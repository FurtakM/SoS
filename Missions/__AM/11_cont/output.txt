// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 16817 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 81390 0 9
// PrepareAmerican ;
  77: CALL 525 0 0
// PrepareArabian ;
  81: CALL 2197 0 0
// MC_Start ( ) ;
  85: CALL 18929 0 0
// Action ;
  89: CALL 7689 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: EMPTY
 227: LIST
 228: LIST
 229: LIST
 230: PUSH
 231: LD_OWVAR 67
 235: ARRAY
 236: ST_TO_ADDR
// powell_warn := false ;
 237: LD_ADDR_EXP 16
 241: PUSH
 242: LD_INT 0
 244: ST_TO_ADDR
// loses_counter := 0 ;
 245: LD_ADDR_EXP 17
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// artifact_oncargo := false ;
 253: LD_ADDR_EXP 14
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 261: LD_ADDR_EXP 18
 265: PUSH
 266: LD_STRING 10_GensherEscape_1
 268: PPUSH
 269: LD_EXP 1
 273: PPUSH
 274: CALL_OW 30
 278: ST_TO_ADDR
// can_kamikazed := false ;
 279: LD_ADDR_EXP 10
 283: PUSH
 284: LD_INT 0
 286: ST_TO_ADDR
// end ;
 287: LD_VAR 0 1
 291: RET
// export function CustomInitMacro ; var i ; begin
 292: LD_INT 0
 294: PPUSH
 295: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 296: LD_ADDR_EXP 73
 300: PUSH
 301: LD_INT 20
 303: PUSH
 304: LD_INT 21
 306: PUSH
 307: LD_INT 22
 309: PUSH
 310: EMPTY
 311: LIST
 312: LIST
 313: LIST
 314: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 315: LD_ADDR_EXP 74
 319: PUSH
 320: LD_INT 28
 322: PUSH
 323: LD_INT 24
 325: PUSH
 326: LD_INT 26
 328: PUSH
 329: EMPTY
 330: LIST
 331: LIST
 332: LIST
 333: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PUSH
 340: LD_INT 8
 342: PUSH
 343: LD_INT 9
 345: PUSH
 346: EMPTY
 347: LIST
 348: LIST
 349: LIST
 350: PUSH
 351: LD_OWVAR 67
 355: ARRAY
 356: PPUSH
 357: LD_INT 3
 359: PPUSH
 360: CALL 40034 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 364: LD_INT 2
 366: PPUSH
 367: LD_INT 6
 369: PUSH
 370: LD_INT 8
 372: PUSH
 373: LD_INT 9
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: LIST
 380: PUSH
 381: LD_OWVAR 67
 385: ARRAY
 386: PPUSH
 387: LD_INT 2
 389: PPUSH
 390: CALL 40034 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 394: LD_INT 3
 396: PPUSH
 397: LD_INT 6
 399: PUSH
 400: LD_INT 7
 402: PUSH
 403: LD_INT 9
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: LIST
 410: PUSH
 411: LD_OWVAR 67
 415: ARRAY
 416: PPUSH
 417: LD_INT 1
 419: PPUSH
 420: CALL 40034 0 3
// for i = 1 to mc_bases do
 424: LD_ADDR_VAR 0 2
 428: PUSH
 429: DOUBLE
 430: LD_INT 1
 432: DEC
 433: ST_TO_ADDR
 434: LD_EXP 49
 438: PUSH
 439: FOR_TO
 440: IFFALSE 464
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 442: LD_VAR 0 2
 446: PPUSH
 447: LD_EXP 42
 451: PUSH
 452: LD_VAR 0 2
 456: ARRAY
 457: PPUSH
 458: CALL 40460 0 2
 462: GO 439
 464: POP
 465: POP
// end ;
 466: LD_VAR 0 1
 470: RET
// function Debuger ; var i ; begin
 471: LD_INT 0
 473: PPUSH
 474: PPUSH
// if not debug then
 475: LD_EXP 1
 479: NOT
 480: IFFALSE 484
// exit ;
 482: GO 520
// game_speed := 5 ;
 484: LD_ADDR_OWVAR 65
 488: PUSH
 489: LD_INT 5
 491: ST_TO_ADDR
// uc_side := 1 ;
 492: LD_ADDR_OWVAR 20
 496: PUSH
 497: LD_INT 1
 499: ST_TO_ADDR
// uc_nation := 1 ;
 500: LD_ADDR_OWVAR 21
 504: PUSH
 505: LD_INT 1
 507: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 508: LD_EXP 35
 512: PPUSH
 513: LD_INT 1
 515: PPUSH
 516: CALL_OW 235
// end ; end_of_file
 520: LD_VAR 0 1
 524: RET
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 525: LD_INT 0
 527: PPUSH
 528: PPUSH
 529: PPUSH
 530: PPUSH
 531: PPUSH
 532: PPUSH
 533: PPUSH
 534: PPUSH
// uc_side := 4 ;
 535: LD_ADDR_OWVAR 20
 539: PUSH
 540: LD_INT 4
 542: ST_TO_ADDR
// uc_nation := 1 ;
 543: LD_ADDR_OWVAR 21
 547: PUSH
 548: LD_INT 1
 550: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 551: LD_ADDR_EXP 29
 555: PUSH
 556: LD_STRING Powell
 558: PPUSH
 559: LD_INT 0
 561: PPUSH
 562: LD_STRING 
 564: PPUSH
 565: CALL 46610 0 3
 569: ST_TO_ADDR
// uc_side := 1 ;
 570: LD_ADDR_OWVAR 20
 574: PUSH
 575: LD_INT 1
 577: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 578: LD_ADDR_EXP 20
 582: PUSH
 583: LD_STRING JMM
 585: PPUSH
 586: LD_EXP 1
 590: NOT
 591: PPUSH
 592: LD_EXP 4
 596: PPUSH
 597: CALL 46610 0 3
 601: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 602: LD_EXP 20
 606: PPUSH
 607: CALL_OW 257
 611: PUSH
 612: LD_INT 4
 614: GREATER
 615: IFFALSE 629
// SetClass ( JMM , 1 ) ;
 617: LD_EXP 20
 621: PPUSH
 622: LD_INT 1
 624: PPUSH
 625: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 629: LD_ADDR_EXP 21
 633: PUSH
 634: LD_STRING Lisa
 636: PPUSH
 637: LD_EXP 1
 641: NOT
 642: PPUSH
 643: LD_EXP 4
 647: PPUSH
 648: CALL 46610 0 3
 652: ST_TO_ADDR
// if not Lisa then
 653: LD_EXP 21
 657: NOT
 658: IFFALSE 673
// Lisa := CreateCharacter ( 10_Lisa ) ;
 660: LD_ADDR_EXP 21
 664: PUSH
 665: LD_STRING 10_Lisa
 667: PPUSH
 668: CALL_OW 34
 672: ST_TO_ADDR
// if not Lisa then
 673: LD_EXP 21
 677: NOT
 678: IFFALSE 693
// Lisa := CreateCharacter ( 09_Lisa ) ;
 680: LD_ADDR_EXP 21
 684: PUSH
 685: LD_STRING 09_Lisa
 687: PPUSH
 688: CALL_OW 34
 692: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 693: LD_ADDR_EXP 30
 697: PUSH
 698: LD_STRING Cornel
 700: PPUSH
 701: LD_EXP 1
 705: NOT
 706: PPUSH
 707: LD_EXP 4
 711: PPUSH
 712: CALL 46610 0 3
 716: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 717: LD_ADDR_EXP 22
 721: PUSH
 722: LD_STRING Donaldson
 724: PPUSH
 725: LD_EXP 1
 729: NOT
 730: PPUSH
 731: LD_EXP 4
 735: PPUSH
 736: CALL 46610 0 3
 740: ST_TO_ADDR
// if not Donaldson then
 741: LD_EXP 22
 745: NOT
 746: IFFALSE 761
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 748: LD_ADDR_EXP 22
 752: PUSH
 753: LD_STRING 10_Donaldson
 755: PPUSH
 756: CALL_OW 34
 760: ST_TO_ADDR
// if not Donaldson then
 761: LD_EXP 22
 765: NOT
 766: IFFALSE 781
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 768: LD_ADDR_EXP 22
 772: PUSH
 773: LD_STRING 09_Donaldson
 775: PPUSH
 776: CALL_OW 34
 780: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 781: LD_ADDR_EXP 23
 785: PUSH
 786: LD_STRING Bobby
 788: PPUSH
 789: LD_EXP 1
 793: NOT
 794: PPUSH
 795: LD_EXP 4
 799: PPUSH
 800: CALL 46610 0 3
 804: ST_TO_ADDR
// if not Bobby then
 805: LD_EXP 23
 809: NOT
 810: IFFALSE 825
// Bobby := CreateCharacter ( 10_Bobby ) ;
 812: LD_ADDR_EXP 23
 816: PUSH
 817: LD_STRING 10_Bobby
 819: PPUSH
 820: CALL_OW 34
 824: ST_TO_ADDR
// if not Bobby then
 825: LD_EXP 23
 829: NOT
 830: IFFALSE 845
// Bobby := CreateCharacter ( 09_Bobby ) ;
 832: LD_ADDR_EXP 23
 836: PUSH
 837: LD_STRING 09_Bobby
 839: PPUSH
 840: CALL_OW 34
 844: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 24
 849: PUSH
 850: LD_STRING Cyrus
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 46610 0 3
 868: ST_TO_ADDR
// if not Cyrus then
 869: LD_EXP 24
 873: NOT
 874: IFFALSE 889
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 876: LD_ADDR_EXP 24
 880: PUSH
 881: LD_STRING 10_Cyrus
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Cyrus then
 889: LD_EXP 24
 893: NOT
 894: IFFALSE 909
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 896: LD_ADDR_EXP 24
 900: PUSH
 901: LD_STRING 09_Cyrus
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 25
 913: PUSH
 914: LD_STRING Denis
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 46610 0 3
 932: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 933: LD_ADDR_EXP 26
 937: PUSH
 938: LD_STRING Brown
 940: PPUSH
 941: LD_EXP 1
 945: NOT
 946: PPUSH
 947: LD_EXP 4
 951: PPUSH
 952: CALL 46610 0 3
 956: ST_TO_ADDR
// if not Brown then
 957: LD_EXP 26
 961: NOT
 962: IFFALSE 977
// Brown := CreateCharacter ( 10_Brown ) ;
 964: LD_ADDR_EXP 26
 968: PUSH
 969: LD_STRING 10_Brown
 971: PPUSH
 972: CALL_OW 34
 976: ST_TO_ADDR
// if not Brown then
 977: LD_EXP 26
 981: NOT
 982: IFFALSE 997
// Brown := CreateCharacter ( 08_Brown ) ;
 984: LD_ADDR_EXP 26
 988: PUSH
 989: LD_STRING 08_Brown
 991: PPUSH
 992: CALL_OW 34
 996: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
 997: LD_ADDR_EXP 27
1001: PUSH
1002: LD_STRING Gladstone
1004: PPUSH
1005: LD_EXP 1
1009: NOT
1010: PPUSH
1011: LD_EXP 4
1015: PPUSH
1016: CALL 46610 0 3
1020: ST_TO_ADDR
// if not Gladstone then
1021: LD_EXP 27
1025: NOT
1026: IFFALSE 1041
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1028: LD_ADDR_EXP 27
1032: PUSH
1033: LD_STRING 10_Gladstone
1035: PPUSH
1036: CALL_OW 34
1040: ST_TO_ADDR
// if not Gladstone then
1041: LD_EXP 27
1045: NOT
1046: IFFALSE 1061
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1048: LD_ADDR_EXP 27
1052: PUSH
1053: LD_STRING 08_Gladstone
1055: PPUSH
1056: CALL_OW 34
1060: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 28
1065: PUSH
1066: LD_STRING Houten
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 46610 0 3
1084: ST_TO_ADDR
// if not Houten then
1085: LD_EXP 28
1089: NOT
1090: IFFALSE 1105
// Houten := CreateCharacter ( 10_Houten ) ;
1092: LD_ADDR_EXP 28
1096: PUSH
1097: LD_STRING 10_Houten
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Houten then
1105: LD_EXP 28
1109: NOT
1110: IFFALSE 1125
// Houten := CreateCharacter ( 09_Houten ) ;
1112: LD_ADDR_EXP 28
1116: PUSH
1117: LD_STRING 09_Houten
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 30
1129: PUSH
1130: LD_STRING Cornell
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 46610 0 3
1148: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1149: LD_ADDR_EXP 31
1153: PUSH
1154: LD_STRING Gary
1156: PPUSH
1157: LD_EXP 1
1161: NOT
1162: PPUSH
1163: LD_EXP 4
1167: PPUSH
1168: CALL 46610 0 3
1172: ST_TO_ADDR
// if not Gary then
1173: LD_EXP 31
1177: NOT
1178: IFFALSE 1193
// Gary := CreateCharacter ( 10_Gary ) ;
1180: LD_ADDR_EXP 31
1184: PUSH
1185: LD_STRING 10_Gary
1187: PPUSH
1188: CALL_OW 34
1192: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1193: LD_ADDR_EXP 32
1197: PUSH
1198: LD_STRING Frank
1200: PPUSH
1201: LD_EXP 1
1205: NOT
1206: PPUSH
1207: LD_EXP 4
1211: PPUSH
1212: CALL 46610 0 3
1216: ST_TO_ADDR
// if not Frank then
1217: LD_EXP 32
1221: NOT
1222: IFFALSE 1237
// Frank := CreateCharacter ( 08_Frank ) ;
1224: LD_ADDR_EXP 32
1228: PUSH
1229: LD_STRING 08_Frank
1231: PPUSH
1232: CALL_OW 34
1236: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1237: LD_ADDR_EXP 33
1241: PUSH
1242: LD_STRING Kikuchi
1244: PPUSH
1245: LD_EXP 1
1249: NOT
1250: PPUSH
1251: LD_EXP 4
1255: PPUSH
1256: CALL 46610 0 3
1260: ST_TO_ADDR
// if not Kikuchi then
1261: LD_EXP 33
1265: NOT
1266: IFFALSE 1281
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1268: LD_ADDR_EXP 33
1272: PUSH
1273: LD_STRING 08_Kikuchi
1275: PPUSH
1276: CALL_OW 34
1280: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1281: LD_ADDR_VAR 0 5
1285: PUSH
1286: LD_EXP 21
1290: PUSH
1291: LD_EXP 22
1295: PUSH
1296: LD_EXP 23
1300: PUSH
1301: LD_EXP 24
1305: PUSH
1306: LD_EXP 25
1310: PUSH
1311: LD_EXP 26
1315: PUSH
1316: LD_EXP 27
1320: PUSH
1321: LD_EXP 28
1325: PUSH
1326: LD_EXP 30
1330: PUSH
1331: LD_EXP 31
1335: PUSH
1336: LD_EXP 32
1340: PUSH
1341: LD_EXP 33
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: ST_TO_ADDR
// tmp := tmp diff 0 ;
1360: LD_ADDR_VAR 0 5
1364: PUSH
1365: LD_VAR 0 5
1369: PUSH
1370: LD_INT 0
1372: DIFF
1373: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1374: LD_ADDR_VAR 0 5
1378: PUSH
1379: LD_VAR 0 5
1383: PUSH
1384: LD_STRING 10_lock
1386: PPUSH
1387: CALL_OW 31
1391: UNION
1392: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1393: LD_ADDR_VAR 0 5
1397: PUSH
1398: LD_VAR 0 5
1402: PUSH
1403: LD_STRING 10c_lock
1405: PPUSH
1406: CALL_OW 31
1410: UNION
1411: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1412: LD_STRING 10_lock
1414: PPUSH
1415: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1419: LD_STRING 10c_lock
1421: PPUSH
1422: CALL_OW 40
// for i in tmp do
1426: LD_ADDR_VAR 0 2
1430: PUSH
1431: LD_VAR 0 5
1435: PUSH
1436: FOR_IN
1437: IFFALSE 1475
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1439: LD_VAR 0 2
1443: PPUSH
1444: CALL_OW 257
1448: PUSH
1449: LD_INT 8
1451: PUSH
1452: LD_INT 2
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: IN
1459: IFFALSE 1473
// SetClass ( i , class_soldier ) ;
1461: LD_VAR 0 2
1465: PPUSH
1466: LD_INT 1
1468: PPUSH
1469: CALL_OW 336
1473: GO 1436
1475: POP
1476: POP
// if tmp < 12 then
1477: LD_VAR 0 5
1481: PUSH
1482: LD_INT 12
1484: LESS
1485: IFFALSE 1579
// begin k := 16 - tmp ;
1487: LD_ADDR_VAR 0 3
1491: PUSH
1492: LD_INT 16
1494: PUSH
1495: LD_VAR 0 5
1499: MINUS
1500: ST_TO_ADDR
// for i = 1 to k do
1501: LD_ADDR_VAR 0 2
1505: PUSH
1506: DOUBLE
1507: LD_INT 1
1509: DEC
1510: ST_TO_ADDR
1511: LD_VAR 0 3
1515: PUSH
1516: FOR_TO
1517: IFFALSE 1577
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1519: LD_INT 0
1521: PPUSH
1522: LD_INT 1
1524: PUSH
1525: LD_INT 1
1527: PUSH
1528: LD_INT 3
1530: PUSH
1531: LD_INT 4
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 1
1542: PPUSH
1543: LD_INT 4
1545: PPUSH
1546: CALL_OW 12
1550: ARRAY
1551: PPUSH
1552: LD_INT 6
1554: PPUSH
1555: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1559: LD_ADDR_VAR 0 5
1563: PUSH
1564: LD_VAR 0 5
1568: PUSH
1569: CALL_OW 44
1573: ADD
1574: ST_TO_ADDR
// end ;
1575: GO 1516
1577: POP
1578: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1579: LD_ADDR_EXP 19
1583: PUSH
1584: LD_STRING 1
1586: PPUSH
1587: LD_INT 12
1589: PPUSH
1590: LD_INT 12
1592: PPUSH
1593: LD_INT -5
1595: PUSH
1596: LD_EXP 20
1600: PUSH
1601: LD_INT -2
1603: PUSH
1604: LD_INT -3
1606: PUSH
1607: LD_INT -5
1609: PUSH
1610: EMPTY
1611: LIST
1612: LIST
1613: LIST
1614: LIST
1615: LIST
1616: PUSH
1617: LD_VAR 0 5
1621: ADD
1622: PUSH
1623: LD_INT -6
1625: PUSH
1626: LD_INT -4
1628: PUSH
1629: LD_EXP 29
1633: PUSH
1634: EMPTY
1635: LIST
1636: LIST
1637: LIST
1638: ADD
1639: PPUSH
1640: LD_INT 1
1642: PUSH
1643: LD_INT 4
1645: PUSH
1646: EMPTY
1647: LIST
1648: LIST
1649: PUSH
1650: LD_INT 3
1652: PUSH
1653: LD_INT 0
1655: PUSH
1656: LD_INT 5
1658: PUSH
1659: EMPTY
1660: LIST
1661: LIST
1662: LIST
1663: PUSH
1664: LD_INT 4
1666: PUSH
1667: LD_INT 0
1669: PUSH
1670: LD_INT 3
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: PUSH
1678: LD_INT 5
1680: PUSH
1681: LD_INT 0
1683: PUSH
1684: LD_INT 2
1686: PUSH
1687: EMPTY
1688: LIST
1689: LIST
1690: LIST
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: PPUSH
1698: CALL_OW 42
1702: ST_TO_ADDR
// others := tmp diff selected ;
1703: LD_ADDR_VAR 0 8
1707: PUSH
1708: LD_VAR 0 5
1712: PUSH
1713: LD_EXP 19
1717: DIFF
1718: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1719: LD_ADDR_VAR 0 8
1723: PUSH
1724: LD_VAR 0 8
1728: PUSH
1729: LD_EXP 21
1733: PUSH
1734: LD_EXP 22
1738: PUSH
1739: LD_EXP 23
1743: PUSH
1744: LD_EXP 24
1748: PUSH
1749: LD_EXP 25
1753: PUSH
1754: LD_EXP 26
1758: PUSH
1759: LD_EXP 27
1763: PUSH
1764: LD_EXP 28
1768: PUSH
1769: LD_EXP 30
1773: PUSH
1774: LD_EXP 31
1778: PUSH
1779: LD_EXP 32
1783: PUSH
1784: LD_EXP 33
1788: PUSH
1789: EMPTY
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: LIST
1796: LIST
1797: LIST
1798: LIST
1799: LIST
1800: LIST
1801: LIST
1802: DIFF
1803: ST_TO_ADDR
// if others then
1804: LD_VAR 0 8
1808: IFFALSE 1822
// SaveCharacters ( others , 11_others ) ;
1810: LD_VAR 0 8
1814: PPUSH
1815: LD_STRING 11_others
1817: PPUSH
1818: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1822: LD_ADDR_VAR 0 6
1826: PUSH
1827: LD_INT 3
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 1
1835: PUSH
1836: LD_INT 4
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 2
1850: PUSH
1851: LD_INT 1
1853: PUSH
1854: LD_INT 5
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: PUSH
1863: LD_INT 4
1865: PUSH
1866: LD_INT 1
1868: PUSH
1869: LD_INT 1
1871: PUSH
1872: LD_INT 5
1874: PUSH
1875: EMPTY
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: PUSH
1881: LD_INT 2
1883: PUSH
1884: LD_INT 1
1886: PUSH
1887: LD_INT 1
1889: PUSH
1890: LD_INT 7
1892: PUSH
1893: EMPTY
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: PUSH
1899: LD_INT 3
1901: PUSH
1902: LD_INT 2
1904: PUSH
1905: LD_INT 1
1907: PUSH
1908: LD_INT 7
1910: PUSH
1911: EMPTY
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: PUSH
1917: EMPTY
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: ST_TO_ADDR
// for i in JMM ^ selected do
1924: LD_ADDR_VAR 0 2
1928: PUSH
1929: LD_EXP 20
1933: PUSH
1934: LD_EXP 19
1938: ADD
1939: PUSH
1940: FOR_IN
1941: IFFALSE 2130
// begin if GetClass ( i ) = 3 then
1943: LD_VAR 0 2
1947: PPUSH
1948: CALL_OW 257
1952: PUSH
1953: LD_INT 3
1955: EQUAL
1956: IFFALSE 2113
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1958: LD_ADDR_OWVAR 37
1962: PUSH
1963: LD_VAR 0 6
1967: PUSH
1968: LD_INT 1
1970: ARRAY
1971: PUSH
1972: LD_INT 1
1974: ARRAY
1975: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
1976: LD_ADDR_OWVAR 39
1980: PUSH
1981: LD_VAR 0 6
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PUSH
1990: LD_INT 2
1992: ARRAY
1993: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
1994: LD_ADDR_OWVAR 38
1998: PUSH
1999: LD_VAR 0 6
2003: PUSH
2004: LD_INT 1
2006: ARRAY
2007: PUSH
2008: LD_INT 3
2010: ARRAY
2011: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2012: LD_ADDR_OWVAR 40
2016: PUSH
2017: LD_VAR 0 6
2021: PUSH
2022: LD_INT 1
2024: ARRAY
2025: PUSH
2026: LD_INT 4
2028: ARRAY
2029: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2030: LD_ADDR_VAR 0 6
2034: PUSH
2035: LD_VAR 0 6
2039: PPUSH
2040: LD_INT 1
2042: PPUSH
2043: CALL_OW 3
2047: ST_TO_ADDR
// veh := CreateVehicle ;
2048: LD_ADDR_VAR 0 7
2052: PUSH
2053: CALL_OW 45
2057: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2058: LD_VAR 0 7
2062: PPUSH
2063: LD_INT 8
2065: PPUSH
2066: LD_INT 0
2068: PPUSH
2069: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2073: LD_VAR 0 2
2077: PPUSH
2078: LD_VAR 0 7
2082: PPUSH
2083: CALL_OW 52
// if i = JMM then
2087: LD_VAR 0 2
2091: PUSH
2092: LD_EXP 20
2096: EQUAL
2097: IFFALSE 2111
// SetMark ( veh , 1 ) ;
2099: LD_VAR 0 7
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: CALL_OW 242
// end else
2111: GO 2128
// PlaceUnitArea ( i , am_hum_start , false ) ;
2113: LD_VAR 0 2
2117: PPUSH
2118: LD_INT 9
2120: PPUSH
2121: LD_INT 0
2123: PPUSH
2124: CALL_OW 49
// end ;
2128: GO 1940
2130: POP
2131: POP
// vc_chassis := us_medium_tracked ;
2132: LD_ADDR_OWVAR 37
2136: PUSH
2137: LD_INT 3
2139: ST_TO_ADDR
// vc_engine := engine_solar ;
2140: LD_ADDR_OWVAR 39
2144: PUSH
2145: LD_INT 2
2147: ST_TO_ADDR
// vc_control := control_computer ;
2148: LD_ADDR_OWVAR 38
2152: PUSH
2153: LD_INT 3
2155: ST_TO_ADDR
// vc_weapon := us_radar ;
2156: LD_ADDR_OWVAR 40
2160: PUSH
2161: LD_INT 11
2163: ST_TO_ADDR
// veh := CreateVehicle ;
2164: LD_ADDR_VAR 0 7
2168: PUSH
2169: CALL_OW 45
2173: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2174: LD_VAR 0 7
2178: PPUSH
2179: LD_INT 87
2181: PPUSH
2182: LD_INT 142
2184: PPUSH
2185: LD_INT 0
2187: PPUSH
2188: CALL_OW 48
// end ; end_of_file
2192: LD_VAR 0 1
2196: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
2201: PPUSH
2202: PPUSH
2203: PPUSH
2204: PPUSH
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2205: LD_ADDR_VAR 0 5
2209: PUSH
2210: LD_INT 5
2212: PUSH
2213: LD_INT 6
2215: PUSH
2216: LD_INT 7
2218: PUSH
2219: EMPTY
2220: LIST
2221: LIST
2222: LIST
2223: PUSH
2224: LD_OWVAR 67
2228: ARRAY
2229: ST_TO_ADDR
// uc_side := 2 ;
2230: LD_ADDR_OWVAR 20
2234: PUSH
2235: LD_INT 2
2237: ST_TO_ADDR
// uc_nation := 2 ;
2238: LD_ADDR_OWVAR 21
2242: PUSH
2243: LD_INT 2
2245: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2246: LD_ADDR_OWVAR 37
2250: PUSH
2251: LD_INT 14
2253: ST_TO_ADDR
// vc_engine := engine_siberite ;
2254: LD_ADDR_OWVAR 39
2258: PUSH
2259: LD_INT 3
2261: ST_TO_ADDR
// vc_control := control_manual ;
2262: LD_ADDR_OWVAR 38
2266: PUSH
2267: LD_INT 1
2269: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2270: LD_ADDR_OWVAR 40
2274: PUSH
2275: LD_INT 31
2277: ST_TO_ADDR
// for i = 1 to 3 do
2278: LD_ADDR_VAR 0 2
2282: PUSH
2283: DOUBLE
2284: LD_INT 1
2286: DEC
2287: ST_TO_ADDR
2288: LD_INT 3
2290: PUSH
2291: FOR_TO
2292: IFFALSE 2376
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2294: LD_INT 0
2296: PPUSH
2297: LD_INT 3
2299: PPUSH
2300: LD_VAR 0 5
2304: PPUSH
2305: CALL_OW 380
// un := CreateVehicle ;
2309: LD_ADDR_VAR 0 4
2313: PUSH
2314: CALL_OW 45
2318: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2319: LD_VAR 0 4
2323: PPUSH
2324: LD_INT 0
2326: PPUSH
2327: LD_INT 5
2329: PPUSH
2330: CALL_OW 12
2334: PPUSH
2335: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2339: LD_VAR 0 4
2343: PPUSH
2344: LD_INT 156
2346: PPUSH
2347: LD_INT 15
2349: PPUSH
2350: LD_INT 6
2352: PPUSH
2353: LD_INT 0
2355: PPUSH
2356: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2360: CALL_OW 44
2364: PPUSH
2365: LD_VAR 0 4
2369: PPUSH
2370: CALL_OW 52
// end ;
2374: GO 2291
2376: POP
2377: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ - 1 , 5 , - 1 , 4 ] ) ;
2378: LD_ADDR_EXP 36
2382: PUSH
2383: LD_INT 94
2385: PPUSH
2386: LD_INT 28
2388: PPUSH
2389: LD_STRING dammam
2391: PPUSH
2392: LD_VAR 0 5
2396: PPUSH
2397: LD_INT 10000
2399: PUSH
2400: LD_INT 1000
2402: PUSH
2403: LD_INT 300
2405: PUSH
2406: EMPTY
2407: LIST
2408: LIST
2409: LIST
2410: PPUSH
2411: LD_INT 1
2413: NEG
2414: PUSH
2415: LD_INT 5
2417: PUSH
2418: LD_INT 1
2420: NEG
2421: PUSH
2422: LD_INT 4
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: LIST
2429: LIST
2430: PPUSH
2431: CALL 56985 0 6
2435: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ - 1 , 4 , 2 , 0 ] ) ;
2436: LD_ADDR_EXP 36
2440: PUSH
2441: LD_EXP 36
2445: PUSH
2446: LD_INT 122
2448: PPUSH
2449: LD_INT 25
2451: PPUSH
2452: LD_STRING 
2454: PPUSH
2455: LD_VAR 0 5
2459: PPUSH
2460: LD_INT 500
2462: PUSH
2463: LD_INT 60
2465: PUSH
2466: LD_INT 0
2468: PUSH
2469: EMPTY
2470: LIST
2471: LIST
2472: LIST
2473: PPUSH
2474: LD_INT 1
2476: NEG
2477: PUSH
2478: LD_INT 4
2480: PUSH
2481: LD_INT 2
2483: PUSH
2484: LD_INT 0
2486: PUSH
2487: EMPTY
2488: LIST
2489: LIST
2490: LIST
2491: LIST
2492: PPUSH
2493: CALL 56985 0 6
2497: UNION
2498: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ - 1 , 5 , 3 , 2 ] ) ;
2499: LD_ADDR_EXP 34
2503: PUSH
2504: LD_INT 45
2506: PPUSH
2507: LD_INT 24
2509: PPUSH
2510: LD_STRING jeddah
2512: PPUSH
2513: LD_VAR 0 5
2517: PPUSH
2518: LD_INT 700
2520: PUSH
2521: LD_INT 300
2523: PUSH
2524: LD_INT 10
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: LIST
2531: PPUSH
2532: LD_INT 1
2534: NEG
2535: PUSH
2536: LD_INT 5
2538: PUSH
2539: LD_INT 3
2541: PUSH
2542: LD_INT 2
2544: PUSH
2545: EMPTY
2546: LIST
2547: LIST
2548: LIST
2549: LIST
2550: PPUSH
2551: CALL 56985 0 6
2555: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2556: LD_ADDR_EXP 35
2560: PUSH
2561: LD_INT 7
2563: PPUSH
2564: LD_INT 27
2566: PPUSH
2567: LD_STRING riyadh
2569: PPUSH
2570: LD_VAR 0 5
2574: PPUSH
2575: LD_INT 500
2577: PUSH
2578: LD_INT 60
2580: PUSH
2581: LD_INT 0
2583: PUSH
2584: EMPTY
2585: LIST
2586: LIST
2587: LIST
2588: PPUSH
2589: LD_INT 4
2591: PUSH
2592: LD_INT 2
2594: PUSH
2595: LD_INT 3
2597: PUSH
2598: LD_INT 1
2600: PUSH
2601: EMPTY
2602: LIST
2603: LIST
2604: LIST
2605: LIST
2606: PPUSH
2607: CALL 56985 0 6
2611: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ - 1 , 3 , 3 , 2 ] ) ;
2612: LD_ADDR_EXP 38
2616: PUSH
2617: LD_INT 204
2619: PPUSH
2620: LD_INT 26
2622: PPUSH
2623: LD_STRING 
2625: PPUSH
2626: LD_VAR 0 5
2630: PPUSH
2631: LD_INT 500
2633: PUSH
2634: LD_INT 50
2636: PUSH
2637: LD_INT 0
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: LIST
2644: PPUSH
2645: LD_INT 1
2647: NEG
2648: PUSH
2649: LD_INT 3
2651: PUSH
2652: LD_INT 3
2654: PUSH
2655: LD_INT 2
2657: PUSH
2658: EMPTY
2659: LIST
2660: LIST
2661: LIST
2662: LIST
2663: PPUSH
2664: CALL 56985 0 6
2668: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2669: LD_ADDR_EXP 49
2673: PUSH
2674: LD_EXP 36
2678: PUSH
2679: LD_EXP 34
2683: PUSH
2684: LD_EXP 38
2688: PUSH
2689: EMPTY
2690: LIST
2691: LIST
2692: LIST
2693: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2694: LD_ADDR_VAR 0 2
2698: PUSH
2699: LD_INT 22
2701: PUSH
2702: LD_INT 2
2704: PUSH
2705: EMPTY
2706: LIST
2707: LIST
2708: PUSH
2709: LD_INT 30
2711: PUSH
2712: LD_INT 31
2714: PUSH
2715: EMPTY
2716: LIST
2717: LIST
2718: PUSH
2719: LD_INT 58
2721: PUSH
2722: EMPTY
2723: LIST
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: PPUSH
2730: CALL_OW 69
2734: PUSH
2735: FOR_IN
2736: IFFALSE 2861
// begin if GetBase ( i ) then
2738: LD_VAR 0 2
2742: PPUSH
2743: CALL_OW 274
2747: IFFALSE 2751
// continue ;
2749: GO 2735
// d := GetDir ( i ) ;
2751: LD_ADDR_VAR 0 3
2755: PUSH
2756: LD_VAR 0 2
2760: PPUSH
2761: CALL_OW 254
2765: ST_TO_ADDR
// if d < 3 then
2766: LD_VAR 0 3
2770: PUSH
2771: LD_INT 3
2773: LESS
2774: IFFALSE 2792
// d := d + 3 else
2776: LD_ADDR_VAR 0 3
2780: PUSH
2781: LD_VAR 0 3
2785: PUSH
2786: LD_INT 3
2788: PLUS
2789: ST_TO_ADDR
2790: GO 2806
// d := d - 3 ;
2792: LD_ADDR_VAR 0 3
2796: PUSH
2797: LD_VAR 0 3
2801: PUSH
2802: LD_INT 3
2804: MINUS
2805: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
2806: LD_INT 0
2808: PPUSH
2809: LD_INT 8
2811: PPUSH
2812: LD_VAR 0 5
2816: PPUSH
2817: CALL_OW 380
// un := CreateHuman ;
2821: LD_ADDR_VAR 0 4
2825: PUSH
2826: CALL_OW 44
2830: ST_TO_ADDR
// SetDir ( un , d ) ;
2831: LD_VAR 0 4
2835: PPUSH
2836: LD_VAR 0 3
2840: PPUSH
2841: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
2845: LD_VAR 0 4
2849: PPUSH
2850: LD_VAR 0 2
2854: PPUSH
2855: CALL_OW 52
// end ;
2859: GO 2735
2861: POP
2862: POP
// if Difficulty > 1 then
2863: LD_OWVAR 67
2867: PUSH
2868: LD_INT 1
2870: GREATER
2871: IFFALSE 3242
// begin ar_kamikadze := [ ] ;
2873: LD_ADDR_EXP 41
2877: PUSH
2878: EMPTY
2879: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
2880: LD_INT 0
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: LD_VAR 0 5
2890: PPUSH
2891: CALL_OW 380
// un := CreateHuman ;
2895: LD_ADDR_VAR 0 4
2899: PUSH
2900: CALL_OW 44
2904: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2905: LD_VAR 0 4
2909: PPUSH
2910: LD_INT 3
2912: PPUSH
2913: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
2917: LD_VAR 0 4
2921: PPUSH
2922: LD_INT 23
2924: PPUSH
2925: LD_INT 44
2927: PPUSH
2928: LD_INT 0
2930: PPUSH
2931: CALL_OW 48
// ComCrawl ( un ) ;
2935: LD_VAR 0 4
2939: PPUSH
2940: CALL_OW 137
// un := CreateHuman ;
2944: LD_ADDR_VAR 0 4
2948: PUSH
2949: CALL_OW 44
2953: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2954: LD_VAR 0 4
2958: PPUSH
2959: LD_INT 3
2961: PPUSH
2962: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
2966: LD_VAR 0 4
2970: PPUSH
2971: LD_INT 30
2973: PPUSH
2974: LD_INT 39
2976: PPUSH
2977: LD_INT 0
2979: PPUSH
2980: CALL_OW 48
// ComCrawl ( un ) ;
2984: LD_VAR 0 4
2988: PPUSH
2989: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
2993: LD_INT 0
2995: PPUSH
2996: LD_INT 17
2998: PPUSH
2999: LD_VAR 0 5
3003: PPUSH
3004: CALL_OW 380
// un := CreateHuman ;
3008: LD_ADDR_VAR 0 4
3012: PUSH
3013: CALL_OW 44
3017: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3018: LD_VAR 0 4
3022: PPUSH
3023: LD_INT 3
3025: PPUSH
3026: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3030: LD_VAR 0 4
3034: PPUSH
3035: LD_INT 45
3037: PPUSH
3038: LD_INT 86
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComHold ( un ) ;
3048: LD_VAR 0 4
3052: PPUSH
3053: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3057: LD_ADDR_EXP 41
3061: PUSH
3062: LD_EXP 41
3066: PPUSH
3067: LD_EXP 41
3071: PUSH
3072: LD_INT 1
3074: PLUS
3075: PPUSH
3076: LD_VAR 0 4
3080: PPUSH
3081: CALL_OW 1
3085: ST_TO_ADDR
// un := CreateHuman ;
3086: LD_ADDR_VAR 0 4
3090: PUSH
3091: CALL_OW 44
3095: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3096: LD_VAR 0 4
3100: PPUSH
3101: LD_INT 3
3103: PPUSH
3104: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3108: LD_VAR 0 4
3112: PPUSH
3113: LD_INT 60
3115: PPUSH
3116: LD_INT 85
3118: PPUSH
3119: LD_INT 0
3121: PPUSH
3122: CALL_OW 48
// ComHold ( un ) ;
3126: LD_VAR 0 4
3130: PPUSH
3131: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3135: LD_ADDR_EXP 41
3139: PUSH
3140: LD_EXP 41
3144: PPUSH
3145: LD_EXP 41
3149: PUSH
3150: LD_INT 1
3152: PLUS
3153: PPUSH
3154: LD_VAR 0 4
3158: PPUSH
3159: CALL_OW 1
3163: ST_TO_ADDR
// un := CreateHuman ;
3164: LD_ADDR_VAR 0 4
3168: PUSH
3169: CALL_OW 44
3173: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3174: LD_VAR 0 4
3178: PPUSH
3179: LD_INT 3
3181: PPUSH
3182: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3186: LD_VAR 0 4
3190: PPUSH
3191: LD_INT 222
3193: PPUSH
3194: LD_INT 166
3196: PPUSH
3197: LD_INT 0
3199: PPUSH
3200: CALL_OW 48
// ComHold ( un ) ;
3204: LD_VAR 0 4
3208: PPUSH
3209: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3213: LD_ADDR_EXP 41
3217: PUSH
3218: LD_EXP 41
3222: PPUSH
3223: LD_EXP 41
3227: PUSH
3228: LD_INT 1
3230: PLUS
3231: PPUSH
3232: LD_VAR 0 4
3236: PPUSH
3237: CALL_OW 1
3241: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3242: LD_ADDR_EXP 39
3246: PUSH
3247: EMPTY
3248: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3249: LD_INT 1
3251: PPUSH
3252: LD_INT 1
3254: PPUSH
3255: LD_VAR 0 5
3259: PPUSH
3260: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3264: LD_ADDR_OWVAR 26
3268: PUSH
3269: LD_STRING Pavel Grigorovic
3271: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3272: LD_ADDR_OWVAR 33
3276: PUSH
3277: LD_STRING SecondCharsGal
3279: ST_TO_ADDR
// hc_face_number := 4 ;
3280: LD_ADDR_OWVAR 34
3284: PUSH
3285: LD_INT 4
3287: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3288: LD_ADDR_EXP 39
3292: PUSH
3293: LD_EXP 39
3297: PPUSH
3298: LD_INT 1
3300: PPUSH
3301: CALL_OW 44
3305: PPUSH
3306: CALL_OW 1
3310: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3311: LD_INT 2
3313: PPUSH
3314: LD_INT 4
3316: PPUSH
3317: LD_VAR 0 5
3321: PPUSH
3322: CALL_OW 380
// hc_name := Lucy Sebel ;
3326: LD_ADDR_OWVAR 26
3330: PUSH
3331: LD_STRING Lucy Sebel
3333: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3334: LD_ADDR_OWVAR 33
3338: PUSH
3339: LD_STRING SecondCharsGal
3341: ST_TO_ADDR
// hc_face_number := 15 ;
3342: LD_ADDR_OWVAR 34
3346: PUSH
3347: LD_INT 15
3349: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3350: LD_ADDR_EXP 39
3354: PUSH
3355: LD_EXP 39
3359: PPUSH
3360: LD_INT 2
3362: PPUSH
3363: CALL_OW 44
3367: PPUSH
3368: CALL_OW 1
3372: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3373: LD_INT 2
3375: PPUSH
3376: LD_INT 4
3378: PPUSH
3379: LD_VAR 0 5
3383: PPUSH
3384: CALL_OW 380
// hc_gallery :=  ;
3388: LD_ADDR_OWVAR 33
3392: PUSH
3393: LD_STRING 
3395: ST_TO_ADDR
// hc_name :=  ;
3396: LD_ADDR_OWVAR 26
3400: PUSH
3401: LD_STRING 
3403: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3404: LD_ADDR_EXP 39
3408: PUSH
3409: LD_EXP 39
3413: PPUSH
3414: LD_INT 3
3416: PPUSH
3417: CALL_OW 44
3421: PPUSH
3422: CALL_OW 1
3426: ST_TO_ADDR
// hc_sex := sex_male ;
3427: LD_ADDR_OWVAR 27
3431: PUSH
3432: LD_INT 1
3434: ST_TO_ADDR
// hc_class = 11 ;
3435: LD_ADDR_OWVAR 28
3439: PUSH
3440: LD_INT 11
3442: ST_TO_ADDR
// hc_gallery = sandar ;
3443: LD_ADDR_OWVAR 33
3447: PUSH
3448: LD_STRING sandar
3450: ST_TO_ADDR
// hc_face_number = 33 ;
3451: LD_ADDR_OWVAR 34
3455: PUSH
3456: LD_INT 33
3458: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3459: LD_ADDR_OWVAR 26
3463: PUSH
3464: LD_STRING Thabit Muhair Saliba
3466: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3467: LD_ADDR_OWVAR 31
3471: PUSH
3472: LD_INT 0
3474: PUSH
3475: LD_INT 0
3477: PUSH
3478: LD_INT 0
3480: PUSH
3481: LD_INT 0
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: LIST
3488: LIST
3489: ST_TO_ADDR
// Saliba = CreateHuman ;
3490: LD_ADDR_EXP 43
3494: PUSH
3495: CALL_OW 44
3499: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3500: LD_EXP 43
3504: PPUSH
3505: LD_INT 7
3507: PPUSH
3508: CALL_OW 52
// if gensher_active then
3512: LD_EXP 18
3516: IFFALSE 3543
// begin Gensher = NewCharacter ( Dietrich ) ;
3518: LD_ADDR_EXP 44
3522: PUSH
3523: LD_STRING Dietrich
3525: PPUSH
3526: CALL_OW 25
3530: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3531: LD_EXP 44
3535: PPUSH
3536: LD_INT 94
3538: PPUSH
3539: CALL_OW 52
// end ; InitHc ;
3543: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3547: LD_ADDR_EXP 40
3551: PUSH
3552: EMPTY
3553: ST_TO_ADDR
// for i = 1 to 5 do
3554: LD_ADDR_VAR 0 2
3558: PUSH
3559: DOUBLE
3560: LD_INT 1
3562: DEC
3563: ST_TO_ADDR
3564: LD_INT 5
3566: PUSH
3567: FOR_TO
3568: IFFALSE 3740
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3570: LD_INT 13
3572: PUSH
3573: LD_INT 14
3575: PUSH
3576: EMPTY
3577: LIST
3578: LIST
3579: PUSH
3580: LD_INT 1
3582: PPUSH
3583: LD_INT 2
3585: PPUSH
3586: CALL_OW 12
3590: ARRAY
3591: PPUSH
3592: LD_INT 1
3594: PUSH
3595: LD_INT 2
3597: PUSH
3598: EMPTY
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 2
3607: PPUSH
3608: CALL_OW 12
3612: ARRAY
3613: PPUSH
3614: LD_INT 1
3616: PPUSH
3617: LD_INT 25
3619: PUSH
3620: LD_INT 27
3622: PUSH
3623: LD_INT 26
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: LIST
3630: PUSH
3631: LD_INT 1
3633: PPUSH
3634: LD_INT 3
3636: PPUSH
3637: CALL_OW 12
3641: ARRAY
3642: PPUSH
3643: LD_INT 60
3645: PPUSH
3646: LD_INT 100
3648: PPUSH
3649: CALL_OW 12
3653: PPUSH
3654: CALL 53576 0 5
// un := CreateVehicle ;
3658: LD_ADDR_VAR 0 4
3662: PUSH
3663: CALL_OW 45
3667: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3668: LD_ADDR_EXP 40
3672: PUSH
3673: LD_EXP 40
3677: PPUSH
3678: LD_EXP 40
3682: PUSH
3683: LD_INT 1
3685: PLUS
3686: PPUSH
3687: LD_VAR 0 4
3691: PPUSH
3692: CALL_OW 1
3696: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3697: LD_VAR 0 4
3701: PPUSH
3702: LD_INT 0
3704: PPUSH
3705: LD_INT 5
3707: PPUSH
3708: CALL_OW 12
3712: PPUSH
3713: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
3717: LD_VAR 0 4
3721: PPUSH
3722: LD_INT 124
3724: PPUSH
3725: LD_INT 141
3727: PPUSH
3728: LD_INT 8
3730: PPUSH
3731: LD_INT 0
3733: PPUSH
3734: CALL_OW 50
// end ;
3738: GO 3567
3740: POP
3741: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3742: LD_ADDR_EXP 42
3746: PUSH
3747: EMPTY
3748: PUSH
3749: EMPTY
3750: PUSH
3751: EMPTY
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: LIST
3757: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3758: LD_ADDR_VAR 0 3
3762: PUSH
3763: DOUBLE
3764: LD_INT 1
3766: DEC
3767: ST_TO_ADDR
3768: LD_INT 3
3770: PUSH
3771: LD_INT 3
3773: PUSH
3774: LD_INT 4
3776: PUSH
3777: EMPTY
3778: LIST
3779: LIST
3780: LIST
3781: PUSH
3782: LD_OWVAR 67
3786: ARRAY
3787: PUSH
3788: FOR_TO
3789: IFFALSE 4003
// for i = 1 to 3 do
3791: LD_ADDR_VAR 0 2
3795: PUSH
3796: DOUBLE
3797: LD_INT 1
3799: DEC
3800: ST_TO_ADDR
3801: LD_INT 3
3803: PUSH
3804: FOR_TO
3805: IFFALSE 3999
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
3807: LD_INT 14
3809: PPUSH
3810: LD_INT 3
3812: PUSH
3813: LD_INT 2
3815: PUSH
3816: EMPTY
3817: LIST
3818: LIST
3819: PUSH
3820: LD_INT 1
3822: PPUSH
3823: LD_INT 2
3825: PPUSH
3826: CALL_OW 12
3830: ARRAY
3831: PPUSH
3832: LD_INT 1
3834: PUSH
3835: LD_INT 5
3837: PUSH
3838: EMPTY
3839: LIST
3840: LIST
3841: PUSH
3842: LD_INT 1
3844: PPUSH
3845: LD_INT 2
3847: PPUSH
3848: CALL_OW 12
3852: ARRAY
3853: PPUSH
3854: LD_INT 25
3856: PUSH
3857: LD_INT 27
3859: PUSH
3860: LD_INT 26
3862: PUSH
3863: LD_INT 28
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: PUSH
3872: LD_INT 1
3874: PPUSH
3875: LD_INT 4
3877: PPUSH
3878: CALL_OW 12
3882: ARRAY
3883: PPUSH
3884: LD_INT 100
3886: PPUSH
3887: CALL 53576 0 5
// un := CreateVehicle ;
3891: LD_ADDR_VAR 0 4
3895: PUSH
3896: CALL_OW 45
3900: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
3901: LD_ADDR_EXP 42
3905: PUSH
3906: LD_EXP 42
3910: PPUSH
3911: LD_VAR 0 2
3915: PUSH
3916: LD_EXP 42
3920: PUSH
3921: LD_VAR 0 2
3925: ARRAY
3926: PUSH
3927: LD_INT 1
3929: PLUS
3930: PUSH
3931: EMPTY
3932: LIST
3933: LIST
3934: PPUSH
3935: LD_VAR 0 4
3939: PPUSH
3940: CALL 53698 0 3
3944: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3945: LD_VAR 0 4
3949: PPUSH
3950: LD_INT 0
3952: PPUSH
3953: LD_INT 5
3955: PPUSH
3956: CALL_OW 12
3960: PPUSH
3961: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
3965: LD_VAR 0 4
3969: PPUSH
3970: LD_INT 20
3972: PUSH
3973: LD_INT 21
3975: PUSH
3976: LD_INT 22
3978: PUSH
3979: EMPTY
3980: LIST
3981: LIST
3982: LIST
3983: PUSH
3984: LD_VAR 0 2
3988: ARRAY
3989: PPUSH
3990: LD_INT 0
3992: PPUSH
3993: CALL_OW 49
// end ;
3997: GO 3804
3999: POP
4000: POP
4001: GO 3788
4003: POP
4004: POP
// InitHc ;
4005: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4009: LD_INT 4
4011: PPUSH
4012: LD_INT 5
4014: PPUSH
4015: LD_INT 10
4017: PPUSH
4018: LD_INT 5
4020: PPUSH
4021: LD_INT 0
4023: PPUSH
4024: CALL_OW 58
// end ;
4028: LD_VAR 0 1
4032: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4033: LD_EXP 41
4037: IFFALSE 4111
4039: GO 4041
4041: DISABLE
4042: LD_INT 0
4044: PPUSH
// begin enable ;
4045: ENABLE
// for i in ar_kamikadze do
4046: LD_ADDR_VAR 0 1
4050: PUSH
4051: LD_EXP 41
4055: PUSH
4056: FOR_IN
4057: IFFALSE 4109
// if See ( 1 , i ) then
4059: LD_INT 1
4061: PPUSH
4062: LD_VAR 0 1
4066: PPUSH
4067: CALL_OW 292
4071: IFFALSE 4107
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4073: LD_VAR 0 1
4077: PPUSH
4078: LD_INT 81
4080: PUSH
4081: LD_INT 2
4083: PUSH
4084: EMPTY
4085: LIST
4086: LIST
4087: PPUSH
4088: CALL_OW 69
4092: PPUSH
4093: LD_VAR 0 1
4097: PPUSH
4098: CALL_OW 74
4102: PPUSH
4103: CALL_OW 115
4107: GO 4056
4109: POP
4110: POP
// end ;
4111: PPOPN 1
4113: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4114: LD_EXP 13
4118: IFFALSE 4435
4120: GO 4122
4122: DISABLE
4123: LD_INT 0
4125: PPUSH
4126: PPUSH
4127: PPUSH
4128: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4129: LD_INT 35
4131: PPUSH
4132: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4136: LD_INT 1
4138: PPUSH
4139: CALL 40748 0 1
4143: PUSH
4144: LD_INT 0
4146: EQUAL
4147: IFFALSE 4129
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4149: LD_INT 1
4151: PPUSH
4152: LD_INT 14
4154: PUSH
4155: LD_INT 3
4157: PUSH
4158: LD_INT 2
4160: PUSH
4161: LD_INT 32
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: LIST
4168: LIST
4169: PUSH
4170: EMPTY
4171: LIST
4172: PPUSH
4173: CALL 40352 0 2
// repeat wait ( 0 0$1 ) ;
4177: LD_INT 35
4179: PPUSH
4180: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4184: LD_EXP 68
4188: PUSH
4189: LD_INT 1
4191: ARRAY
4192: PPUSH
4193: LD_INT 33
4195: PUSH
4196: LD_INT 2
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: PUSH
4203: LD_INT 34
4205: PUSH
4206: LD_INT 32
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PPUSH
4217: CALL_OW 72
4221: IFFALSE 4177
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4223: LD_ADDR_VAR 0 2
4227: PUSH
4228: LD_EXP 68
4232: PUSH
4233: LD_INT 1
4235: ARRAY
4236: PPUSH
4237: LD_INT 33
4239: PUSH
4240: LD_INT 2
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: PUSH
4247: LD_INT 34
4249: PUSH
4250: LD_INT 32
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: PUSH
4257: EMPTY
4258: LIST
4259: LIST
4260: PPUSH
4261: CALL_OW 72
4265: PUSH
4266: LD_INT 1
4268: ARRAY
4269: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4270: LD_ADDR_VAR 0 4
4274: PUSH
4275: LD_INT 5
4277: PPUSH
4278: CALL_OW 469
4282: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4283: LD_INT 35
4285: PPUSH
4286: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4290: LD_ADDR_VAR 0 4
4294: PUSH
4295: LD_INT 5
4297: PPUSH
4298: CALL_OW 469
4302: ST_TO_ADDR
// tmp := 100 ;
4303: LD_ADDR_VAR 0 3
4307: PUSH
4308: LD_INT 100
4310: ST_TO_ADDR
// if pos then
4311: LD_VAR 0 4
4315: IFFALSE 4355
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4317: LD_ADDR_VAR 0 3
4321: PUSH
4322: LD_INT 2
4324: PPUSH
4325: LD_VAR 0 4
4329: PUSH
4330: LD_INT 1
4332: ARRAY
4333: PPUSH
4334: LD_VAR 0 4
4338: PUSH
4339: LD_INT 2
4341: ARRAY
4342: PPUSH
4343: LD_INT 20
4345: PPUSH
4346: CALL 54594 0 4
4350: PUSH
4351: LD_INT 4
4353: ARRAY
4354: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4355: LD_VAR 0 4
4359: PUSH
4360: LD_EXP 14
4364: NOT
4365: AND
4366: PUSH
4367: LD_VAR 0 3
4371: PUSH
4372: LD_INT 10
4374: LESS
4375: AND
4376: IFFALSE 4283
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4378: LD_VAR 0 2
4382: PPUSH
4383: LD_VAR 0 4
4387: PUSH
4388: LD_INT 1
4390: ARRAY
4391: PPUSH
4392: LD_VAR 0 4
4396: PUSH
4397: LD_INT 2
4399: ARRAY
4400: PPUSH
4401: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4405: LD_VAR 0 2
4409: PPUSH
4410: LD_INT 198
4412: PPUSH
4413: LD_INT 113
4415: PPUSH
4416: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4420: LD_VAR 0 2
4424: PPUSH
4425: LD_INT 124
4427: PPUSH
4428: LD_INT 7
4430: PPUSH
4431: CALL_OW 171
// end ;
4435: PPOPN 4
4437: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4438: LD_EXP 6
4442: IFFALSE 7116
4444: GO 4446
4446: DISABLE
4447: LD_INT 0
4449: PPUSH
4450: PPUSH
4451: PPUSH
4452: PPUSH
4453: PPUSH
4454: PPUSH
4455: PPUSH
4456: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4457: LD_ADDR_VAR 0 4
4461: PUSH
4462: LD_INT 5
4464: PUSH
4465: LD_INT 6
4467: PUSH
4468: LD_INT 7
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: LIST
4475: PUSH
4476: LD_OWVAR 67
4480: ARRAY
4481: ST_TO_ADDR
// coords := [ ] ;
4482: LD_ADDR_VAR 0 5
4486: PUSH
4487: EMPTY
4488: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4489: LD_ADDR_VAR 0 6
4493: PUSH
4494: LD_INT 0
4496: PUSH
4497: LD_INT 0
4499: PUSH
4500: LD_INT 0
4502: PUSH
4503: LD_INT 0
4505: PUSH
4506: LD_INT 1
4508: PUSH
4509: LD_INT 0
4511: PUSH
4512: LD_INT 0
4514: PUSH
4515: LD_INT 0
4517: PUSH
4518: LD_INT 1
4520: PUSH
4521: LD_INT 0
4523: PUSH
4524: EMPTY
4525: LIST
4526: LIST
4527: LIST
4528: LIST
4529: LIST
4530: LIST
4531: LIST
4532: LIST
4533: LIST
4534: LIST
4535: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4536: LD_INT 1
4538: PPUSH
4539: LD_INT 14
4541: PUSH
4542: LD_INT 1
4544: PUSH
4545: LD_INT 2
4547: PUSH
4548: LD_INT 28
4550: PUSH
4551: EMPTY
4552: LIST
4553: LIST
4554: LIST
4555: LIST
4556: PUSH
4557: LD_INT 14
4559: PUSH
4560: LD_INT 1
4562: PUSH
4563: LD_INT 2
4565: PUSH
4566: LD_INT 25
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: LIST
4573: LIST
4574: PUSH
4575: LD_INT 14
4577: PUSH
4578: LD_INT 1
4580: PUSH
4581: LD_INT 2
4583: PUSH
4584: LD_INT 28
4586: PUSH
4587: EMPTY
4588: LIST
4589: LIST
4590: LIST
4591: LIST
4592: PUSH
4593: LD_INT 14
4595: PUSH
4596: LD_INT 1
4598: PUSH
4599: LD_INT 2
4601: PUSH
4602: LD_INT 29
4604: PUSH
4605: EMPTY
4606: LIST
4607: LIST
4608: LIST
4609: LIST
4610: PUSH
4611: EMPTY
4612: LIST
4613: LIST
4614: LIST
4615: LIST
4616: PPUSH
4617: CALL 40352 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4621: LD_INT 21000
4623: PUSH
4624: LD_INT 19950
4626: PUSH
4627: LD_INT 18900
4629: PUSH
4630: EMPTY
4631: LIST
4632: LIST
4633: LIST
4634: PUSH
4635: LD_OWVAR 67
4639: ARRAY
4640: PPUSH
4641: CALL_OW 67
// InitHc ;
4645: CALL_OW 19
// InitUc ;
4649: CALL_OW 18
// uc_side := 2 ;
4653: LD_ADDR_OWVAR 20
4657: PUSH
4658: LD_INT 2
4660: ST_TO_ADDR
// uc_nation := 2 ;
4661: LD_ADDR_OWVAR 21
4665: PUSH
4666: LD_INT 2
4668: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4669: LD_ADDR_VAR 0 3
4673: PUSH
4674: EMPTY
4675: PUSH
4676: EMPTY
4677: PUSH
4678: EMPTY
4679: PUSH
4680: EMPTY
4681: PUSH
4682: EMPTY
4683: PUSH
4684: EMPTY
4685: LIST
4686: LIST
4687: LIST
4688: LIST
4689: LIST
4690: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4691: LD_ADDR_VAR 0 3
4695: PUSH
4696: LD_VAR 0 3
4700: PPUSH
4701: LD_INT 1
4703: PPUSH
4704: LD_EXP 68
4708: PUSH
4709: LD_INT 1
4711: ARRAY
4712: PUSH
4713: LD_INT 34
4715: PUSH
4716: LD_INT 32
4718: PUSH
4719: EMPTY
4720: LIST
4721: LIST
4722: PPUSH
4723: CALL_OW 69
4727: DIFF
4728: PPUSH
4729: CALL_OW 1
4733: ST_TO_ADDR
// for i = 1 to Difficulty do
4734: LD_ADDR_VAR 0 1
4738: PUSH
4739: DOUBLE
4740: LD_INT 1
4742: DEC
4743: ST_TO_ADDR
4744: LD_OWVAR 67
4748: PUSH
4749: FOR_TO
4750: IFFALSE 4888
// begin uc_side := 2 ;
4752: LD_ADDR_OWVAR 20
4756: PUSH
4757: LD_INT 2
4759: ST_TO_ADDR
// uc_nation := 2 ;
4760: LD_ADDR_OWVAR 21
4764: PUSH
4765: LD_INT 2
4767: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4768: LD_INT 13
4770: PPUSH
4771: LD_INT 3
4773: PPUSH
4774: LD_INT 5
4776: PPUSH
4777: LD_INT 29
4779: PPUSH
4780: LD_INT 100
4782: PPUSH
4783: CALL 53576 0 5
// un := CreateVehicle ;
4787: LD_ADDR_VAR 0 2
4791: PUSH
4792: CALL_OW 45
4796: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
4797: LD_ADDR_VAR 0 3
4801: PUSH
4802: LD_VAR 0 3
4806: PPUSH
4807: LD_INT 1
4809: PUSH
4810: LD_VAR 0 3
4814: PUSH
4815: LD_INT 1
4817: ARRAY
4818: PUSH
4819: LD_INT 1
4821: PLUS
4822: PUSH
4823: EMPTY
4824: LIST
4825: LIST
4826: PPUSH
4827: LD_VAR 0 2
4831: PPUSH
4832: CALL 53698 0 3
4836: ST_TO_ADDR
// SetDir ( un , 3 ) ;
4837: LD_VAR 0 2
4841: PPUSH
4842: LD_INT 3
4844: PPUSH
4845: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
4849: LD_VAR 0 2
4853: PPUSH
4854: LD_INT 16
4856: PPUSH
4857: LD_INT 0
4859: PPUSH
4860: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
4864: LD_VAR 0 2
4868: PPUSH
4869: LD_INT 51
4871: PPUSH
4872: LD_INT 10
4874: PPUSH
4875: CALL_OW 111
// wait ( 0 0$2 ) ;
4879: LD_INT 70
4881: PPUSH
4882: CALL_OW 67
// end ;
4886: GO 4749
4888: POP
4889: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
4890: LD_ADDR_VAR 0 5
4894: PUSH
4895: LD_INT 51
4897: PUSH
4898: LD_INT 24
4900: PUSH
4901: EMPTY
4902: LIST
4903: LIST
4904: PUSH
4905: LD_INT 75
4907: PUSH
4908: LD_INT 90
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PUSH
4915: EMPTY
4916: LIST
4917: LIST
4918: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
4919: LD_INT 1
4921: PPUSH
4922: LD_VAR 0 3
4926: PUSH
4927: LD_INT 1
4929: ARRAY
4930: PPUSH
4931: LD_VAR 0 5
4935: PPUSH
4936: LD_VAR 0 6
4940: PPUSH
4941: CALL 40585 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
4945: LD_ADDR_VAR 0 1
4949: PUSH
4950: DOUBLE
4951: LD_INT 1
4953: DEC
4954: ST_TO_ADDR
4955: LD_INT 1
4957: PUSH
4958: LD_INT 3
4960: PUSH
4961: LD_INT 3
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: LIST
4968: PUSH
4969: LD_OWVAR 67
4973: ARRAY
4974: PUSH
4975: FOR_TO
4976: IFFALSE 5076
// begin uc_side := 2 ;
4978: LD_ADDR_OWVAR 20
4982: PUSH
4983: LD_INT 2
4985: ST_TO_ADDR
// uc_nation := 2 ;
4986: LD_ADDR_OWVAR 21
4990: PUSH
4991: LD_INT 2
4993: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
4994: LD_INT 0
4996: PPUSH
4997: LD_INT 17
4999: PPUSH
5000: LD_VAR 0 4
5004: PPUSH
5005: CALL_OW 380
// un := CreateHuman ;
5009: LD_ADDR_VAR 0 2
5013: PUSH
5014: CALL_OW 44
5018: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5019: LD_ADDR_VAR 0 3
5023: PUSH
5024: LD_VAR 0 3
5028: PPUSH
5029: LD_INT 2
5031: PUSH
5032: LD_VAR 0 3
5036: PUSH
5037: LD_INT 2
5039: ARRAY
5040: PUSH
5041: LD_INT 1
5043: PLUS
5044: PUSH
5045: EMPTY
5046: LIST
5047: LIST
5048: PPUSH
5049: LD_VAR 0 2
5053: PPUSH
5054: CALL 53698 0 3
5058: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5059: LD_VAR 0 2
5063: PPUSH
5064: LD_INT 13
5066: PPUSH
5067: LD_INT 0
5069: PPUSH
5070: CALL_OW 49
// end ;
5074: GO 4975
5076: POP
5077: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
5078: LD_ADDR_VAR 0 1
5082: PUSH
5083: DOUBLE
5084: LD_INT 1
5086: DEC
5087: ST_TO_ADDR
5088: LD_INT 2
5090: PUSH
5091: LD_INT 3
5093: PUSH
5094: LD_INT 3
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: LIST
5101: PUSH
5102: LD_OWVAR 67
5106: ARRAY
5107: PUSH
5108: FOR_TO
5109: IFFALSE 5228
// begin uc_side := 2 ;
5111: LD_ADDR_OWVAR 20
5115: PUSH
5116: LD_INT 2
5118: ST_TO_ADDR
// uc_nation := 2 ;
5119: LD_ADDR_OWVAR 21
5123: PUSH
5124: LD_INT 2
5126: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ rand ( 1 , 2 ) ] , skill ) ;
5127: LD_INT 0
5129: PPUSH
5130: LD_INT 1
5132: PUSH
5133: LD_INT 8
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: LD_INT 1
5142: PPUSH
5143: LD_INT 2
5145: PPUSH
5146: CALL_OW 12
5150: ARRAY
5151: PPUSH
5152: LD_VAR 0 4
5156: PPUSH
5157: CALL_OW 380
// un := CreateHuman ;
5161: LD_ADDR_VAR 0 2
5165: PUSH
5166: CALL_OW 44
5170: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5171: LD_ADDR_VAR 0 3
5175: PUSH
5176: LD_VAR 0 3
5180: PPUSH
5181: LD_INT 2
5183: PUSH
5184: LD_VAR 0 3
5188: PUSH
5189: LD_INT 2
5191: ARRAY
5192: PUSH
5193: LD_INT 1
5195: PLUS
5196: PUSH
5197: EMPTY
5198: LIST
5199: LIST
5200: PPUSH
5201: LD_VAR 0 2
5205: PPUSH
5206: CALL 53698 0 3
5210: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5211: LD_VAR 0 2
5215: PPUSH
5216: LD_INT 13
5218: PPUSH
5219: LD_INT 0
5221: PPUSH
5222: CALL_OW 49
// end ;
5226: GO 5108
5228: POP
5229: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5230: LD_ADDR_VAR 0 5
5234: PUSH
5235: LD_INT 67
5237: PUSH
5238: LD_INT 112
5240: PUSH
5241: EMPTY
5242: LIST
5243: LIST
5244: PUSH
5245: LD_INT 85
5247: PUSH
5248: LD_INT 130
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: PUSH
5255: EMPTY
5256: LIST
5257: LIST
5258: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5259: LD_INT 2
5261: PPUSH
5262: LD_VAR 0 3
5266: PUSH
5267: LD_INT 2
5269: ARRAY
5270: PPUSH
5271: LD_VAR 0 5
5275: PPUSH
5276: LD_VAR 0 6
5280: PPUSH
5281: CALL 40585 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5285: LD_ADDR_VAR 0 1
5289: PUSH
5290: DOUBLE
5291: LD_INT 1
5293: DEC
5294: ST_TO_ADDR
5295: LD_INT 1
5297: PUSH
5298: LD_INT 2
5300: PUSH
5301: LD_INT 3
5303: PUSH
5304: EMPTY
5305: LIST
5306: LIST
5307: LIST
5308: PUSH
5309: LD_OWVAR 67
5313: ARRAY
5314: PUSH
5315: FOR_TO
5316: IFFALSE 5416
// begin uc_side := 2 ;
5318: LD_ADDR_OWVAR 20
5322: PUSH
5323: LD_INT 2
5325: ST_TO_ADDR
// uc_nation := 2 ;
5326: LD_ADDR_OWVAR 21
5330: PUSH
5331: LD_INT 2
5333: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5334: LD_INT 0
5336: PPUSH
5337: LD_INT 17
5339: PPUSH
5340: LD_VAR 0 4
5344: PPUSH
5345: CALL_OW 380
// un := CreateHuman ;
5349: LD_ADDR_VAR 0 2
5353: PUSH
5354: CALL_OW 44
5358: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5359: LD_ADDR_VAR 0 3
5363: PUSH
5364: LD_VAR 0 3
5368: PPUSH
5369: LD_INT 3
5371: PUSH
5372: LD_VAR 0 3
5376: PUSH
5377: LD_INT 3
5379: ARRAY
5380: PUSH
5381: LD_INT 1
5383: PLUS
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PPUSH
5389: LD_VAR 0 2
5393: PPUSH
5394: CALL 53698 0 3
5398: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5399: LD_VAR 0 2
5403: PPUSH
5404: LD_INT 14
5406: PPUSH
5407: LD_INT 0
5409: PPUSH
5410: CALL_OW 49
// end ;
5414: GO 5315
5416: POP
5417: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5418: LD_ADDR_VAR 0 5
5422: PUSH
5423: LD_INT 148
5425: PUSH
5426: LD_INT 158
5428: PUSH
5429: EMPTY
5430: LIST
5431: LIST
5432: PUSH
5433: LD_INT 148
5435: PUSH
5436: LD_INT 158
5438: PUSH
5439: EMPTY
5440: LIST
5441: LIST
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5447: LD_INT 3
5449: PPUSH
5450: LD_VAR 0 3
5454: PUSH
5455: LD_INT 3
5457: ARRAY
5458: PPUSH
5459: LD_VAR 0 5
5463: PPUSH
5464: LD_VAR 0 6
5468: PPUSH
5469: CALL 40585 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
5473: LD_ADDR_VAR 0 1
5477: PUSH
5478: DOUBLE
5479: LD_INT 1
5481: DEC
5482: ST_TO_ADDR
5483: LD_INT 2
5485: PUSH
5486: LD_INT 4
5488: PUSH
5489: LD_INT 4
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: LIST
5496: PUSH
5497: LD_OWVAR 67
5501: ARRAY
5502: PUSH
5503: FOR_TO
5504: IFFALSE 5728
// begin uc_side := 2 ;
5506: LD_ADDR_OWVAR 20
5510: PUSH
5511: LD_INT 2
5513: ST_TO_ADDR
// uc_nation := 2 ;
5514: LD_ADDR_OWVAR 21
5518: PUSH
5519: LD_INT 2
5521: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5522: LD_INT 14
5524: PPUSH
5525: LD_INT 3
5527: PPUSH
5528: LD_INT 1
5530: PUSH
5531: LD_INT 5
5533: PUSH
5534: EMPTY
5535: LIST
5536: LIST
5537: PUSH
5538: LD_INT 1
5540: PPUSH
5541: LD_INT 2
5543: PPUSH
5544: CALL_OW 12
5548: ARRAY
5549: PPUSH
5550: LD_INT 27
5552: PUSH
5553: LD_INT 26
5555: PUSH
5556: LD_INT 28
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 1
5566: PPUSH
5567: LD_INT 3
5569: PPUSH
5570: CALL_OW 12
5574: ARRAY
5575: PPUSH
5576: LD_INT 100
5578: PPUSH
5579: CALL 53576 0 5
// un := CreateVehicle ;
5583: LD_ADDR_VAR 0 2
5587: PUSH
5588: CALL_OW 45
5592: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5593: LD_ADDR_VAR 0 3
5597: PUSH
5598: LD_VAR 0 3
5602: PPUSH
5603: LD_INT 4
5605: PUSH
5606: LD_VAR 0 3
5610: PUSH
5611: LD_INT 4
5613: ARRAY
5614: PUSH
5615: LD_INT 1
5617: PLUS
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: PPUSH
5623: LD_VAR 0 2
5627: PPUSH
5628: CALL 53698 0 3
5632: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5633: LD_VAR 0 2
5637: PPUSH
5638: LD_INT 5
5640: PPUSH
5641: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5645: LD_VAR 0 2
5649: PPUSH
5650: LD_INT 15
5652: PPUSH
5653: LD_INT 0
5655: PPUSH
5656: CALL_OW 49
// if GetControl ( un ) = control_manual then
5660: LD_VAR 0 2
5664: PPUSH
5665: CALL_OW 263
5669: PUSH
5670: LD_INT 1
5672: EQUAL
5673: IFFALSE 5704
// begin PrepareHuman ( false , 3 , skill ) ;
5675: LD_INT 0
5677: PPUSH
5678: LD_INT 3
5680: PPUSH
5681: LD_VAR 0 4
5685: PPUSH
5686: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5690: CALL_OW 44
5694: PPUSH
5695: LD_VAR 0 2
5699: PPUSH
5700: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5704: LD_VAR 0 2
5708: PPUSH
5709: LD_INT 179
5711: PPUSH
5712: LD_INT 135
5714: PPUSH
5715: CALL_OW 111
// wait ( 0 0$2 ) ;
5719: LD_INT 70
5721: PPUSH
5722: CALL_OW 67
// end ;
5726: GO 5503
5728: POP
5729: POP
// vc_chassis := 15 ;
5730: LD_ADDR_OWVAR 37
5734: PUSH
5735: LD_INT 15
5737: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5738: LD_ADDR_VAR 0 3
5742: PUSH
5743: LD_VAR 0 3
5747: PPUSH
5748: LD_INT 4
5750: PUSH
5751: LD_VAR 0 3
5755: PUSH
5756: LD_INT 4
5758: ARRAY
5759: PUSH
5760: LD_INT 1
5762: PLUS
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: PPUSH
5768: CALL_OW 45
5772: PPUSH
5773: CALL 53698 0 3
5777: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
5778: LD_VAR 0 3
5782: PUSH
5783: LD_INT 4
5785: ARRAY
5786: PUSH
5787: LD_VAR 0 3
5791: PUSH
5792: LD_INT 4
5794: ARRAY
5795: ARRAY
5796: PPUSH
5797: LD_INT 15
5799: PPUSH
5800: LD_INT 0
5802: PPUSH
5803: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
5807: LD_INT 0
5809: PPUSH
5810: LD_INT 11
5812: PPUSH
5813: LD_VAR 0 4
5817: PPUSH
5818: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
5822: LD_ADDR_VAR 0 3
5826: PUSH
5827: LD_VAR 0 3
5831: PPUSH
5832: LD_INT 4
5834: PUSH
5835: LD_VAR 0 3
5839: PUSH
5840: LD_INT 4
5842: ARRAY
5843: PUSH
5844: LD_INT 1
5846: PLUS
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: PPUSH
5852: CALL_OW 44
5856: PPUSH
5857: CALL 53698 0 3
5861: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
5862: LD_VAR 0 3
5866: PUSH
5867: LD_INT 4
5869: ARRAY
5870: PUSH
5871: LD_VAR 0 3
5875: PUSH
5876: LD_INT 4
5878: ARRAY
5879: ARRAY
5880: PPUSH
5881: LD_VAR 0 3
5885: PUSH
5886: LD_INT 4
5888: ARRAY
5889: PUSH
5890: LD_VAR 0 3
5894: PUSH
5895: LD_INT 4
5897: ARRAY
5898: PUSH
5899: LD_INT 1
5901: MINUS
5902: ARRAY
5903: PPUSH
5904: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
5908: LD_ADDR_VAR 0 5
5912: PUSH
5913: LD_INT 148
5915: PUSH
5916: LD_INT 140
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: PUSH
5923: EMPTY
5924: LIST
5925: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
5926: LD_INT 1
5928: PPUSH
5929: LD_VAR 0 3
5933: PUSH
5934: LD_INT 4
5936: ARRAY
5937: PPUSH
5938: LD_VAR 0 5
5942: PPUSH
5943: LD_VAR 0 6
5947: PPUSH
5948: CALL 40585 0 4
// if gensher_active then
5952: LD_EXP 18
5956: IFFALSE 6358
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
5958: LD_EXP 44
5962: PPUSH
5963: LD_STRING D10-Diet-1
5965: PPUSH
5966: CALL_OW 94
// for i = 1 to 2 do
5970: LD_ADDR_VAR 0 1
5974: PUSH
5975: DOUBLE
5976: LD_INT 1
5978: DEC
5979: ST_TO_ADDR
5980: LD_INT 2
5982: PUSH
5983: FOR_TO
5984: IFFALSE 6122
// begin uc_side := 2 ;
5986: LD_ADDR_OWVAR 20
5990: PUSH
5991: LD_INT 2
5993: ST_TO_ADDR
// uc_nation := 2 ;
5994: LD_ADDR_OWVAR 21
5998: PUSH
5999: LD_INT 2
6001: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6002: LD_INT 13
6004: PPUSH
6005: LD_INT 3
6007: PPUSH
6008: LD_INT 5
6010: PPUSH
6011: LD_INT 29
6013: PPUSH
6014: LD_INT 100
6016: PPUSH
6017: CALL 53576 0 5
// un := CreateVehicle ;
6021: LD_ADDR_VAR 0 2
6025: PUSH
6026: CALL_OW 45
6030: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6031: LD_ADDR_VAR 0 3
6035: PUSH
6036: LD_VAR 0 3
6040: PPUSH
6041: LD_INT 5
6043: PUSH
6044: LD_VAR 0 3
6048: PUSH
6049: LD_INT 5
6051: ARRAY
6052: PUSH
6053: LD_INT 1
6055: PLUS
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: PPUSH
6061: LD_VAR 0 2
6065: PPUSH
6066: CALL 53698 0 3
6070: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6071: LD_VAR 0 2
6075: PPUSH
6076: LD_INT 0
6078: PPUSH
6079: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6083: LD_VAR 0 2
6087: PPUSH
6088: LD_INT 23
6090: PPUSH
6091: LD_INT 0
6093: PPUSH
6094: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6098: LD_VAR 0 2
6102: PPUSH
6103: LD_INT 85
6105: PPUSH
6106: LD_INT 152
6108: PPUSH
6109: CALL_OW 111
// wait ( 0 0$2 ) ;
6113: LD_INT 70
6115: PPUSH
6116: CALL_OW 67
// end ;
6120: GO 5983
6122: POP
6123: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6124: LD_ADDR_VAR 0 1
6128: PUSH
6129: DOUBLE
6130: LD_INT 1
6132: DEC
6133: ST_TO_ADDR
6134: LD_INT 2
6136: PUSH
6137: LD_INT 3
6139: PUSH
6140: LD_INT 3
6142: PUSH
6143: EMPTY
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_OWVAR 67
6152: ARRAY
6153: PUSH
6154: FOR_TO
6155: IFFALSE 6312
// begin uc_side := 2 ;
6157: LD_ADDR_OWVAR 20
6161: PUSH
6162: LD_INT 2
6164: ST_TO_ADDR
// uc_nation := 2 ;
6165: LD_ADDR_OWVAR 21
6169: PUSH
6170: LD_INT 2
6172: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6173: LD_INT 14
6175: PPUSH
6176: LD_INT 3
6178: PPUSH
6179: LD_INT 5
6181: PPUSH
6182: LD_INT 27
6184: PUSH
6185: LD_INT 28
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 1
6194: PPUSH
6195: LD_INT 2
6197: PPUSH
6198: CALL_OW 12
6202: ARRAY
6203: PPUSH
6204: LD_INT 100
6206: PPUSH
6207: CALL 53576 0 5
// un := CreateVehicle ;
6211: LD_ADDR_VAR 0 2
6215: PUSH
6216: CALL_OW 45
6220: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6221: LD_ADDR_VAR 0 3
6225: PUSH
6226: LD_VAR 0 3
6230: PPUSH
6231: LD_INT 5
6233: PUSH
6234: LD_VAR 0 3
6238: PUSH
6239: LD_INT 5
6241: ARRAY
6242: PUSH
6243: LD_INT 1
6245: PLUS
6246: PUSH
6247: EMPTY
6248: LIST
6249: LIST
6250: PPUSH
6251: LD_VAR 0 2
6255: PPUSH
6256: CALL 53698 0 3
6260: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6261: LD_VAR 0 2
6265: PPUSH
6266: LD_INT 0
6268: PPUSH
6269: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6273: LD_VAR 0 2
6277: PPUSH
6278: LD_INT 23
6280: PPUSH
6281: LD_INT 0
6283: PPUSH
6284: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6288: LD_VAR 0 2
6292: PPUSH
6293: LD_INT 85
6295: PPUSH
6296: LD_INT 152
6298: PPUSH
6299: CALL_OW 111
// wait ( 0 0$2 ) ;
6303: LD_INT 70
6305: PPUSH
6306: CALL_OW 67
// end ;
6310: GO 6154
6312: POP
6313: POP
// coords := [ [ 97 , 143 ] ] ;
6314: LD_ADDR_VAR 0 5
6318: PUSH
6319: LD_INT 97
6321: PUSH
6322: LD_INT 143
6324: PUSH
6325: EMPTY
6326: LIST
6327: LIST
6328: PUSH
6329: EMPTY
6330: LIST
6331: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6332: LD_INT 1
6334: PPUSH
6335: LD_VAR 0 3
6339: PUSH
6340: LD_INT 5
6342: ARRAY
6343: PPUSH
6344: LD_VAR 0 5
6348: PPUSH
6349: LD_VAR 0 6
6353: PPUSH
6354: CALL 40585 0 4
// end ; Wait ( 13 13$00 ) ;
6358: LD_INT 27300
6360: PPUSH
6361: CALL_OW 67
// tmp := [ ] ;
6365: LD_ADDR_VAR 0 3
6369: PUSH
6370: EMPTY
6371: ST_TO_ADDR
// w := 1 ;
6372: LD_ADDR_VAR 0 7
6376: PUSH
6377: LD_INT 1
6379: ST_TO_ADDR
// repeat tmp := [ ] ;
6380: LD_ADDR_VAR 0 3
6384: PUSH
6385: EMPTY
6386: ST_TO_ADDR
// if w mod 4 = 0 then
6387: LD_VAR 0 7
6391: PUSH
6392: LD_INT 4
6394: MOD
6395: PUSH
6396: LD_INT 0
6398: EQUAL
6399: IFFALSE 6486
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6401: LD_ADDR_VAR 0 8
6405: PUSH
6406: LD_INT 11
6408: PUSH
6409: LD_INT 1
6411: PUSH
6412: LD_INT 2
6414: PUSH
6415: LD_INT 24
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: LIST
6422: LIST
6423: PUSH
6424: LD_INT 11
6426: PUSH
6427: LD_INT 1
6429: PUSH
6430: LD_INT 2
6432: PUSH
6433: LD_INT 24
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 11
6444: PUSH
6445: LD_INT 1
6447: PUSH
6448: LD_INT 2
6450: PUSH
6451: LD_INT 24
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: PUSH
6460: LD_INT 11
6462: PUSH
6463: LD_INT 1
6465: PUSH
6466: LD_INT 2
6468: PUSH
6469: LD_INT 24
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: ST_TO_ADDR
6484: GO 6588
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6486: LD_ADDR_VAR 0 8
6490: PUSH
6491: LD_INT 14
6493: PUSH
6494: LD_INT 1
6496: PUSH
6497: LD_INT 2
6499: PUSH
6500: LD_INT 28
6502: PUSH
6503: EMPTY
6504: LIST
6505: LIST
6506: LIST
6507: LIST
6508: PUSH
6509: LD_INT 14
6511: PUSH
6512: LD_INT 1
6514: PUSH
6515: LD_INT 2
6517: PUSH
6518: LD_INT 25
6520: PUSH
6521: EMPTY
6522: LIST
6523: LIST
6524: LIST
6525: LIST
6526: PUSH
6527: LD_INT 14
6529: PUSH
6530: LD_INT 1
6532: PUSH
6533: LD_INT 2
6535: PUSH
6536: LD_INT 28
6538: PUSH
6539: EMPTY
6540: LIST
6541: LIST
6542: LIST
6543: LIST
6544: PUSH
6545: LD_INT 14
6547: PUSH
6548: LD_INT 1
6550: PUSH
6551: LD_INT 2
6553: PUSH
6554: LD_INT 29
6556: PUSH
6557: EMPTY
6558: LIST
6559: LIST
6560: LIST
6561: LIST
6562: PUSH
6563: LD_INT 11
6565: PUSH
6566: LD_INT 1
6568: PUSH
6569: LD_INT 2
6571: PUSH
6572: LD_INT 24
6574: PUSH
6575: EMPTY
6576: LIST
6577: LIST
6578: LIST
6579: LIST
6580: PUSH
6581: EMPTY
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: ST_TO_ADDR
// if w mod 3 = 0 then
6588: LD_VAR 0 7
6592: PUSH
6593: LD_INT 3
6595: MOD
6596: PUSH
6597: LD_INT 0
6599: EQUAL
6600: IFFALSE 6676
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6602: LD_ADDR_VAR 0 8
6606: PUSH
6607: LD_VAR 0 8
6611: PPUSH
6612: LD_INT 1
6614: PUSH
6615: LD_VAR 0 8
6619: PUSH
6620: LD_VAR 0 1
6624: ARRAY
6625: PUSH
6626: LD_INT 1
6628: PLUS
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: PPUSH
6634: LD_INT 14
6636: PUSH
6637: LD_INT 1
6639: PUSH
6640: LD_INT 2
6642: PUSH
6643: LD_INT 25
6645: PUSH
6646: LD_INT 28
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PUSH
6653: LD_INT 1
6655: PPUSH
6656: LD_INT 2
6658: PPUSH
6659: CALL_OW 12
6663: ARRAY
6664: PUSH
6665: EMPTY
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: PPUSH
6671: CALL 53698 0 3
6675: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6676: LD_INT 1
6678: PPUSH
6679: LD_VAR 0 8
6683: PPUSH
6684: CALL 40352 0 2
// if GetSide ( ar_dep_w ) = 2 then
6688: LD_INT 45
6690: PPUSH
6691: CALL_OW 255
6695: PUSH
6696: LD_INT 2
6698: EQUAL
6699: IFFALSE 6784
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6701: LD_ADDR_VAR 0 8
6705: PUSH
6706: LD_INT 14
6708: PUSH
6709: LD_INT 1
6711: PUSH
6712: LD_INT 2
6714: PUSH
6715: LD_INT 28
6717: PUSH
6718: EMPTY
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: PUSH
6724: LD_INT 14
6726: PUSH
6727: LD_INT 1
6729: PUSH
6730: LD_INT 2
6732: PUSH
6733: LD_INT 27
6735: PUSH
6736: EMPTY
6737: LIST
6738: LIST
6739: LIST
6740: LIST
6741: PUSH
6742: LD_INT 14
6744: PUSH
6745: LD_INT 1
6747: PUSH
6748: LD_INT 2
6750: PUSH
6751: LD_INT 27
6753: PUSH
6754: EMPTY
6755: LIST
6756: LIST
6757: LIST
6758: LIST
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: LIST
6764: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6765: LD_INT 2
6767: PPUSH
6768: LD_VAR 0 8
6772: PPUSH
6773: CALL 40352 0 2
// wait ( 0 0$50 ) ;
6777: LD_INT 1750
6779: PPUSH
6780: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
6784: LD_INT 35
6786: PPUSH
6787: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
6791: LD_EXP 68
6795: PUSH
6796: LD_INT 1
6798: ARRAY
6799: PPUSH
6800: LD_INT 3
6802: PUSH
6803: LD_INT 34
6805: PUSH
6806: LD_INT 32
6808: PUSH
6809: EMPTY
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: PPUSH
6817: CALL_OW 72
6821: PUSH
6822: LD_INT 4
6824: GREATEREQUAL
6825: IFFALSE 6784
// wait ( 0 0$10 ) ;
6827: LD_INT 350
6829: PPUSH
6830: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
6834: LD_ADDR_VAR 0 3
6838: PUSH
6839: LD_EXP 68
6843: PUSH
6844: LD_INT 1
6846: ARRAY
6847: PPUSH
6848: LD_INT 3
6850: PUSH
6851: LD_INT 34
6853: PUSH
6854: LD_INT 32
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: PPUSH
6865: CALL_OW 72
6869: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
6870: LD_INT 100
6872: PPUSH
6873: CALL_OW 13
6877: PUSH
6878: LD_INT 50
6880: LESS
6881: IFFALSE 6914
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
6883: LD_ADDR_VAR 0 5
6887: PUSH
6888: LD_INT 55
6890: PUSH
6891: LD_INT 7
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 75
6900: PUSH
6901: LD_INT 90
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PUSH
6908: EMPTY
6909: LIST
6910: LIST
6911: ST_TO_ADDR
6912: GO 6943
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
6914: LD_ADDR_VAR 0 5
6918: PUSH
6919: LD_INT 128
6921: PUSH
6922: LD_INT 94
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: PUSH
6929: LD_INT 180
6931: PUSH
6932: LD_INT 135
6934: PUSH
6935: EMPTY
6936: LIST
6937: LIST
6938: PUSH
6939: EMPTY
6940: LIST
6941: LIST
6942: ST_TO_ADDR
// if w mod 4 = 0 then
6943: LD_VAR 0 7
6947: PUSH
6948: LD_INT 4
6950: MOD
6951: PUSH
6952: LD_INT 0
6954: EQUAL
6955: IFFALSE 6986
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
6957: LD_ADDR_VAR 0 5
6961: PUSH
6962: LD_INT 91
6964: PUSH
6965: LD_INT 58
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: PUSH
6972: LD_INT 117
6974: PUSH
6975: LD_INT 107
6977: PUSH
6978: EMPTY
6979: LIST
6980: LIST
6981: PUSH
6982: EMPTY
6983: LIST
6984: LIST
6985: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp , coords , flags ) ;
6986: LD_INT 1
6988: PPUSH
6989: LD_VAR 0 3
6993: PPUSH
6994: LD_VAR 0 5
6998: PPUSH
6999: LD_VAR 0 6
7003: PPUSH
7004: CALL 40585 0 4
// if mc_vehicles [ 2 ] then
7008: LD_EXP 68
7012: PUSH
7013: LD_INT 2
7015: ARRAY
7016: IFFALSE 7052
// MC_PrepareAttack ( 2 , mc_vehicles [ 2 ] , [ [ 73 , 115 ] ] , flags ) ;
7018: LD_INT 2
7020: PPUSH
7021: LD_EXP 68
7025: PUSH
7026: LD_INT 2
7028: ARRAY
7029: PPUSH
7030: LD_INT 73
7032: PUSH
7033: LD_INT 115
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PUSH
7040: EMPTY
7041: LIST
7042: PPUSH
7043: LD_VAR 0 6
7047: PPUSH
7048: CALL 40585 0 4
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7052: LD_INT 22050
7054: PPUSH
7055: LD_INT 28350
7057: PPUSH
7058: CALL_OW 12
7062: PPUSH
7063: CALL_OW 67
// w := w + 1 ;
7067: LD_ADDR_VAR 0 7
7071: PUSH
7072: LD_VAR 0 7
7076: PUSH
7077: LD_INT 1
7079: PLUS
7080: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7081: LD_INT 94
7083: PPUSH
7084: CALL_OW 301
7088: PUSH
7089: LD_EXP 49
7093: PUSH
7094: LD_INT 1
7096: ARRAY
7097: PPUSH
7098: LD_INT 30
7100: PUSH
7101: LD_INT 3
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: PPUSH
7108: CALL_OW 72
7112: NOT
7113: OR
7114: IFFALSE 6380
// end ;
7116: PPOPN 8
7118: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7119: LD_INT 204
7121: IFFALSE 7595
7123: GO 7125
7125: DISABLE
7126: LD_INT 0
7128: PPUSH
7129: PPUSH
7130: PPUSH
7131: PPUSH
// begin enable ;
7132: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7133: LD_INT 35
7135: PPUSH
7136: LD_INT 1190
7138: PPUSH
7139: CALL_OW 12
7143: PPUSH
7144: CALL_OW 67
// tmp := [ ] ;
7148: LD_ADDR_VAR 0 2
7152: PUSH
7153: EMPTY
7154: ST_TO_ADDR
// uc_side := 8 ;
7155: LD_ADDR_OWVAR 20
7159: PUSH
7160: LD_INT 8
7162: ST_TO_ADDR
// uc_nation := 2 ;
7163: LD_ADDR_OWVAR 21
7167: PUSH
7168: LD_INT 2
7170: ST_TO_ADDR
// InitHc ;
7171: CALL_OW 19
// for i = 1 to 3 do
7175: LD_ADDR_VAR 0 1
7179: PUSH
7180: DOUBLE
7181: LD_INT 1
7183: DEC
7184: ST_TO_ADDR
7185: LD_INT 3
7187: PUSH
7188: FOR_TO
7189: IFFALSE 7316
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7191: LD_INT 13
7193: PUSH
7194: LD_INT 14
7196: PUSH
7197: EMPTY
7198: LIST
7199: LIST
7200: PUSH
7201: LD_INT 1
7203: PPUSH
7204: LD_INT 2
7206: PPUSH
7207: CALL_OW 12
7211: ARRAY
7212: PPUSH
7213: LD_INT 3
7215: PPUSH
7216: LD_INT 5
7218: PPUSH
7219: LD_INT 27
7221: PUSH
7222: LD_INT 28
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: LD_INT 1
7231: PPUSH
7232: LD_INT 2
7234: PPUSH
7235: CALL_OW 12
7239: ARRAY
7240: PPUSH
7241: LD_INT 100
7243: PPUSH
7244: CALL 53576 0 5
// un := CreateVehicle ;
7248: LD_ADDR_VAR 0 3
7252: PUSH
7253: CALL_OW 45
7257: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7258: LD_VAR 0 3
7262: PPUSH
7263: LD_INT 4
7265: PPUSH
7266: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7270: LD_VAR 0 3
7274: PPUSH
7275: LD_INT 15
7277: PPUSH
7278: LD_INT 0
7280: PPUSH
7281: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7285: LD_ADDR_VAR 0 2
7289: PUSH
7290: LD_VAR 0 2
7294: PPUSH
7295: LD_VAR 0 2
7299: PUSH
7300: LD_INT 1
7302: PLUS
7303: PPUSH
7304: LD_VAR 0 3
7308: PPUSH
7309: CALL_OW 1
7313: ST_TO_ADDR
// end ;
7314: GO 7188
7316: POP
7317: POP
// for i = 1 to 4 do
7318: LD_ADDR_VAR 0 1
7322: PUSH
7323: DOUBLE
7324: LD_INT 1
7326: DEC
7327: ST_TO_ADDR
7328: LD_INT 4
7330: PUSH
7331: FOR_TO
7332: IFFALSE 7411
// begin PrepareHuman ( false , rand ( 1 , 4 ) , 6 ) ;
7334: LD_INT 0
7336: PPUSH
7337: LD_INT 1
7339: PPUSH
7340: LD_INT 4
7342: PPUSH
7343: CALL_OW 12
7347: PPUSH
7348: LD_INT 6
7350: PPUSH
7351: CALL_OW 380
// un := CreateHuman ;
7355: LD_ADDR_VAR 0 3
7359: PUSH
7360: CALL_OW 44
7364: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7365: LD_VAR 0 3
7369: PPUSH
7370: LD_INT 15
7372: PPUSH
7373: LD_INT 0
7375: PPUSH
7376: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7380: LD_ADDR_VAR 0 2
7384: PUSH
7385: LD_VAR 0 2
7389: PPUSH
7390: LD_VAR 0 2
7394: PUSH
7395: LD_INT 1
7397: PLUS
7398: PPUSH
7399: LD_VAR 0 3
7403: PPUSH
7404: CALL_OW 1
7408: ST_TO_ADDR
// end ;
7409: GO 7331
7411: POP
7412: POP
// wait ( 0 0$3 ) ;
7413: LD_INT 105
7415: PPUSH
7416: CALL_OW 67
// for i in tmp do
7420: LD_ADDR_VAR 0 1
7424: PUSH
7425: LD_VAR 0 2
7429: PUSH
7430: FOR_IN
7431: IFFALSE 7499
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
7433: LD_VAR 0 1
7437: PPUSH
7438: CALL_OW 257
7442: PUSH
7443: LD_INT 1
7445: EQUAL
7446: PUSH
7447: LD_VAR 0 1
7451: PPUSH
7452: CALL_OW 247
7456: PUSH
7457: LD_INT 2
7459: EQUAL
7460: OR
7461: IFFALSE 7497
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7463: LD_VAR 0 1
7467: PPUSH
7468: LD_INT 81
7470: PUSH
7471: LD_INT 8
7473: PUSH
7474: EMPTY
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: PPUSH
7483: LD_VAR 0 1
7487: PPUSH
7488: CALL_OW 74
7492: PPUSH
7493: CALL_OW 115
7497: GO 7430
7499: POP
7500: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
7501: LD_VAR 0 2
7505: PPUSH
7506: LD_INT 210
7508: PPUSH
7509: LD_INT 178
7511: PPUSH
7512: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7516: LD_ADDR_VAR 0 4
7520: PUSH
7521: LD_INT 10
7523: PPUSH
7524: LD_INT 22
7526: PUSH
7527: LD_INT 8
7529: PUSH
7530: EMPTY
7531: LIST
7532: LIST
7533: PPUSH
7534: CALL_OW 70
7538: ST_TO_ADDR
// if x then
7539: LD_VAR 0 4
7543: IFFALSE 7571
// for i in x do
7545: LD_ADDR_VAR 0 1
7549: PUSH
7550: LD_VAR 0 4
7554: PUSH
7555: FOR_IN
7556: IFFALSE 7569
// RemoveUnit ( i ) ;
7558: LD_VAR 0 1
7562: PPUSH
7563: CALL_OW 64
7567: GO 7555
7569: POP
7570: POP
// wait ( 0 0$1 ) ;
7571: LD_INT 35
7573: PPUSH
7574: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
7578: LD_INT 22
7580: PUSH
7581: LD_INT 8
7583: PUSH
7584: EMPTY
7585: LIST
7586: LIST
7587: PPUSH
7588: CALL_OW 69
7592: NOT
7593: IFFALSE 7501
// end ;
7595: PPOPN 4
7597: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
7598: LD_INT 22
7600: PUSH
7601: LD_INT 2
7603: PUSH
7604: EMPTY
7605: LIST
7606: LIST
7607: PUSH
7608: LD_INT 34
7610: PUSH
7611: LD_INT 31
7613: PUSH
7614: EMPTY
7615: LIST
7616: LIST
7617: PUSH
7618: LD_INT 3
7620: PUSH
7621: LD_INT 24
7623: PUSH
7624: LD_INT 1000
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: LIST
7639: PPUSH
7640: CALL_OW 69
7644: IFFALSE 7688
7646: GO 7648
7648: DISABLE
// begin ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
7649: LD_INT 22
7651: PUSH
7652: LD_INT 2
7654: PUSH
7655: EMPTY
7656: LIST
7657: LIST
7658: PUSH
7659: LD_INT 34
7661: PUSH
7662: LD_INT 31
7664: PUSH
7665: EMPTY
7666: LIST
7667: LIST
7668: PUSH
7669: EMPTY
7670: LIST
7671: LIST
7672: PPUSH
7673: CALL_OW 69
7677: PPUSH
7678: LD_INT 106
7680: PPUSH
7681: LD_INT 14
7683: PPUSH
7684: CALL_OW 111
// end ; end_of_file
7688: END
// export function Action ; var tmp , p , radar , sols , i ; begin
7689: LD_INT 0
7691: PPUSH
7692: PPUSH
7693: PPUSH
7694: PPUSH
7695: PPUSH
7696: PPUSH
// InGameOn ;
7697: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
7701: LD_EXP 20
7705: PPUSH
7706: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
7710: LD_INT 2
7712: PPUSH
7713: LD_INT 1
7715: PPUSH
7716: LD_INT 1
7718: PPUSH
7719: LD_INT 1
7721: PPUSH
7722: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
7726: LD_ADDR_VAR 0 2
7730: PUSH
7731: LD_INT 22
7733: PUSH
7734: LD_INT 1
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PUSH
7741: LD_INT 25
7743: PUSH
7744: LD_INT 1
7746: PUSH
7747: EMPTY
7748: LIST
7749: LIST
7750: PUSH
7751: EMPTY
7752: LIST
7753: LIST
7754: PPUSH
7755: CALL_OW 69
7759: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
7760: LD_ADDR_VAR 0 4
7764: PUSH
7765: LD_INT 22
7767: PUSH
7768: LD_INT 1
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PUSH
7775: LD_INT 34
7777: PUSH
7778: LD_INT 11
7780: PUSH
7781: EMPTY
7782: LIST
7783: LIST
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: PPUSH
7789: CALL_OW 69
7793: PUSH
7794: LD_INT 1
7796: ARRAY
7797: ST_TO_ADDR
// for i = 1 to tmp do
7798: LD_ADDR_VAR 0 6
7802: PUSH
7803: DOUBLE
7804: LD_INT 1
7806: DEC
7807: ST_TO_ADDR
7808: LD_VAR 0 2
7812: PUSH
7813: FOR_TO
7814: IFFALSE 7861
// begin if i = 5 then
7816: LD_VAR 0 6
7820: PUSH
7821: LD_INT 5
7823: EQUAL
7824: IFFALSE 7828
// break ;
7826: GO 7861
// sols := Replace ( sols , i , tmp [ i ] ) ;
7828: LD_ADDR_VAR 0 5
7832: PUSH
7833: LD_VAR 0 5
7837: PPUSH
7838: LD_VAR 0 6
7842: PPUSH
7843: LD_VAR 0 2
7847: PUSH
7848: LD_VAR 0 6
7852: ARRAY
7853: PPUSH
7854: CALL_OW 1
7858: ST_TO_ADDR
// end ;
7859: GO 7813
7861: POP
7862: POP
// tmp := ar_force_tmp ;
7863: LD_ADDR_VAR 0 2
7867: PUSH
7868: LD_EXP 39
7872: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
7873: LD_VAR 0 2
7877: PUSH
7878: LD_INT 1
7880: ARRAY
7881: PPUSH
7882: LD_INT 108
7884: PPUSH
7885: LD_INT 139
7887: PPUSH
7888: LD_INT 0
7890: PPUSH
7891: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
7895: LD_VAR 0 2
7899: PUSH
7900: LD_INT 1
7902: ARRAY
7903: PPUSH
7904: LD_EXP 20
7908: PPUSH
7909: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
7913: LD_VAR 0 2
7917: PUSH
7918: LD_INT 2
7920: ARRAY
7921: PPUSH
7922: LD_INT 114
7924: PPUSH
7925: LD_INT 132
7927: PPUSH
7928: LD_INT 0
7930: PPUSH
7931: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
7935: LD_VAR 0 2
7939: PUSH
7940: LD_INT 3
7942: ARRAY
7943: PPUSH
7944: LD_INT 115
7946: PPUSH
7947: LD_INT 132
7949: PPUSH
7950: LD_INT 0
7952: PPUSH
7953: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
7957: LD_VAR 0 2
7961: PUSH
7962: LD_INT 2
7964: ARRAY
7965: PUSH
7966: LD_VAR 0 2
7970: PUSH
7971: LD_INT 3
7973: ARRAY
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: PPUSH
7979: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
7983: LD_VAR 0 4
7987: PPUSH
7988: LD_INT 83
7990: PPUSH
7991: LD_INT 123
7993: PPUSH
7994: CALL_OW 111
// Wait ( 0 0$01 ) ;
7998: LD_INT 35
8000: PPUSH
8001: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8005: LD_INT 90
8007: PPUSH
8008: LD_INT 144
8010: PPUSH
8011: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8015: LD_VAR 0 5
8019: PPUSH
8020: LD_INT 88
8022: PPUSH
8023: LD_INT 129
8025: PPUSH
8026: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8030: LD_ADDR_VAR 0 3
8034: PUSH
8035: LD_INT 92
8037: PUSH
8038: LD_INT 131
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 88
8047: PUSH
8048: LD_INT 127
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PUSH
8055: LD_INT 91
8057: PUSH
8058: LD_INT 132
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: PUSH
8065: LD_INT 92
8067: PUSH
8068: LD_INT 134
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: LIST
8079: LIST
8080: ST_TO_ADDR
// for i = 1 to sols do
8081: LD_ADDR_VAR 0 6
8085: PUSH
8086: DOUBLE
8087: LD_INT 1
8089: DEC
8090: ST_TO_ADDR
8091: LD_VAR 0 5
8095: PUSH
8096: FOR_TO
8097: IFFALSE 8170
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8099: LD_VAR 0 5
8103: PUSH
8104: LD_VAR 0 6
8108: ARRAY
8109: PPUSH
8110: LD_VAR 0 3
8114: PUSH
8115: LD_VAR 0 6
8119: ARRAY
8120: PUSH
8121: LD_INT 1
8123: ARRAY
8124: PPUSH
8125: LD_VAR 0 3
8129: PUSH
8130: LD_VAR 0 6
8134: ARRAY
8135: PUSH
8136: LD_INT 2
8138: ARRAY
8139: PPUSH
8140: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8144: LD_VAR 0 5
8148: PUSH
8149: LD_VAR 0 6
8153: ARRAY
8154: PPUSH
8155: CALL_OW 197
// AddComHold ( sols ) ;
8159: LD_VAR 0 5
8163: PPUSH
8164: CALL_OW 200
// end ;
8168: GO 8096
8170: POP
8171: POP
// repeat wait ( 0 0$1 ) ;
8172: LD_INT 35
8174: PPUSH
8175: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8179: LD_VAR 0 5
8183: PUSH
8184: LD_INT 1
8186: ARRAY
8187: PPUSH
8188: LD_INT 92
8190: PPUSH
8191: LD_INT 131
8193: PPUSH
8194: CALL_OW 297
8198: PUSH
8199: LD_INT 4
8201: LESS
8202: IFFALSE 8172
// CenterOnXY ( 96 , 139 ) ;
8204: LD_INT 96
8206: PPUSH
8207: LD_INT 139
8209: PPUSH
8210: CALL_OW 84
// wait ( 0 0$3 ) ;
8214: LD_INT 105
8216: PPUSH
8217: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8221: LD_INT 111
8223: PPUSH
8224: LD_INT 135
8226: PPUSH
8227: LD_INT 1
8229: PPUSH
8230: LD_INT 25
8232: NEG
8233: PPUSH
8234: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8238: LD_VAR 0 2
8242: PUSH
8243: LD_INT 2
8245: ARRAY
8246: PPUSH
8247: LD_VAR 0 2
8251: PUSH
8252: LD_INT 1
8254: ARRAY
8255: PPUSH
8256: CALL_OW 250
8260: PUSH
8261: LD_INT 3
8263: PLUS
8264: PPUSH
8265: LD_VAR 0 2
8269: PUSH
8270: LD_INT 1
8272: ARRAY
8273: PPUSH
8274: CALL_OW 251
8278: PPUSH
8279: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8283: LD_VAR 0 2
8287: PUSH
8288: LD_INT 3
8290: ARRAY
8291: PPUSH
8292: LD_INT 7
8294: PPUSH
8295: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8299: LD_VAR 0 2
8303: PUSH
8304: LD_INT 2
8306: ARRAY
8307: PPUSH
8308: LD_VAR 0 2
8312: PUSH
8313: LD_INT 1
8315: ARRAY
8316: PPUSH
8317: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8321: LD_INT 35
8323: PPUSH
8324: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8328: LD_VAR 0 2
8332: PUSH
8333: LD_INT 1
8335: ARRAY
8336: PPUSH
8337: LD_VAR 0 2
8341: PUSH
8342: LD_INT 2
8344: ARRAY
8345: PPUSH
8346: CALL_OW 296
8350: PUSH
8351: LD_INT 5
8353: LESS
8354: IFFALSE 8321
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8356: LD_VAR 0 2
8360: PUSH
8361: LD_INT 1
8363: ARRAY
8364: PPUSH
8365: LD_VAR 0 2
8369: PUSH
8370: LD_INT 2
8372: ARRAY
8373: PPUSH
8374: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8378: LD_VAR 0 2
8382: PUSH
8383: LD_INT 1
8385: ARRAY
8386: PPUSH
8387: LD_STRING D1a-Merc1-1
8389: PPUSH
8390: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8394: LD_VAR 0 2
8398: PUSH
8399: LD_INT 2
8401: ARRAY
8402: PPUSH
8403: LD_STRING D1a-FMerc2-1
8405: PPUSH
8406: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8410: LD_VAR 0 2
8414: PUSH
8415: LD_INT 2
8417: ARRAY
8418: PPUSH
8419: LD_VAR 0 2
8423: PUSH
8424: LD_INT 1
8426: ARRAY
8427: PPUSH
8428: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8432: LD_VAR 0 2
8436: PUSH
8437: LD_INT 1
8439: ARRAY
8440: PPUSH
8441: LD_INT 500
8443: PPUSH
8444: CALL_OW 234
// wait ( 0 0$2 ) ;
8448: LD_INT 70
8450: PPUSH
8451: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8455: LD_VAR 0 2
8459: PUSH
8460: LD_INT 1
8462: ARRAY
8463: PPUSH
8464: LD_INT 2
8466: PPUSH
8467: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8471: LD_INT 10
8473: PPUSH
8474: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8478: LD_VAR 0 2
8482: PUSH
8483: LD_INT 1
8485: ARRAY
8486: PPUSH
8487: LD_STRING D1a-Merc1-2
8489: PPUSH
8490: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8494: LD_INT 7
8496: PPUSH
8497: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8501: LD_VAR 0 2
8505: PUSH
8506: LD_INT 1
8508: ARRAY
8509: PPUSH
8510: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8514: LD_VAR 0 2
8518: PUSH
8519: LD_INT 2
8521: ARRAY
8522: PPUSH
8523: LD_INT 10
8525: PPUSH
8526: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8530: LD_VAR 0 2
8534: PUSH
8535: LD_INT 2
8537: ARRAY
8538: PPUSH
8539: LD_STRING D1a-FMerc2-2
8541: PPUSH
8542: CALL_OW 88
// wait ( 0 0$1 ) ;
8546: LD_INT 35
8548: PPUSH
8549: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8553: LD_INT 7
8555: PPUSH
8556: CALL_OW 85
// wait ( 0 0$2 ) ;
8560: LD_INT 70
8562: PPUSH
8563: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8567: LD_EXP 43
8571: PPUSH
8572: LD_STRING D1a-Saliba-1
8574: PPUSH
8575: CALL_OW 91
// KillUnit ( Saliba ) ;
8579: LD_EXP 43
8583: PPUSH
8584: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8588: LD_VAR 0 2
8592: PUSH
8593: LD_INT 3
8595: ARRAY
8596: PPUSH
8597: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8601: LD_EXP 20
8605: PPUSH
8606: CALL_OW 85
// wait ( 0 0$1 ) ;
8610: LD_INT 35
8612: PPUSH
8613: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
8617: LD_VAR 0 5
8621: PPUSH
8622: LD_INT 88
8624: PPUSH
8625: LD_INT 141
8627: PPUSH
8628: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
8632: LD_VAR 0 5
8636: PPUSH
8637: LD_INT 70
8639: PPUSH
8640: CALL_OW 202
// wait ( 0 0$2 ) ;
8644: LD_INT 70
8646: PPUSH
8647: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
8651: LD_INT 2
8653: PPUSH
8654: LD_INT 1
8656: PPUSH
8657: LD_INT 2
8659: PPUSH
8660: LD_INT 1
8662: PPUSH
8663: CALL_OW 80
// InGameOff ;
8667: CALL_OW 9
// ComWalk ( sols ) ;
8671: LD_VAR 0 5
8675: PPUSH
8676: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
8680: LD_STRING M1
8682: PPUSH
8683: CALL_OW 337
// game_speed := 4 ;
8687: LD_ADDR_OWVAR 65
8691: PUSH
8692: LD_INT 4
8694: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
8695: LD_INT 111
8697: PPUSH
8698: LD_INT 135
8700: PPUSH
8701: LD_INT 1
8703: PPUSH
8704: CALL_OW 331
// SaveForQuickRestart ;
8708: CALL_OW 22
// ar_run := true ;
8712: LD_ADDR_EXP 5
8716: PUSH
8717: LD_INT 1
8719: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8720: LD_INT 35
8722: PPUSH
8723: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
8727: LD_INT 22
8729: PUSH
8730: LD_INT 1
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: PUSH
8737: LD_INT 91
8739: PUSH
8740: LD_INT 7
8742: PUSH
8743: LD_INT 10
8745: PUSH
8746: EMPTY
8747: LIST
8748: LIST
8749: LIST
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: PPUSH
8755: CALL_OW 69
8759: PUSH
8760: LD_INT 7
8762: PPUSH
8763: CALL_OW 256
8767: PUSH
8768: LD_INT 999
8770: LESS
8771: OR
8772: IFFALSE 8720
// if GetSide ( ar_dep_s ) = 2 then
8774: LD_INT 7
8776: PPUSH
8777: CALL_OW 255
8781: PUSH
8782: LD_INT 2
8784: EQUAL
8785: IFFALSE 8797
// SetSide ( ar_dep_s , 1 ) ;
8787: LD_INT 7
8789: PPUSH
8790: LD_INT 1
8792: PPUSH
8793: CALL_OW 235
// end ;
8797: LD_VAR 0 1
8801: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
8802: LD_EXP 5
8806: IFFALSE 9166
8808: GO 8810
8810: DISABLE
8811: LD_INT 0
8813: PPUSH
8814: PPUSH
8815: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
8816: LD_ADDR_VAR 0 2
8820: PUSH
8821: LD_EXP 39
8825: PUSH
8826: LD_EXP 35
8830: PPUSH
8831: LD_INT 2
8833: PUSH
8834: LD_INT 21
8836: PUSH
8837: LD_INT 2
8839: PUSH
8840: EMPTY
8841: LIST
8842: LIST
8843: PUSH
8844: LD_INT 21
8846: PUSH
8847: LD_INT 1
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: LIST
8858: PPUSH
8859: CALL_OW 72
8863: ADD
8864: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
8865: LD_VAR 0 2
8869: PPUSH
8870: LD_INT 5
8872: PPUSH
8873: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
8877: LD_INT 5
8879: PPUSH
8880: LD_INT 1
8882: PPUSH
8883: CALL_OW 343
// k := 1 ;
8887: LD_ADDR_VAR 0 3
8891: PUSH
8892: LD_INT 1
8894: ST_TO_ADDR
// for i in tmp do
8895: LD_ADDR_VAR 0 1
8899: PUSH
8900: LD_VAR 0 2
8904: PUSH
8905: FOR_IN
8906: IFFALSE 8991
// begin if IsInUnit ( i ) then
8908: LD_VAR 0 1
8912: PPUSH
8913: CALL_OW 310
8917: IFFALSE 8928
// ComExitBuilding ( i ) ;
8919: LD_VAR 0 1
8923: PPUSH
8924: CALL_OW 122
// if GetClass ( i ) = 3 then
8928: LD_VAR 0 1
8932: PPUSH
8933: CALL_OW 257
8937: PUSH
8938: LD_INT 3
8940: EQUAL
8941: IFFALSE 8977
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
8943: LD_VAR 0 1
8947: PPUSH
8948: LD_EXP 40
8952: PUSH
8953: LD_VAR 0 3
8957: ARRAY
8958: PPUSH
8959: CALL_OW 180
// k := k + 1 ;
8963: LD_ADDR_VAR 0 3
8967: PUSH
8968: LD_VAR 0 3
8972: PUSH
8973: LD_INT 1
8975: PLUS
8976: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
8977: LD_VAR 0 1
8981: PPUSH
8982: LD_INT 10
8984: PPUSH
8985: CALL_OW 173
// end ;
8989: GO 8905
8991: POP
8992: POP
// ar_patrol := true ;
8993: LD_ADDR_EXP 7
8997: PUSH
8998: LD_INT 1
9000: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9001: LD_INT 10
9003: PPUSH
9004: CALL_OW 67
// for i in tmp do
9008: LD_ADDR_VAR 0 1
9012: PUSH
9013: LD_VAR 0 2
9017: PUSH
9018: FOR_IN
9019: IFFALSE 9047
// if not HasTask ( i ) then
9021: LD_VAR 0 1
9025: PPUSH
9026: CALL_OW 314
9030: NOT
9031: IFFALSE 9045
// ComMoveToArea ( i , escape_area ) ;
9033: LD_VAR 0 1
9037: PPUSH
9038: LD_INT 10
9040: PPUSH
9041: CALL_OW 113
9045: GO 9018
9047: POP
9048: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9049: LD_ADDR_VAR 0 3
9053: PUSH
9054: LD_VAR 0 2
9058: PPUSH
9059: LD_INT 95
9061: PUSH
9062: LD_INT 10
9064: PUSH
9065: EMPTY
9066: LIST
9067: LIST
9068: PPUSH
9069: CALL_OW 72
9073: ST_TO_ADDR
// if k then
9074: LD_VAR 0 3
9078: IFFALSE 9147
// for i in k do
9080: LD_ADDR_VAR 0 1
9084: PUSH
9085: LD_VAR 0 3
9089: PUSH
9090: FOR_IN
9091: IFFALSE 9145
// begin if IsInUnit ( i ) then
9093: LD_VAR 0 1
9097: PPUSH
9098: CALL_OW 310
9102: IFFALSE 9118
// RemoveUnit ( IsInUnit ( i ) ) ;
9104: LD_VAR 0 1
9108: PPUSH
9109: CALL_OW 310
9113: PPUSH
9114: CALL_OW 64
// RemoveUnit ( i ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: CALL_OW 64
// tmp := tmp diff i ;
9127: LD_ADDR_VAR 0 2
9131: PUSH
9132: LD_VAR 0 2
9136: PUSH
9137: LD_VAR 0 1
9141: DIFF
9142: ST_TO_ADDR
// end ;
9143: GO 9090
9145: POP
9146: POP
// until tmp = [ ] ;
9147: LD_VAR 0 2
9151: PUSH
9152: EMPTY
9153: EQUAL
9154: IFFALSE 9001
// ChangeSideFog ( 5 , 5 ) ;
9156: LD_INT 5
9158: PPUSH
9159: LD_INT 5
9161: PPUSH
9162: CALL_OW 343
// end ;
9166: PPOPN 3
9168: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9169: LD_EXP 7
9173: IFFALSE 9463
9175: GO 9177
9177: DISABLE
9178: LD_INT 0
9180: PPUSH
9181: PPUSH
9182: PPUSH
// begin uc_side := 2 ;
9183: LD_ADDR_OWVAR 20
9187: PUSH
9188: LD_INT 2
9190: ST_TO_ADDR
// uc_nation := 2 ;
9191: LD_ADDR_OWVAR 21
9195: PUSH
9196: LD_INT 2
9198: ST_TO_ADDR
// InitHc ;
9199: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9203: LD_INT 1
9205: PPUSH
9206: LD_INT 1
9208: PPUSH
9209: LD_INT 6
9211: PPUSH
9212: CALL_OW 380
// un := CreateHuman ;
9216: LD_ADDR_VAR 0 2
9220: PUSH
9221: CALL_OW 44
9225: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9226: LD_INT 14
9228: PPUSH
9229: LD_INT 1
9231: PPUSH
9232: LD_INT 1
9234: PPUSH
9235: LD_INT 27
9237: PPUSH
9238: LD_INT 98
9240: PPUSH
9241: CALL 53576 0 5
// veh := CreateVehicle ;
9245: LD_ADDR_VAR 0 3
9249: PUSH
9250: CALL_OW 45
9254: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9255: LD_VAR 0 3
9259: PPUSH
9260: LD_INT 4
9262: PPUSH
9263: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9267: LD_VAR 0 3
9271: PPUSH
9272: LD_INT 179
9274: PPUSH
9275: LD_INT 135
9277: PPUSH
9278: LD_INT 0
9280: PPUSH
9281: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9285: LD_VAR 0 2
9289: PPUSH
9290: LD_VAR 0 3
9294: PPUSH
9295: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9299: LD_VAR 0 2
9303: PPUSH
9304: LD_INT 126
9306: PPUSH
9307: LD_INT 133
9309: PPUSH
9310: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9314: LD_INT 10
9316: PPUSH
9317: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9321: LD_INT 1
9323: PPUSH
9324: LD_VAR 0 3
9328: PPUSH
9329: CALL_OW 292
9333: PUSH
9334: LD_VAR 0 3
9338: PPUSH
9339: LD_INT 7
9341: PPUSH
9342: CALL_OW 296
9346: PUSH
9347: LD_INT 9
9349: LESS
9350: OR
9351: IFFALSE 9314
// ComHold ( veh ) ;
9353: LD_VAR 0 3
9357: PPUSH
9358: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9362: LD_VAR 0 2
9366: PPUSH
9367: LD_STRING D2aa-Ar1-1
9369: PPUSH
9370: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9374: LD_VAR 0 2
9378: PPUSH
9379: LD_INT 177
9381: PPUSH
9382: LD_INT 96
9384: PPUSH
9385: CALL_OW 111
// AddComExitVehicle ( un ) ;
9389: LD_VAR 0 2
9393: PPUSH
9394: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9398: LD_INT 35
9400: PPUSH
9401: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9405: LD_VAR 0 2
9409: PPUSH
9410: LD_INT 204
9412: PPUSH
9413: CALL_OW 296
9417: PUSH
9418: LD_INT 15
9420: LESS
9421: IFFALSE 9398
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9423: LD_ADDR_EXP 49
9427: PUSH
9428: LD_EXP 49
9432: PPUSH
9433: LD_INT 3
9435: PUSH
9436: LD_EXP 49
9440: PUSH
9441: LD_INT 3
9443: ARRAY
9444: PUSH
9445: LD_INT 1
9447: PLUS
9448: PUSH
9449: EMPTY
9450: LIST
9451: LIST
9452: PPUSH
9453: LD_VAR 0 2
9457: PPUSH
9458: CALL 53698 0 3
9462: ST_TO_ADDR
// end ;
9463: PPOPN 3
9465: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9466: LD_INT 7
9468: PPUSH
9469: CALL_OW 255
9473: PUSH
9474: LD_INT 1
9476: EQUAL
9477: PUSH
9478: LD_INT 7
9480: PPUSH
9481: CALL_OW 301
9485: OR
9486: IFFALSE 11910
9488: GO 9490
9490: DISABLE
9491: LD_INT 0
9493: PPUSH
9494: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9495: LD_ADDR_VAR 0 1
9499: PUSH
9500: LD_EXP 35
9504: PPUSH
9505: LD_INT 21
9507: PUSH
9508: LD_INT 3
9510: PUSH
9511: EMPTY
9512: LIST
9513: LIST
9514: PPUSH
9515: CALL_OW 72
9519: PUSH
9520: FOR_IN
9521: IFFALSE 9537
// SetSide ( i , 1 ) ;
9523: LD_VAR 0 1
9527: PPUSH
9528: LD_INT 1
9530: PPUSH
9531: CALL_OW 235
9535: GO 9520
9537: POP
9538: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9539: LD_ADDR_VAR 0 2
9543: PUSH
9544: LD_INT 46
9546: PUSH
9547: LD_INT 41
9549: PUSH
9550: EMPTY
9551: LIST
9552: LIST
9553: PUSH
9554: LD_INT 50
9556: PUSH
9557: LD_INT 25
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: PUSH
9564: LD_INT 57
9566: PUSH
9567: LD_INT 75
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: PUSH
9574: LD_INT 75
9576: PUSH
9577: LD_INT 89
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: PUSH
9584: LD_INT 51
9586: PUSH
9587: LD_INT 45
9589: PUSH
9590: EMPTY
9591: LIST
9592: LIST
9593: PUSH
9594: LD_INT 95
9596: PUSH
9597: LD_INT 95
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 84
9606: PUSH
9607: LD_INT 77
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: PUSH
9614: LD_INT 101
9616: PUSH
9617: LD_INT 76
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: PUSH
9624: LD_INT 118
9626: PUSH
9627: LD_INT 81
9629: PUSH
9630: EMPTY
9631: LIST
9632: LIST
9633: PUSH
9634: LD_INT 139
9636: PUSH
9637: LD_INT 97
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: PUSH
9644: LD_INT 129
9646: PUSH
9647: LD_INT 114
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: PUSH
9654: LD_INT 154
9656: PUSH
9657: LD_INT 111
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: LIST
9668: LIST
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: ST_TO_ADDR
// base_captured := true ;
9678: LD_ADDR_EXP 6
9682: PUSH
9683: LD_INT 1
9685: ST_TO_ADDR
// DialogueOn ;
9686: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
9690: LD_EXP 20
9694: PPUSH
9695: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
9699: LD_EXP 20
9703: PPUSH
9704: LD_STRING D2-JMM-1
9706: PPUSH
9707: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
9711: LD_EXP 29
9715: PPUSH
9716: LD_STRING D2-Pow-1
9718: PPUSH
9719: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
9723: LD_EXP 20
9727: PPUSH
9728: LD_STRING D2-JMM-2
9730: PPUSH
9731: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
9735: LD_EXP 29
9739: PPUSH
9740: LD_STRING D2-Pow-2
9742: PPUSH
9743: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
9747: LD_EXP 20
9751: PPUSH
9752: LD_STRING D2-JMM-3
9754: PPUSH
9755: CALL_OW 88
// DialogueOff ;
9759: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
9763: LD_STRING M2
9765: PPUSH
9766: CALL_OW 337
// Wait ( 0 0$2 ) ;
9770: LD_INT 70
9772: PPUSH
9773: CALL_OW 67
// if IsOk ( Gary ) then
9777: LD_EXP 31
9781: PPUSH
9782: CALL_OW 302
9786: IFFALSE 9800
// Say ( Gary , D2a-Gary-1 ) ;
9788: LD_EXP 31
9792: PPUSH
9793: LD_STRING D2a-Gary-1
9795: PPUSH
9796: CALL_OW 88
// if IsOk ( Bobby ) then
9800: LD_EXP 23
9804: PPUSH
9805: CALL_OW 302
9809: IFFALSE 9823
// Say ( Bobby , D2a-Bobby-1 ) ;
9811: LD_EXP 23
9815: PPUSH
9816: LD_STRING D2a-Bobby-1
9818: PPUSH
9819: CALL_OW 88
// if IsOk ( Cyrus ) then
9823: LD_EXP 24
9827: PPUSH
9828: CALL_OW 302
9832: IFFALSE 9846
// Say ( Cyrus , D2a-Cyrus-1 ) ;
9834: LD_EXP 24
9838: PPUSH
9839: LD_STRING D2a-Cyrus-1
9841: PPUSH
9842: CALL_OW 88
// if IsOk ( Lisa ) then
9846: LD_EXP 21
9850: PPUSH
9851: CALL_OW 302
9855: IFFALSE 9869
// Say ( Lisa , D2a-Lisa-1 ) ;
9857: LD_EXP 21
9861: PPUSH
9862: LD_STRING D2a-Lisa-1
9864: PPUSH
9865: CALL_OW 88
// if IsOk ( Frank ) then
9869: LD_EXP 32
9873: PPUSH
9874: CALL_OW 302
9878: IFFALSE 9892
// Say ( Frank , D2a-Frank-1 ) ;
9880: LD_EXP 32
9884: PPUSH
9885: LD_STRING D2a-Frank-1
9887: PPUSH
9888: CALL_OW 88
// if IsOk ( Cornel ) then
9892: LD_EXP 30
9896: PPUSH
9897: CALL_OW 302
9901: IFFALSE 9915
// Say ( Cornel , D2a-Corn-1 ) ;
9903: LD_EXP 30
9907: PPUSH
9908: LD_STRING D2a-Corn-1
9910: PPUSH
9911: CALL_OW 88
// if IsOk ( Donaldson ) then
9915: LD_EXP 22
9919: PPUSH
9920: CALL_OW 302
9924: IFFALSE 9938
// Say ( Donaldson , D2a-Don-1 ) ;
9926: LD_EXP 22
9930: PPUSH
9931: LD_STRING D2a-Don-1
9933: PPUSH
9934: CALL_OW 88
// if IsOk ( Brown ) then
9938: LD_EXP 26
9942: PPUSH
9943: CALL_OW 302
9947: IFFALSE 9961
// Say ( Brown , D2a-Brown-1 ) ;
9949: LD_EXP 26
9953: PPUSH
9954: LD_STRING D2a-Brown-1
9956: PPUSH
9957: CALL_OW 88
// Wait ( 0 0$30 ) ;
9961: LD_INT 1050
9963: PPUSH
9964: CALL_OW 67
// if IsOk ( Frank ) then
9968: LD_EXP 32
9972: PPUSH
9973: CALL_OW 302
9977: IFFALSE 10243
// begin DialogueOn ;
9979: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
9983: LD_EXP 20
9987: PUSH
9988: LD_EXP 32
9992: PUSH
9993: EMPTY
9994: LIST
9995: LIST
9996: PPUSH
9997: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10001: LD_EXP 32
10005: PPUSH
10006: LD_STRING D3F-Frank-1
10008: PPUSH
10009: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10013: LD_EXP 20
10017: PPUSH
10018: LD_STRING D3F-JMM-1
10020: PPUSH
10021: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10025: LD_EXP 32
10029: PPUSH
10030: LD_STRING D3F-Frank-2
10032: PPUSH
10033: CALL_OW 88
// case Query ( QFrank ) of 1 :
10037: LD_STRING QFrank
10039: PPUSH
10040: CALL_OW 97
10044: PUSH
10045: LD_INT 1
10047: DOUBLE
10048: EQUAL
10049: IFTRUE 10053
10051: GO 10076
10053: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10054: LD_EXP 20
10058: PPUSH
10059: LD_STRING D3Fa-JMM-1
10061: PPUSH
10062: CALL_OW 88
// us_scout := 1 ;
10066: LD_ADDR_EXP 8
10070: PUSH
10071: LD_INT 1
10073: ST_TO_ADDR
// end ; 2 :
10074: GO 10239
10076: LD_INT 2
10078: DOUBLE
10079: EQUAL
10080: IFTRUE 10084
10082: GO 10206
10084: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10085: LD_EXP 20
10089: PPUSH
10090: LD_STRING D3Fb-JMM-1
10092: PPUSH
10093: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10097: LD_EXP 32
10101: PPUSH
10102: LD_STRING D3Fb-Frank-1
10104: PPUSH
10105: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10109: LD_STRING QFrank2
10111: PPUSH
10112: CALL_OW 97
10116: PUSH
10117: LD_INT 1
10119: DOUBLE
10120: EQUAL
10121: IFTRUE 10125
10123: GO 10172
10125: POP
// begin us_scout := 2 ;
10126: LD_ADDR_EXP 8
10130: PUSH
10131: LD_INT 2
10133: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10134: LD_EXP 20
10138: PPUSH
10139: LD_STRING D3Fba-JMM-1
10141: PPUSH
10142: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10146: LD_EXP 32
10150: PPUSH
10151: LD_STRING D3Fba-Frank-1
10153: PPUSH
10154: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10158: LD_EXP 20
10162: PPUSH
10163: LD_STRING D3Fba-JMM-2
10165: PPUSH
10166: CALL_OW 88
// end ; 2 :
10170: GO 10204
10172: LD_INT 2
10174: DOUBLE
10175: EQUAL
10176: IFTRUE 10180
10178: GO 10203
10180: POP
// begin us_scout := 0 ;
10181: LD_ADDR_EXP 8
10185: PUSH
10186: LD_INT 0
10188: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10189: LD_EXP 20
10193: PPUSH
10194: LD_STRING D3Fbb-JMM-1
10196: PPUSH
10197: CALL_OW 88
// end ; end ;
10201: GO 10204
10203: POP
// end ; 3 :
10204: GO 10239
10206: LD_INT 3
10208: DOUBLE
10209: EQUAL
10210: IFTRUE 10214
10212: GO 10238
10214: POP
// begin us_scout := - 1 ;
10215: LD_ADDR_EXP 8
10219: PUSH
10220: LD_INT 1
10222: NEG
10223: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10224: LD_EXP 20
10228: PPUSH
10229: LD_STRING D3Fc-JMM-1
10231: PPUSH
10232: CALL_OW 88
// end ; end ;
10236: GO 10239
10238: POP
// DialogueOff ;
10239: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10243: LD_EXP 8
10247: PUSH
10248: LD_INT 1
10250: NEG
10251: PUSH
10252: LD_INT 0
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: IN
10259: IFFALSE 10263
// exit ;
10261: GO 11910
// if us_scout in [ 1 , 2 ] then
10263: LD_EXP 8
10267: PUSH
10268: LD_INT 1
10270: PUSH
10271: LD_INT 2
10273: PUSH
10274: EMPTY
10275: LIST
10276: LIST
10277: IN
10278: IFFALSE 10977
// begin if IsInUnit ( Frank ) then
10280: LD_EXP 32
10284: PPUSH
10285: CALL_OW 310
10289: IFFALSE 10300
// ComExitBuilding ( Frank ) ;
10291: LD_EXP 32
10295: PPUSH
10296: CALL_OW 122
// if IsDrivenBy ( Frank ) then
10300: LD_EXP 32
10304: PPUSH
10305: CALL_OW 311
10309: IFFALSE 10320
// ComExitVehicle ( Frank ) ;
10311: LD_EXP 32
10315: PPUSH
10316: CALL_OW 121
// SetSide ( Frank , 4 ) ;
10320: LD_EXP 32
10324: PPUSH
10325: LD_INT 4
10327: PPUSH
10328: CALL_OW 235
// wait ( 0 0$1 ) ;
10332: LD_INT 35
10334: PPUSH
10335: CALL_OW 67
// if us_scout = 2 then
10339: LD_EXP 8
10343: PUSH
10344: LD_INT 2
10346: EQUAL
10347: IFFALSE 10715
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10349: LD_EXP 32
10353: PPUSH
10354: LD_INT 75
10356: PPUSH
10357: LD_INT 63
10359: PPUSH
10360: CALL_OW 111
// AddComHold ( Frank ) ;
10364: LD_EXP 32
10368: PPUSH
10369: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10373: LD_EXP 32
10377: PPUSH
10378: LD_INT 770
10380: PPUSH
10381: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10385: LD_EXP 32
10389: PPUSH
10390: LD_INT 100
10392: PPUSH
10393: LD_INT 75
10395: PPUSH
10396: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10400: LD_EXP 32
10404: PPUSH
10405: LD_INT 123
10407: PPUSH
10408: LD_INT 103
10410: PPUSH
10411: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10415: LD_EXP 32
10419: PPUSH
10420: LD_INT 138
10422: PPUSH
10423: LD_INT 108
10425: PPUSH
10426: CALL_OW 171
// AddComHold ( Frank ) ;
10430: LD_EXP 32
10434: PPUSH
10435: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10439: LD_INT 35
10441: PPUSH
10442: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10446: LD_EXP 32
10450: PPUSH
10451: LD_INT 138
10453: PPUSH
10454: LD_INT 108
10456: PPUSH
10457: CALL_OW 307
10461: IFFALSE 10439
// AddComMoveXY ( Frank , 125 , 132 ) ;
10463: LD_EXP 32
10467: PPUSH
10468: LD_INT 125
10470: PPUSH
10471: LD_INT 132
10473: PPUSH
10474: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10478: LD_INT 35
10480: PPUSH
10481: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10485: LD_INT 1
10487: PPUSH
10488: LD_EXP 32
10492: PPUSH
10493: CALL_OW 292
10497: PUSH
10498: LD_EXP 32
10502: PPUSH
10503: LD_INT 7
10505: PPUSH
10506: CALL_OW 296
10510: PUSH
10511: LD_INT 7
10513: LESS
10514: OR
10515: IFFALSE 10478
// DialogueOn ;
10517: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10521: LD_EXP 32
10525: PPUSH
10526: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10530: LD_INT 10
10532: PPUSH
10533: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10537: LD_EXP 20
10541: PPUSH
10542: LD_STRING D4Fa-JMM-1
10544: PPUSH
10545: CALL_OW 88
// for i in points do
10549: LD_ADDR_VAR 0 1
10553: PUSH
10554: LD_VAR 0 2
10558: PUSH
10559: FOR_IN
10560: IFFALSE 10618
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10562: LD_VAR 0 1
10566: PUSH
10567: LD_INT 1
10569: ARRAY
10570: PPUSH
10571: LD_VAR 0 1
10575: PUSH
10576: LD_INT 2
10578: ARRAY
10579: PPUSH
10580: LD_INT 1
10582: PPUSH
10583: LD_INT 20
10585: NEG
10586: PPUSH
10587: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10591: LD_VAR 0 1
10595: PUSH
10596: LD_INT 1
10598: ARRAY
10599: PPUSH
10600: LD_VAR 0 1
10604: PUSH
10605: LD_INT 2
10607: ARRAY
10608: PPUSH
10609: LD_INT 1
10611: PPUSH
10612: CALL_OW 331
// end ;
10616: GO 10559
10618: POP
10619: POP
// dwait ( 0 0$0.5 ) ;
10620: LD_INT 18
10622: PPUSH
10623: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
10627: LD_INT 42
10629: PPUSH
10630: LD_INT 27
10632: PPUSH
10633: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
10637: LD_EXP 32
10641: PPUSH
10642: LD_STRING D4Fa-Frank-1
10644: PPUSH
10645: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
10649: LD_INT 18
10651: PPUSH
10652: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
10656: LD_EXP 20
10660: PPUSH
10661: LD_STRING D4Fa-JMM-2
10663: PPUSH
10664: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
10668: LD_INT 118
10670: PPUSH
10671: LD_INT 80
10673: PPUSH
10674: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
10678: LD_EXP 32
10682: PPUSH
10683: LD_STRING D4Fa-Frank-2
10685: PPUSH
10686: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
10690: LD_INT 10
10692: PPUSH
10693: CALL_OW 68
// DialogueOff ;
10697: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10701: LD_EXP 32
10705: PPUSH
10706: LD_INT 1
10708: PPUSH
10709: CALL_OW 235
// end else
10713: GO 10977
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
10715: LD_INT 2
10717: PPUSH
10718: LD_INT 4
10720: PPUSH
10721: LD_INT 2
10723: PPUSH
10724: LD_INT 1
10726: PPUSH
10727: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
10731: LD_EXP 32
10735: PPUSH
10736: LD_INT 75
10738: PPUSH
10739: LD_INT 63
10741: PPUSH
10742: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
10746: LD_EXP 32
10750: PPUSH
10751: LD_INT 175
10753: PPUSH
10754: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
10758: LD_EXP 32
10762: PPUSH
10763: LD_INT 102
10765: PPUSH
10766: LD_INT 76
10768: PPUSH
10769: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
10773: LD_EXP 32
10777: PPUSH
10778: LD_INT 108
10780: PPUSH
10781: LD_INT 70
10783: PPUSH
10784: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10788: LD_INT 35
10790: PPUSH
10791: CALL_OW 67
// until See ( 2 , Frank ) ;
10795: LD_INT 2
10797: PPUSH
10798: LD_EXP 32
10802: PPUSH
10803: CALL_OW 292
10807: IFFALSE 10788
// ComMoveXY ( Frank , 112 , 118 ) ;
10809: LD_EXP 32
10813: PPUSH
10814: LD_INT 112
10816: PPUSH
10817: LD_INT 118
10819: PPUSH
10820: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
10824: LD_EXP 32
10828: PPUSH
10829: CALL_OW 256
10833: PUSH
10834: LD_INT 750
10836: GREATEREQUAL
10837: IFFALSE 10851
// SetLives ( Frank , 700 ) ;
10839: LD_EXP 32
10843: PPUSH
10844: LD_INT 700
10846: PPUSH
10847: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
10851: LD_INT 35
10853: PPUSH
10854: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
10858: LD_INT 1
10860: PPUSH
10861: LD_EXP 32
10865: PPUSH
10866: CALL_OW 292
10870: PUSH
10871: LD_EXP 32
10875: PPUSH
10876: LD_INT 7
10878: PPUSH
10879: CALL_OW 296
10883: PUSH
10884: LD_INT 17
10886: LESS
10887: OR
10888: IFFALSE 10851
// DialogueOn ;
10890: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10894: LD_EXP 32
10898: PPUSH
10899: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
10903: LD_EXP 32
10907: PPUSH
10908: LD_STRING D4Fb-Frank-1
10910: PPUSH
10911: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
10915: LD_EXP 20
10919: PPUSH
10920: LD_STRING D4Fb-JMM-1
10922: PPUSH
10923: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
10927: LD_INT 2
10929: PPUSH
10930: LD_STRING D4Fb-FSci1-1
10932: PPUSH
10933: CALL 15655 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
10937: LD_EXP 32
10941: PPUSH
10942: LD_STRING D4Fb-Frank-2
10944: PPUSH
10945: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
10949: LD_EXP 20
10953: PPUSH
10954: LD_STRING D4Fb-JMM-2
10956: PPUSH
10957: CALL_OW 88
// DialogueOff ;
10961: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10965: LD_EXP 32
10969: PPUSH
10970: LD_INT 1
10972: PPUSH
10973: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
10977: LD_EXP 33
10981: PPUSH
10982: CALL_OW 302
10986: PUSH
10987: LD_EXP 32
10991: NOT
10992: AND
10993: IFFALSE 11141
// begin DialogueOn ;
10995: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
10999: LD_EXP 20
11003: PUSH
11004: LD_EXP 33
11008: PUSH
11009: EMPTY
11010: LIST
11011: LIST
11012: PPUSH
11013: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11017: LD_EXP 33
11021: PPUSH
11022: LD_STRING D3Y-Yam-1
11024: PPUSH
11025: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11029: LD_EXP 20
11033: PPUSH
11034: LD_STRING D3Y-JMM-1
11036: PPUSH
11037: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11041: LD_EXP 33
11045: PPUSH
11046: LD_STRING D3Y-Yam-2
11048: PPUSH
11049: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11053: LD_STRING QYamoko
11055: PPUSH
11056: CALL_OW 97
11060: PUSH
11061: LD_INT 1
11063: DOUBLE
11064: EQUAL
11065: IFTRUE 11069
11067: GO 11104
11069: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11070: LD_EXP 20
11074: PPUSH
11075: LD_STRING D3Ya-JMM-1
11077: PPUSH
11078: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11082: LD_EXP 33
11086: PPUSH
11087: LD_STRING D3Ya-Yam-1
11089: PPUSH
11090: CALL_OW 88
// us_scout := 1 ;
11094: LD_ADDR_EXP 8
11098: PUSH
11099: LD_INT 1
11101: ST_TO_ADDR
// end ; 2 :
11102: GO 11137
11104: LD_INT 2
11106: DOUBLE
11107: EQUAL
11108: IFTRUE 11112
11110: GO 11136
11112: POP
// begin us_scout := - 1 ;
11113: LD_ADDR_EXP 8
11117: PUSH
11118: LD_INT 1
11120: NEG
11121: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11122: LD_EXP 20
11126: PPUSH
11127: LD_STRING D3Yb-JMM-1
11129: PPUSH
11130: CALL_OW 88
// end ; end ;
11134: GO 11137
11136: POP
// DialogueOff ;
11137: CALL_OW 7
// end ; if Frank then
11141: LD_EXP 32
11145: IFFALSE 11149
// exit ;
11147: GO 11910
// if us_scout in [ - 1 , 0 ] then
11149: LD_EXP 8
11153: PUSH
11154: LD_INT 1
11156: NEG
11157: PUSH
11158: LD_INT 0
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: IN
11165: IFFALSE 11169
// exit ;
11167: GO 11910
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11169: LD_ADDR_EXP 8
11173: PUSH
11174: LD_INT 2
11176: PUSH
11177: LD_INT 2
11179: PUSH
11180: LD_INT 1
11182: PUSH
11183: EMPTY
11184: LIST
11185: LIST
11186: LIST
11187: PUSH
11188: LD_OWVAR 67
11192: ARRAY
11193: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11194: LD_EXP 8
11198: PUSH
11199: LD_INT 1
11201: PUSH
11202: LD_INT 2
11204: PUSH
11205: EMPTY
11206: LIST
11207: LIST
11208: IN
11209: IFFALSE 11910
// begin if IsInUnit ( Kikuchi ) then
11211: LD_EXP 33
11215: PPUSH
11216: CALL_OW 310
11220: IFFALSE 11231
// ComExitBuilding ( Kikuchi ) ;
11222: LD_EXP 33
11226: PPUSH
11227: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11231: LD_EXP 33
11235: PPUSH
11236: CALL_OW 311
11240: IFFALSE 11251
// ComExitVehicle ( Kikuchi ) ;
11242: LD_EXP 33
11246: PPUSH
11247: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11251: LD_EXP 33
11255: PPUSH
11256: LD_INT 4
11258: PPUSH
11259: CALL_OW 235
// wait ( 0 0$1 ) ;
11263: LD_INT 35
11265: PPUSH
11266: CALL_OW 67
// if us_scout = 2 then
11270: LD_EXP 8
11274: PUSH
11275: LD_INT 2
11277: EQUAL
11278: IFFALSE 11658
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11280: LD_EXP 33
11284: PPUSH
11285: LD_INT 75
11287: PPUSH
11288: LD_INT 63
11290: PPUSH
11291: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11295: LD_EXP 33
11299: PPUSH
11300: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11304: LD_EXP 33
11308: PPUSH
11309: LD_INT 770
11311: PPUSH
11312: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11316: LD_EXP 33
11320: PPUSH
11321: LD_INT 100
11323: PPUSH
11324: LD_INT 75
11326: PPUSH
11327: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11331: LD_EXP 33
11335: PPUSH
11336: LD_INT 123
11338: PPUSH
11339: LD_INT 103
11341: PPUSH
11342: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11346: LD_EXP 33
11350: PPUSH
11351: LD_INT 138
11353: PPUSH
11354: LD_INT 108
11356: PPUSH
11357: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11361: LD_EXP 33
11365: PPUSH
11366: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11370: LD_INT 35
11372: PPUSH
11373: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11377: LD_EXP 33
11381: PPUSH
11382: LD_INT 138
11384: PPUSH
11385: LD_INT 108
11387: PPUSH
11388: CALL_OW 307
11392: IFFALSE 11370
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11394: LD_EXP 33
11398: PPUSH
11399: LD_INT 125
11401: PPUSH
11402: LD_INT 132
11404: PPUSH
11405: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11409: LD_INT 35
11411: PPUSH
11412: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11416: LD_INT 1
11418: PPUSH
11419: LD_EXP 33
11423: PPUSH
11424: CALL_OW 292
11428: PUSH
11429: LD_EXP 33
11433: PPUSH
11434: LD_INT 7
11436: PPUSH
11437: CALL_OW 296
11441: PUSH
11442: LD_INT 7
11444: LESS
11445: OR
11446: IFFALSE 11409
// DialogueOn ;
11448: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11452: LD_EXP 33
11456: PPUSH
11457: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11461: LD_INT 10
11463: PPUSH
11464: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11468: LD_EXP 33
11472: PPUSH
11473: LD_STRING D4Ya-Yam-1
11475: PPUSH
11476: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11480: LD_EXP 20
11484: PPUSH
11485: LD_STRING D4Ya-JMM-1
11487: PPUSH
11488: CALL_OW 88
// for i in points do
11492: LD_ADDR_VAR 0 1
11496: PUSH
11497: LD_VAR 0 2
11501: PUSH
11502: FOR_IN
11503: IFFALSE 11561
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11505: LD_VAR 0 1
11509: PUSH
11510: LD_INT 1
11512: ARRAY
11513: PPUSH
11514: LD_VAR 0 1
11518: PUSH
11519: LD_INT 2
11521: ARRAY
11522: PPUSH
11523: LD_INT 1
11525: PPUSH
11526: LD_INT 20
11528: NEG
11529: PPUSH
11530: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11534: LD_VAR 0 1
11538: PUSH
11539: LD_INT 1
11541: ARRAY
11542: PPUSH
11543: LD_VAR 0 1
11547: PUSH
11548: LD_INT 2
11550: ARRAY
11551: PPUSH
11552: LD_INT 1
11554: PPUSH
11555: CALL_OW 331
// end ;
11559: GO 11502
11561: POP
11562: POP
// dwait ( 0 0$0.5 ) ;
11563: LD_INT 18
11565: PPUSH
11566: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11570: LD_INT 42
11572: PPUSH
11573: LD_INT 27
11575: PPUSH
11576: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11580: LD_EXP 33
11584: PPUSH
11585: LD_STRING D4Ya-Yam-2
11587: PPUSH
11588: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11592: LD_INT 18
11594: PPUSH
11595: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11599: LD_INT 118
11601: PPUSH
11602: LD_INT 80
11604: PPUSH
11605: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11609: LD_EXP 20
11613: PPUSH
11614: LD_STRING D4Ya-JMM-2
11616: PPUSH
11617: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
11621: LD_EXP 33
11625: PPUSH
11626: LD_STRING D4Ya-Yam-3
11628: PPUSH
11629: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11633: LD_INT 10
11635: PPUSH
11636: CALL_OW 68
// DialogueOff ;
11640: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11644: LD_EXP 33
11648: PPUSH
11649: LD_INT 1
11651: PPUSH
11652: CALL_OW 235
// end else
11656: GO 11910
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11658: LD_INT 2
11660: PPUSH
11661: LD_INT 4
11663: PPUSH
11664: LD_INT 2
11666: PPUSH
11667: LD_INT 1
11669: PPUSH
11670: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
11674: LD_EXP 33
11678: PPUSH
11679: LD_INT 75
11681: PPUSH
11682: LD_INT 63
11684: PPUSH
11685: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
11689: LD_EXP 33
11693: PPUSH
11694: LD_INT 175
11696: PPUSH
11697: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
11701: LD_EXP 33
11705: PPUSH
11706: LD_INT 102
11708: PPUSH
11709: LD_INT 76
11711: PPUSH
11712: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
11716: LD_EXP 33
11720: PPUSH
11721: LD_INT 108
11723: PPUSH
11724: LD_INT 70
11726: PPUSH
11727: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11731: LD_INT 35
11733: PPUSH
11734: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
11738: LD_INT 2
11740: PPUSH
11741: LD_EXP 33
11745: PPUSH
11746: CALL_OW 292
11750: IFFALSE 11731
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
11752: LD_EXP 33
11756: PPUSH
11757: LD_INT 112
11759: PPUSH
11760: LD_INT 118
11762: PPUSH
11763: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
11767: LD_EXP 33
11771: PPUSH
11772: CALL_OW 256
11776: PUSH
11777: LD_INT 750
11779: GREATEREQUAL
11780: IFFALSE 11794
// SetLives ( Kikuchi , 700 ) ;
11782: LD_EXP 33
11786: PPUSH
11787: LD_INT 700
11789: PPUSH
11790: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11794: LD_INT 35
11796: PPUSH
11797: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
11801: LD_INT 1
11803: PPUSH
11804: LD_EXP 33
11808: PPUSH
11809: CALL_OW 292
11813: PUSH
11814: LD_EXP 33
11818: PPUSH
11819: LD_INT 7
11821: PPUSH
11822: CALL_OW 296
11826: PUSH
11827: LD_INT 17
11829: LESS
11830: OR
11831: IFFALSE 11794
// DialogueOn ;
11833: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11837: LD_EXP 33
11841: PPUSH
11842: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
11846: LD_EXP 33
11850: PPUSH
11851: LD_STRING D4Yb-Yam-1
11853: PPUSH
11854: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
11858: LD_EXP 20
11862: PPUSH
11863: LD_STRING D4Yb-JMM-1
11865: PPUSH
11866: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
11870: LD_EXP 33
11874: PPUSH
11875: LD_STRING D4Yb-Yam-2
11877: PPUSH
11878: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
11882: LD_EXP 20
11886: PPUSH
11887: LD_STRING D4Yb-JMM-2
11889: PPUSH
11890: CALL_OW 88
// DialogueOff ;
11894: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11898: LD_EXP 33
11902: PPUSH
11903: LD_INT 1
11905: PPUSH
11906: CALL_OW 235
// end ; end ; end ;
11910: PPOPN 2
11912: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
11913: LD_EXP 6
11917: IFFALSE 12950
11919: GO 11921
11921: DISABLE
11922: LD_INT 0
11924: PPUSH
11925: PPUSH
11926: PPUSH
11927: PPUSH
// begin enable ;
11928: ENABLE
// if not seen [ 1 ] then
11929: LD_EXP 9
11933: PUSH
11934: LD_INT 1
11936: ARRAY
11937: NOT
11938: IFFALSE 12118
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
11940: LD_ADDR_VAR 0 2
11944: PUSH
11945: LD_INT 22
11947: PUSH
11948: LD_INT 2
11950: PUSH
11951: EMPTY
11952: LIST
11953: LIST
11954: PUSH
11955: LD_INT 2
11957: PUSH
11958: LD_INT 25
11960: PUSH
11961: LD_INT 11
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: PUSH
11968: LD_INT 33
11970: PUSH
11971: LD_INT 4
11973: PUSH
11974: EMPTY
11975: LIST
11976: LIST
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: LIST
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PPUSH
11987: CALL_OW 69
11991: ST_TO_ADDR
// if tmp then
11992: LD_VAR 0 2
11996: IFFALSE 12118
// for i in tmp do
11998: LD_ADDR_VAR 0 1
12002: PUSH
12003: LD_VAR 0 2
12007: PUSH
12008: FOR_IN
12009: IFFALSE 12116
// if See ( 1 , i ) then
12011: LD_INT 1
12013: PPUSH
12014: LD_VAR 0 1
12018: PPUSH
12019: CALL_OW 292
12023: IFFALSE 12114
// begin seen := Replace ( seen , 1 , true ) ;
12025: LD_ADDR_EXP 9
12029: PUSH
12030: LD_EXP 9
12034: PPUSH
12035: LD_INT 1
12037: PPUSH
12038: LD_INT 1
12040: PPUSH
12041: CALL_OW 1
12045: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12046: LD_INT 1
12048: PPUSH
12049: CALL 15477 0 1
12053: IFFALSE 12114
// begin DialogueOn ;
12055: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12059: LD_VAR 0 1
12063: PPUSH
12064: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12068: LD_INT 10
12070: PPUSH
12071: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12075: LD_ADDR_VAR 0 3
12079: PUSH
12080: LD_INT 1
12082: PPUSH
12083: LD_STRING D5a-Sol2-1
12085: PPUSH
12086: CALL 15655 0 2
12090: ST_TO_ADDR
// if not un then
12091: LD_VAR 0 3
12095: NOT
12096: IFFALSE 12108
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12098: LD_INT 2
12100: PPUSH
12101: LD_STRING D5a-FSol2-1
12103: PPUSH
12104: CALL 15655 0 2
// DialogueOff ;
12108: CALL_OW 7
// break ;
12112: GO 12116
// end ; end ;
12114: GO 12008
12116: POP
12117: POP
// end ; if not seen [ 2 ] then
12118: LD_EXP 9
12122: PUSH
12123: LD_INT 2
12125: ARRAY
12126: NOT
12127: IFFALSE 12352
// begin can_kamikazed := true ;
12129: LD_ADDR_EXP 10
12133: PUSH
12134: LD_INT 1
12136: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12137: LD_ADDR_VAR 0 2
12141: PUSH
12142: LD_INT 22
12144: PUSH
12145: LD_INT 2
12147: PUSH
12148: EMPTY
12149: LIST
12150: LIST
12151: PUSH
12152: LD_INT 25
12154: PUSH
12155: LD_INT 17
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: PPUSH
12166: CALL_OW 69
12170: ST_TO_ADDR
// if tmp then
12171: LD_VAR 0 2
12175: IFFALSE 12352
// for i in tmp do
12177: LD_ADDR_VAR 0 1
12181: PUSH
12182: LD_VAR 0 2
12186: PUSH
12187: FOR_IN
12188: IFFALSE 12350
// if See ( 1 , i ) then
12190: LD_INT 1
12192: PPUSH
12193: LD_VAR 0 1
12197: PPUSH
12198: CALL_OW 292
12202: IFFALSE 12348
// begin seen := Replace ( seen , 2 , true ) ;
12204: LD_ADDR_EXP 9
12208: PUSH
12209: LD_EXP 9
12213: PPUSH
12214: LD_INT 2
12216: PPUSH
12217: LD_INT 1
12219: PPUSH
12220: CALL_OW 1
12224: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12225: LD_INT 1
12227: PPUSH
12228: CALL 15477 0 1
12232: IFFALSE 12348
// begin DialogueOn ;
12234: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12238: LD_VAR 0 1
12242: PPUSH
12243: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12247: LD_INT 10
12249: PPUSH
12250: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12254: LD_ADDR_VAR 0 3
12258: PUSH
12259: LD_INT 1
12261: PPUSH
12262: LD_STRING D5b-Sol1-1
12264: PPUSH
12265: CALL 15655 0 2
12269: ST_TO_ADDR
// if not un then
12270: LD_VAR 0 3
12274: NOT
12275: IFFALSE 12293
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12277: LD_ADDR_VAR 0 3
12281: PUSH
12282: LD_INT 2
12284: PPUSH
12285: LD_STRING D5b-FSol1-1
12287: PPUSH
12288: CALL 15655 0 2
12292: ST_TO_ADDR
// if un then
12293: LD_VAR 0 3
12297: IFFALSE 12342
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12299: LD_ADDR_VAR 0 4
12303: PUSH
12304: LD_INT 1
12306: PPUSH
12307: LD_STRING D5b-Sol2-1
12309: PPUSH
12310: LD_VAR 0 3
12314: PPUSH
12315: CALL 15881 0 3
12319: ST_TO_ADDR
// if not un2 then
12320: LD_VAR 0 4
12324: NOT
12325: IFFALSE 12342
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12327: LD_INT 2
12329: PPUSH
12330: LD_STRING D5b-FSol2-1
12332: PPUSH
12333: LD_VAR 0 3
12337: PPUSH
12338: CALL 15881 0 3
// end ; DialogueOff ;
12342: CALL_OW 7
// break ;
12346: GO 12350
// end ; end ;
12348: GO 12187
12350: POP
12351: POP
// end ; if not seen [ 3 ] then
12352: LD_EXP 9
12356: PUSH
12357: LD_INT 3
12359: ARRAY
12360: NOT
12361: IFFALSE 12535
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12363: LD_ADDR_VAR 0 2
12367: PUSH
12368: LD_INT 22
12370: PUSH
12371: LD_INT 2
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: PUSH
12378: LD_INT 33
12380: PUSH
12381: LD_INT 2
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: PPUSH
12392: CALL_OW 69
12396: ST_TO_ADDR
// if tmp then
12397: LD_VAR 0 2
12401: IFFALSE 12535
// for i in tmp do
12403: LD_ADDR_VAR 0 1
12407: PUSH
12408: LD_VAR 0 2
12412: PUSH
12413: FOR_IN
12414: IFFALSE 12533
// if See ( 1 , i ) then
12416: LD_INT 1
12418: PPUSH
12419: LD_VAR 0 1
12423: PPUSH
12424: CALL_OW 292
12428: IFFALSE 12531
// begin seen := Replace ( seen , 3 , true ) ;
12430: LD_ADDR_EXP 9
12434: PUSH
12435: LD_EXP 9
12439: PPUSH
12440: LD_INT 3
12442: PPUSH
12443: LD_INT 1
12445: PPUSH
12446: CALL_OW 1
12450: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12451: LD_INT 1
12453: PPUSH
12454: CALL 15477 0 1
12458: IFFALSE 12531
// begin DialogueOn ;
12460: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12464: LD_VAR 0 1
12468: PPUSH
12469: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12473: LD_INT 10
12475: PPUSH
12476: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12480: LD_ADDR_VAR 0 3
12484: PUSH
12485: LD_INT 1
12487: PPUSH
12488: LD_STRING D8-Sol1-1
12490: PPUSH
12491: CALL 15655 0 2
12495: ST_TO_ADDR
// if not un then
12496: LD_VAR 0 3
12500: NOT
12501: IFFALSE 12513
// SayRand ( sex_female , D8-FSol1-1 ) ;
12503: LD_INT 2
12505: PPUSH
12506: LD_STRING D8-FSol1-1
12508: PPUSH
12509: CALL 15655 0 2
// Say ( JMM , D8-JMM-1 ) ;
12513: LD_EXP 20
12517: PPUSH
12518: LD_STRING D8-JMM-1
12520: PPUSH
12521: CALL_OW 88
// DialogueOff ;
12525: CALL_OW 7
// break ;
12529: GO 12533
// end ; end ;
12531: GO 12413
12533: POP
12534: POP
// end ; if not seen [ 4 ] then
12535: LD_EXP 9
12539: PUSH
12540: LD_INT 4
12542: ARRAY
12543: NOT
12544: IFFALSE 12706
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12546: LD_ADDR_VAR 0 2
12550: PUSH
12551: LD_INT 22
12553: PUSH
12554: LD_INT 2
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: LD_INT 33
12563: PUSH
12564: LD_INT 5
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: PUSH
12571: EMPTY
12572: LIST
12573: LIST
12574: PPUSH
12575: CALL_OW 69
12579: ST_TO_ADDR
// if tmp then
12580: LD_VAR 0 2
12584: IFFALSE 12706
// for i in tmp do
12586: LD_ADDR_VAR 0 1
12590: PUSH
12591: LD_VAR 0 2
12595: PUSH
12596: FOR_IN
12597: IFFALSE 12704
// if See ( 1 , i ) then
12599: LD_INT 1
12601: PPUSH
12602: LD_VAR 0 1
12606: PPUSH
12607: CALL_OW 292
12611: IFFALSE 12702
// begin seen := Replace ( seen , 4 , true ) ;
12613: LD_ADDR_EXP 9
12617: PUSH
12618: LD_EXP 9
12622: PPUSH
12623: LD_INT 4
12625: PPUSH
12626: LD_INT 1
12628: PPUSH
12629: CALL_OW 1
12633: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12634: LD_INT 1
12636: PPUSH
12637: CALL 15477 0 1
12641: IFFALSE 12702
// begin DialogueOn ;
12643: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12647: LD_VAR 0 1
12651: PPUSH
12652: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12656: LD_INT 10
12658: PPUSH
12659: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
12663: LD_ADDR_VAR 0 3
12667: PUSH
12668: LD_INT 1
12670: PPUSH
12671: LD_STRING D5a-Sol1-1
12673: PPUSH
12674: CALL 15655 0 2
12678: ST_TO_ADDR
// if not un then
12679: LD_VAR 0 3
12683: NOT
12684: IFFALSE 12696
// SayRand ( sex_female , D5a-FSol1-1 ) ;
12686: LD_INT 2
12688: PPUSH
12689: LD_STRING D5a-FSol1-1
12691: PPUSH
12692: CALL 15655 0 2
// DialogueOff ;
12696: CALL_OW 7
// break ;
12700: GO 12704
// end ; end ;
12702: GO 12596
12704: POP
12705: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
12706: LD_EXP 9
12710: PUSH
12711: LD_INT 5
12713: ARRAY
12714: NOT
12715: PUSH
12716: LD_EXP 9
12720: PUSH
12721: LD_INT 3
12723: ARRAY
12724: AND
12725: IFFALSE 12899
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
12727: LD_ADDR_VAR 0 2
12731: PUSH
12732: LD_INT 22
12734: PUSH
12735: LD_INT 2
12737: PUSH
12738: EMPTY
12739: LIST
12740: LIST
12741: PUSH
12742: LD_INT 34
12744: PUSH
12745: LD_INT 31
12747: PUSH
12748: EMPTY
12749: LIST
12750: LIST
12751: PUSH
12752: EMPTY
12753: LIST
12754: LIST
12755: PPUSH
12756: CALL_OW 69
12760: ST_TO_ADDR
// if tmp then
12761: LD_VAR 0 2
12765: IFFALSE 12899
// for i in tmp do
12767: LD_ADDR_VAR 0 1
12771: PUSH
12772: LD_VAR 0 2
12776: PUSH
12777: FOR_IN
12778: IFFALSE 12897
// if See ( 1 , i ) then
12780: LD_INT 1
12782: PPUSH
12783: LD_VAR 0 1
12787: PPUSH
12788: CALL_OW 292
12792: IFFALSE 12895
// begin seen := Replace ( seen , 5 , true ) ;
12794: LD_ADDR_EXP 9
12798: PUSH
12799: LD_EXP 9
12803: PPUSH
12804: LD_INT 5
12806: PPUSH
12807: LD_INT 1
12809: PPUSH
12810: CALL_OW 1
12814: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12815: LD_INT 1
12817: PPUSH
12818: CALL 15477 0 1
12822: IFFALSE 12895
// begin DialogueOn ;
12824: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12828: LD_VAR 0 1
12832: PPUSH
12833: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12837: LD_INT 10
12839: PPUSH
12840: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
12844: LD_ADDR_VAR 0 3
12848: PUSH
12849: LD_INT 1
12851: PPUSH
12852: LD_STRING D8a-Sol2-1
12854: PPUSH
12855: CALL 15655 0 2
12859: ST_TO_ADDR
// if not un then
12860: LD_VAR 0 3
12864: NOT
12865: IFFALSE 12877
// SayRand ( sex_female , D8a-FSol2-1 ) ;
12867: LD_INT 2
12869: PPUSH
12870: LD_STRING D8a-FSol2-1
12872: PPUSH
12873: CALL 15655 0 2
// Say ( JMM , D8a-JMM-1 ) ;
12877: LD_EXP 20
12881: PPUSH
12882: LD_STRING D8a-JMM-1
12884: PPUSH
12885: CALL_OW 88
// DialogueOff ;
12889: CALL_OW 7
// break ;
12893: GO 12897
// end ; end ;
12895: GO 12777
12897: POP
12898: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
12899: LD_EXP 9
12903: PUSH
12904: LD_INT 1
12906: ARRAY
12907: PUSH
12908: LD_EXP 9
12912: PUSH
12913: LD_INT 2
12915: ARRAY
12916: AND
12917: PUSH
12918: LD_EXP 9
12922: PUSH
12923: LD_INT 3
12925: ARRAY
12926: AND
12927: PUSH
12928: LD_EXP 9
12932: PUSH
12933: LD_INT 4
12935: ARRAY
12936: AND
12937: PUSH
12938: LD_EXP 9
12942: PUSH
12943: LD_INT 5
12945: ARRAY
12946: AND
12947: IFFALSE 12950
// disable ;
12949: DISABLE
// end ;
12950: PPOPN 4
12952: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
12953: LD_EXP 10
12957: PUSH
12958: LD_EXP 11
12962: AND
12963: IFFALSE 13161
12965: GO 12967
12967: DISABLE
12968: LD_INT 0
12970: PPUSH
// begin DialogueOn ;
12971: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
12975: LD_EXP 11
12979: PPUSH
12980: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
12984: LD_ADDR_VAR 0 1
12988: PUSH
12989: LD_INT 1
12991: PPUSH
12992: LD_STRING D5c-Sol1-1
12994: PPUSH
12995: CALL 15655 0 2
12999: ST_TO_ADDR
// if not un then
13000: LD_VAR 0 1
13004: NOT
13005: IFFALSE 13023
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13007: LD_ADDR_VAR 0 1
13011: PUSH
13012: LD_INT 2
13014: PPUSH
13015: LD_STRING D5c-FSol1-1
13017: PPUSH
13018: CALL 15655 0 2
13022: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13023: LD_EXP 20
13027: PPUSH
13028: LD_STRING D5c-JMM-1
13030: PPUSH
13031: CALL_OW 88
// if IsOk ( Lisa ) then
13035: LD_EXP 21
13039: PPUSH
13040: CALL_OW 302
13044: IFFALSE 13060
// Say ( Lisa , D5d-Lisa-1 ) else
13046: LD_EXP 21
13050: PPUSH
13051: LD_STRING D5d-Lisa-1
13053: PPUSH
13054: CALL_OW 88
13058: GO 13145
// if IsOk ( Cyrus ) then
13060: LD_EXP 24
13064: PPUSH
13065: CALL_OW 302
13069: IFFALSE 13085
// Say ( Cyrus , D5d-Cyrus-1 ) else
13071: LD_EXP 24
13075: PPUSH
13076: LD_STRING D5d-Cyrus-1
13078: PPUSH
13079: CALL_OW 88
13083: GO 13145
// if IsOk ( Gary ) then
13085: LD_EXP 31
13089: PPUSH
13090: CALL_OW 302
13094: IFFALSE 13110
// Say ( Gary , D5d-Gary-1 ) else
13096: LD_EXP 31
13100: PPUSH
13101: LD_STRING D5d-Gary-1
13103: PPUSH
13104: CALL_OW 88
13108: GO 13145
// if GetSex ( un ) = sex_male then
13110: LD_VAR 0 1
13114: PPUSH
13115: CALL_OW 258
13119: PUSH
13120: LD_INT 1
13122: EQUAL
13123: IFFALSE 13139
// Say ( un , D5d-Sol1-1 ) else
13125: LD_VAR 0 1
13129: PPUSH
13130: LD_STRING D5d-Sol1-1
13132: PPUSH
13133: CALL_OW 88
13137: GO 13145
// begin DialogueOff ;
13139: CALL_OW 7
// exit ;
13143: GO 13161
// end ; Say ( JMM , D5d-JMM-1 ) ;
13145: LD_EXP 20
13149: PPUSH
13150: LD_STRING D5d-JMM-1
13152: PPUSH
13153: CALL_OW 88
// DialogueOff ;
13157: CALL_OW 7
// end ;
13161: PPOPN 1
13163: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13164: LD_INT 1
13166: PPUSH
13167: LD_INT 17
13169: PPUSH
13170: CALL_OW 294
13174: PUSH
13175: LD_INT 2
13177: GREATEREQUAL
13178: IFFALSE 13299
13180: GO 13182
13182: DISABLE
13183: LD_INT 0
13185: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13186: LD_INT 10
13188: PPUSH
13189: LD_INT 5
13191: PPUSH
13192: LD_INT 1
13194: PPUSH
13195: LD_INT 10
13197: NEG
13198: PPUSH
13199: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13203: LD_INT 10
13205: PPUSH
13206: LD_INT 5
13208: PPUSH
13209: LD_INT 1
13211: PPUSH
13212: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13216: LD_INT 10
13218: PPUSH
13219: LD_INT 5
13221: PPUSH
13222: CALL_OW 86
// DialogueOn ;
13226: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13230: LD_ADDR_VAR 0 1
13234: PUSH
13235: LD_INT 1
13237: PPUSH
13238: LD_STRING D6-Sci1-1
13240: PPUSH
13241: CALL 15655 0 2
13245: ST_TO_ADDR
// if un then
13246: LD_VAR 0 1
13250: IFFALSE 13288
// begin Say ( JMM , D6-JMM-1 ) ;
13252: LD_EXP 20
13256: PPUSH
13257: LD_STRING D6-JMM-1
13259: PPUSH
13260: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13264: LD_VAR 0 1
13268: PPUSH
13269: LD_STRING D6-Sci1-2
13271: PPUSH
13272: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13276: LD_EXP 20
13280: PPUSH
13281: LD_STRING D6-JMM-2
13283: PPUSH
13284: CALL_OW 88
// end ; DialogueOff ;
13288: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13292: LD_STRING M3
13294: PPUSH
13295: CALL_OW 337
// end ;
13299: PPOPN 1
13301: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp ;
13302: LD_OWVAR 1
13306: PUSH
13307: LD_INT 42000
13309: GREATEREQUAL
13310: PUSH
13311: LD_INT 2
13313: PPUSH
13314: LD_INT 169
13316: PPUSH
13317: LD_INT 90
13319: PPUSH
13320: LD_INT 10
13322: PPUSH
13323: CALL 54594 0 4
13327: PUSH
13328: LD_INT 4
13330: ARRAY
13331: PUSH
13332: LD_INT 0
13334: EQUAL
13335: PUSH
13336: LD_INT 45
13338: PPUSH
13339: CALL_OW 301
13343: OR
13344: PUSH
13345: LD_INT 45
13347: PPUSH
13348: CALL_OW 255
13352: PUSH
13353: LD_INT 1
13355: EQUAL
13356: OR
13357: AND
13358: PUSH
13359: LD_INT 94
13361: PPUSH
13362: CALL_OW 301
13366: NOT
13367: AND
13368: IFFALSE 14494
13370: GO 13372
13372: DISABLE
13373: LD_INT 0
13375: PPUSH
13376: PPUSH
13377: PPUSH
13378: PPUSH
// begin uc_side := 5 ;
13379: LD_ADDR_OWVAR 20
13383: PUSH
13384: LD_INT 5
13386: ST_TO_ADDR
// uc_nation := 2 ;
13387: LD_ADDR_OWVAR 21
13391: PUSH
13392: LD_INT 2
13394: ST_TO_ADDR
// InitHc ;
13395: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13399: LD_INT 1
13401: PPUSH
13402: LD_INT 3
13404: PPUSH
13405: LD_INT 8
13407: PPUSH
13408: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13412: LD_ADDR_OWVAR 29
13416: PUSH
13417: LD_INT 12
13419: PUSH
13420: LD_INT 12
13422: PUSH
13423: EMPTY
13424: LIST
13425: LIST
13426: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13427: LD_ADDR_OWVAR 33
13431: PUSH
13432: LD_STRING SecondCharsGal
13434: ST_TO_ADDR
// hc_face_number := 7 ;
13435: LD_ADDR_OWVAR 34
13439: PUSH
13440: LD_INT 7
13442: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13443: LD_ADDR_EXP 45
13447: PUSH
13448: CALL_OW 44
13452: ST_TO_ADDR
// InitHc ;
13453: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13457: LD_INT 1
13459: PPUSH
13460: LD_INT 16
13462: PPUSH
13463: LD_INT 2
13465: PPUSH
13466: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13470: LD_ADDR_OWVAR 29
13474: PUSH
13475: LD_INT 12
13477: PUSH
13478: LD_INT 12
13480: PUSH
13481: EMPTY
13482: LIST
13483: LIST
13484: ST_TO_ADDR
// hc_name :=  ;
13485: LD_ADDR_OWVAR 26
13489: PUSH
13490: LD_STRING 
13492: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13493: LD_ADDR_EXP 46
13497: PUSH
13498: CALL_OW 44
13502: ST_TO_ADDR
// InitHc ;
13503: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13507: LD_INT 35
13509: PPUSH
13510: CALL_OW 67
// until not InBattle ( 1 ) ;
13514: LD_INT 1
13516: PPUSH
13517: CALL_OW 463
13521: NOT
13522: IFFALSE 13507
// wait ( 0 0$5 ) ;
13524: LD_INT 175
13526: PPUSH
13527: CALL_OW 67
// DialogueOn ;
13531: CALL_OW 6
// InGameOn ;
13535: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13539: LD_ADDR_VAR 0 1
13543: PUSH
13544: LD_INT 22
13546: PUSH
13547: LD_INT 1
13549: PUSH
13550: EMPTY
13551: LIST
13552: LIST
13553: PUSH
13554: LD_INT 2
13556: PUSH
13557: LD_INT 25
13559: PUSH
13560: LD_INT 1
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: LD_INT 25
13569: PUSH
13570: LD_INT 2
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: PUSH
13577: LD_INT 25
13579: PUSH
13580: LD_INT 3
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: PUSH
13587: LD_INT 25
13589: PUSH
13590: LD_INT 4
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PUSH
13597: LD_INT 25
13599: PUSH
13600: LD_INT 5
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PUSH
13607: LD_INT 25
13609: PUSH
13610: LD_INT 8
13612: PUSH
13613: EMPTY
13614: LIST
13615: LIST
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: LIST
13624: LIST
13625: PUSH
13626: EMPTY
13627: LIST
13628: LIST
13629: PPUSH
13630: CALL_OW 69
13634: PUSH
13635: LD_EXP 20
13639: PUSH
13640: LD_EXP 21
13644: PUSH
13645: LD_EXP 22
13649: PUSH
13650: LD_EXP 23
13654: PUSH
13655: LD_EXP 24
13659: PUSH
13660: LD_EXP 25
13664: PUSH
13665: LD_EXP 26
13669: PUSH
13670: LD_EXP 27
13674: PUSH
13675: LD_EXP 28
13679: PUSH
13680: LD_EXP 30
13684: PUSH
13685: LD_EXP 31
13689: PUSH
13690: LD_EXP 32
13694: PUSH
13695: LD_EXP 33
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: LIST
13710: LIST
13711: LIST
13712: LIST
13713: LIST
13714: DIFF
13715: PPUSH
13716: LD_INT 26
13718: PUSH
13719: LD_INT 1
13721: PUSH
13722: EMPTY
13723: LIST
13724: LIST
13725: PPUSH
13726: CALL_OW 72
13730: PUSH
13731: LD_INT 1
13733: ARRAY
13734: ST_TO_ADDR
// if not un and Brown then
13735: LD_VAR 0 1
13739: NOT
13740: PUSH
13741: LD_EXP 26
13745: AND
13746: IFFALSE 13758
// un := Brown ;
13748: LD_ADDR_VAR 0 1
13752: PUSH
13753: LD_EXP 26
13757: ST_TO_ADDR
// if un then
13758: LD_VAR 0 1
13762: IFFALSE 13788
// begin Say ( un , D7-Sol1-1 ) ;
13764: LD_VAR 0 1
13768: PPUSH
13769: LD_STRING D7-Sol1-1
13771: PPUSH
13772: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
13776: LD_EXP 20
13780: PPUSH
13781: LD_STRING D7-JMM-1
13783: PPUSH
13784: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
13788: LD_EXP 45
13792: PPUSH
13793: LD_STRING D7-Ar1-1
13795: PPUSH
13796: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
13800: LD_EXP 20
13804: PPUSH
13805: LD_STRING D7-JMM-2
13807: PPUSH
13808: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
13812: LD_EXP 45
13816: PPUSH
13817: LD_STRING D7-Ar1-2
13819: PPUSH
13820: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
13824: LD_EXP 20
13828: PPUSH
13829: LD_STRING D7-JMM-3
13831: PPUSH
13832: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
13836: LD_EXP 45
13840: PPUSH
13841: LD_STRING D7-Ar1-3
13843: PPUSH
13844: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
13848: LD_EXP 20
13852: PPUSH
13853: LD_STRING D7-JMM-4
13855: PPUSH
13856: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
13860: LD_EXP 45
13864: PPUSH
13865: LD_STRING D7-Ar1-4
13867: PPUSH
13868: CALL_OW 94
// InGameOff ;
13872: CALL_OW 9
// DialogueOff ;
13876: CALL_OW 7
// case Query ( QCameras ) of 1 :
13880: LD_STRING QCameras
13882: PPUSH
13883: CALL_OW 97
13887: PUSH
13888: LD_INT 1
13890: DOUBLE
13891: EQUAL
13892: IFTRUE 13896
13894: GO 13899
13896: POP
// ; 2 :
13897: GO 13913
13899: LD_INT 2
13901: DOUBLE
13902: EQUAL
13903: IFTRUE 13907
13905: GO 13912
13907: POP
// exit ; end ;
13908: GO 14494
13910: GO 13913
13912: POP
// ChangeMissionObjectives ( MCar ) ;
13913: LD_STRING MCar
13915: PPUSH
13916: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
13920: LD_INT 124
13922: PPUSH
13923: LD_INT 90
13925: PPUSH
13926: LD_INT 1
13928: PPUSH
13929: LD_INT 6
13931: NEG
13932: PPUSH
13933: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
13937: LD_INT 124
13939: PPUSH
13940: LD_INT 90
13942: PPUSH
13943: LD_INT 1
13945: PPUSH
13946: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
13950: LD_INT 12
13952: PPUSH
13953: LD_INT 1
13955: PPUSH
13956: CALL_OW 424
// wait ( 3 ) ;
13960: LD_INT 3
13962: PPUSH
13963: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
13967: LD_INT 124
13969: PPUSH
13970: LD_INT 90
13972: PPUSH
13973: CALL_OW 86
// cargo := false ;
13977: LD_ADDR_VAR 0 3
13981: PUSH
13982: LD_INT 0
13984: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13985: LD_INT 35
13987: PPUSH
13988: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
13992: LD_ADDR_VAR 0 3
13996: PUSH
13997: LD_INT 12
13999: PPUSH
14000: LD_INT 32
14002: PUSH
14003: LD_INT 3
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: PUSH
14010: LD_INT 34
14012: PUSH
14013: LD_INT 32
14015: PUSH
14016: EMPTY
14017: LIST
14018: LIST
14019: PUSH
14020: LD_INT 58
14022: PUSH
14023: EMPTY
14024: LIST
14025: PUSH
14026: EMPTY
14027: LIST
14028: LIST
14029: LIST
14030: PPUSH
14031: CALL_OW 70
14035: ST_TO_ADDR
// until cargo ;
14036: LD_VAR 0 3
14040: IFFALSE 13985
// cargo := cargo [ 1 ] ;
14042: LD_ADDR_VAR 0 3
14046: PUSH
14047: LD_VAR 0 3
14051: PUSH
14052: LD_INT 1
14054: ARRAY
14055: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14056: LD_VAR 0 3
14060: PPUSH
14061: LD_INT 5
14063: PPUSH
14064: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14068: LD_INT 12
14070: PPUSH
14071: LD_INT 0
14073: PPUSH
14074: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14078: LD_EXP 45
14082: PPUSH
14083: LD_INT 11
14085: PPUSH
14086: LD_INT 0
14088: PPUSH
14089: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14093: LD_EXP 46
14097: PPUSH
14098: LD_INT 11
14100: PPUSH
14101: LD_INT 0
14103: PPUSH
14104: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14108: LD_EXP 45
14112: PUSH
14113: LD_EXP 46
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: PPUSH
14122: LD_INT 12
14124: PPUSH
14125: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14129: LD_EXP 45
14133: PPUSH
14134: LD_VAR 0 3
14138: PPUSH
14139: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14143: LD_EXP 45
14147: PUSH
14148: LD_EXP 46
14152: PUSH
14153: EMPTY
14154: LIST
14155: LIST
14156: PPUSH
14157: LD_INT 209
14159: PPUSH
14160: LD_INT 178
14162: PPUSH
14163: CALL_OW 171
// while ( true ) do
14167: LD_INT 1
14169: IFFALSE 14323
// begin wait ( 0 0$1 ) ;
14171: LD_INT 35
14173: PPUSH
14174: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14178: LD_EXP 45
14182: PPUSH
14183: CALL_OW 314
14187: NOT
14188: PUSH
14189: LD_EXP 46
14193: PPUSH
14194: CALL_OW 314
14198: NOT
14199: OR
14200: IFFALSE 14226
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14202: LD_EXP 45
14206: PUSH
14207: LD_EXP 46
14211: PUSH
14212: EMPTY
14213: LIST
14214: LIST
14215: PPUSH
14216: LD_INT 209
14218: PPUSH
14219: LD_INT 178
14221: PPUSH
14222: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14226: LD_EXP 45
14230: PPUSH
14231: LD_INT 10
14233: PPUSH
14234: CALL_OW 308
14238: IFFALSE 14249
// RemoveUnit ( ar_mechanic ) ;
14240: LD_EXP 45
14244: PPUSH
14245: CALL_OW 64
// if IsInArea ( ar_mechanic_friend , escape_area ) then
14249: LD_EXP 46
14253: PPUSH
14254: LD_INT 10
14256: PPUSH
14257: CALL_OW 308
14261: IFFALSE 14272
// RemoveUnit ( ar_mechanic_friend ) ;
14263: LD_EXP 46
14267: PPUSH
14268: CALL_OW 64
// if IsInArea ( cargo , escape_area ) then
14272: LD_VAR 0 3
14276: PPUSH
14277: LD_INT 10
14279: PPUSH
14280: CALL_OW 308
14284: IFFALSE 14295
// RemoveUnit ( cargo ) ;
14286: LD_VAR 0 3
14290: PPUSH
14291: CALL_OW 64
// if not IsLive ( ar_mechanic ) and not IsLive ( ar_mechanic_friend ) then
14295: LD_EXP 45
14299: PPUSH
14300: CALL_OW 300
14304: NOT
14305: PUSH
14306: LD_EXP 46
14310: PPUSH
14311: CALL_OW 300
14315: NOT
14316: AND
14317: IFFALSE 14321
// break ;
14319: GO 14323
// end ;
14321: GO 14167
// wait ( 0 0$2 ) ;
14323: LD_INT 70
14325: PPUSH
14326: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14330: LD_EXP 45
14334: PPUSH
14335: LD_STRING D7a-Ar1-1
14337: PPUSH
14338: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14342: LD_ADDR_VAR 0 4
14346: PUSH
14347: LD_INT 129
14349: PUSH
14350: LD_INT 10
14352: PUSH
14353: EMPTY
14354: LIST
14355: LIST
14356: PUSH
14357: LD_INT 103
14359: PUSH
14360: LD_INT 6
14362: PUSH
14363: EMPTY
14364: LIST
14365: LIST
14366: PUSH
14367: LD_INT 148
14369: PUSH
14370: LD_INT 47
14372: PUSH
14373: EMPTY
14374: LIST
14375: LIST
14376: PUSH
14377: LD_INT 155
14379: PUSH
14380: LD_INT 16
14382: PUSH
14383: EMPTY
14384: LIST
14385: LIST
14386: PUSH
14387: EMPTY
14388: LIST
14389: LIST
14390: LIST
14391: LIST
14392: ST_TO_ADDR
// if Difficulty = 1 then
14393: LD_OWVAR 67
14397: PUSH
14398: LD_INT 1
14400: EQUAL
14401: IFFALSE 14438
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14403: LD_ADDR_VAR 0 4
14407: PUSH
14408: LD_VAR 0 4
14412: PUSH
14413: LD_INT 78
14415: PUSH
14416: LD_INT 7
14418: PUSH
14419: EMPTY
14420: LIST
14421: LIST
14422: PUSH
14423: LD_INT 104
14425: PUSH
14426: LD_INT 43
14428: PUSH
14429: EMPTY
14430: LIST
14431: LIST
14432: PUSH
14433: EMPTY
14434: LIST
14435: LIST
14436: ADD
14437: ST_TO_ADDR
// for i in tmp do
14438: LD_ADDR_VAR 0 2
14442: PUSH
14443: LD_VAR 0 4
14447: PUSH
14448: FOR_IN
14449: IFFALSE 14482
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14451: LD_VAR 0 2
14455: PUSH
14456: LD_INT 1
14458: ARRAY
14459: PPUSH
14460: LD_VAR 0 2
14464: PUSH
14465: LD_INT 2
14467: ARRAY
14468: PPUSH
14469: LD_INT 1
14471: PPUSH
14472: LD_INT 9
14474: NEG
14475: PPUSH
14476: CALL_OW 330
14480: GO 14448
14482: POP
14483: POP
// CenterOnXY ( 129 , 10 ) ;
14484: LD_INT 129
14486: PPUSH
14487: LD_INT 10
14489: PPUSH
14490: CALL_OW 84
// end ;
14494: PPOPN 4
14496: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14497: LD_EXP 15
14501: PUSH
14502: LD_INT 21000
14504: MINUS
14505: PUSH
14506: LD_OWVAR 1
14510: LESSEQUAL
14511: IFFALSE 14551
14513: GO 14515
14515: DISABLE
// begin powell_warn := true ;
14516: LD_ADDR_EXP 16
14520: PUSH
14521: LD_INT 1
14523: ST_TO_ADDR
// DialogueOn ;
14524: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14528: LD_EXP 29
14532: PPUSH
14533: LD_STRING D9-Pow-1
14535: PPUSH
14536: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
14540: LD_INT 10
14542: PPUSH
14543: CALL_OW 68
// DialogueOff ;
14547: CALL_OW 7
// end ;
14551: END
// every 0 0$1 trigger game_time <= tick do
14552: LD_EXP 15
14556: PUSH
14557: LD_OWVAR 1
14561: LESSEQUAL
14562: IFFALSE 14601
14564: GO 14566
14566: DISABLE
// begin DialogueOn ;
14567: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
14571: LD_EXP 29
14575: PPUSH
14576: LD_STRING D9a-Pow-1
14578: PPUSH
14579: CALL_OW 94
// dwait ( 0 0$2 ) ;
14583: LD_INT 70
14585: PPUSH
14586: CALL_OW 68
// DialogueOff ;
14590: CALL_OW 7
// YouLost ( Command ) ;
14594: LD_STRING Command
14596: PPUSH
14597: CALL_OW 104
// end ;
14601: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
14602: LD_INT 22
14604: PUSH
14605: LD_INT 2
14607: PUSH
14608: EMPTY
14609: LIST
14610: LIST
14611: PUSH
14612: LD_INT 30
14614: PUSH
14615: LD_INT 1
14617: PUSH
14618: EMPTY
14619: LIST
14620: LIST
14621: PUSH
14622: EMPTY
14623: LIST
14624: LIST
14625: PPUSH
14626: CALL_OW 69
14630: PUSH
14631: LD_INT 0
14633: EQUAL
14634: PUSH
14635: LD_EXP 20
14639: PPUSH
14640: CALL_OW 302
14644: AND
14645: IFFALSE 15474
14647: GO 14649
14649: DISABLE
14650: LD_INT 0
14652: PPUSH
14653: PPUSH
14654: PPUSH
14655: PPUSH
// begin m1 := false ;
14656: LD_ADDR_VAR 0 2
14660: PUSH
14661: LD_INT 0
14663: ST_TO_ADDR
// m2 := false ;
14664: LD_ADDR_VAR 0 3
14668: PUSH
14669: LD_INT 0
14671: ST_TO_ADDR
// m3 := false ;
14672: LD_ADDR_VAR 0 4
14676: PUSH
14677: LD_INT 0
14679: ST_TO_ADDR
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
14680: LD_OWVAR 1
14684: PUSH
14685: LD_INT 252000
14687: PUSH
14688: LD_INT 210000
14690: PUSH
14691: LD_INT 199500
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: LIST
14698: PUSH
14699: LD_OWVAR 67
14703: ARRAY
14704: LESS
14705: IFFALSE 14727
// begin m3 := true ;
14707: LD_ADDR_VAR 0 4
14711: PUSH
14712: LD_INT 1
14714: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
14715: LD_STRING Time1
14717: PPUSH
14718: LD_INT 1
14720: PPUSH
14721: CALL_OW 101
// end else
14725: GO 14758
// if not powell_warn then
14727: LD_EXP 16
14731: NOT
14732: IFFALSE 14747
// AddMedal ( Time1 , - 1 ) else
14734: LD_STRING Time1
14736: PPUSH
14737: LD_INT 1
14739: NEG
14740: PPUSH
14741: CALL_OW 101
14745: GO 14758
// AddMedal ( Time1 , - 2 ) ;
14747: LD_STRING Time1
14749: PPUSH
14750: LD_INT 2
14752: NEG
14753: PPUSH
14754: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
14758: LD_EXP 17
14762: PUSH
14763: LD_INT 5
14765: PUSH
14766: LD_INT 4
14768: PUSH
14769: LD_INT 3
14771: PUSH
14772: EMPTY
14773: LIST
14774: LIST
14775: LIST
14776: PUSH
14777: LD_OWVAR 67
14781: ARRAY
14782: GREATEREQUAL
14783: IFFALSE 14798
// AddMedal ( Destroy , - 2 ) else
14785: LD_STRING Destroy
14787: PPUSH
14788: LD_INT 2
14790: NEG
14791: PPUSH
14792: CALL_OW 101
14796: GO 14931
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
14798: LD_INT 22
14800: PUSH
14801: LD_INT 2
14803: PUSH
14804: EMPTY
14805: LIST
14806: LIST
14807: PUSH
14808: LD_INT 21
14810: PUSH
14811: LD_INT 3
14813: PUSH
14814: EMPTY
14815: LIST
14816: LIST
14817: PUSH
14818: LD_INT 50
14820: PUSH
14821: EMPTY
14822: LIST
14823: PUSH
14824: EMPTY
14825: LIST
14826: LIST
14827: LIST
14828: PPUSH
14829: CALL_OW 69
14833: PUSH
14834: LD_INT 25
14836: GREATEREQUAL
14837: IFFALSE 14852
// AddMedal ( Destroy , - 1 ) else
14839: LD_STRING Destroy
14841: PPUSH
14842: LD_INT 1
14844: NEG
14845: PPUSH
14846: CALL_OW 101
14850: GO 14931
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
14852: LD_INT 22
14854: PUSH
14855: LD_INT 2
14857: PUSH
14858: EMPTY
14859: LIST
14860: LIST
14861: PUSH
14862: LD_INT 21
14864: PUSH
14865: LD_INT 3
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: PUSH
14872: LD_INT 50
14874: PUSH
14875: EMPTY
14876: LIST
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: LIST
14882: PPUSH
14883: CALL_OW 69
14887: PUSH
14888: LD_INT 15
14890: GREATEREQUAL
14891: IFFALSE 14913
// begin m1 := true ;
14893: LD_ADDR_VAR 0 2
14897: PUSH
14898: LD_INT 1
14900: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
14901: LD_STRING Destroy
14903: PPUSH
14904: LD_INT 1
14906: PPUSH
14907: CALL_OW 101
// end else
14911: GO 14931
// begin m1 := true ;
14913: LD_ADDR_VAR 0 2
14917: PUSH
14918: LD_INT 1
14920: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
14921: LD_STRING Destroy
14923: PPUSH
14924: LD_INT 2
14926: PPUSH
14927: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
14931: LD_EXP 13
14935: PPUSH
14936: LD_STRING 11_artifact_captured
14938: PPUSH
14939: CALL_OW 39
// if artifact_get then
14943: LD_EXP 13
14947: IFFALSE 14969
// begin m2 := true ;
14949: LD_ADDR_VAR 0 3
14953: PUSH
14954: LD_INT 1
14956: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
14957: LD_STRING Artefact
14959: PPUSH
14960: LD_INT 1
14962: PPUSH
14963: CALL_OW 101
// end else
14967: GO 14980
// AddMedal ( Artefact , - 1 ) ;
14969: LD_STRING Artefact
14971: PPUSH
14972: LD_INT 1
14974: NEG
14975: PPUSH
14976: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
14980: LD_VAR 0 2
14984: PUSH
14985: LD_VAR 0 3
14989: AND
14990: PUSH
14991: LD_VAR 0 4
14995: AND
14996: PUSH
14997: LD_OWVAR 67
15001: PUSH
15002: LD_INT 3
15004: EQUAL
15005: AND
15006: IFFALSE 15018
// SetAchievementEX ( ACH_AMER , 11 ) ;
15008: LD_STRING ACH_AMER
15010: PPUSH
15011: LD_INT 11
15013: PPUSH
15014: CALL_OW 564
// GiveMedals ( MAIN ) ;
15018: LD_STRING MAIN
15020: PPUSH
15021: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15025: LD_ADDR_EXP 19
15029: PUSH
15030: LD_EXP 19
15034: PPUSH
15035: LD_INT 51
15037: PUSH
15038: EMPTY
15039: LIST
15040: PPUSH
15041: CALL_OW 72
15045: ST_TO_ADDR
// tmp := JMM ^ selected ;
15046: LD_ADDR_VAR 0 1
15050: PUSH
15051: LD_EXP 20
15055: PUSH
15056: LD_EXP 19
15060: ADD
15061: ST_TO_ADDR
// RewardPeople ( tmp ) ;
15062: LD_VAR 0 1
15066: PPUSH
15067: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
15071: LD_VAR 0 1
15075: PUSH
15076: LD_EXP 20
15080: PUSH
15081: LD_EXP 21
15085: PUSH
15086: LD_EXP 22
15090: PUSH
15091: LD_EXP 23
15095: PUSH
15096: LD_EXP 24
15100: PUSH
15101: LD_EXP 25
15105: PUSH
15106: LD_EXP 26
15110: PUSH
15111: LD_EXP 27
15115: PUSH
15116: LD_EXP 28
15120: PUSH
15121: LD_EXP 30
15125: PUSH
15126: LD_EXP 31
15130: PUSH
15131: LD_EXP 32
15135: PUSH
15136: LD_EXP 33
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: LIST
15145: LIST
15146: LIST
15147: LIST
15148: LIST
15149: LIST
15150: LIST
15151: LIST
15152: LIST
15153: LIST
15154: LIST
15155: DIFF
15156: PPUSH
15157: LD_STRING 11c_others
15159: PPUSH
15160: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15164: LD_EXP 20
15168: PPUSH
15169: LD_EXP 3
15173: PUSH
15174: LD_STRING JMM
15176: STR
15177: PPUSH
15178: CALL_OW 38
// if Lisa then
15182: LD_EXP 21
15186: IFFALSE 15206
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15188: LD_EXP 21
15192: PPUSH
15193: LD_EXP 3
15197: PUSH
15198: LD_STRING Lisa
15200: STR
15201: PPUSH
15202: CALL_OW 38
// if Donaldson then
15206: LD_EXP 22
15210: IFFALSE 15230
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15212: LD_EXP 22
15216: PPUSH
15217: LD_EXP 3
15221: PUSH
15222: LD_STRING Donaldson
15224: STR
15225: PPUSH
15226: CALL_OW 38
// if Bobby then
15230: LD_EXP 23
15234: IFFALSE 15254
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15236: LD_EXP 23
15240: PPUSH
15241: LD_EXP 3
15245: PUSH
15246: LD_STRING Bobby
15248: STR
15249: PPUSH
15250: CALL_OW 38
// if Cyrus then
15254: LD_EXP 24
15258: IFFALSE 15278
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15260: LD_EXP 24
15264: PPUSH
15265: LD_EXP 3
15269: PUSH
15270: LD_STRING Cyrus
15272: STR
15273: PPUSH
15274: CALL_OW 38
// if Denis then
15278: LD_EXP 25
15282: IFFALSE 15302
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15284: LD_EXP 25
15288: PPUSH
15289: LD_EXP 3
15293: PUSH
15294: LD_STRING Denis
15296: STR
15297: PPUSH
15298: CALL_OW 38
// if Brown then
15302: LD_EXP 26
15306: IFFALSE 15326
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15308: LD_EXP 26
15312: PPUSH
15313: LD_EXP 3
15317: PUSH
15318: LD_STRING Brown
15320: STR
15321: PPUSH
15322: CALL_OW 38
// if Gladstone then
15326: LD_EXP 27
15330: IFFALSE 15350
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15332: LD_EXP 27
15336: PPUSH
15337: LD_EXP 3
15341: PUSH
15342: LD_STRING Gladstone
15344: STR
15345: PPUSH
15346: CALL_OW 38
// if Houten then
15350: LD_EXP 28
15354: IFFALSE 15374
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15356: LD_EXP 28
15360: PPUSH
15361: LD_EXP 3
15365: PUSH
15366: LD_STRING Houten
15368: STR
15369: PPUSH
15370: CALL_OW 38
// if Cornel then
15374: LD_EXP 30
15378: IFFALSE 15398
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
15380: LD_EXP 30
15384: PPUSH
15385: LD_EXP 3
15389: PUSH
15390: LD_STRING Cornell
15392: STR
15393: PPUSH
15394: CALL_OW 38
// if Gary then
15398: LD_EXP 31
15402: IFFALSE 15422
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
15404: LD_EXP 31
15408: PPUSH
15409: LD_EXP 3
15413: PUSH
15414: LD_STRING Gary
15416: STR
15417: PPUSH
15418: CALL_OW 38
// if Frank then
15422: LD_EXP 32
15426: IFFALSE 15446
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
15428: LD_EXP 32
15432: PPUSH
15433: LD_EXP 3
15437: PUSH
15438: LD_STRING Frank
15440: STR
15441: PPUSH
15442: CALL_OW 38
// if Kikuchi then
15446: LD_EXP 33
15450: IFFALSE 15470
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
15452: LD_EXP 33
15456: PPUSH
15457: LD_EXP 3
15461: PUSH
15462: LD_STRING Kikuchi
15464: STR
15465: PPUSH
15466: CALL_OW 38
// YouWin ;
15470: CALL_OW 103
// end ;
15474: PPOPN 4
15476: END
// export function CanSayRand ( side ) ; begin
15477: LD_INT 0
15479: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15480: LD_ADDR_VAR 0 2
15484: PUSH
15485: LD_INT 52
15487: PUSH
15488: EMPTY
15489: LIST
15490: PUSH
15491: LD_INT 22
15493: PUSH
15494: LD_VAR 0 1
15498: PUSH
15499: EMPTY
15500: LIST
15501: LIST
15502: PUSH
15503: LD_INT 2
15505: PUSH
15506: LD_INT 25
15508: PUSH
15509: LD_INT 1
15511: PUSH
15512: EMPTY
15513: LIST
15514: LIST
15515: PUSH
15516: LD_INT 25
15518: PUSH
15519: LD_INT 2
15521: PUSH
15522: EMPTY
15523: LIST
15524: LIST
15525: PUSH
15526: LD_INT 25
15528: PUSH
15529: LD_INT 3
15531: PUSH
15532: EMPTY
15533: LIST
15534: LIST
15535: PUSH
15536: LD_INT 25
15538: PUSH
15539: LD_INT 4
15541: PUSH
15542: EMPTY
15543: LIST
15544: LIST
15545: PUSH
15546: EMPTY
15547: LIST
15548: LIST
15549: LIST
15550: LIST
15551: LIST
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: LIST
15557: PPUSH
15558: CALL_OW 69
15562: PUSH
15563: LD_EXP 20
15567: PUSH
15568: LD_EXP 32
15572: PUSH
15573: LD_EXP 21
15577: PUSH
15578: LD_EXP 22
15582: PUSH
15583: LD_EXP 23
15587: PUSH
15588: LD_EXP 24
15592: PUSH
15593: LD_EXP 25
15597: PUSH
15598: LD_EXP 26
15602: PUSH
15603: LD_EXP 27
15607: PUSH
15608: LD_EXP 28
15612: PUSH
15613: LD_EXP 29
15617: PUSH
15618: LD_EXP 30
15622: PUSH
15623: LD_EXP 31
15627: PUSH
15628: LD_EXP 33
15632: PUSH
15633: EMPTY
15634: LIST
15635: LIST
15636: LIST
15637: LIST
15638: LIST
15639: LIST
15640: LIST
15641: LIST
15642: LIST
15643: LIST
15644: LIST
15645: LIST
15646: LIST
15647: LIST
15648: DIFF
15649: ST_TO_ADDR
// end ;
15650: LD_VAR 0 2
15654: RET
// export function SayRand ( sex , dial ) ; begin
15655: LD_INT 0
15657: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15658: LD_ADDR_VAR 0 3
15662: PUSH
15663: LD_INT 52
15665: PUSH
15666: EMPTY
15667: LIST
15668: PUSH
15669: LD_INT 22
15671: PUSH
15672: LD_INT 1
15674: PUSH
15675: EMPTY
15676: LIST
15677: LIST
15678: PUSH
15679: LD_INT 26
15681: PUSH
15682: LD_VAR 0 1
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: PUSH
15691: LD_INT 2
15693: PUSH
15694: LD_INT 25
15696: PUSH
15697: LD_INT 1
15699: PUSH
15700: EMPTY
15701: LIST
15702: LIST
15703: PUSH
15704: LD_INT 25
15706: PUSH
15707: LD_INT 2
15709: PUSH
15710: EMPTY
15711: LIST
15712: LIST
15713: PUSH
15714: LD_INT 25
15716: PUSH
15717: LD_INT 3
15719: PUSH
15720: EMPTY
15721: LIST
15722: LIST
15723: PUSH
15724: LD_INT 25
15726: PUSH
15727: LD_INT 4
15729: PUSH
15730: EMPTY
15731: LIST
15732: LIST
15733: PUSH
15734: EMPTY
15735: LIST
15736: LIST
15737: LIST
15738: LIST
15739: LIST
15740: PUSH
15741: EMPTY
15742: LIST
15743: LIST
15744: LIST
15745: LIST
15746: PPUSH
15747: CALL_OW 69
15751: PUSH
15752: LD_EXP 20
15756: PUSH
15757: LD_EXP 32
15761: PUSH
15762: LD_EXP 21
15766: PUSH
15767: LD_EXP 22
15771: PUSH
15772: LD_EXP 23
15776: PUSH
15777: LD_EXP 24
15781: PUSH
15782: LD_EXP 25
15786: PUSH
15787: LD_EXP 26
15791: PUSH
15792: LD_EXP 27
15796: PUSH
15797: LD_EXP 28
15801: PUSH
15802: LD_EXP 29
15806: PUSH
15807: LD_EXP 30
15811: PUSH
15812: LD_EXP 31
15816: PUSH
15817: LD_EXP 33
15821: PUSH
15822: EMPTY
15823: LIST
15824: LIST
15825: LIST
15826: LIST
15827: LIST
15828: LIST
15829: LIST
15830: LIST
15831: LIST
15832: LIST
15833: LIST
15834: LIST
15835: LIST
15836: LIST
15837: DIFF
15838: ST_TO_ADDR
// if not result then
15839: LD_VAR 0 3
15843: NOT
15844: IFFALSE 15848
// exit ;
15846: GO 15876
// result := result [ 1 ] ;
15848: LD_ADDR_VAR 0 3
15852: PUSH
15853: LD_VAR 0 3
15857: PUSH
15858: LD_INT 1
15860: ARRAY
15861: ST_TO_ADDR
// Say ( result , dial ) ;
15862: LD_VAR 0 3
15866: PPUSH
15867: LD_VAR 0 2
15871: PPUSH
15872: CALL_OW 88
// end ;
15876: LD_VAR 0 3
15880: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
15881: LD_INT 0
15883: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
15884: LD_ADDR_VAR 0 4
15888: PUSH
15889: LD_INT 22
15891: PUSH
15892: LD_INT 1
15894: PUSH
15895: EMPTY
15896: LIST
15897: LIST
15898: PUSH
15899: LD_INT 26
15901: PUSH
15902: LD_VAR 0 1
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: PUSH
15911: LD_INT 2
15913: PUSH
15914: LD_INT 25
15916: PUSH
15917: LD_INT 1
15919: PUSH
15920: EMPTY
15921: LIST
15922: LIST
15923: PUSH
15924: LD_INT 25
15926: PUSH
15927: LD_INT 2
15929: PUSH
15930: EMPTY
15931: LIST
15932: LIST
15933: PUSH
15934: LD_INT 25
15936: PUSH
15937: LD_INT 3
15939: PUSH
15940: EMPTY
15941: LIST
15942: LIST
15943: PUSH
15944: LD_INT 25
15946: PUSH
15947: LD_INT 4
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: PUSH
15954: EMPTY
15955: LIST
15956: LIST
15957: LIST
15958: LIST
15959: LIST
15960: PUSH
15961: EMPTY
15962: LIST
15963: LIST
15964: LIST
15965: PPUSH
15966: CALL_OW 69
15970: PUSH
15971: LD_EXP 20
15975: PUSH
15976: LD_EXP 32
15980: PUSH
15981: LD_EXP 21
15985: PUSH
15986: LD_EXP 22
15990: PUSH
15991: LD_EXP 23
15995: PUSH
15996: LD_EXP 24
16000: PUSH
16001: LD_EXP 25
16005: PUSH
16006: LD_EXP 26
16010: PUSH
16011: LD_EXP 27
16015: PUSH
16016: LD_EXP 28
16020: PUSH
16021: LD_EXP 29
16025: PUSH
16026: LD_EXP 30
16030: PUSH
16031: LD_EXP 31
16035: PUSH
16036: LD_EXP 33
16040: PUSH
16041: EMPTY
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: LIST
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: PUSH
16057: LD_VAR 0 3
16061: ADD
16062: DIFF
16063: ST_TO_ADDR
// if not result then
16064: LD_VAR 0 4
16068: NOT
16069: IFFALSE 16073
// exit ;
16071: GO 16101
// result := result [ 1 ] ;
16073: LD_ADDR_VAR 0 4
16077: PUSH
16078: LD_VAR 0 4
16082: PUSH
16083: LD_INT 1
16085: ARRAY
16086: ST_TO_ADDR
// Say ( result , dial ) ;
16087: LD_VAR 0 4
16091: PPUSH
16092: LD_VAR 0 2
16096: PPUSH
16097: CALL_OW 88
// end ; end_of_file
16101: LD_VAR 0 4
16105: RET
// export function CustomEvent ( event ) ; begin
16106: LD_INT 0
16108: PPUSH
// end ;
16109: LD_VAR 0 2
16113: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
16114: LD_VAR 0 1
16118: PPUSH
16119: CALL_OW 255
16123: PUSH
16124: LD_INT 1
16126: EQUAL
16127: IFFALSE 16137
// artifact_get := true ;
16129: LD_ADDR_EXP 13
16133: PUSH
16134: LD_INT 1
16136: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
16137: LD_VAR 0 1
16141: PPUSH
16142: CALL_OW 255
16146: PUSH
16147: LD_INT 2
16149: EQUAL
16150: IFFALSE 16168
// begin artifact_get := false ;
16152: LD_ADDR_EXP 13
16156: PUSH
16157: LD_INT 0
16159: ST_TO_ADDR
// artifact_stolen := true ;
16160: LD_ADDR_EXP 12
16164: PUSH
16165: LD_INT 1
16167: ST_TO_ADDR
// end ; artifact_oncargo := true ;
16168: LD_ADDR_EXP 14
16172: PUSH
16173: LD_INT 1
16175: ST_TO_ADDR
// end ;
16176: PPOPN 2
16178: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
16179: LD_ADDR_EXP 14
16183: PUSH
16184: LD_INT 0
16186: ST_TO_ADDR
// end ;
16187: PPOPN 2
16189: END
// on UnitDestroyed ( un ) do begin if un = JMM then
16190: LD_VAR 0 1
16194: PUSH
16195: LD_EXP 20
16199: EQUAL
16200: IFFALSE 16211
// begin YouLost ( JMM ) ;
16202: LD_STRING JMM
16204: PPUSH
16205: CALL_OW 104
// exit ;
16209: GO 16343
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
16211: LD_VAR 0 1
16215: PUSH
16216: LD_INT 22
16218: PUSH
16219: LD_INT 1
16221: PUSH
16222: EMPTY
16223: LIST
16224: LIST
16225: PUSH
16226: LD_INT 21
16228: PUSH
16229: LD_INT 1
16231: PUSH
16232: EMPTY
16233: LIST
16234: LIST
16235: PUSH
16236: LD_INT 2
16238: PUSH
16239: LD_INT 25
16241: PUSH
16242: LD_INT 1
16244: PUSH
16245: EMPTY
16246: LIST
16247: LIST
16248: PUSH
16249: LD_INT 25
16251: PUSH
16252: LD_INT 2
16254: PUSH
16255: EMPTY
16256: LIST
16257: LIST
16258: PUSH
16259: LD_INT 25
16261: PUSH
16262: LD_INT 3
16264: PUSH
16265: EMPTY
16266: LIST
16267: LIST
16268: PUSH
16269: LD_INT 25
16271: PUSH
16272: LD_INT 4
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: PUSH
16279: LD_INT 25
16281: PUSH
16282: LD_INT 5
16284: PUSH
16285: EMPTY
16286: LIST
16287: LIST
16288: PUSH
16289: LD_INT 25
16291: PUSH
16292: LD_INT 8
16294: PUSH
16295: EMPTY
16296: LIST
16297: LIST
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: LIST
16303: LIST
16304: LIST
16305: LIST
16306: LIST
16307: PUSH
16308: EMPTY
16309: LIST
16310: LIST
16311: LIST
16312: PPUSH
16313: CALL_OW 69
16317: IN
16318: IFFALSE 16334
// loses_counter := loses_counter + 1 ;
16320: LD_ADDR_EXP 17
16324: PUSH
16325: LD_EXP 17
16329: PUSH
16330: LD_INT 1
16332: PLUS
16333: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16334: LD_VAR 0 1
16338: PPUSH
16339: CALL 43792 0 1
// end ;
16343: PPOPN 1
16345: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16346: LD_VAR 0 1
16350: PPUSH
16351: LD_VAR 0 2
16355: PPUSH
16356: CALL 45992 0 2
// end ;
16360: PPOPN 2
16362: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16363: LD_VAR 0 1
16367: PPUSH
16368: CALL 45301 0 1
// end ;
16372: PPOPN 1
16374: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16375: LD_VAR 0 1
16379: PPUSH
16380: LD_VAR 0 2
16384: PPUSH
16385: LD_VAR 0 3
16389: PPUSH
16390: LD_VAR 0 4
16394: PPUSH
16395: LD_VAR 0 5
16399: PPUSH
16400: CALL 43108 0 5
// end ;
16404: PPOPN 5
16406: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
16407: LD_VAR 0 1
16411: PPUSH
16412: LD_VAR 0 2
16416: PPUSH
16417: CALL 42704 0 2
// end ;
16421: PPOPN 2
16423: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
16424: LD_VAR 0 1
16428: PPUSH
16429: CALL_OW 247
16433: PUSH
16434: LD_INT 2
16436: EQUAL
16437: IFFALSE 16441
// exit ;
16439: GO 16458
// if not kamikazed then
16441: LD_EXP 11
16445: NOT
16446: IFFALSE 16458
// kamikazed := unit ;
16448: LD_ADDR_EXP 11
16452: PUSH
16453: LD_VAR 0 1
16457: ST_TO_ADDR
// end ;
16458: PPOPN 1
16460: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
16461: LD_INT 0
16463: PPUSH
16464: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16465: LD_VAR 0 1
16469: PPUSH
16470: LD_VAR 0 2
16474: PPUSH
16475: LD_VAR 0 3
16479: PPUSH
16480: LD_VAR 0 4
16484: PPUSH
16485: CALL 42542 0 4
// end ;
16489: PPOPN 6
16491: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16492: LD_VAR 0 1
16496: PPUSH
16497: LD_VAR 0 2
16501: PPUSH
16502: LD_VAR 0 3
16506: PPUSH
16507: CALL 42317 0 3
// end ;
16511: PPOPN 3
16513: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16514: LD_VAR 0 1
16518: PPUSH
16519: LD_VAR 0 2
16523: PPUSH
16524: CALL 43488 0 2
// end ;
16528: PPOPN 2
16530: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16531: LD_VAR 0 1
16535: PPUSH
16536: LD_VAR 0 2
16540: PPUSH
16541: CALL 42011 0 2
// end ;
16545: PPOPN 2
16547: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16548: LD_VAR 0 1
16552: PPUSH
16553: LD_VAR 0 2
16557: PPUSH
16558: CALL 42202 0 2
// end ;
16562: PPOPN 2
16564: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16565: LD_VAR 0 1
16569: PPUSH
16570: CALL 45060 0 1
// end ;
16574: PPOPN 1
16576: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16577: LD_VAR 0 1
16581: PPUSH
16582: LD_VAR 0 2
16586: PPUSH
16587: CALL 46253 0 2
// end ;
16591: PPOPN 2
16593: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16594: LD_VAR 0 1
16598: PPUSH
16599: LD_VAR 0 2
16603: PPUSH
16604: LD_VAR 0 3
16608: PPUSH
16609: LD_VAR 0 4
16613: PPUSH
16614: CALL 46469 0 4
// end ;
16618: PPOPN 4
16620: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
16621: LD_VAR 0 1
16625: PPUSH
16626: CALL 89765 0 1
// end ; end_of_file
16630: PPOPN 1
16632: END
// every 0 0$1 trigger game do
16633: LD_EXP 2
16637: IFFALSE 16667
16639: GO 16641
16641: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
16642: LD_INT 7
16644: PUSH
16645: LD_INT 6
16647: PUSH
16648: LD_INT 4
16650: PUSH
16651: LD_INT 6
16653: PUSH
16654: EMPTY
16655: LIST
16656: LIST
16657: LIST
16658: LIST
16659: PPUSH
16660: LD_INT 1750
16662: PPUSH
16663: CALL 16668 0 2
16667: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
16668: LD_INT 0
16670: PPUSH
16671: PPUSH
16672: PPUSH
// if not areas then
16673: LD_VAR 0 1
16677: NOT
16678: IFFALSE 16682
// exit ;
16680: GO 16812
// repeat wait ( time ) ;
16682: LD_VAR 0 2
16686: PPUSH
16687: CALL_OW 67
// p := rand ( 1 , 90 ) ;
16691: LD_ADDR_VAR 0 5
16695: PUSH
16696: LD_INT 1
16698: PPUSH
16699: LD_INT 90
16701: PPUSH
16702: CALL_OW 12
16706: ST_TO_ADDR
// for i in areas do
16707: LD_ADDR_VAR 0 4
16711: PUSH
16712: LD_VAR 0 1
16716: PUSH
16717: FOR_IN
16718: IFFALSE 16771
// begin if Prob ( p ) then
16720: LD_VAR 0 5
16724: PPUSH
16725: CALL_OW 13
16729: IFFALSE 16769
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
16731: LD_INT 1
16733: PPUSH
16734: LD_INT 5
16736: PPUSH
16737: CALL_OW 12
16741: PPUSH
16742: LD_VAR 0 4
16746: PPUSH
16747: LD_INT 1
16749: PPUSH
16750: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
16754: LD_INT 385
16756: PPUSH
16757: LD_INT 595
16759: PPUSH
16760: CALL_OW 12
16764: PPUSH
16765: CALL_OW 67
// end ; end ;
16769: GO 16717
16771: POP
16772: POP
// time := time + 0 0$3 ;
16773: LD_ADDR_VAR 0 2
16777: PUSH
16778: LD_VAR 0 2
16782: PUSH
16783: LD_INT 105
16785: PLUS
16786: ST_TO_ADDR
// if time > 7 7$00 then
16787: LD_VAR 0 2
16791: PUSH
16792: LD_INT 14700
16794: GREATER
16795: IFFALSE 16805
// time := 0 0$40 ;
16797: LD_ADDR_VAR 0 2
16801: PUSH
16802: LD_INT 1400
16804: ST_TO_ADDR
// until not game ;
16805: LD_EXP 2
16809: NOT
16810: IFFALSE 16682
// end ; end_of_file
16812: LD_VAR 0 3
16816: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
16817: LD_INT 0
16819: PPUSH
16820: PPUSH
// skirmish := false ;
16821: LD_ADDR_EXP 47
16825: PUSH
16826: LD_INT 0
16828: ST_TO_ADDR
// debug_mc := false ;
16829: LD_ADDR_EXP 48
16833: PUSH
16834: LD_INT 0
16836: ST_TO_ADDR
// mc_bases := [ ] ;
16837: LD_ADDR_EXP 49
16841: PUSH
16842: EMPTY
16843: ST_TO_ADDR
// mc_sides := [ ] ;
16844: LD_ADDR_EXP 75
16848: PUSH
16849: EMPTY
16850: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
16851: LD_ADDR_EXP 50
16855: PUSH
16856: EMPTY
16857: ST_TO_ADDR
// mc_building_repairs := [ ] ;
16858: LD_ADDR_EXP 51
16862: PUSH
16863: EMPTY
16864: ST_TO_ADDR
// mc_need_heal := [ ] ;
16865: LD_ADDR_EXP 52
16869: PUSH
16870: EMPTY
16871: ST_TO_ADDR
// mc_healers := [ ] ;
16872: LD_ADDR_EXP 53
16876: PUSH
16877: EMPTY
16878: ST_TO_ADDR
// mc_build_list := [ ] ;
16879: LD_ADDR_EXP 54
16883: PUSH
16884: EMPTY
16885: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
16886: LD_ADDR_EXP 81
16890: PUSH
16891: EMPTY
16892: ST_TO_ADDR
// mc_builders := [ ] ;
16893: LD_ADDR_EXP 55
16897: PUSH
16898: EMPTY
16899: ST_TO_ADDR
// mc_construct_list := [ ] ;
16900: LD_ADDR_EXP 56
16904: PUSH
16905: EMPTY
16906: ST_TO_ADDR
// mc_turret_list := [ ] ;
16907: LD_ADDR_EXP 57
16911: PUSH
16912: EMPTY
16913: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
16914: LD_ADDR_EXP 58
16918: PUSH
16919: EMPTY
16920: ST_TO_ADDR
// mc_miners := [ ] ;
16921: LD_ADDR_EXP 63
16925: PUSH
16926: EMPTY
16927: ST_TO_ADDR
// mc_mines := [ ] ;
16928: LD_ADDR_EXP 62
16932: PUSH
16933: EMPTY
16934: ST_TO_ADDR
// mc_minefields := [ ] ;
16935: LD_ADDR_EXP 64
16939: PUSH
16940: EMPTY
16941: ST_TO_ADDR
// mc_crates := [ ] ;
16942: LD_ADDR_EXP 65
16946: PUSH
16947: EMPTY
16948: ST_TO_ADDR
// mc_crates_collector := [ ] ;
16949: LD_ADDR_EXP 66
16953: PUSH
16954: EMPTY
16955: ST_TO_ADDR
// mc_crates_area := [ ] ;
16956: LD_ADDR_EXP 67
16960: PUSH
16961: EMPTY
16962: ST_TO_ADDR
// mc_vehicles := [ ] ;
16963: LD_ADDR_EXP 68
16967: PUSH
16968: EMPTY
16969: ST_TO_ADDR
// mc_attack := [ ] ;
16970: LD_ADDR_EXP 69
16974: PUSH
16975: EMPTY
16976: ST_TO_ADDR
// mc_produce := [ ] ;
16977: LD_ADDR_EXP 70
16981: PUSH
16982: EMPTY
16983: ST_TO_ADDR
// mc_defender := [ ] ;
16984: LD_ADDR_EXP 71
16988: PUSH
16989: EMPTY
16990: ST_TO_ADDR
// mc_parking := [ ] ;
16991: LD_ADDR_EXP 73
16995: PUSH
16996: EMPTY
16997: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
16998: LD_ADDR_EXP 59
17002: PUSH
17003: EMPTY
17004: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
17005: LD_ADDR_EXP 61
17009: PUSH
17010: EMPTY
17011: ST_TO_ADDR
// mc_scan := [ ] ;
17012: LD_ADDR_EXP 72
17016: PUSH
17017: EMPTY
17018: ST_TO_ADDR
// mc_scan_area := [ ] ;
17019: LD_ADDR_EXP 74
17023: PUSH
17024: EMPTY
17025: ST_TO_ADDR
// mc_tech := [ ] ;
17026: LD_ADDR_EXP 76
17030: PUSH
17031: EMPTY
17032: ST_TO_ADDR
// mc_class := [ ] ;
17033: LD_ADDR_EXP 90
17037: PUSH
17038: EMPTY
17039: ST_TO_ADDR
// mc_class_case_use := [ ] ;
17040: LD_ADDR_EXP 91
17044: PUSH
17045: EMPTY
17046: ST_TO_ADDR
// end ;
17047: LD_VAR 0 1
17051: RET
// export function MC_Kill ( base ) ; begin
17052: LD_INT 0
17054: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
17055: LD_ADDR_EXP 49
17059: PUSH
17060: LD_EXP 49
17064: PPUSH
17065: LD_VAR 0 1
17069: PPUSH
17070: EMPTY
17071: PPUSH
17072: CALL_OW 1
17076: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
17077: LD_ADDR_EXP 50
17081: PUSH
17082: LD_EXP 50
17086: PPUSH
17087: LD_VAR 0 1
17091: PPUSH
17092: EMPTY
17093: PPUSH
17094: CALL_OW 1
17098: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
17099: LD_ADDR_EXP 51
17103: PUSH
17104: LD_EXP 51
17108: PPUSH
17109: LD_VAR 0 1
17113: PPUSH
17114: EMPTY
17115: PPUSH
17116: CALL_OW 1
17120: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
17121: LD_ADDR_EXP 52
17125: PUSH
17126: LD_EXP 52
17130: PPUSH
17131: LD_VAR 0 1
17135: PPUSH
17136: EMPTY
17137: PPUSH
17138: CALL_OW 1
17142: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
17143: LD_ADDR_EXP 53
17147: PUSH
17148: LD_EXP 53
17152: PPUSH
17153: LD_VAR 0 1
17157: PPUSH
17158: EMPTY
17159: PPUSH
17160: CALL_OW 1
17164: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
17165: LD_ADDR_EXP 54
17169: PUSH
17170: LD_EXP 54
17174: PPUSH
17175: LD_VAR 0 1
17179: PPUSH
17180: EMPTY
17181: PPUSH
17182: CALL_OW 1
17186: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
17187: LD_ADDR_EXP 55
17191: PUSH
17192: LD_EXP 55
17196: PPUSH
17197: LD_VAR 0 1
17201: PPUSH
17202: EMPTY
17203: PPUSH
17204: CALL_OW 1
17208: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
17209: LD_ADDR_EXP 56
17213: PUSH
17214: LD_EXP 56
17218: PPUSH
17219: LD_VAR 0 1
17223: PPUSH
17224: EMPTY
17225: PPUSH
17226: CALL_OW 1
17230: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17231: LD_ADDR_EXP 57
17235: PUSH
17236: LD_EXP 57
17240: PPUSH
17241: LD_VAR 0 1
17245: PPUSH
17246: EMPTY
17247: PPUSH
17248: CALL_OW 1
17252: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17253: LD_ADDR_EXP 58
17257: PUSH
17258: LD_EXP 58
17262: PPUSH
17263: LD_VAR 0 1
17267: PPUSH
17268: EMPTY
17269: PPUSH
17270: CALL_OW 1
17274: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17275: LD_ADDR_EXP 59
17279: PUSH
17280: LD_EXP 59
17284: PPUSH
17285: LD_VAR 0 1
17289: PPUSH
17290: EMPTY
17291: PPUSH
17292: CALL_OW 1
17296: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17297: LD_ADDR_EXP 60
17301: PUSH
17302: LD_EXP 60
17306: PPUSH
17307: LD_VAR 0 1
17311: PPUSH
17312: LD_INT 0
17314: PPUSH
17315: CALL_OW 1
17319: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17320: LD_ADDR_EXP 61
17324: PUSH
17325: LD_EXP 61
17329: PPUSH
17330: LD_VAR 0 1
17334: PPUSH
17335: EMPTY
17336: PPUSH
17337: CALL_OW 1
17341: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17342: LD_ADDR_EXP 62
17346: PUSH
17347: LD_EXP 62
17351: PPUSH
17352: LD_VAR 0 1
17356: PPUSH
17357: EMPTY
17358: PPUSH
17359: CALL_OW 1
17363: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17364: LD_ADDR_EXP 63
17368: PUSH
17369: LD_EXP 63
17373: PPUSH
17374: LD_VAR 0 1
17378: PPUSH
17379: EMPTY
17380: PPUSH
17381: CALL_OW 1
17385: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
17386: LD_ADDR_EXP 64
17390: PUSH
17391: LD_EXP 64
17395: PPUSH
17396: LD_VAR 0 1
17400: PPUSH
17401: EMPTY
17402: PPUSH
17403: CALL_OW 1
17407: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
17408: LD_ADDR_EXP 65
17412: PUSH
17413: LD_EXP 65
17417: PPUSH
17418: LD_VAR 0 1
17422: PPUSH
17423: EMPTY
17424: PPUSH
17425: CALL_OW 1
17429: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
17430: LD_ADDR_EXP 66
17434: PUSH
17435: LD_EXP 66
17439: PPUSH
17440: LD_VAR 0 1
17444: PPUSH
17445: EMPTY
17446: PPUSH
17447: CALL_OW 1
17451: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
17452: LD_ADDR_EXP 67
17456: PUSH
17457: LD_EXP 67
17461: PPUSH
17462: LD_VAR 0 1
17466: PPUSH
17467: EMPTY
17468: PPUSH
17469: CALL_OW 1
17473: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
17474: LD_ADDR_EXP 68
17478: PUSH
17479: LD_EXP 68
17483: PPUSH
17484: LD_VAR 0 1
17488: PPUSH
17489: EMPTY
17490: PPUSH
17491: CALL_OW 1
17495: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
17496: LD_ADDR_EXP 69
17500: PUSH
17501: LD_EXP 69
17505: PPUSH
17506: LD_VAR 0 1
17510: PPUSH
17511: EMPTY
17512: PPUSH
17513: CALL_OW 1
17517: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
17518: LD_ADDR_EXP 70
17522: PUSH
17523: LD_EXP 70
17527: PPUSH
17528: LD_VAR 0 1
17532: PPUSH
17533: EMPTY
17534: PPUSH
17535: CALL_OW 1
17539: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
17540: LD_ADDR_EXP 71
17544: PUSH
17545: LD_EXP 71
17549: PPUSH
17550: LD_VAR 0 1
17554: PPUSH
17555: EMPTY
17556: PPUSH
17557: CALL_OW 1
17561: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
17562: LD_ADDR_EXP 72
17566: PUSH
17567: LD_EXP 72
17571: PPUSH
17572: LD_VAR 0 1
17576: PPUSH
17577: EMPTY
17578: PPUSH
17579: CALL_OW 1
17583: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
17584: LD_ADDR_EXP 73
17588: PUSH
17589: LD_EXP 73
17593: PPUSH
17594: LD_VAR 0 1
17598: PPUSH
17599: EMPTY
17600: PPUSH
17601: CALL_OW 1
17605: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
17606: LD_ADDR_EXP 74
17610: PUSH
17611: LD_EXP 74
17615: PPUSH
17616: LD_VAR 0 1
17620: PPUSH
17621: EMPTY
17622: PPUSH
17623: CALL_OW 1
17627: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
17628: LD_ADDR_EXP 76
17632: PUSH
17633: LD_EXP 76
17637: PPUSH
17638: LD_VAR 0 1
17642: PPUSH
17643: EMPTY
17644: PPUSH
17645: CALL_OW 1
17649: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
17650: LD_ADDR_EXP 78
17654: PUSH
17655: LD_EXP 78
17659: PPUSH
17660: LD_VAR 0 1
17664: PPUSH
17665: EMPTY
17666: PPUSH
17667: CALL_OW 1
17671: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
17672: LD_ADDR_EXP 79
17676: PUSH
17677: LD_EXP 79
17681: PPUSH
17682: LD_VAR 0 1
17686: PPUSH
17687: EMPTY
17688: PPUSH
17689: CALL_OW 1
17693: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
17694: LD_ADDR_EXP 80
17698: PUSH
17699: LD_EXP 80
17703: PPUSH
17704: LD_VAR 0 1
17708: PPUSH
17709: EMPTY
17710: PPUSH
17711: CALL_OW 1
17715: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
17716: LD_ADDR_EXP 81
17720: PUSH
17721: LD_EXP 81
17725: PPUSH
17726: LD_VAR 0 1
17730: PPUSH
17731: EMPTY
17732: PPUSH
17733: CALL_OW 1
17737: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
17738: LD_ADDR_EXP 82
17742: PUSH
17743: LD_EXP 82
17747: PPUSH
17748: LD_VAR 0 1
17752: PPUSH
17753: EMPTY
17754: PPUSH
17755: CALL_OW 1
17759: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
17760: LD_ADDR_EXP 83
17764: PUSH
17765: LD_EXP 83
17769: PPUSH
17770: LD_VAR 0 1
17774: PPUSH
17775: EMPTY
17776: PPUSH
17777: CALL_OW 1
17781: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
17782: LD_ADDR_EXP 84
17786: PUSH
17787: LD_EXP 84
17791: PPUSH
17792: LD_VAR 0 1
17796: PPUSH
17797: EMPTY
17798: PPUSH
17799: CALL_OW 1
17803: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
17804: LD_ADDR_EXP 85
17808: PUSH
17809: LD_EXP 85
17813: PPUSH
17814: LD_VAR 0 1
17818: PPUSH
17819: EMPTY
17820: PPUSH
17821: CALL_OW 1
17825: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
17826: LD_ADDR_EXP 86
17830: PUSH
17831: LD_EXP 86
17835: PPUSH
17836: LD_VAR 0 1
17840: PPUSH
17841: EMPTY
17842: PPUSH
17843: CALL_OW 1
17847: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
17848: LD_ADDR_EXP 87
17852: PUSH
17853: LD_EXP 87
17857: PPUSH
17858: LD_VAR 0 1
17862: PPUSH
17863: EMPTY
17864: PPUSH
17865: CALL_OW 1
17869: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
17870: LD_ADDR_EXP 88
17874: PUSH
17875: LD_EXP 88
17879: PPUSH
17880: LD_VAR 0 1
17884: PPUSH
17885: EMPTY
17886: PPUSH
17887: CALL_OW 1
17891: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
17892: LD_ADDR_EXP 89
17896: PUSH
17897: LD_EXP 89
17901: PPUSH
17902: LD_VAR 0 1
17906: PPUSH
17907: EMPTY
17908: PPUSH
17909: CALL_OW 1
17913: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
17914: LD_ADDR_EXP 90
17918: PUSH
17919: LD_EXP 90
17923: PPUSH
17924: LD_VAR 0 1
17928: PPUSH
17929: EMPTY
17930: PPUSH
17931: CALL_OW 1
17935: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
17936: LD_ADDR_EXP 91
17940: PUSH
17941: LD_EXP 91
17945: PPUSH
17946: LD_VAR 0 1
17950: PPUSH
17951: LD_INT 0
17953: PPUSH
17954: CALL_OW 1
17958: ST_TO_ADDR
// end ;
17959: LD_VAR 0 2
17963: RET
// export function MC_Add ( side , units ) ; var base ; begin
17964: LD_INT 0
17966: PPUSH
17967: PPUSH
// base := mc_bases + 1 ;
17968: LD_ADDR_VAR 0 4
17972: PUSH
17973: LD_EXP 49
17977: PUSH
17978: LD_INT 1
17980: PLUS
17981: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
17982: LD_ADDR_EXP 75
17986: PUSH
17987: LD_EXP 75
17991: PPUSH
17992: LD_VAR 0 4
17996: PPUSH
17997: LD_VAR 0 1
18001: PPUSH
18002: CALL_OW 1
18006: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
18007: LD_ADDR_EXP 49
18011: PUSH
18012: LD_EXP 49
18016: PPUSH
18017: LD_VAR 0 4
18021: PPUSH
18022: LD_VAR 0 2
18026: PPUSH
18027: CALL_OW 1
18031: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18032: LD_ADDR_EXP 50
18036: PUSH
18037: LD_EXP 50
18041: PPUSH
18042: LD_VAR 0 4
18046: PPUSH
18047: EMPTY
18048: PPUSH
18049: CALL_OW 1
18053: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18054: LD_ADDR_EXP 51
18058: PUSH
18059: LD_EXP 51
18063: PPUSH
18064: LD_VAR 0 4
18068: PPUSH
18069: EMPTY
18070: PPUSH
18071: CALL_OW 1
18075: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18076: LD_ADDR_EXP 52
18080: PUSH
18081: LD_EXP 52
18085: PPUSH
18086: LD_VAR 0 4
18090: PPUSH
18091: EMPTY
18092: PPUSH
18093: CALL_OW 1
18097: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18098: LD_ADDR_EXP 53
18102: PUSH
18103: LD_EXP 53
18107: PPUSH
18108: LD_VAR 0 4
18112: PPUSH
18113: EMPTY
18114: PPUSH
18115: CALL_OW 1
18119: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18120: LD_ADDR_EXP 54
18124: PUSH
18125: LD_EXP 54
18129: PPUSH
18130: LD_VAR 0 4
18134: PPUSH
18135: EMPTY
18136: PPUSH
18137: CALL_OW 1
18141: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18142: LD_ADDR_EXP 55
18146: PUSH
18147: LD_EXP 55
18151: PPUSH
18152: LD_VAR 0 4
18156: PPUSH
18157: EMPTY
18158: PPUSH
18159: CALL_OW 1
18163: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18164: LD_ADDR_EXP 56
18168: PUSH
18169: LD_EXP 56
18173: PPUSH
18174: LD_VAR 0 4
18178: PPUSH
18179: EMPTY
18180: PPUSH
18181: CALL_OW 1
18185: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18186: LD_ADDR_EXP 57
18190: PUSH
18191: LD_EXP 57
18195: PPUSH
18196: LD_VAR 0 4
18200: PPUSH
18201: EMPTY
18202: PPUSH
18203: CALL_OW 1
18207: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18208: LD_ADDR_EXP 58
18212: PUSH
18213: LD_EXP 58
18217: PPUSH
18218: LD_VAR 0 4
18222: PPUSH
18223: EMPTY
18224: PPUSH
18225: CALL_OW 1
18229: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18230: LD_ADDR_EXP 59
18234: PUSH
18235: LD_EXP 59
18239: PPUSH
18240: LD_VAR 0 4
18244: PPUSH
18245: EMPTY
18246: PPUSH
18247: CALL_OW 1
18251: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18252: LD_ADDR_EXP 60
18256: PUSH
18257: LD_EXP 60
18261: PPUSH
18262: LD_VAR 0 4
18266: PPUSH
18267: LD_INT 0
18269: PPUSH
18270: CALL_OW 1
18274: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18275: LD_ADDR_EXP 61
18279: PUSH
18280: LD_EXP 61
18284: PPUSH
18285: LD_VAR 0 4
18289: PPUSH
18290: EMPTY
18291: PPUSH
18292: CALL_OW 1
18296: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18297: LD_ADDR_EXP 62
18301: PUSH
18302: LD_EXP 62
18306: PPUSH
18307: LD_VAR 0 4
18311: PPUSH
18312: EMPTY
18313: PPUSH
18314: CALL_OW 1
18318: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18319: LD_ADDR_EXP 63
18323: PUSH
18324: LD_EXP 63
18328: PPUSH
18329: LD_VAR 0 4
18333: PPUSH
18334: EMPTY
18335: PPUSH
18336: CALL_OW 1
18340: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18341: LD_ADDR_EXP 64
18345: PUSH
18346: LD_EXP 64
18350: PPUSH
18351: LD_VAR 0 4
18355: PPUSH
18356: EMPTY
18357: PPUSH
18358: CALL_OW 1
18362: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18363: LD_ADDR_EXP 65
18367: PUSH
18368: LD_EXP 65
18372: PPUSH
18373: LD_VAR 0 4
18377: PPUSH
18378: EMPTY
18379: PPUSH
18380: CALL_OW 1
18384: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18385: LD_ADDR_EXP 66
18389: PUSH
18390: LD_EXP 66
18394: PPUSH
18395: LD_VAR 0 4
18399: PPUSH
18400: EMPTY
18401: PPUSH
18402: CALL_OW 1
18406: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18407: LD_ADDR_EXP 67
18411: PUSH
18412: LD_EXP 67
18416: PPUSH
18417: LD_VAR 0 4
18421: PPUSH
18422: EMPTY
18423: PPUSH
18424: CALL_OW 1
18428: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18429: LD_ADDR_EXP 68
18433: PUSH
18434: LD_EXP 68
18438: PPUSH
18439: LD_VAR 0 4
18443: PPUSH
18444: EMPTY
18445: PPUSH
18446: CALL_OW 1
18450: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18451: LD_ADDR_EXP 69
18455: PUSH
18456: LD_EXP 69
18460: PPUSH
18461: LD_VAR 0 4
18465: PPUSH
18466: EMPTY
18467: PPUSH
18468: CALL_OW 1
18472: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18473: LD_ADDR_EXP 70
18477: PUSH
18478: LD_EXP 70
18482: PPUSH
18483: LD_VAR 0 4
18487: PPUSH
18488: EMPTY
18489: PPUSH
18490: CALL_OW 1
18494: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18495: LD_ADDR_EXP 71
18499: PUSH
18500: LD_EXP 71
18504: PPUSH
18505: LD_VAR 0 4
18509: PPUSH
18510: EMPTY
18511: PPUSH
18512: CALL_OW 1
18516: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18517: LD_ADDR_EXP 72
18521: PUSH
18522: LD_EXP 72
18526: PPUSH
18527: LD_VAR 0 4
18531: PPUSH
18532: EMPTY
18533: PPUSH
18534: CALL_OW 1
18538: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18539: LD_ADDR_EXP 73
18543: PUSH
18544: LD_EXP 73
18548: PPUSH
18549: LD_VAR 0 4
18553: PPUSH
18554: EMPTY
18555: PPUSH
18556: CALL_OW 1
18560: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18561: LD_ADDR_EXP 74
18565: PUSH
18566: LD_EXP 74
18570: PPUSH
18571: LD_VAR 0 4
18575: PPUSH
18576: EMPTY
18577: PPUSH
18578: CALL_OW 1
18582: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18583: LD_ADDR_EXP 76
18587: PUSH
18588: LD_EXP 76
18592: PPUSH
18593: LD_VAR 0 4
18597: PPUSH
18598: EMPTY
18599: PPUSH
18600: CALL_OW 1
18604: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18605: LD_ADDR_EXP 78
18609: PUSH
18610: LD_EXP 78
18614: PPUSH
18615: LD_VAR 0 4
18619: PPUSH
18620: EMPTY
18621: PPUSH
18622: CALL_OW 1
18626: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18627: LD_ADDR_EXP 79
18631: PUSH
18632: LD_EXP 79
18636: PPUSH
18637: LD_VAR 0 4
18641: PPUSH
18642: EMPTY
18643: PPUSH
18644: CALL_OW 1
18648: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18649: LD_ADDR_EXP 80
18653: PUSH
18654: LD_EXP 80
18658: PPUSH
18659: LD_VAR 0 4
18663: PPUSH
18664: EMPTY
18665: PPUSH
18666: CALL_OW 1
18670: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18671: LD_ADDR_EXP 81
18675: PUSH
18676: LD_EXP 81
18680: PPUSH
18681: LD_VAR 0 4
18685: PPUSH
18686: EMPTY
18687: PPUSH
18688: CALL_OW 1
18692: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18693: LD_ADDR_EXP 82
18697: PUSH
18698: LD_EXP 82
18702: PPUSH
18703: LD_VAR 0 4
18707: PPUSH
18708: EMPTY
18709: PPUSH
18710: CALL_OW 1
18714: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18715: LD_ADDR_EXP 83
18719: PUSH
18720: LD_EXP 83
18724: PPUSH
18725: LD_VAR 0 4
18729: PPUSH
18730: EMPTY
18731: PPUSH
18732: CALL_OW 1
18736: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18737: LD_ADDR_EXP 84
18741: PUSH
18742: LD_EXP 84
18746: PPUSH
18747: LD_VAR 0 4
18751: PPUSH
18752: EMPTY
18753: PPUSH
18754: CALL_OW 1
18758: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18759: LD_ADDR_EXP 85
18763: PUSH
18764: LD_EXP 85
18768: PPUSH
18769: LD_VAR 0 4
18773: PPUSH
18774: EMPTY
18775: PPUSH
18776: CALL_OW 1
18780: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18781: LD_ADDR_EXP 86
18785: PUSH
18786: LD_EXP 86
18790: PPUSH
18791: LD_VAR 0 4
18795: PPUSH
18796: EMPTY
18797: PPUSH
18798: CALL_OW 1
18802: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18803: LD_ADDR_EXP 87
18807: PUSH
18808: LD_EXP 87
18812: PPUSH
18813: LD_VAR 0 4
18817: PPUSH
18818: EMPTY
18819: PPUSH
18820: CALL_OW 1
18824: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18825: LD_ADDR_EXP 88
18829: PUSH
18830: LD_EXP 88
18834: PPUSH
18835: LD_VAR 0 4
18839: PPUSH
18840: EMPTY
18841: PPUSH
18842: CALL_OW 1
18846: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18847: LD_ADDR_EXP 89
18851: PUSH
18852: LD_EXP 89
18856: PPUSH
18857: LD_VAR 0 4
18861: PPUSH
18862: EMPTY
18863: PPUSH
18864: CALL_OW 1
18868: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18869: LD_ADDR_EXP 90
18873: PUSH
18874: LD_EXP 90
18878: PPUSH
18879: LD_VAR 0 4
18883: PPUSH
18884: EMPTY
18885: PPUSH
18886: CALL_OW 1
18890: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18891: LD_ADDR_EXP 91
18895: PUSH
18896: LD_EXP 91
18900: PPUSH
18901: LD_VAR 0 4
18905: PPUSH
18906: LD_INT 0
18908: PPUSH
18909: CALL_OW 1
18913: ST_TO_ADDR
// result := base ;
18914: LD_ADDR_VAR 0 3
18918: PUSH
18919: LD_VAR 0 4
18923: ST_TO_ADDR
// end ;
18924: LD_VAR 0 3
18928: RET
// export function MC_Start ( ) ; var i ; begin
18929: LD_INT 0
18931: PPUSH
18932: PPUSH
// for i = 1 to mc_bases do
18933: LD_ADDR_VAR 0 2
18937: PUSH
18938: DOUBLE
18939: LD_INT 1
18941: DEC
18942: ST_TO_ADDR
18943: LD_EXP 49
18947: PUSH
18948: FOR_TO
18949: IFFALSE 20026
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
18951: LD_ADDR_EXP 49
18955: PUSH
18956: LD_EXP 49
18960: PPUSH
18961: LD_VAR 0 2
18965: PPUSH
18966: LD_EXP 49
18970: PUSH
18971: LD_VAR 0 2
18975: ARRAY
18976: PUSH
18977: LD_INT 0
18979: DIFF
18980: PPUSH
18981: CALL_OW 1
18985: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
18986: LD_ADDR_EXP 50
18990: PUSH
18991: LD_EXP 50
18995: PPUSH
18996: LD_VAR 0 2
19000: PPUSH
19001: EMPTY
19002: PPUSH
19003: CALL_OW 1
19007: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19008: LD_ADDR_EXP 51
19012: PUSH
19013: LD_EXP 51
19017: PPUSH
19018: LD_VAR 0 2
19022: PPUSH
19023: EMPTY
19024: PPUSH
19025: CALL_OW 1
19029: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
19030: LD_ADDR_EXP 52
19034: PUSH
19035: LD_EXP 52
19039: PPUSH
19040: LD_VAR 0 2
19044: PPUSH
19045: EMPTY
19046: PPUSH
19047: CALL_OW 1
19051: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
19052: LD_ADDR_EXP 53
19056: PUSH
19057: LD_EXP 53
19061: PPUSH
19062: LD_VAR 0 2
19066: PPUSH
19067: EMPTY
19068: PUSH
19069: EMPTY
19070: PUSH
19071: EMPTY
19072: LIST
19073: LIST
19074: PPUSH
19075: CALL_OW 1
19079: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
19080: LD_ADDR_EXP 54
19084: PUSH
19085: LD_EXP 54
19089: PPUSH
19090: LD_VAR 0 2
19094: PPUSH
19095: EMPTY
19096: PPUSH
19097: CALL_OW 1
19101: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
19102: LD_ADDR_EXP 81
19106: PUSH
19107: LD_EXP 81
19111: PPUSH
19112: LD_VAR 0 2
19116: PPUSH
19117: EMPTY
19118: PPUSH
19119: CALL_OW 1
19123: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
19124: LD_ADDR_EXP 55
19128: PUSH
19129: LD_EXP 55
19133: PPUSH
19134: LD_VAR 0 2
19138: PPUSH
19139: EMPTY
19140: PPUSH
19141: CALL_OW 1
19145: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
19146: LD_ADDR_EXP 56
19150: PUSH
19151: LD_EXP 56
19155: PPUSH
19156: LD_VAR 0 2
19160: PPUSH
19161: EMPTY
19162: PPUSH
19163: CALL_OW 1
19167: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
19168: LD_ADDR_EXP 57
19172: PUSH
19173: LD_EXP 57
19177: PPUSH
19178: LD_VAR 0 2
19182: PPUSH
19183: LD_EXP 49
19187: PUSH
19188: LD_VAR 0 2
19192: ARRAY
19193: PPUSH
19194: LD_INT 2
19196: PUSH
19197: LD_INT 30
19199: PUSH
19200: LD_INT 32
19202: PUSH
19203: EMPTY
19204: LIST
19205: LIST
19206: PUSH
19207: LD_INT 30
19209: PUSH
19210: LD_INT 33
19212: PUSH
19213: EMPTY
19214: LIST
19215: LIST
19216: PUSH
19217: EMPTY
19218: LIST
19219: LIST
19220: LIST
19221: PPUSH
19222: CALL_OW 72
19226: PPUSH
19227: CALL_OW 1
19231: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
19232: LD_ADDR_EXP 58
19236: PUSH
19237: LD_EXP 58
19241: PPUSH
19242: LD_VAR 0 2
19246: PPUSH
19247: LD_EXP 49
19251: PUSH
19252: LD_VAR 0 2
19256: ARRAY
19257: PPUSH
19258: LD_INT 2
19260: PUSH
19261: LD_INT 30
19263: PUSH
19264: LD_INT 32
19266: PUSH
19267: EMPTY
19268: LIST
19269: LIST
19270: PUSH
19271: LD_INT 30
19273: PUSH
19274: LD_INT 31
19276: PUSH
19277: EMPTY
19278: LIST
19279: LIST
19280: PUSH
19281: EMPTY
19282: LIST
19283: LIST
19284: LIST
19285: PUSH
19286: LD_INT 58
19288: PUSH
19289: EMPTY
19290: LIST
19291: PUSH
19292: EMPTY
19293: LIST
19294: LIST
19295: PPUSH
19296: CALL_OW 72
19300: PPUSH
19301: CALL_OW 1
19305: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
19306: LD_ADDR_EXP 59
19310: PUSH
19311: LD_EXP 59
19315: PPUSH
19316: LD_VAR 0 2
19320: PPUSH
19321: EMPTY
19322: PPUSH
19323: CALL_OW 1
19327: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
19328: LD_ADDR_EXP 63
19332: PUSH
19333: LD_EXP 63
19337: PPUSH
19338: LD_VAR 0 2
19342: PPUSH
19343: EMPTY
19344: PPUSH
19345: CALL_OW 1
19349: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
19350: LD_ADDR_EXP 62
19354: PUSH
19355: LD_EXP 62
19359: PPUSH
19360: LD_VAR 0 2
19364: PPUSH
19365: EMPTY
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
19372: LD_ADDR_EXP 64
19376: PUSH
19377: LD_EXP 64
19381: PPUSH
19382: LD_VAR 0 2
19386: PPUSH
19387: EMPTY
19388: PPUSH
19389: CALL_OW 1
19393: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
19394: LD_ADDR_EXP 65
19398: PUSH
19399: LD_EXP 65
19403: PPUSH
19404: LD_VAR 0 2
19408: PPUSH
19409: EMPTY
19410: PPUSH
19411: CALL_OW 1
19415: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
19416: LD_ADDR_EXP 66
19420: PUSH
19421: LD_EXP 66
19425: PPUSH
19426: LD_VAR 0 2
19430: PPUSH
19431: EMPTY
19432: PPUSH
19433: CALL_OW 1
19437: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
19438: LD_ADDR_EXP 67
19442: PUSH
19443: LD_EXP 67
19447: PPUSH
19448: LD_VAR 0 2
19452: PPUSH
19453: EMPTY
19454: PPUSH
19455: CALL_OW 1
19459: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
19460: LD_ADDR_EXP 68
19464: PUSH
19465: LD_EXP 68
19469: PPUSH
19470: LD_VAR 0 2
19474: PPUSH
19475: EMPTY
19476: PPUSH
19477: CALL_OW 1
19481: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
19482: LD_ADDR_EXP 69
19486: PUSH
19487: LD_EXP 69
19491: PPUSH
19492: LD_VAR 0 2
19496: PPUSH
19497: EMPTY
19498: PPUSH
19499: CALL_OW 1
19503: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
19504: LD_ADDR_EXP 70
19508: PUSH
19509: LD_EXP 70
19513: PPUSH
19514: LD_VAR 0 2
19518: PPUSH
19519: EMPTY
19520: PPUSH
19521: CALL_OW 1
19525: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
19526: LD_ADDR_EXP 71
19530: PUSH
19531: LD_EXP 71
19535: PPUSH
19536: LD_VAR 0 2
19540: PPUSH
19541: EMPTY
19542: PPUSH
19543: CALL_OW 1
19547: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
19548: LD_ADDR_EXP 60
19552: PUSH
19553: LD_EXP 60
19557: PPUSH
19558: LD_VAR 0 2
19562: PPUSH
19563: LD_INT 0
19565: PPUSH
19566: CALL_OW 1
19570: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
19571: LD_ADDR_EXP 73
19575: PUSH
19576: LD_EXP 73
19580: PPUSH
19581: LD_VAR 0 2
19585: PPUSH
19586: LD_INT 0
19588: PPUSH
19589: CALL_OW 1
19593: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
19594: LD_ADDR_EXP 61
19598: PUSH
19599: LD_EXP 61
19603: PPUSH
19604: LD_VAR 0 2
19608: PPUSH
19609: EMPTY
19610: PPUSH
19611: CALL_OW 1
19615: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
19616: LD_ADDR_EXP 72
19620: PUSH
19621: LD_EXP 72
19625: PPUSH
19626: LD_VAR 0 2
19630: PPUSH
19631: LD_INT 0
19633: PPUSH
19634: CALL_OW 1
19638: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
19639: LD_ADDR_EXP 74
19643: PUSH
19644: LD_EXP 74
19648: PPUSH
19649: LD_VAR 0 2
19653: PPUSH
19654: EMPTY
19655: PPUSH
19656: CALL_OW 1
19660: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
19661: LD_ADDR_EXP 77
19665: PUSH
19666: LD_EXP 77
19670: PPUSH
19671: LD_VAR 0 2
19675: PPUSH
19676: LD_INT 0
19678: PPUSH
19679: CALL_OW 1
19683: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
19684: LD_ADDR_EXP 78
19688: PUSH
19689: LD_EXP 78
19693: PPUSH
19694: LD_VAR 0 2
19698: PPUSH
19699: EMPTY
19700: PPUSH
19701: CALL_OW 1
19705: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
19706: LD_ADDR_EXP 79
19710: PUSH
19711: LD_EXP 79
19715: PPUSH
19716: LD_VAR 0 2
19720: PPUSH
19721: EMPTY
19722: PPUSH
19723: CALL_OW 1
19727: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
19728: LD_ADDR_EXP 80
19732: PUSH
19733: LD_EXP 80
19737: PPUSH
19738: LD_VAR 0 2
19742: PPUSH
19743: EMPTY
19744: PPUSH
19745: CALL_OW 1
19749: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
19750: LD_ADDR_EXP 82
19754: PUSH
19755: LD_EXP 82
19759: PPUSH
19760: LD_VAR 0 2
19764: PPUSH
19765: LD_EXP 49
19769: PUSH
19770: LD_VAR 0 2
19774: ARRAY
19775: PPUSH
19776: LD_INT 2
19778: PUSH
19779: LD_INT 30
19781: PUSH
19782: LD_INT 6
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 30
19791: PUSH
19792: LD_INT 7
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: PUSH
19799: LD_INT 30
19801: PUSH
19802: LD_INT 8
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: PUSH
19809: EMPTY
19810: LIST
19811: LIST
19812: LIST
19813: LIST
19814: PPUSH
19815: CALL_OW 72
19819: PPUSH
19820: CALL_OW 1
19824: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
19825: LD_ADDR_EXP 83
19829: PUSH
19830: LD_EXP 83
19834: PPUSH
19835: LD_VAR 0 2
19839: PPUSH
19840: EMPTY
19841: PPUSH
19842: CALL_OW 1
19846: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
19847: LD_ADDR_EXP 84
19851: PUSH
19852: LD_EXP 84
19856: PPUSH
19857: LD_VAR 0 2
19861: PPUSH
19862: EMPTY
19863: PPUSH
19864: CALL_OW 1
19868: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
19869: LD_ADDR_EXP 85
19873: PUSH
19874: LD_EXP 85
19878: PPUSH
19879: LD_VAR 0 2
19883: PPUSH
19884: EMPTY
19885: PPUSH
19886: CALL_OW 1
19890: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
19891: LD_ADDR_EXP 86
19895: PUSH
19896: LD_EXP 86
19900: PPUSH
19901: LD_VAR 0 2
19905: PPUSH
19906: EMPTY
19907: PPUSH
19908: CALL_OW 1
19912: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
19913: LD_ADDR_EXP 87
19917: PUSH
19918: LD_EXP 87
19922: PPUSH
19923: LD_VAR 0 2
19927: PPUSH
19928: EMPTY
19929: PPUSH
19930: CALL_OW 1
19934: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
19935: LD_ADDR_EXP 88
19939: PUSH
19940: LD_EXP 88
19944: PPUSH
19945: LD_VAR 0 2
19949: PPUSH
19950: EMPTY
19951: PPUSH
19952: CALL_OW 1
19956: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
19957: LD_ADDR_EXP 89
19961: PUSH
19962: LD_EXP 89
19966: PPUSH
19967: LD_VAR 0 2
19971: PPUSH
19972: EMPTY
19973: PPUSH
19974: CALL_OW 1
19978: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
19979: LD_ADDR_EXP 90
19983: PUSH
19984: LD_EXP 90
19988: PPUSH
19989: LD_VAR 0 2
19993: PPUSH
19994: EMPTY
19995: PPUSH
19996: CALL_OW 1
20000: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
20001: LD_ADDR_EXP 91
20005: PUSH
20006: LD_EXP 91
20010: PPUSH
20011: LD_VAR 0 2
20015: PPUSH
20016: LD_INT 0
20018: PPUSH
20019: CALL_OW 1
20023: ST_TO_ADDR
// end ;
20024: GO 18948
20026: POP
20027: POP
// MC_InitSides ( ) ;
20028: CALL 20314 0 0
// MC_InitResearch ( ) ;
20032: CALL 20053 0 0
// CustomInitMacro ( ) ;
20036: CALL 292 0 0
// skirmish := true ;
20040: LD_ADDR_EXP 47
20044: PUSH
20045: LD_INT 1
20047: ST_TO_ADDR
// end ;
20048: LD_VAR 0 1
20052: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
20053: LD_INT 0
20055: PPUSH
20056: PPUSH
20057: PPUSH
20058: PPUSH
20059: PPUSH
20060: PPUSH
// if not mc_bases then
20061: LD_EXP 49
20065: NOT
20066: IFFALSE 20070
// exit ;
20068: GO 20309
// for i = 1 to 8 do
20070: LD_ADDR_VAR 0 2
20074: PUSH
20075: DOUBLE
20076: LD_INT 1
20078: DEC
20079: ST_TO_ADDR
20080: LD_INT 8
20082: PUSH
20083: FOR_TO
20084: IFFALSE 20110
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
20086: LD_ADDR_EXP 76
20090: PUSH
20091: LD_EXP 76
20095: PPUSH
20096: LD_VAR 0 2
20100: PPUSH
20101: EMPTY
20102: PPUSH
20103: CALL_OW 1
20107: ST_TO_ADDR
20108: GO 20083
20110: POP
20111: POP
// tmp := [ ] ;
20112: LD_ADDR_VAR 0 5
20116: PUSH
20117: EMPTY
20118: ST_TO_ADDR
// for i = 1 to mc_sides do
20119: LD_ADDR_VAR 0 2
20123: PUSH
20124: DOUBLE
20125: LD_INT 1
20127: DEC
20128: ST_TO_ADDR
20129: LD_EXP 75
20133: PUSH
20134: FOR_TO
20135: IFFALSE 20193
// if not mc_sides [ i ] in tmp then
20137: LD_EXP 75
20141: PUSH
20142: LD_VAR 0 2
20146: ARRAY
20147: PUSH
20148: LD_VAR 0 5
20152: IN
20153: NOT
20154: IFFALSE 20191
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
20156: LD_ADDR_VAR 0 5
20160: PUSH
20161: LD_VAR 0 5
20165: PPUSH
20166: LD_VAR 0 5
20170: PUSH
20171: LD_INT 1
20173: PLUS
20174: PPUSH
20175: LD_EXP 75
20179: PUSH
20180: LD_VAR 0 2
20184: ARRAY
20185: PPUSH
20186: CALL_OW 2
20190: ST_TO_ADDR
20191: GO 20134
20193: POP
20194: POP
// if not tmp then
20195: LD_VAR 0 5
20199: NOT
20200: IFFALSE 20204
// exit ;
20202: GO 20309
// for j in tmp do
20204: LD_ADDR_VAR 0 3
20208: PUSH
20209: LD_VAR 0 5
20213: PUSH
20214: FOR_IN
20215: IFFALSE 20307
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
20217: LD_ADDR_VAR 0 6
20221: PUSH
20222: LD_INT 22
20224: PUSH
20225: LD_VAR 0 3
20229: PUSH
20230: EMPTY
20231: LIST
20232: LIST
20233: PPUSH
20234: CALL_OW 69
20238: ST_TO_ADDR
// if not un then
20239: LD_VAR 0 6
20243: NOT
20244: IFFALSE 20248
// continue ;
20246: GO 20214
// nation := GetNation ( un [ 1 ] ) ;
20248: LD_ADDR_VAR 0 4
20252: PUSH
20253: LD_VAR 0 6
20257: PUSH
20258: LD_INT 1
20260: ARRAY
20261: PPUSH
20262: CALL_OW 248
20266: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
20267: LD_ADDR_EXP 76
20271: PUSH
20272: LD_EXP 76
20276: PPUSH
20277: LD_VAR 0 3
20281: PPUSH
20282: LD_VAR 0 3
20286: PPUSH
20287: LD_VAR 0 4
20291: PPUSH
20292: LD_INT 1
20294: PPUSH
20295: CALL 46673 0 3
20299: PPUSH
20300: CALL_OW 1
20304: ST_TO_ADDR
// end ;
20305: GO 20214
20307: POP
20308: POP
// end ;
20309: LD_VAR 0 1
20313: RET
// export function MC_InitSides ( ) ; var i ; begin
20314: LD_INT 0
20316: PPUSH
20317: PPUSH
// if not mc_bases then
20318: LD_EXP 49
20322: NOT
20323: IFFALSE 20327
// exit ;
20325: GO 20401
// for i = 1 to mc_bases do
20327: LD_ADDR_VAR 0 2
20331: PUSH
20332: DOUBLE
20333: LD_INT 1
20335: DEC
20336: ST_TO_ADDR
20337: LD_EXP 49
20341: PUSH
20342: FOR_TO
20343: IFFALSE 20399
// if mc_bases [ i ] then
20345: LD_EXP 49
20349: PUSH
20350: LD_VAR 0 2
20354: ARRAY
20355: IFFALSE 20397
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
20357: LD_ADDR_EXP 75
20361: PUSH
20362: LD_EXP 75
20366: PPUSH
20367: LD_VAR 0 2
20371: PPUSH
20372: LD_EXP 49
20376: PUSH
20377: LD_VAR 0 2
20381: ARRAY
20382: PUSH
20383: LD_INT 1
20385: ARRAY
20386: PPUSH
20387: CALL_OW 255
20391: PPUSH
20392: CALL_OW 1
20396: ST_TO_ADDR
20397: GO 20342
20399: POP
20400: POP
// end ;
20401: LD_VAR 0 1
20405: RET
// every 0 0$01 trigger skirmish do
20406: LD_EXP 47
20410: IFFALSE 20564
20412: GO 20414
20414: DISABLE
// begin enable ;
20415: ENABLE
// MC_CheckBuildings ( ) ;
20416: CALL 25062 0 0
// MC_CheckPeopleLife ( ) ;
20420: CALL 25187 0 0
// RaiseSailEvent ( 100 ) ;
20424: LD_INT 100
20426: PPUSH
20427: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
20431: LD_INT 103
20433: PPUSH
20434: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
20438: LD_INT 104
20440: PPUSH
20441: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
20445: LD_INT 105
20447: PPUSH
20448: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
20452: LD_INT 106
20454: PPUSH
20455: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
20459: LD_INT 107
20461: PPUSH
20462: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
20466: LD_INT 108
20468: PPUSH
20469: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
20473: LD_INT 109
20475: PPUSH
20476: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
20480: LD_INT 110
20482: PPUSH
20483: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
20487: LD_INT 111
20489: PPUSH
20490: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
20494: LD_INT 112
20496: PPUSH
20497: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
20501: LD_INT 113
20503: PPUSH
20504: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
20508: LD_INT 120
20510: PPUSH
20511: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
20515: LD_INT 121
20517: PPUSH
20518: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
20522: LD_INT 122
20524: PPUSH
20525: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
20529: LD_INT 123
20531: PPUSH
20532: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
20536: LD_INT 124
20538: PPUSH
20539: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
20543: LD_INT 125
20545: PPUSH
20546: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
20550: LD_INT 126
20552: PPUSH
20553: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
20557: LD_INT 200
20559: PPUSH
20560: CALL_OW 427
// end ;
20564: END
// on SailEvent ( event ) do begin if event < 100 then
20565: LD_VAR 0 1
20569: PUSH
20570: LD_INT 100
20572: LESS
20573: IFFALSE 20584
// CustomEvent ( event ) ;
20575: LD_VAR 0 1
20579: PPUSH
20580: CALL 16106 0 1
// if event = 100 then
20584: LD_VAR 0 1
20588: PUSH
20589: LD_INT 100
20591: EQUAL
20592: IFFALSE 20598
// MC_ClassManager ( ) ;
20594: CALL 20990 0 0
// if event = 101 then
20598: LD_VAR 0 1
20602: PUSH
20603: LD_INT 101
20605: EQUAL
20606: IFFALSE 20612
// MC_RepairBuildings ( ) ;
20608: CALL 25783 0 0
// if event = 102 then
20612: LD_VAR 0 1
20616: PUSH
20617: LD_INT 102
20619: EQUAL
20620: IFFALSE 20626
// MC_Heal ( ) ;
20622: CALL 26515 0 0
// if event = 103 then
20626: LD_VAR 0 1
20630: PUSH
20631: LD_INT 103
20633: EQUAL
20634: IFFALSE 20640
// MC_Build ( ) ;
20636: CALL 26937 0 0
// if event = 104 then
20640: LD_VAR 0 1
20644: PUSH
20645: LD_INT 104
20647: EQUAL
20648: IFFALSE 20654
// MC_TurretWeapon ( ) ;
20650: CALL 28550 0 0
// if event = 105 then
20654: LD_VAR 0 1
20658: PUSH
20659: LD_INT 105
20661: EQUAL
20662: IFFALSE 20668
// MC_BuildUpgrade ( ) ;
20664: CALL 28101 0 0
// if event = 106 then
20668: LD_VAR 0 1
20672: PUSH
20673: LD_INT 106
20675: EQUAL
20676: IFFALSE 20682
// MC_PlantMines ( ) ;
20678: CALL 28980 0 0
// if event = 107 then
20682: LD_VAR 0 1
20686: PUSH
20687: LD_INT 107
20689: EQUAL
20690: IFFALSE 20696
// MC_CollectCrates ( ) ;
20692: CALL 30014 0 0
// if event = 108 then
20696: LD_VAR 0 1
20700: PUSH
20701: LD_INT 108
20703: EQUAL
20704: IFFALSE 20710
// MC_LinkRemoteControl ( ) ;
20706: CALL 31790 0 0
// if event = 109 then
20710: LD_VAR 0 1
20714: PUSH
20715: LD_INT 109
20717: EQUAL
20718: IFFALSE 20724
// MC_ProduceVehicle ( ) ;
20720: CALL 31971 0 0
// if event = 110 then
20724: LD_VAR 0 1
20728: PUSH
20729: LD_INT 110
20731: EQUAL
20732: IFFALSE 20738
// MC_SendAttack ( ) ;
20734: CALL 32437 0 0
// if event = 111 then
20738: LD_VAR 0 1
20742: PUSH
20743: LD_INT 111
20745: EQUAL
20746: IFFALSE 20752
// MC_Defend ( ) ;
20748: CALL 32545 0 0
// if event = 112 then
20752: LD_VAR 0 1
20756: PUSH
20757: LD_INT 112
20759: EQUAL
20760: IFFALSE 20766
// MC_Research ( ) ;
20762: CALL 33150 0 0
// if event = 113 then
20766: LD_VAR 0 1
20770: PUSH
20771: LD_INT 113
20773: EQUAL
20774: IFFALSE 20780
// MC_MinesTrigger ( ) ;
20776: CALL 34264 0 0
// if event = 120 then
20780: LD_VAR 0 1
20784: PUSH
20785: LD_INT 120
20787: EQUAL
20788: IFFALSE 20794
// MC_RepairVehicle ( ) ;
20790: CALL 34363 0 0
// if event = 121 then
20794: LD_VAR 0 1
20798: PUSH
20799: LD_INT 121
20801: EQUAL
20802: IFFALSE 20808
// MC_TameApe ( ) ;
20804: CALL 35093 0 0
// if event = 122 then
20808: LD_VAR 0 1
20812: PUSH
20813: LD_INT 122
20815: EQUAL
20816: IFFALSE 20822
// MC_ChangeApeClass ( ) ;
20818: CALL 35922 0 0
// if event = 123 then
20822: LD_VAR 0 1
20826: PUSH
20827: LD_INT 123
20829: EQUAL
20830: IFFALSE 20836
// MC_Bazooka ( ) ;
20832: CALL 36572 0 0
// if event = 124 then
20836: LD_VAR 0 1
20840: PUSH
20841: LD_INT 124
20843: EQUAL
20844: IFFALSE 20850
// MC_TeleportExit ( ) ;
20846: CALL 36770 0 0
// if event = 125 then
20850: LD_VAR 0 1
20854: PUSH
20855: LD_INT 125
20857: EQUAL
20858: IFFALSE 20864
// MC_Deposits ( ) ;
20860: CALL 37417 0 0
// if event = 126 then
20864: LD_VAR 0 1
20868: PUSH
20869: LD_INT 126
20871: EQUAL
20872: IFFALSE 20878
// MC_RemoteDriver ( ) ;
20874: CALL 38042 0 0
// if event = 200 then
20878: LD_VAR 0 1
20882: PUSH
20883: LD_INT 200
20885: EQUAL
20886: IFFALSE 20892
// MC_Idle ( ) ;
20888: CALL 39775 0 0
// end ;
20892: PPOPN 1
20894: END
// export function MC_Reset ( base , tag ) ; var i ; begin
20895: LD_INT 0
20897: PPUSH
20898: PPUSH
// if not mc_bases [ base ] or not tag then
20899: LD_EXP 49
20903: PUSH
20904: LD_VAR 0 1
20908: ARRAY
20909: NOT
20910: PUSH
20911: LD_VAR 0 2
20915: NOT
20916: OR
20917: IFFALSE 20921
// exit ;
20919: GO 20985
// for i in mc_bases [ base ] union mc_ape [ base ] do
20921: LD_ADDR_VAR 0 4
20925: PUSH
20926: LD_EXP 49
20930: PUSH
20931: LD_VAR 0 1
20935: ARRAY
20936: PUSH
20937: LD_EXP 78
20941: PUSH
20942: LD_VAR 0 1
20946: ARRAY
20947: UNION
20948: PUSH
20949: FOR_IN
20950: IFFALSE 20983
// if GetTag ( i ) = tag then
20952: LD_VAR 0 4
20956: PPUSH
20957: CALL_OW 110
20961: PUSH
20962: LD_VAR 0 2
20966: EQUAL
20967: IFFALSE 20981
// SetTag ( i , 0 ) ;
20969: LD_VAR 0 4
20973: PPUSH
20974: LD_INT 0
20976: PPUSH
20977: CALL_OW 109
20981: GO 20949
20983: POP
20984: POP
// end ;
20985: LD_VAR 0 3
20989: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
20990: LD_INT 0
20992: PPUSH
20993: PPUSH
20994: PPUSH
20995: PPUSH
20996: PPUSH
20997: PPUSH
20998: PPUSH
20999: PPUSH
// if not mc_bases then
21000: LD_EXP 49
21004: NOT
21005: IFFALSE 21009
// exit ;
21007: GO 21467
// for i = 1 to mc_bases do
21009: LD_ADDR_VAR 0 2
21013: PUSH
21014: DOUBLE
21015: LD_INT 1
21017: DEC
21018: ST_TO_ADDR
21019: LD_EXP 49
21023: PUSH
21024: FOR_TO
21025: IFFALSE 21465
// begin tmp := MC_ClassCheckReq ( i ) ;
21027: LD_ADDR_VAR 0 4
21031: PUSH
21032: LD_VAR 0 2
21036: PPUSH
21037: CALL 21472 0 1
21041: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
21042: LD_ADDR_EXP 90
21046: PUSH
21047: LD_EXP 90
21051: PPUSH
21052: LD_VAR 0 2
21056: PPUSH
21057: LD_VAR 0 4
21061: PPUSH
21062: CALL_OW 1
21066: ST_TO_ADDR
// if not tmp then
21067: LD_VAR 0 4
21071: NOT
21072: IFFALSE 21076
// continue ;
21074: GO 21024
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
21076: LD_ADDR_VAR 0 6
21080: PUSH
21081: LD_EXP 49
21085: PUSH
21086: LD_VAR 0 2
21090: ARRAY
21091: PPUSH
21092: LD_INT 2
21094: PUSH
21095: LD_INT 30
21097: PUSH
21098: LD_INT 4
21100: PUSH
21101: EMPTY
21102: LIST
21103: LIST
21104: PUSH
21105: LD_INT 30
21107: PUSH
21108: LD_INT 5
21110: PUSH
21111: EMPTY
21112: LIST
21113: LIST
21114: PUSH
21115: EMPTY
21116: LIST
21117: LIST
21118: LIST
21119: PPUSH
21120: CALL_OW 72
21124: PUSH
21125: LD_EXP 49
21129: PUSH
21130: LD_VAR 0 2
21134: ARRAY
21135: PPUSH
21136: LD_INT 2
21138: PUSH
21139: LD_INT 30
21141: PUSH
21142: LD_INT 0
21144: PUSH
21145: EMPTY
21146: LIST
21147: LIST
21148: PUSH
21149: LD_INT 30
21151: PUSH
21152: LD_INT 1
21154: PUSH
21155: EMPTY
21156: LIST
21157: LIST
21158: PUSH
21159: EMPTY
21160: LIST
21161: LIST
21162: LIST
21163: PPUSH
21164: CALL_OW 72
21168: PUSH
21169: LD_EXP 49
21173: PUSH
21174: LD_VAR 0 2
21178: ARRAY
21179: PPUSH
21180: LD_INT 30
21182: PUSH
21183: LD_INT 3
21185: PUSH
21186: EMPTY
21187: LIST
21188: LIST
21189: PPUSH
21190: CALL_OW 72
21194: PUSH
21195: LD_EXP 49
21199: PUSH
21200: LD_VAR 0 2
21204: ARRAY
21205: PPUSH
21206: LD_INT 2
21208: PUSH
21209: LD_INT 30
21211: PUSH
21212: LD_INT 6
21214: PUSH
21215: EMPTY
21216: LIST
21217: LIST
21218: PUSH
21219: LD_INT 30
21221: PUSH
21222: LD_INT 7
21224: PUSH
21225: EMPTY
21226: LIST
21227: LIST
21228: PUSH
21229: LD_INT 30
21231: PUSH
21232: LD_INT 8
21234: PUSH
21235: EMPTY
21236: LIST
21237: LIST
21238: PUSH
21239: EMPTY
21240: LIST
21241: LIST
21242: LIST
21243: LIST
21244: PPUSH
21245: CALL_OW 72
21249: PUSH
21250: EMPTY
21251: LIST
21252: LIST
21253: LIST
21254: LIST
21255: ST_TO_ADDR
// for j = 1 to 4 do
21256: LD_ADDR_VAR 0 3
21260: PUSH
21261: DOUBLE
21262: LD_INT 1
21264: DEC
21265: ST_TO_ADDR
21266: LD_INT 4
21268: PUSH
21269: FOR_TO
21270: IFFALSE 21461
// begin if not tmp [ j ] then
21272: LD_VAR 0 4
21276: PUSH
21277: LD_VAR 0 3
21281: ARRAY
21282: NOT
21283: IFFALSE 21287
// continue ;
21285: GO 21269
// for p in tmp [ j ] do
21287: LD_ADDR_VAR 0 5
21291: PUSH
21292: LD_VAR 0 4
21296: PUSH
21297: LD_VAR 0 3
21301: ARRAY
21302: PUSH
21303: FOR_IN
21304: IFFALSE 21457
// begin if not b [ j ] then
21306: LD_VAR 0 6
21310: PUSH
21311: LD_VAR 0 3
21315: ARRAY
21316: NOT
21317: IFFALSE 21321
// break ;
21319: GO 21457
// e := 0 ;
21321: LD_ADDR_VAR 0 7
21325: PUSH
21326: LD_INT 0
21328: ST_TO_ADDR
// for k in b [ j ] do
21329: LD_ADDR_VAR 0 8
21333: PUSH
21334: LD_VAR 0 6
21338: PUSH
21339: LD_VAR 0 3
21343: ARRAY
21344: PUSH
21345: FOR_IN
21346: IFFALSE 21373
// if IsNotFull ( k ) then
21348: LD_VAR 0 8
21352: PPUSH
21353: CALL 50964 0 1
21357: IFFALSE 21371
// begin e := k ;
21359: LD_ADDR_VAR 0 7
21363: PUSH
21364: LD_VAR 0 8
21368: ST_TO_ADDR
// break ;
21369: GO 21373
// end ;
21371: GO 21345
21373: POP
21374: POP
// if e and not UnitGoingToBuilding ( p , e ) then
21375: LD_VAR 0 7
21379: PUSH
21380: LD_VAR 0 5
21384: PPUSH
21385: LD_VAR 0 7
21389: PPUSH
21390: CALL 88083 0 2
21394: NOT
21395: AND
21396: IFFALSE 21455
// begin if IsInUnit ( p ) then
21398: LD_VAR 0 5
21402: PPUSH
21403: CALL_OW 310
21407: IFFALSE 21418
// ComExitBuilding ( p ) ;
21409: LD_VAR 0 5
21413: PPUSH
21414: CALL_OW 122
// ComEnterUnit ( p , e ) ;
21418: LD_VAR 0 5
21422: PPUSH
21423: LD_VAR 0 7
21427: PPUSH
21428: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
21432: LD_VAR 0 5
21436: PPUSH
21437: LD_VAR 0 3
21441: PPUSH
21442: CALL_OW 183
// AddComExitBuilding ( p ) ;
21446: LD_VAR 0 5
21450: PPUSH
21451: CALL_OW 182
// end ; end ;
21455: GO 21303
21457: POP
21458: POP
// end ;
21459: GO 21269
21461: POP
21462: POP
// end ;
21463: GO 21024
21465: POP
21466: POP
// end ;
21467: LD_VAR 0 1
21471: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
21472: LD_INT 0
21474: PPUSH
21475: PPUSH
21476: PPUSH
21477: PPUSH
21478: PPUSH
21479: PPUSH
21480: PPUSH
21481: PPUSH
21482: PPUSH
21483: PPUSH
21484: PPUSH
21485: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
21486: LD_VAR 0 1
21490: NOT
21491: PUSH
21492: LD_EXP 49
21496: PUSH
21497: LD_VAR 0 1
21501: ARRAY
21502: NOT
21503: OR
21504: PUSH
21505: LD_EXP 49
21509: PUSH
21510: LD_VAR 0 1
21514: ARRAY
21515: PPUSH
21516: LD_INT 2
21518: PUSH
21519: LD_INT 30
21521: PUSH
21522: LD_INT 0
21524: PUSH
21525: EMPTY
21526: LIST
21527: LIST
21528: PUSH
21529: LD_INT 30
21531: PUSH
21532: LD_INT 1
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: PUSH
21539: EMPTY
21540: LIST
21541: LIST
21542: LIST
21543: PPUSH
21544: CALL_OW 72
21548: NOT
21549: OR
21550: IFFALSE 21554
// exit ;
21552: GO 25057
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
21554: LD_ADDR_VAR 0 4
21558: PUSH
21559: LD_EXP 49
21563: PUSH
21564: LD_VAR 0 1
21568: ARRAY
21569: PPUSH
21570: LD_INT 2
21572: PUSH
21573: LD_INT 25
21575: PUSH
21576: LD_INT 1
21578: PUSH
21579: EMPTY
21580: LIST
21581: LIST
21582: PUSH
21583: LD_INT 25
21585: PUSH
21586: LD_INT 2
21588: PUSH
21589: EMPTY
21590: LIST
21591: LIST
21592: PUSH
21593: LD_INT 25
21595: PUSH
21596: LD_INT 3
21598: PUSH
21599: EMPTY
21600: LIST
21601: LIST
21602: PUSH
21603: LD_INT 25
21605: PUSH
21606: LD_INT 4
21608: PUSH
21609: EMPTY
21610: LIST
21611: LIST
21612: PUSH
21613: LD_INT 25
21615: PUSH
21616: LD_INT 5
21618: PUSH
21619: EMPTY
21620: LIST
21621: LIST
21622: PUSH
21623: LD_INT 25
21625: PUSH
21626: LD_INT 8
21628: PUSH
21629: EMPTY
21630: LIST
21631: LIST
21632: PUSH
21633: LD_INT 25
21635: PUSH
21636: LD_INT 9
21638: PUSH
21639: EMPTY
21640: LIST
21641: LIST
21642: PUSH
21643: EMPTY
21644: LIST
21645: LIST
21646: LIST
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: LIST
21652: PPUSH
21653: CALL_OW 72
21657: ST_TO_ADDR
// if not tmp then
21658: LD_VAR 0 4
21662: NOT
21663: IFFALSE 21667
// exit ;
21665: GO 25057
// for i in tmp do
21667: LD_ADDR_VAR 0 3
21671: PUSH
21672: LD_VAR 0 4
21676: PUSH
21677: FOR_IN
21678: IFFALSE 21709
// if GetTag ( i ) then
21680: LD_VAR 0 3
21684: PPUSH
21685: CALL_OW 110
21689: IFFALSE 21707
// tmp := tmp diff i ;
21691: LD_ADDR_VAR 0 4
21695: PUSH
21696: LD_VAR 0 4
21700: PUSH
21701: LD_VAR 0 3
21705: DIFF
21706: ST_TO_ADDR
21707: GO 21677
21709: POP
21710: POP
// if not tmp then
21711: LD_VAR 0 4
21715: NOT
21716: IFFALSE 21720
// exit ;
21718: GO 25057
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
21720: LD_ADDR_VAR 0 5
21724: PUSH
21725: LD_EXP 49
21729: PUSH
21730: LD_VAR 0 1
21734: ARRAY
21735: PPUSH
21736: LD_INT 2
21738: PUSH
21739: LD_INT 25
21741: PUSH
21742: LD_INT 1
21744: PUSH
21745: EMPTY
21746: LIST
21747: LIST
21748: PUSH
21749: LD_INT 25
21751: PUSH
21752: LD_INT 5
21754: PUSH
21755: EMPTY
21756: LIST
21757: LIST
21758: PUSH
21759: LD_INT 25
21761: PUSH
21762: LD_INT 8
21764: PUSH
21765: EMPTY
21766: LIST
21767: LIST
21768: PUSH
21769: LD_INT 25
21771: PUSH
21772: LD_INT 9
21774: PUSH
21775: EMPTY
21776: LIST
21777: LIST
21778: PUSH
21779: EMPTY
21780: LIST
21781: LIST
21782: LIST
21783: LIST
21784: LIST
21785: PPUSH
21786: CALL_OW 72
21790: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
21791: LD_ADDR_VAR 0 6
21795: PUSH
21796: LD_EXP 49
21800: PUSH
21801: LD_VAR 0 1
21805: ARRAY
21806: PPUSH
21807: LD_INT 25
21809: PUSH
21810: LD_INT 2
21812: PUSH
21813: EMPTY
21814: LIST
21815: LIST
21816: PPUSH
21817: CALL_OW 72
21821: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
21822: LD_ADDR_VAR 0 7
21826: PUSH
21827: LD_EXP 49
21831: PUSH
21832: LD_VAR 0 1
21836: ARRAY
21837: PPUSH
21838: LD_INT 25
21840: PUSH
21841: LD_INT 3
21843: PUSH
21844: EMPTY
21845: LIST
21846: LIST
21847: PPUSH
21848: CALL_OW 72
21852: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
21853: LD_ADDR_VAR 0 8
21857: PUSH
21858: LD_EXP 49
21862: PUSH
21863: LD_VAR 0 1
21867: ARRAY
21868: PPUSH
21869: LD_INT 25
21871: PUSH
21872: LD_INT 4
21874: PUSH
21875: EMPTY
21876: LIST
21877: LIST
21878: PUSH
21879: LD_INT 24
21881: PUSH
21882: LD_INT 251
21884: PUSH
21885: EMPTY
21886: LIST
21887: LIST
21888: PUSH
21889: EMPTY
21890: LIST
21891: LIST
21892: PPUSH
21893: CALL_OW 72
21897: ST_TO_ADDR
// if mc_scan [ base ] then
21898: LD_EXP 72
21902: PUSH
21903: LD_VAR 0 1
21907: ARRAY
21908: IFFALSE 22369
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
21910: LD_ADDR_EXP 91
21914: PUSH
21915: LD_EXP 91
21919: PPUSH
21920: LD_VAR 0 1
21924: PPUSH
21925: LD_INT 4
21927: PPUSH
21928: CALL_OW 1
21932: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
21933: LD_ADDR_VAR 0 12
21937: PUSH
21938: LD_EXP 49
21942: PUSH
21943: LD_VAR 0 1
21947: ARRAY
21948: PPUSH
21949: LD_INT 2
21951: PUSH
21952: LD_INT 30
21954: PUSH
21955: LD_INT 4
21957: PUSH
21958: EMPTY
21959: LIST
21960: LIST
21961: PUSH
21962: LD_INT 30
21964: PUSH
21965: LD_INT 5
21967: PUSH
21968: EMPTY
21969: LIST
21970: LIST
21971: PUSH
21972: EMPTY
21973: LIST
21974: LIST
21975: LIST
21976: PPUSH
21977: CALL_OW 72
21981: ST_TO_ADDR
// if not b then
21982: LD_VAR 0 12
21986: NOT
21987: IFFALSE 21991
// exit ;
21989: GO 25057
// p := [ ] ;
21991: LD_ADDR_VAR 0 11
21995: PUSH
21996: EMPTY
21997: ST_TO_ADDR
// if sci >= 2 then
21998: LD_VAR 0 8
22002: PUSH
22003: LD_INT 2
22005: GREATEREQUAL
22006: IFFALSE 22037
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
22008: LD_ADDR_VAR 0 8
22012: PUSH
22013: LD_VAR 0 8
22017: PUSH
22018: LD_INT 1
22020: ARRAY
22021: PUSH
22022: LD_VAR 0 8
22026: PUSH
22027: LD_INT 2
22029: ARRAY
22030: PUSH
22031: EMPTY
22032: LIST
22033: LIST
22034: ST_TO_ADDR
22035: GO 22098
// if sci = 1 then
22037: LD_VAR 0 8
22041: PUSH
22042: LD_INT 1
22044: EQUAL
22045: IFFALSE 22066
// sci := [ sci [ 1 ] ] else
22047: LD_ADDR_VAR 0 8
22051: PUSH
22052: LD_VAR 0 8
22056: PUSH
22057: LD_INT 1
22059: ARRAY
22060: PUSH
22061: EMPTY
22062: LIST
22063: ST_TO_ADDR
22064: GO 22098
// if sci = 0 then
22066: LD_VAR 0 8
22070: PUSH
22071: LD_INT 0
22073: EQUAL
22074: IFFALSE 22098
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
22076: LD_ADDR_VAR 0 11
22080: PUSH
22081: LD_VAR 0 4
22085: PPUSH
22086: LD_INT 4
22088: PPUSH
22089: CALL 87946 0 2
22093: PUSH
22094: LD_INT 1
22096: ARRAY
22097: ST_TO_ADDR
// if eng > 4 then
22098: LD_VAR 0 6
22102: PUSH
22103: LD_INT 4
22105: GREATER
22106: IFFALSE 22152
// for i = eng downto 4 do
22108: LD_ADDR_VAR 0 3
22112: PUSH
22113: DOUBLE
22114: LD_VAR 0 6
22118: INC
22119: ST_TO_ADDR
22120: LD_INT 4
22122: PUSH
22123: FOR_DOWNTO
22124: IFFALSE 22150
// eng := eng diff eng [ i ] ;
22126: LD_ADDR_VAR 0 6
22130: PUSH
22131: LD_VAR 0 6
22135: PUSH
22136: LD_VAR 0 6
22140: PUSH
22141: LD_VAR 0 3
22145: ARRAY
22146: DIFF
22147: ST_TO_ADDR
22148: GO 22123
22150: POP
22151: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
22152: LD_ADDR_VAR 0 4
22156: PUSH
22157: LD_VAR 0 4
22161: PUSH
22162: LD_VAR 0 5
22166: PUSH
22167: LD_VAR 0 6
22171: UNION
22172: PUSH
22173: LD_VAR 0 7
22177: UNION
22178: PUSH
22179: LD_VAR 0 8
22183: UNION
22184: DIFF
22185: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
22186: LD_ADDR_VAR 0 13
22190: PUSH
22191: LD_EXP 49
22195: PUSH
22196: LD_VAR 0 1
22200: ARRAY
22201: PPUSH
22202: LD_INT 2
22204: PUSH
22205: LD_INT 30
22207: PUSH
22208: LD_INT 32
22210: PUSH
22211: EMPTY
22212: LIST
22213: LIST
22214: PUSH
22215: LD_INT 30
22217: PUSH
22218: LD_INT 31
22220: PUSH
22221: EMPTY
22222: LIST
22223: LIST
22224: PUSH
22225: EMPTY
22226: LIST
22227: LIST
22228: LIST
22229: PPUSH
22230: CALL_OW 72
22234: PUSH
22235: LD_EXP 49
22239: PUSH
22240: LD_VAR 0 1
22244: ARRAY
22245: PPUSH
22246: LD_INT 2
22248: PUSH
22249: LD_INT 30
22251: PUSH
22252: LD_INT 4
22254: PUSH
22255: EMPTY
22256: LIST
22257: LIST
22258: PUSH
22259: LD_INT 30
22261: PUSH
22262: LD_INT 5
22264: PUSH
22265: EMPTY
22266: LIST
22267: LIST
22268: PUSH
22269: EMPTY
22270: LIST
22271: LIST
22272: LIST
22273: PPUSH
22274: CALL_OW 72
22278: PUSH
22279: LD_INT 6
22281: MUL
22282: PLUS
22283: ST_TO_ADDR
// if bcount < tmp then
22284: LD_VAR 0 13
22288: PUSH
22289: LD_VAR 0 4
22293: LESS
22294: IFFALSE 22340
// for i = tmp downto bcount do
22296: LD_ADDR_VAR 0 3
22300: PUSH
22301: DOUBLE
22302: LD_VAR 0 4
22306: INC
22307: ST_TO_ADDR
22308: LD_VAR 0 13
22312: PUSH
22313: FOR_DOWNTO
22314: IFFALSE 22338
// tmp := Delete ( tmp , tmp ) ;
22316: LD_ADDR_VAR 0 4
22320: PUSH
22321: LD_VAR 0 4
22325: PPUSH
22326: LD_VAR 0 4
22330: PPUSH
22331: CALL_OW 3
22335: ST_TO_ADDR
22336: GO 22313
22338: POP
22339: POP
// result := [ tmp , 0 , 0 , p ] ;
22340: LD_ADDR_VAR 0 2
22344: PUSH
22345: LD_VAR 0 4
22349: PUSH
22350: LD_INT 0
22352: PUSH
22353: LD_INT 0
22355: PUSH
22356: LD_VAR 0 11
22360: PUSH
22361: EMPTY
22362: LIST
22363: LIST
22364: LIST
22365: LIST
22366: ST_TO_ADDR
// exit ;
22367: GO 25057
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22369: LD_EXP 49
22373: PUSH
22374: LD_VAR 0 1
22378: ARRAY
22379: PPUSH
22380: LD_INT 2
22382: PUSH
22383: LD_INT 30
22385: PUSH
22386: LD_INT 6
22388: PUSH
22389: EMPTY
22390: LIST
22391: LIST
22392: PUSH
22393: LD_INT 30
22395: PUSH
22396: LD_INT 7
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: PUSH
22403: LD_INT 30
22405: PUSH
22406: LD_INT 8
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: PUSH
22413: EMPTY
22414: LIST
22415: LIST
22416: LIST
22417: LIST
22418: PPUSH
22419: CALL_OW 72
22423: NOT
22424: PUSH
22425: LD_EXP 49
22429: PUSH
22430: LD_VAR 0 1
22434: ARRAY
22435: PPUSH
22436: LD_INT 30
22438: PUSH
22439: LD_INT 3
22441: PUSH
22442: EMPTY
22443: LIST
22444: LIST
22445: PPUSH
22446: CALL_OW 72
22450: NOT
22451: AND
22452: IFFALSE 22524
// begin if eng = tmp then
22454: LD_VAR 0 6
22458: PUSH
22459: LD_VAR 0 4
22463: EQUAL
22464: IFFALSE 22468
// exit ;
22466: GO 25057
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
22468: LD_ADDR_EXP 91
22472: PUSH
22473: LD_EXP 91
22477: PPUSH
22478: LD_VAR 0 1
22482: PPUSH
22483: LD_INT 1
22485: PPUSH
22486: CALL_OW 1
22490: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
22491: LD_ADDR_VAR 0 2
22495: PUSH
22496: LD_INT 0
22498: PUSH
22499: LD_VAR 0 4
22503: PUSH
22504: LD_VAR 0 6
22508: DIFF
22509: PUSH
22510: LD_INT 0
22512: PUSH
22513: LD_INT 0
22515: PUSH
22516: EMPTY
22517: LIST
22518: LIST
22519: LIST
22520: LIST
22521: ST_TO_ADDR
// exit ;
22522: GO 25057
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22524: LD_EXP 76
22528: PUSH
22529: LD_EXP 75
22533: PUSH
22534: LD_VAR 0 1
22538: ARRAY
22539: ARRAY
22540: PUSH
22541: LD_EXP 49
22545: PUSH
22546: LD_VAR 0 1
22550: ARRAY
22551: PPUSH
22552: LD_INT 2
22554: PUSH
22555: LD_INT 30
22557: PUSH
22558: LD_INT 6
22560: PUSH
22561: EMPTY
22562: LIST
22563: LIST
22564: PUSH
22565: LD_INT 30
22567: PUSH
22568: LD_INT 7
22570: PUSH
22571: EMPTY
22572: LIST
22573: LIST
22574: PUSH
22575: LD_INT 30
22577: PUSH
22578: LD_INT 8
22580: PUSH
22581: EMPTY
22582: LIST
22583: LIST
22584: PUSH
22585: EMPTY
22586: LIST
22587: LIST
22588: LIST
22589: LIST
22590: PPUSH
22591: CALL_OW 72
22595: AND
22596: PUSH
22597: LD_EXP 49
22601: PUSH
22602: LD_VAR 0 1
22606: ARRAY
22607: PPUSH
22608: LD_INT 30
22610: PUSH
22611: LD_INT 3
22613: PUSH
22614: EMPTY
22615: LIST
22616: LIST
22617: PPUSH
22618: CALL_OW 72
22622: NOT
22623: AND
22624: IFFALSE 22838
// begin if sci >= 6 then
22626: LD_VAR 0 8
22630: PUSH
22631: LD_INT 6
22633: GREATEREQUAL
22634: IFFALSE 22638
// exit ;
22636: GO 25057
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
22638: LD_ADDR_EXP 91
22642: PUSH
22643: LD_EXP 91
22647: PPUSH
22648: LD_VAR 0 1
22652: PPUSH
22653: LD_INT 2
22655: PPUSH
22656: CALL_OW 1
22660: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
22661: LD_ADDR_VAR 0 9
22665: PUSH
22666: LD_VAR 0 4
22670: PUSH
22671: LD_VAR 0 8
22675: DIFF
22676: PPUSH
22677: LD_INT 4
22679: PPUSH
22680: CALL 87946 0 2
22684: ST_TO_ADDR
// p := [ ] ;
22685: LD_ADDR_VAR 0 11
22689: PUSH
22690: EMPTY
22691: ST_TO_ADDR
// if sci < 6 and sort > 6 then
22692: LD_VAR 0 8
22696: PUSH
22697: LD_INT 6
22699: LESS
22700: PUSH
22701: LD_VAR 0 9
22705: PUSH
22706: LD_INT 6
22708: GREATER
22709: AND
22710: IFFALSE 22791
// begin for i = 1 to 6 - sci do
22712: LD_ADDR_VAR 0 3
22716: PUSH
22717: DOUBLE
22718: LD_INT 1
22720: DEC
22721: ST_TO_ADDR
22722: LD_INT 6
22724: PUSH
22725: LD_VAR 0 8
22729: MINUS
22730: PUSH
22731: FOR_TO
22732: IFFALSE 22787
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
22734: LD_ADDR_VAR 0 11
22738: PUSH
22739: LD_VAR 0 11
22743: PPUSH
22744: LD_VAR 0 11
22748: PUSH
22749: LD_INT 1
22751: PLUS
22752: PPUSH
22753: LD_VAR 0 9
22757: PUSH
22758: LD_INT 1
22760: ARRAY
22761: PPUSH
22762: CALL_OW 2
22766: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
22767: LD_ADDR_VAR 0 9
22771: PUSH
22772: LD_VAR 0 9
22776: PPUSH
22777: LD_INT 1
22779: PPUSH
22780: CALL_OW 3
22784: ST_TO_ADDR
// end ;
22785: GO 22731
22787: POP
22788: POP
// end else
22789: GO 22811
// if sort then
22791: LD_VAR 0 9
22795: IFFALSE 22811
// p := sort [ 1 ] ;
22797: LD_ADDR_VAR 0 11
22801: PUSH
22802: LD_VAR 0 9
22806: PUSH
22807: LD_INT 1
22809: ARRAY
22810: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
22811: LD_ADDR_VAR 0 2
22815: PUSH
22816: LD_INT 0
22818: PUSH
22819: LD_INT 0
22821: PUSH
22822: LD_INT 0
22824: PUSH
22825: LD_VAR 0 11
22829: PUSH
22830: EMPTY
22831: LIST
22832: LIST
22833: LIST
22834: LIST
22835: ST_TO_ADDR
// exit ;
22836: GO 25057
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22838: LD_EXP 76
22842: PUSH
22843: LD_EXP 75
22847: PUSH
22848: LD_VAR 0 1
22852: ARRAY
22853: ARRAY
22854: PUSH
22855: LD_EXP 49
22859: PUSH
22860: LD_VAR 0 1
22864: ARRAY
22865: PPUSH
22866: LD_INT 2
22868: PUSH
22869: LD_INT 30
22871: PUSH
22872: LD_INT 6
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: PUSH
22879: LD_INT 30
22881: PUSH
22882: LD_INT 7
22884: PUSH
22885: EMPTY
22886: LIST
22887: LIST
22888: PUSH
22889: LD_INT 30
22891: PUSH
22892: LD_INT 8
22894: PUSH
22895: EMPTY
22896: LIST
22897: LIST
22898: PUSH
22899: EMPTY
22900: LIST
22901: LIST
22902: LIST
22903: LIST
22904: PPUSH
22905: CALL_OW 72
22909: AND
22910: PUSH
22911: LD_EXP 49
22915: PUSH
22916: LD_VAR 0 1
22920: ARRAY
22921: PPUSH
22922: LD_INT 30
22924: PUSH
22925: LD_INT 3
22927: PUSH
22928: EMPTY
22929: LIST
22930: LIST
22931: PPUSH
22932: CALL_OW 72
22936: AND
22937: IFFALSE 23671
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
22939: LD_ADDR_EXP 91
22943: PUSH
22944: LD_EXP 91
22948: PPUSH
22949: LD_VAR 0 1
22953: PPUSH
22954: LD_INT 3
22956: PPUSH
22957: CALL_OW 1
22961: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
22962: LD_ADDR_VAR 0 2
22966: PUSH
22967: LD_INT 0
22969: PUSH
22970: LD_INT 0
22972: PUSH
22973: LD_INT 0
22975: PUSH
22976: LD_INT 0
22978: PUSH
22979: EMPTY
22980: LIST
22981: LIST
22982: LIST
22983: LIST
22984: ST_TO_ADDR
// if not eng then
22985: LD_VAR 0 6
22989: NOT
22990: IFFALSE 23053
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
22992: LD_ADDR_VAR 0 11
22996: PUSH
22997: LD_VAR 0 4
23001: PPUSH
23002: LD_INT 2
23004: PPUSH
23005: CALL 87946 0 2
23009: PUSH
23010: LD_INT 1
23012: ARRAY
23013: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
23014: LD_ADDR_VAR 0 2
23018: PUSH
23019: LD_VAR 0 2
23023: PPUSH
23024: LD_INT 2
23026: PPUSH
23027: LD_VAR 0 11
23031: PPUSH
23032: CALL_OW 1
23036: ST_TO_ADDR
// tmp := tmp diff p ;
23037: LD_ADDR_VAR 0 4
23041: PUSH
23042: LD_VAR 0 4
23046: PUSH
23047: LD_VAR 0 11
23051: DIFF
23052: ST_TO_ADDR
// end ; if tmp and sci < 6 then
23053: LD_VAR 0 4
23057: PUSH
23058: LD_VAR 0 8
23062: PUSH
23063: LD_INT 6
23065: LESS
23066: AND
23067: IFFALSE 23255
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
23069: LD_ADDR_VAR 0 9
23073: PUSH
23074: LD_VAR 0 4
23078: PUSH
23079: LD_VAR 0 8
23083: PUSH
23084: LD_VAR 0 7
23088: UNION
23089: DIFF
23090: PPUSH
23091: LD_INT 4
23093: PPUSH
23094: CALL 87946 0 2
23098: ST_TO_ADDR
// p := [ ] ;
23099: LD_ADDR_VAR 0 11
23103: PUSH
23104: EMPTY
23105: ST_TO_ADDR
// if sort then
23106: LD_VAR 0 9
23110: IFFALSE 23226
// for i = 1 to 6 - sci do
23112: LD_ADDR_VAR 0 3
23116: PUSH
23117: DOUBLE
23118: LD_INT 1
23120: DEC
23121: ST_TO_ADDR
23122: LD_INT 6
23124: PUSH
23125: LD_VAR 0 8
23129: MINUS
23130: PUSH
23131: FOR_TO
23132: IFFALSE 23224
// begin if i = sort then
23134: LD_VAR 0 3
23138: PUSH
23139: LD_VAR 0 9
23143: EQUAL
23144: IFFALSE 23148
// break ;
23146: GO 23224
// if GetClass ( i ) = 4 then
23148: LD_VAR 0 3
23152: PPUSH
23153: CALL_OW 257
23157: PUSH
23158: LD_INT 4
23160: EQUAL
23161: IFFALSE 23165
// continue ;
23163: GO 23131
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23165: LD_ADDR_VAR 0 11
23169: PUSH
23170: LD_VAR 0 11
23174: PPUSH
23175: LD_VAR 0 11
23179: PUSH
23180: LD_INT 1
23182: PLUS
23183: PPUSH
23184: LD_VAR 0 9
23188: PUSH
23189: LD_VAR 0 3
23193: ARRAY
23194: PPUSH
23195: CALL_OW 2
23199: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23200: LD_ADDR_VAR 0 4
23204: PUSH
23205: LD_VAR 0 4
23209: PUSH
23210: LD_VAR 0 9
23214: PUSH
23215: LD_VAR 0 3
23219: ARRAY
23220: DIFF
23221: ST_TO_ADDR
// end ;
23222: GO 23131
23224: POP
23225: POP
// if p then
23226: LD_VAR 0 11
23230: IFFALSE 23255
// result := Replace ( result , 4 , p ) ;
23232: LD_ADDR_VAR 0 2
23236: PUSH
23237: LD_VAR 0 2
23241: PPUSH
23242: LD_INT 4
23244: PPUSH
23245: LD_VAR 0 11
23249: PPUSH
23250: CALL_OW 1
23254: ST_TO_ADDR
// end ; if tmp and mech < 6 then
23255: LD_VAR 0 4
23259: PUSH
23260: LD_VAR 0 7
23264: PUSH
23265: LD_INT 6
23267: LESS
23268: AND
23269: IFFALSE 23457
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
23271: LD_ADDR_VAR 0 9
23275: PUSH
23276: LD_VAR 0 4
23280: PUSH
23281: LD_VAR 0 8
23285: PUSH
23286: LD_VAR 0 7
23290: UNION
23291: DIFF
23292: PPUSH
23293: LD_INT 3
23295: PPUSH
23296: CALL 87946 0 2
23300: ST_TO_ADDR
// p := [ ] ;
23301: LD_ADDR_VAR 0 11
23305: PUSH
23306: EMPTY
23307: ST_TO_ADDR
// if sort then
23308: LD_VAR 0 9
23312: IFFALSE 23428
// for i = 1 to 6 - mech do
23314: LD_ADDR_VAR 0 3
23318: PUSH
23319: DOUBLE
23320: LD_INT 1
23322: DEC
23323: ST_TO_ADDR
23324: LD_INT 6
23326: PUSH
23327: LD_VAR 0 7
23331: MINUS
23332: PUSH
23333: FOR_TO
23334: IFFALSE 23426
// begin if i = sort then
23336: LD_VAR 0 3
23340: PUSH
23341: LD_VAR 0 9
23345: EQUAL
23346: IFFALSE 23350
// break ;
23348: GO 23426
// if GetClass ( i ) = 3 then
23350: LD_VAR 0 3
23354: PPUSH
23355: CALL_OW 257
23359: PUSH
23360: LD_INT 3
23362: EQUAL
23363: IFFALSE 23367
// continue ;
23365: GO 23333
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23367: LD_ADDR_VAR 0 11
23371: PUSH
23372: LD_VAR 0 11
23376: PPUSH
23377: LD_VAR 0 11
23381: PUSH
23382: LD_INT 1
23384: PLUS
23385: PPUSH
23386: LD_VAR 0 9
23390: PUSH
23391: LD_VAR 0 3
23395: ARRAY
23396: PPUSH
23397: CALL_OW 2
23401: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23402: LD_ADDR_VAR 0 4
23406: PUSH
23407: LD_VAR 0 4
23411: PUSH
23412: LD_VAR 0 9
23416: PUSH
23417: LD_VAR 0 3
23421: ARRAY
23422: DIFF
23423: ST_TO_ADDR
// end ;
23424: GO 23333
23426: POP
23427: POP
// if p then
23428: LD_VAR 0 11
23432: IFFALSE 23457
// result := Replace ( result , 3 , p ) ;
23434: LD_ADDR_VAR 0 2
23438: PUSH
23439: LD_VAR 0 2
23443: PPUSH
23444: LD_INT 3
23446: PPUSH
23447: LD_VAR 0 11
23451: PPUSH
23452: CALL_OW 1
23456: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
23457: LD_VAR 0 4
23461: PUSH
23462: LD_INT 6
23464: GREATER
23465: PUSH
23466: LD_VAR 0 6
23470: PUSH
23471: LD_INT 6
23473: LESS
23474: AND
23475: IFFALSE 23669
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
23477: LD_ADDR_VAR 0 9
23481: PUSH
23482: LD_VAR 0 4
23486: PUSH
23487: LD_VAR 0 8
23491: PUSH
23492: LD_VAR 0 7
23496: UNION
23497: PUSH
23498: LD_VAR 0 6
23502: UNION
23503: DIFF
23504: PPUSH
23505: LD_INT 2
23507: PPUSH
23508: CALL 87946 0 2
23512: ST_TO_ADDR
// p := [ ] ;
23513: LD_ADDR_VAR 0 11
23517: PUSH
23518: EMPTY
23519: ST_TO_ADDR
// if sort then
23520: LD_VAR 0 9
23524: IFFALSE 23640
// for i = 1 to 6 - eng do
23526: LD_ADDR_VAR 0 3
23530: PUSH
23531: DOUBLE
23532: LD_INT 1
23534: DEC
23535: ST_TO_ADDR
23536: LD_INT 6
23538: PUSH
23539: LD_VAR 0 6
23543: MINUS
23544: PUSH
23545: FOR_TO
23546: IFFALSE 23638
// begin if i = sort then
23548: LD_VAR 0 3
23552: PUSH
23553: LD_VAR 0 9
23557: EQUAL
23558: IFFALSE 23562
// break ;
23560: GO 23638
// if GetClass ( i ) = 2 then
23562: LD_VAR 0 3
23566: PPUSH
23567: CALL_OW 257
23571: PUSH
23572: LD_INT 2
23574: EQUAL
23575: IFFALSE 23579
// continue ;
23577: GO 23545
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23579: LD_ADDR_VAR 0 11
23583: PUSH
23584: LD_VAR 0 11
23588: PPUSH
23589: LD_VAR 0 11
23593: PUSH
23594: LD_INT 1
23596: PLUS
23597: PPUSH
23598: LD_VAR 0 9
23602: PUSH
23603: LD_VAR 0 3
23607: ARRAY
23608: PPUSH
23609: CALL_OW 2
23613: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23614: LD_ADDR_VAR 0 4
23618: PUSH
23619: LD_VAR 0 4
23623: PUSH
23624: LD_VAR 0 9
23628: PUSH
23629: LD_VAR 0 3
23633: ARRAY
23634: DIFF
23635: ST_TO_ADDR
// end ;
23636: GO 23545
23638: POP
23639: POP
// if p then
23640: LD_VAR 0 11
23644: IFFALSE 23669
// result := Replace ( result , 2 , p ) ;
23646: LD_ADDR_VAR 0 2
23650: PUSH
23651: LD_VAR 0 2
23655: PPUSH
23656: LD_INT 2
23658: PPUSH
23659: LD_VAR 0 11
23663: PPUSH
23664: CALL_OW 1
23668: ST_TO_ADDR
// end ; exit ;
23669: GO 25057
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
23671: LD_EXP 76
23675: PUSH
23676: LD_EXP 75
23680: PUSH
23681: LD_VAR 0 1
23685: ARRAY
23686: ARRAY
23687: NOT
23688: PUSH
23689: LD_EXP 49
23693: PUSH
23694: LD_VAR 0 1
23698: ARRAY
23699: PPUSH
23700: LD_INT 30
23702: PUSH
23703: LD_INT 3
23705: PUSH
23706: EMPTY
23707: LIST
23708: LIST
23709: PPUSH
23710: CALL_OW 72
23714: AND
23715: PUSH
23716: LD_EXP 54
23720: PUSH
23721: LD_VAR 0 1
23725: ARRAY
23726: AND
23727: IFFALSE 24335
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
23729: LD_ADDR_EXP 91
23733: PUSH
23734: LD_EXP 91
23738: PPUSH
23739: LD_VAR 0 1
23743: PPUSH
23744: LD_INT 5
23746: PPUSH
23747: CALL_OW 1
23751: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23752: LD_ADDR_VAR 0 2
23756: PUSH
23757: LD_INT 0
23759: PUSH
23760: LD_INT 0
23762: PUSH
23763: LD_INT 0
23765: PUSH
23766: LD_INT 0
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: LIST
23773: LIST
23774: ST_TO_ADDR
// if sci > 1 then
23775: LD_VAR 0 8
23779: PUSH
23780: LD_INT 1
23782: GREATER
23783: IFFALSE 23811
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
23785: LD_ADDR_VAR 0 4
23789: PUSH
23790: LD_VAR 0 4
23794: PUSH
23795: LD_VAR 0 8
23799: PUSH
23800: LD_VAR 0 8
23804: PUSH
23805: LD_INT 1
23807: ARRAY
23808: DIFF
23809: DIFF
23810: ST_TO_ADDR
// if tmp and not sci then
23811: LD_VAR 0 4
23815: PUSH
23816: LD_VAR 0 8
23820: NOT
23821: AND
23822: IFFALSE 23891
// begin sort := SortBySkill ( tmp , 4 ) ;
23824: LD_ADDR_VAR 0 9
23828: PUSH
23829: LD_VAR 0 4
23833: PPUSH
23834: LD_INT 4
23836: PPUSH
23837: CALL 87946 0 2
23841: ST_TO_ADDR
// if sort then
23842: LD_VAR 0 9
23846: IFFALSE 23862
// p := sort [ 1 ] ;
23848: LD_ADDR_VAR 0 11
23852: PUSH
23853: LD_VAR 0 9
23857: PUSH
23858: LD_INT 1
23860: ARRAY
23861: ST_TO_ADDR
// if p then
23862: LD_VAR 0 11
23866: IFFALSE 23891
// result := Replace ( result , 4 , p ) ;
23868: LD_ADDR_VAR 0 2
23872: PUSH
23873: LD_VAR 0 2
23877: PPUSH
23878: LD_INT 4
23880: PPUSH
23881: LD_VAR 0 11
23885: PPUSH
23886: CALL_OW 1
23890: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
23891: LD_ADDR_VAR 0 4
23895: PUSH
23896: LD_VAR 0 4
23900: PUSH
23901: LD_VAR 0 7
23905: DIFF
23906: ST_TO_ADDR
// if tmp and mech < 6 then
23907: LD_VAR 0 4
23911: PUSH
23912: LD_VAR 0 7
23916: PUSH
23917: LD_INT 6
23919: LESS
23920: AND
23921: IFFALSE 24109
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
23923: LD_ADDR_VAR 0 9
23927: PUSH
23928: LD_VAR 0 4
23932: PUSH
23933: LD_VAR 0 8
23937: PUSH
23938: LD_VAR 0 7
23942: UNION
23943: DIFF
23944: PPUSH
23945: LD_INT 3
23947: PPUSH
23948: CALL 87946 0 2
23952: ST_TO_ADDR
// p := [ ] ;
23953: LD_ADDR_VAR 0 11
23957: PUSH
23958: EMPTY
23959: ST_TO_ADDR
// if sort then
23960: LD_VAR 0 9
23964: IFFALSE 24080
// for i = 1 to 6 - mech do
23966: LD_ADDR_VAR 0 3
23970: PUSH
23971: DOUBLE
23972: LD_INT 1
23974: DEC
23975: ST_TO_ADDR
23976: LD_INT 6
23978: PUSH
23979: LD_VAR 0 7
23983: MINUS
23984: PUSH
23985: FOR_TO
23986: IFFALSE 24078
// begin if i = sort then
23988: LD_VAR 0 3
23992: PUSH
23993: LD_VAR 0 9
23997: EQUAL
23998: IFFALSE 24002
// break ;
24000: GO 24078
// if GetClass ( i ) = 3 then
24002: LD_VAR 0 3
24006: PPUSH
24007: CALL_OW 257
24011: PUSH
24012: LD_INT 3
24014: EQUAL
24015: IFFALSE 24019
// continue ;
24017: GO 23985
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24019: LD_ADDR_VAR 0 11
24023: PUSH
24024: LD_VAR 0 11
24028: PPUSH
24029: LD_VAR 0 11
24033: PUSH
24034: LD_INT 1
24036: PLUS
24037: PPUSH
24038: LD_VAR 0 9
24042: PUSH
24043: LD_VAR 0 3
24047: ARRAY
24048: PPUSH
24049: CALL_OW 2
24053: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24054: LD_ADDR_VAR 0 4
24058: PUSH
24059: LD_VAR 0 4
24063: PUSH
24064: LD_VAR 0 9
24068: PUSH
24069: LD_VAR 0 3
24073: ARRAY
24074: DIFF
24075: ST_TO_ADDR
// end ;
24076: GO 23985
24078: POP
24079: POP
// if p then
24080: LD_VAR 0 11
24084: IFFALSE 24109
// result := Replace ( result , 3 , p ) ;
24086: LD_ADDR_VAR 0 2
24090: PUSH
24091: LD_VAR 0 2
24095: PPUSH
24096: LD_INT 3
24098: PPUSH
24099: LD_VAR 0 11
24103: PPUSH
24104: CALL_OW 1
24108: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
24109: LD_ADDR_VAR 0 4
24113: PUSH
24114: LD_VAR 0 4
24118: PUSH
24119: LD_VAR 0 6
24123: DIFF
24124: ST_TO_ADDR
// if tmp and eng < 6 then
24125: LD_VAR 0 4
24129: PUSH
24130: LD_VAR 0 6
24134: PUSH
24135: LD_INT 6
24137: LESS
24138: AND
24139: IFFALSE 24333
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24141: LD_ADDR_VAR 0 9
24145: PUSH
24146: LD_VAR 0 4
24150: PUSH
24151: LD_VAR 0 8
24155: PUSH
24156: LD_VAR 0 7
24160: UNION
24161: PUSH
24162: LD_VAR 0 6
24166: UNION
24167: DIFF
24168: PPUSH
24169: LD_INT 2
24171: PPUSH
24172: CALL 87946 0 2
24176: ST_TO_ADDR
// p := [ ] ;
24177: LD_ADDR_VAR 0 11
24181: PUSH
24182: EMPTY
24183: ST_TO_ADDR
// if sort then
24184: LD_VAR 0 9
24188: IFFALSE 24304
// for i = 1 to 6 - eng do
24190: LD_ADDR_VAR 0 3
24194: PUSH
24195: DOUBLE
24196: LD_INT 1
24198: DEC
24199: ST_TO_ADDR
24200: LD_INT 6
24202: PUSH
24203: LD_VAR 0 6
24207: MINUS
24208: PUSH
24209: FOR_TO
24210: IFFALSE 24302
// begin if i = sort then
24212: LD_VAR 0 3
24216: PUSH
24217: LD_VAR 0 9
24221: EQUAL
24222: IFFALSE 24226
// break ;
24224: GO 24302
// if GetClass ( i ) = 2 then
24226: LD_VAR 0 3
24230: PPUSH
24231: CALL_OW 257
24235: PUSH
24236: LD_INT 2
24238: EQUAL
24239: IFFALSE 24243
// continue ;
24241: GO 24209
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24243: LD_ADDR_VAR 0 11
24247: PUSH
24248: LD_VAR 0 11
24252: PPUSH
24253: LD_VAR 0 11
24257: PUSH
24258: LD_INT 1
24260: PLUS
24261: PPUSH
24262: LD_VAR 0 9
24266: PUSH
24267: LD_VAR 0 3
24271: ARRAY
24272: PPUSH
24273: CALL_OW 2
24277: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24278: LD_ADDR_VAR 0 4
24282: PUSH
24283: LD_VAR 0 4
24287: PUSH
24288: LD_VAR 0 9
24292: PUSH
24293: LD_VAR 0 3
24297: ARRAY
24298: DIFF
24299: ST_TO_ADDR
// end ;
24300: GO 24209
24302: POP
24303: POP
// if p then
24304: LD_VAR 0 11
24308: IFFALSE 24333
// result := Replace ( result , 2 , p ) ;
24310: LD_ADDR_VAR 0 2
24314: PUSH
24315: LD_VAR 0 2
24319: PPUSH
24320: LD_INT 2
24322: PPUSH
24323: LD_VAR 0 11
24327: PPUSH
24328: CALL_OW 1
24332: ST_TO_ADDR
// end ; exit ;
24333: GO 25057
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
24335: LD_EXP 76
24339: PUSH
24340: LD_EXP 75
24344: PUSH
24345: LD_VAR 0 1
24349: ARRAY
24350: ARRAY
24351: NOT
24352: PUSH
24353: LD_EXP 49
24357: PUSH
24358: LD_VAR 0 1
24362: ARRAY
24363: PPUSH
24364: LD_INT 30
24366: PUSH
24367: LD_INT 3
24369: PUSH
24370: EMPTY
24371: LIST
24372: LIST
24373: PPUSH
24374: CALL_OW 72
24378: AND
24379: PUSH
24380: LD_EXP 54
24384: PUSH
24385: LD_VAR 0 1
24389: ARRAY
24390: NOT
24391: AND
24392: IFFALSE 25057
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
24394: LD_ADDR_EXP 91
24398: PUSH
24399: LD_EXP 91
24403: PPUSH
24404: LD_VAR 0 1
24408: PPUSH
24409: LD_INT 6
24411: PPUSH
24412: CALL_OW 1
24416: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24417: LD_ADDR_VAR 0 2
24421: PUSH
24422: LD_INT 0
24424: PUSH
24425: LD_INT 0
24427: PUSH
24428: LD_INT 0
24430: PUSH
24431: LD_INT 0
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: LIST
24438: LIST
24439: ST_TO_ADDR
// if sci >= 1 then
24440: LD_VAR 0 8
24444: PUSH
24445: LD_INT 1
24447: GREATEREQUAL
24448: IFFALSE 24470
// tmp := tmp diff sci [ 1 ] ;
24450: LD_ADDR_VAR 0 4
24454: PUSH
24455: LD_VAR 0 4
24459: PUSH
24460: LD_VAR 0 8
24464: PUSH
24465: LD_INT 1
24467: ARRAY
24468: DIFF
24469: ST_TO_ADDR
// if tmp and not sci then
24470: LD_VAR 0 4
24474: PUSH
24475: LD_VAR 0 8
24479: NOT
24480: AND
24481: IFFALSE 24550
// begin sort := SortBySkill ( tmp , 4 ) ;
24483: LD_ADDR_VAR 0 9
24487: PUSH
24488: LD_VAR 0 4
24492: PPUSH
24493: LD_INT 4
24495: PPUSH
24496: CALL 87946 0 2
24500: ST_TO_ADDR
// if sort then
24501: LD_VAR 0 9
24505: IFFALSE 24521
// p := sort [ 1 ] ;
24507: LD_ADDR_VAR 0 11
24511: PUSH
24512: LD_VAR 0 9
24516: PUSH
24517: LD_INT 1
24519: ARRAY
24520: ST_TO_ADDR
// if p then
24521: LD_VAR 0 11
24525: IFFALSE 24550
// result := Replace ( result , 4 , p ) ;
24527: LD_ADDR_VAR 0 2
24531: PUSH
24532: LD_VAR 0 2
24536: PPUSH
24537: LD_INT 4
24539: PPUSH
24540: LD_VAR 0 11
24544: PPUSH
24545: CALL_OW 1
24549: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24550: LD_ADDR_VAR 0 4
24554: PUSH
24555: LD_VAR 0 4
24559: PUSH
24560: LD_VAR 0 7
24564: DIFF
24565: ST_TO_ADDR
// if tmp and mech < 6 then
24566: LD_VAR 0 4
24570: PUSH
24571: LD_VAR 0 7
24575: PUSH
24576: LD_INT 6
24578: LESS
24579: AND
24580: IFFALSE 24762
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
24582: LD_ADDR_VAR 0 9
24586: PUSH
24587: LD_VAR 0 4
24591: PUSH
24592: LD_VAR 0 7
24596: DIFF
24597: PPUSH
24598: LD_INT 3
24600: PPUSH
24601: CALL 87946 0 2
24605: ST_TO_ADDR
// p := [ ] ;
24606: LD_ADDR_VAR 0 11
24610: PUSH
24611: EMPTY
24612: ST_TO_ADDR
// if sort then
24613: LD_VAR 0 9
24617: IFFALSE 24733
// for i = 1 to 6 - mech do
24619: LD_ADDR_VAR 0 3
24623: PUSH
24624: DOUBLE
24625: LD_INT 1
24627: DEC
24628: ST_TO_ADDR
24629: LD_INT 6
24631: PUSH
24632: LD_VAR 0 7
24636: MINUS
24637: PUSH
24638: FOR_TO
24639: IFFALSE 24731
// begin if i = sort then
24641: LD_VAR 0 3
24645: PUSH
24646: LD_VAR 0 9
24650: EQUAL
24651: IFFALSE 24655
// break ;
24653: GO 24731
// if GetClass ( i ) = 3 then
24655: LD_VAR 0 3
24659: PPUSH
24660: CALL_OW 257
24664: PUSH
24665: LD_INT 3
24667: EQUAL
24668: IFFALSE 24672
// continue ;
24670: GO 24638
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24672: LD_ADDR_VAR 0 11
24676: PUSH
24677: LD_VAR 0 11
24681: PPUSH
24682: LD_VAR 0 11
24686: PUSH
24687: LD_INT 1
24689: PLUS
24690: PPUSH
24691: LD_VAR 0 9
24695: PUSH
24696: LD_VAR 0 3
24700: ARRAY
24701: PPUSH
24702: CALL_OW 2
24706: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24707: LD_ADDR_VAR 0 4
24711: PUSH
24712: LD_VAR 0 4
24716: PUSH
24717: LD_VAR 0 9
24721: PUSH
24722: LD_VAR 0 3
24726: ARRAY
24727: DIFF
24728: ST_TO_ADDR
// end ;
24729: GO 24638
24731: POP
24732: POP
// if p then
24733: LD_VAR 0 11
24737: IFFALSE 24762
// result := Replace ( result , 3 , p ) ;
24739: LD_ADDR_VAR 0 2
24743: PUSH
24744: LD_VAR 0 2
24748: PPUSH
24749: LD_INT 3
24751: PPUSH
24752: LD_VAR 0 11
24756: PPUSH
24757: CALL_OW 1
24761: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
24762: LD_ADDR_VAR 0 4
24766: PUSH
24767: LD_VAR 0 4
24771: PUSH
24772: LD_VAR 0 6
24776: DIFF
24777: ST_TO_ADDR
// if tmp and eng < 4 then
24778: LD_VAR 0 4
24782: PUSH
24783: LD_VAR 0 6
24787: PUSH
24788: LD_INT 4
24790: LESS
24791: AND
24792: IFFALSE 24982
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
24794: LD_ADDR_VAR 0 9
24798: PUSH
24799: LD_VAR 0 4
24803: PUSH
24804: LD_VAR 0 7
24808: PUSH
24809: LD_VAR 0 6
24813: UNION
24814: DIFF
24815: PPUSH
24816: LD_INT 2
24818: PPUSH
24819: CALL 87946 0 2
24823: ST_TO_ADDR
// p := [ ] ;
24824: LD_ADDR_VAR 0 11
24828: PUSH
24829: EMPTY
24830: ST_TO_ADDR
// if sort then
24831: LD_VAR 0 9
24835: IFFALSE 24951
// for i = 1 to 4 - eng do
24837: LD_ADDR_VAR 0 3
24841: PUSH
24842: DOUBLE
24843: LD_INT 1
24845: DEC
24846: ST_TO_ADDR
24847: LD_INT 4
24849: PUSH
24850: LD_VAR 0 6
24854: MINUS
24855: PUSH
24856: FOR_TO
24857: IFFALSE 24949
// begin if i = sort then
24859: LD_VAR 0 3
24863: PUSH
24864: LD_VAR 0 9
24868: EQUAL
24869: IFFALSE 24873
// break ;
24871: GO 24949
// if GetClass ( i ) = 2 then
24873: LD_VAR 0 3
24877: PPUSH
24878: CALL_OW 257
24882: PUSH
24883: LD_INT 2
24885: EQUAL
24886: IFFALSE 24890
// continue ;
24888: GO 24856
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24890: LD_ADDR_VAR 0 11
24894: PUSH
24895: LD_VAR 0 11
24899: PPUSH
24900: LD_VAR 0 11
24904: PUSH
24905: LD_INT 1
24907: PLUS
24908: PPUSH
24909: LD_VAR 0 9
24913: PUSH
24914: LD_VAR 0 3
24918: ARRAY
24919: PPUSH
24920: CALL_OW 2
24924: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24925: LD_ADDR_VAR 0 4
24929: PUSH
24930: LD_VAR 0 4
24934: PUSH
24935: LD_VAR 0 9
24939: PUSH
24940: LD_VAR 0 3
24944: ARRAY
24945: DIFF
24946: ST_TO_ADDR
// end ;
24947: GO 24856
24949: POP
24950: POP
// if p then
24951: LD_VAR 0 11
24955: IFFALSE 24980
// result := Replace ( result , 2 , p ) ;
24957: LD_ADDR_VAR 0 2
24961: PUSH
24962: LD_VAR 0 2
24966: PPUSH
24967: LD_INT 2
24969: PPUSH
24970: LD_VAR 0 11
24974: PPUSH
24975: CALL_OW 1
24979: ST_TO_ADDR
// end else
24980: GO 25026
// for i = eng downto 5 do
24982: LD_ADDR_VAR 0 3
24986: PUSH
24987: DOUBLE
24988: LD_VAR 0 6
24992: INC
24993: ST_TO_ADDR
24994: LD_INT 5
24996: PUSH
24997: FOR_DOWNTO
24998: IFFALSE 25024
// tmp := tmp union eng [ i ] ;
25000: LD_ADDR_VAR 0 4
25004: PUSH
25005: LD_VAR 0 4
25009: PUSH
25010: LD_VAR 0 6
25014: PUSH
25015: LD_VAR 0 3
25019: ARRAY
25020: UNION
25021: ST_TO_ADDR
25022: GO 24997
25024: POP
25025: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
25026: LD_ADDR_VAR 0 2
25030: PUSH
25031: LD_VAR 0 2
25035: PPUSH
25036: LD_INT 1
25038: PPUSH
25039: LD_VAR 0 4
25043: PUSH
25044: LD_VAR 0 5
25048: DIFF
25049: PPUSH
25050: CALL_OW 1
25054: ST_TO_ADDR
// exit ;
25055: GO 25057
// end ; end ;
25057: LD_VAR 0 2
25061: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
25062: LD_INT 0
25064: PPUSH
25065: PPUSH
25066: PPUSH
// if not mc_bases then
25067: LD_EXP 49
25071: NOT
25072: IFFALSE 25076
// exit ;
25074: GO 25182
// for i = 1 to mc_bases do
25076: LD_ADDR_VAR 0 2
25080: PUSH
25081: DOUBLE
25082: LD_INT 1
25084: DEC
25085: ST_TO_ADDR
25086: LD_EXP 49
25090: PUSH
25091: FOR_TO
25092: IFFALSE 25173
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
25094: LD_ADDR_VAR 0 3
25098: PUSH
25099: LD_EXP 49
25103: PUSH
25104: LD_VAR 0 2
25108: ARRAY
25109: PPUSH
25110: LD_INT 21
25112: PUSH
25113: LD_INT 3
25115: PUSH
25116: EMPTY
25117: LIST
25118: LIST
25119: PUSH
25120: LD_INT 3
25122: PUSH
25123: LD_INT 24
25125: PUSH
25126: LD_INT 1000
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: PUSH
25133: EMPTY
25134: LIST
25135: LIST
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: PPUSH
25141: CALL_OW 72
25145: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
25146: LD_ADDR_EXP 50
25150: PUSH
25151: LD_EXP 50
25155: PPUSH
25156: LD_VAR 0 2
25160: PPUSH
25161: LD_VAR 0 3
25165: PPUSH
25166: CALL_OW 1
25170: ST_TO_ADDR
// end ;
25171: GO 25091
25173: POP
25174: POP
// RaiseSailEvent ( 101 ) ;
25175: LD_INT 101
25177: PPUSH
25178: CALL_OW 427
// end ;
25182: LD_VAR 0 1
25186: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
25187: LD_INT 0
25189: PPUSH
25190: PPUSH
25191: PPUSH
25192: PPUSH
25193: PPUSH
25194: PPUSH
25195: PPUSH
// if not mc_bases then
25196: LD_EXP 49
25200: NOT
25201: IFFALSE 25205
// exit ;
25203: GO 25778
// for i = 1 to mc_bases do
25205: LD_ADDR_VAR 0 2
25209: PUSH
25210: DOUBLE
25211: LD_INT 1
25213: DEC
25214: ST_TO_ADDR
25215: LD_EXP 49
25219: PUSH
25220: FOR_TO
25221: IFFALSE 25769
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
25223: LD_ADDR_VAR 0 5
25227: PUSH
25228: LD_EXP 49
25232: PUSH
25233: LD_VAR 0 2
25237: ARRAY
25238: PUSH
25239: LD_EXP 78
25243: PUSH
25244: LD_VAR 0 2
25248: ARRAY
25249: UNION
25250: PPUSH
25251: LD_INT 21
25253: PUSH
25254: LD_INT 1
25256: PUSH
25257: EMPTY
25258: LIST
25259: LIST
25260: PUSH
25261: LD_INT 1
25263: PUSH
25264: LD_INT 3
25266: PUSH
25267: LD_INT 54
25269: PUSH
25270: EMPTY
25271: LIST
25272: PUSH
25273: EMPTY
25274: LIST
25275: LIST
25276: PUSH
25277: LD_INT 3
25279: PUSH
25280: LD_INT 24
25282: PUSH
25283: LD_INT 800
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: PUSH
25290: EMPTY
25291: LIST
25292: LIST
25293: PUSH
25294: EMPTY
25295: LIST
25296: LIST
25297: LIST
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PPUSH
25303: CALL_OW 72
25307: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
25308: LD_ADDR_VAR 0 6
25312: PUSH
25313: LD_EXP 49
25317: PUSH
25318: LD_VAR 0 2
25322: ARRAY
25323: PPUSH
25324: LD_INT 21
25326: PUSH
25327: LD_INT 1
25329: PUSH
25330: EMPTY
25331: LIST
25332: LIST
25333: PUSH
25334: LD_INT 1
25336: PUSH
25337: LD_INT 3
25339: PUSH
25340: LD_INT 54
25342: PUSH
25343: EMPTY
25344: LIST
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: LD_INT 3
25352: PUSH
25353: LD_INT 24
25355: PUSH
25356: LD_INT 250
25358: PUSH
25359: EMPTY
25360: LIST
25361: LIST
25362: PUSH
25363: EMPTY
25364: LIST
25365: LIST
25366: PUSH
25367: EMPTY
25368: LIST
25369: LIST
25370: LIST
25371: PUSH
25372: EMPTY
25373: LIST
25374: LIST
25375: PPUSH
25376: CALL_OW 72
25380: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
25381: LD_ADDR_VAR 0 7
25385: PUSH
25386: LD_VAR 0 5
25390: PUSH
25391: LD_VAR 0 6
25395: DIFF
25396: ST_TO_ADDR
// if not need_heal_1 then
25397: LD_VAR 0 6
25401: NOT
25402: IFFALSE 25435
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
25404: LD_ADDR_EXP 52
25408: PUSH
25409: LD_EXP 52
25413: PPUSH
25414: LD_VAR 0 2
25418: PUSH
25419: LD_INT 1
25421: PUSH
25422: EMPTY
25423: LIST
25424: LIST
25425: PPUSH
25426: EMPTY
25427: PPUSH
25428: CALL 53698 0 3
25432: ST_TO_ADDR
25433: GO 25505
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
25435: LD_ADDR_EXP 52
25439: PUSH
25440: LD_EXP 52
25444: PPUSH
25445: LD_VAR 0 2
25449: PUSH
25450: LD_INT 1
25452: PUSH
25453: EMPTY
25454: LIST
25455: LIST
25456: PPUSH
25457: LD_EXP 52
25461: PUSH
25462: LD_VAR 0 2
25466: ARRAY
25467: PUSH
25468: LD_INT 1
25470: ARRAY
25471: PPUSH
25472: LD_INT 3
25474: PUSH
25475: LD_INT 24
25477: PUSH
25478: LD_INT 1000
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: PPUSH
25489: CALL_OW 72
25493: PUSH
25494: LD_VAR 0 6
25498: UNION
25499: PPUSH
25500: CALL 53698 0 3
25504: ST_TO_ADDR
// if not need_heal_2 then
25505: LD_VAR 0 7
25509: NOT
25510: IFFALSE 25543
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
25512: LD_ADDR_EXP 52
25516: PUSH
25517: LD_EXP 52
25521: PPUSH
25522: LD_VAR 0 2
25526: PUSH
25527: LD_INT 2
25529: PUSH
25530: EMPTY
25531: LIST
25532: LIST
25533: PPUSH
25534: EMPTY
25535: PPUSH
25536: CALL 53698 0 3
25540: ST_TO_ADDR
25541: GO 25575
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
25543: LD_ADDR_EXP 52
25547: PUSH
25548: LD_EXP 52
25552: PPUSH
25553: LD_VAR 0 2
25557: PUSH
25558: LD_INT 2
25560: PUSH
25561: EMPTY
25562: LIST
25563: LIST
25564: PPUSH
25565: LD_VAR 0 7
25569: PPUSH
25570: CALL 53698 0 3
25574: ST_TO_ADDR
// if need_heal_2 then
25575: LD_VAR 0 7
25579: IFFALSE 25751
// for j in need_heal_2 do
25581: LD_ADDR_VAR 0 3
25585: PUSH
25586: LD_VAR 0 7
25590: PUSH
25591: FOR_IN
25592: IFFALSE 25749
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
25594: LD_ADDR_VAR 0 5
25598: PUSH
25599: LD_EXP 49
25603: PUSH
25604: LD_VAR 0 2
25608: ARRAY
25609: PPUSH
25610: LD_INT 2
25612: PUSH
25613: LD_INT 30
25615: PUSH
25616: LD_INT 6
25618: PUSH
25619: EMPTY
25620: LIST
25621: LIST
25622: PUSH
25623: LD_INT 30
25625: PUSH
25626: LD_INT 7
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: LD_INT 30
25635: PUSH
25636: LD_INT 8
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: LD_INT 30
25645: PUSH
25646: LD_INT 0
25648: PUSH
25649: EMPTY
25650: LIST
25651: LIST
25652: PUSH
25653: LD_INT 30
25655: PUSH
25656: LD_INT 1
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: PUSH
25663: LD_INT 25
25665: PUSH
25666: LD_INT 4
25668: PUSH
25669: EMPTY
25670: LIST
25671: LIST
25672: PUSH
25673: EMPTY
25674: LIST
25675: LIST
25676: LIST
25677: LIST
25678: LIST
25679: LIST
25680: LIST
25681: PPUSH
25682: CALL_OW 72
25686: ST_TO_ADDR
// if tmp then
25687: LD_VAR 0 5
25691: IFFALSE 25747
// begin k := NearestUnitToUnit ( tmp , j ) ;
25693: LD_ADDR_VAR 0 4
25697: PUSH
25698: LD_VAR 0 5
25702: PPUSH
25703: LD_VAR 0 3
25707: PPUSH
25708: CALL_OW 74
25712: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
25713: LD_VAR 0 3
25717: PPUSH
25718: LD_VAR 0 4
25722: PPUSH
25723: CALL_OW 296
25727: PUSH
25728: LD_INT 7
25730: GREATER
25731: IFFALSE 25747
// ComMoveUnit ( j , k ) ;
25733: LD_VAR 0 3
25737: PPUSH
25738: LD_VAR 0 4
25742: PPUSH
25743: CALL_OW 112
// end ; end ;
25747: GO 25591
25749: POP
25750: POP
// if not need_heal_1 and not need_heal_2 then
25751: LD_VAR 0 6
25755: NOT
25756: PUSH
25757: LD_VAR 0 7
25761: NOT
25762: AND
25763: IFFALSE 25767
// continue ;
25765: GO 25220
// end ;
25767: GO 25220
25769: POP
25770: POP
// RaiseSailEvent ( 102 ) ;
25771: LD_INT 102
25773: PPUSH
25774: CALL_OW 427
// end ;
25778: LD_VAR 0 1
25782: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
25783: LD_INT 0
25785: PPUSH
25786: PPUSH
25787: PPUSH
25788: PPUSH
25789: PPUSH
25790: PPUSH
// if not mc_bases then
25791: LD_EXP 49
25795: NOT
25796: IFFALSE 25800
// exit ;
25798: GO 26510
// for i = 1 to mc_bases do
25800: LD_ADDR_VAR 0 2
25804: PUSH
25805: DOUBLE
25806: LD_INT 1
25808: DEC
25809: ST_TO_ADDR
25810: LD_EXP 49
25814: PUSH
25815: FOR_TO
25816: IFFALSE 26508
// begin if not mc_building_need_repair [ i ] then
25818: LD_EXP 50
25822: PUSH
25823: LD_VAR 0 2
25827: ARRAY
25828: NOT
25829: IFFALSE 26003
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
25831: LD_ADDR_VAR 0 6
25835: PUSH
25836: LD_EXP 68
25840: PUSH
25841: LD_VAR 0 2
25845: ARRAY
25846: PPUSH
25847: LD_INT 3
25849: PUSH
25850: LD_INT 24
25852: PUSH
25853: LD_INT 1000
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: PUSH
25864: LD_INT 2
25866: PUSH
25867: LD_INT 34
25869: PUSH
25870: LD_INT 13
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: PUSH
25877: LD_INT 34
25879: PUSH
25880: LD_INT 52
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: PUSH
25887: EMPTY
25888: LIST
25889: LIST
25890: LIST
25891: PUSH
25892: EMPTY
25893: LIST
25894: LIST
25895: PPUSH
25896: CALL_OW 72
25900: ST_TO_ADDR
// if cranes then
25901: LD_VAR 0 6
25905: IFFALSE 25967
// for j in cranes do
25907: LD_ADDR_VAR 0 3
25911: PUSH
25912: LD_VAR 0 6
25916: PUSH
25917: FOR_IN
25918: IFFALSE 25965
// if not IsInArea ( j , mc_parking [ i ] ) then
25920: LD_VAR 0 3
25924: PPUSH
25925: LD_EXP 73
25929: PUSH
25930: LD_VAR 0 2
25934: ARRAY
25935: PPUSH
25936: CALL_OW 308
25940: NOT
25941: IFFALSE 25963
// ComMoveToArea ( j , mc_parking [ i ] ) ;
25943: LD_VAR 0 3
25947: PPUSH
25948: LD_EXP 73
25952: PUSH
25953: LD_VAR 0 2
25957: ARRAY
25958: PPUSH
25959: CALL_OW 113
25963: GO 25917
25965: POP
25966: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
25967: LD_ADDR_EXP 51
25971: PUSH
25972: LD_EXP 51
25976: PPUSH
25977: LD_VAR 0 2
25981: PPUSH
25982: EMPTY
25983: PPUSH
25984: CALL_OW 1
25988: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
25989: LD_VAR 0 2
25993: PPUSH
25994: LD_INT 101
25996: PPUSH
25997: CALL 20895 0 2
// continue ;
26001: GO 25815
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
26003: LD_ADDR_EXP 55
26007: PUSH
26008: LD_EXP 55
26012: PPUSH
26013: LD_VAR 0 2
26017: PPUSH
26018: EMPTY
26019: PPUSH
26020: CALL_OW 1
26024: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
26025: LD_VAR 0 2
26029: PPUSH
26030: LD_INT 103
26032: PPUSH
26033: CALL 20895 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
26037: LD_ADDR_VAR 0 5
26041: PUSH
26042: LD_EXP 49
26046: PUSH
26047: LD_VAR 0 2
26051: ARRAY
26052: PUSH
26053: LD_EXP 78
26057: PUSH
26058: LD_VAR 0 2
26062: ARRAY
26063: UNION
26064: PPUSH
26065: LD_INT 2
26067: PUSH
26068: LD_INT 25
26070: PUSH
26071: LD_INT 2
26073: PUSH
26074: EMPTY
26075: LIST
26076: LIST
26077: PUSH
26078: LD_INT 25
26080: PUSH
26081: LD_INT 16
26083: PUSH
26084: EMPTY
26085: LIST
26086: LIST
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: LIST
26092: PUSH
26093: EMPTY
26094: LIST
26095: PPUSH
26096: CALL_OW 72
26100: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
26101: LD_ADDR_VAR 0 6
26105: PUSH
26106: LD_EXP 68
26110: PUSH
26111: LD_VAR 0 2
26115: ARRAY
26116: PPUSH
26117: LD_INT 2
26119: PUSH
26120: LD_INT 34
26122: PUSH
26123: LD_INT 13
26125: PUSH
26126: EMPTY
26127: LIST
26128: LIST
26129: PUSH
26130: LD_INT 34
26132: PUSH
26133: LD_INT 52
26135: PUSH
26136: EMPTY
26137: LIST
26138: LIST
26139: PUSH
26140: EMPTY
26141: LIST
26142: LIST
26143: LIST
26144: PPUSH
26145: CALL_OW 72
26149: ST_TO_ADDR
// if cranes then
26150: LD_VAR 0 6
26154: IFFALSE 26290
// begin for j in cranes do
26156: LD_ADDR_VAR 0 3
26160: PUSH
26161: LD_VAR 0 6
26165: PUSH
26166: FOR_IN
26167: IFFALSE 26288
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
26169: LD_VAR 0 3
26173: PPUSH
26174: CALL_OW 256
26178: PUSH
26179: LD_INT 500
26181: GREATEREQUAL
26182: PUSH
26183: LD_VAR 0 3
26187: PPUSH
26188: CALL_OW 314
26192: NOT
26193: AND
26194: IFFALSE 26228
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
26196: LD_VAR 0 3
26200: PPUSH
26201: LD_EXP 50
26205: PUSH
26206: LD_VAR 0 2
26210: ARRAY
26211: PPUSH
26212: LD_VAR 0 3
26216: PPUSH
26217: CALL_OW 74
26221: PPUSH
26222: CALL_OW 130
26226: GO 26286
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
26228: LD_VAR 0 3
26232: PPUSH
26233: CALL_OW 256
26237: PUSH
26238: LD_INT 500
26240: LESS
26241: PUSH
26242: LD_VAR 0 3
26246: PPUSH
26247: LD_EXP 73
26251: PUSH
26252: LD_VAR 0 2
26256: ARRAY
26257: PPUSH
26258: CALL_OW 308
26262: NOT
26263: AND
26264: IFFALSE 26286
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26266: LD_VAR 0 3
26270: PPUSH
26271: LD_EXP 73
26275: PUSH
26276: LD_VAR 0 2
26280: ARRAY
26281: PPUSH
26282: CALL_OW 113
26286: GO 26166
26288: POP
26289: POP
// end ; if not tmp then
26290: LD_VAR 0 5
26294: NOT
26295: IFFALSE 26299
// continue ;
26297: GO 25815
// for j in tmp do
26299: LD_ADDR_VAR 0 3
26303: PUSH
26304: LD_VAR 0 5
26308: PUSH
26309: FOR_IN
26310: IFFALSE 26504
// begin if mc_need_heal [ i ] then
26312: LD_EXP 52
26316: PUSH
26317: LD_VAR 0 2
26321: ARRAY
26322: IFFALSE 26370
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
26324: LD_VAR 0 3
26328: PUSH
26329: LD_EXP 52
26333: PUSH
26334: LD_VAR 0 2
26338: ARRAY
26339: PUSH
26340: LD_INT 1
26342: ARRAY
26343: IN
26344: PUSH
26345: LD_VAR 0 3
26349: PUSH
26350: LD_EXP 52
26354: PUSH
26355: LD_VAR 0 2
26359: ARRAY
26360: PUSH
26361: LD_INT 2
26363: ARRAY
26364: IN
26365: OR
26366: IFFALSE 26370
// continue ;
26368: GO 26309
// if IsInUnit ( j ) then
26370: LD_VAR 0 3
26374: PPUSH
26375: CALL_OW 310
26379: IFFALSE 26390
// ComExitBuilding ( j ) ;
26381: LD_VAR 0 3
26385: PPUSH
26386: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
26390: LD_VAR 0 3
26394: PUSH
26395: LD_EXP 51
26399: PUSH
26400: LD_VAR 0 2
26404: ARRAY
26405: IN
26406: NOT
26407: IFFALSE 26465
// begin SetTag ( j , 101 ) ;
26409: LD_VAR 0 3
26413: PPUSH
26414: LD_INT 101
26416: PPUSH
26417: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
26421: LD_ADDR_EXP 51
26425: PUSH
26426: LD_EXP 51
26430: PPUSH
26431: LD_VAR 0 2
26435: PUSH
26436: LD_EXP 51
26440: PUSH
26441: LD_VAR 0 2
26445: ARRAY
26446: PUSH
26447: LD_INT 1
26449: PLUS
26450: PUSH
26451: EMPTY
26452: LIST
26453: LIST
26454: PPUSH
26455: LD_VAR 0 3
26459: PPUSH
26460: CALL 53698 0 3
26464: ST_TO_ADDR
// end ; wait ( 1 ) ;
26465: LD_INT 1
26467: PPUSH
26468: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
26472: LD_VAR 0 3
26476: PPUSH
26477: LD_EXP 50
26481: PUSH
26482: LD_VAR 0 2
26486: ARRAY
26487: PPUSH
26488: LD_VAR 0 3
26492: PPUSH
26493: CALL_OW 74
26497: PPUSH
26498: CALL_OW 130
// end ;
26502: GO 26309
26504: POP
26505: POP
// end ;
26506: GO 25815
26508: POP
26509: POP
// end ;
26510: LD_VAR 0 1
26514: RET
// export function MC_Heal ; var i , j , tmp ; begin
26515: LD_INT 0
26517: PPUSH
26518: PPUSH
26519: PPUSH
26520: PPUSH
// if not mc_bases then
26521: LD_EXP 49
26525: NOT
26526: IFFALSE 26530
// exit ;
26528: GO 26932
// for i = 1 to mc_bases do
26530: LD_ADDR_VAR 0 2
26534: PUSH
26535: DOUBLE
26536: LD_INT 1
26538: DEC
26539: ST_TO_ADDR
26540: LD_EXP 49
26544: PUSH
26545: FOR_TO
26546: IFFALSE 26930
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
26548: LD_EXP 52
26552: PUSH
26553: LD_VAR 0 2
26557: ARRAY
26558: PUSH
26559: LD_INT 1
26561: ARRAY
26562: NOT
26563: PUSH
26564: LD_EXP 52
26568: PUSH
26569: LD_VAR 0 2
26573: ARRAY
26574: PUSH
26575: LD_INT 2
26577: ARRAY
26578: NOT
26579: AND
26580: IFFALSE 26618
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
26582: LD_ADDR_EXP 53
26586: PUSH
26587: LD_EXP 53
26591: PPUSH
26592: LD_VAR 0 2
26596: PPUSH
26597: EMPTY
26598: PPUSH
26599: CALL_OW 1
26603: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
26604: LD_VAR 0 2
26608: PPUSH
26609: LD_INT 102
26611: PPUSH
26612: CALL 20895 0 2
// continue ;
26616: GO 26545
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
26618: LD_ADDR_VAR 0 4
26622: PUSH
26623: LD_EXP 49
26627: PUSH
26628: LD_VAR 0 2
26632: ARRAY
26633: PPUSH
26634: LD_INT 25
26636: PUSH
26637: LD_INT 4
26639: PUSH
26640: EMPTY
26641: LIST
26642: LIST
26643: PPUSH
26644: CALL_OW 72
26648: ST_TO_ADDR
// if not tmp then
26649: LD_VAR 0 4
26653: NOT
26654: IFFALSE 26658
// continue ;
26656: GO 26545
// if mc_taming [ i ] then
26658: LD_EXP 80
26662: PUSH
26663: LD_VAR 0 2
26667: ARRAY
26668: IFFALSE 26692
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
26670: LD_ADDR_EXP 80
26674: PUSH
26675: LD_EXP 80
26679: PPUSH
26680: LD_VAR 0 2
26684: PPUSH
26685: EMPTY
26686: PPUSH
26687: CALL_OW 1
26691: ST_TO_ADDR
// for j in tmp do
26692: LD_ADDR_VAR 0 3
26696: PUSH
26697: LD_VAR 0 4
26701: PUSH
26702: FOR_IN
26703: IFFALSE 26926
// begin if IsInUnit ( j ) then
26705: LD_VAR 0 3
26709: PPUSH
26710: CALL_OW 310
26714: IFFALSE 26725
// ComExitBuilding ( j ) ;
26716: LD_VAR 0 3
26720: PPUSH
26721: CALL_OW 122
// if not j in mc_healers [ i ] then
26725: LD_VAR 0 3
26729: PUSH
26730: LD_EXP 53
26734: PUSH
26735: LD_VAR 0 2
26739: ARRAY
26740: IN
26741: NOT
26742: IFFALSE 26788
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
26744: LD_ADDR_EXP 53
26748: PUSH
26749: LD_EXP 53
26753: PPUSH
26754: LD_VAR 0 2
26758: PUSH
26759: LD_EXP 53
26763: PUSH
26764: LD_VAR 0 2
26768: ARRAY
26769: PUSH
26770: LD_INT 1
26772: PLUS
26773: PUSH
26774: EMPTY
26775: LIST
26776: LIST
26777: PPUSH
26778: LD_VAR 0 3
26782: PPUSH
26783: CALL 53698 0 3
26787: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
26788: LD_VAR 0 3
26792: PPUSH
26793: CALL_OW 110
26797: PUSH
26798: LD_INT 102
26800: NONEQUAL
26801: IFFALSE 26815
// SetTag ( j , 102 ) ;
26803: LD_VAR 0 3
26807: PPUSH
26808: LD_INT 102
26810: PPUSH
26811: CALL_OW 109
// Wait ( 3 ) ;
26815: LD_INT 3
26817: PPUSH
26818: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
26822: LD_EXP 52
26826: PUSH
26827: LD_VAR 0 2
26831: ARRAY
26832: PUSH
26833: LD_INT 1
26835: ARRAY
26836: IFFALSE 26868
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
26838: LD_VAR 0 3
26842: PPUSH
26843: LD_EXP 52
26847: PUSH
26848: LD_VAR 0 2
26852: ARRAY
26853: PUSH
26854: LD_INT 1
26856: ARRAY
26857: PUSH
26858: LD_INT 1
26860: ARRAY
26861: PPUSH
26862: CALL_OW 128
26866: GO 26924
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
26868: LD_VAR 0 3
26872: PPUSH
26873: CALL_OW 314
26877: NOT
26878: PUSH
26879: LD_EXP 52
26883: PUSH
26884: LD_VAR 0 2
26888: ARRAY
26889: PUSH
26890: LD_INT 2
26892: ARRAY
26893: AND
26894: IFFALSE 26924
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
26896: LD_VAR 0 3
26900: PPUSH
26901: LD_EXP 52
26905: PUSH
26906: LD_VAR 0 2
26910: ARRAY
26911: PUSH
26912: LD_INT 2
26914: ARRAY
26915: PUSH
26916: LD_INT 1
26918: ARRAY
26919: PPUSH
26920: CALL_OW 128
// end ;
26924: GO 26702
26926: POP
26927: POP
// end ;
26928: GO 26545
26930: POP
26931: POP
// end ;
26932: LD_VAR 0 1
26936: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
26937: LD_INT 0
26939: PPUSH
26940: PPUSH
26941: PPUSH
26942: PPUSH
26943: PPUSH
// if not mc_bases then
26944: LD_EXP 49
26948: NOT
26949: IFFALSE 26953
// exit ;
26951: GO 28096
// for i = 1 to mc_bases do
26953: LD_ADDR_VAR 0 2
26957: PUSH
26958: DOUBLE
26959: LD_INT 1
26961: DEC
26962: ST_TO_ADDR
26963: LD_EXP 49
26967: PUSH
26968: FOR_TO
26969: IFFALSE 28094
// begin if mc_scan [ i ] then
26971: LD_EXP 72
26975: PUSH
26976: LD_VAR 0 2
26980: ARRAY
26981: IFFALSE 26985
// continue ;
26983: GO 26968
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
26985: LD_EXP 54
26989: PUSH
26990: LD_VAR 0 2
26994: ARRAY
26995: NOT
26996: PUSH
26997: LD_EXP 56
27001: PUSH
27002: LD_VAR 0 2
27006: ARRAY
27007: NOT
27008: AND
27009: PUSH
27010: LD_EXP 55
27014: PUSH
27015: LD_VAR 0 2
27019: ARRAY
27020: AND
27021: IFFALSE 27059
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
27023: LD_ADDR_EXP 55
27027: PUSH
27028: LD_EXP 55
27032: PPUSH
27033: LD_VAR 0 2
27037: PPUSH
27038: EMPTY
27039: PPUSH
27040: CALL_OW 1
27044: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27045: LD_VAR 0 2
27049: PPUSH
27050: LD_INT 103
27052: PPUSH
27053: CALL 20895 0 2
// continue ;
27057: GO 26968
// end ; if mc_construct_list [ i ] then
27059: LD_EXP 56
27063: PUSH
27064: LD_VAR 0 2
27068: ARRAY
27069: IFFALSE 27289
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27071: LD_ADDR_VAR 0 4
27075: PUSH
27076: LD_EXP 49
27080: PUSH
27081: LD_VAR 0 2
27085: ARRAY
27086: PPUSH
27087: LD_INT 25
27089: PUSH
27090: LD_INT 2
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: PPUSH
27097: CALL_OW 72
27101: PUSH
27102: LD_EXP 51
27106: PUSH
27107: LD_VAR 0 2
27111: ARRAY
27112: DIFF
27113: ST_TO_ADDR
// if not tmp then
27114: LD_VAR 0 4
27118: NOT
27119: IFFALSE 27123
// continue ;
27121: GO 26968
// for j in tmp do
27123: LD_ADDR_VAR 0 3
27127: PUSH
27128: LD_VAR 0 4
27132: PUSH
27133: FOR_IN
27134: IFFALSE 27285
// begin if not mc_builders [ i ] then
27136: LD_EXP 55
27140: PUSH
27141: LD_VAR 0 2
27145: ARRAY
27146: NOT
27147: IFFALSE 27205
// begin SetTag ( j , 103 ) ;
27149: LD_VAR 0 3
27153: PPUSH
27154: LD_INT 103
27156: PPUSH
27157: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
27161: LD_ADDR_EXP 55
27165: PUSH
27166: LD_EXP 55
27170: PPUSH
27171: LD_VAR 0 2
27175: PUSH
27176: LD_EXP 55
27180: PUSH
27181: LD_VAR 0 2
27185: ARRAY
27186: PUSH
27187: LD_INT 1
27189: PLUS
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PPUSH
27195: LD_VAR 0 3
27199: PPUSH
27200: CALL 53698 0 3
27204: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
27205: LD_VAR 0 3
27209: PPUSH
27210: CALL_OW 310
27214: IFFALSE 27225
// ComExitBuilding ( j ) ;
27216: LD_VAR 0 3
27220: PPUSH
27221: CALL_OW 122
// wait ( 3 ) ;
27225: LD_INT 3
27227: PPUSH
27228: CALL_OW 67
// if not mc_construct_list [ i ] then
27232: LD_EXP 56
27236: PUSH
27237: LD_VAR 0 2
27241: ARRAY
27242: NOT
27243: IFFALSE 27247
// break ;
27245: GO 27285
// if not HasTask ( j ) then
27247: LD_VAR 0 3
27251: PPUSH
27252: CALL_OW 314
27256: NOT
27257: IFFALSE 27283
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
27259: LD_VAR 0 3
27263: PPUSH
27264: LD_EXP 56
27268: PUSH
27269: LD_VAR 0 2
27273: ARRAY
27274: PUSH
27275: LD_INT 1
27277: ARRAY
27278: PPUSH
27279: CALL 56549 0 2
// end ;
27283: GO 27133
27285: POP
27286: POP
// end else
27287: GO 28092
// if mc_build_list [ i ] then
27289: LD_EXP 54
27293: PUSH
27294: LD_VAR 0 2
27298: ARRAY
27299: IFFALSE 28092
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27301: LD_ADDR_VAR 0 5
27305: PUSH
27306: LD_EXP 49
27310: PUSH
27311: LD_VAR 0 2
27315: ARRAY
27316: PPUSH
27317: LD_INT 2
27319: PUSH
27320: LD_INT 30
27322: PUSH
27323: LD_INT 0
27325: PUSH
27326: EMPTY
27327: LIST
27328: LIST
27329: PUSH
27330: LD_INT 30
27332: PUSH
27333: LD_INT 1
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: LIST
27344: PPUSH
27345: CALL_OW 72
27349: ST_TO_ADDR
// if depot then
27350: LD_VAR 0 5
27354: IFFALSE 27372
// depot := depot [ 1 ] else
27356: LD_ADDR_VAR 0 5
27360: PUSH
27361: LD_VAR 0 5
27365: PUSH
27366: LD_INT 1
27368: ARRAY
27369: ST_TO_ADDR
27370: GO 27380
// depot := 0 ;
27372: LD_ADDR_VAR 0 5
27376: PUSH
27377: LD_INT 0
27379: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
27380: LD_EXP 54
27384: PUSH
27385: LD_VAR 0 2
27389: ARRAY
27390: PUSH
27391: LD_INT 1
27393: ARRAY
27394: PUSH
27395: LD_INT 1
27397: ARRAY
27398: PPUSH
27399: CALL 56379 0 1
27403: PUSH
27404: LD_EXP 49
27408: PUSH
27409: LD_VAR 0 2
27413: ARRAY
27414: PPUSH
27415: LD_INT 2
27417: PUSH
27418: LD_INT 30
27420: PUSH
27421: LD_INT 2
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: PUSH
27428: LD_INT 30
27430: PUSH
27431: LD_INT 3
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: LIST
27442: PPUSH
27443: CALL_OW 72
27447: NOT
27448: AND
27449: IFFALSE 27554
// begin for j = 1 to mc_build_list [ i ] do
27451: LD_ADDR_VAR 0 3
27455: PUSH
27456: DOUBLE
27457: LD_INT 1
27459: DEC
27460: ST_TO_ADDR
27461: LD_EXP 54
27465: PUSH
27466: LD_VAR 0 2
27470: ARRAY
27471: PUSH
27472: FOR_TO
27473: IFFALSE 27552
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
27475: LD_EXP 54
27479: PUSH
27480: LD_VAR 0 2
27484: ARRAY
27485: PUSH
27486: LD_VAR 0 3
27490: ARRAY
27491: PUSH
27492: LD_INT 1
27494: ARRAY
27495: PUSH
27496: LD_INT 2
27498: EQUAL
27499: IFFALSE 27550
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
27501: LD_ADDR_EXP 54
27505: PUSH
27506: LD_EXP 54
27510: PPUSH
27511: LD_VAR 0 2
27515: PPUSH
27516: LD_EXP 54
27520: PUSH
27521: LD_VAR 0 2
27525: ARRAY
27526: PPUSH
27527: LD_VAR 0 3
27531: PPUSH
27532: LD_INT 1
27534: PPUSH
27535: LD_INT 0
27537: PPUSH
27538: CALL 53116 0 4
27542: PPUSH
27543: CALL_OW 1
27547: ST_TO_ADDR
// break ;
27548: GO 27552
// end ;
27550: GO 27472
27552: POP
27553: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
27554: LD_EXP 54
27558: PUSH
27559: LD_VAR 0 2
27563: ARRAY
27564: PUSH
27565: LD_INT 1
27567: ARRAY
27568: PUSH
27569: LD_INT 1
27571: ARRAY
27572: PUSH
27573: LD_INT 0
27575: EQUAL
27576: PUSH
27577: LD_VAR 0 5
27581: PUSH
27582: LD_VAR 0 5
27586: PPUSH
27587: LD_EXP 54
27591: PUSH
27592: LD_VAR 0 2
27596: ARRAY
27597: PUSH
27598: LD_INT 1
27600: ARRAY
27601: PUSH
27602: LD_INT 1
27604: ARRAY
27605: PPUSH
27606: LD_EXP 54
27610: PUSH
27611: LD_VAR 0 2
27615: ARRAY
27616: PUSH
27617: LD_INT 1
27619: ARRAY
27620: PUSH
27621: LD_INT 2
27623: ARRAY
27624: PPUSH
27625: LD_EXP 54
27629: PUSH
27630: LD_VAR 0 2
27634: ARRAY
27635: PUSH
27636: LD_INT 1
27638: ARRAY
27639: PUSH
27640: LD_INT 3
27642: ARRAY
27643: PPUSH
27644: LD_EXP 54
27648: PUSH
27649: LD_VAR 0 2
27653: ARRAY
27654: PUSH
27655: LD_INT 1
27657: ARRAY
27658: PUSH
27659: LD_INT 4
27661: ARRAY
27662: PPUSH
27663: CALL 61113 0 5
27667: AND
27668: OR
27669: IFFALSE 27950
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27671: LD_ADDR_VAR 0 4
27675: PUSH
27676: LD_EXP 49
27680: PUSH
27681: LD_VAR 0 2
27685: ARRAY
27686: PPUSH
27687: LD_INT 25
27689: PUSH
27690: LD_INT 2
27692: PUSH
27693: EMPTY
27694: LIST
27695: LIST
27696: PPUSH
27697: CALL_OW 72
27701: PUSH
27702: LD_EXP 51
27706: PUSH
27707: LD_VAR 0 2
27711: ARRAY
27712: DIFF
27713: ST_TO_ADDR
// if not tmp then
27714: LD_VAR 0 4
27718: NOT
27719: IFFALSE 27723
// continue ;
27721: GO 26968
// for j in tmp do
27723: LD_ADDR_VAR 0 3
27727: PUSH
27728: LD_VAR 0 4
27732: PUSH
27733: FOR_IN
27734: IFFALSE 27946
// begin if not mc_builders [ i ] then
27736: LD_EXP 55
27740: PUSH
27741: LD_VAR 0 2
27745: ARRAY
27746: NOT
27747: IFFALSE 27805
// begin SetTag ( j , 103 ) ;
27749: LD_VAR 0 3
27753: PPUSH
27754: LD_INT 103
27756: PPUSH
27757: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
27761: LD_ADDR_EXP 55
27765: PUSH
27766: LD_EXP 55
27770: PPUSH
27771: LD_VAR 0 2
27775: PUSH
27776: LD_EXP 55
27780: PUSH
27781: LD_VAR 0 2
27785: ARRAY
27786: PUSH
27787: LD_INT 1
27789: PLUS
27790: PUSH
27791: EMPTY
27792: LIST
27793: LIST
27794: PPUSH
27795: LD_VAR 0 3
27799: PPUSH
27800: CALL 53698 0 3
27804: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
27805: LD_VAR 0 3
27809: PPUSH
27810: CALL_OW 310
27814: IFFALSE 27825
// ComExitBuilding ( j ) ;
27816: LD_VAR 0 3
27820: PPUSH
27821: CALL_OW 122
// wait ( 3 ) ;
27825: LD_INT 3
27827: PPUSH
27828: CALL_OW 67
// if not mc_build_list [ i ] then
27832: LD_EXP 54
27836: PUSH
27837: LD_VAR 0 2
27841: ARRAY
27842: NOT
27843: IFFALSE 27847
// break ;
27845: GO 27946
// if not HasTask ( j ) then
27847: LD_VAR 0 3
27851: PPUSH
27852: CALL_OW 314
27856: NOT
27857: IFFALSE 27944
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
27859: LD_VAR 0 3
27863: PPUSH
27864: LD_EXP 54
27868: PUSH
27869: LD_VAR 0 2
27873: ARRAY
27874: PUSH
27875: LD_INT 1
27877: ARRAY
27878: PUSH
27879: LD_INT 1
27881: ARRAY
27882: PPUSH
27883: LD_EXP 54
27887: PUSH
27888: LD_VAR 0 2
27892: ARRAY
27893: PUSH
27894: LD_INT 1
27896: ARRAY
27897: PUSH
27898: LD_INT 2
27900: ARRAY
27901: PPUSH
27902: LD_EXP 54
27906: PUSH
27907: LD_VAR 0 2
27911: ARRAY
27912: PUSH
27913: LD_INT 1
27915: ARRAY
27916: PUSH
27917: LD_INT 3
27919: ARRAY
27920: PPUSH
27921: LD_EXP 54
27925: PUSH
27926: LD_VAR 0 2
27930: ARRAY
27931: PUSH
27932: LD_INT 1
27934: ARRAY
27935: PUSH
27936: LD_INT 4
27938: ARRAY
27939: PPUSH
27940: CALL_OW 145
// end ;
27944: GO 27733
27946: POP
27947: POP
// end else
27948: GO 28092
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
27950: LD_EXP 49
27954: PUSH
27955: LD_VAR 0 2
27959: ARRAY
27960: PPUSH
27961: LD_EXP 54
27965: PUSH
27966: LD_VAR 0 2
27970: ARRAY
27971: PUSH
27972: LD_INT 1
27974: ARRAY
27975: PUSH
27976: LD_INT 1
27978: ARRAY
27979: PPUSH
27980: LD_EXP 54
27984: PUSH
27985: LD_VAR 0 2
27989: ARRAY
27990: PUSH
27991: LD_INT 1
27993: ARRAY
27994: PUSH
27995: LD_INT 2
27997: ARRAY
27998: PPUSH
27999: LD_EXP 54
28003: PUSH
28004: LD_VAR 0 2
28008: ARRAY
28009: PUSH
28010: LD_INT 1
28012: ARRAY
28013: PUSH
28014: LD_INT 3
28016: ARRAY
28017: PPUSH
28018: LD_EXP 54
28022: PUSH
28023: LD_VAR 0 2
28027: ARRAY
28028: PUSH
28029: LD_INT 1
28031: ARRAY
28032: PUSH
28033: LD_INT 4
28035: ARRAY
28036: PPUSH
28037: CALL 60449 0 5
28041: NOT
28042: IFFALSE 28092
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
28044: LD_ADDR_EXP 54
28048: PUSH
28049: LD_EXP 54
28053: PPUSH
28054: LD_VAR 0 2
28058: PPUSH
28059: LD_EXP 54
28063: PUSH
28064: LD_VAR 0 2
28068: ARRAY
28069: PPUSH
28070: LD_INT 1
28072: PPUSH
28073: LD_INT 1
28075: NEG
28076: PPUSH
28077: LD_INT 0
28079: PPUSH
28080: CALL 53116 0 4
28084: PPUSH
28085: CALL_OW 1
28089: ST_TO_ADDR
// continue ;
28090: GO 26968
// end ; end ; end ;
28092: GO 26968
28094: POP
28095: POP
// end ;
28096: LD_VAR 0 1
28100: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
28101: LD_INT 0
28103: PPUSH
28104: PPUSH
28105: PPUSH
28106: PPUSH
28107: PPUSH
28108: PPUSH
// if not mc_bases then
28109: LD_EXP 49
28113: NOT
28114: IFFALSE 28118
// exit ;
28116: GO 28545
// for i = 1 to mc_bases do
28118: LD_ADDR_VAR 0 2
28122: PUSH
28123: DOUBLE
28124: LD_INT 1
28126: DEC
28127: ST_TO_ADDR
28128: LD_EXP 49
28132: PUSH
28133: FOR_TO
28134: IFFALSE 28543
// begin tmp := mc_build_upgrade [ i ] ;
28136: LD_ADDR_VAR 0 4
28140: PUSH
28141: LD_EXP 81
28145: PUSH
28146: LD_VAR 0 2
28150: ARRAY
28151: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
28152: LD_ADDR_VAR 0 6
28156: PUSH
28157: LD_EXP 82
28161: PUSH
28162: LD_VAR 0 2
28166: ARRAY
28167: PPUSH
28168: LD_INT 2
28170: PUSH
28171: LD_INT 30
28173: PUSH
28174: LD_INT 6
28176: PUSH
28177: EMPTY
28178: LIST
28179: LIST
28180: PUSH
28181: LD_INT 30
28183: PUSH
28184: LD_INT 7
28186: PUSH
28187: EMPTY
28188: LIST
28189: LIST
28190: PUSH
28191: EMPTY
28192: LIST
28193: LIST
28194: LIST
28195: PPUSH
28196: CALL_OW 72
28200: ST_TO_ADDR
// if not tmp and not lab then
28201: LD_VAR 0 4
28205: NOT
28206: PUSH
28207: LD_VAR 0 6
28211: NOT
28212: AND
28213: IFFALSE 28217
// continue ;
28215: GO 28133
// if tmp then
28217: LD_VAR 0 4
28221: IFFALSE 28341
// for j in tmp do
28223: LD_ADDR_VAR 0 3
28227: PUSH
28228: LD_VAR 0 4
28232: PUSH
28233: FOR_IN
28234: IFFALSE 28339
// begin if UpgradeCost ( j ) then
28236: LD_VAR 0 3
28240: PPUSH
28241: CALL 60109 0 1
28245: IFFALSE 28337
// begin ComUpgrade ( j ) ;
28247: LD_VAR 0 3
28251: PPUSH
28252: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
28256: LD_ADDR_EXP 81
28260: PUSH
28261: LD_EXP 81
28265: PPUSH
28266: LD_VAR 0 2
28270: PPUSH
28271: LD_EXP 81
28275: PUSH
28276: LD_VAR 0 2
28280: ARRAY
28281: PUSH
28282: LD_VAR 0 3
28286: DIFF
28287: PPUSH
28288: CALL_OW 1
28292: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28293: LD_ADDR_EXP 56
28297: PUSH
28298: LD_EXP 56
28302: PPUSH
28303: LD_VAR 0 2
28307: PUSH
28308: LD_EXP 56
28312: PUSH
28313: LD_VAR 0 2
28317: ARRAY
28318: PUSH
28319: LD_INT 1
28321: PLUS
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: PPUSH
28327: LD_VAR 0 3
28331: PPUSH
28332: CALL 53698 0 3
28336: ST_TO_ADDR
// end ; end ;
28337: GO 28233
28339: POP
28340: POP
// if not lab or not mc_lab_upgrade [ i ] then
28341: LD_VAR 0 6
28345: NOT
28346: PUSH
28347: LD_EXP 83
28351: PUSH
28352: LD_VAR 0 2
28356: ARRAY
28357: NOT
28358: OR
28359: IFFALSE 28363
// continue ;
28361: GO 28133
// for j in lab do
28363: LD_ADDR_VAR 0 3
28367: PUSH
28368: LD_VAR 0 6
28372: PUSH
28373: FOR_IN
28374: IFFALSE 28539
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
28376: LD_VAR 0 3
28380: PPUSH
28381: CALL_OW 266
28385: PUSH
28386: LD_INT 6
28388: PUSH
28389: LD_INT 7
28391: PUSH
28392: EMPTY
28393: LIST
28394: LIST
28395: IN
28396: PUSH
28397: LD_VAR 0 3
28401: PPUSH
28402: CALL_OW 461
28406: PUSH
28407: LD_INT 1
28409: NONEQUAL
28410: AND
28411: IFFALSE 28537
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
28413: LD_VAR 0 3
28417: PPUSH
28418: LD_EXP 83
28422: PUSH
28423: LD_VAR 0 2
28427: ARRAY
28428: PUSH
28429: LD_INT 1
28431: ARRAY
28432: PPUSH
28433: CALL 60314 0 2
28437: IFFALSE 28537
// begin ComCancel ( j ) ;
28439: LD_VAR 0 3
28443: PPUSH
28444: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
28448: LD_VAR 0 3
28452: PPUSH
28453: LD_EXP 83
28457: PUSH
28458: LD_VAR 0 2
28462: ARRAY
28463: PUSH
28464: LD_INT 1
28466: ARRAY
28467: PPUSH
28468: CALL_OW 207
// if not j in mc_construct_list [ i ] then
28472: LD_VAR 0 3
28476: PUSH
28477: LD_EXP 56
28481: PUSH
28482: LD_VAR 0 2
28486: ARRAY
28487: IN
28488: NOT
28489: IFFALSE 28535
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28491: LD_ADDR_EXP 56
28495: PUSH
28496: LD_EXP 56
28500: PPUSH
28501: LD_VAR 0 2
28505: PUSH
28506: LD_EXP 56
28510: PUSH
28511: LD_VAR 0 2
28515: ARRAY
28516: PUSH
28517: LD_INT 1
28519: PLUS
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PPUSH
28525: LD_VAR 0 3
28529: PPUSH
28530: CALL 53698 0 3
28534: ST_TO_ADDR
// break ;
28535: GO 28539
// end ; end ; end ;
28537: GO 28373
28539: POP
28540: POP
// end ;
28541: GO 28133
28543: POP
28544: POP
// end ;
28545: LD_VAR 0 1
28549: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
28550: LD_INT 0
28552: PPUSH
28553: PPUSH
28554: PPUSH
28555: PPUSH
28556: PPUSH
28557: PPUSH
28558: PPUSH
28559: PPUSH
28560: PPUSH
// if not mc_bases then
28561: LD_EXP 49
28565: NOT
28566: IFFALSE 28570
// exit ;
28568: GO 28975
// for i = 1 to mc_bases do
28570: LD_ADDR_VAR 0 2
28574: PUSH
28575: DOUBLE
28576: LD_INT 1
28578: DEC
28579: ST_TO_ADDR
28580: LD_EXP 49
28584: PUSH
28585: FOR_TO
28586: IFFALSE 28973
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
28588: LD_EXP 57
28592: PUSH
28593: LD_VAR 0 2
28597: ARRAY
28598: NOT
28599: PUSH
28600: LD_EXP 49
28604: PUSH
28605: LD_VAR 0 2
28609: ARRAY
28610: PPUSH
28611: LD_INT 30
28613: PUSH
28614: LD_INT 3
28616: PUSH
28617: EMPTY
28618: LIST
28619: LIST
28620: PPUSH
28621: CALL_OW 72
28625: NOT
28626: OR
28627: IFFALSE 28631
// continue ;
28629: GO 28585
// busy := false ;
28631: LD_ADDR_VAR 0 8
28635: PUSH
28636: LD_INT 0
28638: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
28639: LD_ADDR_VAR 0 4
28643: PUSH
28644: LD_EXP 49
28648: PUSH
28649: LD_VAR 0 2
28653: ARRAY
28654: PPUSH
28655: LD_INT 30
28657: PUSH
28658: LD_INT 3
28660: PUSH
28661: EMPTY
28662: LIST
28663: LIST
28664: PPUSH
28665: CALL_OW 72
28669: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
28670: LD_ADDR_VAR 0 6
28674: PUSH
28675: LD_EXP 57
28679: PUSH
28680: LD_VAR 0 2
28684: ARRAY
28685: PPUSH
28686: LD_INT 2
28688: PUSH
28689: LD_INT 30
28691: PUSH
28692: LD_INT 32
28694: PUSH
28695: EMPTY
28696: LIST
28697: LIST
28698: PUSH
28699: LD_INT 30
28701: PUSH
28702: LD_INT 33
28704: PUSH
28705: EMPTY
28706: LIST
28707: LIST
28708: PUSH
28709: EMPTY
28710: LIST
28711: LIST
28712: LIST
28713: PPUSH
28714: CALL_OW 72
28718: ST_TO_ADDR
// if not t then
28719: LD_VAR 0 6
28723: NOT
28724: IFFALSE 28728
// continue ;
28726: GO 28585
// for j in tmp do
28728: LD_ADDR_VAR 0 3
28732: PUSH
28733: LD_VAR 0 4
28737: PUSH
28738: FOR_IN
28739: IFFALSE 28769
// if not BuildingStatus ( j ) = bs_idle then
28741: LD_VAR 0 3
28745: PPUSH
28746: CALL_OW 461
28750: PUSH
28751: LD_INT 2
28753: EQUAL
28754: NOT
28755: IFFALSE 28767
// begin busy := true ;
28757: LD_ADDR_VAR 0 8
28761: PUSH
28762: LD_INT 1
28764: ST_TO_ADDR
// break ;
28765: GO 28769
// end ;
28767: GO 28738
28769: POP
28770: POP
// if busy then
28771: LD_VAR 0 8
28775: IFFALSE 28779
// continue ;
28777: GO 28585
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
28779: LD_ADDR_VAR 0 7
28783: PUSH
28784: LD_VAR 0 6
28788: PPUSH
28789: LD_INT 35
28791: PUSH
28792: LD_INT 0
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PPUSH
28799: CALL_OW 72
28803: ST_TO_ADDR
// if tw then
28804: LD_VAR 0 7
28808: IFFALSE 28885
// begin tw := tw [ 1 ] ;
28810: LD_ADDR_VAR 0 7
28814: PUSH
28815: LD_VAR 0 7
28819: PUSH
28820: LD_INT 1
28822: ARRAY
28823: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
28824: LD_ADDR_VAR 0 9
28828: PUSH
28829: LD_VAR 0 7
28833: PPUSH
28834: LD_EXP 74
28838: PUSH
28839: LD_VAR 0 2
28843: ARRAY
28844: PPUSH
28845: CALL 58668 0 2
28849: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
28850: LD_EXP 88
28854: PUSH
28855: LD_VAR 0 2
28859: ARRAY
28860: IFFALSE 28883
// if not weapon in mc_allowed_tower_weapons [ i ] then
28862: LD_VAR 0 9
28866: PUSH
28867: LD_EXP 88
28871: PUSH
28872: LD_VAR 0 2
28876: ARRAY
28877: IN
28878: NOT
28879: IFFALSE 28883
// continue ;
28881: GO 28585
// end else
28883: GO 28948
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
28885: LD_ADDR_VAR 0 5
28889: PUSH
28890: LD_EXP 57
28894: PUSH
28895: LD_VAR 0 2
28899: ARRAY
28900: PPUSH
28901: LD_VAR 0 4
28905: PPUSH
28906: CALL 88869 0 2
28910: ST_TO_ADDR
// if not tmp2 then
28911: LD_VAR 0 5
28915: NOT
28916: IFFALSE 28920
// continue ;
28918: GO 28585
// tw := tmp2 [ 1 ] ;
28920: LD_ADDR_VAR 0 7
28924: PUSH
28925: LD_VAR 0 5
28929: PUSH
28930: LD_INT 1
28932: ARRAY
28933: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
28934: LD_ADDR_VAR 0 9
28938: PUSH
28939: LD_VAR 0 5
28943: PUSH
28944: LD_INT 2
28946: ARRAY
28947: ST_TO_ADDR
// end ; if not weapon then
28948: LD_VAR 0 9
28952: NOT
28953: IFFALSE 28957
// continue ;
28955: GO 28585
// ComPlaceWeapon ( tw , weapon ) ;
28957: LD_VAR 0 7
28961: PPUSH
28962: LD_VAR 0 9
28966: PPUSH
28967: CALL_OW 148
// end ;
28971: GO 28585
28973: POP
28974: POP
// end ;
28975: LD_VAR 0 1
28979: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
28980: LD_INT 0
28982: PPUSH
28983: PPUSH
28984: PPUSH
28985: PPUSH
28986: PPUSH
28987: PPUSH
// if not mc_bases then
28988: LD_EXP 49
28992: NOT
28993: IFFALSE 28997
// exit ;
28995: GO 30009
// for i = 1 to mc_bases do
28997: LD_ADDR_VAR 0 2
29001: PUSH
29002: DOUBLE
29003: LD_INT 1
29005: DEC
29006: ST_TO_ADDR
29007: LD_EXP 49
29011: PUSH
29012: FOR_TO
29013: IFFALSE 30007
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
29015: LD_EXP 62
29019: PUSH
29020: LD_VAR 0 2
29024: ARRAY
29025: NOT
29026: PUSH
29027: LD_EXP 62
29031: PUSH
29032: LD_VAR 0 2
29036: ARRAY
29037: PUSH
29038: LD_EXP 63
29042: PUSH
29043: LD_VAR 0 2
29047: ARRAY
29048: EQUAL
29049: OR
29050: IFFALSE 29054
// continue ;
29052: GO 29012
// if mc_miners [ i ] then
29054: LD_EXP 63
29058: PUSH
29059: LD_VAR 0 2
29063: ARRAY
29064: IFFALSE 29694
// begin k := 1 ;
29066: LD_ADDR_VAR 0 4
29070: PUSH
29071: LD_INT 1
29073: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
29074: LD_ADDR_VAR 0 3
29078: PUSH
29079: DOUBLE
29080: LD_EXP 63
29084: PUSH
29085: LD_VAR 0 2
29089: ARRAY
29090: INC
29091: ST_TO_ADDR
29092: LD_INT 1
29094: PUSH
29095: FOR_DOWNTO
29096: IFFALSE 29692
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
29098: LD_EXP 63
29102: PUSH
29103: LD_VAR 0 2
29107: ARRAY
29108: PUSH
29109: LD_VAR 0 3
29113: ARRAY
29114: PPUSH
29115: CALL_OW 301
29119: PUSH
29120: LD_EXP 63
29124: PUSH
29125: LD_VAR 0 2
29129: ARRAY
29130: PUSH
29131: LD_VAR 0 3
29135: ARRAY
29136: PPUSH
29137: CALL_OW 257
29141: PUSH
29142: LD_INT 1
29144: NONEQUAL
29145: OR
29146: IFFALSE 29209
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
29148: LD_ADDR_VAR 0 5
29152: PUSH
29153: LD_EXP 63
29157: PUSH
29158: LD_VAR 0 2
29162: ARRAY
29163: PUSH
29164: LD_EXP 63
29168: PUSH
29169: LD_VAR 0 2
29173: ARRAY
29174: PUSH
29175: LD_VAR 0 3
29179: ARRAY
29180: DIFF
29181: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
29182: LD_ADDR_EXP 63
29186: PUSH
29187: LD_EXP 63
29191: PPUSH
29192: LD_VAR 0 2
29196: PPUSH
29197: LD_VAR 0 5
29201: PPUSH
29202: CALL_OW 1
29206: ST_TO_ADDR
// continue ;
29207: GO 29095
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
29209: LD_EXP 63
29213: PUSH
29214: LD_VAR 0 2
29218: ARRAY
29219: PUSH
29220: LD_VAR 0 3
29224: ARRAY
29225: PPUSH
29226: CALL 53634 0 1
29230: PUSH
29231: LD_EXP 63
29235: PUSH
29236: LD_VAR 0 2
29240: ARRAY
29241: PUSH
29242: LD_VAR 0 3
29246: ARRAY
29247: PPUSH
29248: CALL_OW 255
29252: PPUSH
29253: LD_EXP 62
29257: PUSH
29258: LD_VAR 0 2
29262: ARRAY
29263: PUSH
29264: LD_VAR 0 4
29268: ARRAY
29269: PUSH
29270: LD_INT 1
29272: ARRAY
29273: PPUSH
29274: LD_EXP 62
29278: PUSH
29279: LD_VAR 0 2
29283: ARRAY
29284: PUSH
29285: LD_VAR 0 4
29289: ARRAY
29290: PUSH
29291: LD_INT 2
29293: ARRAY
29294: PPUSH
29295: LD_INT 15
29297: PPUSH
29298: CALL 54594 0 4
29302: PUSH
29303: LD_INT 4
29305: ARRAY
29306: PUSH
29307: LD_EXP 63
29311: PUSH
29312: LD_VAR 0 2
29316: ARRAY
29317: PUSH
29318: LD_VAR 0 3
29322: ARRAY
29323: PPUSH
29324: LD_INT 10
29326: PPUSH
29327: CALL 56291 0 2
29331: PUSH
29332: LD_INT 4
29334: ARRAY
29335: OR
29336: AND
29337: IFFALSE 29360
// ComStop ( mc_miners [ i ] [ j ] ) ;
29339: LD_EXP 63
29343: PUSH
29344: LD_VAR 0 2
29348: ARRAY
29349: PUSH
29350: LD_VAR 0 3
29354: ARRAY
29355: PPUSH
29356: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
29360: LD_EXP 63
29364: PUSH
29365: LD_VAR 0 2
29369: ARRAY
29370: PUSH
29371: LD_VAR 0 3
29375: ARRAY
29376: PPUSH
29377: CALL_OW 257
29381: PUSH
29382: LD_INT 1
29384: EQUAL
29385: PUSH
29386: LD_EXP 63
29390: PUSH
29391: LD_VAR 0 2
29395: ARRAY
29396: PUSH
29397: LD_VAR 0 3
29401: ARRAY
29402: PPUSH
29403: CALL_OW 459
29407: NOT
29408: AND
29409: PUSH
29410: LD_EXP 63
29414: PUSH
29415: LD_VAR 0 2
29419: ARRAY
29420: PUSH
29421: LD_VAR 0 3
29425: ARRAY
29426: PPUSH
29427: CALL_OW 255
29431: PPUSH
29432: LD_EXP 62
29436: PUSH
29437: LD_VAR 0 2
29441: ARRAY
29442: PUSH
29443: LD_VAR 0 4
29447: ARRAY
29448: PUSH
29449: LD_INT 1
29451: ARRAY
29452: PPUSH
29453: LD_EXP 62
29457: PUSH
29458: LD_VAR 0 2
29462: ARRAY
29463: PUSH
29464: LD_VAR 0 4
29468: ARRAY
29469: PUSH
29470: LD_INT 2
29472: ARRAY
29473: PPUSH
29474: LD_INT 15
29476: PPUSH
29477: CALL 54594 0 4
29481: PUSH
29482: LD_INT 4
29484: ARRAY
29485: PUSH
29486: LD_INT 0
29488: EQUAL
29489: AND
29490: PUSH
29491: LD_EXP 63
29495: PUSH
29496: LD_VAR 0 2
29500: ARRAY
29501: PUSH
29502: LD_VAR 0 3
29506: ARRAY
29507: PPUSH
29508: CALL_OW 314
29512: NOT
29513: AND
29514: IFFALSE 29690
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
29516: LD_EXP 63
29520: PUSH
29521: LD_VAR 0 2
29525: ARRAY
29526: PUSH
29527: LD_VAR 0 3
29531: ARRAY
29532: PPUSH
29533: CALL_OW 310
29537: IFFALSE 29560
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
29539: LD_EXP 63
29543: PUSH
29544: LD_VAR 0 2
29548: ARRAY
29549: PUSH
29550: LD_VAR 0 3
29554: ARRAY
29555: PPUSH
29556: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
29560: LD_EXP 63
29564: PUSH
29565: LD_VAR 0 2
29569: ARRAY
29570: PUSH
29571: LD_VAR 0 3
29575: ARRAY
29576: PPUSH
29577: CALL_OW 314
29581: NOT
29582: IFFALSE 29650
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
29584: LD_EXP 63
29588: PUSH
29589: LD_VAR 0 2
29593: ARRAY
29594: PUSH
29595: LD_VAR 0 3
29599: ARRAY
29600: PPUSH
29601: LD_EXP 62
29605: PUSH
29606: LD_VAR 0 2
29610: ARRAY
29611: PUSH
29612: LD_VAR 0 4
29616: ARRAY
29617: PUSH
29618: LD_INT 1
29620: ARRAY
29621: PPUSH
29622: LD_EXP 62
29626: PUSH
29627: LD_VAR 0 2
29631: ARRAY
29632: PUSH
29633: LD_VAR 0 4
29637: ARRAY
29638: PUSH
29639: LD_INT 2
29641: ARRAY
29642: PPUSH
29643: LD_INT 0
29645: PPUSH
29646: CALL_OW 193
// k := k + 1 ;
29650: LD_ADDR_VAR 0 4
29654: PUSH
29655: LD_VAR 0 4
29659: PUSH
29660: LD_INT 1
29662: PLUS
29663: ST_TO_ADDR
// if k > mc_mines [ i ] then
29664: LD_VAR 0 4
29668: PUSH
29669: LD_EXP 62
29673: PUSH
29674: LD_VAR 0 2
29678: ARRAY
29679: GREATER
29680: IFFALSE 29690
// k := 1 ;
29682: LD_ADDR_VAR 0 4
29686: PUSH
29687: LD_INT 1
29689: ST_TO_ADDR
// end ; end ;
29690: GO 29095
29692: POP
29693: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
29694: LD_ADDR_VAR 0 5
29698: PUSH
29699: LD_EXP 49
29703: PUSH
29704: LD_VAR 0 2
29708: ARRAY
29709: PPUSH
29710: LD_INT 2
29712: PUSH
29713: LD_INT 30
29715: PUSH
29716: LD_INT 4
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 30
29725: PUSH
29726: LD_INT 5
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: LD_INT 30
29735: PUSH
29736: LD_INT 32
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: LIST
29747: LIST
29748: PPUSH
29749: CALL_OW 72
29753: ST_TO_ADDR
// if not tmp then
29754: LD_VAR 0 5
29758: NOT
29759: IFFALSE 29763
// continue ;
29761: GO 29012
// list := [ ] ;
29763: LD_ADDR_VAR 0 6
29767: PUSH
29768: EMPTY
29769: ST_TO_ADDR
// for j in tmp do
29770: LD_ADDR_VAR 0 3
29774: PUSH
29775: LD_VAR 0 5
29779: PUSH
29780: FOR_IN
29781: IFFALSE 29850
// begin for k in UnitsInside ( j ) do
29783: LD_ADDR_VAR 0 4
29787: PUSH
29788: LD_VAR 0 3
29792: PPUSH
29793: CALL_OW 313
29797: PUSH
29798: FOR_IN
29799: IFFALSE 29846
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
29801: LD_VAR 0 4
29805: PPUSH
29806: CALL_OW 257
29810: PUSH
29811: LD_INT 1
29813: EQUAL
29814: PUSH
29815: LD_VAR 0 4
29819: PPUSH
29820: CALL_OW 459
29824: NOT
29825: AND
29826: IFFALSE 29844
// list := list ^ k ;
29828: LD_ADDR_VAR 0 6
29832: PUSH
29833: LD_VAR 0 6
29837: PUSH
29838: LD_VAR 0 4
29842: ADD
29843: ST_TO_ADDR
29844: GO 29798
29846: POP
29847: POP
// end ;
29848: GO 29780
29850: POP
29851: POP
// list := list diff mc_miners [ i ] ;
29852: LD_ADDR_VAR 0 6
29856: PUSH
29857: LD_VAR 0 6
29861: PUSH
29862: LD_EXP 63
29866: PUSH
29867: LD_VAR 0 2
29871: ARRAY
29872: DIFF
29873: ST_TO_ADDR
// if not list then
29874: LD_VAR 0 6
29878: NOT
29879: IFFALSE 29883
// continue ;
29881: GO 29012
// k := mc_mines [ i ] - mc_miners [ i ] ;
29883: LD_ADDR_VAR 0 4
29887: PUSH
29888: LD_EXP 62
29892: PUSH
29893: LD_VAR 0 2
29897: ARRAY
29898: PUSH
29899: LD_EXP 63
29903: PUSH
29904: LD_VAR 0 2
29908: ARRAY
29909: MINUS
29910: ST_TO_ADDR
// if k > list then
29911: LD_VAR 0 4
29915: PUSH
29916: LD_VAR 0 6
29920: GREATER
29921: IFFALSE 29933
// k := list ;
29923: LD_ADDR_VAR 0 4
29927: PUSH
29928: LD_VAR 0 6
29932: ST_TO_ADDR
// for j = 1 to k do
29933: LD_ADDR_VAR 0 3
29937: PUSH
29938: DOUBLE
29939: LD_INT 1
29941: DEC
29942: ST_TO_ADDR
29943: LD_VAR 0 4
29947: PUSH
29948: FOR_TO
29949: IFFALSE 30003
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
29951: LD_ADDR_EXP 63
29955: PUSH
29956: LD_EXP 63
29960: PPUSH
29961: LD_VAR 0 2
29965: PUSH
29966: LD_EXP 63
29970: PUSH
29971: LD_VAR 0 2
29975: ARRAY
29976: PUSH
29977: LD_INT 1
29979: PLUS
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: PPUSH
29985: LD_VAR 0 6
29989: PUSH
29990: LD_VAR 0 3
29994: ARRAY
29995: PPUSH
29996: CALL 53698 0 3
30000: ST_TO_ADDR
30001: GO 29948
30003: POP
30004: POP
// end ;
30005: GO 29012
30007: POP
30008: POP
// end ;
30009: LD_VAR 0 1
30013: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30014: LD_INT 0
30016: PPUSH
30017: PPUSH
30018: PPUSH
30019: PPUSH
30020: PPUSH
30021: PPUSH
30022: PPUSH
30023: PPUSH
30024: PPUSH
30025: PPUSH
// if not mc_bases then
30026: LD_EXP 49
30030: NOT
30031: IFFALSE 30035
// exit ;
30033: GO 31785
// for i = 1 to mc_bases do
30035: LD_ADDR_VAR 0 2
30039: PUSH
30040: DOUBLE
30041: LD_INT 1
30043: DEC
30044: ST_TO_ADDR
30045: LD_EXP 49
30049: PUSH
30050: FOR_TO
30051: IFFALSE 31783
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
30053: LD_EXP 49
30057: PUSH
30058: LD_VAR 0 2
30062: ARRAY
30063: NOT
30064: PUSH
30065: LD_EXP 56
30069: PUSH
30070: LD_VAR 0 2
30074: ARRAY
30075: OR
30076: IFFALSE 30080
// continue ;
30078: GO 30050
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
30080: LD_EXP 65
30084: PUSH
30085: LD_VAR 0 2
30089: ARRAY
30090: NOT
30091: PUSH
30092: LD_EXP 66
30096: PUSH
30097: LD_VAR 0 2
30101: ARRAY
30102: AND
30103: IFFALSE 30141
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
30105: LD_ADDR_EXP 66
30109: PUSH
30110: LD_EXP 66
30114: PPUSH
30115: LD_VAR 0 2
30119: PPUSH
30120: EMPTY
30121: PPUSH
30122: CALL_OW 1
30126: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
30127: LD_VAR 0 2
30131: PPUSH
30132: LD_INT 107
30134: PPUSH
30135: CALL 20895 0 2
// continue ;
30139: GO 30050
// end ; target := [ ] ;
30141: LD_ADDR_VAR 0 6
30145: PUSH
30146: EMPTY
30147: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
30148: LD_ADDR_VAR 0 3
30152: PUSH
30153: DOUBLE
30154: LD_EXP 65
30158: PUSH
30159: LD_VAR 0 2
30163: ARRAY
30164: INC
30165: ST_TO_ADDR
30166: LD_INT 1
30168: PUSH
30169: FOR_DOWNTO
30170: IFFALSE 30430
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
30172: LD_EXP 65
30176: PUSH
30177: LD_VAR 0 2
30181: ARRAY
30182: PUSH
30183: LD_VAR 0 3
30187: ARRAY
30188: PUSH
30189: LD_INT 2
30191: ARRAY
30192: PPUSH
30193: LD_EXP 65
30197: PUSH
30198: LD_VAR 0 2
30202: ARRAY
30203: PUSH
30204: LD_VAR 0 3
30208: ARRAY
30209: PUSH
30210: LD_INT 3
30212: ARRAY
30213: PPUSH
30214: CALL_OW 488
30218: PUSH
30219: LD_EXP 65
30223: PUSH
30224: LD_VAR 0 2
30228: ARRAY
30229: PUSH
30230: LD_VAR 0 3
30234: ARRAY
30235: PUSH
30236: LD_INT 2
30238: ARRAY
30239: PPUSH
30240: LD_EXP 65
30244: PUSH
30245: LD_VAR 0 2
30249: ARRAY
30250: PUSH
30251: LD_VAR 0 3
30255: ARRAY
30256: PUSH
30257: LD_INT 3
30259: ARRAY
30260: PPUSH
30261: CALL_OW 284
30265: PUSH
30266: LD_INT 0
30268: EQUAL
30269: AND
30270: IFFALSE 30325
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
30272: LD_ADDR_VAR 0 5
30276: PUSH
30277: LD_EXP 65
30281: PUSH
30282: LD_VAR 0 2
30286: ARRAY
30287: PPUSH
30288: LD_VAR 0 3
30292: PPUSH
30293: CALL_OW 3
30297: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
30298: LD_ADDR_EXP 65
30302: PUSH
30303: LD_EXP 65
30307: PPUSH
30308: LD_VAR 0 2
30312: PPUSH
30313: LD_VAR 0 5
30317: PPUSH
30318: CALL_OW 1
30322: ST_TO_ADDR
// continue ;
30323: GO 30169
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
30325: LD_EXP 49
30329: PUSH
30330: LD_VAR 0 2
30334: ARRAY
30335: PUSH
30336: LD_INT 1
30338: ARRAY
30339: PPUSH
30340: CALL_OW 255
30344: PPUSH
30345: LD_EXP 65
30349: PUSH
30350: LD_VAR 0 2
30354: ARRAY
30355: PUSH
30356: LD_VAR 0 3
30360: ARRAY
30361: PUSH
30362: LD_INT 2
30364: ARRAY
30365: PPUSH
30366: LD_EXP 65
30370: PUSH
30371: LD_VAR 0 2
30375: ARRAY
30376: PUSH
30377: LD_VAR 0 3
30381: ARRAY
30382: PUSH
30383: LD_INT 3
30385: ARRAY
30386: PPUSH
30387: LD_INT 30
30389: PPUSH
30390: CALL 54594 0 4
30394: PUSH
30395: LD_INT 4
30397: ARRAY
30398: PUSH
30399: LD_INT 0
30401: EQUAL
30402: IFFALSE 30428
// begin target := mc_crates [ i ] [ j ] ;
30404: LD_ADDR_VAR 0 6
30408: PUSH
30409: LD_EXP 65
30413: PUSH
30414: LD_VAR 0 2
30418: ARRAY
30419: PUSH
30420: LD_VAR 0 3
30424: ARRAY
30425: ST_TO_ADDR
// break ;
30426: GO 30430
// end ; end ;
30428: GO 30169
30430: POP
30431: POP
// if not target then
30432: LD_VAR 0 6
30436: NOT
30437: IFFALSE 30441
// continue ;
30439: GO 30050
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
30441: LD_ADDR_VAR 0 7
30445: PUSH
30446: LD_EXP 68
30450: PUSH
30451: LD_VAR 0 2
30455: ARRAY
30456: PPUSH
30457: LD_INT 2
30459: PUSH
30460: LD_INT 3
30462: PUSH
30463: LD_INT 58
30465: PUSH
30466: EMPTY
30467: LIST
30468: PUSH
30469: EMPTY
30470: LIST
30471: LIST
30472: PUSH
30473: LD_INT 61
30475: PUSH
30476: EMPTY
30477: LIST
30478: PUSH
30479: LD_INT 33
30481: PUSH
30482: LD_INT 5
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 33
30491: PUSH
30492: LD_INT 3
30494: PUSH
30495: EMPTY
30496: LIST
30497: LIST
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: LIST
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 2
30508: PUSH
30509: LD_INT 34
30511: PUSH
30512: LD_INT 32
30514: PUSH
30515: EMPTY
30516: LIST
30517: LIST
30518: PUSH
30519: LD_INT 34
30521: PUSH
30522: LD_INT 51
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 34
30531: PUSH
30532: LD_INT 12
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: LIST
30543: LIST
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: PPUSH
30549: CALL_OW 72
30553: ST_TO_ADDR
// if not cargo then
30554: LD_VAR 0 7
30558: NOT
30559: IFFALSE 31202
// begin if mc_crates_collector [ i ] < 5 then
30561: LD_EXP 66
30565: PUSH
30566: LD_VAR 0 2
30570: ARRAY
30571: PUSH
30572: LD_INT 5
30574: LESS
30575: IFFALSE 30941
// begin if mc_ape [ i ] then
30577: LD_EXP 78
30581: PUSH
30582: LD_VAR 0 2
30586: ARRAY
30587: IFFALSE 30634
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
30589: LD_ADDR_VAR 0 5
30593: PUSH
30594: LD_EXP 78
30598: PUSH
30599: LD_VAR 0 2
30603: ARRAY
30604: PPUSH
30605: LD_INT 25
30607: PUSH
30608: LD_INT 16
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: PUSH
30615: LD_INT 24
30617: PUSH
30618: LD_INT 750
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PPUSH
30629: CALL_OW 72
30633: ST_TO_ADDR
// if not tmp then
30634: LD_VAR 0 5
30638: NOT
30639: IFFALSE 30686
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
30641: LD_ADDR_VAR 0 5
30645: PUSH
30646: LD_EXP 49
30650: PUSH
30651: LD_VAR 0 2
30655: ARRAY
30656: PPUSH
30657: LD_INT 25
30659: PUSH
30660: LD_INT 2
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: LD_INT 24
30669: PUSH
30670: LD_INT 750
30672: PUSH
30673: EMPTY
30674: LIST
30675: LIST
30676: PUSH
30677: EMPTY
30678: LIST
30679: LIST
30680: PPUSH
30681: CALL_OW 72
30685: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
30686: LD_EXP 78
30690: PUSH
30691: LD_VAR 0 2
30695: ARRAY
30696: PUSH
30697: LD_EXP 49
30701: PUSH
30702: LD_VAR 0 2
30706: ARRAY
30707: PPUSH
30708: LD_INT 25
30710: PUSH
30711: LD_INT 2
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 24
30720: PUSH
30721: LD_INT 750
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PPUSH
30732: CALL_OW 72
30736: AND
30737: PUSH
30738: LD_VAR 0 5
30742: PUSH
30743: LD_INT 5
30745: LESS
30746: AND
30747: IFFALSE 30829
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
30749: LD_ADDR_VAR 0 3
30753: PUSH
30754: LD_EXP 49
30758: PUSH
30759: LD_VAR 0 2
30763: ARRAY
30764: PPUSH
30765: LD_INT 25
30767: PUSH
30768: LD_INT 2
30770: PUSH
30771: EMPTY
30772: LIST
30773: LIST
30774: PUSH
30775: LD_INT 24
30777: PUSH
30778: LD_INT 750
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: EMPTY
30786: LIST
30787: LIST
30788: PPUSH
30789: CALL_OW 72
30793: PUSH
30794: FOR_IN
30795: IFFALSE 30827
// begin tmp := tmp union j ;
30797: LD_ADDR_VAR 0 5
30801: PUSH
30802: LD_VAR 0 5
30806: PUSH
30807: LD_VAR 0 3
30811: UNION
30812: ST_TO_ADDR
// if tmp >= 5 then
30813: LD_VAR 0 5
30817: PUSH
30818: LD_INT 5
30820: GREATEREQUAL
30821: IFFALSE 30825
// break ;
30823: GO 30827
// end ;
30825: GO 30794
30827: POP
30828: POP
// end ; if not tmp then
30829: LD_VAR 0 5
30833: NOT
30834: IFFALSE 30838
// continue ;
30836: GO 30050
// for j in tmp do
30838: LD_ADDR_VAR 0 3
30842: PUSH
30843: LD_VAR 0 5
30847: PUSH
30848: FOR_IN
30849: IFFALSE 30939
// if not GetTag ( j ) then
30851: LD_VAR 0 3
30855: PPUSH
30856: CALL_OW 110
30860: NOT
30861: IFFALSE 30937
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
30863: LD_ADDR_EXP 66
30867: PUSH
30868: LD_EXP 66
30872: PPUSH
30873: LD_VAR 0 2
30877: PUSH
30878: LD_EXP 66
30882: PUSH
30883: LD_VAR 0 2
30887: ARRAY
30888: PUSH
30889: LD_INT 1
30891: PLUS
30892: PUSH
30893: EMPTY
30894: LIST
30895: LIST
30896: PPUSH
30897: LD_VAR 0 3
30901: PPUSH
30902: CALL 53698 0 3
30906: ST_TO_ADDR
// SetTag ( j , 107 ) ;
30907: LD_VAR 0 3
30911: PPUSH
30912: LD_INT 107
30914: PPUSH
30915: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
30919: LD_EXP 66
30923: PUSH
30924: LD_VAR 0 2
30928: ARRAY
30929: PUSH
30930: LD_INT 5
30932: GREATEREQUAL
30933: IFFALSE 30937
// break ;
30935: GO 30939
// end ;
30937: GO 30848
30939: POP
30940: POP
// end ; if mc_crates_collector [ i ] and target then
30941: LD_EXP 66
30945: PUSH
30946: LD_VAR 0 2
30950: ARRAY
30951: PUSH
30952: LD_VAR 0 6
30956: AND
30957: IFFALSE 31200
// begin if mc_crates_collector [ i ] < target [ 1 ] then
30959: LD_EXP 66
30963: PUSH
30964: LD_VAR 0 2
30968: ARRAY
30969: PUSH
30970: LD_VAR 0 6
30974: PUSH
30975: LD_INT 1
30977: ARRAY
30978: LESS
30979: IFFALSE 30999
// tmp := mc_crates_collector [ i ] else
30981: LD_ADDR_VAR 0 5
30985: PUSH
30986: LD_EXP 66
30990: PUSH
30991: LD_VAR 0 2
30995: ARRAY
30996: ST_TO_ADDR
30997: GO 31013
// tmp := target [ 1 ] ;
30999: LD_ADDR_VAR 0 5
31003: PUSH
31004: LD_VAR 0 6
31008: PUSH
31009: LD_INT 1
31011: ARRAY
31012: ST_TO_ADDR
// k := 0 ;
31013: LD_ADDR_VAR 0 4
31017: PUSH
31018: LD_INT 0
31020: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31021: LD_ADDR_VAR 0 3
31025: PUSH
31026: LD_EXP 66
31030: PUSH
31031: LD_VAR 0 2
31035: ARRAY
31036: PUSH
31037: FOR_IN
31038: IFFALSE 31198
// begin k := k + 1 ;
31040: LD_ADDR_VAR 0 4
31044: PUSH
31045: LD_VAR 0 4
31049: PUSH
31050: LD_INT 1
31052: PLUS
31053: ST_TO_ADDR
// if k > tmp then
31054: LD_VAR 0 4
31058: PUSH
31059: LD_VAR 0 5
31063: GREATER
31064: IFFALSE 31068
// break ;
31066: GO 31198
// if not GetClass ( j ) in [ 2 , 16 ] then
31068: LD_VAR 0 3
31072: PPUSH
31073: CALL_OW 257
31077: PUSH
31078: LD_INT 2
31080: PUSH
31081: LD_INT 16
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: IN
31088: NOT
31089: IFFALSE 31142
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
31091: LD_ADDR_EXP 66
31095: PUSH
31096: LD_EXP 66
31100: PPUSH
31101: LD_VAR 0 2
31105: PPUSH
31106: LD_EXP 66
31110: PUSH
31111: LD_VAR 0 2
31115: ARRAY
31116: PUSH
31117: LD_VAR 0 3
31121: DIFF
31122: PPUSH
31123: CALL_OW 1
31127: ST_TO_ADDR
// SetTag ( j , 0 ) ;
31128: LD_VAR 0 3
31132: PPUSH
31133: LD_INT 0
31135: PPUSH
31136: CALL_OW 109
// continue ;
31140: GO 31037
// end ; if IsInUnit ( j ) then
31142: LD_VAR 0 3
31146: PPUSH
31147: CALL_OW 310
31151: IFFALSE 31162
// ComExitBuilding ( j ) ;
31153: LD_VAR 0 3
31157: PPUSH
31158: CALL_OW 122
// wait ( 3 ) ;
31162: LD_INT 3
31164: PPUSH
31165: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
31169: LD_VAR 0 3
31173: PPUSH
31174: LD_VAR 0 6
31178: PUSH
31179: LD_INT 2
31181: ARRAY
31182: PPUSH
31183: LD_VAR 0 6
31187: PUSH
31188: LD_INT 3
31190: ARRAY
31191: PPUSH
31192: CALL_OW 117
// end ;
31196: GO 31037
31198: POP
31199: POP
// end ; end else
31200: GO 31781
// begin for j in cargo do
31202: LD_ADDR_VAR 0 3
31206: PUSH
31207: LD_VAR 0 7
31211: PUSH
31212: FOR_IN
31213: IFFALSE 31779
// begin if GetTag ( j ) <> 0 then
31215: LD_VAR 0 3
31219: PPUSH
31220: CALL_OW 110
31224: PUSH
31225: LD_INT 0
31227: NONEQUAL
31228: IFFALSE 31232
// continue ;
31230: GO 31212
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
31232: LD_VAR 0 3
31236: PPUSH
31237: CALL_OW 256
31241: PUSH
31242: LD_INT 1000
31244: LESS
31245: PUSH
31246: LD_VAR 0 3
31250: PPUSH
31251: LD_EXP 73
31255: PUSH
31256: LD_VAR 0 2
31260: ARRAY
31261: PPUSH
31262: CALL_OW 308
31266: NOT
31267: AND
31268: IFFALSE 31290
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31270: LD_VAR 0 3
31274: PPUSH
31275: LD_EXP 73
31279: PUSH
31280: LD_VAR 0 2
31284: ARRAY
31285: PPUSH
31286: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
31290: LD_VAR 0 3
31294: PPUSH
31295: CALL_OW 256
31299: PUSH
31300: LD_INT 1000
31302: LESS
31303: PUSH
31304: LD_VAR 0 3
31308: PPUSH
31309: LD_EXP 73
31313: PUSH
31314: LD_VAR 0 2
31318: ARRAY
31319: PPUSH
31320: CALL_OW 308
31324: AND
31325: IFFALSE 31329
// continue ;
31327: GO 31212
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
31329: LD_VAR 0 3
31333: PPUSH
31334: CALL_OW 262
31338: PUSH
31339: LD_INT 2
31341: EQUAL
31342: PUSH
31343: LD_VAR 0 3
31347: PPUSH
31348: CALL_OW 261
31352: PUSH
31353: LD_INT 15
31355: LESS
31356: AND
31357: IFFALSE 31361
// continue ;
31359: GO 31212
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
31361: LD_VAR 0 3
31365: PPUSH
31366: CALL_OW 262
31370: PUSH
31371: LD_INT 1
31373: EQUAL
31374: PUSH
31375: LD_VAR 0 3
31379: PPUSH
31380: CALL_OW 261
31384: PUSH
31385: LD_INT 10
31387: LESS
31388: AND
31389: IFFALSE 31718
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31391: LD_ADDR_VAR 0 8
31395: PUSH
31396: LD_EXP 49
31400: PUSH
31401: LD_VAR 0 2
31405: ARRAY
31406: PPUSH
31407: LD_INT 2
31409: PUSH
31410: LD_INT 30
31412: PUSH
31413: LD_INT 0
31415: PUSH
31416: EMPTY
31417: LIST
31418: LIST
31419: PUSH
31420: LD_INT 30
31422: PUSH
31423: LD_INT 1
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: EMPTY
31431: LIST
31432: LIST
31433: LIST
31434: PPUSH
31435: CALL_OW 72
31439: ST_TO_ADDR
// if not depot then
31440: LD_VAR 0 8
31444: NOT
31445: IFFALSE 31449
// continue ;
31447: GO 31212
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
31449: LD_VAR 0 3
31453: PPUSH
31454: LD_VAR 0 8
31458: PPUSH
31459: LD_VAR 0 3
31463: PPUSH
31464: CALL_OW 74
31468: PPUSH
31469: CALL_OW 296
31473: PUSH
31474: LD_INT 6
31476: LESS
31477: IFFALSE 31493
// SetFuel ( j , 100 ) else
31479: LD_VAR 0 3
31483: PPUSH
31484: LD_INT 100
31486: PPUSH
31487: CALL_OW 240
31491: GO 31718
// if GetFuel ( j ) = 0 then
31493: LD_VAR 0 3
31497: PPUSH
31498: CALL_OW 261
31502: PUSH
31503: LD_INT 0
31505: EQUAL
31506: IFFALSE 31718
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
31508: LD_ADDR_EXP 68
31512: PUSH
31513: LD_EXP 68
31517: PPUSH
31518: LD_VAR 0 2
31522: PPUSH
31523: LD_EXP 68
31527: PUSH
31528: LD_VAR 0 2
31532: ARRAY
31533: PUSH
31534: LD_VAR 0 3
31538: DIFF
31539: PPUSH
31540: CALL_OW 1
31544: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
31545: LD_VAR 0 3
31549: PPUSH
31550: CALL_OW 263
31554: PUSH
31555: LD_INT 1
31557: EQUAL
31558: IFFALSE 31574
// ComExitVehicle ( IsInUnit ( j ) ) ;
31560: LD_VAR 0 3
31564: PPUSH
31565: CALL_OW 310
31569: PPUSH
31570: CALL_OW 121
// if GetControl ( j ) = control_remote then
31574: LD_VAR 0 3
31578: PPUSH
31579: CALL_OW 263
31583: PUSH
31584: LD_INT 2
31586: EQUAL
31587: IFFALSE 31598
// ComUnlink ( j ) ;
31589: LD_VAR 0 3
31593: PPUSH
31594: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
31598: LD_ADDR_VAR 0 9
31602: PUSH
31603: LD_VAR 0 2
31607: PPUSH
31608: LD_INT 3
31610: PPUSH
31611: CALL 40855 0 2
31615: ST_TO_ADDR
// if fac then
31616: LD_VAR 0 9
31620: IFFALSE 31716
// begin for k in fac do
31622: LD_ADDR_VAR 0 4
31626: PUSH
31627: LD_VAR 0 9
31631: PUSH
31632: FOR_IN
31633: IFFALSE 31714
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
31635: LD_ADDR_VAR 0 10
31639: PUSH
31640: LD_VAR 0 9
31644: PPUSH
31645: LD_VAR 0 3
31649: PPUSH
31650: CALL_OW 265
31654: PPUSH
31655: LD_VAR 0 3
31659: PPUSH
31660: CALL_OW 262
31664: PPUSH
31665: LD_VAR 0 3
31669: PPUSH
31670: CALL_OW 263
31674: PPUSH
31675: LD_VAR 0 3
31679: PPUSH
31680: CALL_OW 264
31684: PPUSH
31685: CALL 51230 0 5
31689: ST_TO_ADDR
// if components then
31690: LD_VAR 0 10
31694: IFFALSE 31712
// begin MC_InsertProduceList ( i , components ) ;
31696: LD_VAR 0 2
31700: PPUSH
31701: LD_VAR 0 10
31705: PPUSH
31706: CALL 40400 0 2
// break ;
31710: GO 31714
// end ; end ;
31712: GO 31632
31714: POP
31715: POP
// end ; continue ;
31716: GO 31212
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
31718: LD_VAR 0 3
31722: PPUSH
31723: LD_INT 1
31725: PPUSH
31726: CALL_OW 289
31730: PUSH
31731: LD_INT 100
31733: LESS
31734: PUSH
31735: LD_VAR 0 3
31739: PPUSH
31740: CALL_OW 314
31744: NOT
31745: AND
31746: IFFALSE 31775
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
31748: LD_VAR 0 3
31752: PPUSH
31753: LD_VAR 0 6
31757: PUSH
31758: LD_INT 2
31760: ARRAY
31761: PPUSH
31762: LD_VAR 0 6
31766: PUSH
31767: LD_INT 3
31769: ARRAY
31770: PPUSH
31771: CALL_OW 117
// break ;
31775: GO 31779
// end ;
31777: GO 31212
31779: POP
31780: POP
// end ; end ;
31781: GO 30050
31783: POP
31784: POP
// end ;
31785: LD_VAR 0 1
31789: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
31790: LD_INT 0
31792: PPUSH
31793: PPUSH
31794: PPUSH
31795: PPUSH
// if not mc_bases then
31796: LD_EXP 49
31800: NOT
31801: IFFALSE 31805
// exit ;
31803: GO 31966
// for i = 1 to mc_bases do
31805: LD_ADDR_VAR 0 2
31809: PUSH
31810: DOUBLE
31811: LD_INT 1
31813: DEC
31814: ST_TO_ADDR
31815: LD_EXP 49
31819: PUSH
31820: FOR_TO
31821: IFFALSE 31964
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
31823: LD_ADDR_VAR 0 4
31827: PUSH
31828: LD_EXP 68
31832: PUSH
31833: LD_VAR 0 2
31837: ARRAY
31838: PUSH
31839: LD_EXP 71
31843: PUSH
31844: LD_VAR 0 2
31848: ARRAY
31849: UNION
31850: PPUSH
31851: LD_INT 33
31853: PUSH
31854: LD_INT 2
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PPUSH
31861: CALL_OW 72
31865: ST_TO_ADDR
// if tmp then
31866: LD_VAR 0 4
31870: IFFALSE 31962
// for j in tmp do
31872: LD_ADDR_VAR 0 3
31876: PUSH
31877: LD_VAR 0 4
31881: PUSH
31882: FOR_IN
31883: IFFALSE 31960
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
31885: LD_VAR 0 3
31889: PPUSH
31890: CALL_OW 312
31894: NOT
31895: PUSH
31896: LD_VAR 0 3
31900: PPUSH
31901: CALL_OW 256
31905: PUSH
31906: LD_INT 250
31908: GREATEREQUAL
31909: AND
31910: IFFALSE 31923
// Connect ( j ) else
31912: LD_VAR 0 3
31916: PPUSH
31917: CALL 56631 0 1
31921: GO 31958
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
31923: LD_VAR 0 3
31927: PPUSH
31928: CALL_OW 256
31932: PUSH
31933: LD_INT 250
31935: LESS
31936: PUSH
31937: LD_VAR 0 3
31941: PPUSH
31942: CALL_OW 312
31946: AND
31947: IFFALSE 31958
// ComUnlink ( j ) ;
31949: LD_VAR 0 3
31953: PPUSH
31954: CALL_OW 136
31958: GO 31882
31960: POP
31961: POP
// end ;
31962: GO 31820
31964: POP
31965: POP
// end ;
31966: LD_VAR 0 1
31970: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
31971: LD_INT 0
31973: PPUSH
31974: PPUSH
31975: PPUSH
31976: PPUSH
31977: PPUSH
// if not mc_bases then
31978: LD_EXP 49
31982: NOT
31983: IFFALSE 31987
// exit ;
31985: GO 32432
// for i = 1 to mc_bases do
31987: LD_ADDR_VAR 0 2
31991: PUSH
31992: DOUBLE
31993: LD_INT 1
31995: DEC
31996: ST_TO_ADDR
31997: LD_EXP 49
32001: PUSH
32002: FOR_TO
32003: IFFALSE 32430
// begin if not mc_produce [ i ] then
32005: LD_EXP 70
32009: PUSH
32010: LD_VAR 0 2
32014: ARRAY
32015: NOT
32016: IFFALSE 32020
// continue ;
32018: GO 32002
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32020: LD_ADDR_VAR 0 5
32024: PUSH
32025: LD_EXP 49
32029: PUSH
32030: LD_VAR 0 2
32034: ARRAY
32035: PPUSH
32036: LD_INT 30
32038: PUSH
32039: LD_INT 3
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PPUSH
32046: CALL_OW 72
32050: ST_TO_ADDR
// if not fac then
32051: LD_VAR 0 5
32055: NOT
32056: IFFALSE 32060
// continue ;
32058: GO 32002
// for j in fac do
32060: LD_ADDR_VAR 0 3
32064: PUSH
32065: LD_VAR 0 5
32069: PUSH
32070: FOR_IN
32071: IFFALSE 32426
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
32073: LD_VAR 0 3
32077: PPUSH
32078: CALL_OW 461
32082: PUSH
32083: LD_INT 2
32085: NONEQUAL
32086: PUSH
32087: LD_VAR 0 3
32091: PPUSH
32092: LD_INT 15
32094: PPUSH
32095: CALL 56291 0 2
32099: PUSH
32100: LD_INT 4
32102: ARRAY
32103: OR
32104: IFFALSE 32108
// continue ;
32106: GO 32070
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
32108: LD_VAR 0 3
32112: PPUSH
32113: LD_EXP 70
32117: PUSH
32118: LD_VAR 0 2
32122: ARRAY
32123: PUSH
32124: LD_INT 1
32126: ARRAY
32127: PUSH
32128: LD_INT 1
32130: ARRAY
32131: PPUSH
32132: LD_EXP 70
32136: PUSH
32137: LD_VAR 0 2
32141: ARRAY
32142: PUSH
32143: LD_INT 1
32145: ARRAY
32146: PUSH
32147: LD_INT 2
32149: ARRAY
32150: PPUSH
32151: LD_EXP 70
32155: PUSH
32156: LD_VAR 0 2
32160: ARRAY
32161: PUSH
32162: LD_INT 1
32164: ARRAY
32165: PUSH
32166: LD_INT 3
32168: ARRAY
32169: PPUSH
32170: LD_EXP 70
32174: PUSH
32175: LD_VAR 0 2
32179: ARRAY
32180: PUSH
32181: LD_INT 1
32183: ARRAY
32184: PUSH
32185: LD_INT 4
32187: ARRAY
32188: PPUSH
32189: CALL_OW 448
32193: PUSH
32194: LD_VAR 0 3
32198: PPUSH
32199: LD_EXP 70
32203: PUSH
32204: LD_VAR 0 2
32208: ARRAY
32209: PUSH
32210: LD_INT 1
32212: ARRAY
32213: PUSH
32214: LD_INT 1
32216: ARRAY
32217: PUSH
32218: LD_EXP 70
32222: PUSH
32223: LD_VAR 0 2
32227: ARRAY
32228: PUSH
32229: LD_INT 1
32231: ARRAY
32232: PUSH
32233: LD_INT 2
32235: ARRAY
32236: PUSH
32237: LD_EXP 70
32241: PUSH
32242: LD_VAR 0 2
32246: ARRAY
32247: PUSH
32248: LD_INT 1
32250: ARRAY
32251: PUSH
32252: LD_INT 3
32254: ARRAY
32255: PUSH
32256: LD_EXP 70
32260: PUSH
32261: LD_VAR 0 2
32265: ARRAY
32266: PUSH
32267: LD_INT 1
32269: ARRAY
32270: PUSH
32271: LD_INT 4
32273: ARRAY
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: LIST
32279: LIST
32280: PPUSH
32281: CALL 59962 0 2
32285: AND
32286: IFFALSE 32424
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
32288: LD_VAR 0 3
32292: PPUSH
32293: LD_EXP 70
32297: PUSH
32298: LD_VAR 0 2
32302: ARRAY
32303: PUSH
32304: LD_INT 1
32306: ARRAY
32307: PUSH
32308: LD_INT 1
32310: ARRAY
32311: PPUSH
32312: LD_EXP 70
32316: PUSH
32317: LD_VAR 0 2
32321: ARRAY
32322: PUSH
32323: LD_INT 1
32325: ARRAY
32326: PUSH
32327: LD_INT 2
32329: ARRAY
32330: PPUSH
32331: LD_EXP 70
32335: PUSH
32336: LD_VAR 0 2
32340: ARRAY
32341: PUSH
32342: LD_INT 1
32344: ARRAY
32345: PUSH
32346: LD_INT 3
32348: ARRAY
32349: PPUSH
32350: LD_EXP 70
32354: PUSH
32355: LD_VAR 0 2
32359: ARRAY
32360: PUSH
32361: LD_INT 1
32363: ARRAY
32364: PUSH
32365: LD_INT 4
32367: ARRAY
32368: PPUSH
32369: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
32373: LD_ADDR_VAR 0 4
32377: PUSH
32378: LD_EXP 70
32382: PUSH
32383: LD_VAR 0 2
32387: ARRAY
32388: PPUSH
32389: LD_INT 1
32391: PPUSH
32392: CALL_OW 3
32396: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
32397: LD_ADDR_EXP 70
32401: PUSH
32402: LD_EXP 70
32406: PPUSH
32407: LD_VAR 0 2
32411: PPUSH
32412: LD_VAR 0 4
32416: PPUSH
32417: CALL_OW 1
32421: ST_TO_ADDR
// break ;
32422: GO 32426
// end ; end ;
32424: GO 32070
32426: POP
32427: POP
// end ;
32428: GO 32002
32430: POP
32431: POP
// end ;
32432: LD_VAR 0 1
32436: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
32437: LD_INT 0
32439: PPUSH
32440: PPUSH
32441: PPUSH
// if not mc_bases then
32442: LD_EXP 49
32446: NOT
32447: IFFALSE 32451
// exit ;
32449: GO 32540
// for i = 1 to mc_bases do
32451: LD_ADDR_VAR 0 2
32455: PUSH
32456: DOUBLE
32457: LD_INT 1
32459: DEC
32460: ST_TO_ADDR
32461: LD_EXP 49
32465: PUSH
32466: FOR_TO
32467: IFFALSE 32538
// begin if mc_attack [ i ] then
32469: LD_EXP 69
32473: PUSH
32474: LD_VAR 0 2
32478: ARRAY
32479: IFFALSE 32536
// begin tmp := mc_attack [ i ] [ 1 ] ;
32481: LD_ADDR_VAR 0 3
32485: PUSH
32486: LD_EXP 69
32490: PUSH
32491: LD_VAR 0 2
32495: ARRAY
32496: PUSH
32497: LD_INT 1
32499: ARRAY
32500: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
32501: LD_ADDR_EXP 69
32505: PUSH
32506: LD_EXP 69
32510: PPUSH
32511: LD_VAR 0 2
32515: PPUSH
32516: EMPTY
32517: PPUSH
32518: CALL_OW 1
32522: ST_TO_ADDR
// Attack ( tmp ) ;
32523: LD_VAR 0 3
32527: PPUSH
32528: CALL 82175 0 1
// exit ;
32532: POP
32533: POP
32534: GO 32540
// end ; end ;
32536: GO 32466
32538: POP
32539: POP
// end ;
32540: LD_VAR 0 1
32544: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
32545: LD_INT 0
32547: PPUSH
32548: PPUSH
32549: PPUSH
32550: PPUSH
32551: PPUSH
32552: PPUSH
32553: PPUSH
// if not mc_bases then
32554: LD_EXP 49
32558: NOT
32559: IFFALSE 32563
// exit ;
32561: GO 33145
// for i = 1 to mc_bases do
32563: LD_ADDR_VAR 0 2
32567: PUSH
32568: DOUBLE
32569: LD_INT 1
32571: DEC
32572: ST_TO_ADDR
32573: LD_EXP 49
32577: PUSH
32578: FOR_TO
32579: IFFALSE 33143
// begin if not mc_bases [ i ] then
32581: LD_EXP 49
32585: PUSH
32586: LD_VAR 0 2
32590: ARRAY
32591: NOT
32592: IFFALSE 32596
// continue ;
32594: GO 32578
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
32596: LD_ADDR_VAR 0 7
32600: PUSH
32601: LD_EXP 49
32605: PUSH
32606: LD_VAR 0 2
32610: ARRAY
32611: PUSH
32612: LD_INT 1
32614: ARRAY
32615: PPUSH
32616: CALL 50534 0 1
32620: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
32621: LD_ADDR_EXP 72
32625: PUSH
32626: LD_EXP 72
32630: PPUSH
32631: LD_VAR 0 2
32635: PPUSH
32636: LD_EXP 49
32640: PUSH
32641: LD_VAR 0 2
32645: ARRAY
32646: PUSH
32647: LD_INT 1
32649: ARRAY
32650: PPUSH
32651: CALL_OW 255
32655: PPUSH
32656: LD_EXP 74
32660: PUSH
32661: LD_VAR 0 2
32665: ARRAY
32666: PPUSH
32667: CALL 48237 0 2
32671: PPUSH
32672: CALL_OW 1
32676: ST_TO_ADDR
// if not mc_scan [ i ] then
32677: LD_EXP 72
32681: PUSH
32682: LD_VAR 0 2
32686: ARRAY
32687: NOT
32688: IFFALSE 32843
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
32690: LD_ADDR_VAR 0 4
32694: PUSH
32695: LD_EXP 49
32699: PUSH
32700: LD_VAR 0 2
32704: ARRAY
32705: PPUSH
32706: LD_INT 2
32708: PUSH
32709: LD_INT 25
32711: PUSH
32712: LD_INT 5
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 25
32721: PUSH
32722: LD_INT 8
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 25
32731: PUSH
32732: LD_INT 9
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: LIST
32743: LIST
32744: PPUSH
32745: CALL_OW 72
32749: ST_TO_ADDR
// if not tmp then
32750: LD_VAR 0 4
32754: NOT
32755: IFFALSE 32759
// continue ;
32757: GO 32578
// for j in tmp do
32759: LD_ADDR_VAR 0 3
32763: PUSH
32764: LD_VAR 0 4
32768: PUSH
32769: FOR_IN
32770: IFFALSE 32841
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
32772: LD_VAR 0 3
32776: PPUSH
32777: CALL_OW 310
32781: PPUSH
32782: CALL_OW 266
32786: PUSH
32787: LD_INT 5
32789: EQUAL
32790: PUSH
32791: LD_VAR 0 3
32795: PPUSH
32796: CALL_OW 257
32800: PUSH
32801: LD_INT 1
32803: EQUAL
32804: AND
32805: PUSH
32806: LD_VAR 0 3
32810: PPUSH
32811: CALL_OW 459
32815: NOT
32816: AND
32817: PUSH
32818: LD_VAR 0 7
32822: AND
32823: IFFALSE 32839
// ComChangeProfession ( j , class ) ;
32825: LD_VAR 0 3
32829: PPUSH
32830: LD_VAR 0 7
32834: PPUSH
32835: CALL_OW 123
32839: GO 32769
32841: POP
32842: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
32843: LD_EXP 72
32847: PUSH
32848: LD_VAR 0 2
32852: ARRAY
32853: PUSH
32854: LD_EXP 71
32858: PUSH
32859: LD_VAR 0 2
32863: ARRAY
32864: NOT
32865: AND
32866: PUSH
32867: LD_EXP 49
32871: PUSH
32872: LD_VAR 0 2
32876: ARRAY
32877: PPUSH
32878: LD_INT 30
32880: PUSH
32881: LD_INT 32
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PPUSH
32888: CALL_OW 72
32892: NOT
32893: AND
32894: PUSH
32895: LD_EXP 49
32899: PUSH
32900: LD_VAR 0 2
32904: ARRAY
32905: PPUSH
32906: LD_INT 2
32908: PUSH
32909: LD_INT 30
32911: PUSH
32912: LD_INT 4
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 30
32921: PUSH
32922: LD_INT 5
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: EMPTY
32930: LIST
32931: LIST
32932: LIST
32933: PPUSH
32934: CALL_OW 72
32938: NOT
32939: AND
32940: IFFALSE 33072
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
32942: LD_ADDR_VAR 0 4
32946: PUSH
32947: LD_EXP 49
32951: PUSH
32952: LD_VAR 0 2
32956: ARRAY
32957: PPUSH
32958: LD_INT 2
32960: PUSH
32961: LD_INT 25
32963: PUSH
32964: LD_INT 1
32966: PUSH
32967: EMPTY
32968: LIST
32969: LIST
32970: PUSH
32971: LD_INT 25
32973: PUSH
32974: LD_INT 5
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: PUSH
32981: LD_INT 25
32983: PUSH
32984: LD_INT 8
32986: PUSH
32987: EMPTY
32988: LIST
32989: LIST
32990: PUSH
32991: LD_INT 25
32993: PUSH
32994: LD_INT 9
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: LIST
33007: PPUSH
33008: CALL_OW 72
33012: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33013: LD_ADDR_VAR 0 4
33017: PUSH
33018: LD_VAR 0 4
33022: PUSH
33023: LD_VAR 0 4
33027: PPUSH
33028: LD_INT 18
33030: PPUSH
33031: CALL 86958 0 2
33035: DIFF
33036: ST_TO_ADDR
// if tmp then
33037: LD_VAR 0 4
33041: IFFALSE 33072
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
33043: LD_VAR 0 2
33047: PPUSH
33048: LD_VAR 0 4
33052: PPUSH
33053: LD_EXP 74
33057: PUSH
33058: LD_VAR 0 2
33062: ARRAY
33063: PPUSH
33064: CALL 48272 0 3
// exit ;
33068: POP
33069: POP
33070: GO 33145
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
33072: LD_EXP 72
33076: PUSH
33077: LD_VAR 0 2
33081: ARRAY
33082: PUSH
33083: LD_EXP 71
33087: PUSH
33088: LD_VAR 0 2
33092: ARRAY
33093: AND
33094: IFFALSE 33141
// begin tmp := mc_defender [ i ] ;
33096: LD_ADDR_VAR 0 4
33100: PUSH
33101: LD_EXP 71
33105: PUSH
33106: LD_VAR 0 2
33110: ARRAY
33111: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
33112: LD_VAR 0 2
33116: PPUSH
33117: LD_VAR 0 4
33121: PPUSH
33122: LD_EXP 72
33126: PUSH
33127: LD_VAR 0 2
33131: ARRAY
33132: PPUSH
33133: CALL 48833 0 3
// exit ;
33137: POP
33138: POP
33139: GO 33145
// end ; end ;
33141: GO 32578
33143: POP
33144: POP
// end ;
33145: LD_VAR 0 1
33149: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
33150: LD_INT 0
33152: PPUSH
33153: PPUSH
33154: PPUSH
33155: PPUSH
33156: PPUSH
33157: PPUSH
33158: PPUSH
33159: PPUSH
33160: PPUSH
33161: PPUSH
33162: PPUSH
// if not mc_bases then
33163: LD_EXP 49
33167: NOT
33168: IFFALSE 33172
// exit ;
33170: GO 34259
// for i = 1 to mc_bases do
33172: LD_ADDR_VAR 0 2
33176: PUSH
33177: DOUBLE
33178: LD_INT 1
33180: DEC
33181: ST_TO_ADDR
33182: LD_EXP 49
33186: PUSH
33187: FOR_TO
33188: IFFALSE 34257
// begin tmp := mc_lab [ i ] ;
33190: LD_ADDR_VAR 0 6
33194: PUSH
33195: LD_EXP 82
33199: PUSH
33200: LD_VAR 0 2
33204: ARRAY
33205: ST_TO_ADDR
// if not tmp then
33206: LD_VAR 0 6
33210: NOT
33211: IFFALSE 33215
// continue ;
33213: GO 33187
// idle_lab := 0 ;
33215: LD_ADDR_VAR 0 11
33219: PUSH
33220: LD_INT 0
33222: ST_TO_ADDR
// for j in tmp do
33223: LD_ADDR_VAR 0 3
33227: PUSH
33228: LD_VAR 0 6
33232: PUSH
33233: FOR_IN
33234: IFFALSE 34253
// begin researching := false ;
33236: LD_ADDR_VAR 0 10
33240: PUSH
33241: LD_INT 0
33243: ST_TO_ADDR
// side := GetSide ( j ) ;
33244: LD_ADDR_VAR 0 4
33248: PUSH
33249: LD_VAR 0 3
33253: PPUSH
33254: CALL_OW 255
33258: ST_TO_ADDR
// if not mc_tech [ side ] then
33259: LD_EXP 76
33263: PUSH
33264: LD_VAR 0 4
33268: ARRAY
33269: NOT
33270: IFFALSE 33274
// continue ;
33272: GO 33233
// if BuildingStatus ( j ) = bs_idle then
33274: LD_VAR 0 3
33278: PPUSH
33279: CALL_OW 461
33283: PUSH
33284: LD_INT 2
33286: EQUAL
33287: IFFALSE 33475
// begin if idle_lab and UnitsInside ( j ) < 6 then
33289: LD_VAR 0 11
33293: PUSH
33294: LD_VAR 0 3
33298: PPUSH
33299: CALL_OW 313
33303: PUSH
33304: LD_INT 6
33306: LESS
33307: AND
33308: IFFALSE 33379
// begin tmp2 := UnitsInside ( idle_lab ) ;
33310: LD_ADDR_VAR 0 9
33314: PUSH
33315: LD_VAR 0 11
33319: PPUSH
33320: CALL_OW 313
33324: ST_TO_ADDR
// if tmp2 then
33325: LD_VAR 0 9
33329: IFFALSE 33371
// for x in tmp2 do
33331: LD_ADDR_VAR 0 7
33335: PUSH
33336: LD_VAR 0 9
33340: PUSH
33341: FOR_IN
33342: IFFALSE 33369
// begin ComExitBuilding ( x ) ;
33344: LD_VAR 0 7
33348: PPUSH
33349: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
33353: LD_VAR 0 7
33357: PPUSH
33358: LD_VAR 0 3
33362: PPUSH
33363: CALL_OW 180
// end ;
33367: GO 33341
33369: POP
33370: POP
// idle_lab := 0 ;
33371: LD_ADDR_VAR 0 11
33375: PUSH
33376: LD_INT 0
33378: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
33379: LD_ADDR_VAR 0 5
33383: PUSH
33384: LD_EXP 76
33388: PUSH
33389: LD_VAR 0 4
33393: ARRAY
33394: PUSH
33395: FOR_IN
33396: IFFALSE 33456
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
33398: LD_VAR 0 3
33402: PPUSH
33403: LD_VAR 0 5
33407: PPUSH
33408: CALL_OW 430
33412: PUSH
33413: LD_VAR 0 4
33417: PPUSH
33418: LD_VAR 0 5
33422: PPUSH
33423: CALL 47342 0 2
33427: AND
33428: IFFALSE 33454
// begin researching := true ;
33430: LD_ADDR_VAR 0 10
33434: PUSH
33435: LD_INT 1
33437: ST_TO_ADDR
// ComResearch ( j , t ) ;
33438: LD_VAR 0 3
33442: PPUSH
33443: LD_VAR 0 5
33447: PPUSH
33448: CALL_OW 124
// break ;
33452: GO 33456
// end ;
33454: GO 33395
33456: POP
33457: POP
// if not researching then
33458: LD_VAR 0 10
33462: NOT
33463: IFFALSE 33475
// idle_lab := j ;
33465: LD_ADDR_VAR 0 11
33469: PUSH
33470: LD_VAR 0 3
33474: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
33475: LD_VAR 0 3
33479: PPUSH
33480: CALL_OW 461
33484: PUSH
33485: LD_INT 10
33487: EQUAL
33488: IFFALSE 34076
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
33490: LD_EXP 78
33494: PUSH
33495: LD_VAR 0 2
33499: ARRAY
33500: NOT
33501: PUSH
33502: LD_EXP 79
33506: PUSH
33507: LD_VAR 0 2
33511: ARRAY
33512: NOT
33513: AND
33514: PUSH
33515: LD_EXP 76
33519: PUSH
33520: LD_VAR 0 4
33524: ARRAY
33525: PUSH
33526: LD_INT 1
33528: GREATER
33529: AND
33530: IFFALSE 33661
// begin ComCancel ( j ) ;
33532: LD_VAR 0 3
33536: PPUSH
33537: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
33541: LD_ADDR_EXP 76
33545: PUSH
33546: LD_EXP 76
33550: PPUSH
33551: LD_VAR 0 4
33555: PPUSH
33556: LD_EXP 76
33560: PUSH
33561: LD_VAR 0 4
33565: ARRAY
33566: PPUSH
33567: LD_EXP 76
33571: PUSH
33572: LD_VAR 0 4
33576: ARRAY
33577: PUSH
33578: LD_INT 1
33580: MINUS
33581: PPUSH
33582: LD_EXP 76
33586: PUSH
33587: LD_VAR 0 4
33591: ARRAY
33592: PPUSH
33593: LD_INT 0
33595: PPUSH
33596: CALL 53116 0 4
33600: PPUSH
33601: CALL_OW 1
33605: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
33606: LD_ADDR_EXP 76
33610: PUSH
33611: LD_EXP 76
33615: PPUSH
33616: LD_VAR 0 4
33620: PPUSH
33621: LD_EXP 76
33625: PUSH
33626: LD_VAR 0 4
33630: ARRAY
33631: PPUSH
33632: LD_EXP 76
33636: PUSH
33637: LD_VAR 0 4
33641: ARRAY
33642: PPUSH
33643: LD_INT 1
33645: PPUSH
33646: LD_INT 0
33648: PPUSH
33649: CALL 53116 0 4
33653: PPUSH
33654: CALL_OW 1
33658: ST_TO_ADDR
// continue ;
33659: GO 33233
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
33661: LD_EXP 78
33665: PUSH
33666: LD_VAR 0 2
33670: ARRAY
33671: PUSH
33672: LD_EXP 79
33676: PUSH
33677: LD_VAR 0 2
33681: ARRAY
33682: NOT
33683: AND
33684: IFFALSE 33811
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
33686: LD_ADDR_EXP 79
33690: PUSH
33691: LD_EXP 79
33695: PPUSH
33696: LD_VAR 0 2
33700: PUSH
33701: LD_EXP 79
33705: PUSH
33706: LD_VAR 0 2
33710: ARRAY
33711: PUSH
33712: LD_INT 1
33714: PLUS
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PPUSH
33720: LD_EXP 78
33724: PUSH
33725: LD_VAR 0 2
33729: ARRAY
33730: PUSH
33731: LD_INT 1
33733: ARRAY
33734: PPUSH
33735: CALL 53698 0 3
33739: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
33740: LD_EXP 78
33744: PUSH
33745: LD_VAR 0 2
33749: ARRAY
33750: PUSH
33751: LD_INT 1
33753: ARRAY
33754: PPUSH
33755: LD_INT 112
33757: PPUSH
33758: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
33762: LD_ADDR_VAR 0 9
33766: PUSH
33767: LD_EXP 78
33771: PUSH
33772: LD_VAR 0 2
33776: ARRAY
33777: PPUSH
33778: LD_INT 1
33780: PPUSH
33781: CALL_OW 3
33785: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
33786: LD_ADDR_EXP 78
33790: PUSH
33791: LD_EXP 78
33795: PPUSH
33796: LD_VAR 0 2
33800: PPUSH
33801: LD_VAR 0 9
33805: PPUSH
33806: CALL_OW 1
33810: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
33811: LD_EXP 78
33815: PUSH
33816: LD_VAR 0 2
33820: ARRAY
33821: PUSH
33822: LD_EXP 79
33826: PUSH
33827: LD_VAR 0 2
33831: ARRAY
33832: AND
33833: PUSH
33834: LD_EXP 79
33838: PUSH
33839: LD_VAR 0 2
33843: ARRAY
33844: PUSH
33845: LD_INT 1
33847: ARRAY
33848: PPUSH
33849: CALL_OW 310
33853: NOT
33854: AND
33855: PUSH
33856: LD_VAR 0 3
33860: PPUSH
33861: CALL_OW 313
33865: PUSH
33866: LD_INT 6
33868: EQUAL
33869: AND
33870: IFFALSE 33926
// begin tmp2 := UnitsInside ( j ) ;
33872: LD_ADDR_VAR 0 9
33876: PUSH
33877: LD_VAR 0 3
33881: PPUSH
33882: CALL_OW 313
33886: ST_TO_ADDR
// if tmp2 = 6 then
33887: LD_VAR 0 9
33891: PUSH
33892: LD_INT 6
33894: EQUAL
33895: IFFALSE 33926
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
33897: LD_VAR 0 9
33901: PUSH
33902: LD_INT 1
33904: ARRAY
33905: PPUSH
33906: LD_INT 112
33908: PPUSH
33909: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
33913: LD_VAR 0 9
33917: PUSH
33918: LD_INT 1
33920: ARRAY
33921: PPUSH
33922: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
33926: LD_EXP 79
33930: PUSH
33931: LD_VAR 0 2
33935: ARRAY
33936: PUSH
33937: LD_EXP 79
33941: PUSH
33942: LD_VAR 0 2
33946: ARRAY
33947: PUSH
33948: LD_INT 1
33950: ARRAY
33951: PPUSH
33952: CALL_OW 314
33956: NOT
33957: AND
33958: PUSH
33959: LD_EXP 79
33963: PUSH
33964: LD_VAR 0 2
33968: ARRAY
33969: PUSH
33970: LD_INT 1
33972: ARRAY
33973: PPUSH
33974: CALL_OW 310
33978: NOT
33979: AND
33980: IFFALSE 34006
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
33982: LD_EXP 79
33986: PUSH
33987: LD_VAR 0 2
33991: ARRAY
33992: PUSH
33993: LD_INT 1
33995: ARRAY
33996: PPUSH
33997: LD_VAR 0 3
34001: PPUSH
34002: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34006: LD_EXP 79
34010: PUSH
34011: LD_VAR 0 2
34015: ARRAY
34016: PUSH
34017: LD_INT 1
34019: ARRAY
34020: PPUSH
34021: CALL_OW 310
34025: PUSH
34026: LD_EXP 79
34030: PUSH
34031: LD_VAR 0 2
34035: ARRAY
34036: PUSH
34037: LD_INT 1
34039: ARRAY
34040: PPUSH
34041: CALL_OW 310
34045: PPUSH
34046: CALL_OW 461
34050: PUSH
34051: LD_INT 3
34053: NONEQUAL
34054: AND
34055: IFFALSE 34076
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
34057: LD_EXP 79
34061: PUSH
34062: LD_VAR 0 2
34066: ARRAY
34067: PUSH
34068: LD_INT 1
34070: ARRAY
34071: PPUSH
34072: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
34076: LD_VAR 0 3
34080: PPUSH
34081: CALL_OW 461
34085: PUSH
34086: LD_INT 6
34088: EQUAL
34089: PUSH
34090: LD_VAR 0 6
34094: PUSH
34095: LD_INT 1
34097: GREATER
34098: AND
34099: IFFALSE 34251
// begin sci := [ ] ;
34101: LD_ADDR_VAR 0 8
34105: PUSH
34106: EMPTY
34107: ST_TO_ADDR
// for x in ( tmp diff j ) do
34108: LD_ADDR_VAR 0 7
34112: PUSH
34113: LD_VAR 0 6
34117: PUSH
34118: LD_VAR 0 3
34122: DIFF
34123: PUSH
34124: FOR_IN
34125: IFFALSE 34177
// begin if sci = 6 then
34127: LD_VAR 0 8
34131: PUSH
34132: LD_INT 6
34134: EQUAL
34135: IFFALSE 34139
// break ;
34137: GO 34177
// if BuildingStatus ( x ) = bs_idle then
34139: LD_VAR 0 7
34143: PPUSH
34144: CALL_OW 461
34148: PUSH
34149: LD_INT 2
34151: EQUAL
34152: IFFALSE 34175
// sci := sci ^ UnitsInside ( x ) ;
34154: LD_ADDR_VAR 0 8
34158: PUSH
34159: LD_VAR 0 8
34163: PUSH
34164: LD_VAR 0 7
34168: PPUSH
34169: CALL_OW 313
34173: ADD
34174: ST_TO_ADDR
// end ;
34175: GO 34124
34177: POP
34178: POP
// if not sci then
34179: LD_VAR 0 8
34183: NOT
34184: IFFALSE 34188
// continue ;
34186: GO 33233
// for x in sci do
34188: LD_ADDR_VAR 0 7
34192: PUSH
34193: LD_VAR 0 8
34197: PUSH
34198: FOR_IN
34199: IFFALSE 34249
// if IsInUnit ( x ) and not HasTask ( x ) then
34201: LD_VAR 0 7
34205: PPUSH
34206: CALL_OW 310
34210: PUSH
34211: LD_VAR 0 7
34215: PPUSH
34216: CALL_OW 314
34220: NOT
34221: AND
34222: IFFALSE 34247
// begin ComExitBuilding ( x ) ;
34224: LD_VAR 0 7
34228: PPUSH
34229: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34233: LD_VAR 0 7
34237: PPUSH
34238: LD_VAR 0 3
34242: PPUSH
34243: CALL_OW 180
// end ;
34247: GO 34198
34249: POP
34250: POP
// end ; end ;
34251: GO 33233
34253: POP
34254: POP
// end ;
34255: GO 33187
34257: POP
34258: POP
// end ;
34259: LD_VAR 0 1
34263: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
34264: LD_INT 0
34266: PPUSH
34267: PPUSH
// if not mc_bases then
34268: LD_EXP 49
34272: NOT
34273: IFFALSE 34277
// exit ;
34275: GO 34358
// for i = 1 to mc_bases do
34277: LD_ADDR_VAR 0 2
34281: PUSH
34282: DOUBLE
34283: LD_INT 1
34285: DEC
34286: ST_TO_ADDR
34287: LD_EXP 49
34291: PUSH
34292: FOR_TO
34293: IFFALSE 34356
// if mc_mines [ i ] and mc_miners [ i ] then
34295: LD_EXP 62
34299: PUSH
34300: LD_VAR 0 2
34304: ARRAY
34305: PUSH
34306: LD_EXP 63
34310: PUSH
34311: LD_VAR 0 2
34315: ARRAY
34316: AND
34317: IFFALSE 34354
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
34319: LD_EXP 63
34323: PUSH
34324: LD_VAR 0 2
34328: ARRAY
34329: PUSH
34330: LD_INT 1
34332: ARRAY
34333: PPUSH
34334: CALL_OW 255
34338: PPUSH
34339: LD_EXP 62
34343: PUSH
34344: LD_VAR 0 2
34348: ARRAY
34349: PPUSH
34350: CALL 50687 0 2
34354: GO 34292
34356: POP
34357: POP
// end ;
34358: LD_VAR 0 1
34362: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
34363: LD_INT 0
34365: PPUSH
34366: PPUSH
34367: PPUSH
34368: PPUSH
34369: PPUSH
34370: PPUSH
34371: PPUSH
34372: PPUSH
// if not mc_bases or not mc_parking then
34373: LD_EXP 49
34377: NOT
34378: PUSH
34379: LD_EXP 73
34383: NOT
34384: OR
34385: IFFALSE 34389
// exit ;
34387: GO 35088
// for i = 1 to mc_bases do
34389: LD_ADDR_VAR 0 2
34393: PUSH
34394: DOUBLE
34395: LD_INT 1
34397: DEC
34398: ST_TO_ADDR
34399: LD_EXP 49
34403: PUSH
34404: FOR_TO
34405: IFFALSE 35086
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
34407: LD_EXP 49
34411: PUSH
34412: LD_VAR 0 2
34416: ARRAY
34417: NOT
34418: PUSH
34419: LD_EXP 73
34423: PUSH
34424: LD_VAR 0 2
34428: ARRAY
34429: NOT
34430: OR
34431: IFFALSE 34435
// continue ;
34433: GO 34404
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34435: LD_ADDR_VAR 0 5
34439: PUSH
34440: LD_EXP 49
34444: PUSH
34445: LD_VAR 0 2
34449: ARRAY
34450: PUSH
34451: LD_INT 1
34453: ARRAY
34454: PPUSH
34455: CALL_OW 255
34459: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34460: LD_ADDR_VAR 0 6
34464: PUSH
34465: LD_EXP 49
34469: PUSH
34470: LD_VAR 0 2
34474: ARRAY
34475: PPUSH
34476: LD_INT 30
34478: PUSH
34479: LD_INT 3
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PPUSH
34486: CALL_OW 72
34490: ST_TO_ADDR
// if not fac then
34491: LD_VAR 0 6
34495: NOT
34496: IFFALSE 34547
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34498: LD_ADDR_VAR 0 6
34502: PUSH
34503: LD_EXP 49
34507: PUSH
34508: LD_VAR 0 2
34512: ARRAY
34513: PPUSH
34514: LD_INT 2
34516: PUSH
34517: LD_INT 30
34519: PUSH
34520: LD_INT 0
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 30
34529: PUSH
34530: LD_INT 1
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: LIST
34541: PPUSH
34542: CALL_OW 72
34546: ST_TO_ADDR
// if not fac then
34547: LD_VAR 0 6
34551: NOT
34552: IFFALSE 34556
// continue ;
34554: GO 34404
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34556: LD_ADDR_VAR 0 7
34560: PUSH
34561: LD_EXP 73
34565: PUSH
34566: LD_VAR 0 2
34570: ARRAY
34571: PPUSH
34572: LD_INT 22
34574: PUSH
34575: LD_VAR 0 5
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 21
34586: PUSH
34587: LD_INT 2
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 3
34596: PUSH
34597: LD_INT 24
34599: PUSH
34600: LD_INT 1000
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: LIST
34615: PPUSH
34616: CALL_OW 70
34620: ST_TO_ADDR
// for j in fac do
34621: LD_ADDR_VAR 0 3
34625: PUSH
34626: LD_VAR 0 6
34630: PUSH
34631: FOR_IN
34632: IFFALSE 34713
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34634: LD_ADDR_VAR 0 7
34638: PUSH
34639: LD_VAR 0 7
34643: PUSH
34644: LD_INT 22
34646: PUSH
34647: LD_VAR 0 5
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 91
34658: PUSH
34659: LD_VAR 0 3
34663: PUSH
34664: LD_INT 15
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 21
34674: PUSH
34675: LD_INT 2
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 3
34684: PUSH
34685: LD_INT 24
34687: PUSH
34688: LD_INT 1000
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PUSH
34695: EMPTY
34696: LIST
34697: LIST
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: PPUSH
34705: CALL_OW 69
34709: UNION
34710: ST_TO_ADDR
34711: GO 34631
34713: POP
34714: POP
// if not vehs then
34715: LD_VAR 0 7
34719: NOT
34720: IFFALSE 34746
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
34722: LD_ADDR_EXP 61
34726: PUSH
34727: LD_EXP 61
34731: PPUSH
34732: LD_VAR 0 2
34736: PPUSH
34737: EMPTY
34738: PPUSH
34739: CALL_OW 1
34743: ST_TO_ADDR
// continue ;
34744: GO 34404
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34746: LD_ADDR_VAR 0 8
34750: PUSH
34751: LD_EXP 49
34755: PUSH
34756: LD_VAR 0 2
34760: ARRAY
34761: PPUSH
34762: LD_INT 30
34764: PUSH
34765: LD_INT 3
34767: PUSH
34768: EMPTY
34769: LIST
34770: LIST
34771: PPUSH
34772: CALL_OW 72
34776: ST_TO_ADDR
// if tmp then
34777: LD_VAR 0 8
34781: IFFALSE 34884
// begin for j in tmp do
34783: LD_ADDR_VAR 0 3
34787: PUSH
34788: LD_VAR 0 8
34792: PUSH
34793: FOR_IN
34794: IFFALSE 34882
// for k in UnitsInside ( j ) do
34796: LD_ADDR_VAR 0 4
34800: PUSH
34801: LD_VAR 0 3
34805: PPUSH
34806: CALL_OW 313
34810: PUSH
34811: FOR_IN
34812: IFFALSE 34878
// if k then
34814: LD_VAR 0 4
34818: IFFALSE 34876
// if not k in mc_repair_vehicle [ i ] then
34820: LD_VAR 0 4
34824: PUSH
34825: LD_EXP 61
34829: PUSH
34830: LD_VAR 0 2
34834: ARRAY
34835: IN
34836: NOT
34837: IFFALSE 34876
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
34839: LD_ADDR_EXP 61
34843: PUSH
34844: LD_EXP 61
34848: PPUSH
34849: LD_VAR 0 2
34853: PPUSH
34854: LD_EXP 61
34858: PUSH
34859: LD_VAR 0 2
34863: ARRAY
34864: PUSH
34865: LD_VAR 0 4
34869: UNION
34870: PPUSH
34871: CALL_OW 1
34875: ST_TO_ADDR
34876: GO 34811
34878: POP
34879: POP
34880: GO 34793
34882: POP
34883: POP
// end ; if not mc_repair_vehicle [ i ] then
34884: LD_EXP 61
34888: PUSH
34889: LD_VAR 0 2
34893: ARRAY
34894: NOT
34895: IFFALSE 34899
// continue ;
34897: GO 34404
// for j in mc_repair_vehicle [ i ] do
34899: LD_ADDR_VAR 0 3
34903: PUSH
34904: LD_EXP 61
34908: PUSH
34909: LD_VAR 0 2
34913: ARRAY
34914: PUSH
34915: FOR_IN
34916: IFFALSE 35082
// begin if GetClass ( j ) <> 3 then
34918: LD_VAR 0 3
34922: PPUSH
34923: CALL_OW 257
34927: PUSH
34928: LD_INT 3
34930: NONEQUAL
34931: IFFALSE 34972
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
34933: LD_ADDR_EXP 61
34937: PUSH
34938: LD_EXP 61
34942: PPUSH
34943: LD_VAR 0 2
34947: PPUSH
34948: LD_EXP 61
34952: PUSH
34953: LD_VAR 0 2
34957: ARRAY
34958: PUSH
34959: LD_VAR 0 3
34963: DIFF
34964: PPUSH
34965: CALL_OW 1
34969: ST_TO_ADDR
// continue ;
34970: GO 34915
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
34972: LD_VAR 0 3
34976: PPUSH
34977: CALL_OW 311
34981: NOT
34982: PUSH
34983: LD_VAR 0 3
34987: PUSH
34988: LD_EXP 52
34992: PUSH
34993: LD_VAR 0 2
34997: ARRAY
34998: PUSH
34999: LD_INT 1
35001: ARRAY
35002: IN
35003: NOT
35004: AND
35005: PUSH
35006: LD_VAR 0 3
35010: PUSH
35011: LD_EXP 52
35015: PUSH
35016: LD_VAR 0 2
35020: ARRAY
35021: PUSH
35022: LD_INT 2
35024: ARRAY
35025: IN
35026: NOT
35027: AND
35028: IFFALSE 35080
// begin if IsInUnit ( j ) then
35030: LD_VAR 0 3
35034: PPUSH
35035: CALL_OW 310
35039: IFFALSE 35050
// ComExitBuilding ( j ) ;
35041: LD_VAR 0 3
35045: PPUSH
35046: CALL_OW 122
// if not HasTask ( j ) then
35050: LD_VAR 0 3
35054: PPUSH
35055: CALL_OW 314
35059: NOT
35060: IFFALSE 35080
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
35062: LD_VAR 0 3
35066: PPUSH
35067: LD_VAR 0 7
35071: PUSH
35072: LD_INT 1
35074: ARRAY
35075: PPUSH
35076: CALL_OW 189
// end ; end ;
35080: GO 34915
35082: POP
35083: POP
// end ;
35084: GO 34404
35086: POP
35087: POP
// end ;
35088: LD_VAR 0 1
35092: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
35093: LD_INT 0
35095: PPUSH
35096: PPUSH
35097: PPUSH
35098: PPUSH
35099: PPUSH
35100: PPUSH
35101: PPUSH
35102: PPUSH
35103: PPUSH
35104: PPUSH
35105: PPUSH
// if not mc_bases then
35106: LD_EXP 49
35110: NOT
35111: IFFALSE 35115
// exit ;
35113: GO 35917
// for i = 1 to mc_bases do
35115: LD_ADDR_VAR 0 2
35119: PUSH
35120: DOUBLE
35121: LD_INT 1
35123: DEC
35124: ST_TO_ADDR
35125: LD_EXP 49
35129: PUSH
35130: FOR_TO
35131: IFFALSE 35915
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
35133: LD_EXP 77
35137: PUSH
35138: LD_VAR 0 2
35142: ARRAY
35143: NOT
35144: PUSH
35145: LD_EXP 52
35149: PUSH
35150: LD_VAR 0 2
35154: ARRAY
35155: PUSH
35156: LD_INT 1
35158: ARRAY
35159: OR
35160: PUSH
35161: LD_EXP 52
35165: PUSH
35166: LD_VAR 0 2
35170: ARRAY
35171: PUSH
35172: LD_INT 2
35174: ARRAY
35175: OR
35176: PUSH
35177: LD_EXP 75
35181: PUSH
35182: LD_VAR 0 2
35186: ARRAY
35187: PPUSH
35188: LD_INT 1
35190: PPUSH
35191: CALL_OW 325
35195: NOT
35196: OR
35197: PUSH
35198: LD_EXP 72
35202: PUSH
35203: LD_VAR 0 2
35207: ARRAY
35208: OR
35209: IFFALSE 35213
// continue ;
35211: GO 35130
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
35213: LD_ADDR_VAR 0 8
35217: PUSH
35218: LD_EXP 49
35222: PUSH
35223: LD_VAR 0 2
35227: ARRAY
35228: PPUSH
35229: LD_INT 25
35231: PUSH
35232: LD_INT 4
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: PUSH
35239: LD_INT 50
35241: PUSH
35242: EMPTY
35243: LIST
35244: PUSH
35245: LD_INT 3
35247: PUSH
35248: LD_INT 60
35250: PUSH
35251: EMPTY
35252: LIST
35253: PUSH
35254: EMPTY
35255: LIST
35256: LIST
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: LIST
35262: PPUSH
35263: CALL_OW 72
35267: PUSH
35268: LD_EXP 53
35272: PUSH
35273: LD_VAR 0 2
35277: ARRAY
35278: DIFF
35279: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35280: LD_ADDR_VAR 0 9
35284: PUSH
35285: LD_EXP 49
35289: PUSH
35290: LD_VAR 0 2
35294: ARRAY
35295: PPUSH
35296: LD_INT 2
35298: PUSH
35299: LD_INT 30
35301: PUSH
35302: LD_INT 0
35304: PUSH
35305: EMPTY
35306: LIST
35307: LIST
35308: PUSH
35309: LD_INT 30
35311: PUSH
35312: LD_INT 1
35314: PUSH
35315: EMPTY
35316: LIST
35317: LIST
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: LIST
35323: PPUSH
35324: CALL_OW 72
35328: ST_TO_ADDR
// if not tmp or not dep then
35329: LD_VAR 0 8
35333: NOT
35334: PUSH
35335: LD_VAR 0 9
35339: NOT
35340: OR
35341: IFFALSE 35345
// continue ;
35343: GO 35130
// side := GetSide ( tmp [ 1 ] ) ;
35345: LD_ADDR_VAR 0 11
35349: PUSH
35350: LD_VAR 0 8
35354: PUSH
35355: LD_INT 1
35357: ARRAY
35358: PPUSH
35359: CALL_OW 255
35363: ST_TO_ADDR
// dep := dep [ 1 ] ;
35364: LD_ADDR_VAR 0 9
35368: PUSH
35369: LD_VAR 0 9
35373: PUSH
35374: LD_INT 1
35376: ARRAY
35377: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
35378: LD_ADDR_VAR 0 7
35382: PUSH
35383: LD_EXP 77
35387: PUSH
35388: LD_VAR 0 2
35392: ARRAY
35393: PPUSH
35394: LD_INT 22
35396: PUSH
35397: LD_INT 0
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: LD_INT 25
35406: PUSH
35407: LD_INT 12
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PPUSH
35418: CALL_OW 70
35422: PUSH
35423: LD_INT 22
35425: PUSH
35426: LD_INT 0
35428: PUSH
35429: EMPTY
35430: LIST
35431: LIST
35432: PUSH
35433: LD_INT 25
35435: PUSH
35436: LD_INT 12
35438: PUSH
35439: EMPTY
35440: LIST
35441: LIST
35442: PUSH
35443: LD_INT 91
35445: PUSH
35446: LD_VAR 0 9
35450: PUSH
35451: LD_INT 20
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: LIST
35458: PUSH
35459: EMPTY
35460: LIST
35461: LIST
35462: LIST
35463: PPUSH
35464: CALL_OW 69
35468: UNION
35469: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
35470: LD_ADDR_VAR 0 10
35474: PUSH
35475: LD_EXP 77
35479: PUSH
35480: LD_VAR 0 2
35484: ARRAY
35485: PPUSH
35486: LD_INT 81
35488: PUSH
35489: LD_VAR 0 11
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: PPUSH
35498: CALL_OW 70
35502: ST_TO_ADDR
// if not apes or danger_at_area then
35503: LD_VAR 0 7
35507: NOT
35508: PUSH
35509: LD_VAR 0 10
35513: OR
35514: IFFALSE 35564
// begin if mc_taming [ i ] then
35516: LD_EXP 80
35520: PUSH
35521: LD_VAR 0 2
35525: ARRAY
35526: IFFALSE 35562
// begin MC_Reset ( i , 121 ) ;
35528: LD_VAR 0 2
35532: PPUSH
35533: LD_INT 121
35535: PPUSH
35536: CALL 20895 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
35540: LD_ADDR_EXP 80
35544: PUSH
35545: LD_EXP 80
35549: PPUSH
35550: LD_VAR 0 2
35554: PPUSH
35555: EMPTY
35556: PPUSH
35557: CALL_OW 1
35561: ST_TO_ADDR
// end ; continue ;
35562: GO 35130
// end ; for j in tmp do
35564: LD_ADDR_VAR 0 3
35568: PUSH
35569: LD_VAR 0 8
35573: PUSH
35574: FOR_IN
35575: IFFALSE 35911
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
35577: LD_VAR 0 3
35581: PUSH
35582: LD_EXP 80
35586: PUSH
35587: LD_VAR 0 2
35591: ARRAY
35592: IN
35593: NOT
35594: PUSH
35595: LD_EXP 80
35599: PUSH
35600: LD_VAR 0 2
35604: ARRAY
35605: PUSH
35606: LD_INT 3
35608: LESS
35609: AND
35610: IFFALSE 35668
// begin SetTag ( j , 121 ) ;
35612: LD_VAR 0 3
35616: PPUSH
35617: LD_INT 121
35619: PPUSH
35620: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
35624: LD_ADDR_EXP 80
35628: PUSH
35629: LD_EXP 80
35633: PPUSH
35634: LD_VAR 0 2
35638: PUSH
35639: LD_EXP 80
35643: PUSH
35644: LD_VAR 0 2
35648: ARRAY
35649: PUSH
35650: LD_INT 1
35652: PLUS
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PPUSH
35658: LD_VAR 0 3
35662: PPUSH
35663: CALL 53698 0 3
35667: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
35668: LD_VAR 0 3
35672: PUSH
35673: LD_EXP 80
35677: PUSH
35678: LD_VAR 0 2
35682: ARRAY
35683: IN
35684: IFFALSE 35909
// begin if GetClass ( j ) <> 4 then
35686: LD_VAR 0 3
35690: PPUSH
35691: CALL_OW 257
35695: PUSH
35696: LD_INT 4
35698: NONEQUAL
35699: IFFALSE 35752
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
35701: LD_ADDR_EXP 80
35705: PUSH
35706: LD_EXP 80
35710: PPUSH
35711: LD_VAR 0 2
35715: PPUSH
35716: LD_EXP 80
35720: PUSH
35721: LD_VAR 0 2
35725: ARRAY
35726: PUSH
35727: LD_VAR 0 3
35731: DIFF
35732: PPUSH
35733: CALL_OW 1
35737: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35738: LD_VAR 0 3
35742: PPUSH
35743: LD_INT 0
35745: PPUSH
35746: CALL_OW 109
// continue ;
35750: GO 35574
// end ; if IsInUnit ( j ) then
35752: LD_VAR 0 3
35756: PPUSH
35757: CALL_OW 310
35761: IFFALSE 35772
// ComExitBuilding ( j ) ;
35763: LD_VAR 0 3
35767: PPUSH
35768: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
35772: LD_ADDR_VAR 0 6
35776: PUSH
35777: LD_VAR 0 7
35781: PPUSH
35782: LD_VAR 0 3
35786: PPUSH
35787: CALL_OW 74
35791: ST_TO_ADDR
// if not ape then
35792: LD_VAR 0 6
35796: NOT
35797: IFFALSE 35801
// break ;
35799: GO 35911
// x := GetX ( ape ) ;
35801: LD_ADDR_VAR 0 4
35805: PUSH
35806: LD_VAR 0 6
35810: PPUSH
35811: CALL_OW 250
35815: ST_TO_ADDR
// y := GetY ( ape ) ;
35816: LD_ADDR_VAR 0 5
35820: PUSH
35821: LD_VAR 0 6
35825: PPUSH
35826: CALL_OW 251
35830: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
35831: LD_VAR 0 4
35835: PPUSH
35836: LD_VAR 0 5
35840: PPUSH
35841: CALL_OW 488
35845: NOT
35846: PUSH
35847: LD_VAR 0 11
35851: PPUSH
35852: LD_VAR 0 4
35856: PPUSH
35857: LD_VAR 0 5
35861: PPUSH
35862: LD_INT 20
35864: PPUSH
35865: CALL 54594 0 4
35869: PUSH
35870: LD_INT 4
35872: ARRAY
35873: OR
35874: IFFALSE 35878
// break ;
35876: GO 35911
// if not HasTask ( j ) then
35878: LD_VAR 0 3
35882: PPUSH
35883: CALL_OW 314
35887: NOT
35888: IFFALSE 35909
// ComTameXY ( j , x , y ) ;
35890: LD_VAR 0 3
35894: PPUSH
35895: LD_VAR 0 4
35899: PPUSH
35900: LD_VAR 0 5
35904: PPUSH
35905: CALL_OW 131
// end ; end ;
35909: GO 35574
35911: POP
35912: POP
// end ;
35913: GO 35130
35915: POP
35916: POP
// end ;
35917: LD_VAR 0 1
35921: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
35922: LD_INT 0
35924: PPUSH
35925: PPUSH
35926: PPUSH
35927: PPUSH
35928: PPUSH
35929: PPUSH
35930: PPUSH
35931: PPUSH
// if not mc_bases then
35932: LD_EXP 49
35936: NOT
35937: IFFALSE 35941
// exit ;
35939: GO 36567
// for i = 1 to mc_bases do
35941: LD_ADDR_VAR 0 2
35945: PUSH
35946: DOUBLE
35947: LD_INT 1
35949: DEC
35950: ST_TO_ADDR
35951: LD_EXP 49
35955: PUSH
35956: FOR_TO
35957: IFFALSE 36565
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
35959: LD_EXP 78
35963: PUSH
35964: LD_VAR 0 2
35968: ARRAY
35969: NOT
35970: PUSH
35971: LD_EXP 78
35975: PUSH
35976: LD_VAR 0 2
35980: ARRAY
35981: PPUSH
35982: LD_INT 25
35984: PUSH
35985: LD_INT 12
35987: PUSH
35988: EMPTY
35989: LIST
35990: LIST
35991: PPUSH
35992: CALL_OW 72
35996: NOT
35997: OR
35998: IFFALSE 36002
// continue ;
36000: GO 35956
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36002: LD_ADDR_VAR 0 5
36006: PUSH
36007: LD_EXP 78
36011: PUSH
36012: LD_VAR 0 2
36016: ARRAY
36017: PUSH
36018: LD_INT 1
36020: ARRAY
36021: PPUSH
36022: CALL_OW 255
36026: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
36027: LD_VAR 0 5
36031: PPUSH
36032: LD_INT 2
36034: PPUSH
36035: CALL_OW 325
36039: IFFALSE 36292
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36041: LD_ADDR_VAR 0 4
36045: PUSH
36046: LD_EXP 78
36050: PUSH
36051: LD_VAR 0 2
36055: ARRAY
36056: PPUSH
36057: LD_INT 25
36059: PUSH
36060: LD_INT 16
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PPUSH
36067: CALL_OW 72
36071: ST_TO_ADDR
// if tmp < 6 then
36072: LD_VAR 0 4
36076: PUSH
36077: LD_INT 6
36079: LESS
36080: IFFALSE 36292
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36082: LD_ADDR_VAR 0 6
36086: PUSH
36087: LD_EXP 49
36091: PUSH
36092: LD_VAR 0 2
36096: ARRAY
36097: PPUSH
36098: LD_INT 2
36100: PUSH
36101: LD_INT 30
36103: PUSH
36104: LD_INT 0
36106: PUSH
36107: EMPTY
36108: LIST
36109: LIST
36110: PUSH
36111: LD_INT 30
36113: PUSH
36114: LD_INT 1
36116: PUSH
36117: EMPTY
36118: LIST
36119: LIST
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: LIST
36125: PPUSH
36126: CALL_OW 72
36130: ST_TO_ADDR
// if depot then
36131: LD_VAR 0 6
36135: IFFALSE 36292
// begin selected := 0 ;
36137: LD_ADDR_VAR 0 7
36141: PUSH
36142: LD_INT 0
36144: ST_TO_ADDR
// for j in depot do
36145: LD_ADDR_VAR 0 3
36149: PUSH
36150: LD_VAR 0 6
36154: PUSH
36155: FOR_IN
36156: IFFALSE 36187
// begin if UnitsInside ( j ) < 6 then
36158: LD_VAR 0 3
36162: PPUSH
36163: CALL_OW 313
36167: PUSH
36168: LD_INT 6
36170: LESS
36171: IFFALSE 36185
// begin selected := j ;
36173: LD_ADDR_VAR 0 7
36177: PUSH
36178: LD_VAR 0 3
36182: ST_TO_ADDR
// break ;
36183: GO 36187
// end ; end ;
36185: GO 36155
36187: POP
36188: POP
// if selected then
36189: LD_VAR 0 7
36193: IFFALSE 36292
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36195: LD_ADDR_VAR 0 3
36199: PUSH
36200: LD_EXP 78
36204: PUSH
36205: LD_VAR 0 2
36209: ARRAY
36210: PPUSH
36211: LD_INT 25
36213: PUSH
36214: LD_INT 12
36216: PUSH
36217: EMPTY
36218: LIST
36219: LIST
36220: PPUSH
36221: CALL_OW 72
36225: PUSH
36226: FOR_IN
36227: IFFALSE 36290
// if not HasTask ( j ) then
36229: LD_VAR 0 3
36233: PPUSH
36234: CALL_OW 314
36238: NOT
36239: IFFALSE 36288
// begin if not IsInUnit ( j ) then
36241: LD_VAR 0 3
36245: PPUSH
36246: CALL_OW 310
36250: NOT
36251: IFFALSE 36267
// ComEnterUnit ( j , selected ) ;
36253: LD_VAR 0 3
36257: PPUSH
36258: LD_VAR 0 7
36262: PPUSH
36263: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
36267: LD_VAR 0 3
36271: PPUSH
36272: LD_INT 16
36274: PPUSH
36275: CALL_OW 183
// AddComExitBuilding ( j ) ;
36279: LD_VAR 0 3
36283: PPUSH
36284: CALL_OW 182
// end ;
36288: GO 36226
36290: POP
36291: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
36292: LD_VAR 0 5
36296: PPUSH
36297: LD_INT 11
36299: PPUSH
36300: CALL_OW 325
36304: IFFALSE 36563
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36306: LD_ADDR_VAR 0 4
36310: PUSH
36311: LD_EXP 78
36315: PUSH
36316: LD_VAR 0 2
36320: ARRAY
36321: PPUSH
36322: LD_INT 25
36324: PUSH
36325: LD_INT 16
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PPUSH
36332: CALL_OW 72
36336: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
36337: LD_VAR 0 4
36341: PUSH
36342: LD_INT 6
36344: GREATEREQUAL
36345: PUSH
36346: LD_VAR 0 5
36350: PPUSH
36351: LD_INT 2
36353: PPUSH
36354: CALL_OW 325
36358: NOT
36359: OR
36360: IFFALSE 36563
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
36362: LD_ADDR_VAR 0 8
36366: PUSH
36367: LD_EXP 49
36371: PUSH
36372: LD_VAR 0 2
36376: ARRAY
36377: PPUSH
36378: LD_INT 2
36380: PUSH
36381: LD_INT 30
36383: PUSH
36384: LD_INT 4
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: PUSH
36391: LD_INT 30
36393: PUSH
36394: LD_INT 5
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: LIST
36405: PPUSH
36406: CALL_OW 72
36410: ST_TO_ADDR
// if barracks then
36411: LD_VAR 0 8
36415: IFFALSE 36563
// begin selected := 0 ;
36417: LD_ADDR_VAR 0 7
36421: PUSH
36422: LD_INT 0
36424: ST_TO_ADDR
// for j in barracks do
36425: LD_ADDR_VAR 0 3
36429: PUSH
36430: LD_VAR 0 8
36434: PUSH
36435: FOR_IN
36436: IFFALSE 36467
// begin if UnitsInside ( j ) < 6 then
36438: LD_VAR 0 3
36442: PPUSH
36443: CALL_OW 313
36447: PUSH
36448: LD_INT 6
36450: LESS
36451: IFFALSE 36465
// begin selected := j ;
36453: LD_ADDR_VAR 0 7
36457: PUSH
36458: LD_VAR 0 3
36462: ST_TO_ADDR
// break ;
36463: GO 36467
// end ; end ;
36465: GO 36435
36467: POP
36468: POP
// if selected then
36469: LD_VAR 0 7
36473: IFFALSE 36563
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36475: LD_ADDR_VAR 0 3
36479: PUSH
36480: LD_EXP 78
36484: PUSH
36485: LD_VAR 0 2
36489: ARRAY
36490: PPUSH
36491: LD_INT 25
36493: PUSH
36494: LD_INT 12
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PPUSH
36501: CALL_OW 72
36505: PUSH
36506: FOR_IN
36507: IFFALSE 36561
// if not IsInUnit ( j ) and not HasTask ( j ) then
36509: LD_VAR 0 3
36513: PPUSH
36514: CALL_OW 310
36518: NOT
36519: PUSH
36520: LD_VAR 0 3
36524: PPUSH
36525: CALL_OW 314
36529: NOT
36530: AND
36531: IFFALSE 36559
// begin ComEnterUnit ( j , selected ) ;
36533: LD_VAR 0 3
36537: PPUSH
36538: LD_VAR 0 7
36542: PPUSH
36543: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
36547: LD_VAR 0 3
36551: PPUSH
36552: LD_INT 15
36554: PPUSH
36555: CALL_OW 183
// end ;
36559: GO 36506
36561: POP
36562: POP
// end ; end ; end ; end ; end ;
36563: GO 35956
36565: POP
36566: POP
// end ;
36567: LD_VAR 0 1
36571: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
36572: LD_INT 0
36574: PPUSH
36575: PPUSH
36576: PPUSH
36577: PPUSH
// if not mc_bases then
36578: LD_EXP 49
36582: NOT
36583: IFFALSE 36587
// exit ;
36585: GO 36765
// for i = 1 to mc_bases do
36587: LD_ADDR_VAR 0 2
36591: PUSH
36592: DOUBLE
36593: LD_INT 1
36595: DEC
36596: ST_TO_ADDR
36597: LD_EXP 49
36601: PUSH
36602: FOR_TO
36603: IFFALSE 36763
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
36605: LD_ADDR_VAR 0 4
36609: PUSH
36610: LD_EXP 49
36614: PUSH
36615: LD_VAR 0 2
36619: ARRAY
36620: PPUSH
36621: LD_INT 25
36623: PUSH
36624: LD_INT 9
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PPUSH
36631: CALL_OW 72
36635: ST_TO_ADDR
// if not tmp then
36636: LD_VAR 0 4
36640: NOT
36641: IFFALSE 36645
// continue ;
36643: GO 36602
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
36645: LD_EXP 75
36649: PUSH
36650: LD_VAR 0 2
36654: ARRAY
36655: PPUSH
36656: LD_INT 29
36658: PPUSH
36659: CALL_OW 325
36663: NOT
36664: PUSH
36665: LD_EXP 75
36669: PUSH
36670: LD_VAR 0 2
36674: ARRAY
36675: PPUSH
36676: LD_INT 28
36678: PPUSH
36679: CALL_OW 325
36683: NOT
36684: AND
36685: IFFALSE 36689
// continue ;
36687: GO 36602
// for j in tmp do
36689: LD_ADDR_VAR 0 3
36693: PUSH
36694: LD_VAR 0 4
36698: PUSH
36699: FOR_IN
36700: IFFALSE 36759
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36702: LD_VAR 0 3
36706: PUSH
36707: LD_EXP 52
36711: PUSH
36712: LD_VAR 0 2
36716: ARRAY
36717: PUSH
36718: LD_INT 1
36720: ARRAY
36721: IN
36722: NOT
36723: PUSH
36724: LD_VAR 0 3
36728: PUSH
36729: LD_EXP 52
36733: PUSH
36734: LD_VAR 0 2
36738: ARRAY
36739: PUSH
36740: LD_INT 2
36742: ARRAY
36743: IN
36744: NOT
36745: AND
36746: IFFALSE 36757
// ComSpaceTimeShoot ( j ) ;
36748: LD_VAR 0 3
36752: PPUSH
36753: CALL 47433 0 1
36757: GO 36699
36759: POP
36760: POP
// end ;
36761: GO 36602
36763: POP
36764: POP
// end ;
36765: LD_VAR 0 1
36769: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
36770: LD_INT 0
36772: PPUSH
36773: PPUSH
36774: PPUSH
36775: PPUSH
36776: PPUSH
36777: PPUSH
36778: PPUSH
36779: PPUSH
36780: PPUSH
// if not mc_bases then
36781: LD_EXP 49
36785: NOT
36786: IFFALSE 36790
// exit ;
36788: GO 37412
// for i = 1 to mc_bases do
36790: LD_ADDR_VAR 0 2
36794: PUSH
36795: DOUBLE
36796: LD_INT 1
36798: DEC
36799: ST_TO_ADDR
36800: LD_EXP 49
36804: PUSH
36805: FOR_TO
36806: IFFALSE 37410
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
36808: LD_EXP 84
36812: PUSH
36813: LD_VAR 0 2
36817: ARRAY
36818: NOT
36819: PUSH
36820: LD_INT 38
36822: PPUSH
36823: LD_EXP 75
36827: PUSH
36828: LD_VAR 0 2
36832: ARRAY
36833: PPUSH
36834: CALL_OW 321
36838: PUSH
36839: LD_INT 2
36841: NONEQUAL
36842: OR
36843: IFFALSE 36847
// continue ;
36845: GO 36805
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
36847: LD_ADDR_VAR 0 8
36851: PUSH
36852: LD_EXP 49
36856: PUSH
36857: LD_VAR 0 2
36861: ARRAY
36862: PPUSH
36863: LD_INT 30
36865: PUSH
36866: LD_INT 34
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PPUSH
36873: CALL_OW 72
36877: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
36878: LD_ADDR_VAR 0 9
36882: PUSH
36883: LD_EXP 49
36887: PUSH
36888: LD_VAR 0 2
36892: ARRAY
36893: PPUSH
36894: LD_INT 25
36896: PUSH
36897: LD_INT 4
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PPUSH
36904: CALL_OW 72
36908: PPUSH
36909: LD_INT 0
36911: PPUSH
36912: CALL 86958 0 2
36916: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
36917: LD_VAR 0 9
36921: NOT
36922: PUSH
36923: LD_VAR 0 8
36927: NOT
36928: OR
36929: PUSH
36930: LD_EXP 49
36934: PUSH
36935: LD_VAR 0 2
36939: ARRAY
36940: PPUSH
36941: LD_INT 124
36943: PPUSH
36944: CALL 86958 0 2
36948: OR
36949: IFFALSE 36953
// continue ;
36951: GO 36805
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
36953: LD_EXP 85
36957: PUSH
36958: LD_VAR 0 2
36962: ARRAY
36963: PUSH
36964: LD_EXP 84
36968: PUSH
36969: LD_VAR 0 2
36973: ARRAY
36974: LESS
36975: PUSH
36976: LD_EXP 85
36980: PUSH
36981: LD_VAR 0 2
36985: ARRAY
36986: PUSH
36987: LD_VAR 0 8
36991: LESS
36992: AND
36993: IFFALSE 37408
// begin tmp := sci [ 1 ] ;
36995: LD_ADDR_VAR 0 7
36999: PUSH
37000: LD_VAR 0 9
37004: PUSH
37005: LD_INT 1
37007: ARRAY
37008: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37009: LD_VAR 0 7
37013: PPUSH
37014: LD_INT 124
37016: PPUSH
37017: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
37021: LD_ADDR_VAR 0 3
37025: PUSH
37026: DOUBLE
37027: LD_EXP 84
37031: PUSH
37032: LD_VAR 0 2
37036: ARRAY
37037: INC
37038: ST_TO_ADDR
37039: LD_EXP 84
37043: PUSH
37044: LD_VAR 0 2
37048: ARRAY
37049: PUSH
37050: FOR_DOWNTO
37051: IFFALSE 37394
// begin if IsInUnit ( tmp ) then
37053: LD_VAR 0 7
37057: PPUSH
37058: CALL_OW 310
37062: IFFALSE 37073
// ComExitBuilding ( tmp ) ;
37064: LD_VAR 0 7
37068: PPUSH
37069: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
37073: LD_INT 35
37075: PPUSH
37076: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
37080: LD_VAR 0 7
37084: PPUSH
37085: CALL_OW 310
37089: NOT
37090: PUSH
37091: LD_VAR 0 7
37095: PPUSH
37096: CALL_OW 314
37100: NOT
37101: AND
37102: IFFALSE 37073
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
37104: LD_ADDR_VAR 0 6
37108: PUSH
37109: LD_VAR 0 7
37113: PPUSH
37114: CALL_OW 250
37118: PUSH
37119: LD_VAR 0 7
37123: PPUSH
37124: CALL_OW 251
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37133: LD_INT 35
37135: PPUSH
37136: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
37140: LD_ADDR_VAR 0 4
37144: PUSH
37145: LD_EXP 84
37149: PUSH
37150: LD_VAR 0 2
37154: ARRAY
37155: PUSH
37156: LD_VAR 0 3
37160: ARRAY
37161: PUSH
37162: LD_INT 1
37164: ARRAY
37165: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
37166: LD_ADDR_VAR 0 5
37170: PUSH
37171: LD_EXP 84
37175: PUSH
37176: LD_VAR 0 2
37180: ARRAY
37181: PUSH
37182: LD_VAR 0 3
37186: ARRAY
37187: PUSH
37188: LD_INT 2
37190: ARRAY
37191: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
37192: LD_VAR 0 7
37196: PPUSH
37197: LD_INT 10
37199: PPUSH
37200: CALL 56291 0 2
37204: PUSH
37205: LD_INT 4
37207: ARRAY
37208: IFFALSE 37246
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
37210: LD_VAR 0 7
37214: PPUSH
37215: LD_VAR 0 6
37219: PUSH
37220: LD_INT 1
37222: ARRAY
37223: PPUSH
37224: LD_VAR 0 6
37228: PUSH
37229: LD_INT 2
37231: ARRAY
37232: PPUSH
37233: CALL_OW 111
// wait ( 0 0$10 ) ;
37237: LD_INT 350
37239: PPUSH
37240: CALL_OW 67
// end else
37244: GO 37272
// begin ComMoveXY ( tmp , x , y ) ;
37246: LD_VAR 0 7
37250: PPUSH
37251: LD_VAR 0 4
37255: PPUSH
37256: LD_VAR 0 5
37260: PPUSH
37261: CALL_OW 111
// wait ( 0 0$3 ) ;
37265: LD_INT 105
37267: PPUSH
37268: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
37272: LD_VAR 0 7
37276: PPUSH
37277: LD_VAR 0 4
37281: PPUSH
37282: LD_VAR 0 5
37286: PPUSH
37287: CALL_OW 307
37291: IFFALSE 37133
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
37293: LD_VAR 0 7
37297: PPUSH
37298: LD_VAR 0 4
37302: PPUSH
37303: LD_VAR 0 5
37307: PPUSH
37308: LD_VAR 0 8
37312: PUSH
37313: LD_VAR 0 3
37317: ARRAY
37318: PPUSH
37319: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
37323: LD_INT 35
37325: PPUSH
37326: CALL_OW 67
// until not HasTask ( tmp ) ;
37330: LD_VAR 0 7
37334: PPUSH
37335: CALL_OW 314
37339: NOT
37340: IFFALSE 37323
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
37342: LD_ADDR_EXP 85
37346: PUSH
37347: LD_EXP 85
37351: PPUSH
37352: LD_VAR 0 2
37356: PUSH
37357: LD_EXP 85
37361: PUSH
37362: LD_VAR 0 2
37366: ARRAY
37367: PUSH
37368: LD_INT 1
37370: PLUS
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PPUSH
37376: LD_VAR 0 8
37380: PUSH
37381: LD_VAR 0 3
37385: ARRAY
37386: PPUSH
37387: CALL 53698 0 3
37391: ST_TO_ADDR
// end ;
37392: GO 37050
37394: POP
37395: POP
// MC_Reset ( i , 124 ) ;
37396: LD_VAR 0 2
37400: PPUSH
37401: LD_INT 124
37403: PPUSH
37404: CALL 20895 0 2
// end ; end ;
37408: GO 36805
37410: POP
37411: POP
// end ;
37412: LD_VAR 0 1
37416: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
37417: LD_INT 0
37419: PPUSH
37420: PPUSH
37421: PPUSH
// if not mc_bases then
37422: LD_EXP 49
37426: NOT
37427: IFFALSE 37431
// exit ;
37429: GO 38037
// for i = 1 to mc_bases do
37431: LD_ADDR_VAR 0 2
37435: PUSH
37436: DOUBLE
37437: LD_INT 1
37439: DEC
37440: ST_TO_ADDR
37441: LD_EXP 49
37445: PUSH
37446: FOR_TO
37447: IFFALSE 38035
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
37449: LD_ADDR_VAR 0 3
37453: PUSH
37454: LD_EXP 49
37458: PUSH
37459: LD_VAR 0 2
37463: ARRAY
37464: PPUSH
37465: LD_INT 25
37467: PUSH
37468: LD_INT 4
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PPUSH
37475: CALL_OW 72
37479: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
37480: LD_VAR 0 3
37484: NOT
37485: PUSH
37486: LD_EXP 86
37490: PUSH
37491: LD_VAR 0 2
37495: ARRAY
37496: NOT
37497: OR
37498: PUSH
37499: LD_EXP 49
37503: PUSH
37504: LD_VAR 0 2
37508: ARRAY
37509: PPUSH
37510: LD_INT 2
37512: PUSH
37513: LD_INT 30
37515: PUSH
37516: LD_INT 0
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 30
37525: PUSH
37526: LD_INT 1
37528: PUSH
37529: EMPTY
37530: LIST
37531: LIST
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: LIST
37537: PPUSH
37538: CALL_OW 72
37542: NOT
37543: OR
37544: IFFALSE 37594
// begin if mc_deposits_finder [ i ] then
37546: LD_EXP 87
37550: PUSH
37551: LD_VAR 0 2
37555: ARRAY
37556: IFFALSE 37592
// begin MC_Reset ( i , 125 ) ;
37558: LD_VAR 0 2
37562: PPUSH
37563: LD_INT 125
37565: PPUSH
37566: CALL 20895 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37570: LD_ADDR_EXP 87
37574: PUSH
37575: LD_EXP 87
37579: PPUSH
37580: LD_VAR 0 2
37584: PPUSH
37585: EMPTY
37586: PPUSH
37587: CALL_OW 1
37591: ST_TO_ADDR
// end ; continue ;
37592: GO 37446
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
37594: LD_EXP 86
37598: PUSH
37599: LD_VAR 0 2
37603: ARRAY
37604: PUSH
37605: LD_INT 1
37607: ARRAY
37608: PUSH
37609: LD_INT 3
37611: ARRAY
37612: PUSH
37613: LD_INT 1
37615: EQUAL
37616: PUSH
37617: LD_INT 20
37619: PPUSH
37620: LD_EXP 75
37624: PUSH
37625: LD_VAR 0 2
37629: ARRAY
37630: PPUSH
37631: CALL_OW 321
37635: PUSH
37636: LD_INT 2
37638: NONEQUAL
37639: AND
37640: IFFALSE 37690
// begin if mc_deposits_finder [ i ] then
37642: LD_EXP 87
37646: PUSH
37647: LD_VAR 0 2
37651: ARRAY
37652: IFFALSE 37688
// begin MC_Reset ( i , 125 ) ;
37654: LD_VAR 0 2
37658: PPUSH
37659: LD_INT 125
37661: PPUSH
37662: CALL 20895 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37666: LD_ADDR_EXP 87
37670: PUSH
37671: LD_EXP 87
37675: PPUSH
37676: LD_VAR 0 2
37680: PPUSH
37681: EMPTY
37682: PPUSH
37683: CALL_OW 1
37687: ST_TO_ADDR
// end ; continue ;
37688: GO 37446
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
37690: LD_EXP 86
37694: PUSH
37695: LD_VAR 0 2
37699: ARRAY
37700: PUSH
37701: LD_INT 1
37703: ARRAY
37704: PUSH
37705: LD_INT 1
37707: ARRAY
37708: PPUSH
37709: LD_EXP 86
37713: PUSH
37714: LD_VAR 0 2
37718: ARRAY
37719: PUSH
37720: LD_INT 1
37722: ARRAY
37723: PUSH
37724: LD_INT 2
37726: ARRAY
37727: PPUSH
37728: LD_EXP 75
37732: PUSH
37733: LD_VAR 0 2
37737: ARRAY
37738: PPUSH
37739: CALL_OW 440
37743: IFFALSE 37786
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
37745: LD_ADDR_EXP 86
37749: PUSH
37750: LD_EXP 86
37754: PPUSH
37755: LD_VAR 0 2
37759: PPUSH
37760: LD_EXP 86
37764: PUSH
37765: LD_VAR 0 2
37769: ARRAY
37770: PPUSH
37771: LD_INT 1
37773: PPUSH
37774: CALL_OW 3
37778: PPUSH
37779: CALL_OW 1
37783: ST_TO_ADDR
37784: GO 38033
// begin if not mc_deposits_finder [ i ] then
37786: LD_EXP 87
37790: PUSH
37791: LD_VAR 0 2
37795: ARRAY
37796: NOT
37797: IFFALSE 37849
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
37799: LD_ADDR_EXP 87
37803: PUSH
37804: LD_EXP 87
37808: PPUSH
37809: LD_VAR 0 2
37813: PPUSH
37814: LD_VAR 0 3
37818: PUSH
37819: LD_INT 1
37821: ARRAY
37822: PUSH
37823: EMPTY
37824: LIST
37825: PPUSH
37826: CALL_OW 1
37830: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
37831: LD_VAR 0 3
37835: PUSH
37836: LD_INT 1
37838: ARRAY
37839: PPUSH
37840: LD_INT 125
37842: PPUSH
37843: CALL_OW 109
// end else
37847: GO 38033
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
37849: LD_EXP 87
37853: PUSH
37854: LD_VAR 0 2
37858: ARRAY
37859: PUSH
37860: LD_INT 1
37862: ARRAY
37863: PPUSH
37864: CALL_OW 310
37868: IFFALSE 37891
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
37870: LD_EXP 87
37874: PUSH
37875: LD_VAR 0 2
37879: ARRAY
37880: PUSH
37881: LD_INT 1
37883: ARRAY
37884: PPUSH
37885: CALL_OW 122
37889: GO 38033
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
37891: LD_EXP 87
37895: PUSH
37896: LD_VAR 0 2
37900: ARRAY
37901: PUSH
37902: LD_INT 1
37904: ARRAY
37905: PPUSH
37906: CALL_OW 314
37910: NOT
37911: PUSH
37912: LD_EXP 87
37916: PUSH
37917: LD_VAR 0 2
37921: ARRAY
37922: PUSH
37923: LD_INT 1
37925: ARRAY
37926: PPUSH
37927: LD_EXP 86
37931: PUSH
37932: LD_VAR 0 2
37936: ARRAY
37937: PUSH
37938: LD_INT 1
37940: ARRAY
37941: PUSH
37942: LD_INT 1
37944: ARRAY
37945: PPUSH
37946: LD_EXP 86
37950: PUSH
37951: LD_VAR 0 2
37955: ARRAY
37956: PUSH
37957: LD_INT 1
37959: ARRAY
37960: PUSH
37961: LD_INT 2
37963: ARRAY
37964: PPUSH
37965: CALL_OW 297
37969: PUSH
37970: LD_INT 6
37972: GREATER
37973: AND
37974: IFFALSE 38033
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
37976: LD_EXP 87
37980: PUSH
37981: LD_VAR 0 2
37985: ARRAY
37986: PUSH
37987: LD_INT 1
37989: ARRAY
37990: PPUSH
37991: LD_EXP 86
37995: PUSH
37996: LD_VAR 0 2
38000: ARRAY
38001: PUSH
38002: LD_INT 1
38004: ARRAY
38005: PUSH
38006: LD_INT 1
38008: ARRAY
38009: PPUSH
38010: LD_EXP 86
38014: PUSH
38015: LD_VAR 0 2
38019: ARRAY
38020: PUSH
38021: LD_INT 1
38023: ARRAY
38024: PUSH
38025: LD_INT 2
38027: ARRAY
38028: PPUSH
38029: CALL_OW 111
// end ; end ; end ;
38033: GO 37446
38035: POP
38036: POP
// end ;
38037: LD_VAR 0 1
38041: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
38042: LD_INT 0
38044: PPUSH
38045: PPUSH
38046: PPUSH
38047: PPUSH
38048: PPUSH
38049: PPUSH
38050: PPUSH
38051: PPUSH
38052: PPUSH
38053: PPUSH
38054: PPUSH
// if not mc_bases then
38055: LD_EXP 49
38059: NOT
38060: IFFALSE 38064
// exit ;
38062: GO 38788
// for i = 1 to mc_bases do
38064: LD_ADDR_VAR 0 2
38068: PUSH
38069: DOUBLE
38070: LD_INT 1
38072: DEC
38073: ST_TO_ADDR
38074: LD_EXP 49
38078: PUSH
38079: FOR_TO
38080: IFFALSE 38786
// begin if not mc_bases [ i ] then
38082: LD_EXP 49
38086: PUSH
38087: LD_VAR 0 2
38091: ARRAY
38092: NOT
38093: IFFALSE 38097
// continue ;
38095: GO 38079
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
38097: LD_ADDR_VAR 0 7
38101: PUSH
38102: LD_EXP 49
38106: PUSH
38107: LD_VAR 0 2
38111: ARRAY
38112: PUSH
38113: LD_INT 1
38115: ARRAY
38116: PPUSH
38117: CALL_OW 248
38121: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
38122: LD_VAR 0 7
38126: PUSH
38127: LD_INT 3
38129: EQUAL
38130: PUSH
38131: LD_EXP 68
38135: PUSH
38136: LD_VAR 0 2
38140: ARRAY
38141: PUSH
38142: LD_EXP 71
38146: PUSH
38147: LD_VAR 0 2
38151: ARRAY
38152: UNION
38153: PPUSH
38154: LD_INT 33
38156: PUSH
38157: LD_INT 2
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PPUSH
38164: CALL_OW 72
38168: NOT
38169: OR
38170: IFFALSE 38174
// continue ;
38172: GO 38079
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
38174: LD_ADDR_VAR 0 9
38178: PUSH
38179: LD_EXP 49
38183: PUSH
38184: LD_VAR 0 2
38188: ARRAY
38189: PPUSH
38190: LD_INT 30
38192: PUSH
38193: LD_INT 36
38195: PUSH
38196: EMPTY
38197: LIST
38198: LIST
38199: PPUSH
38200: CALL_OW 72
38204: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
38205: LD_ADDR_VAR 0 10
38209: PUSH
38210: LD_EXP 68
38214: PUSH
38215: LD_VAR 0 2
38219: ARRAY
38220: PPUSH
38221: LD_INT 34
38223: PUSH
38224: LD_INT 31
38226: PUSH
38227: EMPTY
38228: LIST
38229: LIST
38230: PPUSH
38231: CALL_OW 72
38235: ST_TO_ADDR
// if not cts and not mcts then
38236: LD_VAR 0 9
38240: NOT
38241: PUSH
38242: LD_VAR 0 10
38246: NOT
38247: AND
38248: IFFALSE 38252
// continue ;
38250: GO 38079
// x := cts ;
38252: LD_ADDR_VAR 0 11
38256: PUSH
38257: LD_VAR 0 9
38261: ST_TO_ADDR
// if not x then
38262: LD_VAR 0 11
38266: NOT
38267: IFFALSE 38279
// x := mcts ;
38269: LD_ADDR_VAR 0 11
38273: PUSH
38274: LD_VAR 0 10
38278: ST_TO_ADDR
// if mc_remote_driver [ i ] then
38279: LD_EXP 89
38283: PUSH
38284: LD_VAR 0 2
38288: ARRAY
38289: IFFALSE 38558
// for j in mc_remote_driver [ i ] do
38291: LD_ADDR_VAR 0 3
38295: PUSH
38296: LD_EXP 89
38300: PUSH
38301: LD_VAR 0 2
38305: ARRAY
38306: PUSH
38307: FOR_IN
38308: IFFALSE 38556
// begin if GetClass ( j ) <> 3 then
38310: LD_VAR 0 3
38314: PPUSH
38315: CALL_OW 257
38319: PUSH
38320: LD_INT 3
38322: NONEQUAL
38323: IFFALSE 38376
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
38325: LD_ADDR_EXP 89
38329: PUSH
38330: LD_EXP 89
38334: PPUSH
38335: LD_VAR 0 2
38339: PPUSH
38340: LD_EXP 89
38344: PUSH
38345: LD_VAR 0 2
38349: ARRAY
38350: PUSH
38351: LD_VAR 0 3
38355: DIFF
38356: PPUSH
38357: CALL_OW 1
38361: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38362: LD_VAR 0 3
38366: PPUSH
38367: LD_INT 0
38369: PPUSH
38370: CALL_OW 109
// continue ;
38374: GO 38307
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
38376: LD_VAR 0 3
38380: PPUSH
38381: CALL_OW 310
38385: NOT
38386: PUSH
38387: LD_VAR 0 3
38391: PPUSH
38392: CALL_OW 310
38396: PPUSH
38397: CALL_OW 266
38401: PUSH
38402: LD_INT 36
38404: NONEQUAL
38405: PUSH
38406: LD_VAR 0 3
38410: PPUSH
38411: CALL 87046 0 1
38415: NOT
38416: AND
38417: OR
38418: IFFALSE 38554
// begin if IsInUnit ( j ) then
38420: LD_VAR 0 3
38424: PPUSH
38425: CALL_OW 310
38429: IFFALSE 38440
// ComExitBuilding ( j ) ;
38431: LD_VAR 0 3
38435: PPUSH
38436: CALL_OW 122
// ct := 0 ;
38440: LD_ADDR_VAR 0 8
38444: PUSH
38445: LD_INT 0
38447: ST_TO_ADDR
// for k in x do
38448: LD_ADDR_VAR 0 4
38452: PUSH
38453: LD_VAR 0 11
38457: PUSH
38458: FOR_IN
38459: IFFALSE 38532
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
38461: LD_VAR 0 4
38465: PPUSH
38466: CALL_OW 264
38470: PUSH
38471: LD_INT 31
38473: EQUAL
38474: PUSH
38475: LD_VAR 0 4
38479: PPUSH
38480: CALL_OW 311
38484: NOT
38485: AND
38486: PUSH
38487: LD_VAR 0 4
38491: PPUSH
38492: CALL_OW 266
38496: PUSH
38497: LD_INT 36
38499: EQUAL
38500: PUSH
38501: LD_VAR 0 4
38505: PPUSH
38506: CALL_OW 313
38510: PUSH
38511: LD_INT 3
38513: LESS
38514: AND
38515: OR
38516: IFFALSE 38530
// begin ct := k ;
38518: LD_ADDR_VAR 0 8
38522: PUSH
38523: LD_VAR 0 4
38527: ST_TO_ADDR
// break ;
38528: GO 38532
// end ;
38530: GO 38458
38532: POP
38533: POP
// if ct then
38534: LD_VAR 0 8
38538: IFFALSE 38554
// ComEnterUnit ( j , ct ) ;
38540: LD_VAR 0 3
38544: PPUSH
38545: LD_VAR 0 8
38549: PPUSH
38550: CALL_OW 120
// end ; end ;
38554: GO 38307
38556: POP
38557: POP
// places := 0 ;
38558: LD_ADDR_VAR 0 5
38562: PUSH
38563: LD_INT 0
38565: ST_TO_ADDR
// for j = 1 to x do
38566: LD_ADDR_VAR 0 3
38570: PUSH
38571: DOUBLE
38572: LD_INT 1
38574: DEC
38575: ST_TO_ADDR
38576: LD_VAR 0 11
38580: PUSH
38581: FOR_TO
38582: IFFALSE 38637
// if GetWeapon ( x [ j ] ) = ar_control_tower then
38584: LD_VAR 0 11
38588: PUSH
38589: LD_VAR 0 3
38593: ARRAY
38594: PPUSH
38595: CALL_OW 264
38599: PUSH
38600: LD_INT 31
38602: EQUAL
38603: IFFALSE 38621
// places := places + 1 else
38605: LD_ADDR_VAR 0 5
38609: PUSH
38610: LD_VAR 0 5
38614: PUSH
38615: LD_INT 1
38617: PLUS
38618: ST_TO_ADDR
38619: GO 38635
// places := places + 3 ;
38621: LD_ADDR_VAR 0 5
38625: PUSH
38626: LD_VAR 0 5
38630: PUSH
38631: LD_INT 3
38633: PLUS
38634: ST_TO_ADDR
38635: GO 38581
38637: POP
38638: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
38639: LD_ADDR_VAR 0 6
38643: PUSH
38644: LD_EXP 49
38648: PUSH
38649: LD_VAR 0 2
38653: ARRAY
38654: PPUSH
38655: LD_INT 25
38657: PUSH
38658: LD_INT 3
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PPUSH
38665: CALL_OW 72
38669: PUSH
38670: LD_EXP 89
38674: PUSH
38675: LD_VAR 0 2
38679: ARRAY
38680: DIFF
38681: PPUSH
38682: LD_INT 3
38684: PPUSH
38685: CALL 87946 0 2
38689: ST_TO_ADDR
// if not tmp then
38690: LD_VAR 0 6
38694: NOT
38695: IFFALSE 38699
// continue ;
38697: GO 38079
// places := places - mc_remote_driver [ i ] ;
38699: LD_ADDR_VAR 0 5
38703: PUSH
38704: LD_VAR 0 5
38708: PUSH
38709: LD_EXP 89
38713: PUSH
38714: LD_VAR 0 2
38718: ARRAY
38719: MINUS
38720: ST_TO_ADDR
// if places then
38721: LD_VAR 0 5
38725: IFFALSE 38784
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
38727: LD_ADDR_EXP 89
38731: PUSH
38732: LD_EXP 89
38736: PPUSH
38737: LD_VAR 0 2
38741: PPUSH
38742: LD_EXP 89
38746: PUSH
38747: LD_VAR 0 2
38751: ARRAY
38752: PUSH
38753: LD_VAR 0 6
38757: PUSH
38758: LD_INT 1
38760: ARRAY
38761: UNION
38762: PPUSH
38763: CALL_OW 1
38767: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
38768: LD_VAR 0 6
38772: PUSH
38773: LD_INT 1
38775: ARRAY
38776: PPUSH
38777: LD_INT 126
38779: PPUSH
38780: CALL_OW 109
// end ; end ;
38784: GO 38079
38786: POP
38787: POP
// end ;
38788: LD_VAR 0 1
38792: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
38793: LD_INT 0
38795: PPUSH
38796: PPUSH
38797: PPUSH
38798: PPUSH
38799: PPUSH
38800: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
38801: LD_VAR 0 1
38805: NOT
38806: PUSH
38807: LD_VAR 0 2
38811: NOT
38812: OR
38813: PUSH
38814: LD_VAR 0 3
38818: NOT
38819: OR
38820: PUSH
38821: LD_VAR 0 4
38825: PUSH
38826: LD_INT 1
38828: PUSH
38829: LD_INT 2
38831: PUSH
38832: LD_INT 3
38834: PUSH
38835: LD_INT 4
38837: PUSH
38838: LD_INT 5
38840: PUSH
38841: LD_INT 8
38843: PUSH
38844: LD_INT 9
38846: PUSH
38847: LD_INT 15
38849: PUSH
38850: LD_INT 16
38852: PUSH
38853: EMPTY
38854: LIST
38855: LIST
38856: LIST
38857: LIST
38858: LIST
38859: LIST
38860: LIST
38861: LIST
38862: LIST
38863: IN
38864: NOT
38865: OR
38866: IFFALSE 38870
// exit ;
38868: GO 39770
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
38870: LD_ADDR_VAR 0 2
38874: PUSH
38875: LD_VAR 0 2
38879: PPUSH
38880: LD_INT 21
38882: PUSH
38883: LD_INT 3
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: PUSH
38890: LD_INT 24
38892: PUSH
38893: LD_INT 250
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PPUSH
38904: CALL_OW 72
38908: ST_TO_ADDR
// case class of 1 , 15 :
38909: LD_VAR 0 4
38913: PUSH
38914: LD_INT 1
38916: DOUBLE
38917: EQUAL
38918: IFTRUE 38928
38920: LD_INT 15
38922: DOUBLE
38923: EQUAL
38924: IFTRUE 38928
38926: GO 39013
38928: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
38929: LD_ADDR_VAR 0 8
38933: PUSH
38934: LD_VAR 0 2
38938: PPUSH
38939: LD_INT 2
38941: PUSH
38942: LD_INT 30
38944: PUSH
38945: LD_INT 32
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 30
38954: PUSH
38955: LD_INT 31
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: LIST
38966: PPUSH
38967: CALL_OW 72
38971: PUSH
38972: LD_VAR 0 2
38976: PPUSH
38977: LD_INT 2
38979: PUSH
38980: LD_INT 30
38982: PUSH
38983: LD_INT 4
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 30
38992: PUSH
38993: LD_INT 5
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: LIST
39004: PPUSH
39005: CALL_OW 72
39009: ADD
39010: ST_TO_ADDR
39011: GO 39259
39013: LD_INT 2
39015: DOUBLE
39016: EQUAL
39017: IFTRUE 39027
39019: LD_INT 16
39021: DOUBLE
39022: EQUAL
39023: IFTRUE 39027
39025: GO 39073
39027: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
39028: LD_ADDR_VAR 0 8
39032: PUSH
39033: LD_VAR 0 2
39037: PPUSH
39038: LD_INT 2
39040: PUSH
39041: LD_INT 30
39043: PUSH
39044: LD_INT 0
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: PUSH
39051: LD_INT 30
39053: PUSH
39054: LD_INT 1
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: LIST
39065: PPUSH
39066: CALL_OW 72
39070: ST_TO_ADDR
39071: GO 39259
39073: LD_INT 3
39075: DOUBLE
39076: EQUAL
39077: IFTRUE 39081
39079: GO 39127
39081: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
39082: LD_ADDR_VAR 0 8
39086: PUSH
39087: LD_VAR 0 2
39091: PPUSH
39092: LD_INT 2
39094: PUSH
39095: LD_INT 30
39097: PUSH
39098: LD_INT 2
39100: PUSH
39101: EMPTY
39102: LIST
39103: LIST
39104: PUSH
39105: LD_INT 30
39107: PUSH
39108: LD_INT 3
39110: PUSH
39111: EMPTY
39112: LIST
39113: LIST
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: LIST
39119: PPUSH
39120: CALL_OW 72
39124: ST_TO_ADDR
39125: GO 39259
39127: LD_INT 4
39129: DOUBLE
39130: EQUAL
39131: IFTRUE 39135
39133: GO 39192
39135: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
39136: LD_ADDR_VAR 0 8
39140: PUSH
39141: LD_VAR 0 2
39145: PPUSH
39146: LD_INT 2
39148: PUSH
39149: LD_INT 30
39151: PUSH
39152: LD_INT 6
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 30
39161: PUSH
39162: LD_INT 7
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 30
39171: PUSH
39172: LD_INT 8
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: EMPTY
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: PPUSH
39185: CALL_OW 72
39189: ST_TO_ADDR
39190: GO 39259
39192: LD_INT 5
39194: DOUBLE
39195: EQUAL
39196: IFTRUE 39212
39198: LD_INT 8
39200: DOUBLE
39201: EQUAL
39202: IFTRUE 39212
39204: LD_INT 9
39206: DOUBLE
39207: EQUAL
39208: IFTRUE 39212
39210: GO 39258
39212: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
39213: LD_ADDR_VAR 0 8
39217: PUSH
39218: LD_VAR 0 2
39222: PPUSH
39223: LD_INT 2
39225: PUSH
39226: LD_INT 30
39228: PUSH
39229: LD_INT 4
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PUSH
39236: LD_INT 30
39238: PUSH
39239: LD_INT 5
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: LIST
39250: PPUSH
39251: CALL_OW 72
39255: ST_TO_ADDR
39256: GO 39259
39258: POP
// if not tmp then
39259: LD_VAR 0 8
39263: NOT
39264: IFFALSE 39268
// exit ;
39266: GO 39770
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
39268: LD_VAR 0 4
39272: PUSH
39273: LD_INT 1
39275: PUSH
39276: LD_INT 15
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: IN
39283: PUSH
39284: LD_EXP 58
39288: PUSH
39289: LD_VAR 0 1
39293: ARRAY
39294: AND
39295: IFFALSE 39451
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
39297: LD_ADDR_VAR 0 9
39301: PUSH
39302: LD_EXP 58
39306: PUSH
39307: LD_VAR 0 1
39311: ARRAY
39312: PUSH
39313: LD_INT 1
39315: ARRAY
39316: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
39317: LD_VAR 0 9
39321: PUSH
39322: LD_EXP 59
39326: PUSH
39327: LD_VAR 0 1
39331: ARRAY
39332: IN
39333: NOT
39334: IFFALSE 39449
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
39336: LD_ADDR_EXP 59
39340: PUSH
39341: LD_EXP 59
39345: PPUSH
39346: LD_VAR 0 1
39350: PUSH
39351: LD_EXP 59
39355: PUSH
39356: LD_VAR 0 1
39360: ARRAY
39361: PUSH
39362: LD_INT 1
39364: PLUS
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PPUSH
39370: LD_VAR 0 9
39374: PPUSH
39375: CALL 53698 0 3
39379: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
39380: LD_ADDR_EXP 58
39384: PUSH
39385: LD_EXP 58
39389: PPUSH
39390: LD_VAR 0 1
39394: PPUSH
39395: LD_EXP 58
39399: PUSH
39400: LD_VAR 0 1
39404: ARRAY
39405: PUSH
39406: LD_VAR 0 9
39410: DIFF
39411: PPUSH
39412: CALL_OW 1
39416: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
39417: LD_VAR 0 3
39421: PPUSH
39422: LD_EXP 59
39426: PUSH
39427: LD_VAR 0 1
39431: ARRAY
39432: PUSH
39433: LD_EXP 59
39437: PUSH
39438: LD_VAR 0 1
39442: ARRAY
39443: ARRAY
39444: PPUSH
39445: CALL_OW 120
// end ; exit ;
39449: GO 39770
// end ; if tmp > 1 then
39451: LD_VAR 0 8
39455: PUSH
39456: LD_INT 1
39458: GREATER
39459: IFFALSE 39563
// for i = 2 to tmp do
39461: LD_ADDR_VAR 0 6
39465: PUSH
39466: DOUBLE
39467: LD_INT 2
39469: DEC
39470: ST_TO_ADDR
39471: LD_VAR 0 8
39475: PUSH
39476: FOR_TO
39477: IFFALSE 39561
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
39479: LD_VAR 0 8
39483: PUSH
39484: LD_VAR 0 6
39488: ARRAY
39489: PPUSH
39490: CALL_OW 461
39494: PUSH
39495: LD_INT 6
39497: EQUAL
39498: IFFALSE 39559
// begin x := tmp [ i ] ;
39500: LD_ADDR_VAR 0 9
39504: PUSH
39505: LD_VAR 0 8
39509: PUSH
39510: LD_VAR 0 6
39514: ARRAY
39515: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
39516: LD_ADDR_VAR 0 8
39520: PUSH
39521: LD_VAR 0 8
39525: PPUSH
39526: LD_VAR 0 6
39530: PPUSH
39531: CALL_OW 3
39535: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
39536: LD_ADDR_VAR 0 8
39540: PUSH
39541: LD_VAR 0 8
39545: PPUSH
39546: LD_INT 1
39548: PPUSH
39549: LD_VAR 0 9
39553: PPUSH
39554: CALL_OW 2
39558: ST_TO_ADDR
// end ;
39559: GO 39476
39561: POP
39562: POP
// for i in tmp do
39563: LD_ADDR_VAR 0 6
39567: PUSH
39568: LD_VAR 0 8
39572: PUSH
39573: FOR_IN
39574: IFFALSE 39643
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
39576: LD_VAR 0 6
39580: PPUSH
39581: CALL_OW 313
39585: PUSH
39586: LD_INT 6
39588: LESS
39589: PUSH
39590: LD_VAR 0 6
39594: PPUSH
39595: CALL_OW 266
39599: PUSH
39600: LD_INT 31
39602: PUSH
39603: LD_INT 32
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: IN
39610: NOT
39611: AND
39612: PUSH
39613: LD_VAR 0 6
39617: PPUSH
39618: CALL_OW 313
39622: PUSH
39623: LD_INT 0
39625: EQUAL
39626: OR
39627: IFFALSE 39641
// begin j := i ;
39629: LD_ADDR_VAR 0 7
39633: PUSH
39634: LD_VAR 0 6
39638: ST_TO_ADDR
// break ;
39639: GO 39643
// end ; end ;
39641: GO 39573
39643: POP
39644: POP
// if j then
39645: LD_VAR 0 7
39649: IFFALSE 39667
// ComEnterUnit ( unit , j ) else
39651: LD_VAR 0 3
39655: PPUSH
39656: LD_VAR 0 7
39660: PPUSH
39661: CALL_OW 120
39665: GO 39770
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39667: LD_ADDR_VAR 0 10
39671: PUSH
39672: LD_VAR 0 2
39676: PPUSH
39677: LD_INT 2
39679: PUSH
39680: LD_INT 30
39682: PUSH
39683: LD_INT 0
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 30
39692: PUSH
39693: LD_INT 1
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: LIST
39704: PPUSH
39705: CALL_OW 72
39709: ST_TO_ADDR
// if depot then
39710: LD_VAR 0 10
39714: IFFALSE 39770
// begin depot := NearestUnitToUnit ( depot , unit ) ;
39716: LD_ADDR_VAR 0 10
39720: PUSH
39721: LD_VAR 0 10
39725: PPUSH
39726: LD_VAR 0 3
39730: PPUSH
39731: CALL_OW 74
39735: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
39736: LD_VAR 0 3
39740: PPUSH
39741: LD_VAR 0 10
39745: PPUSH
39746: CALL_OW 296
39750: PUSH
39751: LD_INT 10
39753: GREATER
39754: IFFALSE 39770
// ComStandNearbyBuilding ( unit , depot ) ;
39756: LD_VAR 0 3
39760: PPUSH
39761: LD_VAR 0 10
39765: PPUSH
39766: CALL 48050 0 2
// end ; end ; end ;
39770: LD_VAR 0 5
39774: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
39775: LD_INT 0
39777: PPUSH
39778: PPUSH
39779: PPUSH
39780: PPUSH
// if not mc_bases then
39781: LD_EXP 49
39785: NOT
39786: IFFALSE 39790
// exit ;
39788: GO 40029
// for i = 1 to mc_bases do
39790: LD_ADDR_VAR 0 2
39794: PUSH
39795: DOUBLE
39796: LD_INT 1
39798: DEC
39799: ST_TO_ADDR
39800: LD_EXP 49
39804: PUSH
39805: FOR_TO
39806: IFFALSE 40027
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
39808: LD_ADDR_VAR 0 4
39812: PUSH
39813: LD_EXP 49
39817: PUSH
39818: LD_VAR 0 2
39822: ARRAY
39823: PPUSH
39824: LD_INT 21
39826: PUSH
39827: LD_INT 1
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: PPUSH
39834: CALL_OW 72
39838: PUSH
39839: LD_EXP 78
39843: PUSH
39844: LD_VAR 0 2
39848: ARRAY
39849: UNION
39850: ST_TO_ADDR
// if not tmp then
39851: LD_VAR 0 4
39855: NOT
39856: IFFALSE 39860
// continue ;
39858: GO 39805
// for j in tmp do
39860: LD_ADDR_VAR 0 3
39864: PUSH
39865: LD_VAR 0 4
39869: PUSH
39870: FOR_IN
39871: IFFALSE 40023
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
39873: LD_VAR 0 3
39877: PPUSH
39878: CALL_OW 110
39882: NOT
39883: PUSH
39884: LD_VAR 0 3
39888: PPUSH
39889: CALL_OW 314
39893: NOT
39894: AND
39895: PUSH
39896: LD_VAR 0 3
39900: PPUSH
39901: CALL_OW 311
39905: NOT
39906: AND
39907: PUSH
39908: LD_VAR 0 3
39912: PPUSH
39913: CALL_OW 310
39917: NOT
39918: AND
39919: PUSH
39920: LD_VAR 0 3
39924: PUSH
39925: LD_EXP 52
39929: PUSH
39930: LD_VAR 0 2
39934: ARRAY
39935: PUSH
39936: LD_INT 1
39938: ARRAY
39939: IN
39940: NOT
39941: AND
39942: PUSH
39943: LD_VAR 0 3
39947: PUSH
39948: LD_EXP 52
39952: PUSH
39953: LD_VAR 0 2
39957: ARRAY
39958: PUSH
39959: LD_INT 2
39961: ARRAY
39962: IN
39963: NOT
39964: AND
39965: PUSH
39966: LD_VAR 0 3
39970: PUSH
39971: LD_EXP 61
39975: PUSH
39976: LD_VAR 0 2
39980: ARRAY
39981: IN
39982: NOT
39983: AND
39984: IFFALSE 40021
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
39986: LD_VAR 0 2
39990: PPUSH
39991: LD_EXP 49
39995: PUSH
39996: LD_VAR 0 2
40000: ARRAY
40001: PPUSH
40002: LD_VAR 0 3
40006: PPUSH
40007: LD_VAR 0 3
40011: PPUSH
40012: CALL_OW 257
40016: PPUSH
40017: CALL 38793 0 4
// end ;
40021: GO 39870
40023: POP
40024: POP
// end ;
40025: GO 39805
40027: POP
40028: POP
// end ;
40029: LD_VAR 0 1
40033: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
40034: LD_INT 0
40036: PPUSH
40037: PPUSH
40038: PPUSH
40039: PPUSH
40040: PPUSH
40041: PPUSH
// if not mc_bases [ base ] then
40042: LD_EXP 49
40046: PUSH
40047: LD_VAR 0 1
40051: ARRAY
40052: NOT
40053: IFFALSE 40057
// exit ;
40055: GO 40239
// tmp := [ ] ;
40057: LD_ADDR_VAR 0 6
40061: PUSH
40062: EMPTY
40063: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
40064: LD_ADDR_VAR 0 7
40068: PUSH
40069: LD_VAR 0 3
40073: PPUSH
40074: LD_INT 0
40076: PPUSH
40077: CALL_OW 517
40081: ST_TO_ADDR
// if not list then
40082: LD_VAR 0 7
40086: NOT
40087: IFFALSE 40091
// exit ;
40089: GO 40239
// for i = 1 to amount do
40091: LD_ADDR_VAR 0 5
40095: PUSH
40096: DOUBLE
40097: LD_INT 1
40099: DEC
40100: ST_TO_ADDR
40101: LD_VAR 0 2
40105: PUSH
40106: FOR_TO
40107: IFFALSE 40187
// begin x := rand ( 1 , list [ 1 ] ) ;
40109: LD_ADDR_VAR 0 8
40113: PUSH
40114: LD_INT 1
40116: PPUSH
40117: LD_VAR 0 7
40121: PUSH
40122: LD_INT 1
40124: ARRAY
40125: PPUSH
40126: CALL_OW 12
40130: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
40131: LD_ADDR_VAR 0 6
40135: PUSH
40136: LD_VAR 0 6
40140: PPUSH
40141: LD_VAR 0 5
40145: PPUSH
40146: LD_VAR 0 7
40150: PUSH
40151: LD_INT 1
40153: ARRAY
40154: PUSH
40155: LD_VAR 0 8
40159: ARRAY
40160: PUSH
40161: LD_VAR 0 7
40165: PUSH
40166: LD_INT 2
40168: ARRAY
40169: PUSH
40170: LD_VAR 0 8
40174: ARRAY
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: PPUSH
40180: CALL_OW 1
40184: ST_TO_ADDR
// end ;
40185: GO 40106
40187: POP
40188: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
40189: LD_ADDR_EXP 62
40193: PUSH
40194: LD_EXP 62
40198: PPUSH
40199: LD_VAR 0 1
40203: PPUSH
40204: LD_VAR 0 6
40208: PPUSH
40209: CALL_OW 1
40213: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
40214: LD_ADDR_EXP 64
40218: PUSH
40219: LD_EXP 64
40223: PPUSH
40224: LD_VAR 0 1
40228: PPUSH
40229: LD_VAR 0 3
40233: PPUSH
40234: CALL_OW 1
40238: ST_TO_ADDR
// end ;
40239: LD_VAR 0 4
40243: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
40244: LD_INT 0
40246: PPUSH
// if not mc_bases [ base ] then
40247: LD_EXP 49
40251: PUSH
40252: LD_VAR 0 1
40256: ARRAY
40257: NOT
40258: IFFALSE 40262
// exit ;
40260: GO 40287
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
40262: LD_ADDR_EXP 54
40266: PUSH
40267: LD_EXP 54
40271: PPUSH
40272: LD_VAR 0 1
40276: PPUSH
40277: LD_VAR 0 2
40281: PPUSH
40282: CALL_OW 1
40286: ST_TO_ADDR
// end ;
40287: LD_VAR 0 3
40291: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
40292: LD_INT 0
40294: PPUSH
// if not mc_bases [ base ] then
40295: LD_EXP 49
40299: PUSH
40300: LD_VAR 0 1
40304: ARRAY
40305: NOT
40306: IFFALSE 40310
// exit ;
40308: GO 40347
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
40310: LD_ADDR_EXP 54
40314: PUSH
40315: LD_EXP 54
40319: PPUSH
40320: LD_VAR 0 1
40324: PPUSH
40325: LD_EXP 54
40329: PUSH
40330: LD_VAR 0 1
40334: ARRAY
40335: PUSH
40336: LD_VAR 0 2
40340: UNION
40341: PPUSH
40342: CALL_OW 1
40346: ST_TO_ADDR
// end ;
40347: LD_VAR 0 3
40351: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
40352: LD_INT 0
40354: PPUSH
// if not mc_bases [ base ] then
40355: LD_EXP 49
40359: PUSH
40360: LD_VAR 0 1
40364: ARRAY
40365: NOT
40366: IFFALSE 40370
// exit ;
40368: GO 40395
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
40370: LD_ADDR_EXP 70
40374: PUSH
40375: LD_EXP 70
40379: PPUSH
40380: LD_VAR 0 1
40384: PPUSH
40385: LD_VAR 0 2
40389: PPUSH
40390: CALL_OW 1
40394: ST_TO_ADDR
// end ;
40395: LD_VAR 0 3
40399: RET
// export function MC_InsertProduceList ( base , components ) ; begin
40400: LD_INT 0
40402: PPUSH
// if not mc_bases [ base ] then
40403: LD_EXP 49
40407: PUSH
40408: LD_VAR 0 1
40412: ARRAY
40413: NOT
40414: IFFALSE 40418
// exit ;
40416: GO 40455
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
40418: LD_ADDR_EXP 70
40422: PUSH
40423: LD_EXP 70
40427: PPUSH
40428: LD_VAR 0 1
40432: PPUSH
40433: LD_EXP 70
40437: PUSH
40438: LD_VAR 0 1
40442: ARRAY
40443: PUSH
40444: LD_VAR 0 2
40448: ADD
40449: PPUSH
40450: CALL_OW 1
40454: ST_TO_ADDR
// end ;
40455: LD_VAR 0 3
40459: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
40460: LD_INT 0
40462: PPUSH
// if not mc_bases [ base ] then
40463: LD_EXP 49
40467: PUSH
40468: LD_VAR 0 1
40472: ARRAY
40473: NOT
40474: IFFALSE 40478
// exit ;
40476: GO 40532
// mc_defender := Replace ( mc_defender , base , deflist ) ;
40478: LD_ADDR_EXP 71
40482: PUSH
40483: LD_EXP 71
40487: PPUSH
40488: LD_VAR 0 1
40492: PPUSH
40493: LD_VAR 0 2
40497: PPUSH
40498: CALL_OW 1
40502: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
40503: LD_ADDR_EXP 60
40507: PUSH
40508: LD_EXP 60
40512: PPUSH
40513: LD_VAR 0 1
40517: PPUSH
40518: LD_VAR 0 2
40522: PUSH
40523: LD_INT 0
40525: PLUS
40526: PPUSH
40527: CALL_OW 1
40531: ST_TO_ADDR
// end ;
40532: LD_VAR 0 3
40536: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
40537: LD_INT 0
40539: PPUSH
// if not mc_bases [ base ] then
40540: LD_EXP 49
40544: PUSH
40545: LD_VAR 0 1
40549: ARRAY
40550: NOT
40551: IFFALSE 40555
// exit ;
40553: GO 40580
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
40555: LD_ADDR_EXP 60
40559: PUSH
40560: LD_EXP 60
40564: PPUSH
40565: LD_VAR 0 1
40569: PPUSH
40570: LD_VAR 0 2
40574: PPUSH
40575: CALL_OW 1
40579: ST_TO_ADDR
// end ;
40580: LD_VAR 0 3
40584: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
40585: LD_INT 0
40587: PPUSH
40588: PPUSH
40589: PPUSH
40590: PPUSH
// if not mc_bases [ base ] then
40591: LD_EXP 49
40595: PUSH
40596: LD_VAR 0 1
40600: ARRAY
40601: NOT
40602: IFFALSE 40606
// exit ;
40604: GO 40671
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
40606: LD_ADDR_EXP 69
40610: PUSH
40611: LD_EXP 69
40615: PPUSH
40616: LD_VAR 0 1
40620: PUSH
40621: LD_EXP 69
40625: PUSH
40626: LD_VAR 0 1
40630: ARRAY
40631: PUSH
40632: LD_INT 1
40634: PLUS
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PPUSH
40640: LD_VAR 0 1
40644: PUSH
40645: LD_VAR 0 2
40649: PUSH
40650: LD_VAR 0 3
40654: PUSH
40655: LD_VAR 0 4
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: LIST
40664: LIST
40665: PPUSH
40666: CALL 53698 0 3
40670: ST_TO_ADDR
// end ;
40671: LD_VAR 0 5
40675: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
40676: LD_INT 0
40678: PPUSH
// if not mc_bases [ base ] then
40679: LD_EXP 49
40683: PUSH
40684: LD_VAR 0 1
40688: ARRAY
40689: NOT
40690: IFFALSE 40694
// exit ;
40692: GO 40719
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
40694: LD_ADDR_EXP 86
40698: PUSH
40699: LD_EXP 86
40703: PPUSH
40704: LD_VAR 0 1
40708: PPUSH
40709: LD_VAR 0 2
40713: PPUSH
40714: CALL_OW 1
40718: ST_TO_ADDR
// end ;
40719: LD_VAR 0 3
40723: RET
// export function MC_GetMinesField ( base ) ; begin
40724: LD_INT 0
40726: PPUSH
// result := mc_mines [ base ] ;
40727: LD_ADDR_VAR 0 2
40731: PUSH
40732: LD_EXP 62
40736: PUSH
40737: LD_VAR 0 1
40741: ARRAY
40742: ST_TO_ADDR
// end ;
40743: LD_VAR 0 2
40747: RET
// export function MC_GetProduceList ( base ) ; begin
40748: LD_INT 0
40750: PPUSH
// result := mc_produce [ base ] ;
40751: LD_ADDR_VAR 0 2
40755: PUSH
40756: LD_EXP 70
40760: PUSH
40761: LD_VAR 0 1
40765: ARRAY
40766: ST_TO_ADDR
// end ;
40767: LD_VAR 0 2
40771: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
40772: LD_INT 0
40774: PPUSH
40775: PPUSH
// if not mc_bases then
40776: LD_EXP 49
40780: NOT
40781: IFFALSE 40785
// exit ;
40783: GO 40850
// if mc_bases [ base ] then
40785: LD_EXP 49
40789: PUSH
40790: LD_VAR 0 1
40794: ARRAY
40795: IFFALSE 40850
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
40797: LD_ADDR_VAR 0 3
40801: PUSH
40802: LD_EXP 49
40806: PUSH
40807: LD_VAR 0 1
40811: ARRAY
40812: PPUSH
40813: LD_INT 30
40815: PUSH
40816: LD_VAR 0 2
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PPUSH
40825: CALL_OW 72
40829: ST_TO_ADDR
// if result then
40830: LD_VAR 0 3
40834: IFFALSE 40850
// result := result [ 1 ] ;
40836: LD_ADDR_VAR 0 3
40840: PUSH
40841: LD_VAR 0 3
40845: PUSH
40846: LD_INT 1
40848: ARRAY
40849: ST_TO_ADDR
// end ; end ;
40850: LD_VAR 0 3
40854: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
40855: LD_INT 0
40857: PPUSH
40858: PPUSH
// if not mc_bases then
40859: LD_EXP 49
40863: NOT
40864: IFFALSE 40868
// exit ;
40866: GO 40913
// if mc_bases [ base ] then
40868: LD_EXP 49
40872: PUSH
40873: LD_VAR 0 1
40877: ARRAY
40878: IFFALSE 40913
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
40880: LD_ADDR_VAR 0 3
40884: PUSH
40885: LD_EXP 49
40889: PUSH
40890: LD_VAR 0 1
40894: ARRAY
40895: PPUSH
40896: LD_INT 30
40898: PUSH
40899: LD_VAR 0 2
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PPUSH
40908: CALL_OW 72
40912: ST_TO_ADDR
// end ;
40913: LD_VAR 0 3
40917: RET
// export function MC_SetTame ( base , area ) ; begin
40918: LD_INT 0
40920: PPUSH
// if not mc_bases or not base then
40921: LD_EXP 49
40925: NOT
40926: PUSH
40927: LD_VAR 0 1
40931: NOT
40932: OR
40933: IFFALSE 40937
// exit ;
40935: GO 40962
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
40937: LD_ADDR_EXP 77
40941: PUSH
40942: LD_EXP 77
40946: PPUSH
40947: LD_VAR 0 1
40951: PPUSH
40952: LD_VAR 0 2
40956: PPUSH
40957: CALL_OW 1
40961: ST_TO_ADDR
// end ;
40962: LD_VAR 0 3
40966: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
40967: LD_INT 0
40969: PPUSH
40970: PPUSH
// if not mc_bases or not base then
40971: LD_EXP 49
40975: NOT
40976: PUSH
40977: LD_VAR 0 1
40981: NOT
40982: OR
40983: IFFALSE 40987
// exit ;
40985: GO 41089
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
40987: LD_ADDR_VAR 0 4
40991: PUSH
40992: LD_EXP 49
40996: PUSH
40997: LD_VAR 0 1
41001: ARRAY
41002: PPUSH
41003: LD_INT 30
41005: PUSH
41006: LD_VAR 0 2
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: PPUSH
41015: CALL_OW 72
41019: ST_TO_ADDR
// if not tmp then
41020: LD_VAR 0 4
41024: NOT
41025: IFFALSE 41029
// exit ;
41027: GO 41089
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
41029: LD_ADDR_EXP 81
41033: PUSH
41034: LD_EXP 81
41038: PPUSH
41039: LD_VAR 0 1
41043: PPUSH
41044: LD_EXP 81
41048: PUSH
41049: LD_VAR 0 1
41053: ARRAY
41054: PPUSH
41055: LD_EXP 81
41059: PUSH
41060: LD_VAR 0 1
41064: ARRAY
41065: PUSH
41066: LD_INT 1
41068: PLUS
41069: PPUSH
41070: LD_VAR 0 4
41074: PUSH
41075: LD_INT 1
41077: ARRAY
41078: PPUSH
41079: CALL_OW 2
41083: PPUSH
41084: CALL_OW 1
41088: ST_TO_ADDR
// end ;
41089: LD_VAR 0 3
41093: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
41094: LD_INT 0
41096: PPUSH
41097: PPUSH
// if not mc_bases or not base or not kinds then
41098: LD_EXP 49
41102: NOT
41103: PUSH
41104: LD_VAR 0 1
41108: NOT
41109: OR
41110: PUSH
41111: LD_VAR 0 2
41115: NOT
41116: OR
41117: IFFALSE 41121
// exit ;
41119: GO 41182
// for i in kinds do
41121: LD_ADDR_VAR 0 4
41125: PUSH
41126: LD_VAR 0 2
41130: PUSH
41131: FOR_IN
41132: IFFALSE 41180
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
41134: LD_ADDR_EXP 83
41138: PUSH
41139: LD_EXP 83
41143: PPUSH
41144: LD_VAR 0 1
41148: PUSH
41149: LD_EXP 83
41153: PUSH
41154: LD_VAR 0 1
41158: ARRAY
41159: PUSH
41160: LD_INT 1
41162: PLUS
41163: PUSH
41164: EMPTY
41165: LIST
41166: LIST
41167: PPUSH
41168: LD_VAR 0 4
41172: PPUSH
41173: CALL 53698 0 3
41177: ST_TO_ADDR
41178: GO 41131
41180: POP
41181: POP
// end ;
41182: LD_VAR 0 3
41186: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
41187: LD_INT 0
41189: PPUSH
// if not mc_bases or not base or not areas then
41190: LD_EXP 49
41194: NOT
41195: PUSH
41196: LD_VAR 0 1
41200: NOT
41201: OR
41202: PUSH
41203: LD_VAR 0 2
41207: NOT
41208: OR
41209: IFFALSE 41213
// exit ;
41211: GO 41238
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
41213: LD_ADDR_EXP 67
41217: PUSH
41218: LD_EXP 67
41222: PPUSH
41223: LD_VAR 0 1
41227: PPUSH
41228: LD_VAR 0 2
41232: PPUSH
41233: CALL_OW 1
41237: ST_TO_ADDR
// end ;
41238: LD_VAR 0 3
41242: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
41243: LD_INT 0
41245: PPUSH
// if not mc_bases or not base or not teleports_exit then
41246: LD_EXP 49
41250: NOT
41251: PUSH
41252: LD_VAR 0 1
41256: NOT
41257: OR
41258: PUSH
41259: LD_VAR 0 2
41263: NOT
41264: OR
41265: IFFALSE 41269
// exit ;
41267: GO 41294
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
41269: LD_ADDR_EXP 84
41273: PUSH
41274: LD_EXP 84
41278: PPUSH
41279: LD_VAR 0 1
41283: PPUSH
41284: LD_VAR 0 2
41288: PPUSH
41289: CALL_OW 1
41293: ST_TO_ADDR
// end ;
41294: LD_VAR 0 3
41298: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
41299: LD_INT 0
41301: PPUSH
41302: PPUSH
41303: PPUSH
// if not mc_bases or not base or not ext_list then
41304: LD_EXP 49
41308: NOT
41309: PUSH
41310: LD_VAR 0 1
41314: NOT
41315: OR
41316: PUSH
41317: LD_VAR 0 5
41321: NOT
41322: OR
41323: IFFALSE 41327
// exit ;
41325: GO 41500
// tmp := GetFacExtXYD ( x , y , d ) ;
41327: LD_ADDR_VAR 0 8
41331: PUSH
41332: LD_VAR 0 2
41336: PPUSH
41337: LD_VAR 0 3
41341: PPUSH
41342: LD_VAR 0 4
41346: PPUSH
41347: CALL 87076 0 3
41351: ST_TO_ADDR
// if not tmp then
41352: LD_VAR 0 8
41356: NOT
41357: IFFALSE 41361
// exit ;
41359: GO 41500
// for i in tmp do
41361: LD_ADDR_VAR 0 7
41365: PUSH
41366: LD_VAR 0 8
41370: PUSH
41371: FOR_IN
41372: IFFALSE 41498
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
41374: LD_ADDR_EXP 54
41378: PUSH
41379: LD_EXP 54
41383: PPUSH
41384: LD_VAR 0 1
41388: PPUSH
41389: LD_EXP 54
41393: PUSH
41394: LD_VAR 0 1
41398: ARRAY
41399: PPUSH
41400: LD_EXP 54
41404: PUSH
41405: LD_VAR 0 1
41409: ARRAY
41410: PUSH
41411: LD_INT 1
41413: PLUS
41414: PPUSH
41415: LD_VAR 0 5
41419: PUSH
41420: LD_INT 1
41422: ARRAY
41423: PUSH
41424: LD_VAR 0 7
41428: PUSH
41429: LD_INT 1
41431: ARRAY
41432: PUSH
41433: LD_VAR 0 7
41437: PUSH
41438: LD_INT 2
41440: ARRAY
41441: PUSH
41442: LD_VAR 0 7
41446: PUSH
41447: LD_INT 3
41449: ARRAY
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: PPUSH
41457: CALL_OW 2
41461: PPUSH
41462: CALL_OW 1
41466: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
41467: LD_ADDR_VAR 0 5
41471: PUSH
41472: LD_VAR 0 5
41476: PPUSH
41477: LD_INT 1
41479: PPUSH
41480: CALL_OW 3
41484: ST_TO_ADDR
// if not ext_list then
41485: LD_VAR 0 5
41489: NOT
41490: IFFALSE 41496
// exit ;
41492: POP
41493: POP
41494: GO 41500
// end ;
41496: GO 41371
41498: POP
41499: POP
// end ;
41500: LD_VAR 0 6
41504: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
41505: LD_INT 0
41507: PPUSH
// if not mc_bases or not base or not weapon_list then
41508: LD_EXP 49
41512: NOT
41513: PUSH
41514: LD_VAR 0 1
41518: NOT
41519: OR
41520: PUSH
41521: LD_VAR 0 2
41525: NOT
41526: OR
41527: IFFALSE 41531
// exit ;
41529: GO 41556
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
41531: LD_ADDR_EXP 88
41535: PUSH
41536: LD_EXP 88
41540: PPUSH
41541: LD_VAR 0 1
41545: PPUSH
41546: LD_VAR 0 2
41550: PPUSH
41551: CALL_OW 1
41555: ST_TO_ADDR
// end ;
41556: LD_VAR 0 3
41560: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
41561: LD_INT 0
41563: PPUSH
// if not mc_bases or not base or not tech_list then
41564: LD_EXP 49
41568: NOT
41569: PUSH
41570: LD_VAR 0 1
41574: NOT
41575: OR
41576: PUSH
41577: LD_VAR 0 2
41581: NOT
41582: OR
41583: IFFALSE 41587
// exit ;
41585: GO 41612
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
41587: LD_ADDR_EXP 76
41591: PUSH
41592: LD_EXP 76
41596: PPUSH
41597: LD_VAR 0 1
41601: PPUSH
41602: LD_VAR 0 2
41606: PPUSH
41607: CALL_OW 1
41611: ST_TO_ADDR
// end ;
41612: LD_VAR 0 3
41616: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
41617: LD_INT 0
41619: PPUSH
// if not mc_bases or not parking_area or not base then
41620: LD_EXP 49
41624: NOT
41625: PUSH
41626: LD_VAR 0 2
41630: NOT
41631: OR
41632: PUSH
41633: LD_VAR 0 1
41637: NOT
41638: OR
41639: IFFALSE 41643
// exit ;
41641: GO 41668
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
41643: LD_ADDR_EXP 73
41647: PUSH
41648: LD_EXP 73
41652: PPUSH
41653: LD_VAR 0 1
41657: PPUSH
41658: LD_VAR 0 2
41662: PPUSH
41663: CALL_OW 1
41667: ST_TO_ADDR
// end ;
41668: LD_VAR 0 3
41672: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
41673: LD_INT 0
41675: PPUSH
// if not mc_bases or not base or not scan_area then
41676: LD_EXP 49
41680: NOT
41681: PUSH
41682: LD_VAR 0 1
41686: NOT
41687: OR
41688: PUSH
41689: LD_VAR 0 2
41693: NOT
41694: OR
41695: IFFALSE 41699
// exit ;
41697: GO 41724
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
41699: LD_ADDR_EXP 74
41703: PUSH
41704: LD_EXP 74
41708: PPUSH
41709: LD_VAR 0 1
41713: PPUSH
41714: LD_VAR 0 2
41718: PPUSH
41719: CALL_OW 1
41723: ST_TO_ADDR
// end ;
41724: LD_VAR 0 3
41728: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
41729: LD_INT 0
41731: PPUSH
41732: PPUSH
// if not mc_bases or not base then
41733: LD_EXP 49
41737: NOT
41738: PUSH
41739: LD_VAR 0 1
41743: NOT
41744: OR
41745: IFFALSE 41749
// exit ;
41747: GO 41813
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
41749: LD_ADDR_VAR 0 3
41753: PUSH
41754: LD_INT 1
41756: PUSH
41757: LD_INT 2
41759: PUSH
41760: LD_INT 3
41762: PUSH
41763: LD_INT 4
41765: PUSH
41766: LD_INT 11
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: LIST
41773: LIST
41774: LIST
41775: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
41776: LD_ADDR_EXP 76
41780: PUSH
41781: LD_EXP 76
41785: PPUSH
41786: LD_VAR 0 1
41790: PPUSH
41791: LD_EXP 76
41795: PUSH
41796: LD_VAR 0 1
41800: ARRAY
41801: PUSH
41802: LD_VAR 0 3
41806: DIFF
41807: PPUSH
41808: CALL_OW 1
41812: ST_TO_ADDR
// end ;
41813: LD_VAR 0 2
41817: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
41818: LD_INT 0
41820: PPUSH
// result := mc_vehicles [ base ] ;
41821: LD_ADDR_VAR 0 3
41825: PUSH
41826: LD_EXP 68
41830: PUSH
41831: LD_VAR 0 1
41835: ARRAY
41836: ST_TO_ADDR
// if onlyCombat then
41837: LD_VAR 0 2
41841: IFFALSE 42006
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
41843: LD_ADDR_VAR 0 3
41847: PUSH
41848: LD_VAR 0 3
41852: PUSH
41853: LD_VAR 0 3
41857: PPUSH
41858: LD_INT 2
41860: PUSH
41861: LD_INT 34
41863: PUSH
41864: LD_INT 12
41866: PUSH
41867: EMPTY
41868: LIST
41869: LIST
41870: PUSH
41871: LD_INT 34
41873: PUSH
41874: LD_INT 51
41876: PUSH
41877: EMPTY
41878: LIST
41879: LIST
41880: PUSH
41881: LD_INT 34
41883: PUSH
41884: LD_EXP 93
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: PUSH
41893: LD_INT 34
41895: PUSH
41896: LD_INT 32
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: PUSH
41903: LD_INT 34
41905: PUSH
41906: LD_INT 13
41908: PUSH
41909: EMPTY
41910: LIST
41911: LIST
41912: PUSH
41913: LD_INT 34
41915: PUSH
41916: LD_INT 52
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 34
41925: PUSH
41926: LD_INT 14
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 34
41935: PUSH
41936: LD_INT 53
41938: PUSH
41939: EMPTY
41940: LIST
41941: LIST
41942: PUSH
41943: LD_INT 34
41945: PUSH
41946: LD_EXP 92
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: LD_INT 34
41957: PUSH
41958: LD_INT 31
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 34
41967: PUSH
41968: LD_INT 48
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 34
41977: PUSH
41978: LD_INT 8
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: LIST
41989: LIST
41990: LIST
41991: LIST
41992: LIST
41993: LIST
41994: LIST
41995: LIST
41996: LIST
41997: LIST
41998: LIST
41999: PPUSH
42000: CALL_OW 72
42004: DIFF
42005: ST_TO_ADDR
// end ; end_of_file
42006: LD_VAR 0 3
42010: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
42011: LD_INT 0
42013: PPUSH
42014: PPUSH
42015: PPUSH
// if not mc_bases or not skirmish then
42016: LD_EXP 49
42020: NOT
42021: PUSH
42022: LD_EXP 47
42026: NOT
42027: OR
42028: IFFALSE 42032
// exit ;
42030: GO 42197
// for i = 1 to mc_bases do
42032: LD_ADDR_VAR 0 4
42036: PUSH
42037: DOUBLE
42038: LD_INT 1
42040: DEC
42041: ST_TO_ADDR
42042: LD_EXP 49
42046: PUSH
42047: FOR_TO
42048: IFFALSE 42195
// begin if sci in mc_bases [ i ] then
42050: LD_VAR 0 2
42054: PUSH
42055: LD_EXP 49
42059: PUSH
42060: LD_VAR 0 4
42064: ARRAY
42065: IN
42066: IFFALSE 42193
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
42068: LD_ADDR_EXP 78
42072: PUSH
42073: LD_EXP 78
42077: PPUSH
42078: LD_VAR 0 4
42082: PUSH
42083: LD_EXP 78
42087: PUSH
42088: LD_VAR 0 4
42092: ARRAY
42093: PUSH
42094: LD_INT 1
42096: PLUS
42097: PUSH
42098: EMPTY
42099: LIST
42100: LIST
42101: PPUSH
42102: LD_VAR 0 1
42106: PPUSH
42107: CALL 53698 0 3
42111: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
42112: LD_ADDR_VAR 0 5
42116: PUSH
42117: LD_EXP 49
42121: PUSH
42122: LD_VAR 0 4
42126: ARRAY
42127: PPUSH
42128: LD_INT 2
42130: PUSH
42131: LD_INT 30
42133: PUSH
42134: LD_INT 0
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 30
42143: PUSH
42144: LD_INT 1
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: LIST
42155: PPUSH
42156: CALL_OW 72
42160: PPUSH
42161: LD_VAR 0 1
42165: PPUSH
42166: CALL_OW 74
42170: ST_TO_ADDR
// if tmp then
42171: LD_VAR 0 5
42175: IFFALSE 42191
// ComStandNearbyBuilding ( ape , tmp ) ;
42177: LD_VAR 0 1
42181: PPUSH
42182: LD_VAR 0 5
42186: PPUSH
42187: CALL 48050 0 2
// break ;
42191: GO 42195
// end ; end ;
42193: GO 42047
42195: POP
42196: POP
// end ;
42197: LD_VAR 0 3
42201: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
42202: LD_INT 0
42204: PPUSH
42205: PPUSH
42206: PPUSH
// if not mc_bases or not skirmish then
42207: LD_EXP 49
42211: NOT
42212: PUSH
42213: LD_EXP 47
42217: NOT
42218: OR
42219: IFFALSE 42223
// exit ;
42221: GO 42312
// for i = 1 to mc_bases do
42223: LD_ADDR_VAR 0 4
42227: PUSH
42228: DOUBLE
42229: LD_INT 1
42231: DEC
42232: ST_TO_ADDR
42233: LD_EXP 49
42237: PUSH
42238: FOR_TO
42239: IFFALSE 42310
// begin if building in mc_busy_turret_list [ i ] then
42241: LD_VAR 0 1
42245: PUSH
42246: LD_EXP 59
42250: PUSH
42251: LD_VAR 0 4
42255: ARRAY
42256: IN
42257: IFFALSE 42308
// begin tmp := mc_busy_turret_list [ i ] diff building ;
42259: LD_ADDR_VAR 0 5
42263: PUSH
42264: LD_EXP 59
42268: PUSH
42269: LD_VAR 0 4
42273: ARRAY
42274: PUSH
42275: LD_VAR 0 1
42279: DIFF
42280: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
42281: LD_ADDR_EXP 59
42285: PUSH
42286: LD_EXP 59
42290: PPUSH
42291: LD_VAR 0 4
42295: PPUSH
42296: LD_VAR 0 5
42300: PPUSH
42301: CALL_OW 1
42305: ST_TO_ADDR
// break ;
42306: GO 42310
// end ; end ;
42308: GO 42238
42310: POP
42311: POP
// end ;
42312: LD_VAR 0 3
42316: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
42317: LD_INT 0
42319: PPUSH
42320: PPUSH
42321: PPUSH
// if not mc_bases or not skirmish then
42322: LD_EXP 49
42326: NOT
42327: PUSH
42328: LD_EXP 47
42332: NOT
42333: OR
42334: IFFALSE 42338
// exit ;
42336: GO 42537
// for i = 1 to mc_bases do
42338: LD_ADDR_VAR 0 5
42342: PUSH
42343: DOUBLE
42344: LD_INT 1
42346: DEC
42347: ST_TO_ADDR
42348: LD_EXP 49
42352: PUSH
42353: FOR_TO
42354: IFFALSE 42535
// if building in mc_bases [ i ] then
42356: LD_VAR 0 1
42360: PUSH
42361: LD_EXP 49
42365: PUSH
42366: LD_VAR 0 5
42370: ARRAY
42371: IN
42372: IFFALSE 42533
// begin tmp := mc_bases [ i ] diff building ;
42374: LD_ADDR_VAR 0 6
42378: PUSH
42379: LD_EXP 49
42383: PUSH
42384: LD_VAR 0 5
42388: ARRAY
42389: PUSH
42390: LD_VAR 0 1
42394: DIFF
42395: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
42396: LD_ADDR_EXP 49
42400: PUSH
42401: LD_EXP 49
42405: PPUSH
42406: LD_VAR 0 5
42410: PPUSH
42411: LD_VAR 0 6
42415: PPUSH
42416: CALL_OW 1
42420: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
42421: LD_VAR 0 1
42425: PUSH
42426: LD_EXP 57
42430: PUSH
42431: LD_VAR 0 5
42435: ARRAY
42436: IN
42437: IFFALSE 42476
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
42439: LD_ADDR_EXP 57
42443: PUSH
42444: LD_EXP 57
42448: PPUSH
42449: LD_VAR 0 5
42453: PPUSH
42454: LD_EXP 57
42458: PUSH
42459: LD_VAR 0 5
42463: ARRAY
42464: PUSH
42465: LD_VAR 0 1
42469: DIFF
42470: PPUSH
42471: CALL_OW 1
42475: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
42476: LD_VAR 0 1
42480: PUSH
42481: LD_EXP 58
42485: PUSH
42486: LD_VAR 0 5
42490: ARRAY
42491: IN
42492: IFFALSE 42531
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
42494: LD_ADDR_EXP 58
42498: PUSH
42499: LD_EXP 58
42503: PPUSH
42504: LD_VAR 0 5
42508: PPUSH
42509: LD_EXP 58
42513: PUSH
42514: LD_VAR 0 5
42518: ARRAY
42519: PUSH
42520: LD_VAR 0 1
42524: DIFF
42525: PPUSH
42526: CALL_OW 1
42530: ST_TO_ADDR
// break ;
42531: GO 42535
// end ;
42533: GO 42353
42535: POP
42536: POP
// end ;
42537: LD_VAR 0 4
42541: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
42542: LD_INT 0
42544: PPUSH
42545: PPUSH
42546: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
42547: LD_EXP 49
42551: NOT
42552: PUSH
42553: LD_EXP 47
42557: NOT
42558: OR
42559: PUSH
42560: LD_VAR 0 3
42564: PUSH
42565: LD_EXP 75
42569: IN
42570: NOT
42571: OR
42572: IFFALSE 42576
// exit ;
42574: GO 42699
// for i = 1 to mc_vehicles do
42576: LD_ADDR_VAR 0 6
42580: PUSH
42581: DOUBLE
42582: LD_INT 1
42584: DEC
42585: ST_TO_ADDR
42586: LD_EXP 68
42590: PUSH
42591: FOR_TO
42592: IFFALSE 42697
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
42594: LD_VAR 0 2
42598: PUSH
42599: LD_EXP 68
42603: PUSH
42604: LD_VAR 0 6
42608: ARRAY
42609: IN
42610: PUSH
42611: LD_VAR 0 1
42615: PUSH
42616: LD_EXP 68
42620: PUSH
42621: LD_VAR 0 6
42625: ARRAY
42626: IN
42627: OR
42628: IFFALSE 42695
// begin tmp := mc_vehicles [ i ] diff old ;
42630: LD_ADDR_VAR 0 7
42634: PUSH
42635: LD_EXP 68
42639: PUSH
42640: LD_VAR 0 6
42644: ARRAY
42645: PUSH
42646: LD_VAR 0 2
42650: DIFF
42651: ST_TO_ADDR
// tmp := tmp diff new ;
42652: LD_ADDR_VAR 0 7
42656: PUSH
42657: LD_VAR 0 7
42661: PUSH
42662: LD_VAR 0 1
42666: DIFF
42667: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
42668: LD_ADDR_EXP 68
42672: PUSH
42673: LD_EXP 68
42677: PPUSH
42678: LD_VAR 0 6
42682: PPUSH
42683: LD_VAR 0 7
42687: PPUSH
42688: CALL_OW 1
42692: ST_TO_ADDR
// break ;
42693: GO 42697
// end ;
42695: GO 42591
42697: POP
42698: POP
// end ;
42699: LD_VAR 0 5
42703: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
42704: LD_INT 0
42706: PPUSH
42707: PPUSH
42708: PPUSH
42709: PPUSH
// if not mc_bases or not skirmish then
42710: LD_EXP 49
42714: NOT
42715: PUSH
42716: LD_EXP 47
42720: NOT
42721: OR
42722: IFFALSE 42726
// exit ;
42724: GO 43103
// side := GetSide ( vehicle ) ;
42726: LD_ADDR_VAR 0 5
42730: PUSH
42731: LD_VAR 0 1
42735: PPUSH
42736: CALL_OW 255
42740: ST_TO_ADDR
// for i = 1 to mc_bases do
42741: LD_ADDR_VAR 0 4
42745: PUSH
42746: DOUBLE
42747: LD_INT 1
42749: DEC
42750: ST_TO_ADDR
42751: LD_EXP 49
42755: PUSH
42756: FOR_TO
42757: IFFALSE 43101
// begin if factory in mc_bases [ i ] then
42759: LD_VAR 0 2
42763: PUSH
42764: LD_EXP 49
42768: PUSH
42769: LD_VAR 0 4
42773: ARRAY
42774: IN
42775: IFFALSE 43099
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
42777: LD_EXP 71
42781: PUSH
42782: LD_VAR 0 4
42786: ARRAY
42787: PUSH
42788: LD_EXP 60
42792: PUSH
42793: LD_VAR 0 4
42797: ARRAY
42798: LESS
42799: PUSH
42800: LD_VAR 0 1
42804: PPUSH
42805: CALL_OW 264
42809: PUSH
42810: LD_INT 31
42812: PUSH
42813: LD_INT 32
42815: PUSH
42816: LD_INT 51
42818: PUSH
42819: LD_EXP 93
42823: PUSH
42824: LD_INT 12
42826: PUSH
42827: LD_INT 30
42829: PUSH
42830: LD_EXP 92
42834: PUSH
42835: LD_INT 11
42837: PUSH
42838: LD_INT 53
42840: PUSH
42841: LD_INT 14
42843: PUSH
42844: LD_EXP 96
42848: PUSH
42849: LD_INT 29
42851: PUSH
42852: LD_EXP 94
42856: PUSH
42857: LD_INT 13
42859: PUSH
42860: LD_INT 52
42862: PUSH
42863: LD_INT 48
42865: PUSH
42866: LD_INT 8
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: LIST
42873: LIST
42874: LIST
42875: LIST
42876: LIST
42877: LIST
42878: LIST
42879: LIST
42880: LIST
42881: LIST
42882: LIST
42883: LIST
42884: LIST
42885: LIST
42886: LIST
42887: IN
42888: NOT
42889: AND
42890: IFFALSE 42938
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
42892: LD_ADDR_EXP 71
42896: PUSH
42897: LD_EXP 71
42901: PPUSH
42902: LD_VAR 0 4
42906: PUSH
42907: LD_EXP 71
42911: PUSH
42912: LD_VAR 0 4
42916: ARRAY
42917: PUSH
42918: LD_INT 1
42920: PLUS
42921: PUSH
42922: EMPTY
42923: LIST
42924: LIST
42925: PPUSH
42926: LD_VAR 0 1
42930: PPUSH
42931: CALL 53698 0 3
42935: ST_TO_ADDR
42936: GO 42982
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
42938: LD_ADDR_EXP 68
42942: PUSH
42943: LD_EXP 68
42947: PPUSH
42948: LD_VAR 0 4
42952: PUSH
42953: LD_EXP 68
42957: PUSH
42958: LD_VAR 0 4
42962: ARRAY
42963: PUSH
42964: LD_INT 1
42966: PLUS
42967: PUSH
42968: EMPTY
42969: LIST
42970: LIST
42971: PPUSH
42972: LD_VAR 0 1
42976: PPUSH
42977: CALL 53698 0 3
42981: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
42982: LD_VAR 0 1
42986: PPUSH
42987: CALL_OW 263
42991: PUSH
42992: LD_INT 2
42994: EQUAL
42995: IFFALSE 43015
// begin repeat wait ( 0 0$1 ) ;
42997: LD_INT 35
42999: PPUSH
43000: CALL_OW 67
// until IsControledBy ( vehicle ) ;
43004: LD_VAR 0 1
43008: PPUSH
43009: CALL_OW 312
43013: IFFALSE 42997
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
43015: LD_VAR 0 1
43019: PPUSH
43020: LD_EXP 73
43024: PUSH
43025: LD_VAR 0 4
43029: ARRAY
43030: PPUSH
43031: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
43035: LD_VAR 0 1
43039: PPUSH
43040: CALL_OW 263
43044: PUSH
43045: LD_INT 1
43047: NONEQUAL
43048: IFFALSE 43052
// break ;
43050: GO 43101
// repeat wait ( 0 0$1 ) ;
43052: LD_INT 35
43054: PPUSH
43055: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
43059: LD_VAR 0 1
43063: PPUSH
43064: LD_EXP 73
43068: PUSH
43069: LD_VAR 0 4
43073: ARRAY
43074: PPUSH
43075: CALL_OW 308
43079: IFFALSE 43052
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
43081: LD_VAR 0 1
43085: PPUSH
43086: CALL_OW 311
43090: PPUSH
43091: CALL_OW 121
// exit ;
43095: POP
43096: POP
43097: GO 43103
// end ; end ;
43099: GO 42756
43101: POP
43102: POP
// end ;
43103: LD_VAR 0 3
43107: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
43108: LD_INT 0
43110: PPUSH
43111: PPUSH
43112: PPUSH
43113: PPUSH
// if not mc_bases or not skirmish then
43114: LD_EXP 49
43118: NOT
43119: PUSH
43120: LD_EXP 47
43124: NOT
43125: OR
43126: IFFALSE 43130
// exit ;
43128: GO 43483
// repeat wait ( 0 0$1 ) ;
43130: LD_INT 35
43132: PPUSH
43133: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
43137: LD_VAR 0 2
43141: PPUSH
43142: LD_VAR 0 3
43146: PPUSH
43147: CALL_OW 284
43151: IFFALSE 43130
// if GetResourceTypeXY ( x , y ) = mat_artefact then
43153: LD_VAR 0 2
43157: PPUSH
43158: LD_VAR 0 3
43162: PPUSH
43163: CALL_OW 283
43167: PUSH
43168: LD_INT 4
43170: EQUAL
43171: IFFALSE 43175
// exit ;
43173: GO 43483
// for i = 1 to mc_bases do
43175: LD_ADDR_VAR 0 7
43179: PUSH
43180: DOUBLE
43181: LD_INT 1
43183: DEC
43184: ST_TO_ADDR
43185: LD_EXP 49
43189: PUSH
43190: FOR_TO
43191: IFFALSE 43481
// begin if mc_crates_area [ i ] then
43193: LD_EXP 67
43197: PUSH
43198: LD_VAR 0 7
43202: ARRAY
43203: IFFALSE 43314
// for j in mc_crates_area [ i ] do
43205: LD_ADDR_VAR 0 8
43209: PUSH
43210: LD_EXP 67
43214: PUSH
43215: LD_VAR 0 7
43219: ARRAY
43220: PUSH
43221: FOR_IN
43222: IFFALSE 43312
// if InArea ( x , y , j ) then
43224: LD_VAR 0 2
43228: PPUSH
43229: LD_VAR 0 3
43233: PPUSH
43234: LD_VAR 0 8
43238: PPUSH
43239: CALL_OW 309
43243: IFFALSE 43310
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43245: LD_ADDR_EXP 65
43249: PUSH
43250: LD_EXP 65
43254: PPUSH
43255: LD_VAR 0 7
43259: PUSH
43260: LD_EXP 65
43264: PUSH
43265: LD_VAR 0 7
43269: ARRAY
43270: PUSH
43271: LD_INT 1
43273: PLUS
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PPUSH
43279: LD_VAR 0 4
43283: PUSH
43284: LD_VAR 0 2
43288: PUSH
43289: LD_VAR 0 3
43293: PUSH
43294: EMPTY
43295: LIST
43296: LIST
43297: LIST
43298: PPUSH
43299: CALL 53698 0 3
43303: ST_TO_ADDR
// exit ;
43304: POP
43305: POP
43306: POP
43307: POP
43308: GO 43483
// end ;
43310: GO 43221
43312: POP
43313: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43314: LD_ADDR_VAR 0 9
43318: PUSH
43319: LD_EXP 49
43323: PUSH
43324: LD_VAR 0 7
43328: ARRAY
43329: PPUSH
43330: LD_INT 2
43332: PUSH
43333: LD_INT 30
43335: PUSH
43336: LD_INT 0
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 30
43345: PUSH
43346: LD_INT 1
43348: PUSH
43349: EMPTY
43350: LIST
43351: LIST
43352: PUSH
43353: EMPTY
43354: LIST
43355: LIST
43356: LIST
43357: PPUSH
43358: CALL_OW 72
43362: ST_TO_ADDR
// if not depot then
43363: LD_VAR 0 9
43367: NOT
43368: IFFALSE 43372
// continue ;
43370: GO 43190
// for j in depot do
43372: LD_ADDR_VAR 0 8
43376: PUSH
43377: LD_VAR 0 9
43381: PUSH
43382: FOR_IN
43383: IFFALSE 43477
// if GetDistUnitXY ( j , x , y ) < 30 then
43385: LD_VAR 0 8
43389: PPUSH
43390: LD_VAR 0 2
43394: PPUSH
43395: LD_VAR 0 3
43399: PPUSH
43400: CALL_OW 297
43404: PUSH
43405: LD_INT 30
43407: LESS
43408: IFFALSE 43475
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43410: LD_ADDR_EXP 65
43414: PUSH
43415: LD_EXP 65
43419: PPUSH
43420: LD_VAR 0 7
43424: PUSH
43425: LD_EXP 65
43429: PUSH
43430: LD_VAR 0 7
43434: ARRAY
43435: PUSH
43436: LD_INT 1
43438: PLUS
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PPUSH
43444: LD_VAR 0 4
43448: PUSH
43449: LD_VAR 0 2
43453: PUSH
43454: LD_VAR 0 3
43458: PUSH
43459: EMPTY
43460: LIST
43461: LIST
43462: LIST
43463: PPUSH
43464: CALL 53698 0 3
43468: ST_TO_ADDR
// exit ;
43469: POP
43470: POP
43471: POP
43472: POP
43473: GO 43483
// end ;
43475: GO 43382
43477: POP
43478: POP
// end ;
43479: GO 43190
43481: POP
43482: POP
// end ;
43483: LD_VAR 0 6
43487: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
43488: LD_INT 0
43490: PPUSH
43491: PPUSH
43492: PPUSH
43493: PPUSH
// if not mc_bases or not skirmish then
43494: LD_EXP 49
43498: NOT
43499: PUSH
43500: LD_EXP 47
43504: NOT
43505: OR
43506: IFFALSE 43510
// exit ;
43508: GO 43787
// side := GetSide ( lab ) ;
43510: LD_ADDR_VAR 0 4
43514: PUSH
43515: LD_VAR 0 2
43519: PPUSH
43520: CALL_OW 255
43524: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
43525: LD_VAR 0 4
43529: PUSH
43530: LD_EXP 75
43534: IN
43535: NOT
43536: PUSH
43537: LD_EXP 76
43541: NOT
43542: OR
43543: PUSH
43544: LD_EXP 49
43548: NOT
43549: OR
43550: IFFALSE 43554
// exit ;
43552: GO 43787
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
43554: LD_ADDR_EXP 76
43558: PUSH
43559: LD_EXP 76
43563: PPUSH
43564: LD_VAR 0 4
43568: PPUSH
43569: LD_EXP 76
43573: PUSH
43574: LD_VAR 0 4
43578: ARRAY
43579: PUSH
43580: LD_VAR 0 1
43584: DIFF
43585: PPUSH
43586: CALL_OW 1
43590: ST_TO_ADDR
// for i = 1 to mc_bases do
43591: LD_ADDR_VAR 0 5
43595: PUSH
43596: DOUBLE
43597: LD_INT 1
43599: DEC
43600: ST_TO_ADDR
43601: LD_EXP 49
43605: PUSH
43606: FOR_TO
43607: IFFALSE 43785
// begin if lab in mc_bases [ i ] then
43609: LD_VAR 0 2
43613: PUSH
43614: LD_EXP 49
43618: PUSH
43619: LD_VAR 0 5
43623: ARRAY
43624: IN
43625: IFFALSE 43783
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
43627: LD_VAR 0 1
43631: PUSH
43632: LD_INT 11
43634: PUSH
43635: LD_INT 4
43637: PUSH
43638: LD_INT 3
43640: PUSH
43641: LD_INT 2
43643: PUSH
43644: EMPTY
43645: LIST
43646: LIST
43647: LIST
43648: LIST
43649: IN
43650: PUSH
43651: LD_EXP 79
43655: PUSH
43656: LD_VAR 0 5
43660: ARRAY
43661: AND
43662: IFFALSE 43783
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
43664: LD_ADDR_VAR 0 6
43668: PUSH
43669: LD_EXP 79
43673: PUSH
43674: LD_VAR 0 5
43678: ARRAY
43679: PUSH
43680: LD_INT 1
43682: ARRAY
43683: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
43684: LD_ADDR_EXP 79
43688: PUSH
43689: LD_EXP 79
43693: PPUSH
43694: LD_VAR 0 5
43698: PPUSH
43699: EMPTY
43700: PPUSH
43701: CALL_OW 1
43705: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
43706: LD_VAR 0 6
43710: PPUSH
43711: LD_INT 0
43713: PPUSH
43714: CALL_OW 109
// ComExitBuilding ( tmp ) ;
43718: LD_VAR 0 6
43722: PPUSH
43723: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
43727: LD_ADDR_EXP 78
43731: PUSH
43732: LD_EXP 78
43736: PPUSH
43737: LD_VAR 0 5
43741: PPUSH
43742: LD_EXP 78
43746: PUSH
43747: LD_VAR 0 5
43751: ARRAY
43752: PPUSH
43753: LD_INT 1
43755: PPUSH
43756: LD_VAR 0 6
43760: PPUSH
43761: CALL_OW 2
43765: PPUSH
43766: CALL_OW 1
43770: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
43771: LD_VAR 0 5
43775: PPUSH
43776: LD_INT 112
43778: PPUSH
43779: CALL 20895 0 2
// end ; end ; end ;
43783: GO 43606
43785: POP
43786: POP
// end ;
43787: LD_VAR 0 3
43791: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
43792: LD_INT 0
43794: PPUSH
43795: PPUSH
43796: PPUSH
43797: PPUSH
43798: PPUSH
43799: PPUSH
43800: PPUSH
43801: PPUSH
// if not mc_bases or not skirmish then
43802: LD_EXP 49
43806: NOT
43807: PUSH
43808: LD_EXP 47
43812: NOT
43813: OR
43814: IFFALSE 43818
// exit ;
43816: GO 45055
// for i = 1 to mc_bases do
43818: LD_ADDR_VAR 0 3
43822: PUSH
43823: DOUBLE
43824: LD_INT 1
43826: DEC
43827: ST_TO_ADDR
43828: LD_EXP 49
43832: PUSH
43833: FOR_TO
43834: IFFALSE 45053
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
43836: LD_VAR 0 1
43840: PUSH
43841: LD_EXP 49
43845: PUSH
43846: LD_VAR 0 3
43850: ARRAY
43851: IN
43852: PUSH
43853: LD_VAR 0 1
43857: PUSH
43858: LD_EXP 56
43862: PUSH
43863: LD_VAR 0 3
43867: ARRAY
43868: IN
43869: OR
43870: PUSH
43871: LD_VAR 0 1
43875: PUSH
43876: LD_EXP 71
43880: PUSH
43881: LD_VAR 0 3
43885: ARRAY
43886: IN
43887: OR
43888: PUSH
43889: LD_VAR 0 1
43893: PUSH
43894: LD_EXP 68
43898: PUSH
43899: LD_VAR 0 3
43903: ARRAY
43904: IN
43905: OR
43906: PUSH
43907: LD_VAR 0 1
43911: PUSH
43912: LD_EXP 78
43916: PUSH
43917: LD_VAR 0 3
43921: ARRAY
43922: IN
43923: OR
43924: PUSH
43925: LD_VAR 0 1
43929: PUSH
43930: LD_EXP 79
43934: PUSH
43935: LD_VAR 0 3
43939: ARRAY
43940: IN
43941: OR
43942: IFFALSE 45051
// begin if un in mc_ape [ i ] then
43944: LD_VAR 0 1
43948: PUSH
43949: LD_EXP 78
43953: PUSH
43954: LD_VAR 0 3
43958: ARRAY
43959: IN
43960: IFFALSE 43999
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
43962: LD_ADDR_EXP 78
43966: PUSH
43967: LD_EXP 78
43971: PPUSH
43972: LD_VAR 0 3
43976: PPUSH
43977: LD_EXP 78
43981: PUSH
43982: LD_VAR 0 3
43986: ARRAY
43987: PUSH
43988: LD_VAR 0 1
43992: DIFF
43993: PPUSH
43994: CALL_OW 1
43998: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
43999: LD_VAR 0 1
44003: PUSH
44004: LD_EXP 79
44008: PUSH
44009: LD_VAR 0 3
44013: ARRAY
44014: IN
44015: IFFALSE 44039
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44017: LD_ADDR_EXP 79
44021: PUSH
44022: LD_EXP 79
44026: PPUSH
44027: LD_VAR 0 3
44031: PPUSH
44032: EMPTY
44033: PPUSH
44034: CALL_OW 1
44038: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
44039: LD_VAR 0 1
44043: PPUSH
44044: CALL_OW 247
44048: PUSH
44049: LD_INT 2
44051: EQUAL
44052: PUSH
44053: LD_VAR 0 1
44057: PPUSH
44058: CALL_OW 110
44062: PUSH
44063: LD_INT 20
44065: EQUAL
44066: PUSH
44067: LD_VAR 0 1
44071: PUSH
44072: LD_EXP 71
44076: PUSH
44077: LD_VAR 0 3
44081: ARRAY
44082: IN
44083: OR
44084: PUSH
44085: LD_VAR 0 1
44089: PPUSH
44090: CALL_OW 264
44094: PUSH
44095: LD_INT 12
44097: PUSH
44098: LD_INT 51
44100: PUSH
44101: LD_EXP 93
44105: PUSH
44106: LD_INT 32
44108: PUSH
44109: LD_INT 13
44111: PUSH
44112: LD_INT 52
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: LIST
44119: LIST
44120: LIST
44121: LIST
44122: IN
44123: OR
44124: AND
44125: IFFALSE 44303
// begin if un in mc_defender [ i ] then
44127: LD_VAR 0 1
44131: PUSH
44132: LD_EXP 71
44136: PUSH
44137: LD_VAR 0 3
44141: ARRAY
44142: IN
44143: IFFALSE 44182
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
44145: LD_ADDR_EXP 71
44149: PUSH
44150: LD_EXP 71
44154: PPUSH
44155: LD_VAR 0 3
44159: PPUSH
44160: LD_EXP 71
44164: PUSH
44165: LD_VAR 0 3
44169: ARRAY
44170: PUSH
44171: LD_VAR 0 1
44175: DIFF
44176: PPUSH
44177: CALL_OW 1
44181: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
44182: LD_ADDR_VAR 0 8
44186: PUSH
44187: LD_VAR 0 3
44191: PPUSH
44192: LD_INT 3
44194: PPUSH
44195: CALL 40855 0 2
44199: ST_TO_ADDR
// if fac then
44200: LD_VAR 0 8
44204: IFFALSE 44303
// begin for j in fac do
44206: LD_ADDR_VAR 0 4
44210: PUSH
44211: LD_VAR 0 8
44215: PUSH
44216: FOR_IN
44217: IFFALSE 44301
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
44219: LD_ADDR_VAR 0 9
44223: PUSH
44224: LD_VAR 0 8
44228: PPUSH
44229: LD_VAR 0 1
44233: PPUSH
44234: CALL_OW 265
44238: PPUSH
44239: LD_VAR 0 1
44243: PPUSH
44244: CALL_OW 262
44248: PPUSH
44249: LD_VAR 0 1
44253: PPUSH
44254: CALL_OW 263
44258: PPUSH
44259: LD_VAR 0 1
44263: PPUSH
44264: CALL_OW 264
44268: PPUSH
44269: CALL 51230 0 5
44273: ST_TO_ADDR
// if components then
44274: LD_VAR 0 9
44278: IFFALSE 44299
// begin MC_InsertProduceList ( i , [ components ] ) ;
44280: LD_VAR 0 3
44284: PPUSH
44285: LD_VAR 0 9
44289: PUSH
44290: EMPTY
44291: LIST
44292: PPUSH
44293: CALL 40400 0 2
// break ;
44297: GO 44301
// end ; end ;
44299: GO 44216
44301: POP
44302: POP
// end ; end ; if GetType ( un ) = unit_building then
44303: LD_VAR 0 1
44307: PPUSH
44308: CALL_OW 247
44312: PUSH
44313: LD_INT 3
44315: EQUAL
44316: IFFALSE 44719
// begin btype := GetBType ( un ) ;
44318: LD_ADDR_VAR 0 5
44322: PUSH
44323: LD_VAR 0 1
44327: PPUSH
44328: CALL_OW 266
44332: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
44333: LD_VAR 0 5
44337: PUSH
44338: LD_INT 29
44340: PUSH
44341: LD_INT 30
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: IN
44348: IFFALSE 44421
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
44350: LD_VAR 0 1
44354: PPUSH
44355: CALL_OW 250
44359: PPUSH
44360: LD_VAR 0 1
44364: PPUSH
44365: CALL_OW 251
44369: PPUSH
44370: LD_VAR 0 1
44374: PPUSH
44375: CALL_OW 255
44379: PPUSH
44380: CALL_OW 440
44384: NOT
44385: IFFALSE 44421
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
44387: LD_VAR 0 1
44391: PPUSH
44392: CALL_OW 250
44396: PPUSH
44397: LD_VAR 0 1
44401: PPUSH
44402: CALL_OW 251
44406: PPUSH
44407: LD_VAR 0 1
44411: PPUSH
44412: CALL_OW 255
44416: PPUSH
44417: CALL_OW 441
// end ; if btype = b_warehouse then
44421: LD_VAR 0 5
44425: PUSH
44426: LD_INT 1
44428: EQUAL
44429: IFFALSE 44447
// begin btype := b_depot ;
44431: LD_ADDR_VAR 0 5
44435: PUSH
44436: LD_INT 0
44438: ST_TO_ADDR
// pos := 1 ;
44439: LD_ADDR_VAR 0 6
44443: PUSH
44444: LD_INT 1
44446: ST_TO_ADDR
// end ; if btype = b_factory then
44447: LD_VAR 0 5
44451: PUSH
44452: LD_INT 3
44454: EQUAL
44455: IFFALSE 44473
// begin btype := b_workshop ;
44457: LD_ADDR_VAR 0 5
44461: PUSH
44462: LD_INT 2
44464: ST_TO_ADDR
// pos := 1 ;
44465: LD_ADDR_VAR 0 6
44469: PUSH
44470: LD_INT 1
44472: ST_TO_ADDR
// end ; if btype = b_barracks then
44473: LD_VAR 0 5
44477: PUSH
44478: LD_INT 5
44480: EQUAL
44481: IFFALSE 44491
// btype := b_armoury ;
44483: LD_ADDR_VAR 0 5
44487: PUSH
44488: LD_INT 4
44490: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
44491: LD_VAR 0 5
44495: PUSH
44496: LD_INT 7
44498: PUSH
44499: LD_INT 8
44501: PUSH
44502: EMPTY
44503: LIST
44504: LIST
44505: IN
44506: IFFALSE 44516
// btype := b_lab ;
44508: LD_ADDR_VAR 0 5
44512: PUSH
44513: LD_INT 6
44515: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
44516: LD_ADDR_EXP 54
44520: PUSH
44521: LD_EXP 54
44525: PPUSH
44526: LD_VAR 0 3
44530: PUSH
44531: LD_EXP 54
44535: PUSH
44536: LD_VAR 0 3
44540: ARRAY
44541: PUSH
44542: LD_INT 1
44544: PLUS
44545: PUSH
44546: EMPTY
44547: LIST
44548: LIST
44549: PPUSH
44550: LD_VAR 0 5
44554: PUSH
44555: LD_VAR 0 1
44559: PPUSH
44560: CALL_OW 250
44564: PUSH
44565: LD_VAR 0 1
44569: PPUSH
44570: CALL_OW 251
44574: PUSH
44575: LD_VAR 0 1
44579: PPUSH
44580: CALL_OW 254
44584: PUSH
44585: EMPTY
44586: LIST
44587: LIST
44588: LIST
44589: LIST
44590: PPUSH
44591: CALL 53698 0 3
44595: ST_TO_ADDR
// if pos = 1 then
44596: LD_VAR 0 6
44600: PUSH
44601: LD_INT 1
44603: EQUAL
44604: IFFALSE 44719
// begin tmp := mc_build_list [ i ] ;
44606: LD_ADDR_VAR 0 7
44610: PUSH
44611: LD_EXP 54
44615: PUSH
44616: LD_VAR 0 3
44620: ARRAY
44621: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44622: LD_VAR 0 7
44626: PPUSH
44627: LD_INT 2
44629: PUSH
44630: LD_INT 30
44632: PUSH
44633: LD_INT 0
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: PUSH
44640: LD_INT 30
44642: PUSH
44643: LD_INT 1
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: PUSH
44650: EMPTY
44651: LIST
44652: LIST
44653: LIST
44654: PPUSH
44655: CALL_OW 72
44659: IFFALSE 44669
// pos := 2 ;
44661: LD_ADDR_VAR 0 6
44665: PUSH
44666: LD_INT 2
44668: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
44669: LD_ADDR_VAR 0 7
44673: PUSH
44674: LD_VAR 0 7
44678: PPUSH
44679: LD_VAR 0 6
44683: PPUSH
44684: LD_VAR 0 7
44688: PPUSH
44689: CALL 54024 0 3
44693: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
44694: LD_ADDR_EXP 54
44698: PUSH
44699: LD_EXP 54
44703: PPUSH
44704: LD_VAR 0 3
44708: PPUSH
44709: LD_VAR 0 7
44713: PPUSH
44714: CALL_OW 1
44718: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
44719: LD_VAR 0 1
44723: PUSH
44724: LD_EXP 49
44728: PUSH
44729: LD_VAR 0 3
44733: ARRAY
44734: IN
44735: IFFALSE 44774
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
44737: LD_ADDR_EXP 49
44741: PUSH
44742: LD_EXP 49
44746: PPUSH
44747: LD_VAR 0 3
44751: PPUSH
44752: LD_EXP 49
44756: PUSH
44757: LD_VAR 0 3
44761: ARRAY
44762: PUSH
44763: LD_VAR 0 1
44767: DIFF
44768: PPUSH
44769: CALL_OW 1
44773: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
44774: LD_VAR 0 1
44778: PUSH
44779: LD_EXP 56
44783: PUSH
44784: LD_VAR 0 3
44788: ARRAY
44789: IN
44790: IFFALSE 44829
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
44792: LD_ADDR_EXP 56
44796: PUSH
44797: LD_EXP 56
44801: PPUSH
44802: LD_VAR 0 3
44806: PPUSH
44807: LD_EXP 56
44811: PUSH
44812: LD_VAR 0 3
44816: ARRAY
44817: PUSH
44818: LD_VAR 0 1
44822: DIFF
44823: PPUSH
44824: CALL_OW 1
44828: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
44829: LD_VAR 0 1
44833: PUSH
44834: LD_EXP 68
44838: PUSH
44839: LD_VAR 0 3
44843: ARRAY
44844: IN
44845: IFFALSE 44884
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
44847: LD_ADDR_EXP 68
44851: PUSH
44852: LD_EXP 68
44856: PPUSH
44857: LD_VAR 0 3
44861: PPUSH
44862: LD_EXP 68
44866: PUSH
44867: LD_VAR 0 3
44871: ARRAY
44872: PUSH
44873: LD_VAR 0 1
44877: DIFF
44878: PPUSH
44879: CALL_OW 1
44883: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
44884: LD_VAR 0 1
44888: PUSH
44889: LD_EXP 71
44893: PUSH
44894: LD_VAR 0 3
44898: ARRAY
44899: IN
44900: IFFALSE 44939
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
44902: LD_ADDR_EXP 71
44906: PUSH
44907: LD_EXP 71
44911: PPUSH
44912: LD_VAR 0 3
44916: PPUSH
44917: LD_EXP 71
44921: PUSH
44922: LD_VAR 0 3
44926: ARRAY
44927: PUSH
44928: LD_VAR 0 1
44932: DIFF
44933: PPUSH
44934: CALL_OW 1
44938: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
44939: LD_VAR 0 1
44943: PUSH
44944: LD_EXP 58
44948: PUSH
44949: LD_VAR 0 3
44953: ARRAY
44954: IN
44955: IFFALSE 44994
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
44957: LD_ADDR_EXP 58
44961: PUSH
44962: LD_EXP 58
44966: PPUSH
44967: LD_VAR 0 3
44971: PPUSH
44972: LD_EXP 58
44976: PUSH
44977: LD_VAR 0 3
44981: ARRAY
44982: PUSH
44983: LD_VAR 0 1
44987: DIFF
44988: PPUSH
44989: CALL_OW 1
44993: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
44994: LD_VAR 0 1
44998: PUSH
44999: LD_EXP 57
45003: PUSH
45004: LD_VAR 0 3
45008: ARRAY
45009: IN
45010: IFFALSE 45049
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
45012: LD_ADDR_EXP 57
45016: PUSH
45017: LD_EXP 57
45021: PPUSH
45022: LD_VAR 0 3
45026: PPUSH
45027: LD_EXP 57
45031: PUSH
45032: LD_VAR 0 3
45036: ARRAY
45037: PUSH
45038: LD_VAR 0 1
45042: DIFF
45043: PPUSH
45044: CALL_OW 1
45048: ST_TO_ADDR
// end ; break ;
45049: GO 45053
// end ;
45051: GO 43833
45053: POP
45054: POP
// end ;
45055: LD_VAR 0 2
45059: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
45060: LD_INT 0
45062: PPUSH
45063: PPUSH
45064: PPUSH
// if not mc_bases or not skirmish then
45065: LD_EXP 49
45069: NOT
45070: PUSH
45071: LD_EXP 47
45075: NOT
45076: OR
45077: IFFALSE 45081
// exit ;
45079: GO 45296
// for i = 1 to mc_bases do
45081: LD_ADDR_VAR 0 3
45085: PUSH
45086: DOUBLE
45087: LD_INT 1
45089: DEC
45090: ST_TO_ADDR
45091: LD_EXP 49
45095: PUSH
45096: FOR_TO
45097: IFFALSE 45294
// begin if building in mc_construct_list [ i ] then
45099: LD_VAR 0 1
45103: PUSH
45104: LD_EXP 56
45108: PUSH
45109: LD_VAR 0 3
45113: ARRAY
45114: IN
45115: IFFALSE 45292
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
45117: LD_ADDR_EXP 56
45121: PUSH
45122: LD_EXP 56
45126: PPUSH
45127: LD_VAR 0 3
45131: PPUSH
45132: LD_EXP 56
45136: PUSH
45137: LD_VAR 0 3
45141: ARRAY
45142: PUSH
45143: LD_VAR 0 1
45147: DIFF
45148: PPUSH
45149: CALL_OW 1
45153: ST_TO_ADDR
// if building in mc_lab [ i ] then
45154: LD_VAR 0 1
45158: PUSH
45159: LD_EXP 82
45163: PUSH
45164: LD_VAR 0 3
45168: ARRAY
45169: IN
45170: IFFALSE 45225
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
45172: LD_ADDR_EXP 83
45176: PUSH
45177: LD_EXP 83
45181: PPUSH
45182: LD_VAR 0 3
45186: PPUSH
45187: LD_EXP 83
45191: PUSH
45192: LD_VAR 0 3
45196: ARRAY
45197: PPUSH
45198: LD_INT 1
45200: PPUSH
45201: LD_EXP 83
45205: PUSH
45206: LD_VAR 0 3
45210: ARRAY
45211: PPUSH
45212: LD_INT 0
45214: PPUSH
45215: CALL 53116 0 4
45219: PPUSH
45220: CALL_OW 1
45224: ST_TO_ADDR
// if not building in mc_bases [ i ] then
45225: LD_VAR 0 1
45229: PUSH
45230: LD_EXP 49
45234: PUSH
45235: LD_VAR 0 3
45239: ARRAY
45240: IN
45241: NOT
45242: IFFALSE 45288
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
45244: LD_ADDR_EXP 49
45248: PUSH
45249: LD_EXP 49
45253: PPUSH
45254: LD_VAR 0 3
45258: PUSH
45259: LD_EXP 49
45263: PUSH
45264: LD_VAR 0 3
45268: ARRAY
45269: PUSH
45270: LD_INT 1
45272: PLUS
45273: PUSH
45274: EMPTY
45275: LIST
45276: LIST
45277: PPUSH
45278: LD_VAR 0 1
45282: PPUSH
45283: CALL 53698 0 3
45287: ST_TO_ADDR
// exit ;
45288: POP
45289: POP
45290: GO 45296
// end ; end ;
45292: GO 45096
45294: POP
45295: POP
// end ;
45296: LD_VAR 0 2
45300: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
45301: LD_INT 0
45303: PPUSH
45304: PPUSH
45305: PPUSH
45306: PPUSH
45307: PPUSH
45308: PPUSH
45309: PPUSH
// if not mc_bases or not skirmish then
45310: LD_EXP 49
45314: NOT
45315: PUSH
45316: LD_EXP 47
45320: NOT
45321: OR
45322: IFFALSE 45326
// exit ;
45324: GO 45987
// for i = 1 to mc_bases do
45326: LD_ADDR_VAR 0 3
45330: PUSH
45331: DOUBLE
45332: LD_INT 1
45334: DEC
45335: ST_TO_ADDR
45336: LD_EXP 49
45340: PUSH
45341: FOR_TO
45342: IFFALSE 45985
// begin if building in mc_construct_list [ i ] then
45344: LD_VAR 0 1
45348: PUSH
45349: LD_EXP 56
45353: PUSH
45354: LD_VAR 0 3
45358: ARRAY
45359: IN
45360: IFFALSE 45983
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
45362: LD_ADDR_EXP 56
45366: PUSH
45367: LD_EXP 56
45371: PPUSH
45372: LD_VAR 0 3
45376: PPUSH
45377: LD_EXP 56
45381: PUSH
45382: LD_VAR 0 3
45386: ARRAY
45387: PUSH
45388: LD_VAR 0 1
45392: DIFF
45393: PPUSH
45394: CALL_OW 1
45398: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
45399: LD_ADDR_EXP 49
45403: PUSH
45404: LD_EXP 49
45408: PPUSH
45409: LD_VAR 0 3
45413: PUSH
45414: LD_EXP 49
45418: PUSH
45419: LD_VAR 0 3
45423: ARRAY
45424: PUSH
45425: LD_INT 1
45427: PLUS
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PPUSH
45433: LD_VAR 0 1
45437: PPUSH
45438: CALL 53698 0 3
45442: ST_TO_ADDR
// btype := GetBType ( building ) ;
45443: LD_ADDR_VAR 0 5
45447: PUSH
45448: LD_VAR 0 1
45452: PPUSH
45453: CALL_OW 266
45457: ST_TO_ADDR
// side := GetSide ( building ) ;
45458: LD_ADDR_VAR 0 8
45462: PUSH
45463: LD_VAR 0 1
45467: PPUSH
45468: CALL_OW 255
45472: ST_TO_ADDR
// if btype = b_lab then
45473: LD_VAR 0 5
45477: PUSH
45478: LD_INT 6
45480: EQUAL
45481: IFFALSE 45531
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
45483: LD_ADDR_EXP 82
45487: PUSH
45488: LD_EXP 82
45492: PPUSH
45493: LD_VAR 0 3
45497: PUSH
45498: LD_EXP 82
45502: PUSH
45503: LD_VAR 0 3
45507: ARRAY
45508: PUSH
45509: LD_INT 1
45511: PLUS
45512: PUSH
45513: EMPTY
45514: LIST
45515: LIST
45516: PPUSH
45517: LD_VAR 0 1
45521: PPUSH
45522: CALL 53698 0 3
45526: ST_TO_ADDR
// exit ;
45527: POP
45528: POP
45529: GO 45987
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
45531: LD_VAR 0 5
45535: PUSH
45536: LD_INT 0
45538: PUSH
45539: LD_INT 2
45541: PUSH
45542: LD_INT 4
45544: PUSH
45545: EMPTY
45546: LIST
45547: LIST
45548: LIST
45549: IN
45550: IFFALSE 45674
// begin if btype = b_armoury then
45552: LD_VAR 0 5
45556: PUSH
45557: LD_INT 4
45559: EQUAL
45560: IFFALSE 45570
// btype := b_barracks ;
45562: LD_ADDR_VAR 0 5
45566: PUSH
45567: LD_INT 5
45569: ST_TO_ADDR
// if btype = b_depot then
45570: LD_VAR 0 5
45574: PUSH
45575: LD_INT 0
45577: EQUAL
45578: IFFALSE 45588
// btype := b_warehouse ;
45580: LD_ADDR_VAR 0 5
45584: PUSH
45585: LD_INT 1
45587: ST_TO_ADDR
// if btype = b_workshop then
45588: LD_VAR 0 5
45592: PUSH
45593: LD_INT 2
45595: EQUAL
45596: IFFALSE 45606
// btype := b_factory ;
45598: LD_ADDR_VAR 0 5
45602: PUSH
45603: LD_INT 3
45605: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
45606: LD_VAR 0 5
45610: PPUSH
45611: LD_VAR 0 8
45615: PPUSH
45616: CALL_OW 323
45620: PUSH
45621: LD_INT 1
45623: EQUAL
45624: IFFALSE 45670
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
45626: LD_ADDR_EXP 81
45630: PUSH
45631: LD_EXP 81
45635: PPUSH
45636: LD_VAR 0 3
45640: PUSH
45641: LD_EXP 81
45645: PUSH
45646: LD_VAR 0 3
45650: ARRAY
45651: PUSH
45652: LD_INT 1
45654: PLUS
45655: PUSH
45656: EMPTY
45657: LIST
45658: LIST
45659: PPUSH
45660: LD_VAR 0 1
45664: PPUSH
45665: CALL 53698 0 3
45669: ST_TO_ADDR
// exit ;
45670: POP
45671: POP
45672: GO 45987
// end ; if btype in [ b_bunker , b_turret ] then
45674: LD_VAR 0 5
45678: PUSH
45679: LD_INT 32
45681: PUSH
45682: LD_INT 33
45684: PUSH
45685: EMPTY
45686: LIST
45687: LIST
45688: IN
45689: IFFALSE 45979
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
45691: LD_ADDR_EXP 57
45695: PUSH
45696: LD_EXP 57
45700: PPUSH
45701: LD_VAR 0 3
45705: PUSH
45706: LD_EXP 57
45710: PUSH
45711: LD_VAR 0 3
45715: ARRAY
45716: PUSH
45717: LD_INT 1
45719: PLUS
45720: PUSH
45721: EMPTY
45722: LIST
45723: LIST
45724: PPUSH
45725: LD_VAR 0 1
45729: PPUSH
45730: CALL 53698 0 3
45734: ST_TO_ADDR
// if btype = b_bunker then
45735: LD_VAR 0 5
45739: PUSH
45740: LD_INT 32
45742: EQUAL
45743: IFFALSE 45979
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
45745: LD_ADDR_EXP 58
45749: PUSH
45750: LD_EXP 58
45754: PPUSH
45755: LD_VAR 0 3
45759: PUSH
45760: LD_EXP 58
45764: PUSH
45765: LD_VAR 0 3
45769: ARRAY
45770: PUSH
45771: LD_INT 1
45773: PLUS
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: PPUSH
45779: LD_VAR 0 1
45783: PPUSH
45784: CALL 53698 0 3
45788: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
45789: LD_ADDR_VAR 0 6
45793: PUSH
45794: LD_EXP 49
45798: PUSH
45799: LD_VAR 0 3
45803: ARRAY
45804: PPUSH
45805: LD_INT 25
45807: PUSH
45808: LD_INT 1
45810: PUSH
45811: EMPTY
45812: LIST
45813: LIST
45814: PUSH
45815: LD_INT 3
45817: PUSH
45818: LD_INT 54
45820: PUSH
45821: EMPTY
45822: LIST
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: EMPTY
45829: LIST
45830: LIST
45831: PPUSH
45832: CALL_OW 72
45836: ST_TO_ADDR
// if tmp then
45837: LD_VAR 0 6
45841: IFFALSE 45847
// exit ;
45843: POP
45844: POP
45845: GO 45987
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
45847: LD_ADDR_VAR 0 6
45851: PUSH
45852: LD_EXP 49
45856: PUSH
45857: LD_VAR 0 3
45861: ARRAY
45862: PPUSH
45863: LD_INT 2
45865: PUSH
45866: LD_INT 30
45868: PUSH
45869: LD_INT 4
45871: PUSH
45872: EMPTY
45873: LIST
45874: LIST
45875: PUSH
45876: LD_INT 30
45878: PUSH
45879: LD_INT 5
45881: PUSH
45882: EMPTY
45883: LIST
45884: LIST
45885: PUSH
45886: EMPTY
45887: LIST
45888: LIST
45889: LIST
45890: PPUSH
45891: CALL_OW 72
45895: ST_TO_ADDR
// if not tmp then
45896: LD_VAR 0 6
45900: NOT
45901: IFFALSE 45907
// exit ;
45903: POP
45904: POP
45905: GO 45987
// for j in tmp do
45907: LD_ADDR_VAR 0 4
45911: PUSH
45912: LD_VAR 0 6
45916: PUSH
45917: FOR_IN
45918: IFFALSE 45977
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
45920: LD_ADDR_VAR 0 7
45924: PUSH
45925: LD_VAR 0 4
45929: PPUSH
45930: CALL_OW 313
45934: PPUSH
45935: LD_INT 25
45937: PUSH
45938: LD_INT 1
45940: PUSH
45941: EMPTY
45942: LIST
45943: LIST
45944: PPUSH
45945: CALL_OW 72
45949: ST_TO_ADDR
// if units then
45950: LD_VAR 0 7
45954: IFFALSE 45975
// begin ComExitBuilding ( units [ 1 ] ) ;
45956: LD_VAR 0 7
45960: PUSH
45961: LD_INT 1
45963: ARRAY
45964: PPUSH
45965: CALL_OW 122
// exit ;
45969: POP
45970: POP
45971: POP
45972: POP
45973: GO 45987
// end ; end ;
45975: GO 45917
45977: POP
45978: POP
// end ; end ; exit ;
45979: POP
45980: POP
45981: GO 45987
// end ; end ;
45983: GO 45341
45985: POP
45986: POP
// end ;
45987: LD_VAR 0 2
45991: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
45992: LD_INT 0
45994: PPUSH
45995: PPUSH
45996: PPUSH
45997: PPUSH
45998: PPUSH
45999: PPUSH
46000: PPUSH
// if not mc_bases or not skirmish then
46001: LD_EXP 49
46005: NOT
46006: PUSH
46007: LD_EXP 47
46011: NOT
46012: OR
46013: IFFALSE 46017
// exit ;
46015: GO 46248
// btype := GetBType ( building ) ;
46017: LD_ADDR_VAR 0 6
46021: PUSH
46022: LD_VAR 0 1
46026: PPUSH
46027: CALL_OW 266
46031: ST_TO_ADDR
// x := GetX ( building ) ;
46032: LD_ADDR_VAR 0 7
46036: PUSH
46037: LD_VAR 0 1
46041: PPUSH
46042: CALL_OW 250
46046: ST_TO_ADDR
// y := GetY ( building ) ;
46047: LD_ADDR_VAR 0 8
46051: PUSH
46052: LD_VAR 0 1
46056: PPUSH
46057: CALL_OW 251
46061: ST_TO_ADDR
// d := GetDir ( building ) ;
46062: LD_ADDR_VAR 0 9
46066: PUSH
46067: LD_VAR 0 1
46071: PPUSH
46072: CALL_OW 254
46076: ST_TO_ADDR
// for i = 1 to mc_bases do
46077: LD_ADDR_VAR 0 4
46081: PUSH
46082: DOUBLE
46083: LD_INT 1
46085: DEC
46086: ST_TO_ADDR
46087: LD_EXP 49
46091: PUSH
46092: FOR_TO
46093: IFFALSE 46246
// begin if not mc_build_list [ i ] then
46095: LD_EXP 54
46099: PUSH
46100: LD_VAR 0 4
46104: ARRAY
46105: NOT
46106: IFFALSE 46110
// continue ;
46108: GO 46092
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
46110: LD_VAR 0 6
46114: PUSH
46115: LD_VAR 0 7
46119: PUSH
46120: LD_VAR 0 8
46124: PUSH
46125: LD_VAR 0 9
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: LIST
46134: LIST
46135: PPUSH
46136: LD_EXP 54
46140: PUSH
46141: LD_VAR 0 4
46145: ARRAY
46146: PUSH
46147: LD_INT 1
46149: ARRAY
46150: PPUSH
46151: CALL 59867 0 2
46155: IFFALSE 46244
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
46157: LD_ADDR_EXP 54
46161: PUSH
46162: LD_EXP 54
46166: PPUSH
46167: LD_VAR 0 4
46171: PPUSH
46172: LD_EXP 54
46176: PUSH
46177: LD_VAR 0 4
46181: ARRAY
46182: PPUSH
46183: LD_INT 1
46185: PPUSH
46186: CALL_OW 3
46190: PPUSH
46191: CALL_OW 1
46195: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
46196: LD_ADDR_EXP 56
46200: PUSH
46201: LD_EXP 56
46205: PPUSH
46206: LD_VAR 0 4
46210: PUSH
46211: LD_EXP 56
46215: PUSH
46216: LD_VAR 0 4
46220: ARRAY
46221: PUSH
46222: LD_INT 1
46224: PLUS
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: PPUSH
46230: LD_VAR 0 1
46234: PPUSH
46235: CALL 53698 0 3
46239: ST_TO_ADDR
// exit ;
46240: POP
46241: POP
46242: GO 46248
// end ; end ;
46244: GO 46092
46246: POP
46247: POP
// end ;
46248: LD_VAR 0 3
46252: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
46253: LD_INT 0
46255: PPUSH
46256: PPUSH
46257: PPUSH
// if not mc_bases or not skirmish then
46258: LD_EXP 49
46262: NOT
46263: PUSH
46264: LD_EXP 47
46268: NOT
46269: OR
46270: IFFALSE 46274
// exit ;
46272: GO 46464
// for i = 1 to mc_bases do
46274: LD_ADDR_VAR 0 4
46278: PUSH
46279: DOUBLE
46280: LD_INT 1
46282: DEC
46283: ST_TO_ADDR
46284: LD_EXP 49
46288: PUSH
46289: FOR_TO
46290: IFFALSE 46377
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
46292: LD_VAR 0 1
46296: PUSH
46297: LD_EXP 57
46301: PUSH
46302: LD_VAR 0 4
46306: ARRAY
46307: IN
46308: PUSH
46309: LD_VAR 0 1
46313: PUSH
46314: LD_EXP 58
46318: PUSH
46319: LD_VAR 0 4
46323: ARRAY
46324: IN
46325: NOT
46326: AND
46327: IFFALSE 46375
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46329: LD_ADDR_EXP 58
46333: PUSH
46334: LD_EXP 58
46338: PPUSH
46339: LD_VAR 0 4
46343: PUSH
46344: LD_EXP 58
46348: PUSH
46349: LD_VAR 0 4
46353: ARRAY
46354: PUSH
46355: LD_INT 1
46357: PLUS
46358: PUSH
46359: EMPTY
46360: LIST
46361: LIST
46362: PPUSH
46363: LD_VAR 0 1
46367: PPUSH
46368: CALL 53698 0 3
46372: ST_TO_ADDR
// break ;
46373: GO 46377
// end ; end ;
46375: GO 46289
46377: POP
46378: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
46379: LD_VAR 0 1
46383: PPUSH
46384: CALL_OW 257
46388: PUSH
46389: LD_EXP 75
46393: IN
46394: PUSH
46395: LD_VAR 0 1
46399: PPUSH
46400: CALL_OW 266
46404: PUSH
46405: LD_INT 5
46407: EQUAL
46408: AND
46409: PUSH
46410: LD_VAR 0 2
46414: PPUSH
46415: CALL_OW 110
46419: PUSH
46420: LD_INT 18
46422: NONEQUAL
46423: AND
46424: IFFALSE 46464
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
46426: LD_VAR 0 2
46430: PPUSH
46431: CALL_OW 257
46435: PUSH
46436: LD_INT 5
46438: PUSH
46439: LD_INT 8
46441: PUSH
46442: LD_INT 9
46444: PUSH
46445: EMPTY
46446: LIST
46447: LIST
46448: LIST
46449: IN
46450: IFFALSE 46464
// SetClass ( unit , 1 ) ;
46452: LD_VAR 0 2
46456: PPUSH
46457: LD_INT 1
46459: PPUSH
46460: CALL_OW 336
// end ;
46464: LD_VAR 0 3
46468: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
46469: LD_INT 0
46471: PPUSH
46472: PPUSH
// if not mc_bases or not skirmish then
46473: LD_EXP 49
46477: NOT
46478: PUSH
46479: LD_EXP 47
46483: NOT
46484: OR
46485: IFFALSE 46489
// exit ;
46487: GO 46605
// if GetLives ( abandoned_vehicle ) > 250 then
46489: LD_VAR 0 2
46493: PPUSH
46494: CALL_OW 256
46498: PUSH
46499: LD_INT 250
46501: GREATER
46502: IFFALSE 46506
// exit ;
46504: GO 46605
// for i = 1 to mc_bases do
46506: LD_ADDR_VAR 0 6
46510: PUSH
46511: DOUBLE
46512: LD_INT 1
46514: DEC
46515: ST_TO_ADDR
46516: LD_EXP 49
46520: PUSH
46521: FOR_TO
46522: IFFALSE 46603
// begin if driver in mc_bases [ i ] then
46524: LD_VAR 0 1
46528: PUSH
46529: LD_EXP 49
46533: PUSH
46534: LD_VAR 0 6
46538: ARRAY
46539: IN
46540: IFFALSE 46601
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
46542: LD_VAR 0 1
46546: PPUSH
46547: LD_EXP 49
46551: PUSH
46552: LD_VAR 0 6
46556: ARRAY
46557: PPUSH
46558: LD_INT 2
46560: PUSH
46561: LD_INT 30
46563: PUSH
46564: LD_INT 0
46566: PUSH
46567: EMPTY
46568: LIST
46569: LIST
46570: PUSH
46571: LD_INT 30
46573: PUSH
46574: LD_INT 1
46576: PUSH
46577: EMPTY
46578: LIST
46579: LIST
46580: PUSH
46581: EMPTY
46582: LIST
46583: LIST
46584: LIST
46585: PPUSH
46586: CALL_OW 72
46590: PUSH
46591: LD_INT 1
46593: ARRAY
46594: PPUSH
46595: CALL_OW 112
// break ;
46599: GO 46603
// end ; end ;
46601: GO 46521
46603: POP
46604: POP
// end ; end_of_file
46605: LD_VAR 0 5
46609: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
46610: LD_INT 0
46612: PPUSH
46613: PPUSH
// if exist_mode then
46614: LD_VAR 0 2
46618: IFFALSE 46643
// unit := CreateCharacter ( prefix & ident ) else
46620: LD_ADDR_VAR 0 5
46624: PUSH
46625: LD_VAR 0 3
46629: PUSH
46630: LD_VAR 0 1
46634: STR
46635: PPUSH
46636: CALL_OW 34
46640: ST_TO_ADDR
46641: GO 46658
// unit := NewCharacter ( ident ) ;
46643: LD_ADDR_VAR 0 5
46647: PUSH
46648: LD_VAR 0 1
46652: PPUSH
46653: CALL_OW 25
46657: ST_TO_ADDR
// result := unit ;
46658: LD_ADDR_VAR 0 4
46662: PUSH
46663: LD_VAR 0 5
46667: ST_TO_ADDR
// end ;
46668: LD_VAR 0 4
46672: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
46673: LD_INT 0
46675: PPUSH
46676: PPUSH
// if not side or not nation then
46677: LD_VAR 0 1
46681: NOT
46682: PUSH
46683: LD_VAR 0 2
46687: NOT
46688: OR
46689: IFFALSE 46693
// exit ;
46691: GO 47337
// case nation of nation_american :
46693: LD_VAR 0 2
46697: PUSH
46698: LD_INT 1
46700: DOUBLE
46701: EQUAL
46702: IFTRUE 46706
46704: GO 46880
46706: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
46707: LD_ADDR_VAR 0 4
46711: PUSH
46712: LD_INT 35
46714: PUSH
46715: LD_INT 45
46717: PUSH
46718: LD_INT 46
46720: PUSH
46721: LD_INT 47
46723: PUSH
46724: LD_INT 1
46726: PUSH
46727: LD_INT 2
46729: PUSH
46730: LD_INT 6
46732: PUSH
46733: LD_INT 15
46735: PUSH
46736: LD_INT 16
46738: PUSH
46739: LD_INT 7
46741: PUSH
46742: LD_INT 12
46744: PUSH
46745: LD_INT 13
46747: PUSH
46748: LD_INT 10
46750: PUSH
46751: LD_INT 14
46753: PUSH
46754: LD_INT 20
46756: PUSH
46757: LD_INT 21
46759: PUSH
46760: LD_INT 22
46762: PUSH
46763: LD_INT 25
46765: PUSH
46766: LD_INT 32
46768: PUSH
46769: LD_INT 27
46771: PUSH
46772: LD_INT 36
46774: PUSH
46775: LD_INT 69
46777: PUSH
46778: LD_INT 39
46780: PUSH
46781: LD_INT 34
46783: PUSH
46784: LD_INT 40
46786: PUSH
46787: LD_INT 48
46789: PUSH
46790: LD_INT 49
46792: PUSH
46793: LD_INT 50
46795: PUSH
46796: LD_INT 51
46798: PUSH
46799: LD_INT 52
46801: PUSH
46802: LD_INT 53
46804: PUSH
46805: LD_INT 54
46807: PUSH
46808: LD_INT 55
46810: PUSH
46811: LD_INT 56
46813: PUSH
46814: LD_INT 57
46816: PUSH
46817: LD_INT 58
46819: PUSH
46820: LD_INT 59
46822: PUSH
46823: LD_INT 60
46825: PUSH
46826: LD_INT 61
46828: PUSH
46829: LD_INT 62
46831: PUSH
46832: LD_INT 80
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: LIST
46839: LIST
46840: LIST
46841: LIST
46842: LIST
46843: LIST
46844: LIST
46845: LIST
46846: LIST
46847: LIST
46848: LIST
46849: LIST
46850: LIST
46851: LIST
46852: LIST
46853: LIST
46854: LIST
46855: LIST
46856: LIST
46857: LIST
46858: LIST
46859: LIST
46860: LIST
46861: LIST
46862: LIST
46863: LIST
46864: LIST
46865: LIST
46866: LIST
46867: LIST
46868: LIST
46869: LIST
46870: LIST
46871: LIST
46872: LIST
46873: LIST
46874: LIST
46875: LIST
46876: LIST
46877: ST_TO_ADDR
46878: GO 47261
46880: LD_INT 2
46882: DOUBLE
46883: EQUAL
46884: IFTRUE 46888
46886: GO 47070
46888: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
46889: LD_ADDR_VAR 0 4
46893: PUSH
46894: LD_INT 35
46896: PUSH
46897: LD_INT 45
46899: PUSH
46900: LD_INT 46
46902: PUSH
46903: LD_INT 47
46905: PUSH
46906: LD_INT 70
46908: PUSH
46909: LD_INT 1
46911: PUSH
46912: LD_INT 11
46914: PUSH
46915: LD_INT 3
46917: PUSH
46918: LD_INT 4
46920: PUSH
46921: LD_INT 5
46923: PUSH
46924: LD_INT 6
46926: PUSH
46927: LD_INT 15
46929: PUSH
46930: LD_INT 18
46932: PUSH
46933: LD_INT 7
46935: PUSH
46936: LD_INT 17
46938: PUSH
46939: LD_INT 8
46941: PUSH
46942: LD_INT 20
46944: PUSH
46945: LD_INT 21
46947: PUSH
46948: LD_INT 22
46950: PUSH
46951: LD_INT 72
46953: PUSH
46954: LD_INT 26
46956: PUSH
46957: LD_INT 69
46959: PUSH
46960: LD_INT 39
46962: PUSH
46963: LD_INT 40
46965: PUSH
46966: LD_INT 41
46968: PUSH
46969: LD_INT 42
46971: PUSH
46972: LD_INT 43
46974: PUSH
46975: LD_INT 48
46977: PUSH
46978: LD_INT 49
46980: PUSH
46981: LD_INT 50
46983: PUSH
46984: LD_INT 51
46986: PUSH
46987: LD_INT 52
46989: PUSH
46990: LD_INT 53
46992: PUSH
46993: LD_INT 54
46995: PUSH
46996: LD_INT 55
46998: PUSH
46999: LD_INT 56
47001: PUSH
47002: LD_INT 60
47004: PUSH
47005: LD_INT 61
47007: PUSH
47008: LD_INT 62
47010: PUSH
47011: LD_INT 66
47013: PUSH
47014: LD_INT 67
47016: PUSH
47017: LD_INT 68
47019: PUSH
47020: LD_INT 81
47022: PUSH
47023: EMPTY
47024: LIST
47025: LIST
47026: LIST
47027: LIST
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: LIST
47044: LIST
47045: LIST
47046: LIST
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: LIST
47067: ST_TO_ADDR
47068: GO 47261
47070: LD_INT 3
47072: DOUBLE
47073: EQUAL
47074: IFTRUE 47078
47076: GO 47260
47078: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
47079: LD_ADDR_VAR 0 4
47083: PUSH
47084: LD_INT 46
47086: PUSH
47087: LD_INT 47
47089: PUSH
47090: LD_INT 1
47092: PUSH
47093: LD_INT 2
47095: PUSH
47096: LD_INT 11
47098: PUSH
47099: LD_INT 9
47101: PUSH
47102: LD_INT 20
47104: PUSH
47105: LD_INT 19
47107: PUSH
47108: LD_INT 21
47110: PUSH
47111: LD_INT 24
47113: PUSH
47114: LD_INT 22
47116: PUSH
47117: LD_INT 25
47119: PUSH
47120: LD_INT 28
47122: PUSH
47123: LD_INT 29
47125: PUSH
47126: LD_INT 30
47128: PUSH
47129: LD_INT 31
47131: PUSH
47132: LD_INT 37
47134: PUSH
47135: LD_INT 38
47137: PUSH
47138: LD_INT 32
47140: PUSH
47141: LD_INT 27
47143: PUSH
47144: LD_INT 33
47146: PUSH
47147: LD_INT 69
47149: PUSH
47150: LD_INT 39
47152: PUSH
47153: LD_INT 34
47155: PUSH
47156: LD_INT 40
47158: PUSH
47159: LD_INT 71
47161: PUSH
47162: LD_INT 23
47164: PUSH
47165: LD_INT 44
47167: PUSH
47168: LD_INT 48
47170: PUSH
47171: LD_INT 49
47173: PUSH
47174: LD_INT 50
47176: PUSH
47177: LD_INT 51
47179: PUSH
47180: LD_INT 52
47182: PUSH
47183: LD_INT 53
47185: PUSH
47186: LD_INT 54
47188: PUSH
47189: LD_INT 55
47191: PUSH
47192: LD_INT 56
47194: PUSH
47195: LD_INT 57
47197: PUSH
47198: LD_INT 58
47200: PUSH
47201: LD_INT 59
47203: PUSH
47204: LD_INT 63
47206: PUSH
47207: LD_INT 64
47209: PUSH
47210: LD_INT 65
47212: PUSH
47213: EMPTY
47214: LIST
47215: LIST
47216: LIST
47217: LIST
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: LIST
47228: LIST
47229: LIST
47230: LIST
47231: LIST
47232: LIST
47233: LIST
47234: LIST
47235: LIST
47236: LIST
47237: LIST
47238: LIST
47239: LIST
47240: LIST
47241: LIST
47242: LIST
47243: LIST
47244: LIST
47245: LIST
47246: LIST
47247: LIST
47248: LIST
47249: LIST
47250: LIST
47251: LIST
47252: LIST
47253: LIST
47254: LIST
47255: LIST
47256: LIST
47257: ST_TO_ADDR
47258: GO 47261
47260: POP
// if state > - 1 and state < 3 then
47261: LD_VAR 0 3
47265: PUSH
47266: LD_INT 1
47268: NEG
47269: GREATER
47270: PUSH
47271: LD_VAR 0 3
47275: PUSH
47276: LD_INT 3
47278: LESS
47279: AND
47280: IFFALSE 47337
// for i in result do
47282: LD_ADDR_VAR 0 5
47286: PUSH
47287: LD_VAR 0 4
47291: PUSH
47292: FOR_IN
47293: IFFALSE 47335
// if GetTech ( i , side ) <> state then
47295: LD_VAR 0 5
47299: PPUSH
47300: LD_VAR 0 1
47304: PPUSH
47305: CALL_OW 321
47309: PUSH
47310: LD_VAR 0 3
47314: NONEQUAL
47315: IFFALSE 47333
// result := result diff i ;
47317: LD_ADDR_VAR 0 4
47321: PUSH
47322: LD_VAR 0 4
47326: PUSH
47327: LD_VAR 0 5
47331: DIFF
47332: ST_TO_ADDR
47333: GO 47292
47335: POP
47336: POP
// end ;
47337: LD_VAR 0 4
47341: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
47342: LD_INT 0
47344: PPUSH
47345: PPUSH
47346: PPUSH
// result := true ;
47347: LD_ADDR_VAR 0 3
47351: PUSH
47352: LD_INT 1
47354: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
47355: LD_ADDR_VAR 0 5
47359: PUSH
47360: LD_VAR 0 2
47364: PPUSH
47365: CALL_OW 480
47369: ST_TO_ADDR
// if not tmp then
47370: LD_VAR 0 5
47374: NOT
47375: IFFALSE 47379
// exit ;
47377: GO 47428
// for i in tmp do
47379: LD_ADDR_VAR 0 4
47383: PUSH
47384: LD_VAR 0 5
47388: PUSH
47389: FOR_IN
47390: IFFALSE 47426
// if GetTech ( i , side ) <> state_researched then
47392: LD_VAR 0 4
47396: PPUSH
47397: LD_VAR 0 1
47401: PPUSH
47402: CALL_OW 321
47406: PUSH
47407: LD_INT 2
47409: NONEQUAL
47410: IFFALSE 47424
// begin result := false ;
47412: LD_ADDR_VAR 0 3
47416: PUSH
47417: LD_INT 0
47419: ST_TO_ADDR
// exit ;
47420: POP
47421: POP
47422: GO 47428
// end ;
47424: GO 47389
47426: POP
47427: POP
// end ;
47428: LD_VAR 0 3
47432: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
47433: LD_INT 0
47435: PPUSH
47436: PPUSH
47437: PPUSH
47438: PPUSH
47439: PPUSH
47440: PPUSH
47441: PPUSH
47442: PPUSH
47443: PPUSH
47444: PPUSH
47445: PPUSH
47446: PPUSH
47447: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
47448: LD_VAR 0 1
47452: NOT
47453: PUSH
47454: LD_VAR 0 1
47458: PPUSH
47459: CALL_OW 257
47463: PUSH
47464: LD_INT 9
47466: NONEQUAL
47467: OR
47468: IFFALSE 47472
// exit ;
47470: GO 48045
// side := GetSide ( unit ) ;
47472: LD_ADDR_VAR 0 9
47476: PUSH
47477: LD_VAR 0 1
47481: PPUSH
47482: CALL_OW 255
47486: ST_TO_ADDR
// tech_space := tech_spacanom ;
47487: LD_ADDR_VAR 0 12
47491: PUSH
47492: LD_INT 29
47494: ST_TO_ADDR
// tech_time := tech_taurad ;
47495: LD_ADDR_VAR 0 13
47499: PUSH
47500: LD_INT 28
47502: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
47503: LD_ADDR_VAR 0 11
47507: PUSH
47508: LD_VAR 0 1
47512: PPUSH
47513: CALL_OW 310
47517: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
47518: LD_VAR 0 11
47522: PPUSH
47523: CALL_OW 247
47527: PUSH
47528: LD_INT 2
47530: EQUAL
47531: IFFALSE 47535
// exit ;
47533: GO 48045
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
47535: LD_ADDR_VAR 0 8
47539: PUSH
47540: LD_INT 81
47542: PUSH
47543: LD_VAR 0 9
47547: PUSH
47548: EMPTY
47549: LIST
47550: LIST
47551: PUSH
47552: LD_INT 3
47554: PUSH
47555: LD_INT 21
47557: PUSH
47558: LD_INT 3
47560: PUSH
47561: EMPTY
47562: LIST
47563: LIST
47564: PUSH
47565: EMPTY
47566: LIST
47567: LIST
47568: PUSH
47569: EMPTY
47570: LIST
47571: LIST
47572: PPUSH
47573: CALL_OW 69
47577: ST_TO_ADDR
// if not tmp then
47578: LD_VAR 0 8
47582: NOT
47583: IFFALSE 47587
// exit ;
47585: GO 48045
// if in_unit then
47587: LD_VAR 0 11
47591: IFFALSE 47615
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
47593: LD_ADDR_VAR 0 10
47597: PUSH
47598: LD_VAR 0 8
47602: PPUSH
47603: LD_VAR 0 11
47607: PPUSH
47608: CALL_OW 74
47612: ST_TO_ADDR
47613: GO 47635
// enemy := NearestUnitToUnit ( tmp , unit ) ;
47615: LD_ADDR_VAR 0 10
47619: PUSH
47620: LD_VAR 0 8
47624: PPUSH
47625: LD_VAR 0 1
47629: PPUSH
47630: CALL_OW 74
47634: ST_TO_ADDR
// if not enemy then
47635: LD_VAR 0 10
47639: NOT
47640: IFFALSE 47644
// exit ;
47642: GO 48045
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
47644: LD_VAR 0 11
47648: PUSH
47649: LD_VAR 0 11
47653: PPUSH
47654: LD_VAR 0 10
47658: PPUSH
47659: CALL_OW 296
47663: PUSH
47664: LD_INT 13
47666: GREATER
47667: AND
47668: PUSH
47669: LD_VAR 0 1
47673: PPUSH
47674: LD_VAR 0 10
47678: PPUSH
47679: CALL_OW 296
47683: PUSH
47684: LD_INT 12
47686: GREATER
47687: OR
47688: IFFALSE 47692
// exit ;
47690: GO 48045
// missile := [ 1 ] ;
47692: LD_ADDR_VAR 0 14
47696: PUSH
47697: LD_INT 1
47699: PUSH
47700: EMPTY
47701: LIST
47702: ST_TO_ADDR
// if Researched ( side , tech_space ) then
47703: LD_VAR 0 9
47707: PPUSH
47708: LD_VAR 0 12
47712: PPUSH
47713: CALL_OW 325
47717: IFFALSE 47746
// missile := Insert ( missile , missile + 1 , 2 ) ;
47719: LD_ADDR_VAR 0 14
47723: PUSH
47724: LD_VAR 0 14
47728: PPUSH
47729: LD_VAR 0 14
47733: PUSH
47734: LD_INT 1
47736: PLUS
47737: PPUSH
47738: LD_INT 2
47740: PPUSH
47741: CALL_OW 2
47745: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
47746: LD_VAR 0 9
47750: PPUSH
47751: LD_VAR 0 13
47755: PPUSH
47756: CALL_OW 325
47760: PUSH
47761: LD_VAR 0 10
47765: PPUSH
47766: CALL_OW 255
47770: PPUSH
47771: LD_VAR 0 13
47775: PPUSH
47776: CALL_OW 325
47780: NOT
47781: AND
47782: IFFALSE 47811
// missile := Insert ( missile , missile + 1 , 3 ) ;
47784: LD_ADDR_VAR 0 14
47788: PUSH
47789: LD_VAR 0 14
47793: PPUSH
47794: LD_VAR 0 14
47798: PUSH
47799: LD_INT 1
47801: PLUS
47802: PPUSH
47803: LD_INT 3
47805: PPUSH
47806: CALL_OW 2
47810: ST_TO_ADDR
// if missile < 2 then
47811: LD_VAR 0 14
47815: PUSH
47816: LD_INT 2
47818: LESS
47819: IFFALSE 47823
// exit ;
47821: GO 48045
// x := GetX ( enemy ) ;
47823: LD_ADDR_VAR 0 4
47827: PUSH
47828: LD_VAR 0 10
47832: PPUSH
47833: CALL_OW 250
47837: ST_TO_ADDR
// y := GetY ( enemy ) ;
47838: LD_ADDR_VAR 0 5
47842: PUSH
47843: LD_VAR 0 10
47847: PPUSH
47848: CALL_OW 251
47852: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
47853: LD_ADDR_VAR 0 6
47857: PUSH
47858: LD_VAR 0 4
47862: PUSH
47863: LD_INT 1
47865: NEG
47866: PPUSH
47867: LD_INT 1
47869: PPUSH
47870: CALL_OW 12
47874: PLUS
47875: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
47876: LD_ADDR_VAR 0 7
47880: PUSH
47881: LD_VAR 0 5
47885: PUSH
47886: LD_INT 1
47888: NEG
47889: PPUSH
47890: LD_INT 1
47892: PPUSH
47893: CALL_OW 12
47897: PLUS
47898: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
47899: LD_VAR 0 6
47903: PPUSH
47904: LD_VAR 0 7
47908: PPUSH
47909: CALL_OW 488
47913: NOT
47914: IFFALSE 47936
// begin _x := x ;
47916: LD_ADDR_VAR 0 6
47920: PUSH
47921: LD_VAR 0 4
47925: ST_TO_ADDR
// _y := y ;
47926: LD_ADDR_VAR 0 7
47930: PUSH
47931: LD_VAR 0 5
47935: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
47936: LD_ADDR_VAR 0 3
47940: PUSH
47941: LD_INT 1
47943: PPUSH
47944: LD_VAR 0 14
47948: PPUSH
47949: CALL_OW 12
47953: ST_TO_ADDR
// case i of 1 :
47954: LD_VAR 0 3
47958: PUSH
47959: LD_INT 1
47961: DOUBLE
47962: EQUAL
47963: IFTRUE 47967
47965: GO 47984
47967: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
47968: LD_VAR 0 1
47972: PPUSH
47973: LD_VAR 0 10
47977: PPUSH
47978: CALL_OW 115
47982: GO 48045
47984: LD_INT 2
47986: DOUBLE
47987: EQUAL
47988: IFTRUE 47992
47990: GO 48014
47992: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
47993: LD_VAR 0 1
47997: PPUSH
47998: LD_VAR 0 6
48002: PPUSH
48003: LD_VAR 0 7
48007: PPUSH
48008: CALL_OW 153
48012: GO 48045
48014: LD_INT 3
48016: DOUBLE
48017: EQUAL
48018: IFTRUE 48022
48020: GO 48044
48022: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
48023: LD_VAR 0 1
48027: PPUSH
48028: LD_VAR 0 6
48032: PPUSH
48033: LD_VAR 0 7
48037: PPUSH
48038: CALL_OW 154
48042: GO 48045
48044: POP
// end ;
48045: LD_VAR 0 2
48049: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
48050: LD_INT 0
48052: PPUSH
48053: PPUSH
48054: PPUSH
48055: PPUSH
48056: PPUSH
48057: PPUSH
// if not unit or not building then
48058: LD_VAR 0 1
48062: NOT
48063: PUSH
48064: LD_VAR 0 2
48068: NOT
48069: OR
48070: IFFALSE 48074
// exit ;
48072: GO 48232
// x := GetX ( building ) ;
48074: LD_ADDR_VAR 0 5
48078: PUSH
48079: LD_VAR 0 2
48083: PPUSH
48084: CALL_OW 250
48088: ST_TO_ADDR
// y := GetY ( building ) ;
48089: LD_ADDR_VAR 0 6
48093: PUSH
48094: LD_VAR 0 2
48098: PPUSH
48099: CALL_OW 251
48103: ST_TO_ADDR
// for i = 0 to 5 do
48104: LD_ADDR_VAR 0 4
48108: PUSH
48109: DOUBLE
48110: LD_INT 0
48112: DEC
48113: ST_TO_ADDR
48114: LD_INT 5
48116: PUSH
48117: FOR_TO
48118: IFFALSE 48230
// begin _x := ShiftX ( x , i , 3 ) ;
48120: LD_ADDR_VAR 0 7
48124: PUSH
48125: LD_VAR 0 5
48129: PPUSH
48130: LD_VAR 0 4
48134: PPUSH
48135: LD_INT 3
48137: PPUSH
48138: CALL_OW 272
48142: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
48143: LD_ADDR_VAR 0 8
48147: PUSH
48148: LD_VAR 0 6
48152: PPUSH
48153: LD_VAR 0 4
48157: PPUSH
48158: LD_INT 3
48160: PPUSH
48161: CALL_OW 273
48165: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48166: LD_VAR 0 7
48170: PPUSH
48171: LD_VAR 0 8
48175: PPUSH
48176: CALL_OW 488
48180: NOT
48181: IFFALSE 48185
// continue ;
48183: GO 48117
// if HexInfo ( _x , _y ) = 0 then
48185: LD_VAR 0 7
48189: PPUSH
48190: LD_VAR 0 8
48194: PPUSH
48195: CALL_OW 428
48199: PUSH
48200: LD_INT 0
48202: EQUAL
48203: IFFALSE 48228
// begin ComMoveXY ( unit , _x , _y ) ;
48205: LD_VAR 0 1
48209: PPUSH
48210: LD_VAR 0 7
48214: PPUSH
48215: LD_VAR 0 8
48219: PPUSH
48220: CALL_OW 111
// exit ;
48224: POP
48225: POP
48226: GO 48232
// end ; end ;
48228: GO 48117
48230: POP
48231: POP
// end ;
48232: LD_VAR 0 3
48236: RET
// export function ScanBase ( side , base_area ) ; begin
48237: LD_INT 0
48239: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
48240: LD_ADDR_VAR 0 3
48244: PUSH
48245: LD_VAR 0 2
48249: PPUSH
48250: LD_INT 81
48252: PUSH
48253: LD_VAR 0 1
48257: PUSH
48258: EMPTY
48259: LIST
48260: LIST
48261: PPUSH
48262: CALL_OW 70
48266: ST_TO_ADDR
// end ;
48267: LD_VAR 0 3
48271: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
48272: LD_INT 0
48274: PPUSH
48275: PPUSH
48276: PPUSH
48277: PPUSH
48278: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
48279: LD_VAR 0 1
48283: NOT
48284: PUSH
48285: LD_EXP 49
48289: PUSH
48290: LD_VAR 0 1
48294: ARRAY
48295: NOT
48296: OR
48297: PUSH
48298: LD_VAR 0 2
48302: NOT
48303: OR
48304: PUSH
48305: LD_VAR 0 3
48309: NOT
48310: OR
48311: IFFALSE 48315
// exit ;
48313: GO 48828
// side := mc_sides [ base ] ;
48315: LD_ADDR_VAR 0 6
48319: PUSH
48320: LD_EXP 75
48324: PUSH
48325: LD_VAR 0 1
48329: ARRAY
48330: ST_TO_ADDR
// if not side then
48331: LD_VAR 0 6
48335: NOT
48336: IFFALSE 48340
// exit ;
48338: GO 48828
// for i in solds do
48340: LD_ADDR_VAR 0 7
48344: PUSH
48345: LD_VAR 0 2
48349: PUSH
48350: FOR_IN
48351: IFFALSE 48412
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
48353: LD_VAR 0 7
48357: PPUSH
48358: CALL_OW 310
48362: PPUSH
48363: CALL_OW 266
48367: PUSH
48368: LD_INT 32
48370: PUSH
48371: LD_INT 31
48373: PUSH
48374: EMPTY
48375: LIST
48376: LIST
48377: IN
48378: IFFALSE 48398
// solds := solds diff i else
48380: LD_ADDR_VAR 0 2
48384: PUSH
48385: LD_VAR 0 2
48389: PUSH
48390: LD_VAR 0 7
48394: DIFF
48395: ST_TO_ADDR
48396: GO 48410
// SetTag ( i , 18 ) ;
48398: LD_VAR 0 7
48402: PPUSH
48403: LD_INT 18
48405: PPUSH
48406: CALL_OW 109
48410: GO 48350
48412: POP
48413: POP
// if not solds then
48414: LD_VAR 0 2
48418: NOT
48419: IFFALSE 48423
// exit ;
48421: GO 48828
// repeat wait ( 0 0$1 ) ;
48423: LD_INT 35
48425: PPUSH
48426: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
48430: LD_ADDR_VAR 0 5
48434: PUSH
48435: LD_VAR 0 6
48439: PPUSH
48440: LD_VAR 0 3
48444: PPUSH
48445: CALL 48237 0 2
48449: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
48450: LD_EXP 49
48454: PUSH
48455: LD_VAR 0 1
48459: ARRAY
48460: NOT
48461: PUSH
48462: LD_EXP 49
48466: PUSH
48467: LD_VAR 0 1
48471: ARRAY
48472: PUSH
48473: EMPTY
48474: EQUAL
48475: OR
48476: IFFALSE 48513
// begin for i in solds do
48478: LD_ADDR_VAR 0 7
48482: PUSH
48483: LD_VAR 0 2
48487: PUSH
48488: FOR_IN
48489: IFFALSE 48502
// ComStop ( i ) ;
48491: LD_VAR 0 7
48495: PPUSH
48496: CALL_OW 141
48500: GO 48488
48502: POP
48503: POP
// solds := [ ] ;
48504: LD_ADDR_VAR 0 2
48508: PUSH
48509: EMPTY
48510: ST_TO_ADDR
// exit ;
48511: GO 48828
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
48513: LD_VAR 0 5
48517: NOT
48518: PUSH
48519: LD_VAR 0 5
48523: PUSH
48524: LD_INT 3
48526: GREATER
48527: OR
48528: PUSH
48529: LD_EXP 71
48533: PUSH
48534: LD_VAR 0 1
48538: ARRAY
48539: OR
48540: IFFALSE 48581
// begin for i in solds do
48542: LD_ADDR_VAR 0 7
48546: PUSH
48547: LD_VAR 0 2
48551: PUSH
48552: FOR_IN
48553: IFFALSE 48577
// if HasTask ( i ) then
48555: LD_VAR 0 7
48559: PPUSH
48560: CALL_OW 314
48564: IFFALSE 48575
// ComStop ( i ) ;
48566: LD_VAR 0 7
48570: PPUSH
48571: CALL_OW 141
48575: GO 48552
48577: POP
48578: POP
// break ;
48579: GO 48816
// end ; for i in solds do
48581: LD_ADDR_VAR 0 7
48585: PUSH
48586: LD_VAR 0 2
48590: PUSH
48591: FOR_IN
48592: IFFALSE 48808
// begin if IsInUnit ( i ) then
48594: LD_VAR 0 7
48598: PPUSH
48599: CALL_OW 310
48603: IFFALSE 48614
// ComExitBuilding ( i ) ;
48605: LD_VAR 0 7
48609: PPUSH
48610: CALL_OW 122
// if GetLives ( i ) > 333 then
48614: LD_VAR 0 7
48618: PPUSH
48619: CALL_OW 256
48623: PUSH
48624: LD_INT 333
48626: GREATER
48627: IFFALSE 48655
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
48629: LD_VAR 0 7
48633: PPUSH
48634: LD_VAR 0 5
48638: PPUSH
48639: LD_VAR 0 7
48643: PPUSH
48644: CALL_OW 74
48648: PPUSH
48649: CALL_OW 115
48653: GO 48806
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
48655: LD_ADDR_VAR 0 8
48659: PUSH
48660: LD_EXP 49
48664: PUSH
48665: LD_VAR 0 1
48669: ARRAY
48670: PPUSH
48671: LD_INT 2
48673: PUSH
48674: LD_INT 30
48676: PUSH
48677: LD_INT 0
48679: PUSH
48680: EMPTY
48681: LIST
48682: LIST
48683: PUSH
48684: LD_INT 30
48686: PUSH
48687: LD_INT 1
48689: PUSH
48690: EMPTY
48691: LIST
48692: LIST
48693: PUSH
48694: LD_INT 30
48696: PUSH
48697: LD_INT 6
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: PUSH
48704: EMPTY
48705: LIST
48706: LIST
48707: LIST
48708: LIST
48709: PPUSH
48710: CALL_OW 72
48714: PPUSH
48715: LD_VAR 0 7
48719: PPUSH
48720: CALL_OW 74
48724: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
48725: LD_VAR 0 7
48729: PPUSH
48730: LD_VAR 0 8
48734: PPUSH
48735: CALL_OW 250
48739: PPUSH
48740: LD_INT 3
48742: PPUSH
48743: LD_INT 5
48745: PPUSH
48746: CALL_OW 272
48750: PPUSH
48751: LD_VAR 0 8
48755: PPUSH
48756: CALL_OW 251
48760: PPUSH
48761: LD_INT 3
48763: PPUSH
48764: LD_INT 5
48766: PPUSH
48767: CALL_OW 273
48771: PPUSH
48772: CALL_OW 111
// SetTag ( i , 0 ) ;
48776: LD_VAR 0 7
48780: PPUSH
48781: LD_INT 0
48783: PPUSH
48784: CALL_OW 109
// solds := solds diff i ;
48788: LD_ADDR_VAR 0 2
48792: PUSH
48793: LD_VAR 0 2
48797: PUSH
48798: LD_VAR 0 7
48802: DIFF
48803: ST_TO_ADDR
// continue ;
48804: GO 48591
// end ; end ;
48806: GO 48591
48808: POP
48809: POP
// until solds ;
48810: LD_VAR 0 2
48814: IFFALSE 48423
// MC_Reset ( base , 18 ) ;
48816: LD_VAR 0 1
48820: PPUSH
48821: LD_INT 18
48823: PPUSH
48824: CALL 20895 0 2
// end ;
48828: LD_VAR 0 4
48832: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
48833: LD_INT 0
48835: PPUSH
48836: PPUSH
48837: PPUSH
48838: PPUSH
48839: PPUSH
48840: PPUSH
48841: PPUSH
48842: PPUSH
48843: PPUSH
48844: PPUSH
48845: PPUSH
48846: PPUSH
48847: PPUSH
48848: PPUSH
48849: PPUSH
48850: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
48851: LD_ADDR_VAR 0 12
48855: PUSH
48856: LD_EXP 49
48860: PUSH
48861: LD_VAR 0 1
48865: ARRAY
48866: PPUSH
48867: LD_INT 25
48869: PUSH
48870: LD_INT 3
48872: PUSH
48873: EMPTY
48874: LIST
48875: LIST
48876: PPUSH
48877: CALL_OW 72
48881: ST_TO_ADDR
// if mc_remote_driver [ base ] then
48882: LD_EXP 89
48886: PUSH
48887: LD_VAR 0 1
48891: ARRAY
48892: IFFALSE 48916
// mechs := mechs diff mc_remote_driver [ base ] ;
48894: LD_ADDR_VAR 0 12
48898: PUSH
48899: LD_VAR 0 12
48903: PUSH
48904: LD_EXP 89
48908: PUSH
48909: LD_VAR 0 1
48913: ARRAY
48914: DIFF
48915: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
48916: LD_ADDR_VAR 0 8
48920: PUSH
48921: LD_EXP 49
48925: PUSH
48926: LD_VAR 0 1
48930: ARRAY
48931: PPUSH
48932: LD_INT 2
48934: PUSH
48935: LD_INT 25
48937: PUSH
48938: LD_INT 1
48940: PUSH
48941: EMPTY
48942: LIST
48943: LIST
48944: PUSH
48945: LD_INT 25
48947: PUSH
48948: LD_INT 5
48950: PUSH
48951: EMPTY
48952: LIST
48953: LIST
48954: PUSH
48955: LD_INT 25
48957: PUSH
48958: LD_INT 8
48960: PUSH
48961: EMPTY
48962: LIST
48963: LIST
48964: PUSH
48965: LD_INT 25
48967: PUSH
48968: LD_INT 9
48970: PUSH
48971: EMPTY
48972: LIST
48973: LIST
48974: PUSH
48975: EMPTY
48976: LIST
48977: LIST
48978: LIST
48979: LIST
48980: LIST
48981: PPUSH
48982: CALL_OW 72
48986: ST_TO_ADDR
// if not defenders and not solds then
48987: LD_VAR 0 2
48991: NOT
48992: PUSH
48993: LD_VAR 0 8
48997: NOT
48998: AND
48999: IFFALSE 49003
// exit ;
49001: GO 50529
// depot_under_attack := false ;
49003: LD_ADDR_VAR 0 16
49007: PUSH
49008: LD_INT 0
49010: ST_TO_ADDR
// sold_defenders := [ ] ;
49011: LD_ADDR_VAR 0 17
49015: PUSH
49016: EMPTY
49017: ST_TO_ADDR
// if mechs then
49018: LD_VAR 0 12
49022: IFFALSE 49151
// for i in defenders do
49024: LD_ADDR_VAR 0 5
49028: PUSH
49029: LD_VAR 0 2
49033: PUSH
49034: FOR_IN
49035: IFFALSE 49149
// begin SetTag ( i , 20 ) ;
49037: LD_VAR 0 5
49041: PPUSH
49042: LD_INT 20
49044: PPUSH
49045: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
49049: LD_VAR 0 5
49053: PPUSH
49054: CALL_OW 263
49058: PUSH
49059: LD_INT 1
49061: EQUAL
49062: PUSH
49063: LD_VAR 0 5
49067: PPUSH
49068: CALL_OW 311
49072: NOT
49073: AND
49074: PUSH
49075: LD_VAR 0 12
49079: AND
49080: IFFALSE 49147
// begin un := mechs [ 1 ] ;
49082: LD_ADDR_VAR 0 10
49086: PUSH
49087: LD_VAR 0 12
49091: PUSH
49092: LD_INT 1
49094: ARRAY
49095: ST_TO_ADDR
// ComExitBuilding ( un ) ;
49096: LD_VAR 0 10
49100: PPUSH
49101: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
49105: LD_VAR 0 10
49109: PPUSH
49110: LD_VAR 0 5
49114: PPUSH
49115: CALL_OW 180
// SetTag ( un , 19 ) ;
49119: LD_VAR 0 10
49123: PPUSH
49124: LD_INT 19
49126: PPUSH
49127: CALL_OW 109
// mechs := mechs diff un ;
49131: LD_ADDR_VAR 0 12
49135: PUSH
49136: LD_VAR 0 12
49140: PUSH
49141: LD_VAR 0 10
49145: DIFF
49146: ST_TO_ADDR
// end ; end ;
49147: GO 49034
49149: POP
49150: POP
// if solds then
49151: LD_VAR 0 8
49155: IFFALSE 49214
// for i in solds do
49157: LD_ADDR_VAR 0 5
49161: PUSH
49162: LD_VAR 0 8
49166: PUSH
49167: FOR_IN
49168: IFFALSE 49212
// if not GetTag ( i ) then
49170: LD_VAR 0 5
49174: PPUSH
49175: CALL_OW 110
49179: NOT
49180: IFFALSE 49210
// begin defenders := defenders union i ;
49182: LD_ADDR_VAR 0 2
49186: PUSH
49187: LD_VAR 0 2
49191: PUSH
49192: LD_VAR 0 5
49196: UNION
49197: ST_TO_ADDR
// SetTag ( i , 18 ) ;
49198: LD_VAR 0 5
49202: PPUSH
49203: LD_INT 18
49205: PPUSH
49206: CALL_OW 109
// end ;
49210: GO 49167
49212: POP
49213: POP
// repeat wait ( 0 0$1 ) ;
49214: LD_INT 35
49216: PPUSH
49217: CALL_OW 67
// enemy := mc_scan [ base ] ;
49221: LD_ADDR_VAR 0 3
49225: PUSH
49226: LD_EXP 72
49230: PUSH
49231: LD_VAR 0 1
49235: ARRAY
49236: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
49237: LD_EXP 49
49241: PUSH
49242: LD_VAR 0 1
49246: ARRAY
49247: NOT
49248: PUSH
49249: LD_EXP 49
49253: PUSH
49254: LD_VAR 0 1
49258: ARRAY
49259: PUSH
49260: EMPTY
49261: EQUAL
49262: OR
49263: IFFALSE 49300
// begin for i in defenders do
49265: LD_ADDR_VAR 0 5
49269: PUSH
49270: LD_VAR 0 2
49274: PUSH
49275: FOR_IN
49276: IFFALSE 49289
// ComStop ( i ) ;
49278: LD_VAR 0 5
49282: PPUSH
49283: CALL_OW 141
49287: GO 49275
49289: POP
49290: POP
// defenders := [ ] ;
49291: LD_ADDR_VAR 0 2
49295: PUSH
49296: EMPTY
49297: ST_TO_ADDR
// exit ;
49298: GO 50529
// end ; for i in defenders do
49300: LD_ADDR_VAR 0 5
49304: PUSH
49305: LD_VAR 0 2
49309: PUSH
49310: FOR_IN
49311: IFFALSE 50041
// begin e := NearestUnitToUnit ( enemy , i ) ;
49313: LD_ADDR_VAR 0 13
49317: PUSH
49318: LD_VAR 0 3
49322: PPUSH
49323: LD_VAR 0 5
49327: PPUSH
49328: CALL_OW 74
49332: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
49333: LD_ADDR_VAR 0 16
49337: PUSH
49338: LD_EXP 49
49342: PUSH
49343: LD_VAR 0 1
49347: ARRAY
49348: PPUSH
49349: LD_INT 2
49351: PUSH
49352: LD_INT 30
49354: PUSH
49355: LD_INT 0
49357: PUSH
49358: EMPTY
49359: LIST
49360: LIST
49361: PUSH
49362: LD_INT 30
49364: PUSH
49365: LD_INT 1
49367: PUSH
49368: EMPTY
49369: LIST
49370: LIST
49371: PUSH
49372: EMPTY
49373: LIST
49374: LIST
49375: LIST
49376: PPUSH
49377: CALL_OW 72
49381: NOT
49382: PUSH
49383: LD_EXP 49
49387: PUSH
49388: LD_VAR 0 1
49392: ARRAY
49393: PPUSH
49394: LD_INT 2
49396: PUSH
49397: LD_INT 30
49399: PUSH
49400: LD_INT 0
49402: PUSH
49403: EMPTY
49404: LIST
49405: LIST
49406: PUSH
49407: LD_INT 30
49409: PUSH
49410: LD_INT 1
49412: PUSH
49413: EMPTY
49414: LIST
49415: LIST
49416: PUSH
49417: EMPTY
49418: LIST
49419: LIST
49420: LIST
49421: PPUSH
49422: CALL_OW 72
49426: PPUSH
49427: CALL_OW 256
49431: PUSH
49432: LD_INT 600
49434: LESS
49435: OR
49436: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
49437: LD_VAR 0 5
49441: PPUSH
49442: CALL_OW 247
49446: PUSH
49447: LD_INT 2
49449: DOUBLE
49450: EQUAL
49451: IFTRUE 49455
49453: GO 49747
49455: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
49456: LD_VAR 0 5
49460: PPUSH
49461: CALL_OW 256
49465: PUSH
49466: LD_INT 650
49468: GREATER
49469: PUSH
49470: LD_VAR 0 5
49474: PPUSH
49475: LD_VAR 0 13
49479: PPUSH
49480: CALL_OW 296
49484: PUSH
49485: LD_INT 40
49487: LESS
49488: PUSH
49489: LD_VAR 0 13
49493: PPUSH
49494: LD_EXP 74
49498: PUSH
49499: LD_VAR 0 1
49503: ARRAY
49504: PPUSH
49505: CALL_OW 308
49509: OR
49510: AND
49511: IFFALSE 49529
// ComAttackUnit ( i , e ) else
49513: LD_VAR 0 5
49517: PPUSH
49518: LD_VAR 0 13
49522: PPUSH
49523: CALL_OW 115
49527: GO 49630
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
49529: LD_VAR 0 13
49533: PPUSH
49534: LD_EXP 74
49538: PUSH
49539: LD_VAR 0 1
49543: ARRAY
49544: PPUSH
49545: CALL_OW 308
49549: NOT
49550: PUSH
49551: LD_VAR 0 5
49555: PPUSH
49556: LD_VAR 0 13
49560: PPUSH
49561: CALL_OW 296
49565: PUSH
49566: LD_INT 40
49568: GREATEREQUAL
49569: AND
49570: PUSH
49571: LD_VAR 0 5
49575: PPUSH
49576: CALL_OW 256
49580: PUSH
49581: LD_INT 650
49583: LESSEQUAL
49584: OR
49585: PUSH
49586: LD_VAR 0 5
49590: PPUSH
49591: LD_EXP 73
49595: PUSH
49596: LD_VAR 0 1
49600: ARRAY
49601: PPUSH
49602: CALL_OW 308
49606: NOT
49607: AND
49608: IFFALSE 49630
// ComMoveToArea ( i , mc_parking [ base ] ) ;
49610: LD_VAR 0 5
49614: PPUSH
49615: LD_EXP 73
49619: PUSH
49620: LD_VAR 0 1
49624: ARRAY
49625: PPUSH
49626: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
49630: LD_VAR 0 5
49634: PPUSH
49635: CALL_OW 256
49639: PUSH
49640: LD_INT 998
49642: LESS
49643: PUSH
49644: LD_VAR 0 5
49648: PPUSH
49649: CALL_OW 263
49653: PUSH
49654: LD_INT 1
49656: EQUAL
49657: AND
49658: PUSH
49659: LD_VAR 0 5
49663: PPUSH
49664: CALL_OW 311
49668: AND
49669: PUSH
49670: LD_VAR 0 5
49674: PPUSH
49675: LD_EXP 73
49679: PUSH
49680: LD_VAR 0 1
49684: ARRAY
49685: PPUSH
49686: CALL_OW 308
49690: AND
49691: IFFALSE 49745
// begin mech := IsDrivenBy ( i ) ;
49693: LD_ADDR_VAR 0 9
49697: PUSH
49698: LD_VAR 0 5
49702: PPUSH
49703: CALL_OW 311
49707: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
49708: LD_VAR 0 9
49712: PPUSH
49713: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
49717: LD_VAR 0 9
49721: PPUSH
49722: LD_VAR 0 5
49726: PPUSH
49727: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
49731: LD_VAR 0 9
49735: PPUSH
49736: LD_VAR 0 5
49740: PPUSH
49741: CALL_OW 180
// end ; end ; unit_human :
49745: GO 50012
49747: LD_INT 1
49749: DOUBLE
49750: EQUAL
49751: IFTRUE 49755
49753: GO 50011
49755: POP
// begin b := IsInUnit ( i ) ;
49756: LD_ADDR_VAR 0 18
49760: PUSH
49761: LD_VAR 0 5
49765: PPUSH
49766: CALL_OW 310
49770: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
49771: LD_ADDR_VAR 0 19
49775: PUSH
49776: LD_VAR 0 18
49780: NOT
49781: PUSH
49782: LD_VAR 0 18
49786: PPUSH
49787: CALL_OW 266
49791: PUSH
49792: LD_INT 32
49794: PUSH
49795: LD_INT 31
49797: PUSH
49798: EMPTY
49799: LIST
49800: LIST
49801: IN
49802: OR
49803: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
49804: LD_VAR 0 16
49808: PUSH
49809: LD_VAR 0 2
49813: PPUSH
49814: LD_INT 21
49816: PUSH
49817: LD_INT 2
49819: PUSH
49820: EMPTY
49821: LIST
49822: LIST
49823: PPUSH
49824: CALL_OW 72
49828: PUSH
49829: LD_INT 1
49831: LESSEQUAL
49832: OR
49833: PUSH
49834: LD_VAR 0 19
49838: AND
49839: PUSH
49840: LD_VAR 0 5
49844: PUSH
49845: LD_VAR 0 17
49849: IN
49850: NOT
49851: AND
49852: IFFALSE 49945
// begin if b then
49854: LD_VAR 0 18
49858: IFFALSE 49907
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
49860: LD_VAR 0 18
49864: PPUSH
49865: LD_VAR 0 3
49869: PPUSH
49870: LD_VAR 0 18
49874: PPUSH
49875: CALL_OW 74
49879: PPUSH
49880: CALL_OW 296
49884: PUSH
49885: LD_INT 10
49887: LESS
49888: PUSH
49889: LD_VAR 0 18
49893: PPUSH
49894: CALL_OW 461
49898: PUSH
49899: LD_INT 7
49901: NONEQUAL
49902: AND
49903: IFFALSE 49907
// continue ;
49905: GO 49310
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
49907: LD_ADDR_VAR 0 17
49911: PUSH
49912: LD_VAR 0 17
49916: PPUSH
49917: LD_VAR 0 17
49921: PUSH
49922: LD_INT 1
49924: PLUS
49925: PPUSH
49926: LD_VAR 0 5
49930: PPUSH
49931: CALL_OW 1
49935: ST_TO_ADDR
// ComExitBuilding ( i ) ;
49936: LD_VAR 0 5
49940: PPUSH
49941: CALL_OW 122
// end ; if sold_defenders then
49945: LD_VAR 0 17
49949: IFFALSE 50009
// if i in sold_defenders then
49951: LD_VAR 0 5
49955: PUSH
49956: LD_VAR 0 17
49960: IN
49961: IFFALSE 50009
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
49963: LD_VAR 0 5
49967: PPUSH
49968: CALL_OW 314
49972: NOT
49973: PUSH
49974: LD_VAR 0 5
49978: PPUSH
49979: LD_VAR 0 13
49983: PPUSH
49984: CALL_OW 296
49988: PUSH
49989: LD_INT 30
49991: LESS
49992: AND
49993: IFFALSE 50009
// ComAttackUnit ( i , e ) ;
49995: LD_VAR 0 5
49999: PPUSH
50000: LD_VAR 0 13
50004: PPUSH
50005: CALL_OW 115
// end ; end ; end ;
50009: GO 50012
50011: POP
// if IsDead ( i ) then
50012: LD_VAR 0 5
50016: PPUSH
50017: CALL_OW 301
50021: IFFALSE 50039
// defenders := defenders diff i ;
50023: LD_ADDR_VAR 0 2
50027: PUSH
50028: LD_VAR 0 2
50032: PUSH
50033: LD_VAR 0 5
50037: DIFF
50038: ST_TO_ADDR
// end ;
50039: GO 49310
50041: POP
50042: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
50043: LD_VAR 0 3
50047: NOT
50048: PUSH
50049: LD_VAR 0 2
50053: NOT
50054: OR
50055: PUSH
50056: LD_EXP 49
50060: PUSH
50061: LD_VAR 0 1
50065: ARRAY
50066: NOT
50067: OR
50068: IFFALSE 49214
// MC_Reset ( base , 18 ) ;
50070: LD_VAR 0 1
50074: PPUSH
50075: LD_INT 18
50077: PPUSH
50078: CALL 20895 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50082: LD_ADDR_VAR 0 2
50086: PUSH
50087: LD_VAR 0 2
50091: PUSH
50092: LD_VAR 0 2
50096: PPUSH
50097: LD_INT 2
50099: PUSH
50100: LD_INT 25
50102: PUSH
50103: LD_INT 1
50105: PUSH
50106: EMPTY
50107: LIST
50108: LIST
50109: PUSH
50110: LD_INT 25
50112: PUSH
50113: LD_INT 5
50115: PUSH
50116: EMPTY
50117: LIST
50118: LIST
50119: PUSH
50120: LD_INT 25
50122: PUSH
50123: LD_INT 8
50125: PUSH
50126: EMPTY
50127: LIST
50128: LIST
50129: PUSH
50130: LD_INT 25
50132: PUSH
50133: LD_INT 9
50135: PUSH
50136: EMPTY
50137: LIST
50138: LIST
50139: PUSH
50140: EMPTY
50141: LIST
50142: LIST
50143: LIST
50144: LIST
50145: LIST
50146: PPUSH
50147: CALL_OW 72
50151: DIFF
50152: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
50153: LD_VAR 0 3
50157: NOT
50158: PUSH
50159: LD_VAR 0 2
50163: PPUSH
50164: LD_INT 21
50166: PUSH
50167: LD_INT 2
50169: PUSH
50170: EMPTY
50171: LIST
50172: LIST
50173: PPUSH
50174: CALL_OW 72
50178: AND
50179: IFFALSE 50517
// begin tmp := FilterByTag ( defenders , 19 ) ;
50181: LD_ADDR_VAR 0 11
50185: PUSH
50186: LD_VAR 0 2
50190: PPUSH
50191: LD_INT 19
50193: PPUSH
50194: CALL 86958 0 2
50198: ST_TO_ADDR
// if tmp then
50199: LD_VAR 0 11
50203: IFFALSE 50273
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
50205: LD_ADDR_VAR 0 11
50209: PUSH
50210: LD_VAR 0 11
50214: PPUSH
50215: LD_INT 25
50217: PUSH
50218: LD_INT 3
50220: PUSH
50221: EMPTY
50222: LIST
50223: LIST
50224: PPUSH
50225: CALL_OW 72
50229: ST_TO_ADDR
// if tmp then
50230: LD_VAR 0 11
50234: IFFALSE 50273
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
50236: LD_ADDR_EXP 61
50240: PUSH
50241: LD_EXP 61
50245: PPUSH
50246: LD_VAR 0 1
50250: PPUSH
50251: LD_EXP 61
50255: PUSH
50256: LD_VAR 0 1
50260: ARRAY
50261: PUSH
50262: LD_VAR 0 11
50266: UNION
50267: PPUSH
50268: CALL_OW 1
50272: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
50273: LD_VAR 0 1
50277: PPUSH
50278: LD_INT 19
50280: PPUSH
50281: CALL 20895 0 2
// repeat wait ( 0 0$1 ) ;
50285: LD_INT 35
50287: PPUSH
50288: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
50292: LD_EXP 49
50296: PUSH
50297: LD_VAR 0 1
50301: ARRAY
50302: NOT
50303: PUSH
50304: LD_EXP 49
50308: PUSH
50309: LD_VAR 0 1
50313: ARRAY
50314: PUSH
50315: EMPTY
50316: EQUAL
50317: OR
50318: IFFALSE 50355
// begin for i in defenders do
50320: LD_ADDR_VAR 0 5
50324: PUSH
50325: LD_VAR 0 2
50329: PUSH
50330: FOR_IN
50331: IFFALSE 50344
// ComStop ( i ) ;
50333: LD_VAR 0 5
50337: PPUSH
50338: CALL_OW 141
50342: GO 50330
50344: POP
50345: POP
// defenders := [ ] ;
50346: LD_ADDR_VAR 0 2
50350: PUSH
50351: EMPTY
50352: ST_TO_ADDR
// exit ;
50353: GO 50529
// end ; for i in defenders do
50355: LD_ADDR_VAR 0 5
50359: PUSH
50360: LD_VAR 0 2
50364: PUSH
50365: FOR_IN
50366: IFFALSE 50455
// begin if not IsInArea ( i , mc_parking [ base ] ) then
50368: LD_VAR 0 5
50372: PPUSH
50373: LD_EXP 73
50377: PUSH
50378: LD_VAR 0 1
50382: ARRAY
50383: PPUSH
50384: CALL_OW 308
50388: NOT
50389: IFFALSE 50413
// ComMoveToArea ( i , mc_parking [ base ] ) else
50391: LD_VAR 0 5
50395: PPUSH
50396: LD_EXP 73
50400: PUSH
50401: LD_VAR 0 1
50405: ARRAY
50406: PPUSH
50407: CALL_OW 113
50411: GO 50453
// if GetControl ( i ) = control_manual then
50413: LD_VAR 0 5
50417: PPUSH
50418: CALL_OW 263
50422: PUSH
50423: LD_INT 1
50425: EQUAL
50426: IFFALSE 50453
// if IsDrivenBy ( i ) then
50428: LD_VAR 0 5
50432: PPUSH
50433: CALL_OW 311
50437: IFFALSE 50453
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
50439: LD_VAR 0 5
50443: PPUSH
50444: CALL_OW 311
50448: PPUSH
50449: CALL_OW 121
// end ;
50453: GO 50365
50455: POP
50456: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
50457: LD_VAR 0 2
50461: PPUSH
50462: LD_INT 95
50464: PUSH
50465: LD_EXP 73
50469: PUSH
50470: LD_VAR 0 1
50474: ARRAY
50475: PUSH
50476: EMPTY
50477: LIST
50478: LIST
50479: PPUSH
50480: CALL_OW 72
50484: PUSH
50485: LD_VAR 0 2
50489: EQUAL
50490: PUSH
50491: LD_EXP 72
50495: PUSH
50496: LD_VAR 0 1
50500: ARRAY
50501: OR
50502: PUSH
50503: LD_EXP 49
50507: PUSH
50508: LD_VAR 0 1
50512: ARRAY
50513: NOT
50514: OR
50515: IFFALSE 50285
// end ; MC_Reset ( base , 20 ) ;
50517: LD_VAR 0 1
50521: PPUSH
50522: LD_INT 20
50524: PPUSH
50525: CALL 20895 0 2
// end ;
50529: LD_VAR 0 4
50533: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50534: LD_INT 0
50536: PPUSH
50537: PPUSH
50538: PPUSH
50539: PPUSH
// result := false ;
50540: LD_ADDR_VAR 0 2
50544: PUSH
50545: LD_INT 0
50547: ST_TO_ADDR
// side := GetSide ( unit ) ;
50548: LD_ADDR_VAR 0 3
50552: PUSH
50553: LD_VAR 0 1
50557: PPUSH
50558: CALL_OW 255
50562: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50563: LD_ADDR_VAR 0 4
50567: PUSH
50568: LD_VAR 0 1
50572: PPUSH
50573: CALL_OW 248
50577: ST_TO_ADDR
// case nat of 1 :
50578: LD_VAR 0 4
50582: PUSH
50583: LD_INT 1
50585: DOUBLE
50586: EQUAL
50587: IFTRUE 50591
50589: GO 50602
50591: POP
// tech := tech_lassight ; 2 :
50592: LD_ADDR_VAR 0 5
50596: PUSH
50597: LD_INT 12
50599: ST_TO_ADDR
50600: GO 50641
50602: LD_INT 2
50604: DOUBLE
50605: EQUAL
50606: IFTRUE 50610
50608: GO 50621
50610: POP
// tech := tech_mortar ; 3 :
50611: LD_ADDR_VAR 0 5
50615: PUSH
50616: LD_INT 41
50618: ST_TO_ADDR
50619: GO 50641
50621: LD_INT 3
50623: DOUBLE
50624: EQUAL
50625: IFTRUE 50629
50627: GO 50640
50629: POP
// tech := tech_bazooka ; end ;
50630: LD_ADDR_VAR 0 5
50634: PUSH
50635: LD_INT 44
50637: ST_TO_ADDR
50638: GO 50641
50640: POP
// if Researched ( side , tech ) then
50641: LD_VAR 0 3
50645: PPUSH
50646: LD_VAR 0 5
50650: PPUSH
50651: CALL_OW 325
50655: IFFALSE 50682
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50657: LD_ADDR_VAR 0 2
50661: PUSH
50662: LD_INT 5
50664: PUSH
50665: LD_INT 8
50667: PUSH
50668: LD_INT 9
50670: PUSH
50671: EMPTY
50672: LIST
50673: LIST
50674: LIST
50675: PUSH
50676: LD_VAR 0 4
50680: ARRAY
50681: ST_TO_ADDR
// end ;
50682: LD_VAR 0 2
50686: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50687: LD_INT 0
50689: PPUSH
50690: PPUSH
50691: PPUSH
// if not mines then
50692: LD_VAR 0 2
50696: NOT
50697: IFFALSE 50701
// exit ;
50699: GO 50845
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50701: LD_ADDR_VAR 0 5
50705: PUSH
50706: LD_INT 81
50708: PUSH
50709: LD_VAR 0 1
50713: PUSH
50714: EMPTY
50715: LIST
50716: LIST
50717: PUSH
50718: LD_INT 3
50720: PUSH
50721: LD_INT 21
50723: PUSH
50724: LD_INT 3
50726: PUSH
50727: EMPTY
50728: LIST
50729: LIST
50730: PUSH
50731: EMPTY
50732: LIST
50733: LIST
50734: PUSH
50735: EMPTY
50736: LIST
50737: LIST
50738: PPUSH
50739: CALL_OW 69
50743: ST_TO_ADDR
// for i in mines do
50744: LD_ADDR_VAR 0 4
50748: PUSH
50749: LD_VAR 0 2
50753: PUSH
50754: FOR_IN
50755: IFFALSE 50843
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50757: LD_VAR 0 4
50761: PUSH
50762: LD_INT 1
50764: ARRAY
50765: PPUSH
50766: LD_VAR 0 4
50770: PUSH
50771: LD_INT 2
50773: ARRAY
50774: PPUSH
50775: CALL_OW 458
50779: NOT
50780: IFFALSE 50784
// continue ;
50782: GO 50754
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50784: LD_VAR 0 4
50788: PUSH
50789: LD_INT 1
50791: ARRAY
50792: PPUSH
50793: LD_VAR 0 4
50797: PUSH
50798: LD_INT 2
50800: ARRAY
50801: PPUSH
50802: CALL_OW 428
50806: PUSH
50807: LD_VAR 0 5
50811: IN
50812: IFFALSE 50841
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50814: LD_VAR 0 4
50818: PUSH
50819: LD_INT 1
50821: ARRAY
50822: PPUSH
50823: LD_VAR 0 4
50827: PUSH
50828: LD_INT 2
50830: ARRAY
50831: PPUSH
50832: LD_VAR 0 1
50836: PPUSH
50837: CALL_OW 456
// end ;
50841: GO 50754
50843: POP
50844: POP
// end ;
50845: LD_VAR 0 3
50849: RET
// export function Count ( array ) ; var i ; begin
50850: LD_INT 0
50852: PPUSH
50853: PPUSH
// result := 0 ;
50854: LD_ADDR_VAR 0 2
50858: PUSH
50859: LD_INT 0
50861: ST_TO_ADDR
// for i in array do
50862: LD_ADDR_VAR 0 3
50866: PUSH
50867: LD_VAR 0 1
50871: PUSH
50872: FOR_IN
50873: IFFALSE 50897
// if i then
50875: LD_VAR 0 3
50879: IFFALSE 50895
// result := result + 1 ;
50881: LD_ADDR_VAR 0 2
50885: PUSH
50886: LD_VAR 0 2
50890: PUSH
50891: LD_INT 1
50893: PLUS
50894: ST_TO_ADDR
50895: GO 50872
50897: POP
50898: POP
// end ;
50899: LD_VAR 0 2
50903: RET
// export function IsEmpty ( building ) ; begin
50904: LD_INT 0
50906: PPUSH
// if not building then
50907: LD_VAR 0 1
50911: NOT
50912: IFFALSE 50916
// exit ;
50914: GO 50959
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50916: LD_ADDR_VAR 0 2
50920: PUSH
50921: LD_VAR 0 1
50925: PUSH
50926: LD_INT 22
50928: PUSH
50929: LD_VAR 0 1
50933: PPUSH
50934: CALL_OW 255
50938: PUSH
50939: EMPTY
50940: LIST
50941: LIST
50942: PUSH
50943: LD_INT 58
50945: PUSH
50946: EMPTY
50947: LIST
50948: PUSH
50949: EMPTY
50950: LIST
50951: LIST
50952: PPUSH
50953: CALL_OW 69
50957: IN
50958: ST_TO_ADDR
// end ;
50959: LD_VAR 0 2
50963: RET
// export function IsNotFull ( building ) ; begin
50964: LD_INT 0
50966: PPUSH
// if not building then
50967: LD_VAR 0 1
50971: NOT
50972: IFFALSE 50976
// exit ;
50974: GO 50995
// result := UnitsInside ( building ) < 6 ;
50976: LD_ADDR_VAR 0 2
50980: PUSH
50981: LD_VAR 0 1
50985: PPUSH
50986: CALL_OW 313
50990: PUSH
50991: LD_INT 6
50993: LESS
50994: ST_TO_ADDR
// end ;
50995: LD_VAR 0 2
50999: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51000: LD_INT 0
51002: PPUSH
51003: PPUSH
51004: PPUSH
51005: PPUSH
// tmp := [ ] ;
51006: LD_ADDR_VAR 0 3
51010: PUSH
51011: EMPTY
51012: ST_TO_ADDR
// list := [ ] ;
51013: LD_ADDR_VAR 0 5
51017: PUSH
51018: EMPTY
51019: ST_TO_ADDR
// for i = 16 to 25 do
51020: LD_ADDR_VAR 0 4
51024: PUSH
51025: DOUBLE
51026: LD_INT 16
51028: DEC
51029: ST_TO_ADDR
51030: LD_INT 25
51032: PUSH
51033: FOR_TO
51034: IFFALSE 51107
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51036: LD_ADDR_VAR 0 3
51040: PUSH
51041: LD_VAR 0 3
51045: PUSH
51046: LD_INT 22
51048: PUSH
51049: LD_VAR 0 1
51053: PPUSH
51054: CALL_OW 255
51058: PUSH
51059: EMPTY
51060: LIST
51061: LIST
51062: PUSH
51063: LD_INT 91
51065: PUSH
51066: LD_VAR 0 1
51070: PUSH
51071: LD_INT 6
51073: PUSH
51074: EMPTY
51075: LIST
51076: LIST
51077: LIST
51078: PUSH
51079: LD_INT 30
51081: PUSH
51082: LD_VAR 0 4
51086: PUSH
51087: EMPTY
51088: LIST
51089: LIST
51090: PUSH
51091: EMPTY
51092: LIST
51093: LIST
51094: LIST
51095: PUSH
51096: EMPTY
51097: LIST
51098: PPUSH
51099: CALL_OW 69
51103: ADD
51104: ST_TO_ADDR
51105: GO 51033
51107: POP
51108: POP
// for i = 1 to tmp do
51109: LD_ADDR_VAR 0 4
51113: PUSH
51114: DOUBLE
51115: LD_INT 1
51117: DEC
51118: ST_TO_ADDR
51119: LD_VAR 0 3
51123: PUSH
51124: FOR_TO
51125: IFFALSE 51213
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51127: LD_ADDR_VAR 0 5
51131: PUSH
51132: LD_VAR 0 5
51136: PUSH
51137: LD_VAR 0 3
51141: PUSH
51142: LD_VAR 0 4
51146: ARRAY
51147: PPUSH
51148: CALL_OW 266
51152: PUSH
51153: LD_VAR 0 3
51157: PUSH
51158: LD_VAR 0 4
51162: ARRAY
51163: PPUSH
51164: CALL_OW 250
51168: PUSH
51169: LD_VAR 0 3
51173: PUSH
51174: LD_VAR 0 4
51178: ARRAY
51179: PPUSH
51180: CALL_OW 251
51184: PUSH
51185: LD_VAR 0 3
51189: PUSH
51190: LD_VAR 0 4
51194: ARRAY
51195: PPUSH
51196: CALL_OW 254
51200: PUSH
51201: EMPTY
51202: LIST
51203: LIST
51204: LIST
51205: LIST
51206: PUSH
51207: EMPTY
51208: LIST
51209: ADD
51210: ST_TO_ADDR
51211: GO 51124
51213: POP
51214: POP
// result := list ;
51215: LD_ADDR_VAR 0 2
51219: PUSH
51220: LD_VAR 0 5
51224: ST_TO_ADDR
// end ;
51225: LD_VAR 0 2
51229: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51230: LD_INT 0
51232: PPUSH
51233: PPUSH
51234: PPUSH
51235: PPUSH
51236: PPUSH
51237: PPUSH
51238: PPUSH
// if not factory then
51239: LD_VAR 0 1
51243: NOT
51244: IFFALSE 51248
// exit ;
51246: GO 51841
// if control = control_apeman then
51248: LD_VAR 0 4
51252: PUSH
51253: LD_INT 5
51255: EQUAL
51256: IFFALSE 51365
// begin tmp := UnitsInside ( factory ) ;
51258: LD_ADDR_VAR 0 8
51262: PUSH
51263: LD_VAR 0 1
51267: PPUSH
51268: CALL_OW 313
51272: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51273: LD_VAR 0 8
51277: PPUSH
51278: LD_INT 25
51280: PUSH
51281: LD_INT 12
51283: PUSH
51284: EMPTY
51285: LIST
51286: LIST
51287: PPUSH
51288: CALL_OW 72
51292: NOT
51293: IFFALSE 51303
// control := control_manual ;
51295: LD_ADDR_VAR 0 4
51299: PUSH
51300: LD_INT 1
51302: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51303: LD_ADDR_VAR 0 8
51307: PUSH
51308: LD_VAR 0 1
51312: PPUSH
51313: CALL 51000 0 1
51317: ST_TO_ADDR
// if tmp then
51318: LD_VAR 0 8
51322: IFFALSE 51365
// begin for i in tmp do
51324: LD_ADDR_VAR 0 7
51328: PUSH
51329: LD_VAR 0 8
51333: PUSH
51334: FOR_IN
51335: IFFALSE 51363
// if i [ 1 ] = b_ext_radio then
51337: LD_VAR 0 7
51341: PUSH
51342: LD_INT 1
51344: ARRAY
51345: PUSH
51346: LD_INT 22
51348: EQUAL
51349: IFFALSE 51361
// begin control := control_remote ;
51351: LD_ADDR_VAR 0 4
51355: PUSH
51356: LD_INT 2
51358: ST_TO_ADDR
// break ;
51359: GO 51363
// end ;
51361: GO 51334
51363: POP
51364: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51365: LD_VAR 0 1
51369: PPUSH
51370: LD_VAR 0 2
51374: PPUSH
51375: LD_VAR 0 3
51379: PPUSH
51380: LD_VAR 0 4
51384: PPUSH
51385: LD_VAR 0 5
51389: PPUSH
51390: CALL_OW 448
51394: IFFALSE 51429
// begin result := [ chassis , engine , control , weapon ] ;
51396: LD_ADDR_VAR 0 6
51400: PUSH
51401: LD_VAR 0 2
51405: PUSH
51406: LD_VAR 0 3
51410: PUSH
51411: LD_VAR 0 4
51415: PUSH
51416: LD_VAR 0 5
51420: PUSH
51421: EMPTY
51422: LIST
51423: LIST
51424: LIST
51425: LIST
51426: ST_TO_ADDR
// exit ;
51427: GO 51841
// end ; _chassis := AvailableChassisList ( factory ) ;
51429: LD_ADDR_VAR 0 9
51433: PUSH
51434: LD_VAR 0 1
51438: PPUSH
51439: CALL_OW 475
51443: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51444: LD_ADDR_VAR 0 11
51448: PUSH
51449: LD_VAR 0 1
51453: PPUSH
51454: CALL_OW 476
51458: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51459: LD_ADDR_VAR 0 12
51463: PUSH
51464: LD_VAR 0 1
51468: PPUSH
51469: CALL_OW 477
51473: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51474: LD_ADDR_VAR 0 10
51478: PUSH
51479: LD_VAR 0 1
51483: PPUSH
51484: CALL_OW 478
51488: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51489: LD_VAR 0 9
51493: NOT
51494: PUSH
51495: LD_VAR 0 11
51499: NOT
51500: OR
51501: PUSH
51502: LD_VAR 0 12
51506: NOT
51507: OR
51508: PUSH
51509: LD_VAR 0 10
51513: NOT
51514: OR
51515: IFFALSE 51550
// begin result := [ chassis , engine , control , weapon ] ;
51517: LD_ADDR_VAR 0 6
51521: PUSH
51522: LD_VAR 0 2
51526: PUSH
51527: LD_VAR 0 3
51531: PUSH
51532: LD_VAR 0 4
51536: PUSH
51537: LD_VAR 0 5
51541: PUSH
51542: EMPTY
51543: LIST
51544: LIST
51545: LIST
51546: LIST
51547: ST_TO_ADDR
// exit ;
51548: GO 51841
// end ; if not chassis in _chassis then
51550: LD_VAR 0 2
51554: PUSH
51555: LD_VAR 0 9
51559: IN
51560: NOT
51561: IFFALSE 51587
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51563: LD_ADDR_VAR 0 2
51567: PUSH
51568: LD_VAR 0 9
51572: PUSH
51573: LD_INT 1
51575: PPUSH
51576: LD_VAR 0 9
51580: PPUSH
51581: CALL_OW 12
51585: ARRAY
51586: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51587: LD_VAR 0 2
51591: PPUSH
51592: LD_VAR 0 3
51596: PPUSH
51597: CALL 51846 0 2
51601: NOT
51602: IFFALSE 51661
// repeat engine := _engine [ 1 ] ;
51604: LD_ADDR_VAR 0 3
51608: PUSH
51609: LD_VAR 0 11
51613: PUSH
51614: LD_INT 1
51616: ARRAY
51617: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51618: LD_ADDR_VAR 0 11
51622: PUSH
51623: LD_VAR 0 11
51627: PPUSH
51628: LD_INT 1
51630: PPUSH
51631: CALL_OW 3
51635: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51636: LD_VAR 0 2
51640: PPUSH
51641: LD_VAR 0 3
51645: PPUSH
51646: CALL 51846 0 2
51650: PUSH
51651: LD_VAR 0 11
51655: PUSH
51656: EMPTY
51657: EQUAL
51658: OR
51659: IFFALSE 51604
// if not control in _control then
51661: LD_VAR 0 4
51665: PUSH
51666: LD_VAR 0 12
51670: IN
51671: NOT
51672: IFFALSE 51698
// control := _control [ rand ( 1 , _control ) ] ;
51674: LD_ADDR_VAR 0 4
51678: PUSH
51679: LD_VAR 0 12
51683: PUSH
51684: LD_INT 1
51686: PPUSH
51687: LD_VAR 0 12
51691: PPUSH
51692: CALL_OW 12
51696: ARRAY
51697: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51698: LD_VAR 0 2
51702: PPUSH
51703: LD_VAR 0 5
51707: PPUSH
51708: CALL 52066 0 2
51712: NOT
51713: IFFALSE 51772
// repeat weapon := _weapon [ 1 ] ;
51715: LD_ADDR_VAR 0 5
51719: PUSH
51720: LD_VAR 0 10
51724: PUSH
51725: LD_INT 1
51727: ARRAY
51728: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51729: LD_ADDR_VAR 0 10
51733: PUSH
51734: LD_VAR 0 10
51738: PPUSH
51739: LD_INT 1
51741: PPUSH
51742: CALL_OW 3
51746: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51747: LD_VAR 0 2
51751: PPUSH
51752: LD_VAR 0 5
51756: PPUSH
51757: CALL 52066 0 2
51761: PUSH
51762: LD_VAR 0 10
51766: PUSH
51767: EMPTY
51768: EQUAL
51769: OR
51770: IFFALSE 51715
// result := [ ] ;
51772: LD_ADDR_VAR 0 6
51776: PUSH
51777: EMPTY
51778: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51779: LD_VAR 0 1
51783: PPUSH
51784: LD_VAR 0 2
51788: PPUSH
51789: LD_VAR 0 3
51793: PPUSH
51794: LD_VAR 0 4
51798: PPUSH
51799: LD_VAR 0 5
51803: PPUSH
51804: CALL_OW 448
51808: IFFALSE 51841
// result := [ chassis , engine , control , weapon ] ;
51810: LD_ADDR_VAR 0 6
51814: PUSH
51815: LD_VAR 0 2
51819: PUSH
51820: LD_VAR 0 3
51824: PUSH
51825: LD_VAR 0 4
51829: PUSH
51830: LD_VAR 0 5
51834: PUSH
51835: EMPTY
51836: LIST
51837: LIST
51838: LIST
51839: LIST
51840: ST_TO_ADDR
// end ;
51841: LD_VAR 0 6
51845: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51846: LD_INT 0
51848: PPUSH
// if not chassis or not engine then
51849: LD_VAR 0 1
51853: NOT
51854: PUSH
51855: LD_VAR 0 2
51859: NOT
51860: OR
51861: IFFALSE 51865
// exit ;
51863: GO 52061
// case engine of engine_solar :
51865: LD_VAR 0 2
51869: PUSH
51870: LD_INT 2
51872: DOUBLE
51873: EQUAL
51874: IFTRUE 51878
51876: GO 51916
51878: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51879: LD_ADDR_VAR 0 3
51883: PUSH
51884: LD_INT 11
51886: PUSH
51887: LD_INT 12
51889: PUSH
51890: LD_INT 13
51892: PUSH
51893: LD_INT 14
51895: PUSH
51896: LD_INT 1
51898: PUSH
51899: LD_INT 2
51901: PUSH
51902: LD_INT 3
51904: PUSH
51905: EMPTY
51906: LIST
51907: LIST
51908: LIST
51909: LIST
51910: LIST
51911: LIST
51912: LIST
51913: ST_TO_ADDR
51914: GO 52045
51916: LD_INT 1
51918: DOUBLE
51919: EQUAL
51920: IFTRUE 51924
51922: GO 51986
51924: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51925: LD_ADDR_VAR 0 3
51929: PUSH
51930: LD_INT 11
51932: PUSH
51933: LD_INT 12
51935: PUSH
51936: LD_INT 13
51938: PUSH
51939: LD_INT 14
51941: PUSH
51942: LD_INT 1
51944: PUSH
51945: LD_INT 2
51947: PUSH
51948: LD_INT 3
51950: PUSH
51951: LD_INT 4
51953: PUSH
51954: LD_INT 5
51956: PUSH
51957: LD_INT 21
51959: PUSH
51960: LD_INT 23
51962: PUSH
51963: LD_INT 22
51965: PUSH
51966: LD_INT 24
51968: PUSH
51969: EMPTY
51970: LIST
51971: LIST
51972: LIST
51973: LIST
51974: LIST
51975: LIST
51976: LIST
51977: LIST
51978: LIST
51979: LIST
51980: LIST
51981: LIST
51982: LIST
51983: ST_TO_ADDR
51984: GO 52045
51986: LD_INT 3
51988: DOUBLE
51989: EQUAL
51990: IFTRUE 51994
51992: GO 52044
51994: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51995: LD_ADDR_VAR 0 3
51999: PUSH
52000: LD_INT 13
52002: PUSH
52003: LD_INT 14
52005: PUSH
52006: LD_INT 2
52008: PUSH
52009: LD_INT 3
52011: PUSH
52012: LD_INT 4
52014: PUSH
52015: LD_INT 5
52017: PUSH
52018: LD_INT 21
52020: PUSH
52021: LD_INT 22
52023: PUSH
52024: LD_INT 23
52026: PUSH
52027: LD_INT 24
52029: PUSH
52030: EMPTY
52031: LIST
52032: LIST
52033: LIST
52034: LIST
52035: LIST
52036: LIST
52037: LIST
52038: LIST
52039: LIST
52040: LIST
52041: ST_TO_ADDR
52042: GO 52045
52044: POP
// result := ( chassis in result ) ;
52045: LD_ADDR_VAR 0 3
52049: PUSH
52050: LD_VAR 0 1
52054: PUSH
52055: LD_VAR 0 3
52059: IN
52060: ST_TO_ADDR
// end ;
52061: LD_VAR 0 3
52065: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52066: LD_INT 0
52068: PPUSH
// if not chassis or not weapon then
52069: LD_VAR 0 1
52073: NOT
52074: PUSH
52075: LD_VAR 0 2
52079: NOT
52080: OR
52081: IFFALSE 52085
// exit ;
52083: GO 53111
// case weapon of us_machine_gun :
52085: LD_VAR 0 2
52089: PUSH
52090: LD_INT 2
52092: DOUBLE
52093: EQUAL
52094: IFTRUE 52098
52096: GO 52128
52098: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52099: LD_ADDR_VAR 0 3
52103: PUSH
52104: LD_INT 1
52106: PUSH
52107: LD_INT 2
52109: PUSH
52110: LD_INT 3
52112: PUSH
52113: LD_INT 4
52115: PUSH
52116: LD_INT 5
52118: PUSH
52119: EMPTY
52120: LIST
52121: LIST
52122: LIST
52123: LIST
52124: LIST
52125: ST_TO_ADDR
52126: GO 53095
52128: LD_INT 3
52130: DOUBLE
52131: EQUAL
52132: IFTRUE 52136
52134: GO 52166
52136: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52137: LD_ADDR_VAR 0 3
52141: PUSH
52142: LD_INT 1
52144: PUSH
52145: LD_INT 2
52147: PUSH
52148: LD_INT 3
52150: PUSH
52151: LD_INT 4
52153: PUSH
52154: LD_INT 5
52156: PUSH
52157: EMPTY
52158: LIST
52159: LIST
52160: LIST
52161: LIST
52162: LIST
52163: ST_TO_ADDR
52164: GO 53095
52166: LD_INT 11
52168: DOUBLE
52169: EQUAL
52170: IFTRUE 52174
52172: GO 52204
52174: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52175: LD_ADDR_VAR 0 3
52179: PUSH
52180: LD_INT 1
52182: PUSH
52183: LD_INT 2
52185: PUSH
52186: LD_INT 3
52188: PUSH
52189: LD_INT 4
52191: PUSH
52192: LD_INT 5
52194: PUSH
52195: EMPTY
52196: LIST
52197: LIST
52198: LIST
52199: LIST
52200: LIST
52201: ST_TO_ADDR
52202: GO 53095
52204: LD_INT 4
52206: DOUBLE
52207: EQUAL
52208: IFTRUE 52212
52210: GO 52238
52212: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52213: LD_ADDR_VAR 0 3
52217: PUSH
52218: LD_INT 2
52220: PUSH
52221: LD_INT 3
52223: PUSH
52224: LD_INT 4
52226: PUSH
52227: LD_INT 5
52229: PUSH
52230: EMPTY
52231: LIST
52232: LIST
52233: LIST
52234: LIST
52235: ST_TO_ADDR
52236: GO 53095
52238: LD_INT 5
52240: DOUBLE
52241: EQUAL
52242: IFTRUE 52246
52244: GO 52272
52246: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52247: LD_ADDR_VAR 0 3
52251: PUSH
52252: LD_INT 2
52254: PUSH
52255: LD_INT 3
52257: PUSH
52258: LD_INT 4
52260: PUSH
52261: LD_INT 5
52263: PUSH
52264: EMPTY
52265: LIST
52266: LIST
52267: LIST
52268: LIST
52269: ST_TO_ADDR
52270: GO 53095
52272: LD_INT 9
52274: DOUBLE
52275: EQUAL
52276: IFTRUE 52280
52278: GO 52306
52280: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52281: LD_ADDR_VAR 0 3
52285: PUSH
52286: LD_INT 2
52288: PUSH
52289: LD_INT 3
52291: PUSH
52292: LD_INT 4
52294: PUSH
52295: LD_INT 5
52297: PUSH
52298: EMPTY
52299: LIST
52300: LIST
52301: LIST
52302: LIST
52303: ST_TO_ADDR
52304: GO 53095
52306: LD_INT 7
52308: DOUBLE
52309: EQUAL
52310: IFTRUE 52314
52312: GO 52340
52314: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52315: LD_ADDR_VAR 0 3
52319: PUSH
52320: LD_INT 2
52322: PUSH
52323: LD_INT 3
52325: PUSH
52326: LD_INT 4
52328: PUSH
52329: LD_INT 5
52331: PUSH
52332: EMPTY
52333: LIST
52334: LIST
52335: LIST
52336: LIST
52337: ST_TO_ADDR
52338: GO 53095
52340: LD_INT 12
52342: DOUBLE
52343: EQUAL
52344: IFTRUE 52348
52346: GO 52374
52348: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52349: LD_ADDR_VAR 0 3
52353: PUSH
52354: LD_INT 2
52356: PUSH
52357: LD_INT 3
52359: PUSH
52360: LD_INT 4
52362: PUSH
52363: LD_INT 5
52365: PUSH
52366: EMPTY
52367: LIST
52368: LIST
52369: LIST
52370: LIST
52371: ST_TO_ADDR
52372: GO 53095
52374: LD_INT 13
52376: DOUBLE
52377: EQUAL
52378: IFTRUE 52382
52380: GO 52408
52382: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52383: LD_ADDR_VAR 0 3
52387: PUSH
52388: LD_INT 2
52390: PUSH
52391: LD_INT 3
52393: PUSH
52394: LD_INT 4
52396: PUSH
52397: LD_INT 5
52399: PUSH
52400: EMPTY
52401: LIST
52402: LIST
52403: LIST
52404: LIST
52405: ST_TO_ADDR
52406: GO 53095
52408: LD_INT 14
52410: DOUBLE
52411: EQUAL
52412: IFTRUE 52416
52414: GO 52434
52416: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52417: LD_ADDR_VAR 0 3
52421: PUSH
52422: LD_INT 4
52424: PUSH
52425: LD_INT 5
52427: PUSH
52428: EMPTY
52429: LIST
52430: LIST
52431: ST_TO_ADDR
52432: GO 53095
52434: LD_INT 6
52436: DOUBLE
52437: EQUAL
52438: IFTRUE 52442
52440: GO 52460
52442: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52443: LD_ADDR_VAR 0 3
52447: PUSH
52448: LD_INT 4
52450: PUSH
52451: LD_INT 5
52453: PUSH
52454: EMPTY
52455: LIST
52456: LIST
52457: ST_TO_ADDR
52458: GO 53095
52460: LD_INT 10
52462: DOUBLE
52463: EQUAL
52464: IFTRUE 52468
52466: GO 52486
52468: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52469: LD_ADDR_VAR 0 3
52473: PUSH
52474: LD_INT 4
52476: PUSH
52477: LD_INT 5
52479: PUSH
52480: EMPTY
52481: LIST
52482: LIST
52483: ST_TO_ADDR
52484: GO 53095
52486: LD_INT 22
52488: DOUBLE
52489: EQUAL
52490: IFTRUE 52494
52492: GO 52520
52494: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52495: LD_ADDR_VAR 0 3
52499: PUSH
52500: LD_INT 11
52502: PUSH
52503: LD_INT 12
52505: PUSH
52506: LD_INT 13
52508: PUSH
52509: LD_INT 14
52511: PUSH
52512: EMPTY
52513: LIST
52514: LIST
52515: LIST
52516: LIST
52517: ST_TO_ADDR
52518: GO 53095
52520: LD_INT 23
52522: DOUBLE
52523: EQUAL
52524: IFTRUE 52528
52526: GO 52554
52528: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52529: LD_ADDR_VAR 0 3
52533: PUSH
52534: LD_INT 11
52536: PUSH
52537: LD_INT 12
52539: PUSH
52540: LD_INT 13
52542: PUSH
52543: LD_INT 14
52545: PUSH
52546: EMPTY
52547: LIST
52548: LIST
52549: LIST
52550: LIST
52551: ST_TO_ADDR
52552: GO 53095
52554: LD_INT 24
52556: DOUBLE
52557: EQUAL
52558: IFTRUE 52562
52560: GO 52588
52562: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52563: LD_ADDR_VAR 0 3
52567: PUSH
52568: LD_INT 11
52570: PUSH
52571: LD_INT 12
52573: PUSH
52574: LD_INT 13
52576: PUSH
52577: LD_INT 14
52579: PUSH
52580: EMPTY
52581: LIST
52582: LIST
52583: LIST
52584: LIST
52585: ST_TO_ADDR
52586: GO 53095
52588: LD_INT 30
52590: DOUBLE
52591: EQUAL
52592: IFTRUE 52596
52594: GO 52622
52596: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52597: LD_ADDR_VAR 0 3
52601: PUSH
52602: LD_INT 11
52604: PUSH
52605: LD_INT 12
52607: PUSH
52608: LD_INT 13
52610: PUSH
52611: LD_INT 14
52613: PUSH
52614: EMPTY
52615: LIST
52616: LIST
52617: LIST
52618: LIST
52619: ST_TO_ADDR
52620: GO 53095
52622: LD_INT 25
52624: DOUBLE
52625: EQUAL
52626: IFTRUE 52630
52628: GO 52648
52630: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52631: LD_ADDR_VAR 0 3
52635: PUSH
52636: LD_INT 13
52638: PUSH
52639: LD_INT 14
52641: PUSH
52642: EMPTY
52643: LIST
52644: LIST
52645: ST_TO_ADDR
52646: GO 53095
52648: LD_INT 27
52650: DOUBLE
52651: EQUAL
52652: IFTRUE 52656
52654: GO 52674
52656: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52657: LD_ADDR_VAR 0 3
52661: PUSH
52662: LD_INT 13
52664: PUSH
52665: LD_INT 14
52667: PUSH
52668: EMPTY
52669: LIST
52670: LIST
52671: ST_TO_ADDR
52672: GO 53095
52674: LD_INT 28
52676: DOUBLE
52677: EQUAL
52678: IFTRUE 52682
52680: GO 52700
52682: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52683: LD_ADDR_VAR 0 3
52687: PUSH
52688: LD_INT 13
52690: PUSH
52691: LD_INT 14
52693: PUSH
52694: EMPTY
52695: LIST
52696: LIST
52697: ST_TO_ADDR
52698: GO 53095
52700: LD_INT 29
52702: DOUBLE
52703: EQUAL
52704: IFTRUE 52708
52706: GO 52726
52708: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52709: LD_ADDR_VAR 0 3
52713: PUSH
52714: LD_INT 13
52716: PUSH
52717: LD_INT 14
52719: PUSH
52720: EMPTY
52721: LIST
52722: LIST
52723: ST_TO_ADDR
52724: GO 53095
52726: LD_INT 31
52728: DOUBLE
52729: EQUAL
52730: IFTRUE 52734
52732: GO 52752
52734: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52735: LD_ADDR_VAR 0 3
52739: PUSH
52740: LD_INT 13
52742: PUSH
52743: LD_INT 14
52745: PUSH
52746: EMPTY
52747: LIST
52748: LIST
52749: ST_TO_ADDR
52750: GO 53095
52752: LD_INT 26
52754: DOUBLE
52755: EQUAL
52756: IFTRUE 52760
52758: GO 52778
52760: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52761: LD_ADDR_VAR 0 3
52765: PUSH
52766: LD_INT 13
52768: PUSH
52769: LD_INT 14
52771: PUSH
52772: EMPTY
52773: LIST
52774: LIST
52775: ST_TO_ADDR
52776: GO 53095
52778: LD_INT 42
52780: DOUBLE
52781: EQUAL
52782: IFTRUE 52786
52784: GO 52812
52786: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52787: LD_ADDR_VAR 0 3
52791: PUSH
52792: LD_INT 21
52794: PUSH
52795: LD_INT 22
52797: PUSH
52798: LD_INT 23
52800: PUSH
52801: LD_INT 24
52803: PUSH
52804: EMPTY
52805: LIST
52806: LIST
52807: LIST
52808: LIST
52809: ST_TO_ADDR
52810: GO 53095
52812: LD_INT 43
52814: DOUBLE
52815: EQUAL
52816: IFTRUE 52820
52818: GO 52846
52820: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52821: LD_ADDR_VAR 0 3
52825: PUSH
52826: LD_INT 21
52828: PUSH
52829: LD_INT 22
52831: PUSH
52832: LD_INT 23
52834: PUSH
52835: LD_INT 24
52837: PUSH
52838: EMPTY
52839: LIST
52840: LIST
52841: LIST
52842: LIST
52843: ST_TO_ADDR
52844: GO 53095
52846: LD_INT 44
52848: DOUBLE
52849: EQUAL
52850: IFTRUE 52854
52852: GO 52880
52854: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52855: LD_ADDR_VAR 0 3
52859: PUSH
52860: LD_INT 21
52862: PUSH
52863: LD_INT 22
52865: PUSH
52866: LD_INT 23
52868: PUSH
52869: LD_INT 24
52871: PUSH
52872: EMPTY
52873: LIST
52874: LIST
52875: LIST
52876: LIST
52877: ST_TO_ADDR
52878: GO 53095
52880: LD_INT 45
52882: DOUBLE
52883: EQUAL
52884: IFTRUE 52888
52886: GO 52914
52888: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52889: LD_ADDR_VAR 0 3
52893: PUSH
52894: LD_INT 21
52896: PUSH
52897: LD_INT 22
52899: PUSH
52900: LD_INT 23
52902: PUSH
52903: LD_INT 24
52905: PUSH
52906: EMPTY
52907: LIST
52908: LIST
52909: LIST
52910: LIST
52911: ST_TO_ADDR
52912: GO 53095
52914: LD_INT 49
52916: DOUBLE
52917: EQUAL
52918: IFTRUE 52922
52920: GO 52948
52922: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52923: LD_ADDR_VAR 0 3
52927: PUSH
52928: LD_INT 21
52930: PUSH
52931: LD_INT 22
52933: PUSH
52934: LD_INT 23
52936: PUSH
52937: LD_INT 24
52939: PUSH
52940: EMPTY
52941: LIST
52942: LIST
52943: LIST
52944: LIST
52945: ST_TO_ADDR
52946: GO 53095
52948: LD_INT 51
52950: DOUBLE
52951: EQUAL
52952: IFTRUE 52956
52954: GO 52982
52956: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52957: LD_ADDR_VAR 0 3
52961: PUSH
52962: LD_INT 21
52964: PUSH
52965: LD_INT 22
52967: PUSH
52968: LD_INT 23
52970: PUSH
52971: LD_INT 24
52973: PUSH
52974: EMPTY
52975: LIST
52976: LIST
52977: LIST
52978: LIST
52979: ST_TO_ADDR
52980: GO 53095
52982: LD_INT 52
52984: DOUBLE
52985: EQUAL
52986: IFTRUE 52990
52988: GO 53016
52990: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
52991: LD_ADDR_VAR 0 3
52995: PUSH
52996: LD_INT 21
52998: PUSH
52999: LD_INT 22
53001: PUSH
53002: LD_INT 23
53004: PUSH
53005: LD_INT 24
53007: PUSH
53008: EMPTY
53009: LIST
53010: LIST
53011: LIST
53012: LIST
53013: ST_TO_ADDR
53014: GO 53095
53016: LD_INT 53
53018: DOUBLE
53019: EQUAL
53020: IFTRUE 53024
53022: GO 53042
53024: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53025: LD_ADDR_VAR 0 3
53029: PUSH
53030: LD_INT 23
53032: PUSH
53033: LD_INT 24
53035: PUSH
53036: EMPTY
53037: LIST
53038: LIST
53039: ST_TO_ADDR
53040: GO 53095
53042: LD_INT 46
53044: DOUBLE
53045: EQUAL
53046: IFTRUE 53050
53048: GO 53068
53050: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53051: LD_ADDR_VAR 0 3
53055: PUSH
53056: LD_INT 23
53058: PUSH
53059: LD_INT 24
53061: PUSH
53062: EMPTY
53063: LIST
53064: LIST
53065: ST_TO_ADDR
53066: GO 53095
53068: LD_INT 47
53070: DOUBLE
53071: EQUAL
53072: IFTRUE 53076
53074: GO 53094
53076: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53077: LD_ADDR_VAR 0 3
53081: PUSH
53082: LD_INT 23
53084: PUSH
53085: LD_INT 24
53087: PUSH
53088: EMPTY
53089: LIST
53090: LIST
53091: ST_TO_ADDR
53092: GO 53095
53094: POP
// result := ( chassis in result ) ;
53095: LD_ADDR_VAR 0 3
53099: PUSH
53100: LD_VAR 0 1
53104: PUSH
53105: LD_VAR 0 3
53109: IN
53110: ST_TO_ADDR
// end ;
53111: LD_VAR 0 3
53115: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53116: LD_INT 0
53118: PPUSH
53119: PPUSH
53120: PPUSH
53121: PPUSH
53122: PPUSH
53123: PPUSH
53124: PPUSH
// result := array ;
53125: LD_ADDR_VAR 0 5
53129: PUSH
53130: LD_VAR 0 1
53134: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53135: LD_VAR 0 1
53139: NOT
53140: PUSH
53141: LD_VAR 0 2
53145: NOT
53146: OR
53147: PUSH
53148: LD_VAR 0 3
53152: NOT
53153: OR
53154: PUSH
53155: LD_VAR 0 2
53159: PUSH
53160: LD_VAR 0 1
53164: GREATER
53165: OR
53166: PUSH
53167: LD_VAR 0 3
53171: PUSH
53172: LD_VAR 0 1
53176: GREATER
53177: OR
53178: IFFALSE 53182
// exit ;
53180: GO 53478
// if direction then
53182: LD_VAR 0 4
53186: IFFALSE 53250
// begin d := 1 ;
53188: LD_ADDR_VAR 0 9
53192: PUSH
53193: LD_INT 1
53195: ST_TO_ADDR
// if i_from > i_to then
53196: LD_VAR 0 2
53200: PUSH
53201: LD_VAR 0 3
53205: GREATER
53206: IFFALSE 53232
// length := ( array - i_from ) + i_to else
53208: LD_ADDR_VAR 0 11
53212: PUSH
53213: LD_VAR 0 1
53217: PUSH
53218: LD_VAR 0 2
53222: MINUS
53223: PUSH
53224: LD_VAR 0 3
53228: PLUS
53229: ST_TO_ADDR
53230: GO 53248
// length := i_to - i_from ;
53232: LD_ADDR_VAR 0 11
53236: PUSH
53237: LD_VAR 0 3
53241: PUSH
53242: LD_VAR 0 2
53246: MINUS
53247: ST_TO_ADDR
// end else
53248: GO 53311
// begin d := - 1 ;
53250: LD_ADDR_VAR 0 9
53254: PUSH
53255: LD_INT 1
53257: NEG
53258: ST_TO_ADDR
// if i_from > i_to then
53259: LD_VAR 0 2
53263: PUSH
53264: LD_VAR 0 3
53268: GREATER
53269: IFFALSE 53289
// length := i_from - i_to else
53271: LD_ADDR_VAR 0 11
53275: PUSH
53276: LD_VAR 0 2
53280: PUSH
53281: LD_VAR 0 3
53285: MINUS
53286: ST_TO_ADDR
53287: GO 53311
// length := ( array - i_to ) + i_from ;
53289: LD_ADDR_VAR 0 11
53293: PUSH
53294: LD_VAR 0 1
53298: PUSH
53299: LD_VAR 0 3
53303: MINUS
53304: PUSH
53305: LD_VAR 0 2
53309: PLUS
53310: ST_TO_ADDR
// end ; if not length then
53311: LD_VAR 0 11
53315: NOT
53316: IFFALSE 53320
// exit ;
53318: GO 53478
// tmp := array ;
53320: LD_ADDR_VAR 0 10
53324: PUSH
53325: LD_VAR 0 1
53329: ST_TO_ADDR
// for i = 1 to length do
53330: LD_ADDR_VAR 0 6
53334: PUSH
53335: DOUBLE
53336: LD_INT 1
53338: DEC
53339: ST_TO_ADDR
53340: LD_VAR 0 11
53344: PUSH
53345: FOR_TO
53346: IFFALSE 53466
// begin for j = 1 to array do
53348: LD_ADDR_VAR 0 7
53352: PUSH
53353: DOUBLE
53354: LD_INT 1
53356: DEC
53357: ST_TO_ADDR
53358: LD_VAR 0 1
53362: PUSH
53363: FOR_TO
53364: IFFALSE 53452
// begin k := j + d ;
53366: LD_ADDR_VAR 0 8
53370: PUSH
53371: LD_VAR 0 7
53375: PUSH
53376: LD_VAR 0 9
53380: PLUS
53381: ST_TO_ADDR
// if k > array then
53382: LD_VAR 0 8
53386: PUSH
53387: LD_VAR 0 1
53391: GREATER
53392: IFFALSE 53402
// k := 1 ;
53394: LD_ADDR_VAR 0 8
53398: PUSH
53399: LD_INT 1
53401: ST_TO_ADDR
// if not k then
53402: LD_VAR 0 8
53406: NOT
53407: IFFALSE 53419
// k := array ;
53409: LD_ADDR_VAR 0 8
53413: PUSH
53414: LD_VAR 0 1
53418: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53419: LD_ADDR_VAR 0 10
53423: PUSH
53424: LD_VAR 0 10
53428: PPUSH
53429: LD_VAR 0 8
53433: PPUSH
53434: LD_VAR 0 1
53438: PUSH
53439: LD_VAR 0 7
53443: ARRAY
53444: PPUSH
53445: CALL_OW 1
53449: ST_TO_ADDR
// end ;
53450: GO 53363
53452: POP
53453: POP
// array := tmp ;
53454: LD_ADDR_VAR 0 1
53458: PUSH
53459: LD_VAR 0 10
53463: ST_TO_ADDR
// end ;
53464: GO 53345
53466: POP
53467: POP
// result := array ;
53468: LD_ADDR_VAR 0 5
53472: PUSH
53473: LD_VAR 0 1
53477: ST_TO_ADDR
// end ;
53478: LD_VAR 0 5
53482: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53483: LD_INT 0
53485: PPUSH
53486: PPUSH
// result := 0 ;
53487: LD_ADDR_VAR 0 3
53491: PUSH
53492: LD_INT 0
53494: ST_TO_ADDR
// if not array or not value in array then
53495: LD_VAR 0 1
53499: NOT
53500: PUSH
53501: LD_VAR 0 2
53505: PUSH
53506: LD_VAR 0 1
53510: IN
53511: NOT
53512: OR
53513: IFFALSE 53517
// exit ;
53515: GO 53571
// for i = 1 to array do
53517: LD_ADDR_VAR 0 4
53521: PUSH
53522: DOUBLE
53523: LD_INT 1
53525: DEC
53526: ST_TO_ADDR
53527: LD_VAR 0 1
53531: PUSH
53532: FOR_TO
53533: IFFALSE 53569
// if value = array [ i ] then
53535: LD_VAR 0 2
53539: PUSH
53540: LD_VAR 0 1
53544: PUSH
53545: LD_VAR 0 4
53549: ARRAY
53550: EQUAL
53551: IFFALSE 53567
// begin result := i ;
53553: LD_ADDR_VAR 0 3
53557: PUSH
53558: LD_VAR 0 4
53562: ST_TO_ADDR
// exit ;
53563: POP
53564: POP
53565: GO 53571
// end ;
53567: GO 53532
53569: POP
53570: POP
// end ;
53571: LD_VAR 0 3
53575: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53576: LD_INT 0
53578: PPUSH
// vc_chassis := chassis ;
53579: LD_ADDR_OWVAR 37
53583: PUSH
53584: LD_VAR 0 1
53588: ST_TO_ADDR
// vc_engine := engine ;
53589: LD_ADDR_OWVAR 39
53593: PUSH
53594: LD_VAR 0 2
53598: ST_TO_ADDR
// vc_control := control ;
53599: LD_ADDR_OWVAR 38
53603: PUSH
53604: LD_VAR 0 3
53608: ST_TO_ADDR
// vc_weapon := weapon ;
53609: LD_ADDR_OWVAR 40
53613: PUSH
53614: LD_VAR 0 4
53618: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53619: LD_ADDR_OWVAR 41
53623: PUSH
53624: LD_VAR 0 5
53628: ST_TO_ADDR
// end ;
53629: LD_VAR 0 6
53633: RET
// export function WantPlant ( unit ) ; var task ; begin
53634: LD_INT 0
53636: PPUSH
53637: PPUSH
// result := false ;
53638: LD_ADDR_VAR 0 2
53642: PUSH
53643: LD_INT 0
53645: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53646: LD_ADDR_VAR 0 3
53650: PUSH
53651: LD_VAR 0 1
53655: PPUSH
53656: CALL_OW 437
53660: ST_TO_ADDR
// if task then
53661: LD_VAR 0 3
53665: IFFALSE 53693
// if task [ 1 ] [ 1 ] = p then
53667: LD_VAR 0 3
53671: PUSH
53672: LD_INT 1
53674: ARRAY
53675: PUSH
53676: LD_INT 1
53678: ARRAY
53679: PUSH
53680: LD_STRING p
53682: EQUAL
53683: IFFALSE 53693
// result := true ;
53685: LD_ADDR_VAR 0 2
53689: PUSH
53690: LD_INT 1
53692: ST_TO_ADDR
// end ;
53693: LD_VAR 0 2
53697: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53698: LD_INT 0
53700: PPUSH
53701: PPUSH
53702: PPUSH
53703: PPUSH
// if pos < 1 then
53704: LD_VAR 0 2
53708: PUSH
53709: LD_INT 1
53711: LESS
53712: IFFALSE 53716
// exit ;
53714: GO 54019
// if pos = 1 then
53716: LD_VAR 0 2
53720: PUSH
53721: LD_INT 1
53723: EQUAL
53724: IFFALSE 53757
// result := Replace ( arr , pos [ 1 ] , value ) else
53726: LD_ADDR_VAR 0 4
53730: PUSH
53731: LD_VAR 0 1
53735: PPUSH
53736: LD_VAR 0 2
53740: PUSH
53741: LD_INT 1
53743: ARRAY
53744: PPUSH
53745: LD_VAR 0 3
53749: PPUSH
53750: CALL_OW 1
53754: ST_TO_ADDR
53755: GO 54019
// begin tmp := arr ;
53757: LD_ADDR_VAR 0 6
53761: PUSH
53762: LD_VAR 0 1
53766: ST_TO_ADDR
// s_arr := [ tmp ] ;
53767: LD_ADDR_VAR 0 7
53771: PUSH
53772: LD_VAR 0 6
53776: PUSH
53777: EMPTY
53778: LIST
53779: ST_TO_ADDR
// for i = 1 to pos - 1 do
53780: LD_ADDR_VAR 0 5
53784: PUSH
53785: DOUBLE
53786: LD_INT 1
53788: DEC
53789: ST_TO_ADDR
53790: LD_VAR 0 2
53794: PUSH
53795: LD_INT 1
53797: MINUS
53798: PUSH
53799: FOR_TO
53800: IFFALSE 53845
// begin tmp := tmp [ pos [ i ] ] ;
53802: LD_ADDR_VAR 0 6
53806: PUSH
53807: LD_VAR 0 6
53811: PUSH
53812: LD_VAR 0 2
53816: PUSH
53817: LD_VAR 0 5
53821: ARRAY
53822: ARRAY
53823: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53824: LD_ADDR_VAR 0 7
53828: PUSH
53829: LD_VAR 0 7
53833: PUSH
53834: LD_VAR 0 6
53838: PUSH
53839: EMPTY
53840: LIST
53841: ADD
53842: ST_TO_ADDR
// end ;
53843: GO 53799
53845: POP
53846: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53847: LD_ADDR_VAR 0 6
53851: PUSH
53852: LD_VAR 0 6
53856: PPUSH
53857: LD_VAR 0 2
53861: PUSH
53862: LD_VAR 0 2
53866: ARRAY
53867: PPUSH
53868: LD_VAR 0 3
53872: PPUSH
53873: CALL_OW 1
53877: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53878: LD_ADDR_VAR 0 7
53882: PUSH
53883: LD_VAR 0 7
53887: PPUSH
53888: LD_VAR 0 7
53892: PPUSH
53893: LD_VAR 0 6
53897: PPUSH
53898: CALL_OW 1
53902: ST_TO_ADDR
// for i = s_arr downto 2 do
53903: LD_ADDR_VAR 0 5
53907: PUSH
53908: DOUBLE
53909: LD_VAR 0 7
53913: INC
53914: ST_TO_ADDR
53915: LD_INT 2
53917: PUSH
53918: FOR_DOWNTO
53919: IFFALSE 54003
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53921: LD_ADDR_VAR 0 6
53925: PUSH
53926: LD_VAR 0 7
53930: PUSH
53931: LD_VAR 0 5
53935: PUSH
53936: LD_INT 1
53938: MINUS
53939: ARRAY
53940: PPUSH
53941: LD_VAR 0 2
53945: PUSH
53946: LD_VAR 0 5
53950: PUSH
53951: LD_INT 1
53953: MINUS
53954: ARRAY
53955: PPUSH
53956: LD_VAR 0 7
53960: PUSH
53961: LD_VAR 0 5
53965: ARRAY
53966: PPUSH
53967: CALL_OW 1
53971: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53972: LD_ADDR_VAR 0 7
53976: PUSH
53977: LD_VAR 0 7
53981: PPUSH
53982: LD_VAR 0 5
53986: PUSH
53987: LD_INT 1
53989: MINUS
53990: PPUSH
53991: LD_VAR 0 6
53995: PPUSH
53996: CALL_OW 1
54000: ST_TO_ADDR
// end ;
54001: GO 53918
54003: POP
54004: POP
// result := s_arr [ 1 ] ;
54005: LD_ADDR_VAR 0 4
54009: PUSH
54010: LD_VAR 0 7
54014: PUSH
54015: LD_INT 1
54017: ARRAY
54018: ST_TO_ADDR
// end ; end ;
54019: LD_VAR 0 4
54023: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54024: LD_INT 0
54026: PPUSH
54027: PPUSH
// if not list then
54028: LD_VAR 0 1
54032: NOT
54033: IFFALSE 54037
// exit ;
54035: GO 54128
// i := list [ pos1 ] ;
54037: LD_ADDR_VAR 0 5
54041: PUSH
54042: LD_VAR 0 1
54046: PUSH
54047: LD_VAR 0 2
54051: ARRAY
54052: ST_TO_ADDR
// if not i then
54053: LD_VAR 0 5
54057: NOT
54058: IFFALSE 54062
// exit ;
54060: GO 54128
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54062: LD_ADDR_VAR 0 1
54066: PUSH
54067: LD_VAR 0 1
54071: PPUSH
54072: LD_VAR 0 2
54076: PPUSH
54077: LD_VAR 0 1
54081: PUSH
54082: LD_VAR 0 3
54086: ARRAY
54087: PPUSH
54088: CALL_OW 1
54092: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54093: LD_ADDR_VAR 0 1
54097: PUSH
54098: LD_VAR 0 1
54102: PPUSH
54103: LD_VAR 0 3
54107: PPUSH
54108: LD_VAR 0 5
54112: PPUSH
54113: CALL_OW 1
54117: ST_TO_ADDR
// result := list ;
54118: LD_ADDR_VAR 0 4
54122: PUSH
54123: LD_VAR 0 1
54127: ST_TO_ADDR
// end ;
54128: LD_VAR 0 4
54132: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54133: LD_INT 0
54135: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54136: LD_ADDR_VAR 0 5
54140: PUSH
54141: LD_VAR 0 1
54145: PPUSH
54146: CALL_OW 250
54150: PPUSH
54151: LD_VAR 0 1
54155: PPUSH
54156: CALL_OW 251
54160: PPUSH
54161: LD_VAR 0 2
54165: PPUSH
54166: LD_VAR 0 3
54170: PPUSH
54171: LD_VAR 0 4
54175: PPUSH
54176: CALL 54186 0 5
54180: ST_TO_ADDR
// end ;
54181: LD_VAR 0 5
54185: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54186: LD_INT 0
54188: PPUSH
54189: PPUSH
54190: PPUSH
54191: PPUSH
// if not list then
54192: LD_VAR 0 3
54196: NOT
54197: IFFALSE 54201
// exit ;
54199: GO 54589
// result := [ ] ;
54201: LD_ADDR_VAR 0 6
54205: PUSH
54206: EMPTY
54207: ST_TO_ADDR
// for i in list do
54208: LD_ADDR_VAR 0 7
54212: PUSH
54213: LD_VAR 0 3
54217: PUSH
54218: FOR_IN
54219: IFFALSE 54421
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54221: LD_ADDR_VAR 0 9
54225: PUSH
54226: LD_VAR 0 7
54230: PPUSH
54231: LD_VAR 0 1
54235: PPUSH
54236: LD_VAR 0 2
54240: PPUSH
54241: CALL_OW 297
54245: ST_TO_ADDR
// if not result then
54246: LD_VAR 0 6
54250: NOT
54251: IFFALSE 54277
// result := [ [ i , tmp ] ] else
54253: LD_ADDR_VAR 0 6
54257: PUSH
54258: LD_VAR 0 7
54262: PUSH
54263: LD_VAR 0 9
54267: PUSH
54268: EMPTY
54269: LIST
54270: LIST
54271: PUSH
54272: EMPTY
54273: LIST
54274: ST_TO_ADDR
54275: GO 54419
// begin if result [ result ] [ 2 ] < tmp then
54277: LD_VAR 0 6
54281: PUSH
54282: LD_VAR 0 6
54286: ARRAY
54287: PUSH
54288: LD_INT 2
54290: ARRAY
54291: PUSH
54292: LD_VAR 0 9
54296: LESS
54297: IFFALSE 54339
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54299: LD_ADDR_VAR 0 6
54303: PUSH
54304: LD_VAR 0 6
54308: PPUSH
54309: LD_VAR 0 6
54313: PUSH
54314: LD_INT 1
54316: PLUS
54317: PPUSH
54318: LD_VAR 0 7
54322: PUSH
54323: LD_VAR 0 9
54327: PUSH
54328: EMPTY
54329: LIST
54330: LIST
54331: PPUSH
54332: CALL_OW 2
54336: ST_TO_ADDR
54337: GO 54419
// for j = 1 to result do
54339: LD_ADDR_VAR 0 8
54343: PUSH
54344: DOUBLE
54345: LD_INT 1
54347: DEC
54348: ST_TO_ADDR
54349: LD_VAR 0 6
54353: PUSH
54354: FOR_TO
54355: IFFALSE 54417
// begin if tmp < result [ j ] [ 2 ] then
54357: LD_VAR 0 9
54361: PUSH
54362: LD_VAR 0 6
54366: PUSH
54367: LD_VAR 0 8
54371: ARRAY
54372: PUSH
54373: LD_INT 2
54375: ARRAY
54376: LESS
54377: IFFALSE 54415
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54379: LD_ADDR_VAR 0 6
54383: PUSH
54384: LD_VAR 0 6
54388: PPUSH
54389: LD_VAR 0 8
54393: PPUSH
54394: LD_VAR 0 7
54398: PUSH
54399: LD_VAR 0 9
54403: PUSH
54404: EMPTY
54405: LIST
54406: LIST
54407: PPUSH
54408: CALL_OW 2
54412: ST_TO_ADDR
// break ;
54413: GO 54417
// end ; end ;
54415: GO 54354
54417: POP
54418: POP
// end ; end ;
54419: GO 54218
54421: POP
54422: POP
// if result and not asc then
54423: LD_VAR 0 6
54427: PUSH
54428: LD_VAR 0 4
54432: NOT
54433: AND
54434: IFFALSE 54509
// begin tmp := result ;
54436: LD_ADDR_VAR 0 9
54440: PUSH
54441: LD_VAR 0 6
54445: ST_TO_ADDR
// for i = tmp downto 1 do
54446: LD_ADDR_VAR 0 7
54450: PUSH
54451: DOUBLE
54452: LD_VAR 0 9
54456: INC
54457: ST_TO_ADDR
54458: LD_INT 1
54460: PUSH
54461: FOR_DOWNTO
54462: IFFALSE 54507
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54464: LD_ADDR_VAR 0 6
54468: PUSH
54469: LD_VAR 0 6
54473: PPUSH
54474: LD_VAR 0 9
54478: PUSH
54479: LD_VAR 0 7
54483: MINUS
54484: PUSH
54485: LD_INT 1
54487: PLUS
54488: PPUSH
54489: LD_VAR 0 9
54493: PUSH
54494: LD_VAR 0 7
54498: ARRAY
54499: PPUSH
54500: CALL_OW 1
54504: ST_TO_ADDR
54505: GO 54461
54507: POP
54508: POP
// end ; tmp := [ ] ;
54509: LD_ADDR_VAR 0 9
54513: PUSH
54514: EMPTY
54515: ST_TO_ADDR
// if mode then
54516: LD_VAR 0 5
54520: IFFALSE 54589
// begin for i = 1 to result do
54522: LD_ADDR_VAR 0 7
54526: PUSH
54527: DOUBLE
54528: LD_INT 1
54530: DEC
54531: ST_TO_ADDR
54532: LD_VAR 0 6
54536: PUSH
54537: FOR_TO
54538: IFFALSE 54577
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54540: LD_ADDR_VAR 0 9
54544: PUSH
54545: LD_VAR 0 9
54549: PPUSH
54550: LD_VAR 0 7
54554: PPUSH
54555: LD_VAR 0 6
54559: PUSH
54560: LD_VAR 0 7
54564: ARRAY
54565: PUSH
54566: LD_INT 1
54568: ARRAY
54569: PPUSH
54570: CALL_OW 1
54574: ST_TO_ADDR
54575: GO 54537
54577: POP
54578: POP
// result := tmp ;
54579: LD_ADDR_VAR 0 6
54583: PUSH
54584: LD_VAR 0 9
54588: ST_TO_ADDR
// end ; end ;
54589: LD_VAR 0 6
54593: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54594: LD_INT 0
54596: PPUSH
54597: PPUSH
54598: PPUSH
54599: PPUSH
54600: PPUSH
54601: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54602: LD_ADDR_VAR 0 5
54606: PUSH
54607: LD_INT 0
54609: PUSH
54610: LD_INT 0
54612: PUSH
54613: LD_INT 0
54615: PUSH
54616: EMPTY
54617: PUSH
54618: EMPTY
54619: LIST
54620: LIST
54621: LIST
54622: LIST
54623: ST_TO_ADDR
// if not x or not y then
54624: LD_VAR 0 2
54628: NOT
54629: PUSH
54630: LD_VAR 0 3
54634: NOT
54635: OR
54636: IFFALSE 54640
// exit ;
54638: GO 56286
// if not range then
54640: LD_VAR 0 4
54644: NOT
54645: IFFALSE 54655
// range := 10 ;
54647: LD_ADDR_VAR 0 4
54651: PUSH
54652: LD_INT 10
54654: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54655: LD_ADDR_VAR 0 8
54659: PUSH
54660: LD_INT 81
54662: PUSH
54663: LD_VAR 0 1
54667: PUSH
54668: EMPTY
54669: LIST
54670: LIST
54671: PUSH
54672: LD_INT 92
54674: PUSH
54675: LD_VAR 0 2
54679: PUSH
54680: LD_VAR 0 3
54684: PUSH
54685: LD_VAR 0 4
54689: PUSH
54690: EMPTY
54691: LIST
54692: LIST
54693: LIST
54694: LIST
54695: PUSH
54696: LD_INT 3
54698: PUSH
54699: LD_INT 21
54701: PUSH
54702: LD_INT 3
54704: PUSH
54705: EMPTY
54706: LIST
54707: LIST
54708: PUSH
54709: EMPTY
54710: LIST
54711: LIST
54712: PUSH
54713: EMPTY
54714: LIST
54715: LIST
54716: LIST
54717: PPUSH
54718: CALL_OW 69
54722: ST_TO_ADDR
// if not tmp then
54723: LD_VAR 0 8
54727: NOT
54728: IFFALSE 54732
// exit ;
54730: GO 56286
// for i in tmp do
54732: LD_ADDR_VAR 0 6
54736: PUSH
54737: LD_VAR 0 8
54741: PUSH
54742: FOR_IN
54743: IFFALSE 56261
// begin points := [ 0 , 0 , 0 ] ;
54745: LD_ADDR_VAR 0 9
54749: PUSH
54750: LD_INT 0
54752: PUSH
54753: LD_INT 0
54755: PUSH
54756: LD_INT 0
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: LIST
54763: ST_TO_ADDR
// bpoints := 1 ;
54764: LD_ADDR_VAR 0 10
54768: PUSH
54769: LD_INT 1
54771: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54772: LD_VAR 0 6
54776: PPUSH
54777: CALL_OW 247
54781: PUSH
54782: LD_INT 1
54784: DOUBLE
54785: EQUAL
54786: IFTRUE 54790
54788: GO 55368
54790: POP
// begin if GetClass ( i ) = 1 then
54791: LD_VAR 0 6
54795: PPUSH
54796: CALL_OW 257
54800: PUSH
54801: LD_INT 1
54803: EQUAL
54804: IFFALSE 54825
// points := [ 10 , 5 , 3 ] ;
54806: LD_ADDR_VAR 0 9
54810: PUSH
54811: LD_INT 10
54813: PUSH
54814: LD_INT 5
54816: PUSH
54817: LD_INT 3
54819: PUSH
54820: EMPTY
54821: LIST
54822: LIST
54823: LIST
54824: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54825: LD_VAR 0 6
54829: PPUSH
54830: CALL_OW 257
54834: PUSH
54835: LD_INT 2
54837: PUSH
54838: LD_INT 3
54840: PUSH
54841: LD_INT 4
54843: PUSH
54844: EMPTY
54845: LIST
54846: LIST
54847: LIST
54848: IN
54849: IFFALSE 54870
// points := [ 3 , 2 , 1 ] ;
54851: LD_ADDR_VAR 0 9
54855: PUSH
54856: LD_INT 3
54858: PUSH
54859: LD_INT 2
54861: PUSH
54862: LD_INT 1
54864: PUSH
54865: EMPTY
54866: LIST
54867: LIST
54868: LIST
54869: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54870: LD_VAR 0 6
54874: PPUSH
54875: CALL_OW 257
54879: PUSH
54880: LD_INT 5
54882: EQUAL
54883: IFFALSE 54904
// points := [ 130 , 5 , 2 ] ;
54885: LD_ADDR_VAR 0 9
54889: PUSH
54890: LD_INT 130
54892: PUSH
54893: LD_INT 5
54895: PUSH
54896: LD_INT 2
54898: PUSH
54899: EMPTY
54900: LIST
54901: LIST
54902: LIST
54903: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54904: LD_VAR 0 6
54908: PPUSH
54909: CALL_OW 257
54913: PUSH
54914: LD_INT 8
54916: EQUAL
54917: IFFALSE 54938
// points := [ 35 , 35 , 30 ] ;
54919: LD_ADDR_VAR 0 9
54923: PUSH
54924: LD_INT 35
54926: PUSH
54927: LD_INT 35
54929: PUSH
54930: LD_INT 30
54932: PUSH
54933: EMPTY
54934: LIST
54935: LIST
54936: LIST
54937: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54938: LD_VAR 0 6
54942: PPUSH
54943: CALL_OW 257
54947: PUSH
54948: LD_INT 9
54950: EQUAL
54951: IFFALSE 54972
// points := [ 20 , 55 , 40 ] ;
54953: LD_ADDR_VAR 0 9
54957: PUSH
54958: LD_INT 20
54960: PUSH
54961: LD_INT 55
54963: PUSH
54964: LD_INT 40
54966: PUSH
54967: EMPTY
54968: LIST
54969: LIST
54970: LIST
54971: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54972: LD_VAR 0 6
54976: PPUSH
54977: CALL_OW 257
54981: PUSH
54982: LD_INT 12
54984: PUSH
54985: LD_INT 16
54987: PUSH
54988: EMPTY
54989: LIST
54990: LIST
54991: IN
54992: IFFALSE 55013
// points := [ 5 , 3 , 2 ] ;
54994: LD_ADDR_VAR 0 9
54998: PUSH
54999: LD_INT 5
55001: PUSH
55002: LD_INT 3
55004: PUSH
55005: LD_INT 2
55007: PUSH
55008: EMPTY
55009: LIST
55010: LIST
55011: LIST
55012: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55013: LD_VAR 0 6
55017: PPUSH
55018: CALL_OW 257
55022: PUSH
55023: LD_INT 17
55025: EQUAL
55026: IFFALSE 55047
// points := [ 100 , 50 , 75 ] ;
55028: LD_ADDR_VAR 0 9
55032: PUSH
55033: LD_INT 100
55035: PUSH
55036: LD_INT 50
55038: PUSH
55039: LD_INT 75
55041: PUSH
55042: EMPTY
55043: LIST
55044: LIST
55045: LIST
55046: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55047: LD_VAR 0 6
55051: PPUSH
55052: CALL_OW 257
55056: PUSH
55057: LD_INT 15
55059: EQUAL
55060: IFFALSE 55081
// points := [ 10 , 5 , 3 ] ;
55062: LD_ADDR_VAR 0 9
55066: PUSH
55067: LD_INT 10
55069: PUSH
55070: LD_INT 5
55072: PUSH
55073: LD_INT 3
55075: PUSH
55076: EMPTY
55077: LIST
55078: LIST
55079: LIST
55080: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55081: LD_VAR 0 6
55085: PPUSH
55086: CALL_OW 257
55090: PUSH
55091: LD_INT 14
55093: EQUAL
55094: IFFALSE 55115
// points := [ 10 , 0 , 0 ] ;
55096: LD_ADDR_VAR 0 9
55100: PUSH
55101: LD_INT 10
55103: PUSH
55104: LD_INT 0
55106: PUSH
55107: LD_INT 0
55109: PUSH
55110: EMPTY
55111: LIST
55112: LIST
55113: LIST
55114: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55115: LD_VAR 0 6
55119: PPUSH
55120: CALL_OW 257
55124: PUSH
55125: LD_INT 11
55127: EQUAL
55128: IFFALSE 55149
// points := [ 30 , 10 , 5 ] ;
55130: LD_ADDR_VAR 0 9
55134: PUSH
55135: LD_INT 30
55137: PUSH
55138: LD_INT 10
55140: PUSH
55141: LD_INT 5
55143: PUSH
55144: EMPTY
55145: LIST
55146: LIST
55147: LIST
55148: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55149: LD_VAR 0 1
55153: PPUSH
55154: LD_INT 5
55156: PPUSH
55157: CALL_OW 321
55161: PUSH
55162: LD_INT 2
55164: EQUAL
55165: IFFALSE 55182
// bpoints := bpoints * 1.8 ;
55167: LD_ADDR_VAR 0 10
55171: PUSH
55172: LD_VAR 0 10
55176: PUSH
55177: LD_REAL  1.80000000000000E+0000
55180: MUL
55181: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55182: LD_VAR 0 6
55186: PPUSH
55187: CALL_OW 257
55191: PUSH
55192: LD_INT 1
55194: PUSH
55195: LD_INT 2
55197: PUSH
55198: LD_INT 3
55200: PUSH
55201: LD_INT 4
55203: PUSH
55204: EMPTY
55205: LIST
55206: LIST
55207: LIST
55208: LIST
55209: IN
55210: PUSH
55211: LD_VAR 0 1
55215: PPUSH
55216: LD_INT 51
55218: PPUSH
55219: CALL_OW 321
55223: PUSH
55224: LD_INT 2
55226: EQUAL
55227: AND
55228: IFFALSE 55245
// bpoints := bpoints * 1.2 ;
55230: LD_ADDR_VAR 0 10
55234: PUSH
55235: LD_VAR 0 10
55239: PUSH
55240: LD_REAL  1.20000000000000E+0000
55243: MUL
55244: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55245: LD_VAR 0 6
55249: PPUSH
55250: CALL_OW 257
55254: PUSH
55255: LD_INT 5
55257: PUSH
55258: LD_INT 7
55260: PUSH
55261: LD_INT 9
55263: PUSH
55264: EMPTY
55265: LIST
55266: LIST
55267: LIST
55268: IN
55269: PUSH
55270: LD_VAR 0 1
55274: PPUSH
55275: LD_INT 52
55277: PPUSH
55278: CALL_OW 321
55282: PUSH
55283: LD_INT 2
55285: EQUAL
55286: AND
55287: IFFALSE 55304
// bpoints := bpoints * 1.5 ;
55289: LD_ADDR_VAR 0 10
55293: PUSH
55294: LD_VAR 0 10
55298: PUSH
55299: LD_REAL  1.50000000000000E+0000
55302: MUL
55303: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55304: LD_VAR 0 1
55308: PPUSH
55309: LD_INT 66
55311: PPUSH
55312: CALL_OW 321
55316: PUSH
55317: LD_INT 2
55319: EQUAL
55320: IFFALSE 55337
// bpoints := bpoints * 1.1 ;
55322: LD_ADDR_VAR 0 10
55326: PUSH
55327: LD_VAR 0 10
55331: PUSH
55332: LD_REAL  1.10000000000000E+0000
55335: MUL
55336: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55337: LD_ADDR_VAR 0 10
55341: PUSH
55342: LD_VAR 0 10
55346: PUSH
55347: LD_VAR 0 6
55351: PPUSH
55352: LD_INT 1
55354: PPUSH
55355: CALL_OW 259
55359: PUSH
55360: LD_REAL  1.15000000000000E+0000
55363: MUL
55364: MUL
55365: ST_TO_ADDR
// end ; unit_vehicle :
55366: GO 56190
55368: LD_INT 2
55370: DOUBLE
55371: EQUAL
55372: IFTRUE 55376
55374: GO 56178
55376: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55377: LD_VAR 0 6
55381: PPUSH
55382: CALL_OW 264
55386: PUSH
55387: LD_INT 2
55389: PUSH
55390: LD_INT 42
55392: PUSH
55393: LD_INT 24
55395: PUSH
55396: EMPTY
55397: LIST
55398: LIST
55399: LIST
55400: IN
55401: IFFALSE 55422
// points := [ 25 , 5 , 3 ] ;
55403: LD_ADDR_VAR 0 9
55407: PUSH
55408: LD_INT 25
55410: PUSH
55411: LD_INT 5
55413: PUSH
55414: LD_INT 3
55416: PUSH
55417: EMPTY
55418: LIST
55419: LIST
55420: LIST
55421: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55422: LD_VAR 0 6
55426: PPUSH
55427: CALL_OW 264
55431: PUSH
55432: LD_INT 4
55434: PUSH
55435: LD_INT 43
55437: PUSH
55438: LD_INT 25
55440: PUSH
55441: EMPTY
55442: LIST
55443: LIST
55444: LIST
55445: IN
55446: IFFALSE 55467
// points := [ 40 , 15 , 5 ] ;
55448: LD_ADDR_VAR 0 9
55452: PUSH
55453: LD_INT 40
55455: PUSH
55456: LD_INT 15
55458: PUSH
55459: LD_INT 5
55461: PUSH
55462: EMPTY
55463: LIST
55464: LIST
55465: LIST
55466: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55467: LD_VAR 0 6
55471: PPUSH
55472: CALL_OW 264
55476: PUSH
55477: LD_INT 3
55479: PUSH
55480: LD_INT 23
55482: PUSH
55483: EMPTY
55484: LIST
55485: LIST
55486: IN
55487: IFFALSE 55508
// points := [ 7 , 25 , 8 ] ;
55489: LD_ADDR_VAR 0 9
55493: PUSH
55494: LD_INT 7
55496: PUSH
55497: LD_INT 25
55499: PUSH
55500: LD_INT 8
55502: PUSH
55503: EMPTY
55504: LIST
55505: LIST
55506: LIST
55507: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55508: LD_VAR 0 6
55512: PPUSH
55513: CALL_OW 264
55517: PUSH
55518: LD_INT 5
55520: PUSH
55521: LD_INT 27
55523: PUSH
55524: LD_INT 44
55526: PUSH
55527: EMPTY
55528: LIST
55529: LIST
55530: LIST
55531: IN
55532: IFFALSE 55553
// points := [ 14 , 50 , 16 ] ;
55534: LD_ADDR_VAR 0 9
55538: PUSH
55539: LD_INT 14
55541: PUSH
55542: LD_INT 50
55544: PUSH
55545: LD_INT 16
55547: PUSH
55548: EMPTY
55549: LIST
55550: LIST
55551: LIST
55552: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55553: LD_VAR 0 6
55557: PPUSH
55558: CALL_OW 264
55562: PUSH
55563: LD_INT 6
55565: PUSH
55566: LD_INT 46
55568: PUSH
55569: EMPTY
55570: LIST
55571: LIST
55572: IN
55573: IFFALSE 55594
// points := [ 32 , 120 , 70 ] ;
55575: LD_ADDR_VAR 0 9
55579: PUSH
55580: LD_INT 32
55582: PUSH
55583: LD_INT 120
55585: PUSH
55586: LD_INT 70
55588: PUSH
55589: EMPTY
55590: LIST
55591: LIST
55592: LIST
55593: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
55594: LD_VAR 0 6
55598: PPUSH
55599: CALL_OW 264
55603: PUSH
55604: LD_INT 7
55606: PUSH
55607: LD_INT 28
55609: PUSH
55610: LD_INT 45
55612: PUSH
55613: EMPTY
55614: LIST
55615: LIST
55616: LIST
55617: IN
55618: IFFALSE 55639
// points := [ 35 , 20 , 45 ] ;
55620: LD_ADDR_VAR 0 9
55624: PUSH
55625: LD_INT 35
55627: PUSH
55628: LD_INT 20
55630: PUSH
55631: LD_INT 45
55633: PUSH
55634: EMPTY
55635: LIST
55636: LIST
55637: LIST
55638: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55639: LD_VAR 0 6
55643: PPUSH
55644: CALL_OW 264
55648: PUSH
55649: LD_INT 47
55651: PUSH
55652: EMPTY
55653: LIST
55654: IN
55655: IFFALSE 55676
// points := [ 67 , 45 , 75 ] ;
55657: LD_ADDR_VAR 0 9
55661: PUSH
55662: LD_INT 67
55664: PUSH
55665: LD_INT 45
55667: PUSH
55668: LD_INT 75
55670: PUSH
55671: EMPTY
55672: LIST
55673: LIST
55674: LIST
55675: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55676: LD_VAR 0 6
55680: PPUSH
55681: CALL_OW 264
55685: PUSH
55686: LD_INT 26
55688: PUSH
55689: EMPTY
55690: LIST
55691: IN
55692: IFFALSE 55713
// points := [ 120 , 30 , 80 ] ;
55694: LD_ADDR_VAR 0 9
55698: PUSH
55699: LD_INT 120
55701: PUSH
55702: LD_INT 30
55704: PUSH
55705: LD_INT 80
55707: PUSH
55708: EMPTY
55709: LIST
55710: LIST
55711: LIST
55712: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55713: LD_VAR 0 6
55717: PPUSH
55718: CALL_OW 264
55722: PUSH
55723: LD_INT 22
55725: PUSH
55726: EMPTY
55727: LIST
55728: IN
55729: IFFALSE 55750
// points := [ 40 , 1 , 1 ] ;
55731: LD_ADDR_VAR 0 9
55735: PUSH
55736: LD_INT 40
55738: PUSH
55739: LD_INT 1
55741: PUSH
55742: LD_INT 1
55744: PUSH
55745: EMPTY
55746: LIST
55747: LIST
55748: LIST
55749: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55750: LD_VAR 0 6
55754: PPUSH
55755: CALL_OW 264
55759: PUSH
55760: LD_INT 29
55762: PUSH
55763: EMPTY
55764: LIST
55765: IN
55766: IFFALSE 55787
// points := [ 70 , 200 , 400 ] ;
55768: LD_ADDR_VAR 0 9
55772: PUSH
55773: LD_INT 70
55775: PUSH
55776: LD_INT 200
55778: PUSH
55779: LD_INT 400
55781: PUSH
55782: EMPTY
55783: LIST
55784: LIST
55785: LIST
55786: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55787: LD_VAR 0 6
55791: PPUSH
55792: CALL_OW 264
55796: PUSH
55797: LD_INT 14
55799: PUSH
55800: LD_INT 53
55802: PUSH
55803: EMPTY
55804: LIST
55805: LIST
55806: IN
55807: IFFALSE 55828
// points := [ 40 , 10 , 20 ] ;
55809: LD_ADDR_VAR 0 9
55813: PUSH
55814: LD_INT 40
55816: PUSH
55817: LD_INT 10
55819: PUSH
55820: LD_INT 20
55822: PUSH
55823: EMPTY
55824: LIST
55825: LIST
55826: LIST
55827: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55828: LD_VAR 0 6
55832: PPUSH
55833: CALL_OW 264
55837: PUSH
55838: LD_INT 9
55840: PUSH
55841: EMPTY
55842: LIST
55843: IN
55844: IFFALSE 55865
// points := [ 5 , 70 , 20 ] ;
55846: LD_ADDR_VAR 0 9
55850: PUSH
55851: LD_INT 5
55853: PUSH
55854: LD_INT 70
55856: PUSH
55857: LD_INT 20
55859: PUSH
55860: EMPTY
55861: LIST
55862: LIST
55863: LIST
55864: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55865: LD_VAR 0 6
55869: PPUSH
55870: CALL_OW 264
55874: PUSH
55875: LD_INT 10
55877: PUSH
55878: EMPTY
55879: LIST
55880: IN
55881: IFFALSE 55902
// points := [ 35 , 110 , 70 ] ;
55883: LD_ADDR_VAR 0 9
55887: PUSH
55888: LD_INT 35
55890: PUSH
55891: LD_INT 110
55893: PUSH
55894: LD_INT 70
55896: PUSH
55897: EMPTY
55898: LIST
55899: LIST
55900: LIST
55901: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55902: LD_VAR 0 6
55906: PPUSH
55907: CALL_OW 265
55911: PUSH
55912: LD_INT 25
55914: EQUAL
55915: IFFALSE 55936
// points := [ 80 , 65 , 100 ] ;
55917: LD_ADDR_VAR 0 9
55921: PUSH
55922: LD_INT 80
55924: PUSH
55925: LD_INT 65
55927: PUSH
55928: LD_INT 100
55930: PUSH
55931: EMPTY
55932: LIST
55933: LIST
55934: LIST
55935: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55936: LD_VAR 0 6
55940: PPUSH
55941: CALL_OW 263
55945: PUSH
55946: LD_INT 1
55948: EQUAL
55949: IFFALSE 55984
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55951: LD_ADDR_VAR 0 10
55955: PUSH
55956: LD_VAR 0 10
55960: PUSH
55961: LD_VAR 0 6
55965: PPUSH
55966: CALL_OW 311
55970: PPUSH
55971: LD_INT 3
55973: PPUSH
55974: CALL_OW 259
55978: PUSH
55979: LD_INT 4
55981: MUL
55982: MUL
55983: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
55984: LD_VAR 0 6
55988: PPUSH
55989: CALL_OW 263
55993: PUSH
55994: LD_INT 2
55996: EQUAL
55997: IFFALSE 56048
// begin j := IsControledBy ( i ) ;
55999: LD_ADDR_VAR 0 7
56003: PUSH
56004: LD_VAR 0 6
56008: PPUSH
56009: CALL_OW 312
56013: ST_TO_ADDR
// if j then
56014: LD_VAR 0 7
56018: IFFALSE 56048
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56020: LD_ADDR_VAR 0 10
56024: PUSH
56025: LD_VAR 0 10
56029: PUSH
56030: LD_VAR 0 7
56034: PPUSH
56035: LD_INT 3
56037: PPUSH
56038: CALL_OW 259
56042: PUSH
56043: LD_INT 3
56045: MUL
56046: MUL
56047: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56048: LD_VAR 0 6
56052: PPUSH
56053: CALL_OW 264
56057: PUSH
56058: LD_INT 5
56060: PUSH
56061: LD_INT 6
56063: PUSH
56064: LD_INT 46
56066: PUSH
56067: LD_INT 44
56069: PUSH
56070: LD_INT 47
56072: PUSH
56073: LD_INT 45
56075: PUSH
56076: LD_INT 28
56078: PUSH
56079: LD_INT 7
56081: PUSH
56082: LD_INT 27
56084: PUSH
56085: LD_INT 29
56087: PUSH
56088: EMPTY
56089: LIST
56090: LIST
56091: LIST
56092: LIST
56093: LIST
56094: LIST
56095: LIST
56096: LIST
56097: LIST
56098: LIST
56099: IN
56100: PUSH
56101: LD_VAR 0 1
56105: PPUSH
56106: LD_INT 52
56108: PPUSH
56109: CALL_OW 321
56113: PUSH
56114: LD_INT 2
56116: EQUAL
56117: AND
56118: IFFALSE 56135
// bpoints := bpoints * 1.2 ;
56120: LD_ADDR_VAR 0 10
56124: PUSH
56125: LD_VAR 0 10
56129: PUSH
56130: LD_REAL  1.20000000000000E+0000
56133: MUL
56134: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56135: LD_VAR 0 6
56139: PPUSH
56140: CALL_OW 264
56144: PUSH
56145: LD_INT 6
56147: PUSH
56148: LD_INT 46
56150: PUSH
56151: LD_INT 47
56153: PUSH
56154: EMPTY
56155: LIST
56156: LIST
56157: LIST
56158: IN
56159: IFFALSE 56176
// bpoints := bpoints * 1.2 ;
56161: LD_ADDR_VAR 0 10
56165: PUSH
56166: LD_VAR 0 10
56170: PUSH
56171: LD_REAL  1.20000000000000E+0000
56174: MUL
56175: ST_TO_ADDR
// end ; unit_building :
56176: GO 56190
56178: LD_INT 3
56180: DOUBLE
56181: EQUAL
56182: IFTRUE 56186
56184: GO 56189
56186: POP
// ; end ;
56187: GO 56190
56189: POP
// for j = 1 to 3 do
56190: LD_ADDR_VAR 0 7
56194: PUSH
56195: DOUBLE
56196: LD_INT 1
56198: DEC
56199: ST_TO_ADDR
56200: LD_INT 3
56202: PUSH
56203: FOR_TO
56204: IFFALSE 56257
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56206: LD_ADDR_VAR 0 5
56210: PUSH
56211: LD_VAR 0 5
56215: PPUSH
56216: LD_VAR 0 7
56220: PPUSH
56221: LD_VAR 0 5
56225: PUSH
56226: LD_VAR 0 7
56230: ARRAY
56231: PUSH
56232: LD_VAR 0 9
56236: PUSH
56237: LD_VAR 0 7
56241: ARRAY
56242: PUSH
56243: LD_VAR 0 10
56247: MUL
56248: PLUS
56249: PPUSH
56250: CALL_OW 1
56254: ST_TO_ADDR
56255: GO 56203
56257: POP
56258: POP
// end ;
56259: GO 54742
56261: POP
56262: POP
// result := Replace ( result , 4 , tmp ) ;
56263: LD_ADDR_VAR 0 5
56267: PUSH
56268: LD_VAR 0 5
56272: PPUSH
56273: LD_INT 4
56275: PPUSH
56276: LD_VAR 0 8
56280: PPUSH
56281: CALL_OW 1
56285: ST_TO_ADDR
// end ;
56286: LD_VAR 0 5
56290: RET
// export function DangerAtRange ( unit , range ) ; begin
56291: LD_INT 0
56293: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56294: LD_ADDR_VAR 0 3
56298: PUSH
56299: LD_VAR 0 1
56303: PPUSH
56304: CALL_OW 255
56308: PPUSH
56309: LD_VAR 0 1
56313: PPUSH
56314: CALL_OW 250
56318: PPUSH
56319: LD_VAR 0 1
56323: PPUSH
56324: CALL_OW 251
56328: PPUSH
56329: LD_VAR 0 2
56333: PPUSH
56334: CALL 54594 0 4
56338: ST_TO_ADDR
// end ;
56339: LD_VAR 0 3
56343: RET
// export function DangerInArea ( side , area ) ; begin
56344: LD_INT 0
56346: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56347: LD_ADDR_VAR 0 3
56351: PUSH
56352: LD_VAR 0 2
56356: PPUSH
56357: LD_INT 81
56359: PUSH
56360: LD_VAR 0 1
56364: PUSH
56365: EMPTY
56366: LIST
56367: LIST
56368: PPUSH
56369: CALL_OW 70
56373: ST_TO_ADDR
// end ;
56374: LD_VAR 0 3
56378: RET
// export function IsExtension ( b ) ; begin
56379: LD_INT 0
56381: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56382: LD_ADDR_VAR 0 2
56386: PUSH
56387: LD_VAR 0 1
56391: PUSH
56392: LD_INT 23
56394: PUSH
56395: LD_INT 20
56397: PUSH
56398: LD_INT 22
56400: PUSH
56401: LD_INT 17
56403: PUSH
56404: LD_INT 24
56406: PUSH
56407: LD_INT 21
56409: PUSH
56410: LD_INT 19
56412: PUSH
56413: LD_INT 16
56415: PUSH
56416: LD_INT 25
56418: PUSH
56419: LD_INT 18
56421: PUSH
56422: EMPTY
56423: LIST
56424: LIST
56425: LIST
56426: LIST
56427: LIST
56428: LIST
56429: LIST
56430: LIST
56431: LIST
56432: LIST
56433: IN
56434: ST_TO_ADDR
// end ;
56435: LD_VAR 0 2
56439: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
56440: LD_INT 0
56442: PPUSH
56443: PPUSH
56444: PPUSH
// result := [ ] ;
56445: LD_ADDR_VAR 0 3
56449: PUSH
56450: EMPTY
56451: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56452: LD_ADDR_VAR 0 4
56456: PUSH
56457: LD_VAR 0 2
56461: PPUSH
56462: LD_INT 21
56464: PUSH
56465: LD_INT 3
56467: PUSH
56468: EMPTY
56469: LIST
56470: LIST
56471: PPUSH
56472: CALL_OW 70
56476: ST_TO_ADDR
// if not tmp then
56477: LD_VAR 0 4
56481: NOT
56482: IFFALSE 56486
// exit ;
56484: GO 56544
// for i in tmp do
56486: LD_ADDR_VAR 0 5
56490: PUSH
56491: LD_VAR 0 4
56495: PUSH
56496: FOR_IN
56497: IFFALSE 56532
// if GetBase ( i ) <> base then
56499: LD_VAR 0 5
56503: PPUSH
56504: CALL_OW 274
56508: PUSH
56509: LD_VAR 0 1
56513: NONEQUAL
56514: IFFALSE 56530
// ComLinkToBase ( base , i ) ;
56516: LD_VAR 0 1
56520: PPUSH
56521: LD_VAR 0 5
56525: PPUSH
56526: CALL_OW 169
56530: GO 56496
56532: POP
56533: POP
// result := tmp ;
56534: LD_ADDR_VAR 0 3
56538: PUSH
56539: LD_VAR 0 4
56543: ST_TO_ADDR
// end ;
56544: LD_VAR 0 3
56548: RET
// export function ComComplete ( unit , b ) ; var i ; begin
56549: LD_INT 0
56551: PPUSH
56552: PPUSH
// if BuildingStatus ( b ) = bs_build then
56553: LD_VAR 0 2
56557: PPUSH
56558: CALL_OW 461
56562: PUSH
56563: LD_INT 1
56565: EQUAL
56566: IFFALSE 56626
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56568: LD_VAR 0 1
56572: PPUSH
56573: LD_STRING h
56575: PUSH
56576: LD_VAR 0 2
56580: PPUSH
56581: CALL_OW 250
56585: PUSH
56586: LD_VAR 0 2
56590: PPUSH
56591: CALL_OW 251
56595: PUSH
56596: LD_VAR 0 2
56600: PUSH
56601: LD_INT 0
56603: PUSH
56604: LD_INT 0
56606: PUSH
56607: LD_INT 0
56609: PUSH
56610: EMPTY
56611: LIST
56612: LIST
56613: LIST
56614: LIST
56615: LIST
56616: LIST
56617: LIST
56618: PUSH
56619: EMPTY
56620: LIST
56621: PPUSH
56622: CALL_OW 446
// end ;
56626: LD_VAR 0 3
56630: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56631: LD_INT 0
56633: PPUSH
56634: PPUSH
56635: PPUSH
56636: PPUSH
56637: PPUSH
56638: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
56639: LD_VAR 0 1
56643: NOT
56644: PUSH
56645: LD_VAR 0 1
56649: PPUSH
56650: CALL_OW 263
56654: PUSH
56655: LD_INT 2
56657: EQUAL
56658: NOT
56659: OR
56660: IFFALSE 56664
// exit ;
56662: GO 56980
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56664: LD_ADDR_VAR 0 6
56668: PUSH
56669: LD_INT 22
56671: PUSH
56672: LD_VAR 0 1
56676: PPUSH
56677: CALL_OW 255
56681: PUSH
56682: EMPTY
56683: LIST
56684: LIST
56685: PUSH
56686: LD_INT 2
56688: PUSH
56689: LD_INT 30
56691: PUSH
56692: LD_INT 36
56694: PUSH
56695: EMPTY
56696: LIST
56697: LIST
56698: PUSH
56699: LD_INT 34
56701: PUSH
56702: LD_INT 31
56704: PUSH
56705: EMPTY
56706: LIST
56707: LIST
56708: PUSH
56709: EMPTY
56710: LIST
56711: LIST
56712: LIST
56713: PUSH
56714: EMPTY
56715: LIST
56716: LIST
56717: PPUSH
56718: CALL_OW 69
56722: ST_TO_ADDR
// if not tmp then
56723: LD_VAR 0 6
56727: NOT
56728: IFFALSE 56732
// exit ;
56730: GO 56980
// result := [ ] ;
56732: LD_ADDR_VAR 0 2
56736: PUSH
56737: EMPTY
56738: ST_TO_ADDR
// for i in tmp do
56739: LD_ADDR_VAR 0 3
56743: PUSH
56744: LD_VAR 0 6
56748: PUSH
56749: FOR_IN
56750: IFFALSE 56821
// begin t := UnitsInside ( i ) ;
56752: LD_ADDR_VAR 0 4
56756: PUSH
56757: LD_VAR 0 3
56761: PPUSH
56762: CALL_OW 313
56766: ST_TO_ADDR
// if t then
56767: LD_VAR 0 4
56771: IFFALSE 56819
// for j in t do
56773: LD_ADDR_VAR 0 7
56777: PUSH
56778: LD_VAR 0 4
56782: PUSH
56783: FOR_IN
56784: IFFALSE 56817
// result := Insert ( result , result + 1 , j ) ;
56786: LD_ADDR_VAR 0 2
56790: PUSH
56791: LD_VAR 0 2
56795: PPUSH
56796: LD_VAR 0 2
56800: PUSH
56801: LD_INT 1
56803: PLUS
56804: PPUSH
56805: LD_VAR 0 7
56809: PPUSH
56810: CALL_OW 2
56814: ST_TO_ADDR
56815: GO 56783
56817: POP
56818: POP
// end ;
56819: GO 56749
56821: POP
56822: POP
// if not result then
56823: LD_VAR 0 2
56827: NOT
56828: IFFALSE 56832
// exit ;
56830: GO 56980
// mech := result [ 1 ] ;
56832: LD_ADDR_VAR 0 5
56836: PUSH
56837: LD_VAR 0 2
56841: PUSH
56842: LD_INT 1
56844: ARRAY
56845: ST_TO_ADDR
// if result > 1 then
56846: LD_VAR 0 2
56850: PUSH
56851: LD_INT 1
56853: GREATER
56854: IFFALSE 56966
// for i = 2 to result do
56856: LD_ADDR_VAR 0 3
56860: PUSH
56861: DOUBLE
56862: LD_INT 2
56864: DEC
56865: ST_TO_ADDR
56866: LD_VAR 0 2
56870: PUSH
56871: FOR_TO
56872: IFFALSE 56964
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56874: LD_ADDR_VAR 0 4
56878: PUSH
56879: LD_VAR 0 2
56883: PUSH
56884: LD_VAR 0 3
56888: ARRAY
56889: PPUSH
56890: LD_INT 3
56892: PPUSH
56893: CALL_OW 259
56897: PUSH
56898: LD_VAR 0 2
56902: PUSH
56903: LD_VAR 0 3
56907: ARRAY
56908: PPUSH
56909: CALL_OW 432
56913: MINUS
56914: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56915: LD_VAR 0 4
56919: PUSH
56920: LD_VAR 0 5
56924: PPUSH
56925: LD_INT 3
56927: PPUSH
56928: CALL_OW 259
56932: PUSH
56933: LD_VAR 0 5
56937: PPUSH
56938: CALL_OW 432
56942: MINUS
56943: GREATEREQUAL
56944: IFFALSE 56962
// mech := result [ i ] ;
56946: LD_ADDR_VAR 0 5
56950: PUSH
56951: LD_VAR 0 2
56955: PUSH
56956: LD_VAR 0 3
56960: ARRAY
56961: ST_TO_ADDR
// end ;
56962: GO 56871
56964: POP
56965: POP
// ComLinkTo ( vehicle , mech ) ;
56966: LD_VAR 0 1
56970: PPUSH
56971: LD_VAR 0 5
56975: PPUSH
56976: CALL_OW 135
// end ;
56980: LD_VAR 0 2
56984: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
56985: LD_INT 0
56987: PPUSH
56988: PPUSH
56989: PPUSH
56990: PPUSH
56991: PPUSH
56992: PPUSH
56993: PPUSH
56994: PPUSH
56995: PPUSH
56996: PPUSH
56997: PPUSH
56998: PPUSH
56999: PPUSH
// result := [ ] ;
57000: LD_ADDR_VAR 0 7
57004: PUSH
57005: EMPTY
57006: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57007: LD_VAR 0 1
57011: PPUSH
57012: CALL_OW 266
57016: PUSH
57017: LD_INT 0
57019: PUSH
57020: LD_INT 1
57022: PUSH
57023: EMPTY
57024: LIST
57025: LIST
57026: IN
57027: NOT
57028: IFFALSE 57032
// exit ;
57030: GO 58663
// if name then
57032: LD_VAR 0 3
57036: IFFALSE 57052
// SetBName ( base_dep , name ) ;
57038: LD_VAR 0 1
57042: PPUSH
57043: LD_VAR 0 3
57047: PPUSH
57048: CALL_OW 500
// base := GetBase ( base_dep ) ;
57052: LD_ADDR_VAR 0 15
57056: PUSH
57057: LD_VAR 0 1
57061: PPUSH
57062: CALL_OW 274
57066: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57067: LD_ADDR_VAR 0 16
57071: PUSH
57072: LD_VAR 0 1
57076: PPUSH
57077: CALL_OW 255
57081: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57082: LD_ADDR_VAR 0 17
57086: PUSH
57087: LD_VAR 0 1
57091: PPUSH
57092: CALL_OW 248
57096: ST_TO_ADDR
// if sources then
57097: LD_VAR 0 5
57101: IFFALSE 57148
// for i = 1 to 3 do
57103: LD_ADDR_VAR 0 8
57107: PUSH
57108: DOUBLE
57109: LD_INT 1
57111: DEC
57112: ST_TO_ADDR
57113: LD_INT 3
57115: PUSH
57116: FOR_TO
57117: IFFALSE 57146
// AddResourceType ( base , i , sources [ i ] ) ;
57119: LD_VAR 0 15
57123: PPUSH
57124: LD_VAR 0 8
57128: PPUSH
57129: LD_VAR 0 5
57133: PUSH
57134: LD_VAR 0 8
57138: ARRAY
57139: PPUSH
57140: CALL_OW 276
57144: GO 57116
57146: POP
57147: POP
// buildings := GetBaseBuildings ( base , area ) ;
57148: LD_ADDR_VAR 0 18
57152: PUSH
57153: LD_VAR 0 15
57157: PPUSH
57158: LD_VAR 0 2
57162: PPUSH
57163: CALL 56440 0 2
57167: ST_TO_ADDR
// InitHc ;
57168: CALL_OW 19
// InitUc ;
57172: CALL_OW 18
// uc_side := side ;
57176: LD_ADDR_OWVAR 20
57180: PUSH
57181: LD_VAR 0 16
57185: ST_TO_ADDR
// uc_nation := nation ;
57186: LD_ADDR_OWVAR 21
57190: PUSH
57191: LD_VAR 0 17
57195: ST_TO_ADDR
// if buildings then
57196: LD_VAR 0 18
57200: IFFALSE 58522
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57202: LD_ADDR_VAR 0 19
57206: PUSH
57207: LD_VAR 0 18
57211: PPUSH
57212: LD_INT 2
57214: PUSH
57215: LD_INT 30
57217: PUSH
57218: LD_INT 29
57220: PUSH
57221: EMPTY
57222: LIST
57223: LIST
57224: PUSH
57225: LD_INT 30
57227: PUSH
57228: LD_INT 30
57230: PUSH
57231: EMPTY
57232: LIST
57233: LIST
57234: PUSH
57235: EMPTY
57236: LIST
57237: LIST
57238: LIST
57239: PPUSH
57240: CALL_OW 72
57244: ST_TO_ADDR
// if tmp then
57245: LD_VAR 0 19
57249: IFFALSE 57297
// for i in tmp do
57251: LD_ADDR_VAR 0 8
57255: PUSH
57256: LD_VAR 0 19
57260: PUSH
57261: FOR_IN
57262: IFFALSE 57295
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57264: LD_VAR 0 8
57268: PPUSH
57269: CALL_OW 250
57273: PPUSH
57274: LD_VAR 0 8
57278: PPUSH
57279: CALL_OW 251
57283: PPUSH
57284: LD_VAR 0 16
57288: PPUSH
57289: CALL_OW 441
57293: GO 57261
57295: POP
57296: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57297: LD_VAR 0 18
57301: PPUSH
57302: LD_INT 2
57304: PUSH
57305: LD_INT 30
57307: PUSH
57308: LD_INT 32
57310: PUSH
57311: EMPTY
57312: LIST
57313: LIST
57314: PUSH
57315: LD_INT 30
57317: PUSH
57318: LD_INT 33
57320: PUSH
57321: EMPTY
57322: LIST
57323: LIST
57324: PUSH
57325: EMPTY
57326: LIST
57327: LIST
57328: LIST
57329: PPUSH
57330: CALL_OW 72
57334: IFFALSE 57422
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57336: LD_ADDR_VAR 0 8
57340: PUSH
57341: LD_VAR 0 18
57345: PPUSH
57346: LD_INT 2
57348: PUSH
57349: LD_INT 30
57351: PUSH
57352: LD_INT 32
57354: PUSH
57355: EMPTY
57356: LIST
57357: LIST
57358: PUSH
57359: LD_INT 30
57361: PUSH
57362: LD_INT 33
57364: PUSH
57365: EMPTY
57366: LIST
57367: LIST
57368: PUSH
57369: EMPTY
57370: LIST
57371: LIST
57372: LIST
57373: PPUSH
57374: CALL_OW 72
57378: PUSH
57379: FOR_IN
57380: IFFALSE 57420
// begin if not GetBWeapon ( i ) then
57382: LD_VAR 0 8
57386: PPUSH
57387: CALL_OW 269
57391: NOT
57392: IFFALSE 57418
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57394: LD_VAR 0 8
57398: PPUSH
57399: LD_VAR 0 8
57403: PPUSH
57404: LD_VAR 0 2
57408: PPUSH
57409: CALL 58668 0 2
57413: PPUSH
57414: CALL_OW 431
// end ;
57418: GO 57379
57420: POP
57421: POP
// end ; for i = 1 to personel do
57422: LD_ADDR_VAR 0 8
57426: PUSH
57427: DOUBLE
57428: LD_INT 1
57430: DEC
57431: ST_TO_ADDR
57432: LD_VAR 0 6
57436: PUSH
57437: FOR_TO
57438: IFFALSE 58502
// begin if i > 4 then
57440: LD_VAR 0 8
57444: PUSH
57445: LD_INT 4
57447: GREATER
57448: IFFALSE 57452
// break ;
57450: GO 58502
// case i of 1 :
57452: LD_VAR 0 8
57456: PUSH
57457: LD_INT 1
57459: DOUBLE
57460: EQUAL
57461: IFTRUE 57465
57463: GO 57545
57465: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57466: LD_ADDR_VAR 0 12
57470: PUSH
57471: LD_VAR 0 18
57475: PPUSH
57476: LD_INT 22
57478: PUSH
57479: LD_VAR 0 16
57483: PUSH
57484: EMPTY
57485: LIST
57486: LIST
57487: PUSH
57488: LD_INT 58
57490: PUSH
57491: EMPTY
57492: LIST
57493: PUSH
57494: LD_INT 2
57496: PUSH
57497: LD_INT 30
57499: PUSH
57500: LD_INT 32
57502: PUSH
57503: EMPTY
57504: LIST
57505: LIST
57506: PUSH
57507: LD_INT 30
57509: PUSH
57510: LD_INT 4
57512: PUSH
57513: EMPTY
57514: LIST
57515: LIST
57516: PUSH
57517: LD_INT 30
57519: PUSH
57520: LD_INT 5
57522: PUSH
57523: EMPTY
57524: LIST
57525: LIST
57526: PUSH
57527: EMPTY
57528: LIST
57529: LIST
57530: LIST
57531: LIST
57532: PUSH
57533: EMPTY
57534: LIST
57535: LIST
57536: LIST
57537: PPUSH
57538: CALL_OW 72
57542: ST_TO_ADDR
57543: GO 57767
57545: LD_INT 2
57547: DOUBLE
57548: EQUAL
57549: IFTRUE 57553
57551: GO 57615
57553: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57554: LD_ADDR_VAR 0 12
57558: PUSH
57559: LD_VAR 0 18
57563: PPUSH
57564: LD_INT 22
57566: PUSH
57567: LD_VAR 0 16
57571: PUSH
57572: EMPTY
57573: LIST
57574: LIST
57575: PUSH
57576: LD_INT 2
57578: PUSH
57579: LD_INT 30
57581: PUSH
57582: LD_INT 0
57584: PUSH
57585: EMPTY
57586: LIST
57587: LIST
57588: PUSH
57589: LD_INT 30
57591: PUSH
57592: LD_INT 1
57594: PUSH
57595: EMPTY
57596: LIST
57597: LIST
57598: PUSH
57599: EMPTY
57600: LIST
57601: LIST
57602: LIST
57603: PUSH
57604: EMPTY
57605: LIST
57606: LIST
57607: PPUSH
57608: CALL_OW 72
57612: ST_TO_ADDR
57613: GO 57767
57615: LD_INT 3
57617: DOUBLE
57618: EQUAL
57619: IFTRUE 57623
57621: GO 57685
57623: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57624: LD_ADDR_VAR 0 12
57628: PUSH
57629: LD_VAR 0 18
57633: PPUSH
57634: LD_INT 22
57636: PUSH
57637: LD_VAR 0 16
57641: PUSH
57642: EMPTY
57643: LIST
57644: LIST
57645: PUSH
57646: LD_INT 2
57648: PUSH
57649: LD_INT 30
57651: PUSH
57652: LD_INT 2
57654: PUSH
57655: EMPTY
57656: LIST
57657: LIST
57658: PUSH
57659: LD_INT 30
57661: PUSH
57662: LD_INT 3
57664: PUSH
57665: EMPTY
57666: LIST
57667: LIST
57668: PUSH
57669: EMPTY
57670: LIST
57671: LIST
57672: LIST
57673: PUSH
57674: EMPTY
57675: LIST
57676: LIST
57677: PPUSH
57678: CALL_OW 72
57682: ST_TO_ADDR
57683: GO 57767
57685: LD_INT 4
57687: DOUBLE
57688: EQUAL
57689: IFTRUE 57693
57691: GO 57766
57693: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57694: LD_ADDR_VAR 0 12
57698: PUSH
57699: LD_VAR 0 18
57703: PPUSH
57704: LD_INT 22
57706: PUSH
57707: LD_VAR 0 16
57711: PUSH
57712: EMPTY
57713: LIST
57714: LIST
57715: PUSH
57716: LD_INT 2
57718: PUSH
57719: LD_INT 30
57721: PUSH
57722: LD_INT 6
57724: PUSH
57725: EMPTY
57726: LIST
57727: LIST
57728: PUSH
57729: LD_INT 30
57731: PUSH
57732: LD_INT 7
57734: PUSH
57735: EMPTY
57736: LIST
57737: LIST
57738: PUSH
57739: LD_INT 30
57741: PUSH
57742: LD_INT 8
57744: PUSH
57745: EMPTY
57746: LIST
57747: LIST
57748: PUSH
57749: EMPTY
57750: LIST
57751: LIST
57752: LIST
57753: LIST
57754: PUSH
57755: EMPTY
57756: LIST
57757: LIST
57758: PPUSH
57759: CALL_OW 72
57763: ST_TO_ADDR
57764: GO 57767
57766: POP
// if i = 1 then
57767: LD_VAR 0 8
57771: PUSH
57772: LD_INT 1
57774: EQUAL
57775: IFFALSE 57886
// begin tmp := [ ] ;
57777: LD_ADDR_VAR 0 19
57781: PUSH
57782: EMPTY
57783: ST_TO_ADDR
// for j in f do
57784: LD_ADDR_VAR 0 9
57788: PUSH
57789: LD_VAR 0 12
57793: PUSH
57794: FOR_IN
57795: IFFALSE 57868
// if GetBType ( j ) = b_bunker then
57797: LD_VAR 0 9
57801: PPUSH
57802: CALL_OW 266
57806: PUSH
57807: LD_INT 32
57809: EQUAL
57810: IFFALSE 57837
// tmp := Insert ( tmp , 1 , j ) else
57812: LD_ADDR_VAR 0 19
57816: PUSH
57817: LD_VAR 0 19
57821: PPUSH
57822: LD_INT 1
57824: PPUSH
57825: LD_VAR 0 9
57829: PPUSH
57830: CALL_OW 2
57834: ST_TO_ADDR
57835: GO 57866
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57837: LD_ADDR_VAR 0 19
57841: PUSH
57842: LD_VAR 0 19
57846: PPUSH
57847: LD_VAR 0 19
57851: PUSH
57852: LD_INT 1
57854: PLUS
57855: PPUSH
57856: LD_VAR 0 9
57860: PPUSH
57861: CALL_OW 2
57865: ST_TO_ADDR
57866: GO 57794
57868: POP
57869: POP
// if tmp then
57870: LD_VAR 0 19
57874: IFFALSE 57886
// f := tmp ;
57876: LD_ADDR_VAR 0 12
57880: PUSH
57881: LD_VAR 0 19
57885: ST_TO_ADDR
// end ; x := personel [ i ] ;
57886: LD_ADDR_VAR 0 13
57890: PUSH
57891: LD_VAR 0 6
57895: PUSH
57896: LD_VAR 0 8
57900: ARRAY
57901: ST_TO_ADDR
// if x = - 1 then
57902: LD_VAR 0 13
57906: PUSH
57907: LD_INT 1
57909: NEG
57910: EQUAL
57911: IFFALSE 58120
// begin for j in f do
57913: LD_ADDR_VAR 0 9
57917: PUSH
57918: LD_VAR 0 12
57922: PUSH
57923: FOR_IN
57924: IFFALSE 58116
// repeat InitHc ;
57926: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57930: LD_VAR 0 9
57934: PPUSH
57935: CALL_OW 266
57939: PUSH
57940: LD_INT 5
57942: EQUAL
57943: IFFALSE 58013
// begin if UnitsInside ( j ) < 3 then
57945: LD_VAR 0 9
57949: PPUSH
57950: CALL_OW 313
57954: PUSH
57955: LD_INT 3
57957: LESS
57958: IFFALSE 57994
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57960: LD_INT 0
57962: PPUSH
57963: LD_INT 5
57965: PUSH
57966: LD_INT 8
57968: PUSH
57969: LD_INT 9
57971: PUSH
57972: EMPTY
57973: LIST
57974: LIST
57975: LIST
57976: PUSH
57977: LD_VAR 0 17
57981: ARRAY
57982: PPUSH
57983: LD_VAR 0 4
57987: PPUSH
57988: CALL_OW 380
57992: GO 58011
// PrepareHuman ( false , i , skill ) ;
57994: LD_INT 0
57996: PPUSH
57997: LD_VAR 0 8
58001: PPUSH
58002: LD_VAR 0 4
58006: PPUSH
58007: CALL_OW 380
// end else
58011: GO 58030
// PrepareHuman ( false , i , skill ) ;
58013: LD_INT 0
58015: PPUSH
58016: LD_VAR 0 8
58020: PPUSH
58021: LD_VAR 0 4
58025: PPUSH
58026: CALL_OW 380
// un := CreateHuman ;
58030: LD_ADDR_VAR 0 14
58034: PUSH
58035: CALL_OW 44
58039: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58040: LD_ADDR_VAR 0 7
58044: PUSH
58045: LD_VAR 0 7
58049: PPUSH
58050: LD_INT 1
58052: PPUSH
58053: LD_VAR 0 14
58057: PPUSH
58058: CALL_OW 2
58062: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58063: LD_VAR 0 14
58067: PPUSH
58068: LD_VAR 0 9
58072: PPUSH
58073: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58077: LD_VAR 0 9
58081: PPUSH
58082: CALL_OW 313
58086: PUSH
58087: LD_INT 6
58089: EQUAL
58090: PUSH
58091: LD_VAR 0 9
58095: PPUSH
58096: CALL_OW 266
58100: PUSH
58101: LD_INT 32
58103: PUSH
58104: LD_INT 31
58106: PUSH
58107: EMPTY
58108: LIST
58109: LIST
58110: IN
58111: OR
58112: IFFALSE 57926
58114: GO 57923
58116: POP
58117: POP
// end else
58118: GO 58500
// for j = 1 to x do
58120: LD_ADDR_VAR 0 9
58124: PUSH
58125: DOUBLE
58126: LD_INT 1
58128: DEC
58129: ST_TO_ADDR
58130: LD_VAR 0 13
58134: PUSH
58135: FOR_TO
58136: IFFALSE 58498
// begin InitHc ;
58138: CALL_OW 19
// if not f then
58142: LD_VAR 0 12
58146: NOT
58147: IFFALSE 58236
// begin PrepareHuman ( false , i , skill ) ;
58149: LD_INT 0
58151: PPUSH
58152: LD_VAR 0 8
58156: PPUSH
58157: LD_VAR 0 4
58161: PPUSH
58162: CALL_OW 380
// un := CreateHuman ;
58166: LD_ADDR_VAR 0 14
58170: PUSH
58171: CALL_OW 44
58175: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58176: LD_ADDR_VAR 0 7
58180: PUSH
58181: LD_VAR 0 7
58185: PPUSH
58186: LD_INT 1
58188: PPUSH
58189: LD_VAR 0 14
58193: PPUSH
58194: CALL_OW 2
58198: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58199: LD_VAR 0 14
58203: PPUSH
58204: LD_VAR 0 1
58208: PPUSH
58209: CALL_OW 250
58213: PPUSH
58214: LD_VAR 0 1
58218: PPUSH
58219: CALL_OW 251
58223: PPUSH
58224: LD_INT 10
58226: PPUSH
58227: LD_INT 0
58229: PPUSH
58230: CALL_OW 50
// continue ;
58234: GO 58135
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58236: LD_VAR 0 12
58240: PUSH
58241: LD_INT 1
58243: ARRAY
58244: PPUSH
58245: CALL_OW 313
58249: PUSH
58250: LD_VAR 0 12
58254: PUSH
58255: LD_INT 1
58257: ARRAY
58258: PPUSH
58259: CALL_OW 266
58263: PUSH
58264: LD_INT 32
58266: PUSH
58267: LD_INT 31
58269: PUSH
58270: EMPTY
58271: LIST
58272: LIST
58273: IN
58274: AND
58275: PUSH
58276: LD_VAR 0 12
58280: PUSH
58281: LD_INT 1
58283: ARRAY
58284: PPUSH
58285: CALL_OW 313
58289: PUSH
58290: LD_INT 6
58292: EQUAL
58293: OR
58294: IFFALSE 58314
// f := Delete ( f , 1 ) ;
58296: LD_ADDR_VAR 0 12
58300: PUSH
58301: LD_VAR 0 12
58305: PPUSH
58306: LD_INT 1
58308: PPUSH
58309: CALL_OW 3
58313: ST_TO_ADDR
// if not f then
58314: LD_VAR 0 12
58318: NOT
58319: IFFALSE 58337
// begin x := x + 2 ;
58321: LD_ADDR_VAR 0 13
58325: PUSH
58326: LD_VAR 0 13
58330: PUSH
58331: LD_INT 2
58333: PLUS
58334: ST_TO_ADDR
// continue ;
58335: GO 58135
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58337: LD_VAR 0 12
58341: PUSH
58342: LD_INT 1
58344: ARRAY
58345: PPUSH
58346: CALL_OW 266
58350: PUSH
58351: LD_INT 5
58353: EQUAL
58354: IFFALSE 58428
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58356: LD_VAR 0 12
58360: PUSH
58361: LD_INT 1
58363: ARRAY
58364: PPUSH
58365: CALL_OW 313
58369: PUSH
58370: LD_INT 3
58372: LESS
58373: IFFALSE 58409
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58375: LD_INT 0
58377: PPUSH
58378: LD_INT 5
58380: PUSH
58381: LD_INT 8
58383: PUSH
58384: LD_INT 9
58386: PUSH
58387: EMPTY
58388: LIST
58389: LIST
58390: LIST
58391: PUSH
58392: LD_VAR 0 17
58396: ARRAY
58397: PPUSH
58398: LD_VAR 0 4
58402: PPUSH
58403: CALL_OW 380
58407: GO 58426
// PrepareHuman ( false , i , skill ) ;
58409: LD_INT 0
58411: PPUSH
58412: LD_VAR 0 8
58416: PPUSH
58417: LD_VAR 0 4
58421: PPUSH
58422: CALL_OW 380
// end else
58426: GO 58445
// PrepareHuman ( false , i , skill ) ;
58428: LD_INT 0
58430: PPUSH
58431: LD_VAR 0 8
58435: PPUSH
58436: LD_VAR 0 4
58440: PPUSH
58441: CALL_OW 380
// un := CreateHuman ;
58445: LD_ADDR_VAR 0 14
58449: PUSH
58450: CALL_OW 44
58454: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58455: LD_ADDR_VAR 0 7
58459: PUSH
58460: LD_VAR 0 7
58464: PPUSH
58465: LD_INT 1
58467: PPUSH
58468: LD_VAR 0 14
58472: PPUSH
58473: CALL_OW 2
58477: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58478: LD_VAR 0 14
58482: PPUSH
58483: LD_VAR 0 12
58487: PUSH
58488: LD_INT 1
58490: ARRAY
58491: PPUSH
58492: CALL_OW 52
// end ;
58496: GO 58135
58498: POP
58499: POP
// end ;
58500: GO 57437
58502: POP
58503: POP
// result := result ^ buildings ;
58504: LD_ADDR_VAR 0 7
58508: PUSH
58509: LD_VAR 0 7
58513: PUSH
58514: LD_VAR 0 18
58518: ADD
58519: ST_TO_ADDR
// end else
58520: GO 58663
// begin for i = 1 to personel do
58522: LD_ADDR_VAR 0 8
58526: PUSH
58527: DOUBLE
58528: LD_INT 1
58530: DEC
58531: ST_TO_ADDR
58532: LD_VAR 0 6
58536: PUSH
58537: FOR_TO
58538: IFFALSE 58661
// begin if i > 4 then
58540: LD_VAR 0 8
58544: PUSH
58545: LD_INT 4
58547: GREATER
58548: IFFALSE 58552
// break ;
58550: GO 58661
// x := personel [ i ] ;
58552: LD_ADDR_VAR 0 13
58556: PUSH
58557: LD_VAR 0 6
58561: PUSH
58562: LD_VAR 0 8
58566: ARRAY
58567: ST_TO_ADDR
// if x = - 1 then
58568: LD_VAR 0 13
58572: PUSH
58573: LD_INT 1
58575: NEG
58576: EQUAL
58577: IFFALSE 58581
// continue ;
58579: GO 58537
// PrepareHuman ( false , i , skill ) ;
58581: LD_INT 0
58583: PPUSH
58584: LD_VAR 0 8
58588: PPUSH
58589: LD_VAR 0 4
58593: PPUSH
58594: CALL_OW 380
// un := CreateHuman ;
58598: LD_ADDR_VAR 0 14
58602: PUSH
58603: CALL_OW 44
58607: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58608: LD_VAR 0 14
58612: PPUSH
58613: LD_VAR 0 1
58617: PPUSH
58618: CALL_OW 250
58622: PPUSH
58623: LD_VAR 0 1
58627: PPUSH
58628: CALL_OW 251
58632: PPUSH
58633: LD_INT 10
58635: PPUSH
58636: LD_INT 0
58638: PPUSH
58639: CALL_OW 50
// result := result ^ un ;
58643: LD_ADDR_VAR 0 7
58647: PUSH
58648: LD_VAR 0 7
58652: PUSH
58653: LD_VAR 0 14
58657: ADD
58658: ST_TO_ADDR
// end ;
58659: GO 58537
58661: POP
58662: POP
// end ; end ;
58663: LD_VAR 0 7
58667: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58668: LD_INT 0
58670: PPUSH
58671: PPUSH
58672: PPUSH
58673: PPUSH
58674: PPUSH
58675: PPUSH
58676: PPUSH
58677: PPUSH
58678: PPUSH
58679: PPUSH
58680: PPUSH
58681: PPUSH
58682: PPUSH
58683: PPUSH
58684: PPUSH
58685: PPUSH
// result := false ;
58686: LD_ADDR_VAR 0 3
58690: PUSH
58691: LD_INT 0
58693: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58694: LD_VAR 0 1
58698: NOT
58699: PUSH
58700: LD_VAR 0 1
58704: PPUSH
58705: CALL_OW 266
58709: PUSH
58710: LD_INT 32
58712: PUSH
58713: LD_INT 33
58715: PUSH
58716: EMPTY
58717: LIST
58718: LIST
58719: IN
58720: NOT
58721: OR
58722: IFFALSE 58726
// exit ;
58724: GO 59862
// nat := GetNation ( tower ) ;
58726: LD_ADDR_VAR 0 12
58730: PUSH
58731: LD_VAR 0 1
58735: PPUSH
58736: CALL_OW 248
58740: ST_TO_ADDR
// side := GetSide ( tower ) ;
58741: LD_ADDR_VAR 0 16
58745: PUSH
58746: LD_VAR 0 1
58750: PPUSH
58751: CALL_OW 255
58755: ST_TO_ADDR
// x := GetX ( tower ) ;
58756: LD_ADDR_VAR 0 10
58760: PUSH
58761: LD_VAR 0 1
58765: PPUSH
58766: CALL_OW 250
58770: ST_TO_ADDR
// y := GetY ( tower ) ;
58771: LD_ADDR_VAR 0 11
58775: PUSH
58776: LD_VAR 0 1
58780: PPUSH
58781: CALL_OW 251
58785: ST_TO_ADDR
// if not x or not y then
58786: LD_VAR 0 10
58790: NOT
58791: PUSH
58792: LD_VAR 0 11
58796: NOT
58797: OR
58798: IFFALSE 58802
// exit ;
58800: GO 59862
// weapon := 0 ;
58802: LD_ADDR_VAR 0 18
58806: PUSH
58807: LD_INT 0
58809: ST_TO_ADDR
// fac_list := [ ] ;
58810: LD_ADDR_VAR 0 17
58814: PUSH
58815: EMPTY
58816: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
58817: LD_ADDR_VAR 0 6
58821: PUSH
58822: LD_VAR 0 1
58826: PPUSH
58827: CALL_OW 274
58831: PPUSH
58832: LD_VAR 0 2
58836: PPUSH
58837: CALL 56440 0 2
58841: PPUSH
58842: LD_INT 30
58844: PUSH
58845: LD_INT 3
58847: PUSH
58848: EMPTY
58849: LIST
58850: LIST
58851: PPUSH
58852: CALL_OW 72
58856: ST_TO_ADDR
// if not factories then
58857: LD_VAR 0 6
58861: NOT
58862: IFFALSE 58866
// exit ;
58864: GO 59862
// for i in factories do
58866: LD_ADDR_VAR 0 8
58870: PUSH
58871: LD_VAR 0 6
58875: PUSH
58876: FOR_IN
58877: IFFALSE 58902
// fac_list := fac_list union AvailableWeaponList ( i ) ;
58879: LD_ADDR_VAR 0 17
58883: PUSH
58884: LD_VAR 0 17
58888: PUSH
58889: LD_VAR 0 8
58893: PPUSH
58894: CALL_OW 478
58898: UNION
58899: ST_TO_ADDR
58900: GO 58876
58902: POP
58903: POP
// if not fac_list then
58904: LD_VAR 0 17
58908: NOT
58909: IFFALSE 58913
// exit ;
58911: GO 59862
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58913: LD_ADDR_VAR 0 5
58917: PUSH
58918: LD_INT 4
58920: PUSH
58921: LD_INT 5
58923: PUSH
58924: LD_INT 9
58926: PUSH
58927: LD_INT 10
58929: PUSH
58930: LD_INT 6
58932: PUSH
58933: LD_INT 7
58935: PUSH
58936: LD_INT 11
58938: PUSH
58939: EMPTY
58940: LIST
58941: LIST
58942: LIST
58943: LIST
58944: LIST
58945: LIST
58946: LIST
58947: PUSH
58948: LD_INT 27
58950: PUSH
58951: LD_INT 28
58953: PUSH
58954: LD_INT 26
58956: PUSH
58957: LD_INT 30
58959: PUSH
58960: EMPTY
58961: LIST
58962: LIST
58963: LIST
58964: LIST
58965: PUSH
58966: LD_INT 43
58968: PUSH
58969: LD_INT 44
58971: PUSH
58972: LD_INT 46
58974: PUSH
58975: LD_INT 45
58977: PUSH
58978: LD_INT 47
58980: PUSH
58981: LD_INT 49
58983: PUSH
58984: EMPTY
58985: LIST
58986: LIST
58987: LIST
58988: LIST
58989: LIST
58990: LIST
58991: PUSH
58992: EMPTY
58993: LIST
58994: LIST
58995: LIST
58996: PUSH
58997: LD_VAR 0 12
59001: ARRAY
59002: ST_TO_ADDR
// for i in list do
59003: LD_ADDR_VAR 0 8
59007: PUSH
59008: LD_VAR 0 5
59012: PUSH
59013: FOR_IN
59014: IFFALSE 59047
// if not i in fac_list then
59016: LD_VAR 0 8
59020: PUSH
59021: LD_VAR 0 17
59025: IN
59026: NOT
59027: IFFALSE 59045
// list := list diff i ;
59029: LD_ADDR_VAR 0 5
59033: PUSH
59034: LD_VAR 0 5
59038: PUSH
59039: LD_VAR 0 8
59043: DIFF
59044: ST_TO_ADDR
59045: GO 59013
59047: POP
59048: POP
// if not list then
59049: LD_VAR 0 5
59053: NOT
59054: IFFALSE 59058
// exit ;
59056: GO 59862
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59058: LD_VAR 0 12
59062: PUSH
59063: LD_INT 3
59065: EQUAL
59066: PUSH
59067: LD_INT 49
59069: PUSH
59070: LD_VAR 0 5
59074: IN
59075: AND
59076: PUSH
59077: LD_INT 31
59079: PPUSH
59080: LD_VAR 0 16
59084: PPUSH
59085: CALL_OW 321
59089: PUSH
59090: LD_INT 2
59092: EQUAL
59093: AND
59094: IFFALSE 59154
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59096: LD_INT 22
59098: PUSH
59099: LD_VAR 0 16
59103: PUSH
59104: EMPTY
59105: LIST
59106: LIST
59107: PUSH
59108: LD_INT 35
59110: PUSH
59111: LD_INT 49
59113: PUSH
59114: EMPTY
59115: LIST
59116: LIST
59117: PUSH
59118: LD_INT 91
59120: PUSH
59121: LD_VAR 0 1
59125: PUSH
59126: LD_INT 10
59128: PUSH
59129: EMPTY
59130: LIST
59131: LIST
59132: LIST
59133: PUSH
59134: EMPTY
59135: LIST
59136: LIST
59137: LIST
59138: PPUSH
59139: CALL_OW 69
59143: NOT
59144: IFFALSE 59154
// weapon := ru_time_lapser ;
59146: LD_ADDR_VAR 0 18
59150: PUSH
59151: LD_INT 49
59153: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59154: LD_VAR 0 12
59158: PUSH
59159: LD_INT 1
59161: PUSH
59162: LD_INT 2
59164: PUSH
59165: EMPTY
59166: LIST
59167: LIST
59168: IN
59169: PUSH
59170: LD_INT 11
59172: PUSH
59173: LD_VAR 0 5
59177: IN
59178: PUSH
59179: LD_INT 30
59181: PUSH
59182: LD_VAR 0 5
59186: IN
59187: OR
59188: AND
59189: PUSH
59190: LD_INT 6
59192: PPUSH
59193: LD_VAR 0 16
59197: PPUSH
59198: CALL_OW 321
59202: PUSH
59203: LD_INT 2
59205: EQUAL
59206: AND
59207: IFFALSE 59372
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59209: LD_INT 22
59211: PUSH
59212: LD_VAR 0 16
59216: PUSH
59217: EMPTY
59218: LIST
59219: LIST
59220: PUSH
59221: LD_INT 2
59223: PUSH
59224: LD_INT 35
59226: PUSH
59227: LD_INT 11
59229: PUSH
59230: EMPTY
59231: LIST
59232: LIST
59233: PUSH
59234: LD_INT 35
59236: PUSH
59237: LD_INT 30
59239: PUSH
59240: EMPTY
59241: LIST
59242: LIST
59243: PUSH
59244: EMPTY
59245: LIST
59246: LIST
59247: LIST
59248: PUSH
59249: LD_INT 91
59251: PUSH
59252: LD_VAR 0 1
59256: PUSH
59257: LD_INT 18
59259: PUSH
59260: EMPTY
59261: LIST
59262: LIST
59263: LIST
59264: PUSH
59265: EMPTY
59266: LIST
59267: LIST
59268: LIST
59269: PPUSH
59270: CALL_OW 69
59274: NOT
59275: PUSH
59276: LD_INT 22
59278: PUSH
59279: LD_VAR 0 16
59283: PUSH
59284: EMPTY
59285: LIST
59286: LIST
59287: PUSH
59288: LD_INT 2
59290: PUSH
59291: LD_INT 30
59293: PUSH
59294: LD_INT 32
59296: PUSH
59297: EMPTY
59298: LIST
59299: LIST
59300: PUSH
59301: LD_INT 30
59303: PUSH
59304: LD_INT 33
59306: PUSH
59307: EMPTY
59308: LIST
59309: LIST
59310: PUSH
59311: EMPTY
59312: LIST
59313: LIST
59314: LIST
59315: PUSH
59316: LD_INT 91
59318: PUSH
59319: LD_VAR 0 1
59323: PUSH
59324: LD_INT 12
59326: PUSH
59327: EMPTY
59328: LIST
59329: LIST
59330: LIST
59331: PUSH
59332: EMPTY
59333: LIST
59334: LIST
59335: LIST
59336: PUSH
59337: EMPTY
59338: LIST
59339: PPUSH
59340: CALL_OW 69
59344: PUSH
59345: LD_INT 2
59347: GREATER
59348: AND
59349: IFFALSE 59372
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59351: LD_ADDR_VAR 0 18
59355: PUSH
59356: LD_INT 11
59358: PUSH
59359: LD_INT 30
59361: PUSH
59362: EMPTY
59363: LIST
59364: LIST
59365: PUSH
59366: LD_VAR 0 12
59370: ARRAY
59371: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59372: LD_VAR 0 18
59376: NOT
59377: PUSH
59378: LD_INT 40
59380: PPUSH
59381: LD_VAR 0 16
59385: PPUSH
59386: CALL_OW 321
59390: PUSH
59391: LD_INT 2
59393: EQUAL
59394: AND
59395: PUSH
59396: LD_INT 7
59398: PUSH
59399: LD_VAR 0 5
59403: IN
59404: PUSH
59405: LD_INT 28
59407: PUSH
59408: LD_VAR 0 5
59412: IN
59413: OR
59414: PUSH
59415: LD_INT 45
59417: PUSH
59418: LD_VAR 0 5
59422: IN
59423: OR
59424: AND
59425: IFFALSE 59679
// begin hex := GetHexInfo ( x , y ) ;
59427: LD_ADDR_VAR 0 4
59431: PUSH
59432: LD_VAR 0 10
59436: PPUSH
59437: LD_VAR 0 11
59441: PPUSH
59442: CALL_OW 546
59446: ST_TO_ADDR
// if hex [ 1 ] then
59447: LD_VAR 0 4
59451: PUSH
59452: LD_INT 1
59454: ARRAY
59455: IFFALSE 59459
// exit ;
59457: GO 59862
// height := hex [ 2 ] ;
59459: LD_ADDR_VAR 0 15
59463: PUSH
59464: LD_VAR 0 4
59468: PUSH
59469: LD_INT 2
59471: ARRAY
59472: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59473: LD_ADDR_VAR 0 14
59477: PUSH
59478: LD_INT 0
59480: PUSH
59481: LD_INT 2
59483: PUSH
59484: LD_INT 3
59486: PUSH
59487: LD_INT 5
59489: PUSH
59490: EMPTY
59491: LIST
59492: LIST
59493: LIST
59494: LIST
59495: ST_TO_ADDR
// for i in tmp do
59496: LD_ADDR_VAR 0 8
59500: PUSH
59501: LD_VAR 0 14
59505: PUSH
59506: FOR_IN
59507: IFFALSE 59677
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59509: LD_ADDR_VAR 0 9
59513: PUSH
59514: LD_VAR 0 10
59518: PPUSH
59519: LD_VAR 0 8
59523: PPUSH
59524: LD_INT 5
59526: PPUSH
59527: CALL_OW 272
59531: PUSH
59532: LD_VAR 0 11
59536: PPUSH
59537: LD_VAR 0 8
59541: PPUSH
59542: LD_INT 5
59544: PPUSH
59545: CALL_OW 273
59549: PUSH
59550: EMPTY
59551: LIST
59552: LIST
59553: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59554: LD_VAR 0 9
59558: PUSH
59559: LD_INT 1
59561: ARRAY
59562: PPUSH
59563: LD_VAR 0 9
59567: PUSH
59568: LD_INT 2
59570: ARRAY
59571: PPUSH
59572: CALL_OW 488
59576: IFFALSE 59675
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59578: LD_ADDR_VAR 0 4
59582: PUSH
59583: LD_VAR 0 9
59587: PUSH
59588: LD_INT 1
59590: ARRAY
59591: PPUSH
59592: LD_VAR 0 9
59596: PUSH
59597: LD_INT 2
59599: ARRAY
59600: PPUSH
59601: CALL_OW 546
59605: ST_TO_ADDR
// if hex [ 1 ] then
59606: LD_VAR 0 4
59610: PUSH
59611: LD_INT 1
59613: ARRAY
59614: IFFALSE 59618
// continue ;
59616: GO 59506
// h := hex [ 2 ] ;
59618: LD_ADDR_VAR 0 13
59622: PUSH
59623: LD_VAR 0 4
59627: PUSH
59628: LD_INT 2
59630: ARRAY
59631: ST_TO_ADDR
// if h + 7 < height then
59632: LD_VAR 0 13
59636: PUSH
59637: LD_INT 7
59639: PLUS
59640: PUSH
59641: LD_VAR 0 15
59645: LESS
59646: IFFALSE 59675
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59648: LD_ADDR_VAR 0 18
59652: PUSH
59653: LD_INT 7
59655: PUSH
59656: LD_INT 28
59658: PUSH
59659: LD_INT 45
59661: PUSH
59662: EMPTY
59663: LIST
59664: LIST
59665: LIST
59666: PUSH
59667: LD_VAR 0 12
59671: ARRAY
59672: ST_TO_ADDR
// break ;
59673: GO 59677
// end ; end ; end ;
59675: GO 59506
59677: POP
59678: POP
// end ; if not weapon then
59679: LD_VAR 0 18
59683: NOT
59684: IFFALSE 59744
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59686: LD_ADDR_VAR 0 5
59690: PUSH
59691: LD_VAR 0 5
59695: PUSH
59696: LD_INT 11
59698: PUSH
59699: LD_INT 30
59701: PUSH
59702: LD_INT 49
59704: PUSH
59705: EMPTY
59706: LIST
59707: LIST
59708: LIST
59709: DIFF
59710: ST_TO_ADDR
// if not list then
59711: LD_VAR 0 5
59715: NOT
59716: IFFALSE 59720
// exit ;
59718: GO 59862
// weapon := list [ rand ( 1 , list ) ] ;
59720: LD_ADDR_VAR 0 18
59724: PUSH
59725: LD_VAR 0 5
59729: PUSH
59730: LD_INT 1
59732: PPUSH
59733: LD_VAR 0 5
59737: PPUSH
59738: CALL_OW 12
59742: ARRAY
59743: ST_TO_ADDR
// end ; if weapon then
59744: LD_VAR 0 18
59748: IFFALSE 59862
// begin tmp := CostOfWeapon ( weapon ) ;
59750: LD_ADDR_VAR 0 14
59754: PUSH
59755: LD_VAR 0 18
59759: PPUSH
59760: CALL_OW 451
59764: ST_TO_ADDR
// j := GetBase ( tower ) ;
59765: LD_ADDR_VAR 0 9
59769: PUSH
59770: LD_VAR 0 1
59774: PPUSH
59775: CALL_OW 274
59779: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59780: LD_VAR 0 9
59784: PPUSH
59785: LD_INT 1
59787: PPUSH
59788: CALL_OW 275
59792: PUSH
59793: LD_VAR 0 14
59797: PUSH
59798: LD_INT 1
59800: ARRAY
59801: GREATEREQUAL
59802: PUSH
59803: LD_VAR 0 9
59807: PPUSH
59808: LD_INT 2
59810: PPUSH
59811: CALL_OW 275
59815: PUSH
59816: LD_VAR 0 14
59820: PUSH
59821: LD_INT 2
59823: ARRAY
59824: GREATEREQUAL
59825: AND
59826: PUSH
59827: LD_VAR 0 9
59831: PPUSH
59832: LD_INT 3
59834: PPUSH
59835: CALL_OW 275
59839: PUSH
59840: LD_VAR 0 14
59844: PUSH
59845: LD_INT 3
59847: ARRAY
59848: GREATEREQUAL
59849: AND
59850: IFFALSE 59862
// result := weapon ;
59852: LD_ADDR_VAR 0 3
59856: PUSH
59857: LD_VAR 0 18
59861: ST_TO_ADDR
// end ; end ;
59862: LD_VAR 0 3
59866: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59867: LD_INT 0
59869: PPUSH
59870: PPUSH
// result := true ;
59871: LD_ADDR_VAR 0 3
59875: PUSH
59876: LD_INT 1
59878: ST_TO_ADDR
// if array1 = array2 then
59879: LD_VAR 0 1
59883: PUSH
59884: LD_VAR 0 2
59888: EQUAL
59889: IFFALSE 59949
// begin for i = 1 to array1 do
59891: LD_ADDR_VAR 0 4
59895: PUSH
59896: DOUBLE
59897: LD_INT 1
59899: DEC
59900: ST_TO_ADDR
59901: LD_VAR 0 1
59905: PUSH
59906: FOR_TO
59907: IFFALSE 59945
// if array1 [ i ] <> array2 [ i ] then
59909: LD_VAR 0 1
59913: PUSH
59914: LD_VAR 0 4
59918: ARRAY
59919: PUSH
59920: LD_VAR 0 2
59924: PUSH
59925: LD_VAR 0 4
59929: ARRAY
59930: NONEQUAL
59931: IFFALSE 59943
// begin result := false ;
59933: LD_ADDR_VAR 0 3
59937: PUSH
59938: LD_INT 0
59940: ST_TO_ADDR
// break ;
59941: GO 59945
// end ;
59943: GO 59906
59945: POP
59946: POP
// end else
59947: GO 59957
// result := false ;
59949: LD_ADDR_VAR 0 3
59953: PUSH
59954: LD_INT 0
59956: ST_TO_ADDR
// end ;
59957: LD_VAR 0 3
59961: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
59962: LD_INT 0
59964: PPUSH
59965: PPUSH
59966: PPUSH
// pom := GetBase ( fac ) ;
59967: LD_ADDR_VAR 0 5
59971: PUSH
59972: LD_VAR 0 1
59976: PPUSH
59977: CALL_OW 274
59981: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
59982: LD_ADDR_VAR 0 4
59986: PUSH
59987: LD_VAR 0 2
59991: PUSH
59992: LD_INT 1
59994: ARRAY
59995: PPUSH
59996: LD_VAR 0 2
60000: PUSH
60001: LD_INT 2
60003: ARRAY
60004: PPUSH
60005: LD_VAR 0 2
60009: PUSH
60010: LD_INT 3
60012: ARRAY
60013: PPUSH
60014: LD_VAR 0 2
60018: PUSH
60019: LD_INT 4
60021: ARRAY
60022: PPUSH
60023: CALL_OW 449
60027: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60028: LD_ADDR_VAR 0 3
60032: PUSH
60033: LD_VAR 0 5
60037: PPUSH
60038: LD_INT 1
60040: PPUSH
60041: CALL_OW 275
60045: PUSH
60046: LD_VAR 0 4
60050: PUSH
60051: LD_INT 1
60053: ARRAY
60054: GREATEREQUAL
60055: PUSH
60056: LD_VAR 0 5
60060: PPUSH
60061: LD_INT 2
60063: PPUSH
60064: CALL_OW 275
60068: PUSH
60069: LD_VAR 0 4
60073: PUSH
60074: LD_INT 2
60076: ARRAY
60077: GREATEREQUAL
60078: AND
60079: PUSH
60080: LD_VAR 0 5
60084: PPUSH
60085: LD_INT 3
60087: PPUSH
60088: CALL_OW 275
60092: PUSH
60093: LD_VAR 0 4
60097: PUSH
60098: LD_INT 3
60100: ARRAY
60101: GREATEREQUAL
60102: AND
60103: ST_TO_ADDR
// end ;
60104: LD_VAR 0 3
60108: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60109: LD_INT 0
60111: PPUSH
60112: PPUSH
60113: PPUSH
60114: PPUSH
// pom := GetBase ( building ) ;
60115: LD_ADDR_VAR 0 3
60119: PUSH
60120: LD_VAR 0 1
60124: PPUSH
60125: CALL_OW 274
60129: ST_TO_ADDR
// if not pom then
60130: LD_VAR 0 3
60134: NOT
60135: IFFALSE 60139
// exit ;
60137: GO 60309
// btype := GetBType ( building ) ;
60139: LD_ADDR_VAR 0 5
60143: PUSH
60144: LD_VAR 0 1
60148: PPUSH
60149: CALL_OW 266
60153: ST_TO_ADDR
// if btype = b_armoury then
60154: LD_VAR 0 5
60158: PUSH
60159: LD_INT 4
60161: EQUAL
60162: IFFALSE 60172
// btype := b_barracks ;
60164: LD_ADDR_VAR 0 5
60168: PUSH
60169: LD_INT 5
60171: ST_TO_ADDR
// if btype = b_depot then
60172: LD_VAR 0 5
60176: PUSH
60177: LD_INT 0
60179: EQUAL
60180: IFFALSE 60190
// btype := b_warehouse ;
60182: LD_ADDR_VAR 0 5
60186: PUSH
60187: LD_INT 1
60189: ST_TO_ADDR
// if btype = b_workshop then
60190: LD_VAR 0 5
60194: PUSH
60195: LD_INT 2
60197: EQUAL
60198: IFFALSE 60208
// btype := b_factory ;
60200: LD_ADDR_VAR 0 5
60204: PUSH
60205: LD_INT 3
60207: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60208: LD_ADDR_VAR 0 4
60212: PUSH
60213: LD_VAR 0 5
60217: PPUSH
60218: LD_VAR 0 1
60222: PPUSH
60223: CALL_OW 248
60227: PPUSH
60228: CALL_OW 450
60232: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60233: LD_ADDR_VAR 0 2
60237: PUSH
60238: LD_VAR 0 3
60242: PPUSH
60243: LD_INT 1
60245: PPUSH
60246: CALL_OW 275
60250: PUSH
60251: LD_VAR 0 4
60255: PUSH
60256: LD_INT 1
60258: ARRAY
60259: GREATEREQUAL
60260: PUSH
60261: LD_VAR 0 3
60265: PPUSH
60266: LD_INT 2
60268: PPUSH
60269: CALL_OW 275
60273: PUSH
60274: LD_VAR 0 4
60278: PUSH
60279: LD_INT 2
60281: ARRAY
60282: GREATEREQUAL
60283: AND
60284: PUSH
60285: LD_VAR 0 3
60289: PPUSH
60290: LD_INT 3
60292: PPUSH
60293: CALL_OW 275
60297: PUSH
60298: LD_VAR 0 4
60302: PUSH
60303: LD_INT 3
60305: ARRAY
60306: GREATEREQUAL
60307: AND
60308: ST_TO_ADDR
// end ;
60309: LD_VAR 0 2
60313: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60314: LD_INT 0
60316: PPUSH
60317: PPUSH
60318: PPUSH
// pom := GetBase ( building ) ;
60319: LD_ADDR_VAR 0 4
60323: PUSH
60324: LD_VAR 0 1
60328: PPUSH
60329: CALL_OW 274
60333: ST_TO_ADDR
// if not pom then
60334: LD_VAR 0 4
60338: NOT
60339: IFFALSE 60343
// exit ;
60341: GO 60444
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60343: LD_ADDR_VAR 0 5
60347: PUSH
60348: LD_VAR 0 2
60352: PPUSH
60353: LD_VAR 0 1
60357: PPUSH
60358: CALL_OW 248
60362: PPUSH
60363: CALL_OW 450
60367: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60368: LD_ADDR_VAR 0 3
60372: PUSH
60373: LD_VAR 0 4
60377: PPUSH
60378: LD_INT 1
60380: PPUSH
60381: CALL_OW 275
60385: PUSH
60386: LD_VAR 0 5
60390: PUSH
60391: LD_INT 1
60393: ARRAY
60394: GREATEREQUAL
60395: PUSH
60396: LD_VAR 0 4
60400: PPUSH
60401: LD_INT 2
60403: PPUSH
60404: CALL_OW 275
60408: PUSH
60409: LD_VAR 0 5
60413: PUSH
60414: LD_INT 2
60416: ARRAY
60417: GREATEREQUAL
60418: AND
60419: PUSH
60420: LD_VAR 0 4
60424: PPUSH
60425: LD_INT 3
60427: PPUSH
60428: CALL_OW 275
60432: PUSH
60433: LD_VAR 0 5
60437: PUSH
60438: LD_INT 3
60440: ARRAY
60441: GREATEREQUAL
60442: AND
60443: ST_TO_ADDR
// end ;
60444: LD_VAR 0 3
60448: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
60449: LD_INT 0
60451: PPUSH
60452: PPUSH
60453: PPUSH
60454: PPUSH
60455: PPUSH
60456: PPUSH
60457: PPUSH
60458: PPUSH
60459: PPUSH
60460: PPUSH
// result := false ;
60461: LD_ADDR_VAR 0 6
60465: PUSH
60466: LD_INT 0
60468: ST_TO_ADDR
// if not base or not btype or not x or not y then
60469: LD_VAR 0 1
60473: NOT
60474: PUSH
60475: LD_VAR 0 2
60479: NOT
60480: OR
60481: PUSH
60482: LD_VAR 0 3
60486: NOT
60487: OR
60488: PUSH
60489: LD_VAR 0 4
60493: NOT
60494: OR
60495: IFFALSE 60499
// exit ;
60497: GO 61108
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
60499: LD_ADDR_VAR 0 12
60503: PUSH
60504: LD_VAR 0 2
60508: PPUSH
60509: LD_VAR 0 3
60513: PPUSH
60514: LD_VAR 0 4
60518: PPUSH
60519: LD_VAR 0 5
60523: PPUSH
60524: LD_VAR 0 1
60528: PUSH
60529: LD_INT 1
60531: ARRAY
60532: PPUSH
60533: CALL_OW 248
60537: PPUSH
60538: LD_INT 0
60540: PPUSH
60541: CALL 61945 0 6
60545: ST_TO_ADDR
// if not hexes then
60546: LD_VAR 0 12
60550: NOT
60551: IFFALSE 60555
// exit ;
60553: GO 61108
// for i = 1 to hexes do
60555: LD_ADDR_VAR 0 7
60559: PUSH
60560: DOUBLE
60561: LD_INT 1
60563: DEC
60564: ST_TO_ADDR
60565: LD_VAR 0 12
60569: PUSH
60570: FOR_TO
60571: IFFALSE 61106
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60573: LD_ADDR_VAR 0 11
60577: PUSH
60578: LD_VAR 0 12
60582: PUSH
60583: LD_VAR 0 7
60587: ARRAY
60588: PUSH
60589: LD_INT 1
60591: ARRAY
60592: PPUSH
60593: LD_VAR 0 12
60597: PUSH
60598: LD_VAR 0 7
60602: ARRAY
60603: PUSH
60604: LD_INT 2
60606: ARRAY
60607: PPUSH
60608: CALL_OW 428
60612: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60613: LD_VAR 0 12
60617: PUSH
60618: LD_VAR 0 7
60622: ARRAY
60623: PUSH
60624: LD_INT 1
60626: ARRAY
60627: PPUSH
60628: LD_VAR 0 12
60632: PUSH
60633: LD_VAR 0 7
60637: ARRAY
60638: PUSH
60639: LD_INT 2
60641: ARRAY
60642: PPUSH
60643: CALL_OW 351
60647: PUSH
60648: LD_VAR 0 12
60652: PUSH
60653: LD_VAR 0 7
60657: ARRAY
60658: PUSH
60659: LD_INT 1
60661: ARRAY
60662: PPUSH
60663: LD_VAR 0 12
60667: PUSH
60668: LD_VAR 0 7
60672: ARRAY
60673: PUSH
60674: LD_INT 2
60676: ARRAY
60677: PPUSH
60678: CALL_OW 488
60682: NOT
60683: OR
60684: PUSH
60685: LD_VAR 0 11
60689: PPUSH
60690: CALL_OW 247
60694: PUSH
60695: LD_INT 3
60697: EQUAL
60698: OR
60699: IFFALSE 60705
// exit ;
60701: POP
60702: POP
60703: GO 61108
// if not tmp or not tmp in base then
60705: LD_VAR 0 11
60709: NOT
60710: PUSH
60711: LD_VAR 0 11
60715: PUSH
60716: LD_VAR 0 1
60720: IN
60721: NOT
60722: OR
60723: IFFALSE 60727
// continue ;
60725: GO 60570
// result := true ;
60727: LD_ADDR_VAR 0 6
60731: PUSH
60732: LD_INT 1
60734: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60735: LD_ADDR_VAR 0 15
60739: PUSH
60740: LD_VAR 0 1
60744: PPUSH
60745: LD_INT 22
60747: PUSH
60748: LD_VAR 0 11
60752: PPUSH
60753: CALL_OW 255
60757: PUSH
60758: EMPTY
60759: LIST
60760: LIST
60761: PUSH
60762: LD_INT 2
60764: PUSH
60765: LD_INT 30
60767: PUSH
60768: LD_INT 0
60770: PUSH
60771: EMPTY
60772: LIST
60773: LIST
60774: PUSH
60775: LD_INT 30
60777: PUSH
60778: LD_INT 1
60780: PUSH
60781: EMPTY
60782: LIST
60783: LIST
60784: PUSH
60785: EMPTY
60786: LIST
60787: LIST
60788: LIST
60789: PUSH
60790: EMPTY
60791: LIST
60792: LIST
60793: PPUSH
60794: CALL_OW 72
60798: ST_TO_ADDR
// if dep then
60799: LD_VAR 0 15
60803: IFFALSE 60939
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
60805: LD_ADDR_VAR 0 14
60809: PUSH
60810: LD_VAR 0 15
60814: PUSH
60815: LD_INT 1
60817: ARRAY
60818: PPUSH
60819: CALL_OW 250
60823: PPUSH
60824: LD_VAR 0 15
60828: PUSH
60829: LD_INT 1
60831: ARRAY
60832: PPUSH
60833: CALL_OW 254
60837: PPUSH
60838: LD_INT 5
60840: PPUSH
60841: CALL_OW 272
60845: PUSH
60846: LD_VAR 0 15
60850: PUSH
60851: LD_INT 1
60853: ARRAY
60854: PPUSH
60855: CALL_OW 251
60859: PPUSH
60860: LD_VAR 0 15
60864: PUSH
60865: LD_INT 1
60867: ARRAY
60868: PPUSH
60869: CALL_OW 254
60873: PPUSH
60874: LD_INT 5
60876: PPUSH
60877: CALL_OW 273
60881: PUSH
60882: EMPTY
60883: LIST
60884: LIST
60885: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
60886: LD_VAR 0 14
60890: PUSH
60891: LD_INT 1
60893: ARRAY
60894: PPUSH
60895: LD_VAR 0 14
60899: PUSH
60900: LD_INT 2
60902: ARRAY
60903: PPUSH
60904: CALL_OW 488
60908: IFFALSE 60939
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
60910: LD_VAR 0 11
60914: PPUSH
60915: LD_VAR 0 14
60919: PUSH
60920: LD_INT 1
60922: ARRAY
60923: PPUSH
60924: LD_VAR 0 14
60928: PUSH
60929: LD_INT 2
60931: ARRAY
60932: PPUSH
60933: CALL_OW 111
// continue ;
60937: GO 60570
// end ; end ; r := GetDir ( tmp ) ;
60939: LD_ADDR_VAR 0 13
60943: PUSH
60944: LD_VAR 0 11
60948: PPUSH
60949: CALL_OW 254
60953: ST_TO_ADDR
// if r = 5 then
60954: LD_VAR 0 13
60958: PUSH
60959: LD_INT 5
60961: EQUAL
60962: IFFALSE 60972
// r := 0 ;
60964: LD_ADDR_VAR 0 13
60968: PUSH
60969: LD_INT 0
60971: ST_TO_ADDR
// for j = r to 5 do
60972: LD_ADDR_VAR 0 8
60976: PUSH
60977: DOUBLE
60978: LD_VAR 0 13
60982: DEC
60983: ST_TO_ADDR
60984: LD_INT 5
60986: PUSH
60987: FOR_TO
60988: IFFALSE 61102
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
60990: LD_ADDR_VAR 0 9
60994: PUSH
60995: LD_VAR 0 11
60999: PPUSH
61000: CALL_OW 250
61004: PPUSH
61005: LD_VAR 0 8
61009: PPUSH
61010: LD_INT 2
61012: PPUSH
61013: CALL_OW 272
61017: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61018: LD_ADDR_VAR 0 10
61022: PUSH
61023: LD_VAR 0 11
61027: PPUSH
61028: CALL_OW 251
61032: PPUSH
61033: LD_VAR 0 8
61037: PPUSH
61038: LD_INT 2
61040: PPUSH
61041: CALL_OW 273
61045: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61046: LD_VAR 0 9
61050: PPUSH
61051: LD_VAR 0 10
61055: PPUSH
61056: CALL_OW 488
61060: PUSH
61061: LD_VAR 0 9
61065: PPUSH
61066: LD_VAR 0 10
61070: PPUSH
61071: CALL_OW 428
61075: NOT
61076: AND
61077: IFFALSE 61100
// begin ComMoveXY ( tmp , _x , _y ) ;
61079: LD_VAR 0 11
61083: PPUSH
61084: LD_VAR 0 9
61088: PPUSH
61089: LD_VAR 0 10
61093: PPUSH
61094: CALL_OW 111
// break ;
61098: GO 61102
// end ; end ;
61100: GO 60987
61102: POP
61103: POP
// end ;
61104: GO 60570
61106: POP
61107: POP
// end ;
61108: LD_VAR 0 6
61112: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
61113: LD_INT 0
61115: PPUSH
61116: PPUSH
61117: PPUSH
61118: PPUSH
61119: PPUSH
61120: PPUSH
61121: PPUSH
61122: PPUSH
61123: PPUSH
61124: PPUSH
// result := false ;
61125: LD_ADDR_VAR 0 6
61129: PUSH
61130: LD_INT 0
61132: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61133: LD_VAR 0 1
61137: NOT
61138: PUSH
61139: LD_VAR 0 1
61143: PPUSH
61144: CALL_OW 266
61148: PUSH
61149: LD_INT 0
61151: PUSH
61152: LD_INT 1
61154: PUSH
61155: EMPTY
61156: LIST
61157: LIST
61158: IN
61159: NOT
61160: OR
61161: PUSH
61162: LD_VAR 0 2
61166: NOT
61167: OR
61168: PUSH
61169: LD_VAR 0 5
61173: PUSH
61174: LD_INT 0
61176: PUSH
61177: LD_INT 1
61179: PUSH
61180: LD_INT 2
61182: PUSH
61183: LD_INT 3
61185: PUSH
61186: LD_INT 4
61188: PUSH
61189: LD_INT 5
61191: PUSH
61192: EMPTY
61193: LIST
61194: LIST
61195: LIST
61196: LIST
61197: LIST
61198: LIST
61199: IN
61200: NOT
61201: OR
61202: PUSH
61203: LD_VAR 0 3
61207: PPUSH
61208: LD_VAR 0 4
61212: PPUSH
61213: CALL_OW 488
61217: NOT
61218: OR
61219: IFFALSE 61223
// exit ;
61221: GO 61940
// pom := GetBase ( depot ) ;
61223: LD_ADDR_VAR 0 10
61227: PUSH
61228: LD_VAR 0 1
61232: PPUSH
61233: CALL_OW 274
61237: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
61238: LD_ADDR_VAR 0 11
61242: PUSH
61243: LD_VAR 0 2
61247: PPUSH
61248: LD_VAR 0 1
61252: PPUSH
61253: CALL_OW 248
61257: PPUSH
61258: CALL_OW 450
61262: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
61263: LD_VAR 0 10
61267: PPUSH
61268: LD_INT 1
61270: PPUSH
61271: CALL_OW 275
61275: PUSH
61276: LD_VAR 0 11
61280: PUSH
61281: LD_INT 1
61283: ARRAY
61284: GREATEREQUAL
61285: PUSH
61286: LD_VAR 0 10
61290: PPUSH
61291: LD_INT 2
61293: PPUSH
61294: CALL_OW 275
61298: PUSH
61299: LD_VAR 0 11
61303: PUSH
61304: LD_INT 2
61306: ARRAY
61307: GREATEREQUAL
61308: AND
61309: PUSH
61310: LD_VAR 0 10
61314: PPUSH
61315: LD_INT 3
61317: PPUSH
61318: CALL_OW 275
61322: PUSH
61323: LD_VAR 0 11
61327: PUSH
61328: LD_INT 3
61330: ARRAY
61331: GREATEREQUAL
61332: AND
61333: NOT
61334: IFFALSE 61338
// exit ;
61336: GO 61940
// if GetBType ( depot ) = b_depot then
61338: LD_VAR 0 1
61342: PPUSH
61343: CALL_OW 266
61347: PUSH
61348: LD_INT 0
61350: EQUAL
61351: IFFALSE 61363
// dist := 28 else
61353: LD_ADDR_VAR 0 14
61357: PUSH
61358: LD_INT 28
61360: ST_TO_ADDR
61361: GO 61371
// dist := 36 ;
61363: LD_ADDR_VAR 0 14
61367: PUSH
61368: LD_INT 36
61370: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
61371: LD_VAR 0 1
61375: PPUSH
61376: LD_VAR 0 3
61380: PPUSH
61381: LD_VAR 0 4
61385: PPUSH
61386: CALL_OW 297
61390: PUSH
61391: LD_VAR 0 14
61395: GREATER
61396: IFFALSE 61400
// exit ;
61398: GO 61940
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
61400: LD_ADDR_VAR 0 12
61404: PUSH
61405: LD_VAR 0 2
61409: PPUSH
61410: LD_VAR 0 3
61414: PPUSH
61415: LD_VAR 0 4
61419: PPUSH
61420: LD_VAR 0 5
61424: PPUSH
61425: LD_VAR 0 1
61429: PPUSH
61430: CALL_OW 248
61434: PPUSH
61435: LD_INT 0
61437: PPUSH
61438: CALL 61945 0 6
61442: ST_TO_ADDR
// if not hexes then
61443: LD_VAR 0 12
61447: NOT
61448: IFFALSE 61452
// exit ;
61450: GO 61940
// hex := GetHexInfo ( x , y ) ;
61452: LD_ADDR_VAR 0 15
61456: PUSH
61457: LD_VAR 0 3
61461: PPUSH
61462: LD_VAR 0 4
61466: PPUSH
61467: CALL_OW 546
61471: ST_TO_ADDR
// if hex [ 1 ] then
61472: LD_VAR 0 15
61476: PUSH
61477: LD_INT 1
61479: ARRAY
61480: IFFALSE 61484
// exit ;
61482: GO 61940
// height := hex [ 2 ] ;
61484: LD_ADDR_VAR 0 13
61488: PUSH
61489: LD_VAR 0 15
61493: PUSH
61494: LD_INT 2
61496: ARRAY
61497: ST_TO_ADDR
// for i = 1 to hexes do
61498: LD_ADDR_VAR 0 7
61502: PUSH
61503: DOUBLE
61504: LD_INT 1
61506: DEC
61507: ST_TO_ADDR
61508: LD_VAR 0 12
61512: PUSH
61513: FOR_TO
61514: IFFALSE 61844
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
61516: LD_VAR 0 12
61520: PUSH
61521: LD_VAR 0 7
61525: ARRAY
61526: PUSH
61527: LD_INT 1
61529: ARRAY
61530: PPUSH
61531: LD_VAR 0 12
61535: PUSH
61536: LD_VAR 0 7
61540: ARRAY
61541: PUSH
61542: LD_INT 2
61544: ARRAY
61545: PPUSH
61546: CALL_OW 488
61550: NOT
61551: PUSH
61552: LD_VAR 0 12
61556: PUSH
61557: LD_VAR 0 7
61561: ARRAY
61562: PUSH
61563: LD_INT 1
61565: ARRAY
61566: PPUSH
61567: LD_VAR 0 12
61571: PUSH
61572: LD_VAR 0 7
61576: ARRAY
61577: PUSH
61578: LD_INT 2
61580: ARRAY
61581: PPUSH
61582: CALL_OW 428
61586: PUSH
61587: LD_INT 0
61589: GREATER
61590: OR
61591: PUSH
61592: LD_VAR 0 12
61596: PUSH
61597: LD_VAR 0 7
61601: ARRAY
61602: PUSH
61603: LD_INT 1
61605: ARRAY
61606: PPUSH
61607: LD_VAR 0 12
61611: PUSH
61612: LD_VAR 0 7
61616: ARRAY
61617: PUSH
61618: LD_INT 2
61620: ARRAY
61621: PPUSH
61622: CALL_OW 351
61626: OR
61627: IFFALSE 61633
// exit ;
61629: POP
61630: POP
61631: GO 61940
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61633: LD_ADDR_VAR 0 8
61637: PUSH
61638: LD_VAR 0 12
61642: PUSH
61643: LD_VAR 0 7
61647: ARRAY
61648: PUSH
61649: LD_INT 1
61651: ARRAY
61652: PPUSH
61653: LD_VAR 0 12
61657: PUSH
61658: LD_VAR 0 7
61662: ARRAY
61663: PUSH
61664: LD_INT 2
61666: ARRAY
61667: PPUSH
61668: CALL_OW 546
61672: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
61673: LD_VAR 0 8
61677: PUSH
61678: LD_INT 1
61680: ARRAY
61681: PUSH
61682: LD_VAR 0 8
61686: PUSH
61687: LD_INT 2
61689: ARRAY
61690: PUSH
61691: LD_VAR 0 13
61695: PUSH
61696: LD_INT 2
61698: PLUS
61699: GREATER
61700: OR
61701: PUSH
61702: LD_VAR 0 8
61706: PUSH
61707: LD_INT 2
61709: ARRAY
61710: PUSH
61711: LD_VAR 0 13
61715: PUSH
61716: LD_INT 2
61718: MINUS
61719: LESS
61720: OR
61721: PUSH
61722: LD_VAR 0 8
61726: PUSH
61727: LD_INT 3
61729: ARRAY
61730: PUSH
61731: LD_INT 0
61733: PUSH
61734: LD_INT 8
61736: PUSH
61737: LD_INT 9
61739: PUSH
61740: LD_INT 10
61742: PUSH
61743: LD_INT 11
61745: PUSH
61746: LD_INT 12
61748: PUSH
61749: LD_INT 13
61751: PUSH
61752: LD_INT 16
61754: PUSH
61755: LD_INT 17
61757: PUSH
61758: LD_INT 18
61760: PUSH
61761: LD_INT 19
61763: PUSH
61764: LD_INT 20
61766: PUSH
61767: LD_INT 21
61769: PUSH
61770: EMPTY
61771: LIST
61772: LIST
61773: LIST
61774: LIST
61775: LIST
61776: LIST
61777: LIST
61778: LIST
61779: LIST
61780: LIST
61781: LIST
61782: LIST
61783: LIST
61784: IN
61785: NOT
61786: OR
61787: PUSH
61788: LD_VAR 0 8
61792: PUSH
61793: LD_INT 5
61795: ARRAY
61796: NOT
61797: OR
61798: PUSH
61799: LD_VAR 0 8
61803: PUSH
61804: LD_INT 6
61806: ARRAY
61807: PUSH
61808: LD_INT 1
61810: PUSH
61811: LD_INT 2
61813: PUSH
61814: LD_INT 7
61816: PUSH
61817: LD_INT 9
61819: PUSH
61820: LD_INT 10
61822: PUSH
61823: LD_INT 11
61825: PUSH
61826: EMPTY
61827: LIST
61828: LIST
61829: LIST
61830: LIST
61831: LIST
61832: LIST
61833: IN
61834: NOT
61835: OR
61836: IFFALSE 61842
// exit ;
61838: POP
61839: POP
61840: GO 61940
// end ;
61842: GO 61513
61844: POP
61845: POP
// side := GetSide ( depot ) ;
61846: LD_ADDR_VAR 0 9
61850: PUSH
61851: LD_VAR 0 1
61855: PPUSH
61856: CALL_OW 255
61860: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
61861: LD_VAR 0 9
61865: PPUSH
61866: LD_VAR 0 3
61870: PPUSH
61871: LD_VAR 0 4
61875: PPUSH
61876: LD_INT 20
61878: PPUSH
61879: CALL 54594 0 4
61883: PUSH
61884: LD_INT 4
61886: ARRAY
61887: IFFALSE 61891
// exit ;
61889: GO 61940
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
61891: LD_VAR 0 2
61895: PUSH
61896: LD_INT 29
61898: PUSH
61899: LD_INT 30
61901: PUSH
61902: EMPTY
61903: LIST
61904: LIST
61905: IN
61906: PUSH
61907: LD_VAR 0 3
61911: PPUSH
61912: LD_VAR 0 4
61916: PPUSH
61917: LD_VAR 0 9
61921: PPUSH
61922: CALL_OW 440
61926: NOT
61927: AND
61928: IFFALSE 61932
// exit ;
61930: GO 61940
// result := true ;
61932: LD_ADDR_VAR 0 6
61936: PUSH
61937: LD_INT 1
61939: ST_TO_ADDR
// end ;
61940: LD_VAR 0 6
61944: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
61945: LD_INT 0
61947: PPUSH
61948: PPUSH
61949: PPUSH
61950: PPUSH
61951: PPUSH
61952: PPUSH
61953: PPUSH
61954: PPUSH
61955: PPUSH
61956: PPUSH
61957: PPUSH
61958: PPUSH
61959: PPUSH
61960: PPUSH
61961: PPUSH
61962: PPUSH
61963: PPUSH
61964: PPUSH
61965: PPUSH
61966: PPUSH
61967: PPUSH
61968: PPUSH
61969: PPUSH
61970: PPUSH
61971: PPUSH
61972: PPUSH
61973: PPUSH
61974: PPUSH
61975: PPUSH
61976: PPUSH
61977: PPUSH
61978: PPUSH
61979: PPUSH
61980: PPUSH
61981: PPUSH
61982: PPUSH
61983: PPUSH
61984: PPUSH
61985: PPUSH
61986: PPUSH
61987: PPUSH
61988: PPUSH
61989: PPUSH
61990: PPUSH
61991: PPUSH
61992: PPUSH
61993: PPUSH
61994: PPUSH
61995: PPUSH
61996: PPUSH
61997: PPUSH
61998: PPUSH
61999: PPUSH
62000: PPUSH
62001: PPUSH
62002: PPUSH
62003: PPUSH
62004: PPUSH
// result = [ ] ;
62005: LD_ADDR_VAR 0 7
62009: PUSH
62010: EMPTY
62011: ST_TO_ADDR
// temp_list = [ ] ;
62012: LD_ADDR_VAR 0 9
62016: PUSH
62017: EMPTY
62018: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62019: LD_VAR 0 4
62023: PUSH
62024: LD_INT 0
62026: PUSH
62027: LD_INT 1
62029: PUSH
62030: LD_INT 2
62032: PUSH
62033: LD_INT 3
62035: PUSH
62036: LD_INT 4
62038: PUSH
62039: LD_INT 5
62041: PUSH
62042: EMPTY
62043: LIST
62044: LIST
62045: LIST
62046: LIST
62047: LIST
62048: LIST
62049: IN
62050: NOT
62051: PUSH
62052: LD_VAR 0 1
62056: PUSH
62057: LD_INT 0
62059: PUSH
62060: LD_INT 1
62062: PUSH
62063: EMPTY
62064: LIST
62065: LIST
62066: IN
62067: PUSH
62068: LD_VAR 0 5
62072: PUSH
62073: LD_INT 1
62075: PUSH
62076: LD_INT 2
62078: PUSH
62079: LD_INT 3
62081: PUSH
62082: EMPTY
62083: LIST
62084: LIST
62085: LIST
62086: IN
62087: NOT
62088: AND
62089: OR
62090: IFFALSE 62094
// exit ;
62092: GO 80485
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62094: LD_VAR 0 1
62098: PUSH
62099: LD_INT 6
62101: PUSH
62102: LD_INT 7
62104: PUSH
62105: LD_INT 8
62107: PUSH
62108: LD_INT 13
62110: PUSH
62111: LD_INT 12
62113: PUSH
62114: LD_INT 15
62116: PUSH
62117: LD_INT 11
62119: PUSH
62120: LD_INT 14
62122: PUSH
62123: LD_INT 10
62125: PUSH
62126: EMPTY
62127: LIST
62128: LIST
62129: LIST
62130: LIST
62131: LIST
62132: LIST
62133: LIST
62134: LIST
62135: LIST
62136: IN
62137: IFFALSE 62147
// btype = b_lab ;
62139: LD_ADDR_VAR 0 1
62143: PUSH
62144: LD_INT 6
62146: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62147: LD_VAR 0 6
62151: PUSH
62152: LD_INT 0
62154: PUSH
62155: LD_INT 1
62157: PUSH
62158: LD_INT 2
62160: PUSH
62161: EMPTY
62162: LIST
62163: LIST
62164: LIST
62165: IN
62166: NOT
62167: PUSH
62168: LD_VAR 0 1
62172: PUSH
62173: LD_INT 0
62175: PUSH
62176: LD_INT 1
62178: PUSH
62179: LD_INT 2
62181: PUSH
62182: LD_INT 3
62184: PUSH
62185: LD_INT 6
62187: PUSH
62188: LD_INT 36
62190: PUSH
62191: LD_INT 4
62193: PUSH
62194: LD_INT 5
62196: PUSH
62197: LD_INT 31
62199: PUSH
62200: LD_INT 32
62202: PUSH
62203: LD_INT 33
62205: PUSH
62206: EMPTY
62207: LIST
62208: LIST
62209: LIST
62210: LIST
62211: LIST
62212: LIST
62213: LIST
62214: LIST
62215: LIST
62216: LIST
62217: LIST
62218: IN
62219: NOT
62220: PUSH
62221: LD_VAR 0 6
62225: PUSH
62226: LD_INT 1
62228: EQUAL
62229: AND
62230: OR
62231: PUSH
62232: LD_VAR 0 1
62236: PUSH
62237: LD_INT 2
62239: PUSH
62240: LD_INT 3
62242: PUSH
62243: EMPTY
62244: LIST
62245: LIST
62246: IN
62247: NOT
62248: PUSH
62249: LD_VAR 0 6
62253: PUSH
62254: LD_INT 2
62256: EQUAL
62257: AND
62258: OR
62259: IFFALSE 62269
// mode = 0 ;
62261: LD_ADDR_VAR 0 6
62265: PUSH
62266: LD_INT 0
62268: ST_TO_ADDR
// case mode of 0 :
62269: LD_VAR 0 6
62273: PUSH
62274: LD_INT 0
62276: DOUBLE
62277: EQUAL
62278: IFTRUE 62282
62280: GO 73735
62282: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
62283: LD_ADDR_VAR 0 11
62287: PUSH
62288: LD_INT 0
62290: PUSH
62291: LD_INT 0
62293: PUSH
62294: EMPTY
62295: LIST
62296: LIST
62297: PUSH
62298: LD_INT 0
62300: PUSH
62301: LD_INT 1
62303: NEG
62304: PUSH
62305: EMPTY
62306: LIST
62307: LIST
62308: PUSH
62309: LD_INT 1
62311: PUSH
62312: LD_INT 0
62314: PUSH
62315: EMPTY
62316: LIST
62317: LIST
62318: PUSH
62319: LD_INT 1
62321: PUSH
62322: LD_INT 1
62324: PUSH
62325: EMPTY
62326: LIST
62327: LIST
62328: PUSH
62329: LD_INT 0
62331: PUSH
62332: LD_INT 1
62334: PUSH
62335: EMPTY
62336: LIST
62337: LIST
62338: PUSH
62339: LD_INT 1
62341: NEG
62342: PUSH
62343: LD_INT 0
62345: PUSH
62346: EMPTY
62347: LIST
62348: LIST
62349: PUSH
62350: LD_INT 1
62352: NEG
62353: PUSH
62354: LD_INT 1
62356: NEG
62357: PUSH
62358: EMPTY
62359: LIST
62360: LIST
62361: PUSH
62362: LD_INT 1
62364: NEG
62365: PUSH
62366: LD_INT 2
62368: NEG
62369: PUSH
62370: EMPTY
62371: LIST
62372: LIST
62373: PUSH
62374: LD_INT 0
62376: PUSH
62377: LD_INT 2
62379: NEG
62380: PUSH
62381: EMPTY
62382: LIST
62383: LIST
62384: PUSH
62385: LD_INT 1
62387: PUSH
62388: LD_INT 1
62390: NEG
62391: PUSH
62392: EMPTY
62393: LIST
62394: LIST
62395: PUSH
62396: LD_INT 1
62398: PUSH
62399: LD_INT 2
62401: PUSH
62402: EMPTY
62403: LIST
62404: LIST
62405: PUSH
62406: LD_INT 0
62408: PUSH
62409: LD_INT 2
62411: PUSH
62412: EMPTY
62413: LIST
62414: LIST
62415: PUSH
62416: LD_INT 1
62418: NEG
62419: PUSH
62420: LD_INT 1
62422: PUSH
62423: EMPTY
62424: LIST
62425: LIST
62426: PUSH
62427: LD_INT 1
62429: PUSH
62430: LD_INT 3
62432: PUSH
62433: EMPTY
62434: LIST
62435: LIST
62436: PUSH
62437: LD_INT 0
62439: PUSH
62440: LD_INT 3
62442: PUSH
62443: EMPTY
62444: LIST
62445: LIST
62446: PUSH
62447: LD_INT 1
62449: NEG
62450: PUSH
62451: LD_INT 2
62453: PUSH
62454: EMPTY
62455: LIST
62456: LIST
62457: PUSH
62458: EMPTY
62459: LIST
62460: LIST
62461: LIST
62462: LIST
62463: LIST
62464: LIST
62465: LIST
62466: LIST
62467: LIST
62468: LIST
62469: LIST
62470: LIST
62471: LIST
62472: LIST
62473: LIST
62474: LIST
62475: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
62476: LD_ADDR_VAR 0 12
62480: PUSH
62481: LD_INT 0
62483: PUSH
62484: LD_INT 0
62486: PUSH
62487: EMPTY
62488: LIST
62489: LIST
62490: PUSH
62491: LD_INT 0
62493: PUSH
62494: LD_INT 1
62496: NEG
62497: PUSH
62498: EMPTY
62499: LIST
62500: LIST
62501: PUSH
62502: LD_INT 1
62504: PUSH
62505: LD_INT 0
62507: PUSH
62508: EMPTY
62509: LIST
62510: LIST
62511: PUSH
62512: LD_INT 1
62514: PUSH
62515: LD_INT 1
62517: PUSH
62518: EMPTY
62519: LIST
62520: LIST
62521: PUSH
62522: LD_INT 0
62524: PUSH
62525: LD_INT 1
62527: PUSH
62528: EMPTY
62529: LIST
62530: LIST
62531: PUSH
62532: LD_INT 1
62534: NEG
62535: PUSH
62536: LD_INT 0
62538: PUSH
62539: EMPTY
62540: LIST
62541: LIST
62542: PUSH
62543: LD_INT 1
62545: NEG
62546: PUSH
62547: LD_INT 1
62549: NEG
62550: PUSH
62551: EMPTY
62552: LIST
62553: LIST
62554: PUSH
62555: LD_INT 1
62557: PUSH
62558: LD_INT 1
62560: NEG
62561: PUSH
62562: EMPTY
62563: LIST
62564: LIST
62565: PUSH
62566: LD_INT 2
62568: PUSH
62569: LD_INT 0
62571: PUSH
62572: EMPTY
62573: LIST
62574: LIST
62575: PUSH
62576: LD_INT 2
62578: PUSH
62579: LD_INT 1
62581: PUSH
62582: EMPTY
62583: LIST
62584: LIST
62585: PUSH
62586: LD_INT 1
62588: NEG
62589: PUSH
62590: LD_INT 1
62592: PUSH
62593: EMPTY
62594: LIST
62595: LIST
62596: PUSH
62597: LD_INT 2
62599: NEG
62600: PUSH
62601: LD_INT 0
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: PUSH
62608: LD_INT 2
62610: NEG
62611: PUSH
62612: LD_INT 1
62614: NEG
62615: PUSH
62616: EMPTY
62617: LIST
62618: LIST
62619: PUSH
62620: LD_INT 2
62622: NEG
62623: PUSH
62624: LD_INT 1
62626: PUSH
62627: EMPTY
62628: LIST
62629: LIST
62630: PUSH
62631: LD_INT 3
62633: NEG
62634: PUSH
62635: LD_INT 0
62637: PUSH
62638: EMPTY
62639: LIST
62640: LIST
62641: PUSH
62642: LD_INT 3
62644: NEG
62645: PUSH
62646: LD_INT 1
62648: NEG
62649: PUSH
62650: EMPTY
62651: LIST
62652: LIST
62653: PUSH
62654: EMPTY
62655: LIST
62656: LIST
62657: LIST
62658: LIST
62659: LIST
62660: LIST
62661: LIST
62662: LIST
62663: LIST
62664: LIST
62665: LIST
62666: LIST
62667: LIST
62668: LIST
62669: LIST
62670: LIST
62671: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
62672: LD_ADDR_VAR 0 13
62676: PUSH
62677: LD_INT 0
62679: PUSH
62680: LD_INT 0
62682: PUSH
62683: EMPTY
62684: LIST
62685: LIST
62686: PUSH
62687: LD_INT 0
62689: PUSH
62690: LD_INT 1
62692: NEG
62693: PUSH
62694: EMPTY
62695: LIST
62696: LIST
62697: PUSH
62698: LD_INT 1
62700: PUSH
62701: LD_INT 0
62703: PUSH
62704: EMPTY
62705: LIST
62706: LIST
62707: PUSH
62708: LD_INT 1
62710: PUSH
62711: LD_INT 1
62713: PUSH
62714: EMPTY
62715: LIST
62716: LIST
62717: PUSH
62718: LD_INT 0
62720: PUSH
62721: LD_INT 1
62723: PUSH
62724: EMPTY
62725: LIST
62726: LIST
62727: PUSH
62728: LD_INT 1
62730: NEG
62731: PUSH
62732: LD_INT 0
62734: PUSH
62735: EMPTY
62736: LIST
62737: LIST
62738: PUSH
62739: LD_INT 1
62741: NEG
62742: PUSH
62743: LD_INT 1
62745: NEG
62746: PUSH
62747: EMPTY
62748: LIST
62749: LIST
62750: PUSH
62751: LD_INT 1
62753: NEG
62754: PUSH
62755: LD_INT 2
62757: NEG
62758: PUSH
62759: EMPTY
62760: LIST
62761: LIST
62762: PUSH
62763: LD_INT 2
62765: PUSH
62766: LD_INT 1
62768: PUSH
62769: EMPTY
62770: LIST
62771: LIST
62772: PUSH
62773: LD_INT 2
62775: PUSH
62776: LD_INT 2
62778: PUSH
62779: EMPTY
62780: LIST
62781: LIST
62782: PUSH
62783: LD_INT 1
62785: PUSH
62786: LD_INT 2
62788: PUSH
62789: EMPTY
62790: LIST
62791: LIST
62792: PUSH
62793: LD_INT 2
62795: NEG
62796: PUSH
62797: LD_INT 1
62799: NEG
62800: PUSH
62801: EMPTY
62802: LIST
62803: LIST
62804: PUSH
62805: LD_INT 2
62807: NEG
62808: PUSH
62809: LD_INT 2
62811: NEG
62812: PUSH
62813: EMPTY
62814: LIST
62815: LIST
62816: PUSH
62817: LD_INT 2
62819: NEG
62820: PUSH
62821: LD_INT 3
62823: NEG
62824: PUSH
62825: EMPTY
62826: LIST
62827: LIST
62828: PUSH
62829: LD_INT 3
62831: NEG
62832: PUSH
62833: LD_INT 2
62835: NEG
62836: PUSH
62837: EMPTY
62838: LIST
62839: LIST
62840: PUSH
62841: LD_INT 3
62843: NEG
62844: PUSH
62845: LD_INT 3
62847: NEG
62848: PUSH
62849: EMPTY
62850: LIST
62851: LIST
62852: PUSH
62853: EMPTY
62854: LIST
62855: LIST
62856: LIST
62857: LIST
62858: LIST
62859: LIST
62860: LIST
62861: LIST
62862: LIST
62863: LIST
62864: LIST
62865: LIST
62866: LIST
62867: LIST
62868: LIST
62869: LIST
62870: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
62871: LD_ADDR_VAR 0 14
62875: PUSH
62876: LD_INT 0
62878: PUSH
62879: LD_INT 0
62881: PUSH
62882: EMPTY
62883: LIST
62884: LIST
62885: PUSH
62886: LD_INT 0
62888: PUSH
62889: LD_INT 1
62891: NEG
62892: PUSH
62893: EMPTY
62894: LIST
62895: LIST
62896: PUSH
62897: LD_INT 1
62899: PUSH
62900: LD_INT 0
62902: PUSH
62903: EMPTY
62904: LIST
62905: LIST
62906: PUSH
62907: LD_INT 1
62909: PUSH
62910: LD_INT 1
62912: PUSH
62913: EMPTY
62914: LIST
62915: LIST
62916: PUSH
62917: LD_INT 0
62919: PUSH
62920: LD_INT 1
62922: PUSH
62923: EMPTY
62924: LIST
62925: LIST
62926: PUSH
62927: LD_INT 1
62929: NEG
62930: PUSH
62931: LD_INT 0
62933: PUSH
62934: EMPTY
62935: LIST
62936: LIST
62937: PUSH
62938: LD_INT 1
62940: NEG
62941: PUSH
62942: LD_INT 1
62944: NEG
62945: PUSH
62946: EMPTY
62947: LIST
62948: LIST
62949: PUSH
62950: LD_INT 1
62952: NEG
62953: PUSH
62954: LD_INT 2
62956: NEG
62957: PUSH
62958: EMPTY
62959: LIST
62960: LIST
62961: PUSH
62962: LD_INT 0
62964: PUSH
62965: LD_INT 2
62967: NEG
62968: PUSH
62969: EMPTY
62970: LIST
62971: LIST
62972: PUSH
62973: LD_INT 1
62975: PUSH
62976: LD_INT 1
62978: NEG
62979: PUSH
62980: EMPTY
62981: LIST
62982: LIST
62983: PUSH
62984: LD_INT 1
62986: PUSH
62987: LD_INT 2
62989: PUSH
62990: EMPTY
62991: LIST
62992: LIST
62993: PUSH
62994: LD_INT 0
62996: PUSH
62997: LD_INT 2
62999: PUSH
63000: EMPTY
63001: LIST
63002: LIST
63003: PUSH
63004: LD_INT 1
63006: NEG
63007: PUSH
63008: LD_INT 1
63010: PUSH
63011: EMPTY
63012: LIST
63013: LIST
63014: PUSH
63015: LD_INT 1
63017: NEG
63018: PUSH
63019: LD_INT 3
63021: NEG
63022: PUSH
63023: EMPTY
63024: LIST
63025: LIST
63026: PUSH
63027: LD_INT 0
63029: PUSH
63030: LD_INT 3
63032: NEG
63033: PUSH
63034: EMPTY
63035: LIST
63036: LIST
63037: PUSH
63038: LD_INT 1
63040: PUSH
63041: LD_INT 2
63043: NEG
63044: PUSH
63045: EMPTY
63046: LIST
63047: LIST
63048: PUSH
63049: EMPTY
63050: LIST
63051: LIST
63052: LIST
63053: LIST
63054: LIST
63055: LIST
63056: LIST
63057: LIST
63058: LIST
63059: LIST
63060: LIST
63061: LIST
63062: LIST
63063: LIST
63064: LIST
63065: LIST
63066: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63067: LD_ADDR_VAR 0 15
63071: PUSH
63072: LD_INT 0
63074: PUSH
63075: LD_INT 0
63077: PUSH
63078: EMPTY
63079: LIST
63080: LIST
63081: PUSH
63082: LD_INT 0
63084: PUSH
63085: LD_INT 1
63087: NEG
63088: PUSH
63089: EMPTY
63090: LIST
63091: LIST
63092: PUSH
63093: LD_INT 1
63095: PUSH
63096: LD_INT 0
63098: PUSH
63099: EMPTY
63100: LIST
63101: LIST
63102: PUSH
63103: LD_INT 1
63105: PUSH
63106: LD_INT 1
63108: PUSH
63109: EMPTY
63110: LIST
63111: LIST
63112: PUSH
63113: LD_INT 0
63115: PUSH
63116: LD_INT 1
63118: PUSH
63119: EMPTY
63120: LIST
63121: LIST
63122: PUSH
63123: LD_INT 1
63125: NEG
63126: PUSH
63127: LD_INT 0
63129: PUSH
63130: EMPTY
63131: LIST
63132: LIST
63133: PUSH
63134: LD_INT 1
63136: NEG
63137: PUSH
63138: LD_INT 1
63140: NEG
63141: PUSH
63142: EMPTY
63143: LIST
63144: LIST
63145: PUSH
63146: LD_INT 1
63148: PUSH
63149: LD_INT 1
63151: NEG
63152: PUSH
63153: EMPTY
63154: LIST
63155: LIST
63156: PUSH
63157: LD_INT 2
63159: PUSH
63160: LD_INT 0
63162: PUSH
63163: EMPTY
63164: LIST
63165: LIST
63166: PUSH
63167: LD_INT 2
63169: PUSH
63170: LD_INT 1
63172: PUSH
63173: EMPTY
63174: LIST
63175: LIST
63176: PUSH
63177: LD_INT 1
63179: NEG
63180: PUSH
63181: LD_INT 1
63183: PUSH
63184: EMPTY
63185: LIST
63186: LIST
63187: PUSH
63188: LD_INT 2
63190: NEG
63191: PUSH
63192: LD_INT 0
63194: PUSH
63195: EMPTY
63196: LIST
63197: LIST
63198: PUSH
63199: LD_INT 2
63201: NEG
63202: PUSH
63203: LD_INT 1
63205: NEG
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: PUSH
63211: LD_INT 2
63213: PUSH
63214: LD_INT 1
63216: NEG
63217: PUSH
63218: EMPTY
63219: LIST
63220: LIST
63221: PUSH
63222: LD_INT 3
63224: PUSH
63225: LD_INT 0
63227: PUSH
63228: EMPTY
63229: LIST
63230: LIST
63231: PUSH
63232: LD_INT 3
63234: PUSH
63235: LD_INT 1
63237: PUSH
63238: EMPTY
63239: LIST
63240: LIST
63241: PUSH
63242: EMPTY
63243: LIST
63244: LIST
63245: LIST
63246: LIST
63247: LIST
63248: LIST
63249: LIST
63250: LIST
63251: LIST
63252: LIST
63253: LIST
63254: LIST
63255: LIST
63256: LIST
63257: LIST
63258: LIST
63259: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
63260: LD_ADDR_VAR 0 16
63264: PUSH
63265: LD_INT 0
63267: PUSH
63268: LD_INT 0
63270: PUSH
63271: EMPTY
63272: LIST
63273: LIST
63274: PUSH
63275: LD_INT 0
63277: PUSH
63278: LD_INT 1
63280: NEG
63281: PUSH
63282: EMPTY
63283: LIST
63284: LIST
63285: PUSH
63286: LD_INT 1
63288: PUSH
63289: LD_INT 0
63291: PUSH
63292: EMPTY
63293: LIST
63294: LIST
63295: PUSH
63296: LD_INT 1
63298: PUSH
63299: LD_INT 1
63301: PUSH
63302: EMPTY
63303: LIST
63304: LIST
63305: PUSH
63306: LD_INT 0
63308: PUSH
63309: LD_INT 1
63311: PUSH
63312: EMPTY
63313: LIST
63314: LIST
63315: PUSH
63316: LD_INT 1
63318: NEG
63319: PUSH
63320: LD_INT 0
63322: PUSH
63323: EMPTY
63324: LIST
63325: LIST
63326: PUSH
63327: LD_INT 1
63329: NEG
63330: PUSH
63331: LD_INT 1
63333: NEG
63334: PUSH
63335: EMPTY
63336: LIST
63337: LIST
63338: PUSH
63339: LD_INT 1
63341: NEG
63342: PUSH
63343: LD_INT 2
63345: NEG
63346: PUSH
63347: EMPTY
63348: LIST
63349: LIST
63350: PUSH
63351: LD_INT 2
63353: PUSH
63354: LD_INT 1
63356: PUSH
63357: EMPTY
63358: LIST
63359: LIST
63360: PUSH
63361: LD_INT 2
63363: PUSH
63364: LD_INT 2
63366: PUSH
63367: EMPTY
63368: LIST
63369: LIST
63370: PUSH
63371: LD_INT 1
63373: PUSH
63374: LD_INT 2
63376: PUSH
63377: EMPTY
63378: LIST
63379: LIST
63380: PUSH
63381: LD_INT 2
63383: NEG
63384: PUSH
63385: LD_INT 1
63387: NEG
63388: PUSH
63389: EMPTY
63390: LIST
63391: LIST
63392: PUSH
63393: LD_INT 2
63395: NEG
63396: PUSH
63397: LD_INT 2
63399: NEG
63400: PUSH
63401: EMPTY
63402: LIST
63403: LIST
63404: PUSH
63405: LD_INT 3
63407: PUSH
63408: LD_INT 2
63410: PUSH
63411: EMPTY
63412: LIST
63413: LIST
63414: PUSH
63415: LD_INT 3
63417: PUSH
63418: LD_INT 3
63420: PUSH
63421: EMPTY
63422: LIST
63423: LIST
63424: PUSH
63425: LD_INT 2
63427: PUSH
63428: LD_INT 3
63430: PUSH
63431: EMPTY
63432: LIST
63433: LIST
63434: PUSH
63435: EMPTY
63436: LIST
63437: LIST
63438: LIST
63439: LIST
63440: LIST
63441: LIST
63442: LIST
63443: LIST
63444: LIST
63445: LIST
63446: LIST
63447: LIST
63448: LIST
63449: LIST
63450: LIST
63451: LIST
63452: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63453: LD_ADDR_VAR 0 17
63457: PUSH
63458: LD_INT 0
63460: PUSH
63461: LD_INT 0
63463: PUSH
63464: EMPTY
63465: LIST
63466: LIST
63467: PUSH
63468: LD_INT 0
63470: PUSH
63471: LD_INT 1
63473: NEG
63474: PUSH
63475: EMPTY
63476: LIST
63477: LIST
63478: PUSH
63479: LD_INT 1
63481: PUSH
63482: LD_INT 0
63484: PUSH
63485: EMPTY
63486: LIST
63487: LIST
63488: PUSH
63489: LD_INT 1
63491: PUSH
63492: LD_INT 1
63494: PUSH
63495: EMPTY
63496: LIST
63497: LIST
63498: PUSH
63499: LD_INT 0
63501: PUSH
63502: LD_INT 1
63504: PUSH
63505: EMPTY
63506: LIST
63507: LIST
63508: PUSH
63509: LD_INT 1
63511: NEG
63512: PUSH
63513: LD_INT 0
63515: PUSH
63516: EMPTY
63517: LIST
63518: LIST
63519: PUSH
63520: LD_INT 1
63522: NEG
63523: PUSH
63524: LD_INT 1
63526: NEG
63527: PUSH
63528: EMPTY
63529: LIST
63530: LIST
63531: PUSH
63532: LD_INT 1
63534: NEG
63535: PUSH
63536: LD_INT 2
63538: NEG
63539: PUSH
63540: EMPTY
63541: LIST
63542: LIST
63543: PUSH
63544: LD_INT 0
63546: PUSH
63547: LD_INT 2
63549: NEG
63550: PUSH
63551: EMPTY
63552: LIST
63553: LIST
63554: PUSH
63555: LD_INT 1
63557: PUSH
63558: LD_INT 1
63560: NEG
63561: PUSH
63562: EMPTY
63563: LIST
63564: LIST
63565: PUSH
63566: LD_INT 2
63568: PUSH
63569: LD_INT 0
63571: PUSH
63572: EMPTY
63573: LIST
63574: LIST
63575: PUSH
63576: LD_INT 2
63578: PUSH
63579: LD_INT 1
63581: PUSH
63582: EMPTY
63583: LIST
63584: LIST
63585: PUSH
63586: LD_INT 2
63588: PUSH
63589: LD_INT 2
63591: PUSH
63592: EMPTY
63593: LIST
63594: LIST
63595: PUSH
63596: LD_INT 1
63598: PUSH
63599: LD_INT 2
63601: PUSH
63602: EMPTY
63603: LIST
63604: LIST
63605: PUSH
63606: LD_INT 0
63608: PUSH
63609: LD_INT 2
63611: PUSH
63612: EMPTY
63613: LIST
63614: LIST
63615: PUSH
63616: LD_INT 1
63618: NEG
63619: PUSH
63620: LD_INT 1
63622: PUSH
63623: EMPTY
63624: LIST
63625: LIST
63626: PUSH
63627: LD_INT 2
63629: NEG
63630: PUSH
63631: LD_INT 0
63633: PUSH
63634: EMPTY
63635: LIST
63636: LIST
63637: PUSH
63638: LD_INT 2
63640: NEG
63641: PUSH
63642: LD_INT 1
63644: NEG
63645: PUSH
63646: EMPTY
63647: LIST
63648: LIST
63649: PUSH
63650: LD_INT 2
63652: NEG
63653: PUSH
63654: LD_INT 2
63656: NEG
63657: PUSH
63658: EMPTY
63659: LIST
63660: LIST
63661: PUSH
63662: EMPTY
63663: LIST
63664: LIST
63665: LIST
63666: LIST
63667: LIST
63668: LIST
63669: LIST
63670: LIST
63671: LIST
63672: LIST
63673: LIST
63674: LIST
63675: LIST
63676: LIST
63677: LIST
63678: LIST
63679: LIST
63680: LIST
63681: LIST
63682: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63683: LD_ADDR_VAR 0 18
63687: PUSH
63688: LD_INT 0
63690: PUSH
63691: LD_INT 0
63693: PUSH
63694: EMPTY
63695: LIST
63696: LIST
63697: PUSH
63698: LD_INT 0
63700: PUSH
63701: LD_INT 1
63703: NEG
63704: PUSH
63705: EMPTY
63706: LIST
63707: LIST
63708: PUSH
63709: LD_INT 1
63711: PUSH
63712: LD_INT 0
63714: PUSH
63715: EMPTY
63716: LIST
63717: LIST
63718: PUSH
63719: LD_INT 1
63721: PUSH
63722: LD_INT 1
63724: PUSH
63725: EMPTY
63726: LIST
63727: LIST
63728: PUSH
63729: LD_INT 0
63731: PUSH
63732: LD_INT 1
63734: PUSH
63735: EMPTY
63736: LIST
63737: LIST
63738: PUSH
63739: LD_INT 1
63741: NEG
63742: PUSH
63743: LD_INT 0
63745: PUSH
63746: EMPTY
63747: LIST
63748: LIST
63749: PUSH
63750: LD_INT 1
63752: NEG
63753: PUSH
63754: LD_INT 1
63756: NEG
63757: PUSH
63758: EMPTY
63759: LIST
63760: LIST
63761: PUSH
63762: LD_INT 1
63764: NEG
63765: PUSH
63766: LD_INT 2
63768: NEG
63769: PUSH
63770: EMPTY
63771: LIST
63772: LIST
63773: PUSH
63774: LD_INT 0
63776: PUSH
63777: LD_INT 2
63779: NEG
63780: PUSH
63781: EMPTY
63782: LIST
63783: LIST
63784: PUSH
63785: LD_INT 1
63787: PUSH
63788: LD_INT 1
63790: NEG
63791: PUSH
63792: EMPTY
63793: LIST
63794: LIST
63795: PUSH
63796: LD_INT 2
63798: PUSH
63799: LD_INT 0
63801: PUSH
63802: EMPTY
63803: LIST
63804: LIST
63805: PUSH
63806: LD_INT 2
63808: PUSH
63809: LD_INT 1
63811: PUSH
63812: EMPTY
63813: LIST
63814: LIST
63815: PUSH
63816: LD_INT 2
63818: PUSH
63819: LD_INT 2
63821: PUSH
63822: EMPTY
63823: LIST
63824: LIST
63825: PUSH
63826: LD_INT 1
63828: PUSH
63829: LD_INT 2
63831: PUSH
63832: EMPTY
63833: LIST
63834: LIST
63835: PUSH
63836: LD_INT 0
63838: PUSH
63839: LD_INT 2
63841: PUSH
63842: EMPTY
63843: LIST
63844: LIST
63845: PUSH
63846: LD_INT 1
63848: NEG
63849: PUSH
63850: LD_INT 1
63852: PUSH
63853: EMPTY
63854: LIST
63855: LIST
63856: PUSH
63857: LD_INT 2
63859: NEG
63860: PUSH
63861: LD_INT 0
63863: PUSH
63864: EMPTY
63865: LIST
63866: LIST
63867: PUSH
63868: LD_INT 2
63870: NEG
63871: PUSH
63872: LD_INT 1
63874: NEG
63875: PUSH
63876: EMPTY
63877: LIST
63878: LIST
63879: PUSH
63880: LD_INT 2
63882: NEG
63883: PUSH
63884: LD_INT 2
63886: NEG
63887: PUSH
63888: EMPTY
63889: LIST
63890: LIST
63891: PUSH
63892: EMPTY
63893: LIST
63894: LIST
63895: LIST
63896: LIST
63897: LIST
63898: LIST
63899: LIST
63900: LIST
63901: LIST
63902: LIST
63903: LIST
63904: LIST
63905: LIST
63906: LIST
63907: LIST
63908: LIST
63909: LIST
63910: LIST
63911: LIST
63912: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63913: LD_ADDR_VAR 0 19
63917: PUSH
63918: LD_INT 0
63920: PUSH
63921: LD_INT 0
63923: PUSH
63924: EMPTY
63925: LIST
63926: LIST
63927: PUSH
63928: LD_INT 0
63930: PUSH
63931: LD_INT 1
63933: NEG
63934: PUSH
63935: EMPTY
63936: LIST
63937: LIST
63938: PUSH
63939: LD_INT 1
63941: PUSH
63942: LD_INT 0
63944: PUSH
63945: EMPTY
63946: LIST
63947: LIST
63948: PUSH
63949: LD_INT 1
63951: PUSH
63952: LD_INT 1
63954: PUSH
63955: EMPTY
63956: LIST
63957: LIST
63958: PUSH
63959: LD_INT 0
63961: PUSH
63962: LD_INT 1
63964: PUSH
63965: EMPTY
63966: LIST
63967: LIST
63968: PUSH
63969: LD_INT 1
63971: NEG
63972: PUSH
63973: LD_INT 0
63975: PUSH
63976: EMPTY
63977: LIST
63978: LIST
63979: PUSH
63980: LD_INT 1
63982: NEG
63983: PUSH
63984: LD_INT 1
63986: NEG
63987: PUSH
63988: EMPTY
63989: LIST
63990: LIST
63991: PUSH
63992: LD_INT 1
63994: NEG
63995: PUSH
63996: LD_INT 2
63998: NEG
63999: PUSH
64000: EMPTY
64001: LIST
64002: LIST
64003: PUSH
64004: LD_INT 0
64006: PUSH
64007: LD_INT 2
64009: NEG
64010: PUSH
64011: EMPTY
64012: LIST
64013: LIST
64014: PUSH
64015: LD_INT 1
64017: PUSH
64018: LD_INT 1
64020: NEG
64021: PUSH
64022: EMPTY
64023: LIST
64024: LIST
64025: PUSH
64026: LD_INT 2
64028: PUSH
64029: LD_INT 0
64031: PUSH
64032: EMPTY
64033: LIST
64034: LIST
64035: PUSH
64036: LD_INT 2
64038: PUSH
64039: LD_INT 1
64041: PUSH
64042: EMPTY
64043: LIST
64044: LIST
64045: PUSH
64046: LD_INT 2
64048: PUSH
64049: LD_INT 2
64051: PUSH
64052: EMPTY
64053: LIST
64054: LIST
64055: PUSH
64056: LD_INT 1
64058: PUSH
64059: LD_INT 2
64061: PUSH
64062: EMPTY
64063: LIST
64064: LIST
64065: PUSH
64066: LD_INT 0
64068: PUSH
64069: LD_INT 2
64071: PUSH
64072: EMPTY
64073: LIST
64074: LIST
64075: PUSH
64076: LD_INT 1
64078: NEG
64079: PUSH
64080: LD_INT 1
64082: PUSH
64083: EMPTY
64084: LIST
64085: LIST
64086: PUSH
64087: LD_INT 2
64089: NEG
64090: PUSH
64091: LD_INT 0
64093: PUSH
64094: EMPTY
64095: LIST
64096: LIST
64097: PUSH
64098: LD_INT 2
64100: NEG
64101: PUSH
64102: LD_INT 1
64104: NEG
64105: PUSH
64106: EMPTY
64107: LIST
64108: LIST
64109: PUSH
64110: LD_INT 2
64112: NEG
64113: PUSH
64114: LD_INT 2
64116: NEG
64117: PUSH
64118: EMPTY
64119: LIST
64120: LIST
64121: PUSH
64122: EMPTY
64123: LIST
64124: LIST
64125: LIST
64126: LIST
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: LIST
64136: LIST
64137: LIST
64138: LIST
64139: LIST
64140: LIST
64141: LIST
64142: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64143: LD_ADDR_VAR 0 20
64147: PUSH
64148: LD_INT 0
64150: PUSH
64151: LD_INT 0
64153: PUSH
64154: EMPTY
64155: LIST
64156: LIST
64157: PUSH
64158: LD_INT 0
64160: PUSH
64161: LD_INT 1
64163: NEG
64164: PUSH
64165: EMPTY
64166: LIST
64167: LIST
64168: PUSH
64169: LD_INT 1
64171: PUSH
64172: LD_INT 0
64174: PUSH
64175: EMPTY
64176: LIST
64177: LIST
64178: PUSH
64179: LD_INT 1
64181: PUSH
64182: LD_INT 1
64184: PUSH
64185: EMPTY
64186: LIST
64187: LIST
64188: PUSH
64189: LD_INT 0
64191: PUSH
64192: LD_INT 1
64194: PUSH
64195: EMPTY
64196: LIST
64197: LIST
64198: PUSH
64199: LD_INT 1
64201: NEG
64202: PUSH
64203: LD_INT 0
64205: PUSH
64206: EMPTY
64207: LIST
64208: LIST
64209: PUSH
64210: LD_INT 1
64212: NEG
64213: PUSH
64214: LD_INT 1
64216: NEG
64217: PUSH
64218: EMPTY
64219: LIST
64220: LIST
64221: PUSH
64222: LD_INT 1
64224: NEG
64225: PUSH
64226: LD_INT 2
64228: NEG
64229: PUSH
64230: EMPTY
64231: LIST
64232: LIST
64233: PUSH
64234: LD_INT 0
64236: PUSH
64237: LD_INT 2
64239: NEG
64240: PUSH
64241: EMPTY
64242: LIST
64243: LIST
64244: PUSH
64245: LD_INT 1
64247: PUSH
64248: LD_INT 1
64250: NEG
64251: PUSH
64252: EMPTY
64253: LIST
64254: LIST
64255: PUSH
64256: LD_INT 2
64258: PUSH
64259: LD_INT 0
64261: PUSH
64262: EMPTY
64263: LIST
64264: LIST
64265: PUSH
64266: LD_INT 2
64268: PUSH
64269: LD_INT 1
64271: PUSH
64272: EMPTY
64273: LIST
64274: LIST
64275: PUSH
64276: LD_INT 2
64278: PUSH
64279: LD_INT 2
64281: PUSH
64282: EMPTY
64283: LIST
64284: LIST
64285: PUSH
64286: LD_INT 1
64288: PUSH
64289: LD_INT 2
64291: PUSH
64292: EMPTY
64293: LIST
64294: LIST
64295: PUSH
64296: LD_INT 0
64298: PUSH
64299: LD_INT 2
64301: PUSH
64302: EMPTY
64303: LIST
64304: LIST
64305: PUSH
64306: LD_INT 1
64308: NEG
64309: PUSH
64310: LD_INT 1
64312: PUSH
64313: EMPTY
64314: LIST
64315: LIST
64316: PUSH
64317: LD_INT 2
64319: NEG
64320: PUSH
64321: LD_INT 0
64323: PUSH
64324: EMPTY
64325: LIST
64326: LIST
64327: PUSH
64328: LD_INT 2
64330: NEG
64331: PUSH
64332: LD_INT 1
64334: NEG
64335: PUSH
64336: EMPTY
64337: LIST
64338: LIST
64339: PUSH
64340: LD_INT 2
64342: NEG
64343: PUSH
64344: LD_INT 2
64346: NEG
64347: PUSH
64348: EMPTY
64349: LIST
64350: LIST
64351: PUSH
64352: EMPTY
64353: LIST
64354: LIST
64355: LIST
64356: LIST
64357: LIST
64358: LIST
64359: LIST
64360: LIST
64361: LIST
64362: LIST
64363: LIST
64364: LIST
64365: LIST
64366: LIST
64367: LIST
64368: LIST
64369: LIST
64370: LIST
64371: LIST
64372: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64373: LD_ADDR_VAR 0 21
64377: PUSH
64378: LD_INT 0
64380: PUSH
64381: LD_INT 0
64383: PUSH
64384: EMPTY
64385: LIST
64386: LIST
64387: PUSH
64388: LD_INT 0
64390: PUSH
64391: LD_INT 1
64393: NEG
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: PUSH
64399: LD_INT 1
64401: PUSH
64402: LD_INT 0
64404: PUSH
64405: EMPTY
64406: LIST
64407: LIST
64408: PUSH
64409: LD_INT 1
64411: PUSH
64412: LD_INT 1
64414: PUSH
64415: EMPTY
64416: LIST
64417: LIST
64418: PUSH
64419: LD_INT 0
64421: PUSH
64422: LD_INT 1
64424: PUSH
64425: EMPTY
64426: LIST
64427: LIST
64428: PUSH
64429: LD_INT 1
64431: NEG
64432: PUSH
64433: LD_INT 0
64435: PUSH
64436: EMPTY
64437: LIST
64438: LIST
64439: PUSH
64440: LD_INT 1
64442: NEG
64443: PUSH
64444: LD_INT 1
64446: NEG
64447: PUSH
64448: EMPTY
64449: LIST
64450: LIST
64451: PUSH
64452: LD_INT 1
64454: NEG
64455: PUSH
64456: LD_INT 2
64458: NEG
64459: PUSH
64460: EMPTY
64461: LIST
64462: LIST
64463: PUSH
64464: LD_INT 0
64466: PUSH
64467: LD_INT 2
64469: NEG
64470: PUSH
64471: EMPTY
64472: LIST
64473: LIST
64474: PUSH
64475: LD_INT 1
64477: PUSH
64478: LD_INT 1
64480: NEG
64481: PUSH
64482: EMPTY
64483: LIST
64484: LIST
64485: PUSH
64486: LD_INT 2
64488: PUSH
64489: LD_INT 0
64491: PUSH
64492: EMPTY
64493: LIST
64494: LIST
64495: PUSH
64496: LD_INT 2
64498: PUSH
64499: LD_INT 1
64501: PUSH
64502: EMPTY
64503: LIST
64504: LIST
64505: PUSH
64506: LD_INT 2
64508: PUSH
64509: LD_INT 2
64511: PUSH
64512: EMPTY
64513: LIST
64514: LIST
64515: PUSH
64516: LD_INT 1
64518: PUSH
64519: LD_INT 2
64521: PUSH
64522: EMPTY
64523: LIST
64524: LIST
64525: PUSH
64526: LD_INT 0
64528: PUSH
64529: LD_INT 2
64531: PUSH
64532: EMPTY
64533: LIST
64534: LIST
64535: PUSH
64536: LD_INT 1
64538: NEG
64539: PUSH
64540: LD_INT 1
64542: PUSH
64543: EMPTY
64544: LIST
64545: LIST
64546: PUSH
64547: LD_INT 2
64549: NEG
64550: PUSH
64551: LD_INT 0
64553: PUSH
64554: EMPTY
64555: LIST
64556: LIST
64557: PUSH
64558: LD_INT 2
64560: NEG
64561: PUSH
64562: LD_INT 1
64564: NEG
64565: PUSH
64566: EMPTY
64567: LIST
64568: LIST
64569: PUSH
64570: LD_INT 2
64572: NEG
64573: PUSH
64574: LD_INT 2
64576: NEG
64577: PUSH
64578: EMPTY
64579: LIST
64580: LIST
64581: PUSH
64582: EMPTY
64583: LIST
64584: LIST
64585: LIST
64586: LIST
64587: LIST
64588: LIST
64589: LIST
64590: LIST
64591: LIST
64592: LIST
64593: LIST
64594: LIST
64595: LIST
64596: LIST
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: LIST
64602: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64603: LD_ADDR_VAR 0 22
64607: PUSH
64608: LD_INT 0
64610: PUSH
64611: LD_INT 0
64613: PUSH
64614: EMPTY
64615: LIST
64616: LIST
64617: PUSH
64618: LD_INT 0
64620: PUSH
64621: LD_INT 1
64623: NEG
64624: PUSH
64625: EMPTY
64626: LIST
64627: LIST
64628: PUSH
64629: LD_INT 1
64631: PUSH
64632: LD_INT 0
64634: PUSH
64635: EMPTY
64636: LIST
64637: LIST
64638: PUSH
64639: LD_INT 1
64641: PUSH
64642: LD_INT 1
64644: PUSH
64645: EMPTY
64646: LIST
64647: LIST
64648: PUSH
64649: LD_INT 0
64651: PUSH
64652: LD_INT 1
64654: PUSH
64655: EMPTY
64656: LIST
64657: LIST
64658: PUSH
64659: LD_INT 1
64661: NEG
64662: PUSH
64663: LD_INT 0
64665: PUSH
64666: EMPTY
64667: LIST
64668: LIST
64669: PUSH
64670: LD_INT 1
64672: NEG
64673: PUSH
64674: LD_INT 1
64676: NEG
64677: PUSH
64678: EMPTY
64679: LIST
64680: LIST
64681: PUSH
64682: LD_INT 1
64684: NEG
64685: PUSH
64686: LD_INT 2
64688: NEG
64689: PUSH
64690: EMPTY
64691: LIST
64692: LIST
64693: PUSH
64694: LD_INT 0
64696: PUSH
64697: LD_INT 2
64699: NEG
64700: PUSH
64701: EMPTY
64702: LIST
64703: LIST
64704: PUSH
64705: LD_INT 1
64707: PUSH
64708: LD_INT 1
64710: NEG
64711: PUSH
64712: EMPTY
64713: LIST
64714: LIST
64715: PUSH
64716: LD_INT 2
64718: PUSH
64719: LD_INT 0
64721: PUSH
64722: EMPTY
64723: LIST
64724: LIST
64725: PUSH
64726: LD_INT 2
64728: PUSH
64729: LD_INT 1
64731: PUSH
64732: EMPTY
64733: LIST
64734: LIST
64735: PUSH
64736: LD_INT 2
64738: PUSH
64739: LD_INT 2
64741: PUSH
64742: EMPTY
64743: LIST
64744: LIST
64745: PUSH
64746: LD_INT 1
64748: PUSH
64749: LD_INT 2
64751: PUSH
64752: EMPTY
64753: LIST
64754: LIST
64755: PUSH
64756: LD_INT 0
64758: PUSH
64759: LD_INT 2
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: PUSH
64766: LD_INT 1
64768: NEG
64769: PUSH
64770: LD_INT 1
64772: PUSH
64773: EMPTY
64774: LIST
64775: LIST
64776: PUSH
64777: LD_INT 2
64779: NEG
64780: PUSH
64781: LD_INT 0
64783: PUSH
64784: EMPTY
64785: LIST
64786: LIST
64787: PUSH
64788: LD_INT 2
64790: NEG
64791: PUSH
64792: LD_INT 1
64794: NEG
64795: PUSH
64796: EMPTY
64797: LIST
64798: LIST
64799: PUSH
64800: LD_INT 2
64802: NEG
64803: PUSH
64804: LD_INT 2
64806: NEG
64807: PUSH
64808: EMPTY
64809: LIST
64810: LIST
64811: PUSH
64812: EMPTY
64813: LIST
64814: LIST
64815: LIST
64816: LIST
64817: LIST
64818: LIST
64819: LIST
64820: LIST
64821: LIST
64822: LIST
64823: LIST
64824: LIST
64825: LIST
64826: LIST
64827: LIST
64828: LIST
64829: LIST
64830: LIST
64831: LIST
64832: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
64833: LD_ADDR_VAR 0 23
64837: PUSH
64838: LD_INT 0
64840: PUSH
64841: LD_INT 0
64843: PUSH
64844: EMPTY
64845: LIST
64846: LIST
64847: PUSH
64848: LD_INT 0
64850: PUSH
64851: LD_INT 1
64853: NEG
64854: PUSH
64855: EMPTY
64856: LIST
64857: LIST
64858: PUSH
64859: LD_INT 1
64861: PUSH
64862: LD_INT 0
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: PUSH
64869: LD_INT 1
64871: PUSH
64872: LD_INT 1
64874: PUSH
64875: EMPTY
64876: LIST
64877: LIST
64878: PUSH
64879: LD_INT 0
64881: PUSH
64882: LD_INT 1
64884: PUSH
64885: EMPTY
64886: LIST
64887: LIST
64888: PUSH
64889: LD_INT 1
64891: NEG
64892: PUSH
64893: LD_INT 0
64895: PUSH
64896: EMPTY
64897: LIST
64898: LIST
64899: PUSH
64900: LD_INT 1
64902: NEG
64903: PUSH
64904: LD_INT 1
64906: NEG
64907: PUSH
64908: EMPTY
64909: LIST
64910: LIST
64911: PUSH
64912: LD_INT 1
64914: NEG
64915: PUSH
64916: LD_INT 2
64918: NEG
64919: PUSH
64920: EMPTY
64921: LIST
64922: LIST
64923: PUSH
64924: LD_INT 0
64926: PUSH
64927: LD_INT 2
64929: NEG
64930: PUSH
64931: EMPTY
64932: LIST
64933: LIST
64934: PUSH
64935: LD_INT 1
64937: PUSH
64938: LD_INT 1
64940: NEG
64941: PUSH
64942: EMPTY
64943: LIST
64944: LIST
64945: PUSH
64946: LD_INT 2
64948: PUSH
64949: LD_INT 0
64951: PUSH
64952: EMPTY
64953: LIST
64954: LIST
64955: PUSH
64956: LD_INT 2
64958: PUSH
64959: LD_INT 1
64961: PUSH
64962: EMPTY
64963: LIST
64964: LIST
64965: PUSH
64966: LD_INT 2
64968: PUSH
64969: LD_INT 2
64971: PUSH
64972: EMPTY
64973: LIST
64974: LIST
64975: PUSH
64976: LD_INT 1
64978: PUSH
64979: LD_INT 2
64981: PUSH
64982: EMPTY
64983: LIST
64984: LIST
64985: PUSH
64986: LD_INT 0
64988: PUSH
64989: LD_INT 2
64991: PUSH
64992: EMPTY
64993: LIST
64994: LIST
64995: PUSH
64996: LD_INT 1
64998: NEG
64999: PUSH
65000: LD_INT 1
65002: PUSH
65003: EMPTY
65004: LIST
65005: LIST
65006: PUSH
65007: LD_INT 2
65009: NEG
65010: PUSH
65011: LD_INT 0
65013: PUSH
65014: EMPTY
65015: LIST
65016: LIST
65017: PUSH
65018: LD_INT 2
65020: NEG
65021: PUSH
65022: LD_INT 1
65024: NEG
65025: PUSH
65026: EMPTY
65027: LIST
65028: LIST
65029: PUSH
65030: LD_INT 2
65032: NEG
65033: PUSH
65034: LD_INT 2
65036: NEG
65037: PUSH
65038: EMPTY
65039: LIST
65040: LIST
65041: PUSH
65042: LD_INT 2
65044: NEG
65045: PUSH
65046: LD_INT 3
65048: NEG
65049: PUSH
65050: EMPTY
65051: LIST
65052: LIST
65053: PUSH
65054: LD_INT 1
65056: NEG
65057: PUSH
65058: LD_INT 3
65060: NEG
65061: PUSH
65062: EMPTY
65063: LIST
65064: LIST
65065: PUSH
65066: LD_INT 1
65068: PUSH
65069: LD_INT 2
65071: NEG
65072: PUSH
65073: EMPTY
65074: LIST
65075: LIST
65076: PUSH
65077: LD_INT 2
65079: PUSH
65080: LD_INT 1
65082: NEG
65083: PUSH
65084: EMPTY
65085: LIST
65086: LIST
65087: PUSH
65088: EMPTY
65089: LIST
65090: LIST
65091: LIST
65092: LIST
65093: LIST
65094: LIST
65095: LIST
65096: LIST
65097: LIST
65098: LIST
65099: LIST
65100: LIST
65101: LIST
65102: LIST
65103: LIST
65104: LIST
65105: LIST
65106: LIST
65107: LIST
65108: LIST
65109: LIST
65110: LIST
65111: LIST
65112: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65113: LD_ADDR_VAR 0 24
65117: PUSH
65118: LD_INT 0
65120: PUSH
65121: LD_INT 0
65123: PUSH
65124: EMPTY
65125: LIST
65126: LIST
65127: PUSH
65128: LD_INT 0
65130: PUSH
65131: LD_INT 1
65133: NEG
65134: PUSH
65135: EMPTY
65136: LIST
65137: LIST
65138: PUSH
65139: LD_INT 1
65141: PUSH
65142: LD_INT 0
65144: PUSH
65145: EMPTY
65146: LIST
65147: LIST
65148: PUSH
65149: LD_INT 1
65151: PUSH
65152: LD_INT 1
65154: PUSH
65155: EMPTY
65156: LIST
65157: LIST
65158: PUSH
65159: LD_INT 0
65161: PUSH
65162: LD_INT 1
65164: PUSH
65165: EMPTY
65166: LIST
65167: LIST
65168: PUSH
65169: LD_INT 1
65171: NEG
65172: PUSH
65173: LD_INT 0
65175: PUSH
65176: EMPTY
65177: LIST
65178: LIST
65179: PUSH
65180: LD_INT 1
65182: NEG
65183: PUSH
65184: LD_INT 1
65186: NEG
65187: PUSH
65188: EMPTY
65189: LIST
65190: LIST
65191: PUSH
65192: LD_INT 1
65194: NEG
65195: PUSH
65196: LD_INT 2
65198: NEG
65199: PUSH
65200: EMPTY
65201: LIST
65202: LIST
65203: PUSH
65204: LD_INT 0
65206: PUSH
65207: LD_INT 2
65209: NEG
65210: PUSH
65211: EMPTY
65212: LIST
65213: LIST
65214: PUSH
65215: LD_INT 1
65217: PUSH
65218: LD_INT 1
65220: NEG
65221: PUSH
65222: EMPTY
65223: LIST
65224: LIST
65225: PUSH
65226: LD_INT 2
65228: PUSH
65229: LD_INT 0
65231: PUSH
65232: EMPTY
65233: LIST
65234: LIST
65235: PUSH
65236: LD_INT 2
65238: PUSH
65239: LD_INT 1
65241: PUSH
65242: EMPTY
65243: LIST
65244: LIST
65245: PUSH
65246: LD_INT 2
65248: PUSH
65249: LD_INT 2
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: PUSH
65256: LD_INT 1
65258: PUSH
65259: LD_INT 2
65261: PUSH
65262: EMPTY
65263: LIST
65264: LIST
65265: PUSH
65266: LD_INT 0
65268: PUSH
65269: LD_INT 2
65271: PUSH
65272: EMPTY
65273: LIST
65274: LIST
65275: PUSH
65276: LD_INT 1
65278: NEG
65279: PUSH
65280: LD_INT 1
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: LD_INT 2
65289: NEG
65290: PUSH
65291: LD_INT 0
65293: PUSH
65294: EMPTY
65295: LIST
65296: LIST
65297: PUSH
65298: LD_INT 2
65300: NEG
65301: PUSH
65302: LD_INT 1
65304: NEG
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: PUSH
65310: LD_INT 2
65312: NEG
65313: PUSH
65314: LD_INT 2
65316: NEG
65317: PUSH
65318: EMPTY
65319: LIST
65320: LIST
65321: PUSH
65322: LD_INT 1
65324: PUSH
65325: LD_INT 2
65327: NEG
65328: PUSH
65329: EMPTY
65330: LIST
65331: LIST
65332: PUSH
65333: LD_INT 2
65335: PUSH
65336: LD_INT 1
65338: NEG
65339: PUSH
65340: EMPTY
65341: LIST
65342: LIST
65343: PUSH
65344: LD_INT 3
65346: PUSH
65347: LD_INT 1
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: PUSH
65354: LD_INT 3
65356: PUSH
65357: LD_INT 2
65359: PUSH
65360: EMPTY
65361: LIST
65362: LIST
65363: PUSH
65364: EMPTY
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
65389: LD_ADDR_VAR 0 25
65393: PUSH
65394: LD_INT 0
65396: PUSH
65397: LD_INT 0
65399: PUSH
65400: EMPTY
65401: LIST
65402: LIST
65403: PUSH
65404: LD_INT 0
65406: PUSH
65407: LD_INT 1
65409: NEG
65410: PUSH
65411: EMPTY
65412: LIST
65413: LIST
65414: PUSH
65415: LD_INT 1
65417: PUSH
65418: LD_INT 0
65420: PUSH
65421: EMPTY
65422: LIST
65423: LIST
65424: PUSH
65425: LD_INT 1
65427: PUSH
65428: LD_INT 1
65430: PUSH
65431: EMPTY
65432: LIST
65433: LIST
65434: PUSH
65435: LD_INT 0
65437: PUSH
65438: LD_INT 1
65440: PUSH
65441: EMPTY
65442: LIST
65443: LIST
65444: PUSH
65445: LD_INT 1
65447: NEG
65448: PUSH
65449: LD_INT 0
65451: PUSH
65452: EMPTY
65453: LIST
65454: LIST
65455: PUSH
65456: LD_INT 1
65458: NEG
65459: PUSH
65460: LD_INT 1
65462: NEG
65463: PUSH
65464: EMPTY
65465: LIST
65466: LIST
65467: PUSH
65468: LD_INT 1
65470: NEG
65471: PUSH
65472: LD_INT 2
65474: NEG
65475: PUSH
65476: EMPTY
65477: LIST
65478: LIST
65479: PUSH
65480: LD_INT 0
65482: PUSH
65483: LD_INT 2
65485: NEG
65486: PUSH
65487: EMPTY
65488: LIST
65489: LIST
65490: PUSH
65491: LD_INT 1
65493: PUSH
65494: LD_INT 1
65496: NEG
65497: PUSH
65498: EMPTY
65499: LIST
65500: LIST
65501: PUSH
65502: LD_INT 2
65504: PUSH
65505: LD_INT 0
65507: PUSH
65508: EMPTY
65509: LIST
65510: LIST
65511: PUSH
65512: LD_INT 2
65514: PUSH
65515: LD_INT 1
65517: PUSH
65518: EMPTY
65519: LIST
65520: LIST
65521: PUSH
65522: LD_INT 2
65524: PUSH
65525: LD_INT 2
65527: PUSH
65528: EMPTY
65529: LIST
65530: LIST
65531: PUSH
65532: LD_INT 1
65534: PUSH
65535: LD_INT 2
65537: PUSH
65538: EMPTY
65539: LIST
65540: LIST
65541: PUSH
65542: LD_INT 0
65544: PUSH
65545: LD_INT 2
65547: PUSH
65548: EMPTY
65549: LIST
65550: LIST
65551: PUSH
65552: LD_INT 1
65554: NEG
65555: PUSH
65556: LD_INT 1
65558: PUSH
65559: EMPTY
65560: LIST
65561: LIST
65562: PUSH
65563: LD_INT 2
65565: NEG
65566: PUSH
65567: LD_INT 0
65569: PUSH
65570: EMPTY
65571: LIST
65572: LIST
65573: PUSH
65574: LD_INT 2
65576: NEG
65577: PUSH
65578: LD_INT 1
65580: NEG
65581: PUSH
65582: EMPTY
65583: LIST
65584: LIST
65585: PUSH
65586: LD_INT 2
65588: NEG
65589: PUSH
65590: LD_INT 2
65592: NEG
65593: PUSH
65594: EMPTY
65595: LIST
65596: LIST
65597: PUSH
65598: LD_INT 3
65600: PUSH
65601: LD_INT 1
65603: PUSH
65604: EMPTY
65605: LIST
65606: LIST
65607: PUSH
65608: LD_INT 3
65610: PUSH
65611: LD_INT 2
65613: PUSH
65614: EMPTY
65615: LIST
65616: LIST
65617: PUSH
65618: LD_INT 2
65620: PUSH
65621: LD_INT 3
65623: PUSH
65624: EMPTY
65625: LIST
65626: LIST
65627: PUSH
65628: LD_INT 1
65630: PUSH
65631: LD_INT 3
65633: PUSH
65634: EMPTY
65635: LIST
65636: LIST
65637: PUSH
65638: EMPTY
65639: LIST
65640: LIST
65641: LIST
65642: LIST
65643: LIST
65644: LIST
65645: LIST
65646: LIST
65647: LIST
65648: LIST
65649: LIST
65650: LIST
65651: LIST
65652: LIST
65653: LIST
65654: LIST
65655: LIST
65656: LIST
65657: LIST
65658: LIST
65659: LIST
65660: LIST
65661: LIST
65662: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
65663: LD_ADDR_VAR 0 26
65667: PUSH
65668: LD_INT 0
65670: PUSH
65671: LD_INT 0
65673: PUSH
65674: EMPTY
65675: LIST
65676: LIST
65677: PUSH
65678: LD_INT 0
65680: PUSH
65681: LD_INT 1
65683: NEG
65684: PUSH
65685: EMPTY
65686: LIST
65687: LIST
65688: PUSH
65689: LD_INT 1
65691: PUSH
65692: LD_INT 0
65694: PUSH
65695: EMPTY
65696: LIST
65697: LIST
65698: PUSH
65699: LD_INT 1
65701: PUSH
65702: LD_INT 1
65704: PUSH
65705: EMPTY
65706: LIST
65707: LIST
65708: PUSH
65709: LD_INT 0
65711: PUSH
65712: LD_INT 1
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PUSH
65719: LD_INT 1
65721: NEG
65722: PUSH
65723: LD_INT 0
65725: PUSH
65726: EMPTY
65727: LIST
65728: LIST
65729: PUSH
65730: LD_INT 1
65732: NEG
65733: PUSH
65734: LD_INT 1
65736: NEG
65737: PUSH
65738: EMPTY
65739: LIST
65740: LIST
65741: PUSH
65742: LD_INT 1
65744: NEG
65745: PUSH
65746: LD_INT 2
65748: NEG
65749: PUSH
65750: EMPTY
65751: LIST
65752: LIST
65753: PUSH
65754: LD_INT 0
65756: PUSH
65757: LD_INT 2
65759: NEG
65760: PUSH
65761: EMPTY
65762: LIST
65763: LIST
65764: PUSH
65765: LD_INT 1
65767: PUSH
65768: LD_INT 1
65770: NEG
65771: PUSH
65772: EMPTY
65773: LIST
65774: LIST
65775: PUSH
65776: LD_INT 2
65778: PUSH
65779: LD_INT 0
65781: PUSH
65782: EMPTY
65783: LIST
65784: LIST
65785: PUSH
65786: LD_INT 2
65788: PUSH
65789: LD_INT 1
65791: PUSH
65792: EMPTY
65793: LIST
65794: LIST
65795: PUSH
65796: LD_INT 2
65798: PUSH
65799: LD_INT 2
65801: PUSH
65802: EMPTY
65803: LIST
65804: LIST
65805: PUSH
65806: LD_INT 1
65808: PUSH
65809: LD_INT 2
65811: PUSH
65812: EMPTY
65813: LIST
65814: LIST
65815: PUSH
65816: LD_INT 0
65818: PUSH
65819: LD_INT 2
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: PUSH
65826: LD_INT 1
65828: NEG
65829: PUSH
65830: LD_INT 1
65832: PUSH
65833: EMPTY
65834: LIST
65835: LIST
65836: PUSH
65837: LD_INT 2
65839: NEG
65840: PUSH
65841: LD_INT 0
65843: PUSH
65844: EMPTY
65845: LIST
65846: LIST
65847: PUSH
65848: LD_INT 2
65850: NEG
65851: PUSH
65852: LD_INT 1
65854: NEG
65855: PUSH
65856: EMPTY
65857: LIST
65858: LIST
65859: PUSH
65860: LD_INT 2
65862: NEG
65863: PUSH
65864: LD_INT 2
65866: NEG
65867: PUSH
65868: EMPTY
65869: LIST
65870: LIST
65871: PUSH
65872: LD_INT 2
65874: PUSH
65875: LD_INT 3
65877: PUSH
65878: EMPTY
65879: LIST
65880: LIST
65881: PUSH
65882: LD_INT 1
65884: PUSH
65885: LD_INT 3
65887: PUSH
65888: EMPTY
65889: LIST
65890: LIST
65891: PUSH
65892: LD_INT 1
65894: NEG
65895: PUSH
65896: LD_INT 2
65898: PUSH
65899: EMPTY
65900: LIST
65901: LIST
65902: PUSH
65903: LD_INT 2
65905: NEG
65906: PUSH
65907: LD_INT 1
65909: PUSH
65910: EMPTY
65911: LIST
65912: LIST
65913: PUSH
65914: EMPTY
65915: LIST
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
65939: LD_ADDR_VAR 0 27
65943: PUSH
65944: LD_INT 0
65946: PUSH
65947: LD_INT 0
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: PUSH
65954: LD_INT 0
65956: PUSH
65957: LD_INT 1
65959: NEG
65960: PUSH
65961: EMPTY
65962: LIST
65963: LIST
65964: PUSH
65965: LD_INT 1
65967: PUSH
65968: LD_INT 0
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: LD_INT 1
65977: PUSH
65978: LD_INT 1
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 0
65987: PUSH
65988: LD_INT 1
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: PUSH
65995: LD_INT 1
65997: NEG
65998: PUSH
65999: LD_INT 0
66001: PUSH
66002: EMPTY
66003: LIST
66004: LIST
66005: PUSH
66006: LD_INT 1
66008: NEG
66009: PUSH
66010: LD_INT 1
66012: NEG
66013: PUSH
66014: EMPTY
66015: LIST
66016: LIST
66017: PUSH
66018: LD_INT 1
66020: NEG
66021: PUSH
66022: LD_INT 2
66024: NEG
66025: PUSH
66026: EMPTY
66027: LIST
66028: LIST
66029: PUSH
66030: LD_INT 0
66032: PUSH
66033: LD_INT 2
66035: NEG
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: PUSH
66041: LD_INT 1
66043: PUSH
66044: LD_INT 1
66046: NEG
66047: PUSH
66048: EMPTY
66049: LIST
66050: LIST
66051: PUSH
66052: LD_INT 2
66054: PUSH
66055: LD_INT 0
66057: PUSH
66058: EMPTY
66059: LIST
66060: LIST
66061: PUSH
66062: LD_INT 2
66064: PUSH
66065: LD_INT 1
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: PUSH
66072: LD_INT 2
66074: PUSH
66075: LD_INT 2
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: LD_INT 1
66084: PUSH
66085: LD_INT 2
66087: PUSH
66088: EMPTY
66089: LIST
66090: LIST
66091: PUSH
66092: LD_INT 0
66094: PUSH
66095: LD_INT 2
66097: PUSH
66098: EMPTY
66099: LIST
66100: LIST
66101: PUSH
66102: LD_INT 1
66104: NEG
66105: PUSH
66106: LD_INT 1
66108: PUSH
66109: EMPTY
66110: LIST
66111: LIST
66112: PUSH
66113: LD_INT 2
66115: NEG
66116: PUSH
66117: LD_INT 0
66119: PUSH
66120: EMPTY
66121: LIST
66122: LIST
66123: PUSH
66124: LD_INT 2
66126: NEG
66127: PUSH
66128: LD_INT 1
66130: NEG
66131: PUSH
66132: EMPTY
66133: LIST
66134: LIST
66135: PUSH
66136: LD_INT 2
66138: NEG
66139: PUSH
66140: LD_INT 2
66142: NEG
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: PUSH
66148: LD_INT 1
66150: NEG
66151: PUSH
66152: LD_INT 2
66154: PUSH
66155: EMPTY
66156: LIST
66157: LIST
66158: PUSH
66159: LD_INT 2
66161: NEG
66162: PUSH
66163: LD_INT 1
66165: PUSH
66166: EMPTY
66167: LIST
66168: LIST
66169: PUSH
66170: LD_INT 3
66172: NEG
66173: PUSH
66174: LD_INT 1
66176: NEG
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: LD_INT 3
66184: NEG
66185: PUSH
66186: LD_INT 2
66188: NEG
66189: PUSH
66190: EMPTY
66191: LIST
66192: LIST
66193: PUSH
66194: EMPTY
66195: LIST
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: LIST
66212: LIST
66213: LIST
66214: LIST
66215: LIST
66216: LIST
66217: LIST
66218: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66219: LD_ADDR_VAR 0 28
66223: PUSH
66224: LD_INT 0
66226: PUSH
66227: LD_INT 0
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: LD_INT 0
66236: PUSH
66237: LD_INT 1
66239: NEG
66240: PUSH
66241: EMPTY
66242: LIST
66243: LIST
66244: PUSH
66245: LD_INT 1
66247: PUSH
66248: LD_INT 0
66250: PUSH
66251: EMPTY
66252: LIST
66253: LIST
66254: PUSH
66255: LD_INT 1
66257: PUSH
66258: LD_INT 1
66260: PUSH
66261: EMPTY
66262: LIST
66263: LIST
66264: PUSH
66265: LD_INT 0
66267: PUSH
66268: LD_INT 1
66270: PUSH
66271: EMPTY
66272: LIST
66273: LIST
66274: PUSH
66275: LD_INT 1
66277: NEG
66278: PUSH
66279: LD_INT 0
66281: PUSH
66282: EMPTY
66283: LIST
66284: LIST
66285: PUSH
66286: LD_INT 1
66288: NEG
66289: PUSH
66290: LD_INT 1
66292: NEG
66293: PUSH
66294: EMPTY
66295: LIST
66296: LIST
66297: PUSH
66298: LD_INT 1
66300: NEG
66301: PUSH
66302: LD_INT 2
66304: NEG
66305: PUSH
66306: EMPTY
66307: LIST
66308: LIST
66309: PUSH
66310: LD_INT 0
66312: PUSH
66313: LD_INT 2
66315: NEG
66316: PUSH
66317: EMPTY
66318: LIST
66319: LIST
66320: PUSH
66321: LD_INT 1
66323: PUSH
66324: LD_INT 1
66326: NEG
66327: PUSH
66328: EMPTY
66329: LIST
66330: LIST
66331: PUSH
66332: LD_INT 2
66334: PUSH
66335: LD_INT 0
66337: PUSH
66338: EMPTY
66339: LIST
66340: LIST
66341: PUSH
66342: LD_INT 2
66344: PUSH
66345: LD_INT 1
66347: PUSH
66348: EMPTY
66349: LIST
66350: LIST
66351: PUSH
66352: LD_INT 2
66354: PUSH
66355: LD_INT 2
66357: PUSH
66358: EMPTY
66359: LIST
66360: LIST
66361: PUSH
66362: LD_INT 1
66364: PUSH
66365: LD_INT 2
66367: PUSH
66368: EMPTY
66369: LIST
66370: LIST
66371: PUSH
66372: LD_INT 0
66374: PUSH
66375: LD_INT 2
66377: PUSH
66378: EMPTY
66379: LIST
66380: LIST
66381: PUSH
66382: LD_INT 1
66384: NEG
66385: PUSH
66386: LD_INT 1
66388: PUSH
66389: EMPTY
66390: LIST
66391: LIST
66392: PUSH
66393: LD_INT 2
66395: NEG
66396: PUSH
66397: LD_INT 0
66399: PUSH
66400: EMPTY
66401: LIST
66402: LIST
66403: PUSH
66404: LD_INT 2
66406: NEG
66407: PUSH
66408: LD_INT 1
66410: NEG
66411: PUSH
66412: EMPTY
66413: LIST
66414: LIST
66415: PUSH
66416: LD_INT 2
66418: NEG
66419: PUSH
66420: LD_INT 2
66422: NEG
66423: PUSH
66424: EMPTY
66425: LIST
66426: LIST
66427: PUSH
66428: LD_INT 2
66430: NEG
66431: PUSH
66432: LD_INT 3
66434: NEG
66435: PUSH
66436: EMPTY
66437: LIST
66438: LIST
66439: PUSH
66440: LD_INT 1
66442: NEG
66443: PUSH
66444: LD_INT 3
66446: NEG
66447: PUSH
66448: EMPTY
66449: LIST
66450: LIST
66451: PUSH
66452: LD_INT 3
66454: NEG
66455: PUSH
66456: LD_INT 1
66458: NEG
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PUSH
66464: LD_INT 3
66466: NEG
66467: PUSH
66468: LD_INT 2
66470: NEG
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: EMPTY
66477: LIST
66478: LIST
66479: LIST
66480: LIST
66481: LIST
66482: LIST
66483: LIST
66484: LIST
66485: LIST
66486: LIST
66487: LIST
66488: LIST
66489: LIST
66490: LIST
66491: LIST
66492: LIST
66493: LIST
66494: LIST
66495: LIST
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66501: LD_ADDR_VAR 0 29
66505: PUSH
66506: LD_INT 0
66508: PUSH
66509: LD_INT 0
66511: PUSH
66512: EMPTY
66513: LIST
66514: LIST
66515: PUSH
66516: LD_INT 0
66518: PUSH
66519: LD_INT 1
66521: NEG
66522: PUSH
66523: EMPTY
66524: LIST
66525: LIST
66526: PUSH
66527: LD_INT 1
66529: PUSH
66530: LD_INT 0
66532: PUSH
66533: EMPTY
66534: LIST
66535: LIST
66536: PUSH
66537: LD_INT 1
66539: PUSH
66540: LD_INT 1
66542: PUSH
66543: EMPTY
66544: LIST
66545: LIST
66546: PUSH
66547: LD_INT 0
66549: PUSH
66550: LD_INT 1
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: PUSH
66557: LD_INT 1
66559: NEG
66560: PUSH
66561: LD_INT 0
66563: PUSH
66564: EMPTY
66565: LIST
66566: LIST
66567: PUSH
66568: LD_INT 1
66570: NEG
66571: PUSH
66572: LD_INT 1
66574: NEG
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 1
66582: NEG
66583: PUSH
66584: LD_INT 2
66586: NEG
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 0
66594: PUSH
66595: LD_INT 2
66597: NEG
66598: PUSH
66599: EMPTY
66600: LIST
66601: LIST
66602: PUSH
66603: LD_INT 1
66605: PUSH
66606: LD_INT 1
66608: NEG
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: PUSH
66614: LD_INT 2
66616: PUSH
66617: LD_INT 0
66619: PUSH
66620: EMPTY
66621: LIST
66622: LIST
66623: PUSH
66624: LD_INT 2
66626: PUSH
66627: LD_INT 1
66629: PUSH
66630: EMPTY
66631: LIST
66632: LIST
66633: PUSH
66634: LD_INT 1
66636: PUSH
66637: LD_INT 2
66639: PUSH
66640: EMPTY
66641: LIST
66642: LIST
66643: PUSH
66644: LD_INT 0
66646: PUSH
66647: LD_INT 2
66649: PUSH
66650: EMPTY
66651: LIST
66652: LIST
66653: PUSH
66654: LD_INT 1
66656: NEG
66657: PUSH
66658: LD_INT 1
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: LD_INT 2
66667: NEG
66668: PUSH
66669: LD_INT 1
66671: NEG
66672: PUSH
66673: EMPTY
66674: LIST
66675: LIST
66676: PUSH
66677: LD_INT 2
66679: NEG
66680: PUSH
66681: LD_INT 2
66683: NEG
66684: PUSH
66685: EMPTY
66686: LIST
66687: LIST
66688: PUSH
66689: LD_INT 2
66691: NEG
66692: PUSH
66693: LD_INT 3
66695: NEG
66696: PUSH
66697: EMPTY
66698: LIST
66699: LIST
66700: PUSH
66701: LD_INT 2
66703: PUSH
66704: LD_INT 1
66706: NEG
66707: PUSH
66708: EMPTY
66709: LIST
66710: LIST
66711: PUSH
66712: LD_INT 3
66714: PUSH
66715: LD_INT 1
66717: PUSH
66718: EMPTY
66719: LIST
66720: LIST
66721: PUSH
66722: LD_INT 1
66724: PUSH
66725: LD_INT 3
66727: PUSH
66728: EMPTY
66729: LIST
66730: LIST
66731: PUSH
66732: LD_INT 1
66734: NEG
66735: PUSH
66736: LD_INT 2
66738: PUSH
66739: EMPTY
66740: LIST
66741: LIST
66742: PUSH
66743: LD_INT 3
66745: NEG
66746: PUSH
66747: LD_INT 2
66749: NEG
66750: PUSH
66751: EMPTY
66752: LIST
66753: LIST
66754: PUSH
66755: EMPTY
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: LIST
66763: LIST
66764: LIST
66765: LIST
66766: LIST
66767: LIST
66768: LIST
66769: LIST
66770: LIST
66771: LIST
66772: LIST
66773: LIST
66774: LIST
66775: LIST
66776: LIST
66777: LIST
66778: LIST
66779: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66780: LD_ADDR_VAR 0 30
66784: PUSH
66785: LD_INT 0
66787: PUSH
66788: LD_INT 0
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: PUSH
66795: LD_INT 0
66797: PUSH
66798: LD_INT 1
66800: NEG
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: PUSH
66806: LD_INT 1
66808: PUSH
66809: LD_INT 0
66811: PUSH
66812: EMPTY
66813: LIST
66814: LIST
66815: PUSH
66816: LD_INT 1
66818: PUSH
66819: LD_INT 1
66821: PUSH
66822: EMPTY
66823: LIST
66824: LIST
66825: PUSH
66826: LD_INT 0
66828: PUSH
66829: LD_INT 1
66831: PUSH
66832: EMPTY
66833: LIST
66834: LIST
66835: PUSH
66836: LD_INT 1
66838: NEG
66839: PUSH
66840: LD_INT 0
66842: PUSH
66843: EMPTY
66844: LIST
66845: LIST
66846: PUSH
66847: LD_INT 1
66849: NEG
66850: PUSH
66851: LD_INT 1
66853: NEG
66854: PUSH
66855: EMPTY
66856: LIST
66857: LIST
66858: PUSH
66859: LD_INT 1
66861: NEG
66862: PUSH
66863: LD_INT 2
66865: NEG
66866: PUSH
66867: EMPTY
66868: LIST
66869: LIST
66870: PUSH
66871: LD_INT 0
66873: PUSH
66874: LD_INT 2
66876: NEG
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: PUSH
66882: LD_INT 1
66884: PUSH
66885: LD_INT 1
66887: NEG
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 2
66895: PUSH
66896: LD_INT 0
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PUSH
66903: LD_INT 2
66905: PUSH
66906: LD_INT 1
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PUSH
66913: LD_INT 2
66915: PUSH
66916: LD_INT 2
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: PUSH
66923: LD_INT 1
66925: PUSH
66926: LD_INT 2
66928: PUSH
66929: EMPTY
66930: LIST
66931: LIST
66932: PUSH
66933: LD_INT 1
66935: NEG
66936: PUSH
66937: LD_INT 1
66939: PUSH
66940: EMPTY
66941: LIST
66942: LIST
66943: PUSH
66944: LD_INT 2
66946: NEG
66947: PUSH
66948: LD_INT 0
66950: PUSH
66951: EMPTY
66952: LIST
66953: LIST
66954: PUSH
66955: LD_INT 2
66957: NEG
66958: PUSH
66959: LD_INT 1
66961: NEG
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PUSH
66967: LD_INT 1
66969: NEG
66970: PUSH
66971: LD_INT 3
66973: NEG
66974: PUSH
66975: EMPTY
66976: LIST
66977: LIST
66978: PUSH
66979: LD_INT 1
66981: PUSH
66982: LD_INT 2
66984: NEG
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: LD_INT 3
66992: PUSH
66993: LD_INT 2
66995: PUSH
66996: EMPTY
66997: LIST
66998: LIST
66999: PUSH
67000: LD_INT 2
67002: PUSH
67003: LD_INT 3
67005: PUSH
67006: EMPTY
67007: LIST
67008: LIST
67009: PUSH
67010: LD_INT 2
67012: NEG
67013: PUSH
67014: LD_INT 1
67016: PUSH
67017: EMPTY
67018: LIST
67019: LIST
67020: PUSH
67021: LD_INT 3
67023: NEG
67024: PUSH
67025: LD_INT 1
67027: NEG
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: PUSH
67033: EMPTY
67034: LIST
67035: LIST
67036: LIST
67037: LIST
67038: LIST
67039: LIST
67040: LIST
67041: LIST
67042: LIST
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: LIST
67048: LIST
67049: LIST
67050: LIST
67051: LIST
67052: LIST
67053: LIST
67054: LIST
67055: LIST
67056: LIST
67057: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67058: LD_ADDR_VAR 0 31
67062: PUSH
67063: LD_INT 0
67065: PUSH
67066: LD_INT 0
67068: PUSH
67069: EMPTY
67070: LIST
67071: LIST
67072: PUSH
67073: LD_INT 0
67075: PUSH
67076: LD_INT 1
67078: NEG
67079: PUSH
67080: EMPTY
67081: LIST
67082: LIST
67083: PUSH
67084: LD_INT 1
67086: PUSH
67087: LD_INT 0
67089: PUSH
67090: EMPTY
67091: LIST
67092: LIST
67093: PUSH
67094: LD_INT 1
67096: PUSH
67097: LD_INT 1
67099: PUSH
67100: EMPTY
67101: LIST
67102: LIST
67103: PUSH
67104: LD_INT 0
67106: PUSH
67107: LD_INT 1
67109: PUSH
67110: EMPTY
67111: LIST
67112: LIST
67113: PUSH
67114: LD_INT 1
67116: NEG
67117: PUSH
67118: LD_INT 0
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PUSH
67125: LD_INT 1
67127: NEG
67128: PUSH
67129: LD_INT 1
67131: NEG
67132: PUSH
67133: EMPTY
67134: LIST
67135: LIST
67136: PUSH
67137: LD_INT 1
67139: NEG
67140: PUSH
67141: LD_INT 2
67143: NEG
67144: PUSH
67145: EMPTY
67146: LIST
67147: LIST
67148: PUSH
67149: LD_INT 1
67151: PUSH
67152: LD_INT 1
67154: NEG
67155: PUSH
67156: EMPTY
67157: LIST
67158: LIST
67159: PUSH
67160: LD_INT 2
67162: PUSH
67163: LD_INT 0
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: PUSH
67170: LD_INT 2
67172: PUSH
67173: LD_INT 1
67175: PUSH
67176: EMPTY
67177: LIST
67178: LIST
67179: PUSH
67180: LD_INT 2
67182: PUSH
67183: LD_INT 2
67185: PUSH
67186: EMPTY
67187: LIST
67188: LIST
67189: PUSH
67190: LD_INT 1
67192: PUSH
67193: LD_INT 2
67195: PUSH
67196: EMPTY
67197: LIST
67198: LIST
67199: PUSH
67200: LD_INT 0
67202: PUSH
67203: LD_INT 2
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: PUSH
67210: LD_INT 1
67212: NEG
67213: PUSH
67214: LD_INT 1
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 2
67223: NEG
67224: PUSH
67225: LD_INT 1
67227: NEG
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: PUSH
67233: LD_INT 2
67235: NEG
67236: PUSH
67237: LD_INT 2
67239: NEG
67240: PUSH
67241: EMPTY
67242: LIST
67243: LIST
67244: PUSH
67245: LD_INT 2
67247: NEG
67248: PUSH
67249: LD_INT 3
67251: NEG
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 2
67259: PUSH
67260: LD_INT 1
67262: NEG
67263: PUSH
67264: EMPTY
67265: LIST
67266: LIST
67267: PUSH
67268: LD_INT 3
67270: PUSH
67271: LD_INT 1
67273: PUSH
67274: EMPTY
67275: LIST
67276: LIST
67277: PUSH
67278: LD_INT 1
67280: PUSH
67281: LD_INT 3
67283: PUSH
67284: EMPTY
67285: LIST
67286: LIST
67287: PUSH
67288: LD_INT 1
67290: NEG
67291: PUSH
67292: LD_INT 2
67294: PUSH
67295: EMPTY
67296: LIST
67297: LIST
67298: PUSH
67299: LD_INT 3
67301: NEG
67302: PUSH
67303: LD_INT 2
67305: NEG
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: PUSH
67311: EMPTY
67312: LIST
67313: LIST
67314: LIST
67315: LIST
67316: LIST
67317: LIST
67318: LIST
67319: LIST
67320: LIST
67321: LIST
67322: LIST
67323: LIST
67324: LIST
67325: LIST
67326: LIST
67327: LIST
67328: LIST
67329: LIST
67330: LIST
67331: LIST
67332: LIST
67333: LIST
67334: LIST
67335: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67336: LD_ADDR_VAR 0 32
67340: PUSH
67341: LD_INT 0
67343: PUSH
67344: LD_INT 0
67346: PUSH
67347: EMPTY
67348: LIST
67349: LIST
67350: PUSH
67351: LD_INT 0
67353: PUSH
67354: LD_INT 1
67356: NEG
67357: PUSH
67358: EMPTY
67359: LIST
67360: LIST
67361: PUSH
67362: LD_INT 1
67364: PUSH
67365: LD_INT 0
67367: PUSH
67368: EMPTY
67369: LIST
67370: LIST
67371: PUSH
67372: LD_INT 1
67374: PUSH
67375: LD_INT 1
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: PUSH
67382: LD_INT 0
67384: PUSH
67385: LD_INT 1
67387: PUSH
67388: EMPTY
67389: LIST
67390: LIST
67391: PUSH
67392: LD_INT 1
67394: NEG
67395: PUSH
67396: LD_INT 0
67398: PUSH
67399: EMPTY
67400: LIST
67401: LIST
67402: PUSH
67403: LD_INT 1
67405: NEG
67406: PUSH
67407: LD_INT 1
67409: NEG
67410: PUSH
67411: EMPTY
67412: LIST
67413: LIST
67414: PUSH
67415: LD_INT 1
67417: NEG
67418: PUSH
67419: LD_INT 2
67421: NEG
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: PUSH
67427: LD_INT 0
67429: PUSH
67430: LD_INT 2
67432: NEG
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: PUSH
67438: LD_INT 1
67440: PUSH
67441: LD_INT 1
67443: NEG
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: PUSH
67449: LD_INT 2
67451: PUSH
67452: LD_INT 1
67454: PUSH
67455: EMPTY
67456: LIST
67457: LIST
67458: PUSH
67459: LD_INT 2
67461: PUSH
67462: LD_INT 2
67464: PUSH
67465: EMPTY
67466: LIST
67467: LIST
67468: PUSH
67469: LD_INT 1
67471: PUSH
67472: LD_INT 2
67474: PUSH
67475: EMPTY
67476: LIST
67477: LIST
67478: PUSH
67479: LD_INT 0
67481: PUSH
67482: LD_INT 2
67484: PUSH
67485: EMPTY
67486: LIST
67487: LIST
67488: PUSH
67489: LD_INT 1
67491: NEG
67492: PUSH
67493: LD_INT 1
67495: PUSH
67496: EMPTY
67497: LIST
67498: LIST
67499: PUSH
67500: LD_INT 2
67502: NEG
67503: PUSH
67504: LD_INT 0
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: LD_INT 2
67513: NEG
67514: PUSH
67515: LD_INT 1
67517: NEG
67518: PUSH
67519: EMPTY
67520: LIST
67521: LIST
67522: PUSH
67523: LD_INT 1
67525: NEG
67526: PUSH
67527: LD_INT 3
67529: NEG
67530: PUSH
67531: EMPTY
67532: LIST
67533: LIST
67534: PUSH
67535: LD_INT 1
67537: PUSH
67538: LD_INT 2
67540: NEG
67541: PUSH
67542: EMPTY
67543: LIST
67544: LIST
67545: PUSH
67546: LD_INT 3
67548: PUSH
67549: LD_INT 2
67551: PUSH
67552: EMPTY
67553: LIST
67554: LIST
67555: PUSH
67556: LD_INT 2
67558: PUSH
67559: LD_INT 3
67561: PUSH
67562: EMPTY
67563: LIST
67564: LIST
67565: PUSH
67566: LD_INT 2
67568: NEG
67569: PUSH
67570: LD_INT 1
67572: PUSH
67573: EMPTY
67574: LIST
67575: LIST
67576: PUSH
67577: LD_INT 3
67579: NEG
67580: PUSH
67581: LD_INT 1
67583: NEG
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: LIST
67593: LIST
67594: LIST
67595: LIST
67596: LIST
67597: LIST
67598: LIST
67599: LIST
67600: LIST
67601: LIST
67602: LIST
67603: LIST
67604: LIST
67605: LIST
67606: LIST
67607: LIST
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67614: LD_ADDR_VAR 0 33
67618: PUSH
67619: LD_INT 0
67621: PUSH
67622: LD_INT 0
67624: PUSH
67625: EMPTY
67626: LIST
67627: LIST
67628: PUSH
67629: LD_INT 0
67631: PUSH
67632: LD_INT 1
67634: NEG
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PUSH
67640: LD_INT 1
67642: PUSH
67643: LD_INT 0
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: PUSH
67650: LD_INT 1
67652: PUSH
67653: LD_INT 1
67655: PUSH
67656: EMPTY
67657: LIST
67658: LIST
67659: PUSH
67660: LD_INT 0
67662: PUSH
67663: LD_INT 1
67665: PUSH
67666: EMPTY
67667: LIST
67668: LIST
67669: PUSH
67670: LD_INT 1
67672: NEG
67673: PUSH
67674: LD_INT 0
67676: PUSH
67677: EMPTY
67678: LIST
67679: LIST
67680: PUSH
67681: LD_INT 1
67683: NEG
67684: PUSH
67685: LD_INT 1
67687: NEG
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: PUSH
67693: LD_INT 1
67695: NEG
67696: PUSH
67697: LD_INT 2
67699: NEG
67700: PUSH
67701: EMPTY
67702: LIST
67703: LIST
67704: PUSH
67705: LD_INT 1
67707: PUSH
67708: LD_INT 1
67710: NEG
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: PUSH
67716: LD_INT 2
67718: PUSH
67719: LD_INT 0
67721: PUSH
67722: EMPTY
67723: LIST
67724: LIST
67725: PUSH
67726: LD_INT 2
67728: PUSH
67729: LD_INT 1
67731: PUSH
67732: EMPTY
67733: LIST
67734: LIST
67735: PUSH
67736: LD_INT 1
67738: PUSH
67739: LD_INT 2
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: PUSH
67746: LD_INT 0
67748: PUSH
67749: LD_INT 2
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: PUSH
67756: LD_INT 1
67758: NEG
67759: PUSH
67760: LD_INT 1
67762: PUSH
67763: EMPTY
67764: LIST
67765: LIST
67766: PUSH
67767: LD_INT 2
67769: NEG
67770: PUSH
67771: LD_INT 0
67773: PUSH
67774: EMPTY
67775: LIST
67776: LIST
67777: PUSH
67778: LD_INT 2
67780: NEG
67781: PUSH
67782: LD_INT 1
67784: NEG
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: PUSH
67790: LD_INT 2
67792: NEG
67793: PUSH
67794: LD_INT 2
67796: NEG
67797: PUSH
67798: EMPTY
67799: LIST
67800: LIST
67801: PUSH
67802: LD_INT 2
67804: NEG
67805: PUSH
67806: LD_INT 3
67808: NEG
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 2
67816: PUSH
67817: LD_INT 1
67819: NEG
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: PUSH
67825: LD_INT 3
67827: PUSH
67828: LD_INT 1
67830: PUSH
67831: EMPTY
67832: LIST
67833: LIST
67834: PUSH
67835: LD_INT 1
67837: PUSH
67838: LD_INT 3
67840: PUSH
67841: EMPTY
67842: LIST
67843: LIST
67844: PUSH
67845: LD_INT 1
67847: NEG
67848: PUSH
67849: LD_INT 2
67851: PUSH
67852: EMPTY
67853: LIST
67854: LIST
67855: PUSH
67856: LD_INT 3
67858: NEG
67859: PUSH
67860: LD_INT 2
67862: NEG
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: LIST
67880: LIST
67881: LIST
67882: LIST
67883: LIST
67884: LIST
67885: LIST
67886: LIST
67887: LIST
67888: LIST
67889: LIST
67890: LIST
67891: LIST
67892: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67893: LD_ADDR_VAR 0 34
67897: PUSH
67898: LD_INT 0
67900: PUSH
67901: LD_INT 0
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: PUSH
67908: LD_INT 0
67910: PUSH
67911: LD_INT 1
67913: NEG
67914: PUSH
67915: EMPTY
67916: LIST
67917: LIST
67918: PUSH
67919: LD_INT 1
67921: PUSH
67922: LD_INT 0
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: PUSH
67929: LD_INT 1
67931: PUSH
67932: LD_INT 1
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: PUSH
67939: LD_INT 0
67941: PUSH
67942: LD_INT 1
67944: PUSH
67945: EMPTY
67946: LIST
67947: LIST
67948: PUSH
67949: LD_INT 1
67951: NEG
67952: PUSH
67953: LD_INT 0
67955: PUSH
67956: EMPTY
67957: LIST
67958: LIST
67959: PUSH
67960: LD_INT 1
67962: NEG
67963: PUSH
67964: LD_INT 1
67966: NEG
67967: PUSH
67968: EMPTY
67969: LIST
67970: LIST
67971: PUSH
67972: LD_INT 1
67974: NEG
67975: PUSH
67976: LD_INT 2
67978: NEG
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 0
67986: PUSH
67987: LD_INT 2
67989: NEG
67990: PUSH
67991: EMPTY
67992: LIST
67993: LIST
67994: PUSH
67995: LD_INT 1
67997: PUSH
67998: LD_INT 1
68000: NEG
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: LD_INT 2
68008: PUSH
68009: LD_INT 1
68011: PUSH
68012: EMPTY
68013: LIST
68014: LIST
68015: PUSH
68016: LD_INT 2
68018: PUSH
68019: LD_INT 2
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: PUSH
68026: LD_INT 1
68028: PUSH
68029: LD_INT 2
68031: PUSH
68032: EMPTY
68033: LIST
68034: LIST
68035: PUSH
68036: LD_INT 1
68038: NEG
68039: PUSH
68040: LD_INT 1
68042: PUSH
68043: EMPTY
68044: LIST
68045: LIST
68046: PUSH
68047: LD_INT 2
68049: NEG
68050: PUSH
68051: LD_INT 0
68053: PUSH
68054: EMPTY
68055: LIST
68056: LIST
68057: PUSH
68058: LD_INT 2
68060: NEG
68061: PUSH
68062: LD_INT 1
68064: NEG
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: PUSH
68070: LD_INT 2
68072: NEG
68073: PUSH
68074: LD_INT 2
68076: NEG
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: PUSH
68082: LD_INT 1
68084: NEG
68085: PUSH
68086: LD_INT 3
68088: NEG
68089: PUSH
68090: EMPTY
68091: LIST
68092: LIST
68093: PUSH
68094: LD_INT 1
68096: PUSH
68097: LD_INT 2
68099: NEG
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: PUSH
68105: LD_INT 3
68107: PUSH
68108: LD_INT 2
68110: PUSH
68111: EMPTY
68112: LIST
68113: LIST
68114: PUSH
68115: LD_INT 2
68117: PUSH
68118: LD_INT 3
68120: PUSH
68121: EMPTY
68122: LIST
68123: LIST
68124: PUSH
68125: LD_INT 2
68127: NEG
68128: PUSH
68129: LD_INT 1
68131: PUSH
68132: EMPTY
68133: LIST
68134: LIST
68135: PUSH
68136: LD_INT 3
68138: NEG
68139: PUSH
68140: LD_INT 1
68142: NEG
68143: PUSH
68144: EMPTY
68145: LIST
68146: LIST
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: LIST
68162: LIST
68163: LIST
68164: LIST
68165: LIST
68166: LIST
68167: LIST
68168: LIST
68169: LIST
68170: LIST
68171: LIST
68172: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68173: LD_ADDR_VAR 0 35
68177: PUSH
68178: LD_INT 0
68180: PUSH
68181: LD_INT 0
68183: PUSH
68184: EMPTY
68185: LIST
68186: LIST
68187: PUSH
68188: LD_INT 0
68190: PUSH
68191: LD_INT 1
68193: NEG
68194: PUSH
68195: EMPTY
68196: LIST
68197: LIST
68198: PUSH
68199: LD_INT 1
68201: PUSH
68202: LD_INT 0
68204: PUSH
68205: EMPTY
68206: LIST
68207: LIST
68208: PUSH
68209: LD_INT 1
68211: PUSH
68212: LD_INT 1
68214: PUSH
68215: EMPTY
68216: LIST
68217: LIST
68218: PUSH
68219: LD_INT 0
68221: PUSH
68222: LD_INT 1
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 1
68231: NEG
68232: PUSH
68233: LD_INT 0
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: PUSH
68240: LD_INT 1
68242: NEG
68243: PUSH
68244: LD_INT 1
68246: NEG
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: PUSH
68252: LD_INT 2
68254: PUSH
68255: LD_INT 1
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: PUSH
68262: LD_INT 2
68264: NEG
68265: PUSH
68266: LD_INT 1
68268: NEG
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68285: LD_ADDR_VAR 0 36
68289: PUSH
68290: LD_INT 0
68292: PUSH
68293: LD_INT 0
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: LD_INT 0
68302: PUSH
68303: LD_INT 1
68305: NEG
68306: PUSH
68307: EMPTY
68308: LIST
68309: LIST
68310: PUSH
68311: LD_INT 1
68313: PUSH
68314: LD_INT 0
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: PUSH
68321: LD_INT 1
68323: PUSH
68324: LD_INT 1
68326: PUSH
68327: EMPTY
68328: LIST
68329: LIST
68330: PUSH
68331: LD_INT 0
68333: PUSH
68334: LD_INT 1
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: LD_INT 1
68343: NEG
68344: PUSH
68345: LD_INT 0
68347: PUSH
68348: EMPTY
68349: LIST
68350: LIST
68351: PUSH
68352: LD_INT 1
68354: NEG
68355: PUSH
68356: LD_INT 1
68358: NEG
68359: PUSH
68360: EMPTY
68361: LIST
68362: LIST
68363: PUSH
68364: LD_INT 1
68366: NEG
68367: PUSH
68368: LD_INT 2
68370: NEG
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: PUSH
68376: LD_INT 1
68378: PUSH
68379: LD_INT 2
68381: PUSH
68382: EMPTY
68383: LIST
68384: LIST
68385: PUSH
68386: EMPTY
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: LIST
68394: LIST
68395: LIST
68396: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68397: LD_ADDR_VAR 0 37
68401: PUSH
68402: LD_INT 0
68404: PUSH
68405: LD_INT 0
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: LD_INT 0
68414: PUSH
68415: LD_INT 1
68417: NEG
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 1
68425: PUSH
68426: LD_INT 0
68428: PUSH
68429: EMPTY
68430: LIST
68431: LIST
68432: PUSH
68433: LD_INT 1
68435: PUSH
68436: LD_INT 1
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: PUSH
68443: LD_INT 0
68445: PUSH
68446: LD_INT 1
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: LD_INT 1
68455: NEG
68456: PUSH
68457: LD_INT 0
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: PUSH
68464: LD_INT 1
68466: NEG
68467: PUSH
68468: LD_INT 1
68470: NEG
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PUSH
68476: LD_INT 1
68478: PUSH
68479: LD_INT 1
68481: NEG
68482: PUSH
68483: EMPTY
68484: LIST
68485: LIST
68486: PUSH
68487: LD_INT 1
68489: NEG
68490: PUSH
68491: LD_INT 1
68493: PUSH
68494: EMPTY
68495: LIST
68496: LIST
68497: PUSH
68498: EMPTY
68499: LIST
68500: LIST
68501: LIST
68502: LIST
68503: LIST
68504: LIST
68505: LIST
68506: LIST
68507: LIST
68508: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68509: LD_ADDR_VAR 0 38
68513: PUSH
68514: LD_INT 0
68516: PUSH
68517: LD_INT 0
68519: PUSH
68520: EMPTY
68521: LIST
68522: LIST
68523: PUSH
68524: LD_INT 0
68526: PUSH
68527: LD_INT 1
68529: NEG
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: LD_INT 1
68537: PUSH
68538: LD_INT 0
68540: PUSH
68541: EMPTY
68542: LIST
68543: LIST
68544: PUSH
68545: LD_INT 1
68547: PUSH
68548: LD_INT 1
68550: PUSH
68551: EMPTY
68552: LIST
68553: LIST
68554: PUSH
68555: LD_INT 0
68557: PUSH
68558: LD_INT 1
68560: PUSH
68561: EMPTY
68562: LIST
68563: LIST
68564: PUSH
68565: LD_INT 1
68567: NEG
68568: PUSH
68569: LD_INT 0
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: PUSH
68576: LD_INT 1
68578: NEG
68579: PUSH
68580: LD_INT 1
68582: NEG
68583: PUSH
68584: EMPTY
68585: LIST
68586: LIST
68587: PUSH
68588: LD_INT 2
68590: PUSH
68591: LD_INT 1
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: PUSH
68598: LD_INT 2
68600: NEG
68601: PUSH
68602: LD_INT 1
68604: NEG
68605: PUSH
68606: EMPTY
68607: LIST
68608: LIST
68609: PUSH
68610: EMPTY
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: LIST
68616: LIST
68617: LIST
68618: LIST
68619: LIST
68620: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68621: LD_ADDR_VAR 0 39
68625: PUSH
68626: LD_INT 0
68628: PUSH
68629: LD_INT 0
68631: PUSH
68632: EMPTY
68633: LIST
68634: LIST
68635: PUSH
68636: LD_INT 0
68638: PUSH
68639: LD_INT 1
68641: NEG
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: PUSH
68647: LD_INT 1
68649: PUSH
68650: LD_INT 0
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: PUSH
68657: LD_INT 1
68659: PUSH
68660: LD_INT 1
68662: PUSH
68663: EMPTY
68664: LIST
68665: LIST
68666: PUSH
68667: LD_INT 0
68669: PUSH
68670: LD_INT 1
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: PUSH
68677: LD_INT 1
68679: NEG
68680: PUSH
68681: LD_INT 0
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: PUSH
68688: LD_INT 1
68690: NEG
68691: PUSH
68692: LD_INT 1
68694: NEG
68695: PUSH
68696: EMPTY
68697: LIST
68698: LIST
68699: PUSH
68700: LD_INT 1
68702: NEG
68703: PUSH
68704: LD_INT 2
68706: NEG
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: PUSH
68712: LD_INT 1
68714: PUSH
68715: LD_INT 2
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: EMPTY
68723: LIST
68724: LIST
68725: LIST
68726: LIST
68727: LIST
68728: LIST
68729: LIST
68730: LIST
68731: LIST
68732: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68733: LD_ADDR_VAR 0 40
68737: PUSH
68738: LD_INT 0
68740: PUSH
68741: LD_INT 0
68743: PUSH
68744: EMPTY
68745: LIST
68746: LIST
68747: PUSH
68748: LD_INT 0
68750: PUSH
68751: LD_INT 1
68753: NEG
68754: PUSH
68755: EMPTY
68756: LIST
68757: LIST
68758: PUSH
68759: LD_INT 1
68761: PUSH
68762: LD_INT 0
68764: PUSH
68765: EMPTY
68766: LIST
68767: LIST
68768: PUSH
68769: LD_INT 1
68771: PUSH
68772: LD_INT 1
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: PUSH
68779: LD_INT 0
68781: PUSH
68782: LD_INT 1
68784: PUSH
68785: EMPTY
68786: LIST
68787: LIST
68788: PUSH
68789: LD_INT 1
68791: NEG
68792: PUSH
68793: LD_INT 0
68795: PUSH
68796: EMPTY
68797: LIST
68798: LIST
68799: PUSH
68800: LD_INT 1
68802: NEG
68803: PUSH
68804: LD_INT 1
68806: NEG
68807: PUSH
68808: EMPTY
68809: LIST
68810: LIST
68811: PUSH
68812: LD_INT 1
68814: PUSH
68815: LD_INT 1
68817: NEG
68818: PUSH
68819: EMPTY
68820: LIST
68821: LIST
68822: PUSH
68823: LD_INT 1
68825: NEG
68826: PUSH
68827: LD_INT 1
68829: PUSH
68830: EMPTY
68831: LIST
68832: LIST
68833: PUSH
68834: EMPTY
68835: LIST
68836: LIST
68837: LIST
68838: LIST
68839: LIST
68840: LIST
68841: LIST
68842: LIST
68843: LIST
68844: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68845: LD_ADDR_VAR 0 41
68849: PUSH
68850: LD_INT 0
68852: PUSH
68853: LD_INT 0
68855: PUSH
68856: EMPTY
68857: LIST
68858: LIST
68859: PUSH
68860: LD_INT 0
68862: PUSH
68863: LD_INT 1
68865: NEG
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: LD_INT 1
68873: PUSH
68874: LD_INT 0
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: PUSH
68881: LD_INT 1
68883: PUSH
68884: LD_INT 1
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PUSH
68891: LD_INT 0
68893: PUSH
68894: LD_INT 1
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PUSH
68901: LD_INT 1
68903: NEG
68904: PUSH
68905: LD_INT 0
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PUSH
68912: LD_INT 1
68914: NEG
68915: PUSH
68916: LD_INT 1
68918: NEG
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PUSH
68924: LD_INT 1
68926: NEG
68927: PUSH
68928: LD_INT 2
68930: NEG
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: PUSH
68936: LD_INT 1
68938: PUSH
68939: LD_INT 1
68941: NEG
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: PUSH
68947: LD_INT 2
68949: PUSH
68950: LD_INT 0
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: PUSH
68957: LD_INT 2
68959: PUSH
68960: LD_INT 1
68962: PUSH
68963: EMPTY
68964: LIST
68965: LIST
68966: PUSH
68967: LD_INT 2
68969: PUSH
68970: LD_INT 2
68972: PUSH
68973: EMPTY
68974: LIST
68975: LIST
68976: PUSH
68977: LD_INT 1
68979: PUSH
68980: LD_INT 2
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: PUSH
68987: LD_INT 1
68989: NEG
68990: PUSH
68991: LD_INT 1
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 2
69000: NEG
69001: PUSH
69002: LD_INT 0
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: PUSH
69009: LD_INT 2
69011: NEG
69012: PUSH
69013: LD_INT 1
69015: NEG
69016: PUSH
69017: EMPTY
69018: LIST
69019: LIST
69020: PUSH
69021: LD_INT 2
69023: NEG
69024: PUSH
69025: LD_INT 2
69027: NEG
69028: PUSH
69029: EMPTY
69030: LIST
69031: LIST
69032: PUSH
69033: LD_INT 2
69035: NEG
69036: PUSH
69037: LD_INT 3
69039: NEG
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: PUSH
69045: LD_INT 2
69047: PUSH
69048: LD_INT 1
69050: NEG
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PUSH
69056: LD_INT 3
69058: PUSH
69059: LD_INT 0
69061: PUSH
69062: EMPTY
69063: LIST
69064: LIST
69065: PUSH
69066: LD_INT 3
69068: PUSH
69069: LD_INT 1
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: LD_INT 3
69078: PUSH
69079: LD_INT 2
69081: PUSH
69082: EMPTY
69083: LIST
69084: LIST
69085: PUSH
69086: LD_INT 3
69088: PUSH
69089: LD_INT 3
69091: PUSH
69092: EMPTY
69093: LIST
69094: LIST
69095: PUSH
69096: LD_INT 2
69098: PUSH
69099: LD_INT 3
69101: PUSH
69102: EMPTY
69103: LIST
69104: LIST
69105: PUSH
69106: LD_INT 2
69108: NEG
69109: PUSH
69110: LD_INT 1
69112: PUSH
69113: EMPTY
69114: LIST
69115: LIST
69116: PUSH
69117: LD_INT 3
69119: NEG
69120: PUSH
69121: LD_INT 0
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 3
69130: NEG
69131: PUSH
69132: LD_INT 1
69134: NEG
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: PUSH
69140: LD_INT 3
69142: NEG
69143: PUSH
69144: LD_INT 2
69146: NEG
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: PUSH
69152: LD_INT 3
69154: NEG
69155: PUSH
69156: LD_INT 3
69158: NEG
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: LIST
69178: LIST
69179: LIST
69180: LIST
69181: LIST
69182: LIST
69183: LIST
69184: LIST
69185: LIST
69186: LIST
69187: LIST
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: LIST
69194: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69195: LD_ADDR_VAR 0 42
69199: PUSH
69200: LD_INT 0
69202: PUSH
69203: LD_INT 0
69205: PUSH
69206: EMPTY
69207: LIST
69208: LIST
69209: PUSH
69210: LD_INT 0
69212: PUSH
69213: LD_INT 1
69215: NEG
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: PUSH
69221: LD_INT 1
69223: PUSH
69224: LD_INT 0
69226: PUSH
69227: EMPTY
69228: LIST
69229: LIST
69230: PUSH
69231: LD_INT 1
69233: PUSH
69234: LD_INT 1
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PUSH
69241: LD_INT 0
69243: PUSH
69244: LD_INT 1
69246: PUSH
69247: EMPTY
69248: LIST
69249: LIST
69250: PUSH
69251: LD_INT 1
69253: NEG
69254: PUSH
69255: LD_INT 0
69257: PUSH
69258: EMPTY
69259: LIST
69260: LIST
69261: PUSH
69262: LD_INT 1
69264: NEG
69265: PUSH
69266: LD_INT 1
69268: NEG
69269: PUSH
69270: EMPTY
69271: LIST
69272: LIST
69273: PUSH
69274: LD_INT 1
69276: NEG
69277: PUSH
69278: LD_INT 2
69280: NEG
69281: PUSH
69282: EMPTY
69283: LIST
69284: LIST
69285: PUSH
69286: LD_INT 0
69288: PUSH
69289: LD_INT 2
69291: NEG
69292: PUSH
69293: EMPTY
69294: LIST
69295: LIST
69296: PUSH
69297: LD_INT 1
69299: PUSH
69300: LD_INT 1
69302: NEG
69303: PUSH
69304: EMPTY
69305: LIST
69306: LIST
69307: PUSH
69308: LD_INT 2
69310: PUSH
69311: LD_INT 1
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: PUSH
69318: LD_INT 2
69320: PUSH
69321: LD_INT 2
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: PUSH
69328: LD_INT 1
69330: PUSH
69331: LD_INT 2
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: LD_INT 0
69340: PUSH
69341: LD_INT 2
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: PUSH
69348: LD_INT 1
69350: NEG
69351: PUSH
69352: LD_INT 1
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: PUSH
69359: LD_INT 2
69361: NEG
69362: PUSH
69363: LD_INT 1
69365: NEG
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: LD_INT 2
69373: NEG
69374: PUSH
69375: LD_INT 2
69377: NEG
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: LD_INT 2
69385: NEG
69386: PUSH
69387: LD_INT 3
69389: NEG
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: PUSH
69395: LD_INT 1
69397: NEG
69398: PUSH
69399: LD_INT 3
69401: NEG
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PUSH
69407: LD_INT 0
69409: PUSH
69410: LD_INT 3
69412: NEG
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: PUSH
69418: LD_INT 1
69420: PUSH
69421: LD_INT 2
69423: NEG
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 3
69431: PUSH
69432: LD_INT 2
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: PUSH
69439: LD_INT 3
69441: PUSH
69442: LD_INT 3
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 2
69451: PUSH
69452: LD_INT 3
69454: PUSH
69455: EMPTY
69456: LIST
69457: LIST
69458: PUSH
69459: LD_INT 1
69461: PUSH
69462: LD_INT 3
69464: PUSH
69465: EMPTY
69466: LIST
69467: LIST
69468: PUSH
69469: LD_INT 0
69471: PUSH
69472: LD_INT 3
69474: PUSH
69475: EMPTY
69476: LIST
69477: LIST
69478: PUSH
69479: LD_INT 1
69481: NEG
69482: PUSH
69483: LD_INT 2
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: LD_INT 3
69492: NEG
69493: PUSH
69494: LD_INT 2
69496: NEG
69497: PUSH
69498: EMPTY
69499: LIST
69500: LIST
69501: PUSH
69502: LD_INT 3
69504: NEG
69505: PUSH
69506: LD_INT 3
69508: NEG
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: LIST
69518: LIST
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: LIST
69524: LIST
69525: LIST
69526: LIST
69527: LIST
69528: LIST
69529: LIST
69530: LIST
69531: LIST
69532: LIST
69533: LIST
69534: LIST
69535: LIST
69536: LIST
69537: LIST
69538: LIST
69539: LIST
69540: LIST
69541: LIST
69542: LIST
69543: LIST
69544: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69545: LD_ADDR_VAR 0 43
69549: PUSH
69550: LD_INT 0
69552: PUSH
69553: LD_INT 0
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: LD_INT 0
69562: PUSH
69563: LD_INT 1
69565: NEG
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: PUSH
69571: LD_INT 1
69573: PUSH
69574: LD_INT 0
69576: PUSH
69577: EMPTY
69578: LIST
69579: LIST
69580: PUSH
69581: LD_INT 1
69583: PUSH
69584: LD_INT 1
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: PUSH
69591: LD_INT 0
69593: PUSH
69594: LD_INT 1
69596: PUSH
69597: EMPTY
69598: LIST
69599: LIST
69600: PUSH
69601: LD_INT 1
69603: NEG
69604: PUSH
69605: LD_INT 0
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: PUSH
69612: LD_INT 1
69614: NEG
69615: PUSH
69616: LD_INT 1
69618: NEG
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 1
69626: NEG
69627: PUSH
69628: LD_INT 2
69630: NEG
69631: PUSH
69632: EMPTY
69633: LIST
69634: LIST
69635: PUSH
69636: LD_INT 0
69638: PUSH
69639: LD_INT 2
69641: NEG
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: PUSH
69647: LD_INT 1
69649: PUSH
69650: LD_INT 1
69652: NEG
69653: PUSH
69654: EMPTY
69655: LIST
69656: LIST
69657: PUSH
69658: LD_INT 2
69660: PUSH
69661: LD_INT 0
69663: PUSH
69664: EMPTY
69665: LIST
69666: LIST
69667: PUSH
69668: LD_INT 2
69670: PUSH
69671: LD_INT 1
69673: PUSH
69674: EMPTY
69675: LIST
69676: LIST
69677: PUSH
69678: LD_INT 1
69680: PUSH
69681: LD_INT 2
69683: PUSH
69684: EMPTY
69685: LIST
69686: LIST
69687: PUSH
69688: LD_INT 0
69690: PUSH
69691: LD_INT 2
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: PUSH
69698: LD_INT 1
69700: NEG
69701: PUSH
69702: LD_INT 1
69704: PUSH
69705: EMPTY
69706: LIST
69707: LIST
69708: PUSH
69709: LD_INT 2
69711: NEG
69712: PUSH
69713: LD_INT 0
69715: PUSH
69716: EMPTY
69717: LIST
69718: LIST
69719: PUSH
69720: LD_INT 2
69722: NEG
69723: PUSH
69724: LD_INT 1
69726: NEG
69727: PUSH
69728: EMPTY
69729: LIST
69730: LIST
69731: PUSH
69732: LD_INT 1
69734: NEG
69735: PUSH
69736: LD_INT 3
69738: NEG
69739: PUSH
69740: EMPTY
69741: LIST
69742: LIST
69743: PUSH
69744: LD_INT 0
69746: PUSH
69747: LD_INT 3
69749: NEG
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: PUSH
69755: LD_INT 1
69757: PUSH
69758: LD_INT 2
69760: NEG
69761: PUSH
69762: EMPTY
69763: LIST
69764: LIST
69765: PUSH
69766: LD_INT 2
69768: PUSH
69769: LD_INT 1
69771: NEG
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 3
69779: PUSH
69780: LD_INT 0
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: LD_INT 3
69789: PUSH
69790: LD_INT 1
69792: PUSH
69793: EMPTY
69794: LIST
69795: LIST
69796: PUSH
69797: LD_INT 1
69799: PUSH
69800: LD_INT 3
69802: PUSH
69803: EMPTY
69804: LIST
69805: LIST
69806: PUSH
69807: LD_INT 0
69809: PUSH
69810: LD_INT 3
69812: PUSH
69813: EMPTY
69814: LIST
69815: LIST
69816: PUSH
69817: LD_INT 1
69819: NEG
69820: PUSH
69821: LD_INT 2
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: PUSH
69828: LD_INT 2
69830: NEG
69831: PUSH
69832: LD_INT 1
69834: PUSH
69835: EMPTY
69836: LIST
69837: LIST
69838: PUSH
69839: LD_INT 3
69841: NEG
69842: PUSH
69843: LD_INT 0
69845: PUSH
69846: EMPTY
69847: LIST
69848: LIST
69849: PUSH
69850: LD_INT 3
69852: NEG
69853: PUSH
69854: LD_INT 1
69856: NEG
69857: PUSH
69858: EMPTY
69859: LIST
69860: LIST
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: LIST
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: LIST
69877: LIST
69878: LIST
69879: LIST
69880: LIST
69881: LIST
69882: LIST
69883: LIST
69884: LIST
69885: LIST
69886: LIST
69887: LIST
69888: LIST
69889: LIST
69890: LIST
69891: LIST
69892: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69893: LD_ADDR_VAR 0 44
69897: PUSH
69898: LD_INT 0
69900: PUSH
69901: LD_INT 0
69903: PUSH
69904: EMPTY
69905: LIST
69906: LIST
69907: PUSH
69908: LD_INT 0
69910: PUSH
69911: LD_INT 1
69913: NEG
69914: PUSH
69915: EMPTY
69916: LIST
69917: LIST
69918: PUSH
69919: LD_INT 1
69921: PUSH
69922: LD_INT 0
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PUSH
69929: LD_INT 1
69931: PUSH
69932: LD_INT 1
69934: PUSH
69935: EMPTY
69936: LIST
69937: LIST
69938: PUSH
69939: LD_INT 0
69941: PUSH
69942: LD_INT 1
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: PUSH
69949: LD_INT 1
69951: NEG
69952: PUSH
69953: LD_INT 0
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: LD_INT 1
69962: NEG
69963: PUSH
69964: LD_INT 1
69966: NEG
69967: PUSH
69968: EMPTY
69969: LIST
69970: LIST
69971: PUSH
69972: LD_INT 1
69974: NEG
69975: PUSH
69976: LD_INT 2
69978: NEG
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: PUSH
69984: LD_INT 1
69986: PUSH
69987: LD_INT 1
69989: NEG
69990: PUSH
69991: EMPTY
69992: LIST
69993: LIST
69994: PUSH
69995: LD_INT 2
69997: PUSH
69998: LD_INT 0
70000: PUSH
70001: EMPTY
70002: LIST
70003: LIST
70004: PUSH
70005: LD_INT 2
70007: PUSH
70008: LD_INT 1
70010: PUSH
70011: EMPTY
70012: LIST
70013: LIST
70014: PUSH
70015: LD_INT 2
70017: PUSH
70018: LD_INT 2
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: PUSH
70025: LD_INT 1
70027: PUSH
70028: LD_INT 2
70030: PUSH
70031: EMPTY
70032: LIST
70033: LIST
70034: PUSH
70035: LD_INT 1
70037: NEG
70038: PUSH
70039: LD_INT 1
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: PUSH
70046: LD_INT 2
70048: NEG
70049: PUSH
70050: LD_INT 0
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: PUSH
70057: LD_INT 2
70059: NEG
70060: PUSH
70061: LD_INT 1
70063: NEG
70064: PUSH
70065: EMPTY
70066: LIST
70067: LIST
70068: PUSH
70069: LD_INT 2
70071: NEG
70072: PUSH
70073: LD_INT 2
70075: NEG
70076: PUSH
70077: EMPTY
70078: LIST
70079: LIST
70080: PUSH
70081: LD_INT 2
70083: NEG
70084: PUSH
70085: LD_INT 3
70087: NEG
70088: PUSH
70089: EMPTY
70090: LIST
70091: LIST
70092: PUSH
70093: LD_INT 2
70095: PUSH
70096: LD_INT 1
70098: NEG
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 3
70106: PUSH
70107: LD_INT 0
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 3
70116: PUSH
70117: LD_INT 1
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 3
70126: PUSH
70127: LD_INT 2
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: PUSH
70134: LD_INT 3
70136: PUSH
70137: LD_INT 3
70139: PUSH
70140: EMPTY
70141: LIST
70142: LIST
70143: PUSH
70144: LD_INT 2
70146: PUSH
70147: LD_INT 3
70149: PUSH
70150: EMPTY
70151: LIST
70152: LIST
70153: PUSH
70154: LD_INT 2
70156: NEG
70157: PUSH
70158: LD_INT 1
70160: PUSH
70161: EMPTY
70162: LIST
70163: LIST
70164: PUSH
70165: LD_INT 3
70167: NEG
70168: PUSH
70169: LD_INT 0
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 3
70178: NEG
70179: PUSH
70180: LD_INT 1
70182: NEG
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PUSH
70188: LD_INT 3
70190: NEG
70191: PUSH
70192: LD_INT 2
70194: NEG
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: PUSH
70200: LD_INT 3
70202: NEG
70203: PUSH
70204: LD_INT 3
70206: NEG
70207: PUSH
70208: EMPTY
70209: LIST
70210: LIST
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: LIST
70216: LIST
70217: LIST
70218: LIST
70219: LIST
70220: LIST
70221: LIST
70222: LIST
70223: LIST
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: LIST
70231: LIST
70232: LIST
70233: LIST
70234: LIST
70235: LIST
70236: LIST
70237: LIST
70238: LIST
70239: LIST
70240: LIST
70241: LIST
70242: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70243: LD_ADDR_VAR 0 45
70247: PUSH
70248: LD_INT 0
70250: PUSH
70251: LD_INT 0
70253: PUSH
70254: EMPTY
70255: LIST
70256: LIST
70257: PUSH
70258: LD_INT 0
70260: PUSH
70261: LD_INT 1
70263: NEG
70264: PUSH
70265: EMPTY
70266: LIST
70267: LIST
70268: PUSH
70269: LD_INT 1
70271: PUSH
70272: LD_INT 0
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PUSH
70279: LD_INT 1
70281: PUSH
70282: LD_INT 1
70284: PUSH
70285: EMPTY
70286: LIST
70287: LIST
70288: PUSH
70289: LD_INT 0
70291: PUSH
70292: LD_INT 1
70294: PUSH
70295: EMPTY
70296: LIST
70297: LIST
70298: PUSH
70299: LD_INT 1
70301: NEG
70302: PUSH
70303: LD_INT 0
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: LD_INT 1
70312: NEG
70313: PUSH
70314: LD_INT 1
70316: NEG
70317: PUSH
70318: EMPTY
70319: LIST
70320: LIST
70321: PUSH
70322: LD_INT 1
70324: NEG
70325: PUSH
70326: LD_INT 2
70328: NEG
70329: PUSH
70330: EMPTY
70331: LIST
70332: LIST
70333: PUSH
70334: LD_INT 0
70336: PUSH
70337: LD_INT 2
70339: NEG
70340: PUSH
70341: EMPTY
70342: LIST
70343: LIST
70344: PUSH
70345: LD_INT 1
70347: PUSH
70348: LD_INT 1
70350: NEG
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: PUSH
70356: LD_INT 2
70358: PUSH
70359: LD_INT 1
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: PUSH
70366: LD_INT 2
70368: PUSH
70369: LD_INT 2
70371: PUSH
70372: EMPTY
70373: LIST
70374: LIST
70375: PUSH
70376: LD_INT 1
70378: PUSH
70379: LD_INT 2
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PUSH
70386: LD_INT 0
70388: PUSH
70389: LD_INT 2
70391: PUSH
70392: EMPTY
70393: LIST
70394: LIST
70395: PUSH
70396: LD_INT 1
70398: NEG
70399: PUSH
70400: LD_INT 1
70402: PUSH
70403: EMPTY
70404: LIST
70405: LIST
70406: PUSH
70407: LD_INT 2
70409: NEG
70410: PUSH
70411: LD_INT 1
70413: NEG
70414: PUSH
70415: EMPTY
70416: LIST
70417: LIST
70418: PUSH
70419: LD_INT 2
70421: NEG
70422: PUSH
70423: LD_INT 2
70425: NEG
70426: PUSH
70427: EMPTY
70428: LIST
70429: LIST
70430: PUSH
70431: LD_INT 2
70433: NEG
70434: PUSH
70435: LD_INT 3
70437: NEG
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: PUSH
70443: LD_INT 1
70445: NEG
70446: PUSH
70447: LD_INT 3
70449: NEG
70450: PUSH
70451: EMPTY
70452: LIST
70453: LIST
70454: PUSH
70455: LD_INT 0
70457: PUSH
70458: LD_INT 3
70460: NEG
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: LD_INT 1
70468: PUSH
70469: LD_INT 2
70471: NEG
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 3
70479: PUSH
70480: LD_INT 2
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 3
70489: PUSH
70490: LD_INT 3
70492: PUSH
70493: EMPTY
70494: LIST
70495: LIST
70496: PUSH
70497: LD_INT 2
70499: PUSH
70500: LD_INT 3
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: PUSH
70507: LD_INT 1
70509: PUSH
70510: LD_INT 3
70512: PUSH
70513: EMPTY
70514: LIST
70515: LIST
70516: PUSH
70517: LD_INT 0
70519: PUSH
70520: LD_INT 3
70522: PUSH
70523: EMPTY
70524: LIST
70525: LIST
70526: PUSH
70527: LD_INT 1
70529: NEG
70530: PUSH
70531: LD_INT 2
70533: PUSH
70534: EMPTY
70535: LIST
70536: LIST
70537: PUSH
70538: LD_INT 3
70540: NEG
70541: PUSH
70542: LD_INT 2
70544: NEG
70545: PUSH
70546: EMPTY
70547: LIST
70548: LIST
70549: PUSH
70550: LD_INT 3
70552: NEG
70553: PUSH
70554: LD_INT 3
70556: NEG
70557: PUSH
70558: EMPTY
70559: LIST
70560: LIST
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: LIST
70566: LIST
70567: LIST
70568: LIST
70569: LIST
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: LIST
70586: LIST
70587: LIST
70588: LIST
70589: LIST
70590: LIST
70591: LIST
70592: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70593: LD_ADDR_VAR 0 46
70597: PUSH
70598: LD_INT 0
70600: PUSH
70601: LD_INT 0
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 0
70610: PUSH
70611: LD_INT 1
70613: NEG
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: PUSH
70619: LD_INT 1
70621: PUSH
70622: LD_INT 0
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 1
70631: PUSH
70632: LD_INT 1
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 0
70641: PUSH
70642: LD_INT 1
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: PUSH
70649: LD_INT 1
70651: NEG
70652: PUSH
70653: LD_INT 0
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: LD_INT 1
70662: NEG
70663: PUSH
70664: LD_INT 1
70666: NEG
70667: PUSH
70668: EMPTY
70669: LIST
70670: LIST
70671: PUSH
70672: LD_INT 1
70674: NEG
70675: PUSH
70676: LD_INT 2
70678: NEG
70679: PUSH
70680: EMPTY
70681: LIST
70682: LIST
70683: PUSH
70684: LD_INT 0
70686: PUSH
70687: LD_INT 2
70689: NEG
70690: PUSH
70691: EMPTY
70692: LIST
70693: LIST
70694: PUSH
70695: LD_INT 1
70697: PUSH
70698: LD_INT 1
70700: NEG
70701: PUSH
70702: EMPTY
70703: LIST
70704: LIST
70705: PUSH
70706: LD_INT 2
70708: PUSH
70709: LD_INT 0
70711: PUSH
70712: EMPTY
70713: LIST
70714: LIST
70715: PUSH
70716: LD_INT 2
70718: PUSH
70719: LD_INT 1
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: PUSH
70726: LD_INT 1
70728: PUSH
70729: LD_INT 2
70731: PUSH
70732: EMPTY
70733: LIST
70734: LIST
70735: PUSH
70736: LD_INT 0
70738: PUSH
70739: LD_INT 2
70741: PUSH
70742: EMPTY
70743: LIST
70744: LIST
70745: PUSH
70746: LD_INT 1
70748: NEG
70749: PUSH
70750: LD_INT 1
70752: PUSH
70753: EMPTY
70754: LIST
70755: LIST
70756: PUSH
70757: LD_INT 2
70759: NEG
70760: PUSH
70761: LD_INT 0
70763: PUSH
70764: EMPTY
70765: LIST
70766: LIST
70767: PUSH
70768: LD_INT 2
70770: NEG
70771: PUSH
70772: LD_INT 1
70774: NEG
70775: PUSH
70776: EMPTY
70777: LIST
70778: LIST
70779: PUSH
70780: LD_INT 1
70782: NEG
70783: PUSH
70784: LD_INT 3
70786: NEG
70787: PUSH
70788: EMPTY
70789: LIST
70790: LIST
70791: PUSH
70792: LD_INT 0
70794: PUSH
70795: LD_INT 3
70797: NEG
70798: PUSH
70799: EMPTY
70800: LIST
70801: LIST
70802: PUSH
70803: LD_INT 1
70805: PUSH
70806: LD_INT 2
70808: NEG
70809: PUSH
70810: EMPTY
70811: LIST
70812: LIST
70813: PUSH
70814: LD_INT 2
70816: PUSH
70817: LD_INT 1
70819: NEG
70820: PUSH
70821: EMPTY
70822: LIST
70823: LIST
70824: PUSH
70825: LD_INT 3
70827: PUSH
70828: LD_INT 0
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PUSH
70835: LD_INT 3
70837: PUSH
70838: LD_INT 1
70840: PUSH
70841: EMPTY
70842: LIST
70843: LIST
70844: PUSH
70845: LD_INT 1
70847: PUSH
70848: LD_INT 3
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: LD_INT 0
70857: PUSH
70858: LD_INT 3
70860: PUSH
70861: EMPTY
70862: LIST
70863: LIST
70864: PUSH
70865: LD_INT 1
70867: NEG
70868: PUSH
70869: LD_INT 2
70871: PUSH
70872: EMPTY
70873: LIST
70874: LIST
70875: PUSH
70876: LD_INT 2
70878: NEG
70879: PUSH
70880: LD_INT 1
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 3
70889: NEG
70890: PUSH
70891: LD_INT 0
70893: PUSH
70894: EMPTY
70895: LIST
70896: LIST
70897: PUSH
70898: LD_INT 3
70900: NEG
70901: PUSH
70902: LD_INT 1
70904: NEG
70905: PUSH
70906: EMPTY
70907: LIST
70908: LIST
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: LIST
70925: LIST
70926: LIST
70927: LIST
70928: LIST
70929: LIST
70930: LIST
70931: LIST
70932: LIST
70933: LIST
70934: LIST
70935: LIST
70936: LIST
70937: LIST
70938: LIST
70939: LIST
70940: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70941: LD_ADDR_VAR 0 47
70945: PUSH
70946: LD_INT 0
70948: PUSH
70949: LD_INT 0
70951: PUSH
70952: EMPTY
70953: LIST
70954: LIST
70955: PUSH
70956: LD_INT 0
70958: PUSH
70959: LD_INT 1
70961: NEG
70962: PUSH
70963: EMPTY
70964: LIST
70965: LIST
70966: PUSH
70967: LD_INT 1
70969: PUSH
70970: LD_INT 0
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: PUSH
70977: LD_INT 1
70979: PUSH
70980: LD_INT 1
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: PUSH
70987: LD_INT 0
70989: PUSH
70990: LD_INT 1
70992: PUSH
70993: EMPTY
70994: LIST
70995: LIST
70996: PUSH
70997: LD_INT 1
70999: NEG
71000: PUSH
71001: LD_INT 0
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: PUSH
71008: LD_INT 1
71010: NEG
71011: PUSH
71012: LD_INT 1
71014: NEG
71015: PUSH
71016: EMPTY
71017: LIST
71018: LIST
71019: PUSH
71020: LD_INT 1
71022: NEG
71023: PUSH
71024: LD_INT 2
71026: NEG
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: PUSH
71032: LD_INT 0
71034: PUSH
71035: LD_INT 2
71037: NEG
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: PUSH
71043: LD_INT 1
71045: PUSH
71046: LD_INT 1
71048: NEG
71049: PUSH
71050: EMPTY
71051: LIST
71052: LIST
71053: PUSH
71054: LD_INT 2
71056: NEG
71057: PUSH
71058: LD_INT 1
71060: NEG
71061: PUSH
71062: EMPTY
71063: LIST
71064: LIST
71065: PUSH
71066: LD_INT 2
71068: NEG
71069: PUSH
71070: LD_INT 2
71072: NEG
71073: PUSH
71074: EMPTY
71075: LIST
71076: LIST
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71092: LD_ADDR_VAR 0 48
71096: PUSH
71097: LD_INT 0
71099: PUSH
71100: LD_INT 0
71102: PUSH
71103: EMPTY
71104: LIST
71105: LIST
71106: PUSH
71107: LD_INT 0
71109: PUSH
71110: LD_INT 1
71112: NEG
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: PUSH
71118: LD_INT 1
71120: PUSH
71121: LD_INT 0
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PUSH
71128: LD_INT 1
71130: PUSH
71131: LD_INT 1
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 0
71140: PUSH
71141: LD_INT 1
71143: PUSH
71144: EMPTY
71145: LIST
71146: LIST
71147: PUSH
71148: LD_INT 1
71150: NEG
71151: PUSH
71152: LD_INT 0
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 1
71161: NEG
71162: PUSH
71163: LD_INT 1
71165: NEG
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PUSH
71171: LD_INT 1
71173: NEG
71174: PUSH
71175: LD_INT 2
71177: NEG
71178: PUSH
71179: EMPTY
71180: LIST
71181: LIST
71182: PUSH
71183: LD_INT 0
71185: PUSH
71186: LD_INT 2
71188: NEG
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PUSH
71194: LD_INT 1
71196: PUSH
71197: LD_INT 1
71199: NEG
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: LD_INT 2
71207: PUSH
71208: LD_INT 0
71210: PUSH
71211: EMPTY
71212: LIST
71213: LIST
71214: PUSH
71215: LD_INT 2
71217: PUSH
71218: LD_INT 1
71220: PUSH
71221: EMPTY
71222: LIST
71223: LIST
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: LIST
71229: LIST
71230: LIST
71231: LIST
71232: LIST
71233: LIST
71234: LIST
71235: LIST
71236: LIST
71237: LIST
71238: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
71239: LD_ADDR_VAR 0 49
71243: PUSH
71244: LD_INT 0
71246: PUSH
71247: LD_INT 0
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: PUSH
71254: LD_INT 0
71256: PUSH
71257: LD_INT 1
71259: NEG
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PUSH
71265: LD_INT 1
71267: PUSH
71268: LD_INT 0
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PUSH
71275: LD_INT 1
71277: PUSH
71278: LD_INT 1
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: PUSH
71285: LD_INT 0
71287: PUSH
71288: LD_INT 1
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: PUSH
71295: LD_INT 1
71297: NEG
71298: PUSH
71299: LD_INT 0
71301: PUSH
71302: EMPTY
71303: LIST
71304: LIST
71305: PUSH
71306: LD_INT 1
71308: NEG
71309: PUSH
71310: LD_INT 1
71312: NEG
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 1
71320: PUSH
71321: LD_INT 1
71323: NEG
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: PUSH
71329: LD_INT 2
71331: PUSH
71332: LD_INT 0
71334: PUSH
71335: EMPTY
71336: LIST
71337: LIST
71338: PUSH
71339: LD_INT 2
71341: PUSH
71342: LD_INT 1
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: PUSH
71349: LD_INT 2
71351: PUSH
71352: LD_INT 2
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: PUSH
71359: LD_INT 1
71361: PUSH
71362: LD_INT 2
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: LIST
71377: LIST
71378: LIST
71379: LIST
71380: LIST
71381: LIST
71382: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
71383: LD_ADDR_VAR 0 50
71387: PUSH
71388: LD_INT 0
71390: PUSH
71391: LD_INT 0
71393: PUSH
71394: EMPTY
71395: LIST
71396: LIST
71397: PUSH
71398: LD_INT 0
71400: PUSH
71401: LD_INT 1
71403: NEG
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: PUSH
71409: LD_INT 1
71411: PUSH
71412: LD_INT 0
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: LD_INT 1
71421: PUSH
71422: LD_INT 1
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PUSH
71429: LD_INT 0
71431: PUSH
71432: LD_INT 1
71434: PUSH
71435: EMPTY
71436: LIST
71437: LIST
71438: PUSH
71439: LD_INT 1
71441: NEG
71442: PUSH
71443: LD_INT 0
71445: PUSH
71446: EMPTY
71447: LIST
71448: LIST
71449: PUSH
71450: LD_INT 1
71452: NEG
71453: PUSH
71454: LD_INT 1
71456: NEG
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: LD_INT 2
71464: PUSH
71465: LD_INT 1
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: PUSH
71472: LD_INT 2
71474: PUSH
71475: LD_INT 2
71477: PUSH
71478: EMPTY
71479: LIST
71480: LIST
71481: PUSH
71482: LD_INT 1
71484: PUSH
71485: LD_INT 2
71487: PUSH
71488: EMPTY
71489: LIST
71490: LIST
71491: PUSH
71492: LD_INT 0
71494: PUSH
71495: LD_INT 2
71497: PUSH
71498: EMPTY
71499: LIST
71500: LIST
71501: PUSH
71502: LD_INT 1
71504: NEG
71505: PUSH
71506: LD_INT 1
71508: PUSH
71509: EMPTY
71510: LIST
71511: LIST
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: LIST
71517: LIST
71518: LIST
71519: LIST
71520: LIST
71521: LIST
71522: LIST
71523: LIST
71524: LIST
71525: LIST
71526: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
71527: LD_ADDR_VAR 0 51
71531: PUSH
71532: LD_INT 0
71534: PUSH
71535: LD_INT 0
71537: PUSH
71538: EMPTY
71539: LIST
71540: LIST
71541: PUSH
71542: LD_INT 0
71544: PUSH
71545: LD_INT 1
71547: NEG
71548: PUSH
71549: EMPTY
71550: LIST
71551: LIST
71552: PUSH
71553: LD_INT 1
71555: PUSH
71556: LD_INT 0
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: LD_INT 1
71565: PUSH
71566: LD_INT 1
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 0
71575: PUSH
71576: LD_INT 1
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PUSH
71583: LD_INT 1
71585: NEG
71586: PUSH
71587: LD_INT 0
71589: PUSH
71590: EMPTY
71591: LIST
71592: LIST
71593: PUSH
71594: LD_INT 1
71596: NEG
71597: PUSH
71598: LD_INT 1
71600: NEG
71601: PUSH
71602: EMPTY
71603: LIST
71604: LIST
71605: PUSH
71606: LD_INT 1
71608: PUSH
71609: LD_INT 2
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: PUSH
71616: LD_INT 0
71618: PUSH
71619: LD_INT 2
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: PUSH
71626: LD_INT 1
71628: NEG
71629: PUSH
71630: LD_INT 1
71632: PUSH
71633: EMPTY
71634: LIST
71635: LIST
71636: PUSH
71637: LD_INT 2
71639: NEG
71640: PUSH
71641: LD_INT 0
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: PUSH
71648: LD_INT 2
71650: NEG
71651: PUSH
71652: LD_INT 1
71654: NEG
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: PUSH
71660: EMPTY
71661: LIST
71662: LIST
71663: LIST
71664: LIST
71665: LIST
71666: LIST
71667: LIST
71668: LIST
71669: LIST
71670: LIST
71671: LIST
71672: LIST
71673: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71674: LD_ADDR_VAR 0 52
71678: PUSH
71679: LD_INT 0
71681: PUSH
71682: LD_INT 0
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 0
71691: PUSH
71692: LD_INT 1
71694: NEG
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: PUSH
71700: LD_INT 1
71702: PUSH
71703: LD_INT 0
71705: PUSH
71706: EMPTY
71707: LIST
71708: LIST
71709: PUSH
71710: LD_INT 1
71712: PUSH
71713: LD_INT 1
71715: PUSH
71716: EMPTY
71717: LIST
71718: LIST
71719: PUSH
71720: LD_INT 0
71722: PUSH
71723: LD_INT 1
71725: PUSH
71726: EMPTY
71727: LIST
71728: LIST
71729: PUSH
71730: LD_INT 1
71732: NEG
71733: PUSH
71734: LD_INT 0
71736: PUSH
71737: EMPTY
71738: LIST
71739: LIST
71740: PUSH
71741: LD_INT 1
71743: NEG
71744: PUSH
71745: LD_INT 1
71747: NEG
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: PUSH
71753: LD_INT 1
71755: NEG
71756: PUSH
71757: LD_INT 2
71759: NEG
71760: PUSH
71761: EMPTY
71762: LIST
71763: LIST
71764: PUSH
71765: LD_INT 1
71767: NEG
71768: PUSH
71769: LD_INT 1
71771: PUSH
71772: EMPTY
71773: LIST
71774: LIST
71775: PUSH
71776: LD_INT 2
71778: NEG
71779: PUSH
71780: LD_INT 0
71782: PUSH
71783: EMPTY
71784: LIST
71785: LIST
71786: PUSH
71787: LD_INT 2
71789: NEG
71790: PUSH
71791: LD_INT 1
71793: NEG
71794: PUSH
71795: EMPTY
71796: LIST
71797: LIST
71798: PUSH
71799: LD_INT 2
71801: NEG
71802: PUSH
71803: LD_INT 2
71805: NEG
71806: PUSH
71807: EMPTY
71808: LIST
71809: LIST
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: LIST
71815: LIST
71816: LIST
71817: LIST
71818: LIST
71819: LIST
71820: LIST
71821: LIST
71822: LIST
71823: LIST
71824: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71825: LD_ADDR_VAR 0 53
71829: PUSH
71830: LD_INT 0
71832: PUSH
71833: LD_INT 0
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: PUSH
71840: LD_INT 0
71842: PUSH
71843: LD_INT 1
71845: NEG
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: PUSH
71851: LD_INT 1
71853: PUSH
71854: LD_INT 0
71856: PUSH
71857: EMPTY
71858: LIST
71859: LIST
71860: PUSH
71861: LD_INT 1
71863: PUSH
71864: LD_INT 1
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: PUSH
71871: LD_INT 0
71873: PUSH
71874: LD_INT 1
71876: PUSH
71877: EMPTY
71878: LIST
71879: LIST
71880: PUSH
71881: LD_INT 1
71883: NEG
71884: PUSH
71885: LD_INT 0
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 1
71894: NEG
71895: PUSH
71896: LD_INT 1
71898: NEG
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 1
71906: NEG
71907: PUSH
71908: LD_INT 2
71910: NEG
71911: PUSH
71912: EMPTY
71913: LIST
71914: LIST
71915: PUSH
71916: LD_INT 0
71918: PUSH
71919: LD_INT 2
71921: NEG
71922: PUSH
71923: EMPTY
71924: LIST
71925: LIST
71926: PUSH
71927: LD_INT 1
71929: PUSH
71930: LD_INT 1
71932: NEG
71933: PUSH
71934: EMPTY
71935: LIST
71936: LIST
71937: PUSH
71938: LD_INT 2
71940: PUSH
71941: LD_INT 0
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: PUSH
71948: LD_INT 2
71950: PUSH
71951: LD_INT 1
71953: PUSH
71954: EMPTY
71955: LIST
71956: LIST
71957: PUSH
71958: LD_INT 2
71960: PUSH
71961: LD_INT 2
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: PUSH
71968: LD_INT 1
71970: PUSH
71971: LD_INT 2
71973: PUSH
71974: EMPTY
71975: LIST
71976: LIST
71977: PUSH
71978: LD_INT 0
71980: PUSH
71981: LD_INT 2
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: LD_INT 1
71990: NEG
71991: PUSH
71992: LD_INT 1
71994: PUSH
71995: EMPTY
71996: LIST
71997: LIST
71998: PUSH
71999: LD_INT 2
72001: NEG
72002: PUSH
72003: LD_INT 0
72005: PUSH
72006: EMPTY
72007: LIST
72008: LIST
72009: PUSH
72010: LD_INT 2
72012: NEG
72013: PUSH
72014: LD_INT 1
72016: NEG
72017: PUSH
72018: EMPTY
72019: LIST
72020: LIST
72021: PUSH
72022: LD_INT 2
72024: NEG
72025: PUSH
72026: LD_INT 2
72028: NEG
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: PUSH
72034: EMPTY
72035: LIST
72036: LIST
72037: LIST
72038: LIST
72039: LIST
72040: LIST
72041: LIST
72042: LIST
72043: LIST
72044: LIST
72045: LIST
72046: LIST
72047: LIST
72048: LIST
72049: LIST
72050: LIST
72051: LIST
72052: LIST
72053: LIST
72054: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72055: LD_ADDR_VAR 0 54
72059: PUSH
72060: LD_INT 0
72062: PUSH
72063: LD_INT 0
72065: PUSH
72066: EMPTY
72067: LIST
72068: LIST
72069: PUSH
72070: LD_INT 0
72072: PUSH
72073: LD_INT 1
72075: NEG
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: PUSH
72081: LD_INT 1
72083: PUSH
72084: LD_INT 0
72086: PUSH
72087: EMPTY
72088: LIST
72089: LIST
72090: PUSH
72091: LD_INT 1
72093: PUSH
72094: LD_INT 1
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: PUSH
72101: LD_INT 0
72103: PUSH
72104: LD_INT 1
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 1
72113: NEG
72114: PUSH
72115: LD_INT 0
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: PUSH
72122: LD_INT 1
72124: NEG
72125: PUSH
72126: LD_INT 1
72128: NEG
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: LD_INT 1
72136: NEG
72137: PUSH
72138: LD_INT 2
72140: NEG
72141: PUSH
72142: EMPTY
72143: LIST
72144: LIST
72145: PUSH
72146: LD_INT 0
72148: PUSH
72149: LD_INT 2
72151: NEG
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: PUSH
72157: LD_INT 1
72159: PUSH
72160: LD_INT 1
72162: NEG
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: PUSH
72168: LD_INT 2
72170: PUSH
72171: LD_INT 0
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: PUSH
72178: LD_INT 2
72180: PUSH
72181: LD_INT 1
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: PUSH
72188: LD_INT 2
72190: PUSH
72191: LD_INT 2
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 1
72200: PUSH
72201: LD_INT 2
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 0
72210: PUSH
72211: LD_INT 2
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 1
72220: NEG
72221: PUSH
72222: LD_INT 1
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PUSH
72229: LD_INT 2
72231: NEG
72232: PUSH
72233: LD_INT 0
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: PUSH
72240: LD_INT 2
72242: NEG
72243: PUSH
72244: LD_INT 1
72246: NEG
72247: PUSH
72248: EMPTY
72249: LIST
72250: LIST
72251: PUSH
72252: LD_INT 2
72254: NEG
72255: PUSH
72256: LD_INT 2
72258: NEG
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: EMPTY
72265: LIST
72266: LIST
72267: LIST
72268: LIST
72269: LIST
72270: LIST
72271: LIST
72272: LIST
72273: LIST
72274: LIST
72275: LIST
72276: LIST
72277: LIST
72278: LIST
72279: LIST
72280: LIST
72281: LIST
72282: LIST
72283: LIST
72284: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72285: LD_ADDR_VAR 0 55
72289: PUSH
72290: LD_INT 0
72292: PUSH
72293: LD_INT 0
72295: PUSH
72296: EMPTY
72297: LIST
72298: LIST
72299: PUSH
72300: LD_INT 0
72302: PUSH
72303: LD_INT 1
72305: NEG
72306: PUSH
72307: EMPTY
72308: LIST
72309: LIST
72310: PUSH
72311: LD_INT 1
72313: PUSH
72314: LD_INT 0
72316: PUSH
72317: EMPTY
72318: LIST
72319: LIST
72320: PUSH
72321: LD_INT 1
72323: PUSH
72324: LD_INT 1
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: PUSH
72331: LD_INT 0
72333: PUSH
72334: LD_INT 1
72336: PUSH
72337: EMPTY
72338: LIST
72339: LIST
72340: PUSH
72341: LD_INT 1
72343: NEG
72344: PUSH
72345: LD_INT 0
72347: PUSH
72348: EMPTY
72349: LIST
72350: LIST
72351: PUSH
72352: LD_INT 1
72354: NEG
72355: PUSH
72356: LD_INT 1
72358: NEG
72359: PUSH
72360: EMPTY
72361: LIST
72362: LIST
72363: PUSH
72364: LD_INT 1
72366: NEG
72367: PUSH
72368: LD_INT 2
72370: NEG
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: PUSH
72376: LD_INT 0
72378: PUSH
72379: LD_INT 2
72381: NEG
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: PUSH
72387: LD_INT 1
72389: PUSH
72390: LD_INT 1
72392: NEG
72393: PUSH
72394: EMPTY
72395: LIST
72396: LIST
72397: PUSH
72398: LD_INT 2
72400: PUSH
72401: LD_INT 0
72403: PUSH
72404: EMPTY
72405: LIST
72406: LIST
72407: PUSH
72408: LD_INT 2
72410: PUSH
72411: LD_INT 1
72413: PUSH
72414: EMPTY
72415: LIST
72416: LIST
72417: PUSH
72418: LD_INT 2
72420: PUSH
72421: LD_INT 2
72423: PUSH
72424: EMPTY
72425: LIST
72426: LIST
72427: PUSH
72428: LD_INT 1
72430: PUSH
72431: LD_INT 2
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PUSH
72438: LD_INT 0
72440: PUSH
72441: LD_INT 2
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: PUSH
72448: LD_INT 1
72450: NEG
72451: PUSH
72452: LD_INT 1
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: PUSH
72459: LD_INT 2
72461: NEG
72462: PUSH
72463: LD_INT 0
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: PUSH
72470: LD_INT 2
72472: NEG
72473: PUSH
72474: LD_INT 1
72476: NEG
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: LD_INT 2
72484: NEG
72485: PUSH
72486: LD_INT 2
72488: NEG
72489: PUSH
72490: EMPTY
72491: LIST
72492: LIST
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: LIST
72498: LIST
72499: LIST
72500: LIST
72501: LIST
72502: LIST
72503: LIST
72504: LIST
72505: LIST
72506: LIST
72507: LIST
72508: LIST
72509: LIST
72510: LIST
72511: LIST
72512: LIST
72513: LIST
72514: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72515: LD_ADDR_VAR 0 56
72519: PUSH
72520: LD_INT 0
72522: PUSH
72523: LD_INT 0
72525: PUSH
72526: EMPTY
72527: LIST
72528: LIST
72529: PUSH
72530: LD_INT 0
72532: PUSH
72533: LD_INT 1
72535: NEG
72536: PUSH
72537: EMPTY
72538: LIST
72539: LIST
72540: PUSH
72541: LD_INT 1
72543: PUSH
72544: LD_INT 0
72546: PUSH
72547: EMPTY
72548: LIST
72549: LIST
72550: PUSH
72551: LD_INT 1
72553: PUSH
72554: LD_INT 1
72556: PUSH
72557: EMPTY
72558: LIST
72559: LIST
72560: PUSH
72561: LD_INT 0
72563: PUSH
72564: LD_INT 1
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: PUSH
72571: LD_INT 1
72573: NEG
72574: PUSH
72575: LD_INT 0
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PUSH
72582: LD_INT 1
72584: NEG
72585: PUSH
72586: LD_INT 1
72588: NEG
72589: PUSH
72590: EMPTY
72591: LIST
72592: LIST
72593: PUSH
72594: LD_INT 1
72596: NEG
72597: PUSH
72598: LD_INT 2
72600: NEG
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: PUSH
72606: LD_INT 0
72608: PUSH
72609: LD_INT 2
72611: NEG
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: PUSH
72617: LD_INT 1
72619: PUSH
72620: LD_INT 1
72622: NEG
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: PUSH
72628: LD_INT 2
72630: PUSH
72631: LD_INT 0
72633: PUSH
72634: EMPTY
72635: LIST
72636: LIST
72637: PUSH
72638: LD_INT 2
72640: PUSH
72641: LD_INT 1
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: PUSH
72648: LD_INT 2
72650: PUSH
72651: LD_INT 2
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: PUSH
72658: LD_INT 1
72660: PUSH
72661: LD_INT 2
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: LD_INT 0
72670: PUSH
72671: LD_INT 2
72673: PUSH
72674: EMPTY
72675: LIST
72676: LIST
72677: PUSH
72678: LD_INT 1
72680: NEG
72681: PUSH
72682: LD_INT 1
72684: PUSH
72685: EMPTY
72686: LIST
72687: LIST
72688: PUSH
72689: LD_INT 2
72691: NEG
72692: PUSH
72693: LD_INT 0
72695: PUSH
72696: EMPTY
72697: LIST
72698: LIST
72699: PUSH
72700: LD_INT 2
72702: NEG
72703: PUSH
72704: LD_INT 1
72706: NEG
72707: PUSH
72708: EMPTY
72709: LIST
72710: LIST
72711: PUSH
72712: LD_INT 2
72714: NEG
72715: PUSH
72716: LD_INT 2
72718: NEG
72719: PUSH
72720: EMPTY
72721: LIST
72722: LIST
72723: PUSH
72724: EMPTY
72725: LIST
72726: LIST
72727: LIST
72728: LIST
72729: LIST
72730: LIST
72731: LIST
72732: LIST
72733: LIST
72734: LIST
72735: LIST
72736: LIST
72737: LIST
72738: LIST
72739: LIST
72740: LIST
72741: LIST
72742: LIST
72743: LIST
72744: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72745: LD_ADDR_VAR 0 57
72749: PUSH
72750: LD_INT 0
72752: PUSH
72753: LD_INT 0
72755: PUSH
72756: EMPTY
72757: LIST
72758: LIST
72759: PUSH
72760: LD_INT 0
72762: PUSH
72763: LD_INT 1
72765: NEG
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: PUSH
72771: LD_INT 1
72773: PUSH
72774: LD_INT 0
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: LD_INT 1
72783: PUSH
72784: LD_INT 1
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 0
72793: PUSH
72794: LD_INT 1
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: PUSH
72801: LD_INT 1
72803: NEG
72804: PUSH
72805: LD_INT 0
72807: PUSH
72808: EMPTY
72809: LIST
72810: LIST
72811: PUSH
72812: LD_INT 1
72814: NEG
72815: PUSH
72816: LD_INT 1
72818: NEG
72819: PUSH
72820: EMPTY
72821: LIST
72822: LIST
72823: PUSH
72824: LD_INT 1
72826: NEG
72827: PUSH
72828: LD_INT 2
72830: NEG
72831: PUSH
72832: EMPTY
72833: LIST
72834: LIST
72835: PUSH
72836: LD_INT 0
72838: PUSH
72839: LD_INT 2
72841: NEG
72842: PUSH
72843: EMPTY
72844: LIST
72845: LIST
72846: PUSH
72847: LD_INT 1
72849: PUSH
72850: LD_INT 1
72852: NEG
72853: PUSH
72854: EMPTY
72855: LIST
72856: LIST
72857: PUSH
72858: LD_INT 2
72860: PUSH
72861: LD_INT 0
72863: PUSH
72864: EMPTY
72865: LIST
72866: LIST
72867: PUSH
72868: LD_INT 2
72870: PUSH
72871: LD_INT 1
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: PUSH
72878: LD_INT 2
72880: PUSH
72881: LD_INT 2
72883: PUSH
72884: EMPTY
72885: LIST
72886: LIST
72887: PUSH
72888: LD_INT 1
72890: PUSH
72891: LD_INT 2
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: PUSH
72898: LD_INT 0
72900: PUSH
72901: LD_INT 2
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 1
72910: NEG
72911: PUSH
72912: LD_INT 1
72914: PUSH
72915: EMPTY
72916: LIST
72917: LIST
72918: PUSH
72919: LD_INT 2
72921: NEG
72922: PUSH
72923: LD_INT 0
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: LD_INT 2
72932: NEG
72933: PUSH
72934: LD_INT 1
72936: NEG
72937: PUSH
72938: EMPTY
72939: LIST
72940: LIST
72941: PUSH
72942: LD_INT 2
72944: NEG
72945: PUSH
72946: LD_INT 2
72948: NEG
72949: PUSH
72950: EMPTY
72951: LIST
72952: LIST
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: LIST
72958: LIST
72959: LIST
72960: LIST
72961: LIST
72962: LIST
72963: LIST
72964: LIST
72965: LIST
72966: LIST
72967: LIST
72968: LIST
72969: LIST
72970: LIST
72971: LIST
72972: LIST
72973: LIST
72974: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72975: LD_ADDR_VAR 0 58
72979: PUSH
72980: LD_INT 0
72982: PUSH
72983: LD_INT 0
72985: PUSH
72986: EMPTY
72987: LIST
72988: LIST
72989: PUSH
72990: LD_INT 0
72992: PUSH
72993: LD_INT 1
72995: NEG
72996: PUSH
72997: EMPTY
72998: LIST
72999: LIST
73000: PUSH
73001: LD_INT 1
73003: PUSH
73004: LD_INT 0
73006: PUSH
73007: EMPTY
73008: LIST
73009: LIST
73010: PUSH
73011: LD_INT 1
73013: PUSH
73014: LD_INT 1
73016: PUSH
73017: EMPTY
73018: LIST
73019: LIST
73020: PUSH
73021: LD_INT 0
73023: PUSH
73024: LD_INT 1
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: PUSH
73031: LD_INT 1
73033: NEG
73034: PUSH
73035: LD_INT 0
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: PUSH
73042: LD_INT 1
73044: NEG
73045: PUSH
73046: LD_INT 1
73048: NEG
73049: PUSH
73050: EMPTY
73051: LIST
73052: LIST
73053: PUSH
73054: LD_INT 1
73056: NEG
73057: PUSH
73058: LD_INT 2
73060: NEG
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: PUSH
73066: LD_INT 0
73068: PUSH
73069: LD_INT 2
73071: NEG
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PUSH
73077: LD_INT 1
73079: PUSH
73080: LD_INT 1
73082: NEG
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 2
73090: PUSH
73091: LD_INT 0
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PUSH
73098: LD_INT 2
73100: PUSH
73101: LD_INT 1
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PUSH
73108: LD_INT 2
73110: PUSH
73111: LD_INT 2
73113: PUSH
73114: EMPTY
73115: LIST
73116: LIST
73117: PUSH
73118: LD_INT 1
73120: PUSH
73121: LD_INT 2
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: PUSH
73128: LD_INT 0
73130: PUSH
73131: LD_INT 2
73133: PUSH
73134: EMPTY
73135: LIST
73136: LIST
73137: PUSH
73138: LD_INT 1
73140: NEG
73141: PUSH
73142: LD_INT 1
73144: PUSH
73145: EMPTY
73146: LIST
73147: LIST
73148: PUSH
73149: LD_INT 2
73151: NEG
73152: PUSH
73153: LD_INT 0
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: PUSH
73160: LD_INT 2
73162: NEG
73163: PUSH
73164: LD_INT 1
73166: NEG
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PUSH
73172: LD_INT 2
73174: NEG
73175: PUSH
73176: LD_INT 2
73178: NEG
73179: PUSH
73180: EMPTY
73181: LIST
73182: LIST
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: LIST
73188: LIST
73189: LIST
73190: LIST
73191: LIST
73192: LIST
73193: LIST
73194: LIST
73195: LIST
73196: LIST
73197: LIST
73198: LIST
73199: LIST
73200: LIST
73201: LIST
73202: LIST
73203: LIST
73204: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73205: LD_ADDR_VAR 0 59
73209: PUSH
73210: LD_INT 0
73212: PUSH
73213: LD_INT 0
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PUSH
73220: LD_INT 0
73222: PUSH
73223: LD_INT 1
73225: NEG
73226: PUSH
73227: EMPTY
73228: LIST
73229: LIST
73230: PUSH
73231: LD_INT 1
73233: PUSH
73234: LD_INT 0
73236: PUSH
73237: EMPTY
73238: LIST
73239: LIST
73240: PUSH
73241: LD_INT 1
73243: PUSH
73244: LD_INT 1
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PUSH
73251: LD_INT 0
73253: PUSH
73254: LD_INT 1
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PUSH
73261: LD_INT 1
73263: NEG
73264: PUSH
73265: LD_INT 0
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: PUSH
73272: LD_INT 1
73274: NEG
73275: PUSH
73276: LD_INT 1
73278: NEG
73279: PUSH
73280: EMPTY
73281: LIST
73282: LIST
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73293: LD_ADDR_VAR 0 60
73297: PUSH
73298: LD_INT 0
73300: PUSH
73301: LD_INT 0
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: PUSH
73308: LD_INT 0
73310: PUSH
73311: LD_INT 1
73313: NEG
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PUSH
73319: LD_INT 1
73321: PUSH
73322: LD_INT 0
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PUSH
73329: LD_INT 1
73331: PUSH
73332: LD_INT 1
73334: PUSH
73335: EMPTY
73336: LIST
73337: LIST
73338: PUSH
73339: LD_INT 0
73341: PUSH
73342: LD_INT 1
73344: PUSH
73345: EMPTY
73346: LIST
73347: LIST
73348: PUSH
73349: LD_INT 1
73351: NEG
73352: PUSH
73353: LD_INT 0
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PUSH
73360: LD_INT 1
73362: NEG
73363: PUSH
73364: LD_INT 1
73366: NEG
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: LIST
73378: LIST
73379: LIST
73380: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73381: LD_ADDR_VAR 0 61
73385: PUSH
73386: LD_INT 0
73388: PUSH
73389: LD_INT 0
73391: PUSH
73392: EMPTY
73393: LIST
73394: LIST
73395: PUSH
73396: LD_INT 0
73398: PUSH
73399: LD_INT 1
73401: NEG
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: PUSH
73407: LD_INT 1
73409: PUSH
73410: LD_INT 0
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: PUSH
73417: LD_INT 1
73419: PUSH
73420: LD_INT 1
73422: PUSH
73423: EMPTY
73424: LIST
73425: LIST
73426: PUSH
73427: LD_INT 0
73429: PUSH
73430: LD_INT 1
73432: PUSH
73433: EMPTY
73434: LIST
73435: LIST
73436: PUSH
73437: LD_INT 1
73439: NEG
73440: PUSH
73441: LD_INT 0
73443: PUSH
73444: EMPTY
73445: LIST
73446: LIST
73447: PUSH
73448: LD_INT 1
73450: NEG
73451: PUSH
73452: LD_INT 1
73454: NEG
73455: PUSH
73456: EMPTY
73457: LIST
73458: LIST
73459: PUSH
73460: EMPTY
73461: LIST
73462: LIST
73463: LIST
73464: LIST
73465: LIST
73466: LIST
73467: LIST
73468: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73469: LD_ADDR_VAR 0 62
73473: PUSH
73474: LD_INT 0
73476: PUSH
73477: LD_INT 0
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: PUSH
73484: LD_INT 0
73486: PUSH
73487: LD_INT 1
73489: NEG
73490: PUSH
73491: EMPTY
73492: LIST
73493: LIST
73494: PUSH
73495: LD_INT 1
73497: PUSH
73498: LD_INT 0
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: LD_INT 1
73507: PUSH
73508: LD_INT 1
73510: PUSH
73511: EMPTY
73512: LIST
73513: LIST
73514: PUSH
73515: LD_INT 0
73517: PUSH
73518: LD_INT 1
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: PUSH
73525: LD_INT 1
73527: NEG
73528: PUSH
73529: LD_INT 0
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: LD_INT 1
73538: NEG
73539: PUSH
73540: LD_INT 1
73542: NEG
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: LIST
73552: LIST
73553: LIST
73554: LIST
73555: LIST
73556: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73557: LD_ADDR_VAR 0 63
73561: PUSH
73562: LD_INT 0
73564: PUSH
73565: LD_INT 0
73567: PUSH
73568: EMPTY
73569: LIST
73570: LIST
73571: PUSH
73572: LD_INT 0
73574: PUSH
73575: LD_INT 1
73577: NEG
73578: PUSH
73579: EMPTY
73580: LIST
73581: LIST
73582: PUSH
73583: LD_INT 1
73585: PUSH
73586: LD_INT 0
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: LD_INT 1
73595: PUSH
73596: LD_INT 1
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: PUSH
73603: LD_INT 0
73605: PUSH
73606: LD_INT 1
73608: PUSH
73609: EMPTY
73610: LIST
73611: LIST
73612: PUSH
73613: LD_INT 1
73615: NEG
73616: PUSH
73617: LD_INT 0
73619: PUSH
73620: EMPTY
73621: LIST
73622: LIST
73623: PUSH
73624: LD_INT 1
73626: NEG
73627: PUSH
73628: LD_INT 1
73630: NEG
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: EMPTY
73637: LIST
73638: LIST
73639: LIST
73640: LIST
73641: LIST
73642: LIST
73643: LIST
73644: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73645: LD_ADDR_VAR 0 64
73649: PUSH
73650: LD_INT 0
73652: PUSH
73653: LD_INT 0
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: PUSH
73660: LD_INT 0
73662: PUSH
73663: LD_INT 1
73665: NEG
73666: PUSH
73667: EMPTY
73668: LIST
73669: LIST
73670: PUSH
73671: LD_INT 1
73673: PUSH
73674: LD_INT 0
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: PUSH
73681: LD_INT 1
73683: PUSH
73684: LD_INT 1
73686: PUSH
73687: EMPTY
73688: LIST
73689: LIST
73690: PUSH
73691: LD_INT 0
73693: PUSH
73694: LD_INT 1
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: PUSH
73701: LD_INT 1
73703: NEG
73704: PUSH
73705: LD_INT 0
73707: PUSH
73708: EMPTY
73709: LIST
73710: LIST
73711: PUSH
73712: LD_INT 1
73714: NEG
73715: PUSH
73716: LD_INT 1
73718: NEG
73719: PUSH
73720: EMPTY
73721: LIST
73722: LIST
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: LIST
73728: LIST
73729: LIST
73730: LIST
73731: LIST
73732: ST_TO_ADDR
// end ; 1 :
73733: GO 79630
73735: LD_INT 1
73737: DOUBLE
73738: EQUAL
73739: IFTRUE 73743
73741: GO 76366
73743: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
73744: LD_ADDR_VAR 0 11
73748: PUSH
73749: LD_INT 1
73751: NEG
73752: PUSH
73753: LD_INT 3
73755: NEG
73756: PUSH
73757: EMPTY
73758: LIST
73759: LIST
73760: PUSH
73761: LD_INT 0
73763: PUSH
73764: LD_INT 3
73766: NEG
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: PUSH
73772: LD_INT 1
73774: PUSH
73775: LD_INT 2
73777: NEG
73778: PUSH
73779: EMPTY
73780: LIST
73781: LIST
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: LIST
73787: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
73788: LD_ADDR_VAR 0 12
73792: PUSH
73793: LD_INT 2
73795: PUSH
73796: LD_INT 1
73798: NEG
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 3
73806: PUSH
73807: LD_INT 0
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: PUSH
73814: LD_INT 3
73816: PUSH
73817: LD_INT 1
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: EMPTY
73825: LIST
73826: LIST
73827: LIST
73828: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
73829: LD_ADDR_VAR 0 13
73833: PUSH
73834: LD_INT 3
73836: PUSH
73837: LD_INT 2
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: PUSH
73844: LD_INT 3
73846: PUSH
73847: LD_INT 3
73849: PUSH
73850: EMPTY
73851: LIST
73852: LIST
73853: PUSH
73854: LD_INT 2
73856: PUSH
73857: LD_INT 3
73859: PUSH
73860: EMPTY
73861: LIST
73862: LIST
73863: PUSH
73864: EMPTY
73865: LIST
73866: LIST
73867: LIST
73868: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
73869: LD_ADDR_VAR 0 14
73873: PUSH
73874: LD_INT 1
73876: PUSH
73877: LD_INT 3
73879: PUSH
73880: EMPTY
73881: LIST
73882: LIST
73883: PUSH
73884: LD_INT 0
73886: PUSH
73887: LD_INT 3
73889: PUSH
73890: EMPTY
73891: LIST
73892: LIST
73893: PUSH
73894: LD_INT 1
73896: NEG
73897: PUSH
73898: LD_INT 2
73900: PUSH
73901: EMPTY
73902: LIST
73903: LIST
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: LIST
73909: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73910: LD_ADDR_VAR 0 15
73914: PUSH
73915: LD_INT 2
73917: NEG
73918: PUSH
73919: LD_INT 1
73921: PUSH
73922: EMPTY
73923: LIST
73924: LIST
73925: PUSH
73926: LD_INT 3
73928: NEG
73929: PUSH
73930: LD_INT 0
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: PUSH
73937: LD_INT 3
73939: NEG
73940: PUSH
73941: LD_INT 1
73943: NEG
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: LIST
73953: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73954: LD_ADDR_VAR 0 16
73958: PUSH
73959: LD_INT 2
73961: NEG
73962: PUSH
73963: LD_INT 3
73965: NEG
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 3
73973: NEG
73974: PUSH
73975: LD_INT 2
73977: NEG
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: PUSH
73983: LD_INT 3
73985: NEG
73986: PUSH
73987: LD_INT 3
73989: NEG
73990: PUSH
73991: EMPTY
73992: LIST
73993: LIST
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: LIST
73999: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74000: LD_ADDR_VAR 0 17
74004: PUSH
74005: LD_INT 1
74007: NEG
74008: PUSH
74009: LD_INT 3
74011: NEG
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 0
74019: PUSH
74020: LD_INT 3
74022: NEG
74023: PUSH
74024: EMPTY
74025: LIST
74026: LIST
74027: PUSH
74028: LD_INT 1
74030: PUSH
74031: LD_INT 2
74033: NEG
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: PUSH
74039: EMPTY
74040: LIST
74041: LIST
74042: LIST
74043: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74044: LD_ADDR_VAR 0 18
74048: PUSH
74049: LD_INT 2
74051: PUSH
74052: LD_INT 1
74054: NEG
74055: PUSH
74056: EMPTY
74057: LIST
74058: LIST
74059: PUSH
74060: LD_INT 3
74062: PUSH
74063: LD_INT 0
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: PUSH
74070: LD_INT 3
74072: PUSH
74073: LD_INT 1
74075: PUSH
74076: EMPTY
74077: LIST
74078: LIST
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: LIST
74084: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74085: LD_ADDR_VAR 0 19
74089: PUSH
74090: LD_INT 3
74092: PUSH
74093: LD_INT 2
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: PUSH
74100: LD_INT 3
74102: PUSH
74103: LD_INT 3
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: PUSH
74110: LD_INT 2
74112: PUSH
74113: LD_INT 3
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PUSH
74120: EMPTY
74121: LIST
74122: LIST
74123: LIST
74124: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74125: LD_ADDR_VAR 0 20
74129: PUSH
74130: LD_INT 1
74132: PUSH
74133: LD_INT 3
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: PUSH
74140: LD_INT 0
74142: PUSH
74143: LD_INT 3
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: PUSH
74150: LD_INT 1
74152: NEG
74153: PUSH
74154: LD_INT 2
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: LIST
74165: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74166: LD_ADDR_VAR 0 21
74170: PUSH
74171: LD_INT 2
74173: NEG
74174: PUSH
74175: LD_INT 1
74177: PUSH
74178: EMPTY
74179: LIST
74180: LIST
74181: PUSH
74182: LD_INT 3
74184: NEG
74185: PUSH
74186: LD_INT 0
74188: PUSH
74189: EMPTY
74190: LIST
74191: LIST
74192: PUSH
74193: LD_INT 3
74195: NEG
74196: PUSH
74197: LD_INT 1
74199: NEG
74200: PUSH
74201: EMPTY
74202: LIST
74203: LIST
74204: PUSH
74205: EMPTY
74206: LIST
74207: LIST
74208: LIST
74209: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74210: LD_ADDR_VAR 0 22
74214: PUSH
74215: LD_INT 2
74217: NEG
74218: PUSH
74219: LD_INT 3
74221: NEG
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: PUSH
74227: LD_INT 3
74229: NEG
74230: PUSH
74231: LD_INT 2
74233: NEG
74234: PUSH
74235: EMPTY
74236: LIST
74237: LIST
74238: PUSH
74239: LD_INT 3
74241: NEG
74242: PUSH
74243: LD_INT 3
74245: NEG
74246: PUSH
74247: EMPTY
74248: LIST
74249: LIST
74250: PUSH
74251: EMPTY
74252: LIST
74253: LIST
74254: LIST
74255: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
74256: LD_ADDR_VAR 0 23
74260: PUSH
74261: LD_INT 0
74263: PUSH
74264: LD_INT 3
74266: NEG
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 1
74274: NEG
74275: PUSH
74276: LD_INT 4
74278: NEG
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: LD_INT 1
74286: PUSH
74287: LD_INT 3
74289: NEG
74290: PUSH
74291: EMPTY
74292: LIST
74293: LIST
74294: PUSH
74295: EMPTY
74296: LIST
74297: LIST
74298: LIST
74299: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
74300: LD_ADDR_VAR 0 24
74304: PUSH
74305: LD_INT 3
74307: PUSH
74308: LD_INT 0
74310: PUSH
74311: EMPTY
74312: LIST
74313: LIST
74314: PUSH
74315: LD_INT 3
74317: PUSH
74318: LD_INT 1
74320: NEG
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: LD_INT 4
74328: PUSH
74329: LD_INT 1
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PUSH
74336: EMPTY
74337: LIST
74338: LIST
74339: LIST
74340: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
74341: LD_ADDR_VAR 0 25
74345: PUSH
74346: LD_INT 3
74348: PUSH
74349: LD_INT 3
74351: PUSH
74352: EMPTY
74353: LIST
74354: LIST
74355: PUSH
74356: LD_INT 4
74358: PUSH
74359: LD_INT 3
74361: PUSH
74362: EMPTY
74363: LIST
74364: LIST
74365: PUSH
74366: LD_INT 3
74368: PUSH
74369: LD_INT 4
74371: PUSH
74372: EMPTY
74373: LIST
74374: LIST
74375: PUSH
74376: EMPTY
74377: LIST
74378: LIST
74379: LIST
74380: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
74381: LD_ADDR_VAR 0 26
74385: PUSH
74386: LD_INT 0
74388: PUSH
74389: LD_INT 3
74391: PUSH
74392: EMPTY
74393: LIST
74394: LIST
74395: PUSH
74396: LD_INT 1
74398: PUSH
74399: LD_INT 4
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: PUSH
74406: LD_INT 1
74408: NEG
74409: PUSH
74410: LD_INT 3
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: PUSH
74417: EMPTY
74418: LIST
74419: LIST
74420: LIST
74421: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
74422: LD_ADDR_VAR 0 27
74426: PUSH
74427: LD_INT 3
74429: NEG
74430: PUSH
74431: LD_INT 0
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 3
74440: NEG
74441: PUSH
74442: LD_INT 1
74444: PUSH
74445: EMPTY
74446: LIST
74447: LIST
74448: PUSH
74449: LD_INT 4
74451: NEG
74452: PUSH
74453: LD_INT 1
74455: NEG
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: LIST
74465: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
74466: LD_ADDR_VAR 0 28
74470: PUSH
74471: LD_INT 3
74473: NEG
74474: PUSH
74475: LD_INT 3
74477: NEG
74478: PUSH
74479: EMPTY
74480: LIST
74481: LIST
74482: PUSH
74483: LD_INT 3
74485: NEG
74486: PUSH
74487: LD_INT 4
74489: NEG
74490: PUSH
74491: EMPTY
74492: LIST
74493: LIST
74494: PUSH
74495: LD_INT 4
74497: NEG
74498: PUSH
74499: LD_INT 3
74501: NEG
74502: PUSH
74503: EMPTY
74504: LIST
74505: LIST
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: LIST
74511: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
74512: LD_ADDR_VAR 0 29
74516: PUSH
74517: LD_INT 1
74519: NEG
74520: PUSH
74521: LD_INT 3
74523: NEG
74524: PUSH
74525: EMPTY
74526: LIST
74527: LIST
74528: PUSH
74529: LD_INT 0
74531: PUSH
74532: LD_INT 3
74534: NEG
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: PUSH
74540: LD_INT 1
74542: PUSH
74543: LD_INT 2
74545: NEG
74546: PUSH
74547: EMPTY
74548: LIST
74549: LIST
74550: PUSH
74551: LD_INT 1
74553: NEG
74554: PUSH
74555: LD_INT 4
74557: NEG
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: PUSH
74563: LD_INT 0
74565: PUSH
74566: LD_INT 4
74568: NEG
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: PUSH
74574: LD_INT 1
74576: PUSH
74577: LD_INT 3
74579: NEG
74580: PUSH
74581: EMPTY
74582: LIST
74583: LIST
74584: PUSH
74585: LD_INT 1
74587: NEG
74588: PUSH
74589: LD_INT 5
74591: NEG
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_INT 0
74599: PUSH
74600: LD_INT 5
74602: NEG
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: LD_INT 1
74610: PUSH
74611: LD_INT 4
74613: NEG
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: PUSH
74619: LD_INT 1
74621: NEG
74622: PUSH
74623: LD_INT 6
74625: NEG
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: LD_INT 0
74633: PUSH
74634: LD_INT 6
74636: NEG
74637: PUSH
74638: EMPTY
74639: LIST
74640: LIST
74641: PUSH
74642: LD_INT 1
74644: PUSH
74645: LD_INT 5
74647: NEG
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: LIST
74657: LIST
74658: LIST
74659: LIST
74660: LIST
74661: LIST
74662: LIST
74663: LIST
74664: LIST
74665: LIST
74666: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
74667: LD_ADDR_VAR 0 30
74671: PUSH
74672: LD_INT 2
74674: PUSH
74675: LD_INT 1
74677: NEG
74678: PUSH
74679: EMPTY
74680: LIST
74681: LIST
74682: PUSH
74683: LD_INT 3
74685: PUSH
74686: LD_INT 0
74688: PUSH
74689: EMPTY
74690: LIST
74691: LIST
74692: PUSH
74693: LD_INT 3
74695: PUSH
74696: LD_INT 1
74698: PUSH
74699: EMPTY
74700: LIST
74701: LIST
74702: PUSH
74703: LD_INT 3
74705: PUSH
74706: LD_INT 1
74708: NEG
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: PUSH
74714: LD_INT 4
74716: PUSH
74717: LD_INT 0
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: PUSH
74724: LD_INT 4
74726: PUSH
74727: LD_INT 1
74729: PUSH
74730: EMPTY
74731: LIST
74732: LIST
74733: PUSH
74734: LD_INT 4
74736: PUSH
74737: LD_INT 1
74739: NEG
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: PUSH
74745: LD_INT 5
74747: PUSH
74748: LD_INT 0
74750: PUSH
74751: EMPTY
74752: LIST
74753: LIST
74754: PUSH
74755: LD_INT 5
74757: PUSH
74758: LD_INT 1
74760: PUSH
74761: EMPTY
74762: LIST
74763: LIST
74764: PUSH
74765: LD_INT 5
74767: PUSH
74768: LD_INT 1
74770: NEG
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 6
74778: PUSH
74779: LD_INT 0
74781: PUSH
74782: EMPTY
74783: LIST
74784: LIST
74785: PUSH
74786: LD_INT 6
74788: PUSH
74789: LD_INT 1
74791: PUSH
74792: EMPTY
74793: LIST
74794: LIST
74795: PUSH
74796: EMPTY
74797: LIST
74798: LIST
74799: LIST
74800: LIST
74801: LIST
74802: LIST
74803: LIST
74804: LIST
74805: LIST
74806: LIST
74807: LIST
74808: LIST
74809: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
74810: LD_ADDR_VAR 0 31
74814: PUSH
74815: LD_INT 3
74817: PUSH
74818: LD_INT 2
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: PUSH
74825: LD_INT 3
74827: PUSH
74828: LD_INT 3
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: PUSH
74835: LD_INT 2
74837: PUSH
74838: LD_INT 3
74840: PUSH
74841: EMPTY
74842: LIST
74843: LIST
74844: PUSH
74845: LD_INT 4
74847: PUSH
74848: LD_INT 3
74850: PUSH
74851: EMPTY
74852: LIST
74853: LIST
74854: PUSH
74855: LD_INT 4
74857: PUSH
74858: LD_INT 4
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PUSH
74865: LD_INT 3
74867: PUSH
74868: LD_INT 4
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 5
74877: PUSH
74878: LD_INT 4
74880: PUSH
74881: EMPTY
74882: LIST
74883: LIST
74884: PUSH
74885: LD_INT 5
74887: PUSH
74888: LD_INT 5
74890: PUSH
74891: EMPTY
74892: LIST
74893: LIST
74894: PUSH
74895: LD_INT 4
74897: PUSH
74898: LD_INT 5
74900: PUSH
74901: EMPTY
74902: LIST
74903: LIST
74904: PUSH
74905: LD_INT 6
74907: PUSH
74908: LD_INT 5
74910: PUSH
74911: EMPTY
74912: LIST
74913: LIST
74914: PUSH
74915: LD_INT 6
74917: PUSH
74918: LD_INT 6
74920: PUSH
74921: EMPTY
74922: LIST
74923: LIST
74924: PUSH
74925: LD_INT 5
74927: PUSH
74928: LD_INT 6
74930: PUSH
74931: EMPTY
74932: LIST
74933: LIST
74934: PUSH
74935: EMPTY
74936: LIST
74937: LIST
74938: LIST
74939: LIST
74940: LIST
74941: LIST
74942: LIST
74943: LIST
74944: LIST
74945: LIST
74946: LIST
74947: LIST
74948: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
74949: LD_ADDR_VAR 0 32
74953: PUSH
74954: LD_INT 1
74956: PUSH
74957: LD_INT 3
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: PUSH
74964: LD_INT 0
74966: PUSH
74967: LD_INT 3
74969: PUSH
74970: EMPTY
74971: LIST
74972: LIST
74973: PUSH
74974: LD_INT 1
74976: NEG
74977: PUSH
74978: LD_INT 2
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 1
74987: PUSH
74988: LD_INT 4
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: LD_INT 0
74997: PUSH
74998: LD_INT 4
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: LD_INT 1
75007: NEG
75008: PUSH
75009: LD_INT 3
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PUSH
75016: LD_INT 1
75018: PUSH
75019: LD_INT 5
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: LD_INT 0
75028: PUSH
75029: LD_INT 5
75031: PUSH
75032: EMPTY
75033: LIST
75034: LIST
75035: PUSH
75036: LD_INT 1
75038: NEG
75039: PUSH
75040: LD_INT 4
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_INT 1
75049: PUSH
75050: LD_INT 6
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 0
75059: PUSH
75060: LD_INT 6
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PUSH
75067: LD_INT 1
75069: NEG
75070: PUSH
75071: LD_INT 5
75073: PUSH
75074: EMPTY
75075: LIST
75076: LIST
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: LIST
75082: LIST
75083: LIST
75084: LIST
75085: LIST
75086: LIST
75087: LIST
75088: LIST
75089: LIST
75090: LIST
75091: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75092: LD_ADDR_VAR 0 33
75096: PUSH
75097: LD_INT 2
75099: NEG
75100: PUSH
75101: LD_INT 1
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PUSH
75108: LD_INT 3
75110: NEG
75111: PUSH
75112: LD_INT 0
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: PUSH
75119: LD_INT 3
75121: NEG
75122: PUSH
75123: LD_INT 1
75125: NEG
75126: PUSH
75127: EMPTY
75128: LIST
75129: LIST
75130: PUSH
75131: LD_INT 3
75133: NEG
75134: PUSH
75135: LD_INT 1
75137: PUSH
75138: EMPTY
75139: LIST
75140: LIST
75141: PUSH
75142: LD_INT 4
75144: NEG
75145: PUSH
75146: LD_INT 0
75148: PUSH
75149: EMPTY
75150: LIST
75151: LIST
75152: PUSH
75153: LD_INT 4
75155: NEG
75156: PUSH
75157: LD_INT 1
75159: NEG
75160: PUSH
75161: EMPTY
75162: LIST
75163: LIST
75164: PUSH
75165: LD_INT 4
75167: NEG
75168: PUSH
75169: LD_INT 1
75171: PUSH
75172: EMPTY
75173: LIST
75174: LIST
75175: PUSH
75176: LD_INT 5
75178: NEG
75179: PUSH
75180: LD_INT 0
75182: PUSH
75183: EMPTY
75184: LIST
75185: LIST
75186: PUSH
75187: LD_INT 5
75189: NEG
75190: PUSH
75191: LD_INT 1
75193: NEG
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: LD_INT 5
75201: NEG
75202: PUSH
75203: LD_INT 1
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: LD_INT 6
75212: NEG
75213: PUSH
75214: LD_INT 0
75216: PUSH
75217: EMPTY
75218: LIST
75219: LIST
75220: PUSH
75221: LD_INT 6
75223: NEG
75224: PUSH
75225: LD_INT 1
75227: NEG
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: EMPTY
75234: LIST
75235: LIST
75236: LIST
75237: LIST
75238: LIST
75239: LIST
75240: LIST
75241: LIST
75242: LIST
75243: LIST
75244: LIST
75245: LIST
75246: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
75247: LD_ADDR_VAR 0 34
75251: PUSH
75252: LD_INT 2
75254: NEG
75255: PUSH
75256: LD_INT 3
75258: NEG
75259: PUSH
75260: EMPTY
75261: LIST
75262: LIST
75263: PUSH
75264: LD_INT 3
75266: NEG
75267: PUSH
75268: LD_INT 2
75270: NEG
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: PUSH
75276: LD_INT 3
75278: NEG
75279: PUSH
75280: LD_INT 3
75282: NEG
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 3
75290: NEG
75291: PUSH
75292: LD_INT 4
75294: NEG
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 4
75302: NEG
75303: PUSH
75304: LD_INT 3
75306: NEG
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 4
75314: NEG
75315: PUSH
75316: LD_INT 4
75318: NEG
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: PUSH
75324: LD_INT 4
75326: NEG
75327: PUSH
75328: LD_INT 5
75330: NEG
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 5
75338: NEG
75339: PUSH
75340: LD_INT 4
75342: NEG
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: PUSH
75348: LD_INT 5
75350: NEG
75351: PUSH
75352: LD_INT 5
75354: NEG
75355: PUSH
75356: EMPTY
75357: LIST
75358: LIST
75359: PUSH
75360: LD_INT 5
75362: NEG
75363: PUSH
75364: LD_INT 6
75366: NEG
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PUSH
75372: LD_INT 6
75374: NEG
75375: PUSH
75376: LD_INT 5
75378: NEG
75379: PUSH
75380: EMPTY
75381: LIST
75382: LIST
75383: PUSH
75384: LD_INT 6
75386: NEG
75387: PUSH
75388: LD_INT 6
75390: NEG
75391: PUSH
75392: EMPTY
75393: LIST
75394: LIST
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: LIST
75400: LIST
75401: LIST
75402: LIST
75403: LIST
75404: LIST
75405: LIST
75406: LIST
75407: LIST
75408: LIST
75409: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
75410: LD_ADDR_VAR 0 41
75414: PUSH
75415: LD_INT 0
75417: PUSH
75418: LD_INT 2
75420: NEG
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PUSH
75426: LD_INT 1
75428: NEG
75429: PUSH
75430: LD_INT 3
75432: NEG
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: LD_INT 1
75440: PUSH
75441: LD_INT 2
75443: NEG
75444: PUSH
75445: EMPTY
75446: LIST
75447: LIST
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: LIST
75453: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
75454: LD_ADDR_VAR 0 42
75458: PUSH
75459: LD_INT 2
75461: PUSH
75462: LD_INT 0
75464: PUSH
75465: EMPTY
75466: LIST
75467: LIST
75468: PUSH
75469: LD_INT 2
75471: PUSH
75472: LD_INT 1
75474: NEG
75475: PUSH
75476: EMPTY
75477: LIST
75478: LIST
75479: PUSH
75480: LD_INT 3
75482: PUSH
75483: LD_INT 1
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: LIST
75494: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
75495: LD_ADDR_VAR 0 43
75499: PUSH
75500: LD_INT 2
75502: PUSH
75503: LD_INT 2
75505: PUSH
75506: EMPTY
75507: LIST
75508: LIST
75509: PUSH
75510: LD_INT 3
75512: PUSH
75513: LD_INT 2
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: PUSH
75520: LD_INT 2
75522: PUSH
75523: LD_INT 3
75525: PUSH
75526: EMPTY
75527: LIST
75528: LIST
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: LIST
75534: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
75535: LD_ADDR_VAR 0 44
75539: PUSH
75540: LD_INT 0
75542: PUSH
75543: LD_INT 2
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 1
75552: PUSH
75553: LD_INT 3
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: PUSH
75560: LD_INT 1
75562: NEG
75563: PUSH
75564: LD_INT 2
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: LIST
75575: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
75576: LD_ADDR_VAR 0 45
75580: PUSH
75581: LD_INT 2
75583: NEG
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: PUSH
75592: LD_INT 2
75594: NEG
75595: PUSH
75596: LD_INT 1
75598: PUSH
75599: EMPTY
75600: LIST
75601: LIST
75602: PUSH
75603: LD_INT 3
75605: NEG
75606: PUSH
75607: LD_INT 1
75609: NEG
75610: PUSH
75611: EMPTY
75612: LIST
75613: LIST
75614: PUSH
75615: EMPTY
75616: LIST
75617: LIST
75618: LIST
75619: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
75620: LD_ADDR_VAR 0 46
75624: PUSH
75625: LD_INT 2
75627: NEG
75628: PUSH
75629: LD_INT 2
75631: NEG
75632: PUSH
75633: EMPTY
75634: LIST
75635: LIST
75636: PUSH
75637: LD_INT 2
75639: NEG
75640: PUSH
75641: LD_INT 3
75643: NEG
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: PUSH
75649: LD_INT 3
75651: NEG
75652: PUSH
75653: LD_INT 2
75655: NEG
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: EMPTY
75662: LIST
75663: LIST
75664: LIST
75665: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
75666: LD_ADDR_VAR 0 47
75670: PUSH
75671: LD_INT 2
75673: NEG
75674: PUSH
75675: LD_INT 3
75677: NEG
75678: PUSH
75679: EMPTY
75680: LIST
75681: LIST
75682: PUSH
75683: LD_INT 1
75685: NEG
75686: PUSH
75687: LD_INT 3
75689: NEG
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PUSH
75695: EMPTY
75696: LIST
75697: LIST
75698: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
75699: LD_ADDR_VAR 0 48
75703: PUSH
75704: LD_INT 1
75706: PUSH
75707: LD_INT 2
75709: NEG
75710: PUSH
75711: EMPTY
75712: LIST
75713: LIST
75714: PUSH
75715: LD_INT 2
75717: PUSH
75718: LD_INT 1
75720: NEG
75721: PUSH
75722: EMPTY
75723: LIST
75724: LIST
75725: PUSH
75726: EMPTY
75727: LIST
75728: LIST
75729: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
75730: LD_ADDR_VAR 0 49
75734: PUSH
75735: LD_INT 3
75737: PUSH
75738: LD_INT 1
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: LD_INT 3
75747: PUSH
75748: LD_INT 2
75750: PUSH
75751: EMPTY
75752: LIST
75753: LIST
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
75759: LD_ADDR_VAR 0 50
75763: PUSH
75764: LD_INT 2
75766: PUSH
75767: LD_INT 3
75769: PUSH
75770: EMPTY
75771: LIST
75772: LIST
75773: PUSH
75774: LD_INT 1
75776: PUSH
75777: LD_INT 3
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
75788: LD_ADDR_VAR 0 51
75792: PUSH
75793: LD_INT 1
75795: NEG
75796: PUSH
75797: LD_INT 2
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: PUSH
75804: LD_INT 2
75806: NEG
75807: PUSH
75808: LD_INT 1
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: EMPTY
75816: LIST
75817: LIST
75818: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
75819: LD_ADDR_VAR 0 52
75823: PUSH
75824: LD_INT 3
75826: NEG
75827: PUSH
75828: LD_INT 1
75830: NEG
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 3
75838: NEG
75839: PUSH
75840: LD_INT 2
75842: NEG
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75852: LD_ADDR_VAR 0 53
75856: PUSH
75857: LD_INT 1
75859: NEG
75860: PUSH
75861: LD_INT 3
75863: NEG
75864: PUSH
75865: EMPTY
75866: LIST
75867: LIST
75868: PUSH
75869: LD_INT 0
75871: PUSH
75872: LD_INT 3
75874: NEG
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: PUSH
75880: LD_INT 1
75882: PUSH
75883: LD_INT 2
75885: NEG
75886: PUSH
75887: EMPTY
75888: LIST
75889: LIST
75890: PUSH
75891: EMPTY
75892: LIST
75893: LIST
75894: LIST
75895: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75896: LD_ADDR_VAR 0 54
75900: PUSH
75901: LD_INT 2
75903: PUSH
75904: LD_INT 1
75906: NEG
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: PUSH
75912: LD_INT 3
75914: PUSH
75915: LD_INT 0
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: PUSH
75922: LD_INT 3
75924: PUSH
75925: LD_INT 1
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: EMPTY
75933: LIST
75934: LIST
75935: LIST
75936: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75937: LD_ADDR_VAR 0 55
75941: PUSH
75942: LD_INT 3
75944: PUSH
75945: LD_INT 2
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 3
75954: PUSH
75955: LD_INT 3
75957: PUSH
75958: EMPTY
75959: LIST
75960: LIST
75961: PUSH
75962: LD_INT 2
75964: PUSH
75965: LD_INT 3
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: LIST
75976: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75977: LD_ADDR_VAR 0 56
75981: PUSH
75982: LD_INT 1
75984: PUSH
75985: LD_INT 3
75987: PUSH
75988: EMPTY
75989: LIST
75990: LIST
75991: PUSH
75992: LD_INT 0
75994: PUSH
75995: LD_INT 3
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: PUSH
76002: LD_INT 1
76004: NEG
76005: PUSH
76006: LD_INT 2
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: PUSH
76013: EMPTY
76014: LIST
76015: LIST
76016: LIST
76017: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76018: LD_ADDR_VAR 0 57
76022: PUSH
76023: LD_INT 2
76025: NEG
76026: PUSH
76027: LD_INT 1
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PUSH
76034: LD_INT 3
76036: NEG
76037: PUSH
76038: LD_INT 0
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PUSH
76045: LD_INT 3
76047: NEG
76048: PUSH
76049: LD_INT 1
76051: NEG
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: LIST
76061: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76062: LD_ADDR_VAR 0 58
76066: PUSH
76067: LD_INT 2
76069: NEG
76070: PUSH
76071: LD_INT 3
76073: NEG
76074: PUSH
76075: EMPTY
76076: LIST
76077: LIST
76078: PUSH
76079: LD_INT 3
76081: NEG
76082: PUSH
76083: LD_INT 2
76085: NEG
76086: PUSH
76087: EMPTY
76088: LIST
76089: LIST
76090: PUSH
76091: LD_INT 3
76093: NEG
76094: PUSH
76095: LD_INT 3
76097: NEG
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PUSH
76103: EMPTY
76104: LIST
76105: LIST
76106: LIST
76107: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76108: LD_ADDR_VAR 0 59
76112: PUSH
76113: LD_INT 1
76115: NEG
76116: PUSH
76117: LD_INT 2
76119: NEG
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: PUSH
76125: LD_INT 0
76127: PUSH
76128: LD_INT 2
76130: NEG
76131: PUSH
76132: EMPTY
76133: LIST
76134: LIST
76135: PUSH
76136: LD_INT 1
76138: PUSH
76139: LD_INT 1
76141: NEG
76142: PUSH
76143: EMPTY
76144: LIST
76145: LIST
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: LIST
76151: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76152: LD_ADDR_VAR 0 60
76156: PUSH
76157: LD_INT 1
76159: PUSH
76160: LD_INT 1
76162: NEG
76163: PUSH
76164: EMPTY
76165: LIST
76166: LIST
76167: PUSH
76168: LD_INT 2
76170: PUSH
76171: LD_INT 0
76173: PUSH
76174: EMPTY
76175: LIST
76176: LIST
76177: PUSH
76178: LD_INT 2
76180: PUSH
76181: LD_INT 1
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: LIST
76192: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76193: LD_ADDR_VAR 0 61
76197: PUSH
76198: LD_INT 2
76200: PUSH
76201: LD_INT 1
76203: PUSH
76204: EMPTY
76205: LIST
76206: LIST
76207: PUSH
76208: LD_INT 2
76210: PUSH
76211: LD_INT 2
76213: PUSH
76214: EMPTY
76215: LIST
76216: LIST
76217: PUSH
76218: LD_INT 1
76220: PUSH
76221: LD_INT 2
76223: PUSH
76224: EMPTY
76225: LIST
76226: LIST
76227: PUSH
76228: EMPTY
76229: LIST
76230: LIST
76231: LIST
76232: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76233: LD_ADDR_VAR 0 62
76237: PUSH
76238: LD_INT 1
76240: PUSH
76241: LD_INT 2
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: PUSH
76248: LD_INT 0
76250: PUSH
76251: LD_INT 2
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: PUSH
76258: LD_INT 1
76260: NEG
76261: PUSH
76262: LD_INT 1
76264: PUSH
76265: EMPTY
76266: LIST
76267: LIST
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: LIST
76273: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76274: LD_ADDR_VAR 0 63
76278: PUSH
76279: LD_INT 1
76281: NEG
76282: PUSH
76283: LD_INT 1
76285: PUSH
76286: EMPTY
76287: LIST
76288: LIST
76289: PUSH
76290: LD_INT 2
76292: NEG
76293: PUSH
76294: LD_INT 0
76296: PUSH
76297: EMPTY
76298: LIST
76299: LIST
76300: PUSH
76301: LD_INT 2
76303: NEG
76304: PUSH
76305: LD_INT 1
76307: NEG
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: LIST
76317: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76318: LD_ADDR_VAR 0 64
76322: PUSH
76323: LD_INT 1
76325: NEG
76326: PUSH
76327: LD_INT 2
76329: NEG
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PUSH
76335: LD_INT 2
76337: NEG
76338: PUSH
76339: LD_INT 1
76341: NEG
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: LD_INT 2
76349: NEG
76350: PUSH
76351: LD_INT 2
76353: NEG
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: LIST
76363: ST_TO_ADDR
// end ; 2 :
76364: GO 79630
76366: LD_INT 2
76368: DOUBLE
76369: EQUAL
76370: IFTRUE 76374
76372: GO 79629
76374: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
76375: LD_ADDR_VAR 0 29
76379: PUSH
76380: LD_INT 4
76382: PUSH
76383: LD_INT 0
76385: PUSH
76386: EMPTY
76387: LIST
76388: LIST
76389: PUSH
76390: LD_INT 4
76392: PUSH
76393: LD_INT 1
76395: NEG
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: PUSH
76401: LD_INT 5
76403: PUSH
76404: LD_INT 0
76406: PUSH
76407: EMPTY
76408: LIST
76409: LIST
76410: PUSH
76411: LD_INT 5
76413: PUSH
76414: LD_INT 1
76416: PUSH
76417: EMPTY
76418: LIST
76419: LIST
76420: PUSH
76421: LD_INT 4
76423: PUSH
76424: LD_INT 1
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: PUSH
76431: LD_INT 3
76433: PUSH
76434: LD_INT 0
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PUSH
76441: LD_INT 3
76443: PUSH
76444: LD_INT 1
76446: NEG
76447: PUSH
76448: EMPTY
76449: LIST
76450: LIST
76451: PUSH
76452: LD_INT 3
76454: PUSH
76455: LD_INT 2
76457: NEG
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: PUSH
76463: LD_INT 5
76465: PUSH
76466: LD_INT 2
76468: PUSH
76469: EMPTY
76470: LIST
76471: LIST
76472: PUSH
76473: LD_INT 3
76475: PUSH
76476: LD_INT 3
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: LD_INT 3
76485: PUSH
76486: LD_INT 2
76488: PUSH
76489: EMPTY
76490: LIST
76491: LIST
76492: PUSH
76493: LD_INT 4
76495: PUSH
76496: LD_INT 3
76498: PUSH
76499: EMPTY
76500: LIST
76501: LIST
76502: PUSH
76503: LD_INT 4
76505: PUSH
76506: LD_INT 4
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: PUSH
76513: LD_INT 3
76515: PUSH
76516: LD_INT 4
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: PUSH
76523: LD_INT 2
76525: PUSH
76526: LD_INT 3
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: LD_INT 2
76535: PUSH
76536: LD_INT 2
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 4
76545: PUSH
76546: LD_INT 2
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: PUSH
76553: LD_INT 2
76555: PUSH
76556: LD_INT 4
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 0
76565: PUSH
76566: LD_INT 4
76568: PUSH
76569: EMPTY
76570: LIST
76571: LIST
76572: PUSH
76573: LD_INT 0
76575: PUSH
76576: LD_INT 3
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: PUSH
76583: LD_INT 1
76585: PUSH
76586: LD_INT 4
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: PUSH
76593: LD_INT 1
76595: PUSH
76596: LD_INT 5
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: PUSH
76603: LD_INT 0
76605: PUSH
76606: LD_INT 5
76608: PUSH
76609: EMPTY
76610: LIST
76611: LIST
76612: PUSH
76613: LD_INT 1
76615: NEG
76616: PUSH
76617: LD_INT 4
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: PUSH
76624: LD_INT 1
76626: NEG
76627: PUSH
76628: LD_INT 3
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 2
76637: PUSH
76638: LD_INT 5
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: LD_INT 2
76647: NEG
76648: PUSH
76649: LD_INT 3
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: LD_INT 3
76658: NEG
76659: PUSH
76660: LD_INT 0
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 3
76669: NEG
76670: PUSH
76671: LD_INT 1
76673: NEG
76674: PUSH
76675: EMPTY
76676: LIST
76677: LIST
76678: PUSH
76679: LD_INT 2
76681: NEG
76682: PUSH
76683: LD_INT 0
76685: PUSH
76686: EMPTY
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 2
76692: NEG
76693: PUSH
76694: LD_INT 1
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PUSH
76701: LD_INT 3
76703: NEG
76704: PUSH
76705: LD_INT 1
76707: PUSH
76708: EMPTY
76709: LIST
76710: LIST
76711: PUSH
76712: LD_INT 4
76714: NEG
76715: PUSH
76716: LD_INT 0
76718: PUSH
76719: EMPTY
76720: LIST
76721: LIST
76722: PUSH
76723: LD_INT 4
76725: NEG
76726: PUSH
76727: LD_INT 1
76729: NEG
76730: PUSH
76731: EMPTY
76732: LIST
76733: LIST
76734: PUSH
76735: LD_INT 4
76737: NEG
76738: PUSH
76739: LD_INT 2
76741: NEG
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: PUSH
76747: LD_INT 2
76749: NEG
76750: PUSH
76751: LD_INT 2
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PUSH
76758: LD_INT 4
76760: NEG
76761: PUSH
76762: LD_INT 4
76764: NEG
76765: PUSH
76766: EMPTY
76767: LIST
76768: LIST
76769: PUSH
76770: LD_INT 4
76772: NEG
76773: PUSH
76774: LD_INT 5
76776: NEG
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: PUSH
76782: LD_INT 3
76784: NEG
76785: PUSH
76786: LD_INT 4
76788: NEG
76789: PUSH
76790: EMPTY
76791: LIST
76792: LIST
76793: PUSH
76794: LD_INT 3
76796: NEG
76797: PUSH
76798: LD_INT 3
76800: NEG
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: LD_INT 4
76808: NEG
76809: PUSH
76810: LD_INT 3
76812: NEG
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: LD_INT 5
76820: NEG
76821: PUSH
76822: LD_INT 4
76824: NEG
76825: PUSH
76826: EMPTY
76827: LIST
76828: LIST
76829: PUSH
76830: LD_INT 5
76832: NEG
76833: PUSH
76834: LD_INT 5
76836: NEG
76837: PUSH
76838: EMPTY
76839: LIST
76840: LIST
76841: PUSH
76842: LD_INT 3
76844: NEG
76845: PUSH
76846: LD_INT 5
76848: NEG
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PUSH
76854: LD_INT 5
76856: NEG
76857: PUSH
76858: LD_INT 3
76860: NEG
76861: PUSH
76862: EMPTY
76863: LIST
76864: LIST
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: LIST
76870: LIST
76871: LIST
76872: LIST
76873: LIST
76874: LIST
76875: LIST
76876: LIST
76877: LIST
76878: LIST
76879: LIST
76880: LIST
76881: LIST
76882: LIST
76883: LIST
76884: LIST
76885: LIST
76886: LIST
76887: LIST
76888: LIST
76889: LIST
76890: LIST
76891: LIST
76892: LIST
76893: LIST
76894: LIST
76895: LIST
76896: LIST
76897: LIST
76898: LIST
76899: LIST
76900: LIST
76901: LIST
76902: LIST
76903: LIST
76904: LIST
76905: LIST
76906: LIST
76907: LIST
76908: LIST
76909: LIST
76910: LIST
76911: LIST
76912: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
76913: LD_ADDR_VAR 0 30
76917: PUSH
76918: LD_INT 4
76920: PUSH
76921: LD_INT 4
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: PUSH
76928: LD_INT 4
76930: PUSH
76931: LD_INT 3
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: PUSH
76938: LD_INT 5
76940: PUSH
76941: LD_INT 4
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 5
76950: PUSH
76951: LD_INT 5
76953: PUSH
76954: EMPTY
76955: LIST
76956: LIST
76957: PUSH
76958: LD_INT 4
76960: PUSH
76961: LD_INT 5
76963: PUSH
76964: EMPTY
76965: LIST
76966: LIST
76967: PUSH
76968: LD_INT 3
76970: PUSH
76971: LD_INT 4
76973: PUSH
76974: EMPTY
76975: LIST
76976: LIST
76977: PUSH
76978: LD_INT 3
76980: PUSH
76981: LD_INT 3
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: PUSH
76988: LD_INT 5
76990: PUSH
76991: LD_INT 3
76993: PUSH
76994: EMPTY
76995: LIST
76996: LIST
76997: PUSH
76998: LD_INT 3
77000: PUSH
77001: LD_INT 5
77003: PUSH
77004: EMPTY
77005: LIST
77006: LIST
77007: PUSH
77008: LD_INT 0
77010: PUSH
77011: LD_INT 3
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: PUSH
77018: LD_INT 0
77020: PUSH
77021: LD_INT 2
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: PUSH
77028: LD_INT 1
77030: PUSH
77031: LD_INT 3
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: LD_INT 1
77040: PUSH
77041: LD_INT 4
77043: PUSH
77044: EMPTY
77045: LIST
77046: LIST
77047: PUSH
77048: LD_INT 0
77050: PUSH
77051: LD_INT 4
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: PUSH
77058: LD_INT 1
77060: NEG
77061: PUSH
77062: LD_INT 3
77064: PUSH
77065: EMPTY
77066: LIST
77067: LIST
77068: PUSH
77069: LD_INT 1
77071: NEG
77072: PUSH
77073: LD_INT 2
77075: PUSH
77076: EMPTY
77077: LIST
77078: LIST
77079: PUSH
77080: LD_INT 2
77082: PUSH
77083: LD_INT 4
77085: PUSH
77086: EMPTY
77087: LIST
77088: LIST
77089: PUSH
77090: LD_INT 2
77092: NEG
77093: PUSH
77094: LD_INT 2
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: PUSH
77101: LD_INT 4
77103: NEG
77104: PUSH
77105: LD_INT 0
77107: PUSH
77108: EMPTY
77109: LIST
77110: LIST
77111: PUSH
77112: LD_INT 4
77114: NEG
77115: PUSH
77116: LD_INT 1
77118: NEG
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: PUSH
77124: LD_INT 3
77126: NEG
77127: PUSH
77128: LD_INT 0
77130: PUSH
77131: EMPTY
77132: LIST
77133: LIST
77134: PUSH
77135: LD_INT 3
77137: NEG
77138: PUSH
77139: LD_INT 1
77141: PUSH
77142: EMPTY
77143: LIST
77144: LIST
77145: PUSH
77146: LD_INT 4
77148: NEG
77149: PUSH
77150: LD_INT 1
77152: PUSH
77153: EMPTY
77154: LIST
77155: LIST
77156: PUSH
77157: LD_INT 5
77159: NEG
77160: PUSH
77161: LD_INT 0
77163: PUSH
77164: EMPTY
77165: LIST
77166: LIST
77167: PUSH
77168: LD_INT 5
77170: NEG
77171: PUSH
77172: LD_INT 1
77174: NEG
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: PUSH
77180: LD_INT 5
77182: NEG
77183: PUSH
77184: LD_INT 2
77186: NEG
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: LD_INT 3
77194: NEG
77195: PUSH
77196: LD_INT 2
77198: PUSH
77199: EMPTY
77200: LIST
77201: LIST
77202: PUSH
77203: LD_INT 3
77205: NEG
77206: PUSH
77207: LD_INT 3
77209: NEG
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: LD_INT 3
77217: NEG
77218: PUSH
77219: LD_INT 4
77221: NEG
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: PUSH
77227: LD_INT 2
77229: NEG
77230: PUSH
77231: LD_INT 3
77233: NEG
77234: PUSH
77235: EMPTY
77236: LIST
77237: LIST
77238: PUSH
77239: LD_INT 2
77241: NEG
77242: PUSH
77243: LD_INT 2
77245: NEG
77246: PUSH
77247: EMPTY
77248: LIST
77249: LIST
77250: PUSH
77251: LD_INT 3
77253: NEG
77254: PUSH
77255: LD_INT 2
77257: NEG
77258: PUSH
77259: EMPTY
77260: LIST
77261: LIST
77262: PUSH
77263: LD_INT 4
77265: NEG
77266: PUSH
77267: LD_INT 3
77269: NEG
77270: PUSH
77271: EMPTY
77272: LIST
77273: LIST
77274: PUSH
77275: LD_INT 4
77277: NEG
77278: PUSH
77279: LD_INT 4
77281: NEG
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: PUSH
77287: LD_INT 2
77289: NEG
77290: PUSH
77291: LD_INT 4
77293: NEG
77294: PUSH
77295: EMPTY
77296: LIST
77297: LIST
77298: PUSH
77299: LD_INT 4
77301: NEG
77302: PUSH
77303: LD_INT 2
77305: NEG
77306: PUSH
77307: EMPTY
77308: LIST
77309: LIST
77310: PUSH
77311: LD_INT 0
77313: PUSH
77314: LD_INT 4
77316: NEG
77317: PUSH
77318: EMPTY
77319: LIST
77320: LIST
77321: PUSH
77322: LD_INT 0
77324: PUSH
77325: LD_INT 5
77327: NEG
77328: PUSH
77329: EMPTY
77330: LIST
77331: LIST
77332: PUSH
77333: LD_INT 1
77335: PUSH
77336: LD_INT 4
77338: NEG
77339: PUSH
77340: EMPTY
77341: LIST
77342: LIST
77343: PUSH
77344: LD_INT 1
77346: PUSH
77347: LD_INT 3
77349: NEG
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: PUSH
77355: LD_INT 0
77357: PUSH
77358: LD_INT 3
77360: NEG
77361: PUSH
77362: EMPTY
77363: LIST
77364: LIST
77365: PUSH
77366: LD_INT 1
77368: NEG
77369: PUSH
77370: LD_INT 4
77372: NEG
77373: PUSH
77374: EMPTY
77375: LIST
77376: LIST
77377: PUSH
77378: LD_INT 1
77380: NEG
77381: PUSH
77382: LD_INT 5
77384: NEG
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: LD_INT 2
77392: PUSH
77393: LD_INT 3
77395: NEG
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: PUSH
77401: LD_INT 2
77403: NEG
77404: PUSH
77405: LD_INT 5
77407: NEG
77408: PUSH
77409: EMPTY
77410: LIST
77411: LIST
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: LIST
77417: LIST
77418: LIST
77419: LIST
77420: LIST
77421: LIST
77422: LIST
77423: LIST
77424: LIST
77425: LIST
77426: LIST
77427: LIST
77428: LIST
77429: LIST
77430: LIST
77431: LIST
77432: LIST
77433: LIST
77434: LIST
77435: LIST
77436: LIST
77437: LIST
77438: LIST
77439: LIST
77440: LIST
77441: LIST
77442: LIST
77443: LIST
77444: LIST
77445: LIST
77446: LIST
77447: LIST
77448: LIST
77449: LIST
77450: LIST
77451: LIST
77452: LIST
77453: LIST
77454: LIST
77455: LIST
77456: LIST
77457: LIST
77458: LIST
77459: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
77460: LD_ADDR_VAR 0 31
77464: PUSH
77465: LD_INT 0
77467: PUSH
77468: LD_INT 4
77470: PUSH
77471: EMPTY
77472: LIST
77473: LIST
77474: PUSH
77475: LD_INT 0
77477: PUSH
77478: LD_INT 3
77480: PUSH
77481: EMPTY
77482: LIST
77483: LIST
77484: PUSH
77485: LD_INT 1
77487: PUSH
77488: LD_INT 4
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: LD_INT 1
77497: PUSH
77498: LD_INT 5
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: LD_INT 0
77507: PUSH
77508: LD_INT 5
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PUSH
77515: LD_INT 1
77517: NEG
77518: PUSH
77519: LD_INT 4
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: PUSH
77526: LD_INT 1
77528: NEG
77529: PUSH
77530: LD_INT 3
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: PUSH
77537: LD_INT 2
77539: PUSH
77540: LD_INT 5
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: LD_INT 2
77549: NEG
77550: PUSH
77551: LD_INT 3
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: PUSH
77558: LD_INT 3
77560: NEG
77561: PUSH
77562: LD_INT 0
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: LD_INT 3
77571: NEG
77572: PUSH
77573: LD_INT 1
77575: NEG
77576: PUSH
77577: EMPTY
77578: LIST
77579: LIST
77580: PUSH
77581: LD_INT 2
77583: NEG
77584: PUSH
77585: LD_INT 0
77587: PUSH
77588: EMPTY
77589: LIST
77590: LIST
77591: PUSH
77592: LD_INT 2
77594: NEG
77595: PUSH
77596: LD_INT 1
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: PUSH
77603: LD_INT 3
77605: NEG
77606: PUSH
77607: LD_INT 1
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: LD_INT 4
77616: NEG
77617: PUSH
77618: LD_INT 0
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PUSH
77625: LD_INT 4
77627: NEG
77628: PUSH
77629: LD_INT 1
77631: NEG
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: LD_INT 4
77639: NEG
77640: PUSH
77641: LD_INT 2
77643: NEG
77644: PUSH
77645: EMPTY
77646: LIST
77647: LIST
77648: PUSH
77649: LD_INT 2
77651: NEG
77652: PUSH
77653: LD_INT 2
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: LD_INT 4
77662: NEG
77663: PUSH
77664: LD_INT 4
77666: NEG
77667: PUSH
77668: EMPTY
77669: LIST
77670: LIST
77671: PUSH
77672: LD_INT 4
77674: NEG
77675: PUSH
77676: LD_INT 5
77678: NEG
77679: PUSH
77680: EMPTY
77681: LIST
77682: LIST
77683: PUSH
77684: LD_INT 3
77686: NEG
77687: PUSH
77688: LD_INT 4
77690: NEG
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: PUSH
77696: LD_INT 3
77698: NEG
77699: PUSH
77700: LD_INT 3
77702: NEG
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PUSH
77708: LD_INT 4
77710: NEG
77711: PUSH
77712: LD_INT 3
77714: NEG
77715: PUSH
77716: EMPTY
77717: LIST
77718: LIST
77719: PUSH
77720: LD_INT 5
77722: NEG
77723: PUSH
77724: LD_INT 4
77726: NEG
77727: PUSH
77728: EMPTY
77729: LIST
77730: LIST
77731: PUSH
77732: LD_INT 5
77734: NEG
77735: PUSH
77736: LD_INT 5
77738: NEG
77739: PUSH
77740: EMPTY
77741: LIST
77742: LIST
77743: PUSH
77744: LD_INT 3
77746: NEG
77747: PUSH
77748: LD_INT 5
77750: NEG
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 5
77758: NEG
77759: PUSH
77760: LD_INT 3
77762: NEG
77763: PUSH
77764: EMPTY
77765: LIST
77766: LIST
77767: PUSH
77768: LD_INT 0
77770: PUSH
77771: LD_INT 3
77773: NEG
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: PUSH
77779: LD_INT 0
77781: PUSH
77782: LD_INT 4
77784: NEG
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 1
77792: PUSH
77793: LD_INT 3
77795: NEG
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: LD_INT 1
77803: PUSH
77804: LD_INT 2
77806: NEG
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: PUSH
77812: LD_INT 0
77814: PUSH
77815: LD_INT 2
77817: NEG
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: LD_INT 1
77825: NEG
77826: PUSH
77827: LD_INT 3
77829: NEG
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PUSH
77835: LD_INT 1
77837: NEG
77838: PUSH
77839: LD_INT 4
77841: NEG
77842: PUSH
77843: EMPTY
77844: LIST
77845: LIST
77846: PUSH
77847: LD_INT 2
77849: PUSH
77850: LD_INT 2
77852: NEG
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 2
77860: NEG
77861: PUSH
77862: LD_INT 4
77864: NEG
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: PUSH
77870: LD_INT 4
77872: PUSH
77873: LD_INT 0
77875: PUSH
77876: EMPTY
77877: LIST
77878: LIST
77879: PUSH
77880: LD_INT 4
77882: PUSH
77883: LD_INT 1
77885: NEG
77886: PUSH
77887: EMPTY
77888: LIST
77889: LIST
77890: PUSH
77891: LD_INT 5
77893: PUSH
77894: LD_INT 0
77896: PUSH
77897: EMPTY
77898: LIST
77899: LIST
77900: PUSH
77901: LD_INT 5
77903: PUSH
77904: LD_INT 1
77906: PUSH
77907: EMPTY
77908: LIST
77909: LIST
77910: PUSH
77911: LD_INT 4
77913: PUSH
77914: LD_INT 1
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PUSH
77921: LD_INT 3
77923: PUSH
77924: LD_INT 0
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: PUSH
77931: LD_INT 3
77933: PUSH
77934: LD_INT 1
77936: NEG
77937: PUSH
77938: EMPTY
77939: LIST
77940: LIST
77941: PUSH
77942: LD_INT 3
77944: PUSH
77945: LD_INT 2
77947: NEG
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: PUSH
77953: LD_INT 5
77955: PUSH
77956: LD_INT 2
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: PUSH
77963: EMPTY
77964: LIST
77965: LIST
77966: LIST
77967: LIST
77968: LIST
77969: LIST
77970: LIST
77971: LIST
77972: LIST
77973: LIST
77974: LIST
77975: LIST
77976: LIST
77977: LIST
77978: LIST
77979: LIST
77980: LIST
77981: LIST
77982: LIST
77983: LIST
77984: LIST
77985: LIST
77986: LIST
77987: LIST
77988: LIST
77989: LIST
77990: LIST
77991: LIST
77992: LIST
77993: LIST
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78010: LD_ADDR_VAR 0 32
78014: PUSH
78015: LD_INT 4
78017: NEG
78018: PUSH
78019: LD_INT 0
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: LD_INT 4
78028: NEG
78029: PUSH
78030: LD_INT 1
78032: NEG
78033: PUSH
78034: EMPTY
78035: LIST
78036: LIST
78037: PUSH
78038: LD_INT 3
78040: NEG
78041: PUSH
78042: LD_INT 0
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: PUSH
78049: LD_INT 3
78051: NEG
78052: PUSH
78053: LD_INT 1
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: LD_INT 4
78062: NEG
78063: PUSH
78064: LD_INT 1
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: PUSH
78071: LD_INT 5
78073: NEG
78074: PUSH
78075: LD_INT 0
78077: PUSH
78078: EMPTY
78079: LIST
78080: LIST
78081: PUSH
78082: LD_INT 5
78084: NEG
78085: PUSH
78086: LD_INT 1
78088: NEG
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: LD_INT 5
78096: NEG
78097: PUSH
78098: LD_INT 2
78100: NEG
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: PUSH
78106: LD_INT 3
78108: NEG
78109: PUSH
78110: LD_INT 2
78112: PUSH
78113: EMPTY
78114: LIST
78115: LIST
78116: PUSH
78117: LD_INT 3
78119: NEG
78120: PUSH
78121: LD_INT 3
78123: NEG
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 3
78131: NEG
78132: PUSH
78133: LD_INT 4
78135: NEG
78136: PUSH
78137: EMPTY
78138: LIST
78139: LIST
78140: PUSH
78141: LD_INT 2
78143: NEG
78144: PUSH
78145: LD_INT 3
78147: NEG
78148: PUSH
78149: EMPTY
78150: LIST
78151: LIST
78152: PUSH
78153: LD_INT 2
78155: NEG
78156: PUSH
78157: LD_INT 2
78159: NEG
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PUSH
78165: LD_INT 3
78167: NEG
78168: PUSH
78169: LD_INT 2
78171: NEG
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 4
78179: NEG
78180: PUSH
78181: LD_INT 3
78183: NEG
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PUSH
78189: LD_INT 4
78191: NEG
78192: PUSH
78193: LD_INT 4
78195: NEG
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: PUSH
78201: LD_INT 2
78203: NEG
78204: PUSH
78205: LD_INT 4
78207: NEG
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: PUSH
78213: LD_INT 4
78215: NEG
78216: PUSH
78217: LD_INT 2
78219: NEG
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PUSH
78225: LD_INT 0
78227: PUSH
78228: LD_INT 4
78230: NEG
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: PUSH
78236: LD_INT 0
78238: PUSH
78239: LD_INT 5
78241: NEG
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: PUSH
78247: LD_INT 1
78249: PUSH
78250: LD_INT 4
78252: NEG
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: PUSH
78258: LD_INT 1
78260: PUSH
78261: LD_INT 3
78263: NEG
78264: PUSH
78265: EMPTY
78266: LIST
78267: LIST
78268: PUSH
78269: LD_INT 0
78271: PUSH
78272: LD_INT 3
78274: NEG
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: PUSH
78280: LD_INT 1
78282: NEG
78283: PUSH
78284: LD_INT 4
78286: NEG
78287: PUSH
78288: EMPTY
78289: LIST
78290: LIST
78291: PUSH
78292: LD_INT 1
78294: NEG
78295: PUSH
78296: LD_INT 5
78298: NEG
78299: PUSH
78300: EMPTY
78301: LIST
78302: LIST
78303: PUSH
78304: LD_INT 2
78306: PUSH
78307: LD_INT 3
78309: NEG
78310: PUSH
78311: EMPTY
78312: LIST
78313: LIST
78314: PUSH
78315: LD_INT 2
78317: NEG
78318: PUSH
78319: LD_INT 5
78321: NEG
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: PUSH
78327: LD_INT 3
78329: PUSH
78330: LD_INT 0
78332: PUSH
78333: EMPTY
78334: LIST
78335: LIST
78336: PUSH
78337: LD_INT 3
78339: PUSH
78340: LD_INT 1
78342: NEG
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 4
78350: PUSH
78351: LD_INT 0
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: LD_INT 4
78360: PUSH
78361: LD_INT 1
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: PUSH
78368: LD_INT 3
78370: PUSH
78371: LD_INT 1
78373: PUSH
78374: EMPTY
78375: LIST
78376: LIST
78377: PUSH
78378: LD_INT 2
78380: PUSH
78381: LD_INT 0
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: LD_INT 2
78390: PUSH
78391: LD_INT 1
78393: NEG
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: LD_INT 2
78401: PUSH
78402: LD_INT 2
78404: NEG
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: PUSH
78410: LD_INT 4
78412: PUSH
78413: LD_INT 2
78415: PUSH
78416: EMPTY
78417: LIST
78418: LIST
78419: PUSH
78420: LD_INT 4
78422: PUSH
78423: LD_INT 4
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 4
78432: PUSH
78433: LD_INT 3
78435: PUSH
78436: EMPTY
78437: LIST
78438: LIST
78439: PUSH
78440: LD_INT 5
78442: PUSH
78443: LD_INT 4
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: LD_INT 5
78452: PUSH
78453: LD_INT 5
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 4
78462: PUSH
78463: LD_INT 5
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: PUSH
78470: LD_INT 3
78472: PUSH
78473: LD_INT 4
78475: PUSH
78476: EMPTY
78477: LIST
78478: LIST
78479: PUSH
78480: LD_INT 3
78482: PUSH
78483: LD_INT 3
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: PUSH
78490: LD_INT 5
78492: PUSH
78493: LD_INT 3
78495: PUSH
78496: EMPTY
78497: LIST
78498: LIST
78499: PUSH
78500: LD_INT 3
78502: PUSH
78503: LD_INT 5
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: EMPTY
78511: LIST
78512: LIST
78513: LIST
78514: LIST
78515: LIST
78516: LIST
78517: LIST
78518: LIST
78519: LIST
78520: LIST
78521: LIST
78522: LIST
78523: LIST
78524: LIST
78525: LIST
78526: LIST
78527: LIST
78528: LIST
78529: LIST
78530: LIST
78531: LIST
78532: LIST
78533: LIST
78534: LIST
78535: LIST
78536: LIST
78537: LIST
78538: LIST
78539: LIST
78540: LIST
78541: LIST
78542: LIST
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: LIST
78552: LIST
78553: LIST
78554: LIST
78555: LIST
78556: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
78557: LD_ADDR_VAR 0 33
78561: PUSH
78562: LD_INT 4
78564: NEG
78565: PUSH
78566: LD_INT 4
78568: NEG
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: PUSH
78574: LD_INT 4
78576: NEG
78577: PUSH
78578: LD_INT 5
78580: NEG
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: PUSH
78586: LD_INT 3
78588: NEG
78589: PUSH
78590: LD_INT 4
78592: NEG
78593: PUSH
78594: EMPTY
78595: LIST
78596: LIST
78597: PUSH
78598: LD_INT 3
78600: NEG
78601: PUSH
78602: LD_INT 3
78604: NEG
78605: PUSH
78606: EMPTY
78607: LIST
78608: LIST
78609: PUSH
78610: LD_INT 4
78612: NEG
78613: PUSH
78614: LD_INT 3
78616: NEG
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PUSH
78622: LD_INT 5
78624: NEG
78625: PUSH
78626: LD_INT 4
78628: NEG
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: PUSH
78634: LD_INT 5
78636: NEG
78637: PUSH
78638: LD_INT 5
78640: NEG
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: PUSH
78646: LD_INT 3
78648: NEG
78649: PUSH
78650: LD_INT 5
78652: NEG
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 5
78660: NEG
78661: PUSH
78662: LD_INT 3
78664: NEG
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 0
78672: PUSH
78673: LD_INT 3
78675: NEG
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 0
78683: PUSH
78684: LD_INT 4
78686: NEG
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 1
78694: PUSH
78695: LD_INT 3
78697: NEG
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: PUSH
78703: LD_INT 1
78705: PUSH
78706: LD_INT 2
78708: NEG
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 0
78716: PUSH
78717: LD_INT 2
78719: NEG
78720: PUSH
78721: EMPTY
78722: LIST
78723: LIST
78724: PUSH
78725: LD_INT 1
78727: NEG
78728: PUSH
78729: LD_INT 3
78731: NEG
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: LD_INT 1
78739: NEG
78740: PUSH
78741: LD_INT 4
78743: NEG
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 2
78751: PUSH
78752: LD_INT 2
78754: NEG
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: PUSH
78760: LD_INT 2
78762: NEG
78763: PUSH
78764: LD_INT 4
78766: NEG
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 4
78774: PUSH
78775: LD_INT 0
78777: PUSH
78778: EMPTY
78779: LIST
78780: LIST
78781: PUSH
78782: LD_INT 4
78784: PUSH
78785: LD_INT 1
78787: NEG
78788: PUSH
78789: EMPTY
78790: LIST
78791: LIST
78792: PUSH
78793: LD_INT 5
78795: PUSH
78796: LD_INT 0
78798: PUSH
78799: EMPTY
78800: LIST
78801: LIST
78802: PUSH
78803: LD_INT 5
78805: PUSH
78806: LD_INT 1
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: PUSH
78813: LD_INT 4
78815: PUSH
78816: LD_INT 1
78818: PUSH
78819: EMPTY
78820: LIST
78821: LIST
78822: PUSH
78823: LD_INT 3
78825: PUSH
78826: LD_INT 0
78828: PUSH
78829: EMPTY
78830: LIST
78831: LIST
78832: PUSH
78833: LD_INT 3
78835: PUSH
78836: LD_INT 1
78838: NEG
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 3
78846: PUSH
78847: LD_INT 2
78849: NEG
78850: PUSH
78851: EMPTY
78852: LIST
78853: LIST
78854: PUSH
78855: LD_INT 5
78857: PUSH
78858: LD_INT 2
78860: PUSH
78861: EMPTY
78862: LIST
78863: LIST
78864: PUSH
78865: LD_INT 3
78867: PUSH
78868: LD_INT 3
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: PUSH
78875: LD_INT 3
78877: PUSH
78878: LD_INT 2
78880: PUSH
78881: EMPTY
78882: LIST
78883: LIST
78884: PUSH
78885: LD_INT 4
78887: PUSH
78888: LD_INT 3
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 4
78897: PUSH
78898: LD_INT 4
78900: PUSH
78901: EMPTY
78902: LIST
78903: LIST
78904: PUSH
78905: LD_INT 3
78907: PUSH
78908: LD_INT 4
78910: PUSH
78911: EMPTY
78912: LIST
78913: LIST
78914: PUSH
78915: LD_INT 2
78917: PUSH
78918: LD_INT 3
78920: PUSH
78921: EMPTY
78922: LIST
78923: LIST
78924: PUSH
78925: LD_INT 2
78927: PUSH
78928: LD_INT 2
78930: PUSH
78931: EMPTY
78932: LIST
78933: LIST
78934: PUSH
78935: LD_INT 4
78937: PUSH
78938: LD_INT 2
78940: PUSH
78941: EMPTY
78942: LIST
78943: LIST
78944: PUSH
78945: LD_INT 2
78947: PUSH
78948: LD_INT 4
78950: PUSH
78951: EMPTY
78952: LIST
78953: LIST
78954: PUSH
78955: LD_INT 0
78957: PUSH
78958: LD_INT 4
78960: PUSH
78961: EMPTY
78962: LIST
78963: LIST
78964: PUSH
78965: LD_INT 0
78967: PUSH
78968: LD_INT 3
78970: PUSH
78971: EMPTY
78972: LIST
78973: LIST
78974: PUSH
78975: LD_INT 1
78977: PUSH
78978: LD_INT 4
78980: PUSH
78981: EMPTY
78982: LIST
78983: LIST
78984: PUSH
78985: LD_INT 1
78987: PUSH
78988: LD_INT 5
78990: PUSH
78991: EMPTY
78992: LIST
78993: LIST
78994: PUSH
78995: LD_INT 0
78997: PUSH
78998: LD_INT 5
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: PUSH
79005: LD_INT 1
79007: NEG
79008: PUSH
79009: LD_INT 4
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: PUSH
79016: LD_INT 1
79018: NEG
79019: PUSH
79020: LD_INT 3
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PUSH
79027: LD_INT 2
79029: PUSH
79030: LD_INT 5
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 2
79039: NEG
79040: PUSH
79041: LD_INT 3
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: LIST
79052: LIST
79053: LIST
79054: LIST
79055: LIST
79056: LIST
79057: LIST
79058: LIST
79059: LIST
79060: LIST
79061: LIST
79062: LIST
79063: LIST
79064: LIST
79065: LIST
79066: LIST
79067: LIST
79068: LIST
79069: LIST
79070: LIST
79071: LIST
79072: LIST
79073: LIST
79074: LIST
79075: LIST
79076: LIST
79077: LIST
79078: LIST
79079: LIST
79080: LIST
79081: LIST
79082: LIST
79083: LIST
79084: LIST
79085: LIST
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: LIST
79092: LIST
79093: LIST
79094: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79095: LD_ADDR_VAR 0 34
79099: PUSH
79100: LD_INT 0
79102: PUSH
79103: LD_INT 4
79105: NEG
79106: PUSH
79107: EMPTY
79108: LIST
79109: LIST
79110: PUSH
79111: LD_INT 0
79113: PUSH
79114: LD_INT 5
79116: NEG
79117: PUSH
79118: EMPTY
79119: LIST
79120: LIST
79121: PUSH
79122: LD_INT 1
79124: PUSH
79125: LD_INT 4
79127: NEG
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: PUSH
79133: LD_INT 1
79135: PUSH
79136: LD_INT 3
79138: NEG
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 0
79146: PUSH
79147: LD_INT 3
79149: NEG
79150: PUSH
79151: EMPTY
79152: LIST
79153: LIST
79154: PUSH
79155: LD_INT 1
79157: NEG
79158: PUSH
79159: LD_INT 4
79161: NEG
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 1
79169: NEG
79170: PUSH
79171: LD_INT 5
79173: NEG
79174: PUSH
79175: EMPTY
79176: LIST
79177: LIST
79178: PUSH
79179: LD_INT 2
79181: PUSH
79182: LD_INT 3
79184: NEG
79185: PUSH
79186: EMPTY
79187: LIST
79188: LIST
79189: PUSH
79190: LD_INT 2
79192: NEG
79193: PUSH
79194: LD_INT 5
79196: NEG
79197: PUSH
79198: EMPTY
79199: LIST
79200: LIST
79201: PUSH
79202: LD_INT 3
79204: PUSH
79205: LD_INT 0
79207: PUSH
79208: EMPTY
79209: LIST
79210: LIST
79211: PUSH
79212: LD_INT 3
79214: PUSH
79215: LD_INT 1
79217: NEG
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 4
79225: PUSH
79226: LD_INT 0
79228: PUSH
79229: EMPTY
79230: LIST
79231: LIST
79232: PUSH
79233: LD_INT 4
79235: PUSH
79236: LD_INT 1
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 3
79245: PUSH
79246: LD_INT 1
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: PUSH
79253: LD_INT 2
79255: PUSH
79256: LD_INT 0
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 2
79265: PUSH
79266: LD_INT 1
79268: NEG
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 2
79276: PUSH
79277: LD_INT 2
79279: NEG
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: PUSH
79285: LD_INT 4
79287: PUSH
79288: LD_INT 2
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 4
79297: PUSH
79298: LD_INT 4
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: LD_INT 4
79307: PUSH
79308: LD_INT 3
79310: PUSH
79311: EMPTY
79312: LIST
79313: LIST
79314: PUSH
79315: LD_INT 5
79317: PUSH
79318: LD_INT 4
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 5
79327: PUSH
79328: LD_INT 5
79330: PUSH
79331: EMPTY
79332: LIST
79333: LIST
79334: PUSH
79335: LD_INT 4
79337: PUSH
79338: LD_INT 5
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: LD_INT 3
79347: PUSH
79348: LD_INT 4
79350: PUSH
79351: EMPTY
79352: LIST
79353: LIST
79354: PUSH
79355: LD_INT 3
79357: PUSH
79358: LD_INT 3
79360: PUSH
79361: EMPTY
79362: LIST
79363: LIST
79364: PUSH
79365: LD_INT 5
79367: PUSH
79368: LD_INT 3
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: LD_INT 3
79377: PUSH
79378: LD_INT 5
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 0
79387: PUSH
79388: LD_INT 3
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: LD_INT 0
79397: PUSH
79398: LD_INT 2
79400: PUSH
79401: EMPTY
79402: LIST
79403: LIST
79404: PUSH
79405: LD_INT 1
79407: PUSH
79408: LD_INT 3
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 1
79417: PUSH
79418: LD_INT 4
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: PUSH
79425: LD_INT 0
79427: PUSH
79428: LD_INT 4
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 1
79437: NEG
79438: PUSH
79439: LD_INT 3
79441: PUSH
79442: EMPTY
79443: LIST
79444: LIST
79445: PUSH
79446: LD_INT 1
79448: NEG
79449: PUSH
79450: LD_INT 2
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: LD_INT 2
79459: PUSH
79460: LD_INT 4
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: LD_INT 2
79469: NEG
79470: PUSH
79471: LD_INT 2
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 4
79480: NEG
79481: PUSH
79482: LD_INT 0
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: PUSH
79489: LD_INT 4
79491: NEG
79492: PUSH
79493: LD_INT 1
79495: NEG
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: PUSH
79501: LD_INT 3
79503: NEG
79504: PUSH
79505: LD_INT 0
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: LD_INT 3
79514: NEG
79515: PUSH
79516: LD_INT 1
79518: PUSH
79519: EMPTY
79520: LIST
79521: LIST
79522: PUSH
79523: LD_INT 4
79525: NEG
79526: PUSH
79527: LD_INT 1
79529: PUSH
79530: EMPTY
79531: LIST
79532: LIST
79533: PUSH
79534: LD_INT 5
79536: NEG
79537: PUSH
79538: LD_INT 0
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PUSH
79545: LD_INT 5
79547: NEG
79548: PUSH
79549: LD_INT 1
79551: NEG
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: PUSH
79557: LD_INT 5
79559: NEG
79560: PUSH
79561: LD_INT 2
79563: NEG
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 3
79571: NEG
79572: PUSH
79573: LD_INT 2
79575: PUSH
79576: EMPTY
79577: LIST
79578: LIST
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: LIST
79584: LIST
79585: LIST
79586: LIST
79587: LIST
79588: LIST
79589: LIST
79590: LIST
79591: LIST
79592: LIST
79593: LIST
79594: LIST
79595: LIST
79596: LIST
79597: LIST
79598: LIST
79599: LIST
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: LIST
79608: LIST
79609: LIST
79610: LIST
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: LIST
79623: LIST
79624: LIST
79625: LIST
79626: ST_TO_ADDR
// end ; end ;
79627: GO 79630
79629: POP
// case btype of b_depot , b_warehouse :
79630: LD_VAR 0 1
79634: PUSH
79635: LD_INT 0
79637: DOUBLE
79638: EQUAL
79639: IFTRUE 79649
79641: LD_INT 1
79643: DOUBLE
79644: EQUAL
79645: IFTRUE 79649
79647: GO 79850
79649: POP
// case nation of nation_american :
79650: LD_VAR 0 5
79654: PUSH
79655: LD_INT 1
79657: DOUBLE
79658: EQUAL
79659: IFTRUE 79663
79661: GO 79719
79663: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
79664: LD_ADDR_VAR 0 9
79668: PUSH
79669: LD_VAR 0 11
79673: PUSH
79674: LD_VAR 0 12
79678: PUSH
79679: LD_VAR 0 13
79683: PUSH
79684: LD_VAR 0 14
79688: PUSH
79689: LD_VAR 0 15
79693: PUSH
79694: LD_VAR 0 16
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: LIST
79703: LIST
79704: LIST
79705: LIST
79706: PUSH
79707: LD_VAR 0 4
79711: PUSH
79712: LD_INT 1
79714: PLUS
79715: ARRAY
79716: ST_TO_ADDR
79717: GO 79848
79719: LD_INT 2
79721: DOUBLE
79722: EQUAL
79723: IFTRUE 79727
79725: GO 79783
79727: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
79728: LD_ADDR_VAR 0 9
79732: PUSH
79733: LD_VAR 0 17
79737: PUSH
79738: LD_VAR 0 18
79742: PUSH
79743: LD_VAR 0 19
79747: PUSH
79748: LD_VAR 0 20
79752: PUSH
79753: LD_VAR 0 21
79757: PUSH
79758: LD_VAR 0 22
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: LIST
79767: LIST
79768: LIST
79769: LIST
79770: PUSH
79771: LD_VAR 0 4
79775: PUSH
79776: LD_INT 1
79778: PLUS
79779: ARRAY
79780: ST_TO_ADDR
79781: GO 79848
79783: LD_INT 3
79785: DOUBLE
79786: EQUAL
79787: IFTRUE 79791
79789: GO 79847
79791: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
79792: LD_ADDR_VAR 0 9
79796: PUSH
79797: LD_VAR 0 23
79801: PUSH
79802: LD_VAR 0 24
79806: PUSH
79807: LD_VAR 0 25
79811: PUSH
79812: LD_VAR 0 26
79816: PUSH
79817: LD_VAR 0 27
79821: PUSH
79822: LD_VAR 0 28
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: LIST
79831: LIST
79832: LIST
79833: LIST
79834: PUSH
79835: LD_VAR 0 4
79839: PUSH
79840: LD_INT 1
79842: PLUS
79843: ARRAY
79844: ST_TO_ADDR
79845: GO 79848
79847: POP
79848: GO 80403
79850: LD_INT 2
79852: DOUBLE
79853: EQUAL
79854: IFTRUE 79864
79856: LD_INT 3
79858: DOUBLE
79859: EQUAL
79860: IFTRUE 79864
79862: GO 79920
79864: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
79865: LD_ADDR_VAR 0 9
79869: PUSH
79870: LD_VAR 0 29
79874: PUSH
79875: LD_VAR 0 30
79879: PUSH
79880: LD_VAR 0 31
79884: PUSH
79885: LD_VAR 0 32
79889: PUSH
79890: LD_VAR 0 33
79894: PUSH
79895: LD_VAR 0 34
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: LIST
79904: LIST
79905: LIST
79906: LIST
79907: PUSH
79908: LD_VAR 0 4
79912: PUSH
79913: LD_INT 1
79915: PLUS
79916: ARRAY
79917: ST_TO_ADDR
79918: GO 80403
79920: LD_INT 16
79922: DOUBLE
79923: EQUAL
79924: IFTRUE 79982
79926: LD_INT 17
79928: DOUBLE
79929: EQUAL
79930: IFTRUE 79982
79932: LD_INT 18
79934: DOUBLE
79935: EQUAL
79936: IFTRUE 79982
79938: LD_INT 19
79940: DOUBLE
79941: EQUAL
79942: IFTRUE 79982
79944: LD_INT 22
79946: DOUBLE
79947: EQUAL
79948: IFTRUE 79982
79950: LD_INT 20
79952: DOUBLE
79953: EQUAL
79954: IFTRUE 79982
79956: LD_INT 21
79958: DOUBLE
79959: EQUAL
79960: IFTRUE 79982
79962: LD_INT 23
79964: DOUBLE
79965: EQUAL
79966: IFTRUE 79982
79968: LD_INT 24
79970: DOUBLE
79971: EQUAL
79972: IFTRUE 79982
79974: LD_INT 25
79976: DOUBLE
79977: EQUAL
79978: IFTRUE 79982
79980: GO 80038
79982: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
79983: LD_ADDR_VAR 0 9
79987: PUSH
79988: LD_VAR 0 35
79992: PUSH
79993: LD_VAR 0 36
79997: PUSH
79998: LD_VAR 0 37
80002: PUSH
80003: LD_VAR 0 38
80007: PUSH
80008: LD_VAR 0 39
80012: PUSH
80013: LD_VAR 0 40
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: LIST
80022: LIST
80023: LIST
80024: LIST
80025: PUSH
80026: LD_VAR 0 4
80030: PUSH
80031: LD_INT 1
80033: PLUS
80034: ARRAY
80035: ST_TO_ADDR
80036: GO 80403
80038: LD_INT 6
80040: DOUBLE
80041: EQUAL
80042: IFTRUE 80094
80044: LD_INT 7
80046: DOUBLE
80047: EQUAL
80048: IFTRUE 80094
80050: LD_INT 8
80052: DOUBLE
80053: EQUAL
80054: IFTRUE 80094
80056: LD_INT 13
80058: DOUBLE
80059: EQUAL
80060: IFTRUE 80094
80062: LD_INT 12
80064: DOUBLE
80065: EQUAL
80066: IFTRUE 80094
80068: LD_INT 15
80070: DOUBLE
80071: EQUAL
80072: IFTRUE 80094
80074: LD_INT 11
80076: DOUBLE
80077: EQUAL
80078: IFTRUE 80094
80080: LD_INT 14
80082: DOUBLE
80083: EQUAL
80084: IFTRUE 80094
80086: LD_INT 10
80088: DOUBLE
80089: EQUAL
80090: IFTRUE 80094
80092: GO 80150
80094: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
80095: LD_ADDR_VAR 0 9
80099: PUSH
80100: LD_VAR 0 41
80104: PUSH
80105: LD_VAR 0 42
80109: PUSH
80110: LD_VAR 0 43
80114: PUSH
80115: LD_VAR 0 44
80119: PUSH
80120: LD_VAR 0 45
80124: PUSH
80125: LD_VAR 0 46
80129: PUSH
80130: EMPTY
80131: LIST
80132: LIST
80133: LIST
80134: LIST
80135: LIST
80136: LIST
80137: PUSH
80138: LD_VAR 0 4
80142: PUSH
80143: LD_INT 1
80145: PLUS
80146: ARRAY
80147: ST_TO_ADDR
80148: GO 80403
80150: LD_INT 36
80152: DOUBLE
80153: EQUAL
80154: IFTRUE 80158
80156: GO 80214
80158: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80159: LD_ADDR_VAR 0 9
80163: PUSH
80164: LD_VAR 0 47
80168: PUSH
80169: LD_VAR 0 48
80173: PUSH
80174: LD_VAR 0 49
80178: PUSH
80179: LD_VAR 0 50
80183: PUSH
80184: LD_VAR 0 51
80188: PUSH
80189: LD_VAR 0 52
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: LIST
80198: LIST
80199: LIST
80200: LIST
80201: PUSH
80202: LD_VAR 0 4
80206: PUSH
80207: LD_INT 1
80209: PLUS
80210: ARRAY
80211: ST_TO_ADDR
80212: GO 80403
80214: LD_INT 4
80216: DOUBLE
80217: EQUAL
80218: IFTRUE 80240
80220: LD_INT 5
80222: DOUBLE
80223: EQUAL
80224: IFTRUE 80240
80226: LD_INT 34
80228: DOUBLE
80229: EQUAL
80230: IFTRUE 80240
80232: LD_INT 37
80234: DOUBLE
80235: EQUAL
80236: IFTRUE 80240
80238: GO 80296
80240: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
80241: LD_ADDR_VAR 0 9
80245: PUSH
80246: LD_VAR 0 53
80250: PUSH
80251: LD_VAR 0 54
80255: PUSH
80256: LD_VAR 0 55
80260: PUSH
80261: LD_VAR 0 56
80265: PUSH
80266: LD_VAR 0 57
80270: PUSH
80271: LD_VAR 0 58
80275: PUSH
80276: EMPTY
80277: LIST
80278: LIST
80279: LIST
80280: LIST
80281: LIST
80282: LIST
80283: PUSH
80284: LD_VAR 0 4
80288: PUSH
80289: LD_INT 1
80291: PLUS
80292: ARRAY
80293: ST_TO_ADDR
80294: GO 80403
80296: LD_INT 31
80298: DOUBLE
80299: EQUAL
80300: IFTRUE 80346
80302: LD_INT 32
80304: DOUBLE
80305: EQUAL
80306: IFTRUE 80346
80308: LD_INT 33
80310: DOUBLE
80311: EQUAL
80312: IFTRUE 80346
80314: LD_INT 27
80316: DOUBLE
80317: EQUAL
80318: IFTRUE 80346
80320: LD_INT 26
80322: DOUBLE
80323: EQUAL
80324: IFTRUE 80346
80326: LD_INT 28
80328: DOUBLE
80329: EQUAL
80330: IFTRUE 80346
80332: LD_INT 29
80334: DOUBLE
80335: EQUAL
80336: IFTRUE 80346
80338: LD_INT 30
80340: DOUBLE
80341: EQUAL
80342: IFTRUE 80346
80344: GO 80402
80346: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
80347: LD_ADDR_VAR 0 9
80351: PUSH
80352: LD_VAR 0 59
80356: PUSH
80357: LD_VAR 0 60
80361: PUSH
80362: LD_VAR 0 61
80366: PUSH
80367: LD_VAR 0 62
80371: PUSH
80372: LD_VAR 0 63
80376: PUSH
80377: LD_VAR 0 64
80381: PUSH
80382: EMPTY
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: PUSH
80390: LD_VAR 0 4
80394: PUSH
80395: LD_INT 1
80397: PLUS
80398: ARRAY
80399: ST_TO_ADDR
80400: GO 80403
80402: POP
// temp_list2 = [ ] ;
80403: LD_ADDR_VAR 0 10
80407: PUSH
80408: EMPTY
80409: ST_TO_ADDR
// for i in temp_list do
80410: LD_ADDR_VAR 0 8
80414: PUSH
80415: LD_VAR 0 9
80419: PUSH
80420: FOR_IN
80421: IFFALSE 80473
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
80423: LD_ADDR_VAR 0 10
80427: PUSH
80428: LD_VAR 0 10
80432: PUSH
80433: LD_VAR 0 8
80437: PUSH
80438: LD_INT 1
80440: ARRAY
80441: PUSH
80442: LD_VAR 0 2
80446: PLUS
80447: PUSH
80448: LD_VAR 0 8
80452: PUSH
80453: LD_INT 2
80455: ARRAY
80456: PUSH
80457: LD_VAR 0 3
80461: PLUS
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: EMPTY
80468: LIST
80469: ADD
80470: ST_TO_ADDR
80471: GO 80420
80473: POP
80474: POP
// result = temp_list2 ;
80475: LD_ADDR_VAR 0 7
80479: PUSH
80480: LD_VAR 0 10
80484: ST_TO_ADDR
// end ;
80485: LD_VAR 0 7
80489: RET
// export function EnemyInRange ( unit , dist ) ; begin
80490: LD_INT 0
80492: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
80493: LD_ADDR_VAR 0 3
80497: PUSH
80498: LD_VAR 0 1
80502: PPUSH
80503: CALL_OW 255
80507: PPUSH
80508: LD_VAR 0 1
80512: PPUSH
80513: CALL_OW 250
80517: PPUSH
80518: LD_VAR 0 1
80522: PPUSH
80523: CALL_OW 251
80527: PPUSH
80528: LD_VAR 0 2
80532: PPUSH
80533: CALL 54594 0 4
80537: PUSH
80538: LD_INT 4
80540: ARRAY
80541: ST_TO_ADDR
// end ;
80542: LD_VAR 0 3
80546: RET
// export function PlayerSeeMe ( unit ) ; begin
80547: LD_INT 0
80549: PPUSH
// result := See ( your_side , unit ) ;
80550: LD_ADDR_VAR 0 2
80554: PUSH
80555: LD_OWVAR 2
80559: PPUSH
80560: LD_VAR 0 1
80564: PPUSH
80565: CALL_OW 292
80569: ST_TO_ADDR
// end ;
80570: LD_VAR 0 2
80574: RET
// export function ReverseDir ( unit ) ; begin
80575: LD_INT 0
80577: PPUSH
// if not unit then
80578: LD_VAR 0 1
80582: NOT
80583: IFFALSE 80587
// exit ;
80585: GO 80633
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
80587: LD_ADDR_VAR 0 2
80591: PUSH
80592: LD_INT 3
80594: PUSH
80595: LD_INT 4
80597: PUSH
80598: LD_INT 5
80600: PUSH
80601: LD_INT 0
80603: PUSH
80604: LD_INT 1
80606: PUSH
80607: LD_INT 2
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: LIST
80614: LIST
80615: LIST
80616: LIST
80617: PUSH
80618: LD_VAR 0 1
80622: PPUSH
80623: CALL_OW 254
80627: PUSH
80628: LD_INT 1
80630: PLUS
80631: ARRAY
80632: ST_TO_ADDR
// end ;
80633: LD_VAR 0 2
80637: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
80638: LD_INT 0
80640: PPUSH
80641: PPUSH
80642: PPUSH
80643: PPUSH
80644: PPUSH
// if not hexes then
80645: LD_VAR 0 2
80649: NOT
80650: IFFALSE 80654
// exit ;
80652: GO 80802
// dist := 9999 ;
80654: LD_ADDR_VAR 0 5
80658: PUSH
80659: LD_INT 9999
80661: ST_TO_ADDR
// for i = 1 to hexes do
80662: LD_ADDR_VAR 0 4
80666: PUSH
80667: DOUBLE
80668: LD_INT 1
80670: DEC
80671: ST_TO_ADDR
80672: LD_VAR 0 2
80676: PUSH
80677: FOR_TO
80678: IFFALSE 80790
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
80680: LD_VAR 0 1
80684: PPUSH
80685: LD_VAR 0 2
80689: PUSH
80690: LD_VAR 0 4
80694: ARRAY
80695: PUSH
80696: LD_INT 1
80698: ARRAY
80699: PPUSH
80700: LD_VAR 0 2
80704: PUSH
80705: LD_VAR 0 4
80709: ARRAY
80710: PUSH
80711: LD_INT 2
80713: ARRAY
80714: PPUSH
80715: CALL_OW 297
80719: PUSH
80720: LD_VAR 0 5
80724: LESS
80725: IFFALSE 80788
// begin hex := hexes [ i ] ;
80727: LD_ADDR_VAR 0 7
80731: PUSH
80732: LD_VAR 0 2
80736: PUSH
80737: LD_VAR 0 4
80741: ARRAY
80742: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
80743: LD_ADDR_VAR 0 5
80747: PUSH
80748: LD_VAR 0 1
80752: PPUSH
80753: LD_VAR 0 2
80757: PUSH
80758: LD_VAR 0 4
80762: ARRAY
80763: PUSH
80764: LD_INT 1
80766: ARRAY
80767: PPUSH
80768: LD_VAR 0 2
80772: PUSH
80773: LD_VAR 0 4
80777: ARRAY
80778: PUSH
80779: LD_INT 2
80781: ARRAY
80782: PPUSH
80783: CALL_OW 297
80787: ST_TO_ADDR
// end ; end ;
80788: GO 80677
80790: POP
80791: POP
// result := hex ;
80792: LD_ADDR_VAR 0 3
80796: PUSH
80797: LD_VAR 0 7
80801: ST_TO_ADDR
// end ;
80802: LD_VAR 0 3
80806: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
80807: LD_INT 0
80809: PPUSH
80810: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
80811: LD_VAR 0 1
80815: NOT
80816: PUSH
80817: LD_VAR 0 1
80821: PUSH
80822: LD_INT 21
80824: PUSH
80825: LD_INT 2
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PUSH
80832: LD_INT 23
80834: PUSH
80835: LD_INT 2
80837: PUSH
80838: EMPTY
80839: LIST
80840: LIST
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PPUSH
80846: CALL_OW 69
80850: IN
80851: NOT
80852: OR
80853: IFFALSE 80857
// exit ;
80855: GO 80904
// for i = 1 to 3 do
80857: LD_ADDR_VAR 0 3
80861: PUSH
80862: DOUBLE
80863: LD_INT 1
80865: DEC
80866: ST_TO_ADDR
80867: LD_INT 3
80869: PUSH
80870: FOR_TO
80871: IFFALSE 80902
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
80873: LD_VAR 0 1
80877: PPUSH
80878: CALL_OW 250
80882: PPUSH
80883: LD_VAR 0 1
80887: PPUSH
80888: CALL_OW 251
80892: PPUSH
80893: LD_INT 1
80895: PPUSH
80896: CALL_OW 453
80900: GO 80870
80902: POP
80903: POP
// end ;
80904: LD_VAR 0 2
80908: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
80909: LD_INT 0
80911: PPUSH
80912: PPUSH
80913: PPUSH
80914: PPUSH
80915: PPUSH
80916: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
80917: LD_VAR 0 1
80921: NOT
80922: PUSH
80923: LD_VAR 0 2
80927: NOT
80928: OR
80929: PUSH
80930: LD_VAR 0 1
80934: PPUSH
80935: CALL_OW 314
80939: OR
80940: IFFALSE 80944
// exit ;
80942: GO 81385
// x := GetX ( enemy_unit ) ;
80944: LD_ADDR_VAR 0 7
80948: PUSH
80949: LD_VAR 0 2
80953: PPUSH
80954: CALL_OW 250
80958: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
80959: LD_ADDR_VAR 0 8
80963: PUSH
80964: LD_VAR 0 2
80968: PPUSH
80969: CALL_OW 251
80973: ST_TO_ADDR
// if not x or not y then
80974: LD_VAR 0 7
80978: NOT
80979: PUSH
80980: LD_VAR 0 8
80984: NOT
80985: OR
80986: IFFALSE 80990
// exit ;
80988: GO 81385
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
80990: LD_ADDR_VAR 0 6
80994: PUSH
80995: LD_VAR 0 7
80999: PPUSH
81000: LD_INT 0
81002: PPUSH
81003: LD_INT 4
81005: PPUSH
81006: CALL_OW 272
81010: PUSH
81011: LD_VAR 0 8
81015: PPUSH
81016: LD_INT 0
81018: PPUSH
81019: LD_INT 4
81021: PPUSH
81022: CALL_OW 273
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_VAR 0 7
81035: PPUSH
81036: LD_INT 1
81038: PPUSH
81039: LD_INT 4
81041: PPUSH
81042: CALL_OW 272
81046: PUSH
81047: LD_VAR 0 8
81051: PPUSH
81052: LD_INT 1
81054: PPUSH
81055: LD_INT 4
81057: PPUSH
81058: CALL_OW 273
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PUSH
81067: LD_VAR 0 7
81071: PPUSH
81072: LD_INT 2
81074: PPUSH
81075: LD_INT 4
81077: PPUSH
81078: CALL_OW 272
81082: PUSH
81083: LD_VAR 0 8
81087: PPUSH
81088: LD_INT 2
81090: PPUSH
81091: LD_INT 4
81093: PPUSH
81094: CALL_OW 273
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_VAR 0 7
81107: PPUSH
81108: LD_INT 3
81110: PPUSH
81111: LD_INT 4
81113: PPUSH
81114: CALL_OW 272
81118: PUSH
81119: LD_VAR 0 8
81123: PPUSH
81124: LD_INT 3
81126: PPUSH
81127: LD_INT 4
81129: PPUSH
81130: CALL_OW 273
81134: PUSH
81135: EMPTY
81136: LIST
81137: LIST
81138: PUSH
81139: LD_VAR 0 7
81143: PPUSH
81144: LD_INT 4
81146: PPUSH
81147: LD_INT 4
81149: PPUSH
81150: CALL_OW 272
81154: PUSH
81155: LD_VAR 0 8
81159: PPUSH
81160: LD_INT 4
81162: PPUSH
81163: LD_INT 4
81165: PPUSH
81166: CALL_OW 273
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_VAR 0 7
81179: PPUSH
81180: LD_INT 5
81182: PPUSH
81183: LD_INT 4
81185: PPUSH
81186: CALL_OW 272
81190: PUSH
81191: LD_VAR 0 8
81195: PPUSH
81196: LD_INT 5
81198: PPUSH
81199: LD_INT 4
81201: PPUSH
81202: CALL_OW 273
81206: PUSH
81207: EMPTY
81208: LIST
81209: LIST
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: LIST
81215: LIST
81216: LIST
81217: LIST
81218: ST_TO_ADDR
// for i = tmp downto 1 do
81219: LD_ADDR_VAR 0 4
81223: PUSH
81224: DOUBLE
81225: LD_VAR 0 6
81229: INC
81230: ST_TO_ADDR
81231: LD_INT 1
81233: PUSH
81234: FOR_DOWNTO
81235: IFFALSE 81336
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
81237: LD_VAR 0 6
81241: PUSH
81242: LD_VAR 0 4
81246: ARRAY
81247: PUSH
81248: LD_INT 1
81250: ARRAY
81251: PPUSH
81252: LD_VAR 0 6
81256: PUSH
81257: LD_VAR 0 4
81261: ARRAY
81262: PUSH
81263: LD_INT 2
81265: ARRAY
81266: PPUSH
81267: CALL_OW 488
81271: NOT
81272: PUSH
81273: LD_VAR 0 6
81277: PUSH
81278: LD_VAR 0 4
81282: ARRAY
81283: PUSH
81284: LD_INT 1
81286: ARRAY
81287: PPUSH
81288: LD_VAR 0 6
81292: PUSH
81293: LD_VAR 0 4
81297: ARRAY
81298: PUSH
81299: LD_INT 2
81301: ARRAY
81302: PPUSH
81303: CALL_OW 428
81307: PUSH
81308: LD_INT 0
81310: NONEQUAL
81311: OR
81312: IFFALSE 81334
// tmp := Delete ( tmp , i ) ;
81314: LD_ADDR_VAR 0 6
81318: PUSH
81319: LD_VAR 0 6
81323: PPUSH
81324: LD_VAR 0 4
81328: PPUSH
81329: CALL_OW 3
81333: ST_TO_ADDR
81334: GO 81234
81336: POP
81337: POP
// j := GetClosestHex ( unit , tmp ) ;
81338: LD_ADDR_VAR 0 5
81342: PUSH
81343: LD_VAR 0 1
81347: PPUSH
81348: LD_VAR 0 6
81352: PPUSH
81353: CALL 80638 0 2
81357: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
81358: LD_VAR 0 1
81362: PPUSH
81363: LD_VAR 0 5
81367: PUSH
81368: LD_INT 1
81370: ARRAY
81371: PPUSH
81372: LD_VAR 0 5
81376: PUSH
81377: LD_INT 2
81379: ARRAY
81380: PPUSH
81381: CALL_OW 111
// end ;
81385: LD_VAR 0 3
81389: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
81390: LD_INT 0
81392: PPUSH
81393: PPUSH
81394: PPUSH
// uc_side = 0 ;
81395: LD_ADDR_OWVAR 20
81399: PUSH
81400: LD_INT 0
81402: ST_TO_ADDR
// uc_nation = 0 ;
81403: LD_ADDR_OWVAR 21
81407: PUSH
81408: LD_INT 0
81410: ST_TO_ADDR
// InitHc ;
81411: CALL_OW 19
// InitVc ;
81415: CALL_OW 20
// if mastodonts then
81419: LD_VAR 0 6
81423: IFFALSE 81490
// for i = 1 to mastodonts do
81425: LD_ADDR_VAR 0 11
81429: PUSH
81430: DOUBLE
81431: LD_INT 1
81433: DEC
81434: ST_TO_ADDR
81435: LD_VAR 0 6
81439: PUSH
81440: FOR_TO
81441: IFFALSE 81488
// begin vc_chassis := 31 ;
81443: LD_ADDR_OWVAR 37
81447: PUSH
81448: LD_INT 31
81450: ST_TO_ADDR
// vc_control := control_rider ;
81451: LD_ADDR_OWVAR 38
81455: PUSH
81456: LD_INT 4
81458: ST_TO_ADDR
// animal := CreateVehicle ;
81459: LD_ADDR_VAR 0 12
81463: PUSH
81464: CALL_OW 45
81468: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81469: LD_VAR 0 12
81473: PPUSH
81474: LD_VAR 0 8
81478: PPUSH
81479: LD_INT 0
81481: PPUSH
81482: CALL 88235 0 3
// end ;
81486: GO 81440
81488: POP
81489: POP
// if horses then
81490: LD_VAR 0 5
81494: IFFALSE 81561
// for i = 1 to horses do
81496: LD_ADDR_VAR 0 11
81500: PUSH
81501: DOUBLE
81502: LD_INT 1
81504: DEC
81505: ST_TO_ADDR
81506: LD_VAR 0 5
81510: PUSH
81511: FOR_TO
81512: IFFALSE 81559
// begin hc_class := 21 ;
81514: LD_ADDR_OWVAR 28
81518: PUSH
81519: LD_INT 21
81521: ST_TO_ADDR
// hc_gallery :=  ;
81522: LD_ADDR_OWVAR 33
81526: PUSH
81527: LD_STRING 
81529: ST_TO_ADDR
// animal := CreateHuman ;
81530: LD_ADDR_VAR 0 12
81534: PUSH
81535: CALL_OW 44
81539: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81540: LD_VAR 0 12
81544: PPUSH
81545: LD_VAR 0 8
81549: PPUSH
81550: LD_INT 0
81552: PPUSH
81553: CALL 88235 0 3
// end ;
81557: GO 81511
81559: POP
81560: POP
// if birds then
81561: LD_VAR 0 1
81565: IFFALSE 81632
// for i = 1 to birds do
81567: LD_ADDR_VAR 0 11
81571: PUSH
81572: DOUBLE
81573: LD_INT 1
81575: DEC
81576: ST_TO_ADDR
81577: LD_VAR 0 1
81581: PUSH
81582: FOR_TO
81583: IFFALSE 81630
// begin hc_class = 18 ;
81585: LD_ADDR_OWVAR 28
81589: PUSH
81590: LD_INT 18
81592: ST_TO_ADDR
// hc_gallery =  ;
81593: LD_ADDR_OWVAR 33
81597: PUSH
81598: LD_STRING 
81600: ST_TO_ADDR
// animal := CreateHuman ;
81601: LD_ADDR_VAR 0 12
81605: PUSH
81606: CALL_OW 44
81610: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81611: LD_VAR 0 12
81615: PPUSH
81616: LD_VAR 0 8
81620: PPUSH
81621: LD_INT 0
81623: PPUSH
81624: CALL 88235 0 3
// end ;
81628: GO 81582
81630: POP
81631: POP
// if tigers then
81632: LD_VAR 0 2
81636: IFFALSE 81720
// for i = 1 to tigers do
81638: LD_ADDR_VAR 0 11
81642: PUSH
81643: DOUBLE
81644: LD_INT 1
81646: DEC
81647: ST_TO_ADDR
81648: LD_VAR 0 2
81652: PUSH
81653: FOR_TO
81654: IFFALSE 81718
// begin hc_class = class_tiger ;
81656: LD_ADDR_OWVAR 28
81660: PUSH
81661: LD_INT 14
81663: ST_TO_ADDR
// hc_gallery =  ;
81664: LD_ADDR_OWVAR 33
81668: PUSH
81669: LD_STRING 
81671: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
81672: LD_ADDR_OWVAR 35
81676: PUSH
81677: LD_INT 7
81679: NEG
81680: PPUSH
81681: LD_INT 7
81683: PPUSH
81684: CALL_OW 12
81688: ST_TO_ADDR
// animal := CreateHuman ;
81689: LD_ADDR_VAR 0 12
81693: PUSH
81694: CALL_OW 44
81698: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81699: LD_VAR 0 12
81703: PPUSH
81704: LD_VAR 0 8
81708: PPUSH
81709: LD_INT 0
81711: PPUSH
81712: CALL 88235 0 3
// end ;
81716: GO 81653
81718: POP
81719: POP
// if apemans then
81720: LD_VAR 0 3
81724: IFFALSE 81847
// for i = 1 to apemans do
81726: LD_ADDR_VAR 0 11
81730: PUSH
81731: DOUBLE
81732: LD_INT 1
81734: DEC
81735: ST_TO_ADDR
81736: LD_VAR 0 3
81740: PUSH
81741: FOR_TO
81742: IFFALSE 81845
// begin hc_class = class_apeman ;
81744: LD_ADDR_OWVAR 28
81748: PUSH
81749: LD_INT 12
81751: ST_TO_ADDR
// hc_gallery =  ;
81752: LD_ADDR_OWVAR 33
81756: PUSH
81757: LD_STRING 
81759: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
81760: LD_ADDR_OWVAR 35
81764: PUSH
81765: LD_INT 5
81767: NEG
81768: PPUSH
81769: LD_INT 5
81771: PPUSH
81772: CALL_OW 12
81776: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
81777: LD_ADDR_OWVAR 31
81781: PUSH
81782: LD_INT 1
81784: PPUSH
81785: LD_INT 3
81787: PPUSH
81788: CALL_OW 12
81792: PUSH
81793: LD_INT 1
81795: PPUSH
81796: LD_INT 3
81798: PPUSH
81799: CALL_OW 12
81803: PUSH
81804: LD_INT 0
81806: PUSH
81807: LD_INT 0
81809: PUSH
81810: EMPTY
81811: LIST
81812: LIST
81813: LIST
81814: LIST
81815: ST_TO_ADDR
// animal := CreateHuman ;
81816: LD_ADDR_VAR 0 12
81820: PUSH
81821: CALL_OW 44
81825: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81826: LD_VAR 0 12
81830: PPUSH
81831: LD_VAR 0 8
81835: PPUSH
81836: LD_INT 0
81838: PPUSH
81839: CALL 88235 0 3
// end ;
81843: GO 81741
81845: POP
81846: POP
// if enchidnas then
81847: LD_VAR 0 4
81851: IFFALSE 81918
// for i = 1 to enchidnas do
81853: LD_ADDR_VAR 0 11
81857: PUSH
81858: DOUBLE
81859: LD_INT 1
81861: DEC
81862: ST_TO_ADDR
81863: LD_VAR 0 4
81867: PUSH
81868: FOR_TO
81869: IFFALSE 81916
// begin hc_class = 13 ;
81871: LD_ADDR_OWVAR 28
81875: PUSH
81876: LD_INT 13
81878: ST_TO_ADDR
// hc_gallery =  ;
81879: LD_ADDR_OWVAR 33
81883: PUSH
81884: LD_STRING 
81886: ST_TO_ADDR
// animal := CreateHuman ;
81887: LD_ADDR_VAR 0 12
81891: PUSH
81892: CALL_OW 44
81896: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81897: LD_VAR 0 12
81901: PPUSH
81902: LD_VAR 0 8
81906: PPUSH
81907: LD_INT 0
81909: PPUSH
81910: CALL 88235 0 3
// end ;
81914: GO 81868
81916: POP
81917: POP
// if fishes then
81918: LD_VAR 0 7
81922: IFFALSE 81989
// for i = 1 to fishes do
81924: LD_ADDR_VAR 0 11
81928: PUSH
81929: DOUBLE
81930: LD_INT 1
81932: DEC
81933: ST_TO_ADDR
81934: LD_VAR 0 7
81938: PUSH
81939: FOR_TO
81940: IFFALSE 81987
// begin hc_class = 20 ;
81942: LD_ADDR_OWVAR 28
81946: PUSH
81947: LD_INT 20
81949: ST_TO_ADDR
// hc_gallery =  ;
81950: LD_ADDR_OWVAR 33
81954: PUSH
81955: LD_STRING 
81957: ST_TO_ADDR
// animal := CreateHuman ;
81958: LD_ADDR_VAR 0 12
81962: PUSH
81963: CALL_OW 44
81967: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
81968: LD_VAR 0 12
81972: PPUSH
81973: LD_VAR 0 9
81977: PPUSH
81978: LD_INT 0
81980: PPUSH
81981: CALL 88235 0 3
// end ;
81985: GO 81939
81987: POP
81988: POP
// end ;
81989: LD_VAR 0 10
81993: RET
// export function WantHeal ( sci , unit ) ; begin
81994: LD_INT 0
81996: PPUSH
// if GetTaskList ( sci ) > 0 then
81997: LD_VAR 0 1
82001: PPUSH
82002: CALL_OW 437
82006: PUSH
82007: LD_INT 0
82009: GREATER
82010: IFFALSE 82080
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82012: LD_VAR 0 1
82016: PPUSH
82017: CALL_OW 437
82021: PUSH
82022: LD_INT 1
82024: ARRAY
82025: PUSH
82026: LD_INT 1
82028: ARRAY
82029: PUSH
82030: LD_STRING l
82032: EQUAL
82033: PUSH
82034: LD_VAR 0 1
82038: PPUSH
82039: CALL_OW 437
82043: PUSH
82044: LD_INT 1
82046: ARRAY
82047: PUSH
82048: LD_INT 4
82050: ARRAY
82051: PUSH
82052: LD_VAR 0 2
82056: EQUAL
82057: AND
82058: IFFALSE 82070
// result := true else
82060: LD_ADDR_VAR 0 3
82064: PUSH
82065: LD_INT 1
82067: ST_TO_ADDR
82068: GO 82078
// result := false ;
82070: LD_ADDR_VAR 0 3
82074: PUSH
82075: LD_INT 0
82077: ST_TO_ADDR
// end else
82078: GO 82088
// result := false ;
82080: LD_ADDR_VAR 0 3
82084: PUSH
82085: LD_INT 0
82087: ST_TO_ADDR
// end ;
82088: LD_VAR 0 3
82092: RET
// export function HealTarget ( sci ) ; begin
82093: LD_INT 0
82095: PPUSH
// if not sci then
82096: LD_VAR 0 1
82100: NOT
82101: IFFALSE 82105
// exit ;
82103: GO 82170
// result := 0 ;
82105: LD_ADDR_VAR 0 2
82109: PUSH
82110: LD_INT 0
82112: ST_TO_ADDR
// if GetTaskList ( sci ) then
82113: LD_VAR 0 1
82117: PPUSH
82118: CALL_OW 437
82122: IFFALSE 82170
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82124: LD_VAR 0 1
82128: PPUSH
82129: CALL_OW 437
82133: PUSH
82134: LD_INT 1
82136: ARRAY
82137: PUSH
82138: LD_INT 1
82140: ARRAY
82141: PUSH
82142: LD_STRING l
82144: EQUAL
82145: IFFALSE 82170
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
82147: LD_ADDR_VAR 0 2
82151: PUSH
82152: LD_VAR 0 1
82156: PPUSH
82157: CALL_OW 437
82161: PUSH
82162: LD_INT 1
82164: ARRAY
82165: PUSH
82166: LD_INT 4
82168: ARRAY
82169: ST_TO_ADDR
// end ;
82170: LD_VAR 0 2
82174: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
82175: LD_INT 0
82177: PPUSH
82178: PPUSH
82179: PPUSH
82180: PPUSH
82181: PPUSH
82182: PPUSH
82183: PPUSH
82184: PPUSH
82185: PPUSH
82186: PPUSH
82187: PPUSH
82188: PPUSH
82189: PPUSH
82190: PPUSH
82191: PPUSH
82192: PPUSH
82193: PPUSH
82194: PPUSH
82195: PPUSH
82196: PPUSH
82197: PPUSH
82198: PPUSH
82199: PPUSH
82200: PPUSH
82201: PPUSH
82202: PPUSH
82203: PPUSH
82204: PPUSH
82205: PPUSH
82206: PPUSH
82207: PPUSH
82208: PPUSH
82209: PPUSH
82210: PPUSH
// if not list then
82211: LD_VAR 0 1
82215: NOT
82216: IFFALSE 82220
// exit ;
82218: GO 86846
// base := list [ 1 ] ;
82220: LD_ADDR_VAR 0 3
82224: PUSH
82225: LD_VAR 0 1
82229: PUSH
82230: LD_INT 1
82232: ARRAY
82233: ST_TO_ADDR
// group := list [ 2 ] ;
82234: LD_ADDR_VAR 0 4
82238: PUSH
82239: LD_VAR 0 1
82243: PUSH
82244: LD_INT 2
82246: ARRAY
82247: ST_TO_ADDR
// path := list [ 3 ] ;
82248: LD_ADDR_VAR 0 5
82252: PUSH
82253: LD_VAR 0 1
82257: PUSH
82258: LD_INT 3
82260: ARRAY
82261: ST_TO_ADDR
// flags := list [ 4 ] ;
82262: LD_ADDR_VAR 0 6
82266: PUSH
82267: LD_VAR 0 1
82271: PUSH
82272: LD_INT 4
82274: ARRAY
82275: ST_TO_ADDR
// mined := [ ] ;
82276: LD_ADDR_VAR 0 27
82280: PUSH
82281: EMPTY
82282: ST_TO_ADDR
// bombed := [ ] ;
82283: LD_ADDR_VAR 0 28
82287: PUSH
82288: EMPTY
82289: ST_TO_ADDR
// healers := [ ] ;
82290: LD_ADDR_VAR 0 31
82294: PUSH
82295: EMPTY
82296: ST_TO_ADDR
// to_heal := [ ] ;
82297: LD_ADDR_VAR 0 30
82301: PUSH
82302: EMPTY
82303: ST_TO_ADDR
// repairs := [ ] ;
82304: LD_ADDR_VAR 0 33
82308: PUSH
82309: EMPTY
82310: ST_TO_ADDR
// to_repair := [ ] ;
82311: LD_ADDR_VAR 0 32
82315: PUSH
82316: EMPTY
82317: ST_TO_ADDR
// if not group or not path then
82318: LD_VAR 0 4
82322: NOT
82323: PUSH
82324: LD_VAR 0 5
82328: NOT
82329: OR
82330: IFFALSE 82334
// exit ;
82332: GO 86846
// side := GetSide ( group [ 1 ] ) ;
82334: LD_ADDR_VAR 0 35
82338: PUSH
82339: LD_VAR 0 4
82343: PUSH
82344: LD_INT 1
82346: ARRAY
82347: PPUSH
82348: CALL_OW 255
82352: ST_TO_ADDR
// if flags then
82353: LD_VAR 0 6
82357: IFFALSE 82501
// begin f_ignore_area := flags [ 1 ] ;
82359: LD_ADDR_VAR 0 17
82363: PUSH
82364: LD_VAR 0 6
82368: PUSH
82369: LD_INT 1
82371: ARRAY
82372: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
82373: LD_ADDR_VAR 0 18
82377: PUSH
82378: LD_VAR 0 6
82382: PUSH
82383: LD_INT 2
82385: ARRAY
82386: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
82387: LD_ADDR_VAR 0 19
82391: PUSH
82392: LD_VAR 0 6
82396: PUSH
82397: LD_INT 3
82399: ARRAY
82400: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
82401: LD_ADDR_VAR 0 20
82405: PUSH
82406: LD_VAR 0 6
82410: PUSH
82411: LD_INT 4
82413: ARRAY
82414: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
82415: LD_ADDR_VAR 0 21
82419: PUSH
82420: LD_VAR 0 6
82424: PUSH
82425: LD_INT 5
82427: ARRAY
82428: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
82429: LD_ADDR_VAR 0 22
82433: PUSH
82434: LD_VAR 0 6
82438: PUSH
82439: LD_INT 6
82441: ARRAY
82442: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
82443: LD_ADDR_VAR 0 23
82447: PUSH
82448: LD_VAR 0 6
82452: PUSH
82453: LD_INT 7
82455: ARRAY
82456: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
82457: LD_ADDR_VAR 0 24
82461: PUSH
82462: LD_VAR 0 6
82466: PUSH
82467: LD_INT 8
82469: ARRAY
82470: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
82471: LD_ADDR_VAR 0 25
82475: PUSH
82476: LD_VAR 0 6
82480: PUSH
82481: LD_INT 9
82483: ARRAY
82484: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
82485: LD_ADDR_VAR 0 26
82489: PUSH
82490: LD_VAR 0 6
82494: PUSH
82495: LD_INT 10
82497: ARRAY
82498: ST_TO_ADDR
// end else
82499: GO 82581
// begin f_ignore_area := false ;
82501: LD_ADDR_VAR 0 17
82505: PUSH
82506: LD_INT 0
82508: ST_TO_ADDR
// f_capture := false ;
82509: LD_ADDR_VAR 0 18
82513: PUSH
82514: LD_INT 0
82516: ST_TO_ADDR
// f_ignore_civ := false ;
82517: LD_ADDR_VAR 0 19
82521: PUSH
82522: LD_INT 0
82524: ST_TO_ADDR
// f_murder := false ;
82525: LD_ADDR_VAR 0 20
82529: PUSH
82530: LD_INT 0
82532: ST_TO_ADDR
// f_mines := false ;
82533: LD_ADDR_VAR 0 21
82537: PUSH
82538: LD_INT 0
82540: ST_TO_ADDR
// f_repair := false ;
82541: LD_ADDR_VAR 0 22
82545: PUSH
82546: LD_INT 0
82548: ST_TO_ADDR
// f_heal := false ;
82549: LD_ADDR_VAR 0 23
82553: PUSH
82554: LD_INT 0
82556: ST_TO_ADDR
// f_spacetime := false ;
82557: LD_ADDR_VAR 0 24
82561: PUSH
82562: LD_INT 0
82564: ST_TO_ADDR
// f_attack_depot := false ;
82565: LD_ADDR_VAR 0 25
82569: PUSH
82570: LD_INT 0
82572: ST_TO_ADDR
// f_crawl := false ;
82573: LD_ADDR_VAR 0 26
82577: PUSH
82578: LD_INT 0
82580: ST_TO_ADDR
// end ; if f_heal then
82581: LD_VAR 0 23
82585: IFFALSE 82612
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
82587: LD_ADDR_VAR 0 31
82591: PUSH
82592: LD_VAR 0 4
82596: PPUSH
82597: LD_INT 25
82599: PUSH
82600: LD_INT 4
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PPUSH
82607: CALL_OW 72
82611: ST_TO_ADDR
// if f_repair then
82612: LD_VAR 0 22
82616: IFFALSE 82643
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
82618: LD_ADDR_VAR 0 33
82622: PUSH
82623: LD_VAR 0 4
82627: PPUSH
82628: LD_INT 25
82630: PUSH
82631: LD_INT 3
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PPUSH
82638: CALL_OW 72
82642: ST_TO_ADDR
// units_path := [ ] ;
82643: LD_ADDR_VAR 0 16
82647: PUSH
82648: EMPTY
82649: ST_TO_ADDR
// for i = 1 to group do
82650: LD_ADDR_VAR 0 7
82654: PUSH
82655: DOUBLE
82656: LD_INT 1
82658: DEC
82659: ST_TO_ADDR
82660: LD_VAR 0 4
82664: PUSH
82665: FOR_TO
82666: IFFALSE 82695
// units_path := Replace ( units_path , i , path ) ;
82668: LD_ADDR_VAR 0 16
82672: PUSH
82673: LD_VAR 0 16
82677: PPUSH
82678: LD_VAR 0 7
82682: PPUSH
82683: LD_VAR 0 5
82687: PPUSH
82688: CALL_OW 1
82692: ST_TO_ADDR
82693: GO 82665
82695: POP
82696: POP
// repeat for i = group downto 1 do
82697: LD_ADDR_VAR 0 7
82701: PUSH
82702: DOUBLE
82703: LD_VAR 0 4
82707: INC
82708: ST_TO_ADDR
82709: LD_INT 1
82711: PUSH
82712: FOR_DOWNTO
82713: IFFALSE 86809
// begin wait ( 5 ) ;
82715: LD_INT 5
82717: PPUSH
82718: CALL_OW 67
// tmp := [ ] ;
82722: LD_ADDR_VAR 0 14
82726: PUSH
82727: EMPTY
82728: ST_TO_ADDR
// attacking := false ;
82729: LD_ADDR_VAR 0 29
82733: PUSH
82734: LD_INT 0
82736: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
82737: LD_VAR 0 4
82741: PUSH
82742: LD_VAR 0 7
82746: ARRAY
82747: PPUSH
82748: CALL_OW 301
82752: PUSH
82753: LD_VAR 0 4
82757: PUSH
82758: LD_VAR 0 7
82762: ARRAY
82763: NOT
82764: OR
82765: IFFALSE 82874
// begin if GetType ( group [ i ] ) = unit_human then
82767: LD_VAR 0 4
82771: PUSH
82772: LD_VAR 0 7
82776: ARRAY
82777: PPUSH
82778: CALL_OW 247
82782: PUSH
82783: LD_INT 1
82785: EQUAL
82786: IFFALSE 82832
// begin to_heal := to_heal diff group [ i ] ;
82788: LD_ADDR_VAR 0 30
82792: PUSH
82793: LD_VAR 0 30
82797: PUSH
82798: LD_VAR 0 4
82802: PUSH
82803: LD_VAR 0 7
82807: ARRAY
82808: DIFF
82809: ST_TO_ADDR
// healers := healers diff group [ i ] ;
82810: LD_ADDR_VAR 0 31
82814: PUSH
82815: LD_VAR 0 31
82819: PUSH
82820: LD_VAR 0 4
82824: PUSH
82825: LD_VAR 0 7
82829: ARRAY
82830: DIFF
82831: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
82832: LD_ADDR_VAR 0 4
82836: PUSH
82837: LD_VAR 0 4
82841: PPUSH
82842: LD_VAR 0 7
82846: PPUSH
82847: CALL_OW 3
82851: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
82852: LD_ADDR_VAR 0 16
82856: PUSH
82857: LD_VAR 0 16
82861: PPUSH
82862: LD_VAR 0 7
82866: PPUSH
82867: CALL_OW 3
82871: ST_TO_ADDR
// continue ;
82872: GO 82712
// end ; if f_repair then
82874: LD_VAR 0 22
82878: IFFALSE 83367
// begin if GetType ( group [ i ] ) = unit_vehicle then
82880: LD_VAR 0 4
82884: PUSH
82885: LD_VAR 0 7
82889: ARRAY
82890: PPUSH
82891: CALL_OW 247
82895: PUSH
82896: LD_INT 2
82898: EQUAL
82899: IFFALSE 83089
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
82901: LD_VAR 0 4
82905: PUSH
82906: LD_VAR 0 7
82910: ARRAY
82911: PPUSH
82912: CALL_OW 256
82916: PUSH
82917: LD_INT 700
82919: LESS
82920: PUSH
82921: LD_VAR 0 4
82925: PUSH
82926: LD_VAR 0 7
82930: ARRAY
82931: PUSH
82932: LD_VAR 0 32
82936: IN
82937: NOT
82938: AND
82939: IFFALSE 82963
// to_repair := to_repair union group [ i ] ;
82941: LD_ADDR_VAR 0 32
82945: PUSH
82946: LD_VAR 0 32
82950: PUSH
82951: LD_VAR 0 4
82955: PUSH
82956: LD_VAR 0 7
82960: ARRAY
82961: UNION
82962: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
82963: LD_VAR 0 4
82967: PUSH
82968: LD_VAR 0 7
82972: ARRAY
82973: PPUSH
82974: CALL_OW 256
82978: PUSH
82979: LD_INT 1000
82981: EQUAL
82982: PUSH
82983: LD_VAR 0 4
82987: PUSH
82988: LD_VAR 0 7
82992: ARRAY
82993: PUSH
82994: LD_VAR 0 32
82998: IN
82999: AND
83000: IFFALSE 83024
// to_repair := to_repair diff group [ i ] ;
83002: LD_ADDR_VAR 0 32
83006: PUSH
83007: LD_VAR 0 32
83011: PUSH
83012: LD_VAR 0 4
83016: PUSH
83017: LD_VAR 0 7
83021: ARRAY
83022: DIFF
83023: ST_TO_ADDR
// if group [ i ] in to_repair then
83024: LD_VAR 0 4
83028: PUSH
83029: LD_VAR 0 7
83033: ARRAY
83034: PUSH
83035: LD_VAR 0 32
83039: IN
83040: IFFALSE 83087
// begin if not IsInArea ( group [ i ] , f_repair ) then
83042: LD_VAR 0 4
83046: PUSH
83047: LD_VAR 0 7
83051: ARRAY
83052: PPUSH
83053: LD_VAR 0 22
83057: PPUSH
83058: CALL_OW 308
83062: NOT
83063: IFFALSE 83085
// ComMoveToArea ( group [ i ] , f_repair ) ;
83065: LD_VAR 0 4
83069: PUSH
83070: LD_VAR 0 7
83074: ARRAY
83075: PPUSH
83076: LD_VAR 0 22
83080: PPUSH
83081: CALL_OW 113
// continue ;
83085: GO 82712
// end ; end else
83087: GO 83367
// if group [ i ] in repairs then
83089: LD_VAR 0 4
83093: PUSH
83094: LD_VAR 0 7
83098: ARRAY
83099: PUSH
83100: LD_VAR 0 33
83104: IN
83105: IFFALSE 83367
// begin if IsInUnit ( group [ i ] ) then
83107: LD_VAR 0 4
83111: PUSH
83112: LD_VAR 0 7
83116: ARRAY
83117: PPUSH
83118: CALL_OW 310
83122: IFFALSE 83190
// begin z := IsInUnit ( group [ i ] ) ;
83124: LD_ADDR_VAR 0 13
83128: PUSH
83129: LD_VAR 0 4
83133: PUSH
83134: LD_VAR 0 7
83138: ARRAY
83139: PPUSH
83140: CALL_OW 310
83144: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
83145: LD_VAR 0 13
83149: PUSH
83150: LD_VAR 0 32
83154: IN
83155: PUSH
83156: LD_VAR 0 13
83160: PPUSH
83161: LD_VAR 0 22
83165: PPUSH
83166: CALL_OW 308
83170: AND
83171: IFFALSE 83188
// ComExitVehicle ( group [ i ] ) ;
83173: LD_VAR 0 4
83177: PUSH
83178: LD_VAR 0 7
83182: ARRAY
83183: PPUSH
83184: CALL_OW 121
// end else
83188: GO 83367
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
83190: LD_ADDR_VAR 0 13
83194: PUSH
83195: LD_VAR 0 4
83199: PPUSH
83200: LD_INT 95
83202: PUSH
83203: LD_VAR 0 22
83207: PUSH
83208: EMPTY
83209: LIST
83210: LIST
83211: PUSH
83212: LD_INT 58
83214: PUSH
83215: EMPTY
83216: LIST
83217: PUSH
83218: EMPTY
83219: LIST
83220: LIST
83221: PPUSH
83222: CALL_OW 72
83226: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
83227: LD_VAR 0 4
83231: PUSH
83232: LD_VAR 0 7
83236: ARRAY
83237: PPUSH
83238: CALL_OW 314
83242: NOT
83243: IFFALSE 83365
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
83245: LD_ADDR_VAR 0 10
83249: PUSH
83250: LD_VAR 0 13
83254: PPUSH
83255: LD_VAR 0 4
83259: PUSH
83260: LD_VAR 0 7
83264: ARRAY
83265: PPUSH
83266: CALL_OW 74
83270: ST_TO_ADDR
// if not x then
83271: LD_VAR 0 10
83275: NOT
83276: IFFALSE 83280
// continue ;
83278: GO 82712
// if GetLives ( x ) < 1000 then
83280: LD_VAR 0 10
83284: PPUSH
83285: CALL_OW 256
83289: PUSH
83290: LD_INT 1000
83292: LESS
83293: IFFALSE 83317
// ComRepairVehicle ( group [ i ] , x ) else
83295: LD_VAR 0 4
83299: PUSH
83300: LD_VAR 0 7
83304: ARRAY
83305: PPUSH
83306: LD_VAR 0 10
83310: PPUSH
83311: CALL_OW 129
83315: GO 83365
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
83317: LD_VAR 0 23
83321: PUSH
83322: LD_VAR 0 4
83326: PUSH
83327: LD_VAR 0 7
83331: ARRAY
83332: PPUSH
83333: CALL_OW 256
83337: PUSH
83338: LD_INT 1000
83340: LESS
83341: AND
83342: NOT
83343: IFFALSE 83365
// ComEnterUnit ( group [ i ] , x ) ;
83345: LD_VAR 0 4
83349: PUSH
83350: LD_VAR 0 7
83354: ARRAY
83355: PPUSH
83356: LD_VAR 0 10
83360: PPUSH
83361: CALL_OW 120
// end ; continue ;
83365: GO 82712
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
83367: LD_VAR 0 23
83371: PUSH
83372: LD_VAR 0 4
83376: PUSH
83377: LD_VAR 0 7
83381: ARRAY
83382: PPUSH
83383: CALL_OW 247
83387: PUSH
83388: LD_INT 1
83390: EQUAL
83391: AND
83392: IFFALSE 83870
// begin if group [ i ] in healers then
83394: LD_VAR 0 4
83398: PUSH
83399: LD_VAR 0 7
83403: ARRAY
83404: PUSH
83405: LD_VAR 0 31
83409: IN
83410: IFFALSE 83683
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
83412: LD_VAR 0 4
83416: PUSH
83417: LD_VAR 0 7
83421: ARRAY
83422: PPUSH
83423: LD_VAR 0 23
83427: PPUSH
83428: CALL_OW 308
83432: NOT
83433: PUSH
83434: LD_VAR 0 4
83438: PUSH
83439: LD_VAR 0 7
83443: ARRAY
83444: PPUSH
83445: CALL_OW 314
83449: NOT
83450: AND
83451: IFFALSE 83475
// ComMoveToArea ( group [ i ] , f_heal ) else
83453: LD_VAR 0 4
83457: PUSH
83458: LD_VAR 0 7
83462: ARRAY
83463: PPUSH
83464: LD_VAR 0 23
83468: PPUSH
83469: CALL_OW 113
83473: GO 83681
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
83475: LD_VAR 0 4
83479: PUSH
83480: LD_VAR 0 7
83484: ARRAY
83485: PPUSH
83486: CALL 82093 0 1
83490: PPUSH
83491: CALL_OW 256
83495: PUSH
83496: LD_INT 1000
83498: EQUAL
83499: IFFALSE 83518
// ComStop ( group [ i ] ) else
83501: LD_VAR 0 4
83505: PUSH
83506: LD_VAR 0 7
83510: ARRAY
83511: PPUSH
83512: CALL_OW 141
83516: GO 83681
// if not HasTask ( group [ i ] ) and to_heal then
83518: LD_VAR 0 4
83522: PUSH
83523: LD_VAR 0 7
83527: ARRAY
83528: PPUSH
83529: CALL_OW 314
83533: NOT
83534: PUSH
83535: LD_VAR 0 30
83539: AND
83540: IFFALSE 83681
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
83542: LD_ADDR_VAR 0 13
83546: PUSH
83547: LD_VAR 0 30
83551: PPUSH
83552: LD_INT 3
83554: PUSH
83555: LD_INT 54
83557: PUSH
83558: EMPTY
83559: LIST
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: PPUSH
83565: CALL_OW 72
83569: PPUSH
83570: LD_VAR 0 4
83574: PUSH
83575: LD_VAR 0 7
83579: ARRAY
83580: PPUSH
83581: CALL_OW 74
83585: ST_TO_ADDR
// if z then
83586: LD_VAR 0 13
83590: IFFALSE 83681
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
83592: LD_INT 91
83594: PUSH
83595: LD_VAR 0 13
83599: PUSH
83600: LD_INT 10
83602: PUSH
83603: EMPTY
83604: LIST
83605: LIST
83606: LIST
83607: PUSH
83608: LD_INT 81
83610: PUSH
83611: LD_VAR 0 13
83615: PPUSH
83616: CALL_OW 255
83620: PUSH
83621: EMPTY
83622: LIST
83623: LIST
83624: PUSH
83625: EMPTY
83626: LIST
83627: LIST
83628: PPUSH
83629: CALL_OW 69
83633: PUSH
83634: LD_INT 0
83636: EQUAL
83637: IFFALSE 83661
// ComHeal ( group [ i ] , z ) else
83639: LD_VAR 0 4
83643: PUSH
83644: LD_VAR 0 7
83648: ARRAY
83649: PPUSH
83650: LD_VAR 0 13
83654: PPUSH
83655: CALL_OW 128
83659: GO 83681
// ComMoveToArea ( group [ i ] , f_heal ) ;
83661: LD_VAR 0 4
83665: PUSH
83666: LD_VAR 0 7
83670: ARRAY
83671: PPUSH
83672: LD_VAR 0 23
83676: PPUSH
83677: CALL_OW 113
// end ; continue ;
83681: GO 82712
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
83683: LD_VAR 0 4
83687: PUSH
83688: LD_VAR 0 7
83692: ARRAY
83693: PPUSH
83694: CALL_OW 256
83698: PUSH
83699: LD_INT 700
83701: LESS
83702: PUSH
83703: LD_VAR 0 4
83707: PUSH
83708: LD_VAR 0 7
83712: ARRAY
83713: PUSH
83714: LD_VAR 0 30
83718: IN
83719: NOT
83720: AND
83721: IFFALSE 83745
// to_heal := to_heal union group [ i ] ;
83723: LD_ADDR_VAR 0 30
83727: PUSH
83728: LD_VAR 0 30
83732: PUSH
83733: LD_VAR 0 4
83737: PUSH
83738: LD_VAR 0 7
83742: ARRAY
83743: UNION
83744: ST_TO_ADDR
// if group [ i ] in to_heal then
83745: LD_VAR 0 4
83749: PUSH
83750: LD_VAR 0 7
83754: ARRAY
83755: PUSH
83756: LD_VAR 0 30
83760: IN
83761: IFFALSE 83870
// begin if GetLives ( group [ i ] ) = 1000 then
83763: LD_VAR 0 4
83767: PUSH
83768: LD_VAR 0 7
83772: ARRAY
83773: PPUSH
83774: CALL_OW 256
83778: PUSH
83779: LD_INT 1000
83781: EQUAL
83782: IFFALSE 83808
// to_heal := to_heal diff group [ i ] else
83784: LD_ADDR_VAR 0 30
83788: PUSH
83789: LD_VAR 0 30
83793: PUSH
83794: LD_VAR 0 4
83798: PUSH
83799: LD_VAR 0 7
83803: ARRAY
83804: DIFF
83805: ST_TO_ADDR
83806: GO 83870
// begin if not IsInArea ( group [ i ] , to_heal ) then
83808: LD_VAR 0 4
83812: PUSH
83813: LD_VAR 0 7
83817: ARRAY
83818: PPUSH
83819: LD_VAR 0 30
83823: PPUSH
83824: CALL_OW 308
83828: NOT
83829: IFFALSE 83853
// ComMoveToArea ( group [ i ] , f_heal ) else
83831: LD_VAR 0 4
83835: PUSH
83836: LD_VAR 0 7
83840: ARRAY
83841: PPUSH
83842: LD_VAR 0 23
83846: PPUSH
83847: CALL_OW 113
83851: GO 83868
// ComHold ( group [ i ] ) ;
83853: LD_VAR 0 4
83857: PUSH
83858: LD_VAR 0 7
83862: ARRAY
83863: PPUSH
83864: CALL_OW 140
// continue ;
83868: GO 82712
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
83870: LD_VAR 0 4
83874: PUSH
83875: LD_VAR 0 7
83879: ARRAY
83880: PPUSH
83881: LD_INT 10
83883: PPUSH
83884: CALL 80490 0 2
83888: NOT
83889: PUSH
83890: LD_VAR 0 16
83894: PUSH
83895: LD_VAR 0 7
83899: ARRAY
83900: PUSH
83901: EMPTY
83902: EQUAL
83903: NOT
83904: AND
83905: IFFALSE 84171
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
83907: LD_VAR 0 4
83911: PUSH
83912: LD_VAR 0 7
83916: ARRAY
83917: PPUSH
83918: CALL_OW 262
83922: PUSH
83923: LD_INT 1
83925: PUSH
83926: LD_INT 2
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: IN
83933: IFFALSE 83974
// if GetFuel ( group [ i ] ) < 10 then
83935: LD_VAR 0 4
83939: PUSH
83940: LD_VAR 0 7
83944: ARRAY
83945: PPUSH
83946: CALL_OW 261
83950: PUSH
83951: LD_INT 10
83953: LESS
83954: IFFALSE 83974
// SetFuel ( group [ i ] , 12 ) ;
83956: LD_VAR 0 4
83960: PUSH
83961: LD_VAR 0 7
83965: ARRAY
83966: PPUSH
83967: LD_INT 12
83969: PPUSH
83970: CALL_OW 240
// if units_path [ i ] then
83974: LD_VAR 0 16
83978: PUSH
83979: LD_VAR 0 7
83983: ARRAY
83984: IFFALSE 84169
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
83986: LD_VAR 0 4
83990: PUSH
83991: LD_VAR 0 7
83995: ARRAY
83996: PPUSH
83997: LD_VAR 0 16
84001: PUSH
84002: LD_VAR 0 7
84006: ARRAY
84007: PUSH
84008: LD_INT 1
84010: ARRAY
84011: PUSH
84012: LD_INT 1
84014: ARRAY
84015: PPUSH
84016: LD_VAR 0 16
84020: PUSH
84021: LD_VAR 0 7
84025: ARRAY
84026: PUSH
84027: LD_INT 1
84029: ARRAY
84030: PUSH
84031: LD_INT 2
84033: ARRAY
84034: PPUSH
84035: CALL_OW 297
84039: PUSH
84040: LD_INT 6
84042: GREATER
84043: IFFALSE 84118
// begin if not HasTask ( group [ i ] ) then
84045: LD_VAR 0 4
84049: PUSH
84050: LD_VAR 0 7
84054: ARRAY
84055: PPUSH
84056: CALL_OW 314
84060: NOT
84061: IFFALSE 84116
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84063: LD_VAR 0 4
84067: PUSH
84068: LD_VAR 0 7
84072: ARRAY
84073: PPUSH
84074: LD_VAR 0 16
84078: PUSH
84079: LD_VAR 0 7
84083: ARRAY
84084: PUSH
84085: LD_INT 1
84087: ARRAY
84088: PUSH
84089: LD_INT 1
84091: ARRAY
84092: PPUSH
84093: LD_VAR 0 16
84097: PUSH
84098: LD_VAR 0 7
84102: ARRAY
84103: PUSH
84104: LD_INT 1
84106: ARRAY
84107: PUSH
84108: LD_INT 2
84110: ARRAY
84111: PPUSH
84112: CALL_OW 114
// end else
84116: GO 84169
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84118: LD_ADDR_VAR 0 15
84122: PUSH
84123: LD_VAR 0 16
84127: PUSH
84128: LD_VAR 0 7
84132: ARRAY
84133: PPUSH
84134: LD_INT 1
84136: PPUSH
84137: CALL_OW 3
84141: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
84142: LD_ADDR_VAR 0 16
84146: PUSH
84147: LD_VAR 0 16
84151: PPUSH
84152: LD_VAR 0 7
84156: PPUSH
84157: LD_VAR 0 15
84161: PPUSH
84162: CALL_OW 1
84166: ST_TO_ADDR
// continue ;
84167: GO 82712
// end ; end ; end else
84169: GO 86807
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
84171: LD_ADDR_VAR 0 14
84175: PUSH
84176: LD_INT 81
84178: PUSH
84179: LD_VAR 0 4
84183: PUSH
84184: LD_VAR 0 7
84188: ARRAY
84189: PPUSH
84190: CALL_OW 255
84194: PUSH
84195: EMPTY
84196: LIST
84197: LIST
84198: PPUSH
84199: CALL_OW 69
84203: ST_TO_ADDR
// if not tmp then
84204: LD_VAR 0 14
84208: NOT
84209: IFFALSE 84213
// continue ;
84211: GO 82712
// if f_ignore_area then
84213: LD_VAR 0 17
84217: IFFALSE 84305
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
84219: LD_ADDR_VAR 0 15
84223: PUSH
84224: LD_VAR 0 14
84228: PPUSH
84229: LD_INT 3
84231: PUSH
84232: LD_INT 92
84234: PUSH
84235: LD_VAR 0 17
84239: PUSH
84240: LD_INT 1
84242: ARRAY
84243: PUSH
84244: LD_VAR 0 17
84248: PUSH
84249: LD_INT 2
84251: ARRAY
84252: PUSH
84253: LD_VAR 0 17
84257: PUSH
84258: LD_INT 3
84260: ARRAY
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: LIST
84266: LIST
84267: PUSH
84268: EMPTY
84269: LIST
84270: LIST
84271: PPUSH
84272: CALL_OW 72
84276: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84277: LD_VAR 0 14
84281: PUSH
84282: LD_VAR 0 15
84286: DIFF
84287: IFFALSE 84305
// tmp := tmp diff tmp2 ;
84289: LD_ADDR_VAR 0 14
84293: PUSH
84294: LD_VAR 0 14
84298: PUSH
84299: LD_VAR 0 15
84303: DIFF
84304: ST_TO_ADDR
// end ; if not f_murder then
84305: LD_VAR 0 20
84309: NOT
84310: IFFALSE 84368
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
84312: LD_ADDR_VAR 0 15
84316: PUSH
84317: LD_VAR 0 14
84321: PPUSH
84322: LD_INT 3
84324: PUSH
84325: LD_INT 50
84327: PUSH
84328: EMPTY
84329: LIST
84330: PUSH
84331: EMPTY
84332: LIST
84333: LIST
84334: PPUSH
84335: CALL_OW 72
84339: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84340: LD_VAR 0 14
84344: PUSH
84345: LD_VAR 0 15
84349: DIFF
84350: IFFALSE 84368
// tmp := tmp diff tmp2 ;
84352: LD_ADDR_VAR 0 14
84356: PUSH
84357: LD_VAR 0 14
84361: PUSH
84362: LD_VAR 0 15
84366: DIFF
84367: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
84368: LD_ADDR_VAR 0 14
84372: PUSH
84373: LD_VAR 0 4
84377: PUSH
84378: LD_VAR 0 7
84382: ARRAY
84383: PPUSH
84384: LD_VAR 0 14
84388: PPUSH
84389: LD_INT 1
84391: PPUSH
84392: LD_INT 1
84394: PPUSH
84395: CALL 54133 0 4
84399: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
84400: LD_VAR 0 4
84404: PUSH
84405: LD_VAR 0 7
84409: ARRAY
84410: PPUSH
84411: CALL_OW 257
84415: PUSH
84416: LD_INT 1
84418: EQUAL
84419: IFFALSE 84867
// begin if WantPlant ( group [ i ] ) then
84421: LD_VAR 0 4
84425: PUSH
84426: LD_VAR 0 7
84430: ARRAY
84431: PPUSH
84432: CALL 53634 0 1
84436: IFFALSE 84440
// continue ;
84438: GO 82712
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
84440: LD_VAR 0 18
84444: PUSH
84445: LD_VAR 0 4
84449: PUSH
84450: LD_VAR 0 7
84454: ARRAY
84455: PPUSH
84456: CALL_OW 310
84460: NOT
84461: AND
84462: PUSH
84463: LD_VAR 0 14
84467: PUSH
84468: LD_INT 1
84470: ARRAY
84471: PUSH
84472: LD_VAR 0 14
84476: PPUSH
84477: LD_INT 21
84479: PUSH
84480: LD_INT 2
84482: PUSH
84483: EMPTY
84484: LIST
84485: LIST
84486: PUSH
84487: LD_INT 58
84489: PUSH
84490: EMPTY
84491: LIST
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: PPUSH
84497: CALL_OW 72
84501: IN
84502: AND
84503: IFFALSE 84539
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
84505: LD_VAR 0 4
84509: PUSH
84510: LD_VAR 0 7
84514: ARRAY
84515: PPUSH
84516: LD_VAR 0 14
84520: PUSH
84521: LD_INT 1
84523: ARRAY
84524: PPUSH
84525: CALL_OW 120
// attacking := true ;
84529: LD_ADDR_VAR 0 29
84533: PUSH
84534: LD_INT 1
84536: ST_TO_ADDR
// continue ;
84537: GO 82712
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
84539: LD_VAR 0 26
84543: PUSH
84544: LD_VAR 0 4
84548: PUSH
84549: LD_VAR 0 7
84553: ARRAY
84554: PPUSH
84555: CALL_OW 257
84559: PUSH
84560: LD_INT 1
84562: EQUAL
84563: AND
84564: PUSH
84565: LD_VAR 0 4
84569: PUSH
84570: LD_VAR 0 7
84574: ARRAY
84575: PPUSH
84576: CALL_OW 256
84580: PUSH
84581: LD_INT 800
84583: LESS
84584: AND
84585: PUSH
84586: LD_VAR 0 4
84590: PUSH
84591: LD_VAR 0 7
84595: ARRAY
84596: PPUSH
84597: CALL_OW 318
84601: NOT
84602: AND
84603: IFFALSE 84620
// ComCrawl ( group [ i ] ) ;
84605: LD_VAR 0 4
84609: PUSH
84610: LD_VAR 0 7
84614: ARRAY
84615: PPUSH
84616: CALL_OW 137
// if f_mines then
84620: LD_VAR 0 21
84624: IFFALSE 84867
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
84626: LD_VAR 0 14
84630: PUSH
84631: LD_INT 1
84633: ARRAY
84634: PPUSH
84635: CALL_OW 247
84639: PUSH
84640: LD_INT 3
84642: EQUAL
84643: PUSH
84644: LD_VAR 0 14
84648: PUSH
84649: LD_INT 1
84651: ARRAY
84652: PUSH
84653: LD_VAR 0 27
84657: IN
84658: NOT
84659: AND
84660: IFFALSE 84867
// begin x := GetX ( tmp [ 1 ] ) ;
84662: LD_ADDR_VAR 0 10
84666: PUSH
84667: LD_VAR 0 14
84671: PUSH
84672: LD_INT 1
84674: ARRAY
84675: PPUSH
84676: CALL_OW 250
84680: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
84681: LD_ADDR_VAR 0 11
84685: PUSH
84686: LD_VAR 0 14
84690: PUSH
84691: LD_INT 1
84693: ARRAY
84694: PPUSH
84695: CALL_OW 251
84699: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
84700: LD_ADDR_VAR 0 12
84704: PUSH
84705: LD_VAR 0 4
84709: PUSH
84710: LD_VAR 0 7
84714: ARRAY
84715: PPUSH
84716: CALL 80575 0 1
84720: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
84721: LD_VAR 0 4
84725: PUSH
84726: LD_VAR 0 7
84730: ARRAY
84731: PPUSH
84732: LD_VAR 0 10
84736: PPUSH
84737: LD_VAR 0 11
84741: PPUSH
84742: LD_VAR 0 14
84746: PUSH
84747: LD_INT 1
84749: ARRAY
84750: PPUSH
84751: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
84755: LD_VAR 0 4
84759: PUSH
84760: LD_VAR 0 7
84764: ARRAY
84765: PPUSH
84766: LD_VAR 0 10
84770: PPUSH
84771: LD_VAR 0 12
84775: PPUSH
84776: LD_INT 7
84778: PPUSH
84779: CALL_OW 272
84783: PPUSH
84784: LD_VAR 0 11
84788: PPUSH
84789: LD_VAR 0 12
84793: PPUSH
84794: LD_INT 7
84796: PPUSH
84797: CALL_OW 273
84801: PPUSH
84802: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
84806: LD_VAR 0 4
84810: PUSH
84811: LD_VAR 0 7
84815: ARRAY
84816: PPUSH
84817: LD_INT 71
84819: PPUSH
84820: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
84824: LD_ADDR_VAR 0 27
84828: PUSH
84829: LD_VAR 0 27
84833: PPUSH
84834: LD_VAR 0 27
84838: PUSH
84839: LD_INT 1
84841: PLUS
84842: PPUSH
84843: LD_VAR 0 14
84847: PUSH
84848: LD_INT 1
84850: ARRAY
84851: PPUSH
84852: CALL_OW 1
84856: ST_TO_ADDR
// attacking := true ;
84857: LD_ADDR_VAR 0 29
84861: PUSH
84862: LD_INT 1
84864: ST_TO_ADDR
// continue ;
84865: GO 82712
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
84867: LD_VAR 0 4
84871: PUSH
84872: LD_VAR 0 7
84876: ARRAY
84877: PPUSH
84878: CALL_OW 257
84882: PUSH
84883: LD_INT 17
84885: EQUAL
84886: PUSH
84887: LD_VAR 0 4
84891: PUSH
84892: LD_VAR 0 7
84896: ARRAY
84897: PPUSH
84898: CALL_OW 110
84902: PUSH
84903: LD_INT 71
84905: EQUAL
84906: NOT
84907: AND
84908: IFFALSE 85054
// begin attacking := false ;
84910: LD_ADDR_VAR 0 29
84914: PUSH
84915: LD_INT 0
84917: ST_TO_ADDR
// k := 5 ;
84918: LD_ADDR_VAR 0 9
84922: PUSH
84923: LD_INT 5
84925: ST_TO_ADDR
// if tmp < k then
84926: LD_VAR 0 14
84930: PUSH
84931: LD_VAR 0 9
84935: LESS
84936: IFFALSE 84948
// k := tmp ;
84938: LD_ADDR_VAR 0 9
84942: PUSH
84943: LD_VAR 0 14
84947: ST_TO_ADDR
// for j = 1 to k do
84948: LD_ADDR_VAR 0 8
84952: PUSH
84953: DOUBLE
84954: LD_INT 1
84956: DEC
84957: ST_TO_ADDR
84958: LD_VAR 0 9
84962: PUSH
84963: FOR_TO
84964: IFFALSE 85052
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
84966: LD_VAR 0 14
84970: PUSH
84971: LD_VAR 0 8
84975: ARRAY
84976: PUSH
84977: LD_VAR 0 14
84981: PPUSH
84982: LD_INT 58
84984: PUSH
84985: EMPTY
84986: LIST
84987: PPUSH
84988: CALL_OW 72
84992: IN
84993: NOT
84994: IFFALSE 85050
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84996: LD_VAR 0 4
85000: PUSH
85001: LD_VAR 0 7
85005: ARRAY
85006: PPUSH
85007: LD_VAR 0 14
85011: PUSH
85012: LD_VAR 0 8
85016: ARRAY
85017: PPUSH
85018: CALL_OW 115
// attacking := true ;
85022: LD_ADDR_VAR 0 29
85026: PUSH
85027: LD_INT 1
85029: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85030: LD_VAR 0 4
85034: PUSH
85035: LD_VAR 0 7
85039: ARRAY
85040: PPUSH
85041: LD_INT 71
85043: PPUSH
85044: CALL_OW 109
// continue ;
85048: GO 84963
// end ; end ;
85050: GO 84963
85052: POP
85053: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85054: LD_VAR 0 4
85058: PUSH
85059: LD_VAR 0 7
85063: ARRAY
85064: PPUSH
85065: CALL_OW 257
85069: PUSH
85070: LD_INT 8
85072: EQUAL
85073: PUSH
85074: LD_VAR 0 4
85078: PUSH
85079: LD_VAR 0 7
85083: ARRAY
85084: PPUSH
85085: CALL_OW 264
85089: PUSH
85090: LD_INT 28
85092: PUSH
85093: LD_INT 45
85095: PUSH
85096: LD_INT 7
85098: PUSH
85099: LD_INT 47
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: LIST
85106: LIST
85107: IN
85108: OR
85109: IFFALSE 85339
// begin attacking := false ;
85111: LD_ADDR_VAR 0 29
85115: PUSH
85116: LD_INT 0
85118: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85119: LD_VAR 0 14
85123: PUSH
85124: LD_INT 1
85126: ARRAY
85127: PPUSH
85128: CALL_OW 266
85132: PUSH
85133: LD_INT 32
85135: PUSH
85136: LD_INT 31
85138: PUSH
85139: LD_INT 33
85141: PUSH
85142: LD_INT 4
85144: PUSH
85145: LD_INT 5
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: IN
85155: IFFALSE 85339
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
85157: LD_ADDR_VAR 0 9
85161: PUSH
85162: LD_VAR 0 14
85166: PUSH
85167: LD_INT 1
85169: ARRAY
85170: PPUSH
85171: CALL_OW 266
85175: PPUSH
85176: LD_VAR 0 14
85180: PUSH
85181: LD_INT 1
85183: ARRAY
85184: PPUSH
85185: CALL_OW 250
85189: PPUSH
85190: LD_VAR 0 14
85194: PUSH
85195: LD_INT 1
85197: ARRAY
85198: PPUSH
85199: CALL_OW 251
85203: PPUSH
85204: LD_VAR 0 14
85208: PUSH
85209: LD_INT 1
85211: ARRAY
85212: PPUSH
85213: CALL_OW 254
85217: PPUSH
85218: LD_VAR 0 14
85222: PUSH
85223: LD_INT 1
85225: ARRAY
85226: PPUSH
85227: CALL_OW 248
85231: PPUSH
85232: LD_INT 0
85234: PPUSH
85235: CALL 61945 0 6
85239: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
85240: LD_ADDR_VAR 0 8
85244: PUSH
85245: LD_VAR 0 4
85249: PUSH
85250: LD_VAR 0 7
85254: ARRAY
85255: PPUSH
85256: LD_VAR 0 9
85260: PPUSH
85261: CALL 80638 0 2
85265: ST_TO_ADDR
// if j then
85266: LD_VAR 0 8
85270: IFFALSE 85339
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
85272: LD_VAR 0 8
85276: PUSH
85277: LD_INT 1
85279: ARRAY
85280: PPUSH
85281: LD_VAR 0 8
85285: PUSH
85286: LD_INT 2
85288: ARRAY
85289: PPUSH
85290: CALL_OW 488
85294: IFFALSE 85339
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
85296: LD_VAR 0 4
85300: PUSH
85301: LD_VAR 0 7
85305: ARRAY
85306: PPUSH
85307: LD_VAR 0 8
85311: PUSH
85312: LD_INT 1
85314: ARRAY
85315: PPUSH
85316: LD_VAR 0 8
85320: PUSH
85321: LD_INT 2
85323: ARRAY
85324: PPUSH
85325: CALL_OW 116
// attacking := true ;
85329: LD_ADDR_VAR 0 29
85333: PUSH
85334: LD_INT 1
85336: ST_TO_ADDR
// continue ;
85337: GO 82712
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
85339: LD_VAR 0 4
85343: PUSH
85344: LD_VAR 0 7
85348: ARRAY
85349: PPUSH
85350: CALL_OW 265
85354: PUSH
85355: LD_INT 11
85357: EQUAL
85358: IFFALSE 85636
// begin k := 10 ;
85360: LD_ADDR_VAR 0 9
85364: PUSH
85365: LD_INT 10
85367: ST_TO_ADDR
// x := 0 ;
85368: LD_ADDR_VAR 0 10
85372: PUSH
85373: LD_INT 0
85375: ST_TO_ADDR
// if tmp < k then
85376: LD_VAR 0 14
85380: PUSH
85381: LD_VAR 0 9
85385: LESS
85386: IFFALSE 85398
// k := tmp ;
85388: LD_ADDR_VAR 0 9
85392: PUSH
85393: LD_VAR 0 14
85397: ST_TO_ADDR
// for j = k downto 1 do
85398: LD_ADDR_VAR 0 8
85402: PUSH
85403: DOUBLE
85404: LD_VAR 0 9
85408: INC
85409: ST_TO_ADDR
85410: LD_INT 1
85412: PUSH
85413: FOR_DOWNTO
85414: IFFALSE 85489
// begin if GetType ( tmp [ j ] ) = unit_human then
85416: LD_VAR 0 14
85420: PUSH
85421: LD_VAR 0 8
85425: ARRAY
85426: PPUSH
85427: CALL_OW 247
85431: PUSH
85432: LD_INT 1
85434: EQUAL
85435: IFFALSE 85487
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
85437: LD_VAR 0 4
85441: PUSH
85442: LD_VAR 0 7
85446: ARRAY
85447: PPUSH
85448: LD_VAR 0 14
85452: PUSH
85453: LD_VAR 0 8
85457: ARRAY
85458: PPUSH
85459: CALL 80909 0 2
// x := tmp [ j ] ;
85463: LD_ADDR_VAR 0 10
85467: PUSH
85468: LD_VAR 0 14
85472: PUSH
85473: LD_VAR 0 8
85477: ARRAY
85478: ST_TO_ADDR
// attacking := true ;
85479: LD_ADDR_VAR 0 29
85483: PUSH
85484: LD_INT 1
85486: ST_TO_ADDR
// end ; end ;
85487: GO 85413
85489: POP
85490: POP
// if not x then
85491: LD_VAR 0 10
85495: NOT
85496: IFFALSE 85636
// begin attacking := true ;
85498: LD_ADDR_VAR 0 29
85502: PUSH
85503: LD_INT 1
85505: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
85506: LD_VAR 0 4
85510: PUSH
85511: LD_VAR 0 7
85515: ARRAY
85516: PPUSH
85517: CALL_OW 250
85521: PPUSH
85522: LD_VAR 0 4
85526: PUSH
85527: LD_VAR 0 7
85531: ARRAY
85532: PPUSH
85533: CALL_OW 251
85537: PPUSH
85538: CALL_OW 546
85542: PUSH
85543: LD_INT 2
85545: ARRAY
85546: PUSH
85547: LD_VAR 0 14
85551: PUSH
85552: LD_INT 1
85554: ARRAY
85555: PPUSH
85556: CALL_OW 250
85560: PPUSH
85561: LD_VAR 0 14
85565: PUSH
85566: LD_INT 1
85568: ARRAY
85569: PPUSH
85570: CALL_OW 251
85574: PPUSH
85575: CALL_OW 546
85579: PUSH
85580: LD_INT 2
85582: ARRAY
85583: EQUAL
85584: IFFALSE 85612
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
85586: LD_VAR 0 4
85590: PUSH
85591: LD_VAR 0 7
85595: ARRAY
85596: PPUSH
85597: LD_VAR 0 14
85601: PUSH
85602: LD_INT 1
85604: ARRAY
85605: PPUSH
85606: CALL 80909 0 2
85610: GO 85636
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85612: LD_VAR 0 4
85616: PUSH
85617: LD_VAR 0 7
85621: ARRAY
85622: PPUSH
85623: LD_VAR 0 14
85627: PUSH
85628: LD_INT 1
85630: ARRAY
85631: PPUSH
85632: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
85636: LD_VAR 0 4
85640: PUSH
85641: LD_VAR 0 7
85645: ARRAY
85646: PPUSH
85647: CALL_OW 264
85651: PUSH
85652: LD_INT 29
85654: EQUAL
85655: IFFALSE 86021
// begin if WantsToAttack ( group [ i ] ) in bombed then
85657: LD_VAR 0 4
85661: PUSH
85662: LD_VAR 0 7
85666: ARRAY
85667: PPUSH
85668: CALL_OW 319
85672: PUSH
85673: LD_VAR 0 28
85677: IN
85678: IFFALSE 85682
// continue ;
85680: GO 82712
// k := 8 ;
85682: LD_ADDR_VAR 0 9
85686: PUSH
85687: LD_INT 8
85689: ST_TO_ADDR
// x := 0 ;
85690: LD_ADDR_VAR 0 10
85694: PUSH
85695: LD_INT 0
85697: ST_TO_ADDR
// if tmp < k then
85698: LD_VAR 0 14
85702: PUSH
85703: LD_VAR 0 9
85707: LESS
85708: IFFALSE 85720
// k := tmp ;
85710: LD_ADDR_VAR 0 9
85714: PUSH
85715: LD_VAR 0 14
85719: ST_TO_ADDR
// for j = 1 to k do
85720: LD_ADDR_VAR 0 8
85724: PUSH
85725: DOUBLE
85726: LD_INT 1
85728: DEC
85729: ST_TO_ADDR
85730: LD_VAR 0 9
85734: PUSH
85735: FOR_TO
85736: IFFALSE 85868
// begin if GetType ( tmp [ j ] ) = unit_building then
85738: LD_VAR 0 14
85742: PUSH
85743: LD_VAR 0 8
85747: ARRAY
85748: PPUSH
85749: CALL_OW 247
85753: PUSH
85754: LD_INT 3
85756: EQUAL
85757: IFFALSE 85866
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
85759: LD_VAR 0 14
85763: PUSH
85764: LD_VAR 0 8
85768: ARRAY
85769: PUSH
85770: LD_VAR 0 28
85774: IN
85775: NOT
85776: PUSH
85777: LD_VAR 0 14
85781: PUSH
85782: LD_VAR 0 8
85786: ARRAY
85787: PPUSH
85788: CALL_OW 313
85792: AND
85793: IFFALSE 85866
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85795: LD_VAR 0 4
85799: PUSH
85800: LD_VAR 0 7
85804: ARRAY
85805: PPUSH
85806: LD_VAR 0 14
85810: PUSH
85811: LD_VAR 0 8
85815: ARRAY
85816: PPUSH
85817: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
85821: LD_ADDR_VAR 0 28
85825: PUSH
85826: LD_VAR 0 28
85830: PPUSH
85831: LD_VAR 0 28
85835: PUSH
85836: LD_INT 1
85838: PLUS
85839: PPUSH
85840: LD_VAR 0 14
85844: PUSH
85845: LD_VAR 0 8
85849: ARRAY
85850: PPUSH
85851: CALL_OW 1
85855: ST_TO_ADDR
// attacking := true ;
85856: LD_ADDR_VAR 0 29
85860: PUSH
85861: LD_INT 1
85863: ST_TO_ADDR
// break ;
85864: GO 85868
// end ; end ;
85866: GO 85735
85868: POP
85869: POP
// if not attacking and f_attack_depot then
85870: LD_VAR 0 29
85874: NOT
85875: PUSH
85876: LD_VAR 0 25
85880: AND
85881: IFFALSE 85976
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85883: LD_ADDR_VAR 0 13
85887: PUSH
85888: LD_VAR 0 14
85892: PPUSH
85893: LD_INT 2
85895: PUSH
85896: LD_INT 30
85898: PUSH
85899: LD_INT 0
85901: PUSH
85902: EMPTY
85903: LIST
85904: LIST
85905: PUSH
85906: LD_INT 30
85908: PUSH
85909: LD_INT 1
85911: PUSH
85912: EMPTY
85913: LIST
85914: LIST
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: LIST
85920: PPUSH
85921: CALL_OW 72
85925: ST_TO_ADDR
// if z then
85926: LD_VAR 0 13
85930: IFFALSE 85976
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
85932: LD_VAR 0 4
85936: PUSH
85937: LD_VAR 0 7
85941: ARRAY
85942: PPUSH
85943: LD_VAR 0 13
85947: PPUSH
85948: LD_VAR 0 4
85952: PUSH
85953: LD_VAR 0 7
85957: ARRAY
85958: PPUSH
85959: CALL_OW 74
85963: PPUSH
85964: CALL_OW 115
// attacking := true ;
85968: LD_ADDR_VAR 0 29
85972: PUSH
85973: LD_INT 1
85975: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
85976: LD_VAR 0 4
85980: PUSH
85981: LD_VAR 0 7
85985: ARRAY
85986: PPUSH
85987: CALL_OW 256
85991: PUSH
85992: LD_INT 500
85994: LESS
85995: IFFALSE 86021
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85997: LD_VAR 0 4
86001: PUSH
86002: LD_VAR 0 7
86006: ARRAY
86007: PPUSH
86008: LD_VAR 0 14
86012: PUSH
86013: LD_INT 1
86015: ARRAY
86016: PPUSH
86017: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86021: LD_VAR 0 4
86025: PUSH
86026: LD_VAR 0 7
86030: ARRAY
86031: PPUSH
86032: CALL_OW 264
86036: PUSH
86037: LD_INT 49
86039: EQUAL
86040: IFFALSE 86161
// begin if not HasTask ( group [ i ] ) then
86042: LD_VAR 0 4
86046: PUSH
86047: LD_VAR 0 7
86051: ARRAY
86052: PPUSH
86053: CALL_OW 314
86057: NOT
86058: IFFALSE 86161
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86060: LD_ADDR_VAR 0 9
86064: PUSH
86065: LD_INT 81
86067: PUSH
86068: LD_VAR 0 4
86072: PUSH
86073: LD_VAR 0 7
86077: ARRAY
86078: PPUSH
86079: CALL_OW 255
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: PPUSH
86088: CALL_OW 69
86092: PPUSH
86093: LD_VAR 0 4
86097: PUSH
86098: LD_VAR 0 7
86102: ARRAY
86103: PPUSH
86104: CALL_OW 74
86108: ST_TO_ADDR
// if k then
86109: LD_VAR 0 9
86113: IFFALSE 86161
// if GetDistUnits ( group [ i ] , k ) > 10 then
86115: LD_VAR 0 4
86119: PUSH
86120: LD_VAR 0 7
86124: ARRAY
86125: PPUSH
86126: LD_VAR 0 9
86130: PPUSH
86131: CALL_OW 296
86135: PUSH
86136: LD_INT 10
86138: GREATER
86139: IFFALSE 86161
// ComMoveUnit ( group [ i ] , k ) ;
86141: LD_VAR 0 4
86145: PUSH
86146: LD_VAR 0 7
86150: ARRAY
86151: PPUSH
86152: LD_VAR 0 9
86156: PPUSH
86157: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86161: LD_VAR 0 4
86165: PUSH
86166: LD_VAR 0 7
86170: ARRAY
86171: PPUSH
86172: CALL_OW 256
86176: PUSH
86177: LD_INT 250
86179: LESS
86180: PUSH
86181: LD_VAR 0 4
86185: PUSH
86186: LD_VAR 0 7
86190: ARRAY
86191: PUSH
86192: LD_INT 21
86194: PUSH
86195: LD_INT 2
86197: PUSH
86198: EMPTY
86199: LIST
86200: LIST
86201: PUSH
86202: LD_INT 23
86204: PUSH
86205: LD_INT 2
86207: PUSH
86208: EMPTY
86209: LIST
86210: LIST
86211: PUSH
86212: EMPTY
86213: LIST
86214: LIST
86215: PPUSH
86216: CALL_OW 69
86220: IN
86221: AND
86222: IFFALSE 86347
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
86224: LD_ADDR_VAR 0 9
86228: PUSH
86229: LD_OWVAR 3
86233: PUSH
86234: LD_VAR 0 4
86238: PUSH
86239: LD_VAR 0 7
86243: ARRAY
86244: DIFF
86245: PPUSH
86246: LD_VAR 0 4
86250: PUSH
86251: LD_VAR 0 7
86255: ARRAY
86256: PPUSH
86257: CALL_OW 74
86261: ST_TO_ADDR
// if not k then
86262: LD_VAR 0 9
86266: NOT
86267: IFFALSE 86271
// continue ;
86269: GO 82712
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
86271: LD_VAR 0 9
86275: PUSH
86276: LD_INT 81
86278: PUSH
86279: LD_VAR 0 4
86283: PUSH
86284: LD_VAR 0 7
86288: ARRAY
86289: PPUSH
86290: CALL_OW 255
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PPUSH
86299: CALL_OW 69
86303: IN
86304: PUSH
86305: LD_VAR 0 9
86309: PPUSH
86310: LD_VAR 0 4
86314: PUSH
86315: LD_VAR 0 7
86319: ARRAY
86320: PPUSH
86321: CALL_OW 296
86325: PUSH
86326: LD_INT 5
86328: LESS
86329: AND
86330: IFFALSE 86347
// ComAutodestruct ( group [ i ] ) ;
86332: LD_VAR 0 4
86336: PUSH
86337: LD_VAR 0 7
86341: ARRAY
86342: PPUSH
86343: CALL 80807 0 1
// end ; if f_attack_depot then
86347: LD_VAR 0 25
86351: IFFALSE 86463
// begin k := 6 ;
86353: LD_ADDR_VAR 0 9
86357: PUSH
86358: LD_INT 6
86360: ST_TO_ADDR
// if tmp < k then
86361: LD_VAR 0 14
86365: PUSH
86366: LD_VAR 0 9
86370: LESS
86371: IFFALSE 86383
// k := tmp ;
86373: LD_ADDR_VAR 0 9
86377: PUSH
86378: LD_VAR 0 14
86382: ST_TO_ADDR
// for j = 1 to k do
86383: LD_ADDR_VAR 0 8
86387: PUSH
86388: DOUBLE
86389: LD_INT 1
86391: DEC
86392: ST_TO_ADDR
86393: LD_VAR 0 9
86397: PUSH
86398: FOR_TO
86399: IFFALSE 86461
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
86401: LD_VAR 0 8
86405: PPUSH
86406: CALL_OW 266
86410: PUSH
86411: LD_INT 0
86413: PUSH
86414: LD_INT 1
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: IN
86421: IFFALSE 86459
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86423: LD_VAR 0 4
86427: PUSH
86428: LD_VAR 0 7
86432: ARRAY
86433: PPUSH
86434: LD_VAR 0 14
86438: PUSH
86439: LD_VAR 0 8
86443: ARRAY
86444: PPUSH
86445: CALL_OW 115
// attacking := true ;
86449: LD_ADDR_VAR 0 29
86453: PUSH
86454: LD_INT 1
86456: ST_TO_ADDR
// break ;
86457: GO 86461
// end ;
86459: GO 86398
86461: POP
86462: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
86463: LD_VAR 0 4
86467: PUSH
86468: LD_VAR 0 7
86472: ARRAY
86473: PPUSH
86474: CALL_OW 302
86478: PUSH
86479: LD_VAR 0 29
86483: NOT
86484: AND
86485: IFFALSE 86807
// begin if GetTag ( group [ i ] ) = 71 then
86487: LD_VAR 0 4
86491: PUSH
86492: LD_VAR 0 7
86496: ARRAY
86497: PPUSH
86498: CALL_OW 110
86502: PUSH
86503: LD_INT 71
86505: EQUAL
86506: IFFALSE 86547
// begin if HasTask ( group [ i ] ) then
86508: LD_VAR 0 4
86512: PUSH
86513: LD_VAR 0 7
86517: ARRAY
86518: PPUSH
86519: CALL_OW 314
86523: IFFALSE 86529
// continue else
86525: GO 82712
86527: GO 86547
// SetTag ( group [ i ] , 0 ) ;
86529: LD_VAR 0 4
86533: PUSH
86534: LD_VAR 0 7
86538: ARRAY
86539: PPUSH
86540: LD_INT 0
86542: PPUSH
86543: CALL_OW 109
// end ; k := 8 ;
86547: LD_ADDR_VAR 0 9
86551: PUSH
86552: LD_INT 8
86554: ST_TO_ADDR
// x := 0 ;
86555: LD_ADDR_VAR 0 10
86559: PUSH
86560: LD_INT 0
86562: ST_TO_ADDR
// if tmp < k then
86563: LD_VAR 0 14
86567: PUSH
86568: LD_VAR 0 9
86572: LESS
86573: IFFALSE 86585
// k := tmp ;
86575: LD_ADDR_VAR 0 9
86579: PUSH
86580: LD_VAR 0 14
86584: ST_TO_ADDR
// for j = 1 to k do
86585: LD_ADDR_VAR 0 8
86589: PUSH
86590: DOUBLE
86591: LD_INT 1
86593: DEC
86594: ST_TO_ADDR
86595: LD_VAR 0 9
86599: PUSH
86600: FOR_TO
86601: IFFALSE 86699
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
86603: LD_VAR 0 14
86607: PUSH
86608: LD_VAR 0 8
86612: ARRAY
86613: PPUSH
86614: CALL_OW 247
86618: PUSH
86619: LD_INT 1
86621: EQUAL
86622: PUSH
86623: LD_VAR 0 14
86627: PUSH
86628: LD_VAR 0 8
86632: ARRAY
86633: PPUSH
86634: CALL_OW 256
86638: PUSH
86639: LD_INT 250
86641: LESS
86642: PUSH
86643: LD_VAR 0 20
86647: AND
86648: PUSH
86649: LD_VAR 0 20
86653: NOT
86654: PUSH
86655: LD_VAR 0 14
86659: PUSH
86660: LD_VAR 0 8
86664: ARRAY
86665: PPUSH
86666: CALL_OW 256
86670: PUSH
86671: LD_INT 250
86673: GREATEREQUAL
86674: AND
86675: OR
86676: AND
86677: IFFALSE 86697
// begin x := tmp [ j ] ;
86679: LD_ADDR_VAR 0 10
86683: PUSH
86684: LD_VAR 0 14
86688: PUSH
86689: LD_VAR 0 8
86693: ARRAY
86694: ST_TO_ADDR
// break ;
86695: GO 86699
// end ;
86697: GO 86600
86699: POP
86700: POP
// if x then
86701: LD_VAR 0 10
86705: IFFALSE 86729
// ComAttackUnit ( group [ i ] , x ) else
86707: LD_VAR 0 4
86711: PUSH
86712: LD_VAR 0 7
86716: ARRAY
86717: PPUSH
86718: LD_VAR 0 10
86722: PPUSH
86723: CALL_OW 115
86727: GO 86753
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86729: LD_VAR 0 4
86733: PUSH
86734: LD_VAR 0 7
86738: ARRAY
86739: PPUSH
86740: LD_VAR 0 14
86744: PUSH
86745: LD_INT 1
86747: ARRAY
86748: PPUSH
86749: CALL_OW 115
// if not HasTask ( group [ i ] ) then
86753: LD_VAR 0 4
86757: PUSH
86758: LD_VAR 0 7
86762: ARRAY
86763: PPUSH
86764: CALL_OW 314
86768: NOT
86769: IFFALSE 86807
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
86771: LD_VAR 0 4
86775: PUSH
86776: LD_VAR 0 7
86780: ARRAY
86781: PPUSH
86782: LD_VAR 0 14
86786: PPUSH
86787: LD_VAR 0 4
86791: PUSH
86792: LD_VAR 0 7
86796: ARRAY
86797: PPUSH
86798: CALL_OW 74
86802: PPUSH
86803: CALL_OW 115
// end ; end ; end ;
86807: GO 82712
86809: POP
86810: POP
// wait ( 0 0$1 ) ;
86811: LD_INT 35
86813: PPUSH
86814: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
86818: LD_VAR 0 4
86822: PUSH
86823: EMPTY
86824: EQUAL
86825: PUSH
86826: LD_INT 81
86828: PUSH
86829: LD_VAR 0 35
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PPUSH
86838: CALL_OW 69
86842: NOT
86843: OR
86844: IFFALSE 82697
// end ;
86846: LD_VAR 0 2
86850: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
86851: LD_INT 0
86853: PPUSH
86854: PPUSH
86855: PPUSH
86856: PPUSH
// if not base_units then
86857: LD_VAR 0 1
86861: NOT
86862: IFFALSE 86866
// exit ;
86864: GO 86953
// result := false ;
86866: LD_ADDR_VAR 0 2
86870: PUSH
86871: LD_INT 0
86873: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
86874: LD_ADDR_VAR 0 5
86878: PUSH
86879: LD_VAR 0 1
86883: PPUSH
86884: LD_INT 21
86886: PUSH
86887: LD_INT 3
86889: PUSH
86890: EMPTY
86891: LIST
86892: LIST
86893: PPUSH
86894: CALL_OW 72
86898: ST_TO_ADDR
// if not tmp then
86899: LD_VAR 0 5
86903: NOT
86904: IFFALSE 86908
// exit ;
86906: GO 86953
// for i in tmp do
86908: LD_ADDR_VAR 0 3
86912: PUSH
86913: LD_VAR 0 5
86917: PUSH
86918: FOR_IN
86919: IFFALSE 86951
// begin result := EnemyInRange ( i , 22 ) ;
86921: LD_ADDR_VAR 0 2
86925: PUSH
86926: LD_VAR 0 3
86930: PPUSH
86931: LD_INT 22
86933: PPUSH
86934: CALL 80490 0 2
86938: ST_TO_ADDR
// if result then
86939: LD_VAR 0 2
86943: IFFALSE 86949
// exit ;
86945: POP
86946: POP
86947: GO 86953
// end ;
86949: GO 86918
86951: POP
86952: POP
// end ;
86953: LD_VAR 0 2
86957: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
86958: LD_INT 0
86960: PPUSH
86961: PPUSH
// if not units then
86962: LD_VAR 0 1
86966: NOT
86967: IFFALSE 86971
// exit ;
86969: GO 87041
// result := [ ] ;
86971: LD_ADDR_VAR 0 3
86975: PUSH
86976: EMPTY
86977: ST_TO_ADDR
// for i in units do
86978: LD_ADDR_VAR 0 4
86982: PUSH
86983: LD_VAR 0 1
86987: PUSH
86988: FOR_IN
86989: IFFALSE 87039
// if GetTag ( i ) = tag then
86991: LD_VAR 0 4
86995: PPUSH
86996: CALL_OW 110
87000: PUSH
87001: LD_VAR 0 2
87005: EQUAL
87006: IFFALSE 87037
// result := Insert ( result , result + 1 , i ) ;
87008: LD_ADDR_VAR 0 3
87012: PUSH
87013: LD_VAR 0 3
87017: PPUSH
87018: LD_VAR 0 3
87022: PUSH
87023: LD_INT 1
87025: PLUS
87026: PPUSH
87027: LD_VAR 0 4
87031: PPUSH
87032: CALL_OW 2
87036: ST_TO_ADDR
87037: GO 86988
87039: POP
87040: POP
// end ;
87041: LD_VAR 0 3
87045: RET
// export function IsDriver ( un ) ; begin
87046: LD_INT 0
87048: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87049: LD_ADDR_VAR 0 2
87053: PUSH
87054: LD_VAR 0 1
87058: PUSH
87059: LD_INT 55
87061: PUSH
87062: EMPTY
87063: LIST
87064: PPUSH
87065: CALL_OW 69
87069: IN
87070: ST_TO_ADDR
// end ;
87071: LD_VAR 0 2
87075: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87076: LD_INT 0
87078: PPUSH
87079: PPUSH
// list := [ ] ;
87080: LD_ADDR_VAR 0 5
87084: PUSH
87085: EMPTY
87086: ST_TO_ADDR
// case d of 0 :
87087: LD_VAR 0 3
87091: PUSH
87092: LD_INT 0
87094: DOUBLE
87095: EQUAL
87096: IFTRUE 87100
87098: GO 87233
87100: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87101: LD_ADDR_VAR 0 5
87105: PUSH
87106: LD_VAR 0 1
87110: PUSH
87111: LD_INT 4
87113: MINUS
87114: PUSH
87115: LD_VAR 0 2
87119: PUSH
87120: LD_INT 4
87122: MINUS
87123: PUSH
87124: LD_INT 2
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: LIST
87131: PUSH
87132: LD_VAR 0 1
87136: PUSH
87137: LD_INT 3
87139: MINUS
87140: PUSH
87141: LD_VAR 0 2
87145: PUSH
87146: LD_INT 1
87148: PUSH
87149: EMPTY
87150: LIST
87151: LIST
87152: LIST
87153: PUSH
87154: LD_VAR 0 1
87158: PUSH
87159: LD_INT 4
87161: PLUS
87162: PUSH
87163: LD_VAR 0 2
87167: PUSH
87168: LD_INT 4
87170: PUSH
87171: EMPTY
87172: LIST
87173: LIST
87174: LIST
87175: PUSH
87176: LD_VAR 0 1
87180: PUSH
87181: LD_INT 3
87183: PLUS
87184: PUSH
87185: LD_VAR 0 2
87189: PUSH
87190: LD_INT 3
87192: PLUS
87193: PUSH
87194: LD_INT 5
87196: PUSH
87197: EMPTY
87198: LIST
87199: LIST
87200: LIST
87201: PUSH
87202: LD_VAR 0 1
87206: PUSH
87207: LD_VAR 0 2
87211: PUSH
87212: LD_INT 4
87214: PLUS
87215: PUSH
87216: LD_INT 0
87218: PUSH
87219: EMPTY
87220: LIST
87221: LIST
87222: LIST
87223: PUSH
87224: EMPTY
87225: LIST
87226: LIST
87227: LIST
87228: LIST
87229: LIST
87230: ST_TO_ADDR
// end ; 1 :
87231: GO 87931
87233: LD_INT 1
87235: DOUBLE
87236: EQUAL
87237: IFTRUE 87241
87239: GO 87374
87241: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
87242: LD_ADDR_VAR 0 5
87246: PUSH
87247: LD_VAR 0 1
87251: PUSH
87252: LD_VAR 0 2
87256: PUSH
87257: LD_INT 4
87259: MINUS
87260: PUSH
87261: LD_INT 3
87263: PUSH
87264: EMPTY
87265: LIST
87266: LIST
87267: LIST
87268: PUSH
87269: LD_VAR 0 1
87273: PUSH
87274: LD_INT 3
87276: MINUS
87277: PUSH
87278: LD_VAR 0 2
87282: PUSH
87283: LD_INT 3
87285: MINUS
87286: PUSH
87287: LD_INT 2
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: LIST
87294: PUSH
87295: LD_VAR 0 1
87299: PUSH
87300: LD_INT 4
87302: MINUS
87303: PUSH
87304: LD_VAR 0 2
87308: PUSH
87309: LD_INT 1
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: LIST
87316: PUSH
87317: LD_VAR 0 1
87321: PUSH
87322: LD_VAR 0 2
87326: PUSH
87327: LD_INT 3
87329: PLUS
87330: PUSH
87331: LD_INT 0
87333: PUSH
87334: EMPTY
87335: LIST
87336: LIST
87337: LIST
87338: PUSH
87339: LD_VAR 0 1
87343: PUSH
87344: LD_INT 4
87346: PLUS
87347: PUSH
87348: LD_VAR 0 2
87352: PUSH
87353: LD_INT 4
87355: PLUS
87356: PUSH
87357: LD_INT 5
87359: PUSH
87360: EMPTY
87361: LIST
87362: LIST
87363: LIST
87364: PUSH
87365: EMPTY
87366: LIST
87367: LIST
87368: LIST
87369: LIST
87370: LIST
87371: ST_TO_ADDR
// end ; 2 :
87372: GO 87931
87374: LD_INT 2
87376: DOUBLE
87377: EQUAL
87378: IFTRUE 87382
87380: GO 87511
87382: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
87383: LD_ADDR_VAR 0 5
87387: PUSH
87388: LD_VAR 0 1
87392: PUSH
87393: LD_VAR 0 2
87397: PUSH
87398: LD_INT 3
87400: MINUS
87401: PUSH
87402: LD_INT 3
87404: PUSH
87405: EMPTY
87406: LIST
87407: LIST
87408: LIST
87409: PUSH
87410: LD_VAR 0 1
87414: PUSH
87415: LD_INT 4
87417: PLUS
87418: PUSH
87419: LD_VAR 0 2
87423: PUSH
87424: LD_INT 4
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: LIST
87431: PUSH
87432: LD_VAR 0 1
87436: PUSH
87437: LD_VAR 0 2
87441: PUSH
87442: LD_INT 4
87444: PLUS
87445: PUSH
87446: LD_INT 0
87448: PUSH
87449: EMPTY
87450: LIST
87451: LIST
87452: LIST
87453: PUSH
87454: LD_VAR 0 1
87458: PUSH
87459: LD_INT 3
87461: MINUS
87462: PUSH
87463: LD_VAR 0 2
87467: PUSH
87468: LD_INT 1
87470: PUSH
87471: EMPTY
87472: LIST
87473: LIST
87474: LIST
87475: PUSH
87476: LD_VAR 0 1
87480: PUSH
87481: LD_INT 4
87483: MINUS
87484: PUSH
87485: LD_VAR 0 2
87489: PUSH
87490: LD_INT 4
87492: MINUS
87493: PUSH
87494: LD_INT 2
87496: PUSH
87497: EMPTY
87498: LIST
87499: LIST
87500: LIST
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: LIST
87506: LIST
87507: LIST
87508: ST_TO_ADDR
// end ; 3 :
87509: GO 87931
87511: LD_INT 3
87513: DOUBLE
87514: EQUAL
87515: IFTRUE 87519
87517: GO 87652
87519: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
87520: LD_ADDR_VAR 0 5
87524: PUSH
87525: LD_VAR 0 1
87529: PUSH
87530: LD_INT 3
87532: PLUS
87533: PUSH
87534: LD_VAR 0 2
87538: PUSH
87539: LD_INT 4
87541: PUSH
87542: EMPTY
87543: LIST
87544: LIST
87545: LIST
87546: PUSH
87547: LD_VAR 0 1
87551: PUSH
87552: LD_INT 4
87554: PLUS
87555: PUSH
87556: LD_VAR 0 2
87560: PUSH
87561: LD_INT 4
87563: PLUS
87564: PUSH
87565: LD_INT 5
87567: PUSH
87568: EMPTY
87569: LIST
87570: LIST
87571: LIST
87572: PUSH
87573: LD_VAR 0 1
87577: PUSH
87578: LD_INT 4
87580: MINUS
87581: PUSH
87582: LD_VAR 0 2
87586: PUSH
87587: LD_INT 1
87589: PUSH
87590: EMPTY
87591: LIST
87592: LIST
87593: LIST
87594: PUSH
87595: LD_VAR 0 1
87599: PUSH
87600: LD_VAR 0 2
87604: PUSH
87605: LD_INT 4
87607: MINUS
87608: PUSH
87609: LD_INT 3
87611: PUSH
87612: EMPTY
87613: LIST
87614: LIST
87615: LIST
87616: PUSH
87617: LD_VAR 0 1
87621: PUSH
87622: LD_INT 3
87624: MINUS
87625: PUSH
87626: LD_VAR 0 2
87630: PUSH
87631: LD_INT 3
87633: MINUS
87634: PUSH
87635: LD_INT 2
87637: PUSH
87638: EMPTY
87639: LIST
87640: LIST
87641: LIST
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: LIST
87647: LIST
87648: LIST
87649: ST_TO_ADDR
// end ; 4 :
87650: GO 87931
87652: LD_INT 4
87654: DOUBLE
87655: EQUAL
87656: IFTRUE 87660
87658: GO 87793
87660: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
87661: LD_ADDR_VAR 0 5
87665: PUSH
87666: LD_VAR 0 1
87670: PUSH
87671: LD_VAR 0 2
87675: PUSH
87676: LD_INT 4
87678: PLUS
87679: PUSH
87680: LD_INT 0
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: LIST
87687: PUSH
87688: LD_VAR 0 1
87692: PUSH
87693: LD_INT 3
87695: PLUS
87696: PUSH
87697: LD_VAR 0 2
87701: PUSH
87702: LD_INT 3
87704: PLUS
87705: PUSH
87706: LD_INT 5
87708: PUSH
87709: EMPTY
87710: LIST
87711: LIST
87712: LIST
87713: PUSH
87714: LD_VAR 0 1
87718: PUSH
87719: LD_INT 4
87721: PLUS
87722: PUSH
87723: LD_VAR 0 2
87727: PUSH
87728: LD_INT 4
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: LIST
87735: PUSH
87736: LD_VAR 0 1
87740: PUSH
87741: LD_VAR 0 2
87745: PUSH
87746: LD_INT 3
87748: MINUS
87749: PUSH
87750: LD_INT 3
87752: PUSH
87753: EMPTY
87754: LIST
87755: LIST
87756: LIST
87757: PUSH
87758: LD_VAR 0 1
87762: PUSH
87763: LD_INT 4
87765: MINUS
87766: PUSH
87767: LD_VAR 0 2
87771: PUSH
87772: LD_INT 4
87774: MINUS
87775: PUSH
87776: LD_INT 2
87778: PUSH
87779: EMPTY
87780: LIST
87781: LIST
87782: LIST
87783: PUSH
87784: EMPTY
87785: LIST
87786: LIST
87787: LIST
87788: LIST
87789: LIST
87790: ST_TO_ADDR
// end ; 5 :
87791: GO 87931
87793: LD_INT 5
87795: DOUBLE
87796: EQUAL
87797: IFTRUE 87801
87799: GO 87930
87801: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
87802: LD_ADDR_VAR 0 5
87806: PUSH
87807: LD_VAR 0 1
87811: PUSH
87812: LD_INT 4
87814: MINUS
87815: PUSH
87816: LD_VAR 0 2
87820: PUSH
87821: LD_INT 1
87823: PUSH
87824: EMPTY
87825: LIST
87826: LIST
87827: LIST
87828: PUSH
87829: LD_VAR 0 1
87833: PUSH
87834: LD_VAR 0 2
87838: PUSH
87839: LD_INT 4
87841: MINUS
87842: PUSH
87843: LD_INT 3
87845: PUSH
87846: EMPTY
87847: LIST
87848: LIST
87849: LIST
87850: PUSH
87851: LD_VAR 0 1
87855: PUSH
87856: LD_INT 4
87858: PLUS
87859: PUSH
87860: LD_VAR 0 2
87864: PUSH
87865: LD_INT 4
87867: PLUS
87868: PUSH
87869: LD_INT 5
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: LIST
87876: PUSH
87877: LD_VAR 0 1
87881: PUSH
87882: LD_INT 3
87884: PLUS
87885: PUSH
87886: LD_VAR 0 2
87890: PUSH
87891: LD_INT 4
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: LIST
87898: PUSH
87899: LD_VAR 0 1
87903: PUSH
87904: LD_VAR 0 2
87908: PUSH
87909: LD_INT 3
87911: PLUS
87912: PUSH
87913: LD_INT 0
87915: PUSH
87916: EMPTY
87917: LIST
87918: LIST
87919: LIST
87920: PUSH
87921: EMPTY
87922: LIST
87923: LIST
87924: LIST
87925: LIST
87926: LIST
87927: ST_TO_ADDR
// end ; end ;
87928: GO 87931
87930: POP
// result := list ;
87931: LD_ADDR_VAR 0 4
87935: PUSH
87936: LD_VAR 0 5
87940: ST_TO_ADDR
// end ;
87941: LD_VAR 0 4
87945: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
87946: LD_INT 0
87948: PPUSH
87949: PPUSH
87950: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
87951: LD_VAR 0 1
87955: NOT
87956: PUSH
87957: LD_VAR 0 2
87961: PUSH
87962: LD_INT 1
87964: PUSH
87965: LD_INT 2
87967: PUSH
87968: LD_INT 3
87970: PUSH
87971: LD_INT 4
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: IN
87980: NOT
87981: OR
87982: IFFALSE 87986
// exit ;
87984: GO 88078
// tmp := [ ] ;
87986: LD_ADDR_VAR 0 5
87990: PUSH
87991: EMPTY
87992: ST_TO_ADDR
// for i in units do
87993: LD_ADDR_VAR 0 4
87997: PUSH
87998: LD_VAR 0 1
88002: PUSH
88003: FOR_IN
88004: IFFALSE 88047
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
88006: LD_ADDR_VAR 0 5
88010: PUSH
88011: LD_VAR 0 5
88015: PPUSH
88016: LD_VAR 0 5
88020: PUSH
88021: LD_INT 1
88023: PLUS
88024: PPUSH
88025: LD_VAR 0 4
88029: PPUSH
88030: LD_VAR 0 2
88034: PPUSH
88035: CALL_OW 259
88039: PPUSH
88040: CALL_OW 2
88044: ST_TO_ADDR
88045: GO 88003
88047: POP
88048: POP
// if not tmp then
88049: LD_VAR 0 5
88053: NOT
88054: IFFALSE 88058
// exit ;
88056: GO 88078
// result := SortListByListDesc ( units , tmp ) ;
88058: LD_ADDR_VAR 0 3
88062: PUSH
88063: LD_VAR 0 1
88067: PPUSH
88068: LD_VAR 0 5
88072: PPUSH
88073: CALL_OW 77
88077: ST_TO_ADDR
// end ;
88078: LD_VAR 0 3
88082: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88083: LD_INT 0
88085: PPUSH
88086: PPUSH
88087: PPUSH
// x := GetX ( building ) ;
88088: LD_ADDR_VAR 0 4
88092: PUSH
88093: LD_VAR 0 2
88097: PPUSH
88098: CALL_OW 250
88102: ST_TO_ADDR
// y := GetY ( building ) ;
88103: LD_ADDR_VAR 0 5
88107: PUSH
88108: LD_VAR 0 2
88112: PPUSH
88113: CALL_OW 251
88117: ST_TO_ADDR
// if GetTaskList ( unit ) then
88118: LD_VAR 0 1
88122: PPUSH
88123: CALL_OW 437
88127: IFFALSE 88222
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88129: LD_STRING e
88131: PUSH
88132: LD_VAR 0 1
88136: PPUSH
88137: CALL_OW 437
88141: PUSH
88142: LD_INT 1
88144: ARRAY
88145: PUSH
88146: LD_INT 1
88148: ARRAY
88149: EQUAL
88150: PUSH
88151: LD_VAR 0 4
88155: PUSH
88156: LD_VAR 0 1
88160: PPUSH
88161: CALL_OW 437
88165: PUSH
88166: LD_INT 1
88168: ARRAY
88169: PUSH
88170: LD_INT 2
88172: ARRAY
88173: EQUAL
88174: AND
88175: PUSH
88176: LD_VAR 0 5
88180: PUSH
88181: LD_VAR 0 1
88185: PPUSH
88186: CALL_OW 437
88190: PUSH
88191: LD_INT 1
88193: ARRAY
88194: PUSH
88195: LD_INT 3
88197: ARRAY
88198: EQUAL
88199: AND
88200: IFFALSE 88212
// result := true else
88202: LD_ADDR_VAR 0 3
88206: PUSH
88207: LD_INT 1
88209: ST_TO_ADDR
88210: GO 88220
// result := false ;
88212: LD_ADDR_VAR 0 3
88216: PUSH
88217: LD_INT 0
88219: ST_TO_ADDR
// end else
88220: GO 88230
// result := false ;
88222: LD_ADDR_VAR 0 3
88226: PUSH
88227: LD_INT 0
88229: ST_TO_ADDR
// end ;
88230: LD_VAR 0 3
88234: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
88235: LD_INT 0
88237: PPUSH
88238: PPUSH
88239: PPUSH
88240: PPUSH
// if not unit or not area then
88241: LD_VAR 0 1
88245: NOT
88246: PUSH
88247: LD_VAR 0 2
88251: NOT
88252: OR
88253: IFFALSE 88257
// exit ;
88255: GO 88421
// tmp := AreaToList ( area , i ) ;
88257: LD_ADDR_VAR 0 6
88261: PUSH
88262: LD_VAR 0 2
88266: PPUSH
88267: LD_VAR 0 5
88271: PPUSH
88272: CALL_OW 517
88276: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
88277: LD_ADDR_VAR 0 5
88281: PUSH
88282: DOUBLE
88283: LD_INT 1
88285: DEC
88286: ST_TO_ADDR
88287: LD_VAR 0 6
88291: PUSH
88292: LD_INT 1
88294: ARRAY
88295: PUSH
88296: FOR_TO
88297: IFFALSE 88419
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
88299: LD_ADDR_VAR 0 7
88303: PUSH
88304: LD_VAR 0 6
88308: PUSH
88309: LD_INT 1
88311: ARRAY
88312: PUSH
88313: LD_VAR 0 5
88317: ARRAY
88318: PUSH
88319: LD_VAR 0 6
88323: PUSH
88324: LD_INT 2
88326: ARRAY
88327: PUSH
88328: LD_VAR 0 5
88332: ARRAY
88333: PUSH
88334: EMPTY
88335: LIST
88336: LIST
88337: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
88338: LD_VAR 0 7
88342: PUSH
88343: LD_INT 1
88345: ARRAY
88346: PPUSH
88347: LD_VAR 0 7
88351: PUSH
88352: LD_INT 2
88354: ARRAY
88355: PPUSH
88356: CALL_OW 428
88360: PUSH
88361: LD_INT 0
88363: EQUAL
88364: IFFALSE 88417
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
88366: LD_VAR 0 1
88370: PPUSH
88371: LD_VAR 0 7
88375: PUSH
88376: LD_INT 1
88378: ARRAY
88379: PPUSH
88380: LD_VAR 0 7
88384: PUSH
88385: LD_INT 2
88387: ARRAY
88388: PPUSH
88389: LD_VAR 0 3
88393: PPUSH
88394: CALL_OW 48
// result := IsPlaced ( unit ) ;
88398: LD_ADDR_VAR 0 4
88402: PUSH
88403: LD_VAR 0 1
88407: PPUSH
88408: CALL_OW 305
88412: ST_TO_ADDR
// exit ;
88413: POP
88414: POP
88415: GO 88421
// end ; end ;
88417: GO 88296
88419: POP
88420: POP
// end ;
88421: LD_VAR 0 4
88425: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
88426: LD_INT 0
88428: PPUSH
88429: PPUSH
88430: PPUSH
// if not side or side > 8 then
88431: LD_VAR 0 1
88435: NOT
88436: PUSH
88437: LD_VAR 0 1
88441: PUSH
88442: LD_INT 8
88444: GREATER
88445: OR
88446: IFFALSE 88450
// exit ;
88448: GO 88637
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
88450: LD_ADDR_VAR 0 4
88454: PUSH
88455: LD_INT 22
88457: PUSH
88458: LD_VAR 0 1
88462: PUSH
88463: EMPTY
88464: LIST
88465: LIST
88466: PUSH
88467: LD_INT 21
88469: PUSH
88470: LD_INT 3
88472: PUSH
88473: EMPTY
88474: LIST
88475: LIST
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PPUSH
88481: CALL_OW 69
88485: ST_TO_ADDR
// if not tmp then
88486: LD_VAR 0 4
88490: NOT
88491: IFFALSE 88495
// exit ;
88493: GO 88637
// enable_addtolog := true ;
88495: LD_ADDR_OWVAR 81
88499: PUSH
88500: LD_INT 1
88502: ST_TO_ADDR
// AddToLog ( [ ) ;
88503: LD_STRING [
88505: PPUSH
88506: CALL_OW 561
// for i in tmp do
88510: LD_ADDR_VAR 0 3
88514: PUSH
88515: LD_VAR 0 4
88519: PUSH
88520: FOR_IN
88521: IFFALSE 88628
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
88523: LD_STRING [
88525: PUSH
88526: LD_VAR 0 3
88530: PPUSH
88531: CALL_OW 266
88535: STR
88536: PUSH
88537: LD_STRING , 
88539: STR
88540: PUSH
88541: LD_VAR 0 3
88545: PPUSH
88546: CALL_OW 250
88550: STR
88551: PUSH
88552: LD_STRING , 
88554: STR
88555: PUSH
88556: LD_VAR 0 3
88560: PPUSH
88561: CALL_OW 251
88565: STR
88566: PUSH
88567: LD_STRING , 
88569: STR
88570: PUSH
88571: LD_VAR 0 3
88575: PPUSH
88576: CALL_OW 254
88580: STR
88581: PUSH
88582: LD_STRING , 
88584: STR
88585: PUSH
88586: LD_VAR 0 3
88590: PPUSH
88591: LD_INT 1
88593: PPUSH
88594: CALL_OW 268
88598: STR
88599: PUSH
88600: LD_STRING , 
88602: STR
88603: PUSH
88604: LD_VAR 0 3
88608: PPUSH
88609: LD_INT 2
88611: PPUSH
88612: CALL_OW 268
88616: STR
88617: PUSH
88618: LD_STRING ],
88620: STR
88621: PPUSH
88622: CALL_OW 561
// end ;
88626: GO 88520
88628: POP
88629: POP
// AddToLog ( ]; ) ;
88630: LD_STRING ];
88632: PPUSH
88633: CALL_OW 561
// end ;
88637: LD_VAR 0 2
88641: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
88642: LD_INT 0
88644: PPUSH
88645: PPUSH
88646: PPUSH
88647: PPUSH
88648: PPUSH
// if not area or not rate or not max then
88649: LD_VAR 0 1
88653: NOT
88654: PUSH
88655: LD_VAR 0 2
88659: NOT
88660: OR
88661: PUSH
88662: LD_VAR 0 4
88666: NOT
88667: OR
88668: IFFALSE 88672
// exit ;
88670: GO 88864
// while 1 do
88672: LD_INT 1
88674: IFFALSE 88864
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
88676: LD_ADDR_VAR 0 9
88680: PUSH
88681: LD_VAR 0 1
88685: PPUSH
88686: LD_INT 1
88688: PPUSH
88689: CALL_OW 287
88693: PUSH
88694: LD_INT 10
88696: MUL
88697: ST_TO_ADDR
// r := rate / 10 ;
88698: LD_ADDR_VAR 0 7
88702: PUSH
88703: LD_VAR 0 2
88707: PUSH
88708: LD_INT 10
88710: DIVREAL
88711: ST_TO_ADDR
// time := 1 1$00 ;
88712: LD_ADDR_VAR 0 8
88716: PUSH
88717: LD_INT 2100
88719: ST_TO_ADDR
// if amount < min then
88720: LD_VAR 0 9
88724: PUSH
88725: LD_VAR 0 3
88729: LESS
88730: IFFALSE 88748
// r := r * 2 else
88732: LD_ADDR_VAR 0 7
88736: PUSH
88737: LD_VAR 0 7
88741: PUSH
88742: LD_INT 2
88744: MUL
88745: ST_TO_ADDR
88746: GO 88774
// if amount > max then
88748: LD_VAR 0 9
88752: PUSH
88753: LD_VAR 0 4
88757: GREATER
88758: IFFALSE 88774
// r := r / 2 ;
88760: LD_ADDR_VAR 0 7
88764: PUSH
88765: LD_VAR 0 7
88769: PUSH
88770: LD_INT 2
88772: DIVREAL
88773: ST_TO_ADDR
// time := time / r ;
88774: LD_ADDR_VAR 0 8
88778: PUSH
88779: LD_VAR 0 8
88783: PUSH
88784: LD_VAR 0 7
88788: DIVREAL
88789: ST_TO_ADDR
// if time < 0 then
88790: LD_VAR 0 8
88794: PUSH
88795: LD_INT 0
88797: LESS
88798: IFFALSE 88815
// time := time * - 1 ;
88800: LD_ADDR_VAR 0 8
88804: PUSH
88805: LD_VAR 0 8
88809: PUSH
88810: LD_INT 1
88812: NEG
88813: MUL
88814: ST_TO_ADDR
// wait ( time ) ;
88815: LD_VAR 0 8
88819: PPUSH
88820: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
88824: LD_INT 35
88826: PPUSH
88827: LD_INT 875
88829: PPUSH
88830: CALL_OW 12
88834: PPUSH
88835: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
88839: LD_INT 1
88841: PPUSH
88842: LD_INT 5
88844: PPUSH
88845: CALL_OW 12
88849: PPUSH
88850: LD_VAR 0 1
88854: PPUSH
88855: LD_INT 1
88857: PPUSH
88858: CALL_OW 55
// end ;
88862: GO 88672
// end ;
88864: LD_VAR 0 5
88868: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
88869: LD_INT 0
88871: PPUSH
88872: PPUSH
88873: PPUSH
88874: PPUSH
88875: PPUSH
88876: PPUSH
88877: PPUSH
88878: PPUSH
// if not turrets or not factories then
88879: LD_VAR 0 1
88883: NOT
88884: PUSH
88885: LD_VAR 0 2
88889: NOT
88890: OR
88891: IFFALSE 88895
// exit ;
88893: GO 89202
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
88895: LD_ADDR_VAR 0 10
88899: PUSH
88900: LD_INT 5
88902: PUSH
88903: LD_INT 6
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: PUSH
88910: LD_INT 2
88912: PUSH
88913: LD_INT 4
88915: PUSH
88916: EMPTY
88917: LIST
88918: LIST
88919: PUSH
88920: LD_INT 3
88922: PUSH
88923: LD_INT 5
88925: PUSH
88926: EMPTY
88927: LIST
88928: LIST
88929: PUSH
88930: EMPTY
88931: LIST
88932: LIST
88933: LIST
88934: PUSH
88935: LD_INT 24
88937: PUSH
88938: LD_INT 25
88940: PUSH
88941: EMPTY
88942: LIST
88943: LIST
88944: PUSH
88945: LD_INT 23
88947: PUSH
88948: LD_INT 27
88950: PUSH
88951: EMPTY
88952: LIST
88953: LIST
88954: PUSH
88955: EMPTY
88956: LIST
88957: LIST
88958: PUSH
88959: LD_INT 42
88961: PUSH
88962: LD_INT 43
88964: PUSH
88965: EMPTY
88966: LIST
88967: LIST
88968: PUSH
88969: LD_INT 44
88971: PUSH
88972: LD_INT 46
88974: PUSH
88975: EMPTY
88976: LIST
88977: LIST
88978: PUSH
88979: LD_INT 45
88981: PUSH
88982: LD_INT 47
88984: PUSH
88985: EMPTY
88986: LIST
88987: LIST
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: LIST
88993: PUSH
88994: EMPTY
88995: LIST
88996: LIST
88997: LIST
88998: ST_TO_ADDR
// result := [ ] ;
88999: LD_ADDR_VAR 0 3
89003: PUSH
89004: EMPTY
89005: ST_TO_ADDR
// for i in turrets do
89006: LD_ADDR_VAR 0 4
89010: PUSH
89011: LD_VAR 0 1
89015: PUSH
89016: FOR_IN
89017: IFFALSE 89200
// begin nat := GetNation ( i ) ;
89019: LD_ADDR_VAR 0 7
89023: PUSH
89024: LD_VAR 0 4
89028: PPUSH
89029: CALL_OW 248
89033: ST_TO_ADDR
// weapon := 0 ;
89034: LD_ADDR_VAR 0 8
89038: PUSH
89039: LD_INT 0
89041: ST_TO_ADDR
// if not nat then
89042: LD_VAR 0 7
89046: NOT
89047: IFFALSE 89051
// continue ;
89049: GO 89016
// for j in list [ nat ] do
89051: LD_ADDR_VAR 0 5
89055: PUSH
89056: LD_VAR 0 10
89060: PUSH
89061: LD_VAR 0 7
89065: ARRAY
89066: PUSH
89067: FOR_IN
89068: IFFALSE 89109
// if GetBWeapon ( i ) = j [ 1 ] then
89070: LD_VAR 0 4
89074: PPUSH
89075: CALL_OW 269
89079: PUSH
89080: LD_VAR 0 5
89084: PUSH
89085: LD_INT 1
89087: ARRAY
89088: EQUAL
89089: IFFALSE 89107
// begin weapon := j [ 2 ] ;
89091: LD_ADDR_VAR 0 8
89095: PUSH
89096: LD_VAR 0 5
89100: PUSH
89101: LD_INT 2
89103: ARRAY
89104: ST_TO_ADDR
// break ;
89105: GO 89109
// end ;
89107: GO 89067
89109: POP
89110: POP
// if not weapon then
89111: LD_VAR 0 8
89115: NOT
89116: IFFALSE 89120
// continue ;
89118: GO 89016
// for k in factories do
89120: LD_ADDR_VAR 0 6
89124: PUSH
89125: LD_VAR 0 2
89129: PUSH
89130: FOR_IN
89131: IFFALSE 89196
// begin weapons := AvailableWeaponList ( k ) ;
89133: LD_ADDR_VAR 0 9
89137: PUSH
89138: LD_VAR 0 6
89142: PPUSH
89143: CALL_OW 478
89147: ST_TO_ADDR
// if not weapons then
89148: LD_VAR 0 9
89152: NOT
89153: IFFALSE 89157
// continue ;
89155: GO 89130
// if weapon in weapons then
89157: LD_VAR 0 8
89161: PUSH
89162: LD_VAR 0 9
89166: IN
89167: IFFALSE 89194
// begin result := [ i , weapon ] ;
89169: LD_ADDR_VAR 0 3
89173: PUSH
89174: LD_VAR 0 4
89178: PUSH
89179: LD_VAR 0 8
89183: PUSH
89184: EMPTY
89185: LIST
89186: LIST
89187: ST_TO_ADDR
// exit ;
89188: POP
89189: POP
89190: POP
89191: POP
89192: GO 89202
// end ; end ;
89194: GO 89130
89196: POP
89197: POP
// end ;
89198: GO 89016
89200: POP
89201: POP
// end ;
89202: LD_VAR 0 3
89206: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
89207: LD_INT 0
89209: PPUSH
// if not side or side > 8 then
89210: LD_VAR 0 3
89214: NOT
89215: PUSH
89216: LD_VAR 0 3
89220: PUSH
89221: LD_INT 8
89223: GREATER
89224: OR
89225: IFFALSE 89229
// exit ;
89227: GO 89288
// if not range then
89229: LD_VAR 0 4
89233: NOT
89234: IFFALSE 89245
// range := - 12 ;
89236: LD_ADDR_VAR 0 4
89240: PUSH
89241: LD_INT 12
89243: NEG
89244: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
89245: LD_VAR 0 1
89249: PPUSH
89250: LD_VAR 0 2
89254: PPUSH
89255: LD_VAR 0 3
89259: PPUSH
89260: LD_VAR 0 4
89264: PPUSH
89265: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
89269: LD_VAR 0 1
89273: PPUSH
89274: LD_VAR 0 2
89278: PPUSH
89279: LD_VAR 0 3
89283: PPUSH
89284: CALL_OW 331
// end ;
89288: LD_VAR 0 5
89292: RET
// export function Video ( mode ) ; begin
89293: LD_INT 0
89295: PPUSH
// ingame_video = mode ;
89296: LD_ADDR_OWVAR 52
89300: PUSH
89301: LD_VAR 0 1
89305: ST_TO_ADDR
// interface_hidden = mode ;
89306: LD_ADDR_OWVAR 54
89310: PUSH
89311: LD_VAR 0 1
89315: ST_TO_ADDR
// end ;
89316: LD_VAR 0 2
89320: RET
// export function Join ( array , element ) ; begin
89321: LD_INT 0
89323: PPUSH
// result := array ^ element ;
89324: LD_ADDR_VAR 0 3
89328: PUSH
89329: LD_VAR 0 1
89333: PUSH
89334: LD_VAR 0 2
89338: ADD
89339: ST_TO_ADDR
// end ;
89340: LD_VAR 0 3
89344: RET
// export function JoinUnion ( array , element ) ; begin
89345: LD_INT 0
89347: PPUSH
// result := array union element ;
89348: LD_ADDR_VAR 0 3
89352: PUSH
89353: LD_VAR 0 1
89357: PUSH
89358: LD_VAR 0 2
89362: UNION
89363: ST_TO_ADDR
// end ;
89364: LD_VAR 0 3
89368: RET
// export function GetBehemoths ( side ) ; begin
89369: LD_INT 0
89371: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
89372: LD_ADDR_VAR 0 2
89376: PUSH
89377: LD_INT 22
89379: PUSH
89380: LD_VAR 0 1
89384: PUSH
89385: EMPTY
89386: LIST
89387: LIST
89388: PUSH
89389: LD_INT 31
89391: PUSH
89392: LD_INT 25
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: PPUSH
89403: CALL_OW 69
89407: ST_TO_ADDR
// end ;
89408: LD_VAR 0 2
89412: RET
// export function Shuffle ( array ) ; var i , index ; begin
89413: LD_INT 0
89415: PPUSH
89416: PPUSH
89417: PPUSH
// result := [ ] ;
89418: LD_ADDR_VAR 0 2
89422: PUSH
89423: EMPTY
89424: ST_TO_ADDR
// if not array then
89425: LD_VAR 0 1
89429: NOT
89430: IFFALSE 89434
// exit ;
89432: GO 89533
// Randomize ;
89434: CALL_OW 10
// for i = array downto 1 do
89438: LD_ADDR_VAR 0 3
89442: PUSH
89443: DOUBLE
89444: LD_VAR 0 1
89448: INC
89449: ST_TO_ADDR
89450: LD_INT 1
89452: PUSH
89453: FOR_DOWNTO
89454: IFFALSE 89531
// begin index := rand ( 1 , array ) ;
89456: LD_ADDR_VAR 0 4
89460: PUSH
89461: LD_INT 1
89463: PPUSH
89464: LD_VAR 0 1
89468: PPUSH
89469: CALL_OW 12
89473: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
89474: LD_ADDR_VAR 0 2
89478: PUSH
89479: LD_VAR 0 2
89483: PPUSH
89484: LD_VAR 0 2
89488: PUSH
89489: LD_INT 1
89491: PLUS
89492: PPUSH
89493: LD_VAR 0 1
89497: PUSH
89498: LD_VAR 0 4
89502: ARRAY
89503: PPUSH
89504: CALL_OW 2
89508: ST_TO_ADDR
// array := Delete ( array , index ) ;
89509: LD_ADDR_VAR 0 1
89513: PUSH
89514: LD_VAR 0 1
89518: PPUSH
89519: LD_VAR 0 4
89523: PPUSH
89524: CALL_OW 3
89528: ST_TO_ADDR
// end ;
89529: GO 89453
89531: POP
89532: POP
// end ;
89533: LD_VAR 0 2
89537: RET
// export function GetBaseMaterials ( base ) ; begin
89538: LD_INT 0
89540: PPUSH
// result := [ 0 , 0 , 0 ] ;
89541: LD_ADDR_VAR 0 2
89545: PUSH
89546: LD_INT 0
89548: PUSH
89549: LD_INT 0
89551: PUSH
89552: LD_INT 0
89554: PUSH
89555: EMPTY
89556: LIST
89557: LIST
89558: LIST
89559: ST_TO_ADDR
// if not base then
89560: LD_VAR 0 1
89564: NOT
89565: IFFALSE 89569
// exit ;
89567: GO 89618
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
89569: LD_ADDR_VAR 0 2
89573: PUSH
89574: LD_VAR 0 1
89578: PPUSH
89579: LD_INT 1
89581: PPUSH
89582: CALL_OW 275
89586: PUSH
89587: LD_VAR 0 1
89591: PPUSH
89592: LD_INT 2
89594: PPUSH
89595: CALL_OW 275
89599: PUSH
89600: LD_VAR 0 1
89604: PPUSH
89605: LD_INT 3
89607: PPUSH
89608: CALL_OW 275
89612: PUSH
89613: EMPTY
89614: LIST
89615: LIST
89616: LIST
89617: ST_TO_ADDR
// end ; end_of_file
89618: LD_VAR 0 2
89622: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
89623: GO 89625
89625: DISABLE
// begin ru_radar := 98 ;
89626: LD_ADDR_EXP 92
89630: PUSH
89631: LD_INT 98
89633: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
89634: LD_ADDR_EXP 93
89638: PUSH
89639: LD_INT 89
89641: ST_TO_ADDR
// us_hack := 99 ;
89642: LD_ADDR_EXP 94
89646: PUSH
89647: LD_INT 99
89649: ST_TO_ADDR
// us_artillery := 97 ;
89650: LD_ADDR_EXP 95
89654: PUSH
89655: LD_INT 97
89657: ST_TO_ADDR
// ar_bio_bomb := 91 ;
89658: LD_ADDR_EXP 96
89662: PUSH
89663: LD_INT 91
89665: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
89666: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
89667: LD_INT 0
89669: PPUSH
89670: PPUSH
89671: PPUSH
89672: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
89673: LD_VAR 0 1
89677: PPUSH
89678: CALL_OW 264
89682: PUSH
89683: LD_EXP 96
89687: EQUAL
89688: IFFALSE 89760
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
89690: LD_INT 68
89692: PPUSH
89693: LD_VAR 0 1
89697: PPUSH
89698: CALL_OW 255
89702: PPUSH
89703: CALL_OW 321
89707: PUSH
89708: LD_INT 2
89710: EQUAL
89711: IFFALSE 89723
// eff := 70 else
89713: LD_ADDR_VAR 0 6
89717: PUSH
89718: LD_INT 70
89720: ST_TO_ADDR
89721: GO 89731
// eff := 30 ;
89723: LD_ADDR_VAR 0 6
89727: PUSH
89728: LD_INT 30
89730: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
89731: LD_VAR 0 1
89735: PPUSH
89736: CALL_OW 250
89740: PPUSH
89741: LD_VAR 0 1
89745: PPUSH
89746: CALL_OW 251
89750: PPUSH
89751: LD_VAR 0 6
89755: PPUSH
89756: CALL_OW 495
// end ; end ;
89760: LD_VAR 0 4
89764: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
89765: LD_INT 0
89767: PPUSH
89768: PPUSH
89769: PPUSH
89770: PPUSH
89771: PPUSH
89772: PPUSH
// if cmd = 124 then
89773: LD_VAR 0 1
89777: PUSH
89778: LD_INT 124
89780: EQUAL
89781: IFFALSE 89987
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
89783: LD_ADDR_VAR 0 5
89787: PUSH
89788: LD_INT 2
89790: PUSH
89791: LD_INT 34
89793: PUSH
89794: LD_INT 53
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: PUSH
89801: LD_INT 34
89803: PUSH
89804: LD_INT 14
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: EMPTY
89812: LIST
89813: LIST
89814: LIST
89815: PPUSH
89816: CALL_OW 69
89820: ST_TO_ADDR
// if not tmp then
89821: LD_VAR 0 5
89825: NOT
89826: IFFALSE 89830
// exit ;
89828: GO 89987
// for i in tmp do
89830: LD_ADDR_VAR 0 3
89834: PUSH
89835: LD_VAR 0 5
89839: PUSH
89840: FOR_IN
89841: IFFALSE 89985
// begin taskList := GetTaskList ( i ) ;
89843: LD_ADDR_VAR 0 6
89847: PUSH
89848: LD_VAR 0 3
89852: PPUSH
89853: CALL_OW 437
89857: ST_TO_ADDR
// if not taskList then
89858: LD_VAR 0 6
89862: NOT
89863: IFFALSE 89867
// continue ;
89865: GO 89840
// for j = 1 to taskList do
89867: LD_ADDR_VAR 0 4
89871: PUSH
89872: DOUBLE
89873: LD_INT 1
89875: DEC
89876: ST_TO_ADDR
89877: LD_VAR 0 6
89881: PUSH
89882: FOR_TO
89883: IFFALSE 89981
// if taskList [ j ] [ 1 ] = | then
89885: LD_VAR 0 6
89889: PUSH
89890: LD_VAR 0 4
89894: ARRAY
89895: PUSH
89896: LD_INT 1
89898: ARRAY
89899: PUSH
89900: LD_STRING |
89902: EQUAL
89903: IFFALSE 89979
// begin _taskList := Delete ( taskList , 1 ) ;
89905: LD_ADDR_VAR 0 7
89909: PUSH
89910: LD_VAR 0 6
89914: PPUSH
89915: LD_INT 1
89917: PPUSH
89918: CALL_OW 3
89922: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
89923: LD_VAR 0 3
89927: PPUSH
89928: LD_VAR 0 7
89932: PPUSH
89933: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
89937: LD_VAR 0 3
89941: PPUSH
89942: LD_VAR 0 6
89946: PUSH
89947: LD_VAR 0 4
89951: ARRAY
89952: PUSH
89953: LD_INT 2
89955: ARRAY
89956: PPUSH
89957: LD_VAR 0 6
89961: PUSH
89962: LD_VAR 0 4
89966: ARRAY
89967: PUSH
89968: LD_INT 3
89970: ARRAY
89971: PPUSH
89972: LD_INT 8
89974: PPUSH
89975: CALL 89992 0 4
// end ;
89979: GO 89882
89981: POP
89982: POP
// end ;
89983: GO 89840
89985: POP
89986: POP
// end ; end ;
89987: LD_VAR 0 2
89991: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
89992: LD_INT 0
89994: PPUSH
89995: PPUSH
89996: PPUSH
89997: PPUSH
89998: PPUSH
89999: PPUSH
90000: PPUSH
90001: PPUSH
90002: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
90003: LD_VAR 0 1
90007: NOT
90008: PUSH
90009: LD_VAR 0 2
90013: PPUSH
90014: LD_VAR 0 3
90018: PPUSH
90019: CALL_OW 488
90023: NOT
90024: OR
90025: PUSH
90026: LD_VAR 0 4
90030: NOT
90031: OR
90032: IFFALSE 90036
// exit ;
90034: GO 90376
// list := [ ] ;
90036: LD_ADDR_VAR 0 13
90040: PUSH
90041: EMPTY
90042: ST_TO_ADDR
// if x - r < 0 then
90043: LD_VAR 0 2
90047: PUSH
90048: LD_VAR 0 4
90052: MINUS
90053: PUSH
90054: LD_INT 0
90056: LESS
90057: IFFALSE 90069
// min_x := 0 else
90059: LD_ADDR_VAR 0 7
90063: PUSH
90064: LD_INT 0
90066: ST_TO_ADDR
90067: GO 90085
// min_x := x - r ;
90069: LD_ADDR_VAR 0 7
90073: PUSH
90074: LD_VAR 0 2
90078: PUSH
90079: LD_VAR 0 4
90083: MINUS
90084: ST_TO_ADDR
// if y - r < 0 then
90085: LD_VAR 0 3
90089: PUSH
90090: LD_VAR 0 4
90094: MINUS
90095: PUSH
90096: LD_INT 0
90098: LESS
90099: IFFALSE 90111
// min_y := 0 else
90101: LD_ADDR_VAR 0 8
90105: PUSH
90106: LD_INT 0
90108: ST_TO_ADDR
90109: GO 90127
// min_y := y - r ;
90111: LD_ADDR_VAR 0 8
90115: PUSH
90116: LD_VAR 0 3
90120: PUSH
90121: LD_VAR 0 4
90125: MINUS
90126: ST_TO_ADDR
// max_x := x + r ;
90127: LD_ADDR_VAR 0 9
90131: PUSH
90132: LD_VAR 0 2
90136: PUSH
90137: LD_VAR 0 4
90141: PLUS
90142: ST_TO_ADDR
// max_y := y + r ;
90143: LD_ADDR_VAR 0 10
90147: PUSH
90148: LD_VAR 0 3
90152: PUSH
90153: LD_VAR 0 4
90157: PLUS
90158: ST_TO_ADDR
// for _x = min_x to max_x do
90159: LD_ADDR_VAR 0 11
90163: PUSH
90164: DOUBLE
90165: LD_VAR 0 7
90169: DEC
90170: ST_TO_ADDR
90171: LD_VAR 0 9
90175: PUSH
90176: FOR_TO
90177: IFFALSE 90294
// for _y = min_y to max_y do
90179: LD_ADDR_VAR 0 12
90183: PUSH
90184: DOUBLE
90185: LD_VAR 0 8
90189: DEC
90190: ST_TO_ADDR
90191: LD_VAR 0 10
90195: PUSH
90196: FOR_TO
90197: IFFALSE 90290
// begin if not ValidHex ( _x , _y ) then
90199: LD_VAR 0 11
90203: PPUSH
90204: LD_VAR 0 12
90208: PPUSH
90209: CALL_OW 488
90213: NOT
90214: IFFALSE 90218
// continue ;
90216: GO 90196
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
90218: LD_VAR 0 11
90222: PPUSH
90223: LD_VAR 0 12
90227: PPUSH
90228: CALL_OW 351
90232: PUSH
90233: LD_VAR 0 11
90237: PPUSH
90238: LD_VAR 0 12
90242: PPUSH
90243: CALL_OW 554
90247: AND
90248: IFFALSE 90288
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
90250: LD_ADDR_VAR 0 13
90254: PUSH
90255: LD_VAR 0 13
90259: PPUSH
90260: LD_VAR 0 13
90264: PUSH
90265: LD_INT 1
90267: PLUS
90268: PPUSH
90269: LD_VAR 0 11
90273: PUSH
90274: LD_VAR 0 12
90278: PUSH
90279: EMPTY
90280: LIST
90281: LIST
90282: PPUSH
90283: CALL_OW 2
90287: ST_TO_ADDR
// end ;
90288: GO 90196
90290: POP
90291: POP
90292: GO 90176
90294: POP
90295: POP
// if not list then
90296: LD_VAR 0 13
90300: NOT
90301: IFFALSE 90305
// exit ;
90303: GO 90376
// for i in list do
90305: LD_ADDR_VAR 0 6
90309: PUSH
90310: LD_VAR 0 13
90314: PUSH
90315: FOR_IN
90316: IFFALSE 90374
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
90318: LD_VAR 0 1
90322: PPUSH
90323: LD_STRING M
90325: PUSH
90326: LD_VAR 0 6
90330: PUSH
90331: LD_INT 1
90333: ARRAY
90334: PUSH
90335: LD_VAR 0 6
90339: PUSH
90340: LD_INT 2
90342: ARRAY
90343: PUSH
90344: LD_INT 0
90346: PUSH
90347: LD_INT 0
90349: PUSH
90350: LD_INT 0
90352: PUSH
90353: LD_INT 0
90355: PUSH
90356: EMPTY
90357: LIST
90358: LIST
90359: LIST
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: PUSH
90365: EMPTY
90366: LIST
90367: PPUSH
90368: CALL_OW 447
90372: GO 90315
90374: POP
90375: POP
// end ;
90376: LD_VAR 0 5
90380: RET
