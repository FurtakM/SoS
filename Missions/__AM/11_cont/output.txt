// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17362 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 80000 0 9
// PrepareAmerican ;
  77: CALL 562 0 0
// PrepareArabian ;
  81: CALL 2234 0 0
// MC_Start ( ) ;
  85: CALL 19474 0 0
// Action ;
  89: CALL 8072 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: EMPTY
 227: LIST
 228: LIST
 229: LIST
 230: PUSH
 231: LD_OWVAR 67
 235: ARRAY
 236: ST_TO_ADDR
// powell_warn := false ;
 237: LD_ADDR_EXP 16
 241: PUSH
 242: LD_INT 0
 244: ST_TO_ADDR
// loses_counter := 0 ;
 245: LD_ADDR_EXP 17
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// artifact_oncargo := false ;
 253: LD_ADDR_EXP 14
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 261: LD_ADDR_EXP 18
 265: PUSH
 266: LD_STRING 10_GensherEscape_1
 268: PPUSH
 269: LD_EXP 1
 273: PPUSH
 274: CALL_OW 30
 278: ST_TO_ADDR
// can_kamikazed := false ;
 279: LD_ADDR_EXP 10
 283: PUSH
 284: LD_INT 0
 286: ST_TO_ADDR
// am_veh_consturcted := false ;
 287: LD_ADDR_EXP 20
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// end ;
 295: LD_VAR 0 1
 299: RET
// export function CustomInitMacro ; var i ; begin
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 304: LD_ADDR_EXP 74
 308: PUSH
 309: LD_INT 20
 311: PUSH
 312: LD_INT 21
 314: PUSH
 315: LD_INT 22
 317: PUSH
 318: EMPTY
 319: LIST
 320: LIST
 321: LIST
 322: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 323: LD_ADDR_EXP 75
 327: PUSH
 328: LD_INT 28
 330: PUSH
 331: LD_INT 24
 333: PUSH
 334: LD_INT 26
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 4
 347: PUSH
 348: LD_INT 6
 350: PUSH
 351: LD_INT 9
 353: PUSH
 354: EMPTY
 355: LIST
 356: LIST
 357: LIST
 358: PUSH
 359: LD_OWVAR 67
 363: ARRAY
 364: PPUSH
 365: LD_INT 3
 367: PPUSH
 368: CALL 40675 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 372: LD_INT 2
 374: PPUSH
 375: LD_INT 4
 377: PUSH
 378: LD_INT 6
 380: PUSH
 381: LD_INT 9
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_OWVAR 67
 393: ARRAY
 394: PPUSH
 395: LD_INT 2
 397: PPUSH
 398: CALL 40675 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield3_left ) ;
 402: LD_INT 3
 404: PPUSH
 405: LD_INT 4
 407: PUSH
 408: LD_INT 6
 410: PUSH
 411: LD_INT 9
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: PUSH
 419: LD_OWVAR 67
 423: ARRAY
 424: PPUSH
 425: LD_INT 1
 427: PPUSH
 428: CALL 40675 0 3
// for i = 1 to mc_bases do
 432: LD_ADDR_VAR 0 2
 436: PUSH
 437: DOUBLE
 438: LD_INT 1
 440: DEC
 441: ST_TO_ADDR
 442: LD_EXP 50
 446: PUSH
 447: FOR_TO
 448: IFFALSE 472
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 450: LD_VAR 0 2
 454: PPUSH
 455: LD_EXP 43
 459: PUSH
 460: LD_VAR 0 2
 464: ARRAY
 465: PPUSH
 466: CALL 41101 0 2
 470: GO 447
 472: POP
 473: POP
// end ;
 474: LD_VAR 0 1
 478: RET
// function Debuger ; var i ; begin
 479: LD_INT 0
 481: PPUSH
 482: PPUSH
// if not debug then
 483: LD_EXP 1
 487: NOT
 488: IFFALSE 492
// exit ;
 490: GO 528
// game_speed := 5 ;
 492: LD_ADDR_OWVAR 65
 496: PUSH
 497: LD_INT 5
 499: ST_TO_ADDR
// uc_side := 1 ;
 500: LD_ADDR_OWVAR 20
 504: PUSH
 505: LD_INT 1
 507: ST_TO_ADDR
// uc_nation := 1 ;
 508: LD_ADDR_OWVAR 21
 512: PUSH
 513: LD_INT 1
 515: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 516: LD_EXP 36
 520: PPUSH
 521: LD_INT 1
 523: PPUSH
 524: CALL_OW 235
// end ;
 528: LD_VAR 0 1
 532: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 533: LD_INT 94
 535: PPUSH
 536: CALL_OW 301
 540: PUSH
 541: LD_INT 45
 543: PPUSH
 544: CALL_OW 302
 548: AND
 549: IFFALSE 561
 551: GO 553
 553: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 554: LD_STRING ACH_EAST
 556: PPUSH
 557: CALL_OW 543
 561: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 562: LD_INT 0
 564: PPUSH
 565: PPUSH
 566: PPUSH
 567: PPUSH
 568: PPUSH
 569: PPUSH
 570: PPUSH
 571: PPUSH
// uc_side := 4 ;
 572: LD_ADDR_OWVAR 20
 576: PUSH
 577: LD_INT 4
 579: ST_TO_ADDR
// uc_nation := 1 ;
 580: LD_ADDR_OWVAR 21
 584: PUSH
 585: LD_INT 1
 587: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 588: LD_ADDR_EXP 30
 592: PUSH
 593: LD_STRING Powell
 595: PPUSH
 596: LD_INT 0
 598: PPUSH
 599: LD_STRING 
 601: PPUSH
 602: CALL 47385 0 3
 606: ST_TO_ADDR
// uc_side := 1 ;
 607: LD_ADDR_OWVAR 20
 611: PUSH
 612: LD_INT 1
 614: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 615: LD_ADDR_EXP 21
 619: PUSH
 620: LD_STRING JMM
 622: PPUSH
 623: LD_EXP 1
 627: NOT
 628: PPUSH
 629: LD_EXP 4
 633: PPUSH
 634: CALL 47385 0 3
 638: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 639: LD_EXP 21
 643: PPUSH
 644: CALL_OW 257
 648: PUSH
 649: LD_INT 4
 651: GREATER
 652: IFFALSE 666
// SetClass ( JMM , 1 ) ;
 654: LD_EXP 21
 658: PPUSH
 659: LD_INT 1
 661: PPUSH
 662: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 666: LD_ADDR_EXP 22
 670: PUSH
 671: LD_STRING Lisa
 673: PPUSH
 674: LD_EXP 1
 678: NOT
 679: PPUSH
 680: LD_EXP 4
 684: PPUSH
 685: CALL 47385 0 3
 689: ST_TO_ADDR
// if not Lisa then
 690: LD_EXP 22
 694: NOT
 695: IFFALSE 710
// Lisa := CreateCharacter ( 10_Lisa ) ;
 697: LD_ADDR_EXP 22
 701: PUSH
 702: LD_STRING 10_Lisa
 704: PPUSH
 705: CALL_OW 34
 709: ST_TO_ADDR
// if not Lisa then
 710: LD_EXP 22
 714: NOT
 715: IFFALSE 730
// Lisa := CreateCharacter ( 09_Lisa ) ;
 717: LD_ADDR_EXP 22
 721: PUSH
 722: LD_STRING 09_Lisa
 724: PPUSH
 725: CALL_OW 34
 729: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 730: LD_ADDR_EXP 31
 734: PUSH
 735: LD_STRING Cornel
 737: PPUSH
 738: LD_EXP 1
 742: NOT
 743: PPUSH
 744: LD_EXP 4
 748: PPUSH
 749: CALL 47385 0 3
 753: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 754: LD_ADDR_EXP 23
 758: PUSH
 759: LD_STRING Donaldson
 761: PPUSH
 762: LD_EXP 1
 766: NOT
 767: PPUSH
 768: LD_EXP 4
 772: PPUSH
 773: CALL 47385 0 3
 777: ST_TO_ADDR
// if not Donaldson then
 778: LD_EXP 23
 782: NOT
 783: IFFALSE 798
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 785: LD_ADDR_EXP 23
 789: PUSH
 790: LD_STRING 10_Donaldson
 792: PPUSH
 793: CALL_OW 34
 797: ST_TO_ADDR
// if not Donaldson then
 798: LD_EXP 23
 802: NOT
 803: IFFALSE 818
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 805: LD_ADDR_EXP 23
 809: PUSH
 810: LD_STRING 09_Donaldson
 812: PPUSH
 813: CALL_OW 34
 817: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 818: LD_ADDR_EXP 24
 822: PUSH
 823: LD_STRING Bobby
 825: PPUSH
 826: LD_EXP 1
 830: NOT
 831: PPUSH
 832: LD_EXP 4
 836: PPUSH
 837: CALL 47385 0 3
 841: ST_TO_ADDR
// if not Bobby then
 842: LD_EXP 24
 846: NOT
 847: IFFALSE 862
// Bobby := CreateCharacter ( 10_Bobby ) ;
 849: LD_ADDR_EXP 24
 853: PUSH
 854: LD_STRING 10_Bobby
 856: PPUSH
 857: CALL_OW 34
 861: ST_TO_ADDR
// if not Bobby then
 862: LD_EXP 24
 866: NOT
 867: IFFALSE 882
// Bobby := CreateCharacter ( 09_Bobby ) ;
 869: LD_ADDR_EXP 24
 873: PUSH
 874: LD_STRING 09_Bobby
 876: PPUSH
 877: CALL_OW 34
 881: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 882: LD_ADDR_EXP 25
 886: PUSH
 887: LD_STRING Cyrus
 889: PPUSH
 890: LD_EXP 1
 894: NOT
 895: PPUSH
 896: LD_EXP 4
 900: PPUSH
 901: CALL 47385 0 3
 905: ST_TO_ADDR
// if not Cyrus then
 906: LD_EXP 25
 910: NOT
 911: IFFALSE 926
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 913: LD_ADDR_EXP 25
 917: PUSH
 918: LD_STRING 10_Cyrus
 920: PPUSH
 921: CALL_OW 34
 925: ST_TO_ADDR
// if not Cyrus then
 926: LD_EXP 25
 930: NOT
 931: IFFALSE 946
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 933: LD_ADDR_EXP 25
 937: PUSH
 938: LD_STRING 09_Cyrus
 940: PPUSH
 941: CALL_OW 34
 945: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 946: LD_ADDR_EXP 26
 950: PUSH
 951: LD_STRING Denis
 953: PPUSH
 954: LD_EXP 1
 958: NOT
 959: PPUSH
 960: LD_EXP 4
 964: PPUSH
 965: CALL 47385 0 3
 969: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 970: LD_ADDR_EXP 27
 974: PUSH
 975: LD_STRING Brown
 977: PPUSH
 978: LD_EXP 1
 982: NOT
 983: PPUSH
 984: LD_EXP 4
 988: PPUSH
 989: CALL 47385 0 3
 993: ST_TO_ADDR
// if not Brown then
 994: LD_EXP 27
 998: NOT
 999: IFFALSE 1014
// Brown := CreateCharacter ( 10_Brown ) ;
1001: LD_ADDR_EXP 27
1005: PUSH
1006: LD_STRING 10_Brown
1008: PPUSH
1009: CALL_OW 34
1013: ST_TO_ADDR
// if not Brown then
1014: LD_EXP 27
1018: NOT
1019: IFFALSE 1034
// Brown := CreateCharacter ( 08_Brown ) ;
1021: LD_ADDR_EXP 27
1025: PUSH
1026: LD_STRING 08_Brown
1028: PPUSH
1029: CALL_OW 34
1033: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1034: LD_ADDR_EXP 28
1038: PUSH
1039: LD_STRING Gladstone
1041: PPUSH
1042: LD_EXP 1
1046: NOT
1047: PPUSH
1048: LD_EXP 4
1052: PPUSH
1053: CALL 47385 0 3
1057: ST_TO_ADDR
// if not Gladstone then
1058: LD_EXP 28
1062: NOT
1063: IFFALSE 1078
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1065: LD_ADDR_EXP 28
1069: PUSH
1070: LD_STRING 10_Gladstone
1072: PPUSH
1073: CALL_OW 34
1077: ST_TO_ADDR
// if not Gladstone then
1078: LD_EXP 28
1082: NOT
1083: IFFALSE 1098
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1085: LD_ADDR_EXP 28
1089: PUSH
1090: LD_STRING 08_Gladstone
1092: PPUSH
1093: CALL_OW 34
1097: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1098: LD_ADDR_EXP 29
1102: PUSH
1103: LD_STRING Houten
1105: PPUSH
1106: LD_EXP 1
1110: NOT
1111: PPUSH
1112: LD_EXP 4
1116: PPUSH
1117: CALL 47385 0 3
1121: ST_TO_ADDR
// if not Houten then
1122: LD_EXP 29
1126: NOT
1127: IFFALSE 1142
// Houten := CreateCharacter ( 10_Houten ) ;
1129: LD_ADDR_EXP 29
1133: PUSH
1134: LD_STRING 10_Houten
1136: PPUSH
1137: CALL_OW 34
1141: ST_TO_ADDR
// if not Houten then
1142: LD_EXP 29
1146: NOT
1147: IFFALSE 1162
// Houten := CreateCharacter ( 09_Houten ) ;
1149: LD_ADDR_EXP 29
1153: PUSH
1154: LD_STRING 09_Houten
1156: PPUSH
1157: CALL_OW 34
1161: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1162: LD_ADDR_EXP 31
1166: PUSH
1167: LD_STRING Cornell
1169: PPUSH
1170: LD_EXP 1
1174: NOT
1175: PPUSH
1176: LD_EXP 4
1180: PPUSH
1181: CALL 47385 0 3
1185: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1186: LD_ADDR_EXP 32
1190: PUSH
1191: LD_STRING Gary
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_EXP 4
1204: PPUSH
1205: CALL 47385 0 3
1209: ST_TO_ADDR
// if not Gary then
1210: LD_EXP 32
1214: NOT
1215: IFFALSE 1230
// Gary := CreateCharacter ( 10_Gary ) ;
1217: LD_ADDR_EXP 32
1221: PUSH
1222: LD_STRING 10_Gary
1224: PPUSH
1225: CALL_OW 34
1229: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1230: LD_ADDR_EXP 33
1234: PUSH
1235: LD_STRING Frank
1237: PPUSH
1238: LD_EXP 1
1242: NOT
1243: PPUSH
1244: LD_EXP 4
1248: PPUSH
1249: CALL 47385 0 3
1253: ST_TO_ADDR
// if not Frank then
1254: LD_EXP 33
1258: NOT
1259: IFFALSE 1274
// Frank := CreateCharacter ( 08_Frank ) ;
1261: LD_ADDR_EXP 33
1265: PUSH
1266: LD_STRING 08_Frank
1268: PPUSH
1269: CALL_OW 34
1273: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1274: LD_ADDR_EXP 34
1278: PUSH
1279: LD_STRING Kikuchi
1281: PPUSH
1282: LD_EXP 1
1286: NOT
1287: PPUSH
1288: LD_EXP 4
1292: PPUSH
1293: CALL 47385 0 3
1297: ST_TO_ADDR
// if not Kikuchi then
1298: LD_EXP 34
1302: NOT
1303: IFFALSE 1318
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1305: LD_ADDR_EXP 34
1309: PUSH
1310: LD_STRING 08_Kikuchi
1312: PPUSH
1313: CALL_OW 34
1317: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1318: LD_ADDR_VAR 0 5
1322: PUSH
1323: LD_EXP 22
1327: PUSH
1328: LD_EXP 23
1332: PUSH
1333: LD_EXP 24
1337: PUSH
1338: LD_EXP 25
1342: PUSH
1343: LD_EXP 26
1347: PUSH
1348: LD_EXP 27
1352: PUSH
1353: LD_EXP 28
1357: PUSH
1358: LD_EXP 29
1362: PUSH
1363: LD_EXP 31
1367: PUSH
1368: LD_EXP 32
1372: PUSH
1373: LD_EXP 33
1377: PUSH
1378: LD_EXP 34
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: ST_TO_ADDR
// tmp := tmp diff 0 ;
1397: LD_ADDR_VAR 0 5
1401: PUSH
1402: LD_VAR 0 5
1406: PUSH
1407: LD_INT 0
1409: DIFF
1410: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1411: LD_ADDR_VAR 0 5
1415: PUSH
1416: LD_VAR 0 5
1420: PUSH
1421: LD_STRING 10_lock
1423: PPUSH
1424: CALL_OW 31
1428: UNION
1429: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1430: LD_ADDR_VAR 0 5
1434: PUSH
1435: LD_VAR 0 5
1439: PUSH
1440: LD_STRING 10c_lock
1442: PPUSH
1443: CALL_OW 31
1447: UNION
1448: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1449: LD_STRING 10_lock
1451: PPUSH
1452: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1456: LD_STRING 10c_lock
1458: PPUSH
1459: CALL_OW 40
// for i in tmp do
1463: LD_ADDR_VAR 0 2
1467: PUSH
1468: LD_VAR 0 5
1472: PUSH
1473: FOR_IN
1474: IFFALSE 1512
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1476: LD_VAR 0 2
1480: PPUSH
1481: CALL_OW 257
1485: PUSH
1486: LD_INT 8
1488: PUSH
1489: LD_INT 2
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: IN
1496: IFFALSE 1510
// SetClass ( i , class_soldier ) ;
1498: LD_VAR 0 2
1502: PPUSH
1503: LD_INT 1
1505: PPUSH
1506: CALL_OW 336
1510: GO 1473
1512: POP
1513: POP
// if tmp < 12 then
1514: LD_VAR 0 5
1518: PUSH
1519: LD_INT 12
1521: LESS
1522: IFFALSE 1616
// begin k := 16 - tmp ;
1524: LD_ADDR_VAR 0 3
1528: PUSH
1529: LD_INT 16
1531: PUSH
1532: LD_VAR 0 5
1536: MINUS
1537: ST_TO_ADDR
// for i = 1 to k do
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: DOUBLE
1544: LD_INT 1
1546: DEC
1547: ST_TO_ADDR
1548: LD_VAR 0 3
1552: PUSH
1553: FOR_TO
1554: IFFALSE 1614
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1556: LD_INT 0
1558: PPUSH
1559: LD_INT 1
1561: PUSH
1562: LD_INT 1
1564: PUSH
1565: LD_INT 3
1567: PUSH
1568: LD_INT 4
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: LIST
1575: LIST
1576: PUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 4
1582: PPUSH
1583: CALL_OW 12
1587: ARRAY
1588: PPUSH
1589: LD_INT 6
1591: PPUSH
1592: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1596: LD_ADDR_VAR 0 5
1600: PUSH
1601: LD_VAR 0 5
1605: PUSH
1606: CALL_OW 44
1610: ADD
1611: ST_TO_ADDR
// end ;
1612: GO 1553
1614: POP
1615: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1616: LD_ADDR_EXP 19
1620: PUSH
1621: LD_STRING 1
1623: PPUSH
1624: LD_INT 12
1626: PPUSH
1627: LD_INT 12
1629: PPUSH
1630: LD_INT -5
1632: PUSH
1633: LD_EXP 21
1637: PUSH
1638: LD_INT -2
1640: PUSH
1641: LD_INT -3
1643: PUSH
1644: LD_INT -5
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: PUSH
1654: LD_VAR 0 5
1658: ADD
1659: PUSH
1660: LD_INT -6
1662: PUSH
1663: LD_INT -4
1665: PUSH
1666: LD_EXP 30
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: LIST
1675: ADD
1676: PPUSH
1677: LD_INT 1
1679: PUSH
1680: LD_INT 4
1682: PUSH
1683: EMPTY
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 3
1689: PUSH
1690: LD_INT 0
1692: PUSH
1693: LD_INT 5
1695: PUSH
1696: EMPTY
1697: LIST
1698: LIST
1699: LIST
1700: PUSH
1701: LD_INT 4
1703: PUSH
1704: LD_INT 0
1706: PUSH
1707: LD_INT 3
1709: PUSH
1710: EMPTY
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 5
1717: PUSH
1718: LD_INT 0
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: PPUSH
1735: CALL_OW 42
1739: ST_TO_ADDR
// others := tmp diff selected ;
1740: LD_ADDR_VAR 0 8
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 19
1754: DIFF
1755: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1756: LD_ADDR_VAR 0 8
1760: PUSH
1761: LD_VAR 0 8
1765: PUSH
1766: LD_EXP 22
1770: PUSH
1771: LD_EXP 23
1775: PUSH
1776: LD_EXP 24
1780: PUSH
1781: LD_EXP 25
1785: PUSH
1786: LD_EXP 26
1790: PUSH
1791: LD_EXP 27
1795: PUSH
1796: LD_EXP 28
1800: PUSH
1801: LD_EXP 29
1805: PUSH
1806: LD_EXP 31
1810: PUSH
1811: LD_EXP 32
1815: PUSH
1816: LD_EXP 33
1820: PUSH
1821: LD_EXP 34
1825: PUSH
1826: EMPTY
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: DIFF
1840: ST_TO_ADDR
// if others then
1841: LD_VAR 0 8
1845: IFFALSE 1859
// SaveCharacters ( others , 11_others ) ;
1847: LD_VAR 0 8
1851: PPUSH
1852: LD_STRING 11_others
1854: PPUSH
1855: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1859: LD_ADDR_VAR 0 6
1863: PUSH
1864: LD_INT 3
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 1
1872: PUSH
1873: LD_INT 4
1875: PUSH
1876: EMPTY
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: PUSH
1882: LD_INT 2
1884: PUSH
1885: LD_INT 2
1887: PUSH
1888: LD_INT 1
1890: PUSH
1891: LD_INT 5
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: PUSH
1900: LD_INT 4
1902: PUSH
1903: LD_INT 1
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: LD_INT 5
1911: PUSH
1912: EMPTY
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: PUSH
1918: LD_INT 2
1920: PUSH
1921: LD_INT 1
1923: PUSH
1924: LD_INT 1
1926: PUSH
1927: LD_INT 7
1929: PUSH
1930: EMPTY
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: PUSH
1936: LD_INT 3
1938: PUSH
1939: LD_INT 2
1941: PUSH
1942: LD_INT 1
1944: PUSH
1945: LD_INT 7
1947: PUSH
1948: EMPTY
1949: LIST
1950: LIST
1951: LIST
1952: LIST
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: LIST
1960: ST_TO_ADDR
// for i in JMM ^ selected do
1961: LD_ADDR_VAR 0 2
1965: PUSH
1966: LD_EXP 21
1970: PUSH
1971: LD_EXP 19
1975: ADD
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2167
// begin if GetClass ( i ) = 3 then
1980: LD_VAR 0 2
1984: PPUSH
1985: CALL_OW 257
1989: PUSH
1990: LD_INT 3
1992: EQUAL
1993: IFFALSE 2150
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1995: LD_ADDR_OWVAR 37
1999: PUSH
2000: LD_VAR 0 6
2004: PUSH
2005: LD_INT 1
2007: ARRAY
2008: PUSH
2009: LD_INT 1
2011: ARRAY
2012: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2013: LD_ADDR_OWVAR 39
2017: PUSH
2018: LD_VAR 0 6
2022: PUSH
2023: LD_INT 1
2025: ARRAY
2026: PUSH
2027: LD_INT 2
2029: ARRAY
2030: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2031: LD_ADDR_OWVAR 38
2035: PUSH
2036: LD_VAR 0 6
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PUSH
2045: LD_INT 3
2047: ARRAY
2048: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2049: LD_ADDR_OWVAR 40
2053: PUSH
2054: LD_VAR 0 6
2058: PUSH
2059: LD_INT 1
2061: ARRAY
2062: PUSH
2063: LD_INT 4
2065: ARRAY
2066: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2067: LD_ADDR_VAR 0 6
2071: PUSH
2072: LD_VAR 0 6
2076: PPUSH
2077: LD_INT 1
2079: PPUSH
2080: CALL_OW 3
2084: ST_TO_ADDR
// veh := CreateVehicle ;
2085: LD_ADDR_VAR 0 7
2089: PUSH
2090: CALL_OW 45
2094: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2095: LD_VAR 0 7
2099: PPUSH
2100: LD_INT 8
2102: PPUSH
2103: LD_INT 0
2105: PPUSH
2106: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2110: LD_VAR 0 2
2114: PPUSH
2115: LD_VAR 0 7
2119: PPUSH
2120: CALL_OW 52
// if i = JMM then
2124: LD_VAR 0 2
2128: PUSH
2129: LD_EXP 21
2133: EQUAL
2134: IFFALSE 2148
// SetMark ( veh , 1 ) ;
2136: LD_VAR 0 7
2140: PPUSH
2141: LD_INT 1
2143: PPUSH
2144: CALL_OW 242
// end else
2148: GO 2165
// PlaceUnitArea ( i , am_hum_start , false ) ;
2150: LD_VAR 0 2
2154: PPUSH
2155: LD_INT 9
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: CALL_OW 49
// end ;
2165: GO 1977
2167: POP
2168: POP
// vc_chassis := us_medium_tracked ;
2169: LD_ADDR_OWVAR 37
2173: PUSH
2174: LD_INT 3
2176: ST_TO_ADDR
// vc_engine := engine_solar ;
2177: LD_ADDR_OWVAR 39
2181: PUSH
2182: LD_INT 2
2184: ST_TO_ADDR
// vc_control := control_computer ;
2185: LD_ADDR_OWVAR 38
2189: PUSH
2190: LD_INT 3
2192: ST_TO_ADDR
// vc_weapon := us_radar ;
2193: LD_ADDR_OWVAR 40
2197: PUSH
2198: LD_INT 11
2200: ST_TO_ADDR
// veh := CreateVehicle ;
2201: LD_ADDR_VAR 0 7
2205: PUSH
2206: CALL_OW 45
2210: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2211: LD_VAR 0 7
2215: PPUSH
2216: LD_INT 87
2218: PPUSH
2219: LD_INT 142
2221: PPUSH
2222: LD_INT 0
2224: PPUSH
2225: CALL_OW 48
// end ; end_of_file
2229: LD_VAR 0 1
2233: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2234: LD_INT 0
2236: PPUSH
2237: PPUSH
2238: PPUSH
2239: PPUSH
2240: PPUSH
2241: PPUSH
// if Difficulty = 1 then
2242: LD_OWVAR 67
2246: PUSH
2247: LD_INT 1
2249: EQUAL
2250: IFFALSE 2347
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2252: LD_ADDR_VAR 0 6
2256: PUSH
2257: LD_INT 129
2259: PUSH
2260: LD_INT 45
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: LD_INT 143
2269: PUSH
2270: LD_INT 58
2272: PUSH
2273: EMPTY
2274: LIST
2275: LIST
2276: PUSH
2277: LD_INT 184
2279: PUSH
2280: LD_INT 113
2282: PUSH
2283: EMPTY
2284: LIST
2285: LIST
2286: PUSH
2287: LD_INT 163
2289: PUSH
2290: LD_INT 107
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: EMPTY
2298: LIST
2299: LIST
2300: LIST
2301: LIST
2302: ST_TO_ADDR
// for i in tmp do
2303: LD_ADDR_VAR 0 2
2307: PUSH
2308: LD_VAR 0 6
2312: PUSH
2313: FOR_IN
2314: IFFALSE 2345
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2316: LD_VAR 0 2
2320: PUSH
2321: LD_INT 1
2323: ARRAY
2324: PPUSH
2325: LD_VAR 0 2
2329: PUSH
2330: LD_INT 2
2332: ARRAY
2333: PPUSH
2334: CALL_OW 428
2338: PPUSH
2339: CALL_OW 64
2343: GO 2313
2345: POP
2346: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2347: LD_ADDR_VAR 0 2
2351: PUSH
2352: LD_INT 21
2354: PUSH
2355: LD_INT 3
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PPUSH
2362: CALL_OW 69
2366: PUSH
2367: FOR_IN
2368: IFFALSE 2401
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
2370: LD_VAR 0 2
2374: PPUSH
2375: LD_INT 5
2377: PUSH
2378: LD_INT 6
2380: PUSH
2381: LD_INT 7
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: LIST
2388: PUSH
2389: LD_OWVAR 67
2393: ARRAY
2394: PPUSH
2395: CALL_OW 241
2399: GO 2367
2401: POP
2402: POP
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2403: LD_ADDR_VAR 0 5
2407: PUSH
2408: LD_INT 5
2410: PUSH
2411: LD_INT 6
2413: PUSH
2414: LD_INT 7
2416: PUSH
2417: EMPTY
2418: LIST
2419: LIST
2420: LIST
2421: PUSH
2422: LD_OWVAR 67
2426: ARRAY
2427: ST_TO_ADDR
// uc_side := 2 ;
2428: LD_ADDR_OWVAR 20
2432: PUSH
2433: LD_INT 2
2435: ST_TO_ADDR
// uc_nation := 2 ;
2436: LD_ADDR_OWVAR 21
2440: PUSH
2441: LD_INT 2
2443: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2444: LD_ADDR_OWVAR 37
2448: PUSH
2449: LD_INT 14
2451: ST_TO_ADDR
// vc_engine := engine_siberite ;
2452: LD_ADDR_OWVAR 39
2456: PUSH
2457: LD_INT 3
2459: ST_TO_ADDR
// vc_control := control_manual ;
2460: LD_ADDR_OWVAR 38
2464: PUSH
2465: LD_INT 1
2467: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2468: LD_ADDR_OWVAR 40
2472: PUSH
2473: LD_INT 31
2475: ST_TO_ADDR
// for i = 1 to 3 do
2476: LD_ADDR_VAR 0 2
2480: PUSH
2481: DOUBLE
2482: LD_INT 1
2484: DEC
2485: ST_TO_ADDR
2486: LD_INT 3
2488: PUSH
2489: FOR_TO
2490: IFFALSE 2574
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2492: LD_INT 0
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: LD_VAR 0 5
2502: PPUSH
2503: CALL_OW 380
// un := CreateVehicle ;
2507: LD_ADDR_VAR 0 4
2511: PUSH
2512: CALL_OW 45
2516: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2517: LD_VAR 0 4
2521: PPUSH
2522: LD_INT 0
2524: PPUSH
2525: LD_INT 5
2527: PPUSH
2528: CALL_OW 12
2532: PPUSH
2533: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2537: LD_VAR 0 4
2541: PPUSH
2542: LD_INT 156
2544: PPUSH
2545: LD_INT 15
2547: PPUSH
2548: LD_INT 6
2550: PPUSH
2551: LD_INT 0
2553: PPUSH
2554: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2558: CALL_OW 44
2562: PPUSH
2563: LD_VAR 0 4
2567: PPUSH
2568: CALL_OW 52
// end ;
2572: GO 2489
2574: POP
2575: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 16 , [ 2 , 3 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2576: LD_ADDR_EXP 37
2580: PUSH
2581: LD_INT 94
2583: PPUSH
2584: LD_INT 28
2586: PPUSH
2587: LD_STRING dammam
2589: PPUSH
2590: LD_VAR 0 5
2594: PPUSH
2595: LD_INT 10000
2597: PUSH
2598: LD_INT 1000
2600: PUSH
2601: LD_INT 300
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: LIST
2608: PPUSH
2609: LD_INT 16
2611: PUSH
2612: LD_INT 2
2614: PUSH
2615: LD_INT 3
2617: PUSH
2618: LD_INT 4
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: LIST
2625: PUSH
2626: LD_OWVAR 67
2630: ARRAY
2631: PUSH
2632: LD_INT 1
2634: NEG
2635: PUSH
2636: LD_INT 4
2638: PUSH
2639: EMPTY
2640: LIST
2641: LIST
2642: LIST
2643: LIST
2644: PPUSH
2645: CALL 55618 0 6
2649: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ - 1 , [ 2 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
2650: LD_ADDR_EXP 37
2654: PUSH
2655: LD_EXP 37
2659: PUSH
2660: LD_INT 122
2662: PPUSH
2663: LD_INT 25
2665: PPUSH
2666: LD_STRING 
2668: PPUSH
2669: LD_VAR 0 5
2673: PPUSH
2674: LD_INT 500
2676: PUSH
2677: LD_INT 60
2679: PUSH
2680: LD_INT 0
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: LIST
2687: PPUSH
2688: LD_INT 1
2690: NEG
2691: PUSH
2692: LD_INT 2
2694: PUSH
2695: LD_INT 3
2697: PUSH
2698: LD_INT 4
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: LIST
2705: PUSH
2706: LD_OWVAR 67
2710: ARRAY
2711: PUSH
2712: LD_INT 2
2714: PUSH
2715: LD_INT 0
2717: PUSH
2718: EMPTY
2719: LIST
2720: LIST
2721: LIST
2722: LIST
2723: PPUSH
2724: CALL 55618 0 6
2728: UNION
2729: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 10 , 4 , 3 , 2 ] ) ;
2730: LD_ADDR_EXP 35
2734: PUSH
2735: LD_INT 45
2737: PPUSH
2738: LD_INT 24
2740: PPUSH
2741: LD_STRING jeddah
2743: PPUSH
2744: LD_VAR 0 5
2748: PPUSH
2749: LD_INT 700
2751: PUSH
2752: LD_INT 300
2754: PUSH
2755: LD_INT 10
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: LIST
2762: PPUSH
2763: LD_INT 10
2765: PUSH
2766: LD_INT 4
2768: PUSH
2769: LD_INT 3
2771: PUSH
2772: LD_INT 2
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: LIST
2779: LIST
2780: PPUSH
2781: CALL 55618 0 6
2785: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2786: LD_ADDR_EXP 36
2790: PUSH
2791: LD_INT 7
2793: PPUSH
2794: LD_INT 27
2796: PPUSH
2797: LD_STRING riyadh
2799: PPUSH
2800: LD_VAR 0 5
2804: PPUSH
2805: LD_INT 500
2807: PUSH
2808: LD_INT 60
2810: PUSH
2811: LD_INT 0
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: PPUSH
2819: LD_INT 4
2821: PUSH
2822: LD_INT 2
2824: PUSH
2825: LD_INT 3
2827: PUSH
2828: LD_INT 1
2830: PUSH
2831: EMPTY
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: PPUSH
2837: CALL 55618 0 6
2841: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 10 , 2 , 3 , 1 ] ) ;
2842: LD_ADDR_EXP 39
2846: PUSH
2847: LD_INT 204
2849: PPUSH
2850: LD_INT 26
2852: PPUSH
2853: LD_STRING 
2855: PPUSH
2856: LD_VAR 0 5
2860: PPUSH
2861: LD_INT 500
2863: PUSH
2864: LD_INT 50
2866: PUSH
2867: LD_INT 0
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: LIST
2874: PPUSH
2875: LD_INT 10
2877: PUSH
2878: LD_INT 2
2880: PUSH
2881: LD_INT 3
2883: PUSH
2884: LD_INT 1
2886: PUSH
2887: EMPTY
2888: LIST
2889: LIST
2890: LIST
2891: LIST
2892: PPUSH
2893: CALL 55618 0 6
2897: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2898: LD_ADDR_EXP 50
2902: PUSH
2903: LD_EXP 37
2907: PUSH
2908: LD_EXP 35
2912: PUSH
2913: LD_EXP 39
2917: PUSH
2918: EMPTY
2919: LIST
2920: LIST
2921: LIST
2922: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2923: LD_ADDR_VAR 0 2
2927: PUSH
2928: LD_INT 22
2930: PUSH
2931: LD_INT 2
2933: PUSH
2934: EMPTY
2935: LIST
2936: LIST
2937: PUSH
2938: LD_INT 30
2940: PUSH
2941: LD_INT 31
2943: PUSH
2944: EMPTY
2945: LIST
2946: LIST
2947: PUSH
2948: LD_INT 58
2950: PUSH
2951: EMPTY
2952: LIST
2953: PUSH
2954: EMPTY
2955: LIST
2956: LIST
2957: LIST
2958: PPUSH
2959: CALL_OW 69
2963: PUSH
2964: FOR_IN
2965: IFFALSE 3090
// begin if GetBase ( i ) then
2967: LD_VAR 0 2
2971: PPUSH
2972: CALL_OW 274
2976: IFFALSE 2980
// continue ;
2978: GO 2964
// d := GetDir ( i ) ;
2980: LD_ADDR_VAR 0 3
2984: PUSH
2985: LD_VAR 0 2
2989: PPUSH
2990: CALL_OW 254
2994: ST_TO_ADDR
// if d < 3 then
2995: LD_VAR 0 3
2999: PUSH
3000: LD_INT 3
3002: LESS
3003: IFFALSE 3021
// d := d + 3 else
3005: LD_ADDR_VAR 0 3
3009: PUSH
3010: LD_VAR 0 3
3014: PUSH
3015: LD_INT 3
3017: PLUS
3018: ST_TO_ADDR
3019: GO 3035
// d := d - 3 ;
3021: LD_ADDR_VAR 0 3
3025: PUSH
3026: LD_VAR 0 3
3030: PUSH
3031: LD_INT 3
3033: MINUS
3034: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3035: LD_INT 0
3037: PPUSH
3038: LD_INT 8
3040: PPUSH
3041: LD_VAR 0 5
3045: PPUSH
3046: CALL_OW 380
// un := CreateHuman ;
3050: LD_ADDR_VAR 0 4
3054: PUSH
3055: CALL_OW 44
3059: ST_TO_ADDR
// SetDir ( un , d ) ;
3060: LD_VAR 0 4
3064: PPUSH
3065: LD_VAR 0 3
3069: PPUSH
3070: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3074: LD_VAR 0 4
3078: PPUSH
3079: LD_VAR 0 2
3083: PPUSH
3084: CALL_OW 52
// end ;
3088: GO 2964
3090: POP
3091: POP
// if Difficulty > 1 then
3092: LD_OWVAR 67
3096: PUSH
3097: LD_INT 1
3099: GREATER
3100: IFFALSE 3471
// begin ar_kamikadze := [ ] ;
3102: LD_ADDR_EXP 42
3106: PUSH
3107: EMPTY
3108: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3109: LD_INT 0
3111: PPUSH
3112: LD_INT 1
3114: PPUSH
3115: LD_VAR 0 5
3119: PPUSH
3120: CALL_OW 380
// un := CreateHuman ;
3124: LD_ADDR_VAR 0 4
3128: PUSH
3129: CALL_OW 44
3133: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3134: LD_VAR 0 4
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3146: LD_VAR 0 4
3150: PPUSH
3151: LD_INT 23
3153: PPUSH
3154: LD_INT 44
3156: PPUSH
3157: LD_INT 0
3159: PPUSH
3160: CALL_OW 48
// ComCrawl ( un ) ;
3164: LD_VAR 0 4
3168: PPUSH
3169: CALL_OW 137
// un := CreateHuman ;
3173: LD_ADDR_VAR 0 4
3177: PUSH
3178: CALL_OW 44
3182: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3183: LD_VAR 0 4
3187: PPUSH
3188: LD_INT 3
3190: PPUSH
3191: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3195: LD_VAR 0 4
3199: PPUSH
3200: LD_INT 30
3202: PPUSH
3203: LD_INT 39
3205: PPUSH
3206: LD_INT 0
3208: PPUSH
3209: CALL_OW 48
// ComCrawl ( un ) ;
3213: LD_VAR 0 4
3217: PPUSH
3218: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3222: LD_INT 0
3224: PPUSH
3225: LD_INT 17
3227: PPUSH
3228: LD_VAR 0 5
3232: PPUSH
3233: CALL_OW 380
// un := CreateHuman ;
3237: LD_ADDR_VAR 0 4
3241: PUSH
3242: CALL_OW 44
3246: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3247: LD_VAR 0 4
3251: PPUSH
3252: LD_INT 3
3254: PPUSH
3255: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3259: LD_VAR 0 4
3263: PPUSH
3264: LD_INT 45
3266: PPUSH
3267: LD_INT 86
3269: PPUSH
3270: LD_INT 0
3272: PPUSH
3273: CALL_OW 48
// ComHold ( un ) ;
3277: LD_VAR 0 4
3281: PPUSH
3282: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3286: LD_ADDR_EXP 42
3290: PUSH
3291: LD_EXP 42
3295: PPUSH
3296: LD_EXP 42
3300: PUSH
3301: LD_INT 1
3303: PLUS
3304: PPUSH
3305: LD_VAR 0 4
3309: PPUSH
3310: CALL_OW 1
3314: ST_TO_ADDR
// un := CreateHuman ;
3315: LD_ADDR_VAR 0 4
3319: PUSH
3320: CALL_OW 44
3324: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3325: LD_VAR 0 4
3329: PPUSH
3330: LD_INT 3
3332: PPUSH
3333: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3337: LD_VAR 0 4
3341: PPUSH
3342: LD_INT 60
3344: PPUSH
3345: LD_INT 85
3347: PPUSH
3348: LD_INT 0
3350: PPUSH
3351: CALL_OW 48
// ComHold ( un ) ;
3355: LD_VAR 0 4
3359: PPUSH
3360: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3364: LD_ADDR_EXP 42
3368: PUSH
3369: LD_EXP 42
3373: PPUSH
3374: LD_EXP 42
3378: PUSH
3379: LD_INT 1
3381: PLUS
3382: PPUSH
3383: LD_VAR 0 4
3387: PPUSH
3388: CALL_OW 1
3392: ST_TO_ADDR
// un := CreateHuman ;
3393: LD_ADDR_VAR 0 4
3397: PUSH
3398: CALL_OW 44
3402: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3403: LD_VAR 0 4
3407: PPUSH
3408: LD_INT 3
3410: PPUSH
3411: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3415: LD_VAR 0 4
3419: PPUSH
3420: LD_INT 222
3422: PPUSH
3423: LD_INT 166
3425: PPUSH
3426: LD_INT 0
3428: PPUSH
3429: CALL_OW 48
// ComHold ( un ) ;
3433: LD_VAR 0 4
3437: PPUSH
3438: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3442: LD_ADDR_EXP 42
3446: PUSH
3447: LD_EXP 42
3451: PPUSH
3452: LD_EXP 42
3456: PUSH
3457: LD_INT 1
3459: PLUS
3460: PPUSH
3461: LD_VAR 0 4
3465: PPUSH
3466: CALL_OW 1
3470: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3471: LD_ADDR_EXP 40
3475: PUSH
3476: EMPTY
3477: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3478: LD_INT 1
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_VAR 0 5
3488: PPUSH
3489: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3493: LD_ADDR_OWVAR 26
3497: PUSH
3498: LD_STRING Pavel Grigorovic
3500: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3501: LD_ADDR_OWVAR 33
3505: PUSH
3506: LD_STRING SecondCharsGal
3508: ST_TO_ADDR
// hc_face_number := 4 ;
3509: LD_ADDR_OWVAR 34
3513: PUSH
3514: LD_INT 4
3516: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3517: LD_ADDR_EXP 40
3521: PUSH
3522: LD_EXP 40
3526: PPUSH
3527: LD_INT 1
3529: PPUSH
3530: CALL_OW 44
3534: PPUSH
3535: CALL_OW 1
3539: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3540: LD_INT 2
3542: PPUSH
3543: LD_INT 4
3545: PPUSH
3546: LD_INT 2
3548: PPUSH
3549: CALL_OW 380
// hc_name := Lucy Sebel ;
3553: LD_ADDR_OWVAR 26
3557: PUSH
3558: LD_STRING Lucy Sebel
3560: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3561: LD_ADDR_OWVAR 33
3565: PUSH
3566: LD_STRING SecondCharsGal
3568: ST_TO_ADDR
// hc_face_number := 15 ;
3569: LD_ADDR_OWVAR 34
3573: PUSH
3574: LD_INT 15
3576: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3577: LD_ADDR_EXP 40
3581: PUSH
3582: LD_EXP 40
3586: PPUSH
3587: LD_INT 2
3589: PPUSH
3590: CALL_OW 44
3594: PPUSH
3595: CALL_OW 1
3599: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3600: LD_INT 2
3602: PPUSH
3603: LD_INT 4
3605: PPUSH
3606: LD_INT 2
3608: PPUSH
3609: CALL_OW 380
// hc_gallery :=  ;
3613: LD_ADDR_OWVAR 33
3617: PUSH
3618: LD_STRING 
3620: ST_TO_ADDR
// hc_name :=  ;
3621: LD_ADDR_OWVAR 26
3625: PUSH
3626: LD_STRING 
3628: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3629: LD_ADDR_EXP 40
3633: PUSH
3634: LD_EXP 40
3638: PPUSH
3639: LD_INT 3
3641: PPUSH
3642: CALL_OW 44
3646: PPUSH
3647: CALL_OW 1
3651: ST_TO_ADDR
// hc_sex := sex_male ;
3652: LD_ADDR_OWVAR 27
3656: PUSH
3657: LD_INT 1
3659: ST_TO_ADDR
// hc_class = 11 ;
3660: LD_ADDR_OWVAR 28
3664: PUSH
3665: LD_INT 11
3667: ST_TO_ADDR
// hc_gallery = sandar ;
3668: LD_ADDR_OWVAR 33
3672: PUSH
3673: LD_STRING sandar
3675: ST_TO_ADDR
// hc_face_number = 33 ;
3676: LD_ADDR_OWVAR 34
3680: PUSH
3681: LD_INT 33
3683: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3684: LD_ADDR_OWVAR 26
3688: PUSH
3689: LD_STRING Thabit Muhair Saliba
3691: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3692: LD_ADDR_OWVAR 31
3696: PUSH
3697: LD_INT 0
3699: PUSH
3700: LD_INT 0
3702: PUSH
3703: LD_INT 0
3705: PUSH
3706: LD_INT 0
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: LIST
3713: LIST
3714: ST_TO_ADDR
// Saliba = CreateHuman ;
3715: LD_ADDR_EXP 44
3719: PUSH
3720: CALL_OW 44
3724: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3725: LD_EXP 44
3729: PPUSH
3730: LD_INT 7
3732: PPUSH
3733: CALL_OW 52
// if gensher_active then
3737: LD_EXP 18
3741: IFFALSE 3768
// begin Gensher = NewCharacter ( Dietrich ) ;
3743: LD_ADDR_EXP 45
3747: PUSH
3748: LD_STRING Dietrich
3750: PPUSH
3751: CALL_OW 25
3755: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3756: LD_EXP 45
3760: PPUSH
3761: LD_INT 94
3763: PPUSH
3764: CALL_OW 52
// end ; InitHc ;
3768: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3772: LD_ADDR_EXP 41
3776: PUSH
3777: EMPTY
3778: ST_TO_ADDR
// for i = 1 to 5 do
3779: LD_ADDR_VAR 0 2
3783: PUSH
3784: DOUBLE
3785: LD_INT 1
3787: DEC
3788: ST_TO_ADDR
3789: LD_INT 5
3791: PUSH
3792: FOR_TO
3793: IFFALSE 3965
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3795: LD_INT 13
3797: PUSH
3798: LD_INT 14
3800: PUSH
3801: EMPTY
3802: LIST
3803: LIST
3804: PUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 2
3810: PPUSH
3811: CALL_OW 12
3815: ARRAY
3816: PPUSH
3817: LD_INT 1
3819: PUSH
3820: LD_INT 2
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: PUSH
3827: LD_INT 1
3829: PPUSH
3830: LD_INT 2
3832: PPUSH
3833: CALL_OW 12
3837: ARRAY
3838: PPUSH
3839: LD_INT 1
3841: PPUSH
3842: LD_INT 25
3844: PUSH
3845: LD_INT 27
3847: PUSH
3848: LD_INT 26
3850: PUSH
3851: EMPTY
3852: LIST
3853: LIST
3854: LIST
3855: PUSH
3856: LD_INT 1
3858: PPUSH
3859: LD_INT 3
3861: PPUSH
3862: CALL_OW 12
3866: ARRAY
3867: PPUSH
3868: LD_INT 60
3870: PPUSH
3871: LD_INT 100
3873: PPUSH
3874: CALL_OW 12
3878: PPUSH
3879: CALL 52209 0 5
// un := CreateVehicle ;
3883: LD_ADDR_VAR 0 4
3887: PUSH
3888: CALL_OW 45
3892: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3893: LD_ADDR_EXP 41
3897: PUSH
3898: LD_EXP 41
3902: PPUSH
3903: LD_EXP 41
3907: PUSH
3908: LD_INT 1
3910: PLUS
3911: PPUSH
3912: LD_VAR 0 4
3916: PPUSH
3917: CALL_OW 1
3921: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3922: LD_VAR 0 4
3926: PPUSH
3927: LD_INT 0
3929: PPUSH
3930: LD_INT 5
3932: PPUSH
3933: CALL_OW 12
3937: PPUSH
3938: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
3942: LD_VAR 0 4
3946: PPUSH
3947: LD_INT 124
3949: PPUSH
3950: LD_INT 141
3952: PPUSH
3953: LD_INT 8
3955: PPUSH
3956: LD_INT 0
3958: PPUSH
3959: CALL_OW 50
// end ;
3963: GO 3792
3965: POP
3966: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3967: LD_ADDR_EXP 43
3971: PUSH
3972: EMPTY
3973: PUSH
3974: EMPTY
3975: PUSH
3976: EMPTY
3977: PUSH
3978: EMPTY
3979: LIST
3980: LIST
3981: LIST
3982: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3983: LD_ADDR_VAR 0 3
3987: PUSH
3988: DOUBLE
3989: LD_INT 1
3991: DEC
3992: ST_TO_ADDR
3993: LD_INT 3
3995: PUSH
3996: LD_INT 3
3998: PUSH
3999: LD_INT 4
4001: PUSH
4002: EMPTY
4003: LIST
4004: LIST
4005: LIST
4006: PUSH
4007: LD_OWVAR 67
4011: ARRAY
4012: PUSH
4013: FOR_TO
4014: IFFALSE 4228
// for i = 1 to 3 do
4016: LD_ADDR_VAR 0 2
4020: PUSH
4021: DOUBLE
4022: LD_INT 1
4024: DEC
4025: ST_TO_ADDR
4026: LD_INT 3
4028: PUSH
4029: FOR_TO
4030: IFFALSE 4224
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4032: LD_INT 14
4034: PPUSH
4035: LD_INT 3
4037: PUSH
4038: LD_INT 2
4040: PUSH
4041: EMPTY
4042: LIST
4043: LIST
4044: PUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 2
4050: PPUSH
4051: CALL_OW 12
4055: ARRAY
4056: PPUSH
4057: LD_INT 1
4059: PUSH
4060: LD_INT 5
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: PUSH
4067: LD_INT 1
4069: PPUSH
4070: LD_INT 2
4072: PPUSH
4073: CALL_OW 12
4077: ARRAY
4078: PPUSH
4079: LD_INT 25
4081: PUSH
4082: LD_INT 27
4084: PUSH
4085: LD_INT 26
4087: PUSH
4088: LD_INT 28
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: LIST
4095: LIST
4096: PUSH
4097: LD_INT 1
4099: PPUSH
4100: LD_INT 4
4102: PPUSH
4103: CALL_OW 12
4107: ARRAY
4108: PPUSH
4109: LD_INT 100
4111: PPUSH
4112: CALL 52209 0 5
// un := CreateVehicle ;
4116: LD_ADDR_VAR 0 4
4120: PUSH
4121: CALL_OW 45
4125: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4126: LD_ADDR_EXP 43
4130: PUSH
4131: LD_EXP 43
4135: PPUSH
4136: LD_VAR 0 2
4140: PUSH
4141: LD_EXP 43
4145: PUSH
4146: LD_VAR 0 2
4150: ARRAY
4151: PUSH
4152: LD_INT 1
4154: PLUS
4155: PUSH
4156: EMPTY
4157: LIST
4158: LIST
4159: PPUSH
4160: LD_VAR 0 4
4164: PPUSH
4165: CALL 52331 0 3
4169: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4170: LD_VAR 0 4
4174: PPUSH
4175: LD_INT 0
4177: PPUSH
4178: LD_INT 5
4180: PPUSH
4181: CALL_OW 12
4185: PPUSH
4186: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4190: LD_VAR 0 4
4194: PPUSH
4195: LD_INT 20
4197: PUSH
4198: LD_INT 21
4200: PUSH
4201: LD_INT 22
4203: PUSH
4204: EMPTY
4205: LIST
4206: LIST
4207: LIST
4208: PUSH
4209: LD_VAR 0 2
4213: ARRAY
4214: PPUSH
4215: LD_INT 0
4217: PPUSH
4218: CALL_OW 49
// end ;
4222: GO 4029
4224: POP
4225: POP
4226: GO 4013
4228: POP
4229: POP
// InitHc ;
4230: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4234: LD_INT 4
4236: PPUSH
4237: LD_INT 5
4239: PPUSH
4240: LD_INT 10
4242: PPUSH
4243: LD_INT 5
4245: PPUSH
4246: LD_INT 0
4248: PPUSH
4249: CALL_OW 58
// end ;
4253: LD_VAR 0 1
4257: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4258: LD_EXP 42
4262: IFFALSE 4336
4264: GO 4266
4266: DISABLE
4267: LD_INT 0
4269: PPUSH
// begin enable ;
4270: ENABLE
// for i in ar_kamikadze do
4271: LD_ADDR_VAR 0 1
4275: PUSH
4276: LD_EXP 42
4280: PUSH
4281: FOR_IN
4282: IFFALSE 4334
// if See ( 1 , i ) then
4284: LD_INT 1
4286: PPUSH
4287: LD_VAR 0 1
4291: PPUSH
4292: CALL_OW 292
4296: IFFALSE 4332
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4298: LD_VAR 0 1
4302: PPUSH
4303: LD_INT 81
4305: PUSH
4306: LD_INT 2
4308: PUSH
4309: EMPTY
4310: LIST
4311: LIST
4312: PPUSH
4313: CALL_OW 69
4317: PPUSH
4318: LD_VAR 0 1
4322: PPUSH
4323: CALL_OW 74
4327: PPUSH
4328: CALL_OW 115
4332: GO 4281
4334: POP
4335: POP
// end ;
4336: PPOPN 1
4338: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4339: LD_EXP 13
4343: IFFALSE 4660
4345: GO 4347
4347: DISABLE
4348: LD_INT 0
4350: PPUSH
4351: PPUSH
4352: PPUSH
4353: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4354: LD_INT 35
4356: PPUSH
4357: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4361: LD_INT 1
4363: PPUSH
4364: CALL 41389 0 1
4368: PUSH
4369: LD_INT 0
4371: EQUAL
4372: IFFALSE 4354
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4374: LD_INT 1
4376: PPUSH
4377: LD_INT 14
4379: PUSH
4380: LD_INT 3
4382: PUSH
4383: LD_INT 2
4385: PUSH
4386: LD_INT 32
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: PUSH
4395: EMPTY
4396: LIST
4397: PPUSH
4398: CALL 40993 0 2
// repeat wait ( 0 0$1 ) ;
4402: LD_INT 35
4404: PPUSH
4405: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4409: LD_EXP 69
4413: PUSH
4414: LD_INT 1
4416: ARRAY
4417: PPUSH
4418: LD_INT 33
4420: PUSH
4421: LD_INT 2
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: LD_INT 34
4430: PUSH
4431: LD_INT 32
4433: PUSH
4434: EMPTY
4435: LIST
4436: LIST
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: PPUSH
4442: CALL_OW 72
4446: IFFALSE 4402
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4448: LD_ADDR_VAR 0 2
4452: PUSH
4453: LD_EXP 69
4457: PUSH
4458: LD_INT 1
4460: ARRAY
4461: PPUSH
4462: LD_INT 33
4464: PUSH
4465: LD_INT 2
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PUSH
4472: LD_INT 34
4474: PUSH
4475: LD_INT 32
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: EMPTY
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 72
4490: PUSH
4491: LD_INT 1
4493: ARRAY
4494: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4495: LD_ADDR_VAR 0 4
4499: PUSH
4500: LD_INT 5
4502: PPUSH
4503: CALL_OW 469
4507: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4508: LD_INT 35
4510: PPUSH
4511: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4515: LD_ADDR_VAR 0 4
4519: PUSH
4520: LD_INT 5
4522: PPUSH
4523: CALL_OW 469
4527: ST_TO_ADDR
// tmp := 100 ;
4528: LD_ADDR_VAR 0 3
4532: PUSH
4533: LD_INT 100
4535: ST_TO_ADDR
// if pos then
4536: LD_VAR 0 4
4540: IFFALSE 4580
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4542: LD_ADDR_VAR 0 3
4546: PUSH
4547: LD_INT 2
4549: PPUSH
4550: LD_VAR 0 4
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_VAR 0 4
4563: PUSH
4564: LD_INT 2
4566: ARRAY
4567: PPUSH
4568: LD_INT 20
4570: PPUSH
4571: CALL 53227 0 4
4575: PUSH
4576: LD_INT 4
4578: ARRAY
4579: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4580: LD_VAR 0 4
4584: PUSH
4585: LD_EXP 14
4589: NOT
4590: AND
4591: PUSH
4592: LD_VAR 0 3
4596: PUSH
4597: LD_INT 10
4599: LESS
4600: AND
4601: IFFALSE 4508
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4603: LD_VAR 0 2
4607: PPUSH
4608: LD_VAR 0 4
4612: PUSH
4613: LD_INT 1
4615: ARRAY
4616: PPUSH
4617: LD_VAR 0 4
4621: PUSH
4622: LD_INT 2
4624: ARRAY
4625: PPUSH
4626: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4630: LD_VAR 0 2
4634: PPUSH
4635: LD_INT 198
4637: PPUSH
4638: LD_INT 113
4640: PPUSH
4641: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4645: LD_VAR 0 2
4649: PPUSH
4650: LD_INT 124
4652: PPUSH
4653: LD_INT 7
4655: PPUSH
4656: CALL_OW 171
// end ;
4660: PPOPN 4
4662: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4663: LD_EXP 6
4667: IFFALSE 7448
4669: GO 4671
4671: DISABLE
4672: LD_INT 0
4674: PPUSH
4675: PPUSH
4676: PPUSH
4677: PPUSH
4678: PPUSH
4679: PPUSH
4680: PPUSH
4681: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4682: LD_ADDR_VAR 0 4
4686: PUSH
4687: LD_INT 5
4689: PUSH
4690: LD_INT 6
4692: PUSH
4693: LD_INT 7
4695: PUSH
4696: EMPTY
4697: LIST
4698: LIST
4699: LIST
4700: PUSH
4701: LD_OWVAR 67
4705: ARRAY
4706: ST_TO_ADDR
// coords := [ ] ;
4707: LD_ADDR_VAR 0 5
4711: PUSH
4712: EMPTY
4713: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4714: LD_ADDR_VAR 0 6
4718: PUSH
4719: LD_INT 0
4721: PUSH
4722: LD_INT 0
4724: PUSH
4725: LD_INT 0
4727: PUSH
4728: LD_INT 0
4730: PUSH
4731: LD_INT 1
4733: PUSH
4734: LD_INT 0
4736: PUSH
4737: LD_INT 0
4739: PUSH
4740: LD_INT 0
4742: PUSH
4743: LD_INT 1
4745: PUSH
4746: LD_INT 0
4748: PUSH
4749: EMPTY
4750: LIST
4751: LIST
4752: LIST
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4761: LD_INT 1
4763: PPUSH
4764: LD_INT 14
4766: PUSH
4767: LD_INT 1
4769: PUSH
4770: LD_INT 2
4772: PUSH
4773: LD_INT 28
4775: PUSH
4776: EMPTY
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: PUSH
4782: LD_INT 14
4784: PUSH
4785: LD_INT 1
4787: PUSH
4788: LD_INT 2
4790: PUSH
4791: LD_INT 25
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: LIST
4798: LIST
4799: PUSH
4800: LD_INT 14
4802: PUSH
4803: LD_INT 1
4805: PUSH
4806: LD_INT 2
4808: PUSH
4809: LD_INT 28
4811: PUSH
4812: EMPTY
4813: LIST
4814: LIST
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 14
4820: PUSH
4821: LD_INT 1
4823: PUSH
4824: LD_INT 2
4826: PUSH
4827: LD_INT 29
4829: PUSH
4830: EMPTY
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: PUSH
4836: EMPTY
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: PPUSH
4842: CALL 40993 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4846: LD_INT 21000
4848: PUSH
4849: LD_INT 19950
4851: PUSH
4852: LD_INT 18900
4854: PUSH
4855: EMPTY
4856: LIST
4857: LIST
4858: LIST
4859: PUSH
4860: LD_OWVAR 67
4864: ARRAY
4865: PPUSH
4866: CALL_OW 67
// InitHc ;
4870: CALL_OW 19
// InitUc ;
4874: CALL_OW 18
// uc_side := 2 ;
4878: LD_ADDR_OWVAR 20
4882: PUSH
4883: LD_INT 2
4885: ST_TO_ADDR
// uc_nation := 2 ;
4886: LD_ADDR_OWVAR 21
4890: PUSH
4891: LD_INT 2
4893: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4894: LD_ADDR_VAR 0 3
4898: PUSH
4899: EMPTY
4900: PUSH
4901: EMPTY
4902: PUSH
4903: EMPTY
4904: PUSH
4905: EMPTY
4906: PUSH
4907: EMPTY
4908: PUSH
4909: EMPTY
4910: LIST
4911: LIST
4912: LIST
4913: LIST
4914: LIST
4915: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4916: LD_ADDR_VAR 0 3
4920: PUSH
4921: LD_VAR 0 3
4925: PPUSH
4926: LD_INT 1
4928: PPUSH
4929: LD_EXP 69
4933: PUSH
4934: LD_INT 1
4936: ARRAY
4937: PUSH
4938: LD_INT 34
4940: PUSH
4941: LD_INT 32
4943: PUSH
4944: EMPTY
4945: LIST
4946: LIST
4947: PPUSH
4948: CALL_OW 69
4952: DIFF
4953: PPUSH
4954: CALL_OW 1
4958: ST_TO_ADDR
// for i = 1 to Difficulty do
4959: LD_ADDR_VAR 0 1
4963: PUSH
4964: DOUBLE
4965: LD_INT 1
4967: DEC
4968: ST_TO_ADDR
4969: LD_OWVAR 67
4973: PUSH
4974: FOR_TO
4975: IFFALSE 5113
// begin uc_side := 2 ;
4977: LD_ADDR_OWVAR 20
4981: PUSH
4982: LD_INT 2
4984: ST_TO_ADDR
// uc_nation := 2 ;
4985: LD_ADDR_OWVAR 21
4989: PUSH
4990: LD_INT 2
4992: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4993: LD_INT 13
4995: PPUSH
4996: LD_INT 3
4998: PPUSH
4999: LD_INT 5
5001: PPUSH
5002: LD_INT 29
5004: PPUSH
5005: LD_INT 100
5007: PPUSH
5008: CALL 52209 0 5
// un := CreateVehicle ;
5012: LD_ADDR_VAR 0 2
5016: PUSH
5017: CALL_OW 45
5021: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5022: LD_ADDR_VAR 0 3
5026: PUSH
5027: LD_VAR 0 3
5031: PPUSH
5032: LD_INT 1
5034: PUSH
5035: LD_VAR 0 3
5039: PUSH
5040: LD_INT 1
5042: ARRAY
5043: PUSH
5044: LD_INT 1
5046: PLUS
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PPUSH
5052: LD_VAR 0 2
5056: PPUSH
5057: CALL 52331 0 3
5061: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5062: LD_VAR 0 2
5066: PPUSH
5067: LD_INT 3
5069: PPUSH
5070: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5074: LD_VAR 0 2
5078: PPUSH
5079: LD_INT 16
5081: PPUSH
5082: LD_INT 0
5084: PPUSH
5085: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5089: LD_VAR 0 2
5093: PPUSH
5094: LD_INT 51
5096: PPUSH
5097: LD_INT 10
5099: PPUSH
5100: CALL_OW 111
// wait ( 0 0$2 ) ;
5104: LD_INT 70
5106: PPUSH
5107: CALL_OW 67
// end ;
5111: GO 4974
5113: POP
5114: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5115: LD_ADDR_VAR 0 5
5119: PUSH
5120: LD_INT 51
5122: PUSH
5123: LD_INT 24
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: LD_INT 75
5132: PUSH
5133: LD_INT 90
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5144: LD_INT 1
5146: PPUSH
5147: LD_VAR 0 3
5151: PUSH
5152: LD_INT 1
5154: ARRAY
5155: PPUSH
5156: LD_VAR 0 5
5160: PPUSH
5161: LD_VAR 0 6
5165: PPUSH
5166: CALL 41226 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5170: LD_ADDR_VAR 0 1
5174: PUSH
5175: DOUBLE
5176: LD_INT 1
5178: DEC
5179: ST_TO_ADDR
5180: LD_INT 1
5182: PUSH
5183: LD_INT 3
5185: PUSH
5186: LD_INT 3
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_OWVAR 67
5198: ARRAY
5199: PUSH
5200: FOR_TO
5201: IFFALSE 5301
// begin uc_side := 2 ;
5203: LD_ADDR_OWVAR 20
5207: PUSH
5208: LD_INT 2
5210: ST_TO_ADDR
// uc_nation := 2 ;
5211: LD_ADDR_OWVAR 21
5215: PUSH
5216: LD_INT 2
5218: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5219: LD_INT 0
5221: PPUSH
5222: LD_INT 17
5224: PPUSH
5225: LD_VAR 0 4
5229: PPUSH
5230: CALL_OW 380
// un := CreateHuman ;
5234: LD_ADDR_VAR 0 2
5238: PUSH
5239: CALL_OW 44
5243: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5244: LD_ADDR_VAR 0 3
5248: PUSH
5249: LD_VAR 0 3
5253: PPUSH
5254: LD_INT 2
5256: PUSH
5257: LD_VAR 0 3
5261: PUSH
5262: LD_INT 2
5264: ARRAY
5265: PUSH
5266: LD_INT 1
5268: PLUS
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: PPUSH
5274: LD_VAR 0 2
5278: PPUSH
5279: CALL 52331 0 3
5283: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5284: LD_VAR 0 2
5288: PPUSH
5289: LD_INT 13
5291: PPUSH
5292: LD_INT 0
5294: PPUSH
5295: CALL_OW 49
// end ;
5299: GO 5200
5301: POP
5302: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5303: LD_ADDR_VAR 0 1
5307: PUSH
5308: DOUBLE
5309: LD_INT 1
5311: DEC
5312: ST_TO_ADDR
5313: LD_INT 3
5315: PUSH
5316: LD_INT 4
5318: PUSH
5319: LD_INT 4
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: LIST
5326: PUSH
5327: LD_OWVAR 67
5331: ARRAY
5332: PUSH
5333: FOR_TO
5334: IFFALSE 5455
// begin uc_side := 2 ;
5336: LD_ADDR_OWVAR 20
5340: PUSH
5341: LD_INT 2
5343: ST_TO_ADDR
// uc_nation := 2 ;
5344: LD_ADDR_OWVAR 21
5348: PUSH
5349: LD_INT 2
5351: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5352: LD_INT 0
5354: PPUSH
5355: LD_INT 1
5357: PUSH
5358: LD_INT 8
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: PUSH
5365: LD_VAR 0 1
5369: PUSH
5370: LD_INT 2
5372: MOD
5373: PUSH
5374: LD_INT 1
5376: PLUS
5377: ARRAY
5378: PPUSH
5379: LD_VAR 0 4
5383: PPUSH
5384: CALL_OW 380
// un := CreateHuman ;
5388: LD_ADDR_VAR 0 2
5392: PUSH
5393: CALL_OW 44
5397: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5398: LD_ADDR_VAR 0 3
5402: PUSH
5403: LD_VAR 0 3
5407: PPUSH
5408: LD_INT 2
5410: PUSH
5411: LD_VAR 0 3
5415: PUSH
5416: LD_INT 2
5418: ARRAY
5419: PUSH
5420: LD_INT 1
5422: PLUS
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: PPUSH
5428: LD_VAR 0 2
5432: PPUSH
5433: CALL 52331 0 3
5437: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5438: LD_VAR 0 2
5442: PPUSH
5443: LD_INT 13
5445: PPUSH
5446: LD_INT 0
5448: PPUSH
5449: CALL_OW 49
// end ;
5453: GO 5333
5455: POP
5456: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5457: LD_ADDR_VAR 0 5
5461: PUSH
5462: LD_INT 67
5464: PUSH
5465: LD_INT 112
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: PUSH
5472: LD_INT 85
5474: PUSH
5475: LD_INT 130
5477: PUSH
5478: EMPTY
5479: LIST
5480: LIST
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5486: LD_INT 2
5488: PPUSH
5489: LD_VAR 0 3
5493: PUSH
5494: LD_INT 2
5496: ARRAY
5497: PPUSH
5498: LD_VAR 0 5
5502: PPUSH
5503: LD_VAR 0 6
5507: PPUSH
5508: CALL 41226 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5512: LD_ADDR_VAR 0 1
5516: PUSH
5517: DOUBLE
5518: LD_INT 1
5520: DEC
5521: ST_TO_ADDR
5522: LD_INT 1
5524: PUSH
5525: LD_INT 2
5527: PUSH
5528: LD_INT 3
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: PUSH
5536: LD_OWVAR 67
5540: ARRAY
5541: PUSH
5542: FOR_TO
5543: IFFALSE 5643
// begin uc_side := 2 ;
5545: LD_ADDR_OWVAR 20
5549: PUSH
5550: LD_INT 2
5552: ST_TO_ADDR
// uc_nation := 2 ;
5553: LD_ADDR_OWVAR 21
5557: PUSH
5558: LD_INT 2
5560: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5561: LD_INT 0
5563: PPUSH
5564: LD_INT 17
5566: PPUSH
5567: LD_VAR 0 4
5571: PPUSH
5572: CALL_OW 380
// un := CreateHuman ;
5576: LD_ADDR_VAR 0 2
5580: PUSH
5581: CALL_OW 44
5585: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5586: LD_ADDR_VAR 0 3
5590: PUSH
5591: LD_VAR 0 3
5595: PPUSH
5596: LD_INT 3
5598: PUSH
5599: LD_VAR 0 3
5603: PUSH
5604: LD_INT 3
5606: ARRAY
5607: PUSH
5608: LD_INT 1
5610: PLUS
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PPUSH
5616: LD_VAR 0 2
5620: PPUSH
5621: CALL 52331 0 3
5625: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5626: LD_VAR 0 2
5630: PPUSH
5631: LD_INT 14
5633: PPUSH
5634: LD_INT 0
5636: PPUSH
5637: CALL_OW 49
// end ;
5641: GO 5542
5643: POP
5644: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5645: LD_ADDR_VAR 0 5
5649: PUSH
5650: LD_INT 148
5652: PUSH
5653: LD_INT 158
5655: PUSH
5656: EMPTY
5657: LIST
5658: LIST
5659: PUSH
5660: LD_INT 148
5662: PUSH
5663: LD_INT 158
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5674: LD_INT 3
5676: PPUSH
5677: LD_VAR 0 3
5681: PUSH
5682: LD_INT 3
5684: ARRAY
5685: PPUSH
5686: LD_VAR 0 5
5690: PPUSH
5691: LD_VAR 0 6
5695: PPUSH
5696: CALL 41226 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
5700: LD_ADDR_VAR 0 1
5704: PUSH
5705: DOUBLE
5706: LD_INT 1
5708: DEC
5709: ST_TO_ADDR
5710: LD_INT 2
5712: PUSH
5713: LD_INT 4
5715: PUSH
5716: LD_INT 4
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: LIST
5723: PUSH
5724: LD_OWVAR 67
5728: ARRAY
5729: PUSH
5730: FOR_TO
5731: IFFALSE 5955
// begin uc_side := 2 ;
5733: LD_ADDR_OWVAR 20
5737: PUSH
5738: LD_INT 2
5740: ST_TO_ADDR
// uc_nation := 2 ;
5741: LD_ADDR_OWVAR 21
5745: PUSH
5746: LD_INT 2
5748: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5749: LD_INT 14
5751: PPUSH
5752: LD_INT 3
5754: PPUSH
5755: LD_INT 1
5757: PUSH
5758: LD_INT 5
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 1
5767: PPUSH
5768: LD_INT 2
5770: PPUSH
5771: CALL_OW 12
5775: ARRAY
5776: PPUSH
5777: LD_INT 27
5779: PUSH
5780: LD_INT 26
5782: PUSH
5783: LD_INT 28
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 1
5793: PPUSH
5794: LD_INT 3
5796: PPUSH
5797: CALL_OW 12
5801: ARRAY
5802: PPUSH
5803: LD_INT 100
5805: PPUSH
5806: CALL 52209 0 5
// un := CreateVehicle ;
5810: LD_ADDR_VAR 0 2
5814: PUSH
5815: CALL_OW 45
5819: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5820: LD_ADDR_VAR 0 3
5824: PUSH
5825: LD_VAR 0 3
5829: PPUSH
5830: LD_INT 4
5832: PUSH
5833: LD_VAR 0 3
5837: PUSH
5838: LD_INT 4
5840: ARRAY
5841: PUSH
5842: LD_INT 1
5844: PLUS
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: PPUSH
5850: LD_VAR 0 2
5854: PPUSH
5855: CALL 52331 0 3
5859: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5860: LD_VAR 0 2
5864: PPUSH
5865: LD_INT 5
5867: PPUSH
5868: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5872: LD_VAR 0 2
5876: PPUSH
5877: LD_INT 15
5879: PPUSH
5880: LD_INT 0
5882: PPUSH
5883: CALL_OW 49
// if GetControl ( un ) = control_manual then
5887: LD_VAR 0 2
5891: PPUSH
5892: CALL_OW 263
5896: PUSH
5897: LD_INT 1
5899: EQUAL
5900: IFFALSE 5931
// begin PrepareHuman ( false , 3 , skill ) ;
5902: LD_INT 0
5904: PPUSH
5905: LD_INT 3
5907: PPUSH
5908: LD_VAR 0 4
5912: PPUSH
5913: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5917: CALL_OW 44
5921: PPUSH
5922: LD_VAR 0 2
5926: PPUSH
5927: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5931: LD_VAR 0 2
5935: PPUSH
5936: LD_INT 179
5938: PPUSH
5939: LD_INT 135
5941: PPUSH
5942: CALL_OW 111
// wait ( 0 0$2 ) ;
5946: LD_INT 70
5948: PPUSH
5949: CALL_OW 67
// end ;
5953: GO 5730
5955: POP
5956: POP
// vc_chassis := 15 ;
5957: LD_ADDR_OWVAR 37
5961: PUSH
5962: LD_INT 15
5964: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5965: LD_ADDR_VAR 0 3
5969: PUSH
5970: LD_VAR 0 3
5974: PPUSH
5975: LD_INT 4
5977: PUSH
5978: LD_VAR 0 3
5982: PUSH
5983: LD_INT 4
5985: ARRAY
5986: PUSH
5987: LD_INT 1
5989: PLUS
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PPUSH
5995: CALL_OW 45
5999: PPUSH
6000: CALL 52331 0 3
6004: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6005: LD_VAR 0 3
6009: PUSH
6010: LD_INT 4
6012: ARRAY
6013: PUSH
6014: LD_VAR 0 3
6018: PUSH
6019: LD_INT 4
6021: ARRAY
6022: ARRAY
6023: PPUSH
6024: LD_INT 15
6026: PPUSH
6027: LD_INT 0
6029: PPUSH
6030: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6034: LD_INT 0
6036: PPUSH
6037: LD_INT 11
6039: PPUSH
6040: LD_VAR 0 4
6044: PPUSH
6045: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6049: LD_ADDR_VAR 0 3
6053: PUSH
6054: LD_VAR 0 3
6058: PPUSH
6059: LD_INT 4
6061: PUSH
6062: LD_VAR 0 3
6066: PUSH
6067: LD_INT 4
6069: ARRAY
6070: PUSH
6071: LD_INT 1
6073: PLUS
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: PPUSH
6079: CALL_OW 44
6083: PPUSH
6084: CALL 52331 0 3
6088: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6089: LD_VAR 0 3
6093: PUSH
6094: LD_INT 4
6096: ARRAY
6097: PUSH
6098: LD_VAR 0 3
6102: PUSH
6103: LD_INT 4
6105: ARRAY
6106: ARRAY
6107: PPUSH
6108: LD_VAR 0 3
6112: PUSH
6113: LD_INT 4
6115: ARRAY
6116: PUSH
6117: LD_VAR 0 3
6121: PUSH
6122: LD_INT 4
6124: ARRAY
6125: PUSH
6126: LD_INT 1
6128: MINUS
6129: ARRAY
6130: PPUSH
6131: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6135: LD_ADDR_VAR 0 5
6139: PUSH
6140: LD_INT 148
6142: PUSH
6143: LD_INT 140
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: PUSH
6150: EMPTY
6151: LIST
6152: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6153: LD_INT 1
6155: PPUSH
6156: LD_VAR 0 3
6160: PUSH
6161: LD_INT 4
6163: ARRAY
6164: PPUSH
6165: LD_VAR 0 5
6169: PPUSH
6170: LD_VAR 0 6
6174: PPUSH
6175: CALL 41226 0 4
// if gensher_active then
6179: LD_EXP 18
6183: IFFALSE 6585
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6185: LD_EXP 45
6189: PPUSH
6190: LD_STRING D10-Diet-1
6192: PPUSH
6193: CALL_OW 94
// for i = 1 to 2 do
6197: LD_ADDR_VAR 0 1
6201: PUSH
6202: DOUBLE
6203: LD_INT 1
6205: DEC
6206: ST_TO_ADDR
6207: LD_INT 2
6209: PUSH
6210: FOR_TO
6211: IFFALSE 6349
// begin uc_side := 2 ;
6213: LD_ADDR_OWVAR 20
6217: PUSH
6218: LD_INT 2
6220: ST_TO_ADDR
// uc_nation := 2 ;
6221: LD_ADDR_OWVAR 21
6225: PUSH
6226: LD_INT 2
6228: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6229: LD_INT 13
6231: PPUSH
6232: LD_INT 3
6234: PPUSH
6235: LD_INT 5
6237: PPUSH
6238: LD_INT 29
6240: PPUSH
6241: LD_INT 100
6243: PPUSH
6244: CALL 52209 0 5
// un := CreateVehicle ;
6248: LD_ADDR_VAR 0 2
6252: PUSH
6253: CALL_OW 45
6257: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6258: LD_ADDR_VAR 0 3
6262: PUSH
6263: LD_VAR 0 3
6267: PPUSH
6268: LD_INT 5
6270: PUSH
6271: LD_VAR 0 3
6275: PUSH
6276: LD_INT 5
6278: ARRAY
6279: PUSH
6280: LD_INT 1
6282: PLUS
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: PPUSH
6288: LD_VAR 0 2
6292: PPUSH
6293: CALL 52331 0 3
6297: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6298: LD_VAR 0 2
6302: PPUSH
6303: LD_INT 0
6305: PPUSH
6306: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6310: LD_VAR 0 2
6314: PPUSH
6315: LD_INT 23
6317: PPUSH
6318: LD_INT 0
6320: PPUSH
6321: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6325: LD_VAR 0 2
6329: PPUSH
6330: LD_INT 85
6332: PPUSH
6333: LD_INT 152
6335: PPUSH
6336: CALL_OW 111
// wait ( 0 0$2 ) ;
6340: LD_INT 70
6342: PPUSH
6343: CALL_OW 67
// end ;
6347: GO 6210
6349: POP
6350: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6351: LD_ADDR_VAR 0 1
6355: PUSH
6356: DOUBLE
6357: LD_INT 1
6359: DEC
6360: ST_TO_ADDR
6361: LD_INT 2
6363: PUSH
6364: LD_INT 3
6366: PUSH
6367: LD_INT 3
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: LD_OWVAR 67
6379: ARRAY
6380: PUSH
6381: FOR_TO
6382: IFFALSE 6539
// begin uc_side := 2 ;
6384: LD_ADDR_OWVAR 20
6388: PUSH
6389: LD_INT 2
6391: ST_TO_ADDR
// uc_nation := 2 ;
6392: LD_ADDR_OWVAR 21
6396: PUSH
6397: LD_INT 2
6399: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6400: LD_INT 14
6402: PPUSH
6403: LD_INT 3
6405: PPUSH
6406: LD_INT 5
6408: PPUSH
6409: LD_INT 27
6411: PUSH
6412: LD_INT 28
6414: PUSH
6415: EMPTY
6416: LIST
6417: LIST
6418: PUSH
6419: LD_INT 1
6421: PPUSH
6422: LD_INT 2
6424: PPUSH
6425: CALL_OW 12
6429: ARRAY
6430: PPUSH
6431: LD_INT 100
6433: PPUSH
6434: CALL 52209 0 5
// un := CreateVehicle ;
6438: LD_ADDR_VAR 0 2
6442: PUSH
6443: CALL_OW 45
6447: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6448: LD_ADDR_VAR 0 3
6452: PUSH
6453: LD_VAR 0 3
6457: PPUSH
6458: LD_INT 5
6460: PUSH
6461: LD_VAR 0 3
6465: PUSH
6466: LD_INT 5
6468: ARRAY
6469: PUSH
6470: LD_INT 1
6472: PLUS
6473: PUSH
6474: EMPTY
6475: LIST
6476: LIST
6477: PPUSH
6478: LD_VAR 0 2
6482: PPUSH
6483: CALL 52331 0 3
6487: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6488: LD_VAR 0 2
6492: PPUSH
6493: LD_INT 0
6495: PPUSH
6496: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6500: LD_VAR 0 2
6504: PPUSH
6505: LD_INT 23
6507: PPUSH
6508: LD_INT 0
6510: PPUSH
6511: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6515: LD_VAR 0 2
6519: PPUSH
6520: LD_INT 85
6522: PPUSH
6523: LD_INT 152
6525: PPUSH
6526: CALL_OW 111
// wait ( 0 0$2 ) ;
6530: LD_INT 70
6532: PPUSH
6533: CALL_OW 67
// end ;
6537: GO 6381
6539: POP
6540: POP
// coords := [ [ 97 , 143 ] ] ;
6541: LD_ADDR_VAR 0 5
6545: PUSH
6546: LD_INT 97
6548: PUSH
6549: LD_INT 143
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: PUSH
6556: EMPTY
6557: LIST
6558: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6559: LD_INT 1
6561: PPUSH
6562: LD_VAR 0 3
6566: PUSH
6567: LD_INT 5
6569: ARRAY
6570: PPUSH
6571: LD_VAR 0 5
6575: PPUSH
6576: LD_VAR 0 6
6580: PPUSH
6581: CALL 41226 0 4
// end ; Wait ( 13 13$00 ) ;
6585: LD_INT 27300
6587: PPUSH
6588: CALL_OW 67
// tmp := [ ] ;
6592: LD_ADDR_VAR 0 3
6596: PUSH
6597: EMPTY
6598: ST_TO_ADDR
// w := 1 ;
6599: LD_ADDR_VAR 0 7
6603: PUSH
6604: LD_INT 1
6606: ST_TO_ADDR
// repeat tmp := [ ] ;
6607: LD_ADDR_VAR 0 3
6611: PUSH
6612: EMPTY
6613: ST_TO_ADDR
// if w mod 4 = 0 then
6614: LD_VAR 0 7
6618: PUSH
6619: LD_INT 4
6621: MOD
6622: PUSH
6623: LD_INT 0
6625: EQUAL
6626: IFFALSE 6713
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6628: LD_ADDR_VAR 0 8
6632: PUSH
6633: LD_INT 11
6635: PUSH
6636: LD_INT 1
6638: PUSH
6639: LD_INT 2
6641: PUSH
6642: LD_INT 24
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 11
6653: PUSH
6654: LD_INT 1
6656: PUSH
6657: LD_INT 2
6659: PUSH
6660: LD_INT 24
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 11
6671: PUSH
6672: LD_INT 1
6674: PUSH
6675: LD_INT 2
6677: PUSH
6678: LD_INT 24
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 11
6689: PUSH
6690: LD_INT 1
6692: PUSH
6693: LD_INT 2
6695: PUSH
6696: LD_INT 24
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: EMPTY
6706: LIST
6707: LIST
6708: LIST
6709: LIST
6710: ST_TO_ADDR
6711: GO 6815
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6713: LD_ADDR_VAR 0 8
6717: PUSH
6718: LD_INT 14
6720: PUSH
6721: LD_INT 1
6723: PUSH
6724: LD_INT 2
6726: PUSH
6727: LD_INT 28
6729: PUSH
6730: EMPTY
6731: LIST
6732: LIST
6733: LIST
6734: LIST
6735: PUSH
6736: LD_INT 14
6738: PUSH
6739: LD_INT 1
6741: PUSH
6742: LD_INT 2
6744: PUSH
6745: LD_INT 25
6747: PUSH
6748: EMPTY
6749: LIST
6750: LIST
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 14
6756: PUSH
6757: LD_INT 1
6759: PUSH
6760: LD_INT 2
6762: PUSH
6763: LD_INT 28
6765: PUSH
6766: EMPTY
6767: LIST
6768: LIST
6769: LIST
6770: LIST
6771: PUSH
6772: LD_INT 14
6774: PUSH
6775: LD_INT 1
6777: PUSH
6778: LD_INT 2
6780: PUSH
6781: LD_INT 29
6783: PUSH
6784: EMPTY
6785: LIST
6786: LIST
6787: LIST
6788: LIST
6789: PUSH
6790: LD_INT 11
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: LD_INT 2
6798: PUSH
6799: LD_INT 24
6801: PUSH
6802: EMPTY
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: LIST
6812: LIST
6813: LIST
6814: ST_TO_ADDR
// if w mod 3 = 0 then
6815: LD_VAR 0 7
6819: PUSH
6820: LD_INT 3
6822: MOD
6823: PUSH
6824: LD_INT 0
6826: EQUAL
6827: IFFALSE 6903
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6829: LD_ADDR_VAR 0 8
6833: PUSH
6834: LD_VAR 0 8
6838: PPUSH
6839: LD_INT 1
6841: PUSH
6842: LD_VAR 0 8
6846: PUSH
6847: LD_VAR 0 1
6851: ARRAY
6852: PUSH
6853: LD_INT 1
6855: PLUS
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: LD_INT 14
6863: PUSH
6864: LD_INT 1
6866: PUSH
6867: LD_INT 2
6869: PUSH
6870: LD_INT 25
6872: PUSH
6873: LD_INT 28
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: PUSH
6880: LD_INT 1
6882: PPUSH
6883: LD_INT 2
6885: PPUSH
6886: CALL_OW 12
6890: ARRAY
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: LIST
6897: PPUSH
6898: CALL 52331 0 3
6902: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6903: LD_INT 1
6905: PPUSH
6906: LD_VAR 0 8
6910: PPUSH
6911: CALL 40993 0 2
// if GetSide ( ar_dep_w ) = 2 then
6915: LD_INT 45
6917: PPUSH
6918: CALL_OW 255
6922: PUSH
6923: LD_INT 2
6925: EQUAL
6926: IFFALSE 7011
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6928: LD_ADDR_VAR 0 8
6932: PUSH
6933: LD_INT 14
6935: PUSH
6936: LD_INT 1
6938: PUSH
6939: LD_INT 2
6941: PUSH
6942: LD_INT 28
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: LIST
6949: LIST
6950: PUSH
6951: LD_INT 14
6953: PUSH
6954: LD_INT 1
6956: PUSH
6957: LD_INT 2
6959: PUSH
6960: LD_INT 27
6962: PUSH
6963: EMPTY
6964: LIST
6965: LIST
6966: LIST
6967: LIST
6968: PUSH
6969: LD_INT 14
6971: PUSH
6972: LD_INT 1
6974: PUSH
6975: LD_INT 2
6977: PUSH
6978: LD_INT 27
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: LIST
6985: LIST
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: LIST
6991: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6992: LD_INT 2
6994: PPUSH
6995: LD_VAR 0 8
6999: PPUSH
7000: CALL 40993 0 2
// wait ( 0 0$50 ) ;
7004: LD_INT 1750
7006: PPUSH
7007: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7011: LD_INT 35
7013: PPUSH
7014: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
7018: LD_EXP 69
7022: PUSH
7023: LD_INT 1
7025: ARRAY
7026: PPUSH
7027: LD_INT 3
7029: PUSH
7030: LD_INT 34
7032: PUSH
7033: LD_INT 32
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PUSH
7040: EMPTY
7041: LIST
7042: LIST
7043: PPUSH
7044: CALL_OW 72
7048: PUSH
7049: LD_INT 4
7051: GREATEREQUAL
7052: IFFALSE 7011
// wait ( 0 0$10 ) ;
7054: LD_INT 350
7056: PPUSH
7057: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
7061: LD_ADDR_VAR 0 3
7065: PUSH
7066: LD_EXP 69
7070: PUSH
7071: LD_INT 1
7073: ARRAY
7074: PPUSH
7075: LD_INT 3
7077: PUSH
7078: LD_INT 34
7080: PUSH
7081: LD_INT 32
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PPUSH
7092: CALL_OW 72
7096: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7097: LD_INT 100
7099: PPUSH
7100: CALL_OW 13
7104: PUSH
7105: LD_INT 50
7107: LESS
7108: IFFALSE 7141
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7110: LD_ADDR_VAR 0 5
7114: PUSH
7115: LD_INT 55
7117: PUSH
7118: LD_INT 7
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 75
7127: PUSH
7128: LD_INT 90
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: ST_TO_ADDR
7139: GO 7170
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7141: LD_ADDR_VAR 0 5
7145: PUSH
7146: LD_INT 128
7148: PUSH
7149: LD_INT 94
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PUSH
7156: LD_INT 180
7158: PUSH
7159: LD_INT 135
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: ST_TO_ADDR
// if w mod 4 = 0 then
7170: LD_VAR 0 7
7174: PUSH
7175: LD_INT 4
7177: MOD
7178: PUSH
7179: LD_INT 0
7181: EQUAL
7182: IFFALSE 7213
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7184: LD_ADDR_VAR 0 5
7188: PUSH
7189: LD_INT 91
7191: PUSH
7192: LD_INT 58
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: PUSH
7199: LD_INT 117
7201: PUSH
7202: LD_INT 107
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: PUSH
7209: EMPTY
7210: LIST
7211: LIST
7212: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7213: LD_VAR 0 3
7217: PPUSH
7218: LD_VAR 0 5
7222: PUSH
7223: LD_INT 1
7225: ARRAY
7226: PPUSH
7227: LD_VAR 0 5
7231: PUSH
7232: LD_INT 2
7234: ARRAY
7235: PPUSH
7236: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7240: LD_INT 35
7242: PPUSH
7243: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7247: LD_VAR 0 3
7251: PPUSH
7252: LD_INT 60
7254: PUSH
7255: EMPTY
7256: LIST
7257: PPUSH
7258: CALL_OW 72
7262: PUSH
7263: LD_INT 0
7265: EQUAL
7266: IFFALSE 7240
// repeat wait ( 0 0$2 ) ;
7268: LD_INT 70
7270: PPUSH
7271: CALL_OW 67
// for i in tmp do
7275: LD_ADDR_VAR 0 1
7279: PUSH
7280: LD_VAR 0 3
7284: PUSH
7285: FOR_IN
7286: IFFALSE 7375
// if GetChassis ( i ) = ar_hovercraft then
7288: LD_VAR 0 1
7292: PPUSH
7293: CALL_OW 265
7297: PUSH
7298: LD_INT 11
7300: EQUAL
7301: IFFALSE 7339
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7303: LD_VAR 0 1
7307: PPUSH
7308: LD_INT 22
7310: PUSH
7311: LD_INT 1
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: PPUSH
7318: CALL_OW 69
7322: PPUSH
7323: LD_VAR 0 1
7327: PPUSH
7328: CALL_OW 74
7332: PPUSH
7333: CALL 79519 0 2
7337: GO 7373
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7339: LD_VAR 0 1
7343: PPUSH
7344: LD_INT 22
7346: PUSH
7347: LD_INT 1
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: PPUSH
7354: CALL_OW 69
7358: PPUSH
7359: LD_VAR 0 1
7363: PPUSH
7364: CALL_OW 74
7368: PPUSH
7369: CALL_OW 115
7373: GO 7285
7375: POP
7376: POP
// until not tmp ;
7377: LD_VAR 0 3
7381: NOT
7382: IFFALSE 7268
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7384: LD_INT 22050
7386: PPUSH
7387: LD_INT 28350
7389: PPUSH
7390: CALL_OW 12
7394: PPUSH
7395: CALL_OW 67
// w := w + 1 ;
7399: LD_ADDR_VAR 0 7
7403: PUSH
7404: LD_VAR 0 7
7408: PUSH
7409: LD_INT 1
7411: PLUS
7412: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7413: LD_INT 94
7415: PPUSH
7416: CALL_OW 301
7420: PUSH
7421: LD_EXP 50
7425: PUSH
7426: LD_INT 1
7428: ARRAY
7429: PPUSH
7430: LD_INT 30
7432: PUSH
7433: LD_INT 3
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: PPUSH
7440: CALL_OW 72
7444: NOT
7445: OR
7446: IFFALSE 6607
// end ;
7448: PPOPN 8
7450: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7451: LD_INT 204
7453: IFFALSE 7919
7455: GO 7457
7457: DISABLE
7458: LD_INT 0
7460: PPUSH
7461: PPUSH
7462: PPUSH
7463: PPUSH
// begin enable ;
7464: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7465: LD_INT 35
7467: PPUSH
7468: LD_INT 1190
7470: PPUSH
7471: CALL_OW 12
7475: PPUSH
7476: CALL_OW 67
// tmp := [ ] ;
7480: LD_ADDR_VAR 0 2
7484: PUSH
7485: EMPTY
7486: ST_TO_ADDR
// uc_side := 8 ;
7487: LD_ADDR_OWVAR 20
7491: PUSH
7492: LD_INT 8
7494: ST_TO_ADDR
// uc_nation := 2 ;
7495: LD_ADDR_OWVAR 21
7499: PUSH
7500: LD_INT 2
7502: ST_TO_ADDR
// InitHc ;
7503: CALL_OW 19
// for i = 1 to 3 do
7507: LD_ADDR_VAR 0 1
7511: PUSH
7512: DOUBLE
7513: LD_INT 1
7515: DEC
7516: ST_TO_ADDR
7517: LD_INT 3
7519: PUSH
7520: FOR_TO
7521: IFFALSE 7648
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7523: LD_INT 13
7525: PUSH
7526: LD_INT 14
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: PUSH
7533: LD_INT 1
7535: PPUSH
7536: LD_INT 2
7538: PPUSH
7539: CALL_OW 12
7543: ARRAY
7544: PPUSH
7545: LD_INT 3
7547: PPUSH
7548: LD_INT 5
7550: PPUSH
7551: LD_INT 27
7553: PUSH
7554: LD_INT 28
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PUSH
7561: LD_INT 1
7563: PPUSH
7564: LD_INT 2
7566: PPUSH
7567: CALL_OW 12
7571: ARRAY
7572: PPUSH
7573: LD_INT 100
7575: PPUSH
7576: CALL 52209 0 5
// un := CreateVehicle ;
7580: LD_ADDR_VAR 0 3
7584: PUSH
7585: CALL_OW 45
7589: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7590: LD_VAR 0 3
7594: PPUSH
7595: LD_INT 4
7597: PPUSH
7598: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7602: LD_VAR 0 3
7606: PPUSH
7607: LD_INT 15
7609: PPUSH
7610: LD_INT 0
7612: PPUSH
7613: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7617: LD_ADDR_VAR 0 2
7621: PUSH
7622: LD_VAR 0 2
7626: PPUSH
7627: LD_VAR 0 2
7631: PUSH
7632: LD_INT 1
7634: PLUS
7635: PPUSH
7636: LD_VAR 0 3
7640: PPUSH
7641: CALL_OW 1
7645: ST_TO_ADDR
// end ;
7646: GO 7520
7648: POP
7649: POP
// for i = 1 to 4 do
7650: LD_ADDR_VAR 0 1
7654: PUSH
7655: DOUBLE
7656: LD_INT 1
7658: DEC
7659: ST_TO_ADDR
7660: LD_INT 4
7662: PUSH
7663: FOR_TO
7664: IFFALSE 7735
// begin PrepareHuman ( false , 1 , 6 ) ;
7666: LD_INT 0
7668: PPUSH
7669: LD_INT 1
7671: PPUSH
7672: LD_INT 6
7674: PPUSH
7675: CALL_OW 380
// un := CreateHuman ;
7679: LD_ADDR_VAR 0 3
7683: PUSH
7684: CALL_OW 44
7688: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7689: LD_VAR 0 3
7693: PPUSH
7694: LD_INT 15
7696: PPUSH
7697: LD_INT 0
7699: PPUSH
7700: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7704: LD_ADDR_VAR 0 2
7708: PUSH
7709: LD_VAR 0 2
7713: PPUSH
7714: LD_VAR 0 2
7718: PUSH
7719: LD_INT 1
7721: PLUS
7722: PPUSH
7723: LD_VAR 0 3
7727: PPUSH
7728: CALL_OW 1
7732: ST_TO_ADDR
// end ;
7733: GO 7663
7735: POP
7736: POP
// wait ( 0 0$3 ) ;
7737: LD_INT 105
7739: PPUSH
7740: CALL_OW 67
// for i in tmp do
7744: LD_ADDR_VAR 0 1
7748: PUSH
7749: LD_VAR 0 2
7753: PUSH
7754: FOR_IN
7755: IFFALSE 7823
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
7757: LD_VAR 0 1
7761: PPUSH
7762: CALL_OW 257
7766: PUSH
7767: LD_INT 1
7769: EQUAL
7770: PUSH
7771: LD_VAR 0 1
7775: PPUSH
7776: CALL_OW 247
7780: PUSH
7781: LD_INT 2
7783: EQUAL
7784: OR
7785: IFFALSE 7821
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7787: LD_VAR 0 1
7791: PPUSH
7792: LD_INT 81
7794: PUSH
7795: LD_INT 8
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: PPUSH
7802: CALL_OW 69
7806: PPUSH
7807: LD_VAR 0 1
7811: PPUSH
7812: CALL_OW 74
7816: PPUSH
7817: CALL_OW 115
7821: GO 7754
7823: POP
7824: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
7825: LD_VAR 0 2
7829: PPUSH
7830: LD_INT 210
7832: PPUSH
7833: LD_INT 178
7835: PPUSH
7836: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7840: LD_ADDR_VAR 0 4
7844: PUSH
7845: LD_INT 10
7847: PPUSH
7848: LD_INT 22
7850: PUSH
7851: LD_INT 8
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PPUSH
7858: CALL_OW 70
7862: ST_TO_ADDR
// if x then
7863: LD_VAR 0 4
7867: IFFALSE 7895
// for i in x do
7869: LD_ADDR_VAR 0 1
7873: PUSH
7874: LD_VAR 0 4
7878: PUSH
7879: FOR_IN
7880: IFFALSE 7893
// RemoveUnit ( i ) ;
7882: LD_VAR 0 1
7886: PPUSH
7887: CALL_OW 64
7891: GO 7879
7893: POP
7894: POP
// wait ( 0 0$1 ) ;
7895: LD_INT 35
7897: PPUSH
7898: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
7902: LD_INT 22
7904: PUSH
7905: LD_INT 8
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PPUSH
7912: CALL_OW 69
7916: NOT
7917: IFFALSE 7825
// end ;
7919: PPOPN 4
7921: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
7922: LD_INT 22
7924: PUSH
7925: LD_INT 2
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PUSH
7932: LD_INT 34
7934: PUSH
7935: LD_INT 31
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PUSH
7942: LD_INT 3
7944: PUSH
7945: LD_INT 24
7947: PUSH
7948: LD_INT 1000
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: PUSH
7955: EMPTY
7956: LIST
7957: LIST
7958: PUSH
7959: EMPTY
7960: LIST
7961: LIST
7962: LIST
7963: PPUSH
7964: CALL_OW 69
7968: IFFALSE 8071
7970: GO 7972
7972: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
7973: LD_INT 45
7975: PPUSH
7976: CALL_OW 302
7980: PUSH
7981: LD_INT 45
7983: PPUSH
7984: CALL_OW 255
7988: AND
7989: IFFALSE 8032
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
7991: LD_INT 22
7993: PUSH
7994: LD_INT 2
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 34
8003: PUSH
8004: LD_INT 31
8006: PUSH
8007: EMPTY
8008: LIST
8009: LIST
8010: PUSH
8011: EMPTY
8012: LIST
8013: LIST
8014: PPUSH
8015: CALL_OW 69
8019: PPUSH
8020: LD_INT 18
8022: PPUSH
8023: LD_INT 8
8025: PPUSH
8026: CALL_OW 111
8030: GO 8071
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8032: LD_INT 22
8034: PUSH
8035: LD_INT 2
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: LD_INT 34
8044: PUSH
8045: LD_INT 31
8047: PUSH
8048: EMPTY
8049: LIST
8050: LIST
8051: PUSH
8052: EMPTY
8053: LIST
8054: LIST
8055: PPUSH
8056: CALL_OW 69
8060: PPUSH
8061: LD_INT 106
8063: PPUSH
8064: LD_INT 14
8066: PPUSH
8067: CALL_OW 111
// end ; end_of_file
8071: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8072: LD_INT 0
8074: PPUSH
8075: PPUSH
8076: PPUSH
8077: PPUSH
8078: PPUSH
8079: PPUSH
// InGameOn ;
8080: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8084: LD_EXP 21
8088: PPUSH
8089: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8093: LD_INT 2
8095: PPUSH
8096: LD_INT 1
8098: PPUSH
8099: LD_INT 1
8101: PPUSH
8102: LD_INT 1
8104: PPUSH
8105: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8109: LD_ADDR_VAR 0 2
8113: PUSH
8114: LD_INT 22
8116: PUSH
8117: LD_INT 1
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: PUSH
8124: LD_INT 25
8126: PUSH
8127: LD_INT 1
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PPUSH
8138: CALL_OW 69
8142: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8143: LD_ADDR_VAR 0 4
8147: PUSH
8148: LD_INT 22
8150: PUSH
8151: LD_INT 1
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: LD_INT 34
8160: PUSH
8161: LD_INT 11
8163: PUSH
8164: EMPTY
8165: LIST
8166: LIST
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PPUSH
8172: CALL_OW 69
8176: PUSH
8177: LD_INT 1
8179: ARRAY
8180: ST_TO_ADDR
// for i = 1 to tmp do
8181: LD_ADDR_VAR 0 6
8185: PUSH
8186: DOUBLE
8187: LD_INT 1
8189: DEC
8190: ST_TO_ADDR
8191: LD_VAR 0 2
8195: PUSH
8196: FOR_TO
8197: IFFALSE 8244
// begin if i = 5 then
8199: LD_VAR 0 6
8203: PUSH
8204: LD_INT 5
8206: EQUAL
8207: IFFALSE 8211
// break ;
8209: GO 8244
// sols := Replace ( sols , i , tmp [ i ] ) ;
8211: LD_ADDR_VAR 0 5
8215: PUSH
8216: LD_VAR 0 5
8220: PPUSH
8221: LD_VAR 0 6
8225: PPUSH
8226: LD_VAR 0 2
8230: PUSH
8231: LD_VAR 0 6
8235: ARRAY
8236: PPUSH
8237: CALL_OW 1
8241: ST_TO_ADDR
// end ;
8242: GO 8196
8244: POP
8245: POP
// tmp := ar_force_tmp ;
8246: LD_ADDR_VAR 0 2
8250: PUSH
8251: LD_EXP 40
8255: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8256: LD_VAR 0 2
8260: PUSH
8261: LD_INT 1
8263: ARRAY
8264: PPUSH
8265: LD_INT 108
8267: PPUSH
8268: LD_INT 139
8270: PPUSH
8271: LD_INT 0
8273: PPUSH
8274: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8278: LD_VAR 0 2
8282: PUSH
8283: LD_INT 1
8285: ARRAY
8286: PPUSH
8287: LD_EXP 21
8291: PPUSH
8292: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8296: LD_VAR 0 2
8300: PUSH
8301: LD_INT 2
8303: ARRAY
8304: PPUSH
8305: LD_INT 114
8307: PPUSH
8308: LD_INT 132
8310: PPUSH
8311: LD_INT 0
8313: PPUSH
8314: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8318: LD_VAR 0 2
8322: PUSH
8323: LD_INT 3
8325: ARRAY
8326: PPUSH
8327: LD_INT 115
8329: PPUSH
8330: LD_INT 132
8332: PPUSH
8333: LD_INT 0
8335: PPUSH
8336: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8340: LD_VAR 0 2
8344: PUSH
8345: LD_INT 2
8347: ARRAY
8348: PUSH
8349: LD_VAR 0 2
8353: PUSH
8354: LD_INT 3
8356: ARRAY
8357: PUSH
8358: EMPTY
8359: LIST
8360: LIST
8361: PPUSH
8362: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8366: LD_VAR 0 4
8370: PPUSH
8371: LD_INT 83
8373: PPUSH
8374: LD_INT 123
8376: PPUSH
8377: CALL_OW 111
// Wait ( 0 0$01 ) ;
8381: LD_INT 35
8383: PPUSH
8384: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8388: LD_INT 90
8390: PPUSH
8391: LD_INT 144
8393: PPUSH
8394: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8398: LD_VAR 0 5
8402: PPUSH
8403: LD_INT 88
8405: PPUSH
8406: LD_INT 129
8408: PPUSH
8409: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8413: LD_ADDR_VAR 0 3
8417: PUSH
8418: LD_INT 92
8420: PUSH
8421: LD_INT 131
8423: PUSH
8424: EMPTY
8425: LIST
8426: LIST
8427: PUSH
8428: LD_INT 88
8430: PUSH
8431: LD_INT 127
8433: PUSH
8434: EMPTY
8435: LIST
8436: LIST
8437: PUSH
8438: LD_INT 91
8440: PUSH
8441: LD_INT 132
8443: PUSH
8444: EMPTY
8445: LIST
8446: LIST
8447: PUSH
8448: LD_INT 92
8450: PUSH
8451: LD_INT 134
8453: PUSH
8454: EMPTY
8455: LIST
8456: LIST
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: LIST
8462: LIST
8463: ST_TO_ADDR
// for i = 1 to sols do
8464: LD_ADDR_VAR 0 6
8468: PUSH
8469: DOUBLE
8470: LD_INT 1
8472: DEC
8473: ST_TO_ADDR
8474: LD_VAR 0 5
8478: PUSH
8479: FOR_TO
8480: IFFALSE 8553
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8482: LD_VAR 0 5
8486: PUSH
8487: LD_VAR 0 6
8491: ARRAY
8492: PPUSH
8493: LD_VAR 0 3
8497: PUSH
8498: LD_VAR 0 6
8502: ARRAY
8503: PUSH
8504: LD_INT 1
8506: ARRAY
8507: PPUSH
8508: LD_VAR 0 3
8512: PUSH
8513: LD_VAR 0 6
8517: ARRAY
8518: PUSH
8519: LD_INT 2
8521: ARRAY
8522: PPUSH
8523: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8527: LD_VAR 0 5
8531: PUSH
8532: LD_VAR 0 6
8536: ARRAY
8537: PPUSH
8538: CALL_OW 197
// AddComHold ( sols ) ;
8542: LD_VAR 0 5
8546: PPUSH
8547: CALL_OW 200
// end ;
8551: GO 8479
8553: POP
8554: POP
// repeat wait ( 0 0$1 ) ;
8555: LD_INT 35
8557: PPUSH
8558: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8562: LD_VAR 0 5
8566: PUSH
8567: LD_INT 1
8569: ARRAY
8570: PPUSH
8571: LD_INT 92
8573: PPUSH
8574: LD_INT 131
8576: PPUSH
8577: CALL_OW 297
8581: PUSH
8582: LD_INT 4
8584: LESS
8585: IFFALSE 8555
// CenterOnXY ( 96 , 139 ) ;
8587: LD_INT 96
8589: PPUSH
8590: LD_INT 139
8592: PPUSH
8593: CALL_OW 84
// wait ( 0 0$3 ) ;
8597: LD_INT 105
8599: PPUSH
8600: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8604: LD_INT 111
8606: PPUSH
8607: LD_INT 135
8609: PPUSH
8610: LD_INT 1
8612: PPUSH
8613: LD_INT 25
8615: NEG
8616: PPUSH
8617: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8621: LD_VAR 0 2
8625: PUSH
8626: LD_INT 2
8628: ARRAY
8629: PPUSH
8630: LD_VAR 0 2
8634: PUSH
8635: LD_INT 1
8637: ARRAY
8638: PPUSH
8639: CALL_OW 250
8643: PUSH
8644: LD_INT 3
8646: PLUS
8647: PPUSH
8648: LD_VAR 0 2
8652: PUSH
8653: LD_INT 1
8655: ARRAY
8656: PPUSH
8657: CALL_OW 251
8661: PPUSH
8662: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8666: LD_VAR 0 2
8670: PUSH
8671: LD_INT 3
8673: ARRAY
8674: PPUSH
8675: LD_INT 7
8677: PPUSH
8678: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8682: LD_VAR 0 2
8686: PUSH
8687: LD_INT 2
8689: ARRAY
8690: PPUSH
8691: LD_VAR 0 2
8695: PUSH
8696: LD_INT 1
8698: ARRAY
8699: PPUSH
8700: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8704: LD_INT 35
8706: PPUSH
8707: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8711: LD_VAR 0 2
8715: PUSH
8716: LD_INT 1
8718: ARRAY
8719: PPUSH
8720: LD_VAR 0 2
8724: PUSH
8725: LD_INT 2
8727: ARRAY
8728: PPUSH
8729: CALL_OW 296
8733: PUSH
8734: LD_INT 5
8736: LESS
8737: IFFALSE 8704
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8739: LD_VAR 0 2
8743: PUSH
8744: LD_INT 1
8746: ARRAY
8747: PPUSH
8748: LD_VAR 0 2
8752: PUSH
8753: LD_INT 2
8755: ARRAY
8756: PPUSH
8757: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8761: LD_VAR 0 2
8765: PUSH
8766: LD_INT 1
8768: ARRAY
8769: PPUSH
8770: LD_STRING D1a-Merc1-1
8772: PPUSH
8773: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8777: LD_VAR 0 2
8781: PUSH
8782: LD_INT 2
8784: ARRAY
8785: PPUSH
8786: LD_STRING D1a-FMerc2-1
8788: PPUSH
8789: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8793: LD_VAR 0 2
8797: PUSH
8798: LD_INT 2
8800: ARRAY
8801: PPUSH
8802: LD_VAR 0 2
8806: PUSH
8807: LD_INT 1
8809: ARRAY
8810: PPUSH
8811: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8815: LD_VAR 0 2
8819: PUSH
8820: LD_INT 1
8822: ARRAY
8823: PPUSH
8824: LD_INT 500
8826: PPUSH
8827: CALL_OW 234
// wait ( 0 0$2 ) ;
8831: LD_INT 70
8833: PPUSH
8834: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8838: LD_VAR 0 2
8842: PUSH
8843: LD_INT 1
8845: ARRAY
8846: PPUSH
8847: LD_INT 2
8849: PPUSH
8850: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8854: LD_INT 10
8856: PPUSH
8857: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8861: LD_VAR 0 2
8865: PUSH
8866: LD_INT 1
8868: ARRAY
8869: PPUSH
8870: LD_STRING D1a-Merc1-2
8872: PPUSH
8873: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8877: LD_INT 7
8879: PPUSH
8880: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8884: LD_VAR 0 2
8888: PUSH
8889: LD_INT 1
8891: ARRAY
8892: PPUSH
8893: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8897: LD_VAR 0 2
8901: PUSH
8902: LD_INT 2
8904: ARRAY
8905: PPUSH
8906: LD_INT 10
8908: PPUSH
8909: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8913: LD_VAR 0 2
8917: PUSH
8918: LD_INT 2
8920: ARRAY
8921: PPUSH
8922: LD_STRING D1a-FMerc2-2
8924: PPUSH
8925: CALL_OW 88
// wait ( 0 0$1 ) ;
8929: LD_INT 35
8931: PPUSH
8932: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8936: LD_INT 7
8938: PPUSH
8939: CALL_OW 85
// wait ( 0 0$2 ) ;
8943: LD_INT 70
8945: PPUSH
8946: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8950: LD_EXP 44
8954: PPUSH
8955: LD_STRING D1a-Saliba-1
8957: PPUSH
8958: CALL_OW 91
// KillUnit ( Saliba ) ;
8962: LD_EXP 44
8966: PPUSH
8967: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8971: LD_VAR 0 2
8975: PUSH
8976: LD_INT 3
8978: ARRAY
8979: PPUSH
8980: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8984: LD_EXP 21
8988: PPUSH
8989: CALL_OW 85
// wait ( 0 0$1 ) ;
8993: LD_INT 35
8995: PPUSH
8996: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9000: LD_VAR 0 5
9004: PPUSH
9005: LD_INT 88
9007: PPUSH
9008: LD_INT 141
9010: PPUSH
9011: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9015: LD_VAR 0 5
9019: PPUSH
9020: LD_INT 70
9022: PPUSH
9023: CALL_OW 202
// wait ( 0 0$2 ) ;
9027: LD_INT 70
9029: PPUSH
9030: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9034: LD_INT 2
9036: PPUSH
9037: LD_INT 1
9039: PPUSH
9040: LD_INT 2
9042: PPUSH
9043: LD_INT 1
9045: PPUSH
9046: CALL_OW 80
// InGameOff ;
9050: CALL_OW 9
// ComWalk ( sols ) ;
9054: LD_VAR 0 5
9058: PPUSH
9059: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9063: LD_STRING M1
9065: PPUSH
9066: CALL_OW 337
// game_speed := 4 ;
9070: LD_ADDR_OWVAR 65
9074: PUSH
9075: LD_INT 4
9077: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9078: LD_INT 111
9080: PPUSH
9081: LD_INT 135
9083: PPUSH
9084: LD_INT 1
9086: PPUSH
9087: CALL_OW 331
// SaveForQuickRestart ;
9091: CALL_OW 22
// ar_run := true ;
9095: LD_ADDR_EXP 5
9099: PUSH
9100: LD_INT 1
9102: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9103: LD_INT 35
9105: PPUSH
9106: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9110: LD_INT 22
9112: PUSH
9113: LD_INT 1
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: PUSH
9120: LD_INT 91
9122: PUSH
9123: LD_INT 7
9125: PUSH
9126: LD_INT 10
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: LIST
9133: PUSH
9134: EMPTY
9135: LIST
9136: LIST
9137: PPUSH
9138: CALL_OW 69
9142: PUSH
9143: LD_INT 7
9145: PPUSH
9146: CALL_OW 256
9150: PUSH
9151: LD_INT 999
9153: LESS
9154: OR
9155: IFFALSE 9103
// if GetSide ( ar_dep_s ) = 2 then
9157: LD_INT 7
9159: PPUSH
9160: CALL_OW 255
9164: PUSH
9165: LD_INT 2
9167: EQUAL
9168: IFFALSE 9180
// SetSide ( ar_dep_s , 1 ) ;
9170: LD_INT 7
9172: PPUSH
9173: LD_INT 1
9175: PPUSH
9176: CALL_OW 235
// end ;
9180: LD_VAR 0 1
9184: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9185: LD_EXP 5
9189: IFFALSE 9549
9191: GO 9193
9193: DISABLE
9194: LD_INT 0
9196: PPUSH
9197: PPUSH
9198: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9199: LD_ADDR_VAR 0 2
9203: PUSH
9204: LD_EXP 40
9208: PUSH
9209: LD_EXP 36
9213: PPUSH
9214: LD_INT 2
9216: PUSH
9217: LD_INT 21
9219: PUSH
9220: LD_INT 2
9222: PUSH
9223: EMPTY
9224: LIST
9225: LIST
9226: PUSH
9227: LD_INT 21
9229: PUSH
9230: LD_INT 1
9232: PUSH
9233: EMPTY
9234: LIST
9235: LIST
9236: PUSH
9237: EMPTY
9238: LIST
9239: LIST
9240: LIST
9241: PPUSH
9242: CALL_OW 72
9246: ADD
9247: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9248: LD_VAR 0 2
9252: PPUSH
9253: LD_INT 5
9255: PPUSH
9256: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9260: LD_INT 5
9262: PPUSH
9263: LD_INT 1
9265: PPUSH
9266: CALL_OW 343
// k := 1 ;
9270: LD_ADDR_VAR 0 3
9274: PUSH
9275: LD_INT 1
9277: ST_TO_ADDR
// for i in tmp do
9278: LD_ADDR_VAR 0 1
9282: PUSH
9283: LD_VAR 0 2
9287: PUSH
9288: FOR_IN
9289: IFFALSE 9374
// begin if IsInUnit ( i ) then
9291: LD_VAR 0 1
9295: PPUSH
9296: CALL_OW 310
9300: IFFALSE 9311
// ComExitBuilding ( i ) ;
9302: LD_VAR 0 1
9306: PPUSH
9307: CALL_OW 122
// if GetClass ( i ) = 3 then
9311: LD_VAR 0 1
9315: PPUSH
9316: CALL_OW 257
9320: PUSH
9321: LD_INT 3
9323: EQUAL
9324: IFFALSE 9360
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9326: LD_VAR 0 1
9330: PPUSH
9331: LD_EXP 41
9335: PUSH
9336: LD_VAR 0 3
9340: ARRAY
9341: PPUSH
9342: CALL_OW 180
// k := k + 1 ;
9346: LD_ADDR_VAR 0 3
9350: PUSH
9351: LD_VAR 0 3
9355: PUSH
9356: LD_INT 1
9358: PLUS
9359: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9360: LD_VAR 0 1
9364: PPUSH
9365: LD_INT 10
9367: PPUSH
9368: CALL_OW 173
// end ;
9372: GO 9288
9374: POP
9375: POP
// ar_patrol := true ;
9376: LD_ADDR_EXP 7
9380: PUSH
9381: LD_INT 1
9383: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9384: LD_INT 10
9386: PPUSH
9387: CALL_OW 67
// for i in tmp do
9391: LD_ADDR_VAR 0 1
9395: PUSH
9396: LD_VAR 0 2
9400: PUSH
9401: FOR_IN
9402: IFFALSE 9430
// if not HasTask ( i ) then
9404: LD_VAR 0 1
9408: PPUSH
9409: CALL_OW 314
9413: NOT
9414: IFFALSE 9428
// ComMoveToArea ( i , escape_area ) ;
9416: LD_VAR 0 1
9420: PPUSH
9421: LD_INT 10
9423: PPUSH
9424: CALL_OW 113
9428: GO 9401
9430: POP
9431: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9432: LD_ADDR_VAR 0 3
9436: PUSH
9437: LD_VAR 0 2
9441: PPUSH
9442: LD_INT 95
9444: PUSH
9445: LD_INT 10
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PPUSH
9452: CALL_OW 72
9456: ST_TO_ADDR
// if k then
9457: LD_VAR 0 3
9461: IFFALSE 9530
// for i in k do
9463: LD_ADDR_VAR 0 1
9467: PUSH
9468: LD_VAR 0 3
9472: PUSH
9473: FOR_IN
9474: IFFALSE 9528
// begin if IsInUnit ( i ) then
9476: LD_VAR 0 1
9480: PPUSH
9481: CALL_OW 310
9485: IFFALSE 9501
// RemoveUnit ( IsInUnit ( i ) ) ;
9487: LD_VAR 0 1
9491: PPUSH
9492: CALL_OW 310
9496: PPUSH
9497: CALL_OW 64
// RemoveUnit ( i ) ;
9501: LD_VAR 0 1
9505: PPUSH
9506: CALL_OW 64
// tmp := tmp diff i ;
9510: LD_ADDR_VAR 0 2
9514: PUSH
9515: LD_VAR 0 2
9519: PUSH
9520: LD_VAR 0 1
9524: DIFF
9525: ST_TO_ADDR
// end ;
9526: GO 9473
9528: POP
9529: POP
// until tmp = [ ] ;
9530: LD_VAR 0 2
9534: PUSH
9535: EMPTY
9536: EQUAL
9537: IFFALSE 9384
// ChangeSideFog ( 5 , 5 ) ;
9539: LD_INT 5
9541: PPUSH
9542: LD_INT 5
9544: PPUSH
9545: CALL_OW 343
// end ;
9549: PPOPN 3
9551: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9552: LD_EXP 7
9556: IFFALSE 9846
9558: GO 9560
9560: DISABLE
9561: LD_INT 0
9563: PPUSH
9564: PPUSH
9565: PPUSH
// begin uc_side := 2 ;
9566: LD_ADDR_OWVAR 20
9570: PUSH
9571: LD_INT 2
9573: ST_TO_ADDR
// uc_nation := 2 ;
9574: LD_ADDR_OWVAR 21
9578: PUSH
9579: LD_INT 2
9581: ST_TO_ADDR
// InitHc ;
9582: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9586: LD_INT 1
9588: PPUSH
9589: LD_INT 1
9591: PPUSH
9592: LD_INT 6
9594: PPUSH
9595: CALL_OW 380
// un := CreateHuman ;
9599: LD_ADDR_VAR 0 2
9603: PUSH
9604: CALL_OW 44
9608: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9609: LD_INT 14
9611: PPUSH
9612: LD_INT 1
9614: PPUSH
9615: LD_INT 1
9617: PPUSH
9618: LD_INT 27
9620: PPUSH
9621: LD_INT 98
9623: PPUSH
9624: CALL 52209 0 5
// veh := CreateVehicle ;
9628: LD_ADDR_VAR 0 3
9632: PUSH
9633: CALL_OW 45
9637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9638: LD_VAR 0 3
9642: PPUSH
9643: LD_INT 4
9645: PPUSH
9646: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9650: LD_VAR 0 3
9654: PPUSH
9655: LD_INT 179
9657: PPUSH
9658: LD_INT 135
9660: PPUSH
9661: LD_INT 0
9663: PPUSH
9664: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9668: LD_VAR 0 2
9672: PPUSH
9673: LD_VAR 0 3
9677: PPUSH
9678: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9682: LD_VAR 0 2
9686: PPUSH
9687: LD_INT 126
9689: PPUSH
9690: LD_INT 133
9692: PPUSH
9693: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9697: LD_INT 10
9699: PPUSH
9700: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9704: LD_INT 1
9706: PPUSH
9707: LD_VAR 0 3
9711: PPUSH
9712: CALL_OW 292
9716: PUSH
9717: LD_VAR 0 3
9721: PPUSH
9722: LD_INT 7
9724: PPUSH
9725: CALL_OW 296
9729: PUSH
9730: LD_INT 9
9732: LESS
9733: OR
9734: IFFALSE 9697
// ComHold ( veh ) ;
9736: LD_VAR 0 3
9740: PPUSH
9741: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9745: LD_VAR 0 2
9749: PPUSH
9750: LD_STRING D2aa-Ar1-1
9752: PPUSH
9753: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9757: LD_VAR 0 2
9761: PPUSH
9762: LD_INT 177
9764: PPUSH
9765: LD_INT 96
9767: PPUSH
9768: CALL_OW 111
// AddComExitVehicle ( un ) ;
9772: LD_VAR 0 2
9776: PPUSH
9777: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9781: LD_INT 35
9783: PPUSH
9784: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9788: LD_VAR 0 2
9792: PPUSH
9793: LD_INT 204
9795: PPUSH
9796: CALL_OW 296
9800: PUSH
9801: LD_INT 15
9803: LESS
9804: IFFALSE 9781
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9806: LD_ADDR_EXP 50
9810: PUSH
9811: LD_EXP 50
9815: PPUSH
9816: LD_INT 3
9818: PUSH
9819: LD_EXP 50
9823: PUSH
9824: LD_INT 3
9826: ARRAY
9827: PUSH
9828: LD_INT 1
9830: PLUS
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: PPUSH
9836: LD_VAR 0 2
9840: PPUSH
9841: CALL 52331 0 3
9845: ST_TO_ADDR
// end ;
9846: PPOPN 3
9848: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9849: LD_INT 7
9851: PPUSH
9852: CALL_OW 255
9856: PUSH
9857: LD_INT 1
9859: EQUAL
9860: PUSH
9861: LD_INT 7
9863: PPUSH
9864: CALL_OW 301
9868: OR
9869: IFFALSE 12273
9871: GO 9873
9873: DISABLE
9874: LD_INT 0
9876: PPUSH
9877: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9878: LD_ADDR_VAR 0 1
9882: PUSH
9883: LD_EXP 36
9887: PPUSH
9888: LD_INT 21
9890: PUSH
9891: LD_INT 3
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: PPUSH
9898: CALL_OW 72
9902: PUSH
9903: FOR_IN
9904: IFFALSE 9920
// SetSide ( i , 1 ) ;
9906: LD_VAR 0 1
9910: PPUSH
9911: LD_INT 1
9913: PPUSH
9914: CALL_OW 235
9918: GO 9903
9920: POP
9921: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9922: LD_ADDR_VAR 0 2
9926: PUSH
9927: LD_INT 46
9929: PUSH
9930: LD_INT 41
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: PUSH
9937: LD_INT 50
9939: PUSH
9940: LD_INT 25
9942: PUSH
9943: EMPTY
9944: LIST
9945: LIST
9946: PUSH
9947: LD_INT 57
9949: PUSH
9950: LD_INT 75
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PUSH
9957: LD_INT 75
9959: PUSH
9960: LD_INT 89
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: PUSH
9967: LD_INT 51
9969: PUSH
9970: LD_INT 45
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: PUSH
9977: LD_INT 95
9979: PUSH
9980: LD_INT 95
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: PUSH
9987: LD_INT 84
9989: PUSH
9990: LD_INT 77
9992: PUSH
9993: EMPTY
9994: LIST
9995: LIST
9996: PUSH
9997: LD_INT 101
9999: PUSH
10000: LD_INT 76
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: PUSH
10007: LD_INT 118
10009: PUSH
10010: LD_INT 81
10012: PUSH
10013: EMPTY
10014: LIST
10015: LIST
10016: PUSH
10017: LD_INT 139
10019: PUSH
10020: LD_INT 97
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: PUSH
10027: LD_INT 129
10029: PUSH
10030: LD_INT 114
10032: PUSH
10033: EMPTY
10034: LIST
10035: LIST
10036: PUSH
10037: LD_INT 154
10039: PUSH
10040: LD_INT 111
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: LIST
10051: LIST
10052: LIST
10053: LIST
10054: LIST
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: LIST
10060: ST_TO_ADDR
// base_captured := true ;
10061: LD_ADDR_EXP 6
10065: PUSH
10066: LD_INT 1
10068: ST_TO_ADDR
// DialogueOn ;
10069: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10073: LD_EXP 21
10077: PPUSH
10078: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10082: LD_EXP 21
10086: PPUSH
10087: LD_STRING D2-JMM-1
10089: PPUSH
10090: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10094: LD_EXP 30
10098: PPUSH
10099: LD_STRING D2-Pow-1
10101: PPUSH
10102: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10106: LD_EXP 21
10110: PPUSH
10111: LD_STRING D2-JMM-2
10113: PPUSH
10114: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10118: LD_EXP 30
10122: PPUSH
10123: LD_STRING D2-Pow-2
10125: PPUSH
10126: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10130: LD_EXP 21
10134: PPUSH
10135: LD_STRING D2-JMM-3
10137: PPUSH
10138: CALL_OW 88
// DialogueOff ;
10142: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10146: LD_STRING M2
10148: PPUSH
10149: CALL_OW 337
// Wait ( 0 0$2 ) ;
10153: LD_INT 70
10155: PPUSH
10156: CALL_OW 67
// if IsOk ( Gary ) then
10160: LD_EXP 32
10164: PPUSH
10165: CALL_OW 302
10169: IFFALSE 10183
// Say ( Gary , D2a-Gary-1 ) ;
10171: LD_EXP 32
10175: PPUSH
10176: LD_STRING D2a-Gary-1
10178: PPUSH
10179: CALL_OW 88
// if IsOk ( Bobby ) then
10183: LD_EXP 24
10187: PPUSH
10188: CALL_OW 302
10192: IFFALSE 10206
// Say ( Bobby , D2a-Bobby-1 ) ;
10194: LD_EXP 24
10198: PPUSH
10199: LD_STRING D2a-Bobby-1
10201: PPUSH
10202: CALL_OW 88
// if IsOk ( Cyrus ) then
10206: LD_EXP 25
10210: PPUSH
10211: CALL_OW 302
10215: IFFALSE 10229
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10217: LD_EXP 25
10221: PPUSH
10222: LD_STRING D2a-Cyrus-1
10224: PPUSH
10225: CALL_OW 88
// if IsOk ( Lisa ) then
10229: LD_EXP 22
10233: PPUSH
10234: CALL_OW 302
10238: IFFALSE 10252
// Say ( Lisa , D2a-Lisa-1 ) ;
10240: LD_EXP 22
10244: PPUSH
10245: LD_STRING D2a-Lisa-1
10247: PPUSH
10248: CALL_OW 88
// if IsOk ( Frank ) then
10252: LD_EXP 33
10256: PPUSH
10257: CALL_OW 302
10261: IFFALSE 10275
// Say ( Frank , D2a-Frank-1 ) ;
10263: LD_EXP 33
10267: PPUSH
10268: LD_STRING D2a-Frank-1
10270: PPUSH
10271: CALL_OW 88
// if IsOk ( Cornel ) then
10275: LD_EXP 31
10279: PPUSH
10280: CALL_OW 302
10284: IFFALSE 10298
// Say ( Cornel , D2a-Corn-1 ) ;
10286: LD_EXP 31
10290: PPUSH
10291: LD_STRING D2a-Corn-1
10293: PPUSH
10294: CALL_OW 88
// if IsOk ( Donaldson ) then
10298: LD_EXP 23
10302: PPUSH
10303: CALL_OW 302
10307: IFFALSE 10321
// Say ( Donaldson , D2a-Don-1 ) ;
10309: LD_EXP 23
10313: PPUSH
10314: LD_STRING D2a-Don-1
10316: PPUSH
10317: CALL_OW 88
// if IsOk ( Brown ) then
10321: LD_EXP 27
10325: PPUSH
10326: CALL_OW 302
10330: IFFALSE 10344
// Say ( Brown , D2a-Brown-1 ) ;
10332: LD_EXP 27
10336: PPUSH
10337: LD_STRING D2a-Brown-1
10339: PPUSH
10340: CALL_OW 88
// Wait ( 0 0$30 ) ;
10344: LD_INT 1050
10346: PPUSH
10347: CALL_OW 67
// if IsOk ( Frank ) then
10351: LD_EXP 33
10355: PPUSH
10356: CALL_OW 302
10360: IFFALSE 10626
// begin DialogueOn ;
10362: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10366: LD_EXP 21
10370: PUSH
10371: LD_EXP 33
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PPUSH
10380: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10384: LD_EXP 33
10388: PPUSH
10389: LD_STRING D3F-Frank-1
10391: PPUSH
10392: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10396: LD_EXP 21
10400: PPUSH
10401: LD_STRING D3F-JMM-1
10403: PPUSH
10404: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10408: LD_EXP 33
10412: PPUSH
10413: LD_STRING D3F-Frank-2
10415: PPUSH
10416: CALL_OW 88
// case Query ( QFrank ) of 1 :
10420: LD_STRING QFrank
10422: PPUSH
10423: CALL_OW 97
10427: PUSH
10428: LD_INT 1
10430: DOUBLE
10431: EQUAL
10432: IFTRUE 10436
10434: GO 10459
10436: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10437: LD_EXP 21
10441: PPUSH
10442: LD_STRING D3Fa-JMM-1
10444: PPUSH
10445: CALL_OW 88
// us_scout := 1 ;
10449: LD_ADDR_EXP 8
10453: PUSH
10454: LD_INT 1
10456: ST_TO_ADDR
// end ; 2 :
10457: GO 10622
10459: LD_INT 2
10461: DOUBLE
10462: EQUAL
10463: IFTRUE 10467
10465: GO 10589
10467: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10468: LD_EXP 21
10472: PPUSH
10473: LD_STRING D3Fb-JMM-1
10475: PPUSH
10476: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10480: LD_EXP 33
10484: PPUSH
10485: LD_STRING D3Fb-Frank-1
10487: PPUSH
10488: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10492: LD_STRING QFrank2
10494: PPUSH
10495: CALL_OW 97
10499: PUSH
10500: LD_INT 1
10502: DOUBLE
10503: EQUAL
10504: IFTRUE 10508
10506: GO 10555
10508: POP
// begin us_scout := 2 ;
10509: LD_ADDR_EXP 8
10513: PUSH
10514: LD_INT 2
10516: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10517: LD_EXP 21
10521: PPUSH
10522: LD_STRING D3Fba-JMM-1
10524: PPUSH
10525: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10529: LD_EXP 33
10533: PPUSH
10534: LD_STRING D3Fba-Frank-1
10536: PPUSH
10537: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10541: LD_EXP 21
10545: PPUSH
10546: LD_STRING D3Fba-JMM-2
10548: PPUSH
10549: CALL_OW 88
// end ; 2 :
10553: GO 10587
10555: LD_INT 2
10557: DOUBLE
10558: EQUAL
10559: IFTRUE 10563
10561: GO 10586
10563: POP
// begin us_scout := 0 ;
10564: LD_ADDR_EXP 8
10568: PUSH
10569: LD_INT 0
10571: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10572: LD_EXP 21
10576: PPUSH
10577: LD_STRING D3Fbb-JMM-1
10579: PPUSH
10580: CALL_OW 88
// end ; end ;
10584: GO 10587
10586: POP
// end ; 3 :
10587: GO 10622
10589: LD_INT 3
10591: DOUBLE
10592: EQUAL
10593: IFTRUE 10597
10595: GO 10621
10597: POP
// begin us_scout := - 1 ;
10598: LD_ADDR_EXP 8
10602: PUSH
10603: LD_INT 1
10605: NEG
10606: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10607: LD_EXP 21
10611: PPUSH
10612: LD_STRING D3Fc-JMM-1
10614: PPUSH
10615: CALL_OW 88
// end ; end ;
10619: GO 10622
10621: POP
// DialogueOff ;
10622: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10626: LD_EXP 8
10630: PUSH
10631: LD_INT 1
10633: NEG
10634: PUSH
10635: LD_INT 0
10637: PUSH
10638: EMPTY
10639: LIST
10640: LIST
10641: IN
10642: IFFALSE 10646
// exit ;
10644: GO 12273
// if us_scout in [ 1 , 2 ] then
10646: LD_EXP 8
10650: PUSH
10651: LD_INT 1
10653: PUSH
10654: LD_INT 2
10656: PUSH
10657: EMPTY
10658: LIST
10659: LIST
10660: IN
10661: IFFALSE 11340
// begin if IsInUnit ( Frank ) then
10663: LD_EXP 33
10667: PPUSH
10668: CALL_OW 310
10672: IFFALSE 10683
// ComExit ( Frank ) ;
10674: LD_EXP 33
10678: PPUSH
10679: CALL 83762 0 1
// SetSide ( Frank , 4 ) ;
10683: LD_EXP 33
10687: PPUSH
10688: LD_INT 4
10690: PPUSH
10691: CALL_OW 235
// wait ( 0 0$1 ) ;
10695: LD_INT 35
10697: PPUSH
10698: CALL_OW 67
// if us_scout = 2 then
10702: LD_EXP 8
10706: PUSH
10707: LD_INT 2
10709: EQUAL
10710: IFFALSE 11078
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10712: LD_EXP 33
10716: PPUSH
10717: LD_INT 75
10719: PPUSH
10720: LD_INT 63
10722: PPUSH
10723: CALL_OW 111
// AddComHold ( Frank ) ;
10727: LD_EXP 33
10731: PPUSH
10732: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10736: LD_EXP 33
10740: PPUSH
10741: LD_INT 770
10743: PPUSH
10744: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10748: LD_EXP 33
10752: PPUSH
10753: LD_INT 100
10755: PPUSH
10756: LD_INT 75
10758: PPUSH
10759: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10763: LD_EXP 33
10767: PPUSH
10768: LD_INT 123
10770: PPUSH
10771: LD_INT 103
10773: PPUSH
10774: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10778: LD_EXP 33
10782: PPUSH
10783: LD_INT 138
10785: PPUSH
10786: LD_INT 108
10788: PPUSH
10789: CALL_OW 171
// AddComHold ( Frank ) ;
10793: LD_EXP 33
10797: PPUSH
10798: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10802: LD_INT 35
10804: PPUSH
10805: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10809: LD_EXP 33
10813: PPUSH
10814: LD_INT 138
10816: PPUSH
10817: LD_INT 108
10819: PPUSH
10820: CALL_OW 307
10824: IFFALSE 10802
// AddComMoveXY ( Frank , 125 , 132 ) ;
10826: LD_EXP 33
10830: PPUSH
10831: LD_INT 125
10833: PPUSH
10834: LD_INT 132
10836: PPUSH
10837: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10841: LD_INT 35
10843: PPUSH
10844: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10848: LD_INT 1
10850: PPUSH
10851: LD_EXP 33
10855: PPUSH
10856: CALL_OW 292
10860: PUSH
10861: LD_EXP 33
10865: PPUSH
10866: LD_INT 7
10868: PPUSH
10869: CALL_OW 296
10873: PUSH
10874: LD_INT 7
10876: LESS
10877: OR
10878: IFFALSE 10841
// DialogueOn ;
10880: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10884: LD_EXP 33
10888: PPUSH
10889: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10893: LD_INT 10
10895: PPUSH
10896: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10900: LD_EXP 21
10904: PPUSH
10905: LD_STRING D4Fa-JMM-1
10907: PPUSH
10908: CALL_OW 88
// for i in points do
10912: LD_ADDR_VAR 0 1
10916: PUSH
10917: LD_VAR 0 2
10921: PUSH
10922: FOR_IN
10923: IFFALSE 10981
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10925: LD_VAR 0 1
10929: PUSH
10930: LD_INT 1
10932: ARRAY
10933: PPUSH
10934: LD_VAR 0 1
10938: PUSH
10939: LD_INT 2
10941: ARRAY
10942: PPUSH
10943: LD_INT 1
10945: PPUSH
10946: LD_INT 20
10948: NEG
10949: PPUSH
10950: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10954: LD_VAR 0 1
10958: PUSH
10959: LD_INT 1
10961: ARRAY
10962: PPUSH
10963: LD_VAR 0 1
10967: PUSH
10968: LD_INT 2
10970: ARRAY
10971: PPUSH
10972: LD_INT 1
10974: PPUSH
10975: CALL_OW 331
// end ;
10979: GO 10922
10981: POP
10982: POP
// dwait ( 0 0$0.5 ) ;
10983: LD_INT 18
10985: PPUSH
10986: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
10990: LD_INT 42
10992: PPUSH
10993: LD_INT 27
10995: PPUSH
10996: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11000: LD_EXP 33
11004: PPUSH
11005: LD_STRING D4Fa-Frank-1
11007: PPUSH
11008: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11012: LD_INT 18
11014: PPUSH
11015: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11019: LD_EXP 21
11023: PPUSH
11024: LD_STRING D4Fa-JMM-2
11026: PPUSH
11027: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11031: LD_INT 118
11033: PPUSH
11034: LD_INT 80
11036: PPUSH
11037: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11041: LD_EXP 33
11045: PPUSH
11046: LD_STRING D4Fa-Frank-2
11048: PPUSH
11049: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11053: LD_INT 10
11055: PPUSH
11056: CALL_OW 68
// DialogueOff ;
11060: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11064: LD_EXP 33
11068: PPUSH
11069: LD_INT 1
11071: PPUSH
11072: CALL_OW 235
// end else
11076: GO 11340
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11078: LD_INT 2
11080: PPUSH
11081: LD_INT 4
11083: PPUSH
11084: LD_INT 2
11086: PPUSH
11087: LD_INT 1
11089: PPUSH
11090: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11094: LD_EXP 33
11098: PPUSH
11099: LD_INT 75
11101: PPUSH
11102: LD_INT 63
11104: PPUSH
11105: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11109: LD_EXP 33
11113: PPUSH
11114: LD_INT 175
11116: PPUSH
11117: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11121: LD_EXP 33
11125: PPUSH
11126: LD_INT 102
11128: PPUSH
11129: LD_INT 76
11131: PPUSH
11132: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11136: LD_EXP 33
11140: PPUSH
11141: LD_INT 108
11143: PPUSH
11144: LD_INT 70
11146: PPUSH
11147: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11151: LD_INT 35
11153: PPUSH
11154: CALL_OW 67
// until See ( 2 , Frank ) ;
11158: LD_INT 2
11160: PPUSH
11161: LD_EXP 33
11165: PPUSH
11166: CALL_OW 292
11170: IFFALSE 11151
// ComMoveXY ( Frank , 112 , 118 ) ;
11172: LD_EXP 33
11176: PPUSH
11177: LD_INT 112
11179: PPUSH
11180: LD_INT 118
11182: PPUSH
11183: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11187: LD_EXP 33
11191: PPUSH
11192: CALL_OW 256
11196: PUSH
11197: LD_INT 750
11199: GREATEREQUAL
11200: IFFALSE 11214
// SetLives ( Frank , 700 ) ;
11202: LD_EXP 33
11206: PPUSH
11207: LD_INT 700
11209: PPUSH
11210: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11214: LD_INT 35
11216: PPUSH
11217: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11221: LD_INT 1
11223: PPUSH
11224: LD_EXP 33
11228: PPUSH
11229: CALL_OW 292
11233: PUSH
11234: LD_EXP 33
11238: PPUSH
11239: LD_INT 7
11241: PPUSH
11242: CALL_OW 296
11246: PUSH
11247: LD_INT 17
11249: LESS
11250: OR
11251: IFFALSE 11214
// DialogueOn ;
11253: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11257: LD_EXP 33
11261: PPUSH
11262: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11266: LD_EXP 33
11270: PPUSH
11271: LD_STRING D4Fb-Frank-1
11273: PPUSH
11274: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11278: LD_EXP 21
11282: PPUSH
11283: LD_STRING D4Fb-JMM-1
11285: PPUSH
11286: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11290: LD_INT 2
11292: PPUSH
11293: LD_STRING D4Fb-FSci1-1
11295: PPUSH
11296: CALL 16177 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11300: LD_EXP 33
11304: PPUSH
11305: LD_STRING D4Fb-Frank-2
11307: PPUSH
11308: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11312: LD_EXP 21
11316: PPUSH
11317: LD_STRING D4Fb-JMM-2
11319: PPUSH
11320: CALL_OW 88
// DialogueOff ;
11324: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11328: LD_EXP 33
11332: PPUSH
11333: LD_INT 1
11335: PPUSH
11336: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11340: LD_EXP 34
11344: PPUSH
11345: CALL_OW 302
11349: PUSH
11350: LD_EXP 33
11354: NOT
11355: AND
11356: IFFALSE 11504
// begin DialogueOn ;
11358: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11362: LD_EXP 21
11366: PUSH
11367: LD_EXP 34
11371: PUSH
11372: EMPTY
11373: LIST
11374: LIST
11375: PPUSH
11376: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11380: LD_EXP 34
11384: PPUSH
11385: LD_STRING D3Y-Yam-1
11387: PPUSH
11388: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11392: LD_EXP 21
11396: PPUSH
11397: LD_STRING D3Y-JMM-1
11399: PPUSH
11400: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11404: LD_EXP 34
11408: PPUSH
11409: LD_STRING D3Y-Yam-2
11411: PPUSH
11412: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11416: LD_STRING QYamoko
11418: PPUSH
11419: CALL_OW 97
11423: PUSH
11424: LD_INT 1
11426: DOUBLE
11427: EQUAL
11428: IFTRUE 11432
11430: GO 11467
11432: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11433: LD_EXP 21
11437: PPUSH
11438: LD_STRING D3Ya-JMM-1
11440: PPUSH
11441: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11445: LD_EXP 34
11449: PPUSH
11450: LD_STRING D3Ya-Yam-1
11452: PPUSH
11453: CALL_OW 88
// us_scout := 1 ;
11457: LD_ADDR_EXP 8
11461: PUSH
11462: LD_INT 1
11464: ST_TO_ADDR
// end ; 2 :
11465: GO 11500
11467: LD_INT 2
11469: DOUBLE
11470: EQUAL
11471: IFTRUE 11475
11473: GO 11499
11475: POP
// begin us_scout := - 1 ;
11476: LD_ADDR_EXP 8
11480: PUSH
11481: LD_INT 1
11483: NEG
11484: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11485: LD_EXP 21
11489: PPUSH
11490: LD_STRING D3Yb-JMM-1
11492: PPUSH
11493: CALL_OW 88
// end ; end ;
11497: GO 11500
11499: POP
// DialogueOff ;
11500: CALL_OW 7
// end ; if Frank then
11504: LD_EXP 33
11508: IFFALSE 11512
// exit ;
11510: GO 12273
// if us_scout in [ - 1 , 0 ] then
11512: LD_EXP 8
11516: PUSH
11517: LD_INT 1
11519: NEG
11520: PUSH
11521: LD_INT 0
11523: PUSH
11524: EMPTY
11525: LIST
11526: LIST
11527: IN
11528: IFFALSE 11532
// exit ;
11530: GO 12273
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11532: LD_ADDR_EXP 8
11536: PUSH
11537: LD_INT 2
11539: PUSH
11540: LD_INT 2
11542: PUSH
11543: LD_INT 1
11545: PUSH
11546: EMPTY
11547: LIST
11548: LIST
11549: LIST
11550: PUSH
11551: LD_OWVAR 67
11555: ARRAY
11556: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11557: LD_EXP 8
11561: PUSH
11562: LD_INT 1
11564: PUSH
11565: LD_INT 2
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: IN
11572: IFFALSE 12273
// begin if IsInUnit ( Kikuchi ) then
11574: LD_EXP 34
11578: PPUSH
11579: CALL_OW 310
11583: IFFALSE 11594
// ComExitBuilding ( Kikuchi ) ;
11585: LD_EXP 34
11589: PPUSH
11590: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11594: LD_EXP 34
11598: PPUSH
11599: CALL_OW 311
11603: IFFALSE 11614
// ComExitVehicle ( Kikuchi ) ;
11605: LD_EXP 34
11609: PPUSH
11610: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11614: LD_EXP 34
11618: PPUSH
11619: LD_INT 4
11621: PPUSH
11622: CALL_OW 235
// wait ( 0 0$1 ) ;
11626: LD_INT 35
11628: PPUSH
11629: CALL_OW 67
// if us_scout = 2 then
11633: LD_EXP 8
11637: PUSH
11638: LD_INT 2
11640: EQUAL
11641: IFFALSE 12021
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11643: LD_EXP 34
11647: PPUSH
11648: LD_INT 75
11650: PPUSH
11651: LD_INT 63
11653: PPUSH
11654: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11658: LD_EXP 34
11662: PPUSH
11663: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11667: LD_EXP 34
11671: PPUSH
11672: LD_INT 770
11674: PPUSH
11675: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11679: LD_EXP 34
11683: PPUSH
11684: LD_INT 100
11686: PPUSH
11687: LD_INT 75
11689: PPUSH
11690: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11694: LD_EXP 34
11698: PPUSH
11699: LD_INT 123
11701: PPUSH
11702: LD_INT 103
11704: PPUSH
11705: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11709: LD_EXP 34
11713: PPUSH
11714: LD_INT 138
11716: PPUSH
11717: LD_INT 108
11719: PPUSH
11720: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11724: LD_EXP 34
11728: PPUSH
11729: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11733: LD_INT 35
11735: PPUSH
11736: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11740: LD_EXP 34
11744: PPUSH
11745: LD_INT 138
11747: PPUSH
11748: LD_INT 108
11750: PPUSH
11751: CALL_OW 307
11755: IFFALSE 11733
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11757: LD_EXP 34
11761: PPUSH
11762: LD_INT 125
11764: PPUSH
11765: LD_INT 132
11767: PPUSH
11768: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11772: LD_INT 35
11774: PPUSH
11775: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11779: LD_INT 1
11781: PPUSH
11782: LD_EXP 34
11786: PPUSH
11787: CALL_OW 292
11791: PUSH
11792: LD_EXP 34
11796: PPUSH
11797: LD_INT 7
11799: PPUSH
11800: CALL_OW 296
11804: PUSH
11805: LD_INT 7
11807: LESS
11808: OR
11809: IFFALSE 11772
// DialogueOn ;
11811: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11815: LD_EXP 34
11819: PPUSH
11820: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11824: LD_INT 10
11826: PPUSH
11827: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11831: LD_EXP 34
11835: PPUSH
11836: LD_STRING D4Ya-Yam-1
11838: PPUSH
11839: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11843: LD_EXP 21
11847: PPUSH
11848: LD_STRING D4Ya-JMM-1
11850: PPUSH
11851: CALL_OW 88
// for i in points do
11855: LD_ADDR_VAR 0 1
11859: PUSH
11860: LD_VAR 0 2
11864: PUSH
11865: FOR_IN
11866: IFFALSE 11924
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11868: LD_VAR 0 1
11872: PUSH
11873: LD_INT 1
11875: ARRAY
11876: PPUSH
11877: LD_VAR 0 1
11881: PUSH
11882: LD_INT 2
11884: ARRAY
11885: PPUSH
11886: LD_INT 1
11888: PPUSH
11889: LD_INT 20
11891: NEG
11892: PPUSH
11893: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11897: LD_VAR 0 1
11901: PUSH
11902: LD_INT 1
11904: ARRAY
11905: PPUSH
11906: LD_VAR 0 1
11910: PUSH
11911: LD_INT 2
11913: ARRAY
11914: PPUSH
11915: LD_INT 1
11917: PPUSH
11918: CALL_OW 331
// end ;
11922: GO 11865
11924: POP
11925: POP
// dwait ( 0 0$0.5 ) ;
11926: LD_INT 18
11928: PPUSH
11929: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11933: LD_INT 42
11935: PPUSH
11936: LD_INT 27
11938: PPUSH
11939: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11943: LD_EXP 34
11947: PPUSH
11948: LD_STRING D4Ya-Yam-2
11950: PPUSH
11951: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11955: LD_INT 18
11957: PPUSH
11958: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11962: LD_INT 118
11964: PPUSH
11965: LD_INT 80
11967: PPUSH
11968: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11972: LD_EXP 21
11976: PPUSH
11977: LD_STRING D4Ya-JMM-2
11979: PPUSH
11980: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
11984: LD_EXP 34
11988: PPUSH
11989: LD_STRING D4Ya-Yam-3
11991: PPUSH
11992: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11996: LD_INT 10
11998: PPUSH
11999: CALL_OW 68
// DialogueOff ;
12003: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12007: LD_EXP 34
12011: PPUSH
12012: LD_INT 1
12014: PPUSH
12015: CALL_OW 235
// end else
12019: GO 12273
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12021: LD_INT 2
12023: PPUSH
12024: LD_INT 4
12026: PPUSH
12027: LD_INT 2
12029: PPUSH
12030: LD_INT 1
12032: PPUSH
12033: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12037: LD_EXP 34
12041: PPUSH
12042: LD_INT 75
12044: PPUSH
12045: LD_INT 63
12047: PPUSH
12048: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12052: LD_EXP 34
12056: PPUSH
12057: LD_INT 175
12059: PPUSH
12060: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12064: LD_EXP 34
12068: PPUSH
12069: LD_INT 102
12071: PPUSH
12072: LD_INT 76
12074: PPUSH
12075: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12079: LD_EXP 34
12083: PPUSH
12084: LD_INT 108
12086: PPUSH
12087: LD_INT 70
12089: PPUSH
12090: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12094: LD_INT 35
12096: PPUSH
12097: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12101: LD_INT 2
12103: PPUSH
12104: LD_EXP 34
12108: PPUSH
12109: CALL_OW 292
12113: IFFALSE 12094
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12115: LD_EXP 34
12119: PPUSH
12120: LD_INT 112
12122: PPUSH
12123: LD_INT 118
12125: PPUSH
12126: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12130: LD_EXP 34
12134: PPUSH
12135: CALL_OW 256
12139: PUSH
12140: LD_INT 750
12142: GREATEREQUAL
12143: IFFALSE 12157
// SetLives ( Kikuchi , 700 ) ;
12145: LD_EXP 34
12149: PPUSH
12150: LD_INT 700
12152: PPUSH
12153: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12157: LD_INT 35
12159: PPUSH
12160: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12164: LD_INT 1
12166: PPUSH
12167: LD_EXP 34
12171: PPUSH
12172: CALL_OW 292
12176: PUSH
12177: LD_EXP 34
12181: PPUSH
12182: LD_INT 7
12184: PPUSH
12185: CALL_OW 296
12189: PUSH
12190: LD_INT 17
12192: LESS
12193: OR
12194: IFFALSE 12157
// DialogueOn ;
12196: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12200: LD_EXP 34
12204: PPUSH
12205: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12209: LD_EXP 34
12213: PPUSH
12214: LD_STRING D4Yb-Yam-1
12216: PPUSH
12217: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12221: LD_EXP 21
12225: PPUSH
12226: LD_STRING D4Yb-JMM-1
12228: PPUSH
12229: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12233: LD_EXP 34
12237: PPUSH
12238: LD_STRING D4Yb-Yam-2
12240: PPUSH
12241: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12245: LD_EXP 21
12249: PPUSH
12250: LD_STRING D4Yb-JMM-2
12252: PPUSH
12253: CALL_OW 88
// DialogueOff ;
12257: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12261: LD_EXP 34
12265: PPUSH
12266: LD_INT 1
12268: PPUSH
12269: CALL_OW 235
// end ; end ; end ;
12273: PPOPN 2
12275: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12276: LD_EXP 6
12280: IFFALSE 13313
12282: GO 12284
12284: DISABLE
12285: LD_INT 0
12287: PPUSH
12288: PPUSH
12289: PPUSH
12290: PPUSH
// begin enable ;
12291: ENABLE
// if not seen [ 1 ] then
12292: LD_EXP 9
12296: PUSH
12297: LD_INT 1
12299: ARRAY
12300: NOT
12301: IFFALSE 12481
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12303: LD_ADDR_VAR 0 2
12307: PUSH
12308: LD_INT 22
12310: PUSH
12311: LD_INT 2
12313: PUSH
12314: EMPTY
12315: LIST
12316: LIST
12317: PUSH
12318: LD_INT 2
12320: PUSH
12321: LD_INT 25
12323: PUSH
12324: LD_INT 11
12326: PUSH
12327: EMPTY
12328: LIST
12329: LIST
12330: PUSH
12331: LD_INT 33
12333: PUSH
12334: LD_INT 4
12336: PUSH
12337: EMPTY
12338: LIST
12339: LIST
12340: PUSH
12341: EMPTY
12342: LIST
12343: LIST
12344: LIST
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PPUSH
12350: CALL_OW 69
12354: ST_TO_ADDR
// if tmp then
12355: LD_VAR 0 2
12359: IFFALSE 12481
// for i in tmp do
12361: LD_ADDR_VAR 0 1
12365: PUSH
12366: LD_VAR 0 2
12370: PUSH
12371: FOR_IN
12372: IFFALSE 12479
// if See ( 1 , i ) then
12374: LD_INT 1
12376: PPUSH
12377: LD_VAR 0 1
12381: PPUSH
12382: CALL_OW 292
12386: IFFALSE 12477
// begin seen := Replace ( seen , 1 , true ) ;
12388: LD_ADDR_EXP 9
12392: PUSH
12393: LD_EXP 9
12397: PPUSH
12398: LD_INT 1
12400: PPUSH
12401: LD_INT 1
12403: PPUSH
12404: CALL_OW 1
12408: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12409: LD_INT 1
12411: PPUSH
12412: CALL 15999 0 1
12416: IFFALSE 12477
// begin DialogueOn ;
12418: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12422: LD_VAR 0 1
12426: PPUSH
12427: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12431: LD_INT 10
12433: PPUSH
12434: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12438: LD_ADDR_VAR 0 3
12442: PUSH
12443: LD_INT 1
12445: PPUSH
12446: LD_STRING D5a-Sol2-1
12448: PPUSH
12449: CALL 16177 0 2
12453: ST_TO_ADDR
// if not un then
12454: LD_VAR 0 3
12458: NOT
12459: IFFALSE 12471
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12461: LD_INT 2
12463: PPUSH
12464: LD_STRING D5a-FSol2-1
12466: PPUSH
12467: CALL 16177 0 2
// DialogueOff ;
12471: CALL_OW 7
// break ;
12475: GO 12479
// end ; end ;
12477: GO 12371
12479: POP
12480: POP
// end ; if not seen [ 2 ] then
12481: LD_EXP 9
12485: PUSH
12486: LD_INT 2
12488: ARRAY
12489: NOT
12490: IFFALSE 12715
// begin can_kamikazed := true ;
12492: LD_ADDR_EXP 10
12496: PUSH
12497: LD_INT 1
12499: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12500: LD_ADDR_VAR 0 2
12504: PUSH
12505: LD_INT 22
12507: PUSH
12508: LD_INT 2
12510: PUSH
12511: EMPTY
12512: LIST
12513: LIST
12514: PUSH
12515: LD_INT 25
12517: PUSH
12518: LD_INT 17
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: PUSH
12525: EMPTY
12526: LIST
12527: LIST
12528: PPUSH
12529: CALL_OW 69
12533: ST_TO_ADDR
// if tmp then
12534: LD_VAR 0 2
12538: IFFALSE 12715
// for i in tmp do
12540: LD_ADDR_VAR 0 1
12544: PUSH
12545: LD_VAR 0 2
12549: PUSH
12550: FOR_IN
12551: IFFALSE 12713
// if See ( 1 , i ) then
12553: LD_INT 1
12555: PPUSH
12556: LD_VAR 0 1
12560: PPUSH
12561: CALL_OW 292
12565: IFFALSE 12711
// begin seen := Replace ( seen , 2 , true ) ;
12567: LD_ADDR_EXP 9
12571: PUSH
12572: LD_EXP 9
12576: PPUSH
12577: LD_INT 2
12579: PPUSH
12580: LD_INT 1
12582: PPUSH
12583: CALL_OW 1
12587: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12588: LD_INT 1
12590: PPUSH
12591: CALL 15999 0 1
12595: IFFALSE 12711
// begin DialogueOn ;
12597: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12601: LD_VAR 0 1
12605: PPUSH
12606: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12610: LD_INT 10
12612: PPUSH
12613: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12617: LD_ADDR_VAR 0 3
12621: PUSH
12622: LD_INT 1
12624: PPUSH
12625: LD_STRING D5b-Sol1-1
12627: PPUSH
12628: CALL 16177 0 2
12632: ST_TO_ADDR
// if not un then
12633: LD_VAR 0 3
12637: NOT
12638: IFFALSE 12656
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12640: LD_ADDR_VAR 0 3
12644: PUSH
12645: LD_INT 2
12647: PPUSH
12648: LD_STRING D5b-FSol1-1
12650: PPUSH
12651: CALL 16177 0 2
12655: ST_TO_ADDR
// if un then
12656: LD_VAR 0 3
12660: IFFALSE 12705
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12662: LD_ADDR_VAR 0 4
12666: PUSH
12667: LD_INT 1
12669: PPUSH
12670: LD_STRING D5b-Sol2-1
12672: PPUSH
12673: LD_VAR 0 3
12677: PPUSH
12678: CALL 16403 0 3
12682: ST_TO_ADDR
// if not un2 then
12683: LD_VAR 0 4
12687: NOT
12688: IFFALSE 12705
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12690: LD_INT 2
12692: PPUSH
12693: LD_STRING D5b-FSol2-1
12695: PPUSH
12696: LD_VAR 0 3
12700: PPUSH
12701: CALL 16403 0 3
// end ; DialogueOff ;
12705: CALL_OW 7
// break ;
12709: GO 12713
// end ; end ;
12711: GO 12550
12713: POP
12714: POP
// end ; if not seen [ 3 ] then
12715: LD_EXP 9
12719: PUSH
12720: LD_INT 3
12722: ARRAY
12723: NOT
12724: IFFALSE 12898
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12726: LD_ADDR_VAR 0 2
12730: PUSH
12731: LD_INT 22
12733: PUSH
12734: LD_INT 2
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: PUSH
12741: LD_INT 33
12743: PUSH
12744: LD_INT 2
12746: PUSH
12747: EMPTY
12748: LIST
12749: LIST
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PPUSH
12755: CALL_OW 69
12759: ST_TO_ADDR
// if tmp then
12760: LD_VAR 0 2
12764: IFFALSE 12898
// for i in tmp do
12766: LD_ADDR_VAR 0 1
12770: PUSH
12771: LD_VAR 0 2
12775: PUSH
12776: FOR_IN
12777: IFFALSE 12896
// if See ( 1 , i ) then
12779: LD_INT 1
12781: PPUSH
12782: LD_VAR 0 1
12786: PPUSH
12787: CALL_OW 292
12791: IFFALSE 12894
// begin seen := Replace ( seen , 3 , true ) ;
12793: LD_ADDR_EXP 9
12797: PUSH
12798: LD_EXP 9
12802: PPUSH
12803: LD_INT 3
12805: PPUSH
12806: LD_INT 1
12808: PPUSH
12809: CALL_OW 1
12813: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12814: LD_INT 1
12816: PPUSH
12817: CALL 15999 0 1
12821: IFFALSE 12894
// begin DialogueOn ;
12823: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12827: LD_VAR 0 1
12831: PPUSH
12832: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12836: LD_INT 10
12838: PPUSH
12839: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12843: LD_ADDR_VAR 0 3
12847: PUSH
12848: LD_INT 1
12850: PPUSH
12851: LD_STRING D8-Sol1-1
12853: PPUSH
12854: CALL 16177 0 2
12858: ST_TO_ADDR
// if not un then
12859: LD_VAR 0 3
12863: NOT
12864: IFFALSE 12876
// SayRand ( sex_female , D8-FSol1-1 ) ;
12866: LD_INT 2
12868: PPUSH
12869: LD_STRING D8-FSol1-1
12871: PPUSH
12872: CALL 16177 0 2
// Say ( JMM , D8-JMM-1 ) ;
12876: LD_EXP 21
12880: PPUSH
12881: LD_STRING D8-JMM-1
12883: PPUSH
12884: CALL_OW 88
// DialogueOff ;
12888: CALL_OW 7
// break ;
12892: GO 12896
// end ; end ;
12894: GO 12776
12896: POP
12897: POP
// end ; if not seen [ 4 ] then
12898: LD_EXP 9
12902: PUSH
12903: LD_INT 4
12905: ARRAY
12906: NOT
12907: IFFALSE 13069
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12909: LD_ADDR_VAR 0 2
12913: PUSH
12914: LD_INT 22
12916: PUSH
12917: LD_INT 2
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: PUSH
12924: LD_INT 33
12926: PUSH
12927: LD_INT 5
12929: PUSH
12930: EMPTY
12931: LIST
12932: LIST
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: PPUSH
12938: CALL_OW 69
12942: ST_TO_ADDR
// if tmp then
12943: LD_VAR 0 2
12947: IFFALSE 13069
// for i in tmp do
12949: LD_ADDR_VAR 0 1
12953: PUSH
12954: LD_VAR 0 2
12958: PUSH
12959: FOR_IN
12960: IFFALSE 13067
// if See ( 1 , i ) then
12962: LD_INT 1
12964: PPUSH
12965: LD_VAR 0 1
12969: PPUSH
12970: CALL_OW 292
12974: IFFALSE 13065
// begin seen := Replace ( seen , 4 , true ) ;
12976: LD_ADDR_EXP 9
12980: PUSH
12981: LD_EXP 9
12985: PPUSH
12986: LD_INT 4
12988: PPUSH
12989: LD_INT 1
12991: PPUSH
12992: CALL_OW 1
12996: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12997: LD_INT 1
12999: PPUSH
13000: CALL 15999 0 1
13004: IFFALSE 13065
// begin DialogueOn ;
13006: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13010: LD_VAR 0 1
13014: PPUSH
13015: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13019: LD_INT 10
13021: PPUSH
13022: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13026: LD_ADDR_VAR 0 3
13030: PUSH
13031: LD_INT 1
13033: PPUSH
13034: LD_STRING D5a-Sol1-1
13036: PPUSH
13037: CALL 16177 0 2
13041: ST_TO_ADDR
// if not un then
13042: LD_VAR 0 3
13046: NOT
13047: IFFALSE 13059
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13049: LD_INT 2
13051: PPUSH
13052: LD_STRING D5a-FSol1-1
13054: PPUSH
13055: CALL 16177 0 2
// DialogueOff ;
13059: CALL_OW 7
// break ;
13063: GO 13067
// end ; end ;
13065: GO 12959
13067: POP
13068: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13069: LD_EXP 9
13073: PUSH
13074: LD_INT 5
13076: ARRAY
13077: NOT
13078: PUSH
13079: LD_EXP 9
13083: PUSH
13084: LD_INT 3
13086: ARRAY
13087: AND
13088: IFFALSE 13262
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13090: LD_ADDR_VAR 0 2
13094: PUSH
13095: LD_INT 22
13097: PUSH
13098: LD_INT 2
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: PUSH
13105: LD_INT 34
13107: PUSH
13108: LD_INT 31
13110: PUSH
13111: EMPTY
13112: LIST
13113: LIST
13114: PUSH
13115: EMPTY
13116: LIST
13117: LIST
13118: PPUSH
13119: CALL_OW 69
13123: ST_TO_ADDR
// if tmp then
13124: LD_VAR 0 2
13128: IFFALSE 13262
// for i in tmp do
13130: LD_ADDR_VAR 0 1
13134: PUSH
13135: LD_VAR 0 2
13139: PUSH
13140: FOR_IN
13141: IFFALSE 13260
// if See ( 1 , i ) then
13143: LD_INT 1
13145: PPUSH
13146: LD_VAR 0 1
13150: PPUSH
13151: CALL_OW 292
13155: IFFALSE 13258
// begin seen := Replace ( seen , 5 , true ) ;
13157: LD_ADDR_EXP 9
13161: PUSH
13162: LD_EXP 9
13166: PPUSH
13167: LD_INT 5
13169: PPUSH
13170: LD_INT 1
13172: PPUSH
13173: CALL_OW 1
13177: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13178: LD_INT 1
13180: PPUSH
13181: CALL 15999 0 1
13185: IFFALSE 13258
// begin DialogueOn ;
13187: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13191: LD_VAR 0 1
13195: PPUSH
13196: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13200: LD_INT 10
13202: PPUSH
13203: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13207: LD_ADDR_VAR 0 3
13211: PUSH
13212: LD_INT 1
13214: PPUSH
13215: LD_STRING D8a-Sol2-1
13217: PPUSH
13218: CALL 16177 0 2
13222: ST_TO_ADDR
// if not un then
13223: LD_VAR 0 3
13227: NOT
13228: IFFALSE 13240
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13230: LD_INT 2
13232: PPUSH
13233: LD_STRING D8a-FSol2-1
13235: PPUSH
13236: CALL 16177 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13240: LD_EXP 21
13244: PPUSH
13245: LD_STRING D8a-JMM-1
13247: PPUSH
13248: CALL_OW 88
// DialogueOff ;
13252: CALL_OW 7
// break ;
13256: GO 13260
// end ; end ;
13258: GO 13140
13260: POP
13261: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13262: LD_EXP 9
13266: PUSH
13267: LD_INT 1
13269: ARRAY
13270: PUSH
13271: LD_EXP 9
13275: PUSH
13276: LD_INT 2
13278: ARRAY
13279: AND
13280: PUSH
13281: LD_EXP 9
13285: PUSH
13286: LD_INT 3
13288: ARRAY
13289: AND
13290: PUSH
13291: LD_EXP 9
13295: PUSH
13296: LD_INT 4
13298: ARRAY
13299: AND
13300: PUSH
13301: LD_EXP 9
13305: PUSH
13306: LD_INT 5
13308: ARRAY
13309: AND
13310: IFFALSE 13313
// disable ;
13312: DISABLE
// end ;
13313: PPOPN 4
13315: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13316: LD_EXP 10
13320: PUSH
13321: LD_EXP 11
13325: AND
13326: IFFALSE 13524
13328: GO 13330
13330: DISABLE
13331: LD_INT 0
13333: PPUSH
// begin DialogueOn ;
13334: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13338: LD_EXP 11
13342: PPUSH
13343: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13347: LD_ADDR_VAR 0 1
13351: PUSH
13352: LD_INT 1
13354: PPUSH
13355: LD_STRING D5c-Sol1-1
13357: PPUSH
13358: CALL 16177 0 2
13362: ST_TO_ADDR
// if not un then
13363: LD_VAR 0 1
13367: NOT
13368: IFFALSE 13386
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13370: LD_ADDR_VAR 0 1
13374: PUSH
13375: LD_INT 2
13377: PPUSH
13378: LD_STRING D5c-FSol1-1
13380: PPUSH
13381: CALL 16177 0 2
13385: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13386: LD_EXP 21
13390: PPUSH
13391: LD_STRING D5c-JMM-1
13393: PPUSH
13394: CALL_OW 88
// if IsOk ( Lisa ) then
13398: LD_EXP 22
13402: PPUSH
13403: CALL_OW 302
13407: IFFALSE 13423
// Say ( Lisa , D5d-Lisa-1 ) else
13409: LD_EXP 22
13413: PPUSH
13414: LD_STRING D5d-Lisa-1
13416: PPUSH
13417: CALL_OW 88
13421: GO 13508
// if IsOk ( Cyrus ) then
13423: LD_EXP 25
13427: PPUSH
13428: CALL_OW 302
13432: IFFALSE 13448
// Say ( Cyrus , D5d-Cyrus-1 ) else
13434: LD_EXP 25
13438: PPUSH
13439: LD_STRING D5d-Cyrus-1
13441: PPUSH
13442: CALL_OW 88
13446: GO 13508
// if IsOk ( Gary ) then
13448: LD_EXP 32
13452: PPUSH
13453: CALL_OW 302
13457: IFFALSE 13473
// Say ( Gary , D5d-Gary-1 ) else
13459: LD_EXP 32
13463: PPUSH
13464: LD_STRING D5d-Gary-1
13466: PPUSH
13467: CALL_OW 88
13471: GO 13508
// if GetSex ( un ) = sex_male then
13473: LD_VAR 0 1
13477: PPUSH
13478: CALL_OW 258
13482: PUSH
13483: LD_INT 1
13485: EQUAL
13486: IFFALSE 13502
// Say ( un , D5d-Sol1-1 ) else
13488: LD_VAR 0 1
13492: PPUSH
13493: LD_STRING D5d-Sol1-1
13495: PPUSH
13496: CALL_OW 88
13500: GO 13508
// begin DialogueOff ;
13502: CALL_OW 7
// exit ;
13506: GO 13524
// end ; Say ( JMM , D5d-JMM-1 ) ;
13508: LD_EXP 21
13512: PPUSH
13513: LD_STRING D5d-JMM-1
13515: PPUSH
13516: CALL_OW 88
// DialogueOff ;
13520: CALL_OW 7
// end ;
13524: PPOPN 1
13526: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13527: LD_INT 1
13529: PPUSH
13530: LD_INT 17
13532: PPUSH
13533: CALL_OW 294
13537: PUSH
13538: LD_INT 2
13540: GREATEREQUAL
13541: IFFALSE 13662
13543: GO 13545
13545: DISABLE
13546: LD_INT 0
13548: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13549: LD_INT 10
13551: PPUSH
13552: LD_INT 5
13554: PPUSH
13555: LD_INT 1
13557: PPUSH
13558: LD_INT 10
13560: NEG
13561: PPUSH
13562: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13566: LD_INT 10
13568: PPUSH
13569: LD_INT 5
13571: PPUSH
13572: LD_INT 1
13574: PPUSH
13575: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13579: LD_INT 10
13581: PPUSH
13582: LD_INT 5
13584: PPUSH
13585: CALL_OW 86
// DialogueOn ;
13589: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13593: LD_ADDR_VAR 0 1
13597: PUSH
13598: LD_INT 1
13600: PPUSH
13601: LD_STRING D6-Sci1-1
13603: PPUSH
13604: CALL 16177 0 2
13608: ST_TO_ADDR
// if un then
13609: LD_VAR 0 1
13613: IFFALSE 13651
// begin Say ( JMM , D6-JMM-1 ) ;
13615: LD_EXP 21
13619: PPUSH
13620: LD_STRING D6-JMM-1
13622: PPUSH
13623: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13627: LD_VAR 0 1
13631: PPUSH
13632: LD_STRING D6-Sci1-2
13634: PPUSH
13635: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13639: LD_EXP 21
13643: PPUSH
13644: LD_STRING D6-JMM-2
13646: PPUSH
13647: CALL_OW 88
// end ; DialogueOff ;
13651: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13655: LD_STRING M3
13657: PPUSH
13658: CALL_OW 337
// end ;
13662: PPOPN 1
13664: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
13665: LD_OWVAR 1
13669: PUSH
13670: LD_INT 42000
13672: GREATEREQUAL
13673: PUSH
13674: LD_INT 2
13676: PPUSH
13677: LD_INT 169
13679: PPUSH
13680: LD_INT 90
13682: PPUSH
13683: LD_INT 10
13685: PPUSH
13686: CALL 53227 0 4
13690: PUSH
13691: LD_INT 4
13693: ARRAY
13694: PUSH
13695: LD_INT 0
13697: EQUAL
13698: PUSH
13699: LD_INT 45
13701: PPUSH
13702: CALL_OW 301
13706: OR
13707: PUSH
13708: LD_INT 45
13710: PPUSH
13711: CALL_OW 255
13715: PUSH
13716: LD_INT 1
13718: EQUAL
13719: OR
13720: AND
13721: PUSH
13722: LD_INT 94
13724: PPUSH
13725: CALL_OW 301
13729: NOT
13730: AND
13731: IFFALSE 14936
13733: GO 13735
13735: DISABLE
13736: LD_INT 0
13738: PPUSH
13739: PPUSH
13740: PPUSH
13741: PPUSH
13742: PPUSH
// begin uc_side := 5 ;
13743: LD_ADDR_OWVAR 20
13747: PUSH
13748: LD_INT 5
13750: ST_TO_ADDR
// uc_nation := 2 ;
13751: LD_ADDR_OWVAR 21
13755: PUSH
13756: LD_INT 2
13758: ST_TO_ADDR
// InitHc ;
13759: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13763: LD_INT 1
13765: PPUSH
13766: LD_INT 3
13768: PPUSH
13769: LD_INT 8
13771: PPUSH
13772: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13776: LD_ADDR_OWVAR 29
13780: PUSH
13781: LD_INT 12
13783: PUSH
13784: LD_INT 12
13786: PUSH
13787: EMPTY
13788: LIST
13789: LIST
13790: ST_TO_ADDR
// hc_name := Hans Felige ;
13791: LD_ADDR_OWVAR 26
13795: PUSH
13796: LD_STRING Hans Felige
13798: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13799: LD_ADDR_OWVAR 33
13803: PUSH
13804: LD_STRING SecondCharsGal
13806: ST_TO_ADDR
// hc_face_number := 7 ;
13807: LD_ADDR_OWVAR 34
13811: PUSH
13812: LD_INT 7
13814: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13815: LD_ADDR_EXP 46
13819: PUSH
13820: CALL_OW 44
13824: ST_TO_ADDR
// InitHc ;
13825: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13829: LD_INT 1
13831: PPUSH
13832: LD_INT 16
13834: PPUSH
13835: LD_INT 2
13837: PPUSH
13838: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13842: LD_ADDR_OWVAR 29
13846: PUSH
13847: LD_INT 12
13849: PUSH
13850: LD_INT 12
13852: PUSH
13853: EMPTY
13854: LIST
13855: LIST
13856: ST_TO_ADDR
// hc_name :=  ;
13857: LD_ADDR_OWVAR 26
13861: PUSH
13862: LD_STRING 
13864: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13865: LD_ADDR_EXP 47
13869: PUSH
13870: CALL_OW 44
13874: ST_TO_ADDR
// InitHc ;
13875: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13879: LD_INT 35
13881: PPUSH
13882: CALL_OW 67
// until not InBattle ( 1 ) ;
13886: LD_INT 1
13888: PPUSH
13889: CALL_OW 463
13893: NOT
13894: IFFALSE 13879
// wait ( 0 0$5 ) ;
13896: LD_INT 175
13898: PPUSH
13899: CALL_OW 67
// DialogueOn ;
13903: CALL_OW 6
// InGameOn ;
13907: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13911: LD_ADDR_VAR 0 1
13915: PUSH
13916: LD_INT 22
13918: PUSH
13919: LD_INT 1
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: PUSH
13926: LD_INT 2
13928: PUSH
13929: LD_INT 25
13931: PUSH
13932: LD_INT 1
13934: PUSH
13935: EMPTY
13936: LIST
13937: LIST
13938: PUSH
13939: LD_INT 25
13941: PUSH
13942: LD_INT 2
13944: PUSH
13945: EMPTY
13946: LIST
13947: LIST
13948: PUSH
13949: LD_INT 25
13951: PUSH
13952: LD_INT 3
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PUSH
13959: LD_INT 25
13961: PUSH
13962: LD_INT 4
13964: PUSH
13965: EMPTY
13966: LIST
13967: LIST
13968: PUSH
13969: LD_INT 25
13971: PUSH
13972: LD_INT 5
13974: PUSH
13975: EMPTY
13976: LIST
13977: LIST
13978: PUSH
13979: LD_INT 25
13981: PUSH
13982: LD_INT 8
13984: PUSH
13985: EMPTY
13986: LIST
13987: LIST
13988: PUSH
13989: EMPTY
13990: LIST
13991: LIST
13992: LIST
13993: LIST
13994: LIST
13995: LIST
13996: LIST
13997: PUSH
13998: EMPTY
13999: LIST
14000: LIST
14001: PPUSH
14002: CALL_OW 69
14006: PUSH
14007: LD_EXP 21
14011: PUSH
14012: LD_EXP 22
14016: PUSH
14017: LD_EXP 23
14021: PUSH
14022: LD_EXP 24
14026: PUSH
14027: LD_EXP 25
14031: PUSH
14032: LD_EXP 26
14036: PUSH
14037: LD_EXP 27
14041: PUSH
14042: LD_EXP 28
14046: PUSH
14047: LD_EXP 29
14051: PUSH
14052: LD_EXP 31
14056: PUSH
14057: LD_EXP 32
14061: PUSH
14062: LD_EXP 33
14066: PUSH
14067: LD_EXP 34
14071: PUSH
14072: EMPTY
14073: LIST
14074: LIST
14075: LIST
14076: LIST
14077: LIST
14078: LIST
14079: LIST
14080: LIST
14081: LIST
14082: LIST
14083: LIST
14084: LIST
14085: LIST
14086: DIFF
14087: PPUSH
14088: LD_INT 26
14090: PUSH
14091: LD_INT 1
14093: PUSH
14094: EMPTY
14095: LIST
14096: LIST
14097: PPUSH
14098: CALL_OW 72
14102: PUSH
14103: LD_INT 1
14105: ARRAY
14106: ST_TO_ADDR
// if Brown then
14107: LD_EXP 27
14111: IFFALSE 14123
// un := Brown ;
14113: LD_ADDR_VAR 0 1
14117: PUSH
14118: LD_EXP 27
14122: ST_TO_ADDR
// if un then
14123: LD_VAR 0 1
14127: IFFALSE 14153
// begin Say ( un , D7-Sol1-1 ) ;
14129: LD_VAR 0 1
14133: PPUSH
14134: LD_STRING D7-Sol1-1
14136: PPUSH
14137: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14141: LD_EXP 21
14145: PPUSH
14146: LD_STRING D7-JMM-1
14148: PPUSH
14149: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14153: LD_EXP 46
14157: PPUSH
14158: LD_STRING D7-Ar1-1
14160: PPUSH
14161: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14165: LD_EXP 21
14169: PPUSH
14170: LD_STRING D7-JMM-2
14172: PPUSH
14173: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14177: LD_EXP 46
14181: PPUSH
14182: LD_STRING D7-Ar1-2
14184: PPUSH
14185: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14189: LD_EXP 21
14193: PPUSH
14194: LD_STRING D7-JMM-3
14196: PPUSH
14197: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14201: LD_EXP 46
14205: PPUSH
14206: LD_STRING D7-Ar1-3
14208: PPUSH
14209: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14213: LD_EXP 21
14217: PPUSH
14218: LD_STRING D7-JMM-4
14220: PPUSH
14221: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14225: LD_EXP 46
14229: PPUSH
14230: LD_STRING D7-Ar1-4
14232: PPUSH
14233: CALL_OW 94
// InGameOff ;
14237: CALL_OW 9
// DialogueOff ;
14241: CALL_OW 7
// case Query ( QCameras ) of 1 :
14245: LD_STRING QCameras
14247: PPUSH
14248: CALL_OW 97
14252: PUSH
14253: LD_INT 1
14255: DOUBLE
14256: EQUAL
14257: IFTRUE 14261
14259: GO 14264
14261: POP
// ; 2 :
14262: GO 14278
14264: LD_INT 2
14266: DOUBLE
14267: EQUAL
14268: IFTRUE 14272
14270: GO 14277
14272: POP
// exit ; end ;
14273: GO 14936
14275: GO 14278
14277: POP
// ChangeMissionObjectives ( MCar ) ;
14278: LD_STRING MCar
14280: PPUSH
14281: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14285: LD_INT 124
14287: PPUSH
14288: LD_INT 90
14290: PPUSH
14291: LD_INT 1
14293: PPUSH
14294: LD_INT 6
14296: NEG
14297: PPUSH
14298: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14302: LD_INT 124
14304: PPUSH
14305: LD_INT 90
14307: PPUSH
14308: LD_INT 1
14310: PPUSH
14311: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14315: LD_INT 12
14317: PPUSH
14318: LD_INT 1
14320: PPUSH
14321: CALL_OW 424
// wait ( 3 ) ;
14325: LD_INT 3
14327: PPUSH
14328: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14332: LD_INT 124
14334: PPUSH
14335: LD_INT 90
14337: PPUSH
14338: CALL_OW 86
// cargo := false ;
14342: LD_ADDR_VAR 0 3
14346: PUSH
14347: LD_INT 0
14349: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14350: LD_INT 35
14352: PPUSH
14353: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14357: LD_ADDR_VAR 0 3
14361: PUSH
14362: LD_INT 12
14364: PPUSH
14365: LD_INT 32
14367: PUSH
14368: LD_INT 3
14370: PUSH
14371: EMPTY
14372: LIST
14373: LIST
14374: PUSH
14375: LD_INT 34
14377: PUSH
14378: LD_INT 32
14380: PUSH
14381: EMPTY
14382: LIST
14383: LIST
14384: PUSH
14385: LD_INT 58
14387: PUSH
14388: EMPTY
14389: LIST
14390: PUSH
14391: EMPTY
14392: LIST
14393: LIST
14394: LIST
14395: PPUSH
14396: CALL_OW 70
14400: ST_TO_ADDR
// until cargo ;
14401: LD_VAR 0 3
14405: IFFALSE 14350
// cargo := cargo [ 1 ] ;
14407: LD_ADDR_VAR 0 3
14411: PUSH
14412: LD_VAR 0 3
14416: PUSH
14417: LD_INT 1
14419: ARRAY
14420: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14421: LD_VAR 0 3
14425: PPUSH
14426: LD_INT 5
14428: PPUSH
14429: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14433: LD_INT 12
14435: PPUSH
14436: LD_INT 0
14438: PPUSH
14439: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14443: LD_EXP 46
14447: PPUSH
14448: LD_INT 11
14450: PPUSH
14451: LD_INT 0
14453: PPUSH
14454: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14458: LD_EXP 47
14462: PPUSH
14463: LD_INT 11
14465: PPUSH
14466: LD_INT 0
14468: PPUSH
14469: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14473: LD_EXP 46
14477: PUSH
14478: LD_EXP 47
14482: PUSH
14483: EMPTY
14484: LIST
14485: LIST
14486: PPUSH
14487: LD_INT 12
14489: PPUSH
14490: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14494: LD_EXP 46
14498: PPUSH
14499: LD_VAR 0 3
14503: PPUSH
14504: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14508: LD_EXP 46
14512: PUSH
14513: LD_EXP 47
14517: PUSH
14518: EMPTY
14519: LIST
14520: LIST
14521: PPUSH
14522: LD_INT 209
14524: PPUSH
14525: LD_INT 178
14527: PPUSH
14528: CALL_OW 171
// escaped := 0 ;
14532: LD_ADDR_VAR 0 5
14536: PUSH
14537: LD_INT 0
14539: ST_TO_ADDR
// while ( true ) do
14540: LD_INT 1
14542: IFFALSE 14758
// begin wait ( 0 0$1 ) ;
14544: LD_INT 35
14546: PPUSH
14547: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14551: LD_EXP 46
14555: PPUSH
14556: CALL_OW 314
14560: NOT
14561: PUSH
14562: LD_EXP 47
14566: PPUSH
14567: CALL_OW 314
14571: NOT
14572: OR
14573: IFFALSE 14599
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14575: LD_EXP 46
14579: PUSH
14580: LD_EXP 47
14584: PUSH
14585: EMPTY
14586: LIST
14587: LIST
14588: PPUSH
14589: LD_INT 209
14591: PPUSH
14592: LD_INT 178
14594: PPUSH
14595: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14599: LD_EXP 46
14603: PPUSH
14604: LD_INT 10
14606: PPUSH
14607: CALL_OW 308
14611: IFFALSE 14636
// begin RemoveUnit ( ar_mechanic ) ;
14613: LD_EXP 46
14617: PPUSH
14618: CALL_OW 64
// escaped := escaped + 1 ;
14622: LD_ADDR_VAR 0 5
14626: PUSH
14627: LD_VAR 0 5
14631: PUSH
14632: LD_INT 1
14634: PLUS
14635: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
14636: LD_EXP 47
14640: PPUSH
14641: LD_INT 10
14643: PPUSH
14644: CALL_OW 308
14648: IFFALSE 14673
// begin RemoveUnit ( ar_mechanic_friend ) ;
14650: LD_EXP 47
14654: PPUSH
14655: CALL_OW 64
// escaped := escaped + 1 ;
14659: LD_ADDR_VAR 0 5
14663: PUSH
14664: LD_VAR 0 5
14668: PUSH
14669: LD_INT 1
14671: PLUS
14672: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
14673: LD_VAR 0 3
14677: PPUSH
14678: LD_INT 10
14680: PPUSH
14681: CALL_OW 308
14685: IFFALSE 14696
// RemoveUnit ( cargo ) ;
14687: LD_VAR 0 3
14691: PPUSH
14692: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
14696: LD_EXP 46
14700: PPUSH
14701: CALL_OW 305
14705: NOT
14706: PUSH
14707: LD_VAR 0 5
14711: PUSH
14712: LD_INT 2
14714: GREATEREQUAL
14715: AND
14716: IFFALSE 14720
// break ;
14718: GO 14758
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
14720: LD_EXP 46
14724: PPUSH
14725: CALL_OW 305
14729: NOT
14730: PUSH
14731: LD_EXP 47
14735: PPUSH
14736: CALL_OW 305
14740: NOT
14741: AND
14742: PUSH
14743: LD_VAR 0 5
14747: PUSH
14748: LD_INT 2
14750: LESS
14751: AND
14752: IFFALSE 14756
// exit ;
14754: GO 14936
// end ;
14756: GO 14540
// wait ( 0 0$2 ) ;
14758: LD_INT 70
14760: PPUSH
14761: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14765: LD_EXP 46
14769: PPUSH
14770: LD_STRING D7a-Ar1-1
14772: PPUSH
14773: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14777: LD_ADDR_VAR 0 4
14781: PUSH
14782: LD_INT 129
14784: PUSH
14785: LD_INT 10
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PUSH
14792: LD_INT 103
14794: PUSH
14795: LD_INT 6
14797: PUSH
14798: EMPTY
14799: LIST
14800: LIST
14801: PUSH
14802: LD_INT 148
14804: PUSH
14805: LD_INT 47
14807: PUSH
14808: EMPTY
14809: LIST
14810: LIST
14811: PUSH
14812: LD_INT 155
14814: PUSH
14815: LD_INT 16
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: PUSH
14822: EMPTY
14823: LIST
14824: LIST
14825: LIST
14826: LIST
14827: ST_TO_ADDR
// if Difficulty = 1 then
14828: LD_OWVAR 67
14832: PUSH
14833: LD_INT 1
14835: EQUAL
14836: IFFALSE 14873
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14838: LD_ADDR_VAR 0 4
14842: PUSH
14843: LD_VAR 0 4
14847: PUSH
14848: LD_INT 78
14850: PUSH
14851: LD_INT 7
14853: PUSH
14854: EMPTY
14855: LIST
14856: LIST
14857: PUSH
14858: LD_INT 104
14860: PUSH
14861: LD_INT 43
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: ADD
14872: ST_TO_ADDR
// for i in tmp do
14873: LD_ADDR_VAR 0 2
14877: PUSH
14878: LD_VAR 0 4
14882: PUSH
14883: FOR_IN
14884: IFFALSE 14917
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14886: LD_VAR 0 2
14890: PUSH
14891: LD_INT 1
14893: ARRAY
14894: PPUSH
14895: LD_VAR 0 2
14899: PUSH
14900: LD_INT 2
14902: ARRAY
14903: PPUSH
14904: LD_INT 1
14906: PPUSH
14907: LD_INT 9
14909: NEG
14910: PPUSH
14911: CALL_OW 330
14915: GO 14883
14917: POP
14918: POP
// SetAchievement ( ACH_FRIEND ) ;
14919: LD_STRING ACH_FRIEND
14921: PPUSH
14922: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
14926: LD_INT 129
14928: PPUSH
14929: LD_INT 10
14931: PPUSH
14932: CALL_OW 84
// end ;
14936: PPOPN 5
14938: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14939: LD_EXP 15
14943: PUSH
14944: LD_INT 21000
14946: MINUS
14947: PUSH
14948: LD_OWVAR 1
14952: LESSEQUAL
14953: IFFALSE 14993
14955: GO 14957
14957: DISABLE
// begin powell_warn := true ;
14958: LD_ADDR_EXP 16
14962: PUSH
14963: LD_INT 1
14965: ST_TO_ADDR
// DialogueOn ;
14966: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14970: LD_EXP 30
14974: PPUSH
14975: LD_STRING D9-Pow-1
14977: PPUSH
14978: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
14982: LD_INT 10
14984: PPUSH
14985: CALL_OW 68
// DialogueOff ;
14989: CALL_OW 7
// end ;
14993: END
// every 0 0$1 trigger game_time <= tick do
14994: LD_EXP 15
14998: PUSH
14999: LD_OWVAR 1
15003: LESSEQUAL
15004: IFFALSE 15043
15006: GO 15008
15008: DISABLE
// begin DialogueOn ;
15009: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15013: LD_EXP 30
15017: PPUSH
15018: LD_STRING D9a-Pow-1
15020: PPUSH
15021: CALL_OW 94
// dwait ( 0 0$2 ) ;
15025: LD_INT 70
15027: PPUSH
15028: CALL_OW 68
// DialogueOff ;
15032: CALL_OW 7
// YouLost ( Command ) ;
15036: LD_STRING Command
15038: PPUSH
15039: CALL_OW 104
// end ;
15043: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15044: LD_INT 22
15046: PUSH
15047: LD_INT 2
15049: PUSH
15050: EMPTY
15051: LIST
15052: LIST
15053: PUSH
15054: LD_INT 30
15056: PUSH
15057: LD_INT 1
15059: PUSH
15060: EMPTY
15061: LIST
15062: LIST
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: PPUSH
15068: CALL_OW 69
15072: PUSH
15073: LD_INT 0
15075: EQUAL
15076: PUSH
15077: LD_EXP 21
15081: PPUSH
15082: CALL_OW 302
15086: AND
15087: IFFALSE 15996
15089: GO 15091
15091: DISABLE
15092: LD_INT 0
15094: PPUSH
15095: PPUSH
15096: PPUSH
15097: PPUSH
// begin m1 := false ;
15098: LD_ADDR_VAR 0 2
15102: PUSH
15103: LD_INT 0
15105: ST_TO_ADDR
// m2 := false ;
15106: LD_ADDR_VAR 0 3
15110: PUSH
15111: LD_INT 0
15113: ST_TO_ADDR
// m3 := false ;
15114: LD_ADDR_VAR 0 4
15118: PUSH
15119: LD_INT 0
15121: ST_TO_ADDR
// if not am_veh_consturcted then
15122: LD_EXP 20
15126: NOT
15127: IFFALSE 15136
// SetAchievement ( ACH_ARABTECH ) ;
15129: LD_STRING ACH_ARABTECH
15131: PPUSH
15132: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
15136: LD_OWVAR 1
15140: PUSH
15141: LD_INT 252000
15143: PUSH
15144: LD_INT 210000
15146: PUSH
15147: LD_INT 199500
15149: PUSH
15150: EMPTY
15151: LIST
15152: LIST
15153: LIST
15154: PUSH
15155: LD_OWVAR 67
15159: ARRAY
15160: LESS
15161: IFFALSE 15183
// begin m3 := true ;
15163: LD_ADDR_VAR 0 4
15167: PUSH
15168: LD_INT 1
15170: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15171: LD_STRING Time1
15173: PPUSH
15174: LD_INT 1
15176: PPUSH
15177: CALL_OW 101
// end else
15181: GO 15214
// if not powell_warn then
15183: LD_EXP 16
15187: NOT
15188: IFFALSE 15203
// AddMedal ( Time1 , - 1 ) else
15190: LD_STRING Time1
15192: PPUSH
15193: LD_INT 1
15195: NEG
15196: PPUSH
15197: CALL_OW 101
15201: GO 15214
// AddMedal ( Time1 , - 2 ) ;
15203: LD_STRING Time1
15205: PPUSH
15206: LD_INT 2
15208: NEG
15209: PPUSH
15210: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15214: LD_EXP 17
15218: PUSH
15219: LD_INT 5
15221: PUSH
15222: LD_INT 4
15224: PUSH
15225: LD_INT 3
15227: PUSH
15228: EMPTY
15229: LIST
15230: LIST
15231: LIST
15232: PUSH
15233: LD_OWVAR 67
15237: ARRAY
15238: GREATEREQUAL
15239: IFFALSE 15254
// AddMedal ( Destroy , - 2 ) else
15241: LD_STRING Destroy
15243: PPUSH
15244: LD_INT 2
15246: NEG
15247: PPUSH
15248: CALL_OW 101
15252: GO 15387
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15254: LD_INT 22
15256: PUSH
15257: LD_INT 2
15259: PUSH
15260: EMPTY
15261: LIST
15262: LIST
15263: PUSH
15264: LD_INT 21
15266: PUSH
15267: LD_INT 3
15269: PUSH
15270: EMPTY
15271: LIST
15272: LIST
15273: PUSH
15274: LD_INT 50
15276: PUSH
15277: EMPTY
15278: LIST
15279: PUSH
15280: EMPTY
15281: LIST
15282: LIST
15283: LIST
15284: PPUSH
15285: CALL_OW 69
15289: PUSH
15290: LD_INT 25
15292: GREATEREQUAL
15293: IFFALSE 15308
// AddMedal ( Destroy , - 1 ) else
15295: LD_STRING Destroy
15297: PPUSH
15298: LD_INT 1
15300: NEG
15301: PPUSH
15302: CALL_OW 101
15306: GO 15387
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15308: LD_INT 22
15310: PUSH
15311: LD_INT 2
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: PUSH
15318: LD_INT 21
15320: PUSH
15321: LD_INT 3
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: PUSH
15328: LD_INT 50
15330: PUSH
15331: EMPTY
15332: LIST
15333: PUSH
15334: EMPTY
15335: LIST
15336: LIST
15337: LIST
15338: PPUSH
15339: CALL_OW 69
15343: PUSH
15344: LD_INT 15
15346: GREATEREQUAL
15347: IFFALSE 15369
// begin m1 := true ;
15349: LD_ADDR_VAR 0 2
15353: PUSH
15354: LD_INT 1
15356: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15357: LD_STRING Destroy
15359: PPUSH
15360: LD_INT 1
15362: PPUSH
15363: CALL_OW 101
// end else
15367: GO 15387
// begin m1 := true ;
15369: LD_ADDR_VAR 0 2
15373: PUSH
15374: LD_INT 1
15376: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15377: LD_STRING Destroy
15379: PPUSH
15380: LD_INT 2
15382: PPUSH
15383: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15387: LD_EXP 13
15391: PPUSH
15392: LD_STRING 11_artifact_captured
15394: PPUSH
15395: CALL_OW 39
// if artifact_get then
15399: LD_EXP 13
15403: IFFALSE 15425
// begin m2 := true ;
15405: LD_ADDR_VAR 0 3
15409: PUSH
15410: LD_INT 1
15412: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15413: LD_STRING Artefact
15415: PPUSH
15416: LD_INT 1
15418: PPUSH
15419: CALL_OW 101
// end else
15423: GO 15436
// AddMedal ( Artefact , - 1 ) ;
15425: LD_STRING Artefact
15427: PPUSH
15428: LD_INT 1
15430: NEG
15431: PPUSH
15432: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15436: LD_VAR 0 2
15440: PUSH
15441: LD_VAR 0 3
15445: AND
15446: PUSH
15447: LD_VAR 0 4
15451: AND
15452: PUSH
15453: LD_OWVAR 67
15457: PUSH
15458: LD_INT 3
15460: EQUAL
15461: AND
15462: IFFALSE 15474
// SetAchievementEX ( ACH_AMER , 11 ) ;
15464: LD_STRING ACH_AMER
15466: PPUSH
15467: LD_INT 11
15469: PPUSH
15470: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15474: LD_VAR 0 2
15478: PUSH
15479: LD_VAR 0 3
15483: AND
15484: PUSH
15485: LD_VAR 0 4
15489: AND
15490: PUSH
15491: LD_EXP 17
15495: PUSH
15496: LD_INT 0
15498: EQUAL
15499: AND
15500: IFFALSE 15516
// begin wait ( 3 ) ;
15502: LD_INT 3
15504: PPUSH
15505: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15509: LD_STRING ACH_GENERAL
15511: PPUSH
15512: CALL_OW 543
// end ; if tick <= 100 100$00 then
15516: LD_OWVAR 1
15520: PUSH
15521: LD_INT 210000
15523: LESSEQUAL
15524: IFFALSE 15540
// begin wait ( 3 ) ;
15526: LD_INT 3
15528: PPUSH
15529: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15533: LD_STRING ACH_ASPEED_11
15535: PPUSH
15536: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15540: LD_STRING MAIN
15542: PPUSH
15543: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15547: LD_ADDR_EXP 19
15551: PUSH
15552: LD_EXP 19
15556: PPUSH
15557: LD_INT 51
15559: PUSH
15560: EMPTY
15561: LIST
15562: PPUSH
15563: CALL_OW 72
15567: ST_TO_ADDR
// tmp := JMM ^ selected ;
15568: LD_ADDR_VAR 0 1
15572: PUSH
15573: LD_EXP 21
15577: PUSH
15578: LD_EXP 19
15582: ADD
15583: ST_TO_ADDR
// RewardPeople ( tmp ) ;
15584: LD_VAR 0 1
15588: PPUSH
15589: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
15593: LD_VAR 0 1
15597: PUSH
15598: LD_EXP 21
15602: PUSH
15603: LD_EXP 22
15607: PUSH
15608: LD_EXP 23
15612: PUSH
15613: LD_EXP 24
15617: PUSH
15618: LD_EXP 25
15622: PUSH
15623: LD_EXP 26
15627: PUSH
15628: LD_EXP 27
15632: PUSH
15633: LD_EXP 28
15637: PUSH
15638: LD_EXP 29
15642: PUSH
15643: LD_EXP 31
15647: PUSH
15648: LD_EXP 32
15652: PUSH
15653: LD_EXP 33
15657: PUSH
15658: LD_EXP 34
15662: PUSH
15663: EMPTY
15664: LIST
15665: LIST
15666: LIST
15667: LIST
15668: LIST
15669: LIST
15670: LIST
15671: LIST
15672: LIST
15673: LIST
15674: LIST
15675: LIST
15676: LIST
15677: DIFF
15678: PPUSH
15679: LD_STRING 11c_others
15681: PPUSH
15682: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15686: LD_EXP 21
15690: PPUSH
15691: LD_EXP 3
15695: PUSH
15696: LD_STRING JMM
15698: STR
15699: PPUSH
15700: CALL_OW 38
// if Lisa then
15704: LD_EXP 22
15708: IFFALSE 15728
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15710: LD_EXP 22
15714: PPUSH
15715: LD_EXP 3
15719: PUSH
15720: LD_STRING Lisa
15722: STR
15723: PPUSH
15724: CALL_OW 38
// if Donaldson then
15728: LD_EXP 23
15732: IFFALSE 15752
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15734: LD_EXP 23
15738: PPUSH
15739: LD_EXP 3
15743: PUSH
15744: LD_STRING Donaldson
15746: STR
15747: PPUSH
15748: CALL_OW 38
// if Bobby then
15752: LD_EXP 24
15756: IFFALSE 15776
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15758: LD_EXP 24
15762: PPUSH
15763: LD_EXP 3
15767: PUSH
15768: LD_STRING Bobby
15770: STR
15771: PPUSH
15772: CALL_OW 38
// if Cyrus then
15776: LD_EXP 25
15780: IFFALSE 15800
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15782: LD_EXP 25
15786: PPUSH
15787: LD_EXP 3
15791: PUSH
15792: LD_STRING Cyrus
15794: STR
15795: PPUSH
15796: CALL_OW 38
// if Denis then
15800: LD_EXP 26
15804: IFFALSE 15824
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15806: LD_EXP 26
15810: PPUSH
15811: LD_EXP 3
15815: PUSH
15816: LD_STRING Denis
15818: STR
15819: PPUSH
15820: CALL_OW 38
// if Brown then
15824: LD_EXP 27
15828: IFFALSE 15848
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15830: LD_EXP 27
15834: PPUSH
15835: LD_EXP 3
15839: PUSH
15840: LD_STRING Brown
15842: STR
15843: PPUSH
15844: CALL_OW 38
// if Gladstone then
15848: LD_EXP 28
15852: IFFALSE 15872
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15854: LD_EXP 28
15858: PPUSH
15859: LD_EXP 3
15863: PUSH
15864: LD_STRING Gladstone
15866: STR
15867: PPUSH
15868: CALL_OW 38
// if Houten then
15872: LD_EXP 29
15876: IFFALSE 15896
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15878: LD_EXP 29
15882: PPUSH
15883: LD_EXP 3
15887: PUSH
15888: LD_STRING Houten
15890: STR
15891: PPUSH
15892: CALL_OW 38
// if Cornel then
15896: LD_EXP 31
15900: IFFALSE 15920
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
15902: LD_EXP 31
15906: PPUSH
15907: LD_EXP 3
15911: PUSH
15912: LD_STRING Cornell
15914: STR
15915: PPUSH
15916: CALL_OW 38
// if Gary then
15920: LD_EXP 32
15924: IFFALSE 15944
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
15926: LD_EXP 32
15930: PPUSH
15931: LD_EXP 3
15935: PUSH
15936: LD_STRING Gary
15938: STR
15939: PPUSH
15940: CALL_OW 38
// if Frank then
15944: LD_EXP 33
15948: IFFALSE 15968
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
15950: LD_EXP 33
15954: PPUSH
15955: LD_EXP 3
15959: PUSH
15960: LD_STRING Frank
15962: STR
15963: PPUSH
15964: CALL_OW 38
// if Kikuchi then
15968: LD_EXP 34
15972: IFFALSE 15992
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
15974: LD_EXP 34
15978: PPUSH
15979: LD_EXP 3
15983: PUSH
15984: LD_STRING Kikuchi
15986: STR
15987: PPUSH
15988: CALL_OW 38
// YouWin ;
15992: CALL_OW 103
// end ;
15996: PPOPN 4
15998: END
// export function CanSayRand ( side ) ; begin
15999: LD_INT 0
16001: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16002: LD_ADDR_VAR 0 2
16006: PUSH
16007: LD_INT 52
16009: PUSH
16010: EMPTY
16011: LIST
16012: PUSH
16013: LD_INT 22
16015: PUSH
16016: LD_VAR 0 1
16020: PUSH
16021: EMPTY
16022: LIST
16023: LIST
16024: PUSH
16025: LD_INT 2
16027: PUSH
16028: LD_INT 25
16030: PUSH
16031: LD_INT 1
16033: PUSH
16034: EMPTY
16035: LIST
16036: LIST
16037: PUSH
16038: LD_INT 25
16040: PUSH
16041: LD_INT 2
16043: PUSH
16044: EMPTY
16045: LIST
16046: LIST
16047: PUSH
16048: LD_INT 25
16050: PUSH
16051: LD_INT 3
16053: PUSH
16054: EMPTY
16055: LIST
16056: LIST
16057: PUSH
16058: LD_INT 25
16060: PUSH
16061: LD_INT 4
16063: PUSH
16064: EMPTY
16065: LIST
16066: LIST
16067: PUSH
16068: EMPTY
16069: LIST
16070: LIST
16071: LIST
16072: LIST
16073: LIST
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: LIST
16079: PPUSH
16080: CALL_OW 69
16084: PUSH
16085: LD_EXP 21
16089: PUSH
16090: LD_EXP 33
16094: PUSH
16095: LD_EXP 22
16099: PUSH
16100: LD_EXP 23
16104: PUSH
16105: LD_EXP 24
16109: PUSH
16110: LD_EXP 25
16114: PUSH
16115: LD_EXP 26
16119: PUSH
16120: LD_EXP 27
16124: PUSH
16125: LD_EXP 28
16129: PUSH
16130: LD_EXP 29
16134: PUSH
16135: LD_EXP 30
16139: PUSH
16140: LD_EXP 31
16144: PUSH
16145: LD_EXP 32
16149: PUSH
16150: LD_EXP 34
16154: PUSH
16155: EMPTY
16156: LIST
16157: LIST
16158: LIST
16159: LIST
16160: LIST
16161: LIST
16162: LIST
16163: LIST
16164: LIST
16165: LIST
16166: LIST
16167: LIST
16168: LIST
16169: LIST
16170: DIFF
16171: ST_TO_ADDR
// end ;
16172: LD_VAR 0 2
16176: RET
// export function SayRand ( sex , dial ) ; begin
16177: LD_INT 0
16179: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16180: LD_ADDR_VAR 0 3
16184: PUSH
16185: LD_INT 52
16187: PUSH
16188: EMPTY
16189: LIST
16190: PUSH
16191: LD_INT 22
16193: PUSH
16194: LD_INT 1
16196: PUSH
16197: EMPTY
16198: LIST
16199: LIST
16200: PUSH
16201: LD_INT 26
16203: PUSH
16204: LD_VAR 0 1
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: PUSH
16213: LD_INT 2
16215: PUSH
16216: LD_INT 25
16218: PUSH
16219: LD_INT 1
16221: PUSH
16222: EMPTY
16223: LIST
16224: LIST
16225: PUSH
16226: LD_INT 25
16228: PUSH
16229: LD_INT 2
16231: PUSH
16232: EMPTY
16233: LIST
16234: LIST
16235: PUSH
16236: LD_INT 25
16238: PUSH
16239: LD_INT 3
16241: PUSH
16242: EMPTY
16243: LIST
16244: LIST
16245: PUSH
16246: LD_INT 25
16248: PUSH
16249: LD_INT 4
16251: PUSH
16252: EMPTY
16253: LIST
16254: LIST
16255: PUSH
16256: EMPTY
16257: LIST
16258: LIST
16259: LIST
16260: LIST
16261: LIST
16262: PUSH
16263: EMPTY
16264: LIST
16265: LIST
16266: LIST
16267: LIST
16268: PPUSH
16269: CALL_OW 69
16273: PUSH
16274: LD_EXP 21
16278: PUSH
16279: LD_EXP 33
16283: PUSH
16284: LD_EXP 22
16288: PUSH
16289: LD_EXP 23
16293: PUSH
16294: LD_EXP 24
16298: PUSH
16299: LD_EXP 25
16303: PUSH
16304: LD_EXP 26
16308: PUSH
16309: LD_EXP 27
16313: PUSH
16314: LD_EXP 28
16318: PUSH
16319: LD_EXP 29
16323: PUSH
16324: LD_EXP 30
16328: PUSH
16329: LD_EXP 31
16333: PUSH
16334: LD_EXP 32
16338: PUSH
16339: LD_EXP 34
16343: PUSH
16344: EMPTY
16345: LIST
16346: LIST
16347: LIST
16348: LIST
16349: LIST
16350: LIST
16351: LIST
16352: LIST
16353: LIST
16354: LIST
16355: LIST
16356: LIST
16357: LIST
16358: LIST
16359: DIFF
16360: ST_TO_ADDR
// if not result then
16361: LD_VAR 0 3
16365: NOT
16366: IFFALSE 16370
// exit ;
16368: GO 16398
// result := result [ 1 ] ;
16370: LD_ADDR_VAR 0 3
16374: PUSH
16375: LD_VAR 0 3
16379: PUSH
16380: LD_INT 1
16382: ARRAY
16383: ST_TO_ADDR
// Say ( result , dial ) ;
16384: LD_VAR 0 3
16388: PPUSH
16389: LD_VAR 0 2
16393: PPUSH
16394: CALL_OW 88
// end ;
16398: LD_VAR 0 3
16402: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16403: LD_INT 0
16405: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16406: LD_ADDR_VAR 0 4
16410: PUSH
16411: LD_INT 22
16413: PUSH
16414: LD_INT 1
16416: PUSH
16417: EMPTY
16418: LIST
16419: LIST
16420: PUSH
16421: LD_INT 26
16423: PUSH
16424: LD_VAR 0 1
16428: PUSH
16429: EMPTY
16430: LIST
16431: LIST
16432: PUSH
16433: LD_INT 2
16435: PUSH
16436: LD_INT 25
16438: PUSH
16439: LD_INT 1
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: PUSH
16446: LD_INT 25
16448: PUSH
16449: LD_INT 2
16451: PUSH
16452: EMPTY
16453: LIST
16454: LIST
16455: PUSH
16456: LD_INT 25
16458: PUSH
16459: LD_INT 3
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: PUSH
16466: LD_INT 25
16468: PUSH
16469: LD_INT 4
16471: PUSH
16472: EMPTY
16473: LIST
16474: LIST
16475: PUSH
16476: EMPTY
16477: LIST
16478: LIST
16479: LIST
16480: LIST
16481: LIST
16482: PUSH
16483: EMPTY
16484: LIST
16485: LIST
16486: LIST
16487: PPUSH
16488: CALL_OW 69
16492: PUSH
16493: LD_EXP 21
16497: PUSH
16498: LD_EXP 33
16502: PUSH
16503: LD_EXP 22
16507: PUSH
16508: LD_EXP 23
16512: PUSH
16513: LD_EXP 24
16517: PUSH
16518: LD_EXP 25
16522: PUSH
16523: LD_EXP 26
16527: PUSH
16528: LD_EXP 27
16532: PUSH
16533: LD_EXP 28
16537: PUSH
16538: LD_EXP 29
16542: PUSH
16543: LD_EXP 30
16547: PUSH
16548: LD_EXP 31
16552: PUSH
16553: LD_EXP 32
16557: PUSH
16558: LD_EXP 34
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: LIST
16567: LIST
16568: LIST
16569: LIST
16570: LIST
16571: LIST
16572: LIST
16573: LIST
16574: LIST
16575: LIST
16576: LIST
16577: LIST
16578: PUSH
16579: LD_VAR 0 3
16583: ADD
16584: DIFF
16585: ST_TO_ADDR
// if not result then
16586: LD_VAR 0 4
16590: NOT
16591: IFFALSE 16595
// exit ;
16593: GO 16623
// result := result [ 1 ] ;
16595: LD_ADDR_VAR 0 4
16599: PUSH
16600: LD_VAR 0 4
16604: PUSH
16605: LD_INT 1
16607: ARRAY
16608: ST_TO_ADDR
// Say ( result , dial ) ;
16609: LD_VAR 0 4
16613: PPUSH
16614: LD_VAR 0 2
16618: PPUSH
16619: CALL_OW 88
// end ; end_of_file
16623: LD_VAR 0 4
16627: RET
// export function CustomEvent ( event ) ; begin
16628: LD_INT 0
16630: PPUSH
// end ;
16631: LD_VAR 0 2
16635: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
16636: LD_VAR 0 1
16640: PPUSH
16641: CALL_OW 255
16645: PUSH
16646: LD_INT 1
16648: EQUAL
16649: IFFALSE 16659
// artifact_get := true ;
16651: LD_ADDR_EXP 13
16655: PUSH
16656: LD_INT 1
16658: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
16659: LD_VAR 0 1
16663: PPUSH
16664: CALL_OW 255
16668: PUSH
16669: LD_INT 2
16671: EQUAL
16672: IFFALSE 16690
// begin artifact_get := false ;
16674: LD_ADDR_EXP 13
16678: PUSH
16679: LD_INT 0
16681: ST_TO_ADDR
// artifact_stolen := true ;
16682: LD_ADDR_EXP 12
16686: PUSH
16687: LD_INT 1
16689: ST_TO_ADDR
// end ; artifact_oncargo := true ;
16690: LD_ADDR_EXP 14
16694: PUSH
16695: LD_INT 1
16697: ST_TO_ADDR
// end ;
16698: PPOPN 2
16700: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
16701: LD_ADDR_EXP 14
16705: PUSH
16706: LD_INT 0
16708: ST_TO_ADDR
// end ;
16709: PPOPN 2
16711: END
// on UnitDestroyed ( un ) do begin if un = JMM then
16712: LD_VAR 0 1
16716: PUSH
16717: LD_EXP 21
16721: EQUAL
16722: IFFALSE 16733
// begin YouLost ( JMM ) ;
16724: LD_STRING JMM
16726: PPUSH
16727: CALL_OW 104
// exit ;
16731: GO 16865
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
16733: LD_VAR 0 1
16737: PUSH
16738: LD_INT 22
16740: PUSH
16741: LD_INT 1
16743: PUSH
16744: EMPTY
16745: LIST
16746: LIST
16747: PUSH
16748: LD_INT 21
16750: PUSH
16751: LD_INT 1
16753: PUSH
16754: EMPTY
16755: LIST
16756: LIST
16757: PUSH
16758: LD_INT 2
16760: PUSH
16761: LD_INT 25
16763: PUSH
16764: LD_INT 1
16766: PUSH
16767: EMPTY
16768: LIST
16769: LIST
16770: PUSH
16771: LD_INT 25
16773: PUSH
16774: LD_INT 2
16776: PUSH
16777: EMPTY
16778: LIST
16779: LIST
16780: PUSH
16781: LD_INT 25
16783: PUSH
16784: LD_INT 3
16786: PUSH
16787: EMPTY
16788: LIST
16789: LIST
16790: PUSH
16791: LD_INT 25
16793: PUSH
16794: LD_INT 4
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PUSH
16801: LD_INT 25
16803: PUSH
16804: LD_INT 5
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: PUSH
16811: LD_INT 25
16813: PUSH
16814: LD_INT 8
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: PUSH
16821: EMPTY
16822: LIST
16823: LIST
16824: LIST
16825: LIST
16826: LIST
16827: LIST
16828: LIST
16829: PUSH
16830: EMPTY
16831: LIST
16832: LIST
16833: LIST
16834: PPUSH
16835: CALL_OW 69
16839: IN
16840: IFFALSE 16856
// loses_counter := loses_counter + 1 ;
16842: LD_ADDR_EXP 17
16846: PUSH
16847: LD_EXP 17
16851: PUSH
16852: LD_INT 1
16854: PLUS
16855: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16856: LD_VAR 0 1
16860: PPUSH
16861: CALL 44433 0 1
// end ;
16865: PPOPN 1
16867: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16868: LD_VAR 0 1
16872: PPUSH
16873: LD_VAR 0 2
16877: PPUSH
16878: CALL 46767 0 2
// end ;
16882: PPOPN 2
16884: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16885: LD_VAR 0 1
16889: PPUSH
16890: CALL 46076 0 1
// end ;
16894: PPOPN 1
16896: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16897: LD_VAR 0 1
16901: PPUSH
16902: LD_VAR 0 2
16906: PPUSH
16907: LD_VAR 0 3
16911: PPUSH
16912: LD_VAR 0 4
16916: PPUSH
16917: LD_VAR 0 5
16921: PPUSH
16922: CALL 43749 0 5
// end ;
16926: PPOPN 5
16928: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
16929: LD_VAR 0 1
16933: PPUSH
16934: CALL_OW 248
16938: PUSH
16939: LD_INT 1
16941: EQUAL
16942: IFFALSE 16952
// am_veh_consturcted := true ;
16944: LD_ADDR_EXP 20
16948: PUSH
16949: LD_INT 1
16951: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
16952: LD_VAR 0 1
16956: PPUSH
16957: LD_VAR 0 2
16961: PPUSH
16962: CALL 43345 0 2
// end ;
16966: PPOPN 2
16968: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
16969: LD_VAR 0 1
16973: PPUSH
16974: CALL_OW 247
16978: PUSH
16979: LD_INT 2
16981: EQUAL
16982: IFFALSE 16986
// exit ;
16984: GO 17003
// if not kamikazed then
16986: LD_EXP 11
16990: NOT
16991: IFFALSE 17003
// kamikazed := unit ;
16993: LD_ADDR_EXP 11
16997: PUSH
16998: LD_VAR 0 1
17002: ST_TO_ADDR
// end ;
17003: PPOPN 1
17005: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17006: LD_INT 0
17008: PPUSH
17009: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17010: LD_VAR 0 1
17014: PPUSH
17015: LD_VAR 0 2
17019: PPUSH
17020: LD_VAR 0 3
17024: PPUSH
17025: LD_VAR 0 4
17029: PPUSH
17030: CALL 43183 0 4
// end ;
17034: PPOPN 6
17036: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17037: LD_VAR 0 1
17041: PPUSH
17042: LD_VAR 0 2
17046: PPUSH
17047: LD_VAR 0 3
17051: PPUSH
17052: CALL 42958 0 3
// end ;
17056: PPOPN 3
17058: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17059: LD_VAR 0 1
17063: PPUSH
17064: LD_VAR 0 2
17068: PPUSH
17069: CALL 44129 0 2
// end ;
17073: PPOPN 2
17075: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17076: LD_VAR 0 1
17080: PPUSH
17081: LD_VAR 0 2
17085: PPUSH
17086: CALL 42652 0 2
// end ;
17090: PPOPN 2
17092: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17093: LD_VAR 0 1
17097: PPUSH
17098: LD_VAR 0 2
17102: PPUSH
17103: CALL 42843 0 2
// end ;
17107: PPOPN 2
17109: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17110: LD_VAR 0 1
17114: PPUSH
17115: CALL 45835 0 1
// end ;
17119: PPOPN 1
17121: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17122: LD_VAR 0 1
17126: PPUSH
17127: LD_VAR 0 2
17131: PPUSH
17132: CALL 47028 0 2
// end ;
17136: PPOPN 2
17138: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17139: LD_VAR 0 1
17143: PPUSH
17144: LD_VAR 0 2
17148: PPUSH
17149: LD_VAR 0 3
17153: PPUSH
17154: LD_VAR 0 4
17158: PPUSH
17159: CALL 47244 0 4
// end ;
17163: PPOPN 4
17165: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17166: LD_VAR 0 1
17170: PPUSH
17171: CALL 97614 0 1
// end ; end_of_file
17175: PPOPN 1
17177: END
// every 0 0$1 trigger game do
17178: LD_EXP 2
17182: IFFALSE 17212
17184: GO 17186
17186: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17187: LD_INT 7
17189: PUSH
17190: LD_INT 6
17192: PUSH
17193: LD_INT 4
17195: PUSH
17196: LD_INT 6
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: LIST
17203: LIST
17204: PPUSH
17205: LD_INT 1750
17207: PPUSH
17208: CALL 17213 0 2
17212: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17213: LD_INT 0
17215: PPUSH
17216: PPUSH
17217: PPUSH
// if not areas then
17218: LD_VAR 0 1
17222: NOT
17223: IFFALSE 17227
// exit ;
17225: GO 17357
// repeat wait ( time ) ;
17227: LD_VAR 0 2
17231: PPUSH
17232: CALL_OW 67
// p := rand ( 1 , 90 ) ;
17236: LD_ADDR_VAR 0 5
17240: PUSH
17241: LD_INT 1
17243: PPUSH
17244: LD_INT 90
17246: PPUSH
17247: CALL_OW 12
17251: ST_TO_ADDR
// for i in areas do
17252: LD_ADDR_VAR 0 4
17256: PUSH
17257: LD_VAR 0 1
17261: PUSH
17262: FOR_IN
17263: IFFALSE 17316
// begin if Prob ( p ) then
17265: LD_VAR 0 5
17269: PPUSH
17270: CALL_OW 13
17274: IFFALSE 17314
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
17276: LD_INT 1
17278: PPUSH
17279: LD_INT 5
17281: PPUSH
17282: CALL_OW 12
17286: PPUSH
17287: LD_VAR 0 4
17291: PPUSH
17292: LD_INT 1
17294: PPUSH
17295: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
17299: LD_INT 385
17301: PPUSH
17302: LD_INT 595
17304: PPUSH
17305: CALL_OW 12
17309: PPUSH
17310: CALL_OW 67
// end ; end ;
17314: GO 17262
17316: POP
17317: POP
// time := time + 0 0$3 ;
17318: LD_ADDR_VAR 0 2
17322: PUSH
17323: LD_VAR 0 2
17327: PUSH
17328: LD_INT 105
17330: PLUS
17331: ST_TO_ADDR
// if time > 7 7$00 then
17332: LD_VAR 0 2
17336: PUSH
17337: LD_INT 14700
17339: GREATER
17340: IFFALSE 17350
// time := 0 0$40 ;
17342: LD_ADDR_VAR 0 2
17346: PUSH
17347: LD_INT 1400
17349: ST_TO_ADDR
// until not game ;
17350: LD_EXP 2
17354: NOT
17355: IFFALSE 17227
// end ; end_of_file
17357: LD_VAR 0 3
17361: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
17362: LD_INT 0
17364: PPUSH
17365: PPUSH
// skirmish := false ;
17366: LD_ADDR_EXP 48
17370: PUSH
17371: LD_INT 0
17373: ST_TO_ADDR
// debug_mc := false ;
17374: LD_ADDR_EXP 49
17378: PUSH
17379: LD_INT 0
17381: ST_TO_ADDR
// mc_bases := [ ] ;
17382: LD_ADDR_EXP 50
17386: PUSH
17387: EMPTY
17388: ST_TO_ADDR
// mc_sides := [ ] ;
17389: LD_ADDR_EXP 76
17393: PUSH
17394: EMPTY
17395: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17396: LD_ADDR_EXP 51
17400: PUSH
17401: EMPTY
17402: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17403: LD_ADDR_EXP 52
17407: PUSH
17408: EMPTY
17409: ST_TO_ADDR
// mc_need_heal := [ ] ;
17410: LD_ADDR_EXP 53
17414: PUSH
17415: EMPTY
17416: ST_TO_ADDR
// mc_healers := [ ] ;
17417: LD_ADDR_EXP 54
17421: PUSH
17422: EMPTY
17423: ST_TO_ADDR
// mc_build_list := [ ] ;
17424: LD_ADDR_EXP 55
17428: PUSH
17429: EMPTY
17430: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17431: LD_ADDR_EXP 82
17435: PUSH
17436: EMPTY
17437: ST_TO_ADDR
// mc_builders := [ ] ;
17438: LD_ADDR_EXP 56
17442: PUSH
17443: EMPTY
17444: ST_TO_ADDR
// mc_construct_list := [ ] ;
17445: LD_ADDR_EXP 57
17449: PUSH
17450: EMPTY
17451: ST_TO_ADDR
// mc_turret_list := [ ] ;
17452: LD_ADDR_EXP 58
17456: PUSH
17457: EMPTY
17458: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17459: LD_ADDR_EXP 59
17463: PUSH
17464: EMPTY
17465: ST_TO_ADDR
// mc_miners := [ ] ;
17466: LD_ADDR_EXP 64
17470: PUSH
17471: EMPTY
17472: ST_TO_ADDR
// mc_mines := [ ] ;
17473: LD_ADDR_EXP 63
17477: PUSH
17478: EMPTY
17479: ST_TO_ADDR
// mc_minefields := [ ] ;
17480: LD_ADDR_EXP 65
17484: PUSH
17485: EMPTY
17486: ST_TO_ADDR
// mc_crates := [ ] ;
17487: LD_ADDR_EXP 66
17491: PUSH
17492: EMPTY
17493: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17494: LD_ADDR_EXP 67
17498: PUSH
17499: EMPTY
17500: ST_TO_ADDR
// mc_crates_area := [ ] ;
17501: LD_ADDR_EXP 68
17505: PUSH
17506: EMPTY
17507: ST_TO_ADDR
// mc_vehicles := [ ] ;
17508: LD_ADDR_EXP 69
17512: PUSH
17513: EMPTY
17514: ST_TO_ADDR
// mc_attack := [ ] ;
17515: LD_ADDR_EXP 70
17519: PUSH
17520: EMPTY
17521: ST_TO_ADDR
// mc_produce := [ ] ;
17522: LD_ADDR_EXP 71
17526: PUSH
17527: EMPTY
17528: ST_TO_ADDR
// mc_defender := [ ] ;
17529: LD_ADDR_EXP 72
17533: PUSH
17534: EMPTY
17535: ST_TO_ADDR
// mc_parking := [ ] ;
17536: LD_ADDR_EXP 74
17540: PUSH
17541: EMPTY
17542: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
17543: LD_ADDR_EXP 60
17547: PUSH
17548: EMPTY
17549: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
17550: LD_ADDR_EXP 62
17554: PUSH
17555: EMPTY
17556: ST_TO_ADDR
// mc_scan := [ ] ;
17557: LD_ADDR_EXP 73
17561: PUSH
17562: EMPTY
17563: ST_TO_ADDR
// mc_scan_area := [ ] ;
17564: LD_ADDR_EXP 75
17568: PUSH
17569: EMPTY
17570: ST_TO_ADDR
// mc_tech := [ ] ;
17571: LD_ADDR_EXP 77
17575: PUSH
17576: EMPTY
17577: ST_TO_ADDR
// mc_class := [ ] ;
17578: LD_ADDR_EXP 91
17582: PUSH
17583: EMPTY
17584: ST_TO_ADDR
// mc_class_case_use := [ ] ;
17585: LD_ADDR_EXP 92
17589: PUSH
17590: EMPTY
17591: ST_TO_ADDR
// end ;
17592: LD_VAR 0 1
17596: RET
// export function MC_Kill ( base ) ; begin
17597: LD_INT 0
17599: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
17600: LD_ADDR_EXP 50
17604: PUSH
17605: LD_EXP 50
17609: PPUSH
17610: LD_VAR 0 1
17614: PPUSH
17615: EMPTY
17616: PPUSH
17617: CALL_OW 1
17621: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
17622: LD_ADDR_EXP 51
17626: PUSH
17627: LD_EXP 51
17631: PPUSH
17632: LD_VAR 0 1
17636: PPUSH
17637: EMPTY
17638: PPUSH
17639: CALL_OW 1
17643: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
17644: LD_ADDR_EXP 52
17648: PUSH
17649: LD_EXP 52
17653: PPUSH
17654: LD_VAR 0 1
17658: PPUSH
17659: EMPTY
17660: PPUSH
17661: CALL_OW 1
17665: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
17666: LD_ADDR_EXP 53
17670: PUSH
17671: LD_EXP 53
17675: PPUSH
17676: LD_VAR 0 1
17680: PPUSH
17681: EMPTY
17682: PPUSH
17683: CALL_OW 1
17687: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
17688: LD_ADDR_EXP 54
17692: PUSH
17693: LD_EXP 54
17697: PPUSH
17698: LD_VAR 0 1
17702: PPUSH
17703: EMPTY
17704: PPUSH
17705: CALL_OW 1
17709: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
17710: LD_ADDR_EXP 55
17714: PUSH
17715: LD_EXP 55
17719: PPUSH
17720: LD_VAR 0 1
17724: PPUSH
17725: EMPTY
17726: PPUSH
17727: CALL_OW 1
17731: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
17732: LD_ADDR_EXP 56
17736: PUSH
17737: LD_EXP 56
17741: PPUSH
17742: LD_VAR 0 1
17746: PPUSH
17747: EMPTY
17748: PPUSH
17749: CALL_OW 1
17753: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
17754: LD_ADDR_EXP 57
17758: PUSH
17759: LD_EXP 57
17763: PPUSH
17764: LD_VAR 0 1
17768: PPUSH
17769: EMPTY
17770: PPUSH
17771: CALL_OW 1
17775: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17776: LD_ADDR_EXP 58
17780: PUSH
17781: LD_EXP 58
17785: PPUSH
17786: LD_VAR 0 1
17790: PPUSH
17791: EMPTY
17792: PPUSH
17793: CALL_OW 1
17797: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17798: LD_ADDR_EXP 59
17802: PUSH
17803: LD_EXP 59
17807: PPUSH
17808: LD_VAR 0 1
17812: PPUSH
17813: EMPTY
17814: PPUSH
17815: CALL_OW 1
17819: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17820: LD_ADDR_EXP 60
17824: PUSH
17825: LD_EXP 60
17829: PPUSH
17830: LD_VAR 0 1
17834: PPUSH
17835: EMPTY
17836: PPUSH
17837: CALL_OW 1
17841: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17842: LD_ADDR_EXP 61
17846: PUSH
17847: LD_EXP 61
17851: PPUSH
17852: LD_VAR 0 1
17856: PPUSH
17857: LD_INT 0
17859: PPUSH
17860: CALL_OW 1
17864: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17865: LD_ADDR_EXP 62
17869: PUSH
17870: LD_EXP 62
17874: PPUSH
17875: LD_VAR 0 1
17879: PPUSH
17880: EMPTY
17881: PPUSH
17882: CALL_OW 1
17886: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17887: LD_ADDR_EXP 63
17891: PUSH
17892: LD_EXP 63
17896: PPUSH
17897: LD_VAR 0 1
17901: PPUSH
17902: EMPTY
17903: PPUSH
17904: CALL_OW 1
17908: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17909: LD_ADDR_EXP 64
17913: PUSH
17914: LD_EXP 64
17918: PPUSH
17919: LD_VAR 0 1
17923: PPUSH
17924: EMPTY
17925: PPUSH
17926: CALL_OW 1
17930: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
17931: LD_ADDR_EXP 65
17935: PUSH
17936: LD_EXP 65
17940: PPUSH
17941: LD_VAR 0 1
17945: PPUSH
17946: EMPTY
17947: PPUSH
17948: CALL_OW 1
17952: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
17953: LD_ADDR_EXP 66
17957: PUSH
17958: LD_EXP 66
17962: PPUSH
17963: LD_VAR 0 1
17967: PPUSH
17968: EMPTY
17969: PPUSH
17970: CALL_OW 1
17974: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
17975: LD_ADDR_EXP 67
17979: PUSH
17980: LD_EXP 67
17984: PPUSH
17985: LD_VAR 0 1
17989: PPUSH
17990: EMPTY
17991: PPUSH
17992: CALL_OW 1
17996: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
17997: LD_ADDR_EXP 68
18001: PUSH
18002: LD_EXP 68
18006: PPUSH
18007: LD_VAR 0 1
18011: PPUSH
18012: EMPTY
18013: PPUSH
18014: CALL_OW 1
18018: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18019: LD_ADDR_EXP 69
18023: PUSH
18024: LD_EXP 69
18028: PPUSH
18029: LD_VAR 0 1
18033: PPUSH
18034: EMPTY
18035: PPUSH
18036: CALL_OW 1
18040: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18041: LD_ADDR_EXP 70
18045: PUSH
18046: LD_EXP 70
18050: PPUSH
18051: LD_VAR 0 1
18055: PPUSH
18056: EMPTY
18057: PPUSH
18058: CALL_OW 1
18062: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18063: LD_ADDR_EXP 71
18067: PUSH
18068: LD_EXP 71
18072: PPUSH
18073: LD_VAR 0 1
18077: PPUSH
18078: EMPTY
18079: PPUSH
18080: CALL_OW 1
18084: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18085: LD_ADDR_EXP 72
18089: PUSH
18090: LD_EXP 72
18094: PPUSH
18095: LD_VAR 0 1
18099: PPUSH
18100: EMPTY
18101: PPUSH
18102: CALL_OW 1
18106: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18107: LD_ADDR_EXP 73
18111: PUSH
18112: LD_EXP 73
18116: PPUSH
18117: LD_VAR 0 1
18121: PPUSH
18122: EMPTY
18123: PPUSH
18124: CALL_OW 1
18128: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18129: LD_ADDR_EXP 74
18133: PUSH
18134: LD_EXP 74
18138: PPUSH
18139: LD_VAR 0 1
18143: PPUSH
18144: EMPTY
18145: PPUSH
18146: CALL_OW 1
18150: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18151: LD_ADDR_EXP 75
18155: PUSH
18156: LD_EXP 75
18160: PPUSH
18161: LD_VAR 0 1
18165: PPUSH
18166: EMPTY
18167: PPUSH
18168: CALL_OW 1
18172: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18173: LD_ADDR_EXP 77
18177: PUSH
18178: LD_EXP 77
18182: PPUSH
18183: LD_VAR 0 1
18187: PPUSH
18188: EMPTY
18189: PPUSH
18190: CALL_OW 1
18194: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18195: LD_ADDR_EXP 79
18199: PUSH
18200: LD_EXP 79
18204: PPUSH
18205: LD_VAR 0 1
18209: PPUSH
18210: EMPTY
18211: PPUSH
18212: CALL_OW 1
18216: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18217: LD_ADDR_EXP 80
18221: PUSH
18222: LD_EXP 80
18226: PPUSH
18227: LD_VAR 0 1
18231: PPUSH
18232: EMPTY
18233: PPUSH
18234: CALL_OW 1
18238: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18239: LD_ADDR_EXP 81
18243: PUSH
18244: LD_EXP 81
18248: PPUSH
18249: LD_VAR 0 1
18253: PPUSH
18254: EMPTY
18255: PPUSH
18256: CALL_OW 1
18260: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18261: LD_ADDR_EXP 82
18265: PUSH
18266: LD_EXP 82
18270: PPUSH
18271: LD_VAR 0 1
18275: PPUSH
18276: EMPTY
18277: PPUSH
18278: CALL_OW 1
18282: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18283: LD_ADDR_EXP 83
18287: PUSH
18288: LD_EXP 83
18292: PPUSH
18293: LD_VAR 0 1
18297: PPUSH
18298: EMPTY
18299: PPUSH
18300: CALL_OW 1
18304: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18305: LD_ADDR_EXP 84
18309: PUSH
18310: LD_EXP 84
18314: PPUSH
18315: LD_VAR 0 1
18319: PPUSH
18320: EMPTY
18321: PPUSH
18322: CALL_OW 1
18326: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18327: LD_ADDR_EXP 85
18331: PUSH
18332: LD_EXP 85
18336: PPUSH
18337: LD_VAR 0 1
18341: PPUSH
18342: EMPTY
18343: PPUSH
18344: CALL_OW 1
18348: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18349: LD_ADDR_EXP 86
18353: PUSH
18354: LD_EXP 86
18358: PPUSH
18359: LD_VAR 0 1
18363: PPUSH
18364: EMPTY
18365: PPUSH
18366: CALL_OW 1
18370: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18371: LD_ADDR_EXP 87
18375: PUSH
18376: LD_EXP 87
18380: PPUSH
18381: LD_VAR 0 1
18385: PPUSH
18386: EMPTY
18387: PPUSH
18388: CALL_OW 1
18392: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18393: LD_ADDR_EXP 88
18397: PUSH
18398: LD_EXP 88
18402: PPUSH
18403: LD_VAR 0 1
18407: PPUSH
18408: EMPTY
18409: PPUSH
18410: CALL_OW 1
18414: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18415: LD_ADDR_EXP 89
18419: PUSH
18420: LD_EXP 89
18424: PPUSH
18425: LD_VAR 0 1
18429: PPUSH
18430: EMPTY
18431: PPUSH
18432: CALL_OW 1
18436: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18437: LD_ADDR_EXP 90
18441: PUSH
18442: LD_EXP 90
18446: PPUSH
18447: LD_VAR 0 1
18451: PPUSH
18452: EMPTY
18453: PPUSH
18454: CALL_OW 1
18458: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18459: LD_ADDR_EXP 91
18463: PUSH
18464: LD_EXP 91
18468: PPUSH
18469: LD_VAR 0 1
18473: PPUSH
18474: EMPTY
18475: PPUSH
18476: CALL_OW 1
18480: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18481: LD_ADDR_EXP 92
18485: PUSH
18486: LD_EXP 92
18490: PPUSH
18491: LD_VAR 0 1
18495: PPUSH
18496: LD_INT 0
18498: PPUSH
18499: CALL_OW 1
18503: ST_TO_ADDR
// end ;
18504: LD_VAR 0 2
18508: RET
// export function MC_Add ( side , units ) ; var base ; begin
18509: LD_INT 0
18511: PPUSH
18512: PPUSH
// base := mc_bases + 1 ;
18513: LD_ADDR_VAR 0 4
18517: PUSH
18518: LD_EXP 50
18522: PUSH
18523: LD_INT 1
18525: PLUS
18526: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
18527: LD_ADDR_EXP 76
18531: PUSH
18532: LD_EXP 76
18536: PPUSH
18537: LD_VAR 0 4
18541: PPUSH
18542: LD_VAR 0 1
18546: PPUSH
18547: CALL_OW 1
18551: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
18552: LD_ADDR_EXP 50
18556: PUSH
18557: LD_EXP 50
18561: PPUSH
18562: LD_VAR 0 4
18566: PPUSH
18567: LD_VAR 0 2
18571: PPUSH
18572: CALL_OW 1
18576: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18577: LD_ADDR_EXP 51
18581: PUSH
18582: LD_EXP 51
18586: PPUSH
18587: LD_VAR 0 4
18591: PPUSH
18592: EMPTY
18593: PPUSH
18594: CALL_OW 1
18598: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18599: LD_ADDR_EXP 52
18603: PUSH
18604: LD_EXP 52
18608: PPUSH
18609: LD_VAR 0 4
18613: PPUSH
18614: EMPTY
18615: PPUSH
18616: CALL_OW 1
18620: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18621: LD_ADDR_EXP 53
18625: PUSH
18626: LD_EXP 53
18630: PPUSH
18631: LD_VAR 0 4
18635: PPUSH
18636: EMPTY
18637: PPUSH
18638: CALL_OW 1
18642: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18643: LD_ADDR_EXP 54
18647: PUSH
18648: LD_EXP 54
18652: PPUSH
18653: LD_VAR 0 4
18657: PPUSH
18658: EMPTY
18659: PPUSH
18660: CALL_OW 1
18664: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18665: LD_ADDR_EXP 55
18669: PUSH
18670: LD_EXP 55
18674: PPUSH
18675: LD_VAR 0 4
18679: PPUSH
18680: EMPTY
18681: PPUSH
18682: CALL_OW 1
18686: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18687: LD_ADDR_EXP 56
18691: PUSH
18692: LD_EXP 56
18696: PPUSH
18697: LD_VAR 0 4
18701: PPUSH
18702: EMPTY
18703: PPUSH
18704: CALL_OW 1
18708: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18709: LD_ADDR_EXP 57
18713: PUSH
18714: LD_EXP 57
18718: PPUSH
18719: LD_VAR 0 4
18723: PPUSH
18724: EMPTY
18725: PPUSH
18726: CALL_OW 1
18730: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18731: LD_ADDR_EXP 58
18735: PUSH
18736: LD_EXP 58
18740: PPUSH
18741: LD_VAR 0 4
18745: PPUSH
18746: EMPTY
18747: PPUSH
18748: CALL_OW 1
18752: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18753: LD_ADDR_EXP 59
18757: PUSH
18758: LD_EXP 59
18762: PPUSH
18763: LD_VAR 0 4
18767: PPUSH
18768: EMPTY
18769: PPUSH
18770: CALL_OW 1
18774: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18775: LD_ADDR_EXP 60
18779: PUSH
18780: LD_EXP 60
18784: PPUSH
18785: LD_VAR 0 4
18789: PPUSH
18790: EMPTY
18791: PPUSH
18792: CALL_OW 1
18796: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18797: LD_ADDR_EXP 61
18801: PUSH
18802: LD_EXP 61
18806: PPUSH
18807: LD_VAR 0 4
18811: PPUSH
18812: LD_INT 0
18814: PPUSH
18815: CALL_OW 1
18819: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18820: LD_ADDR_EXP 62
18824: PUSH
18825: LD_EXP 62
18829: PPUSH
18830: LD_VAR 0 4
18834: PPUSH
18835: EMPTY
18836: PPUSH
18837: CALL_OW 1
18841: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18842: LD_ADDR_EXP 63
18846: PUSH
18847: LD_EXP 63
18851: PPUSH
18852: LD_VAR 0 4
18856: PPUSH
18857: EMPTY
18858: PPUSH
18859: CALL_OW 1
18863: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18864: LD_ADDR_EXP 64
18868: PUSH
18869: LD_EXP 64
18873: PPUSH
18874: LD_VAR 0 4
18878: PPUSH
18879: EMPTY
18880: PPUSH
18881: CALL_OW 1
18885: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18886: LD_ADDR_EXP 65
18890: PUSH
18891: LD_EXP 65
18895: PPUSH
18896: LD_VAR 0 4
18900: PPUSH
18901: EMPTY
18902: PPUSH
18903: CALL_OW 1
18907: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18908: LD_ADDR_EXP 66
18912: PUSH
18913: LD_EXP 66
18917: PPUSH
18918: LD_VAR 0 4
18922: PPUSH
18923: EMPTY
18924: PPUSH
18925: CALL_OW 1
18929: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18930: LD_ADDR_EXP 67
18934: PUSH
18935: LD_EXP 67
18939: PPUSH
18940: LD_VAR 0 4
18944: PPUSH
18945: EMPTY
18946: PPUSH
18947: CALL_OW 1
18951: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18952: LD_ADDR_EXP 68
18956: PUSH
18957: LD_EXP 68
18961: PPUSH
18962: LD_VAR 0 4
18966: PPUSH
18967: EMPTY
18968: PPUSH
18969: CALL_OW 1
18973: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18974: LD_ADDR_EXP 69
18978: PUSH
18979: LD_EXP 69
18983: PPUSH
18984: LD_VAR 0 4
18988: PPUSH
18989: EMPTY
18990: PPUSH
18991: CALL_OW 1
18995: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18996: LD_ADDR_EXP 70
19000: PUSH
19001: LD_EXP 70
19005: PPUSH
19006: LD_VAR 0 4
19010: PPUSH
19011: EMPTY
19012: PPUSH
19013: CALL_OW 1
19017: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19018: LD_ADDR_EXP 71
19022: PUSH
19023: LD_EXP 71
19027: PPUSH
19028: LD_VAR 0 4
19032: PPUSH
19033: EMPTY
19034: PPUSH
19035: CALL_OW 1
19039: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19040: LD_ADDR_EXP 72
19044: PUSH
19045: LD_EXP 72
19049: PPUSH
19050: LD_VAR 0 4
19054: PPUSH
19055: EMPTY
19056: PPUSH
19057: CALL_OW 1
19061: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19062: LD_ADDR_EXP 73
19066: PUSH
19067: LD_EXP 73
19071: PPUSH
19072: LD_VAR 0 4
19076: PPUSH
19077: EMPTY
19078: PPUSH
19079: CALL_OW 1
19083: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19084: LD_ADDR_EXP 74
19088: PUSH
19089: LD_EXP 74
19093: PPUSH
19094: LD_VAR 0 4
19098: PPUSH
19099: EMPTY
19100: PPUSH
19101: CALL_OW 1
19105: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19106: LD_ADDR_EXP 75
19110: PUSH
19111: LD_EXP 75
19115: PPUSH
19116: LD_VAR 0 4
19120: PPUSH
19121: EMPTY
19122: PPUSH
19123: CALL_OW 1
19127: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19128: LD_ADDR_EXP 77
19132: PUSH
19133: LD_EXP 77
19137: PPUSH
19138: LD_VAR 0 4
19142: PPUSH
19143: EMPTY
19144: PPUSH
19145: CALL_OW 1
19149: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19150: LD_ADDR_EXP 79
19154: PUSH
19155: LD_EXP 79
19159: PPUSH
19160: LD_VAR 0 4
19164: PPUSH
19165: EMPTY
19166: PPUSH
19167: CALL_OW 1
19171: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19172: LD_ADDR_EXP 80
19176: PUSH
19177: LD_EXP 80
19181: PPUSH
19182: LD_VAR 0 4
19186: PPUSH
19187: EMPTY
19188: PPUSH
19189: CALL_OW 1
19193: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19194: LD_ADDR_EXP 81
19198: PUSH
19199: LD_EXP 81
19203: PPUSH
19204: LD_VAR 0 4
19208: PPUSH
19209: EMPTY
19210: PPUSH
19211: CALL_OW 1
19215: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19216: LD_ADDR_EXP 82
19220: PUSH
19221: LD_EXP 82
19225: PPUSH
19226: LD_VAR 0 4
19230: PPUSH
19231: EMPTY
19232: PPUSH
19233: CALL_OW 1
19237: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19238: LD_ADDR_EXP 83
19242: PUSH
19243: LD_EXP 83
19247: PPUSH
19248: LD_VAR 0 4
19252: PPUSH
19253: EMPTY
19254: PPUSH
19255: CALL_OW 1
19259: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19260: LD_ADDR_EXP 84
19264: PUSH
19265: LD_EXP 84
19269: PPUSH
19270: LD_VAR 0 4
19274: PPUSH
19275: EMPTY
19276: PPUSH
19277: CALL_OW 1
19281: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19282: LD_ADDR_EXP 85
19286: PUSH
19287: LD_EXP 85
19291: PPUSH
19292: LD_VAR 0 4
19296: PPUSH
19297: EMPTY
19298: PPUSH
19299: CALL_OW 1
19303: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19304: LD_ADDR_EXP 86
19308: PUSH
19309: LD_EXP 86
19313: PPUSH
19314: LD_VAR 0 4
19318: PPUSH
19319: EMPTY
19320: PPUSH
19321: CALL_OW 1
19325: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19326: LD_ADDR_EXP 87
19330: PUSH
19331: LD_EXP 87
19335: PPUSH
19336: LD_VAR 0 4
19340: PPUSH
19341: EMPTY
19342: PPUSH
19343: CALL_OW 1
19347: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19348: LD_ADDR_EXP 88
19352: PUSH
19353: LD_EXP 88
19357: PPUSH
19358: LD_VAR 0 4
19362: PPUSH
19363: EMPTY
19364: PPUSH
19365: CALL_OW 1
19369: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19370: LD_ADDR_EXP 89
19374: PUSH
19375: LD_EXP 89
19379: PPUSH
19380: LD_VAR 0 4
19384: PPUSH
19385: EMPTY
19386: PPUSH
19387: CALL_OW 1
19391: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19392: LD_ADDR_EXP 90
19396: PUSH
19397: LD_EXP 90
19401: PPUSH
19402: LD_VAR 0 4
19406: PPUSH
19407: EMPTY
19408: PPUSH
19409: CALL_OW 1
19413: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19414: LD_ADDR_EXP 91
19418: PUSH
19419: LD_EXP 91
19423: PPUSH
19424: LD_VAR 0 4
19428: PPUSH
19429: EMPTY
19430: PPUSH
19431: CALL_OW 1
19435: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19436: LD_ADDR_EXP 92
19440: PUSH
19441: LD_EXP 92
19445: PPUSH
19446: LD_VAR 0 4
19450: PPUSH
19451: LD_INT 0
19453: PPUSH
19454: CALL_OW 1
19458: ST_TO_ADDR
// result := base ;
19459: LD_ADDR_VAR 0 3
19463: PUSH
19464: LD_VAR 0 4
19468: ST_TO_ADDR
// end ;
19469: LD_VAR 0 3
19473: RET
// export function MC_Start ( ) ; var i ; begin
19474: LD_INT 0
19476: PPUSH
19477: PPUSH
// for i = 1 to mc_bases do
19478: LD_ADDR_VAR 0 2
19482: PUSH
19483: DOUBLE
19484: LD_INT 1
19486: DEC
19487: ST_TO_ADDR
19488: LD_EXP 50
19492: PUSH
19493: FOR_TO
19494: IFFALSE 20571
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
19496: LD_ADDR_EXP 50
19500: PUSH
19501: LD_EXP 50
19505: PPUSH
19506: LD_VAR 0 2
19510: PPUSH
19511: LD_EXP 50
19515: PUSH
19516: LD_VAR 0 2
19520: ARRAY
19521: PUSH
19522: LD_INT 0
19524: DIFF
19525: PPUSH
19526: CALL_OW 1
19530: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
19531: LD_ADDR_EXP 51
19535: PUSH
19536: LD_EXP 51
19540: PPUSH
19541: LD_VAR 0 2
19545: PPUSH
19546: EMPTY
19547: PPUSH
19548: CALL_OW 1
19552: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19553: LD_ADDR_EXP 52
19557: PUSH
19558: LD_EXP 52
19562: PPUSH
19563: LD_VAR 0 2
19567: PPUSH
19568: EMPTY
19569: PPUSH
19570: CALL_OW 1
19574: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
19575: LD_ADDR_EXP 53
19579: PUSH
19580: LD_EXP 53
19584: PPUSH
19585: LD_VAR 0 2
19589: PPUSH
19590: EMPTY
19591: PPUSH
19592: CALL_OW 1
19596: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
19597: LD_ADDR_EXP 54
19601: PUSH
19602: LD_EXP 54
19606: PPUSH
19607: LD_VAR 0 2
19611: PPUSH
19612: EMPTY
19613: PUSH
19614: EMPTY
19615: PUSH
19616: EMPTY
19617: LIST
19618: LIST
19619: PPUSH
19620: CALL_OW 1
19624: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
19625: LD_ADDR_EXP 55
19629: PUSH
19630: LD_EXP 55
19634: PPUSH
19635: LD_VAR 0 2
19639: PPUSH
19640: EMPTY
19641: PPUSH
19642: CALL_OW 1
19646: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
19647: LD_ADDR_EXP 82
19651: PUSH
19652: LD_EXP 82
19656: PPUSH
19657: LD_VAR 0 2
19661: PPUSH
19662: EMPTY
19663: PPUSH
19664: CALL_OW 1
19668: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
19669: LD_ADDR_EXP 56
19673: PUSH
19674: LD_EXP 56
19678: PPUSH
19679: LD_VAR 0 2
19683: PPUSH
19684: EMPTY
19685: PPUSH
19686: CALL_OW 1
19690: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
19691: LD_ADDR_EXP 57
19695: PUSH
19696: LD_EXP 57
19700: PPUSH
19701: LD_VAR 0 2
19705: PPUSH
19706: EMPTY
19707: PPUSH
19708: CALL_OW 1
19712: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
19713: LD_ADDR_EXP 58
19717: PUSH
19718: LD_EXP 58
19722: PPUSH
19723: LD_VAR 0 2
19727: PPUSH
19728: LD_EXP 50
19732: PUSH
19733: LD_VAR 0 2
19737: ARRAY
19738: PPUSH
19739: LD_INT 2
19741: PUSH
19742: LD_INT 30
19744: PUSH
19745: LD_INT 32
19747: PUSH
19748: EMPTY
19749: LIST
19750: LIST
19751: PUSH
19752: LD_INT 30
19754: PUSH
19755: LD_INT 33
19757: PUSH
19758: EMPTY
19759: LIST
19760: LIST
19761: PUSH
19762: EMPTY
19763: LIST
19764: LIST
19765: LIST
19766: PPUSH
19767: CALL_OW 72
19771: PPUSH
19772: CALL_OW 1
19776: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
19777: LD_ADDR_EXP 59
19781: PUSH
19782: LD_EXP 59
19786: PPUSH
19787: LD_VAR 0 2
19791: PPUSH
19792: LD_EXP 50
19796: PUSH
19797: LD_VAR 0 2
19801: ARRAY
19802: PPUSH
19803: LD_INT 2
19805: PUSH
19806: LD_INT 30
19808: PUSH
19809: LD_INT 32
19811: PUSH
19812: EMPTY
19813: LIST
19814: LIST
19815: PUSH
19816: LD_INT 30
19818: PUSH
19819: LD_INT 31
19821: PUSH
19822: EMPTY
19823: LIST
19824: LIST
19825: PUSH
19826: EMPTY
19827: LIST
19828: LIST
19829: LIST
19830: PUSH
19831: LD_INT 58
19833: PUSH
19834: EMPTY
19835: LIST
19836: PUSH
19837: EMPTY
19838: LIST
19839: LIST
19840: PPUSH
19841: CALL_OW 72
19845: PPUSH
19846: CALL_OW 1
19850: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
19851: LD_ADDR_EXP 60
19855: PUSH
19856: LD_EXP 60
19860: PPUSH
19861: LD_VAR 0 2
19865: PPUSH
19866: EMPTY
19867: PPUSH
19868: CALL_OW 1
19872: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
19873: LD_ADDR_EXP 64
19877: PUSH
19878: LD_EXP 64
19882: PPUSH
19883: LD_VAR 0 2
19887: PPUSH
19888: EMPTY
19889: PPUSH
19890: CALL_OW 1
19894: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
19895: LD_ADDR_EXP 63
19899: PUSH
19900: LD_EXP 63
19904: PPUSH
19905: LD_VAR 0 2
19909: PPUSH
19910: EMPTY
19911: PPUSH
19912: CALL_OW 1
19916: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
19917: LD_ADDR_EXP 65
19921: PUSH
19922: LD_EXP 65
19926: PPUSH
19927: LD_VAR 0 2
19931: PPUSH
19932: EMPTY
19933: PPUSH
19934: CALL_OW 1
19938: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
19939: LD_ADDR_EXP 66
19943: PUSH
19944: LD_EXP 66
19948: PPUSH
19949: LD_VAR 0 2
19953: PPUSH
19954: EMPTY
19955: PPUSH
19956: CALL_OW 1
19960: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
19961: LD_ADDR_EXP 67
19965: PUSH
19966: LD_EXP 67
19970: PPUSH
19971: LD_VAR 0 2
19975: PPUSH
19976: EMPTY
19977: PPUSH
19978: CALL_OW 1
19982: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
19983: LD_ADDR_EXP 68
19987: PUSH
19988: LD_EXP 68
19992: PPUSH
19993: LD_VAR 0 2
19997: PPUSH
19998: EMPTY
19999: PPUSH
20000: CALL_OW 1
20004: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20005: LD_ADDR_EXP 69
20009: PUSH
20010: LD_EXP 69
20014: PPUSH
20015: LD_VAR 0 2
20019: PPUSH
20020: EMPTY
20021: PPUSH
20022: CALL_OW 1
20026: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20027: LD_ADDR_EXP 70
20031: PUSH
20032: LD_EXP 70
20036: PPUSH
20037: LD_VAR 0 2
20041: PPUSH
20042: EMPTY
20043: PPUSH
20044: CALL_OW 1
20048: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20049: LD_ADDR_EXP 71
20053: PUSH
20054: LD_EXP 71
20058: PPUSH
20059: LD_VAR 0 2
20063: PPUSH
20064: EMPTY
20065: PPUSH
20066: CALL_OW 1
20070: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20071: LD_ADDR_EXP 72
20075: PUSH
20076: LD_EXP 72
20080: PPUSH
20081: LD_VAR 0 2
20085: PPUSH
20086: EMPTY
20087: PPUSH
20088: CALL_OW 1
20092: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20093: LD_ADDR_EXP 61
20097: PUSH
20098: LD_EXP 61
20102: PPUSH
20103: LD_VAR 0 2
20107: PPUSH
20108: LD_INT 0
20110: PPUSH
20111: CALL_OW 1
20115: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20116: LD_ADDR_EXP 74
20120: PUSH
20121: LD_EXP 74
20125: PPUSH
20126: LD_VAR 0 2
20130: PPUSH
20131: LD_INT 0
20133: PPUSH
20134: CALL_OW 1
20138: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20139: LD_ADDR_EXP 62
20143: PUSH
20144: LD_EXP 62
20148: PPUSH
20149: LD_VAR 0 2
20153: PPUSH
20154: EMPTY
20155: PPUSH
20156: CALL_OW 1
20160: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20161: LD_ADDR_EXP 73
20165: PUSH
20166: LD_EXP 73
20170: PPUSH
20171: LD_VAR 0 2
20175: PPUSH
20176: LD_INT 0
20178: PPUSH
20179: CALL_OW 1
20183: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20184: LD_ADDR_EXP 75
20188: PUSH
20189: LD_EXP 75
20193: PPUSH
20194: LD_VAR 0 2
20198: PPUSH
20199: EMPTY
20200: PPUSH
20201: CALL_OW 1
20205: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20206: LD_ADDR_EXP 78
20210: PUSH
20211: LD_EXP 78
20215: PPUSH
20216: LD_VAR 0 2
20220: PPUSH
20221: LD_INT 0
20223: PPUSH
20224: CALL_OW 1
20228: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20229: LD_ADDR_EXP 79
20233: PUSH
20234: LD_EXP 79
20238: PPUSH
20239: LD_VAR 0 2
20243: PPUSH
20244: EMPTY
20245: PPUSH
20246: CALL_OW 1
20250: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20251: LD_ADDR_EXP 80
20255: PUSH
20256: LD_EXP 80
20260: PPUSH
20261: LD_VAR 0 2
20265: PPUSH
20266: EMPTY
20267: PPUSH
20268: CALL_OW 1
20272: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20273: LD_ADDR_EXP 81
20277: PUSH
20278: LD_EXP 81
20282: PPUSH
20283: LD_VAR 0 2
20287: PPUSH
20288: EMPTY
20289: PPUSH
20290: CALL_OW 1
20294: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20295: LD_ADDR_EXP 83
20299: PUSH
20300: LD_EXP 83
20304: PPUSH
20305: LD_VAR 0 2
20309: PPUSH
20310: LD_EXP 50
20314: PUSH
20315: LD_VAR 0 2
20319: ARRAY
20320: PPUSH
20321: LD_INT 2
20323: PUSH
20324: LD_INT 30
20326: PUSH
20327: LD_INT 6
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: PUSH
20334: LD_INT 30
20336: PUSH
20337: LD_INT 7
20339: PUSH
20340: EMPTY
20341: LIST
20342: LIST
20343: PUSH
20344: LD_INT 30
20346: PUSH
20347: LD_INT 8
20349: PUSH
20350: EMPTY
20351: LIST
20352: LIST
20353: PUSH
20354: EMPTY
20355: LIST
20356: LIST
20357: LIST
20358: LIST
20359: PPUSH
20360: CALL_OW 72
20364: PPUSH
20365: CALL_OW 1
20369: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20370: LD_ADDR_EXP 84
20374: PUSH
20375: LD_EXP 84
20379: PPUSH
20380: LD_VAR 0 2
20384: PPUSH
20385: EMPTY
20386: PPUSH
20387: CALL_OW 1
20391: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20392: LD_ADDR_EXP 85
20396: PUSH
20397: LD_EXP 85
20401: PPUSH
20402: LD_VAR 0 2
20406: PPUSH
20407: EMPTY
20408: PPUSH
20409: CALL_OW 1
20413: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20414: LD_ADDR_EXP 86
20418: PUSH
20419: LD_EXP 86
20423: PPUSH
20424: LD_VAR 0 2
20428: PPUSH
20429: EMPTY
20430: PPUSH
20431: CALL_OW 1
20435: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20436: LD_ADDR_EXP 87
20440: PUSH
20441: LD_EXP 87
20445: PPUSH
20446: LD_VAR 0 2
20450: PPUSH
20451: EMPTY
20452: PPUSH
20453: CALL_OW 1
20457: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20458: LD_ADDR_EXP 88
20462: PUSH
20463: LD_EXP 88
20467: PPUSH
20468: LD_VAR 0 2
20472: PPUSH
20473: EMPTY
20474: PPUSH
20475: CALL_OW 1
20479: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
20480: LD_ADDR_EXP 89
20484: PUSH
20485: LD_EXP 89
20489: PPUSH
20490: LD_VAR 0 2
20494: PPUSH
20495: EMPTY
20496: PPUSH
20497: CALL_OW 1
20501: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
20502: LD_ADDR_EXP 90
20506: PUSH
20507: LD_EXP 90
20511: PPUSH
20512: LD_VAR 0 2
20516: PPUSH
20517: EMPTY
20518: PPUSH
20519: CALL_OW 1
20523: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
20524: LD_ADDR_EXP 91
20528: PUSH
20529: LD_EXP 91
20533: PPUSH
20534: LD_VAR 0 2
20538: PPUSH
20539: EMPTY
20540: PPUSH
20541: CALL_OW 1
20545: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
20546: LD_ADDR_EXP 92
20550: PUSH
20551: LD_EXP 92
20555: PPUSH
20556: LD_VAR 0 2
20560: PPUSH
20561: LD_INT 0
20563: PPUSH
20564: CALL_OW 1
20568: ST_TO_ADDR
// end ;
20569: GO 19493
20571: POP
20572: POP
// MC_InitSides ( ) ;
20573: CALL 20859 0 0
// MC_InitResearch ( ) ;
20577: CALL 20598 0 0
// CustomInitMacro ( ) ;
20581: CALL 300 0 0
// skirmish := true ;
20585: LD_ADDR_EXP 48
20589: PUSH
20590: LD_INT 1
20592: ST_TO_ADDR
// end ;
20593: LD_VAR 0 1
20597: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
20598: LD_INT 0
20600: PPUSH
20601: PPUSH
20602: PPUSH
20603: PPUSH
20604: PPUSH
20605: PPUSH
// if not mc_bases then
20606: LD_EXP 50
20610: NOT
20611: IFFALSE 20615
// exit ;
20613: GO 20854
// for i = 1 to 8 do
20615: LD_ADDR_VAR 0 2
20619: PUSH
20620: DOUBLE
20621: LD_INT 1
20623: DEC
20624: ST_TO_ADDR
20625: LD_INT 8
20627: PUSH
20628: FOR_TO
20629: IFFALSE 20655
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
20631: LD_ADDR_EXP 77
20635: PUSH
20636: LD_EXP 77
20640: PPUSH
20641: LD_VAR 0 2
20645: PPUSH
20646: EMPTY
20647: PPUSH
20648: CALL_OW 1
20652: ST_TO_ADDR
20653: GO 20628
20655: POP
20656: POP
// tmp := [ ] ;
20657: LD_ADDR_VAR 0 5
20661: PUSH
20662: EMPTY
20663: ST_TO_ADDR
// for i = 1 to mc_sides do
20664: LD_ADDR_VAR 0 2
20668: PUSH
20669: DOUBLE
20670: LD_INT 1
20672: DEC
20673: ST_TO_ADDR
20674: LD_EXP 76
20678: PUSH
20679: FOR_TO
20680: IFFALSE 20738
// if not mc_sides [ i ] in tmp then
20682: LD_EXP 76
20686: PUSH
20687: LD_VAR 0 2
20691: ARRAY
20692: PUSH
20693: LD_VAR 0 5
20697: IN
20698: NOT
20699: IFFALSE 20736
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
20701: LD_ADDR_VAR 0 5
20705: PUSH
20706: LD_VAR 0 5
20710: PPUSH
20711: LD_VAR 0 5
20715: PUSH
20716: LD_INT 1
20718: PLUS
20719: PPUSH
20720: LD_EXP 76
20724: PUSH
20725: LD_VAR 0 2
20729: ARRAY
20730: PPUSH
20731: CALL_OW 2
20735: ST_TO_ADDR
20736: GO 20679
20738: POP
20739: POP
// if not tmp then
20740: LD_VAR 0 5
20744: NOT
20745: IFFALSE 20749
// exit ;
20747: GO 20854
// for j in tmp do
20749: LD_ADDR_VAR 0 3
20753: PUSH
20754: LD_VAR 0 5
20758: PUSH
20759: FOR_IN
20760: IFFALSE 20852
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
20762: LD_ADDR_VAR 0 6
20766: PUSH
20767: LD_INT 22
20769: PUSH
20770: LD_VAR 0 3
20774: PUSH
20775: EMPTY
20776: LIST
20777: LIST
20778: PPUSH
20779: CALL_OW 69
20783: ST_TO_ADDR
// if not un then
20784: LD_VAR 0 6
20788: NOT
20789: IFFALSE 20793
// continue ;
20791: GO 20759
// nation := GetNation ( un [ 1 ] ) ;
20793: LD_ADDR_VAR 0 4
20797: PUSH
20798: LD_VAR 0 6
20802: PUSH
20803: LD_INT 1
20805: ARRAY
20806: PPUSH
20807: CALL_OW 248
20811: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
20812: LD_ADDR_EXP 77
20816: PUSH
20817: LD_EXP 77
20821: PPUSH
20822: LD_VAR 0 3
20826: PPUSH
20827: LD_VAR 0 3
20831: PPUSH
20832: LD_VAR 0 4
20836: PPUSH
20837: LD_INT 1
20839: PPUSH
20840: CALL 47448 0 3
20844: PPUSH
20845: CALL_OW 1
20849: ST_TO_ADDR
// end ;
20850: GO 20759
20852: POP
20853: POP
// end ;
20854: LD_VAR 0 1
20858: RET
// export function MC_InitSides ( ) ; var i ; begin
20859: LD_INT 0
20861: PPUSH
20862: PPUSH
// if not mc_bases then
20863: LD_EXP 50
20867: NOT
20868: IFFALSE 20872
// exit ;
20870: GO 20946
// for i = 1 to mc_bases do
20872: LD_ADDR_VAR 0 2
20876: PUSH
20877: DOUBLE
20878: LD_INT 1
20880: DEC
20881: ST_TO_ADDR
20882: LD_EXP 50
20886: PUSH
20887: FOR_TO
20888: IFFALSE 20944
// if mc_bases [ i ] then
20890: LD_EXP 50
20894: PUSH
20895: LD_VAR 0 2
20899: ARRAY
20900: IFFALSE 20942
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
20902: LD_ADDR_EXP 76
20906: PUSH
20907: LD_EXP 76
20911: PPUSH
20912: LD_VAR 0 2
20916: PPUSH
20917: LD_EXP 50
20921: PUSH
20922: LD_VAR 0 2
20926: ARRAY
20927: PUSH
20928: LD_INT 1
20930: ARRAY
20931: PPUSH
20932: CALL_OW 255
20936: PPUSH
20937: CALL_OW 1
20941: ST_TO_ADDR
20942: GO 20887
20944: POP
20945: POP
// end ;
20946: LD_VAR 0 1
20950: RET
// every 0 0$01 trigger skirmish do
20951: LD_EXP 48
20955: IFFALSE 21109
20957: GO 20959
20959: DISABLE
// begin enable ;
20960: ENABLE
// MC_CheckBuildings ( ) ;
20961: CALL 25607 0 0
// MC_CheckPeopleLife ( ) ;
20965: CALL 25732 0 0
// RaiseSailEvent ( 100 ) ;
20969: LD_INT 100
20971: PPUSH
20972: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
20976: LD_INT 103
20978: PPUSH
20979: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
20983: LD_INT 104
20985: PPUSH
20986: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
20990: LD_INT 105
20992: PPUSH
20993: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
20997: LD_INT 106
20999: PPUSH
21000: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21004: LD_INT 107
21006: PPUSH
21007: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21011: LD_INT 108
21013: PPUSH
21014: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21018: LD_INT 109
21020: PPUSH
21021: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21025: LD_INT 110
21027: PPUSH
21028: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21032: LD_INT 111
21034: PPUSH
21035: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21039: LD_INT 112
21041: PPUSH
21042: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21046: LD_INT 113
21048: PPUSH
21049: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21053: LD_INT 120
21055: PPUSH
21056: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21060: LD_INT 121
21062: PPUSH
21063: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21067: LD_INT 122
21069: PPUSH
21070: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21074: LD_INT 123
21076: PPUSH
21077: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21081: LD_INT 124
21083: PPUSH
21084: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21088: LD_INT 125
21090: PPUSH
21091: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21095: LD_INT 126
21097: PPUSH
21098: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21102: LD_INT 200
21104: PPUSH
21105: CALL_OW 427
// end ;
21109: END
// on SailEvent ( event ) do begin if event < 100 then
21110: LD_VAR 0 1
21114: PUSH
21115: LD_INT 100
21117: LESS
21118: IFFALSE 21129
// CustomEvent ( event ) ;
21120: LD_VAR 0 1
21124: PPUSH
21125: CALL 16628 0 1
// if event = 100 then
21129: LD_VAR 0 1
21133: PUSH
21134: LD_INT 100
21136: EQUAL
21137: IFFALSE 21143
// MC_ClassManager ( ) ;
21139: CALL 21535 0 0
// if event = 101 then
21143: LD_VAR 0 1
21147: PUSH
21148: LD_INT 101
21150: EQUAL
21151: IFFALSE 21157
// MC_RepairBuildings ( ) ;
21153: CALL 26317 0 0
// if event = 102 then
21157: LD_VAR 0 1
21161: PUSH
21162: LD_INT 102
21164: EQUAL
21165: IFFALSE 21171
// MC_Heal ( ) ;
21167: CALL 27176 0 0
// if event = 103 then
21171: LD_VAR 0 1
21175: PUSH
21176: LD_INT 103
21178: EQUAL
21179: IFFALSE 21185
// MC_Build ( ) ;
21181: CALL 27598 0 0
// if event = 104 then
21185: LD_VAR 0 1
21189: PUSH
21190: LD_INT 104
21192: EQUAL
21193: IFFALSE 21199
// MC_TurretWeapon ( ) ;
21195: CALL 29211 0 0
// if event = 105 then
21199: LD_VAR 0 1
21203: PUSH
21204: LD_INT 105
21206: EQUAL
21207: IFFALSE 21213
// MC_BuildUpgrade ( ) ;
21209: CALL 28762 0 0
// if event = 106 then
21213: LD_VAR 0 1
21217: PUSH
21218: LD_INT 106
21220: EQUAL
21221: IFFALSE 21227
// MC_PlantMines ( ) ;
21223: CALL 29641 0 0
// if event = 107 then
21227: LD_VAR 0 1
21231: PUSH
21232: LD_INT 107
21234: EQUAL
21235: IFFALSE 21241
// MC_CollectCrates ( ) ;
21237: CALL 30439 0 0
// if event = 108 then
21241: LD_VAR 0 1
21245: PUSH
21246: LD_INT 108
21248: EQUAL
21249: IFFALSE 21255
// MC_LinkRemoteControl ( ) ;
21251: CALL 32215 0 0
// if event = 109 then
21255: LD_VAR 0 1
21259: PUSH
21260: LD_INT 109
21262: EQUAL
21263: IFFALSE 21269
// MC_ProduceVehicle ( ) ;
21265: CALL 32396 0 0
// if event = 110 then
21269: LD_VAR 0 1
21273: PUSH
21274: LD_INT 110
21276: EQUAL
21277: IFFALSE 21283
// MC_SendAttack ( ) ;
21279: CALL 32862 0 0
// if event = 111 then
21283: LD_VAR 0 1
21287: PUSH
21288: LD_INT 111
21290: EQUAL
21291: IFFALSE 21297
// MC_Defend ( ) ;
21293: CALL 32970 0 0
// if event = 112 then
21297: LD_VAR 0 1
21301: PUSH
21302: LD_INT 112
21304: EQUAL
21305: IFFALSE 21311
// MC_Research ( ) ;
21307: CALL 33575 0 0
// if event = 113 then
21311: LD_VAR 0 1
21315: PUSH
21316: LD_INT 113
21318: EQUAL
21319: IFFALSE 21325
// MC_MinesTrigger ( ) ;
21321: CALL 34689 0 0
// if event = 120 then
21325: LD_VAR 0 1
21329: PUSH
21330: LD_INT 120
21332: EQUAL
21333: IFFALSE 21339
// MC_RepairVehicle ( ) ;
21335: CALL 34788 0 0
// if event = 121 then
21339: LD_VAR 0 1
21343: PUSH
21344: LD_INT 121
21346: EQUAL
21347: IFFALSE 21353
// MC_TameApe ( ) ;
21349: CALL 35518 0 0
// if event = 122 then
21353: LD_VAR 0 1
21357: PUSH
21358: LD_INT 122
21360: EQUAL
21361: IFFALSE 21367
// MC_ChangeApeClass ( ) ;
21363: CALL 36347 0 0
// if event = 123 then
21367: LD_VAR 0 1
21371: PUSH
21372: LD_INT 123
21374: EQUAL
21375: IFFALSE 21381
// MC_Bazooka ( ) ;
21377: CALL 36997 0 0
// if event = 124 then
21381: LD_VAR 0 1
21385: PUSH
21386: LD_INT 124
21388: EQUAL
21389: IFFALSE 21395
// MC_TeleportExit ( ) ;
21391: CALL 37195 0 0
// if event = 125 then
21395: LD_VAR 0 1
21399: PUSH
21400: LD_INT 125
21402: EQUAL
21403: IFFALSE 21409
// MC_Deposits ( ) ;
21405: CALL 37842 0 0
// if event = 126 then
21409: LD_VAR 0 1
21413: PUSH
21414: LD_INT 126
21416: EQUAL
21417: IFFALSE 21423
// MC_RemoteDriver ( ) ;
21419: CALL 38467 0 0
// if event = 200 then
21423: LD_VAR 0 1
21427: PUSH
21428: LD_INT 200
21430: EQUAL
21431: IFFALSE 21437
// MC_Idle ( ) ;
21433: CALL 40416 0 0
// end ;
21437: PPOPN 1
21439: END
// export function MC_Reset ( base , tag ) ; var i ; begin
21440: LD_INT 0
21442: PPUSH
21443: PPUSH
// if not mc_bases [ base ] or not tag then
21444: LD_EXP 50
21448: PUSH
21449: LD_VAR 0 1
21453: ARRAY
21454: NOT
21455: PUSH
21456: LD_VAR 0 2
21460: NOT
21461: OR
21462: IFFALSE 21466
// exit ;
21464: GO 21530
// for i in mc_bases [ base ] union mc_ape [ base ] do
21466: LD_ADDR_VAR 0 4
21470: PUSH
21471: LD_EXP 50
21475: PUSH
21476: LD_VAR 0 1
21480: ARRAY
21481: PUSH
21482: LD_EXP 79
21486: PUSH
21487: LD_VAR 0 1
21491: ARRAY
21492: UNION
21493: PUSH
21494: FOR_IN
21495: IFFALSE 21528
// if GetTag ( i ) = tag then
21497: LD_VAR 0 4
21501: PPUSH
21502: CALL_OW 110
21506: PUSH
21507: LD_VAR 0 2
21511: EQUAL
21512: IFFALSE 21526
// SetTag ( i , 0 ) ;
21514: LD_VAR 0 4
21518: PPUSH
21519: LD_INT 0
21521: PPUSH
21522: CALL_OW 109
21526: GO 21494
21528: POP
21529: POP
// end ;
21530: LD_VAR 0 3
21534: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
21535: LD_INT 0
21537: PPUSH
21538: PPUSH
21539: PPUSH
21540: PPUSH
21541: PPUSH
21542: PPUSH
21543: PPUSH
21544: PPUSH
// if not mc_bases then
21545: LD_EXP 50
21549: NOT
21550: IFFALSE 21554
// exit ;
21552: GO 22012
// for i = 1 to mc_bases do
21554: LD_ADDR_VAR 0 2
21558: PUSH
21559: DOUBLE
21560: LD_INT 1
21562: DEC
21563: ST_TO_ADDR
21564: LD_EXP 50
21568: PUSH
21569: FOR_TO
21570: IFFALSE 22010
// begin tmp := MC_ClassCheckReq ( i ) ;
21572: LD_ADDR_VAR 0 4
21576: PUSH
21577: LD_VAR 0 2
21581: PPUSH
21582: CALL 22017 0 1
21586: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
21587: LD_ADDR_EXP 91
21591: PUSH
21592: LD_EXP 91
21596: PPUSH
21597: LD_VAR 0 2
21601: PPUSH
21602: LD_VAR 0 4
21606: PPUSH
21607: CALL_OW 1
21611: ST_TO_ADDR
// if not tmp then
21612: LD_VAR 0 4
21616: NOT
21617: IFFALSE 21621
// continue ;
21619: GO 21569
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
21621: LD_ADDR_VAR 0 6
21625: PUSH
21626: LD_EXP 50
21630: PUSH
21631: LD_VAR 0 2
21635: ARRAY
21636: PPUSH
21637: LD_INT 2
21639: PUSH
21640: LD_INT 30
21642: PUSH
21643: LD_INT 4
21645: PUSH
21646: EMPTY
21647: LIST
21648: LIST
21649: PUSH
21650: LD_INT 30
21652: PUSH
21653: LD_INT 5
21655: PUSH
21656: EMPTY
21657: LIST
21658: LIST
21659: PUSH
21660: EMPTY
21661: LIST
21662: LIST
21663: LIST
21664: PPUSH
21665: CALL_OW 72
21669: PUSH
21670: LD_EXP 50
21674: PUSH
21675: LD_VAR 0 2
21679: ARRAY
21680: PPUSH
21681: LD_INT 2
21683: PUSH
21684: LD_INT 30
21686: PUSH
21687: LD_INT 0
21689: PUSH
21690: EMPTY
21691: LIST
21692: LIST
21693: PUSH
21694: LD_INT 30
21696: PUSH
21697: LD_INT 1
21699: PUSH
21700: EMPTY
21701: LIST
21702: LIST
21703: PUSH
21704: EMPTY
21705: LIST
21706: LIST
21707: LIST
21708: PPUSH
21709: CALL_OW 72
21713: PUSH
21714: LD_EXP 50
21718: PUSH
21719: LD_VAR 0 2
21723: ARRAY
21724: PPUSH
21725: LD_INT 30
21727: PUSH
21728: LD_INT 3
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: PPUSH
21735: CALL_OW 72
21739: PUSH
21740: LD_EXP 50
21744: PUSH
21745: LD_VAR 0 2
21749: ARRAY
21750: PPUSH
21751: LD_INT 2
21753: PUSH
21754: LD_INT 30
21756: PUSH
21757: LD_INT 6
21759: PUSH
21760: EMPTY
21761: LIST
21762: LIST
21763: PUSH
21764: LD_INT 30
21766: PUSH
21767: LD_INT 7
21769: PUSH
21770: EMPTY
21771: LIST
21772: LIST
21773: PUSH
21774: LD_INT 30
21776: PUSH
21777: LD_INT 8
21779: PUSH
21780: EMPTY
21781: LIST
21782: LIST
21783: PUSH
21784: EMPTY
21785: LIST
21786: LIST
21787: LIST
21788: LIST
21789: PPUSH
21790: CALL_OW 72
21794: PUSH
21795: EMPTY
21796: LIST
21797: LIST
21798: LIST
21799: LIST
21800: ST_TO_ADDR
// for j = 1 to 4 do
21801: LD_ADDR_VAR 0 3
21805: PUSH
21806: DOUBLE
21807: LD_INT 1
21809: DEC
21810: ST_TO_ADDR
21811: LD_INT 4
21813: PUSH
21814: FOR_TO
21815: IFFALSE 22006
// begin if not tmp [ j ] then
21817: LD_VAR 0 4
21821: PUSH
21822: LD_VAR 0 3
21826: ARRAY
21827: NOT
21828: IFFALSE 21832
// continue ;
21830: GO 21814
// for p in tmp [ j ] do
21832: LD_ADDR_VAR 0 5
21836: PUSH
21837: LD_VAR 0 4
21841: PUSH
21842: LD_VAR 0 3
21846: ARRAY
21847: PUSH
21848: FOR_IN
21849: IFFALSE 22002
// begin if not b [ j ] then
21851: LD_VAR 0 6
21855: PUSH
21856: LD_VAR 0 3
21860: ARRAY
21861: NOT
21862: IFFALSE 21866
// break ;
21864: GO 22002
// e := 0 ;
21866: LD_ADDR_VAR 0 7
21870: PUSH
21871: LD_INT 0
21873: ST_TO_ADDR
// for k in b [ j ] do
21874: LD_ADDR_VAR 0 8
21878: PUSH
21879: LD_VAR 0 6
21883: PUSH
21884: LD_VAR 0 3
21888: ARRAY
21889: PUSH
21890: FOR_IN
21891: IFFALSE 21918
// if IsNotFull ( k ) then
21893: LD_VAR 0 8
21897: PPUSH
21898: CALL 49597 0 1
21902: IFFALSE 21916
// begin e := k ;
21904: LD_ADDR_VAR 0 7
21908: PUSH
21909: LD_VAR 0 8
21913: ST_TO_ADDR
// break ;
21914: GO 21918
// end ;
21916: GO 21890
21918: POP
21919: POP
// if e and not UnitGoingToBuilding ( p , e ) then
21920: LD_VAR 0 7
21924: PUSH
21925: LD_VAR 0 5
21929: PPUSH
21930: LD_VAR 0 7
21934: PPUSH
21935: CALL 82017 0 2
21939: NOT
21940: AND
21941: IFFALSE 22000
// begin if IsInUnit ( p ) then
21943: LD_VAR 0 5
21947: PPUSH
21948: CALL_OW 310
21952: IFFALSE 21963
// ComExitBuilding ( p ) ;
21954: LD_VAR 0 5
21958: PPUSH
21959: CALL_OW 122
// ComEnterUnit ( p , e ) ;
21963: LD_VAR 0 5
21967: PPUSH
21968: LD_VAR 0 7
21972: PPUSH
21973: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
21977: LD_VAR 0 5
21981: PPUSH
21982: LD_VAR 0 3
21986: PPUSH
21987: CALL_OW 183
// AddComExitBuilding ( p ) ;
21991: LD_VAR 0 5
21995: PPUSH
21996: CALL_OW 182
// end ; end ;
22000: GO 21848
22002: POP
22003: POP
// end ;
22004: GO 21814
22006: POP
22007: POP
// end ;
22008: GO 21569
22010: POP
22011: POP
// end ;
22012: LD_VAR 0 1
22016: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22017: LD_INT 0
22019: PPUSH
22020: PPUSH
22021: PPUSH
22022: PPUSH
22023: PPUSH
22024: PPUSH
22025: PPUSH
22026: PPUSH
22027: PPUSH
22028: PPUSH
22029: PPUSH
22030: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22031: LD_VAR 0 1
22035: NOT
22036: PUSH
22037: LD_EXP 50
22041: PUSH
22042: LD_VAR 0 1
22046: ARRAY
22047: NOT
22048: OR
22049: PUSH
22050: LD_EXP 50
22054: PUSH
22055: LD_VAR 0 1
22059: ARRAY
22060: PPUSH
22061: LD_INT 2
22063: PUSH
22064: LD_INT 30
22066: PUSH
22067: LD_INT 0
22069: PUSH
22070: EMPTY
22071: LIST
22072: LIST
22073: PUSH
22074: LD_INT 30
22076: PUSH
22077: LD_INT 1
22079: PUSH
22080: EMPTY
22081: LIST
22082: LIST
22083: PUSH
22084: EMPTY
22085: LIST
22086: LIST
22087: LIST
22088: PPUSH
22089: CALL_OW 72
22093: NOT
22094: OR
22095: IFFALSE 22099
// exit ;
22097: GO 25602
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22099: LD_ADDR_VAR 0 4
22103: PUSH
22104: LD_EXP 50
22108: PUSH
22109: LD_VAR 0 1
22113: ARRAY
22114: PPUSH
22115: LD_INT 2
22117: PUSH
22118: LD_INT 25
22120: PUSH
22121: LD_INT 1
22123: PUSH
22124: EMPTY
22125: LIST
22126: LIST
22127: PUSH
22128: LD_INT 25
22130: PUSH
22131: LD_INT 2
22133: PUSH
22134: EMPTY
22135: LIST
22136: LIST
22137: PUSH
22138: LD_INT 25
22140: PUSH
22141: LD_INT 3
22143: PUSH
22144: EMPTY
22145: LIST
22146: LIST
22147: PUSH
22148: LD_INT 25
22150: PUSH
22151: LD_INT 4
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: PUSH
22158: LD_INT 25
22160: PUSH
22161: LD_INT 5
22163: PUSH
22164: EMPTY
22165: LIST
22166: LIST
22167: PUSH
22168: LD_INT 25
22170: PUSH
22171: LD_INT 8
22173: PUSH
22174: EMPTY
22175: LIST
22176: LIST
22177: PUSH
22178: LD_INT 25
22180: PUSH
22181: LD_INT 9
22183: PUSH
22184: EMPTY
22185: LIST
22186: LIST
22187: PUSH
22188: EMPTY
22189: LIST
22190: LIST
22191: LIST
22192: LIST
22193: LIST
22194: LIST
22195: LIST
22196: LIST
22197: PPUSH
22198: CALL_OW 72
22202: ST_TO_ADDR
// if not tmp then
22203: LD_VAR 0 4
22207: NOT
22208: IFFALSE 22212
// exit ;
22210: GO 25602
// for i in tmp do
22212: LD_ADDR_VAR 0 3
22216: PUSH
22217: LD_VAR 0 4
22221: PUSH
22222: FOR_IN
22223: IFFALSE 22254
// if GetTag ( i ) then
22225: LD_VAR 0 3
22229: PPUSH
22230: CALL_OW 110
22234: IFFALSE 22252
// tmp := tmp diff i ;
22236: LD_ADDR_VAR 0 4
22240: PUSH
22241: LD_VAR 0 4
22245: PUSH
22246: LD_VAR 0 3
22250: DIFF
22251: ST_TO_ADDR
22252: GO 22222
22254: POP
22255: POP
// if not tmp then
22256: LD_VAR 0 4
22260: NOT
22261: IFFALSE 22265
// exit ;
22263: GO 25602
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22265: LD_ADDR_VAR 0 5
22269: PUSH
22270: LD_EXP 50
22274: PUSH
22275: LD_VAR 0 1
22279: ARRAY
22280: PPUSH
22281: LD_INT 2
22283: PUSH
22284: LD_INT 25
22286: PUSH
22287: LD_INT 1
22289: PUSH
22290: EMPTY
22291: LIST
22292: LIST
22293: PUSH
22294: LD_INT 25
22296: PUSH
22297: LD_INT 5
22299: PUSH
22300: EMPTY
22301: LIST
22302: LIST
22303: PUSH
22304: LD_INT 25
22306: PUSH
22307: LD_INT 8
22309: PUSH
22310: EMPTY
22311: LIST
22312: LIST
22313: PUSH
22314: LD_INT 25
22316: PUSH
22317: LD_INT 9
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: LIST
22328: LIST
22329: LIST
22330: PPUSH
22331: CALL_OW 72
22335: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22336: LD_ADDR_VAR 0 6
22340: PUSH
22341: LD_EXP 50
22345: PUSH
22346: LD_VAR 0 1
22350: ARRAY
22351: PPUSH
22352: LD_INT 25
22354: PUSH
22355: LD_INT 2
22357: PUSH
22358: EMPTY
22359: LIST
22360: LIST
22361: PPUSH
22362: CALL_OW 72
22366: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22367: LD_ADDR_VAR 0 7
22371: PUSH
22372: LD_EXP 50
22376: PUSH
22377: LD_VAR 0 1
22381: ARRAY
22382: PPUSH
22383: LD_INT 25
22385: PUSH
22386: LD_INT 3
22388: PUSH
22389: EMPTY
22390: LIST
22391: LIST
22392: PPUSH
22393: CALL_OW 72
22397: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22398: LD_ADDR_VAR 0 8
22402: PUSH
22403: LD_EXP 50
22407: PUSH
22408: LD_VAR 0 1
22412: ARRAY
22413: PPUSH
22414: LD_INT 25
22416: PUSH
22417: LD_INT 4
22419: PUSH
22420: EMPTY
22421: LIST
22422: LIST
22423: PUSH
22424: LD_INT 24
22426: PUSH
22427: LD_INT 251
22429: PUSH
22430: EMPTY
22431: LIST
22432: LIST
22433: PUSH
22434: EMPTY
22435: LIST
22436: LIST
22437: PPUSH
22438: CALL_OW 72
22442: ST_TO_ADDR
// if mc_scan [ base ] then
22443: LD_EXP 73
22447: PUSH
22448: LD_VAR 0 1
22452: ARRAY
22453: IFFALSE 22914
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
22455: LD_ADDR_EXP 92
22459: PUSH
22460: LD_EXP 92
22464: PPUSH
22465: LD_VAR 0 1
22469: PPUSH
22470: LD_INT 4
22472: PPUSH
22473: CALL_OW 1
22477: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
22478: LD_ADDR_VAR 0 12
22482: PUSH
22483: LD_EXP 50
22487: PUSH
22488: LD_VAR 0 1
22492: ARRAY
22493: PPUSH
22494: LD_INT 2
22496: PUSH
22497: LD_INT 30
22499: PUSH
22500: LD_INT 4
22502: PUSH
22503: EMPTY
22504: LIST
22505: LIST
22506: PUSH
22507: LD_INT 30
22509: PUSH
22510: LD_INT 5
22512: PUSH
22513: EMPTY
22514: LIST
22515: LIST
22516: PUSH
22517: EMPTY
22518: LIST
22519: LIST
22520: LIST
22521: PPUSH
22522: CALL_OW 72
22526: ST_TO_ADDR
// if not b then
22527: LD_VAR 0 12
22531: NOT
22532: IFFALSE 22536
// exit ;
22534: GO 25602
// p := [ ] ;
22536: LD_ADDR_VAR 0 11
22540: PUSH
22541: EMPTY
22542: ST_TO_ADDR
// if sci >= 2 then
22543: LD_VAR 0 8
22547: PUSH
22548: LD_INT 2
22550: GREATEREQUAL
22551: IFFALSE 22582
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
22553: LD_ADDR_VAR 0 8
22557: PUSH
22558: LD_VAR 0 8
22562: PUSH
22563: LD_INT 1
22565: ARRAY
22566: PUSH
22567: LD_VAR 0 8
22571: PUSH
22572: LD_INT 2
22574: ARRAY
22575: PUSH
22576: EMPTY
22577: LIST
22578: LIST
22579: ST_TO_ADDR
22580: GO 22643
// if sci = 1 then
22582: LD_VAR 0 8
22586: PUSH
22587: LD_INT 1
22589: EQUAL
22590: IFFALSE 22611
// sci := [ sci [ 1 ] ] else
22592: LD_ADDR_VAR 0 8
22596: PUSH
22597: LD_VAR 0 8
22601: PUSH
22602: LD_INT 1
22604: ARRAY
22605: PUSH
22606: EMPTY
22607: LIST
22608: ST_TO_ADDR
22609: GO 22643
// if sci = 0 then
22611: LD_VAR 0 8
22615: PUSH
22616: LD_INT 0
22618: EQUAL
22619: IFFALSE 22643
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
22621: LD_ADDR_VAR 0 11
22625: PUSH
22626: LD_VAR 0 4
22630: PPUSH
22631: LD_INT 4
22633: PPUSH
22634: CALL 81880 0 2
22638: PUSH
22639: LD_INT 1
22641: ARRAY
22642: ST_TO_ADDR
// if eng > 4 then
22643: LD_VAR 0 6
22647: PUSH
22648: LD_INT 4
22650: GREATER
22651: IFFALSE 22697
// for i = eng downto 4 do
22653: LD_ADDR_VAR 0 3
22657: PUSH
22658: DOUBLE
22659: LD_VAR 0 6
22663: INC
22664: ST_TO_ADDR
22665: LD_INT 4
22667: PUSH
22668: FOR_DOWNTO
22669: IFFALSE 22695
// eng := eng diff eng [ i ] ;
22671: LD_ADDR_VAR 0 6
22675: PUSH
22676: LD_VAR 0 6
22680: PUSH
22681: LD_VAR 0 6
22685: PUSH
22686: LD_VAR 0 3
22690: ARRAY
22691: DIFF
22692: ST_TO_ADDR
22693: GO 22668
22695: POP
22696: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
22697: LD_ADDR_VAR 0 4
22701: PUSH
22702: LD_VAR 0 4
22706: PUSH
22707: LD_VAR 0 5
22711: PUSH
22712: LD_VAR 0 6
22716: UNION
22717: PUSH
22718: LD_VAR 0 7
22722: UNION
22723: PUSH
22724: LD_VAR 0 8
22728: UNION
22729: DIFF
22730: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
22731: LD_ADDR_VAR 0 13
22735: PUSH
22736: LD_EXP 50
22740: PUSH
22741: LD_VAR 0 1
22745: ARRAY
22746: PPUSH
22747: LD_INT 2
22749: PUSH
22750: LD_INT 30
22752: PUSH
22753: LD_INT 32
22755: PUSH
22756: EMPTY
22757: LIST
22758: LIST
22759: PUSH
22760: LD_INT 30
22762: PUSH
22763: LD_INT 31
22765: PUSH
22766: EMPTY
22767: LIST
22768: LIST
22769: PUSH
22770: EMPTY
22771: LIST
22772: LIST
22773: LIST
22774: PPUSH
22775: CALL_OW 72
22779: PUSH
22780: LD_EXP 50
22784: PUSH
22785: LD_VAR 0 1
22789: ARRAY
22790: PPUSH
22791: LD_INT 2
22793: PUSH
22794: LD_INT 30
22796: PUSH
22797: LD_INT 4
22799: PUSH
22800: EMPTY
22801: LIST
22802: LIST
22803: PUSH
22804: LD_INT 30
22806: PUSH
22807: LD_INT 5
22809: PUSH
22810: EMPTY
22811: LIST
22812: LIST
22813: PUSH
22814: EMPTY
22815: LIST
22816: LIST
22817: LIST
22818: PPUSH
22819: CALL_OW 72
22823: PUSH
22824: LD_INT 6
22826: MUL
22827: PLUS
22828: ST_TO_ADDR
// if bcount < tmp then
22829: LD_VAR 0 13
22833: PUSH
22834: LD_VAR 0 4
22838: LESS
22839: IFFALSE 22885
// for i = tmp downto bcount do
22841: LD_ADDR_VAR 0 3
22845: PUSH
22846: DOUBLE
22847: LD_VAR 0 4
22851: INC
22852: ST_TO_ADDR
22853: LD_VAR 0 13
22857: PUSH
22858: FOR_DOWNTO
22859: IFFALSE 22883
// tmp := Delete ( tmp , tmp ) ;
22861: LD_ADDR_VAR 0 4
22865: PUSH
22866: LD_VAR 0 4
22870: PPUSH
22871: LD_VAR 0 4
22875: PPUSH
22876: CALL_OW 3
22880: ST_TO_ADDR
22881: GO 22858
22883: POP
22884: POP
// result := [ tmp , 0 , 0 , p ] ;
22885: LD_ADDR_VAR 0 2
22889: PUSH
22890: LD_VAR 0 4
22894: PUSH
22895: LD_INT 0
22897: PUSH
22898: LD_INT 0
22900: PUSH
22901: LD_VAR 0 11
22905: PUSH
22906: EMPTY
22907: LIST
22908: LIST
22909: LIST
22910: LIST
22911: ST_TO_ADDR
// exit ;
22912: GO 25602
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22914: LD_EXP 50
22918: PUSH
22919: LD_VAR 0 1
22923: ARRAY
22924: PPUSH
22925: LD_INT 2
22927: PUSH
22928: LD_INT 30
22930: PUSH
22931: LD_INT 6
22933: PUSH
22934: EMPTY
22935: LIST
22936: LIST
22937: PUSH
22938: LD_INT 30
22940: PUSH
22941: LD_INT 7
22943: PUSH
22944: EMPTY
22945: LIST
22946: LIST
22947: PUSH
22948: LD_INT 30
22950: PUSH
22951: LD_INT 8
22953: PUSH
22954: EMPTY
22955: LIST
22956: LIST
22957: PUSH
22958: EMPTY
22959: LIST
22960: LIST
22961: LIST
22962: LIST
22963: PPUSH
22964: CALL_OW 72
22968: NOT
22969: PUSH
22970: LD_EXP 50
22974: PUSH
22975: LD_VAR 0 1
22979: ARRAY
22980: PPUSH
22981: LD_INT 30
22983: PUSH
22984: LD_INT 3
22986: PUSH
22987: EMPTY
22988: LIST
22989: LIST
22990: PPUSH
22991: CALL_OW 72
22995: NOT
22996: AND
22997: IFFALSE 23069
// begin if eng = tmp then
22999: LD_VAR 0 6
23003: PUSH
23004: LD_VAR 0 4
23008: EQUAL
23009: IFFALSE 23013
// exit ;
23011: GO 25602
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23013: LD_ADDR_EXP 92
23017: PUSH
23018: LD_EXP 92
23022: PPUSH
23023: LD_VAR 0 1
23027: PPUSH
23028: LD_INT 1
23030: PPUSH
23031: CALL_OW 1
23035: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23036: LD_ADDR_VAR 0 2
23040: PUSH
23041: LD_INT 0
23043: PUSH
23044: LD_VAR 0 4
23048: PUSH
23049: LD_VAR 0 6
23053: DIFF
23054: PUSH
23055: LD_INT 0
23057: PUSH
23058: LD_INT 0
23060: PUSH
23061: EMPTY
23062: LIST
23063: LIST
23064: LIST
23065: LIST
23066: ST_TO_ADDR
// exit ;
23067: GO 25602
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23069: LD_EXP 77
23073: PUSH
23074: LD_EXP 76
23078: PUSH
23079: LD_VAR 0 1
23083: ARRAY
23084: ARRAY
23085: PUSH
23086: LD_EXP 50
23090: PUSH
23091: LD_VAR 0 1
23095: ARRAY
23096: PPUSH
23097: LD_INT 2
23099: PUSH
23100: LD_INT 30
23102: PUSH
23103: LD_INT 6
23105: PUSH
23106: EMPTY
23107: LIST
23108: LIST
23109: PUSH
23110: LD_INT 30
23112: PUSH
23113: LD_INT 7
23115: PUSH
23116: EMPTY
23117: LIST
23118: LIST
23119: PUSH
23120: LD_INT 30
23122: PUSH
23123: LD_INT 8
23125: PUSH
23126: EMPTY
23127: LIST
23128: LIST
23129: PUSH
23130: EMPTY
23131: LIST
23132: LIST
23133: LIST
23134: LIST
23135: PPUSH
23136: CALL_OW 72
23140: AND
23141: PUSH
23142: LD_EXP 50
23146: PUSH
23147: LD_VAR 0 1
23151: ARRAY
23152: PPUSH
23153: LD_INT 30
23155: PUSH
23156: LD_INT 3
23158: PUSH
23159: EMPTY
23160: LIST
23161: LIST
23162: PPUSH
23163: CALL_OW 72
23167: NOT
23168: AND
23169: IFFALSE 23383
// begin if sci >= 6 then
23171: LD_VAR 0 8
23175: PUSH
23176: LD_INT 6
23178: GREATEREQUAL
23179: IFFALSE 23183
// exit ;
23181: GO 25602
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23183: LD_ADDR_EXP 92
23187: PUSH
23188: LD_EXP 92
23192: PPUSH
23193: LD_VAR 0 1
23197: PPUSH
23198: LD_INT 2
23200: PPUSH
23201: CALL_OW 1
23205: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23206: LD_ADDR_VAR 0 9
23210: PUSH
23211: LD_VAR 0 4
23215: PUSH
23216: LD_VAR 0 8
23220: DIFF
23221: PPUSH
23222: LD_INT 4
23224: PPUSH
23225: CALL 81880 0 2
23229: ST_TO_ADDR
// p := [ ] ;
23230: LD_ADDR_VAR 0 11
23234: PUSH
23235: EMPTY
23236: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23237: LD_VAR 0 8
23241: PUSH
23242: LD_INT 6
23244: LESS
23245: PUSH
23246: LD_VAR 0 9
23250: PUSH
23251: LD_INT 6
23253: GREATER
23254: AND
23255: IFFALSE 23336
// begin for i = 1 to 6 - sci do
23257: LD_ADDR_VAR 0 3
23261: PUSH
23262: DOUBLE
23263: LD_INT 1
23265: DEC
23266: ST_TO_ADDR
23267: LD_INT 6
23269: PUSH
23270: LD_VAR 0 8
23274: MINUS
23275: PUSH
23276: FOR_TO
23277: IFFALSE 23332
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23279: LD_ADDR_VAR 0 11
23283: PUSH
23284: LD_VAR 0 11
23288: PPUSH
23289: LD_VAR 0 11
23293: PUSH
23294: LD_INT 1
23296: PLUS
23297: PPUSH
23298: LD_VAR 0 9
23302: PUSH
23303: LD_INT 1
23305: ARRAY
23306: PPUSH
23307: CALL_OW 2
23311: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23312: LD_ADDR_VAR 0 9
23316: PUSH
23317: LD_VAR 0 9
23321: PPUSH
23322: LD_INT 1
23324: PPUSH
23325: CALL_OW 3
23329: ST_TO_ADDR
// end ;
23330: GO 23276
23332: POP
23333: POP
// end else
23334: GO 23356
// if sort then
23336: LD_VAR 0 9
23340: IFFALSE 23356
// p := sort [ 1 ] ;
23342: LD_ADDR_VAR 0 11
23346: PUSH
23347: LD_VAR 0 9
23351: PUSH
23352: LD_INT 1
23354: ARRAY
23355: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23356: LD_ADDR_VAR 0 2
23360: PUSH
23361: LD_INT 0
23363: PUSH
23364: LD_INT 0
23366: PUSH
23367: LD_INT 0
23369: PUSH
23370: LD_VAR 0 11
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: LIST
23379: LIST
23380: ST_TO_ADDR
// exit ;
23381: GO 25602
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23383: LD_EXP 77
23387: PUSH
23388: LD_EXP 76
23392: PUSH
23393: LD_VAR 0 1
23397: ARRAY
23398: ARRAY
23399: PUSH
23400: LD_EXP 50
23404: PUSH
23405: LD_VAR 0 1
23409: ARRAY
23410: PPUSH
23411: LD_INT 2
23413: PUSH
23414: LD_INT 30
23416: PUSH
23417: LD_INT 6
23419: PUSH
23420: EMPTY
23421: LIST
23422: LIST
23423: PUSH
23424: LD_INT 30
23426: PUSH
23427: LD_INT 7
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: PUSH
23434: LD_INT 30
23436: PUSH
23437: LD_INT 8
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: PUSH
23444: EMPTY
23445: LIST
23446: LIST
23447: LIST
23448: LIST
23449: PPUSH
23450: CALL_OW 72
23454: AND
23455: PUSH
23456: LD_EXP 50
23460: PUSH
23461: LD_VAR 0 1
23465: ARRAY
23466: PPUSH
23467: LD_INT 30
23469: PUSH
23470: LD_INT 3
23472: PUSH
23473: EMPTY
23474: LIST
23475: LIST
23476: PPUSH
23477: CALL_OW 72
23481: AND
23482: IFFALSE 24216
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
23484: LD_ADDR_EXP 92
23488: PUSH
23489: LD_EXP 92
23493: PPUSH
23494: LD_VAR 0 1
23498: PPUSH
23499: LD_INT 3
23501: PPUSH
23502: CALL_OW 1
23506: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23507: LD_ADDR_VAR 0 2
23511: PUSH
23512: LD_INT 0
23514: PUSH
23515: LD_INT 0
23517: PUSH
23518: LD_INT 0
23520: PUSH
23521: LD_INT 0
23523: PUSH
23524: EMPTY
23525: LIST
23526: LIST
23527: LIST
23528: LIST
23529: ST_TO_ADDR
// if not eng then
23530: LD_VAR 0 6
23534: NOT
23535: IFFALSE 23598
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
23537: LD_ADDR_VAR 0 11
23541: PUSH
23542: LD_VAR 0 4
23546: PPUSH
23547: LD_INT 2
23549: PPUSH
23550: CALL 81880 0 2
23554: PUSH
23555: LD_INT 1
23557: ARRAY
23558: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
23559: LD_ADDR_VAR 0 2
23563: PUSH
23564: LD_VAR 0 2
23568: PPUSH
23569: LD_INT 2
23571: PPUSH
23572: LD_VAR 0 11
23576: PPUSH
23577: CALL_OW 1
23581: ST_TO_ADDR
// tmp := tmp diff p ;
23582: LD_ADDR_VAR 0 4
23586: PUSH
23587: LD_VAR 0 4
23591: PUSH
23592: LD_VAR 0 11
23596: DIFF
23597: ST_TO_ADDR
// end ; if tmp and sci < 6 then
23598: LD_VAR 0 4
23602: PUSH
23603: LD_VAR 0 8
23607: PUSH
23608: LD_INT 6
23610: LESS
23611: AND
23612: IFFALSE 23800
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
23614: LD_ADDR_VAR 0 9
23618: PUSH
23619: LD_VAR 0 4
23623: PUSH
23624: LD_VAR 0 8
23628: PUSH
23629: LD_VAR 0 7
23633: UNION
23634: DIFF
23635: PPUSH
23636: LD_INT 4
23638: PPUSH
23639: CALL 81880 0 2
23643: ST_TO_ADDR
// p := [ ] ;
23644: LD_ADDR_VAR 0 11
23648: PUSH
23649: EMPTY
23650: ST_TO_ADDR
// if sort then
23651: LD_VAR 0 9
23655: IFFALSE 23771
// for i = 1 to 6 - sci do
23657: LD_ADDR_VAR 0 3
23661: PUSH
23662: DOUBLE
23663: LD_INT 1
23665: DEC
23666: ST_TO_ADDR
23667: LD_INT 6
23669: PUSH
23670: LD_VAR 0 8
23674: MINUS
23675: PUSH
23676: FOR_TO
23677: IFFALSE 23769
// begin if i = sort then
23679: LD_VAR 0 3
23683: PUSH
23684: LD_VAR 0 9
23688: EQUAL
23689: IFFALSE 23693
// break ;
23691: GO 23769
// if GetClass ( i ) = 4 then
23693: LD_VAR 0 3
23697: PPUSH
23698: CALL_OW 257
23702: PUSH
23703: LD_INT 4
23705: EQUAL
23706: IFFALSE 23710
// continue ;
23708: GO 23676
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23710: LD_ADDR_VAR 0 11
23714: PUSH
23715: LD_VAR 0 11
23719: PPUSH
23720: LD_VAR 0 11
23724: PUSH
23725: LD_INT 1
23727: PLUS
23728: PPUSH
23729: LD_VAR 0 9
23733: PUSH
23734: LD_VAR 0 3
23738: ARRAY
23739: PPUSH
23740: CALL_OW 2
23744: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23745: LD_ADDR_VAR 0 4
23749: PUSH
23750: LD_VAR 0 4
23754: PUSH
23755: LD_VAR 0 9
23759: PUSH
23760: LD_VAR 0 3
23764: ARRAY
23765: DIFF
23766: ST_TO_ADDR
// end ;
23767: GO 23676
23769: POP
23770: POP
// if p then
23771: LD_VAR 0 11
23775: IFFALSE 23800
// result := Replace ( result , 4 , p ) ;
23777: LD_ADDR_VAR 0 2
23781: PUSH
23782: LD_VAR 0 2
23786: PPUSH
23787: LD_INT 4
23789: PPUSH
23790: LD_VAR 0 11
23794: PPUSH
23795: CALL_OW 1
23799: ST_TO_ADDR
// end ; if tmp and mech < 6 then
23800: LD_VAR 0 4
23804: PUSH
23805: LD_VAR 0 7
23809: PUSH
23810: LD_INT 6
23812: LESS
23813: AND
23814: IFFALSE 24002
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
23816: LD_ADDR_VAR 0 9
23820: PUSH
23821: LD_VAR 0 4
23825: PUSH
23826: LD_VAR 0 8
23830: PUSH
23831: LD_VAR 0 7
23835: UNION
23836: DIFF
23837: PPUSH
23838: LD_INT 3
23840: PPUSH
23841: CALL 81880 0 2
23845: ST_TO_ADDR
// p := [ ] ;
23846: LD_ADDR_VAR 0 11
23850: PUSH
23851: EMPTY
23852: ST_TO_ADDR
// if sort then
23853: LD_VAR 0 9
23857: IFFALSE 23973
// for i = 1 to 6 - mech do
23859: LD_ADDR_VAR 0 3
23863: PUSH
23864: DOUBLE
23865: LD_INT 1
23867: DEC
23868: ST_TO_ADDR
23869: LD_INT 6
23871: PUSH
23872: LD_VAR 0 7
23876: MINUS
23877: PUSH
23878: FOR_TO
23879: IFFALSE 23971
// begin if i = sort then
23881: LD_VAR 0 3
23885: PUSH
23886: LD_VAR 0 9
23890: EQUAL
23891: IFFALSE 23895
// break ;
23893: GO 23971
// if GetClass ( i ) = 3 then
23895: LD_VAR 0 3
23899: PPUSH
23900: CALL_OW 257
23904: PUSH
23905: LD_INT 3
23907: EQUAL
23908: IFFALSE 23912
// continue ;
23910: GO 23878
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23912: LD_ADDR_VAR 0 11
23916: PUSH
23917: LD_VAR 0 11
23921: PPUSH
23922: LD_VAR 0 11
23926: PUSH
23927: LD_INT 1
23929: PLUS
23930: PPUSH
23931: LD_VAR 0 9
23935: PUSH
23936: LD_VAR 0 3
23940: ARRAY
23941: PPUSH
23942: CALL_OW 2
23946: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23947: LD_ADDR_VAR 0 4
23951: PUSH
23952: LD_VAR 0 4
23956: PUSH
23957: LD_VAR 0 9
23961: PUSH
23962: LD_VAR 0 3
23966: ARRAY
23967: DIFF
23968: ST_TO_ADDR
// end ;
23969: GO 23878
23971: POP
23972: POP
// if p then
23973: LD_VAR 0 11
23977: IFFALSE 24002
// result := Replace ( result , 3 , p ) ;
23979: LD_ADDR_VAR 0 2
23983: PUSH
23984: LD_VAR 0 2
23988: PPUSH
23989: LD_INT 3
23991: PPUSH
23992: LD_VAR 0 11
23996: PPUSH
23997: CALL_OW 1
24001: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24002: LD_VAR 0 4
24006: PUSH
24007: LD_INT 6
24009: GREATER
24010: PUSH
24011: LD_VAR 0 6
24015: PUSH
24016: LD_INT 6
24018: LESS
24019: AND
24020: IFFALSE 24214
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24022: LD_ADDR_VAR 0 9
24026: PUSH
24027: LD_VAR 0 4
24031: PUSH
24032: LD_VAR 0 8
24036: PUSH
24037: LD_VAR 0 7
24041: UNION
24042: PUSH
24043: LD_VAR 0 6
24047: UNION
24048: DIFF
24049: PPUSH
24050: LD_INT 2
24052: PPUSH
24053: CALL 81880 0 2
24057: ST_TO_ADDR
// p := [ ] ;
24058: LD_ADDR_VAR 0 11
24062: PUSH
24063: EMPTY
24064: ST_TO_ADDR
// if sort then
24065: LD_VAR 0 9
24069: IFFALSE 24185
// for i = 1 to 6 - eng do
24071: LD_ADDR_VAR 0 3
24075: PUSH
24076: DOUBLE
24077: LD_INT 1
24079: DEC
24080: ST_TO_ADDR
24081: LD_INT 6
24083: PUSH
24084: LD_VAR 0 6
24088: MINUS
24089: PUSH
24090: FOR_TO
24091: IFFALSE 24183
// begin if i = sort then
24093: LD_VAR 0 3
24097: PUSH
24098: LD_VAR 0 9
24102: EQUAL
24103: IFFALSE 24107
// break ;
24105: GO 24183
// if GetClass ( i ) = 2 then
24107: LD_VAR 0 3
24111: PPUSH
24112: CALL_OW 257
24116: PUSH
24117: LD_INT 2
24119: EQUAL
24120: IFFALSE 24124
// continue ;
24122: GO 24090
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24124: LD_ADDR_VAR 0 11
24128: PUSH
24129: LD_VAR 0 11
24133: PPUSH
24134: LD_VAR 0 11
24138: PUSH
24139: LD_INT 1
24141: PLUS
24142: PPUSH
24143: LD_VAR 0 9
24147: PUSH
24148: LD_VAR 0 3
24152: ARRAY
24153: PPUSH
24154: CALL_OW 2
24158: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24159: LD_ADDR_VAR 0 4
24163: PUSH
24164: LD_VAR 0 4
24168: PUSH
24169: LD_VAR 0 9
24173: PUSH
24174: LD_VAR 0 3
24178: ARRAY
24179: DIFF
24180: ST_TO_ADDR
// end ;
24181: GO 24090
24183: POP
24184: POP
// if p then
24185: LD_VAR 0 11
24189: IFFALSE 24214
// result := Replace ( result , 2 , p ) ;
24191: LD_ADDR_VAR 0 2
24195: PUSH
24196: LD_VAR 0 2
24200: PPUSH
24201: LD_INT 2
24203: PPUSH
24204: LD_VAR 0 11
24208: PPUSH
24209: CALL_OW 1
24213: ST_TO_ADDR
// end ; exit ;
24214: GO 25602
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24216: LD_EXP 77
24220: PUSH
24221: LD_EXP 76
24225: PUSH
24226: LD_VAR 0 1
24230: ARRAY
24231: ARRAY
24232: NOT
24233: PUSH
24234: LD_EXP 50
24238: PUSH
24239: LD_VAR 0 1
24243: ARRAY
24244: PPUSH
24245: LD_INT 30
24247: PUSH
24248: LD_INT 3
24250: PUSH
24251: EMPTY
24252: LIST
24253: LIST
24254: PPUSH
24255: CALL_OW 72
24259: AND
24260: PUSH
24261: LD_EXP 55
24265: PUSH
24266: LD_VAR 0 1
24270: ARRAY
24271: AND
24272: IFFALSE 24880
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24274: LD_ADDR_EXP 92
24278: PUSH
24279: LD_EXP 92
24283: PPUSH
24284: LD_VAR 0 1
24288: PPUSH
24289: LD_INT 5
24291: PPUSH
24292: CALL_OW 1
24296: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24297: LD_ADDR_VAR 0 2
24301: PUSH
24302: LD_INT 0
24304: PUSH
24305: LD_INT 0
24307: PUSH
24308: LD_INT 0
24310: PUSH
24311: LD_INT 0
24313: PUSH
24314: EMPTY
24315: LIST
24316: LIST
24317: LIST
24318: LIST
24319: ST_TO_ADDR
// if sci > 1 then
24320: LD_VAR 0 8
24324: PUSH
24325: LD_INT 1
24327: GREATER
24328: IFFALSE 24356
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24330: LD_ADDR_VAR 0 4
24334: PUSH
24335: LD_VAR 0 4
24339: PUSH
24340: LD_VAR 0 8
24344: PUSH
24345: LD_VAR 0 8
24349: PUSH
24350: LD_INT 1
24352: ARRAY
24353: DIFF
24354: DIFF
24355: ST_TO_ADDR
// if tmp and not sci then
24356: LD_VAR 0 4
24360: PUSH
24361: LD_VAR 0 8
24365: NOT
24366: AND
24367: IFFALSE 24436
// begin sort := SortBySkill ( tmp , 4 ) ;
24369: LD_ADDR_VAR 0 9
24373: PUSH
24374: LD_VAR 0 4
24378: PPUSH
24379: LD_INT 4
24381: PPUSH
24382: CALL 81880 0 2
24386: ST_TO_ADDR
// if sort then
24387: LD_VAR 0 9
24391: IFFALSE 24407
// p := sort [ 1 ] ;
24393: LD_ADDR_VAR 0 11
24397: PUSH
24398: LD_VAR 0 9
24402: PUSH
24403: LD_INT 1
24405: ARRAY
24406: ST_TO_ADDR
// if p then
24407: LD_VAR 0 11
24411: IFFALSE 24436
// result := Replace ( result , 4 , p ) ;
24413: LD_ADDR_VAR 0 2
24417: PUSH
24418: LD_VAR 0 2
24422: PPUSH
24423: LD_INT 4
24425: PPUSH
24426: LD_VAR 0 11
24430: PPUSH
24431: CALL_OW 1
24435: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24436: LD_ADDR_VAR 0 4
24440: PUSH
24441: LD_VAR 0 4
24445: PUSH
24446: LD_VAR 0 7
24450: DIFF
24451: ST_TO_ADDR
// if tmp and mech < 6 then
24452: LD_VAR 0 4
24456: PUSH
24457: LD_VAR 0 7
24461: PUSH
24462: LD_INT 6
24464: LESS
24465: AND
24466: IFFALSE 24654
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24468: LD_ADDR_VAR 0 9
24472: PUSH
24473: LD_VAR 0 4
24477: PUSH
24478: LD_VAR 0 8
24482: PUSH
24483: LD_VAR 0 7
24487: UNION
24488: DIFF
24489: PPUSH
24490: LD_INT 3
24492: PPUSH
24493: CALL 81880 0 2
24497: ST_TO_ADDR
// p := [ ] ;
24498: LD_ADDR_VAR 0 11
24502: PUSH
24503: EMPTY
24504: ST_TO_ADDR
// if sort then
24505: LD_VAR 0 9
24509: IFFALSE 24625
// for i = 1 to 6 - mech do
24511: LD_ADDR_VAR 0 3
24515: PUSH
24516: DOUBLE
24517: LD_INT 1
24519: DEC
24520: ST_TO_ADDR
24521: LD_INT 6
24523: PUSH
24524: LD_VAR 0 7
24528: MINUS
24529: PUSH
24530: FOR_TO
24531: IFFALSE 24623
// begin if i = sort then
24533: LD_VAR 0 3
24537: PUSH
24538: LD_VAR 0 9
24542: EQUAL
24543: IFFALSE 24547
// break ;
24545: GO 24623
// if GetClass ( i ) = 3 then
24547: LD_VAR 0 3
24551: PPUSH
24552: CALL_OW 257
24556: PUSH
24557: LD_INT 3
24559: EQUAL
24560: IFFALSE 24564
// continue ;
24562: GO 24530
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24564: LD_ADDR_VAR 0 11
24568: PUSH
24569: LD_VAR 0 11
24573: PPUSH
24574: LD_VAR 0 11
24578: PUSH
24579: LD_INT 1
24581: PLUS
24582: PPUSH
24583: LD_VAR 0 9
24587: PUSH
24588: LD_VAR 0 3
24592: ARRAY
24593: PPUSH
24594: CALL_OW 2
24598: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24599: LD_ADDR_VAR 0 4
24603: PUSH
24604: LD_VAR 0 4
24608: PUSH
24609: LD_VAR 0 9
24613: PUSH
24614: LD_VAR 0 3
24618: ARRAY
24619: DIFF
24620: ST_TO_ADDR
// end ;
24621: GO 24530
24623: POP
24624: POP
// if p then
24625: LD_VAR 0 11
24629: IFFALSE 24654
// result := Replace ( result , 3 , p ) ;
24631: LD_ADDR_VAR 0 2
24635: PUSH
24636: LD_VAR 0 2
24640: PPUSH
24641: LD_INT 3
24643: PPUSH
24644: LD_VAR 0 11
24648: PPUSH
24649: CALL_OW 1
24653: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
24654: LD_ADDR_VAR 0 4
24658: PUSH
24659: LD_VAR 0 4
24663: PUSH
24664: LD_VAR 0 6
24668: DIFF
24669: ST_TO_ADDR
// if tmp and eng < 6 then
24670: LD_VAR 0 4
24674: PUSH
24675: LD_VAR 0 6
24679: PUSH
24680: LD_INT 6
24682: LESS
24683: AND
24684: IFFALSE 24878
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24686: LD_ADDR_VAR 0 9
24690: PUSH
24691: LD_VAR 0 4
24695: PUSH
24696: LD_VAR 0 8
24700: PUSH
24701: LD_VAR 0 7
24705: UNION
24706: PUSH
24707: LD_VAR 0 6
24711: UNION
24712: DIFF
24713: PPUSH
24714: LD_INT 2
24716: PPUSH
24717: CALL 81880 0 2
24721: ST_TO_ADDR
// p := [ ] ;
24722: LD_ADDR_VAR 0 11
24726: PUSH
24727: EMPTY
24728: ST_TO_ADDR
// if sort then
24729: LD_VAR 0 9
24733: IFFALSE 24849
// for i = 1 to 6 - eng do
24735: LD_ADDR_VAR 0 3
24739: PUSH
24740: DOUBLE
24741: LD_INT 1
24743: DEC
24744: ST_TO_ADDR
24745: LD_INT 6
24747: PUSH
24748: LD_VAR 0 6
24752: MINUS
24753: PUSH
24754: FOR_TO
24755: IFFALSE 24847
// begin if i = sort then
24757: LD_VAR 0 3
24761: PUSH
24762: LD_VAR 0 9
24766: EQUAL
24767: IFFALSE 24771
// break ;
24769: GO 24847
// if GetClass ( i ) = 2 then
24771: LD_VAR 0 3
24775: PPUSH
24776: CALL_OW 257
24780: PUSH
24781: LD_INT 2
24783: EQUAL
24784: IFFALSE 24788
// continue ;
24786: GO 24754
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24788: LD_ADDR_VAR 0 11
24792: PUSH
24793: LD_VAR 0 11
24797: PPUSH
24798: LD_VAR 0 11
24802: PUSH
24803: LD_INT 1
24805: PLUS
24806: PPUSH
24807: LD_VAR 0 9
24811: PUSH
24812: LD_VAR 0 3
24816: ARRAY
24817: PPUSH
24818: CALL_OW 2
24822: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24823: LD_ADDR_VAR 0 4
24827: PUSH
24828: LD_VAR 0 4
24832: PUSH
24833: LD_VAR 0 9
24837: PUSH
24838: LD_VAR 0 3
24842: ARRAY
24843: DIFF
24844: ST_TO_ADDR
// end ;
24845: GO 24754
24847: POP
24848: POP
// if p then
24849: LD_VAR 0 11
24853: IFFALSE 24878
// result := Replace ( result , 2 , p ) ;
24855: LD_ADDR_VAR 0 2
24859: PUSH
24860: LD_VAR 0 2
24864: PPUSH
24865: LD_INT 2
24867: PPUSH
24868: LD_VAR 0 11
24872: PPUSH
24873: CALL_OW 1
24877: ST_TO_ADDR
// end ; exit ;
24878: GO 25602
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
24880: LD_EXP 77
24884: PUSH
24885: LD_EXP 76
24889: PUSH
24890: LD_VAR 0 1
24894: ARRAY
24895: ARRAY
24896: NOT
24897: PUSH
24898: LD_EXP 50
24902: PUSH
24903: LD_VAR 0 1
24907: ARRAY
24908: PPUSH
24909: LD_INT 30
24911: PUSH
24912: LD_INT 3
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: PPUSH
24919: CALL_OW 72
24923: AND
24924: PUSH
24925: LD_EXP 55
24929: PUSH
24930: LD_VAR 0 1
24934: ARRAY
24935: NOT
24936: AND
24937: IFFALSE 25602
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
24939: LD_ADDR_EXP 92
24943: PUSH
24944: LD_EXP 92
24948: PPUSH
24949: LD_VAR 0 1
24953: PPUSH
24954: LD_INT 6
24956: PPUSH
24957: CALL_OW 1
24961: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24962: LD_ADDR_VAR 0 2
24966: PUSH
24967: LD_INT 0
24969: PUSH
24970: LD_INT 0
24972: PUSH
24973: LD_INT 0
24975: PUSH
24976: LD_INT 0
24978: PUSH
24979: EMPTY
24980: LIST
24981: LIST
24982: LIST
24983: LIST
24984: ST_TO_ADDR
// if sci >= 1 then
24985: LD_VAR 0 8
24989: PUSH
24990: LD_INT 1
24992: GREATEREQUAL
24993: IFFALSE 25015
// tmp := tmp diff sci [ 1 ] ;
24995: LD_ADDR_VAR 0 4
24999: PUSH
25000: LD_VAR 0 4
25004: PUSH
25005: LD_VAR 0 8
25009: PUSH
25010: LD_INT 1
25012: ARRAY
25013: DIFF
25014: ST_TO_ADDR
// if tmp and not sci then
25015: LD_VAR 0 4
25019: PUSH
25020: LD_VAR 0 8
25024: NOT
25025: AND
25026: IFFALSE 25095
// begin sort := SortBySkill ( tmp , 4 ) ;
25028: LD_ADDR_VAR 0 9
25032: PUSH
25033: LD_VAR 0 4
25037: PPUSH
25038: LD_INT 4
25040: PPUSH
25041: CALL 81880 0 2
25045: ST_TO_ADDR
// if sort then
25046: LD_VAR 0 9
25050: IFFALSE 25066
// p := sort [ 1 ] ;
25052: LD_ADDR_VAR 0 11
25056: PUSH
25057: LD_VAR 0 9
25061: PUSH
25062: LD_INT 1
25064: ARRAY
25065: ST_TO_ADDR
// if p then
25066: LD_VAR 0 11
25070: IFFALSE 25095
// result := Replace ( result , 4 , p ) ;
25072: LD_ADDR_VAR 0 2
25076: PUSH
25077: LD_VAR 0 2
25081: PPUSH
25082: LD_INT 4
25084: PPUSH
25085: LD_VAR 0 11
25089: PPUSH
25090: CALL_OW 1
25094: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25095: LD_ADDR_VAR 0 4
25099: PUSH
25100: LD_VAR 0 4
25104: PUSH
25105: LD_VAR 0 7
25109: DIFF
25110: ST_TO_ADDR
// if tmp and mech < 6 then
25111: LD_VAR 0 4
25115: PUSH
25116: LD_VAR 0 7
25120: PUSH
25121: LD_INT 6
25123: LESS
25124: AND
25125: IFFALSE 25307
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25127: LD_ADDR_VAR 0 9
25131: PUSH
25132: LD_VAR 0 4
25136: PUSH
25137: LD_VAR 0 7
25141: DIFF
25142: PPUSH
25143: LD_INT 3
25145: PPUSH
25146: CALL 81880 0 2
25150: ST_TO_ADDR
// p := [ ] ;
25151: LD_ADDR_VAR 0 11
25155: PUSH
25156: EMPTY
25157: ST_TO_ADDR
// if sort then
25158: LD_VAR 0 9
25162: IFFALSE 25278
// for i = 1 to 6 - mech do
25164: LD_ADDR_VAR 0 3
25168: PUSH
25169: DOUBLE
25170: LD_INT 1
25172: DEC
25173: ST_TO_ADDR
25174: LD_INT 6
25176: PUSH
25177: LD_VAR 0 7
25181: MINUS
25182: PUSH
25183: FOR_TO
25184: IFFALSE 25276
// begin if i = sort then
25186: LD_VAR 0 3
25190: PUSH
25191: LD_VAR 0 9
25195: EQUAL
25196: IFFALSE 25200
// break ;
25198: GO 25276
// if GetClass ( i ) = 3 then
25200: LD_VAR 0 3
25204: PPUSH
25205: CALL_OW 257
25209: PUSH
25210: LD_INT 3
25212: EQUAL
25213: IFFALSE 25217
// continue ;
25215: GO 25183
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25217: LD_ADDR_VAR 0 11
25221: PUSH
25222: LD_VAR 0 11
25226: PPUSH
25227: LD_VAR 0 11
25231: PUSH
25232: LD_INT 1
25234: PLUS
25235: PPUSH
25236: LD_VAR 0 9
25240: PUSH
25241: LD_VAR 0 3
25245: ARRAY
25246: PPUSH
25247: CALL_OW 2
25251: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25252: LD_ADDR_VAR 0 4
25256: PUSH
25257: LD_VAR 0 4
25261: PUSH
25262: LD_VAR 0 9
25266: PUSH
25267: LD_VAR 0 3
25271: ARRAY
25272: DIFF
25273: ST_TO_ADDR
// end ;
25274: GO 25183
25276: POP
25277: POP
// if p then
25278: LD_VAR 0 11
25282: IFFALSE 25307
// result := Replace ( result , 3 , p ) ;
25284: LD_ADDR_VAR 0 2
25288: PUSH
25289: LD_VAR 0 2
25293: PPUSH
25294: LD_INT 3
25296: PPUSH
25297: LD_VAR 0 11
25301: PPUSH
25302: CALL_OW 1
25306: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25307: LD_ADDR_VAR 0 4
25311: PUSH
25312: LD_VAR 0 4
25316: PUSH
25317: LD_VAR 0 6
25321: DIFF
25322: ST_TO_ADDR
// if tmp and eng < 4 then
25323: LD_VAR 0 4
25327: PUSH
25328: LD_VAR 0 6
25332: PUSH
25333: LD_INT 4
25335: LESS
25336: AND
25337: IFFALSE 25527
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25339: LD_ADDR_VAR 0 9
25343: PUSH
25344: LD_VAR 0 4
25348: PUSH
25349: LD_VAR 0 7
25353: PUSH
25354: LD_VAR 0 6
25358: UNION
25359: DIFF
25360: PPUSH
25361: LD_INT 2
25363: PPUSH
25364: CALL 81880 0 2
25368: ST_TO_ADDR
// p := [ ] ;
25369: LD_ADDR_VAR 0 11
25373: PUSH
25374: EMPTY
25375: ST_TO_ADDR
// if sort then
25376: LD_VAR 0 9
25380: IFFALSE 25496
// for i = 1 to 4 - eng do
25382: LD_ADDR_VAR 0 3
25386: PUSH
25387: DOUBLE
25388: LD_INT 1
25390: DEC
25391: ST_TO_ADDR
25392: LD_INT 4
25394: PUSH
25395: LD_VAR 0 6
25399: MINUS
25400: PUSH
25401: FOR_TO
25402: IFFALSE 25494
// begin if i = sort then
25404: LD_VAR 0 3
25408: PUSH
25409: LD_VAR 0 9
25413: EQUAL
25414: IFFALSE 25418
// break ;
25416: GO 25494
// if GetClass ( i ) = 2 then
25418: LD_VAR 0 3
25422: PPUSH
25423: CALL_OW 257
25427: PUSH
25428: LD_INT 2
25430: EQUAL
25431: IFFALSE 25435
// continue ;
25433: GO 25401
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25435: LD_ADDR_VAR 0 11
25439: PUSH
25440: LD_VAR 0 11
25444: PPUSH
25445: LD_VAR 0 11
25449: PUSH
25450: LD_INT 1
25452: PLUS
25453: PPUSH
25454: LD_VAR 0 9
25458: PUSH
25459: LD_VAR 0 3
25463: ARRAY
25464: PPUSH
25465: CALL_OW 2
25469: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25470: LD_ADDR_VAR 0 4
25474: PUSH
25475: LD_VAR 0 4
25479: PUSH
25480: LD_VAR 0 9
25484: PUSH
25485: LD_VAR 0 3
25489: ARRAY
25490: DIFF
25491: ST_TO_ADDR
// end ;
25492: GO 25401
25494: POP
25495: POP
// if p then
25496: LD_VAR 0 11
25500: IFFALSE 25525
// result := Replace ( result , 2 , p ) ;
25502: LD_ADDR_VAR 0 2
25506: PUSH
25507: LD_VAR 0 2
25511: PPUSH
25512: LD_INT 2
25514: PPUSH
25515: LD_VAR 0 11
25519: PPUSH
25520: CALL_OW 1
25524: ST_TO_ADDR
// end else
25525: GO 25571
// for i = eng downto 5 do
25527: LD_ADDR_VAR 0 3
25531: PUSH
25532: DOUBLE
25533: LD_VAR 0 6
25537: INC
25538: ST_TO_ADDR
25539: LD_INT 5
25541: PUSH
25542: FOR_DOWNTO
25543: IFFALSE 25569
// tmp := tmp union eng [ i ] ;
25545: LD_ADDR_VAR 0 4
25549: PUSH
25550: LD_VAR 0 4
25554: PUSH
25555: LD_VAR 0 6
25559: PUSH
25560: LD_VAR 0 3
25564: ARRAY
25565: UNION
25566: ST_TO_ADDR
25567: GO 25542
25569: POP
25570: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
25571: LD_ADDR_VAR 0 2
25575: PUSH
25576: LD_VAR 0 2
25580: PPUSH
25581: LD_INT 1
25583: PPUSH
25584: LD_VAR 0 4
25588: PUSH
25589: LD_VAR 0 5
25593: DIFF
25594: PPUSH
25595: CALL_OW 1
25599: ST_TO_ADDR
// exit ;
25600: GO 25602
// end ; end ;
25602: LD_VAR 0 2
25606: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
25607: LD_INT 0
25609: PPUSH
25610: PPUSH
25611: PPUSH
// if not mc_bases then
25612: LD_EXP 50
25616: NOT
25617: IFFALSE 25621
// exit ;
25619: GO 25727
// for i = 1 to mc_bases do
25621: LD_ADDR_VAR 0 2
25625: PUSH
25626: DOUBLE
25627: LD_INT 1
25629: DEC
25630: ST_TO_ADDR
25631: LD_EXP 50
25635: PUSH
25636: FOR_TO
25637: IFFALSE 25718
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
25639: LD_ADDR_VAR 0 3
25643: PUSH
25644: LD_EXP 50
25648: PUSH
25649: LD_VAR 0 2
25653: ARRAY
25654: PPUSH
25655: LD_INT 21
25657: PUSH
25658: LD_INT 3
25660: PUSH
25661: EMPTY
25662: LIST
25663: LIST
25664: PUSH
25665: LD_INT 3
25667: PUSH
25668: LD_INT 24
25670: PUSH
25671: LD_INT 1000
25673: PUSH
25674: EMPTY
25675: LIST
25676: LIST
25677: PUSH
25678: EMPTY
25679: LIST
25680: LIST
25681: PUSH
25682: EMPTY
25683: LIST
25684: LIST
25685: PPUSH
25686: CALL_OW 72
25690: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
25691: LD_ADDR_EXP 51
25695: PUSH
25696: LD_EXP 51
25700: PPUSH
25701: LD_VAR 0 2
25705: PPUSH
25706: LD_VAR 0 3
25710: PPUSH
25711: CALL_OW 1
25715: ST_TO_ADDR
// end ;
25716: GO 25636
25718: POP
25719: POP
// RaiseSailEvent ( 101 ) ;
25720: LD_INT 101
25722: PPUSH
25723: CALL_OW 427
// end ;
25727: LD_VAR 0 1
25731: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
25732: LD_INT 0
25734: PPUSH
25735: PPUSH
25736: PPUSH
25737: PPUSH
25738: PPUSH
25739: PPUSH
25740: PPUSH
// if not mc_bases then
25741: LD_EXP 50
25745: NOT
25746: IFFALSE 25750
// exit ;
25748: GO 26312
// for i = 1 to mc_bases do
25750: LD_ADDR_VAR 0 2
25754: PUSH
25755: DOUBLE
25756: LD_INT 1
25758: DEC
25759: ST_TO_ADDR
25760: LD_EXP 50
25764: PUSH
25765: FOR_TO
25766: IFFALSE 26303
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
25768: LD_ADDR_VAR 0 5
25772: PUSH
25773: LD_EXP 50
25777: PUSH
25778: LD_VAR 0 2
25782: ARRAY
25783: PUSH
25784: LD_EXP 79
25788: PUSH
25789: LD_VAR 0 2
25793: ARRAY
25794: UNION
25795: PPUSH
25796: LD_INT 21
25798: PUSH
25799: LD_INT 1
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 1
25808: PUSH
25809: LD_INT 3
25811: PUSH
25812: LD_INT 54
25814: PUSH
25815: EMPTY
25816: LIST
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: PUSH
25822: LD_INT 3
25824: PUSH
25825: LD_INT 24
25827: PUSH
25828: LD_INT 800
25830: PUSH
25831: EMPTY
25832: LIST
25833: LIST
25834: PUSH
25835: EMPTY
25836: LIST
25837: LIST
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: LIST
25843: PUSH
25844: EMPTY
25845: LIST
25846: LIST
25847: PPUSH
25848: CALL_OW 72
25852: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
25853: LD_ADDR_VAR 0 6
25857: PUSH
25858: LD_EXP 50
25862: PUSH
25863: LD_VAR 0 2
25867: ARRAY
25868: PPUSH
25869: LD_INT 21
25871: PUSH
25872: LD_INT 1
25874: PUSH
25875: EMPTY
25876: LIST
25877: LIST
25878: PUSH
25879: LD_INT 1
25881: PUSH
25882: LD_INT 3
25884: PUSH
25885: LD_INT 54
25887: PUSH
25888: EMPTY
25889: LIST
25890: PUSH
25891: EMPTY
25892: LIST
25893: LIST
25894: PUSH
25895: LD_INT 3
25897: PUSH
25898: LD_INT 24
25900: PUSH
25901: LD_INT 250
25903: PUSH
25904: EMPTY
25905: LIST
25906: LIST
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: PUSH
25912: EMPTY
25913: LIST
25914: LIST
25915: LIST
25916: PUSH
25917: EMPTY
25918: LIST
25919: LIST
25920: PPUSH
25921: CALL_OW 72
25925: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
25926: LD_ADDR_VAR 0 7
25930: PUSH
25931: LD_VAR 0 5
25935: PUSH
25936: LD_VAR 0 6
25940: DIFF
25941: ST_TO_ADDR
// if not need_heal_1 then
25942: LD_VAR 0 6
25946: NOT
25947: IFFALSE 25980
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
25949: LD_ADDR_EXP 53
25953: PUSH
25954: LD_EXP 53
25958: PPUSH
25959: LD_VAR 0 2
25963: PUSH
25964: LD_INT 1
25966: PUSH
25967: EMPTY
25968: LIST
25969: LIST
25970: PPUSH
25971: EMPTY
25972: PPUSH
25973: CALL 52331 0 3
25977: ST_TO_ADDR
25978: GO 26050
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
25980: LD_ADDR_EXP 53
25984: PUSH
25985: LD_EXP 53
25989: PPUSH
25990: LD_VAR 0 2
25994: PUSH
25995: LD_INT 1
25997: PUSH
25998: EMPTY
25999: LIST
26000: LIST
26001: PPUSH
26002: LD_EXP 53
26006: PUSH
26007: LD_VAR 0 2
26011: ARRAY
26012: PUSH
26013: LD_INT 1
26015: ARRAY
26016: PPUSH
26017: LD_INT 3
26019: PUSH
26020: LD_INT 24
26022: PUSH
26023: LD_INT 1000
26025: PUSH
26026: EMPTY
26027: LIST
26028: LIST
26029: PUSH
26030: EMPTY
26031: LIST
26032: LIST
26033: PPUSH
26034: CALL_OW 72
26038: PUSH
26039: LD_VAR 0 6
26043: UNION
26044: PPUSH
26045: CALL 52331 0 3
26049: ST_TO_ADDR
// if not need_heal_2 then
26050: LD_VAR 0 7
26054: NOT
26055: IFFALSE 26088
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26057: LD_ADDR_EXP 53
26061: PUSH
26062: LD_EXP 53
26066: PPUSH
26067: LD_VAR 0 2
26071: PUSH
26072: LD_INT 2
26074: PUSH
26075: EMPTY
26076: LIST
26077: LIST
26078: PPUSH
26079: EMPTY
26080: PPUSH
26081: CALL 52331 0 3
26085: ST_TO_ADDR
26086: GO 26120
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26088: LD_ADDR_EXP 53
26092: PUSH
26093: LD_EXP 53
26097: PPUSH
26098: LD_VAR 0 2
26102: PUSH
26103: LD_INT 2
26105: PUSH
26106: EMPTY
26107: LIST
26108: LIST
26109: PPUSH
26110: LD_VAR 0 7
26114: PPUSH
26115: CALL 52331 0 3
26119: ST_TO_ADDR
// if need_heal_2 then
26120: LD_VAR 0 7
26124: IFFALSE 26285
// for j in need_heal_2 do
26126: LD_ADDR_VAR 0 3
26130: PUSH
26131: LD_VAR 0 7
26135: PUSH
26136: FOR_IN
26137: IFFALSE 26283
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26139: LD_ADDR_VAR 0 5
26143: PUSH
26144: LD_EXP 50
26148: PUSH
26149: LD_VAR 0 2
26153: ARRAY
26154: PPUSH
26155: LD_INT 2
26157: PUSH
26158: LD_INT 30
26160: PUSH
26161: LD_INT 6
26163: PUSH
26164: EMPTY
26165: LIST
26166: LIST
26167: PUSH
26168: LD_INT 30
26170: PUSH
26171: LD_INT 7
26173: PUSH
26174: EMPTY
26175: LIST
26176: LIST
26177: PUSH
26178: LD_INT 30
26180: PUSH
26181: LD_INT 8
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 30
26190: PUSH
26191: LD_INT 0
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: PUSH
26198: LD_INT 30
26200: PUSH
26201: LD_INT 1
26203: PUSH
26204: EMPTY
26205: LIST
26206: LIST
26207: PUSH
26208: EMPTY
26209: LIST
26210: LIST
26211: LIST
26212: LIST
26213: LIST
26214: LIST
26215: PPUSH
26216: CALL_OW 72
26220: ST_TO_ADDR
// if tmp then
26221: LD_VAR 0 5
26225: IFFALSE 26281
// begin k := NearestUnitToUnit ( tmp , j ) ;
26227: LD_ADDR_VAR 0 4
26231: PUSH
26232: LD_VAR 0 5
26236: PPUSH
26237: LD_VAR 0 3
26241: PPUSH
26242: CALL_OW 74
26246: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26247: LD_VAR 0 3
26251: PPUSH
26252: LD_VAR 0 4
26256: PPUSH
26257: CALL_OW 296
26261: PUSH
26262: LD_INT 5
26264: GREATER
26265: IFFALSE 26281
// ComMoveUnit ( j , k ) ;
26267: LD_VAR 0 3
26271: PPUSH
26272: LD_VAR 0 4
26276: PPUSH
26277: CALL_OW 112
// end ; end ;
26281: GO 26136
26283: POP
26284: POP
// if not need_heal_1 and not need_heal_2 then
26285: LD_VAR 0 6
26289: NOT
26290: PUSH
26291: LD_VAR 0 7
26295: NOT
26296: AND
26297: IFFALSE 26301
// continue ;
26299: GO 25765
// end ;
26301: GO 25765
26303: POP
26304: POP
// RaiseSailEvent ( 102 ) ;
26305: LD_INT 102
26307: PPUSH
26308: CALL_OW 427
// end ;
26312: LD_VAR 0 1
26316: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26317: LD_INT 0
26319: PPUSH
26320: PPUSH
26321: PPUSH
26322: PPUSH
26323: PPUSH
26324: PPUSH
26325: PPUSH
26326: PPUSH
// if not mc_bases then
26327: LD_EXP 50
26331: NOT
26332: IFFALSE 26336
// exit ;
26334: GO 27171
// for i = 1 to mc_bases do
26336: LD_ADDR_VAR 0 2
26340: PUSH
26341: DOUBLE
26342: LD_INT 1
26344: DEC
26345: ST_TO_ADDR
26346: LD_EXP 50
26350: PUSH
26351: FOR_TO
26352: IFFALSE 27169
// begin if not mc_building_need_repair [ i ] then
26354: LD_EXP 51
26358: PUSH
26359: LD_VAR 0 2
26363: ARRAY
26364: NOT
26365: IFFALSE 26539
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
26367: LD_ADDR_VAR 0 6
26371: PUSH
26372: LD_EXP 69
26376: PUSH
26377: LD_VAR 0 2
26381: ARRAY
26382: PPUSH
26383: LD_INT 3
26385: PUSH
26386: LD_INT 24
26388: PUSH
26389: LD_INT 1000
26391: PUSH
26392: EMPTY
26393: LIST
26394: LIST
26395: PUSH
26396: EMPTY
26397: LIST
26398: LIST
26399: PUSH
26400: LD_INT 2
26402: PUSH
26403: LD_INT 34
26405: PUSH
26406: LD_INT 13
26408: PUSH
26409: EMPTY
26410: LIST
26411: LIST
26412: PUSH
26413: LD_INT 34
26415: PUSH
26416: LD_INT 52
26418: PUSH
26419: EMPTY
26420: LIST
26421: LIST
26422: PUSH
26423: EMPTY
26424: LIST
26425: LIST
26426: LIST
26427: PUSH
26428: EMPTY
26429: LIST
26430: LIST
26431: PPUSH
26432: CALL_OW 72
26436: ST_TO_ADDR
// if cranes then
26437: LD_VAR 0 6
26441: IFFALSE 26503
// for j in cranes do
26443: LD_ADDR_VAR 0 3
26447: PUSH
26448: LD_VAR 0 6
26452: PUSH
26453: FOR_IN
26454: IFFALSE 26501
// if not IsInArea ( j , mc_parking [ i ] ) then
26456: LD_VAR 0 3
26460: PPUSH
26461: LD_EXP 74
26465: PUSH
26466: LD_VAR 0 2
26470: ARRAY
26471: PPUSH
26472: CALL_OW 308
26476: NOT
26477: IFFALSE 26499
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26479: LD_VAR 0 3
26483: PPUSH
26484: LD_EXP 74
26488: PUSH
26489: LD_VAR 0 2
26493: ARRAY
26494: PPUSH
26495: CALL_OW 113
26499: GO 26453
26501: POP
26502: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
26503: LD_ADDR_EXP 52
26507: PUSH
26508: LD_EXP 52
26512: PPUSH
26513: LD_VAR 0 2
26517: PPUSH
26518: EMPTY
26519: PPUSH
26520: CALL_OW 1
26524: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
26525: LD_VAR 0 2
26529: PPUSH
26530: LD_INT 101
26532: PPUSH
26533: CALL 21440 0 2
// continue ;
26537: GO 26351
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
26539: LD_ADDR_EXP 56
26543: PUSH
26544: LD_EXP 56
26548: PPUSH
26549: LD_VAR 0 2
26553: PPUSH
26554: EMPTY
26555: PPUSH
26556: CALL_OW 1
26560: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
26561: LD_VAR 0 2
26565: PPUSH
26566: LD_INT 103
26568: PPUSH
26569: CALL 21440 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
26573: LD_ADDR_VAR 0 5
26577: PUSH
26578: LD_EXP 50
26582: PUSH
26583: LD_VAR 0 2
26587: ARRAY
26588: PUSH
26589: LD_EXP 79
26593: PUSH
26594: LD_VAR 0 2
26598: ARRAY
26599: UNION
26600: PPUSH
26601: LD_INT 2
26603: PUSH
26604: LD_INT 25
26606: PUSH
26607: LD_INT 2
26609: PUSH
26610: EMPTY
26611: LIST
26612: LIST
26613: PUSH
26614: LD_INT 25
26616: PUSH
26617: LD_INT 16
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: EMPTY
26625: LIST
26626: LIST
26627: LIST
26628: PUSH
26629: EMPTY
26630: LIST
26631: PPUSH
26632: CALL_OW 72
26636: PUSH
26637: LD_EXP 53
26641: PUSH
26642: LD_VAR 0 2
26646: ARRAY
26647: PUSH
26648: LD_INT 1
26650: ARRAY
26651: PUSH
26652: LD_EXP 53
26656: PUSH
26657: LD_VAR 0 2
26661: ARRAY
26662: PUSH
26663: LD_INT 2
26665: ARRAY
26666: UNION
26667: DIFF
26668: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
26669: LD_ADDR_VAR 0 6
26673: PUSH
26674: LD_EXP 69
26678: PUSH
26679: LD_VAR 0 2
26683: ARRAY
26684: PPUSH
26685: LD_INT 2
26687: PUSH
26688: LD_INT 34
26690: PUSH
26691: LD_INT 13
26693: PUSH
26694: EMPTY
26695: LIST
26696: LIST
26697: PUSH
26698: LD_INT 34
26700: PUSH
26701: LD_INT 52
26703: PUSH
26704: EMPTY
26705: LIST
26706: LIST
26707: PUSH
26708: EMPTY
26709: LIST
26710: LIST
26711: LIST
26712: PPUSH
26713: CALL_OW 72
26717: ST_TO_ADDR
// if cranes then
26718: LD_VAR 0 6
26722: IFFALSE 26858
// begin for j in cranes do
26724: LD_ADDR_VAR 0 3
26728: PUSH
26729: LD_VAR 0 6
26733: PUSH
26734: FOR_IN
26735: IFFALSE 26856
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
26737: LD_VAR 0 3
26741: PPUSH
26742: CALL_OW 256
26746: PUSH
26747: LD_INT 500
26749: GREATEREQUAL
26750: PUSH
26751: LD_VAR 0 3
26755: PPUSH
26756: CALL_OW 314
26760: NOT
26761: AND
26762: IFFALSE 26796
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
26764: LD_VAR 0 3
26768: PPUSH
26769: LD_EXP 51
26773: PUSH
26774: LD_VAR 0 2
26778: ARRAY
26779: PPUSH
26780: LD_VAR 0 3
26784: PPUSH
26785: CALL_OW 74
26789: PPUSH
26790: CALL_OW 130
26794: GO 26854
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
26796: LD_VAR 0 3
26800: PPUSH
26801: CALL_OW 256
26805: PUSH
26806: LD_INT 500
26808: LESS
26809: PUSH
26810: LD_VAR 0 3
26814: PPUSH
26815: LD_EXP 74
26819: PUSH
26820: LD_VAR 0 2
26824: ARRAY
26825: PPUSH
26826: CALL_OW 308
26830: NOT
26831: AND
26832: IFFALSE 26854
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26834: LD_VAR 0 3
26838: PPUSH
26839: LD_EXP 74
26843: PUSH
26844: LD_VAR 0 2
26848: ARRAY
26849: PPUSH
26850: CALL_OW 113
26854: GO 26734
26856: POP
26857: POP
// end ; if tmp > 3 then
26858: LD_VAR 0 5
26862: PUSH
26863: LD_INT 3
26865: GREATER
26866: IFFALSE 26886
// tmp := ShrinkArray ( tmp , 4 ) ;
26868: LD_ADDR_VAR 0 5
26872: PUSH
26873: LD_VAR 0 5
26877: PPUSH
26878: LD_INT 4
26880: PPUSH
26881: CALL 83689 0 2
26885: ST_TO_ADDR
// if not tmp then
26886: LD_VAR 0 5
26890: NOT
26891: IFFALSE 26895
// continue ;
26893: GO 26351
// for j in tmp do
26895: LD_ADDR_VAR 0 3
26899: PUSH
26900: LD_VAR 0 5
26904: PUSH
26905: FOR_IN
26906: IFFALSE 27165
// begin if IsInUnit ( j ) then
26908: LD_VAR 0 3
26912: PPUSH
26913: CALL_OW 310
26917: IFFALSE 26928
// ComExitBuilding ( j ) ;
26919: LD_VAR 0 3
26923: PPUSH
26924: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
26928: LD_VAR 0 3
26932: PUSH
26933: LD_EXP 52
26937: PUSH
26938: LD_VAR 0 2
26942: ARRAY
26943: IN
26944: NOT
26945: IFFALSE 27003
// begin SetTag ( j , 101 ) ;
26947: LD_VAR 0 3
26951: PPUSH
26952: LD_INT 101
26954: PPUSH
26955: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
26959: LD_ADDR_EXP 52
26963: PUSH
26964: LD_EXP 52
26968: PPUSH
26969: LD_VAR 0 2
26973: PUSH
26974: LD_EXP 52
26978: PUSH
26979: LD_VAR 0 2
26983: ARRAY
26984: PUSH
26985: LD_INT 1
26987: PLUS
26988: PUSH
26989: EMPTY
26990: LIST
26991: LIST
26992: PPUSH
26993: LD_VAR 0 3
26997: PPUSH
26998: CALL 52331 0 3
27002: ST_TO_ADDR
// end ; wait ( 1 ) ;
27003: LD_INT 1
27005: PPUSH
27006: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27010: LD_ADDR_VAR 0 7
27014: PUSH
27015: LD_EXP 51
27019: PUSH
27020: LD_VAR 0 2
27024: ARRAY
27025: ST_TO_ADDR
// if mc_scan [ i ] then
27026: LD_EXP 73
27030: PUSH
27031: LD_VAR 0 2
27035: ARRAY
27036: IFFALSE 27098
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27038: LD_ADDR_VAR 0 7
27042: PUSH
27043: LD_EXP 51
27047: PUSH
27048: LD_VAR 0 2
27052: ARRAY
27053: PPUSH
27054: LD_INT 3
27056: PUSH
27057: LD_INT 30
27059: PUSH
27060: LD_INT 32
27062: PUSH
27063: EMPTY
27064: LIST
27065: LIST
27066: PUSH
27067: LD_INT 30
27069: PUSH
27070: LD_INT 33
27072: PUSH
27073: EMPTY
27074: LIST
27075: LIST
27076: PUSH
27077: LD_INT 30
27079: PUSH
27080: LD_INT 31
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PUSH
27087: EMPTY
27088: LIST
27089: LIST
27090: LIST
27091: LIST
27092: PPUSH
27093: CALL_OW 72
27097: ST_TO_ADDR
// if not to_repair_tmp then
27098: LD_VAR 0 7
27102: NOT
27103: IFFALSE 27107
// continue ;
27105: GO 26905
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27107: LD_ADDR_VAR 0 8
27111: PUSH
27112: LD_VAR 0 7
27116: PPUSH
27117: LD_VAR 0 3
27121: PPUSH
27122: CALL_OW 74
27126: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
27127: LD_VAR 0 8
27131: PPUSH
27132: LD_INT 16
27134: PPUSH
27135: CALL 54924 0 2
27139: PUSH
27140: LD_INT 4
27142: ARRAY
27143: PUSH
27144: LD_INT 5
27146: LESS
27147: IFFALSE 27163
// ComRepairBuilding ( j , to_repair ) ;
27149: LD_VAR 0 3
27153: PPUSH
27154: LD_VAR 0 8
27158: PPUSH
27159: CALL_OW 130
// end ;
27163: GO 26905
27165: POP
27166: POP
// end ;
27167: GO 26351
27169: POP
27170: POP
// end ;
27171: LD_VAR 0 1
27175: RET
// export function MC_Heal ; var i , j , tmp ; begin
27176: LD_INT 0
27178: PPUSH
27179: PPUSH
27180: PPUSH
27181: PPUSH
// if not mc_bases then
27182: LD_EXP 50
27186: NOT
27187: IFFALSE 27191
// exit ;
27189: GO 27593
// for i = 1 to mc_bases do
27191: LD_ADDR_VAR 0 2
27195: PUSH
27196: DOUBLE
27197: LD_INT 1
27199: DEC
27200: ST_TO_ADDR
27201: LD_EXP 50
27205: PUSH
27206: FOR_TO
27207: IFFALSE 27591
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27209: LD_EXP 53
27213: PUSH
27214: LD_VAR 0 2
27218: ARRAY
27219: PUSH
27220: LD_INT 1
27222: ARRAY
27223: NOT
27224: PUSH
27225: LD_EXP 53
27229: PUSH
27230: LD_VAR 0 2
27234: ARRAY
27235: PUSH
27236: LD_INT 2
27238: ARRAY
27239: NOT
27240: AND
27241: IFFALSE 27279
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27243: LD_ADDR_EXP 54
27247: PUSH
27248: LD_EXP 54
27252: PPUSH
27253: LD_VAR 0 2
27257: PPUSH
27258: EMPTY
27259: PPUSH
27260: CALL_OW 1
27264: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27265: LD_VAR 0 2
27269: PPUSH
27270: LD_INT 102
27272: PPUSH
27273: CALL 21440 0 2
// continue ;
27277: GO 27206
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27279: LD_ADDR_VAR 0 4
27283: PUSH
27284: LD_EXP 50
27288: PUSH
27289: LD_VAR 0 2
27293: ARRAY
27294: PPUSH
27295: LD_INT 25
27297: PUSH
27298: LD_INT 4
27300: PUSH
27301: EMPTY
27302: LIST
27303: LIST
27304: PPUSH
27305: CALL_OW 72
27309: ST_TO_ADDR
// if not tmp then
27310: LD_VAR 0 4
27314: NOT
27315: IFFALSE 27319
// continue ;
27317: GO 27206
// if mc_taming [ i ] then
27319: LD_EXP 81
27323: PUSH
27324: LD_VAR 0 2
27328: ARRAY
27329: IFFALSE 27353
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27331: LD_ADDR_EXP 81
27335: PUSH
27336: LD_EXP 81
27340: PPUSH
27341: LD_VAR 0 2
27345: PPUSH
27346: EMPTY
27347: PPUSH
27348: CALL_OW 1
27352: ST_TO_ADDR
// for j in tmp do
27353: LD_ADDR_VAR 0 3
27357: PUSH
27358: LD_VAR 0 4
27362: PUSH
27363: FOR_IN
27364: IFFALSE 27587
// begin if IsInUnit ( j ) then
27366: LD_VAR 0 3
27370: PPUSH
27371: CALL_OW 310
27375: IFFALSE 27386
// ComExitBuilding ( j ) ;
27377: LD_VAR 0 3
27381: PPUSH
27382: CALL_OW 122
// if not j in mc_healers [ i ] then
27386: LD_VAR 0 3
27390: PUSH
27391: LD_EXP 54
27395: PUSH
27396: LD_VAR 0 2
27400: ARRAY
27401: IN
27402: NOT
27403: IFFALSE 27449
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27405: LD_ADDR_EXP 54
27409: PUSH
27410: LD_EXP 54
27414: PPUSH
27415: LD_VAR 0 2
27419: PUSH
27420: LD_EXP 54
27424: PUSH
27425: LD_VAR 0 2
27429: ARRAY
27430: PUSH
27431: LD_INT 1
27433: PLUS
27434: PUSH
27435: EMPTY
27436: LIST
27437: LIST
27438: PPUSH
27439: LD_VAR 0 3
27443: PPUSH
27444: CALL 52331 0 3
27448: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
27449: LD_VAR 0 3
27453: PPUSH
27454: CALL_OW 110
27458: PUSH
27459: LD_INT 102
27461: NONEQUAL
27462: IFFALSE 27476
// SetTag ( j , 102 ) ;
27464: LD_VAR 0 3
27468: PPUSH
27469: LD_INT 102
27471: PPUSH
27472: CALL_OW 109
// Wait ( 3 ) ;
27476: LD_INT 3
27478: PPUSH
27479: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
27483: LD_EXP 53
27487: PUSH
27488: LD_VAR 0 2
27492: ARRAY
27493: PUSH
27494: LD_INT 1
27496: ARRAY
27497: IFFALSE 27529
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
27499: LD_VAR 0 3
27503: PPUSH
27504: LD_EXP 53
27508: PUSH
27509: LD_VAR 0 2
27513: ARRAY
27514: PUSH
27515: LD_INT 1
27517: ARRAY
27518: PUSH
27519: LD_INT 1
27521: ARRAY
27522: PPUSH
27523: CALL_OW 128
27527: GO 27585
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
27529: LD_VAR 0 3
27533: PPUSH
27534: CALL_OW 314
27538: NOT
27539: PUSH
27540: LD_EXP 53
27544: PUSH
27545: LD_VAR 0 2
27549: ARRAY
27550: PUSH
27551: LD_INT 2
27553: ARRAY
27554: AND
27555: IFFALSE 27585
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
27557: LD_VAR 0 3
27561: PPUSH
27562: LD_EXP 53
27566: PUSH
27567: LD_VAR 0 2
27571: ARRAY
27572: PUSH
27573: LD_INT 2
27575: ARRAY
27576: PUSH
27577: LD_INT 1
27579: ARRAY
27580: PPUSH
27581: CALL_OW 128
// end ;
27585: GO 27363
27587: POP
27588: POP
// end ;
27589: GO 27206
27591: POP
27592: POP
// end ;
27593: LD_VAR 0 1
27597: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
27598: LD_INT 0
27600: PPUSH
27601: PPUSH
27602: PPUSH
27603: PPUSH
27604: PPUSH
// if not mc_bases then
27605: LD_EXP 50
27609: NOT
27610: IFFALSE 27614
// exit ;
27612: GO 28757
// for i = 1 to mc_bases do
27614: LD_ADDR_VAR 0 2
27618: PUSH
27619: DOUBLE
27620: LD_INT 1
27622: DEC
27623: ST_TO_ADDR
27624: LD_EXP 50
27628: PUSH
27629: FOR_TO
27630: IFFALSE 28755
// begin if mc_scan [ i ] then
27632: LD_EXP 73
27636: PUSH
27637: LD_VAR 0 2
27641: ARRAY
27642: IFFALSE 27646
// continue ;
27644: GO 27629
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
27646: LD_EXP 55
27650: PUSH
27651: LD_VAR 0 2
27655: ARRAY
27656: NOT
27657: PUSH
27658: LD_EXP 57
27662: PUSH
27663: LD_VAR 0 2
27667: ARRAY
27668: NOT
27669: AND
27670: PUSH
27671: LD_EXP 56
27675: PUSH
27676: LD_VAR 0 2
27680: ARRAY
27681: AND
27682: IFFALSE 27720
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
27684: LD_ADDR_EXP 56
27688: PUSH
27689: LD_EXP 56
27693: PPUSH
27694: LD_VAR 0 2
27698: PPUSH
27699: EMPTY
27700: PPUSH
27701: CALL_OW 1
27705: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27706: LD_VAR 0 2
27710: PPUSH
27711: LD_INT 103
27713: PPUSH
27714: CALL 21440 0 2
// continue ;
27718: GO 27629
// end ; if mc_construct_list [ i ] then
27720: LD_EXP 57
27724: PUSH
27725: LD_VAR 0 2
27729: ARRAY
27730: IFFALSE 27950
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27732: LD_ADDR_VAR 0 4
27736: PUSH
27737: LD_EXP 50
27741: PUSH
27742: LD_VAR 0 2
27746: ARRAY
27747: PPUSH
27748: LD_INT 25
27750: PUSH
27751: LD_INT 2
27753: PUSH
27754: EMPTY
27755: LIST
27756: LIST
27757: PPUSH
27758: CALL_OW 72
27762: PUSH
27763: LD_EXP 52
27767: PUSH
27768: LD_VAR 0 2
27772: ARRAY
27773: DIFF
27774: ST_TO_ADDR
// if not tmp then
27775: LD_VAR 0 4
27779: NOT
27780: IFFALSE 27784
// continue ;
27782: GO 27629
// for j in tmp do
27784: LD_ADDR_VAR 0 3
27788: PUSH
27789: LD_VAR 0 4
27793: PUSH
27794: FOR_IN
27795: IFFALSE 27946
// begin if not mc_builders [ i ] then
27797: LD_EXP 56
27801: PUSH
27802: LD_VAR 0 2
27806: ARRAY
27807: NOT
27808: IFFALSE 27866
// begin SetTag ( j , 103 ) ;
27810: LD_VAR 0 3
27814: PPUSH
27815: LD_INT 103
27817: PPUSH
27818: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
27822: LD_ADDR_EXP 56
27826: PUSH
27827: LD_EXP 56
27831: PPUSH
27832: LD_VAR 0 2
27836: PUSH
27837: LD_EXP 56
27841: PUSH
27842: LD_VAR 0 2
27846: ARRAY
27847: PUSH
27848: LD_INT 1
27850: PLUS
27851: PUSH
27852: EMPTY
27853: LIST
27854: LIST
27855: PPUSH
27856: LD_VAR 0 3
27860: PPUSH
27861: CALL 52331 0 3
27865: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
27866: LD_VAR 0 3
27870: PPUSH
27871: CALL_OW 310
27875: IFFALSE 27886
// ComExitBuilding ( j ) ;
27877: LD_VAR 0 3
27881: PPUSH
27882: CALL_OW 122
// wait ( 3 ) ;
27886: LD_INT 3
27888: PPUSH
27889: CALL_OW 67
// if not mc_construct_list [ i ] then
27893: LD_EXP 57
27897: PUSH
27898: LD_VAR 0 2
27902: ARRAY
27903: NOT
27904: IFFALSE 27908
// break ;
27906: GO 27946
// if not HasTask ( j ) then
27908: LD_VAR 0 3
27912: PPUSH
27913: CALL_OW 314
27917: NOT
27918: IFFALSE 27944
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
27920: LD_VAR 0 3
27924: PPUSH
27925: LD_EXP 57
27929: PUSH
27930: LD_VAR 0 2
27934: ARRAY
27935: PUSH
27936: LD_INT 1
27938: ARRAY
27939: PPUSH
27940: CALL 55182 0 2
// end ;
27944: GO 27794
27946: POP
27947: POP
// end else
27948: GO 28753
// if mc_build_list [ i ] then
27950: LD_EXP 55
27954: PUSH
27955: LD_VAR 0 2
27959: ARRAY
27960: IFFALSE 28753
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27962: LD_ADDR_VAR 0 5
27966: PUSH
27967: LD_EXP 50
27971: PUSH
27972: LD_VAR 0 2
27976: ARRAY
27977: PPUSH
27978: LD_INT 2
27980: PUSH
27981: LD_INT 30
27983: PUSH
27984: LD_INT 0
27986: PUSH
27987: EMPTY
27988: LIST
27989: LIST
27990: PUSH
27991: LD_INT 30
27993: PUSH
27994: LD_INT 1
27996: PUSH
27997: EMPTY
27998: LIST
27999: LIST
28000: PUSH
28001: EMPTY
28002: LIST
28003: LIST
28004: LIST
28005: PPUSH
28006: CALL_OW 72
28010: ST_TO_ADDR
// if depot then
28011: LD_VAR 0 5
28015: IFFALSE 28033
// depot := depot [ 1 ] else
28017: LD_ADDR_VAR 0 5
28021: PUSH
28022: LD_VAR 0 5
28026: PUSH
28027: LD_INT 1
28029: ARRAY
28030: ST_TO_ADDR
28031: GO 28041
// depot := 0 ;
28033: LD_ADDR_VAR 0 5
28037: PUSH
28038: LD_INT 0
28040: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28041: LD_EXP 55
28045: PUSH
28046: LD_VAR 0 2
28050: ARRAY
28051: PUSH
28052: LD_INT 1
28054: ARRAY
28055: PUSH
28056: LD_INT 1
28058: ARRAY
28059: PPUSH
28060: CALL 55012 0 1
28064: PUSH
28065: LD_EXP 50
28069: PUSH
28070: LD_VAR 0 2
28074: ARRAY
28075: PPUSH
28076: LD_INT 2
28078: PUSH
28079: LD_INT 30
28081: PUSH
28082: LD_INT 2
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: LD_INT 30
28091: PUSH
28092: LD_INT 3
28094: PUSH
28095: EMPTY
28096: LIST
28097: LIST
28098: PUSH
28099: EMPTY
28100: LIST
28101: LIST
28102: LIST
28103: PPUSH
28104: CALL_OW 72
28108: NOT
28109: AND
28110: IFFALSE 28215
// begin for j = 1 to mc_build_list [ i ] do
28112: LD_ADDR_VAR 0 3
28116: PUSH
28117: DOUBLE
28118: LD_INT 1
28120: DEC
28121: ST_TO_ADDR
28122: LD_EXP 55
28126: PUSH
28127: LD_VAR 0 2
28131: ARRAY
28132: PUSH
28133: FOR_TO
28134: IFFALSE 28213
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28136: LD_EXP 55
28140: PUSH
28141: LD_VAR 0 2
28145: ARRAY
28146: PUSH
28147: LD_VAR 0 3
28151: ARRAY
28152: PUSH
28153: LD_INT 1
28155: ARRAY
28156: PUSH
28157: LD_INT 2
28159: EQUAL
28160: IFFALSE 28211
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28162: LD_ADDR_EXP 55
28166: PUSH
28167: LD_EXP 55
28171: PPUSH
28172: LD_VAR 0 2
28176: PPUSH
28177: LD_EXP 55
28181: PUSH
28182: LD_VAR 0 2
28186: ARRAY
28187: PPUSH
28188: LD_VAR 0 3
28192: PPUSH
28193: LD_INT 1
28195: PPUSH
28196: LD_INT 0
28198: PPUSH
28199: CALL 51749 0 4
28203: PPUSH
28204: CALL_OW 1
28208: ST_TO_ADDR
// break ;
28209: GO 28213
// end ;
28211: GO 28133
28213: POP
28214: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28215: LD_EXP 55
28219: PUSH
28220: LD_VAR 0 2
28224: ARRAY
28225: PUSH
28226: LD_INT 1
28228: ARRAY
28229: PUSH
28230: LD_INT 1
28232: ARRAY
28233: PUSH
28234: LD_INT 0
28236: EQUAL
28237: PUSH
28238: LD_VAR 0 5
28242: PUSH
28243: LD_VAR 0 5
28247: PPUSH
28248: LD_EXP 55
28252: PUSH
28253: LD_VAR 0 2
28257: ARRAY
28258: PUSH
28259: LD_INT 1
28261: ARRAY
28262: PUSH
28263: LD_INT 1
28265: ARRAY
28266: PPUSH
28267: LD_EXP 55
28271: PUSH
28272: LD_VAR 0 2
28276: ARRAY
28277: PUSH
28278: LD_INT 1
28280: ARRAY
28281: PUSH
28282: LD_INT 2
28284: ARRAY
28285: PPUSH
28286: LD_EXP 55
28290: PUSH
28291: LD_VAR 0 2
28295: ARRAY
28296: PUSH
28297: LD_INT 1
28299: ARRAY
28300: PUSH
28301: LD_INT 3
28303: ARRAY
28304: PPUSH
28305: LD_EXP 55
28309: PUSH
28310: LD_VAR 0 2
28314: ARRAY
28315: PUSH
28316: LD_INT 1
28318: ARRAY
28319: PUSH
28320: LD_INT 4
28322: ARRAY
28323: PPUSH
28324: CALL 59746 0 5
28328: AND
28329: OR
28330: IFFALSE 28611
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28332: LD_ADDR_VAR 0 4
28336: PUSH
28337: LD_EXP 50
28341: PUSH
28342: LD_VAR 0 2
28346: ARRAY
28347: PPUSH
28348: LD_INT 25
28350: PUSH
28351: LD_INT 2
28353: PUSH
28354: EMPTY
28355: LIST
28356: LIST
28357: PPUSH
28358: CALL_OW 72
28362: PUSH
28363: LD_EXP 52
28367: PUSH
28368: LD_VAR 0 2
28372: ARRAY
28373: DIFF
28374: ST_TO_ADDR
// if not tmp then
28375: LD_VAR 0 4
28379: NOT
28380: IFFALSE 28384
// continue ;
28382: GO 27629
// for j in tmp do
28384: LD_ADDR_VAR 0 3
28388: PUSH
28389: LD_VAR 0 4
28393: PUSH
28394: FOR_IN
28395: IFFALSE 28607
// begin if not mc_builders [ i ] then
28397: LD_EXP 56
28401: PUSH
28402: LD_VAR 0 2
28406: ARRAY
28407: NOT
28408: IFFALSE 28466
// begin SetTag ( j , 103 ) ;
28410: LD_VAR 0 3
28414: PPUSH
28415: LD_INT 103
28417: PPUSH
28418: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28422: LD_ADDR_EXP 56
28426: PUSH
28427: LD_EXP 56
28431: PPUSH
28432: LD_VAR 0 2
28436: PUSH
28437: LD_EXP 56
28441: PUSH
28442: LD_VAR 0 2
28446: ARRAY
28447: PUSH
28448: LD_INT 1
28450: PLUS
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PPUSH
28456: LD_VAR 0 3
28460: PPUSH
28461: CALL 52331 0 3
28465: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28466: LD_VAR 0 3
28470: PPUSH
28471: CALL_OW 310
28475: IFFALSE 28486
// ComExitBuilding ( j ) ;
28477: LD_VAR 0 3
28481: PPUSH
28482: CALL_OW 122
// wait ( 3 ) ;
28486: LD_INT 3
28488: PPUSH
28489: CALL_OW 67
// if not mc_build_list [ i ] then
28493: LD_EXP 55
28497: PUSH
28498: LD_VAR 0 2
28502: ARRAY
28503: NOT
28504: IFFALSE 28508
// break ;
28506: GO 28607
// if not HasTask ( j ) then
28508: LD_VAR 0 3
28512: PPUSH
28513: CALL_OW 314
28517: NOT
28518: IFFALSE 28605
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
28520: LD_VAR 0 3
28524: PPUSH
28525: LD_EXP 55
28529: PUSH
28530: LD_VAR 0 2
28534: ARRAY
28535: PUSH
28536: LD_INT 1
28538: ARRAY
28539: PUSH
28540: LD_INT 1
28542: ARRAY
28543: PPUSH
28544: LD_EXP 55
28548: PUSH
28549: LD_VAR 0 2
28553: ARRAY
28554: PUSH
28555: LD_INT 1
28557: ARRAY
28558: PUSH
28559: LD_INT 2
28561: ARRAY
28562: PPUSH
28563: LD_EXP 55
28567: PUSH
28568: LD_VAR 0 2
28572: ARRAY
28573: PUSH
28574: LD_INT 1
28576: ARRAY
28577: PUSH
28578: LD_INT 3
28580: ARRAY
28581: PPUSH
28582: LD_EXP 55
28586: PUSH
28587: LD_VAR 0 2
28591: ARRAY
28592: PUSH
28593: LD_INT 1
28595: ARRAY
28596: PUSH
28597: LD_INT 4
28599: ARRAY
28600: PPUSH
28601: CALL_OW 145
// end ;
28605: GO 28394
28607: POP
28608: POP
// end else
28609: GO 28753
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
28611: LD_EXP 50
28615: PUSH
28616: LD_VAR 0 2
28620: ARRAY
28621: PPUSH
28622: LD_EXP 55
28626: PUSH
28627: LD_VAR 0 2
28631: ARRAY
28632: PUSH
28633: LD_INT 1
28635: ARRAY
28636: PUSH
28637: LD_INT 1
28639: ARRAY
28640: PPUSH
28641: LD_EXP 55
28645: PUSH
28646: LD_VAR 0 2
28650: ARRAY
28651: PUSH
28652: LD_INT 1
28654: ARRAY
28655: PUSH
28656: LD_INT 2
28658: ARRAY
28659: PPUSH
28660: LD_EXP 55
28664: PUSH
28665: LD_VAR 0 2
28669: ARRAY
28670: PUSH
28671: LD_INT 1
28673: ARRAY
28674: PUSH
28675: LD_INT 3
28677: ARRAY
28678: PPUSH
28679: LD_EXP 55
28683: PUSH
28684: LD_VAR 0 2
28688: ARRAY
28689: PUSH
28690: LD_INT 1
28692: ARRAY
28693: PUSH
28694: LD_INT 4
28696: ARRAY
28697: PPUSH
28698: CALL 59082 0 5
28702: NOT
28703: IFFALSE 28753
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
28705: LD_ADDR_EXP 55
28709: PUSH
28710: LD_EXP 55
28714: PPUSH
28715: LD_VAR 0 2
28719: PPUSH
28720: LD_EXP 55
28724: PUSH
28725: LD_VAR 0 2
28729: ARRAY
28730: PPUSH
28731: LD_INT 1
28733: PPUSH
28734: LD_INT 1
28736: NEG
28737: PPUSH
28738: LD_INT 0
28740: PPUSH
28741: CALL 51749 0 4
28745: PPUSH
28746: CALL_OW 1
28750: ST_TO_ADDR
// continue ;
28751: GO 27629
// end ; end ; end ;
28753: GO 27629
28755: POP
28756: POP
// end ;
28757: LD_VAR 0 1
28761: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
28762: LD_INT 0
28764: PPUSH
28765: PPUSH
28766: PPUSH
28767: PPUSH
28768: PPUSH
28769: PPUSH
// if not mc_bases then
28770: LD_EXP 50
28774: NOT
28775: IFFALSE 28779
// exit ;
28777: GO 29206
// for i = 1 to mc_bases do
28779: LD_ADDR_VAR 0 2
28783: PUSH
28784: DOUBLE
28785: LD_INT 1
28787: DEC
28788: ST_TO_ADDR
28789: LD_EXP 50
28793: PUSH
28794: FOR_TO
28795: IFFALSE 29204
// begin tmp := mc_build_upgrade [ i ] ;
28797: LD_ADDR_VAR 0 4
28801: PUSH
28802: LD_EXP 82
28806: PUSH
28807: LD_VAR 0 2
28811: ARRAY
28812: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
28813: LD_ADDR_VAR 0 6
28817: PUSH
28818: LD_EXP 83
28822: PUSH
28823: LD_VAR 0 2
28827: ARRAY
28828: PPUSH
28829: LD_INT 2
28831: PUSH
28832: LD_INT 30
28834: PUSH
28835: LD_INT 6
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: LD_INT 30
28844: PUSH
28845: LD_INT 7
28847: PUSH
28848: EMPTY
28849: LIST
28850: LIST
28851: PUSH
28852: EMPTY
28853: LIST
28854: LIST
28855: LIST
28856: PPUSH
28857: CALL_OW 72
28861: ST_TO_ADDR
// if not tmp and not lab then
28862: LD_VAR 0 4
28866: NOT
28867: PUSH
28868: LD_VAR 0 6
28872: NOT
28873: AND
28874: IFFALSE 28878
// continue ;
28876: GO 28794
// if tmp then
28878: LD_VAR 0 4
28882: IFFALSE 29002
// for j in tmp do
28884: LD_ADDR_VAR 0 3
28888: PUSH
28889: LD_VAR 0 4
28893: PUSH
28894: FOR_IN
28895: IFFALSE 29000
// begin if UpgradeCost ( j ) then
28897: LD_VAR 0 3
28901: PPUSH
28902: CALL 58742 0 1
28906: IFFALSE 28998
// begin ComUpgrade ( j ) ;
28908: LD_VAR 0 3
28912: PPUSH
28913: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
28917: LD_ADDR_EXP 82
28921: PUSH
28922: LD_EXP 82
28926: PPUSH
28927: LD_VAR 0 2
28931: PPUSH
28932: LD_EXP 82
28936: PUSH
28937: LD_VAR 0 2
28941: ARRAY
28942: PUSH
28943: LD_VAR 0 3
28947: DIFF
28948: PPUSH
28949: CALL_OW 1
28953: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28954: LD_ADDR_EXP 57
28958: PUSH
28959: LD_EXP 57
28963: PPUSH
28964: LD_VAR 0 2
28968: PUSH
28969: LD_EXP 57
28973: PUSH
28974: LD_VAR 0 2
28978: ARRAY
28979: PUSH
28980: LD_INT 1
28982: PLUS
28983: PUSH
28984: EMPTY
28985: LIST
28986: LIST
28987: PPUSH
28988: LD_VAR 0 3
28992: PPUSH
28993: CALL 52331 0 3
28997: ST_TO_ADDR
// end ; end ;
28998: GO 28894
29000: POP
29001: POP
// if not lab or not mc_lab_upgrade [ i ] then
29002: LD_VAR 0 6
29006: NOT
29007: PUSH
29008: LD_EXP 84
29012: PUSH
29013: LD_VAR 0 2
29017: ARRAY
29018: NOT
29019: OR
29020: IFFALSE 29024
// continue ;
29022: GO 28794
// for j in lab do
29024: LD_ADDR_VAR 0 3
29028: PUSH
29029: LD_VAR 0 6
29033: PUSH
29034: FOR_IN
29035: IFFALSE 29200
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29037: LD_VAR 0 3
29041: PPUSH
29042: CALL_OW 266
29046: PUSH
29047: LD_INT 6
29049: PUSH
29050: LD_INT 7
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: IN
29057: PUSH
29058: LD_VAR 0 3
29062: PPUSH
29063: CALL_OW 461
29067: PUSH
29068: LD_INT 1
29070: NONEQUAL
29071: AND
29072: IFFALSE 29198
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29074: LD_VAR 0 3
29078: PPUSH
29079: LD_EXP 84
29083: PUSH
29084: LD_VAR 0 2
29088: ARRAY
29089: PUSH
29090: LD_INT 1
29092: ARRAY
29093: PPUSH
29094: CALL 58947 0 2
29098: IFFALSE 29198
// begin ComCancel ( j ) ;
29100: LD_VAR 0 3
29104: PPUSH
29105: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29109: LD_VAR 0 3
29113: PPUSH
29114: LD_EXP 84
29118: PUSH
29119: LD_VAR 0 2
29123: ARRAY
29124: PUSH
29125: LD_INT 1
29127: ARRAY
29128: PPUSH
29129: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29133: LD_VAR 0 3
29137: PUSH
29138: LD_EXP 57
29142: PUSH
29143: LD_VAR 0 2
29147: ARRAY
29148: IN
29149: NOT
29150: IFFALSE 29196
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29152: LD_ADDR_EXP 57
29156: PUSH
29157: LD_EXP 57
29161: PPUSH
29162: LD_VAR 0 2
29166: PUSH
29167: LD_EXP 57
29171: PUSH
29172: LD_VAR 0 2
29176: ARRAY
29177: PUSH
29178: LD_INT 1
29180: PLUS
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: PPUSH
29186: LD_VAR 0 3
29190: PPUSH
29191: CALL 52331 0 3
29195: ST_TO_ADDR
// break ;
29196: GO 29200
// end ; end ; end ;
29198: GO 29034
29200: POP
29201: POP
// end ;
29202: GO 28794
29204: POP
29205: POP
// end ;
29206: LD_VAR 0 1
29210: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29211: LD_INT 0
29213: PPUSH
29214: PPUSH
29215: PPUSH
29216: PPUSH
29217: PPUSH
29218: PPUSH
29219: PPUSH
29220: PPUSH
29221: PPUSH
// if not mc_bases then
29222: LD_EXP 50
29226: NOT
29227: IFFALSE 29231
// exit ;
29229: GO 29636
// for i = 1 to mc_bases do
29231: LD_ADDR_VAR 0 2
29235: PUSH
29236: DOUBLE
29237: LD_INT 1
29239: DEC
29240: ST_TO_ADDR
29241: LD_EXP 50
29245: PUSH
29246: FOR_TO
29247: IFFALSE 29634
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
29249: LD_EXP 58
29253: PUSH
29254: LD_VAR 0 2
29258: ARRAY
29259: NOT
29260: PUSH
29261: LD_EXP 50
29265: PUSH
29266: LD_VAR 0 2
29270: ARRAY
29271: PPUSH
29272: LD_INT 30
29274: PUSH
29275: LD_INT 3
29277: PUSH
29278: EMPTY
29279: LIST
29280: LIST
29281: PPUSH
29282: CALL_OW 72
29286: NOT
29287: OR
29288: IFFALSE 29292
// continue ;
29290: GO 29246
// busy := false ;
29292: LD_ADDR_VAR 0 8
29296: PUSH
29297: LD_INT 0
29299: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29300: LD_ADDR_VAR 0 4
29304: PUSH
29305: LD_EXP 50
29309: PUSH
29310: LD_VAR 0 2
29314: ARRAY
29315: PPUSH
29316: LD_INT 30
29318: PUSH
29319: LD_INT 3
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PPUSH
29326: CALL_OW 72
29330: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
29331: LD_ADDR_VAR 0 6
29335: PUSH
29336: LD_EXP 58
29340: PUSH
29341: LD_VAR 0 2
29345: ARRAY
29346: PPUSH
29347: LD_INT 2
29349: PUSH
29350: LD_INT 30
29352: PUSH
29353: LD_INT 32
29355: PUSH
29356: EMPTY
29357: LIST
29358: LIST
29359: PUSH
29360: LD_INT 30
29362: PUSH
29363: LD_INT 33
29365: PUSH
29366: EMPTY
29367: LIST
29368: LIST
29369: PUSH
29370: EMPTY
29371: LIST
29372: LIST
29373: LIST
29374: PPUSH
29375: CALL_OW 72
29379: ST_TO_ADDR
// if not t then
29380: LD_VAR 0 6
29384: NOT
29385: IFFALSE 29389
// continue ;
29387: GO 29246
// for j in tmp do
29389: LD_ADDR_VAR 0 3
29393: PUSH
29394: LD_VAR 0 4
29398: PUSH
29399: FOR_IN
29400: IFFALSE 29430
// if not BuildingStatus ( j ) = bs_idle then
29402: LD_VAR 0 3
29406: PPUSH
29407: CALL_OW 461
29411: PUSH
29412: LD_INT 2
29414: EQUAL
29415: NOT
29416: IFFALSE 29428
// begin busy := true ;
29418: LD_ADDR_VAR 0 8
29422: PUSH
29423: LD_INT 1
29425: ST_TO_ADDR
// break ;
29426: GO 29430
// end ;
29428: GO 29399
29430: POP
29431: POP
// if busy then
29432: LD_VAR 0 8
29436: IFFALSE 29440
// continue ;
29438: GO 29246
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
29440: LD_ADDR_VAR 0 7
29444: PUSH
29445: LD_VAR 0 6
29449: PPUSH
29450: LD_INT 35
29452: PUSH
29453: LD_INT 0
29455: PUSH
29456: EMPTY
29457: LIST
29458: LIST
29459: PPUSH
29460: CALL_OW 72
29464: ST_TO_ADDR
// if tw then
29465: LD_VAR 0 7
29469: IFFALSE 29546
// begin tw := tw [ 1 ] ;
29471: LD_ADDR_VAR 0 7
29475: PUSH
29476: LD_VAR 0 7
29480: PUSH
29481: LD_INT 1
29483: ARRAY
29484: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
29485: LD_ADDR_VAR 0 9
29489: PUSH
29490: LD_VAR 0 7
29494: PPUSH
29495: LD_EXP 75
29499: PUSH
29500: LD_VAR 0 2
29504: ARRAY
29505: PPUSH
29506: CALL 57301 0 2
29510: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
29511: LD_EXP 89
29515: PUSH
29516: LD_VAR 0 2
29520: ARRAY
29521: IFFALSE 29544
// if not weapon in mc_allowed_tower_weapons [ i ] then
29523: LD_VAR 0 9
29527: PUSH
29528: LD_EXP 89
29532: PUSH
29533: LD_VAR 0 2
29537: ARRAY
29538: IN
29539: NOT
29540: IFFALSE 29544
// continue ;
29542: GO 29246
// end else
29544: GO 29609
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
29546: LD_ADDR_VAR 0 5
29550: PUSH
29551: LD_EXP 58
29555: PUSH
29556: LD_VAR 0 2
29560: ARRAY
29561: PPUSH
29562: LD_VAR 0 4
29566: PPUSH
29567: CALL 82922 0 2
29571: ST_TO_ADDR
// if not tmp2 then
29572: LD_VAR 0 5
29576: NOT
29577: IFFALSE 29581
// continue ;
29579: GO 29246
// tw := tmp2 [ 1 ] ;
29581: LD_ADDR_VAR 0 7
29585: PUSH
29586: LD_VAR 0 5
29590: PUSH
29591: LD_INT 1
29593: ARRAY
29594: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
29595: LD_ADDR_VAR 0 9
29599: PUSH
29600: LD_VAR 0 5
29604: PUSH
29605: LD_INT 2
29607: ARRAY
29608: ST_TO_ADDR
// end ; if not weapon then
29609: LD_VAR 0 9
29613: NOT
29614: IFFALSE 29618
// continue ;
29616: GO 29246
// ComPlaceWeapon ( tw , weapon ) ;
29618: LD_VAR 0 7
29622: PPUSH
29623: LD_VAR 0 9
29627: PPUSH
29628: CALL_OW 148
// end ;
29632: GO 29246
29634: POP
29635: POP
// end ;
29636: LD_VAR 0 1
29640: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
29641: LD_INT 0
29643: PPUSH
29644: PPUSH
29645: PPUSH
29646: PPUSH
29647: PPUSH
29648: PPUSH
// if not mc_bases then
29649: LD_EXP 50
29653: NOT
29654: IFFALSE 29658
// exit ;
29656: GO 30434
// for i = 1 to mc_bases do
29658: LD_ADDR_VAR 0 2
29662: PUSH
29663: DOUBLE
29664: LD_INT 1
29666: DEC
29667: ST_TO_ADDR
29668: LD_EXP 50
29672: PUSH
29673: FOR_TO
29674: IFFALSE 30432
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
29676: LD_EXP 63
29680: PUSH
29681: LD_VAR 0 2
29685: ARRAY
29686: NOT
29687: PUSH
29688: LD_EXP 63
29692: PUSH
29693: LD_VAR 0 2
29697: ARRAY
29698: PUSH
29699: LD_EXP 64
29703: PUSH
29704: LD_VAR 0 2
29708: ARRAY
29709: EQUAL
29710: OR
29711: PUSH
29712: LD_EXP 73
29716: PUSH
29717: LD_VAR 0 2
29721: ARRAY
29722: OR
29723: IFFALSE 29727
// continue ;
29725: GO 29673
// if mc_miners [ i ] then
29727: LD_EXP 64
29731: PUSH
29732: LD_VAR 0 2
29736: ARRAY
29737: IFFALSE 30119
// begin for j = mc_miners [ i ] downto 1 do
29739: LD_ADDR_VAR 0 3
29743: PUSH
29744: DOUBLE
29745: LD_EXP 64
29749: PUSH
29750: LD_VAR 0 2
29754: ARRAY
29755: INC
29756: ST_TO_ADDR
29757: LD_INT 1
29759: PUSH
29760: FOR_DOWNTO
29761: IFFALSE 30117
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
29763: LD_EXP 64
29767: PUSH
29768: LD_VAR 0 2
29772: ARRAY
29773: PUSH
29774: LD_VAR 0 3
29778: ARRAY
29779: PPUSH
29780: CALL_OW 301
29784: PUSH
29785: LD_EXP 64
29789: PUSH
29790: LD_VAR 0 2
29794: ARRAY
29795: PUSH
29796: LD_VAR 0 3
29800: ARRAY
29801: PPUSH
29802: CALL_OW 257
29806: PUSH
29807: LD_INT 1
29809: NONEQUAL
29810: OR
29811: IFFALSE 29874
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
29813: LD_ADDR_VAR 0 5
29817: PUSH
29818: LD_EXP 64
29822: PUSH
29823: LD_VAR 0 2
29827: ARRAY
29828: PUSH
29829: LD_EXP 64
29833: PUSH
29834: LD_VAR 0 2
29838: ARRAY
29839: PUSH
29840: LD_VAR 0 3
29844: ARRAY
29845: DIFF
29846: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
29847: LD_ADDR_EXP 64
29851: PUSH
29852: LD_EXP 64
29856: PPUSH
29857: LD_VAR 0 2
29861: PPUSH
29862: LD_VAR 0 5
29866: PPUSH
29867: CALL_OW 1
29871: ST_TO_ADDR
// continue ;
29872: GO 29760
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
29874: LD_EXP 64
29878: PUSH
29879: LD_VAR 0 2
29883: ARRAY
29884: PUSH
29885: LD_VAR 0 3
29889: ARRAY
29890: PPUSH
29891: CALL_OW 257
29895: PUSH
29896: LD_INT 1
29898: EQUAL
29899: PUSH
29900: LD_EXP 64
29904: PUSH
29905: LD_VAR 0 2
29909: ARRAY
29910: PUSH
29911: LD_VAR 0 3
29915: ARRAY
29916: PPUSH
29917: CALL_OW 459
29921: NOT
29922: AND
29923: PUSH
29924: LD_EXP 64
29928: PUSH
29929: LD_VAR 0 2
29933: ARRAY
29934: PUSH
29935: LD_VAR 0 3
29939: ARRAY
29940: PPUSH
29941: CALL_OW 314
29945: NOT
29946: AND
29947: IFFALSE 30115
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
29949: LD_EXP 64
29953: PUSH
29954: LD_VAR 0 2
29958: ARRAY
29959: PUSH
29960: LD_VAR 0 3
29964: ARRAY
29965: PPUSH
29966: CALL_OW 310
29970: IFFALSE 29993
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
29972: LD_EXP 64
29976: PUSH
29977: LD_VAR 0 2
29981: ARRAY
29982: PUSH
29983: LD_VAR 0 3
29987: ARRAY
29988: PPUSH
29989: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
29993: LD_EXP 64
29997: PUSH
29998: LD_VAR 0 2
30002: ARRAY
30003: PUSH
30004: LD_VAR 0 3
30008: ARRAY
30009: PPUSH
30010: CALL_OW 314
30014: NOT
30015: IFFALSE 30115
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
30017: LD_EXP 64
30021: PUSH
30022: LD_VAR 0 2
30026: ARRAY
30027: PUSH
30028: LD_VAR 0 3
30032: ARRAY
30033: PPUSH
30034: LD_EXP 63
30038: PUSH
30039: LD_VAR 0 2
30043: ARRAY
30044: PUSH
30045: LD_VAR 0 3
30049: PUSH
30050: LD_EXP 63
30054: PUSH
30055: LD_VAR 0 2
30059: ARRAY
30060: MOD
30061: PUSH
30062: LD_INT 1
30064: PLUS
30065: ARRAY
30066: PUSH
30067: LD_INT 1
30069: ARRAY
30070: PPUSH
30071: LD_EXP 63
30075: PUSH
30076: LD_VAR 0 2
30080: ARRAY
30081: PUSH
30082: LD_VAR 0 3
30086: PUSH
30087: LD_EXP 63
30091: PUSH
30092: LD_VAR 0 2
30096: ARRAY
30097: MOD
30098: PUSH
30099: LD_INT 1
30101: PLUS
30102: ARRAY
30103: PUSH
30104: LD_INT 2
30106: ARRAY
30107: PPUSH
30108: LD_INT 0
30110: PPUSH
30111: CALL_OW 193
// end ; end ;
30115: GO 29760
30117: POP
30118: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30119: LD_ADDR_VAR 0 5
30123: PUSH
30124: LD_EXP 50
30128: PUSH
30129: LD_VAR 0 2
30133: ARRAY
30134: PPUSH
30135: LD_INT 2
30137: PUSH
30138: LD_INT 30
30140: PUSH
30141: LD_INT 4
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 30
30150: PUSH
30151: LD_INT 5
30153: PUSH
30154: EMPTY
30155: LIST
30156: LIST
30157: PUSH
30158: LD_INT 30
30160: PUSH
30161: LD_INT 32
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: LIST
30172: LIST
30173: PPUSH
30174: CALL_OW 72
30178: ST_TO_ADDR
// if not tmp then
30179: LD_VAR 0 5
30183: NOT
30184: IFFALSE 30188
// continue ;
30186: GO 29673
// list := [ ] ;
30188: LD_ADDR_VAR 0 6
30192: PUSH
30193: EMPTY
30194: ST_TO_ADDR
// for j in tmp do
30195: LD_ADDR_VAR 0 3
30199: PUSH
30200: LD_VAR 0 5
30204: PUSH
30205: FOR_IN
30206: IFFALSE 30275
// begin for k in UnitsInside ( j ) do
30208: LD_ADDR_VAR 0 4
30212: PUSH
30213: LD_VAR 0 3
30217: PPUSH
30218: CALL_OW 313
30222: PUSH
30223: FOR_IN
30224: IFFALSE 30271
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30226: LD_VAR 0 4
30230: PPUSH
30231: CALL_OW 257
30235: PUSH
30236: LD_INT 1
30238: EQUAL
30239: PUSH
30240: LD_VAR 0 4
30244: PPUSH
30245: CALL_OW 459
30249: NOT
30250: AND
30251: IFFALSE 30269
// list := list ^ k ;
30253: LD_ADDR_VAR 0 6
30257: PUSH
30258: LD_VAR 0 6
30262: PUSH
30263: LD_VAR 0 4
30267: ADD
30268: ST_TO_ADDR
30269: GO 30223
30271: POP
30272: POP
// end ;
30273: GO 30205
30275: POP
30276: POP
// list := list diff mc_miners [ i ] ;
30277: LD_ADDR_VAR 0 6
30281: PUSH
30282: LD_VAR 0 6
30286: PUSH
30287: LD_EXP 64
30291: PUSH
30292: LD_VAR 0 2
30296: ARRAY
30297: DIFF
30298: ST_TO_ADDR
// if not list then
30299: LD_VAR 0 6
30303: NOT
30304: IFFALSE 30308
// continue ;
30306: GO 29673
// k := mc_mines [ i ] - mc_miners [ i ] ;
30308: LD_ADDR_VAR 0 4
30312: PUSH
30313: LD_EXP 63
30317: PUSH
30318: LD_VAR 0 2
30322: ARRAY
30323: PUSH
30324: LD_EXP 64
30328: PUSH
30329: LD_VAR 0 2
30333: ARRAY
30334: MINUS
30335: ST_TO_ADDR
// if k > list then
30336: LD_VAR 0 4
30340: PUSH
30341: LD_VAR 0 6
30345: GREATER
30346: IFFALSE 30358
// k := list ;
30348: LD_ADDR_VAR 0 4
30352: PUSH
30353: LD_VAR 0 6
30357: ST_TO_ADDR
// for j = 1 to k do
30358: LD_ADDR_VAR 0 3
30362: PUSH
30363: DOUBLE
30364: LD_INT 1
30366: DEC
30367: ST_TO_ADDR
30368: LD_VAR 0 4
30372: PUSH
30373: FOR_TO
30374: IFFALSE 30428
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30376: LD_ADDR_EXP 64
30380: PUSH
30381: LD_EXP 64
30385: PPUSH
30386: LD_VAR 0 2
30390: PUSH
30391: LD_EXP 64
30395: PUSH
30396: LD_VAR 0 2
30400: ARRAY
30401: PUSH
30402: LD_INT 1
30404: PLUS
30405: PUSH
30406: EMPTY
30407: LIST
30408: LIST
30409: PPUSH
30410: LD_VAR 0 6
30414: PUSH
30415: LD_VAR 0 3
30419: ARRAY
30420: PPUSH
30421: CALL 52331 0 3
30425: ST_TO_ADDR
30426: GO 30373
30428: POP
30429: POP
// end ;
30430: GO 29673
30432: POP
30433: POP
// end ;
30434: LD_VAR 0 1
30438: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30439: LD_INT 0
30441: PPUSH
30442: PPUSH
30443: PPUSH
30444: PPUSH
30445: PPUSH
30446: PPUSH
30447: PPUSH
30448: PPUSH
30449: PPUSH
30450: PPUSH
// if not mc_bases then
30451: LD_EXP 50
30455: NOT
30456: IFFALSE 30460
// exit ;
30458: GO 32210
// for i = 1 to mc_bases do
30460: LD_ADDR_VAR 0 2
30464: PUSH
30465: DOUBLE
30466: LD_INT 1
30468: DEC
30469: ST_TO_ADDR
30470: LD_EXP 50
30474: PUSH
30475: FOR_TO
30476: IFFALSE 32208
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
30478: LD_EXP 50
30482: PUSH
30483: LD_VAR 0 2
30487: ARRAY
30488: NOT
30489: PUSH
30490: LD_EXP 57
30494: PUSH
30495: LD_VAR 0 2
30499: ARRAY
30500: OR
30501: IFFALSE 30505
// continue ;
30503: GO 30475
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
30505: LD_EXP 66
30509: PUSH
30510: LD_VAR 0 2
30514: ARRAY
30515: NOT
30516: PUSH
30517: LD_EXP 67
30521: PUSH
30522: LD_VAR 0 2
30526: ARRAY
30527: AND
30528: IFFALSE 30566
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
30530: LD_ADDR_EXP 67
30534: PUSH
30535: LD_EXP 67
30539: PPUSH
30540: LD_VAR 0 2
30544: PPUSH
30545: EMPTY
30546: PPUSH
30547: CALL_OW 1
30551: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
30552: LD_VAR 0 2
30556: PPUSH
30557: LD_INT 107
30559: PPUSH
30560: CALL 21440 0 2
// continue ;
30564: GO 30475
// end ; target := [ ] ;
30566: LD_ADDR_VAR 0 6
30570: PUSH
30571: EMPTY
30572: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
30573: LD_ADDR_VAR 0 3
30577: PUSH
30578: DOUBLE
30579: LD_EXP 66
30583: PUSH
30584: LD_VAR 0 2
30588: ARRAY
30589: INC
30590: ST_TO_ADDR
30591: LD_INT 1
30593: PUSH
30594: FOR_DOWNTO
30595: IFFALSE 30855
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
30597: LD_EXP 66
30601: PUSH
30602: LD_VAR 0 2
30606: ARRAY
30607: PUSH
30608: LD_VAR 0 3
30612: ARRAY
30613: PUSH
30614: LD_INT 2
30616: ARRAY
30617: PPUSH
30618: LD_EXP 66
30622: PUSH
30623: LD_VAR 0 2
30627: ARRAY
30628: PUSH
30629: LD_VAR 0 3
30633: ARRAY
30634: PUSH
30635: LD_INT 3
30637: ARRAY
30638: PPUSH
30639: CALL_OW 488
30643: PUSH
30644: LD_EXP 66
30648: PUSH
30649: LD_VAR 0 2
30653: ARRAY
30654: PUSH
30655: LD_VAR 0 3
30659: ARRAY
30660: PUSH
30661: LD_INT 2
30663: ARRAY
30664: PPUSH
30665: LD_EXP 66
30669: PUSH
30670: LD_VAR 0 2
30674: ARRAY
30675: PUSH
30676: LD_VAR 0 3
30680: ARRAY
30681: PUSH
30682: LD_INT 3
30684: ARRAY
30685: PPUSH
30686: CALL_OW 284
30690: PUSH
30691: LD_INT 0
30693: EQUAL
30694: AND
30695: IFFALSE 30750
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
30697: LD_ADDR_VAR 0 5
30701: PUSH
30702: LD_EXP 66
30706: PUSH
30707: LD_VAR 0 2
30711: ARRAY
30712: PPUSH
30713: LD_VAR 0 3
30717: PPUSH
30718: CALL_OW 3
30722: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
30723: LD_ADDR_EXP 66
30727: PUSH
30728: LD_EXP 66
30732: PPUSH
30733: LD_VAR 0 2
30737: PPUSH
30738: LD_VAR 0 5
30742: PPUSH
30743: CALL_OW 1
30747: ST_TO_ADDR
// continue ;
30748: GO 30594
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
30750: LD_EXP 50
30754: PUSH
30755: LD_VAR 0 2
30759: ARRAY
30760: PUSH
30761: LD_INT 1
30763: ARRAY
30764: PPUSH
30765: CALL_OW 255
30769: PPUSH
30770: LD_EXP 66
30774: PUSH
30775: LD_VAR 0 2
30779: ARRAY
30780: PUSH
30781: LD_VAR 0 3
30785: ARRAY
30786: PUSH
30787: LD_INT 2
30789: ARRAY
30790: PPUSH
30791: LD_EXP 66
30795: PUSH
30796: LD_VAR 0 2
30800: ARRAY
30801: PUSH
30802: LD_VAR 0 3
30806: ARRAY
30807: PUSH
30808: LD_INT 3
30810: ARRAY
30811: PPUSH
30812: LD_INT 30
30814: PPUSH
30815: CALL 53227 0 4
30819: PUSH
30820: LD_INT 4
30822: ARRAY
30823: PUSH
30824: LD_INT 0
30826: EQUAL
30827: IFFALSE 30853
// begin target := mc_crates [ i ] [ j ] ;
30829: LD_ADDR_VAR 0 6
30833: PUSH
30834: LD_EXP 66
30838: PUSH
30839: LD_VAR 0 2
30843: ARRAY
30844: PUSH
30845: LD_VAR 0 3
30849: ARRAY
30850: ST_TO_ADDR
// break ;
30851: GO 30855
// end ; end ;
30853: GO 30594
30855: POP
30856: POP
// if not target then
30857: LD_VAR 0 6
30861: NOT
30862: IFFALSE 30866
// continue ;
30864: GO 30475
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
30866: LD_ADDR_VAR 0 7
30870: PUSH
30871: LD_EXP 69
30875: PUSH
30876: LD_VAR 0 2
30880: ARRAY
30881: PPUSH
30882: LD_INT 2
30884: PUSH
30885: LD_INT 3
30887: PUSH
30888: LD_INT 58
30890: PUSH
30891: EMPTY
30892: LIST
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 61
30900: PUSH
30901: EMPTY
30902: LIST
30903: PUSH
30904: LD_INT 33
30906: PUSH
30907: LD_INT 5
30909: PUSH
30910: EMPTY
30911: LIST
30912: LIST
30913: PUSH
30914: LD_INT 33
30916: PUSH
30917: LD_INT 3
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: LIST
30928: LIST
30929: LIST
30930: PUSH
30931: LD_INT 2
30933: PUSH
30934: LD_INT 34
30936: PUSH
30937: LD_INT 32
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 34
30946: PUSH
30947: LD_INT 51
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 34
30956: PUSH
30957: LD_INT 12
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: EMPTY
30965: LIST
30966: LIST
30967: LIST
30968: LIST
30969: PUSH
30970: EMPTY
30971: LIST
30972: LIST
30973: PPUSH
30974: CALL_OW 72
30978: ST_TO_ADDR
// if not cargo then
30979: LD_VAR 0 7
30983: NOT
30984: IFFALSE 31627
// begin if mc_crates_collector [ i ] < 5 then
30986: LD_EXP 67
30990: PUSH
30991: LD_VAR 0 2
30995: ARRAY
30996: PUSH
30997: LD_INT 5
30999: LESS
31000: IFFALSE 31366
// begin if mc_ape [ i ] then
31002: LD_EXP 79
31006: PUSH
31007: LD_VAR 0 2
31011: ARRAY
31012: IFFALSE 31059
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31014: LD_ADDR_VAR 0 5
31018: PUSH
31019: LD_EXP 79
31023: PUSH
31024: LD_VAR 0 2
31028: ARRAY
31029: PPUSH
31030: LD_INT 25
31032: PUSH
31033: LD_INT 16
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: PUSH
31040: LD_INT 24
31042: PUSH
31043: LD_INT 750
31045: PUSH
31046: EMPTY
31047: LIST
31048: LIST
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PPUSH
31054: CALL_OW 72
31058: ST_TO_ADDR
// if not tmp then
31059: LD_VAR 0 5
31063: NOT
31064: IFFALSE 31111
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31066: LD_ADDR_VAR 0 5
31070: PUSH
31071: LD_EXP 50
31075: PUSH
31076: LD_VAR 0 2
31080: ARRAY
31081: PPUSH
31082: LD_INT 25
31084: PUSH
31085: LD_INT 2
31087: PUSH
31088: EMPTY
31089: LIST
31090: LIST
31091: PUSH
31092: LD_INT 24
31094: PUSH
31095: LD_INT 750
31097: PUSH
31098: EMPTY
31099: LIST
31100: LIST
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: PPUSH
31106: CALL_OW 72
31110: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31111: LD_EXP 79
31115: PUSH
31116: LD_VAR 0 2
31120: ARRAY
31121: PUSH
31122: LD_EXP 50
31126: PUSH
31127: LD_VAR 0 2
31131: ARRAY
31132: PPUSH
31133: LD_INT 25
31135: PUSH
31136: LD_INT 2
31138: PUSH
31139: EMPTY
31140: LIST
31141: LIST
31142: PUSH
31143: LD_INT 24
31145: PUSH
31146: LD_INT 750
31148: PUSH
31149: EMPTY
31150: LIST
31151: LIST
31152: PUSH
31153: EMPTY
31154: LIST
31155: LIST
31156: PPUSH
31157: CALL_OW 72
31161: AND
31162: PUSH
31163: LD_VAR 0 5
31167: PUSH
31168: LD_INT 5
31170: LESS
31171: AND
31172: IFFALSE 31254
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31174: LD_ADDR_VAR 0 3
31178: PUSH
31179: LD_EXP 50
31183: PUSH
31184: LD_VAR 0 2
31188: ARRAY
31189: PPUSH
31190: LD_INT 25
31192: PUSH
31193: LD_INT 2
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: PUSH
31200: LD_INT 24
31202: PUSH
31203: LD_INT 750
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: EMPTY
31211: LIST
31212: LIST
31213: PPUSH
31214: CALL_OW 72
31218: PUSH
31219: FOR_IN
31220: IFFALSE 31252
// begin tmp := tmp union j ;
31222: LD_ADDR_VAR 0 5
31226: PUSH
31227: LD_VAR 0 5
31231: PUSH
31232: LD_VAR 0 3
31236: UNION
31237: ST_TO_ADDR
// if tmp >= 5 then
31238: LD_VAR 0 5
31242: PUSH
31243: LD_INT 5
31245: GREATEREQUAL
31246: IFFALSE 31250
// break ;
31248: GO 31252
// end ;
31250: GO 31219
31252: POP
31253: POP
// end ; if not tmp then
31254: LD_VAR 0 5
31258: NOT
31259: IFFALSE 31263
// continue ;
31261: GO 30475
// for j in tmp do
31263: LD_ADDR_VAR 0 3
31267: PUSH
31268: LD_VAR 0 5
31272: PUSH
31273: FOR_IN
31274: IFFALSE 31364
// if not GetTag ( j ) then
31276: LD_VAR 0 3
31280: PPUSH
31281: CALL_OW 110
31285: NOT
31286: IFFALSE 31362
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31288: LD_ADDR_EXP 67
31292: PUSH
31293: LD_EXP 67
31297: PPUSH
31298: LD_VAR 0 2
31302: PUSH
31303: LD_EXP 67
31307: PUSH
31308: LD_VAR 0 2
31312: ARRAY
31313: PUSH
31314: LD_INT 1
31316: PLUS
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PPUSH
31322: LD_VAR 0 3
31326: PPUSH
31327: CALL 52331 0 3
31331: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31332: LD_VAR 0 3
31336: PPUSH
31337: LD_INT 107
31339: PPUSH
31340: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31344: LD_EXP 67
31348: PUSH
31349: LD_VAR 0 2
31353: ARRAY
31354: PUSH
31355: LD_INT 5
31357: GREATEREQUAL
31358: IFFALSE 31362
// break ;
31360: GO 31364
// end ;
31362: GO 31273
31364: POP
31365: POP
// end ; if mc_crates_collector [ i ] and target then
31366: LD_EXP 67
31370: PUSH
31371: LD_VAR 0 2
31375: ARRAY
31376: PUSH
31377: LD_VAR 0 6
31381: AND
31382: IFFALSE 31625
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31384: LD_EXP 67
31388: PUSH
31389: LD_VAR 0 2
31393: ARRAY
31394: PUSH
31395: LD_VAR 0 6
31399: PUSH
31400: LD_INT 1
31402: ARRAY
31403: LESS
31404: IFFALSE 31424
// tmp := mc_crates_collector [ i ] else
31406: LD_ADDR_VAR 0 5
31410: PUSH
31411: LD_EXP 67
31415: PUSH
31416: LD_VAR 0 2
31420: ARRAY
31421: ST_TO_ADDR
31422: GO 31438
// tmp := target [ 1 ] ;
31424: LD_ADDR_VAR 0 5
31428: PUSH
31429: LD_VAR 0 6
31433: PUSH
31434: LD_INT 1
31436: ARRAY
31437: ST_TO_ADDR
// k := 0 ;
31438: LD_ADDR_VAR 0 4
31442: PUSH
31443: LD_INT 0
31445: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31446: LD_ADDR_VAR 0 3
31450: PUSH
31451: LD_EXP 67
31455: PUSH
31456: LD_VAR 0 2
31460: ARRAY
31461: PUSH
31462: FOR_IN
31463: IFFALSE 31623
// begin k := k + 1 ;
31465: LD_ADDR_VAR 0 4
31469: PUSH
31470: LD_VAR 0 4
31474: PUSH
31475: LD_INT 1
31477: PLUS
31478: ST_TO_ADDR
// if k > tmp then
31479: LD_VAR 0 4
31483: PUSH
31484: LD_VAR 0 5
31488: GREATER
31489: IFFALSE 31493
// break ;
31491: GO 31623
// if not GetClass ( j ) in [ 2 , 16 ] then
31493: LD_VAR 0 3
31497: PPUSH
31498: CALL_OW 257
31502: PUSH
31503: LD_INT 2
31505: PUSH
31506: LD_INT 16
31508: PUSH
31509: EMPTY
31510: LIST
31511: LIST
31512: IN
31513: NOT
31514: IFFALSE 31567
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
31516: LD_ADDR_EXP 67
31520: PUSH
31521: LD_EXP 67
31525: PPUSH
31526: LD_VAR 0 2
31530: PPUSH
31531: LD_EXP 67
31535: PUSH
31536: LD_VAR 0 2
31540: ARRAY
31541: PUSH
31542: LD_VAR 0 3
31546: DIFF
31547: PPUSH
31548: CALL_OW 1
31552: ST_TO_ADDR
// SetTag ( j , 0 ) ;
31553: LD_VAR 0 3
31557: PPUSH
31558: LD_INT 0
31560: PPUSH
31561: CALL_OW 109
// continue ;
31565: GO 31462
// end ; if IsInUnit ( j ) then
31567: LD_VAR 0 3
31571: PPUSH
31572: CALL_OW 310
31576: IFFALSE 31587
// ComExitBuilding ( j ) ;
31578: LD_VAR 0 3
31582: PPUSH
31583: CALL_OW 122
// wait ( 3 ) ;
31587: LD_INT 3
31589: PPUSH
31590: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
31594: LD_VAR 0 3
31598: PPUSH
31599: LD_VAR 0 6
31603: PUSH
31604: LD_INT 2
31606: ARRAY
31607: PPUSH
31608: LD_VAR 0 6
31612: PUSH
31613: LD_INT 3
31615: ARRAY
31616: PPUSH
31617: CALL_OW 117
// end ;
31621: GO 31462
31623: POP
31624: POP
// end ; end else
31625: GO 32206
// begin for j in cargo do
31627: LD_ADDR_VAR 0 3
31631: PUSH
31632: LD_VAR 0 7
31636: PUSH
31637: FOR_IN
31638: IFFALSE 32204
// begin if GetTag ( j ) <> 0 then
31640: LD_VAR 0 3
31644: PPUSH
31645: CALL_OW 110
31649: PUSH
31650: LD_INT 0
31652: NONEQUAL
31653: IFFALSE 31657
// continue ;
31655: GO 31637
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
31657: LD_VAR 0 3
31661: PPUSH
31662: CALL_OW 256
31666: PUSH
31667: LD_INT 1000
31669: LESS
31670: PUSH
31671: LD_VAR 0 3
31675: PPUSH
31676: LD_EXP 74
31680: PUSH
31681: LD_VAR 0 2
31685: ARRAY
31686: PPUSH
31687: CALL_OW 308
31691: NOT
31692: AND
31693: IFFALSE 31715
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31695: LD_VAR 0 3
31699: PPUSH
31700: LD_EXP 74
31704: PUSH
31705: LD_VAR 0 2
31709: ARRAY
31710: PPUSH
31711: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
31715: LD_VAR 0 3
31719: PPUSH
31720: CALL_OW 256
31724: PUSH
31725: LD_INT 1000
31727: LESS
31728: PUSH
31729: LD_VAR 0 3
31733: PPUSH
31734: LD_EXP 74
31738: PUSH
31739: LD_VAR 0 2
31743: ARRAY
31744: PPUSH
31745: CALL_OW 308
31749: AND
31750: IFFALSE 31754
// continue ;
31752: GO 31637
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
31754: LD_VAR 0 3
31758: PPUSH
31759: CALL_OW 262
31763: PUSH
31764: LD_INT 2
31766: EQUAL
31767: PUSH
31768: LD_VAR 0 3
31772: PPUSH
31773: CALL_OW 261
31777: PUSH
31778: LD_INT 15
31780: LESS
31781: AND
31782: IFFALSE 31786
// continue ;
31784: GO 31637
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
31786: LD_VAR 0 3
31790: PPUSH
31791: CALL_OW 262
31795: PUSH
31796: LD_INT 1
31798: EQUAL
31799: PUSH
31800: LD_VAR 0 3
31804: PPUSH
31805: CALL_OW 261
31809: PUSH
31810: LD_INT 10
31812: LESS
31813: AND
31814: IFFALSE 32143
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31816: LD_ADDR_VAR 0 8
31820: PUSH
31821: LD_EXP 50
31825: PUSH
31826: LD_VAR 0 2
31830: ARRAY
31831: PPUSH
31832: LD_INT 2
31834: PUSH
31835: LD_INT 30
31837: PUSH
31838: LD_INT 0
31840: PUSH
31841: EMPTY
31842: LIST
31843: LIST
31844: PUSH
31845: LD_INT 30
31847: PUSH
31848: LD_INT 1
31850: PUSH
31851: EMPTY
31852: LIST
31853: LIST
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: LIST
31859: PPUSH
31860: CALL_OW 72
31864: ST_TO_ADDR
// if not depot then
31865: LD_VAR 0 8
31869: NOT
31870: IFFALSE 31874
// continue ;
31872: GO 31637
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
31874: LD_VAR 0 3
31878: PPUSH
31879: LD_VAR 0 8
31883: PPUSH
31884: LD_VAR 0 3
31888: PPUSH
31889: CALL_OW 74
31893: PPUSH
31894: CALL_OW 296
31898: PUSH
31899: LD_INT 6
31901: LESS
31902: IFFALSE 31918
// SetFuel ( j , 100 ) else
31904: LD_VAR 0 3
31908: PPUSH
31909: LD_INT 100
31911: PPUSH
31912: CALL_OW 240
31916: GO 32143
// if GetFuel ( j ) = 0 then
31918: LD_VAR 0 3
31922: PPUSH
31923: CALL_OW 261
31927: PUSH
31928: LD_INT 0
31930: EQUAL
31931: IFFALSE 32143
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
31933: LD_ADDR_EXP 69
31937: PUSH
31938: LD_EXP 69
31942: PPUSH
31943: LD_VAR 0 2
31947: PPUSH
31948: LD_EXP 69
31952: PUSH
31953: LD_VAR 0 2
31957: ARRAY
31958: PUSH
31959: LD_VAR 0 3
31963: DIFF
31964: PPUSH
31965: CALL_OW 1
31969: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
31970: LD_VAR 0 3
31974: PPUSH
31975: CALL_OW 263
31979: PUSH
31980: LD_INT 1
31982: EQUAL
31983: IFFALSE 31999
// ComExitVehicle ( IsInUnit ( j ) ) ;
31985: LD_VAR 0 3
31989: PPUSH
31990: CALL_OW 310
31994: PPUSH
31995: CALL_OW 121
// if GetControl ( j ) = control_remote then
31999: LD_VAR 0 3
32003: PPUSH
32004: CALL_OW 263
32008: PUSH
32009: LD_INT 2
32011: EQUAL
32012: IFFALSE 32023
// ComUnlink ( j ) ;
32014: LD_VAR 0 3
32018: PPUSH
32019: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32023: LD_ADDR_VAR 0 9
32027: PUSH
32028: LD_VAR 0 2
32032: PPUSH
32033: LD_INT 3
32035: PPUSH
32036: CALL 41496 0 2
32040: ST_TO_ADDR
// if fac then
32041: LD_VAR 0 9
32045: IFFALSE 32141
// begin for k in fac do
32047: LD_ADDR_VAR 0 4
32051: PUSH
32052: LD_VAR 0 9
32056: PUSH
32057: FOR_IN
32058: IFFALSE 32139
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32060: LD_ADDR_VAR 0 10
32064: PUSH
32065: LD_VAR 0 9
32069: PPUSH
32070: LD_VAR 0 3
32074: PPUSH
32075: CALL_OW 265
32079: PPUSH
32080: LD_VAR 0 3
32084: PPUSH
32085: CALL_OW 262
32089: PPUSH
32090: LD_VAR 0 3
32094: PPUSH
32095: CALL_OW 263
32099: PPUSH
32100: LD_VAR 0 3
32104: PPUSH
32105: CALL_OW 264
32109: PPUSH
32110: CALL 49863 0 5
32114: ST_TO_ADDR
// if components then
32115: LD_VAR 0 10
32119: IFFALSE 32137
// begin MC_InsertProduceList ( i , components ) ;
32121: LD_VAR 0 2
32125: PPUSH
32126: LD_VAR 0 10
32130: PPUSH
32131: CALL 41041 0 2
// break ;
32135: GO 32139
// end ; end ;
32137: GO 32057
32139: POP
32140: POP
// end ; continue ;
32141: GO 31637
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32143: LD_VAR 0 3
32147: PPUSH
32148: LD_INT 1
32150: PPUSH
32151: CALL_OW 289
32155: PUSH
32156: LD_INT 100
32158: LESS
32159: PUSH
32160: LD_VAR 0 3
32164: PPUSH
32165: CALL_OW 314
32169: NOT
32170: AND
32171: IFFALSE 32200
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32173: LD_VAR 0 3
32177: PPUSH
32178: LD_VAR 0 6
32182: PUSH
32183: LD_INT 2
32185: ARRAY
32186: PPUSH
32187: LD_VAR 0 6
32191: PUSH
32192: LD_INT 3
32194: ARRAY
32195: PPUSH
32196: CALL_OW 117
// break ;
32200: GO 32204
// end ;
32202: GO 31637
32204: POP
32205: POP
// end ; end ;
32206: GO 30475
32208: POP
32209: POP
// end ;
32210: LD_VAR 0 1
32214: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32215: LD_INT 0
32217: PPUSH
32218: PPUSH
32219: PPUSH
32220: PPUSH
// if not mc_bases then
32221: LD_EXP 50
32225: NOT
32226: IFFALSE 32230
// exit ;
32228: GO 32391
// for i = 1 to mc_bases do
32230: LD_ADDR_VAR 0 2
32234: PUSH
32235: DOUBLE
32236: LD_INT 1
32238: DEC
32239: ST_TO_ADDR
32240: LD_EXP 50
32244: PUSH
32245: FOR_TO
32246: IFFALSE 32389
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32248: LD_ADDR_VAR 0 4
32252: PUSH
32253: LD_EXP 69
32257: PUSH
32258: LD_VAR 0 2
32262: ARRAY
32263: PUSH
32264: LD_EXP 72
32268: PUSH
32269: LD_VAR 0 2
32273: ARRAY
32274: UNION
32275: PPUSH
32276: LD_INT 33
32278: PUSH
32279: LD_INT 2
32281: PUSH
32282: EMPTY
32283: LIST
32284: LIST
32285: PPUSH
32286: CALL_OW 72
32290: ST_TO_ADDR
// if tmp then
32291: LD_VAR 0 4
32295: IFFALSE 32387
// for j in tmp do
32297: LD_ADDR_VAR 0 3
32301: PUSH
32302: LD_VAR 0 4
32306: PUSH
32307: FOR_IN
32308: IFFALSE 32385
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32310: LD_VAR 0 3
32314: PPUSH
32315: CALL_OW 312
32319: NOT
32320: PUSH
32321: LD_VAR 0 3
32325: PPUSH
32326: CALL_OW 256
32330: PUSH
32331: LD_INT 250
32333: GREATEREQUAL
32334: AND
32335: IFFALSE 32348
// Connect ( j ) else
32337: LD_VAR 0 3
32341: PPUSH
32342: CALL 55264 0 1
32346: GO 32383
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32348: LD_VAR 0 3
32352: PPUSH
32353: CALL_OW 256
32357: PUSH
32358: LD_INT 250
32360: LESS
32361: PUSH
32362: LD_VAR 0 3
32366: PPUSH
32367: CALL_OW 312
32371: AND
32372: IFFALSE 32383
// ComUnlink ( j ) ;
32374: LD_VAR 0 3
32378: PPUSH
32379: CALL_OW 136
32383: GO 32307
32385: POP
32386: POP
// end ;
32387: GO 32245
32389: POP
32390: POP
// end ;
32391: LD_VAR 0 1
32395: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
32396: LD_INT 0
32398: PPUSH
32399: PPUSH
32400: PPUSH
32401: PPUSH
32402: PPUSH
// if not mc_bases then
32403: LD_EXP 50
32407: NOT
32408: IFFALSE 32412
// exit ;
32410: GO 32857
// for i = 1 to mc_bases do
32412: LD_ADDR_VAR 0 2
32416: PUSH
32417: DOUBLE
32418: LD_INT 1
32420: DEC
32421: ST_TO_ADDR
32422: LD_EXP 50
32426: PUSH
32427: FOR_TO
32428: IFFALSE 32855
// begin if not mc_produce [ i ] then
32430: LD_EXP 71
32434: PUSH
32435: LD_VAR 0 2
32439: ARRAY
32440: NOT
32441: IFFALSE 32445
// continue ;
32443: GO 32427
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32445: LD_ADDR_VAR 0 5
32449: PUSH
32450: LD_EXP 50
32454: PUSH
32455: LD_VAR 0 2
32459: ARRAY
32460: PPUSH
32461: LD_INT 30
32463: PUSH
32464: LD_INT 3
32466: PUSH
32467: EMPTY
32468: LIST
32469: LIST
32470: PPUSH
32471: CALL_OW 72
32475: ST_TO_ADDR
// if not fac then
32476: LD_VAR 0 5
32480: NOT
32481: IFFALSE 32485
// continue ;
32483: GO 32427
// for j in fac do
32485: LD_ADDR_VAR 0 3
32489: PUSH
32490: LD_VAR 0 5
32494: PUSH
32495: FOR_IN
32496: IFFALSE 32851
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
32498: LD_VAR 0 3
32502: PPUSH
32503: CALL_OW 461
32507: PUSH
32508: LD_INT 2
32510: NONEQUAL
32511: PUSH
32512: LD_VAR 0 3
32516: PPUSH
32517: LD_INT 15
32519: PPUSH
32520: CALL 54924 0 2
32524: PUSH
32525: LD_INT 4
32527: ARRAY
32528: OR
32529: IFFALSE 32533
// continue ;
32531: GO 32495
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
32533: LD_VAR 0 3
32537: PPUSH
32538: LD_EXP 71
32542: PUSH
32543: LD_VAR 0 2
32547: ARRAY
32548: PUSH
32549: LD_INT 1
32551: ARRAY
32552: PUSH
32553: LD_INT 1
32555: ARRAY
32556: PPUSH
32557: LD_EXP 71
32561: PUSH
32562: LD_VAR 0 2
32566: ARRAY
32567: PUSH
32568: LD_INT 1
32570: ARRAY
32571: PUSH
32572: LD_INT 2
32574: ARRAY
32575: PPUSH
32576: LD_EXP 71
32580: PUSH
32581: LD_VAR 0 2
32585: ARRAY
32586: PUSH
32587: LD_INT 1
32589: ARRAY
32590: PUSH
32591: LD_INT 3
32593: ARRAY
32594: PPUSH
32595: LD_EXP 71
32599: PUSH
32600: LD_VAR 0 2
32604: ARRAY
32605: PUSH
32606: LD_INT 1
32608: ARRAY
32609: PUSH
32610: LD_INT 4
32612: ARRAY
32613: PPUSH
32614: CALL_OW 448
32618: PUSH
32619: LD_VAR 0 3
32623: PPUSH
32624: LD_EXP 71
32628: PUSH
32629: LD_VAR 0 2
32633: ARRAY
32634: PUSH
32635: LD_INT 1
32637: ARRAY
32638: PUSH
32639: LD_INT 1
32641: ARRAY
32642: PUSH
32643: LD_EXP 71
32647: PUSH
32648: LD_VAR 0 2
32652: ARRAY
32653: PUSH
32654: LD_INT 1
32656: ARRAY
32657: PUSH
32658: LD_INT 2
32660: ARRAY
32661: PUSH
32662: LD_EXP 71
32666: PUSH
32667: LD_VAR 0 2
32671: ARRAY
32672: PUSH
32673: LD_INT 1
32675: ARRAY
32676: PUSH
32677: LD_INT 3
32679: ARRAY
32680: PUSH
32681: LD_EXP 71
32685: PUSH
32686: LD_VAR 0 2
32690: ARRAY
32691: PUSH
32692: LD_INT 1
32694: ARRAY
32695: PUSH
32696: LD_INT 4
32698: ARRAY
32699: PUSH
32700: EMPTY
32701: LIST
32702: LIST
32703: LIST
32704: LIST
32705: PPUSH
32706: CALL 58595 0 2
32710: AND
32711: IFFALSE 32849
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
32713: LD_VAR 0 3
32717: PPUSH
32718: LD_EXP 71
32722: PUSH
32723: LD_VAR 0 2
32727: ARRAY
32728: PUSH
32729: LD_INT 1
32731: ARRAY
32732: PUSH
32733: LD_INT 1
32735: ARRAY
32736: PPUSH
32737: LD_EXP 71
32741: PUSH
32742: LD_VAR 0 2
32746: ARRAY
32747: PUSH
32748: LD_INT 1
32750: ARRAY
32751: PUSH
32752: LD_INT 2
32754: ARRAY
32755: PPUSH
32756: LD_EXP 71
32760: PUSH
32761: LD_VAR 0 2
32765: ARRAY
32766: PUSH
32767: LD_INT 1
32769: ARRAY
32770: PUSH
32771: LD_INT 3
32773: ARRAY
32774: PPUSH
32775: LD_EXP 71
32779: PUSH
32780: LD_VAR 0 2
32784: ARRAY
32785: PUSH
32786: LD_INT 1
32788: ARRAY
32789: PUSH
32790: LD_INT 4
32792: ARRAY
32793: PPUSH
32794: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
32798: LD_ADDR_VAR 0 4
32802: PUSH
32803: LD_EXP 71
32807: PUSH
32808: LD_VAR 0 2
32812: ARRAY
32813: PPUSH
32814: LD_INT 1
32816: PPUSH
32817: CALL_OW 3
32821: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
32822: LD_ADDR_EXP 71
32826: PUSH
32827: LD_EXP 71
32831: PPUSH
32832: LD_VAR 0 2
32836: PPUSH
32837: LD_VAR 0 4
32841: PPUSH
32842: CALL_OW 1
32846: ST_TO_ADDR
// break ;
32847: GO 32851
// end ; end ;
32849: GO 32495
32851: POP
32852: POP
// end ;
32853: GO 32427
32855: POP
32856: POP
// end ;
32857: LD_VAR 0 1
32861: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
32862: LD_INT 0
32864: PPUSH
32865: PPUSH
32866: PPUSH
// if not mc_bases then
32867: LD_EXP 50
32871: NOT
32872: IFFALSE 32876
// exit ;
32874: GO 32965
// for i = 1 to mc_bases do
32876: LD_ADDR_VAR 0 2
32880: PUSH
32881: DOUBLE
32882: LD_INT 1
32884: DEC
32885: ST_TO_ADDR
32886: LD_EXP 50
32890: PUSH
32891: FOR_TO
32892: IFFALSE 32963
// begin if mc_attack [ i ] then
32894: LD_EXP 70
32898: PUSH
32899: LD_VAR 0 2
32903: ARRAY
32904: IFFALSE 32961
// begin tmp := mc_attack [ i ] [ 1 ] ;
32906: LD_ADDR_VAR 0 3
32910: PUSH
32911: LD_EXP 70
32915: PUSH
32916: LD_VAR 0 2
32920: ARRAY
32921: PUSH
32922: LD_INT 1
32924: ARRAY
32925: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
32926: LD_ADDR_EXP 70
32930: PUSH
32931: LD_EXP 70
32935: PPUSH
32936: LD_VAR 0 2
32940: PPUSH
32941: EMPTY
32942: PPUSH
32943: CALL_OW 1
32947: ST_TO_ADDR
// Attack ( tmp ) ;
32948: LD_VAR 0 3
32952: PPUSH
32953: CALL 101497 0 1
// exit ;
32957: POP
32958: POP
32959: GO 32965
// end ; end ;
32961: GO 32891
32963: POP
32964: POP
// end ;
32965: LD_VAR 0 1
32969: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
32970: LD_INT 0
32972: PPUSH
32973: PPUSH
32974: PPUSH
32975: PPUSH
32976: PPUSH
32977: PPUSH
32978: PPUSH
// if not mc_bases then
32979: LD_EXP 50
32983: NOT
32984: IFFALSE 32988
// exit ;
32986: GO 33570
// for i = 1 to mc_bases do
32988: LD_ADDR_VAR 0 2
32992: PUSH
32993: DOUBLE
32994: LD_INT 1
32996: DEC
32997: ST_TO_ADDR
32998: LD_EXP 50
33002: PUSH
33003: FOR_TO
33004: IFFALSE 33568
// begin if not mc_bases [ i ] then
33006: LD_EXP 50
33010: PUSH
33011: LD_VAR 0 2
33015: ARRAY
33016: NOT
33017: IFFALSE 33021
// continue ;
33019: GO 33003
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33021: LD_ADDR_VAR 0 7
33025: PUSH
33026: LD_EXP 50
33030: PUSH
33031: LD_VAR 0 2
33035: ARRAY
33036: PUSH
33037: LD_INT 1
33039: ARRAY
33040: PPUSH
33041: CALL 49167 0 1
33045: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33046: LD_ADDR_EXP 73
33050: PUSH
33051: LD_EXP 73
33055: PPUSH
33056: LD_VAR 0 2
33060: PPUSH
33061: LD_EXP 50
33065: PUSH
33066: LD_VAR 0 2
33070: ARRAY
33071: PUSH
33072: LD_INT 1
33074: ARRAY
33075: PPUSH
33076: CALL_OW 255
33080: PPUSH
33081: LD_EXP 75
33085: PUSH
33086: LD_VAR 0 2
33090: ARRAY
33091: PPUSH
33092: CALL 49132 0 2
33096: PPUSH
33097: CALL_OW 1
33101: ST_TO_ADDR
// if not mc_scan [ i ] then
33102: LD_EXP 73
33106: PUSH
33107: LD_VAR 0 2
33111: ARRAY
33112: NOT
33113: IFFALSE 33268
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33115: LD_ADDR_VAR 0 4
33119: PUSH
33120: LD_EXP 50
33124: PUSH
33125: LD_VAR 0 2
33129: ARRAY
33130: PPUSH
33131: LD_INT 2
33133: PUSH
33134: LD_INT 25
33136: PUSH
33137: LD_INT 5
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 25
33146: PUSH
33147: LD_INT 8
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: LD_INT 25
33156: PUSH
33157: LD_INT 9
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PUSH
33164: EMPTY
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: PPUSH
33170: CALL_OW 72
33174: ST_TO_ADDR
// if not tmp then
33175: LD_VAR 0 4
33179: NOT
33180: IFFALSE 33184
// continue ;
33182: GO 33003
// for j in tmp do
33184: LD_ADDR_VAR 0 3
33188: PUSH
33189: LD_VAR 0 4
33193: PUSH
33194: FOR_IN
33195: IFFALSE 33266
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33197: LD_VAR 0 3
33201: PPUSH
33202: CALL_OW 310
33206: PPUSH
33207: CALL_OW 266
33211: PUSH
33212: LD_INT 5
33214: EQUAL
33215: PUSH
33216: LD_VAR 0 3
33220: PPUSH
33221: CALL_OW 257
33225: PUSH
33226: LD_INT 1
33228: EQUAL
33229: AND
33230: PUSH
33231: LD_VAR 0 3
33235: PPUSH
33236: CALL_OW 459
33240: NOT
33241: AND
33242: PUSH
33243: LD_VAR 0 7
33247: AND
33248: IFFALSE 33264
// ComChangeProfession ( j , class ) ;
33250: LD_VAR 0 3
33254: PPUSH
33255: LD_VAR 0 7
33259: PPUSH
33260: CALL_OW 123
33264: GO 33194
33266: POP
33267: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33268: LD_EXP 73
33272: PUSH
33273: LD_VAR 0 2
33277: ARRAY
33278: PUSH
33279: LD_EXP 72
33283: PUSH
33284: LD_VAR 0 2
33288: ARRAY
33289: NOT
33290: AND
33291: PUSH
33292: LD_EXP 50
33296: PUSH
33297: LD_VAR 0 2
33301: ARRAY
33302: PPUSH
33303: LD_INT 30
33305: PUSH
33306: LD_INT 32
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: PPUSH
33313: CALL_OW 72
33317: NOT
33318: AND
33319: PUSH
33320: LD_EXP 50
33324: PUSH
33325: LD_VAR 0 2
33329: ARRAY
33330: PPUSH
33331: LD_INT 2
33333: PUSH
33334: LD_INT 30
33336: PUSH
33337: LD_INT 4
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: LD_INT 30
33346: PUSH
33347: LD_INT 5
33349: PUSH
33350: EMPTY
33351: LIST
33352: LIST
33353: PUSH
33354: EMPTY
33355: LIST
33356: LIST
33357: LIST
33358: PPUSH
33359: CALL_OW 72
33363: NOT
33364: AND
33365: IFFALSE 33497
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33367: LD_ADDR_VAR 0 4
33371: PUSH
33372: LD_EXP 50
33376: PUSH
33377: LD_VAR 0 2
33381: ARRAY
33382: PPUSH
33383: LD_INT 2
33385: PUSH
33386: LD_INT 25
33388: PUSH
33389: LD_INT 1
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 25
33398: PUSH
33399: LD_INT 5
33401: PUSH
33402: EMPTY
33403: LIST
33404: LIST
33405: PUSH
33406: LD_INT 25
33408: PUSH
33409: LD_INT 8
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 25
33418: PUSH
33419: LD_INT 9
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: PPUSH
33433: CALL_OW 72
33437: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33438: LD_ADDR_VAR 0 4
33442: PUSH
33443: LD_VAR 0 4
33447: PUSH
33448: LD_VAR 0 4
33452: PPUSH
33453: LD_INT 18
33455: PPUSH
33456: CALL 80892 0 2
33460: DIFF
33461: ST_TO_ADDR
// if tmp then
33462: LD_VAR 0 4
33466: IFFALSE 33497
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
33468: LD_VAR 0 2
33472: PPUSH
33473: LD_VAR 0 4
33477: PPUSH
33478: LD_EXP 75
33482: PUSH
33483: LD_VAR 0 2
33487: ARRAY
33488: PPUSH
33489: CALL 106206 0 3
// exit ;
33493: POP
33494: POP
33495: GO 33570
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
33497: LD_EXP 73
33501: PUSH
33502: LD_VAR 0 2
33506: ARRAY
33507: PUSH
33508: LD_EXP 72
33512: PUSH
33513: LD_VAR 0 2
33517: ARRAY
33518: AND
33519: IFFALSE 33566
// begin tmp := mc_defender [ i ] ;
33521: LD_ADDR_VAR 0 4
33525: PUSH
33526: LD_EXP 72
33530: PUSH
33531: LD_VAR 0 2
33535: ARRAY
33536: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
33537: LD_VAR 0 2
33541: PPUSH
33542: LD_VAR 0 4
33546: PPUSH
33547: LD_EXP 73
33551: PUSH
33552: LD_VAR 0 2
33556: ARRAY
33557: PPUSH
33558: CALL 106767 0 3
// exit ;
33562: POP
33563: POP
33564: GO 33570
// end ; end ;
33566: GO 33003
33568: POP
33569: POP
// end ;
33570: LD_VAR 0 1
33574: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
33575: LD_INT 0
33577: PPUSH
33578: PPUSH
33579: PPUSH
33580: PPUSH
33581: PPUSH
33582: PPUSH
33583: PPUSH
33584: PPUSH
33585: PPUSH
33586: PPUSH
33587: PPUSH
// if not mc_bases then
33588: LD_EXP 50
33592: NOT
33593: IFFALSE 33597
// exit ;
33595: GO 34684
// for i = 1 to mc_bases do
33597: LD_ADDR_VAR 0 2
33601: PUSH
33602: DOUBLE
33603: LD_INT 1
33605: DEC
33606: ST_TO_ADDR
33607: LD_EXP 50
33611: PUSH
33612: FOR_TO
33613: IFFALSE 34682
// begin tmp := mc_lab [ i ] ;
33615: LD_ADDR_VAR 0 6
33619: PUSH
33620: LD_EXP 83
33624: PUSH
33625: LD_VAR 0 2
33629: ARRAY
33630: ST_TO_ADDR
// if not tmp then
33631: LD_VAR 0 6
33635: NOT
33636: IFFALSE 33640
// continue ;
33638: GO 33612
// idle_lab := 0 ;
33640: LD_ADDR_VAR 0 11
33644: PUSH
33645: LD_INT 0
33647: ST_TO_ADDR
// for j in tmp do
33648: LD_ADDR_VAR 0 3
33652: PUSH
33653: LD_VAR 0 6
33657: PUSH
33658: FOR_IN
33659: IFFALSE 34678
// begin researching := false ;
33661: LD_ADDR_VAR 0 10
33665: PUSH
33666: LD_INT 0
33668: ST_TO_ADDR
// side := GetSide ( j ) ;
33669: LD_ADDR_VAR 0 4
33673: PUSH
33674: LD_VAR 0 3
33678: PPUSH
33679: CALL_OW 255
33683: ST_TO_ADDR
// if not mc_tech [ side ] then
33684: LD_EXP 77
33688: PUSH
33689: LD_VAR 0 4
33693: ARRAY
33694: NOT
33695: IFFALSE 33699
// continue ;
33697: GO 33658
// if BuildingStatus ( j ) = bs_idle then
33699: LD_VAR 0 3
33703: PPUSH
33704: CALL_OW 461
33708: PUSH
33709: LD_INT 2
33711: EQUAL
33712: IFFALSE 33900
// begin if idle_lab and UnitsInside ( j ) < 6 then
33714: LD_VAR 0 11
33718: PUSH
33719: LD_VAR 0 3
33723: PPUSH
33724: CALL_OW 313
33728: PUSH
33729: LD_INT 6
33731: LESS
33732: AND
33733: IFFALSE 33804
// begin tmp2 := UnitsInside ( idle_lab ) ;
33735: LD_ADDR_VAR 0 9
33739: PUSH
33740: LD_VAR 0 11
33744: PPUSH
33745: CALL_OW 313
33749: ST_TO_ADDR
// if tmp2 then
33750: LD_VAR 0 9
33754: IFFALSE 33796
// for x in tmp2 do
33756: LD_ADDR_VAR 0 7
33760: PUSH
33761: LD_VAR 0 9
33765: PUSH
33766: FOR_IN
33767: IFFALSE 33794
// begin ComExitBuilding ( x ) ;
33769: LD_VAR 0 7
33773: PPUSH
33774: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
33778: LD_VAR 0 7
33782: PPUSH
33783: LD_VAR 0 3
33787: PPUSH
33788: CALL_OW 180
// end ;
33792: GO 33766
33794: POP
33795: POP
// idle_lab := 0 ;
33796: LD_ADDR_VAR 0 11
33800: PUSH
33801: LD_INT 0
33803: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
33804: LD_ADDR_VAR 0 5
33808: PUSH
33809: LD_EXP 77
33813: PUSH
33814: LD_VAR 0 4
33818: ARRAY
33819: PUSH
33820: FOR_IN
33821: IFFALSE 33881
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
33823: LD_VAR 0 3
33827: PPUSH
33828: LD_VAR 0 5
33832: PPUSH
33833: CALL_OW 430
33837: PUSH
33838: LD_VAR 0 4
33842: PPUSH
33843: LD_VAR 0 5
33847: PPUSH
33848: CALL 48237 0 2
33852: AND
33853: IFFALSE 33879
// begin researching := true ;
33855: LD_ADDR_VAR 0 10
33859: PUSH
33860: LD_INT 1
33862: ST_TO_ADDR
// ComResearch ( j , t ) ;
33863: LD_VAR 0 3
33867: PPUSH
33868: LD_VAR 0 5
33872: PPUSH
33873: CALL_OW 124
// break ;
33877: GO 33881
// end ;
33879: GO 33820
33881: POP
33882: POP
// if not researching then
33883: LD_VAR 0 10
33887: NOT
33888: IFFALSE 33900
// idle_lab := j ;
33890: LD_ADDR_VAR 0 11
33894: PUSH
33895: LD_VAR 0 3
33899: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
33900: LD_VAR 0 3
33904: PPUSH
33905: CALL_OW 461
33909: PUSH
33910: LD_INT 10
33912: EQUAL
33913: IFFALSE 34501
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
33915: LD_EXP 79
33919: PUSH
33920: LD_VAR 0 2
33924: ARRAY
33925: NOT
33926: PUSH
33927: LD_EXP 80
33931: PUSH
33932: LD_VAR 0 2
33936: ARRAY
33937: NOT
33938: AND
33939: PUSH
33940: LD_EXP 77
33944: PUSH
33945: LD_VAR 0 4
33949: ARRAY
33950: PUSH
33951: LD_INT 1
33953: GREATER
33954: AND
33955: IFFALSE 34086
// begin ComCancel ( j ) ;
33957: LD_VAR 0 3
33961: PPUSH
33962: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
33966: LD_ADDR_EXP 77
33970: PUSH
33971: LD_EXP 77
33975: PPUSH
33976: LD_VAR 0 4
33980: PPUSH
33981: LD_EXP 77
33985: PUSH
33986: LD_VAR 0 4
33990: ARRAY
33991: PPUSH
33992: LD_EXP 77
33996: PUSH
33997: LD_VAR 0 4
34001: ARRAY
34002: PUSH
34003: LD_INT 1
34005: MINUS
34006: PPUSH
34007: LD_EXP 77
34011: PUSH
34012: LD_VAR 0 4
34016: ARRAY
34017: PPUSH
34018: LD_INT 0
34020: PPUSH
34021: CALL 51749 0 4
34025: PPUSH
34026: CALL_OW 1
34030: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
34031: LD_ADDR_EXP 77
34035: PUSH
34036: LD_EXP 77
34040: PPUSH
34041: LD_VAR 0 4
34045: PPUSH
34046: LD_EXP 77
34050: PUSH
34051: LD_VAR 0 4
34055: ARRAY
34056: PPUSH
34057: LD_EXP 77
34061: PUSH
34062: LD_VAR 0 4
34066: ARRAY
34067: PPUSH
34068: LD_INT 1
34070: PPUSH
34071: LD_INT 0
34073: PPUSH
34074: CALL 51749 0 4
34078: PPUSH
34079: CALL_OW 1
34083: ST_TO_ADDR
// continue ;
34084: GO 33658
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
34086: LD_EXP 79
34090: PUSH
34091: LD_VAR 0 2
34095: ARRAY
34096: PUSH
34097: LD_EXP 80
34101: PUSH
34102: LD_VAR 0 2
34106: ARRAY
34107: NOT
34108: AND
34109: IFFALSE 34236
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
34111: LD_ADDR_EXP 80
34115: PUSH
34116: LD_EXP 80
34120: PPUSH
34121: LD_VAR 0 2
34125: PUSH
34126: LD_EXP 80
34130: PUSH
34131: LD_VAR 0 2
34135: ARRAY
34136: PUSH
34137: LD_INT 1
34139: PLUS
34140: PUSH
34141: EMPTY
34142: LIST
34143: LIST
34144: PPUSH
34145: LD_EXP 79
34149: PUSH
34150: LD_VAR 0 2
34154: ARRAY
34155: PUSH
34156: LD_INT 1
34158: ARRAY
34159: PPUSH
34160: CALL 52331 0 3
34164: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34165: LD_EXP 79
34169: PUSH
34170: LD_VAR 0 2
34174: ARRAY
34175: PUSH
34176: LD_INT 1
34178: ARRAY
34179: PPUSH
34180: LD_INT 112
34182: PPUSH
34183: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34187: LD_ADDR_VAR 0 9
34191: PUSH
34192: LD_EXP 79
34196: PUSH
34197: LD_VAR 0 2
34201: ARRAY
34202: PPUSH
34203: LD_INT 1
34205: PPUSH
34206: CALL_OW 3
34210: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34211: LD_ADDR_EXP 79
34215: PUSH
34216: LD_EXP 79
34220: PPUSH
34221: LD_VAR 0 2
34225: PPUSH
34226: LD_VAR 0 9
34230: PPUSH
34231: CALL_OW 1
34235: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34236: LD_EXP 79
34240: PUSH
34241: LD_VAR 0 2
34245: ARRAY
34246: PUSH
34247: LD_EXP 80
34251: PUSH
34252: LD_VAR 0 2
34256: ARRAY
34257: AND
34258: PUSH
34259: LD_EXP 80
34263: PUSH
34264: LD_VAR 0 2
34268: ARRAY
34269: PUSH
34270: LD_INT 1
34272: ARRAY
34273: PPUSH
34274: CALL_OW 310
34278: NOT
34279: AND
34280: PUSH
34281: LD_VAR 0 3
34285: PPUSH
34286: CALL_OW 313
34290: PUSH
34291: LD_INT 6
34293: EQUAL
34294: AND
34295: IFFALSE 34351
// begin tmp2 := UnitsInside ( j ) ;
34297: LD_ADDR_VAR 0 9
34301: PUSH
34302: LD_VAR 0 3
34306: PPUSH
34307: CALL_OW 313
34311: ST_TO_ADDR
// if tmp2 = 6 then
34312: LD_VAR 0 9
34316: PUSH
34317: LD_INT 6
34319: EQUAL
34320: IFFALSE 34351
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
34322: LD_VAR 0 9
34326: PUSH
34327: LD_INT 1
34329: ARRAY
34330: PPUSH
34331: LD_INT 112
34333: PPUSH
34334: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
34338: LD_VAR 0 9
34342: PUSH
34343: LD_INT 1
34345: ARRAY
34346: PPUSH
34347: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
34351: LD_EXP 80
34355: PUSH
34356: LD_VAR 0 2
34360: ARRAY
34361: PUSH
34362: LD_EXP 80
34366: PUSH
34367: LD_VAR 0 2
34371: ARRAY
34372: PUSH
34373: LD_INT 1
34375: ARRAY
34376: PPUSH
34377: CALL_OW 314
34381: NOT
34382: AND
34383: PUSH
34384: LD_EXP 80
34388: PUSH
34389: LD_VAR 0 2
34393: ARRAY
34394: PUSH
34395: LD_INT 1
34397: ARRAY
34398: PPUSH
34399: CALL_OW 310
34403: NOT
34404: AND
34405: IFFALSE 34431
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
34407: LD_EXP 80
34411: PUSH
34412: LD_VAR 0 2
34416: ARRAY
34417: PUSH
34418: LD_INT 1
34420: ARRAY
34421: PPUSH
34422: LD_VAR 0 3
34426: PPUSH
34427: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34431: LD_EXP 80
34435: PUSH
34436: LD_VAR 0 2
34440: ARRAY
34441: PUSH
34442: LD_INT 1
34444: ARRAY
34445: PPUSH
34446: CALL_OW 310
34450: PUSH
34451: LD_EXP 80
34455: PUSH
34456: LD_VAR 0 2
34460: ARRAY
34461: PUSH
34462: LD_INT 1
34464: ARRAY
34465: PPUSH
34466: CALL_OW 310
34470: PPUSH
34471: CALL_OW 461
34475: PUSH
34476: LD_INT 3
34478: NONEQUAL
34479: AND
34480: IFFALSE 34501
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
34482: LD_EXP 80
34486: PUSH
34487: LD_VAR 0 2
34491: ARRAY
34492: PUSH
34493: LD_INT 1
34495: ARRAY
34496: PPUSH
34497: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
34501: LD_VAR 0 3
34505: PPUSH
34506: CALL_OW 461
34510: PUSH
34511: LD_INT 6
34513: EQUAL
34514: PUSH
34515: LD_VAR 0 6
34519: PUSH
34520: LD_INT 1
34522: GREATER
34523: AND
34524: IFFALSE 34676
// begin sci := [ ] ;
34526: LD_ADDR_VAR 0 8
34530: PUSH
34531: EMPTY
34532: ST_TO_ADDR
// for x in ( tmp diff j ) do
34533: LD_ADDR_VAR 0 7
34537: PUSH
34538: LD_VAR 0 6
34542: PUSH
34543: LD_VAR 0 3
34547: DIFF
34548: PUSH
34549: FOR_IN
34550: IFFALSE 34602
// begin if sci = 6 then
34552: LD_VAR 0 8
34556: PUSH
34557: LD_INT 6
34559: EQUAL
34560: IFFALSE 34564
// break ;
34562: GO 34602
// if BuildingStatus ( x ) = bs_idle then
34564: LD_VAR 0 7
34568: PPUSH
34569: CALL_OW 461
34573: PUSH
34574: LD_INT 2
34576: EQUAL
34577: IFFALSE 34600
// sci := sci ^ UnitsInside ( x ) ;
34579: LD_ADDR_VAR 0 8
34583: PUSH
34584: LD_VAR 0 8
34588: PUSH
34589: LD_VAR 0 7
34593: PPUSH
34594: CALL_OW 313
34598: ADD
34599: ST_TO_ADDR
// end ;
34600: GO 34549
34602: POP
34603: POP
// if not sci then
34604: LD_VAR 0 8
34608: NOT
34609: IFFALSE 34613
// continue ;
34611: GO 33658
// for x in sci do
34613: LD_ADDR_VAR 0 7
34617: PUSH
34618: LD_VAR 0 8
34622: PUSH
34623: FOR_IN
34624: IFFALSE 34674
// if IsInUnit ( x ) and not HasTask ( x ) then
34626: LD_VAR 0 7
34630: PPUSH
34631: CALL_OW 310
34635: PUSH
34636: LD_VAR 0 7
34640: PPUSH
34641: CALL_OW 314
34645: NOT
34646: AND
34647: IFFALSE 34672
// begin ComExitBuilding ( x ) ;
34649: LD_VAR 0 7
34653: PPUSH
34654: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34658: LD_VAR 0 7
34662: PPUSH
34663: LD_VAR 0 3
34667: PPUSH
34668: CALL_OW 180
// end ;
34672: GO 34623
34674: POP
34675: POP
// end ; end ;
34676: GO 33658
34678: POP
34679: POP
// end ;
34680: GO 33612
34682: POP
34683: POP
// end ;
34684: LD_VAR 0 1
34688: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
34689: LD_INT 0
34691: PPUSH
34692: PPUSH
// if not mc_bases then
34693: LD_EXP 50
34697: NOT
34698: IFFALSE 34702
// exit ;
34700: GO 34783
// for i = 1 to mc_bases do
34702: LD_ADDR_VAR 0 2
34706: PUSH
34707: DOUBLE
34708: LD_INT 1
34710: DEC
34711: ST_TO_ADDR
34712: LD_EXP 50
34716: PUSH
34717: FOR_TO
34718: IFFALSE 34781
// if mc_mines [ i ] and mc_miners [ i ] then
34720: LD_EXP 63
34724: PUSH
34725: LD_VAR 0 2
34729: ARRAY
34730: PUSH
34731: LD_EXP 64
34735: PUSH
34736: LD_VAR 0 2
34740: ARRAY
34741: AND
34742: IFFALSE 34779
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
34744: LD_EXP 64
34748: PUSH
34749: LD_VAR 0 2
34753: ARRAY
34754: PUSH
34755: LD_INT 1
34757: ARRAY
34758: PPUSH
34759: CALL_OW 255
34763: PPUSH
34764: LD_EXP 63
34768: PUSH
34769: LD_VAR 0 2
34773: ARRAY
34774: PPUSH
34775: CALL 49320 0 2
34779: GO 34717
34781: POP
34782: POP
// end ;
34783: LD_VAR 0 1
34787: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
34788: LD_INT 0
34790: PPUSH
34791: PPUSH
34792: PPUSH
34793: PPUSH
34794: PPUSH
34795: PPUSH
34796: PPUSH
34797: PPUSH
// if not mc_bases or not mc_parking then
34798: LD_EXP 50
34802: NOT
34803: PUSH
34804: LD_EXP 74
34808: NOT
34809: OR
34810: IFFALSE 34814
// exit ;
34812: GO 35513
// for i = 1 to mc_bases do
34814: LD_ADDR_VAR 0 2
34818: PUSH
34819: DOUBLE
34820: LD_INT 1
34822: DEC
34823: ST_TO_ADDR
34824: LD_EXP 50
34828: PUSH
34829: FOR_TO
34830: IFFALSE 35511
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
34832: LD_EXP 50
34836: PUSH
34837: LD_VAR 0 2
34841: ARRAY
34842: NOT
34843: PUSH
34844: LD_EXP 74
34848: PUSH
34849: LD_VAR 0 2
34853: ARRAY
34854: NOT
34855: OR
34856: IFFALSE 34860
// continue ;
34858: GO 34829
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34860: LD_ADDR_VAR 0 5
34864: PUSH
34865: LD_EXP 50
34869: PUSH
34870: LD_VAR 0 2
34874: ARRAY
34875: PUSH
34876: LD_INT 1
34878: ARRAY
34879: PPUSH
34880: CALL_OW 255
34884: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34885: LD_ADDR_VAR 0 6
34889: PUSH
34890: LD_EXP 50
34894: PUSH
34895: LD_VAR 0 2
34899: ARRAY
34900: PPUSH
34901: LD_INT 30
34903: PUSH
34904: LD_INT 3
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PPUSH
34911: CALL_OW 72
34915: ST_TO_ADDR
// if not fac then
34916: LD_VAR 0 6
34920: NOT
34921: IFFALSE 34972
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34923: LD_ADDR_VAR 0 6
34927: PUSH
34928: LD_EXP 50
34932: PUSH
34933: LD_VAR 0 2
34937: ARRAY
34938: PPUSH
34939: LD_INT 2
34941: PUSH
34942: LD_INT 30
34944: PUSH
34945: LD_INT 0
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 30
34954: PUSH
34955: LD_INT 1
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: LIST
34966: PPUSH
34967: CALL_OW 72
34971: ST_TO_ADDR
// if not fac then
34972: LD_VAR 0 6
34976: NOT
34977: IFFALSE 34981
// continue ;
34979: GO 34829
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34981: LD_ADDR_VAR 0 7
34985: PUSH
34986: LD_EXP 74
34990: PUSH
34991: LD_VAR 0 2
34995: ARRAY
34996: PPUSH
34997: LD_INT 22
34999: PUSH
35000: LD_VAR 0 5
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 21
35011: PUSH
35012: LD_INT 2
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 3
35021: PUSH
35022: LD_INT 24
35024: PUSH
35025: LD_INT 1000
35027: PUSH
35028: EMPTY
35029: LIST
35030: LIST
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: LIST
35040: PPUSH
35041: CALL_OW 70
35045: ST_TO_ADDR
// for j in fac do
35046: LD_ADDR_VAR 0 3
35050: PUSH
35051: LD_VAR 0 6
35055: PUSH
35056: FOR_IN
35057: IFFALSE 35138
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35059: LD_ADDR_VAR 0 7
35063: PUSH
35064: LD_VAR 0 7
35068: PUSH
35069: LD_INT 22
35071: PUSH
35072: LD_VAR 0 5
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 91
35083: PUSH
35084: LD_VAR 0 3
35088: PUSH
35089: LD_INT 15
35091: PUSH
35092: EMPTY
35093: LIST
35094: LIST
35095: LIST
35096: PUSH
35097: LD_INT 21
35099: PUSH
35100: LD_INT 2
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 3
35109: PUSH
35110: LD_INT 24
35112: PUSH
35113: LD_INT 1000
35115: PUSH
35116: EMPTY
35117: LIST
35118: LIST
35119: PUSH
35120: EMPTY
35121: LIST
35122: LIST
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: PPUSH
35130: CALL_OW 69
35134: UNION
35135: ST_TO_ADDR
35136: GO 35056
35138: POP
35139: POP
// if not vehs then
35140: LD_VAR 0 7
35144: NOT
35145: IFFALSE 35171
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35147: LD_ADDR_EXP 62
35151: PUSH
35152: LD_EXP 62
35156: PPUSH
35157: LD_VAR 0 2
35161: PPUSH
35162: EMPTY
35163: PPUSH
35164: CALL_OW 1
35168: ST_TO_ADDR
// continue ;
35169: GO 34829
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35171: LD_ADDR_VAR 0 8
35175: PUSH
35176: LD_EXP 50
35180: PUSH
35181: LD_VAR 0 2
35185: ARRAY
35186: PPUSH
35187: LD_INT 30
35189: PUSH
35190: LD_INT 3
35192: PUSH
35193: EMPTY
35194: LIST
35195: LIST
35196: PPUSH
35197: CALL_OW 72
35201: ST_TO_ADDR
// if tmp then
35202: LD_VAR 0 8
35206: IFFALSE 35309
// begin for j in tmp do
35208: LD_ADDR_VAR 0 3
35212: PUSH
35213: LD_VAR 0 8
35217: PUSH
35218: FOR_IN
35219: IFFALSE 35307
// for k in UnitsInside ( j ) do
35221: LD_ADDR_VAR 0 4
35225: PUSH
35226: LD_VAR 0 3
35230: PPUSH
35231: CALL_OW 313
35235: PUSH
35236: FOR_IN
35237: IFFALSE 35303
// if k then
35239: LD_VAR 0 4
35243: IFFALSE 35301
// if not k in mc_repair_vehicle [ i ] then
35245: LD_VAR 0 4
35249: PUSH
35250: LD_EXP 62
35254: PUSH
35255: LD_VAR 0 2
35259: ARRAY
35260: IN
35261: NOT
35262: IFFALSE 35301
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35264: LD_ADDR_EXP 62
35268: PUSH
35269: LD_EXP 62
35273: PPUSH
35274: LD_VAR 0 2
35278: PPUSH
35279: LD_EXP 62
35283: PUSH
35284: LD_VAR 0 2
35288: ARRAY
35289: PUSH
35290: LD_VAR 0 4
35294: UNION
35295: PPUSH
35296: CALL_OW 1
35300: ST_TO_ADDR
35301: GO 35236
35303: POP
35304: POP
35305: GO 35218
35307: POP
35308: POP
// end ; if not mc_repair_vehicle [ i ] then
35309: LD_EXP 62
35313: PUSH
35314: LD_VAR 0 2
35318: ARRAY
35319: NOT
35320: IFFALSE 35324
// continue ;
35322: GO 34829
// for j in mc_repair_vehicle [ i ] do
35324: LD_ADDR_VAR 0 3
35328: PUSH
35329: LD_EXP 62
35333: PUSH
35334: LD_VAR 0 2
35338: ARRAY
35339: PUSH
35340: FOR_IN
35341: IFFALSE 35507
// begin if GetClass ( j ) <> 3 then
35343: LD_VAR 0 3
35347: PPUSH
35348: CALL_OW 257
35352: PUSH
35353: LD_INT 3
35355: NONEQUAL
35356: IFFALSE 35397
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
35358: LD_ADDR_EXP 62
35362: PUSH
35363: LD_EXP 62
35367: PPUSH
35368: LD_VAR 0 2
35372: PPUSH
35373: LD_EXP 62
35377: PUSH
35378: LD_VAR 0 2
35382: ARRAY
35383: PUSH
35384: LD_VAR 0 3
35388: DIFF
35389: PPUSH
35390: CALL_OW 1
35394: ST_TO_ADDR
// continue ;
35395: GO 35340
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
35397: LD_VAR 0 3
35401: PPUSH
35402: CALL_OW 311
35406: NOT
35407: PUSH
35408: LD_VAR 0 3
35412: PUSH
35413: LD_EXP 53
35417: PUSH
35418: LD_VAR 0 2
35422: ARRAY
35423: PUSH
35424: LD_INT 1
35426: ARRAY
35427: IN
35428: NOT
35429: AND
35430: PUSH
35431: LD_VAR 0 3
35435: PUSH
35436: LD_EXP 53
35440: PUSH
35441: LD_VAR 0 2
35445: ARRAY
35446: PUSH
35447: LD_INT 2
35449: ARRAY
35450: IN
35451: NOT
35452: AND
35453: IFFALSE 35505
// begin if IsInUnit ( j ) then
35455: LD_VAR 0 3
35459: PPUSH
35460: CALL_OW 310
35464: IFFALSE 35475
// ComExitBuilding ( j ) ;
35466: LD_VAR 0 3
35470: PPUSH
35471: CALL_OW 122
// if not HasTask ( j ) then
35475: LD_VAR 0 3
35479: PPUSH
35480: CALL_OW 314
35484: NOT
35485: IFFALSE 35505
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
35487: LD_VAR 0 3
35491: PPUSH
35492: LD_VAR 0 7
35496: PUSH
35497: LD_INT 1
35499: ARRAY
35500: PPUSH
35501: CALL_OW 189
// end ; end ;
35505: GO 35340
35507: POP
35508: POP
// end ;
35509: GO 34829
35511: POP
35512: POP
// end ;
35513: LD_VAR 0 1
35517: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
35518: LD_INT 0
35520: PPUSH
35521: PPUSH
35522: PPUSH
35523: PPUSH
35524: PPUSH
35525: PPUSH
35526: PPUSH
35527: PPUSH
35528: PPUSH
35529: PPUSH
35530: PPUSH
// if not mc_bases then
35531: LD_EXP 50
35535: NOT
35536: IFFALSE 35540
// exit ;
35538: GO 36342
// for i = 1 to mc_bases do
35540: LD_ADDR_VAR 0 2
35544: PUSH
35545: DOUBLE
35546: LD_INT 1
35548: DEC
35549: ST_TO_ADDR
35550: LD_EXP 50
35554: PUSH
35555: FOR_TO
35556: IFFALSE 36340
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
35558: LD_EXP 78
35562: PUSH
35563: LD_VAR 0 2
35567: ARRAY
35568: NOT
35569: PUSH
35570: LD_EXP 53
35574: PUSH
35575: LD_VAR 0 2
35579: ARRAY
35580: PUSH
35581: LD_INT 1
35583: ARRAY
35584: OR
35585: PUSH
35586: LD_EXP 53
35590: PUSH
35591: LD_VAR 0 2
35595: ARRAY
35596: PUSH
35597: LD_INT 2
35599: ARRAY
35600: OR
35601: PUSH
35602: LD_EXP 76
35606: PUSH
35607: LD_VAR 0 2
35611: ARRAY
35612: PPUSH
35613: LD_INT 1
35615: PPUSH
35616: CALL_OW 325
35620: NOT
35621: OR
35622: PUSH
35623: LD_EXP 73
35627: PUSH
35628: LD_VAR 0 2
35632: ARRAY
35633: OR
35634: IFFALSE 35638
// continue ;
35636: GO 35555
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
35638: LD_ADDR_VAR 0 8
35642: PUSH
35643: LD_EXP 50
35647: PUSH
35648: LD_VAR 0 2
35652: ARRAY
35653: PPUSH
35654: LD_INT 25
35656: PUSH
35657: LD_INT 4
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 50
35666: PUSH
35667: EMPTY
35668: LIST
35669: PUSH
35670: LD_INT 3
35672: PUSH
35673: LD_INT 60
35675: PUSH
35676: EMPTY
35677: LIST
35678: PUSH
35679: EMPTY
35680: LIST
35681: LIST
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: LIST
35687: PPUSH
35688: CALL_OW 72
35692: PUSH
35693: LD_EXP 54
35697: PUSH
35698: LD_VAR 0 2
35702: ARRAY
35703: DIFF
35704: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35705: LD_ADDR_VAR 0 9
35709: PUSH
35710: LD_EXP 50
35714: PUSH
35715: LD_VAR 0 2
35719: ARRAY
35720: PPUSH
35721: LD_INT 2
35723: PUSH
35724: LD_INT 30
35726: PUSH
35727: LD_INT 0
35729: PUSH
35730: EMPTY
35731: LIST
35732: LIST
35733: PUSH
35734: LD_INT 30
35736: PUSH
35737: LD_INT 1
35739: PUSH
35740: EMPTY
35741: LIST
35742: LIST
35743: PUSH
35744: EMPTY
35745: LIST
35746: LIST
35747: LIST
35748: PPUSH
35749: CALL_OW 72
35753: ST_TO_ADDR
// if not tmp or not dep then
35754: LD_VAR 0 8
35758: NOT
35759: PUSH
35760: LD_VAR 0 9
35764: NOT
35765: OR
35766: IFFALSE 35770
// continue ;
35768: GO 35555
// side := GetSide ( tmp [ 1 ] ) ;
35770: LD_ADDR_VAR 0 11
35774: PUSH
35775: LD_VAR 0 8
35779: PUSH
35780: LD_INT 1
35782: ARRAY
35783: PPUSH
35784: CALL_OW 255
35788: ST_TO_ADDR
// dep := dep [ 1 ] ;
35789: LD_ADDR_VAR 0 9
35793: PUSH
35794: LD_VAR 0 9
35798: PUSH
35799: LD_INT 1
35801: ARRAY
35802: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
35803: LD_ADDR_VAR 0 7
35807: PUSH
35808: LD_EXP 78
35812: PUSH
35813: LD_VAR 0 2
35817: ARRAY
35818: PPUSH
35819: LD_INT 22
35821: PUSH
35822: LD_INT 0
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 25
35831: PUSH
35832: LD_INT 12
35834: PUSH
35835: EMPTY
35836: LIST
35837: LIST
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: PPUSH
35843: CALL_OW 70
35847: PUSH
35848: LD_INT 22
35850: PUSH
35851: LD_INT 0
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: PUSH
35858: LD_INT 25
35860: PUSH
35861: LD_INT 12
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: PUSH
35868: LD_INT 91
35870: PUSH
35871: LD_VAR 0 9
35875: PUSH
35876: LD_INT 20
35878: PUSH
35879: EMPTY
35880: LIST
35881: LIST
35882: LIST
35883: PUSH
35884: EMPTY
35885: LIST
35886: LIST
35887: LIST
35888: PPUSH
35889: CALL_OW 69
35893: UNION
35894: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
35895: LD_ADDR_VAR 0 10
35899: PUSH
35900: LD_EXP 78
35904: PUSH
35905: LD_VAR 0 2
35909: ARRAY
35910: PPUSH
35911: LD_INT 81
35913: PUSH
35914: LD_VAR 0 11
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PPUSH
35923: CALL_OW 70
35927: ST_TO_ADDR
// if not apes or danger_at_area then
35928: LD_VAR 0 7
35932: NOT
35933: PUSH
35934: LD_VAR 0 10
35938: OR
35939: IFFALSE 35989
// begin if mc_taming [ i ] then
35941: LD_EXP 81
35945: PUSH
35946: LD_VAR 0 2
35950: ARRAY
35951: IFFALSE 35987
// begin MC_Reset ( i , 121 ) ;
35953: LD_VAR 0 2
35957: PPUSH
35958: LD_INT 121
35960: PPUSH
35961: CALL 21440 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
35965: LD_ADDR_EXP 81
35969: PUSH
35970: LD_EXP 81
35974: PPUSH
35975: LD_VAR 0 2
35979: PPUSH
35980: EMPTY
35981: PPUSH
35982: CALL_OW 1
35986: ST_TO_ADDR
// end ; continue ;
35987: GO 35555
// end ; for j in tmp do
35989: LD_ADDR_VAR 0 3
35993: PUSH
35994: LD_VAR 0 8
35998: PUSH
35999: FOR_IN
36000: IFFALSE 36336
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
36002: LD_VAR 0 3
36006: PUSH
36007: LD_EXP 81
36011: PUSH
36012: LD_VAR 0 2
36016: ARRAY
36017: IN
36018: NOT
36019: PUSH
36020: LD_EXP 81
36024: PUSH
36025: LD_VAR 0 2
36029: ARRAY
36030: PUSH
36031: LD_INT 3
36033: LESS
36034: AND
36035: IFFALSE 36093
// begin SetTag ( j , 121 ) ;
36037: LD_VAR 0 3
36041: PPUSH
36042: LD_INT 121
36044: PPUSH
36045: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
36049: LD_ADDR_EXP 81
36053: PUSH
36054: LD_EXP 81
36058: PPUSH
36059: LD_VAR 0 2
36063: PUSH
36064: LD_EXP 81
36068: PUSH
36069: LD_VAR 0 2
36073: ARRAY
36074: PUSH
36075: LD_INT 1
36077: PLUS
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PPUSH
36083: LD_VAR 0 3
36087: PPUSH
36088: CALL 52331 0 3
36092: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
36093: LD_VAR 0 3
36097: PUSH
36098: LD_EXP 81
36102: PUSH
36103: LD_VAR 0 2
36107: ARRAY
36108: IN
36109: IFFALSE 36334
// begin if GetClass ( j ) <> 4 then
36111: LD_VAR 0 3
36115: PPUSH
36116: CALL_OW 257
36120: PUSH
36121: LD_INT 4
36123: NONEQUAL
36124: IFFALSE 36177
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
36126: LD_ADDR_EXP 81
36130: PUSH
36131: LD_EXP 81
36135: PPUSH
36136: LD_VAR 0 2
36140: PPUSH
36141: LD_EXP 81
36145: PUSH
36146: LD_VAR 0 2
36150: ARRAY
36151: PUSH
36152: LD_VAR 0 3
36156: DIFF
36157: PPUSH
36158: CALL_OW 1
36162: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36163: LD_VAR 0 3
36167: PPUSH
36168: LD_INT 0
36170: PPUSH
36171: CALL_OW 109
// continue ;
36175: GO 35999
// end ; if IsInUnit ( j ) then
36177: LD_VAR 0 3
36181: PPUSH
36182: CALL_OW 310
36186: IFFALSE 36197
// ComExitBuilding ( j ) ;
36188: LD_VAR 0 3
36192: PPUSH
36193: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36197: LD_ADDR_VAR 0 6
36201: PUSH
36202: LD_VAR 0 7
36206: PPUSH
36207: LD_VAR 0 3
36211: PPUSH
36212: CALL_OW 74
36216: ST_TO_ADDR
// if not ape then
36217: LD_VAR 0 6
36221: NOT
36222: IFFALSE 36226
// break ;
36224: GO 36336
// x := GetX ( ape ) ;
36226: LD_ADDR_VAR 0 4
36230: PUSH
36231: LD_VAR 0 6
36235: PPUSH
36236: CALL_OW 250
36240: ST_TO_ADDR
// y := GetY ( ape ) ;
36241: LD_ADDR_VAR 0 5
36245: PUSH
36246: LD_VAR 0 6
36250: PPUSH
36251: CALL_OW 251
36255: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36256: LD_VAR 0 4
36260: PPUSH
36261: LD_VAR 0 5
36265: PPUSH
36266: CALL_OW 488
36270: NOT
36271: PUSH
36272: LD_VAR 0 11
36276: PPUSH
36277: LD_VAR 0 4
36281: PPUSH
36282: LD_VAR 0 5
36286: PPUSH
36287: LD_INT 20
36289: PPUSH
36290: CALL 53227 0 4
36294: PUSH
36295: LD_INT 4
36297: ARRAY
36298: OR
36299: IFFALSE 36303
// break ;
36301: GO 36336
// if not HasTask ( j ) then
36303: LD_VAR 0 3
36307: PPUSH
36308: CALL_OW 314
36312: NOT
36313: IFFALSE 36334
// ComTameXY ( j , x , y ) ;
36315: LD_VAR 0 3
36319: PPUSH
36320: LD_VAR 0 4
36324: PPUSH
36325: LD_VAR 0 5
36329: PPUSH
36330: CALL_OW 131
// end ; end ;
36334: GO 35999
36336: POP
36337: POP
// end ;
36338: GO 35555
36340: POP
36341: POP
// end ;
36342: LD_VAR 0 1
36346: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
36347: LD_INT 0
36349: PPUSH
36350: PPUSH
36351: PPUSH
36352: PPUSH
36353: PPUSH
36354: PPUSH
36355: PPUSH
36356: PPUSH
// if not mc_bases then
36357: LD_EXP 50
36361: NOT
36362: IFFALSE 36366
// exit ;
36364: GO 36992
// for i = 1 to mc_bases do
36366: LD_ADDR_VAR 0 2
36370: PUSH
36371: DOUBLE
36372: LD_INT 1
36374: DEC
36375: ST_TO_ADDR
36376: LD_EXP 50
36380: PUSH
36381: FOR_TO
36382: IFFALSE 36990
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
36384: LD_EXP 79
36388: PUSH
36389: LD_VAR 0 2
36393: ARRAY
36394: NOT
36395: PUSH
36396: LD_EXP 79
36400: PUSH
36401: LD_VAR 0 2
36405: ARRAY
36406: PPUSH
36407: LD_INT 25
36409: PUSH
36410: LD_INT 12
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PPUSH
36417: CALL_OW 72
36421: NOT
36422: OR
36423: IFFALSE 36427
// continue ;
36425: GO 36381
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36427: LD_ADDR_VAR 0 5
36431: PUSH
36432: LD_EXP 79
36436: PUSH
36437: LD_VAR 0 2
36441: ARRAY
36442: PUSH
36443: LD_INT 1
36445: ARRAY
36446: PPUSH
36447: CALL_OW 255
36451: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
36452: LD_VAR 0 5
36456: PPUSH
36457: LD_INT 2
36459: PPUSH
36460: CALL_OW 325
36464: IFFALSE 36717
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36466: LD_ADDR_VAR 0 4
36470: PUSH
36471: LD_EXP 79
36475: PUSH
36476: LD_VAR 0 2
36480: ARRAY
36481: PPUSH
36482: LD_INT 25
36484: PUSH
36485: LD_INT 16
36487: PUSH
36488: EMPTY
36489: LIST
36490: LIST
36491: PPUSH
36492: CALL_OW 72
36496: ST_TO_ADDR
// if tmp < 6 then
36497: LD_VAR 0 4
36501: PUSH
36502: LD_INT 6
36504: LESS
36505: IFFALSE 36717
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36507: LD_ADDR_VAR 0 6
36511: PUSH
36512: LD_EXP 50
36516: PUSH
36517: LD_VAR 0 2
36521: ARRAY
36522: PPUSH
36523: LD_INT 2
36525: PUSH
36526: LD_INT 30
36528: PUSH
36529: LD_INT 0
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: LD_INT 30
36538: PUSH
36539: LD_INT 1
36541: PUSH
36542: EMPTY
36543: LIST
36544: LIST
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: LIST
36550: PPUSH
36551: CALL_OW 72
36555: ST_TO_ADDR
// if depot then
36556: LD_VAR 0 6
36560: IFFALSE 36717
// begin selected := 0 ;
36562: LD_ADDR_VAR 0 7
36566: PUSH
36567: LD_INT 0
36569: ST_TO_ADDR
// for j in depot do
36570: LD_ADDR_VAR 0 3
36574: PUSH
36575: LD_VAR 0 6
36579: PUSH
36580: FOR_IN
36581: IFFALSE 36612
// begin if UnitsInside ( j ) < 6 then
36583: LD_VAR 0 3
36587: PPUSH
36588: CALL_OW 313
36592: PUSH
36593: LD_INT 6
36595: LESS
36596: IFFALSE 36610
// begin selected := j ;
36598: LD_ADDR_VAR 0 7
36602: PUSH
36603: LD_VAR 0 3
36607: ST_TO_ADDR
// break ;
36608: GO 36612
// end ; end ;
36610: GO 36580
36612: POP
36613: POP
// if selected then
36614: LD_VAR 0 7
36618: IFFALSE 36717
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36620: LD_ADDR_VAR 0 3
36624: PUSH
36625: LD_EXP 79
36629: PUSH
36630: LD_VAR 0 2
36634: ARRAY
36635: PPUSH
36636: LD_INT 25
36638: PUSH
36639: LD_INT 12
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: PPUSH
36646: CALL_OW 72
36650: PUSH
36651: FOR_IN
36652: IFFALSE 36715
// if not HasTask ( j ) then
36654: LD_VAR 0 3
36658: PPUSH
36659: CALL_OW 314
36663: NOT
36664: IFFALSE 36713
// begin if not IsInUnit ( j ) then
36666: LD_VAR 0 3
36670: PPUSH
36671: CALL_OW 310
36675: NOT
36676: IFFALSE 36692
// ComEnterUnit ( j , selected ) ;
36678: LD_VAR 0 3
36682: PPUSH
36683: LD_VAR 0 7
36687: PPUSH
36688: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
36692: LD_VAR 0 3
36696: PPUSH
36697: LD_INT 16
36699: PPUSH
36700: CALL_OW 183
// AddComExitBuilding ( j ) ;
36704: LD_VAR 0 3
36708: PPUSH
36709: CALL_OW 182
// end ;
36713: GO 36651
36715: POP
36716: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
36717: LD_VAR 0 5
36721: PPUSH
36722: LD_INT 11
36724: PPUSH
36725: CALL_OW 325
36729: IFFALSE 36988
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36731: LD_ADDR_VAR 0 4
36735: PUSH
36736: LD_EXP 79
36740: PUSH
36741: LD_VAR 0 2
36745: ARRAY
36746: PPUSH
36747: LD_INT 25
36749: PUSH
36750: LD_INT 16
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PPUSH
36757: CALL_OW 72
36761: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
36762: LD_VAR 0 4
36766: PUSH
36767: LD_INT 6
36769: GREATEREQUAL
36770: PUSH
36771: LD_VAR 0 5
36775: PPUSH
36776: LD_INT 2
36778: PPUSH
36779: CALL_OW 325
36783: NOT
36784: OR
36785: IFFALSE 36988
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
36787: LD_ADDR_VAR 0 8
36791: PUSH
36792: LD_EXP 50
36796: PUSH
36797: LD_VAR 0 2
36801: ARRAY
36802: PPUSH
36803: LD_INT 2
36805: PUSH
36806: LD_INT 30
36808: PUSH
36809: LD_INT 4
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 30
36818: PUSH
36819: LD_INT 5
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: LIST
36830: PPUSH
36831: CALL_OW 72
36835: ST_TO_ADDR
// if barracks then
36836: LD_VAR 0 8
36840: IFFALSE 36988
// begin selected := 0 ;
36842: LD_ADDR_VAR 0 7
36846: PUSH
36847: LD_INT 0
36849: ST_TO_ADDR
// for j in barracks do
36850: LD_ADDR_VAR 0 3
36854: PUSH
36855: LD_VAR 0 8
36859: PUSH
36860: FOR_IN
36861: IFFALSE 36892
// begin if UnitsInside ( j ) < 6 then
36863: LD_VAR 0 3
36867: PPUSH
36868: CALL_OW 313
36872: PUSH
36873: LD_INT 6
36875: LESS
36876: IFFALSE 36890
// begin selected := j ;
36878: LD_ADDR_VAR 0 7
36882: PUSH
36883: LD_VAR 0 3
36887: ST_TO_ADDR
// break ;
36888: GO 36892
// end ; end ;
36890: GO 36860
36892: POP
36893: POP
// if selected then
36894: LD_VAR 0 7
36898: IFFALSE 36988
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36900: LD_ADDR_VAR 0 3
36904: PUSH
36905: LD_EXP 79
36909: PUSH
36910: LD_VAR 0 2
36914: ARRAY
36915: PPUSH
36916: LD_INT 25
36918: PUSH
36919: LD_INT 12
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PPUSH
36926: CALL_OW 72
36930: PUSH
36931: FOR_IN
36932: IFFALSE 36986
// if not IsInUnit ( j ) and not HasTask ( j ) then
36934: LD_VAR 0 3
36938: PPUSH
36939: CALL_OW 310
36943: NOT
36944: PUSH
36945: LD_VAR 0 3
36949: PPUSH
36950: CALL_OW 314
36954: NOT
36955: AND
36956: IFFALSE 36984
// begin ComEnterUnit ( j , selected ) ;
36958: LD_VAR 0 3
36962: PPUSH
36963: LD_VAR 0 7
36967: PPUSH
36968: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
36972: LD_VAR 0 3
36976: PPUSH
36977: LD_INT 15
36979: PPUSH
36980: CALL_OW 183
// end ;
36984: GO 36931
36986: POP
36987: POP
// end ; end ; end ; end ; end ;
36988: GO 36381
36990: POP
36991: POP
// end ;
36992: LD_VAR 0 1
36996: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
36997: LD_INT 0
36999: PPUSH
37000: PPUSH
37001: PPUSH
37002: PPUSH
// if not mc_bases then
37003: LD_EXP 50
37007: NOT
37008: IFFALSE 37012
// exit ;
37010: GO 37190
// for i = 1 to mc_bases do
37012: LD_ADDR_VAR 0 2
37016: PUSH
37017: DOUBLE
37018: LD_INT 1
37020: DEC
37021: ST_TO_ADDR
37022: LD_EXP 50
37026: PUSH
37027: FOR_TO
37028: IFFALSE 37188
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
37030: LD_ADDR_VAR 0 4
37034: PUSH
37035: LD_EXP 50
37039: PUSH
37040: LD_VAR 0 2
37044: ARRAY
37045: PPUSH
37046: LD_INT 25
37048: PUSH
37049: LD_INT 9
37051: PUSH
37052: EMPTY
37053: LIST
37054: LIST
37055: PPUSH
37056: CALL_OW 72
37060: ST_TO_ADDR
// if not tmp then
37061: LD_VAR 0 4
37065: NOT
37066: IFFALSE 37070
// continue ;
37068: GO 37027
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
37070: LD_EXP 76
37074: PUSH
37075: LD_VAR 0 2
37079: ARRAY
37080: PPUSH
37081: LD_INT 29
37083: PPUSH
37084: CALL_OW 325
37088: NOT
37089: PUSH
37090: LD_EXP 76
37094: PUSH
37095: LD_VAR 0 2
37099: ARRAY
37100: PPUSH
37101: LD_INT 28
37103: PPUSH
37104: CALL_OW 325
37108: NOT
37109: AND
37110: IFFALSE 37114
// continue ;
37112: GO 37027
// for j in tmp do
37114: LD_ADDR_VAR 0 3
37118: PUSH
37119: LD_VAR 0 4
37123: PUSH
37124: FOR_IN
37125: IFFALSE 37184
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37127: LD_VAR 0 3
37131: PUSH
37132: LD_EXP 53
37136: PUSH
37137: LD_VAR 0 2
37141: ARRAY
37142: PUSH
37143: LD_INT 1
37145: ARRAY
37146: IN
37147: NOT
37148: PUSH
37149: LD_VAR 0 3
37153: PUSH
37154: LD_EXP 53
37158: PUSH
37159: LD_VAR 0 2
37163: ARRAY
37164: PUSH
37165: LD_INT 2
37167: ARRAY
37168: IN
37169: NOT
37170: AND
37171: IFFALSE 37182
// ComSpaceTimeShoot ( j ) ;
37173: LD_VAR 0 3
37177: PPUSH
37178: CALL 48328 0 1
37182: GO 37124
37184: POP
37185: POP
// end ;
37186: GO 37027
37188: POP
37189: POP
// end ;
37190: LD_VAR 0 1
37194: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37195: LD_INT 0
37197: PPUSH
37198: PPUSH
37199: PPUSH
37200: PPUSH
37201: PPUSH
37202: PPUSH
37203: PPUSH
37204: PPUSH
37205: PPUSH
// if not mc_bases then
37206: LD_EXP 50
37210: NOT
37211: IFFALSE 37215
// exit ;
37213: GO 37837
// for i = 1 to mc_bases do
37215: LD_ADDR_VAR 0 2
37219: PUSH
37220: DOUBLE
37221: LD_INT 1
37223: DEC
37224: ST_TO_ADDR
37225: LD_EXP 50
37229: PUSH
37230: FOR_TO
37231: IFFALSE 37835
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37233: LD_EXP 85
37237: PUSH
37238: LD_VAR 0 2
37242: ARRAY
37243: NOT
37244: PUSH
37245: LD_INT 38
37247: PPUSH
37248: LD_EXP 76
37252: PUSH
37253: LD_VAR 0 2
37257: ARRAY
37258: PPUSH
37259: CALL_OW 321
37263: PUSH
37264: LD_INT 2
37266: NONEQUAL
37267: OR
37268: IFFALSE 37272
// continue ;
37270: GO 37230
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37272: LD_ADDR_VAR 0 8
37276: PUSH
37277: LD_EXP 50
37281: PUSH
37282: LD_VAR 0 2
37286: ARRAY
37287: PPUSH
37288: LD_INT 30
37290: PUSH
37291: LD_INT 34
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PPUSH
37298: CALL_OW 72
37302: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
37303: LD_ADDR_VAR 0 9
37307: PUSH
37308: LD_EXP 50
37312: PUSH
37313: LD_VAR 0 2
37317: ARRAY
37318: PPUSH
37319: LD_INT 25
37321: PUSH
37322: LD_INT 4
37324: PUSH
37325: EMPTY
37326: LIST
37327: LIST
37328: PPUSH
37329: CALL_OW 72
37333: PPUSH
37334: LD_INT 0
37336: PPUSH
37337: CALL 80892 0 2
37341: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
37342: LD_VAR 0 9
37346: NOT
37347: PUSH
37348: LD_VAR 0 8
37352: NOT
37353: OR
37354: PUSH
37355: LD_EXP 50
37359: PUSH
37360: LD_VAR 0 2
37364: ARRAY
37365: PPUSH
37366: LD_INT 124
37368: PPUSH
37369: CALL 80892 0 2
37373: OR
37374: IFFALSE 37378
// continue ;
37376: GO 37230
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
37378: LD_EXP 86
37382: PUSH
37383: LD_VAR 0 2
37387: ARRAY
37388: PUSH
37389: LD_EXP 85
37393: PUSH
37394: LD_VAR 0 2
37398: ARRAY
37399: LESS
37400: PUSH
37401: LD_EXP 86
37405: PUSH
37406: LD_VAR 0 2
37410: ARRAY
37411: PUSH
37412: LD_VAR 0 8
37416: LESS
37417: AND
37418: IFFALSE 37833
// begin tmp := sci [ 1 ] ;
37420: LD_ADDR_VAR 0 7
37424: PUSH
37425: LD_VAR 0 9
37429: PUSH
37430: LD_INT 1
37432: ARRAY
37433: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37434: LD_VAR 0 7
37438: PPUSH
37439: LD_INT 124
37441: PPUSH
37442: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
37446: LD_ADDR_VAR 0 3
37450: PUSH
37451: DOUBLE
37452: LD_EXP 85
37456: PUSH
37457: LD_VAR 0 2
37461: ARRAY
37462: INC
37463: ST_TO_ADDR
37464: LD_EXP 85
37468: PUSH
37469: LD_VAR 0 2
37473: ARRAY
37474: PUSH
37475: FOR_DOWNTO
37476: IFFALSE 37819
// begin if IsInUnit ( tmp ) then
37478: LD_VAR 0 7
37482: PPUSH
37483: CALL_OW 310
37487: IFFALSE 37498
// ComExitBuilding ( tmp ) ;
37489: LD_VAR 0 7
37493: PPUSH
37494: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
37498: LD_INT 35
37500: PPUSH
37501: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
37505: LD_VAR 0 7
37509: PPUSH
37510: CALL_OW 310
37514: NOT
37515: PUSH
37516: LD_VAR 0 7
37520: PPUSH
37521: CALL_OW 314
37525: NOT
37526: AND
37527: IFFALSE 37498
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
37529: LD_ADDR_VAR 0 6
37533: PUSH
37534: LD_VAR 0 7
37538: PPUSH
37539: CALL_OW 250
37543: PUSH
37544: LD_VAR 0 7
37548: PPUSH
37549: CALL_OW 251
37553: PUSH
37554: EMPTY
37555: LIST
37556: LIST
37557: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37558: LD_INT 35
37560: PPUSH
37561: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
37565: LD_ADDR_VAR 0 4
37569: PUSH
37570: LD_EXP 85
37574: PUSH
37575: LD_VAR 0 2
37579: ARRAY
37580: PUSH
37581: LD_VAR 0 3
37585: ARRAY
37586: PUSH
37587: LD_INT 1
37589: ARRAY
37590: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
37591: LD_ADDR_VAR 0 5
37595: PUSH
37596: LD_EXP 85
37600: PUSH
37601: LD_VAR 0 2
37605: ARRAY
37606: PUSH
37607: LD_VAR 0 3
37611: ARRAY
37612: PUSH
37613: LD_INT 2
37615: ARRAY
37616: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
37617: LD_VAR 0 7
37621: PPUSH
37622: LD_INT 10
37624: PPUSH
37625: CALL 54924 0 2
37629: PUSH
37630: LD_INT 4
37632: ARRAY
37633: IFFALSE 37671
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
37635: LD_VAR 0 7
37639: PPUSH
37640: LD_VAR 0 6
37644: PUSH
37645: LD_INT 1
37647: ARRAY
37648: PPUSH
37649: LD_VAR 0 6
37653: PUSH
37654: LD_INT 2
37656: ARRAY
37657: PPUSH
37658: CALL_OW 111
// wait ( 0 0$10 ) ;
37662: LD_INT 350
37664: PPUSH
37665: CALL_OW 67
// end else
37669: GO 37697
// begin ComMoveXY ( tmp , x , y ) ;
37671: LD_VAR 0 7
37675: PPUSH
37676: LD_VAR 0 4
37680: PPUSH
37681: LD_VAR 0 5
37685: PPUSH
37686: CALL_OW 111
// wait ( 0 0$3 ) ;
37690: LD_INT 105
37692: PPUSH
37693: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
37697: LD_VAR 0 7
37701: PPUSH
37702: LD_VAR 0 4
37706: PPUSH
37707: LD_VAR 0 5
37711: PPUSH
37712: CALL_OW 307
37716: IFFALSE 37558
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
37718: LD_VAR 0 7
37722: PPUSH
37723: LD_VAR 0 4
37727: PPUSH
37728: LD_VAR 0 5
37732: PPUSH
37733: LD_VAR 0 8
37737: PUSH
37738: LD_VAR 0 3
37742: ARRAY
37743: PPUSH
37744: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
37748: LD_INT 35
37750: PPUSH
37751: CALL_OW 67
// until not HasTask ( tmp ) ;
37755: LD_VAR 0 7
37759: PPUSH
37760: CALL_OW 314
37764: NOT
37765: IFFALSE 37748
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
37767: LD_ADDR_EXP 86
37771: PUSH
37772: LD_EXP 86
37776: PPUSH
37777: LD_VAR 0 2
37781: PUSH
37782: LD_EXP 86
37786: PUSH
37787: LD_VAR 0 2
37791: ARRAY
37792: PUSH
37793: LD_INT 1
37795: PLUS
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PPUSH
37801: LD_VAR 0 8
37805: PUSH
37806: LD_VAR 0 3
37810: ARRAY
37811: PPUSH
37812: CALL 52331 0 3
37816: ST_TO_ADDR
// end ;
37817: GO 37475
37819: POP
37820: POP
// MC_Reset ( i , 124 ) ;
37821: LD_VAR 0 2
37825: PPUSH
37826: LD_INT 124
37828: PPUSH
37829: CALL 21440 0 2
// end ; end ;
37833: GO 37230
37835: POP
37836: POP
// end ;
37837: LD_VAR 0 1
37841: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
37842: LD_INT 0
37844: PPUSH
37845: PPUSH
37846: PPUSH
// if not mc_bases then
37847: LD_EXP 50
37851: NOT
37852: IFFALSE 37856
// exit ;
37854: GO 38462
// for i = 1 to mc_bases do
37856: LD_ADDR_VAR 0 2
37860: PUSH
37861: DOUBLE
37862: LD_INT 1
37864: DEC
37865: ST_TO_ADDR
37866: LD_EXP 50
37870: PUSH
37871: FOR_TO
37872: IFFALSE 38460
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
37874: LD_ADDR_VAR 0 3
37878: PUSH
37879: LD_EXP 50
37883: PUSH
37884: LD_VAR 0 2
37888: ARRAY
37889: PPUSH
37890: LD_INT 25
37892: PUSH
37893: LD_INT 4
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PPUSH
37900: CALL_OW 72
37904: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
37905: LD_VAR 0 3
37909: NOT
37910: PUSH
37911: LD_EXP 87
37915: PUSH
37916: LD_VAR 0 2
37920: ARRAY
37921: NOT
37922: OR
37923: PUSH
37924: LD_EXP 50
37928: PUSH
37929: LD_VAR 0 2
37933: ARRAY
37934: PPUSH
37935: LD_INT 2
37937: PUSH
37938: LD_INT 30
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 30
37950: PUSH
37951: LD_INT 1
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: LIST
37962: PPUSH
37963: CALL_OW 72
37967: NOT
37968: OR
37969: IFFALSE 38019
// begin if mc_deposits_finder [ i ] then
37971: LD_EXP 88
37975: PUSH
37976: LD_VAR 0 2
37980: ARRAY
37981: IFFALSE 38017
// begin MC_Reset ( i , 125 ) ;
37983: LD_VAR 0 2
37987: PPUSH
37988: LD_INT 125
37990: PPUSH
37991: CALL 21440 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37995: LD_ADDR_EXP 88
37999: PUSH
38000: LD_EXP 88
38004: PPUSH
38005: LD_VAR 0 2
38009: PPUSH
38010: EMPTY
38011: PPUSH
38012: CALL_OW 1
38016: ST_TO_ADDR
// end ; continue ;
38017: GO 37871
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
38019: LD_EXP 87
38023: PUSH
38024: LD_VAR 0 2
38028: ARRAY
38029: PUSH
38030: LD_INT 1
38032: ARRAY
38033: PUSH
38034: LD_INT 3
38036: ARRAY
38037: PUSH
38038: LD_INT 1
38040: EQUAL
38041: PUSH
38042: LD_INT 20
38044: PPUSH
38045: LD_EXP 76
38049: PUSH
38050: LD_VAR 0 2
38054: ARRAY
38055: PPUSH
38056: CALL_OW 321
38060: PUSH
38061: LD_INT 2
38063: NONEQUAL
38064: AND
38065: IFFALSE 38115
// begin if mc_deposits_finder [ i ] then
38067: LD_EXP 88
38071: PUSH
38072: LD_VAR 0 2
38076: ARRAY
38077: IFFALSE 38113
// begin MC_Reset ( i , 125 ) ;
38079: LD_VAR 0 2
38083: PPUSH
38084: LD_INT 125
38086: PPUSH
38087: CALL 21440 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38091: LD_ADDR_EXP 88
38095: PUSH
38096: LD_EXP 88
38100: PPUSH
38101: LD_VAR 0 2
38105: PPUSH
38106: EMPTY
38107: PPUSH
38108: CALL_OW 1
38112: ST_TO_ADDR
// end ; continue ;
38113: GO 37871
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
38115: LD_EXP 87
38119: PUSH
38120: LD_VAR 0 2
38124: ARRAY
38125: PUSH
38126: LD_INT 1
38128: ARRAY
38129: PUSH
38130: LD_INT 1
38132: ARRAY
38133: PPUSH
38134: LD_EXP 87
38138: PUSH
38139: LD_VAR 0 2
38143: ARRAY
38144: PUSH
38145: LD_INT 1
38147: ARRAY
38148: PUSH
38149: LD_INT 2
38151: ARRAY
38152: PPUSH
38153: LD_EXP 76
38157: PUSH
38158: LD_VAR 0 2
38162: ARRAY
38163: PPUSH
38164: CALL_OW 440
38168: IFFALSE 38211
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38170: LD_ADDR_EXP 87
38174: PUSH
38175: LD_EXP 87
38179: PPUSH
38180: LD_VAR 0 2
38184: PPUSH
38185: LD_EXP 87
38189: PUSH
38190: LD_VAR 0 2
38194: ARRAY
38195: PPUSH
38196: LD_INT 1
38198: PPUSH
38199: CALL_OW 3
38203: PPUSH
38204: CALL_OW 1
38208: ST_TO_ADDR
38209: GO 38458
// begin if not mc_deposits_finder [ i ] then
38211: LD_EXP 88
38215: PUSH
38216: LD_VAR 0 2
38220: ARRAY
38221: NOT
38222: IFFALSE 38274
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38224: LD_ADDR_EXP 88
38228: PUSH
38229: LD_EXP 88
38233: PPUSH
38234: LD_VAR 0 2
38238: PPUSH
38239: LD_VAR 0 3
38243: PUSH
38244: LD_INT 1
38246: ARRAY
38247: PUSH
38248: EMPTY
38249: LIST
38250: PPUSH
38251: CALL_OW 1
38255: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38256: LD_VAR 0 3
38260: PUSH
38261: LD_INT 1
38263: ARRAY
38264: PPUSH
38265: LD_INT 125
38267: PPUSH
38268: CALL_OW 109
// end else
38272: GO 38458
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
38274: LD_EXP 88
38278: PUSH
38279: LD_VAR 0 2
38283: ARRAY
38284: PUSH
38285: LD_INT 1
38287: ARRAY
38288: PPUSH
38289: CALL_OW 310
38293: IFFALSE 38316
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
38295: LD_EXP 88
38299: PUSH
38300: LD_VAR 0 2
38304: ARRAY
38305: PUSH
38306: LD_INT 1
38308: ARRAY
38309: PPUSH
38310: CALL_OW 122
38314: GO 38458
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
38316: LD_EXP 88
38320: PUSH
38321: LD_VAR 0 2
38325: ARRAY
38326: PUSH
38327: LD_INT 1
38329: ARRAY
38330: PPUSH
38331: CALL_OW 314
38335: NOT
38336: PUSH
38337: LD_EXP 88
38341: PUSH
38342: LD_VAR 0 2
38346: ARRAY
38347: PUSH
38348: LD_INT 1
38350: ARRAY
38351: PPUSH
38352: LD_EXP 87
38356: PUSH
38357: LD_VAR 0 2
38361: ARRAY
38362: PUSH
38363: LD_INT 1
38365: ARRAY
38366: PUSH
38367: LD_INT 1
38369: ARRAY
38370: PPUSH
38371: LD_EXP 87
38375: PUSH
38376: LD_VAR 0 2
38380: ARRAY
38381: PUSH
38382: LD_INT 1
38384: ARRAY
38385: PUSH
38386: LD_INT 2
38388: ARRAY
38389: PPUSH
38390: CALL_OW 297
38394: PUSH
38395: LD_INT 6
38397: GREATER
38398: AND
38399: IFFALSE 38458
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
38401: LD_EXP 88
38405: PUSH
38406: LD_VAR 0 2
38410: ARRAY
38411: PUSH
38412: LD_INT 1
38414: ARRAY
38415: PPUSH
38416: LD_EXP 87
38420: PUSH
38421: LD_VAR 0 2
38425: ARRAY
38426: PUSH
38427: LD_INT 1
38429: ARRAY
38430: PUSH
38431: LD_INT 1
38433: ARRAY
38434: PPUSH
38435: LD_EXP 87
38439: PUSH
38440: LD_VAR 0 2
38444: ARRAY
38445: PUSH
38446: LD_INT 1
38448: ARRAY
38449: PUSH
38450: LD_INT 2
38452: ARRAY
38453: PPUSH
38454: CALL_OW 111
// end ; end ; end ;
38458: GO 37871
38460: POP
38461: POP
// end ;
38462: LD_VAR 0 1
38466: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
38467: LD_INT 0
38469: PPUSH
38470: PPUSH
38471: PPUSH
38472: PPUSH
38473: PPUSH
38474: PPUSH
38475: PPUSH
38476: PPUSH
38477: PPUSH
38478: PPUSH
38479: PPUSH
// if not mc_bases then
38480: LD_EXP 50
38484: NOT
38485: IFFALSE 38489
// exit ;
38487: GO 39429
// for i = 1 to mc_bases do
38489: LD_ADDR_VAR 0 2
38493: PUSH
38494: DOUBLE
38495: LD_INT 1
38497: DEC
38498: ST_TO_ADDR
38499: LD_EXP 50
38503: PUSH
38504: FOR_TO
38505: IFFALSE 39427
// begin if not mc_bases [ i ] or mc_scan [ i ] then
38507: LD_EXP 50
38511: PUSH
38512: LD_VAR 0 2
38516: ARRAY
38517: NOT
38518: PUSH
38519: LD_EXP 73
38523: PUSH
38524: LD_VAR 0 2
38528: ARRAY
38529: OR
38530: IFFALSE 38534
// continue ;
38532: GO 38504
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
38534: LD_ADDR_VAR 0 7
38538: PUSH
38539: LD_EXP 50
38543: PUSH
38544: LD_VAR 0 2
38548: ARRAY
38549: PUSH
38550: LD_INT 1
38552: ARRAY
38553: PPUSH
38554: CALL_OW 248
38558: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
38559: LD_VAR 0 7
38563: PUSH
38564: LD_INT 3
38566: EQUAL
38567: PUSH
38568: LD_EXP 69
38572: PUSH
38573: LD_VAR 0 2
38577: ARRAY
38578: PUSH
38579: LD_EXP 72
38583: PUSH
38584: LD_VAR 0 2
38588: ARRAY
38589: UNION
38590: PPUSH
38591: LD_INT 33
38593: PUSH
38594: LD_INT 2
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PPUSH
38601: CALL_OW 72
38605: NOT
38606: OR
38607: IFFALSE 38611
// continue ;
38609: GO 38504
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
38611: LD_ADDR_VAR 0 9
38615: PUSH
38616: LD_EXP 50
38620: PUSH
38621: LD_VAR 0 2
38625: ARRAY
38626: PPUSH
38627: LD_INT 30
38629: PUSH
38630: LD_INT 36
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PPUSH
38637: CALL_OW 72
38641: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
38642: LD_ADDR_VAR 0 10
38646: PUSH
38647: LD_EXP 69
38651: PUSH
38652: LD_VAR 0 2
38656: ARRAY
38657: PPUSH
38658: LD_INT 34
38660: PUSH
38661: LD_INT 31
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PPUSH
38668: CALL_OW 72
38672: ST_TO_ADDR
// if not cts and not mcts then
38673: LD_VAR 0 9
38677: NOT
38678: PUSH
38679: LD_VAR 0 10
38683: NOT
38684: AND
38685: IFFALSE 38689
// continue ;
38687: GO 38504
// x := cts ;
38689: LD_ADDR_VAR 0 11
38693: PUSH
38694: LD_VAR 0 9
38698: ST_TO_ADDR
// if not x then
38699: LD_VAR 0 11
38703: NOT
38704: IFFALSE 38716
// x := mcts ;
38706: LD_ADDR_VAR 0 11
38710: PUSH
38711: LD_VAR 0 10
38715: ST_TO_ADDR
// if not x then
38716: LD_VAR 0 11
38720: NOT
38721: IFFALSE 38725
// continue ;
38723: GO 38504
// if mc_remote_driver [ i ] then
38725: LD_EXP 90
38729: PUSH
38730: LD_VAR 0 2
38734: ARRAY
38735: IFFALSE 39122
// for j in mc_remote_driver [ i ] do
38737: LD_ADDR_VAR 0 3
38741: PUSH
38742: LD_EXP 90
38746: PUSH
38747: LD_VAR 0 2
38751: ARRAY
38752: PUSH
38753: FOR_IN
38754: IFFALSE 39120
// begin if GetClass ( j ) <> 3 then
38756: LD_VAR 0 3
38760: PPUSH
38761: CALL_OW 257
38765: PUSH
38766: LD_INT 3
38768: NONEQUAL
38769: IFFALSE 38822
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
38771: LD_ADDR_EXP 90
38775: PUSH
38776: LD_EXP 90
38780: PPUSH
38781: LD_VAR 0 2
38785: PPUSH
38786: LD_EXP 90
38790: PUSH
38791: LD_VAR 0 2
38795: ARRAY
38796: PUSH
38797: LD_VAR 0 3
38801: DIFF
38802: PPUSH
38803: CALL_OW 1
38807: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38808: LD_VAR 0 3
38812: PPUSH
38813: LD_INT 0
38815: PPUSH
38816: CALL_OW 109
// continue ;
38820: GO 38753
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
38822: LD_EXP 69
38826: PUSH
38827: LD_VAR 0 2
38831: ARRAY
38832: PPUSH
38833: LD_INT 34
38835: PUSH
38836: LD_INT 31
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 58
38845: PUSH
38846: EMPTY
38847: LIST
38848: PUSH
38849: EMPTY
38850: LIST
38851: LIST
38852: PPUSH
38853: CALL_OW 72
38857: PUSH
38858: LD_VAR 0 3
38862: PPUSH
38863: CALL 80980 0 1
38867: NOT
38868: AND
38869: IFFALSE 38940
// begin if IsInUnit ( j ) then
38871: LD_VAR 0 3
38875: PPUSH
38876: CALL_OW 310
38880: IFFALSE 38891
// ComExitBuilding ( j ) ;
38882: LD_VAR 0 3
38886: PPUSH
38887: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
38891: LD_VAR 0 3
38895: PPUSH
38896: LD_EXP 69
38900: PUSH
38901: LD_VAR 0 2
38905: ARRAY
38906: PPUSH
38907: LD_INT 34
38909: PUSH
38910: LD_INT 31
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 58
38919: PUSH
38920: EMPTY
38921: LIST
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PPUSH
38927: CALL_OW 72
38931: PUSH
38932: LD_INT 1
38934: ARRAY
38935: PPUSH
38936: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
38940: LD_VAR 0 3
38944: PPUSH
38945: CALL_OW 310
38949: NOT
38950: PUSH
38951: LD_VAR 0 3
38955: PPUSH
38956: CALL_OW 310
38960: PPUSH
38961: CALL_OW 266
38965: PUSH
38966: LD_INT 36
38968: NONEQUAL
38969: PUSH
38970: LD_VAR 0 3
38974: PPUSH
38975: CALL 80980 0 1
38979: NOT
38980: AND
38981: OR
38982: IFFALSE 39118
// begin if IsInUnit ( j ) then
38984: LD_VAR 0 3
38988: PPUSH
38989: CALL_OW 310
38993: IFFALSE 39004
// ComExitBuilding ( j ) ;
38995: LD_VAR 0 3
38999: PPUSH
39000: CALL_OW 122
// ct := 0 ;
39004: LD_ADDR_VAR 0 8
39008: PUSH
39009: LD_INT 0
39011: ST_TO_ADDR
// for k in x do
39012: LD_ADDR_VAR 0 4
39016: PUSH
39017: LD_VAR 0 11
39021: PUSH
39022: FOR_IN
39023: IFFALSE 39096
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
39025: LD_VAR 0 4
39029: PPUSH
39030: CALL_OW 264
39034: PUSH
39035: LD_INT 31
39037: EQUAL
39038: PUSH
39039: LD_VAR 0 4
39043: PPUSH
39044: CALL_OW 311
39048: NOT
39049: AND
39050: PUSH
39051: LD_VAR 0 4
39055: PPUSH
39056: CALL_OW 266
39060: PUSH
39061: LD_INT 36
39063: EQUAL
39064: PUSH
39065: LD_VAR 0 4
39069: PPUSH
39070: CALL_OW 313
39074: PUSH
39075: LD_INT 3
39077: LESS
39078: AND
39079: OR
39080: IFFALSE 39094
// begin ct := k ;
39082: LD_ADDR_VAR 0 8
39086: PUSH
39087: LD_VAR 0 4
39091: ST_TO_ADDR
// break ;
39092: GO 39096
// end ;
39094: GO 39022
39096: POP
39097: POP
// if ct then
39098: LD_VAR 0 8
39102: IFFALSE 39118
// ComEnterUnit ( j , ct ) ;
39104: LD_VAR 0 3
39108: PPUSH
39109: LD_VAR 0 8
39113: PPUSH
39114: CALL_OW 120
// end ; end ;
39118: GO 38753
39120: POP
39121: POP
// places := 0 ;
39122: LD_ADDR_VAR 0 5
39126: PUSH
39127: LD_INT 0
39129: ST_TO_ADDR
// for j = 1 to x do
39130: LD_ADDR_VAR 0 3
39134: PUSH
39135: DOUBLE
39136: LD_INT 1
39138: DEC
39139: ST_TO_ADDR
39140: LD_VAR 0 11
39144: PUSH
39145: FOR_TO
39146: IFFALSE 39222
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39148: LD_VAR 0 11
39152: PUSH
39153: LD_VAR 0 3
39157: ARRAY
39158: PPUSH
39159: CALL_OW 264
39163: PUSH
39164: LD_INT 31
39166: EQUAL
39167: IFFALSE 39185
// places := places + 1 else
39169: LD_ADDR_VAR 0 5
39173: PUSH
39174: LD_VAR 0 5
39178: PUSH
39179: LD_INT 1
39181: PLUS
39182: ST_TO_ADDR
39183: GO 39220
// if GetBType ( x [ j ] ) = b_control_tower then
39185: LD_VAR 0 11
39189: PUSH
39190: LD_VAR 0 3
39194: ARRAY
39195: PPUSH
39196: CALL_OW 266
39200: PUSH
39201: LD_INT 36
39203: EQUAL
39204: IFFALSE 39220
// places := places + 3 ;
39206: LD_ADDR_VAR 0 5
39210: PUSH
39211: LD_VAR 0 5
39215: PUSH
39216: LD_INT 3
39218: PLUS
39219: ST_TO_ADDR
39220: GO 39145
39222: POP
39223: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39224: LD_VAR 0 5
39228: PUSH
39229: LD_INT 0
39231: EQUAL
39232: PUSH
39233: LD_VAR 0 5
39237: PUSH
39238: LD_EXP 90
39242: PUSH
39243: LD_VAR 0 2
39247: ARRAY
39248: LESSEQUAL
39249: OR
39250: IFFALSE 39254
// continue ;
39252: GO 38504
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39254: LD_ADDR_VAR 0 6
39258: PUSH
39259: LD_EXP 50
39263: PUSH
39264: LD_VAR 0 2
39268: ARRAY
39269: PPUSH
39270: LD_INT 25
39272: PUSH
39273: LD_INT 3
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: PPUSH
39280: CALL_OW 72
39284: PUSH
39285: LD_EXP 90
39289: PUSH
39290: LD_VAR 0 2
39294: ARRAY
39295: DIFF
39296: PPUSH
39297: LD_INT 3
39299: PPUSH
39300: CALL 81880 0 2
39304: ST_TO_ADDR
// for j in tmp do
39305: LD_ADDR_VAR 0 3
39309: PUSH
39310: LD_VAR 0 6
39314: PUSH
39315: FOR_IN
39316: IFFALSE 39351
// if GetTag ( j ) > 0 then
39318: LD_VAR 0 3
39322: PPUSH
39323: CALL_OW 110
39327: PUSH
39328: LD_INT 0
39330: GREATER
39331: IFFALSE 39349
// tmp := tmp diff j ;
39333: LD_ADDR_VAR 0 6
39337: PUSH
39338: LD_VAR 0 6
39342: PUSH
39343: LD_VAR 0 3
39347: DIFF
39348: ST_TO_ADDR
39349: GO 39315
39351: POP
39352: POP
// if not tmp then
39353: LD_VAR 0 6
39357: NOT
39358: IFFALSE 39362
// continue ;
39360: GO 38504
// if places then
39362: LD_VAR 0 5
39366: IFFALSE 39425
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
39368: LD_ADDR_EXP 90
39372: PUSH
39373: LD_EXP 90
39377: PPUSH
39378: LD_VAR 0 2
39382: PPUSH
39383: LD_EXP 90
39387: PUSH
39388: LD_VAR 0 2
39392: ARRAY
39393: PUSH
39394: LD_VAR 0 6
39398: PUSH
39399: LD_INT 1
39401: ARRAY
39402: UNION
39403: PPUSH
39404: CALL_OW 1
39408: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
39409: LD_VAR 0 6
39413: PUSH
39414: LD_INT 1
39416: ARRAY
39417: PPUSH
39418: LD_INT 126
39420: PPUSH
39421: CALL_OW 109
// end ; end ;
39425: GO 38504
39427: POP
39428: POP
// end ;
39429: LD_VAR 0 1
39433: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
39434: LD_INT 0
39436: PPUSH
39437: PPUSH
39438: PPUSH
39439: PPUSH
39440: PPUSH
39441: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
39442: LD_VAR 0 1
39446: NOT
39447: PUSH
39448: LD_VAR 0 2
39452: NOT
39453: OR
39454: PUSH
39455: LD_VAR 0 3
39459: NOT
39460: OR
39461: PUSH
39462: LD_VAR 0 4
39466: PUSH
39467: LD_INT 1
39469: PUSH
39470: LD_INT 2
39472: PUSH
39473: LD_INT 3
39475: PUSH
39476: LD_INT 4
39478: PUSH
39479: LD_INT 5
39481: PUSH
39482: LD_INT 8
39484: PUSH
39485: LD_INT 9
39487: PUSH
39488: LD_INT 15
39490: PUSH
39491: LD_INT 16
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: LIST
39498: LIST
39499: LIST
39500: LIST
39501: LIST
39502: LIST
39503: LIST
39504: IN
39505: NOT
39506: OR
39507: IFFALSE 39511
// exit ;
39509: GO 40411
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
39511: LD_ADDR_VAR 0 2
39515: PUSH
39516: LD_VAR 0 2
39520: PPUSH
39521: LD_INT 21
39523: PUSH
39524: LD_INT 3
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 24
39533: PUSH
39534: LD_INT 250
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: EMPTY
39542: LIST
39543: LIST
39544: PPUSH
39545: CALL_OW 72
39549: ST_TO_ADDR
// case class of 1 , 15 :
39550: LD_VAR 0 4
39554: PUSH
39555: LD_INT 1
39557: DOUBLE
39558: EQUAL
39559: IFTRUE 39569
39561: LD_INT 15
39563: DOUBLE
39564: EQUAL
39565: IFTRUE 39569
39567: GO 39654
39569: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
39570: LD_ADDR_VAR 0 8
39574: PUSH
39575: LD_VAR 0 2
39579: PPUSH
39580: LD_INT 2
39582: PUSH
39583: LD_INT 30
39585: PUSH
39586: LD_INT 32
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 30
39595: PUSH
39596: LD_INT 31
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: LIST
39607: PPUSH
39608: CALL_OW 72
39612: PUSH
39613: LD_VAR 0 2
39617: PPUSH
39618: LD_INT 2
39620: PUSH
39621: LD_INT 30
39623: PUSH
39624: LD_INT 4
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 30
39633: PUSH
39634: LD_INT 5
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: LIST
39645: PPUSH
39646: CALL_OW 72
39650: ADD
39651: ST_TO_ADDR
39652: GO 39900
39654: LD_INT 2
39656: DOUBLE
39657: EQUAL
39658: IFTRUE 39668
39660: LD_INT 16
39662: DOUBLE
39663: EQUAL
39664: IFTRUE 39668
39666: GO 39714
39668: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
39669: LD_ADDR_VAR 0 8
39673: PUSH
39674: LD_VAR 0 2
39678: PPUSH
39679: LD_INT 2
39681: PUSH
39682: LD_INT 30
39684: PUSH
39685: LD_INT 0
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: LD_INT 30
39694: PUSH
39695: LD_INT 1
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: LIST
39706: PPUSH
39707: CALL_OW 72
39711: ST_TO_ADDR
39712: GO 39900
39714: LD_INT 3
39716: DOUBLE
39717: EQUAL
39718: IFTRUE 39722
39720: GO 39768
39722: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
39723: LD_ADDR_VAR 0 8
39727: PUSH
39728: LD_VAR 0 2
39732: PPUSH
39733: LD_INT 2
39735: PUSH
39736: LD_INT 30
39738: PUSH
39739: LD_INT 2
39741: PUSH
39742: EMPTY
39743: LIST
39744: LIST
39745: PUSH
39746: LD_INT 30
39748: PUSH
39749: LD_INT 3
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: EMPTY
39757: LIST
39758: LIST
39759: LIST
39760: PPUSH
39761: CALL_OW 72
39765: ST_TO_ADDR
39766: GO 39900
39768: LD_INT 4
39770: DOUBLE
39771: EQUAL
39772: IFTRUE 39776
39774: GO 39833
39776: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
39777: LD_ADDR_VAR 0 8
39781: PUSH
39782: LD_VAR 0 2
39786: PPUSH
39787: LD_INT 2
39789: PUSH
39790: LD_INT 30
39792: PUSH
39793: LD_INT 6
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PUSH
39800: LD_INT 30
39802: PUSH
39803: LD_INT 7
39805: PUSH
39806: EMPTY
39807: LIST
39808: LIST
39809: PUSH
39810: LD_INT 30
39812: PUSH
39813: LD_INT 8
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: LIST
39824: LIST
39825: PPUSH
39826: CALL_OW 72
39830: ST_TO_ADDR
39831: GO 39900
39833: LD_INT 5
39835: DOUBLE
39836: EQUAL
39837: IFTRUE 39853
39839: LD_INT 8
39841: DOUBLE
39842: EQUAL
39843: IFTRUE 39853
39845: LD_INT 9
39847: DOUBLE
39848: EQUAL
39849: IFTRUE 39853
39851: GO 39899
39853: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
39854: LD_ADDR_VAR 0 8
39858: PUSH
39859: LD_VAR 0 2
39863: PPUSH
39864: LD_INT 2
39866: PUSH
39867: LD_INT 30
39869: PUSH
39870: LD_INT 4
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 30
39879: PUSH
39880: LD_INT 5
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: LIST
39891: PPUSH
39892: CALL_OW 72
39896: ST_TO_ADDR
39897: GO 39900
39899: POP
// if not tmp then
39900: LD_VAR 0 8
39904: NOT
39905: IFFALSE 39909
// exit ;
39907: GO 40411
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
39909: LD_VAR 0 4
39913: PUSH
39914: LD_INT 1
39916: PUSH
39917: LD_INT 15
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: IN
39924: PUSH
39925: LD_EXP 59
39929: PUSH
39930: LD_VAR 0 1
39934: ARRAY
39935: AND
39936: IFFALSE 40092
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
39938: LD_ADDR_VAR 0 9
39942: PUSH
39943: LD_EXP 59
39947: PUSH
39948: LD_VAR 0 1
39952: ARRAY
39953: PUSH
39954: LD_INT 1
39956: ARRAY
39957: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
39958: LD_VAR 0 9
39962: PUSH
39963: LD_EXP 60
39967: PUSH
39968: LD_VAR 0 1
39972: ARRAY
39973: IN
39974: NOT
39975: IFFALSE 40090
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
39977: LD_ADDR_EXP 60
39981: PUSH
39982: LD_EXP 60
39986: PPUSH
39987: LD_VAR 0 1
39991: PUSH
39992: LD_EXP 60
39996: PUSH
39997: LD_VAR 0 1
40001: ARRAY
40002: PUSH
40003: LD_INT 1
40005: PLUS
40006: PUSH
40007: EMPTY
40008: LIST
40009: LIST
40010: PPUSH
40011: LD_VAR 0 9
40015: PPUSH
40016: CALL 52331 0 3
40020: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
40021: LD_ADDR_EXP 59
40025: PUSH
40026: LD_EXP 59
40030: PPUSH
40031: LD_VAR 0 1
40035: PPUSH
40036: LD_EXP 59
40040: PUSH
40041: LD_VAR 0 1
40045: ARRAY
40046: PUSH
40047: LD_VAR 0 9
40051: DIFF
40052: PPUSH
40053: CALL_OW 1
40057: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
40058: LD_VAR 0 3
40062: PPUSH
40063: LD_EXP 60
40067: PUSH
40068: LD_VAR 0 1
40072: ARRAY
40073: PUSH
40074: LD_EXP 60
40078: PUSH
40079: LD_VAR 0 1
40083: ARRAY
40084: ARRAY
40085: PPUSH
40086: CALL_OW 120
// end ; exit ;
40090: GO 40411
// end ; if tmp > 1 then
40092: LD_VAR 0 8
40096: PUSH
40097: LD_INT 1
40099: GREATER
40100: IFFALSE 40204
// for i = 2 to tmp do
40102: LD_ADDR_VAR 0 6
40106: PUSH
40107: DOUBLE
40108: LD_INT 2
40110: DEC
40111: ST_TO_ADDR
40112: LD_VAR 0 8
40116: PUSH
40117: FOR_TO
40118: IFFALSE 40202
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
40120: LD_VAR 0 8
40124: PUSH
40125: LD_VAR 0 6
40129: ARRAY
40130: PPUSH
40131: CALL_OW 461
40135: PUSH
40136: LD_INT 6
40138: EQUAL
40139: IFFALSE 40200
// begin x := tmp [ i ] ;
40141: LD_ADDR_VAR 0 9
40145: PUSH
40146: LD_VAR 0 8
40150: PUSH
40151: LD_VAR 0 6
40155: ARRAY
40156: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40157: LD_ADDR_VAR 0 8
40161: PUSH
40162: LD_VAR 0 8
40166: PPUSH
40167: LD_VAR 0 6
40171: PPUSH
40172: CALL_OW 3
40176: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40177: LD_ADDR_VAR 0 8
40181: PUSH
40182: LD_VAR 0 8
40186: PPUSH
40187: LD_INT 1
40189: PPUSH
40190: LD_VAR 0 9
40194: PPUSH
40195: CALL_OW 2
40199: ST_TO_ADDR
// end ;
40200: GO 40117
40202: POP
40203: POP
// for i in tmp do
40204: LD_ADDR_VAR 0 6
40208: PUSH
40209: LD_VAR 0 8
40213: PUSH
40214: FOR_IN
40215: IFFALSE 40284
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40217: LD_VAR 0 6
40221: PPUSH
40222: CALL_OW 313
40226: PUSH
40227: LD_INT 6
40229: LESS
40230: PUSH
40231: LD_VAR 0 6
40235: PPUSH
40236: CALL_OW 266
40240: PUSH
40241: LD_INT 31
40243: PUSH
40244: LD_INT 32
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: IN
40251: NOT
40252: AND
40253: PUSH
40254: LD_VAR 0 6
40258: PPUSH
40259: CALL_OW 313
40263: PUSH
40264: LD_INT 0
40266: EQUAL
40267: OR
40268: IFFALSE 40282
// begin j := i ;
40270: LD_ADDR_VAR 0 7
40274: PUSH
40275: LD_VAR 0 6
40279: ST_TO_ADDR
// break ;
40280: GO 40284
// end ; end ;
40282: GO 40214
40284: POP
40285: POP
// if j then
40286: LD_VAR 0 7
40290: IFFALSE 40308
// ComEnterUnit ( unit , j ) else
40292: LD_VAR 0 3
40296: PPUSH
40297: LD_VAR 0 7
40301: PPUSH
40302: CALL_OW 120
40306: GO 40411
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40308: LD_ADDR_VAR 0 10
40312: PUSH
40313: LD_VAR 0 2
40317: PPUSH
40318: LD_INT 2
40320: PUSH
40321: LD_INT 30
40323: PUSH
40324: LD_INT 0
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PUSH
40331: LD_INT 30
40333: PUSH
40334: LD_INT 1
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: LIST
40345: PPUSH
40346: CALL_OW 72
40350: ST_TO_ADDR
// if depot then
40351: LD_VAR 0 10
40355: IFFALSE 40411
// begin depot := NearestUnitToUnit ( depot , unit ) ;
40357: LD_ADDR_VAR 0 10
40361: PUSH
40362: LD_VAR 0 10
40366: PPUSH
40367: LD_VAR 0 3
40371: PPUSH
40372: CALL_OW 74
40376: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
40377: LD_VAR 0 3
40381: PPUSH
40382: LD_VAR 0 10
40386: PPUSH
40387: CALL_OW 296
40391: PUSH
40392: LD_INT 10
40394: GREATER
40395: IFFALSE 40411
// ComStandNearbyBuilding ( unit , depot ) ;
40397: LD_VAR 0 3
40401: PPUSH
40402: LD_VAR 0 10
40406: PPUSH
40407: CALL 48945 0 2
// end ; end ; end ;
40411: LD_VAR 0 5
40415: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
40416: LD_INT 0
40418: PPUSH
40419: PPUSH
40420: PPUSH
40421: PPUSH
// if not mc_bases then
40422: LD_EXP 50
40426: NOT
40427: IFFALSE 40431
// exit ;
40429: GO 40670
// for i = 1 to mc_bases do
40431: LD_ADDR_VAR 0 2
40435: PUSH
40436: DOUBLE
40437: LD_INT 1
40439: DEC
40440: ST_TO_ADDR
40441: LD_EXP 50
40445: PUSH
40446: FOR_TO
40447: IFFALSE 40668
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
40449: LD_ADDR_VAR 0 4
40453: PUSH
40454: LD_EXP 50
40458: PUSH
40459: LD_VAR 0 2
40463: ARRAY
40464: PPUSH
40465: LD_INT 21
40467: PUSH
40468: LD_INT 1
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PPUSH
40475: CALL_OW 72
40479: PUSH
40480: LD_EXP 79
40484: PUSH
40485: LD_VAR 0 2
40489: ARRAY
40490: UNION
40491: ST_TO_ADDR
// if not tmp then
40492: LD_VAR 0 4
40496: NOT
40497: IFFALSE 40501
// continue ;
40499: GO 40446
// for j in tmp do
40501: LD_ADDR_VAR 0 3
40505: PUSH
40506: LD_VAR 0 4
40510: PUSH
40511: FOR_IN
40512: IFFALSE 40664
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
40514: LD_VAR 0 3
40518: PPUSH
40519: CALL_OW 110
40523: NOT
40524: PUSH
40525: LD_VAR 0 3
40529: PPUSH
40530: CALL_OW 314
40534: NOT
40535: AND
40536: PUSH
40537: LD_VAR 0 3
40541: PPUSH
40542: CALL_OW 311
40546: NOT
40547: AND
40548: PUSH
40549: LD_VAR 0 3
40553: PPUSH
40554: CALL_OW 310
40558: NOT
40559: AND
40560: PUSH
40561: LD_VAR 0 3
40565: PUSH
40566: LD_EXP 53
40570: PUSH
40571: LD_VAR 0 2
40575: ARRAY
40576: PUSH
40577: LD_INT 1
40579: ARRAY
40580: IN
40581: NOT
40582: AND
40583: PUSH
40584: LD_VAR 0 3
40588: PUSH
40589: LD_EXP 53
40593: PUSH
40594: LD_VAR 0 2
40598: ARRAY
40599: PUSH
40600: LD_INT 2
40602: ARRAY
40603: IN
40604: NOT
40605: AND
40606: PUSH
40607: LD_VAR 0 3
40611: PUSH
40612: LD_EXP 62
40616: PUSH
40617: LD_VAR 0 2
40621: ARRAY
40622: IN
40623: NOT
40624: AND
40625: IFFALSE 40662
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
40627: LD_VAR 0 2
40631: PPUSH
40632: LD_EXP 50
40636: PUSH
40637: LD_VAR 0 2
40641: ARRAY
40642: PPUSH
40643: LD_VAR 0 3
40647: PPUSH
40648: LD_VAR 0 3
40652: PPUSH
40653: CALL_OW 257
40657: PPUSH
40658: CALL 39434 0 4
// end ;
40662: GO 40511
40664: POP
40665: POP
// end ;
40666: GO 40446
40668: POP
40669: POP
// end ;
40670: LD_VAR 0 1
40674: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
40675: LD_INT 0
40677: PPUSH
40678: PPUSH
40679: PPUSH
40680: PPUSH
40681: PPUSH
40682: PPUSH
// if not mc_bases [ base ] then
40683: LD_EXP 50
40687: PUSH
40688: LD_VAR 0 1
40692: ARRAY
40693: NOT
40694: IFFALSE 40698
// exit ;
40696: GO 40880
// tmp := [ ] ;
40698: LD_ADDR_VAR 0 6
40702: PUSH
40703: EMPTY
40704: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
40705: LD_ADDR_VAR 0 7
40709: PUSH
40710: LD_VAR 0 3
40714: PPUSH
40715: LD_INT 0
40717: PPUSH
40718: CALL_OW 517
40722: ST_TO_ADDR
// if not list then
40723: LD_VAR 0 7
40727: NOT
40728: IFFALSE 40732
// exit ;
40730: GO 40880
// for i = 1 to amount do
40732: LD_ADDR_VAR 0 5
40736: PUSH
40737: DOUBLE
40738: LD_INT 1
40740: DEC
40741: ST_TO_ADDR
40742: LD_VAR 0 2
40746: PUSH
40747: FOR_TO
40748: IFFALSE 40828
// begin x := rand ( 1 , list [ 1 ] ) ;
40750: LD_ADDR_VAR 0 8
40754: PUSH
40755: LD_INT 1
40757: PPUSH
40758: LD_VAR 0 7
40762: PUSH
40763: LD_INT 1
40765: ARRAY
40766: PPUSH
40767: CALL_OW 12
40771: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
40772: LD_ADDR_VAR 0 6
40776: PUSH
40777: LD_VAR 0 6
40781: PPUSH
40782: LD_VAR 0 5
40786: PPUSH
40787: LD_VAR 0 7
40791: PUSH
40792: LD_INT 1
40794: ARRAY
40795: PUSH
40796: LD_VAR 0 8
40800: ARRAY
40801: PUSH
40802: LD_VAR 0 7
40806: PUSH
40807: LD_INT 2
40809: ARRAY
40810: PUSH
40811: LD_VAR 0 8
40815: ARRAY
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PPUSH
40821: CALL_OW 1
40825: ST_TO_ADDR
// end ;
40826: GO 40747
40828: POP
40829: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
40830: LD_ADDR_EXP 63
40834: PUSH
40835: LD_EXP 63
40839: PPUSH
40840: LD_VAR 0 1
40844: PPUSH
40845: LD_VAR 0 6
40849: PPUSH
40850: CALL_OW 1
40854: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
40855: LD_ADDR_EXP 65
40859: PUSH
40860: LD_EXP 65
40864: PPUSH
40865: LD_VAR 0 1
40869: PPUSH
40870: LD_VAR 0 3
40874: PPUSH
40875: CALL_OW 1
40879: ST_TO_ADDR
// end ;
40880: LD_VAR 0 4
40884: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
40885: LD_INT 0
40887: PPUSH
// if not mc_bases [ base ] then
40888: LD_EXP 50
40892: PUSH
40893: LD_VAR 0 1
40897: ARRAY
40898: NOT
40899: IFFALSE 40903
// exit ;
40901: GO 40928
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
40903: LD_ADDR_EXP 55
40907: PUSH
40908: LD_EXP 55
40912: PPUSH
40913: LD_VAR 0 1
40917: PPUSH
40918: LD_VAR 0 2
40922: PPUSH
40923: CALL_OW 1
40927: ST_TO_ADDR
// end ;
40928: LD_VAR 0 3
40932: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
40933: LD_INT 0
40935: PPUSH
// if not mc_bases [ base ] then
40936: LD_EXP 50
40940: PUSH
40941: LD_VAR 0 1
40945: ARRAY
40946: NOT
40947: IFFALSE 40951
// exit ;
40949: GO 40988
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
40951: LD_ADDR_EXP 55
40955: PUSH
40956: LD_EXP 55
40960: PPUSH
40961: LD_VAR 0 1
40965: PPUSH
40966: LD_EXP 55
40970: PUSH
40971: LD_VAR 0 1
40975: ARRAY
40976: PUSH
40977: LD_VAR 0 2
40981: UNION
40982: PPUSH
40983: CALL_OW 1
40987: ST_TO_ADDR
// end ;
40988: LD_VAR 0 3
40992: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
40993: LD_INT 0
40995: PPUSH
// if not mc_bases [ base ] then
40996: LD_EXP 50
41000: PUSH
41001: LD_VAR 0 1
41005: ARRAY
41006: NOT
41007: IFFALSE 41011
// exit ;
41009: GO 41036
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
41011: LD_ADDR_EXP 71
41015: PUSH
41016: LD_EXP 71
41020: PPUSH
41021: LD_VAR 0 1
41025: PPUSH
41026: LD_VAR 0 2
41030: PPUSH
41031: CALL_OW 1
41035: ST_TO_ADDR
// end ;
41036: LD_VAR 0 3
41040: RET
// export function MC_InsertProduceList ( base , components ) ; begin
41041: LD_INT 0
41043: PPUSH
// if not mc_bases [ base ] then
41044: LD_EXP 50
41048: PUSH
41049: LD_VAR 0 1
41053: ARRAY
41054: NOT
41055: IFFALSE 41059
// exit ;
41057: GO 41096
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
41059: LD_ADDR_EXP 71
41063: PUSH
41064: LD_EXP 71
41068: PPUSH
41069: LD_VAR 0 1
41073: PPUSH
41074: LD_EXP 71
41078: PUSH
41079: LD_VAR 0 1
41083: ARRAY
41084: PUSH
41085: LD_VAR 0 2
41089: ADD
41090: PPUSH
41091: CALL_OW 1
41095: ST_TO_ADDR
// end ;
41096: LD_VAR 0 3
41100: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
41101: LD_INT 0
41103: PPUSH
// if not mc_bases [ base ] then
41104: LD_EXP 50
41108: PUSH
41109: LD_VAR 0 1
41113: ARRAY
41114: NOT
41115: IFFALSE 41119
// exit ;
41117: GO 41173
// mc_defender := Replace ( mc_defender , base , deflist ) ;
41119: LD_ADDR_EXP 72
41123: PUSH
41124: LD_EXP 72
41128: PPUSH
41129: LD_VAR 0 1
41133: PPUSH
41134: LD_VAR 0 2
41138: PPUSH
41139: CALL_OW 1
41143: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
41144: LD_ADDR_EXP 61
41148: PUSH
41149: LD_EXP 61
41153: PPUSH
41154: LD_VAR 0 1
41158: PPUSH
41159: LD_VAR 0 2
41163: PUSH
41164: LD_INT 0
41166: PLUS
41167: PPUSH
41168: CALL_OW 1
41172: ST_TO_ADDR
// end ;
41173: LD_VAR 0 3
41177: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41178: LD_INT 0
41180: PPUSH
// if not mc_bases [ base ] then
41181: LD_EXP 50
41185: PUSH
41186: LD_VAR 0 1
41190: ARRAY
41191: NOT
41192: IFFALSE 41196
// exit ;
41194: GO 41221
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41196: LD_ADDR_EXP 61
41200: PUSH
41201: LD_EXP 61
41205: PPUSH
41206: LD_VAR 0 1
41210: PPUSH
41211: LD_VAR 0 2
41215: PPUSH
41216: CALL_OW 1
41220: ST_TO_ADDR
// end ;
41221: LD_VAR 0 3
41225: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41226: LD_INT 0
41228: PPUSH
41229: PPUSH
41230: PPUSH
41231: PPUSH
// if not mc_bases [ base ] then
41232: LD_EXP 50
41236: PUSH
41237: LD_VAR 0 1
41241: ARRAY
41242: NOT
41243: IFFALSE 41247
// exit ;
41245: GO 41312
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41247: LD_ADDR_EXP 70
41251: PUSH
41252: LD_EXP 70
41256: PPUSH
41257: LD_VAR 0 1
41261: PUSH
41262: LD_EXP 70
41266: PUSH
41267: LD_VAR 0 1
41271: ARRAY
41272: PUSH
41273: LD_INT 1
41275: PLUS
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PPUSH
41281: LD_VAR 0 1
41285: PUSH
41286: LD_VAR 0 2
41290: PUSH
41291: LD_VAR 0 3
41295: PUSH
41296: LD_VAR 0 4
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: LIST
41305: LIST
41306: PPUSH
41307: CALL 52331 0 3
41311: ST_TO_ADDR
// end ;
41312: LD_VAR 0 5
41316: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
41317: LD_INT 0
41319: PPUSH
// if not mc_bases [ base ] then
41320: LD_EXP 50
41324: PUSH
41325: LD_VAR 0 1
41329: ARRAY
41330: NOT
41331: IFFALSE 41335
// exit ;
41333: GO 41360
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
41335: LD_ADDR_EXP 87
41339: PUSH
41340: LD_EXP 87
41344: PPUSH
41345: LD_VAR 0 1
41349: PPUSH
41350: LD_VAR 0 2
41354: PPUSH
41355: CALL_OW 1
41359: ST_TO_ADDR
// end ;
41360: LD_VAR 0 3
41364: RET
// export function MC_GetMinesField ( base ) ; begin
41365: LD_INT 0
41367: PPUSH
// result := mc_mines [ base ] ;
41368: LD_ADDR_VAR 0 2
41372: PUSH
41373: LD_EXP 63
41377: PUSH
41378: LD_VAR 0 1
41382: ARRAY
41383: ST_TO_ADDR
// end ;
41384: LD_VAR 0 2
41388: RET
// export function MC_GetProduceList ( base ) ; begin
41389: LD_INT 0
41391: PPUSH
// result := mc_produce [ base ] ;
41392: LD_ADDR_VAR 0 2
41396: PUSH
41397: LD_EXP 71
41401: PUSH
41402: LD_VAR 0 1
41406: ARRAY
41407: ST_TO_ADDR
// end ;
41408: LD_VAR 0 2
41412: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
41413: LD_INT 0
41415: PPUSH
41416: PPUSH
// if not mc_bases then
41417: LD_EXP 50
41421: NOT
41422: IFFALSE 41426
// exit ;
41424: GO 41491
// if mc_bases [ base ] then
41426: LD_EXP 50
41430: PUSH
41431: LD_VAR 0 1
41435: ARRAY
41436: IFFALSE 41491
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41438: LD_ADDR_VAR 0 3
41442: PUSH
41443: LD_EXP 50
41447: PUSH
41448: LD_VAR 0 1
41452: ARRAY
41453: PPUSH
41454: LD_INT 30
41456: PUSH
41457: LD_VAR 0 2
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: PPUSH
41466: CALL_OW 72
41470: ST_TO_ADDR
// if result then
41471: LD_VAR 0 3
41475: IFFALSE 41491
// result := result [ 1 ] ;
41477: LD_ADDR_VAR 0 3
41481: PUSH
41482: LD_VAR 0 3
41486: PUSH
41487: LD_INT 1
41489: ARRAY
41490: ST_TO_ADDR
// end ; end ;
41491: LD_VAR 0 3
41495: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
41496: LD_INT 0
41498: PPUSH
41499: PPUSH
// if not mc_bases then
41500: LD_EXP 50
41504: NOT
41505: IFFALSE 41509
// exit ;
41507: GO 41554
// if mc_bases [ base ] then
41509: LD_EXP 50
41513: PUSH
41514: LD_VAR 0 1
41518: ARRAY
41519: IFFALSE 41554
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41521: LD_ADDR_VAR 0 3
41525: PUSH
41526: LD_EXP 50
41530: PUSH
41531: LD_VAR 0 1
41535: ARRAY
41536: PPUSH
41537: LD_INT 30
41539: PUSH
41540: LD_VAR 0 2
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PPUSH
41549: CALL_OW 72
41553: ST_TO_ADDR
// end ;
41554: LD_VAR 0 3
41558: RET
// export function MC_SetTame ( base , area ) ; begin
41559: LD_INT 0
41561: PPUSH
// if not mc_bases or not base then
41562: LD_EXP 50
41566: NOT
41567: PUSH
41568: LD_VAR 0 1
41572: NOT
41573: OR
41574: IFFALSE 41578
// exit ;
41576: GO 41603
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
41578: LD_ADDR_EXP 78
41582: PUSH
41583: LD_EXP 78
41587: PPUSH
41588: LD_VAR 0 1
41592: PPUSH
41593: LD_VAR 0 2
41597: PPUSH
41598: CALL_OW 1
41602: ST_TO_ADDR
// end ;
41603: LD_VAR 0 3
41607: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
41608: LD_INT 0
41610: PPUSH
41611: PPUSH
// if not mc_bases or not base then
41612: LD_EXP 50
41616: NOT
41617: PUSH
41618: LD_VAR 0 1
41622: NOT
41623: OR
41624: IFFALSE 41628
// exit ;
41626: GO 41730
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41628: LD_ADDR_VAR 0 4
41632: PUSH
41633: LD_EXP 50
41637: PUSH
41638: LD_VAR 0 1
41642: ARRAY
41643: PPUSH
41644: LD_INT 30
41646: PUSH
41647: LD_VAR 0 2
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PPUSH
41656: CALL_OW 72
41660: ST_TO_ADDR
// if not tmp then
41661: LD_VAR 0 4
41665: NOT
41666: IFFALSE 41670
// exit ;
41668: GO 41730
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
41670: LD_ADDR_EXP 82
41674: PUSH
41675: LD_EXP 82
41679: PPUSH
41680: LD_VAR 0 1
41684: PPUSH
41685: LD_EXP 82
41689: PUSH
41690: LD_VAR 0 1
41694: ARRAY
41695: PPUSH
41696: LD_EXP 82
41700: PUSH
41701: LD_VAR 0 1
41705: ARRAY
41706: PUSH
41707: LD_INT 1
41709: PLUS
41710: PPUSH
41711: LD_VAR 0 4
41715: PUSH
41716: LD_INT 1
41718: ARRAY
41719: PPUSH
41720: CALL_OW 2
41724: PPUSH
41725: CALL_OW 1
41729: ST_TO_ADDR
// end ;
41730: LD_VAR 0 3
41734: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
41735: LD_INT 0
41737: PPUSH
41738: PPUSH
// if not mc_bases or not base or not kinds then
41739: LD_EXP 50
41743: NOT
41744: PUSH
41745: LD_VAR 0 1
41749: NOT
41750: OR
41751: PUSH
41752: LD_VAR 0 2
41756: NOT
41757: OR
41758: IFFALSE 41762
// exit ;
41760: GO 41823
// for i in kinds do
41762: LD_ADDR_VAR 0 4
41766: PUSH
41767: LD_VAR 0 2
41771: PUSH
41772: FOR_IN
41773: IFFALSE 41821
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
41775: LD_ADDR_EXP 84
41779: PUSH
41780: LD_EXP 84
41784: PPUSH
41785: LD_VAR 0 1
41789: PUSH
41790: LD_EXP 84
41794: PUSH
41795: LD_VAR 0 1
41799: ARRAY
41800: PUSH
41801: LD_INT 1
41803: PLUS
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PPUSH
41809: LD_VAR 0 4
41813: PPUSH
41814: CALL 52331 0 3
41818: ST_TO_ADDR
41819: GO 41772
41821: POP
41822: POP
// end ;
41823: LD_VAR 0 3
41827: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
41828: LD_INT 0
41830: PPUSH
// if not mc_bases or not base or not areas then
41831: LD_EXP 50
41835: NOT
41836: PUSH
41837: LD_VAR 0 1
41841: NOT
41842: OR
41843: PUSH
41844: LD_VAR 0 2
41848: NOT
41849: OR
41850: IFFALSE 41854
// exit ;
41852: GO 41879
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
41854: LD_ADDR_EXP 68
41858: PUSH
41859: LD_EXP 68
41863: PPUSH
41864: LD_VAR 0 1
41868: PPUSH
41869: LD_VAR 0 2
41873: PPUSH
41874: CALL_OW 1
41878: ST_TO_ADDR
// end ;
41879: LD_VAR 0 3
41883: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
41884: LD_INT 0
41886: PPUSH
// if not mc_bases or not base or not teleports_exit then
41887: LD_EXP 50
41891: NOT
41892: PUSH
41893: LD_VAR 0 1
41897: NOT
41898: OR
41899: PUSH
41900: LD_VAR 0 2
41904: NOT
41905: OR
41906: IFFALSE 41910
// exit ;
41908: GO 41935
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
41910: LD_ADDR_EXP 85
41914: PUSH
41915: LD_EXP 85
41919: PPUSH
41920: LD_VAR 0 1
41924: PPUSH
41925: LD_VAR 0 2
41929: PPUSH
41930: CALL_OW 1
41934: ST_TO_ADDR
// end ;
41935: LD_VAR 0 3
41939: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
41940: LD_INT 0
41942: PPUSH
41943: PPUSH
41944: PPUSH
// if not mc_bases or not base or not ext_list then
41945: LD_EXP 50
41949: NOT
41950: PUSH
41951: LD_VAR 0 1
41955: NOT
41956: OR
41957: PUSH
41958: LD_VAR 0 5
41962: NOT
41963: OR
41964: IFFALSE 41968
// exit ;
41966: GO 42141
// tmp := GetFacExtXYD ( x , y , d ) ;
41968: LD_ADDR_VAR 0 8
41972: PUSH
41973: LD_VAR 0 2
41977: PPUSH
41978: LD_VAR 0 3
41982: PPUSH
41983: LD_VAR 0 4
41987: PPUSH
41988: CALL 81010 0 3
41992: ST_TO_ADDR
// if not tmp then
41993: LD_VAR 0 8
41997: NOT
41998: IFFALSE 42002
// exit ;
42000: GO 42141
// for i in tmp do
42002: LD_ADDR_VAR 0 7
42006: PUSH
42007: LD_VAR 0 8
42011: PUSH
42012: FOR_IN
42013: IFFALSE 42139
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
42015: LD_ADDR_EXP 55
42019: PUSH
42020: LD_EXP 55
42024: PPUSH
42025: LD_VAR 0 1
42029: PPUSH
42030: LD_EXP 55
42034: PUSH
42035: LD_VAR 0 1
42039: ARRAY
42040: PPUSH
42041: LD_EXP 55
42045: PUSH
42046: LD_VAR 0 1
42050: ARRAY
42051: PUSH
42052: LD_INT 1
42054: PLUS
42055: PPUSH
42056: LD_VAR 0 5
42060: PUSH
42061: LD_INT 1
42063: ARRAY
42064: PUSH
42065: LD_VAR 0 7
42069: PUSH
42070: LD_INT 1
42072: ARRAY
42073: PUSH
42074: LD_VAR 0 7
42078: PUSH
42079: LD_INT 2
42081: ARRAY
42082: PUSH
42083: LD_VAR 0 7
42087: PUSH
42088: LD_INT 3
42090: ARRAY
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: LIST
42096: LIST
42097: PPUSH
42098: CALL_OW 2
42102: PPUSH
42103: CALL_OW 1
42107: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
42108: LD_ADDR_VAR 0 5
42112: PUSH
42113: LD_VAR 0 5
42117: PPUSH
42118: LD_INT 1
42120: PPUSH
42121: CALL_OW 3
42125: ST_TO_ADDR
// if not ext_list then
42126: LD_VAR 0 5
42130: NOT
42131: IFFALSE 42137
// exit ;
42133: POP
42134: POP
42135: GO 42141
// end ;
42137: GO 42012
42139: POP
42140: POP
// end ;
42141: LD_VAR 0 6
42145: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42146: LD_INT 0
42148: PPUSH
// if not mc_bases or not base or not weapon_list then
42149: LD_EXP 50
42153: NOT
42154: PUSH
42155: LD_VAR 0 1
42159: NOT
42160: OR
42161: PUSH
42162: LD_VAR 0 2
42166: NOT
42167: OR
42168: IFFALSE 42172
// exit ;
42170: GO 42197
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42172: LD_ADDR_EXP 89
42176: PUSH
42177: LD_EXP 89
42181: PPUSH
42182: LD_VAR 0 1
42186: PPUSH
42187: LD_VAR 0 2
42191: PPUSH
42192: CALL_OW 1
42196: ST_TO_ADDR
// end ;
42197: LD_VAR 0 3
42201: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42202: LD_INT 0
42204: PPUSH
// if not mc_bases or not base or not tech_list then
42205: LD_EXP 50
42209: NOT
42210: PUSH
42211: LD_VAR 0 1
42215: NOT
42216: OR
42217: PUSH
42218: LD_VAR 0 2
42222: NOT
42223: OR
42224: IFFALSE 42228
// exit ;
42226: GO 42253
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42228: LD_ADDR_EXP 77
42232: PUSH
42233: LD_EXP 77
42237: PPUSH
42238: LD_VAR 0 1
42242: PPUSH
42243: LD_VAR 0 2
42247: PPUSH
42248: CALL_OW 1
42252: ST_TO_ADDR
// end ;
42253: LD_VAR 0 3
42257: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42258: LD_INT 0
42260: PPUSH
// if not mc_bases or not parking_area or not base then
42261: LD_EXP 50
42265: NOT
42266: PUSH
42267: LD_VAR 0 2
42271: NOT
42272: OR
42273: PUSH
42274: LD_VAR 0 1
42278: NOT
42279: OR
42280: IFFALSE 42284
// exit ;
42282: GO 42309
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
42284: LD_ADDR_EXP 74
42288: PUSH
42289: LD_EXP 74
42293: PPUSH
42294: LD_VAR 0 1
42298: PPUSH
42299: LD_VAR 0 2
42303: PPUSH
42304: CALL_OW 1
42308: ST_TO_ADDR
// end ;
42309: LD_VAR 0 3
42313: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
42314: LD_INT 0
42316: PPUSH
// if not mc_bases or not base or not scan_area then
42317: LD_EXP 50
42321: NOT
42322: PUSH
42323: LD_VAR 0 1
42327: NOT
42328: OR
42329: PUSH
42330: LD_VAR 0 2
42334: NOT
42335: OR
42336: IFFALSE 42340
// exit ;
42338: GO 42365
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
42340: LD_ADDR_EXP 75
42344: PUSH
42345: LD_EXP 75
42349: PPUSH
42350: LD_VAR 0 1
42354: PPUSH
42355: LD_VAR 0 2
42359: PPUSH
42360: CALL_OW 1
42364: ST_TO_ADDR
// end ;
42365: LD_VAR 0 3
42369: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
42370: LD_INT 0
42372: PPUSH
42373: PPUSH
// if not mc_bases or not base then
42374: LD_EXP 50
42378: NOT
42379: PUSH
42380: LD_VAR 0 1
42384: NOT
42385: OR
42386: IFFALSE 42390
// exit ;
42388: GO 42454
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
42390: LD_ADDR_VAR 0 3
42394: PUSH
42395: LD_INT 1
42397: PUSH
42398: LD_INT 2
42400: PUSH
42401: LD_INT 3
42403: PUSH
42404: LD_INT 4
42406: PUSH
42407: LD_INT 11
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: LIST
42414: LIST
42415: LIST
42416: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
42417: LD_ADDR_EXP 77
42421: PUSH
42422: LD_EXP 77
42426: PPUSH
42427: LD_VAR 0 1
42431: PPUSH
42432: LD_EXP 77
42436: PUSH
42437: LD_VAR 0 1
42441: ARRAY
42442: PUSH
42443: LD_VAR 0 3
42447: DIFF
42448: PPUSH
42449: CALL_OW 1
42453: ST_TO_ADDR
// end ;
42454: LD_VAR 0 2
42458: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
42459: LD_INT 0
42461: PPUSH
// result := mc_vehicles [ base ] ;
42462: LD_ADDR_VAR 0 3
42466: PUSH
42467: LD_EXP 69
42471: PUSH
42472: LD_VAR 0 1
42476: ARRAY
42477: ST_TO_ADDR
// if onlyCombat then
42478: LD_VAR 0 2
42482: IFFALSE 42647
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
42484: LD_ADDR_VAR 0 3
42488: PUSH
42489: LD_VAR 0 3
42493: PUSH
42494: LD_VAR 0 3
42498: PPUSH
42499: LD_INT 2
42501: PUSH
42502: LD_INT 34
42504: PUSH
42505: LD_INT 12
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 34
42514: PUSH
42515: LD_INT 51
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 34
42524: PUSH
42525: LD_EXP 94
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 34
42536: PUSH
42537: LD_INT 32
42539: PUSH
42540: EMPTY
42541: LIST
42542: LIST
42543: PUSH
42544: LD_INT 34
42546: PUSH
42547: LD_INT 13
42549: PUSH
42550: EMPTY
42551: LIST
42552: LIST
42553: PUSH
42554: LD_INT 34
42556: PUSH
42557: LD_INT 52
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: LD_INT 34
42566: PUSH
42567: LD_INT 14
42569: PUSH
42570: EMPTY
42571: LIST
42572: LIST
42573: PUSH
42574: LD_INT 34
42576: PUSH
42577: LD_INT 53
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 34
42586: PUSH
42587: LD_EXP 93
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PUSH
42596: LD_INT 34
42598: PUSH
42599: LD_INT 31
42601: PUSH
42602: EMPTY
42603: LIST
42604: LIST
42605: PUSH
42606: LD_INT 34
42608: PUSH
42609: LD_INT 48
42611: PUSH
42612: EMPTY
42613: LIST
42614: LIST
42615: PUSH
42616: LD_INT 34
42618: PUSH
42619: LD_INT 8
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: LIST
42634: LIST
42635: LIST
42636: LIST
42637: LIST
42638: LIST
42639: LIST
42640: PPUSH
42641: CALL_OW 72
42645: DIFF
42646: ST_TO_ADDR
// end ; end_of_file
42647: LD_VAR 0 3
42651: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
42652: LD_INT 0
42654: PPUSH
42655: PPUSH
42656: PPUSH
// if not mc_bases or not skirmish then
42657: LD_EXP 50
42661: NOT
42662: PUSH
42663: LD_EXP 48
42667: NOT
42668: OR
42669: IFFALSE 42673
// exit ;
42671: GO 42838
// for i = 1 to mc_bases do
42673: LD_ADDR_VAR 0 4
42677: PUSH
42678: DOUBLE
42679: LD_INT 1
42681: DEC
42682: ST_TO_ADDR
42683: LD_EXP 50
42687: PUSH
42688: FOR_TO
42689: IFFALSE 42836
// begin if sci in mc_bases [ i ] then
42691: LD_VAR 0 2
42695: PUSH
42696: LD_EXP 50
42700: PUSH
42701: LD_VAR 0 4
42705: ARRAY
42706: IN
42707: IFFALSE 42834
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
42709: LD_ADDR_EXP 79
42713: PUSH
42714: LD_EXP 79
42718: PPUSH
42719: LD_VAR 0 4
42723: PUSH
42724: LD_EXP 79
42728: PUSH
42729: LD_VAR 0 4
42733: ARRAY
42734: PUSH
42735: LD_INT 1
42737: PLUS
42738: PUSH
42739: EMPTY
42740: LIST
42741: LIST
42742: PPUSH
42743: LD_VAR 0 1
42747: PPUSH
42748: CALL 52331 0 3
42752: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
42753: LD_ADDR_VAR 0 5
42757: PUSH
42758: LD_EXP 50
42762: PUSH
42763: LD_VAR 0 4
42767: ARRAY
42768: PPUSH
42769: LD_INT 2
42771: PUSH
42772: LD_INT 30
42774: PUSH
42775: LD_INT 0
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: LD_INT 30
42784: PUSH
42785: LD_INT 1
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: EMPTY
42793: LIST
42794: LIST
42795: LIST
42796: PPUSH
42797: CALL_OW 72
42801: PPUSH
42802: LD_VAR 0 1
42806: PPUSH
42807: CALL_OW 74
42811: ST_TO_ADDR
// if tmp then
42812: LD_VAR 0 5
42816: IFFALSE 42832
// ComStandNearbyBuilding ( ape , tmp ) ;
42818: LD_VAR 0 1
42822: PPUSH
42823: LD_VAR 0 5
42827: PPUSH
42828: CALL 48945 0 2
// break ;
42832: GO 42836
// end ; end ;
42834: GO 42688
42836: POP
42837: POP
// end ;
42838: LD_VAR 0 3
42842: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
42843: LD_INT 0
42845: PPUSH
42846: PPUSH
42847: PPUSH
// if not mc_bases or not skirmish then
42848: LD_EXP 50
42852: NOT
42853: PUSH
42854: LD_EXP 48
42858: NOT
42859: OR
42860: IFFALSE 42864
// exit ;
42862: GO 42953
// for i = 1 to mc_bases do
42864: LD_ADDR_VAR 0 4
42868: PUSH
42869: DOUBLE
42870: LD_INT 1
42872: DEC
42873: ST_TO_ADDR
42874: LD_EXP 50
42878: PUSH
42879: FOR_TO
42880: IFFALSE 42951
// begin if building in mc_busy_turret_list [ i ] then
42882: LD_VAR 0 1
42886: PUSH
42887: LD_EXP 60
42891: PUSH
42892: LD_VAR 0 4
42896: ARRAY
42897: IN
42898: IFFALSE 42949
// begin tmp := mc_busy_turret_list [ i ] diff building ;
42900: LD_ADDR_VAR 0 5
42904: PUSH
42905: LD_EXP 60
42909: PUSH
42910: LD_VAR 0 4
42914: ARRAY
42915: PUSH
42916: LD_VAR 0 1
42920: DIFF
42921: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
42922: LD_ADDR_EXP 60
42926: PUSH
42927: LD_EXP 60
42931: PPUSH
42932: LD_VAR 0 4
42936: PPUSH
42937: LD_VAR 0 5
42941: PPUSH
42942: CALL_OW 1
42946: ST_TO_ADDR
// break ;
42947: GO 42951
// end ; end ;
42949: GO 42879
42951: POP
42952: POP
// end ;
42953: LD_VAR 0 3
42957: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
42958: LD_INT 0
42960: PPUSH
42961: PPUSH
42962: PPUSH
// if not mc_bases or not skirmish then
42963: LD_EXP 50
42967: NOT
42968: PUSH
42969: LD_EXP 48
42973: NOT
42974: OR
42975: IFFALSE 42979
// exit ;
42977: GO 43178
// for i = 1 to mc_bases do
42979: LD_ADDR_VAR 0 5
42983: PUSH
42984: DOUBLE
42985: LD_INT 1
42987: DEC
42988: ST_TO_ADDR
42989: LD_EXP 50
42993: PUSH
42994: FOR_TO
42995: IFFALSE 43176
// if building in mc_bases [ i ] then
42997: LD_VAR 0 1
43001: PUSH
43002: LD_EXP 50
43006: PUSH
43007: LD_VAR 0 5
43011: ARRAY
43012: IN
43013: IFFALSE 43174
// begin tmp := mc_bases [ i ] diff building ;
43015: LD_ADDR_VAR 0 6
43019: PUSH
43020: LD_EXP 50
43024: PUSH
43025: LD_VAR 0 5
43029: ARRAY
43030: PUSH
43031: LD_VAR 0 1
43035: DIFF
43036: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
43037: LD_ADDR_EXP 50
43041: PUSH
43042: LD_EXP 50
43046: PPUSH
43047: LD_VAR 0 5
43051: PPUSH
43052: LD_VAR 0 6
43056: PPUSH
43057: CALL_OW 1
43061: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
43062: LD_VAR 0 1
43066: PUSH
43067: LD_EXP 58
43071: PUSH
43072: LD_VAR 0 5
43076: ARRAY
43077: IN
43078: IFFALSE 43117
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
43080: LD_ADDR_EXP 58
43084: PUSH
43085: LD_EXP 58
43089: PPUSH
43090: LD_VAR 0 5
43094: PPUSH
43095: LD_EXP 58
43099: PUSH
43100: LD_VAR 0 5
43104: ARRAY
43105: PUSH
43106: LD_VAR 0 1
43110: DIFF
43111: PPUSH
43112: CALL_OW 1
43116: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
43117: LD_VAR 0 1
43121: PUSH
43122: LD_EXP 59
43126: PUSH
43127: LD_VAR 0 5
43131: ARRAY
43132: IN
43133: IFFALSE 43172
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
43135: LD_ADDR_EXP 59
43139: PUSH
43140: LD_EXP 59
43144: PPUSH
43145: LD_VAR 0 5
43149: PPUSH
43150: LD_EXP 59
43154: PUSH
43155: LD_VAR 0 5
43159: ARRAY
43160: PUSH
43161: LD_VAR 0 1
43165: DIFF
43166: PPUSH
43167: CALL_OW 1
43171: ST_TO_ADDR
// break ;
43172: GO 43176
// end ;
43174: GO 42994
43176: POP
43177: POP
// end ;
43178: LD_VAR 0 4
43182: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43183: LD_INT 0
43185: PPUSH
43186: PPUSH
43187: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43188: LD_EXP 50
43192: NOT
43193: PUSH
43194: LD_EXP 48
43198: NOT
43199: OR
43200: PUSH
43201: LD_VAR 0 3
43205: PUSH
43206: LD_EXP 76
43210: IN
43211: NOT
43212: OR
43213: IFFALSE 43217
// exit ;
43215: GO 43340
// for i = 1 to mc_vehicles do
43217: LD_ADDR_VAR 0 6
43221: PUSH
43222: DOUBLE
43223: LD_INT 1
43225: DEC
43226: ST_TO_ADDR
43227: LD_EXP 69
43231: PUSH
43232: FOR_TO
43233: IFFALSE 43338
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43235: LD_VAR 0 2
43239: PUSH
43240: LD_EXP 69
43244: PUSH
43245: LD_VAR 0 6
43249: ARRAY
43250: IN
43251: PUSH
43252: LD_VAR 0 1
43256: PUSH
43257: LD_EXP 69
43261: PUSH
43262: LD_VAR 0 6
43266: ARRAY
43267: IN
43268: OR
43269: IFFALSE 43336
// begin tmp := mc_vehicles [ i ] diff old ;
43271: LD_ADDR_VAR 0 7
43275: PUSH
43276: LD_EXP 69
43280: PUSH
43281: LD_VAR 0 6
43285: ARRAY
43286: PUSH
43287: LD_VAR 0 2
43291: DIFF
43292: ST_TO_ADDR
// tmp := tmp diff new ;
43293: LD_ADDR_VAR 0 7
43297: PUSH
43298: LD_VAR 0 7
43302: PUSH
43303: LD_VAR 0 1
43307: DIFF
43308: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
43309: LD_ADDR_EXP 69
43313: PUSH
43314: LD_EXP 69
43318: PPUSH
43319: LD_VAR 0 6
43323: PPUSH
43324: LD_VAR 0 7
43328: PPUSH
43329: CALL_OW 1
43333: ST_TO_ADDR
// break ;
43334: GO 43338
// end ;
43336: GO 43232
43338: POP
43339: POP
// end ;
43340: LD_VAR 0 5
43344: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
43345: LD_INT 0
43347: PPUSH
43348: PPUSH
43349: PPUSH
43350: PPUSH
// if not mc_bases or not skirmish then
43351: LD_EXP 50
43355: NOT
43356: PUSH
43357: LD_EXP 48
43361: NOT
43362: OR
43363: IFFALSE 43367
// exit ;
43365: GO 43744
// side := GetSide ( vehicle ) ;
43367: LD_ADDR_VAR 0 5
43371: PUSH
43372: LD_VAR 0 1
43376: PPUSH
43377: CALL_OW 255
43381: ST_TO_ADDR
// for i = 1 to mc_bases do
43382: LD_ADDR_VAR 0 4
43386: PUSH
43387: DOUBLE
43388: LD_INT 1
43390: DEC
43391: ST_TO_ADDR
43392: LD_EXP 50
43396: PUSH
43397: FOR_TO
43398: IFFALSE 43742
// begin if factory in mc_bases [ i ] then
43400: LD_VAR 0 2
43404: PUSH
43405: LD_EXP 50
43409: PUSH
43410: LD_VAR 0 4
43414: ARRAY
43415: IN
43416: IFFALSE 43740
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
43418: LD_EXP 72
43422: PUSH
43423: LD_VAR 0 4
43427: ARRAY
43428: PUSH
43429: LD_EXP 61
43433: PUSH
43434: LD_VAR 0 4
43438: ARRAY
43439: LESS
43440: PUSH
43441: LD_VAR 0 1
43445: PPUSH
43446: CALL_OW 264
43450: PUSH
43451: LD_INT 31
43453: PUSH
43454: LD_INT 32
43456: PUSH
43457: LD_INT 51
43459: PUSH
43460: LD_EXP 94
43464: PUSH
43465: LD_INT 12
43467: PUSH
43468: LD_INT 30
43470: PUSH
43471: LD_EXP 93
43475: PUSH
43476: LD_INT 11
43478: PUSH
43479: LD_INT 53
43481: PUSH
43482: LD_INT 14
43484: PUSH
43485: LD_EXP 97
43489: PUSH
43490: LD_INT 29
43492: PUSH
43493: LD_EXP 95
43497: PUSH
43498: LD_INT 13
43500: PUSH
43501: LD_INT 52
43503: PUSH
43504: LD_INT 48
43506: PUSH
43507: LD_INT 8
43509: PUSH
43510: EMPTY
43511: LIST
43512: LIST
43513: LIST
43514: LIST
43515: LIST
43516: LIST
43517: LIST
43518: LIST
43519: LIST
43520: LIST
43521: LIST
43522: LIST
43523: LIST
43524: LIST
43525: LIST
43526: LIST
43527: LIST
43528: IN
43529: NOT
43530: AND
43531: IFFALSE 43579
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
43533: LD_ADDR_EXP 72
43537: PUSH
43538: LD_EXP 72
43542: PPUSH
43543: LD_VAR 0 4
43547: PUSH
43548: LD_EXP 72
43552: PUSH
43553: LD_VAR 0 4
43557: ARRAY
43558: PUSH
43559: LD_INT 1
43561: PLUS
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PPUSH
43567: LD_VAR 0 1
43571: PPUSH
43572: CALL 52331 0 3
43576: ST_TO_ADDR
43577: GO 43623
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
43579: LD_ADDR_EXP 69
43583: PUSH
43584: LD_EXP 69
43588: PPUSH
43589: LD_VAR 0 4
43593: PUSH
43594: LD_EXP 69
43598: PUSH
43599: LD_VAR 0 4
43603: ARRAY
43604: PUSH
43605: LD_INT 1
43607: PLUS
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: PPUSH
43613: LD_VAR 0 1
43617: PPUSH
43618: CALL 52331 0 3
43622: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
43623: LD_VAR 0 1
43627: PPUSH
43628: CALL_OW 263
43632: PUSH
43633: LD_INT 2
43635: EQUAL
43636: IFFALSE 43656
// begin repeat wait ( 0 0$1 ) ;
43638: LD_INT 35
43640: PPUSH
43641: CALL_OW 67
// until IsControledBy ( vehicle ) ;
43645: LD_VAR 0 1
43649: PPUSH
43650: CALL_OW 312
43654: IFFALSE 43638
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
43656: LD_VAR 0 1
43660: PPUSH
43661: LD_EXP 74
43665: PUSH
43666: LD_VAR 0 4
43670: ARRAY
43671: PPUSH
43672: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
43676: LD_VAR 0 1
43680: PPUSH
43681: CALL_OW 263
43685: PUSH
43686: LD_INT 1
43688: NONEQUAL
43689: IFFALSE 43693
// break ;
43691: GO 43742
// repeat wait ( 0 0$1 ) ;
43693: LD_INT 35
43695: PPUSH
43696: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
43700: LD_VAR 0 1
43704: PPUSH
43705: LD_EXP 74
43709: PUSH
43710: LD_VAR 0 4
43714: ARRAY
43715: PPUSH
43716: CALL_OW 308
43720: IFFALSE 43693
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
43722: LD_VAR 0 1
43726: PPUSH
43727: CALL_OW 311
43731: PPUSH
43732: CALL_OW 121
// exit ;
43736: POP
43737: POP
43738: GO 43744
// end ; end ;
43740: GO 43397
43742: POP
43743: POP
// end ;
43744: LD_VAR 0 3
43748: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
43749: LD_INT 0
43751: PPUSH
43752: PPUSH
43753: PPUSH
43754: PPUSH
// if not mc_bases or not skirmish then
43755: LD_EXP 50
43759: NOT
43760: PUSH
43761: LD_EXP 48
43765: NOT
43766: OR
43767: IFFALSE 43771
// exit ;
43769: GO 44124
// repeat wait ( 0 0$1 ) ;
43771: LD_INT 35
43773: PPUSH
43774: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
43778: LD_VAR 0 2
43782: PPUSH
43783: LD_VAR 0 3
43787: PPUSH
43788: CALL_OW 284
43792: IFFALSE 43771
// if GetResourceTypeXY ( x , y ) = mat_artefact then
43794: LD_VAR 0 2
43798: PPUSH
43799: LD_VAR 0 3
43803: PPUSH
43804: CALL_OW 283
43808: PUSH
43809: LD_INT 4
43811: EQUAL
43812: IFFALSE 43816
// exit ;
43814: GO 44124
// for i = 1 to mc_bases do
43816: LD_ADDR_VAR 0 7
43820: PUSH
43821: DOUBLE
43822: LD_INT 1
43824: DEC
43825: ST_TO_ADDR
43826: LD_EXP 50
43830: PUSH
43831: FOR_TO
43832: IFFALSE 44122
// begin if mc_crates_area [ i ] then
43834: LD_EXP 68
43838: PUSH
43839: LD_VAR 0 7
43843: ARRAY
43844: IFFALSE 43955
// for j in mc_crates_area [ i ] do
43846: LD_ADDR_VAR 0 8
43850: PUSH
43851: LD_EXP 68
43855: PUSH
43856: LD_VAR 0 7
43860: ARRAY
43861: PUSH
43862: FOR_IN
43863: IFFALSE 43953
// if InArea ( x , y , j ) then
43865: LD_VAR 0 2
43869: PPUSH
43870: LD_VAR 0 3
43874: PPUSH
43875: LD_VAR 0 8
43879: PPUSH
43880: CALL_OW 309
43884: IFFALSE 43951
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43886: LD_ADDR_EXP 66
43890: PUSH
43891: LD_EXP 66
43895: PPUSH
43896: LD_VAR 0 7
43900: PUSH
43901: LD_EXP 66
43905: PUSH
43906: LD_VAR 0 7
43910: ARRAY
43911: PUSH
43912: LD_INT 1
43914: PLUS
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PPUSH
43920: LD_VAR 0 4
43924: PUSH
43925: LD_VAR 0 2
43929: PUSH
43930: LD_VAR 0 3
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: LIST
43939: PPUSH
43940: CALL 52331 0 3
43944: ST_TO_ADDR
// exit ;
43945: POP
43946: POP
43947: POP
43948: POP
43949: GO 44124
// end ;
43951: GO 43862
43953: POP
43954: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43955: LD_ADDR_VAR 0 9
43959: PUSH
43960: LD_EXP 50
43964: PUSH
43965: LD_VAR 0 7
43969: ARRAY
43970: PPUSH
43971: LD_INT 2
43973: PUSH
43974: LD_INT 30
43976: PUSH
43977: LD_INT 0
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: PUSH
43984: LD_INT 30
43986: PUSH
43987: LD_INT 1
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: PUSH
43994: EMPTY
43995: LIST
43996: LIST
43997: LIST
43998: PPUSH
43999: CALL_OW 72
44003: ST_TO_ADDR
// if not depot then
44004: LD_VAR 0 9
44008: NOT
44009: IFFALSE 44013
// continue ;
44011: GO 43831
// for j in depot do
44013: LD_ADDR_VAR 0 8
44017: PUSH
44018: LD_VAR 0 9
44022: PUSH
44023: FOR_IN
44024: IFFALSE 44118
// if GetDistUnitXY ( j , x , y ) < 30 then
44026: LD_VAR 0 8
44030: PPUSH
44031: LD_VAR 0 2
44035: PPUSH
44036: LD_VAR 0 3
44040: PPUSH
44041: CALL_OW 297
44045: PUSH
44046: LD_INT 30
44048: LESS
44049: IFFALSE 44116
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44051: LD_ADDR_EXP 66
44055: PUSH
44056: LD_EXP 66
44060: PPUSH
44061: LD_VAR 0 7
44065: PUSH
44066: LD_EXP 66
44070: PUSH
44071: LD_VAR 0 7
44075: ARRAY
44076: PUSH
44077: LD_INT 1
44079: PLUS
44080: PUSH
44081: EMPTY
44082: LIST
44083: LIST
44084: PPUSH
44085: LD_VAR 0 4
44089: PUSH
44090: LD_VAR 0 2
44094: PUSH
44095: LD_VAR 0 3
44099: PUSH
44100: EMPTY
44101: LIST
44102: LIST
44103: LIST
44104: PPUSH
44105: CALL 52331 0 3
44109: ST_TO_ADDR
// exit ;
44110: POP
44111: POP
44112: POP
44113: POP
44114: GO 44124
// end ;
44116: GO 44023
44118: POP
44119: POP
// end ;
44120: GO 43831
44122: POP
44123: POP
// end ;
44124: LD_VAR 0 6
44128: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
44129: LD_INT 0
44131: PPUSH
44132: PPUSH
44133: PPUSH
44134: PPUSH
// if not mc_bases or not skirmish then
44135: LD_EXP 50
44139: NOT
44140: PUSH
44141: LD_EXP 48
44145: NOT
44146: OR
44147: IFFALSE 44151
// exit ;
44149: GO 44428
// side := GetSide ( lab ) ;
44151: LD_ADDR_VAR 0 4
44155: PUSH
44156: LD_VAR 0 2
44160: PPUSH
44161: CALL_OW 255
44165: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44166: LD_VAR 0 4
44170: PUSH
44171: LD_EXP 76
44175: IN
44176: NOT
44177: PUSH
44178: LD_EXP 77
44182: NOT
44183: OR
44184: PUSH
44185: LD_EXP 50
44189: NOT
44190: OR
44191: IFFALSE 44195
// exit ;
44193: GO 44428
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44195: LD_ADDR_EXP 77
44199: PUSH
44200: LD_EXP 77
44204: PPUSH
44205: LD_VAR 0 4
44209: PPUSH
44210: LD_EXP 77
44214: PUSH
44215: LD_VAR 0 4
44219: ARRAY
44220: PUSH
44221: LD_VAR 0 1
44225: DIFF
44226: PPUSH
44227: CALL_OW 1
44231: ST_TO_ADDR
// for i = 1 to mc_bases do
44232: LD_ADDR_VAR 0 5
44236: PUSH
44237: DOUBLE
44238: LD_INT 1
44240: DEC
44241: ST_TO_ADDR
44242: LD_EXP 50
44246: PUSH
44247: FOR_TO
44248: IFFALSE 44426
// begin if lab in mc_bases [ i ] then
44250: LD_VAR 0 2
44254: PUSH
44255: LD_EXP 50
44259: PUSH
44260: LD_VAR 0 5
44264: ARRAY
44265: IN
44266: IFFALSE 44424
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
44268: LD_VAR 0 1
44272: PUSH
44273: LD_INT 11
44275: PUSH
44276: LD_INT 4
44278: PUSH
44279: LD_INT 3
44281: PUSH
44282: LD_INT 2
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: LIST
44289: LIST
44290: IN
44291: PUSH
44292: LD_EXP 80
44296: PUSH
44297: LD_VAR 0 5
44301: ARRAY
44302: AND
44303: IFFALSE 44424
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
44305: LD_ADDR_VAR 0 6
44309: PUSH
44310: LD_EXP 80
44314: PUSH
44315: LD_VAR 0 5
44319: ARRAY
44320: PUSH
44321: LD_INT 1
44323: ARRAY
44324: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44325: LD_ADDR_EXP 80
44329: PUSH
44330: LD_EXP 80
44334: PPUSH
44335: LD_VAR 0 5
44339: PPUSH
44340: EMPTY
44341: PPUSH
44342: CALL_OW 1
44346: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
44347: LD_VAR 0 6
44351: PPUSH
44352: LD_INT 0
44354: PPUSH
44355: CALL_OW 109
// ComExitBuilding ( tmp ) ;
44359: LD_VAR 0 6
44363: PPUSH
44364: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
44368: LD_ADDR_EXP 79
44372: PUSH
44373: LD_EXP 79
44377: PPUSH
44378: LD_VAR 0 5
44382: PPUSH
44383: LD_EXP 79
44387: PUSH
44388: LD_VAR 0 5
44392: ARRAY
44393: PPUSH
44394: LD_INT 1
44396: PPUSH
44397: LD_VAR 0 6
44401: PPUSH
44402: CALL_OW 2
44406: PPUSH
44407: CALL_OW 1
44411: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
44412: LD_VAR 0 5
44416: PPUSH
44417: LD_INT 112
44419: PPUSH
44420: CALL 21440 0 2
// end ; end ; end ;
44424: GO 44247
44426: POP
44427: POP
// end ;
44428: LD_VAR 0 3
44432: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
44433: LD_INT 0
44435: PPUSH
44436: PPUSH
44437: PPUSH
44438: PPUSH
44439: PPUSH
44440: PPUSH
44441: PPUSH
44442: PPUSH
// if not mc_bases or not skirmish then
44443: LD_EXP 50
44447: NOT
44448: PUSH
44449: LD_EXP 48
44453: NOT
44454: OR
44455: IFFALSE 44459
// exit ;
44457: GO 45830
// for i = 1 to mc_bases do
44459: LD_ADDR_VAR 0 3
44463: PUSH
44464: DOUBLE
44465: LD_INT 1
44467: DEC
44468: ST_TO_ADDR
44469: LD_EXP 50
44473: PUSH
44474: FOR_TO
44475: IFFALSE 45828
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
44477: LD_VAR 0 1
44481: PUSH
44482: LD_EXP 50
44486: PUSH
44487: LD_VAR 0 3
44491: ARRAY
44492: IN
44493: PUSH
44494: LD_VAR 0 1
44498: PUSH
44499: LD_EXP 57
44503: PUSH
44504: LD_VAR 0 3
44508: ARRAY
44509: IN
44510: OR
44511: PUSH
44512: LD_VAR 0 1
44516: PUSH
44517: LD_EXP 72
44521: PUSH
44522: LD_VAR 0 3
44526: ARRAY
44527: IN
44528: OR
44529: PUSH
44530: LD_VAR 0 1
44534: PUSH
44535: LD_EXP 69
44539: PUSH
44540: LD_VAR 0 3
44544: ARRAY
44545: IN
44546: OR
44547: PUSH
44548: LD_VAR 0 1
44552: PUSH
44553: LD_EXP 79
44557: PUSH
44558: LD_VAR 0 3
44562: ARRAY
44563: IN
44564: OR
44565: PUSH
44566: LD_VAR 0 1
44570: PUSH
44571: LD_EXP 80
44575: PUSH
44576: LD_VAR 0 3
44580: ARRAY
44581: IN
44582: OR
44583: IFFALSE 45826
// begin if un in mc_ape [ i ] then
44585: LD_VAR 0 1
44589: PUSH
44590: LD_EXP 79
44594: PUSH
44595: LD_VAR 0 3
44599: ARRAY
44600: IN
44601: IFFALSE 44640
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
44603: LD_ADDR_EXP 79
44607: PUSH
44608: LD_EXP 79
44612: PPUSH
44613: LD_VAR 0 3
44617: PPUSH
44618: LD_EXP 79
44622: PUSH
44623: LD_VAR 0 3
44627: ARRAY
44628: PUSH
44629: LD_VAR 0 1
44633: DIFF
44634: PPUSH
44635: CALL_OW 1
44639: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
44640: LD_VAR 0 1
44644: PUSH
44645: LD_EXP 80
44649: PUSH
44650: LD_VAR 0 3
44654: ARRAY
44655: IN
44656: IFFALSE 44680
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44658: LD_ADDR_EXP 80
44662: PUSH
44663: LD_EXP 80
44667: PPUSH
44668: LD_VAR 0 3
44672: PPUSH
44673: EMPTY
44674: PPUSH
44675: CALL_OW 1
44679: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
44680: LD_VAR 0 1
44684: PPUSH
44685: CALL_OW 247
44689: PUSH
44690: LD_INT 2
44692: EQUAL
44693: PUSH
44694: LD_VAR 0 1
44698: PPUSH
44699: CALL_OW 110
44703: PUSH
44704: LD_INT 20
44706: EQUAL
44707: PUSH
44708: LD_VAR 0 1
44712: PUSH
44713: LD_EXP 72
44717: PUSH
44718: LD_VAR 0 3
44722: ARRAY
44723: IN
44724: OR
44725: PUSH
44726: LD_VAR 0 1
44730: PPUSH
44731: CALL_OW 264
44735: PUSH
44736: LD_INT 12
44738: PUSH
44739: LD_INT 51
44741: PUSH
44742: LD_EXP 94
44746: PUSH
44747: LD_INT 32
44749: PUSH
44750: LD_INT 13
44752: PUSH
44753: LD_INT 52
44755: PUSH
44756: LD_INT 31
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: LIST
44763: LIST
44764: LIST
44765: LIST
44766: LIST
44767: IN
44768: OR
44769: AND
44770: IFFALSE 45078
// begin if un in mc_defender [ i ] then
44772: LD_VAR 0 1
44776: PUSH
44777: LD_EXP 72
44781: PUSH
44782: LD_VAR 0 3
44786: ARRAY
44787: IN
44788: IFFALSE 44827
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
44790: LD_ADDR_EXP 72
44794: PUSH
44795: LD_EXP 72
44799: PPUSH
44800: LD_VAR 0 3
44804: PPUSH
44805: LD_EXP 72
44809: PUSH
44810: LD_VAR 0 3
44814: ARRAY
44815: PUSH
44816: LD_VAR 0 1
44820: DIFF
44821: PPUSH
44822: CALL_OW 1
44826: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
44827: LD_ADDR_VAR 0 8
44831: PUSH
44832: LD_VAR 0 3
44836: PPUSH
44837: LD_INT 3
44839: PPUSH
44840: CALL 41496 0 2
44844: ST_TO_ADDR
// if fac then
44845: LD_VAR 0 8
44849: IFFALSE 45078
// begin for j in fac do
44851: LD_ADDR_VAR 0 4
44855: PUSH
44856: LD_VAR 0 8
44860: PUSH
44861: FOR_IN
44862: IFFALSE 45076
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
44864: LD_ADDR_VAR 0 9
44868: PUSH
44869: LD_VAR 0 8
44873: PPUSH
44874: LD_VAR 0 1
44878: PPUSH
44879: CALL_OW 265
44883: PPUSH
44884: LD_VAR 0 1
44888: PPUSH
44889: CALL_OW 262
44893: PPUSH
44894: LD_VAR 0 1
44898: PPUSH
44899: CALL_OW 263
44903: PPUSH
44904: LD_VAR 0 1
44908: PPUSH
44909: CALL_OW 264
44913: PPUSH
44914: CALL 49863 0 5
44918: ST_TO_ADDR
// if components then
44919: LD_VAR 0 9
44923: IFFALSE 45074
// begin if GetWeapon ( un ) = ar_control_tower then
44925: LD_VAR 0 1
44929: PPUSH
44930: CALL_OW 264
44934: PUSH
44935: LD_INT 31
44937: EQUAL
44938: IFFALSE 45055
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
44940: LD_VAR 0 1
44944: PPUSH
44945: CALL_OW 311
44949: PPUSH
44950: LD_INT 0
44952: PPUSH
44953: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
44957: LD_ADDR_EXP 90
44961: PUSH
44962: LD_EXP 90
44966: PPUSH
44967: LD_VAR 0 3
44971: PPUSH
44972: LD_EXP 90
44976: PUSH
44977: LD_VAR 0 3
44981: ARRAY
44982: PUSH
44983: LD_VAR 0 1
44987: PPUSH
44988: CALL_OW 311
44992: DIFF
44993: PPUSH
44994: CALL_OW 1
44998: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
44999: LD_ADDR_VAR 0 7
45003: PUSH
45004: LD_EXP 71
45008: PUSH
45009: LD_VAR 0 3
45013: ARRAY
45014: PPUSH
45015: LD_INT 1
45017: PPUSH
45018: LD_VAR 0 9
45022: PPUSH
45023: CALL_OW 2
45027: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
45028: LD_ADDR_EXP 71
45032: PUSH
45033: LD_EXP 71
45037: PPUSH
45038: LD_VAR 0 3
45042: PPUSH
45043: LD_VAR 0 7
45047: PPUSH
45048: CALL_OW 1
45052: ST_TO_ADDR
// end else
45053: GO 45072
// MC_InsertProduceList ( i , [ components ] ) ;
45055: LD_VAR 0 3
45059: PPUSH
45060: LD_VAR 0 9
45064: PUSH
45065: EMPTY
45066: LIST
45067: PPUSH
45068: CALL 41041 0 2
// break ;
45072: GO 45076
// end ; end ;
45074: GO 44861
45076: POP
45077: POP
// end ; end ; if GetType ( un ) = unit_building then
45078: LD_VAR 0 1
45082: PPUSH
45083: CALL_OW 247
45087: PUSH
45088: LD_INT 3
45090: EQUAL
45091: IFFALSE 45494
// begin btype := GetBType ( un ) ;
45093: LD_ADDR_VAR 0 5
45097: PUSH
45098: LD_VAR 0 1
45102: PPUSH
45103: CALL_OW 266
45107: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
45108: LD_VAR 0 5
45112: PUSH
45113: LD_INT 29
45115: PUSH
45116: LD_INT 30
45118: PUSH
45119: EMPTY
45120: LIST
45121: LIST
45122: IN
45123: IFFALSE 45196
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
45125: LD_VAR 0 1
45129: PPUSH
45130: CALL_OW 250
45134: PPUSH
45135: LD_VAR 0 1
45139: PPUSH
45140: CALL_OW 251
45144: PPUSH
45145: LD_VAR 0 1
45149: PPUSH
45150: CALL_OW 255
45154: PPUSH
45155: CALL_OW 440
45159: NOT
45160: IFFALSE 45196
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45162: LD_VAR 0 1
45166: PPUSH
45167: CALL_OW 250
45171: PPUSH
45172: LD_VAR 0 1
45176: PPUSH
45177: CALL_OW 251
45181: PPUSH
45182: LD_VAR 0 1
45186: PPUSH
45187: CALL_OW 255
45191: PPUSH
45192: CALL_OW 441
// end ; if btype = b_warehouse then
45196: LD_VAR 0 5
45200: PUSH
45201: LD_INT 1
45203: EQUAL
45204: IFFALSE 45222
// begin btype := b_depot ;
45206: LD_ADDR_VAR 0 5
45210: PUSH
45211: LD_INT 0
45213: ST_TO_ADDR
// pos := 1 ;
45214: LD_ADDR_VAR 0 6
45218: PUSH
45219: LD_INT 1
45221: ST_TO_ADDR
// end ; if btype = b_factory then
45222: LD_VAR 0 5
45226: PUSH
45227: LD_INT 3
45229: EQUAL
45230: IFFALSE 45248
// begin btype := b_workshop ;
45232: LD_ADDR_VAR 0 5
45236: PUSH
45237: LD_INT 2
45239: ST_TO_ADDR
// pos := 1 ;
45240: LD_ADDR_VAR 0 6
45244: PUSH
45245: LD_INT 1
45247: ST_TO_ADDR
// end ; if btype = b_barracks then
45248: LD_VAR 0 5
45252: PUSH
45253: LD_INT 5
45255: EQUAL
45256: IFFALSE 45266
// btype := b_armoury ;
45258: LD_ADDR_VAR 0 5
45262: PUSH
45263: LD_INT 4
45265: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
45266: LD_VAR 0 5
45270: PUSH
45271: LD_INT 7
45273: PUSH
45274: LD_INT 8
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: IN
45281: IFFALSE 45291
// btype := b_lab ;
45283: LD_ADDR_VAR 0 5
45287: PUSH
45288: LD_INT 6
45290: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
45291: LD_ADDR_EXP 55
45295: PUSH
45296: LD_EXP 55
45300: PPUSH
45301: LD_VAR 0 3
45305: PUSH
45306: LD_EXP 55
45310: PUSH
45311: LD_VAR 0 3
45315: ARRAY
45316: PUSH
45317: LD_INT 1
45319: PLUS
45320: PUSH
45321: EMPTY
45322: LIST
45323: LIST
45324: PPUSH
45325: LD_VAR 0 5
45329: PUSH
45330: LD_VAR 0 1
45334: PPUSH
45335: CALL_OW 250
45339: PUSH
45340: LD_VAR 0 1
45344: PPUSH
45345: CALL_OW 251
45349: PUSH
45350: LD_VAR 0 1
45354: PPUSH
45355: CALL_OW 254
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: PPUSH
45366: CALL 52331 0 3
45370: ST_TO_ADDR
// if pos = 1 then
45371: LD_VAR 0 6
45375: PUSH
45376: LD_INT 1
45378: EQUAL
45379: IFFALSE 45494
// begin tmp := mc_build_list [ i ] ;
45381: LD_ADDR_VAR 0 7
45385: PUSH
45386: LD_EXP 55
45390: PUSH
45391: LD_VAR 0 3
45395: ARRAY
45396: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45397: LD_VAR 0 7
45401: PPUSH
45402: LD_INT 2
45404: PUSH
45405: LD_INT 30
45407: PUSH
45408: LD_INT 0
45410: PUSH
45411: EMPTY
45412: LIST
45413: LIST
45414: PUSH
45415: LD_INT 30
45417: PUSH
45418: LD_INT 1
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: LIST
45429: PPUSH
45430: CALL_OW 72
45434: IFFALSE 45444
// pos := 2 ;
45436: LD_ADDR_VAR 0 6
45440: PUSH
45441: LD_INT 2
45443: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
45444: LD_ADDR_VAR 0 7
45448: PUSH
45449: LD_VAR 0 7
45453: PPUSH
45454: LD_VAR 0 6
45458: PPUSH
45459: LD_VAR 0 7
45463: PPUSH
45464: CALL 52657 0 3
45468: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
45469: LD_ADDR_EXP 55
45473: PUSH
45474: LD_EXP 55
45478: PPUSH
45479: LD_VAR 0 3
45483: PPUSH
45484: LD_VAR 0 7
45488: PPUSH
45489: CALL_OW 1
45493: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
45494: LD_VAR 0 1
45498: PUSH
45499: LD_EXP 50
45503: PUSH
45504: LD_VAR 0 3
45508: ARRAY
45509: IN
45510: IFFALSE 45549
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
45512: LD_ADDR_EXP 50
45516: PUSH
45517: LD_EXP 50
45521: PPUSH
45522: LD_VAR 0 3
45526: PPUSH
45527: LD_EXP 50
45531: PUSH
45532: LD_VAR 0 3
45536: ARRAY
45537: PUSH
45538: LD_VAR 0 1
45542: DIFF
45543: PPUSH
45544: CALL_OW 1
45548: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
45549: LD_VAR 0 1
45553: PUSH
45554: LD_EXP 57
45558: PUSH
45559: LD_VAR 0 3
45563: ARRAY
45564: IN
45565: IFFALSE 45604
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
45567: LD_ADDR_EXP 57
45571: PUSH
45572: LD_EXP 57
45576: PPUSH
45577: LD_VAR 0 3
45581: PPUSH
45582: LD_EXP 57
45586: PUSH
45587: LD_VAR 0 3
45591: ARRAY
45592: PUSH
45593: LD_VAR 0 1
45597: DIFF
45598: PPUSH
45599: CALL_OW 1
45603: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
45604: LD_VAR 0 1
45608: PUSH
45609: LD_EXP 69
45613: PUSH
45614: LD_VAR 0 3
45618: ARRAY
45619: IN
45620: IFFALSE 45659
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
45622: LD_ADDR_EXP 69
45626: PUSH
45627: LD_EXP 69
45631: PPUSH
45632: LD_VAR 0 3
45636: PPUSH
45637: LD_EXP 69
45641: PUSH
45642: LD_VAR 0 3
45646: ARRAY
45647: PUSH
45648: LD_VAR 0 1
45652: DIFF
45653: PPUSH
45654: CALL_OW 1
45658: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
45659: LD_VAR 0 1
45663: PUSH
45664: LD_EXP 72
45668: PUSH
45669: LD_VAR 0 3
45673: ARRAY
45674: IN
45675: IFFALSE 45714
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45677: LD_ADDR_EXP 72
45681: PUSH
45682: LD_EXP 72
45686: PPUSH
45687: LD_VAR 0 3
45691: PPUSH
45692: LD_EXP 72
45696: PUSH
45697: LD_VAR 0 3
45701: ARRAY
45702: PUSH
45703: LD_VAR 0 1
45707: DIFF
45708: PPUSH
45709: CALL_OW 1
45713: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
45714: LD_VAR 0 1
45718: PUSH
45719: LD_EXP 59
45723: PUSH
45724: LD_VAR 0 3
45728: ARRAY
45729: IN
45730: IFFALSE 45769
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
45732: LD_ADDR_EXP 59
45736: PUSH
45737: LD_EXP 59
45741: PPUSH
45742: LD_VAR 0 3
45746: PPUSH
45747: LD_EXP 59
45751: PUSH
45752: LD_VAR 0 3
45756: ARRAY
45757: PUSH
45758: LD_VAR 0 1
45762: DIFF
45763: PPUSH
45764: CALL_OW 1
45768: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
45769: LD_VAR 0 1
45773: PUSH
45774: LD_EXP 58
45778: PUSH
45779: LD_VAR 0 3
45783: ARRAY
45784: IN
45785: IFFALSE 45824
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
45787: LD_ADDR_EXP 58
45791: PUSH
45792: LD_EXP 58
45796: PPUSH
45797: LD_VAR 0 3
45801: PPUSH
45802: LD_EXP 58
45806: PUSH
45807: LD_VAR 0 3
45811: ARRAY
45812: PUSH
45813: LD_VAR 0 1
45817: DIFF
45818: PPUSH
45819: CALL_OW 1
45823: ST_TO_ADDR
// end ; break ;
45824: GO 45828
// end ;
45826: GO 44474
45828: POP
45829: POP
// end ;
45830: LD_VAR 0 2
45834: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
45835: LD_INT 0
45837: PPUSH
45838: PPUSH
45839: PPUSH
// if not mc_bases or not skirmish then
45840: LD_EXP 50
45844: NOT
45845: PUSH
45846: LD_EXP 48
45850: NOT
45851: OR
45852: IFFALSE 45856
// exit ;
45854: GO 46071
// for i = 1 to mc_bases do
45856: LD_ADDR_VAR 0 3
45860: PUSH
45861: DOUBLE
45862: LD_INT 1
45864: DEC
45865: ST_TO_ADDR
45866: LD_EXP 50
45870: PUSH
45871: FOR_TO
45872: IFFALSE 46069
// begin if building in mc_construct_list [ i ] then
45874: LD_VAR 0 1
45878: PUSH
45879: LD_EXP 57
45883: PUSH
45884: LD_VAR 0 3
45888: ARRAY
45889: IN
45890: IFFALSE 46067
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
45892: LD_ADDR_EXP 57
45896: PUSH
45897: LD_EXP 57
45901: PPUSH
45902: LD_VAR 0 3
45906: PPUSH
45907: LD_EXP 57
45911: PUSH
45912: LD_VAR 0 3
45916: ARRAY
45917: PUSH
45918: LD_VAR 0 1
45922: DIFF
45923: PPUSH
45924: CALL_OW 1
45928: ST_TO_ADDR
// if building in mc_lab [ i ] then
45929: LD_VAR 0 1
45933: PUSH
45934: LD_EXP 83
45938: PUSH
45939: LD_VAR 0 3
45943: ARRAY
45944: IN
45945: IFFALSE 46000
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
45947: LD_ADDR_EXP 84
45951: PUSH
45952: LD_EXP 84
45956: PPUSH
45957: LD_VAR 0 3
45961: PPUSH
45962: LD_EXP 84
45966: PUSH
45967: LD_VAR 0 3
45971: ARRAY
45972: PPUSH
45973: LD_INT 1
45975: PPUSH
45976: LD_EXP 84
45980: PUSH
45981: LD_VAR 0 3
45985: ARRAY
45986: PPUSH
45987: LD_INT 0
45989: PPUSH
45990: CALL 51749 0 4
45994: PPUSH
45995: CALL_OW 1
45999: ST_TO_ADDR
// if not building in mc_bases [ i ] then
46000: LD_VAR 0 1
46004: PUSH
46005: LD_EXP 50
46009: PUSH
46010: LD_VAR 0 3
46014: ARRAY
46015: IN
46016: NOT
46017: IFFALSE 46063
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46019: LD_ADDR_EXP 50
46023: PUSH
46024: LD_EXP 50
46028: PPUSH
46029: LD_VAR 0 3
46033: PUSH
46034: LD_EXP 50
46038: PUSH
46039: LD_VAR 0 3
46043: ARRAY
46044: PUSH
46045: LD_INT 1
46047: PLUS
46048: PUSH
46049: EMPTY
46050: LIST
46051: LIST
46052: PPUSH
46053: LD_VAR 0 1
46057: PPUSH
46058: CALL 52331 0 3
46062: ST_TO_ADDR
// exit ;
46063: POP
46064: POP
46065: GO 46071
// end ; end ;
46067: GO 45871
46069: POP
46070: POP
// end ;
46071: LD_VAR 0 2
46075: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
46076: LD_INT 0
46078: PPUSH
46079: PPUSH
46080: PPUSH
46081: PPUSH
46082: PPUSH
46083: PPUSH
46084: PPUSH
// if not mc_bases or not skirmish then
46085: LD_EXP 50
46089: NOT
46090: PUSH
46091: LD_EXP 48
46095: NOT
46096: OR
46097: IFFALSE 46101
// exit ;
46099: GO 46762
// for i = 1 to mc_bases do
46101: LD_ADDR_VAR 0 3
46105: PUSH
46106: DOUBLE
46107: LD_INT 1
46109: DEC
46110: ST_TO_ADDR
46111: LD_EXP 50
46115: PUSH
46116: FOR_TO
46117: IFFALSE 46760
// begin if building in mc_construct_list [ i ] then
46119: LD_VAR 0 1
46123: PUSH
46124: LD_EXP 57
46128: PUSH
46129: LD_VAR 0 3
46133: ARRAY
46134: IN
46135: IFFALSE 46758
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46137: LD_ADDR_EXP 57
46141: PUSH
46142: LD_EXP 57
46146: PPUSH
46147: LD_VAR 0 3
46151: PPUSH
46152: LD_EXP 57
46156: PUSH
46157: LD_VAR 0 3
46161: ARRAY
46162: PUSH
46163: LD_VAR 0 1
46167: DIFF
46168: PPUSH
46169: CALL_OW 1
46173: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46174: LD_ADDR_EXP 50
46178: PUSH
46179: LD_EXP 50
46183: PPUSH
46184: LD_VAR 0 3
46188: PUSH
46189: LD_EXP 50
46193: PUSH
46194: LD_VAR 0 3
46198: ARRAY
46199: PUSH
46200: LD_INT 1
46202: PLUS
46203: PUSH
46204: EMPTY
46205: LIST
46206: LIST
46207: PPUSH
46208: LD_VAR 0 1
46212: PPUSH
46213: CALL 52331 0 3
46217: ST_TO_ADDR
// btype := GetBType ( building ) ;
46218: LD_ADDR_VAR 0 5
46222: PUSH
46223: LD_VAR 0 1
46227: PPUSH
46228: CALL_OW 266
46232: ST_TO_ADDR
// side := GetSide ( building ) ;
46233: LD_ADDR_VAR 0 8
46237: PUSH
46238: LD_VAR 0 1
46242: PPUSH
46243: CALL_OW 255
46247: ST_TO_ADDR
// if btype = b_lab then
46248: LD_VAR 0 5
46252: PUSH
46253: LD_INT 6
46255: EQUAL
46256: IFFALSE 46306
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
46258: LD_ADDR_EXP 83
46262: PUSH
46263: LD_EXP 83
46267: PPUSH
46268: LD_VAR 0 3
46272: PUSH
46273: LD_EXP 83
46277: PUSH
46278: LD_VAR 0 3
46282: ARRAY
46283: PUSH
46284: LD_INT 1
46286: PLUS
46287: PUSH
46288: EMPTY
46289: LIST
46290: LIST
46291: PPUSH
46292: LD_VAR 0 1
46296: PPUSH
46297: CALL 52331 0 3
46301: ST_TO_ADDR
// exit ;
46302: POP
46303: POP
46304: GO 46762
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
46306: LD_VAR 0 5
46310: PUSH
46311: LD_INT 0
46313: PUSH
46314: LD_INT 2
46316: PUSH
46317: LD_INT 4
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: LIST
46324: IN
46325: IFFALSE 46449
// begin if btype = b_armoury then
46327: LD_VAR 0 5
46331: PUSH
46332: LD_INT 4
46334: EQUAL
46335: IFFALSE 46345
// btype := b_barracks ;
46337: LD_ADDR_VAR 0 5
46341: PUSH
46342: LD_INT 5
46344: ST_TO_ADDR
// if btype = b_depot then
46345: LD_VAR 0 5
46349: PUSH
46350: LD_INT 0
46352: EQUAL
46353: IFFALSE 46363
// btype := b_warehouse ;
46355: LD_ADDR_VAR 0 5
46359: PUSH
46360: LD_INT 1
46362: ST_TO_ADDR
// if btype = b_workshop then
46363: LD_VAR 0 5
46367: PUSH
46368: LD_INT 2
46370: EQUAL
46371: IFFALSE 46381
// btype := b_factory ;
46373: LD_ADDR_VAR 0 5
46377: PUSH
46378: LD_INT 3
46380: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
46381: LD_VAR 0 5
46385: PPUSH
46386: LD_VAR 0 8
46390: PPUSH
46391: CALL_OW 323
46395: PUSH
46396: LD_INT 1
46398: EQUAL
46399: IFFALSE 46445
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
46401: LD_ADDR_EXP 82
46405: PUSH
46406: LD_EXP 82
46410: PPUSH
46411: LD_VAR 0 3
46415: PUSH
46416: LD_EXP 82
46420: PUSH
46421: LD_VAR 0 3
46425: ARRAY
46426: PUSH
46427: LD_INT 1
46429: PLUS
46430: PUSH
46431: EMPTY
46432: LIST
46433: LIST
46434: PPUSH
46435: LD_VAR 0 1
46439: PPUSH
46440: CALL 52331 0 3
46444: ST_TO_ADDR
// exit ;
46445: POP
46446: POP
46447: GO 46762
// end ; if btype in [ b_bunker , b_turret ] then
46449: LD_VAR 0 5
46453: PUSH
46454: LD_INT 32
46456: PUSH
46457: LD_INT 33
46459: PUSH
46460: EMPTY
46461: LIST
46462: LIST
46463: IN
46464: IFFALSE 46754
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
46466: LD_ADDR_EXP 58
46470: PUSH
46471: LD_EXP 58
46475: PPUSH
46476: LD_VAR 0 3
46480: PUSH
46481: LD_EXP 58
46485: PUSH
46486: LD_VAR 0 3
46490: ARRAY
46491: PUSH
46492: LD_INT 1
46494: PLUS
46495: PUSH
46496: EMPTY
46497: LIST
46498: LIST
46499: PPUSH
46500: LD_VAR 0 1
46504: PPUSH
46505: CALL 52331 0 3
46509: ST_TO_ADDR
// if btype = b_bunker then
46510: LD_VAR 0 5
46514: PUSH
46515: LD_INT 32
46517: EQUAL
46518: IFFALSE 46754
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46520: LD_ADDR_EXP 59
46524: PUSH
46525: LD_EXP 59
46529: PPUSH
46530: LD_VAR 0 3
46534: PUSH
46535: LD_EXP 59
46539: PUSH
46540: LD_VAR 0 3
46544: ARRAY
46545: PUSH
46546: LD_INT 1
46548: PLUS
46549: PUSH
46550: EMPTY
46551: LIST
46552: LIST
46553: PPUSH
46554: LD_VAR 0 1
46558: PPUSH
46559: CALL 52331 0 3
46563: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
46564: LD_ADDR_VAR 0 6
46568: PUSH
46569: LD_EXP 50
46573: PUSH
46574: LD_VAR 0 3
46578: ARRAY
46579: PPUSH
46580: LD_INT 25
46582: PUSH
46583: LD_INT 1
46585: PUSH
46586: EMPTY
46587: LIST
46588: LIST
46589: PUSH
46590: LD_INT 3
46592: PUSH
46593: LD_INT 54
46595: PUSH
46596: EMPTY
46597: LIST
46598: PUSH
46599: EMPTY
46600: LIST
46601: LIST
46602: PUSH
46603: EMPTY
46604: LIST
46605: LIST
46606: PPUSH
46607: CALL_OW 72
46611: ST_TO_ADDR
// if tmp then
46612: LD_VAR 0 6
46616: IFFALSE 46622
// exit ;
46618: POP
46619: POP
46620: GO 46762
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
46622: LD_ADDR_VAR 0 6
46626: PUSH
46627: LD_EXP 50
46631: PUSH
46632: LD_VAR 0 3
46636: ARRAY
46637: PPUSH
46638: LD_INT 2
46640: PUSH
46641: LD_INT 30
46643: PUSH
46644: LD_INT 4
46646: PUSH
46647: EMPTY
46648: LIST
46649: LIST
46650: PUSH
46651: LD_INT 30
46653: PUSH
46654: LD_INT 5
46656: PUSH
46657: EMPTY
46658: LIST
46659: LIST
46660: PUSH
46661: EMPTY
46662: LIST
46663: LIST
46664: LIST
46665: PPUSH
46666: CALL_OW 72
46670: ST_TO_ADDR
// if not tmp then
46671: LD_VAR 0 6
46675: NOT
46676: IFFALSE 46682
// exit ;
46678: POP
46679: POP
46680: GO 46762
// for j in tmp do
46682: LD_ADDR_VAR 0 4
46686: PUSH
46687: LD_VAR 0 6
46691: PUSH
46692: FOR_IN
46693: IFFALSE 46752
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
46695: LD_ADDR_VAR 0 7
46699: PUSH
46700: LD_VAR 0 4
46704: PPUSH
46705: CALL_OW 313
46709: PPUSH
46710: LD_INT 25
46712: PUSH
46713: LD_INT 1
46715: PUSH
46716: EMPTY
46717: LIST
46718: LIST
46719: PPUSH
46720: CALL_OW 72
46724: ST_TO_ADDR
// if units then
46725: LD_VAR 0 7
46729: IFFALSE 46750
// begin ComExitBuilding ( units [ 1 ] ) ;
46731: LD_VAR 0 7
46735: PUSH
46736: LD_INT 1
46738: ARRAY
46739: PPUSH
46740: CALL_OW 122
// exit ;
46744: POP
46745: POP
46746: POP
46747: POP
46748: GO 46762
// end ; end ;
46750: GO 46692
46752: POP
46753: POP
// end ; end ; exit ;
46754: POP
46755: POP
46756: GO 46762
// end ; end ;
46758: GO 46116
46760: POP
46761: POP
// end ;
46762: LD_VAR 0 2
46766: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
46767: LD_INT 0
46769: PPUSH
46770: PPUSH
46771: PPUSH
46772: PPUSH
46773: PPUSH
46774: PPUSH
46775: PPUSH
// if not mc_bases or not skirmish then
46776: LD_EXP 50
46780: NOT
46781: PUSH
46782: LD_EXP 48
46786: NOT
46787: OR
46788: IFFALSE 46792
// exit ;
46790: GO 47023
// btype := GetBType ( building ) ;
46792: LD_ADDR_VAR 0 6
46796: PUSH
46797: LD_VAR 0 1
46801: PPUSH
46802: CALL_OW 266
46806: ST_TO_ADDR
// x := GetX ( building ) ;
46807: LD_ADDR_VAR 0 7
46811: PUSH
46812: LD_VAR 0 1
46816: PPUSH
46817: CALL_OW 250
46821: ST_TO_ADDR
// y := GetY ( building ) ;
46822: LD_ADDR_VAR 0 8
46826: PUSH
46827: LD_VAR 0 1
46831: PPUSH
46832: CALL_OW 251
46836: ST_TO_ADDR
// d := GetDir ( building ) ;
46837: LD_ADDR_VAR 0 9
46841: PUSH
46842: LD_VAR 0 1
46846: PPUSH
46847: CALL_OW 254
46851: ST_TO_ADDR
// for i = 1 to mc_bases do
46852: LD_ADDR_VAR 0 4
46856: PUSH
46857: DOUBLE
46858: LD_INT 1
46860: DEC
46861: ST_TO_ADDR
46862: LD_EXP 50
46866: PUSH
46867: FOR_TO
46868: IFFALSE 47021
// begin if not mc_build_list [ i ] then
46870: LD_EXP 55
46874: PUSH
46875: LD_VAR 0 4
46879: ARRAY
46880: NOT
46881: IFFALSE 46885
// continue ;
46883: GO 46867
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
46885: LD_VAR 0 6
46889: PUSH
46890: LD_VAR 0 7
46894: PUSH
46895: LD_VAR 0 8
46899: PUSH
46900: LD_VAR 0 9
46904: PUSH
46905: EMPTY
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: PPUSH
46911: LD_EXP 55
46915: PUSH
46916: LD_VAR 0 4
46920: ARRAY
46921: PUSH
46922: LD_INT 1
46924: ARRAY
46925: PPUSH
46926: CALL 58500 0 2
46930: IFFALSE 47019
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
46932: LD_ADDR_EXP 55
46936: PUSH
46937: LD_EXP 55
46941: PPUSH
46942: LD_VAR 0 4
46946: PPUSH
46947: LD_EXP 55
46951: PUSH
46952: LD_VAR 0 4
46956: ARRAY
46957: PPUSH
46958: LD_INT 1
46960: PPUSH
46961: CALL_OW 3
46965: PPUSH
46966: CALL_OW 1
46970: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
46971: LD_ADDR_EXP 57
46975: PUSH
46976: LD_EXP 57
46980: PPUSH
46981: LD_VAR 0 4
46985: PUSH
46986: LD_EXP 57
46990: PUSH
46991: LD_VAR 0 4
46995: ARRAY
46996: PUSH
46997: LD_INT 1
46999: PLUS
47000: PUSH
47001: EMPTY
47002: LIST
47003: LIST
47004: PPUSH
47005: LD_VAR 0 1
47009: PPUSH
47010: CALL 52331 0 3
47014: ST_TO_ADDR
// exit ;
47015: POP
47016: POP
47017: GO 47023
// end ; end ;
47019: GO 46867
47021: POP
47022: POP
// end ;
47023: LD_VAR 0 3
47027: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
47028: LD_INT 0
47030: PPUSH
47031: PPUSH
47032: PPUSH
// if not mc_bases or not skirmish then
47033: LD_EXP 50
47037: NOT
47038: PUSH
47039: LD_EXP 48
47043: NOT
47044: OR
47045: IFFALSE 47049
// exit ;
47047: GO 47239
// for i = 1 to mc_bases do
47049: LD_ADDR_VAR 0 4
47053: PUSH
47054: DOUBLE
47055: LD_INT 1
47057: DEC
47058: ST_TO_ADDR
47059: LD_EXP 50
47063: PUSH
47064: FOR_TO
47065: IFFALSE 47152
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
47067: LD_VAR 0 1
47071: PUSH
47072: LD_EXP 58
47076: PUSH
47077: LD_VAR 0 4
47081: ARRAY
47082: IN
47083: PUSH
47084: LD_VAR 0 1
47088: PUSH
47089: LD_EXP 59
47093: PUSH
47094: LD_VAR 0 4
47098: ARRAY
47099: IN
47100: NOT
47101: AND
47102: IFFALSE 47150
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47104: LD_ADDR_EXP 59
47108: PUSH
47109: LD_EXP 59
47113: PPUSH
47114: LD_VAR 0 4
47118: PUSH
47119: LD_EXP 59
47123: PUSH
47124: LD_VAR 0 4
47128: ARRAY
47129: PUSH
47130: LD_INT 1
47132: PLUS
47133: PUSH
47134: EMPTY
47135: LIST
47136: LIST
47137: PPUSH
47138: LD_VAR 0 1
47142: PPUSH
47143: CALL 52331 0 3
47147: ST_TO_ADDR
// break ;
47148: GO 47152
// end ; end ;
47150: GO 47064
47152: POP
47153: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47154: LD_VAR 0 1
47158: PPUSH
47159: CALL_OW 257
47163: PUSH
47164: LD_EXP 76
47168: IN
47169: PUSH
47170: LD_VAR 0 1
47174: PPUSH
47175: CALL_OW 266
47179: PUSH
47180: LD_INT 5
47182: EQUAL
47183: AND
47184: PUSH
47185: LD_VAR 0 2
47189: PPUSH
47190: CALL_OW 110
47194: PUSH
47195: LD_INT 18
47197: NONEQUAL
47198: AND
47199: IFFALSE 47239
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47201: LD_VAR 0 2
47205: PPUSH
47206: CALL_OW 257
47210: PUSH
47211: LD_INT 5
47213: PUSH
47214: LD_INT 8
47216: PUSH
47217: LD_INT 9
47219: PUSH
47220: EMPTY
47221: LIST
47222: LIST
47223: LIST
47224: IN
47225: IFFALSE 47239
// SetClass ( unit , 1 ) ;
47227: LD_VAR 0 2
47231: PPUSH
47232: LD_INT 1
47234: PPUSH
47235: CALL_OW 336
// end ;
47239: LD_VAR 0 3
47243: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
47244: LD_INT 0
47246: PPUSH
47247: PPUSH
// if not mc_bases or not skirmish then
47248: LD_EXP 50
47252: NOT
47253: PUSH
47254: LD_EXP 48
47258: NOT
47259: OR
47260: IFFALSE 47264
// exit ;
47262: GO 47380
// if GetLives ( abandoned_vehicle ) > 250 then
47264: LD_VAR 0 2
47268: PPUSH
47269: CALL_OW 256
47273: PUSH
47274: LD_INT 250
47276: GREATER
47277: IFFALSE 47281
// exit ;
47279: GO 47380
// for i = 1 to mc_bases do
47281: LD_ADDR_VAR 0 6
47285: PUSH
47286: DOUBLE
47287: LD_INT 1
47289: DEC
47290: ST_TO_ADDR
47291: LD_EXP 50
47295: PUSH
47296: FOR_TO
47297: IFFALSE 47378
// begin if driver in mc_bases [ i ] then
47299: LD_VAR 0 1
47303: PUSH
47304: LD_EXP 50
47308: PUSH
47309: LD_VAR 0 6
47313: ARRAY
47314: IN
47315: IFFALSE 47376
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
47317: LD_VAR 0 1
47321: PPUSH
47322: LD_EXP 50
47326: PUSH
47327: LD_VAR 0 6
47331: ARRAY
47332: PPUSH
47333: LD_INT 2
47335: PUSH
47336: LD_INT 30
47338: PUSH
47339: LD_INT 0
47341: PUSH
47342: EMPTY
47343: LIST
47344: LIST
47345: PUSH
47346: LD_INT 30
47348: PUSH
47349: LD_INT 1
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: PUSH
47356: EMPTY
47357: LIST
47358: LIST
47359: LIST
47360: PPUSH
47361: CALL_OW 72
47365: PUSH
47366: LD_INT 1
47368: ARRAY
47369: PPUSH
47370: CALL_OW 112
// break ;
47374: GO 47378
// end ; end ;
47376: GO 47296
47378: POP
47379: POP
// end ; end_of_file
47380: LD_VAR 0 5
47384: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
47385: LD_INT 0
47387: PPUSH
47388: PPUSH
// if exist_mode then
47389: LD_VAR 0 2
47393: IFFALSE 47418
// unit := CreateCharacter ( prefix & ident ) else
47395: LD_ADDR_VAR 0 5
47399: PUSH
47400: LD_VAR 0 3
47404: PUSH
47405: LD_VAR 0 1
47409: STR
47410: PPUSH
47411: CALL_OW 34
47415: ST_TO_ADDR
47416: GO 47433
// unit := NewCharacter ( ident ) ;
47418: LD_ADDR_VAR 0 5
47422: PUSH
47423: LD_VAR 0 1
47427: PPUSH
47428: CALL_OW 25
47432: ST_TO_ADDR
// result := unit ;
47433: LD_ADDR_VAR 0 4
47437: PUSH
47438: LD_VAR 0 5
47442: ST_TO_ADDR
// end ;
47443: LD_VAR 0 4
47447: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
47448: LD_INT 0
47450: PPUSH
47451: PPUSH
// if not side or not nation then
47452: LD_VAR 0 1
47456: NOT
47457: PUSH
47458: LD_VAR 0 2
47462: NOT
47463: OR
47464: IFFALSE 47468
// exit ;
47466: GO 48232
// case nation of nation_american :
47468: LD_VAR 0 2
47472: PUSH
47473: LD_INT 1
47475: DOUBLE
47476: EQUAL
47477: IFTRUE 47481
47479: GO 47695
47481: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
47482: LD_ADDR_VAR 0 4
47486: PUSH
47487: LD_INT 35
47489: PUSH
47490: LD_INT 45
47492: PUSH
47493: LD_INT 46
47495: PUSH
47496: LD_INT 47
47498: PUSH
47499: LD_INT 82
47501: PUSH
47502: LD_INT 83
47504: PUSH
47505: LD_INT 84
47507: PUSH
47508: LD_INT 85
47510: PUSH
47511: LD_INT 86
47513: PUSH
47514: LD_INT 1
47516: PUSH
47517: LD_INT 2
47519: PUSH
47520: LD_INT 6
47522: PUSH
47523: LD_INT 15
47525: PUSH
47526: LD_INT 16
47528: PUSH
47529: LD_INT 7
47531: PUSH
47532: LD_INT 12
47534: PUSH
47535: LD_INT 13
47537: PUSH
47538: LD_INT 10
47540: PUSH
47541: LD_INT 14
47543: PUSH
47544: LD_INT 20
47546: PUSH
47547: LD_INT 21
47549: PUSH
47550: LD_INT 22
47552: PUSH
47553: LD_INT 25
47555: PUSH
47556: LD_INT 32
47558: PUSH
47559: LD_INT 27
47561: PUSH
47562: LD_INT 36
47564: PUSH
47565: LD_INT 69
47567: PUSH
47568: LD_INT 39
47570: PUSH
47571: LD_INT 34
47573: PUSH
47574: LD_INT 40
47576: PUSH
47577: LD_INT 48
47579: PUSH
47580: LD_INT 49
47582: PUSH
47583: LD_INT 50
47585: PUSH
47586: LD_INT 51
47588: PUSH
47589: LD_INT 52
47591: PUSH
47592: LD_INT 53
47594: PUSH
47595: LD_INT 54
47597: PUSH
47598: LD_INT 55
47600: PUSH
47601: LD_INT 56
47603: PUSH
47604: LD_INT 57
47606: PUSH
47607: LD_INT 58
47609: PUSH
47610: LD_INT 59
47612: PUSH
47613: LD_INT 60
47615: PUSH
47616: LD_INT 61
47618: PUSH
47619: LD_INT 62
47621: PUSH
47622: LD_INT 80
47624: PUSH
47625: LD_INT 82
47627: PUSH
47628: LD_INT 83
47630: PUSH
47631: LD_INT 84
47633: PUSH
47634: LD_INT 85
47636: PUSH
47637: LD_INT 86
47639: PUSH
47640: EMPTY
47641: LIST
47642: LIST
47643: LIST
47644: LIST
47645: LIST
47646: LIST
47647: LIST
47648: LIST
47649: LIST
47650: LIST
47651: LIST
47652: LIST
47653: LIST
47654: LIST
47655: LIST
47656: LIST
47657: LIST
47658: LIST
47659: LIST
47660: LIST
47661: LIST
47662: LIST
47663: LIST
47664: LIST
47665: LIST
47666: LIST
47667: LIST
47668: LIST
47669: LIST
47670: LIST
47671: LIST
47672: LIST
47673: LIST
47674: LIST
47675: LIST
47676: LIST
47677: LIST
47678: LIST
47679: LIST
47680: LIST
47681: LIST
47682: LIST
47683: LIST
47684: LIST
47685: LIST
47686: LIST
47687: LIST
47688: LIST
47689: LIST
47690: LIST
47691: LIST
47692: ST_TO_ADDR
47693: GO 48156
47695: LD_INT 2
47697: DOUBLE
47698: EQUAL
47699: IFTRUE 47703
47701: GO 47925
47703: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
47704: LD_ADDR_VAR 0 4
47708: PUSH
47709: LD_INT 35
47711: PUSH
47712: LD_INT 45
47714: PUSH
47715: LD_INT 46
47717: PUSH
47718: LD_INT 47
47720: PUSH
47721: LD_INT 82
47723: PUSH
47724: LD_INT 83
47726: PUSH
47727: LD_INT 84
47729: PUSH
47730: LD_INT 85
47732: PUSH
47733: LD_INT 87
47735: PUSH
47736: LD_INT 70
47738: PUSH
47739: LD_INT 1
47741: PUSH
47742: LD_INT 11
47744: PUSH
47745: LD_INT 3
47747: PUSH
47748: LD_INT 4
47750: PUSH
47751: LD_INT 5
47753: PUSH
47754: LD_INT 6
47756: PUSH
47757: LD_INT 15
47759: PUSH
47760: LD_INT 18
47762: PUSH
47763: LD_INT 7
47765: PUSH
47766: LD_INT 17
47768: PUSH
47769: LD_INT 8
47771: PUSH
47772: LD_INT 20
47774: PUSH
47775: LD_INT 21
47777: PUSH
47778: LD_INT 22
47780: PUSH
47781: LD_INT 72
47783: PUSH
47784: LD_INT 26
47786: PUSH
47787: LD_INT 69
47789: PUSH
47790: LD_INT 39
47792: PUSH
47793: LD_INT 40
47795: PUSH
47796: LD_INT 41
47798: PUSH
47799: LD_INT 42
47801: PUSH
47802: LD_INT 43
47804: PUSH
47805: LD_INT 48
47807: PUSH
47808: LD_INT 49
47810: PUSH
47811: LD_INT 50
47813: PUSH
47814: LD_INT 51
47816: PUSH
47817: LD_INT 52
47819: PUSH
47820: LD_INT 53
47822: PUSH
47823: LD_INT 54
47825: PUSH
47826: LD_INT 55
47828: PUSH
47829: LD_INT 56
47831: PUSH
47832: LD_INT 60
47834: PUSH
47835: LD_INT 61
47837: PUSH
47838: LD_INT 62
47840: PUSH
47841: LD_INT 66
47843: PUSH
47844: LD_INT 67
47846: PUSH
47847: LD_INT 68
47849: PUSH
47850: LD_INT 81
47852: PUSH
47853: LD_INT 82
47855: PUSH
47856: LD_INT 83
47858: PUSH
47859: LD_INT 84
47861: PUSH
47862: LD_INT 85
47864: PUSH
47865: LD_INT 87
47867: PUSH
47868: EMPTY
47869: LIST
47870: LIST
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: LIST
47878: LIST
47879: LIST
47880: LIST
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: LIST
47886: LIST
47887: LIST
47888: LIST
47889: LIST
47890: LIST
47891: LIST
47892: LIST
47893: LIST
47894: LIST
47895: LIST
47896: LIST
47897: LIST
47898: LIST
47899: LIST
47900: LIST
47901: LIST
47902: LIST
47903: LIST
47904: LIST
47905: LIST
47906: LIST
47907: LIST
47908: LIST
47909: LIST
47910: LIST
47911: LIST
47912: LIST
47913: LIST
47914: LIST
47915: LIST
47916: LIST
47917: LIST
47918: LIST
47919: LIST
47920: LIST
47921: LIST
47922: ST_TO_ADDR
47923: GO 48156
47925: LD_INT 3
47927: DOUBLE
47928: EQUAL
47929: IFTRUE 47933
47931: GO 48155
47933: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
47934: LD_ADDR_VAR 0 4
47938: PUSH
47939: LD_INT 46
47941: PUSH
47942: LD_INT 47
47944: PUSH
47945: LD_INT 1
47947: PUSH
47948: LD_INT 2
47950: PUSH
47951: LD_INT 82
47953: PUSH
47954: LD_INT 83
47956: PUSH
47957: LD_INT 84
47959: PUSH
47960: LD_INT 85
47962: PUSH
47963: LD_INT 86
47965: PUSH
47966: LD_INT 11
47968: PUSH
47969: LD_INT 9
47971: PUSH
47972: LD_INT 20
47974: PUSH
47975: LD_INT 19
47977: PUSH
47978: LD_INT 21
47980: PUSH
47981: LD_INT 24
47983: PUSH
47984: LD_INT 22
47986: PUSH
47987: LD_INT 25
47989: PUSH
47990: LD_INT 28
47992: PUSH
47993: LD_INT 29
47995: PUSH
47996: LD_INT 30
47998: PUSH
47999: LD_INT 31
48001: PUSH
48002: LD_INT 37
48004: PUSH
48005: LD_INT 38
48007: PUSH
48008: LD_INT 32
48010: PUSH
48011: LD_INT 27
48013: PUSH
48014: LD_INT 33
48016: PUSH
48017: LD_INT 69
48019: PUSH
48020: LD_INT 39
48022: PUSH
48023: LD_INT 34
48025: PUSH
48026: LD_INT 40
48028: PUSH
48029: LD_INT 71
48031: PUSH
48032: LD_INT 23
48034: PUSH
48035: LD_INT 44
48037: PUSH
48038: LD_INT 48
48040: PUSH
48041: LD_INT 49
48043: PUSH
48044: LD_INT 50
48046: PUSH
48047: LD_INT 51
48049: PUSH
48050: LD_INT 52
48052: PUSH
48053: LD_INT 53
48055: PUSH
48056: LD_INT 54
48058: PUSH
48059: LD_INT 55
48061: PUSH
48062: LD_INT 56
48064: PUSH
48065: LD_INT 57
48067: PUSH
48068: LD_INT 58
48070: PUSH
48071: LD_INT 59
48073: PUSH
48074: LD_INT 63
48076: PUSH
48077: LD_INT 64
48079: PUSH
48080: LD_INT 65
48082: PUSH
48083: LD_INT 82
48085: PUSH
48086: LD_INT 83
48088: PUSH
48089: LD_INT 84
48091: PUSH
48092: LD_INT 85
48094: PUSH
48095: LD_INT 86
48097: PUSH
48098: EMPTY
48099: LIST
48100: LIST
48101: LIST
48102: LIST
48103: LIST
48104: LIST
48105: LIST
48106: LIST
48107: LIST
48108: LIST
48109: LIST
48110: LIST
48111: LIST
48112: LIST
48113: LIST
48114: LIST
48115: LIST
48116: LIST
48117: LIST
48118: LIST
48119: LIST
48120: LIST
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: LIST
48131: LIST
48132: LIST
48133: LIST
48134: LIST
48135: LIST
48136: LIST
48137: LIST
48138: LIST
48139: LIST
48140: LIST
48141: LIST
48142: LIST
48143: LIST
48144: LIST
48145: LIST
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: ST_TO_ADDR
48153: GO 48156
48155: POP
// if state > - 1 and state < 3 then
48156: LD_VAR 0 3
48160: PUSH
48161: LD_INT 1
48163: NEG
48164: GREATER
48165: PUSH
48166: LD_VAR 0 3
48170: PUSH
48171: LD_INT 3
48173: LESS
48174: AND
48175: IFFALSE 48232
// for i in result do
48177: LD_ADDR_VAR 0 5
48181: PUSH
48182: LD_VAR 0 4
48186: PUSH
48187: FOR_IN
48188: IFFALSE 48230
// if GetTech ( i , side ) <> state then
48190: LD_VAR 0 5
48194: PPUSH
48195: LD_VAR 0 1
48199: PPUSH
48200: CALL_OW 321
48204: PUSH
48205: LD_VAR 0 3
48209: NONEQUAL
48210: IFFALSE 48228
// result := result diff i ;
48212: LD_ADDR_VAR 0 4
48216: PUSH
48217: LD_VAR 0 4
48221: PUSH
48222: LD_VAR 0 5
48226: DIFF
48227: ST_TO_ADDR
48228: GO 48187
48230: POP
48231: POP
// end ;
48232: LD_VAR 0 4
48236: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
48237: LD_INT 0
48239: PPUSH
48240: PPUSH
48241: PPUSH
// result := true ;
48242: LD_ADDR_VAR 0 3
48246: PUSH
48247: LD_INT 1
48249: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
48250: LD_ADDR_VAR 0 5
48254: PUSH
48255: LD_VAR 0 2
48259: PPUSH
48260: CALL_OW 480
48264: ST_TO_ADDR
// if not tmp then
48265: LD_VAR 0 5
48269: NOT
48270: IFFALSE 48274
// exit ;
48272: GO 48323
// for i in tmp do
48274: LD_ADDR_VAR 0 4
48278: PUSH
48279: LD_VAR 0 5
48283: PUSH
48284: FOR_IN
48285: IFFALSE 48321
// if GetTech ( i , side ) <> state_researched then
48287: LD_VAR 0 4
48291: PPUSH
48292: LD_VAR 0 1
48296: PPUSH
48297: CALL_OW 321
48301: PUSH
48302: LD_INT 2
48304: NONEQUAL
48305: IFFALSE 48319
// begin result := false ;
48307: LD_ADDR_VAR 0 3
48311: PUSH
48312: LD_INT 0
48314: ST_TO_ADDR
// exit ;
48315: POP
48316: POP
48317: GO 48323
// end ;
48319: GO 48284
48321: POP
48322: POP
// end ;
48323: LD_VAR 0 3
48327: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
48328: LD_INT 0
48330: PPUSH
48331: PPUSH
48332: PPUSH
48333: PPUSH
48334: PPUSH
48335: PPUSH
48336: PPUSH
48337: PPUSH
48338: PPUSH
48339: PPUSH
48340: PPUSH
48341: PPUSH
48342: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
48343: LD_VAR 0 1
48347: NOT
48348: PUSH
48349: LD_VAR 0 1
48353: PPUSH
48354: CALL_OW 257
48358: PUSH
48359: LD_INT 9
48361: NONEQUAL
48362: OR
48363: IFFALSE 48367
// exit ;
48365: GO 48940
// side := GetSide ( unit ) ;
48367: LD_ADDR_VAR 0 9
48371: PUSH
48372: LD_VAR 0 1
48376: PPUSH
48377: CALL_OW 255
48381: ST_TO_ADDR
// tech_space := tech_spacanom ;
48382: LD_ADDR_VAR 0 12
48386: PUSH
48387: LD_INT 29
48389: ST_TO_ADDR
// tech_time := tech_taurad ;
48390: LD_ADDR_VAR 0 13
48394: PUSH
48395: LD_INT 28
48397: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
48398: LD_ADDR_VAR 0 11
48402: PUSH
48403: LD_VAR 0 1
48407: PPUSH
48408: CALL_OW 310
48412: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
48413: LD_VAR 0 11
48417: PPUSH
48418: CALL_OW 247
48422: PUSH
48423: LD_INT 2
48425: EQUAL
48426: IFFALSE 48430
// exit ;
48428: GO 48940
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48430: LD_ADDR_VAR 0 8
48434: PUSH
48435: LD_INT 81
48437: PUSH
48438: LD_VAR 0 9
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: PUSH
48447: LD_INT 3
48449: PUSH
48450: LD_INT 21
48452: PUSH
48453: LD_INT 3
48455: PUSH
48456: EMPTY
48457: LIST
48458: LIST
48459: PUSH
48460: EMPTY
48461: LIST
48462: LIST
48463: PUSH
48464: EMPTY
48465: LIST
48466: LIST
48467: PPUSH
48468: CALL_OW 69
48472: ST_TO_ADDR
// if not tmp then
48473: LD_VAR 0 8
48477: NOT
48478: IFFALSE 48482
// exit ;
48480: GO 48940
// if in_unit then
48482: LD_VAR 0 11
48486: IFFALSE 48510
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
48488: LD_ADDR_VAR 0 10
48492: PUSH
48493: LD_VAR 0 8
48497: PPUSH
48498: LD_VAR 0 11
48502: PPUSH
48503: CALL_OW 74
48507: ST_TO_ADDR
48508: GO 48530
// enemy := NearestUnitToUnit ( tmp , unit ) ;
48510: LD_ADDR_VAR 0 10
48514: PUSH
48515: LD_VAR 0 8
48519: PPUSH
48520: LD_VAR 0 1
48524: PPUSH
48525: CALL_OW 74
48529: ST_TO_ADDR
// if not enemy then
48530: LD_VAR 0 10
48534: NOT
48535: IFFALSE 48539
// exit ;
48537: GO 48940
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
48539: LD_VAR 0 11
48543: PUSH
48544: LD_VAR 0 11
48548: PPUSH
48549: LD_VAR 0 10
48553: PPUSH
48554: CALL_OW 296
48558: PUSH
48559: LD_INT 13
48561: GREATER
48562: AND
48563: PUSH
48564: LD_VAR 0 1
48568: PPUSH
48569: LD_VAR 0 10
48573: PPUSH
48574: CALL_OW 296
48578: PUSH
48579: LD_INT 12
48581: GREATER
48582: OR
48583: IFFALSE 48587
// exit ;
48585: GO 48940
// missile := [ 1 ] ;
48587: LD_ADDR_VAR 0 14
48591: PUSH
48592: LD_INT 1
48594: PUSH
48595: EMPTY
48596: LIST
48597: ST_TO_ADDR
// if Researched ( side , tech_space ) then
48598: LD_VAR 0 9
48602: PPUSH
48603: LD_VAR 0 12
48607: PPUSH
48608: CALL_OW 325
48612: IFFALSE 48641
// missile := Insert ( missile , missile + 1 , 2 ) ;
48614: LD_ADDR_VAR 0 14
48618: PUSH
48619: LD_VAR 0 14
48623: PPUSH
48624: LD_VAR 0 14
48628: PUSH
48629: LD_INT 1
48631: PLUS
48632: PPUSH
48633: LD_INT 2
48635: PPUSH
48636: CALL_OW 2
48640: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
48641: LD_VAR 0 9
48645: PPUSH
48646: LD_VAR 0 13
48650: PPUSH
48651: CALL_OW 325
48655: PUSH
48656: LD_VAR 0 10
48660: PPUSH
48661: CALL_OW 255
48665: PPUSH
48666: LD_VAR 0 13
48670: PPUSH
48671: CALL_OW 325
48675: NOT
48676: AND
48677: IFFALSE 48706
// missile := Insert ( missile , missile + 1 , 3 ) ;
48679: LD_ADDR_VAR 0 14
48683: PUSH
48684: LD_VAR 0 14
48688: PPUSH
48689: LD_VAR 0 14
48693: PUSH
48694: LD_INT 1
48696: PLUS
48697: PPUSH
48698: LD_INT 3
48700: PPUSH
48701: CALL_OW 2
48705: ST_TO_ADDR
// if missile < 2 then
48706: LD_VAR 0 14
48710: PUSH
48711: LD_INT 2
48713: LESS
48714: IFFALSE 48718
// exit ;
48716: GO 48940
// x := GetX ( enemy ) ;
48718: LD_ADDR_VAR 0 4
48722: PUSH
48723: LD_VAR 0 10
48727: PPUSH
48728: CALL_OW 250
48732: ST_TO_ADDR
// y := GetY ( enemy ) ;
48733: LD_ADDR_VAR 0 5
48737: PUSH
48738: LD_VAR 0 10
48742: PPUSH
48743: CALL_OW 251
48747: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
48748: LD_ADDR_VAR 0 6
48752: PUSH
48753: LD_VAR 0 4
48757: PUSH
48758: LD_INT 1
48760: NEG
48761: PPUSH
48762: LD_INT 1
48764: PPUSH
48765: CALL_OW 12
48769: PLUS
48770: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
48771: LD_ADDR_VAR 0 7
48775: PUSH
48776: LD_VAR 0 5
48780: PUSH
48781: LD_INT 1
48783: NEG
48784: PPUSH
48785: LD_INT 1
48787: PPUSH
48788: CALL_OW 12
48792: PLUS
48793: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48794: LD_VAR 0 6
48798: PPUSH
48799: LD_VAR 0 7
48803: PPUSH
48804: CALL_OW 488
48808: NOT
48809: IFFALSE 48831
// begin _x := x ;
48811: LD_ADDR_VAR 0 6
48815: PUSH
48816: LD_VAR 0 4
48820: ST_TO_ADDR
// _y := y ;
48821: LD_ADDR_VAR 0 7
48825: PUSH
48826: LD_VAR 0 5
48830: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
48831: LD_ADDR_VAR 0 3
48835: PUSH
48836: LD_INT 1
48838: PPUSH
48839: LD_VAR 0 14
48843: PPUSH
48844: CALL_OW 12
48848: ST_TO_ADDR
// case i of 1 :
48849: LD_VAR 0 3
48853: PUSH
48854: LD_INT 1
48856: DOUBLE
48857: EQUAL
48858: IFTRUE 48862
48860: GO 48879
48862: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
48863: LD_VAR 0 1
48867: PPUSH
48868: LD_VAR 0 10
48872: PPUSH
48873: CALL_OW 115
48877: GO 48940
48879: LD_INT 2
48881: DOUBLE
48882: EQUAL
48883: IFTRUE 48887
48885: GO 48909
48887: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
48888: LD_VAR 0 1
48892: PPUSH
48893: LD_VAR 0 6
48897: PPUSH
48898: LD_VAR 0 7
48902: PPUSH
48903: CALL_OW 153
48907: GO 48940
48909: LD_INT 3
48911: DOUBLE
48912: EQUAL
48913: IFTRUE 48917
48915: GO 48939
48917: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
48918: LD_VAR 0 1
48922: PPUSH
48923: LD_VAR 0 6
48927: PPUSH
48928: LD_VAR 0 7
48932: PPUSH
48933: CALL_OW 154
48937: GO 48940
48939: POP
// end ;
48940: LD_VAR 0 2
48944: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
48945: LD_INT 0
48947: PPUSH
48948: PPUSH
48949: PPUSH
48950: PPUSH
48951: PPUSH
48952: PPUSH
// if not unit or not building then
48953: LD_VAR 0 1
48957: NOT
48958: PUSH
48959: LD_VAR 0 2
48963: NOT
48964: OR
48965: IFFALSE 48969
// exit ;
48967: GO 49127
// x := GetX ( building ) ;
48969: LD_ADDR_VAR 0 5
48973: PUSH
48974: LD_VAR 0 2
48978: PPUSH
48979: CALL_OW 250
48983: ST_TO_ADDR
// y := GetY ( building ) ;
48984: LD_ADDR_VAR 0 6
48988: PUSH
48989: LD_VAR 0 2
48993: PPUSH
48994: CALL_OW 251
48998: ST_TO_ADDR
// for i = 0 to 5 do
48999: LD_ADDR_VAR 0 4
49003: PUSH
49004: DOUBLE
49005: LD_INT 0
49007: DEC
49008: ST_TO_ADDR
49009: LD_INT 5
49011: PUSH
49012: FOR_TO
49013: IFFALSE 49125
// begin _x := ShiftX ( x , i , 3 ) ;
49015: LD_ADDR_VAR 0 7
49019: PUSH
49020: LD_VAR 0 5
49024: PPUSH
49025: LD_VAR 0 4
49029: PPUSH
49030: LD_INT 3
49032: PPUSH
49033: CALL_OW 272
49037: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
49038: LD_ADDR_VAR 0 8
49042: PUSH
49043: LD_VAR 0 6
49047: PPUSH
49048: LD_VAR 0 4
49052: PPUSH
49053: LD_INT 3
49055: PPUSH
49056: CALL_OW 273
49060: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49061: LD_VAR 0 7
49065: PPUSH
49066: LD_VAR 0 8
49070: PPUSH
49071: CALL_OW 488
49075: NOT
49076: IFFALSE 49080
// continue ;
49078: GO 49012
// if HexInfo ( _x , _y ) = 0 then
49080: LD_VAR 0 7
49084: PPUSH
49085: LD_VAR 0 8
49089: PPUSH
49090: CALL_OW 428
49094: PUSH
49095: LD_INT 0
49097: EQUAL
49098: IFFALSE 49123
// begin ComMoveXY ( unit , _x , _y ) ;
49100: LD_VAR 0 1
49104: PPUSH
49105: LD_VAR 0 7
49109: PPUSH
49110: LD_VAR 0 8
49114: PPUSH
49115: CALL_OW 111
// exit ;
49119: POP
49120: POP
49121: GO 49127
// end ; end ;
49123: GO 49012
49125: POP
49126: POP
// end ;
49127: LD_VAR 0 3
49131: RET
// export function ScanBase ( side , base_area ) ; begin
49132: LD_INT 0
49134: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
49135: LD_ADDR_VAR 0 3
49139: PUSH
49140: LD_VAR 0 2
49144: PPUSH
49145: LD_INT 81
49147: PUSH
49148: LD_VAR 0 1
49152: PUSH
49153: EMPTY
49154: LIST
49155: LIST
49156: PPUSH
49157: CALL_OW 70
49161: ST_TO_ADDR
// end ;
49162: LD_VAR 0 3
49166: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
49167: LD_INT 0
49169: PPUSH
49170: PPUSH
49171: PPUSH
49172: PPUSH
// result := false ;
49173: LD_ADDR_VAR 0 2
49177: PUSH
49178: LD_INT 0
49180: ST_TO_ADDR
// side := GetSide ( unit ) ;
49181: LD_ADDR_VAR 0 3
49185: PUSH
49186: LD_VAR 0 1
49190: PPUSH
49191: CALL_OW 255
49195: ST_TO_ADDR
// nat := GetNation ( unit ) ;
49196: LD_ADDR_VAR 0 4
49200: PUSH
49201: LD_VAR 0 1
49205: PPUSH
49206: CALL_OW 248
49210: ST_TO_ADDR
// case nat of 1 :
49211: LD_VAR 0 4
49215: PUSH
49216: LD_INT 1
49218: DOUBLE
49219: EQUAL
49220: IFTRUE 49224
49222: GO 49235
49224: POP
// tech := tech_lassight ; 2 :
49225: LD_ADDR_VAR 0 5
49229: PUSH
49230: LD_INT 12
49232: ST_TO_ADDR
49233: GO 49274
49235: LD_INT 2
49237: DOUBLE
49238: EQUAL
49239: IFTRUE 49243
49241: GO 49254
49243: POP
// tech := tech_mortar ; 3 :
49244: LD_ADDR_VAR 0 5
49248: PUSH
49249: LD_INT 41
49251: ST_TO_ADDR
49252: GO 49274
49254: LD_INT 3
49256: DOUBLE
49257: EQUAL
49258: IFTRUE 49262
49260: GO 49273
49262: POP
// tech := tech_bazooka ; end ;
49263: LD_ADDR_VAR 0 5
49267: PUSH
49268: LD_INT 44
49270: ST_TO_ADDR
49271: GO 49274
49273: POP
// if Researched ( side , tech ) then
49274: LD_VAR 0 3
49278: PPUSH
49279: LD_VAR 0 5
49283: PPUSH
49284: CALL_OW 325
49288: IFFALSE 49315
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
49290: LD_ADDR_VAR 0 2
49294: PUSH
49295: LD_INT 5
49297: PUSH
49298: LD_INT 8
49300: PUSH
49301: LD_INT 9
49303: PUSH
49304: EMPTY
49305: LIST
49306: LIST
49307: LIST
49308: PUSH
49309: LD_VAR 0 4
49313: ARRAY
49314: ST_TO_ADDR
// end ;
49315: LD_VAR 0 2
49319: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
49320: LD_INT 0
49322: PPUSH
49323: PPUSH
49324: PPUSH
// if not mines then
49325: LD_VAR 0 2
49329: NOT
49330: IFFALSE 49334
// exit ;
49332: GO 49478
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49334: LD_ADDR_VAR 0 5
49338: PUSH
49339: LD_INT 81
49341: PUSH
49342: LD_VAR 0 1
49346: PUSH
49347: EMPTY
49348: LIST
49349: LIST
49350: PUSH
49351: LD_INT 3
49353: PUSH
49354: LD_INT 21
49356: PUSH
49357: LD_INT 3
49359: PUSH
49360: EMPTY
49361: LIST
49362: LIST
49363: PUSH
49364: EMPTY
49365: LIST
49366: LIST
49367: PUSH
49368: EMPTY
49369: LIST
49370: LIST
49371: PPUSH
49372: CALL_OW 69
49376: ST_TO_ADDR
// for i in mines do
49377: LD_ADDR_VAR 0 4
49381: PUSH
49382: LD_VAR 0 2
49386: PUSH
49387: FOR_IN
49388: IFFALSE 49476
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
49390: LD_VAR 0 4
49394: PUSH
49395: LD_INT 1
49397: ARRAY
49398: PPUSH
49399: LD_VAR 0 4
49403: PUSH
49404: LD_INT 2
49406: ARRAY
49407: PPUSH
49408: CALL_OW 458
49412: NOT
49413: IFFALSE 49417
// continue ;
49415: GO 49387
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
49417: LD_VAR 0 4
49421: PUSH
49422: LD_INT 1
49424: ARRAY
49425: PPUSH
49426: LD_VAR 0 4
49430: PUSH
49431: LD_INT 2
49433: ARRAY
49434: PPUSH
49435: CALL_OW 428
49439: PUSH
49440: LD_VAR 0 5
49444: IN
49445: IFFALSE 49474
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
49447: LD_VAR 0 4
49451: PUSH
49452: LD_INT 1
49454: ARRAY
49455: PPUSH
49456: LD_VAR 0 4
49460: PUSH
49461: LD_INT 2
49463: ARRAY
49464: PPUSH
49465: LD_VAR 0 1
49469: PPUSH
49470: CALL_OW 456
// end ;
49474: GO 49387
49476: POP
49477: POP
// end ;
49478: LD_VAR 0 3
49482: RET
// export function Count ( array ) ; var i ; begin
49483: LD_INT 0
49485: PPUSH
49486: PPUSH
// result := 0 ;
49487: LD_ADDR_VAR 0 2
49491: PUSH
49492: LD_INT 0
49494: ST_TO_ADDR
// for i in array do
49495: LD_ADDR_VAR 0 3
49499: PUSH
49500: LD_VAR 0 1
49504: PUSH
49505: FOR_IN
49506: IFFALSE 49530
// if i then
49508: LD_VAR 0 3
49512: IFFALSE 49528
// result := result + 1 ;
49514: LD_ADDR_VAR 0 2
49518: PUSH
49519: LD_VAR 0 2
49523: PUSH
49524: LD_INT 1
49526: PLUS
49527: ST_TO_ADDR
49528: GO 49505
49530: POP
49531: POP
// end ;
49532: LD_VAR 0 2
49536: RET
// export function IsEmpty ( building ) ; begin
49537: LD_INT 0
49539: PPUSH
// if not building then
49540: LD_VAR 0 1
49544: NOT
49545: IFFALSE 49549
// exit ;
49547: GO 49592
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
49549: LD_ADDR_VAR 0 2
49553: PUSH
49554: LD_VAR 0 1
49558: PUSH
49559: LD_INT 22
49561: PUSH
49562: LD_VAR 0 1
49566: PPUSH
49567: CALL_OW 255
49571: PUSH
49572: EMPTY
49573: LIST
49574: LIST
49575: PUSH
49576: LD_INT 58
49578: PUSH
49579: EMPTY
49580: LIST
49581: PUSH
49582: EMPTY
49583: LIST
49584: LIST
49585: PPUSH
49586: CALL_OW 69
49590: IN
49591: ST_TO_ADDR
// end ;
49592: LD_VAR 0 2
49596: RET
// export function IsNotFull ( building ) ; begin
49597: LD_INT 0
49599: PPUSH
// if not building then
49600: LD_VAR 0 1
49604: NOT
49605: IFFALSE 49609
// exit ;
49607: GO 49628
// result := UnitsInside ( building ) < 6 ;
49609: LD_ADDR_VAR 0 2
49613: PUSH
49614: LD_VAR 0 1
49618: PPUSH
49619: CALL_OW 313
49623: PUSH
49624: LD_INT 6
49626: LESS
49627: ST_TO_ADDR
// end ;
49628: LD_VAR 0 2
49632: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
49633: LD_INT 0
49635: PPUSH
49636: PPUSH
49637: PPUSH
49638: PPUSH
// tmp := [ ] ;
49639: LD_ADDR_VAR 0 3
49643: PUSH
49644: EMPTY
49645: ST_TO_ADDR
// list := [ ] ;
49646: LD_ADDR_VAR 0 5
49650: PUSH
49651: EMPTY
49652: ST_TO_ADDR
// for i = 16 to 25 do
49653: LD_ADDR_VAR 0 4
49657: PUSH
49658: DOUBLE
49659: LD_INT 16
49661: DEC
49662: ST_TO_ADDR
49663: LD_INT 25
49665: PUSH
49666: FOR_TO
49667: IFFALSE 49740
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
49669: LD_ADDR_VAR 0 3
49673: PUSH
49674: LD_VAR 0 3
49678: PUSH
49679: LD_INT 22
49681: PUSH
49682: LD_VAR 0 1
49686: PPUSH
49687: CALL_OW 255
49691: PUSH
49692: EMPTY
49693: LIST
49694: LIST
49695: PUSH
49696: LD_INT 91
49698: PUSH
49699: LD_VAR 0 1
49703: PUSH
49704: LD_INT 6
49706: PUSH
49707: EMPTY
49708: LIST
49709: LIST
49710: LIST
49711: PUSH
49712: LD_INT 30
49714: PUSH
49715: LD_VAR 0 4
49719: PUSH
49720: EMPTY
49721: LIST
49722: LIST
49723: PUSH
49724: EMPTY
49725: LIST
49726: LIST
49727: LIST
49728: PUSH
49729: EMPTY
49730: LIST
49731: PPUSH
49732: CALL_OW 69
49736: ADD
49737: ST_TO_ADDR
49738: GO 49666
49740: POP
49741: POP
// for i = 1 to tmp do
49742: LD_ADDR_VAR 0 4
49746: PUSH
49747: DOUBLE
49748: LD_INT 1
49750: DEC
49751: ST_TO_ADDR
49752: LD_VAR 0 3
49756: PUSH
49757: FOR_TO
49758: IFFALSE 49846
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
49760: LD_ADDR_VAR 0 5
49764: PUSH
49765: LD_VAR 0 5
49769: PUSH
49770: LD_VAR 0 3
49774: PUSH
49775: LD_VAR 0 4
49779: ARRAY
49780: PPUSH
49781: CALL_OW 266
49785: PUSH
49786: LD_VAR 0 3
49790: PUSH
49791: LD_VAR 0 4
49795: ARRAY
49796: PPUSH
49797: CALL_OW 250
49801: PUSH
49802: LD_VAR 0 3
49806: PUSH
49807: LD_VAR 0 4
49811: ARRAY
49812: PPUSH
49813: CALL_OW 251
49817: PUSH
49818: LD_VAR 0 3
49822: PUSH
49823: LD_VAR 0 4
49827: ARRAY
49828: PPUSH
49829: CALL_OW 254
49833: PUSH
49834: EMPTY
49835: LIST
49836: LIST
49837: LIST
49838: LIST
49839: PUSH
49840: EMPTY
49841: LIST
49842: ADD
49843: ST_TO_ADDR
49844: GO 49757
49846: POP
49847: POP
// result := list ;
49848: LD_ADDR_VAR 0 2
49852: PUSH
49853: LD_VAR 0 5
49857: ST_TO_ADDR
// end ;
49858: LD_VAR 0 2
49862: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
49863: LD_INT 0
49865: PPUSH
49866: PPUSH
49867: PPUSH
49868: PPUSH
49869: PPUSH
49870: PPUSH
49871: PPUSH
// if not factory then
49872: LD_VAR 0 1
49876: NOT
49877: IFFALSE 49881
// exit ;
49879: GO 50474
// if control = control_apeman then
49881: LD_VAR 0 4
49885: PUSH
49886: LD_INT 5
49888: EQUAL
49889: IFFALSE 49998
// begin tmp := UnitsInside ( factory ) ;
49891: LD_ADDR_VAR 0 8
49895: PUSH
49896: LD_VAR 0 1
49900: PPUSH
49901: CALL_OW 313
49905: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
49906: LD_VAR 0 8
49910: PPUSH
49911: LD_INT 25
49913: PUSH
49914: LD_INT 12
49916: PUSH
49917: EMPTY
49918: LIST
49919: LIST
49920: PPUSH
49921: CALL_OW 72
49925: NOT
49926: IFFALSE 49936
// control := control_manual ;
49928: LD_ADDR_VAR 0 4
49932: PUSH
49933: LD_INT 1
49935: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
49936: LD_ADDR_VAR 0 8
49940: PUSH
49941: LD_VAR 0 1
49945: PPUSH
49946: CALL 49633 0 1
49950: ST_TO_ADDR
// if tmp then
49951: LD_VAR 0 8
49955: IFFALSE 49998
// begin for i in tmp do
49957: LD_ADDR_VAR 0 7
49961: PUSH
49962: LD_VAR 0 8
49966: PUSH
49967: FOR_IN
49968: IFFALSE 49996
// if i [ 1 ] = b_ext_radio then
49970: LD_VAR 0 7
49974: PUSH
49975: LD_INT 1
49977: ARRAY
49978: PUSH
49979: LD_INT 22
49981: EQUAL
49982: IFFALSE 49994
// begin control := control_remote ;
49984: LD_ADDR_VAR 0 4
49988: PUSH
49989: LD_INT 2
49991: ST_TO_ADDR
// break ;
49992: GO 49996
// end ;
49994: GO 49967
49996: POP
49997: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
49998: LD_VAR 0 1
50002: PPUSH
50003: LD_VAR 0 2
50007: PPUSH
50008: LD_VAR 0 3
50012: PPUSH
50013: LD_VAR 0 4
50017: PPUSH
50018: LD_VAR 0 5
50022: PPUSH
50023: CALL_OW 448
50027: IFFALSE 50062
// begin result := [ chassis , engine , control , weapon ] ;
50029: LD_ADDR_VAR 0 6
50033: PUSH
50034: LD_VAR 0 2
50038: PUSH
50039: LD_VAR 0 3
50043: PUSH
50044: LD_VAR 0 4
50048: PUSH
50049: LD_VAR 0 5
50053: PUSH
50054: EMPTY
50055: LIST
50056: LIST
50057: LIST
50058: LIST
50059: ST_TO_ADDR
// exit ;
50060: GO 50474
// end ; _chassis := AvailableChassisList ( factory ) ;
50062: LD_ADDR_VAR 0 9
50066: PUSH
50067: LD_VAR 0 1
50071: PPUSH
50072: CALL_OW 475
50076: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
50077: LD_ADDR_VAR 0 11
50081: PUSH
50082: LD_VAR 0 1
50086: PPUSH
50087: CALL_OW 476
50091: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
50092: LD_ADDR_VAR 0 12
50096: PUSH
50097: LD_VAR 0 1
50101: PPUSH
50102: CALL_OW 477
50106: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
50107: LD_ADDR_VAR 0 10
50111: PUSH
50112: LD_VAR 0 1
50116: PPUSH
50117: CALL_OW 478
50121: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
50122: LD_VAR 0 9
50126: NOT
50127: PUSH
50128: LD_VAR 0 11
50132: NOT
50133: OR
50134: PUSH
50135: LD_VAR 0 12
50139: NOT
50140: OR
50141: PUSH
50142: LD_VAR 0 10
50146: NOT
50147: OR
50148: IFFALSE 50183
// begin result := [ chassis , engine , control , weapon ] ;
50150: LD_ADDR_VAR 0 6
50154: PUSH
50155: LD_VAR 0 2
50159: PUSH
50160: LD_VAR 0 3
50164: PUSH
50165: LD_VAR 0 4
50169: PUSH
50170: LD_VAR 0 5
50174: PUSH
50175: EMPTY
50176: LIST
50177: LIST
50178: LIST
50179: LIST
50180: ST_TO_ADDR
// exit ;
50181: GO 50474
// end ; if not chassis in _chassis then
50183: LD_VAR 0 2
50187: PUSH
50188: LD_VAR 0 9
50192: IN
50193: NOT
50194: IFFALSE 50220
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
50196: LD_ADDR_VAR 0 2
50200: PUSH
50201: LD_VAR 0 9
50205: PUSH
50206: LD_INT 1
50208: PPUSH
50209: LD_VAR 0 9
50213: PPUSH
50214: CALL_OW 12
50218: ARRAY
50219: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
50220: LD_VAR 0 2
50224: PPUSH
50225: LD_VAR 0 3
50229: PPUSH
50230: CALL 50479 0 2
50234: NOT
50235: IFFALSE 50294
// repeat engine := _engine [ 1 ] ;
50237: LD_ADDR_VAR 0 3
50241: PUSH
50242: LD_VAR 0 11
50246: PUSH
50247: LD_INT 1
50249: ARRAY
50250: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
50251: LD_ADDR_VAR 0 11
50255: PUSH
50256: LD_VAR 0 11
50260: PPUSH
50261: LD_INT 1
50263: PPUSH
50264: CALL_OW 3
50268: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
50269: LD_VAR 0 2
50273: PPUSH
50274: LD_VAR 0 3
50278: PPUSH
50279: CALL 50479 0 2
50283: PUSH
50284: LD_VAR 0 11
50288: PUSH
50289: EMPTY
50290: EQUAL
50291: OR
50292: IFFALSE 50237
// if not control in _control then
50294: LD_VAR 0 4
50298: PUSH
50299: LD_VAR 0 12
50303: IN
50304: NOT
50305: IFFALSE 50331
// control := _control [ rand ( 1 , _control ) ] ;
50307: LD_ADDR_VAR 0 4
50311: PUSH
50312: LD_VAR 0 12
50316: PUSH
50317: LD_INT 1
50319: PPUSH
50320: LD_VAR 0 12
50324: PPUSH
50325: CALL_OW 12
50329: ARRAY
50330: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
50331: LD_VAR 0 2
50335: PPUSH
50336: LD_VAR 0 5
50340: PPUSH
50341: CALL 50699 0 2
50345: NOT
50346: IFFALSE 50405
// repeat weapon := _weapon [ 1 ] ;
50348: LD_ADDR_VAR 0 5
50352: PUSH
50353: LD_VAR 0 10
50357: PUSH
50358: LD_INT 1
50360: ARRAY
50361: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
50362: LD_ADDR_VAR 0 10
50366: PUSH
50367: LD_VAR 0 10
50371: PPUSH
50372: LD_INT 1
50374: PPUSH
50375: CALL_OW 3
50379: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
50380: LD_VAR 0 2
50384: PPUSH
50385: LD_VAR 0 5
50389: PPUSH
50390: CALL 50699 0 2
50394: PUSH
50395: LD_VAR 0 10
50399: PUSH
50400: EMPTY
50401: EQUAL
50402: OR
50403: IFFALSE 50348
// result := [ ] ;
50405: LD_ADDR_VAR 0 6
50409: PUSH
50410: EMPTY
50411: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50412: LD_VAR 0 1
50416: PPUSH
50417: LD_VAR 0 2
50421: PPUSH
50422: LD_VAR 0 3
50426: PPUSH
50427: LD_VAR 0 4
50431: PPUSH
50432: LD_VAR 0 5
50436: PPUSH
50437: CALL_OW 448
50441: IFFALSE 50474
// result := [ chassis , engine , control , weapon ] ;
50443: LD_ADDR_VAR 0 6
50447: PUSH
50448: LD_VAR 0 2
50452: PUSH
50453: LD_VAR 0 3
50457: PUSH
50458: LD_VAR 0 4
50462: PUSH
50463: LD_VAR 0 5
50467: PUSH
50468: EMPTY
50469: LIST
50470: LIST
50471: LIST
50472: LIST
50473: ST_TO_ADDR
// end ;
50474: LD_VAR 0 6
50478: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
50479: LD_INT 0
50481: PPUSH
// if not chassis or not engine then
50482: LD_VAR 0 1
50486: NOT
50487: PUSH
50488: LD_VAR 0 2
50492: NOT
50493: OR
50494: IFFALSE 50498
// exit ;
50496: GO 50694
// case engine of engine_solar :
50498: LD_VAR 0 2
50502: PUSH
50503: LD_INT 2
50505: DOUBLE
50506: EQUAL
50507: IFTRUE 50511
50509: GO 50549
50511: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
50512: LD_ADDR_VAR 0 3
50516: PUSH
50517: LD_INT 11
50519: PUSH
50520: LD_INT 12
50522: PUSH
50523: LD_INT 13
50525: PUSH
50526: LD_INT 14
50528: PUSH
50529: LD_INT 1
50531: PUSH
50532: LD_INT 2
50534: PUSH
50535: LD_INT 3
50537: PUSH
50538: EMPTY
50539: LIST
50540: LIST
50541: LIST
50542: LIST
50543: LIST
50544: LIST
50545: LIST
50546: ST_TO_ADDR
50547: GO 50678
50549: LD_INT 1
50551: DOUBLE
50552: EQUAL
50553: IFTRUE 50557
50555: GO 50619
50557: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
50558: LD_ADDR_VAR 0 3
50562: PUSH
50563: LD_INT 11
50565: PUSH
50566: LD_INT 12
50568: PUSH
50569: LD_INT 13
50571: PUSH
50572: LD_INT 14
50574: PUSH
50575: LD_INT 1
50577: PUSH
50578: LD_INT 2
50580: PUSH
50581: LD_INT 3
50583: PUSH
50584: LD_INT 4
50586: PUSH
50587: LD_INT 5
50589: PUSH
50590: LD_INT 21
50592: PUSH
50593: LD_INT 23
50595: PUSH
50596: LD_INT 22
50598: PUSH
50599: LD_INT 24
50601: PUSH
50602: EMPTY
50603: LIST
50604: LIST
50605: LIST
50606: LIST
50607: LIST
50608: LIST
50609: LIST
50610: LIST
50611: LIST
50612: LIST
50613: LIST
50614: LIST
50615: LIST
50616: ST_TO_ADDR
50617: GO 50678
50619: LD_INT 3
50621: DOUBLE
50622: EQUAL
50623: IFTRUE 50627
50625: GO 50677
50627: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
50628: LD_ADDR_VAR 0 3
50632: PUSH
50633: LD_INT 13
50635: PUSH
50636: LD_INT 14
50638: PUSH
50639: LD_INT 2
50641: PUSH
50642: LD_INT 3
50644: PUSH
50645: LD_INT 4
50647: PUSH
50648: LD_INT 5
50650: PUSH
50651: LD_INT 21
50653: PUSH
50654: LD_INT 22
50656: PUSH
50657: LD_INT 23
50659: PUSH
50660: LD_INT 24
50662: PUSH
50663: EMPTY
50664: LIST
50665: LIST
50666: LIST
50667: LIST
50668: LIST
50669: LIST
50670: LIST
50671: LIST
50672: LIST
50673: LIST
50674: ST_TO_ADDR
50675: GO 50678
50677: POP
// result := ( chassis in result ) ;
50678: LD_ADDR_VAR 0 3
50682: PUSH
50683: LD_VAR 0 1
50687: PUSH
50688: LD_VAR 0 3
50692: IN
50693: ST_TO_ADDR
// end ;
50694: LD_VAR 0 3
50698: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
50699: LD_INT 0
50701: PPUSH
// if not chassis or not weapon then
50702: LD_VAR 0 1
50706: NOT
50707: PUSH
50708: LD_VAR 0 2
50712: NOT
50713: OR
50714: IFFALSE 50718
// exit ;
50716: GO 51744
// case weapon of us_machine_gun :
50718: LD_VAR 0 2
50722: PUSH
50723: LD_INT 2
50725: DOUBLE
50726: EQUAL
50727: IFTRUE 50731
50729: GO 50761
50731: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
50732: LD_ADDR_VAR 0 3
50736: PUSH
50737: LD_INT 1
50739: PUSH
50740: LD_INT 2
50742: PUSH
50743: LD_INT 3
50745: PUSH
50746: LD_INT 4
50748: PUSH
50749: LD_INT 5
50751: PUSH
50752: EMPTY
50753: LIST
50754: LIST
50755: LIST
50756: LIST
50757: LIST
50758: ST_TO_ADDR
50759: GO 51728
50761: LD_INT 3
50763: DOUBLE
50764: EQUAL
50765: IFTRUE 50769
50767: GO 50799
50769: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
50770: LD_ADDR_VAR 0 3
50774: PUSH
50775: LD_INT 1
50777: PUSH
50778: LD_INT 2
50780: PUSH
50781: LD_INT 3
50783: PUSH
50784: LD_INT 4
50786: PUSH
50787: LD_INT 5
50789: PUSH
50790: EMPTY
50791: LIST
50792: LIST
50793: LIST
50794: LIST
50795: LIST
50796: ST_TO_ADDR
50797: GO 51728
50799: LD_INT 11
50801: DOUBLE
50802: EQUAL
50803: IFTRUE 50807
50805: GO 50837
50807: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
50808: LD_ADDR_VAR 0 3
50812: PUSH
50813: LD_INT 1
50815: PUSH
50816: LD_INT 2
50818: PUSH
50819: LD_INT 3
50821: PUSH
50822: LD_INT 4
50824: PUSH
50825: LD_INT 5
50827: PUSH
50828: EMPTY
50829: LIST
50830: LIST
50831: LIST
50832: LIST
50833: LIST
50834: ST_TO_ADDR
50835: GO 51728
50837: LD_INT 4
50839: DOUBLE
50840: EQUAL
50841: IFTRUE 50845
50843: GO 50871
50845: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
50846: LD_ADDR_VAR 0 3
50850: PUSH
50851: LD_INT 2
50853: PUSH
50854: LD_INT 3
50856: PUSH
50857: LD_INT 4
50859: PUSH
50860: LD_INT 5
50862: PUSH
50863: EMPTY
50864: LIST
50865: LIST
50866: LIST
50867: LIST
50868: ST_TO_ADDR
50869: GO 51728
50871: LD_INT 5
50873: DOUBLE
50874: EQUAL
50875: IFTRUE 50879
50877: GO 50905
50879: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
50880: LD_ADDR_VAR 0 3
50884: PUSH
50885: LD_INT 2
50887: PUSH
50888: LD_INT 3
50890: PUSH
50891: LD_INT 4
50893: PUSH
50894: LD_INT 5
50896: PUSH
50897: EMPTY
50898: LIST
50899: LIST
50900: LIST
50901: LIST
50902: ST_TO_ADDR
50903: GO 51728
50905: LD_INT 9
50907: DOUBLE
50908: EQUAL
50909: IFTRUE 50913
50911: GO 50939
50913: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
50914: LD_ADDR_VAR 0 3
50918: PUSH
50919: LD_INT 2
50921: PUSH
50922: LD_INT 3
50924: PUSH
50925: LD_INT 4
50927: PUSH
50928: LD_INT 5
50930: PUSH
50931: EMPTY
50932: LIST
50933: LIST
50934: LIST
50935: LIST
50936: ST_TO_ADDR
50937: GO 51728
50939: LD_INT 7
50941: DOUBLE
50942: EQUAL
50943: IFTRUE 50947
50945: GO 50973
50947: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
50948: LD_ADDR_VAR 0 3
50952: PUSH
50953: LD_INT 2
50955: PUSH
50956: LD_INT 3
50958: PUSH
50959: LD_INT 4
50961: PUSH
50962: LD_INT 5
50964: PUSH
50965: EMPTY
50966: LIST
50967: LIST
50968: LIST
50969: LIST
50970: ST_TO_ADDR
50971: GO 51728
50973: LD_INT 12
50975: DOUBLE
50976: EQUAL
50977: IFTRUE 50981
50979: GO 51007
50981: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
50982: LD_ADDR_VAR 0 3
50986: PUSH
50987: LD_INT 2
50989: PUSH
50990: LD_INT 3
50992: PUSH
50993: LD_INT 4
50995: PUSH
50996: LD_INT 5
50998: PUSH
50999: EMPTY
51000: LIST
51001: LIST
51002: LIST
51003: LIST
51004: ST_TO_ADDR
51005: GO 51728
51007: LD_INT 13
51009: DOUBLE
51010: EQUAL
51011: IFTRUE 51015
51013: GO 51041
51015: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
51016: LD_ADDR_VAR 0 3
51020: PUSH
51021: LD_INT 2
51023: PUSH
51024: LD_INT 3
51026: PUSH
51027: LD_INT 4
51029: PUSH
51030: LD_INT 5
51032: PUSH
51033: EMPTY
51034: LIST
51035: LIST
51036: LIST
51037: LIST
51038: ST_TO_ADDR
51039: GO 51728
51041: LD_INT 14
51043: DOUBLE
51044: EQUAL
51045: IFTRUE 51049
51047: GO 51067
51049: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
51050: LD_ADDR_VAR 0 3
51054: PUSH
51055: LD_INT 4
51057: PUSH
51058: LD_INT 5
51060: PUSH
51061: EMPTY
51062: LIST
51063: LIST
51064: ST_TO_ADDR
51065: GO 51728
51067: LD_INT 6
51069: DOUBLE
51070: EQUAL
51071: IFTRUE 51075
51073: GO 51093
51075: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
51076: LD_ADDR_VAR 0 3
51080: PUSH
51081: LD_INT 4
51083: PUSH
51084: LD_INT 5
51086: PUSH
51087: EMPTY
51088: LIST
51089: LIST
51090: ST_TO_ADDR
51091: GO 51728
51093: LD_INT 10
51095: DOUBLE
51096: EQUAL
51097: IFTRUE 51101
51099: GO 51119
51101: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
51102: LD_ADDR_VAR 0 3
51106: PUSH
51107: LD_INT 4
51109: PUSH
51110: LD_INT 5
51112: PUSH
51113: EMPTY
51114: LIST
51115: LIST
51116: ST_TO_ADDR
51117: GO 51728
51119: LD_INT 22
51121: DOUBLE
51122: EQUAL
51123: IFTRUE 51127
51125: GO 51153
51127: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
51128: LD_ADDR_VAR 0 3
51132: PUSH
51133: LD_INT 11
51135: PUSH
51136: LD_INT 12
51138: PUSH
51139: LD_INT 13
51141: PUSH
51142: LD_INT 14
51144: PUSH
51145: EMPTY
51146: LIST
51147: LIST
51148: LIST
51149: LIST
51150: ST_TO_ADDR
51151: GO 51728
51153: LD_INT 23
51155: DOUBLE
51156: EQUAL
51157: IFTRUE 51161
51159: GO 51187
51161: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
51162: LD_ADDR_VAR 0 3
51166: PUSH
51167: LD_INT 11
51169: PUSH
51170: LD_INT 12
51172: PUSH
51173: LD_INT 13
51175: PUSH
51176: LD_INT 14
51178: PUSH
51179: EMPTY
51180: LIST
51181: LIST
51182: LIST
51183: LIST
51184: ST_TO_ADDR
51185: GO 51728
51187: LD_INT 24
51189: DOUBLE
51190: EQUAL
51191: IFTRUE 51195
51193: GO 51221
51195: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
51196: LD_ADDR_VAR 0 3
51200: PUSH
51201: LD_INT 11
51203: PUSH
51204: LD_INT 12
51206: PUSH
51207: LD_INT 13
51209: PUSH
51210: LD_INT 14
51212: PUSH
51213: EMPTY
51214: LIST
51215: LIST
51216: LIST
51217: LIST
51218: ST_TO_ADDR
51219: GO 51728
51221: LD_INT 30
51223: DOUBLE
51224: EQUAL
51225: IFTRUE 51229
51227: GO 51255
51229: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
51230: LD_ADDR_VAR 0 3
51234: PUSH
51235: LD_INT 11
51237: PUSH
51238: LD_INT 12
51240: PUSH
51241: LD_INT 13
51243: PUSH
51244: LD_INT 14
51246: PUSH
51247: EMPTY
51248: LIST
51249: LIST
51250: LIST
51251: LIST
51252: ST_TO_ADDR
51253: GO 51728
51255: LD_INT 25
51257: DOUBLE
51258: EQUAL
51259: IFTRUE 51263
51261: GO 51281
51263: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
51264: LD_ADDR_VAR 0 3
51268: PUSH
51269: LD_INT 13
51271: PUSH
51272: LD_INT 14
51274: PUSH
51275: EMPTY
51276: LIST
51277: LIST
51278: ST_TO_ADDR
51279: GO 51728
51281: LD_INT 27
51283: DOUBLE
51284: EQUAL
51285: IFTRUE 51289
51287: GO 51307
51289: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
51290: LD_ADDR_VAR 0 3
51294: PUSH
51295: LD_INT 13
51297: PUSH
51298: LD_INT 14
51300: PUSH
51301: EMPTY
51302: LIST
51303: LIST
51304: ST_TO_ADDR
51305: GO 51728
51307: LD_INT 28
51309: DOUBLE
51310: EQUAL
51311: IFTRUE 51315
51313: GO 51333
51315: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
51316: LD_ADDR_VAR 0 3
51320: PUSH
51321: LD_INT 13
51323: PUSH
51324: LD_INT 14
51326: PUSH
51327: EMPTY
51328: LIST
51329: LIST
51330: ST_TO_ADDR
51331: GO 51728
51333: LD_INT 29
51335: DOUBLE
51336: EQUAL
51337: IFTRUE 51341
51339: GO 51359
51341: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
51342: LD_ADDR_VAR 0 3
51346: PUSH
51347: LD_INT 13
51349: PUSH
51350: LD_INT 14
51352: PUSH
51353: EMPTY
51354: LIST
51355: LIST
51356: ST_TO_ADDR
51357: GO 51728
51359: LD_INT 31
51361: DOUBLE
51362: EQUAL
51363: IFTRUE 51367
51365: GO 51385
51367: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
51368: LD_ADDR_VAR 0 3
51372: PUSH
51373: LD_INT 13
51375: PUSH
51376: LD_INT 14
51378: PUSH
51379: EMPTY
51380: LIST
51381: LIST
51382: ST_TO_ADDR
51383: GO 51728
51385: LD_INT 26
51387: DOUBLE
51388: EQUAL
51389: IFTRUE 51393
51391: GO 51411
51393: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
51394: LD_ADDR_VAR 0 3
51398: PUSH
51399: LD_INT 13
51401: PUSH
51402: LD_INT 14
51404: PUSH
51405: EMPTY
51406: LIST
51407: LIST
51408: ST_TO_ADDR
51409: GO 51728
51411: LD_INT 42
51413: DOUBLE
51414: EQUAL
51415: IFTRUE 51419
51417: GO 51445
51419: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
51420: LD_ADDR_VAR 0 3
51424: PUSH
51425: LD_INT 21
51427: PUSH
51428: LD_INT 22
51430: PUSH
51431: LD_INT 23
51433: PUSH
51434: LD_INT 24
51436: PUSH
51437: EMPTY
51438: LIST
51439: LIST
51440: LIST
51441: LIST
51442: ST_TO_ADDR
51443: GO 51728
51445: LD_INT 43
51447: DOUBLE
51448: EQUAL
51449: IFTRUE 51453
51451: GO 51479
51453: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
51454: LD_ADDR_VAR 0 3
51458: PUSH
51459: LD_INT 21
51461: PUSH
51462: LD_INT 22
51464: PUSH
51465: LD_INT 23
51467: PUSH
51468: LD_INT 24
51470: PUSH
51471: EMPTY
51472: LIST
51473: LIST
51474: LIST
51475: LIST
51476: ST_TO_ADDR
51477: GO 51728
51479: LD_INT 44
51481: DOUBLE
51482: EQUAL
51483: IFTRUE 51487
51485: GO 51513
51487: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
51488: LD_ADDR_VAR 0 3
51492: PUSH
51493: LD_INT 21
51495: PUSH
51496: LD_INT 22
51498: PUSH
51499: LD_INT 23
51501: PUSH
51502: LD_INT 24
51504: PUSH
51505: EMPTY
51506: LIST
51507: LIST
51508: LIST
51509: LIST
51510: ST_TO_ADDR
51511: GO 51728
51513: LD_INT 45
51515: DOUBLE
51516: EQUAL
51517: IFTRUE 51521
51519: GO 51547
51521: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
51522: LD_ADDR_VAR 0 3
51526: PUSH
51527: LD_INT 21
51529: PUSH
51530: LD_INT 22
51532: PUSH
51533: LD_INT 23
51535: PUSH
51536: LD_INT 24
51538: PUSH
51539: EMPTY
51540: LIST
51541: LIST
51542: LIST
51543: LIST
51544: ST_TO_ADDR
51545: GO 51728
51547: LD_INT 49
51549: DOUBLE
51550: EQUAL
51551: IFTRUE 51555
51553: GO 51581
51555: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
51556: LD_ADDR_VAR 0 3
51560: PUSH
51561: LD_INT 21
51563: PUSH
51564: LD_INT 22
51566: PUSH
51567: LD_INT 23
51569: PUSH
51570: LD_INT 24
51572: PUSH
51573: EMPTY
51574: LIST
51575: LIST
51576: LIST
51577: LIST
51578: ST_TO_ADDR
51579: GO 51728
51581: LD_INT 51
51583: DOUBLE
51584: EQUAL
51585: IFTRUE 51589
51587: GO 51615
51589: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
51590: LD_ADDR_VAR 0 3
51594: PUSH
51595: LD_INT 21
51597: PUSH
51598: LD_INT 22
51600: PUSH
51601: LD_INT 23
51603: PUSH
51604: LD_INT 24
51606: PUSH
51607: EMPTY
51608: LIST
51609: LIST
51610: LIST
51611: LIST
51612: ST_TO_ADDR
51613: GO 51728
51615: LD_INT 52
51617: DOUBLE
51618: EQUAL
51619: IFTRUE 51623
51621: GO 51649
51623: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
51624: LD_ADDR_VAR 0 3
51628: PUSH
51629: LD_INT 21
51631: PUSH
51632: LD_INT 22
51634: PUSH
51635: LD_INT 23
51637: PUSH
51638: LD_INT 24
51640: PUSH
51641: EMPTY
51642: LIST
51643: LIST
51644: LIST
51645: LIST
51646: ST_TO_ADDR
51647: GO 51728
51649: LD_INT 53
51651: DOUBLE
51652: EQUAL
51653: IFTRUE 51657
51655: GO 51675
51657: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
51658: LD_ADDR_VAR 0 3
51662: PUSH
51663: LD_INT 23
51665: PUSH
51666: LD_INT 24
51668: PUSH
51669: EMPTY
51670: LIST
51671: LIST
51672: ST_TO_ADDR
51673: GO 51728
51675: LD_INT 46
51677: DOUBLE
51678: EQUAL
51679: IFTRUE 51683
51681: GO 51701
51683: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
51684: LD_ADDR_VAR 0 3
51688: PUSH
51689: LD_INT 23
51691: PUSH
51692: LD_INT 24
51694: PUSH
51695: EMPTY
51696: LIST
51697: LIST
51698: ST_TO_ADDR
51699: GO 51728
51701: LD_INT 47
51703: DOUBLE
51704: EQUAL
51705: IFTRUE 51709
51707: GO 51727
51709: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51710: LD_ADDR_VAR 0 3
51714: PUSH
51715: LD_INT 23
51717: PUSH
51718: LD_INT 24
51720: PUSH
51721: EMPTY
51722: LIST
51723: LIST
51724: ST_TO_ADDR
51725: GO 51728
51727: POP
// result := ( chassis in result ) ;
51728: LD_ADDR_VAR 0 3
51732: PUSH
51733: LD_VAR 0 1
51737: PUSH
51738: LD_VAR 0 3
51742: IN
51743: ST_TO_ADDR
// end ;
51744: LD_VAR 0 3
51748: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
51749: LD_INT 0
51751: PPUSH
51752: PPUSH
51753: PPUSH
51754: PPUSH
51755: PPUSH
51756: PPUSH
51757: PPUSH
// result := array ;
51758: LD_ADDR_VAR 0 5
51762: PUSH
51763: LD_VAR 0 1
51767: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
51768: LD_VAR 0 1
51772: NOT
51773: PUSH
51774: LD_VAR 0 2
51778: NOT
51779: OR
51780: PUSH
51781: LD_VAR 0 3
51785: NOT
51786: OR
51787: PUSH
51788: LD_VAR 0 2
51792: PUSH
51793: LD_VAR 0 1
51797: GREATER
51798: OR
51799: PUSH
51800: LD_VAR 0 3
51804: PUSH
51805: LD_VAR 0 1
51809: GREATER
51810: OR
51811: IFFALSE 51815
// exit ;
51813: GO 52111
// if direction then
51815: LD_VAR 0 4
51819: IFFALSE 51883
// begin d := 1 ;
51821: LD_ADDR_VAR 0 9
51825: PUSH
51826: LD_INT 1
51828: ST_TO_ADDR
// if i_from > i_to then
51829: LD_VAR 0 2
51833: PUSH
51834: LD_VAR 0 3
51838: GREATER
51839: IFFALSE 51865
// length := ( array - i_from ) + i_to else
51841: LD_ADDR_VAR 0 11
51845: PUSH
51846: LD_VAR 0 1
51850: PUSH
51851: LD_VAR 0 2
51855: MINUS
51856: PUSH
51857: LD_VAR 0 3
51861: PLUS
51862: ST_TO_ADDR
51863: GO 51881
// length := i_to - i_from ;
51865: LD_ADDR_VAR 0 11
51869: PUSH
51870: LD_VAR 0 3
51874: PUSH
51875: LD_VAR 0 2
51879: MINUS
51880: ST_TO_ADDR
// end else
51881: GO 51944
// begin d := - 1 ;
51883: LD_ADDR_VAR 0 9
51887: PUSH
51888: LD_INT 1
51890: NEG
51891: ST_TO_ADDR
// if i_from > i_to then
51892: LD_VAR 0 2
51896: PUSH
51897: LD_VAR 0 3
51901: GREATER
51902: IFFALSE 51922
// length := i_from - i_to else
51904: LD_ADDR_VAR 0 11
51908: PUSH
51909: LD_VAR 0 2
51913: PUSH
51914: LD_VAR 0 3
51918: MINUS
51919: ST_TO_ADDR
51920: GO 51944
// length := ( array - i_to ) + i_from ;
51922: LD_ADDR_VAR 0 11
51926: PUSH
51927: LD_VAR 0 1
51931: PUSH
51932: LD_VAR 0 3
51936: MINUS
51937: PUSH
51938: LD_VAR 0 2
51942: PLUS
51943: ST_TO_ADDR
// end ; if not length then
51944: LD_VAR 0 11
51948: NOT
51949: IFFALSE 51953
// exit ;
51951: GO 52111
// tmp := array ;
51953: LD_ADDR_VAR 0 10
51957: PUSH
51958: LD_VAR 0 1
51962: ST_TO_ADDR
// for i = 1 to length do
51963: LD_ADDR_VAR 0 6
51967: PUSH
51968: DOUBLE
51969: LD_INT 1
51971: DEC
51972: ST_TO_ADDR
51973: LD_VAR 0 11
51977: PUSH
51978: FOR_TO
51979: IFFALSE 52099
// begin for j = 1 to array do
51981: LD_ADDR_VAR 0 7
51985: PUSH
51986: DOUBLE
51987: LD_INT 1
51989: DEC
51990: ST_TO_ADDR
51991: LD_VAR 0 1
51995: PUSH
51996: FOR_TO
51997: IFFALSE 52085
// begin k := j + d ;
51999: LD_ADDR_VAR 0 8
52003: PUSH
52004: LD_VAR 0 7
52008: PUSH
52009: LD_VAR 0 9
52013: PLUS
52014: ST_TO_ADDR
// if k > array then
52015: LD_VAR 0 8
52019: PUSH
52020: LD_VAR 0 1
52024: GREATER
52025: IFFALSE 52035
// k := 1 ;
52027: LD_ADDR_VAR 0 8
52031: PUSH
52032: LD_INT 1
52034: ST_TO_ADDR
// if not k then
52035: LD_VAR 0 8
52039: NOT
52040: IFFALSE 52052
// k := array ;
52042: LD_ADDR_VAR 0 8
52046: PUSH
52047: LD_VAR 0 1
52051: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
52052: LD_ADDR_VAR 0 10
52056: PUSH
52057: LD_VAR 0 10
52061: PPUSH
52062: LD_VAR 0 8
52066: PPUSH
52067: LD_VAR 0 1
52071: PUSH
52072: LD_VAR 0 7
52076: ARRAY
52077: PPUSH
52078: CALL_OW 1
52082: ST_TO_ADDR
// end ;
52083: GO 51996
52085: POP
52086: POP
// array := tmp ;
52087: LD_ADDR_VAR 0 1
52091: PUSH
52092: LD_VAR 0 10
52096: ST_TO_ADDR
// end ;
52097: GO 51978
52099: POP
52100: POP
// result := array ;
52101: LD_ADDR_VAR 0 5
52105: PUSH
52106: LD_VAR 0 1
52110: ST_TO_ADDR
// end ;
52111: LD_VAR 0 5
52115: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
52116: LD_INT 0
52118: PPUSH
52119: PPUSH
// result := 0 ;
52120: LD_ADDR_VAR 0 3
52124: PUSH
52125: LD_INT 0
52127: ST_TO_ADDR
// if not array or not value in array then
52128: LD_VAR 0 1
52132: NOT
52133: PUSH
52134: LD_VAR 0 2
52138: PUSH
52139: LD_VAR 0 1
52143: IN
52144: NOT
52145: OR
52146: IFFALSE 52150
// exit ;
52148: GO 52204
// for i = 1 to array do
52150: LD_ADDR_VAR 0 4
52154: PUSH
52155: DOUBLE
52156: LD_INT 1
52158: DEC
52159: ST_TO_ADDR
52160: LD_VAR 0 1
52164: PUSH
52165: FOR_TO
52166: IFFALSE 52202
// if value = array [ i ] then
52168: LD_VAR 0 2
52172: PUSH
52173: LD_VAR 0 1
52177: PUSH
52178: LD_VAR 0 4
52182: ARRAY
52183: EQUAL
52184: IFFALSE 52200
// begin result := i ;
52186: LD_ADDR_VAR 0 3
52190: PUSH
52191: LD_VAR 0 4
52195: ST_TO_ADDR
// exit ;
52196: POP
52197: POP
52198: GO 52204
// end ;
52200: GO 52165
52202: POP
52203: POP
// end ;
52204: LD_VAR 0 3
52208: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
52209: LD_INT 0
52211: PPUSH
// vc_chassis := chassis ;
52212: LD_ADDR_OWVAR 37
52216: PUSH
52217: LD_VAR 0 1
52221: ST_TO_ADDR
// vc_engine := engine ;
52222: LD_ADDR_OWVAR 39
52226: PUSH
52227: LD_VAR 0 2
52231: ST_TO_ADDR
// vc_control := control ;
52232: LD_ADDR_OWVAR 38
52236: PUSH
52237: LD_VAR 0 3
52241: ST_TO_ADDR
// vc_weapon := weapon ;
52242: LD_ADDR_OWVAR 40
52246: PUSH
52247: LD_VAR 0 4
52251: ST_TO_ADDR
// vc_fuel_battery := fuel ;
52252: LD_ADDR_OWVAR 41
52256: PUSH
52257: LD_VAR 0 5
52261: ST_TO_ADDR
// end ;
52262: LD_VAR 0 6
52266: RET
// export function WantPlant ( unit ) ; var task ; begin
52267: LD_INT 0
52269: PPUSH
52270: PPUSH
// result := false ;
52271: LD_ADDR_VAR 0 2
52275: PUSH
52276: LD_INT 0
52278: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
52279: LD_ADDR_VAR 0 3
52283: PUSH
52284: LD_VAR 0 1
52288: PPUSH
52289: CALL_OW 437
52293: ST_TO_ADDR
// if task then
52294: LD_VAR 0 3
52298: IFFALSE 52326
// if task [ 1 ] [ 1 ] = p then
52300: LD_VAR 0 3
52304: PUSH
52305: LD_INT 1
52307: ARRAY
52308: PUSH
52309: LD_INT 1
52311: ARRAY
52312: PUSH
52313: LD_STRING p
52315: EQUAL
52316: IFFALSE 52326
// result := true ;
52318: LD_ADDR_VAR 0 2
52322: PUSH
52323: LD_INT 1
52325: ST_TO_ADDR
// end ;
52326: LD_VAR 0 2
52330: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
52331: LD_INT 0
52333: PPUSH
52334: PPUSH
52335: PPUSH
52336: PPUSH
// if pos < 1 then
52337: LD_VAR 0 2
52341: PUSH
52342: LD_INT 1
52344: LESS
52345: IFFALSE 52349
// exit ;
52347: GO 52652
// if pos = 1 then
52349: LD_VAR 0 2
52353: PUSH
52354: LD_INT 1
52356: EQUAL
52357: IFFALSE 52390
// result := Replace ( arr , pos [ 1 ] , value ) else
52359: LD_ADDR_VAR 0 4
52363: PUSH
52364: LD_VAR 0 1
52368: PPUSH
52369: LD_VAR 0 2
52373: PUSH
52374: LD_INT 1
52376: ARRAY
52377: PPUSH
52378: LD_VAR 0 3
52382: PPUSH
52383: CALL_OW 1
52387: ST_TO_ADDR
52388: GO 52652
// begin tmp := arr ;
52390: LD_ADDR_VAR 0 6
52394: PUSH
52395: LD_VAR 0 1
52399: ST_TO_ADDR
// s_arr := [ tmp ] ;
52400: LD_ADDR_VAR 0 7
52404: PUSH
52405: LD_VAR 0 6
52409: PUSH
52410: EMPTY
52411: LIST
52412: ST_TO_ADDR
// for i = 1 to pos - 1 do
52413: LD_ADDR_VAR 0 5
52417: PUSH
52418: DOUBLE
52419: LD_INT 1
52421: DEC
52422: ST_TO_ADDR
52423: LD_VAR 0 2
52427: PUSH
52428: LD_INT 1
52430: MINUS
52431: PUSH
52432: FOR_TO
52433: IFFALSE 52478
// begin tmp := tmp [ pos [ i ] ] ;
52435: LD_ADDR_VAR 0 6
52439: PUSH
52440: LD_VAR 0 6
52444: PUSH
52445: LD_VAR 0 2
52449: PUSH
52450: LD_VAR 0 5
52454: ARRAY
52455: ARRAY
52456: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
52457: LD_ADDR_VAR 0 7
52461: PUSH
52462: LD_VAR 0 7
52466: PUSH
52467: LD_VAR 0 6
52471: PUSH
52472: EMPTY
52473: LIST
52474: ADD
52475: ST_TO_ADDR
// end ;
52476: GO 52432
52478: POP
52479: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
52480: LD_ADDR_VAR 0 6
52484: PUSH
52485: LD_VAR 0 6
52489: PPUSH
52490: LD_VAR 0 2
52494: PUSH
52495: LD_VAR 0 2
52499: ARRAY
52500: PPUSH
52501: LD_VAR 0 3
52505: PPUSH
52506: CALL_OW 1
52510: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
52511: LD_ADDR_VAR 0 7
52515: PUSH
52516: LD_VAR 0 7
52520: PPUSH
52521: LD_VAR 0 7
52525: PPUSH
52526: LD_VAR 0 6
52530: PPUSH
52531: CALL_OW 1
52535: ST_TO_ADDR
// for i = s_arr downto 2 do
52536: LD_ADDR_VAR 0 5
52540: PUSH
52541: DOUBLE
52542: LD_VAR 0 7
52546: INC
52547: ST_TO_ADDR
52548: LD_INT 2
52550: PUSH
52551: FOR_DOWNTO
52552: IFFALSE 52636
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
52554: LD_ADDR_VAR 0 6
52558: PUSH
52559: LD_VAR 0 7
52563: PUSH
52564: LD_VAR 0 5
52568: PUSH
52569: LD_INT 1
52571: MINUS
52572: ARRAY
52573: PPUSH
52574: LD_VAR 0 2
52578: PUSH
52579: LD_VAR 0 5
52583: PUSH
52584: LD_INT 1
52586: MINUS
52587: ARRAY
52588: PPUSH
52589: LD_VAR 0 7
52593: PUSH
52594: LD_VAR 0 5
52598: ARRAY
52599: PPUSH
52600: CALL_OW 1
52604: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
52605: LD_ADDR_VAR 0 7
52609: PUSH
52610: LD_VAR 0 7
52614: PPUSH
52615: LD_VAR 0 5
52619: PUSH
52620: LD_INT 1
52622: MINUS
52623: PPUSH
52624: LD_VAR 0 6
52628: PPUSH
52629: CALL_OW 1
52633: ST_TO_ADDR
// end ;
52634: GO 52551
52636: POP
52637: POP
// result := s_arr [ 1 ] ;
52638: LD_ADDR_VAR 0 4
52642: PUSH
52643: LD_VAR 0 7
52647: PUSH
52648: LD_INT 1
52650: ARRAY
52651: ST_TO_ADDR
// end ; end ;
52652: LD_VAR 0 4
52656: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
52657: LD_INT 0
52659: PPUSH
52660: PPUSH
// if not list then
52661: LD_VAR 0 1
52665: NOT
52666: IFFALSE 52670
// exit ;
52668: GO 52761
// i := list [ pos1 ] ;
52670: LD_ADDR_VAR 0 5
52674: PUSH
52675: LD_VAR 0 1
52679: PUSH
52680: LD_VAR 0 2
52684: ARRAY
52685: ST_TO_ADDR
// if not i then
52686: LD_VAR 0 5
52690: NOT
52691: IFFALSE 52695
// exit ;
52693: GO 52761
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
52695: LD_ADDR_VAR 0 1
52699: PUSH
52700: LD_VAR 0 1
52704: PPUSH
52705: LD_VAR 0 2
52709: PPUSH
52710: LD_VAR 0 1
52714: PUSH
52715: LD_VAR 0 3
52719: ARRAY
52720: PPUSH
52721: CALL_OW 1
52725: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
52726: LD_ADDR_VAR 0 1
52730: PUSH
52731: LD_VAR 0 1
52735: PPUSH
52736: LD_VAR 0 3
52740: PPUSH
52741: LD_VAR 0 5
52745: PPUSH
52746: CALL_OW 1
52750: ST_TO_ADDR
// result := list ;
52751: LD_ADDR_VAR 0 4
52755: PUSH
52756: LD_VAR 0 1
52760: ST_TO_ADDR
// end ;
52761: LD_VAR 0 4
52765: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
52766: LD_INT 0
52768: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
52769: LD_ADDR_VAR 0 5
52773: PUSH
52774: LD_VAR 0 1
52778: PPUSH
52779: CALL_OW 250
52783: PPUSH
52784: LD_VAR 0 1
52788: PPUSH
52789: CALL_OW 251
52793: PPUSH
52794: LD_VAR 0 2
52798: PPUSH
52799: LD_VAR 0 3
52803: PPUSH
52804: LD_VAR 0 4
52808: PPUSH
52809: CALL 52819 0 5
52813: ST_TO_ADDR
// end ;
52814: LD_VAR 0 5
52818: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
52819: LD_INT 0
52821: PPUSH
52822: PPUSH
52823: PPUSH
52824: PPUSH
// if not list then
52825: LD_VAR 0 3
52829: NOT
52830: IFFALSE 52834
// exit ;
52832: GO 53222
// result := [ ] ;
52834: LD_ADDR_VAR 0 6
52838: PUSH
52839: EMPTY
52840: ST_TO_ADDR
// for i in list do
52841: LD_ADDR_VAR 0 7
52845: PUSH
52846: LD_VAR 0 3
52850: PUSH
52851: FOR_IN
52852: IFFALSE 53054
// begin tmp := GetDistUnitXY ( i , x , y ) ;
52854: LD_ADDR_VAR 0 9
52858: PUSH
52859: LD_VAR 0 7
52863: PPUSH
52864: LD_VAR 0 1
52868: PPUSH
52869: LD_VAR 0 2
52873: PPUSH
52874: CALL_OW 297
52878: ST_TO_ADDR
// if not result then
52879: LD_VAR 0 6
52883: NOT
52884: IFFALSE 52910
// result := [ [ i , tmp ] ] else
52886: LD_ADDR_VAR 0 6
52890: PUSH
52891: LD_VAR 0 7
52895: PUSH
52896: LD_VAR 0 9
52900: PUSH
52901: EMPTY
52902: LIST
52903: LIST
52904: PUSH
52905: EMPTY
52906: LIST
52907: ST_TO_ADDR
52908: GO 53052
// begin if result [ result ] [ 2 ] < tmp then
52910: LD_VAR 0 6
52914: PUSH
52915: LD_VAR 0 6
52919: ARRAY
52920: PUSH
52921: LD_INT 2
52923: ARRAY
52924: PUSH
52925: LD_VAR 0 9
52929: LESS
52930: IFFALSE 52972
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
52932: LD_ADDR_VAR 0 6
52936: PUSH
52937: LD_VAR 0 6
52941: PPUSH
52942: LD_VAR 0 6
52946: PUSH
52947: LD_INT 1
52949: PLUS
52950: PPUSH
52951: LD_VAR 0 7
52955: PUSH
52956: LD_VAR 0 9
52960: PUSH
52961: EMPTY
52962: LIST
52963: LIST
52964: PPUSH
52965: CALL_OW 2
52969: ST_TO_ADDR
52970: GO 53052
// for j = 1 to result do
52972: LD_ADDR_VAR 0 8
52976: PUSH
52977: DOUBLE
52978: LD_INT 1
52980: DEC
52981: ST_TO_ADDR
52982: LD_VAR 0 6
52986: PUSH
52987: FOR_TO
52988: IFFALSE 53050
// begin if tmp < result [ j ] [ 2 ] then
52990: LD_VAR 0 9
52994: PUSH
52995: LD_VAR 0 6
52999: PUSH
53000: LD_VAR 0 8
53004: ARRAY
53005: PUSH
53006: LD_INT 2
53008: ARRAY
53009: LESS
53010: IFFALSE 53048
// begin result := Insert ( result , j , [ i , tmp ] ) ;
53012: LD_ADDR_VAR 0 6
53016: PUSH
53017: LD_VAR 0 6
53021: PPUSH
53022: LD_VAR 0 8
53026: PPUSH
53027: LD_VAR 0 7
53031: PUSH
53032: LD_VAR 0 9
53036: PUSH
53037: EMPTY
53038: LIST
53039: LIST
53040: PPUSH
53041: CALL_OW 2
53045: ST_TO_ADDR
// break ;
53046: GO 53050
// end ; end ;
53048: GO 52987
53050: POP
53051: POP
// end ; end ;
53052: GO 52851
53054: POP
53055: POP
// if result and not asc then
53056: LD_VAR 0 6
53060: PUSH
53061: LD_VAR 0 4
53065: NOT
53066: AND
53067: IFFALSE 53142
// begin tmp := result ;
53069: LD_ADDR_VAR 0 9
53073: PUSH
53074: LD_VAR 0 6
53078: ST_TO_ADDR
// for i = tmp downto 1 do
53079: LD_ADDR_VAR 0 7
53083: PUSH
53084: DOUBLE
53085: LD_VAR 0 9
53089: INC
53090: ST_TO_ADDR
53091: LD_INT 1
53093: PUSH
53094: FOR_DOWNTO
53095: IFFALSE 53140
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
53097: LD_ADDR_VAR 0 6
53101: PUSH
53102: LD_VAR 0 6
53106: PPUSH
53107: LD_VAR 0 9
53111: PUSH
53112: LD_VAR 0 7
53116: MINUS
53117: PUSH
53118: LD_INT 1
53120: PLUS
53121: PPUSH
53122: LD_VAR 0 9
53126: PUSH
53127: LD_VAR 0 7
53131: ARRAY
53132: PPUSH
53133: CALL_OW 1
53137: ST_TO_ADDR
53138: GO 53094
53140: POP
53141: POP
// end ; tmp := [ ] ;
53142: LD_ADDR_VAR 0 9
53146: PUSH
53147: EMPTY
53148: ST_TO_ADDR
// if mode then
53149: LD_VAR 0 5
53153: IFFALSE 53222
// begin for i = 1 to result do
53155: LD_ADDR_VAR 0 7
53159: PUSH
53160: DOUBLE
53161: LD_INT 1
53163: DEC
53164: ST_TO_ADDR
53165: LD_VAR 0 6
53169: PUSH
53170: FOR_TO
53171: IFFALSE 53210
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
53173: LD_ADDR_VAR 0 9
53177: PUSH
53178: LD_VAR 0 9
53182: PPUSH
53183: LD_VAR 0 7
53187: PPUSH
53188: LD_VAR 0 6
53192: PUSH
53193: LD_VAR 0 7
53197: ARRAY
53198: PUSH
53199: LD_INT 1
53201: ARRAY
53202: PPUSH
53203: CALL_OW 1
53207: ST_TO_ADDR
53208: GO 53170
53210: POP
53211: POP
// result := tmp ;
53212: LD_ADDR_VAR 0 6
53216: PUSH
53217: LD_VAR 0 9
53221: ST_TO_ADDR
// end ; end ;
53222: LD_VAR 0 6
53226: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
53227: LD_INT 0
53229: PPUSH
53230: PPUSH
53231: PPUSH
53232: PPUSH
53233: PPUSH
53234: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
53235: LD_ADDR_VAR 0 5
53239: PUSH
53240: LD_INT 0
53242: PUSH
53243: LD_INT 0
53245: PUSH
53246: LD_INT 0
53248: PUSH
53249: EMPTY
53250: PUSH
53251: EMPTY
53252: LIST
53253: LIST
53254: LIST
53255: LIST
53256: ST_TO_ADDR
// if not x or not y then
53257: LD_VAR 0 2
53261: NOT
53262: PUSH
53263: LD_VAR 0 3
53267: NOT
53268: OR
53269: IFFALSE 53273
// exit ;
53271: GO 54919
// if not range then
53273: LD_VAR 0 4
53277: NOT
53278: IFFALSE 53288
// range := 10 ;
53280: LD_ADDR_VAR 0 4
53284: PUSH
53285: LD_INT 10
53287: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53288: LD_ADDR_VAR 0 8
53292: PUSH
53293: LD_INT 81
53295: PUSH
53296: LD_VAR 0 1
53300: PUSH
53301: EMPTY
53302: LIST
53303: LIST
53304: PUSH
53305: LD_INT 92
53307: PUSH
53308: LD_VAR 0 2
53312: PUSH
53313: LD_VAR 0 3
53317: PUSH
53318: LD_VAR 0 4
53322: PUSH
53323: EMPTY
53324: LIST
53325: LIST
53326: LIST
53327: LIST
53328: PUSH
53329: LD_INT 3
53331: PUSH
53332: LD_INT 21
53334: PUSH
53335: LD_INT 3
53337: PUSH
53338: EMPTY
53339: LIST
53340: LIST
53341: PUSH
53342: EMPTY
53343: LIST
53344: LIST
53345: PUSH
53346: EMPTY
53347: LIST
53348: LIST
53349: LIST
53350: PPUSH
53351: CALL_OW 69
53355: ST_TO_ADDR
// if not tmp then
53356: LD_VAR 0 8
53360: NOT
53361: IFFALSE 53365
// exit ;
53363: GO 54919
// for i in tmp do
53365: LD_ADDR_VAR 0 6
53369: PUSH
53370: LD_VAR 0 8
53374: PUSH
53375: FOR_IN
53376: IFFALSE 54894
// begin points := [ 0 , 0 , 0 ] ;
53378: LD_ADDR_VAR 0 9
53382: PUSH
53383: LD_INT 0
53385: PUSH
53386: LD_INT 0
53388: PUSH
53389: LD_INT 0
53391: PUSH
53392: EMPTY
53393: LIST
53394: LIST
53395: LIST
53396: ST_TO_ADDR
// bpoints := 1 ;
53397: LD_ADDR_VAR 0 10
53401: PUSH
53402: LD_INT 1
53404: ST_TO_ADDR
// case GetType ( i ) of unit_human :
53405: LD_VAR 0 6
53409: PPUSH
53410: CALL_OW 247
53414: PUSH
53415: LD_INT 1
53417: DOUBLE
53418: EQUAL
53419: IFTRUE 53423
53421: GO 54001
53423: POP
// begin if GetClass ( i ) = 1 then
53424: LD_VAR 0 6
53428: PPUSH
53429: CALL_OW 257
53433: PUSH
53434: LD_INT 1
53436: EQUAL
53437: IFFALSE 53458
// points := [ 10 , 5 , 3 ] ;
53439: LD_ADDR_VAR 0 9
53443: PUSH
53444: LD_INT 10
53446: PUSH
53447: LD_INT 5
53449: PUSH
53450: LD_INT 3
53452: PUSH
53453: EMPTY
53454: LIST
53455: LIST
53456: LIST
53457: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
53458: LD_VAR 0 6
53462: PPUSH
53463: CALL_OW 257
53467: PUSH
53468: LD_INT 2
53470: PUSH
53471: LD_INT 3
53473: PUSH
53474: LD_INT 4
53476: PUSH
53477: EMPTY
53478: LIST
53479: LIST
53480: LIST
53481: IN
53482: IFFALSE 53503
// points := [ 3 , 2 , 1 ] ;
53484: LD_ADDR_VAR 0 9
53488: PUSH
53489: LD_INT 3
53491: PUSH
53492: LD_INT 2
53494: PUSH
53495: LD_INT 1
53497: PUSH
53498: EMPTY
53499: LIST
53500: LIST
53501: LIST
53502: ST_TO_ADDR
// if GetClass ( i ) = 5 then
53503: LD_VAR 0 6
53507: PPUSH
53508: CALL_OW 257
53512: PUSH
53513: LD_INT 5
53515: EQUAL
53516: IFFALSE 53537
// points := [ 130 , 5 , 2 ] ;
53518: LD_ADDR_VAR 0 9
53522: PUSH
53523: LD_INT 130
53525: PUSH
53526: LD_INT 5
53528: PUSH
53529: LD_INT 2
53531: PUSH
53532: EMPTY
53533: LIST
53534: LIST
53535: LIST
53536: ST_TO_ADDR
// if GetClass ( i ) = 8 then
53537: LD_VAR 0 6
53541: PPUSH
53542: CALL_OW 257
53546: PUSH
53547: LD_INT 8
53549: EQUAL
53550: IFFALSE 53571
// points := [ 35 , 35 , 30 ] ;
53552: LD_ADDR_VAR 0 9
53556: PUSH
53557: LD_INT 35
53559: PUSH
53560: LD_INT 35
53562: PUSH
53563: LD_INT 30
53565: PUSH
53566: EMPTY
53567: LIST
53568: LIST
53569: LIST
53570: ST_TO_ADDR
// if GetClass ( i ) = 9 then
53571: LD_VAR 0 6
53575: PPUSH
53576: CALL_OW 257
53580: PUSH
53581: LD_INT 9
53583: EQUAL
53584: IFFALSE 53605
// points := [ 20 , 55 , 40 ] ;
53586: LD_ADDR_VAR 0 9
53590: PUSH
53591: LD_INT 20
53593: PUSH
53594: LD_INT 55
53596: PUSH
53597: LD_INT 40
53599: PUSH
53600: EMPTY
53601: LIST
53602: LIST
53603: LIST
53604: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
53605: LD_VAR 0 6
53609: PPUSH
53610: CALL_OW 257
53614: PUSH
53615: LD_INT 12
53617: PUSH
53618: LD_INT 16
53620: PUSH
53621: EMPTY
53622: LIST
53623: LIST
53624: IN
53625: IFFALSE 53646
// points := [ 5 , 3 , 2 ] ;
53627: LD_ADDR_VAR 0 9
53631: PUSH
53632: LD_INT 5
53634: PUSH
53635: LD_INT 3
53637: PUSH
53638: LD_INT 2
53640: PUSH
53641: EMPTY
53642: LIST
53643: LIST
53644: LIST
53645: ST_TO_ADDR
// if GetClass ( i ) = 17 then
53646: LD_VAR 0 6
53650: PPUSH
53651: CALL_OW 257
53655: PUSH
53656: LD_INT 17
53658: EQUAL
53659: IFFALSE 53680
// points := [ 100 , 50 , 75 ] ;
53661: LD_ADDR_VAR 0 9
53665: PUSH
53666: LD_INT 100
53668: PUSH
53669: LD_INT 50
53671: PUSH
53672: LD_INT 75
53674: PUSH
53675: EMPTY
53676: LIST
53677: LIST
53678: LIST
53679: ST_TO_ADDR
// if GetClass ( i ) = 15 then
53680: LD_VAR 0 6
53684: PPUSH
53685: CALL_OW 257
53689: PUSH
53690: LD_INT 15
53692: EQUAL
53693: IFFALSE 53714
// points := [ 10 , 5 , 3 ] ;
53695: LD_ADDR_VAR 0 9
53699: PUSH
53700: LD_INT 10
53702: PUSH
53703: LD_INT 5
53705: PUSH
53706: LD_INT 3
53708: PUSH
53709: EMPTY
53710: LIST
53711: LIST
53712: LIST
53713: ST_TO_ADDR
// if GetClass ( i ) = 14 then
53714: LD_VAR 0 6
53718: PPUSH
53719: CALL_OW 257
53723: PUSH
53724: LD_INT 14
53726: EQUAL
53727: IFFALSE 53748
// points := [ 10 , 0 , 0 ] ;
53729: LD_ADDR_VAR 0 9
53733: PUSH
53734: LD_INT 10
53736: PUSH
53737: LD_INT 0
53739: PUSH
53740: LD_INT 0
53742: PUSH
53743: EMPTY
53744: LIST
53745: LIST
53746: LIST
53747: ST_TO_ADDR
// if GetClass ( i ) = 11 then
53748: LD_VAR 0 6
53752: PPUSH
53753: CALL_OW 257
53757: PUSH
53758: LD_INT 11
53760: EQUAL
53761: IFFALSE 53782
// points := [ 30 , 10 , 5 ] ;
53763: LD_ADDR_VAR 0 9
53767: PUSH
53768: LD_INT 30
53770: PUSH
53771: LD_INT 10
53773: PUSH
53774: LD_INT 5
53776: PUSH
53777: EMPTY
53778: LIST
53779: LIST
53780: LIST
53781: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
53782: LD_VAR 0 1
53786: PPUSH
53787: LD_INT 5
53789: PPUSH
53790: CALL_OW 321
53794: PUSH
53795: LD_INT 2
53797: EQUAL
53798: IFFALSE 53815
// bpoints := bpoints * 1.8 ;
53800: LD_ADDR_VAR 0 10
53804: PUSH
53805: LD_VAR 0 10
53809: PUSH
53810: LD_REAL  1.80000000000000E+0000
53813: MUL
53814: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
53815: LD_VAR 0 6
53819: PPUSH
53820: CALL_OW 257
53824: PUSH
53825: LD_INT 1
53827: PUSH
53828: LD_INT 2
53830: PUSH
53831: LD_INT 3
53833: PUSH
53834: LD_INT 4
53836: PUSH
53837: EMPTY
53838: LIST
53839: LIST
53840: LIST
53841: LIST
53842: IN
53843: PUSH
53844: LD_VAR 0 1
53848: PPUSH
53849: LD_INT 51
53851: PPUSH
53852: CALL_OW 321
53856: PUSH
53857: LD_INT 2
53859: EQUAL
53860: AND
53861: IFFALSE 53878
// bpoints := bpoints * 1.2 ;
53863: LD_ADDR_VAR 0 10
53867: PUSH
53868: LD_VAR 0 10
53872: PUSH
53873: LD_REAL  1.20000000000000E+0000
53876: MUL
53877: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
53878: LD_VAR 0 6
53882: PPUSH
53883: CALL_OW 257
53887: PUSH
53888: LD_INT 5
53890: PUSH
53891: LD_INT 7
53893: PUSH
53894: LD_INT 9
53896: PUSH
53897: EMPTY
53898: LIST
53899: LIST
53900: LIST
53901: IN
53902: PUSH
53903: LD_VAR 0 1
53907: PPUSH
53908: LD_INT 52
53910: PPUSH
53911: CALL_OW 321
53915: PUSH
53916: LD_INT 2
53918: EQUAL
53919: AND
53920: IFFALSE 53937
// bpoints := bpoints * 1.5 ;
53922: LD_ADDR_VAR 0 10
53926: PUSH
53927: LD_VAR 0 10
53931: PUSH
53932: LD_REAL  1.50000000000000E+0000
53935: MUL
53936: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
53937: LD_VAR 0 1
53941: PPUSH
53942: LD_INT 66
53944: PPUSH
53945: CALL_OW 321
53949: PUSH
53950: LD_INT 2
53952: EQUAL
53953: IFFALSE 53970
// bpoints := bpoints * 1.1 ;
53955: LD_ADDR_VAR 0 10
53959: PUSH
53960: LD_VAR 0 10
53964: PUSH
53965: LD_REAL  1.10000000000000E+0000
53968: MUL
53969: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
53970: LD_ADDR_VAR 0 10
53974: PUSH
53975: LD_VAR 0 10
53979: PUSH
53980: LD_VAR 0 6
53984: PPUSH
53985: LD_INT 1
53987: PPUSH
53988: CALL_OW 259
53992: PUSH
53993: LD_REAL  1.15000000000000E+0000
53996: MUL
53997: MUL
53998: ST_TO_ADDR
// end ; unit_vehicle :
53999: GO 54823
54001: LD_INT 2
54003: DOUBLE
54004: EQUAL
54005: IFTRUE 54009
54007: GO 54811
54009: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
54010: LD_VAR 0 6
54014: PPUSH
54015: CALL_OW 264
54019: PUSH
54020: LD_INT 2
54022: PUSH
54023: LD_INT 42
54025: PUSH
54026: LD_INT 24
54028: PUSH
54029: EMPTY
54030: LIST
54031: LIST
54032: LIST
54033: IN
54034: IFFALSE 54055
// points := [ 25 , 5 , 3 ] ;
54036: LD_ADDR_VAR 0 9
54040: PUSH
54041: LD_INT 25
54043: PUSH
54044: LD_INT 5
54046: PUSH
54047: LD_INT 3
54049: PUSH
54050: EMPTY
54051: LIST
54052: LIST
54053: LIST
54054: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
54055: LD_VAR 0 6
54059: PPUSH
54060: CALL_OW 264
54064: PUSH
54065: LD_INT 4
54067: PUSH
54068: LD_INT 43
54070: PUSH
54071: LD_INT 25
54073: PUSH
54074: EMPTY
54075: LIST
54076: LIST
54077: LIST
54078: IN
54079: IFFALSE 54100
// points := [ 40 , 15 , 5 ] ;
54081: LD_ADDR_VAR 0 9
54085: PUSH
54086: LD_INT 40
54088: PUSH
54089: LD_INT 15
54091: PUSH
54092: LD_INT 5
54094: PUSH
54095: EMPTY
54096: LIST
54097: LIST
54098: LIST
54099: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
54100: LD_VAR 0 6
54104: PPUSH
54105: CALL_OW 264
54109: PUSH
54110: LD_INT 3
54112: PUSH
54113: LD_INT 23
54115: PUSH
54116: EMPTY
54117: LIST
54118: LIST
54119: IN
54120: IFFALSE 54141
// points := [ 7 , 25 , 8 ] ;
54122: LD_ADDR_VAR 0 9
54126: PUSH
54127: LD_INT 7
54129: PUSH
54130: LD_INT 25
54132: PUSH
54133: LD_INT 8
54135: PUSH
54136: EMPTY
54137: LIST
54138: LIST
54139: LIST
54140: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
54141: LD_VAR 0 6
54145: PPUSH
54146: CALL_OW 264
54150: PUSH
54151: LD_INT 5
54153: PUSH
54154: LD_INT 27
54156: PUSH
54157: LD_INT 44
54159: PUSH
54160: EMPTY
54161: LIST
54162: LIST
54163: LIST
54164: IN
54165: IFFALSE 54186
// points := [ 14 , 50 , 16 ] ;
54167: LD_ADDR_VAR 0 9
54171: PUSH
54172: LD_INT 14
54174: PUSH
54175: LD_INT 50
54177: PUSH
54178: LD_INT 16
54180: PUSH
54181: EMPTY
54182: LIST
54183: LIST
54184: LIST
54185: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
54186: LD_VAR 0 6
54190: PPUSH
54191: CALL_OW 264
54195: PUSH
54196: LD_INT 6
54198: PUSH
54199: LD_INT 46
54201: PUSH
54202: EMPTY
54203: LIST
54204: LIST
54205: IN
54206: IFFALSE 54227
// points := [ 32 , 120 , 70 ] ;
54208: LD_ADDR_VAR 0 9
54212: PUSH
54213: LD_INT 32
54215: PUSH
54216: LD_INT 120
54218: PUSH
54219: LD_INT 70
54221: PUSH
54222: EMPTY
54223: LIST
54224: LIST
54225: LIST
54226: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
54227: LD_VAR 0 6
54231: PPUSH
54232: CALL_OW 264
54236: PUSH
54237: LD_INT 7
54239: PUSH
54240: LD_INT 28
54242: PUSH
54243: LD_INT 45
54245: PUSH
54246: EMPTY
54247: LIST
54248: LIST
54249: LIST
54250: IN
54251: IFFALSE 54272
// points := [ 35 , 20 , 45 ] ;
54253: LD_ADDR_VAR 0 9
54257: PUSH
54258: LD_INT 35
54260: PUSH
54261: LD_INT 20
54263: PUSH
54264: LD_INT 45
54266: PUSH
54267: EMPTY
54268: LIST
54269: LIST
54270: LIST
54271: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
54272: LD_VAR 0 6
54276: PPUSH
54277: CALL_OW 264
54281: PUSH
54282: LD_INT 47
54284: PUSH
54285: EMPTY
54286: LIST
54287: IN
54288: IFFALSE 54309
// points := [ 67 , 45 , 75 ] ;
54290: LD_ADDR_VAR 0 9
54294: PUSH
54295: LD_INT 67
54297: PUSH
54298: LD_INT 45
54300: PUSH
54301: LD_INT 75
54303: PUSH
54304: EMPTY
54305: LIST
54306: LIST
54307: LIST
54308: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
54309: LD_VAR 0 6
54313: PPUSH
54314: CALL_OW 264
54318: PUSH
54319: LD_INT 26
54321: PUSH
54322: EMPTY
54323: LIST
54324: IN
54325: IFFALSE 54346
// points := [ 120 , 30 , 80 ] ;
54327: LD_ADDR_VAR 0 9
54331: PUSH
54332: LD_INT 120
54334: PUSH
54335: LD_INT 30
54337: PUSH
54338: LD_INT 80
54340: PUSH
54341: EMPTY
54342: LIST
54343: LIST
54344: LIST
54345: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
54346: LD_VAR 0 6
54350: PPUSH
54351: CALL_OW 264
54355: PUSH
54356: LD_INT 22
54358: PUSH
54359: EMPTY
54360: LIST
54361: IN
54362: IFFALSE 54383
// points := [ 40 , 1 , 1 ] ;
54364: LD_ADDR_VAR 0 9
54368: PUSH
54369: LD_INT 40
54371: PUSH
54372: LD_INT 1
54374: PUSH
54375: LD_INT 1
54377: PUSH
54378: EMPTY
54379: LIST
54380: LIST
54381: LIST
54382: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
54383: LD_VAR 0 6
54387: PPUSH
54388: CALL_OW 264
54392: PUSH
54393: LD_INT 29
54395: PUSH
54396: EMPTY
54397: LIST
54398: IN
54399: IFFALSE 54420
// points := [ 70 , 200 , 400 ] ;
54401: LD_ADDR_VAR 0 9
54405: PUSH
54406: LD_INT 70
54408: PUSH
54409: LD_INT 200
54411: PUSH
54412: LD_INT 400
54414: PUSH
54415: EMPTY
54416: LIST
54417: LIST
54418: LIST
54419: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
54420: LD_VAR 0 6
54424: PPUSH
54425: CALL_OW 264
54429: PUSH
54430: LD_INT 14
54432: PUSH
54433: LD_INT 53
54435: PUSH
54436: EMPTY
54437: LIST
54438: LIST
54439: IN
54440: IFFALSE 54461
// points := [ 40 , 10 , 20 ] ;
54442: LD_ADDR_VAR 0 9
54446: PUSH
54447: LD_INT 40
54449: PUSH
54450: LD_INT 10
54452: PUSH
54453: LD_INT 20
54455: PUSH
54456: EMPTY
54457: LIST
54458: LIST
54459: LIST
54460: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
54461: LD_VAR 0 6
54465: PPUSH
54466: CALL_OW 264
54470: PUSH
54471: LD_INT 9
54473: PUSH
54474: EMPTY
54475: LIST
54476: IN
54477: IFFALSE 54498
// points := [ 5 , 70 , 20 ] ;
54479: LD_ADDR_VAR 0 9
54483: PUSH
54484: LD_INT 5
54486: PUSH
54487: LD_INT 70
54489: PUSH
54490: LD_INT 20
54492: PUSH
54493: EMPTY
54494: LIST
54495: LIST
54496: LIST
54497: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
54498: LD_VAR 0 6
54502: PPUSH
54503: CALL_OW 264
54507: PUSH
54508: LD_INT 10
54510: PUSH
54511: EMPTY
54512: LIST
54513: IN
54514: IFFALSE 54535
// points := [ 35 , 110 , 70 ] ;
54516: LD_ADDR_VAR 0 9
54520: PUSH
54521: LD_INT 35
54523: PUSH
54524: LD_INT 110
54526: PUSH
54527: LD_INT 70
54529: PUSH
54530: EMPTY
54531: LIST
54532: LIST
54533: LIST
54534: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
54535: LD_VAR 0 6
54539: PPUSH
54540: CALL_OW 265
54544: PUSH
54545: LD_INT 25
54547: EQUAL
54548: IFFALSE 54569
// points := [ 80 , 65 , 100 ] ;
54550: LD_ADDR_VAR 0 9
54554: PUSH
54555: LD_INT 80
54557: PUSH
54558: LD_INT 65
54560: PUSH
54561: LD_INT 100
54563: PUSH
54564: EMPTY
54565: LIST
54566: LIST
54567: LIST
54568: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
54569: LD_VAR 0 6
54573: PPUSH
54574: CALL_OW 263
54578: PUSH
54579: LD_INT 1
54581: EQUAL
54582: IFFALSE 54617
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
54584: LD_ADDR_VAR 0 10
54588: PUSH
54589: LD_VAR 0 10
54593: PUSH
54594: LD_VAR 0 6
54598: PPUSH
54599: CALL_OW 311
54603: PPUSH
54604: LD_INT 3
54606: PPUSH
54607: CALL_OW 259
54611: PUSH
54612: LD_INT 4
54614: MUL
54615: MUL
54616: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
54617: LD_VAR 0 6
54621: PPUSH
54622: CALL_OW 263
54626: PUSH
54627: LD_INT 2
54629: EQUAL
54630: IFFALSE 54681
// begin j := IsControledBy ( i ) ;
54632: LD_ADDR_VAR 0 7
54636: PUSH
54637: LD_VAR 0 6
54641: PPUSH
54642: CALL_OW 312
54646: ST_TO_ADDR
// if j then
54647: LD_VAR 0 7
54651: IFFALSE 54681
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
54653: LD_ADDR_VAR 0 10
54657: PUSH
54658: LD_VAR 0 10
54662: PUSH
54663: LD_VAR 0 7
54667: PPUSH
54668: LD_INT 3
54670: PPUSH
54671: CALL_OW 259
54675: PUSH
54676: LD_INT 3
54678: MUL
54679: MUL
54680: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
54681: LD_VAR 0 6
54685: PPUSH
54686: CALL_OW 264
54690: PUSH
54691: LD_INT 5
54693: PUSH
54694: LD_INT 6
54696: PUSH
54697: LD_INT 46
54699: PUSH
54700: LD_INT 44
54702: PUSH
54703: LD_INT 47
54705: PUSH
54706: LD_INT 45
54708: PUSH
54709: LD_INT 28
54711: PUSH
54712: LD_INT 7
54714: PUSH
54715: LD_INT 27
54717: PUSH
54718: LD_INT 29
54720: PUSH
54721: EMPTY
54722: LIST
54723: LIST
54724: LIST
54725: LIST
54726: LIST
54727: LIST
54728: LIST
54729: LIST
54730: LIST
54731: LIST
54732: IN
54733: PUSH
54734: LD_VAR 0 1
54738: PPUSH
54739: LD_INT 52
54741: PPUSH
54742: CALL_OW 321
54746: PUSH
54747: LD_INT 2
54749: EQUAL
54750: AND
54751: IFFALSE 54768
// bpoints := bpoints * 1.2 ;
54753: LD_ADDR_VAR 0 10
54757: PUSH
54758: LD_VAR 0 10
54762: PUSH
54763: LD_REAL  1.20000000000000E+0000
54766: MUL
54767: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
54768: LD_VAR 0 6
54772: PPUSH
54773: CALL_OW 264
54777: PUSH
54778: LD_INT 6
54780: PUSH
54781: LD_INT 46
54783: PUSH
54784: LD_INT 47
54786: PUSH
54787: EMPTY
54788: LIST
54789: LIST
54790: LIST
54791: IN
54792: IFFALSE 54809
// bpoints := bpoints * 1.2 ;
54794: LD_ADDR_VAR 0 10
54798: PUSH
54799: LD_VAR 0 10
54803: PUSH
54804: LD_REAL  1.20000000000000E+0000
54807: MUL
54808: ST_TO_ADDR
// end ; unit_building :
54809: GO 54823
54811: LD_INT 3
54813: DOUBLE
54814: EQUAL
54815: IFTRUE 54819
54817: GO 54822
54819: POP
// ; end ;
54820: GO 54823
54822: POP
// for j = 1 to 3 do
54823: LD_ADDR_VAR 0 7
54827: PUSH
54828: DOUBLE
54829: LD_INT 1
54831: DEC
54832: ST_TO_ADDR
54833: LD_INT 3
54835: PUSH
54836: FOR_TO
54837: IFFALSE 54890
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
54839: LD_ADDR_VAR 0 5
54843: PUSH
54844: LD_VAR 0 5
54848: PPUSH
54849: LD_VAR 0 7
54853: PPUSH
54854: LD_VAR 0 5
54858: PUSH
54859: LD_VAR 0 7
54863: ARRAY
54864: PUSH
54865: LD_VAR 0 9
54869: PUSH
54870: LD_VAR 0 7
54874: ARRAY
54875: PUSH
54876: LD_VAR 0 10
54880: MUL
54881: PLUS
54882: PPUSH
54883: CALL_OW 1
54887: ST_TO_ADDR
54888: GO 54836
54890: POP
54891: POP
// end ;
54892: GO 53375
54894: POP
54895: POP
// result := Replace ( result , 4 , tmp ) ;
54896: LD_ADDR_VAR 0 5
54900: PUSH
54901: LD_VAR 0 5
54905: PPUSH
54906: LD_INT 4
54908: PPUSH
54909: LD_VAR 0 8
54913: PPUSH
54914: CALL_OW 1
54918: ST_TO_ADDR
// end ;
54919: LD_VAR 0 5
54923: RET
// export function DangerAtRange ( unit , range ) ; begin
54924: LD_INT 0
54926: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
54927: LD_ADDR_VAR 0 3
54931: PUSH
54932: LD_VAR 0 1
54936: PPUSH
54937: CALL_OW 255
54941: PPUSH
54942: LD_VAR 0 1
54946: PPUSH
54947: CALL_OW 250
54951: PPUSH
54952: LD_VAR 0 1
54956: PPUSH
54957: CALL_OW 251
54961: PPUSH
54962: LD_VAR 0 2
54966: PPUSH
54967: CALL 53227 0 4
54971: ST_TO_ADDR
// end ;
54972: LD_VAR 0 3
54976: RET
// export function DangerInArea ( side , area ) ; begin
54977: LD_INT 0
54979: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
54980: LD_ADDR_VAR 0 3
54984: PUSH
54985: LD_VAR 0 2
54989: PPUSH
54990: LD_INT 81
54992: PUSH
54993: LD_VAR 0 1
54997: PUSH
54998: EMPTY
54999: LIST
55000: LIST
55001: PPUSH
55002: CALL_OW 70
55006: ST_TO_ADDR
// end ;
55007: LD_VAR 0 3
55011: RET
// export function IsExtension ( b ) ; begin
55012: LD_INT 0
55014: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
55015: LD_ADDR_VAR 0 2
55019: PUSH
55020: LD_VAR 0 1
55024: PUSH
55025: LD_INT 23
55027: PUSH
55028: LD_INT 20
55030: PUSH
55031: LD_INT 22
55033: PUSH
55034: LD_INT 17
55036: PUSH
55037: LD_INT 24
55039: PUSH
55040: LD_INT 21
55042: PUSH
55043: LD_INT 19
55045: PUSH
55046: LD_INT 16
55048: PUSH
55049: LD_INT 25
55051: PUSH
55052: LD_INT 18
55054: PUSH
55055: EMPTY
55056: LIST
55057: LIST
55058: LIST
55059: LIST
55060: LIST
55061: LIST
55062: LIST
55063: LIST
55064: LIST
55065: LIST
55066: IN
55067: ST_TO_ADDR
// end ;
55068: LD_VAR 0 2
55072: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
55073: LD_INT 0
55075: PPUSH
55076: PPUSH
55077: PPUSH
// result := [ ] ;
55078: LD_ADDR_VAR 0 3
55082: PUSH
55083: EMPTY
55084: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
55085: LD_ADDR_VAR 0 4
55089: PUSH
55090: LD_VAR 0 2
55094: PPUSH
55095: LD_INT 21
55097: PUSH
55098: LD_INT 3
55100: PUSH
55101: EMPTY
55102: LIST
55103: LIST
55104: PPUSH
55105: CALL_OW 70
55109: ST_TO_ADDR
// if not tmp then
55110: LD_VAR 0 4
55114: NOT
55115: IFFALSE 55119
// exit ;
55117: GO 55177
// for i in tmp do
55119: LD_ADDR_VAR 0 5
55123: PUSH
55124: LD_VAR 0 4
55128: PUSH
55129: FOR_IN
55130: IFFALSE 55165
// if GetBase ( i ) <> base then
55132: LD_VAR 0 5
55136: PPUSH
55137: CALL_OW 274
55141: PUSH
55142: LD_VAR 0 1
55146: NONEQUAL
55147: IFFALSE 55163
// ComLinkToBase ( base , i ) ;
55149: LD_VAR 0 1
55153: PPUSH
55154: LD_VAR 0 5
55158: PPUSH
55159: CALL_OW 169
55163: GO 55129
55165: POP
55166: POP
// result := tmp ;
55167: LD_ADDR_VAR 0 3
55171: PUSH
55172: LD_VAR 0 4
55176: ST_TO_ADDR
// end ;
55177: LD_VAR 0 3
55181: RET
// export function ComComplete ( unit , b ) ; var i ; begin
55182: LD_INT 0
55184: PPUSH
55185: PPUSH
// if BuildingStatus ( b ) = bs_build then
55186: LD_VAR 0 2
55190: PPUSH
55191: CALL_OW 461
55195: PUSH
55196: LD_INT 1
55198: EQUAL
55199: IFFALSE 55259
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
55201: LD_VAR 0 1
55205: PPUSH
55206: LD_STRING h
55208: PUSH
55209: LD_VAR 0 2
55213: PPUSH
55214: CALL_OW 250
55218: PUSH
55219: LD_VAR 0 2
55223: PPUSH
55224: CALL_OW 251
55228: PUSH
55229: LD_VAR 0 2
55233: PUSH
55234: LD_INT 0
55236: PUSH
55237: LD_INT 0
55239: PUSH
55240: LD_INT 0
55242: PUSH
55243: EMPTY
55244: LIST
55245: LIST
55246: LIST
55247: LIST
55248: LIST
55249: LIST
55250: LIST
55251: PUSH
55252: EMPTY
55253: LIST
55254: PPUSH
55255: CALL_OW 446
// end ;
55259: LD_VAR 0 3
55263: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
55264: LD_INT 0
55266: PPUSH
55267: PPUSH
55268: PPUSH
55269: PPUSH
55270: PPUSH
55271: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
55272: LD_VAR 0 1
55276: NOT
55277: PUSH
55278: LD_VAR 0 1
55282: PPUSH
55283: CALL_OW 263
55287: PUSH
55288: LD_INT 2
55290: EQUAL
55291: NOT
55292: OR
55293: IFFALSE 55297
// exit ;
55295: GO 55613
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
55297: LD_ADDR_VAR 0 6
55301: PUSH
55302: LD_INT 22
55304: PUSH
55305: LD_VAR 0 1
55309: PPUSH
55310: CALL_OW 255
55314: PUSH
55315: EMPTY
55316: LIST
55317: LIST
55318: PUSH
55319: LD_INT 2
55321: PUSH
55322: LD_INT 30
55324: PUSH
55325: LD_INT 36
55327: PUSH
55328: EMPTY
55329: LIST
55330: LIST
55331: PUSH
55332: LD_INT 34
55334: PUSH
55335: LD_INT 31
55337: PUSH
55338: EMPTY
55339: LIST
55340: LIST
55341: PUSH
55342: EMPTY
55343: LIST
55344: LIST
55345: LIST
55346: PUSH
55347: EMPTY
55348: LIST
55349: LIST
55350: PPUSH
55351: CALL_OW 69
55355: ST_TO_ADDR
// if not tmp then
55356: LD_VAR 0 6
55360: NOT
55361: IFFALSE 55365
// exit ;
55363: GO 55613
// result := [ ] ;
55365: LD_ADDR_VAR 0 2
55369: PUSH
55370: EMPTY
55371: ST_TO_ADDR
// for i in tmp do
55372: LD_ADDR_VAR 0 3
55376: PUSH
55377: LD_VAR 0 6
55381: PUSH
55382: FOR_IN
55383: IFFALSE 55454
// begin t := UnitsInside ( i ) ;
55385: LD_ADDR_VAR 0 4
55389: PUSH
55390: LD_VAR 0 3
55394: PPUSH
55395: CALL_OW 313
55399: ST_TO_ADDR
// if t then
55400: LD_VAR 0 4
55404: IFFALSE 55452
// for j in t do
55406: LD_ADDR_VAR 0 7
55410: PUSH
55411: LD_VAR 0 4
55415: PUSH
55416: FOR_IN
55417: IFFALSE 55450
// result := Insert ( result , result + 1 , j ) ;
55419: LD_ADDR_VAR 0 2
55423: PUSH
55424: LD_VAR 0 2
55428: PPUSH
55429: LD_VAR 0 2
55433: PUSH
55434: LD_INT 1
55436: PLUS
55437: PPUSH
55438: LD_VAR 0 7
55442: PPUSH
55443: CALL_OW 2
55447: ST_TO_ADDR
55448: GO 55416
55450: POP
55451: POP
// end ;
55452: GO 55382
55454: POP
55455: POP
// if not result then
55456: LD_VAR 0 2
55460: NOT
55461: IFFALSE 55465
// exit ;
55463: GO 55613
// mech := result [ 1 ] ;
55465: LD_ADDR_VAR 0 5
55469: PUSH
55470: LD_VAR 0 2
55474: PUSH
55475: LD_INT 1
55477: ARRAY
55478: ST_TO_ADDR
// if result > 1 then
55479: LD_VAR 0 2
55483: PUSH
55484: LD_INT 1
55486: GREATER
55487: IFFALSE 55599
// for i = 2 to result do
55489: LD_ADDR_VAR 0 3
55493: PUSH
55494: DOUBLE
55495: LD_INT 2
55497: DEC
55498: ST_TO_ADDR
55499: LD_VAR 0 2
55503: PUSH
55504: FOR_TO
55505: IFFALSE 55597
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
55507: LD_ADDR_VAR 0 4
55511: PUSH
55512: LD_VAR 0 2
55516: PUSH
55517: LD_VAR 0 3
55521: ARRAY
55522: PPUSH
55523: LD_INT 3
55525: PPUSH
55526: CALL_OW 259
55530: PUSH
55531: LD_VAR 0 2
55535: PUSH
55536: LD_VAR 0 3
55540: ARRAY
55541: PPUSH
55542: CALL_OW 432
55546: MINUS
55547: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
55548: LD_VAR 0 4
55552: PUSH
55553: LD_VAR 0 5
55557: PPUSH
55558: LD_INT 3
55560: PPUSH
55561: CALL_OW 259
55565: PUSH
55566: LD_VAR 0 5
55570: PPUSH
55571: CALL_OW 432
55575: MINUS
55576: GREATEREQUAL
55577: IFFALSE 55595
// mech := result [ i ] ;
55579: LD_ADDR_VAR 0 5
55583: PUSH
55584: LD_VAR 0 2
55588: PUSH
55589: LD_VAR 0 3
55593: ARRAY
55594: ST_TO_ADDR
// end ;
55595: GO 55504
55597: POP
55598: POP
// ComLinkTo ( vehicle , mech ) ;
55599: LD_VAR 0 1
55603: PPUSH
55604: LD_VAR 0 5
55608: PPUSH
55609: CALL_OW 135
// end ;
55613: LD_VAR 0 2
55617: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
55618: LD_INT 0
55620: PPUSH
55621: PPUSH
55622: PPUSH
55623: PPUSH
55624: PPUSH
55625: PPUSH
55626: PPUSH
55627: PPUSH
55628: PPUSH
55629: PPUSH
55630: PPUSH
55631: PPUSH
55632: PPUSH
// result := [ ] ;
55633: LD_ADDR_VAR 0 7
55637: PUSH
55638: EMPTY
55639: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
55640: LD_VAR 0 1
55644: PPUSH
55645: CALL_OW 266
55649: PUSH
55650: LD_INT 0
55652: PUSH
55653: LD_INT 1
55655: PUSH
55656: EMPTY
55657: LIST
55658: LIST
55659: IN
55660: NOT
55661: IFFALSE 55665
// exit ;
55663: GO 57296
// if name then
55665: LD_VAR 0 3
55669: IFFALSE 55685
// SetBName ( base_dep , name ) ;
55671: LD_VAR 0 1
55675: PPUSH
55676: LD_VAR 0 3
55680: PPUSH
55681: CALL_OW 500
// base := GetBase ( base_dep ) ;
55685: LD_ADDR_VAR 0 15
55689: PUSH
55690: LD_VAR 0 1
55694: PPUSH
55695: CALL_OW 274
55699: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
55700: LD_ADDR_VAR 0 16
55704: PUSH
55705: LD_VAR 0 1
55709: PPUSH
55710: CALL_OW 255
55714: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
55715: LD_ADDR_VAR 0 17
55719: PUSH
55720: LD_VAR 0 1
55724: PPUSH
55725: CALL_OW 248
55729: ST_TO_ADDR
// if sources then
55730: LD_VAR 0 5
55734: IFFALSE 55781
// for i = 1 to 3 do
55736: LD_ADDR_VAR 0 8
55740: PUSH
55741: DOUBLE
55742: LD_INT 1
55744: DEC
55745: ST_TO_ADDR
55746: LD_INT 3
55748: PUSH
55749: FOR_TO
55750: IFFALSE 55779
// AddResourceType ( base , i , sources [ i ] ) ;
55752: LD_VAR 0 15
55756: PPUSH
55757: LD_VAR 0 8
55761: PPUSH
55762: LD_VAR 0 5
55766: PUSH
55767: LD_VAR 0 8
55771: ARRAY
55772: PPUSH
55773: CALL_OW 276
55777: GO 55749
55779: POP
55780: POP
// buildings := GetBaseBuildings ( base , area ) ;
55781: LD_ADDR_VAR 0 18
55785: PUSH
55786: LD_VAR 0 15
55790: PPUSH
55791: LD_VAR 0 2
55795: PPUSH
55796: CALL 55073 0 2
55800: ST_TO_ADDR
// InitHc ;
55801: CALL_OW 19
// InitUc ;
55805: CALL_OW 18
// uc_side := side ;
55809: LD_ADDR_OWVAR 20
55813: PUSH
55814: LD_VAR 0 16
55818: ST_TO_ADDR
// uc_nation := nation ;
55819: LD_ADDR_OWVAR 21
55823: PUSH
55824: LD_VAR 0 17
55828: ST_TO_ADDR
// if buildings then
55829: LD_VAR 0 18
55833: IFFALSE 57155
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
55835: LD_ADDR_VAR 0 19
55839: PUSH
55840: LD_VAR 0 18
55844: PPUSH
55845: LD_INT 2
55847: PUSH
55848: LD_INT 30
55850: PUSH
55851: LD_INT 29
55853: PUSH
55854: EMPTY
55855: LIST
55856: LIST
55857: PUSH
55858: LD_INT 30
55860: PUSH
55861: LD_INT 30
55863: PUSH
55864: EMPTY
55865: LIST
55866: LIST
55867: PUSH
55868: EMPTY
55869: LIST
55870: LIST
55871: LIST
55872: PPUSH
55873: CALL_OW 72
55877: ST_TO_ADDR
// if tmp then
55878: LD_VAR 0 19
55882: IFFALSE 55930
// for i in tmp do
55884: LD_ADDR_VAR 0 8
55888: PUSH
55889: LD_VAR 0 19
55893: PUSH
55894: FOR_IN
55895: IFFALSE 55928
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
55897: LD_VAR 0 8
55901: PPUSH
55902: CALL_OW 250
55906: PPUSH
55907: LD_VAR 0 8
55911: PPUSH
55912: CALL_OW 251
55916: PPUSH
55917: LD_VAR 0 16
55921: PPUSH
55922: CALL_OW 441
55926: GO 55894
55928: POP
55929: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
55930: LD_VAR 0 18
55934: PPUSH
55935: LD_INT 2
55937: PUSH
55938: LD_INT 30
55940: PUSH
55941: LD_INT 32
55943: PUSH
55944: EMPTY
55945: LIST
55946: LIST
55947: PUSH
55948: LD_INT 30
55950: PUSH
55951: LD_INT 33
55953: PUSH
55954: EMPTY
55955: LIST
55956: LIST
55957: PUSH
55958: EMPTY
55959: LIST
55960: LIST
55961: LIST
55962: PPUSH
55963: CALL_OW 72
55967: IFFALSE 56055
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
55969: LD_ADDR_VAR 0 8
55973: PUSH
55974: LD_VAR 0 18
55978: PPUSH
55979: LD_INT 2
55981: PUSH
55982: LD_INT 30
55984: PUSH
55985: LD_INT 32
55987: PUSH
55988: EMPTY
55989: LIST
55990: LIST
55991: PUSH
55992: LD_INT 30
55994: PUSH
55995: LD_INT 33
55997: PUSH
55998: EMPTY
55999: LIST
56000: LIST
56001: PUSH
56002: EMPTY
56003: LIST
56004: LIST
56005: LIST
56006: PPUSH
56007: CALL_OW 72
56011: PUSH
56012: FOR_IN
56013: IFFALSE 56053
// begin if not GetBWeapon ( i ) then
56015: LD_VAR 0 8
56019: PPUSH
56020: CALL_OW 269
56024: NOT
56025: IFFALSE 56051
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
56027: LD_VAR 0 8
56031: PPUSH
56032: LD_VAR 0 8
56036: PPUSH
56037: LD_VAR 0 2
56041: PPUSH
56042: CALL 57301 0 2
56046: PPUSH
56047: CALL_OW 431
// end ;
56051: GO 56012
56053: POP
56054: POP
// end ; for i = 1 to personel do
56055: LD_ADDR_VAR 0 8
56059: PUSH
56060: DOUBLE
56061: LD_INT 1
56063: DEC
56064: ST_TO_ADDR
56065: LD_VAR 0 6
56069: PUSH
56070: FOR_TO
56071: IFFALSE 57135
// begin if i > 4 then
56073: LD_VAR 0 8
56077: PUSH
56078: LD_INT 4
56080: GREATER
56081: IFFALSE 56085
// break ;
56083: GO 57135
// case i of 1 :
56085: LD_VAR 0 8
56089: PUSH
56090: LD_INT 1
56092: DOUBLE
56093: EQUAL
56094: IFTRUE 56098
56096: GO 56178
56098: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
56099: LD_ADDR_VAR 0 12
56103: PUSH
56104: LD_VAR 0 18
56108: PPUSH
56109: LD_INT 22
56111: PUSH
56112: LD_VAR 0 16
56116: PUSH
56117: EMPTY
56118: LIST
56119: LIST
56120: PUSH
56121: LD_INT 58
56123: PUSH
56124: EMPTY
56125: LIST
56126: PUSH
56127: LD_INT 2
56129: PUSH
56130: LD_INT 30
56132: PUSH
56133: LD_INT 32
56135: PUSH
56136: EMPTY
56137: LIST
56138: LIST
56139: PUSH
56140: LD_INT 30
56142: PUSH
56143: LD_INT 4
56145: PUSH
56146: EMPTY
56147: LIST
56148: LIST
56149: PUSH
56150: LD_INT 30
56152: PUSH
56153: LD_INT 5
56155: PUSH
56156: EMPTY
56157: LIST
56158: LIST
56159: PUSH
56160: EMPTY
56161: LIST
56162: LIST
56163: LIST
56164: LIST
56165: PUSH
56166: EMPTY
56167: LIST
56168: LIST
56169: LIST
56170: PPUSH
56171: CALL_OW 72
56175: ST_TO_ADDR
56176: GO 56400
56178: LD_INT 2
56180: DOUBLE
56181: EQUAL
56182: IFTRUE 56186
56184: GO 56248
56186: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
56187: LD_ADDR_VAR 0 12
56191: PUSH
56192: LD_VAR 0 18
56196: PPUSH
56197: LD_INT 22
56199: PUSH
56200: LD_VAR 0 16
56204: PUSH
56205: EMPTY
56206: LIST
56207: LIST
56208: PUSH
56209: LD_INT 2
56211: PUSH
56212: LD_INT 30
56214: PUSH
56215: LD_INT 0
56217: PUSH
56218: EMPTY
56219: LIST
56220: LIST
56221: PUSH
56222: LD_INT 30
56224: PUSH
56225: LD_INT 1
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: PUSH
56232: EMPTY
56233: LIST
56234: LIST
56235: LIST
56236: PUSH
56237: EMPTY
56238: LIST
56239: LIST
56240: PPUSH
56241: CALL_OW 72
56245: ST_TO_ADDR
56246: GO 56400
56248: LD_INT 3
56250: DOUBLE
56251: EQUAL
56252: IFTRUE 56256
56254: GO 56318
56256: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
56257: LD_ADDR_VAR 0 12
56261: PUSH
56262: LD_VAR 0 18
56266: PPUSH
56267: LD_INT 22
56269: PUSH
56270: LD_VAR 0 16
56274: PUSH
56275: EMPTY
56276: LIST
56277: LIST
56278: PUSH
56279: LD_INT 2
56281: PUSH
56282: LD_INT 30
56284: PUSH
56285: LD_INT 2
56287: PUSH
56288: EMPTY
56289: LIST
56290: LIST
56291: PUSH
56292: LD_INT 30
56294: PUSH
56295: LD_INT 3
56297: PUSH
56298: EMPTY
56299: LIST
56300: LIST
56301: PUSH
56302: EMPTY
56303: LIST
56304: LIST
56305: LIST
56306: PUSH
56307: EMPTY
56308: LIST
56309: LIST
56310: PPUSH
56311: CALL_OW 72
56315: ST_TO_ADDR
56316: GO 56400
56318: LD_INT 4
56320: DOUBLE
56321: EQUAL
56322: IFTRUE 56326
56324: GO 56399
56326: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
56327: LD_ADDR_VAR 0 12
56331: PUSH
56332: LD_VAR 0 18
56336: PPUSH
56337: LD_INT 22
56339: PUSH
56340: LD_VAR 0 16
56344: PUSH
56345: EMPTY
56346: LIST
56347: LIST
56348: PUSH
56349: LD_INT 2
56351: PUSH
56352: LD_INT 30
56354: PUSH
56355: LD_INT 6
56357: PUSH
56358: EMPTY
56359: LIST
56360: LIST
56361: PUSH
56362: LD_INT 30
56364: PUSH
56365: LD_INT 7
56367: PUSH
56368: EMPTY
56369: LIST
56370: LIST
56371: PUSH
56372: LD_INT 30
56374: PUSH
56375: LD_INT 8
56377: PUSH
56378: EMPTY
56379: LIST
56380: LIST
56381: PUSH
56382: EMPTY
56383: LIST
56384: LIST
56385: LIST
56386: LIST
56387: PUSH
56388: EMPTY
56389: LIST
56390: LIST
56391: PPUSH
56392: CALL_OW 72
56396: ST_TO_ADDR
56397: GO 56400
56399: POP
// if i = 1 then
56400: LD_VAR 0 8
56404: PUSH
56405: LD_INT 1
56407: EQUAL
56408: IFFALSE 56519
// begin tmp := [ ] ;
56410: LD_ADDR_VAR 0 19
56414: PUSH
56415: EMPTY
56416: ST_TO_ADDR
// for j in f do
56417: LD_ADDR_VAR 0 9
56421: PUSH
56422: LD_VAR 0 12
56426: PUSH
56427: FOR_IN
56428: IFFALSE 56501
// if GetBType ( j ) = b_bunker then
56430: LD_VAR 0 9
56434: PPUSH
56435: CALL_OW 266
56439: PUSH
56440: LD_INT 32
56442: EQUAL
56443: IFFALSE 56470
// tmp := Insert ( tmp , 1 , j ) else
56445: LD_ADDR_VAR 0 19
56449: PUSH
56450: LD_VAR 0 19
56454: PPUSH
56455: LD_INT 1
56457: PPUSH
56458: LD_VAR 0 9
56462: PPUSH
56463: CALL_OW 2
56467: ST_TO_ADDR
56468: GO 56499
// tmp := Insert ( tmp , tmp + 1 , j ) ;
56470: LD_ADDR_VAR 0 19
56474: PUSH
56475: LD_VAR 0 19
56479: PPUSH
56480: LD_VAR 0 19
56484: PUSH
56485: LD_INT 1
56487: PLUS
56488: PPUSH
56489: LD_VAR 0 9
56493: PPUSH
56494: CALL_OW 2
56498: ST_TO_ADDR
56499: GO 56427
56501: POP
56502: POP
// if tmp then
56503: LD_VAR 0 19
56507: IFFALSE 56519
// f := tmp ;
56509: LD_ADDR_VAR 0 12
56513: PUSH
56514: LD_VAR 0 19
56518: ST_TO_ADDR
// end ; x := personel [ i ] ;
56519: LD_ADDR_VAR 0 13
56523: PUSH
56524: LD_VAR 0 6
56528: PUSH
56529: LD_VAR 0 8
56533: ARRAY
56534: ST_TO_ADDR
// if x = - 1 then
56535: LD_VAR 0 13
56539: PUSH
56540: LD_INT 1
56542: NEG
56543: EQUAL
56544: IFFALSE 56753
// begin for j in f do
56546: LD_ADDR_VAR 0 9
56550: PUSH
56551: LD_VAR 0 12
56555: PUSH
56556: FOR_IN
56557: IFFALSE 56749
// repeat InitHc ;
56559: CALL_OW 19
// if GetBType ( j ) = b_barracks then
56563: LD_VAR 0 9
56567: PPUSH
56568: CALL_OW 266
56572: PUSH
56573: LD_INT 5
56575: EQUAL
56576: IFFALSE 56646
// begin if UnitsInside ( j ) < 3 then
56578: LD_VAR 0 9
56582: PPUSH
56583: CALL_OW 313
56587: PUSH
56588: LD_INT 3
56590: LESS
56591: IFFALSE 56627
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
56593: LD_INT 0
56595: PPUSH
56596: LD_INT 5
56598: PUSH
56599: LD_INT 8
56601: PUSH
56602: LD_INT 9
56604: PUSH
56605: EMPTY
56606: LIST
56607: LIST
56608: LIST
56609: PUSH
56610: LD_VAR 0 17
56614: ARRAY
56615: PPUSH
56616: LD_VAR 0 4
56620: PPUSH
56621: CALL_OW 380
56625: GO 56644
// PrepareHuman ( false , i , skill ) ;
56627: LD_INT 0
56629: PPUSH
56630: LD_VAR 0 8
56634: PPUSH
56635: LD_VAR 0 4
56639: PPUSH
56640: CALL_OW 380
// end else
56644: GO 56663
// PrepareHuman ( false , i , skill ) ;
56646: LD_INT 0
56648: PPUSH
56649: LD_VAR 0 8
56653: PPUSH
56654: LD_VAR 0 4
56658: PPUSH
56659: CALL_OW 380
// un := CreateHuman ;
56663: LD_ADDR_VAR 0 14
56667: PUSH
56668: CALL_OW 44
56672: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
56673: LD_ADDR_VAR 0 7
56677: PUSH
56678: LD_VAR 0 7
56682: PPUSH
56683: LD_INT 1
56685: PPUSH
56686: LD_VAR 0 14
56690: PPUSH
56691: CALL_OW 2
56695: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
56696: LD_VAR 0 14
56700: PPUSH
56701: LD_VAR 0 9
56705: PPUSH
56706: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
56710: LD_VAR 0 9
56714: PPUSH
56715: CALL_OW 313
56719: PUSH
56720: LD_INT 6
56722: EQUAL
56723: PUSH
56724: LD_VAR 0 9
56728: PPUSH
56729: CALL_OW 266
56733: PUSH
56734: LD_INT 32
56736: PUSH
56737: LD_INT 31
56739: PUSH
56740: EMPTY
56741: LIST
56742: LIST
56743: IN
56744: OR
56745: IFFALSE 56559
56747: GO 56556
56749: POP
56750: POP
// end else
56751: GO 57133
// for j = 1 to x do
56753: LD_ADDR_VAR 0 9
56757: PUSH
56758: DOUBLE
56759: LD_INT 1
56761: DEC
56762: ST_TO_ADDR
56763: LD_VAR 0 13
56767: PUSH
56768: FOR_TO
56769: IFFALSE 57131
// begin InitHc ;
56771: CALL_OW 19
// if not f then
56775: LD_VAR 0 12
56779: NOT
56780: IFFALSE 56869
// begin PrepareHuman ( false , i , skill ) ;
56782: LD_INT 0
56784: PPUSH
56785: LD_VAR 0 8
56789: PPUSH
56790: LD_VAR 0 4
56794: PPUSH
56795: CALL_OW 380
// un := CreateHuman ;
56799: LD_ADDR_VAR 0 14
56803: PUSH
56804: CALL_OW 44
56808: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
56809: LD_ADDR_VAR 0 7
56813: PUSH
56814: LD_VAR 0 7
56818: PPUSH
56819: LD_INT 1
56821: PPUSH
56822: LD_VAR 0 14
56826: PPUSH
56827: CALL_OW 2
56831: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
56832: LD_VAR 0 14
56836: PPUSH
56837: LD_VAR 0 1
56841: PPUSH
56842: CALL_OW 250
56846: PPUSH
56847: LD_VAR 0 1
56851: PPUSH
56852: CALL_OW 251
56856: PPUSH
56857: LD_INT 10
56859: PPUSH
56860: LD_INT 0
56862: PPUSH
56863: CALL_OW 50
// continue ;
56867: GO 56768
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
56869: LD_VAR 0 12
56873: PUSH
56874: LD_INT 1
56876: ARRAY
56877: PPUSH
56878: CALL_OW 313
56882: PUSH
56883: LD_VAR 0 12
56887: PUSH
56888: LD_INT 1
56890: ARRAY
56891: PPUSH
56892: CALL_OW 266
56896: PUSH
56897: LD_INT 32
56899: PUSH
56900: LD_INT 31
56902: PUSH
56903: EMPTY
56904: LIST
56905: LIST
56906: IN
56907: AND
56908: PUSH
56909: LD_VAR 0 12
56913: PUSH
56914: LD_INT 1
56916: ARRAY
56917: PPUSH
56918: CALL_OW 313
56922: PUSH
56923: LD_INT 6
56925: EQUAL
56926: OR
56927: IFFALSE 56947
// f := Delete ( f , 1 ) ;
56929: LD_ADDR_VAR 0 12
56933: PUSH
56934: LD_VAR 0 12
56938: PPUSH
56939: LD_INT 1
56941: PPUSH
56942: CALL_OW 3
56946: ST_TO_ADDR
// if not f then
56947: LD_VAR 0 12
56951: NOT
56952: IFFALSE 56970
// begin x := x + 2 ;
56954: LD_ADDR_VAR 0 13
56958: PUSH
56959: LD_VAR 0 13
56963: PUSH
56964: LD_INT 2
56966: PLUS
56967: ST_TO_ADDR
// continue ;
56968: GO 56768
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
56970: LD_VAR 0 12
56974: PUSH
56975: LD_INT 1
56977: ARRAY
56978: PPUSH
56979: CALL_OW 266
56983: PUSH
56984: LD_INT 5
56986: EQUAL
56987: IFFALSE 57061
// begin if UnitsInside ( f [ 1 ] ) < 3 then
56989: LD_VAR 0 12
56993: PUSH
56994: LD_INT 1
56996: ARRAY
56997: PPUSH
56998: CALL_OW 313
57002: PUSH
57003: LD_INT 3
57005: LESS
57006: IFFALSE 57042
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57008: LD_INT 0
57010: PPUSH
57011: LD_INT 5
57013: PUSH
57014: LD_INT 8
57016: PUSH
57017: LD_INT 9
57019: PUSH
57020: EMPTY
57021: LIST
57022: LIST
57023: LIST
57024: PUSH
57025: LD_VAR 0 17
57029: ARRAY
57030: PPUSH
57031: LD_VAR 0 4
57035: PPUSH
57036: CALL_OW 380
57040: GO 57059
// PrepareHuman ( false , i , skill ) ;
57042: LD_INT 0
57044: PPUSH
57045: LD_VAR 0 8
57049: PPUSH
57050: LD_VAR 0 4
57054: PPUSH
57055: CALL_OW 380
// end else
57059: GO 57078
// PrepareHuman ( false , i , skill ) ;
57061: LD_INT 0
57063: PPUSH
57064: LD_VAR 0 8
57068: PPUSH
57069: LD_VAR 0 4
57073: PPUSH
57074: CALL_OW 380
// un := CreateHuman ;
57078: LD_ADDR_VAR 0 14
57082: PUSH
57083: CALL_OW 44
57087: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57088: LD_ADDR_VAR 0 7
57092: PUSH
57093: LD_VAR 0 7
57097: PPUSH
57098: LD_INT 1
57100: PPUSH
57101: LD_VAR 0 14
57105: PPUSH
57106: CALL_OW 2
57110: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
57111: LD_VAR 0 14
57115: PPUSH
57116: LD_VAR 0 12
57120: PUSH
57121: LD_INT 1
57123: ARRAY
57124: PPUSH
57125: CALL_OW 52
// end ;
57129: GO 56768
57131: POP
57132: POP
// end ;
57133: GO 56070
57135: POP
57136: POP
// result := result ^ buildings ;
57137: LD_ADDR_VAR 0 7
57141: PUSH
57142: LD_VAR 0 7
57146: PUSH
57147: LD_VAR 0 18
57151: ADD
57152: ST_TO_ADDR
// end else
57153: GO 57296
// begin for i = 1 to personel do
57155: LD_ADDR_VAR 0 8
57159: PUSH
57160: DOUBLE
57161: LD_INT 1
57163: DEC
57164: ST_TO_ADDR
57165: LD_VAR 0 6
57169: PUSH
57170: FOR_TO
57171: IFFALSE 57294
// begin if i > 4 then
57173: LD_VAR 0 8
57177: PUSH
57178: LD_INT 4
57180: GREATER
57181: IFFALSE 57185
// break ;
57183: GO 57294
// x := personel [ i ] ;
57185: LD_ADDR_VAR 0 13
57189: PUSH
57190: LD_VAR 0 6
57194: PUSH
57195: LD_VAR 0 8
57199: ARRAY
57200: ST_TO_ADDR
// if x = - 1 then
57201: LD_VAR 0 13
57205: PUSH
57206: LD_INT 1
57208: NEG
57209: EQUAL
57210: IFFALSE 57214
// continue ;
57212: GO 57170
// PrepareHuman ( false , i , skill ) ;
57214: LD_INT 0
57216: PPUSH
57217: LD_VAR 0 8
57221: PPUSH
57222: LD_VAR 0 4
57226: PPUSH
57227: CALL_OW 380
// un := CreateHuman ;
57231: LD_ADDR_VAR 0 14
57235: PUSH
57236: CALL_OW 44
57240: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57241: LD_VAR 0 14
57245: PPUSH
57246: LD_VAR 0 1
57250: PPUSH
57251: CALL_OW 250
57255: PPUSH
57256: LD_VAR 0 1
57260: PPUSH
57261: CALL_OW 251
57265: PPUSH
57266: LD_INT 10
57268: PPUSH
57269: LD_INT 0
57271: PPUSH
57272: CALL_OW 50
// result := result ^ un ;
57276: LD_ADDR_VAR 0 7
57280: PUSH
57281: LD_VAR 0 7
57285: PUSH
57286: LD_VAR 0 14
57290: ADD
57291: ST_TO_ADDR
// end ;
57292: GO 57170
57294: POP
57295: POP
// end ; end ;
57296: LD_VAR 0 7
57300: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
57301: LD_INT 0
57303: PPUSH
57304: PPUSH
57305: PPUSH
57306: PPUSH
57307: PPUSH
57308: PPUSH
57309: PPUSH
57310: PPUSH
57311: PPUSH
57312: PPUSH
57313: PPUSH
57314: PPUSH
57315: PPUSH
57316: PPUSH
57317: PPUSH
57318: PPUSH
// result := false ;
57319: LD_ADDR_VAR 0 3
57323: PUSH
57324: LD_INT 0
57326: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
57327: LD_VAR 0 1
57331: NOT
57332: PUSH
57333: LD_VAR 0 1
57337: PPUSH
57338: CALL_OW 266
57342: PUSH
57343: LD_INT 32
57345: PUSH
57346: LD_INT 33
57348: PUSH
57349: EMPTY
57350: LIST
57351: LIST
57352: IN
57353: NOT
57354: OR
57355: IFFALSE 57359
// exit ;
57357: GO 58495
// nat := GetNation ( tower ) ;
57359: LD_ADDR_VAR 0 12
57363: PUSH
57364: LD_VAR 0 1
57368: PPUSH
57369: CALL_OW 248
57373: ST_TO_ADDR
// side := GetSide ( tower ) ;
57374: LD_ADDR_VAR 0 16
57378: PUSH
57379: LD_VAR 0 1
57383: PPUSH
57384: CALL_OW 255
57388: ST_TO_ADDR
// x := GetX ( tower ) ;
57389: LD_ADDR_VAR 0 10
57393: PUSH
57394: LD_VAR 0 1
57398: PPUSH
57399: CALL_OW 250
57403: ST_TO_ADDR
// y := GetY ( tower ) ;
57404: LD_ADDR_VAR 0 11
57408: PUSH
57409: LD_VAR 0 1
57413: PPUSH
57414: CALL_OW 251
57418: ST_TO_ADDR
// if not x or not y then
57419: LD_VAR 0 10
57423: NOT
57424: PUSH
57425: LD_VAR 0 11
57429: NOT
57430: OR
57431: IFFALSE 57435
// exit ;
57433: GO 58495
// weapon := 0 ;
57435: LD_ADDR_VAR 0 18
57439: PUSH
57440: LD_INT 0
57442: ST_TO_ADDR
// fac_list := [ ] ;
57443: LD_ADDR_VAR 0 17
57447: PUSH
57448: EMPTY
57449: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
57450: LD_ADDR_VAR 0 6
57454: PUSH
57455: LD_VAR 0 1
57459: PPUSH
57460: CALL_OW 274
57464: PPUSH
57465: LD_VAR 0 2
57469: PPUSH
57470: CALL 55073 0 2
57474: PPUSH
57475: LD_INT 30
57477: PUSH
57478: LD_INT 3
57480: PUSH
57481: EMPTY
57482: LIST
57483: LIST
57484: PPUSH
57485: CALL_OW 72
57489: ST_TO_ADDR
// if not factories then
57490: LD_VAR 0 6
57494: NOT
57495: IFFALSE 57499
// exit ;
57497: GO 58495
// for i in factories do
57499: LD_ADDR_VAR 0 8
57503: PUSH
57504: LD_VAR 0 6
57508: PUSH
57509: FOR_IN
57510: IFFALSE 57535
// fac_list := fac_list union AvailableWeaponList ( i ) ;
57512: LD_ADDR_VAR 0 17
57516: PUSH
57517: LD_VAR 0 17
57521: PUSH
57522: LD_VAR 0 8
57526: PPUSH
57527: CALL_OW 478
57531: UNION
57532: ST_TO_ADDR
57533: GO 57509
57535: POP
57536: POP
// if not fac_list then
57537: LD_VAR 0 17
57541: NOT
57542: IFFALSE 57546
// exit ;
57544: GO 58495
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
57546: LD_ADDR_VAR 0 5
57550: PUSH
57551: LD_INT 4
57553: PUSH
57554: LD_INT 5
57556: PUSH
57557: LD_INT 9
57559: PUSH
57560: LD_INT 10
57562: PUSH
57563: LD_INT 6
57565: PUSH
57566: LD_INT 7
57568: PUSH
57569: LD_INT 11
57571: PUSH
57572: EMPTY
57573: LIST
57574: LIST
57575: LIST
57576: LIST
57577: LIST
57578: LIST
57579: LIST
57580: PUSH
57581: LD_INT 27
57583: PUSH
57584: LD_INT 28
57586: PUSH
57587: LD_INT 26
57589: PUSH
57590: LD_INT 30
57592: PUSH
57593: EMPTY
57594: LIST
57595: LIST
57596: LIST
57597: LIST
57598: PUSH
57599: LD_INT 43
57601: PUSH
57602: LD_INT 44
57604: PUSH
57605: LD_INT 46
57607: PUSH
57608: LD_INT 45
57610: PUSH
57611: LD_INT 47
57613: PUSH
57614: LD_INT 49
57616: PUSH
57617: EMPTY
57618: LIST
57619: LIST
57620: LIST
57621: LIST
57622: LIST
57623: LIST
57624: PUSH
57625: EMPTY
57626: LIST
57627: LIST
57628: LIST
57629: PUSH
57630: LD_VAR 0 12
57634: ARRAY
57635: ST_TO_ADDR
// for i in list do
57636: LD_ADDR_VAR 0 8
57640: PUSH
57641: LD_VAR 0 5
57645: PUSH
57646: FOR_IN
57647: IFFALSE 57680
// if not i in fac_list then
57649: LD_VAR 0 8
57653: PUSH
57654: LD_VAR 0 17
57658: IN
57659: NOT
57660: IFFALSE 57678
// list := list diff i ;
57662: LD_ADDR_VAR 0 5
57666: PUSH
57667: LD_VAR 0 5
57671: PUSH
57672: LD_VAR 0 8
57676: DIFF
57677: ST_TO_ADDR
57678: GO 57646
57680: POP
57681: POP
// if not list then
57682: LD_VAR 0 5
57686: NOT
57687: IFFALSE 57691
// exit ;
57689: GO 58495
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
57691: LD_VAR 0 12
57695: PUSH
57696: LD_INT 3
57698: EQUAL
57699: PUSH
57700: LD_INT 49
57702: PUSH
57703: LD_VAR 0 5
57707: IN
57708: AND
57709: PUSH
57710: LD_INT 31
57712: PPUSH
57713: LD_VAR 0 16
57717: PPUSH
57718: CALL_OW 321
57722: PUSH
57723: LD_INT 2
57725: EQUAL
57726: AND
57727: IFFALSE 57787
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
57729: LD_INT 22
57731: PUSH
57732: LD_VAR 0 16
57736: PUSH
57737: EMPTY
57738: LIST
57739: LIST
57740: PUSH
57741: LD_INT 35
57743: PUSH
57744: LD_INT 49
57746: PUSH
57747: EMPTY
57748: LIST
57749: LIST
57750: PUSH
57751: LD_INT 91
57753: PUSH
57754: LD_VAR 0 1
57758: PUSH
57759: LD_INT 10
57761: PUSH
57762: EMPTY
57763: LIST
57764: LIST
57765: LIST
57766: PUSH
57767: EMPTY
57768: LIST
57769: LIST
57770: LIST
57771: PPUSH
57772: CALL_OW 69
57776: NOT
57777: IFFALSE 57787
// weapon := ru_time_lapser ;
57779: LD_ADDR_VAR 0 18
57783: PUSH
57784: LD_INT 49
57786: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
57787: LD_VAR 0 12
57791: PUSH
57792: LD_INT 1
57794: PUSH
57795: LD_INT 2
57797: PUSH
57798: EMPTY
57799: LIST
57800: LIST
57801: IN
57802: PUSH
57803: LD_INT 11
57805: PUSH
57806: LD_VAR 0 5
57810: IN
57811: PUSH
57812: LD_INT 30
57814: PUSH
57815: LD_VAR 0 5
57819: IN
57820: OR
57821: AND
57822: PUSH
57823: LD_INT 6
57825: PPUSH
57826: LD_VAR 0 16
57830: PPUSH
57831: CALL_OW 321
57835: PUSH
57836: LD_INT 2
57838: EQUAL
57839: AND
57840: IFFALSE 58005
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
57842: LD_INT 22
57844: PUSH
57845: LD_VAR 0 16
57849: PUSH
57850: EMPTY
57851: LIST
57852: LIST
57853: PUSH
57854: LD_INT 2
57856: PUSH
57857: LD_INT 35
57859: PUSH
57860: LD_INT 11
57862: PUSH
57863: EMPTY
57864: LIST
57865: LIST
57866: PUSH
57867: LD_INT 35
57869: PUSH
57870: LD_INT 30
57872: PUSH
57873: EMPTY
57874: LIST
57875: LIST
57876: PUSH
57877: EMPTY
57878: LIST
57879: LIST
57880: LIST
57881: PUSH
57882: LD_INT 91
57884: PUSH
57885: LD_VAR 0 1
57889: PUSH
57890: LD_INT 18
57892: PUSH
57893: EMPTY
57894: LIST
57895: LIST
57896: LIST
57897: PUSH
57898: EMPTY
57899: LIST
57900: LIST
57901: LIST
57902: PPUSH
57903: CALL_OW 69
57907: NOT
57908: PUSH
57909: LD_INT 22
57911: PUSH
57912: LD_VAR 0 16
57916: PUSH
57917: EMPTY
57918: LIST
57919: LIST
57920: PUSH
57921: LD_INT 2
57923: PUSH
57924: LD_INT 30
57926: PUSH
57927: LD_INT 32
57929: PUSH
57930: EMPTY
57931: LIST
57932: LIST
57933: PUSH
57934: LD_INT 30
57936: PUSH
57937: LD_INT 33
57939: PUSH
57940: EMPTY
57941: LIST
57942: LIST
57943: PUSH
57944: EMPTY
57945: LIST
57946: LIST
57947: LIST
57948: PUSH
57949: LD_INT 91
57951: PUSH
57952: LD_VAR 0 1
57956: PUSH
57957: LD_INT 12
57959: PUSH
57960: EMPTY
57961: LIST
57962: LIST
57963: LIST
57964: PUSH
57965: EMPTY
57966: LIST
57967: LIST
57968: LIST
57969: PUSH
57970: EMPTY
57971: LIST
57972: PPUSH
57973: CALL_OW 69
57977: PUSH
57978: LD_INT 2
57980: GREATER
57981: AND
57982: IFFALSE 58005
// weapon := [ us_radar , ar_radar ] [ nat ] ;
57984: LD_ADDR_VAR 0 18
57988: PUSH
57989: LD_INT 11
57991: PUSH
57992: LD_INT 30
57994: PUSH
57995: EMPTY
57996: LIST
57997: LIST
57998: PUSH
57999: LD_VAR 0 12
58003: ARRAY
58004: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
58005: LD_VAR 0 18
58009: NOT
58010: PUSH
58011: LD_INT 40
58013: PPUSH
58014: LD_VAR 0 16
58018: PPUSH
58019: CALL_OW 321
58023: PUSH
58024: LD_INT 2
58026: EQUAL
58027: AND
58028: PUSH
58029: LD_INT 7
58031: PUSH
58032: LD_VAR 0 5
58036: IN
58037: PUSH
58038: LD_INT 28
58040: PUSH
58041: LD_VAR 0 5
58045: IN
58046: OR
58047: PUSH
58048: LD_INT 45
58050: PUSH
58051: LD_VAR 0 5
58055: IN
58056: OR
58057: AND
58058: IFFALSE 58312
// begin hex := GetHexInfo ( x , y ) ;
58060: LD_ADDR_VAR 0 4
58064: PUSH
58065: LD_VAR 0 10
58069: PPUSH
58070: LD_VAR 0 11
58074: PPUSH
58075: CALL_OW 546
58079: ST_TO_ADDR
// if hex [ 1 ] then
58080: LD_VAR 0 4
58084: PUSH
58085: LD_INT 1
58087: ARRAY
58088: IFFALSE 58092
// exit ;
58090: GO 58495
// height := hex [ 2 ] ;
58092: LD_ADDR_VAR 0 15
58096: PUSH
58097: LD_VAR 0 4
58101: PUSH
58102: LD_INT 2
58104: ARRAY
58105: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
58106: LD_ADDR_VAR 0 14
58110: PUSH
58111: LD_INT 0
58113: PUSH
58114: LD_INT 2
58116: PUSH
58117: LD_INT 3
58119: PUSH
58120: LD_INT 5
58122: PUSH
58123: EMPTY
58124: LIST
58125: LIST
58126: LIST
58127: LIST
58128: ST_TO_ADDR
// for i in tmp do
58129: LD_ADDR_VAR 0 8
58133: PUSH
58134: LD_VAR 0 14
58138: PUSH
58139: FOR_IN
58140: IFFALSE 58310
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
58142: LD_ADDR_VAR 0 9
58146: PUSH
58147: LD_VAR 0 10
58151: PPUSH
58152: LD_VAR 0 8
58156: PPUSH
58157: LD_INT 5
58159: PPUSH
58160: CALL_OW 272
58164: PUSH
58165: LD_VAR 0 11
58169: PPUSH
58170: LD_VAR 0 8
58174: PPUSH
58175: LD_INT 5
58177: PPUSH
58178: CALL_OW 273
58182: PUSH
58183: EMPTY
58184: LIST
58185: LIST
58186: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
58187: LD_VAR 0 9
58191: PUSH
58192: LD_INT 1
58194: ARRAY
58195: PPUSH
58196: LD_VAR 0 9
58200: PUSH
58201: LD_INT 2
58203: ARRAY
58204: PPUSH
58205: CALL_OW 488
58209: IFFALSE 58308
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
58211: LD_ADDR_VAR 0 4
58215: PUSH
58216: LD_VAR 0 9
58220: PUSH
58221: LD_INT 1
58223: ARRAY
58224: PPUSH
58225: LD_VAR 0 9
58229: PUSH
58230: LD_INT 2
58232: ARRAY
58233: PPUSH
58234: CALL_OW 546
58238: ST_TO_ADDR
// if hex [ 1 ] then
58239: LD_VAR 0 4
58243: PUSH
58244: LD_INT 1
58246: ARRAY
58247: IFFALSE 58251
// continue ;
58249: GO 58139
// h := hex [ 2 ] ;
58251: LD_ADDR_VAR 0 13
58255: PUSH
58256: LD_VAR 0 4
58260: PUSH
58261: LD_INT 2
58263: ARRAY
58264: ST_TO_ADDR
// if h + 7 < height then
58265: LD_VAR 0 13
58269: PUSH
58270: LD_INT 7
58272: PLUS
58273: PUSH
58274: LD_VAR 0 15
58278: LESS
58279: IFFALSE 58308
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
58281: LD_ADDR_VAR 0 18
58285: PUSH
58286: LD_INT 7
58288: PUSH
58289: LD_INT 28
58291: PUSH
58292: LD_INT 45
58294: PUSH
58295: EMPTY
58296: LIST
58297: LIST
58298: LIST
58299: PUSH
58300: LD_VAR 0 12
58304: ARRAY
58305: ST_TO_ADDR
// break ;
58306: GO 58310
// end ; end ; end ;
58308: GO 58139
58310: POP
58311: POP
// end ; if not weapon then
58312: LD_VAR 0 18
58316: NOT
58317: IFFALSE 58377
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
58319: LD_ADDR_VAR 0 5
58323: PUSH
58324: LD_VAR 0 5
58328: PUSH
58329: LD_INT 11
58331: PUSH
58332: LD_INT 30
58334: PUSH
58335: LD_INT 49
58337: PUSH
58338: EMPTY
58339: LIST
58340: LIST
58341: LIST
58342: DIFF
58343: ST_TO_ADDR
// if not list then
58344: LD_VAR 0 5
58348: NOT
58349: IFFALSE 58353
// exit ;
58351: GO 58495
// weapon := list [ rand ( 1 , list ) ] ;
58353: LD_ADDR_VAR 0 18
58357: PUSH
58358: LD_VAR 0 5
58362: PUSH
58363: LD_INT 1
58365: PPUSH
58366: LD_VAR 0 5
58370: PPUSH
58371: CALL_OW 12
58375: ARRAY
58376: ST_TO_ADDR
// end ; if weapon then
58377: LD_VAR 0 18
58381: IFFALSE 58495
// begin tmp := CostOfWeapon ( weapon ) ;
58383: LD_ADDR_VAR 0 14
58387: PUSH
58388: LD_VAR 0 18
58392: PPUSH
58393: CALL_OW 451
58397: ST_TO_ADDR
// j := GetBase ( tower ) ;
58398: LD_ADDR_VAR 0 9
58402: PUSH
58403: LD_VAR 0 1
58407: PPUSH
58408: CALL_OW 274
58412: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
58413: LD_VAR 0 9
58417: PPUSH
58418: LD_INT 1
58420: PPUSH
58421: CALL_OW 275
58425: PUSH
58426: LD_VAR 0 14
58430: PUSH
58431: LD_INT 1
58433: ARRAY
58434: GREATEREQUAL
58435: PUSH
58436: LD_VAR 0 9
58440: PPUSH
58441: LD_INT 2
58443: PPUSH
58444: CALL_OW 275
58448: PUSH
58449: LD_VAR 0 14
58453: PUSH
58454: LD_INT 2
58456: ARRAY
58457: GREATEREQUAL
58458: AND
58459: PUSH
58460: LD_VAR 0 9
58464: PPUSH
58465: LD_INT 3
58467: PPUSH
58468: CALL_OW 275
58472: PUSH
58473: LD_VAR 0 14
58477: PUSH
58478: LD_INT 3
58480: ARRAY
58481: GREATEREQUAL
58482: AND
58483: IFFALSE 58495
// result := weapon ;
58485: LD_ADDR_VAR 0 3
58489: PUSH
58490: LD_VAR 0 18
58494: ST_TO_ADDR
// end ; end ;
58495: LD_VAR 0 3
58499: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
58500: LD_INT 0
58502: PPUSH
58503: PPUSH
// result := true ;
58504: LD_ADDR_VAR 0 3
58508: PUSH
58509: LD_INT 1
58511: ST_TO_ADDR
// if array1 = array2 then
58512: LD_VAR 0 1
58516: PUSH
58517: LD_VAR 0 2
58521: EQUAL
58522: IFFALSE 58582
// begin for i = 1 to array1 do
58524: LD_ADDR_VAR 0 4
58528: PUSH
58529: DOUBLE
58530: LD_INT 1
58532: DEC
58533: ST_TO_ADDR
58534: LD_VAR 0 1
58538: PUSH
58539: FOR_TO
58540: IFFALSE 58578
// if array1 [ i ] <> array2 [ i ] then
58542: LD_VAR 0 1
58546: PUSH
58547: LD_VAR 0 4
58551: ARRAY
58552: PUSH
58553: LD_VAR 0 2
58557: PUSH
58558: LD_VAR 0 4
58562: ARRAY
58563: NONEQUAL
58564: IFFALSE 58576
// begin result := false ;
58566: LD_ADDR_VAR 0 3
58570: PUSH
58571: LD_INT 0
58573: ST_TO_ADDR
// break ;
58574: GO 58578
// end ;
58576: GO 58539
58578: POP
58579: POP
// end else
58580: GO 58590
// result := false ;
58582: LD_ADDR_VAR 0 3
58586: PUSH
58587: LD_INT 0
58589: ST_TO_ADDR
// end ;
58590: LD_VAR 0 3
58594: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
58595: LD_INT 0
58597: PPUSH
58598: PPUSH
58599: PPUSH
// pom := GetBase ( fac ) ;
58600: LD_ADDR_VAR 0 5
58604: PUSH
58605: LD_VAR 0 1
58609: PPUSH
58610: CALL_OW 274
58614: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
58615: LD_ADDR_VAR 0 4
58619: PUSH
58620: LD_VAR 0 2
58624: PUSH
58625: LD_INT 1
58627: ARRAY
58628: PPUSH
58629: LD_VAR 0 2
58633: PUSH
58634: LD_INT 2
58636: ARRAY
58637: PPUSH
58638: LD_VAR 0 2
58642: PUSH
58643: LD_INT 3
58645: ARRAY
58646: PPUSH
58647: LD_VAR 0 2
58651: PUSH
58652: LD_INT 4
58654: ARRAY
58655: PPUSH
58656: CALL_OW 449
58660: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
58661: LD_ADDR_VAR 0 3
58665: PUSH
58666: LD_VAR 0 5
58670: PPUSH
58671: LD_INT 1
58673: PPUSH
58674: CALL_OW 275
58678: PUSH
58679: LD_VAR 0 4
58683: PUSH
58684: LD_INT 1
58686: ARRAY
58687: GREATEREQUAL
58688: PUSH
58689: LD_VAR 0 5
58693: PPUSH
58694: LD_INT 2
58696: PPUSH
58697: CALL_OW 275
58701: PUSH
58702: LD_VAR 0 4
58706: PUSH
58707: LD_INT 2
58709: ARRAY
58710: GREATEREQUAL
58711: AND
58712: PUSH
58713: LD_VAR 0 5
58717: PPUSH
58718: LD_INT 3
58720: PPUSH
58721: CALL_OW 275
58725: PUSH
58726: LD_VAR 0 4
58730: PUSH
58731: LD_INT 3
58733: ARRAY
58734: GREATEREQUAL
58735: AND
58736: ST_TO_ADDR
// end ;
58737: LD_VAR 0 3
58741: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
58742: LD_INT 0
58744: PPUSH
58745: PPUSH
58746: PPUSH
58747: PPUSH
// pom := GetBase ( building ) ;
58748: LD_ADDR_VAR 0 3
58752: PUSH
58753: LD_VAR 0 1
58757: PPUSH
58758: CALL_OW 274
58762: ST_TO_ADDR
// if not pom then
58763: LD_VAR 0 3
58767: NOT
58768: IFFALSE 58772
// exit ;
58770: GO 58942
// btype := GetBType ( building ) ;
58772: LD_ADDR_VAR 0 5
58776: PUSH
58777: LD_VAR 0 1
58781: PPUSH
58782: CALL_OW 266
58786: ST_TO_ADDR
// if btype = b_armoury then
58787: LD_VAR 0 5
58791: PUSH
58792: LD_INT 4
58794: EQUAL
58795: IFFALSE 58805
// btype := b_barracks ;
58797: LD_ADDR_VAR 0 5
58801: PUSH
58802: LD_INT 5
58804: ST_TO_ADDR
// if btype = b_depot then
58805: LD_VAR 0 5
58809: PUSH
58810: LD_INT 0
58812: EQUAL
58813: IFFALSE 58823
// btype := b_warehouse ;
58815: LD_ADDR_VAR 0 5
58819: PUSH
58820: LD_INT 1
58822: ST_TO_ADDR
// if btype = b_workshop then
58823: LD_VAR 0 5
58827: PUSH
58828: LD_INT 2
58830: EQUAL
58831: IFFALSE 58841
// btype := b_factory ;
58833: LD_ADDR_VAR 0 5
58837: PUSH
58838: LD_INT 3
58840: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
58841: LD_ADDR_VAR 0 4
58845: PUSH
58846: LD_VAR 0 5
58850: PPUSH
58851: LD_VAR 0 1
58855: PPUSH
58856: CALL_OW 248
58860: PPUSH
58861: CALL_OW 450
58865: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
58866: LD_ADDR_VAR 0 2
58870: PUSH
58871: LD_VAR 0 3
58875: PPUSH
58876: LD_INT 1
58878: PPUSH
58879: CALL_OW 275
58883: PUSH
58884: LD_VAR 0 4
58888: PUSH
58889: LD_INT 1
58891: ARRAY
58892: GREATEREQUAL
58893: PUSH
58894: LD_VAR 0 3
58898: PPUSH
58899: LD_INT 2
58901: PPUSH
58902: CALL_OW 275
58906: PUSH
58907: LD_VAR 0 4
58911: PUSH
58912: LD_INT 2
58914: ARRAY
58915: GREATEREQUAL
58916: AND
58917: PUSH
58918: LD_VAR 0 3
58922: PPUSH
58923: LD_INT 3
58925: PPUSH
58926: CALL_OW 275
58930: PUSH
58931: LD_VAR 0 4
58935: PUSH
58936: LD_INT 3
58938: ARRAY
58939: GREATEREQUAL
58940: AND
58941: ST_TO_ADDR
// end ;
58942: LD_VAR 0 2
58946: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
58947: LD_INT 0
58949: PPUSH
58950: PPUSH
58951: PPUSH
// pom := GetBase ( building ) ;
58952: LD_ADDR_VAR 0 4
58956: PUSH
58957: LD_VAR 0 1
58961: PPUSH
58962: CALL_OW 274
58966: ST_TO_ADDR
// if not pom then
58967: LD_VAR 0 4
58971: NOT
58972: IFFALSE 58976
// exit ;
58974: GO 59077
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
58976: LD_ADDR_VAR 0 5
58980: PUSH
58981: LD_VAR 0 2
58985: PPUSH
58986: LD_VAR 0 1
58990: PPUSH
58991: CALL_OW 248
58995: PPUSH
58996: CALL_OW 450
59000: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59001: LD_ADDR_VAR 0 3
59005: PUSH
59006: LD_VAR 0 4
59010: PPUSH
59011: LD_INT 1
59013: PPUSH
59014: CALL_OW 275
59018: PUSH
59019: LD_VAR 0 5
59023: PUSH
59024: LD_INT 1
59026: ARRAY
59027: GREATEREQUAL
59028: PUSH
59029: LD_VAR 0 4
59033: PPUSH
59034: LD_INT 2
59036: PPUSH
59037: CALL_OW 275
59041: PUSH
59042: LD_VAR 0 5
59046: PUSH
59047: LD_INT 2
59049: ARRAY
59050: GREATEREQUAL
59051: AND
59052: PUSH
59053: LD_VAR 0 4
59057: PPUSH
59058: LD_INT 3
59060: PPUSH
59061: CALL_OW 275
59065: PUSH
59066: LD_VAR 0 5
59070: PUSH
59071: LD_INT 3
59073: ARRAY
59074: GREATEREQUAL
59075: AND
59076: ST_TO_ADDR
// end ;
59077: LD_VAR 0 3
59081: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
59082: LD_INT 0
59084: PPUSH
59085: PPUSH
59086: PPUSH
59087: PPUSH
59088: PPUSH
59089: PPUSH
59090: PPUSH
59091: PPUSH
59092: PPUSH
59093: PPUSH
// result := false ;
59094: LD_ADDR_VAR 0 6
59098: PUSH
59099: LD_INT 0
59101: ST_TO_ADDR
// if not base or not btype or not x or not y then
59102: LD_VAR 0 1
59106: NOT
59107: PUSH
59108: LD_VAR 0 2
59112: NOT
59113: OR
59114: PUSH
59115: LD_VAR 0 3
59119: NOT
59120: OR
59121: PUSH
59122: LD_VAR 0 4
59126: NOT
59127: OR
59128: IFFALSE 59132
// exit ;
59130: GO 59741
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
59132: LD_ADDR_VAR 0 12
59136: PUSH
59137: LD_VAR 0 2
59141: PPUSH
59142: LD_VAR 0 3
59146: PPUSH
59147: LD_VAR 0 4
59151: PPUSH
59152: LD_VAR 0 5
59156: PPUSH
59157: LD_VAR 0 1
59161: PUSH
59162: LD_INT 1
59164: ARRAY
59165: PPUSH
59166: CALL_OW 248
59170: PPUSH
59171: LD_INT 0
59173: PPUSH
59174: CALL 60578 0 6
59178: ST_TO_ADDR
// if not hexes then
59179: LD_VAR 0 12
59183: NOT
59184: IFFALSE 59188
// exit ;
59186: GO 59741
// for i = 1 to hexes do
59188: LD_ADDR_VAR 0 7
59192: PUSH
59193: DOUBLE
59194: LD_INT 1
59196: DEC
59197: ST_TO_ADDR
59198: LD_VAR 0 12
59202: PUSH
59203: FOR_TO
59204: IFFALSE 59739
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
59206: LD_ADDR_VAR 0 11
59210: PUSH
59211: LD_VAR 0 12
59215: PUSH
59216: LD_VAR 0 7
59220: ARRAY
59221: PUSH
59222: LD_INT 1
59224: ARRAY
59225: PPUSH
59226: LD_VAR 0 12
59230: PUSH
59231: LD_VAR 0 7
59235: ARRAY
59236: PUSH
59237: LD_INT 2
59239: ARRAY
59240: PPUSH
59241: CALL_OW 428
59245: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
59246: LD_VAR 0 12
59250: PUSH
59251: LD_VAR 0 7
59255: ARRAY
59256: PUSH
59257: LD_INT 1
59259: ARRAY
59260: PPUSH
59261: LD_VAR 0 12
59265: PUSH
59266: LD_VAR 0 7
59270: ARRAY
59271: PUSH
59272: LD_INT 2
59274: ARRAY
59275: PPUSH
59276: CALL_OW 351
59280: PUSH
59281: LD_VAR 0 12
59285: PUSH
59286: LD_VAR 0 7
59290: ARRAY
59291: PUSH
59292: LD_INT 1
59294: ARRAY
59295: PPUSH
59296: LD_VAR 0 12
59300: PUSH
59301: LD_VAR 0 7
59305: ARRAY
59306: PUSH
59307: LD_INT 2
59309: ARRAY
59310: PPUSH
59311: CALL_OW 488
59315: NOT
59316: OR
59317: PUSH
59318: LD_VAR 0 11
59322: PPUSH
59323: CALL_OW 247
59327: PUSH
59328: LD_INT 3
59330: EQUAL
59331: OR
59332: IFFALSE 59338
// exit ;
59334: POP
59335: POP
59336: GO 59741
// if not tmp or not tmp in base then
59338: LD_VAR 0 11
59342: NOT
59343: PUSH
59344: LD_VAR 0 11
59348: PUSH
59349: LD_VAR 0 1
59353: IN
59354: NOT
59355: OR
59356: IFFALSE 59360
// continue ;
59358: GO 59203
// result := true ;
59360: LD_ADDR_VAR 0 6
59364: PUSH
59365: LD_INT 1
59367: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
59368: LD_ADDR_VAR 0 15
59372: PUSH
59373: LD_VAR 0 1
59377: PPUSH
59378: LD_INT 22
59380: PUSH
59381: LD_VAR 0 11
59385: PPUSH
59386: CALL_OW 255
59390: PUSH
59391: EMPTY
59392: LIST
59393: LIST
59394: PUSH
59395: LD_INT 2
59397: PUSH
59398: LD_INT 30
59400: PUSH
59401: LD_INT 0
59403: PUSH
59404: EMPTY
59405: LIST
59406: LIST
59407: PUSH
59408: LD_INT 30
59410: PUSH
59411: LD_INT 1
59413: PUSH
59414: EMPTY
59415: LIST
59416: LIST
59417: PUSH
59418: EMPTY
59419: LIST
59420: LIST
59421: LIST
59422: PUSH
59423: EMPTY
59424: LIST
59425: LIST
59426: PPUSH
59427: CALL_OW 72
59431: ST_TO_ADDR
// if dep then
59432: LD_VAR 0 15
59436: IFFALSE 59572
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
59438: LD_ADDR_VAR 0 14
59442: PUSH
59443: LD_VAR 0 15
59447: PUSH
59448: LD_INT 1
59450: ARRAY
59451: PPUSH
59452: CALL_OW 250
59456: PPUSH
59457: LD_VAR 0 15
59461: PUSH
59462: LD_INT 1
59464: ARRAY
59465: PPUSH
59466: CALL_OW 254
59470: PPUSH
59471: LD_INT 5
59473: PPUSH
59474: CALL_OW 272
59478: PUSH
59479: LD_VAR 0 15
59483: PUSH
59484: LD_INT 1
59486: ARRAY
59487: PPUSH
59488: CALL_OW 251
59492: PPUSH
59493: LD_VAR 0 15
59497: PUSH
59498: LD_INT 1
59500: ARRAY
59501: PPUSH
59502: CALL_OW 254
59506: PPUSH
59507: LD_INT 5
59509: PPUSH
59510: CALL_OW 273
59514: PUSH
59515: EMPTY
59516: LIST
59517: LIST
59518: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
59519: LD_VAR 0 14
59523: PUSH
59524: LD_INT 1
59526: ARRAY
59527: PPUSH
59528: LD_VAR 0 14
59532: PUSH
59533: LD_INT 2
59535: ARRAY
59536: PPUSH
59537: CALL_OW 488
59541: IFFALSE 59572
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
59543: LD_VAR 0 11
59547: PPUSH
59548: LD_VAR 0 14
59552: PUSH
59553: LD_INT 1
59555: ARRAY
59556: PPUSH
59557: LD_VAR 0 14
59561: PUSH
59562: LD_INT 2
59564: ARRAY
59565: PPUSH
59566: CALL_OW 111
// continue ;
59570: GO 59203
// end ; end ; r := GetDir ( tmp ) ;
59572: LD_ADDR_VAR 0 13
59576: PUSH
59577: LD_VAR 0 11
59581: PPUSH
59582: CALL_OW 254
59586: ST_TO_ADDR
// if r = 5 then
59587: LD_VAR 0 13
59591: PUSH
59592: LD_INT 5
59594: EQUAL
59595: IFFALSE 59605
// r := 0 ;
59597: LD_ADDR_VAR 0 13
59601: PUSH
59602: LD_INT 0
59604: ST_TO_ADDR
// for j = r to 5 do
59605: LD_ADDR_VAR 0 8
59609: PUSH
59610: DOUBLE
59611: LD_VAR 0 13
59615: DEC
59616: ST_TO_ADDR
59617: LD_INT 5
59619: PUSH
59620: FOR_TO
59621: IFFALSE 59735
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
59623: LD_ADDR_VAR 0 9
59627: PUSH
59628: LD_VAR 0 11
59632: PPUSH
59633: CALL_OW 250
59637: PPUSH
59638: LD_VAR 0 8
59642: PPUSH
59643: LD_INT 2
59645: PPUSH
59646: CALL_OW 272
59650: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
59651: LD_ADDR_VAR 0 10
59655: PUSH
59656: LD_VAR 0 11
59660: PPUSH
59661: CALL_OW 251
59665: PPUSH
59666: LD_VAR 0 8
59670: PPUSH
59671: LD_INT 2
59673: PPUSH
59674: CALL_OW 273
59678: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
59679: LD_VAR 0 9
59683: PPUSH
59684: LD_VAR 0 10
59688: PPUSH
59689: CALL_OW 488
59693: PUSH
59694: LD_VAR 0 9
59698: PPUSH
59699: LD_VAR 0 10
59703: PPUSH
59704: CALL_OW 428
59708: NOT
59709: AND
59710: IFFALSE 59733
// begin ComMoveXY ( tmp , _x , _y ) ;
59712: LD_VAR 0 11
59716: PPUSH
59717: LD_VAR 0 9
59721: PPUSH
59722: LD_VAR 0 10
59726: PPUSH
59727: CALL_OW 111
// break ;
59731: GO 59735
// end ; end ;
59733: GO 59620
59735: POP
59736: POP
// end ;
59737: GO 59203
59739: POP
59740: POP
// end ;
59741: LD_VAR 0 6
59745: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
59746: LD_INT 0
59748: PPUSH
59749: PPUSH
59750: PPUSH
59751: PPUSH
59752: PPUSH
59753: PPUSH
59754: PPUSH
59755: PPUSH
59756: PPUSH
59757: PPUSH
// result := false ;
59758: LD_ADDR_VAR 0 6
59762: PUSH
59763: LD_INT 0
59765: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
59766: LD_VAR 0 1
59770: NOT
59771: PUSH
59772: LD_VAR 0 1
59776: PPUSH
59777: CALL_OW 266
59781: PUSH
59782: LD_INT 0
59784: PUSH
59785: LD_INT 1
59787: PUSH
59788: EMPTY
59789: LIST
59790: LIST
59791: IN
59792: NOT
59793: OR
59794: PUSH
59795: LD_VAR 0 2
59799: NOT
59800: OR
59801: PUSH
59802: LD_VAR 0 5
59806: PUSH
59807: LD_INT 0
59809: PUSH
59810: LD_INT 1
59812: PUSH
59813: LD_INT 2
59815: PUSH
59816: LD_INT 3
59818: PUSH
59819: LD_INT 4
59821: PUSH
59822: LD_INT 5
59824: PUSH
59825: EMPTY
59826: LIST
59827: LIST
59828: LIST
59829: LIST
59830: LIST
59831: LIST
59832: IN
59833: NOT
59834: OR
59835: PUSH
59836: LD_VAR 0 3
59840: PPUSH
59841: LD_VAR 0 4
59845: PPUSH
59846: CALL_OW 488
59850: NOT
59851: OR
59852: IFFALSE 59856
// exit ;
59854: GO 60573
// pom := GetBase ( depot ) ;
59856: LD_ADDR_VAR 0 10
59860: PUSH
59861: LD_VAR 0 1
59865: PPUSH
59866: CALL_OW 274
59870: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
59871: LD_ADDR_VAR 0 11
59875: PUSH
59876: LD_VAR 0 2
59880: PPUSH
59881: LD_VAR 0 1
59885: PPUSH
59886: CALL_OW 248
59890: PPUSH
59891: CALL_OW 450
59895: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
59896: LD_VAR 0 10
59900: PPUSH
59901: LD_INT 1
59903: PPUSH
59904: CALL_OW 275
59908: PUSH
59909: LD_VAR 0 11
59913: PUSH
59914: LD_INT 1
59916: ARRAY
59917: GREATEREQUAL
59918: PUSH
59919: LD_VAR 0 10
59923: PPUSH
59924: LD_INT 2
59926: PPUSH
59927: CALL_OW 275
59931: PUSH
59932: LD_VAR 0 11
59936: PUSH
59937: LD_INT 2
59939: ARRAY
59940: GREATEREQUAL
59941: AND
59942: PUSH
59943: LD_VAR 0 10
59947: PPUSH
59948: LD_INT 3
59950: PPUSH
59951: CALL_OW 275
59955: PUSH
59956: LD_VAR 0 11
59960: PUSH
59961: LD_INT 3
59963: ARRAY
59964: GREATEREQUAL
59965: AND
59966: NOT
59967: IFFALSE 59971
// exit ;
59969: GO 60573
// if GetBType ( depot ) = b_depot then
59971: LD_VAR 0 1
59975: PPUSH
59976: CALL_OW 266
59980: PUSH
59981: LD_INT 0
59983: EQUAL
59984: IFFALSE 59996
// dist := 28 else
59986: LD_ADDR_VAR 0 14
59990: PUSH
59991: LD_INT 28
59993: ST_TO_ADDR
59994: GO 60004
// dist := 36 ;
59996: LD_ADDR_VAR 0 14
60000: PUSH
60001: LD_INT 36
60003: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
60004: LD_VAR 0 1
60008: PPUSH
60009: LD_VAR 0 3
60013: PPUSH
60014: LD_VAR 0 4
60018: PPUSH
60019: CALL_OW 297
60023: PUSH
60024: LD_VAR 0 14
60028: GREATER
60029: IFFALSE 60033
// exit ;
60031: GO 60573
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
60033: LD_ADDR_VAR 0 12
60037: PUSH
60038: LD_VAR 0 2
60042: PPUSH
60043: LD_VAR 0 3
60047: PPUSH
60048: LD_VAR 0 4
60052: PPUSH
60053: LD_VAR 0 5
60057: PPUSH
60058: LD_VAR 0 1
60062: PPUSH
60063: CALL_OW 248
60067: PPUSH
60068: LD_INT 0
60070: PPUSH
60071: CALL 60578 0 6
60075: ST_TO_ADDR
// if not hexes then
60076: LD_VAR 0 12
60080: NOT
60081: IFFALSE 60085
// exit ;
60083: GO 60573
// hex := GetHexInfo ( x , y ) ;
60085: LD_ADDR_VAR 0 15
60089: PUSH
60090: LD_VAR 0 3
60094: PPUSH
60095: LD_VAR 0 4
60099: PPUSH
60100: CALL_OW 546
60104: ST_TO_ADDR
// if hex [ 1 ] then
60105: LD_VAR 0 15
60109: PUSH
60110: LD_INT 1
60112: ARRAY
60113: IFFALSE 60117
// exit ;
60115: GO 60573
// height := hex [ 2 ] ;
60117: LD_ADDR_VAR 0 13
60121: PUSH
60122: LD_VAR 0 15
60126: PUSH
60127: LD_INT 2
60129: ARRAY
60130: ST_TO_ADDR
// for i = 1 to hexes do
60131: LD_ADDR_VAR 0 7
60135: PUSH
60136: DOUBLE
60137: LD_INT 1
60139: DEC
60140: ST_TO_ADDR
60141: LD_VAR 0 12
60145: PUSH
60146: FOR_TO
60147: IFFALSE 60477
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
60149: LD_VAR 0 12
60153: PUSH
60154: LD_VAR 0 7
60158: ARRAY
60159: PUSH
60160: LD_INT 1
60162: ARRAY
60163: PPUSH
60164: LD_VAR 0 12
60168: PUSH
60169: LD_VAR 0 7
60173: ARRAY
60174: PUSH
60175: LD_INT 2
60177: ARRAY
60178: PPUSH
60179: CALL_OW 488
60183: NOT
60184: PUSH
60185: LD_VAR 0 12
60189: PUSH
60190: LD_VAR 0 7
60194: ARRAY
60195: PUSH
60196: LD_INT 1
60198: ARRAY
60199: PPUSH
60200: LD_VAR 0 12
60204: PUSH
60205: LD_VAR 0 7
60209: ARRAY
60210: PUSH
60211: LD_INT 2
60213: ARRAY
60214: PPUSH
60215: CALL_OW 428
60219: PUSH
60220: LD_INT 0
60222: GREATER
60223: OR
60224: PUSH
60225: LD_VAR 0 12
60229: PUSH
60230: LD_VAR 0 7
60234: ARRAY
60235: PUSH
60236: LD_INT 1
60238: ARRAY
60239: PPUSH
60240: LD_VAR 0 12
60244: PUSH
60245: LD_VAR 0 7
60249: ARRAY
60250: PUSH
60251: LD_INT 2
60253: ARRAY
60254: PPUSH
60255: CALL_OW 351
60259: OR
60260: IFFALSE 60266
// exit ;
60262: POP
60263: POP
60264: GO 60573
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60266: LD_ADDR_VAR 0 8
60270: PUSH
60271: LD_VAR 0 12
60275: PUSH
60276: LD_VAR 0 7
60280: ARRAY
60281: PUSH
60282: LD_INT 1
60284: ARRAY
60285: PPUSH
60286: LD_VAR 0 12
60290: PUSH
60291: LD_VAR 0 7
60295: ARRAY
60296: PUSH
60297: LD_INT 2
60299: ARRAY
60300: PPUSH
60301: CALL_OW 546
60305: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
60306: LD_VAR 0 8
60310: PUSH
60311: LD_INT 1
60313: ARRAY
60314: PUSH
60315: LD_VAR 0 8
60319: PUSH
60320: LD_INT 2
60322: ARRAY
60323: PUSH
60324: LD_VAR 0 13
60328: PUSH
60329: LD_INT 2
60331: PLUS
60332: GREATER
60333: OR
60334: PUSH
60335: LD_VAR 0 8
60339: PUSH
60340: LD_INT 2
60342: ARRAY
60343: PUSH
60344: LD_VAR 0 13
60348: PUSH
60349: LD_INT 2
60351: MINUS
60352: LESS
60353: OR
60354: PUSH
60355: LD_VAR 0 8
60359: PUSH
60360: LD_INT 3
60362: ARRAY
60363: PUSH
60364: LD_INT 0
60366: PUSH
60367: LD_INT 8
60369: PUSH
60370: LD_INT 9
60372: PUSH
60373: LD_INT 10
60375: PUSH
60376: LD_INT 11
60378: PUSH
60379: LD_INT 12
60381: PUSH
60382: LD_INT 13
60384: PUSH
60385: LD_INT 16
60387: PUSH
60388: LD_INT 17
60390: PUSH
60391: LD_INT 18
60393: PUSH
60394: LD_INT 19
60396: PUSH
60397: LD_INT 20
60399: PUSH
60400: LD_INT 21
60402: PUSH
60403: EMPTY
60404: LIST
60405: LIST
60406: LIST
60407: LIST
60408: LIST
60409: LIST
60410: LIST
60411: LIST
60412: LIST
60413: LIST
60414: LIST
60415: LIST
60416: LIST
60417: IN
60418: NOT
60419: OR
60420: PUSH
60421: LD_VAR 0 8
60425: PUSH
60426: LD_INT 5
60428: ARRAY
60429: NOT
60430: OR
60431: PUSH
60432: LD_VAR 0 8
60436: PUSH
60437: LD_INT 6
60439: ARRAY
60440: PUSH
60441: LD_INT 1
60443: PUSH
60444: LD_INT 2
60446: PUSH
60447: LD_INT 7
60449: PUSH
60450: LD_INT 9
60452: PUSH
60453: LD_INT 10
60455: PUSH
60456: LD_INT 11
60458: PUSH
60459: EMPTY
60460: LIST
60461: LIST
60462: LIST
60463: LIST
60464: LIST
60465: LIST
60466: IN
60467: NOT
60468: OR
60469: IFFALSE 60475
// exit ;
60471: POP
60472: POP
60473: GO 60573
// end ;
60475: GO 60146
60477: POP
60478: POP
// side := GetSide ( depot ) ;
60479: LD_ADDR_VAR 0 9
60483: PUSH
60484: LD_VAR 0 1
60488: PPUSH
60489: CALL_OW 255
60493: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
60494: LD_VAR 0 9
60498: PPUSH
60499: LD_VAR 0 3
60503: PPUSH
60504: LD_VAR 0 4
60508: PPUSH
60509: LD_INT 20
60511: PPUSH
60512: CALL 53227 0 4
60516: PUSH
60517: LD_INT 4
60519: ARRAY
60520: IFFALSE 60524
// exit ;
60522: GO 60573
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
60524: LD_VAR 0 2
60528: PUSH
60529: LD_INT 29
60531: PUSH
60532: LD_INT 30
60534: PUSH
60535: EMPTY
60536: LIST
60537: LIST
60538: IN
60539: PUSH
60540: LD_VAR 0 3
60544: PPUSH
60545: LD_VAR 0 4
60549: PPUSH
60550: LD_VAR 0 9
60554: PPUSH
60555: CALL_OW 440
60559: NOT
60560: AND
60561: IFFALSE 60565
// exit ;
60563: GO 60573
// result := true ;
60565: LD_ADDR_VAR 0 6
60569: PUSH
60570: LD_INT 1
60572: ST_TO_ADDR
// end ;
60573: LD_VAR 0 6
60577: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
60578: LD_INT 0
60580: PPUSH
60581: PPUSH
60582: PPUSH
60583: PPUSH
60584: PPUSH
60585: PPUSH
60586: PPUSH
60587: PPUSH
60588: PPUSH
60589: PPUSH
60590: PPUSH
60591: PPUSH
60592: PPUSH
60593: PPUSH
60594: PPUSH
60595: PPUSH
60596: PPUSH
60597: PPUSH
60598: PPUSH
60599: PPUSH
60600: PPUSH
60601: PPUSH
60602: PPUSH
60603: PPUSH
60604: PPUSH
60605: PPUSH
60606: PPUSH
60607: PPUSH
60608: PPUSH
60609: PPUSH
60610: PPUSH
60611: PPUSH
60612: PPUSH
60613: PPUSH
60614: PPUSH
60615: PPUSH
60616: PPUSH
60617: PPUSH
60618: PPUSH
60619: PPUSH
60620: PPUSH
60621: PPUSH
60622: PPUSH
60623: PPUSH
60624: PPUSH
60625: PPUSH
60626: PPUSH
60627: PPUSH
60628: PPUSH
60629: PPUSH
60630: PPUSH
60631: PPUSH
60632: PPUSH
60633: PPUSH
60634: PPUSH
60635: PPUSH
60636: PPUSH
60637: PPUSH
// result = [ ] ;
60638: LD_ADDR_VAR 0 7
60642: PUSH
60643: EMPTY
60644: ST_TO_ADDR
// temp_list = [ ] ;
60645: LD_ADDR_VAR 0 9
60649: PUSH
60650: EMPTY
60651: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
60652: LD_VAR 0 4
60656: PUSH
60657: LD_INT 0
60659: PUSH
60660: LD_INT 1
60662: PUSH
60663: LD_INT 2
60665: PUSH
60666: LD_INT 3
60668: PUSH
60669: LD_INT 4
60671: PUSH
60672: LD_INT 5
60674: PUSH
60675: EMPTY
60676: LIST
60677: LIST
60678: LIST
60679: LIST
60680: LIST
60681: LIST
60682: IN
60683: NOT
60684: PUSH
60685: LD_VAR 0 1
60689: PUSH
60690: LD_INT 0
60692: PUSH
60693: LD_INT 1
60695: PUSH
60696: EMPTY
60697: LIST
60698: LIST
60699: IN
60700: PUSH
60701: LD_VAR 0 5
60705: PUSH
60706: LD_INT 1
60708: PUSH
60709: LD_INT 2
60711: PUSH
60712: LD_INT 3
60714: PUSH
60715: EMPTY
60716: LIST
60717: LIST
60718: LIST
60719: IN
60720: NOT
60721: AND
60722: OR
60723: IFFALSE 60727
// exit ;
60725: GO 79118
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
60727: LD_VAR 0 1
60731: PUSH
60732: LD_INT 6
60734: PUSH
60735: LD_INT 7
60737: PUSH
60738: LD_INT 8
60740: PUSH
60741: LD_INT 13
60743: PUSH
60744: LD_INT 12
60746: PUSH
60747: LD_INT 15
60749: PUSH
60750: LD_INT 11
60752: PUSH
60753: LD_INT 14
60755: PUSH
60756: LD_INT 10
60758: PUSH
60759: EMPTY
60760: LIST
60761: LIST
60762: LIST
60763: LIST
60764: LIST
60765: LIST
60766: LIST
60767: LIST
60768: LIST
60769: IN
60770: IFFALSE 60780
// btype = b_lab ;
60772: LD_ADDR_VAR 0 1
60776: PUSH
60777: LD_INT 6
60779: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
60780: LD_VAR 0 6
60784: PUSH
60785: LD_INT 0
60787: PUSH
60788: LD_INT 1
60790: PUSH
60791: LD_INT 2
60793: PUSH
60794: EMPTY
60795: LIST
60796: LIST
60797: LIST
60798: IN
60799: NOT
60800: PUSH
60801: LD_VAR 0 1
60805: PUSH
60806: LD_INT 0
60808: PUSH
60809: LD_INT 1
60811: PUSH
60812: LD_INT 2
60814: PUSH
60815: LD_INT 3
60817: PUSH
60818: LD_INT 6
60820: PUSH
60821: LD_INT 36
60823: PUSH
60824: LD_INT 4
60826: PUSH
60827: LD_INT 5
60829: PUSH
60830: LD_INT 31
60832: PUSH
60833: LD_INT 32
60835: PUSH
60836: LD_INT 33
60838: PUSH
60839: EMPTY
60840: LIST
60841: LIST
60842: LIST
60843: LIST
60844: LIST
60845: LIST
60846: LIST
60847: LIST
60848: LIST
60849: LIST
60850: LIST
60851: IN
60852: NOT
60853: PUSH
60854: LD_VAR 0 6
60858: PUSH
60859: LD_INT 1
60861: EQUAL
60862: AND
60863: OR
60864: PUSH
60865: LD_VAR 0 1
60869: PUSH
60870: LD_INT 2
60872: PUSH
60873: LD_INT 3
60875: PUSH
60876: EMPTY
60877: LIST
60878: LIST
60879: IN
60880: NOT
60881: PUSH
60882: LD_VAR 0 6
60886: PUSH
60887: LD_INT 2
60889: EQUAL
60890: AND
60891: OR
60892: IFFALSE 60902
// mode = 0 ;
60894: LD_ADDR_VAR 0 6
60898: PUSH
60899: LD_INT 0
60901: ST_TO_ADDR
// case mode of 0 :
60902: LD_VAR 0 6
60906: PUSH
60907: LD_INT 0
60909: DOUBLE
60910: EQUAL
60911: IFTRUE 60915
60913: GO 72368
60915: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
60916: LD_ADDR_VAR 0 11
60920: PUSH
60921: LD_INT 0
60923: PUSH
60924: LD_INT 0
60926: PUSH
60927: EMPTY
60928: LIST
60929: LIST
60930: PUSH
60931: LD_INT 0
60933: PUSH
60934: LD_INT 1
60936: NEG
60937: PUSH
60938: EMPTY
60939: LIST
60940: LIST
60941: PUSH
60942: LD_INT 1
60944: PUSH
60945: LD_INT 0
60947: PUSH
60948: EMPTY
60949: LIST
60950: LIST
60951: PUSH
60952: LD_INT 1
60954: PUSH
60955: LD_INT 1
60957: PUSH
60958: EMPTY
60959: LIST
60960: LIST
60961: PUSH
60962: LD_INT 0
60964: PUSH
60965: LD_INT 1
60967: PUSH
60968: EMPTY
60969: LIST
60970: LIST
60971: PUSH
60972: LD_INT 1
60974: NEG
60975: PUSH
60976: LD_INT 0
60978: PUSH
60979: EMPTY
60980: LIST
60981: LIST
60982: PUSH
60983: LD_INT 1
60985: NEG
60986: PUSH
60987: LD_INT 1
60989: NEG
60990: PUSH
60991: EMPTY
60992: LIST
60993: LIST
60994: PUSH
60995: LD_INT 1
60997: NEG
60998: PUSH
60999: LD_INT 2
61001: NEG
61002: PUSH
61003: EMPTY
61004: LIST
61005: LIST
61006: PUSH
61007: LD_INT 0
61009: PUSH
61010: LD_INT 2
61012: NEG
61013: PUSH
61014: EMPTY
61015: LIST
61016: LIST
61017: PUSH
61018: LD_INT 1
61020: PUSH
61021: LD_INT 1
61023: NEG
61024: PUSH
61025: EMPTY
61026: LIST
61027: LIST
61028: PUSH
61029: LD_INT 1
61031: PUSH
61032: LD_INT 2
61034: PUSH
61035: EMPTY
61036: LIST
61037: LIST
61038: PUSH
61039: LD_INT 0
61041: PUSH
61042: LD_INT 2
61044: PUSH
61045: EMPTY
61046: LIST
61047: LIST
61048: PUSH
61049: LD_INT 1
61051: NEG
61052: PUSH
61053: LD_INT 1
61055: PUSH
61056: EMPTY
61057: LIST
61058: LIST
61059: PUSH
61060: LD_INT 1
61062: PUSH
61063: LD_INT 3
61065: PUSH
61066: EMPTY
61067: LIST
61068: LIST
61069: PUSH
61070: LD_INT 0
61072: PUSH
61073: LD_INT 3
61075: PUSH
61076: EMPTY
61077: LIST
61078: LIST
61079: PUSH
61080: LD_INT 1
61082: NEG
61083: PUSH
61084: LD_INT 2
61086: PUSH
61087: EMPTY
61088: LIST
61089: LIST
61090: PUSH
61091: EMPTY
61092: LIST
61093: LIST
61094: LIST
61095: LIST
61096: LIST
61097: LIST
61098: LIST
61099: LIST
61100: LIST
61101: LIST
61102: LIST
61103: LIST
61104: LIST
61105: LIST
61106: LIST
61107: LIST
61108: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
61109: LD_ADDR_VAR 0 12
61113: PUSH
61114: LD_INT 0
61116: PUSH
61117: LD_INT 0
61119: PUSH
61120: EMPTY
61121: LIST
61122: LIST
61123: PUSH
61124: LD_INT 0
61126: PUSH
61127: LD_INT 1
61129: NEG
61130: PUSH
61131: EMPTY
61132: LIST
61133: LIST
61134: PUSH
61135: LD_INT 1
61137: PUSH
61138: LD_INT 0
61140: PUSH
61141: EMPTY
61142: LIST
61143: LIST
61144: PUSH
61145: LD_INT 1
61147: PUSH
61148: LD_INT 1
61150: PUSH
61151: EMPTY
61152: LIST
61153: LIST
61154: PUSH
61155: LD_INT 0
61157: PUSH
61158: LD_INT 1
61160: PUSH
61161: EMPTY
61162: LIST
61163: LIST
61164: PUSH
61165: LD_INT 1
61167: NEG
61168: PUSH
61169: LD_INT 0
61171: PUSH
61172: EMPTY
61173: LIST
61174: LIST
61175: PUSH
61176: LD_INT 1
61178: NEG
61179: PUSH
61180: LD_INT 1
61182: NEG
61183: PUSH
61184: EMPTY
61185: LIST
61186: LIST
61187: PUSH
61188: LD_INT 1
61190: PUSH
61191: LD_INT 1
61193: NEG
61194: PUSH
61195: EMPTY
61196: LIST
61197: LIST
61198: PUSH
61199: LD_INT 2
61201: PUSH
61202: LD_INT 0
61204: PUSH
61205: EMPTY
61206: LIST
61207: LIST
61208: PUSH
61209: LD_INT 2
61211: PUSH
61212: LD_INT 1
61214: PUSH
61215: EMPTY
61216: LIST
61217: LIST
61218: PUSH
61219: LD_INT 1
61221: NEG
61222: PUSH
61223: LD_INT 1
61225: PUSH
61226: EMPTY
61227: LIST
61228: LIST
61229: PUSH
61230: LD_INT 2
61232: NEG
61233: PUSH
61234: LD_INT 0
61236: PUSH
61237: EMPTY
61238: LIST
61239: LIST
61240: PUSH
61241: LD_INT 2
61243: NEG
61244: PUSH
61245: LD_INT 1
61247: NEG
61248: PUSH
61249: EMPTY
61250: LIST
61251: LIST
61252: PUSH
61253: LD_INT 2
61255: NEG
61256: PUSH
61257: LD_INT 1
61259: PUSH
61260: EMPTY
61261: LIST
61262: LIST
61263: PUSH
61264: LD_INT 3
61266: NEG
61267: PUSH
61268: LD_INT 0
61270: PUSH
61271: EMPTY
61272: LIST
61273: LIST
61274: PUSH
61275: LD_INT 3
61277: NEG
61278: PUSH
61279: LD_INT 1
61281: NEG
61282: PUSH
61283: EMPTY
61284: LIST
61285: LIST
61286: PUSH
61287: EMPTY
61288: LIST
61289: LIST
61290: LIST
61291: LIST
61292: LIST
61293: LIST
61294: LIST
61295: LIST
61296: LIST
61297: LIST
61298: LIST
61299: LIST
61300: LIST
61301: LIST
61302: LIST
61303: LIST
61304: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
61305: LD_ADDR_VAR 0 13
61309: PUSH
61310: LD_INT 0
61312: PUSH
61313: LD_INT 0
61315: PUSH
61316: EMPTY
61317: LIST
61318: LIST
61319: PUSH
61320: LD_INT 0
61322: PUSH
61323: LD_INT 1
61325: NEG
61326: PUSH
61327: EMPTY
61328: LIST
61329: LIST
61330: PUSH
61331: LD_INT 1
61333: PUSH
61334: LD_INT 0
61336: PUSH
61337: EMPTY
61338: LIST
61339: LIST
61340: PUSH
61341: LD_INT 1
61343: PUSH
61344: LD_INT 1
61346: PUSH
61347: EMPTY
61348: LIST
61349: LIST
61350: PUSH
61351: LD_INT 0
61353: PUSH
61354: LD_INT 1
61356: PUSH
61357: EMPTY
61358: LIST
61359: LIST
61360: PUSH
61361: LD_INT 1
61363: NEG
61364: PUSH
61365: LD_INT 0
61367: PUSH
61368: EMPTY
61369: LIST
61370: LIST
61371: PUSH
61372: LD_INT 1
61374: NEG
61375: PUSH
61376: LD_INT 1
61378: NEG
61379: PUSH
61380: EMPTY
61381: LIST
61382: LIST
61383: PUSH
61384: LD_INT 1
61386: NEG
61387: PUSH
61388: LD_INT 2
61390: NEG
61391: PUSH
61392: EMPTY
61393: LIST
61394: LIST
61395: PUSH
61396: LD_INT 2
61398: PUSH
61399: LD_INT 1
61401: PUSH
61402: EMPTY
61403: LIST
61404: LIST
61405: PUSH
61406: LD_INT 2
61408: PUSH
61409: LD_INT 2
61411: PUSH
61412: EMPTY
61413: LIST
61414: LIST
61415: PUSH
61416: LD_INT 1
61418: PUSH
61419: LD_INT 2
61421: PUSH
61422: EMPTY
61423: LIST
61424: LIST
61425: PUSH
61426: LD_INT 2
61428: NEG
61429: PUSH
61430: LD_INT 1
61432: NEG
61433: PUSH
61434: EMPTY
61435: LIST
61436: LIST
61437: PUSH
61438: LD_INT 2
61440: NEG
61441: PUSH
61442: LD_INT 2
61444: NEG
61445: PUSH
61446: EMPTY
61447: LIST
61448: LIST
61449: PUSH
61450: LD_INT 2
61452: NEG
61453: PUSH
61454: LD_INT 3
61456: NEG
61457: PUSH
61458: EMPTY
61459: LIST
61460: LIST
61461: PUSH
61462: LD_INT 3
61464: NEG
61465: PUSH
61466: LD_INT 2
61468: NEG
61469: PUSH
61470: EMPTY
61471: LIST
61472: LIST
61473: PUSH
61474: LD_INT 3
61476: NEG
61477: PUSH
61478: LD_INT 3
61480: NEG
61481: PUSH
61482: EMPTY
61483: LIST
61484: LIST
61485: PUSH
61486: EMPTY
61487: LIST
61488: LIST
61489: LIST
61490: LIST
61491: LIST
61492: LIST
61493: LIST
61494: LIST
61495: LIST
61496: LIST
61497: LIST
61498: LIST
61499: LIST
61500: LIST
61501: LIST
61502: LIST
61503: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
61504: LD_ADDR_VAR 0 14
61508: PUSH
61509: LD_INT 0
61511: PUSH
61512: LD_INT 0
61514: PUSH
61515: EMPTY
61516: LIST
61517: LIST
61518: PUSH
61519: LD_INT 0
61521: PUSH
61522: LD_INT 1
61524: NEG
61525: PUSH
61526: EMPTY
61527: LIST
61528: LIST
61529: PUSH
61530: LD_INT 1
61532: PUSH
61533: LD_INT 0
61535: PUSH
61536: EMPTY
61537: LIST
61538: LIST
61539: PUSH
61540: LD_INT 1
61542: PUSH
61543: LD_INT 1
61545: PUSH
61546: EMPTY
61547: LIST
61548: LIST
61549: PUSH
61550: LD_INT 0
61552: PUSH
61553: LD_INT 1
61555: PUSH
61556: EMPTY
61557: LIST
61558: LIST
61559: PUSH
61560: LD_INT 1
61562: NEG
61563: PUSH
61564: LD_INT 0
61566: PUSH
61567: EMPTY
61568: LIST
61569: LIST
61570: PUSH
61571: LD_INT 1
61573: NEG
61574: PUSH
61575: LD_INT 1
61577: NEG
61578: PUSH
61579: EMPTY
61580: LIST
61581: LIST
61582: PUSH
61583: LD_INT 1
61585: NEG
61586: PUSH
61587: LD_INT 2
61589: NEG
61590: PUSH
61591: EMPTY
61592: LIST
61593: LIST
61594: PUSH
61595: LD_INT 0
61597: PUSH
61598: LD_INT 2
61600: NEG
61601: PUSH
61602: EMPTY
61603: LIST
61604: LIST
61605: PUSH
61606: LD_INT 1
61608: PUSH
61609: LD_INT 1
61611: NEG
61612: PUSH
61613: EMPTY
61614: LIST
61615: LIST
61616: PUSH
61617: LD_INT 1
61619: PUSH
61620: LD_INT 2
61622: PUSH
61623: EMPTY
61624: LIST
61625: LIST
61626: PUSH
61627: LD_INT 0
61629: PUSH
61630: LD_INT 2
61632: PUSH
61633: EMPTY
61634: LIST
61635: LIST
61636: PUSH
61637: LD_INT 1
61639: NEG
61640: PUSH
61641: LD_INT 1
61643: PUSH
61644: EMPTY
61645: LIST
61646: LIST
61647: PUSH
61648: LD_INT 1
61650: NEG
61651: PUSH
61652: LD_INT 3
61654: NEG
61655: PUSH
61656: EMPTY
61657: LIST
61658: LIST
61659: PUSH
61660: LD_INT 0
61662: PUSH
61663: LD_INT 3
61665: NEG
61666: PUSH
61667: EMPTY
61668: LIST
61669: LIST
61670: PUSH
61671: LD_INT 1
61673: PUSH
61674: LD_INT 2
61676: NEG
61677: PUSH
61678: EMPTY
61679: LIST
61680: LIST
61681: PUSH
61682: EMPTY
61683: LIST
61684: LIST
61685: LIST
61686: LIST
61687: LIST
61688: LIST
61689: LIST
61690: LIST
61691: LIST
61692: LIST
61693: LIST
61694: LIST
61695: LIST
61696: LIST
61697: LIST
61698: LIST
61699: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
61700: LD_ADDR_VAR 0 15
61704: PUSH
61705: LD_INT 0
61707: PUSH
61708: LD_INT 0
61710: PUSH
61711: EMPTY
61712: LIST
61713: LIST
61714: PUSH
61715: LD_INT 0
61717: PUSH
61718: LD_INT 1
61720: NEG
61721: PUSH
61722: EMPTY
61723: LIST
61724: LIST
61725: PUSH
61726: LD_INT 1
61728: PUSH
61729: LD_INT 0
61731: PUSH
61732: EMPTY
61733: LIST
61734: LIST
61735: PUSH
61736: LD_INT 1
61738: PUSH
61739: LD_INT 1
61741: PUSH
61742: EMPTY
61743: LIST
61744: LIST
61745: PUSH
61746: LD_INT 0
61748: PUSH
61749: LD_INT 1
61751: PUSH
61752: EMPTY
61753: LIST
61754: LIST
61755: PUSH
61756: LD_INT 1
61758: NEG
61759: PUSH
61760: LD_INT 0
61762: PUSH
61763: EMPTY
61764: LIST
61765: LIST
61766: PUSH
61767: LD_INT 1
61769: NEG
61770: PUSH
61771: LD_INT 1
61773: NEG
61774: PUSH
61775: EMPTY
61776: LIST
61777: LIST
61778: PUSH
61779: LD_INT 1
61781: PUSH
61782: LD_INT 1
61784: NEG
61785: PUSH
61786: EMPTY
61787: LIST
61788: LIST
61789: PUSH
61790: LD_INT 2
61792: PUSH
61793: LD_INT 0
61795: PUSH
61796: EMPTY
61797: LIST
61798: LIST
61799: PUSH
61800: LD_INT 2
61802: PUSH
61803: LD_INT 1
61805: PUSH
61806: EMPTY
61807: LIST
61808: LIST
61809: PUSH
61810: LD_INT 1
61812: NEG
61813: PUSH
61814: LD_INT 1
61816: PUSH
61817: EMPTY
61818: LIST
61819: LIST
61820: PUSH
61821: LD_INT 2
61823: NEG
61824: PUSH
61825: LD_INT 0
61827: PUSH
61828: EMPTY
61829: LIST
61830: LIST
61831: PUSH
61832: LD_INT 2
61834: NEG
61835: PUSH
61836: LD_INT 1
61838: NEG
61839: PUSH
61840: EMPTY
61841: LIST
61842: LIST
61843: PUSH
61844: LD_INT 2
61846: PUSH
61847: LD_INT 1
61849: NEG
61850: PUSH
61851: EMPTY
61852: LIST
61853: LIST
61854: PUSH
61855: LD_INT 3
61857: PUSH
61858: LD_INT 0
61860: PUSH
61861: EMPTY
61862: LIST
61863: LIST
61864: PUSH
61865: LD_INT 3
61867: PUSH
61868: LD_INT 1
61870: PUSH
61871: EMPTY
61872: LIST
61873: LIST
61874: PUSH
61875: EMPTY
61876: LIST
61877: LIST
61878: LIST
61879: LIST
61880: LIST
61881: LIST
61882: LIST
61883: LIST
61884: LIST
61885: LIST
61886: LIST
61887: LIST
61888: LIST
61889: LIST
61890: LIST
61891: LIST
61892: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
61893: LD_ADDR_VAR 0 16
61897: PUSH
61898: LD_INT 0
61900: PUSH
61901: LD_INT 0
61903: PUSH
61904: EMPTY
61905: LIST
61906: LIST
61907: PUSH
61908: LD_INT 0
61910: PUSH
61911: LD_INT 1
61913: NEG
61914: PUSH
61915: EMPTY
61916: LIST
61917: LIST
61918: PUSH
61919: LD_INT 1
61921: PUSH
61922: LD_INT 0
61924: PUSH
61925: EMPTY
61926: LIST
61927: LIST
61928: PUSH
61929: LD_INT 1
61931: PUSH
61932: LD_INT 1
61934: PUSH
61935: EMPTY
61936: LIST
61937: LIST
61938: PUSH
61939: LD_INT 0
61941: PUSH
61942: LD_INT 1
61944: PUSH
61945: EMPTY
61946: LIST
61947: LIST
61948: PUSH
61949: LD_INT 1
61951: NEG
61952: PUSH
61953: LD_INT 0
61955: PUSH
61956: EMPTY
61957: LIST
61958: LIST
61959: PUSH
61960: LD_INT 1
61962: NEG
61963: PUSH
61964: LD_INT 1
61966: NEG
61967: PUSH
61968: EMPTY
61969: LIST
61970: LIST
61971: PUSH
61972: LD_INT 1
61974: NEG
61975: PUSH
61976: LD_INT 2
61978: NEG
61979: PUSH
61980: EMPTY
61981: LIST
61982: LIST
61983: PUSH
61984: LD_INT 2
61986: PUSH
61987: LD_INT 1
61989: PUSH
61990: EMPTY
61991: LIST
61992: LIST
61993: PUSH
61994: LD_INT 2
61996: PUSH
61997: LD_INT 2
61999: PUSH
62000: EMPTY
62001: LIST
62002: LIST
62003: PUSH
62004: LD_INT 1
62006: PUSH
62007: LD_INT 2
62009: PUSH
62010: EMPTY
62011: LIST
62012: LIST
62013: PUSH
62014: LD_INT 2
62016: NEG
62017: PUSH
62018: LD_INT 1
62020: NEG
62021: PUSH
62022: EMPTY
62023: LIST
62024: LIST
62025: PUSH
62026: LD_INT 2
62028: NEG
62029: PUSH
62030: LD_INT 2
62032: NEG
62033: PUSH
62034: EMPTY
62035: LIST
62036: LIST
62037: PUSH
62038: LD_INT 3
62040: PUSH
62041: LD_INT 2
62043: PUSH
62044: EMPTY
62045: LIST
62046: LIST
62047: PUSH
62048: LD_INT 3
62050: PUSH
62051: LD_INT 3
62053: PUSH
62054: EMPTY
62055: LIST
62056: LIST
62057: PUSH
62058: LD_INT 2
62060: PUSH
62061: LD_INT 3
62063: PUSH
62064: EMPTY
62065: LIST
62066: LIST
62067: PUSH
62068: EMPTY
62069: LIST
62070: LIST
62071: LIST
62072: LIST
62073: LIST
62074: LIST
62075: LIST
62076: LIST
62077: LIST
62078: LIST
62079: LIST
62080: LIST
62081: LIST
62082: LIST
62083: LIST
62084: LIST
62085: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62086: LD_ADDR_VAR 0 17
62090: PUSH
62091: LD_INT 0
62093: PUSH
62094: LD_INT 0
62096: PUSH
62097: EMPTY
62098: LIST
62099: LIST
62100: PUSH
62101: LD_INT 0
62103: PUSH
62104: LD_INT 1
62106: NEG
62107: PUSH
62108: EMPTY
62109: LIST
62110: LIST
62111: PUSH
62112: LD_INT 1
62114: PUSH
62115: LD_INT 0
62117: PUSH
62118: EMPTY
62119: LIST
62120: LIST
62121: PUSH
62122: LD_INT 1
62124: PUSH
62125: LD_INT 1
62127: PUSH
62128: EMPTY
62129: LIST
62130: LIST
62131: PUSH
62132: LD_INT 0
62134: PUSH
62135: LD_INT 1
62137: PUSH
62138: EMPTY
62139: LIST
62140: LIST
62141: PUSH
62142: LD_INT 1
62144: NEG
62145: PUSH
62146: LD_INT 0
62148: PUSH
62149: EMPTY
62150: LIST
62151: LIST
62152: PUSH
62153: LD_INT 1
62155: NEG
62156: PUSH
62157: LD_INT 1
62159: NEG
62160: PUSH
62161: EMPTY
62162: LIST
62163: LIST
62164: PUSH
62165: LD_INT 1
62167: NEG
62168: PUSH
62169: LD_INT 2
62171: NEG
62172: PUSH
62173: EMPTY
62174: LIST
62175: LIST
62176: PUSH
62177: LD_INT 0
62179: PUSH
62180: LD_INT 2
62182: NEG
62183: PUSH
62184: EMPTY
62185: LIST
62186: LIST
62187: PUSH
62188: LD_INT 1
62190: PUSH
62191: LD_INT 1
62193: NEG
62194: PUSH
62195: EMPTY
62196: LIST
62197: LIST
62198: PUSH
62199: LD_INT 2
62201: PUSH
62202: LD_INT 0
62204: PUSH
62205: EMPTY
62206: LIST
62207: LIST
62208: PUSH
62209: LD_INT 2
62211: PUSH
62212: LD_INT 1
62214: PUSH
62215: EMPTY
62216: LIST
62217: LIST
62218: PUSH
62219: LD_INT 2
62221: PUSH
62222: LD_INT 2
62224: PUSH
62225: EMPTY
62226: LIST
62227: LIST
62228: PUSH
62229: LD_INT 1
62231: PUSH
62232: LD_INT 2
62234: PUSH
62235: EMPTY
62236: LIST
62237: LIST
62238: PUSH
62239: LD_INT 0
62241: PUSH
62242: LD_INT 2
62244: PUSH
62245: EMPTY
62246: LIST
62247: LIST
62248: PUSH
62249: LD_INT 1
62251: NEG
62252: PUSH
62253: LD_INT 1
62255: PUSH
62256: EMPTY
62257: LIST
62258: LIST
62259: PUSH
62260: LD_INT 2
62262: NEG
62263: PUSH
62264: LD_INT 0
62266: PUSH
62267: EMPTY
62268: LIST
62269: LIST
62270: PUSH
62271: LD_INT 2
62273: NEG
62274: PUSH
62275: LD_INT 1
62277: NEG
62278: PUSH
62279: EMPTY
62280: LIST
62281: LIST
62282: PUSH
62283: LD_INT 2
62285: NEG
62286: PUSH
62287: LD_INT 2
62289: NEG
62290: PUSH
62291: EMPTY
62292: LIST
62293: LIST
62294: PUSH
62295: EMPTY
62296: LIST
62297: LIST
62298: LIST
62299: LIST
62300: LIST
62301: LIST
62302: LIST
62303: LIST
62304: LIST
62305: LIST
62306: LIST
62307: LIST
62308: LIST
62309: LIST
62310: LIST
62311: LIST
62312: LIST
62313: LIST
62314: LIST
62315: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62316: LD_ADDR_VAR 0 18
62320: PUSH
62321: LD_INT 0
62323: PUSH
62324: LD_INT 0
62326: PUSH
62327: EMPTY
62328: LIST
62329: LIST
62330: PUSH
62331: LD_INT 0
62333: PUSH
62334: LD_INT 1
62336: NEG
62337: PUSH
62338: EMPTY
62339: LIST
62340: LIST
62341: PUSH
62342: LD_INT 1
62344: PUSH
62345: LD_INT 0
62347: PUSH
62348: EMPTY
62349: LIST
62350: LIST
62351: PUSH
62352: LD_INT 1
62354: PUSH
62355: LD_INT 1
62357: PUSH
62358: EMPTY
62359: LIST
62360: LIST
62361: PUSH
62362: LD_INT 0
62364: PUSH
62365: LD_INT 1
62367: PUSH
62368: EMPTY
62369: LIST
62370: LIST
62371: PUSH
62372: LD_INT 1
62374: NEG
62375: PUSH
62376: LD_INT 0
62378: PUSH
62379: EMPTY
62380: LIST
62381: LIST
62382: PUSH
62383: LD_INT 1
62385: NEG
62386: PUSH
62387: LD_INT 1
62389: NEG
62390: PUSH
62391: EMPTY
62392: LIST
62393: LIST
62394: PUSH
62395: LD_INT 1
62397: NEG
62398: PUSH
62399: LD_INT 2
62401: NEG
62402: PUSH
62403: EMPTY
62404: LIST
62405: LIST
62406: PUSH
62407: LD_INT 0
62409: PUSH
62410: LD_INT 2
62412: NEG
62413: PUSH
62414: EMPTY
62415: LIST
62416: LIST
62417: PUSH
62418: LD_INT 1
62420: PUSH
62421: LD_INT 1
62423: NEG
62424: PUSH
62425: EMPTY
62426: LIST
62427: LIST
62428: PUSH
62429: LD_INT 2
62431: PUSH
62432: LD_INT 0
62434: PUSH
62435: EMPTY
62436: LIST
62437: LIST
62438: PUSH
62439: LD_INT 2
62441: PUSH
62442: LD_INT 1
62444: PUSH
62445: EMPTY
62446: LIST
62447: LIST
62448: PUSH
62449: LD_INT 2
62451: PUSH
62452: LD_INT 2
62454: PUSH
62455: EMPTY
62456: LIST
62457: LIST
62458: PUSH
62459: LD_INT 1
62461: PUSH
62462: LD_INT 2
62464: PUSH
62465: EMPTY
62466: LIST
62467: LIST
62468: PUSH
62469: LD_INT 0
62471: PUSH
62472: LD_INT 2
62474: PUSH
62475: EMPTY
62476: LIST
62477: LIST
62478: PUSH
62479: LD_INT 1
62481: NEG
62482: PUSH
62483: LD_INT 1
62485: PUSH
62486: EMPTY
62487: LIST
62488: LIST
62489: PUSH
62490: LD_INT 2
62492: NEG
62493: PUSH
62494: LD_INT 0
62496: PUSH
62497: EMPTY
62498: LIST
62499: LIST
62500: PUSH
62501: LD_INT 2
62503: NEG
62504: PUSH
62505: LD_INT 1
62507: NEG
62508: PUSH
62509: EMPTY
62510: LIST
62511: LIST
62512: PUSH
62513: LD_INT 2
62515: NEG
62516: PUSH
62517: LD_INT 2
62519: NEG
62520: PUSH
62521: EMPTY
62522: LIST
62523: LIST
62524: PUSH
62525: EMPTY
62526: LIST
62527: LIST
62528: LIST
62529: LIST
62530: LIST
62531: LIST
62532: LIST
62533: LIST
62534: LIST
62535: LIST
62536: LIST
62537: LIST
62538: LIST
62539: LIST
62540: LIST
62541: LIST
62542: LIST
62543: LIST
62544: LIST
62545: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62546: LD_ADDR_VAR 0 19
62550: PUSH
62551: LD_INT 0
62553: PUSH
62554: LD_INT 0
62556: PUSH
62557: EMPTY
62558: LIST
62559: LIST
62560: PUSH
62561: LD_INT 0
62563: PUSH
62564: LD_INT 1
62566: NEG
62567: PUSH
62568: EMPTY
62569: LIST
62570: LIST
62571: PUSH
62572: LD_INT 1
62574: PUSH
62575: LD_INT 0
62577: PUSH
62578: EMPTY
62579: LIST
62580: LIST
62581: PUSH
62582: LD_INT 1
62584: PUSH
62585: LD_INT 1
62587: PUSH
62588: EMPTY
62589: LIST
62590: LIST
62591: PUSH
62592: LD_INT 0
62594: PUSH
62595: LD_INT 1
62597: PUSH
62598: EMPTY
62599: LIST
62600: LIST
62601: PUSH
62602: LD_INT 1
62604: NEG
62605: PUSH
62606: LD_INT 0
62608: PUSH
62609: EMPTY
62610: LIST
62611: LIST
62612: PUSH
62613: LD_INT 1
62615: NEG
62616: PUSH
62617: LD_INT 1
62619: NEG
62620: PUSH
62621: EMPTY
62622: LIST
62623: LIST
62624: PUSH
62625: LD_INT 1
62627: NEG
62628: PUSH
62629: LD_INT 2
62631: NEG
62632: PUSH
62633: EMPTY
62634: LIST
62635: LIST
62636: PUSH
62637: LD_INT 0
62639: PUSH
62640: LD_INT 2
62642: NEG
62643: PUSH
62644: EMPTY
62645: LIST
62646: LIST
62647: PUSH
62648: LD_INT 1
62650: PUSH
62651: LD_INT 1
62653: NEG
62654: PUSH
62655: EMPTY
62656: LIST
62657: LIST
62658: PUSH
62659: LD_INT 2
62661: PUSH
62662: LD_INT 0
62664: PUSH
62665: EMPTY
62666: LIST
62667: LIST
62668: PUSH
62669: LD_INT 2
62671: PUSH
62672: LD_INT 1
62674: PUSH
62675: EMPTY
62676: LIST
62677: LIST
62678: PUSH
62679: LD_INT 2
62681: PUSH
62682: LD_INT 2
62684: PUSH
62685: EMPTY
62686: LIST
62687: LIST
62688: PUSH
62689: LD_INT 1
62691: PUSH
62692: LD_INT 2
62694: PUSH
62695: EMPTY
62696: LIST
62697: LIST
62698: PUSH
62699: LD_INT 0
62701: PUSH
62702: LD_INT 2
62704: PUSH
62705: EMPTY
62706: LIST
62707: LIST
62708: PUSH
62709: LD_INT 1
62711: NEG
62712: PUSH
62713: LD_INT 1
62715: PUSH
62716: EMPTY
62717: LIST
62718: LIST
62719: PUSH
62720: LD_INT 2
62722: NEG
62723: PUSH
62724: LD_INT 0
62726: PUSH
62727: EMPTY
62728: LIST
62729: LIST
62730: PUSH
62731: LD_INT 2
62733: NEG
62734: PUSH
62735: LD_INT 1
62737: NEG
62738: PUSH
62739: EMPTY
62740: LIST
62741: LIST
62742: PUSH
62743: LD_INT 2
62745: NEG
62746: PUSH
62747: LD_INT 2
62749: NEG
62750: PUSH
62751: EMPTY
62752: LIST
62753: LIST
62754: PUSH
62755: EMPTY
62756: LIST
62757: LIST
62758: LIST
62759: LIST
62760: LIST
62761: LIST
62762: LIST
62763: LIST
62764: LIST
62765: LIST
62766: LIST
62767: LIST
62768: LIST
62769: LIST
62770: LIST
62771: LIST
62772: LIST
62773: LIST
62774: LIST
62775: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62776: LD_ADDR_VAR 0 20
62780: PUSH
62781: LD_INT 0
62783: PUSH
62784: LD_INT 0
62786: PUSH
62787: EMPTY
62788: LIST
62789: LIST
62790: PUSH
62791: LD_INT 0
62793: PUSH
62794: LD_INT 1
62796: NEG
62797: PUSH
62798: EMPTY
62799: LIST
62800: LIST
62801: PUSH
62802: LD_INT 1
62804: PUSH
62805: LD_INT 0
62807: PUSH
62808: EMPTY
62809: LIST
62810: LIST
62811: PUSH
62812: LD_INT 1
62814: PUSH
62815: LD_INT 1
62817: PUSH
62818: EMPTY
62819: LIST
62820: LIST
62821: PUSH
62822: LD_INT 0
62824: PUSH
62825: LD_INT 1
62827: PUSH
62828: EMPTY
62829: LIST
62830: LIST
62831: PUSH
62832: LD_INT 1
62834: NEG
62835: PUSH
62836: LD_INT 0
62838: PUSH
62839: EMPTY
62840: LIST
62841: LIST
62842: PUSH
62843: LD_INT 1
62845: NEG
62846: PUSH
62847: LD_INT 1
62849: NEG
62850: PUSH
62851: EMPTY
62852: LIST
62853: LIST
62854: PUSH
62855: LD_INT 1
62857: NEG
62858: PUSH
62859: LD_INT 2
62861: NEG
62862: PUSH
62863: EMPTY
62864: LIST
62865: LIST
62866: PUSH
62867: LD_INT 0
62869: PUSH
62870: LD_INT 2
62872: NEG
62873: PUSH
62874: EMPTY
62875: LIST
62876: LIST
62877: PUSH
62878: LD_INT 1
62880: PUSH
62881: LD_INT 1
62883: NEG
62884: PUSH
62885: EMPTY
62886: LIST
62887: LIST
62888: PUSH
62889: LD_INT 2
62891: PUSH
62892: LD_INT 0
62894: PUSH
62895: EMPTY
62896: LIST
62897: LIST
62898: PUSH
62899: LD_INT 2
62901: PUSH
62902: LD_INT 1
62904: PUSH
62905: EMPTY
62906: LIST
62907: LIST
62908: PUSH
62909: LD_INT 2
62911: PUSH
62912: LD_INT 2
62914: PUSH
62915: EMPTY
62916: LIST
62917: LIST
62918: PUSH
62919: LD_INT 1
62921: PUSH
62922: LD_INT 2
62924: PUSH
62925: EMPTY
62926: LIST
62927: LIST
62928: PUSH
62929: LD_INT 0
62931: PUSH
62932: LD_INT 2
62934: PUSH
62935: EMPTY
62936: LIST
62937: LIST
62938: PUSH
62939: LD_INT 1
62941: NEG
62942: PUSH
62943: LD_INT 1
62945: PUSH
62946: EMPTY
62947: LIST
62948: LIST
62949: PUSH
62950: LD_INT 2
62952: NEG
62953: PUSH
62954: LD_INT 0
62956: PUSH
62957: EMPTY
62958: LIST
62959: LIST
62960: PUSH
62961: LD_INT 2
62963: NEG
62964: PUSH
62965: LD_INT 1
62967: NEG
62968: PUSH
62969: EMPTY
62970: LIST
62971: LIST
62972: PUSH
62973: LD_INT 2
62975: NEG
62976: PUSH
62977: LD_INT 2
62979: NEG
62980: PUSH
62981: EMPTY
62982: LIST
62983: LIST
62984: PUSH
62985: EMPTY
62986: LIST
62987: LIST
62988: LIST
62989: LIST
62990: LIST
62991: LIST
62992: LIST
62993: LIST
62994: LIST
62995: LIST
62996: LIST
62997: LIST
62998: LIST
62999: LIST
63000: LIST
63001: LIST
63002: LIST
63003: LIST
63004: LIST
63005: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63006: LD_ADDR_VAR 0 21
63010: PUSH
63011: LD_INT 0
63013: PUSH
63014: LD_INT 0
63016: PUSH
63017: EMPTY
63018: LIST
63019: LIST
63020: PUSH
63021: LD_INT 0
63023: PUSH
63024: LD_INT 1
63026: NEG
63027: PUSH
63028: EMPTY
63029: LIST
63030: LIST
63031: PUSH
63032: LD_INT 1
63034: PUSH
63035: LD_INT 0
63037: PUSH
63038: EMPTY
63039: LIST
63040: LIST
63041: PUSH
63042: LD_INT 1
63044: PUSH
63045: LD_INT 1
63047: PUSH
63048: EMPTY
63049: LIST
63050: LIST
63051: PUSH
63052: LD_INT 0
63054: PUSH
63055: LD_INT 1
63057: PUSH
63058: EMPTY
63059: LIST
63060: LIST
63061: PUSH
63062: LD_INT 1
63064: NEG
63065: PUSH
63066: LD_INT 0
63068: PUSH
63069: EMPTY
63070: LIST
63071: LIST
63072: PUSH
63073: LD_INT 1
63075: NEG
63076: PUSH
63077: LD_INT 1
63079: NEG
63080: PUSH
63081: EMPTY
63082: LIST
63083: LIST
63084: PUSH
63085: LD_INT 1
63087: NEG
63088: PUSH
63089: LD_INT 2
63091: NEG
63092: PUSH
63093: EMPTY
63094: LIST
63095: LIST
63096: PUSH
63097: LD_INT 0
63099: PUSH
63100: LD_INT 2
63102: NEG
63103: PUSH
63104: EMPTY
63105: LIST
63106: LIST
63107: PUSH
63108: LD_INT 1
63110: PUSH
63111: LD_INT 1
63113: NEG
63114: PUSH
63115: EMPTY
63116: LIST
63117: LIST
63118: PUSH
63119: LD_INT 2
63121: PUSH
63122: LD_INT 0
63124: PUSH
63125: EMPTY
63126: LIST
63127: LIST
63128: PUSH
63129: LD_INT 2
63131: PUSH
63132: LD_INT 1
63134: PUSH
63135: EMPTY
63136: LIST
63137: LIST
63138: PUSH
63139: LD_INT 2
63141: PUSH
63142: LD_INT 2
63144: PUSH
63145: EMPTY
63146: LIST
63147: LIST
63148: PUSH
63149: LD_INT 1
63151: PUSH
63152: LD_INT 2
63154: PUSH
63155: EMPTY
63156: LIST
63157: LIST
63158: PUSH
63159: LD_INT 0
63161: PUSH
63162: LD_INT 2
63164: PUSH
63165: EMPTY
63166: LIST
63167: LIST
63168: PUSH
63169: LD_INT 1
63171: NEG
63172: PUSH
63173: LD_INT 1
63175: PUSH
63176: EMPTY
63177: LIST
63178: LIST
63179: PUSH
63180: LD_INT 2
63182: NEG
63183: PUSH
63184: LD_INT 0
63186: PUSH
63187: EMPTY
63188: LIST
63189: LIST
63190: PUSH
63191: LD_INT 2
63193: NEG
63194: PUSH
63195: LD_INT 1
63197: NEG
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: PUSH
63203: LD_INT 2
63205: NEG
63206: PUSH
63207: LD_INT 2
63209: NEG
63210: PUSH
63211: EMPTY
63212: LIST
63213: LIST
63214: PUSH
63215: EMPTY
63216: LIST
63217: LIST
63218: LIST
63219: LIST
63220: LIST
63221: LIST
63222: LIST
63223: LIST
63224: LIST
63225: LIST
63226: LIST
63227: LIST
63228: LIST
63229: LIST
63230: LIST
63231: LIST
63232: LIST
63233: LIST
63234: LIST
63235: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63236: LD_ADDR_VAR 0 22
63240: PUSH
63241: LD_INT 0
63243: PUSH
63244: LD_INT 0
63246: PUSH
63247: EMPTY
63248: LIST
63249: LIST
63250: PUSH
63251: LD_INT 0
63253: PUSH
63254: LD_INT 1
63256: NEG
63257: PUSH
63258: EMPTY
63259: LIST
63260: LIST
63261: PUSH
63262: LD_INT 1
63264: PUSH
63265: LD_INT 0
63267: PUSH
63268: EMPTY
63269: LIST
63270: LIST
63271: PUSH
63272: LD_INT 1
63274: PUSH
63275: LD_INT 1
63277: PUSH
63278: EMPTY
63279: LIST
63280: LIST
63281: PUSH
63282: LD_INT 0
63284: PUSH
63285: LD_INT 1
63287: PUSH
63288: EMPTY
63289: LIST
63290: LIST
63291: PUSH
63292: LD_INT 1
63294: NEG
63295: PUSH
63296: LD_INT 0
63298: PUSH
63299: EMPTY
63300: LIST
63301: LIST
63302: PUSH
63303: LD_INT 1
63305: NEG
63306: PUSH
63307: LD_INT 1
63309: NEG
63310: PUSH
63311: EMPTY
63312: LIST
63313: LIST
63314: PUSH
63315: LD_INT 1
63317: NEG
63318: PUSH
63319: LD_INT 2
63321: NEG
63322: PUSH
63323: EMPTY
63324: LIST
63325: LIST
63326: PUSH
63327: LD_INT 0
63329: PUSH
63330: LD_INT 2
63332: NEG
63333: PUSH
63334: EMPTY
63335: LIST
63336: LIST
63337: PUSH
63338: LD_INT 1
63340: PUSH
63341: LD_INT 1
63343: NEG
63344: PUSH
63345: EMPTY
63346: LIST
63347: LIST
63348: PUSH
63349: LD_INT 2
63351: PUSH
63352: LD_INT 0
63354: PUSH
63355: EMPTY
63356: LIST
63357: LIST
63358: PUSH
63359: LD_INT 2
63361: PUSH
63362: LD_INT 1
63364: PUSH
63365: EMPTY
63366: LIST
63367: LIST
63368: PUSH
63369: LD_INT 2
63371: PUSH
63372: LD_INT 2
63374: PUSH
63375: EMPTY
63376: LIST
63377: LIST
63378: PUSH
63379: LD_INT 1
63381: PUSH
63382: LD_INT 2
63384: PUSH
63385: EMPTY
63386: LIST
63387: LIST
63388: PUSH
63389: LD_INT 0
63391: PUSH
63392: LD_INT 2
63394: PUSH
63395: EMPTY
63396: LIST
63397: LIST
63398: PUSH
63399: LD_INT 1
63401: NEG
63402: PUSH
63403: LD_INT 1
63405: PUSH
63406: EMPTY
63407: LIST
63408: LIST
63409: PUSH
63410: LD_INT 2
63412: NEG
63413: PUSH
63414: LD_INT 0
63416: PUSH
63417: EMPTY
63418: LIST
63419: LIST
63420: PUSH
63421: LD_INT 2
63423: NEG
63424: PUSH
63425: LD_INT 1
63427: NEG
63428: PUSH
63429: EMPTY
63430: LIST
63431: LIST
63432: PUSH
63433: LD_INT 2
63435: NEG
63436: PUSH
63437: LD_INT 2
63439: NEG
63440: PUSH
63441: EMPTY
63442: LIST
63443: LIST
63444: PUSH
63445: EMPTY
63446: LIST
63447: LIST
63448: LIST
63449: LIST
63450: LIST
63451: LIST
63452: LIST
63453: LIST
63454: LIST
63455: LIST
63456: LIST
63457: LIST
63458: LIST
63459: LIST
63460: LIST
63461: LIST
63462: LIST
63463: LIST
63464: LIST
63465: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
63466: LD_ADDR_VAR 0 23
63470: PUSH
63471: LD_INT 0
63473: PUSH
63474: LD_INT 0
63476: PUSH
63477: EMPTY
63478: LIST
63479: LIST
63480: PUSH
63481: LD_INT 0
63483: PUSH
63484: LD_INT 1
63486: NEG
63487: PUSH
63488: EMPTY
63489: LIST
63490: LIST
63491: PUSH
63492: LD_INT 1
63494: PUSH
63495: LD_INT 0
63497: PUSH
63498: EMPTY
63499: LIST
63500: LIST
63501: PUSH
63502: LD_INT 1
63504: PUSH
63505: LD_INT 1
63507: PUSH
63508: EMPTY
63509: LIST
63510: LIST
63511: PUSH
63512: LD_INT 0
63514: PUSH
63515: LD_INT 1
63517: PUSH
63518: EMPTY
63519: LIST
63520: LIST
63521: PUSH
63522: LD_INT 1
63524: NEG
63525: PUSH
63526: LD_INT 0
63528: PUSH
63529: EMPTY
63530: LIST
63531: LIST
63532: PUSH
63533: LD_INT 1
63535: NEG
63536: PUSH
63537: LD_INT 1
63539: NEG
63540: PUSH
63541: EMPTY
63542: LIST
63543: LIST
63544: PUSH
63545: LD_INT 1
63547: NEG
63548: PUSH
63549: LD_INT 2
63551: NEG
63552: PUSH
63553: EMPTY
63554: LIST
63555: LIST
63556: PUSH
63557: LD_INT 0
63559: PUSH
63560: LD_INT 2
63562: NEG
63563: PUSH
63564: EMPTY
63565: LIST
63566: LIST
63567: PUSH
63568: LD_INT 1
63570: PUSH
63571: LD_INT 1
63573: NEG
63574: PUSH
63575: EMPTY
63576: LIST
63577: LIST
63578: PUSH
63579: LD_INT 2
63581: PUSH
63582: LD_INT 0
63584: PUSH
63585: EMPTY
63586: LIST
63587: LIST
63588: PUSH
63589: LD_INT 2
63591: PUSH
63592: LD_INT 1
63594: PUSH
63595: EMPTY
63596: LIST
63597: LIST
63598: PUSH
63599: LD_INT 2
63601: PUSH
63602: LD_INT 2
63604: PUSH
63605: EMPTY
63606: LIST
63607: LIST
63608: PUSH
63609: LD_INT 1
63611: PUSH
63612: LD_INT 2
63614: PUSH
63615: EMPTY
63616: LIST
63617: LIST
63618: PUSH
63619: LD_INT 0
63621: PUSH
63622: LD_INT 2
63624: PUSH
63625: EMPTY
63626: LIST
63627: LIST
63628: PUSH
63629: LD_INT 1
63631: NEG
63632: PUSH
63633: LD_INT 1
63635: PUSH
63636: EMPTY
63637: LIST
63638: LIST
63639: PUSH
63640: LD_INT 2
63642: NEG
63643: PUSH
63644: LD_INT 0
63646: PUSH
63647: EMPTY
63648: LIST
63649: LIST
63650: PUSH
63651: LD_INT 2
63653: NEG
63654: PUSH
63655: LD_INT 1
63657: NEG
63658: PUSH
63659: EMPTY
63660: LIST
63661: LIST
63662: PUSH
63663: LD_INT 2
63665: NEG
63666: PUSH
63667: LD_INT 2
63669: NEG
63670: PUSH
63671: EMPTY
63672: LIST
63673: LIST
63674: PUSH
63675: LD_INT 2
63677: NEG
63678: PUSH
63679: LD_INT 3
63681: NEG
63682: PUSH
63683: EMPTY
63684: LIST
63685: LIST
63686: PUSH
63687: LD_INT 1
63689: NEG
63690: PUSH
63691: LD_INT 3
63693: NEG
63694: PUSH
63695: EMPTY
63696: LIST
63697: LIST
63698: PUSH
63699: LD_INT 1
63701: PUSH
63702: LD_INT 2
63704: NEG
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PUSH
63710: LD_INT 2
63712: PUSH
63713: LD_INT 1
63715: NEG
63716: PUSH
63717: EMPTY
63718: LIST
63719: LIST
63720: PUSH
63721: EMPTY
63722: LIST
63723: LIST
63724: LIST
63725: LIST
63726: LIST
63727: LIST
63728: LIST
63729: LIST
63730: LIST
63731: LIST
63732: LIST
63733: LIST
63734: LIST
63735: LIST
63736: LIST
63737: LIST
63738: LIST
63739: LIST
63740: LIST
63741: LIST
63742: LIST
63743: LIST
63744: LIST
63745: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
63746: LD_ADDR_VAR 0 24
63750: PUSH
63751: LD_INT 0
63753: PUSH
63754: LD_INT 0
63756: PUSH
63757: EMPTY
63758: LIST
63759: LIST
63760: PUSH
63761: LD_INT 0
63763: PUSH
63764: LD_INT 1
63766: NEG
63767: PUSH
63768: EMPTY
63769: LIST
63770: LIST
63771: PUSH
63772: LD_INT 1
63774: PUSH
63775: LD_INT 0
63777: PUSH
63778: EMPTY
63779: LIST
63780: LIST
63781: PUSH
63782: LD_INT 1
63784: PUSH
63785: LD_INT 1
63787: PUSH
63788: EMPTY
63789: LIST
63790: LIST
63791: PUSH
63792: LD_INT 0
63794: PUSH
63795: LD_INT 1
63797: PUSH
63798: EMPTY
63799: LIST
63800: LIST
63801: PUSH
63802: LD_INT 1
63804: NEG
63805: PUSH
63806: LD_INT 0
63808: PUSH
63809: EMPTY
63810: LIST
63811: LIST
63812: PUSH
63813: LD_INT 1
63815: NEG
63816: PUSH
63817: LD_INT 1
63819: NEG
63820: PUSH
63821: EMPTY
63822: LIST
63823: LIST
63824: PUSH
63825: LD_INT 1
63827: NEG
63828: PUSH
63829: LD_INT 2
63831: NEG
63832: PUSH
63833: EMPTY
63834: LIST
63835: LIST
63836: PUSH
63837: LD_INT 0
63839: PUSH
63840: LD_INT 2
63842: NEG
63843: PUSH
63844: EMPTY
63845: LIST
63846: LIST
63847: PUSH
63848: LD_INT 1
63850: PUSH
63851: LD_INT 1
63853: NEG
63854: PUSH
63855: EMPTY
63856: LIST
63857: LIST
63858: PUSH
63859: LD_INT 2
63861: PUSH
63862: LD_INT 0
63864: PUSH
63865: EMPTY
63866: LIST
63867: LIST
63868: PUSH
63869: LD_INT 2
63871: PUSH
63872: LD_INT 1
63874: PUSH
63875: EMPTY
63876: LIST
63877: LIST
63878: PUSH
63879: LD_INT 2
63881: PUSH
63882: LD_INT 2
63884: PUSH
63885: EMPTY
63886: LIST
63887: LIST
63888: PUSH
63889: LD_INT 1
63891: PUSH
63892: LD_INT 2
63894: PUSH
63895: EMPTY
63896: LIST
63897: LIST
63898: PUSH
63899: LD_INT 0
63901: PUSH
63902: LD_INT 2
63904: PUSH
63905: EMPTY
63906: LIST
63907: LIST
63908: PUSH
63909: LD_INT 1
63911: NEG
63912: PUSH
63913: LD_INT 1
63915: PUSH
63916: EMPTY
63917: LIST
63918: LIST
63919: PUSH
63920: LD_INT 2
63922: NEG
63923: PUSH
63924: LD_INT 0
63926: PUSH
63927: EMPTY
63928: LIST
63929: LIST
63930: PUSH
63931: LD_INT 2
63933: NEG
63934: PUSH
63935: LD_INT 1
63937: NEG
63938: PUSH
63939: EMPTY
63940: LIST
63941: LIST
63942: PUSH
63943: LD_INT 2
63945: NEG
63946: PUSH
63947: LD_INT 2
63949: NEG
63950: PUSH
63951: EMPTY
63952: LIST
63953: LIST
63954: PUSH
63955: LD_INT 1
63957: PUSH
63958: LD_INT 2
63960: NEG
63961: PUSH
63962: EMPTY
63963: LIST
63964: LIST
63965: PUSH
63966: LD_INT 2
63968: PUSH
63969: LD_INT 1
63971: NEG
63972: PUSH
63973: EMPTY
63974: LIST
63975: LIST
63976: PUSH
63977: LD_INT 3
63979: PUSH
63980: LD_INT 1
63982: PUSH
63983: EMPTY
63984: LIST
63985: LIST
63986: PUSH
63987: LD_INT 3
63989: PUSH
63990: LD_INT 2
63992: PUSH
63993: EMPTY
63994: LIST
63995: LIST
63996: PUSH
63997: EMPTY
63998: LIST
63999: LIST
64000: LIST
64001: LIST
64002: LIST
64003: LIST
64004: LIST
64005: LIST
64006: LIST
64007: LIST
64008: LIST
64009: LIST
64010: LIST
64011: LIST
64012: LIST
64013: LIST
64014: LIST
64015: LIST
64016: LIST
64017: LIST
64018: LIST
64019: LIST
64020: LIST
64021: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
64022: LD_ADDR_VAR 0 25
64026: PUSH
64027: LD_INT 0
64029: PUSH
64030: LD_INT 0
64032: PUSH
64033: EMPTY
64034: LIST
64035: LIST
64036: PUSH
64037: LD_INT 0
64039: PUSH
64040: LD_INT 1
64042: NEG
64043: PUSH
64044: EMPTY
64045: LIST
64046: LIST
64047: PUSH
64048: LD_INT 1
64050: PUSH
64051: LD_INT 0
64053: PUSH
64054: EMPTY
64055: LIST
64056: LIST
64057: PUSH
64058: LD_INT 1
64060: PUSH
64061: LD_INT 1
64063: PUSH
64064: EMPTY
64065: LIST
64066: LIST
64067: PUSH
64068: LD_INT 0
64070: PUSH
64071: LD_INT 1
64073: PUSH
64074: EMPTY
64075: LIST
64076: LIST
64077: PUSH
64078: LD_INT 1
64080: NEG
64081: PUSH
64082: LD_INT 0
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: PUSH
64089: LD_INT 1
64091: NEG
64092: PUSH
64093: LD_INT 1
64095: NEG
64096: PUSH
64097: EMPTY
64098: LIST
64099: LIST
64100: PUSH
64101: LD_INT 1
64103: NEG
64104: PUSH
64105: LD_INT 2
64107: NEG
64108: PUSH
64109: EMPTY
64110: LIST
64111: LIST
64112: PUSH
64113: LD_INT 0
64115: PUSH
64116: LD_INT 2
64118: NEG
64119: PUSH
64120: EMPTY
64121: LIST
64122: LIST
64123: PUSH
64124: LD_INT 1
64126: PUSH
64127: LD_INT 1
64129: NEG
64130: PUSH
64131: EMPTY
64132: LIST
64133: LIST
64134: PUSH
64135: LD_INT 2
64137: PUSH
64138: LD_INT 0
64140: PUSH
64141: EMPTY
64142: LIST
64143: LIST
64144: PUSH
64145: LD_INT 2
64147: PUSH
64148: LD_INT 1
64150: PUSH
64151: EMPTY
64152: LIST
64153: LIST
64154: PUSH
64155: LD_INT 2
64157: PUSH
64158: LD_INT 2
64160: PUSH
64161: EMPTY
64162: LIST
64163: LIST
64164: PUSH
64165: LD_INT 1
64167: PUSH
64168: LD_INT 2
64170: PUSH
64171: EMPTY
64172: LIST
64173: LIST
64174: PUSH
64175: LD_INT 0
64177: PUSH
64178: LD_INT 2
64180: PUSH
64181: EMPTY
64182: LIST
64183: LIST
64184: PUSH
64185: LD_INT 1
64187: NEG
64188: PUSH
64189: LD_INT 1
64191: PUSH
64192: EMPTY
64193: LIST
64194: LIST
64195: PUSH
64196: LD_INT 2
64198: NEG
64199: PUSH
64200: LD_INT 0
64202: PUSH
64203: EMPTY
64204: LIST
64205: LIST
64206: PUSH
64207: LD_INT 2
64209: NEG
64210: PUSH
64211: LD_INT 1
64213: NEG
64214: PUSH
64215: EMPTY
64216: LIST
64217: LIST
64218: PUSH
64219: LD_INT 2
64221: NEG
64222: PUSH
64223: LD_INT 2
64225: NEG
64226: PUSH
64227: EMPTY
64228: LIST
64229: LIST
64230: PUSH
64231: LD_INT 3
64233: PUSH
64234: LD_INT 1
64236: PUSH
64237: EMPTY
64238: LIST
64239: LIST
64240: PUSH
64241: LD_INT 3
64243: PUSH
64244: LD_INT 2
64246: PUSH
64247: EMPTY
64248: LIST
64249: LIST
64250: PUSH
64251: LD_INT 2
64253: PUSH
64254: LD_INT 3
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: PUSH
64261: LD_INT 1
64263: PUSH
64264: LD_INT 3
64266: PUSH
64267: EMPTY
64268: LIST
64269: LIST
64270: PUSH
64271: EMPTY
64272: LIST
64273: LIST
64274: LIST
64275: LIST
64276: LIST
64277: LIST
64278: LIST
64279: LIST
64280: LIST
64281: LIST
64282: LIST
64283: LIST
64284: LIST
64285: LIST
64286: LIST
64287: LIST
64288: LIST
64289: LIST
64290: LIST
64291: LIST
64292: LIST
64293: LIST
64294: LIST
64295: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
64296: LD_ADDR_VAR 0 26
64300: PUSH
64301: LD_INT 0
64303: PUSH
64304: LD_INT 0
64306: PUSH
64307: EMPTY
64308: LIST
64309: LIST
64310: PUSH
64311: LD_INT 0
64313: PUSH
64314: LD_INT 1
64316: NEG
64317: PUSH
64318: EMPTY
64319: LIST
64320: LIST
64321: PUSH
64322: LD_INT 1
64324: PUSH
64325: LD_INT 0
64327: PUSH
64328: EMPTY
64329: LIST
64330: LIST
64331: PUSH
64332: LD_INT 1
64334: PUSH
64335: LD_INT 1
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: PUSH
64342: LD_INT 0
64344: PUSH
64345: LD_INT 1
64347: PUSH
64348: EMPTY
64349: LIST
64350: LIST
64351: PUSH
64352: LD_INT 1
64354: NEG
64355: PUSH
64356: LD_INT 0
64358: PUSH
64359: EMPTY
64360: LIST
64361: LIST
64362: PUSH
64363: LD_INT 1
64365: NEG
64366: PUSH
64367: LD_INT 1
64369: NEG
64370: PUSH
64371: EMPTY
64372: LIST
64373: LIST
64374: PUSH
64375: LD_INT 1
64377: NEG
64378: PUSH
64379: LD_INT 2
64381: NEG
64382: PUSH
64383: EMPTY
64384: LIST
64385: LIST
64386: PUSH
64387: LD_INT 0
64389: PUSH
64390: LD_INT 2
64392: NEG
64393: PUSH
64394: EMPTY
64395: LIST
64396: LIST
64397: PUSH
64398: LD_INT 1
64400: PUSH
64401: LD_INT 1
64403: NEG
64404: PUSH
64405: EMPTY
64406: LIST
64407: LIST
64408: PUSH
64409: LD_INT 2
64411: PUSH
64412: LD_INT 0
64414: PUSH
64415: EMPTY
64416: LIST
64417: LIST
64418: PUSH
64419: LD_INT 2
64421: PUSH
64422: LD_INT 1
64424: PUSH
64425: EMPTY
64426: LIST
64427: LIST
64428: PUSH
64429: LD_INT 2
64431: PUSH
64432: LD_INT 2
64434: PUSH
64435: EMPTY
64436: LIST
64437: LIST
64438: PUSH
64439: LD_INT 1
64441: PUSH
64442: LD_INT 2
64444: PUSH
64445: EMPTY
64446: LIST
64447: LIST
64448: PUSH
64449: LD_INT 0
64451: PUSH
64452: LD_INT 2
64454: PUSH
64455: EMPTY
64456: LIST
64457: LIST
64458: PUSH
64459: LD_INT 1
64461: NEG
64462: PUSH
64463: LD_INT 1
64465: PUSH
64466: EMPTY
64467: LIST
64468: LIST
64469: PUSH
64470: LD_INT 2
64472: NEG
64473: PUSH
64474: LD_INT 0
64476: PUSH
64477: EMPTY
64478: LIST
64479: LIST
64480: PUSH
64481: LD_INT 2
64483: NEG
64484: PUSH
64485: LD_INT 1
64487: NEG
64488: PUSH
64489: EMPTY
64490: LIST
64491: LIST
64492: PUSH
64493: LD_INT 2
64495: NEG
64496: PUSH
64497: LD_INT 2
64499: NEG
64500: PUSH
64501: EMPTY
64502: LIST
64503: LIST
64504: PUSH
64505: LD_INT 2
64507: PUSH
64508: LD_INT 3
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: PUSH
64515: LD_INT 1
64517: PUSH
64518: LD_INT 3
64520: PUSH
64521: EMPTY
64522: LIST
64523: LIST
64524: PUSH
64525: LD_INT 1
64527: NEG
64528: PUSH
64529: LD_INT 2
64531: PUSH
64532: EMPTY
64533: LIST
64534: LIST
64535: PUSH
64536: LD_INT 2
64538: NEG
64539: PUSH
64540: LD_INT 1
64542: PUSH
64543: EMPTY
64544: LIST
64545: LIST
64546: PUSH
64547: EMPTY
64548: LIST
64549: LIST
64550: LIST
64551: LIST
64552: LIST
64553: LIST
64554: LIST
64555: LIST
64556: LIST
64557: LIST
64558: LIST
64559: LIST
64560: LIST
64561: LIST
64562: LIST
64563: LIST
64564: LIST
64565: LIST
64566: LIST
64567: LIST
64568: LIST
64569: LIST
64570: LIST
64571: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
64572: LD_ADDR_VAR 0 27
64576: PUSH
64577: LD_INT 0
64579: PUSH
64580: LD_INT 0
64582: PUSH
64583: EMPTY
64584: LIST
64585: LIST
64586: PUSH
64587: LD_INT 0
64589: PUSH
64590: LD_INT 1
64592: NEG
64593: PUSH
64594: EMPTY
64595: LIST
64596: LIST
64597: PUSH
64598: LD_INT 1
64600: PUSH
64601: LD_INT 0
64603: PUSH
64604: EMPTY
64605: LIST
64606: LIST
64607: PUSH
64608: LD_INT 1
64610: PUSH
64611: LD_INT 1
64613: PUSH
64614: EMPTY
64615: LIST
64616: LIST
64617: PUSH
64618: LD_INT 0
64620: PUSH
64621: LD_INT 1
64623: PUSH
64624: EMPTY
64625: LIST
64626: LIST
64627: PUSH
64628: LD_INT 1
64630: NEG
64631: PUSH
64632: LD_INT 0
64634: PUSH
64635: EMPTY
64636: LIST
64637: LIST
64638: PUSH
64639: LD_INT 1
64641: NEG
64642: PUSH
64643: LD_INT 1
64645: NEG
64646: PUSH
64647: EMPTY
64648: LIST
64649: LIST
64650: PUSH
64651: LD_INT 1
64653: NEG
64654: PUSH
64655: LD_INT 2
64657: NEG
64658: PUSH
64659: EMPTY
64660: LIST
64661: LIST
64662: PUSH
64663: LD_INT 0
64665: PUSH
64666: LD_INT 2
64668: NEG
64669: PUSH
64670: EMPTY
64671: LIST
64672: LIST
64673: PUSH
64674: LD_INT 1
64676: PUSH
64677: LD_INT 1
64679: NEG
64680: PUSH
64681: EMPTY
64682: LIST
64683: LIST
64684: PUSH
64685: LD_INT 2
64687: PUSH
64688: LD_INT 0
64690: PUSH
64691: EMPTY
64692: LIST
64693: LIST
64694: PUSH
64695: LD_INT 2
64697: PUSH
64698: LD_INT 1
64700: PUSH
64701: EMPTY
64702: LIST
64703: LIST
64704: PUSH
64705: LD_INT 2
64707: PUSH
64708: LD_INT 2
64710: PUSH
64711: EMPTY
64712: LIST
64713: LIST
64714: PUSH
64715: LD_INT 1
64717: PUSH
64718: LD_INT 2
64720: PUSH
64721: EMPTY
64722: LIST
64723: LIST
64724: PUSH
64725: LD_INT 0
64727: PUSH
64728: LD_INT 2
64730: PUSH
64731: EMPTY
64732: LIST
64733: LIST
64734: PUSH
64735: LD_INT 1
64737: NEG
64738: PUSH
64739: LD_INT 1
64741: PUSH
64742: EMPTY
64743: LIST
64744: LIST
64745: PUSH
64746: LD_INT 2
64748: NEG
64749: PUSH
64750: LD_INT 0
64752: PUSH
64753: EMPTY
64754: LIST
64755: LIST
64756: PUSH
64757: LD_INT 2
64759: NEG
64760: PUSH
64761: LD_INT 1
64763: NEG
64764: PUSH
64765: EMPTY
64766: LIST
64767: LIST
64768: PUSH
64769: LD_INT 2
64771: NEG
64772: PUSH
64773: LD_INT 2
64775: NEG
64776: PUSH
64777: EMPTY
64778: LIST
64779: LIST
64780: PUSH
64781: LD_INT 1
64783: NEG
64784: PUSH
64785: LD_INT 2
64787: PUSH
64788: EMPTY
64789: LIST
64790: LIST
64791: PUSH
64792: LD_INT 2
64794: NEG
64795: PUSH
64796: LD_INT 1
64798: PUSH
64799: EMPTY
64800: LIST
64801: LIST
64802: PUSH
64803: LD_INT 3
64805: NEG
64806: PUSH
64807: LD_INT 1
64809: NEG
64810: PUSH
64811: EMPTY
64812: LIST
64813: LIST
64814: PUSH
64815: LD_INT 3
64817: NEG
64818: PUSH
64819: LD_INT 2
64821: NEG
64822: PUSH
64823: EMPTY
64824: LIST
64825: LIST
64826: PUSH
64827: EMPTY
64828: LIST
64829: LIST
64830: LIST
64831: LIST
64832: LIST
64833: LIST
64834: LIST
64835: LIST
64836: LIST
64837: LIST
64838: LIST
64839: LIST
64840: LIST
64841: LIST
64842: LIST
64843: LIST
64844: LIST
64845: LIST
64846: LIST
64847: LIST
64848: LIST
64849: LIST
64850: LIST
64851: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
64852: LD_ADDR_VAR 0 28
64856: PUSH
64857: LD_INT 0
64859: PUSH
64860: LD_INT 0
64862: PUSH
64863: EMPTY
64864: LIST
64865: LIST
64866: PUSH
64867: LD_INT 0
64869: PUSH
64870: LD_INT 1
64872: NEG
64873: PUSH
64874: EMPTY
64875: LIST
64876: LIST
64877: PUSH
64878: LD_INT 1
64880: PUSH
64881: LD_INT 0
64883: PUSH
64884: EMPTY
64885: LIST
64886: LIST
64887: PUSH
64888: LD_INT 1
64890: PUSH
64891: LD_INT 1
64893: PUSH
64894: EMPTY
64895: LIST
64896: LIST
64897: PUSH
64898: LD_INT 0
64900: PUSH
64901: LD_INT 1
64903: PUSH
64904: EMPTY
64905: LIST
64906: LIST
64907: PUSH
64908: LD_INT 1
64910: NEG
64911: PUSH
64912: LD_INT 0
64914: PUSH
64915: EMPTY
64916: LIST
64917: LIST
64918: PUSH
64919: LD_INT 1
64921: NEG
64922: PUSH
64923: LD_INT 1
64925: NEG
64926: PUSH
64927: EMPTY
64928: LIST
64929: LIST
64930: PUSH
64931: LD_INT 1
64933: NEG
64934: PUSH
64935: LD_INT 2
64937: NEG
64938: PUSH
64939: EMPTY
64940: LIST
64941: LIST
64942: PUSH
64943: LD_INT 0
64945: PUSH
64946: LD_INT 2
64948: NEG
64949: PUSH
64950: EMPTY
64951: LIST
64952: LIST
64953: PUSH
64954: LD_INT 1
64956: PUSH
64957: LD_INT 1
64959: NEG
64960: PUSH
64961: EMPTY
64962: LIST
64963: LIST
64964: PUSH
64965: LD_INT 2
64967: PUSH
64968: LD_INT 0
64970: PUSH
64971: EMPTY
64972: LIST
64973: LIST
64974: PUSH
64975: LD_INT 2
64977: PUSH
64978: LD_INT 1
64980: PUSH
64981: EMPTY
64982: LIST
64983: LIST
64984: PUSH
64985: LD_INT 2
64987: PUSH
64988: LD_INT 2
64990: PUSH
64991: EMPTY
64992: LIST
64993: LIST
64994: PUSH
64995: LD_INT 1
64997: PUSH
64998: LD_INT 2
65000: PUSH
65001: EMPTY
65002: LIST
65003: LIST
65004: PUSH
65005: LD_INT 0
65007: PUSH
65008: LD_INT 2
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: PUSH
65015: LD_INT 1
65017: NEG
65018: PUSH
65019: LD_INT 1
65021: PUSH
65022: EMPTY
65023: LIST
65024: LIST
65025: PUSH
65026: LD_INT 2
65028: NEG
65029: PUSH
65030: LD_INT 0
65032: PUSH
65033: EMPTY
65034: LIST
65035: LIST
65036: PUSH
65037: LD_INT 2
65039: NEG
65040: PUSH
65041: LD_INT 1
65043: NEG
65044: PUSH
65045: EMPTY
65046: LIST
65047: LIST
65048: PUSH
65049: LD_INT 2
65051: NEG
65052: PUSH
65053: LD_INT 2
65055: NEG
65056: PUSH
65057: EMPTY
65058: LIST
65059: LIST
65060: PUSH
65061: LD_INT 2
65063: NEG
65064: PUSH
65065: LD_INT 3
65067: NEG
65068: PUSH
65069: EMPTY
65070: LIST
65071: LIST
65072: PUSH
65073: LD_INT 1
65075: NEG
65076: PUSH
65077: LD_INT 3
65079: NEG
65080: PUSH
65081: EMPTY
65082: LIST
65083: LIST
65084: PUSH
65085: LD_INT 3
65087: NEG
65088: PUSH
65089: LD_INT 1
65091: NEG
65092: PUSH
65093: EMPTY
65094: LIST
65095: LIST
65096: PUSH
65097: LD_INT 3
65099: NEG
65100: PUSH
65101: LD_INT 2
65103: NEG
65104: PUSH
65105: EMPTY
65106: LIST
65107: LIST
65108: PUSH
65109: EMPTY
65110: LIST
65111: LIST
65112: LIST
65113: LIST
65114: LIST
65115: LIST
65116: LIST
65117: LIST
65118: LIST
65119: LIST
65120: LIST
65121: LIST
65122: LIST
65123: LIST
65124: LIST
65125: LIST
65126: LIST
65127: LIST
65128: LIST
65129: LIST
65130: LIST
65131: LIST
65132: LIST
65133: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
65134: LD_ADDR_VAR 0 29
65138: PUSH
65139: LD_INT 0
65141: PUSH
65142: LD_INT 0
65144: PUSH
65145: EMPTY
65146: LIST
65147: LIST
65148: PUSH
65149: LD_INT 0
65151: PUSH
65152: LD_INT 1
65154: NEG
65155: PUSH
65156: EMPTY
65157: LIST
65158: LIST
65159: PUSH
65160: LD_INT 1
65162: PUSH
65163: LD_INT 0
65165: PUSH
65166: EMPTY
65167: LIST
65168: LIST
65169: PUSH
65170: LD_INT 1
65172: PUSH
65173: LD_INT 1
65175: PUSH
65176: EMPTY
65177: LIST
65178: LIST
65179: PUSH
65180: LD_INT 0
65182: PUSH
65183: LD_INT 1
65185: PUSH
65186: EMPTY
65187: LIST
65188: LIST
65189: PUSH
65190: LD_INT 1
65192: NEG
65193: PUSH
65194: LD_INT 0
65196: PUSH
65197: EMPTY
65198: LIST
65199: LIST
65200: PUSH
65201: LD_INT 1
65203: NEG
65204: PUSH
65205: LD_INT 1
65207: NEG
65208: PUSH
65209: EMPTY
65210: LIST
65211: LIST
65212: PUSH
65213: LD_INT 1
65215: NEG
65216: PUSH
65217: LD_INT 2
65219: NEG
65220: PUSH
65221: EMPTY
65222: LIST
65223: LIST
65224: PUSH
65225: LD_INT 0
65227: PUSH
65228: LD_INT 2
65230: NEG
65231: PUSH
65232: EMPTY
65233: LIST
65234: LIST
65235: PUSH
65236: LD_INT 1
65238: PUSH
65239: LD_INT 1
65241: NEG
65242: PUSH
65243: EMPTY
65244: LIST
65245: LIST
65246: PUSH
65247: LD_INT 2
65249: PUSH
65250: LD_INT 0
65252: PUSH
65253: EMPTY
65254: LIST
65255: LIST
65256: PUSH
65257: LD_INT 2
65259: PUSH
65260: LD_INT 1
65262: PUSH
65263: EMPTY
65264: LIST
65265: LIST
65266: PUSH
65267: LD_INT 1
65269: PUSH
65270: LD_INT 2
65272: PUSH
65273: EMPTY
65274: LIST
65275: LIST
65276: PUSH
65277: LD_INT 0
65279: PUSH
65280: LD_INT 2
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: LD_INT 1
65289: NEG
65290: PUSH
65291: LD_INT 1
65293: PUSH
65294: EMPTY
65295: LIST
65296: LIST
65297: PUSH
65298: LD_INT 2
65300: NEG
65301: PUSH
65302: LD_INT 1
65304: NEG
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: PUSH
65310: LD_INT 2
65312: NEG
65313: PUSH
65314: LD_INT 2
65316: NEG
65317: PUSH
65318: EMPTY
65319: LIST
65320: LIST
65321: PUSH
65322: LD_INT 2
65324: NEG
65325: PUSH
65326: LD_INT 3
65328: NEG
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: LD_INT 2
65336: PUSH
65337: LD_INT 1
65339: NEG
65340: PUSH
65341: EMPTY
65342: LIST
65343: LIST
65344: PUSH
65345: LD_INT 3
65347: PUSH
65348: LD_INT 1
65350: PUSH
65351: EMPTY
65352: LIST
65353: LIST
65354: PUSH
65355: LD_INT 1
65357: PUSH
65358: LD_INT 3
65360: PUSH
65361: EMPTY
65362: LIST
65363: LIST
65364: PUSH
65365: LD_INT 1
65367: NEG
65368: PUSH
65369: LD_INT 2
65371: PUSH
65372: EMPTY
65373: LIST
65374: LIST
65375: PUSH
65376: LD_INT 3
65378: NEG
65379: PUSH
65380: LD_INT 2
65382: NEG
65383: PUSH
65384: EMPTY
65385: LIST
65386: LIST
65387: PUSH
65388: EMPTY
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: LIST
65404: LIST
65405: LIST
65406: LIST
65407: LIST
65408: LIST
65409: LIST
65410: LIST
65411: LIST
65412: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
65413: LD_ADDR_VAR 0 30
65417: PUSH
65418: LD_INT 0
65420: PUSH
65421: LD_INT 0
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PUSH
65428: LD_INT 0
65430: PUSH
65431: LD_INT 1
65433: NEG
65434: PUSH
65435: EMPTY
65436: LIST
65437: LIST
65438: PUSH
65439: LD_INT 1
65441: PUSH
65442: LD_INT 0
65444: PUSH
65445: EMPTY
65446: LIST
65447: LIST
65448: PUSH
65449: LD_INT 1
65451: PUSH
65452: LD_INT 1
65454: PUSH
65455: EMPTY
65456: LIST
65457: LIST
65458: PUSH
65459: LD_INT 0
65461: PUSH
65462: LD_INT 1
65464: PUSH
65465: EMPTY
65466: LIST
65467: LIST
65468: PUSH
65469: LD_INT 1
65471: NEG
65472: PUSH
65473: LD_INT 0
65475: PUSH
65476: EMPTY
65477: LIST
65478: LIST
65479: PUSH
65480: LD_INT 1
65482: NEG
65483: PUSH
65484: LD_INT 1
65486: NEG
65487: PUSH
65488: EMPTY
65489: LIST
65490: LIST
65491: PUSH
65492: LD_INT 1
65494: NEG
65495: PUSH
65496: LD_INT 2
65498: NEG
65499: PUSH
65500: EMPTY
65501: LIST
65502: LIST
65503: PUSH
65504: LD_INT 0
65506: PUSH
65507: LD_INT 2
65509: NEG
65510: PUSH
65511: EMPTY
65512: LIST
65513: LIST
65514: PUSH
65515: LD_INT 1
65517: PUSH
65518: LD_INT 1
65520: NEG
65521: PUSH
65522: EMPTY
65523: LIST
65524: LIST
65525: PUSH
65526: LD_INT 2
65528: PUSH
65529: LD_INT 0
65531: PUSH
65532: EMPTY
65533: LIST
65534: LIST
65535: PUSH
65536: LD_INT 2
65538: PUSH
65539: LD_INT 1
65541: PUSH
65542: EMPTY
65543: LIST
65544: LIST
65545: PUSH
65546: LD_INT 2
65548: PUSH
65549: LD_INT 2
65551: PUSH
65552: EMPTY
65553: LIST
65554: LIST
65555: PUSH
65556: LD_INT 1
65558: PUSH
65559: LD_INT 2
65561: PUSH
65562: EMPTY
65563: LIST
65564: LIST
65565: PUSH
65566: LD_INT 1
65568: NEG
65569: PUSH
65570: LD_INT 1
65572: PUSH
65573: EMPTY
65574: LIST
65575: LIST
65576: PUSH
65577: LD_INT 2
65579: NEG
65580: PUSH
65581: LD_INT 0
65583: PUSH
65584: EMPTY
65585: LIST
65586: LIST
65587: PUSH
65588: LD_INT 2
65590: NEG
65591: PUSH
65592: LD_INT 1
65594: NEG
65595: PUSH
65596: EMPTY
65597: LIST
65598: LIST
65599: PUSH
65600: LD_INT 1
65602: NEG
65603: PUSH
65604: LD_INT 3
65606: NEG
65607: PUSH
65608: EMPTY
65609: LIST
65610: LIST
65611: PUSH
65612: LD_INT 1
65614: PUSH
65615: LD_INT 2
65617: NEG
65618: PUSH
65619: EMPTY
65620: LIST
65621: LIST
65622: PUSH
65623: LD_INT 3
65625: PUSH
65626: LD_INT 2
65628: PUSH
65629: EMPTY
65630: LIST
65631: LIST
65632: PUSH
65633: LD_INT 2
65635: PUSH
65636: LD_INT 3
65638: PUSH
65639: EMPTY
65640: LIST
65641: LIST
65642: PUSH
65643: LD_INT 2
65645: NEG
65646: PUSH
65647: LD_INT 1
65649: PUSH
65650: EMPTY
65651: LIST
65652: LIST
65653: PUSH
65654: LD_INT 3
65656: NEG
65657: PUSH
65658: LD_INT 1
65660: NEG
65661: PUSH
65662: EMPTY
65663: LIST
65664: LIST
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: LIST
65670: LIST
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: LIST
65678: LIST
65679: LIST
65680: LIST
65681: LIST
65682: LIST
65683: LIST
65684: LIST
65685: LIST
65686: LIST
65687: LIST
65688: LIST
65689: LIST
65690: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
65691: LD_ADDR_VAR 0 31
65695: PUSH
65696: LD_INT 0
65698: PUSH
65699: LD_INT 0
65701: PUSH
65702: EMPTY
65703: LIST
65704: LIST
65705: PUSH
65706: LD_INT 0
65708: PUSH
65709: LD_INT 1
65711: NEG
65712: PUSH
65713: EMPTY
65714: LIST
65715: LIST
65716: PUSH
65717: LD_INT 1
65719: PUSH
65720: LD_INT 0
65722: PUSH
65723: EMPTY
65724: LIST
65725: LIST
65726: PUSH
65727: LD_INT 1
65729: PUSH
65730: LD_INT 1
65732: PUSH
65733: EMPTY
65734: LIST
65735: LIST
65736: PUSH
65737: LD_INT 0
65739: PUSH
65740: LD_INT 1
65742: PUSH
65743: EMPTY
65744: LIST
65745: LIST
65746: PUSH
65747: LD_INT 1
65749: NEG
65750: PUSH
65751: LD_INT 0
65753: PUSH
65754: EMPTY
65755: LIST
65756: LIST
65757: PUSH
65758: LD_INT 1
65760: NEG
65761: PUSH
65762: LD_INT 1
65764: NEG
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: PUSH
65770: LD_INT 1
65772: NEG
65773: PUSH
65774: LD_INT 2
65776: NEG
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: PUSH
65782: LD_INT 1
65784: PUSH
65785: LD_INT 1
65787: NEG
65788: PUSH
65789: EMPTY
65790: LIST
65791: LIST
65792: PUSH
65793: LD_INT 2
65795: PUSH
65796: LD_INT 0
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: LD_INT 2
65805: PUSH
65806: LD_INT 1
65808: PUSH
65809: EMPTY
65810: LIST
65811: LIST
65812: PUSH
65813: LD_INT 2
65815: PUSH
65816: LD_INT 2
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: PUSH
65823: LD_INT 1
65825: PUSH
65826: LD_INT 2
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: PUSH
65833: LD_INT 0
65835: PUSH
65836: LD_INT 2
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PUSH
65843: LD_INT 1
65845: NEG
65846: PUSH
65847: LD_INT 1
65849: PUSH
65850: EMPTY
65851: LIST
65852: LIST
65853: PUSH
65854: LD_INT 2
65856: NEG
65857: PUSH
65858: LD_INT 1
65860: NEG
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: PUSH
65866: LD_INT 2
65868: NEG
65869: PUSH
65870: LD_INT 2
65872: NEG
65873: PUSH
65874: EMPTY
65875: LIST
65876: LIST
65877: PUSH
65878: LD_INT 2
65880: NEG
65881: PUSH
65882: LD_INT 3
65884: NEG
65885: PUSH
65886: EMPTY
65887: LIST
65888: LIST
65889: PUSH
65890: LD_INT 2
65892: PUSH
65893: LD_INT 1
65895: NEG
65896: PUSH
65897: EMPTY
65898: LIST
65899: LIST
65900: PUSH
65901: LD_INT 3
65903: PUSH
65904: LD_INT 1
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PUSH
65911: LD_INT 1
65913: PUSH
65914: LD_INT 3
65916: PUSH
65917: EMPTY
65918: LIST
65919: LIST
65920: PUSH
65921: LD_INT 1
65923: NEG
65924: PUSH
65925: LD_INT 2
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 3
65934: NEG
65935: PUSH
65936: LD_INT 2
65938: NEG
65939: PUSH
65940: EMPTY
65941: LIST
65942: LIST
65943: PUSH
65944: EMPTY
65945: LIST
65946: LIST
65947: LIST
65948: LIST
65949: LIST
65950: LIST
65951: LIST
65952: LIST
65953: LIST
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: LIST
65959: LIST
65960: LIST
65961: LIST
65962: LIST
65963: LIST
65964: LIST
65965: LIST
65966: LIST
65967: LIST
65968: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
65969: LD_ADDR_VAR 0 32
65973: PUSH
65974: LD_INT 0
65976: PUSH
65977: LD_INT 0
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 0
65986: PUSH
65987: LD_INT 1
65989: NEG
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: PUSH
65995: LD_INT 1
65997: PUSH
65998: LD_INT 0
66000: PUSH
66001: EMPTY
66002: LIST
66003: LIST
66004: PUSH
66005: LD_INT 1
66007: PUSH
66008: LD_INT 1
66010: PUSH
66011: EMPTY
66012: LIST
66013: LIST
66014: PUSH
66015: LD_INT 0
66017: PUSH
66018: LD_INT 1
66020: PUSH
66021: EMPTY
66022: LIST
66023: LIST
66024: PUSH
66025: LD_INT 1
66027: NEG
66028: PUSH
66029: LD_INT 0
66031: PUSH
66032: EMPTY
66033: LIST
66034: LIST
66035: PUSH
66036: LD_INT 1
66038: NEG
66039: PUSH
66040: LD_INT 1
66042: NEG
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: PUSH
66048: LD_INT 1
66050: NEG
66051: PUSH
66052: LD_INT 2
66054: NEG
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: PUSH
66060: LD_INT 0
66062: PUSH
66063: LD_INT 2
66065: NEG
66066: PUSH
66067: EMPTY
66068: LIST
66069: LIST
66070: PUSH
66071: LD_INT 1
66073: PUSH
66074: LD_INT 1
66076: NEG
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: LD_INT 2
66084: PUSH
66085: LD_INT 1
66087: PUSH
66088: EMPTY
66089: LIST
66090: LIST
66091: PUSH
66092: LD_INT 2
66094: PUSH
66095: LD_INT 2
66097: PUSH
66098: EMPTY
66099: LIST
66100: LIST
66101: PUSH
66102: LD_INT 1
66104: PUSH
66105: LD_INT 2
66107: PUSH
66108: EMPTY
66109: LIST
66110: LIST
66111: PUSH
66112: LD_INT 0
66114: PUSH
66115: LD_INT 2
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: PUSH
66122: LD_INT 1
66124: NEG
66125: PUSH
66126: LD_INT 1
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PUSH
66133: LD_INT 2
66135: NEG
66136: PUSH
66137: LD_INT 0
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PUSH
66144: LD_INT 2
66146: NEG
66147: PUSH
66148: LD_INT 1
66150: NEG
66151: PUSH
66152: EMPTY
66153: LIST
66154: LIST
66155: PUSH
66156: LD_INT 1
66158: NEG
66159: PUSH
66160: LD_INT 3
66162: NEG
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: PUSH
66168: LD_INT 1
66170: PUSH
66171: LD_INT 2
66173: NEG
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: PUSH
66179: LD_INT 3
66181: PUSH
66182: LD_INT 2
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PUSH
66189: LD_INT 2
66191: PUSH
66192: LD_INT 3
66194: PUSH
66195: EMPTY
66196: LIST
66197: LIST
66198: PUSH
66199: LD_INT 2
66201: NEG
66202: PUSH
66203: LD_INT 1
66205: PUSH
66206: EMPTY
66207: LIST
66208: LIST
66209: PUSH
66210: LD_INT 3
66212: NEG
66213: PUSH
66214: LD_INT 1
66216: NEG
66217: PUSH
66218: EMPTY
66219: LIST
66220: LIST
66221: PUSH
66222: EMPTY
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: LIST
66235: LIST
66236: LIST
66237: LIST
66238: LIST
66239: LIST
66240: LIST
66241: LIST
66242: LIST
66243: LIST
66244: LIST
66245: LIST
66246: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66247: LD_ADDR_VAR 0 33
66251: PUSH
66252: LD_INT 0
66254: PUSH
66255: LD_INT 0
66257: PUSH
66258: EMPTY
66259: LIST
66260: LIST
66261: PUSH
66262: LD_INT 0
66264: PUSH
66265: LD_INT 1
66267: NEG
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PUSH
66273: LD_INT 1
66275: PUSH
66276: LD_INT 0
66278: PUSH
66279: EMPTY
66280: LIST
66281: LIST
66282: PUSH
66283: LD_INT 1
66285: PUSH
66286: LD_INT 1
66288: PUSH
66289: EMPTY
66290: LIST
66291: LIST
66292: PUSH
66293: LD_INT 0
66295: PUSH
66296: LD_INT 1
66298: PUSH
66299: EMPTY
66300: LIST
66301: LIST
66302: PUSH
66303: LD_INT 1
66305: NEG
66306: PUSH
66307: LD_INT 0
66309: PUSH
66310: EMPTY
66311: LIST
66312: LIST
66313: PUSH
66314: LD_INT 1
66316: NEG
66317: PUSH
66318: LD_INT 1
66320: NEG
66321: PUSH
66322: EMPTY
66323: LIST
66324: LIST
66325: PUSH
66326: LD_INT 1
66328: NEG
66329: PUSH
66330: LD_INT 2
66332: NEG
66333: PUSH
66334: EMPTY
66335: LIST
66336: LIST
66337: PUSH
66338: LD_INT 1
66340: PUSH
66341: LD_INT 1
66343: NEG
66344: PUSH
66345: EMPTY
66346: LIST
66347: LIST
66348: PUSH
66349: LD_INT 2
66351: PUSH
66352: LD_INT 0
66354: PUSH
66355: EMPTY
66356: LIST
66357: LIST
66358: PUSH
66359: LD_INT 2
66361: PUSH
66362: LD_INT 1
66364: PUSH
66365: EMPTY
66366: LIST
66367: LIST
66368: PUSH
66369: LD_INT 1
66371: PUSH
66372: LD_INT 2
66374: PUSH
66375: EMPTY
66376: LIST
66377: LIST
66378: PUSH
66379: LD_INT 0
66381: PUSH
66382: LD_INT 2
66384: PUSH
66385: EMPTY
66386: LIST
66387: LIST
66388: PUSH
66389: LD_INT 1
66391: NEG
66392: PUSH
66393: LD_INT 1
66395: PUSH
66396: EMPTY
66397: LIST
66398: LIST
66399: PUSH
66400: LD_INT 2
66402: NEG
66403: PUSH
66404: LD_INT 0
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 2
66413: NEG
66414: PUSH
66415: LD_INT 1
66417: NEG
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: PUSH
66423: LD_INT 2
66425: NEG
66426: PUSH
66427: LD_INT 2
66429: NEG
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: PUSH
66435: LD_INT 2
66437: NEG
66438: PUSH
66439: LD_INT 3
66441: NEG
66442: PUSH
66443: EMPTY
66444: LIST
66445: LIST
66446: PUSH
66447: LD_INT 2
66449: PUSH
66450: LD_INT 1
66452: NEG
66453: PUSH
66454: EMPTY
66455: LIST
66456: LIST
66457: PUSH
66458: LD_INT 3
66460: PUSH
66461: LD_INT 1
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: PUSH
66468: LD_INT 1
66470: PUSH
66471: LD_INT 3
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 1
66480: NEG
66481: PUSH
66482: LD_INT 2
66484: PUSH
66485: EMPTY
66486: LIST
66487: LIST
66488: PUSH
66489: LD_INT 3
66491: NEG
66492: PUSH
66493: LD_INT 2
66495: NEG
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: LIST
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: LIST
66520: LIST
66521: LIST
66522: LIST
66523: LIST
66524: LIST
66525: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66526: LD_ADDR_VAR 0 34
66530: PUSH
66531: LD_INT 0
66533: PUSH
66534: LD_INT 0
66536: PUSH
66537: EMPTY
66538: LIST
66539: LIST
66540: PUSH
66541: LD_INT 0
66543: PUSH
66544: LD_INT 1
66546: NEG
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: PUSH
66552: LD_INT 1
66554: PUSH
66555: LD_INT 0
66557: PUSH
66558: EMPTY
66559: LIST
66560: LIST
66561: PUSH
66562: LD_INT 1
66564: PUSH
66565: LD_INT 1
66567: PUSH
66568: EMPTY
66569: LIST
66570: LIST
66571: PUSH
66572: LD_INT 0
66574: PUSH
66575: LD_INT 1
66577: PUSH
66578: EMPTY
66579: LIST
66580: LIST
66581: PUSH
66582: LD_INT 1
66584: NEG
66585: PUSH
66586: LD_INT 0
66588: PUSH
66589: EMPTY
66590: LIST
66591: LIST
66592: PUSH
66593: LD_INT 1
66595: NEG
66596: PUSH
66597: LD_INT 1
66599: NEG
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: PUSH
66605: LD_INT 1
66607: NEG
66608: PUSH
66609: LD_INT 2
66611: NEG
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PUSH
66617: LD_INT 0
66619: PUSH
66620: LD_INT 2
66622: NEG
66623: PUSH
66624: EMPTY
66625: LIST
66626: LIST
66627: PUSH
66628: LD_INT 1
66630: PUSH
66631: LD_INT 1
66633: NEG
66634: PUSH
66635: EMPTY
66636: LIST
66637: LIST
66638: PUSH
66639: LD_INT 2
66641: PUSH
66642: LD_INT 1
66644: PUSH
66645: EMPTY
66646: LIST
66647: LIST
66648: PUSH
66649: LD_INT 2
66651: PUSH
66652: LD_INT 2
66654: PUSH
66655: EMPTY
66656: LIST
66657: LIST
66658: PUSH
66659: LD_INT 1
66661: PUSH
66662: LD_INT 2
66664: PUSH
66665: EMPTY
66666: LIST
66667: LIST
66668: PUSH
66669: LD_INT 1
66671: NEG
66672: PUSH
66673: LD_INT 1
66675: PUSH
66676: EMPTY
66677: LIST
66678: LIST
66679: PUSH
66680: LD_INT 2
66682: NEG
66683: PUSH
66684: LD_INT 0
66686: PUSH
66687: EMPTY
66688: LIST
66689: LIST
66690: PUSH
66691: LD_INT 2
66693: NEG
66694: PUSH
66695: LD_INT 1
66697: NEG
66698: PUSH
66699: EMPTY
66700: LIST
66701: LIST
66702: PUSH
66703: LD_INT 2
66705: NEG
66706: PUSH
66707: LD_INT 2
66709: NEG
66710: PUSH
66711: EMPTY
66712: LIST
66713: LIST
66714: PUSH
66715: LD_INT 1
66717: NEG
66718: PUSH
66719: LD_INT 3
66721: NEG
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: PUSH
66727: LD_INT 1
66729: PUSH
66730: LD_INT 2
66732: NEG
66733: PUSH
66734: EMPTY
66735: LIST
66736: LIST
66737: PUSH
66738: LD_INT 3
66740: PUSH
66741: LD_INT 2
66743: PUSH
66744: EMPTY
66745: LIST
66746: LIST
66747: PUSH
66748: LD_INT 2
66750: PUSH
66751: LD_INT 3
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PUSH
66758: LD_INT 2
66760: NEG
66761: PUSH
66762: LD_INT 1
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: PUSH
66769: LD_INT 3
66771: NEG
66772: PUSH
66773: LD_INT 1
66775: NEG
66776: PUSH
66777: EMPTY
66778: LIST
66779: LIST
66780: PUSH
66781: EMPTY
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: LIST
66793: LIST
66794: LIST
66795: LIST
66796: LIST
66797: LIST
66798: LIST
66799: LIST
66800: LIST
66801: LIST
66802: LIST
66803: LIST
66804: LIST
66805: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
66806: LD_ADDR_VAR 0 35
66810: PUSH
66811: LD_INT 0
66813: PUSH
66814: LD_INT 0
66816: PUSH
66817: EMPTY
66818: LIST
66819: LIST
66820: PUSH
66821: LD_INT 0
66823: PUSH
66824: LD_INT 1
66826: NEG
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: LD_INT 1
66834: PUSH
66835: LD_INT 0
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: PUSH
66842: LD_INT 1
66844: PUSH
66845: LD_INT 1
66847: PUSH
66848: EMPTY
66849: LIST
66850: LIST
66851: PUSH
66852: LD_INT 0
66854: PUSH
66855: LD_INT 1
66857: PUSH
66858: EMPTY
66859: LIST
66860: LIST
66861: PUSH
66862: LD_INT 1
66864: NEG
66865: PUSH
66866: LD_INT 0
66868: PUSH
66869: EMPTY
66870: LIST
66871: LIST
66872: PUSH
66873: LD_INT 1
66875: NEG
66876: PUSH
66877: LD_INT 1
66879: NEG
66880: PUSH
66881: EMPTY
66882: LIST
66883: LIST
66884: PUSH
66885: LD_INT 2
66887: PUSH
66888: LD_INT 1
66890: PUSH
66891: EMPTY
66892: LIST
66893: LIST
66894: PUSH
66895: LD_INT 2
66897: NEG
66898: PUSH
66899: LD_INT 1
66901: NEG
66902: PUSH
66903: EMPTY
66904: LIST
66905: LIST
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: LIST
66911: LIST
66912: LIST
66913: LIST
66914: LIST
66915: LIST
66916: LIST
66917: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
66918: LD_ADDR_VAR 0 36
66922: PUSH
66923: LD_INT 0
66925: PUSH
66926: LD_INT 0
66928: PUSH
66929: EMPTY
66930: LIST
66931: LIST
66932: PUSH
66933: LD_INT 0
66935: PUSH
66936: LD_INT 1
66938: NEG
66939: PUSH
66940: EMPTY
66941: LIST
66942: LIST
66943: PUSH
66944: LD_INT 1
66946: PUSH
66947: LD_INT 0
66949: PUSH
66950: EMPTY
66951: LIST
66952: LIST
66953: PUSH
66954: LD_INT 1
66956: PUSH
66957: LD_INT 1
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PUSH
66964: LD_INT 0
66966: PUSH
66967: LD_INT 1
66969: PUSH
66970: EMPTY
66971: LIST
66972: LIST
66973: PUSH
66974: LD_INT 1
66976: NEG
66977: PUSH
66978: LD_INT 0
66980: PUSH
66981: EMPTY
66982: LIST
66983: LIST
66984: PUSH
66985: LD_INT 1
66987: NEG
66988: PUSH
66989: LD_INT 1
66991: NEG
66992: PUSH
66993: EMPTY
66994: LIST
66995: LIST
66996: PUSH
66997: LD_INT 1
66999: NEG
67000: PUSH
67001: LD_INT 2
67003: NEG
67004: PUSH
67005: EMPTY
67006: LIST
67007: LIST
67008: PUSH
67009: LD_INT 1
67011: PUSH
67012: LD_INT 2
67014: PUSH
67015: EMPTY
67016: LIST
67017: LIST
67018: PUSH
67019: EMPTY
67020: LIST
67021: LIST
67022: LIST
67023: LIST
67024: LIST
67025: LIST
67026: LIST
67027: LIST
67028: LIST
67029: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
67030: LD_ADDR_VAR 0 37
67034: PUSH
67035: LD_INT 0
67037: PUSH
67038: LD_INT 0
67040: PUSH
67041: EMPTY
67042: LIST
67043: LIST
67044: PUSH
67045: LD_INT 0
67047: PUSH
67048: LD_INT 1
67050: NEG
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: PUSH
67056: LD_INT 1
67058: PUSH
67059: LD_INT 0
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PUSH
67066: LD_INT 1
67068: PUSH
67069: LD_INT 1
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 0
67078: PUSH
67079: LD_INT 1
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: LD_INT 1
67088: NEG
67089: PUSH
67090: LD_INT 0
67092: PUSH
67093: EMPTY
67094: LIST
67095: LIST
67096: PUSH
67097: LD_INT 1
67099: NEG
67100: PUSH
67101: LD_INT 1
67103: NEG
67104: PUSH
67105: EMPTY
67106: LIST
67107: LIST
67108: PUSH
67109: LD_INT 1
67111: PUSH
67112: LD_INT 1
67114: NEG
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: LD_INT 1
67122: NEG
67123: PUSH
67124: LD_INT 1
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: PUSH
67131: EMPTY
67132: LIST
67133: LIST
67134: LIST
67135: LIST
67136: LIST
67137: LIST
67138: LIST
67139: LIST
67140: LIST
67141: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
67142: LD_ADDR_VAR 0 38
67146: PUSH
67147: LD_INT 0
67149: PUSH
67150: LD_INT 0
67152: PUSH
67153: EMPTY
67154: LIST
67155: LIST
67156: PUSH
67157: LD_INT 0
67159: PUSH
67160: LD_INT 1
67162: NEG
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PUSH
67168: LD_INT 1
67170: PUSH
67171: LD_INT 0
67173: PUSH
67174: EMPTY
67175: LIST
67176: LIST
67177: PUSH
67178: LD_INT 1
67180: PUSH
67181: LD_INT 1
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: PUSH
67188: LD_INT 0
67190: PUSH
67191: LD_INT 1
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: LD_INT 1
67200: NEG
67201: PUSH
67202: LD_INT 0
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: PUSH
67209: LD_INT 1
67211: NEG
67212: PUSH
67213: LD_INT 1
67215: NEG
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 2
67223: PUSH
67224: LD_INT 1
67226: PUSH
67227: EMPTY
67228: LIST
67229: LIST
67230: PUSH
67231: LD_INT 2
67233: NEG
67234: PUSH
67235: LD_INT 1
67237: NEG
67238: PUSH
67239: EMPTY
67240: LIST
67241: LIST
67242: PUSH
67243: EMPTY
67244: LIST
67245: LIST
67246: LIST
67247: LIST
67248: LIST
67249: LIST
67250: LIST
67251: LIST
67252: LIST
67253: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
67254: LD_ADDR_VAR 0 39
67258: PUSH
67259: LD_INT 0
67261: PUSH
67262: LD_INT 0
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: LD_INT 0
67271: PUSH
67272: LD_INT 1
67274: NEG
67275: PUSH
67276: EMPTY
67277: LIST
67278: LIST
67279: PUSH
67280: LD_INT 1
67282: PUSH
67283: LD_INT 0
67285: PUSH
67286: EMPTY
67287: LIST
67288: LIST
67289: PUSH
67290: LD_INT 1
67292: PUSH
67293: LD_INT 1
67295: PUSH
67296: EMPTY
67297: LIST
67298: LIST
67299: PUSH
67300: LD_INT 0
67302: PUSH
67303: LD_INT 1
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: PUSH
67310: LD_INT 1
67312: NEG
67313: PUSH
67314: LD_INT 0
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: LD_INT 1
67323: NEG
67324: PUSH
67325: LD_INT 1
67327: NEG
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: LD_INT 1
67335: NEG
67336: PUSH
67337: LD_INT 2
67339: NEG
67340: PUSH
67341: EMPTY
67342: LIST
67343: LIST
67344: PUSH
67345: LD_INT 1
67347: PUSH
67348: LD_INT 2
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: LIST
67359: LIST
67360: LIST
67361: LIST
67362: LIST
67363: LIST
67364: LIST
67365: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
67366: LD_ADDR_VAR 0 40
67370: PUSH
67371: LD_INT 0
67373: PUSH
67374: LD_INT 0
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: PUSH
67381: LD_INT 0
67383: PUSH
67384: LD_INT 1
67386: NEG
67387: PUSH
67388: EMPTY
67389: LIST
67390: LIST
67391: PUSH
67392: LD_INT 1
67394: PUSH
67395: LD_INT 0
67397: PUSH
67398: EMPTY
67399: LIST
67400: LIST
67401: PUSH
67402: LD_INT 1
67404: PUSH
67405: LD_INT 1
67407: PUSH
67408: EMPTY
67409: LIST
67410: LIST
67411: PUSH
67412: LD_INT 0
67414: PUSH
67415: LD_INT 1
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PUSH
67422: LD_INT 1
67424: NEG
67425: PUSH
67426: LD_INT 0
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: PUSH
67433: LD_INT 1
67435: NEG
67436: PUSH
67437: LD_INT 1
67439: NEG
67440: PUSH
67441: EMPTY
67442: LIST
67443: LIST
67444: PUSH
67445: LD_INT 1
67447: PUSH
67448: LD_INT 1
67450: NEG
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: PUSH
67456: LD_INT 1
67458: NEG
67459: PUSH
67460: LD_INT 1
67462: PUSH
67463: EMPTY
67464: LIST
67465: LIST
67466: PUSH
67467: EMPTY
67468: LIST
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67478: LD_ADDR_VAR 0 41
67482: PUSH
67483: LD_INT 0
67485: PUSH
67486: LD_INT 0
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: PUSH
67493: LD_INT 0
67495: PUSH
67496: LD_INT 1
67498: NEG
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: PUSH
67504: LD_INT 1
67506: PUSH
67507: LD_INT 0
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PUSH
67514: LD_INT 1
67516: PUSH
67517: LD_INT 1
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: PUSH
67524: LD_INT 0
67526: PUSH
67527: LD_INT 1
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 1
67536: NEG
67537: PUSH
67538: LD_INT 0
67540: PUSH
67541: EMPTY
67542: LIST
67543: LIST
67544: PUSH
67545: LD_INT 1
67547: NEG
67548: PUSH
67549: LD_INT 1
67551: NEG
67552: PUSH
67553: EMPTY
67554: LIST
67555: LIST
67556: PUSH
67557: LD_INT 1
67559: NEG
67560: PUSH
67561: LD_INT 2
67563: NEG
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: PUSH
67569: LD_INT 1
67571: PUSH
67572: LD_INT 1
67574: NEG
67575: PUSH
67576: EMPTY
67577: LIST
67578: LIST
67579: PUSH
67580: LD_INT 2
67582: PUSH
67583: LD_INT 0
67585: PUSH
67586: EMPTY
67587: LIST
67588: LIST
67589: PUSH
67590: LD_INT 2
67592: PUSH
67593: LD_INT 1
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 2
67602: PUSH
67603: LD_INT 2
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: PUSH
67610: LD_INT 1
67612: PUSH
67613: LD_INT 2
67615: PUSH
67616: EMPTY
67617: LIST
67618: LIST
67619: PUSH
67620: LD_INT 1
67622: NEG
67623: PUSH
67624: LD_INT 1
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 2
67633: NEG
67634: PUSH
67635: LD_INT 0
67637: PUSH
67638: EMPTY
67639: LIST
67640: LIST
67641: PUSH
67642: LD_INT 2
67644: NEG
67645: PUSH
67646: LD_INT 1
67648: NEG
67649: PUSH
67650: EMPTY
67651: LIST
67652: LIST
67653: PUSH
67654: LD_INT 2
67656: NEG
67657: PUSH
67658: LD_INT 2
67660: NEG
67661: PUSH
67662: EMPTY
67663: LIST
67664: LIST
67665: PUSH
67666: LD_INT 2
67668: NEG
67669: PUSH
67670: LD_INT 3
67672: NEG
67673: PUSH
67674: EMPTY
67675: LIST
67676: LIST
67677: PUSH
67678: LD_INT 2
67680: PUSH
67681: LD_INT 1
67683: NEG
67684: PUSH
67685: EMPTY
67686: LIST
67687: LIST
67688: PUSH
67689: LD_INT 3
67691: PUSH
67692: LD_INT 0
67694: PUSH
67695: EMPTY
67696: LIST
67697: LIST
67698: PUSH
67699: LD_INT 3
67701: PUSH
67702: LD_INT 1
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: PUSH
67709: LD_INT 3
67711: PUSH
67712: LD_INT 2
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: PUSH
67719: LD_INT 3
67721: PUSH
67722: LD_INT 3
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PUSH
67729: LD_INT 2
67731: PUSH
67732: LD_INT 3
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PUSH
67739: LD_INT 2
67741: NEG
67742: PUSH
67743: LD_INT 1
67745: PUSH
67746: EMPTY
67747: LIST
67748: LIST
67749: PUSH
67750: LD_INT 3
67752: NEG
67753: PUSH
67754: LD_INT 0
67756: PUSH
67757: EMPTY
67758: LIST
67759: LIST
67760: PUSH
67761: LD_INT 3
67763: NEG
67764: PUSH
67765: LD_INT 1
67767: NEG
67768: PUSH
67769: EMPTY
67770: LIST
67771: LIST
67772: PUSH
67773: LD_INT 3
67775: NEG
67776: PUSH
67777: LD_INT 2
67779: NEG
67780: PUSH
67781: EMPTY
67782: LIST
67783: LIST
67784: PUSH
67785: LD_INT 3
67787: NEG
67788: PUSH
67789: LD_INT 3
67791: NEG
67792: PUSH
67793: EMPTY
67794: LIST
67795: LIST
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: LIST
67801: LIST
67802: LIST
67803: LIST
67804: LIST
67805: LIST
67806: LIST
67807: LIST
67808: LIST
67809: LIST
67810: LIST
67811: LIST
67812: LIST
67813: LIST
67814: LIST
67815: LIST
67816: LIST
67817: LIST
67818: LIST
67819: LIST
67820: LIST
67821: LIST
67822: LIST
67823: LIST
67824: LIST
67825: LIST
67826: LIST
67827: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67828: LD_ADDR_VAR 0 42
67832: PUSH
67833: LD_INT 0
67835: PUSH
67836: LD_INT 0
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: PUSH
67843: LD_INT 0
67845: PUSH
67846: LD_INT 1
67848: NEG
67849: PUSH
67850: EMPTY
67851: LIST
67852: LIST
67853: PUSH
67854: LD_INT 1
67856: PUSH
67857: LD_INT 0
67859: PUSH
67860: EMPTY
67861: LIST
67862: LIST
67863: PUSH
67864: LD_INT 1
67866: PUSH
67867: LD_INT 1
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: PUSH
67874: LD_INT 0
67876: PUSH
67877: LD_INT 1
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 1
67886: NEG
67887: PUSH
67888: LD_INT 0
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: LD_INT 1
67897: NEG
67898: PUSH
67899: LD_INT 1
67901: NEG
67902: PUSH
67903: EMPTY
67904: LIST
67905: LIST
67906: PUSH
67907: LD_INT 1
67909: NEG
67910: PUSH
67911: LD_INT 2
67913: NEG
67914: PUSH
67915: EMPTY
67916: LIST
67917: LIST
67918: PUSH
67919: LD_INT 0
67921: PUSH
67922: LD_INT 2
67924: NEG
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: PUSH
67930: LD_INT 1
67932: PUSH
67933: LD_INT 1
67935: NEG
67936: PUSH
67937: EMPTY
67938: LIST
67939: LIST
67940: PUSH
67941: LD_INT 2
67943: PUSH
67944: LD_INT 1
67946: PUSH
67947: EMPTY
67948: LIST
67949: LIST
67950: PUSH
67951: LD_INT 2
67953: PUSH
67954: LD_INT 2
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 1
67963: PUSH
67964: LD_INT 2
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 0
67973: PUSH
67974: LD_INT 2
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: PUSH
67981: LD_INT 1
67983: NEG
67984: PUSH
67985: LD_INT 1
67987: PUSH
67988: EMPTY
67989: LIST
67990: LIST
67991: PUSH
67992: LD_INT 2
67994: NEG
67995: PUSH
67996: LD_INT 1
67998: NEG
67999: PUSH
68000: EMPTY
68001: LIST
68002: LIST
68003: PUSH
68004: LD_INT 2
68006: NEG
68007: PUSH
68008: LD_INT 2
68010: NEG
68011: PUSH
68012: EMPTY
68013: LIST
68014: LIST
68015: PUSH
68016: LD_INT 2
68018: NEG
68019: PUSH
68020: LD_INT 3
68022: NEG
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: PUSH
68028: LD_INT 1
68030: NEG
68031: PUSH
68032: LD_INT 3
68034: NEG
68035: PUSH
68036: EMPTY
68037: LIST
68038: LIST
68039: PUSH
68040: LD_INT 0
68042: PUSH
68043: LD_INT 3
68045: NEG
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: PUSH
68051: LD_INT 1
68053: PUSH
68054: LD_INT 2
68056: NEG
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: PUSH
68062: LD_INT 3
68064: PUSH
68065: LD_INT 2
68067: PUSH
68068: EMPTY
68069: LIST
68070: LIST
68071: PUSH
68072: LD_INT 3
68074: PUSH
68075: LD_INT 3
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: PUSH
68082: LD_INT 2
68084: PUSH
68085: LD_INT 3
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PUSH
68092: LD_INT 1
68094: PUSH
68095: LD_INT 3
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: LD_INT 0
68104: PUSH
68105: LD_INT 3
68107: PUSH
68108: EMPTY
68109: LIST
68110: LIST
68111: PUSH
68112: LD_INT 1
68114: NEG
68115: PUSH
68116: LD_INT 2
68118: PUSH
68119: EMPTY
68120: LIST
68121: LIST
68122: PUSH
68123: LD_INT 3
68125: NEG
68126: PUSH
68127: LD_INT 2
68129: NEG
68130: PUSH
68131: EMPTY
68132: LIST
68133: LIST
68134: PUSH
68135: LD_INT 3
68137: NEG
68138: PUSH
68139: LD_INT 3
68141: NEG
68142: PUSH
68143: EMPTY
68144: LIST
68145: LIST
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: LIST
68162: LIST
68163: LIST
68164: LIST
68165: LIST
68166: LIST
68167: LIST
68168: LIST
68169: LIST
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: LIST
68175: LIST
68176: LIST
68177: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68178: LD_ADDR_VAR 0 43
68182: PUSH
68183: LD_INT 0
68185: PUSH
68186: LD_INT 0
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PUSH
68193: LD_INT 0
68195: PUSH
68196: LD_INT 1
68198: NEG
68199: PUSH
68200: EMPTY
68201: LIST
68202: LIST
68203: PUSH
68204: LD_INT 1
68206: PUSH
68207: LD_INT 0
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: PUSH
68214: LD_INT 1
68216: PUSH
68217: LD_INT 1
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: PUSH
68224: LD_INT 0
68226: PUSH
68227: LD_INT 1
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: LD_INT 1
68236: NEG
68237: PUSH
68238: LD_INT 0
68240: PUSH
68241: EMPTY
68242: LIST
68243: LIST
68244: PUSH
68245: LD_INT 1
68247: NEG
68248: PUSH
68249: LD_INT 1
68251: NEG
68252: PUSH
68253: EMPTY
68254: LIST
68255: LIST
68256: PUSH
68257: LD_INT 1
68259: NEG
68260: PUSH
68261: LD_INT 2
68263: NEG
68264: PUSH
68265: EMPTY
68266: LIST
68267: LIST
68268: PUSH
68269: LD_INT 0
68271: PUSH
68272: LD_INT 2
68274: NEG
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: PUSH
68280: LD_INT 1
68282: PUSH
68283: LD_INT 1
68285: NEG
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: PUSH
68291: LD_INT 2
68293: PUSH
68294: LD_INT 0
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: LD_INT 2
68303: PUSH
68304: LD_INT 1
68306: PUSH
68307: EMPTY
68308: LIST
68309: LIST
68310: PUSH
68311: LD_INT 1
68313: PUSH
68314: LD_INT 2
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: PUSH
68321: LD_INT 0
68323: PUSH
68324: LD_INT 2
68326: PUSH
68327: EMPTY
68328: LIST
68329: LIST
68330: PUSH
68331: LD_INT 1
68333: NEG
68334: PUSH
68335: LD_INT 1
68337: PUSH
68338: EMPTY
68339: LIST
68340: LIST
68341: PUSH
68342: LD_INT 2
68344: NEG
68345: PUSH
68346: LD_INT 0
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 2
68355: NEG
68356: PUSH
68357: LD_INT 1
68359: NEG
68360: PUSH
68361: EMPTY
68362: LIST
68363: LIST
68364: PUSH
68365: LD_INT 1
68367: NEG
68368: PUSH
68369: LD_INT 3
68371: NEG
68372: PUSH
68373: EMPTY
68374: LIST
68375: LIST
68376: PUSH
68377: LD_INT 0
68379: PUSH
68380: LD_INT 3
68382: NEG
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 1
68390: PUSH
68391: LD_INT 2
68393: NEG
68394: PUSH
68395: EMPTY
68396: LIST
68397: LIST
68398: PUSH
68399: LD_INT 2
68401: PUSH
68402: LD_INT 1
68404: NEG
68405: PUSH
68406: EMPTY
68407: LIST
68408: LIST
68409: PUSH
68410: LD_INT 3
68412: PUSH
68413: LD_INT 0
68415: PUSH
68416: EMPTY
68417: LIST
68418: LIST
68419: PUSH
68420: LD_INT 3
68422: PUSH
68423: LD_INT 1
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 1
68432: PUSH
68433: LD_INT 3
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: PUSH
68440: LD_INT 0
68442: PUSH
68443: LD_INT 3
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: PUSH
68450: LD_INT 1
68452: NEG
68453: PUSH
68454: LD_INT 2
68456: PUSH
68457: EMPTY
68458: LIST
68459: LIST
68460: PUSH
68461: LD_INT 2
68463: NEG
68464: PUSH
68465: LD_INT 1
68467: PUSH
68468: EMPTY
68469: LIST
68470: LIST
68471: PUSH
68472: LD_INT 3
68474: NEG
68475: PUSH
68476: LD_INT 0
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PUSH
68483: LD_INT 3
68485: NEG
68486: PUSH
68487: LD_INT 1
68489: NEG
68490: PUSH
68491: EMPTY
68492: LIST
68493: LIST
68494: PUSH
68495: EMPTY
68496: LIST
68497: LIST
68498: LIST
68499: LIST
68500: LIST
68501: LIST
68502: LIST
68503: LIST
68504: LIST
68505: LIST
68506: LIST
68507: LIST
68508: LIST
68509: LIST
68510: LIST
68511: LIST
68512: LIST
68513: LIST
68514: LIST
68515: LIST
68516: LIST
68517: LIST
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68526: LD_ADDR_VAR 0 44
68530: PUSH
68531: LD_INT 0
68533: PUSH
68534: LD_INT 0
68536: PUSH
68537: EMPTY
68538: LIST
68539: LIST
68540: PUSH
68541: LD_INT 0
68543: PUSH
68544: LD_INT 1
68546: NEG
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: LD_INT 1
68554: PUSH
68555: LD_INT 0
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: PUSH
68562: LD_INT 1
68564: PUSH
68565: LD_INT 1
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: PUSH
68572: LD_INT 0
68574: PUSH
68575: LD_INT 1
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: PUSH
68582: LD_INT 1
68584: NEG
68585: PUSH
68586: LD_INT 0
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PUSH
68593: LD_INT 1
68595: NEG
68596: PUSH
68597: LD_INT 1
68599: NEG
68600: PUSH
68601: EMPTY
68602: LIST
68603: LIST
68604: PUSH
68605: LD_INT 1
68607: NEG
68608: PUSH
68609: LD_INT 2
68611: NEG
68612: PUSH
68613: EMPTY
68614: LIST
68615: LIST
68616: PUSH
68617: LD_INT 1
68619: PUSH
68620: LD_INT 1
68622: NEG
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: PUSH
68628: LD_INT 2
68630: PUSH
68631: LD_INT 0
68633: PUSH
68634: EMPTY
68635: LIST
68636: LIST
68637: PUSH
68638: LD_INT 2
68640: PUSH
68641: LD_INT 1
68643: PUSH
68644: EMPTY
68645: LIST
68646: LIST
68647: PUSH
68648: LD_INT 2
68650: PUSH
68651: LD_INT 2
68653: PUSH
68654: EMPTY
68655: LIST
68656: LIST
68657: PUSH
68658: LD_INT 1
68660: PUSH
68661: LD_INT 2
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: PUSH
68668: LD_INT 1
68670: NEG
68671: PUSH
68672: LD_INT 1
68674: PUSH
68675: EMPTY
68676: LIST
68677: LIST
68678: PUSH
68679: LD_INT 2
68681: NEG
68682: PUSH
68683: LD_INT 0
68685: PUSH
68686: EMPTY
68687: LIST
68688: LIST
68689: PUSH
68690: LD_INT 2
68692: NEG
68693: PUSH
68694: LD_INT 1
68696: NEG
68697: PUSH
68698: EMPTY
68699: LIST
68700: LIST
68701: PUSH
68702: LD_INT 2
68704: NEG
68705: PUSH
68706: LD_INT 2
68708: NEG
68709: PUSH
68710: EMPTY
68711: LIST
68712: LIST
68713: PUSH
68714: LD_INT 2
68716: NEG
68717: PUSH
68718: LD_INT 3
68720: NEG
68721: PUSH
68722: EMPTY
68723: LIST
68724: LIST
68725: PUSH
68726: LD_INT 2
68728: PUSH
68729: LD_INT 1
68731: NEG
68732: PUSH
68733: EMPTY
68734: LIST
68735: LIST
68736: PUSH
68737: LD_INT 3
68739: PUSH
68740: LD_INT 0
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: PUSH
68747: LD_INT 3
68749: PUSH
68750: LD_INT 1
68752: PUSH
68753: EMPTY
68754: LIST
68755: LIST
68756: PUSH
68757: LD_INT 3
68759: PUSH
68760: LD_INT 2
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: LD_INT 3
68769: PUSH
68770: LD_INT 3
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 2
68779: PUSH
68780: LD_INT 3
68782: PUSH
68783: EMPTY
68784: LIST
68785: LIST
68786: PUSH
68787: LD_INT 2
68789: NEG
68790: PUSH
68791: LD_INT 1
68793: PUSH
68794: EMPTY
68795: LIST
68796: LIST
68797: PUSH
68798: LD_INT 3
68800: NEG
68801: PUSH
68802: LD_INT 0
68804: PUSH
68805: EMPTY
68806: LIST
68807: LIST
68808: PUSH
68809: LD_INT 3
68811: NEG
68812: PUSH
68813: LD_INT 1
68815: NEG
68816: PUSH
68817: EMPTY
68818: LIST
68819: LIST
68820: PUSH
68821: LD_INT 3
68823: NEG
68824: PUSH
68825: LD_INT 2
68827: NEG
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PUSH
68833: LD_INT 3
68835: NEG
68836: PUSH
68837: LD_INT 3
68839: NEG
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: PUSH
68845: EMPTY
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: LIST
68873: LIST
68874: LIST
68875: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68876: LD_ADDR_VAR 0 45
68880: PUSH
68881: LD_INT 0
68883: PUSH
68884: LD_INT 0
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PUSH
68891: LD_INT 0
68893: PUSH
68894: LD_INT 1
68896: NEG
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: LD_INT 1
68904: PUSH
68905: LD_INT 0
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PUSH
68912: LD_INT 1
68914: PUSH
68915: LD_INT 1
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 0
68924: PUSH
68925: LD_INT 1
68927: PUSH
68928: EMPTY
68929: LIST
68930: LIST
68931: PUSH
68932: LD_INT 1
68934: NEG
68935: PUSH
68936: LD_INT 0
68938: PUSH
68939: EMPTY
68940: LIST
68941: LIST
68942: PUSH
68943: LD_INT 1
68945: NEG
68946: PUSH
68947: LD_INT 1
68949: NEG
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 1
68957: NEG
68958: PUSH
68959: LD_INT 2
68961: NEG
68962: PUSH
68963: EMPTY
68964: LIST
68965: LIST
68966: PUSH
68967: LD_INT 0
68969: PUSH
68970: LD_INT 2
68972: NEG
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: PUSH
68978: LD_INT 1
68980: PUSH
68981: LD_INT 1
68983: NEG
68984: PUSH
68985: EMPTY
68986: LIST
68987: LIST
68988: PUSH
68989: LD_INT 2
68991: PUSH
68992: LD_INT 1
68994: PUSH
68995: EMPTY
68996: LIST
68997: LIST
68998: PUSH
68999: LD_INT 2
69001: PUSH
69002: LD_INT 2
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: PUSH
69009: LD_INT 1
69011: PUSH
69012: LD_INT 2
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PUSH
69019: LD_INT 0
69021: PUSH
69022: LD_INT 2
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: PUSH
69029: LD_INT 1
69031: NEG
69032: PUSH
69033: LD_INT 1
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: PUSH
69040: LD_INT 2
69042: NEG
69043: PUSH
69044: LD_INT 1
69046: NEG
69047: PUSH
69048: EMPTY
69049: LIST
69050: LIST
69051: PUSH
69052: LD_INT 2
69054: NEG
69055: PUSH
69056: LD_INT 2
69058: NEG
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PUSH
69064: LD_INT 2
69066: NEG
69067: PUSH
69068: LD_INT 3
69070: NEG
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: LD_INT 1
69078: NEG
69079: PUSH
69080: LD_INT 3
69082: NEG
69083: PUSH
69084: EMPTY
69085: LIST
69086: LIST
69087: PUSH
69088: LD_INT 0
69090: PUSH
69091: LD_INT 3
69093: NEG
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PUSH
69099: LD_INT 1
69101: PUSH
69102: LD_INT 2
69104: NEG
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: LD_INT 3
69112: PUSH
69113: LD_INT 2
69115: PUSH
69116: EMPTY
69117: LIST
69118: LIST
69119: PUSH
69120: LD_INT 3
69122: PUSH
69123: LD_INT 3
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: LD_INT 2
69132: PUSH
69133: LD_INT 3
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: PUSH
69140: LD_INT 1
69142: PUSH
69143: LD_INT 3
69145: PUSH
69146: EMPTY
69147: LIST
69148: LIST
69149: PUSH
69150: LD_INT 0
69152: PUSH
69153: LD_INT 3
69155: PUSH
69156: EMPTY
69157: LIST
69158: LIST
69159: PUSH
69160: LD_INT 1
69162: NEG
69163: PUSH
69164: LD_INT 2
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: PUSH
69171: LD_INT 3
69173: NEG
69174: PUSH
69175: LD_INT 2
69177: NEG
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: PUSH
69183: LD_INT 3
69185: NEG
69186: PUSH
69187: LD_INT 3
69189: NEG
69190: PUSH
69191: EMPTY
69192: LIST
69193: LIST
69194: PUSH
69195: EMPTY
69196: LIST
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: LIST
69202: LIST
69203: LIST
69204: LIST
69205: LIST
69206: LIST
69207: LIST
69208: LIST
69209: LIST
69210: LIST
69211: LIST
69212: LIST
69213: LIST
69214: LIST
69215: LIST
69216: LIST
69217: LIST
69218: LIST
69219: LIST
69220: LIST
69221: LIST
69222: LIST
69223: LIST
69224: LIST
69225: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69226: LD_ADDR_VAR 0 46
69230: PUSH
69231: LD_INT 0
69233: PUSH
69234: LD_INT 0
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PUSH
69241: LD_INT 0
69243: PUSH
69244: LD_INT 1
69246: NEG
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: PUSH
69252: LD_INT 1
69254: PUSH
69255: LD_INT 0
69257: PUSH
69258: EMPTY
69259: LIST
69260: LIST
69261: PUSH
69262: LD_INT 1
69264: PUSH
69265: LD_INT 1
69267: PUSH
69268: EMPTY
69269: LIST
69270: LIST
69271: PUSH
69272: LD_INT 0
69274: PUSH
69275: LD_INT 1
69277: PUSH
69278: EMPTY
69279: LIST
69280: LIST
69281: PUSH
69282: LD_INT 1
69284: NEG
69285: PUSH
69286: LD_INT 0
69288: PUSH
69289: EMPTY
69290: LIST
69291: LIST
69292: PUSH
69293: LD_INT 1
69295: NEG
69296: PUSH
69297: LD_INT 1
69299: NEG
69300: PUSH
69301: EMPTY
69302: LIST
69303: LIST
69304: PUSH
69305: LD_INT 1
69307: NEG
69308: PUSH
69309: LD_INT 2
69311: NEG
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: PUSH
69317: LD_INT 0
69319: PUSH
69320: LD_INT 2
69322: NEG
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: PUSH
69328: LD_INT 1
69330: PUSH
69331: LD_INT 1
69333: NEG
69334: PUSH
69335: EMPTY
69336: LIST
69337: LIST
69338: PUSH
69339: LD_INT 2
69341: PUSH
69342: LD_INT 0
69344: PUSH
69345: EMPTY
69346: LIST
69347: LIST
69348: PUSH
69349: LD_INT 2
69351: PUSH
69352: LD_INT 1
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: PUSH
69359: LD_INT 1
69361: PUSH
69362: LD_INT 2
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: PUSH
69369: LD_INT 0
69371: PUSH
69372: LD_INT 2
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: PUSH
69379: LD_INT 1
69381: NEG
69382: PUSH
69383: LD_INT 1
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PUSH
69390: LD_INT 2
69392: NEG
69393: PUSH
69394: LD_INT 0
69396: PUSH
69397: EMPTY
69398: LIST
69399: LIST
69400: PUSH
69401: LD_INT 2
69403: NEG
69404: PUSH
69405: LD_INT 1
69407: NEG
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: PUSH
69413: LD_INT 1
69415: NEG
69416: PUSH
69417: LD_INT 3
69419: NEG
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: PUSH
69425: LD_INT 0
69427: PUSH
69428: LD_INT 3
69430: NEG
69431: PUSH
69432: EMPTY
69433: LIST
69434: LIST
69435: PUSH
69436: LD_INT 1
69438: PUSH
69439: LD_INT 2
69441: NEG
69442: PUSH
69443: EMPTY
69444: LIST
69445: LIST
69446: PUSH
69447: LD_INT 2
69449: PUSH
69450: LD_INT 1
69452: NEG
69453: PUSH
69454: EMPTY
69455: LIST
69456: LIST
69457: PUSH
69458: LD_INT 3
69460: PUSH
69461: LD_INT 0
69463: PUSH
69464: EMPTY
69465: LIST
69466: LIST
69467: PUSH
69468: LD_INT 3
69470: PUSH
69471: LD_INT 1
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: LD_INT 1
69480: PUSH
69481: LD_INT 3
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: LD_INT 0
69490: PUSH
69491: LD_INT 3
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: LD_INT 1
69500: NEG
69501: PUSH
69502: LD_INT 2
69504: PUSH
69505: EMPTY
69506: LIST
69507: LIST
69508: PUSH
69509: LD_INT 2
69511: NEG
69512: PUSH
69513: LD_INT 1
69515: PUSH
69516: EMPTY
69517: LIST
69518: LIST
69519: PUSH
69520: LD_INT 3
69522: NEG
69523: PUSH
69524: LD_INT 0
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: PUSH
69531: LD_INT 3
69533: NEG
69534: PUSH
69535: LD_INT 1
69537: NEG
69538: PUSH
69539: EMPTY
69540: LIST
69541: LIST
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: LIST
69547: LIST
69548: LIST
69549: LIST
69550: LIST
69551: LIST
69552: LIST
69553: LIST
69554: LIST
69555: LIST
69556: LIST
69557: LIST
69558: LIST
69559: LIST
69560: LIST
69561: LIST
69562: LIST
69563: LIST
69564: LIST
69565: LIST
69566: LIST
69567: LIST
69568: LIST
69569: LIST
69570: LIST
69571: LIST
69572: LIST
69573: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69574: LD_ADDR_VAR 0 47
69578: PUSH
69579: LD_INT 0
69581: PUSH
69582: LD_INT 0
69584: PUSH
69585: EMPTY
69586: LIST
69587: LIST
69588: PUSH
69589: LD_INT 0
69591: PUSH
69592: LD_INT 1
69594: NEG
69595: PUSH
69596: EMPTY
69597: LIST
69598: LIST
69599: PUSH
69600: LD_INT 1
69602: PUSH
69603: LD_INT 0
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: PUSH
69610: LD_INT 1
69612: PUSH
69613: LD_INT 1
69615: PUSH
69616: EMPTY
69617: LIST
69618: LIST
69619: PUSH
69620: LD_INT 0
69622: PUSH
69623: LD_INT 1
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: LD_INT 1
69632: NEG
69633: PUSH
69634: LD_INT 0
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: PUSH
69641: LD_INT 1
69643: NEG
69644: PUSH
69645: LD_INT 1
69647: NEG
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: PUSH
69653: LD_INT 1
69655: NEG
69656: PUSH
69657: LD_INT 2
69659: NEG
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 0
69667: PUSH
69668: LD_INT 2
69670: NEG
69671: PUSH
69672: EMPTY
69673: LIST
69674: LIST
69675: PUSH
69676: LD_INT 1
69678: PUSH
69679: LD_INT 1
69681: NEG
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: PUSH
69687: LD_INT 2
69689: NEG
69690: PUSH
69691: LD_INT 1
69693: NEG
69694: PUSH
69695: EMPTY
69696: LIST
69697: LIST
69698: PUSH
69699: LD_INT 2
69701: NEG
69702: PUSH
69703: LD_INT 2
69705: NEG
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: LIST
69723: LIST
69724: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
69725: LD_ADDR_VAR 0 48
69729: PUSH
69730: LD_INT 0
69732: PUSH
69733: LD_INT 0
69735: PUSH
69736: EMPTY
69737: LIST
69738: LIST
69739: PUSH
69740: LD_INT 0
69742: PUSH
69743: LD_INT 1
69745: NEG
69746: PUSH
69747: EMPTY
69748: LIST
69749: LIST
69750: PUSH
69751: LD_INT 1
69753: PUSH
69754: LD_INT 0
69756: PUSH
69757: EMPTY
69758: LIST
69759: LIST
69760: PUSH
69761: LD_INT 1
69763: PUSH
69764: LD_INT 1
69766: PUSH
69767: EMPTY
69768: LIST
69769: LIST
69770: PUSH
69771: LD_INT 0
69773: PUSH
69774: LD_INT 1
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: LD_INT 1
69783: NEG
69784: PUSH
69785: LD_INT 0
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: LD_INT 1
69794: NEG
69795: PUSH
69796: LD_INT 1
69798: NEG
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 1
69806: NEG
69807: PUSH
69808: LD_INT 2
69810: NEG
69811: PUSH
69812: EMPTY
69813: LIST
69814: LIST
69815: PUSH
69816: LD_INT 0
69818: PUSH
69819: LD_INT 2
69821: NEG
69822: PUSH
69823: EMPTY
69824: LIST
69825: LIST
69826: PUSH
69827: LD_INT 1
69829: PUSH
69830: LD_INT 1
69832: NEG
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: PUSH
69838: LD_INT 2
69840: PUSH
69841: LD_INT 0
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 2
69850: PUSH
69851: LD_INT 1
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: PUSH
69858: EMPTY
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: LIST
69869: LIST
69870: LIST
69871: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
69872: LD_ADDR_VAR 0 49
69876: PUSH
69877: LD_INT 0
69879: PUSH
69880: LD_INT 0
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: LD_INT 0
69889: PUSH
69890: LD_INT 1
69892: NEG
69893: PUSH
69894: EMPTY
69895: LIST
69896: LIST
69897: PUSH
69898: LD_INT 1
69900: PUSH
69901: LD_INT 0
69903: PUSH
69904: EMPTY
69905: LIST
69906: LIST
69907: PUSH
69908: LD_INT 1
69910: PUSH
69911: LD_INT 1
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: PUSH
69918: LD_INT 0
69920: PUSH
69921: LD_INT 1
69923: PUSH
69924: EMPTY
69925: LIST
69926: LIST
69927: PUSH
69928: LD_INT 1
69930: NEG
69931: PUSH
69932: LD_INT 0
69934: PUSH
69935: EMPTY
69936: LIST
69937: LIST
69938: PUSH
69939: LD_INT 1
69941: NEG
69942: PUSH
69943: LD_INT 1
69945: NEG
69946: PUSH
69947: EMPTY
69948: LIST
69949: LIST
69950: PUSH
69951: LD_INT 1
69953: PUSH
69954: LD_INT 1
69956: NEG
69957: PUSH
69958: EMPTY
69959: LIST
69960: LIST
69961: PUSH
69962: LD_INT 2
69964: PUSH
69965: LD_INT 0
69967: PUSH
69968: EMPTY
69969: LIST
69970: LIST
69971: PUSH
69972: LD_INT 2
69974: PUSH
69975: LD_INT 1
69977: PUSH
69978: EMPTY
69979: LIST
69980: LIST
69981: PUSH
69982: LD_INT 2
69984: PUSH
69985: LD_INT 2
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: PUSH
69992: LD_INT 1
69994: PUSH
69995: LD_INT 2
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: LIST
70006: LIST
70007: LIST
70008: LIST
70009: LIST
70010: LIST
70011: LIST
70012: LIST
70013: LIST
70014: LIST
70015: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
70016: LD_ADDR_VAR 0 50
70020: PUSH
70021: LD_INT 0
70023: PUSH
70024: LD_INT 0
70026: PUSH
70027: EMPTY
70028: LIST
70029: LIST
70030: PUSH
70031: LD_INT 0
70033: PUSH
70034: LD_INT 1
70036: NEG
70037: PUSH
70038: EMPTY
70039: LIST
70040: LIST
70041: PUSH
70042: LD_INT 1
70044: PUSH
70045: LD_INT 0
70047: PUSH
70048: EMPTY
70049: LIST
70050: LIST
70051: PUSH
70052: LD_INT 1
70054: PUSH
70055: LD_INT 1
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PUSH
70062: LD_INT 0
70064: PUSH
70065: LD_INT 1
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PUSH
70072: LD_INT 1
70074: NEG
70075: PUSH
70076: LD_INT 0
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: PUSH
70083: LD_INT 1
70085: NEG
70086: PUSH
70087: LD_INT 1
70089: NEG
70090: PUSH
70091: EMPTY
70092: LIST
70093: LIST
70094: PUSH
70095: LD_INT 2
70097: PUSH
70098: LD_INT 1
70100: PUSH
70101: EMPTY
70102: LIST
70103: LIST
70104: PUSH
70105: LD_INT 2
70107: PUSH
70108: LD_INT 2
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PUSH
70115: LD_INT 1
70117: PUSH
70118: LD_INT 2
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PUSH
70125: LD_INT 0
70127: PUSH
70128: LD_INT 2
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: PUSH
70135: LD_INT 1
70137: NEG
70138: PUSH
70139: LD_INT 1
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: PUSH
70146: EMPTY
70147: LIST
70148: LIST
70149: LIST
70150: LIST
70151: LIST
70152: LIST
70153: LIST
70154: LIST
70155: LIST
70156: LIST
70157: LIST
70158: LIST
70159: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
70160: LD_ADDR_VAR 0 51
70164: PUSH
70165: LD_INT 0
70167: PUSH
70168: LD_INT 0
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: PUSH
70175: LD_INT 0
70177: PUSH
70178: LD_INT 1
70180: NEG
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: LD_INT 1
70188: PUSH
70189: LD_INT 0
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 1
70198: PUSH
70199: LD_INT 1
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 0
70208: PUSH
70209: LD_INT 1
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 1
70218: NEG
70219: PUSH
70220: LD_INT 0
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: LD_INT 1
70229: NEG
70230: PUSH
70231: LD_INT 1
70233: NEG
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PUSH
70239: LD_INT 1
70241: PUSH
70242: LD_INT 2
70244: PUSH
70245: EMPTY
70246: LIST
70247: LIST
70248: PUSH
70249: LD_INT 0
70251: PUSH
70252: LD_INT 2
70254: PUSH
70255: EMPTY
70256: LIST
70257: LIST
70258: PUSH
70259: LD_INT 1
70261: NEG
70262: PUSH
70263: LD_INT 1
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: LD_INT 2
70272: NEG
70273: PUSH
70274: LD_INT 0
70276: PUSH
70277: EMPTY
70278: LIST
70279: LIST
70280: PUSH
70281: LD_INT 2
70283: NEG
70284: PUSH
70285: LD_INT 1
70287: NEG
70288: PUSH
70289: EMPTY
70290: LIST
70291: LIST
70292: PUSH
70293: EMPTY
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: LIST
70303: LIST
70304: LIST
70305: LIST
70306: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70307: LD_ADDR_VAR 0 52
70311: PUSH
70312: LD_INT 0
70314: PUSH
70315: LD_INT 0
70317: PUSH
70318: EMPTY
70319: LIST
70320: LIST
70321: PUSH
70322: LD_INT 0
70324: PUSH
70325: LD_INT 1
70327: NEG
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: PUSH
70333: LD_INT 1
70335: PUSH
70336: LD_INT 0
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: PUSH
70343: LD_INT 1
70345: PUSH
70346: LD_INT 1
70348: PUSH
70349: EMPTY
70350: LIST
70351: LIST
70352: PUSH
70353: LD_INT 0
70355: PUSH
70356: LD_INT 1
70358: PUSH
70359: EMPTY
70360: LIST
70361: LIST
70362: PUSH
70363: LD_INT 1
70365: NEG
70366: PUSH
70367: LD_INT 0
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: LD_INT 1
70376: NEG
70377: PUSH
70378: LD_INT 1
70380: NEG
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PUSH
70386: LD_INT 1
70388: NEG
70389: PUSH
70390: LD_INT 2
70392: NEG
70393: PUSH
70394: EMPTY
70395: LIST
70396: LIST
70397: PUSH
70398: LD_INT 1
70400: NEG
70401: PUSH
70402: LD_INT 1
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: LD_INT 2
70411: NEG
70412: PUSH
70413: LD_INT 0
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: PUSH
70420: LD_INT 2
70422: NEG
70423: PUSH
70424: LD_INT 1
70426: NEG
70427: PUSH
70428: EMPTY
70429: LIST
70430: LIST
70431: PUSH
70432: LD_INT 2
70434: NEG
70435: PUSH
70436: LD_INT 2
70438: NEG
70439: PUSH
70440: EMPTY
70441: LIST
70442: LIST
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: LIST
70448: LIST
70449: LIST
70450: LIST
70451: LIST
70452: LIST
70453: LIST
70454: LIST
70455: LIST
70456: LIST
70457: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70458: LD_ADDR_VAR 0 53
70462: PUSH
70463: LD_INT 0
70465: PUSH
70466: LD_INT 0
70468: PUSH
70469: EMPTY
70470: LIST
70471: LIST
70472: PUSH
70473: LD_INT 0
70475: PUSH
70476: LD_INT 1
70478: NEG
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: PUSH
70484: LD_INT 1
70486: PUSH
70487: LD_INT 0
70489: PUSH
70490: EMPTY
70491: LIST
70492: LIST
70493: PUSH
70494: LD_INT 1
70496: PUSH
70497: LD_INT 1
70499: PUSH
70500: EMPTY
70501: LIST
70502: LIST
70503: PUSH
70504: LD_INT 0
70506: PUSH
70507: LD_INT 1
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: LD_INT 1
70516: NEG
70517: PUSH
70518: LD_INT 0
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: LD_INT 1
70527: NEG
70528: PUSH
70529: LD_INT 1
70531: NEG
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: PUSH
70537: LD_INT 1
70539: NEG
70540: PUSH
70541: LD_INT 2
70543: NEG
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 0
70551: PUSH
70552: LD_INT 2
70554: NEG
70555: PUSH
70556: EMPTY
70557: LIST
70558: LIST
70559: PUSH
70560: LD_INT 1
70562: PUSH
70563: LD_INT 1
70565: NEG
70566: PUSH
70567: EMPTY
70568: LIST
70569: LIST
70570: PUSH
70571: LD_INT 2
70573: PUSH
70574: LD_INT 0
70576: PUSH
70577: EMPTY
70578: LIST
70579: LIST
70580: PUSH
70581: LD_INT 2
70583: PUSH
70584: LD_INT 1
70586: PUSH
70587: EMPTY
70588: LIST
70589: LIST
70590: PUSH
70591: LD_INT 2
70593: PUSH
70594: LD_INT 2
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: PUSH
70601: LD_INT 1
70603: PUSH
70604: LD_INT 2
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: LD_INT 0
70613: PUSH
70614: LD_INT 2
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: PUSH
70621: LD_INT 1
70623: NEG
70624: PUSH
70625: LD_INT 1
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: LD_INT 2
70634: NEG
70635: PUSH
70636: LD_INT 0
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 2
70645: NEG
70646: PUSH
70647: LD_INT 1
70649: NEG
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: LD_INT 2
70657: NEG
70658: PUSH
70659: LD_INT 2
70661: NEG
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: PUSH
70667: EMPTY
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: LIST
70679: LIST
70680: LIST
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: LIST
70686: LIST
70687: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70688: LD_ADDR_VAR 0 54
70692: PUSH
70693: LD_INT 0
70695: PUSH
70696: LD_INT 0
70698: PUSH
70699: EMPTY
70700: LIST
70701: LIST
70702: PUSH
70703: LD_INT 0
70705: PUSH
70706: LD_INT 1
70708: NEG
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: PUSH
70714: LD_INT 1
70716: PUSH
70717: LD_INT 0
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: LD_INT 1
70726: PUSH
70727: LD_INT 1
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 0
70736: PUSH
70737: LD_INT 1
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 1
70746: NEG
70747: PUSH
70748: LD_INT 0
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PUSH
70755: LD_INT 1
70757: NEG
70758: PUSH
70759: LD_INT 1
70761: NEG
70762: PUSH
70763: EMPTY
70764: LIST
70765: LIST
70766: PUSH
70767: LD_INT 1
70769: NEG
70770: PUSH
70771: LD_INT 2
70773: NEG
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: PUSH
70779: LD_INT 0
70781: PUSH
70782: LD_INT 2
70784: NEG
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: PUSH
70790: LD_INT 1
70792: PUSH
70793: LD_INT 1
70795: NEG
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: PUSH
70801: LD_INT 2
70803: PUSH
70804: LD_INT 0
70806: PUSH
70807: EMPTY
70808: LIST
70809: LIST
70810: PUSH
70811: LD_INT 2
70813: PUSH
70814: LD_INT 1
70816: PUSH
70817: EMPTY
70818: LIST
70819: LIST
70820: PUSH
70821: LD_INT 2
70823: PUSH
70824: LD_INT 2
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: LD_INT 1
70833: PUSH
70834: LD_INT 2
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: LD_INT 0
70843: PUSH
70844: LD_INT 2
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 1
70853: NEG
70854: PUSH
70855: LD_INT 1
70857: PUSH
70858: EMPTY
70859: LIST
70860: LIST
70861: PUSH
70862: LD_INT 2
70864: NEG
70865: PUSH
70866: LD_INT 0
70868: PUSH
70869: EMPTY
70870: LIST
70871: LIST
70872: PUSH
70873: LD_INT 2
70875: NEG
70876: PUSH
70877: LD_INT 1
70879: NEG
70880: PUSH
70881: EMPTY
70882: LIST
70883: LIST
70884: PUSH
70885: LD_INT 2
70887: NEG
70888: PUSH
70889: LD_INT 2
70891: NEG
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: EMPTY
70898: LIST
70899: LIST
70900: LIST
70901: LIST
70902: LIST
70903: LIST
70904: LIST
70905: LIST
70906: LIST
70907: LIST
70908: LIST
70909: LIST
70910: LIST
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70918: LD_ADDR_VAR 0 55
70922: PUSH
70923: LD_INT 0
70925: PUSH
70926: LD_INT 0
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: PUSH
70933: LD_INT 0
70935: PUSH
70936: LD_INT 1
70938: NEG
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: LD_INT 1
70946: PUSH
70947: LD_INT 0
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: PUSH
70954: LD_INT 1
70956: PUSH
70957: LD_INT 1
70959: PUSH
70960: EMPTY
70961: LIST
70962: LIST
70963: PUSH
70964: LD_INT 0
70966: PUSH
70967: LD_INT 1
70969: PUSH
70970: EMPTY
70971: LIST
70972: LIST
70973: PUSH
70974: LD_INT 1
70976: NEG
70977: PUSH
70978: LD_INT 0
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: PUSH
70985: LD_INT 1
70987: NEG
70988: PUSH
70989: LD_INT 1
70991: NEG
70992: PUSH
70993: EMPTY
70994: LIST
70995: LIST
70996: PUSH
70997: LD_INT 1
70999: NEG
71000: PUSH
71001: LD_INT 2
71003: NEG
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: PUSH
71009: LD_INT 0
71011: PUSH
71012: LD_INT 2
71014: NEG
71015: PUSH
71016: EMPTY
71017: LIST
71018: LIST
71019: PUSH
71020: LD_INT 1
71022: PUSH
71023: LD_INT 1
71025: NEG
71026: PUSH
71027: EMPTY
71028: LIST
71029: LIST
71030: PUSH
71031: LD_INT 2
71033: PUSH
71034: LD_INT 0
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: PUSH
71041: LD_INT 2
71043: PUSH
71044: LD_INT 1
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 2
71053: PUSH
71054: LD_INT 2
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: LD_INT 1
71063: PUSH
71064: LD_INT 2
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PUSH
71071: LD_INT 0
71073: PUSH
71074: LD_INT 2
71076: PUSH
71077: EMPTY
71078: LIST
71079: LIST
71080: PUSH
71081: LD_INT 1
71083: NEG
71084: PUSH
71085: LD_INT 1
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PUSH
71092: LD_INT 2
71094: NEG
71095: PUSH
71096: LD_INT 0
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: LD_INT 2
71105: NEG
71106: PUSH
71107: LD_INT 1
71109: NEG
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 2
71117: NEG
71118: PUSH
71119: LD_INT 2
71121: NEG
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: EMPTY
71128: LIST
71129: LIST
71130: LIST
71131: LIST
71132: LIST
71133: LIST
71134: LIST
71135: LIST
71136: LIST
71137: LIST
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: LIST
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71148: LD_ADDR_VAR 0 56
71152: PUSH
71153: LD_INT 0
71155: PUSH
71156: LD_INT 0
71158: PUSH
71159: EMPTY
71160: LIST
71161: LIST
71162: PUSH
71163: LD_INT 0
71165: PUSH
71166: LD_INT 1
71168: NEG
71169: PUSH
71170: EMPTY
71171: LIST
71172: LIST
71173: PUSH
71174: LD_INT 1
71176: PUSH
71177: LD_INT 0
71179: PUSH
71180: EMPTY
71181: LIST
71182: LIST
71183: PUSH
71184: LD_INT 1
71186: PUSH
71187: LD_INT 1
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PUSH
71194: LD_INT 0
71196: PUSH
71197: LD_INT 1
71199: PUSH
71200: EMPTY
71201: LIST
71202: LIST
71203: PUSH
71204: LD_INT 1
71206: NEG
71207: PUSH
71208: LD_INT 0
71210: PUSH
71211: EMPTY
71212: LIST
71213: LIST
71214: PUSH
71215: LD_INT 1
71217: NEG
71218: PUSH
71219: LD_INT 1
71221: NEG
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: PUSH
71227: LD_INT 1
71229: NEG
71230: PUSH
71231: LD_INT 2
71233: NEG
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 0
71241: PUSH
71242: LD_INT 2
71244: NEG
71245: PUSH
71246: EMPTY
71247: LIST
71248: LIST
71249: PUSH
71250: LD_INT 1
71252: PUSH
71253: LD_INT 1
71255: NEG
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PUSH
71261: LD_INT 2
71263: PUSH
71264: LD_INT 0
71266: PUSH
71267: EMPTY
71268: LIST
71269: LIST
71270: PUSH
71271: LD_INT 2
71273: PUSH
71274: LD_INT 1
71276: PUSH
71277: EMPTY
71278: LIST
71279: LIST
71280: PUSH
71281: LD_INT 2
71283: PUSH
71284: LD_INT 2
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: PUSH
71291: LD_INT 1
71293: PUSH
71294: LD_INT 2
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: LD_INT 0
71303: PUSH
71304: LD_INT 2
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: PUSH
71311: LD_INT 1
71313: NEG
71314: PUSH
71315: LD_INT 1
71317: PUSH
71318: EMPTY
71319: LIST
71320: LIST
71321: PUSH
71322: LD_INT 2
71324: NEG
71325: PUSH
71326: LD_INT 0
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: PUSH
71333: LD_INT 2
71335: NEG
71336: PUSH
71337: LD_INT 1
71339: NEG
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: PUSH
71345: LD_INT 2
71347: NEG
71348: PUSH
71349: LD_INT 2
71351: NEG
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: LIST
71364: LIST
71365: LIST
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: LIST
71377: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71378: LD_ADDR_VAR 0 57
71382: PUSH
71383: LD_INT 0
71385: PUSH
71386: LD_INT 0
71388: PUSH
71389: EMPTY
71390: LIST
71391: LIST
71392: PUSH
71393: LD_INT 0
71395: PUSH
71396: LD_INT 1
71398: NEG
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: PUSH
71404: LD_INT 1
71406: PUSH
71407: LD_INT 0
71409: PUSH
71410: EMPTY
71411: LIST
71412: LIST
71413: PUSH
71414: LD_INT 1
71416: PUSH
71417: LD_INT 1
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: PUSH
71424: LD_INT 0
71426: PUSH
71427: LD_INT 1
71429: PUSH
71430: EMPTY
71431: LIST
71432: LIST
71433: PUSH
71434: LD_INT 1
71436: NEG
71437: PUSH
71438: LD_INT 0
71440: PUSH
71441: EMPTY
71442: LIST
71443: LIST
71444: PUSH
71445: LD_INT 1
71447: NEG
71448: PUSH
71449: LD_INT 1
71451: NEG
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PUSH
71457: LD_INT 1
71459: NEG
71460: PUSH
71461: LD_INT 2
71463: NEG
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: PUSH
71469: LD_INT 0
71471: PUSH
71472: LD_INT 2
71474: NEG
71475: PUSH
71476: EMPTY
71477: LIST
71478: LIST
71479: PUSH
71480: LD_INT 1
71482: PUSH
71483: LD_INT 1
71485: NEG
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 2
71493: PUSH
71494: LD_INT 0
71496: PUSH
71497: EMPTY
71498: LIST
71499: LIST
71500: PUSH
71501: LD_INT 2
71503: PUSH
71504: LD_INT 1
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 2
71513: PUSH
71514: LD_INT 2
71516: PUSH
71517: EMPTY
71518: LIST
71519: LIST
71520: PUSH
71521: LD_INT 1
71523: PUSH
71524: LD_INT 2
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 0
71533: PUSH
71534: LD_INT 2
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 1
71543: NEG
71544: PUSH
71545: LD_INT 1
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: PUSH
71552: LD_INT 2
71554: NEG
71555: PUSH
71556: LD_INT 0
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: LD_INT 2
71565: NEG
71566: PUSH
71567: LD_INT 1
71569: NEG
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PUSH
71575: LD_INT 2
71577: NEG
71578: PUSH
71579: LD_INT 2
71581: NEG
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: EMPTY
71588: LIST
71589: LIST
71590: LIST
71591: LIST
71592: LIST
71593: LIST
71594: LIST
71595: LIST
71596: LIST
71597: LIST
71598: LIST
71599: LIST
71600: LIST
71601: LIST
71602: LIST
71603: LIST
71604: LIST
71605: LIST
71606: LIST
71607: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71608: LD_ADDR_VAR 0 58
71612: PUSH
71613: LD_INT 0
71615: PUSH
71616: LD_INT 0
71618: PUSH
71619: EMPTY
71620: LIST
71621: LIST
71622: PUSH
71623: LD_INT 0
71625: PUSH
71626: LD_INT 1
71628: NEG
71629: PUSH
71630: EMPTY
71631: LIST
71632: LIST
71633: PUSH
71634: LD_INT 1
71636: PUSH
71637: LD_INT 0
71639: PUSH
71640: EMPTY
71641: LIST
71642: LIST
71643: PUSH
71644: LD_INT 1
71646: PUSH
71647: LD_INT 1
71649: PUSH
71650: EMPTY
71651: LIST
71652: LIST
71653: PUSH
71654: LD_INT 0
71656: PUSH
71657: LD_INT 1
71659: PUSH
71660: EMPTY
71661: LIST
71662: LIST
71663: PUSH
71664: LD_INT 1
71666: NEG
71667: PUSH
71668: LD_INT 0
71670: PUSH
71671: EMPTY
71672: LIST
71673: LIST
71674: PUSH
71675: LD_INT 1
71677: NEG
71678: PUSH
71679: LD_INT 1
71681: NEG
71682: PUSH
71683: EMPTY
71684: LIST
71685: LIST
71686: PUSH
71687: LD_INT 1
71689: NEG
71690: PUSH
71691: LD_INT 2
71693: NEG
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: PUSH
71699: LD_INT 0
71701: PUSH
71702: LD_INT 2
71704: NEG
71705: PUSH
71706: EMPTY
71707: LIST
71708: LIST
71709: PUSH
71710: LD_INT 1
71712: PUSH
71713: LD_INT 1
71715: NEG
71716: PUSH
71717: EMPTY
71718: LIST
71719: LIST
71720: PUSH
71721: LD_INT 2
71723: PUSH
71724: LD_INT 0
71726: PUSH
71727: EMPTY
71728: LIST
71729: LIST
71730: PUSH
71731: LD_INT 2
71733: PUSH
71734: LD_INT 1
71736: PUSH
71737: EMPTY
71738: LIST
71739: LIST
71740: PUSH
71741: LD_INT 2
71743: PUSH
71744: LD_INT 2
71746: PUSH
71747: EMPTY
71748: LIST
71749: LIST
71750: PUSH
71751: LD_INT 1
71753: PUSH
71754: LD_INT 2
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: LD_INT 0
71763: PUSH
71764: LD_INT 2
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: PUSH
71771: LD_INT 1
71773: NEG
71774: PUSH
71775: LD_INT 1
71777: PUSH
71778: EMPTY
71779: LIST
71780: LIST
71781: PUSH
71782: LD_INT 2
71784: NEG
71785: PUSH
71786: LD_INT 0
71788: PUSH
71789: EMPTY
71790: LIST
71791: LIST
71792: PUSH
71793: LD_INT 2
71795: NEG
71796: PUSH
71797: LD_INT 1
71799: NEG
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 2
71807: NEG
71808: PUSH
71809: LD_INT 2
71811: NEG
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: LIST
71821: LIST
71822: LIST
71823: LIST
71824: LIST
71825: LIST
71826: LIST
71827: LIST
71828: LIST
71829: LIST
71830: LIST
71831: LIST
71832: LIST
71833: LIST
71834: LIST
71835: LIST
71836: LIST
71837: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
71838: LD_ADDR_VAR 0 59
71842: PUSH
71843: LD_INT 0
71845: PUSH
71846: LD_INT 0
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: LD_INT 0
71855: PUSH
71856: LD_INT 1
71858: NEG
71859: PUSH
71860: EMPTY
71861: LIST
71862: LIST
71863: PUSH
71864: LD_INT 1
71866: PUSH
71867: LD_INT 0
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: PUSH
71874: LD_INT 1
71876: PUSH
71877: LD_INT 1
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: PUSH
71884: LD_INT 0
71886: PUSH
71887: LD_INT 1
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 1
71896: NEG
71897: PUSH
71898: LD_INT 0
71900: PUSH
71901: EMPTY
71902: LIST
71903: LIST
71904: PUSH
71905: LD_INT 1
71907: NEG
71908: PUSH
71909: LD_INT 1
71911: NEG
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: PUSH
71917: EMPTY
71918: LIST
71919: LIST
71920: LIST
71921: LIST
71922: LIST
71923: LIST
71924: LIST
71925: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
71926: LD_ADDR_VAR 0 60
71930: PUSH
71931: LD_INT 0
71933: PUSH
71934: LD_INT 0
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: PUSH
71941: LD_INT 0
71943: PUSH
71944: LD_INT 1
71946: NEG
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PUSH
71952: LD_INT 1
71954: PUSH
71955: LD_INT 0
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: PUSH
71962: LD_INT 1
71964: PUSH
71965: LD_INT 1
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: PUSH
71972: LD_INT 0
71974: PUSH
71975: LD_INT 1
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PUSH
71982: LD_INT 1
71984: NEG
71985: PUSH
71986: LD_INT 0
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 1
71995: NEG
71996: PUSH
71997: LD_INT 1
71999: NEG
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PUSH
72005: EMPTY
72006: LIST
72007: LIST
72008: LIST
72009: LIST
72010: LIST
72011: LIST
72012: LIST
72013: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72014: LD_ADDR_VAR 0 61
72018: PUSH
72019: LD_INT 0
72021: PUSH
72022: LD_INT 0
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: PUSH
72029: LD_INT 0
72031: PUSH
72032: LD_INT 1
72034: NEG
72035: PUSH
72036: EMPTY
72037: LIST
72038: LIST
72039: PUSH
72040: LD_INT 1
72042: PUSH
72043: LD_INT 0
72045: PUSH
72046: EMPTY
72047: LIST
72048: LIST
72049: PUSH
72050: LD_INT 1
72052: PUSH
72053: LD_INT 1
72055: PUSH
72056: EMPTY
72057: LIST
72058: LIST
72059: PUSH
72060: LD_INT 0
72062: PUSH
72063: LD_INT 1
72065: PUSH
72066: EMPTY
72067: LIST
72068: LIST
72069: PUSH
72070: LD_INT 1
72072: NEG
72073: PUSH
72074: LD_INT 0
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: PUSH
72081: LD_INT 1
72083: NEG
72084: PUSH
72085: LD_INT 1
72087: NEG
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: LIST
72101: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72102: LD_ADDR_VAR 0 62
72106: PUSH
72107: LD_INT 0
72109: PUSH
72110: LD_INT 0
72112: PUSH
72113: EMPTY
72114: LIST
72115: LIST
72116: PUSH
72117: LD_INT 0
72119: PUSH
72120: LD_INT 1
72122: NEG
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 1
72130: PUSH
72131: LD_INT 0
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 1
72140: PUSH
72141: LD_INT 1
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 0
72150: PUSH
72151: LD_INT 1
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 1
72160: NEG
72161: PUSH
72162: LD_INT 0
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 1
72171: NEG
72172: PUSH
72173: LD_INT 1
72175: NEG
72176: PUSH
72177: EMPTY
72178: LIST
72179: LIST
72180: PUSH
72181: EMPTY
72182: LIST
72183: LIST
72184: LIST
72185: LIST
72186: LIST
72187: LIST
72188: LIST
72189: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72190: LD_ADDR_VAR 0 63
72194: PUSH
72195: LD_INT 0
72197: PUSH
72198: LD_INT 0
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: PUSH
72205: LD_INT 0
72207: PUSH
72208: LD_INT 1
72210: NEG
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: PUSH
72216: LD_INT 1
72218: PUSH
72219: LD_INT 0
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PUSH
72226: LD_INT 1
72228: PUSH
72229: LD_INT 1
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: LD_INT 0
72238: PUSH
72239: LD_INT 1
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 1
72248: NEG
72249: PUSH
72250: LD_INT 0
72252: PUSH
72253: EMPTY
72254: LIST
72255: LIST
72256: PUSH
72257: LD_INT 1
72259: NEG
72260: PUSH
72261: LD_INT 1
72263: NEG
72264: PUSH
72265: EMPTY
72266: LIST
72267: LIST
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: LIST
72273: LIST
72274: LIST
72275: LIST
72276: LIST
72277: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72278: LD_ADDR_VAR 0 64
72282: PUSH
72283: LD_INT 0
72285: PUSH
72286: LD_INT 0
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PUSH
72293: LD_INT 0
72295: PUSH
72296: LD_INT 1
72298: NEG
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PUSH
72304: LD_INT 1
72306: PUSH
72307: LD_INT 0
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: LD_INT 1
72316: PUSH
72317: LD_INT 1
72319: PUSH
72320: EMPTY
72321: LIST
72322: LIST
72323: PUSH
72324: LD_INT 0
72326: PUSH
72327: LD_INT 1
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: PUSH
72334: LD_INT 1
72336: NEG
72337: PUSH
72338: LD_INT 0
72340: PUSH
72341: EMPTY
72342: LIST
72343: LIST
72344: PUSH
72345: LD_INT 1
72347: NEG
72348: PUSH
72349: LD_INT 1
72351: NEG
72352: PUSH
72353: EMPTY
72354: LIST
72355: LIST
72356: PUSH
72357: EMPTY
72358: LIST
72359: LIST
72360: LIST
72361: LIST
72362: LIST
72363: LIST
72364: LIST
72365: ST_TO_ADDR
// end ; 1 :
72366: GO 78263
72368: LD_INT 1
72370: DOUBLE
72371: EQUAL
72372: IFTRUE 72376
72374: GO 74999
72376: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72377: LD_ADDR_VAR 0 11
72381: PUSH
72382: LD_INT 1
72384: NEG
72385: PUSH
72386: LD_INT 3
72388: NEG
72389: PUSH
72390: EMPTY
72391: LIST
72392: LIST
72393: PUSH
72394: LD_INT 0
72396: PUSH
72397: LD_INT 3
72399: NEG
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PUSH
72405: LD_INT 1
72407: PUSH
72408: LD_INT 2
72410: NEG
72411: PUSH
72412: EMPTY
72413: LIST
72414: LIST
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: LIST
72420: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72421: LD_ADDR_VAR 0 12
72425: PUSH
72426: LD_INT 2
72428: PUSH
72429: LD_INT 1
72431: NEG
72432: PUSH
72433: EMPTY
72434: LIST
72435: LIST
72436: PUSH
72437: LD_INT 3
72439: PUSH
72440: LD_INT 0
72442: PUSH
72443: EMPTY
72444: LIST
72445: LIST
72446: PUSH
72447: LD_INT 3
72449: PUSH
72450: LD_INT 1
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: LIST
72461: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72462: LD_ADDR_VAR 0 13
72466: PUSH
72467: LD_INT 3
72469: PUSH
72470: LD_INT 2
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: PUSH
72477: LD_INT 3
72479: PUSH
72480: LD_INT 3
72482: PUSH
72483: EMPTY
72484: LIST
72485: LIST
72486: PUSH
72487: LD_INT 2
72489: PUSH
72490: LD_INT 3
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: LIST
72501: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
72502: LD_ADDR_VAR 0 14
72506: PUSH
72507: LD_INT 1
72509: PUSH
72510: LD_INT 3
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: LD_INT 0
72519: PUSH
72520: LD_INT 3
72522: PUSH
72523: EMPTY
72524: LIST
72525: LIST
72526: PUSH
72527: LD_INT 1
72529: NEG
72530: PUSH
72531: LD_INT 2
72533: PUSH
72534: EMPTY
72535: LIST
72536: LIST
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: LIST
72542: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72543: LD_ADDR_VAR 0 15
72547: PUSH
72548: LD_INT 2
72550: NEG
72551: PUSH
72552: LD_INT 1
72554: PUSH
72555: EMPTY
72556: LIST
72557: LIST
72558: PUSH
72559: LD_INT 3
72561: NEG
72562: PUSH
72563: LD_INT 0
72565: PUSH
72566: EMPTY
72567: LIST
72568: LIST
72569: PUSH
72570: LD_INT 3
72572: NEG
72573: PUSH
72574: LD_INT 1
72576: NEG
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PUSH
72582: EMPTY
72583: LIST
72584: LIST
72585: LIST
72586: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72587: LD_ADDR_VAR 0 16
72591: PUSH
72592: LD_INT 2
72594: NEG
72595: PUSH
72596: LD_INT 3
72598: NEG
72599: PUSH
72600: EMPTY
72601: LIST
72602: LIST
72603: PUSH
72604: LD_INT 3
72606: NEG
72607: PUSH
72608: LD_INT 2
72610: NEG
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: PUSH
72616: LD_INT 3
72618: NEG
72619: PUSH
72620: LD_INT 3
72622: NEG
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: LIST
72632: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72633: LD_ADDR_VAR 0 17
72637: PUSH
72638: LD_INT 1
72640: NEG
72641: PUSH
72642: LD_INT 3
72644: NEG
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PUSH
72650: LD_INT 0
72652: PUSH
72653: LD_INT 3
72655: NEG
72656: PUSH
72657: EMPTY
72658: LIST
72659: LIST
72660: PUSH
72661: LD_INT 1
72663: PUSH
72664: LD_INT 2
72666: NEG
72667: PUSH
72668: EMPTY
72669: LIST
72670: LIST
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: LIST
72676: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72677: LD_ADDR_VAR 0 18
72681: PUSH
72682: LD_INT 2
72684: PUSH
72685: LD_INT 1
72687: NEG
72688: PUSH
72689: EMPTY
72690: LIST
72691: LIST
72692: PUSH
72693: LD_INT 3
72695: PUSH
72696: LD_INT 0
72698: PUSH
72699: EMPTY
72700: LIST
72701: LIST
72702: PUSH
72703: LD_INT 3
72705: PUSH
72706: LD_INT 1
72708: PUSH
72709: EMPTY
72710: LIST
72711: LIST
72712: PUSH
72713: EMPTY
72714: LIST
72715: LIST
72716: LIST
72717: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72718: LD_ADDR_VAR 0 19
72722: PUSH
72723: LD_INT 3
72725: PUSH
72726: LD_INT 2
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 3
72735: PUSH
72736: LD_INT 3
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: LD_INT 2
72745: PUSH
72746: LD_INT 3
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: PUSH
72753: EMPTY
72754: LIST
72755: LIST
72756: LIST
72757: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
72758: LD_ADDR_VAR 0 20
72762: PUSH
72763: LD_INT 1
72765: PUSH
72766: LD_INT 3
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: LD_INT 0
72775: PUSH
72776: LD_INT 3
72778: PUSH
72779: EMPTY
72780: LIST
72781: LIST
72782: PUSH
72783: LD_INT 1
72785: NEG
72786: PUSH
72787: LD_INT 2
72789: PUSH
72790: EMPTY
72791: LIST
72792: LIST
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: LIST
72798: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72799: LD_ADDR_VAR 0 21
72803: PUSH
72804: LD_INT 2
72806: NEG
72807: PUSH
72808: LD_INT 1
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: LD_INT 3
72817: NEG
72818: PUSH
72819: LD_INT 0
72821: PUSH
72822: EMPTY
72823: LIST
72824: LIST
72825: PUSH
72826: LD_INT 3
72828: NEG
72829: PUSH
72830: LD_INT 1
72832: NEG
72833: PUSH
72834: EMPTY
72835: LIST
72836: LIST
72837: PUSH
72838: EMPTY
72839: LIST
72840: LIST
72841: LIST
72842: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72843: LD_ADDR_VAR 0 22
72847: PUSH
72848: LD_INT 2
72850: NEG
72851: PUSH
72852: LD_INT 3
72854: NEG
72855: PUSH
72856: EMPTY
72857: LIST
72858: LIST
72859: PUSH
72860: LD_INT 3
72862: NEG
72863: PUSH
72864: LD_INT 2
72866: NEG
72867: PUSH
72868: EMPTY
72869: LIST
72870: LIST
72871: PUSH
72872: LD_INT 3
72874: NEG
72875: PUSH
72876: LD_INT 3
72878: NEG
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: EMPTY
72885: LIST
72886: LIST
72887: LIST
72888: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
72889: LD_ADDR_VAR 0 23
72893: PUSH
72894: LD_INT 0
72896: PUSH
72897: LD_INT 3
72899: NEG
72900: PUSH
72901: EMPTY
72902: LIST
72903: LIST
72904: PUSH
72905: LD_INT 1
72907: NEG
72908: PUSH
72909: LD_INT 4
72911: NEG
72912: PUSH
72913: EMPTY
72914: LIST
72915: LIST
72916: PUSH
72917: LD_INT 1
72919: PUSH
72920: LD_INT 3
72922: NEG
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: PUSH
72928: EMPTY
72929: LIST
72930: LIST
72931: LIST
72932: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
72933: LD_ADDR_VAR 0 24
72937: PUSH
72938: LD_INT 3
72940: PUSH
72941: LD_INT 0
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: LD_INT 3
72950: PUSH
72951: LD_INT 1
72953: NEG
72954: PUSH
72955: EMPTY
72956: LIST
72957: LIST
72958: PUSH
72959: LD_INT 4
72961: PUSH
72962: LD_INT 1
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: LIST
72973: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
72974: LD_ADDR_VAR 0 25
72978: PUSH
72979: LD_INT 3
72981: PUSH
72982: LD_INT 3
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: LD_INT 4
72991: PUSH
72992: LD_INT 3
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: PUSH
72999: LD_INT 3
73001: PUSH
73002: LD_INT 4
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: PUSH
73009: EMPTY
73010: LIST
73011: LIST
73012: LIST
73013: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
73014: LD_ADDR_VAR 0 26
73018: PUSH
73019: LD_INT 0
73021: PUSH
73022: LD_INT 3
73024: PUSH
73025: EMPTY
73026: LIST
73027: LIST
73028: PUSH
73029: LD_INT 1
73031: PUSH
73032: LD_INT 4
73034: PUSH
73035: EMPTY
73036: LIST
73037: LIST
73038: PUSH
73039: LD_INT 1
73041: NEG
73042: PUSH
73043: LD_INT 3
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PUSH
73050: EMPTY
73051: LIST
73052: LIST
73053: LIST
73054: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
73055: LD_ADDR_VAR 0 27
73059: PUSH
73060: LD_INT 3
73062: NEG
73063: PUSH
73064: LD_INT 0
73066: PUSH
73067: EMPTY
73068: LIST
73069: LIST
73070: PUSH
73071: LD_INT 3
73073: NEG
73074: PUSH
73075: LD_INT 1
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: PUSH
73082: LD_INT 4
73084: NEG
73085: PUSH
73086: LD_INT 1
73088: NEG
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: LIST
73098: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
73099: LD_ADDR_VAR 0 28
73103: PUSH
73104: LD_INT 3
73106: NEG
73107: PUSH
73108: LD_INT 3
73110: NEG
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 3
73118: NEG
73119: PUSH
73120: LD_INT 4
73122: NEG
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: PUSH
73128: LD_INT 4
73130: NEG
73131: PUSH
73132: LD_INT 3
73134: NEG
73135: PUSH
73136: EMPTY
73137: LIST
73138: LIST
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: LIST
73144: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
73145: LD_ADDR_VAR 0 29
73149: PUSH
73150: LD_INT 1
73152: NEG
73153: PUSH
73154: LD_INT 3
73156: NEG
73157: PUSH
73158: EMPTY
73159: LIST
73160: LIST
73161: PUSH
73162: LD_INT 0
73164: PUSH
73165: LD_INT 3
73167: NEG
73168: PUSH
73169: EMPTY
73170: LIST
73171: LIST
73172: PUSH
73173: LD_INT 1
73175: PUSH
73176: LD_INT 2
73178: NEG
73179: PUSH
73180: EMPTY
73181: LIST
73182: LIST
73183: PUSH
73184: LD_INT 1
73186: NEG
73187: PUSH
73188: LD_INT 4
73190: NEG
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PUSH
73196: LD_INT 0
73198: PUSH
73199: LD_INT 4
73201: NEG
73202: PUSH
73203: EMPTY
73204: LIST
73205: LIST
73206: PUSH
73207: LD_INT 1
73209: PUSH
73210: LD_INT 3
73212: NEG
73213: PUSH
73214: EMPTY
73215: LIST
73216: LIST
73217: PUSH
73218: LD_INT 1
73220: NEG
73221: PUSH
73222: LD_INT 5
73224: NEG
73225: PUSH
73226: EMPTY
73227: LIST
73228: LIST
73229: PUSH
73230: LD_INT 0
73232: PUSH
73233: LD_INT 5
73235: NEG
73236: PUSH
73237: EMPTY
73238: LIST
73239: LIST
73240: PUSH
73241: LD_INT 1
73243: PUSH
73244: LD_INT 4
73246: NEG
73247: PUSH
73248: EMPTY
73249: LIST
73250: LIST
73251: PUSH
73252: LD_INT 1
73254: NEG
73255: PUSH
73256: LD_INT 6
73258: NEG
73259: PUSH
73260: EMPTY
73261: LIST
73262: LIST
73263: PUSH
73264: LD_INT 0
73266: PUSH
73267: LD_INT 6
73269: NEG
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 1
73277: PUSH
73278: LD_INT 5
73280: NEG
73281: PUSH
73282: EMPTY
73283: LIST
73284: LIST
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: LIST
73294: LIST
73295: LIST
73296: LIST
73297: LIST
73298: LIST
73299: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
73300: LD_ADDR_VAR 0 30
73304: PUSH
73305: LD_INT 2
73307: PUSH
73308: LD_INT 1
73310: NEG
73311: PUSH
73312: EMPTY
73313: LIST
73314: LIST
73315: PUSH
73316: LD_INT 3
73318: PUSH
73319: LD_INT 0
73321: PUSH
73322: EMPTY
73323: LIST
73324: LIST
73325: PUSH
73326: LD_INT 3
73328: PUSH
73329: LD_INT 1
73331: PUSH
73332: EMPTY
73333: LIST
73334: LIST
73335: PUSH
73336: LD_INT 3
73338: PUSH
73339: LD_INT 1
73341: NEG
73342: PUSH
73343: EMPTY
73344: LIST
73345: LIST
73346: PUSH
73347: LD_INT 4
73349: PUSH
73350: LD_INT 0
73352: PUSH
73353: EMPTY
73354: LIST
73355: LIST
73356: PUSH
73357: LD_INT 4
73359: PUSH
73360: LD_INT 1
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: LD_INT 4
73369: PUSH
73370: LD_INT 1
73372: NEG
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: PUSH
73378: LD_INT 5
73380: PUSH
73381: LD_INT 0
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: LD_INT 5
73390: PUSH
73391: LD_INT 1
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 5
73400: PUSH
73401: LD_INT 1
73403: NEG
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 6
73411: PUSH
73412: LD_INT 0
73414: PUSH
73415: EMPTY
73416: LIST
73417: LIST
73418: PUSH
73419: LD_INT 6
73421: PUSH
73422: LD_INT 1
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: LIST
73433: LIST
73434: LIST
73435: LIST
73436: LIST
73437: LIST
73438: LIST
73439: LIST
73440: LIST
73441: LIST
73442: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
73443: LD_ADDR_VAR 0 31
73447: PUSH
73448: LD_INT 3
73450: PUSH
73451: LD_INT 2
73453: PUSH
73454: EMPTY
73455: LIST
73456: LIST
73457: PUSH
73458: LD_INT 3
73460: PUSH
73461: LD_INT 3
73463: PUSH
73464: EMPTY
73465: LIST
73466: LIST
73467: PUSH
73468: LD_INT 2
73470: PUSH
73471: LD_INT 3
73473: PUSH
73474: EMPTY
73475: LIST
73476: LIST
73477: PUSH
73478: LD_INT 4
73480: PUSH
73481: LD_INT 3
73483: PUSH
73484: EMPTY
73485: LIST
73486: LIST
73487: PUSH
73488: LD_INT 4
73490: PUSH
73491: LD_INT 4
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: LD_INT 3
73500: PUSH
73501: LD_INT 4
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: LD_INT 5
73510: PUSH
73511: LD_INT 4
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: PUSH
73518: LD_INT 5
73520: PUSH
73521: LD_INT 5
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: PUSH
73528: LD_INT 4
73530: PUSH
73531: LD_INT 5
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: LD_INT 6
73540: PUSH
73541: LD_INT 5
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: LD_INT 6
73550: PUSH
73551: LD_INT 6
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: PUSH
73558: LD_INT 5
73560: PUSH
73561: LD_INT 6
73563: PUSH
73564: EMPTY
73565: LIST
73566: LIST
73567: PUSH
73568: EMPTY
73569: LIST
73570: LIST
73571: LIST
73572: LIST
73573: LIST
73574: LIST
73575: LIST
73576: LIST
73577: LIST
73578: LIST
73579: LIST
73580: LIST
73581: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
73582: LD_ADDR_VAR 0 32
73586: PUSH
73587: LD_INT 1
73589: PUSH
73590: LD_INT 3
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: LD_INT 0
73599: PUSH
73600: LD_INT 3
73602: PUSH
73603: EMPTY
73604: LIST
73605: LIST
73606: PUSH
73607: LD_INT 1
73609: NEG
73610: PUSH
73611: LD_INT 2
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PUSH
73618: LD_INT 1
73620: PUSH
73621: LD_INT 4
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 0
73630: PUSH
73631: LD_INT 4
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: PUSH
73638: LD_INT 1
73640: NEG
73641: PUSH
73642: LD_INT 3
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: LD_INT 1
73651: PUSH
73652: LD_INT 5
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: PUSH
73659: LD_INT 0
73661: PUSH
73662: LD_INT 5
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 1
73671: NEG
73672: PUSH
73673: LD_INT 4
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: PUSH
73680: LD_INT 1
73682: PUSH
73683: LD_INT 6
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: PUSH
73690: LD_INT 0
73692: PUSH
73693: LD_INT 6
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: LD_INT 1
73702: NEG
73703: PUSH
73704: LD_INT 5
73706: PUSH
73707: EMPTY
73708: LIST
73709: LIST
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: LIST
73715: LIST
73716: LIST
73717: LIST
73718: LIST
73719: LIST
73720: LIST
73721: LIST
73722: LIST
73723: LIST
73724: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
73725: LD_ADDR_VAR 0 33
73729: PUSH
73730: LD_INT 2
73732: NEG
73733: PUSH
73734: LD_INT 1
73736: PUSH
73737: EMPTY
73738: LIST
73739: LIST
73740: PUSH
73741: LD_INT 3
73743: NEG
73744: PUSH
73745: LD_INT 0
73747: PUSH
73748: EMPTY
73749: LIST
73750: LIST
73751: PUSH
73752: LD_INT 3
73754: NEG
73755: PUSH
73756: LD_INT 1
73758: NEG
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: PUSH
73764: LD_INT 3
73766: NEG
73767: PUSH
73768: LD_INT 1
73770: PUSH
73771: EMPTY
73772: LIST
73773: LIST
73774: PUSH
73775: LD_INT 4
73777: NEG
73778: PUSH
73779: LD_INT 0
73781: PUSH
73782: EMPTY
73783: LIST
73784: LIST
73785: PUSH
73786: LD_INT 4
73788: NEG
73789: PUSH
73790: LD_INT 1
73792: NEG
73793: PUSH
73794: EMPTY
73795: LIST
73796: LIST
73797: PUSH
73798: LD_INT 4
73800: NEG
73801: PUSH
73802: LD_INT 1
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: LD_INT 5
73811: NEG
73812: PUSH
73813: LD_INT 0
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: PUSH
73820: LD_INT 5
73822: NEG
73823: PUSH
73824: LD_INT 1
73826: NEG
73827: PUSH
73828: EMPTY
73829: LIST
73830: LIST
73831: PUSH
73832: LD_INT 5
73834: NEG
73835: PUSH
73836: LD_INT 1
73838: PUSH
73839: EMPTY
73840: LIST
73841: LIST
73842: PUSH
73843: LD_INT 6
73845: NEG
73846: PUSH
73847: LD_INT 0
73849: PUSH
73850: EMPTY
73851: LIST
73852: LIST
73853: PUSH
73854: LD_INT 6
73856: NEG
73857: PUSH
73858: LD_INT 1
73860: NEG
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: LIST
73870: LIST
73871: LIST
73872: LIST
73873: LIST
73874: LIST
73875: LIST
73876: LIST
73877: LIST
73878: LIST
73879: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
73880: LD_ADDR_VAR 0 34
73884: PUSH
73885: LD_INT 2
73887: NEG
73888: PUSH
73889: LD_INT 3
73891: NEG
73892: PUSH
73893: EMPTY
73894: LIST
73895: LIST
73896: PUSH
73897: LD_INT 3
73899: NEG
73900: PUSH
73901: LD_INT 2
73903: NEG
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: PUSH
73909: LD_INT 3
73911: NEG
73912: PUSH
73913: LD_INT 3
73915: NEG
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: PUSH
73921: LD_INT 3
73923: NEG
73924: PUSH
73925: LD_INT 4
73927: NEG
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 4
73935: NEG
73936: PUSH
73937: LD_INT 3
73939: NEG
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: LD_INT 4
73947: NEG
73948: PUSH
73949: LD_INT 4
73951: NEG
73952: PUSH
73953: EMPTY
73954: LIST
73955: LIST
73956: PUSH
73957: LD_INT 4
73959: NEG
73960: PUSH
73961: LD_INT 5
73963: NEG
73964: PUSH
73965: EMPTY
73966: LIST
73967: LIST
73968: PUSH
73969: LD_INT 5
73971: NEG
73972: PUSH
73973: LD_INT 4
73975: NEG
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: PUSH
73981: LD_INT 5
73983: NEG
73984: PUSH
73985: LD_INT 5
73987: NEG
73988: PUSH
73989: EMPTY
73990: LIST
73991: LIST
73992: PUSH
73993: LD_INT 5
73995: NEG
73996: PUSH
73997: LD_INT 6
73999: NEG
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: PUSH
74005: LD_INT 6
74007: NEG
74008: PUSH
74009: LD_INT 5
74011: NEG
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 6
74019: NEG
74020: PUSH
74021: LD_INT 6
74023: NEG
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: LIST
74033: LIST
74034: LIST
74035: LIST
74036: LIST
74037: LIST
74038: LIST
74039: LIST
74040: LIST
74041: LIST
74042: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
74043: LD_ADDR_VAR 0 41
74047: PUSH
74048: LD_INT 0
74050: PUSH
74051: LD_INT 2
74053: NEG
74054: PUSH
74055: EMPTY
74056: LIST
74057: LIST
74058: PUSH
74059: LD_INT 1
74061: NEG
74062: PUSH
74063: LD_INT 3
74065: NEG
74066: PUSH
74067: EMPTY
74068: LIST
74069: LIST
74070: PUSH
74071: LD_INT 1
74073: PUSH
74074: LD_INT 2
74076: NEG
74077: PUSH
74078: EMPTY
74079: LIST
74080: LIST
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: LIST
74086: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
74087: LD_ADDR_VAR 0 42
74091: PUSH
74092: LD_INT 2
74094: PUSH
74095: LD_INT 0
74097: PUSH
74098: EMPTY
74099: LIST
74100: LIST
74101: PUSH
74102: LD_INT 2
74104: PUSH
74105: LD_INT 1
74107: NEG
74108: PUSH
74109: EMPTY
74110: LIST
74111: LIST
74112: PUSH
74113: LD_INT 3
74115: PUSH
74116: LD_INT 1
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: PUSH
74123: EMPTY
74124: LIST
74125: LIST
74126: LIST
74127: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
74128: LD_ADDR_VAR 0 43
74132: PUSH
74133: LD_INT 2
74135: PUSH
74136: LD_INT 2
74138: PUSH
74139: EMPTY
74140: LIST
74141: LIST
74142: PUSH
74143: LD_INT 3
74145: PUSH
74146: LD_INT 2
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: PUSH
74153: LD_INT 2
74155: PUSH
74156: LD_INT 3
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: EMPTY
74164: LIST
74165: LIST
74166: LIST
74167: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
74168: LD_ADDR_VAR 0 44
74172: PUSH
74173: LD_INT 0
74175: PUSH
74176: LD_INT 2
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: PUSH
74183: LD_INT 1
74185: PUSH
74186: LD_INT 3
74188: PUSH
74189: EMPTY
74190: LIST
74191: LIST
74192: PUSH
74193: LD_INT 1
74195: NEG
74196: PUSH
74197: LD_INT 2
74199: PUSH
74200: EMPTY
74201: LIST
74202: LIST
74203: PUSH
74204: EMPTY
74205: LIST
74206: LIST
74207: LIST
74208: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
74209: LD_ADDR_VAR 0 45
74213: PUSH
74214: LD_INT 2
74216: NEG
74217: PUSH
74218: LD_INT 0
74220: PUSH
74221: EMPTY
74222: LIST
74223: LIST
74224: PUSH
74225: LD_INT 2
74227: NEG
74228: PUSH
74229: LD_INT 1
74231: PUSH
74232: EMPTY
74233: LIST
74234: LIST
74235: PUSH
74236: LD_INT 3
74238: NEG
74239: PUSH
74240: LD_INT 1
74242: NEG
74243: PUSH
74244: EMPTY
74245: LIST
74246: LIST
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: LIST
74252: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
74253: LD_ADDR_VAR 0 46
74257: PUSH
74258: LD_INT 2
74260: NEG
74261: PUSH
74262: LD_INT 2
74264: NEG
74265: PUSH
74266: EMPTY
74267: LIST
74268: LIST
74269: PUSH
74270: LD_INT 2
74272: NEG
74273: PUSH
74274: LD_INT 3
74276: NEG
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: PUSH
74282: LD_INT 3
74284: NEG
74285: PUSH
74286: LD_INT 2
74288: NEG
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: LIST
74298: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
74299: LD_ADDR_VAR 0 47
74303: PUSH
74304: LD_INT 2
74306: NEG
74307: PUSH
74308: LD_INT 3
74310: NEG
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: PUSH
74316: LD_INT 1
74318: NEG
74319: PUSH
74320: LD_INT 3
74322: NEG
74323: PUSH
74324: EMPTY
74325: LIST
74326: LIST
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
74332: LD_ADDR_VAR 0 48
74336: PUSH
74337: LD_INT 1
74339: PUSH
74340: LD_INT 2
74342: NEG
74343: PUSH
74344: EMPTY
74345: LIST
74346: LIST
74347: PUSH
74348: LD_INT 2
74350: PUSH
74351: LD_INT 1
74353: NEG
74354: PUSH
74355: EMPTY
74356: LIST
74357: LIST
74358: PUSH
74359: EMPTY
74360: LIST
74361: LIST
74362: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
74363: LD_ADDR_VAR 0 49
74367: PUSH
74368: LD_INT 3
74370: PUSH
74371: LD_INT 1
74373: PUSH
74374: EMPTY
74375: LIST
74376: LIST
74377: PUSH
74378: LD_INT 3
74380: PUSH
74381: LD_INT 2
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: PUSH
74388: EMPTY
74389: LIST
74390: LIST
74391: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
74392: LD_ADDR_VAR 0 50
74396: PUSH
74397: LD_INT 2
74399: PUSH
74400: LD_INT 3
74402: PUSH
74403: EMPTY
74404: LIST
74405: LIST
74406: PUSH
74407: LD_INT 1
74409: PUSH
74410: LD_INT 3
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: PUSH
74417: EMPTY
74418: LIST
74419: LIST
74420: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
74421: LD_ADDR_VAR 0 51
74425: PUSH
74426: LD_INT 1
74428: NEG
74429: PUSH
74430: LD_INT 2
74432: PUSH
74433: EMPTY
74434: LIST
74435: LIST
74436: PUSH
74437: LD_INT 2
74439: NEG
74440: PUSH
74441: LD_INT 1
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: PUSH
74448: EMPTY
74449: LIST
74450: LIST
74451: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
74452: LD_ADDR_VAR 0 52
74456: PUSH
74457: LD_INT 3
74459: NEG
74460: PUSH
74461: LD_INT 1
74463: NEG
74464: PUSH
74465: EMPTY
74466: LIST
74467: LIST
74468: PUSH
74469: LD_INT 3
74471: NEG
74472: PUSH
74473: LD_INT 2
74475: NEG
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74485: LD_ADDR_VAR 0 53
74489: PUSH
74490: LD_INT 1
74492: NEG
74493: PUSH
74494: LD_INT 3
74496: NEG
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PUSH
74502: LD_INT 0
74504: PUSH
74505: LD_INT 3
74507: NEG
74508: PUSH
74509: EMPTY
74510: LIST
74511: LIST
74512: PUSH
74513: LD_INT 1
74515: PUSH
74516: LD_INT 2
74518: NEG
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: LIST
74528: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74529: LD_ADDR_VAR 0 54
74533: PUSH
74534: LD_INT 2
74536: PUSH
74537: LD_INT 1
74539: NEG
74540: PUSH
74541: EMPTY
74542: LIST
74543: LIST
74544: PUSH
74545: LD_INT 3
74547: PUSH
74548: LD_INT 0
74550: PUSH
74551: EMPTY
74552: LIST
74553: LIST
74554: PUSH
74555: LD_INT 3
74557: PUSH
74558: LD_INT 1
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: LIST
74569: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74570: LD_ADDR_VAR 0 55
74574: PUSH
74575: LD_INT 3
74577: PUSH
74578: LD_INT 2
74580: PUSH
74581: EMPTY
74582: LIST
74583: LIST
74584: PUSH
74585: LD_INT 3
74587: PUSH
74588: LD_INT 3
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: PUSH
74595: LD_INT 2
74597: PUSH
74598: LD_INT 3
74600: PUSH
74601: EMPTY
74602: LIST
74603: LIST
74604: PUSH
74605: EMPTY
74606: LIST
74607: LIST
74608: LIST
74609: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74610: LD_ADDR_VAR 0 56
74614: PUSH
74615: LD_INT 1
74617: PUSH
74618: LD_INT 3
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PUSH
74625: LD_INT 0
74627: PUSH
74628: LD_INT 3
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: PUSH
74635: LD_INT 1
74637: NEG
74638: PUSH
74639: LD_INT 2
74641: PUSH
74642: EMPTY
74643: LIST
74644: LIST
74645: PUSH
74646: EMPTY
74647: LIST
74648: LIST
74649: LIST
74650: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74651: LD_ADDR_VAR 0 57
74655: PUSH
74656: LD_INT 2
74658: NEG
74659: PUSH
74660: LD_INT 1
74662: PUSH
74663: EMPTY
74664: LIST
74665: LIST
74666: PUSH
74667: LD_INT 3
74669: NEG
74670: PUSH
74671: LD_INT 0
74673: PUSH
74674: EMPTY
74675: LIST
74676: LIST
74677: PUSH
74678: LD_INT 3
74680: NEG
74681: PUSH
74682: LD_INT 1
74684: NEG
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: LIST
74694: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74695: LD_ADDR_VAR 0 58
74699: PUSH
74700: LD_INT 2
74702: NEG
74703: PUSH
74704: LD_INT 3
74706: NEG
74707: PUSH
74708: EMPTY
74709: LIST
74710: LIST
74711: PUSH
74712: LD_INT 3
74714: NEG
74715: PUSH
74716: LD_INT 2
74718: NEG
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: PUSH
74724: LD_INT 3
74726: NEG
74727: PUSH
74728: LD_INT 3
74730: NEG
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: LIST
74740: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
74741: LD_ADDR_VAR 0 59
74745: PUSH
74746: LD_INT 1
74748: NEG
74749: PUSH
74750: LD_INT 2
74752: NEG
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: PUSH
74758: LD_INT 0
74760: PUSH
74761: LD_INT 2
74763: NEG
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PUSH
74769: LD_INT 1
74771: PUSH
74772: LD_INT 1
74774: NEG
74775: PUSH
74776: EMPTY
74777: LIST
74778: LIST
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: LIST
74784: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74785: LD_ADDR_VAR 0 60
74789: PUSH
74790: LD_INT 1
74792: PUSH
74793: LD_INT 1
74795: NEG
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PUSH
74801: LD_INT 2
74803: PUSH
74804: LD_INT 0
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 2
74813: PUSH
74814: LD_INT 1
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: LIST
74825: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74826: LD_ADDR_VAR 0 61
74830: PUSH
74831: LD_INT 2
74833: PUSH
74834: LD_INT 1
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PUSH
74841: LD_INT 2
74843: PUSH
74844: LD_INT 2
74846: PUSH
74847: EMPTY
74848: LIST
74849: LIST
74850: PUSH
74851: LD_INT 1
74853: PUSH
74854: LD_INT 2
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: LIST
74865: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74866: LD_ADDR_VAR 0 62
74870: PUSH
74871: LD_INT 1
74873: PUSH
74874: LD_INT 2
74876: PUSH
74877: EMPTY
74878: LIST
74879: LIST
74880: PUSH
74881: LD_INT 0
74883: PUSH
74884: LD_INT 2
74886: PUSH
74887: EMPTY
74888: LIST
74889: LIST
74890: PUSH
74891: LD_INT 1
74893: NEG
74894: PUSH
74895: LD_INT 1
74897: PUSH
74898: EMPTY
74899: LIST
74900: LIST
74901: PUSH
74902: EMPTY
74903: LIST
74904: LIST
74905: LIST
74906: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74907: LD_ADDR_VAR 0 63
74911: PUSH
74912: LD_INT 1
74914: NEG
74915: PUSH
74916: LD_INT 1
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: PUSH
74923: LD_INT 2
74925: NEG
74926: PUSH
74927: LD_INT 0
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 2
74936: NEG
74937: PUSH
74938: LD_INT 1
74940: NEG
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: LIST
74950: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74951: LD_ADDR_VAR 0 64
74955: PUSH
74956: LD_INT 1
74958: NEG
74959: PUSH
74960: LD_INT 2
74962: NEG
74963: PUSH
74964: EMPTY
74965: LIST
74966: LIST
74967: PUSH
74968: LD_INT 2
74970: NEG
74971: PUSH
74972: LD_INT 1
74974: NEG
74975: PUSH
74976: EMPTY
74977: LIST
74978: LIST
74979: PUSH
74980: LD_INT 2
74982: NEG
74983: PUSH
74984: LD_INT 2
74986: NEG
74987: PUSH
74988: EMPTY
74989: LIST
74990: LIST
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: LIST
74996: ST_TO_ADDR
// end ; 2 :
74997: GO 78263
74999: LD_INT 2
75001: DOUBLE
75002: EQUAL
75003: IFTRUE 75007
75005: GO 78262
75007: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
75008: LD_ADDR_VAR 0 29
75012: PUSH
75013: LD_INT 4
75015: PUSH
75016: LD_INT 0
75018: PUSH
75019: EMPTY
75020: LIST
75021: LIST
75022: PUSH
75023: LD_INT 4
75025: PUSH
75026: LD_INT 1
75028: NEG
75029: PUSH
75030: EMPTY
75031: LIST
75032: LIST
75033: PUSH
75034: LD_INT 5
75036: PUSH
75037: LD_INT 0
75039: PUSH
75040: EMPTY
75041: LIST
75042: LIST
75043: PUSH
75044: LD_INT 5
75046: PUSH
75047: LD_INT 1
75049: PUSH
75050: EMPTY
75051: LIST
75052: LIST
75053: PUSH
75054: LD_INT 4
75056: PUSH
75057: LD_INT 1
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: PUSH
75064: LD_INT 3
75066: PUSH
75067: LD_INT 0
75069: PUSH
75070: EMPTY
75071: LIST
75072: LIST
75073: PUSH
75074: LD_INT 3
75076: PUSH
75077: LD_INT 1
75079: NEG
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: PUSH
75085: LD_INT 3
75087: PUSH
75088: LD_INT 2
75090: NEG
75091: PUSH
75092: EMPTY
75093: LIST
75094: LIST
75095: PUSH
75096: LD_INT 5
75098: PUSH
75099: LD_INT 2
75101: PUSH
75102: EMPTY
75103: LIST
75104: LIST
75105: PUSH
75106: LD_INT 3
75108: PUSH
75109: LD_INT 3
75111: PUSH
75112: EMPTY
75113: LIST
75114: LIST
75115: PUSH
75116: LD_INT 3
75118: PUSH
75119: LD_INT 2
75121: PUSH
75122: EMPTY
75123: LIST
75124: LIST
75125: PUSH
75126: LD_INT 4
75128: PUSH
75129: LD_INT 3
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 4
75138: PUSH
75139: LD_INT 4
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PUSH
75146: LD_INT 3
75148: PUSH
75149: LD_INT 4
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: PUSH
75156: LD_INT 2
75158: PUSH
75159: LD_INT 3
75161: PUSH
75162: EMPTY
75163: LIST
75164: LIST
75165: PUSH
75166: LD_INT 2
75168: PUSH
75169: LD_INT 2
75171: PUSH
75172: EMPTY
75173: LIST
75174: LIST
75175: PUSH
75176: LD_INT 4
75178: PUSH
75179: LD_INT 2
75181: PUSH
75182: EMPTY
75183: LIST
75184: LIST
75185: PUSH
75186: LD_INT 2
75188: PUSH
75189: LD_INT 4
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: LD_INT 0
75198: PUSH
75199: LD_INT 4
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: PUSH
75206: LD_INT 0
75208: PUSH
75209: LD_INT 3
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: PUSH
75216: LD_INT 1
75218: PUSH
75219: LD_INT 4
75221: PUSH
75222: EMPTY
75223: LIST
75224: LIST
75225: PUSH
75226: LD_INT 1
75228: PUSH
75229: LD_INT 5
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: PUSH
75236: LD_INT 0
75238: PUSH
75239: LD_INT 5
75241: PUSH
75242: EMPTY
75243: LIST
75244: LIST
75245: PUSH
75246: LD_INT 1
75248: NEG
75249: PUSH
75250: LD_INT 4
75252: PUSH
75253: EMPTY
75254: LIST
75255: LIST
75256: PUSH
75257: LD_INT 1
75259: NEG
75260: PUSH
75261: LD_INT 3
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: PUSH
75268: LD_INT 2
75270: PUSH
75271: LD_INT 5
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: PUSH
75278: LD_INT 2
75280: NEG
75281: PUSH
75282: LD_INT 3
75284: PUSH
75285: EMPTY
75286: LIST
75287: LIST
75288: PUSH
75289: LD_INT 3
75291: NEG
75292: PUSH
75293: LD_INT 0
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 3
75302: NEG
75303: PUSH
75304: LD_INT 1
75306: NEG
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 2
75314: NEG
75315: PUSH
75316: LD_INT 0
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_INT 2
75325: NEG
75326: PUSH
75327: LD_INT 1
75329: PUSH
75330: EMPTY
75331: LIST
75332: LIST
75333: PUSH
75334: LD_INT 3
75336: NEG
75337: PUSH
75338: LD_INT 1
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: LD_INT 4
75347: NEG
75348: PUSH
75349: LD_INT 0
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: PUSH
75356: LD_INT 4
75358: NEG
75359: PUSH
75360: LD_INT 1
75362: NEG
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: PUSH
75368: LD_INT 4
75370: NEG
75371: PUSH
75372: LD_INT 2
75374: NEG
75375: PUSH
75376: EMPTY
75377: LIST
75378: LIST
75379: PUSH
75380: LD_INT 2
75382: NEG
75383: PUSH
75384: LD_INT 2
75386: PUSH
75387: EMPTY
75388: LIST
75389: LIST
75390: PUSH
75391: LD_INT 4
75393: NEG
75394: PUSH
75395: LD_INT 4
75397: NEG
75398: PUSH
75399: EMPTY
75400: LIST
75401: LIST
75402: PUSH
75403: LD_INT 4
75405: NEG
75406: PUSH
75407: LD_INT 5
75409: NEG
75410: PUSH
75411: EMPTY
75412: LIST
75413: LIST
75414: PUSH
75415: LD_INT 3
75417: NEG
75418: PUSH
75419: LD_INT 4
75421: NEG
75422: PUSH
75423: EMPTY
75424: LIST
75425: LIST
75426: PUSH
75427: LD_INT 3
75429: NEG
75430: PUSH
75431: LD_INT 3
75433: NEG
75434: PUSH
75435: EMPTY
75436: LIST
75437: LIST
75438: PUSH
75439: LD_INT 4
75441: NEG
75442: PUSH
75443: LD_INT 3
75445: NEG
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: LD_INT 5
75453: NEG
75454: PUSH
75455: LD_INT 4
75457: NEG
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 5
75465: NEG
75466: PUSH
75467: LD_INT 5
75469: NEG
75470: PUSH
75471: EMPTY
75472: LIST
75473: LIST
75474: PUSH
75475: LD_INT 3
75477: NEG
75478: PUSH
75479: LD_INT 5
75481: NEG
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: PUSH
75487: LD_INT 5
75489: NEG
75490: PUSH
75491: LD_INT 3
75493: NEG
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: EMPTY
75500: LIST
75501: LIST
75502: LIST
75503: LIST
75504: LIST
75505: LIST
75506: LIST
75507: LIST
75508: LIST
75509: LIST
75510: LIST
75511: LIST
75512: LIST
75513: LIST
75514: LIST
75515: LIST
75516: LIST
75517: LIST
75518: LIST
75519: LIST
75520: LIST
75521: LIST
75522: LIST
75523: LIST
75524: LIST
75525: LIST
75526: LIST
75527: LIST
75528: LIST
75529: LIST
75530: LIST
75531: LIST
75532: LIST
75533: LIST
75534: LIST
75535: LIST
75536: LIST
75537: LIST
75538: LIST
75539: LIST
75540: LIST
75541: LIST
75542: LIST
75543: LIST
75544: LIST
75545: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
75546: LD_ADDR_VAR 0 30
75550: PUSH
75551: LD_INT 4
75553: PUSH
75554: LD_INT 4
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: LD_INT 4
75563: PUSH
75564: LD_INT 3
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PUSH
75571: LD_INT 5
75573: PUSH
75574: LD_INT 4
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 5
75583: PUSH
75584: LD_INT 5
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 4
75593: PUSH
75594: LD_INT 5
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: LD_INT 3
75603: PUSH
75604: LD_INT 4
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: PUSH
75611: LD_INT 3
75613: PUSH
75614: LD_INT 3
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 5
75623: PUSH
75624: LD_INT 3
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: LD_INT 3
75633: PUSH
75634: LD_INT 5
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 0
75643: PUSH
75644: LD_INT 3
75646: PUSH
75647: EMPTY
75648: LIST
75649: LIST
75650: PUSH
75651: LD_INT 0
75653: PUSH
75654: LD_INT 2
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: LD_INT 1
75663: PUSH
75664: LD_INT 3
75666: PUSH
75667: EMPTY
75668: LIST
75669: LIST
75670: PUSH
75671: LD_INT 1
75673: PUSH
75674: LD_INT 4
75676: PUSH
75677: EMPTY
75678: LIST
75679: LIST
75680: PUSH
75681: LD_INT 0
75683: PUSH
75684: LD_INT 4
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: LD_INT 1
75693: NEG
75694: PUSH
75695: LD_INT 3
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: LD_INT 1
75704: NEG
75705: PUSH
75706: LD_INT 2
75708: PUSH
75709: EMPTY
75710: LIST
75711: LIST
75712: PUSH
75713: LD_INT 2
75715: PUSH
75716: LD_INT 4
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: PUSH
75723: LD_INT 2
75725: NEG
75726: PUSH
75727: LD_INT 2
75729: PUSH
75730: EMPTY
75731: LIST
75732: LIST
75733: PUSH
75734: LD_INT 4
75736: NEG
75737: PUSH
75738: LD_INT 0
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: LD_INT 4
75747: NEG
75748: PUSH
75749: LD_INT 1
75751: NEG
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PUSH
75757: LD_INT 3
75759: NEG
75760: PUSH
75761: LD_INT 0
75763: PUSH
75764: EMPTY
75765: LIST
75766: LIST
75767: PUSH
75768: LD_INT 3
75770: NEG
75771: PUSH
75772: LD_INT 1
75774: PUSH
75775: EMPTY
75776: LIST
75777: LIST
75778: PUSH
75779: LD_INT 4
75781: NEG
75782: PUSH
75783: LD_INT 1
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: PUSH
75790: LD_INT 5
75792: NEG
75793: PUSH
75794: LD_INT 0
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: LD_INT 5
75803: NEG
75804: PUSH
75805: LD_INT 1
75807: NEG
75808: PUSH
75809: EMPTY
75810: LIST
75811: LIST
75812: PUSH
75813: LD_INT 5
75815: NEG
75816: PUSH
75817: LD_INT 2
75819: NEG
75820: PUSH
75821: EMPTY
75822: LIST
75823: LIST
75824: PUSH
75825: LD_INT 3
75827: NEG
75828: PUSH
75829: LD_INT 2
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 3
75838: NEG
75839: PUSH
75840: LD_INT 3
75842: NEG
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: LD_INT 3
75850: NEG
75851: PUSH
75852: LD_INT 4
75854: NEG
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: LD_INT 2
75862: NEG
75863: PUSH
75864: LD_INT 3
75866: NEG
75867: PUSH
75868: EMPTY
75869: LIST
75870: LIST
75871: PUSH
75872: LD_INT 2
75874: NEG
75875: PUSH
75876: LD_INT 2
75878: NEG
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: PUSH
75884: LD_INT 3
75886: NEG
75887: PUSH
75888: LD_INT 2
75890: NEG
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PUSH
75896: LD_INT 4
75898: NEG
75899: PUSH
75900: LD_INT 3
75902: NEG
75903: PUSH
75904: EMPTY
75905: LIST
75906: LIST
75907: PUSH
75908: LD_INT 4
75910: NEG
75911: PUSH
75912: LD_INT 4
75914: NEG
75915: PUSH
75916: EMPTY
75917: LIST
75918: LIST
75919: PUSH
75920: LD_INT 2
75922: NEG
75923: PUSH
75924: LD_INT 4
75926: NEG
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: LD_INT 4
75934: NEG
75935: PUSH
75936: LD_INT 2
75938: NEG
75939: PUSH
75940: EMPTY
75941: LIST
75942: LIST
75943: PUSH
75944: LD_INT 0
75946: PUSH
75947: LD_INT 4
75949: NEG
75950: PUSH
75951: EMPTY
75952: LIST
75953: LIST
75954: PUSH
75955: LD_INT 0
75957: PUSH
75958: LD_INT 5
75960: NEG
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PUSH
75966: LD_INT 1
75968: PUSH
75969: LD_INT 4
75971: NEG
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 1
75979: PUSH
75980: LD_INT 3
75982: NEG
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PUSH
75988: LD_INT 0
75990: PUSH
75991: LD_INT 3
75993: NEG
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: PUSH
75999: LD_INT 1
76001: NEG
76002: PUSH
76003: LD_INT 4
76005: NEG
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: PUSH
76011: LD_INT 1
76013: NEG
76014: PUSH
76015: LD_INT 5
76017: NEG
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: PUSH
76023: LD_INT 2
76025: PUSH
76026: LD_INT 3
76028: NEG
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PUSH
76034: LD_INT 2
76036: NEG
76037: PUSH
76038: LD_INT 5
76040: NEG
76041: PUSH
76042: EMPTY
76043: LIST
76044: LIST
76045: PUSH
76046: EMPTY
76047: LIST
76048: LIST
76049: LIST
76050: LIST
76051: LIST
76052: LIST
76053: LIST
76054: LIST
76055: LIST
76056: LIST
76057: LIST
76058: LIST
76059: LIST
76060: LIST
76061: LIST
76062: LIST
76063: LIST
76064: LIST
76065: LIST
76066: LIST
76067: LIST
76068: LIST
76069: LIST
76070: LIST
76071: LIST
76072: LIST
76073: LIST
76074: LIST
76075: LIST
76076: LIST
76077: LIST
76078: LIST
76079: LIST
76080: LIST
76081: LIST
76082: LIST
76083: LIST
76084: LIST
76085: LIST
76086: LIST
76087: LIST
76088: LIST
76089: LIST
76090: LIST
76091: LIST
76092: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
76093: LD_ADDR_VAR 0 31
76097: PUSH
76098: LD_INT 0
76100: PUSH
76101: LD_INT 4
76103: PUSH
76104: EMPTY
76105: LIST
76106: LIST
76107: PUSH
76108: LD_INT 0
76110: PUSH
76111: LD_INT 3
76113: PUSH
76114: EMPTY
76115: LIST
76116: LIST
76117: PUSH
76118: LD_INT 1
76120: PUSH
76121: LD_INT 4
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: PUSH
76128: LD_INT 1
76130: PUSH
76131: LD_INT 5
76133: PUSH
76134: EMPTY
76135: LIST
76136: LIST
76137: PUSH
76138: LD_INT 0
76140: PUSH
76141: LD_INT 5
76143: PUSH
76144: EMPTY
76145: LIST
76146: LIST
76147: PUSH
76148: LD_INT 1
76150: NEG
76151: PUSH
76152: LD_INT 4
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: PUSH
76159: LD_INT 1
76161: NEG
76162: PUSH
76163: LD_INT 3
76165: PUSH
76166: EMPTY
76167: LIST
76168: LIST
76169: PUSH
76170: LD_INT 2
76172: PUSH
76173: LD_INT 5
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: PUSH
76180: LD_INT 2
76182: NEG
76183: PUSH
76184: LD_INT 3
76186: PUSH
76187: EMPTY
76188: LIST
76189: LIST
76190: PUSH
76191: LD_INT 3
76193: NEG
76194: PUSH
76195: LD_INT 0
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PUSH
76202: LD_INT 3
76204: NEG
76205: PUSH
76206: LD_INT 1
76208: NEG
76209: PUSH
76210: EMPTY
76211: LIST
76212: LIST
76213: PUSH
76214: LD_INT 2
76216: NEG
76217: PUSH
76218: LD_INT 0
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: PUSH
76225: LD_INT 2
76227: NEG
76228: PUSH
76229: LD_INT 1
76231: PUSH
76232: EMPTY
76233: LIST
76234: LIST
76235: PUSH
76236: LD_INT 3
76238: NEG
76239: PUSH
76240: LD_INT 1
76242: PUSH
76243: EMPTY
76244: LIST
76245: LIST
76246: PUSH
76247: LD_INT 4
76249: NEG
76250: PUSH
76251: LD_INT 0
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: PUSH
76258: LD_INT 4
76260: NEG
76261: PUSH
76262: LD_INT 1
76264: NEG
76265: PUSH
76266: EMPTY
76267: LIST
76268: LIST
76269: PUSH
76270: LD_INT 4
76272: NEG
76273: PUSH
76274: LD_INT 2
76276: NEG
76277: PUSH
76278: EMPTY
76279: LIST
76280: LIST
76281: PUSH
76282: LD_INT 2
76284: NEG
76285: PUSH
76286: LD_INT 2
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: LD_INT 4
76295: NEG
76296: PUSH
76297: LD_INT 4
76299: NEG
76300: PUSH
76301: EMPTY
76302: LIST
76303: LIST
76304: PUSH
76305: LD_INT 4
76307: NEG
76308: PUSH
76309: LD_INT 5
76311: NEG
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: PUSH
76317: LD_INT 3
76319: NEG
76320: PUSH
76321: LD_INT 4
76323: NEG
76324: PUSH
76325: EMPTY
76326: LIST
76327: LIST
76328: PUSH
76329: LD_INT 3
76331: NEG
76332: PUSH
76333: LD_INT 3
76335: NEG
76336: PUSH
76337: EMPTY
76338: LIST
76339: LIST
76340: PUSH
76341: LD_INT 4
76343: NEG
76344: PUSH
76345: LD_INT 3
76347: NEG
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 5
76355: NEG
76356: PUSH
76357: LD_INT 4
76359: NEG
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: LD_INT 5
76367: NEG
76368: PUSH
76369: LD_INT 5
76371: NEG
76372: PUSH
76373: EMPTY
76374: LIST
76375: LIST
76376: PUSH
76377: LD_INT 3
76379: NEG
76380: PUSH
76381: LD_INT 5
76383: NEG
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: LD_INT 5
76391: NEG
76392: PUSH
76393: LD_INT 3
76395: NEG
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: PUSH
76401: LD_INT 0
76403: PUSH
76404: LD_INT 3
76406: NEG
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: PUSH
76412: LD_INT 0
76414: PUSH
76415: LD_INT 4
76417: NEG
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PUSH
76423: LD_INT 1
76425: PUSH
76426: LD_INT 3
76428: NEG
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: PUSH
76434: LD_INT 1
76436: PUSH
76437: LD_INT 2
76439: NEG
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: PUSH
76445: LD_INT 0
76447: PUSH
76448: LD_INT 2
76450: NEG
76451: PUSH
76452: EMPTY
76453: LIST
76454: LIST
76455: PUSH
76456: LD_INT 1
76458: NEG
76459: PUSH
76460: LD_INT 3
76462: NEG
76463: PUSH
76464: EMPTY
76465: LIST
76466: LIST
76467: PUSH
76468: LD_INT 1
76470: NEG
76471: PUSH
76472: LD_INT 4
76474: NEG
76475: PUSH
76476: EMPTY
76477: LIST
76478: LIST
76479: PUSH
76480: LD_INT 2
76482: PUSH
76483: LD_INT 2
76485: NEG
76486: PUSH
76487: EMPTY
76488: LIST
76489: LIST
76490: PUSH
76491: LD_INT 2
76493: NEG
76494: PUSH
76495: LD_INT 4
76497: NEG
76498: PUSH
76499: EMPTY
76500: LIST
76501: LIST
76502: PUSH
76503: LD_INT 4
76505: PUSH
76506: LD_INT 0
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: PUSH
76513: LD_INT 4
76515: PUSH
76516: LD_INT 1
76518: NEG
76519: PUSH
76520: EMPTY
76521: LIST
76522: LIST
76523: PUSH
76524: LD_INT 5
76526: PUSH
76527: LD_INT 0
76529: PUSH
76530: EMPTY
76531: LIST
76532: LIST
76533: PUSH
76534: LD_INT 5
76536: PUSH
76537: LD_INT 1
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: PUSH
76544: LD_INT 4
76546: PUSH
76547: LD_INT 1
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 3
76556: PUSH
76557: LD_INT 0
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: PUSH
76564: LD_INT 3
76566: PUSH
76567: LD_INT 1
76569: NEG
76570: PUSH
76571: EMPTY
76572: LIST
76573: LIST
76574: PUSH
76575: LD_INT 3
76577: PUSH
76578: LD_INT 2
76580: NEG
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: PUSH
76586: LD_INT 5
76588: PUSH
76589: LD_INT 2
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: LIST
76600: LIST
76601: LIST
76602: LIST
76603: LIST
76604: LIST
76605: LIST
76606: LIST
76607: LIST
76608: LIST
76609: LIST
76610: LIST
76611: LIST
76612: LIST
76613: LIST
76614: LIST
76615: LIST
76616: LIST
76617: LIST
76618: LIST
76619: LIST
76620: LIST
76621: LIST
76622: LIST
76623: LIST
76624: LIST
76625: LIST
76626: LIST
76627: LIST
76628: LIST
76629: LIST
76630: LIST
76631: LIST
76632: LIST
76633: LIST
76634: LIST
76635: LIST
76636: LIST
76637: LIST
76638: LIST
76639: LIST
76640: LIST
76641: LIST
76642: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
76643: LD_ADDR_VAR 0 32
76647: PUSH
76648: LD_INT 4
76650: NEG
76651: PUSH
76652: LD_INT 0
76654: PUSH
76655: EMPTY
76656: LIST
76657: LIST
76658: PUSH
76659: LD_INT 4
76661: NEG
76662: PUSH
76663: LD_INT 1
76665: NEG
76666: PUSH
76667: EMPTY
76668: LIST
76669: LIST
76670: PUSH
76671: LD_INT 3
76673: NEG
76674: PUSH
76675: LD_INT 0
76677: PUSH
76678: EMPTY
76679: LIST
76680: LIST
76681: PUSH
76682: LD_INT 3
76684: NEG
76685: PUSH
76686: LD_INT 1
76688: PUSH
76689: EMPTY
76690: LIST
76691: LIST
76692: PUSH
76693: LD_INT 4
76695: NEG
76696: PUSH
76697: LD_INT 1
76699: PUSH
76700: EMPTY
76701: LIST
76702: LIST
76703: PUSH
76704: LD_INT 5
76706: NEG
76707: PUSH
76708: LD_INT 0
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: LD_INT 5
76717: NEG
76718: PUSH
76719: LD_INT 1
76721: NEG
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: PUSH
76727: LD_INT 5
76729: NEG
76730: PUSH
76731: LD_INT 2
76733: NEG
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: LD_INT 3
76741: NEG
76742: PUSH
76743: LD_INT 2
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: PUSH
76750: LD_INT 3
76752: NEG
76753: PUSH
76754: LD_INT 3
76756: NEG
76757: PUSH
76758: EMPTY
76759: LIST
76760: LIST
76761: PUSH
76762: LD_INT 3
76764: NEG
76765: PUSH
76766: LD_INT 4
76768: NEG
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 2
76776: NEG
76777: PUSH
76778: LD_INT 3
76780: NEG
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: LD_INT 2
76788: NEG
76789: PUSH
76790: LD_INT 2
76792: NEG
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: PUSH
76798: LD_INT 3
76800: NEG
76801: PUSH
76802: LD_INT 2
76804: NEG
76805: PUSH
76806: EMPTY
76807: LIST
76808: LIST
76809: PUSH
76810: LD_INT 4
76812: NEG
76813: PUSH
76814: LD_INT 3
76816: NEG
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: PUSH
76822: LD_INT 4
76824: NEG
76825: PUSH
76826: LD_INT 4
76828: NEG
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: PUSH
76834: LD_INT 2
76836: NEG
76837: PUSH
76838: LD_INT 4
76840: NEG
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: LD_INT 4
76848: NEG
76849: PUSH
76850: LD_INT 2
76852: NEG
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: LD_INT 0
76860: PUSH
76861: LD_INT 4
76863: NEG
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 0
76871: PUSH
76872: LD_INT 5
76874: NEG
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 1
76882: PUSH
76883: LD_INT 4
76885: NEG
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: PUSH
76891: LD_INT 1
76893: PUSH
76894: LD_INT 3
76896: NEG
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: PUSH
76902: LD_INT 0
76904: PUSH
76905: LD_INT 3
76907: NEG
76908: PUSH
76909: EMPTY
76910: LIST
76911: LIST
76912: PUSH
76913: LD_INT 1
76915: NEG
76916: PUSH
76917: LD_INT 4
76919: NEG
76920: PUSH
76921: EMPTY
76922: LIST
76923: LIST
76924: PUSH
76925: LD_INT 1
76927: NEG
76928: PUSH
76929: LD_INT 5
76931: NEG
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 2
76939: PUSH
76940: LD_INT 3
76942: NEG
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 2
76950: NEG
76951: PUSH
76952: LD_INT 5
76954: NEG
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: LD_INT 3
76962: PUSH
76963: LD_INT 0
76965: PUSH
76966: EMPTY
76967: LIST
76968: LIST
76969: PUSH
76970: LD_INT 3
76972: PUSH
76973: LD_INT 1
76975: NEG
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: PUSH
76981: LD_INT 4
76983: PUSH
76984: LD_INT 0
76986: PUSH
76987: EMPTY
76988: LIST
76989: LIST
76990: PUSH
76991: LD_INT 4
76993: PUSH
76994: LD_INT 1
76996: PUSH
76997: EMPTY
76998: LIST
76999: LIST
77000: PUSH
77001: LD_INT 3
77003: PUSH
77004: LD_INT 1
77006: PUSH
77007: EMPTY
77008: LIST
77009: LIST
77010: PUSH
77011: LD_INT 2
77013: PUSH
77014: LD_INT 0
77016: PUSH
77017: EMPTY
77018: LIST
77019: LIST
77020: PUSH
77021: LD_INT 2
77023: PUSH
77024: LD_INT 1
77026: NEG
77027: PUSH
77028: EMPTY
77029: LIST
77030: LIST
77031: PUSH
77032: LD_INT 2
77034: PUSH
77035: LD_INT 2
77037: NEG
77038: PUSH
77039: EMPTY
77040: LIST
77041: LIST
77042: PUSH
77043: LD_INT 4
77045: PUSH
77046: LD_INT 2
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PUSH
77053: LD_INT 4
77055: PUSH
77056: LD_INT 4
77058: PUSH
77059: EMPTY
77060: LIST
77061: LIST
77062: PUSH
77063: LD_INT 4
77065: PUSH
77066: LD_INT 3
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: PUSH
77073: LD_INT 5
77075: PUSH
77076: LD_INT 4
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: LD_INT 5
77085: PUSH
77086: LD_INT 5
77088: PUSH
77089: EMPTY
77090: LIST
77091: LIST
77092: PUSH
77093: LD_INT 4
77095: PUSH
77096: LD_INT 5
77098: PUSH
77099: EMPTY
77100: LIST
77101: LIST
77102: PUSH
77103: LD_INT 3
77105: PUSH
77106: LD_INT 4
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: LD_INT 3
77115: PUSH
77116: LD_INT 3
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: PUSH
77123: LD_INT 5
77125: PUSH
77126: LD_INT 3
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: PUSH
77133: LD_INT 3
77135: PUSH
77136: LD_INT 5
77138: PUSH
77139: EMPTY
77140: LIST
77141: LIST
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: LIST
77147: LIST
77148: LIST
77149: LIST
77150: LIST
77151: LIST
77152: LIST
77153: LIST
77154: LIST
77155: LIST
77156: LIST
77157: LIST
77158: LIST
77159: LIST
77160: LIST
77161: LIST
77162: LIST
77163: LIST
77164: LIST
77165: LIST
77166: LIST
77167: LIST
77168: LIST
77169: LIST
77170: LIST
77171: LIST
77172: LIST
77173: LIST
77174: LIST
77175: LIST
77176: LIST
77177: LIST
77178: LIST
77179: LIST
77180: LIST
77181: LIST
77182: LIST
77183: LIST
77184: LIST
77185: LIST
77186: LIST
77187: LIST
77188: LIST
77189: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
77190: LD_ADDR_VAR 0 33
77194: PUSH
77195: LD_INT 4
77197: NEG
77198: PUSH
77199: LD_INT 4
77201: NEG
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PUSH
77207: LD_INT 4
77209: NEG
77210: PUSH
77211: LD_INT 5
77213: NEG
77214: PUSH
77215: EMPTY
77216: LIST
77217: LIST
77218: PUSH
77219: LD_INT 3
77221: NEG
77222: PUSH
77223: LD_INT 4
77225: NEG
77226: PUSH
77227: EMPTY
77228: LIST
77229: LIST
77230: PUSH
77231: LD_INT 3
77233: NEG
77234: PUSH
77235: LD_INT 3
77237: NEG
77238: PUSH
77239: EMPTY
77240: LIST
77241: LIST
77242: PUSH
77243: LD_INT 4
77245: NEG
77246: PUSH
77247: LD_INT 3
77249: NEG
77250: PUSH
77251: EMPTY
77252: LIST
77253: LIST
77254: PUSH
77255: LD_INT 5
77257: NEG
77258: PUSH
77259: LD_INT 4
77261: NEG
77262: PUSH
77263: EMPTY
77264: LIST
77265: LIST
77266: PUSH
77267: LD_INT 5
77269: NEG
77270: PUSH
77271: LD_INT 5
77273: NEG
77274: PUSH
77275: EMPTY
77276: LIST
77277: LIST
77278: PUSH
77279: LD_INT 3
77281: NEG
77282: PUSH
77283: LD_INT 5
77285: NEG
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PUSH
77291: LD_INT 5
77293: NEG
77294: PUSH
77295: LD_INT 3
77297: NEG
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: LD_INT 0
77305: PUSH
77306: LD_INT 3
77308: NEG
77309: PUSH
77310: EMPTY
77311: LIST
77312: LIST
77313: PUSH
77314: LD_INT 0
77316: PUSH
77317: LD_INT 4
77319: NEG
77320: PUSH
77321: EMPTY
77322: LIST
77323: LIST
77324: PUSH
77325: LD_INT 1
77327: PUSH
77328: LD_INT 3
77330: NEG
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: PUSH
77336: LD_INT 1
77338: PUSH
77339: LD_INT 2
77341: NEG
77342: PUSH
77343: EMPTY
77344: LIST
77345: LIST
77346: PUSH
77347: LD_INT 0
77349: PUSH
77350: LD_INT 2
77352: NEG
77353: PUSH
77354: EMPTY
77355: LIST
77356: LIST
77357: PUSH
77358: LD_INT 1
77360: NEG
77361: PUSH
77362: LD_INT 3
77364: NEG
77365: PUSH
77366: EMPTY
77367: LIST
77368: LIST
77369: PUSH
77370: LD_INT 1
77372: NEG
77373: PUSH
77374: LD_INT 4
77376: NEG
77377: PUSH
77378: EMPTY
77379: LIST
77380: LIST
77381: PUSH
77382: LD_INT 2
77384: PUSH
77385: LD_INT 2
77387: NEG
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: PUSH
77393: LD_INT 2
77395: NEG
77396: PUSH
77397: LD_INT 4
77399: NEG
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: PUSH
77405: LD_INT 4
77407: PUSH
77408: LD_INT 0
77410: PUSH
77411: EMPTY
77412: LIST
77413: LIST
77414: PUSH
77415: LD_INT 4
77417: PUSH
77418: LD_INT 1
77420: NEG
77421: PUSH
77422: EMPTY
77423: LIST
77424: LIST
77425: PUSH
77426: LD_INT 5
77428: PUSH
77429: LD_INT 0
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: PUSH
77436: LD_INT 5
77438: PUSH
77439: LD_INT 1
77441: PUSH
77442: EMPTY
77443: LIST
77444: LIST
77445: PUSH
77446: LD_INT 4
77448: PUSH
77449: LD_INT 1
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PUSH
77456: LD_INT 3
77458: PUSH
77459: LD_INT 0
77461: PUSH
77462: EMPTY
77463: LIST
77464: LIST
77465: PUSH
77466: LD_INT 3
77468: PUSH
77469: LD_INT 1
77471: NEG
77472: PUSH
77473: EMPTY
77474: LIST
77475: LIST
77476: PUSH
77477: LD_INT 3
77479: PUSH
77480: LD_INT 2
77482: NEG
77483: PUSH
77484: EMPTY
77485: LIST
77486: LIST
77487: PUSH
77488: LD_INT 5
77490: PUSH
77491: LD_INT 2
77493: PUSH
77494: EMPTY
77495: LIST
77496: LIST
77497: PUSH
77498: LD_INT 3
77500: PUSH
77501: LD_INT 3
77503: PUSH
77504: EMPTY
77505: LIST
77506: LIST
77507: PUSH
77508: LD_INT 3
77510: PUSH
77511: LD_INT 2
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: PUSH
77518: LD_INT 4
77520: PUSH
77521: LD_INT 3
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: PUSH
77528: LD_INT 4
77530: PUSH
77531: LD_INT 4
77533: PUSH
77534: EMPTY
77535: LIST
77536: LIST
77537: PUSH
77538: LD_INT 3
77540: PUSH
77541: LD_INT 4
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: LD_INT 2
77550: PUSH
77551: LD_INT 3
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: PUSH
77558: LD_INT 2
77560: PUSH
77561: LD_INT 2
77563: PUSH
77564: EMPTY
77565: LIST
77566: LIST
77567: PUSH
77568: LD_INT 4
77570: PUSH
77571: LD_INT 2
77573: PUSH
77574: EMPTY
77575: LIST
77576: LIST
77577: PUSH
77578: LD_INT 2
77580: PUSH
77581: LD_INT 4
77583: PUSH
77584: EMPTY
77585: LIST
77586: LIST
77587: PUSH
77588: LD_INT 0
77590: PUSH
77591: LD_INT 4
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PUSH
77598: LD_INT 0
77600: PUSH
77601: LD_INT 3
77603: PUSH
77604: EMPTY
77605: LIST
77606: LIST
77607: PUSH
77608: LD_INT 1
77610: PUSH
77611: LD_INT 4
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: PUSH
77618: LD_INT 1
77620: PUSH
77621: LD_INT 5
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: PUSH
77628: LD_INT 0
77630: PUSH
77631: LD_INT 5
77633: PUSH
77634: EMPTY
77635: LIST
77636: LIST
77637: PUSH
77638: LD_INT 1
77640: NEG
77641: PUSH
77642: LD_INT 4
77644: PUSH
77645: EMPTY
77646: LIST
77647: LIST
77648: PUSH
77649: LD_INT 1
77651: NEG
77652: PUSH
77653: LD_INT 3
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: LD_INT 2
77662: PUSH
77663: LD_INT 5
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: PUSH
77670: LD_INT 2
77672: NEG
77673: PUSH
77674: LD_INT 3
77676: PUSH
77677: EMPTY
77678: LIST
77679: LIST
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: LIST
77685: LIST
77686: LIST
77687: LIST
77688: LIST
77689: LIST
77690: LIST
77691: LIST
77692: LIST
77693: LIST
77694: LIST
77695: LIST
77696: LIST
77697: LIST
77698: LIST
77699: LIST
77700: LIST
77701: LIST
77702: LIST
77703: LIST
77704: LIST
77705: LIST
77706: LIST
77707: LIST
77708: LIST
77709: LIST
77710: LIST
77711: LIST
77712: LIST
77713: LIST
77714: LIST
77715: LIST
77716: LIST
77717: LIST
77718: LIST
77719: LIST
77720: LIST
77721: LIST
77722: LIST
77723: LIST
77724: LIST
77725: LIST
77726: LIST
77727: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
77728: LD_ADDR_VAR 0 34
77732: PUSH
77733: LD_INT 0
77735: PUSH
77736: LD_INT 4
77738: NEG
77739: PUSH
77740: EMPTY
77741: LIST
77742: LIST
77743: PUSH
77744: LD_INT 0
77746: PUSH
77747: LD_INT 5
77749: NEG
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: PUSH
77755: LD_INT 1
77757: PUSH
77758: LD_INT 4
77760: NEG
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: LD_INT 1
77768: PUSH
77769: LD_INT 3
77771: NEG
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: PUSH
77777: LD_INT 0
77779: PUSH
77780: LD_INT 3
77782: NEG
77783: PUSH
77784: EMPTY
77785: LIST
77786: LIST
77787: PUSH
77788: LD_INT 1
77790: NEG
77791: PUSH
77792: LD_INT 4
77794: NEG
77795: PUSH
77796: EMPTY
77797: LIST
77798: LIST
77799: PUSH
77800: LD_INT 1
77802: NEG
77803: PUSH
77804: LD_INT 5
77806: NEG
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: PUSH
77812: LD_INT 2
77814: PUSH
77815: LD_INT 3
77817: NEG
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: LD_INT 2
77825: NEG
77826: PUSH
77827: LD_INT 5
77829: NEG
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PUSH
77835: LD_INT 3
77837: PUSH
77838: LD_INT 0
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: PUSH
77845: LD_INT 3
77847: PUSH
77848: LD_INT 1
77850: NEG
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: PUSH
77856: LD_INT 4
77858: PUSH
77859: LD_INT 0
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: PUSH
77866: LD_INT 4
77868: PUSH
77869: LD_INT 1
77871: PUSH
77872: EMPTY
77873: LIST
77874: LIST
77875: PUSH
77876: LD_INT 3
77878: PUSH
77879: LD_INT 1
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PUSH
77886: LD_INT 2
77888: PUSH
77889: LD_INT 0
77891: PUSH
77892: EMPTY
77893: LIST
77894: LIST
77895: PUSH
77896: LD_INT 2
77898: PUSH
77899: LD_INT 1
77901: NEG
77902: PUSH
77903: EMPTY
77904: LIST
77905: LIST
77906: PUSH
77907: LD_INT 2
77909: PUSH
77910: LD_INT 2
77912: NEG
77913: PUSH
77914: EMPTY
77915: LIST
77916: LIST
77917: PUSH
77918: LD_INT 4
77920: PUSH
77921: LD_INT 2
77923: PUSH
77924: EMPTY
77925: LIST
77926: LIST
77927: PUSH
77928: LD_INT 4
77930: PUSH
77931: LD_INT 4
77933: PUSH
77934: EMPTY
77935: LIST
77936: LIST
77937: PUSH
77938: LD_INT 4
77940: PUSH
77941: LD_INT 3
77943: PUSH
77944: EMPTY
77945: LIST
77946: LIST
77947: PUSH
77948: LD_INT 5
77950: PUSH
77951: LD_INT 4
77953: PUSH
77954: EMPTY
77955: LIST
77956: LIST
77957: PUSH
77958: LD_INT 5
77960: PUSH
77961: LD_INT 5
77963: PUSH
77964: EMPTY
77965: LIST
77966: LIST
77967: PUSH
77968: LD_INT 4
77970: PUSH
77971: LD_INT 5
77973: PUSH
77974: EMPTY
77975: LIST
77976: LIST
77977: PUSH
77978: LD_INT 3
77980: PUSH
77981: LD_INT 4
77983: PUSH
77984: EMPTY
77985: LIST
77986: LIST
77987: PUSH
77988: LD_INT 3
77990: PUSH
77991: LD_INT 3
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 5
78000: PUSH
78001: LD_INT 3
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 3
78010: PUSH
78011: LD_INT 5
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: PUSH
78018: LD_INT 0
78020: PUSH
78021: LD_INT 3
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 0
78030: PUSH
78031: LD_INT 2
78033: PUSH
78034: EMPTY
78035: LIST
78036: LIST
78037: PUSH
78038: LD_INT 1
78040: PUSH
78041: LD_INT 3
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: PUSH
78048: LD_INT 1
78050: PUSH
78051: LD_INT 4
78053: PUSH
78054: EMPTY
78055: LIST
78056: LIST
78057: PUSH
78058: LD_INT 0
78060: PUSH
78061: LD_INT 4
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 1
78070: NEG
78071: PUSH
78072: LD_INT 3
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PUSH
78079: LD_INT 1
78081: NEG
78082: PUSH
78083: LD_INT 2
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: LD_INT 2
78092: PUSH
78093: LD_INT 4
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: PUSH
78100: LD_INT 2
78102: NEG
78103: PUSH
78104: LD_INT 2
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: PUSH
78111: LD_INT 4
78113: NEG
78114: PUSH
78115: LD_INT 0
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PUSH
78122: LD_INT 4
78124: NEG
78125: PUSH
78126: LD_INT 1
78128: NEG
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: PUSH
78134: LD_INT 3
78136: NEG
78137: PUSH
78138: LD_INT 0
78140: PUSH
78141: EMPTY
78142: LIST
78143: LIST
78144: PUSH
78145: LD_INT 3
78147: NEG
78148: PUSH
78149: LD_INT 1
78151: PUSH
78152: EMPTY
78153: LIST
78154: LIST
78155: PUSH
78156: LD_INT 4
78158: NEG
78159: PUSH
78160: LD_INT 1
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 5
78169: NEG
78170: PUSH
78171: LD_INT 0
78173: PUSH
78174: EMPTY
78175: LIST
78176: LIST
78177: PUSH
78178: LD_INT 5
78180: NEG
78181: PUSH
78182: LD_INT 1
78184: NEG
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: LD_INT 5
78192: NEG
78193: PUSH
78194: LD_INT 2
78196: NEG
78197: PUSH
78198: EMPTY
78199: LIST
78200: LIST
78201: PUSH
78202: LD_INT 3
78204: NEG
78205: PUSH
78206: LD_INT 2
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: PUSH
78213: EMPTY
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: LIST
78246: LIST
78247: LIST
78248: LIST
78249: LIST
78250: LIST
78251: LIST
78252: LIST
78253: LIST
78254: LIST
78255: LIST
78256: LIST
78257: LIST
78258: LIST
78259: ST_TO_ADDR
// end ; end ;
78260: GO 78263
78262: POP
// case btype of b_depot , b_warehouse :
78263: LD_VAR 0 1
78267: PUSH
78268: LD_INT 0
78270: DOUBLE
78271: EQUAL
78272: IFTRUE 78282
78274: LD_INT 1
78276: DOUBLE
78277: EQUAL
78278: IFTRUE 78282
78280: GO 78483
78282: POP
// case nation of nation_american :
78283: LD_VAR 0 5
78287: PUSH
78288: LD_INT 1
78290: DOUBLE
78291: EQUAL
78292: IFTRUE 78296
78294: GO 78352
78296: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
78297: LD_ADDR_VAR 0 9
78301: PUSH
78302: LD_VAR 0 11
78306: PUSH
78307: LD_VAR 0 12
78311: PUSH
78312: LD_VAR 0 13
78316: PUSH
78317: LD_VAR 0 14
78321: PUSH
78322: LD_VAR 0 15
78326: PUSH
78327: LD_VAR 0 16
78331: PUSH
78332: EMPTY
78333: LIST
78334: LIST
78335: LIST
78336: LIST
78337: LIST
78338: LIST
78339: PUSH
78340: LD_VAR 0 4
78344: PUSH
78345: LD_INT 1
78347: PLUS
78348: ARRAY
78349: ST_TO_ADDR
78350: GO 78481
78352: LD_INT 2
78354: DOUBLE
78355: EQUAL
78356: IFTRUE 78360
78358: GO 78416
78360: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
78361: LD_ADDR_VAR 0 9
78365: PUSH
78366: LD_VAR 0 17
78370: PUSH
78371: LD_VAR 0 18
78375: PUSH
78376: LD_VAR 0 19
78380: PUSH
78381: LD_VAR 0 20
78385: PUSH
78386: LD_VAR 0 21
78390: PUSH
78391: LD_VAR 0 22
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: LIST
78400: LIST
78401: LIST
78402: LIST
78403: PUSH
78404: LD_VAR 0 4
78408: PUSH
78409: LD_INT 1
78411: PLUS
78412: ARRAY
78413: ST_TO_ADDR
78414: GO 78481
78416: LD_INT 3
78418: DOUBLE
78419: EQUAL
78420: IFTRUE 78424
78422: GO 78480
78424: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
78425: LD_ADDR_VAR 0 9
78429: PUSH
78430: LD_VAR 0 23
78434: PUSH
78435: LD_VAR 0 24
78439: PUSH
78440: LD_VAR 0 25
78444: PUSH
78445: LD_VAR 0 26
78449: PUSH
78450: LD_VAR 0 27
78454: PUSH
78455: LD_VAR 0 28
78459: PUSH
78460: EMPTY
78461: LIST
78462: LIST
78463: LIST
78464: LIST
78465: LIST
78466: LIST
78467: PUSH
78468: LD_VAR 0 4
78472: PUSH
78473: LD_INT 1
78475: PLUS
78476: ARRAY
78477: ST_TO_ADDR
78478: GO 78481
78480: POP
78481: GO 79036
78483: LD_INT 2
78485: DOUBLE
78486: EQUAL
78487: IFTRUE 78497
78489: LD_INT 3
78491: DOUBLE
78492: EQUAL
78493: IFTRUE 78497
78495: GO 78553
78497: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
78498: LD_ADDR_VAR 0 9
78502: PUSH
78503: LD_VAR 0 29
78507: PUSH
78508: LD_VAR 0 30
78512: PUSH
78513: LD_VAR 0 31
78517: PUSH
78518: LD_VAR 0 32
78522: PUSH
78523: LD_VAR 0 33
78527: PUSH
78528: LD_VAR 0 34
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: LIST
78537: LIST
78538: LIST
78539: LIST
78540: PUSH
78541: LD_VAR 0 4
78545: PUSH
78546: LD_INT 1
78548: PLUS
78549: ARRAY
78550: ST_TO_ADDR
78551: GO 79036
78553: LD_INT 16
78555: DOUBLE
78556: EQUAL
78557: IFTRUE 78615
78559: LD_INT 17
78561: DOUBLE
78562: EQUAL
78563: IFTRUE 78615
78565: LD_INT 18
78567: DOUBLE
78568: EQUAL
78569: IFTRUE 78615
78571: LD_INT 19
78573: DOUBLE
78574: EQUAL
78575: IFTRUE 78615
78577: LD_INT 22
78579: DOUBLE
78580: EQUAL
78581: IFTRUE 78615
78583: LD_INT 20
78585: DOUBLE
78586: EQUAL
78587: IFTRUE 78615
78589: LD_INT 21
78591: DOUBLE
78592: EQUAL
78593: IFTRUE 78615
78595: LD_INT 23
78597: DOUBLE
78598: EQUAL
78599: IFTRUE 78615
78601: LD_INT 24
78603: DOUBLE
78604: EQUAL
78605: IFTRUE 78615
78607: LD_INT 25
78609: DOUBLE
78610: EQUAL
78611: IFTRUE 78615
78613: GO 78671
78615: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
78616: LD_ADDR_VAR 0 9
78620: PUSH
78621: LD_VAR 0 35
78625: PUSH
78626: LD_VAR 0 36
78630: PUSH
78631: LD_VAR 0 37
78635: PUSH
78636: LD_VAR 0 38
78640: PUSH
78641: LD_VAR 0 39
78645: PUSH
78646: LD_VAR 0 40
78650: PUSH
78651: EMPTY
78652: LIST
78653: LIST
78654: LIST
78655: LIST
78656: LIST
78657: LIST
78658: PUSH
78659: LD_VAR 0 4
78663: PUSH
78664: LD_INT 1
78666: PLUS
78667: ARRAY
78668: ST_TO_ADDR
78669: GO 79036
78671: LD_INT 6
78673: DOUBLE
78674: EQUAL
78675: IFTRUE 78727
78677: LD_INT 7
78679: DOUBLE
78680: EQUAL
78681: IFTRUE 78727
78683: LD_INT 8
78685: DOUBLE
78686: EQUAL
78687: IFTRUE 78727
78689: LD_INT 13
78691: DOUBLE
78692: EQUAL
78693: IFTRUE 78727
78695: LD_INT 12
78697: DOUBLE
78698: EQUAL
78699: IFTRUE 78727
78701: LD_INT 15
78703: DOUBLE
78704: EQUAL
78705: IFTRUE 78727
78707: LD_INT 11
78709: DOUBLE
78710: EQUAL
78711: IFTRUE 78727
78713: LD_INT 14
78715: DOUBLE
78716: EQUAL
78717: IFTRUE 78727
78719: LD_INT 10
78721: DOUBLE
78722: EQUAL
78723: IFTRUE 78727
78725: GO 78783
78727: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
78728: LD_ADDR_VAR 0 9
78732: PUSH
78733: LD_VAR 0 41
78737: PUSH
78738: LD_VAR 0 42
78742: PUSH
78743: LD_VAR 0 43
78747: PUSH
78748: LD_VAR 0 44
78752: PUSH
78753: LD_VAR 0 45
78757: PUSH
78758: LD_VAR 0 46
78762: PUSH
78763: EMPTY
78764: LIST
78765: LIST
78766: LIST
78767: LIST
78768: LIST
78769: LIST
78770: PUSH
78771: LD_VAR 0 4
78775: PUSH
78776: LD_INT 1
78778: PLUS
78779: ARRAY
78780: ST_TO_ADDR
78781: GO 79036
78783: LD_INT 36
78785: DOUBLE
78786: EQUAL
78787: IFTRUE 78791
78789: GO 78847
78791: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
78792: LD_ADDR_VAR 0 9
78796: PUSH
78797: LD_VAR 0 47
78801: PUSH
78802: LD_VAR 0 48
78806: PUSH
78807: LD_VAR 0 49
78811: PUSH
78812: LD_VAR 0 50
78816: PUSH
78817: LD_VAR 0 51
78821: PUSH
78822: LD_VAR 0 52
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: LIST
78833: LIST
78834: PUSH
78835: LD_VAR 0 4
78839: PUSH
78840: LD_INT 1
78842: PLUS
78843: ARRAY
78844: ST_TO_ADDR
78845: GO 79036
78847: LD_INT 4
78849: DOUBLE
78850: EQUAL
78851: IFTRUE 78873
78853: LD_INT 5
78855: DOUBLE
78856: EQUAL
78857: IFTRUE 78873
78859: LD_INT 34
78861: DOUBLE
78862: EQUAL
78863: IFTRUE 78873
78865: LD_INT 37
78867: DOUBLE
78868: EQUAL
78869: IFTRUE 78873
78871: GO 78929
78873: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
78874: LD_ADDR_VAR 0 9
78878: PUSH
78879: LD_VAR 0 53
78883: PUSH
78884: LD_VAR 0 54
78888: PUSH
78889: LD_VAR 0 55
78893: PUSH
78894: LD_VAR 0 56
78898: PUSH
78899: LD_VAR 0 57
78903: PUSH
78904: LD_VAR 0 58
78908: PUSH
78909: EMPTY
78910: LIST
78911: LIST
78912: LIST
78913: LIST
78914: LIST
78915: LIST
78916: PUSH
78917: LD_VAR 0 4
78921: PUSH
78922: LD_INT 1
78924: PLUS
78925: ARRAY
78926: ST_TO_ADDR
78927: GO 79036
78929: LD_INT 31
78931: DOUBLE
78932: EQUAL
78933: IFTRUE 78979
78935: LD_INT 32
78937: DOUBLE
78938: EQUAL
78939: IFTRUE 78979
78941: LD_INT 33
78943: DOUBLE
78944: EQUAL
78945: IFTRUE 78979
78947: LD_INT 27
78949: DOUBLE
78950: EQUAL
78951: IFTRUE 78979
78953: LD_INT 26
78955: DOUBLE
78956: EQUAL
78957: IFTRUE 78979
78959: LD_INT 28
78961: DOUBLE
78962: EQUAL
78963: IFTRUE 78979
78965: LD_INT 29
78967: DOUBLE
78968: EQUAL
78969: IFTRUE 78979
78971: LD_INT 30
78973: DOUBLE
78974: EQUAL
78975: IFTRUE 78979
78977: GO 79035
78979: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
78980: LD_ADDR_VAR 0 9
78984: PUSH
78985: LD_VAR 0 59
78989: PUSH
78990: LD_VAR 0 60
78994: PUSH
78995: LD_VAR 0 61
78999: PUSH
79000: LD_VAR 0 62
79004: PUSH
79005: LD_VAR 0 63
79009: PUSH
79010: LD_VAR 0 64
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: PUSH
79023: LD_VAR 0 4
79027: PUSH
79028: LD_INT 1
79030: PLUS
79031: ARRAY
79032: ST_TO_ADDR
79033: GO 79036
79035: POP
// temp_list2 = [ ] ;
79036: LD_ADDR_VAR 0 10
79040: PUSH
79041: EMPTY
79042: ST_TO_ADDR
// for i in temp_list do
79043: LD_ADDR_VAR 0 8
79047: PUSH
79048: LD_VAR 0 9
79052: PUSH
79053: FOR_IN
79054: IFFALSE 79106
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
79056: LD_ADDR_VAR 0 10
79060: PUSH
79061: LD_VAR 0 10
79065: PUSH
79066: LD_VAR 0 8
79070: PUSH
79071: LD_INT 1
79073: ARRAY
79074: PUSH
79075: LD_VAR 0 2
79079: PLUS
79080: PUSH
79081: LD_VAR 0 8
79085: PUSH
79086: LD_INT 2
79088: ARRAY
79089: PUSH
79090: LD_VAR 0 3
79094: PLUS
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: EMPTY
79101: LIST
79102: ADD
79103: ST_TO_ADDR
79104: GO 79053
79106: POP
79107: POP
// result = temp_list2 ;
79108: LD_ADDR_VAR 0 7
79112: PUSH
79113: LD_VAR 0 10
79117: ST_TO_ADDR
// end ;
79118: LD_VAR 0 7
79122: RET
// export function EnemyInRange ( unit , dist ) ; begin
79123: LD_INT 0
79125: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
79126: LD_ADDR_VAR 0 3
79130: PUSH
79131: LD_VAR 0 1
79135: PPUSH
79136: CALL_OW 255
79140: PPUSH
79141: LD_VAR 0 1
79145: PPUSH
79146: CALL_OW 250
79150: PPUSH
79151: LD_VAR 0 1
79155: PPUSH
79156: CALL_OW 251
79160: PPUSH
79161: LD_VAR 0 2
79165: PPUSH
79166: CALL 53227 0 4
79170: PUSH
79171: LD_INT 4
79173: ARRAY
79174: ST_TO_ADDR
// end ;
79175: LD_VAR 0 3
79179: RET
// export function PlayerSeeMe ( unit ) ; begin
79180: LD_INT 0
79182: PPUSH
// result := See ( your_side , unit ) ;
79183: LD_ADDR_VAR 0 2
79187: PUSH
79188: LD_OWVAR 2
79192: PPUSH
79193: LD_VAR 0 1
79197: PPUSH
79198: CALL_OW 292
79202: ST_TO_ADDR
// end ;
79203: LD_VAR 0 2
79207: RET
// export function ReverseDir ( unit ) ; begin
79208: LD_INT 0
79210: PPUSH
// if not unit then
79211: LD_VAR 0 1
79215: NOT
79216: IFFALSE 79220
// exit ;
79218: GO 79243
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
79220: LD_ADDR_VAR 0 2
79224: PUSH
79225: LD_VAR 0 1
79229: PPUSH
79230: CALL_OW 254
79234: PUSH
79235: LD_INT 3
79237: PLUS
79238: PUSH
79239: LD_INT 6
79241: MOD
79242: ST_TO_ADDR
// end ;
79243: LD_VAR 0 2
79247: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
79248: LD_INT 0
79250: PPUSH
79251: PPUSH
79252: PPUSH
79253: PPUSH
79254: PPUSH
// if not hexes then
79255: LD_VAR 0 2
79259: NOT
79260: IFFALSE 79264
// exit ;
79262: GO 79412
// dist := 9999 ;
79264: LD_ADDR_VAR 0 5
79268: PUSH
79269: LD_INT 9999
79271: ST_TO_ADDR
// for i = 1 to hexes do
79272: LD_ADDR_VAR 0 4
79276: PUSH
79277: DOUBLE
79278: LD_INT 1
79280: DEC
79281: ST_TO_ADDR
79282: LD_VAR 0 2
79286: PUSH
79287: FOR_TO
79288: IFFALSE 79400
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
79290: LD_VAR 0 1
79294: PPUSH
79295: LD_VAR 0 2
79299: PUSH
79300: LD_VAR 0 4
79304: ARRAY
79305: PUSH
79306: LD_INT 1
79308: ARRAY
79309: PPUSH
79310: LD_VAR 0 2
79314: PUSH
79315: LD_VAR 0 4
79319: ARRAY
79320: PUSH
79321: LD_INT 2
79323: ARRAY
79324: PPUSH
79325: CALL_OW 297
79329: PUSH
79330: LD_VAR 0 5
79334: LESS
79335: IFFALSE 79398
// begin hex := hexes [ i ] ;
79337: LD_ADDR_VAR 0 7
79341: PUSH
79342: LD_VAR 0 2
79346: PUSH
79347: LD_VAR 0 4
79351: ARRAY
79352: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79353: LD_ADDR_VAR 0 5
79357: PUSH
79358: LD_VAR 0 1
79362: PPUSH
79363: LD_VAR 0 2
79367: PUSH
79368: LD_VAR 0 4
79372: ARRAY
79373: PUSH
79374: LD_INT 1
79376: ARRAY
79377: PPUSH
79378: LD_VAR 0 2
79382: PUSH
79383: LD_VAR 0 4
79387: ARRAY
79388: PUSH
79389: LD_INT 2
79391: ARRAY
79392: PPUSH
79393: CALL_OW 297
79397: ST_TO_ADDR
// end ; end ;
79398: GO 79287
79400: POP
79401: POP
// result := hex ;
79402: LD_ADDR_VAR 0 3
79406: PUSH
79407: LD_VAR 0 7
79411: ST_TO_ADDR
// end ;
79412: LD_VAR 0 3
79416: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
79417: LD_INT 0
79419: PPUSH
79420: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
79421: LD_VAR 0 1
79425: NOT
79426: PUSH
79427: LD_VAR 0 1
79431: PUSH
79432: LD_INT 21
79434: PUSH
79435: LD_INT 2
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: PUSH
79442: LD_INT 23
79444: PUSH
79445: LD_INT 2
79447: PUSH
79448: EMPTY
79449: LIST
79450: LIST
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PPUSH
79456: CALL_OW 69
79460: IN
79461: NOT
79462: OR
79463: IFFALSE 79467
// exit ;
79465: GO 79514
// for i = 1 to 3 do
79467: LD_ADDR_VAR 0 3
79471: PUSH
79472: DOUBLE
79473: LD_INT 1
79475: DEC
79476: ST_TO_ADDR
79477: LD_INT 3
79479: PUSH
79480: FOR_TO
79481: IFFALSE 79512
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
79483: LD_VAR 0 1
79487: PPUSH
79488: CALL_OW 250
79492: PPUSH
79493: LD_VAR 0 1
79497: PPUSH
79498: CALL_OW 251
79502: PPUSH
79503: LD_INT 1
79505: PPUSH
79506: CALL_OW 453
79510: GO 79480
79512: POP
79513: POP
// end ;
79514: LD_VAR 0 2
79518: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
79519: LD_INT 0
79521: PPUSH
79522: PPUSH
79523: PPUSH
79524: PPUSH
79525: PPUSH
79526: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
79527: LD_VAR 0 1
79531: NOT
79532: PUSH
79533: LD_VAR 0 2
79537: NOT
79538: OR
79539: PUSH
79540: LD_VAR 0 1
79544: PPUSH
79545: CALL_OW 314
79549: OR
79550: IFFALSE 79554
// exit ;
79552: GO 79995
// x := GetX ( enemy_unit ) ;
79554: LD_ADDR_VAR 0 7
79558: PUSH
79559: LD_VAR 0 2
79563: PPUSH
79564: CALL_OW 250
79568: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
79569: LD_ADDR_VAR 0 8
79573: PUSH
79574: LD_VAR 0 2
79578: PPUSH
79579: CALL_OW 251
79583: ST_TO_ADDR
// if not x or not y then
79584: LD_VAR 0 7
79588: NOT
79589: PUSH
79590: LD_VAR 0 8
79594: NOT
79595: OR
79596: IFFALSE 79600
// exit ;
79598: GO 79995
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
79600: LD_ADDR_VAR 0 6
79604: PUSH
79605: LD_VAR 0 7
79609: PPUSH
79610: LD_INT 0
79612: PPUSH
79613: LD_INT 4
79615: PPUSH
79616: CALL_OW 272
79620: PUSH
79621: LD_VAR 0 8
79625: PPUSH
79626: LD_INT 0
79628: PPUSH
79629: LD_INT 4
79631: PPUSH
79632: CALL_OW 273
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: PUSH
79641: LD_VAR 0 7
79645: PPUSH
79646: LD_INT 1
79648: PPUSH
79649: LD_INT 4
79651: PPUSH
79652: CALL_OW 272
79656: PUSH
79657: LD_VAR 0 8
79661: PPUSH
79662: LD_INT 1
79664: PPUSH
79665: LD_INT 4
79667: PPUSH
79668: CALL_OW 273
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: PUSH
79677: LD_VAR 0 7
79681: PPUSH
79682: LD_INT 2
79684: PPUSH
79685: LD_INT 4
79687: PPUSH
79688: CALL_OW 272
79692: PUSH
79693: LD_VAR 0 8
79697: PPUSH
79698: LD_INT 2
79700: PPUSH
79701: LD_INT 4
79703: PPUSH
79704: CALL_OW 273
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: LD_VAR 0 7
79717: PPUSH
79718: LD_INT 3
79720: PPUSH
79721: LD_INT 4
79723: PPUSH
79724: CALL_OW 272
79728: PUSH
79729: LD_VAR 0 8
79733: PPUSH
79734: LD_INT 3
79736: PPUSH
79737: LD_INT 4
79739: PPUSH
79740: CALL_OW 273
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_VAR 0 7
79753: PPUSH
79754: LD_INT 4
79756: PPUSH
79757: LD_INT 4
79759: PPUSH
79760: CALL_OW 272
79764: PUSH
79765: LD_VAR 0 8
79769: PPUSH
79770: LD_INT 4
79772: PPUSH
79773: LD_INT 4
79775: PPUSH
79776: CALL_OW 273
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PUSH
79785: LD_VAR 0 7
79789: PPUSH
79790: LD_INT 5
79792: PPUSH
79793: LD_INT 4
79795: PPUSH
79796: CALL_OW 272
79800: PUSH
79801: LD_VAR 0 8
79805: PPUSH
79806: LD_INT 5
79808: PPUSH
79809: LD_INT 4
79811: PPUSH
79812: CALL_OW 273
79816: PUSH
79817: EMPTY
79818: LIST
79819: LIST
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: LIST
79825: LIST
79826: LIST
79827: LIST
79828: ST_TO_ADDR
// for i = tmp downto 1 do
79829: LD_ADDR_VAR 0 4
79833: PUSH
79834: DOUBLE
79835: LD_VAR 0 6
79839: INC
79840: ST_TO_ADDR
79841: LD_INT 1
79843: PUSH
79844: FOR_DOWNTO
79845: IFFALSE 79946
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
79847: LD_VAR 0 6
79851: PUSH
79852: LD_VAR 0 4
79856: ARRAY
79857: PUSH
79858: LD_INT 1
79860: ARRAY
79861: PPUSH
79862: LD_VAR 0 6
79866: PUSH
79867: LD_VAR 0 4
79871: ARRAY
79872: PUSH
79873: LD_INT 2
79875: ARRAY
79876: PPUSH
79877: CALL_OW 488
79881: NOT
79882: PUSH
79883: LD_VAR 0 6
79887: PUSH
79888: LD_VAR 0 4
79892: ARRAY
79893: PUSH
79894: LD_INT 1
79896: ARRAY
79897: PPUSH
79898: LD_VAR 0 6
79902: PUSH
79903: LD_VAR 0 4
79907: ARRAY
79908: PUSH
79909: LD_INT 2
79911: ARRAY
79912: PPUSH
79913: CALL_OW 428
79917: PUSH
79918: LD_INT 0
79920: NONEQUAL
79921: OR
79922: IFFALSE 79944
// tmp := Delete ( tmp , i ) ;
79924: LD_ADDR_VAR 0 6
79928: PUSH
79929: LD_VAR 0 6
79933: PPUSH
79934: LD_VAR 0 4
79938: PPUSH
79939: CALL_OW 3
79943: ST_TO_ADDR
79944: GO 79844
79946: POP
79947: POP
// j := GetClosestHex ( unit , tmp ) ;
79948: LD_ADDR_VAR 0 5
79952: PUSH
79953: LD_VAR 0 1
79957: PPUSH
79958: LD_VAR 0 6
79962: PPUSH
79963: CALL 79248 0 2
79967: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
79968: LD_VAR 0 1
79972: PPUSH
79973: LD_VAR 0 5
79977: PUSH
79978: LD_INT 1
79980: ARRAY
79981: PPUSH
79982: LD_VAR 0 5
79986: PUSH
79987: LD_INT 2
79989: ARRAY
79990: PPUSH
79991: CALL_OW 111
// end ;
79995: LD_VAR 0 3
79999: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
80000: LD_INT 0
80002: PPUSH
80003: PPUSH
80004: PPUSH
// uc_side = 0 ;
80005: LD_ADDR_OWVAR 20
80009: PUSH
80010: LD_INT 0
80012: ST_TO_ADDR
// uc_nation = 0 ;
80013: LD_ADDR_OWVAR 21
80017: PUSH
80018: LD_INT 0
80020: ST_TO_ADDR
// InitHc_All ( ) ;
80021: CALL_OW 584
// InitVc ;
80025: CALL_OW 20
// if mastodonts then
80029: LD_VAR 0 6
80033: IFFALSE 80100
// for i = 1 to mastodonts do
80035: LD_ADDR_VAR 0 11
80039: PUSH
80040: DOUBLE
80041: LD_INT 1
80043: DEC
80044: ST_TO_ADDR
80045: LD_VAR 0 6
80049: PUSH
80050: FOR_TO
80051: IFFALSE 80098
// begin vc_chassis := 31 ;
80053: LD_ADDR_OWVAR 37
80057: PUSH
80058: LD_INT 31
80060: ST_TO_ADDR
// vc_control := control_rider ;
80061: LD_ADDR_OWVAR 38
80065: PUSH
80066: LD_INT 4
80068: ST_TO_ADDR
// animal := CreateVehicle ;
80069: LD_ADDR_VAR 0 12
80073: PUSH
80074: CALL_OW 45
80078: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80079: LD_VAR 0 12
80083: PPUSH
80084: LD_VAR 0 8
80088: PPUSH
80089: LD_INT 0
80091: PPUSH
80092: CALL 82288 0 3
// end ;
80096: GO 80050
80098: POP
80099: POP
// if horses then
80100: LD_VAR 0 5
80104: IFFALSE 80171
// for i = 1 to horses do
80106: LD_ADDR_VAR 0 11
80110: PUSH
80111: DOUBLE
80112: LD_INT 1
80114: DEC
80115: ST_TO_ADDR
80116: LD_VAR 0 5
80120: PUSH
80121: FOR_TO
80122: IFFALSE 80169
// begin hc_class := 21 ;
80124: LD_ADDR_OWVAR 28
80128: PUSH
80129: LD_INT 21
80131: ST_TO_ADDR
// hc_gallery :=  ;
80132: LD_ADDR_OWVAR 33
80136: PUSH
80137: LD_STRING 
80139: ST_TO_ADDR
// animal := CreateHuman ;
80140: LD_ADDR_VAR 0 12
80144: PUSH
80145: CALL_OW 44
80149: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80150: LD_VAR 0 12
80154: PPUSH
80155: LD_VAR 0 8
80159: PPUSH
80160: LD_INT 0
80162: PPUSH
80163: CALL 82288 0 3
// end ;
80167: GO 80121
80169: POP
80170: POP
// if birds then
80171: LD_VAR 0 1
80175: IFFALSE 80242
// for i = 1 to birds do
80177: LD_ADDR_VAR 0 11
80181: PUSH
80182: DOUBLE
80183: LD_INT 1
80185: DEC
80186: ST_TO_ADDR
80187: LD_VAR 0 1
80191: PUSH
80192: FOR_TO
80193: IFFALSE 80240
// begin hc_class = 18 ;
80195: LD_ADDR_OWVAR 28
80199: PUSH
80200: LD_INT 18
80202: ST_TO_ADDR
// hc_gallery =  ;
80203: LD_ADDR_OWVAR 33
80207: PUSH
80208: LD_STRING 
80210: ST_TO_ADDR
// animal := CreateHuman ;
80211: LD_ADDR_VAR 0 12
80215: PUSH
80216: CALL_OW 44
80220: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80221: LD_VAR 0 12
80225: PPUSH
80226: LD_VAR 0 8
80230: PPUSH
80231: LD_INT 0
80233: PPUSH
80234: CALL 82288 0 3
// end ;
80238: GO 80192
80240: POP
80241: POP
// if tigers then
80242: LD_VAR 0 2
80246: IFFALSE 80330
// for i = 1 to tigers do
80248: LD_ADDR_VAR 0 11
80252: PUSH
80253: DOUBLE
80254: LD_INT 1
80256: DEC
80257: ST_TO_ADDR
80258: LD_VAR 0 2
80262: PUSH
80263: FOR_TO
80264: IFFALSE 80328
// begin hc_class = class_tiger ;
80266: LD_ADDR_OWVAR 28
80270: PUSH
80271: LD_INT 14
80273: ST_TO_ADDR
// hc_gallery =  ;
80274: LD_ADDR_OWVAR 33
80278: PUSH
80279: LD_STRING 
80281: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
80282: LD_ADDR_OWVAR 35
80286: PUSH
80287: LD_INT 7
80289: NEG
80290: PPUSH
80291: LD_INT 7
80293: PPUSH
80294: CALL_OW 12
80298: ST_TO_ADDR
// animal := CreateHuman ;
80299: LD_ADDR_VAR 0 12
80303: PUSH
80304: CALL_OW 44
80308: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80309: LD_VAR 0 12
80313: PPUSH
80314: LD_VAR 0 8
80318: PPUSH
80319: LD_INT 0
80321: PPUSH
80322: CALL 82288 0 3
// end ;
80326: GO 80263
80328: POP
80329: POP
// if apemans then
80330: LD_VAR 0 3
80334: IFFALSE 80457
// for i = 1 to apemans do
80336: LD_ADDR_VAR 0 11
80340: PUSH
80341: DOUBLE
80342: LD_INT 1
80344: DEC
80345: ST_TO_ADDR
80346: LD_VAR 0 3
80350: PUSH
80351: FOR_TO
80352: IFFALSE 80455
// begin hc_class = class_apeman ;
80354: LD_ADDR_OWVAR 28
80358: PUSH
80359: LD_INT 12
80361: ST_TO_ADDR
// hc_gallery =  ;
80362: LD_ADDR_OWVAR 33
80366: PUSH
80367: LD_STRING 
80369: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
80370: LD_ADDR_OWVAR 35
80374: PUSH
80375: LD_INT 5
80377: NEG
80378: PPUSH
80379: LD_INT 5
80381: PPUSH
80382: CALL_OW 12
80386: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
80387: LD_ADDR_OWVAR 31
80391: PUSH
80392: LD_INT 1
80394: PPUSH
80395: LD_INT 3
80397: PPUSH
80398: CALL_OW 12
80402: PUSH
80403: LD_INT 1
80405: PPUSH
80406: LD_INT 3
80408: PPUSH
80409: CALL_OW 12
80413: PUSH
80414: LD_INT 0
80416: PUSH
80417: LD_INT 0
80419: PUSH
80420: EMPTY
80421: LIST
80422: LIST
80423: LIST
80424: LIST
80425: ST_TO_ADDR
// animal := CreateHuman ;
80426: LD_ADDR_VAR 0 12
80430: PUSH
80431: CALL_OW 44
80435: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80436: LD_VAR 0 12
80440: PPUSH
80441: LD_VAR 0 8
80445: PPUSH
80446: LD_INT 0
80448: PPUSH
80449: CALL 82288 0 3
// end ;
80453: GO 80351
80455: POP
80456: POP
// if enchidnas then
80457: LD_VAR 0 4
80461: IFFALSE 80528
// for i = 1 to enchidnas do
80463: LD_ADDR_VAR 0 11
80467: PUSH
80468: DOUBLE
80469: LD_INT 1
80471: DEC
80472: ST_TO_ADDR
80473: LD_VAR 0 4
80477: PUSH
80478: FOR_TO
80479: IFFALSE 80526
// begin hc_class = 13 ;
80481: LD_ADDR_OWVAR 28
80485: PUSH
80486: LD_INT 13
80488: ST_TO_ADDR
// hc_gallery =  ;
80489: LD_ADDR_OWVAR 33
80493: PUSH
80494: LD_STRING 
80496: ST_TO_ADDR
// animal := CreateHuman ;
80497: LD_ADDR_VAR 0 12
80501: PUSH
80502: CALL_OW 44
80506: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80507: LD_VAR 0 12
80511: PPUSH
80512: LD_VAR 0 8
80516: PPUSH
80517: LD_INT 0
80519: PPUSH
80520: CALL 82288 0 3
// end ;
80524: GO 80478
80526: POP
80527: POP
// if fishes then
80528: LD_VAR 0 7
80532: IFFALSE 80599
// for i = 1 to fishes do
80534: LD_ADDR_VAR 0 11
80538: PUSH
80539: DOUBLE
80540: LD_INT 1
80542: DEC
80543: ST_TO_ADDR
80544: LD_VAR 0 7
80548: PUSH
80549: FOR_TO
80550: IFFALSE 80597
// begin hc_class = 20 ;
80552: LD_ADDR_OWVAR 28
80556: PUSH
80557: LD_INT 20
80559: ST_TO_ADDR
// hc_gallery =  ;
80560: LD_ADDR_OWVAR 33
80564: PUSH
80565: LD_STRING 
80567: ST_TO_ADDR
// animal := CreateHuman ;
80568: LD_ADDR_VAR 0 12
80572: PUSH
80573: CALL_OW 44
80577: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
80578: LD_VAR 0 12
80582: PPUSH
80583: LD_VAR 0 9
80587: PPUSH
80588: LD_INT 0
80590: PPUSH
80591: CALL 82288 0 3
// end ;
80595: GO 80549
80597: POP
80598: POP
// end ;
80599: LD_VAR 0 10
80603: RET
// export function WantHeal ( sci , unit ) ; begin
80604: LD_INT 0
80606: PPUSH
// if GetTaskList ( sci ) > 0 then
80607: LD_VAR 0 1
80611: PPUSH
80612: CALL_OW 437
80616: PUSH
80617: LD_INT 0
80619: GREATER
80620: IFFALSE 80690
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
80622: LD_VAR 0 1
80626: PPUSH
80627: CALL_OW 437
80631: PUSH
80632: LD_INT 1
80634: ARRAY
80635: PUSH
80636: LD_INT 1
80638: ARRAY
80639: PUSH
80640: LD_STRING l
80642: EQUAL
80643: PUSH
80644: LD_VAR 0 1
80648: PPUSH
80649: CALL_OW 437
80653: PUSH
80654: LD_INT 1
80656: ARRAY
80657: PUSH
80658: LD_INT 4
80660: ARRAY
80661: PUSH
80662: LD_VAR 0 2
80666: EQUAL
80667: AND
80668: IFFALSE 80680
// result := true else
80670: LD_ADDR_VAR 0 3
80674: PUSH
80675: LD_INT 1
80677: ST_TO_ADDR
80678: GO 80688
// result := false ;
80680: LD_ADDR_VAR 0 3
80684: PUSH
80685: LD_INT 0
80687: ST_TO_ADDR
// end else
80688: GO 80698
// result := false ;
80690: LD_ADDR_VAR 0 3
80694: PUSH
80695: LD_INT 0
80697: ST_TO_ADDR
// end ;
80698: LD_VAR 0 3
80702: RET
// export function HealTarget ( sci ) ; begin
80703: LD_INT 0
80705: PPUSH
// if not sci then
80706: LD_VAR 0 1
80710: NOT
80711: IFFALSE 80715
// exit ;
80713: GO 80780
// result := 0 ;
80715: LD_ADDR_VAR 0 2
80719: PUSH
80720: LD_INT 0
80722: ST_TO_ADDR
// if GetTaskList ( sci ) then
80723: LD_VAR 0 1
80727: PPUSH
80728: CALL_OW 437
80732: IFFALSE 80780
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
80734: LD_VAR 0 1
80738: PPUSH
80739: CALL_OW 437
80743: PUSH
80744: LD_INT 1
80746: ARRAY
80747: PUSH
80748: LD_INT 1
80750: ARRAY
80751: PUSH
80752: LD_STRING l
80754: EQUAL
80755: IFFALSE 80780
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
80757: LD_ADDR_VAR 0 2
80761: PUSH
80762: LD_VAR 0 1
80766: PPUSH
80767: CALL_OW 437
80771: PUSH
80772: LD_INT 1
80774: ARRAY
80775: PUSH
80776: LD_INT 4
80778: ARRAY
80779: ST_TO_ADDR
// end ;
80780: LD_VAR 0 2
80784: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
80785: LD_INT 0
80787: PPUSH
80788: PPUSH
80789: PPUSH
80790: PPUSH
// if not base_units then
80791: LD_VAR 0 1
80795: NOT
80796: IFFALSE 80800
// exit ;
80798: GO 80887
// result := false ;
80800: LD_ADDR_VAR 0 2
80804: PUSH
80805: LD_INT 0
80807: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
80808: LD_ADDR_VAR 0 5
80812: PUSH
80813: LD_VAR 0 1
80817: PPUSH
80818: LD_INT 21
80820: PUSH
80821: LD_INT 3
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PPUSH
80828: CALL_OW 72
80832: ST_TO_ADDR
// if not tmp then
80833: LD_VAR 0 5
80837: NOT
80838: IFFALSE 80842
// exit ;
80840: GO 80887
// for i in tmp do
80842: LD_ADDR_VAR 0 3
80846: PUSH
80847: LD_VAR 0 5
80851: PUSH
80852: FOR_IN
80853: IFFALSE 80885
// begin result := EnemyInRange ( i , 22 ) ;
80855: LD_ADDR_VAR 0 2
80859: PUSH
80860: LD_VAR 0 3
80864: PPUSH
80865: LD_INT 22
80867: PPUSH
80868: CALL 79123 0 2
80872: ST_TO_ADDR
// if result then
80873: LD_VAR 0 2
80877: IFFALSE 80883
// exit ;
80879: POP
80880: POP
80881: GO 80887
// end ;
80883: GO 80852
80885: POP
80886: POP
// end ;
80887: LD_VAR 0 2
80891: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
80892: LD_INT 0
80894: PPUSH
80895: PPUSH
// if not units then
80896: LD_VAR 0 1
80900: NOT
80901: IFFALSE 80905
// exit ;
80903: GO 80975
// result := [ ] ;
80905: LD_ADDR_VAR 0 3
80909: PUSH
80910: EMPTY
80911: ST_TO_ADDR
// for i in units do
80912: LD_ADDR_VAR 0 4
80916: PUSH
80917: LD_VAR 0 1
80921: PUSH
80922: FOR_IN
80923: IFFALSE 80973
// if GetTag ( i ) = tag then
80925: LD_VAR 0 4
80929: PPUSH
80930: CALL_OW 110
80934: PUSH
80935: LD_VAR 0 2
80939: EQUAL
80940: IFFALSE 80971
// result := Insert ( result , result + 1 , i ) ;
80942: LD_ADDR_VAR 0 3
80946: PUSH
80947: LD_VAR 0 3
80951: PPUSH
80952: LD_VAR 0 3
80956: PUSH
80957: LD_INT 1
80959: PLUS
80960: PPUSH
80961: LD_VAR 0 4
80965: PPUSH
80966: CALL_OW 2
80970: ST_TO_ADDR
80971: GO 80922
80973: POP
80974: POP
// end ;
80975: LD_VAR 0 3
80979: RET
// export function IsDriver ( un ) ; begin
80980: LD_INT 0
80982: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
80983: LD_ADDR_VAR 0 2
80987: PUSH
80988: LD_VAR 0 1
80992: PUSH
80993: LD_INT 55
80995: PUSH
80996: EMPTY
80997: LIST
80998: PPUSH
80999: CALL_OW 69
81003: IN
81004: ST_TO_ADDR
// end ;
81005: LD_VAR 0 2
81009: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
81010: LD_INT 0
81012: PPUSH
81013: PPUSH
// list := [ ] ;
81014: LD_ADDR_VAR 0 5
81018: PUSH
81019: EMPTY
81020: ST_TO_ADDR
// case d of 0 :
81021: LD_VAR 0 3
81025: PUSH
81026: LD_INT 0
81028: DOUBLE
81029: EQUAL
81030: IFTRUE 81034
81032: GO 81167
81034: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
81035: LD_ADDR_VAR 0 5
81039: PUSH
81040: LD_VAR 0 1
81044: PUSH
81045: LD_INT 4
81047: MINUS
81048: PUSH
81049: LD_VAR 0 2
81053: PUSH
81054: LD_INT 4
81056: MINUS
81057: PUSH
81058: LD_INT 2
81060: PUSH
81061: EMPTY
81062: LIST
81063: LIST
81064: LIST
81065: PUSH
81066: LD_VAR 0 1
81070: PUSH
81071: LD_INT 3
81073: MINUS
81074: PUSH
81075: LD_VAR 0 2
81079: PUSH
81080: LD_INT 1
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: LIST
81087: PUSH
81088: LD_VAR 0 1
81092: PUSH
81093: LD_INT 4
81095: PLUS
81096: PUSH
81097: LD_VAR 0 2
81101: PUSH
81102: LD_INT 4
81104: PUSH
81105: EMPTY
81106: LIST
81107: LIST
81108: LIST
81109: PUSH
81110: LD_VAR 0 1
81114: PUSH
81115: LD_INT 3
81117: PLUS
81118: PUSH
81119: LD_VAR 0 2
81123: PUSH
81124: LD_INT 3
81126: PLUS
81127: PUSH
81128: LD_INT 5
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: LIST
81135: PUSH
81136: LD_VAR 0 1
81140: PUSH
81141: LD_VAR 0 2
81145: PUSH
81146: LD_INT 4
81148: PLUS
81149: PUSH
81150: LD_INT 0
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: LIST
81157: PUSH
81158: EMPTY
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: ST_TO_ADDR
// end ; 1 :
81165: GO 81865
81167: LD_INT 1
81169: DOUBLE
81170: EQUAL
81171: IFTRUE 81175
81173: GO 81308
81175: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
81176: LD_ADDR_VAR 0 5
81180: PUSH
81181: LD_VAR 0 1
81185: PUSH
81186: LD_VAR 0 2
81190: PUSH
81191: LD_INT 4
81193: MINUS
81194: PUSH
81195: LD_INT 3
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: LIST
81202: PUSH
81203: LD_VAR 0 1
81207: PUSH
81208: LD_INT 3
81210: MINUS
81211: PUSH
81212: LD_VAR 0 2
81216: PUSH
81217: LD_INT 3
81219: MINUS
81220: PUSH
81221: LD_INT 2
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: LIST
81228: PUSH
81229: LD_VAR 0 1
81233: PUSH
81234: LD_INT 4
81236: MINUS
81237: PUSH
81238: LD_VAR 0 2
81242: PUSH
81243: LD_INT 1
81245: PUSH
81246: EMPTY
81247: LIST
81248: LIST
81249: LIST
81250: PUSH
81251: LD_VAR 0 1
81255: PUSH
81256: LD_VAR 0 2
81260: PUSH
81261: LD_INT 3
81263: PLUS
81264: PUSH
81265: LD_INT 0
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: LIST
81272: PUSH
81273: LD_VAR 0 1
81277: PUSH
81278: LD_INT 4
81280: PLUS
81281: PUSH
81282: LD_VAR 0 2
81286: PUSH
81287: LD_INT 4
81289: PLUS
81290: PUSH
81291: LD_INT 5
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: LIST
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: LIST
81303: LIST
81304: LIST
81305: ST_TO_ADDR
// end ; 2 :
81306: GO 81865
81308: LD_INT 2
81310: DOUBLE
81311: EQUAL
81312: IFTRUE 81316
81314: GO 81445
81316: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
81317: LD_ADDR_VAR 0 5
81321: PUSH
81322: LD_VAR 0 1
81326: PUSH
81327: LD_VAR 0 2
81331: PUSH
81332: LD_INT 3
81334: MINUS
81335: PUSH
81336: LD_INT 3
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: LIST
81343: PUSH
81344: LD_VAR 0 1
81348: PUSH
81349: LD_INT 4
81351: PLUS
81352: PUSH
81353: LD_VAR 0 2
81357: PUSH
81358: LD_INT 4
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: LIST
81365: PUSH
81366: LD_VAR 0 1
81370: PUSH
81371: LD_VAR 0 2
81375: PUSH
81376: LD_INT 4
81378: PLUS
81379: PUSH
81380: LD_INT 0
81382: PUSH
81383: EMPTY
81384: LIST
81385: LIST
81386: LIST
81387: PUSH
81388: LD_VAR 0 1
81392: PUSH
81393: LD_INT 3
81395: MINUS
81396: PUSH
81397: LD_VAR 0 2
81401: PUSH
81402: LD_INT 1
81404: PUSH
81405: EMPTY
81406: LIST
81407: LIST
81408: LIST
81409: PUSH
81410: LD_VAR 0 1
81414: PUSH
81415: LD_INT 4
81417: MINUS
81418: PUSH
81419: LD_VAR 0 2
81423: PUSH
81424: LD_INT 4
81426: MINUS
81427: PUSH
81428: LD_INT 2
81430: PUSH
81431: EMPTY
81432: LIST
81433: LIST
81434: LIST
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: LIST
81440: LIST
81441: LIST
81442: ST_TO_ADDR
// end ; 3 :
81443: GO 81865
81445: LD_INT 3
81447: DOUBLE
81448: EQUAL
81449: IFTRUE 81453
81451: GO 81586
81453: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
81454: LD_ADDR_VAR 0 5
81458: PUSH
81459: LD_VAR 0 1
81463: PUSH
81464: LD_INT 3
81466: PLUS
81467: PUSH
81468: LD_VAR 0 2
81472: PUSH
81473: LD_INT 4
81475: PUSH
81476: EMPTY
81477: LIST
81478: LIST
81479: LIST
81480: PUSH
81481: LD_VAR 0 1
81485: PUSH
81486: LD_INT 4
81488: PLUS
81489: PUSH
81490: LD_VAR 0 2
81494: PUSH
81495: LD_INT 4
81497: PLUS
81498: PUSH
81499: LD_INT 5
81501: PUSH
81502: EMPTY
81503: LIST
81504: LIST
81505: LIST
81506: PUSH
81507: LD_VAR 0 1
81511: PUSH
81512: LD_INT 4
81514: MINUS
81515: PUSH
81516: LD_VAR 0 2
81520: PUSH
81521: LD_INT 1
81523: PUSH
81524: EMPTY
81525: LIST
81526: LIST
81527: LIST
81528: PUSH
81529: LD_VAR 0 1
81533: PUSH
81534: LD_VAR 0 2
81538: PUSH
81539: LD_INT 4
81541: MINUS
81542: PUSH
81543: LD_INT 3
81545: PUSH
81546: EMPTY
81547: LIST
81548: LIST
81549: LIST
81550: PUSH
81551: LD_VAR 0 1
81555: PUSH
81556: LD_INT 3
81558: MINUS
81559: PUSH
81560: LD_VAR 0 2
81564: PUSH
81565: LD_INT 3
81567: MINUS
81568: PUSH
81569: LD_INT 2
81571: PUSH
81572: EMPTY
81573: LIST
81574: LIST
81575: LIST
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: LIST
81581: LIST
81582: LIST
81583: ST_TO_ADDR
// end ; 4 :
81584: GO 81865
81586: LD_INT 4
81588: DOUBLE
81589: EQUAL
81590: IFTRUE 81594
81592: GO 81727
81594: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
81595: LD_ADDR_VAR 0 5
81599: PUSH
81600: LD_VAR 0 1
81604: PUSH
81605: LD_VAR 0 2
81609: PUSH
81610: LD_INT 4
81612: PLUS
81613: PUSH
81614: LD_INT 0
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: LIST
81621: PUSH
81622: LD_VAR 0 1
81626: PUSH
81627: LD_INT 3
81629: PLUS
81630: PUSH
81631: LD_VAR 0 2
81635: PUSH
81636: LD_INT 3
81638: PLUS
81639: PUSH
81640: LD_INT 5
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: LIST
81647: PUSH
81648: LD_VAR 0 1
81652: PUSH
81653: LD_INT 4
81655: PLUS
81656: PUSH
81657: LD_VAR 0 2
81661: PUSH
81662: LD_INT 4
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: LIST
81669: PUSH
81670: LD_VAR 0 1
81674: PUSH
81675: LD_VAR 0 2
81679: PUSH
81680: LD_INT 3
81682: MINUS
81683: PUSH
81684: LD_INT 3
81686: PUSH
81687: EMPTY
81688: LIST
81689: LIST
81690: LIST
81691: PUSH
81692: LD_VAR 0 1
81696: PUSH
81697: LD_INT 4
81699: MINUS
81700: PUSH
81701: LD_VAR 0 2
81705: PUSH
81706: LD_INT 4
81708: MINUS
81709: PUSH
81710: LD_INT 2
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: LIST
81717: PUSH
81718: EMPTY
81719: LIST
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: ST_TO_ADDR
// end ; 5 :
81725: GO 81865
81727: LD_INT 5
81729: DOUBLE
81730: EQUAL
81731: IFTRUE 81735
81733: GO 81864
81735: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
81736: LD_ADDR_VAR 0 5
81740: PUSH
81741: LD_VAR 0 1
81745: PUSH
81746: LD_INT 4
81748: MINUS
81749: PUSH
81750: LD_VAR 0 2
81754: PUSH
81755: LD_INT 1
81757: PUSH
81758: EMPTY
81759: LIST
81760: LIST
81761: LIST
81762: PUSH
81763: LD_VAR 0 1
81767: PUSH
81768: LD_VAR 0 2
81772: PUSH
81773: LD_INT 4
81775: MINUS
81776: PUSH
81777: LD_INT 3
81779: PUSH
81780: EMPTY
81781: LIST
81782: LIST
81783: LIST
81784: PUSH
81785: LD_VAR 0 1
81789: PUSH
81790: LD_INT 4
81792: PLUS
81793: PUSH
81794: LD_VAR 0 2
81798: PUSH
81799: LD_INT 4
81801: PLUS
81802: PUSH
81803: LD_INT 5
81805: PUSH
81806: EMPTY
81807: LIST
81808: LIST
81809: LIST
81810: PUSH
81811: LD_VAR 0 1
81815: PUSH
81816: LD_INT 3
81818: PLUS
81819: PUSH
81820: LD_VAR 0 2
81824: PUSH
81825: LD_INT 4
81827: PUSH
81828: EMPTY
81829: LIST
81830: LIST
81831: LIST
81832: PUSH
81833: LD_VAR 0 1
81837: PUSH
81838: LD_VAR 0 2
81842: PUSH
81843: LD_INT 3
81845: PLUS
81846: PUSH
81847: LD_INT 0
81849: PUSH
81850: EMPTY
81851: LIST
81852: LIST
81853: LIST
81854: PUSH
81855: EMPTY
81856: LIST
81857: LIST
81858: LIST
81859: LIST
81860: LIST
81861: ST_TO_ADDR
// end ; end ;
81862: GO 81865
81864: POP
// result := list ;
81865: LD_ADDR_VAR 0 4
81869: PUSH
81870: LD_VAR 0 5
81874: ST_TO_ADDR
// end ;
81875: LD_VAR 0 4
81879: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
81880: LD_INT 0
81882: PPUSH
81883: PPUSH
81884: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
81885: LD_VAR 0 1
81889: NOT
81890: PUSH
81891: LD_VAR 0 2
81895: PUSH
81896: LD_INT 1
81898: PUSH
81899: LD_INT 2
81901: PUSH
81902: LD_INT 3
81904: PUSH
81905: LD_INT 4
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: LIST
81912: LIST
81913: IN
81914: NOT
81915: OR
81916: IFFALSE 81920
// exit ;
81918: GO 82012
// tmp := [ ] ;
81920: LD_ADDR_VAR 0 5
81924: PUSH
81925: EMPTY
81926: ST_TO_ADDR
// for i in units do
81927: LD_ADDR_VAR 0 4
81931: PUSH
81932: LD_VAR 0 1
81936: PUSH
81937: FOR_IN
81938: IFFALSE 81981
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
81940: LD_ADDR_VAR 0 5
81944: PUSH
81945: LD_VAR 0 5
81949: PPUSH
81950: LD_VAR 0 5
81954: PUSH
81955: LD_INT 1
81957: PLUS
81958: PPUSH
81959: LD_VAR 0 4
81963: PPUSH
81964: LD_VAR 0 2
81968: PPUSH
81969: CALL_OW 259
81973: PPUSH
81974: CALL_OW 2
81978: ST_TO_ADDR
81979: GO 81937
81981: POP
81982: POP
// if not tmp then
81983: LD_VAR 0 5
81987: NOT
81988: IFFALSE 81992
// exit ;
81990: GO 82012
// result := SortListByListDesc ( units , tmp ) ;
81992: LD_ADDR_VAR 0 3
81996: PUSH
81997: LD_VAR 0 1
82001: PPUSH
82002: LD_VAR 0 5
82006: PPUSH
82007: CALL_OW 77
82011: ST_TO_ADDR
// end ;
82012: LD_VAR 0 3
82016: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
82017: LD_INT 0
82019: PPUSH
82020: PPUSH
82021: PPUSH
// result := false ;
82022: LD_ADDR_VAR 0 3
82026: PUSH
82027: LD_INT 0
82029: ST_TO_ADDR
// x := GetX ( building ) ;
82030: LD_ADDR_VAR 0 4
82034: PUSH
82035: LD_VAR 0 2
82039: PPUSH
82040: CALL_OW 250
82044: ST_TO_ADDR
// y := GetY ( building ) ;
82045: LD_ADDR_VAR 0 5
82049: PUSH
82050: LD_VAR 0 2
82054: PPUSH
82055: CALL_OW 251
82059: ST_TO_ADDR
// if not building or not x or not y then
82060: LD_VAR 0 2
82064: NOT
82065: PUSH
82066: LD_VAR 0 4
82070: NOT
82071: OR
82072: PUSH
82073: LD_VAR 0 5
82077: NOT
82078: OR
82079: IFFALSE 82083
// exit ;
82081: GO 82175
// if GetTaskList ( unit ) then
82083: LD_VAR 0 1
82087: PPUSH
82088: CALL_OW 437
82092: IFFALSE 82175
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
82094: LD_STRING e
82096: PUSH
82097: LD_VAR 0 1
82101: PPUSH
82102: CALL_OW 437
82106: PUSH
82107: LD_INT 1
82109: ARRAY
82110: PUSH
82111: LD_INT 1
82113: ARRAY
82114: EQUAL
82115: PUSH
82116: LD_VAR 0 4
82120: PUSH
82121: LD_VAR 0 1
82125: PPUSH
82126: CALL_OW 437
82130: PUSH
82131: LD_INT 1
82133: ARRAY
82134: PUSH
82135: LD_INT 2
82137: ARRAY
82138: EQUAL
82139: AND
82140: PUSH
82141: LD_VAR 0 5
82145: PUSH
82146: LD_VAR 0 1
82150: PPUSH
82151: CALL_OW 437
82155: PUSH
82156: LD_INT 1
82158: ARRAY
82159: PUSH
82160: LD_INT 3
82162: ARRAY
82163: EQUAL
82164: AND
82165: IFFALSE 82175
// result := true end ;
82167: LD_ADDR_VAR 0 3
82171: PUSH
82172: LD_INT 1
82174: ST_TO_ADDR
// end ;
82175: LD_VAR 0 3
82179: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
82180: LD_INT 0
82182: PPUSH
// result := false ;
82183: LD_ADDR_VAR 0 4
82187: PUSH
82188: LD_INT 0
82190: ST_TO_ADDR
// if GetTaskList ( unit ) then
82191: LD_VAR 0 1
82195: PPUSH
82196: CALL_OW 437
82200: IFFALSE 82283
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
82202: LD_STRING M
82204: PUSH
82205: LD_VAR 0 1
82209: PPUSH
82210: CALL_OW 437
82214: PUSH
82215: LD_INT 1
82217: ARRAY
82218: PUSH
82219: LD_INT 1
82221: ARRAY
82222: EQUAL
82223: PUSH
82224: LD_VAR 0 2
82228: PUSH
82229: LD_VAR 0 1
82233: PPUSH
82234: CALL_OW 437
82238: PUSH
82239: LD_INT 1
82241: ARRAY
82242: PUSH
82243: LD_INT 2
82245: ARRAY
82246: EQUAL
82247: AND
82248: PUSH
82249: LD_VAR 0 3
82253: PUSH
82254: LD_VAR 0 1
82258: PPUSH
82259: CALL_OW 437
82263: PUSH
82264: LD_INT 1
82266: ARRAY
82267: PUSH
82268: LD_INT 3
82270: ARRAY
82271: EQUAL
82272: AND
82273: IFFALSE 82283
// result := true ;
82275: LD_ADDR_VAR 0 4
82279: PUSH
82280: LD_INT 1
82282: ST_TO_ADDR
// end ; end ;
82283: LD_VAR 0 4
82287: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
82288: LD_INT 0
82290: PPUSH
82291: PPUSH
82292: PPUSH
82293: PPUSH
// if not unit or not area then
82294: LD_VAR 0 1
82298: NOT
82299: PUSH
82300: LD_VAR 0 2
82304: NOT
82305: OR
82306: IFFALSE 82310
// exit ;
82308: GO 82474
// tmp := AreaToList ( area , i ) ;
82310: LD_ADDR_VAR 0 6
82314: PUSH
82315: LD_VAR 0 2
82319: PPUSH
82320: LD_VAR 0 5
82324: PPUSH
82325: CALL_OW 517
82329: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
82330: LD_ADDR_VAR 0 5
82334: PUSH
82335: DOUBLE
82336: LD_INT 1
82338: DEC
82339: ST_TO_ADDR
82340: LD_VAR 0 6
82344: PUSH
82345: LD_INT 1
82347: ARRAY
82348: PUSH
82349: FOR_TO
82350: IFFALSE 82472
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
82352: LD_ADDR_VAR 0 7
82356: PUSH
82357: LD_VAR 0 6
82361: PUSH
82362: LD_INT 1
82364: ARRAY
82365: PUSH
82366: LD_VAR 0 5
82370: ARRAY
82371: PUSH
82372: LD_VAR 0 6
82376: PUSH
82377: LD_INT 2
82379: ARRAY
82380: PUSH
82381: LD_VAR 0 5
82385: ARRAY
82386: PUSH
82387: EMPTY
82388: LIST
82389: LIST
82390: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
82391: LD_VAR 0 7
82395: PUSH
82396: LD_INT 1
82398: ARRAY
82399: PPUSH
82400: LD_VAR 0 7
82404: PUSH
82405: LD_INT 2
82407: ARRAY
82408: PPUSH
82409: CALL_OW 428
82413: PUSH
82414: LD_INT 0
82416: EQUAL
82417: IFFALSE 82470
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
82419: LD_VAR 0 1
82423: PPUSH
82424: LD_VAR 0 7
82428: PUSH
82429: LD_INT 1
82431: ARRAY
82432: PPUSH
82433: LD_VAR 0 7
82437: PUSH
82438: LD_INT 2
82440: ARRAY
82441: PPUSH
82442: LD_VAR 0 3
82446: PPUSH
82447: CALL_OW 48
// result := IsPlaced ( unit ) ;
82451: LD_ADDR_VAR 0 4
82455: PUSH
82456: LD_VAR 0 1
82460: PPUSH
82461: CALL_OW 305
82465: ST_TO_ADDR
// exit ;
82466: POP
82467: POP
82468: GO 82474
// end ; end ;
82470: GO 82349
82472: POP
82473: POP
// end ;
82474: LD_VAR 0 4
82478: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
82479: LD_INT 0
82481: PPUSH
82482: PPUSH
82483: PPUSH
// if not side or side > 8 then
82484: LD_VAR 0 1
82488: NOT
82489: PUSH
82490: LD_VAR 0 1
82494: PUSH
82495: LD_INT 8
82497: GREATER
82498: OR
82499: IFFALSE 82503
// exit ;
82501: GO 82690
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
82503: LD_ADDR_VAR 0 4
82507: PUSH
82508: LD_INT 22
82510: PUSH
82511: LD_VAR 0 1
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PUSH
82520: LD_INT 21
82522: PUSH
82523: LD_INT 3
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: PPUSH
82534: CALL_OW 69
82538: ST_TO_ADDR
// if not tmp then
82539: LD_VAR 0 4
82543: NOT
82544: IFFALSE 82548
// exit ;
82546: GO 82690
// enable_addtolog := true ;
82548: LD_ADDR_OWVAR 81
82552: PUSH
82553: LD_INT 1
82555: ST_TO_ADDR
// AddToLog ( [ ) ;
82556: LD_STRING [
82558: PPUSH
82559: CALL_OW 561
// for i in tmp do
82563: LD_ADDR_VAR 0 3
82567: PUSH
82568: LD_VAR 0 4
82572: PUSH
82573: FOR_IN
82574: IFFALSE 82681
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
82576: LD_STRING [
82578: PUSH
82579: LD_VAR 0 3
82583: PPUSH
82584: CALL_OW 266
82588: STR
82589: PUSH
82590: LD_STRING , 
82592: STR
82593: PUSH
82594: LD_VAR 0 3
82598: PPUSH
82599: CALL_OW 250
82603: STR
82604: PUSH
82605: LD_STRING , 
82607: STR
82608: PUSH
82609: LD_VAR 0 3
82613: PPUSH
82614: CALL_OW 251
82618: STR
82619: PUSH
82620: LD_STRING , 
82622: STR
82623: PUSH
82624: LD_VAR 0 3
82628: PPUSH
82629: CALL_OW 254
82633: STR
82634: PUSH
82635: LD_STRING , 
82637: STR
82638: PUSH
82639: LD_VAR 0 3
82643: PPUSH
82644: LD_INT 1
82646: PPUSH
82647: CALL_OW 268
82651: STR
82652: PUSH
82653: LD_STRING , 
82655: STR
82656: PUSH
82657: LD_VAR 0 3
82661: PPUSH
82662: LD_INT 2
82664: PPUSH
82665: CALL_OW 268
82669: STR
82670: PUSH
82671: LD_STRING ],
82673: STR
82674: PPUSH
82675: CALL_OW 561
// end ;
82679: GO 82573
82681: POP
82682: POP
// AddToLog ( ]; ) ;
82683: LD_STRING ];
82685: PPUSH
82686: CALL_OW 561
// end ;
82690: LD_VAR 0 2
82694: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
82695: LD_INT 0
82697: PPUSH
82698: PPUSH
82699: PPUSH
82700: PPUSH
82701: PPUSH
// if not area or not rate or not max then
82702: LD_VAR 0 1
82706: NOT
82707: PUSH
82708: LD_VAR 0 2
82712: NOT
82713: OR
82714: PUSH
82715: LD_VAR 0 4
82719: NOT
82720: OR
82721: IFFALSE 82725
// exit ;
82723: GO 82917
// while 1 do
82725: LD_INT 1
82727: IFFALSE 82917
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
82729: LD_ADDR_VAR 0 9
82733: PUSH
82734: LD_VAR 0 1
82738: PPUSH
82739: LD_INT 1
82741: PPUSH
82742: CALL_OW 287
82746: PUSH
82747: LD_INT 10
82749: MUL
82750: ST_TO_ADDR
// r := rate / 10 ;
82751: LD_ADDR_VAR 0 7
82755: PUSH
82756: LD_VAR 0 2
82760: PUSH
82761: LD_INT 10
82763: DIVREAL
82764: ST_TO_ADDR
// time := 1 1$00 ;
82765: LD_ADDR_VAR 0 8
82769: PUSH
82770: LD_INT 2100
82772: ST_TO_ADDR
// if amount < min then
82773: LD_VAR 0 9
82777: PUSH
82778: LD_VAR 0 3
82782: LESS
82783: IFFALSE 82801
// r := r * 2 else
82785: LD_ADDR_VAR 0 7
82789: PUSH
82790: LD_VAR 0 7
82794: PUSH
82795: LD_INT 2
82797: MUL
82798: ST_TO_ADDR
82799: GO 82827
// if amount > max then
82801: LD_VAR 0 9
82805: PUSH
82806: LD_VAR 0 4
82810: GREATER
82811: IFFALSE 82827
// r := r / 2 ;
82813: LD_ADDR_VAR 0 7
82817: PUSH
82818: LD_VAR 0 7
82822: PUSH
82823: LD_INT 2
82825: DIVREAL
82826: ST_TO_ADDR
// time := time / r ;
82827: LD_ADDR_VAR 0 8
82831: PUSH
82832: LD_VAR 0 8
82836: PUSH
82837: LD_VAR 0 7
82841: DIVREAL
82842: ST_TO_ADDR
// if time < 0 then
82843: LD_VAR 0 8
82847: PUSH
82848: LD_INT 0
82850: LESS
82851: IFFALSE 82868
// time := time * - 1 ;
82853: LD_ADDR_VAR 0 8
82857: PUSH
82858: LD_VAR 0 8
82862: PUSH
82863: LD_INT 1
82865: NEG
82866: MUL
82867: ST_TO_ADDR
// wait ( time ) ;
82868: LD_VAR 0 8
82872: PPUSH
82873: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
82877: LD_INT 35
82879: PPUSH
82880: LD_INT 875
82882: PPUSH
82883: CALL_OW 12
82887: PPUSH
82888: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
82892: LD_INT 1
82894: PPUSH
82895: LD_INT 5
82897: PPUSH
82898: CALL_OW 12
82902: PPUSH
82903: LD_VAR 0 1
82907: PPUSH
82908: LD_INT 1
82910: PPUSH
82911: CALL_OW 55
// end ;
82915: GO 82725
// end ;
82917: LD_VAR 0 5
82921: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
82922: LD_INT 0
82924: PPUSH
82925: PPUSH
82926: PPUSH
82927: PPUSH
82928: PPUSH
82929: PPUSH
82930: PPUSH
82931: PPUSH
// if not turrets or not factories then
82932: LD_VAR 0 1
82936: NOT
82937: PUSH
82938: LD_VAR 0 2
82942: NOT
82943: OR
82944: IFFALSE 82948
// exit ;
82946: GO 83255
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
82948: LD_ADDR_VAR 0 10
82952: PUSH
82953: LD_INT 5
82955: PUSH
82956: LD_INT 6
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 2
82965: PUSH
82966: LD_INT 4
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 3
82975: PUSH
82976: LD_INT 5
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: LIST
82987: PUSH
82988: LD_INT 24
82990: PUSH
82991: LD_INT 25
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PUSH
82998: LD_INT 23
83000: PUSH
83001: LD_INT 27
83003: PUSH
83004: EMPTY
83005: LIST
83006: LIST
83007: PUSH
83008: EMPTY
83009: LIST
83010: LIST
83011: PUSH
83012: LD_INT 42
83014: PUSH
83015: LD_INT 43
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 44
83024: PUSH
83025: LD_INT 46
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PUSH
83032: LD_INT 45
83034: PUSH
83035: LD_INT 47
83037: PUSH
83038: EMPTY
83039: LIST
83040: LIST
83041: PUSH
83042: EMPTY
83043: LIST
83044: LIST
83045: LIST
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: LIST
83051: ST_TO_ADDR
// result := [ ] ;
83052: LD_ADDR_VAR 0 3
83056: PUSH
83057: EMPTY
83058: ST_TO_ADDR
// for i in turrets do
83059: LD_ADDR_VAR 0 4
83063: PUSH
83064: LD_VAR 0 1
83068: PUSH
83069: FOR_IN
83070: IFFALSE 83253
// begin nat := GetNation ( i ) ;
83072: LD_ADDR_VAR 0 7
83076: PUSH
83077: LD_VAR 0 4
83081: PPUSH
83082: CALL_OW 248
83086: ST_TO_ADDR
// weapon := 0 ;
83087: LD_ADDR_VAR 0 8
83091: PUSH
83092: LD_INT 0
83094: ST_TO_ADDR
// if not nat then
83095: LD_VAR 0 7
83099: NOT
83100: IFFALSE 83104
// continue ;
83102: GO 83069
// for j in list [ nat ] do
83104: LD_ADDR_VAR 0 5
83108: PUSH
83109: LD_VAR 0 10
83113: PUSH
83114: LD_VAR 0 7
83118: ARRAY
83119: PUSH
83120: FOR_IN
83121: IFFALSE 83162
// if GetBWeapon ( i ) = j [ 1 ] then
83123: LD_VAR 0 4
83127: PPUSH
83128: CALL_OW 269
83132: PUSH
83133: LD_VAR 0 5
83137: PUSH
83138: LD_INT 1
83140: ARRAY
83141: EQUAL
83142: IFFALSE 83160
// begin weapon := j [ 2 ] ;
83144: LD_ADDR_VAR 0 8
83148: PUSH
83149: LD_VAR 0 5
83153: PUSH
83154: LD_INT 2
83156: ARRAY
83157: ST_TO_ADDR
// break ;
83158: GO 83162
// end ;
83160: GO 83120
83162: POP
83163: POP
// if not weapon then
83164: LD_VAR 0 8
83168: NOT
83169: IFFALSE 83173
// continue ;
83171: GO 83069
// for k in factories do
83173: LD_ADDR_VAR 0 6
83177: PUSH
83178: LD_VAR 0 2
83182: PUSH
83183: FOR_IN
83184: IFFALSE 83249
// begin weapons := AvailableWeaponList ( k ) ;
83186: LD_ADDR_VAR 0 9
83190: PUSH
83191: LD_VAR 0 6
83195: PPUSH
83196: CALL_OW 478
83200: ST_TO_ADDR
// if not weapons then
83201: LD_VAR 0 9
83205: NOT
83206: IFFALSE 83210
// continue ;
83208: GO 83183
// if weapon in weapons then
83210: LD_VAR 0 8
83214: PUSH
83215: LD_VAR 0 9
83219: IN
83220: IFFALSE 83247
// begin result := [ i , weapon ] ;
83222: LD_ADDR_VAR 0 3
83226: PUSH
83227: LD_VAR 0 4
83231: PUSH
83232: LD_VAR 0 8
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: ST_TO_ADDR
// exit ;
83241: POP
83242: POP
83243: POP
83244: POP
83245: GO 83255
// end ; end ;
83247: GO 83183
83249: POP
83250: POP
// end ;
83251: GO 83069
83253: POP
83254: POP
// end ;
83255: LD_VAR 0 3
83259: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
83260: LD_INT 0
83262: PPUSH
// if not side or side > 8 then
83263: LD_VAR 0 3
83267: NOT
83268: PUSH
83269: LD_VAR 0 3
83273: PUSH
83274: LD_INT 8
83276: GREATER
83277: OR
83278: IFFALSE 83282
// exit ;
83280: GO 83341
// if not range then
83282: LD_VAR 0 4
83286: NOT
83287: IFFALSE 83298
// range := - 12 ;
83289: LD_ADDR_VAR 0 4
83293: PUSH
83294: LD_INT 12
83296: NEG
83297: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
83298: LD_VAR 0 1
83302: PPUSH
83303: LD_VAR 0 2
83307: PPUSH
83308: LD_VAR 0 3
83312: PPUSH
83313: LD_VAR 0 4
83317: PPUSH
83318: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
83322: LD_VAR 0 1
83326: PPUSH
83327: LD_VAR 0 2
83331: PPUSH
83332: LD_VAR 0 3
83336: PPUSH
83337: CALL_OW 331
// end ;
83341: LD_VAR 0 5
83345: RET
// export function Video ( mode ) ; begin
83346: LD_INT 0
83348: PPUSH
// ingame_video = mode ;
83349: LD_ADDR_OWVAR 52
83353: PUSH
83354: LD_VAR 0 1
83358: ST_TO_ADDR
// interface_hidden = mode ;
83359: LD_ADDR_OWVAR 54
83363: PUSH
83364: LD_VAR 0 1
83368: ST_TO_ADDR
// end ;
83369: LD_VAR 0 2
83373: RET
// export function Join ( array , element ) ; begin
83374: LD_INT 0
83376: PPUSH
// result := Replace ( array , array + 1 , element ) ;
83377: LD_ADDR_VAR 0 3
83381: PUSH
83382: LD_VAR 0 1
83386: PPUSH
83387: LD_VAR 0 1
83391: PUSH
83392: LD_INT 1
83394: PLUS
83395: PPUSH
83396: LD_VAR 0 2
83400: PPUSH
83401: CALL_OW 1
83405: ST_TO_ADDR
// end ;
83406: LD_VAR 0 3
83410: RET
// export function JoinUnion ( array , element ) ; begin
83411: LD_INT 0
83413: PPUSH
// result := array union element ;
83414: LD_ADDR_VAR 0 3
83418: PUSH
83419: LD_VAR 0 1
83423: PUSH
83424: LD_VAR 0 2
83428: UNION
83429: ST_TO_ADDR
// end ;
83430: LD_VAR 0 3
83434: RET
// export function GetBehemoths ( side ) ; begin
83435: LD_INT 0
83437: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
83438: LD_ADDR_VAR 0 2
83442: PUSH
83443: LD_INT 22
83445: PUSH
83446: LD_VAR 0 1
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 31
83457: PUSH
83458: LD_INT 25
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: PUSH
83465: EMPTY
83466: LIST
83467: LIST
83468: PPUSH
83469: CALL_OW 69
83473: ST_TO_ADDR
// end ;
83474: LD_VAR 0 2
83478: RET
// export function Shuffle ( array ) ; var i , index ; begin
83479: LD_INT 0
83481: PPUSH
83482: PPUSH
83483: PPUSH
// result := [ ] ;
83484: LD_ADDR_VAR 0 2
83488: PUSH
83489: EMPTY
83490: ST_TO_ADDR
// if not array then
83491: LD_VAR 0 1
83495: NOT
83496: IFFALSE 83500
// exit ;
83498: GO 83599
// Randomize ;
83500: CALL_OW 10
// for i = array downto 1 do
83504: LD_ADDR_VAR 0 3
83508: PUSH
83509: DOUBLE
83510: LD_VAR 0 1
83514: INC
83515: ST_TO_ADDR
83516: LD_INT 1
83518: PUSH
83519: FOR_DOWNTO
83520: IFFALSE 83597
// begin index := rand ( 1 , array ) ;
83522: LD_ADDR_VAR 0 4
83526: PUSH
83527: LD_INT 1
83529: PPUSH
83530: LD_VAR 0 1
83534: PPUSH
83535: CALL_OW 12
83539: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
83540: LD_ADDR_VAR 0 2
83544: PUSH
83545: LD_VAR 0 2
83549: PPUSH
83550: LD_VAR 0 2
83554: PUSH
83555: LD_INT 1
83557: PLUS
83558: PPUSH
83559: LD_VAR 0 1
83563: PUSH
83564: LD_VAR 0 4
83568: ARRAY
83569: PPUSH
83570: CALL_OW 2
83574: ST_TO_ADDR
// array := Delete ( array , index ) ;
83575: LD_ADDR_VAR 0 1
83579: PUSH
83580: LD_VAR 0 1
83584: PPUSH
83585: LD_VAR 0 4
83589: PPUSH
83590: CALL_OW 3
83594: ST_TO_ADDR
// end ;
83595: GO 83519
83597: POP
83598: POP
// end ;
83599: LD_VAR 0 2
83603: RET
// export function GetBaseMaterials ( base ) ; begin
83604: LD_INT 0
83606: PPUSH
// result := [ 0 , 0 , 0 ] ;
83607: LD_ADDR_VAR 0 2
83611: PUSH
83612: LD_INT 0
83614: PUSH
83615: LD_INT 0
83617: PUSH
83618: LD_INT 0
83620: PUSH
83621: EMPTY
83622: LIST
83623: LIST
83624: LIST
83625: ST_TO_ADDR
// if not base then
83626: LD_VAR 0 1
83630: NOT
83631: IFFALSE 83635
// exit ;
83633: GO 83684
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
83635: LD_ADDR_VAR 0 2
83639: PUSH
83640: LD_VAR 0 1
83644: PPUSH
83645: LD_INT 1
83647: PPUSH
83648: CALL_OW 275
83652: PUSH
83653: LD_VAR 0 1
83657: PPUSH
83658: LD_INT 2
83660: PPUSH
83661: CALL_OW 275
83665: PUSH
83666: LD_VAR 0 1
83670: PPUSH
83671: LD_INT 3
83673: PPUSH
83674: CALL_OW 275
83678: PUSH
83679: EMPTY
83680: LIST
83681: LIST
83682: LIST
83683: ST_TO_ADDR
// end ;
83684: LD_VAR 0 2
83688: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
83689: LD_INT 0
83691: PPUSH
83692: PPUSH
// result := array ;
83693: LD_ADDR_VAR 0 3
83697: PUSH
83698: LD_VAR 0 1
83702: ST_TO_ADDR
// if size > 0 then
83703: LD_VAR 0 2
83707: PUSH
83708: LD_INT 0
83710: GREATER
83711: IFFALSE 83757
// for i := array downto size do
83713: LD_ADDR_VAR 0 4
83717: PUSH
83718: DOUBLE
83719: LD_VAR 0 1
83723: INC
83724: ST_TO_ADDR
83725: LD_VAR 0 2
83729: PUSH
83730: FOR_DOWNTO
83731: IFFALSE 83755
// result := Delete ( result , result ) ;
83733: LD_ADDR_VAR 0 3
83737: PUSH
83738: LD_VAR 0 3
83742: PPUSH
83743: LD_VAR 0 3
83747: PPUSH
83748: CALL_OW 3
83752: ST_TO_ADDR
83753: GO 83730
83755: POP
83756: POP
// end ;
83757: LD_VAR 0 3
83761: RET
// export function ComExit ( unit ) ; var tmp ; begin
83762: LD_INT 0
83764: PPUSH
83765: PPUSH
// if not IsInUnit ( unit ) then
83766: LD_VAR 0 1
83770: PPUSH
83771: CALL_OW 310
83775: NOT
83776: IFFALSE 83780
// exit ;
83778: GO 83840
// tmp := IsInUnit ( unit ) ;
83780: LD_ADDR_VAR 0 3
83784: PUSH
83785: LD_VAR 0 1
83789: PPUSH
83790: CALL_OW 310
83794: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
83795: LD_VAR 0 3
83799: PPUSH
83800: CALL_OW 247
83804: PUSH
83805: LD_INT 2
83807: EQUAL
83808: IFFALSE 83821
// ComExitVehicle ( unit ) else
83810: LD_VAR 0 1
83814: PPUSH
83815: CALL_OW 121
83819: GO 83830
// ComExitBuilding ( unit ) ;
83821: LD_VAR 0 1
83825: PPUSH
83826: CALL_OW 122
// result := tmp ;
83830: LD_ADDR_VAR 0 2
83834: PUSH
83835: LD_VAR 0 3
83839: ST_TO_ADDR
// end ;
83840: LD_VAR 0 2
83844: RET
// export function ResetHc ; begin
83845: LD_INT 0
83847: PPUSH
// InitHc ;
83848: CALL_OW 19
// hc_importance := 0 ;
83852: LD_ADDR_OWVAR 32
83856: PUSH
83857: LD_INT 0
83859: ST_TO_ADDR
// end ;
83860: LD_VAR 0 1
83864: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
83865: LD_INT 0
83867: PPUSH
83868: PPUSH
83869: PPUSH
// _x := ( x1 + x2 ) div 2 ;
83870: LD_ADDR_VAR 0 6
83874: PUSH
83875: LD_VAR 0 1
83879: PUSH
83880: LD_VAR 0 3
83884: PLUS
83885: PUSH
83886: LD_INT 2
83888: DIV
83889: ST_TO_ADDR
// if _x < 0 then
83890: LD_VAR 0 6
83894: PUSH
83895: LD_INT 0
83897: LESS
83898: IFFALSE 83915
// _x := _x * - 1 ;
83900: LD_ADDR_VAR 0 6
83904: PUSH
83905: LD_VAR 0 6
83909: PUSH
83910: LD_INT 1
83912: NEG
83913: MUL
83914: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
83915: LD_ADDR_VAR 0 7
83919: PUSH
83920: LD_VAR 0 2
83924: PUSH
83925: LD_VAR 0 4
83929: PLUS
83930: PUSH
83931: LD_INT 2
83933: DIV
83934: ST_TO_ADDR
// if _y < 0 then
83935: LD_VAR 0 7
83939: PUSH
83940: LD_INT 0
83942: LESS
83943: IFFALSE 83960
// _y := _y * - 1 ;
83945: LD_ADDR_VAR 0 7
83949: PUSH
83950: LD_VAR 0 7
83954: PUSH
83955: LD_INT 1
83957: NEG
83958: MUL
83959: ST_TO_ADDR
// result := [ _x , _y ] ;
83960: LD_ADDR_VAR 0 5
83964: PUSH
83965: LD_VAR 0 6
83969: PUSH
83970: LD_VAR 0 7
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: ST_TO_ADDR
// end ;
83979: LD_VAR 0 5
83983: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
83984: LD_INT 0
83986: PPUSH
83987: PPUSH
83988: PPUSH
83989: PPUSH
// task := GetTaskList ( unit ) ;
83990: LD_ADDR_VAR 0 7
83994: PUSH
83995: LD_VAR 0 1
83999: PPUSH
84000: CALL_OW 437
84004: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
84005: LD_VAR 0 7
84009: NOT
84010: PUSH
84011: LD_VAR 0 1
84015: PPUSH
84016: LD_VAR 0 2
84020: PPUSH
84021: CALL_OW 308
84025: NOT
84026: AND
84027: IFFALSE 84031
// exit ;
84029: GO 84149
// if IsInArea ( unit , area ) then
84031: LD_VAR 0 1
84035: PPUSH
84036: LD_VAR 0 2
84040: PPUSH
84041: CALL_OW 308
84045: IFFALSE 84063
// begin ComMoveToArea ( unit , goAway ) ;
84047: LD_VAR 0 1
84051: PPUSH
84052: LD_VAR 0 3
84056: PPUSH
84057: CALL_OW 113
// exit ;
84061: GO 84149
// end ; if task [ 1 ] [ 1 ] <> M then
84063: LD_VAR 0 7
84067: PUSH
84068: LD_INT 1
84070: ARRAY
84071: PUSH
84072: LD_INT 1
84074: ARRAY
84075: PUSH
84076: LD_STRING M
84078: NONEQUAL
84079: IFFALSE 84083
// exit ;
84081: GO 84149
// x := task [ 1 ] [ 2 ] ;
84083: LD_ADDR_VAR 0 5
84087: PUSH
84088: LD_VAR 0 7
84092: PUSH
84093: LD_INT 1
84095: ARRAY
84096: PUSH
84097: LD_INT 2
84099: ARRAY
84100: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
84101: LD_ADDR_VAR 0 6
84105: PUSH
84106: LD_VAR 0 7
84110: PUSH
84111: LD_INT 1
84113: ARRAY
84114: PUSH
84115: LD_INT 3
84117: ARRAY
84118: ST_TO_ADDR
// if InArea ( x , y , area ) then
84119: LD_VAR 0 5
84123: PPUSH
84124: LD_VAR 0 6
84128: PPUSH
84129: LD_VAR 0 2
84133: PPUSH
84134: CALL_OW 309
84138: IFFALSE 84149
// ComStop ( unit ) ;
84140: LD_VAR 0 1
84144: PPUSH
84145: CALL_OW 141
// end ;
84149: LD_VAR 0 4
84153: RET
// export function Abs ( value ) ; begin
84154: LD_INT 0
84156: PPUSH
// result := value ;
84157: LD_ADDR_VAR 0 2
84161: PUSH
84162: LD_VAR 0 1
84166: ST_TO_ADDR
// if value < 0 then
84167: LD_VAR 0 1
84171: PUSH
84172: LD_INT 0
84174: LESS
84175: IFFALSE 84192
// result := value * - 1 ;
84177: LD_ADDR_VAR 0 2
84181: PUSH
84182: LD_VAR 0 1
84186: PUSH
84187: LD_INT 1
84189: NEG
84190: MUL
84191: ST_TO_ADDR
// end ; end_of_file
84192: LD_VAR 0 2
84196: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
84197: LD_INT 0
84199: PPUSH
// ar_miner := 81 ;
84200: LD_ADDR_EXP 100
84204: PUSH
84205: LD_INT 81
84207: ST_TO_ADDR
// ar_crane := 88 ;
84208: LD_ADDR_EXP 99
84212: PUSH
84213: LD_INT 88
84215: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
84216: LD_ADDR_EXP 94
84220: PUSH
84221: LD_INT 89
84223: ST_TO_ADDR
// us_hack := 99 ;
84224: LD_ADDR_EXP 95
84228: PUSH
84229: LD_INT 99
84231: ST_TO_ADDR
// us_artillery := 97 ;
84232: LD_ADDR_EXP 96
84236: PUSH
84237: LD_INT 97
84239: ST_TO_ADDR
// ar_bio_bomb := 91 ;
84240: LD_ADDR_EXP 97
84244: PUSH
84245: LD_INT 91
84247: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
84248: LD_ADDR_EXP 98
84252: PUSH
84253: LD_INT 92
84255: ST_TO_ADDR
// ru_radar := 98 ;
84256: LD_ADDR_EXP 93
84260: PUSH
84261: LD_INT 98
84263: ST_TO_ADDR
// tech_Artillery := 80 ;
84264: LD_ADDR_EXP 101
84268: PUSH
84269: LD_INT 80
84271: ST_TO_ADDR
// tech_RadMat := 81 ;
84272: LD_ADDR_EXP 102
84276: PUSH
84277: LD_INT 81
84279: ST_TO_ADDR
// tech_BasicTools := 82 ;
84280: LD_ADDR_EXP 103
84284: PUSH
84285: LD_INT 82
84287: ST_TO_ADDR
// tech_Cargo := 83 ;
84288: LD_ADDR_EXP 104
84292: PUSH
84293: LD_INT 83
84295: ST_TO_ADDR
// tech_Track := 84 ;
84296: LD_ADDR_EXP 105
84300: PUSH
84301: LD_INT 84
84303: ST_TO_ADDR
// tech_Crane := 85 ;
84304: LD_ADDR_EXP 106
84308: PUSH
84309: LD_INT 85
84311: ST_TO_ADDR
// tech_Bulldozer := 86 ;
84312: LD_ADDR_EXP 107
84316: PUSH
84317: LD_INT 86
84319: ST_TO_ADDR
// tech_Hovercraft := 87 ;
84320: LD_ADDR_EXP 108
84324: PUSH
84325: LD_INT 87
84327: ST_TO_ADDR
// end ;
84328: LD_VAR 0 1
84332: RET
// every 1 do
84333: GO 84335
84335: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
84336: CALL 84197 0 0
84340: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
84341: LD_VAR 0 2
84345: PUSH
84346: LD_INT 100
84348: EQUAL
84349: IFFALSE 85298
// begin if not StreamModeActive then
84351: LD_EXP 109
84355: NOT
84356: IFFALSE 84366
// StreamModeActive := true ;
84358: LD_ADDR_EXP 109
84362: PUSH
84363: LD_INT 1
84365: ST_TO_ADDR
// if p3 = 0 then
84366: LD_VAR 0 3
84370: PUSH
84371: LD_INT 0
84373: EQUAL
84374: IFFALSE 84380
// InitStreamMode ;
84376: CALL 85456 0 0
// if p3 = 1 then
84380: LD_VAR 0 3
84384: PUSH
84385: LD_INT 1
84387: EQUAL
84388: IFFALSE 84398
// sRocket := true ;
84390: LD_ADDR_EXP 114
84394: PUSH
84395: LD_INT 1
84397: ST_TO_ADDR
// if p3 = 2 then
84398: LD_VAR 0 3
84402: PUSH
84403: LD_INT 2
84405: EQUAL
84406: IFFALSE 84416
// sSpeed := true ;
84408: LD_ADDR_EXP 113
84412: PUSH
84413: LD_INT 1
84415: ST_TO_ADDR
// if p3 = 3 then
84416: LD_VAR 0 3
84420: PUSH
84421: LD_INT 3
84423: EQUAL
84424: IFFALSE 84434
// sEngine := true ;
84426: LD_ADDR_EXP 115
84430: PUSH
84431: LD_INT 1
84433: ST_TO_ADDR
// if p3 = 4 then
84434: LD_VAR 0 3
84438: PUSH
84439: LD_INT 4
84441: EQUAL
84442: IFFALSE 84452
// sSpec := true ;
84444: LD_ADDR_EXP 112
84448: PUSH
84449: LD_INT 1
84451: ST_TO_ADDR
// if p3 = 5 then
84452: LD_VAR 0 3
84456: PUSH
84457: LD_INT 5
84459: EQUAL
84460: IFFALSE 84470
// sLevel := true ;
84462: LD_ADDR_EXP 116
84466: PUSH
84467: LD_INT 1
84469: ST_TO_ADDR
// if p3 = 6 then
84470: LD_VAR 0 3
84474: PUSH
84475: LD_INT 6
84477: EQUAL
84478: IFFALSE 84488
// sArmoury := true ;
84480: LD_ADDR_EXP 117
84484: PUSH
84485: LD_INT 1
84487: ST_TO_ADDR
// if p3 = 7 then
84488: LD_VAR 0 3
84492: PUSH
84493: LD_INT 7
84495: EQUAL
84496: IFFALSE 84506
// sRadar := true ;
84498: LD_ADDR_EXP 118
84502: PUSH
84503: LD_INT 1
84505: ST_TO_ADDR
// if p3 = 8 then
84506: LD_VAR 0 3
84510: PUSH
84511: LD_INT 8
84513: EQUAL
84514: IFFALSE 84524
// sBunker := true ;
84516: LD_ADDR_EXP 119
84520: PUSH
84521: LD_INT 1
84523: ST_TO_ADDR
// if p3 = 9 then
84524: LD_VAR 0 3
84528: PUSH
84529: LD_INT 9
84531: EQUAL
84532: IFFALSE 84542
// sHack := true ;
84534: LD_ADDR_EXP 120
84538: PUSH
84539: LD_INT 1
84541: ST_TO_ADDR
// if p3 = 10 then
84542: LD_VAR 0 3
84546: PUSH
84547: LD_INT 10
84549: EQUAL
84550: IFFALSE 84560
// sFire := true ;
84552: LD_ADDR_EXP 121
84556: PUSH
84557: LD_INT 1
84559: ST_TO_ADDR
// if p3 = 11 then
84560: LD_VAR 0 3
84564: PUSH
84565: LD_INT 11
84567: EQUAL
84568: IFFALSE 84578
// sRefresh := true ;
84570: LD_ADDR_EXP 122
84574: PUSH
84575: LD_INT 1
84577: ST_TO_ADDR
// if p3 = 12 then
84578: LD_VAR 0 3
84582: PUSH
84583: LD_INT 12
84585: EQUAL
84586: IFFALSE 84596
// sExp := true ;
84588: LD_ADDR_EXP 123
84592: PUSH
84593: LD_INT 1
84595: ST_TO_ADDR
// if p3 = 13 then
84596: LD_VAR 0 3
84600: PUSH
84601: LD_INT 13
84603: EQUAL
84604: IFFALSE 84614
// sDepot := true ;
84606: LD_ADDR_EXP 124
84610: PUSH
84611: LD_INT 1
84613: ST_TO_ADDR
// if p3 = 14 then
84614: LD_VAR 0 3
84618: PUSH
84619: LD_INT 14
84621: EQUAL
84622: IFFALSE 84632
// sFlag := true ;
84624: LD_ADDR_EXP 125
84628: PUSH
84629: LD_INT 1
84631: ST_TO_ADDR
// if p3 = 15 then
84632: LD_VAR 0 3
84636: PUSH
84637: LD_INT 15
84639: EQUAL
84640: IFFALSE 84650
// sKamikadze := true ;
84642: LD_ADDR_EXP 133
84646: PUSH
84647: LD_INT 1
84649: ST_TO_ADDR
// if p3 = 16 then
84650: LD_VAR 0 3
84654: PUSH
84655: LD_INT 16
84657: EQUAL
84658: IFFALSE 84668
// sTroll := true ;
84660: LD_ADDR_EXP 134
84664: PUSH
84665: LD_INT 1
84667: ST_TO_ADDR
// if p3 = 17 then
84668: LD_VAR 0 3
84672: PUSH
84673: LD_INT 17
84675: EQUAL
84676: IFFALSE 84686
// sSlow := true ;
84678: LD_ADDR_EXP 135
84682: PUSH
84683: LD_INT 1
84685: ST_TO_ADDR
// if p3 = 18 then
84686: LD_VAR 0 3
84690: PUSH
84691: LD_INT 18
84693: EQUAL
84694: IFFALSE 84704
// sLack := true ;
84696: LD_ADDR_EXP 136
84700: PUSH
84701: LD_INT 1
84703: ST_TO_ADDR
// if p3 = 19 then
84704: LD_VAR 0 3
84708: PUSH
84709: LD_INT 19
84711: EQUAL
84712: IFFALSE 84722
// sTank := true ;
84714: LD_ADDR_EXP 138
84718: PUSH
84719: LD_INT 1
84721: ST_TO_ADDR
// if p3 = 20 then
84722: LD_VAR 0 3
84726: PUSH
84727: LD_INT 20
84729: EQUAL
84730: IFFALSE 84740
// sRemote := true ;
84732: LD_ADDR_EXP 139
84736: PUSH
84737: LD_INT 1
84739: ST_TO_ADDR
// if p3 = 21 then
84740: LD_VAR 0 3
84744: PUSH
84745: LD_INT 21
84747: EQUAL
84748: IFFALSE 84758
// sPowell := true ;
84750: LD_ADDR_EXP 140
84754: PUSH
84755: LD_INT 1
84757: ST_TO_ADDR
// if p3 = 22 then
84758: LD_VAR 0 3
84762: PUSH
84763: LD_INT 22
84765: EQUAL
84766: IFFALSE 84776
// sTeleport := true ;
84768: LD_ADDR_EXP 143
84772: PUSH
84773: LD_INT 1
84775: ST_TO_ADDR
// if p3 = 23 then
84776: LD_VAR 0 3
84780: PUSH
84781: LD_INT 23
84783: EQUAL
84784: IFFALSE 84794
// sOilTower := true ;
84786: LD_ADDR_EXP 145
84790: PUSH
84791: LD_INT 1
84793: ST_TO_ADDR
// if p3 = 24 then
84794: LD_VAR 0 3
84798: PUSH
84799: LD_INT 24
84801: EQUAL
84802: IFFALSE 84812
// sShovel := true ;
84804: LD_ADDR_EXP 146
84808: PUSH
84809: LD_INT 1
84811: ST_TO_ADDR
// if p3 = 25 then
84812: LD_VAR 0 3
84816: PUSH
84817: LD_INT 25
84819: EQUAL
84820: IFFALSE 84830
// sSheik := true ;
84822: LD_ADDR_EXP 147
84826: PUSH
84827: LD_INT 1
84829: ST_TO_ADDR
// if p3 = 26 then
84830: LD_VAR 0 3
84834: PUSH
84835: LD_INT 26
84837: EQUAL
84838: IFFALSE 84848
// sEarthquake := true ;
84840: LD_ADDR_EXP 149
84844: PUSH
84845: LD_INT 1
84847: ST_TO_ADDR
// if p3 = 27 then
84848: LD_VAR 0 3
84852: PUSH
84853: LD_INT 27
84855: EQUAL
84856: IFFALSE 84866
// sAI := true ;
84858: LD_ADDR_EXP 150
84862: PUSH
84863: LD_INT 1
84865: ST_TO_ADDR
// if p3 = 28 then
84866: LD_VAR 0 3
84870: PUSH
84871: LD_INT 28
84873: EQUAL
84874: IFFALSE 84884
// sCargo := true ;
84876: LD_ADDR_EXP 153
84880: PUSH
84881: LD_INT 1
84883: ST_TO_ADDR
// if p3 = 29 then
84884: LD_VAR 0 3
84888: PUSH
84889: LD_INT 29
84891: EQUAL
84892: IFFALSE 84902
// sDLaser := true ;
84894: LD_ADDR_EXP 154
84898: PUSH
84899: LD_INT 1
84901: ST_TO_ADDR
// if p3 = 30 then
84902: LD_VAR 0 3
84906: PUSH
84907: LD_INT 30
84909: EQUAL
84910: IFFALSE 84920
// sExchange := true ;
84912: LD_ADDR_EXP 155
84916: PUSH
84917: LD_INT 1
84919: ST_TO_ADDR
// if p3 = 31 then
84920: LD_VAR 0 3
84924: PUSH
84925: LD_INT 31
84927: EQUAL
84928: IFFALSE 84938
// sFac := true ;
84930: LD_ADDR_EXP 156
84934: PUSH
84935: LD_INT 1
84937: ST_TO_ADDR
// if p3 = 32 then
84938: LD_VAR 0 3
84942: PUSH
84943: LD_INT 32
84945: EQUAL
84946: IFFALSE 84956
// sPower := true ;
84948: LD_ADDR_EXP 157
84952: PUSH
84953: LD_INT 1
84955: ST_TO_ADDR
// if p3 = 33 then
84956: LD_VAR 0 3
84960: PUSH
84961: LD_INT 33
84963: EQUAL
84964: IFFALSE 84974
// sRandom := true ;
84966: LD_ADDR_EXP 158
84970: PUSH
84971: LD_INT 1
84973: ST_TO_ADDR
// if p3 = 34 then
84974: LD_VAR 0 3
84978: PUSH
84979: LD_INT 34
84981: EQUAL
84982: IFFALSE 84992
// sShield := true ;
84984: LD_ADDR_EXP 159
84988: PUSH
84989: LD_INT 1
84991: ST_TO_ADDR
// if p3 = 35 then
84992: LD_VAR 0 3
84996: PUSH
84997: LD_INT 35
84999: EQUAL
85000: IFFALSE 85010
// sTime := true ;
85002: LD_ADDR_EXP 160
85006: PUSH
85007: LD_INT 1
85009: ST_TO_ADDR
// if p3 = 36 then
85010: LD_VAR 0 3
85014: PUSH
85015: LD_INT 36
85017: EQUAL
85018: IFFALSE 85028
// sTools := true ;
85020: LD_ADDR_EXP 161
85024: PUSH
85025: LD_INT 1
85027: ST_TO_ADDR
// if p3 = 101 then
85028: LD_VAR 0 3
85032: PUSH
85033: LD_INT 101
85035: EQUAL
85036: IFFALSE 85046
// sSold := true ;
85038: LD_ADDR_EXP 126
85042: PUSH
85043: LD_INT 1
85045: ST_TO_ADDR
// if p3 = 102 then
85046: LD_VAR 0 3
85050: PUSH
85051: LD_INT 102
85053: EQUAL
85054: IFFALSE 85064
// sDiff := true ;
85056: LD_ADDR_EXP 127
85060: PUSH
85061: LD_INT 1
85063: ST_TO_ADDR
// if p3 = 103 then
85064: LD_VAR 0 3
85068: PUSH
85069: LD_INT 103
85071: EQUAL
85072: IFFALSE 85082
// sFog := true ;
85074: LD_ADDR_EXP 130
85078: PUSH
85079: LD_INT 1
85081: ST_TO_ADDR
// if p3 = 104 then
85082: LD_VAR 0 3
85086: PUSH
85087: LD_INT 104
85089: EQUAL
85090: IFFALSE 85100
// sReset := true ;
85092: LD_ADDR_EXP 131
85096: PUSH
85097: LD_INT 1
85099: ST_TO_ADDR
// if p3 = 105 then
85100: LD_VAR 0 3
85104: PUSH
85105: LD_INT 105
85107: EQUAL
85108: IFFALSE 85118
// sSun := true ;
85110: LD_ADDR_EXP 132
85114: PUSH
85115: LD_INT 1
85117: ST_TO_ADDR
// if p3 = 106 then
85118: LD_VAR 0 3
85122: PUSH
85123: LD_INT 106
85125: EQUAL
85126: IFFALSE 85136
// sTiger := true ;
85128: LD_ADDR_EXP 128
85132: PUSH
85133: LD_INT 1
85135: ST_TO_ADDR
// if p3 = 107 then
85136: LD_VAR 0 3
85140: PUSH
85141: LD_INT 107
85143: EQUAL
85144: IFFALSE 85154
// sBomb := true ;
85146: LD_ADDR_EXP 129
85150: PUSH
85151: LD_INT 1
85153: ST_TO_ADDR
// if p3 = 108 then
85154: LD_VAR 0 3
85158: PUSH
85159: LD_INT 108
85161: EQUAL
85162: IFFALSE 85172
// sWound := true ;
85164: LD_ADDR_EXP 137
85168: PUSH
85169: LD_INT 1
85171: ST_TO_ADDR
// if p3 = 109 then
85172: LD_VAR 0 3
85176: PUSH
85177: LD_INT 109
85179: EQUAL
85180: IFFALSE 85190
// sBetray := true ;
85182: LD_ADDR_EXP 141
85186: PUSH
85187: LD_INT 1
85189: ST_TO_ADDR
// if p3 = 110 then
85190: LD_VAR 0 3
85194: PUSH
85195: LD_INT 110
85197: EQUAL
85198: IFFALSE 85208
// sContamin := true ;
85200: LD_ADDR_EXP 142
85204: PUSH
85205: LD_INT 1
85207: ST_TO_ADDR
// if p3 = 111 then
85208: LD_VAR 0 3
85212: PUSH
85213: LD_INT 111
85215: EQUAL
85216: IFFALSE 85226
// sOil := true ;
85218: LD_ADDR_EXP 144
85222: PUSH
85223: LD_INT 1
85225: ST_TO_ADDR
// if p3 = 112 then
85226: LD_VAR 0 3
85230: PUSH
85231: LD_INT 112
85233: EQUAL
85234: IFFALSE 85244
// sStu := true ;
85236: LD_ADDR_EXP 148
85240: PUSH
85241: LD_INT 1
85243: ST_TO_ADDR
// if p3 = 113 then
85244: LD_VAR 0 3
85248: PUSH
85249: LD_INT 113
85251: EQUAL
85252: IFFALSE 85262
// sBazooka := true ;
85254: LD_ADDR_EXP 151
85258: PUSH
85259: LD_INT 1
85261: ST_TO_ADDR
// if p3 = 114 then
85262: LD_VAR 0 3
85266: PUSH
85267: LD_INT 114
85269: EQUAL
85270: IFFALSE 85280
// sMortar := true ;
85272: LD_ADDR_EXP 152
85276: PUSH
85277: LD_INT 1
85279: ST_TO_ADDR
// if p3 = 115 then
85280: LD_VAR 0 3
85284: PUSH
85285: LD_INT 115
85287: EQUAL
85288: IFFALSE 85298
// sRanger := true ;
85290: LD_ADDR_EXP 162
85294: PUSH
85295: LD_INT 1
85297: ST_TO_ADDR
// end ; if p2 = 101 then
85298: LD_VAR 0 2
85302: PUSH
85303: LD_INT 101
85305: EQUAL
85306: IFFALSE 85434
// begin case p3 of 1 :
85308: LD_VAR 0 3
85312: PUSH
85313: LD_INT 1
85315: DOUBLE
85316: EQUAL
85317: IFTRUE 85321
85319: GO 85328
85321: POP
// hHackUnlimitedResources ; 2 :
85322: CALL 96469 0 0
85326: GO 85434
85328: LD_INT 2
85330: DOUBLE
85331: EQUAL
85332: IFTRUE 85336
85334: GO 85343
85336: POP
// hHackSetLevel10 ; 3 :
85337: CALL 96602 0 0
85341: GO 85434
85343: LD_INT 3
85345: DOUBLE
85346: EQUAL
85347: IFTRUE 85351
85349: GO 85358
85351: POP
// hHackSetLevel10YourUnits ; 4 :
85352: CALL 96687 0 0
85356: GO 85434
85358: LD_INT 4
85360: DOUBLE
85361: EQUAL
85362: IFTRUE 85366
85364: GO 85373
85366: POP
// hHackInvincible ; 5 :
85367: CALL 97135 0 0
85371: GO 85434
85373: LD_INT 5
85375: DOUBLE
85376: EQUAL
85377: IFTRUE 85381
85379: GO 85388
85381: POP
// hHackInvisible ; 6 :
85382: CALL 97246 0 0
85386: GO 85434
85388: LD_INT 6
85390: DOUBLE
85391: EQUAL
85392: IFTRUE 85396
85394: GO 85403
85396: POP
// hHackChangeYourSide ; 7 :
85397: CALL 97303 0 0
85401: GO 85434
85403: LD_INT 7
85405: DOUBLE
85406: EQUAL
85407: IFTRUE 85411
85409: GO 85418
85411: POP
// hHackChangeUnitSide ; 8 :
85412: CALL 97345 0 0
85416: GO 85434
85418: LD_INT 8
85420: DOUBLE
85421: EQUAL
85422: IFTRUE 85426
85424: GO 85433
85426: POP
// hHackFog ; end ;
85427: CALL 97446 0 0
85431: GO 85434
85433: POP
// end ; end ;
85434: PPOPN 6
85436: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
85437: GO 85439
85439: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
85440: LD_STRING initStreamRollete();
85442: PPUSH
85443: CALL_OW 559
// InitStreamMode ;
85447: CALL 85456 0 0
// DefineStreamItems ( ) ;
85451: CALL 85896 0 0
// end ;
85455: END
// function InitStreamMode ; begin
85456: LD_INT 0
85458: PPUSH
// streamModeActive := false ;
85459: LD_ADDR_EXP 109
85463: PUSH
85464: LD_INT 0
85466: ST_TO_ADDR
// normalCounter := 36 ;
85467: LD_ADDR_EXP 110
85471: PUSH
85472: LD_INT 36
85474: ST_TO_ADDR
// hardcoreCounter := 16 ;
85475: LD_ADDR_EXP 111
85479: PUSH
85480: LD_INT 16
85482: ST_TO_ADDR
// sRocket := false ;
85483: LD_ADDR_EXP 114
85487: PUSH
85488: LD_INT 0
85490: ST_TO_ADDR
// sSpeed := false ;
85491: LD_ADDR_EXP 113
85495: PUSH
85496: LD_INT 0
85498: ST_TO_ADDR
// sEngine := false ;
85499: LD_ADDR_EXP 115
85503: PUSH
85504: LD_INT 0
85506: ST_TO_ADDR
// sSpec := false ;
85507: LD_ADDR_EXP 112
85511: PUSH
85512: LD_INT 0
85514: ST_TO_ADDR
// sLevel := false ;
85515: LD_ADDR_EXP 116
85519: PUSH
85520: LD_INT 0
85522: ST_TO_ADDR
// sArmoury := false ;
85523: LD_ADDR_EXP 117
85527: PUSH
85528: LD_INT 0
85530: ST_TO_ADDR
// sRadar := false ;
85531: LD_ADDR_EXP 118
85535: PUSH
85536: LD_INT 0
85538: ST_TO_ADDR
// sBunker := false ;
85539: LD_ADDR_EXP 119
85543: PUSH
85544: LD_INT 0
85546: ST_TO_ADDR
// sHack := false ;
85547: LD_ADDR_EXP 120
85551: PUSH
85552: LD_INT 0
85554: ST_TO_ADDR
// sFire := false ;
85555: LD_ADDR_EXP 121
85559: PUSH
85560: LD_INT 0
85562: ST_TO_ADDR
// sRefresh := false ;
85563: LD_ADDR_EXP 122
85567: PUSH
85568: LD_INT 0
85570: ST_TO_ADDR
// sExp := false ;
85571: LD_ADDR_EXP 123
85575: PUSH
85576: LD_INT 0
85578: ST_TO_ADDR
// sDepot := false ;
85579: LD_ADDR_EXP 124
85583: PUSH
85584: LD_INT 0
85586: ST_TO_ADDR
// sFlag := false ;
85587: LD_ADDR_EXP 125
85591: PUSH
85592: LD_INT 0
85594: ST_TO_ADDR
// sKamikadze := false ;
85595: LD_ADDR_EXP 133
85599: PUSH
85600: LD_INT 0
85602: ST_TO_ADDR
// sTroll := false ;
85603: LD_ADDR_EXP 134
85607: PUSH
85608: LD_INT 0
85610: ST_TO_ADDR
// sSlow := false ;
85611: LD_ADDR_EXP 135
85615: PUSH
85616: LD_INT 0
85618: ST_TO_ADDR
// sLack := false ;
85619: LD_ADDR_EXP 136
85623: PUSH
85624: LD_INT 0
85626: ST_TO_ADDR
// sTank := false ;
85627: LD_ADDR_EXP 138
85631: PUSH
85632: LD_INT 0
85634: ST_TO_ADDR
// sRemote := false ;
85635: LD_ADDR_EXP 139
85639: PUSH
85640: LD_INT 0
85642: ST_TO_ADDR
// sPowell := false ;
85643: LD_ADDR_EXP 140
85647: PUSH
85648: LD_INT 0
85650: ST_TO_ADDR
// sTeleport := false ;
85651: LD_ADDR_EXP 143
85655: PUSH
85656: LD_INT 0
85658: ST_TO_ADDR
// sOilTower := false ;
85659: LD_ADDR_EXP 145
85663: PUSH
85664: LD_INT 0
85666: ST_TO_ADDR
// sShovel := false ;
85667: LD_ADDR_EXP 146
85671: PUSH
85672: LD_INT 0
85674: ST_TO_ADDR
// sSheik := false ;
85675: LD_ADDR_EXP 147
85679: PUSH
85680: LD_INT 0
85682: ST_TO_ADDR
// sEarthquake := false ;
85683: LD_ADDR_EXP 149
85687: PUSH
85688: LD_INT 0
85690: ST_TO_ADDR
// sAI := false ;
85691: LD_ADDR_EXP 150
85695: PUSH
85696: LD_INT 0
85698: ST_TO_ADDR
// sCargo := false ;
85699: LD_ADDR_EXP 153
85703: PUSH
85704: LD_INT 0
85706: ST_TO_ADDR
// sDLaser := false ;
85707: LD_ADDR_EXP 154
85711: PUSH
85712: LD_INT 0
85714: ST_TO_ADDR
// sExchange := false ;
85715: LD_ADDR_EXP 155
85719: PUSH
85720: LD_INT 0
85722: ST_TO_ADDR
// sFac := false ;
85723: LD_ADDR_EXP 156
85727: PUSH
85728: LD_INT 0
85730: ST_TO_ADDR
// sPower := false ;
85731: LD_ADDR_EXP 157
85735: PUSH
85736: LD_INT 0
85738: ST_TO_ADDR
// sRandom := false ;
85739: LD_ADDR_EXP 158
85743: PUSH
85744: LD_INT 0
85746: ST_TO_ADDR
// sShield := false ;
85747: LD_ADDR_EXP 159
85751: PUSH
85752: LD_INT 0
85754: ST_TO_ADDR
// sTime := false ;
85755: LD_ADDR_EXP 160
85759: PUSH
85760: LD_INT 0
85762: ST_TO_ADDR
// sTools := false ;
85763: LD_ADDR_EXP 161
85767: PUSH
85768: LD_INT 0
85770: ST_TO_ADDR
// sSold := false ;
85771: LD_ADDR_EXP 126
85775: PUSH
85776: LD_INT 0
85778: ST_TO_ADDR
// sDiff := false ;
85779: LD_ADDR_EXP 127
85783: PUSH
85784: LD_INT 0
85786: ST_TO_ADDR
// sFog := false ;
85787: LD_ADDR_EXP 130
85791: PUSH
85792: LD_INT 0
85794: ST_TO_ADDR
// sReset := false ;
85795: LD_ADDR_EXP 131
85799: PUSH
85800: LD_INT 0
85802: ST_TO_ADDR
// sSun := false ;
85803: LD_ADDR_EXP 132
85807: PUSH
85808: LD_INT 0
85810: ST_TO_ADDR
// sTiger := false ;
85811: LD_ADDR_EXP 128
85815: PUSH
85816: LD_INT 0
85818: ST_TO_ADDR
// sBomb := false ;
85819: LD_ADDR_EXP 129
85823: PUSH
85824: LD_INT 0
85826: ST_TO_ADDR
// sWound := false ;
85827: LD_ADDR_EXP 137
85831: PUSH
85832: LD_INT 0
85834: ST_TO_ADDR
// sBetray := false ;
85835: LD_ADDR_EXP 141
85839: PUSH
85840: LD_INT 0
85842: ST_TO_ADDR
// sContamin := false ;
85843: LD_ADDR_EXP 142
85847: PUSH
85848: LD_INT 0
85850: ST_TO_ADDR
// sOil := false ;
85851: LD_ADDR_EXP 144
85855: PUSH
85856: LD_INT 0
85858: ST_TO_ADDR
// sStu := false ;
85859: LD_ADDR_EXP 148
85863: PUSH
85864: LD_INT 0
85866: ST_TO_ADDR
// sBazooka := false ;
85867: LD_ADDR_EXP 151
85871: PUSH
85872: LD_INT 0
85874: ST_TO_ADDR
// sMortar := false ;
85875: LD_ADDR_EXP 152
85879: PUSH
85880: LD_INT 0
85882: ST_TO_ADDR
// sRanger := false ;
85883: LD_ADDR_EXP 162
85887: PUSH
85888: LD_INT 0
85890: ST_TO_ADDR
// end ;
85891: LD_VAR 0 1
85895: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
85896: LD_INT 0
85898: PPUSH
85899: PPUSH
85900: PPUSH
85901: PPUSH
85902: PPUSH
// result := [ ] ;
85903: LD_ADDR_VAR 0 1
85907: PUSH
85908: EMPTY
85909: ST_TO_ADDR
// if campaign_id = 1 then
85910: LD_OWVAR 69
85914: PUSH
85915: LD_INT 1
85917: EQUAL
85918: IFFALSE 88856
// begin case mission_number of 1 :
85920: LD_OWVAR 70
85924: PUSH
85925: LD_INT 1
85927: DOUBLE
85928: EQUAL
85929: IFTRUE 85933
85931: GO 85997
85933: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
85934: LD_ADDR_VAR 0 1
85938: PUSH
85939: LD_INT 2
85941: PUSH
85942: LD_INT 4
85944: PUSH
85945: LD_INT 11
85947: PUSH
85948: LD_INT 12
85950: PUSH
85951: LD_INT 15
85953: PUSH
85954: LD_INT 16
85956: PUSH
85957: LD_INT 22
85959: PUSH
85960: LD_INT 23
85962: PUSH
85963: LD_INT 26
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: LIST
85975: LIST
85976: PUSH
85977: LD_INT 101
85979: PUSH
85980: LD_INT 102
85982: PUSH
85983: LD_INT 106
85985: PUSH
85986: EMPTY
85987: LIST
85988: LIST
85989: LIST
85990: PUSH
85991: EMPTY
85992: LIST
85993: LIST
85994: ST_TO_ADDR
85995: GO 88854
85997: LD_INT 2
85999: DOUBLE
86000: EQUAL
86001: IFTRUE 86005
86003: GO 86077
86005: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
86006: LD_ADDR_VAR 0 1
86010: PUSH
86011: LD_INT 2
86013: PUSH
86014: LD_INT 4
86016: PUSH
86017: LD_INT 11
86019: PUSH
86020: LD_INT 12
86022: PUSH
86023: LD_INT 15
86025: PUSH
86026: LD_INT 16
86028: PUSH
86029: LD_INT 22
86031: PUSH
86032: LD_INT 23
86034: PUSH
86035: LD_INT 26
86037: PUSH
86038: EMPTY
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: LIST
86046: LIST
86047: LIST
86048: PUSH
86049: LD_INT 101
86051: PUSH
86052: LD_INT 102
86054: PUSH
86055: LD_INT 105
86057: PUSH
86058: LD_INT 106
86060: PUSH
86061: LD_INT 108
86063: PUSH
86064: EMPTY
86065: LIST
86066: LIST
86067: LIST
86068: LIST
86069: LIST
86070: PUSH
86071: EMPTY
86072: LIST
86073: LIST
86074: ST_TO_ADDR
86075: GO 88854
86077: LD_INT 3
86079: DOUBLE
86080: EQUAL
86081: IFTRUE 86085
86083: GO 86161
86085: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
86086: LD_ADDR_VAR 0 1
86090: PUSH
86091: LD_INT 2
86093: PUSH
86094: LD_INT 4
86096: PUSH
86097: LD_INT 5
86099: PUSH
86100: LD_INT 11
86102: PUSH
86103: LD_INT 12
86105: PUSH
86106: LD_INT 15
86108: PUSH
86109: LD_INT 16
86111: PUSH
86112: LD_INT 22
86114: PUSH
86115: LD_INT 26
86117: PUSH
86118: LD_INT 36
86120: PUSH
86121: EMPTY
86122: LIST
86123: LIST
86124: LIST
86125: LIST
86126: LIST
86127: LIST
86128: LIST
86129: LIST
86130: LIST
86131: LIST
86132: PUSH
86133: LD_INT 101
86135: PUSH
86136: LD_INT 102
86138: PUSH
86139: LD_INT 105
86141: PUSH
86142: LD_INT 106
86144: PUSH
86145: LD_INT 108
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: LIST
86152: LIST
86153: LIST
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: ST_TO_ADDR
86159: GO 88854
86161: LD_INT 4
86163: DOUBLE
86164: EQUAL
86165: IFTRUE 86169
86167: GO 86253
86169: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
86170: LD_ADDR_VAR 0 1
86174: PUSH
86175: LD_INT 2
86177: PUSH
86178: LD_INT 4
86180: PUSH
86181: LD_INT 5
86183: PUSH
86184: LD_INT 8
86186: PUSH
86187: LD_INT 11
86189: PUSH
86190: LD_INT 12
86192: PUSH
86193: LD_INT 15
86195: PUSH
86196: LD_INT 16
86198: PUSH
86199: LD_INT 22
86201: PUSH
86202: LD_INT 23
86204: PUSH
86205: LD_INT 26
86207: PUSH
86208: LD_INT 36
86210: PUSH
86211: EMPTY
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: LIST
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: LIST
86224: PUSH
86225: LD_INT 101
86227: PUSH
86228: LD_INT 102
86230: PUSH
86231: LD_INT 105
86233: PUSH
86234: LD_INT 106
86236: PUSH
86237: LD_INT 108
86239: PUSH
86240: EMPTY
86241: LIST
86242: LIST
86243: LIST
86244: LIST
86245: LIST
86246: PUSH
86247: EMPTY
86248: LIST
86249: LIST
86250: ST_TO_ADDR
86251: GO 88854
86253: LD_INT 5
86255: DOUBLE
86256: EQUAL
86257: IFTRUE 86261
86259: GO 86361
86261: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
86262: LD_ADDR_VAR 0 1
86266: PUSH
86267: LD_INT 2
86269: PUSH
86270: LD_INT 4
86272: PUSH
86273: LD_INT 5
86275: PUSH
86276: LD_INT 6
86278: PUSH
86279: LD_INT 8
86281: PUSH
86282: LD_INT 11
86284: PUSH
86285: LD_INT 12
86287: PUSH
86288: LD_INT 15
86290: PUSH
86291: LD_INT 16
86293: PUSH
86294: LD_INT 22
86296: PUSH
86297: LD_INT 23
86299: PUSH
86300: LD_INT 25
86302: PUSH
86303: LD_INT 26
86305: PUSH
86306: LD_INT 36
86308: PUSH
86309: EMPTY
86310: LIST
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: PUSH
86325: LD_INT 101
86327: PUSH
86328: LD_INT 102
86330: PUSH
86331: LD_INT 105
86333: PUSH
86334: LD_INT 106
86336: PUSH
86337: LD_INT 108
86339: PUSH
86340: LD_INT 109
86342: PUSH
86343: LD_INT 112
86345: PUSH
86346: EMPTY
86347: LIST
86348: LIST
86349: LIST
86350: LIST
86351: LIST
86352: LIST
86353: LIST
86354: PUSH
86355: EMPTY
86356: LIST
86357: LIST
86358: ST_TO_ADDR
86359: GO 88854
86361: LD_INT 6
86363: DOUBLE
86364: EQUAL
86365: IFTRUE 86369
86367: GO 86489
86369: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
86370: LD_ADDR_VAR 0 1
86374: PUSH
86375: LD_INT 2
86377: PUSH
86378: LD_INT 4
86380: PUSH
86381: LD_INT 5
86383: PUSH
86384: LD_INT 6
86386: PUSH
86387: LD_INT 8
86389: PUSH
86390: LD_INT 11
86392: PUSH
86393: LD_INT 12
86395: PUSH
86396: LD_INT 15
86398: PUSH
86399: LD_INT 16
86401: PUSH
86402: LD_INT 20
86404: PUSH
86405: LD_INT 21
86407: PUSH
86408: LD_INT 22
86410: PUSH
86411: LD_INT 23
86413: PUSH
86414: LD_INT 25
86416: PUSH
86417: LD_INT 26
86419: PUSH
86420: LD_INT 30
86422: PUSH
86423: LD_INT 31
86425: PUSH
86426: LD_INT 32
86428: PUSH
86429: LD_INT 36
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: LIST
86449: LIST
86450: LIST
86451: LIST
86452: PUSH
86453: LD_INT 101
86455: PUSH
86456: LD_INT 102
86458: PUSH
86459: LD_INT 105
86461: PUSH
86462: LD_INT 106
86464: PUSH
86465: LD_INT 108
86467: PUSH
86468: LD_INT 109
86470: PUSH
86471: LD_INT 112
86473: PUSH
86474: EMPTY
86475: LIST
86476: LIST
86477: LIST
86478: LIST
86479: LIST
86480: LIST
86481: LIST
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: ST_TO_ADDR
86487: GO 88854
86489: LD_INT 7
86491: DOUBLE
86492: EQUAL
86493: IFTRUE 86497
86495: GO 86597
86497: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
86498: LD_ADDR_VAR 0 1
86502: PUSH
86503: LD_INT 2
86505: PUSH
86506: LD_INT 4
86508: PUSH
86509: LD_INT 5
86511: PUSH
86512: LD_INT 7
86514: PUSH
86515: LD_INT 11
86517: PUSH
86518: LD_INT 12
86520: PUSH
86521: LD_INT 15
86523: PUSH
86524: LD_INT 16
86526: PUSH
86527: LD_INT 20
86529: PUSH
86530: LD_INT 21
86532: PUSH
86533: LD_INT 22
86535: PUSH
86536: LD_INT 23
86538: PUSH
86539: LD_INT 25
86541: PUSH
86542: LD_INT 26
86544: PUSH
86545: EMPTY
86546: LIST
86547: LIST
86548: LIST
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: LIST
86554: LIST
86555: LIST
86556: LIST
86557: LIST
86558: LIST
86559: LIST
86560: PUSH
86561: LD_INT 101
86563: PUSH
86564: LD_INT 102
86566: PUSH
86567: LD_INT 103
86569: PUSH
86570: LD_INT 105
86572: PUSH
86573: LD_INT 106
86575: PUSH
86576: LD_INT 108
86578: PUSH
86579: LD_INT 112
86581: PUSH
86582: EMPTY
86583: LIST
86584: LIST
86585: LIST
86586: LIST
86587: LIST
86588: LIST
86589: LIST
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: ST_TO_ADDR
86595: GO 88854
86597: LD_INT 8
86599: DOUBLE
86600: EQUAL
86601: IFTRUE 86605
86603: GO 86733
86605: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
86606: LD_ADDR_VAR 0 1
86610: PUSH
86611: LD_INT 2
86613: PUSH
86614: LD_INT 4
86616: PUSH
86617: LD_INT 5
86619: PUSH
86620: LD_INT 6
86622: PUSH
86623: LD_INT 7
86625: PUSH
86626: LD_INT 8
86628: PUSH
86629: LD_INT 11
86631: PUSH
86632: LD_INT 12
86634: PUSH
86635: LD_INT 15
86637: PUSH
86638: LD_INT 16
86640: PUSH
86641: LD_INT 20
86643: PUSH
86644: LD_INT 21
86646: PUSH
86647: LD_INT 22
86649: PUSH
86650: LD_INT 23
86652: PUSH
86653: LD_INT 25
86655: PUSH
86656: LD_INT 26
86658: PUSH
86659: LD_INT 30
86661: PUSH
86662: LD_INT 31
86664: PUSH
86665: LD_INT 32
86667: PUSH
86668: LD_INT 36
86670: PUSH
86671: EMPTY
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: PUSH
86693: LD_INT 101
86695: PUSH
86696: LD_INT 102
86698: PUSH
86699: LD_INT 103
86701: PUSH
86702: LD_INT 105
86704: PUSH
86705: LD_INT 106
86707: PUSH
86708: LD_INT 108
86710: PUSH
86711: LD_INT 109
86713: PUSH
86714: LD_INT 112
86716: PUSH
86717: EMPTY
86718: LIST
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: PUSH
86727: EMPTY
86728: LIST
86729: LIST
86730: ST_TO_ADDR
86731: GO 88854
86733: LD_INT 9
86735: DOUBLE
86736: EQUAL
86737: IFTRUE 86741
86739: GO 86877
86741: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
86742: LD_ADDR_VAR 0 1
86746: PUSH
86747: LD_INT 2
86749: PUSH
86750: LD_INT 4
86752: PUSH
86753: LD_INT 5
86755: PUSH
86756: LD_INT 6
86758: PUSH
86759: LD_INT 7
86761: PUSH
86762: LD_INT 8
86764: PUSH
86765: LD_INT 11
86767: PUSH
86768: LD_INT 12
86770: PUSH
86771: LD_INT 15
86773: PUSH
86774: LD_INT 16
86776: PUSH
86777: LD_INT 20
86779: PUSH
86780: LD_INT 21
86782: PUSH
86783: LD_INT 22
86785: PUSH
86786: LD_INT 23
86788: PUSH
86789: LD_INT 25
86791: PUSH
86792: LD_INT 26
86794: PUSH
86795: LD_INT 28
86797: PUSH
86798: LD_INT 30
86800: PUSH
86801: LD_INT 31
86803: PUSH
86804: LD_INT 32
86806: PUSH
86807: LD_INT 36
86809: PUSH
86810: EMPTY
86811: LIST
86812: LIST
86813: LIST
86814: LIST
86815: LIST
86816: LIST
86817: LIST
86818: LIST
86819: LIST
86820: LIST
86821: LIST
86822: LIST
86823: LIST
86824: LIST
86825: LIST
86826: LIST
86827: LIST
86828: LIST
86829: LIST
86830: LIST
86831: LIST
86832: PUSH
86833: LD_INT 101
86835: PUSH
86836: LD_INT 102
86838: PUSH
86839: LD_INT 103
86841: PUSH
86842: LD_INT 105
86844: PUSH
86845: LD_INT 106
86847: PUSH
86848: LD_INT 108
86850: PUSH
86851: LD_INT 109
86853: PUSH
86854: LD_INT 112
86856: PUSH
86857: LD_INT 114
86859: PUSH
86860: EMPTY
86861: LIST
86862: LIST
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: LIST
86869: LIST
86870: PUSH
86871: EMPTY
86872: LIST
86873: LIST
86874: ST_TO_ADDR
86875: GO 88854
86877: LD_INT 10
86879: DOUBLE
86880: EQUAL
86881: IFTRUE 86885
86883: GO 87069
86885: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
86886: LD_ADDR_VAR 0 1
86890: PUSH
86891: LD_INT 2
86893: PUSH
86894: LD_INT 4
86896: PUSH
86897: LD_INT 5
86899: PUSH
86900: LD_INT 6
86902: PUSH
86903: LD_INT 7
86905: PUSH
86906: LD_INT 8
86908: PUSH
86909: LD_INT 9
86911: PUSH
86912: LD_INT 10
86914: PUSH
86915: LD_INT 11
86917: PUSH
86918: LD_INT 12
86920: PUSH
86921: LD_INT 13
86923: PUSH
86924: LD_INT 14
86926: PUSH
86927: LD_INT 15
86929: PUSH
86930: LD_INT 16
86932: PUSH
86933: LD_INT 17
86935: PUSH
86936: LD_INT 18
86938: PUSH
86939: LD_INT 19
86941: PUSH
86942: LD_INT 20
86944: PUSH
86945: LD_INT 21
86947: PUSH
86948: LD_INT 22
86950: PUSH
86951: LD_INT 23
86953: PUSH
86954: LD_INT 24
86956: PUSH
86957: LD_INT 25
86959: PUSH
86960: LD_INT 26
86962: PUSH
86963: LD_INT 28
86965: PUSH
86966: LD_INT 30
86968: PUSH
86969: LD_INT 31
86971: PUSH
86972: LD_INT 32
86974: PUSH
86975: LD_INT 36
86977: PUSH
86978: EMPTY
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: LIST
86987: LIST
86988: LIST
86989: LIST
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 101
87011: PUSH
87012: LD_INT 102
87014: PUSH
87015: LD_INT 103
87017: PUSH
87018: LD_INT 104
87020: PUSH
87021: LD_INT 105
87023: PUSH
87024: LD_INT 106
87026: PUSH
87027: LD_INT 107
87029: PUSH
87030: LD_INT 108
87032: PUSH
87033: LD_INT 109
87035: PUSH
87036: LD_INT 110
87038: PUSH
87039: LD_INT 111
87041: PUSH
87042: LD_INT 112
87044: PUSH
87045: LD_INT 114
87047: PUSH
87048: EMPTY
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: LIST
87059: LIST
87060: LIST
87061: LIST
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: ST_TO_ADDR
87067: GO 88854
87069: LD_INT 11
87071: DOUBLE
87072: EQUAL
87073: IFTRUE 87077
87075: GO 87269
87077: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
87078: LD_ADDR_VAR 0 1
87082: PUSH
87083: LD_INT 2
87085: PUSH
87086: LD_INT 3
87088: PUSH
87089: LD_INT 4
87091: PUSH
87092: LD_INT 5
87094: PUSH
87095: LD_INT 6
87097: PUSH
87098: LD_INT 7
87100: PUSH
87101: LD_INT 8
87103: PUSH
87104: LD_INT 9
87106: PUSH
87107: LD_INT 10
87109: PUSH
87110: LD_INT 11
87112: PUSH
87113: LD_INT 12
87115: PUSH
87116: LD_INT 13
87118: PUSH
87119: LD_INT 14
87121: PUSH
87122: LD_INT 15
87124: PUSH
87125: LD_INT 16
87127: PUSH
87128: LD_INT 17
87130: PUSH
87131: LD_INT 18
87133: PUSH
87134: LD_INT 19
87136: PUSH
87137: LD_INT 20
87139: PUSH
87140: LD_INT 21
87142: PUSH
87143: LD_INT 22
87145: PUSH
87146: LD_INT 23
87148: PUSH
87149: LD_INT 24
87151: PUSH
87152: LD_INT 25
87154: PUSH
87155: LD_INT 26
87157: PUSH
87158: LD_INT 28
87160: PUSH
87161: LD_INT 30
87163: PUSH
87164: LD_INT 31
87166: PUSH
87167: LD_INT 32
87169: PUSH
87170: LD_INT 34
87172: PUSH
87173: LD_INT 36
87175: PUSH
87176: EMPTY
87177: LIST
87178: LIST
87179: LIST
87180: LIST
87181: LIST
87182: LIST
87183: LIST
87184: LIST
87185: LIST
87186: LIST
87187: LIST
87188: LIST
87189: LIST
87190: LIST
87191: LIST
87192: LIST
87193: LIST
87194: LIST
87195: LIST
87196: LIST
87197: LIST
87198: LIST
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: LIST
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 101
87211: PUSH
87212: LD_INT 102
87214: PUSH
87215: LD_INT 103
87217: PUSH
87218: LD_INT 104
87220: PUSH
87221: LD_INT 105
87223: PUSH
87224: LD_INT 106
87226: PUSH
87227: LD_INT 107
87229: PUSH
87230: LD_INT 108
87232: PUSH
87233: LD_INT 109
87235: PUSH
87236: LD_INT 110
87238: PUSH
87239: LD_INT 111
87241: PUSH
87242: LD_INT 112
87244: PUSH
87245: LD_INT 114
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: PUSH
87263: EMPTY
87264: LIST
87265: LIST
87266: ST_TO_ADDR
87267: GO 88854
87269: LD_INT 12
87271: DOUBLE
87272: EQUAL
87273: IFTRUE 87277
87275: GO 87485
87277: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
87278: LD_ADDR_VAR 0 1
87282: PUSH
87283: LD_INT 1
87285: PUSH
87286: LD_INT 2
87288: PUSH
87289: LD_INT 3
87291: PUSH
87292: LD_INT 4
87294: PUSH
87295: LD_INT 5
87297: PUSH
87298: LD_INT 6
87300: PUSH
87301: LD_INT 7
87303: PUSH
87304: LD_INT 8
87306: PUSH
87307: LD_INT 9
87309: PUSH
87310: LD_INT 10
87312: PUSH
87313: LD_INT 11
87315: PUSH
87316: LD_INT 12
87318: PUSH
87319: LD_INT 13
87321: PUSH
87322: LD_INT 14
87324: PUSH
87325: LD_INT 15
87327: PUSH
87328: LD_INT 16
87330: PUSH
87331: LD_INT 17
87333: PUSH
87334: LD_INT 18
87336: PUSH
87337: LD_INT 19
87339: PUSH
87340: LD_INT 20
87342: PUSH
87343: LD_INT 21
87345: PUSH
87346: LD_INT 22
87348: PUSH
87349: LD_INT 23
87351: PUSH
87352: LD_INT 24
87354: PUSH
87355: LD_INT 25
87357: PUSH
87358: LD_INT 26
87360: PUSH
87361: LD_INT 27
87363: PUSH
87364: LD_INT 28
87366: PUSH
87367: LD_INT 30
87369: PUSH
87370: LD_INT 31
87372: PUSH
87373: LD_INT 32
87375: PUSH
87376: LD_INT 33
87378: PUSH
87379: LD_INT 34
87381: PUSH
87382: LD_INT 36
87384: PUSH
87385: EMPTY
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: LIST
87420: PUSH
87421: LD_INT 101
87423: PUSH
87424: LD_INT 102
87426: PUSH
87427: LD_INT 103
87429: PUSH
87430: LD_INT 104
87432: PUSH
87433: LD_INT 105
87435: PUSH
87436: LD_INT 106
87438: PUSH
87439: LD_INT 107
87441: PUSH
87442: LD_INT 108
87444: PUSH
87445: LD_INT 109
87447: PUSH
87448: LD_INT 110
87450: PUSH
87451: LD_INT 111
87453: PUSH
87454: LD_INT 112
87456: PUSH
87457: LD_INT 113
87459: PUSH
87460: LD_INT 114
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: LIST
87467: LIST
87468: LIST
87469: LIST
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: ST_TO_ADDR
87483: GO 88854
87485: LD_INT 13
87487: DOUBLE
87488: EQUAL
87489: IFTRUE 87493
87491: GO 87689
87493: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
87494: LD_ADDR_VAR 0 1
87498: PUSH
87499: LD_INT 1
87501: PUSH
87502: LD_INT 2
87504: PUSH
87505: LD_INT 3
87507: PUSH
87508: LD_INT 4
87510: PUSH
87511: LD_INT 5
87513: PUSH
87514: LD_INT 8
87516: PUSH
87517: LD_INT 9
87519: PUSH
87520: LD_INT 10
87522: PUSH
87523: LD_INT 11
87525: PUSH
87526: LD_INT 12
87528: PUSH
87529: LD_INT 14
87531: PUSH
87532: LD_INT 15
87534: PUSH
87535: LD_INT 16
87537: PUSH
87538: LD_INT 17
87540: PUSH
87541: LD_INT 18
87543: PUSH
87544: LD_INT 19
87546: PUSH
87547: LD_INT 20
87549: PUSH
87550: LD_INT 21
87552: PUSH
87553: LD_INT 22
87555: PUSH
87556: LD_INT 23
87558: PUSH
87559: LD_INT 24
87561: PUSH
87562: LD_INT 25
87564: PUSH
87565: LD_INT 26
87567: PUSH
87568: LD_INT 27
87570: PUSH
87571: LD_INT 28
87573: PUSH
87574: LD_INT 30
87576: PUSH
87577: LD_INT 31
87579: PUSH
87580: LD_INT 32
87582: PUSH
87583: LD_INT 33
87585: PUSH
87586: LD_INT 34
87588: PUSH
87589: LD_INT 36
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: LIST
87598: LIST
87599: LIST
87600: LIST
87601: LIST
87602: LIST
87603: LIST
87604: LIST
87605: LIST
87606: LIST
87607: LIST
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: LIST
87613: LIST
87614: LIST
87615: LIST
87616: LIST
87617: LIST
87618: LIST
87619: LIST
87620: LIST
87621: LIST
87622: LIST
87623: LIST
87624: PUSH
87625: LD_INT 101
87627: PUSH
87628: LD_INT 102
87630: PUSH
87631: LD_INT 103
87633: PUSH
87634: LD_INT 104
87636: PUSH
87637: LD_INT 105
87639: PUSH
87640: LD_INT 106
87642: PUSH
87643: LD_INT 107
87645: PUSH
87646: LD_INT 108
87648: PUSH
87649: LD_INT 109
87651: PUSH
87652: LD_INT 110
87654: PUSH
87655: LD_INT 111
87657: PUSH
87658: LD_INT 112
87660: PUSH
87661: LD_INT 113
87663: PUSH
87664: LD_INT 114
87666: PUSH
87667: EMPTY
87668: LIST
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: ST_TO_ADDR
87687: GO 88854
87689: LD_INT 14
87691: DOUBLE
87692: EQUAL
87693: IFTRUE 87697
87695: GO 87909
87697: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
87698: LD_ADDR_VAR 0 1
87702: PUSH
87703: LD_INT 1
87705: PUSH
87706: LD_INT 2
87708: PUSH
87709: LD_INT 3
87711: PUSH
87712: LD_INT 4
87714: PUSH
87715: LD_INT 5
87717: PUSH
87718: LD_INT 6
87720: PUSH
87721: LD_INT 7
87723: PUSH
87724: LD_INT 8
87726: PUSH
87727: LD_INT 9
87729: PUSH
87730: LD_INT 10
87732: PUSH
87733: LD_INT 11
87735: PUSH
87736: LD_INT 12
87738: PUSH
87739: LD_INT 13
87741: PUSH
87742: LD_INT 14
87744: PUSH
87745: LD_INT 15
87747: PUSH
87748: LD_INT 16
87750: PUSH
87751: LD_INT 17
87753: PUSH
87754: LD_INT 18
87756: PUSH
87757: LD_INT 19
87759: PUSH
87760: LD_INT 20
87762: PUSH
87763: LD_INT 21
87765: PUSH
87766: LD_INT 22
87768: PUSH
87769: LD_INT 23
87771: PUSH
87772: LD_INT 24
87774: PUSH
87775: LD_INT 25
87777: PUSH
87778: LD_INT 26
87780: PUSH
87781: LD_INT 27
87783: PUSH
87784: LD_INT 28
87786: PUSH
87787: LD_INT 29
87789: PUSH
87790: LD_INT 30
87792: PUSH
87793: LD_INT 31
87795: PUSH
87796: LD_INT 32
87798: PUSH
87799: LD_INT 33
87801: PUSH
87802: LD_INT 34
87804: PUSH
87805: LD_INT 36
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: LIST
87812: LIST
87813: LIST
87814: LIST
87815: LIST
87816: LIST
87817: LIST
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: LIST
87835: LIST
87836: LIST
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 101
87847: PUSH
87848: LD_INT 102
87850: PUSH
87851: LD_INT 103
87853: PUSH
87854: LD_INT 104
87856: PUSH
87857: LD_INT 105
87859: PUSH
87860: LD_INT 106
87862: PUSH
87863: LD_INT 107
87865: PUSH
87866: LD_INT 108
87868: PUSH
87869: LD_INT 109
87871: PUSH
87872: LD_INT 110
87874: PUSH
87875: LD_INT 111
87877: PUSH
87878: LD_INT 112
87880: PUSH
87881: LD_INT 113
87883: PUSH
87884: LD_INT 114
87886: PUSH
87887: EMPTY
87888: LIST
87889: LIST
87890: LIST
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: LIST
87900: LIST
87901: LIST
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: ST_TO_ADDR
87907: GO 88854
87909: LD_INT 15
87911: DOUBLE
87912: EQUAL
87913: IFTRUE 87917
87915: GO 88129
87917: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
87918: LD_ADDR_VAR 0 1
87922: PUSH
87923: LD_INT 1
87925: PUSH
87926: LD_INT 2
87928: PUSH
87929: LD_INT 3
87931: PUSH
87932: LD_INT 4
87934: PUSH
87935: LD_INT 5
87937: PUSH
87938: LD_INT 6
87940: PUSH
87941: LD_INT 7
87943: PUSH
87944: LD_INT 8
87946: PUSH
87947: LD_INT 9
87949: PUSH
87950: LD_INT 10
87952: PUSH
87953: LD_INT 11
87955: PUSH
87956: LD_INT 12
87958: PUSH
87959: LD_INT 13
87961: PUSH
87962: LD_INT 14
87964: PUSH
87965: LD_INT 15
87967: PUSH
87968: LD_INT 16
87970: PUSH
87971: LD_INT 17
87973: PUSH
87974: LD_INT 18
87976: PUSH
87977: LD_INT 19
87979: PUSH
87980: LD_INT 20
87982: PUSH
87983: LD_INT 21
87985: PUSH
87986: LD_INT 22
87988: PUSH
87989: LD_INT 23
87991: PUSH
87992: LD_INT 24
87994: PUSH
87995: LD_INT 25
87997: PUSH
87998: LD_INT 26
88000: PUSH
88001: LD_INT 27
88003: PUSH
88004: LD_INT 28
88006: PUSH
88007: LD_INT 29
88009: PUSH
88010: LD_INT 30
88012: PUSH
88013: LD_INT 31
88015: PUSH
88016: LD_INT 32
88018: PUSH
88019: LD_INT 33
88021: PUSH
88022: LD_INT 34
88024: PUSH
88025: LD_INT 36
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: LIST
88053: LIST
88054: LIST
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: LIST
88063: LIST
88064: PUSH
88065: LD_INT 101
88067: PUSH
88068: LD_INT 102
88070: PUSH
88071: LD_INT 103
88073: PUSH
88074: LD_INT 104
88076: PUSH
88077: LD_INT 105
88079: PUSH
88080: LD_INT 106
88082: PUSH
88083: LD_INT 107
88085: PUSH
88086: LD_INT 108
88088: PUSH
88089: LD_INT 109
88091: PUSH
88092: LD_INT 110
88094: PUSH
88095: LD_INT 111
88097: PUSH
88098: LD_INT 112
88100: PUSH
88101: LD_INT 113
88103: PUSH
88104: LD_INT 114
88106: PUSH
88107: EMPTY
88108: LIST
88109: LIST
88110: LIST
88111: LIST
88112: LIST
88113: LIST
88114: LIST
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: ST_TO_ADDR
88127: GO 88854
88129: LD_INT 16
88131: DOUBLE
88132: EQUAL
88133: IFTRUE 88137
88135: GO 88261
88137: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
88138: LD_ADDR_VAR 0 1
88142: PUSH
88143: LD_INT 2
88145: PUSH
88146: LD_INT 4
88148: PUSH
88149: LD_INT 5
88151: PUSH
88152: LD_INT 7
88154: PUSH
88155: LD_INT 11
88157: PUSH
88158: LD_INT 12
88160: PUSH
88161: LD_INT 15
88163: PUSH
88164: LD_INT 16
88166: PUSH
88167: LD_INT 20
88169: PUSH
88170: LD_INT 21
88172: PUSH
88173: LD_INT 22
88175: PUSH
88176: LD_INT 23
88178: PUSH
88179: LD_INT 25
88181: PUSH
88182: LD_INT 26
88184: PUSH
88185: LD_INT 30
88187: PUSH
88188: LD_INT 31
88190: PUSH
88191: LD_INT 32
88193: PUSH
88194: LD_INT 33
88196: PUSH
88197: LD_INT 34
88199: PUSH
88200: EMPTY
88201: LIST
88202: LIST
88203: LIST
88204: LIST
88205: LIST
88206: LIST
88207: LIST
88208: LIST
88209: LIST
88210: LIST
88211: LIST
88212: LIST
88213: LIST
88214: LIST
88215: LIST
88216: LIST
88217: LIST
88218: LIST
88219: LIST
88220: PUSH
88221: LD_INT 101
88223: PUSH
88224: LD_INT 102
88226: PUSH
88227: LD_INT 103
88229: PUSH
88230: LD_INT 106
88232: PUSH
88233: LD_INT 108
88235: PUSH
88236: LD_INT 112
88238: PUSH
88239: LD_INT 113
88241: PUSH
88242: LD_INT 114
88244: PUSH
88245: EMPTY
88246: LIST
88247: LIST
88248: LIST
88249: LIST
88250: LIST
88251: LIST
88252: LIST
88253: LIST
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: ST_TO_ADDR
88259: GO 88854
88261: LD_INT 17
88263: DOUBLE
88264: EQUAL
88265: IFTRUE 88269
88267: GO 88481
88269: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
88270: LD_ADDR_VAR 0 1
88274: PUSH
88275: LD_INT 1
88277: PUSH
88278: LD_INT 2
88280: PUSH
88281: LD_INT 3
88283: PUSH
88284: LD_INT 4
88286: PUSH
88287: LD_INT 5
88289: PUSH
88290: LD_INT 6
88292: PUSH
88293: LD_INT 7
88295: PUSH
88296: LD_INT 8
88298: PUSH
88299: LD_INT 9
88301: PUSH
88302: LD_INT 10
88304: PUSH
88305: LD_INT 11
88307: PUSH
88308: LD_INT 12
88310: PUSH
88311: LD_INT 13
88313: PUSH
88314: LD_INT 14
88316: PUSH
88317: LD_INT 15
88319: PUSH
88320: LD_INT 16
88322: PUSH
88323: LD_INT 17
88325: PUSH
88326: LD_INT 18
88328: PUSH
88329: LD_INT 19
88331: PUSH
88332: LD_INT 20
88334: PUSH
88335: LD_INT 21
88337: PUSH
88338: LD_INT 22
88340: PUSH
88341: LD_INT 23
88343: PUSH
88344: LD_INT 24
88346: PUSH
88347: LD_INT 25
88349: PUSH
88350: LD_INT 26
88352: PUSH
88353: LD_INT 27
88355: PUSH
88356: LD_INT 28
88358: PUSH
88359: LD_INT 29
88361: PUSH
88362: LD_INT 30
88364: PUSH
88365: LD_INT 31
88367: PUSH
88368: LD_INT 32
88370: PUSH
88371: LD_INT 33
88373: PUSH
88374: LD_INT 34
88376: PUSH
88377: LD_INT 36
88379: PUSH
88380: EMPTY
88381: LIST
88382: LIST
88383: LIST
88384: LIST
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: PUSH
88417: LD_INT 101
88419: PUSH
88420: LD_INT 102
88422: PUSH
88423: LD_INT 103
88425: PUSH
88426: LD_INT 104
88428: PUSH
88429: LD_INT 105
88431: PUSH
88432: LD_INT 106
88434: PUSH
88435: LD_INT 107
88437: PUSH
88438: LD_INT 108
88440: PUSH
88441: LD_INT 109
88443: PUSH
88444: LD_INT 110
88446: PUSH
88447: LD_INT 111
88449: PUSH
88450: LD_INT 112
88452: PUSH
88453: LD_INT 113
88455: PUSH
88456: LD_INT 114
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: LIST
88466: LIST
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: PUSH
88475: EMPTY
88476: LIST
88477: LIST
88478: ST_TO_ADDR
88479: GO 88854
88481: LD_INT 18
88483: DOUBLE
88484: EQUAL
88485: IFTRUE 88489
88487: GO 88625
88489: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
88490: LD_ADDR_VAR 0 1
88494: PUSH
88495: LD_INT 2
88497: PUSH
88498: LD_INT 4
88500: PUSH
88501: LD_INT 5
88503: PUSH
88504: LD_INT 7
88506: PUSH
88507: LD_INT 11
88509: PUSH
88510: LD_INT 12
88512: PUSH
88513: LD_INT 15
88515: PUSH
88516: LD_INT 16
88518: PUSH
88519: LD_INT 20
88521: PUSH
88522: LD_INT 21
88524: PUSH
88525: LD_INT 22
88527: PUSH
88528: LD_INT 23
88530: PUSH
88531: LD_INT 25
88533: PUSH
88534: LD_INT 26
88536: PUSH
88537: LD_INT 30
88539: PUSH
88540: LD_INT 31
88542: PUSH
88543: LD_INT 32
88545: PUSH
88546: LD_INT 33
88548: PUSH
88549: LD_INT 34
88551: PUSH
88552: LD_INT 35
88554: PUSH
88555: LD_INT 36
88557: PUSH
88558: EMPTY
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: PUSH
88581: LD_INT 101
88583: PUSH
88584: LD_INT 102
88586: PUSH
88587: LD_INT 103
88589: PUSH
88590: LD_INT 106
88592: PUSH
88593: LD_INT 108
88595: PUSH
88596: LD_INT 112
88598: PUSH
88599: LD_INT 113
88601: PUSH
88602: LD_INT 114
88604: PUSH
88605: LD_INT 115
88607: PUSH
88608: EMPTY
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: LIST
88617: LIST
88618: PUSH
88619: EMPTY
88620: LIST
88621: LIST
88622: ST_TO_ADDR
88623: GO 88854
88625: LD_INT 19
88627: DOUBLE
88628: EQUAL
88629: IFTRUE 88633
88631: GO 88853
88633: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
88634: LD_ADDR_VAR 0 1
88638: PUSH
88639: LD_INT 1
88641: PUSH
88642: LD_INT 2
88644: PUSH
88645: LD_INT 3
88647: PUSH
88648: LD_INT 4
88650: PUSH
88651: LD_INT 5
88653: PUSH
88654: LD_INT 6
88656: PUSH
88657: LD_INT 7
88659: PUSH
88660: LD_INT 8
88662: PUSH
88663: LD_INT 9
88665: PUSH
88666: LD_INT 10
88668: PUSH
88669: LD_INT 11
88671: PUSH
88672: LD_INT 12
88674: PUSH
88675: LD_INT 13
88677: PUSH
88678: LD_INT 14
88680: PUSH
88681: LD_INT 15
88683: PUSH
88684: LD_INT 16
88686: PUSH
88687: LD_INT 17
88689: PUSH
88690: LD_INT 18
88692: PUSH
88693: LD_INT 19
88695: PUSH
88696: LD_INT 20
88698: PUSH
88699: LD_INT 21
88701: PUSH
88702: LD_INT 22
88704: PUSH
88705: LD_INT 23
88707: PUSH
88708: LD_INT 24
88710: PUSH
88711: LD_INT 25
88713: PUSH
88714: LD_INT 26
88716: PUSH
88717: LD_INT 27
88719: PUSH
88720: LD_INT 28
88722: PUSH
88723: LD_INT 29
88725: PUSH
88726: LD_INT 30
88728: PUSH
88729: LD_INT 31
88731: PUSH
88732: LD_INT 32
88734: PUSH
88735: LD_INT 33
88737: PUSH
88738: LD_INT 34
88740: PUSH
88741: LD_INT 35
88743: PUSH
88744: LD_INT 36
88746: PUSH
88747: EMPTY
88748: LIST
88749: LIST
88750: LIST
88751: LIST
88752: LIST
88753: LIST
88754: LIST
88755: LIST
88756: LIST
88757: LIST
88758: LIST
88759: LIST
88760: LIST
88761: LIST
88762: LIST
88763: LIST
88764: LIST
88765: LIST
88766: LIST
88767: LIST
88768: LIST
88769: LIST
88770: LIST
88771: LIST
88772: LIST
88773: LIST
88774: LIST
88775: LIST
88776: LIST
88777: LIST
88778: LIST
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: LIST
88784: PUSH
88785: LD_INT 101
88787: PUSH
88788: LD_INT 102
88790: PUSH
88791: LD_INT 103
88793: PUSH
88794: LD_INT 104
88796: PUSH
88797: LD_INT 105
88799: PUSH
88800: LD_INT 106
88802: PUSH
88803: LD_INT 107
88805: PUSH
88806: LD_INT 108
88808: PUSH
88809: LD_INT 109
88811: PUSH
88812: LD_INT 110
88814: PUSH
88815: LD_INT 111
88817: PUSH
88818: LD_INT 112
88820: PUSH
88821: LD_INT 113
88823: PUSH
88824: LD_INT 114
88826: PUSH
88827: LD_INT 115
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: PUSH
88847: EMPTY
88848: LIST
88849: LIST
88850: ST_TO_ADDR
88851: GO 88854
88853: POP
// end else
88854: GO 89073
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
88856: LD_ADDR_VAR 0 1
88860: PUSH
88861: LD_INT 1
88863: PUSH
88864: LD_INT 2
88866: PUSH
88867: LD_INT 3
88869: PUSH
88870: LD_INT 4
88872: PUSH
88873: LD_INT 5
88875: PUSH
88876: LD_INT 6
88878: PUSH
88879: LD_INT 7
88881: PUSH
88882: LD_INT 8
88884: PUSH
88885: LD_INT 9
88887: PUSH
88888: LD_INT 10
88890: PUSH
88891: LD_INT 11
88893: PUSH
88894: LD_INT 12
88896: PUSH
88897: LD_INT 13
88899: PUSH
88900: LD_INT 14
88902: PUSH
88903: LD_INT 15
88905: PUSH
88906: LD_INT 16
88908: PUSH
88909: LD_INT 17
88911: PUSH
88912: LD_INT 18
88914: PUSH
88915: LD_INT 19
88917: PUSH
88918: LD_INT 20
88920: PUSH
88921: LD_INT 21
88923: PUSH
88924: LD_INT 22
88926: PUSH
88927: LD_INT 23
88929: PUSH
88930: LD_INT 24
88932: PUSH
88933: LD_INT 25
88935: PUSH
88936: LD_INT 26
88938: PUSH
88939: LD_INT 27
88941: PUSH
88942: LD_INT 28
88944: PUSH
88945: LD_INT 29
88947: PUSH
88948: LD_INT 30
88950: PUSH
88951: LD_INT 31
88953: PUSH
88954: LD_INT 32
88956: PUSH
88957: LD_INT 33
88959: PUSH
88960: LD_INT 34
88962: PUSH
88963: LD_INT 35
88965: PUSH
88966: LD_INT 36
88968: PUSH
88969: EMPTY
88970: LIST
88971: LIST
88972: LIST
88973: LIST
88974: LIST
88975: LIST
88976: LIST
88977: LIST
88978: LIST
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: PUSH
89007: LD_INT 101
89009: PUSH
89010: LD_INT 102
89012: PUSH
89013: LD_INT 103
89015: PUSH
89016: LD_INT 104
89018: PUSH
89019: LD_INT 105
89021: PUSH
89022: LD_INT 106
89024: PUSH
89025: LD_INT 107
89027: PUSH
89028: LD_INT 108
89030: PUSH
89031: LD_INT 109
89033: PUSH
89034: LD_INT 110
89036: PUSH
89037: LD_INT 111
89039: PUSH
89040: LD_INT 112
89042: PUSH
89043: LD_INT 113
89045: PUSH
89046: LD_INT 114
89048: PUSH
89049: LD_INT 115
89051: PUSH
89052: EMPTY
89053: LIST
89054: LIST
89055: LIST
89056: LIST
89057: LIST
89058: LIST
89059: LIST
89060: LIST
89061: LIST
89062: LIST
89063: LIST
89064: LIST
89065: LIST
89066: LIST
89067: LIST
89068: PUSH
89069: EMPTY
89070: LIST
89071: LIST
89072: ST_TO_ADDR
// if result then
89073: LD_VAR 0 1
89077: IFFALSE 89366
// begin normal :=  ;
89079: LD_ADDR_VAR 0 3
89083: PUSH
89084: LD_STRING 
89086: ST_TO_ADDR
// hardcore :=  ;
89087: LD_ADDR_VAR 0 4
89091: PUSH
89092: LD_STRING 
89094: ST_TO_ADDR
// for i = 1 to normalCounter do
89095: LD_ADDR_VAR 0 5
89099: PUSH
89100: DOUBLE
89101: LD_INT 1
89103: DEC
89104: ST_TO_ADDR
89105: LD_EXP 110
89109: PUSH
89110: FOR_TO
89111: IFFALSE 89212
// begin tmp := 0 ;
89113: LD_ADDR_VAR 0 2
89117: PUSH
89118: LD_STRING 0
89120: ST_TO_ADDR
// if result [ 1 ] then
89121: LD_VAR 0 1
89125: PUSH
89126: LD_INT 1
89128: ARRAY
89129: IFFALSE 89194
// if result [ 1 ] [ 1 ] = i then
89131: LD_VAR 0 1
89135: PUSH
89136: LD_INT 1
89138: ARRAY
89139: PUSH
89140: LD_INT 1
89142: ARRAY
89143: PUSH
89144: LD_VAR 0 5
89148: EQUAL
89149: IFFALSE 89194
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
89151: LD_ADDR_VAR 0 1
89155: PUSH
89156: LD_VAR 0 1
89160: PPUSH
89161: LD_INT 1
89163: PPUSH
89164: LD_VAR 0 1
89168: PUSH
89169: LD_INT 1
89171: ARRAY
89172: PPUSH
89173: LD_INT 1
89175: PPUSH
89176: CALL_OW 3
89180: PPUSH
89181: CALL_OW 1
89185: ST_TO_ADDR
// tmp := 1 ;
89186: LD_ADDR_VAR 0 2
89190: PUSH
89191: LD_STRING 1
89193: ST_TO_ADDR
// end ; normal := normal & tmp ;
89194: LD_ADDR_VAR 0 3
89198: PUSH
89199: LD_VAR 0 3
89203: PUSH
89204: LD_VAR 0 2
89208: STR
89209: ST_TO_ADDR
// end ;
89210: GO 89110
89212: POP
89213: POP
// for i = 1 to hardcoreCounter do
89214: LD_ADDR_VAR 0 5
89218: PUSH
89219: DOUBLE
89220: LD_INT 1
89222: DEC
89223: ST_TO_ADDR
89224: LD_EXP 111
89228: PUSH
89229: FOR_TO
89230: IFFALSE 89335
// begin tmp := 0 ;
89232: LD_ADDR_VAR 0 2
89236: PUSH
89237: LD_STRING 0
89239: ST_TO_ADDR
// if result [ 2 ] then
89240: LD_VAR 0 1
89244: PUSH
89245: LD_INT 2
89247: ARRAY
89248: IFFALSE 89317
// if result [ 2 ] [ 1 ] = 100 + i then
89250: LD_VAR 0 1
89254: PUSH
89255: LD_INT 2
89257: ARRAY
89258: PUSH
89259: LD_INT 1
89261: ARRAY
89262: PUSH
89263: LD_INT 100
89265: PUSH
89266: LD_VAR 0 5
89270: PLUS
89271: EQUAL
89272: IFFALSE 89317
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
89274: LD_ADDR_VAR 0 1
89278: PUSH
89279: LD_VAR 0 1
89283: PPUSH
89284: LD_INT 2
89286: PPUSH
89287: LD_VAR 0 1
89291: PUSH
89292: LD_INT 2
89294: ARRAY
89295: PPUSH
89296: LD_INT 1
89298: PPUSH
89299: CALL_OW 3
89303: PPUSH
89304: CALL_OW 1
89308: ST_TO_ADDR
// tmp := 1 ;
89309: LD_ADDR_VAR 0 2
89313: PUSH
89314: LD_STRING 1
89316: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
89317: LD_ADDR_VAR 0 4
89321: PUSH
89322: LD_VAR 0 4
89326: PUSH
89327: LD_VAR 0 2
89331: STR
89332: ST_TO_ADDR
// end ;
89333: GO 89229
89335: POP
89336: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
89337: LD_STRING getStreamItemsFromMission("
89339: PUSH
89340: LD_VAR 0 3
89344: STR
89345: PUSH
89346: LD_STRING ","
89348: STR
89349: PUSH
89350: LD_VAR 0 4
89354: STR
89355: PUSH
89356: LD_STRING ")
89358: STR
89359: PPUSH
89360: CALL_OW 559
// end else
89364: GO 89373
// ToLua ( getStreamItemsFromMission("","") ) ;
89366: LD_STRING getStreamItemsFromMission("","")
89368: PPUSH
89369: CALL_OW 559
// end ;
89373: LD_VAR 0 1
89377: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
89378: LD_EXP 109
89382: PUSH
89383: LD_EXP 114
89387: AND
89388: IFFALSE 89512
89390: GO 89392
89392: DISABLE
89393: LD_INT 0
89395: PPUSH
89396: PPUSH
// begin enable ;
89397: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
89398: LD_ADDR_VAR 0 2
89402: PUSH
89403: LD_INT 22
89405: PUSH
89406: LD_OWVAR 2
89410: PUSH
89411: EMPTY
89412: LIST
89413: LIST
89414: PUSH
89415: LD_INT 2
89417: PUSH
89418: LD_INT 34
89420: PUSH
89421: LD_INT 7
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: LD_INT 34
89430: PUSH
89431: LD_INT 45
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: PUSH
89438: LD_INT 34
89440: PUSH
89441: LD_INT 28
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: LD_INT 34
89450: PUSH
89451: LD_INT 47
89453: PUSH
89454: EMPTY
89455: LIST
89456: LIST
89457: PUSH
89458: EMPTY
89459: LIST
89460: LIST
89461: LIST
89462: LIST
89463: LIST
89464: PUSH
89465: EMPTY
89466: LIST
89467: LIST
89468: PPUSH
89469: CALL_OW 69
89473: ST_TO_ADDR
// if not tmp then
89474: LD_VAR 0 2
89478: NOT
89479: IFFALSE 89483
// exit ;
89481: GO 89512
// for i in tmp do
89483: LD_ADDR_VAR 0 1
89487: PUSH
89488: LD_VAR 0 2
89492: PUSH
89493: FOR_IN
89494: IFFALSE 89510
// begin SetLives ( i , 0 ) ;
89496: LD_VAR 0 1
89500: PPUSH
89501: LD_INT 0
89503: PPUSH
89504: CALL_OW 234
// end ;
89508: GO 89493
89510: POP
89511: POP
// end ;
89512: PPOPN 2
89514: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
89515: LD_EXP 109
89519: PUSH
89520: LD_EXP 115
89524: AND
89525: IFFALSE 89609
89527: GO 89529
89529: DISABLE
89530: LD_INT 0
89532: PPUSH
89533: PPUSH
// begin enable ;
89534: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
89535: LD_ADDR_VAR 0 2
89539: PUSH
89540: LD_INT 22
89542: PUSH
89543: LD_OWVAR 2
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: PUSH
89552: LD_INT 32
89554: PUSH
89555: LD_INT 3
89557: PUSH
89558: EMPTY
89559: LIST
89560: LIST
89561: PUSH
89562: EMPTY
89563: LIST
89564: LIST
89565: PPUSH
89566: CALL_OW 69
89570: ST_TO_ADDR
// if not tmp then
89571: LD_VAR 0 2
89575: NOT
89576: IFFALSE 89580
// exit ;
89578: GO 89609
// for i in tmp do
89580: LD_ADDR_VAR 0 1
89584: PUSH
89585: LD_VAR 0 2
89589: PUSH
89590: FOR_IN
89591: IFFALSE 89607
// begin SetLives ( i , 0 ) ;
89593: LD_VAR 0 1
89597: PPUSH
89598: LD_INT 0
89600: PPUSH
89601: CALL_OW 234
// end ;
89605: GO 89590
89607: POP
89608: POP
// end ;
89609: PPOPN 2
89611: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
89612: LD_EXP 109
89616: PUSH
89617: LD_EXP 112
89621: AND
89622: IFFALSE 89715
89624: GO 89626
89626: DISABLE
89627: LD_INT 0
89629: PPUSH
// begin enable ;
89630: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
89631: LD_ADDR_VAR 0 1
89635: PUSH
89636: LD_INT 22
89638: PUSH
89639: LD_OWVAR 2
89643: PUSH
89644: EMPTY
89645: LIST
89646: LIST
89647: PUSH
89648: LD_INT 2
89650: PUSH
89651: LD_INT 25
89653: PUSH
89654: LD_INT 5
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: PUSH
89661: LD_INT 25
89663: PUSH
89664: LD_INT 9
89666: PUSH
89667: EMPTY
89668: LIST
89669: LIST
89670: PUSH
89671: LD_INT 25
89673: PUSH
89674: LD_INT 8
89676: PUSH
89677: EMPTY
89678: LIST
89679: LIST
89680: PUSH
89681: EMPTY
89682: LIST
89683: LIST
89684: LIST
89685: LIST
89686: PUSH
89687: EMPTY
89688: LIST
89689: LIST
89690: PPUSH
89691: CALL_OW 69
89695: PUSH
89696: FOR_IN
89697: IFFALSE 89713
// begin SetClass ( i , 1 ) ;
89699: LD_VAR 0 1
89703: PPUSH
89704: LD_INT 1
89706: PPUSH
89707: CALL_OW 336
// end ;
89711: GO 89696
89713: POP
89714: POP
// end ;
89715: PPOPN 1
89717: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
89718: LD_EXP 109
89722: PUSH
89723: LD_EXP 113
89727: AND
89728: PUSH
89729: LD_OWVAR 65
89733: PUSH
89734: LD_INT 7
89736: LESS
89737: AND
89738: IFFALSE 89752
89740: GO 89742
89742: DISABLE
// begin enable ;
89743: ENABLE
// game_speed := 7 ;
89744: LD_ADDR_OWVAR 65
89748: PUSH
89749: LD_INT 7
89751: ST_TO_ADDR
// end ;
89752: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
89753: LD_EXP 109
89757: PUSH
89758: LD_EXP 116
89762: AND
89763: IFFALSE 89965
89765: GO 89767
89767: DISABLE
89768: LD_INT 0
89770: PPUSH
89771: PPUSH
89772: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
89773: LD_ADDR_VAR 0 3
89777: PUSH
89778: LD_INT 81
89780: PUSH
89781: LD_OWVAR 2
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: PUSH
89790: LD_INT 21
89792: PUSH
89793: LD_INT 1
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: EMPTY
89801: LIST
89802: LIST
89803: PPUSH
89804: CALL_OW 69
89808: ST_TO_ADDR
// if not tmp then
89809: LD_VAR 0 3
89813: NOT
89814: IFFALSE 89818
// exit ;
89816: GO 89965
// if tmp > 5 then
89818: LD_VAR 0 3
89822: PUSH
89823: LD_INT 5
89825: GREATER
89826: IFFALSE 89838
// k := 5 else
89828: LD_ADDR_VAR 0 2
89832: PUSH
89833: LD_INT 5
89835: ST_TO_ADDR
89836: GO 89848
// k := tmp ;
89838: LD_ADDR_VAR 0 2
89842: PUSH
89843: LD_VAR 0 3
89847: ST_TO_ADDR
// for i := 1 to k do
89848: LD_ADDR_VAR 0 1
89852: PUSH
89853: DOUBLE
89854: LD_INT 1
89856: DEC
89857: ST_TO_ADDR
89858: LD_VAR 0 2
89862: PUSH
89863: FOR_TO
89864: IFFALSE 89963
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
89866: LD_VAR 0 3
89870: PUSH
89871: LD_VAR 0 1
89875: ARRAY
89876: PPUSH
89877: LD_VAR 0 1
89881: PUSH
89882: LD_INT 4
89884: MOD
89885: PUSH
89886: LD_INT 1
89888: PLUS
89889: PPUSH
89890: CALL_OW 259
89894: PUSH
89895: LD_INT 10
89897: LESS
89898: IFFALSE 89961
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
89900: LD_VAR 0 3
89904: PUSH
89905: LD_VAR 0 1
89909: ARRAY
89910: PPUSH
89911: LD_VAR 0 1
89915: PUSH
89916: LD_INT 4
89918: MOD
89919: PUSH
89920: LD_INT 1
89922: PLUS
89923: PPUSH
89924: LD_VAR 0 3
89928: PUSH
89929: LD_VAR 0 1
89933: ARRAY
89934: PPUSH
89935: LD_VAR 0 1
89939: PUSH
89940: LD_INT 4
89942: MOD
89943: PUSH
89944: LD_INT 1
89946: PLUS
89947: PPUSH
89948: CALL_OW 259
89952: PUSH
89953: LD_INT 1
89955: PLUS
89956: PPUSH
89957: CALL_OW 237
89961: GO 89863
89963: POP
89964: POP
// end ;
89965: PPOPN 3
89967: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
89968: LD_EXP 109
89972: PUSH
89973: LD_EXP 117
89977: AND
89978: IFFALSE 89998
89980: GO 89982
89982: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
89983: LD_INT 4
89985: PPUSH
89986: LD_OWVAR 2
89990: PPUSH
89991: LD_INT 0
89993: PPUSH
89994: CALL_OW 324
89998: END
// every 0 0$1 trigger StreamModeActive and sShovel do
89999: LD_EXP 109
90003: PUSH
90004: LD_EXP 146
90008: AND
90009: IFFALSE 90029
90011: GO 90013
90013: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
90014: LD_INT 19
90016: PPUSH
90017: LD_OWVAR 2
90021: PPUSH
90022: LD_INT 0
90024: PPUSH
90025: CALL_OW 324
90029: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
90030: LD_EXP 109
90034: PUSH
90035: LD_EXP 118
90039: AND
90040: IFFALSE 90142
90042: GO 90044
90044: DISABLE
90045: LD_INT 0
90047: PPUSH
90048: PPUSH
// begin enable ;
90049: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
90050: LD_ADDR_VAR 0 2
90054: PUSH
90055: LD_INT 22
90057: PUSH
90058: LD_OWVAR 2
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: PUSH
90067: LD_INT 2
90069: PUSH
90070: LD_INT 34
90072: PUSH
90073: LD_INT 11
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: PUSH
90080: LD_INT 34
90082: PUSH
90083: LD_INT 30
90085: PUSH
90086: EMPTY
90087: LIST
90088: LIST
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: LIST
90094: PUSH
90095: EMPTY
90096: LIST
90097: LIST
90098: PPUSH
90099: CALL_OW 69
90103: ST_TO_ADDR
// if not tmp then
90104: LD_VAR 0 2
90108: NOT
90109: IFFALSE 90113
// exit ;
90111: GO 90142
// for i in tmp do
90113: LD_ADDR_VAR 0 1
90117: PUSH
90118: LD_VAR 0 2
90122: PUSH
90123: FOR_IN
90124: IFFALSE 90140
// begin SetLives ( i , 0 ) ;
90126: LD_VAR 0 1
90130: PPUSH
90131: LD_INT 0
90133: PPUSH
90134: CALL_OW 234
// end ;
90138: GO 90123
90140: POP
90141: POP
// end ;
90142: PPOPN 2
90144: END
// every 0 0$1 trigger StreamModeActive and sBunker do
90145: LD_EXP 109
90149: PUSH
90150: LD_EXP 119
90154: AND
90155: IFFALSE 90175
90157: GO 90159
90159: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
90160: LD_INT 32
90162: PPUSH
90163: LD_OWVAR 2
90167: PPUSH
90168: LD_INT 0
90170: PPUSH
90171: CALL_OW 324
90175: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
90176: LD_EXP 109
90180: PUSH
90181: LD_EXP 120
90185: AND
90186: IFFALSE 90367
90188: GO 90190
90190: DISABLE
90191: LD_INT 0
90193: PPUSH
90194: PPUSH
90195: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
90196: LD_ADDR_VAR 0 2
90200: PUSH
90201: LD_INT 22
90203: PUSH
90204: LD_OWVAR 2
90208: PUSH
90209: EMPTY
90210: LIST
90211: LIST
90212: PUSH
90213: LD_INT 33
90215: PUSH
90216: LD_INT 3
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: PPUSH
90227: CALL_OW 69
90231: ST_TO_ADDR
// if not tmp then
90232: LD_VAR 0 2
90236: NOT
90237: IFFALSE 90241
// exit ;
90239: GO 90367
// side := 0 ;
90241: LD_ADDR_VAR 0 3
90245: PUSH
90246: LD_INT 0
90248: ST_TO_ADDR
// for i := 1 to 8 do
90249: LD_ADDR_VAR 0 1
90253: PUSH
90254: DOUBLE
90255: LD_INT 1
90257: DEC
90258: ST_TO_ADDR
90259: LD_INT 8
90261: PUSH
90262: FOR_TO
90263: IFFALSE 90311
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
90265: LD_OWVAR 2
90269: PUSH
90270: LD_VAR 0 1
90274: NONEQUAL
90275: PUSH
90276: LD_OWVAR 2
90280: PPUSH
90281: LD_VAR 0 1
90285: PPUSH
90286: CALL_OW 81
90290: PUSH
90291: LD_INT 2
90293: EQUAL
90294: AND
90295: IFFALSE 90309
// begin side := i ;
90297: LD_ADDR_VAR 0 3
90301: PUSH
90302: LD_VAR 0 1
90306: ST_TO_ADDR
// break ;
90307: GO 90311
// end ;
90309: GO 90262
90311: POP
90312: POP
// if not side then
90313: LD_VAR 0 3
90317: NOT
90318: IFFALSE 90322
// exit ;
90320: GO 90367
// for i := 1 to tmp do
90322: LD_ADDR_VAR 0 1
90326: PUSH
90327: DOUBLE
90328: LD_INT 1
90330: DEC
90331: ST_TO_ADDR
90332: LD_VAR 0 2
90336: PUSH
90337: FOR_TO
90338: IFFALSE 90365
// if Prob ( 60 ) then
90340: LD_INT 60
90342: PPUSH
90343: CALL_OW 13
90347: IFFALSE 90363
// SetSide ( i , side ) ;
90349: LD_VAR 0 1
90353: PPUSH
90354: LD_VAR 0 3
90358: PPUSH
90359: CALL_OW 235
90363: GO 90337
90365: POP
90366: POP
// end ;
90367: PPOPN 3
90369: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
90370: LD_EXP 109
90374: PUSH
90375: LD_EXP 122
90379: AND
90380: IFFALSE 90499
90382: GO 90384
90384: DISABLE
90385: LD_INT 0
90387: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
90388: LD_ADDR_VAR 0 1
90392: PUSH
90393: LD_INT 22
90395: PUSH
90396: LD_OWVAR 2
90400: PUSH
90401: EMPTY
90402: LIST
90403: LIST
90404: PUSH
90405: LD_INT 21
90407: PUSH
90408: LD_INT 1
90410: PUSH
90411: EMPTY
90412: LIST
90413: LIST
90414: PUSH
90415: LD_INT 3
90417: PUSH
90418: LD_INT 23
90420: PUSH
90421: LD_INT 0
90423: PUSH
90424: EMPTY
90425: LIST
90426: LIST
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: PUSH
90432: EMPTY
90433: LIST
90434: LIST
90435: LIST
90436: PPUSH
90437: CALL_OW 69
90441: PUSH
90442: FOR_IN
90443: IFFALSE 90497
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
90445: LD_VAR 0 1
90449: PPUSH
90450: CALL_OW 257
90454: PUSH
90455: LD_INT 1
90457: PUSH
90458: LD_INT 2
90460: PUSH
90461: LD_INT 3
90463: PUSH
90464: LD_INT 4
90466: PUSH
90467: EMPTY
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: IN
90473: IFFALSE 90495
// SetClass ( un , rand ( 1 , 4 ) ) ;
90475: LD_VAR 0 1
90479: PPUSH
90480: LD_INT 1
90482: PPUSH
90483: LD_INT 4
90485: PPUSH
90486: CALL_OW 12
90490: PPUSH
90491: CALL_OW 336
90495: GO 90442
90497: POP
90498: POP
// end ;
90499: PPOPN 1
90501: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
90502: LD_EXP 109
90506: PUSH
90507: LD_EXP 121
90511: AND
90512: IFFALSE 90591
90514: GO 90516
90516: DISABLE
90517: LD_INT 0
90519: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
90520: LD_ADDR_VAR 0 1
90524: PUSH
90525: LD_INT 22
90527: PUSH
90528: LD_OWVAR 2
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: PUSH
90537: LD_INT 21
90539: PUSH
90540: LD_INT 3
90542: PUSH
90543: EMPTY
90544: LIST
90545: LIST
90546: PUSH
90547: EMPTY
90548: LIST
90549: LIST
90550: PPUSH
90551: CALL_OW 69
90555: ST_TO_ADDR
// if not tmp then
90556: LD_VAR 0 1
90560: NOT
90561: IFFALSE 90565
// exit ;
90563: GO 90591
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
90565: LD_VAR 0 1
90569: PUSH
90570: LD_INT 1
90572: PPUSH
90573: LD_VAR 0 1
90577: PPUSH
90578: CALL_OW 12
90582: ARRAY
90583: PPUSH
90584: LD_INT 100
90586: PPUSH
90587: CALL_OW 234
// end ;
90591: PPOPN 1
90593: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
90594: LD_EXP 109
90598: PUSH
90599: LD_EXP 123
90603: AND
90604: IFFALSE 90702
90606: GO 90608
90608: DISABLE
90609: LD_INT 0
90611: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90612: LD_ADDR_VAR 0 1
90616: PUSH
90617: LD_INT 22
90619: PUSH
90620: LD_OWVAR 2
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 21
90631: PUSH
90632: LD_INT 1
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: PUSH
90639: EMPTY
90640: LIST
90641: LIST
90642: PPUSH
90643: CALL_OW 69
90647: ST_TO_ADDR
// if not tmp then
90648: LD_VAR 0 1
90652: NOT
90653: IFFALSE 90657
// exit ;
90655: GO 90702
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
90657: LD_VAR 0 1
90661: PUSH
90662: LD_INT 1
90664: PPUSH
90665: LD_VAR 0 1
90669: PPUSH
90670: CALL_OW 12
90674: ARRAY
90675: PPUSH
90676: LD_INT 1
90678: PPUSH
90679: LD_INT 4
90681: PPUSH
90682: CALL_OW 12
90686: PPUSH
90687: LD_INT 3000
90689: PPUSH
90690: LD_INT 9000
90692: PPUSH
90693: CALL_OW 12
90697: PPUSH
90698: CALL_OW 492
// end ;
90702: PPOPN 1
90704: END
// every 0 0$1 trigger StreamModeActive and sDepot do
90705: LD_EXP 109
90709: PUSH
90710: LD_EXP 124
90714: AND
90715: IFFALSE 90735
90717: GO 90719
90719: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
90720: LD_INT 1
90722: PPUSH
90723: LD_OWVAR 2
90727: PPUSH
90728: LD_INT 0
90730: PPUSH
90731: CALL_OW 324
90735: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
90736: LD_EXP 109
90740: PUSH
90741: LD_EXP 125
90745: AND
90746: IFFALSE 90829
90748: GO 90750
90750: DISABLE
90751: LD_INT 0
90753: PPUSH
90754: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
90755: LD_ADDR_VAR 0 2
90759: PUSH
90760: LD_INT 22
90762: PUSH
90763: LD_OWVAR 2
90767: PUSH
90768: EMPTY
90769: LIST
90770: LIST
90771: PUSH
90772: LD_INT 21
90774: PUSH
90775: LD_INT 3
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: PUSH
90782: EMPTY
90783: LIST
90784: LIST
90785: PPUSH
90786: CALL_OW 69
90790: ST_TO_ADDR
// if not tmp then
90791: LD_VAR 0 2
90795: NOT
90796: IFFALSE 90800
// exit ;
90798: GO 90829
// for i in tmp do
90800: LD_ADDR_VAR 0 1
90804: PUSH
90805: LD_VAR 0 2
90809: PUSH
90810: FOR_IN
90811: IFFALSE 90827
// SetBLevel ( i , 10 ) ;
90813: LD_VAR 0 1
90817: PPUSH
90818: LD_INT 10
90820: PPUSH
90821: CALL_OW 241
90825: GO 90810
90827: POP
90828: POP
// end ;
90829: PPOPN 2
90831: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
90832: LD_EXP 109
90836: PUSH
90837: LD_EXP 126
90841: AND
90842: IFFALSE 90953
90844: GO 90846
90846: DISABLE
90847: LD_INT 0
90849: PPUSH
90850: PPUSH
90851: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90852: LD_ADDR_VAR 0 3
90856: PUSH
90857: LD_INT 22
90859: PUSH
90860: LD_OWVAR 2
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PUSH
90869: LD_INT 25
90871: PUSH
90872: LD_INT 1
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: EMPTY
90880: LIST
90881: LIST
90882: PPUSH
90883: CALL_OW 69
90887: ST_TO_ADDR
// if not tmp then
90888: LD_VAR 0 3
90892: NOT
90893: IFFALSE 90897
// exit ;
90895: GO 90953
// un := tmp [ rand ( 1 , tmp ) ] ;
90897: LD_ADDR_VAR 0 2
90901: PUSH
90902: LD_VAR 0 3
90906: PUSH
90907: LD_INT 1
90909: PPUSH
90910: LD_VAR 0 3
90914: PPUSH
90915: CALL_OW 12
90919: ARRAY
90920: ST_TO_ADDR
// if Crawls ( un ) then
90921: LD_VAR 0 2
90925: PPUSH
90926: CALL_OW 318
90930: IFFALSE 90941
// ComWalk ( un ) ;
90932: LD_VAR 0 2
90936: PPUSH
90937: CALL_OW 138
// SetClass ( un , class_sniper ) ;
90941: LD_VAR 0 2
90945: PPUSH
90946: LD_INT 5
90948: PPUSH
90949: CALL_OW 336
// end ;
90953: PPOPN 3
90955: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
90956: LD_EXP 109
90960: PUSH
90961: LD_EXP 127
90965: AND
90966: PUSH
90967: LD_OWVAR 67
90971: PUSH
90972: LD_INT 3
90974: LESS
90975: AND
90976: IFFALSE 90995
90978: GO 90980
90980: DISABLE
// Difficulty := Difficulty + 1 ;
90981: LD_ADDR_OWVAR 67
90985: PUSH
90986: LD_OWVAR 67
90990: PUSH
90991: LD_INT 1
90993: PLUS
90994: ST_TO_ADDR
90995: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
90996: LD_EXP 109
91000: PUSH
91001: LD_EXP 128
91005: AND
91006: IFFALSE 91109
91008: GO 91010
91010: DISABLE
91011: LD_INT 0
91013: PPUSH
// begin for i := 1 to 5 do
91014: LD_ADDR_VAR 0 1
91018: PUSH
91019: DOUBLE
91020: LD_INT 1
91022: DEC
91023: ST_TO_ADDR
91024: LD_INT 5
91026: PUSH
91027: FOR_TO
91028: IFFALSE 91107
// begin uc_nation := nation_nature ;
91030: LD_ADDR_OWVAR 21
91034: PUSH
91035: LD_INT 0
91037: ST_TO_ADDR
// uc_side := 0 ;
91038: LD_ADDR_OWVAR 20
91042: PUSH
91043: LD_INT 0
91045: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
91046: LD_ADDR_OWVAR 29
91050: PUSH
91051: LD_INT 12
91053: PUSH
91054: LD_INT 12
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: ST_TO_ADDR
// hc_agressivity := 20 ;
91061: LD_ADDR_OWVAR 35
91065: PUSH
91066: LD_INT 20
91068: ST_TO_ADDR
// hc_class := class_tiger ;
91069: LD_ADDR_OWVAR 28
91073: PUSH
91074: LD_INT 14
91076: ST_TO_ADDR
// hc_gallery :=  ;
91077: LD_ADDR_OWVAR 33
91081: PUSH
91082: LD_STRING 
91084: ST_TO_ADDR
// hc_name :=  ;
91085: LD_ADDR_OWVAR 26
91089: PUSH
91090: LD_STRING 
91092: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
91093: CALL_OW 44
91097: PPUSH
91098: LD_INT 0
91100: PPUSH
91101: CALL_OW 51
// end ;
91105: GO 91027
91107: POP
91108: POP
// end ;
91109: PPOPN 1
91111: END
// every 0 0$1 trigger StreamModeActive and sBomb do
91112: LD_EXP 109
91116: PUSH
91117: LD_EXP 129
91121: AND
91122: IFFALSE 91131
91124: GO 91126
91126: DISABLE
// StreamSibBomb ;
91127: CALL 91132 0 0
91131: END
// export function StreamSibBomb ; var i , x , y ; begin
91132: LD_INT 0
91134: PPUSH
91135: PPUSH
91136: PPUSH
91137: PPUSH
// result := false ;
91138: LD_ADDR_VAR 0 1
91142: PUSH
91143: LD_INT 0
91145: ST_TO_ADDR
// for i := 1 to 16 do
91146: LD_ADDR_VAR 0 2
91150: PUSH
91151: DOUBLE
91152: LD_INT 1
91154: DEC
91155: ST_TO_ADDR
91156: LD_INT 16
91158: PUSH
91159: FOR_TO
91160: IFFALSE 91359
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91162: LD_ADDR_VAR 0 3
91166: PUSH
91167: LD_INT 10
91169: PUSH
91170: LD_INT 20
91172: PUSH
91173: LD_INT 30
91175: PUSH
91176: LD_INT 40
91178: PUSH
91179: LD_INT 50
91181: PUSH
91182: LD_INT 60
91184: PUSH
91185: LD_INT 70
91187: PUSH
91188: LD_INT 80
91190: PUSH
91191: LD_INT 90
91193: PUSH
91194: LD_INT 100
91196: PUSH
91197: LD_INT 110
91199: PUSH
91200: LD_INT 120
91202: PUSH
91203: LD_INT 130
91205: PUSH
91206: LD_INT 140
91208: PUSH
91209: LD_INT 150
91211: PUSH
91212: EMPTY
91213: LIST
91214: LIST
91215: LIST
91216: LIST
91217: LIST
91218: LIST
91219: LIST
91220: LIST
91221: LIST
91222: LIST
91223: LIST
91224: LIST
91225: LIST
91226: LIST
91227: LIST
91228: PUSH
91229: LD_INT 1
91231: PPUSH
91232: LD_INT 15
91234: PPUSH
91235: CALL_OW 12
91239: ARRAY
91240: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91241: LD_ADDR_VAR 0 4
91245: PUSH
91246: LD_INT 10
91248: PUSH
91249: LD_INT 20
91251: PUSH
91252: LD_INT 30
91254: PUSH
91255: LD_INT 40
91257: PUSH
91258: LD_INT 50
91260: PUSH
91261: LD_INT 60
91263: PUSH
91264: LD_INT 70
91266: PUSH
91267: LD_INT 80
91269: PUSH
91270: LD_INT 90
91272: PUSH
91273: LD_INT 100
91275: PUSH
91276: LD_INT 110
91278: PUSH
91279: LD_INT 120
91281: PUSH
91282: LD_INT 130
91284: PUSH
91285: LD_INT 140
91287: PUSH
91288: LD_INT 150
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: LIST
91295: LIST
91296: LIST
91297: LIST
91298: LIST
91299: LIST
91300: LIST
91301: LIST
91302: LIST
91303: LIST
91304: LIST
91305: LIST
91306: LIST
91307: PUSH
91308: LD_INT 1
91310: PPUSH
91311: LD_INT 15
91313: PPUSH
91314: CALL_OW 12
91318: ARRAY
91319: ST_TO_ADDR
// if ValidHex ( x , y ) then
91320: LD_VAR 0 3
91324: PPUSH
91325: LD_VAR 0 4
91329: PPUSH
91330: CALL_OW 488
91334: IFFALSE 91357
// begin result := [ x , y ] ;
91336: LD_ADDR_VAR 0 1
91340: PUSH
91341: LD_VAR 0 3
91345: PUSH
91346: LD_VAR 0 4
91350: PUSH
91351: EMPTY
91352: LIST
91353: LIST
91354: ST_TO_ADDR
// break ;
91355: GO 91359
// end ; end ;
91357: GO 91159
91359: POP
91360: POP
// if result then
91361: LD_VAR 0 1
91365: IFFALSE 91425
// begin ToLua ( playSibBomb() ) ;
91367: LD_STRING playSibBomb()
91369: PPUSH
91370: CALL_OW 559
// wait ( 0 0$14 ) ;
91374: LD_INT 490
91376: PPUSH
91377: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
91381: LD_VAR 0 1
91385: PUSH
91386: LD_INT 1
91388: ARRAY
91389: PPUSH
91390: LD_VAR 0 1
91394: PUSH
91395: LD_INT 2
91397: ARRAY
91398: PPUSH
91399: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
91403: LD_VAR 0 1
91407: PUSH
91408: LD_INT 1
91410: ARRAY
91411: PPUSH
91412: LD_VAR 0 1
91416: PUSH
91417: LD_INT 2
91419: ARRAY
91420: PPUSH
91421: CALL_OW 429
// end ; end ;
91425: LD_VAR 0 1
91429: RET
// every 0 0$1 trigger StreamModeActive and sReset do
91430: LD_EXP 109
91434: PUSH
91435: LD_EXP 131
91439: AND
91440: IFFALSE 91452
91442: GO 91444
91444: DISABLE
// YouLost (  ) ;
91445: LD_STRING 
91447: PPUSH
91448: CALL_OW 104
91452: END
// every 0 0$1 trigger StreamModeActive and sFog do
91453: LD_EXP 109
91457: PUSH
91458: LD_EXP 130
91462: AND
91463: IFFALSE 91477
91465: GO 91467
91467: DISABLE
// FogOff ( your_side ) ;
91468: LD_OWVAR 2
91472: PPUSH
91473: CALL_OW 344
91477: END
// every 0 0$1 trigger StreamModeActive and sSun do
91478: LD_EXP 109
91482: PUSH
91483: LD_EXP 132
91487: AND
91488: IFFALSE 91516
91490: GO 91492
91492: DISABLE
// begin solar_recharge_percent := 0 ;
91493: LD_ADDR_OWVAR 79
91497: PUSH
91498: LD_INT 0
91500: ST_TO_ADDR
// wait ( 5 5$00 ) ;
91501: LD_INT 10500
91503: PPUSH
91504: CALL_OW 67
// solar_recharge_percent := 100 ;
91508: LD_ADDR_OWVAR 79
91512: PUSH
91513: LD_INT 100
91515: ST_TO_ADDR
// end ;
91516: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
91517: LD_EXP 109
91521: PUSH
91522: LD_EXP 133
91526: AND
91527: IFFALSE 91766
91529: GO 91531
91531: DISABLE
91532: LD_INT 0
91534: PPUSH
91535: PPUSH
91536: PPUSH
// begin tmp := [ ] ;
91537: LD_ADDR_VAR 0 3
91541: PUSH
91542: EMPTY
91543: ST_TO_ADDR
// for i := 1 to 6 do
91544: LD_ADDR_VAR 0 1
91548: PUSH
91549: DOUBLE
91550: LD_INT 1
91552: DEC
91553: ST_TO_ADDR
91554: LD_INT 6
91556: PUSH
91557: FOR_TO
91558: IFFALSE 91663
// begin uc_nation := nation_nature ;
91560: LD_ADDR_OWVAR 21
91564: PUSH
91565: LD_INT 0
91567: ST_TO_ADDR
// uc_side := 0 ;
91568: LD_ADDR_OWVAR 20
91572: PUSH
91573: LD_INT 0
91575: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
91576: LD_ADDR_OWVAR 29
91580: PUSH
91581: LD_INT 12
91583: PUSH
91584: LD_INT 12
91586: PUSH
91587: EMPTY
91588: LIST
91589: LIST
91590: ST_TO_ADDR
// hc_agressivity := 20 ;
91591: LD_ADDR_OWVAR 35
91595: PUSH
91596: LD_INT 20
91598: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
91599: LD_ADDR_OWVAR 28
91603: PUSH
91604: LD_INT 17
91606: ST_TO_ADDR
// hc_gallery :=  ;
91607: LD_ADDR_OWVAR 33
91611: PUSH
91612: LD_STRING 
91614: ST_TO_ADDR
// hc_name :=  ;
91615: LD_ADDR_OWVAR 26
91619: PUSH
91620: LD_STRING 
91622: ST_TO_ADDR
// un := CreateHuman ;
91623: LD_ADDR_VAR 0 2
91627: PUSH
91628: CALL_OW 44
91632: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
91633: LD_VAR 0 2
91637: PPUSH
91638: LD_INT 1
91640: PPUSH
91641: CALL_OW 51
// tmp := tmp ^ un ;
91645: LD_ADDR_VAR 0 3
91649: PUSH
91650: LD_VAR 0 3
91654: PUSH
91655: LD_VAR 0 2
91659: ADD
91660: ST_TO_ADDR
// end ;
91661: GO 91557
91663: POP
91664: POP
// repeat wait ( 0 0$1 ) ;
91665: LD_INT 35
91667: PPUSH
91668: CALL_OW 67
// for un in tmp do
91672: LD_ADDR_VAR 0 2
91676: PUSH
91677: LD_VAR 0 3
91681: PUSH
91682: FOR_IN
91683: IFFALSE 91757
// begin if IsDead ( un ) then
91685: LD_VAR 0 2
91689: PPUSH
91690: CALL_OW 301
91694: IFFALSE 91714
// begin tmp := tmp diff un ;
91696: LD_ADDR_VAR 0 3
91700: PUSH
91701: LD_VAR 0 3
91705: PUSH
91706: LD_VAR 0 2
91710: DIFF
91711: ST_TO_ADDR
// continue ;
91712: GO 91682
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
91714: LD_VAR 0 2
91718: PPUSH
91719: LD_INT 3
91721: PUSH
91722: LD_INT 22
91724: PUSH
91725: LD_INT 0
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: PUSH
91732: EMPTY
91733: LIST
91734: LIST
91735: PPUSH
91736: CALL_OW 69
91740: PPUSH
91741: LD_VAR 0 2
91745: PPUSH
91746: CALL_OW 74
91750: PPUSH
91751: CALL_OW 115
// end ;
91755: GO 91682
91757: POP
91758: POP
// until not tmp ;
91759: LD_VAR 0 3
91763: NOT
91764: IFFALSE 91665
// end ;
91766: PPOPN 3
91768: END
// every 0 0$1 trigger StreamModeActive and sTroll do
91769: LD_EXP 109
91773: PUSH
91774: LD_EXP 134
91778: AND
91779: IFFALSE 91833
91781: GO 91783
91783: DISABLE
// begin ToLua ( displayTroll(); ) ;
91784: LD_STRING displayTroll();
91786: PPUSH
91787: CALL_OW 559
// wait ( 3 3$00 ) ;
91791: LD_INT 6300
91793: PPUSH
91794: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91798: LD_STRING hideTroll();
91800: PPUSH
91801: CALL_OW 559
// wait ( 1 1$00 ) ;
91805: LD_INT 2100
91807: PPUSH
91808: CALL_OW 67
// ToLua ( displayTroll(); ) ;
91812: LD_STRING displayTroll();
91814: PPUSH
91815: CALL_OW 559
// wait ( 1 1$00 ) ;
91819: LD_INT 2100
91821: PPUSH
91822: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91826: LD_STRING hideTroll();
91828: PPUSH
91829: CALL_OW 559
// end ;
91833: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
91834: LD_EXP 109
91838: PUSH
91839: LD_EXP 135
91843: AND
91844: IFFALSE 91907
91846: GO 91848
91848: DISABLE
91849: LD_INT 0
91851: PPUSH
// begin p := 0 ;
91852: LD_ADDR_VAR 0 1
91856: PUSH
91857: LD_INT 0
91859: ST_TO_ADDR
// repeat game_speed := 1 ;
91860: LD_ADDR_OWVAR 65
91864: PUSH
91865: LD_INT 1
91867: ST_TO_ADDR
// wait ( 0 0$1 ) ;
91868: LD_INT 35
91870: PPUSH
91871: CALL_OW 67
// p := p + 1 ;
91875: LD_ADDR_VAR 0 1
91879: PUSH
91880: LD_VAR 0 1
91884: PUSH
91885: LD_INT 1
91887: PLUS
91888: ST_TO_ADDR
// until p >= 60 ;
91889: LD_VAR 0 1
91893: PUSH
91894: LD_INT 60
91896: GREATEREQUAL
91897: IFFALSE 91860
// game_speed := 4 ;
91899: LD_ADDR_OWVAR 65
91903: PUSH
91904: LD_INT 4
91906: ST_TO_ADDR
// end ;
91907: PPOPN 1
91909: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
91910: LD_EXP 109
91914: PUSH
91915: LD_EXP 136
91919: AND
91920: IFFALSE 92066
91922: GO 91924
91924: DISABLE
91925: LD_INT 0
91927: PPUSH
91928: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91929: LD_ADDR_VAR 0 1
91933: PUSH
91934: LD_INT 22
91936: PUSH
91937: LD_OWVAR 2
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: PUSH
91946: LD_INT 2
91948: PUSH
91949: LD_INT 30
91951: PUSH
91952: LD_INT 0
91954: PUSH
91955: EMPTY
91956: LIST
91957: LIST
91958: PUSH
91959: LD_INT 30
91961: PUSH
91962: LD_INT 1
91964: PUSH
91965: EMPTY
91966: LIST
91967: LIST
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: LIST
91973: PUSH
91974: EMPTY
91975: LIST
91976: LIST
91977: PPUSH
91978: CALL_OW 69
91982: ST_TO_ADDR
// if not depot then
91983: LD_VAR 0 1
91987: NOT
91988: IFFALSE 91992
// exit ;
91990: GO 92066
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
91992: LD_ADDR_VAR 0 2
91996: PUSH
91997: LD_VAR 0 1
92001: PUSH
92002: LD_INT 1
92004: PPUSH
92005: LD_VAR 0 1
92009: PPUSH
92010: CALL_OW 12
92014: ARRAY
92015: PPUSH
92016: CALL_OW 274
92020: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
92021: LD_VAR 0 2
92025: PPUSH
92026: LD_INT 1
92028: PPUSH
92029: LD_INT 0
92031: PPUSH
92032: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
92036: LD_VAR 0 2
92040: PPUSH
92041: LD_INT 2
92043: PPUSH
92044: LD_INT 0
92046: PPUSH
92047: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
92051: LD_VAR 0 2
92055: PPUSH
92056: LD_INT 3
92058: PPUSH
92059: LD_INT 0
92061: PPUSH
92062: CALL_OW 277
// end ;
92066: PPOPN 2
92068: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
92069: LD_EXP 109
92073: PUSH
92074: LD_EXP 137
92078: AND
92079: IFFALSE 92176
92081: GO 92083
92083: DISABLE
92084: LD_INT 0
92086: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92087: LD_ADDR_VAR 0 1
92091: PUSH
92092: LD_INT 22
92094: PUSH
92095: LD_OWVAR 2
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: PUSH
92104: LD_INT 21
92106: PUSH
92107: LD_INT 1
92109: PUSH
92110: EMPTY
92111: LIST
92112: LIST
92113: PUSH
92114: LD_INT 3
92116: PUSH
92117: LD_INT 23
92119: PUSH
92120: LD_INT 0
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: EMPTY
92128: LIST
92129: LIST
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: LIST
92135: PPUSH
92136: CALL_OW 69
92140: ST_TO_ADDR
// if not tmp then
92141: LD_VAR 0 1
92145: NOT
92146: IFFALSE 92150
// exit ;
92148: GO 92176
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
92150: LD_VAR 0 1
92154: PUSH
92155: LD_INT 1
92157: PPUSH
92158: LD_VAR 0 1
92162: PPUSH
92163: CALL_OW 12
92167: ARRAY
92168: PPUSH
92169: LD_INT 200
92171: PPUSH
92172: CALL_OW 234
// end ;
92176: PPOPN 1
92178: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
92179: LD_EXP 109
92183: PUSH
92184: LD_EXP 138
92188: AND
92189: IFFALSE 92268
92191: GO 92193
92193: DISABLE
92194: LD_INT 0
92196: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
92197: LD_ADDR_VAR 0 1
92201: PUSH
92202: LD_INT 22
92204: PUSH
92205: LD_OWVAR 2
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: LD_INT 21
92216: PUSH
92217: LD_INT 2
92219: PUSH
92220: EMPTY
92221: LIST
92222: LIST
92223: PUSH
92224: EMPTY
92225: LIST
92226: LIST
92227: PPUSH
92228: CALL_OW 69
92232: ST_TO_ADDR
// if not tmp then
92233: LD_VAR 0 1
92237: NOT
92238: IFFALSE 92242
// exit ;
92240: GO 92268
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
92242: LD_VAR 0 1
92246: PUSH
92247: LD_INT 1
92249: PPUSH
92250: LD_VAR 0 1
92254: PPUSH
92255: CALL_OW 12
92259: ARRAY
92260: PPUSH
92261: LD_INT 60
92263: PPUSH
92264: CALL_OW 234
// end ;
92268: PPOPN 1
92270: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
92271: LD_EXP 109
92275: PUSH
92276: LD_EXP 139
92280: AND
92281: IFFALSE 92380
92283: GO 92285
92285: DISABLE
92286: LD_INT 0
92288: PPUSH
92289: PPUSH
// begin enable ;
92290: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
92291: LD_ADDR_VAR 0 1
92295: PUSH
92296: LD_INT 22
92298: PUSH
92299: LD_OWVAR 2
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: PUSH
92308: LD_INT 61
92310: PUSH
92311: EMPTY
92312: LIST
92313: PUSH
92314: LD_INT 33
92316: PUSH
92317: LD_INT 2
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PUSH
92324: EMPTY
92325: LIST
92326: LIST
92327: LIST
92328: PPUSH
92329: CALL_OW 69
92333: ST_TO_ADDR
// if not tmp then
92334: LD_VAR 0 1
92338: NOT
92339: IFFALSE 92343
// exit ;
92341: GO 92380
// for i in tmp do
92343: LD_ADDR_VAR 0 2
92347: PUSH
92348: LD_VAR 0 1
92352: PUSH
92353: FOR_IN
92354: IFFALSE 92378
// if IsControledBy ( i ) then
92356: LD_VAR 0 2
92360: PPUSH
92361: CALL_OW 312
92365: IFFALSE 92376
// ComUnlink ( i ) ;
92367: LD_VAR 0 2
92371: PPUSH
92372: CALL_OW 136
92376: GO 92353
92378: POP
92379: POP
// end ;
92380: PPOPN 2
92382: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
92383: LD_EXP 109
92387: PUSH
92388: LD_EXP 140
92392: AND
92393: IFFALSE 92533
92395: GO 92397
92397: DISABLE
92398: LD_INT 0
92400: PPUSH
92401: PPUSH
// begin ToLua ( displayPowell(); ) ;
92402: LD_STRING displayPowell();
92404: PPUSH
92405: CALL_OW 559
// uc_side := 0 ;
92409: LD_ADDR_OWVAR 20
92413: PUSH
92414: LD_INT 0
92416: ST_TO_ADDR
// uc_nation := 2 ;
92417: LD_ADDR_OWVAR 21
92421: PUSH
92422: LD_INT 2
92424: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
92425: LD_ADDR_OWVAR 37
92429: PUSH
92430: LD_INT 14
92432: ST_TO_ADDR
// vc_engine := engine_siberite ;
92433: LD_ADDR_OWVAR 39
92437: PUSH
92438: LD_INT 3
92440: ST_TO_ADDR
// vc_control := control_apeman ;
92441: LD_ADDR_OWVAR 38
92445: PUSH
92446: LD_INT 5
92448: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
92449: LD_ADDR_OWVAR 40
92453: PUSH
92454: LD_INT 29
92456: ST_TO_ADDR
// un := CreateVehicle ;
92457: LD_ADDR_VAR 0 2
92461: PUSH
92462: CALL_OW 45
92466: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92467: LD_VAR 0 2
92471: PPUSH
92472: LD_INT 1
92474: PPUSH
92475: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
92479: LD_INT 35
92481: PPUSH
92482: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
92486: LD_VAR 0 2
92490: PPUSH
92491: LD_INT 22
92493: PUSH
92494: LD_OWVAR 2
92498: PUSH
92499: EMPTY
92500: LIST
92501: LIST
92502: PPUSH
92503: CALL_OW 69
92507: PPUSH
92508: LD_VAR 0 2
92512: PPUSH
92513: CALL_OW 74
92517: PPUSH
92518: CALL_OW 115
// until IsDead ( un ) ;
92522: LD_VAR 0 2
92526: PPUSH
92527: CALL_OW 301
92531: IFFALSE 92479
// end ;
92533: PPOPN 2
92535: END
// every 0 0$1 trigger StreamModeActive and sStu do
92536: LD_EXP 109
92540: PUSH
92541: LD_EXP 148
92545: AND
92546: IFFALSE 92562
92548: GO 92550
92550: DISABLE
// begin ToLua ( displayStucuk(); ) ;
92551: LD_STRING displayStucuk();
92553: PPUSH
92554: CALL_OW 559
// ResetFog ;
92558: CALL_OW 335
// end ;
92562: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
92563: LD_EXP 109
92567: PUSH
92568: LD_EXP 141
92572: AND
92573: IFFALSE 92714
92575: GO 92577
92577: DISABLE
92578: LD_INT 0
92580: PPUSH
92581: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92582: LD_ADDR_VAR 0 2
92586: PUSH
92587: LD_INT 22
92589: PUSH
92590: LD_OWVAR 2
92594: PUSH
92595: EMPTY
92596: LIST
92597: LIST
92598: PUSH
92599: LD_INT 21
92601: PUSH
92602: LD_INT 1
92604: PUSH
92605: EMPTY
92606: LIST
92607: LIST
92608: PUSH
92609: EMPTY
92610: LIST
92611: LIST
92612: PPUSH
92613: CALL_OW 69
92617: ST_TO_ADDR
// if not tmp then
92618: LD_VAR 0 2
92622: NOT
92623: IFFALSE 92627
// exit ;
92625: GO 92714
// un := tmp [ rand ( 1 , tmp ) ] ;
92627: LD_ADDR_VAR 0 1
92631: PUSH
92632: LD_VAR 0 2
92636: PUSH
92637: LD_INT 1
92639: PPUSH
92640: LD_VAR 0 2
92644: PPUSH
92645: CALL_OW 12
92649: ARRAY
92650: ST_TO_ADDR
// SetSide ( un , 0 ) ;
92651: LD_VAR 0 1
92655: PPUSH
92656: LD_INT 0
92658: PPUSH
92659: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
92663: LD_VAR 0 1
92667: PPUSH
92668: LD_OWVAR 3
92672: PUSH
92673: LD_VAR 0 1
92677: DIFF
92678: PPUSH
92679: LD_VAR 0 1
92683: PPUSH
92684: CALL_OW 74
92688: PPUSH
92689: CALL_OW 115
// wait ( 0 0$20 ) ;
92693: LD_INT 700
92695: PPUSH
92696: CALL_OW 67
// SetSide ( un , your_side ) ;
92700: LD_VAR 0 1
92704: PPUSH
92705: LD_OWVAR 2
92709: PPUSH
92710: CALL_OW 235
// end ;
92714: PPOPN 2
92716: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
92717: LD_EXP 109
92721: PUSH
92722: LD_EXP 142
92726: AND
92727: IFFALSE 92833
92729: GO 92731
92731: DISABLE
92732: LD_INT 0
92734: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92735: LD_ADDR_VAR 0 1
92739: PUSH
92740: LD_INT 22
92742: PUSH
92743: LD_OWVAR 2
92747: PUSH
92748: EMPTY
92749: LIST
92750: LIST
92751: PUSH
92752: LD_INT 2
92754: PUSH
92755: LD_INT 30
92757: PUSH
92758: LD_INT 0
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: LD_INT 30
92767: PUSH
92768: LD_INT 1
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: PUSH
92775: EMPTY
92776: LIST
92777: LIST
92778: LIST
92779: PUSH
92780: EMPTY
92781: LIST
92782: LIST
92783: PPUSH
92784: CALL_OW 69
92788: ST_TO_ADDR
// if not depot then
92789: LD_VAR 0 1
92793: NOT
92794: IFFALSE 92798
// exit ;
92796: GO 92833
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
92798: LD_VAR 0 1
92802: PUSH
92803: LD_INT 1
92805: ARRAY
92806: PPUSH
92807: CALL_OW 250
92811: PPUSH
92812: LD_VAR 0 1
92816: PUSH
92817: LD_INT 1
92819: ARRAY
92820: PPUSH
92821: CALL_OW 251
92825: PPUSH
92826: LD_INT 70
92828: PPUSH
92829: CALL_OW 495
// end ;
92833: PPOPN 1
92835: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
92836: LD_EXP 109
92840: PUSH
92841: LD_EXP 143
92845: AND
92846: IFFALSE 93057
92848: GO 92850
92850: DISABLE
92851: LD_INT 0
92853: PPUSH
92854: PPUSH
92855: PPUSH
92856: PPUSH
92857: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92858: LD_ADDR_VAR 0 5
92862: PUSH
92863: LD_INT 22
92865: PUSH
92866: LD_OWVAR 2
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: PUSH
92875: LD_INT 21
92877: PUSH
92878: LD_INT 1
92880: PUSH
92881: EMPTY
92882: LIST
92883: LIST
92884: PUSH
92885: EMPTY
92886: LIST
92887: LIST
92888: PPUSH
92889: CALL_OW 69
92893: ST_TO_ADDR
// if not tmp then
92894: LD_VAR 0 5
92898: NOT
92899: IFFALSE 92903
// exit ;
92901: GO 93057
// for i in tmp do
92903: LD_ADDR_VAR 0 1
92907: PUSH
92908: LD_VAR 0 5
92912: PUSH
92913: FOR_IN
92914: IFFALSE 93055
// begin d := rand ( 0 , 5 ) ;
92916: LD_ADDR_VAR 0 4
92920: PUSH
92921: LD_INT 0
92923: PPUSH
92924: LD_INT 5
92926: PPUSH
92927: CALL_OW 12
92931: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
92932: LD_ADDR_VAR 0 2
92936: PUSH
92937: LD_VAR 0 1
92941: PPUSH
92942: CALL_OW 250
92946: PPUSH
92947: LD_VAR 0 4
92951: PPUSH
92952: LD_INT 3
92954: PPUSH
92955: LD_INT 12
92957: PPUSH
92958: CALL_OW 12
92962: PPUSH
92963: CALL_OW 272
92967: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
92968: LD_ADDR_VAR 0 3
92972: PUSH
92973: LD_VAR 0 1
92977: PPUSH
92978: CALL_OW 251
92982: PPUSH
92983: LD_VAR 0 4
92987: PPUSH
92988: LD_INT 3
92990: PPUSH
92991: LD_INT 12
92993: PPUSH
92994: CALL_OW 12
92998: PPUSH
92999: CALL_OW 273
93003: ST_TO_ADDR
// if ValidHex ( x , y ) then
93004: LD_VAR 0 2
93008: PPUSH
93009: LD_VAR 0 3
93013: PPUSH
93014: CALL_OW 488
93018: IFFALSE 93053
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
93020: LD_VAR 0 1
93024: PPUSH
93025: LD_VAR 0 2
93029: PPUSH
93030: LD_VAR 0 3
93034: PPUSH
93035: LD_INT 3
93037: PPUSH
93038: LD_INT 6
93040: PPUSH
93041: CALL_OW 12
93045: PPUSH
93046: LD_INT 1
93048: PPUSH
93049: CALL_OW 483
// end ;
93053: GO 92913
93055: POP
93056: POP
// end ;
93057: PPOPN 5
93059: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
93060: LD_EXP 109
93064: PUSH
93065: LD_EXP 144
93069: AND
93070: IFFALSE 93164
93072: GO 93074
93074: DISABLE
93075: LD_INT 0
93077: PPUSH
93078: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
93079: LD_ADDR_VAR 0 2
93083: PUSH
93084: LD_INT 22
93086: PUSH
93087: LD_OWVAR 2
93091: PUSH
93092: EMPTY
93093: LIST
93094: LIST
93095: PUSH
93096: LD_INT 32
93098: PUSH
93099: LD_INT 1
93101: PUSH
93102: EMPTY
93103: LIST
93104: LIST
93105: PUSH
93106: LD_INT 21
93108: PUSH
93109: LD_INT 2
93111: PUSH
93112: EMPTY
93113: LIST
93114: LIST
93115: PUSH
93116: EMPTY
93117: LIST
93118: LIST
93119: LIST
93120: PPUSH
93121: CALL_OW 69
93125: ST_TO_ADDR
// if not tmp then
93126: LD_VAR 0 2
93130: NOT
93131: IFFALSE 93135
// exit ;
93133: GO 93164
// for i in tmp do
93135: LD_ADDR_VAR 0 1
93139: PUSH
93140: LD_VAR 0 2
93144: PUSH
93145: FOR_IN
93146: IFFALSE 93162
// SetFuel ( i , 0 ) ;
93148: LD_VAR 0 1
93152: PPUSH
93153: LD_INT 0
93155: PPUSH
93156: CALL_OW 240
93160: GO 93145
93162: POP
93163: POP
// end ;
93164: PPOPN 2
93166: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
93167: LD_EXP 109
93171: PUSH
93172: LD_EXP 145
93176: AND
93177: IFFALSE 93243
93179: GO 93181
93181: DISABLE
93182: LD_INT 0
93184: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93185: LD_ADDR_VAR 0 1
93189: PUSH
93190: LD_INT 22
93192: PUSH
93193: LD_OWVAR 2
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: PUSH
93202: LD_INT 30
93204: PUSH
93205: LD_INT 29
93207: PUSH
93208: EMPTY
93209: LIST
93210: LIST
93211: PUSH
93212: EMPTY
93213: LIST
93214: LIST
93215: PPUSH
93216: CALL_OW 69
93220: ST_TO_ADDR
// if not tmp then
93221: LD_VAR 0 1
93225: NOT
93226: IFFALSE 93230
// exit ;
93228: GO 93243
// DestroyUnit ( tmp [ 1 ] ) ;
93230: LD_VAR 0 1
93234: PUSH
93235: LD_INT 1
93237: ARRAY
93238: PPUSH
93239: CALL_OW 65
// end ;
93243: PPOPN 1
93245: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
93246: LD_EXP 109
93250: PUSH
93251: LD_EXP 147
93255: AND
93256: IFFALSE 93385
93258: GO 93260
93260: DISABLE
93261: LD_INT 0
93263: PPUSH
// begin uc_side := 0 ;
93264: LD_ADDR_OWVAR 20
93268: PUSH
93269: LD_INT 0
93271: ST_TO_ADDR
// uc_nation := nation_arabian ;
93272: LD_ADDR_OWVAR 21
93276: PUSH
93277: LD_INT 2
93279: ST_TO_ADDR
// hc_gallery :=  ;
93280: LD_ADDR_OWVAR 33
93284: PUSH
93285: LD_STRING 
93287: ST_TO_ADDR
// hc_name :=  ;
93288: LD_ADDR_OWVAR 26
93292: PUSH
93293: LD_STRING 
93295: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
93296: LD_INT 1
93298: PPUSH
93299: LD_INT 11
93301: PPUSH
93302: LD_INT 10
93304: PPUSH
93305: CALL_OW 380
// un := CreateHuman ;
93309: LD_ADDR_VAR 0 1
93313: PUSH
93314: CALL_OW 44
93318: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93319: LD_VAR 0 1
93323: PPUSH
93324: LD_INT 1
93326: PPUSH
93327: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
93331: LD_INT 35
93333: PPUSH
93334: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
93338: LD_VAR 0 1
93342: PPUSH
93343: LD_INT 22
93345: PUSH
93346: LD_OWVAR 2
93350: PUSH
93351: EMPTY
93352: LIST
93353: LIST
93354: PPUSH
93355: CALL_OW 69
93359: PPUSH
93360: LD_VAR 0 1
93364: PPUSH
93365: CALL_OW 74
93369: PPUSH
93370: CALL_OW 115
// until IsDead ( un ) ;
93374: LD_VAR 0 1
93378: PPUSH
93379: CALL_OW 301
93383: IFFALSE 93331
// end ;
93385: PPOPN 1
93387: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
93388: LD_EXP 109
93392: PUSH
93393: LD_EXP 149
93397: AND
93398: IFFALSE 93410
93400: GO 93402
93402: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
93403: LD_STRING earthquake(getX(game), 0, 32)
93405: PPUSH
93406: CALL_OW 559
93410: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
93411: LD_EXP 109
93415: PUSH
93416: LD_EXP 150
93420: AND
93421: IFFALSE 93512
93423: GO 93425
93425: DISABLE
93426: LD_INT 0
93428: PPUSH
// begin enable ;
93429: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
93430: LD_ADDR_VAR 0 1
93434: PUSH
93435: LD_INT 22
93437: PUSH
93438: LD_OWVAR 2
93442: PUSH
93443: EMPTY
93444: LIST
93445: LIST
93446: PUSH
93447: LD_INT 21
93449: PUSH
93450: LD_INT 2
93452: PUSH
93453: EMPTY
93454: LIST
93455: LIST
93456: PUSH
93457: LD_INT 33
93459: PUSH
93460: LD_INT 3
93462: PUSH
93463: EMPTY
93464: LIST
93465: LIST
93466: PUSH
93467: EMPTY
93468: LIST
93469: LIST
93470: LIST
93471: PPUSH
93472: CALL_OW 69
93476: ST_TO_ADDR
// if not tmp then
93477: LD_VAR 0 1
93481: NOT
93482: IFFALSE 93486
// exit ;
93484: GO 93512
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
93486: LD_VAR 0 1
93490: PUSH
93491: LD_INT 1
93493: PPUSH
93494: LD_VAR 0 1
93498: PPUSH
93499: CALL_OW 12
93503: ARRAY
93504: PPUSH
93505: LD_INT 1
93507: PPUSH
93508: CALL_OW 234
// end ;
93512: PPOPN 1
93514: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
93515: LD_EXP 109
93519: PUSH
93520: LD_EXP 151
93524: AND
93525: IFFALSE 93666
93527: GO 93529
93529: DISABLE
93530: LD_INT 0
93532: PPUSH
93533: PPUSH
93534: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93535: LD_ADDR_VAR 0 3
93539: PUSH
93540: LD_INT 22
93542: PUSH
93543: LD_OWVAR 2
93547: PUSH
93548: EMPTY
93549: LIST
93550: LIST
93551: PUSH
93552: LD_INT 25
93554: PUSH
93555: LD_INT 1
93557: PUSH
93558: EMPTY
93559: LIST
93560: LIST
93561: PUSH
93562: EMPTY
93563: LIST
93564: LIST
93565: PPUSH
93566: CALL_OW 69
93570: ST_TO_ADDR
// if not tmp then
93571: LD_VAR 0 3
93575: NOT
93576: IFFALSE 93580
// exit ;
93578: GO 93666
// un := tmp [ rand ( 1 , tmp ) ] ;
93580: LD_ADDR_VAR 0 2
93584: PUSH
93585: LD_VAR 0 3
93589: PUSH
93590: LD_INT 1
93592: PPUSH
93593: LD_VAR 0 3
93597: PPUSH
93598: CALL_OW 12
93602: ARRAY
93603: ST_TO_ADDR
// if Crawls ( un ) then
93604: LD_VAR 0 2
93608: PPUSH
93609: CALL_OW 318
93613: IFFALSE 93624
// ComWalk ( un ) ;
93615: LD_VAR 0 2
93619: PPUSH
93620: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
93624: LD_VAR 0 2
93628: PPUSH
93629: LD_INT 9
93631: PPUSH
93632: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
93636: LD_INT 28
93638: PPUSH
93639: LD_OWVAR 2
93643: PPUSH
93644: LD_INT 2
93646: PPUSH
93647: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
93651: LD_INT 29
93653: PPUSH
93654: LD_OWVAR 2
93658: PPUSH
93659: LD_INT 2
93661: PPUSH
93662: CALL_OW 322
// end ;
93666: PPOPN 3
93668: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
93669: LD_EXP 109
93673: PUSH
93674: LD_EXP 152
93678: AND
93679: IFFALSE 93790
93681: GO 93683
93683: DISABLE
93684: LD_INT 0
93686: PPUSH
93687: PPUSH
93688: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93689: LD_ADDR_VAR 0 3
93693: PUSH
93694: LD_INT 22
93696: PUSH
93697: LD_OWVAR 2
93701: PUSH
93702: EMPTY
93703: LIST
93704: LIST
93705: PUSH
93706: LD_INT 25
93708: PUSH
93709: LD_INT 1
93711: PUSH
93712: EMPTY
93713: LIST
93714: LIST
93715: PUSH
93716: EMPTY
93717: LIST
93718: LIST
93719: PPUSH
93720: CALL_OW 69
93724: ST_TO_ADDR
// if not tmp then
93725: LD_VAR 0 3
93729: NOT
93730: IFFALSE 93734
// exit ;
93732: GO 93790
// un := tmp [ rand ( 1 , tmp ) ] ;
93734: LD_ADDR_VAR 0 2
93738: PUSH
93739: LD_VAR 0 3
93743: PUSH
93744: LD_INT 1
93746: PPUSH
93747: LD_VAR 0 3
93751: PPUSH
93752: CALL_OW 12
93756: ARRAY
93757: ST_TO_ADDR
// if Crawls ( un ) then
93758: LD_VAR 0 2
93762: PPUSH
93763: CALL_OW 318
93767: IFFALSE 93778
// ComWalk ( un ) ;
93769: LD_VAR 0 2
93773: PPUSH
93774: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93778: LD_VAR 0 2
93782: PPUSH
93783: LD_INT 8
93785: PPUSH
93786: CALL_OW 336
// end ;
93790: PPOPN 3
93792: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
93793: LD_EXP 109
93797: PUSH
93798: LD_EXP 153
93802: AND
93803: IFFALSE 93947
93805: GO 93807
93807: DISABLE
93808: LD_INT 0
93810: PPUSH
93811: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
93812: LD_ADDR_VAR 0 2
93816: PUSH
93817: LD_INT 22
93819: PUSH
93820: LD_OWVAR 2
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: PUSH
93829: LD_INT 21
93831: PUSH
93832: LD_INT 2
93834: PUSH
93835: EMPTY
93836: LIST
93837: LIST
93838: PUSH
93839: LD_INT 2
93841: PUSH
93842: LD_INT 34
93844: PUSH
93845: LD_INT 12
93847: PUSH
93848: EMPTY
93849: LIST
93850: LIST
93851: PUSH
93852: LD_INT 34
93854: PUSH
93855: LD_INT 51
93857: PUSH
93858: EMPTY
93859: LIST
93860: LIST
93861: PUSH
93862: LD_INT 34
93864: PUSH
93865: LD_INT 32
93867: PUSH
93868: EMPTY
93869: LIST
93870: LIST
93871: PUSH
93872: EMPTY
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: LIST
93882: PPUSH
93883: CALL_OW 69
93887: ST_TO_ADDR
// if not tmp then
93888: LD_VAR 0 2
93892: NOT
93893: IFFALSE 93897
// exit ;
93895: GO 93947
// for i in tmp do
93897: LD_ADDR_VAR 0 1
93901: PUSH
93902: LD_VAR 0 2
93906: PUSH
93907: FOR_IN
93908: IFFALSE 93945
// if GetCargo ( i , mat_artifact ) = 0 then
93910: LD_VAR 0 1
93914: PPUSH
93915: LD_INT 4
93917: PPUSH
93918: CALL_OW 289
93922: PUSH
93923: LD_INT 0
93925: EQUAL
93926: IFFALSE 93943
// SetCargo ( i , mat_siberit , 100 ) ;
93928: LD_VAR 0 1
93932: PPUSH
93933: LD_INT 3
93935: PPUSH
93936: LD_INT 100
93938: PPUSH
93939: CALL_OW 290
93943: GO 93907
93945: POP
93946: POP
// end ;
93947: PPOPN 2
93949: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
93950: LD_EXP 109
93954: PUSH
93955: LD_EXP 154
93959: AND
93960: IFFALSE 94143
93962: GO 93964
93964: DISABLE
93965: LD_INT 0
93967: PPUSH
93968: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
93969: LD_ADDR_VAR 0 2
93973: PUSH
93974: LD_INT 22
93976: PUSH
93977: LD_OWVAR 2
93981: PUSH
93982: EMPTY
93983: LIST
93984: LIST
93985: PPUSH
93986: CALL_OW 69
93990: ST_TO_ADDR
// if not tmp then
93991: LD_VAR 0 2
93995: NOT
93996: IFFALSE 94000
// exit ;
93998: GO 94143
// for i := 1 to 2 do
94000: LD_ADDR_VAR 0 1
94004: PUSH
94005: DOUBLE
94006: LD_INT 1
94008: DEC
94009: ST_TO_ADDR
94010: LD_INT 2
94012: PUSH
94013: FOR_TO
94014: IFFALSE 94141
// begin uc_side := your_side ;
94016: LD_ADDR_OWVAR 20
94020: PUSH
94021: LD_OWVAR 2
94025: ST_TO_ADDR
// uc_nation := nation_american ;
94026: LD_ADDR_OWVAR 21
94030: PUSH
94031: LD_INT 1
94033: ST_TO_ADDR
// vc_chassis := us_morphling ;
94034: LD_ADDR_OWVAR 37
94038: PUSH
94039: LD_INT 5
94041: ST_TO_ADDR
// vc_engine := engine_siberite ;
94042: LD_ADDR_OWVAR 39
94046: PUSH
94047: LD_INT 3
94049: ST_TO_ADDR
// vc_control := control_computer ;
94050: LD_ADDR_OWVAR 38
94054: PUSH
94055: LD_INT 3
94057: ST_TO_ADDR
// vc_weapon := us_double_laser ;
94058: LD_ADDR_OWVAR 40
94062: PUSH
94063: LD_INT 10
94065: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
94066: LD_VAR 0 2
94070: PUSH
94071: LD_INT 1
94073: ARRAY
94074: PPUSH
94075: CALL_OW 310
94079: NOT
94080: IFFALSE 94127
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
94082: CALL_OW 45
94086: PPUSH
94087: LD_VAR 0 2
94091: PUSH
94092: LD_INT 1
94094: ARRAY
94095: PPUSH
94096: CALL_OW 250
94100: PPUSH
94101: LD_VAR 0 2
94105: PUSH
94106: LD_INT 1
94108: ARRAY
94109: PPUSH
94110: CALL_OW 251
94114: PPUSH
94115: LD_INT 12
94117: PPUSH
94118: LD_INT 1
94120: PPUSH
94121: CALL_OW 50
94125: GO 94139
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
94127: CALL_OW 45
94131: PPUSH
94132: LD_INT 1
94134: PPUSH
94135: CALL_OW 51
// end ;
94139: GO 94013
94141: POP
94142: POP
// end ;
94143: PPOPN 2
94145: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
94146: LD_EXP 109
94150: PUSH
94151: LD_EXP 155
94155: AND
94156: IFFALSE 94378
94158: GO 94160
94160: DISABLE
94161: LD_INT 0
94163: PPUSH
94164: PPUSH
94165: PPUSH
94166: PPUSH
94167: PPUSH
94168: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94169: LD_ADDR_VAR 0 6
94173: PUSH
94174: LD_INT 22
94176: PUSH
94177: LD_OWVAR 2
94181: PUSH
94182: EMPTY
94183: LIST
94184: LIST
94185: PUSH
94186: LD_INT 21
94188: PUSH
94189: LD_INT 1
94191: PUSH
94192: EMPTY
94193: LIST
94194: LIST
94195: PUSH
94196: LD_INT 3
94198: PUSH
94199: LD_INT 23
94201: PUSH
94202: LD_INT 0
94204: PUSH
94205: EMPTY
94206: LIST
94207: LIST
94208: PUSH
94209: EMPTY
94210: LIST
94211: LIST
94212: PUSH
94213: EMPTY
94214: LIST
94215: LIST
94216: LIST
94217: PPUSH
94218: CALL_OW 69
94222: ST_TO_ADDR
// if not tmp then
94223: LD_VAR 0 6
94227: NOT
94228: IFFALSE 94232
// exit ;
94230: GO 94378
// s1 := rand ( 1 , 4 ) ;
94232: LD_ADDR_VAR 0 2
94236: PUSH
94237: LD_INT 1
94239: PPUSH
94240: LD_INT 4
94242: PPUSH
94243: CALL_OW 12
94247: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
94248: LD_ADDR_VAR 0 4
94252: PUSH
94253: LD_VAR 0 6
94257: PUSH
94258: LD_INT 1
94260: ARRAY
94261: PPUSH
94262: LD_VAR 0 2
94266: PPUSH
94267: CALL_OW 259
94271: ST_TO_ADDR
// if s1 = 1 then
94272: LD_VAR 0 2
94276: PUSH
94277: LD_INT 1
94279: EQUAL
94280: IFFALSE 94300
// s2 := rand ( 2 , 4 ) else
94282: LD_ADDR_VAR 0 3
94286: PUSH
94287: LD_INT 2
94289: PPUSH
94290: LD_INT 4
94292: PPUSH
94293: CALL_OW 12
94297: ST_TO_ADDR
94298: GO 94308
// s2 := 1 ;
94300: LD_ADDR_VAR 0 3
94304: PUSH
94305: LD_INT 1
94307: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
94308: LD_ADDR_VAR 0 5
94312: PUSH
94313: LD_VAR 0 6
94317: PUSH
94318: LD_INT 1
94320: ARRAY
94321: PPUSH
94322: LD_VAR 0 3
94326: PPUSH
94327: CALL_OW 259
94331: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
94332: LD_VAR 0 6
94336: PUSH
94337: LD_INT 1
94339: ARRAY
94340: PPUSH
94341: LD_VAR 0 2
94345: PPUSH
94346: LD_VAR 0 5
94350: PPUSH
94351: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
94355: LD_VAR 0 6
94359: PUSH
94360: LD_INT 1
94362: ARRAY
94363: PPUSH
94364: LD_VAR 0 3
94368: PPUSH
94369: LD_VAR 0 4
94373: PPUSH
94374: CALL_OW 237
// end ;
94378: PPOPN 6
94380: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
94381: LD_EXP 109
94385: PUSH
94386: LD_EXP 156
94390: AND
94391: IFFALSE 94470
94393: GO 94395
94395: DISABLE
94396: LD_INT 0
94398: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
94399: LD_ADDR_VAR 0 1
94403: PUSH
94404: LD_INT 22
94406: PUSH
94407: LD_OWVAR 2
94411: PUSH
94412: EMPTY
94413: LIST
94414: LIST
94415: PUSH
94416: LD_INT 30
94418: PUSH
94419: LD_INT 3
94421: PUSH
94422: EMPTY
94423: LIST
94424: LIST
94425: PUSH
94426: EMPTY
94427: LIST
94428: LIST
94429: PPUSH
94430: CALL_OW 69
94434: ST_TO_ADDR
// if not tmp then
94435: LD_VAR 0 1
94439: NOT
94440: IFFALSE 94444
// exit ;
94442: GO 94470
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94444: LD_VAR 0 1
94448: PUSH
94449: LD_INT 1
94451: PPUSH
94452: LD_VAR 0 1
94456: PPUSH
94457: CALL_OW 12
94461: ARRAY
94462: PPUSH
94463: LD_INT 1
94465: PPUSH
94466: CALL_OW 234
// end ;
94470: PPOPN 1
94472: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
94473: LD_EXP 109
94477: PUSH
94478: LD_EXP 157
94482: AND
94483: IFFALSE 94595
94485: GO 94487
94487: DISABLE
94488: LD_INT 0
94490: PPUSH
94491: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
94492: LD_ADDR_VAR 0 2
94496: PUSH
94497: LD_INT 22
94499: PUSH
94500: LD_OWVAR 2
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: PUSH
94509: LD_INT 2
94511: PUSH
94512: LD_INT 30
94514: PUSH
94515: LD_INT 27
94517: PUSH
94518: EMPTY
94519: LIST
94520: LIST
94521: PUSH
94522: LD_INT 30
94524: PUSH
94525: LD_INT 26
94527: PUSH
94528: EMPTY
94529: LIST
94530: LIST
94531: PUSH
94532: LD_INT 30
94534: PUSH
94535: LD_INT 28
94537: PUSH
94538: EMPTY
94539: LIST
94540: LIST
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: PPUSH
94552: CALL_OW 69
94556: ST_TO_ADDR
// if not tmp then
94557: LD_VAR 0 2
94561: NOT
94562: IFFALSE 94566
// exit ;
94564: GO 94595
// for i in tmp do
94566: LD_ADDR_VAR 0 1
94570: PUSH
94571: LD_VAR 0 2
94575: PUSH
94576: FOR_IN
94577: IFFALSE 94593
// SetLives ( i , 1 ) ;
94579: LD_VAR 0 1
94583: PPUSH
94584: LD_INT 1
94586: PPUSH
94587: CALL_OW 234
94591: GO 94576
94593: POP
94594: POP
// end ;
94595: PPOPN 2
94597: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
94598: LD_EXP 109
94602: PUSH
94603: LD_EXP 158
94607: AND
94608: IFFALSE 94882
94610: GO 94612
94612: DISABLE
94613: LD_INT 0
94615: PPUSH
94616: PPUSH
94617: PPUSH
// begin i := rand ( 1 , 7 ) ;
94618: LD_ADDR_VAR 0 1
94622: PUSH
94623: LD_INT 1
94625: PPUSH
94626: LD_INT 7
94628: PPUSH
94629: CALL_OW 12
94633: ST_TO_ADDR
// case i of 1 :
94634: LD_VAR 0 1
94638: PUSH
94639: LD_INT 1
94641: DOUBLE
94642: EQUAL
94643: IFTRUE 94647
94645: GO 94657
94647: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
94648: LD_STRING earthquake(getX(game), 0, 32)
94650: PPUSH
94651: CALL_OW 559
94655: GO 94882
94657: LD_INT 2
94659: DOUBLE
94660: EQUAL
94661: IFTRUE 94665
94663: GO 94679
94665: POP
// begin ToLua ( displayStucuk(); ) ;
94666: LD_STRING displayStucuk();
94668: PPUSH
94669: CALL_OW 559
// ResetFog ;
94673: CALL_OW 335
// end ; 3 :
94677: GO 94882
94679: LD_INT 3
94681: DOUBLE
94682: EQUAL
94683: IFTRUE 94687
94685: GO 94791
94687: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94688: LD_ADDR_VAR 0 2
94692: PUSH
94693: LD_INT 22
94695: PUSH
94696: LD_OWVAR 2
94700: PUSH
94701: EMPTY
94702: LIST
94703: LIST
94704: PUSH
94705: LD_INT 25
94707: PUSH
94708: LD_INT 1
94710: PUSH
94711: EMPTY
94712: LIST
94713: LIST
94714: PUSH
94715: EMPTY
94716: LIST
94717: LIST
94718: PPUSH
94719: CALL_OW 69
94723: ST_TO_ADDR
// if not tmp then
94724: LD_VAR 0 2
94728: NOT
94729: IFFALSE 94733
// exit ;
94731: GO 94882
// un := tmp [ rand ( 1 , tmp ) ] ;
94733: LD_ADDR_VAR 0 3
94737: PUSH
94738: LD_VAR 0 2
94742: PUSH
94743: LD_INT 1
94745: PPUSH
94746: LD_VAR 0 2
94750: PPUSH
94751: CALL_OW 12
94755: ARRAY
94756: ST_TO_ADDR
// if Crawls ( un ) then
94757: LD_VAR 0 3
94761: PPUSH
94762: CALL_OW 318
94766: IFFALSE 94777
// ComWalk ( un ) ;
94768: LD_VAR 0 3
94772: PPUSH
94773: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94777: LD_VAR 0 3
94781: PPUSH
94782: LD_INT 8
94784: PPUSH
94785: CALL_OW 336
// end ; 4 :
94789: GO 94882
94791: LD_INT 4
94793: DOUBLE
94794: EQUAL
94795: IFTRUE 94799
94797: GO 94860
94799: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
94800: LD_ADDR_VAR 0 2
94804: PUSH
94805: LD_INT 22
94807: PUSH
94808: LD_OWVAR 2
94812: PUSH
94813: EMPTY
94814: LIST
94815: LIST
94816: PUSH
94817: LD_INT 30
94819: PUSH
94820: LD_INT 29
94822: PUSH
94823: EMPTY
94824: LIST
94825: LIST
94826: PUSH
94827: EMPTY
94828: LIST
94829: LIST
94830: PPUSH
94831: CALL_OW 69
94835: ST_TO_ADDR
// if not tmp then
94836: LD_VAR 0 2
94840: NOT
94841: IFFALSE 94845
// exit ;
94843: GO 94882
// DestroyUnit ( tmp [ 1 ] ) ;
94845: LD_VAR 0 2
94849: PUSH
94850: LD_INT 1
94852: ARRAY
94853: PPUSH
94854: CALL_OW 65
// end ; 5 .. 7 :
94858: GO 94882
94860: LD_INT 5
94862: DOUBLE
94863: GREATEREQUAL
94864: IFFALSE 94872
94866: LD_INT 7
94868: DOUBLE
94869: LESSEQUAL
94870: IFTRUE 94874
94872: GO 94881
94874: POP
// StreamSibBomb ; end ;
94875: CALL 91132 0 0
94879: GO 94882
94881: POP
// end ;
94882: PPOPN 3
94884: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
94885: LD_EXP 109
94889: PUSH
94890: LD_EXP 159
94894: AND
94895: IFFALSE 95051
94897: GO 94899
94899: DISABLE
94900: LD_INT 0
94902: PPUSH
94903: PPUSH
94904: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
94905: LD_ADDR_VAR 0 2
94909: PUSH
94910: LD_INT 81
94912: PUSH
94913: LD_OWVAR 2
94917: PUSH
94918: EMPTY
94919: LIST
94920: LIST
94921: PUSH
94922: LD_INT 2
94924: PUSH
94925: LD_INT 21
94927: PUSH
94928: LD_INT 1
94930: PUSH
94931: EMPTY
94932: LIST
94933: LIST
94934: PUSH
94935: LD_INT 21
94937: PUSH
94938: LD_INT 2
94940: PUSH
94941: EMPTY
94942: LIST
94943: LIST
94944: PUSH
94945: EMPTY
94946: LIST
94947: LIST
94948: LIST
94949: PUSH
94950: EMPTY
94951: LIST
94952: LIST
94953: PPUSH
94954: CALL_OW 69
94958: ST_TO_ADDR
// if not tmp then
94959: LD_VAR 0 2
94963: NOT
94964: IFFALSE 94968
// exit ;
94966: GO 95051
// p := 0 ;
94968: LD_ADDR_VAR 0 3
94972: PUSH
94973: LD_INT 0
94975: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
94976: LD_INT 35
94978: PPUSH
94979: CALL_OW 67
// p := p + 1 ;
94983: LD_ADDR_VAR 0 3
94987: PUSH
94988: LD_VAR 0 3
94992: PUSH
94993: LD_INT 1
94995: PLUS
94996: ST_TO_ADDR
// for i in tmp do
94997: LD_ADDR_VAR 0 1
95001: PUSH
95002: LD_VAR 0 2
95006: PUSH
95007: FOR_IN
95008: IFFALSE 95039
// if GetLives ( i ) < 1000 then
95010: LD_VAR 0 1
95014: PPUSH
95015: CALL_OW 256
95019: PUSH
95020: LD_INT 1000
95022: LESS
95023: IFFALSE 95037
// SetLives ( i , 1000 ) ;
95025: LD_VAR 0 1
95029: PPUSH
95030: LD_INT 1000
95032: PPUSH
95033: CALL_OW 234
95037: GO 95007
95039: POP
95040: POP
// until p > 20 ;
95041: LD_VAR 0 3
95045: PUSH
95046: LD_INT 20
95048: GREATER
95049: IFFALSE 94976
// end ;
95051: PPOPN 3
95053: END
// every 0 0$1 trigger StreamModeActive and sTime do
95054: LD_EXP 109
95058: PUSH
95059: LD_EXP 160
95063: AND
95064: IFFALSE 95099
95066: GO 95068
95068: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
95069: LD_INT 28
95071: PPUSH
95072: LD_OWVAR 2
95076: PPUSH
95077: LD_INT 2
95079: PPUSH
95080: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
95084: LD_INT 30
95086: PPUSH
95087: LD_OWVAR 2
95091: PPUSH
95092: LD_INT 2
95094: PPUSH
95095: CALL_OW 322
// end ;
95099: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
95100: LD_EXP 109
95104: PUSH
95105: LD_EXP 161
95109: AND
95110: IFFALSE 95231
95112: GO 95114
95114: DISABLE
95115: LD_INT 0
95117: PPUSH
95118: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95119: LD_ADDR_VAR 0 2
95123: PUSH
95124: LD_INT 22
95126: PUSH
95127: LD_OWVAR 2
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: PUSH
95136: LD_INT 21
95138: PUSH
95139: LD_INT 1
95141: PUSH
95142: EMPTY
95143: LIST
95144: LIST
95145: PUSH
95146: LD_INT 3
95148: PUSH
95149: LD_INT 23
95151: PUSH
95152: LD_INT 0
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: PUSH
95159: EMPTY
95160: LIST
95161: LIST
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: LIST
95167: PPUSH
95168: CALL_OW 69
95172: ST_TO_ADDR
// if not tmp then
95173: LD_VAR 0 2
95177: NOT
95178: IFFALSE 95182
// exit ;
95180: GO 95231
// for i in tmp do
95182: LD_ADDR_VAR 0 1
95186: PUSH
95187: LD_VAR 0 2
95191: PUSH
95192: FOR_IN
95193: IFFALSE 95229
// begin if Crawls ( i ) then
95195: LD_VAR 0 1
95199: PPUSH
95200: CALL_OW 318
95204: IFFALSE 95215
// ComWalk ( i ) ;
95206: LD_VAR 0 1
95210: PPUSH
95211: CALL_OW 138
// SetClass ( i , 2 ) ;
95215: LD_VAR 0 1
95219: PPUSH
95220: LD_INT 2
95222: PPUSH
95223: CALL_OW 336
// end ;
95227: GO 95192
95229: POP
95230: POP
// end ;
95231: PPOPN 2
95233: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
95234: LD_EXP 109
95238: PUSH
95239: LD_EXP 162
95243: AND
95244: IFFALSE 95525
95246: GO 95248
95248: DISABLE
95249: LD_INT 0
95251: PPUSH
95252: PPUSH
95253: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
95254: LD_OWVAR 2
95258: PPUSH
95259: LD_INT 9
95261: PPUSH
95262: LD_INT 1
95264: PPUSH
95265: LD_INT 1
95267: PPUSH
95268: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
95272: LD_INT 9
95274: PPUSH
95275: LD_OWVAR 2
95279: PPUSH
95280: CALL_OW 343
// uc_side := 9 ;
95284: LD_ADDR_OWVAR 20
95288: PUSH
95289: LD_INT 9
95291: ST_TO_ADDR
// uc_nation := 2 ;
95292: LD_ADDR_OWVAR 21
95296: PUSH
95297: LD_INT 2
95299: ST_TO_ADDR
// hc_name := Dark Warrior ;
95300: LD_ADDR_OWVAR 26
95304: PUSH
95305: LD_STRING Dark Warrior
95307: ST_TO_ADDR
// hc_gallery :=  ;
95308: LD_ADDR_OWVAR 33
95312: PUSH
95313: LD_STRING 
95315: ST_TO_ADDR
// hc_noskilllimit := true ;
95316: LD_ADDR_OWVAR 76
95320: PUSH
95321: LD_INT 1
95323: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
95324: LD_ADDR_OWVAR 31
95328: PUSH
95329: LD_INT 30
95331: PUSH
95332: LD_INT 30
95334: PUSH
95335: LD_INT 30
95337: PUSH
95338: LD_INT 30
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: LIST
95345: LIST
95346: ST_TO_ADDR
// un := CreateHuman ;
95347: LD_ADDR_VAR 0 3
95351: PUSH
95352: CALL_OW 44
95356: ST_TO_ADDR
// hc_noskilllimit := false ;
95357: LD_ADDR_OWVAR 76
95361: PUSH
95362: LD_INT 0
95364: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95365: LD_VAR 0 3
95369: PPUSH
95370: LD_INT 1
95372: PPUSH
95373: CALL_OW 51
// p := 0 ;
95377: LD_ADDR_VAR 0 2
95381: PUSH
95382: LD_INT 0
95384: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
95385: LD_INT 35
95387: PPUSH
95388: CALL_OW 67
// p := p + 1 ;
95392: LD_ADDR_VAR 0 2
95396: PUSH
95397: LD_VAR 0 2
95401: PUSH
95402: LD_INT 1
95404: PLUS
95405: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
95406: LD_VAR 0 3
95410: PPUSH
95411: CALL_OW 256
95415: PUSH
95416: LD_INT 1000
95418: LESS
95419: IFFALSE 95433
// SetLives ( un , 1000 ) ;
95421: LD_VAR 0 3
95425: PPUSH
95426: LD_INT 1000
95428: PPUSH
95429: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
95433: LD_VAR 0 3
95437: PPUSH
95438: LD_INT 81
95440: PUSH
95441: LD_OWVAR 2
95445: PUSH
95446: EMPTY
95447: LIST
95448: LIST
95449: PUSH
95450: LD_INT 91
95452: PUSH
95453: LD_VAR 0 3
95457: PUSH
95458: LD_INT 30
95460: PUSH
95461: EMPTY
95462: LIST
95463: LIST
95464: LIST
95465: PUSH
95466: EMPTY
95467: LIST
95468: LIST
95469: PPUSH
95470: CALL_OW 69
95474: PPUSH
95475: LD_VAR 0 3
95479: PPUSH
95480: CALL_OW 74
95484: PPUSH
95485: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
95489: LD_VAR 0 2
95493: PUSH
95494: LD_INT 60
95496: GREATER
95497: PUSH
95498: LD_VAR 0 3
95502: PPUSH
95503: CALL_OW 301
95507: OR
95508: IFFALSE 95385
// if un then
95510: LD_VAR 0 3
95514: IFFALSE 95525
// RemoveUnit ( un ) ;
95516: LD_VAR 0 3
95520: PPUSH
95521: CALL_OW 64
// end ;
95525: PPOPN 3
95527: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
95528: LD_INT 0
95530: PPUSH
// case cmd of 301 :
95531: LD_VAR 0 1
95535: PUSH
95536: LD_INT 301
95538: DOUBLE
95539: EQUAL
95540: IFTRUE 95544
95542: GO 95576
95544: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
95545: LD_VAR 0 6
95549: PPUSH
95550: LD_VAR 0 7
95554: PPUSH
95555: LD_VAR 0 8
95559: PPUSH
95560: LD_VAR 0 4
95564: PPUSH
95565: LD_VAR 0 5
95569: PPUSH
95570: CALL 96777 0 5
95574: GO 95697
95576: LD_INT 302
95578: DOUBLE
95579: EQUAL
95580: IFTRUE 95584
95582: GO 95621
95584: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
95585: LD_VAR 0 6
95589: PPUSH
95590: LD_VAR 0 7
95594: PPUSH
95595: LD_VAR 0 8
95599: PPUSH
95600: LD_VAR 0 9
95604: PPUSH
95605: LD_VAR 0 4
95609: PPUSH
95610: LD_VAR 0 5
95614: PPUSH
95615: CALL 96868 0 6
95619: GO 95697
95621: LD_INT 303
95623: DOUBLE
95624: EQUAL
95625: IFTRUE 95629
95627: GO 95666
95629: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
95630: LD_VAR 0 6
95634: PPUSH
95635: LD_VAR 0 7
95639: PPUSH
95640: LD_VAR 0 8
95644: PPUSH
95645: LD_VAR 0 9
95649: PPUSH
95650: LD_VAR 0 4
95654: PPUSH
95655: LD_VAR 0 5
95659: PPUSH
95660: CALL 95702 0 6
95664: GO 95697
95666: LD_INT 304
95668: DOUBLE
95669: EQUAL
95670: IFTRUE 95674
95672: GO 95696
95674: POP
// hHackTeleport ( unit , x , y ) ; end ;
95675: LD_VAR 0 2
95679: PPUSH
95680: LD_VAR 0 4
95684: PPUSH
95685: LD_VAR 0 5
95689: PPUSH
95690: CALL 97461 0 3
95694: GO 95697
95696: POP
// end ;
95697: LD_VAR 0 12
95701: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
95702: LD_INT 0
95704: PPUSH
95705: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
95706: LD_VAR 0 1
95710: PUSH
95711: LD_INT 1
95713: LESS
95714: PUSH
95715: LD_VAR 0 1
95719: PUSH
95720: LD_INT 3
95722: GREATER
95723: OR
95724: PUSH
95725: LD_VAR 0 5
95729: PPUSH
95730: LD_VAR 0 6
95734: PPUSH
95735: CALL_OW 428
95739: OR
95740: IFFALSE 95744
// exit ;
95742: GO 96464
// uc_side := your_side ;
95744: LD_ADDR_OWVAR 20
95748: PUSH
95749: LD_OWVAR 2
95753: ST_TO_ADDR
// uc_nation := nation ;
95754: LD_ADDR_OWVAR 21
95758: PUSH
95759: LD_VAR 0 1
95763: ST_TO_ADDR
// bc_level = 1 ;
95764: LD_ADDR_OWVAR 43
95768: PUSH
95769: LD_INT 1
95771: ST_TO_ADDR
// case btype of 1 :
95772: LD_VAR 0 2
95776: PUSH
95777: LD_INT 1
95779: DOUBLE
95780: EQUAL
95781: IFTRUE 95785
95783: GO 95796
95785: POP
// bc_type := b_depot ; 2 :
95786: LD_ADDR_OWVAR 42
95790: PUSH
95791: LD_INT 0
95793: ST_TO_ADDR
95794: GO 96408
95796: LD_INT 2
95798: DOUBLE
95799: EQUAL
95800: IFTRUE 95804
95802: GO 95815
95804: POP
// bc_type := b_warehouse ; 3 :
95805: LD_ADDR_OWVAR 42
95809: PUSH
95810: LD_INT 1
95812: ST_TO_ADDR
95813: GO 96408
95815: LD_INT 3
95817: DOUBLE
95818: EQUAL
95819: IFTRUE 95823
95821: GO 95834
95823: POP
// bc_type := b_lab ; 4 .. 9 :
95824: LD_ADDR_OWVAR 42
95828: PUSH
95829: LD_INT 6
95831: ST_TO_ADDR
95832: GO 96408
95834: LD_INT 4
95836: DOUBLE
95837: GREATEREQUAL
95838: IFFALSE 95846
95840: LD_INT 9
95842: DOUBLE
95843: LESSEQUAL
95844: IFTRUE 95848
95846: GO 95900
95848: POP
// begin bc_type := b_lab_half ;
95849: LD_ADDR_OWVAR 42
95853: PUSH
95854: LD_INT 7
95856: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
95857: LD_ADDR_OWVAR 44
95861: PUSH
95862: LD_INT 10
95864: PUSH
95865: LD_INT 11
95867: PUSH
95868: LD_INT 12
95870: PUSH
95871: LD_INT 15
95873: PUSH
95874: LD_INT 14
95876: PUSH
95877: LD_INT 13
95879: PUSH
95880: EMPTY
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: PUSH
95888: LD_VAR 0 2
95892: PUSH
95893: LD_INT 3
95895: MINUS
95896: ARRAY
95897: ST_TO_ADDR
// end ; 10 .. 13 :
95898: GO 96408
95900: LD_INT 10
95902: DOUBLE
95903: GREATEREQUAL
95904: IFFALSE 95912
95906: LD_INT 13
95908: DOUBLE
95909: LESSEQUAL
95910: IFTRUE 95914
95912: GO 95991
95914: POP
// begin bc_type := b_lab_full ;
95915: LD_ADDR_OWVAR 42
95919: PUSH
95920: LD_INT 8
95922: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
95923: LD_ADDR_OWVAR 44
95927: PUSH
95928: LD_INT 10
95930: PUSH
95931: LD_INT 12
95933: PUSH
95934: LD_INT 14
95936: PUSH
95937: LD_INT 13
95939: PUSH
95940: EMPTY
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: PUSH
95946: LD_VAR 0 2
95950: PUSH
95951: LD_INT 9
95953: MINUS
95954: ARRAY
95955: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
95956: LD_ADDR_OWVAR 45
95960: PUSH
95961: LD_INT 11
95963: PUSH
95964: LD_INT 15
95966: PUSH
95967: LD_INT 12
95969: PUSH
95970: LD_INT 15
95972: PUSH
95973: EMPTY
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: PUSH
95979: LD_VAR 0 2
95983: PUSH
95984: LD_INT 9
95986: MINUS
95987: ARRAY
95988: ST_TO_ADDR
// end ; 14 :
95989: GO 96408
95991: LD_INT 14
95993: DOUBLE
95994: EQUAL
95995: IFTRUE 95999
95997: GO 96010
95999: POP
// bc_type := b_workshop ; 15 :
96000: LD_ADDR_OWVAR 42
96004: PUSH
96005: LD_INT 2
96007: ST_TO_ADDR
96008: GO 96408
96010: LD_INT 15
96012: DOUBLE
96013: EQUAL
96014: IFTRUE 96018
96016: GO 96029
96018: POP
// bc_type := b_factory ; 16 :
96019: LD_ADDR_OWVAR 42
96023: PUSH
96024: LD_INT 3
96026: ST_TO_ADDR
96027: GO 96408
96029: LD_INT 16
96031: DOUBLE
96032: EQUAL
96033: IFTRUE 96037
96035: GO 96048
96037: POP
// bc_type := b_ext_gun ; 17 :
96038: LD_ADDR_OWVAR 42
96042: PUSH
96043: LD_INT 17
96045: ST_TO_ADDR
96046: GO 96408
96048: LD_INT 17
96050: DOUBLE
96051: EQUAL
96052: IFTRUE 96056
96054: GO 96084
96056: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
96057: LD_ADDR_OWVAR 42
96061: PUSH
96062: LD_INT 19
96064: PUSH
96065: LD_INT 23
96067: PUSH
96068: LD_INT 19
96070: PUSH
96071: EMPTY
96072: LIST
96073: LIST
96074: LIST
96075: PUSH
96076: LD_VAR 0 1
96080: ARRAY
96081: ST_TO_ADDR
96082: GO 96408
96084: LD_INT 18
96086: DOUBLE
96087: EQUAL
96088: IFTRUE 96092
96090: GO 96103
96092: POP
// bc_type := b_ext_radar ; 19 :
96093: LD_ADDR_OWVAR 42
96097: PUSH
96098: LD_INT 20
96100: ST_TO_ADDR
96101: GO 96408
96103: LD_INT 19
96105: DOUBLE
96106: EQUAL
96107: IFTRUE 96111
96109: GO 96122
96111: POP
// bc_type := b_ext_radio ; 20 :
96112: LD_ADDR_OWVAR 42
96116: PUSH
96117: LD_INT 22
96119: ST_TO_ADDR
96120: GO 96408
96122: LD_INT 20
96124: DOUBLE
96125: EQUAL
96126: IFTRUE 96130
96128: GO 96141
96130: POP
// bc_type := b_ext_siberium ; 21 :
96131: LD_ADDR_OWVAR 42
96135: PUSH
96136: LD_INT 21
96138: ST_TO_ADDR
96139: GO 96408
96141: LD_INT 21
96143: DOUBLE
96144: EQUAL
96145: IFTRUE 96149
96147: GO 96160
96149: POP
// bc_type := b_ext_computer ; 22 :
96150: LD_ADDR_OWVAR 42
96154: PUSH
96155: LD_INT 24
96157: ST_TO_ADDR
96158: GO 96408
96160: LD_INT 22
96162: DOUBLE
96163: EQUAL
96164: IFTRUE 96168
96166: GO 96179
96168: POP
// bc_type := b_ext_track ; 23 :
96169: LD_ADDR_OWVAR 42
96173: PUSH
96174: LD_INT 16
96176: ST_TO_ADDR
96177: GO 96408
96179: LD_INT 23
96181: DOUBLE
96182: EQUAL
96183: IFTRUE 96187
96185: GO 96198
96187: POP
// bc_type := b_ext_laser ; 24 :
96188: LD_ADDR_OWVAR 42
96192: PUSH
96193: LD_INT 25
96195: ST_TO_ADDR
96196: GO 96408
96198: LD_INT 24
96200: DOUBLE
96201: EQUAL
96202: IFTRUE 96206
96204: GO 96217
96206: POP
// bc_type := b_control_tower ; 25 :
96207: LD_ADDR_OWVAR 42
96211: PUSH
96212: LD_INT 36
96214: ST_TO_ADDR
96215: GO 96408
96217: LD_INT 25
96219: DOUBLE
96220: EQUAL
96221: IFTRUE 96225
96223: GO 96236
96225: POP
// bc_type := b_breastwork ; 26 :
96226: LD_ADDR_OWVAR 42
96230: PUSH
96231: LD_INT 31
96233: ST_TO_ADDR
96234: GO 96408
96236: LD_INT 26
96238: DOUBLE
96239: EQUAL
96240: IFTRUE 96244
96242: GO 96255
96244: POP
// bc_type := b_bunker ; 27 :
96245: LD_ADDR_OWVAR 42
96249: PUSH
96250: LD_INT 32
96252: ST_TO_ADDR
96253: GO 96408
96255: LD_INT 27
96257: DOUBLE
96258: EQUAL
96259: IFTRUE 96263
96261: GO 96274
96263: POP
// bc_type := b_turret ; 28 :
96264: LD_ADDR_OWVAR 42
96268: PUSH
96269: LD_INT 33
96271: ST_TO_ADDR
96272: GO 96408
96274: LD_INT 28
96276: DOUBLE
96277: EQUAL
96278: IFTRUE 96282
96280: GO 96293
96282: POP
// bc_type := b_armoury ; 29 :
96283: LD_ADDR_OWVAR 42
96287: PUSH
96288: LD_INT 4
96290: ST_TO_ADDR
96291: GO 96408
96293: LD_INT 29
96295: DOUBLE
96296: EQUAL
96297: IFTRUE 96301
96299: GO 96312
96301: POP
// bc_type := b_barracks ; 30 :
96302: LD_ADDR_OWVAR 42
96306: PUSH
96307: LD_INT 5
96309: ST_TO_ADDR
96310: GO 96408
96312: LD_INT 30
96314: DOUBLE
96315: EQUAL
96316: IFTRUE 96320
96318: GO 96331
96320: POP
// bc_type := b_solar_power ; 31 :
96321: LD_ADDR_OWVAR 42
96325: PUSH
96326: LD_INT 27
96328: ST_TO_ADDR
96329: GO 96408
96331: LD_INT 31
96333: DOUBLE
96334: EQUAL
96335: IFTRUE 96339
96337: GO 96350
96339: POP
// bc_type := b_oil_power ; 32 :
96340: LD_ADDR_OWVAR 42
96344: PUSH
96345: LD_INT 26
96347: ST_TO_ADDR
96348: GO 96408
96350: LD_INT 32
96352: DOUBLE
96353: EQUAL
96354: IFTRUE 96358
96356: GO 96369
96358: POP
// bc_type := b_siberite_power ; 33 :
96359: LD_ADDR_OWVAR 42
96363: PUSH
96364: LD_INT 28
96366: ST_TO_ADDR
96367: GO 96408
96369: LD_INT 33
96371: DOUBLE
96372: EQUAL
96373: IFTRUE 96377
96375: GO 96388
96377: POP
// bc_type := b_oil_mine ; 34 :
96378: LD_ADDR_OWVAR 42
96382: PUSH
96383: LD_INT 29
96385: ST_TO_ADDR
96386: GO 96408
96388: LD_INT 34
96390: DOUBLE
96391: EQUAL
96392: IFTRUE 96396
96394: GO 96407
96396: POP
// bc_type := b_siberite_mine ; end ;
96397: LD_ADDR_OWVAR 42
96401: PUSH
96402: LD_INT 30
96404: ST_TO_ADDR
96405: GO 96408
96407: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
96408: LD_ADDR_VAR 0 8
96412: PUSH
96413: LD_VAR 0 5
96417: PPUSH
96418: LD_VAR 0 6
96422: PPUSH
96423: LD_VAR 0 3
96427: PPUSH
96428: CALL_OW 47
96432: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
96433: LD_OWVAR 42
96437: PUSH
96438: LD_INT 32
96440: PUSH
96441: LD_INT 33
96443: PUSH
96444: EMPTY
96445: LIST
96446: LIST
96447: IN
96448: IFFALSE 96464
// PlaceWeaponTurret ( b , weapon ) ;
96450: LD_VAR 0 8
96454: PPUSH
96455: LD_VAR 0 4
96459: PPUSH
96460: CALL_OW 431
// end ;
96464: LD_VAR 0 7
96468: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
96469: LD_INT 0
96471: PPUSH
96472: PPUSH
96473: PPUSH
96474: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96475: LD_ADDR_VAR 0 4
96479: PUSH
96480: LD_INT 22
96482: PUSH
96483: LD_OWVAR 2
96487: PUSH
96488: EMPTY
96489: LIST
96490: LIST
96491: PUSH
96492: LD_INT 2
96494: PUSH
96495: LD_INT 30
96497: PUSH
96498: LD_INT 0
96500: PUSH
96501: EMPTY
96502: LIST
96503: LIST
96504: PUSH
96505: LD_INT 30
96507: PUSH
96508: LD_INT 1
96510: PUSH
96511: EMPTY
96512: LIST
96513: LIST
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: LIST
96519: PUSH
96520: EMPTY
96521: LIST
96522: LIST
96523: PPUSH
96524: CALL_OW 69
96528: ST_TO_ADDR
// if not tmp then
96529: LD_VAR 0 4
96533: NOT
96534: IFFALSE 96538
// exit ;
96536: GO 96597
// for i in tmp do
96538: LD_ADDR_VAR 0 2
96542: PUSH
96543: LD_VAR 0 4
96547: PUSH
96548: FOR_IN
96549: IFFALSE 96595
// for j = 1 to 3 do
96551: LD_ADDR_VAR 0 3
96555: PUSH
96556: DOUBLE
96557: LD_INT 1
96559: DEC
96560: ST_TO_ADDR
96561: LD_INT 3
96563: PUSH
96564: FOR_TO
96565: IFFALSE 96591
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
96567: LD_VAR 0 2
96571: PPUSH
96572: CALL_OW 274
96576: PPUSH
96577: LD_VAR 0 3
96581: PPUSH
96582: LD_INT 99999
96584: PPUSH
96585: CALL_OW 277
96589: GO 96564
96591: POP
96592: POP
96593: GO 96548
96595: POP
96596: POP
// end ;
96597: LD_VAR 0 1
96601: RET
// export function hHackSetLevel10 ; var i , j ; begin
96602: LD_INT 0
96604: PPUSH
96605: PPUSH
96606: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
96607: LD_ADDR_VAR 0 2
96611: PUSH
96612: LD_INT 21
96614: PUSH
96615: LD_INT 1
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: PPUSH
96622: CALL_OW 69
96626: PUSH
96627: FOR_IN
96628: IFFALSE 96680
// if IsSelected ( i ) then
96630: LD_VAR 0 2
96634: PPUSH
96635: CALL_OW 306
96639: IFFALSE 96678
// begin for j := 1 to 4 do
96641: LD_ADDR_VAR 0 3
96645: PUSH
96646: DOUBLE
96647: LD_INT 1
96649: DEC
96650: ST_TO_ADDR
96651: LD_INT 4
96653: PUSH
96654: FOR_TO
96655: IFFALSE 96676
// SetSkill ( i , j , 10 ) ;
96657: LD_VAR 0 2
96661: PPUSH
96662: LD_VAR 0 3
96666: PPUSH
96667: LD_INT 10
96669: PPUSH
96670: CALL_OW 237
96674: GO 96654
96676: POP
96677: POP
// end ;
96678: GO 96627
96680: POP
96681: POP
// end ;
96682: LD_VAR 0 1
96686: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
96687: LD_INT 0
96689: PPUSH
96690: PPUSH
96691: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
96692: LD_ADDR_VAR 0 2
96696: PUSH
96697: LD_INT 22
96699: PUSH
96700: LD_OWVAR 2
96704: PUSH
96705: EMPTY
96706: LIST
96707: LIST
96708: PUSH
96709: LD_INT 21
96711: PUSH
96712: LD_INT 1
96714: PUSH
96715: EMPTY
96716: LIST
96717: LIST
96718: PUSH
96719: EMPTY
96720: LIST
96721: LIST
96722: PPUSH
96723: CALL_OW 69
96727: PUSH
96728: FOR_IN
96729: IFFALSE 96770
// begin for j := 1 to 4 do
96731: LD_ADDR_VAR 0 3
96735: PUSH
96736: DOUBLE
96737: LD_INT 1
96739: DEC
96740: ST_TO_ADDR
96741: LD_INT 4
96743: PUSH
96744: FOR_TO
96745: IFFALSE 96766
// SetSkill ( i , j , 10 ) ;
96747: LD_VAR 0 2
96751: PPUSH
96752: LD_VAR 0 3
96756: PPUSH
96757: LD_INT 10
96759: PPUSH
96760: CALL_OW 237
96764: GO 96744
96766: POP
96767: POP
// end ;
96768: GO 96728
96770: POP
96771: POP
// end ;
96772: LD_VAR 0 1
96776: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
96777: LD_INT 0
96779: PPUSH
// uc_side := your_side ;
96780: LD_ADDR_OWVAR 20
96784: PUSH
96785: LD_OWVAR 2
96789: ST_TO_ADDR
// uc_nation := nation ;
96790: LD_ADDR_OWVAR 21
96794: PUSH
96795: LD_VAR 0 1
96799: ST_TO_ADDR
// InitHc ;
96800: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
96804: LD_INT 0
96806: PPUSH
96807: LD_VAR 0 2
96811: PPUSH
96812: LD_VAR 0 3
96816: PPUSH
96817: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
96821: LD_VAR 0 4
96825: PPUSH
96826: LD_VAR 0 5
96830: PPUSH
96831: CALL_OW 428
96835: PUSH
96836: LD_INT 0
96838: EQUAL
96839: IFFALSE 96863
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
96841: CALL_OW 44
96845: PPUSH
96846: LD_VAR 0 4
96850: PPUSH
96851: LD_VAR 0 5
96855: PPUSH
96856: LD_INT 1
96858: PPUSH
96859: CALL_OW 48
// end ;
96863: LD_VAR 0 6
96867: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
96868: LD_INT 0
96870: PPUSH
96871: PPUSH
// uc_side := your_side ;
96872: LD_ADDR_OWVAR 20
96876: PUSH
96877: LD_OWVAR 2
96881: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
96882: LD_VAR 0 1
96886: PUSH
96887: LD_INT 1
96889: PUSH
96890: LD_INT 2
96892: PUSH
96893: LD_INT 3
96895: PUSH
96896: LD_INT 4
96898: PUSH
96899: LD_INT 5
96901: PUSH
96902: EMPTY
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: IN
96909: IFFALSE 96921
// uc_nation := nation_american else
96911: LD_ADDR_OWVAR 21
96915: PUSH
96916: LD_INT 1
96918: ST_TO_ADDR
96919: GO 96964
// if chassis in [ 11 , 12 , 13 , 14 ] then
96921: LD_VAR 0 1
96925: PUSH
96926: LD_INT 11
96928: PUSH
96929: LD_INT 12
96931: PUSH
96932: LD_INT 13
96934: PUSH
96935: LD_INT 14
96937: PUSH
96938: EMPTY
96939: LIST
96940: LIST
96941: LIST
96942: LIST
96943: IN
96944: IFFALSE 96956
// uc_nation := nation_arabian else
96946: LD_ADDR_OWVAR 21
96950: PUSH
96951: LD_INT 2
96953: ST_TO_ADDR
96954: GO 96964
// uc_nation := nation_russian ;
96956: LD_ADDR_OWVAR 21
96960: PUSH
96961: LD_INT 3
96963: ST_TO_ADDR
// vc_chassis := chassis ;
96964: LD_ADDR_OWVAR 37
96968: PUSH
96969: LD_VAR 0 1
96973: ST_TO_ADDR
// vc_engine := engine ;
96974: LD_ADDR_OWVAR 39
96978: PUSH
96979: LD_VAR 0 2
96983: ST_TO_ADDR
// vc_control := control ;
96984: LD_ADDR_OWVAR 38
96988: PUSH
96989: LD_VAR 0 3
96993: ST_TO_ADDR
// vc_weapon := weapon ;
96994: LD_ADDR_OWVAR 40
96998: PUSH
96999: LD_VAR 0 4
97003: ST_TO_ADDR
// un := CreateVehicle ;
97004: LD_ADDR_VAR 0 8
97008: PUSH
97009: CALL_OW 45
97013: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
97014: LD_VAR 0 8
97018: PPUSH
97019: LD_INT 0
97021: PPUSH
97022: LD_INT 5
97024: PPUSH
97025: CALL_OW 12
97029: PPUSH
97030: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
97034: LD_VAR 0 8
97038: PPUSH
97039: LD_VAR 0 5
97043: PPUSH
97044: LD_VAR 0 6
97048: PPUSH
97049: LD_INT 1
97051: PPUSH
97052: CALL_OW 48
// end ;
97056: LD_VAR 0 7
97060: RET
// export hInvincible ; every 1 do
97061: GO 97063
97063: DISABLE
// hInvincible := [ ] ;
97064: LD_ADDR_EXP 163
97068: PUSH
97069: EMPTY
97070: ST_TO_ADDR
97071: END
// every 10 do var i ;
97072: GO 97074
97074: DISABLE
97075: LD_INT 0
97077: PPUSH
// begin enable ;
97078: ENABLE
// if not hInvincible then
97079: LD_EXP 163
97083: NOT
97084: IFFALSE 97088
// exit ;
97086: GO 97132
// for i in hInvincible do
97088: LD_ADDR_VAR 0 1
97092: PUSH
97093: LD_EXP 163
97097: PUSH
97098: FOR_IN
97099: IFFALSE 97130
// if GetLives ( i ) < 1000 then
97101: LD_VAR 0 1
97105: PPUSH
97106: CALL_OW 256
97110: PUSH
97111: LD_INT 1000
97113: LESS
97114: IFFALSE 97128
// SetLives ( i , 1000 ) ;
97116: LD_VAR 0 1
97120: PPUSH
97121: LD_INT 1000
97123: PPUSH
97124: CALL_OW 234
97128: GO 97098
97130: POP
97131: POP
// end ;
97132: PPOPN 1
97134: END
// export function hHackInvincible ; var i ; begin
97135: LD_INT 0
97137: PPUSH
97138: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
97139: LD_ADDR_VAR 0 2
97143: PUSH
97144: LD_INT 2
97146: PUSH
97147: LD_INT 21
97149: PUSH
97150: LD_INT 1
97152: PUSH
97153: EMPTY
97154: LIST
97155: LIST
97156: PUSH
97157: LD_INT 21
97159: PUSH
97160: LD_INT 2
97162: PUSH
97163: EMPTY
97164: LIST
97165: LIST
97166: PUSH
97167: EMPTY
97168: LIST
97169: LIST
97170: LIST
97171: PPUSH
97172: CALL_OW 69
97176: PUSH
97177: FOR_IN
97178: IFFALSE 97239
// if IsSelected ( i ) then
97180: LD_VAR 0 2
97184: PPUSH
97185: CALL_OW 306
97189: IFFALSE 97237
// begin if i in hInvincible then
97191: LD_VAR 0 2
97195: PUSH
97196: LD_EXP 163
97200: IN
97201: IFFALSE 97221
// hInvincible := hInvincible diff i else
97203: LD_ADDR_EXP 163
97207: PUSH
97208: LD_EXP 163
97212: PUSH
97213: LD_VAR 0 2
97217: DIFF
97218: ST_TO_ADDR
97219: GO 97237
// hInvincible := hInvincible union i ;
97221: LD_ADDR_EXP 163
97225: PUSH
97226: LD_EXP 163
97230: PUSH
97231: LD_VAR 0 2
97235: UNION
97236: ST_TO_ADDR
// end ;
97237: GO 97177
97239: POP
97240: POP
// end ;
97241: LD_VAR 0 1
97245: RET
// export function hHackInvisible ; var i , j ; begin
97246: LD_INT 0
97248: PPUSH
97249: PPUSH
97250: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
97251: LD_ADDR_VAR 0 2
97255: PUSH
97256: LD_INT 21
97258: PUSH
97259: LD_INT 1
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PPUSH
97266: CALL_OW 69
97270: PUSH
97271: FOR_IN
97272: IFFALSE 97296
// if IsSelected ( i ) then
97274: LD_VAR 0 2
97278: PPUSH
97279: CALL_OW 306
97283: IFFALSE 97294
// ComForceInvisible ( i ) ;
97285: LD_VAR 0 2
97289: PPUSH
97290: CALL_OW 496
97294: GO 97271
97296: POP
97297: POP
// end ;
97298: LD_VAR 0 1
97302: RET
// export function hHackChangeYourSide ; begin
97303: LD_INT 0
97305: PPUSH
// if your_side = 8 then
97306: LD_OWVAR 2
97310: PUSH
97311: LD_INT 8
97313: EQUAL
97314: IFFALSE 97326
// your_side := 0 else
97316: LD_ADDR_OWVAR 2
97320: PUSH
97321: LD_INT 0
97323: ST_TO_ADDR
97324: GO 97340
// your_side := your_side + 1 ;
97326: LD_ADDR_OWVAR 2
97330: PUSH
97331: LD_OWVAR 2
97335: PUSH
97336: LD_INT 1
97338: PLUS
97339: ST_TO_ADDR
// end ;
97340: LD_VAR 0 1
97344: RET
// export function hHackChangeUnitSide ; var i , j ; begin
97345: LD_INT 0
97347: PPUSH
97348: PPUSH
97349: PPUSH
// for i in all_units do
97350: LD_ADDR_VAR 0 2
97354: PUSH
97355: LD_OWVAR 3
97359: PUSH
97360: FOR_IN
97361: IFFALSE 97439
// if IsSelected ( i ) then
97363: LD_VAR 0 2
97367: PPUSH
97368: CALL_OW 306
97372: IFFALSE 97437
// begin j := GetSide ( i ) ;
97374: LD_ADDR_VAR 0 3
97378: PUSH
97379: LD_VAR 0 2
97383: PPUSH
97384: CALL_OW 255
97388: ST_TO_ADDR
// if j = 8 then
97389: LD_VAR 0 3
97393: PUSH
97394: LD_INT 8
97396: EQUAL
97397: IFFALSE 97409
// j := 0 else
97399: LD_ADDR_VAR 0 3
97403: PUSH
97404: LD_INT 0
97406: ST_TO_ADDR
97407: GO 97423
// j := j + 1 ;
97409: LD_ADDR_VAR 0 3
97413: PUSH
97414: LD_VAR 0 3
97418: PUSH
97419: LD_INT 1
97421: PLUS
97422: ST_TO_ADDR
// SetSide ( i , j ) ;
97423: LD_VAR 0 2
97427: PPUSH
97428: LD_VAR 0 3
97432: PPUSH
97433: CALL_OW 235
// end ;
97437: GO 97360
97439: POP
97440: POP
// end ;
97441: LD_VAR 0 1
97445: RET
// export function hHackFog ; begin
97446: LD_INT 0
97448: PPUSH
// FogOff ( true ) ;
97449: LD_INT 1
97451: PPUSH
97452: CALL_OW 344
// end ;
97456: LD_VAR 0 1
97460: RET
// export function hHackTeleport ( unit , x , y ) ; begin
97461: LD_INT 0
97463: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
97464: LD_VAR 0 1
97468: PPUSH
97469: LD_VAR 0 2
97473: PPUSH
97474: LD_VAR 0 3
97478: PPUSH
97479: LD_INT 1
97481: PPUSH
97482: LD_INT 1
97484: PPUSH
97485: CALL_OW 483
// CenterOnXY ( x , y ) ;
97489: LD_VAR 0 2
97493: PPUSH
97494: LD_VAR 0 3
97498: PPUSH
97499: CALL_OW 84
// end ; end_of_file
97503: LD_VAR 0 4
97507: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
97508: LD_INT 0
97510: PPUSH
97511: PPUSH
97512: PPUSH
97513: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
97514: LD_VAR 0 1
97518: PPUSH
97519: CALL_OW 264
97523: PUSH
97524: LD_EXP 97
97528: EQUAL
97529: IFFALSE 97601
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
97531: LD_INT 68
97533: PPUSH
97534: LD_VAR 0 1
97538: PPUSH
97539: CALL_OW 255
97543: PPUSH
97544: CALL_OW 321
97548: PUSH
97549: LD_INT 2
97551: EQUAL
97552: IFFALSE 97564
// eff := 70 else
97554: LD_ADDR_VAR 0 4
97558: PUSH
97559: LD_INT 70
97561: ST_TO_ADDR
97562: GO 97572
// eff := 30 ;
97564: LD_ADDR_VAR 0 4
97568: PUSH
97569: LD_INT 30
97571: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
97572: LD_VAR 0 1
97576: PPUSH
97577: CALL_OW 250
97581: PPUSH
97582: LD_VAR 0 1
97586: PPUSH
97587: CALL_OW 251
97591: PPUSH
97592: LD_VAR 0 4
97596: PPUSH
97597: CALL_OW 495
// end ; end ;
97601: LD_VAR 0 2
97605: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
97606: LD_INT 0
97608: PPUSH
// end ;
97609: LD_VAR 0 4
97613: RET
// export function SOS_Command ( cmd ) ; begin
97614: LD_INT 0
97616: PPUSH
// end ;
97617: LD_VAR 0 2
97621: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
97622: LD_INT 0
97624: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
97625: LD_VAR 0 1
97629: PUSH
97630: LD_INT 250
97632: EQUAL
97633: PUSH
97634: LD_VAR 0 2
97638: PPUSH
97639: CALL_OW 264
97643: PUSH
97644: LD_EXP 100
97648: EQUAL
97649: AND
97650: IFFALSE 97671
// MinerPlaceMine ( unit , x , y ) ;
97652: LD_VAR 0 2
97656: PPUSH
97657: LD_VAR 0 4
97661: PPUSH
97662: LD_VAR 0 5
97666: PPUSH
97667: CALL 100012 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
97671: LD_VAR 0 1
97675: PUSH
97676: LD_INT 251
97678: EQUAL
97679: PUSH
97680: LD_VAR 0 2
97684: PPUSH
97685: CALL_OW 264
97689: PUSH
97690: LD_EXP 100
97694: EQUAL
97695: AND
97696: IFFALSE 97717
// MinerDetonateMine ( unit , x , y ) ;
97698: LD_VAR 0 2
97702: PPUSH
97703: LD_VAR 0 4
97707: PPUSH
97708: LD_VAR 0 5
97712: PPUSH
97713: CALL 100289 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
97717: LD_VAR 0 1
97721: PUSH
97722: LD_INT 252
97724: EQUAL
97725: PUSH
97726: LD_VAR 0 2
97730: PPUSH
97731: CALL_OW 264
97735: PUSH
97736: LD_EXP 100
97740: EQUAL
97741: AND
97742: IFFALSE 97763
// MinerCreateMinefield ( unit , x , y ) ;
97744: LD_VAR 0 2
97748: PPUSH
97749: LD_VAR 0 4
97753: PPUSH
97754: LD_VAR 0 5
97758: PPUSH
97759: CALL 100706 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
97763: LD_VAR 0 1
97767: PUSH
97768: LD_INT 253
97770: EQUAL
97771: PUSH
97772: LD_VAR 0 2
97776: PPUSH
97777: CALL_OW 257
97781: PUSH
97782: LD_INT 5
97784: EQUAL
97785: AND
97786: IFFALSE 97807
// ComBinocular ( unit , x , y ) ;
97788: LD_VAR 0 2
97792: PPUSH
97793: LD_VAR 0 4
97797: PPUSH
97798: LD_VAR 0 5
97802: PPUSH
97803: CALL 101077 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
97807: LD_VAR 0 1
97811: PUSH
97812: LD_INT 254
97814: EQUAL
97815: PUSH
97816: LD_VAR 0 2
97820: PPUSH
97821: CALL_OW 264
97825: PUSH
97826: LD_EXP 95
97830: EQUAL
97831: AND
97832: PUSH
97833: LD_VAR 0 3
97837: PPUSH
97838: CALL_OW 263
97842: PUSH
97843: LD_INT 3
97845: EQUAL
97846: AND
97847: IFFALSE 97863
// HackDestroyVehicle ( unit , selectedUnit ) ;
97849: LD_VAR 0 2
97853: PPUSH
97854: LD_VAR 0 3
97858: PPUSH
97859: CALL 99372 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
97863: LD_VAR 0 1
97867: PUSH
97868: LD_INT 255
97870: EQUAL
97871: PUSH
97872: LD_VAR 0 2
97876: PPUSH
97877: CALL_OW 264
97881: PUSH
97882: LD_INT 14
97884: PUSH
97885: LD_INT 53
97887: PUSH
97888: EMPTY
97889: LIST
97890: LIST
97891: IN
97892: AND
97893: PUSH
97894: LD_VAR 0 4
97898: PPUSH
97899: LD_VAR 0 5
97903: PPUSH
97904: CALL_OW 488
97908: AND
97909: IFFALSE 97933
// CutTreeXYR ( unit , x , y , 12 ) ;
97911: LD_VAR 0 2
97915: PPUSH
97916: LD_VAR 0 4
97920: PPUSH
97921: LD_VAR 0 5
97925: PPUSH
97926: LD_INT 12
97928: PPUSH
97929: CALL 97938 0 4
// end ;
97933: LD_VAR 0 6
97937: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
97938: LD_INT 0
97940: PPUSH
97941: PPUSH
97942: PPUSH
97943: PPUSH
97944: PPUSH
97945: PPUSH
97946: PPUSH
97947: PPUSH
97948: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
97949: LD_VAR 0 1
97953: NOT
97954: PUSH
97955: LD_VAR 0 2
97959: PPUSH
97960: LD_VAR 0 3
97964: PPUSH
97965: CALL_OW 488
97969: NOT
97970: OR
97971: PUSH
97972: LD_VAR 0 4
97976: NOT
97977: OR
97978: IFFALSE 97982
// exit ;
97980: GO 98322
// list := [ ] ;
97982: LD_ADDR_VAR 0 13
97986: PUSH
97987: EMPTY
97988: ST_TO_ADDR
// if x - r < 0 then
97989: LD_VAR 0 2
97993: PUSH
97994: LD_VAR 0 4
97998: MINUS
97999: PUSH
98000: LD_INT 0
98002: LESS
98003: IFFALSE 98015
// min_x := 0 else
98005: LD_ADDR_VAR 0 7
98009: PUSH
98010: LD_INT 0
98012: ST_TO_ADDR
98013: GO 98031
// min_x := x - r ;
98015: LD_ADDR_VAR 0 7
98019: PUSH
98020: LD_VAR 0 2
98024: PUSH
98025: LD_VAR 0 4
98029: MINUS
98030: ST_TO_ADDR
// if y - r < 0 then
98031: LD_VAR 0 3
98035: PUSH
98036: LD_VAR 0 4
98040: MINUS
98041: PUSH
98042: LD_INT 0
98044: LESS
98045: IFFALSE 98057
// min_y := 0 else
98047: LD_ADDR_VAR 0 8
98051: PUSH
98052: LD_INT 0
98054: ST_TO_ADDR
98055: GO 98073
// min_y := y - r ;
98057: LD_ADDR_VAR 0 8
98061: PUSH
98062: LD_VAR 0 3
98066: PUSH
98067: LD_VAR 0 4
98071: MINUS
98072: ST_TO_ADDR
// max_x := x + r ;
98073: LD_ADDR_VAR 0 9
98077: PUSH
98078: LD_VAR 0 2
98082: PUSH
98083: LD_VAR 0 4
98087: PLUS
98088: ST_TO_ADDR
// max_y := y + r ;
98089: LD_ADDR_VAR 0 10
98093: PUSH
98094: LD_VAR 0 3
98098: PUSH
98099: LD_VAR 0 4
98103: PLUS
98104: ST_TO_ADDR
// for _x = min_x to max_x do
98105: LD_ADDR_VAR 0 11
98109: PUSH
98110: DOUBLE
98111: LD_VAR 0 7
98115: DEC
98116: ST_TO_ADDR
98117: LD_VAR 0 9
98121: PUSH
98122: FOR_TO
98123: IFFALSE 98240
// for _y = min_y to max_y do
98125: LD_ADDR_VAR 0 12
98129: PUSH
98130: DOUBLE
98131: LD_VAR 0 8
98135: DEC
98136: ST_TO_ADDR
98137: LD_VAR 0 10
98141: PUSH
98142: FOR_TO
98143: IFFALSE 98236
// begin if not ValidHex ( _x , _y ) then
98145: LD_VAR 0 11
98149: PPUSH
98150: LD_VAR 0 12
98154: PPUSH
98155: CALL_OW 488
98159: NOT
98160: IFFALSE 98164
// continue ;
98162: GO 98142
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
98164: LD_VAR 0 11
98168: PPUSH
98169: LD_VAR 0 12
98173: PPUSH
98174: CALL_OW 351
98178: PUSH
98179: LD_VAR 0 11
98183: PPUSH
98184: LD_VAR 0 12
98188: PPUSH
98189: CALL_OW 554
98193: AND
98194: IFFALSE 98234
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
98196: LD_ADDR_VAR 0 13
98200: PUSH
98201: LD_VAR 0 13
98205: PPUSH
98206: LD_VAR 0 13
98210: PUSH
98211: LD_INT 1
98213: PLUS
98214: PPUSH
98215: LD_VAR 0 11
98219: PUSH
98220: LD_VAR 0 12
98224: PUSH
98225: EMPTY
98226: LIST
98227: LIST
98228: PPUSH
98229: CALL_OW 2
98233: ST_TO_ADDR
// end ;
98234: GO 98142
98236: POP
98237: POP
98238: GO 98122
98240: POP
98241: POP
// if not list then
98242: LD_VAR 0 13
98246: NOT
98247: IFFALSE 98251
// exit ;
98249: GO 98322
// for i in list do
98251: LD_ADDR_VAR 0 6
98255: PUSH
98256: LD_VAR 0 13
98260: PUSH
98261: FOR_IN
98262: IFFALSE 98320
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
98264: LD_VAR 0 1
98268: PPUSH
98269: LD_STRING M
98271: PUSH
98272: LD_VAR 0 6
98276: PUSH
98277: LD_INT 1
98279: ARRAY
98280: PUSH
98281: LD_VAR 0 6
98285: PUSH
98286: LD_INT 2
98288: ARRAY
98289: PUSH
98290: LD_INT 0
98292: PUSH
98293: LD_INT 0
98295: PUSH
98296: LD_INT 0
98298: PUSH
98299: LD_INT 0
98301: PUSH
98302: EMPTY
98303: LIST
98304: LIST
98305: LIST
98306: LIST
98307: LIST
98308: LIST
98309: LIST
98310: PUSH
98311: EMPTY
98312: LIST
98313: PPUSH
98314: CALL_OW 447
98318: GO 98261
98320: POP
98321: POP
// end ;
98322: LD_VAR 0 5
98326: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
98327: LD_EXP 164
98331: NOT
98332: IFFALSE 98382
98334: GO 98336
98336: DISABLE
// begin initHack := true ;
98337: LD_ADDR_EXP 164
98341: PUSH
98342: LD_INT 1
98344: ST_TO_ADDR
// hackTanks := [ ] ;
98345: LD_ADDR_EXP 165
98349: PUSH
98350: EMPTY
98351: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
98352: LD_ADDR_EXP 166
98356: PUSH
98357: EMPTY
98358: ST_TO_ADDR
// hackLimit := 3 ;
98359: LD_ADDR_EXP 167
98363: PUSH
98364: LD_INT 3
98366: ST_TO_ADDR
// hackDist := 12 ;
98367: LD_ADDR_EXP 168
98371: PUSH
98372: LD_INT 12
98374: ST_TO_ADDR
// hackCounter := [ ] ;
98375: LD_ADDR_EXP 169
98379: PUSH
98380: EMPTY
98381: ST_TO_ADDR
// end ;
98382: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
98383: LD_EXP 164
98387: PUSH
98388: LD_INT 34
98390: PUSH
98391: LD_EXP 95
98395: PUSH
98396: EMPTY
98397: LIST
98398: LIST
98399: PPUSH
98400: CALL_OW 69
98404: AND
98405: IFFALSE 98660
98407: GO 98409
98409: DISABLE
98410: LD_INT 0
98412: PPUSH
98413: PPUSH
// begin enable ;
98414: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
98415: LD_ADDR_VAR 0 1
98419: PUSH
98420: LD_INT 34
98422: PUSH
98423: LD_EXP 95
98427: PUSH
98428: EMPTY
98429: LIST
98430: LIST
98431: PPUSH
98432: CALL_OW 69
98436: PUSH
98437: FOR_IN
98438: IFFALSE 98658
// begin if not i in hackTanks then
98440: LD_VAR 0 1
98444: PUSH
98445: LD_EXP 165
98449: IN
98450: NOT
98451: IFFALSE 98534
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
98453: LD_ADDR_EXP 165
98457: PUSH
98458: LD_EXP 165
98462: PPUSH
98463: LD_EXP 165
98467: PUSH
98468: LD_INT 1
98470: PLUS
98471: PPUSH
98472: LD_VAR 0 1
98476: PPUSH
98477: CALL_OW 1
98481: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
98482: LD_ADDR_EXP 166
98486: PUSH
98487: LD_EXP 166
98491: PPUSH
98492: LD_EXP 166
98496: PUSH
98497: LD_INT 1
98499: PLUS
98500: PPUSH
98501: EMPTY
98502: PPUSH
98503: CALL_OW 1
98507: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
98508: LD_ADDR_EXP 169
98512: PUSH
98513: LD_EXP 169
98517: PPUSH
98518: LD_EXP 169
98522: PUSH
98523: LD_INT 1
98525: PLUS
98526: PPUSH
98527: EMPTY
98528: PPUSH
98529: CALL_OW 1
98533: ST_TO_ADDR
// end ; if not IsOk ( i ) then
98534: LD_VAR 0 1
98538: PPUSH
98539: CALL_OW 302
98543: NOT
98544: IFFALSE 98557
// begin HackUnlinkAll ( i ) ;
98546: LD_VAR 0 1
98550: PPUSH
98551: CALL 98663 0 1
// continue ;
98555: GO 98437
// end ; HackCheckCapturedStatus ( i ) ;
98557: LD_VAR 0 1
98561: PPUSH
98562: CALL 99106 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
98566: LD_ADDR_VAR 0 2
98570: PUSH
98571: LD_INT 81
98573: PUSH
98574: LD_VAR 0 1
98578: PPUSH
98579: CALL_OW 255
98583: PUSH
98584: EMPTY
98585: LIST
98586: LIST
98587: PUSH
98588: LD_INT 33
98590: PUSH
98591: LD_INT 3
98593: PUSH
98594: EMPTY
98595: LIST
98596: LIST
98597: PUSH
98598: LD_INT 91
98600: PUSH
98601: LD_VAR 0 1
98605: PUSH
98606: LD_EXP 168
98610: PUSH
98611: EMPTY
98612: LIST
98613: LIST
98614: LIST
98615: PUSH
98616: LD_INT 50
98618: PUSH
98619: EMPTY
98620: LIST
98621: PUSH
98622: EMPTY
98623: LIST
98624: LIST
98625: LIST
98626: LIST
98627: PPUSH
98628: CALL_OW 69
98632: ST_TO_ADDR
// if not tmp then
98633: LD_VAR 0 2
98637: NOT
98638: IFFALSE 98642
// continue ;
98640: GO 98437
// HackLink ( i , tmp ) ;
98642: LD_VAR 0 1
98646: PPUSH
98647: LD_VAR 0 2
98651: PPUSH
98652: CALL 98799 0 2
// end ;
98656: GO 98437
98658: POP
98659: POP
// end ;
98660: PPOPN 2
98662: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
98663: LD_INT 0
98665: PPUSH
98666: PPUSH
98667: PPUSH
// if not hack in hackTanks then
98668: LD_VAR 0 1
98672: PUSH
98673: LD_EXP 165
98677: IN
98678: NOT
98679: IFFALSE 98683
// exit ;
98681: GO 98794
// index := GetElementIndex ( hackTanks , hack ) ;
98683: LD_ADDR_VAR 0 4
98687: PUSH
98688: LD_EXP 165
98692: PPUSH
98693: LD_VAR 0 1
98697: PPUSH
98698: CALL 52116 0 2
98702: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
98703: LD_EXP 166
98707: PUSH
98708: LD_VAR 0 4
98712: ARRAY
98713: IFFALSE 98794
// begin for i in hackTanksCaptured [ index ] do
98715: LD_ADDR_VAR 0 3
98719: PUSH
98720: LD_EXP 166
98724: PUSH
98725: LD_VAR 0 4
98729: ARRAY
98730: PUSH
98731: FOR_IN
98732: IFFALSE 98758
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
98734: LD_VAR 0 3
98738: PUSH
98739: LD_INT 1
98741: ARRAY
98742: PPUSH
98743: LD_VAR 0 3
98747: PUSH
98748: LD_INT 2
98750: ARRAY
98751: PPUSH
98752: CALL_OW 235
98756: GO 98731
98758: POP
98759: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
98760: LD_ADDR_EXP 166
98764: PUSH
98765: LD_EXP 166
98769: PPUSH
98770: LD_VAR 0 4
98774: PPUSH
98775: EMPTY
98776: PPUSH
98777: CALL_OW 1
98781: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
98782: LD_VAR 0 1
98786: PPUSH
98787: LD_INT 0
98789: PPUSH
98790: CALL_OW 505
// end ; end ;
98794: LD_VAR 0 2
98798: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
98799: LD_INT 0
98801: PPUSH
98802: PPUSH
98803: PPUSH
// if not hack in hackTanks or not vehicles then
98804: LD_VAR 0 1
98808: PUSH
98809: LD_EXP 165
98813: IN
98814: NOT
98815: PUSH
98816: LD_VAR 0 2
98820: NOT
98821: OR
98822: IFFALSE 98826
// exit ;
98824: GO 99101
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
98826: LD_ADDR_VAR 0 2
98830: PUSH
98831: LD_VAR 0 1
98835: PPUSH
98836: LD_VAR 0 2
98840: PPUSH
98841: LD_INT 1
98843: PPUSH
98844: LD_INT 1
98846: PPUSH
98847: CALL 52766 0 4
98851: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
98852: LD_ADDR_VAR 0 5
98856: PUSH
98857: LD_EXP 165
98861: PPUSH
98862: LD_VAR 0 1
98866: PPUSH
98867: CALL 52116 0 2
98871: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
98872: LD_EXP 166
98876: PUSH
98877: LD_VAR 0 5
98881: ARRAY
98882: PUSH
98883: LD_EXP 167
98887: LESS
98888: IFFALSE 99077
// begin for i := 1 to vehicles do
98890: LD_ADDR_VAR 0 4
98894: PUSH
98895: DOUBLE
98896: LD_INT 1
98898: DEC
98899: ST_TO_ADDR
98900: LD_VAR 0 2
98904: PUSH
98905: FOR_TO
98906: IFFALSE 99075
// begin if hackTanksCaptured [ index ] = hackLimit then
98908: LD_EXP 166
98912: PUSH
98913: LD_VAR 0 5
98917: ARRAY
98918: PUSH
98919: LD_EXP 167
98923: EQUAL
98924: IFFALSE 98928
// break ;
98926: GO 99075
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
98928: LD_ADDR_EXP 169
98932: PUSH
98933: LD_EXP 169
98937: PPUSH
98938: LD_VAR 0 5
98942: PPUSH
98943: LD_EXP 169
98947: PUSH
98948: LD_VAR 0 5
98952: ARRAY
98953: PUSH
98954: LD_INT 1
98956: PLUS
98957: PPUSH
98958: CALL_OW 1
98962: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
98963: LD_ADDR_EXP 166
98967: PUSH
98968: LD_EXP 166
98972: PPUSH
98973: LD_VAR 0 5
98977: PUSH
98978: LD_EXP 166
98982: PUSH
98983: LD_VAR 0 5
98987: ARRAY
98988: PUSH
98989: LD_INT 1
98991: PLUS
98992: PUSH
98993: EMPTY
98994: LIST
98995: LIST
98996: PPUSH
98997: LD_VAR 0 2
99001: PUSH
99002: LD_VAR 0 4
99006: ARRAY
99007: PUSH
99008: LD_VAR 0 2
99012: PUSH
99013: LD_VAR 0 4
99017: ARRAY
99018: PPUSH
99019: CALL_OW 255
99023: PUSH
99024: EMPTY
99025: LIST
99026: LIST
99027: PPUSH
99028: CALL 52331 0 3
99032: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
99033: LD_VAR 0 2
99037: PUSH
99038: LD_VAR 0 4
99042: ARRAY
99043: PPUSH
99044: LD_VAR 0 1
99048: PPUSH
99049: CALL_OW 255
99053: PPUSH
99054: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
99058: LD_VAR 0 2
99062: PUSH
99063: LD_VAR 0 4
99067: ARRAY
99068: PPUSH
99069: CALL_OW 141
// end ;
99073: GO 98905
99075: POP
99076: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99077: LD_VAR 0 1
99081: PPUSH
99082: LD_EXP 166
99086: PUSH
99087: LD_VAR 0 5
99091: ARRAY
99092: PUSH
99093: LD_INT 0
99095: PLUS
99096: PPUSH
99097: CALL_OW 505
// end ;
99101: LD_VAR 0 3
99105: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
99106: LD_INT 0
99108: PPUSH
99109: PPUSH
99110: PPUSH
99111: PPUSH
// if not hack in hackTanks then
99112: LD_VAR 0 1
99116: PUSH
99117: LD_EXP 165
99121: IN
99122: NOT
99123: IFFALSE 99127
// exit ;
99125: GO 99367
// index := GetElementIndex ( hackTanks , hack ) ;
99127: LD_ADDR_VAR 0 4
99131: PUSH
99132: LD_EXP 165
99136: PPUSH
99137: LD_VAR 0 1
99141: PPUSH
99142: CALL 52116 0 2
99146: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
99147: LD_ADDR_VAR 0 3
99151: PUSH
99152: DOUBLE
99153: LD_EXP 166
99157: PUSH
99158: LD_VAR 0 4
99162: ARRAY
99163: INC
99164: ST_TO_ADDR
99165: LD_INT 1
99167: PUSH
99168: FOR_DOWNTO
99169: IFFALSE 99341
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
99171: LD_ADDR_VAR 0 5
99175: PUSH
99176: LD_EXP 166
99180: PUSH
99181: LD_VAR 0 4
99185: ARRAY
99186: PUSH
99187: LD_VAR 0 3
99191: ARRAY
99192: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
99193: LD_VAR 0 5
99197: PUSH
99198: LD_INT 1
99200: ARRAY
99201: PPUSH
99202: CALL_OW 302
99206: NOT
99207: PUSH
99208: LD_VAR 0 5
99212: PUSH
99213: LD_INT 1
99215: ARRAY
99216: PPUSH
99217: CALL_OW 255
99221: PUSH
99222: LD_VAR 0 1
99226: PPUSH
99227: CALL_OW 255
99231: NONEQUAL
99232: OR
99233: IFFALSE 99339
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
99235: LD_VAR 0 5
99239: PUSH
99240: LD_INT 1
99242: ARRAY
99243: PPUSH
99244: CALL_OW 305
99248: PUSH
99249: LD_VAR 0 5
99253: PUSH
99254: LD_INT 1
99256: ARRAY
99257: PPUSH
99258: CALL_OW 255
99262: PUSH
99263: LD_VAR 0 1
99267: PPUSH
99268: CALL_OW 255
99272: EQUAL
99273: AND
99274: IFFALSE 99298
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
99276: LD_VAR 0 5
99280: PUSH
99281: LD_INT 1
99283: ARRAY
99284: PPUSH
99285: LD_VAR 0 5
99289: PUSH
99290: LD_INT 2
99292: ARRAY
99293: PPUSH
99294: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
99298: LD_ADDR_EXP 166
99302: PUSH
99303: LD_EXP 166
99307: PPUSH
99308: LD_VAR 0 4
99312: PPUSH
99313: LD_EXP 166
99317: PUSH
99318: LD_VAR 0 4
99322: ARRAY
99323: PPUSH
99324: LD_VAR 0 3
99328: PPUSH
99329: CALL_OW 3
99333: PPUSH
99334: CALL_OW 1
99338: ST_TO_ADDR
// end ; end ;
99339: GO 99168
99341: POP
99342: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99343: LD_VAR 0 1
99347: PPUSH
99348: LD_EXP 166
99352: PUSH
99353: LD_VAR 0 4
99357: ARRAY
99358: PUSH
99359: LD_INT 0
99361: PLUS
99362: PPUSH
99363: CALL_OW 505
// end ;
99367: LD_VAR 0 2
99371: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
99372: LD_INT 0
99374: PPUSH
99375: PPUSH
99376: PPUSH
99377: PPUSH
// if not hack in hackTanks then
99378: LD_VAR 0 1
99382: PUSH
99383: LD_EXP 165
99387: IN
99388: NOT
99389: IFFALSE 99393
// exit ;
99391: GO 99478
// index := GetElementIndex ( hackTanks , hack ) ;
99393: LD_ADDR_VAR 0 5
99397: PUSH
99398: LD_EXP 165
99402: PPUSH
99403: LD_VAR 0 1
99407: PPUSH
99408: CALL 52116 0 2
99412: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
99413: LD_ADDR_VAR 0 4
99417: PUSH
99418: DOUBLE
99419: LD_INT 1
99421: DEC
99422: ST_TO_ADDR
99423: LD_EXP 166
99427: PUSH
99428: LD_VAR 0 5
99432: ARRAY
99433: PUSH
99434: FOR_TO
99435: IFFALSE 99476
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
99437: LD_EXP 166
99441: PUSH
99442: LD_VAR 0 5
99446: ARRAY
99447: PUSH
99448: LD_VAR 0 4
99452: ARRAY
99453: PUSH
99454: LD_INT 1
99456: ARRAY
99457: PUSH
99458: LD_VAR 0 2
99462: EQUAL
99463: IFFALSE 99474
// KillUnit ( vehicle ) ;
99465: LD_VAR 0 2
99469: PPUSH
99470: CALL_OW 66
99474: GO 99434
99476: POP
99477: POP
// end ;
99478: LD_VAR 0 3
99482: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
99483: LD_EXP 170
99487: NOT
99488: IFFALSE 99523
99490: GO 99492
99492: DISABLE
// begin initMiner := true ;
99493: LD_ADDR_EXP 170
99497: PUSH
99498: LD_INT 1
99500: ST_TO_ADDR
// minersList := [ ] ;
99501: LD_ADDR_EXP 171
99505: PUSH
99506: EMPTY
99507: ST_TO_ADDR
// minerMinesList := [ ] ;
99508: LD_ADDR_EXP 172
99512: PUSH
99513: EMPTY
99514: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
99515: LD_ADDR_EXP 173
99519: PUSH
99520: LD_INT 5
99522: ST_TO_ADDR
// end ;
99523: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
99524: LD_EXP 170
99528: PUSH
99529: LD_INT 34
99531: PUSH
99532: LD_EXP 100
99536: PUSH
99537: EMPTY
99538: LIST
99539: LIST
99540: PPUSH
99541: CALL_OW 69
99545: AND
99546: IFFALSE 100009
99548: GO 99550
99550: DISABLE
99551: LD_INT 0
99553: PPUSH
99554: PPUSH
99555: PPUSH
99556: PPUSH
// begin enable ;
99557: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
99558: LD_ADDR_VAR 0 1
99562: PUSH
99563: LD_INT 34
99565: PUSH
99566: LD_EXP 100
99570: PUSH
99571: EMPTY
99572: LIST
99573: LIST
99574: PPUSH
99575: CALL_OW 69
99579: PUSH
99580: FOR_IN
99581: IFFALSE 99653
// begin if not i in minersList then
99583: LD_VAR 0 1
99587: PUSH
99588: LD_EXP 171
99592: IN
99593: NOT
99594: IFFALSE 99651
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
99596: LD_ADDR_EXP 171
99600: PUSH
99601: LD_EXP 171
99605: PPUSH
99606: LD_EXP 171
99610: PUSH
99611: LD_INT 1
99613: PLUS
99614: PPUSH
99615: LD_VAR 0 1
99619: PPUSH
99620: CALL_OW 1
99624: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
99625: LD_ADDR_EXP 172
99629: PUSH
99630: LD_EXP 172
99634: PPUSH
99635: LD_EXP 172
99639: PUSH
99640: LD_INT 1
99642: PLUS
99643: PPUSH
99644: EMPTY
99645: PPUSH
99646: CALL_OW 1
99650: ST_TO_ADDR
// end end ;
99651: GO 99580
99653: POP
99654: POP
// for i := minerMinesList downto 1 do
99655: LD_ADDR_VAR 0 1
99659: PUSH
99660: DOUBLE
99661: LD_EXP 172
99665: INC
99666: ST_TO_ADDR
99667: LD_INT 1
99669: PUSH
99670: FOR_DOWNTO
99671: IFFALSE 100007
// begin if IsLive ( minersList [ i ] ) then
99673: LD_EXP 171
99677: PUSH
99678: LD_VAR 0 1
99682: ARRAY
99683: PPUSH
99684: CALL_OW 300
99688: IFFALSE 99716
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
99690: LD_EXP 171
99694: PUSH
99695: LD_VAR 0 1
99699: ARRAY
99700: PPUSH
99701: LD_EXP 172
99705: PUSH
99706: LD_VAR 0 1
99710: ARRAY
99711: PPUSH
99712: CALL_OW 505
// if not minerMinesList [ i ] then
99716: LD_EXP 172
99720: PUSH
99721: LD_VAR 0 1
99725: ARRAY
99726: NOT
99727: IFFALSE 99731
// continue ;
99729: GO 99670
// for j := minerMinesList [ i ] downto 1 do
99731: LD_ADDR_VAR 0 2
99735: PUSH
99736: DOUBLE
99737: LD_EXP 172
99741: PUSH
99742: LD_VAR 0 1
99746: ARRAY
99747: INC
99748: ST_TO_ADDR
99749: LD_INT 1
99751: PUSH
99752: FOR_DOWNTO
99753: IFFALSE 100003
// begin side := GetSide ( minersList [ i ] ) ;
99755: LD_ADDR_VAR 0 3
99759: PUSH
99760: LD_EXP 171
99764: PUSH
99765: LD_VAR 0 1
99769: ARRAY
99770: PPUSH
99771: CALL_OW 255
99775: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
99776: LD_ADDR_VAR 0 4
99780: PUSH
99781: LD_EXP 172
99785: PUSH
99786: LD_VAR 0 1
99790: ARRAY
99791: PUSH
99792: LD_VAR 0 2
99796: ARRAY
99797: PUSH
99798: LD_INT 1
99800: ARRAY
99801: PPUSH
99802: LD_EXP 172
99806: PUSH
99807: LD_VAR 0 1
99811: ARRAY
99812: PUSH
99813: LD_VAR 0 2
99817: ARRAY
99818: PUSH
99819: LD_INT 2
99821: ARRAY
99822: PPUSH
99823: CALL_OW 428
99827: ST_TO_ADDR
// if not tmp then
99828: LD_VAR 0 4
99832: NOT
99833: IFFALSE 99837
// continue ;
99835: GO 99752
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
99837: LD_VAR 0 4
99841: PUSH
99842: LD_INT 81
99844: PUSH
99845: LD_VAR 0 3
99849: PUSH
99850: EMPTY
99851: LIST
99852: LIST
99853: PPUSH
99854: CALL_OW 69
99858: IN
99859: PUSH
99860: LD_EXP 172
99864: PUSH
99865: LD_VAR 0 1
99869: ARRAY
99870: PUSH
99871: LD_VAR 0 2
99875: ARRAY
99876: PUSH
99877: LD_INT 1
99879: ARRAY
99880: PPUSH
99881: LD_EXP 172
99885: PUSH
99886: LD_VAR 0 1
99890: ARRAY
99891: PUSH
99892: LD_VAR 0 2
99896: ARRAY
99897: PUSH
99898: LD_INT 2
99900: ARRAY
99901: PPUSH
99902: CALL_OW 458
99906: AND
99907: IFFALSE 100001
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
99909: LD_EXP 172
99913: PUSH
99914: LD_VAR 0 1
99918: ARRAY
99919: PUSH
99920: LD_VAR 0 2
99924: ARRAY
99925: PUSH
99926: LD_INT 1
99928: ARRAY
99929: PPUSH
99930: LD_EXP 172
99934: PUSH
99935: LD_VAR 0 1
99939: ARRAY
99940: PUSH
99941: LD_VAR 0 2
99945: ARRAY
99946: PUSH
99947: LD_INT 2
99949: ARRAY
99950: PPUSH
99951: LD_VAR 0 3
99955: PPUSH
99956: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
99960: LD_ADDR_EXP 172
99964: PUSH
99965: LD_EXP 172
99969: PPUSH
99970: LD_VAR 0 1
99974: PPUSH
99975: LD_EXP 172
99979: PUSH
99980: LD_VAR 0 1
99984: ARRAY
99985: PPUSH
99986: LD_VAR 0 2
99990: PPUSH
99991: CALL_OW 3
99995: PPUSH
99996: CALL_OW 1
100000: ST_TO_ADDR
// end ; end ;
100001: GO 99752
100003: POP
100004: POP
// end ;
100005: GO 99670
100007: POP
100008: POP
// end ;
100009: PPOPN 4
100011: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
100012: LD_INT 0
100014: PPUSH
100015: PPUSH
// result := false ;
100016: LD_ADDR_VAR 0 4
100020: PUSH
100021: LD_INT 0
100023: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
100024: LD_VAR 0 1
100028: PPUSH
100029: CALL_OW 264
100033: PUSH
100034: LD_EXP 100
100038: EQUAL
100039: NOT
100040: IFFALSE 100044
// exit ;
100042: GO 100284
// index := GetElementIndex ( minersList , unit ) ;
100044: LD_ADDR_VAR 0 5
100048: PUSH
100049: LD_EXP 171
100053: PPUSH
100054: LD_VAR 0 1
100058: PPUSH
100059: CALL 52116 0 2
100063: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
100064: LD_EXP 172
100068: PUSH
100069: LD_VAR 0 5
100073: ARRAY
100074: PUSH
100075: LD_EXP 173
100079: GREATEREQUAL
100080: IFFALSE 100084
// exit ;
100082: GO 100284
// ComMoveXY ( unit , x , y ) ;
100084: LD_VAR 0 1
100088: PPUSH
100089: LD_VAR 0 2
100093: PPUSH
100094: LD_VAR 0 3
100098: PPUSH
100099: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
100103: LD_INT 35
100105: PPUSH
100106: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
100110: LD_VAR 0 1
100114: PPUSH
100115: LD_VAR 0 2
100119: PPUSH
100120: LD_VAR 0 3
100124: PPUSH
100125: CALL 82180 0 3
100129: NOT
100130: PUSH
100131: LD_VAR 0 1
100135: PPUSH
100136: CALL_OW 314
100140: AND
100141: IFFALSE 100145
// exit ;
100143: GO 100284
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
100145: LD_VAR 0 2
100149: PPUSH
100150: LD_VAR 0 3
100154: PPUSH
100155: CALL_OW 428
100159: PUSH
100160: LD_VAR 0 1
100164: EQUAL
100165: PUSH
100166: LD_VAR 0 1
100170: PPUSH
100171: CALL_OW 314
100175: NOT
100176: AND
100177: IFFALSE 100103
// PlaySoundXY ( x , y , PlantMine ) ;
100179: LD_VAR 0 2
100183: PPUSH
100184: LD_VAR 0 3
100188: PPUSH
100189: LD_STRING PlantMine
100191: PPUSH
100192: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
100196: LD_VAR 0 2
100200: PPUSH
100201: LD_VAR 0 3
100205: PPUSH
100206: LD_VAR 0 1
100210: PPUSH
100211: CALL_OW 255
100215: PPUSH
100216: LD_INT 0
100218: PPUSH
100219: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
100223: LD_ADDR_EXP 172
100227: PUSH
100228: LD_EXP 172
100232: PPUSH
100233: LD_VAR 0 5
100237: PUSH
100238: LD_EXP 172
100242: PUSH
100243: LD_VAR 0 5
100247: ARRAY
100248: PUSH
100249: LD_INT 1
100251: PLUS
100252: PUSH
100253: EMPTY
100254: LIST
100255: LIST
100256: PPUSH
100257: LD_VAR 0 2
100261: PUSH
100262: LD_VAR 0 3
100266: PUSH
100267: EMPTY
100268: LIST
100269: LIST
100270: PPUSH
100271: CALL 52331 0 3
100275: ST_TO_ADDR
// result := true ;
100276: LD_ADDR_VAR 0 4
100280: PUSH
100281: LD_INT 1
100283: ST_TO_ADDR
// end ;
100284: LD_VAR 0 4
100288: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
100289: LD_INT 0
100291: PPUSH
100292: PPUSH
100293: PPUSH
// if not unit in minersList then
100294: LD_VAR 0 1
100298: PUSH
100299: LD_EXP 171
100303: IN
100304: NOT
100305: IFFALSE 100309
// exit ;
100307: GO 100701
// index := GetElementIndex ( minersList , unit ) ;
100309: LD_ADDR_VAR 0 6
100313: PUSH
100314: LD_EXP 171
100318: PPUSH
100319: LD_VAR 0 1
100323: PPUSH
100324: CALL 52116 0 2
100328: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
100329: LD_ADDR_VAR 0 5
100333: PUSH
100334: DOUBLE
100335: LD_EXP 172
100339: PUSH
100340: LD_VAR 0 6
100344: ARRAY
100345: INC
100346: ST_TO_ADDR
100347: LD_INT 1
100349: PUSH
100350: FOR_DOWNTO
100351: IFFALSE 100512
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
100353: LD_EXP 172
100357: PUSH
100358: LD_VAR 0 6
100362: ARRAY
100363: PUSH
100364: LD_VAR 0 5
100368: ARRAY
100369: PUSH
100370: LD_INT 1
100372: ARRAY
100373: PUSH
100374: LD_VAR 0 2
100378: EQUAL
100379: PUSH
100380: LD_EXP 172
100384: PUSH
100385: LD_VAR 0 6
100389: ARRAY
100390: PUSH
100391: LD_VAR 0 5
100395: ARRAY
100396: PUSH
100397: LD_INT 2
100399: ARRAY
100400: PUSH
100401: LD_VAR 0 3
100405: EQUAL
100406: AND
100407: IFFALSE 100510
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
100409: LD_EXP 172
100413: PUSH
100414: LD_VAR 0 6
100418: ARRAY
100419: PUSH
100420: LD_VAR 0 5
100424: ARRAY
100425: PUSH
100426: LD_INT 1
100428: ARRAY
100429: PPUSH
100430: LD_EXP 172
100434: PUSH
100435: LD_VAR 0 6
100439: ARRAY
100440: PUSH
100441: LD_VAR 0 5
100445: ARRAY
100446: PUSH
100447: LD_INT 2
100449: ARRAY
100450: PPUSH
100451: LD_VAR 0 1
100455: PPUSH
100456: CALL_OW 255
100460: PPUSH
100461: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
100465: LD_ADDR_EXP 172
100469: PUSH
100470: LD_EXP 172
100474: PPUSH
100475: LD_VAR 0 6
100479: PPUSH
100480: LD_EXP 172
100484: PUSH
100485: LD_VAR 0 6
100489: ARRAY
100490: PPUSH
100491: LD_VAR 0 5
100495: PPUSH
100496: CALL_OW 3
100500: PPUSH
100501: CALL_OW 1
100505: ST_TO_ADDR
// exit ;
100506: POP
100507: POP
100508: GO 100701
// end ; end ;
100510: GO 100350
100512: POP
100513: POP
// for i := minerMinesList [ index ] downto 1 do
100514: LD_ADDR_VAR 0 5
100518: PUSH
100519: DOUBLE
100520: LD_EXP 172
100524: PUSH
100525: LD_VAR 0 6
100529: ARRAY
100530: INC
100531: ST_TO_ADDR
100532: LD_INT 1
100534: PUSH
100535: FOR_DOWNTO
100536: IFFALSE 100699
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
100538: LD_EXP 172
100542: PUSH
100543: LD_VAR 0 6
100547: ARRAY
100548: PUSH
100549: LD_VAR 0 5
100553: ARRAY
100554: PUSH
100555: LD_INT 1
100557: ARRAY
100558: PPUSH
100559: LD_EXP 172
100563: PUSH
100564: LD_VAR 0 6
100568: ARRAY
100569: PUSH
100570: LD_VAR 0 5
100574: ARRAY
100575: PUSH
100576: LD_INT 2
100578: ARRAY
100579: PPUSH
100580: LD_VAR 0 2
100584: PPUSH
100585: LD_VAR 0 3
100589: PPUSH
100590: CALL_OW 298
100594: PUSH
100595: LD_INT 6
100597: LESS
100598: IFFALSE 100697
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
100600: LD_EXP 172
100604: PUSH
100605: LD_VAR 0 6
100609: ARRAY
100610: PUSH
100611: LD_VAR 0 5
100615: ARRAY
100616: PUSH
100617: LD_INT 1
100619: ARRAY
100620: PPUSH
100621: LD_EXP 172
100625: PUSH
100626: LD_VAR 0 6
100630: ARRAY
100631: PUSH
100632: LD_VAR 0 5
100636: ARRAY
100637: PUSH
100638: LD_INT 2
100640: ARRAY
100641: PPUSH
100642: LD_VAR 0 1
100646: PPUSH
100647: CALL_OW 255
100651: PPUSH
100652: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
100656: LD_ADDR_EXP 172
100660: PUSH
100661: LD_EXP 172
100665: PPUSH
100666: LD_VAR 0 6
100670: PPUSH
100671: LD_EXP 172
100675: PUSH
100676: LD_VAR 0 6
100680: ARRAY
100681: PPUSH
100682: LD_VAR 0 5
100686: PPUSH
100687: CALL_OW 3
100691: PPUSH
100692: CALL_OW 1
100696: ST_TO_ADDR
// end ; end ;
100697: GO 100535
100699: POP
100700: POP
// end ;
100701: LD_VAR 0 4
100705: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
100706: LD_INT 0
100708: PPUSH
100709: PPUSH
100710: PPUSH
100711: PPUSH
100712: PPUSH
100713: PPUSH
100714: PPUSH
100715: PPUSH
100716: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
100717: LD_VAR 0 1
100721: PPUSH
100722: CALL_OW 264
100726: PUSH
100727: LD_EXP 100
100731: EQUAL
100732: NOT
100733: PUSH
100734: LD_VAR 0 1
100738: PUSH
100739: LD_EXP 171
100743: IN
100744: NOT
100745: OR
100746: IFFALSE 100750
// exit ;
100748: GO 101072
// index := GetElementIndex ( minersList , unit ) ;
100750: LD_ADDR_VAR 0 6
100754: PUSH
100755: LD_EXP 171
100759: PPUSH
100760: LD_VAR 0 1
100764: PPUSH
100765: CALL 52116 0 2
100769: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
100770: LD_ADDR_VAR 0 8
100774: PUSH
100775: LD_EXP 173
100779: PUSH
100780: LD_EXP 172
100784: PUSH
100785: LD_VAR 0 6
100789: ARRAY
100790: MINUS
100791: ST_TO_ADDR
// if not minesFreeAmount then
100792: LD_VAR 0 8
100796: NOT
100797: IFFALSE 100801
// exit ;
100799: GO 101072
// tmp := [ ] ;
100801: LD_ADDR_VAR 0 7
100805: PUSH
100806: EMPTY
100807: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
100808: LD_ADDR_VAR 0 5
100812: PUSH
100813: DOUBLE
100814: LD_INT 1
100816: DEC
100817: ST_TO_ADDR
100818: LD_VAR 0 8
100822: PUSH
100823: FOR_TO
100824: IFFALSE 101019
// begin _d := rand ( 0 , 5 ) ;
100826: LD_ADDR_VAR 0 11
100830: PUSH
100831: LD_INT 0
100833: PPUSH
100834: LD_INT 5
100836: PPUSH
100837: CALL_OW 12
100841: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
100842: LD_ADDR_VAR 0 12
100846: PUSH
100847: LD_INT 2
100849: PPUSH
100850: LD_INT 6
100852: PPUSH
100853: CALL_OW 12
100857: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
100858: LD_ADDR_VAR 0 9
100862: PUSH
100863: LD_VAR 0 2
100867: PPUSH
100868: LD_VAR 0 11
100872: PPUSH
100873: LD_VAR 0 12
100877: PPUSH
100878: CALL_OW 272
100882: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
100883: LD_ADDR_VAR 0 10
100887: PUSH
100888: LD_VAR 0 3
100892: PPUSH
100893: LD_VAR 0 11
100897: PPUSH
100898: LD_VAR 0 12
100902: PPUSH
100903: CALL_OW 273
100907: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
100908: LD_VAR 0 9
100912: PPUSH
100913: LD_VAR 0 10
100917: PPUSH
100918: CALL_OW 488
100922: PUSH
100923: LD_VAR 0 9
100927: PUSH
100928: LD_VAR 0 10
100932: PUSH
100933: EMPTY
100934: LIST
100935: LIST
100936: PUSH
100937: LD_VAR 0 7
100941: IN
100942: NOT
100943: AND
100944: PUSH
100945: LD_VAR 0 9
100949: PPUSH
100950: LD_VAR 0 10
100954: PPUSH
100955: CALL_OW 458
100959: NOT
100960: AND
100961: IFFALSE 101003
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
100963: LD_ADDR_VAR 0 7
100967: PUSH
100968: LD_VAR 0 7
100972: PPUSH
100973: LD_VAR 0 7
100977: PUSH
100978: LD_INT 1
100980: PLUS
100981: PPUSH
100982: LD_VAR 0 9
100986: PUSH
100987: LD_VAR 0 10
100991: PUSH
100992: EMPTY
100993: LIST
100994: LIST
100995: PPUSH
100996: CALL_OW 1
101000: ST_TO_ADDR
101001: GO 101017
// i := i - 1 ;
101003: LD_ADDR_VAR 0 5
101007: PUSH
101008: LD_VAR 0 5
101012: PUSH
101013: LD_INT 1
101015: MINUS
101016: ST_TO_ADDR
// end ;
101017: GO 100823
101019: POP
101020: POP
// for i in tmp do
101021: LD_ADDR_VAR 0 5
101025: PUSH
101026: LD_VAR 0 7
101030: PUSH
101031: FOR_IN
101032: IFFALSE 101070
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
101034: LD_VAR 0 1
101038: PPUSH
101039: LD_VAR 0 5
101043: PUSH
101044: LD_INT 1
101046: ARRAY
101047: PPUSH
101048: LD_VAR 0 5
101052: PUSH
101053: LD_INT 2
101055: ARRAY
101056: PPUSH
101057: CALL 100012 0 3
101061: NOT
101062: IFFALSE 101068
// exit ;
101064: POP
101065: POP
101066: GO 101072
101068: GO 101031
101070: POP
101071: POP
// end ;
101072: LD_VAR 0 4
101076: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
101077: LD_INT 0
101079: PPUSH
101080: PPUSH
101081: PPUSH
101082: PPUSH
101083: PPUSH
101084: PPUSH
101085: PPUSH
// if not GetClass ( unit ) = class_sniper then
101086: LD_VAR 0 1
101090: PPUSH
101091: CALL_OW 257
101095: PUSH
101096: LD_INT 5
101098: EQUAL
101099: NOT
101100: IFFALSE 101104
// exit ;
101102: GO 101492
// dist := 8 ;
101104: LD_ADDR_VAR 0 5
101108: PUSH
101109: LD_INT 8
101111: ST_TO_ADDR
// viewRange := 12 ;
101112: LD_ADDR_VAR 0 7
101116: PUSH
101117: LD_INT 12
101119: ST_TO_ADDR
// side := GetSide ( unit ) ;
101120: LD_ADDR_VAR 0 6
101124: PUSH
101125: LD_VAR 0 1
101129: PPUSH
101130: CALL_OW 255
101134: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
101135: LD_INT 61
101137: PPUSH
101138: LD_VAR 0 6
101142: PPUSH
101143: CALL_OW 321
101147: PUSH
101148: LD_INT 2
101150: EQUAL
101151: IFFALSE 101161
// viewRange := 16 ;
101153: LD_ADDR_VAR 0 7
101157: PUSH
101158: LD_INT 16
101160: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
101161: LD_VAR 0 1
101165: PPUSH
101166: LD_VAR 0 2
101170: PPUSH
101171: LD_VAR 0 3
101175: PPUSH
101176: CALL_OW 297
101180: PUSH
101181: LD_VAR 0 5
101185: GREATER
101186: IFFALSE 101265
// begin ComMoveXY ( unit , x , y ) ;
101188: LD_VAR 0 1
101192: PPUSH
101193: LD_VAR 0 2
101197: PPUSH
101198: LD_VAR 0 3
101202: PPUSH
101203: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
101207: LD_INT 35
101209: PPUSH
101210: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
101214: LD_VAR 0 1
101218: PPUSH
101219: LD_VAR 0 2
101223: PPUSH
101224: LD_VAR 0 3
101228: PPUSH
101229: CALL 82180 0 3
101233: NOT
101234: IFFALSE 101238
// exit ;
101236: GO 101492
// until GetDistUnitXY ( unit , x , y ) < dist ;
101238: LD_VAR 0 1
101242: PPUSH
101243: LD_VAR 0 2
101247: PPUSH
101248: LD_VAR 0 3
101252: PPUSH
101253: CALL_OW 297
101257: PUSH
101258: LD_VAR 0 5
101262: LESS
101263: IFFALSE 101207
// end ; ComTurnXY ( unit , x , y ) ;
101265: LD_VAR 0 1
101269: PPUSH
101270: LD_VAR 0 2
101274: PPUSH
101275: LD_VAR 0 3
101279: PPUSH
101280: CALL_OW 118
// wait ( 5 ) ;
101284: LD_INT 5
101286: PPUSH
101287: CALL_OW 67
// _d := GetDir ( unit ) ;
101291: LD_ADDR_VAR 0 10
101295: PUSH
101296: LD_VAR 0 1
101300: PPUSH
101301: CALL_OW 254
101305: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
101306: LD_ADDR_VAR 0 8
101310: PUSH
101311: LD_VAR 0 1
101315: PPUSH
101316: CALL_OW 250
101320: PPUSH
101321: LD_VAR 0 10
101325: PPUSH
101326: LD_VAR 0 5
101330: PPUSH
101331: CALL_OW 272
101335: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
101336: LD_ADDR_VAR 0 9
101340: PUSH
101341: LD_VAR 0 1
101345: PPUSH
101346: CALL_OW 251
101350: PPUSH
101351: LD_VAR 0 10
101355: PPUSH
101356: LD_VAR 0 5
101360: PPUSH
101361: CALL_OW 273
101365: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
101366: LD_VAR 0 8
101370: PPUSH
101371: LD_VAR 0 9
101375: PPUSH
101376: CALL_OW 488
101380: NOT
101381: IFFALSE 101385
// exit ;
101383: GO 101492
// ComAnimCustom ( unit , 1 ) ;
101385: LD_VAR 0 1
101389: PPUSH
101390: LD_INT 1
101392: PPUSH
101393: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
101397: LD_VAR 0 8
101401: PPUSH
101402: LD_VAR 0 9
101406: PPUSH
101407: LD_VAR 0 6
101411: PPUSH
101412: LD_VAR 0 7
101416: PPUSH
101417: CALL_OW 330
// repeat wait ( 1 ) ;
101421: LD_INT 1
101423: PPUSH
101424: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
101428: LD_VAR 0 1
101432: PPUSH
101433: CALL_OW 316
101437: PUSH
101438: LD_VAR 0 1
101442: PPUSH
101443: CALL_OW 314
101447: OR
101448: PUSH
101449: LD_VAR 0 1
101453: PPUSH
101454: CALL_OW 302
101458: NOT
101459: OR
101460: PUSH
101461: LD_VAR 0 1
101465: PPUSH
101466: CALL_OW 301
101470: OR
101471: IFFALSE 101421
// RemoveSeeing ( _x , _y , side ) ;
101473: LD_VAR 0 8
101477: PPUSH
101478: LD_VAR 0 9
101482: PPUSH
101483: LD_VAR 0 6
101487: PPUSH
101488: CALL_OW 331
// end ; end_of_file
101492: LD_VAR 0 4
101496: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
101497: LD_INT 0
101499: PPUSH
101500: PPUSH
101501: PPUSH
101502: PPUSH
101503: PPUSH
101504: PPUSH
101505: PPUSH
101506: PPUSH
101507: PPUSH
101508: PPUSH
101509: PPUSH
101510: PPUSH
101511: PPUSH
101512: PPUSH
101513: PPUSH
101514: PPUSH
101515: PPUSH
101516: PPUSH
101517: PPUSH
101518: PPUSH
101519: PPUSH
101520: PPUSH
101521: PPUSH
101522: PPUSH
101523: PPUSH
101524: PPUSH
101525: PPUSH
101526: PPUSH
101527: PPUSH
101528: PPUSH
101529: PPUSH
101530: PPUSH
101531: PPUSH
101532: PPUSH
// if not list then
101533: LD_VAR 0 1
101537: NOT
101538: IFFALSE 101542
// exit ;
101540: GO 106201
// base := list [ 1 ] ;
101542: LD_ADDR_VAR 0 3
101546: PUSH
101547: LD_VAR 0 1
101551: PUSH
101552: LD_INT 1
101554: ARRAY
101555: ST_TO_ADDR
// group := list [ 2 ] ;
101556: LD_ADDR_VAR 0 4
101560: PUSH
101561: LD_VAR 0 1
101565: PUSH
101566: LD_INT 2
101568: ARRAY
101569: ST_TO_ADDR
// path := list [ 3 ] ;
101570: LD_ADDR_VAR 0 5
101574: PUSH
101575: LD_VAR 0 1
101579: PUSH
101580: LD_INT 3
101582: ARRAY
101583: ST_TO_ADDR
// flags := list [ 4 ] ;
101584: LD_ADDR_VAR 0 6
101588: PUSH
101589: LD_VAR 0 1
101593: PUSH
101594: LD_INT 4
101596: ARRAY
101597: ST_TO_ADDR
// mined := [ ] ;
101598: LD_ADDR_VAR 0 27
101602: PUSH
101603: EMPTY
101604: ST_TO_ADDR
// bombed := [ ] ;
101605: LD_ADDR_VAR 0 28
101609: PUSH
101610: EMPTY
101611: ST_TO_ADDR
// healers := [ ] ;
101612: LD_ADDR_VAR 0 31
101616: PUSH
101617: EMPTY
101618: ST_TO_ADDR
// to_heal := [ ] ;
101619: LD_ADDR_VAR 0 30
101623: PUSH
101624: EMPTY
101625: ST_TO_ADDR
// repairs := [ ] ;
101626: LD_ADDR_VAR 0 33
101630: PUSH
101631: EMPTY
101632: ST_TO_ADDR
// to_repair := [ ] ;
101633: LD_ADDR_VAR 0 32
101637: PUSH
101638: EMPTY
101639: ST_TO_ADDR
// if not group or not path then
101640: LD_VAR 0 4
101644: NOT
101645: PUSH
101646: LD_VAR 0 5
101650: NOT
101651: OR
101652: IFFALSE 101656
// exit ;
101654: GO 106201
// side := GetSide ( group [ 1 ] ) ;
101656: LD_ADDR_VAR 0 35
101660: PUSH
101661: LD_VAR 0 4
101665: PUSH
101666: LD_INT 1
101668: ARRAY
101669: PPUSH
101670: CALL_OW 255
101674: ST_TO_ADDR
// if flags then
101675: LD_VAR 0 6
101679: IFFALSE 101823
// begin f_ignore_area := flags [ 1 ] ;
101681: LD_ADDR_VAR 0 17
101685: PUSH
101686: LD_VAR 0 6
101690: PUSH
101691: LD_INT 1
101693: ARRAY
101694: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
101695: LD_ADDR_VAR 0 18
101699: PUSH
101700: LD_VAR 0 6
101704: PUSH
101705: LD_INT 2
101707: ARRAY
101708: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
101709: LD_ADDR_VAR 0 19
101713: PUSH
101714: LD_VAR 0 6
101718: PUSH
101719: LD_INT 3
101721: ARRAY
101722: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
101723: LD_ADDR_VAR 0 20
101727: PUSH
101728: LD_VAR 0 6
101732: PUSH
101733: LD_INT 4
101735: ARRAY
101736: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
101737: LD_ADDR_VAR 0 21
101741: PUSH
101742: LD_VAR 0 6
101746: PUSH
101747: LD_INT 5
101749: ARRAY
101750: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
101751: LD_ADDR_VAR 0 22
101755: PUSH
101756: LD_VAR 0 6
101760: PUSH
101761: LD_INT 6
101763: ARRAY
101764: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
101765: LD_ADDR_VAR 0 23
101769: PUSH
101770: LD_VAR 0 6
101774: PUSH
101775: LD_INT 7
101777: ARRAY
101778: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
101779: LD_ADDR_VAR 0 24
101783: PUSH
101784: LD_VAR 0 6
101788: PUSH
101789: LD_INT 8
101791: ARRAY
101792: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
101793: LD_ADDR_VAR 0 25
101797: PUSH
101798: LD_VAR 0 6
101802: PUSH
101803: LD_INT 9
101805: ARRAY
101806: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
101807: LD_ADDR_VAR 0 26
101811: PUSH
101812: LD_VAR 0 6
101816: PUSH
101817: LD_INT 10
101819: ARRAY
101820: ST_TO_ADDR
// end else
101821: GO 101903
// begin f_ignore_area := false ;
101823: LD_ADDR_VAR 0 17
101827: PUSH
101828: LD_INT 0
101830: ST_TO_ADDR
// f_capture := false ;
101831: LD_ADDR_VAR 0 18
101835: PUSH
101836: LD_INT 0
101838: ST_TO_ADDR
// f_ignore_civ := false ;
101839: LD_ADDR_VAR 0 19
101843: PUSH
101844: LD_INT 0
101846: ST_TO_ADDR
// f_murder := false ;
101847: LD_ADDR_VAR 0 20
101851: PUSH
101852: LD_INT 0
101854: ST_TO_ADDR
// f_mines := false ;
101855: LD_ADDR_VAR 0 21
101859: PUSH
101860: LD_INT 0
101862: ST_TO_ADDR
// f_repair := false ;
101863: LD_ADDR_VAR 0 22
101867: PUSH
101868: LD_INT 0
101870: ST_TO_ADDR
// f_heal := false ;
101871: LD_ADDR_VAR 0 23
101875: PUSH
101876: LD_INT 0
101878: ST_TO_ADDR
// f_spacetime := false ;
101879: LD_ADDR_VAR 0 24
101883: PUSH
101884: LD_INT 0
101886: ST_TO_ADDR
// f_attack_depot := false ;
101887: LD_ADDR_VAR 0 25
101891: PUSH
101892: LD_INT 0
101894: ST_TO_ADDR
// f_crawl := false ;
101895: LD_ADDR_VAR 0 26
101899: PUSH
101900: LD_INT 0
101902: ST_TO_ADDR
// end ; if f_heal then
101903: LD_VAR 0 23
101907: IFFALSE 101934
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
101909: LD_ADDR_VAR 0 31
101913: PUSH
101914: LD_VAR 0 4
101918: PPUSH
101919: LD_INT 25
101921: PUSH
101922: LD_INT 4
101924: PUSH
101925: EMPTY
101926: LIST
101927: LIST
101928: PPUSH
101929: CALL_OW 72
101933: ST_TO_ADDR
// if f_repair then
101934: LD_VAR 0 22
101938: IFFALSE 101965
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
101940: LD_ADDR_VAR 0 33
101944: PUSH
101945: LD_VAR 0 4
101949: PPUSH
101950: LD_INT 25
101952: PUSH
101953: LD_INT 3
101955: PUSH
101956: EMPTY
101957: LIST
101958: LIST
101959: PPUSH
101960: CALL_OW 72
101964: ST_TO_ADDR
// units_path := [ ] ;
101965: LD_ADDR_VAR 0 16
101969: PUSH
101970: EMPTY
101971: ST_TO_ADDR
// for i = 1 to group do
101972: LD_ADDR_VAR 0 7
101976: PUSH
101977: DOUBLE
101978: LD_INT 1
101980: DEC
101981: ST_TO_ADDR
101982: LD_VAR 0 4
101986: PUSH
101987: FOR_TO
101988: IFFALSE 102017
// units_path := Replace ( units_path , i , path ) ;
101990: LD_ADDR_VAR 0 16
101994: PUSH
101995: LD_VAR 0 16
101999: PPUSH
102000: LD_VAR 0 7
102004: PPUSH
102005: LD_VAR 0 5
102009: PPUSH
102010: CALL_OW 1
102014: ST_TO_ADDR
102015: GO 101987
102017: POP
102018: POP
// repeat for i = group downto 1 do
102019: LD_ADDR_VAR 0 7
102023: PUSH
102024: DOUBLE
102025: LD_VAR 0 4
102029: INC
102030: ST_TO_ADDR
102031: LD_INT 1
102033: PUSH
102034: FOR_DOWNTO
102035: IFFALSE 106157
// begin wait ( 5 ) ;
102037: LD_INT 5
102039: PPUSH
102040: CALL_OW 67
// tmp := [ ] ;
102044: LD_ADDR_VAR 0 14
102048: PUSH
102049: EMPTY
102050: ST_TO_ADDR
// attacking := false ;
102051: LD_ADDR_VAR 0 29
102055: PUSH
102056: LD_INT 0
102058: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
102059: LD_VAR 0 4
102063: PUSH
102064: LD_VAR 0 7
102068: ARRAY
102069: PPUSH
102070: CALL_OW 301
102074: PUSH
102075: LD_VAR 0 4
102079: PUSH
102080: LD_VAR 0 7
102084: ARRAY
102085: NOT
102086: OR
102087: IFFALSE 102196
// begin if GetType ( group [ i ] ) = unit_human then
102089: LD_VAR 0 4
102093: PUSH
102094: LD_VAR 0 7
102098: ARRAY
102099: PPUSH
102100: CALL_OW 247
102104: PUSH
102105: LD_INT 1
102107: EQUAL
102108: IFFALSE 102154
// begin to_heal := to_heal diff group [ i ] ;
102110: LD_ADDR_VAR 0 30
102114: PUSH
102115: LD_VAR 0 30
102119: PUSH
102120: LD_VAR 0 4
102124: PUSH
102125: LD_VAR 0 7
102129: ARRAY
102130: DIFF
102131: ST_TO_ADDR
// healers := healers diff group [ i ] ;
102132: LD_ADDR_VAR 0 31
102136: PUSH
102137: LD_VAR 0 31
102141: PUSH
102142: LD_VAR 0 4
102146: PUSH
102147: LD_VAR 0 7
102151: ARRAY
102152: DIFF
102153: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
102154: LD_ADDR_VAR 0 4
102158: PUSH
102159: LD_VAR 0 4
102163: PPUSH
102164: LD_VAR 0 7
102168: PPUSH
102169: CALL_OW 3
102173: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
102174: LD_ADDR_VAR 0 16
102178: PUSH
102179: LD_VAR 0 16
102183: PPUSH
102184: LD_VAR 0 7
102188: PPUSH
102189: CALL_OW 3
102193: ST_TO_ADDR
// continue ;
102194: GO 102034
// end ; if f_repair then
102196: LD_VAR 0 22
102200: IFFALSE 102689
// begin if GetType ( group [ i ] ) = unit_vehicle then
102202: LD_VAR 0 4
102206: PUSH
102207: LD_VAR 0 7
102211: ARRAY
102212: PPUSH
102213: CALL_OW 247
102217: PUSH
102218: LD_INT 2
102220: EQUAL
102221: IFFALSE 102411
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
102223: LD_VAR 0 4
102227: PUSH
102228: LD_VAR 0 7
102232: ARRAY
102233: PPUSH
102234: CALL_OW 256
102238: PUSH
102239: LD_INT 700
102241: LESS
102242: PUSH
102243: LD_VAR 0 4
102247: PUSH
102248: LD_VAR 0 7
102252: ARRAY
102253: PUSH
102254: LD_VAR 0 32
102258: IN
102259: NOT
102260: AND
102261: IFFALSE 102285
// to_repair := to_repair union group [ i ] ;
102263: LD_ADDR_VAR 0 32
102267: PUSH
102268: LD_VAR 0 32
102272: PUSH
102273: LD_VAR 0 4
102277: PUSH
102278: LD_VAR 0 7
102282: ARRAY
102283: UNION
102284: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
102285: LD_VAR 0 4
102289: PUSH
102290: LD_VAR 0 7
102294: ARRAY
102295: PPUSH
102296: CALL_OW 256
102300: PUSH
102301: LD_INT 1000
102303: EQUAL
102304: PUSH
102305: LD_VAR 0 4
102309: PUSH
102310: LD_VAR 0 7
102314: ARRAY
102315: PUSH
102316: LD_VAR 0 32
102320: IN
102321: AND
102322: IFFALSE 102346
// to_repair := to_repair diff group [ i ] ;
102324: LD_ADDR_VAR 0 32
102328: PUSH
102329: LD_VAR 0 32
102333: PUSH
102334: LD_VAR 0 4
102338: PUSH
102339: LD_VAR 0 7
102343: ARRAY
102344: DIFF
102345: ST_TO_ADDR
// if group [ i ] in to_repair then
102346: LD_VAR 0 4
102350: PUSH
102351: LD_VAR 0 7
102355: ARRAY
102356: PUSH
102357: LD_VAR 0 32
102361: IN
102362: IFFALSE 102409
// begin if not IsInArea ( group [ i ] , f_repair ) then
102364: LD_VAR 0 4
102368: PUSH
102369: LD_VAR 0 7
102373: ARRAY
102374: PPUSH
102375: LD_VAR 0 22
102379: PPUSH
102380: CALL_OW 308
102384: NOT
102385: IFFALSE 102407
// ComMoveToArea ( group [ i ] , f_repair ) ;
102387: LD_VAR 0 4
102391: PUSH
102392: LD_VAR 0 7
102396: ARRAY
102397: PPUSH
102398: LD_VAR 0 22
102402: PPUSH
102403: CALL_OW 113
// continue ;
102407: GO 102034
// end ; end else
102409: GO 102689
// if group [ i ] in repairs then
102411: LD_VAR 0 4
102415: PUSH
102416: LD_VAR 0 7
102420: ARRAY
102421: PUSH
102422: LD_VAR 0 33
102426: IN
102427: IFFALSE 102689
// begin if IsInUnit ( group [ i ] ) then
102429: LD_VAR 0 4
102433: PUSH
102434: LD_VAR 0 7
102438: ARRAY
102439: PPUSH
102440: CALL_OW 310
102444: IFFALSE 102512
// begin z := IsInUnit ( group [ i ] ) ;
102446: LD_ADDR_VAR 0 13
102450: PUSH
102451: LD_VAR 0 4
102455: PUSH
102456: LD_VAR 0 7
102460: ARRAY
102461: PPUSH
102462: CALL_OW 310
102466: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
102467: LD_VAR 0 13
102471: PUSH
102472: LD_VAR 0 32
102476: IN
102477: PUSH
102478: LD_VAR 0 13
102482: PPUSH
102483: LD_VAR 0 22
102487: PPUSH
102488: CALL_OW 308
102492: AND
102493: IFFALSE 102510
// ComExitVehicle ( group [ i ] ) ;
102495: LD_VAR 0 4
102499: PUSH
102500: LD_VAR 0 7
102504: ARRAY
102505: PPUSH
102506: CALL_OW 121
// end else
102510: GO 102689
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
102512: LD_ADDR_VAR 0 13
102516: PUSH
102517: LD_VAR 0 4
102521: PPUSH
102522: LD_INT 95
102524: PUSH
102525: LD_VAR 0 22
102529: PUSH
102530: EMPTY
102531: LIST
102532: LIST
102533: PUSH
102534: LD_INT 58
102536: PUSH
102537: EMPTY
102538: LIST
102539: PUSH
102540: EMPTY
102541: LIST
102542: LIST
102543: PPUSH
102544: CALL_OW 72
102548: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
102549: LD_VAR 0 4
102553: PUSH
102554: LD_VAR 0 7
102558: ARRAY
102559: PPUSH
102560: CALL_OW 314
102564: NOT
102565: IFFALSE 102687
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
102567: LD_ADDR_VAR 0 10
102571: PUSH
102572: LD_VAR 0 13
102576: PPUSH
102577: LD_VAR 0 4
102581: PUSH
102582: LD_VAR 0 7
102586: ARRAY
102587: PPUSH
102588: CALL_OW 74
102592: ST_TO_ADDR
// if not x then
102593: LD_VAR 0 10
102597: NOT
102598: IFFALSE 102602
// continue ;
102600: GO 102034
// if GetLives ( x ) < 1000 then
102602: LD_VAR 0 10
102606: PPUSH
102607: CALL_OW 256
102611: PUSH
102612: LD_INT 1000
102614: LESS
102615: IFFALSE 102639
// ComRepairVehicle ( group [ i ] , x ) else
102617: LD_VAR 0 4
102621: PUSH
102622: LD_VAR 0 7
102626: ARRAY
102627: PPUSH
102628: LD_VAR 0 10
102632: PPUSH
102633: CALL_OW 129
102637: GO 102687
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
102639: LD_VAR 0 23
102643: PUSH
102644: LD_VAR 0 4
102648: PUSH
102649: LD_VAR 0 7
102653: ARRAY
102654: PPUSH
102655: CALL_OW 256
102659: PUSH
102660: LD_INT 1000
102662: LESS
102663: AND
102664: NOT
102665: IFFALSE 102687
// ComEnterUnit ( group [ i ] , x ) ;
102667: LD_VAR 0 4
102671: PUSH
102672: LD_VAR 0 7
102676: ARRAY
102677: PPUSH
102678: LD_VAR 0 10
102682: PPUSH
102683: CALL_OW 120
// end ; continue ;
102687: GO 102034
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
102689: LD_VAR 0 23
102693: PUSH
102694: LD_VAR 0 4
102698: PUSH
102699: LD_VAR 0 7
102703: ARRAY
102704: PPUSH
102705: CALL_OW 247
102709: PUSH
102710: LD_INT 1
102712: EQUAL
102713: AND
102714: IFFALSE 103192
// begin if group [ i ] in healers then
102716: LD_VAR 0 4
102720: PUSH
102721: LD_VAR 0 7
102725: ARRAY
102726: PUSH
102727: LD_VAR 0 31
102731: IN
102732: IFFALSE 103005
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
102734: LD_VAR 0 4
102738: PUSH
102739: LD_VAR 0 7
102743: ARRAY
102744: PPUSH
102745: LD_VAR 0 23
102749: PPUSH
102750: CALL_OW 308
102754: NOT
102755: PUSH
102756: LD_VAR 0 4
102760: PUSH
102761: LD_VAR 0 7
102765: ARRAY
102766: PPUSH
102767: CALL_OW 314
102771: NOT
102772: AND
102773: IFFALSE 102797
// ComMoveToArea ( group [ i ] , f_heal ) else
102775: LD_VAR 0 4
102779: PUSH
102780: LD_VAR 0 7
102784: ARRAY
102785: PPUSH
102786: LD_VAR 0 23
102790: PPUSH
102791: CALL_OW 113
102795: GO 103003
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
102797: LD_VAR 0 4
102801: PUSH
102802: LD_VAR 0 7
102806: ARRAY
102807: PPUSH
102808: CALL 80703 0 1
102812: PPUSH
102813: CALL_OW 256
102817: PUSH
102818: LD_INT 1000
102820: EQUAL
102821: IFFALSE 102840
// ComStop ( group [ i ] ) else
102823: LD_VAR 0 4
102827: PUSH
102828: LD_VAR 0 7
102832: ARRAY
102833: PPUSH
102834: CALL_OW 141
102838: GO 103003
// if not HasTask ( group [ i ] ) and to_heal then
102840: LD_VAR 0 4
102844: PUSH
102845: LD_VAR 0 7
102849: ARRAY
102850: PPUSH
102851: CALL_OW 314
102855: NOT
102856: PUSH
102857: LD_VAR 0 30
102861: AND
102862: IFFALSE 103003
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
102864: LD_ADDR_VAR 0 13
102868: PUSH
102869: LD_VAR 0 30
102873: PPUSH
102874: LD_INT 3
102876: PUSH
102877: LD_INT 54
102879: PUSH
102880: EMPTY
102881: LIST
102882: PUSH
102883: EMPTY
102884: LIST
102885: LIST
102886: PPUSH
102887: CALL_OW 72
102891: PPUSH
102892: LD_VAR 0 4
102896: PUSH
102897: LD_VAR 0 7
102901: ARRAY
102902: PPUSH
102903: CALL_OW 74
102907: ST_TO_ADDR
// if z then
102908: LD_VAR 0 13
102912: IFFALSE 103003
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
102914: LD_INT 91
102916: PUSH
102917: LD_VAR 0 13
102921: PUSH
102922: LD_INT 10
102924: PUSH
102925: EMPTY
102926: LIST
102927: LIST
102928: LIST
102929: PUSH
102930: LD_INT 81
102932: PUSH
102933: LD_VAR 0 13
102937: PPUSH
102938: CALL_OW 255
102942: PUSH
102943: EMPTY
102944: LIST
102945: LIST
102946: PUSH
102947: EMPTY
102948: LIST
102949: LIST
102950: PPUSH
102951: CALL_OW 69
102955: PUSH
102956: LD_INT 0
102958: EQUAL
102959: IFFALSE 102983
// ComHeal ( group [ i ] , z ) else
102961: LD_VAR 0 4
102965: PUSH
102966: LD_VAR 0 7
102970: ARRAY
102971: PPUSH
102972: LD_VAR 0 13
102976: PPUSH
102977: CALL_OW 128
102981: GO 103003
// ComMoveToArea ( group [ i ] , f_heal ) ;
102983: LD_VAR 0 4
102987: PUSH
102988: LD_VAR 0 7
102992: ARRAY
102993: PPUSH
102994: LD_VAR 0 23
102998: PPUSH
102999: CALL_OW 113
// end ; continue ;
103003: GO 102034
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
103005: LD_VAR 0 4
103009: PUSH
103010: LD_VAR 0 7
103014: ARRAY
103015: PPUSH
103016: CALL_OW 256
103020: PUSH
103021: LD_INT 700
103023: LESS
103024: PUSH
103025: LD_VAR 0 4
103029: PUSH
103030: LD_VAR 0 7
103034: ARRAY
103035: PUSH
103036: LD_VAR 0 30
103040: IN
103041: NOT
103042: AND
103043: IFFALSE 103067
// to_heal := to_heal union group [ i ] ;
103045: LD_ADDR_VAR 0 30
103049: PUSH
103050: LD_VAR 0 30
103054: PUSH
103055: LD_VAR 0 4
103059: PUSH
103060: LD_VAR 0 7
103064: ARRAY
103065: UNION
103066: ST_TO_ADDR
// if group [ i ] in to_heal then
103067: LD_VAR 0 4
103071: PUSH
103072: LD_VAR 0 7
103076: ARRAY
103077: PUSH
103078: LD_VAR 0 30
103082: IN
103083: IFFALSE 103192
// begin if GetLives ( group [ i ] ) = 1000 then
103085: LD_VAR 0 4
103089: PUSH
103090: LD_VAR 0 7
103094: ARRAY
103095: PPUSH
103096: CALL_OW 256
103100: PUSH
103101: LD_INT 1000
103103: EQUAL
103104: IFFALSE 103130
// to_heal := to_heal diff group [ i ] else
103106: LD_ADDR_VAR 0 30
103110: PUSH
103111: LD_VAR 0 30
103115: PUSH
103116: LD_VAR 0 4
103120: PUSH
103121: LD_VAR 0 7
103125: ARRAY
103126: DIFF
103127: ST_TO_ADDR
103128: GO 103192
// begin if not IsInArea ( group [ i ] , to_heal ) then
103130: LD_VAR 0 4
103134: PUSH
103135: LD_VAR 0 7
103139: ARRAY
103140: PPUSH
103141: LD_VAR 0 30
103145: PPUSH
103146: CALL_OW 308
103150: NOT
103151: IFFALSE 103175
// ComMoveToArea ( group [ i ] , f_heal ) else
103153: LD_VAR 0 4
103157: PUSH
103158: LD_VAR 0 7
103162: ARRAY
103163: PPUSH
103164: LD_VAR 0 23
103168: PPUSH
103169: CALL_OW 113
103173: GO 103190
// ComHold ( group [ i ] ) ;
103175: LD_VAR 0 4
103179: PUSH
103180: LD_VAR 0 7
103184: ARRAY
103185: PPUSH
103186: CALL_OW 140
// continue ;
103190: GO 102034
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
103192: LD_VAR 0 4
103196: PUSH
103197: LD_VAR 0 7
103201: ARRAY
103202: PPUSH
103203: LD_INT 10
103205: PPUSH
103206: CALL 79123 0 2
103210: NOT
103211: PUSH
103212: LD_VAR 0 16
103216: PUSH
103217: LD_VAR 0 7
103221: ARRAY
103222: PUSH
103223: EMPTY
103224: EQUAL
103225: NOT
103226: AND
103227: IFFALSE 103493
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
103229: LD_VAR 0 4
103233: PUSH
103234: LD_VAR 0 7
103238: ARRAY
103239: PPUSH
103240: CALL_OW 262
103244: PUSH
103245: LD_INT 1
103247: PUSH
103248: LD_INT 2
103250: PUSH
103251: EMPTY
103252: LIST
103253: LIST
103254: IN
103255: IFFALSE 103296
// if GetFuel ( group [ i ] ) < 10 then
103257: LD_VAR 0 4
103261: PUSH
103262: LD_VAR 0 7
103266: ARRAY
103267: PPUSH
103268: CALL_OW 261
103272: PUSH
103273: LD_INT 10
103275: LESS
103276: IFFALSE 103296
// SetFuel ( group [ i ] , 12 ) ;
103278: LD_VAR 0 4
103282: PUSH
103283: LD_VAR 0 7
103287: ARRAY
103288: PPUSH
103289: LD_INT 12
103291: PPUSH
103292: CALL_OW 240
// if units_path [ i ] then
103296: LD_VAR 0 16
103300: PUSH
103301: LD_VAR 0 7
103305: ARRAY
103306: IFFALSE 103491
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
103308: LD_VAR 0 4
103312: PUSH
103313: LD_VAR 0 7
103317: ARRAY
103318: PPUSH
103319: LD_VAR 0 16
103323: PUSH
103324: LD_VAR 0 7
103328: ARRAY
103329: PUSH
103330: LD_INT 1
103332: ARRAY
103333: PUSH
103334: LD_INT 1
103336: ARRAY
103337: PPUSH
103338: LD_VAR 0 16
103342: PUSH
103343: LD_VAR 0 7
103347: ARRAY
103348: PUSH
103349: LD_INT 1
103351: ARRAY
103352: PUSH
103353: LD_INT 2
103355: ARRAY
103356: PPUSH
103357: CALL_OW 297
103361: PUSH
103362: LD_INT 6
103364: GREATER
103365: IFFALSE 103440
// begin if not HasTask ( group [ i ] ) then
103367: LD_VAR 0 4
103371: PUSH
103372: LD_VAR 0 7
103376: ARRAY
103377: PPUSH
103378: CALL_OW 314
103382: NOT
103383: IFFALSE 103438
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
103385: LD_VAR 0 4
103389: PUSH
103390: LD_VAR 0 7
103394: ARRAY
103395: PPUSH
103396: LD_VAR 0 16
103400: PUSH
103401: LD_VAR 0 7
103405: ARRAY
103406: PUSH
103407: LD_INT 1
103409: ARRAY
103410: PUSH
103411: LD_INT 1
103413: ARRAY
103414: PPUSH
103415: LD_VAR 0 16
103419: PUSH
103420: LD_VAR 0 7
103424: ARRAY
103425: PUSH
103426: LD_INT 1
103428: ARRAY
103429: PUSH
103430: LD_INT 2
103432: ARRAY
103433: PPUSH
103434: CALL_OW 114
// end else
103438: GO 103491
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
103440: LD_ADDR_VAR 0 15
103444: PUSH
103445: LD_VAR 0 16
103449: PUSH
103450: LD_VAR 0 7
103454: ARRAY
103455: PPUSH
103456: LD_INT 1
103458: PPUSH
103459: CALL_OW 3
103463: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
103464: LD_ADDR_VAR 0 16
103468: PUSH
103469: LD_VAR 0 16
103473: PPUSH
103474: LD_VAR 0 7
103478: PPUSH
103479: LD_VAR 0 15
103483: PPUSH
103484: CALL_OW 1
103488: ST_TO_ADDR
// continue ;
103489: GO 102034
// end ; end ; end else
103491: GO 106155
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
103493: LD_ADDR_VAR 0 14
103497: PUSH
103498: LD_INT 81
103500: PUSH
103501: LD_VAR 0 4
103505: PUSH
103506: LD_VAR 0 7
103510: ARRAY
103511: PPUSH
103512: CALL_OW 255
103516: PUSH
103517: EMPTY
103518: LIST
103519: LIST
103520: PPUSH
103521: CALL_OW 69
103525: ST_TO_ADDR
// if not tmp then
103526: LD_VAR 0 14
103530: NOT
103531: IFFALSE 103535
// continue ;
103533: GO 102034
// if f_ignore_area then
103535: LD_VAR 0 17
103539: IFFALSE 103627
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
103541: LD_ADDR_VAR 0 15
103545: PUSH
103546: LD_VAR 0 14
103550: PPUSH
103551: LD_INT 3
103553: PUSH
103554: LD_INT 92
103556: PUSH
103557: LD_VAR 0 17
103561: PUSH
103562: LD_INT 1
103564: ARRAY
103565: PUSH
103566: LD_VAR 0 17
103570: PUSH
103571: LD_INT 2
103573: ARRAY
103574: PUSH
103575: LD_VAR 0 17
103579: PUSH
103580: LD_INT 3
103582: ARRAY
103583: PUSH
103584: EMPTY
103585: LIST
103586: LIST
103587: LIST
103588: LIST
103589: PUSH
103590: EMPTY
103591: LIST
103592: LIST
103593: PPUSH
103594: CALL_OW 72
103598: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
103599: LD_VAR 0 14
103603: PUSH
103604: LD_VAR 0 15
103608: DIFF
103609: IFFALSE 103627
// tmp := tmp diff tmp2 ;
103611: LD_ADDR_VAR 0 14
103615: PUSH
103616: LD_VAR 0 14
103620: PUSH
103621: LD_VAR 0 15
103625: DIFF
103626: ST_TO_ADDR
// end ; if not f_murder then
103627: LD_VAR 0 20
103631: NOT
103632: IFFALSE 103690
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
103634: LD_ADDR_VAR 0 15
103638: PUSH
103639: LD_VAR 0 14
103643: PPUSH
103644: LD_INT 3
103646: PUSH
103647: LD_INT 50
103649: PUSH
103650: EMPTY
103651: LIST
103652: PUSH
103653: EMPTY
103654: LIST
103655: LIST
103656: PPUSH
103657: CALL_OW 72
103661: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
103662: LD_VAR 0 14
103666: PUSH
103667: LD_VAR 0 15
103671: DIFF
103672: IFFALSE 103690
// tmp := tmp diff tmp2 ;
103674: LD_ADDR_VAR 0 14
103678: PUSH
103679: LD_VAR 0 14
103683: PUSH
103684: LD_VAR 0 15
103688: DIFF
103689: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
103690: LD_ADDR_VAR 0 14
103694: PUSH
103695: LD_VAR 0 4
103699: PUSH
103700: LD_VAR 0 7
103704: ARRAY
103705: PPUSH
103706: LD_VAR 0 14
103710: PPUSH
103711: LD_INT 1
103713: PPUSH
103714: LD_INT 1
103716: PPUSH
103717: CALL 52766 0 4
103721: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
103722: LD_VAR 0 4
103726: PUSH
103727: LD_VAR 0 7
103731: ARRAY
103732: PPUSH
103733: CALL_OW 257
103737: PUSH
103738: LD_INT 1
103740: EQUAL
103741: IFFALSE 104189
// begin if WantPlant ( group [ i ] ) then
103743: LD_VAR 0 4
103747: PUSH
103748: LD_VAR 0 7
103752: ARRAY
103753: PPUSH
103754: CALL 52267 0 1
103758: IFFALSE 103762
// continue ;
103760: GO 102034
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
103762: LD_VAR 0 18
103766: PUSH
103767: LD_VAR 0 4
103771: PUSH
103772: LD_VAR 0 7
103776: ARRAY
103777: PPUSH
103778: CALL_OW 310
103782: NOT
103783: AND
103784: PUSH
103785: LD_VAR 0 14
103789: PUSH
103790: LD_INT 1
103792: ARRAY
103793: PUSH
103794: LD_VAR 0 14
103798: PPUSH
103799: LD_INT 21
103801: PUSH
103802: LD_INT 2
103804: PUSH
103805: EMPTY
103806: LIST
103807: LIST
103808: PUSH
103809: LD_INT 58
103811: PUSH
103812: EMPTY
103813: LIST
103814: PUSH
103815: EMPTY
103816: LIST
103817: LIST
103818: PPUSH
103819: CALL_OW 72
103823: IN
103824: AND
103825: IFFALSE 103861
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
103827: LD_VAR 0 4
103831: PUSH
103832: LD_VAR 0 7
103836: ARRAY
103837: PPUSH
103838: LD_VAR 0 14
103842: PUSH
103843: LD_INT 1
103845: ARRAY
103846: PPUSH
103847: CALL_OW 120
// attacking := true ;
103851: LD_ADDR_VAR 0 29
103855: PUSH
103856: LD_INT 1
103858: ST_TO_ADDR
// continue ;
103859: GO 102034
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
103861: LD_VAR 0 26
103865: PUSH
103866: LD_VAR 0 4
103870: PUSH
103871: LD_VAR 0 7
103875: ARRAY
103876: PPUSH
103877: CALL_OW 257
103881: PUSH
103882: LD_INT 1
103884: EQUAL
103885: AND
103886: PUSH
103887: LD_VAR 0 4
103891: PUSH
103892: LD_VAR 0 7
103896: ARRAY
103897: PPUSH
103898: CALL_OW 256
103902: PUSH
103903: LD_INT 800
103905: LESS
103906: AND
103907: PUSH
103908: LD_VAR 0 4
103912: PUSH
103913: LD_VAR 0 7
103917: ARRAY
103918: PPUSH
103919: CALL_OW 318
103923: NOT
103924: AND
103925: IFFALSE 103942
// ComCrawl ( group [ i ] ) ;
103927: LD_VAR 0 4
103931: PUSH
103932: LD_VAR 0 7
103936: ARRAY
103937: PPUSH
103938: CALL_OW 137
// if f_mines then
103942: LD_VAR 0 21
103946: IFFALSE 104189
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
103948: LD_VAR 0 14
103952: PUSH
103953: LD_INT 1
103955: ARRAY
103956: PPUSH
103957: CALL_OW 247
103961: PUSH
103962: LD_INT 3
103964: EQUAL
103965: PUSH
103966: LD_VAR 0 14
103970: PUSH
103971: LD_INT 1
103973: ARRAY
103974: PUSH
103975: LD_VAR 0 27
103979: IN
103980: NOT
103981: AND
103982: IFFALSE 104189
// begin x := GetX ( tmp [ 1 ] ) ;
103984: LD_ADDR_VAR 0 10
103988: PUSH
103989: LD_VAR 0 14
103993: PUSH
103994: LD_INT 1
103996: ARRAY
103997: PPUSH
103998: CALL_OW 250
104002: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
104003: LD_ADDR_VAR 0 11
104007: PUSH
104008: LD_VAR 0 14
104012: PUSH
104013: LD_INT 1
104015: ARRAY
104016: PPUSH
104017: CALL_OW 251
104021: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
104022: LD_ADDR_VAR 0 12
104026: PUSH
104027: LD_VAR 0 4
104031: PUSH
104032: LD_VAR 0 7
104036: ARRAY
104037: PPUSH
104038: CALL 79208 0 1
104042: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
104043: LD_VAR 0 4
104047: PUSH
104048: LD_VAR 0 7
104052: ARRAY
104053: PPUSH
104054: LD_VAR 0 10
104058: PPUSH
104059: LD_VAR 0 11
104063: PPUSH
104064: LD_VAR 0 14
104068: PUSH
104069: LD_INT 1
104071: ARRAY
104072: PPUSH
104073: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
104077: LD_VAR 0 4
104081: PUSH
104082: LD_VAR 0 7
104086: ARRAY
104087: PPUSH
104088: LD_VAR 0 10
104092: PPUSH
104093: LD_VAR 0 12
104097: PPUSH
104098: LD_INT 7
104100: PPUSH
104101: CALL_OW 272
104105: PPUSH
104106: LD_VAR 0 11
104110: PPUSH
104111: LD_VAR 0 12
104115: PPUSH
104116: LD_INT 7
104118: PPUSH
104119: CALL_OW 273
104123: PPUSH
104124: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
104128: LD_VAR 0 4
104132: PUSH
104133: LD_VAR 0 7
104137: ARRAY
104138: PPUSH
104139: LD_INT 71
104141: PPUSH
104142: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
104146: LD_ADDR_VAR 0 27
104150: PUSH
104151: LD_VAR 0 27
104155: PPUSH
104156: LD_VAR 0 27
104160: PUSH
104161: LD_INT 1
104163: PLUS
104164: PPUSH
104165: LD_VAR 0 14
104169: PUSH
104170: LD_INT 1
104172: ARRAY
104173: PPUSH
104174: CALL_OW 1
104178: ST_TO_ADDR
// attacking := true ;
104179: LD_ADDR_VAR 0 29
104183: PUSH
104184: LD_INT 1
104186: ST_TO_ADDR
// continue ;
104187: GO 102034
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
104189: LD_VAR 0 4
104193: PUSH
104194: LD_VAR 0 7
104198: ARRAY
104199: PPUSH
104200: CALL_OW 257
104204: PUSH
104205: LD_INT 17
104207: EQUAL
104208: PUSH
104209: LD_VAR 0 4
104213: PUSH
104214: LD_VAR 0 7
104218: ARRAY
104219: PPUSH
104220: CALL_OW 110
104224: PUSH
104225: LD_INT 71
104227: EQUAL
104228: NOT
104229: AND
104230: IFFALSE 104376
// begin attacking := false ;
104232: LD_ADDR_VAR 0 29
104236: PUSH
104237: LD_INT 0
104239: ST_TO_ADDR
// k := 5 ;
104240: LD_ADDR_VAR 0 9
104244: PUSH
104245: LD_INT 5
104247: ST_TO_ADDR
// if tmp < k then
104248: LD_VAR 0 14
104252: PUSH
104253: LD_VAR 0 9
104257: LESS
104258: IFFALSE 104270
// k := tmp ;
104260: LD_ADDR_VAR 0 9
104264: PUSH
104265: LD_VAR 0 14
104269: ST_TO_ADDR
// for j = 1 to k do
104270: LD_ADDR_VAR 0 8
104274: PUSH
104275: DOUBLE
104276: LD_INT 1
104278: DEC
104279: ST_TO_ADDR
104280: LD_VAR 0 9
104284: PUSH
104285: FOR_TO
104286: IFFALSE 104374
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
104288: LD_VAR 0 14
104292: PUSH
104293: LD_VAR 0 8
104297: ARRAY
104298: PUSH
104299: LD_VAR 0 14
104303: PPUSH
104304: LD_INT 58
104306: PUSH
104307: EMPTY
104308: LIST
104309: PPUSH
104310: CALL_OW 72
104314: IN
104315: NOT
104316: IFFALSE 104372
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104318: LD_VAR 0 4
104322: PUSH
104323: LD_VAR 0 7
104327: ARRAY
104328: PPUSH
104329: LD_VAR 0 14
104333: PUSH
104334: LD_VAR 0 8
104338: ARRAY
104339: PPUSH
104340: CALL_OW 115
// attacking := true ;
104344: LD_ADDR_VAR 0 29
104348: PUSH
104349: LD_INT 1
104351: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
104352: LD_VAR 0 4
104356: PUSH
104357: LD_VAR 0 7
104361: ARRAY
104362: PPUSH
104363: LD_INT 71
104365: PPUSH
104366: CALL_OW 109
// continue ;
104370: GO 104285
// end ; end ;
104372: GO 104285
104374: POP
104375: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
104376: LD_VAR 0 4
104380: PUSH
104381: LD_VAR 0 7
104385: ARRAY
104386: PPUSH
104387: CALL_OW 257
104391: PUSH
104392: LD_INT 8
104394: EQUAL
104395: PUSH
104396: LD_VAR 0 4
104400: PUSH
104401: LD_VAR 0 7
104405: ARRAY
104406: PPUSH
104407: CALL_OW 264
104411: PUSH
104412: LD_INT 28
104414: PUSH
104415: LD_INT 45
104417: PUSH
104418: LD_INT 7
104420: PUSH
104421: LD_INT 47
104423: PUSH
104424: EMPTY
104425: LIST
104426: LIST
104427: LIST
104428: LIST
104429: IN
104430: OR
104431: IFFALSE 104687
// begin attacking := false ;
104433: LD_ADDR_VAR 0 29
104437: PUSH
104438: LD_INT 0
104440: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
104441: LD_VAR 0 14
104445: PUSH
104446: LD_INT 1
104448: ARRAY
104449: PPUSH
104450: CALL_OW 266
104454: PUSH
104455: LD_INT 32
104457: PUSH
104458: LD_INT 31
104460: PUSH
104461: LD_INT 33
104463: PUSH
104464: LD_INT 4
104466: PUSH
104467: LD_INT 5
104469: PUSH
104470: EMPTY
104471: LIST
104472: LIST
104473: LIST
104474: LIST
104475: LIST
104476: IN
104477: IFFALSE 104663
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
104479: LD_ADDR_VAR 0 9
104483: PUSH
104484: LD_VAR 0 14
104488: PUSH
104489: LD_INT 1
104491: ARRAY
104492: PPUSH
104493: CALL_OW 266
104497: PPUSH
104498: LD_VAR 0 14
104502: PUSH
104503: LD_INT 1
104505: ARRAY
104506: PPUSH
104507: CALL_OW 250
104511: PPUSH
104512: LD_VAR 0 14
104516: PUSH
104517: LD_INT 1
104519: ARRAY
104520: PPUSH
104521: CALL_OW 251
104525: PPUSH
104526: LD_VAR 0 14
104530: PUSH
104531: LD_INT 1
104533: ARRAY
104534: PPUSH
104535: CALL_OW 254
104539: PPUSH
104540: LD_VAR 0 14
104544: PUSH
104545: LD_INT 1
104547: ARRAY
104548: PPUSH
104549: CALL_OW 248
104553: PPUSH
104554: LD_INT 0
104556: PPUSH
104557: CALL 60578 0 6
104561: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
104562: LD_ADDR_VAR 0 8
104566: PUSH
104567: LD_VAR 0 4
104571: PUSH
104572: LD_VAR 0 7
104576: ARRAY
104577: PPUSH
104578: LD_VAR 0 9
104582: PPUSH
104583: CALL 79248 0 2
104587: ST_TO_ADDR
// if j then
104588: LD_VAR 0 8
104592: IFFALSE 104661
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
104594: LD_VAR 0 8
104598: PUSH
104599: LD_INT 1
104601: ARRAY
104602: PPUSH
104603: LD_VAR 0 8
104607: PUSH
104608: LD_INT 2
104610: ARRAY
104611: PPUSH
104612: CALL_OW 488
104616: IFFALSE 104661
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
104618: LD_VAR 0 4
104622: PUSH
104623: LD_VAR 0 7
104627: ARRAY
104628: PPUSH
104629: LD_VAR 0 8
104633: PUSH
104634: LD_INT 1
104636: ARRAY
104637: PPUSH
104638: LD_VAR 0 8
104642: PUSH
104643: LD_INT 2
104645: ARRAY
104646: PPUSH
104647: CALL_OW 116
// attacking := true ;
104651: LD_ADDR_VAR 0 29
104655: PUSH
104656: LD_INT 1
104658: ST_TO_ADDR
// continue ;
104659: GO 102034
// end ; end else
104661: GO 104687
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104663: LD_VAR 0 4
104667: PUSH
104668: LD_VAR 0 7
104672: ARRAY
104673: PPUSH
104674: LD_VAR 0 14
104678: PUSH
104679: LD_INT 1
104681: ARRAY
104682: PPUSH
104683: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
104687: LD_VAR 0 4
104691: PUSH
104692: LD_VAR 0 7
104696: ARRAY
104697: PPUSH
104698: CALL_OW 265
104702: PUSH
104703: LD_INT 11
104705: EQUAL
104706: IFFALSE 104984
// begin k := 10 ;
104708: LD_ADDR_VAR 0 9
104712: PUSH
104713: LD_INT 10
104715: ST_TO_ADDR
// x := 0 ;
104716: LD_ADDR_VAR 0 10
104720: PUSH
104721: LD_INT 0
104723: ST_TO_ADDR
// if tmp < k then
104724: LD_VAR 0 14
104728: PUSH
104729: LD_VAR 0 9
104733: LESS
104734: IFFALSE 104746
// k := tmp ;
104736: LD_ADDR_VAR 0 9
104740: PUSH
104741: LD_VAR 0 14
104745: ST_TO_ADDR
// for j = k downto 1 do
104746: LD_ADDR_VAR 0 8
104750: PUSH
104751: DOUBLE
104752: LD_VAR 0 9
104756: INC
104757: ST_TO_ADDR
104758: LD_INT 1
104760: PUSH
104761: FOR_DOWNTO
104762: IFFALSE 104837
// begin if GetType ( tmp [ j ] ) = unit_human then
104764: LD_VAR 0 14
104768: PUSH
104769: LD_VAR 0 8
104773: ARRAY
104774: PPUSH
104775: CALL_OW 247
104779: PUSH
104780: LD_INT 1
104782: EQUAL
104783: IFFALSE 104835
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
104785: LD_VAR 0 4
104789: PUSH
104790: LD_VAR 0 7
104794: ARRAY
104795: PPUSH
104796: LD_VAR 0 14
104800: PUSH
104801: LD_VAR 0 8
104805: ARRAY
104806: PPUSH
104807: CALL 79519 0 2
// x := tmp [ j ] ;
104811: LD_ADDR_VAR 0 10
104815: PUSH
104816: LD_VAR 0 14
104820: PUSH
104821: LD_VAR 0 8
104825: ARRAY
104826: ST_TO_ADDR
// attacking := true ;
104827: LD_ADDR_VAR 0 29
104831: PUSH
104832: LD_INT 1
104834: ST_TO_ADDR
// end ; end ;
104835: GO 104761
104837: POP
104838: POP
// if not x then
104839: LD_VAR 0 10
104843: NOT
104844: IFFALSE 104984
// begin attacking := true ;
104846: LD_ADDR_VAR 0 29
104850: PUSH
104851: LD_INT 1
104853: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
104854: LD_VAR 0 4
104858: PUSH
104859: LD_VAR 0 7
104863: ARRAY
104864: PPUSH
104865: CALL_OW 250
104869: PPUSH
104870: LD_VAR 0 4
104874: PUSH
104875: LD_VAR 0 7
104879: ARRAY
104880: PPUSH
104881: CALL_OW 251
104885: PPUSH
104886: CALL_OW 546
104890: PUSH
104891: LD_INT 2
104893: ARRAY
104894: PUSH
104895: LD_VAR 0 14
104899: PUSH
104900: LD_INT 1
104902: ARRAY
104903: PPUSH
104904: CALL_OW 250
104908: PPUSH
104909: LD_VAR 0 14
104913: PUSH
104914: LD_INT 1
104916: ARRAY
104917: PPUSH
104918: CALL_OW 251
104922: PPUSH
104923: CALL_OW 546
104927: PUSH
104928: LD_INT 2
104930: ARRAY
104931: EQUAL
104932: IFFALSE 104960
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
104934: LD_VAR 0 4
104938: PUSH
104939: LD_VAR 0 7
104943: ARRAY
104944: PPUSH
104945: LD_VAR 0 14
104949: PUSH
104950: LD_INT 1
104952: ARRAY
104953: PPUSH
104954: CALL 79519 0 2
104958: GO 104984
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104960: LD_VAR 0 4
104964: PUSH
104965: LD_VAR 0 7
104969: ARRAY
104970: PPUSH
104971: LD_VAR 0 14
104975: PUSH
104976: LD_INT 1
104978: ARRAY
104979: PPUSH
104980: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
104984: LD_VAR 0 4
104988: PUSH
104989: LD_VAR 0 7
104993: ARRAY
104994: PPUSH
104995: CALL_OW 264
104999: PUSH
105000: LD_INT 29
105002: EQUAL
105003: IFFALSE 105369
// begin if WantsToAttack ( group [ i ] ) in bombed then
105005: LD_VAR 0 4
105009: PUSH
105010: LD_VAR 0 7
105014: ARRAY
105015: PPUSH
105016: CALL_OW 319
105020: PUSH
105021: LD_VAR 0 28
105025: IN
105026: IFFALSE 105030
// continue ;
105028: GO 102034
// k := 8 ;
105030: LD_ADDR_VAR 0 9
105034: PUSH
105035: LD_INT 8
105037: ST_TO_ADDR
// x := 0 ;
105038: LD_ADDR_VAR 0 10
105042: PUSH
105043: LD_INT 0
105045: ST_TO_ADDR
// if tmp < k then
105046: LD_VAR 0 14
105050: PUSH
105051: LD_VAR 0 9
105055: LESS
105056: IFFALSE 105068
// k := tmp ;
105058: LD_ADDR_VAR 0 9
105062: PUSH
105063: LD_VAR 0 14
105067: ST_TO_ADDR
// for j = 1 to k do
105068: LD_ADDR_VAR 0 8
105072: PUSH
105073: DOUBLE
105074: LD_INT 1
105076: DEC
105077: ST_TO_ADDR
105078: LD_VAR 0 9
105082: PUSH
105083: FOR_TO
105084: IFFALSE 105216
// begin if GetType ( tmp [ j ] ) = unit_building then
105086: LD_VAR 0 14
105090: PUSH
105091: LD_VAR 0 8
105095: ARRAY
105096: PPUSH
105097: CALL_OW 247
105101: PUSH
105102: LD_INT 3
105104: EQUAL
105105: IFFALSE 105214
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
105107: LD_VAR 0 14
105111: PUSH
105112: LD_VAR 0 8
105116: ARRAY
105117: PUSH
105118: LD_VAR 0 28
105122: IN
105123: NOT
105124: PUSH
105125: LD_VAR 0 14
105129: PUSH
105130: LD_VAR 0 8
105134: ARRAY
105135: PPUSH
105136: CALL_OW 313
105140: AND
105141: IFFALSE 105214
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105143: LD_VAR 0 4
105147: PUSH
105148: LD_VAR 0 7
105152: ARRAY
105153: PPUSH
105154: LD_VAR 0 14
105158: PUSH
105159: LD_VAR 0 8
105163: ARRAY
105164: PPUSH
105165: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
105169: LD_ADDR_VAR 0 28
105173: PUSH
105174: LD_VAR 0 28
105178: PPUSH
105179: LD_VAR 0 28
105183: PUSH
105184: LD_INT 1
105186: PLUS
105187: PPUSH
105188: LD_VAR 0 14
105192: PUSH
105193: LD_VAR 0 8
105197: ARRAY
105198: PPUSH
105199: CALL_OW 1
105203: ST_TO_ADDR
// attacking := true ;
105204: LD_ADDR_VAR 0 29
105208: PUSH
105209: LD_INT 1
105211: ST_TO_ADDR
// break ;
105212: GO 105216
// end ; end ;
105214: GO 105083
105216: POP
105217: POP
// if not attacking and f_attack_depot then
105218: LD_VAR 0 29
105222: NOT
105223: PUSH
105224: LD_VAR 0 25
105228: AND
105229: IFFALSE 105324
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105231: LD_ADDR_VAR 0 13
105235: PUSH
105236: LD_VAR 0 14
105240: PPUSH
105241: LD_INT 2
105243: PUSH
105244: LD_INT 30
105246: PUSH
105247: LD_INT 0
105249: PUSH
105250: EMPTY
105251: LIST
105252: LIST
105253: PUSH
105254: LD_INT 30
105256: PUSH
105257: LD_INT 1
105259: PUSH
105260: EMPTY
105261: LIST
105262: LIST
105263: PUSH
105264: EMPTY
105265: LIST
105266: LIST
105267: LIST
105268: PPUSH
105269: CALL_OW 72
105273: ST_TO_ADDR
// if z then
105274: LD_VAR 0 13
105278: IFFALSE 105324
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
105280: LD_VAR 0 4
105284: PUSH
105285: LD_VAR 0 7
105289: ARRAY
105290: PPUSH
105291: LD_VAR 0 13
105295: PPUSH
105296: LD_VAR 0 4
105300: PUSH
105301: LD_VAR 0 7
105305: ARRAY
105306: PPUSH
105307: CALL_OW 74
105311: PPUSH
105312: CALL_OW 115
// attacking := true ;
105316: LD_ADDR_VAR 0 29
105320: PUSH
105321: LD_INT 1
105323: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
105324: LD_VAR 0 4
105328: PUSH
105329: LD_VAR 0 7
105333: ARRAY
105334: PPUSH
105335: CALL_OW 256
105339: PUSH
105340: LD_INT 500
105342: LESS
105343: IFFALSE 105369
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105345: LD_VAR 0 4
105349: PUSH
105350: LD_VAR 0 7
105354: ARRAY
105355: PPUSH
105356: LD_VAR 0 14
105360: PUSH
105361: LD_INT 1
105363: ARRAY
105364: PPUSH
105365: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
105369: LD_VAR 0 4
105373: PUSH
105374: LD_VAR 0 7
105378: ARRAY
105379: PPUSH
105380: CALL_OW 264
105384: PUSH
105385: LD_INT 49
105387: EQUAL
105388: IFFALSE 105509
// begin if not HasTask ( group [ i ] ) then
105390: LD_VAR 0 4
105394: PUSH
105395: LD_VAR 0 7
105399: ARRAY
105400: PPUSH
105401: CALL_OW 314
105405: NOT
105406: IFFALSE 105509
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
105408: LD_ADDR_VAR 0 9
105412: PUSH
105413: LD_INT 81
105415: PUSH
105416: LD_VAR 0 4
105420: PUSH
105421: LD_VAR 0 7
105425: ARRAY
105426: PPUSH
105427: CALL_OW 255
105431: PUSH
105432: EMPTY
105433: LIST
105434: LIST
105435: PPUSH
105436: CALL_OW 69
105440: PPUSH
105441: LD_VAR 0 4
105445: PUSH
105446: LD_VAR 0 7
105450: ARRAY
105451: PPUSH
105452: CALL_OW 74
105456: ST_TO_ADDR
// if k then
105457: LD_VAR 0 9
105461: IFFALSE 105509
// if GetDistUnits ( group [ i ] , k ) > 10 then
105463: LD_VAR 0 4
105467: PUSH
105468: LD_VAR 0 7
105472: ARRAY
105473: PPUSH
105474: LD_VAR 0 9
105478: PPUSH
105479: CALL_OW 296
105483: PUSH
105484: LD_INT 10
105486: GREATER
105487: IFFALSE 105509
// ComMoveUnit ( group [ i ] , k ) ;
105489: LD_VAR 0 4
105493: PUSH
105494: LD_VAR 0 7
105498: ARRAY
105499: PPUSH
105500: LD_VAR 0 9
105504: PPUSH
105505: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
105509: LD_VAR 0 4
105513: PUSH
105514: LD_VAR 0 7
105518: ARRAY
105519: PPUSH
105520: CALL_OW 256
105524: PUSH
105525: LD_INT 250
105527: LESS
105528: PUSH
105529: LD_VAR 0 4
105533: PUSH
105534: LD_VAR 0 7
105538: ARRAY
105539: PUSH
105540: LD_INT 21
105542: PUSH
105543: LD_INT 2
105545: PUSH
105546: EMPTY
105547: LIST
105548: LIST
105549: PUSH
105550: LD_INT 23
105552: PUSH
105553: LD_INT 2
105555: PUSH
105556: EMPTY
105557: LIST
105558: LIST
105559: PUSH
105560: EMPTY
105561: LIST
105562: LIST
105563: PPUSH
105564: CALL_OW 69
105568: IN
105569: AND
105570: IFFALSE 105695
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
105572: LD_ADDR_VAR 0 9
105576: PUSH
105577: LD_OWVAR 3
105581: PUSH
105582: LD_VAR 0 4
105586: PUSH
105587: LD_VAR 0 7
105591: ARRAY
105592: DIFF
105593: PPUSH
105594: LD_VAR 0 4
105598: PUSH
105599: LD_VAR 0 7
105603: ARRAY
105604: PPUSH
105605: CALL_OW 74
105609: ST_TO_ADDR
// if not k then
105610: LD_VAR 0 9
105614: NOT
105615: IFFALSE 105619
// continue ;
105617: GO 102034
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
105619: LD_VAR 0 9
105623: PUSH
105624: LD_INT 81
105626: PUSH
105627: LD_VAR 0 4
105631: PUSH
105632: LD_VAR 0 7
105636: ARRAY
105637: PPUSH
105638: CALL_OW 255
105642: PUSH
105643: EMPTY
105644: LIST
105645: LIST
105646: PPUSH
105647: CALL_OW 69
105651: IN
105652: PUSH
105653: LD_VAR 0 9
105657: PPUSH
105658: LD_VAR 0 4
105662: PUSH
105663: LD_VAR 0 7
105667: ARRAY
105668: PPUSH
105669: CALL_OW 296
105673: PUSH
105674: LD_INT 5
105676: LESS
105677: AND
105678: IFFALSE 105695
// ComAutodestruct ( group [ i ] ) ;
105680: LD_VAR 0 4
105684: PUSH
105685: LD_VAR 0 7
105689: ARRAY
105690: PPUSH
105691: CALL 79417 0 1
// end ; if f_attack_depot then
105695: LD_VAR 0 25
105699: IFFALSE 105811
// begin k := 6 ;
105701: LD_ADDR_VAR 0 9
105705: PUSH
105706: LD_INT 6
105708: ST_TO_ADDR
// if tmp < k then
105709: LD_VAR 0 14
105713: PUSH
105714: LD_VAR 0 9
105718: LESS
105719: IFFALSE 105731
// k := tmp ;
105721: LD_ADDR_VAR 0 9
105725: PUSH
105726: LD_VAR 0 14
105730: ST_TO_ADDR
// for j = 1 to k do
105731: LD_ADDR_VAR 0 8
105735: PUSH
105736: DOUBLE
105737: LD_INT 1
105739: DEC
105740: ST_TO_ADDR
105741: LD_VAR 0 9
105745: PUSH
105746: FOR_TO
105747: IFFALSE 105809
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
105749: LD_VAR 0 8
105753: PPUSH
105754: CALL_OW 266
105758: PUSH
105759: LD_INT 0
105761: PUSH
105762: LD_INT 1
105764: PUSH
105765: EMPTY
105766: LIST
105767: LIST
105768: IN
105769: IFFALSE 105807
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105771: LD_VAR 0 4
105775: PUSH
105776: LD_VAR 0 7
105780: ARRAY
105781: PPUSH
105782: LD_VAR 0 14
105786: PUSH
105787: LD_VAR 0 8
105791: ARRAY
105792: PPUSH
105793: CALL_OW 115
// attacking := true ;
105797: LD_ADDR_VAR 0 29
105801: PUSH
105802: LD_INT 1
105804: ST_TO_ADDR
// break ;
105805: GO 105809
// end ;
105807: GO 105746
105809: POP
105810: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
105811: LD_VAR 0 4
105815: PUSH
105816: LD_VAR 0 7
105820: ARRAY
105821: PPUSH
105822: CALL_OW 302
105826: PUSH
105827: LD_VAR 0 29
105831: NOT
105832: AND
105833: IFFALSE 106155
// begin if GetTag ( group [ i ] ) = 71 then
105835: LD_VAR 0 4
105839: PUSH
105840: LD_VAR 0 7
105844: ARRAY
105845: PPUSH
105846: CALL_OW 110
105850: PUSH
105851: LD_INT 71
105853: EQUAL
105854: IFFALSE 105895
// begin if HasTask ( group [ i ] ) then
105856: LD_VAR 0 4
105860: PUSH
105861: LD_VAR 0 7
105865: ARRAY
105866: PPUSH
105867: CALL_OW 314
105871: IFFALSE 105877
// continue else
105873: GO 102034
105875: GO 105895
// SetTag ( group [ i ] , 0 ) ;
105877: LD_VAR 0 4
105881: PUSH
105882: LD_VAR 0 7
105886: ARRAY
105887: PPUSH
105888: LD_INT 0
105890: PPUSH
105891: CALL_OW 109
// end ; k := 8 ;
105895: LD_ADDR_VAR 0 9
105899: PUSH
105900: LD_INT 8
105902: ST_TO_ADDR
// x := 0 ;
105903: LD_ADDR_VAR 0 10
105907: PUSH
105908: LD_INT 0
105910: ST_TO_ADDR
// if tmp < k then
105911: LD_VAR 0 14
105915: PUSH
105916: LD_VAR 0 9
105920: LESS
105921: IFFALSE 105933
// k := tmp ;
105923: LD_ADDR_VAR 0 9
105927: PUSH
105928: LD_VAR 0 14
105932: ST_TO_ADDR
// for j = 1 to k do
105933: LD_ADDR_VAR 0 8
105937: PUSH
105938: DOUBLE
105939: LD_INT 1
105941: DEC
105942: ST_TO_ADDR
105943: LD_VAR 0 9
105947: PUSH
105948: FOR_TO
105949: IFFALSE 106047
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
105951: LD_VAR 0 14
105955: PUSH
105956: LD_VAR 0 8
105960: ARRAY
105961: PPUSH
105962: CALL_OW 247
105966: PUSH
105967: LD_INT 1
105969: EQUAL
105970: PUSH
105971: LD_VAR 0 14
105975: PUSH
105976: LD_VAR 0 8
105980: ARRAY
105981: PPUSH
105982: CALL_OW 256
105986: PUSH
105987: LD_INT 250
105989: LESS
105990: PUSH
105991: LD_VAR 0 20
105995: AND
105996: PUSH
105997: LD_VAR 0 20
106001: NOT
106002: PUSH
106003: LD_VAR 0 14
106007: PUSH
106008: LD_VAR 0 8
106012: ARRAY
106013: PPUSH
106014: CALL_OW 256
106018: PUSH
106019: LD_INT 250
106021: GREATEREQUAL
106022: AND
106023: OR
106024: AND
106025: IFFALSE 106045
// begin x := tmp [ j ] ;
106027: LD_ADDR_VAR 0 10
106031: PUSH
106032: LD_VAR 0 14
106036: PUSH
106037: LD_VAR 0 8
106041: ARRAY
106042: ST_TO_ADDR
// break ;
106043: GO 106047
// end ;
106045: GO 105948
106047: POP
106048: POP
// if x then
106049: LD_VAR 0 10
106053: IFFALSE 106077
// ComAttackUnit ( group [ i ] , x ) else
106055: LD_VAR 0 4
106059: PUSH
106060: LD_VAR 0 7
106064: ARRAY
106065: PPUSH
106066: LD_VAR 0 10
106070: PPUSH
106071: CALL_OW 115
106075: GO 106101
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106077: LD_VAR 0 4
106081: PUSH
106082: LD_VAR 0 7
106086: ARRAY
106087: PPUSH
106088: LD_VAR 0 14
106092: PUSH
106093: LD_INT 1
106095: ARRAY
106096: PPUSH
106097: CALL_OW 115
// if not HasTask ( group [ i ] ) then
106101: LD_VAR 0 4
106105: PUSH
106106: LD_VAR 0 7
106110: ARRAY
106111: PPUSH
106112: CALL_OW 314
106116: NOT
106117: IFFALSE 106155
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
106119: LD_VAR 0 4
106123: PUSH
106124: LD_VAR 0 7
106128: ARRAY
106129: PPUSH
106130: LD_VAR 0 14
106134: PPUSH
106135: LD_VAR 0 4
106139: PUSH
106140: LD_VAR 0 7
106144: ARRAY
106145: PPUSH
106146: CALL_OW 74
106150: PPUSH
106151: CALL_OW 115
// end ; end ; end ;
106155: GO 102034
106157: POP
106158: POP
// wait ( 0 0$2 ) ;
106159: LD_INT 70
106161: PPUSH
106162: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
106166: LD_VAR 0 4
106170: NOT
106171: PUSH
106172: LD_VAR 0 4
106176: PUSH
106177: EMPTY
106178: EQUAL
106179: OR
106180: PUSH
106181: LD_INT 81
106183: PUSH
106184: LD_VAR 0 35
106188: PUSH
106189: EMPTY
106190: LIST
106191: LIST
106192: PPUSH
106193: CALL_OW 69
106197: NOT
106198: OR
106199: IFFALSE 102019
// end ;
106201: LD_VAR 0 2
106205: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
106206: LD_INT 0
106208: PPUSH
106209: PPUSH
106210: PPUSH
106211: PPUSH
106212: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
106213: LD_VAR 0 1
106217: NOT
106218: PUSH
106219: LD_EXP 50
106223: PUSH
106224: LD_VAR 0 1
106228: ARRAY
106229: NOT
106230: OR
106231: PUSH
106232: LD_VAR 0 2
106236: NOT
106237: OR
106238: PUSH
106239: LD_VAR 0 3
106243: NOT
106244: OR
106245: IFFALSE 106249
// exit ;
106247: GO 106762
// side := mc_sides [ base ] ;
106249: LD_ADDR_VAR 0 6
106253: PUSH
106254: LD_EXP 76
106258: PUSH
106259: LD_VAR 0 1
106263: ARRAY
106264: ST_TO_ADDR
// if not side then
106265: LD_VAR 0 6
106269: NOT
106270: IFFALSE 106274
// exit ;
106272: GO 106762
// for i in solds do
106274: LD_ADDR_VAR 0 7
106278: PUSH
106279: LD_VAR 0 2
106283: PUSH
106284: FOR_IN
106285: IFFALSE 106346
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
106287: LD_VAR 0 7
106291: PPUSH
106292: CALL_OW 310
106296: PPUSH
106297: CALL_OW 266
106301: PUSH
106302: LD_INT 32
106304: PUSH
106305: LD_INT 31
106307: PUSH
106308: EMPTY
106309: LIST
106310: LIST
106311: IN
106312: IFFALSE 106332
// solds := solds diff i else
106314: LD_ADDR_VAR 0 2
106318: PUSH
106319: LD_VAR 0 2
106323: PUSH
106324: LD_VAR 0 7
106328: DIFF
106329: ST_TO_ADDR
106330: GO 106344
// SetTag ( i , 18 ) ;
106332: LD_VAR 0 7
106336: PPUSH
106337: LD_INT 18
106339: PPUSH
106340: CALL_OW 109
106344: GO 106284
106346: POP
106347: POP
// if not solds then
106348: LD_VAR 0 2
106352: NOT
106353: IFFALSE 106357
// exit ;
106355: GO 106762
// repeat wait ( 0 0$1 ) ;
106357: LD_INT 35
106359: PPUSH
106360: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
106364: LD_ADDR_VAR 0 5
106368: PUSH
106369: LD_VAR 0 6
106373: PPUSH
106374: LD_VAR 0 3
106378: PPUSH
106379: CALL 49132 0 2
106383: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
106384: LD_EXP 50
106388: PUSH
106389: LD_VAR 0 1
106393: ARRAY
106394: NOT
106395: PUSH
106396: LD_EXP 50
106400: PUSH
106401: LD_VAR 0 1
106405: ARRAY
106406: PUSH
106407: EMPTY
106408: EQUAL
106409: OR
106410: IFFALSE 106447
// begin for i in solds do
106412: LD_ADDR_VAR 0 7
106416: PUSH
106417: LD_VAR 0 2
106421: PUSH
106422: FOR_IN
106423: IFFALSE 106436
// ComStop ( i ) ;
106425: LD_VAR 0 7
106429: PPUSH
106430: CALL_OW 141
106434: GO 106422
106436: POP
106437: POP
// solds := [ ] ;
106438: LD_ADDR_VAR 0 2
106442: PUSH
106443: EMPTY
106444: ST_TO_ADDR
// exit ;
106445: GO 106762
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
106447: LD_VAR 0 5
106451: NOT
106452: PUSH
106453: LD_VAR 0 5
106457: PUSH
106458: LD_INT 3
106460: GREATER
106461: OR
106462: PUSH
106463: LD_EXP 72
106467: PUSH
106468: LD_VAR 0 1
106472: ARRAY
106473: OR
106474: IFFALSE 106515
// begin for i in solds do
106476: LD_ADDR_VAR 0 7
106480: PUSH
106481: LD_VAR 0 2
106485: PUSH
106486: FOR_IN
106487: IFFALSE 106511
// if HasTask ( i ) then
106489: LD_VAR 0 7
106493: PPUSH
106494: CALL_OW 314
106498: IFFALSE 106509
// ComStop ( i ) ;
106500: LD_VAR 0 7
106504: PPUSH
106505: CALL_OW 141
106509: GO 106486
106511: POP
106512: POP
// break ;
106513: GO 106750
// end ; for i in solds do
106515: LD_ADDR_VAR 0 7
106519: PUSH
106520: LD_VAR 0 2
106524: PUSH
106525: FOR_IN
106526: IFFALSE 106742
// begin if IsInUnit ( i ) then
106528: LD_VAR 0 7
106532: PPUSH
106533: CALL_OW 310
106537: IFFALSE 106548
// ComExitBuilding ( i ) ;
106539: LD_VAR 0 7
106543: PPUSH
106544: CALL_OW 122
// if GetLives ( i ) > 333 then
106548: LD_VAR 0 7
106552: PPUSH
106553: CALL_OW 256
106557: PUSH
106558: LD_INT 333
106560: GREATER
106561: IFFALSE 106589
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
106563: LD_VAR 0 7
106567: PPUSH
106568: LD_VAR 0 5
106572: PPUSH
106573: LD_VAR 0 7
106577: PPUSH
106578: CALL_OW 74
106582: PPUSH
106583: CALL_OW 115
106587: GO 106740
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
106589: LD_ADDR_VAR 0 8
106593: PUSH
106594: LD_EXP 50
106598: PUSH
106599: LD_VAR 0 1
106603: ARRAY
106604: PPUSH
106605: LD_INT 2
106607: PUSH
106608: LD_INT 30
106610: PUSH
106611: LD_INT 0
106613: PUSH
106614: EMPTY
106615: LIST
106616: LIST
106617: PUSH
106618: LD_INT 30
106620: PUSH
106621: LD_INT 1
106623: PUSH
106624: EMPTY
106625: LIST
106626: LIST
106627: PUSH
106628: LD_INT 30
106630: PUSH
106631: LD_INT 6
106633: PUSH
106634: EMPTY
106635: LIST
106636: LIST
106637: PUSH
106638: EMPTY
106639: LIST
106640: LIST
106641: LIST
106642: LIST
106643: PPUSH
106644: CALL_OW 72
106648: PPUSH
106649: LD_VAR 0 7
106653: PPUSH
106654: CALL_OW 74
106658: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
106659: LD_VAR 0 7
106663: PPUSH
106664: LD_VAR 0 8
106668: PPUSH
106669: CALL_OW 250
106673: PPUSH
106674: LD_INT 3
106676: PPUSH
106677: LD_INT 5
106679: PPUSH
106680: CALL_OW 272
106684: PPUSH
106685: LD_VAR 0 8
106689: PPUSH
106690: CALL_OW 251
106694: PPUSH
106695: LD_INT 3
106697: PPUSH
106698: LD_INT 5
106700: PPUSH
106701: CALL_OW 273
106705: PPUSH
106706: CALL_OW 111
// SetTag ( i , 0 ) ;
106710: LD_VAR 0 7
106714: PPUSH
106715: LD_INT 0
106717: PPUSH
106718: CALL_OW 109
// solds := solds diff i ;
106722: LD_ADDR_VAR 0 2
106726: PUSH
106727: LD_VAR 0 2
106731: PUSH
106732: LD_VAR 0 7
106736: DIFF
106737: ST_TO_ADDR
// continue ;
106738: GO 106525
// end ; end ;
106740: GO 106525
106742: POP
106743: POP
// until solds ;
106744: LD_VAR 0 2
106748: IFFALSE 106357
// MC_Reset ( base , 18 ) ;
106750: LD_VAR 0 1
106754: PPUSH
106755: LD_INT 18
106757: PPUSH
106758: CALL 21440 0 2
// end ;
106762: LD_VAR 0 4
106766: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
106767: LD_INT 0
106769: PPUSH
106770: PPUSH
106771: PPUSH
106772: PPUSH
106773: PPUSH
106774: PPUSH
106775: PPUSH
106776: PPUSH
106777: PPUSH
106778: PPUSH
106779: PPUSH
106780: PPUSH
106781: PPUSH
106782: PPUSH
106783: PPUSH
106784: PPUSH
106785: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
106786: LD_ADDR_VAR 0 13
106790: PUSH
106791: LD_EXP 50
106795: PUSH
106796: LD_VAR 0 1
106800: ARRAY
106801: PPUSH
106802: LD_INT 25
106804: PUSH
106805: LD_INT 3
106807: PUSH
106808: EMPTY
106809: LIST
106810: LIST
106811: PPUSH
106812: CALL_OW 72
106816: ST_TO_ADDR
// if mc_remote_driver [ base ] then
106817: LD_EXP 90
106821: PUSH
106822: LD_VAR 0 1
106826: ARRAY
106827: IFFALSE 106851
// mechs := mechs diff mc_remote_driver [ base ] ;
106829: LD_ADDR_VAR 0 13
106833: PUSH
106834: LD_VAR 0 13
106838: PUSH
106839: LD_EXP 90
106843: PUSH
106844: LD_VAR 0 1
106848: ARRAY
106849: DIFF
106850: ST_TO_ADDR
// for i in mechs do
106851: LD_ADDR_VAR 0 5
106855: PUSH
106856: LD_VAR 0 13
106860: PUSH
106861: FOR_IN
106862: IFFALSE 106897
// if GetTag ( i ) > 0 then
106864: LD_VAR 0 5
106868: PPUSH
106869: CALL_OW 110
106873: PUSH
106874: LD_INT 0
106876: GREATER
106877: IFFALSE 106895
// mechs := mechs diff i ;
106879: LD_ADDR_VAR 0 13
106883: PUSH
106884: LD_VAR 0 13
106888: PUSH
106889: LD_VAR 0 5
106893: DIFF
106894: ST_TO_ADDR
106895: GO 106861
106897: POP
106898: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
106899: LD_ADDR_VAR 0 9
106903: PUSH
106904: LD_EXP 50
106908: PUSH
106909: LD_VAR 0 1
106913: ARRAY
106914: PPUSH
106915: LD_INT 2
106917: PUSH
106918: LD_INT 25
106920: PUSH
106921: LD_INT 1
106923: PUSH
106924: EMPTY
106925: LIST
106926: LIST
106927: PUSH
106928: LD_INT 25
106930: PUSH
106931: LD_INT 5
106933: PUSH
106934: EMPTY
106935: LIST
106936: LIST
106937: PUSH
106938: LD_INT 25
106940: PUSH
106941: LD_INT 8
106943: PUSH
106944: EMPTY
106945: LIST
106946: LIST
106947: PUSH
106948: LD_INT 25
106950: PUSH
106951: LD_INT 9
106953: PUSH
106954: EMPTY
106955: LIST
106956: LIST
106957: PUSH
106958: EMPTY
106959: LIST
106960: LIST
106961: LIST
106962: LIST
106963: LIST
106964: PPUSH
106965: CALL_OW 72
106969: ST_TO_ADDR
// if not defenders and not solds then
106970: LD_VAR 0 2
106974: NOT
106975: PUSH
106976: LD_VAR 0 9
106980: NOT
106981: AND
106982: IFFALSE 106986
// exit ;
106984: GO 108612
// depot_under_attack := false ;
106986: LD_ADDR_VAR 0 17
106990: PUSH
106991: LD_INT 0
106993: ST_TO_ADDR
// sold_defenders := [ ] ;
106994: LD_ADDR_VAR 0 18
106998: PUSH
106999: EMPTY
107000: ST_TO_ADDR
// if mechs then
107001: LD_VAR 0 13
107005: IFFALSE 107134
// for i in defenders do
107007: LD_ADDR_VAR 0 5
107011: PUSH
107012: LD_VAR 0 2
107016: PUSH
107017: FOR_IN
107018: IFFALSE 107132
// begin SetTag ( i , 20 ) ;
107020: LD_VAR 0 5
107024: PPUSH
107025: LD_INT 20
107027: PPUSH
107028: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
107032: LD_VAR 0 5
107036: PPUSH
107037: CALL_OW 263
107041: PUSH
107042: LD_INT 1
107044: EQUAL
107045: PUSH
107046: LD_VAR 0 5
107050: PPUSH
107051: CALL_OW 311
107055: NOT
107056: AND
107057: PUSH
107058: LD_VAR 0 13
107062: AND
107063: IFFALSE 107130
// begin un := mechs [ 1 ] ;
107065: LD_ADDR_VAR 0 11
107069: PUSH
107070: LD_VAR 0 13
107074: PUSH
107075: LD_INT 1
107077: ARRAY
107078: ST_TO_ADDR
// ComExitBuilding ( un ) ;
107079: LD_VAR 0 11
107083: PPUSH
107084: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
107088: LD_VAR 0 11
107092: PPUSH
107093: LD_VAR 0 5
107097: PPUSH
107098: CALL_OW 180
// SetTag ( un , 19 ) ;
107102: LD_VAR 0 11
107106: PPUSH
107107: LD_INT 19
107109: PPUSH
107110: CALL_OW 109
// mechs := mechs diff un ;
107114: LD_ADDR_VAR 0 13
107118: PUSH
107119: LD_VAR 0 13
107123: PUSH
107124: LD_VAR 0 11
107128: DIFF
107129: ST_TO_ADDR
// end ; end ;
107130: GO 107017
107132: POP
107133: POP
// if solds then
107134: LD_VAR 0 9
107138: IFFALSE 107197
// for i in solds do
107140: LD_ADDR_VAR 0 5
107144: PUSH
107145: LD_VAR 0 9
107149: PUSH
107150: FOR_IN
107151: IFFALSE 107195
// if not GetTag ( i ) then
107153: LD_VAR 0 5
107157: PPUSH
107158: CALL_OW 110
107162: NOT
107163: IFFALSE 107193
// begin defenders := defenders union i ;
107165: LD_ADDR_VAR 0 2
107169: PUSH
107170: LD_VAR 0 2
107174: PUSH
107175: LD_VAR 0 5
107179: UNION
107180: ST_TO_ADDR
// SetTag ( i , 18 ) ;
107181: LD_VAR 0 5
107185: PPUSH
107186: LD_INT 18
107188: PPUSH
107189: CALL_OW 109
// end ;
107193: GO 107150
107195: POP
107196: POP
// repeat wait ( 0 0$1 ) ;
107197: LD_INT 35
107199: PPUSH
107200: CALL_OW 67
// enemy := mc_scan [ base ] ;
107204: LD_ADDR_VAR 0 3
107208: PUSH
107209: LD_EXP 73
107213: PUSH
107214: LD_VAR 0 1
107218: ARRAY
107219: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107220: LD_EXP 50
107224: PUSH
107225: LD_VAR 0 1
107229: ARRAY
107230: NOT
107231: PUSH
107232: LD_EXP 50
107236: PUSH
107237: LD_VAR 0 1
107241: ARRAY
107242: PUSH
107243: EMPTY
107244: EQUAL
107245: OR
107246: IFFALSE 107283
// begin for i in defenders do
107248: LD_ADDR_VAR 0 5
107252: PUSH
107253: LD_VAR 0 2
107257: PUSH
107258: FOR_IN
107259: IFFALSE 107272
// ComStop ( i ) ;
107261: LD_VAR 0 5
107265: PPUSH
107266: CALL_OW 141
107270: GO 107258
107272: POP
107273: POP
// defenders := [ ] ;
107274: LD_ADDR_VAR 0 2
107278: PUSH
107279: EMPTY
107280: ST_TO_ADDR
// exit ;
107281: GO 108612
// end ; for i in defenders do
107283: LD_ADDR_VAR 0 5
107287: PUSH
107288: LD_VAR 0 2
107292: PUSH
107293: FOR_IN
107294: IFFALSE 108112
// begin e := NearestUnitToUnit ( enemy , i ) ;
107296: LD_ADDR_VAR 0 14
107300: PUSH
107301: LD_VAR 0 3
107305: PPUSH
107306: LD_VAR 0 5
107310: PPUSH
107311: CALL_OW 74
107315: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107316: LD_ADDR_VAR 0 8
107320: PUSH
107321: LD_EXP 50
107325: PUSH
107326: LD_VAR 0 1
107330: ARRAY
107331: PPUSH
107332: LD_INT 2
107334: PUSH
107335: LD_INT 30
107337: PUSH
107338: LD_INT 0
107340: PUSH
107341: EMPTY
107342: LIST
107343: LIST
107344: PUSH
107345: LD_INT 30
107347: PUSH
107348: LD_INT 1
107350: PUSH
107351: EMPTY
107352: LIST
107353: LIST
107354: PUSH
107355: EMPTY
107356: LIST
107357: LIST
107358: LIST
107359: PPUSH
107360: CALL_OW 72
107364: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
107365: LD_ADDR_VAR 0 17
107369: PUSH
107370: LD_VAR 0 8
107374: NOT
107375: PUSH
107376: LD_VAR 0 8
107380: PPUSH
107381: LD_INT 3
107383: PUSH
107384: LD_INT 24
107386: PUSH
107387: LD_INT 600
107389: PUSH
107390: EMPTY
107391: LIST
107392: LIST
107393: PUSH
107394: EMPTY
107395: LIST
107396: LIST
107397: PPUSH
107398: CALL_OW 72
107402: OR
107403: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
107404: LD_VAR 0 5
107408: PPUSH
107409: CALL_OW 247
107413: PUSH
107414: LD_INT 2
107416: DOUBLE
107417: EQUAL
107418: IFTRUE 107422
107420: GO 107818
107422: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
107423: LD_VAR 0 5
107427: PPUSH
107428: CALL_OW 256
107432: PUSH
107433: LD_INT 650
107435: GREATER
107436: PUSH
107437: LD_VAR 0 5
107441: PPUSH
107442: LD_VAR 0 14
107446: PPUSH
107447: CALL_OW 296
107451: PUSH
107452: LD_INT 40
107454: LESS
107455: PUSH
107456: LD_VAR 0 14
107460: PPUSH
107461: LD_EXP 75
107465: PUSH
107466: LD_VAR 0 1
107470: ARRAY
107471: PPUSH
107472: CALL_OW 308
107476: OR
107477: AND
107478: IFFALSE 107600
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
107480: LD_VAR 0 5
107484: PPUSH
107485: CALL_OW 262
107489: PUSH
107490: LD_INT 1
107492: EQUAL
107493: PUSH
107494: LD_VAR 0 5
107498: PPUSH
107499: CALL_OW 261
107503: PUSH
107504: LD_INT 30
107506: LESS
107507: AND
107508: PUSH
107509: LD_VAR 0 8
107513: AND
107514: IFFALSE 107584
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
107516: LD_VAR 0 5
107520: PPUSH
107521: LD_VAR 0 8
107525: PPUSH
107526: LD_VAR 0 5
107530: PPUSH
107531: CALL_OW 74
107535: PPUSH
107536: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
107540: LD_VAR 0 5
107544: PPUSH
107545: LD_VAR 0 8
107549: PPUSH
107550: LD_VAR 0 5
107554: PPUSH
107555: CALL_OW 74
107559: PPUSH
107560: CALL_OW 296
107564: PUSH
107565: LD_INT 6
107567: LESS
107568: IFFALSE 107582
// SetFuel ( i , 100 ) ;
107570: LD_VAR 0 5
107574: PPUSH
107575: LD_INT 100
107577: PPUSH
107578: CALL_OW 240
// end else
107582: GO 107598
// ComAttackUnit ( i , e ) ;
107584: LD_VAR 0 5
107588: PPUSH
107589: LD_VAR 0 14
107593: PPUSH
107594: CALL_OW 115
// end else
107598: GO 107701
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
107600: LD_VAR 0 14
107604: PPUSH
107605: LD_EXP 75
107609: PUSH
107610: LD_VAR 0 1
107614: ARRAY
107615: PPUSH
107616: CALL_OW 308
107620: NOT
107621: PUSH
107622: LD_VAR 0 5
107626: PPUSH
107627: LD_VAR 0 14
107631: PPUSH
107632: CALL_OW 296
107636: PUSH
107637: LD_INT 40
107639: GREATEREQUAL
107640: AND
107641: PUSH
107642: LD_VAR 0 5
107646: PPUSH
107647: CALL_OW 256
107651: PUSH
107652: LD_INT 650
107654: LESSEQUAL
107655: OR
107656: PUSH
107657: LD_VAR 0 5
107661: PPUSH
107662: LD_EXP 74
107666: PUSH
107667: LD_VAR 0 1
107671: ARRAY
107672: PPUSH
107673: CALL_OW 308
107677: NOT
107678: AND
107679: IFFALSE 107701
// ComMoveToArea ( i , mc_parking [ base ] ) ;
107681: LD_VAR 0 5
107685: PPUSH
107686: LD_EXP 74
107690: PUSH
107691: LD_VAR 0 1
107695: ARRAY
107696: PPUSH
107697: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
107701: LD_VAR 0 5
107705: PPUSH
107706: CALL_OW 256
107710: PUSH
107711: LD_INT 998
107713: LESS
107714: PUSH
107715: LD_VAR 0 5
107719: PPUSH
107720: CALL_OW 263
107724: PUSH
107725: LD_INT 1
107727: EQUAL
107728: AND
107729: PUSH
107730: LD_VAR 0 5
107734: PPUSH
107735: CALL_OW 311
107739: AND
107740: PUSH
107741: LD_VAR 0 5
107745: PPUSH
107746: LD_EXP 74
107750: PUSH
107751: LD_VAR 0 1
107755: ARRAY
107756: PPUSH
107757: CALL_OW 308
107761: AND
107762: IFFALSE 107816
// begin mech := IsDrivenBy ( i ) ;
107764: LD_ADDR_VAR 0 10
107768: PUSH
107769: LD_VAR 0 5
107773: PPUSH
107774: CALL_OW 311
107778: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
107779: LD_VAR 0 10
107783: PPUSH
107784: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
107788: LD_VAR 0 10
107792: PPUSH
107793: LD_VAR 0 5
107797: PPUSH
107798: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
107802: LD_VAR 0 10
107806: PPUSH
107807: LD_VAR 0 5
107811: PPUSH
107812: CALL_OW 180
// end ; end ; unit_human :
107816: GO 108083
107818: LD_INT 1
107820: DOUBLE
107821: EQUAL
107822: IFTRUE 107826
107824: GO 108082
107826: POP
// begin b := IsInUnit ( i ) ;
107827: LD_ADDR_VAR 0 19
107831: PUSH
107832: LD_VAR 0 5
107836: PPUSH
107837: CALL_OW 310
107841: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
107842: LD_ADDR_VAR 0 20
107846: PUSH
107847: LD_VAR 0 19
107851: NOT
107852: PUSH
107853: LD_VAR 0 19
107857: PPUSH
107858: CALL_OW 266
107862: PUSH
107863: LD_INT 32
107865: PUSH
107866: LD_INT 31
107868: PUSH
107869: EMPTY
107870: LIST
107871: LIST
107872: IN
107873: OR
107874: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
107875: LD_VAR 0 17
107879: PUSH
107880: LD_VAR 0 2
107884: PPUSH
107885: LD_INT 21
107887: PUSH
107888: LD_INT 2
107890: PUSH
107891: EMPTY
107892: LIST
107893: LIST
107894: PPUSH
107895: CALL_OW 72
107899: PUSH
107900: LD_INT 1
107902: LESSEQUAL
107903: OR
107904: PUSH
107905: LD_VAR 0 20
107909: AND
107910: PUSH
107911: LD_VAR 0 5
107915: PUSH
107916: LD_VAR 0 18
107920: IN
107921: NOT
107922: AND
107923: IFFALSE 108016
// begin if b then
107925: LD_VAR 0 19
107929: IFFALSE 107978
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
107931: LD_VAR 0 19
107935: PPUSH
107936: LD_VAR 0 3
107940: PPUSH
107941: LD_VAR 0 19
107945: PPUSH
107946: CALL_OW 74
107950: PPUSH
107951: CALL_OW 296
107955: PUSH
107956: LD_INT 10
107958: LESS
107959: PUSH
107960: LD_VAR 0 19
107964: PPUSH
107965: CALL_OW 461
107969: PUSH
107970: LD_INT 7
107972: NONEQUAL
107973: AND
107974: IFFALSE 107978
// continue ;
107976: GO 107293
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
107978: LD_ADDR_VAR 0 18
107982: PUSH
107983: LD_VAR 0 18
107987: PPUSH
107988: LD_VAR 0 18
107992: PUSH
107993: LD_INT 1
107995: PLUS
107996: PPUSH
107997: LD_VAR 0 5
108001: PPUSH
108002: CALL_OW 1
108006: ST_TO_ADDR
// ComExitBuilding ( i ) ;
108007: LD_VAR 0 5
108011: PPUSH
108012: CALL_OW 122
// end ; if sold_defenders then
108016: LD_VAR 0 18
108020: IFFALSE 108080
// if i in sold_defenders then
108022: LD_VAR 0 5
108026: PUSH
108027: LD_VAR 0 18
108031: IN
108032: IFFALSE 108080
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
108034: LD_VAR 0 5
108038: PPUSH
108039: CALL_OW 314
108043: NOT
108044: PUSH
108045: LD_VAR 0 5
108049: PPUSH
108050: LD_VAR 0 14
108054: PPUSH
108055: CALL_OW 296
108059: PUSH
108060: LD_INT 30
108062: LESS
108063: AND
108064: IFFALSE 108080
// ComAttackUnit ( i , e ) ;
108066: LD_VAR 0 5
108070: PPUSH
108071: LD_VAR 0 14
108075: PPUSH
108076: CALL_OW 115
// end ; end ; end ;
108080: GO 108083
108082: POP
// if IsDead ( i ) then
108083: LD_VAR 0 5
108087: PPUSH
108088: CALL_OW 301
108092: IFFALSE 108110
// defenders := defenders diff i ;
108094: LD_ADDR_VAR 0 2
108098: PUSH
108099: LD_VAR 0 2
108103: PUSH
108104: LD_VAR 0 5
108108: DIFF
108109: ST_TO_ADDR
// end ;
108110: GO 107293
108112: POP
108113: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
108114: LD_VAR 0 3
108118: NOT
108119: PUSH
108120: LD_VAR 0 2
108124: NOT
108125: OR
108126: PUSH
108127: LD_EXP 50
108131: PUSH
108132: LD_VAR 0 1
108136: ARRAY
108137: NOT
108138: OR
108139: IFFALSE 107197
// MC_Reset ( base , 18 ) ;
108141: LD_VAR 0 1
108145: PPUSH
108146: LD_INT 18
108148: PPUSH
108149: CALL 21440 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108153: LD_ADDR_VAR 0 2
108157: PUSH
108158: LD_VAR 0 2
108162: PUSH
108163: LD_VAR 0 2
108167: PPUSH
108168: LD_INT 2
108170: PUSH
108171: LD_INT 25
108173: PUSH
108174: LD_INT 1
108176: PUSH
108177: EMPTY
108178: LIST
108179: LIST
108180: PUSH
108181: LD_INT 25
108183: PUSH
108184: LD_INT 5
108186: PUSH
108187: EMPTY
108188: LIST
108189: LIST
108190: PUSH
108191: LD_INT 25
108193: PUSH
108194: LD_INT 8
108196: PUSH
108197: EMPTY
108198: LIST
108199: LIST
108200: PUSH
108201: LD_INT 25
108203: PUSH
108204: LD_INT 9
108206: PUSH
108207: EMPTY
108208: LIST
108209: LIST
108210: PUSH
108211: EMPTY
108212: LIST
108213: LIST
108214: LIST
108215: LIST
108216: LIST
108217: PPUSH
108218: CALL_OW 72
108222: DIFF
108223: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
108224: LD_VAR 0 3
108228: NOT
108229: PUSH
108230: LD_VAR 0 2
108234: PPUSH
108235: LD_INT 21
108237: PUSH
108238: LD_INT 2
108240: PUSH
108241: EMPTY
108242: LIST
108243: LIST
108244: PPUSH
108245: CALL_OW 72
108249: AND
108250: IFFALSE 108588
// begin tmp := FilterByTag ( defenders , 19 ) ;
108252: LD_ADDR_VAR 0 12
108256: PUSH
108257: LD_VAR 0 2
108261: PPUSH
108262: LD_INT 19
108264: PPUSH
108265: CALL 80892 0 2
108269: ST_TO_ADDR
// if tmp then
108270: LD_VAR 0 12
108274: IFFALSE 108344
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
108276: LD_ADDR_VAR 0 12
108280: PUSH
108281: LD_VAR 0 12
108285: PPUSH
108286: LD_INT 25
108288: PUSH
108289: LD_INT 3
108291: PUSH
108292: EMPTY
108293: LIST
108294: LIST
108295: PPUSH
108296: CALL_OW 72
108300: ST_TO_ADDR
// if tmp then
108301: LD_VAR 0 12
108305: IFFALSE 108344
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
108307: LD_ADDR_EXP 62
108311: PUSH
108312: LD_EXP 62
108316: PPUSH
108317: LD_VAR 0 1
108321: PPUSH
108322: LD_EXP 62
108326: PUSH
108327: LD_VAR 0 1
108331: ARRAY
108332: PUSH
108333: LD_VAR 0 12
108337: UNION
108338: PPUSH
108339: CALL_OW 1
108343: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
108344: LD_VAR 0 1
108348: PPUSH
108349: LD_INT 19
108351: PPUSH
108352: CALL 21440 0 2
// repeat wait ( 0 0$1 ) ;
108356: LD_INT 35
108358: PPUSH
108359: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
108363: LD_EXP 50
108367: PUSH
108368: LD_VAR 0 1
108372: ARRAY
108373: NOT
108374: PUSH
108375: LD_EXP 50
108379: PUSH
108380: LD_VAR 0 1
108384: ARRAY
108385: PUSH
108386: EMPTY
108387: EQUAL
108388: OR
108389: IFFALSE 108426
// begin for i in defenders do
108391: LD_ADDR_VAR 0 5
108395: PUSH
108396: LD_VAR 0 2
108400: PUSH
108401: FOR_IN
108402: IFFALSE 108415
// ComStop ( i ) ;
108404: LD_VAR 0 5
108408: PPUSH
108409: CALL_OW 141
108413: GO 108401
108415: POP
108416: POP
// defenders := [ ] ;
108417: LD_ADDR_VAR 0 2
108421: PUSH
108422: EMPTY
108423: ST_TO_ADDR
// exit ;
108424: GO 108612
// end ; for i in defenders do
108426: LD_ADDR_VAR 0 5
108430: PUSH
108431: LD_VAR 0 2
108435: PUSH
108436: FOR_IN
108437: IFFALSE 108526
// begin if not IsInArea ( i , mc_parking [ base ] ) then
108439: LD_VAR 0 5
108443: PPUSH
108444: LD_EXP 74
108448: PUSH
108449: LD_VAR 0 1
108453: ARRAY
108454: PPUSH
108455: CALL_OW 308
108459: NOT
108460: IFFALSE 108484
// ComMoveToArea ( i , mc_parking [ base ] ) else
108462: LD_VAR 0 5
108466: PPUSH
108467: LD_EXP 74
108471: PUSH
108472: LD_VAR 0 1
108476: ARRAY
108477: PPUSH
108478: CALL_OW 113
108482: GO 108524
// if GetControl ( i ) = control_manual then
108484: LD_VAR 0 5
108488: PPUSH
108489: CALL_OW 263
108493: PUSH
108494: LD_INT 1
108496: EQUAL
108497: IFFALSE 108524
// if IsDrivenBy ( i ) then
108499: LD_VAR 0 5
108503: PPUSH
108504: CALL_OW 311
108508: IFFALSE 108524
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
108510: LD_VAR 0 5
108514: PPUSH
108515: CALL_OW 311
108519: PPUSH
108520: CALL_OW 121
// end ;
108524: GO 108436
108526: POP
108527: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
108528: LD_VAR 0 2
108532: PPUSH
108533: LD_INT 95
108535: PUSH
108536: LD_EXP 74
108540: PUSH
108541: LD_VAR 0 1
108545: ARRAY
108546: PUSH
108547: EMPTY
108548: LIST
108549: LIST
108550: PPUSH
108551: CALL_OW 72
108555: PUSH
108556: LD_VAR 0 2
108560: EQUAL
108561: PUSH
108562: LD_EXP 73
108566: PUSH
108567: LD_VAR 0 1
108571: ARRAY
108572: OR
108573: PUSH
108574: LD_EXP 50
108578: PUSH
108579: LD_VAR 0 1
108583: ARRAY
108584: NOT
108585: OR
108586: IFFALSE 108356
// end ; MC_Reset ( base , 19 ) ;
108588: LD_VAR 0 1
108592: PPUSH
108593: LD_INT 19
108595: PPUSH
108596: CALL 21440 0 2
// MC_Reset ( base , 20 ) ;
108600: LD_VAR 0 1
108604: PPUSH
108605: LD_INT 20
108607: PPUSH
108608: CALL 21440 0 2
// end ; end_of_file
108612: LD_VAR 0 4
108616: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
108617: LD_VAR 0 1
108621: PUSH
108622: LD_INT 200
108624: DOUBLE
108625: GREATEREQUAL
108626: IFFALSE 108634
108628: LD_INT 299
108630: DOUBLE
108631: LESSEQUAL
108632: IFTRUE 108636
108634: GO 108668
108636: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
108637: LD_VAR 0 1
108641: PPUSH
108642: LD_VAR 0 2
108646: PPUSH
108647: LD_VAR 0 3
108651: PPUSH
108652: LD_VAR 0 4
108656: PPUSH
108657: LD_VAR 0 5
108661: PPUSH
108662: CALL 97622 0 5
108666: GO 108745
108668: LD_INT 300
108670: DOUBLE
108671: GREATEREQUAL
108672: IFFALSE 108680
108674: LD_INT 399
108676: DOUBLE
108677: LESSEQUAL
108678: IFTRUE 108682
108680: GO 108744
108682: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
108683: LD_VAR 0 1
108687: PPUSH
108688: LD_VAR 0 2
108692: PPUSH
108693: LD_VAR 0 3
108697: PPUSH
108698: LD_VAR 0 4
108702: PPUSH
108703: LD_VAR 0 5
108707: PPUSH
108708: LD_VAR 0 6
108712: PPUSH
108713: LD_VAR 0 7
108717: PPUSH
108718: LD_VAR 0 8
108722: PPUSH
108723: LD_VAR 0 9
108727: PPUSH
108728: LD_VAR 0 10
108732: PPUSH
108733: LD_VAR 0 11
108737: PPUSH
108738: CALL 95528 0 11
108742: GO 108745
108744: POP
// end ;
108745: PPOPN 11
108747: END
