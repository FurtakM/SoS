// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 98 0 0
// InitGlobalVariables ;
  19: CALL 88646 0 0
// InitMacro ;
  23: CALL 17929 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  40: LD_INT 8
  42: PPUSH
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  50: LD_INT 4
  52: PPUSH
  53: LD_INT 3
  55: PPUSH
  56: LD_INT 6
  58: PPUSH
  59: LD_INT 3
  61: PPUSH
  62: LD_INT 2
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 7
  70: PPUSH
  71: LD_INT 18
  73: PPUSH
  74: LD_INT 19
  76: PPUSH
  77: CALL 81918 0 9
// PrepareAmerican ;
  81: CALL 663 0 0
// PrepareArabian ;
  85: CALL 2614 0 0
// MC_Start ( ) ;
  89: CALL 20094 0 0
// Action ;
  93: CALL 8559 0 0
// end ;
  97: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  98: LD_INT 0
 100: PPUSH
// debug := false ;
 101: LD_ADDR_EXP 1
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// game := true ;
 109: LD_ADDR_EXP 2
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// mission_prefix := 11_ ;
 117: LD_ADDR_EXP 3
 121: PUSH
 122: LD_STRING 11_
 124: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 125: LD_ADDR_EXP 4
 129: PUSH
 130: LD_STRING 10c_
 132: ST_TO_ADDR
// ar_run := false ;
 133: LD_ADDR_EXP 5
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// ar_patrol := false ;
 141: LD_ADDR_EXP 7
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// base_captured := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// us_scout := 0 ;
 157: LD_ADDR_EXP 8
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 165: LD_ADDR_EXP 9
 169: PUSH
 170: LD_INT 0
 172: PUSH
 173: LD_INT 0
 175: PUSH
 176: LD_INT 0
 178: PUSH
 179: LD_INT 0
 181: PUSH
 182: LD_INT 0
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: LIST
 189: LIST
 190: LIST
 191: ST_TO_ADDR
// kamikazed := false ;
 192: LD_ADDR_EXP 11
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifact_stolen := false ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// artifact_get := false ;
 208: LD_ADDR_EXP 13
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 273000
 223: PUSH
 224: LD_INT 252000
 226: PUSH
 227: LD_INT 241500
 229: PUSH
 230: LD_INT 235200
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: ST_TO_ADDR
// powell_warn := false ;
 245: LD_ADDR_EXP 16
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// loses_counter := 0 ;
 253: LD_ADDR_EXP 17
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// artifact_oncargo := false ;
 261: LD_ADDR_EXP 14
 265: PUSH
 266: LD_INT 0
 268: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 269: LD_ADDR_EXP 18
 273: PUSH
 274: LD_STRING 10_GensherEscape_1
 276: PPUSH
 277: LD_EXP 1
 281: PPUSH
 282: CALL_OW 30
 286: ST_TO_ADDR
// can_kamikazed := false ;
 287: LD_ADDR_EXP 10
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// am_veh_consturcted := false ;
 295: LD_ADDR_EXP 20
 299: PUSH
 300: LD_INT 0
 302: ST_TO_ADDR
// end ;
 303: LD_VAR 0 1
 307: RET
// export function CustomInitMacro ; var i ; begin
 308: LD_INT 0
 310: PPUSH
 311: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 312: LD_ADDR_EXP 74
 316: PUSH
 317: LD_INT 20
 319: PUSH
 320: LD_INT 21
 322: PUSH
 323: LD_INT 22
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 331: LD_ADDR_EXP 75
 335: PUSH
 336: LD_INT 28
 338: PUSH
 339: LD_INT 24
 341: PUSH
 342: LD_INT 26
 344: PUSH
 345: EMPTY
 346: LIST
 347: LIST
 348: LIST
 349: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 4
 355: PUSH
 356: LD_INT 6
 358: PUSH
 359: LD_INT 8
 361: PUSH
 362: LD_INT 9
 364: PUSH
 365: EMPTY
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: PUSH
 371: LD_OWVAR 67
 375: ARRAY
 376: PPUSH
 377: LD_INT 3
 379: PPUSH
 380: CALL 41783 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 384: LD_INT 2
 386: PPUSH
 387: LD_INT 4
 389: PUSH
 390: LD_INT 6
 392: PUSH
 393: LD_INT 8
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: LIST
 404: PUSH
 405: LD_OWVAR 67
 409: ARRAY
 410: PPUSH
 411: LD_INT 2
 413: PPUSH
 414: CALL 41783 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 418: LD_INT 3
 420: PPUSH
 421: LD_INT 4
 423: PUSH
 424: LD_INT 6
 426: PUSH
 427: LD_INT 8
 429: PUSH
 430: LD_INT 9
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_OWVAR 67
 443: ARRAY
 444: PPUSH
 445: LD_INT 1
 447: PPUSH
 448: CALL 41783 0 3
// for i = 1 to mc_bases do
 452: LD_ADDR_VAR 0 2
 456: PUSH
 457: DOUBLE
 458: LD_INT 1
 460: DEC
 461: ST_TO_ADDR
 462: LD_EXP 50
 466: PUSH
 467: FOR_TO
 468: IFFALSE 492
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 470: LD_VAR 0 2
 474: PPUSH
 475: LD_EXP 43
 479: PUSH
 480: LD_VAR 0 2
 484: ARRAY
 485: PPUSH
 486: CALL 42209 0 2
 490: GO 467
 492: POP
 493: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 494: LD_INT 1
 496: PPUSH
 497: LD_INT 14
 499: PUSH
 500: LD_INT 1
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_EXP 100
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: PUSH
 517: LD_INT 14
 519: PUSH
 520: LD_INT 1
 522: PUSH
 523: LD_INT 2
 525: PUSH
 526: LD_EXP 100
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL 42101 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 545: LD_INT 2
 547: PPUSH
 548: LD_INT 14
 550: PUSH
 551: LD_INT 1
 553: PUSH
 554: LD_INT 2
 556: PUSH
 557: LD_EXP 100
 561: PUSH
 562: EMPTY
 563: LIST
 564: LIST
 565: LIST
 566: LIST
 567: PUSH
 568: EMPTY
 569: LIST
 570: PPUSH
 571: CALL 42101 0 2
// end ;
 575: LD_VAR 0 1
 579: RET
// function Debuger ; var i ; begin
 580: LD_INT 0
 582: PPUSH
 583: PPUSH
// if not debug then
 584: LD_EXP 1
 588: NOT
 589: IFFALSE 593
// exit ;
 591: GO 629
// game_speed := 5 ;
 593: LD_ADDR_OWVAR 65
 597: PUSH
 598: LD_INT 5
 600: ST_TO_ADDR
// uc_side := 1 ;
 601: LD_ADDR_OWVAR 20
 605: PUSH
 606: LD_INT 1
 608: ST_TO_ADDR
// uc_nation := 1 ;
 609: LD_ADDR_OWVAR 21
 613: PUSH
 614: LD_INT 1
 616: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 617: LD_EXP 36
 621: PPUSH
 622: LD_INT 1
 624: PPUSH
 625: CALL_OW 235
// end ;
 629: LD_VAR 0 1
 633: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 634: LD_INT 94
 636: PPUSH
 637: CALL_OW 301
 641: PUSH
 642: LD_INT 45
 644: PPUSH
 645: CALL_OW 302
 649: AND
 650: IFFALSE 662
 652: GO 654
 654: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 655: LD_STRING ACH_EAST
 657: PPUSH
 658: CALL_OW 543
 662: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 663: LD_INT 0
 665: PPUSH
 666: PPUSH
 667: PPUSH
 668: PPUSH
 669: PPUSH
 670: PPUSH
 671: PPUSH
 672: PPUSH
// uc_side := 4 ;
 673: LD_ADDR_OWVAR 20
 677: PUSH
 678: LD_INT 4
 680: ST_TO_ADDR
// uc_nation := 1 ;
 681: LD_ADDR_OWVAR 21
 685: PUSH
 686: LD_INT 1
 688: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 689: LD_ADDR_EXP 30
 693: PUSH
 694: LD_STRING Powell
 696: PPUSH
 697: LD_INT 0
 699: PPUSH
 700: LD_STRING 
 702: PPUSH
 703: CALL 48555 0 3
 707: ST_TO_ADDR
// uc_side := 1 ;
 708: LD_ADDR_OWVAR 20
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 716: LD_ADDR_EXP 21
 720: PUSH
 721: LD_STRING JMM
 723: PPUSH
 724: LD_EXP 1
 728: NOT
 729: PPUSH
 730: LD_EXP 4
 734: PPUSH
 735: CALL 48555 0 3
 739: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 740: LD_EXP 21
 744: PPUSH
 745: CALL_OW 257
 749: PUSH
 750: LD_INT 4
 752: GREATER
 753: IFFALSE 767
// SetClass ( JMM , 1 ) ;
 755: LD_EXP 21
 759: PPUSH
 760: LD_INT 1
 762: PPUSH
 763: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 767: LD_ADDR_EXP 22
 771: PUSH
 772: LD_STRING Lisa
 774: PPUSH
 775: LD_EXP 1
 779: NOT
 780: PPUSH
 781: LD_EXP 4
 785: PPUSH
 786: CALL 48555 0 3
 790: ST_TO_ADDR
// if not Lisa then
 791: LD_EXP 22
 795: NOT
 796: IFFALSE 811
// Lisa := CreateCharacter ( 10_Lisa ) ;
 798: LD_ADDR_EXP 22
 802: PUSH
 803: LD_STRING 10_Lisa
 805: PPUSH
 806: CALL_OW 34
 810: ST_TO_ADDR
// if not Lisa then
 811: LD_EXP 22
 815: NOT
 816: IFFALSE 831
// Lisa := CreateCharacter ( 09_Lisa ) ;
 818: LD_ADDR_EXP 22
 822: PUSH
 823: LD_STRING 09_Lisa
 825: PPUSH
 826: CALL_OW 34
 830: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 831: LD_ADDR_EXP 31
 835: PUSH
 836: LD_STRING Cornel
 838: PPUSH
 839: LD_EXP 1
 843: NOT
 844: PPUSH
 845: LD_EXP 4
 849: PPUSH
 850: CALL 48555 0 3
 854: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 855: LD_ADDR_EXP 23
 859: PUSH
 860: LD_STRING Donaldson
 862: PPUSH
 863: LD_EXP 1
 867: NOT
 868: PPUSH
 869: LD_EXP 4
 873: PPUSH
 874: CALL 48555 0 3
 878: ST_TO_ADDR
// if not Donaldson then
 879: LD_EXP 23
 883: NOT
 884: IFFALSE 899
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 886: LD_ADDR_EXP 23
 890: PUSH
 891: LD_STRING 10_Donaldson
 893: PPUSH
 894: CALL_OW 34
 898: ST_TO_ADDR
// if not Donaldson then
 899: LD_EXP 23
 903: NOT
 904: IFFALSE 919
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 906: LD_ADDR_EXP 23
 910: PUSH
 911: LD_STRING 09_Donaldson
 913: PPUSH
 914: CALL_OW 34
 918: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 919: LD_ADDR_EXP 24
 923: PUSH
 924: LD_STRING Bobby
 926: PPUSH
 927: LD_EXP 1
 931: NOT
 932: PPUSH
 933: LD_EXP 4
 937: PPUSH
 938: CALL 48555 0 3
 942: ST_TO_ADDR
// if not Bobby then
 943: LD_EXP 24
 947: NOT
 948: IFFALSE 963
// Bobby := CreateCharacter ( 10_Bobby ) ;
 950: LD_ADDR_EXP 24
 954: PUSH
 955: LD_STRING 10_Bobby
 957: PPUSH
 958: CALL_OW 34
 962: ST_TO_ADDR
// if not Bobby then
 963: LD_EXP 24
 967: NOT
 968: IFFALSE 983
// Bobby := CreateCharacter ( 09_Bobby ) ;
 970: LD_ADDR_EXP 24
 974: PUSH
 975: LD_STRING 09_Bobby
 977: PPUSH
 978: CALL_OW 34
 982: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 983: LD_ADDR_EXP 25
 987: PUSH
 988: LD_STRING Cyrus
 990: PPUSH
 991: LD_EXP 1
 995: NOT
 996: PPUSH
 997: LD_EXP 4
1001: PPUSH
1002: CALL 48555 0 3
1006: ST_TO_ADDR
// if not Cyrus then
1007: LD_EXP 25
1011: NOT
1012: IFFALSE 1027
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1014: LD_ADDR_EXP 25
1018: PUSH
1019: LD_STRING 10_Cyrus
1021: PPUSH
1022: CALL_OW 34
1026: ST_TO_ADDR
// if not Cyrus then
1027: LD_EXP 25
1031: NOT
1032: IFFALSE 1047
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1034: LD_ADDR_EXP 25
1038: PUSH
1039: LD_STRING 09_Cyrus
1041: PPUSH
1042: CALL_OW 34
1046: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1047: LD_ADDR_EXP 26
1051: PUSH
1052: LD_STRING Denis
1054: PPUSH
1055: LD_EXP 1
1059: NOT
1060: PPUSH
1061: LD_EXP 4
1065: PPUSH
1066: CALL 48555 0 3
1070: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1071: LD_ADDR_EXP 27
1075: PUSH
1076: LD_STRING Brown
1078: PPUSH
1079: LD_EXP 1
1083: NOT
1084: PPUSH
1085: LD_EXP 4
1089: PPUSH
1090: CALL 48555 0 3
1094: ST_TO_ADDR
// if not Brown then
1095: LD_EXP 27
1099: NOT
1100: IFFALSE 1115
// Brown := CreateCharacter ( 10_Brown ) ;
1102: LD_ADDR_EXP 27
1106: PUSH
1107: LD_STRING 10_Brown
1109: PPUSH
1110: CALL_OW 34
1114: ST_TO_ADDR
// if not Brown then
1115: LD_EXP 27
1119: NOT
1120: IFFALSE 1135
// Brown := CreateCharacter ( 08_Brown ) ;
1122: LD_ADDR_EXP 27
1126: PUSH
1127: LD_STRING 08_Brown
1129: PPUSH
1130: CALL_OW 34
1134: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1135: LD_ADDR_EXP 28
1139: PUSH
1140: LD_STRING Gladstone
1142: PPUSH
1143: LD_EXP 1
1147: NOT
1148: PPUSH
1149: LD_EXP 4
1153: PPUSH
1154: CALL 48555 0 3
1158: ST_TO_ADDR
// if not Gladstone then
1159: LD_EXP 28
1163: NOT
1164: IFFALSE 1179
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1166: LD_ADDR_EXP 28
1170: PUSH
1171: LD_STRING 10_Gladstone
1173: PPUSH
1174: CALL_OW 34
1178: ST_TO_ADDR
// if not Gladstone then
1179: LD_EXP 28
1183: NOT
1184: IFFALSE 1199
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1186: LD_ADDR_EXP 28
1190: PUSH
1191: LD_STRING 08_Gladstone
1193: PPUSH
1194: CALL_OW 34
1198: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1199: LD_ADDR_EXP 29
1203: PUSH
1204: LD_STRING Houten
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_EXP 4
1217: PPUSH
1218: CALL 48555 0 3
1222: ST_TO_ADDR
// if not Houten then
1223: LD_EXP 29
1227: NOT
1228: IFFALSE 1243
// Houten := CreateCharacter ( 10_Houten ) ;
1230: LD_ADDR_EXP 29
1234: PUSH
1235: LD_STRING 10_Houten
1237: PPUSH
1238: CALL_OW 34
1242: ST_TO_ADDR
// if not Houten then
1243: LD_EXP 29
1247: NOT
1248: IFFALSE 1263
// Houten := CreateCharacter ( 09_Houten ) ;
1250: LD_ADDR_EXP 29
1254: PUSH
1255: LD_STRING 09_Houten
1257: PPUSH
1258: CALL_OW 34
1262: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1263: LD_ADDR_EXP 31
1267: PUSH
1268: LD_STRING Cornell
1270: PPUSH
1271: LD_EXP 1
1275: NOT
1276: PPUSH
1277: LD_EXP 4
1281: PPUSH
1282: CALL 48555 0 3
1286: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1287: LD_ADDR_EXP 32
1291: PUSH
1292: LD_STRING Gary
1294: PPUSH
1295: LD_EXP 1
1299: NOT
1300: PPUSH
1301: LD_EXP 4
1305: PPUSH
1306: CALL 48555 0 3
1310: ST_TO_ADDR
// if not Gary then
1311: LD_EXP 32
1315: NOT
1316: IFFALSE 1331
// Gary := CreateCharacter ( 10_Gary ) ;
1318: LD_ADDR_EXP 32
1322: PUSH
1323: LD_STRING 10_Gary
1325: PPUSH
1326: CALL_OW 34
1330: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1331: LD_ADDR_EXP 33
1335: PUSH
1336: LD_STRING Frank
1338: PPUSH
1339: LD_EXP 1
1343: NOT
1344: PPUSH
1345: LD_EXP 4
1349: PPUSH
1350: CALL 48555 0 3
1354: ST_TO_ADDR
// if not Frank then
1355: LD_EXP 33
1359: NOT
1360: IFFALSE 1375
// Frank := CreateCharacter ( 08_Frank ) ;
1362: LD_ADDR_EXP 33
1366: PUSH
1367: LD_STRING 08_Frank
1369: PPUSH
1370: CALL_OW 34
1374: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1375: LD_ADDR_EXP 34
1379: PUSH
1380: LD_STRING Kikuchi
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_EXP 4
1393: PPUSH
1394: CALL 48555 0 3
1398: ST_TO_ADDR
// if not Kikuchi then
1399: LD_EXP 34
1403: NOT
1404: IFFALSE 1419
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1406: LD_ADDR_EXP 34
1410: PUSH
1411: LD_STRING 08_Kikuchi
1413: PPUSH
1414: CALL_OW 34
1418: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1419: LD_ADDR_VAR 0 5
1423: PUSH
1424: LD_EXP 22
1428: PUSH
1429: LD_EXP 23
1433: PUSH
1434: LD_EXP 24
1438: PUSH
1439: LD_EXP 25
1443: PUSH
1444: LD_EXP 26
1448: PUSH
1449: LD_EXP 27
1453: PUSH
1454: LD_EXP 28
1458: PUSH
1459: LD_EXP 29
1463: PUSH
1464: LD_EXP 31
1468: PUSH
1469: LD_EXP 32
1473: PUSH
1474: LD_EXP 33
1478: PUSH
1479: LD_EXP 34
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: ST_TO_ADDR
// tmp := tmp diff 0 ;
1498: LD_ADDR_VAR 0 5
1502: PUSH
1503: LD_VAR 0 5
1507: PUSH
1508: LD_INT 0
1510: DIFF
1511: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1512: LD_ADDR_VAR 0 5
1516: PUSH
1517: LD_VAR 0 5
1521: PUSH
1522: LD_STRING 10_lock
1524: PPUSH
1525: CALL_OW 31
1529: UNION
1530: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1531: LD_ADDR_VAR 0 5
1535: PUSH
1536: LD_VAR 0 5
1540: PUSH
1541: LD_STRING 10c_lock
1543: PPUSH
1544: CALL_OW 31
1548: UNION
1549: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1550: LD_STRING 10_lock
1552: PPUSH
1553: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1557: LD_STRING 10c_lock
1559: PPUSH
1560: CALL_OW 40
// for i in tmp do
1564: LD_ADDR_VAR 0 2
1568: PUSH
1569: LD_VAR 0 5
1573: PUSH
1574: FOR_IN
1575: IFFALSE 1613
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1577: LD_VAR 0 2
1581: PPUSH
1582: CALL_OW 257
1586: PUSH
1587: LD_INT 8
1589: PUSH
1590: LD_INT 2
1592: PUSH
1593: EMPTY
1594: LIST
1595: LIST
1596: IN
1597: IFFALSE 1611
// SetClass ( i , class_soldier ) ;
1599: LD_VAR 0 2
1603: PPUSH
1604: LD_INT 1
1606: PPUSH
1607: CALL_OW 336
1611: GO 1574
1613: POP
1614: POP
// if tmp < 12 then
1615: LD_VAR 0 5
1619: PUSH
1620: LD_INT 12
1622: LESS
1623: IFFALSE 1717
// begin k := 16 - tmp ;
1625: LD_ADDR_VAR 0 3
1629: PUSH
1630: LD_INT 16
1632: PUSH
1633: LD_VAR 0 5
1637: MINUS
1638: ST_TO_ADDR
// for i = 1 to k do
1639: LD_ADDR_VAR 0 2
1643: PUSH
1644: DOUBLE
1645: LD_INT 1
1647: DEC
1648: ST_TO_ADDR
1649: LD_VAR 0 3
1653: PUSH
1654: FOR_TO
1655: IFFALSE 1715
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1657: LD_INT 0
1659: PPUSH
1660: LD_INT 1
1662: PUSH
1663: LD_INT 1
1665: PUSH
1666: LD_INT 3
1668: PUSH
1669: LD_INT 4
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: PUSH
1678: LD_INT 1
1680: PPUSH
1681: LD_INT 4
1683: PPUSH
1684: CALL_OW 12
1688: ARRAY
1689: PPUSH
1690: LD_INT 6
1692: PPUSH
1693: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1697: LD_ADDR_VAR 0 5
1701: PUSH
1702: LD_VAR 0 5
1706: PUSH
1707: CALL_OW 44
1711: ADD
1712: ST_TO_ADDR
// end ;
1713: GO 1654
1715: POP
1716: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1717: LD_ADDR_EXP 19
1721: PUSH
1722: LD_STRING 1
1724: PPUSH
1725: LD_INT 12
1727: PPUSH
1728: LD_INT 12
1730: PPUSH
1731: LD_INT -5
1733: PUSH
1734: LD_EXP 21
1738: PUSH
1739: LD_INT -2
1741: PUSH
1742: LD_INT -3
1744: PUSH
1745: LD_INT -5
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: PUSH
1755: LD_VAR 0 5
1759: ADD
1760: PUSH
1761: LD_INT -6
1763: PUSH
1764: LD_INT -4
1766: PUSH
1767: LD_EXP 30
1771: PUSH
1772: EMPTY
1773: LIST
1774: LIST
1775: LIST
1776: ADD
1777: PPUSH
1778: LD_INT 1
1780: PUSH
1781: LD_INT 4
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: PUSH
1788: LD_INT 3
1790: PUSH
1791: LD_INT 0
1793: PUSH
1794: LD_INT 5
1796: PUSH
1797: EMPTY
1798: LIST
1799: LIST
1800: LIST
1801: PUSH
1802: LD_INT 4
1804: PUSH
1805: LD_INT 0
1807: PUSH
1808: LD_INT 3
1810: PUSH
1811: EMPTY
1812: LIST
1813: LIST
1814: LIST
1815: PUSH
1816: LD_INT 5
1818: PUSH
1819: LD_INT 0
1821: PUSH
1822: LD_INT 2
1824: PUSH
1825: EMPTY
1826: LIST
1827: LIST
1828: LIST
1829: PUSH
1830: EMPTY
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: PPUSH
1836: CALL_OW 42
1840: ST_TO_ADDR
// others := tmp diff selected ;
1841: LD_ADDR_VAR 0 8
1845: PUSH
1846: LD_VAR 0 5
1850: PUSH
1851: LD_EXP 19
1855: DIFF
1856: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1857: LD_ADDR_VAR 0 8
1861: PUSH
1862: LD_VAR 0 8
1866: PUSH
1867: LD_EXP 22
1871: PUSH
1872: LD_EXP 23
1876: PUSH
1877: LD_EXP 24
1881: PUSH
1882: LD_EXP 25
1886: PUSH
1887: LD_EXP 26
1891: PUSH
1892: LD_EXP 27
1896: PUSH
1897: LD_EXP 28
1901: PUSH
1902: LD_EXP 29
1906: PUSH
1907: LD_EXP 31
1911: PUSH
1912: LD_EXP 32
1916: PUSH
1917: LD_EXP 33
1921: PUSH
1922: LD_EXP 34
1926: PUSH
1927: EMPTY
1928: LIST
1929: LIST
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: DIFF
1941: ST_TO_ADDR
// if others then
1942: LD_VAR 0 8
1946: IFFALSE 1960
// SaveCharacters ( others , 11_others ) ;
1948: LD_VAR 0 8
1952: PPUSH
1953: LD_STRING 11_others
1955: PPUSH
1956: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1960: LD_ADDR_VAR 0 6
1964: PUSH
1965: LD_INT 3
1967: PUSH
1968: LD_INT 1
1970: PUSH
1971: LD_INT 1
1973: PUSH
1974: LD_INT 4
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: PUSH
1983: LD_INT 2
1985: PUSH
1986: LD_INT 2
1988: PUSH
1989: LD_INT 1
1991: PUSH
1992: LD_INT 5
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: PUSH
2001: LD_INT 4
2003: PUSH
2004: LD_INT 1
2006: PUSH
2007: LD_INT 1
2009: PUSH
2010: LD_INT 5
2012: PUSH
2013: EMPTY
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: PUSH
2019: LD_INT 2
2021: PUSH
2022: LD_INT 1
2024: PUSH
2025: LD_INT 1
2027: PUSH
2028: LD_INT 7
2030: PUSH
2031: EMPTY
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: PUSH
2037: LD_INT 3
2039: PUSH
2040: LD_INT 2
2042: PUSH
2043: LD_INT 1
2045: PUSH
2046: LD_INT 7
2048: PUSH
2049: EMPTY
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PUSH
2055: EMPTY
2056: LIST
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: ST_TO_ADDR
// for i in JMM ^ selected do
2062: LD_ADDR_VAR 0 2
2066: PUSH
2067: LD_EXP 21
2071: PUSH
2072: LD_EXP 19
2076: ADD
2077: PUSH
2078: FOR_IN
2079: IFFALSE 2268
// begin if GetClass ( i ) = 3 then
2081: LD_VAR 0 2
2085: PPUSH
2086: CALL_OW 257
2090: PUSH
2091: LD_INT 3
2093: EQUAL
2094: IFFALSE 2251
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2096: LD_ADDR_OWVAR 37
2100: PUSH
2101: LD_VAR 0 6
2105: PUSH
2106: LD_INT 1
2108: ARRAY
2109: PUSH
2110: LD_INT 1
2112: ARRAY
2113: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2114: LD_ADDR_OWVAR 39
2118: PUSH
2119: LD_VAR 0 6
2123: PUSH
2124: LD_INT 1
2126: ARRAY
2127: PUSH
2128: LD_INT 2
2130: ARRAY
2131: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2132: LD_ADDR_OWVAR 38
2136: PUSH
2137: LD_VAR 0 6
2141: PUSH
2142: LD_INT 1
2144: ARRAY
2145: PUSH
2146: LD_INT 3
2148: ARRAY
2149: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2150: LD_ADDR_OWVAR 40
2154: PUSH
2155: LD_VAR 0 6
2159: PUSH
2160: LD_INT 1
2162: ARRAY
2163: PUSH
2164: LD_INT 4
2166: ARRAY
2167: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2168: LD_ADDR_VAR 0 6
2172: PUSH
2173: LD_VAR 0 6
2177: PPUSH
2178: LD_INT 1
2180: PPUSH
2181: CALL_OW 3
2185: ST_TO_ADDR
// veh := CreateVehicle ;
2186: LD_ADDR_VAR 0 7
2190: PUSH
2191: CALL_OW 45
2195: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2196: LD_VAR 0 7
2200: PPUSH
2201: LD_INT 8
2203: PPUSH
2204: LD_INT 0
2206: PPUSH
2207: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2211: LD_VAR 0 2
2215: PPUSH
2216: LD_VAR 0 7
2220: PPUSH
2221: CALL_OW 52
// if i = JMM then
2225: LD_VAR 0 2
2229: PUSH
2230: LD_EXP 21
2234: EQUAL
2235: IFFALSE 2249
// SetMark ( veh , 1 ) ;
2237: LD_VAR 0 7
2241: PPUSH
2242: LD_INT 1
2244: PPUSH
2245: CALL_OW 242
// end else
2249: GO 2266
// PlaceUnitArea ( i , am_hum_start , false ) ;
2251: LD_VAR 0 2
2255: PPUSH
2256: LD_INT 9
2258: PPUSH
2259: LD_INT 0
2261: PPUSH
2262: CALL_OW 49
// end ;
2266: GO 2078
2268: POP
2269: POP
// vc_chassis := us_medium_tracked ;
2270: LD_ADDR_OWVAR 37
2274: PUSH
2275: LD_INT 3
2277: ST_TO_ADDR
// vc_engine := engine_solar ;
2278: LD_ADDR_OWVAR 39
2282: PUSH
2283: LD_INT 2
2285: ST_TO_ADDR
// vc_control := control_computer ;
2286: LD_ADDR_OWVAR 38
2290: PUSH
2291: LD_INT 3
2293: ST_TO_ADDR
// vc_weapon := us_radar ;
2294: LD_ADDR_OWVAR 40
2298: PUSH
2299: LD_INT 11
2301: ST_TO_ADDR
// veh := CreateVehicle ;
2302: LD_ADDR_VAR 0 7
2306: PUSH
2307: CALL_OW 45
2311: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2312: LD_VAR 0 7
2316: PPUSH
2317: LD_INT 87
2319: PPUSH
2320: LD_INT 142
2322: PPUSH
2323: LD_INT 0
2325: PPUSH
2326: CALL_OW 48
// end ;
2330: LD_VAR 0 1
2334: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2335: LD_INT 0
2337: PPUSH
2338: PPUSH
2339: PPUSH
2340: PPUSH
// uc_side := 1 ;
2341: LD_ADDR_OWVAR 20
2345: PUSH
2346: LD_INT 1
2348: ST_TO_ADDR
// uc_nation := 1 ;
2349: LD_ADDR_OWVAR 21
2353: PUSH
2354: LD_INT 1
2356: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2357: LD_ADDR_VAR 0 3
2361: PUSH
2362: LD_INT 3
2364: PUSH
2365: LD_INT 1
2367: PUSH
2368: LD_INT 3
2370: PUSH
2371: LD_INT 5
2373: PUSH
2374: EMPTY
2375: LIST
2376: LIST
2377: LIST
2378: LIST
2379: PUSH
2380: LD_INT 3
2382: PUSH
2383: LD_INT 1
2385: PUSH
2386: LD_INT 3
2388: PUSH
2389: LD_INT 7
2391: PUSH
2392: EMPTY
2393: LIST
2394: LIST
2395: LIST
2396: LIST
2397: PUSH
2398: LD_INT 3
2400: PUSH
2401: LD_INT 1
2403: PUSH
2404: LD_INT 3
2406: PUSH
2407: LD_INT 7
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 1
2421: PUSH
2422: LD_INT 3
2424: PUSH
2425: LD_INT 11
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: PUSH
2434: LD_INT 4
2436: PUSH
2437: LD_INT 1
2439: PUSH
2440: LD_INT 3
2442: PUSH
2443: LD_INT 6
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: LIST
2450: LIST
2451: PUSH
2452: LD_INT 4
2454: PUSH
2455: LD_INT 1
2457: PUSH
2458: LD_INT 3
2460: PUSH
2461: LD_INT 5
2463: PUSH
2464: EMPTY
2465: LIST
2466: LIST
2467: LIST
2468: LIST
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: LIST
2477: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2478: LD_ADDR_VAR 0 2
2482: PUSH
2483: DOUBLE
2484: LD_INT 1
2486: DEC
2487: ST_TO_ADDR
2488: LD_INT 7
2490: PUSH
2491: LD_OWVAR 67
2495: MINUS
2496: PUSH
2497: FOR_TO
2498: IFFALSE 2607
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2500: LD_ADDR_OWVAR 37
2504: PUSH
2505: LD_VAR 0 3
2509: PUSH
2510: LD_VAR 0 2
2514: ARRAY
2515: PUSH
2516: LD_INT 1
2518: ARRAY
2519: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2520: LD_ADDR_OWVAR 39
2524: PUSH
2525: LD_VAR 0 3
2529: PUSH
2530: LD_VAR 0 2
2534: ARRAY
2535: PUSH
2536: LD_INT 2
2538: ARRAY
2539: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2540: LD_ADDR_OWVAR 38
2544: PUSH
2545: LD_VAR 0 3
2549: PUSH
2550: LD_VAR 0 2
2554: ARRAY
2555: PUSH
2556: LD_INT 3
2558: ARRAY
2559: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2560: LD_ADDR_OWVAR 40
2564: PUSH
2565: LD_VAR 0 3
2569: PUSH
2570: LD_VAR 0 2
2574: ARRAY
2575: PUSH
2576: LD_INT 4
2578: ARRAY
2579: ST_TO_ADDR
// veh := CreateVehicle ;
2580: LD_ADDR_VAR 0 4
2584: PUSH
2585: CALL_OW 45
2589: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2590: LD_VAR 0 4
2594: PPUSH
2595: LD_INT 8
2597: PPUSH
2598: LD_INT 0
2600: PPUSH
2601: CALL_OW 49
// end ;
2605: GO 2497
2607: POP
2608: POP
// end ; end_of_file
2609: LD_VAR 0 1
2613: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2614: LD_INT 0
2616: PPUSH
2617: PPUSH
2618: PPUSH
2619: PPUSH
2620: PPUSH
2621: PPUSH
// if Difficulty = 1 then
2622: LD_OWVAR 67
2626: PUSH
2627: LD_INT 1
2629: EQUAL
2630: IFFALSE 2727
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2632: LD_ADDR_VAR 0 6
2636: PUSH
2637: LD_INT 129
2639: PUSH
2640: LD_INT 45
2642: PUSH
2643: EMPTY
2644: LIST
2645: LIST
2646: PUSH
2647: LD_INT 143
2649: PUSH
2650: LD_INT 58
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 184
2659: PUSH
2660: LD_INT 113
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PUSH
2667: LD_INT 163
2669: PUSH
2670: LD_INT 107
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PUSH
2677: EMPTY
2678: LIST
2679: LIST
2680: LIST
2681: LIST
2682: ST_TO_ADDR
// for i in tmp do
2683: LD_ADDR_VAR 0 2
2687: PUSH
2688: LD_VAR 0 6
2692: PUSH
2693: FOR_IN
2694: IFFALSE 2725
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2696: LD_VAR 0 2
2700: PUSH
2701: LD_INT 1
2703: ARRAY
2704: PPUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_INT 2
2712: ARRAY
2713: PPUSH
2714: CALL_OW 428
2718: PPUSH
2719: CALL_OW 64
2723: GO 2693
2725: POP
2726: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2727: LD_ADDR_VAR 0 2
2731: PUSH
2732: LD_INT 21
2734: PUSH
2735: LD_INT 3
2737: PUSH
2738: EMPTY
2739: LIST
2740: LIST
2741: PPUSH
2742: CALL_OW 69
2746: PUSH
2747: FOR_IN
2748: IFFALSE 2785
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2750: LD_VAR 0 2
2754: PPUSH
2755: LD_INT 5
2757: PUSH
2758: LD_INT 6
2760: PUSH
2761: LD_INT 7
2763: PUSH
2764: LD_INT 8
2766: PUSH
2767: EMPTY
2768: LIST
2769: LIST
2770: LIST
2771: LIST
2772: PUSH
2773: LD_OWVAR 67
2777: ARRAY
2778: PPUSH
2779: CALL_OW 241
2783: GO 2747
2785: POP
2786: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2787: LD_ADDR_VAR 0 5
2791: PUSH
2792: LD_INT 5
2794: PUSH
2795: LD_INT 6
2797: PUSH
2798: LD_INT 7
2800: PUSH
2801: LD_INT 8
2803: PUSH
2804: EMPTY
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: PUSH
2810: LD_OWVAR 67
2814: ARRAY
2815: ST_TO_ADDR
// uc_side := 2 ;
2816: LD_ADDR_OWVAR 20
2820: PUSH
2821: LD_INT 2
2823: ST_TO_ADDR
// uc_nation := 2 ;
2824: LD_ADDR_OWVAR 21
2828: PUSH
2829: LD_INT 2
2831: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2832: LD_ADDR_OWVAR 37
2836: PUSH
2837: LD_INT 14
2839: ST_TO_ADDR
// vc_engine := engine_siberite ;
2840: LD_ADDR_OWVAR 39
2844: PUSH
2845: LD_INT 3
2847: ST_TO_ADDR
// vc_control := control_manual ;
2848: LD_ADDR_OWVAR 38
2852: PUSH
2853: LD_INT 1
2855: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2856: LD_ADDR_OWVAR 40
2860: PUSH
2861: LD_INT 31
2863: ST_TO_ADDR
// for i = 1 to 3 do
2864: LD_ADDR_VAR 0 2
2868: PUSH
2869: DOUBLE
2870: LD_INT 1
2872: DEC
2873: ST_TO_ADDR
2874: LD_INT 3
2876: PUSH
2877: FOR_TO
2878: IFFALSE 2962
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2880: LD_INT 0
2882: PPUSH
2883: LD_INT 3
2885: PPUSH
2886: LD_VAR 0 5
2890: PPUSH
2891: CALL_OW 380
// un := CreateVehicle ;
2895: LD_ADDR_VAR 0 4
2899: PUSH
2900: CALL_OW 45
2904: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2905: LD_VAR 0 4
2909: PPUSH
2910: LD_INT 0
2912: PPUSH
2913: LD_INT 5
2915: PPUSH
2916: CALL_OW 12
2920: PPUSH
2921: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2925: LD_VAR 0 4
2929: PPUSH
2930: LD_INT 156
2932: PPUSH
2933: LD_INT 15
2935: PPUSH
2936: LD_INT 6
2938: PPUSH
2939: LD_INT 0
2941: PPUSH
2942: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2946: CALL_OW 44
2950: PPUSH
2951: LD_VAR 0 4
2955: PPUSH
2956: CALL_OW 52
// end ;
2960: GO 2877
2962: POP
2963: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2964: LD_ADDR_EXP 37
2968: PUSH
2969: LD_INT 94
2971: PPUSH
2972: LD_INT 28
2974: PPUSH
2975: LD_STRING dammam
2977: PPUSH
2978: LD_VAR 0 5
2982: PPUSH
2983: LD_INT 10000
2985: PUSH
2986: LD_INT 1000
2988: PUSH
2989: LD_INT 300
2991: PUSH
2992: EMPTY
2993: LIST
2994: LIST
2995: LIST
2996: PPUSH
2997: LD_INT 12
2999: PUSH
3000: LD_INT 2
3002: PUSH
3003: LD_INT 3
3005: PUSH
3006: LD_INT 4
3008: PUSH
3009: LD_INT 4
3011: PUSH
3012: EMPTY
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: PUSH
3018: LD_OWVAR 67
3022: ARRAY
3023: PUSH
3024: LD_INT 1
3026: NEG
3027: PUSH
3028: LD_INT 4
3030: PUSH
3031: EMPTY
3032: LIST
3033: LIST
3034: LIST
3035: LIST
3036: PPUSH
3037: CALL 56865 0 6
3041: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3042: LD_ADDR_EXP 37
3046: PUSH
3047: LD_EXP 37
3051: PUSH
3052: LD_INT 122
3054: PPUSH
3055: LD_INT 25
3057: PPUSH
3058: LD_STRING 
3060: PPUSH
3061: LD_VAR 0 5
3065: PPUSH
3066: LD_INT 500
3068: PUSH
3069: LD_INT 60
3071: PUSH
3072: LD_INT 0
3074: PUSH
3075: EMPTY
3076: LIST
3077: LIST
3078: LIST
3079: PPUSH
3080: LD_INT 8
3082: PUSH
3083: LD_INT 2
3085: PUSH
3086: LD_INT 3
3088: PUSH
3089: LD_INT 4
3091: PUSH
3092: LD_INT 5
3094: PUSH
3095: EMPTY
3096: LIST
3097: LIST
3098: LIST
3099: LIST
3100: PUSH
3101: LD_OWVAR 67
3105: ARRAY
3106: PUSH
3107: LD_INT 2
3109: PUSH
3110: LD_INT 0
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: LIST
3117: LIST
3118: PPUSH
3119: CALL 56865 0 6
3123: UNION
3124: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3125: LD_ADDR_EXP 35
3129: PUSH
3130: LD_INT 45
3132: PPUSH
3133: LD_INT 24
3135: PPUSH
3136: LD_STRING jeddah
3138: PPUSH
3139: LD_VAR 0 5
3143: PPUSH
3144: LD_INT 700
3146: PUSH
3147: LD_INT 300
3149: PUSH
3150: LD_INT 10
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: LIST
3157: PPUSH
3158: LD_INT 9
3160: PUSH
3161: LD_INT 4
3163: PUSH
3164: LD_INT 3
3166: PUSH
3167: LD_INT 2
3169: PUSH
3170: EMPTY
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: PPUSH
3176: CALL 56865 0 6
3180: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3181: LD_ADDR_EXP 36
3185: PUSH
3186: LD_INT 7
3188: PPUSH
3189: LD_INT 27
3191: PPUSH
3192: LD_STRING riyadh
3194: PPUSH
3195: LD_VAR 0 5
3199: PPUSH
3200: LD_INT 500
3202: PUSH
3203: LD_INT 60
3205: PUSH
3206: LD_INT 0
3208: PUSH
3209: EMPTY
3210: LIST
3211: LIST
3212: LIST
3213: PPUSH
3214: LD_INT 4
3216: PUSH
3217: LD_INT 2
3219: PUSH
3220: LD_INT 3
3222: PUSH
3223: LD_INT 1
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: PPUSH
3232: CALL 56865 0 6
3236: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3237: LD_ADDR_EXP 39
3241: PUSH
3242: LD_INT 204
3244: PPUSH
3245: LD_INT 26
3247: PPUSH
3248: LD_STRING 
3250: PPUSH
3251: LD_VAR 0 5
3255: PPUSH
3256: LD_INT 500
3258: PUSH
3259: LD_INT 50
3261: PUSH
3262: LD_INT 0
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: LIST
3269: PPUSH
3270: LD_INT 9
3272: PUSH
3273: LD_INT 2
3275: PUSH
3276: LD_INT 3
3278: PUSH
3279: LD_INT 1
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: PPUSH
3288: CALL 56865 0 6
3292: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3293: LD_ADDR_EXP 50
3297: PUSH
3298: LD_EXP 37
3302: PUSH
3303: LD_EXP 35
3307: PUSH
3308: LD_EXP 39
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: LIST
3317: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3318: LD_ADDR_VAR 0 2
3322: PUSH
3323: LD_INT 22
3325: PUSH
3326: LD_INT 2
3328: PUSH
3329: EMPTY
3330: LIST
3331: LIST
3332: PUSH
3333: LD_INT 30
3335: PUSH
3336: LD_INT 31
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 58
3345: PUSH
3346: EMPTY
3347: LIST
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: PPUSH
3354: CALL_OW 69
3358: PUSH
3359: FOR_IN
3360: IFFALSE 3485
// begin if GetBase ( i ) then
3362: LD_VAR 0 2
3366: PPUSH
3367: CALL_OW 274
3371: IFFALSE 3375
// continue ;
3373: GO 3359
// d := GetDir ( i ) ;
3375: LD_ADDR_VAR 0 3
3379: PUSH
3380: LD_VAR 0 2
3384: PPUSH
3385: CALL_OW 254
3389: ST_TO_ADDR
// if d < 3 then
3390: LD_VAR 0 3
3394: PUSH
3395: LD_INT 3
3397: LESS
3398: IFFALSE 3416
// d := d + 3 else
3400: LD_ADDR_VAR 0 3
3404: PUSH
3405: LD_VAR 0 3
3409: PUSH
3410: LD_INT 3
3412: PLUS
3413: ST_TO_ADDR
3414: GO 3430
// d := d - 3 ;
3416: LD_ADDR_VAR 0 3
3420: PUSH
3421: LD_VAR 0 3
3425: PUSH
3426: LD_INT 3
3428: MINUS
3429: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3430: LD_INT 0
3432: PPUSH
3433: LD_INT 8
3435: PPUSH
3436: LD_VAR 0 5
3440: PPUSH
3441: CALL_OW 380
// un := CreateHuman ;
3445: LD_ADDR_VAR 0 4
3449: PUSH
3450: CALL_OW 44
3454: ST_TO_ADDR
// SetDir ( un , d ) ;
3455: LD_VAR 0 4
3459: PPUSH
3460: LD_VAR 0 3
3464: PPUSH
3465: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3469: LD_VAR 0 4
3473: PPUSH
3474: LD_VAR 0 2
3478: PPUSH
3479: CALL_OW 52
// end ;
3483: GO 3359
3485: POP
3486: POP
// if Difficulty > 1 then
3487: LD_OWVAR 67
3491: PUSH
3492: LD_INT 1
3494: GREATER
3495: IFFALSE 3866
// begin ar_kamikadze := [ ] ;
3497: LD_ADDR_EXP 42
3501: PUSH
3502: EMPTY
3503: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3504: LD_INT 0
3506: PPUSH
3507: LD_INT 1
3509: PPUSH
3510: LD_VAR 0 5
3514: PPUSH
3515: CALL_OW 380
// un := CreateHuman ;
3519: LD_ADDR_VAR 0 4
3523: PUSH
3524: CALL_OW 44
3528: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3529: LD_VAR 0 4
3533: PPUSH
3534: LD_INT 3
3536: PPUSH
3537: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3541: LD_VAR 0 4
3545: PPUSH
3546: LD_INT 23
3548: PPUSH
3549: LD_INT 44
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// ComCrawl ( un ) ;
3559: LD_VAR 0 4
3563: PPUSH
3564: CALL_OW 137
// un := CreateHuman ;
3568: LD_ADDR_VAR 0 4
3572: PUSH
3573: CALL_OW 44
3577: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3578: LD_VAR 0 4
3582: PPUSH
3583: LD_INT 3
3585: PPUSH
3586: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3590: LD_VAR 0 4
3594: PPUSH
3595: LD_INT 30
3597: PPUSH
3598: LD_INT 39
3600: PPUSH
3601: LD_INT 0
3603: PPUSH
3604: CALL_OW 48
// ComCrawl ( un ) ;
3608: LD_VAR 0 4
3612: PPUSH
3613: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3617: LD_INT 0
3619: PPUSH
3620: LD_INT 17
3622: PPUSH
3623: LD_VAR 0 5
3627: PPUSH
3628: CALL_OW 380
// un := CreateHuman ;
3632: LD_ADDR_VAR 0 4
3636: PUSH
3637: CALL_OW 44
3641: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3642: LD_VAR 0 4
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3654: LD_VAR 0 4
3658: PPUSH
3659: LD_INT 45
3661: PPUSH
3662: LD_INT 86
3664: PPUSH
3665: LD_INT 0
3667: PPUSH
3668: CALL_OW 48
// ComHold ( un ) ;
3672: LD_VAR 0 4
3676: PPUSH
3677: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3681: LD_ADDR_EXP 42
3685: PUSH
3686: LD_EXP 42
3690: PPUSH
3691: LD_EXP 42
3695: PUSH
3696: LD_INT 1
3698: PLUS
3699: PPUSH
3700: LD_VAR 0 4
3704: PPUSH
3705: CALL_OW 1
3709: ST_TO_ADDR
// un := CreateHuman ;
3710: LD_ADDR_VAR 0 4
3714: PUSH
3715: CALL_OW 44
3719: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3720: LD_VAR 0 4
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3732: LD_VAR 0 4
3736: PPUSH
3737: LD_INT 60
3739: PPUSH
3740: LD_INT 85
3742: PPUSH
3743: LD_INT 0
3745: PPUSH
3746: CALL_OW 48
// ComHold ( un ) ;
3750: LD_VAR 0 4
3754: PPUSH
3755: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3759: LD_ADDR_EXP 42
3763: PUSH
3764: LD_EXP 42
3768: PPUSH
3769: LD_EXP 42
3773: PUSH
3774: LD_INT 1
3776: PLUS
3777: PPUSH
3778: LD_VAR 0 4
3782: PPUSH
3783: CALL_OW 1
3787: ST_TO_ADDR
// un := CreateHuman ;
3788: LD_ADDR_VAR 0 4
3792: PUSH
3793: CALL_OW 44
3797: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3798: LD_VAR 0 4
3802: PPUSH
3803: LD_INT 3
3805: PPUSH
3806: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3810: LD_VAR 0 4
3814: PPUSH
3815: LD_INT 222
3817: PPUSH
3818: LD_INT 166
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 48
// ComHold ( un ) ;
3828: LD_VAR 0 4
3832: PPUSH
3833: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3837: LD_ADDR_EXP 42
3841: PUSH
3842: LD_EXP 42
3846: PPUSH
3847: LD_EXP 42
3851: PUSH
3852: LD_INT 1
3854: PLUS
3855: PPUSH
3856: LD_VAR 0 4
3860: PPUSH
3861: CALL_OW 1
3865: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3866: LD_ADDR_EXP 40
3870: PUSH
3871: EMPTY
3872: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3873: LD_INT 1
3875: PPUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_VAR 0 5
3883: PPUSH
3884: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3888: LD_ADDR_OWVAR 26
3892: PUSH
3893: LD_STRING Pavel Grigorovic
3895: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3896: LD_ADDR_OWVAR 33
3900: PUSH
3901: LD_STRING SecondCharsGal
3903: ST_TO_ADDR
// hc_face_number := 4 ;
3904: LD_ADDR_OWVAR 34
3908: PUSH
3909: LD_INT 4
3911: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3912: LD_ADDR_EXP 40
3916: PUSH
3917: LD_EXP 40
3921: PPUSH
3922: LD_INT 1
3924: PPUSH
3925: CALL_OW 44
3929: PPUSH
3930: CALL_OW 1
3934: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3935: LD_INT 2
3937: PPUSH
3938: LD_INT 4
3940: PPUSH
3941: LD_INT 2
3943: PPUSH
3944: CALL_OW 380
// hc_name := Lucy Sebel ;
3948: LD_ADDR_OWVAR 26
3952: PUSH
3953: LD_STRING Lucy Sebel
3955: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3956: LD_ADDR_OWVAR 33
3960: PUSH
3961: LD_STRING SecondCharsGal
3963: ST_TO_ADDR
// hc_face_number := 15 ;
3964: LD_ADDR_OWVAR 34
3968: PUSH
3969: LD_INT 15
3971: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3972: LD_ADDR_EXP 40
3976: PUSH
3977: LD_EXP 40
3981: PPUSH
3982: LD_INT 2
3984: PPUSH
3985: CALL_OW 44
3989: PPUSH
3990: CALL_OW 1
3994: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3995: LD_INT 2
3997: PPUSH
3998: LD_INT 4
4000: PPUSH
4001: LD_INT 2
4003: PPUSH
4004: CALL_OW 380
// hc_gallery :=  ;
4008: LD_ADDR_OWVAR 33
4012: PUSH
4013: LD_STRING 
4015: ST_TO_ADDR
// hc_name :=  ;
4016: LD_ADDR_OWVAR 26
4020: PUSH
4021: LD_STRING 
4023: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4024: LD_ADDR_EXP 40
4028: PUSH
4029: LD_EXP 40
4033: PPUSH
4034: LD_INT 3
4036: PPUSH
4037: CALL_OW 44
4041: PPUSH
4042: CALL_OW 1
4046: ST_TO_ADDR
// hc_sex := sex_male ;
4047: LD_ADDR_OWVAR 27
4051: PUSH
4052: LD_INT 1
4054: ST_TO_ADDR
// hc_class = 11 ;
4055: LD_ADDR_OWVAR 28
4059: PUSH
4060: LD_INT 11
4062: ST_TO_ADDR
// hc_gallery = sandar ;
4063: LD_ADDR_OWVAR 33
4067: PUSH
4068: LD_STRING sandar
4070: ST_TO_ADDR
// hc_face_number = 33 ;
4071: LD_ADDR_OWVAR 34
4075: PUSH
4076: LD_INT 33
4078: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4079: LD_ADDR_OWVAR 26
4083: PUSH
4084: LD_STRING Thabit Muhair Saliba
4086: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4087: LD_ADDR_OWVAR 31
4091: PUSH
4092: LD_INT 0
4094: PUSH
4095: LD_INT 0
4097: PUSH
4098: LD_INT 0
4100: PUSH
4101: LD_INT 0
4103: PUSH
4104: EMPTY
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: ST_TO_ADDR
// Saliba = CreateHuman ;
4110: LD_ADDR_EXP 44
4114: PUSH
4115: CALL_OW 44
4119: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4120: LD_EXP 44
4124: PPUSH
4125: LD_INT 7
4127: PPUSH
4128: CALL_OW 52
// if gensher_active then
4132: LD_EXP 18
4136: IFFALSE 4163
// begin Gensher = NewCharacter ( Dietrich ) ;
4138: LD_ADDR_EXP 45
4142: PUSH
4143: LD_STRING Dietrich
4145: PPUSH
4146: CALL_OW 25
4150: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4151: LD_EXP 45
4155: PPUSH
4156: LD_INT 94
4158: PPUSH
4159: CALL_OW 52
// end ; InitHc ;
4163: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4167: LD_ADDR_EXP 41
4171: PUSH
4172: EMPTY
4173: ST_TO_ADDR
// for i = 1 to 5 do
4174: LD_ADDR_VAR 0 2
4178: PUSH
4179: DOUBLE
4180: LD_INT 1
4182: DEC
4183: ST_TO_ADDR
4184: LD_INT 5
4186: PUSH
4187: FOR_TO
4188: IFFALSE 4360
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4190: LD_INT 13
4192: PUSH
4193: LD_INT 14
4195: PUSH
4196: EMPTY
4197: LIST
4198: LIST
4199: PUSH
4200: LD_INT 1
4202: PPUSH
4203: LD_INT 2
4205: PPUSH
4206: CALL_OW 12
4210: ARRAY
4211: PPUSH
4212: LD_INT 1
4214: PUSH
4215: LD_INT 2
4217: PUSH
4218: EMPTY
4219: LIST
4220: LIST
4221: PUSH
4222: LD_INT 1
4224: PPUSH
4225: LD_INT 2
4227: PPUSH
4228: CALL_OW 12
4232: ARRAY
4233: PPUSH
4234: LD_INT 1
4236: PPUSH
4237: LD_INT 25
4239: PUSH
4240: LD_INT 27
4242: PUSH
4243: LD_INT 26
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: LIST
4250: PUSH
4251: LD_INT 1
4253: PPUSH
4254: LD_INT 3
4256: PPUSH
4257: CALL_OW 12
4261: ARRAY
4262: PPUSH
4263: LD_INT 60
4265: PPUSH
4266: LD_INT 100
4268: PPUSH
4269: CALL_OW 12
4273: PPUSH
4274: CALL 53419 0 5
// un := CreateVehicle ;
4278: LD_ADDR_VAR 0 4
4282: PUSH
4283: CALL_OW 45
4287: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4288: LD_ADDR_EXP 41
4292: PUSH
4293: LD_EXP 41
4297: PPUSH
4298: LD_EXP 41
4302: PUSH
4303: LD_INT 1
4305: PLUS
4306: PPUSH
4307: LD_VAR 0 4
4311: PPUSH
4312: CALL_OW 1
4316: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4317: LD_VAR 0 4
4321: PPUSH
4322: LD_INT 0
4324: PPUSH
4325: LD_INT 5
4327: PPUSH
4328: CALL_OW 12
4332: PPUSH
4333: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4337: LD_VAR 0 4
4341: PPUSH
4342: LD_INT 124
4344: PPUSH
4345: LD_INT 141
4347: PPUSH
4348: LD_INT 8
4350: PPUSH
4351: LD_INT 0
4353: PPUSH
4354: CALL_OW 50
// end ;
4358: GO 4187
4360: POP
4361: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4362: LD_ADDR_EXP 43
4366: PUSH
4367: EMPTY
4368: PUSH
4369: EMPTY
4370: PUSH
4371: EMPTY
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: LIST
4377: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4378: LD_ADDR_VAR 0 3
4382: PUSH
4383: DOUBLE
4384: LD_INT 1
4386: DEC
4387: ST_TO_ADDR
4388: LD_INT 3
4390: PUSH
4391: LD_INT 3
4393: PUSH
4394: LD_INT 4
4396: PUSH
4397: LD_INT 4
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: LIST
4404: LIST
4405: PUSH
4406: LD_OWVAR 67
4410: ARRAY
4411: PUSH
4412: FOR_TO
4413: IFFALSE 4627
// for i = 1 to 3 do
4415: LD_ADDR_VAR 0 2
4419: PUSH
4420: DOUBLE
4421: LD_INT 1
4423: DEC
4424: ST_TO_ADDR
4425: LD_INT 3
4427: PUSH
4428: FOR_TO
4429: IFFALSE 4623
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4431: LD_INT 14
4433: PPUSH
4434: LD_INT 3
4436: PUSH
4437: LD_INT 2
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: PUSH
4444: LD_INT 1
4446: PPUSH
4447: LD_INT 2
4449: PPUSH
4450: CALL_OW 12
4454: ARRAY
4455: PPUSH
4456: LD_INT 1
4458: PUSH
4459: LD_INT 5
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 1
4468: PPUSH
4469: LD_INT 2
4471: PPUSH
4472: CALL_OW 12
4476: ARRAY
4477: PPUSH
4478: LD_INT 25
4480: PUSH
4481: LD_INT 27
4483: PUSH
4484: LD_INT 26
4486: PUSH
4487: LD_INT 28
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: PUSH
4496: LD_INT 1
4498: PPUSH
4499: LD_INT 4
4501: PPUSH
4502: CALL_OW 12
4506: ARRAY
4507: PPUSH
4508: LD_INT 100
4510: PPUSH
4511: CALL 53419 0 5
// un := CreateVehicle ;
4515: LD_ADDR_VAR 0 4
4519: PUSH
4520: CALL_OW 45
4524: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4525: LD_ADDR_EXP 43
4529: PUSH
4530: LD_EXP 43
4534: PPUSH
4535: LD_VAR 0 2
4539: PUSH
4540: LD_EXP 43
4544: PUSH
4545: LD_VAR 0 2
4549: ARRAY
4550: PUSH
4551: LD_INT 1
4553: PLUS
4554: PUSH
4555: EMPTY
4556: LIST
4557: LIST
4558: PPUSH
4559: LD_VAR 0 4
4563: PPUSH
4564: CALL 53541 0 3
4568: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4569: LD_VAR 0 4
4573: PPUSH
4574: LD_INT 0
4576: PPUSH
4577: LD_INT 5
4579: PPUSH
4580: CALL_OW 12
4584: PPUSH
4585: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4589: LD_VAR 0 4
4593: PPUSH
4594: LD_INT 20
4596: PUSH
4597: LD_INT 21
4599: PUSH
4600: LD_INT 22
4602: PUSH
4603: EMPTY
4604: LIST
4605: LIST
4606: LIST
4607: PUSH
4608: LD_VAR 0 2
4612: ARRAY
4613: PPUSH
4614: LD_INT 0
4616: PPUSH
4617: CALL_OW 49
// end ;
4621: GO 4428
4623: POP
4624: POP
4625: GO 4412
4627: POP
4628: POP
// InitHc ;
4629: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4633: LD_INT 4
4635: PPUSH
4636: LD_INT 5
4638: PPUSH
4639: LD_INT 10
4641: PPUSH
4642: LD_INT 5
4644: PPUSH
4645: LD_INT 0
4647: PPUSH
4648: CALL_OW 58
// end ;
4652: LD_VAR 0 1
4656: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4657: LD_EXP 42
4661: IFFALSE 4735
4663: GO 4665
4665: DISABLE
4666: LD_INT 0
4668: PPUSH
// begin enable ;
4669: ENABLE
// for i in ar_kamikadze do
4670: LD_ADDR_VAR 0 1
4674: PUSH
4675: LD_EXP 42
4679: PUSH
4680: FOR_IN
4681: IFFALSE 4733
// if See ( 1 , i ) then
4683: LD_INT 1
4685: PPUSH
4686: LD_VAR 0 1
4690: PPUSH
4691: CALL_OW 292
4695: IFFALSE 4731
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4697: LD_VAR 0 1
4701: PPUSH
4702: LD_INT 81
4704: PUSH
4705: LD_INT 2
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PPUSH
4712: CALL_OW 69
4716: PPUSH
4717: LD_VAR 0 1
4721: PPUSH
4722: CALL_OW 74
4726: PPUSH
4727: CALL_OW 115
4731: GO 4680
4733: POP
4734: POP
// end ;
4735: PPOPN 1
4737: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4738: LD_EXP 13
4742: IFFALSE 5059
4744: GO 4746
4746: DISABLE
4747: LD_INT 0
4749: PPUSH
4750: PPUSH
4751: PPUSH
4752: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4753: LD_INT 35
4755: PPUSH
4756: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4760: LD_INT 1
4762: PPUSH
4763: CALL 42497 0 1
4767: PUSH
4768: LD_INT 0
4770: EQUAL
4771: IFFALSE 4753
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 14
4778: PUSH
4779: LD_INT 3
4781: PUSH
4782: LD_INT 2
4784: PUSH
4785: LD_INT 32
4787: PUSH
4788: EMPTY
4789: LIST
4790: LIST
4791: LIST
4792: LIST
4793: PUSH
4794: EMPTY
4795: LIST
4796: PPUSH
4797: CALL 42101 0 2
// repeat wait ( 0 0$1 ) ;
4801: LD_INT 35
4803: PPUSH
4804: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4808: LD_EXP 69
4812: PUSH
4813: LD_INT 1
4815: ARRAY
4816: PPUSH
4817: LD_INT 33
4819: PUSH
4820: LD_INT 2
4822: PUSH
4823: EMPTY
4824: LIST
4825: LIST
4826: PUSH
4827: LD_INT 34
4829: PUSH
4830: LD_INT 32
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: PPUSH
4841: CALL_OW 72
4845: IFFALSE 4801
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4847: LD_ADDR_VAR 0 2
4851: PUSH
4852: LD_EXP 69
4856: PUSH
4857: LD_INT 1
4859: ARRAY
4860: PPUSH
4861: LD_INT 33
4863: PUSH
4864: LD_INT 2
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: PUSH
4871: LD_INT 34
4873: PUSH
4874: LD_INT 32
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: EMPTY
4882: LIST
4883: LIST
4884: PPUSH
4885: CALL_OW 72
4889: PUSH
4890: LD_INT 1
4892: ARRAY
4893: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4894: LD_ADDR_VAR 0 4
4898: PUSH
4899: LD_INT 5
4901: PPUSH
4902: CALL_OW 469
4906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4907: LD_INT 35
4909: PPUSH
4910: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4914: LD_ADDR_VAR 0 4
4918: PUSH
4919: LD_INT 5
4921: PPUSH
4922: CALL_OW 469
4926: ST_TO_ADDR
// tmp := 100 ;
4927: LD_ADDR_VAR 0 3
4931: PUSH
4932: LD_INT 100
4934: ST_TO_ADDR
// if pos then
4935: LD_VAR 0 4
4939: IFFALSE 4979
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4941: LD_ADDR_VAR 0 3
4945: PUSH
4946: LD_INT 2
4948: PPUSH
4949: LD_VAR 0 4
4953: PUSH
4954: LD_INT 1
4956: ARRAY
4957: PPUSH
4958: LD_VAR 0 4
4962: PUSH
4963: LD_INT 2
4965: ARRAY
4966: PPUSH
4967: LD_INT 20
4969: PPUSH
4970: CALL 54437 0 4
4974: PUSH
4975: LD_INT 4
4977: ARRAY
4978: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4979: LD_VAR 0 4
4983: PUSH
4984: LD_EXP 14
4988: NOT
4989: AND
4990: PUSH
4991: LD_VAR 0 3
4995: PUSH
4996: LD_INT 10
4998: LESS
4999: AND
5000: IFFALSE 4907
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5002: LD_VAR 0 2
5006: PPUSH
5007: LD_VAR 0 4
5011: PUSH
5012: LD_INT 1
5014: ARRAY
5015: PPUSH
5016: LD_VAR 0 4
5020: PUSH
5021: LD_INT 2
5023: ARRAY
5024: PPUSH
5025: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5029: LD_VAR 0 2
5033: PPUSH
5034: LD_INT 198
5036: PPUSH
5037: LD_INT 113
5039: PPUSH
5040: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5044: LD_VAR 0 2
5048: PPUSH
5049: LD_INT 124
5051: PPUSH
5052: LD_INT 7
5054: PPUSH
5055: CALL_OW 171
// end ;
5059: PPOPN 4
5061: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5062: LD_EXP 6
5066: IFFALSE 7935
5068: GO 5070
5070: DISABLE
5071: LD_INT 0
5073: PPUSH
5074: PPUSH
5075: PPUSH
5076: PPUSH
5077: PPUSH
5078: PPUSH
5079: PPUSH
5080: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5081: LD_ADDR_VAR 0 4
5085: PUSH
5086: LD_INT 5
5088: PUSH
5089: LD_INT 6
5091: PUSH
5092: LD_INT 7
5094: PUSH
5095: LD_INT 8
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: LIST
5102: LIST
5103: PUSH
5104: LD_OWVAR 67
5108: ARRAY
5109: ST_TO_ADDR
// coords := [ ] ;
5110: LD_ADDR_VAR 0 5
5114: PUSH
5115: EMPTY
5116: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5117: LD_ADDR_VAR 0 6
5121: PUSH
5122: LD_INT 0
5124: PUSH
5125: LD_INT 0
5127: PUSH
5128: LD_INT 0
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 1
5136: PUSH
5137: LD_INT 0
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: LD_INT 0
5145: PUSH
5146: LD_INT 1
5148: PUSH
5149: LD_INT 0
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: LIST
5157: LIST
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: LIST
5163: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5164: LD_INT 1
5166: PPUSH
5167: LD_INT 14
5169: PUSH
5170: LD_INT 1
5172: PUSH
5173: LD_INT 2
5175: PUSH
5176: LD_INT 28
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: LIST
5183: LIST
5184: PUSH
5185: LD_INT 14
5187: PUSH
5188: LD_INT 1
5190: PUSH
5191: LD_INT 2
5193: PUSH
5194: LD_INT 25
5196: PUSH
5197: EMPTY
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: PUSH
5203: LD_INT 14
5205: PUSH
5206: LD_INT 1
5208: PUSH
5209: LD_INT 2
5211: PUSH
5212: LD_INT 28
5214: PUSH
5215: EMPTY
5216: LIST
5217: LIST
5218: LIST
5219: LIST
5220: PUSH
5221: LD_INT 14
5223: PUSH
5224: LD_INT 1
5226: PUSH
5227: LD_INT 2
5229: PUSH
5230: LD_INT 29
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: LIST
5237: LIST
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: LIST
5243: LIST
5244: PPUSH
5245: CALL 42101 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5249: LD_INT 21000
5251: PUSH
5252: LD_INT 19950
5254: PUSH
5255: LD_INT 18900
5257: PUSH
5258: LD_INT 18200
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: LIST
5265: LIST
5266: PUSH
5267: LD_OWVAR 67
5271: ARRAY
5272: PPUSH
5273: CALL_OW 67
// InitHc ;
5277: CALL_OW 19
// InitUc ;
5281: CALL_OW 18
// uc_side := 2 ;
5285: LD_ADDR_OWVAR 20
5289: PUSH
5290: LD_INT 2
5292: ST_TO_ADDR
// uc_nation := 2 ;
5293: LD_ADDR_OWVAR 21
5297: PUSH
5298: LD_INT 2
5300: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5301: LD_ADDR_VAR 0 3
5305: PUSH
5306: EMPTY
5307: PUSH
5308: EMPTY
5309: PUSH
5310: EMPTY
5311: PUSH
5312: EMPTY
5313: PUSH
5314: EMPTY
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: LIST
5320: LIST
5321: LIST
5322: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5323: LD_ADDR_VAR 0 3
5327: PUSH
5328: LD_VAR 0 3
5332: PPUSH
5333: LD_INT 1
5335: PPUSH
5336: LD_EXP 69
5340: PUSH
5341: LD_INT 1
5343: ARRAY
5344: PUSH
5345: LD_INT 2
5347: PUSH
5348: LD_INT 34
5350: PUSH
5351: LD_EXP 100
5355: PUSH
5356: EMPTY
5357: LIST
5358: LIST
5359: PUSH
5360: LD_INT 34
5362: PUSH
5363: LD_INT 32
5365: PUSH
5366: EMPTY
5367: LIST
5368: LIST
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: LIST
5374: PPUSH
5375: CALL_OW 69
5379: DIFF
5380: PPUSH
5381: CALL_OW 1
5385: ST_TO_ADDR
// for i = 1 to Difficulty do
5386: LD_ADDR_VAR 0 1
5390: PUSH
5391: DOUBLE
5392: LD_INT 1
5394: DEC
5395: ST_TO_ADDR
5396: LD_OWVAR 67
5400: PUSH
5401: FOR_TO
5402: IFFALSE 5540
// begin uc_side := 2 ;
5404: LD_ADDR_OWVAR 20
5408: PUSH
5409: LD_INT 2
5411: ST_TO_ADDR
// uc_nation := 2 ;
5412: LD_ADDR_OWVAR 21
5416: PUSH
5417: LD_INT 2
5419: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5420: LD_INT 13
5422: PPUSH
5423: LD_INT 3
5425: PPUSH
5426: LD_INT 5
5428: PPUSH
5429: LD_INT 29
5431: PPUSH
5432: LD_INT 100
5434: PPUSH
5435: CALL 53419 0 5
// un := CreateVehicle ;
5439: LD_ADDR_VAR 0 2
5443: PUSH
5444: CALL_OW 45
5448: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5449: LD_ADDR_VAR 0 3
5453: PUSH
5454: LD_VAR 0 3
5458: PPUSH
5459: LD_INT 1
5461: PUSH
5462: LD_VAR 0 3
5466: PUSH
5467: LD_INT 1
5469: ARRAY
5470: PUSH
5471: LD_INT 1
5473: PLUS
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PPUSH
5479: LD_VAR 0 2
5483: PPUSH
5484: CALL 53541 0 3
5488: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5489: LD_VAR 0 2
5493: PPUSH
5494: LD_INT 3
5496: PPUSH
5497: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5501: LD_VAR 0 2
5505: PPUSH
5506: LD_INT 16
5508: PPUSH
5509: LD_INT 0
5511: PPUSH
5512: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5516: LD_VAR 0 2
5520: PPUSH
5521: LD_INT 51
5523: PPUSH
5524: LD_INT 10
5526: PPUSH
5527: CALL_OW 111
// wait ( 0 0$2 ) ;
5531: LD_INT 70
5533: PPUSH
5534: CALL_OW 67
// end ;
5538: GO 5401
5540: POP
5541: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5542: LD_ADDR_VAR 0 5
5546: PUSH
5547: LD_INT 51
5549: PUSH
5550: LD_INT 24
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PUSH
5557: LD_INT 75
5559: PUSH
5560: LD_INT 90
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5571: LD_INT 1
5573: PPUSH
5574: LD_VAR 0 3
5578: PUSH
5579: LD_INT 1
5581: ARRAY
5582: PPUSH
5583: LD_VAR 0 5
5587: PPUSH
5588: LD_VAR 0 6
5592: PPUSH
5593: CALL 42334 0 4
// for i = 1 to [ 1 , 3 , 3 , 3 ] [ Difficulty ] do
5597: LD_ADDR_VAR 0 1
5601: PUSH
5602: DOUBLE
5603: LD_INT 1
5605: DEC
5606: ST_TO_ADDR
5607: LD_INT 1
5609: PUSH
5610: LD_INT 3
5612: PUSH
5613: LD_INT 3
5615: PUSH
5616: LD_INT 3
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: LIST
5623: LIST
5624: PUSH
5625: LD_OWVAR 67
5629: ARRAY
5630: PUSH
5631: FOR_TO
5632: IFFALSE 5732
// begin uc_side := 2 ;
5634: LD_ADDR_OWVAR 20
5638: PUSH
5639: LD_INT 2
5641: ST_TO_ADDR
// uc_nation := 2 ;
5642: LD_ADDR_OWVAR 21
5646: PUSH
5647: LD_INT 2
5649: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5650: LD_INT 0
5652: PPUSH
5653: LD_INT 17
5655: PPUSH
5656: LD_VAR 0 4
5660: PPUSH
5661: CALL_OW 380
// un := CreateHuman ;
5665: LD_ADDR_VAR 0 2
5669: PUSH
5670: CALL_OW 44
5674: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5675: LD_ADDR_VAR 0 3
5679: PUSH
5680: LD_VAR 0 3
5684: PPUSH
5685: LD_INT 2
5687: PUSH
5688: LD_VAR 0 3
5692: PUSH
5693: LD_INT 2
5695: ARRAY
5696: PUSH
5697: LD_INT 1
5699: PLUS
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: PPUSH
5705: LD_VAR 0 2
5709: PPUSH
5710: CALL 53541 0 3
5714: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5715: LD_VAR 0 2
5719: PPUSH
5720: LD_INT 13
5722: PPUSH
5723: LD_INT 0
5725: PPUSH
5726: CALL_OW 49
// end ;
5730: GO 5631
5732: POP
5733: POP
// for i = 1 to [ 3 , 4 , 4 , 4 ] [ Difficulty ] do
5734: LD_ADDR_VAR 0 1
5738: PUSH
5739: DOUBLE
5740: LD_INT 1
5742: DEC
5743: ST_TO_ADDR
5744: LD_INT 3
5746: PUSH
5747: LD_INT 4
5749: PUSH
5750: LD_INT 4
5752: PUSH
5753: LD_INT 4
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: PUSH
5762: LD_OWVAR 67
5766: ARRAY
5767: PUSH
5768: FOR_TO
5769: IFFALSE 5890
// begin uc_side := 2 ;
5771: LD_ADDR_OWVAR 20
5775: PUSH
5776: LD_INT 2
5778: ST_TO_ADDR
// uc_nation := 2 ;
5779: LD_ADDR_OWVAR 21
5783: PUSH
5784: LD_INT 2
5786: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5787: LD_INT 0
5789: PPUSH
5790: LD_INT 1
5792: PUSH
5793: LD_INT 8
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: PUSH
5800: LD_VAR 0 1
5804: PUSH
5805: LD_INT 2
5807: MOD
5808: PUSH
5809: LD_INT 1
5811: PLUS
5812: ARRAY
5813: PPUSH
5814: LD_VAR 0 4
5818: PPUSH
5819: CALL_OW 380
// un := CreateHuman ;
5823: LD_ADDR_VAR 0 2
5827: PUSH
5828: CALL_OW 44
5832: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5833: LD_ADDR_VAR 0 3
5837: PUSH
5838: LD_VAR 0 3
5842: PPUSH
5843: LD_INT 2
5845: PUSH
5846: LD_VAR 0 3
5850: PUSH
5851: LD_INT 2
5853: ARRAY
5854: PUSH
5855: LD_INT 1
5857: PLUS
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PPUSH
5863: LD_VAR 0 2
5867: PPUSH
5868: CALL 53541 0 3
5872: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5873: LD_VAR 0 2
5877: PPUSH
5878: LD_INT 13
5880: PPUSH
5881: LD_INT 0
5883: PPUSH
5884: CALL_OW 49
// end ;
5888: GO 5768
5890: POP
5891: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5892: LD_ADDR_VAR 0 5
5896: PUSH
5897: LD_INT 67
5899: PUSH
5900: LD_INT 112
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PUSH
5907: LD_INT 85
5909: PUSH
5910: LD_INT 130
5912: PUSH
5913: EMPTY
5914: LIST
5915: LIST
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5921: LD_INT 2
5923: PPUSH
5924: LD_VAR 0 3
5928: PUSH
5929: LD_INT 2
5931: ARRAY
5932: PPUSH
5933: LD_VAR 0 5
5937: PPUSH
5938: LD_VAR 0 6
5942: PPUSH
5943: CALL 42334 0 4
// for i = 1 to [ 1 , 2 , 3 , 4 ] [ Difficulty ] do
5947: LD_ADDR_VAR 0 1
5951: PUSH
5952: DOUBLE
5953: LD_INT 1
5955: DEC
5956: ST_TO_ADDR
5957: LD_INT 1
5959: PUSH
5960: LD_INT 2
5962: PUSH
5963: LD_INT 3
5965: PUSH
5966: LD_INT 4
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: LIST
5973: LIST
5974: PUSH
5975: LD_OWVAR 67
5979: ARRAY
5980: PUSH
5981: FOR_TO
5982: IFFALSE 6082
// begin uc_side := 2 ;
5984: LD_ADDR_OWVAR 20
5988: PUSH
5989: LD_INT 2
5991: ST_TO_ADDR
// uc_nation := 2 ;
5992: LD_ADDR_OWVAR 21
5996: PUSH
5997: LD_INT 2
5999: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6000: LD_INT 0
6002: PPUSH
6003: LD_INT 17
6005: PPUSH
6006: LD_VAR 0 4
6010: PPUSH
6011: CALL_OW 380
// un := CreateHuman ;
6015: LD_ADDR_VAR 0 2
6019: PUSH
6020: CALL_OW 44
6024: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6025: LD_ADDR_VAR 0 3
6029: PUSH
6030: LD_VAR 0 3
6034: PPUSH
6035: LD_INT 3
6037: PUSH
6038: LD_VAR 0 3
6042: PUSH
6043: LD_INT 3
6045: ARRAY
6046: PUSH
6047: LD_INT 1
6049: PLUS
6050: PUSH
6051: EMPTY
6052: LIST
6053: LIST
6054: PPUSH
6055: LD_VAR 0 2
6059: PPUSH
6060: CALL 53541 0 3
6064: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6065: LD_VAR 0 2
6069: PPUSH
6070: LD_INT 14
6072: PPUSH
6073: LD_INT 0
6075: PPUSH
6076: CALL_OW 49
// end ;
6080: GO 5981
6082: POP
6083: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6084: LD_ADDR_VAR 0 5
6088: PUSH
6089: LD_INT 148
6091: PUSH
6092: LD_INT 158
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PUSH
6099: LD_INT 148
6101: PUSH
6102: LD_INT 158
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6113: LD_INT 3
6115: PPUSH
6116: LD_VAR 0 3
6120: PUSH
6121: LD_INT 3
6123: ARRAY
6124: PPUSH
6125: LD_VAR 0 5
6129: PPUSH
6130: LD_VAR 0 6
6134: PPUSH
6135: CALL 42334 0 4
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
6139: LD_ADDR_VAR 0 1
6143: PUSH
6144: DOUBLE
6145: LD_INT 1
6147: DEC
6148: ST_TO_ADDR
6149: LD_INT 2
6151: PUSH
6152: LD_INT 3
6154: PUSH
6155: LD_INT 4
6157: PUSH
6158: LD_INT 4
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: LIST
6165: LIST
6166: PUSH
6167: LD_OWVAR 67
6171: ARRAY
6172: PUSH
6173: FOR_TO
6174: IFFALSE 6398
// begin uc_side := 2 ;
6176: LD_ADDR_OWVAR 20
6180: PUSH
6181: LD_INT 2
6183: ST_TO_ADDR
// uc_nation := 2 ;
6184: LD_ADDR_OWVAR 21
6188: PUSH
6189: LD_INT 2
6191: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6192: LD_INT 14
6194: PPUSH
6195: LD_INT 3
6197: PPUSH
6198: LD_INT 1
6200: PUSH
6201: LD_INT 5
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: PUSH
6208: LD_INT 1
6210: PPUSH
6211: LD_INT 2
6213: PPUSH
6214: CALL_OW 12
6218: ARRAY
6219: PPUSH
6220: LD_INT 27
6222: PUSH
6223: LD_INT 26
6225: PUSH
6226: LD_INT 28
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: PUSH
6234: LD_INT 1
6236: PPUSH
6237: LD_INT 3
6239: PPUSH
6240: CALL_OW 12
6244: ARRAY
6245: PPUSH
6246: LD_INT 100
6248: PPUSH
6249: CALL 53419 0 5
// un := CreateVehicle ;
6253: LD_ADDR_VAR 0 2
6257: PUSH
6258: CALL_OW 45
6262: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6263: LD_ADDR_VAR 0 3
6267: PUSH
6268: LD_VAR 0 3
6272: PPUSH
6273: LD_INT 4
6275: PUSH
6276: LD_VAR 0 3
6280: PUSH
6281: LD_INT 4
6283: ARRAY
6284: PUSH
6285: LD_INT 1
6287: PLUS
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: PPUSH
6293: LD_VAR 0 2
6297: PPUSH
6298: CALL 53541 0 3
6302: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6303: LD_VAR 0 2
6307: PPUSH
6308: LD_INT 5
6310: PPUSH
6311: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6315: LD_VAR 0 2
6319: PPUSH
6320: LD_INT 15
6322: PPUSH
6323: LD_INT 0
6325: PPUSH
6326: CALL_OW 49
// if GetControl ( un ) = control_manual then
6330: LD_VAR 0 2
6334: PPUSH
6335: CALL_OW 263
6339: PUSH
6340: LD_INT 1
6342: EQUAL
6343: IFFALSE 6374
// begin PrepareHuman ( false , 3 , skill ) ;
6345: LD_INT 0
6347: PPUSH
6348: LD_INT 3
6350: PPUSH
6351: LD_VAR 0 4
6355: PPUSH
6356: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6360: CALL_OW 44
6364: PPUSH
6365: LD_VAR 0 2
6369: PPUSH
6370: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6374: LD_VAR 0 2
6378: PPUSH
6379: LD_INT 179
6381: PPUSH
6382: LD_INT 135
6384: PPUSH
6385: CALL_OW 111
// wait ( 0 0$2 ) ;
6389: LD_INT 70
6391: PPUSH
6392: CALL_OW 67
// end ;
6396: GO 6173
6398: POP
6399: POP
// vc_chassis := 15 ;
6400: LD_ADDR_OWVAR 37
6404: PUSH
6405: LD_INT 15
6407: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6408: LD_ADDR_VAR 0 3
6412: PUSH
6413: LD_VAR 0 3
6417: PPUSH
6418: LD_INT 4
6420: PUSH
6421: LD_VAR 0 3
6425: PUSH
6426: LD_INT 4
6428: ARRAY
6429: PUSH
6430: LD_INT 1
6432: PLUS
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: PPUSH
6438: CALL_OW 45
6442: PPUSH
6443: CALL 53541 0 3
6447: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6448: LD_VAR 0 3
6452: PUSH
6453: LD_INT 4
6455: ARRAY
6456: PUSH
6457: LD_VAR 0 3
6461: PUSH
6462: LD_INT 4
6464: ARRAY
6465: ARRAY
6466: PPUSH
6467: LD_INT 15
6469: PPUSH
6470: LD_INT 0
6472: PPUSH
6473: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6477: LD_INT 0
6479: PPUSH
6480: LD_INT 11
6482: PPUSH
6483: LD_VAR 0 4
6487: PPUSH
6488: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6492: LD_ADDR_VAR 0 3
6496: PUSH
6497: LD_VAR 0 3
6501: PPUSH
6502: LD_INT 4
6504: PUSH
6505: LD_VAR 0 3
6509: PUSH
6510: LD_INT 4
6512: ARRAY
6513: PUSH
6514: LD_INT 1
6516: PLUS
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PPUSH
6522: CALL_OW 44
6526: PPUSH
6527: CALL 53541 0 3
6531: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6532: LD_VAR 0 3
6536: PUSH
6537: LD_INT 4
6539: ARRAY
6540: PUSH
6541: LD_VAR 0 3
6545: PUSH
6546: LD_INT 4
6548: ARRAY
6549: ARRAY
6550: PPUSH
6551: LD_VAR 0 3
6555: PUSH
6556: LD_INT 4
6558: ARRAY
6559: PUSH
6560: LD_VAR 0 3
6564: PUSH
6565: LD_INT 4
6567: ARRAY
6568: PUSH
6569: LD_INT 1
6571: MINUS
6572: ARRAY
6573: PPUSH
6574: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6578: LD_ADDR_VAR 0 5
6582: PUSH
6583: LD_INT 148
6585: PUSH
6586: LD_INT 140
6588: PUSH
6589: EMPTY
6590: LIST
6591: LIST
6592: PUSH
6593: EMPTY
6594: LIST
6595: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6596: LD_INT 1
6598: PPUSH
6599: LD_VAR 0 3
6603: PUSH
6604: LD_INT 4
6606: ARRAY
6607: PPUSH
6608: LD_VAR 0 5
6612: PPUSH
6613: LD_VAR 0 6
6617: PPUSH
6618: CALL 42334 0 4
// if gensher_active then
6622: LD_EXP 18
6626: IFFALSE 7032
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6628: LD_EXP 45
6632: PPUSH
6633: LD_STRING D10-Diet-1
6635: PPUSH
6636: CALL_OW 94
// for i = 1 to 2 do
6640: LD_ADDR_VAR 0 1
6644: PUSH
6645: DOUBLE
6646: LD_INT 1
6648: DEC
6649: ST_TO_ADDR
6650: LD_INT 2
6652: PUSH
6653: FOR_TO
6654: IFFALSE 6792
// begin uc_side := 2 ;
6656: LD_ADDR_OWVAR 20
6660: PUSH
6661: LD_INT 2
6663: ST_TO_ADDR
// uc_nation := 2 ;
6664: LD_ADDR_OWVAR 21
6668: PUSH
6669: LD_INT 2
6671: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6672: LD_INT 13
6674: PPUSH
6675: LD_INT 3
6677: PPUSH
6678: LD_INT 5
6680: PPUSH
6681: LD_INT 29
6683: PPUSH
6684: LD_INT 100
6686: PPUSH
6687: CALL 53419 0 5
// un := CreateVehicle ;
6691: LD_ADDR_VAR 0 2
6695: PUSH
6696: CALL_OW 45
6700: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6701: LD_ADDR_VAR 0 3
6705: PUSH
6706: LD_VAR 0 3
6710: PPUSH
6711: LD_INT 5
6713: PUSH
6714: LD_VAR 0 3
6718: PUSH
6719: LD_INT 5
6721: ARRAY
6722: PUSH
6723: LD_INT 1
6725: PLUS
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PPUSH
6731: LD_VAR 0 2
6735: PPUSH
6736: CALL 53541 0 3
6740: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6741: LD_VAR 0 2
6745: PPUSH
6746: LD_INT 0
6748: PPUSH
6749: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6753: LD_VAR 0 2
6757: PPUSH
6758: LD_INT 23
6760: PPUSH
6761: LD_INT 0
6763: PPUSH
6764: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6768: LD_VAR 0 2
6772: PPUSH
6773: LD_INT 85
6775: PPUSH
6776: LD_INT 152
6778: PPUSH
6779: CALL_OW 111
// wait ( 0 0$2 ) ;
6783: LD_INT 70
6785: PPUSH
6786: CALL_OW 67
// end ;
6790: GO 6653
6792: POP
6793: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6794: LD_ADDR_VAR 0 1
6798: PUSH
6799: DOUBLE
6800: LD_INT 1
6802: DEC
6803: ST_TO_ADDR
6804: LD_INT 2
6806: PUSH
6807: LD_INT 3
6809: PUSH
6810: LD_INT 3
6812: PUSH
6813: LD_INT 4
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: PUSH
6822: LD_OWVAR 67
6826: ARRAY
6827: PUSH
6828: FOR_TO
6829: IFFALSE 6986
// begin uc_side := 2 ;
6831: LD_ADDR_OWVAR 20
6835: PUSH
6836: LD_INT 2
6838: ST_TO_ADDR
// uc_nation := 2 ;
6839: LD_ADDR_OWVAR 21
6843: PUSH
6844: LD_INT 2
6846: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6847: LD_INT 14
6849: PPUSH
6850: LD_INT 3
6852: PPUSH
6853: LD_INT 5
6855: PPUSH
6856: LD_INT 27
6858: PUSH
6859: LD_INT 28
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: PUSH
6866: LD_INT 1
6868: PPUSH
6869: LD_INT 2
6871: PPUSH
6872: CALL_OW 12
6876: ARRAY
6877: PPUSH
6878: LD_INT 100
6880: PPUSH
6881: CALL 53419 0 5
// un := CreateVehicle ;
6885: LD_ADDR_VAR 0 2
6889: PUSH
6890: CALL_OW 45
6894: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6895: LD_ADDR_VAR 0 3
6899: PUSH
6900: LD_VAR 0 3
6904: PPUSH
6905: LD_INT 5
6907: PUSH
6908: LD_VAR 0 3
6912: PUSH
6913: LD_INT 5
6915: ARRAY
6916: PUSH
6917: LD_INT 1
6919: PLUS
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: PPUSH
6925: LD_VAR 0 2
6929: PPUSH
6930: CALL 53541 0 3
6934: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6935: LD_VAR 0 2
6939: PPUSH
6940: LD_INT 0
6942: PPUSH
6943: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6947: LD_VAR 0 2
6951: PPUSH
6952: LD_INT 23
6954: PPUSH
6955: LD_INT 0
6957: PPUSH
6958: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6962: LD_VAR 0 2
6966: PPUSH
6967: LD_INT 85
6969: PPUSH
6970: LD_INT 152
6972: PPUSH
6973: CALL_OW 111
// wait ( 0 0$2 ) ;
6977: LD_INT 70
6979: PPUSH
6980: CALL_OW 67
// end ;
6984: GO 6828
6986: POP
6987: POP
// coords := [ [ 97 , 143 ] ] ;
6988: LD_ADDR_VAR 0 5
6992: PUSH
6993: LD_INT 97
6995: PUSH
6996: LD_INT 143
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: PUSH
7003: EMPTY
7004: LIST
7005: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7006: LD_INT 1
7008: PPUSH
7009: LD_VAR 0 3
7013: PUSH
7014: LD_INT 5
7016: ARRAY
7017: PPUSH
7018: LD_VAR 0 5
7022: PPUSH
7023: LD_VAR 0 6
7027: PPUSH
7028: CALL 42334 0 4
// end ; Wait ( 13 13$00 ) ;
7032: LD_INT 27300
7034: PPUSH
7035: CALL_OW 67
// tmp := [ ] ;
7039: LD_ADDR_VAR 0 3
7043: PUSH
7044: EMPTY
7045: ST_TO_ADDR
// w := 1 ;
7046: LD_ADDR_VAR 0 7
7050: PUSH
7051: LD_INT 1
7053: ST_TO_ADDR
// repeat tmp := [ ] ;
7054: LD_ADDR_VAR 0 3
7058: PUSH
7059: EMPTY
7060: ST_TO_ADDR
// if w mod 4 = 0 then
7061: LD_VAR 0 7
7065: PUSH
7066: LD_INT 4
7068: MOD
7069: PUSH
7070: LD_INT 0
7072: EQUAL
7073: IFFALSE 7160
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7075: LD_ADDR_VAR 0 8
7079: PUSH
7080: LD_INT 11
7082: PUSH
7083: LD_INT 1
7085: PUSH
7086: LD_INT 2
7088: PUSH
7089: LD_INT 24
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: LIST
7096: LIST
7097: PUSH
7098: LD_INT 11
7100: PUSH
7101: LD_INT 1
7103: PUSH
7104: LD_INT 2
7106: PUSH
7107: LD_INT 24
7109: PUSH
7110: EMPTY
7111: LIST
7112: LIST
7113: LIST
7114: LIST
7115: PUSH
7116: LD_INT 11
7118: PUSH
7119: LD_INT 1
7121: PUSH
7122: LD_INT 2
7124: PUSH
7125: LD_INT 24
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: LIST
7132: LIST
7133: PUSH
7134: LD_INT 11
7136: PUSH
7137: LD_INT 1
7139: PUSH
7140: LD_INT 2
7142: PUSH
7143: LD_INT 24
7145: PUSH
7146: EMPTY
7147: LIST
7148: LIST
7149: LIST
7150: LIST
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: LIST
7156: LIST
7157: ST_TO_ADDR
7158: GO 7262
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7160: LD_ADDR_VAR 0 8
7164: PUSH
7165: LD_INT 14
7167: PUSH
7168: LD_INT 1
7170: PUSH
7171: LD_INT 2
7173: PUSH
7174: LD_INT 28
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: LIST
7181: LIST
7182: PUSH
7183: LD_INT 14
7185: PUSH
7186: LD_INT 1
7188: PUSH
7189: LD_INT 2
7191: PUSH
7192: LD_INT 25
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: LIST
7200: PUSH
7201: LD_INT 14
7203: PUSH
7204: LD_INT 1
7206: PUSH
7207: LD_INT 2
7209: PUSH
7210: LD_INT 28
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 14
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: LD_INT 2
7227: PUSH
7228: LD_INT 29
7230: PUSH
7231: EMPTY
7232: LIST
7233: LIST
7234: LIST
7235: LIST
7236: PUSH
7237: LD_INT 11
7239: PUSH
7240: LD_INT 1
7242: PUSH
7243: LD_INT 2
7245: PUSH
7246: LD_INT 24
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: LIST
7253: LIST
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: ST_TO_ADDR
// if w mod 3 = 0 then
7262: LD_VAR 0 7
7266: PUSH
7267: LD_INT 3
7269: MOD
7270: PUSH
7271: LD_INT 0
7273: EQUAL
7274: IFFALSE 7350
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7276: LD_ADDR_VAR 0 8
7280: PUSH
7281: LD_VAR 0 8
7285: PPUSH
7286: LD_INT 1
7288: PUSH
7289: LD_VAR 0 8
7293: PUSH
7294: LD_VAR 0 1
7298: ARRAY
7299: PUSH
7300: LD_INT 1
7302: PLUS
7303: PUSH
7304: EMPTY
7305: LIST
7306: LIST
7307: PPUSH
7308: LD_INT 14
7310: PUSH
7311: LD_INT 1
7313: PUSH
7314: LD_INT 2
7316: PUSH
7317: LD_INT 25
7319: PUSH
7320: LD_INT 28
7322: PUSH
7323: EMPTY
7324: LIST
7325: LIST
7326: PUSH
7327: LD_INT 1
7329: PPUSH
7330: LD_INT 2
7332: PPUSH
7333: CALL_OW 12
7337: ARRAY
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL 53541 0 3
7349: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7350: LD_INT 1
7352: PPUSH
7353: LD_VAR 0 8
7357: PPUSH
7358: CALL 42101 0 2
// if GetSide ( ar_dep_w ) = 2 then
7362: LD_INT 45
7364: PPUSH
7365: CALL_OW 255
7369: PUSH
7370: LD_INT 2
7372: EQUAL
7373: IFFALSE 7458
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7375: LD_ADDR_VAR 0 8
7379: PUSH
7380: LD_INT 14
7382: PUSH
7383: LD_INT 1
7385: PUSH
7386: LD_INT 2
7388: PUSH
7389: LD_INT 28
7391: PUSH
7392: EMPTY
7393: LIST
7394: LIST
7395: LIST
7396: LIST
7397: PUSH
7398: LD_INT 14
7400: PUSH
7401: LD_INT 1
7403: PUSH
7404: LD_INT 2
7406: PUSH
7407: LD_INT 27
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: PUSH
7416: LD_INT 14
7418: PUSH
7419: LD_INT 1
7421: PUSH
7422: LD_INT 2
7424: PUSH
7425: LD_INT 27
7427: PUSH
7428: EMPTY
7429: LIST
7430: LIST
7431: LIST
7432: LIST
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: LIST
7438: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7439: LD_INT 2
7441: PPUSH
7442: LD_VAR 0 8
7446: PPUSH
7447: CALL 42101 0 2
// wait ( 0 0$50 ) ;
7451: LD_INT 1750
7453: PPUSH
7454: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7458: LD_INT 35
7460: PPUSH
7461: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7465: LD_EXP 69
7469: PUSH
7470: LD_INT 1
7472: ARRAY
7473: PPUSH
7474: LD_INT 3
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: LD_INT 34
7482: PUSH
7483: LD_INT 32
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 34
7492: PUSH
7493: LD_EXP 100
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: EMPTY
7508: LIST
7509: LIST
7510: PPUSH
7511: CALL_OW 72
7515: PUSH
7516: LD_INT 4
7518: GREATEREQUAL
7519: IFFALSE 7458
// wait ( 0 0$10 ) ;
7521: LD_INT 350
7523: PPUSH
7524: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7528: LD_ADDR_VAR 0 3
7532: PUSH
7533: LD_EXP 69
7537: PUSH
7538: LD_INT 1
7540: ARRAY
7541: PPUSH
7542: LD_INT 3
7544: PUSH
7545: LD_INT 2
7547: PUSH
7548: LD_INT 34
7550: PUSH
7551: LD_INT 32
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PUSH
7558: LD_INT 34
7560: PUSH
7561: LD_EXP 100
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: LIST
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PPUSH
7579: CALL_OW 72
7583: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7584: LD_INT 100
7586: PPUSH
7587: CALL_OW 13
7591: PUSH
7592: LD_INT 50
7594: LESS
7595: IFFALSE 7628
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7597: LD_ADDR_VAR 0 5
7601: PUSH
7602: LD_INT 55
7604: PUSH
7605: LD_INT 7
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: LD_INT 75
7614: PUSH
7615: LD_INT 90
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: EMPTY
7623: LIST
7624: LIST
7625: ST_TO_ADDR
7626: GO 7657
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7628: LD_ADDR_VAR 0 5
7632: PUSH
7633: LD_INT 128
7635: PUSH
7636: LD_INT 94
7638: PUSH
7639: EMPTY
7640: LIST
7641: LIST
7642: PUSH
7643: LD_INT 180
7645: PUSH
7646: LD_INT 135
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: ST_TO_ADDR
// if w mod 4 = 0 then
7657: LD_VAR 0 7
7661: PUSH
7662: LD_INT 4
7664: MOD
7665: PUSH
7666: LD_INT 0
7668: EQUAL
7669: IFFALSE 7700
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7671: LD_ADDR_VAR 0 5
7675: PUSH
7676: LD_INT 91
7678: PUSH
7679: LD_INT 58
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 117
7688: PUSH
7689: LD_INT 107
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7700: LD_VAR 0 3
7704: PPUSH
7705: LD_VAR 0 5
7709: PUSH
7710: LD_INT 1
7712: ARRAY
7713: PPUSH
7714: LD_VAR 0 5
7718: PUSH
7719: LD_INT 2
7721: ARRAY
7722: PPUSH
7723: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7734: LD_VAR 0 3
7738: PPUSH
7739: LD_INT 60
7741: PUSH
7742: EMPTY
7743: LIST
7744: PPUSH
7745: CALL_OW 72
7749: PUSH
7750: LD_INT 0
7752: EQUAL
7753: IFFALSE 7727
// repeat wait ( 0 0$2 ) ;
7755: LD_INT 70
7757: PPUSH
7758: CALL_OW 67
// for i in tmp do
7762: LD_ADDR_VAR 0 1
7766: PUSH
7767: LD_VAR 0 3
7771: PUSH
7772: FOR_IN
7773: IFFALSE 7862
// if GetChassis ( i ) = ar_hovercraft then
7775: LD_VAR 0 1
7779: PPUSH
7780: CALL_OW 265
7784: PUSH
7785: LD_INT 11
7787: EQUAL
7788: IFFALSE 7826
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7790: LD_VAR 0 1
7794: PPUSH
7795: LD_INT 22
7797: PUSH
7798: LD_INT 1
7800: PUSH
7801: EMPTY
7802: LIST
7803: LIST
7804: PPUSH
7805: CALL_OW 69
7809: PPUSH
7810: LD_VAR 0 1
7814: PPUSH
7815: CALL_OW 74
7819: PPUSH
7820: CALL 81437 0 2
7824: GO 7860
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7826: LD_VAR 0 1
7830: PPUSH
7831: LD_INT 22
7833: PUSH
7834: LD_INT 1
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PPUSH
7841: CALL_OW 69
7845: PPUSH
7846: LD_VAR 0 1
7850: PPUSH
7851: CALL_OW 74
7855: PPUSH
7856: CALL_OW 115
7860: GO 7772
7862: POP
7863: POP
// until not tmp ;
7864: LD_VAR 0 3
7868: NOT
7869: IFFALSE 7755
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7871: LD_INT 22050
7873: PPUSH
7874: LD_INT 28350
7876: PPUSH
7877: CALL_OW 12
7881: PPUSH
7882: CALL_OW 67
// w := w + 1 ;
7886: LD_ADDR_VAR 0 7
7890: PUSH
7891: LD_VAR 0 7
7895: PUSH
7896: LD_INT 1
7898: PLUS
7899: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7900: LD_INT 94
7902: PPUSH
7903: CALL_OW 301
7907: PUSH
7908: LD_EXP 50
7912: PUSH
7913: LD_INT 1
7915: ARRAY
7916: PPUSH
7917: LD_INT 30
7919: PUSH
7920: LD_INT 3
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PPUSH
7927: CALL_OW 72
7931: NOT
7932: OR
7933: IFFALSE 7054
// end ;
7935: PPOPN 8
7937: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7938: LD_INT 204
7940: IFFALSE 8406
7942: GO 7944
7944: DISABLE
7945: LD_INT 0
7947: PPUSH
7948: PPUSH
7949: PPUSH
7950: PPUSH
// begin enable ;
7951: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7952: LD_INT 35
7954: PPUSH
7955: LD_INT 1190
7957: PPUSH
7958: CALL_OW 12
7962: PPUSH
7963: CALL_OW 67
// tmp := [ ] ;
7967: LD_ADDR_VAR 0 2
7971: PUSH
7972: EMPTY
7973: ST_TO_ADDR
// uc_side := 8 ;
7974: LD_ADDR_OWVAR 20
7978: PUSH
7979: LD_INT 8
7981: ST_TO_ADDR
// uc_nation := 2 ;
7982: LD_ADDR_OWVAR 21
7986: PUSH
7987: LD_INT 2
7989: ST_TO_ADDR
// InitHc ;
7990: CALL_OW 19
// for i = 1 to 3 do
7994: LD_ADDR_VAR 0 1
7998: PUSH
7999: DOUBLE
8000: LD_INT 1
8002: DEC
8003: ST_TO_ADDR
8004: LD_INT 3
8006: PUSH
8007: FOR_TO
8008: IFFALSE 8135
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8010: LD_INT 13
8012: PUSH
8013: LD_INT 14
8015: PUSH
8016: EMPTY
8017: LIST
8018: LIST
8019: PUSH
8020: LD_INT 1
8022: PPUSH
8023: LD_INT 2
8025: PPUSH
8026: CALL_OW 12
8030: ARRAY
8031: PPUSH
8032: LD_INT 3
8034: PPUSH
8035: LD_INT 5
8037: PPUSH
8038: LD_INT 27
8040: PUSH
8041: LD_INT 28
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 1
8050: PPUSH
8051: LD_INT 2
8053: PPUSH
8054: CALL_OW 12
8058: ARRAY
8059: PPUSH
8060: LD_INT 100
8062: PPUSH
8063: CALL 53419 0 5
// un := CreateVehicle ;
8067: LD_ADDR_VAR 0 3
8071: PUSH
8072: CALL_OW 45
8076: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8077: LD_VAR 0 3
8081: PPUSH
8082: LD_INT 4
8084: PPUSH
8085: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8089: LD_VAR 0 3
8093: PPUSH
8094: LD_INT 15
8096: PPUSH
8097: LD_INT 0
8099: PPUSH
8100: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8104: LD_ADDR_VAR 0 2
8108: PUSH
8109: LD_VAR 0 2
8113: PPUSH
8114: LD_VAR 0 2
8118: PUSH
8119: LD_INT 1
8121: PLUS
8122: PPUSH
8123: LD_VAR 0 3
8127: PPUSH
8128: CALL_OW 1
8132: ST_TO_ADDR
// end ;
8133: GO 8007
8135: POP
8136: POP
// for i = 1 to 4 do
8137: LD_ADDR_VAR 0 1
8141: PUSH
8142: DOUBLE
8143: LD_INT 1
8145: DEC
8146: ST_TO_ADDR
8147: LD_INT 4
8149: PUSH
8150: FOR_TO
8151: IFFALSE 8222
// begin PrepareHuman ( false , 1 , 6 ) ;
8153: LD_INT 0
8155: PPUSH
8156: LD_INT 1
8158: PPUSH
8159: LD_INT 6
8161: PPUSH
8162: CALL_OW 380
// un := CreateHuman ;
8166: LD_ADDR_VAR 0 3
8170: PUSH
8171: CALL_OW 44
8175: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8176: LD_VAR 0 3
8180: PPUSH
8181: LD_INT 15
8183: PPUSH
8184: LD_INT 0
8186: PPUSH
8187: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8191: LD_ADDR_VAR 0 2
8195: PUSH
8196: LD_VAR 0 2
8200: PPUSH
8201: LD_VAR 0 2
8205: PUSH
8206: LD_INT 1
8208: PLUS
8209: PPUSH
8210: LD_VAR 0 3
8214: PPUSH
8215: CALL_OW 1
8219: ST_TO_ADDR
// end ;
8220: GO 8150
8222: POP
8223: POP
// wait ( 0 0$3 ) ;
8224: LD_INT 105
8226: PPUSH
8227: CALL_OW 67
// for i in tmp do
8231: LD_ADDR_VAR 0 1
8235: PUSH
8236: LD_VAR 0 2
8240: PUSH
8241: FOR_IN
8242: IFFALSE 8310
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8244: LD_VAR 0 1
8248: PPUSH
8249: CALL_OW 257
8253: PUSH
8254: LD_INT 1
8256: EQUAL
8257: PUSH
8258: LD_VAR 0 1
8262: PPUSH
8263: CALL_OW 247
8267: PUSH
8268: LD_INT 2
8270: EQUAL
8271: OR
8272: IFFALSE 8308
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8274: LD_VAR 0 1
8278: PPUSH
8279: LD_INT 81
8281: PUSH
8282: LD_INT 8
8284: PUSH
8285: EMPTY
8286: LIST
8287: LIST
8288: PPUSH
8289: CALL_OW 69
8293: PPUSH
8294: LD_VAR 0 1
8298: PPUSH
8299: CALL_OW 74
8303: PPUSH
8304: CALL_OW 115
8308: GO 8241
8310: POP
8311: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8312: LD_VAR 0 2
8316: PPUSH
8317: LD_INT 210
8319: PPUSH
8320: LD_INT 178
8322: PPUSH
8323: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8327: LD_ADDR_VAR 0 4
8331: PUSH
8332: LD_INT 10
8334: PPUSH
8335: LD_INT 22
8337: PUSH
8338: LD_INT 8
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: PPUSH
8345: CALL_OW 70
8349: ST_TO_ADDR
// if x then
8350: LD_VAR 0 4
8354: IFFALSE 8382
// for i in x do
8356: LD_ADDR_VAR 0 1
8360: PUSH
8361: LD_VAR 0 4
8365: PUSH
8366: FOR_IN
8367: IFFALSE 8380
// RemoveUnit ( i ) ;
8369: LD_VAR 0 1
8373: PPUSH
8374: CALL_OW 64
8378: GO 8366
8380: POP
8381: POP
// wait ( 0 0$1 ) ;
8382: LD_INT 35
8384: PPUSH
8385: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8389: LD_INT 22
8391: PUSH
8392: LD_INT 8
8394: PUSH
8395: EMPTY
8396: LIST
8397: LIST
8398: PPUSH
8399: CALL_OW 69
8403: NOT
8404: IFFALSE 8312
// end ;
8406: PPOPN 4
8408: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8409: LD_INT 22
8411: PUSH
8412: LD_INT 2
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: PUSH
8419: LD_INT 34
8421: PUSH
8422: LD_INT 31
8424: PUSH
8425: EMPTY
8426: LIST
8427: LIST
8428: PUSH
8429: LD_INT 3
8431: PUSH
8432: LD_INT 24
8434: PUSH
8435: LD_INT 1000
8437: PUSH
8438: EMPTY
8439: LIST
8440: LIST
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: PPUSH
8451: CALL_OW 69
8455: IFFALSE 8558
8457: GO 8459
8459: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8460: LD_INT 45
8462: PPUSH
8463: CALL_OW 302
8467: PUSH
8468: LD_INT 45
8470: PPUSH
8471: CALL_OW 255
8475: AND
8476: IFFALSE 8519
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8478: LD_INT 22
8480: PUSH
8481: LD_INT 2
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 34
8490: PUSH
8491: LD_INT 31
8493: PUSH
8494: EMPTY
8495: LIST
8496: LIST
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: PPUSH
8502: CALL_OW 69
8506: PPUSH
8507: LD_INT 18
8509: PPUSH
8510: LD_INT 8
8512: PPUSH
8513: CALL_OW 111
8517: GO 8558
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8519: LD_INT 22
8521: PUSH
8522: LD_INT 2
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 34
8531: PUSH
8532: LD_INT 31
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: PPUSH
8543: CALL_OW 69
8547: PPUSH
8548: LD_INT 106
8550: PPUSH
8551: LD_INT 14
8553: PPUSH
8554: CALL_OW 111
// end ; end_of_file
8558: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8559: LD_INT 0
8561: PPUSH
8562: PPUSH
8563: PPUSH
8564: PPUSH
8565: PPUSH
8566: PPUSH
// InGameOn ;
8567: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8571: LD_EXP 21
8575: PPUSH
8576: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8580: LD_INT 2
8582: PPUSH
8583: LD_INT 1
8585: PPUSH
8586: LD_INT 1
8588: PPUSH
8589: LD_INT 1
8591: PPUSH
8592: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8596: LD_ADDR_VAR 0 2
8600: PUSH
8601: LD_INT 22
8603: PUSH
8604: LD_INT 1
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PUSH
8611: LD_INT 25
8613: PUSH
8614: LD_INT 1
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: PPUSH
8625: CALL_OW 69
8629: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8630: LD_ADDR_VAR 0 4
8634: PUSH
8635: LD_INT 22
8637: PUSH
8638: LD_INT 1
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: PUSH
8645: LD_INT 34
8647: PUSH
8648: LD_INT 11
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: PPUSH
8659: CALL_OW 69
8663: PUSH
8664: LD_INT 1
8666: ARRAY
8667: ST_TO_ADDR
// for i = 1 to tmp do
8668: LD_ADDR_VAR 0 6
8672: PUSH
8673: DOUBLE
8674: LD_INT 1
8676: DEC
8677: ST_TO_ADDR
8678: LD_VAR 0 2
8682: PUSH
8683: FOR_TO
8684: IFFALSE 8731
// begin if i = 5 then
8686: LD_VAR 0 6
8690: PUSH
8691: LD_INT 5
8693: EQUAL
8694: IFFALSE 8698
// break ;
8696: GO 8731
// sols := Replace ( sols , i , tmp [ i ] ) ;
8698: LD_ADDR_VAR 0 5
8702: PUSH
8703: LD_VAR 0 5
8707: PPUSH
8708: LD_VAR 0 6
8712: PPUSH
8713: LD_VAR 0 2
8717: PUSH
8718: LD_VAR 0 6
8722: ARRAY
8723: PPUSH
8724: CALL_OW 1
8728: ST_TO_ADDR
// end ;
8729: GO 8683
8731: POP
8732: POP
// tmp := ar_force_tmp ;
8733: LD_ADDR_VAR 0 2
8737: PUSH
8738: LD_EXP 40
8742: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8743: LD_VAR 0 2
8747: PUSH
8748: LD_INT 1
8750: ARRAY
8751: PPUSH
8752: LD_INT 108
8754: PPUSH
8755: LD_INT 139
8757: PPUSH
8758: LD_INT 0
8760: PPUSH
8761: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8765: LD_VAR 0 2
8769: PUSH
8770: LD_INT 1
8772: ARRAY
8773: PPUSH
8774: LD_EXP 21
8778: PPUSH
8779: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8783: LD_VAR 0 2
8787: PUSH
8788: LD_INT 2
8790: ARRAY
8791: PPUSH
8792: LD_INT 114
8794: PPUSH
8795: LD_INT 132
8797: PPUSH
8798: LD_INT 0
8800: PPUSH
8801: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8805: LD_VAR 0 2
8809: PUSH
8810: LD_INT 3
8812: ARRAY
8813: PPUSH
8814: LD_INT 115
8816: PPUSH
8817: LD_INT 132
8819: PPUSH
8820: LD_INT 0
8822: PPUSH
8823: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8827: LD_VAR 0 2
8831: PUSH
8832: LD_INT 2
8834: ARRAY
8835: PUSH
8836: LD_VAR 0 2
8840: PUSH
8841: LD_INT 3
8843: ARRAY
8844: PUSH
8845: EMPTY
8846: LIST
8847: LIST
8848: PPUSH
8849: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_INT 83
8860: PPUSH
8861: LD_INT 123
8863: PPUSH
8864: CALL_OW 111
// Wait ( 0 0$01 ) ;
8868: LD_INT 35
8870: PPUSH
8871: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8875: LD_INT 90
8877: PPUSH
8878: LD_INT 144
8880: PPUSH
8881: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8885: LD_VAR 0 5
8889: PPUSH
8890: LD_INT 88
8892: PPUSH
8893: LD_INT 129
8895: PPUSH
8896: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8900: LD_ADDR_VAR 0 3
8904: PUSH
8905: LD_INT 92
8907: PUSH
8908: LD_INT 131
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: LD_INT 88
8917: PUSH
8918: LD_INT 127
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 91
8927: PUSH
8928: LD_INT 132
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: LD_INT 92
8937: PUSH
8938: LD_INT 134
8940: PUSH
8941: EMPTY
8942: LIST
8943: LIST
8944: PUSH
8945: EMPTY
8946: LIST
8947: LIST
8948: LIST
8949: LIST
8950: ST_TO_ADDR
// for i = 1 to sols do
8951: LD_ADDR_VAR 0 6
8955: PUSH
8956: DOUBLE
8957: LD_INT 1
8959: DEC
8960: ST_TO_ADDR
8961: LD_VAR 0 5
8965: PUSH
8966: FOR_TO
8967: IFFALSE 9040
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8969: LD_VAR 0 5
8973: PUSH
8974: LD_VAR 0 6
8978: ARRAY
8979: PPUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_VAR 0 6
8989: ARRAY
8990: PUSH
8991: LD_INT 1
8993: ARRAY
8994: PPUSH
8995: LD_VAR 0 3
8999: PUSH
9000: LD_VAR 0 6
9004: ARRAY
9005: PUSH
9006: LD_INT 2
9008: ARRAY
9009: PPUSH
9010: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9014: LD_VAR 0 5
9018: PUSH
9019: LD_VAR 0 6
9023: ARRAY
9024: PPUSH
9025: CALL_OW 197
// AddComHold ( sols ) ;
9029: LD_VAR 0 5
9033: PPUSH
9034: CALL_OW 200
// end ;
9038: GO 8966
9040: POP
9041: POP
// repeat wait ( 0 0$1 ) ;
9042: LD_INT 35
9044: PPUSH
9045: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9049: LD_VAR 0 5
9053: PUSH
9054: LD_INT 1
9056: ARRAY
9057: PPUSH
9058: LD_INT 92
9060: PPUSH
9061: LD_INT 131
9063: PPUSH
9064: CALL_OW 297
9068: PUSH
9069: LD_INT 4
9071: LESS
9072: IFFALSE 9042
// CenterOnXY ( 96 , 139 ) ;
9074: LD_INT 96
9076: PPUSH
9077: LD_INT 139
9079: PPUSH
9080: CALL_OW 84
// wait ( 0 0$3 ) ;
9084: LD_INT 105
9086: PPUSH
9087: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9091: LD_INT 111
9093: PPUSH
9094: LD_INT 135
9096: PPUSH
9097: LD_INT 1
9099: PPUSH
9100: LD_INT 25
9102: NEG
9103: PPUSH
9104: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9108: LD_VAR 0 2
9112: PUSH
9113: LD_INT 2
9115: ARRAY
9116: PPUSH
9117: LD_VAR 0 2
9121: PUSH
9122: LD_INT 1
9124: ARRAY
9125: PPUSH
9126: CALL_OW 250
9130: PUSH
9131: LD_INT 3
9133: PLUS
9134: PPUSH
9135: LD_VAR 0 2
9139: PUSH
9140: LD_INT 1
9142: ARRAY
9143: PPUSH
9144: CALL_OW 251
9148: PPUSH
9149: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9153: LD_VAR 0 2
9157: PUSH
9158: LD_INT 3
9160: ARRAY
9161: PPUSH
9162: LD_INT 7
9164: PPUSH
9165: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9169: LD_VAR 0 2
9173: PUSH
9174: LD_INT 2
9176: ARRAY
9177: PPUSH
9178: LD_VAR 0 2
9182: PUSH
9183: LD_INT 1
9185: ARRAY
9186: PPUSH
9187: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9191: LD_INT 35
9193: PPUSH
9194: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9198: LD_VAR 0 2
9202: PUSH
9203: LD_INT 1
9205: ARRAY
9206: PPUSH
9207: LD_VAR 0 2
9211: PUSH
9212: LD_INT 2
9214: ARRAY
9215: PPUSH
9216: CALL_OW 296
9220: PUSH
9221: LD_INT 5
9223: LESS
9224: IFFALSE 9191
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9226: LD_VAR 0 2
9230: PUSH
9231: LD_INT 1
9233: ARRAY
9234: PPUSH
9235: LD_VAR 0 2
9239: PUSH
9240: LD_INT 2
9242: ARRAY
9243: PPUSH
9244: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9248: LD_VAR 0 2
9252: PUSH
9253: LD_INT 1
9255: ARRAY
9256: PPUSH
9257: LD_STRING D1a-Merc1-1
9259: PPUSH
9260: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9264: LD_VAR 0 2
9268: PUSH
9269: LD_INT 2
9271: ARRAY
9272: PPUSH
9273: LD_STRING D1a-FMerc2-1
9275: PPUSH
9276: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9280: LD_VAR 0 2
9284: PUSH
9285: LD_INT 2
9287: ARRAY
9288: PPUSH
9289: LD_VAR 0 2
9293: PUSH
9294: LD_INT 1
9296: ARRAY
9297: PPUSH
9298: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9302: LD_VAR 0 2
9306: PUSH
9307: LD_INT 1
9309: ARRAY
9310: PPUSH
9311: LD_INT 500
9313: PPUSH
9314: CALL_OW 234
// wait ( 0 0$2 ) ;
9318: LD_INT 70
9320: PPUSH
9321: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9325: LD_VAR 0 2
9329: PUSH
9330: LD_INT 1
9332: ARRAY
9333: PPUSH
9334: LD_INT 2
9336: PPUSH
9337: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9341: LD_INT 10
9343: PPUSH
9344: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9348: LD_VAR 0 2
9352: PUSH
9353: LD_INT 1
9355: ARRAY
9356: PPUSH
9357: LD_STRING D1a-Merc1-2
9359: PPUSH
9360: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9364: LD_INT 7
9366: PPUSH
9367: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9371: LD_VAR 0 2
9375: PUSH
9376: LD_INT 1
9378: ARRAY
9379: PPUSH
9380: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9384: LD_VAR 0 2
9388: PUSH
9389: LD_INT 2
9391: ARRAY
9392: PPUSH
9393: LD_INT 10
9395: PPUSH
9396: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9400: LD_VAR 0 2
9404: PUSH
9405: LD_INT 2
9407: ARRAY
9408: PPUSH
9409: LD_STRING D1a-FMerc2-2
9411: PPUSH
9412: CALL_OW 88
// wait ( 0 0$1 ) ;
9416: LD_INT 35
9418: PPUSH
9419: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9423: LD_INT 7
9425: PPUSH
9426: CALL_OW 85
// wait ( 0 0$2 ) ;
9430: LD_INT 70
9432: PPUSH
9433: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9437: LD_EXP 44
9441: PPUSH
9442: LD_STRING D1a-Saliba-1
9444: PPUSH
9445: CALL_OW 91
// KillUnit ( Saliba ) ;
9449: LD_EXP 44
9453: PPUSH
9454: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9458: LD_VAR 0 2
9462: PUSH
9463: LD_INT 3
9465: ARRAY
9466: PPUSH
9467: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9471: LD_EXP 21
9475: PPUSH
9476: CALL_OW 85
// wait ( 0 0$1 ) ;
9480: LD_INT 35
9482: PPUSH
9483: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9487: LD_VAR 0 5
9491: PPUSH
9492: LD_INT 88
9494: PPUSH
9495: LD_INT 141
9497: PPUSH
9498: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9502: LD_VAR 0 5
9506: PPUSH
9507: LD_INT 70
9509: PPUSH
9510: CALL_OW 202
// wait ( 0 0$2 ) ;
9514: LD_INT 70
9516: PPUSH
9517: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9521: LD_INT 2
9523: PPUSH
9524: LD_INT 1
9526: PPUSH
9527: LD_INT 2
9529: PPUSH
9530: LD_INT 1
9532: PPUSH
9533: CALL_OW 80
// InGameOff ;
9537: CALL_OW 9
// ComWalk ( sols ) ;
9541: LD_VAR 0 5
9545: PPUSH
9546: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9550: LD_STRING M1
9552: PPUSH
9553: CALL_OW 337
// game_speed := 4 ;
9557: LD_ADDR_OWVAR 65
9561: PUSH
9562: LD_INT 4
9564: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9565: LD_INT 111
9567: PPUSH
9568: LD_INT 135
9570: PPUSH
9571: LD_INT 1
9573: PPUSH
9574: CALL_OW 331
// SaveForQuickRestart ;
9578: CALL_OW 22
// ar_run := true ;
9582: LD_ADDR_EXP 5
9586: PUSH
9587: LD_INT 1
9589: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9590: LD_INT 35
9592: PPUSH
9593: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9597: LD_INT 22
9599: PUSH
9600: LD_INT 1
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PUSH
9607: LD_INT 91
9609: PUSH
9610: LD_INT 7
9612: PUSH
9613: LD_INT 10
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: LIST
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: PPUSH
9625: CALL_OW 69
9629: PUSH
9630: LD_INT 7
9632: PPUSH
9633: CALL_OW 256
9637: PUSH
9638: LD_INT 999
9640: LESS
9641: OR
9642: IFFALSE 9590
// if GetSide ( ar_dep_s ) = 2 then
9644: LD_INT 7
9646: PPUSH
9647: CALL_OW 255
9651: PUSH
9652: LD_INT 2
9654: EQUAL
9655: IFFALSE 9667
// SetSide ( ar_dep_s , 1 ) ;
9657: LD_INT 7
9659: PPUSH
9660: LD_INT 1
9662: PPUSH
9663: CALL_OW 235
// end ;
9667: LD_VAR 0 1
9671: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9672: LD_EXP 5
9676: IFFALSE 10036
9678: GO 9680
9680: DISABLE
9681: LD_INT 0
9683: PPUSH
9684: PPUSH
9685: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9686: LD_ADDR_VAR 0 2
9690: PUSH
9691: LD_EXP 40
9695: PUSH
9696: LD_EXP 36
9700: PPUSH
9701: LD_INT 2
9703: PUSH
9704: LD_INT 21
9706: PUSH
9707: LD_INT 2
9709: PUSH
9710: EMPTY
9711: LIST
9712: LIST
9713: PUSH
9714: LD_INT 21
9716: PUSH
9717: LD_INT 1
9719: PUSH
9720: EMPTY
9721: LIST
9722: LIST
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: LIST
9728: PPUSH
9729: CALL_OW 72
9733: ADD
9734: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9735: LD_VAR 0 2
9739: PPUSH
9740: LD_INT 5
9742: PPUSH
9743: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9747: LD_INT 5
9749: PPUSH
9750: LD_INT 1
9752: PPUSH
9753: CALL_OW 343
// k := 1 ;
9757: LD_ADDR_VAR 0 3
9761: PUSH
9762: LD_INT 1
9764: ST_TO_ADDR
// for i in tmp do
9765: LD_ADDR_VAR 0 1
9769: PUSH
9770: LD_VAR 0 2
9774: PUSH
9775: FOR_IN
9776: IFFALSE 9861
// begin if IsInUnit ( i ) then
9778: LD_VAR 0 1
9782: PPUSH
9783: CALL_OW 310
9787: IFFALSE 9798
// ComExitBuilding ( i ) ;
9789: LD_VAR 0 1
9793: PPUSH
9794: CALL_OW 122
// if GetClass ( i ) = 3 then
9798: LD_VAR 0 1
9802: PPUSH
9803: CALL_OW 257
9807: PUSH
9808: LD_INT 3
9810: EQUAL
9811: IFFALSE 9847
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9813: LD_VAR 0 1
9817: PPUSH
9818: LD_EXP 41
9822: PUSH
9823: LD_VAR 0 3
9827: ARRAY
9828: PPUSH
9829: CALL_OW 180
// k := k + 1 ;
9833: LD_ADDR_VAR 0 3
9837: PUSH
9838: LD_VAR 0 3
9842: PUSH
9843: LD_INT 1
9845: PLUS
9846: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9847: LD_VAR 0 1
9851: PPUSH
9852: LD_INT 10
9854: PPUSH
9855: CALL_OW 173
// end ;
9859: GO 9775
9861: POP
9862: POP
// ar_patrol := true ;
9863: LD_ADDR_EXP 7
9867: PUSH
9868: LD_INT 1
9870: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9871: LD_INT 10
9873: PPUSH
9874: CALL_OW 67
// for i in tmp do
9878: LD_ADDR_VAR 0 1
9882: PUSH
9883: LD_VAR 0 2
9887: PUSH
9888: FOR_IN
9889: IFFALSE 9917
// if not HasTask ( i ) then
9891: LD_VAR 0 1
9895: PPUSH
9896: CALL_OW 314
9900: NOT
9901: IFFALSE 9915
// ComMoveToArea ( i , escape_area ) ;
9903: LD_VAR 0 1
9907: PPUSH
9908: LD_INT 10
9910: PPUSH
9911: CALL_OW 113
9915: GO 9888
9917: POP
9918: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9919: LD_ADDR_VAR 0 3
9923: PUSH
9924: LD_VAR 0 2
9928: PPUSH
9929: LD_INT 95
9931: PUSH
9932: LD_INT 10
9934: PUSH
9935: EMPTY
9936: LIST
9937: LIST
9938: PPUSH
9939: CALL_OW 72
9943: ST_TO_ADDR
// if k then
9944: LD_VAR 0 3
9948: IFFALSE 10017
// for i in k do
9950: LD_ADDR_VAR 0 1
9954: PUSH
9955: LD_VAR 0 3
9959: PUSH
9960: FOR_IN
9961: IFFALSE 10015
// begin if IsInUnit ( i ) then
9963: LD_VAR 0 1
9967: PPUSH
9968: CALL_OW 310
9972: IFFALSE 9988
// RemoveUnit ( IsInUnit ( i ) ) ;
9974: LD_VAR 0 1
9978: PPUSH
9979: CALL_OW 310
9983: PPUSH
9984: CALL_OW 64
// RemoveUnit ( i ) ;
9988: LD_VAR 0 1
9992: PPUSH
9993: CALL_OW 64
// tmp := tmp diff i ;
9997: LD_ADDR_VAR 0 2
10001: PUSH
10002: LD_VAR 0 2
10006: PUSH
10007: LD_VAR 0 1
10011: DIFF
10012: ST_TO_ADDR
// end ;
10013: GO 9960
10015: POP
10016: POP
// until tmp = [ ] ;
10017: LD_VAR 0 2
10021: PUSH
10022: EMPTY
10023: EQUAL
10024: IFFALSE 9871
// ChangeSideFog ( 5 , 5 ) ;
10026: LD_INT 5
10028: PPUSH
10029: LD_INT 5
10031: PPUSH
10032: CALL_OW 343
// end ;
10036: PPOPN 3
10038: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10039: LD_EXP 7
10043: IFFALSE 10333
10045: GO 10047
10047: DISABLE
10048: LD_INT 0
10050: PPUSH
10051: PPUSH
10052: PPUSH
// begin uc_side := 2 ;
10053: LD_ADDR_OWVAR 20
10057: PUSH
10058: LD_INT 2
10060: ST_TO_ADDR
// uc_nation := 2 ;
10061: LD_ADDR_OWVAR 21
10065: PUSH
10066: LD_INT 2
10068: ST_TO_ADDR
// InitHc ;
10069: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10073: LD_INT 1
10075: PPUSH
10076: LD_INT 1
10078: PPUSH
10079: LD_INT 6
10081: PPUSH
10082: CALL_OW 380
// un := CreateHuman ;
10086: LD_ADDR_VAR 0 2
10090: PUSH
10091: CALL_OW 44
10095: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10096: LD_INT 14
10098: PPUSH
10099: LD_INT 1
10101: PPUSH
10102: LD_INT 1
10104: PPUSH
10105: LD_INT 27
10107: PPUSH
10108: LD_INT 98
10110: PPUSH
10111: CALL 53419 0 5
// veh := CreateVehicle ;
10115: LD_ADDR_VAR 0 3
10119: PUSH
10120: CALL_OW 45
10124: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10125: LD_VAR 0 3
10129: PPUSH
10130: LD_INT 4
10132: PPUSH
10133: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10137: LD_VAR 0 3
10141: PPUSH
10142: LD_INT 179
10144: PPUSH
10145: LD_INT 135
10147: PPUSH
10148: LD_INT 0
10150: PPUSH
10151: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10155: LD_VAR 0 2
10159: PPUSH
10160: LD_VAR 0 3
10164: PPUSH
10165: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10169: LD_VAR 0 2
10173: PPUSH
10174: LD_INT 126
10176: PPUSH
10177: LD_INT 133
10179: PPUSH
10180: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10184: LD_INT 10
10186: PPUSH
10187: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10191: LD_INT 1
10193: PPUSH
10194: LD_VAR 0 3
10198: PPUSH
10199: CALL_OW 292
10203: PUSH
10204: LD_VAR 0 3
10208: PPUSH
10209: LD_INT 7
10211: PPUSH
10212: CALL_OW 296
10216: PUSH
10217: LD_INT 9
10219: LESS
10220: OR
10221: IFFALSE 10184
// ComHold ( veh ) ;
10223: LD_VAR 0 3
10227: PPUSH
10228: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10232: LD_VAR 0 2
10236: PPUSH
10237: LD_STRING D2aa-Ar1-1
10239: PPUSH
10240: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10244: LD_VAR 0 2
10248: PPUSH
10249: LD_INT 177
10251: PPUSH
10252: LD_INT 96
10254: PPUSH
10255: CALL_OW 111
// AddComExitVehicle ( un ) ;
10259: LD_VAR 0 2
10263: PPUSH
10264: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10268: LD_INT 35
10270: PPUSH
10271: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10275: LD_VAR 0 2
10279: PPUSH
10280: LD_INT 204
10282: PPUSH
10283: CALL_OW 296
10287: PUSH
10288: LD_INT 15
10290: LESS
10291: IFFALSE 10268
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10293: LD_ADDR_EXP 50
10297: PUSH
10298: LD_EXP 50
10302: PPUSH
10303: LD_INT 3
10305: PUSH
10306: LD_EXP 50
10310: PUSH
10311: LD_INT 3
10313: ARRAY
10314: PUSH
10315: LD_INT 1
10317: PLUS
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: PPUSH
10323: LD_VAR 0 2
10327: PPUSH
10328: CALL 53541 0 3
10332: ST_TO_ADDR
// end ;
10333: PPOPN 3
10335: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10336: LD_INT 7
10338: PPUSH
10339: CALL_OW 255
10343: PUSH
10344: LD_INT 1
10346: EQUAL
10347: PUSH
10348: LD_INT 7
10350: PPUSH
10351: CALL_OW 301
10355: OR
10356: IFFALSE 12764
10358: GO 10360
10360: DISABLE
10361: LD_INT 0
10363: PPUSH
10364: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10365: LD_ADDR_VAR 0 1
10369: PUSH
10370: LD_EXP 36
10374: PPUSH
10375: LD_INT 21
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: EMPTY
10382: LIST
10383: LIST
10384: PPUSH
10385: CALL_OW 72
10389: PUSH
10390: FOR_IN
10391: IFFALSE 10407
// SetSide ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 235
10405: GO 10390
10407: POP
10408: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10409: LD_ADDR_VAR 0 2
10413: PUSH
10414: LD_INT 46
10416: PUSH
10417: LD_INT 41
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: PUSH
10424: LD_INT 50
10426: PUSH
10427: LD_INT 25
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: PUSH
10434: LD_INT 57
10436: PUSH
10437: LD_INT 75
10439: PUSH
10440: EMPTY
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 75
10446: PUSH
10447: LD_INT 89
10449: PUSH
10450: EMPTY
10451: LIST
10452: LIST
10453: PUSH
10454: LD_INT 51
10456: PUSH
10457: LD_INT 45
10459: PUSH
10460: EMPTY
10461: LIST
10462: LIST
10463: PUSH
10464: LD_INT 95
10466: PUSH
10467: LD_INT 95
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: PUSH
10474: LD_INT 84
10476: PUSH
10477: LD_INT 77
10479: PUSH
10480: EMPTY
10481: LIST
10482: LIST
10483: PUSH
10484: LD_INT 101
10486: PUSH
10487: LD_INT 76
10489: PUSH
10490: EMPTY
10491: LIST
10492: LIST
10493: PUSH
10494: LD_INT 118
10496: PUSH
10497: LD_INT 81
10499: PUSH
10500: EMPTY
10501: LIST
10502: LIST
10503: PUSH
10504: LD_INT 139
10506: PUSH
10507: LD_INT 97
10509: PUSH
10510: EMPTY
10511: LIST
10512: LIST
10513: PUSH
10514: LD_INT 129
10516: PUSH
10517: LD_INT 114
10519: PUSH
10520: EMPTY
10521: LIST
10522: LIST
10523: PUSH
10524: LD_INT 154
10526: PUSH
10527: LD_INT 111
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PUSH
10534: EMPTY
10535: LIST
10536: LIST
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: ST_TO_ADDR
// base_captured := true ;
10548: LD_ADDR_EXP 6
10552: PUSH
10553: LD_INT 1
10555: ST_TO_ADDR
// DialogueOn ;
10556: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10560: LD_EXP 21
10564: PPUSH
10565: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10569: LD_EXP 21
10573: PPUSH
10574: LD_STRING D2-JMM-1
10576: PPUSH
10577: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10581: LD_EXP 30
10585: PPUSH
10586: LD_STRING D2-Pow-1
10588: PPUSH
10589: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10593: LD_EXP 21
10597: PPUSH
10598: LD_STRING D2-JMM-2
10600: PPUSH
10601: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10605: LD_EXP 30
10609: PPUSH
10610: LD_STRING D2-Pow-2
10612: PPUSH
10613: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10617: LD_EXP 21
10621: PPUSH
10622: LD_STRING D2-JMM-3
10624: PPUSH
10625: CALL_OW 88
// DialogueOff ;
10629: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10633: LD_STRING M2
10635: PPUSH
10636: CALL_OW 337
// Wait ( 0 0$2 ) ;
10640: LD_INT 70
10642: PPUSH
10643: CALL_OW 67
// if IsOk ( Gary ) then
10647: LD_EXP 32
10651: PPUSH
10652: CALL_OW 302
10656: IFFALSE 10670
// Say ( Gary , D2a-Gary-1 ) ;
10658: LD_EXP 32
10662: PPUSH
10663: LD_STRING D2a-Gary-1
10665: PPUSH
10666: CALL_OW 88
// if IsOk ( Bobby ) then
10670: LD_EXP 24
10674: PPUSH
10675: CALL_OW 302
10679: IFFALSE 10693
// Say ( Bobby , D2a-Bobby-1 ) ;
10681: LD_EXP 24
10685: PPUSH
10686: LD_STRING D2a-Bobby-1
10688: PPUSH
10689: CALL_OW 88
// if IsOk ( Cyrus ) then
10693: LD_EXP 25
10697: PPUSH
10698: CALL_OW 302
10702: IFFALSE 10716
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10704: LD_EXP 25
10708: PPUSH
10709: LD_STRING D2a-Cyrus-1
10711: PPUSH
10712: CALL_OW 88
// if IsOk ( Lisa ) then
10716: LD_EXP 22
10720: PPUSH
10721: CALL_OW 302
10725: IFFALSE 10739
// Say ( Lisa , D2a-Lisa-1 ) ;
10727: LD_EXP 22
10731: PPUSH
10732: LD_STRING D2a-Lisa-1
10734: PPUSH
10735: CALL_OW 88
// if IsOk ( Frank ) then
10739: LD_EXP 33
10743: PPUSH
10744: CALL_OW 302
10748: IFFALSE 10762
// Say ( Frank , D2a-Frank-1 ) ;
10750: LD_EXP 33
10754: PPUSH
10755: LD_STRING D2a-Frank-1
10757: PPUSH
10758: CALL_OW 88
// if IsOk ( Cornel ) then
10762: LD_EXP 31
10766: PPUSH
10767: CALL_OW 302
10771: IFFALSE 10785
// Say ( Cornel , D2a-Corn-1 ) ;
10773: LD_EXP 31
10777: PPUSH
10778: LD_STRING D2a-Corn-1
10780: PPUSH
10781: CALL_OW 88
// if IsOk ( Donaldson ) then
10785: LD_EXP 23
10789: PPUSH
10790: CALL_OW 302
10794: IFFALSE 10808
// Say ( Donaldson , D2a-Don-1 ) ;
10796: LD_EXP 23
10800: PPUSH
10801: LD_STRING D2a-Don-1
10803: PPUSH
10804: CALL_OW 88
// if IsOk ( Brown ) then
10808: LD_EXP 27
10812: PPUSH
10813: CALL_OW 302
10817: IFFALSE 10831
// Say ( Brown , D2a-Brown-1 ) ;
10819: LD_EXP 27
10823: PPUSH
10824: LD_STRING D2a-Brown-1
10826: PPUSH
10827: CALL_OW 88
// Wait ( 0 0$30 ) ;
10831: LD_INT 1050
10833: PPUSH
10834: CALL_OW 67
// if IsOk ( Frank ) then
10838: LD_EXP 33
10842: PPUSH
10843: CALL_OW 302
10847: IFFALSE 11113
// begin DialogueOn ;
10849: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10853: LD_EXP 21
10857: PUSH
10858: LD_EXP 33
10862: PUSH
10863: EMPTY
10864: LIST
10865: LIST
10866: PPUSH
10867: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10871: LD_EXP 33
10875: PPUSH
10876: LD_STRING D3F-Frank-1
10878: PPUSH
10879: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10883: LD_EXP 21
10887: PPUSH
10888: LD_STRING D3F-JMM-1
10890: PPUSH
10891: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10895: LD_EXP 33
10899: PPUSH
10900: LD_STRING D3F-Frank-2
10902: PPUSH
10903: CALL_OW 88
// case Query ( QFrank ) of 1 :
10907: LD_STRING QFrank
10909: PPUSH
10910: CALL_OW 97
10914: PUSH
10915: LD_INT 1
10917: DOUBLE
10918: EQUAL
10919: IFTRUE 10923
10921: GO 10946
10923: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10924: LD_EXP 21
10928: PPUSH
10929: LD_STRING D3Fa-JMM-1
10931: PPUSH
10932: CALL_OW 88
// us_scout := 1 ;
10936: LD_ADDR_EXP 8
10940: PUSH
10941: LD_INT 1
10943: ST_TO_ADDR
// end ; 2 :
10944: GO 11109
10946: LD_INT 2
10948: DOUBLE
10949: EQUAL
10950: IFTRUE 10954
10952: GO 11076
10954: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10955: LD_EXP 21
10959: PPUSH
10960: LD_STRING D3Fb-JMM-1
10962: PPUSH
10963: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10967: LD_EXP 33
10971: PPUSH
10972: LD_STRING D3Fb-Frank-1
10974: PPUSH
10975: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10979: LD_STRING QFrank2
10981: PPUSH
10982: CALL_OW 97
10986: PUSH
10987: LD_INT 1
10989: DOUBLE
10990: EQUAL
10991: IFTRUE 10995
10993: GO 11042
10995: POP
// begin us_scout := 2 ;
10996: LD_ADDR_EXP 8
11000: PUSH
11001: LD_INT 2
11003: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11004: LD_EXP 21
11008: PPUSH
11009: LD_STRING D3Fba-JMM-1
11011: PPUSH
11012: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11016: LD_EXP 33
11020: PPUSH
11021: LD_STRING D3Fba-Frank-1
11023: PPUSH
11024: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11028: LD_EXP 21
11032: PPUSH
11033: LD_STRING D3Fba-JMM-2
11035: PPUSH
11036: CALL_OW 88
// end ; 2 :
11040: GO 11074
11042: LD_INT 2
11044: DOUBLE
11045: EQUAL
11046: IFTRUE 11050
11048: GO 11073
11050: POP
// begin us_scout := 0 ;
11051: LD_ADDR_EXP 8
11055: PUSH
11056: LD_INT 0
11058: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11059: LD_EXP 21
11063: PPUSH
11064: LD_STRING D3Fbb-JMM-1
11066: PPUSH
11067: CALL_OW 88
// end ; end ;
11071: GO 11074
11073: POP
// end ; 3 :
11074: GO 11109
11076: LD_INT 3
11078: DOUBLE
11079: EQUAL
11080: IFTRUE 11084
11082: GO 11108
11084: POP
// begin us_scout := - 1 ;
11085: LD_ADDR_EXP 8
11089: PUSH
11090: LD_INT 1
11092: NEG
11093: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11094: LD_EXP 21
11098: PPUSH
11099: LD_STRING D3Fc-JMM-1
11101: PPUSH
11102: CALL_OW 88
// end ; end ;
11106: GO 11109
11108: POP
// DialogueOff ;
11109: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
11113: LD_EXP 8
11117: PUSH
11118: LD_INT 1
11120: NEG
11121: PUSH
11122: LD_INT 0
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: IN
11129: IFFALSE 11133
// exit ;
11131: GO 12764
// if us_scout in [ 1 , 2 ] then
11133: LD_EXP 8
11137: PUSH
11138: LD_INT 1
11140: PUSH
11141: LD_INT 2
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: IN
11148: IFFALSE 11827
// begin if IsInUnit ( Frank ) then
11150: LD_EXP 33
11154: PPUSH
11155: CALL_OW 310
11159: IFFALSE 11170
// ComExit ( Frank ) ;
11161: LD_EXP 33
11165: PPUSH
11166: CALL 85680 0 1
// SetSide ( Frank , 4 ) ;
11170: LD_EXP 33
11174: PPUSH
11175: LD_INT 4
11177: PPUSH
11178: CALL_OW 235
// wait ( 0 0$1 ) ;
11182: LD_INT 35
11184: PPUSH
11185: CALL_OW 67
// if us_scout = 2 then
11189: LD_EXP 8
11193: PUSH
11194: LD_INT 2
11196: EQUAL
11197: IFFALSE 11565
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11199: LD_EXP 33
11203: PPUSH
11204: LD_INT 75
11206: PPUSH
11207: LD_INT 63
11209: PPUSH
11210: CALL_OW 111
// AddComHold ( Frank ) ;
11214: LD_EXP 33
11218: PPUSH
11219: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11223: LD_EXP 33
11227: PPUSH
11228: LD_INT 770
11230: PPUSH
11231: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11235: LD_EXP 33
11239: PPUSH
11240: LD_INT 100
11242: PPUSH
11243: LD_INT 75
11245: PPUSH
11246: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11250: LD_EXP 33
11254: PPUSH
11255: LD_INT 123
11257: PPUSH
11258: LD_INT 103
11260: PPUSH
11261: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11265: LD_EXP 33
11269: PPUSH
11270: LD_INT 138
11272: PPUSH
11273: LD_INT 108
11275: PPUSH
11276: CALL_OW 171
// AddComHold ( Frank ) ;
11280: LD_EXP 33
11284: PPUSH
11285: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11289: LD_INT 35
11291: PPUSH
11292: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11296: LD_EXP 33
11300: PPUSH
11301: LD_INT 138
11303: PPUSH
11304: LD_INT 108
11306: PPUSH
11307: CALL_OW 307
11311: IFFALSE 11289
// AddComMoveXY ( Frank , 125 , 132 ) ;
11313: LD_EXP 33
11317: PPUSH
11318: LD_INT 125
11320: PPUSH
11321: LD_INT 132
11323: PPUSH
11324: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11328: LD_INT 35
11330: PPUSH
11331: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11335: LD_INT 1
11337: PPUSH
11338: LD_EXP 33
11342: PPUSH
11343: CALL_OW 292
11347: PUSH
11348: LD_EXP 33
11352: PPUSH
11353: LD_INT 7
11355: PPUSH
11356: CALL_OW 296
11360: PUSH
11361: LD_INT 7
11363: LESS
11364: OR
11365: IFFALSE 11328
// DialogueOn ;
11367: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11371: LD_EXP 33
11375: PPUSH
11376: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11380: LD_INT 10
11382: PPUSH
11383: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11387: LD_EXP 21
11391: PPUSH
11392: LD_STRING D4Fa-JMM-1
11394: PPUSH
11395: CALL_OW 88
// for i in points do
11399: LD_ADDR_VAR 0 1
11403: PUSH
11404: LD_VAR 0 2
11408: PUSH
11409: FOR_IN
11410: IFFALSE 11468
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11412: LD_VAR 0 1
11416: PUSH
11417: LD_INT 1
11419: ARRAY
11420: PPUSH
11421: LD_VAR 0 1
11425: PUSH
11426: LD_INT 2
11428: ARRAY
11429: PPUSH
11430: LD_INT 1
11432: PPUSH
11433: LD_INT 20
11435: NEG
11436: PPUSH
11437: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11441: LD_VAR 0 1
11445: PUSH
11446: LD_INT 1
11448: ARRAY
11449: PPUSH
11450: LD_VAR 0 1
11454: PUSH
11455: LD_INT 2
11457: ARRAY
11458: PPUSH
11459: LD_INT 1
11461: PPUSH
11462: CALL_OW 331
// end ;
11466: GO 11409
11468: POP
11469: POP
// dwait ( 0 0$0.5 ) ;
11470: LD_INT 18
11472: PPUSH
11473: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11477: LD_INT 42
11479: PPUSH
11480: LD_INT 27
11482: PPUSH
11483: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11487: LD_EXP 33
11491: PPUSH
11492: LD_STRING D4Fa-Frank-1
11494: PPUSH
11495: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11499: LD_INT 18
11501: PPUSH
11502: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11506: LD_EXP 21
11510: PPUSH
11511: LD_STRING D4Fa-JMM-2
11513: PPUSH
11514: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11518: LD_INT 118
11520: PPUSH
11521: LD_INT 80
11523: PPUSH
11524: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11528: LD_EXP 33
11532: PPUSH
11533: LD_STRING D4Fa-Frank-2
11535: PPUSH
11536: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11540: LD_INT 10
11542: PPUSH
11543: CALL_OW 68
// DialogueOff ;
11547: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11551: LD_EXP 33
11555: PPUSH
11556: LD_INT 1
11558: PPUSH
11559: CALL_OW 235
// end else
11563: GO 11827
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11565: LD_INT 2
11567: PPUSH
11568: LD_INT 4
11570: PPUSH
11571: LD_INT 2
11573: PPUSH
11574: LD_INT 1
11576: PPUSH
11577: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11581: LD_EXP 33
11585: PPUSH
11586: LD_INT 75
11588: PPUSH
11589: LD_INT 63
11591: PPUSH
11592: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11596: LD_EXP 33
11600: PPUSH
11601: LD_INT 175
11603: PPUSH
11604: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11608: LD_EXP 33
11612: PPUSH
11613: LD_INT 102
11615: PPUSH
11616: LD_INT 76
11618: PPUSH
11619: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11623: LD_EXP 33
11627: PPUSH
11628: LD_INT 108
11630: PPUSH
11631: LD_INT 70
11633: PPUSH
11634: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11638: LD_INT 35
11640: PPUSH
11641: CALL_OW 67
// until See ( 2 , Frank ) ;
11645: LD_INT 2
11647: PPUSH
11648: LD_EXP 33
11652: PPUSH
11653: CALL_OW 292
11657: IFFALSE 11638
// ComMoveXY ( Frank , 112 , 118 ) ;
11659: LD_EXP 33
11663: PPUSH
11664: LD_INT 112
11666: PPUSH
11667: LD_INT 118
11669: PPUSH
11670: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11674: LD_EXP 33
11678: PPUSH
11679: CALL_OW 256
11683: PUSH
11684: LD_INT 750
11686: GREATEREQUAL
11687: IFFALSE 11701
// SetLives ( Frank , 700 ) ;
11689: LD_EXP 33
11693: PPUSH
11694: LD_INT 700
11696: PPUSH
11697: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11701: LD_INT 35
11703: PPUSH
11704: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11708: LD_INT 1
11710: PPUSH
11711: LD_EXP 33
11715: PPUSH
11716: CALL_OW 292
11720: PUSH
11721: LD_EXP 33
11725: PPUSH
11726: LD_INT 7
11728: PPUSH
11729: CALL_OW 296
11733: PUSH
11734: LD_INT 17
11736: LESS
11737: OR
11738: IFFALSE 11701
// DialogueOn ;
11740: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11744: LD_EXP 33
11748: PPUSH
11749: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11753: LD_EXP 33
11757: PPUSH
11758: LD_STRING D4Fb-Frank-1
11760: PPUSH
11761: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11765: LD_EXP 21
11769: PPUSH
11770: LD_STRING D4Fb-JMM-1
11772: PPUSH
11773: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11777: LD_INT 2
11779: PPUSH
11780: LD_STRING D4Fb-FSci1-1
11782: PPUSH
11783: CALL 16687 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11787: LD_EXP 33
11791: PPUSH
11792: LD_STRING D4Fb-Frank-2
11794: PPUSH
11795: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11799: LD_EXP 21
11803: PPUSH
11804: LD_STRING D4Fb-JMM-2
11806: PPUSH
11807: CALL_OW 88
// DialogueOff ;
11811: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11815: LD_EXP 33
11819: PPUSH
11820: LD_INT 1
11822: PPUSH
11823: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11827: LD_EXP 34
11831: PPUSH
11832: CALL_OW 302
11836: PUSH
11837: LD_EXP 33
11841: NOT
11842: AND
11843: IFFALSE 11991
// begin DialogueOn ;
11845: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11849: LD_EXP 21
11853: PUSH
11854: LD_EXP 34
11858: PUSH
11859: EMPTY
11860: LIST
11861: LIST
11862: PPUSH
11863: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11867: LD_EXP 34
11871: PPUSH
11872: LD_STRING D3Y-Yam-1
11874: PPUSH
11875: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11879: LD_EXP 21
11883: PPUSH
11884: LD_STRING D3Y-JMM-1
11886: PPUSH
11887: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11891: LD_EXP 34
11895: PPUSH
11896: LD_STRING D3Y-Yam-2
11898: PPUSH
11899: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11903: LD_STRING QYamoko
11905: PPUSH
11906: CALL_OW 97
11910: PUSH
11911: LD_INT 1
11913: DOUBLE
11914: EQUAL
11915: IFTRUE 11919
11917: GO 11954
11919: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11920: LD_EXP 21
11924: PPUSH
11925: LD_STRING D3Ya-JMM-1
11927: PPUSH
11928: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11932: LD_EXP 34
11936: PPUSH
11937: LD_STRING D3Ya-Yam-1
11939: PPUSH
11940: CALL_OW 88
// us_scout := 1 ;
11944: LD_ADDR_EXP 8
11948: PUSH
11949: LD_INT 1
11951: ST_TO_ADDR
// end ; 2 :
11952: GO 11987
11954: LD_INT 2
11956: DOUBLE
11957: EQUAL
11958: IFTRUE 11962
11960: GO 11986
11962: POP
// begin us_scout := - 1 ;
11963: LD_ADDR_EXP 8
11967: PUSH
11968: LD_INT 1
11970: NEG
11971: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11972: LD_EXP 21
11976: PPUSH
11977: LD_STRING D3Yb-JMM-1
11979: PPUSH
11980: CALL_OW 88
// end ; end ;
11984: GO 11987
11986: POP
// DialogueOff ;
11987: CALL_OW 7
// end ; if Frank then
11991: LD_EXP 33
11995: IFFALSE 11999
// exit ;
11997: GO 12764
// if us_scout in [ - 1 , 0 ] then
11999: LD_EXP 8
12003: PUSH
12004: LD_INT 1
12006: NEG
12007: PUSH
12008: LD_INT 0
12010: PUSH
12011: EMPTY
12012: LIST
12013: LIST
12014: IN
12015: IFFALSE 12019
// exit ;
12017: GO 12764
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12019: LD_ADDR_EXP 8
12023: PUSH
12024: LD_INT 2
12026: PUSH
12027: LD_INT 2
12029: PUSH
12030: LD_INT 1
12032: PUSH
12033: LD_INT 1
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: LIST
12040: LIST
12041: PUSH
12042: LD_OWVAR 67
12046: ARRAY
12047: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12048: LD_EXP 8
12052: PUSH
12053: LD_INT 1
12055: PUSH
12056: LD_INT 2
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: IN
12063: IFFALSE 12764
// begin if IsInUnit ( Kikuchi ) then
12065: LD_EXP 34
12069: PPUSH
12070: CALL_OW 310
12074: IFFALSE 12085
// ComExitBuilding ( Kikuchi ) ;
12076: LD_EXP 34
12080: PPUSH
12081: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12085: LD_EXP 34
12089: PPUSH
12090: CALL_OW 311
12094: IFFALSE 12105
// ComExitVehicle ( Kikuchi ) ;
12096: LD_EXP 34
12100: PPUSH
12101: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12105: LD_EXP 34
12109: PPUSH
12110: LD_INT 4
12112: PPUSH
12113: CALL_OW 235
// wait ( 0 0$1 ) ;
12117: LD_INT 35
12119: PPUSH
12120: CALL_OW 67
// if us_scout = 2 then
12124: LD_EXP 8
12128: PUSH
12129: LD_INT 2
12131: EQUAL
12132: IFFALSE 12512
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12134: LD_EXP 34
12138: PPUSH
12139: LD_INT 75
12141: PPUSH
12142: LD_INT 63
12144: PPUSH
12145: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12149: LD_EXP 34
12153: PPUSH
12154: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12158: LD_EXP 34
12162: PPUSH
12163: LD_INT 770
12165: PPUSH
12166: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12170: LD_EXP 34
12174: PPUSH
12175: LD_INT 100
12177: PPUSH
12178: LD_INT 75
12180: PPUSH
12181: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12185: LD_EXP 34
12189: PPUSH
12190: LD_INT 123
12192: PPUSH
12193: LD_INT 103
12195: PPUSH
12196: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12200: LD_EXP 34
12204: PPUSH
12205: LD_INT 138
12207: PPUSH
12208: LD_INT 108
12210: PPUSH
12211: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12215: LD_EXP 34
12219: PPUSH
12220: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12224: LD_INT 35
12226: PPUSH
12227: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12231: LD_EXP 34
12235: PPUSH
12236: LD_INT 138
12238: PPUSH
12239: LD_INT 108
12241: PPUSH
12242: CALL_OW 307
12246: IFFALSE 12224
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12248: LD_EXP 34
12252: PPUSH
12253: LD_INT 125
12255: PPUSH
12256: LD_INT 132
12258: PPUSH
12259: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12263: LD_INT 35
12265: PPUSH
12266: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12270: LD_INT 1
12272: PPUSH
12273: LD_EXP 34
12277: PPUSH
12278: CALL_OW 292
12282: PUSH
12283: LD_EXP 34
12287: PPUSH
12288: LD_INT 7
12290: PPUSH
12291: CALL_OW 296
12295: PUSH
12296: LD_INT 7
12298: LESS
12299: OR
12300: IFFALSE 12263
// DialogueOn ;
12302: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12306: LD_EXP 34
12310: PPUSH
12311: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12315: LD_INT 10
12317: PPUSH
12318: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12322: LD_EXP 34
12326: PPUSH
12327: LD_STRING D4Ya-Yam-1
12329: PPUSH
12330: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12334: LD_EXP 21
12338: PPUSH
12339: LD_STRING D4Ya-JMM-1
12341: PPUSH
12342: CALL_OW 88
// for i in points do
12346: LD_ADDR_VAR 0 1
12350: PUSH
12351: LD_VAR 0 2
12355: PUSH
12356: FOR_IN
12357: IFFALSE 12415
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12359: LD_VAR 0 1
12363: PUSH
12364: LD_INT 1
12366: ARRAY
12367: PPUSH
12368: LD_VAR 0 1
12372: PUSH
12373: LD_INT 2
12375: ARRAY
12376: PPUSH
12377: LD_INT 1
12379: PPUSH
12380: LD_INT 20
12382: NEG
12383: PPUSH
12384: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12388: LD_VAR 0 1
12392: PUSH
12393: LD_INT 1
12395: ARRAY
12396: PPUSH
12397: LD_VAR 0 1
12401: PUSH
12402: LD_INT 2
12404: ARRAY
12405: PPUSH
12406: LD_INT 1
12408: PPUSH
12409: CALL_OW 331
// end ;
12413: GO 12356
12415: POP
12416: POP
// dwait ( 0 0$0.5 ) ;
12417: LD_INT 18
12419: PPUSH
12420: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12424: LD_INT 42
12426: PPUSH
12427: LD_INT 27
12429: PPUSH
12430: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12434: LD_EXP 34
12438: PPUSH
12439: LD_STRING D4Ya-Yam-2
12441: PPUSH
12442: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12446: LD_INT 18
12448: PPUSH
12449: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12453: LD_INT 118
12455: PPUSH
12456: LD_INT 80
12458: PPUSH
12459: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12463: LD_EXP 21
12467: PPUSH
12468: LD_STRING D4Ya-JMM-2
12470: PPUSH
12471: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12475: LD_EXP 34
12479: PPUSH
12480: LD_STRING D4Ya-Yam-3
12482: PPUSH
12483: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12487: LD_INT 10
12489: PPUSH
12490: CALL_OW 68
// DialogueOff ;
12494: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12498: LD_EXP 34
12502: PPUSH
12503: LD_INT 1
12505: PPUSH
12506: CALL_OW 235
// end else
12510: GO 12764
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12512: LD_INT 2
12514: PPUSH
12515: LD_INT 4
12517: PPUSH
12518: LD_INT 2
12520: PPUSH
12521: LD_INT 1
12523: PPUSH
12524: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_INT 75
12535: PPUSH
12536: LD_INT 63
12538: PPUSH
12539: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12543: LD_EXP 34
12547: PPUSH
12548: LD_INT 175
12550: PPUSH
12551: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12555: LD_EXP 34
12559: PPUSH
12560: LD_INT 102
12562: PPUSH
12563: LD_INT 76
12565: PPUSH
12566: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12570: LD_EXP 34
12574: PPUSH
12575: LD_INT 108
12577: PPUSH
12578: LD_INT 70
12580: PPUSH
12581: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12585: LD_INT 35
12587: PPUSH
12588: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12592: LD_INT 2
12594: PPUSH
12595: LD_EXP 34
12599: PPUSH
12600: CALL_OW 292
12604: IFFALSE 12585
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12606: LD_EXP 34
12610: PPUSH
12611: LD_INT 112
12613: PPUSH
12614: LD_INT 118
12616: PPUSH
12617: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12621: LD_EXP 34
12625: PPUSH
12626: CALL_OW 256
12630: PUSH
12631: LD_INT 750
12633: GREATEREQUAL
12634: IFFALSE 12648
// SetLives ( Kikuchi , 700 ) ;
12636: LD_EXP 34
12640: PPUSH
12641: LD_INT 700
12643: PPUSH
12644: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12648: LD_INT 35
12650: PPUSH
12651: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12655: LD_INT 1
12657: PPUSH
12658: LD_EXP 34
12662: PPUSH
12663: CALL_OW 292
12667: PUSH
12668: LD_EXP 34
12672: PPUSH
12673: LD_INT 7
12675: PPUSH
12676: CALL_OW 296
12680: PUSH
12681: LD_INT 17
12683: LESS
12684: OR
12685: IFFALSE 12648
// DialogueOn ;
12687: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12691: LD_EXP 34
12695: PPUSH
12696: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12700: LD_EXP 34
12704: PPUSH
12705: LD_STRING D4Yb-Yam-1
12707: PPUSH
12708: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12712: LD_EXP 21
12716: PPUSH
12717: LD_STRING D4Yb-JMM-1
12719: PPUSH
12720: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12724: LD_EXP 34
12728: PPUSH
12729: LD_STRING D4Yb-Yam-2
12731: PPUSH
12732: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12736: LD_EXP 21
12740: PPUSH
12741: LD_STRING D4Yb-JMM-2
12743: PPUSH
12744: CALL_OW 88
// DialogueOff ;
12748: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12752: LD_EXP 34
12756: PPUSH
12757: LD_INT 1
12759: PPUSH
12760: CALL_OW 235
// end ; end ; end ;
12764: PPOPN 2
12766: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12767: LD_EXP 6
12771: IFFALSE 13804
12773: GO 12775
12775: DISABLE
12776: LD_INT 0
12778: PPUSH
12779: PPUSH
12780: PPUSH
12781: PPUSH
// begin enable ;
12782: ENABLE
// if not seen [ 1 ] then
12783: LD_EXP 9
12787: PUSH
12788: LD_INT 1
12790: ARRAY
12791: NOT
12792: IFFALSE 12972
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12794: LD_ADDR_VAR 0 2
12798: PUSH
12799: LD_INT 22
12801: PUSH
12802: LD_INT 2
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: PUSH
12809: LD_INT 2
12811: PUSH
12812: LD_INT 25
12814: PUSH
12815: LD_INT 11
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: PUSH
12822: LD_INT 33
12824: PUSH
12825: LD_INT 4
12827: PUSH
12828: EMPTY
12829: LIST
12830: LIST
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: LIST
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PPUSH
12841: CALL_OW 69
12845: ST_TO_ADDR
// if tmp then
12846: LD_VAR 0 2
12850: IFFALSE 12972
// for i in tmp do
12852: LD_ADDR_VAR 0 1
12856: PUSH
12857: LD_VAR 0 2
12861: PUSH
12862: FOR_IN
12863: IFFALSE 12970
// if See ( 1 , i ) then
12865: LD_INT 1
12867: PPUSH
12868: LD_VAR 0 1
12872: PPUSH
12873: CALL_OW 292
12877: IFFALSE 12968
// begin seen := Replace ( seen , 1 , true ) ;
12879: LD_ADDR_EXP 9
12883: PUSH
12884: LD_EXP 9
12888: PPUSH
12889: LD_INT 1
12891: PPUSH
12892: LD_INT 1
12894: PPUSH
12895: CALL_OW 1
12899: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12900: LD_INT 1
12902: PPUSH
12903: CALL 16509 0 1
12907: IFFALSE 12968
// begin DialogueOn ;
12909: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12913: LD_VAR 0 1
12917: PPUSH
12918: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12922: LD_INT 10
12924: PPUSH
12925: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12929: LD_ADDR_VAR 0 3
12933: PUSH
12934: LD_INT 1
12936: PPUSH
12937: LD_STRING D5a-Sol2-1
12939: PPUSH
12940: CALL 16687 0 2
12944: ST_TO_ADDR
// if not un then
12945: LD_VAR 0 3
12949: NOT
12950: IFFALSE 12962
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12952: LD_INT 2
12954: PPUSH
12955: LD_STRING D5a-FSol2-1
12957: PPUSH
12958: CALL 16687 0 2
// DialogueOff ;
12962: CALL_OW 7
// break ;
12966: GO 12970
// end ; end ;
12968: GO 12862
12970: POP
12971: POP
// end ; if not seen [ 2 ] then
12972: LD_EXP 9
12976: PUSH
12977: LD_INT 2
12979: ARRAY
12980: NOT
12981: IFFALSE 13206
// begin can_kamikazed := true ;
12983: LD_ADDR_EXP 10
12987: PUSH
12988: LD_INT 1
12990: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12991: LD_ADDR_VAR 0 2
12995: PUSH
12996: LD_INT 22
12998: PUSH
12999: LD_INT 2
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: PUSH
13006: LD_INT 25
13008: PUSH
13009: LD_INT 17
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: PUSH
13016: EMPTY
13017: LIST
13018: LIST
13019: PPUSH
13020: CALL_OW 69
13024: ST_TO_ADDR
// if tmp then
13025: LD_VAR 0 2
13029: IFFALSE 13206
// for i in tmp do
13031: LD_ADDR_VAR 0 1
13035: PUSH
13036: LD_VAR 0 2
13040: PUSH
13041: FOR_IN
13042: IFFALSE 13204
// if See ( 1 , i ) then
13044: LD_INT 1
13046: PPUSH
13047: LD_VAR 0 1
13051: PPUSH
13052: CALL_OW 292
13056: IFFALSE 13202
// begin seen := Replace ( seen , 2 , true ) ;
13058: LD_ADDR_EXP 9
13062: PUSH
13063: LD_EXP 9
13067: PPUSH
13068: LD_INT 2
13070: PPUSH
13071: LD_INT 1
13073: PPUSH
13074: CALL_OW 1
13078: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13079: LD_INT 1
13081: PPUSH
13082: CALL 16509 0 1
13086: IFFALSE 13202
// begin DialogueOn ;
13088: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13092: LD_VAR 0 1
13096: PPUSH
13097: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13101: LD_INT 10
13103: PPUSH
13104: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13108: LD_ADDR_VAR 0 3
13112: PUSH
13113: LD_INT 1
13115: PPUSH
13116: LD_STRING D5b-Sol1-1
13118: PPUSH
13119: CALL 16687 0 2
13123: ST_TO_ADDR
// if not un then
13124: LD_VAR 0 3
13128: NOT
13129: IFFALSE 13147
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13131: LD_ADDR_VAR 0 3
13135: PUSH
13136: LD_INT 2
13138: PPUSH
13139: LD_STRING D5b-FSol1-1
13141: PPUSH
13142: CALL 16687 0 2
13146: ST_TO_ADDR
// if un then
13147: LD_VAR 0 3
13151: IFFALSE 13196
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13153: LD_ADDR_VAR 0 4
13157: PUSH
13158: LD_INT 1
13160: PPUSH
13161: LD_STRING D5b-Sol2-1
13163: PPUSH
13164: LD_VAR 0 3
13168: PPUSH
13169: CALL 16913 0 3
13173: ST_TO_ADDR
// if not un2 then
13174: LD_VAR 0 4
13178: NOT
13179: IFFALSE 13196
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13181: LD_INT 2
13183: PPUSH
13184: LD_STRING D5b-FSol2-1
13186: PPUSH
13187: LD_VAR 0 3
13191: PPUSH
13192: CALL 16913 0 3
// end ; DialogueOff ;
13196: CALL_OW 7
// break ;
13200: GO 13204
// end ; end ;
13202: GO 13041
13204: POP
13205: POP
// end ; if not seen [ 3 ] then
13206: LD_EXP 9
13210: PUSH
13211: LD_INT 3
13213: ARRAY
13214: NOT
13215: IFFALSE 13389
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13217: LD_ADDR_VAR 0 2
13221: PUSH
13222: LD_INT 22
13224: PUSH
13225: LD_INT 2
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PUSH
13232: LD_INT 33
13234: PUSH
13235: LD_INT 2
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: PPUSH
13246: CALL_OW 69
13250: ST_TO_ADDR
// if tmp then
13251: LD_VAR 0 2
13255: IFFALSE 13389
// for i in tmp do
13257: LD_ADDR_VAR 0 1
13261: PUSH
13262: LD_VAR 0 2
13266: PUSH
13267: FOR_IN
13268: IFFALSE 13387
// if See ( 1 , i ) then
13270: LD_INT 1
13272: PPUSH
13273: LD_VAR 0 1
13277: PPUSH
13278: CALL_OW 292
13282: IFFALSE 13385
// begin seen := Replace ( seen , 3 , true ) ;
13284: LD_ADDR_EXP 9
13288: PUSH
13289: LD_EXP 9
13293: PPUSH
13294: LD_INT 3
13296: PPUSH
13297: LD_INT 1
13299: PPUSH
13300: CALL_OW 1
13304: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13305: LD_INT 1
13307: PPUSH
13308: CALL 16509 0 1
13312: IFFALSE 13385
// begin DialogueOn ;
13314: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13318: LD_VAR 0 1
13322: PPUSH
13323: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13327: LD_INT 10
13329: PPUSH
13330: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13334: LD_ADDR_VAR 0 3
13338: PUSH
13339: LD_INT 1
13341: PPUSH
13342: LD_STRING D8-Sol1-1
13344: PPUSH
13345: CALL 16687 0 2
13349: ST_TO_ADDR
// if not un then
13350: LD_VAR 0 3
13354: NOT
13355: IFFALSE 13367
// SayRand ( sex_female , D8-FSol1-1 ) ;
13357: LD_INT 2
13359: PPUSH
13360: LD_STRING D8-FSol1-1
13362: PPUSH
13363: CALL 16687 0 2
// Say ( JMM , D8-JMM-1 ) ;
13367: LD_EXP 21
13371: PPUSH
13372: LD_STRING D8-JMM-1
13374: PPUSH
13375: CALL_OW 88
// DialogueOff ;
13379: CALL_OW 7
// break ;
13383: GO 13387
// end ; end ;
13385: GO 13267
13387: POP
13388: POP
// end ; if not seen [ 4 ] then
13389: LD_EXP 9
13393: PUSH
13394: LD_INT 4
13396: ARRAY
13397: NOT
13398: IFFALSE 13560
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13400: LD_ADDR_VAR 0 2
13404: PUSH
13405: LD_INT 22
13407: PUSH
13408: LD_INT 2
13410: PUSH
13411: EMPTY
13412: LIST
13413: LIST
13414: PUSH
13415: LD_INT 33
13417: PUSH
13418: LD_INT 5
13420: PUSH
13421: EMPTY
13422: LIST
13423: LIST
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: PPUSH
13429: CALL_OW 69
13433: ST_TO_ADDR
// if tmp then
13434: LD_VAR 0 2
13438: IFFALSE 13560
// for i in tmp do
13440: LD_ADDR_VAR 0 1
13444: PUSH
13445: LD_VAR 0 2
13449: PUSH
13450: FOR_IN
13451: IFFALSE 13558
// if See ( 1 , i ) then
13453: LD_INT 1
13455: PPUSH
13456: LD_VAR 0 1
13460: PPUSH
13461: CALL_OW 292
13465: IFFALSE 13556
// begin seen := Replace ( seen , 4 , true ) ;
13467: LD_ADDR_EXP 9
13471: PUSH
13472: LD_EXP 9
13476: PPUSH
13477: LD_INT 4
13479: PPUSH
13480: LD_INT 1
13482: PPUSH
13483: CALL_OW 1
13487: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13488: LD_INT 1
13490: PPUSH
13491: CALL 16509 0 1
13495: IFFALSE 13556
// begin DialogueOn ;
13497: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13501: LD_VAR 0 1
13505: PPUSH
13506: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13510: LD_INT 10
13512: PPUSH
13513: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13517: LD_ADDR_VAR 0 3
13521: PUSH
13522: LD_INT 1
13524: PPUSH
13525: LD_STRING D5a-Sol1-1
13527: PPUSH
13528: CALL 16687 0 2
13532: ST_TO_ADDR
// if not un then
13533: LD_VAR 0 3
13537: NOT
13538: IFFALSE 13550
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13540: LD_INT 2
13542: PPUSH
13543: LD_STRING D5a-FSol1-1
13545: PPUSH
13546: CALL 16687 0 2
// DialogueOff ;
13550: CALL_OW 7
// break ;
13554: GO 13558
// end ; end ;
13556: GO 13450
13558: POP
13559: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13560: LD_EXP 9
13564: PUSH
13565: LD_INT 5
13567: ARRAY
13568: NOT
13569: PUSH
13570: LD_EXP 9
13574: PUSH
13575: LD_INT 3
13577: ARRAY
13578: AND
13579: IFFALSE 13753
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13581: LD_ADDR_VAR 0 2
13585: PUSH
13586: LD_INT 22
13588: PUSH
13589: LD_INT 2
13591: PUSH
13592: EMPTY
13593: LIST
13594: LIST
13595: PUSH
13596: LD_INT 34
13598: PUSH
13599: LD_INT 31
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: PUSH
13606: EMPTY
13607: LIST
13608: LIST
13609: PPUSH
13610: CALL_OW 69
13614: ST_TO_ADDR
// if tmp then
13615: LD_VAR 0 2
13619: IFFALSE 13753
// for i in tmp do
13621: LD_ADDR_VAR 0 1
13625: PUSH
13626: LD_VAR 0 2
13630: PUSH
13631: FOR_IN
13632: IFFALSE 13751
// if See ( 1 , i ) then
13634: LD_INT 1
13636: PPUSH
13637: LD_VAR 0 1
13641: PPUSH
13642: CALL_OW 292
13646: IFFALSE 13749
// begin seen := Replace ( seen , 5 , true ) ;
13648: LD_ADDR_EXP 9
13652: PUSH
13653: LD_EXP 9
13657: PPUSH
13658: LD_INT 5
13660: PPUSH
13661: LD_INT 1
13663: PPUSH
13664: CALL_OW 1
13668: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13669: LD_INT 1
13671: PPUSH
13672: CALL 16509 0 1
13676: IFFALSE 13749
// begin DialogueOn ;
13678: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13682: LD_VAR 0 1
13686: PPUSH
13687: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13691: LD_INT 10
13693: PPUSH
13694: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13698: LD_ADDR_VAR 0 3
13702: PUSH
13703: LD_INT 1
13705: PPUSH
13706: LD_STRING D8a-Sol2-1
13708: PPUSH
13709: CALL 16687 0 2
13713: ST_TO_ADDR
// if not un then
13714: LD_VAR 0 3
13718: NOT
13719: IFFALSE 13731
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13721: LD_INT 2
13723: PPUSH
13724: LD_STRING D8a-FSol2-1
13726: PPUSH
13727: CALL 16687 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13731: LD_EXP 21
13735: PPUSH
13736: LD_STRING D8a-JMM-1
13738: PPUSH
13739: CALL_OW 88
// DialogueOff ;
13743: CALL_OW 7
// break ;
13747: GO 13751
// end ; end ;
13749: GO 13631
13751: POP
13752: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13753: LD_EXP 9
13757: PUSH
13758: LD_INT 1
13760: ARRAY
13761: PUSH
13762: LD_EXP 9
13766: PUSH
13767: LD_INT 2
13769: ARRAY
13770: AND
13771: PUSH
13772: LD_EXP 9
13776: PUSH
13777: LD_INT 3
13779: ARRAY
13780: AND
13781: PUSH
13782: LD_EXP 9
13786: PUSH
13787: LD_INT 4
13789: ARRAY
13790: AND
13791: PUSH
13792: LD_EXP 9
13796: PUSH
13797: LD_INT 5
13799: ARRAY
13800: AND
13801: IFFALSE 13804
// disable ;
13803: DISABLE
// end ;
13804: PPOPN 4
13806: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13807: LD_EXP 10
13811: PUSH
13812: LD_EXP 11
13816: AND
13817: IFFALSE 14015
13819: GO 13821
13821: DISABLE
13822: LD_INT 0
13824: PPUSH
// begin DialogueOn ;
13825: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13829: LD_EXP 11
13833: PPUSH
13834: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13838: LD_ADDR_VAR 0 1
13842: PUSH
13843: LD_INT 1
13845: PPUSH
13846: LD_STRING D5c-Sol1-1
13848: PPUSH
13849: CALL 16687 0 2
13853: ST_TO_ADDR
// if not un then
13854: LD_VAR 0 1
13858: NOT
13859: IFFALSE 13877
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13861: LD_ADDR_VAR 0 1
13865: PUSH
13866: LD_INT 2
13868: PPUSH
13869: LD_STRING D5c-FSol1-1
13871: PPUSH
13872: CALL 16687 0 2
13876: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13877: LD_EXP 21
13881: PPUSH
13882: LD_STRING D5c-JMM-1
13884: PPUSH
13885: CALL_OW 88
// if IsOk ( Lisa ) then
13889: LD_EXP 22
13893: PPUSH
13894: CALL_OW 302
13898: IFFALSE 13914
// Say ( Lisa , D5d-Lisa-1 ) else
13900: LD_EXP 22
13904: PPUSH
13905: LD_STRING D5d-Lisa-1
13907: PPUSH
13908: CALL_OW 88
13912: GO 13999
// if IsOk ( Cyrus ) then
13914: LD_EXP 25
13918: PPUSH
13919: CALL_OW 302
13923: IFFALSE 13939
// Say ( Cyrus , D5d-Cyrus-1 ) else
13925: LD_EXP 25
13929: PPUSH
13930: LD_STRING D5d-Cyrus-1
13932: PPUSH
13933: CALL_OW 88
13937: GO 13999
// if IsOk ( Gary ) then
13939: LD_EXP 32
13943: PPUSH
13944: CALL_OW 302
13948: IFFALSE 13964
// Say ( Gary , D5d-Gary-1 ) else
13950: LD_EXP 32
13954: PPUSH
13955: LD_STRING D5d-Gary-1
13957: PPUSH
13958: CALL_OW 88
13962: GO 13999
// if GetSex ( un ) = sex_male then
13964: LD_VAR 0 1
13968: PPUSH
13969: CALL_OW 258
13973: PUSH
13974: LD_INT 1
13976: EQUAL
13977: IFFALSE 13993
// Say ( un , D5d-Sol1-1 ) else
13979: LD_VAR 0 1
13983: PPUSH
13984: LD_STRING D5d-Sol1-1
13986: PPUSH
13987: CALL_OW 88
13991: GO 13999
// begin DialogueOff ;
13993: CALL_OW 7
// exit ;
13997: GO 14015
// end ; Say ( JMM , D5d-JMM-1 ) ;
13999: LD_EXP 21
14003: PPUSH
14004: LD_STRING D5d-JMM-1
14006: PPUSH
14007: CALL_OW 88
// DialogueOff ;
14011: CALL_OW 7
// end ;
14015: PPOPN 1
14017: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14018: LD_INT 1
14020: PPUSH
14021: LD_INT 17
14023: PPUSH
14024: CALL_OW 294
14028: PUSH
14029: LD_INT 2
14031: GREATEREQUAL
14032: IFFALSE 14164
14034: GO 14036
14036: DISABLE
14037: LD_INT 0
14039: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14040: LD_INT 10
14042: PPUSH
14043: LD_INT 5
14045: PPUSH
14046: LD_INT 1
14048: PPUSH
14049: LD_INT 10
14051: NEG
14052: PPUSH
14053: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14057: LD_INT 10
14059: PPUSH
14060: LD_INT 5
14062: PPUSH
14063: LD_INT 1
14065: PPUSH
14066: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14070: LD_INT 10
14072: PPUSH
14073: LD_INT 5
14075: PPUSH
14076: CALL_OW 86
// DialogueOn ;
14080: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14084: LD_ADDR_VAR 0 1
14088: PUSH
14089: LD_INT 1
14091: PPUSH
14092: LD_STRING D6-Sci1-1
14094: PPUSH
14095: CALL 16687 0 2
14099: ST_TO_ADDR
// if un then
14100: LD_VAR 0 1
14104: IFFALSE 14142
// begin Say ( JMM , D6-JMM-1 ) ;
14106: LD_EXP 21
14110: PPUSH
14111: LD_STRING D6-JMM-1
14113: PPUSH
14114: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14118: LD_VAR 0 1
14122: PPUSH
14123: LD_STRING D6-Sci1-2
14125: PPUSH
14126: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14130: LD_EXP 21
14134: PPUSH
14135: LD_STRING D6-JMM-2
14137: PPUSH
14138: CALL_OW 88
// end ; DialogueOff ;
14142: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14146: LD_STRING M3
14148: PPUSH
14149: CALL_OW 337
// wait ( 0 0$30 ) ;
14153: LD_INT 1050
14155: PPUSH
14156: CALL_OW 67
// AmericanReinforcements ;
14160: CALL 2335 0 0
// end ;
14164: PPOPN 1
14166: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14167: LD_OWVAR 1
14171: PUSH
14172: LD_INT 42000
14174: GREATEREQUAL
14175: PUSH
14176: LD_INT 2
14178: PPUSH
14179: LD_INT 169
14181: PPUSH
14182: LD_INT 90
14184: PPUSH
14185: LD_INT 10
14187: PPUSH
14188: CALL 54437 0 4
14192: PUSH
14193: LD_INT 4
14195: ARRAY
14196: PUSH
14197: LD_INT 0
14199: EQUAL
14200: PUSH
14201: LD_INT 45
14203: PPUSH
14204: CALL_OW 301
14208: OR
14209: PUSH
14210: LD_INT 45
14212: PPUSH
14213: CALL_OW 255
14217: PUSH
14218: LD_INT 1
14220: EQUAL
14221: OR
14222: AND
14223: PUSH
14224: LD_INT 94
14226: PPUSH
14227: CALL_OW 301
14231: NOT
14232: AND
14233: IFFALSE 15438
14235: GO 14237
14237: DISABLE
14238: LD_INT 0
14240: PPUSH
14241: PPUSH
14242: PPUSH
14243: PPUSH
14244: PPUSH
// begin uc_side := 5 ;
14245: LD_ADDR_OWVAR 20
14249: PUSH
14250: LD_INT 5
14252: ST_TO_ADDR
// uc_nation := 2 ;
14253: LD_ADDR_OWVAR 21
14257: PUSH
14258: LD_INT 2
14260: ST_TO_ADDR
// InitHc ;
14261: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14265: LD_INT 1
14267: PPUSH
14268: LD_INT 3
14270: PPUSH
14271: LD_INT 8
14273: PPUSH
14274: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14278: LD_ADDR_OWVAR 29
14282: PUSH
14283: LD_INT 12
14285: PUSH
14286: LD_INT 12
14288: PUSH
14289: EMPTY
14290: LIST
14291: LIST
14292: ST_TO_ADDR
// hc_name := Hans Fliege ;
14293: LD_ADDR_OWVAR 26
14297: PUSH
14298: LD_STRING Hans Fliege
14300: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14301: LD_ADDR_OWVAR 33
14305: PUSH
14306: LD_STRING SecondCharsGal
14308: ST_TO_ADDR
// hc_face_number := 7 ;
14309: LD_ADDR_OWVAR 34
14313: PUSH
14314: LD_INT 7
14316: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14317: LD_ADDR_EXP 46
14321: PUSH
14322: CALL_OW 44
14326: ST_TO_ADDR
// InitHc ;
14327: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14331: LD_INT 1
14333: PPUSH
14334: LD_INT 16
14336: PPUSH
14337: LD_INT 2
14339: PPUSH
14340: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14344: LD_ADDR_OWVAR 29
14348: PUSH
14349: LD_INT 12
14351: PUSH
14352: LD_INT 12
14354: PUSH
14355: EMPTY
14356: LIST
14357: LIST
14358: ST_TO_ADDR
// hc_name :=  ;
14359: LD_ADDR_OWVAR 26
14363: PUSH
14364: LD_STRING 
14366: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14367: LD_ADDR_EXP 47
14371: PUSH
14372: CALL_OW 44
14376: ST_TO_ADDR
// InitHc ;
14377: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14381: LD_INT 35
14383: PPUSH
14384: CALL_OW 67
// until not InBattle ( 1 ) ;
14388: LD_INT 1
14390: PPUSH
14391: CALL_OW 463
14395: NOT
14396: IFFALSE 14381
// wait ( 0 0$5 ) ;
14398: LD_INT 175
14400: PPUSH
14401: CALL_OW 67
// DialogueOn ;
14405: CALL_OW 6
// InGameOn ;
14409: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14413: LD_ADDR_VAR 0 1
14417: PUSH
14418: LD_INT 22
14420: PUSH
14421: LD_INT 1
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PUSH
14428: LD_INT 2
14430: PUSH
14431: LD_INT 25
14433: PUSH
14434: LD_INT 1
14436: PUSH
14437: EMPTY
14438: LIST
14439: LIST
14440: PUSH
14441: LD_INT 25
14443: PUSH
14444: LD_INT 2
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: LD_INT 25
14453: PUSH
14454: LD_INT 3
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: LD_INT 25
14463: PUSH
14464: LD_INT 4
14466: PUSH
14467: EMPTY
14468: LIST
14469: LIST
14470: PUSH
14471: LD_INT 25
14473: PUSH
14474: LD_INT 5
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: PUSH
14481: LD_INT 25
14483: PUSH
14484: LD_INT 8
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: EMPTY
14492: LIST
14493: LIST
14494: LIST
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: PUSH
14500: EMPTY
14501: LIST
14502: LIST
14503: PPUSH
14504: CALL_OW 69
14508: PUSH
14509: LD_EXP 21
14513: PUSH
14514: LD_EXP 22
14518: PUSH
14519: LD_EXP 23
14523: PUSH
14524: LD_EXP 24
14528: PUSH
14529: LD_EXP 25
14533: PUSH
14534: LD_EXP 26
14538: PUSH
14539: LD_EXP 27
14543: PUSH
14544: LD_EXP 28
14548: PUSH
14549: LD_EXP 29
14553: PUSH
14554: LD_EXP 31
14558: PUSH
14559: LD_EXP 32
14563: PUSH
14564: LD_EXP 33
14568: PUSH
14569: LD_EXP 34
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: DIFF
14589: PPUSH
14590: LD_INT 26
14592: PUSH
14593: LD_INT 1
14595: PUSH
14596: EMPTY
14597: LIST
14598: LIST
14599: PPUSH
14600: CALL_OW 72
14604: PUSH
14605: LD_INT 1
14607: ARRAY
14608: ST_TO_ADDR
// if Brown then
14609: LD_EXP 27
14613: IFFALSE 14625
// un := Brown ;
14615: LD_ADDR_VAR 0 1
14619: PUSH
14620: LD_EXP 27
14624: ST_TO_ADDR
// if un then
14625: LD_VAR 0 1
14629: IFFALSE 14655
// begin Say ( un , D7-Sol1-1 ) ;
14631: LD_VAR 0 1
14635: PPUSH
14636: LD_STRING D7-Sol1-1
14638: PPUSH
14639: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14643: LD_EXP 21
14647: PPUSH
14648: LD_STRING D7-JMM-1
14650: PPUSH
14651: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14655: LD_EXP 46
14659: PPUSH
14660: LD_STRING D7-Ar1-1
14662: PPUSH
14663: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14667: LD_EXP 21
14671: PPUSH
14672: LD_STRING D7-JMM-2
14674: PPUSH
14675: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14679: LD_EXP 46
14683: PPUSH
14684: LD_STRING D7-Ar1-2
14686: PPUSH
14687: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14691: LD_EXP 21
14695: PPUSH
14696: LD_STRING D7-JMM-3
14698: PPUSH
14699: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14703: LD_EXP 46
14707: PPUSH
14708: LD_STRING D7-Ar1-3
14710: PPUSH
14711: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14715: LD_EXP 21
14719: PPUSH
14720: LD_STRING D7-JMM-4
14722: PPUSH
14723: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14727: LD_EXP 46
14731: PPUSH
14732: LD_STRING D7-Ar1-4
14734: PPUSH
14735: CALL_OW 94
// InGameOff ;
14739: CALL_OW 9
// DialogueOff ;
14743: CALL_OW 7
// case Query ( QCameras ) of 1 :
14747: LD_STRING QCameras
14749: PPUSH
14750: CALL_OW 97
14754: PUSH
14755: LD_INT 1
14757: DOUBLE
14758: EQUAL
14759: IFTRUE 14763
14761: GO 14766
14763: POP
// ; 2 :
14764: GO 14780
14766: LD_INT 2
14768: DOUBLE
14769: EQUAL
14770: IFTRUE 14774
14772: GO 14779
14774: POP
// exit ; end ;
14775: GO 15438
14777: GO 14780
14779: POP
// ChangeMissionObjectives ( MCar ) ;
14780: LD_STRING MCar
14782: PPUSH
14783: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14787: LD_INT 124
14789: PPUSH
14790: LD_INT 90
14792: PPUSH
14793: LD_INT 1
14795: PPUSH
14796: LD_INT 6
14798: NEG
14799: PPUSH
14800: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14804: LD_INT 124
14806: PPUSH
14807: LD_INT 90
14809: PPUSH
14810: LD_INT 1
14812: PPUSH
14813: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14817: LD_INT 12
14819: PPUSH
14820: LD_INT 1
14822: PPUSH
14823: CALL_OW 424
// wait ( 3 ) ;
14827: LD_INT 3
14829: PPUSH
14830: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14834: LD_INT 124
14836: PPUSH
14837: LD_INT 90
14839: PPUSH
14840: CALL_OW 86
// cargo := false ;
14844: LD_ADDR_VAR 0 3
14848: PUSH
14849: LD_INT 0
14851: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14852: LD_INT 35
14854: PPUSH
14855: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14859: LD_ADDR_VAR 0 3
14863: PUSH
14864: LD_INT 12
14866: PPUSH
14867: LD_INT 32
14869: PUSH
14870: LD_INT 3
14872: PUSH
14873: EMPTY
14874: LIST
14875: LIST
14876: PUSH
14877: LD_INT 34
14879: PUSH
14880: LD_INT 32
14882: PUSH
14883: EMPTY
14884: LIST
14885: LIST
14886: PUSH
14887: LD_INT 58
14889: PUSH
14890: EMPTY
14891: LIST
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: LIST
14897: PPUSH
14898: CALL_OW 70
14902: ST_TO_ADDR
// until cargo ;
14903: LD_VAR 0 3
14907: IFFALSE 14852
// cargo := cargo [ 1 ] ;
14909: LD_ADDR_VAR 0 3
14913: PUSH
14914: LD_VAR 0 3
14918: PUSH
14919: LD_INT 1
14921: ARRAY
14922: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14923: LD_VAR 0 3
14927: PPUSH
14928: LD_INT 5
14930: PPUSH
14931: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14935: LD_INT 12
14937: PPUSH
14938: LD_INT 0
14940: PPUSH
14941: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14945: LD_EXP 46
14949: PPUSH
14950: LD_INT 11
14952: PPUSH
14953: LD_INT 0
14955: PPUSH
14956: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14960: LD_EXP 47
14964: PPUSH
14965: LD_INT 11
14967: PPUSH
14968: LD_INT 0
14970: PPUSH
14971: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14975: LD_EXP 46
14979: PUSH
14980: LD_EXP 47
14984: PUSH
14985: EMPTY
14986: LIST
14987: LIST
14988: PPUSH
14989: LD_INT 12
14991: PPUSH
14992: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14996: LD_EXP 46
15000: PPUSH
15001: LD_VAR 0 3
15005: PPUSH
15006: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15010: LD_EXP 46
15014: PUSH
15015: LD_EXP 47
15019: PUSH
15020: EMPTY
15021: LIST
15022: LIST
15023: PPUSH
15024: LD_INT 209
15026: PPUSH
15027: LD_INT 178
15029: PPUSH
15030: CALL_OW 171
// escaped := 0 ;
15034: LD_ADDR_VAR 0 5
15038: PUSH
15039: LD_INT 0
15041: ST_TO_ADDR
// while ( true ) do
15042: LD_INT 1
15044: IFFALSE 15260
// begin wait ( 0 0$1 ) ;
15046: LD_INT 35
15048: PPUSH
15049: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15053: LD_EXP 46
15057: PPUSH
15058: CALL_OW 314
15062: NOT
15063: PUSH
15064: LD_EXP 47
15068: PPUSH
15069: CALL_OW 314
15073: NOT
15074: OR
15075: IFFALSE 15101
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15077: LD_EXP 46
15081: PUSH
15082: LD_EXP 47
15086: PUSH
15087: EMPTY
15088: LIST
15089: LIST
15090: PPUSH
15091: LD_INT 209
15093: PPUSH
15094: LD_INT 178
15096: PPUSH
15097: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15101: LD_EXP 46
15105: PPUSH
15106: LD_INT 10
15108: PPUSH
15109: CALL_OW 308
15113: IFFALSE 15138
// begin RemoveUnit ( ar_mechanic ) ;
15115: LD_EXP 46
15119: PPUSH
15120: CALL_OW 64
// escaped := escaped + 1 ;
15124: LD_ADDR_VAR 0 5
15128: PUSH
15129: LD_VAR 0 5
15133: PUSH
15134: LD_INT 1
15136: PLUS
15137: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15138: LD_EXP 47
15142: PPUSH
15143: LD_INT 10
15145: PPUSH
15146: CALL_OW 308
15150: IFFALSE 15175
// begin RemoveUnit ( ar_mechanic_friend ) ;
15152: LD_EXP 47
15156: PPUSH
15157: CALL_OW 64
// escaped := escaped + 1 ;
15161: LD_ADDR_VAR 0 5
15165: PUSH
15166: LD_VAR 0 5
15170: PUSH
15171: LD_INT 1
15173: PLUS
15174: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15175: LD_VAR 0 3
15179: PPUSH
15180: LD_INT 10
15182: PPUSH
15183: CALL_OW 308
15187: IFFALSE 15198
// RemoveUnit ( cargo ) ;
15189: LD_VAR 0 3
15193: PPUSH
15194: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15198: LD_EXP 46
15202: PPUSH
15203: CALL_OW 305
15207: NOT
15208: PUSH
15209: LD_VAR 0 5
15213: PUSH
15214: LD_INT 2
15216: GREATEREQUAL
15217: AND
15218: IFFALSE 15222
// break ;
15220: GO 15260
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15222: LD_EXP 46
15226: PPUSH
15227: CALL_OW 305
15231: NOT
15232: PUSH
15233: LD_EXP 47
15237: PPUSH
15238: CALL_OW 305
15242: NOT
15243: AND
15244: PUSH
15245: LD_VAR 0 5
15249: PUSH
15250: LD_INT 2
15252: LESS
15253: AND
15254: IFFALSE 15258
// exit ;
15256: GO 15438
// end ;
15258: GO 15042
// wait ( 0 0$2 ) ;
15260: LD_INT 70
15262: PPUSH
15263: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15267: LD_EXP 46
15271: PPUSH
15272: LD_STRING D7a-Ar1-1
15274: PPUSH
15275: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15279: LD_ADDR_VAR 0 4
15283: PUSH
15284: LD_INT 129
15286: PUSH
15287: LD_INT 10
15289: PUSH
15290: EMPTY
15291: LIST
15292: LIST
15293: PUSH
15294: LD_INT 103
15296: PUSH
15297: LD_INT 6
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: PUSH
15304: LD_INT 148
15306: PUSH
15307: LD_INT 47
15309: PUSH
15310: EMPTY
15311: LIST
15312: LIST
15313: PUSH
15314: LD_INT 155
15316: PUSH
15317: LD_INT 16
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: LIST
15328: LIST
15329: ST_TO_ADDR
// if Difficulty = 1 then
15330: LD_OWVAR 67
15334: PUSH
15335: LD_INT 1
15337: EQUAL
15338: IFFALSE 15375
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15340: LD_ADDR_VAR 0 4
15344: PUSH
15345: LD_VAR 0 4
15349: PUSH
15350: LD_INT 78
15352: PUSH
15353: LD_INT 7
15355: PUSH
15356: EMPTY
15357: LIST
15358: LIST
15359: PUSH
15360: LD_INT 104
15362: PUSH
15363: LD_INT 43
15365: PUSH
15366: EMPTY
15367: LIST
15368: LIST
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: ADD
15374: ST_TO_ADDR
// for i in tmp do
15375: LD_ADDR_VAR 0 2
15379: PUSH
15380: LD_VAR 0 4
15384: PUSH
15385: FOR_IN
15386: IFFALSE 15419
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15388: LD_VAR 0 2
15392: PUSH
15393: LD_INT 1
15395: ARRAY
15396: PPUSH
15397: LD_VAR 0 2
15401: PUSH
15402: LD_INT 2
15404: ARRAY
15405: PPUSH
15406: LD_INT 1
15408: PPUSH
15409: LD_INT 9
15411: NEG
15412: PPUSH
15413: CALL_OW 330
15417: GO 15385
15419: POP
15420: POP
// SetAchievement ( ACH_FRIEND ) ;
15421: LD_STRING ACH_FRIEND
15423: PPUSH
15424: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15428: LD_INT 129
15430: PPUSH
15431: LD_INT 10
15433: PPUSH
15434: CALL_OW 84
// end ;
15438: PPOPN 5
15440: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15441: LD_EXP 15
15445: PUSH
15446: LD_INT 21000
15448: MINUS
15449: PUSH
15450: LD_OWVAR 1
15454: LESSEQUAL
15455: IFFALSE 15495
15457: GO 15459
15459: DISABLE
// begin powell_warn := true ;
15460: LD_ADDR_EXP 16
15464: PUSH
15465: LD_INT 1
15467: ST_TO_ADDR
// DialogueOn ;
15468: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15472: LD_EXP 30
15476: PPUSH
15477: LD_STRING D9-Pow-1
15479: PPUSH
15480: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15484: LD_INT 10
15486: PPUSH
15487: CALL_OW 68
// DialogueOff ;
15491: CALL_OW 7
// end ;
15495: END
// every 0 0$1 trigger game_time <= tick do
15496: LD_EXP 15
15500: PUSH
15501: LD_OWVAR 1
15505: LESSEQUAL
15506: IFFALSE 15545
15508: GO 15510
15510: DISABLE
// begin DialogueOn ;
15511: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15515: LD_EXP 30
15519: PPUSH
15520: LD_STRING D9a-Pow-1
15522: PPUSH
15523: CALL_OW 94
// dwait ( 0 0$2 ) ;
15527: LD_INT 70
15529: PPUSH
15530: CALL_OW 68
// DialogueOff ;
15534: CALL_OW 7
// YouLost ( Command ) ;
15538: LD_STRING Command
15540: PPUSH
15541: CALL_OW 104
// end ;
15545: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15546: LD_INT 22
15548: PUSH
15549: LD_INT 2
15551: PUSH
15552: EMPTY
15553: LIST
15554: LIST
15555: PUSH
15556: LD_INT 30
15558: PUSH
15559: LD_INT 1
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: EMPTY
15567: LIST
15568: LIST
15569: PPUSH
15570: CALL_OW 69
15574: PUSH
15575: LD_INT 0
15577: EQUAL
15578: PUSH
15579: LD_EXP 21
15583: PPUSH
15584: CALL_OW 302
15588: AND
15589: IFFALSE 16506
15591: GO 15593
15593: DISABLE
15594: LD_INT 0
15596: PPUSH
15597: PPUSH
15598: PPUSH
15599: PPUSH
// begin m1 := false ;
15600: LD_ADDR_VAR 0 2
15604: PUSH
15605: LD_INT 0
15607: ST_TO_ADDR
// m2 := false ;
15608: LD_ADDR_VAR 0 3
15612: PUSH
15613: LD_INT 0
15615: ST_TO_ADDR
// m3 := false ;
15616: LD_ADDR_VAR 0 4
15620: PUSH
15621: LD_INT 0
15623: ST_TO_ADDR
// if not am_veh_consturcted then
15624: LD_EXP 20
15628: NOT
15629: IFFALSE 15638
// SetAchievement ( ACH_ARABTECH ) ;
15631: LD_STRING ACH_ARABTECH
15633: PPUSH
15634: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15638: LD_OWVAR 1
15642: PUSH
15643: LD_INT 252000
15645: PUSH
15646: LD_INT 210000
15648: PUSH
15649: LD_INT 199500
15651: PUSH
15652: LD_INT 193200
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: LIST
15659: LIST
15660: PUSH
15661: LD_OWVAR 67
15665: ARRAY
15666: LESS
15667: IFFALSE 15689
// begin m3 := true ;
15669: LD_ADDR_VAR 0 4
15673: PUSH
15674: LD_INT 1
15676: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15677: LD_STRING Time1
15679: PPUSH
15680: LD_INT 1
15682: PPUSH
15683: CALL_OW 101
// end else
15687: GO 15720
// if not powell_warn then
15689: LD_EXP 16
15693: NOT
15694: IFFALSE 15709
// AddMedal ( Time1 , - 1 ) else
15696: LD_STRING Time1
15698: PPUSH
15699: LD_INT 1
15701: NEG
15702: PPUSH
15703: CALL_OW 101
15707: GO 15720
// AddMedal ( Time1 , - 2 ) ;
15709: LD_STRING Time1
15711: PPUSH
15712: LD_INT 2
15714: NEG
15715: PPUSH
15716: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15720: LD_EXP 17
15724: PUSH
15725: LD_INT 5
15727: PUSH
15728: LD_INT 4
15730: PUSH
15731: LD_INT 3
15733: PUSH
15734: LD_INT 3
15736: PUSH
15737: EMPTY
15738: LIST
15739: LIST
15740: LIST
15741: LIST
15742: PUSH
15743: LD_OWVAR 67
15747: ARRAY
15748: GREATEREQUAL
15749: IFFALSE 15764
// AddMedal ( Destroy , - 2 ) else
15751: LD_STRING Destroy
15753: PPUSH
15754: LD_INT 2
15756: NEG
15757: PPUSH
15758: CALL_OW 101
15762: GO 15897
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15764: LD_INT 22
15766: PUSH
15767: LD_INT 2
15769: PUSH
15770: EMPTY
15771: LIST
15772: LIST
15773: PUSH
15774: LD_INT 21
15776: PUSH
15777: LD_INT 3
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PUSH
15784: LD_INT 50
15786: PUSH
15787: EMPTY
15788: LIST
15789: PUSH
15790: EMPTY
15791: LIST
15792: LIST
15793: LIST
15794: PPUSH
15795: CALL_OW 69
15799: PUSH
15800: LD_INT 25
15802: GREATEREQUAL
15803: IFFALSE 15818
// AddMedal ( Destroy , - 1 ) else
15805: LD_STRING Destroy
15807: PPUSH
15808: LD_INT 1
15810: NEG
15811: PPUSH
15812: CALL_OW 101
15816: GO 15897
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15818: LD_INT 22
15820: PUSH
15821: LD_INT 2
15823: PUSH
15824: EMPTY
15825: LIST
15826: LIST
15827: PUSH
15828: LD_INT 21
15830: PUSH
15831: LD_INT 3
15833: PUSH
15834: EMPTY
15835: LIST
15836: LIST
15837: PUSH
15838: LD_INT 50
15840: PUSH
15841: EMPTY
15842: LIST
15843: PUSH
15844: EMPTY
15845: LIST
15846: LIST
15847: LIST
15848: PPUSH
15849: CALL_OW 69
15853: PUSH
15854: LD_INT 15
15856: GREATEREQUAL
15857: IFFALSE 15879
// begin m1 := true ;
15859: LD_ADDR_VAR 0 2
15863: PUSH
15864: LD_INT 1
15866: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15867: LD_STRING Destroy
15869: PPUSH
15870: LD_INT 1
15872: PPUSH
15873: CALL_OW 101
// end else
15877: GO 15897
// begin m1 := true ;
15879: LD_ADDR_VAR 0 2
15883: PUSH
15884: LD_INT 1
15886: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15887: LD_STRING Destroy
15889: PPUSH
15890: LD_INT 2
15892: PPUSH
15893: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15897: LD_EXP 13
15901: PPUSH
15902: LD_STRING 11_artifact_captured
15904: PPUSH
15905: CALL_OW 39
// if artifact_get then
15909: LD_EXP 13
15913: IFFALSE 15935
// begin m2 := true ;
15915: LD_ADDR_VAR 0 3
15919: PUSH
15920: LD_INT 1
15922: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15923: LD_STRING Artefact
15925: PPUSH
15926: LD_INT 1
15928: PPUSH
15929: CALL_OW 101
// end else
15933: GO 15946
// AddMedal ( Artefact , - 1 ) ;
15935: LD_STRING Artefact
15937: PPUSH
15938: LD_INT 1
15940: NEG
15941: PPUSH
15942: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
15946: LD_VAR 0 2
15950: PUSH
15951: LD_VAR 0 3
15955: AND
15956: PUSH
15957: LD_VAR 0 4
15961: AND
15962: PUSH
15963: LD_OWVAR 67
15967: PUSH
15968: LD_INT 3
15970: GREATEREQUAL
15971: AND
15972: IFFALSE 15984
// SetAchievementEX ( ACH_AMER , 11 ) ;
15974: LD_STRING ACH_AMER
15976: PPUSH
15977: LD_INT 11
15979: PPUSH
15980: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15984: LD_VAR 0 2
15988: PUSH
15989: LD_VAR 0 3
15993: AND
15994: PUSH
15995: LD_VAR 0 4
15999: AND
16000: PUSH
16001: LD_EXP 17
16005: PUSH
16006: LD_INT 0
16008: EQUAL
16009: AND
16010: IFFALSE 16026
// begin wait ( 3 ) ;
16012: LD_INT 3
16014: PPUSH
16015: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16019: LD_STRING ACH_GENERAL
16021: PPUSH
16022: CALL_OW 543
// end ; if tick <= 100 100$00 then
16026: LD_OWVAR 1
16030: PUSH
16031: LD_INT 210000
16033: LESSEQUAL
16034: IFFALSE 16050
// begin wait ( 3 ) ;
16036: LD_INT 3
16038: PPUSH
16039: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16043: LD_STRING ACH_ASPEED_11
16045: PPUSH
16046: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16050: LD_STRING MAIN
16052: PPUSH
16053: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16057: LD_ADDR_EXP 19
16061: PUSH
16062: LD_EXP 19
16066: PPUSH
16067: LD_INT 51
16069: PUSH
16070: EMPTY
16071: LIST
16072: PPUSH
16073: CALL_OW 72
16077: ST_TO_ADDR
// tmp := JMM ^ selected ;
16078: LD_ADDR_VAR 0 1
16082: PUSH
16083: LD_EXP 21
16087: PUSH
16088: LD_EXP 19
16092: ADD
16093: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16094: LD_VAR 0 1
16098: PPUSH
16099: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16103: LD_VAR 0 1
16107: PUSH
16108: LD_EXP 21
16112: PUSH
16113: LD_EXP 22
16117: PUSH
16118: LD_EXP 23
16122: PUSH
16123: LD_EXP 24
16127: PUSH
16128: LD_EXP 25
16132: PUSH
16133: LD_EXP 26
16137: PUSH
16138: LD_EXP 27
16142: PUSH
16143: LD_EXP 28
16147: PUSH
16148: LD_EXP 29
16152: PUSH
16153: LD_EXP 31
16157: PUSH
16158: LD_EXP 32
16162: PUSH
16163: LD_EXP 33
16167: PUSH
16168: LD_EXP 34
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: LIST
16177: LIST
16178: LIST
16179: LIST
16180: LIST
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: LIST
16186: LIST
16187: DIFF
16188: PPUSH
16189: LD_STRING 11c_others
16191: PPUSH
16192: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16196: LD_EXP 21
16200: PPUSH
16201: LD_EXP 3
16205: PUSH
16206: LD_STRING JMM
16208: STR
16209: PPUSH
16210: CALL_OW 38
// if Lisa then
16214: LD_EXP 22
16218: IFFALSE 16238
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16220: LD_EXP 22
16224: PPUSH
16225: LD_EXP 3
16229: PUSH
16230: LD_STRING Lisa
16232: STR
16233: PPUSH
16234: CALL_OW 38
// if Donaldson then
16238: LD_EXP 23
16242: IFFALSE 16262
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16244: LD_EXP 23
16248: PPUSH
16249: LD_EXP 3
16253: PUSH
16254: LD_STRING Donaldson
16256: STR
16257: PPUSH
16258: CALL_OW 38
// if Bobby then
16262: LD_EXP 24
16266: IFFALSE 16286
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16268: LD_EXP 24
16272: PPUSH
16273: LD_EXP 3
16277: PUSH
16278: LD_STRING Bobby
16280: STR
16281: PPUSH
16282: CALL_OW 38
// if Cyrus then
16286: LD_EXP 25
16290: IFFALSE 16310
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16292: LD_EXP 25
16296: PPUSH
16297: LD_EXP 3
16301: PUSH
16302: LD_STRING Cyrus
16304: STR
16305: PPUSH
16306: CALL_OW 38
// if Denis then
16310: LD_EXP 26
16314: IFFALSE 16334
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16316: LD_EXP 26
16320: PPUSH
16321: LD_EXP 3
16325: PUSH
16326: LD_STRING Denis
16328: STR
16329: PPUSH
16330: CALL_OW 38
// if Brown then
16334: LD_EXP 27
16338: IFFALSE 16358
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16340: LD_EXP 27
16344: PPUSH
16345: LD_EXP 3
16349: PUSH
16350: LD_STRING Brown
16352: STR
16353: PPUSH
16354: CALL_OW 38
// if Gladstone then
16358: LD_EXP 28
16362: IFFALSE 16382
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16364: LD_EXP 28
16368: PPUSH
16369: LD_EXP 3
16373: PUSH
16374: LD_STRING Gladstone
16376: STR
16377: PPUSH
16378: CALL_OW 38
// if Houten then
16382: LD_EXP 29
16386: IFFALSE 16406
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16388: LD_EXP 29
16392: PPUSH
16393: LD_EXP 3
16397: PUSH
16398: LD_STRING Houten
16400: STR
16401: PPUSH
16402: CALL_OW 38
// if Cornel then
16406: LD_EXP 31
16410: IFFALSE 16430
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16412: LD_EXP 31
16416: PPUSH
16417: LD_EXP 3
16421: PUSH
16422: LD_STRING Cornell
16424: STR
16425: PPUSH
16426: CALL_OW 38
// if Gary then
16430: LD_EXP 32
16434: IFFALSE 16454
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16436: LD_EXP 32
16440: PPUSH
16441: LD_EXP 3
16445: PUSH
16446: LD_STRING Gary
16448: STR
16449: PPUSH
16450: CALL_OW 38
// if Frank then
16454: LD_EXP 33
16458: IFFALSE 16478
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16460: LD_EXP 33
16464: PPUSH
16465: LD_EXP 3
16469: PUSH
16470: LD_STRING Frank
16472: STR
16473: PPUSH
16474: CALL_OW 38
// if Kikuchi then
16478: LD_EXP 34
16482: IFFALSE 16502
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16484: LD_EXP 34
16488: PPUSH
16489: LD_EXP 3
16493: PUSH
16494: LD_STRING Kikuchi
16496: STR
16497: PPUSH
16498: CALL_OW 38
// YouWin ;
16502: CALL_OW 103
// end ;
16506: PPOPN 4
16508: END
// export function CanSayRand ( side ) ; begin
16509: LD_INT 0
16511: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16512: LD_ADDR_VAR 0 2
16516: PUSH
16517: LD_INT 52
16519: PUSH
16520: EMPTY
16521: LIST
16522: PUSH
16523: LD_INT 22
16525: PUSH
16526: LD_VAR 0 1
16530: PUSH
16531: EMPTY
16532: LIST
16533: LIST
16534: PUSH
16535: LD_INT 2
16537: PUSH
16538: LD_INT 25
16540: PUSH
16541: LD_INT 1
16543: PUSH
16544: EMPTY
16545: LIST
16546: LIST
16547: PUSH
16548: LD_INT 25
16550: PUSH
16551: LD_INT 2
16553: PUSH
16554: EMPTY
16555: LIST
16556: LIST
16557: PUSH
16558: LD_INT 25
16560: PUSH
16561: LD_INT 3
16563: PUSH
16564: EMPTY
16565: LIST
16566: LIST
16567: PUSH
16568: LD_INT 25
16570: PUSH
16571: LD_INT 4
16573: PUSH
16574: EMPTY
16575: LIST
16576: LIST
16577: PUSH
16578: EMPTY
16579: LIST
16580: LIST
16581: LIST
16582: LIST
16583: LIST
16584: PUSH
16585: EMPTY
16586: LIST
16587: LIST
16588: LIST
16589: PPUSH
16590: CALL_OW 69
16594: PUSH
16595: LD_EXP 21
16599: PUSH
16600: LD_EXP 33
16604: PUSH
16605: LD_EXP 22
16609: PUSH
16610: LD_EXP 23
16614: PUSH
16615: LD_EXP 24
16619: PUSH
16620: LD_EXP 25
16624: PUSH
16625: LD_EXP 26
16629: PUSH
16630: LD_EXP 27
16634: PUSH
16635: LD_EXP 28
16639: PUSH
16640: LD_EXP 29
16644: PUSH
16645: LD_EXP 30
16649: PUSH
16650: LD_EXP 31
16654: PUSH
16655: LD_EXP 32
16659: PUSH
16660: LD_EXP 34
16664: PUSH
16665: EMPTY
16666: LIST
16667: LIST
16668: LIST
16669: LIST
16670: LIST
16671: LIST
16672: LIST
16673: LIST
16674: LIST
16675: LIST
16676: LIST
16677: LIST
16678: LIST
16679: LIST
16680: DIFF
16681: ST_TO_ADDR
// end ;
16682: LD_VAR 0 2
16686: RET
// export function SayRand ( sex , dial ) ; begin
16687: LD_INT 0
16689: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16690: LD_ADDR_VAR 0 3
16694: PUSH
16695: LD_INT 52
16697: PUSH
16698: EMPTY
16699: LIST
16700: PUSH
16701: LD_INT 22
16703: PUSH
16704: LD_INT 1
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: PUSH
16711: LD_INT 26
16713: PUSH
16714: LD_VAR 0 1
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: PUSH
16723: LD_INT 2
16725: PUSH
16726: LD_INT 25
16728: PUSH
16729: LD_INT 1
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: LD_INT 25
16738: PUSH
16739: LD_INT 2
16741: PUSH
16742: EMPTY
16743: LIST
16744: LIST
16745: PUSH
16746: LD_INT 25
16748: PUSH
16749: LD_INT 3
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: PUSH
16756: LD_INT 25
16758: PUSH
16759: LD_INT 4
16761: PUSH
16762: EMPTY
16763: LIST
16764: LIST
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: LIST
16770: LIST
16771: LIST
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: LIST
16777: LIST
16778: PPUSH
16779: CALL_OW 69
16783: PUSH
16784: LD_EXP 21
16788: PUSH
16789: LD_EXP 33
16793: PUSH
16794: LD_EXP 22
16798: PUSH
16799: LD_EXP 23
16803: PUSH
16804: LD_EXP 24
16808: PUSH
16809: LD_EXP 25
16813: PUSH
16814: LD_EXP 26
16818: PUSH
16819: LD_EXP 27
16823: PUSH
16824: LD_EXP 28
16828: PUSH
16829: LD_EXP 29
16833: PUSH
16834: LD_EXP 30
16838: PUSH
16839: LD_EXP 31
16843: PUSH
16844: LD_EXP 32
16848: PUSH
16849: LD_EXP 34
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: LIST
16858: LIST
16859: LIST
16860: LIST
16861: LIST
16862: LIST
16863: LIST
16864: LIST
16865: LIST
16866: LIST
16867: LIST
16868: LIST
16869: DIFF
16870: ST_TO_ADDR
// if not result then
16871: LD_VAR 0 3
16875: NOT
16876: IFFALSE 16880
// exit ;
16878: GO 16908
// result := result [ 1 ] ;
16880: LD_ADDR_VAR 0 3
16884: PUSH
16885: LD_VAR 0 3
16889: PUSH
16890: LD_INT 1
16892: ARRAY
16893: ST_TO_ADDR
// Say ( result , dial ) ;
16894: LD_VAR 0 3
16898: PPUSH
16899: LD_VAR 0 2
16903: PPUSH
16904: CALL_OW 88
// end ;
16908: LD_VAR 0 3
16912: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16913: LD_INT 0
16915: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16916: LD_ADDR_VAR 0 4
16920: PUSH
16921: LD_INT 22
16923: PUSH
16924: LD_INT 1
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: PUSH
16931: LD_INT 26
16933: PUSH
16934: LD_VAR 0 1
16938: PUSH
16939: EMPTY
16940: LIST
16941: LIST
16942: PUSH
16943: LD_INT 2
16945: PUSH
16946: LD_INT 25
16948: PUSH
16949: LD_INT 1
16951: PUSH
16952: EMPTY
16953: LIST
16954: LIST
16955: PUSH
16956: LD_INT 25
16958: PUSH
16959: LD_INT 2
16961: PUSH
16962: EMPTY
16963: LIST
16964: LIST
16965: PUSH
16966: LD_INT 25
16968: PUSH
16969: LD_INT 3
16971: PUSH
16972: EMPTY
16973: LIST
16974: LIST
16975: PUSH
16976: LD_INT 25
16978: PUSH
16979: LD_INT 4
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: LIST
16997: PPUSH
16998: CALL_OW 69
17002: PUSH
17003: LD_EXP 21
17007: PUSH
17008: LD_EXP 33
17012: PUSH
17013: LD_EXP 22
17017: PUSH
17018: LD_EXP 23
17022: PUSH
17023: LD_EXP 24
17027: PUSH
17028: LD_EXP 25
17032: PUSH
17033: LD_EXP 26
17037: PUSH
17038: LD_EXP 27
17042: PUSH
17043: LD_EXP 28
17047: PUSH
17048: LD_EXP 29
17052: PUSH
17053: LD_EXP 30
17057: PUSH
17058: LD_EXP 31
17062: PUSH
17063: LD_EXP 32
17067: PUSH
17068: LD_EXP 34
17072: PUSH
17073: EMPTY
17074: LIST
17075: LIST
17076: LIST
17077: LIST
17078: LIST
17079: LIST
17080: LIST
17081: LIST
17082: LIST
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: LIST
17088: PUSH
17089: LD_VAR 0 3
17093: ADD
17094: DIFF
17095: ST_TO_ADDR
// if not result then
17096: LD_VAR 0 4
17100: NOT
17101: IFFALSE 17105
// exit ;
17103: GO 17133
// result := result [ 1 ] ;
17105: LD_ADDR_VAR 0 4
17109: PUSH
17110: LD_VAR 0 4
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: ST_TO_ADDR
// Say ( result , dial ) ;
17119: LD_VAR 0 4
17123: PPUSH
17124: LD_VAR 0 2
17128: PPUSH
17129: CALL_OW 88
// end ; end_of_file
17133: LD_VAR 0 4
17137: RET
// export function CustomEvent ( event ) ; begin
17138: LD_INT 0
17140: PPUSH
// end ;
17141: LD_VAR 0 2
17145: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17146: LD_VAR 0 1
17150: PPUSH
17151: CALL_OW 255
17155: PUSH
17156: LD_INT 1
17158: EQUAL
17159: IFFALSE 17169
// artifact_get := true ;
17161: LD_ADDR_EXP 13
17165: PUSH
17166: LD_INT 1
17168: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17169: LD_VAR 0 1
17173: PPUSH
17174: CALL_OW 255
17178: PUSH
17179: LD_INT 2
17181: EQUAL
17182: IFFALSE 17200
// begin artifact_get := false ;
17184: LD_ADDR_EXP 13
17188: PUSH
17189: LD_INT 0
17191: ST_TO_ADDR
// artifact_stolen := true ;
17192: LD_ADDR_EXP 12
17196: PUSH
17197: LD_INT 1
17199: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17200: LD_ADDR_EXP 14
17204: PUSH
17205: LD_INT 1
17207: ST_TO_ADDR
// end ;
17208: PPOPN 2
17210: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17211: LD_ADDR_EXP 14
17215: PUSH
17216: LD_INT 0
17218: ST_TO_ADDR
// end ;
17219: PPOPN 2
17221: END
// on UnitDestroyed ( un ) do begin if un = JMM then
17222: LD_VAR 0 1
17226: PUSH
17227: LD_EXP 21
17231: EQUAL
17232: IFFALSE 17243
// begin YouLost ( JMM ) ;
17234: LD_STRING JMM
17236: PPUSH
17237: CALL_OW 104
// exit ;
17241: GO 17375
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17243: LD_VAR 0 1
17247: PUSH
17248: LD_INT 22
17250: PUSH
17251: LD_INT 1
17253: PUSH
17254: EMPTY
17255: LIST
17256: LIST
17257: PUSH
17258: LD_INT 21
17260: PUSH
17261: LD_INT 1
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: PUSH
17268: LD_INT 2
17270: PUSH
17271: LD_INT 25
17273: PUSH
17274: LD_INT 1
17276: PUSH
17277: EMPTY
17278: LIST
17279: LIST
17280: PUSH
17281: LD_INT 25
17283: PUSH
17284: LD_INT 2
17286: PUSH
17287: EMPTY
17288: LIST
17289: LIST
17290: PUSH
17291: LD_INT 25
17293: PUSH
17294: LD_INT 3
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: PUSH
17301: LD_INT 25
17303: PUSH
17304: LD_INT 4
17306: PUSH
17307: EMPTY
17308: LIST
17309: LIST
17310: PUSH
17311: LD_INT 25
17313: PUSH
17314: LD_INT 5
17316: PUSH
17317: EMPTY
17318: LIST
17319: LIST
17320: PUSH
17321: LD_INT 25
17323: PUSH
17324: LD_INT 8
17326: PUSH
17327: EMPTY
17328: LIST
17329: LIST
17330: PUSH
17331: EMPTY
17332: LIST
17333: LIST
17334: LIST
17335: LIST
17336: LIST
17337: LIST
17338: LIST
17339: PUSH
17340: EMPTY
17341: LIST
17342: LIST
17343: LIST
17344: PPUSH
17345: CALL_OW 69
17349: IN
17350: IFFALSE 17366
// loses_counter := loses_counter + 1 ;
17352: LD_ADDR_EXP 17
17356: PUSH
17357: LD_EXP 17
17361: PUSH
17362: LD_INT 1
17364: PLUS
17365: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17366: LD_VAR 0 1
17370: PPUSH
17371: CALL 45569 0 1
// end ;
17375: PPOPN 1
17377: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17378: LD_VAR 0 1
17382: PPUSH
17383: LD_VAR 0 2
17387: PPUSH
17388: CALL 47903 0 2
// end ;
17392: PPOPN 2
17394: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17395: LD_VAR 0 1
17399: PPUSH
17400: CALL 47212 0 1
// end ;
17404: PPOPN 1
17406: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17407: LD_VAR 0 1
17411: PPUSH
17412: LD_VAR 0 2
17416: PPUSH
17417: LD_VAR 0 3
17421: PPUSH
17422: LD_VAR 0 4
17426: PPUSH
17427: LD_VAR 0 5
17431: PPUSH
17432: CALL 44885 0 5
// end ;
17436: PPOPN 5
17438: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
17439: LD_VAR 0 1
17443: PPUSH
17444: CALL_OW 248
17448: PUSH
17449: LD_INT 1
17451: EQUAL
17452: IFFALSE 17462
// am_veh_consturcted := true ;
17454: LD_ADDR_EXP 20
17458: PUSH
17459: LD_INT 1
17461: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17462: LD_VAR 0 1
17466: PPUSH
17467: LD_VAR 0 2
17471: PPUSH
17472: CALL 44466 0 2
// end ;
17476: PPOPN 2
17478: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17479: LD_VAR 0 1
17483: PPUSH
17484: CALL_OW 247
17488: PUSH
17489: LD_INT 2
17491: EQUAL
17492: IFFALSE 17496
// exit ;
17494: GO 17513
// if not kamikazed then
17496: LD_EXP 11
17500: NOT
17501: IFFALSE 17513
// kamikazed := unit ;
17503: LD_ADDR_EXP 11
17507: PUSH
17508: LD_VAR 0 1
17512: ST_TO_ADDR
// end ;
17513: PPOPN 1
17515: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17516: LD_INT 0
17518: PPUSH
17519: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17520: LD_VAR 0 1
17524: PPUSH
17525: LD_VAR 0 2
17529: PPUSH
17530: LD_VAR 0 3
17534: PPUSH
17535: LD_VAR 0 4
17539: PPUSH
17540: CALL 44304 0 4
// end ;
17544: PPOPN 6
17546: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17547: LD_VAR 0 1
17551: PPUSH
17552: LD_VAR 0 2
17556: PPUSH
17557: LD_VAR 0 3
17561: PPUSH
17562: CALL 44079 0 3
// end ;
17566: PPOPN 3
17568: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17569: LD_VAR 0 1
17573: PPUSH
17574: LD_VAR 0 2
17578: PPUSH
17579: CALL 45265 0 2
// end ;
17583: PPOPN 2
17585: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17586: LD_VAR 0 1
17590: PPUSH
17591: LD_VAR 0 2
17595: PPUSH
17596: CALL 43773 0 2
// end ;
17600: PPOPN 2
17602: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17603: LD_VAR 0 1
17607: PPUSH
17608: LD_VAR 0 2
17612: PPUSH
17613: CALL 43964 0 2
// end ;
17617: PPOPN 2
17619: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17620: LD_VAR 0 1
17624: PPUSH
17625: CALL 46971 0 1
// end ;
17629: PPOPN 1
17631: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17632: LD_VAR 0 1
17636: PPUSH
17637: LD_VAR 0 2
17641: PPUSH
17642: CALL 48198 0 2
// end ;
17646: PPOPN 2
17648: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17649: LD_VAR 0 1
17653: PPUSH
17654: LD_VAR 0 2
17658: PPUSH
17659: LD_VAR 0 3
17663: PPUSH
17664: LD_VAR 0 4
17668: PPUSH
17669: CALL 48414 0 4
// end ;
17673: PPOPN 4
17675: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17676: LD_VAR 0 1
17680: PPUSH
17681: CALL 103249 0 1
// end ; end_of_file
17685: PPOPN 1
17687: END
// every 0 0$1 trigger game do
17688: LD_EXP 2
17692: IFFALSE 17722
17694: GO 17696
17696: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17697: LD_INT 7
17699: PUSH
17700: LD_INT 6
17702: PUSH
17703: LD_INT 4
17705: PUSH
17706: LD_INT 6
17708: PUSH
17709: EMPTY
17710: LIST
17711: LIST
17712: LIST
17713: LIST
17714: PPUSH
17715: LD_INT 1750
17717: PPUSH
17718: CALL 17723 0 2
17722: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17723: LD_INT 0
17725: PPUSH
17726: PPUSH
17727: PPUSH
// if not areas then
17728: LD_VAR 0 1
17732: NOT
17733: IFFALSE 17737
// exit ;
17735: GO 17867
// repeat wait ( time ) ;
17737: LD_VAR 0 2
17741: PPUSH
17742: CALL_OW 67
// for i in areas do
17746: LD_ADDR_VAR 0 4
17750: PUSH
17751: LD_VAR 0 1
17755: PUSH
17756: FOR_IN
17757: IFFALSE 17826
// begin p := rand ( 1 , 90 ) ;
17759: LD_ADDR_VAR 0 5
17763: PUSH
17764: LD_INT 1
17766: PPUSH
17767: LD_INT 90
17769: PPUSH
17770: CALL_OW 12
17774: ST_TO_ADDR
// if Prob ( p ) then
17775: LD_VAR 0 5
17779: PPUSH
17780: CALL_OW 13
17784: IFFALSE 17824
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17786: LD_INT 2
17788: PPUSH
17789: LD_INT 5
17791: PPUSH
17792: CALL_OW 12
17796: PPUSH
17797: LD_VAR 0 4
17801: PPUSH
17802: LD_INT 1
17804: PPUSH
17805: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17809: LD_INT 735
17811: PPUSH
17812: LD_INT 1295
17814: PPUSH
17815: CALL_OW 12
17819: PPUSH
17820: CALL_OW 67
// end ; end ;
17824: GO 17756
17826: POP
17827: POP
// time := time + 0 0$3 ;
17828: LD_ADDR_VAR 0 2
17832: PUSH
17833: LD_VAR 0 2
17837: PUSH
17838: LD_INT 105
17840: PLUS
17841: ST_TO_ADDR
// if time > 6 6$00 then
17842: LD_VAR 0 2
17846: PUSH
17847: LD_INT 12600
17849: GREATER
17850: IFFALSE 17860
// time := 0 0$40 ;
17852: LD_ADDR_VAR 0 2
17856: PUSH
17857: LD_INT 1400
17859: ST_TO_ADDR
// until not game ;
17860: LD_EXP 2
17864: NOT
17865: IFFALSE 17737
// end ;
17867: LD_VAR 0 3
17871: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
17872: LD_OWVAR 1
17876: PUSH
17877: LD_INT 84000
17879: PUSH
17880: LD_INT 73500
17882: PUSH
17883: LD_INT 63000
17885: PUSH
17886: LD_INT 52500
17888: PUSH
17889: EMPTY
17890: LIST
17891: LIST
17892: LIST
17893: LIST
17894: PUSH
17895: LD_OWVAR 67
17899: ARRAY
17900: LESS
17901: IFFALSE 17928
17903: GO 17905
17905: DISABLE
// begin enable ;
17906: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17907: LD_INT 1
17909: PPUSH
17910: LD_INT 5
17912: PPUSH
17913: CALL_OW 12
17917: PPUSH
17918: LD_INT 7
17920: PPUSH
17921: LD_INT 1
17923: PPUSH
17924: CALL_OW 55
// end ; end_of_file
17928: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17929: LD_INT 0
17931: PPUSH
17932: PPUSH
// skirmish := false ;
17933: LD_ADDR_EXP 48
17937: PUSH
17938: LD_INT 0
17940: ST_TO_ADDR
// debug_mc := false ;
17941: LD_ADDR_EXP 49
17945: PUSH
17946: LD_INT 0
17948: ST_TO_ADDR
// mc_bases := [ ] ;
17949: LD_ADDR_EXP 50
17953: PUSH
17954: EMPTY
17955: ST_TO_ADDR
// mc_sides := [ ] ;
17956: LD_ADDR_EXP 76
17960: PUSH
17961: EMPTY
17962: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17963: LD_ADDR_EXP 51
17967: PUSH
17968: EMPTY
17969: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17970: LD_ADDR_EXP 52
17974: PUSH
17975: EMPTY
17976: ST_TO_ADDR
// mc_need_heal := [ ] ;
17977: LD_ADDR_EXP 53
17981: PUSH
17982: EMPTY
17983: ST_TO_ADDR
// mc_healers := [ ] ;
17984: LD_ADDR_EXP 54
17988: PUSH
17989: EMPTY
17990: ST_TO_ADDR
// mc_build_list := [ ] ;
17991: LD_ADDR_EXP 55
17995: PUSH
17996: EMPTY
17997: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17998: LD_ADDR_EXP 82
18002: PUSH
18003: EMPTY
18004: ST_TO_ADDR
// mc_builders := [ ] ;
18005: LD_ADDR_EXP 56
18009: PUSH
18010: EMPTY
18011: ST_TO_ADDR
// mc_construct_list := [ ] ;
18012: LD_ADDR_EXP 57
18016: PUSH
18017: EMPTY
18018: ST_TO_ADDR
// mc_turret_list := [ ] ;
18019: LD_ADDR_EXP 58
18023: PUSH
18024: EMPTY
18025: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18026: LD_ADDR_EXP 59
18030: PUSH
18031: EMPTY
18032: ST_TO_ADDR
// mc_miners := [ ] ;
18033: LD_ADDR_EXP 64
18037: PUSH
18038: EMPTY
18039: ST_TO_ADDR
// mc_mines := [ ] ;
18040: LD_ADDR_EXP 63
18044: PUSH
18045: EMPTY
18046: ST_TO_ADDR
// mc_minefields := [ ] ;
18047: LD_ADDR_EXP 65
18051: PUSH
18052: EMPTY
18053: ST_TO_ADDR
// mc_crates := [ ] ;
18054: LD_ADDR_EXP 66
18058: PUSH
18059: EMPTY
18060: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18061: LD_ADDR_EXP 67
18065: PUSH
18066: EMPTY
18067: ST_TO_ADDR
// mc_crates_area := [ ] ;
18068: LD_ADDR_EXP 68
18072: PUSH
18073: EMPTY
18074: ST_TO_ADDR
// mc_vehicles := [ ] ;
18075: LD_ADDR_EXP 69
18079: PUSH
18080: EMPTY
18081: ST_TO_ADDR
// mc_attack := [ ] ;
18082: LD_ADDR_EXP 70
18086: PUSH
18087: EMPTY
18088: ST_TO_ADDR
// mc_produce := [ ] ;
18089: LD_ADDR_EXP 71
18093: PUSH
18094: EMPTY
18095: ST_TO_ADDR
// mc_defender := [ ] ;
18096: LD_ADDR_EXP 72
18100: PUSH
18101: EMPTY
18102: ST_TO_ADDR
// mc_parking := [ ] ;
18103: LD_ADDR_EXP 74
18107: PUSH
18108: EMPTY
18109: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18110: LD_ADDR_EXP 60
18114: PUSH
18115: EMPTY
18116: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18117: LD_ADDR_EXP 62
18121: PUSH
18122: EMPTY
18123: ST_TO_ADDR
// mc_scan := [ ] ;
18124: LD_ADDR_EXP 73
18128: PUSH
18129: EMPTY
18130: ST_TO_ADDR
// mc_scan_area := [ ] ;
18131: LD_ADDR_EXP 75
18135: PUSH
18136: EMPTY
18137: ST_TO_ADDR
// mc_tech := [ ] ;
18138: LD_ADDR_EXP 77
18142: PUSH
18143: EMPTY
18144: ST_TO_ADDR
// mc_class := [ ] ;
18145: LD_ADDR_EXP 91
18149: PUSH
18150: EMPTY
18151: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18152: LD_ADDR_EXP 92
18156: PUSH
18157: EMPTY
18158: ST_TO_ADDR
// mc_is_defending := [ ] ;
18159: LD_ADDR_EXP 93
18163: PUSH
18164: EMPTY
18165: ST_TO_ADDR
// end ;
18166: LD_VAR 0 1
18170: RET
// export function MC_Kill ( base ) ; begin
18171: LD_INT 0
18173: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18174: LD_ADDR_EXP 50
18178: PUSH
18179: LD_EXP 50
18183: PPUSH
18184: LD_VAR 0 1
18188: PPUSH
18189: EMPTY
18190: PPUSH
18191: CALL_OW 1
18195: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18196: LD_ADDR_EXP 51
18200: PUSH
18201: LD_EXP 51
18205: PPUSH
18206: LD_VAR 0 1
18210: PPUSH
18211: EMPTY
18212: PPUSH
18213: CALL_OW 1
18217: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18218: LD_ADDR_EXP 52
18222: PUSH
18223: LD_EXP 52
18227: PPUSH
18228: LD_VAR 0 1
18232: PPUSH
18233: EMPTY
18234: PPUSH
18235: CALL_OW 1
18239: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18240: LD_ADDR_EXP 53
18244: PUSH
18245: LD_EXP 53
18249: PPUSH
18250: LD_VAR 0 1
18254: PPUSH
18255: EMPTY
18256: PPUSH
18257: CALL_OW 1
18261: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18262: LD_ADDR_EXP 54
18266: PUSH
18267: LD_EXP 54
18271: PPUSH
18272: LD_VAR 0 1
18276: PPUSH
18277: EMPTY
18278: PPUSH
18279: CALL_OW 1
18283: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18284: LD_ADDR_EXP 55
18288: PUSH
18289: LD_EXP 55
18293: PPUSH
18294: LD_VAR 0 1
18298: PPUSH
18299: EMPTY
18300: PPUSH
18301: CALL_OW 1
18305: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18306: LD_ADDR_EXP 56
18310: PUSH
18311: LD_EXP 56
18315: PPUSH
18316: LD_VAR 0 1
18320: PPUSH
18321: EMPTY
18322: PPUSH
18323: CALL_OW 1
18327: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18328: LD_ADDR_EXP 57
18332: PUSH
18333: LD_EXP 57
18337: PPUSH
18338: LD_VAR 0 1
18342: PPUSH
18343: EMPTY
18344: PPUSH
18345: CALL_OW 1
18349: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18350: LD_ADDR_EXP 58
18354: PUSH
18355: LD_EXP 58
18359: PPUSH
18360: LD_VAR 0 1
18364: PPUSH
18365: EMPTY
18366: PPUSH
18367: CALL_OW 1
18371: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18372: LD_ADDR_EXP 59
18376: PUSH
18377: LD_EXP 59
18381: PPUSH
18382: LD_VAR 0 1
18386: PPUSH
18387: EMPTY
18388: PPUSH
18389: CALL_OW 1
18393: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18394: LD_ADDR_EXP 60
18398: PUSH
18399: LD_EXP 60
18403: PPUSH
18404: LD_VAR 0 1
18408: PPUSH
18409: EMPTY
18410: PPUSH
18411: CALL_OW 1
18415: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18416: LD_ADDR_EXP 61
18420: PUSH
18421: LD_EXP 61
18425: PPUSH
18426: LD_VAR 0 1
18430: PPUSH
18431: LD_INT 0
18433: PPUSH
18434: CALL_OW 1
18438: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18439: LD_ADDR_EXP 62
18443: PUSH
18444: LD_EXP 62
18448: PPUSH
18449: LD_VAR 0 1
18453: PPUSH
18454: EMPTY
18455: PPUSH
18456: CALL_OW 1
18460: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18461: LD_ADDR_EXP 63
18465: PUSH
18466: LD_EXP 63
18470: PPUSH
18471: LD_VAR 0 1
18475: PPUSH
18476: EMPTY
18477: PPUSH
18478: CALL_OW 1
18482: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18483: LD_ADDR_EXP 64
18487: PUSH
18488: LD_EXP 64
18492: PPUSH
18493: LD_VAR 0 1
18497: PPUSH
18498: EMPTY
18499: PPUSH
18500: CALL_OW 1
18504: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18505: LD_ADDR_EXP 65
18509: PUSH
18510: LD_EXP 65
18514: PPUSH
18515: LD_VAR 0 1
18519: PPUSH
18520: EMPTY
18521: PPUSH
18522: CALL_OW 1
18526: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18527: LD_ADDR_EXP 66
18531: PUSH
18532: LD_EXP 66
18536: PPUSH
18537: LD_VAR 0 1
18541: PPUSH
18542: EMPTY
18543: PPUSH
18544: CALL_OW 1
18548: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18549: LD_ADDR_EXP 67
18553: PUSH
18554: LD_EXP 67
18558: PPUSH
18559: LD_VAR 0 1
18563: PPUSH
18564: EMPTY
18565: PPUSH
18566: CALL_OW 1
18570: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18571: LD_ADDR_EXP 68
18575: PUSH
18576: LD_EXP 68
18580: PPUSH
18581: LD_VAR 0 1
18585: PPUSH
18586: EMPTY
18587: PPUSH
18588: CALL_OW 1
18592: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18593: LD_ADDR_EXP 69
18597: PUSH
18598: LD_EXP 69
18602: PPUSH
18603: LD_VAR 0 1
18607: PPUSH
18608: EMPTY
18609: PPUSH
18610: CALL_OW 1
18614: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18615: LD_ADDR_EXP 70
18619: PUSH
18620: LD_EXP 70
18624: PPUSH
18625: LD_VAR 0 1
18629: PPUSH
18630: EMPTY
18631: PPUSH
18632: CALL_OW 1
18636: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18637: LD_ADDR_EXP 71
18641: PUSH
18642: LD_EXP 71
18646: PPUSH
18647: LD_VAR 0 1
18651: PPUSH
18652: EMPTY
18653: PPUSH
18654: CALL_OW 1
18658: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18659: LD_ADDR_EXP 72
18663: PUSH
18664: LD_EXP 72
18668: PPUSH
18669: LD_VAR 0 1
18673: PPUSH
18674: EMPTY
18675: PPUSH
18676: CALL_OW 1
18680: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18681: LD_ADDR_EXP 73
18685: PUSH
18686: LD_EXP 73
18690: PPUSH
18691: LD_VAR 0 1
18695: PPUSH
18696: EMPTY
18697: PPUSH
18698: CALL_OW 1
18702: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18703: LD_ADDR_EXP 74
18707: PUSH
18708: LD_EXP 74
18712: PPUSH
18713: LD_VAR 0 1
18717: PPUSH
18718: EMPTY
18719: PPUSH
18720: CALL_OW 1
18724: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18725: LD_ADDR_EXP 75
18729: PUSH
18730: LD_EXP 75
18734: PPUSH
18735: LD_VAR 0 1
18739: PPUSH
18740: EMPTY
18741: PPUSH
18742: CALL_OW 1
18746: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18747: LD_ADDR_EXP 77
18751: PUSH
18752: LD_EXP 77
18756: PPUSH
18757: LD_VAR 0 1
18761: PPUSH
18762: EMPTY
18763: PPUSH
18764: CALL_OW 1
18768: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18769: LD_ADDR_EXP 79
18773: PUSH
18774: LD_EXP 79
18778: PPUSH
18779: LD_VAR 0 1
18783: PPUSH
18784: EMPTY
18785: PPUSH
18786: CALL_OW 1
18790: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18791: LD_ADDR_EXP 80
18795: PUSH
18796: LD_EXP 80
18800: PPUSH
18801: LD_VAR 0 1
18805: PPUSH
18806: EMPTY
18807: PPUSH
18808: CALL_OW 1
18812: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18813: LD_ADDR_EXP 81
18817: PUSH
18818: LD_EXP 81
18822: PPUSH
18823: LD_VAR 0 1
18827: PPUSH
18828: EMPTY
18829: PPUSH
18830: CALL_OW 1
18834: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18835: LD_ADDR_EXP 82
18839: PUSH
18840: LD_EXP 82
18844: PPUSH
18845: LD_VAR 0 1
18849: PPUSH
18850: EMPTY
18851: PPUSH
18852: CALL_OW 1
18856: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18857: LD_ADDR_EXP 83
18861: PUSH
18862: LD_EXP 83
18866: PPUSH
18867: LD_VAR 0 1
18871: PPUSH
18872: EMPTY
18873: PPUSH
18874: CALL_OW 1
18878: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18879: LD_ADDR_EXP 84
18883: PUSH
18884: LD_EXP 84
18888: PPUSH
18889: LD_VAR 0 1
18893: PPUSH
18894: EMPTY
18895: PPUSH
18896: CALL_OW 1
18900: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18901: LD_ADDR_EXP 85
18905: PUSH
18906: LD_EXP 85
18910: PPUSH
18911: LD_VAR 0 1
18915: PPUSH
18916: EMPTY
18917: PPUSH
18918: CALL_OW 1
18922: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18923: LD_ADDR_EXP 86
18927: PUSH
18928: LD_EXP 86
18932: PPUSH
18933: LD_VAR 0 1
18937: PPUSH
18938: EMPTY
18939: PPUSH
18940: CALL_OW 1
18944: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18945: LD_ADDR_EXP 87
18949: PUSH
18950: LD_EXP 87
18954: PPUSH
18955: LD_VAR 0 1
18959: PPUSH
18960: EMPTY
18961: PPUSH
18962: CALL_OW 1
18966: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18967: LD_ADDR_EXP 88
18971: PUSH
18972: LD_EXP 88
18976: PPUSH
18977: LD_VAR 0 1
18981: PPUSH
18982: EMPTY
18983: PPUSH
18984: CALL_OW 1
18988: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18989: LD_ADDR_EXP 89
18993: PUSH
18994: LD_EXP 89
18998: PPUSH
18999: LD_VAR 0 1
19003: PPUSH
19004: EMPTY
19005: PPUSH
19006: CALL_OW 1
19010: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19011: LD_ADDR_EXP 90
19015: PUSH
19016: LD_EXP 90
19020: PPUSH
19021: LD_VAR 0 1
19025: PPUSH
19026: EMPTY
19027: PPUSH
19028: CALL_OW 1
19032: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19033: LD_ADDR_EXP 91
19037: PUSH
19038: LD_EXP 91
19042: PPUSH
19043: LD_VAR 0 1
19047: PPUSH
19048: EMPTY
19049: PPUSH
19050: CALL_OW 1
19054: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19055: LD_ADDR_EXP 92
19059: PUSH
19060: LD_EXP 92
19064: PPUSH
19065: LD_VAR 0 1
19069: PPUSH
19070: LD_INT 0
19072: PPUSH
19073: CALL_OW 1
19077: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19078: LD_ADDR_EXP 93
19082: PUSH
19083: LD_EXP 93
19087: PPUSH
19088: LD_VAR 0 1
19092: PPUSH
19093: LD_INT 0
19095: PPUSH
19096: CALL_OW 1
19100: ST_TO_ADDR
// end ;
19101: LD_VAR 0 2
19105: RET
// export function MC_Add ( side , units ) ; var base ; begin
19106: LD_INT 0
19108: PPUSH
19109: PPUSH
// base := mc_bases + 1 ;
19110: LD_ADDR_VAR 0 4
19114: PUSH
19115: LD_EXP 50
19119: PUSH
19120: LD_INT 1
19122: PLUS
19123: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19124: LD_ADDR_EXP 76
19128: PUSH
19129: LD_EXP 76
19133: PPUSH
19134: LD_VAR 0 4
19138: PPUSH
19139: LD_VAR 0 1
19143: PPUSH
19144: CALL_OW 1
19148: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19149: LD_ADDR_EXP 50
19153: PUSH
19154: LD_EXP 50
19158: PPUSH
19159: LD_VAR 0 4
19163: PPUSH
19164: LD_VAR 0 2
19168: PPUSH
19169: CALL_OW 1
19173: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19174: LD_ADDR_EXP 51
19178: PUSH
19179: LD_EXP 51
19183: PPUSH
19184: LD_VAR 0 4
19188: PPUSH
19189: EMPTY
19190: PPUSH
19191: CALL_OW 1
19195: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19196: LD_ADDR_EXP 52
19200: PUSH
19201: LD_EXP 52
19205: PPUSH
19206: LD_VAR 0 4
19210: PPUSH
19211: EMPTY
19212: PPUSH
19213: CALL_OW 1
19217: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19218: LD_ADDR_EXP 53
19222: PUSH
19223: LD_EXP 53
19227: PPUSH
19228: LD_VAR 0 4
19232: PPUSH
19233: EMPTY
19234: PPUSH
19235: CALL_OW 1
19239: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19240: LD_ADDR_EXP 54
19244: PUSH
19245: LD_EXP 54
19249: PPUSH
19250: LD_VAR 0 4
19254: PPUSH
19255: EMPTY
19256: PPUSH
19257: CALL_OW 1
19261: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19262: LD_ADDR_EXP 55
19266: PUSH
19267: LD_EXP 55
19271: PPUSH
19272: LD_VAR 0 4
19276: PPUSH
19277: EMPTY
19278: PPUSH
19279: CALL_OW 1
19283: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19284: LD_ADDR_EXP 56
19288: PUSH
19289: LD_EXP 56
19293: PPUSH
19294: LD_VAR 0 4
19298: PPUSH
19299: EMPTY
19300: PPUSH
19301: CALL_OW 1
19305: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19306: LD_ADDR_EXP 57
19310: PUSH
19311: LD_EXP 57
19315: PPUSH
19316: LD_VAR 0 4
19320: PPUSH
19321: EMPTY
19322: PPUSH
19323: CALL_OW 1
19327: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19328: LD_ADDR_EXP 58
19332: PUSH
19333: LD_EXP 58
19337: PPUSH
19338: LD_VAR 0 4
19342: PPUSH
19343: EMPTY
19344: PPUSH
19345: CALL_OW 1
19349: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19350: LD_ADDR_EXP 59
19354: PUSH
19355: LD_EXP 59
19359: PPUSH
19360: LD_VAR 0 4
19364: PPUSH
19365: EMPTY
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19372: LD_ADDR_EXP 60
19376: PUSH
19377: LD_EXP 60
19381: PPUSH
19382: LD_VAR 0 4
19386: PPUSH
19387: EMPTY
19388: PPUSH
19389: CALL_OW 1
19393: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19394: LD_ADDR_EXP 61
19398: PUSH
19399: LD_EXP 61
19403: PPUSH
19404: LD_VAR 0 4
19408: PPUSH
19409: LD_INT 0
19411: PPUSH
19412: CALL_OW 1
19416: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19417: LD_ADDR_EXP 62
19421: PUSH
19422: LD_EXP 62
19426: PPUSH
19427: LD_VAR 0 4
19431: PPUSH
19432: EMPTY
19433: PPUSH
19434: CALL_OW 1
19438: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19439: LD_ADDR_EXP 63
19443: PUSH
19444: LD_EXP 63
19448: PPUSH
19449: LD_VAR 0 4
19453: PPUSH
19454: EMPTY
19455: PPUSH
19456: CALL_OW 1
19460: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19461: LD_ADDR_EXP 64
19465: PUSH
19466: LD_EXP 64
19470: PPUSH
19471: LD_VAR 0 4
19475: PPUSH
19476: EMPTY
19477: PPUSH
19478: CALL_OW 1
19482: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19483: LD_ADDR_EXP 65
19487: PUSH
19488: LD_EXP 65
19492: PPUSH
19493: LD_VAR 0 4
19497: PPUSH
19498: EMPTY
19499: PPUSH
19500: CALL_OW 1
19504: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19505: LD_ADDR_EXP 66
19509: PUSH
19510: LD_EXP 66
19514: PPUSH
19515: LD_VAR 0 4
19519: PPUSH
19520: EMPTY
19521: PPUSH
19522: CALL_OW 1
19526: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19527: LD_ADDR_EXP 67
19531: PUSH
19532: LD_EXP 67
19536: PPUSH
19537: LD_VAR 0 4
19541: PPUSH
19542: EMPTY
19543: PPUSH
19544: CALL_OW 1
19548: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19549: LD_ADDR_EXP 68
19553: PUSH
19554: LD_EXP 68
19558: PPUSH
19559: LD_VAR 0 4
19563: PPUSH
19564: EMPTY
19565: PPUSH
19566: CALL_OW 1
19570: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19571: LD_ADDR_EXP 69
19575: PUSH
19576: LD_EXP 69
19580: PPUSH
19581: LD_VAR 0 4
19585: PPUSH
19586: EMPTY
19587: PPUSH
19588: CALL_OW 1
19592: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19593: LD_ADDR_EXP 70
19597: PUSH
19598: LD_EXP 70
19602: PPUSH
19603: LD_VAR 0 4
19607: PPUSH
19608: EMPTY
19609: PPUSH
19610: CALL_OW 1
19614: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19615: LD_ADDR_EXP 71
19619: PUSH
19620: LD_EXP 71
19624: PPUSH
19625: LD_VAR 0 4
19629: PPUSH
19630: EMPTY
19631: PPUSH
19632: CALL_OW 1
19636: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19637: LD_ADDR_EXP 72
19641: PUSH
19642: LD_EXP 72
19646: PPUSH
19647: LD_VAR 0 4
19651: PPUSH
19652: EMPTY
19653: PPUSH
19654: CALL_OW 1
19658: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19659: LD_ADDR_EXP 73
19663: PUSH
19664: LD_EXP 73
19668: PPUSH
19669: LD_VAR 0 4
19673: PPUSH
19674: EMPTY
19675: PPUSH
19676: CALL_OW 1
19680: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19681: LD_ADDR_EXP 74
19685: PUSH
19686: LD_EXP 74
19690: PPUSH
19691: LD_VAR 0 4
19695: PPUSH
19696: EMPTY
19697: PPUSH
19698: CALL_OW 1
19702: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19703: LD_ADDR_EXP 75
19707: PUSH
19708: LD_EXP 75
19712: PPUSH
19713: LD_VAR 0 4
19717: PPUSH
19718: EMPTY
19719: PPUSH
19720: CALL_OW 1
19724: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19725: LD_ADDR_EXP 77
19729: PUSH
19730: LD_EXP 77
19734: PPUSH
19735: LD_VAR 0 4
19739: PPUSH
19740: EMPTY
19741: PPUSH
19742: CALL_OW 1
19746: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19747: LD_ADDR_EXP 79
19751: PUSH
19752: LD_EXP 79
19756: PPUSH
19757: LD_VAR 0 4
19761: PPUSH
19762: EMPTY
19763: PPUSH
19764: CALL_OW 1
19768: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19769: LD_ADDR_EXP 80
19773: PUSH
19774: LD_EXP 80
19778: PPUSH
19779: LD_VAR 0 4
19783: PPUSH
19784: EMPTY
19785: PPUSH
19786: CALL_OW 1
19790: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19791: LD_ADDR_EXP 81
19795: PUSH
19796: LD_EXP 81
19800: PPUSH
19801: LD_VAR 0 4
19805: PPUSH
19806: EMPTY
19807: PPUSH
19808: CALL_OW 1
19812: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19813: LD_ADDR_EXP 82
19817: PUSH
19818: LD_EXP 82
19822: PPUSH
19823: LD_VAR 0 4
19827: PPUSH
19828: EMPTY
19829: PPUSH
19830: CALL_OW 1
19834: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19835: LD_ADDR_EXP 83
19839: PUSH
19840: LD_EXP 83
19844: PPUSH
19845: LD_VAR 0 4
19849: PPUSH
19850: EMPTY
19851: PPUSH
19852: CALL_OW 1
19856: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19857: LD_ADDR_EXP 84
19861: PUSH
19862: LD_EXP 84
19866: PPUSH
19867: LD_VAR 0 4
19871: PPUSH
19872: EMPTY
19873: PPUSH
19874: CALL_OW 1
19878: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19879: LD_ADDR_EXP 85
19883: PUSH
19884: LD_EXP 85
19888: PPUSH
19889: LD_VAR 0 4
19893: PPUSH
19894: EMPTY
19895: PPUSH
19896: CALL_OW 1
19900: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19901: LD_ADDR_EXP 86
19905: PUSH
19906: LD_EXP 86
19910: PPUSH
19911: LD_VAR 0 4
19915: PPUSH
19916: EMPTY
19917: PPUSH
19918: CALL_OW 1
19922: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19923: LD_ADDR_EXP 87
19927: PUSH
19928: LD_EXP 87
19932: PPUSH
19933: LD_VAR 0 4
19937: PPUSH
19938: EMPTY
19939: PPUSH
19940: CALL_OW 1
19944: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19945: LD_ADDR_EXP 88
19949: PUSH
19950: LD_EXP 88
19954: PPUSH
19955: LD_VAR 0 4
19959: PPUSH
19960: EMPTY
19961: PPUSH
19962: CALL_OW 1
19966: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19967: LD_ADDR_EXP 89
19971: PUSH
19972: LD_EXP 89
19976: PPUSH
19977: LD_VAR 0 4
19981: PPUSH
19982: EMPTY
19983: PPUSH
19984: CALL_OW 1
19988: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19989: LD_ADDR_EXP 90
19993: PUSH
19994: LD_EXP 90
19998: PPUSH
19999: LD_VAR 0 4
20003: PPUSH
20004: EMPTY
20005: PPUSH
20006: CALL_OW 1
20010: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20011: LD_ADDR_EXP 91
20015: PUSH
20016: LD_EXP 91
20020: PPUSH
20021: LD_VAR 0 4
20025: PPUSH
20026: EMPTY
20027: PPUSH
20028: CALL_OW 1
20032: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20033: LD_ADDR_EXP 92
20037: PUSH
20038: LD_EXP 92
20042: PPUSH
20043: LD_VAR 0 4
20047: PPUSH
20048: LD_INT 0
20050: PPUSH
20051: CALL_OW 1
20055: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20056: LD_ADDR_EXP 93
20060: PUSH
20061: LD_EXP 93
20065: PPUSH
20066: LD_VAR 0 4
20070: PPUSH
20071: LD_INT 0
20073: PPUSH
20074: CALL_OW 1
20078: ST_TO_ADDR
// result := base ;
20079: LD_ADDR_VAR 0 3
20083: PUSH
20084: LD_VAR 0 4
20088: ST_TO_ADDR
// end ;
20089: LD_VAR 0 3
20093: RET
// export function MC_Start ( ) ; var i ; begin
20094: LD_INT 0
20096: PPUSH
20097: PPUSH
// for i = 1 to mc_bases do
20098: LD_ADDR_VAR 0 2
20102: PUSH
20103: DOUBLE
20104: LD_INT 1
20106: DEC
20107: ST_TO_ADDR
20108: LD_EXP 50
20112: PUSH
20113: FOR_TO
20114: IFFALSE 21214
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20116: LD_ADDR_EXP 50
20120: PUSH
20121: LD_EXP 50
20125: PPUSH
20126: LD_VAR 0 2
20130: PPUSH
20131: LD_EXP 50
20135: PUSH
20136: LD_VAR 0 2
20140: ARRAY
20141: PUSH
20142: LD_INT 0
20144: DIFF
20145: PPUSH
20146: CALL_OW 1
20150: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20151: LD_ADDR_EXP 51
20155: PUSH
20156: LD_EXP 51
20160: PPUSH
20161: LD_VAR 0 2
20165: PPUSH
20166: EMPTY
20167: PPUSH
20168: CALL_OW 1
20172: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20173: LD_ADDR_EXP 52
20177: PUSH
20178: LD_EXP 52
20182: PPUSH
20183: LD_VAR 0 2
20187: PPUSH
20188: EMPTY
20189: PPUSH
20190: CALL_OW 1
20194: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20195: LD_ADDR_EXP 53
20199: PUSH
20200: LD_EXP 53
20204: PPUSH
20205: LD_VAR 0 2
20209: PPUSH
20210: EMPTY
20211: PPUSH
20212: CALL_OW 1
20216: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20217: LD_ADDR_EXP 54
20221: PUSH
20222: LD_EXP 54
20226: PPUSH
20227: LD_VAR 0 2
20231: PPUSH
20232: EMPTY
20233: PUSH
20234: EMPTY
20235: PUSH
20236: EMPTY
20237: LIST
20238: LIST
20239: PPUSH
20240: CALL_OW 1
20244: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20245: LD_ADDR_EXP 55
20249: PUSH
20250: LD_EXP 55
20254: PPUSH
20255: LD_VAR 0 2
20259: PPUSH
20260: EMPTY
20261: PPUSH
20262: CALL_OW 1
20266: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20267: LD_ADDR_EXP 82
20271: PUSH
20272: LD_EXP 82
20276: PPUSH
20277: LD_VAR 0 2
20281: PPUSH
20282: EMPTY
20283: PPUSH
20284: CALL_OW 1
20288: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20289: LD_ADDR_EXP 56
20293: PUSH
20294: LD_EXP 56
20298: PPUSH
20299: LD_VAR 0 2
20303: PPUSH
20304: EMPTY
20305: PPUSH
20306: CALL_OW 1
20310: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20311: LD_ADDR_EXP 57
20315: PUSH
20316: LD_EXP 57
20320: PPUSH
20321: LD_VAR 0 2
20325: PPUSH
20326: EMPTY
20327: PPUSH
20328: CALL_OW 1
20332: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20333: LD_ADDR_EXP 58
20337: PUSH
20338: LD_EXP 58
20342: PPUSH
20343: LD_VAR 0 2
20347: PPUSH
20348: LD_EXP 50
20352: PUSH
20353: LD_VAR 0 2
20357: ARRAY
20358: PPUSH
20359: LD_INT 2
20361: PUSH
20362: LD_INT 30
20364: PUSH
20365: LD_INT 32
20367: PUSH
20368: EMPTY
20369: LIST
20370: LIST
20371: PUSH
20372: LD_INT 30
20374: PUSH
20375: LD_INT 33
20377: PUSH
20378: EMPTY
20379: LIST
20380: LIST
20381: PUSH
20382: EMPTY
20383: LIST
20384: LIST
20385: LIST
20386: PPUSH
20387: CALL_OW 72
20391: PPUSH
20392: CALL_OW 1
20396: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20397: LD_ADDR_EXP 59
20401: PUSH
20402: LD_EXP 59
20406: PPUSH
20407: LD_VAR 0 2
20411: PPUSH
20412: LD_EXP 50
20416: PUSH
20417: LD_VAR 0 2
20421: ARRAY
20422: PPUSH
20423: LD_INT 2
20425: PUSH
20426: LD_INT 30
20428: PUSH
20429: LD_INT 32
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: PUSH
20436: LD_INT 30
20438: PUSH
20439: LD_INT 31
20441: PUSH
20442: EMPTY
20443: LIST
20444: LIST
20445: PUSH
20446: EMPTY
20447: LIST
20448: LIST
20449: LIST
20450: PUSH
20451: LD_INT 58
20453: PUSH
20454: EMPTY
20455: LIST
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: PPUSH
20461: CALL_OW 72
20465: PPUSH
20466: CALL_OW 1
20470: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20471: LD_ADDR_EXP 60
20475: PUSH
20476: LD_EXP 60
20480: PPUSH
20481: LD_VAR 0 2
20485: PPUSH
20486: EMPTY
20487: PPUSH
20488: CALL_OW 1
20492: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20493: LD_ADDR_EXP 64
20497: PUSH
20498: LD_EXP 64
20502: PPUSH
20503: LD_VAR 0 2
20507: PPUSH
20508: EMPTY
20509: PPUSH
20510: CALL_OW 1
20514: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20515: LD_ADDR_EXP 63
20519: PUSH
20520: LD_EXP 63
20524: PPUSH
20525: LD_VAR 0 2
20529: PPUSH
20530: EMPTY
20531: PPUSH
20532: CALL_OW 1
20536: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20537: LD_ADDR_EXP 65
20541: PUSH
20542: LD_EXP 65
20546: PPUSH
20547: LD_VAR 0 2
20551: PPUSH
20552: EMPTY
20553: PPUSH
20554: CALL_OW 1
20558: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20559: LD_ADDR_EXP 66
20563: PUSH
20564: LD_EXP 66
20568: PPUSH
20569: LD_VAR 0 2
20573: PPUSH
20574: EMPTY
20575: PPUSH
20576: CALL_OW 1
20580: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20581: LD_ADDR_EXP 67
20585: PUSH
20586: LD_EXP 67
20590: PPUSH
20591: LD_VAR 0 2
20595: PPUSH
20596: EMPTY
20597: PPUSH
20598: CALL_OW 1
20602: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20603: LD_ADDR_EXP 68
20607: PUSH
20608: LD_EXP 68
20612: PPUSH
20613: LD_VAR 0 2
20617: PPUSH
20618: EMPTY
20619: PPUSH
20620: CALL_OW 1
20624: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20625: LD_ADDR_EXP 69
20629: PUSH
20630: LD_EXP 69
20634: PPUSH
20635: LD_VAR 0 2
20639: PPUSH
20640: EMPTY
20641: PPUSH
20642: CALL_OW 1
20646: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20647: LD_ADDR_EXP 70
20651: PUSH
20652: LD_EXP 70
20656: PPUSH
20657: LD_VAR 0 2
20661: PPUSH
20662: EMPTY
20663: PPUSH
20664: CALL_OW 1
20668: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20669: LD_ADDR_EXP 71
20673: PUSH
20674: LD_EXP 71
20678: PPUSH
20679: LD_VAR 0 2
20683: PPUSH
20684: EMPTY
20685: PPUSH
20686: CALL_OW 1
20690: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20691: LD_ADDR_EXP 72
20695: PUSH
20696: LD_EXP 72
20700: PPUSH
20701: LD_VAR 0 2
20705: PPUSH
20706: EMPTY
20707: PPUSH
20708: CALL_OW 1
20712: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20713: LD_ADDR_EXP 61
20717: PUSH
20718: LD_EXP 61
20722: PPUSH
20723: LD_VAR 0 2
20727: PPUSH
20728: LD_INT 0
20730: PPUSH
20731: CALL_OW 1
20735: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20736: LD_ADDR_EXP 74
20740: PUSH
20741: LD_EXP 74
20745: PPUSH
20746: LD_VAR 0 2
20750: PPUSH
20751: LD_INT 0
20753: PPUSH
20754: CALL_OW 1
20758: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20759: LD_ADDR_EXP 62
20763: PUSH
20764: LD_EXP 62
20768: PPUSH
20769: LD_VAR 0 2
20773: PPUSH
20774: EMPTY
20775: PPUSH
20776: CALL_OW 1
20780: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20781: LD_ADDR_EXP 73
20785: PUSH
20786: LD_EXP 73
20790: PPUSH
20791: LD_VAR 0 2
20795: PPUSH
20796: LD_INT 0
20798: PPUSH
20799: CALL_OW 1
20803: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20804: LD_ADDR_EXP 75
20808: PUSH
20809: LD_EXP 75
20813: PPUSH
20814: LD_VAR 0 2
20818: PPUSH
20819: EMPTY
20820: PPUSH
20821: CALL_OW 1
20825: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20826: LD_ADDR_EXP 78
20830: PUSH
20831: LD_EXP 78
20835: PPUSH
20836: LD_VAR 0 2
20840: PPUSH
20841: LD_INT 0
20843: PPUSH
20844: CALL_OW 1
20848: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20849: LD_ADDR_EXP 79
20853: PUSH
20854: LD_EXP 79
20858: PPUSH
20859: LD_VAR 0 2
20863: PPUSH
20864: EMPTY
20865: PPUSH
20866: CALL_OW 1
20870: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20871: LD_ADDR_EXP 80
20875: PUSH
20876: LD_EXP 80
20880: PPUSH
20881: LD_VAR 0 2
20885: PPUSH
20886: EMPTY
20887: PPUSH
20888: CALL_OW 1
20892: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20893: LD_ADDR_EXP 81
20897: PUSH
20898: LD_EXP 81
20902: PPUSH
20903: LD_VAR 0 2
20907: PPUSH
20908: EMPTY
20909: PPUSH
20910: CALL_OW 1
20914: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20915: LD_ADDR_EXP 83
20919: PUSH
20920: LD_EXP 83
20924: PPUSH
20925: LD_VAR 0 2
20929: PPUSH
20930: LD_EXP 50
20934: PUSH
20935: LD_VAR 0 2
20939: ARRAY
20940: PPUSH
20941: LD_INT 2
20943: PUSH
20944: LD_INT 30
20946: PUSH
20947: LD_INT 6
20949: PUSH
20950: EMPTY
20951: LIST
20952: LIST
20953: PUSH
20954: LD_INT 30
20956: PUSH
20957: LD_INT 7
20959: PUSH
20960: EMPTY
20961: LIST
20962: LIST
20963: PUSH
20964: LD_INT 30
20966: PUSH
20967: LD_INT 8
20969: PUSH
20970: EMPTY
20971: LIST
20972: LIST
20973: PUSH
20974: EMPTY
20975: LIST
20976: LIST
20977: LIST
20978: LIST
20979: PPUSH
20980: CALL_OW 72
20984: PPUSH
20985: CALL_OW 1
20989: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20990: LD_ADDR_EXP 84
20994: PUSH
20995: LD_EXP 84
20999: PPUSH
21000: LD_VAR 0 2
21004: PPUSH
21005: EMPTY
21006: PPUSH
21007: CALL_OW 1
21011: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21012: LD_ADDR_EXP 85
21016: PUSH
21017: LD_EXP 85
21021: PPUSH
21022: LD_VAR 0 2
21026: PPUSH
21027: EMPTY
21028: PPUSH
21029: CALL_OW 1
21033: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21034: LD_ADDR_EXP 86
21038: PUSH
21039: LD_EXP 86
21043: PPUSH
21044: LD_VAR 0 2
21048: PPUSH
21049: EMPTY
21050: PPUSH
21051: CALL_OW 1
21055: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21056: LD_ADDR_EXP 87
21060: PUSH
21061: LD_EXP 87
21065: PPUSH
21066: LD_VAR 0 2
21070: PPUSH
21071: EMPTY
21072: PPUSH
21073: CALL_OW 1
21077: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21078: LD_ADDR_EXP 88
21082: PUSH
21083: LD_EXP 88
21087: PPUSH
21088: LD_VAR 0 2
21092: PPUSH
21093: EMPTY
21094: PPUSH
21095: CALL_OW 1
21099: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21100: LD_ADDR_EXP 89
21104: PUSH
21105: LD_EXP 89
21109: PPUSH
21110: LD_VAR 0 2
21114: PPUSH
21115: EMPTY
21116: PPUSH
21117: CALL_OW 1
21121: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21122: LD_ADDR_EXP 90
21126: PUSH
21127: LD_EXP 90
21131: PPUSH
21132: LD_VAR 0 2
21136: PPUSH
21137: EMPTY
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21144: LD_ADDR_EXP 91
21148: PUSH
21149: LD_EXP 91
21153: PPUSH
21154: LD_VAR 0 2
21158: PPUSH
21159: EMPTY
21160: PPUSH
21161: CALL_OW 1
21165: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21166: LD_ADDR_EXP 92
21170: PUSH
21171: LD_EXP 92
21175: PPUSH
21176: LD_VAR 0 2
21180: PPUSH
21181: LD_INT 0
21183: PPUSH
21184: CALL_OW 1
21188: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21189: LD_ADDR_EXP 93
21193: PUSH
21194: LD_EXP 93
21198: PPUSH
21199: LD_VAR 0 2
21203: PPUSH
21204: LD_INT 0
21206: PPUSH
21207: CALL_OW 1
21211: ST_TO_ADDR
// end ;
21212: GO 20113
21214: POP
21215: POP
// MC_InitSides ( ) ;
21216: CALL 21502 0 0
// MC_InitResearch ( ) ;
21220: CALL 21241 0 0
// CustomInitMacro ( ) ;
21224: CALL 308 0 0
// skirmish := true ;
21228: LD_ADDR_EXP 48
21232: PUSH
21233: LD_INT 1
21235: ST_TO_ADDR
// end ;
21236: LD_VAR 0 1
21240: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21241: LD_INT 0
21243: PPUSH
21244: PPUSH
21245: PPUSH
21246: PPUSH
21247: PPUSH
21248: PPUSH
// if not mc_bases then
21249: LD_EXP 50
21253: NOT
21254: IFFALSE 21258
// exit ;
21256: GO 21497
// for i = 1 to 8 do
21258: LD_ADDR_VAR 0 2
21262: PUSH
21263: DOUBLE
21264: LD_INT 1
21266: DEC
21267: ST_TO_ADDR
21268: LD_INT 8
21270: PUSH
21271: FOR_TO
21272: IFFALSE 21298
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21274: LD_ADDR_EXP 77
21278: PUSH
21279: LD_EXP 77
21283: PPUSH
21284: LD_VAR 0 2
21288: PPUSH
21289: EMPTY
21290: PPUSH
21291: CALL_OW 1
21295: ST_TO_ADDR
21296: GO 21271
21298: POP
21299: POP
// tmp := [ ] ;
21300: LD_ADDR_VAR 0 5
21304: PUSH
21305: EMPTY
21306: ST_TO_ADDR
// for i = 1 to mc_sides do
21307: LD_ADDR_VAR 0 2
21311: PUSH
21312: DOUBLE
21313: LD_INT 1
21315: DEC
21316: ST_TO_ADDR
21317: LD_EXP 76
21321: PUSH
21322: FOR_TO
21323: IFFALSE 21381
// if not mc_sides [ i ] in tmp then
21325: LD_EXP 76
21329: PUSH
21330: LD_VAR 0 2
21334: ARRAY
21335: PUSH
21336: LD_VAR 0 5
21340: IN
21341: NOT
21342: IFFALSE 21379
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21344: LD_ADDR_VAR 0 5
21348: PUSH
21349: LD_VAR 0 5
21353: PPUSH
21354: LD_VAR 0 5
21358: PUSH
21359: LD_INT 1
21361: PLUS
21362: PPUSH
21363: LD_EXP 76
21367: PUSH
21368: LD_VAR 0 2
21372: ARRAY
21373: PPUSH
21374: CALL_OW 2
21378: ST_TO_ADDR
21379: GO 21322
21381: POP
21382: POP
// if not tmp then
21383: LD_VAR 0 5
21387: NOT
21388: IFFALSE 21392
// exit ;
21390: GO 21497
// for j in tmp do
21392: LD_ADDR_VAR 0 3
21396: PUSH
21397: LD_VAR 0 5
21401: PUSH
21402: FOR_IN
21403: IFFALSE 21495
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21405: LD_ADDR_VAR 0 6
21409: PUSH
21410: LD_INT 22
21412: PUSH
21413: LD_VAR 0 3
21417: PUSH
21418: EMPTY
21419: LIST
21420: LIST
21421: PPUSH
21422: CALL_OW 69
21426: ST_TO_ADDR
// if not un then
21427: LD_VAR 0 6
21431: NOT
21432: IFFALSE 21436
// continue ;
21434: GO 21402
// nation := GetNation ( un [ 1 ] ) ;
21436: LD_ADDR_VAR 0 4
21440: PUSH
21441: LD_VAR 0 6
21445: PUSH
21446: LD_INT 1
21448: ARRAY
21449: PPUSH
21450: CALL_OW 248
21454: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21455: LD_ADDR_EXP 77
21459: PUSH
21460: LD_EXP 77
21464: PPUSH
21465: LD_VAR 0 3
21469: PPUSH
21470: LD_VAR 0 3
21474: PPUSH
21475: LD_VAR 0 4
21479: PPUSH
21480: LD_INT 1
21482: PPUSH
21483: CALL 48618 0 3
21487: PPUSH
21488: CALL_OW 1
21492: ST_TO_ADDR
// end ;
21493: GO 21402
21495: POP
21496: POP
// end ;
21497: LD_VAR 0 1
21501: RET
// export function MC_InitSides ( ) ; var i ; begin
21502: LD_INT 0
21504: PPUSH
21505: PPUSH
// if not mc_bases then
21506: LD_EXP 50
21510: NOT
21511: IFFALSE 21515
// exit ;
21513: GO 21589
// for i = 1 to mc_bases do
21515: LD_ADDR_VAR 0 2
21519: PUSH
21520: DOUBLE
21521: LD_INT 1
21523: DEC
21524: ST_TO_ADDR
21525: LD_EXP 50
21529: PUSH
21530: FOR_TO
21531: IFFALSE 21587
// if mc_bases [ i ] then
21533: LD_EXP 50
21537: PUSH
21538: LD_VAR 0 2
21542: ARRAY
21543: IFFALSE 21585
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21545: LD_ADDR_EXP 76
21549: PUSH
21550: LD_EXP 76
21554: PPUSH
21555: LD_VAR 0 2
21559: PPUSH
21560: LD_EXP 50
21564: PUSH
21565: LD_VAR 0 2
21569: ARRAY
21570: PUSH
21571: LD_INT 1
21573: ARRAY
21574: PPUSH
21575: CALL_OW 255
21579: PPUSH
21580: CALL_OW 1
21584: ST_TO_ADDR
21585: GO 21530
21587: POP
21588: POP
// end ;
21589: LD_VAR 0 1
21593: RET
// every 0 0$03 trigger skirmish do
21594: LD_EXP 48
21598: IFFALSE 21752
21600: GO 21602
21602: DISABLE
// begin enable ;
21603: ENABLE
// MC_CheckBuildings ( ) ;
21604: CALL 26250 0 0
// MC_CheckPeopleLife ( ) ;
21608: CALL 26411 0 0
// RaiseSailEvent ( 100 ) ;
21612: LD_INT 100
21614: PPUSH
21615: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21619: LD_INT 103
21621: PPUSH
21622: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21626: LD_INT 104
21628: PPUSH
21629: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21633: LD_INT 105
21635: PPUSH
21636: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21640: LD_INT 106
21642: PPUSH
21643: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21647: LD_INT 107
21649: PPUSH
21650: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21654: LD_INT 108
21656: PPUSH
21657: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21661: LD_INT 109
21663: PPUSH
21664: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21668: LD_INT 110
21670: PPUSH
21671: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21675: LD_INT 111
21677: PPUSH
21678: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21682: LD_INT 112
21684: PPUSH
21685: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21689: LD_INT 113
21691: PPUSH
21692: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21696: LD_INT 120
21698: PPUSH
21699: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21703: LD_INT 121
21705: PPUSH
21706: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21710: LD_INT 122
21712: PPUSH
21713: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21717: LD_INT 123
21719: PPUSH
21720: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21724: LD_INT 124
21726: PPUSH
21727: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21731: LD_INT 125
21733: PPUSH
21734: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21738: LD_INT 126
21740: PPUSH
21741: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21745: LD_INT 200
21747: PPUSH
21748: CALL_OW 427
// end ;
21752: END
// on SailEvent ( event ) do begin if event < 100 then
21753: LD_VAR 0 1
21757: PUSH
21758: LD_INT 100
21760: LESS
21761: IFFALSE 21772
// CustomEvent ( event ) ;
21763: LD_VAR 0 1
21767: PPUSH
21768: CALL 17138 0 1
// if event = 100 then
21772: LD_VAR 0 1
21776: PUSH
21777: LD_INT 100
21779: EQUAL
21780: IFFALSE 21786
// MC_ClassManager ( ) ;
21782: CALL 22178 0 0
// if event = 101 then
21786: LD_VAR 0 1
21790: PUSH
21791: LD_INT 101
21793: EQUAL
21794: IFFALSE 21800
// MC_RepairBuildings ( ) ;
21796: CALL 26996 0 0
// if event = 102 then
21800: LD_VAR 0 1
21804: PUSH
21805: LD_INT 102
21807: EQUAL
21808: IFFALSE 21814
// MC_Heal ( ) ;
21810: CALL 27903 0 0
// if event = 103 then
21814: LD_VAR 0 1
21818: PUSH
21819: LD_INT 103
21821: EQUAL
21822: IFFALSE 21828
// MC_Build ( ) ;
21824: CALL 28325 0 0
// if event = 104 then
21828: LD_VAR 0 1
21832: PUSH
21833: LD_INT 104
21835: EQUAL
21836: IFFALSE 21842
// MC_TurretWeapon ( ) ;
21838: CALL 29966 0 0
// if event = 105 then
21842: LD_VAR 0 1
21846: PUSH
21847: LD_INT 105
21849: EQUAL
21850: IFFALSE 21856
// MC_BuildUpgrade ( ) ;
21852: CALL 29517 0 0
// if event = 106 then
21856: LD_VAR 0 1
21860: PUSH
21861: LD_INT 106
21863: EQUAL
21864: IFFALSE 21870
// MC_PlantMines ( ) ;
21866: CALL 30396 0 0
// if event = 107 then
21870: LD_VAR 0 1
21874: PUSH
21875: LD_INT 107
21877: EQUAL
21878: IFFALSE 21884
// MC_CollectCrates ( ) ;
21880: CALL 31187 0 0
// if event = 108 then
21884: LD_VAR 0 1
21888: PUSH
21889: LD_INT 108
21891: EQUAL
21892: IFFALSE 21898
// MC_LinkRemoteControl ( ) ;
21894: CALL 33037 0 0
// if event = 109 then
21898: LD_VAR 0 1
21902: PUSH
21903: LD_INT 109
21905: EQUAL
21906: IFFALSE 21912
// MC_ProduceVehicle ( ) ;
21908: CALL 33218 0 0
// if event = 110 then
21912: LD_VAR 0 1
21916: PUSH
21917: LD_INT 110
21919: EQUAL
21920: IFFALSE 21926
// MC_SendAttack ( ) ;
21922: CALL 33684 0 0
// if event = 111 then
21926: LD_VAR 0 1
21930: PUSH
21931: LD_INT 111
21933: EQUAL
21934: IFFALSE 21940
// MC_Defend ( ) ;
21936: CALL 33792 0 0
// if event = 112 then
21940: LD_VAR 0 1
21944: PUSH
21945: LD_INT 112
21947: EQUAL
21948: IFFALSE 21954
// MC_Research ( ) ;
21950: CALL 34672 0 0
// if event = 113 then
21954: LD_VAR 0 1
21958: PUSH
21959: LD_INT 113
21961: EQUAL
21962: IFFALSE 21968
// MC_MinesTrigger ( ) ;
21964: CALL 35786 0 0
// if event = 120 then
21968: LD_VAR 0 1
21972: PUSH
21973: LD_INT 120
21975: EQUAL
21976: IFFALSE 21982
// MC_RepairVehicle ( ) ;
21978: CALL 35885 0 0
// if event = 121 then
21982: LD_VAR 0 1
21986: PUSH
21987: LD_INT 121
21989: EQUAL
21990: IFFALSE 21996
// MC_TameApe ( ) ;
21992: CALL 36626 0 0
// if event = 122 then
21996: LD_VAR 0 1
22000: PUSH
22001: LD_INT 122
22003: EQUAL
22004: IFFALSE 22010
// MC_ChangeApeClass ( ) ;
22006: CALL 37455 0 0
// if event = 123 then
22010: LD_VAR 0 1
22014: PUSH
22015: LD_INT 123
22017: EQUAL
22018: IFFALSE 22024
// MC_Bazooka ( ) ;
22020: CALL 38105 0 0
// if event = 124 then
22024: LD_VAR 0 1
22028: PUSH
22029: LD_INT 124
22031: EQUAL
22032: IFFALSE 22038
// MC_TeleportExit ( ) ;
22034: CALL 38303 0 0
// if event = 125 then
22038: LD_VAR 0 1
22042: PUSH
22043: LD_INT 125
22045: EQUAL
22046: IFFALSE 22052
// MC_Deposits ( ) ;
22048: CALL 38950 0 0
// if event = 126 then
22052: LD_VAR 0 1
22056: PUSH
22057: LD_INT 126
22059: EQUAL
22060: IFFALSE 22066
// MC_RemoteDriver ( ) ;
22062: CALL 39575 0 0
// if event = 200 then
22066: LD_VAR 0 1
22070: PUSH
22071: LD_INT 200
22073: EQUAL
22074: IFFALSE 22080
// MC_Idle ( ) ;
22076: CALL 41524 0 0
// end ;
22080: PPOPN 1
22082: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22083: LD_INT 0
22085: PPUSH
22086: PPUSH
// if not mc_bases [ base ] or not tag then
22087: LD_EXP 50
22091: PUSH
22092: LD_VAR 0 1
22096: ARRAY
22097: NOT
22098: PUSH
22099: LD_VAR 0 2
22103: NOT
22104: OR
22105: IFFALSE 22109
// exit ;
22107: GO 22173
// for i in mc_bases [ base ] union mc_ape [ base ] do
22109: LD_ADDR_VAR 0 4
22113: PUSH
22114: LD_EXP 50
22118: PUSH
22119: LD_VAR 0 1
22123: ARRAY
22124: PUSH
22125: LD_EXP 79
22129: PUSH
22130: LD_VAR 0 1
22134: ARRAY
22135: UNION
22136: PUSH
22137: FOR_IN
22138: IFFALSE 22171
// if GetTag ( i ) = tag then
22140: LD_VAR 0 4
22144: PPUSH
22145: CALL_OW 110
22149: PUSH
22150: LD_VAR 0 2
22154: EQUAL
22155: IFFALSE 22169
// SetTag ( i , 0 ) ;
22157: LD_VAR 0 4
22161: PPUSH
22162: LD_INT 0
22164: PPUSH
22165: CALL_OW 109
22169: GO 22137
22171: POP
22172: POP
// end ;
22173: LD_VAR 0 3
22177: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22178: LD_INT 0
22180: PPUSH
22181: PPUSH
22182: PPUSH
22183: PPUSH
22184: PPUSH
22185: PPUSH
22186: PPUSH
22187: PPUSH
// if not mc_bases then
22188: LD_EXP 50
22192: NOT
22193: IFFALSE 22197
// exit ;
22195: GO 22655
// for i = 1 to mc_bases do
22197: LD_ADDR_VAR 0 2
22201: PUSH
22202: DOUBLE
22203: LD_INT 1
22205: DEC
22206: ST_TO_ADDR
22207: LD_EXP 50
22211: PUSH
22212: FOR_TO
22213: IFFALSE 22653
// begin tmp := MC_ClassCheckReq ( i ) ;
22215: LD_ADDR_VAR 0 4
22219: PUSH
22220: LD_VAR 0 2
22224: PPUSH
22225: CALL 22660 0 1
22229: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22230: LD_ADDR_EXP 91
22234: PUSH
22235: LD_EXP 91
22239: PPUSH
22240: LD_VAR 0 2
22244: PPUSH
22245: LD_VAR 0 4
22249: PPUSH
22250: CALL_OW 1
22254: ST_TO_ADDR
// if not tmp then
22255: LD_VAR 0 4
22259: NOT
22260: IFFALSE 22264
// continue ;
22262: GO 22212
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22264: LD_ADDR_VAR 0 6
22268: PUSH
22269: LD_EXP 50
22273: PUSH
22274: LD_VAR 0 2
22278: ARRAY
22279: PPUSH
22280: LD_INT 2
22282: PUSH
22283: LD_INT 30
22285: PUSH
22286: LD_INT 4
22288: PUSH
22289: EMPTY
22290: LIST
22291: LIST
22292: PUSH
22293: LD_INT 30
22295: PUSH
22296: LD_INT 5
22298: PUSH
22299: EMPTY
22300: LIST
22301: LIST
22302: PUSH
22303: EMPTY
22304: LIST
22305: LIST
22306: LIST
22307: PPUSH
22308: CALL_OW 72
22312: PUSH
22313: LD_EXP 50
22317: PUSH
22318: LD_VAR 0 2
22322: ARRAY
22323: PPUSH
22324: LD_INT 2
22326: PUSH
22327: LD_INT 30
22329: PUSH
22330: LD_INT 0
22332: PUSH
22333: EMPTY
22334: LIST
22335: LIST
22336: PUSH
22337: LD_INT 30
22339: PUSH
22340: LD_INT 1
22342: PUSH
22343: EMPTY
22344: LIST
22345: LIST
22346: PUSH
22347: EMPTY
22348: LIST
22349: LIST
22350: LIST
22351: PPUSH
22352: CALL_OW 72
22356: PUSH
22357: LD_EXP 50
22361: PUSH
22362: LD_VAR 0 2
22366: ARRAY
22367: PPUSH
22368: LD_INT 30
22370: PUSH
22371: LD_INT 3
22373: PUSH
22374: EMPTY
22375: LIST
22376: LIST
22377: PPUSH
22378: CALL_OW 72
22382: PUSH
22383: LD_EXP 50
22387: PUSH
22388: LD_VAR 0 2
22392: ARRAY
22393: PPUSH
22394: LD_INT 2
22396: PUSH
22397: LD_INT 30
22399: PUSH
22400: LD_INT 6
22402: PUSH
22403: EMPTY
22404: LIST
22405: LIST
22406: PUSH
22407: LD_INT 30
22409: PUSH
22410: LD_INT 7
22412: PUSH
22413: EMPTY
22414: LIST
22415: LIST
22416: PUSH
22417: LD_INT 30
22419: PUSH
22420: LD_INT 8
22422: PUSH
22423: EMPTY
22424: LIST
22425: LIST
22426: PUSH
22427: EMPTY
22428: LIST
22429: LIST
22430: LIST
22431: LIST
22432: PPUSH
22433: CALL_OW 72
22437: PUSH
22438: EMPTY
22439: LIST
22440: LIST
22441: LIST
22442: LIST
22443: ST_TO_ADDR
// for j = 1 to 4 do
22444: LD_ADDR_VAR 0 3
22448: PUSH
22449: DOUBLE
22450: LD_INT 1
22452: DEC
22453: ST_TO_ADDR
22454: LD_INT 4
22456: PUSH
22457: FOR_TO
22458: IFFALSE 22649
// begin if not tmp [ j ] then
22460: LD_VAR 0 4
22464: PUSH
22465: LD_VAR 0 3
22469: ARRAY
22470: NOT
22471: IFFALSE 22475
// continue ;
22473: GO 22457
// for p in tmp [ j ] do
22475: LD_ADDR_VAR 0 5
22479: PUSH
22480: LD_VAR 0 4
22484: PUSH
22485: LD_VAR 0 3
22489: ARRAY
22490: PUSH
22491: FOR_IN
22492: IFFALSE 22645
// begin if not b [ j ] then
22494: LD_VAR 0 6
22498: PUSH
22499: LD_VAR 0 3
22503: ARRAY
22504: NOT
22505: IFFALSE 22509
// break ;
22507: GO 22645
// e := 0 ;
22509: LD_ADDR_VAR 0 7
22513: PUSH
22514: LD_INT 0
22516: ST_TO_ADDR
// for k in b [ j ] do
22517: LD_ADDR_VAR 0 8
22521: PUSH
22522: LD_VAR 0 6
22526: PUSH
22527: LD_VAR 0 3
22531: ARRAY
22532: PUSH
22533: FOR_IN
22534: IFFALSE 22561
// if IsNotFull ( k ) then
22536: LD_VAR 0 8
22540: PPUSH
22541: CALL 50771 0 1
22545: IFFALSE 22559
// begin e := k ;
22547: LD_ADDR_VAR 0 7
22551: PUSH
22552: LD_VAR 0 8
22556: ST_TO_ADDR
// break ;
22557: GO 22561
// end ;
22559: GO 22533
22561: POP
22562: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22563: LD_VAR 0 7
22567: PUSH
22568: LD_VAR 0 5
22572: PPUSH
22573: LD_VAR 0 7
22577: PPUSH
22578: CALL 83935 0 2
22582: NOT
22583: AND
22584: IFFALSE 22643
// begin if IsInUnit ( p ) then
22586: LD_VAR 0 5
22590: PPUSH
22591: CALL_OW 310
22595: IFFALSE 22606
// ComExitBuilding ( p ) ;
22597: LD_VAR 0 5
22601: PPUSH
22602: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22606: LD_VAR 0 5
22610: PPUSH
22611: LD_VAR 0 7
22615: PPUSH
22616: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22620: LD_VAR 0 5
22624: PPUSH
22625: LD_VAR 0 3
22629: PPUSH
22630: CALL_OW 183
// AddComExitBuilding ( p ) ;
22634: LD_VAR 0 5
22638: PPUSH
22639: CALL_OW 182
// end ; end ;
22643: GO 22491
22645: POP
22646: POP
// end ;
22647: GO 22457
22649: POP
22650: POP
// end ;
22651: GO 22212
22653: POP
22654: POP
// end ;
22655: LD_VAR 0 1
22659: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22660: LD_INT 0
22662: PPUSH
22663: PPUSH
22664: PPUSH
22665: PPUSH
22666: PPUSH
22667: PPUSH
22668: PPUSH
22669: PPUSH
22670: PPUSH
22671: PPUSH
22672: PPUSH
22673: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22674: LD_VAR 0 1
22678: NOT
22679: PUSH
22680: LD_EXP 50
22684: PUSH
22685: LD_VAR 0 1
22689: ARRAY
22690: NOT
22691: OR
22692: PUSH
22693: LD_EXP 50
22697: PUSH
22698: LD_VAR 0 1
22702: ARRAY
22703: PPUSH
22704: LD_INT 2
22706: PUSH
22707: LD_INT 30
22709: PUSH
22710: LD_INT 0
22712: PUSH
22713: EMPTY
22714: LIST
22715: LIST
22716: PUSH
22717: LD_INT 30
22719: PUSH
22720: LD_INT 1
22722: PUSH
22723: EMPTY
22724: LIST
22725: LIST
22726: PUSH
22727: EMPTY
22728: LIST
22729: LIST
22730: LIST
22731: PPUSH
22732: CALL_OW 72
22736: NOT
22737: OR
22738: IFFALSE 22742
// exit ;
22740: GO 26245
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22742: LD_ADDR_VAR 0 4
22746: PUSH
22747: LD_EXP 50
22751: PUSH
22752: LD_VAR 0 1
22756: ARRAY
22757: PPUSH
22758: LD_INT 2
22760: PUSH
22761: LD_INT 25
22763: PUSH
22764: LD_INT 1
22766: PUSH
22767: EMPTY
22768: LIST
22769: LIST
22770: PUSH
22771: LD_INT 25
22773: PUSH
22774: LD_INT 2
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: PUSH
22781: LD_INT 25
22783: PUSH
22784: LD_INT 3
22786: PUSH
22787: EMPTY
22788: LIST
22789: LIST
22790: PUSH
22791: LD_INT 25
22793: PUSH
22794: LD_INT 4
22796: PUSH
22797: EMPTY
22798: LIST
22799: LIST
22800: PUSH
22801: LD_INT 25
22803: PUSH
22804: LD_INT 5
22806: PUSH
22807: EMPTY
22808: LIST
22809: LIST
22810: PUSH
22811: LD_INT 25
22813: PUSH
22814: LD_INT 8
22816: PUSH
22817: EMPTY
22818: LIST
22819: LIST
22820: PUSH
22821: LD_INT 25
22823: PUSH
22824: LD_INT 9
22826: PUSH
22827: EMPTY
22828: LIST
22829: LIST
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: LIST
22835: LIST
22836: LIST
22837: LIST
22838: LIST
22839: LIST
22840: PPUSH
22841: CALL_OW 72
22845: ST_TO_ADDR
// if not tmp then
22846: LD_VAR 0 4
22850: NOT
22851: IFFALSE 22855
// exit ;
22853: GO 26245
// for i in tmp do
22855: LD_ADDR_VAR 0 3
22859: PUSH
22860: LD_VAR 0 4
22864: PUSH
22865: FOR_IN
22866: IFFALSE 22897
// if GetTag ( i ) then
22868: LD_VAR 0 3
22872: PPUSH
22873: CALL_OW 110
22877: IFFALSE 22895
// tmp := tmp diff i ;
22879: LD_ADDR_VAR 0 4
22883: PUSH
22884: LD_VAR 0 4
22888: PUSH
22889: LD_VAR 0 3
22893: DIFF
22894: ST_TO_ADDR
22895: GO 22865
22897: POP
22898: POP
// if not tmp then
22899: LD_VAR 0 4
22903: NOT
22904: IFFALSE 22908
// exit ;
22906: GO 26245
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22908: LD_ADDR_VAR 0 5
22912: PUSH
22913: LD_EXP 50
22917: PUSH
22918: LD_VAR 0 1
22922: ARRAY
22923: PPUSH
22924: LD_INT 2
22926: PUSH
22927: LD_INT 25
22929: PUSH
22930: LD_INT 1
22932: PUSH
22933: EMPTY
22934: LIST
22935: LIST
22936: PUSH
22937: LD_INT 25
22939: PUSH
22940: LD_INT 5
22942: PUSH
22943: EMPTY
22944: LIST
22945: LIST
22946: PUSH
22947: LD_INT 25
22949: PUSH
22950: LD_INT 8
22952: PUSH
22953: EMPTY
22954: LIST
22955: LIST
22956: PUSH
22957: LD_INT 25
22959: PUSH
22960: LD_INT 9
22962: PUSH
22963: EMPTY
22964: LIST
22965: LIST
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: LIST
22971: LIST
22972: LIST
22973: PPUSH
22974: CALL_OW 72
22978: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22979: LD_ADDR_VAR 0 6
22983: PUSH
22984: LD_EXP 50
22988: PUSH
22989: LD_VAR 0 1
22993: ARRAY
22994: PPUSH
22995: LD_INT 25
22997: PUSH
22998: LD_INT 2
23000: PUSH
23001: EMPTY
23002: LIST
23003: LIST
23004: PPUSH
23005: CALL_OW 72
23009: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23010: LD_ADDR_VAR 0 7
23014: PUSH
23015: LD_EXP 50
23019: PUSH
23020: LD_VAR 0 1
23024: ARRAY
23025: PPUSH
23026: LD_INT 25
23028: PUSH
23029: LD_INT 3
23031: PUSH
23032: EMPTY
23033: LIST
23034: LIST
23035: PPUSH
23036: CALL_OW 72
23040: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23041: LD_ADDR_VAR 0 8
23045: PUSH
23046: LD_EXP 50
23050: PUSH
23051: LD_VAR 0 1
23055: ARRAY
23056: PPUSH
23057: LD_INT 25
23059: PUSH
23060: LD_INT 4
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: PUSH
23067: LD_INT 24
23069: PUSH
23070: LD_INT 251
23072: PUSH
23073: EMPTY
23074: LIST
23075: LIST
23076: PUSH
23077: EMPTY
23078: LIST
23079: LIST
23080: PPUSH
23081: CALL_OW 72
23085: ST_TO_ADDR
// if mc_is_defending [ base ] then
23086: LD_EXP 93
23090: PUSH
23091: LD_VAR 0 1
23095: ARRAY
23096: IFFALSE 23557
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23098: LD_ADDR_EXP 92
23102: PUSH
23103: LD_EXP 92
23107: PPUSH
23108: LD_VAR 0 1
23112: PPUSH
23113: LD_INT 4
23115: PPUSH
23116: CALL_OW 1
23120: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23121: LD_ADDR_VAR 0 12
23125: PUSH
23126: LD_EXP 50
23130: PUSH
23131: LD_VAR 0 1
23135: ARRAY
23136: PPUSH
23137: LD_INT 2
23139: PUSH
23140: LD_INT 30
23142: PUSH
23143: LD_INT 4
23145: PUSH
23146: EMPTY
23147: LIST
23148: LIST
23149: PUSH
23150: LD_INT 30
23152: PUSH
23153: LD_INT 5
23155: PUSH
23156: EMPTY
23157: LIST
23158: LIST
23159: PUSH
23160: EMPTY
23161: LIST
23162: LIST
23163: LIST
23164: PPUSH
23165: CALL_OW 72
23169: ST_TO_ADDR
// if not b then
23170: LD_VAR 0 12
23174: NOT
23175: IFFALSE 23179
// exit ;
23177: GO 26245
// p := [ ] ;
23179: LD_ADDR_VAR 0 11
23183: PUSH
23184: EMPTY
23185: ST_TO_ADDR
// if sci >= 2 then
23186: LD_VAR 0 8
23190: PUSH
23191: LD_INT 2
23193: GREATEREQUAL
23194: IFFALSE 23225
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23196: LD_ADDR_VAR 0 8
23200: PUSH
23201: LD_VAR 0 8
23205: PUSH
23206: LD_INT 1
23208: ARRAY
23209: PUSH
23210: LD_VAR 0 8
23214: PUSH
23215: LD_INT 2
23217: ARRAY
23218: PUSH
23219: EMPTY
23220: LIST
23221: LIST
23222: ST_TO_ADDR
23223: GO 23286
// if sci = 1 then
23225: LD_VAR 0 8
23229: PUSH
23230: LD_INT 1
23232: EQUAL
23233: IFFALSE 23254
// sci := [ sci [ 1 ] ] else
23235: LD_ADDR_VAR 0 8
23239: PUSH
23240: LD_VAR 0 8
23244: PUSH
23245: LD_INT 1
23247: ARRAY
23248: PUSH
23249: EMPTY
23250: LIST
23251: ST_TO_ADDR
23252: GO 23286
// if sci = 0 then
23254: LD_VAR 0 8
23258: PUSH
23259: LD_INT 0
23261: EQUAL
23262: IFFALSE 23286
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23264: LD_ADDR_VAR 0 11
23268: PUSH
23269: LD_VAR 0 4
23273: PPUSH
23274: LD_INT 4
23276: PPUSH
23277: CALL 83798 0 2
23281: PUSH
23282: LD_INT 1
23284: ARRAY
23285: ST_TO_ADDR
// if eng > 4 then
23286: LD_VAR 0 6
23290: PUSH
23291: LD_INT 4
23293: GREATER
23294: IFFALSE 23340
// for i = eng downto 4 do
23296: LD_ADDR_VAR 0 3
23300: PUSH
23301: DOUBLE
23302: LD_VAR 0 6
23306: INC
23307: ST_TO_ADDR
23308: LD_INT 4
23310: PUSH
23311: FOR_DOWNTO
23312: IFFALSE 23338
// eng := eng diff eng [ i ] ;
23314: LD_ADDR_VAR 0 6
23318: PUSH
23319: LD_VAR 0 6
23323: PUSH
23324: LD_VAR 0 6
23328: PUSH
23329: LD_VAR 0 3
23333: ARRAY
23334: DIFF
23335: ST_TO_ADDR
23336: GO 23311
23338: POP
23339: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23340: LD_ADDR_VAR 0 4
23344: PUSH
23345: LD_VAR 0 4
23349: PUSH
23350: LD_VAR 0 5
23354: PUSH
23355: LD_VAR 0 6
23359: UNION
23360: PUSH
23361: LD_VAR 0 7
23365: UNION
23366: PUSH
23367: LD_VAR 0 8
23371: UNION
23372: DIFF
23373: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23374: LD_ADDR_VAR 0 13
23378: PUSH
23379: LD_EXP 50
23383: PUSH
23384: LD_VAR 0 1
23388: ARRAY
23389: PPUSH
23390: LD_INT 2
23392: PUSH
23393: LD_INT 30
23395: PUSH
23396: LD_INT 32
23398: PUSH
23399: EMPTY
23400: LIST
23401: LIST
23402: PUSH
23403: LD_INT 30
23405: PUSH
23406: LD_INT 31
23408: PUSH
23409: EMPTY
23410: LIST
23411: LIST
23412: PUSH
23413: EMPTY
23414: LIST
23415: LIST
23416: LIST
23417: PPUSH
23418: CALL_OW 72
23422: PUSH
23423: LD_EXP 50
23427: PUSH
23428: LD_VAR 0 1
23432: ARRAY
23433: PPUSH
23434: LD_INT 2
23436: PUSH
23437: LD_INT 30
23439: PUSH
23440: LD_INT 4
23442: PUSH
23443: EMPTY
23444: LIST
23445: LIST
23446: PUSH
23447: LD_INT 30
23449: PUSH
23450: LD_INT 5
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: LIST
23461: PPUSH
23462: CALL_OW 72
23466: PUSH
23467: LD_INT 6
23469: MUL
23470: PLUS
23471: ST_TO_ADDR
// if bcount < tmp then
23472: LD_VAR 0 13
23476: PUSH
23477: LD_VAR 0 4
23481: LESS
23482: IFFALSE 23528
// for i = tmp downto bcount do
23484: LD_ADDR_VAR 0 3
23488: PUSH
23489: DOUBLE
23490: LD_VAR 0 4
23494: INC
23495: ST_TO_ADDR
23496: LD_VAR 0 13
23500: PUSH
23501: FOR_DOWNTO
23502: IFFALSE 23526
// tmp := Delete ( tmp , tmp ) ;
23504: LD_ADDR_VAR 0 4
23508: PUSH
23509: LD_VAR 0 4
23513: PPUSH
23514: LD_VAR 0 4
23518: PPUSH
23519: CALL_OW 3
23523: ST_TO_ADDR
23524: GO 23501
23526: POP
23527: POP
// result := [ tmp , 0 , 0 , p ] ;
23528: LD_ADDR_VAR 0 2
23532: PUSH
23533: LD_VAR 0 4
23537: PUSH
23538: LD_INT 0
23540: PUSH
23541: LD_INT 0
23543: PUSH
23544: LD_VAR 0 11
23548: PUSH
23549: EMPTY
23550: LIST
23551: LIST
23552: LIST
23553: LIST
23554: ST_TO_ADDR
// exit ;
23555: GO 26245
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23557: LD_EXP 50
23561: PUSH
23562: LD_VAR 0 1
23566: ARRAY
23567: PPUSH
23568: LD_INT 2
23570: PUSH
23571: LD_INT 30
23573: PUSH
23574: LD_INT 6
23576: PUSH
23577: EMPTY
23578: LIST
23579: LIST
23580: PUSH
23581: LD_INT 30
23583: PUSH
23584: LD_INT 7
23586: PUSH
23587: EMPTY
23588: LIST
23589: LIST
23590: PUSH
23591: LD_INT 30
23593: PUSH
23594: LD_INT 8
23596: PUSH
23597: EMPTY
23598: LIST
23599: LIST
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: LIST
23605: LIST
23606: PPUSH
23607: CALL_OW 72
23611: NOT
23612: PUSH
23613: LD_EXP 50
23617: PUSH
23618: LD_VAR 0 1
23622: ARRAY
23623: PPUSH
23624: LD_INT 30
23626: PUSH
23627: LD_INT 3
23629: PUSH
23630: EMPTY
23631: LIST
23632: LIST
23633: PPUSH
23634: CALL_OW 72
23638: NOT
23639: AND
23640: IFFALSE 23712
// begin if eng = tmp then
23642: LD_VAR 0 6
23646: PUSH
23647: LD_VAR 0 4
23651: EQUAL
23652: IFFALSE 23656
// exit ;
23654: GO 26245
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23656: LD_ADDR_EXP 92
23660: PUSH
23661: LD_EXP 92
23665: PPUSH
23666: LD_VAR 0 1
23670: PPUSH
23671: LD_INT 1
23673: PPUSH
23674: CALL_OW 1
23678: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23679: LD_ADDR_VAR 0 2
23683: PUSH
23684: LD_INT 0
23686: PUSH
23687: LD_VAR 0 4
23691: PUSH
23692: LD_VAR 0 6
23696: DIFF
23697: PUSH
23698: LD_INT 0
23700: PUSH
23701: LD_INT 0
23703: PUSH
23704: EMPTY
23705: LIST
23706: LIST
23707: LIST
23708: LIST
23709: ST_TO_ADDR
// exit ;
23710: GO 26245
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23712: LD_EXP 77
23716: PUSH
23717: LD_EXP 76
23721: PUSH
23722: LD_VAR 0 1
23726: ARRAY
23727: ARRAY
23728: PUSH
23729: LD_EXP 50
23733: PUSH
23734: LD_VAR 0 1
23738: ARRAY
23739: PPUSH
23740: LD_INT 2
23742: PUSH
23743: LD_INT 30
23745: PUSH
23746: LD_INT 6
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: PUSH
23753: LD_INT 30
23755: PUSH
23756: LD_INT 7
23758: PUSH
23759: EMPTY
23760: LIST
23761: LIST
23762: PUSH
23763: LD_INT 30
23765: PUSH
23766: LD_INT 8
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: PUSH
23773: EMPTY
23774: LIST
23775: LIST
23776: LIST
23777: LIST
23778: PPUSH
23779: CALL_OW 72
23783: AND
23784: PUSH
23785: LD_EXP 50
23789: PUSH
23790: LD_VAR 0 1
23794: ARRAY
23795: PPUSH
23796: LD_INT 30
23798: PUSH
23799: LD_INT 3
23801: PUSH
23802: EMPTY
23803: LIST
23804: LIST
23805: PPUSH
23806: CALL_OW 72
23810: NOT
23811: AND
23812: IFFALSE 24026
// begin if sci >= 6 then
23814: LD_VAR 0 8
23818: PUSH
23819: LD_INT 6
23821: GREATEREQUAL
23822: IFFALSE 23826
// exit ;
23824: GO 26245
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23826: LD_ADDR_EXP 92
23830: PUSH
23831: LD_EXP 92
23835: PPUSH
23836: LD_VAR 0 1
23840: PPUSH
23841: LD_INT 2
23843: PPUSH
23844: CALL_OW 1
23848: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23849: LD_ADDR_VAR 0 9
23853: PUSH
23854: LD_VAR 0 4
23858: PUSH
23859: LD_VAR 0 8
23863: DIFF
23864: PPUSH
23865: LD_INT 4
23867: PPUSH
23868: CALL 83798 0 2
23872: ST_TO_ADDR
// p := [ ] ;
23873: LD_ADDR_VAR 0 11
23877: PUSH
23878: EMPTY
23879: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23880: LD_VAR 0 8
23884: PUSH
23885: LD_INT 6
23887: LESS
23888: PUSH
23889: LD_VAR 0 9
23893: PUSH
23894: LD_INT 6
23896: GREATER
23897: AND
23898: IFFALSE 23979
// begin for i = 1 to 6 - sci do
23900: LD_ADDR_VAR 0 3
23904: PUSH
23905: DOUBLE
23906: LD_INT 1
23908: DEC
23909: ST_TO_ADDR
23910: LD_INT 6
23912: PUSH
23913: LD_VAR 0 8
23917: MINUS
23918: PUSH
23919: FOR_TO
23920: IFFALSE 23975
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23922: LD_ADDR_VAR 0 11
23926: PUSH
23927: LD_VAR 0 11
23931: PPUSH
23932: LD_VAR 0 11
23936: PUSH
23937: LD_INT 1
23939: PLUS
23940: PPUSH
23941: LD_VAR 0 9
23945: PUSH
23946: LD_INT 1
23948: ARRAY
23949: PPUSH
23950: CALL_OW 2
23954: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23955: LD_ADDR_VAR 0 9
23959: PUSH
23960: LD_VAR 0 9
23964: PPUSH
23965: LD_INT 1
23967: PPUSH
23968: CALL_OW 3
23972: ST_TO_ADDR
// end ;
23973: GO 23919
23975: POP
23976: POP
// end else
23977: GO 23999
// if sort then
23979: LD_VAR 0 9
23983: IFFALSE 23999
// p := sort [ 1 ] ;
23985: LD_ADDR_VAR 0 11
23989: PUSH
23990: LD_VAR 0 9
23994: PUSH
23995: LD_INT 1
23997: ARRAY
23998: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23999: LD_ADDR_VAR 0 2
24003: PUSH
24004: LD_INT 0
24006: PUSH
24007: LD_INT 0
24009: PUSH
24010: LD_INT 0
24012: PUSH
24013: LD_VAR 0 11
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: LIST
24022: LIST
24023: ST_TO_ADDR
// exit ;
24024: GO 26245
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24026: LD_EXP 77
24030: PUSH
24031: LD_EXP 76
24035: PUSH
24036: LD_VAR 0 1
24040: ARRAY
24041: ARRAY
24042: PUSH
24043: LD_EXP 50
24047: PUSH
24048: LD_VAR 0 1
24052: ARRAY
24053: PPUSH
24054: LD_INT 2
24056: PUSH
24057: LD_INT 30
24059: PUSH
24060: LD_INT 6
24062: PUSH
24063: EMPTY
24064: LIST
24065: LIST
24066: PUSH
24067: LD_INT 30
24069: PUSH
24070: LD_INT 7
24072: PUSH
24073: EMPTY
24074: LIST
24075: LIST
24076: PUSH
24077: LD_INT 30
24079: PUSH
24080: LD_INT 8
24082: PUSH
24083: EMPTY
24084: LIST
24085: LIST
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: LIST
24091: LIST
24092: PPUSH
24093: CALL_OW 72
24097: AND
24098: PUSH
24099: LD_EXP 50
24103: PUSH
24104: LD_VAR 0 1
24108: ARRAY
24109: PPUSH
24110: LD_INT 30
24112: PUSH
24113: LD_INT 3
24115: PUSH
24116: EMPTY
24117: LIST
24118: LIST
24119: PPUSH
24120: CALL_OW 72
24124: AND
24125: IFFALSE 24859
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24127: LD_ADDR_EXP 92
24131: PUSH
24132: LD_EXP 92
24136: PPUSH
24137: LD_VAR 0 1
24141: PPUSH
24142: LD_INT 3
24144: PPUSH
24145: CALL_OW 1
24149: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24150: LD_ADDR_VAR 0 2
24154: PUSH
24155: LD_INT 0
24157: PUSH
24158: LD_INT 0
24160: PUSH
24161: LD_INT 0
24163: PUSH
24164: LD_INT 0
24166: PUSH
24167: EMPTY
24168: LIST
24169: LIST
24170: LIST
24171: LIST
24172: ST_TO_ADDR
// if not eng then
24173: LD_VAR 0 6
24177: NOT
24178: IFFALSE 24241
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24180: LD_ADDR_VAR 0 11
24184: PUSH
24185: LD_VAR 0 4
24189: PPUSH
24190: LD_INT 2
24192: PPUSH
24193: CALL 83798 0 2
24197: PUSH
24198: LD_INT 1
24200: ARRAY
24201: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24202: LD_ADDR_VAR 0 2
24206: PUSH
24207: LD_VAR 0 2
24211: PPUSH
24212: LD_INT 2
24214: PPUSH
24215: LD_VAR 0 11
24219: PPUSH
24220: CALL_OW 1
24224: ST_TO_ADDR
// tmp := tmp diff p ;
24225: LD_ADDR_VAR 0 4
24229: PUSH
24230: LD_VAR 0 4
24234: PUSH
24235: LD_VAR 0 11
24239: DIFF
24240: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24241: LD_VAR 0 4
24245: PUSH
24246: LD_VAR 0 8
24250: PUSH
24251: LD_INT 6
24253: LESS
24254: AND
24255: IFFALSE 24443
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24257: LD_ADDR_VAR 0 9
24261: PUSH
24262: LD_VAR 0 4
24266: PUSH
24267: LD_VAR 0 8
24271: PUSH
24272: LD_VAR 0 7
24276: UNION
24277: DIFF
24278: PPUSH
24279: LD_INT 4
24281: PPUSH
24282: CALL 83798 0 2
24286: ST_TO_ADDR
// p := [ ] ;
24287: LD_ADDR_VAR 0 11
24291: PUSH
24292: EMPTY
24293: ST_TO_ADDR
// if sort then
24294: LD_VAR 0 9
24298: IFFALSE 24414
// for i = 1 to 6 - sci do
24300: LD_ADDR_VAR 0 3
24304: PUSH
24305: DOUBLE
24306: LD_INT 1
24308: DEC
24309: ST_TO_ADDR
24310: LD_INT 6
24312: PUSH
24313: LD_VAR 0 8
24317: MINUS
24318: PUSH
24319: FOR_TO
24320: IFFALSE 24412
// begin if i = sort then
24322: LD_VAR 0 3
24326: PUSH
24327: LD_VAR 0 9
24331: EQUAL
24332: IFFALSE 24336
// break ;
24334: GO 24412
// if GetClass ( i ) = 4 then
24336: LD_VAR 0 3
24340: PPUSH
24341: CALL_OW 257
24345: PUSH
24346: LD_INT 4
24348: EQUAL
24349: IFFALSE 24353
// continue ;
24351: GO 24319
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24353: LD_ADDR_VAR 0 11
24357: PUSH
24358: LD_VAR 0 11
24362: PPUSH
24363: LD_VAR 0 11
24367: PUSH
24368: LD_INT 1
24370: PLUS
24371: PPUSH
24372: LD_VAR 0 9
24376: PUSH
24377: LD_VAR 0 3
24381: ARRAY
24382: PPUSH
24383: CALL_OW 2
24387: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24388: LD_ADDR_VAR 0 4
24392: PUSH
24393: LD_VAR 0 4
24397: PUSH
24398: LD_VAR 0 9
24402: PUSH
24403: LD_VAR 0 3
24407: ARRAY
24408: DIFF
24409: ST_TO_ADDR
// end ;
24410: GO 24319
24412: POP
24413: POP
// if p then
24414: LD_VAR 0 11
24418: IFFALSE 24443
// result := Replace ( result , 4 , p ) ;
24420: LD_ADDR_VAR 0 2
24424: PUSH
24425: LD_VAR 0 2
24429: PPUSH
24430: LD_INT 4
24432: PPUSH
24433: LD_VAR 0 11
24437: PPUSH
24438: CALL_OW 1
24442: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24443: LD_VAR 0 4
24447: PUSH
24448: LD_VAR 0 7
24452: PUSH
24453: LD_INT 6
24455: LESS
24456: AND
24457: IFFALSE 24645
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24459: LD_ADDR_VAR 0 9
24463: PUSH
24464: LD_VAR 0 4
24468: PUSH
24469: LD_VAR 0 8
24473: PUSH
24474: LD_VAR 0 7
24478: UNION
24479: DIFF
24480: PPUSH
24481: LD_INT 3
24483: PPUSH
24484: CALL 83798 0 2
24488: ST_TO_ADDR
// p := [ ] ;
24489: LD_ADDR_VAR 0 11
24493: PUSH
24494: EMPTY
24495: ST_TO_ADDR
// if sort then
24496: LD_VAR 0 9
24500: IFFALSE 24616
// for i = 1 to 6 - mech do
24502: LD_ADDR_VAR 0 3
24506: PUSH
24507: DOUBLE
24508: LD_INT 1
24510: DEC
24511: ST_TO_ADDR
24512: LD_INT 6
24514: PUSH
24515: LD_VAR 0 7
24519: MINUS
24520: PUSH
24521: FOR_TO
24522: IFFALSE 24614
// begin if i = sort then
24524: LD_VAR 0 3
24528: PUSH
24529: LD_VAR 0 9
24533: EQUAL
24534: IFFALSE 24538
// break ;
24536: GO 24614
// if GetClass ( i ) = 3 then
24538: LD_VAR 0 3
24542: PPUSH
24543: CALL_OW 257
24547: PUSH
24548: LD_INT 3
24550: EQUAL
24551: IFFALSE 24555
// continue ;
24553: GO 24521
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24555: LD_ADDR_VAR 0 11
24559: PUSH
24560: LD_VAR 0 11
24564: PPUSH
24565: LD_VAR 0 11
24569: PUSH
24570: LD_INT 1
24572: PLUS
24573: PPUSH
24574: LD_VAR 0 9
24578: PUSH
24579: LD_VAR 0 3
24583: ARRAY
24584: PPUSH
24585: CALL_OW 2
24589: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24590: LD_ADDR_VAR 0 4
24594: PUSH
24595: LD_VAR 0 4
24599: PUSH
24600: LD_VAR 0 9
24604: PUSH
24605: LD_VAR 0 3
24609: ARRAY
24610: DIFF
24611: ST_TO_ADDR
// end ;
24612: GO 24521
24614: POP
24615: POP
// if p then
24616: LD_VAR 0 11
24620: IFFALSE 24645
// result := Replace ( result , 3 , p ) ;
24622: LD_ADDR_VAR 0 2
24626: PUSH
24627: LD_VAR 0 2
24631: PPUSH
24632: LD_INT 3
24634: PPUSH
24635: LD_VAR 0 11
24639: PPUSH
24640: CALL_OW 1
24644: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24645: LD_VAR 0 4
24649: PUSH
24650: LD_INT 6
24652: GREATER
24653: PUSH
24654: LD_VAR 0 6
24658: PUSH
24659: LD_INT 6
24661: LESS
24662: AND
24663: IFFALSE 24857
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24665: LD_ADDR_VAR 0 9
24669: PUSH
24670: LD_VAR 0 4
24674: PUSH
24675: LD_VAR 0 8
24679: PUSH
24680: LD_VAR 0 7
24684: UNION
24685: PUSH
24686: LD_VAR 0 6
24690: UNION
24691: DIFF
24692: PPUSH
24693: LD_INT 2
24695: PPUSH
24696: CALL 83798 0 2
24700: ST_TO_ADDR
// p := [ ] ;
24701: LD_ADDR_VAR 0 11
24705: PUSH
24706: EMPTY
24707: ST_TO_ADDR
// if sort then
24708: LD_VAR 0 9
24712: IFFALSE 24828
// for i = 1 to 6 - eng do
24714: LD_ADDR_VAR 0 3
24718: PUSH
24719: DOUBLE
24720: LD_INT 1
24722: DEC
24723: ST_TO_ADDR
24724: LD_INT 6
24726: PUSH
24727: LD_VAR 0 6
24731: MINUS
24732: PUSH
24733: FOR_TO
24734: IFFALSE 24826
// begin if i = sort then
24736: LD_VAR 0 3
24740: PUSH
24741: LD_VAR 0 9
24745: EQUAL
24746: IFFALSE 24750
// break ;
24748: GO 24826
// if GetClass ( i ) = 2 then
24750: LD_VAR 0 3
24754: PPUSH
24755: CALL_OW 257
24759: PUSH
24760: LD_INT 2
24762: EQUAL
24763: IFFALSE 24767
// continue ;
24765: GO 24733
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24767: LD_ADDR_VAR 0 11
24771: PUSH
24772: LD_VAR 0 11
24776: PPUSH
24777: LD_VAR 0 11
24781: PUSH
24782: LD_INT 1
24784: PLUS
24785: PPUSH
24786: LD_VAR 0 9
24790: PUSH
24791: LD_VAR 0 3
24795: ARRAY
24796: PPUSH
24797: CALL_OW 2
24801: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24802: LD_ADDR_VAR 0 4
24806: PUSH
24807: LD_VAR 0 4
24811: PUSH
24812: LD_VAR 0 9
24816: PUSH
24817: LD_VAR 0 3
24821: ARRAY
24822: DIFF
24823: ST_TO_ADDR
// end ;
24824: GO 24733
24826: POP
24827: POP
// if p then
24828: LD_VAR 0 11
24832: IFFALSE 24857
// result := Replace ( result , 2 , p ) ;
24834: LD_ADDR_VAR 0 2
24838: PUSH
24839: LD_VAR 0 2
24843: PPUSH
24844: LD_INT 2
24846: PPUSH
24847: LD_VAR 0 11
24851: PPUSH
24852: CALL_OW 1
24856: ST_TO_ADDR
// end ; exit ;
24857: GO 26245
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24859: LD_EXP 77
24863: PUSH
24864: LD_EXP 76
24868: PUSH
24869: LD_VAR 0 1
24873: ARRAY
24874: ARRAY
24875: NOT
24876: PUSH
24877: LD_EXP 50
24881: PUSH
24882: LD_VAR 0 1
24886: ARRAY
24887: PPUSH
24888: LD_INT 30
24890: PUSH
24891: LD_INT 3
24893: PUSH
24894: EMPTY
24895: LIST
24896: LIST
24897: PPUSH
24898: CALL_OW 72
24902: AND
24903: PUSH
24904: LD_EXP 55
24908: PUSH
24909: LD_VAR 0 1
24913: ARRAY
24914: AND
24915: IFFALSE 25523
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24917: LD_ADDR_EXP 92
24921: PUSH
24922: LD_EXP 92
24926: PPUSH
24927: LD_VAR 0 1
24931: PPUSH
24932: LD_INT 5
24934: PPUSH
24935: CALL_OW 1
24939: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24940: LD_ADDR_VAR 0 2
24944: PUSH
24945: LD_INT 0
24947: PUSH
24948: LD_INT 0
24950: PUSH
24951: LD_INT 0
24953: PUSH
24954: LD_INT 0
24956: PUSH
24957: EMPTY
24958: LIST
24959: LIST
24960: LIST
24961: LIST
24962: ST_TO_ADDR
// if sci > 1 then
24963: LD_VAR 0 8
24967: PUSH
24968: LD_INT 1
24970: GREATER
24971: IFFALSE 24999
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24973: LD_ADDR_VAR 0 4
24977: PUSH
24978: LD_VAR 0 4
24982: PUSH
24983: LD_VAR 0 8
24987: PUSH
24988: LD_VAR 0 8
24992: PUSH
24993: LD_INT 1
24995: ARRAY
24996: DIFF
24997: DIFF
24998: ST_TO_ADDR
// if tmp and not sci then
24999: LD_VAR 0 4
25003: PUSH
25004: LD_VAR 0 8
25008: NOT
25009: AND
25010: IFFALSE 25079
// begin sort := SortBySkill ( tmp , 4 ) ;
25012: LD_ADDR_VAR 0 9
25016: PUSH
25017: LD_VAR 0 4
25021: PPUSH
25022: LD_INT 4
25024: PPUSH
25025: CALL 83798 0 2
25029: ST_TO_ADDR
// if sort then
25030: LD_VAR 0 9
25034: IFFALSE 25050
// p := sort [ 1 ] ;
25036: LD_ADDR_VAR 0 11
25040: PUSH
25041: LD_VAR 0 9
25045: PUSH
25046: LD_INT 1
25048: ARRAY
25049: ST_TO_ADDR
// if p then
25050: LD_VAR 0 11
25054: IFFALSE 25079
// result := Replace ( result , 4 , p ) ;
25056: LD_ADDR_VAR 0 2
25060: PUSH
25061: LD_VAR 0 2
25065: PPUSH
25066: LD_INT 4
25068: PPUSH
25069: LD_VAR 0 11
25073: PPUSH
25074: CALL_OW 1
25078: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25079: LD_ADDR_VAR 0 4
25083: PUSH
25084: LD_VAR 0 4
25088: PUSH
25089: LD_VAR 0 7
25093: DIFF
25094: ST_TO_ADDR
// if tmp and mech < 6 then
25095: LD_VAR 0 4
25099: PUSH
25100: LD_VAR 0 7
25104: PUSH
25105: LD_INT 6
25107: LESS
25108: AND
25109: IFFALSE 25297
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25111: LD_ADDR_VAR 0 9
25115: PUSH
25116: LD_VAR 0 4
25120: PUSH
25121: LD_VAR 0 8
25125: PUSH
25126: LD_VAR 0 7
25130: UNION
25131: DIFF
25132: PPUSH
25133: LD_INT 3
25135: PPUSH
25136: CALL 83798 0 2
25140: ST_TO_ADDR
// p := [ ] ;
25141: LD_ADDR_VAR 0 11
25145: PUSH
25146: EMPTY
25147: ST_TO_ADDR
// if sort then
25148: LD_VAR 0 9
25152: IFFALSE 25268
// for i = 1 to 6 - mech do
25154: LD_ADDR_VAR 0 3
25158: PUSH
25159: DOUBLE
25160: LD_INT 1
25162: DEC
25163: ST_TO_ADDR
25164: LD_INT 6
25166: PUSH
25167: LD_VAR 0 7
25171: MINUS
25172: PUSH
25173: FOR_TO
25174: IFFALSE 25266
// begin if i = sort then
25176: LD_VAR 0 3
25180: PUSH
25181: LD_VAR 0 9
25185: EQUAL
25186: IFFALSE 25190
// break ;
25188: GO 25266
// if GetClass ( i ) = 3 then
25190: LD_VAR 0 3
25194: PPUSH
25195: CALL_OW 257
25199: PUSH
25200: LD_INT 3
25202: EQUAL
25203: IFFALSE 25207
// continue ;
25205: GO 25173
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25207: LD_ADDR_VAR 0 11
25211: PUSH
25212: LD_VAR 0 11
25216: PPUSH
25217: LD_VAR 0 11
25221: PUSH
25222: LD_INT 1
25224: PLUS
25225: PPUSH
25226: LD_VAR 0 9
25230: PUSH
25231: LD_VAR 0 3
25235: ARRAY
25236: PPUSH
25237: CALL_OW 2
25241: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25242: LD_ADDR_VAR 0 4
25246: PUSH
25247: LD_VAR 0 4
25251: PUSH
25252: LD_VAR 0 9
25256: PUSH
25257: LD_VAR 0 3
25261: ARRAY
25262: DIFF
25263: ST_TO_ADDR
// end ;
25264: GO 25173
25266: POP
25267: POP
// if p then
25268: LD_VAR 0 11
25272: IFFALSE 25297
// result := Replace ( result , 3 , p ) ;
25274: LD_ADDR_VAR 0 2
25278: PUSH
25279: LD_VAR 0 2
25283: PPUSH
25284: LD_INT 3
25286: PPUSH
25287: LD_VAR 0 11
25291: PPUSH
25292: CALL_OW 1
25296: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25297: LD_ADDR_VAR 0 4
25301: PUSH
25302: LD_VAR 0 4
25306: PUSH
25307: LD_VAR 0 6
25311: DIFF
25312: ST_TO_ADDR
// if tmp and eng < 6 then
25313: LD_VAR 0 4
25317: PUSH
25318: LD_VAR 0 6
25322: PUSH
25323: LD_INT 6
25325: LESS
25326: AND
25327: IFFALSE 25521
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25329: LD_ADDR_VAR 0 9
25333: PUSH
25334: LD_VAR 0 4
25338: PUSH
25339: LD_VAR 0 8
25343: PUSH
25344: LD_VAR 0 7
25348: UNION
25349: PUSH
25350: LD_VAR 0 6
25354: UNION
25355: DIFF
25356: PPUSH
25357: LD_INT 2
25359: PPUSH
25360: CALL 83798 0 2
25364: ST_TO_ADDR
// p := [ ] ;
25365: LD_ADDR_VAR 0 11
25369: PUSH
25370: EMPTY
25371: ST_TO_ADDR
// if sort then
25372: LD_VAR 0 9
25376: IFFALSE 25492
// for i = 1 to 6 - eng do
25378: LD_ADDR_VAR 0 3
25382: PUSH
25383: DOUBLE
25384: LD_INT 1
25386: DEC
25387: ST_TO_ADDR
25388: LD_INT 6
25390: PUSH
25391: LD_VAR 0 6
25395: MINUS
25396: PUSH
25397: FOR_TO
25398: IFFALSE 25490
// begin if i = sort then
25400: LD_VAR 0 3
25404: PUSH
25405: LD_VAR 0 9
25409: EQUAL
25410: IFFALSE 25414
// break ;
25412: GO 25490
// if GetClass ( i ) = 2 then
25414: LD_VAR 0 3
25418: PPUSH
25419: CALL_OW 257
25423: PUSH
25424: LD_INT 2
25426: EQUAL
25427: IFFALSE 25431
// continue ;
25429: GO 25397
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25431: LD_ADDR_VAR 0 11
25435: PUSH
25436: LD_VAR 0 11
25440: PPUSH
25441: LD_VAR 0 11
25445: PUSH
25446: LD_INT 1
25448: PLUS
25449: PPUSH
25450: LD_VAR 0 9
25454: PUSH
25455: LD_VAR 0 3
25459: ARRAY
25460: PPUSH
25461: CALL_OW 2
25465: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25466: LD_ADDR_VAR 0 4
25470: PUSH
25471: LD_VAR 0 4
25475: PUSH
25476: LD_VAR 0 9
25480: PUSH
25481: LD_VAR 0 3
25485: ARRAY
25486: DIFF
25487: ST_TO_ADDR
// end ;
25488: GO 25397
25490: POP
25491: POP
// if p then
25492: LD_VAR 0 11
25496: IFFALSE 25521
// result := Replace ( result , 2 , p ) ;
25498: LD_ADDR_VAR 0 2
25502: PUSH
25503: LD_VAR 0 2
25507: PPUSH
25508: LD_INT 2
25510: PPUSH
25511: LD_VAR 0 11
25515: PPUSH
25516: CALL_OW 1
25520: ST_TO_ADDR
// end ; exit ;
25521: GO 26245
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25523: LD_EXP 77
25527: PUSH
25528: LD_EXP 76
25532: PUSH
25533: LD_VAR 0 1
25537: ARRAY
25538: ARRAY
25539: NOT
25540: PUSH
25541: LD_EXP 50
25545: PUSH
25546: LD_VAR 0 1
25550: ARRAY
25551: PPUSH
25552: LD_INT 30
25554: PUSH
25555: LD_INT 3
25557: PUSH
25558: EMPTY
25559: LIST
25560: LIST
25561: PPUSH
25562: CALL_OW 72
25566: AND
25567: PUSH
25568: LD_EXP 55
25572: PUSH
25573: LD_VAR 0 1
25577: ARRAY
25578: NOT
25579: AND
25580: IFFALSE 26245
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25582: LD_ADDR_EXP 92
25586: PUSH
25587: LD_EXP 92
25591: PPUSH
25592: LD_VAR 0 1
25596: PPUSH
25597: LD_INT 6
25599: PPUSH
25600: CALL_OW 1
25604: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25605: LD_ADDR_VAR 0 2
25609: PUSH
25610: LD_INT 0
25612: PUSH
25613: LD_INT 0
25615: PUSH
25616: LD_INT 0
25618: PUSH
25619: LD_INT 0
25621: PUSH
25622: EMPTY
25623: LIST
25624: LIST
25625: LIST
25626: LIST
25627: ST_TO_ADDR
// if sci >= 1 then
25628: LD_VAR 0 8
25632: PUSH
25633: LD_INT 1
25635: GREATEREQUAL
25636: IFFALSE 25658
// tmp := tmp diff sci [ 1 ] ;
25638: LD_ADDR_VAR 0 4
25642: PUSH
25643: LD_VAR 0 4
25647: PUSH
25648: LD_VAR 0 8
25652: PUSH
25653: LD_INT 1
25655: ARRAY
25656: DIFF
25657: ST_TO_ADDR
// if tmp and not sci then
25658: LD_VAR 0 4
25662: PUSH
25663: LD_VAR 0 8
25667: NOT
25668: AND
25669: IFFALSE 25738
// begin sort := SortBySkill ( tmp , 4 ) ;
25671: LD_ADDR_VAR 0 9
25675: PUSH
25676: LD_VAR 0 4
25680: PPUSH
25681: LD_INT 4
25683: PPUSH
25684: CALL 83798 0 2
25688: ST_TO_ADDR
// if sort then
25689: LD_VAR 0 9
25693: IFFALSE 25709
// p := sort [ 1 ] ;
25695: LD_ADDR_VAR 0 11
25699: PUSH
25700: LD_VAR 0 9
25704: PUSH
25705: LD_INT 1
25707: ARRAY
25708: ST_TO_ADDR
// if p then
25709: LD_VAR 0 11
25713: IFFALSE 25738
// result := Replace ( result , 4 , p ) ;
25715: LD_ADDR_VAR 0 2
25719: PUSH
25720: LD_VAR 0 2
25724: PPUSH
25725: LD_INT 4
25727: PPUSH
25728: LD_VAR 0 11
25732: PPUSH
25733: CALL_OW 1
25737: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25738: LD_ADDR_VAR 0 4
25742: PUSH
25743: LD_VAR 0 4
25747: PUSH
25748: LD_VAR 0 7
25752: DIFF
25753: ST_TO_ADDR
// if tmp and mech < 6 then
25754: LD_VAR 0 4
25758: PUSH
25759: LD_VAR 0 7
25763: PUSH
25764: LD_INT 6
25766: LESS
25767: AND
25768: IFFALSE 25950
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25770: LD_ADDR_VAR 0 9
25774: PUSH
25775: LD_VAR 0 4
25779: PUSH
25780: LD_VAR 0 7
25784: DIFF
25785: PPUSH
25786: LD_INT 3
25788: PPUSH
25789: CALL 83798 0 2
25793: ST_TO_ADDR
// p := [ ] ;
25794: LD_ADDR_VAR 0 11
25798: PUSH
25799: EMPTY
25800: ST_TO_ADDR
// if sort then
25801: LD_VAR 0 9
25805: IFFALSE 25921
// for i = 1 to 6 - mech do
25807: LD_ADDR_VAR 0 3
25811: PUSH
25812: DOUBLE
25813: LD_INT 1
25815: DEC
25816: ST_TO_ADDR
25817: LD_INT 6
25819: PUSH
25820: LD_VAR 0 7
25824: MINUS
25825: PUSH
25826: FOR_TO
25827: IFFALSE 25919
// begin if i = sort then
25829: LD_VAR 0 3
25833: PUSH
25834: LD_VAR 0 9
25838: EQUAL
25839: IFFALSE 25843
// break ;
25841: GO 25919
// if GetClass ( i ) = 3 then
25843: LD_VAR 0 3
25847: PPUSH
25848: CALL_OW 257
25852: PUSH
25853: LD_INT 3
25855: EQUAL
25856: IFFALSE 25860
// continue ;
25858: GO 25826
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25860: LD_ADDR_VAR 0 11
25864: PUSH
25865: LD_VAR 0 11
25869: PPUSH
25870: LD_VAR 0 11
25874: PUSH
25875: LD_INT 1
25877: PLUS
25878: PPUSH
25879: LD_VAR 0 9
25883: PUSH
25884: LD_VAR 0 3
25888: ARRAY
25889: PPUSH
25890: CALL_OW 2
25894: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25895: LD_ADDR_VAR 0 4
25899: PUSH
25900: LD_VAR 0 4
25904: PUSH
25905: LD_VAR 0 9
25909: PUSH
25910: LD_VAR 0 3
25914: ARRAY
25915: DIFF
25916: ST_TO_ADDR
// end ;
25917: GO 25826
25919: POP
25920: POP
// if p then
25921: LD_VAR 0 11
25925: IFFALSE 25950
// result := Replace ( result , 3 , p ) ;
25927: LD_ADDR_VAR 0 2
25931: PUSH
25932: LD_VAR 0 2
25936: PPUSH
25937: LD_INT 3
25939: PPUSH
25940: LD_VAR 0 11
25944: PPUSH
25945: CALL_OW 1
25949: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25950: LD_ADDR_VAR 0 4
25954: PUSH
25955: LD_VAR 0 4
25959: PUSH
25960: LD_VAR 0 6
25964: DIFF
25965: ST_TO_ADDR
// if tmp and eng < 4 then
25966: LD_VAR 0 4
25970: PUSH
25971: LD_VAR 0 6
25975: PUSH
25976: LD_INT 4
25978: LESS
25979: AND
25980: IFFALSE 26170
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25982: LD_ADDR_VAR 0 9
25986: PUSH
25987: LD_VAR 0 4
25991: PUSH
25992: LD_VAR 0 7
25996: PUSH
25997: LD_VAR 0 6
26001: UNION
26002: DIFF
26003: PPUSH
26004: LD_INT 2
26006: PPUSH
26007: CALL 83798 0 2
26011: ST_TO_ADDR
// p := [ ] ;
26012: LD_ADDR_VAR 0 11
26016: PUSH
26017: EMPTY
26018: ST_TO_ADDR
// if sort then
26019: LD_VAR 0 9
26023: IFFALSE 26139
// for i = 1 to 4 - eng do
26025: LD_ADDR_VAR 0 3
26029: PUSH
26030: DOUBLE
26031: LD_INT 1
26033: DEC
26034: ST_TO_ADDR
26035: LD_INT 4
26037: PUSH
26038: LD_VAR 0 6
26042: MINUS
26043: PUSH
26044: FOR_TO
26045: IFFALSE 26137
// begin if i = sort then
26047: LD_VAR 0 3
26051: PUSH
26052: LD_VAR 0 9
26056: EQUAL
26057: IFFALSE 26061
// break ;
26059: GO 26137
// if GetClass ( i ) = 2 then
26061: LD_VAR 0 3
26065: PPUSH
26066: CALL_OW 257
26070: PUSH
26071: LD_INT 2
26073: EQUAL
26074: IFFALSE 26078
// continue ;
26076: GO 26044
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26078: LD_ADDR_VAR 0 11
26082: PUSH
26083: LD_VAR 0 11
26087: PPUSH
26088: LD_VAR 0 11
26092: PUSH
26093: LD_INT 1
26095: PLUS
26096: PPUSH
26097: LD_VAR 0 9
26101: PUSH
26102: LD_VAR 0 3
26106: ARRAY
26107: PPUSH
26108: CALL_OW 2
26112: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26113: LD_ADDR_VAR 0 4
26117: PUSH
26118: LD_VAR 0 4
26122: PUSH
26123: LD_VAR 0 9
26127: PUSH
26128: LD_VAR 0 3
26132: ARRAY
26133: DIFF
26134: ST_TO_ADDR
// end ;
26135: GO 26044
26137: POP
26138: POP
// if p then
26139: LD_VAR 0 11
26143: IFFALSE 26168
// result := Replace ( result , 2 , p ) ;
26145: LD_ADDR_VAR 0 2
26149: PUSH
26150: LD_VAR 0 2
26154: PPUSH
26155: LD_INT 2
26157: PPUSH
26158: LD_VAR 0 11
26162: PPUSH
26163: CALL_OW 1
26167: ST_TO_ADDR
// end else
26168: GO 26214
// for i = eng downto 5 do
26170: LD_ADDR_VAR 0 3
26174: PUSH
26175: DOUBLE
26176: LD_VAR 0 6
26180: INC
26181: ST_TO_ADDR
26182: LD_INT 5
26184: PUSH
26185: FOR_DOWNTO
26186: IFFALSE 26212
// tmp := tmp union eng [ i ] ;
26188: LD_ADDR_VAR 0 4
26192: PUSH
26193: LD_VAR 0 4
26197: PUSH
26198: LD_VAR 0 6
26202: PUSH
26203: LD_VAR 0 3
26207: ARRAY
26208: UNION
26209: ST_TO_ADDR
26210: GO 26185
26212: POP
26213: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26214: LD_ADDR_VAR 0 2
26218: PUSH
26219: LD_VAR 0 2
26223: PPUSH
26224: LD_INT 1
26226: PPUSH
26227: LD_VAR 0 4
26231: PUSH
26232: LD_VAR 0 5
26236: DIFF
26237: PPUSH
26238: CALL_OW 1
26242: ST_TO_ADDR
// exit ;
26243: GO 26245
// end ; end ;
26245: LD_VAR 0 2
26249: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26250: LD_INT 0
26252: PPUSH
26253: PPUSH
26254: PPUSH
// if not mc_bases then
26255: LD_EXP 50
26259: NOT
26260: IFFALSE 26264
// exit ;
26262: GO 26406
// for i = 1 to mc_bases do
26264: LD_ADDR_VAR 0 2
26268: PUSH
26269: DOUBLE
26270: LD_INT 1
26272: DEC
26273: ST_TO_ADDR
26274: LD_EXP 50
26278: PUSH
26279: FOR_TO
26280: IFFALSE 26397
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26282: LD_ADDR_VAR 0 3
26286: PUSH
26287: LD_EXP 50
26291: PUSH
26292: LD_VAR 0 2
26296: ARRAY
26297: PPUSH
26298: LD_INT 21
26300: PUSH
26301: LD_INT 3
26303: PUSH
26304: EMPTY
26305: LIST
26306: LIST
26307: PUSH
26308: LD_INT 3
26310: PUSH
26311: LD_INT 2
26313: PUSH
26314: LD_INT 30
26316: PUSH
26317: LD_INT 29
26319: PUSH
26320: EMPTY
26321: LIST
26322: LIST
26323: PUSH
26324: LD_INT 30
26326: PUSH
26327: LD_INT 30
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: PUSH
26334: EMPTY
26335: LIST
26336: LIST
26337: LIST
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: PUSH
26343: LD_INT 3
26345: PUSH
26346: LD_INT 24
26348: PUSH
26349: LD_INT 1000
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: PUSH
26356: EMPTY
26357: LIST
26358: LIST
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: LIST
26364: PPUSH
26365: CALL_OW 72
26369: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26370: LD_ADDR_EXP 51
26374: PUSH
26375: LD_EXP 51
26379: PPUSH
26380: LD_VAR 0 2
26384: PPUSH
26385: LD_VAR 0 3
26389: PPUSH
26390: CALL_OW 1
26394: ST_TO_ADDR
// end ;
26395: GO 26279
26397: POP
26398: POP
// RaiseSailEvent ( 101 ) ;
26399: LD_INT 101
26401: PPUSH
26402: CALL_OW 427
// end ;
26406: LD_VAR 0 1
26410: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26411: LD_INT 0
26413: PPUSH
26414: PPUSH
26415: PPUSH
26416: PPUSH
26417: PPUSH
26418: PPUSH
26419: PPUSH
// if not mc_bases then
26420: LD_EXP 50
26424: NOT
26425: IFFALSE 26429
// exit ;
26427: GO 26991
// for i = 1 to mc_bases do
26429: LD_ADDR_VAR 0 2
26433: PUSH
26434: DOUBLE
26435: LD_INT 1
26437: DEC
26438: ST_TO_ADDR
26439: LD_EXP 50
26443: PUSH
26444: FOR_TO
26445: IFFALSE 26982
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26447: LD_ADDR_VAR 0 5
26451: PUSH
26452: LD_EXP 50
26456: PUSH
26457: LD_VAR 0 2
26461: ARRAY
26462: PUSH
26463: LD_EXP 79
26467: PUSH
26468: LD_VAR 0 2
26472: ARRAY
26473: UNION
26474: PPUSH
26475: LD_INT 21
26477: PUSH
26478: LD_INT 1
26480: PUSH
26481: EMPTY
26482: LIST
26483: LIST
26484: PUSH
26485: LD_INT 1
26487: PUSH
26488: LD_INT 3
26490: PUSH
26491: LD_INT 54
26493: PUSH
26494: EMPTY
26495: LIST
26496: PUSH
26497: EMPTY
26498: LIST
26499: LIST
26500: PUSH
26501: LD_INT 3
26503: PUSH
26504: LD_INT 24
26506: PUSH
26507: LD_INT 1000
26509: PUSH
26510: EMPTY
26511: LIST
26512: LIST
26513: PUSH
26514: EMPTY
26515: LIST
26516: LIST
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: LIST
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PPUSH
26527: CALL_OW 72
26531: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26532: LD_ADDR_VAR 0 6
26536: PUSH
26537: LD_EXP 50
26541: PUSH
26542: LD_VAR 0 2
26546: ARRAY
26547: PPUSH
26548: LD_INT 21
26550: PUSH
26551: LD_INT 1
26553: PUSH
26554: EMPTY
26555: LIST
26556: LIST
26557: PUSH
26558: LD_INT 1
26560: PUSH
26561: LD_INT 3
26563: PUSH
26564: LD_INT 54
26566: PUSH
26567: EMPTY
26568: LIST
26569: PUSH
26570: EMPTY
26571: LIST
26572: LIST
26573: PUSH
26574: LD_INT 3
26576: PUSH
26577: LD_INT 24
26579: PUSH
26580: LD_INT 250
26582: PUSH
26583: EMPTY
26584: LIST
26585: LIST
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: LIST
26595: PUSH
26596: EMPTY
26597: LIST
26598: LIST
26599: PPUSH
26600: CALL_OW 72
26604: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26605: LD_ADDR_VAR 0 7
26609: PUSH
26610: LD_VAR 0 5
26614: PUSH
26615: LD_VAR 0 6
26619: DIFF
26620: ST_TO_ADDR
// if not need_heal_1 then
26621: LD_VAR 0 6
26625: NOT
26626: IFFALSE 26659
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26628: LD_ADDR_EXP 53
26632: PUSH
26633: LD_EXP 53
26637: PPUSH
26638: LD_VAR 0 2
26642: PUSH
26643: LD_INT 1
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PPUSH
26650: EMPTY
26651: PPUSH
26652: CALL 53541 0 3
26656: ST_TO_ADDR
26657: GO 26729
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26659: LD_ADDR_EXP 53
26663: PUSH
26664: LD_EXP 53
26668: PPUSH
26669: LD_VAR 0 2
26673: PUSH
26674: LD_INT 1
26676: PUSH
26677: EMPTY
26678: LIST
26679: LIST
26680: PPUSH
26681: LD_EXP 53
26685: PUSH
26686: LD_VAR 0 2
26690: ARRAY
26691: PUSH
26692: LD_INT 1
26694: ARRAY
26695: PPUSH
26696: LD_INT 3
26698: PUSH
26699: LD_INT 24
26701: PUSH
26702: LD_INT 1000
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PUSH
26709: EMPTY
26710: LIST
26711: LIST
26712: PPUSH
26713: CALL_OW 72
26717: PUSH
26718: LD_VAR 0 6
26722: UNION
26723: PPUSH
26724: CALL 53541 0 3
26728: ST_TO_ADDR
// if not need_heal_2 then
26729: LD_VAR 0 7
26733: NOT
26734: IFFALSE 26767
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26736: LD_ADDR_EXP 53
26740: PUSH
26741: LD_EXP 53
26745: PPUSH
26746: LD_VAR 0 2
26750: PUSH
26751: LD_INT 2
26753: PUSH
26754: EMPTY
26755: LIST
26756: LIST
26757: PPUSH
26758: EMPTY
26759: PPUSH
26760: CALL 53541 0 3
26764: ST_TO_ADDR
26765: GO 26799
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26767: LD_ADDR_EXP 53
26771: PUSH
26772: LD_EXP 53
26776: PPUSH
26777: LD_VAR 0 2
26781: PUSH
26782: LD_INT 2
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: PPUSH
26789: LD_VAR 0 7
26793: PPUSH
26794: CALL 53541 0 3
26798: ST_TO_ADDR
// if need_heal_2 then
26799: LD_VAR 0 7
26803: IFFALSE 26964
// for j in need_heal_2 do
26805: LD_ADDR_VAR 0 3
26809: PUSH
26810: LD_VAR 0 7
26814: PUSH
26815: FOR_IN
26816: IFFALSE 26962
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26818: LD_ADDR_VAR 0 5
26822: PUSH
26823: LD_EXP 50
26827: PUSH
26828: LD_VAR 0 2
26832: ARRAY
26833: PPUSH
26834: LD_INT 2
26836: PUSH
26837: LD_INT 30
26839: PUSH
26840: LD_INT 6
26842: PUSH
26843: EMPTY
26844: LIST
26845: LIST
26846: PUSH
26847: LD_INT 30
26849: PUSH
26850: LD_INT 7
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 30
26859: PUSH
26860: LD_INT 8
26862: PUSH
26863: EMPTY
26864: LIST
26865: LIST
26866: PUSH
26867: LD_INT 30
26869: PUSH
26870: LD_INT 0
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 30
26879: PUSH
26880: LD_INT 1
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: PUSH
26887: EMPTY
26888: LIST
26889: LIST
26890: LIST
26891: LIST
26892: LIST
26893: LIST
26894: PPUSH
26895: CALL_OW 72
26899: ST_TO_ADDR
// if tmp then
26900: LD_VAR 0 5
26904: IFFALSE 26960
// begin k := NearestUnitToUnit ( tmp , j ) ;
26906: LD_ADDR_VAR 0 4
26910: PUSH
26911: LD_VAR 0 5
26915: PPUSH
26916: LD_VAR 0 3
26920: PPUSH
26921: CALL_OW 74
26925: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26926: LD_VAR 0 3
26930: PPUSH
26931: LD_VAR 0 4
26935: PPUSH
26936: CALL_OW 296
26940: PUSH
26941: LD_INT 5
26943: GREATER
26944: IFFALSE 26960
// ComMoveToNearbyEntrance ( j , k ) ;
26946: LD_VAR 0 3
26950: PPUSH
26951: LD_VAR 0 4
26955: PPUSH
26956: CALL 86159 0 2
// end ; end ;
26960: GO 26815
26962: POP
26963: POP
// if not need_heal_1 and not need_heal_2 then
26964: LD_VAR 0 6
26968: NOT
26969: PUSH
26970: LD_VAR 0 7
26974: NOT
26975: AND
26976: IFFALSE 26980
// continue ;
26978: GO 26444
// end ;
26980: GO 26444
26982: POP
26983: POP
// RaiseSailEvent ( 102 ) ;
26984: LD_INT 102
26986: PPUSH
26987: CALL_OW 427
// end ;
26991: LD_VAR 0 1
26995: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26996: LD_INT 0
26998: PPUSH
26999: PPUSH
27000: PPUSH
27001: PPUSH
27002: PPUSH
27003: PPUSH
27004: PPUSH
27005: PPUSH
// if not mc_bases then
27006: LD_EXP 50
27010: NOT
27011: IFFALSE 27015
// exit ;
27013: GO 27898
// for i = 1 to mc_bases do
27015: LD_ADDR_VAR 0 2
27019: PUSH
27020: DOUBLE
27021: LD_INT 1
27023: DEC
27024: ST_TO_ADDR
27025: LD_EXP 50
27029: PUSH
27030: FOR_TO
27031: IFFALSE 27896
// begin if not mc_building_need_repair [ i ] then
27033: LD_EXP 51
27037: PUSH
27038: LD_VAR 0 2
27042: ARRAY
27043: NOT
27044: IFFALSE 27231
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27046: LD_ADDR_VAR 0 6
27050: PUSH
27051: LD_EXP 69
27055: PUSH
27056: LD_VAR 0 2
27060: ARRAY
27061: PPUSH
27062: LD_INT 3
27064: PUSH
27065: LD_INT 24
27067: PUSH
27068: LD_INT 1000
27070: PUSH
27071: EMPTY
27072: LIST
27073: LIST
27074: PUSH
27075: EMPTY
27076: LIST
27077: LIST
27078: PUSH
27079: LD_INT 2
27081: PUSH
27082: LD_INT 34
27084: PUSH
27085: LD_INT 13
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PUSH
27092: LD_INT 34
27094: PUSH
27095: LD_INT 52
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PUSH
27102: LD_INT 34
27104: PUSH
27105: LD_EXP 100
27109: PUSH
27110: EMPTY
27111: LIST
27112: LIST
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: LIST
27118: LIST
27119: PUSH
27120: EMPTY
27121: LIST
27122: LIST
27123: PPUSH
27124: CALL_OW 72
27128: ST_TO_ADDR
// if cranes then
27129: LD_VAR 0 6
27133: IFFALSE 27195
// for j in cranes do
27135: LD_ADDR_VAR 0 3
27139: PUSH
27140: LD_VAR 0 6
27144: PUSH
27145: FOR_IN
27146: IFFALSE 27193
// if not IsInArea ( j , mc_parking [ i ] ) then
27148: LD_VAR 0 3
27152: PPUSH
27153: LD_EXP 74
27157: PUSH
27158: LD_VAR 0 2
27162: ARRAY
27163: PPUSH
27164: CALL_OW 308
27168: NOT
27169: IFFALSE 27191
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27171: LD_VAR 0 3
27175: PPUSH
27176: LD_EXP 74
27180: PUSH
27181: LD_VAR 0 2
27185: ARRAY
27186: PPUSH
27187: CALL_OW 113
27191: GO 27145
27193: POP
27194: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27195: LD_ADDR_EXP 52
27199: PUSH
27200: LD_EXP 52
27204: PPUSH
27205: LD_VAR 0 2
27209: PPUSH
27210: EMPTY
27211: PPUSH
27212: CALL_OW 1
27216: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27217: LD_VAR 0 2
27221: PPUSH
27222: LD_INT 101
27224: PPUSH
27225: CALL 22083 0 2
// continue ;
27229: GO 27030
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27231: LD_ADDR_EXP 56
27235: PUSH
27236: LD_EXP 56
27240: PPUSH
27241: LD_VAR 0 2
27245: PPUSH
27246: EMPTY
27247: PPUSH
27248: CALL_OW 1
27252: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27253: LD_VAR 0 2
27257: PPUSH
27258: LD_INT 103
27260: PPUSH
27261: CALL 22083 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27265: LD_ADDR_VAR 0 5
27269: PUSH
27270: LD_EXP 50
27274: PUSH
27275: LD_VAR 0 2
27279: ARRAY
27280: PUSH
27281: LD_EXP 79
27285: PUSH
27286: LD_VAR 0 2
27290: ARRAY
27291: UNION
27292: PPUSH
27293: LD_INT 2
27295: PUSH
27296: LD_INT 25
27298: PUSH
27299: LD_INT 2
27301: PUSH
27302: EMPTY
27303: LIST
27304: LIST
27305: PUSH
27306: LD_INT 25
27308: PUSH
27309: LD_INT 16
27311: PUSH
27312: EMPTY
27313: LIST
27314: LIST
27315: PUSH
27316: EMPTY
27317: LIST
27318: LIST
27319: LIST
27320: PUSH
27321: EMPTY
27322: LIST
27323: PPUSH
27324: CALL_OW 72
27328: ST_TO_ADDR
// if mc_need_heal [ i ] then
27329: LD_EXP 53
27333: PUSH
27334: LD_VAR 0 2
27338: ARRAY
27339: IFFALSE 27383
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27341: LD_ADDR_VAR 0 5
27345: PUSH
27346: LD_VAR 0 5
27350: PUSH
27351: LD_EXP 53
27355: PUSH
27356: LD_VAR 0 2
27360: ARRAY
27361: PUSH
27362: LD_INT 1
27364: ARRAY
27365: PUSH
27366: LD_EXP 53
27370: PUSH
27371: LD_VAR 0 2
27375: ARRAY
27376: PUSH
27377: LD_INT 2
27379: ARRAY
27380: UNION
27381: DIFF
27382: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27383: LD_ADDR_VAR 0 6
27387: PUSH
27388: LD_EXP 69
27392: PUSH
27393: LD_VAR 0 2
27397: ARRAY
27398: PPUSH
27399: LD_INT 2
27401: PUSH
27402: LD_INT 34
27404: PUSH
27405: LD_INT 13
27407: PUSH
27408: EMPTY
27409: LIST
27410: LIST
27411: PUSH
27412: LD_INT 34
27414: PUSH
27415: LD_INT 52
27417: PUSH
27418: EMPTY
27419: LIST
27420: LIST
27421: PUSH
27422: LD_INT 34
27424: PUSH
27425: LD_EXP 100
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: LIST
27438: LIST
27439: PPUSH
27440: CALL_OW 72
27444: ST_TO_ADDR
// if cranes then
27445: LD_VAR 0 6
27449: IFFALSE 27585
// begin for j in cranes do
27451: LD_ADDR_VAR 0 3
27455: PUSH
27456: LD_VAR 0 6
27460: PUSH
27461: FOR_IN
27462: IFFALSE 27583
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27464: LD_VAR 0 3
27468: PPUSH
27469: CALL_OW 256
27473: PUSH
27474: LD_INT 1000
27476: EQUAL
27477: PUSH
27478: LD_VAR 0 3
27482: PPUSH
27483: CALL_OW 314
27487: NOT
27488: AND
27489: IFFALSE 27523
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
27491: LD_VAR 0 3
27495: PPUSH
27496: LD_EXP 51
27500: PUSH
27501: LD_VAR 0 2
27505: ARRAY
27506: PPUSH
27507: LD_VAR 0 3
27511: PPUSH
27512: CALL_OW 74
27516: PPUSH
27517: CALL_OW 130
27521: GO 27581
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27523: LD_VAR 0 3
27527: PPUSH
27528: CALL_OW 256
27532: PUSH
27533: LD_INT 500
27535: LESS
27536: PUSH
27537: LD_VAR 0 3
27541: PPUSH
27542: LD_EXP 74
27546: PUSH
27547: LD_VAR 0 2
27551: ARRAY
27552: PPUSH
27553: CALL_OW 308
27557: NOT
27558: AND
27559: IFFALSE 27581
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27561: LD_VAR 0 3
27565: PPUSH
27566: LD_EXP 74
27570: PUSH
27571: LD_VAR 0 2
27575: ARRAY
27576: PPUSH
27577: CALL_OW 113
// end ;
27581: GO 27461
27583: POP
27584: POP
// end ; if tmp > 3 then
27585: LD_VAR 0 5
27589: PUSH
27590: LD_INT 3
27592: GREATER
27593: IFFALSE 27613
// tmp := ShrinkArray ( tmp , 4 ) ;
27595: LD_ADDR_VAR 0 5
27599: PUSH
27600: LD_VAR 0 5
27604: PPUSH
27605: LD_INT 4
27607: PPUSH
27608: CALL 85607 0 2
27612: ST_TO_ADDR
// if not tmp then
27613: LD_VAR 0 5
27617: NOT
27618: IFFALSE 27622
// continue ;
27620: GO 27030
// for j in tmp do
27622: LD_ADDR_VAR 0 3
27626: PUSH
27627: LD_VAR 0 5
27631: PUSH
27632: FOR_IN
27633: IFFALSE 27892
// begin if IsInUnit ( j ) then
27635: LD_VAR 0 3
27639: PPUSH
27640: CALL_OW 310
27644: IFFALSE 27655
// ComExitBuilding ( j ) ;
27646: LD_VAR 0 3
27650: PPUSH
27651: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27655: LD_VAR 0 3
27659: PUSH
27660: LD_EXP 52
27664: PUSH
27665: LD_VAR 0 2
27669: ARRAY
27670: IN
27671: NOT
27672: IFFALSE 27730
// begin SetTag ( j , 101 ) ;
27674: LD_VAR 0 3
27678: PPUSH
27679: LD_INT 101
27681: PPUSH
27682: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27686: LD_ADDR_EXP 52
27690: PUSH
27691: LD_EXP 52
27695: PPUSH
27696: LD_VAR 0 2
27700: PUSH
27701: LD_EXP 52
27705: PUSH
27706: LD_VAR 0 2
27710: ARRAY
27711: PUSH
27712: LD_INT 1
27714: PLUS
27715: PUSH
27716: EMPTY
27717: LIST
27718: LIST
27719: PPUSH
27720: LD_VAR 0 3
27724: PPUSH
27725: CALL 53541 0 3
27729: ST_TO_ADDR
// end ; wait ( 1 ) ;
27730: LD_INT 1
27732: PPUSH
27733: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27737: LD_ADDR_VAR 0 7
27741: PUSH
27742: LD_EXP 51
27746: PUSH
27747: LD_VAR 0 2
27751: ARRAY
27752: ST_TO_ADDR
// if mc_scan [ i ] then
27753: LD_EXP 73
27757: PUSH
27758: LD_VAR 0 2
27762: ARRAY
27763: IFFALSE 27825
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27765: LD_ADDR_VAR 0 7
27769: PUSH
27770: LD_EXP 51
27774: PUSH
27775: LD_VAR 0 2
27779: ARRAY
27780: PPUSH
27781: LD_INT 3
27783: PUSH
27784: LD_INT 30
27786: PUSH
27787: LD_INT 32
27789: PUSH
27790: EMPTY
27791: LIST
27792: LIST
27793: PUSH
27794: LD_INT 30
27796: PUSH
27797: LD_INT 33
27799: PUSH
27800: EMPTY
27801: LIST
27802: LIST
27803: PUSH
27804: LD_INT 30
27806: PUSH
27807: LD_INT 31
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: LIST
27818: LIST
27819: PPUSH
27820: CALL_OW 72
27824: ST_TO_ADDR
// if not to_repair_tmp then
27825: LD_VAR 0 7
27829: NOT
27830: IFFALSE 27834
// continue ;
27832: GO 27632
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27834: LD_ADDR_VAR 0 8
27838: PUSH
27839: LD_VAR 0 7
27843: PPUSH
27844: LD_VAR 0 3
27848: PPUSH
27849: CALL_OW 74
27853: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27854: LD_VAR 0 8
27858: PPUSH
27859: LD_INT 16
27861: PPUSH
27862: CALL 56140 0 2
27866: PUSH
27867: LD_INT 4
27869: ARRAY
27870: PUSH
27871: LD_INT 10
27873: LESS
27874: IFFALSE 27890
// ComRepairBuilding ( j , to_repair ) ;
27876: LD_VAR 0 3
27880: PPUSH
27881: LD_VAR 0 8
27885: PPUSH
27886: CALL_OW 130
// end ;
27890: GO 27632
27892: POP
27893: POP
// end ;
27894: GO 27030
27896: POP
27897: POP
// end ;
27898: LD_VAR 0 1
27902: RET
// export function MC_Heal ; var i , j , tmp ; begin
27903: LD_INT 0
27905: PPUSH
27906: PPUSH
27907: PPUSH
27908: PPUSH
// if not mc_bases then
27909: LD_EXP 50
27913: NOT
27914: IFFALSE 27918
// exit ;
27916: GO 28320
// for i = 1 to mc_bases do
27918: LD_ADDR_VAR 0 2
27922: PUSH
27923: DOUBLE
27924: LD_INT 1
27926: DEC
27927: ST_TO_ADDR
27928: LD_EXP 50
27932: PUSH
27933: FOR_TO
27934: IFFALSE 28318
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27936: LD_EXP 53
27940: PUSH
27941: LD_VAR 0 2
27945: ARRAY
27946: PUSH
27947: LD_INT 1
27949: ARRAY
27950: NOT
27951: PUSH
27952: LD_EXP 53
27956: PUSH
27957: LD_VAR 0 2
27961: ARRAY
27962: PUSH
27963: LD_INT 2
27965: ARRAY
27966: NOT
27967: AND
27968: IFFALSE 28006
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27970: LD_ADDR_EXP 54
27974: PUSH
27975: LD_EXP 54
27979: PPUSH
27980: LD_VAR 0 2
27984: PPUSH
27985: EMPTY
27986: PPUSH
27987: CALL_OW 1
27991: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27992: LD_VAR 0 2
27996: PPUSH
27997: LD_INT 102
27999: PPUSH
28000: CALL 22083 0 2
// continue ;
28004: GO 27933
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28006: LD_ADDR_VAR 0 4
28010: PUSH
28011: LD_EXP 50
28015: PUSH
28016: LD_VAR 0 2
28020: ARRAY
28021: PPUSH
28022: LD_INT 25
28024: PUSH
28025: LD_INT 4
28027: PUSH
28028: EMPTY
28029: LIST
28030: LIST
28031: PPUSH
28032: CALL_OW 72
28036: ST_TO_ADDR
// if not tmp then
28037: LD_VAR 0 4
28041: NOT
28042: IFFALSE 28046
// continue ;
28044: GO 27933
// if mc_taming [ i ] then
28046: LD_EXP 81
28050: PUSH
28051: LD_VAR 0 2
28055: ARRAY
28056: IFFALSE 28080
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28058: LD_ADDR_EXP 81
28062: PUSH
28063: LD_EXP 81
28067: PPUSH
28068: LD_VAR 0 2
28072: PPUSH
28073: EMPTY
28074: PPUSH
28075: CALL_OW 1
28079: ST_TO_ADDR
// for j in tmp do
28080: LD_ADDR_VAR 0 3
28084: PUSH
28085: LD_VAR 0 4
28089: PUSH
28090: FOR_IN
28091: IFFALSE 28314
// begin if IsInUnit ( j ) then
28093: LD_VAR 0 3
28097: PPUSH
28098: CALL_OW 310
28102: IFFALSE 28113
// ComExitBuilding ( j ) ;
28104: LD_VAR 0 3
28108: PPUSH
28109: CALL_OW 122
// if not j in mc_healers [ i ] then
28113: LD_VAR 0 3
28117: PUSH
28118: LD_EXP 54
28122: PUSH
28123: LD_VAR 0 2
28127: ARRAY
28128: IN
28129: NOT
28130: IFFALSE 28176
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28132: LD_ADDR_EXP 54
28136: PUSH
28137: LD_EXP 54
28141: PPUSH
28142: LD_VAR 0 2
28146: PUSH
28147: LD_EXP 54
28151: PUSH
28152: LD_VAR 0 2
28156: ARRAY
28157: PUSH
28158: LD_INT 1
28160: PLUS
28161: PUSH
28162: EMPTY
28163: LIST
28164: LIST
28165: PPUSH
28166: LD_VAR 0 3
28170: PPUSH
28171: CALL 53541 0 3
28175: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28176: LD_VAR 0 3
28180: PPUSH
28181: CALL_OW 110
28185: PUSH
28186: LD_INT 102
28188: NONEQUAL
28189: IFFALSE 28203
// SetTag ( j , 102 ) ;
28191: LD_VAR 0 3
28195: PPUSH
28196: LD_INT 102
28198: PPUSH
28199: CALL_OW 109
// Wait ( 3 ) ;
28203: LD_INT 3
28205: PPUSH
28206: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28210: LD_EXP 53
28214: PUSH
28215: LD_VAR 0 2
28219: ARRAY
28220: PUSH
28221: LD_INT 1
28223: ARRAY
28224: IFFALSE 28256
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28226: LD_VAR 0 3
28230: PPUSH
28231: LD_EXP 53
28235: PUSH
28236: LD_VAR 0 2
28240: ARRAY
28241: PUSH
28242: LD_INT 1
28244: ARRAY
28245: PUSH
28246: LD_INT 1
28248: ARRAY
28249: PPUSH
28250: CALL_OW 128
28254: GO 28312
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28256: LD_VAR 0 3
28260: PPUSH
28261: CALL_OW 314
28265: NOT
28266: PUSH
28267: LD_EXP 53
28271: PUSH
28272: LD_VAR 0 2
28276: ARRAY
28277: PUSH
28278: LD_INT 2
28280: ARRAY
28281: AND
28282: IFFALSE 28312
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28284: LD_VAR 0 3
28288: PPUSH
28289: LD_EXP 53
28293: PUSH
28294: LD_VAR 0 2
28298: ARRAY
28299: PUSH
28300: LD_INT 2
28302: ARRAY
28303: PUSH
28304: LD_INT 1
28306: ARRAY
28307: PPUSH
28308: CALL_OW 128
// end ;
28312: GO 28090
28314: POP
28315: POP
// end ;
28316: GO 27933
28318: POP
28319: POP
// end ;
28320: LD_VAR 0 1
28324: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
28325: LD_INT 0
28327: PPUSH
28328: PPUSH
28329: PPUSH
28330: PPUSH
28331: PPUSH
// if not mc_bases then
28332: LD_EXP 50
28336: NOT
28337: IFFALSE 28341
// exit ;
28339: GO 29512
// for i = 1 to mc_bases do
28341: LD_ADDR_VAR 0 2
28345: PUSH
28346: DOUBLE
28347: LD_INT 1
28349: DEC
28350: ST_TO_ADDR
28351: LD_EXP 50
28355: PUSH
28356: FOR_TO
28357: IFFALSE 29510
// begin if mc_scan [ i ] then
28359: LD_EXP 73
28363: PUSH
28364: LD_VAR 0 2
28368: ARRAY
28369: IFFALSE 28373
// continue ;
28371: GO 28356
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28373: LD_EXP 55
28377: PUSH
28378: LD_VAR 0 2
28382: ARRAY
28383: NOT
28384: PUSH
28385: LD_EXP 57
28389: PUSH
28390: LD_VAR 0 2
28394: ARRAY
28395: NOT
28396: AND
28397: PUSH
28398: LD_EXP 56
28402: PUSH
28403: LD_VAR 0 2
28407: ARRAY
28408: AND
28409: IFFALSE 28447
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28411: LD_ADDR_EXP 56
28415: PUSH
28416: LD_EXP 56
28420: PPUSH
28421: LD_VAR 0 2
28425: PPUSH
28426: EMPTY
28427: PPUSH
28428: CALL_OW 1
28432: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28433: LD_VAR 0 2
28437: PPUSH
28438: LD_INT 103
28440: PPUSH
28441: CALL 22083 0 2
// continue ;
28445: GO 28356
// end ; if mc_construct_list [ i ] then
28447: LD_EXP 57
28451: PUSH
28452: LD_VAR 0 2
28456: ARRAY
28457: IFFALSE 28677
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28459: LD_ADDR_VAR 0 4
28463: PUSH
28464: LD_EXP 50
28468: PUSH
28469: LD_VAR 0 2
28473: ARRAY
28474: PPUSH
28475: LD_INT 25
28477: PUSH
28478: LD_INT 2
28480: PUSH
28481: EMPTY
28482: LIST
28483: LIST
28484: PPUSH
28485: CALL_OW 72
28489: PUSH
28490: LD_EXP 52
28494: PUSH
28495: LD_VAR 0 2
28499: ARRAY
28500: DIFF
28501: ST_TO_ADDR
// if not tmp then
28502: LD_VAR 0 4
28506: NOT
28507: IFFALSE 28511
// continue ;
28509: GO 28356
// for j in tmp do
28511: LD_ADDR_VAR 0 3
28515: PUSH
28516: LD_VAR 0 4
28520: PUSH
28521: FOR_IN
28522: IFFALSE 28673
// begin if not mc_builders [ i ] then
28524: LD_EXP 56
28528: PUSH
28529: LD_VAR 0 2
28533: ARRAY
28534: NOT
28535: IFFALSE 28593
// begin SetTag ( j , 103 ) ;
28537: LD_VAR 0 3
28541: PPUSH
28542: LD_INT 103
28544: PPUSH
28545: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28549: LD_ADDR_EXP 56
28553: PUSH
28554: LD_EXP 56
28558: PPUSH
28559: LD_VAR 0 2
28563: PUSH
28564: LD_EXP 56
28568: PUSH
28569: LD_VAR 0 2
28573: ARRAY
28574: PUSH
28575: LD_INT 1
28577: PLUS
28578: PUSH
28579: EMPTY
28580: LIST
28581: LIST
28582: PPUSH
28583: LD_VAR 0 3
28587: PPUSH
28588: CALL 53541 0 3
28592: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28593: LD_VAR 0 3
28597: PPUSH
28598: CALL_OW 310
28602: IFFALSE 28613
// ComExitBuilding ( j ) ;
28604: LD_VAR 0 3
28608: PPUSH
28609: CALL_OW 122
// wait ( 3 ) ;
28613: LD_INT 3
28615: PPUSH
28616: CALL_OW 67
// if not mc_construct_list [ i ] then
28620: LD_EXP 57
28624: PUSH
28625: LD_VAR 0 2
28629: ARRAY
28630: NOT
28631: IFFALSE 28635
// break ;
28633: GO 28673
// if not HasTask ( j ) then
28635: LD_VAR 0 3
28639: PPUSH
28640: CALL_OW 314
28644: NOT
28645: IFFALSE 28671
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28647: LD_VAR 0 3
28651: PPUSH
28652: LD_EXP 57
28656: PUSH
28657: LD_VAR 0 2
28661: ARRAY
28662: PUSH
28663: LD_INT 1
28665: ARRAY
28666: PPUSH
28667: CALL 56404 0 2
// end ;
28671: GO 28521
28673: POP
28674: POP
// end else
28675: GO 29508
// if mc_build_list [ i ] then
28677: LD_EXP 55
28681: PUSH
28682: LD_VAR 0 2
28686: ARRAY
28687: IFFALSE 29508
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28689: LD_ADDR_VAR 0 5
28693: PUSH
28694: LD_EXP 50
28698: PUSH
28699: LD_VAR 0 2
28703: ARRAY
28704: PPUSH
28705: LD_INT 2
28707: PUSH
28708: LD_INT 30
28710: PUSH
28711: LD_INT 0
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: PUSH
28718: LD_INT 30
28720: PUSH
28721: LD_INT 1
28723: PUSH
28724: EMPTY
28725: LIST
28726: LIST
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: LIST
28732: PPUSH
28733: CALL_OW 72
28737: ST_TO_ADDR
// if depot then
28738: LD_VAR 0 5
28742: IFFALSE 28760
// depot := depot [ 1 ] else
28744: LD_ADDR_VAR 0 5
28748: PUSH
28749: LD_VAR 0 5
28753: PUSH
28754: LD_INT 1
28756: ARRAY
28757: ST_TO_ADDR
28758: GO 28768
// depot := 0 ;
28760: LD_ADDR_VAR 0 5
28764: PUSH
28765: LD_INT 0
28767: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28768: LD_EXP 55
28772: PUSH
28773: LD_VAR 0 2
28777: ARRAY
28778: PUSH
28779: LD_INT 1
28781: ARRAY
28782: PUSH
28783: LD_INT 1
28785: ARRAY
28786: PPUSH
28787: CALL 56228 0 1
28791: PUSH
28792: LD_EXP 50
28796: PUSH
28797: LD_VAR 0 2
28801: ARRAY
28802: PPUSH
28803: LD_INT 2
28805: PUSH
28806: LD_INT 30
28808: PUSH
28809: LD_INT 2
28811: PUSH
28812: EMPTY
28813: LIST
28814: LIST
28815: PUSH
28816: LD_INT 30
28818: PUSH
28819: LD_INT 3
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: LIST
28830: PPUSH
28831: CALL_OW 72
28835: NOT
28836: AND
28837: IFFALSE 28942
// begin for j = 1 to mc_build_list [ i ] do
28839: LD_ADDR_VAR 0 3
28843: PUSH
28844: DOUBLE
28845: LD_INT 1
28847: DEC
28848: ST_TO_ADDR
28849: LD_EXP 55
28853: PUSH
28854: LD_VAR 0 2
28858: ARRAY
28859: PUSH
28860: FOR_TO
28861: IFFALSE 28940
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28863: LD_EXP 55
28867: PUSH
28868: LD_VAR 0 2
28872: ARRAY
28873: PUSH
28874: LD_VAR 0 3
28878: ARRAY
28879: PUSH
28880: LD_INT 1
28882: ARRAY
28883: PUSH
28884: LD_INT 2
28886: EQUAL
28887: IFFALSE 28938
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28889: LD_ADDR_EXP 55
28893: PUSH
28894: LD_EXP 55
28898: PPUSH
28899: LD_VAR 0 2
28903: PPUSH
28904: LD_EXP 55
28908: PUSH
28909: LD_VAR 0 2
28913: ARRAY
28914: PPUSH
28915: LD_VAR 0 3
28919: PPUSH
28920: LD_INT 1
28922: PPUSH
28923: LD_INT 0
28925: PPUSH
28926: CALL 52959 0 4
28930: PPUSH
28931: CALL_OW 1
28935: ST_TO_ADDR
// break ;
28936: GO 28940
// end ;
28938: GO 28860
28940: POP
28941: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28942: LD_EXP 55
28946: PUSH
28947: LD_VAR 0 2
28951: ARRAY
28952: PUSH
28953: LD_INT 1
28955: ARRAY
28956: PUSH
28957: LD_INT 1
28959: ARRAY
28960: PUSH
28961: LD_INT 0
28963: EQUAL
28964: PUSH
28965: LD_VAR 0 5
28969: PUSH
28970: LD_VAR 0 5
28974: PPUSH
28975: LD_EXP 55
28979: PUSH
28980: LD_VAR 0 2
28984: ARRAY
28985: PUSH
28986: LD_INT 1
28988: ARRAY
28989: PUSH
28990: LD_INT 1
28992: ARRAY
28993: PPUSH
28994: LD_EXP 55
28998: PUSH
28999: LD_VAR 0 2
29003: ARRAY
29004: PUSH
29005: LD_INT 1
29007: ARRAY
29008: PUSH
29009: LD_INT 2
29011: ARRAY
29012: PPUSH
29013: LD_EXP 55
29017: PUSH
29018: LD_VAR 0 2
29022: ARRAY
29023: PUSH
29024: LD_INT 1
29026: ARRAY
29027: PUSH
29028: LD_INT 3
29030: ARRAY
29031: PPUSH
29032: LD_EXP 55
29036: PUSH
29037: LD_VAR 0 2
29041: ARRAY
29042: PUSH
29043: LD_INT 1
29045: ARRAY
29046: PUSH
29047: LD_INT 4
29049: ARRAY
29050: PPUSH
29051: CALL 61644 0 5
29055: AND
29056: OR
29057: IFFALSE 29338
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29059: LD_ADDR_VAR 0 4
29063: PUSH
29064: LD_EXP 50
29068: PUSH
29069: LD_VAR 0 2
29073: ARRAY
29074: PPUSH
29075: LD_INT 25
29077: PUSH
29078: LD_INT 2
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PPUSH
29085: CALL_OW 72
29089: PUSH
29090: LD_EXP 52
29094: PUSH
29095: LD_VAR 0 2
29099: ARRAY
29100: DIFF
29101: ST_TO_ADDR
// if not tmp then
29102: LD_VAR 0 4
29106: NOT
29107: IFFALSE 29111
// continue ;
29109: GO 28356
// for j in tmp do
29111: LD_ADDR_VAR 0 3
29115: PUSH
29116: LD_VAR 0 4
29120: PUSH
29121: FOR_IN
29122: IFFALSE 29334
// begin if not mc_builders [ i ] then
29124: LD_EXP 56
29128: PUSH
29129: LD_VAR 0 2
29133: ARRAY
29134: NOT
29135: IFFALSE 29193
// begin SetTag ( j , 103 ) ;
29137: LD_VAR 0 3
29141: PPUSH
29142: LD_INT 103
29144: PPUSH
29145: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29149: LD_ADDR_EXP 56
29153: PUSH
29154: LD_EXP 56
29158: PPUSH
29159: LD_VAR 0 2
29163: PUSH
29164: LD_EXP 56
29168: PUSH
29169: LD_VAR 0 2
29173: ARRAY
29174: PUSH
29175: LD_INT 1
29177: PLUS
29178: PUSH
29179: EMPTY
29180: LIST
29181: LIST
29182: PPUSH
29183: LD_VAR 0 3
29187: PPUSH
29188: CALL 53541 0 3
29192: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29193: LD_VAR 0 3
29197: PPUSH
29198: CALL_OW 310
29202: IFFALSE 29213
// ComExitBuilding ( j ) ;
29204: LD_VAR 0 3
29208: PPUSH
29209: CALL_OW 122
// wait ( 3 ) ;
29213: LD_INT 3
29215: PPUSH
29216: CALL_OW 67
// if not mc_build_list [ i ] then
29220: LD_EXP 55
29224: PUSH
29225: LD_VAR 0 2
29229: ARRAY
29230: NOT
29231: IFFALSE 29235
// break ;
29233: GO 29334
// if not HasTask ( j ) then
29235: LD_VAR 0 3
29239: PPUSH
29240: CALL_OW 314
29244: NOT
29245: IFFALSE 29332
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29247: LD_VAR 0 3
29251: PPUSH
29252: LD_EXP 55
29256: PUSH
29257: LD_VAR 0 2
29261: ARRAY
29262: PUSH
29263: LD_INT 1
29265: ARRAY
29266: PUSH
29267: LD_INT 1
29269: ARRAY
29270: PPUSH
29271: LD_EXP 55
29275: PUSH
29276: LD_VAR 0 2
29280: ARRAY
29281: PUSH
29282: LD_INT 1
29284: ARRAY
29285: PUSH
29286: LD_INT 2
29288: ARRAY
29289: PPUSH
29290: LD_EXP 55
29294: PUSH
29295: LD_VAR 0 2
29299: ARRAY
29300: PUSH
29301: LD_INT 1
29303: ARRAY
29304: PUSH
29305: LD_INT 3
29307: ARRAY
29308: PPUSH
29309: LD_EXP 55
29313: PUSH
29314: LD_VAR 0 2
29318: ARRAY
29319: PUSH
29320: LD_INT 1
29322: ARRAY
29323: PUSH
29324: LD_INT 4
29326: ARRAY
29327: PPUSH
29328: CALL_OW 145
// end ;
29332: GO 29121
29334: POP
29335: POP
// end else
29336: GO 29508
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29338: LD_EXP 50
29342: PUSH
29343: LD_VAR 0 2
29347: ARRAY
29348: PPUSH
29349: LD_EXP 55
29353: PUSH
29354: LD_VAR 0 2
29358: ARRAY
29359: PUSH
29360: LD_INT 1
29362: ARRAY
29363: PUSH
29364: LD_INT 1
29366: ARRAY
29367: PPUSH
29368: LD_EXP 55
29372: PUSH
29373: LD_VAR 0 2
29377: ARRAY
29378: PUSH
29379: LD_INT 1
29381: ARRAY
29382: PUSH
29383: LD_INT 2
29385: ARRAY
29386: PPUSH
29387: LD_EXP 55
29391: PUSH
29392: LD_VAR 0 2
29396: ARRAY
29397: PUSH
29398: LD_INT 1
29400: ARRAY
29401: PUSH
29402: LD_INT 3
29404: ARRAY
29405: PPUSH
29406: LD_EXP 55
29410: PUSH
29411: LD_VAR 0 2
29415: ARRAY
29416: PUSH
29417: LD_INT 1
29419: ARRAY
29420: PUSH
29421: LD_INT 4
29423: ARRAY
29424: PPUSH
29425: LD_EXP 50
29429: PUSH
29430: LD_VAR 0 2
29434: ARRAY
29435: PPUSH
29436: LD_INT 21
29438: PUSH
29439: LD_INT 3
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PPUSH
29446: CALL_OW 72
29450: PPUSH
29451: EMPTY
29452: PPUSH
29453: CALL 60394 0 7
29457: NOT
29458: IFFALSE 29508
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29460: LD_ADDR_EXP 55
29464: PUSH
29465: LD_EXP 55
29469: PPUSH
29470: LD_VAR 0 2
29474: PPUSH
29475: LD_EXP 55
29479: PUSH
29480: LD_VAR 0 2
29484: ARRAY
29485: PPUSH
29486: LD_INT 1
29488: PPUSH
29489: LD_INT 1
29491: NEG
29492: PPUSH
29493: LD_INT 0
29495: PPUSH
29496: CALL 52959 0 4
29500: PPUSH
29501: CALL_OW 1
29505: ST_TO_ADDR
// continue ;
29506: GO 28356
// end ; end ; end ;
29508: GO 28356
29510: POP
29511: POP
// end ;
29512: LD_VAR 0 1
29516: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29517: LD_INT 0
29519: PPUSH
29520: PPUSH
29521: PPUSH
29522: PPUSH
29523: PPUSH
29524: PPUSH
// if not mc_bases then
29525: LD_EXP 50
29529: NOT
29530: IFFALSE 29534
// exit ;
29532: GO 29961
// for i = 1 to mc_bases do
29534: LD_ADDR_VAR 0 2
29538: PUSH
29539: DOUBLE
29540: LD_INT 1
29542: DEC
29543: ST_TO_ADDR
29544: LD_EXP 50
29548: PUSH
29549: FOR_TO
29550: IFFALSE 29959
// begin tmp := mc_build_upgrade [ i ] ;
29552: LD_ADDR_VAR 0 4
29556: PUSH
29557: LD_EXP 82
29561: PUSH
29562: LD_VAR 0 2
29566: ARRAY
29567: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29568: LD_ADDR_VAR 0 6
29572: PUSH
29573: LD_EXP 83
29577: PUSH
29578: LD_VAR 0 2
29582: ARRAY
29583: PPUSH
29584: LD_INT 2
29586: PUSH
29587: LD_INT 30
29589: PUSH
29590: LD_INT 6
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: PUSH
29597: LD_INT 30
29599: PUSH
29600: LD_INT 7
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PUSH
29607: EMPTY
29608: LIST
29609: LIST
29610: LIST
29611: PPUSH
29612: CALL_OW 72
29616: ST_TO_ADDR
// if not tmp and not lab then
29617: LD_VAR 0 4
29621: NOT
29622: PUSH
29623: LD_VAR 0 6
29627: NOT
29628: AND
29629: IFFALSE 29633
// continue ;
29631: GO 29549
// if tmp then
29633: LD_VAR 0 4
29637: IFFALSE 29757
// for j in tmp do
29639: LD_ADDR_VAR 0 3
29643: PUSH
29644: LD_VAR 0 4
29648: PUSH
29649: FOR_IN
29650: IFFALSE 29755
// begin if UpgradeCost ( j ) then
29652: LD_VAR 0 3
29656: PPUSH
29657: CALL 60054 0 1
29661: IFFALSE 29753
// begin ComUpgrade ( j ) ;
29663: LD_VAR 0 3
29667: PPUSH
29668: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29672: LD_ADDR_EXP 82
29676: PUSH
29677: LD_EXP 82
29681: PPUSH
29682: LD_VAR 0 2
29686: PPUSH
29687: LD_EXP 82
29691: PUSH
29692: LD_VAR 0 2
29696: ARRAY
29697: PUSH
29698: LD_VAR 0 3
29702: DIFF
29703: PPUSH
29704: CALL_OW 1
29708: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29709: LD_ADDR_EXP 57
29713: PUSH
29714: LD_EXP 57
29718: PPUSH
29719: LD_VAR 0 2
29723: PUSH
29724: LD_EXP 57
29728: PUSH
29729: LD_VAR 0 2
29733: ARRAY
29734: PUSH
29735: LD_INT 1
29737: PLUS
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PPUSH
29743: LD_VAR 0 3
29747: PPUSH
29748: CALL 53541 0 3
29752: ST_TO_ADDR
// end ; end ;
29753: GO 29649
29755: POP
29756: POP
// if not lab or not mc_lab_upgrade [ i ] then
29757: LD_VAR 0 6
29761: NOT
29762: PUSH
29763: LD_EXP 84
29767: PUSH
29768: LD_VAR 0 2
29772: ARRAY
29773: NOT
29774: OR
29775: IFFALSE 29779
// continue ;
29777: GO 29549
// for j in lab do
29779: LD_ADDR_VAR 0 3
29783: PUSH
29784: LD_VAR 0 6
29788: PUSH
29789: FOR_IN
29790: IFFALSE 29955
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29792: LD_VAR 0 3
29796: PPUSH
29797: CALL_OW 266
29801: PUSH
29802: LD_INT 6
29804: PUSH
29805: LD_INT 7
29807: PUSH
29808: EMPTY
29809: LIST
29810: LIST
29811: IN
29812: PUSH
29813: LD_VAR 0 3
29817: PPUSH
29818: CALL_OW 461
29822: PUSH
29823: LD_INT 1
29825: NONEQUAL
29826: AND
29827: IFFALSE 29953
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29829: LD_VAR 0 3
29833: PPUSH
29834: LD_EXP 84
29838: PUSH
29839: LD_VAR 0 2
29843: ARRAY
29844: PUSH
29845: LD_INT 1
29847: ARRAY
29848: PPUSH
29849: CALL 60259 0 2
29853: IFFALSE 29953
// begin ComCancel ( j ) ;
29855: LD_VAR 0 3
29859: PPUSH
29860: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29864: LD_VAR 0 3
29868: PPUSH
29869: LD_EXP 84
29873: PUSH
29874: LD_VAR 0 2
29878: ARRAY
29879: PUSH
29880: LD_INT 1
29882: ARRAY
29883: PPUSH
29884: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29888: LD_VAR 0 3
29892: PUSH
29893: LD_EXP 57
29897: PUSH
29898: LD_VAR 0 2
29902: ARRAY
29903: IN
29904: NOT
29905: IFFALSE 29951
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29907: LD_ADDR_EXP 57
29911: PUSH
29912: LD_EXP 57
29916: PPUSH
29917: LD_VAR 0 2
29921: PUSH
29922: LD_EXP 57
29926: PUSH
29927: LD_VAR 0 2
29931: ARRAY
29932: PUSH
29933: LD_INT 1
29935: PLUS
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: PPUSH
29941: LD_VAR 0 3
29945: PPUSH
29946: CALL 53541 0 3
29950: ST_TO_ADDR
// break ;
29951: GO 29955
// end ; end ; end ;
29953: GO 29789
29955: POP
29956: POP
// end ;
29957: GO 29549
29959: POP
29960: POP
// end ;
29961: LD_VAR 0 1
29965: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29966: LD_INT 0
29968: PPUSH
29969: PPUSH
29970: PPUSH
29971: PPUSH
29972: PPUSH
29973: PPUSH
29974: PPUSH
29975: PPUSH
29976: PPUSH
// if not mc_bases then
29977: LD_EXP 50
29981: NOT
29982: IFFALSE 29986
// exit ;
29984: GO 30391
// for i = 1 to mc_bases do
29986: LD_ADDR_VAR 0 2
29990: PUSH
29991: DOUBLE
29992: LD_INT 1
29994: DEC
29995: ST_TO_ADDR
29996: LD_EXP 50
30000: PUSH
30001: FOR_TO
30002: IFFALSE 30389
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30004: LD_EXP 58
30008: PUSH
30009: LD_VAR 0 2
30013: ARRAY
30014: NOT
30015: PUSH
30016: LD_EXP 50
30020: PUSH
30021: LD_VAR 0 2
30025: ARRAY
30026: PPUSH
30027: LD_INT 30
30029: PUSH
30030: LD_INT 3
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PPUSH
30037: CALL_OW 72
30041: NOT
30042: OR
30043: IFFALSE 30047
// continue ;
30045: GO 30001
// busy := false ;
30047: LD_ADDR_VAR 0 8
30051: PUSH
30052: LD_INT 0
30054: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30055: LD_ADDR_VAR 0 4
30059: PUSH
30060: LD_EXP 50
30064: PUSH
30065: LD_VAR 0 2
30069: ARRAY
30070: PPUSH
30071: LD_INT 30
30073: PUSH
30074: LD_INT 3
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PPUSH
30081: CALL_OW 72
30085: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30086: LD_ADDR_VAR 0 6
30090: PUSH
30091: LD_EXP 58
30095: PUSH
30096: LD_VAR 0 2
30100: ARRAY
30101: PPUSH
30102: LD_INT 2
30104: PUSH
30105: LD_INT 30
30107: PUSH
30108: LD_INT 32
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 30
30117: PUSH
30118: LD_INT 33
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: LIST
30129: PPUSH
30130: CALL_OW 72
30134: ST_TO_ADDR
// if not t then
30135: LD_VAR 0 6
30139: NOT
30140: IFFALSE 30144
// continue ;
30142: GO 30001
// for j in tmp do
30144: LD_ADDR_VAR 0 3
30148: PUSH
30149: LD_VAR 0 4
30153: PUSH
30154: FOR_IN
30155: IFFALSE 30185
// if not BuildingStatus ( j ) = bs_idle then
30157: LD_VAR 0 3
30161: PPUSH
30162: CALL_OW 461
30166: PUSH
30167: LD_INT 2
30169: EQUAL
30170: NOT
30171: IFFALSE 30183
// begin busy := true ;
30173: LD_ADDR_VAR 0 8
30177: PUSH
30178: LD_INT 1
30180: ST_TO_ADDR
// break ;
30181: GO 30185
// end ;
30183: GO 30154
30185: POP
30186: POP
// if busy then
30187: LD_VAR 0 8
30191: IFFALSE 30195
// continue ;
30193: GO 30001
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30195: LD_ADDR_VAR 0 7
30199: PUSH
30200: LD_VAR 0 6
30204: PPUSH
30205: LD_INT 35
30207: PUSH
30208: LD_INT 0
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PPUSH
30215: CALL_OW 72
30219: ST_TO_ADDR
// if tw then
30220: LD_VAR 0 7
30224: IFFALSE 30301
// begin tw := tw [ 1 ] ;
30226: LD_ADDR_VAR 0 7
30230: PUSH
30231: LD_VAR 0 7
30235: PUSH
30236: LD_INT 1
30238: ARRAY
30239: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30240: LD_ADDR_VAR 0 9
30244: PUSH
30245: LD_VAR 0 7
30249: PPUSH
30250: LD_EXP 75
30254: PUSH
30255: LD_VAR 0 2
30259: ARRAY
30260: PPUSH
30261: CALL 58551 0 2
30265: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30266: LD_EXP 89
30270: PUSH
30271: LD_VAR 0 2
30275: ARRAY
30276: IFFALSE 30299
// if not weapon in mc_allowed_tower_weapons [ i ] then
30278: LD_VAR 0 9
30282: PUSH
30283: LD_EXP 89
30287: PUSH
30288: LD_VAR 0 2
30292: ARRAY
30293: IN
30294: NOT
30295: IFFALSE 30299
// continue ;
30297: GO 30001
// end else
30299: GO 30364
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30301: LD_ADDR_VAR 0 5
30305: PUSH
30306: LD_EXP 58
30310: PUSH
30311: LD_VAR 0 2
30315: ARRAY
30316: PPUSH
30317: LD_VAR 0 4
30321: PPUSH
30322: CALL 84840 0 2
30326: ST_TO_ADDR
// if not tmp2 then
30327: LD_VAR 0 5
30331: NOT
30332: IFFALSE 30336
// continue ;
30334: GO 30001
// tw := tmp2 [ 1 ] ;
30336: LD_ADDR_VAR 0 7
30340: PUSH
30341: LD_VAR 0 5
30345: PUSH
30346: LD_INT 1
30348: ARRAY
30349: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30350: LD_ADDR_VAR 0 9
30354: PUSH
30355: LD_VAR 0 5
30359: PUSH
30360: LD_INT 2
30362: ARRAY
30363: ST_TO_ADDR
// end ; if not weapon then
30364: LD_VAR 0 9
30368: NOT
30369: IFFALSE 30373
// continue ;
30371: GO 30001
// ComPlaceWeapon ( tw , weapon ) ;
30373: LD_VAR 0 7
30377: PPUSH
30378: LD_VAR 0 9
30382: PPUSH
30383: CALL_OW 148
// end ;
30387: GO 30001
30389: POP
30390: POP
// end ;
30391: LD_VAR 0 1
30395: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30396: LD_INT 0
30398: PPUSH
30399: PPUSH
30400: PPUSH
30401: PPUSH
30402: PPUSH
30403: PPUSH
30404: PPUSH
// if not mc_bases then
30405: LD_EXP 50
30409: NOT
30410: IFFALSE 30414
// exit ;
30412: GO 31182
// for i = 1 to mc_bases do
30414: LD_ADDR_VAR 0 2
30418: PUSH
30419: DOUBLE
30420: LD_INT 1
30422: DEC
30423: ST_TO_ADDR
30424: LD_EXP 50
30428: PUSH
30429: FOR_TO
30430: IFFALSE 31180
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30432: LD_EXP 63
30436: PUSH
30437: LD_VAR 0 2
30441: ARRAY
30442: NOT
30443: PUSH
30444: LD_EXP 63
30448: PUSH
30449: LD_VAR 0 2
30453: ARRAY
30454: PUSH
30455: LD_EXP 64
30459: PUSH
30460: LD_VAR 0 2
30464: ARRAY
30465: EQUAL
30466: OR
30467: PUSH
30468: LD_EXP 73
30472: PUSH
30473: LD_VAR 0 2
30477: ARRAY
30478: OR
30479: IFFALSE 30483
// continue ;
30481: GO 30429
// if mc_miners [ i ] then
30483: LD_EXP 64
30487: PUSH
30488: LD_VAR 0 2
30492: ARRAY
30493: IFFALSE 30867
// begin for j = mc_miners [ i ] downto 1 do
30495: LD_ADDR_VAR 0 3
30499: PUSH
30500: DOUBLE
30501: LD_EXP 64
30505: PUSH
30506: LD_VAR 0 2
30510: ARRAY
30511: INC
30512: ST_TO_ADDR
30513: LD_INT 1
30515: PUSH
30516: FOR_DOWNTO
30517: IFFALSE 30865
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30519: LD_EXP 64
30523: PUSH
30524: LD_VAR 0 2
30528: ARRAY
30529: PUSH
30530: LD_VAR 0 3
30534: ARRAY
30535: PPUSH
30536: CALL_OW 301
30540: PUSH
30541: LD_EXP 64
30545: PUSH
30546: LD_VAR 0 2
30550: ARRAY
30551: PUSH
30552: LD_VAR 0 3
30556: ARRAY
30557: PPUSH
30558: CALL_OW 257
30562: PUSH
30563: LD_INT 1
30565: NONEQUAL
30566: OR
30567: IFFALSE 30630
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30569: LD_ADDR_VAR 0 5
30573: PUSH
30574: LD_EXP 64
30578: PUSH
30579: LD_VAR 0 2
30583: ARRAY
30584: PUSH
30585: LD_EXP 64
30589: PUSH
30590: LD_VAR 0 2
30594: ARRAY
30595: PUSH
30596: LD_VAR 0 3
30600: ARRAY
30601: DIFF
30602: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30603: LD_ADDR_EXP 64
30607: PUSH
30608: LD_EXP 64
30612: PPUSH
30613: LD_VAR 0 2
30617: PPUSH
30618: LD_VAR 0 5
30622: PPUSH
30623: CALL_OW 1
30627: ST_TO_ADDR
// continue ;
30628: GO 30516
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30630: LD_EXP 64
30634: PUSH
30635: LD_VAR 0 2
30639: ARRAY
30640: PUSH
30641: LD_VAR 0 3
30645: ARRAY
30646: PPUSH
30647: CALL_OW 257
30651: PUSH
30652: LD_INT 1
30654: EQUAL
30655: PUSH
30656: LD_EXP 64
30660: PUSH
30661: LD_VAR 0 2
30665: ARRAY
30666: PUSH
30667: LD_VAR 0 3
30671: ARRAY
30672: PPUSH
30673: CALL_OW 459
30677: NOT
30678: AND
30679: PUSH
30680: LD_EXP 64
30684: PUSH
30685: LD_VAR 0 2
30689: ARRAY
30690: PUSH
30691: LD_VAR 0 3
30695: ARRAY
30696: PPUSH
30697: CALL_OW 314
30701: NOT
30702: AND
30703: IFFALSE 30863
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30705: LD_EXP 64
30709: PUSH
30710: LD_VAR 0 2
30714: ARRAY
30715: PUSH
30716: LD_VAR 0 3
30720: ARRAY
30721: PPUSH
30722: CALL_OW 310
30726: IFFALSE 30749
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30728: LD_EXP 64
30732: PUSH
30733: LD_VAR 0 2
30737: ARRAY
30738: PUSH
30739: LD_VAR 0 3
30743: ARRAY
30744: PPUSH
30745: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30749: LD_EXP 64
30753: PUSH
30754: LD_VAR 0 2
30758: ARRAY
30759: PUSH
30760: LD_VAR 0 3
30764: ARRAY
30765: PPUSH
30766: CALL_OW 314
30770: NOT
30771: IFFALSE 30863
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30773: LD_ADDR_VAR 0 7
30777: PUSH
30778: LD_INT 1
30780: PPUSH
30781: LD_EXP 63
30785: PUSH
30786: LD_VAR 0 2
30790: ARRAY
30791: PPUSH
30792: CALL_OW 12
30796: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30797: LD_EXP 64
30801: PUSH
30802: LD_VAR 0 2
30806: ARRAY
30807: PUSH
30808: LD_VAR 0 3
30812: ARRAY
30813: PPUSH
30814: LD_EXP 63
30818: PUSH
30819: LD_VAR 0 2
30823: ARRAY
30824: PUSH
30825: LD_VAR 0 7
30829: ARRAY
30830: PUSH
30831: LD_INT 1
30833: ARRAY
30834: PPUSH
30835: LD_EXP 63
30839: PUSH
30840: LD_VAR 0 2
30844: ARRAY
30845: PUSH
30846: LD_VAR 0 7
30850: ARRAY
30851: PUSH
30852: LD_INT 2
30854: ARRAY
30855: PPUSH
30856: LD_INT 0
30858: PPUSH
30859: CALL_OW 193
// end ; end ; end ;
30863: GO 30516
30865: POP
30866: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30867: LD_ADDR_VAR 0 5
30871: PUSH
30872: LD_EXP 50
30876: PUSH
30877: LD_VAR 0 2
30881: ARRAY
30882: PPUSH
30883: LD_INT 2
30885: PUSH
30886: LD_INT 30
30888: PUSH
30889: LD_INT 4
30891: PUSH
30892: EMPTY
30893: LIST
30894: LIST
30895: PUSH
30896: LD_INT 30
30898: PUSH
30899: LD_INT 5
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 30
30908: PUSH
30909: LD_INT 32
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: PPUSH
30922: CALL_OW 72
30926: ST_TO_ADDR
// if not tmp then
30927: LD_VAR 0 5
30931: NOT
30932: IFFALSE 30936
// continue ;
30934: GO 30429
// list := [ ] ;
30936: LD_ADDR_VAR 0 6
30940: PUSH
30941: EMPTY
30942: ST_TO_ADDR
// for j in tmp do
30943: LD_ADDR_VAR 0 3
30947: PUSH
30948: LD_VAR 0 5
30952: PUSH
30953: FOR_IN
30954: IFFALSE 31023
// begin for k in UnitsInside ( j ) do
30956: LD_ADDR_VAR 0 4
30960: PUSH
30961: LD_VAR 0 3
30965: PPUSH
30966: CALL_OW 313
30970: PUSH
30971: FOR_IN
30972: IFFALSE 31019
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30974: LD_VAR 0 4
30978: PPUSH
30979: CALL_OW 257
30983: PUSH
30984: LD_INT 1
30986: EQUAL
30987: PUSH
30988: LD_VAR 0 4
30992: PPUSH
30993: CALL_OW 459
30997: NOT
30998: AND
30999: IFFALSE 31017
// list := list ^ k ;
31001: LD_ADDR_VAR 0 6
31005: PUSH
31006: LD_VAR 0 6
31010: PUSH
31011: LD_VAR 0 4
31015: ADD
31016: ST_TO_ADDR
31017: GO 30971
31019: POP
31020: POP
// end ;
31021: GO 30953
31023: POP
31024: POP
// list := list diff mc_miners [ i ] ;
31025: LD_ADDR_VAR 0 6
31029: PUSH
31030: LD_VAR 0 6
31034: PUSH
31035: LD_EXP 64
31039: PUSH
31040: LD_VAR 0 2
31044: ARRAY
31045: DIFF
31046: ST_TO_ADDR
// if not list then
31047: LD_VAR 0 6
31051: NOT
31052: IFFALSE 31056
// continue ;
31054: GO 30429
// k := mc_mines [ i ] - mc_miners [ i ] ;
31056: LD_ADDR_VAR 0 4
31060: PUSH
31061: LD_EXP 63
31065: PUSH
31066: LD_VAR 0 2
31070: ARRAY
31071: PUSH
31072: LD_EXP 64
31076: PUSH
31077: LD_VAR 0 2
31081: ARRAY
31082: MINUS
31083: ST_TO_ADDR
// if k > list then
31084: LD_VAR 0 4
31088: PUSH
31089: LD_VAR 0 6
31093: GREATER
31094: IFFALSE 31106
// k := list ;
31096: LD_ADDR_VAR 0 4
31100: PUSH
31101: LD_VAR 0 6
31105: ST_TO_ADDR
// for j = 1 to k do
31106: LD_ADDR_VAR 0 3
31110: PUSH
31111: DOUBLE
31112: LD_INT 1
31114: DEC
31115: ST_TO_ADDR
31116: LD_VAR 0 4
31120: PUSH
31121: FOR_TO
31122: IFFALSE 31176
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31124: LD_ADDR_EXP 64
31128: PUSH
31129: LD_EXP 64
31133: PPUSH
31134: LD_VAR 0 2
31138: PUSH
31139: LD_EXP 64
31143: PUSH
31144: LD_VAR 0 2
31148: ARRAY
31149: PUSH
31150: LD_INT 1
31152: PLUS
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PPUSH
31158: LD_VAR 0 6
31162: PUSH
31163: LD_VAR 0 3
31167: ARRAY
31168: PPUSH
31169: CALL 53541 0 3
31173: ST_TO_ADDR
31174: GO 31121
31176: POP
31177: POP
// end ;
31178: GO 30429
31180: POP
31181: POP
// end ;
31182: LD_VAR 0 1
31186: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31187: LD_INT 0
31189: PPUSH
31190: PPUSH
31191: PPUSH
31192: PPUSH
31193: PPUSH
31194: PPUSH
31195: PPUSH
31196: PPUSH
31197: PPUSH
31198: PPUSH
31199: PPUSH
// if not mc_bases then
31200: LD_EXP 50
31204: NOT
31205: IFFALSE 31209
// exit ;
31207: GO 33032
// for i = 1 to mc_bases do
31209: LD_ADDR_VAR 0 2
31213: PUSH
31214: DOUBLE
31215: LD_INT 1
31217: DEC
31218: ST_TO_ADDR
31219: LD_EXP 50
31223: PUSH
31224: FOR_TO
31225: IFFALSE 33030
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31227: LD_EXP 50
31231: PUSH
31232: LD_VAR 0 2
31236: ARRAY
31237: NOT
31238: PUSH
31239: LD_EXP 57
31243: PUSH
31244: LD_VAR 0 2
31248: ARRAY
31249: OR
31250: IFFALSE 31254
// continue ;
31252: GO 31224
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31254: LD_EXP 66
31258: PUSH
31259: LD_VAR 0 2
31263: ARRAY
31264: NOT
31265: PUSH
31266: LD_EXP 67
31270: PUSH
31271: LD_VAR 0 2
31275: ARRAY
31276: AND
31277: IFFALSE 31315
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31279: LD_ADDR_EXP 67
31283: PUSH
31284: LD_EXP 67
31288: PPUSH
31289: LD_VAR 0 2
31293: PPUSH
31294: EMPTY
31295: PPUSH
31296: CALL_OW 1
31300: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31301: LD_VAR 0 2
31305: PPUSH
31306: LD_INT 107
31308: PPUSH
31309: CALL 22083 0 2
// continue ;
31313: GO 31224
// end ; target := [ ] ;
31315: LD_ADDR_VAR 0 7
31319: PUSH
31320: EMPTY
31321: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31322: LD_ADDR_VAR 0 6
31326: PUSH
31327: LD_EXP 50
31331: PUSH
31332: LD_VAR 0 2
31336: ARRAY
31337: PUSH
31338: LD_INT 1
31340: ARRAY
31341: PPUSH
31342: CALL_OW 255
31346: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31347: LD_ADDR_VAR 0 9
31351: PUSH
31352: LD_EXP 50
31356: PUSH
31357: LD_VAR 0 2
31361: ARRAY
31362: PPUSH
31363: LD_INT 2
31365: PUSH
31366: LD_INT 30
31368: PUSH
31369: LD_INT 0
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 30
31378: PUSH
31379: LD_INT 1
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: LIST
31390: PPUSH
31391: CALL_OW 72
31395: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31396: LD_ADDR_VAR 0 3
31400: PUSH
31401: DOUBLE
31402: LD_EXP 66
31406: PUSH
31407: LD_VAR 0 2
31411: ARRAY
31412: INC
31413: ST_TO_ADDR
31414: LD_INT 1
31416: PUSH
31417: FOR_DOWNTO
31418: IFFALSE 31663
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31420: LD_EXP 66
31424: PUSH
31425: LD_VAR 0 2
31429: ARRAY
31430: PUSH
31431: LD_VAR 0 3
31435: ARRAY
31436: PUSH
31437: LD_INT 2
31439: ARRAY
31440: PPUSH
31441: LD_EXP 66
31445: PUSH
31446: LD_VAR 0 2
31450: ARRAY
31451: PUSH
31452: LD_VAR 0 3
31456: ARRAY
31457: PUSH
31458: LD_INT 3
31460: ARRAY
31461: PPUSH
31462: CALL_OW 488
31466: PUSH
31467: LD_EXP 66
31471: PUSH
31472: LD_VAR 0 2
31476: ARRAY
31477: PUSH
31478: LD_VAR 0 3
31482: ARRAY
31483: PUSH
31484: LD_INT 2
31486: ARRAY
31487: PPUSH
31488: LD_EXP 66
31492: PUSH
31493: LD_VAR 0 2
31497: ARRAY
31498: PUSH
31499: LD_VAR 0 3
31503: ARRAY
31504: PUSH
31505: LD_INT 3
31507: ARRAY
31508: PPUSH
31509: CALL_OW 284
31513: PUSH
31514: LD_INT 0
31516: EQUAL
31517: AND
31518: IFFALSE 31573
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31520: LD_ADDR_VAR 0 5
31524: PUSH
31525: LD_EXP 66
31529: PUSH
31530: LD_VAR 0 2
31534: ARRAY
31535: PPUSH
31536: LD_VAR 0 3
31540: PPUSH
31541: CALL_OW 3
31545: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31546: LD_ADDR_EXP 66
31550: PUSH
31551: LD_EXP 66
31555: PPUSH
31556: LD_VAR 0 2
31560: PPUSH
31561: LD_VAR 0 5
31565: PPUSH
31566: CALL_OW 1
31570: ST_TO_ADDR
// continue ;
31571: GO 31417
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31573: LD_VAR 0 6
31577: PPUSH
31578: LD_EXP 66
31582: PUSH
31583: LD_VAR 0 2
31587: ARRAY
31588: PUSH
31589: LD_VAR 0 3
31593: ARRAY
31594: PUSH
31595: LD_INT 2
31597: ARRAY
31598: PPUSH
31599: LD_EXP 66
31603: PUSH
31604: LD_VAR 0 2
31608: ARRAY
31609: PUSH
31610: LD_VAR 0 3
31614: ARRAY
31615: PUSH
31616: LD_INT 3
31618: ARRAY
31619: PPUSH
31620: LD_INT 30
31622: PPUSH
31623: CALL 54437 0 4
31627: PUSH
31628: LD_INT 4
31630: ARRAY
31631: PUSH
31632: LD_INT 0
31634: EQUAL
31635: IFFALSE 31661
// begin target := mc_crates [ i ] [ j ] ;
31637: LD_ADDR_VAR 0 7
31641: PUSH
31642: LD_EXP 66
31646: PUSH
31647: LD_VAR 0 2
31651: ARRAY
31652: PUSH
31653: LD_VAR 0 3
31657: ARRAY
31658: ST_TO_ADDR
// break ;
31659: GO 31663
// end ; end ;
31661: GO 31417
31663: POP
31664: POP
// if not target then
31665: LD_VAR 0 7
31669: NOT
31670: IFFALSE 31674
// continue ;
31672: GO 31224
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31674: LD_ADDR_VAR 0 8
31678: PUSH
31679: LD_EXP 69
31683: PUSH
31684: LD_VAR 0 2
31688: ARRAY
31689: PPUSH
31690: LD_INT 2
31692: PUSH
31693: LD_INT 3
31695: PUSH
31696: LD_INT 58
31698: PUSH
31699: EMPTY
31700: LIST
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: PUSH
31706: LD_INT 61
31708: PUSH
31709: EMPTY
31710: LIST
31711: PUSH
31712: LD_INT 33
31714: PUSH
31715: LD_INT 5
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 33
31724: PUSH
31725: LD_INT 3
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: PUSH
31739: LD_INT 2
31741: PUSH
31742: LD_INT 34
31744: PUSH
31745: LD_INT 32
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: LD_INT 34
31754: PUSH
31755: LD_INT 51
31757: PUSH
31758: EMPTY
31759: LIST
31760: LIST
31761: PUSH
31762: LD_INT 34
31764: PUSH
31765: LD_INT 12
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PPUSH
31782: CALL_OW 72
31786: ST_TO_ADDR
// if not cargo then
31787: LD_VAR 0 8
31791: NOT
31792: IFFALSE 32498
// begin if mc_crates_collector [ i ] < 5 then
31794: LD_EXP 67
31798: PUSH
31799: LD_VAR 0 2
31803: ARRAY
31804: PUSH
31805: LD_INT 5
31807: LESS
31808: IFFALSE 32174
// begin if mc_ape [ i ] then
31810: LD_EXP 79
31814: PUSH
31815: LD_VAR 0 2
31819: ARRAY
31820: IFFALSE 31867
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31822: LD_ADDR_VAR 0 5
31826: PUSH
31827: LD_EXP 79
31831: PUSH
31832: LD_VAR 0 2
31836: ARRAY
31837: PPUSH
31838: LD_INT 25
31840: PUSH
31841: LD_INT 16
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: PUSH
31848: LD_INT 24
31850: PUSH
31851: LD_INT 750
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PPUSH
31862: CALL_OW 72
31866: ST_TO_ADDR
// if not tmp then
31867: LD_VAR 0 5
31871: NOT
31872: IFFALSE 31919
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31874: LD_ADDR_VAR 0 5
31878: PUSH
31879: LD_EXP 50
31883: PUSH
31884: LD_VAR 0 2
31888: ARRAY
31889: PPUSH
31890: LD_INT 25
31892: PUSH
31893: LD_INT 2
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 24
31902: PUSH
31903: LD_INT 750
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PPUSH
31914: CALL_OW 72
31918: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31919: LD_EXP 79
31923: PUSH
31924: LD_VAR 0 2
31928: ARRAY
31929: PUSH
31930: LD_EXP 50
31934: PUSH
31935: LD_VAR 0 2
31939: ARRAY
31940: PPUSH
31941: LD_INT 25
31943: PUSH
31944: LD_INT 2
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 24
31953: PUSH
31954: LD_INT 750
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PPUSH
31965: CALL_OW 72
31969: AND
31970: PUSH
31971: LD_VAR 0 5
31975: PUSH
31976: LD_INT 5
31978: LESS
31979: AND
31980: IFFALSE 32062
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31982: LD_ADDR_VAR 0 3
31986: PUSH
31987: LD_EXP 50
31991: PUSH
31992: LD_VAR 0 2
31996: ARRAY
31997: PPUSH
31998: LD_INT 25
32000: PUSH
32001: LD_INT 2
32003: PUSH
32004: EMPTY
32005: LIST
32006: LIST
32007: PUSH
32008: LD_INT 24
32010: PUSH
32011: LD_INT 750
32013: PUSH
32014: EMPTY
32015: LIST
32016: LIST
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PPUSH
32022: CALL_OW 72
32026: PUSH
32027: FOR_IN
32028: IFFALSE 32060
// begin tmp := tmp union j ;
32030: LD_ADDR_VAR 0 5
32034: PUSH
32035: LD_VAR 0 5
32039: PUSH
32040: LD_VAR 0 3
32044: UNION
32045: ST_TO_ADDR
// if tmp >= 5 then
32046: LD_VAR 0 5
32050: PUSH
32051: LD_INT 5
32053: GREATEREQUAL
32054: IFFALSE 32058
// break ;
32056: GO 32060
// end ;
32058: GO 32027
32060: POP
32061: POP
// end ; if not tmp then
32062: LD_VAR 0 5
32066: NOT
32067: IFFALSE 32071
// continue ;
32069: GO 31224
// for j in tmp do
32071: LD_ADDR_VAR 0 3
32075: PUSH
32076: LD_VAR 0 5
32080: PUSH
32081: FOR_IN
32082: IFFALSE 32172
// if not GetTag ( j ) then
32084: LD_VAR 0 3
32088: PPUSH
32089: CALL_OW 110
32093: NOT
32094: IFFALSE 32170
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32096: LD_ADDR_EXP 67
32100: PUSH
32101: LD_EXP 67
32105: PPUSH
32106: LD_VAR 0 2
32110: PUSH
32111: LD_EXP 67
32115: PUSH
32116: LD_VAR 0 2
32120: ARRAY
32121: PUSH
32122: LD_INT 1
32124: PLUS
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PPUSH
32130: LD_VAR 0 3
32134: PPUSH
32135: CALL 53541 0 3
32139: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32140: LD_VAR 0 3
32144: PPUSH
32145: LD_INT 107
32147: PPUSH
32148: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32152: LD_EXP 67
32156: PUSH
32157: LD_VAR 0 2
32161: ARRAY
32162: PUSH
32163: LD_INT 5
32165: GREATEREQUAL
32166: IFFALSE 32170
// break ;
32168: GO 32172
// end ;
32170: GO 32081
32172: POP
32173: POP
// end ; if mc_crates_collector [ i ] and target then
32174: LD_EXP 67
32178: PUSH
32179: LD_VAR 0 2
32183: ARRAY
32184: PUSH
32185: LD_VAR 0 7
32189: AND
32190: IFFALSE 32496
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32192: LD_EXP 67
32196: PUSH
32197: LD_VAR 0 2
32201: ARRAY
32202: PUSH
32203: LD_VAR 0 7
32207: PUSH
32208: LD_INT 1
32210: ARRAY
32211: LESS
32212: IFFALSE 32232
// tmp := mc_crates_collector [ i ] else
32214: LD_ADDR_VAR 0 5
32218: PUSH
32219: LD_EXP 67
32223: PUSH
32224: LD_VAR 0 2
32228: ARRAY
32229: ST_TO_ADDR
32230: GO 32246
// tmp := target [ 1 ] ;
32232: LD_ADDR_VAR 0 5
32236: PUSH
32237: LD_VAR 0 7
32241: PUSH
32242: LD_INT 1
32244: ARRAY
32245: ST_TO_ADDR
// k := 0 ;
32246: LD_ADDR_VAR 0 4
32250: PUSH
32251: LD_INT 0
32253: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32254: LD_ADDR_VAR 0 3
32258: PUSH
32259: LD_EXP 67
32263: PUSH
32264: LD_VAR 0 2
32268: ARRAY
32269: PUSH
32270: FOR_IN
32271: IFFALSE 32494
// begin k := k + 1 ;
32273: LD_ADDR_VAR 0 4
32277: PUSH
32278: LD_VAR 0 4
32282: PUSH
32283: LD_INT 1
32285: PLUS
32286: ST_TO_ADDR
// if k > tmp then
32287: LD_VAR 0 4
32291: PUSH
32292: LD_VAR 0 5
32296: GREATER
32297: IFFALSE 32301
// break ;
32299: GO 32494
// if not GetClass ( j ) in [ 2 , 16 ] then
32301: LD_VAR 0 3
32305: PPUSH
32306: CALL_OW 257
32310: PUSH
32311: LD_INT 2
32313: PUSH
32314: LD_INT 16
32316: PUSH
32317: EMPTY
32318: LIST
32319: LIST
32320: IN
32321: NOT
32322: IFFALSE 32375
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32324: LD_ADDR_EXP 67
32328: PUSH
32329: LD_EXP 67
32333: PPUSH
32334: LD_VAR 0 2
32338: PPUSH
32339: LD_EXP 67
32343: PUSH
32344: LD_VAR 0 2
32348: ARRAY
32349: PUSH
32350: LD_VAR 0 3
32354: DIFF
32355: PPUSH
32356: CALL_OW 1
32360: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32361: LD_VAR 0 3
32365: PPUSH
32366: LD_INT 0
32368: PPUSH
32369: CALL_OW 109
// continue ;
32373: GO 32270
// end ; if IsInUnit ( j ) then
32375: LD_VAR 0 3
32379: PPUSH
32380: CALL_OW 310
32384: IFFALSE 32395
// ComExitBuilding ( j ) ;
32386: LD_VAR 0 3
32390: PPUSH
32391: CALL_OW 122
// wait ( 3 ) ;
32395: LD_INT 3
32397: PPUSH
32398: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32402: LD_VAR 0 3
32406: PPUSH
32407: CALL_OW 314
32411: PUSH
32412: LD_VAR 0 6
32416: PPUSH
32417: LD_VAR 0 7
32421: PUSH
32422: LD_INT 2
32424: ARRAY
32425: PPUSH
32426: LD_VAR 0 7
32430: PUSH
32431: LD_INT 3
32433: ARRAY
32434: PPUSH
32435: LD_INT 30
32437: PPUSH
32438: CALL 54437 0 4
32442: PUSH
32443: LD_INT 4
32445: ARRAY
32446: AND
32447: IFFALSE 32465
// ComStandNearbyBuilding ( j , depot ) else
32449: LD_VAR 0 3
32453: PPUSH
32454: LD_VAR 0 9
32458: PPUSH
32459: CALL 50119 0 2
32463: GO 32492
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32465: LD_VAR 0 3
32469: PPUSH
32470: LD_VAR 0 7
32474: PUSH
32475: LD_INT 2
32477: ARRAY
32478: PPUSH
32479: LD_VAR 0 7
32483: PUSH
32484: LD_INT 3
32486: ARRAY
32487: PPUSH
32488: CALL_OW 117
// end ;
32492: GO 32270
32494: POP
32495: POP
// end ; end else
32496: GO 33028
// begin for j in cargo do
32498: LD_ADDR_VAR 0 3
32502: PUSH
32503: LD_VAR 0 8
32507: PUSH
32508: FOR_IN
32509: IFFALSE 33026
// begin if GetTag ( j ) <> 0 then
32511: LD_VAR 0 3
32515: PPUSH
32516: CALL_OW 110
32520: PUSH
32521: LD_INT 0
32523: NONEQUAL
32524: IFFALSE 32528
// continue ;
32526: GO 32508
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32528: LD_VAR 0 3
32532: PPUSH
32533: CALL_OW 256
32537: PUSH
32538: LD_INT 1000
32540: LESS
32541: PUSH
32542: LD_VAR 0 3
32546: PPUSH
32547: LD_EXP 74
32551: PUSH
32552: LD_VAR 0 2
32556: ARRAY
32557: PPUSH
32558: CALL_OW 308
32562: NOT
32563: AND
32564: IFFALSE 32586
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32566: LD_VAR 0 3
32570: PPUSH
32571: LD_EXP 74
32575: PUSH
32576: LD_VAR 0 2
32580: ARRAY
32581: PPUSH
32582: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32586: LD_VAR 0 3
32590: PPUSH
32591: CALL_OW 256
32595: PUSH
32596: LD_INT 1000
32598: LESS
32599: PUSH
32600: LD_VAR 0 3
32604: PPUSH
32605: LD_EXP 74
32609: PUSH
32610: LD_VAR 0 2
32614: ARRAY
32615: PPUSH
32616: CALL_OW 308
32620: AND
32621: IFFALSE 32625
// continue ;
32623: GO 32508
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32625: LD_VAR 0 3
32629: PPUSH
32630: CALL_OW 262
32634: PUSH
32635: LD_INT 2
32637: EQUAL
32638: PUSH
32639: LD_VAR 0 3
32643: PPUSH
32644: CALL_OW 261
32648: PUSH
32649: LD_INT 15
32651: LESS
32652: AND
32653: IFFALSE 32657
// continue ;
32655: GO 32508
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32657: LD_VAR 0 3
32661: PPUSH
32662: CALL_OW 262
32666: PUSH
32667: LD_INT 1
32669: EQUAL
32670: PUSH
32671: LD_VAR 0 3
32675: PPUSH
32676: CALL_OW 261
32680: PUSH
32681: LD_INT 10
32683: LESS
32684: AND
32685: IFFALSE 32965
// begin if not depot then
32687: LD_VAR 0 9
32691: NOT
32692: IFFALSE 32696
// continue ;
32694: GO 32508
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32696: LD_VAR 0 3
32700: PPUSH
32701: LD_VAR 0 9
32705: PPUSH
32706: LD_VAR 0 3
32710: PPUSH
32711: CALL_OW 74
32715: PPUSH
32716: CALL_OW 296
32720: PUSH
32721: LD_INT 6
32723: LESS
32724: IFFALSE 32740
// SetFuel ( j , 100 ) else
32726: LD_VAR 0 3
32730: PPUSH
32731: LD_INT 100
32733: PPUSH
32734: CALL_OW 240
32738: GO 32965
// if GetFuel ( j ) = 0 then
32740: LD_VAR 0 3
32744: PPUSH
32745: CALL_OW 261
32749: PUSH
32750: LD_INT 0
32752: EQUAL
32753: IFFALSE 32965
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32755: LD_ADDR_EXP 69
32759: PUSH
32760: LD_EXP 69
32764: PPUSH
32765: LD_VAR 0 2
32769: PPUSH
32770: LD_EXP 69
32774: PUSH
32775: LD_VAR 0 2
32779: ARRAY
32780: PUSH
32781: LD_VAR 0 3
32785: DIFF
32786: PPUSH
32787: CALL_OW 1
32791: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32792: LD_VAR 0 3
32796: PPUSH
32797: CALL_OW 263
32801: PUSH
32802: LD_INT 1
32804: EQUAL
32805: IFFALSE 32821
// ComExitVehicle ( IsInUnit ( j ) ) ;
32807: LD_VAR 0 3
32811: PPUSH
32812: CALL_OW 310
32816: PPUSH
32817: CALL_OW 121
// if GetControl ( j ) = control_remote then
32821: LD_VAR 0 3
32825: PPUSH
32826: CALL_OW 263
32830: PUSH
32831: LD_INT 2
32833: EQUAL
32834: IFFALSE 32845
// ComUnlink ( j ) ;
32836: LD_VAR 0 3
32840: PPUSH
32841: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32845: LD_ADDR_VAR 0 10
32849: PUSH
32850: LD_VAR 0 2
32854: PPUSH
32855: LD_INT 3
32857: PPUSH
32858: CALL 42604 0 2
32862: ST_TO_ADDR
// if fac then
32863: LD_VAR 0 10
32867: IFFALSE 32963
// begin for k in fac do
32869: LD_ADDR_VAR 0 4
32873: PUSH
32874: LD_VAR 0 10
32878: PUSH
32879: FOR_IN
32880: IFFALSE 32961
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32882: LD_ADDR_VAR 0 11
32886: PUSH
32887: LD_VAR 0 10
32891: PPUSH
32892: LD_VAR 0 3
32896: PPUSH
32897: CALL_OW 265
32901: PPUSH
32902: LD_VAR 0 3
32906: PPUSH
32907: CALL_OW 262
32911: PPUSH
32912: LD_VAR 0 3
32916: PPUSH
32917: CALL_OW 263
32921: PPUSH
32922: LD_VAR 0 3
32926: PPUSH
32927: CALL_OW 264
32931: PPUSH
32932: CALL 51037 0 5
32936: ST_TO_ADDR
// if components then
32937: LD_VAR 0 11
32941: IFFALSE 32959
// begin MC_InsertProduceList ( i , components ) ;
32943: LD_VAR 0 2
32947: PPUSH
32948: LD_VAR 0 11
32952: PPUSH
32953: CALL 42149 0 2
// break ;
32957: GO 32961
// end ; end ;
32959: GO 32879
32961: POP
32962: POP
// end ; continue ;
32963: GO 32508
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32965: LD_VAR 0 3
32969: PPUSH
32970: LD_INT 1
32972: PPUSH
32973: CALL_OW 289
32977: PUSH
32978: LD_INT 100
32980: LESS
32981: PUSH
32982: LD_VAR 0 3
32986: PPUSH
32987: CALL_OW 314
32991: NOT
32992: AND
32993: IFFALSE 33022
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32995: LD_VAR 0 3
32999: PPUSH
33000: LD_VAR 0 7
33004: PUSH
33005: LD_INT 2
33007: ARRAY
33008: PPUSH
33009: LD_VAR 0 7
33013: PUSH
33014: LD_INT 3
33016: ARRAY
33017: PPUSH
33018: CALL_OW 117
// break ;
33022: GO 33026
// end ;
33024: GO 32508
33026: POP
33027: POP
// end ; end ;
33028: GO 31224
33030: POP
33031: POP
// end ;
33032: LD_VAR 0 1
33036: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33037: LD_INT 0
33039: PPUSH
33040: PPUSH
33041: PPUSH
33042: PPUSH
// if not mc_bases then
33043: LD_EXP 50
33047: NOT
33048: IFFALSE 33052
// exit ;
33050: GO 33213
// for i = 1 to mc_bases do
33052: LD_ADDR_VAR 0 2
33056: PUSH
33057: DOUBLE
33058: LD_INT 1
33060: DEC
33061: ST_TO_ADDR
33062: LD_EXP 50
33066: PUSH
33067: FOR_TO
33068: IFFALSE 33211
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33070: LD_ADDR_VAR 0 4
33074: PUSH
33075: LD_EXP 69
33079: PUSH
33080: LD_VAR 0 2
33084: ARRAY
33085: PUSH
33086: LD_EXP 72
33090: PUSH
33091: LD_VAR 0 2
33095: ARRAY
33096: UNION
33097: PPUSH
33098: LD_INT 33
33100: PUSH
33101: LD_INT 2
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PPUSH
33108: CALL_OW 72
33112: ST_TO_ADDR
// if tmp then
33113: LD_VAR 0 4
33117: IFFALSE 33209
// for j in tmp do
33119: LD_ADDR_VAR 0 3
33123: PUSH
33124: LD_VAR 0 4
33128: PUSH
33129: FOR_IN
33130: IFFALSE 33207
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33132: LD_VAR 0 3
33136: PPUSH
33137: CALL_OW 312
33141: NOT
33142: PUSH
33143: LD_VAR 0 3
33147: PPUSH
33148: CALL_OW 256
33152: PUSH
33153: LD_INT 250
33155: GREATEREQUAL
33156: AND
33157: IFFALSE 33170
// Connect ( j ) else
33159: LD_VAR 0 3
33163: PPUSH
33164: CALL 56512 0 1
33168: GO 33205
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33170: LD_VAR 0 3
33174: PPUSH
33175: CALL_OW 256
33179: PUSH
33180: LD_INT 250
33182: LESS
33183: PUSH
33184: LD_VAR 0 3
33188: PPUSH
33189: CALL_OW 312
33193: AND
33194: IFFALSE 33205
// ComUnlink ( j ) ;
33196: LD_VAR 0 3
33200: PPUSH
33201: CALL_OW 136
33205: GO 33129
33207: POP
33208: POP
// end ;
33209: GO 33067
33211: POP
33212: POP
// end ;
33213: LD_VAR 0 1
33217: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33218: LD_INT 0
33220: PPUSH
33221: PPUSH
33222: PPUSH
33223: PPUSH
33224: PPUSH
// if not mc_bases then
33225: LD_EXP 50
33229: NOT
33230: IFFALSE 33234
// exit ;
33232: GO 33679
// for i = 1 to mc_bases do
33234: LD_ADDR_VAR 0 2
33238: PUSH
33239: DOUBLE
33240: LD_INT 1
33242: DEC
33243: ST_TO_ADDR
33244: LD_EXP 50
33248: PUSH
33249: FOR_TO
33250: IFFALSE 33677
// begin if not mc_produce [ i ] then
33252: LD_EXP 71
33256: PUSH
33257: LD_VAR 0 2
33261: ARRAY
33262: NOT
33263: IFFALSE 33267
// continue ;
33265: GO 33249
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33267: LD_ADDR_VAR 0 5
33271: PUSH
33272: LD_EXP 50
33276: PUSH
33277: LD_VAR 0 2
33281: ARRAY
33282: PPUSH
33283: LD_INT 30
33285: PUSH
33286: LD_INT 3
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PPUSH
33293: CALL_OW 72
33297: ST_TO_ADDR
// if not fac then
33298: LD_VAR 0 5
33302: NOT
33303: IFFALSE 33307
// continue ;
33305: GO 33249
// for j in fac do
33307: LD_ADDR_VAR 0 3
33311: PUSH
33312: LD_VAR 0 5
33316: PUSH
33317: FOR_IN
33318: IFFALSE 33673
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33320: LD_VAR 0 3
33324: PPUSH
33325: CALL_OW 461
33329: PUSH
33330: LD_INT 2
33332: NONEQUAL
33333: PUSH
33334: LD_VAR 0 3
33338: PPUSH
33339: LD_INT 15
33341: PPUSH
33342: CALL 56140 0 2
33346: PUSH
33347: LD_INT 4
33349: ARRAY
33350: OR
33351: IFFALSE 33355
// continue ;
33353: GO 33317
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33355: LD_VAR 0 3
33359: PPUSH
33360: LD_EXP 71
33364: PUSH
33365: LD_VAR 0 2
33369: ARRAY
33370: PUSH
33371: LD_INT 1
33373: ARRAY
33374: PUSH
33375: LD_INT 1
33377: ARRAY
33378: PPUSH
33379: LD_EXP 71
33383: PUSH
33384: LD_VAR 0 2
33388: ARRAY
33389: PUSH
33390: LD_INT 1
33392: ARRAY
33393: PUSH
33394: LD_INT 2
33396: ARRAY
33397: PPUSH
33398: LD_EXP 71
33402: PUSH
33403: LD_VAR 0 2
33407: ARRAY
33408: PUSH
33409: LD_INT 1
33411: ARRAY
33412: PUSH
33413: LD_INT 3
33415: ARRAY
33416: PPUSH
33417: LD_EXP 71
33421: PUSH
33422: LD_VAR 0 2
33426: ARRAY
33427: PUSH
33428: LD_INT 1
33430: ARRAY
33431: PUSH
33432: LD_INT 4
33434: ARRAY
33435: PPUSH
33436: CALL_OW 448
33440: PUSH
33441: LD_VAR 0 3
33445: PPUSH
33446: LD_EXP 71
33450: PUSH
33451: LD_VAR 0 2
33455: ARRAY
33456: PUSH
33457: LD_INT 1
33459: ARRAY
33460: PUSH
33461: LD_INT 1
33463: ARRAY
33464: PUSH
33465: LD_EXP 71
33469: PUSH
33470: LD_VAR 0 2
33474: ARRAY
33475: PUSH
33476: LD_INT 1
33478: ARRAY
33479: PUSH
33480: LD_INT 2
33482: ARRAY
33483: PUSH
33484: LD_EXP 71
33488: PUSH
33489: LD_VAR 0 2
33493: ARRAY
33494: PUSH
33495: LD_INT 1
33497: ARRAY
33498: PUSH
33499: LD_INT 3
33501: ARRAY
33502: PUSH
33503: LD_EXP 71
33507: PUSH
33508: LD_VAR 0 2
33512: ARRAY
33513: PUSH
33514: LD_INT 1
33516: ARRAY
33517: PUSH
33518: LD_INT 4
33520: ARRAY
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: LIST
33526: LIST
33527: PPUSH
33528: CALL 59907 0 2
33532: AND
33533: IFFALSE 33671
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33535: LD_VAR 0 3
33539: PPUSH
33540: LD_EXP 71
33544: PUSH
33545: LD_VAR 0 2
33549: ARRAY
33550: PUSH
33551: LD_INT 1
33553: ARRAY
33554: PUSH
33555: LD_INT 1
33557: ARRAY
33558: PPUSH
33559: LD_EXP 71
33563: PUSH
33564: LD_VAR 0 2
33568: ARRAY
33569: PUSH
33570: LD_INT 1
33572: ARRAY
33573: PUSH
33574: LD_INT 2
33576: ARRAY
33577: PPUSH
33578: LD_EXP 71
33582: PUSH
33583: LD_VAR 0 2
33587: ARRAY
33588: PUSH
33589: LD_INT 1
33591: ARRAY
33592: PUSH
33593: LD_INT 3
33595: ARRAY
33596: PPUSH
33597: LD_EXP 71
33601: PUSH
33602: LD_VAR 0 2
33606: ARRAY
33607: PUSH
33608: LD_INT 1
33610: ARRAY
33611: PUSH
33612: LD_INT 4
33614: ARRAY
33615: PPUSH
33616: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33620: LD_ADDR_VAR 0 4
33624: PUSH
33625: LD_EXP 71
33629: PUSH
33630: LD_VAR 0 2
33634: ARRAY
33635: PPUSH
33636: LD_INT 1
33638: PPUSH
33639: CALL_OW 3
33643: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33644: LD_ADDR_EXP 71
33648: PUSH
33649: LD_EXP 71
33653: PPUSH
33654: LD_VAR 0 2
33658: PPUSH
33659: LD_VAR 0 4
33663: PPUSH
33664: CALL_OW 1
33668: ST_TO_ADDR
// break ;
33669: GO 33673
// end ; end ;
33671: GO 33317
33673: POP
33674: POP
// end ;
33675: GO 33249
33677: POP
33678: POP
// end ;
33679: LD_VAR 0 1
33683: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33684: LD_INT 0
33686: PPUSH
33687: PPUSH
33688: PPUSH
// if not mc_bases then
33689: LD_EXP 50
33693: NOT
33694: IFFALSE 33698
// exit ;
33696: GO 33787
// for i = 1 to mc_bases do
33698: LD_ADDR_VAR 0 2
33702: PUSH
33703: DOUBLE
33704: LD_INT 1
33706: DEC
33707: ST_TO_ADDR
33708: LD_EXP 50
33712: PUSH
33713: FOR_TO
33714: IFFALSE 33785
// begin if mc_attack [ i ] then
33716: LD_EXP 70
33720: PUSH
33721: LD_VAR 0 2
33725: ARRAY
33726: IFFALSE 33783
// begin tmp := mc_attack [ i ] [ 1 ] ;
33728: LD_ADDR_VAR 0 3
33732: PUSH
33733: LD_EXP 70
33737: PUSH
33738: LD_VAR 0 2
33742: ARRAY
33743: PUSH
33744: LD_INT 1
33746: ARRAY
33747: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33748: LD_ADDR_EXP 70
33752: PUSH
33753: LD_EXP 70
33757: PPUSH
33758: LD_VAR 0 2
33762: PPUSH
33763: EMPTY
33764: PPUSH
33765: CALL_OW 1
33769: ST_TO_ADDR
// Attack ( tmp ) ;
33770: LD_VAR 0 3
33774: PPUSH
33775: CALL 107783 0 1
// exit ;
33779: POP
33780: POP
33781: GO 33787
// end ; end ;
33783: GO 33713
33785: POP
33786: POP
// end ;
33787: LD_VAR 0 1
33791: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33792: LD_INT 0
33794: PPUSH
33795: PPUSH
33796: PPUSH
33797: PPUSH
33798: PPUSH
33799: PPUSH
33800: PPUSH
// if not mc_bases then
33801: LD_EXP 50
33805: NOT
33806: IFFALSE 33810
// exit ;
33808: GO 34667
// for i = 1 to mc_bases do
33810: LD_ADDR_VAR 0 2
33814: PUSH
33815: DOUBLE
33816: LD_INT 1
33818: DEC
33819: ST_TO_ADDR
33820: LD_EXP 50
33824: PUSH
33825: FOR_TO
33826: IFFALSE 34665
// begin if not mc_bases [ i ] then
33828: LD_EXP 50
33832: PUSH
33833: LD_VAR 0 2
33837: ARRAY
33838: NOT
33839: IFFALSE 33843
// continue ;
33841: GO 33825
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33843: LD_ADDR_VAR 0 7
33847: PUSH
33848: LD_EXP 50
33852: PUSH
33853: LD_VAR 0 2
33857: ARRAY
33858: PUSH
33859: LD_INT 1
33861: ARRAY
33862: PPUSH
33863: CALL 50341 0 1
33867: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33868: LD_ADDR_EXP 73
33872: PUSH
33873: LD_EXP 73
33877: PPUSH
33878: LD_VAR 0 2
33882: PPUSH
33883: LD_EXP 50
33887: PUSH
33888: LD_VAR 0 2
33892: ARRAY
33893: PUSH
33894: LD_INT 1
33896: ARRAY
33897: PPUSH
33898: CALL_OW 255
33902: PPUSH
33903: LD_EXP 75
33907: PUSH
33908: LD_VAR 0 2
33912: ARRAY
33913: PPUSH
33914: CALL 50306 0 2
33918: PPUSH
33919: CALL_OW 1
33923: ST_TO_ADDR
// if not mc_scan [ i ] then
33924: LD_EXP 73
33928: PUSH
33929: LD_VAR 0 2
33933: ARRAY
33934: NOT
33935: IFFALSE 34113
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
33937: LD_ADDR_EXP 93
33941: PUSH
33942: LD_EXP 93
33946: PPUSH
33947: LD_VAR 0 2
33951: PPUSH
33952: LD_INT 0
33954: PPUSH
33955: CALL_OW 1
33959: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33960: LD_ADDR_VAR 0 4
33964: PUSH
33965: LD_EXP 50
33969: PUSH
33970: LD_VAR 0 2
33974: ARRAY
33975: PPUSH
33976: LD_INT 2
33978: PUSH
33979: LD_INT 25
33981: PUSH
33982: LD_INT 5
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: LD_INT 25
33991: PUSH
33992: LD_INT 8
33994: PUSH
33995: EMPTY
33996: LIST
33997: LIST
33998: PUSH
33999: LD_INT 25
34001: PUSH
34002: LD_INT 9
34004: PUSH
34005: EMPTY
34006: LIST
34007: LIST
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: LIST
34013: LIST
34014: PPUSH
34015: CALL_OW 72
34019: ST_TO_ADDR
// if not tmp then
34020: LD_VAR 0 4
34024: NOT
34025: IFFALSE 34029
// continue ;
34027: GO 33825
// for j in tmp do
34029: LD_ADDR_VAR 0 3
34033: PUSH
34034: LD_VAR 0 4
34038: PUSH
34039: FOR_IN
34040: IFFALSE 34111
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34042: LD_VAR 0 3
34046: PPUSH
34047: CALL_OW 310
34051: PPUSH
34052: CALL_OW 266
34056: PUSH
34057: LD_INT 5
34059: EQUAL
34060: PUSH
34061: LD_VAR 0 3
34065: PPUSH
34066: CALL_OW 257
34070: PUSH
34071: LD_INT 1
34073: EQUAL
34074: AND
34075: PUSH
34076: LD_VAR 0 3
34080: PPUSH
34081: CALL_OW 459
34085: NOT
34086: AND
34087: PUSH
34088: LD_VAR 0 7
34092: AND
34093: IFFALSE 34109
// ComChangeProfession ( j , class ) ;
34095: LD_VAR 0 3
34099: PPUSH
34100: LD_VAR 0 7
34104: PPUSH
34105: CALL_OW 123
34109: GO 34039
34111: POP
34112: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34113: LD_EXP 73
34117: PUSH
34118: LD_VAR 0 2
34122: ARRAY
34123: PUSH
34124: LD_EXP 93
34128: PUSH
34129: LD_VAR 0 2
34133: ARRAY
34134: NOT
34135: AND
34136: PUSH
34137: LD_EXP 72
34141: PUSH
34142: LD_VAR 0 2
34146: ARRAY
34147: NOT
34148: AND
34149: PUSH
34150: LD_EXP 50
34154: PUSH
34155: LD_VAR 0 2
34159: ARRAY
34160: PPUSH
34161: LD_INT 50
34163: PUSH
34164: EMPTY
34165: LIST
34166: PUSH
34167: LD_INT 2
34169: PUSH
34170: LD_INT 30
34172: PUSH
34173: LD_INT 32
34175: PUSH
34176: EMPTY
34177: LIST
34178: LIST
34179: PUSH
34180: LD_INT 30
34182: PUSH
34183: LD_INT 33
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: PUSH
34190: LD_INT 30
34192: PUSH
34193: LD_INT 4
34195: PUSH
34196: EMPTY
34197: LIST
34198: LIST
34199: PUSH
34200: LD_INT 30
34202: PUSH
34203: LD_INT 5
34205: PUSH
34206: EMPTY
34207: LIST
34208: LIST
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: LIST
34214: LIST
34215: LIST
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PPUSH
34221: CALL_OW 72
34225: PUSH
34226: LD_INT 4
34228: LESS
34229: PUSH
34230: LD_EXP 50
34234: PUSH
34235: LD_VAR 0 2
34239: ARRAY
34240: PPUSH
34241: LD_INT 3
34243: PUSH
34244: LD_INT 24
34246: PUSH
34247: LD_INT 1000
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: LD_INT 2
34260: PUSH
34261: LD_INT 30
34263: PUSH
34264: LD_INT 0
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 30
34273: PUSH
34274: LD_INT 1
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: LIST
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PPUSH
34290: CALL_OW 72
34294: OR
34295: AND
34296: IFFALSE 34547
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34298: LD_ADDR_EXP 93
34302: PUSH
34303: LD_EXP 93
34307: PPUSH
34308: LD_VAR 0 2
34312: PPUSH
34313: LD_INT 1
34315: PPUSH
34316: CALL_OW 1
34320: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34321: LD_ADDR_VAR 0 4
34325: PUSH
34326: LD_EXP 50
34330: PUSH
34331: LD_VAR 0 2
34335: ARRAY
34336: PPUSH
34337: LD_INT 2
34339: PUSH
34340: LD_INT 25
34342: PUSH
34343: LD_INT 1
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 25
34352: PUSH
34353: LD_INT 5
34355: PUSH
34356: EMPTY
34357: LIST
34358: LIST
34359: PUSH
34360: LD_INT 25
34362: PUSH
34363: LD_INT 8
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: PUSH
34370: LD_INT 25
34372: PUSH
34373: LD_INT 9
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: LIST
34384: LIST
34385: LIST
34386: PPUSH
34387: CALL_OW 72
34391: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34392: LD_ADDR_VAR 0 4
34396: PUSH
34397: LD_VAR 0 4
34401: PUSH
34402: LD_VAR 0 4
34406: PPUSH
34407: LD_INT 18
34409: PPUSH
34410: CALL 82810 0 2
34414: DIFF
34415: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34416: LD_VAR 0 4
34420: NOT
34421: PUSH
34422: LD_EXP 50
34426: PUSH
34427: LD_VAR 0 2
34431: ARRAY
34432: PPUSH
34433: LD_INT 2
34435: PUSH
34436: LD_INT 30
34438: PUSH
34439: LD_INT 4
34441: PUSH
34442: EMPTY
34443: LIST
34444: LIST
34445: PUSH
34446: LD_INT 30
34448: PUSH
34449: LD_INT 5
34451: PUSH
34452: EMPTY
34453: LIST
34454: LIST
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: LIST
34460: PPUSH
34461: CALL_OW 72
34465: NOT
34466: AND
34467: IFFALSE 34529
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34469: LD_ADDR_VAR 0 4
34473: PUSH
34474: LD_EXP 50
34478: PUSH
34479: LD_VAR 0 2
34483: ARRAY
34484: PPUSH
34485: LD_INT 2
34487: PUSH
34488: LD_INT 25
34490: PUSH
34491: LD_INT 2
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: LD_INT 25
34500: PUSH
34501: LD_INT 3
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 25
34510: PUSH
34511: LD_INT 4
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: LIST
34522: LIST
34523: PPUSH
34524: CALL_OW 72
34528: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34529: LD_VAR 0 2
34533: PPUSH
34534: LD_VAR 0 4
34538: PPUSH
34539: CALL 112492 0 2
// exit ;
34543: POP
34544: POP
34545: GO 34667
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34547: LD_EXP 73
34551: PUSH
34552: LD_VAR 0 2
34556: ARRAY
34557: PUSH
34558: LD_EXP 93
34562: PUSH
34563: LD_VAR 0 2
34567: ARRAY
34568: NOT
34569: AND
34570: PUSH
34571: LD_EXP 72
34575: PUSH
34576: LD_VAR 0 2
34580: ARRAY
34581: AND
34582: IFFALSE 34663
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34584: LD_ADDR_EXP 93
34588: PUSH
34589: LD_EXP 93
34593: PPUSH
34594: LD_VAR 0 2
34598: PPUSH
34599: LD_INT 1
34601: PPUSH
34602: CALL_OW 1
34606: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34607: LD_ADDR_VAR 0 4
34611: PUSH
34612: LD_EXP 72
34616: PUSH
34617: LD_VAR 0 2
34621: ARRAY
34622: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34623: LD_ADDR_EXP 72
34627: PUSH
34628: LD_EXP 72
34632: PPUSH
34633: LD_VAR 0 2
34637: PPUSH
34638: EMPTY
34639: PPUSH
34640: CALL_OW 1
34644: ST_TO_ADDR
// Defend ( i , tmp ) ;
34645: LD_VAR 0 2
34649: PPUSH
34650: LD_VAR 0 4
34654: PPUSH
34655: CALL 113088 0 2
// exit ;
34659: POP
34660: POP
34661: GO 34667
// end ; end ;
34663: GO 33825
34665: POP
34666: POP
// end ;
34667: LD_VAR 0 1
34671: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34672: LD_INT 0
34674: PPUSH
34675: PPUSH
34676: PPUSH
34677: PPUSH
34678: PPUSH
34679: PPUSH
34680: PPUSH
34681: PPUSH
34682: PPUSH
34683: PPUSH
34684: PPUSH
// if not mc_bases then
34685: LD_EXP 50
34689: NOT
34690: IFFALSE 34694
// exit ;
34692: GO 35781
// for i = 1 to mc_bases do
34694: LD_ADDR_VAR 0 2
34698: PUSH
34699: DOUBLE
34700: LD_INT 1
34702: DEC
34703: ST_TO_ADDR
34704: LD_EXP 50
34708: PUSH
34709: FOR_TO
34710: IFFALSE 35779
// begin tmp := mc_lab [ i ] ;
34712: LD_ADDR_VAR 0 6
34716: PUSH
34717: LD_EXP 83
34721: PUSH
34722: LD_VAR 0 2
34726: ARRAY
34727: ST_TO_ADDR
// if not tmp then
34728: LD_VAR 0 6
34732: NOT
34733: IFFALSE 34737
// continue ;
34735: GO 34709
// idle_lab := 0 ;
34737: LD_ADDR_VAR 0 11
34741: PUSH
34742: LD_INT 0
34744: ST_TO_ADDR
// for j in tmp do
34745: LD_ADDR_VAR 0 3
34749: PUSH
34750: LD_VAR 0 6
34754: PUSH
34755: FOR_IN
34756: IFFALSE 35775
// begin researching := false ;
34758: LD_ADDR_VAR 0 10
34762: PUSH
34763: LD_INT 0
34765: ST_TO_ADDR
// side := GetSide ( j ) ;
34766: LD_ADDR_VAR 0 4
34770: PUSH
34771: LD_VAR 0 3
34775: PPUSH
34776: CALL_OW 255
34780: ST_TO_ADDR
// if not mc_tech [ side ] then
34781: LD_EXP 77
34785: PUSH
34786: LD_VAR 0 4
34790: ARRAY
34791: NOT
34792: IFFALSE 34796
// continue ;
34794: GO 34755
// if BuildingStatus ( j ) = bs_idle then
34796: LD_VAR 0 3
34800: PPUSH
34801: CALL_OW 461
34805: PUSH
34806: LD_INT 2
34808: EQUAL
34809: IFFALSE 34997
// begin if idle_lab and UnitsInside ( j ) < 6 then
34811: LD_VAR 0 11
34815: PUSH
34816: LD_VAR 0 3
34820: PPUSH
34821: CALL_OW 313
34825: PUSH
34826: LD_INT 6
34828: LESS
34829: AND
34830: IFFALSE 34901
// begin tmp2 := UnitsInside ( idle_lab ) ;
34832: LD_ADDR_VAR 0 9
34836: PUSH
34837: LD_VAR 0 11
34841: PPUSH
34842: CALL_OW 313
34846: ST_TO_ADDR
// if tmp2 then
34847: LD_VAR 0 9
34851: IFFALSE 34893
// for x in tmp2 do
34853: LD_ADDR_VAR 0 7
34857: PUSH
34858: LD_VAR 0 9
34862: PUSH
34863: FOR_IN
34864: IFFALSE 34891
// begin ComExitBuilding ( x ) ;
34866: LD_VAR 0 7
34870: PPUSH
34871: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34875: LD_VAR 0 7
34879: PPUSH
34880: LD_VAR 0 3
34884: PPUSH
34885: CALL_OW 180
// end ;
34889: GO 34863
34891: POP
34892: POP
// idle_lab := 0 ;
34893: LD_ADDR_VAR 0 11
34897: PUSH
34898: LD_INT 0
34900: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34901: LD_ADDR_VAR 0 5
34905: PUSH
34906: LD_EXP 77
34910: PUSH
34911: LD_VAR 0 4
34915: ARRAY
34916: PUSH
34917: FOR_IN
34918: IFFALSE 34978
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
34920: LD_VAR 0 3
34924: PPUSH
34925: LD_VAR 0 5
34929: PPUSH
34930: CALL_OW 430
34934: PUSH
34935: LD_VAR 0 4
34939: PPUSH
34940: LD_VAR 0 5
34944: PPUSH
34945: CALL 49411 0 2
34949: AND
34950: IFFALSE 34976
// begin researching := true ;
34952: LD_ADDR_VAR 0 10
34956: PUSH
34957: LD_INT 1
34959: ST_TO_ADDR
// ComResearch ( j , t ) ;
34960: LD_VAR 0 3
34964: PPUSH
34965: LD_VAR 0 5
34969: PPUSH
34970: CALL_OW 124
// break ;
34974: GO 34978
// end ;
34976: GO 34917
34978: POP
34979: POP
// if not researching then
34980: LD_VAR 0 10
34984: NOT
34985: IFFALSE 34997
// idle_lab := j ;
34987: LD_ADDR_VAR 0 11
34991: PUSH
34992: LD_VAR 0 3
34996: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
34997: LD_VAR 0 3
35001: PPUSH
35002: CALL_OW 461
35006: PUSH
35007: LD_INT 10
35009: EQUAL
35010: IFFALSE 35598
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35012: LD_EXP 79
35016: PUSH
35017: LD_VAR 0 2
35021: ARRAY
35022: NOT
35023: PUSH
35024: LD_EXP 80
35028: PUSH
35029: LD_VAR 0 2
35033: ARRAY
35034: NOT
35035: AND
35036: PUSH
35037: LD_EXP 77
35041: PUSH
35042: LD_VAR 0 4
35046: ARRAY
35047: PUSH
35048: LD_INT 1
35050: GREATER
35051: AND
35052: IFFALSE 35183
// begin ComCancel ( j ) ;
35054: LD_VAR 0 3
35058: PPUSH
35059: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35063: LD_ADDR_EXP 77
35067: PUSH
35068: LD_EXP 77
35072: PPUSH
35073: LD_VAR 0 4
35077: PPUSH
35078: LD_EXP 77
35082: PUSH
35083: LD_VAR 0 4
35087: ARRAY
35088: PPUSH
35089: LD_EXP 77
35093: PUSH
35094: LD_VAR 0 4
35098: ARRAY
35099: PUSH
35100: LD_INT 1
35102: MINUS
35103: PPUSH
35104: LD_EXP 77
35108: PUSH
35109: LD_VAR 0 4
35113: ARRAY
35114: PPUSH
35115: LD_INT 0
35117: PPUSH
35118: CALL 52959 0 4
35122: PPUSH
35123: CALL_OW 1
35127: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35128: LD_ADDR_EXP 77
35132: PUSH
35133: LD_EXP 77
35137: PPUSH
35138: LD_VAR 0 4
35142: PPUSH
35143: LD_EXP 77
35147: PUSH
35148: LD_VAR 0 4
35152: ARRAY
35153: PPUSH
35154: LD_EXP 77
35158: PUSH
35159: LD_VAR 0 4
35163: ARRAY
35164: PPUSH
35165: LD_INT 1
35167: PPUSH
35168: LD_INT 0
35170: PPUSH
35171: CALL 52959 0 4
35175: PPUSH
35176: CALL_OW 1
35180: ST_TO_ADDR
// continue ;
35181: GO 34755
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35183: LD_EXP 79
35187: PUSH
35188: LD_VAR 0 2
35192: ARRAY
35193: PUSH
35194: LD_EXP 80
35198: PUSH
35199: LD_VAR 0 2
35203: ARRAY
35204: NOT
35205: AND
35206: IFFALSE 35333
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35208: LD_ADDR_EXP 80
35212: PUSH
35213: LD_EXP 80
35217: PPUSH
35218: LD_VAR 0 2
35222: PUSH
35223: LD_EXP 80
35227: PUSH
35228: LD_VAR 0 2
35232: ARRAY
35233: PUSH
35234: LD_INT 1
35236: PLUS
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PPUSH
35242: LD_EXP 79
35246: PUSH
35247: LD_VAR 0 2
35251: ARRAY
35252: PUSH
35253: LD_INT 1
35255: ARRAY
35256: PPUSH
35257: CALL 53541 0 3
35261: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35262: LD_EXP 79
35266: PUSH
35267: LD_VAR 0 2
35271: ARRAY
35272: PUSH
35273: LD_INT 1
35275: ARRAY
35276: PPUSH
35277: LD_INT 112
35279: PPUSH
35280: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35284: LD_ADDR_VAR 0 9
35288: PUSH
35289: LD_EXP 79
35293: PUSH
35294: LD_VAR 0 2
35298: ARRAY
35299: PPUSH
35300: LD_INT 1
35302: PPUSH
35303: CALL_OW 3
35307: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35308: LD_ADDR_EXP 79
35312: PUSH
35313: LD_EXP 79
35317: PPUSH
35318: LD_VAR 0 2
35322: PPUSH
35323: LD_VAR 0 9
35327: PPUSH
35328: CALL_OW 1
35332: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35333: LD_EXP 79
35337: PUSH
35338: LD_VAR 0 2
35342: ARRAY
35343: PUSH
35344: LD_EXP 80
35348: PUSH
35349: LD_VAR 0 2
35353: ARRAY
35354: AND
35355: PUSH
35356: LD_EXP 80
35360: PUSH
35361: LD_VAR 0 2
35365: ARRAY
35366: PUSH
35367: LD_INT 1
35369: ARRAY
35370: PPUSH
35371: CALL_OW 310
35375: NOT
35376: AND
35377: PUSH
35378: LD_VAR 0 3
35382: PPUSH
35383: CALL_OW 313
35387: PUSH
35388: LD_INT 6
35390: EQUAL
35391: AND
35392: IFFALSE 35448
// begin tmp2 := UnitsInside ( j ) ;
35394: LD_ADDR_VAR 0 9
35398: PUSH
35399: LD_VAR 0 3
35403: PPUSH
35404: CALL_OW 313
35408: ST_TO_ADDR
// if tmp2 = 6 then
35409: LD_VAR 0 9
35413: PUSH
35414: LD_INT 6
35416: EQUAL
35417: IFFALSE 35448
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35419: LD_VAR 0 9
35423: PUSH
35424: LD_INT 1
35426: ARRAY
35427: PPUSH
35428: LD_INT 112
35430: PPUSH
35431: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35435: LD_VAR 0 9
35439: PUSH
35440: LD_INT 1
35442: ARRAY
35443: PPUSH
35444: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35448: LD_EXP 80
35452: PUSH
35453: LD_VAR 0 2
35457: ARRAY
35458: PUSH
35459: LD_EXP 80
35463: PUSH
35464: LD_VAR 0 2
35468: ARRAY
35469: PUSH
35470: LD_INT 1
35472: ARRAY
35473: PPUSH
35474: CALL_OW 314
35478: NOT
35479: AND
35480: PUSH
35481: LD_EXP 80
35485: PUSH
35486: LD_VAR 0 2
35490: ARRAY
35491: PUSH
35492: LD_INT 1
35494: ARRAY
35495: PPUSH
35496: CALL_OW 310
35500: NOT
35501: AND
35502: IFFALSE 35528
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35504: LD_EXP 80
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: PUSH
35515: LD_INT 1
35517: ARRAY
35518: PPUSH
35519: LD_VAR 0 3
35523: PPUSH
35524: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35528: LD_EXP 80
35532: PUSH
35533: LD_VAR 0 2
35537: ARRAY
35538: PUSH
35539: LD_INT 1
35541: ARRAY
35542: PPUSH
35543: CALL_OW 310
35547: PUSH
35548: LD_EXP 80
35552: PUSH
35553: LD_VAR 0 2
35557: ARRAY
35558: PUSH
35559: LD_INT 1
35561: ARRAY
35562: PPUSH
35563: CALL_OW 310
35567: PPUSH
35568: CALL_OW 461
35572: PUSH
35573: LD_INT 3
35575: NONEQUAL
35576: AND
35577: IFFALSE 35598
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35579: LD_EXP 80
35583: PUSH
35584: LD_VAR 0 2
35588: ARRAY
35589: PUSH
35590: LD_INT 1
35592: ARRAY
35593: PPUSH
35594: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35598: LD_VAR 0 3
35602: PPUSH
35603: CALL_OW 461
35607: PUSH
35608: LD_INT 6
35610: EQUAL
35611: PUSH
35612: LD_VAR 0 6
35616: PUSH
35617: LD_INT 1
35619: GREATER
35620: AND
35621: IFFALSE 35773
// begin sci := [ ] ;
35623: LD_ADDR_VAR 0 8
35627: PUSH
35628: EMPTY
35629: ST_TO_ADDR
// for x in ( tmp diff j ) do
35630: LD_ADDR_VAR 0 7
35634: PUSH
35635: LD_VAR 0 6
35639: PUSH
35640: LD_VAR 0 3
35644: DIFF
35645: PUSH
35646: FOR_IN
35647: IFFALSE 35699
// begin if sci = 6 then
35649: LD_VAR 0 8
35653: PUSH
35654: LD_INT 6
35656: EQUAL
35657: IFFALSE 35661
// break ;
35659: GO 35699
// if BuildingStatus ( x ) = bs_idle then
35661: LD_VAR 0 7
35665: PPUSH
35666: CALL_OW 461
35670: PUSH
35671: LD_INT 2
35673: EQUAL
35674: IFFALSE 35697
// sci := sci ^ UnitsInside ( x ) ;
35676: LD_ADDR_VAR 0 8
35680: PUSH
35681: LD_VAR 0 8
35685: PUSH
35686: LD_VAR 0 7
35690: PPUSH
35691: CALL_OW 313
35695: ADD
35696: ST_TO_ADDR
// end ;
35697: GO 35646
35699: POP
35700: POP
// if not sci then
35701: LD_VAR 0 8
35705: NOT
35706: IFFALSE 35710
// continue ;
35708: GO 34755
// for x in sci do
35710: LD_ADDR_VAR 0 7
35714: PUSH
35715: LD_VAR 0 8
35719: PUSH
35720: FOR_IN
35721: IFFALSE 35771
// if IsInUnit ( x ) and not HasTask ( x ) then
35723: LD_VAR 0 7
35727: PPUSH
35728: CALL_OW 310
35732: PUSH
35733: LD_VAR 0 7
35737: PPUSH
35738: CALL_OW 314
35742: NOT
35743: AND
35744: IFFALSE 35769
// begin ComExitBuilding ( x ) ;
35746: LD_VAR 0 7
35750: PPUSH
35751: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35755: LD_VAR 0 7
35759: PPUSH
35760: LD_VAR 0 3
35764: PPUSH
35765: CALL_OW 180
// end ;
35769: GO 35720
35771: POP
35772: POP
// end ; end ;
35773: GO 34755
35775: POP
35776: POP
// end ;
35777: GO 34709
35779: POP
35780: POP
// end ;
35781: LD_VAR 0 1
35785: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35786: LD_INT 0
35788: PPUSH
35789: PPUSH
// if not mc_bases then
35790: LD_EXP 50
35794: NOT
35795: IFFALSE 35799
// exit ;
35797: GO 35880
// for i = 1 to mc_bases do
35799: LD_ADDR_VAR 0 2
35803: PUSH
35804: DOUBLE
35805: LD_INT 1
35807: DEC
35808: ST_TO_ADDR
35809: LD_EXP 50
35813: PUSH
35814: FOR_TO
35815: IFFALSE 35878
// if mc_mines [ i ] and mc_miners [ i ] then
35817: LD_EXP 63
35821: PUSH
35822: LD_VAR 0 2
35826: ARRAY
35827: PUSH
35828: LD_EXP 64
35832: PUSH
35833: LD_VAR 0 2
35837: ARRAY
35838: AND
35839: IFFALSE 35876
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35841: LD_EXP 64
35845: PUSH
35846: LD_VAR 0 2
35850: ARRAY
35851: PUSH
35852: LD_INT 1
35854: ARRAY
35855: PPUSH
35856: CALL_OW 255
35860: PPUSH
35861: LD_EXP 63
35865: PUSH
35866: LD_VAR 0 2
35870: ARRAY
35871: PPUSH
35872: CALL 50494 0 2
35876: GO 35814
35878: POP
35879: POP
// end ;
35880: LD_VAR 0 1
35884: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35885: LD_INT 0
35887: PPUSH
35888: PPUSH
35889: PPUSH
35890: PPUSH
35891: PPUSH
35892: PPUSH
35893: PPUSH
35894: PPUSH
// if not mc_bases or not mc_parking then
35895: LD_EXP 50
35899: NOT
35900: PUSH
35901: LD_EXP 74
35905: NOT
35906: OR
35907: IFFALSE 35911
// exit ;
35909: GO 36621
// for i = 1 to mc_bases do
35911: LD_ADDR_VAR 0 2
35915: PUSH
35916: DOUBLE
35917: LD_INT 1
35919: DEC
35920: ST_TO_ADDR
35921: LD_EXP 50
35925: PUSH
35926: FOR_TO
35927: IFFALSE 36619
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
35929: LD_EXP 50
35933: PUSH
35934: LD_VAR 0 2
35938: ARRAY
35939: NOT
35940: PUSH
35941: LD_EXP 74
35945: PUSH
35946: LD_VAR 0 2
35950: ARRAY
35951: NOT
35952: OR
35953: IFFALSE 35957
// continue ;
35955: GO 35926
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35957: LD_ADDR_VAR 0 5
35961: PUSH
35962: LD_EXP 50
35966: PUSH
35967: LD_VAR 0 2
35971: ARRAY
35972: PUSH
35973: LD_INT 1
35975: ARRAY
35976: PPUSH
35977: CALL_OW 255
35981: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35982: LD_ADDR_VAR 0 6
35986: PUSH
35987: LD_EXP 50
35991: PUSH
35992: LD_VAR 0 2
35996: ARRAY
35997: PPUSH
35998: LD_INT 30
36000: PUSH
36001: LD_INT 3
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PPUSH
36008: CALL_OW 72
36012: ST_TO_ADDR
// if not fac then
36013: LD_VAR 0 6
36017: NOT
36018: IFFALSE 36069
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36020: LD_ADDR_VAR 0 6
36024: PUSH
36025: LD_EXP 50
36029: PUSH
36030: LD_VAR 0 2
36034: ARRAY
36035: PPUSH
36036: LD_INT 2
36038: PUSH
36039: LD_INT 30
36041: PUSH
36042: LD_INT 0
36044: PUSH
36045: EMPTY
36046: LIST
36047: LIST
36048: PUSH
36049: LD_INT 30
36051: PUSH
36052: LD_INT 1
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: LIST
36063: PPUSH
36064: CALL_OW 72
36068: ST_TO_ADDR
// if not fac then
36069: LD_VAR 0 6
36073: NOT
36074: IFFALSE 36078
// continue ;
36076: GO 35926
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36078: LD_ADDR_VAR 0 7
36082: PUSH
36083: LD_EXP 74
36087: PUSH
36088: LD_VAR 0 2
36092: ARRAY
36093: PPUSH
36094: LD_INT 22
36096: PUSH
36097: LD_VAR 0 5
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: PUSH
36106: LD_INT 21
36108: PUSH
36109: LD_INT 2
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: PUSH
36116: LD_INT 3
36118: PUSH
36119: LD_INT 24
36121: PUSH
36122: LD_INT 1000
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: EMPTY
36130: LIST
36131: LIST
36132: PUSH
36133: EMPTY
36134: LIST
36135: LIST
36136: LIST
36137: PPUSH
36138: CALL_OW 70
36142: ST_TO_ADDR
// for j in fac do
36143: LD_ADDR_VAR 0 3
36147: PUSH
36148: LD_VAR 0 6
36152: PUSH
36153: FOR_IN
36154: IFFALSE 36235
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36156: LD_ADDR_VAR 0 7
36160: PUSH
36161: LD_VAR 0 7
36165: PUSH
36166: LD_INT 22
36168: PUSH
36169: LD_VAR 0 5
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PUSH
36178: LD_INT 91
36180: PUSH
36181: LD_VAR 0 3
36185: PUSH
36186: LD_INT 15
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 21
36196: PUSH
36197: LD_INT 2
36199: PUSH
36200: EMPTY
36201: LIST
36202: LIST
36203: PUSH
36204: LD_INT 3
36206: PUSH
36207: LD_INT 24
36209: PUSH
36210: LD_INT 1000
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: EMPTY
36218: LIST
36219: LIST
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: LIST
36225: LIST
36226: PPUSH
36227: CALL_OW 69
36231: UNION
36232: ST_TO_ADDR
36233: GO 36153
36235: POP
36236: POP
// if not vehs then
36237: LD_VAR 0 7
36241: NOT
36242: IFFALSE 36268
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36244: LD_ADDR_EXP 62
36248: PUSH
36249: LD_EXP 62
36253: PPUSH
36254: LD_VAR 0 2
36258: PPUSH
36259: EMPTY
36260: PPUSH
36261: CALL_OW 1
36265: ST_TO_ADDR
// continue ;
36266: GO 35926
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36268: LD_ADDR_VAR 0 8
36272: PUSH
36273: LD_EXP 50
36277: PUSH
36278: LD_VAR 0 2
36282: ARRAY
36283: PPUSH
36284: LD_INT 30
36286: PUSH
36287: LD_INT 3
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PPUSH
36294: CALL_OW 72
36298: ST_TO_ADDR
// if tmp then
36299: LD_VAR 0 8
36303: IFFALSE 36406
// begin for j in tmp do
36305: LD_ADDR_VAR 0 3
36309: PUSH
36310: LD_VAR 0 8
36314: PUSH
36315: FOR_IN
36316: IFFALSE 36404
// for k in UnitsInside ( j ) do
36318: LD_ADDR_VAR 0 4
36322: PUSH
36323: LD_VAR 0 3
36327: PPUSH
36328: CALL_OW 313
36332: PUSH
36333: FOR_IN
36334: IFFALSE 36400
// if k then
36336: LD_VAR 0 4
36340: IFFALSE 36398
// if not k in mc_repair_vehicle [ i ] then
36342: LD_VAR 0 4
36346: PUSH
36347: LD_EXP 62
36351: PUSH
36352: LD_VAR 0 2
36356: ARRAY
36357: IN
36358: NOT
36359: IFFALSE 36398
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36361: LD_ADDR_EXP 62
36365: PUSH
36366: LD_EXP 62
36370: PPUSH
36371: LD_VAR 0 2
36375: PPUSH
36376: LD_EXP 62
36380: PUSH
36381: LD_VAR 0 2
36385: ARRAY
36386: PUSH
36387: LD_VAR 0 4
36391: UNION
36392: PPUSH
36393: CALL_OW 1
36397: ST_TO_ADDR
36398: GO 36333
36400: POP
36401: POP
36402: GO 36315
36404: POP
36405: POP
// end ; if not mc_repair_vehicle [ i ] then
36406: LD_EXP 62
36410: PUSH
36411: LD_VAR 0 2
36415: ARRAY
36416: NOT
36417: IFFALSE 36421
// continue ;
36419: GO 35926
// for j in mc_repair_vehicle [ i ] do
36421: LD_ADDR_VAR 0 3
36425: PUSH
36426: LD_EXP 62
36430: PUSH
36431: LD_VAR 0 2
36435: ARRAY
36436: PUSH
36437: FOR_IN
36438: IFFALSE 36615
// begin if GetClass ( j ) <> 3 then
36440: LD_VAR 0 3
36444: PPUSH
36445: CALL_OW 257
36449: PUSH
36450: LD_INT 3
36452: NONEQUAL
36453: IFFALSE 36494
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36455: LD_ADDR_EXP 62
36459: PUSH
36460: LD_EXP 62
36464: PPUSH
36465: LD_VAR 0 2
36469: PPUSH
36470: LD_EXP 62
36474: PUSH
36475: LD_VAR 0 2
36479: ARRAY
36480: PUSH
36481: LD_VAR 0 3
36485: DIFF
36486: PPUSH
36487: CALL_OW 1
36491: ST_TO_ADDR
// continue ;
36492: GO 36437
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36494: LD_VAR 0 3
36498: PPUSH
36499: CALL_OW 311
36503: NOT
36504: PUSH
36505: LD_VAR 0 3
36509: PUSH
36510: LD_EXP 53
36514: PUSH
36515: LD_VAR 0 2
36519: ARRAY
36520: PUSH
36521: LD_INT 1
36523: ARRAY
36524: IN
36525: NOT
36526: AND
36527: PUSH
36528: LD_VAR 0 3
36532: PUSH
36533: LD_EXP 53
36537: PUSH
36538: LD_VAR 0 2
36542: ARRAY
36543: PUSH
36544: LD_INT 2
36546: ARRAY
36547: IN
36548: NOT
36549: AND
36550: IFFALSE 36613
// begin if IsInUnit ( j ) then
36552: LD_VAR 0 3
36556: PPUSH
36557: CALL_OW 310
36561: IFFALSE 36574
// ComExitBuilding ( j ) else
36563: LD_VAR 0 3
36567: PPUSH
36568: CALL_OW 122
36572: GO 36613
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36574: LD_VAR 0 3
36578: PPUSH
36579: LD_VAR 0 7
36583: PUSH
36584: LD_INT 1
36586: ARRAY
36587: PPUSH
36588: CALL 87349 0 2
36592: NOT
36593: IFFALSE 36613
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
36595: LD_VAR 0 3
36599: PPUSH
36600: LD_VAR 0 7
36604: PUSH
36605: LD_INT 1
36607: ARRAY
36608: PPUSH
36609: CALL_OW 129
// end ; end ;
36613: GO 36437
36615: POP
36616: POP
// end ;
36617: GO 35926
36619: POP
36620: POP
// end ;
36621: LD_VAR 0 1
36625: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36626: LD_INT 0
36628: PPUSH
36629: PPUSH
36630: PPUSH
36631: PPUSH
36632: PPUSH
36633: PPUSH
36634: PPUSH
36635: PPUSH
36636: PPUSH
36637: PPUSH
36638: PPUSH
// if not mc_bases then
36639: LD_EXP 50
36643: NOT
36644: IFFALSE 36648
// exit ;
36646: GO 37450
// for i = 1 to mc_bases do
36648: LD_ADDR_VAR 0 2
36652: PUSH
36653: DOUBLE
36654: LD_INT 1
36656: DEC
36657: ST_TO_ADDR
36658: LD_EXP 50
36662: PUSH
36663: FOR_TO
36664: IFFALSE 37448
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36666: LD_EXP 78
36670: PUSH
36671: LD_VAR 0 2
36675: ARRAY
36676: NOT
36677: PUSH
36678: LD_EXP 53
36682: PUSH
36683: LD_VAR 0 2
36687: ARRAY
36688: PUSH
36689: LD_INT 1
36691: ARRAY
36692: OR
36693: PUSH
36694: LD_EXP 53
36698: PUSH
36699: LD_VAR 0 2
36703: ARRAY
36704: PUSH
36705: LD_INT 2
36707: ARRAY
36708: OR
36709: PUSH
36710: LD_EXP 76
36714: PUSH
36715: LD_VAR 0 2
36719: ARRAY
36720: PPUSH
36721: LD_INT 1
36723: PPUSH
36724: CALL_OW 325
36728: NOT
36729: OR
36730: PUSH
36731: LD_EXP 73
36735: PUSH
36736: LD_VAR 0 2
36740: ARRAY
36741: OR
36742: IFFALSE 36746
// continue ;
36744: GO 36663
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36746: LD_ADDR_VAR 0 8
36750: PUSH
36751: LD_EXP 50
36755: PUSH
36756: LD_VAR 0 2
36760: ARRAY
36761: PPUSH
36762: LD_INT 25
36764: PUSH
36765: LD_INT 4
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 50
36774: PUSH
36775: EMPTY
36776: LIST
36777: PUSH
36778: LD_INT 3
36780: PUSH
36781: LD_INT 60
36783: PUSH
36784: EMPTY
36785: LIST
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: LIST
36795: PPUSH
36796: CALL_OW 72
36800: PUSH
36801: LD_EXP 54
36805: PUSH
36806: LD_VAR 0 2
36810: ARRAY
36811: DIFF
36812: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36813: LD_ADDR_VAR 0 9
36817: PUSH
36818: LD_EXP 50
36822: PUSH
36823: LD_VAR 0 2
36827: ARRAY
36828: PPUSH
36829: LD_INT 2
36831: PUSH
36832: LD_INT 30
36834: PUSH
36835: LD_INT 0
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: PUSH
36842: LD_INT 30
36844: PUSH
36845: LD_INT 1
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: LIST
36856: PPUSH
36857: CALL_OW 72
36861: ST_TO_ADDR
// if not tmp or not dep then
36862: LD_VAR 0 8
36866: NOT
36867: PUSH
36868: LD_VAR 0 9
36872: NOT
36873: OR
36874: IFFALSE 36878
// continue ;
36876: GO 36663
// side := GetSide ( tmp [ 1 ] ) ;
36878: LD_ADDR_VAR 0 11
36882: PUSH
36883: LD_VAR 0 8
36887: PUSH
36888: LD_INT 1
36890: ARRAY
36891: PPUSH
36892: CALL_OW 255
36896: ST_TO_ADDR
// dep := dep [ 1 ] ;
36897: LD_ADDR_VAR 0 9
36901: PUSH
36902: LD_VAR 0 9
36906: PUSH
36907: LD_INT 1
36909: ARRAY
36910: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
36911: LD_ADDR_VAR 0 7
36915: PUSH
36916: LD_EXP 78
36920: PUSH
36921: LD_VAR 0 2
36925: ARRAY
36926: PPUSH
36927: LD_INT 22
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 25
36939: PUSH
36940: LD_INT 12
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PPUSH
36951: CALL_OW 70
36955: PUSH
36956: LD_INT 22
36958: PUSH
36959: LD_INT 0
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: PUSH
36966: LD_INT 25
36968: PUSH
36969: LD_INT 12
36971: PUSH
36972: EMPTY
36973: LIST
36974: LIST
36975: PUSH
36976: LD_INT 91
36978: PUSH
36979: LD_VAR 0 9
36983: PUSH
36984: LD_INT 20
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: LIST
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: LIST
36996: PPUSH
36997: CALL_OW 69
37001: UNION
37002: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37003: LD_ADDR_VAR 0 10
37007: PUSH
37008: LD_EXP 78
37012: PUSH
37013: LD_VAR 0 2
37017: ARRAY
37018: PPUSH
37019: LD_INT 81
37021: PUSH
37022: LD_VAR 0 11
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PPUSH
37031: CALL_OW 70
37035: ST_TO_ADDR
// if not apes or danger_at_area then
37036: LD_VAR 0 7
37040: NOT
37041: PUSH
37042: LD_VAR 0 10
37046: OR
37047: IFFALSE 37097
// begin if mc_taming [ i ] then
37049: LD_EXP 81
37053: PUSH
37054: LD_VAR 0 2
37058: ARRAY
37059: IFFALSE 37095
// begin MC_Reset ( i , 121 ) ;
37061: LD_VAR 0 2
37065: PPUSH
37066: LD_INT 121
37068: PPUSH
37069: CALL 22083 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37073: LD_ADDR_EXP 81
37077: PUSH
37078: LD_EXP 81
37082: PPUSH
37083: LD_VAR 0 2
37087: PPUSH
37088: EMPTY
37089: PPUSH
37090: CALL_OW 1
37094: ST_TO_ADDR
// end ; continue ;
37095: GO 36663
// end ; for j in tmp do
37097: LD_ADDR_VAR 0 3
37101: PUSH
37102: LD_VAR 0 8
37106: PUSH
37107: FOR_IN
37108: IFFALSE 37444
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37110: LD_VAR 0 3
37114: PUSH
37115: LD_EXP 81
37119: PUSH
37120: LD_VAR 0 2
37124: ARRAY
37125: IN
37126: NOT
37127: PUSH
37128: LD_EXP 81
37132: PUSH
37133: LD_VAR 0 2
37137: ARRAY
37138: PUSH
37139: LD_INT 3
37141: LESS
37142: AND
37143: IFFALSE 37201
// begin SetTag ( j , 121 ) ;
37145: LD_VAR 0 3
37149: PPUSH
37150: LD_INT 121
37152: PPUSH
37153: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37157: LD_ADDR_EXP 81
37161: PUSH
37162: LD_EXP 81
37166: PPUSH
37167: LD_VAR 0 2
37171: PUSH
37172: LD_EXP 81
37176: PUSH
37177: LD_VAR 0 2
37181: ARRAY
37182: PUSH
37183: LD_INT 1
37185: PLUS
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PPUSH
37191: LD_VAR 0 3
37195: PPUSH
37196: CALL 53541 0 3
37200: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37201: LD_VAR 0 3
37205: PUSH
37206: LD_EXP 81
37210: PUSH
37211: LD_VAR 0 2
37215: ARRAY
37216: IN
37217: IFFALSE 37442
// begin if GetClass ( j ) <> 4 then
37219: LD_VAR 0 3
37223: PPUSH
37224: CALL_OW 257
37228: PUSH
37229: LD_INT 4
37231: NONEQUAL
37232: IFFALSE 37285
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37234: LD_ADDR_EXP 81
37238: PUSH
37239: LD_EXP 81
37243: PPUSH
37244: LD_VAR 0 2
37248: PPUSH
37249: LD_EXP 81
37253: PUSH
37254: LD_VAR 0 2
37258: ARRAY
37259: PUSH
37260: LD_VAR 0 3
37264: DIFF
37265: PPUSH
37266: CALL_OW 1
37270: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37271: LD_VAR 0 3
37275: PPUSH
37276: LD_INT 0
37278: PPUSH
37279: CALL_OW 109
// continue ;
37283: GO 37107
// end ; if IsInUnit ( j ) then
37285: LD_VAR 0 3
37289: PPUSH
37290: CALL_OW 310
37294: IFFALSE 37305
// ComExitBuilding ( j ) ;
37296: LD_VAR 0 3
37300: PPUSH
37301: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37305: LD_ADDR_VAR 0 6
37309: PUSH
37310: LD_VAR 0 7
37314: PPUSH
37315: LD_VAR 0 3
37319: PPUSH
37320: CALL_OW 74
37324: ST_TO_ADDR
// if not ape then
37325: LD_VAR 0 6
37329: NOT
37330: IFFALSE 37334
// break ;
37332: GO 37444
// x := GetX ( ape ) ;
37334: LD_ADDR_VAR 0 4
37338: PUSH
37339: LD_VAR 0 6
37343: PPUSH
37344: CALL_OW 250
37348: ST_TO_ADDR
// y := GetY ( ape ) ;
37349: LD_ADDR_VAR 0 5
37353: PUSH
37354: LD_VAR 0 6
37358: PPUSH
37359: CALL_OW 251
37363: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37364: LD_VAR 0 4
37368: PPUSH
37369: LD_VAR 0 5
37373: PPUSH
37374: CALL_OW 488
37378: NOT
37379: PUSH
37380: LD_VAR 0 11
37384: PPUSH
37385: LD_VAR 0 4
37389: PPUSH
37390: LD_VAR 0 5
37394: PPUSH
37395: LD_INT 20
37397: PPUSH
37398: CALL 54437 0 4
37402: PUSH
37403: LD_INT 4
37405: ARRAY
37406: OR
37407: IFFALSE 37411
// break ;
37409: GO 37444
// if not HasTask ( j ) then
37411: LD_VAR 0 3
37415: PPUSH
37416: CALL_OW 314
37420: NOT
37421: IFFALSE 37442
// ComTameXY ( j , x , y ) ;
37423: LD_VAR 0 3
37427: PPUSH
37428: LD_VAR 0 4
37432: PPUSH
37433: LD_VAR 0 5
37437: PPUSH
37438: CALL_OW 131
// end ; end ;
37442: GO 37107
37444: POP
37445: POP
// end ;
37446: GO 36663
37448: POP
37449: POP
// end ;
37450: LD_VAR 0 1
37454: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37455: LD_INT 0
37457: PPUSH
37458: PPUSH
37459: PPUSH
37460: PPUSH
37461: PPUSH
37462: PPUSH
37463: PPUSH
37464: PPUSH
// if not mc_bases then
37465: LD_EXP 50
37469: NOT
37470: IFFALSE 37474
// exit ;
37472: GO 38100
// for i = 1 to mc_bases do
37474: LD_ADDR_VAR 0 2
37478: PUSH
37479: DOUBLE
37480: LD_INT 1
37482: DEC
37483: ST_TO_ADDR
37484: LD_EXP 50
37488: PUSH
37489: FOR_TO
37490: IFFALSE 38098
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37492: LD_EXP 79
37496: PUSH
37497: LD_VAR 0 2
37501: ARRAY
37502: NOT
37503: PUSH
37504: LD_EXP 79
37508: PUSH
37509: LD_VAR 0 2
37513: ARRAY
37514: PPUSH
37515: LD_INT 25
37517: PUSH
37518: LD_INT 12
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PPUSH
37525: CALL_OW 72
37529: NOT
37530: OR
37531: IFFALSE 37535
// continue ;
37533: GO 37489
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37535: LD_ADDR_VAR 0 5
37539: PUSH
37540: LD_EXP 79
37544: PUSH
37545: LD_VAR 0 2
37549: ARRAY
37550: PUSH
37551: LD_INT 1
37553: ARRAY
37554: PPUSH
37555: CALL_OW 255
37559: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37560: LD_VAR 0 5
37564: PPUSH
37565: LD_INT 2
37567: PPUSH
37568: CALL_OW 325
37572: IFFALSE 37825
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37574: LD_ADDR_VAR 0 4
37578: PUSH
37579: LD_EXP 79
37583: PUSH
37584: LD_VAR 0 2
37588: ARRAY
37589: PPUSH
37590: LD_INT 25
37592: PUSH
37593: LD_INT 16
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PPUSH
37600: CALL_OW 72
37604: ST_TO_ADDR
// if tmp < 6 then
37605: LD_VAR 0 4
37609: PUSH
37610: LD_INT 6
37612: LESS
37613: IFFALSE 37825
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37615: LD_ADDR_VAR 0 6
37619: PUSH
37620: LD_EXP 50
37624: PUSH
37625: LD_VAR 0 2
37629: ARRAY
37630: PPUSH
37631: LD_INT 2
37633: PUSH
37634: LD_INT 30
37636: PUSH
37637: LD_INT 0
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 30
37646: PUSH
37647: LD_INT 1
37649: PUSH
37650: EMPTY
37651: LIST
37652: LIST
37653: PUSH
37654: EMPTY
37655: LIST
37656: LIST
37657: LIST
37658: PPUSH
37659: CALL_OW 72
37663: ST_TO_ADDR
// if depot then
37664: LD_VAR 0 6
37668: IFFALSE 37825
// begin selected := 0 ;
37670: LD_ADDR_VAR 0 7
37674: PUSH
37675: LD_INT 0
37677: ST_TO_ADDR
// for j in depot do
37678: LD_ADDR_VAR 0 3
37682: PUSH
37683: LD_VAR 0 6
37687: PUSH
37688: FOR_IN
37689: IFFALSE 37720
// begin if UnitsInside ( j ) < 6 then
37691: LD_VAR 0 3
37695: PPUSH
37696: CALL_OW 313
37700: PUSH
37701: LD_INT 6
37703: LESS
37704: IFFALSE 37718
// begin selected := j ;
37706: LD_ADDR_VAR 0 7
37710: PUSH
37711: LD_VAR 0 3
37715: ST_TO_ADDR
// break ;
37716: GO 37720
// end ; end ;
37718: GO 37688
37720: POP
37721: POP
// if selected then
37722: LD_VAR 0 7
37726: IFFALSE 37825
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37728: LD_ADDR_VAR 0 3
37732: PUSH
37733: LD_EXP 79
37737: PUSH
37738: LD_VAR 0 2
37742: ARRAY
37743: PPUSH
37744: LD_INT 25
37746: PUSH
37747: LD_INT 12
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PPUSH
37754: CALL_OW 72
37758: PUSH
37759: FOR_IN
37760: IFFALSE 37823
// if not HasTask ( j ) then
37762: LD_VAR 0 3
37766: PPUSH
37767: CALL_OW 314
37771: NOT
37772: IFFALSE 37821
// begin if not IsInUnit ( j ) then
37774: LD_VAR 0 3
37778: PPUSH
37779: CALL_OW 310
37783: NOT
37784: IFFALSE 37800
// ComEnterUnit ( j , selected ) ;
37786: LD_VAR 0 3
37790: PPUSH
37791: LD_VAR 0 7
37795: PPUSH
37796: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37800: LD_VAR 0 3
37804: PPUSH
37805: LD_INT 16
37807: PPUSH
37808: CALL_OW 183
// AddComExitBuilding ( j ) ;
37812: LD_VAR 0 3
37816: PPUSH
37817: CALL_OW 182
// end ;
37821: GO 37759
37823: POP
37824: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37825: LD_VAR 0 5
37829: PPUSH
37830: LD_INT 11
37832: PPUSH
37833: CALL_OW 325
37837: IFFALSE 38096
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37839: LD_ADDR_VAR 0 4
37843: PUSH
37844: LD_EXP 79
37848: PUSH
37849: LD_VAR 0 2
37853: ARRAY
37854: PPUSH
37855: LD_INT 25
37857: PUSH
37858: LD_INT 16
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PPUSH
37865: CALL_OW 72
37869: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37870: LD_VAR 0 4
37874: PUSH
37875: LD_INT 6
37877: GREATEREQUAL
37878: PUSH
37879: LD_VAR 0 5
37883: PPUSH
37884: LD_INT 2
37886: PPUSH
37887: CALL_OW 325
37891: NOT
37892: OR
37893: IFFALSE 38096
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37895: LD_ADDR_VAR 0 8
37899: PUSH
37900: LD_EXP 50
37904: PUSH
37905: LD_VAR 0 2
37909: ARRAY
37910: PPUSH
37911: LD_INT 2
37913: PUSH
37914: LD_INT 30
37916: PUSH
37917: LD_INT 4
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PUSH
37924: LD_INT 30
37926: PUSH
37927: LD_INT 5
37929: PUSH
37930: EMPTY
37931: LIST
37932: LIST
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: LIST
37938: PPUSH
37939: CALL_OW 72
37943: ST_TO_ADDR
// if barracks then
37944: LD_VAR 0 8
37948: IFFALSE 38096
// begin selected := 0 ;
37950: LD_ADDR_VAR 0 7
37954: PUSH
37955: LD_INT 0
37957: ST_TO_ADDR
// for j in barracks do
37958: LD_ADDR_VAR 0 3
37962: PUSH
37963: LD_VAR 0 8
37967: PUSH
37968: FOR_IN
37969: IFFALSE 38000
// begin if UnitsInside ( j ) < 6 then
37971: LD_VAR 0 3
37975: PPUSH
37976: CALL_OW 313
37980: PUSH
37981: LD_INT 6
37983: LESS
37984: IFFALSE 37998
// begin selected := j ;
37986: LD_ADDR_VAR 0 7
37990: PUSH
37991: LD_VAR 0 3
37995: ST_TO_ADDR
// break ;
37996: GO 38000
// end ; end ;
37998: GO 37968
38000: POP
38001: POP
// if selected then
38002: LD_VAR 0 7
38006: IFFALSE 38096
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38008: LD_ADDR_VAR 0 3
38012: PUSH
38013: LD_EXP 79
38017: PUSH
38018: LD_VAR 0 2
38022: ARRAY
38023: PPUSH
38024: LD_INT 25
38026: PUSH
38027: LD_INT 12
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PPUSH
38034: CALL_OW 72
38038: PUSH
38039: FOR_IN
38040: IFFALSE 38094
// if not IsInUnit ( j ) and not HasTask ( j ) then
38042: LD_VAR 0 3
38046: PPUSH
38047: CALL_OW 310
38051: NOT
38052: PUSH
38053: LD_VAR 0 3
38057: PPUSH
38058: CALL_OW 314
38062: NOT
38063: AND
38064: IFFALSE 38092
// begin ComEnterUnit ( j , selected ) ;
38066: LD_VAR 0 3
38070: PPUSH
38071: LD_VAR 0 7
38075: PPUSH
38076: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38080: LD_VAR 0 3
38084: PPUSH
38085: LD_INT 15
38087: PPUSH
38088: CALL_OW 183
// end ;
38092: GO 38039
38094: POP
38095: POP
// end ; end ; end ; end ; end ;
38096: GO 37489
38098: POP
38099: POP
// end ;
38100: LD_VAR 0 1
38104: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38105: LD_INT 0
38107: PPUSH
38108: PPUSH
38109: PPUSH
38110: PPUSH
// if not mc_bases then
38111: LD_EXP 50
38115: NOT
38116: IFFALSE 38120
// exit ;
38118: GO 38298
// for i = 1 to mc_bases do
38120: LD_ADDR_VAR 0 2
38124: PUSH
38125: DOUBLE
38126: LD_INT 1
38128: DEC
38129: ST_TO_ADDR
38130: LD_EXP 50
38134: PUSH
38135: FOR_TO
38136: IFFALSE 38296
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38138: LD_ADDR_VAR 0 4
38142: PUSH
38143: LD_EXP 50
38147: PUSH
38148: LD_VAR 0 2
38152: ARRAY
38153: PPUSH
38154: LD_INT 25
38156: PUSH
38157: LD_INT 9
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PPUSH
38164: CALL_OW 72
38168: ST_TO_ADDR
// if not tmp then
38169: LD_VAR 0 4
38173: NOT
38174: IFFALSE 38178
// continue ;
38176: GO 38135
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38178: LD_EXP 76
38182: PUSH
38183: LD_VAR 0 2
38187: ARRAY
38188: PPUSH
38189: LD_INT 29
38191: PPUSH
38192: CALL_OW 325
38196: NOT
38197: PUSH
38198: LD_EXP 76
38202: PUSH
38203: LD_VAR 0 2
38207: ARRAY
38208: PPUSH
38209: LD_INT 28
38211: PPUSH
38212: CALL_OW 325
38216: NOT
38217: AND
38218: IFFALSE 38222
// continue ;
38220: GO 38135
// for j in tmp do
38222: LD_ADDR_VAR 0 3
38226: PUSH
38227: LD_VAR 0 4
38231: PUSH
38232: FOR_IN
38233: IFFALSE 38292
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38235: LD_VAR 0 3
38239: PUSH
38240: LD_EXP 53
38244: PUSH
38245: LD_VAR 0 2
38249: ARRAY
38250: PUSH
38251: LD_INT 1
38253: ARRAY
38254: IN
38255: NOT
38256: PUSH
38257: LD_VAR 0 3
38261: PUSH
38262: LD_EXP 53
38266: PUSH
38267: LD_VAR 0 2
38271: ARRAY
38272: PUSH
38273: LD_INT 2
38275: ARRAY
38276: IN
38277: NOT
38278: AND
38279: IFFALSE 38290
// ComSpaceTimeShoot ( j ) ;
38281: LD_VAR 0 3
38285: PPUSH
38286: CALL 49502 0 1
38290: GO 38232
38292: POP
38293: POP
// end ;
38294: GO 38135
38296: POP
38297: POP
// end ;
38298: LD_VAR 0 1
38302: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38303: LD_INT 0
38305: PPUSH
38306: PPUSH
38307: PPUSH
38308: PPUSH
38309: PPUSH
38310: PPUSH
38311: PPUSH
38312: PPUSH
38313: PPUSH
// if not mc_bases then
38314: LD_EXP 50
38318: NOT
38319: IFFALSE 38323
// exit ;
38321: GO 38945
// for i = 1 to mc_bases do
38323: LD_ADDR_VAR 0 2
38327: PUSH
38328: DOUBLE
38329: LD_INT 1
38331: DEC
38332: ST_TO_ADDR
38333: LD_EXP 50
38337: PUSH
38338: FOR_TO
38339: IFFALSE 38943
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38341: LD_EXP 85
38345: PUSH
38346: LD_VAR 0 2
38350: ARRAY
38351: NOT
38352: PUSH
38353: LD_INT 38
38355: PPUSH
38356: LD_EXP 76
38360: PUSH
38361: LD_VAR 0 2
38365: ARRAY
38366: PPUSH
38367: CALL_OW 321
38371: PUSH
38372: LD_INT 2
38374: NONEQUAL
38375: OR
38376: IFFALSE 38380
// continue ;
38378: GO 38338
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38380: LD_ADDR_VAR 0 8
38384: PUSH
38385: LD_EXP 50
38389: PUSH
38390: LD_VAR 0 2
38394: ARRAY
38395: PPUSH
38396: LD_INT 30
38398: PUSH
38399: LD_INT 34
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PPUSH
38406: CALL_OW 72
38410: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38411: LD_ADDR_VAR 0 9
38415: PUSH
38416: LD_EXP 50
38420: PUSH
38421: LD_VAR 0 2
38425: ARRAY
38426: PPUSH
38427: LD_INT 25
38429: PUSH
38430: LD_INT 4
38432: PUSH
38433: EMPTY
38434: LIST
38435: LIST
38436: PPUSH
38437: CALL_OW 72
38441: PPUSH
38442: LD_INT 0
38444: PPUSH
38445: CALL 82810 0 2
38449: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38450: LD_VAR 0 9
38454: NOT
38455: PUSH
38456: LD_VAR 0 8
38460: NOT
38461: OR
38462: PUSH
38463: LD_EXP 50
38467: PUSH
38468: LD_VAR 0 2
38472: ARRAY
38473: PPUSH
38474: LD_INT 124
38476: PPUSH
38477: CALL 82810 0 2
38481: OR
38482: IFFALSE 38486
// continue ;
38484: GO 38338
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38486: LD_EXP 86
38490: PUSH
38491: LD_VAR 0 2
38495: ARRAY
38496: PUSH
38497: LD_EXP 85
38501: PUSH
38502: LD_VAR 0 2
38506: ARRAY
38507: LESS
38508: PUSH
38509: LD_EXP 86
38513: PUSH
38514: LD_VAR 0 2
38518: ARRAY
38519: PUSH
38520: LD_VAR 0 8
38524: LESS
38525: AND
38526: IFFALSE 38941
// begin tmp := sci [ 1 ] ;
38528: LD_ADDR_VAR 0 7
38532: PUSH
38533: LD_VAR 0 9
38537: PUSH
38538: LD_INT 1
38540: ARRAY
38541: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38542: LD_VAR 0 7
38546: PPUSH
38547: LD_INT 124
38549: PPUSH
38550: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38554: LD_ADDR_VAR 0 3
38558: PUSH
38559: DOUBLE
38560: LD_EXP 85
38564: PUSH
38565: LD_VAR 0 2
38569: ARRAY
38570: INC
38571: ST_TO_ADDR
38572: LD_EXP 85
38576: PUSH
38577: LD_VAR 0 2
38581: ARRAY
38582: PUSH
38583: FOR_DOWNTO
38584: IFFALSE 38927
// begin if IsInUnit ( tmp ) then
38586: LD_VAR 0 7
38590: PPUSH
38591: CALL_OW 310
38595: IFFALSE 38606
// ComExitBuilding ( tmp ) ;
38597: LD_VAR 0 7
38601: PPUSH
38602: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38606: LD_INT 35
38608: PPUSH
38609: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38613: LD_VAR 0 7
38617: PPUSH
38618: CALL_OW 310
38622: NOT
38623: PUSH
38624: LD_VAR 0 7
38628: PPUSH
38629: CALL_OW 314
38633: NOT
38634: AND
38635: IFFALSE 38606
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38637: LD_ADDR_VAR 0 6
38641: PUSH
38642: LD_VAR 0 7
38646: PPUSH
38647: CALL_OW 250
38651: PUSH
38652: LD_VAR 0 7
38656: PPUSH
38657: CALL_OW 251
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38666: LD_INT 35
38668: PPUSH
38669: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38673: LD_ADDR_VAR 0 4
38677: PUSH
38678: LD_EXP 85
38682: PUSH
38683: LD_VAR 0 2
38687: ARRAY
38688: PUSH
38689: LD_VAR 0 3
38693: ARRAY
38694: PUSH
38695: LD_INT 1
38697: ARRAY
38698: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38699: LD_ADDR_VAR 0 5
38703: PUSH
38704: LD_EXP 85
38708: PUSH
38709: LD_VAR 0 2
38713: ARRAY
38714: PUSH
38715: LD_VAR 0 3
38719: ARRAY
38720: PUSH
38721: LD_INT 2
38723: ARRAY
38724: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38725: LD_VAR 0 7
38729: PPUSH
38730: LD_INT 10
38732: PPUSH
38733: CALL 56140 0 2
38737: PUSH
38738: LD_INT 4
38740: ARRAY
38741: IFFALSE 38779
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38743: LD_VAR 0 7
38747: PPUSH
38748: LD_VAR 0 6
38752: PUSH
38753: LD_INT 1
38755: ARRAY
38756: PPUSH
38757: LD_VAR 0 6
38761: PUSH
38762: LD_INT 2
38764: ARRAY
38765: PPUSH
38766: CALL_OW 111
// wait ( 0 0$10 ) ;
38770: LD_INT 350
38772: PPUSH
38773: CALL_OW 67
// end else
38777: GO 38805
// begin ComMoveXY ( tmp , x , y ) ;
38779: LD_VAR 0 7
38783: PPUSH
38784: LD_VAR 0 4
38788: PPUSH
38789: LD_VAR 0 5
38793: PPUSH
38794: CALL_OW 111
// wait ( 0 0$3 ) ;
38798: LD_INT 105
38800: PPUSH
38801: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38805: LD_VAR 0 7
38809: PPUSH
38810: LD_VAR 0 4
38814: PPUSH
38815: LD_VAR 0 5
38819: PPUSH
38820: CALL_OW 307
38824: IFFALSE 38666
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38826: LD_VAR 0 7
38830: PPUSH
38831: LD_VAR 0 4
38835: PPUSH
38836: LD_VAR 0 5
38840: PPUSH
38841: LD_VAR 0 8
38845: PUSH
38846: LD_VAR 0 3
38850: ARRAY
38851: PPUSH
38852: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38856: LD_INT 35
38858: PPUSH
38859: CALL_OW 67
// until not HasTask ( tmp ) ;
38863: LD_VAR 0 7
38867: PPUSH
38868: CALL_OW 314
38872: NOT
38873: IFFALSE 38856
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38875: LD_ADDR_EXP 86
38879: PUSH
38880: LD_EXP 86
38884: PPUSH
38885: LD_VAR 0 2
38889: PUSH
38890: LD_EXP 86
38894: PUSH
38895: LD_VAR 0 2
38899: ARRAY
38900: PUSH
38901: LD_INT 1
38903: PLUS
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: PPUSH
38909: LD_VAR 0 8
38913: PUSH
38914: LD_VAR 0 3
38918: ARRAY
38919: PPUSH
38920: CALL 53541 0 3
38924: ST_TO_ADDR
// end ;
38925: GO 38583
38927: POP
38928: POP
// MC_Reset ( i , 124 ) ;
38929: LD_VAR 0 2
38933: PPUSH
38934: LD_INT 124
38936: PPUSH
38937: CALL 22083 0 2
// end ; end ;
38941: GO 38338
38943: POP
38944: POP
// end ;
38945: LD_VAR 0 1
38949: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
38950: LD_INT 0
38952: PPUSH
38953: PPUSH
38954: PPUSH
// if not mc_bases then
38955: LD_EXP 50
38959: NOT
38960: IFFALSE 38964
// exit ;
38962: GO 39570
// for i = 1 to mc_bases do
38964: LD_ADDR_VAR 0 2
38968: PUSH
38969: DOUBLE
38970: LD_INT 1
38972: DEC
38973: ST_TO_ADDR
38974: LD_EXP 50
38978: PUSH
38979: FOR_TO
38980: IFFALSE 39568
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
38982: LD_ADDR_VAR 0 3
38986: PUSH
38987: LD_EXP 50
38991: PUSH
38992: LD_VAR 0 2
38996: ARRAY
38997: PPUSH
38998: LD_INT 25
39000: PUSH
39001: LD_INT 4
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PPUSH
39008: CALL_OW 72
39012: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39013: LD_VAR 0 3
39017: NOT
39018: PUSH
39019: LD_EXP 87
39023: PUSH
39024: LD_VAR 0 2
39028: ARRAY
39029: NOT
39030: OR
39031: PUSH
39032: LD_EXP 50
39036: PUSH
39037: LD_VAR 0 2
39041: ARRAY
39042: PPUSH
39043: LD_INT 2
39045: PUSH
39046: LD_INT 30
39048: PUSH
39049: LD_INT 0
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: PUSH
39056: LD_INT 30
39058: PUSH
39059: LD_INT 1
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: LIST
39070: PPUSH
39071: CALL_OW 72
39075: NOT
39076: OR
39077: IFFALSE 39127
// begin if mc_deposits_finder [ i ] then
39079: LD_EXP 88
39083: PUSH
39084: LD_VAR 0 2
39088: ARRAY
39089: IFFALSE 39125
// begin MC_Reset ( i , 125 ) ;
39091: LD_VAR 0 2
39095: PPUSH
39096: LD_INT 125
39098: PPUSH
39099: CALL 22083 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39103: LD_ADDR_EXP 88
39107: PUSH
39108: LD_EXP 88
39112: PPUSH
39113: LD_VAR 0 2
39117: PPUSH
39118: EMPTY
39119: PPUSH
39120: CALL_OW 1
39124: ST_TO_ADDR
// end ; continue ;
39125: GO 38979
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39127: LD_EXP 87
39131: PUSH
39132: LD_VAR 0 2
39136: ARRAY
39137: PUSH
39138: LD_INT 1
39140: ARRAY
39141: PUSH
39142: LD_INT 3
39144: ARRAY
39145: PUSH
39146: LD_INT 1
39148: EQUAL
39149: PUSH
39150: LD_INT 20
39152: PPUSH
39153: LD_EXP 76
39157: PUSH
39158: LD_VAR 0 2
39162: ARRAY
39163: PPUSH
39164: CALL_OW 321
39168: PUSH
39169: LD_INT 2
39171: NONEQUAL
39172: AND
39173: IFFALSE 39223
// begin if mc_deposits_finder [ i ] then
39175: LD_EXP 88
39179: PUSH
39180: LD_VAR 0 2
39184: ARRAY
39185: IFFALSE 39221
// begin MC_Reset ( i , 125 ) ;
39187: LD_VAR 0 2
39191: PPUSH
39192: LD_INT 125
39194: PPUSH
39195: CALL 22083 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39199: LD_ADDR_EXP 88
39203: PUSH
39204: LD_EXP 88
39208: PPUSH
39209: LD_VAR 0 2
39213: PPUSH
39214: EMPTY
39215: PPUSH
39216: CALL_OW 1
39220: ST_TO_ADDR
// end ; continue ;
39221: GO 38979
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39223: LD_EXP 87
39227: PUSH
39228: LD_VAR 0 2
39232: ARRAY
39233: PUSH
39234: LD_INT 1
39236: ARRAY
39237: PUSH
39238: LD_INT 1
39240: ARRAY
39241: PPUSH
39242: LD_EXP 87
39246: PUSH
39247: LD_VAR 0 2
39251: ARRAY
39252: PUSH
39253: LD_INT 1
39255: ARRAY
39256: PUSH
39257: LD_INT 2
39259: ARRAY
39260: PPUSH
39261: LD_EXP 76
39265: PUSH
39266: LD_VAR 0 2
39270: ARRAY
39271: PPUSH
39272: CALL_OW 440
39276: IFFALSE 39319
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39278: LD_ADDR_EXP 87
39282: PUSH
39283: LD_EXP 87
39287: PPUSH
39288: LD_VAR 0 2
39292: PPUSH
39293: LD_EXP 87
39297: PUSH
39298: LD_VAR 0 2
39302: ARRAY
39303: PPUSH
39304: LD_INT 1
39306: PPUSH
39307: CALL_OW 3
39311: PPUSH
39312: CALL_OW 1
39316: ST_TO_ADDR
39317: GO 39566
// begin if not mc_deposits_finder [ i ] then
39319: LD_EXP 88
39323: PUSH
39324: LD_VAR 0 2
39328: ARRAY
39329: NOT
39330: IFFALSE 39382
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39332: LD_ADDR_EXP 88
39336: PUSH
39337: LD_EXP 88
39341: PPUSH
39342: LD_VAR 0 2
39346: PPUSH
39347: LD_VAR 0 3
39351: PUSH
39352: LD_INT 1
39354: ARRAY
39355: PUSH
39356: EMPTY
39357: LIST
39358: PPUSH
39359: CALL_OW 1
39363: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39364: LD_VAR 0 3
39368: PUSH
39369: LD_INT 1
39371: ARRAY
39372: PPUSH
39373: LD_INT 125
39375: PPUSH
39376: CALL_OW 109
// end else
39380: GO 39566
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39382: LD_EXP 88
39386: PUSH
39387: LD_VAR 0 2
39391: ARRAY
39392: PUSH
39393: LD_INT 1
39395: ARRAY
39396: PPUSH
39397: CALL_OW 310
39401: IFFALSE 39424
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39403: LD_EXP 88
39407: PUSH
39408: LD_VAR 0 2
39412: ARRAY
39413: PUSH
39414: LD_INT 1
39416: ARRAY
39417: PPUSH
39418: CALL_OW 122
39422: GO 39566
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39424: LD_EXP 88
39428: PUSH
39429: LD_VAR 0 2
39433: ARRAY
39434: PUSH
39435: LD_INT 1
39437: ARRAY
39438: PPUSH
39439: CALL_OW 314
39443: NOT
39444: PUSH
39445: LD_EXP 88
39449: PUSH
39450: LD_VAR 0 2
39454: ARRAY
39455: PUSH
39456: LD_INT 1
39458: ARRAY
39459: PPUSH
39460: LD_EXP 87
39464: PUSH
39465: LD_VAR 0 2
39469: ARRAY
39470: PUSH
39471: LD_INT 1
39473: ARRAY
39474: PUSH
39475: LD_INT 1
39477: ARRAY
39478: PPUSH
39479: LD_EXP 87
39483: PUSH
39484: LD_VAR 0 2
39488: ARRAY
39489: PUSH
39490: LD_INT 1
39492: ARRAY
39493: PUSH
39494: LD_INT 2
39496: ARRAY
39497: PPUSH
39498: CALL_OW 297
39502: PUSH
39503: LD_INT 6
39505: GREATER
39506: AND
39507: IFFALSE 39566
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39509: LD_EXP 88
39513: PUSH
39514: LD_VAR 0 2
39518: ARRAY
39519: PUSH
39520: LD_INT 1
39522: ARRAY
39523: PPUSH
39524: LD_EXP 87
39528: PUSH
39529: LD_VAR 0 2
39533: ARRAY
39534: PUSH
39535: LD_INT 1
39537: ARRAY
39538: PUSH
39539: LD_INT 1
39541: ARRAY
39542: PPUSH
39543: LD_EXP 87
39547: PUSH
39548: LD_VAR 0 2
39552: ARRAY
39553: PUSH
39554: LD_INT 1
39556: ARRAY
39557: PUSH
39558: LD_INT 2
39560: ARRAY
39561: PPUSH
39562: CALL_OW 111
// end ; end ; end ;
39566: GO 38979
39568: POP
39569: POP
// end ;
39570: LD_VAR 0 1
39574: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39575: LD_INT 0
39577: PPUSH
39578: PPUSH
39579: PPUSH
39580: PPUSH
39581: PPUSH
39582: PPUSH
39583: PPUSH
39584: PPUSH
39585: PPUSH
39586: PPUSH
39587: PPUSH
// if not mc_bases then
39588: LD_EXP 50
39592: NOT
39593: IFFALSE 39597
// exit ;
39595: GO 40537
// for i = 1 to mc_bases do
39597: LD_ADDR_VAR 0 2
39601: PUSH
39602: DOUBLE
39603: LD_INT 1
39605: DEC
39606: ST_TO_ADDR
39607: LD_EXP 50
39611: PUSH
39612: FOR_TO
39613: IFFALSE 40535
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39615: LD_EXP 50
39619: PUSH
39620: LD_VAR 0 2
39624: ARRAY
39625: NOT
39626: PUSH
39627: LD_EXP 73
39631: PUSH
39632: LD_VAR 0 2
39636: ARRAY
39637: OR
39638: IFFALSE 39642
// continue ;
39640: GO 39612
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39642: LD_ADDR_VAR 0 7
39646: PUSH
39647: LD_EXP 50
39651: PUSH
39652: LD_VAR 0 2
39656: ARRAY
39657: PUSH
39658: LD_INT 1
39660: ARRAY
39661: PPUSH
39662: CALL_OW 248
39666: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39667: LD_VAR 0 7
39671: PUSH
39672: LD_INT 3
39674: EQUAL
39675: PUSH
39676: LD_EXP 69
39680: PUSH
39681: LD_VAR 0 2
39685: ARRAY
39686: PUSH
39687: LD_EXP 72
39691: PUSH
39692: LD_VAR 0 2
39696: ARRAY
39697: UNION
39698: PPUSH
39699: LD_INT 33
39701: PUSH
39702: LD_INT 2
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PPUSH
39709: CALL_OW 72
39713: NOT
39714: OR
39715: IFFALSE 39719
// continue ;
39717: GO 39612
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39719: LD_ADDR_VAR 0 9
39723: PUSH
39724: LD_EXP 50
39728: PUSH
39729: LD_VAR 0 2
39733: ARRAY
39734: PPUSH
39735: LD_INT 30
39737: PUSH
39738: LD_INT 36
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PPUSH
39745: CALL_OW 72
39749: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39750: LD_ADDR_VAR 0 10
39754: PUSH
39755: LD_EXP 69
39759: PUSH
39760: LD_VAR 0 2
39764: ARRAY
39765: PPUSH
39766: LD_INT 34
39768: PUSH
39769: LD_INT 31
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PPUSH
39776: CALL_OW 72
39780: ST_TO_ADDR
// if not cts and not mcts then
39781: LD_VAR 0 9
39785: NOT
39786: PUSH
39787: LD_VAR 0 10
39791: NOT
39792: AND
39793: IFFALSE 39797
// continue ;
39795: GO 39612
// x := cts ;
39797: LD_ADDR_VAR 0 11
39801: PUSH
39802: LD_VAR 0 9
39806: ST_TO_ADDR
// if not x then
39807: LD_VAR 0 11
39811: NOT
39812: IFFALSE 39824
// x := mcts ;
39814: LD_ADDR_VAR 0 11
39818: PUSH
39819: LD_VAR 0 10
39823: ST_TO_ADDR
// if not x then
39824: LD_VAR 0 11
39828: NOT
39829: IFFALSE 39833
// continue ;
39831: GO 39612
// if mc_remote_driver [ i ] then
39833: LD_EXP 90
39837: PUSH
39838: LD_VAR 0 2
39842: ARRAY
39843: IFFALSE 40230
// for j in mc_remote_driver [ i ] do
39845: LD_ADDR_VAR 0 3
39849: PUSH
39850: LD_EXP 90
39854: PUSH
39855: LD_VAR 0 2
39859: ARRAY
39860: PUSH
39861: FOR_IN
39862: IFFALSE 40228
// begin if GetClass ( j ) <> 3 then
39864: LD_VAR 0 3
39868: PPUSH
39869: CALL_OW 257
39873: PUSH
39874: LD_INT 3
39876: NONEQUAL
39877: IFFALSE 39930
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39879: LD_ADDR_EXP 90
39883: PUSH
39884: LD_EXP 90
39888: PPUSH
39889: LD_VAR 0 2
39893: PPUSH
39894: LD_EXP 90
39898: PUSH
39899: LD_VAR 0 2
39903: ARRAY
39904: PUSH
39905: LD_VAR 0 3
39909: DIFF
39910: PPUSH
39911: CALL_OW 1
39915: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39916: LD_VAR 0 3
39920: PPUSH
39921: LD_INT 0
39923: PPUSH
39924: CALL_OW 109
// continue ;
39928: GO 39861
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
39930: LD_EXP 69
39934: PUSH
39935: LD_VAR 0 2
39939: ARRAY
39940: PPUSH
39941: LD_INT 34
39943: PUSH
39944: LD_INT 31
39946: PUSH
39947: EMPTY
39948: LIST
39949: LIST
39950: PUSH
39951: LD_INT 58
39953: PUSH
39954: EMPTY
39955: LIST
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PPUSH
39961: CALL_OW 72
39965: PUSH
39966: LD_VAR 0 3
39970: PPUSH
39971: CALL 82898 0 1
39975: NOT
39976: AND
39977: IFFALSE 40048
// begin if IsInUnit ( j ) then
39979: LD_VAR 0 3
39983: PPUSH
39984: CALL_OW 310
39988: IFFALSE 39999
// ComExitBuilding ( j ) ;
39990: LD_VAR 0 3
39994: PPUSH
39995: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
39999: LD_VAR 0 3
40003: PPUSH
40004: LD_EXP 69
40008: PUSH
40009: LD_VAR 0 2
40013: ARRAY
40014: PPUSH
40015: LD_INT 34
40017: PUSH
40018: LD_INT 31
40020: PUSH
40021: EMPTY
40022: LIST
40023: LIST
40024: PUSH
40025: LD_INT 58
40027: PUSH
40028: EMPTY
40029: LIST
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PPUSH
40035: CALL_OW 72
40039: PUSH
40040: LD_INT 1
40042: ARRAY
40043: PPUSH
40044: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40048: LD_VAR 0 3
40052: PPUSH
40053: CALL_OW 310
40057: NOT
40058: PUSH
40059: LD_VAR 0 3
40063: PPUSH
40064: CALL_OW 310
40068: PPUSH
40069: CALL_OW 266
40073: PUSH
40074: LD_INT 36
40076: NONEQUAL
40077: PUSH
40078: LD_VAR 0 3
40082: PPUSH
40083: CALL 82898 0 1
40087: NOT
40088: AND
40089: OR
40090: IFFALSE 40226
// begin if IsInUnit ( j ) then
40092: LD_VAR 0 3
40096: PPUSH
40097: CALL_OW 310
40101: IFFALSE 40112
// ComExitBuilding ( j ) ;
40103: LD_VAR 0 3
40107: PPUSH
40108: CALL_OW 122
// ct := 0 ;
40112: LD_ADDR_VAR 0 8
40116: PUSH
40117: LD_INT 0
40119: ST_TO_ADDR
// for k in x do
40120: LD_ADDR_VAR 0 4
40124: PUSH
40125: LD_VAR 0 11
40129: PUSH
40130: FOR_IN
40131: IFFALSE 40204
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40133: LD_VAR 0 4
40137: PPUSH
40138: CALL_OW 264
40142: PUSH
40143: LD_INT 31
40145: EQUAL
40146: PUSH
40147: LD_VAR 0 4
40151: PPUSH
40152: CALL_OW 311
40156: NOT
40157: AND
40158: PUSH
40159: LD_VAR 0 4
40163: PPUSH
40164: CALL_OW 266
40168: PUSH
40169: LD_INT 36
40171: EQUAL
40172: PUSH
40173: LD_VAR 0 4
40177: PPUSH
40178: CALL_OW 313
40182: PUSH
40183: LD_INT 3
40185: LESS
40186: AND
40187: OR
40188: IFFALSE 40202
// begin ct := k ;
40190: LD_ADDR_VAR 0 8
40194: PUSH
40195: LD_VAR 0 4
40199: ST_TO_ADDR
// break ;
40200: GO 40204
// end ;
40202: GO 40130
40204: POP
40205: POP
// if ct then
40206: LD_VAR 0 8
40210: IFFALSE 40226
// ComEnterUnit ( j , ct ) ;
40212: LD_VAR 0 3
40216: PPUSH
40217: LD_VAR 0 8
40221: PPUSH
40222: CALL_OW 120
// end ; end ;
40226: GO 39861
40228: POP
40229: POP
// places := 0 ;
40230: LD_ADDR_VAR 0 5
40234: PUSH
40235: LD_INT 0
40237: ST_TO_ADDR
// for j = 1 to x do
40238: LD_ADDR_VAR 0 3
40242: PUSH
40243: DOUBLE
40244: LD_INT 1
40246: DEC
40247: ST_TO_ADDR
40248: LD_VAR 0 11
40252: PUSH
40253: FOR_TO
40254: IFFALSE 40330
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40256: LD_VAR 0 11
40260: PUSH
40261: LD_VAR 0 3
40265: ARRAY
40266: PPUSH
40267: CALL_OW 264
40271: PUSH
40272: LD_INT 31
40274: EQUAL
40275: IFFALSE 40293
// places := places + 1 else
40277: LD_ADDR_VAR 0 5
40281: PUSH
40282: LD_VAR 0 5
40286: PUSH
40287: LD_INT 1
40289: PLUS
40290: ST_TO_ADDR
40291: GO 40328
// if GetBType ( x [ j ] ) = b_control_tower then
40293: LD_VAR 0 11
40297: PUSH
40298: LD_VAR 0 3
40302: ARRAY
40303: PPUSH
40304: CALL_OW 266
40308: PUSH
40309: LD_INT 36
40311: EQUAL
40312: IFFALSE 40328
// places := places + 3 ;
40314: LD_ADDR_VAR 0 5
40318: PUSH
40319: LD_VAR 0 5
40323: PUSH
40324: LD_INT 3
40326: PLUS
40327: ST_TO_ADDR
40328: GO 40253
40330: POP
40331: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40332: LD_VAR 0 5
40336: PUSH
40337: LD_INT 0
40339: EQUAL
40340: PUSH
40341: LD_VAR 0 5
40345: PUSH
40346: LD_EXP 90
40350: PUSH
40351: LD_VAR 0 2
40355: ARRAY
40356: LESSEQUAL
40357: OR
40358: IFFALSE 40362
// continue ;
40360: GO 39612
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40362: LD_ADDR_VAR 0 6
40366: PUSH
40367: LD_EXP 50
40371: PUSH
40372: LD_VAR 0 2
40376: ARRAY
40377: PPUSH
40378: LD_INT 25
40380: PUSH
40381: LD_INT 3
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: PPUSH
40388: CALL_OW 72
40392: PUSH
40393: LD_EXP 90
40397: PUSH
40398: LD_VAR 0 2
40402: ARRAY
40403: DIFF
40404: PPUSH
40405: LD_INT 3
40407: PPUSH
40408: CALL 83798 0 2
40412: ST_TO_ADDR
// for j in tmp do
40413: LD_ADDR_VAR 0 3
40417: PUSH
40418: LD_VAR 0 6
40422: PUSH
40423: FOR_IN
40424: IFFALSE 40459
// if GetTag ( j ) > 0 then
40426: LD_VAR 0 3
40430: PPUSH
40431: CALL_OW 110
40435: PUSH
40436: LD_INT 0
40438: GREATER
40439: IFFALSE 40457
// tmp := tmp diff j ;
40441: LD_ADDR_VAR 0 6
40445: PUSH
40446: LD_VAR 0 6
40450: PUSH
40451: LD_VAR 0 3
40455: DIFF
40456: ST_TO_ADDR
40457: GO 40423
40459: POP
40460: POP
// if not tmp then
40461: LD_VAR 0 6
40465: NOT
40466: IFFALSE 40470
// continue ;
40468: GO 39612
// if places then
40470: LD_VAR 0 5
40474: IFFALSE 40533
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40476: LD_ADDR_EXP 90
40480: PUSH
40481: LD_EXP 90
40485: PPUSH
40486: LD_VAR 0 2
40490: PPUSH
40491: LD_EXP 90
40495: PUSH
40496: LD_VAR 0 2
40500: ARRAY
40501: PUSH
40502: LD_VAR 0 6
40506: PUSH
40507: LD_INT 1
40509: ARRAY
40510: UNION
40511: PPUSH
40512: CALL_OW 1
40516: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40517: LD_VAR 0 6
40521: PUSH
40522: LD_INT 1
40524: ARRAY
40525: PPUSH
40526: LD_INT 126
40528: PPUSH
40529: CALL_OW 109
// end ; end ;
40533: GO 39612
40535: POP
40536: POP
// end ;
40537: LD_VAR 0 1
40541: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40542: LD_INT 0
40544: PPUSH
40545: PPUSH
40546: PPUSH
40547: PPUSH
40548: PPUSH
40549: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40550: LD_VAR 0 1
40554: NOT
40555: PUSH
40556: LD_VAR 0 2
40560: NOT
40561: OR
40562: PUSH
40563: LD_VAR 0 3
40567: NOT
40568: OR
40569: PUSH
40570: LD_VAR 0 4
40574: PUSH
40575: LD_INT 1
40577: PUSH
40578: LD_INT 2
40580: PUSH
40581: LD_INT 3
40583: PUSH
40584: LD_INT 4
40586: PUSH
40587: LD_INT 5
40589: PUSH
40590: LD_INT 8
40592: PUSH
40593: LD_INT 9
40595: PUSH
40596: LD_INT 15
40598: PUSH
40599: LD_INT 16
40601: PUSH
40602: EMPTY
40603: LIST
40604: LIST
40605: LIST
40606: LIST
40607: LIST
40608: LIST
40609: LIST
40610: LIST
40611: LIST
40612: IN
40613: NOT
40614: OR
40615: IFFALSE 40619
// exit ;
40617: GO 41519
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40619: LD_ADDR_VAR 0 2
40623: PUSH
40624: LD_VAR 0 2
40628: PPUSH
40629: LD_INT 21
40631: PUSH
40632: LD_INT 3
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: PUSH
40639: LD_INT 24
40641: PUSH
40642: LD_INT 250
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: EMPTY
40650: LIST
40651: LIST
40652: PPUSH
40653: CALL_OW 72
40657: ST_TO_ADDR
// case class of 1 , 15 :
40658: LD_VAR 0 4
40662: PUSH
40663: LD_INT 1
40665: DOUBLE
40666: EQUAL
40667: IFTRUE 40677
40669: LD_INT 15
40671: DOUBLE
40672: EQUAL
40673: IFTRUE 40677
40675: GO 40762
40677: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40678: LD_ADDR_VAR 0 8
40682: PUSH
40683: LD_VAR 0 2
40687: PPUSH
40688: LD_INT 2
40690: PUSH
40691: LD_INT 30
40693: PUSH
40694: LD_INT 32
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: PUSH
40701: LD_INT 30
40703: PUSH
40704: LD_INT 31
40706: PUSH
40707: EMPTY
40708: LIST
40709: LIST
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: LIST
40715: PPUSH
40716: CALL_OW 72
40720: PUSH
40721: LD_VAR 0 2
40725: PPUSH
40726: LD_INT 2
40728: PUSH
40729: LD_INT 30
40731: PUSH
40732: LD_INT 4
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 30
40741: PUSH
40742: LD_INT 5
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: LIST
40753: PPUSH
40754: CALL_OW 72
40758: ADD
40759: ST_TO_ADDR
40760: GO 41008
40762: LD_INT 2
40764: DOUBLE
40765: EQUAL
40766: IFTRUE 40776
40768: LD_INT 16
40770: DOUBLE
40771: EQUAL
40772: IFTRUE 40776
40774: GO 40822
40776: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40777: LD_ADDR_VAR 0 8
40781: PUSH
40782: LD_VAR 0 2
40786: PPUSH
40787: LD_INT 2
40789: PUSH
40790: LD_INT 30
40792: PUSH
40793: LD_INT 0
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 30
40802: PUSH
40803: LD_INT 1
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: LIST
40814: PPUSH
40815: CALL_OW 72
40819: ST_TO_ADDR
40820: GO 41008
40822: LD_INT 3
40824: DOUBLE
40825: EQUAL
40826: IFTRUE 40830
40828: GO 40876
40830: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40831: LD_ADDR_VAR 0 8
40835: PUSH
40836: LD_VAR 0 2
40840: PPUSH
40841: LD_INT 2
40843: PUSH
40844: LD_INT 30
40846: PUSH
40847: LD_INT 2
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: LD_INT 30
40856: PUSH
40857: LD_INT 3
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: LIST
40868: PPUSH
40869: CALL_OW 72
40873: ST_TO_ADDR
40874: GO 41008
40876: LD_INT 4
40878: DOUBLE
40879: EQUAL
40880: IFTRUE 40884
40882: GO 40941
40884: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40885: LD_ADDR_VAR 0 8
40889: PUSH
40890: LD_VAR 0 2
40894: PPUSH
40895: LD_INT 2
40897: PUSH
40898: LD_INT 30
40900: PUSH
40901: LD_INT 6
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PUSH
40908: LD_INT 30
40910: PUSH
40911: LD_INT 7
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 30
40920: PUSH
40921: LD_INT 8
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: LIST
40932: LIST
40933: PPUSH
40934: CALL_OW 72
40938: ST_TO_ADDR
40939: GO 41008
40941: LD_INT 5
40943: DOUBLE
40944: EQUAL
40945: IFTRUE 40961
40947: LD_INT 8
40949: DOUBLE
40950: EQUAL
40951: IFTRUE 40961
40953: LD_INT 9
40955: DOUBLE
40956: EQUAL
40957: IFTRUE 40961
40959: GO 41007
40961: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
40962: LD_ADDR_VAR 0 8
40966: PUSH
40967: LD_VAR 0 2
40971: PPUSH
40972: LD_INT 2
40974: PUSH
40975: LD_INT 30
40977: PUSH
40978: LD_INT 4
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 30
40987: PUSH
40988: LD_INT 5
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: LIST
40999: PPUSH
41000: CALL_OW 72
41004: ST_TO_ADDR
41005: GO 41008
41007: POP
// if not tmp then
41008: LD_VAR 0 8
41012: NOT
41013: IFFALSE 41017
// exit ;
41015: GO 41519
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41017: LD_VAR 0 4
41021: PUSH
41022: LD_INT 1
41024: PUSH
41025: LD_INT 15
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: IN
41032: PUSH
41033: LD_EXP 59
41037: PUSH
41038: LD_VAR 0 1
41042: ARRAY
41043: AND
41044: IFFALSE 41200
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41046: LD_ADDR_VAR 0 9
41050: PUSH
41051: LD_EXP 59
41055: PUSH
41056: LD_VAR 0 1
41060: ARRAY
41061: PUSH
41062: LD_INT 1
41064: ARRAY
41065: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41066: LD_VAR 0 9
41070: PUSH
41071: LD_EXP 60
41075: PUSH
41076: LD_VAR 0 1
41080: ARRAY
41081: IN
41082: NOT
41083: IFFALSE 41198
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41085: LD_ADDR_EXP 60
41089: PUSH
41090: LD_EXP 60
41094: PPUSH
41095: LD_VAR 0 1
41099: PUSH
41100: LD_EXP 60
41104: PUSH
41105: LD_VAR 0 1
41109: ARRAY
41110: PUSH
41111: LD_INT 1
41113: PLUS
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PPUSH
41119: LD_VAR 0 9
41123: PPUSH
41124: CALL 53541 0 3
41128: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41129: LD_ADDR_EXP 59
41133: PUSH
41134: LD_EXP 59
41138: PPUSH
41139: LD_VAR 0 1
41143: PPUSH
41144: LD_EXP 59
41148: PUSH
41149: LD_VAR 0 1
41153: ARRAY
41154: PUSH
41155: LD_VAR 0 9
41159: DIFF
41160: PPUSH
41161: CALL_OW 1
41165: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41166: LD_VAR 0 3
41170: PPUSH
41171: LD_EXP 60
41175: PUSH
41176: LD_VAR 0 1
41180: ARRAY
41181: PUSH
41182: LD_EXP 60
41186: PUSH
41187: LD_VAR 0 1
41191: ARRAY
41192: ARRAY
41193: PPUSH
41194: CALL_OW 120
// end ; exit ;
41198: GO 41519
// end ; if tmp > 1 then
41200: LD_VAR 0 8
41204: PUSH
41205: LD_INT 1
41207: GREATER
41208: IFFALSE 41312
// for i = 2 to tmp do
41210: LD_ADDR_VAR 0 6
41214: PUSH
41215: DOUBLE
41216: LD_INT 2
41218: DEC
41219: ST_TO_ADDR
41220: LD_VAR 0 8
41224: PUSH
41225: FOR_TO
41226: IFFALSE 41310
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41228: LD_VAR 0 8
41232: PUSH
41233: LD_VAR 0 6
41237: ARRAY
41238: PPUSH
41239: CALL_OW 461
41243: PUSH
41244: LD_INT 6
41246: EQUAL
41247: IFFALSE 41308
// begin x := tmp [ i ] ;
41249: LD_ADDR_VAR 0 9
41253: PUSH
41254: LD_VAR 0 8
41258: PUSH
41259: LD_VAR 0 6
41263: ARRAY
41264: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41265: LD_ADDR_VAR 0 8
41269: PUSH
41270: LD_VAR 0 8
41274: PPUSH
41275: LD_VAR 0 6
41279: PPUSH
41280: CALL_OW 3
41284: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41285: LD_ADDR_VAR 0 8
41289: PUSH
41290: LD_VAR 0 8
41294: PPUSH
41295: LD_INT 1
41297: PPUSH
41298: LD_VAR 0 9
41302: PPUSH
41303: CALL_OW 2
41307: ST_TO_ADDR
// end ;
41308: GO 41225
41310: POP
41311: POP
// for i in tmp do
41312: LD_ADDR_VAR 0 6
41316: PUSH
41317: LD_VAR 0 8
41321: PUSH
41322: FOR_IN
41323: IFFALSE 41392
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41325: LD_VAR 0 6
41329: PPUSH
41330: CALL_OW 313
41334: PUSH
41335: LD_INT 6
41337: LESS
41338: PUSH
41339: LD_VAR 0 6
41343: PPUSH
41344: CALL_OW 266
41348: PUSH
41349: LD_INT 31
41351: PUSH
41352: LD_INT 32
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: IN
41359: NOT
41360: AND
41361: PUSH
41362: LD_VAR 0 6
41366: PPUSH
41367: CALL_OW 313
41371: PUSH
41372: LD_INT 0
41374: EQUAL
41375: OR
41376: IFFALSE 41390
// begin j := i ;
41378: LD_ADDR_VAR 0 7
41382: PUSH
41383: LD_VAR 0 6
41387: ST_TO_ADDR
// break ;
41388: GO 41392
// end ; end ;
41390: GO 41322
41392: POP
41393: POP
// if j then
41394: LD_VAR 0 7
41398: IFFALSE 41416
// ComEnterUnit ( unit , j ) else
41400: LD_VAR 0 3
41404: PPUSH
41405: LD_VAR 0 7
41409: PPUSH
41410: CALL_OW 120
41414: GO 41519
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41416: LD_ADDR_VAR 0 10
41420: PUSH
41421: LD_VAR 0 2
41425: PPUSH
41426: LD_INT 2
41428: PUSH
41429: LD_INT 30
41431: PUSH
41432: LD_INT 0
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 30
41441: PUSH
41442: LD_INT 1
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: LIST
41453: PPUSH
41454: CALL_OW 72
41458: ST_TO_ADDR
// if depot then
41459: LD_VAR 0 10
41463: IFFALSE 41519
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41465: LD_ADDR_VAR 0 10
41469: PUSH
41470: LD_VAR 0 10
41474: PPUSH
41475: LD_VAR 0 3
41479: PPUSH
41480: CALL_OW 74
41484: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41485: LD_VAR 0 3
41489: PPUSH
41490: LD_VAR 0 10
41494: PPUSH
41495: CALL_OW 296
41499: PUSH
41500: LD_INT 10
41502: GREATER
41503: IFFALSE 41519
// ComStandNearbyBuilding ( unit , depot ) ;
41505: LD_VAR 0 3
41509: PPUSH
41510: LD_VAR 0 10
41514: PPUSH
41515: CALL 50119 0 2
// end ; end ; end ;
41519: LD_VAR 0 5
41523: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41524: LD_INT 0
41526: PPUSH
41527: PPUSH
41528: PPUSH
41529: PPUSH
// if not mc_bases then
41530: LD_EXP 50
41534: NOT
41535: IFFALSE 41539
// exit ;
41537: GO 41778
// for i = 1 to mc_bases do
41539: LD_ADDR_VAR 0 2
41543: PUSH
41544: DOUBLE
41545: LD_INT 1
41547: DEC
41548: ST_TO_ADDR
41549: LD_EXP 50
41553: PUSH
41554: FOR_TO
41555: IFFALSE 41776
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41557: LD_ADDR_VAR 0 4
41561: PUSH
41562: LD_EXP 50
41566: PUSH
41567: LD_VAR 0 2
41571: ARRAY
41572: PPUSH
41573: LD_INT 21
41575: PUSH
41576: LD_INT 1
41578: PUSH
41579: EMPTY
41580: LIST
41581: LIST
41582: PPUSH
41583: CALL_OW 72
41587: PUSH
41588: LD_EXP 79
41592: PUSH
41593: LD_VAR 0 2
41597: ARRAY
41598: UNION
41599: ST_TO_ADDR
// if not tmp then
41600: LD_VAR 0 4
41604: NOT
41605: IFFALSE 41609
// continue ;
41607: GO 41554
// for j in tmp do
41609: LD_ADDR_VAR 0 3
41613: PUSH
41614: LD_VAR 0 4
41618: PUSH
41619: FOR_IN
41620: IFFALSE 41772
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41622: LD_VAR 0 3
41626: PPUSH
41627: CALL_OW 110
41631: NOT
41632: PUSH
41633: LD_VAR 0 3
41637: PPUSH
41638: CALL_OW 314
41642: NOT
41643: AND
41644: PUSH
41645: LD_VAR 0 3
41649: PPUSH
41650: CALL_OW 311
41654: NOT
41655: AND
41656: PUSH
41657: LD_VAR 0 3
41661: PPUSH
41662: CALL_OW 310
41666: NOT
41667: AND
41668: PUSH
41669: LD_VAR 0 3
41673: PUSH
41674: LD_EXP 53
41678: PUSH
41679: LD_VAR 0 2
41683: ARRAY
41684: PUSH
41685: LD_INT 1
41687: ARRAY
41688: IN
41689: NOT
41690: AND
41691: PUSH
41692: LD_VAR 0 3
41696: PUSH
41697: LD_EXP 53
41701: PUSH
41702: LD_VAR 0 2
41706: ARRAY
41707: PUSH
41708: LD_INT 2
41710: ARRAY
41711: IN
41712: NOT
41713: AND
41714: PUSH
41715: LD_VAR 0 3
41719: PUSH
41720: LD_EXP 62
41724: PUSH
41725: LD_VAR 0 2
41729: ARRAY
41730: IN
41731: NOT
41732: AND
41733: IFFALSE 41770
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41735: LD_VAR 0 2
41739: PPUSH
41740: LD_EXP 50
41744: PUSH
41745: LD_VAR 0 2
41749: ARRAY
41750: PPUSH
41751: LD_VAR 0 3
41755: PPUSH
41756: LD_VAR 0 3
41760: PPUSH
41761: CALL_OW 257
41765: PPUSH
41766: CALL 40542 0 4
// end ;
41770: GO 41619
41772: POP
41773: POP
// end ;
41774: GO 41554
41776: POP
41777: POP
// end ;
41778: LD_VAR 0 1
41782: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41783: LD_INT 0
41785: PPUSH
41786: PPUSH
41787: PPUSH
41788: PPUSH
41789: PPUSH
41790: PPUSH
// if not mc_bases [ base ] then
41791: LD_EXP 50
41795: PUSH
41796: LD_VAR 0 1
41800: ARRAY
41801: NOT
41802: IFFALSE 41806
// exit ;
41804: GO 41988
// tmp := [ ] ;
41806: LD_ADDR_VAR 0 6
41810: PUSH
41811: EMPTY
41812: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41813: LD_ADDR_VAR 0 7
41817: PUSH
41818: LD_VAR 0 3
41822: PPUSH
41823: LD_INT 0
41825: PPUSH
41826: CALL_OW 517
41830: ST_TO_ADDR
// if not list then
41831: LD_VAR 0 7
41835: NOT
41836: IFFALSE 41840
// exit ;
41838: GO 41988
// for i = 1 to amount do
41840: LD_ADDR_VAR 0 5
41844: PUSH
41845: DOUBLE
41846: LD_INT 1
41848: DEC
41849: ST_TO_ADDR
41850: LD_VAR 0 2
41854: PUSH
41855: FOR_TO
41856: IFFALSE 41936
// begin x := rand ( 1 , list [ 1 ] ) ;
41858: LD_ADDR_VAR 0 8
41862: PUSH
41863: LD_INT 1
41865: PPUSH
41866: LD_VAR 0 7
41870: PUSH
41871: LD_INT 1
41873: ARRAY
41874: PPUSH
41875: CALL_OW 12
41879: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41880: LD_ADDR_VAR 0 6
41884: PUSH
41885: LD_VAR 0 6
41889: PPUSH
41890: LD_VAR 0 5
41894: PPUSH
41895: LD_VAR 0 7
41899: PUSH
41900: LD_INT 1
41902: ARRAY
41903: PUSH
41904: LD_VAR 0 8
41908: ARRAY
41909: PUSH
41910: LD_VAR 0 7
41914: PUSH
41915: LD_INT 2
41917: ARRAY
41918: PUSH
41919: LD_VAR 0 8
41923: ARRAY
41924: PUSH
41925: EMPTY
41926: LIST
41927: LIST
41928: PPUSH
41929: CALL_OW 1
41933: ST_TO_ADDR
// end ;
41934: GO 41855
41936: POP
41937: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
41938: LD_ADDR_EXP 63
41942: PUSH
41943: LD_EXP 63
41947: PPUSH
41948: LD_VAR 0 1
41952: PPUSH
41953: LD_VAR 0 6
41957: PPUSH
41958: CALL_OW 1
41962: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
41963: LD_ADDR_EXP 65
41967: PUSH
41968: LD_EXP 65
41972: PPUSH
41973: LD_VAR 0 1
41977: PPUSH
41978: LD_VAR 0 3
41982: PPUSH
41983: CALL_OW 1
41987: ST_TO_ADDR
// end ;
41988: LD_VAR 0 4
41992: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
41993: LD_INT 0
41995: PPUSH
// if not mc_bases [ base ] then
41996: LD_EXP 50
42000: PUSH
42001: LD_VAR 0 1
42005: ARRAY
42006: NOT
42007: IFFALSE 42011
// exit ;
42009: GO 42036
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42011: LD_ADDR_EXP 55
42015: PUSH
42016: LD_EXP 55
42020: PPUSH
42021: LD_VAR 0 1
42025: PPUSH
42026: LD_VAR 0 2
42030: PPUSH
42031: CALL_OW 1
42035: ST_TO_ADDR
// end ;
42036: LD_VAR 0 3
42040: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42041: LD_INT 0
42043: PPUSH
// if not mc_bases [ base ] then
42044: LD_EXP 50
42048: PUSH
42049: LD_VAR 0 1
42053: ARRAY
42054: NOT
42055: IFFALSE 42059
// exit ;
42057: GO 42096
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42059: LD_ADDR_EXP 55
42063: PUSH
42064: LD_EXP 55
42068: PPUSH
42069: LD_VAR 0 1
42073: PPUSH
42074: LD_EXP 55
42078: PUSH
42079: LD_VAR 0 1
42083: ARRAY
42084: PUSH
42085: LD_VAR 0 2
42089: UNION
42090: PPUSH
42091: CALL_OW 1
42095: ST_TO_ADDR
// end ;
42096: LD_VAR 0 3
42100: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42101: LD_INT 0
42103: PPUSH
// if not mc_bases [ base ] then
42104: LD_EXP 50
42108: PUSH
42109: LD_VAR 0 1
42113: ARRAY
42114: NOT
42115: IFFALSE 42119
// exit ;
42117: GO 42144
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42119: LD_ADDR_EXP 71
42123: PUSH
42124: LD_EXP 71
42128: PPUSH
42129: LD_VAR 0 1
42133: PPUSH
42134: LD_VAR 0 2
42138: PPUSH
42139: CALL_OW 1
42143: ST_TO_ADDR
// end ;
42144: LD_VAR 0 3
42148: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42149: LD_INT 0
42151: PPUSH
// if not mc_bases [ base ] then
42152: LD_EXP 50
42156: PUSH
42157: LD_VAR 0 1
42161: ARRAY
42162: NOT
42163: IFFALSE 42167
// exit ;
42165: GO 42204
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42167: LD_ADDR_EXP 71
42171: PUSH
42172: LD_EXP 71
42176: PPUSH
42177: LD_VAR 0 1
42181: PPUSH
42182: LD_EXP 71
42186: PUSH
42187: LD_VAR 0 1
42191: ARRAY
42192: PUSH
42193: LD_VAR 0 2
42197: ADD
42198: PPUSH
42199: CALL_OW 1
42203: ST_TO_ADDR
// end ;
42204: LD_VAR 0 3
42208: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42209: LD_INT 0
42211: PPUSH
// if not mc_bases [ base ] then
42212: LD_EXP 50
42216: PUSH
42217: LD_VAR 0 1
42221: ARRAY
42222: NOT
42223: IFFALSE 42227
// exit ;
42225: GO 42281
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42227: LD_ADDR_EXP 72
42231: PUSH
42232: LD_EXP 72
42236: PPUSH
42237: LD_VAR 0 1
42241: PPUSH
42242: LD_VAR 0 2
42246: PPUSH
42247: CALL_OW 1
42251: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42252: LD_ADDR_EXP 61
42256: PUSH
42257: LD_EXP 61
42261: PPUSH
42262: LD_VAR 0 1
42266: PPUSH
42267: LD_VAR 0 2
42271: PUSH
42272: LD_INT 0
42274: PLUS
42275: PPUSH
42276: CALL_OW 1
42280: ST_TO_ADDR
// end ;
42281: LD_VAR 0 3
42285: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42286: LD_INT 0
42288: PPUSH
// if not mc_bases [ base ] then
42289: LD_EXP 50
42293: PUSH
42294: LD_VAR 0 1
42298: ARRAY
42299: NOT
42300: IFFALSE 42304
// exit ;
42302: GO 42329
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42304: LD_ADDR_EXP 61
42308: PUSH
42309: LD_EXP 61
42313: PPUSH
42314: LD_VAR 0 1
42318: PPUSH
42319: LD_VAR 0 2
42323: PPUSH
42324: CALL_OW 1
42328: ST_TO_ADDR
// end ;
42329: LD_VAR 0 3
42333: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42334: LD_INT 0
42336: PPUSH
42337: PPUSH
42338: PPUSH
42339: PPUSH
// if not mc_bases [ base ] then
42340: LD_EXP 50
42344: PUSH
42345: LD_VAR 0 1
42349: ARRAY
42350: NOT
42351: IFFALSE 42355
// exit ;
42353: GO 42420
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42355: LD_ADDR_EXP 70
42359: PUSH
42360: LD_EXP 70
42364: PPUSH
42365: LD_VAR 0 1
42369: PUSH
42370: LD_EXP 70
42374: PUSH
42375: LD_VAR 0 1
42379: ARRAY
42380: PUSH
42381: LD_INT 1
42383: PLUS
42384: PUSH
42385: EMPTY
42386: LIST
42387: LIST
42388: PPUSH
42389: LD_VAR 0 1
42393: PUSH
42394: LD_VAR 0 2
42398: PUSH
42399: LD_VAR 0 3
42403: PUSH
42404: LD_VAR 0 4
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: LIST
42413: LIST
42414: PPUSH
42415: CALL 53541 0 3
42419: ST_TO_ADDR
// end ;
42420: LD_VAR 0 5
42424: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42425: LD_INT 0
42427: PPUSH
// if not mc_bases [ base ] then
42428: LD_EXP 50
42432: PUSH
42433: LD_VAR 0 1
42437: ARRAY
42438: NOT
42439: IFFALSE 42443
// exit ;
42441: GO 42468
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42443: LD_ADDR_EXP 87
42447: PUSH
42448: LD_EXP 87
42452: PPUSH
42453: LD_VAR 0 1
42457: PPUSH
42458: LD_VAR 0 2
42462: PPUSH
42463: CALL_OW 1
42467: ST_TO_ADDR
// end ;
42468: LD_VAR 0 3
42472: RET
// export function MC_GetMinesField ( base ) ; begin
42473: LD_INT 0
42475: PPUSH
// result := mc_mines [ base ] ;
42476: LD_ADDR_VAR 0 2
42480: PUSH
42481: LD_EXP 63
42485: PUSH
42486: LD_VAR 0 1
42490: ARRAY
42491: ST_TO_ADDR
// end ;
42492: LD_VAR 0 2
42496: RET
// export function MC_GetProduceList ( base ) ; begin
42497: LD_INT 0
42499: PPUSH
// result := mc_produce [ base ] ;
42500: LD_ADDR_VAR 0 2
42504: PUSH
42505: LD_EXP 71
42509: PUSH
42510: LD_VAR 0 1
42514: ARRAY
42515: ST_TO_ADDR
// end ;
42516: LD_VAR 0 2
42520: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42521: LD_INT 0
42523: PPUSH
42524: PPUSH
// if not mc_bases then
42525: LD_EXP 50
42529: NOT
42530: IFFALSE 42534
// exit ;
42532: GO 42599
// if mc_bases [ base ] then
42534: LD_EXP 50
42538: PUSH
42539: LD_VAR 0 1
42543: ARRAY
42544: IFFALSE 42599
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42546: LD_ADDR_VAR 0 3
42550: PUSH
42551: LD_EXP 50
42555: PUSH
42556: LD_VAR 0 1
42560: ARRAY
42561: PPUSH
42562: LD_INT 30
42564: PUSH
42565: LD_VAR 0 2
42569: PUSH
42570: EMPTY
42571: LIST
42572: LIST
42573: PPUSH
42574: CALL_OW 72
42578: ST_TO_ADDR
// if result then
42579: LD_VAR 0 3
42583: IFFALSE 42599
// result := result [ 1 ] ;
42585: LD_ADDR_VAR 0 3
42589: PUSH
42590: LD_VAR 0 3
42594: PUSH
42595: LD_INT 1
42597: ARRAY
42598: ST_TO_ADDR
// end ; end ;
42599: LD_VAR 0 3
42603: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42604: LD_INT 0
42606: PPUSH
42607: PPUSH
// if not mc_bases then
42608: LD_EXP 50
42612: NOT
42613: IFFALSE 42617
// exit ;
42615: GO 42662
// if mc_bases [ base ] then
42617: LD_EXP 50
42621: PUSH
42622: LD_VAR 0 1
42626: ARRAY
42627: IFFALSE 42662
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42629: LD_ADDR_VAR 0 3
42633: PUSH
42634: LD_EXP 50
42638: PUSH
42639: LD_VAR 0 1
42643: ARRAY
42644: PPUSH
42645: LD_INT 30
42647: PUSH
42648: LD_VAR 0 2
42652: PUSH
42653: EMPTY
42654: LIST
42655: LIST
42656: PPUSH
42657: CALL_OW 72
42661: ST_TO_ADDR
// end ;
42662: LD_VAR 0 3
42666: RET
// export function MC_SetTame ( base , area ) ; begin
42667: LD_INT 0
42669: PPUSH
// if not mc_bases or not base then
42670: LD_EXP 50
42674: NOT
42675: PUSH
42676: LD_VAR 0 1
42680: NOT
42681: OR
42682: IFFALSE 42686
// exit ;
42684: GO 42711
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42686: LD_ADDR_EXP 78
42690: PUSH
42691: LD_EXP 78
42695: PPUSH
42696: LD_VAR 0 1
42700: PPUSH
42701: LD_VAR 0 2
42705: PPUSH
42706: CALL_OW 1
42710: ST_TO_ADDR
// end ;
42711: LD_VAR 0 3
42715: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42716: LD_INT 0
42718: PPUSH
42719: PPUSH
// if not mc_bases or not base then
42720: LD_EXP 50
42724: NOT
42725: PUSH
42726: LD_VAR 0 1
42730: NOT
42731: OR
42732: IFFALSE 42736
// exit ;
42734: GO 42838
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42736: LD_ADDR_VAR 0 4
42740: PUSH
42741: LD_EXP 50
42745: PUSH
42746: LD_VAR 0 1
42750: ARRAY
42751: PPUSH
42752: LD_INT 30
42754: PUSH
42755: LD_VAR 0 2
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PPUSH
42764: CALL_OW 72
42768: ST_TO_ADDR
// if not tmp then
42769: LD_VAR 0 4
42773: NOT
42774: IFFALSE 42778
// exit ;
42776: GO 42838
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42778: LD_ADDR_EXP 82
42782: PUSH
42783: LD_EXP 82
42787: PPUSH
42788: LD_VAR 0 1
42792: PPUSH
42793: LD_EXP 82
42797: PUSH
42798: LD_VAR 0 1
42802: ARRAY
42803: PPUSH
42804: LD_EXP 82
42808: PUSH
42809: LD_VAR 0 1
42813: ARRAY
42814: PUSH
42815: LD_INT 1
42817: PLUS
42818: PPUSH
42819: LD_VAR 0 4
42823: PUSH
42824: LD_INT 1
42826: ARRAY
42827: PPUSH
42828: CALL_OW 2
42832: PPUSH
42833: CALL_OW 1
42837: ST_TO_ADDR
// end ;
42838: LD_VAR 0 3
42842: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42843: LD_INT 0
42845: PPUSH
42846: PPUSH
// if not mc_bases or not base or not kinds then
42847: LD_EXP 50
42851: NOT
42852: PUSH
42853: LD_VAR 0 1
42857: NOT
42858: OR
42859: PUSH
42860: LD_VAR 0 2
42864: NOT
42865: OR
42866: IFFALSE 42870
// exit ;
42868: GO 42931
// for i in kinds do
42870: LD_ADDR_VAR 0 4
42874: PUSH
42875: LD_VAR 0 2
42879: PUSH
42880: FOR_IN
42881: IFFALSE 42929
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42883: LD_ADDR_EXP 84
42887: PUSH
42888: LD_EXP 84
42892: PPUSH
42893: LD_VAR 0 1
42897: PUSH
42898: LD_EXP 84
42902: PUSH
42903: LD_VAR 0 1
42907: ARRAY
42908: PUSH
42909: LD_INT 1
42911: PLUS
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PPUSH
42917: LD_VAR 0 4
42921: PPUSH
42922: CALL 53541 0 3
42926: ST_TO_ADDR
42927: GO 42880
42929: POP
42930: POP
// end ;
42931: LD_VAR 0 3
42935: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
42936: LD_INT 0
42938: PPUSH
// if not mc_bases or not base or not areas then
42939: LD_EXP 50
42943: NOT
42944: PUSH
42945: LD_VAR 0 1
42949: NOT
42950: OR
42951: PUSH
42952: LD_VAR 0 2
42956: NOT
42957: OR
42958: IFFALSE 42962
// exit ;
42960: GO 42987
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
42962: LD_ADDR_EXP 68
42966: PUSH
42967: LD_EXP 68
42971: PPUSH
42972: LD_VAR 0 1
42976: PPUSH
42977: LD_VAR 0 2
42981: PPUSH
42982: CALL_OW 1
42986: ST_TO_ADDR
// end ;
42987: LD_VAR 0 3
42991: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
42992: LD_INT 0
42994: PPUSH
// if not mc_bases or not base or not teleports_exit then
42995: LD_EXP 50
42999: NOT
43000: PUSH
43001: LD_VAR 0 1
43005: NOT
43006: OR
43007: PUSH
43008: LD_VAR 0 2
43012: NOT
43013: OR
43014: IFFALSE 43018
// exit ;
43016: GO 43043
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43018: LD_ADDR_EXP 85
43022: PUSH
43023: LD_EXP 85
43027: PPUSH
43028: LD_VAR 0 1
43032: PPUSH
43033: LD_VAR 0 2
43037: PPUSH
43038: CALL_OW 1
43042: ST_TO_ADDR
// end ;
43043: LD_VAR 0 3
43047: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43048: LD_INT 0
43050: PPUSH
43051: PPUSH
43052: PPUSH
// if not mc_bases or not base or not ext_list then
43053: LD_EXP 50
43057: NOT
43058: PUSH
43059: LD_VAR 0 1
43063: NOT
43064: OR
43065: PUSH
43066: LD_VAR 0 5
43070: NOT
43071: OR
43072: IFFALSE 43076
// exit ;
43074: GO 43249
// tmp := GetFacExtXYD ( x , y , d ) ;
43076: LD_ADDR_VAR 0 8
43080: PUSH
43081: LD_VAR 0 2
43085: PPUSH
43086: LD_VAR 0 3
43090: PPUSH
43091: LD_VAR 0 4
43095: PPUSH
43096: CALL 82928 0 3
43100: ST_TO_ADDR
// if not tmp then
43101: LD_VAR 0 8
43105: NOT
43106: IFFALSE 43110
// exit ;
43108: GO 43249
// for i in tmp do
43110: LD_ADDR_VAR 0 7
43114: PUSH
43115: LD_VAR 0 8
43119: PUSH
43120: FOR_IN
43121: IFFALSE 43247
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43123: LD_ADDR_EXP 55
43127: PUSH
43128: LD_EXP 55
43132: PPUSH
43133: LD_VAR 0 1
43137: PPUSH
43138: LD_EXP 55
43142: PUSH
43143: LD_VAR 0 1
43147: ARRAY
43148: PPUSH
43149: LD_EXP 55
43153: PUSH
43154: LD_VAR 0 1
43158: ARRAY
43159: PUSH
43160: LD_INT 1
43162: PLUS
43163: PPUSH
43164: LD_VAR 0 5
43168: PUSH
43169: LD_INT 1
43171: ARRAY
43172: PUSH
43173: LD_VAR 0 7
43177: PUSH
43178: LD_INT 1
43180: ARRAY
43181: PUSH
43182: LD_VAR 0 7
43186: PUSH
43187: LD_INT 2
43189: ARRAY
43190: PUSH
43191: LD_VAR 0 7
43195: PUSH
43196: LD_INT 3
43198: ARRAY
43199: PUSH
43200: EMPTY
43201: LIST
43202: LIST
43203: LIST
43204: LIST
43205: PPUSH
43206: CALL_OW 2
43210: PPUSH
43211: CALL_OW 1
43215: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43216: LD_ADDR_VAR 0 5
43220: PUSH
43221: LD_VAR 0 5
43225: PPUSH
43226: LD_INT 1
43228: PPUSH
43229: CALL_OW 3
43233: ST_TO_ADDR
// if not ext_list then
43234: LD_VAR 0 5
43238: NOT
43239: IFFALSE 43245
// exit ;
43241: POP
43242: POP
43243: GO 43249
// end ;
43245: GO 43120
43247: POP
43248: POP
// end ;
43249: LD_VAR 0 6
43253: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43254: LD_INT 0
43256: PPUSH
// if not mc_bases or not base or not weapon_list then
43257: LD_EXP 50
43261: NOT
43262: PUSH
43263: LD_VAR 0 1
43267: NOT
43268: OR
43269: PUSH
43270: LD_VAR 0 2
43274: NOT
43275: OR
43276: IFFALSE 43280
// exit ;
43278: GO 43305
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43280: LD_ADDR_EXP 89
43284: PUSH
43285: LD_EXP 89
43289: PPUSH
43290: LD_VAR 0 1
43294: PPUSH
43295: LD_VAR 0 2
43299: PPUSH
43300: CALL_OW 1
43304: ST_TO_ADDR
// end ;
43305: LD_VAR 0 3
43309: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43310: LD_INT 0
43312: PPUSH
// if not mc_bases or not base or not tech_list then
43313: LD_EXP 50
43317: NOT
43318: PUSH
43319: LD_VAR 0 1
43323: NOT
43324: OR
43325: PUSH
43326: LD_VAR 0 2
43330: NOT
43331: OR
43332: IFFALSE 43336
// exit ;
43334: GO 43361
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43336: LD_ADDR_EXP 77
43340: PUSH
43341: LD_EXP 77
43345: PPUSH
43346: LD_VAR 0 1
43350: PPUSH
43351: LD_VAR 0 2
43355: PPUSH
43356: CALL_OW 1
43360: ST_TO_ADDR
// end ;
43361: LD_VAR 0 3
43365: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43366: LD_INT 0
43368: PPUSH
// if not mc_bases or not parking_area or not base then
43369: LD_EXP 50
43373: NOT
43374: PUSH
43375: LD_VAR 0 2
43379: NOT
43380: OR
43381: PUSH
43382: LD_VAR 0 1
43386: NOT
43387: OR
43388: IFFALSE 43392
// exit ;
43390: GO 43417
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43392: LD_ADDR_EXP 74
43396: PUSH
43397: LD_EXP 74
43401: PPUSH
43402: LD_VAR 0 1
43406: PPUSH
43407: LD_VAR 0 2
43411: PPUSH
43412: CALL_OW 1
43416: ST_TO_ADDR
// end ;
43417: LD_VAR 0 3
43421: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43422: LD_INT 0
43424: PPUSH
// if not mc_bases or not base or not scan_area then
43425: LD_EXP 50
43429: NOT
43430: PUSH
43431: LD_VAR 0 1
43435: NOT
43436: OR
43437: PUSH
43438: LD_VAR 0 2
43442: NOT
43443: OR
43444: IFFALSE 43448
// exit ;
43446: GO 43473
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43448: LD_ADDR_EXP 75
43452: PUSH
43453: LD_EXP 75
43457: PPUSH
43458: LD_VAR 0 1
43462: PPUSH
43463: LD_VAR 0 2
43467: PPUSH
43468: CALL_OW 1
43472: ST_TO_ADDR
// end ;
43473: LD_VAR 0 3
43477: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43478: LD_INT 0
43480: PPUSH
43481: PPUSH
// if not mc_bases or not base then
43482: LD_EXP 50
43486: NOT
43487: PUSH
43488: LD_VAR 0 1
43492: NOT
43493: OR
43494: IFFALSE 43498
// exit ;
43496: GO 43562
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43498: LD_ADDR_VAR 0 3
43502: PUSH
43503: LD_INT 1
43505: PUSH
43506: LD_INT 2
43508: PUSH
43509: LD_INT 3
43511: PUSH
43512: LD_INT 4
43514: PUSH
43515: LD_INT 11
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: LIST
43522: LIST
43523: LIST
43524: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43525: LD_ADDR_EXP 77
43529: PUSH
43530: LD_EXP 77
43534: PPUSH
43535: LD_VAR 0 1
43539: PPUSH
43540: LD_EXP 77
43544: PUSH
43545: LD_VAR 0 1
43549: ARRAY
43550: PUSH
43551: LD_VAR 0 3
43555: DIFF
43556: PPUSH
43557: CALL_OW 1
43561: ST_TO_ADDR
// end ;
43562: LD_VAR 0 2
43566: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43567: LD_INT 0
43569: PPUSH
// result := mc_vehicles [ base ] ;
43570: LD_ADDR_VAR 0 3
43574: PUSH
43575: LD_EXP 69
43579: PUSH
43580: LD_VAR 0 1
43584: ARRAY
43585: ST_TO_ADDR
// if onlyCombat then
43586: LD_VAR 0 2
43590: IFFALSE 43768
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43592: LD_ADDR_VAR 0 3
43596: PUSH
43597: LD_VAR 0 3
43601: PUSH
43602: LD_VAR 0 3
43606: PPUSH
43607: LD_INT 2
43609: PUSH
43610: LD_INT 34
43612: PUSH
43613: LD_INT 12
43615: PUSH
43616: EMPTY
43617: LIST
43618: LIST
43619: PUSH
43620: LD_INT 34
43622: PUSH
43623: LD_INT 51
43625: PUSH
43626: EMPTY
43627: LIST
43628: LIST
43629: PUSH
43630: LD_INT 34
43632: PUSH
43633: LD_EXP 95
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: PUSH
43642: LD_INT 34
43644: PUSH
43645: LD_INT 32
43647: PUSH
43648: EMPTY
43649: LIST
43650: LIST
43651: PUSH
43652: LD_INT 34
43654: PUSH
43655: LD_INT 13
43657: PUSH
43658: EMPTY
43659: LIST
43660: LIST
43661: PUSH
43662: LD_INT 34
43664: PUSH
43665: LD_INT 52
43667: PUSH
43668: EMPTY
43669: LIST
43670: LIST
43671: PUSH
43672: LD_INT 34
43674: PUSH
43675: LD_EXP 100
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 34
43686: PUSH
43687: LD_INT 14
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 34
43696: PUSH
43697: LD_INT 53
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 34
43706: PUSH
43707: LD_EXP 94
43711: PUSH
43712: EMPTY
43713: LIST
43714: LIST
43715: PUSH
43716: LD_INT 34
43718: PUSH
43719: LD_INT 31
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: PUSH
43726: LD_INT 34
43728: PUSH
43729: LD_INT 48
43731: PUSH
43732: EMPTY
43733: LIST
43734: LIST
43735: PUSH
43736: LD_INT 34
43738: PUSH
43739: LD_INT 8
43741: PUSH
43742: EMPTY
43743: LIST
43744: LIST
43745: PUSH
43746: EMPTY
43747: LIST
43748: LIST
43749: LIST
43750: LIST
43751: LIST
43752: LIST
43753: LIST
43754: LIST
43755: LIST
43756: LIST
43757: LIST
43758: LIST
43759: LIST
43760: LIST
43761: PPUSH
43762: CALL_OW 72
43766: DIFF
43767: ST_TO_ADDR
// end ; end_of_file
43768: LD_VAR 0 3
43772: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43773: LD_INT 0
43775: PPUSH
43776: PPUSH
43777: PPUSH
// if not mc_bases or not skirmish then
43778: LD_EXP 50
43782: NOT
43783: PUSH
43784: LD_EXP 48
43788: NOT
43789: OR
43790: IFFALSE 43794
// exit ;
43792: GO 43959
// for i = 1 to mc_bases do
43794: LD_ADDR_VAR 0 4
43798: PUSH
43799: DOUBLE
43800: LD_INT 1
43802: DEC
43803: ST_TO_ADDR
43804: LD_EXP 50
43808: PUSH
43809: FOR_TO
43810: IFFALSE 43957
// begin if sci in mc_bases [ i ] then
43812: LD_VAR 0 2
43816: PUSH
43817: LD_EXP 50
43821: PUSH
43822: LD_VAR 0 4
43826: ARRAY
43827: IN
43828: IFFALSE 43955
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43830: LD_ADDR_EXP 79
43834: PUSH
43835: LD_EXP 79
43839: PPUSH
43840: LD_VAR 0 4
43844: PUSH
43845: LD_EXP 79
43849: PUSH
43850: LD_VAR 0 4
43854: ARRAY
43855: PUSH
43856: LD_INT 1
43858: PLUS
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: PPUSH
43864: LD_VAR 0 1
43868: PPUSH
43869: CALL 53541 0 3
43873: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43874: LD_ADDR_VAR 0 5
43878: PUSH
43879: LD_EXP 50
43883: PUSH
43884: LD_VAR 0 4
43888: ARRAY
43889: PPUSH
43890: LD_INT 2
43892: PUSH
43893: LD_INT 30
43895: PUSH
43896: LD_INT 0
43898: PUSH
43899: EMPTY
43900: LIST
43901: LIST
43902: PUSH
43903: LD_INT 30
43905: PUSH
43906: LD_INT 1
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: LIST
43917: PPUSH
43918: CALL_OW 72
43922: PPUSH
43923: LD_VAR 0 1
43927: PPUSH
43928: CALL_OW 74
43932: ST_TO_ADDR
// if tmp then
43933: LD_VAR 0 5
43937: IFFALSE 43953
// ComStandNearbyBuilding ( ape , tmp ) ;
43939: LD_VAR 0 1
43943: PPUSH
43944: LD_VAR 0 5
43948: PPUSH
43949: CALL 50119 0 2
// break ;
43953: GO 43957
// end ; end ;
43955: GO 43809
43957: POP
43958: POP
// end ;
43959: LD_VAR 0 3
43963: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
43964: LD_INT 0
43966: PPUSH
43967: PPUSH
43968: PPUSH
// if not mc_bases or not skirmish then
43969: LD_EXP 50
43973: NOT
43974: PUSH
43975: LD_EXP 48
43979: NOT
43980: OR
43981: IFFALSE 43985
// exit ;
43983: GO 44074
// for i = 1 to mc_bases do
43985: LD_ADDR_VAR 0 4
43989: PUSH
43990: DOUBLE
43991: LD_INT 1
43993: DEC
43994: ST_TO_ADDR
43995: LD_EXP 50
43999: PUSH
44000: FOR_TO
44001: IFFALSE 44072
// begin if building in mc_busy_turret_list [ i ] then
44003: LD_VAR 0 1
44007: PUSH
44008: LD_EXP 60
44012: PUSH
44013: LD_VAR 0 4
44017: ARRAY
44018: IN
44019: IFFALSE 44070
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44021: LD_ADDR_VAR 0 5
44025: PUSH
44026: LD_EXP 60
44030: PUSH
44031: LD_VAR 0 4
44035: ARRAY
44036: PUSH
44037: LD_VAR 0 1
44041: DIFF
44042: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44043: LD_ADDR_EXP 60
44047: PUSH
44048: LD_EXP 60
44052: PPUSH
44053: LD_VAR 0 4
44057: PPUSH
44058: LD_VAR 0 5
44062: PPUSH
44063: CALL_OW 1
44067: ST_TO_ADDR
// break ;
44068: GO 44072
// end ; end ;
44070: GO 44000
44072: POP
44073: POP
// end ;
44074: LD_VAR 0 3
44078: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44079: LD_INT 0
44081: PPUSH
44082: PPUSH
44083: PPUSH
// if not mc_bases or not skirmish then
44084: LD_EXP 50
44088: NOT
44089: PUSH
44090: LD_EXP 48
44094: NOT
44095: OR
44096: IFFALSE 44100
// exit ;
44098: GO 44299
// for i = 1 to mc_bases do
44100: LD_ADDR_VAR 0 5
44104: PUSH
44105: DOUBLE
44106: LD_INT 1
44108: DEC
44109: ST_TO_ADDR
44110: LD_EXP 50
44114: PUSH
44115: FOR_TO
44116: IFFALSE 44297
// if building in mc_bases [ i ] then
44118: LD_VAR 0 1
44122: PUSH
44123: LD_EXP 50
44127: PUSH
44128: LD_VAR 0 5
44132: ARRAY
44133: IN
44134: IFFALSE 44295
// begin tmp := mc_bases [ i ] diff building ;
44136: LD_ADDR_VAR 0 6
44140: PUSH
44141: LD_EXP 50
44145: PUSH
44146: LD_VAR 0 5
44150: ARRAY
44151: PUSH
44152: LD_VAR 0 1
44156: DIFF
44157: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44158: LD_ADDR_EXP 50
44162: PUSH
44163: LD_EXP 50
44167: PPUSH
44168: LD_VAR 0 5
44172: PPUSH
44173: LD_VAR 0 6
44177: PPUSH
44178: CALL_OW 1
44182: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44183: LD_VAR 0 1
44187: PUSH
44188: LD_EXP 58
44192: PUSH
44193: LD_VAR 0 5
44197: ARRAY
44198: IN
44199: IFFALSE 44238
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44201: LD_ADDR_EXP 58
44205: PUSH
44206: LD_EXP 58
44210: PPUSH
44211: LD_VAR 0 5
44215: PPUSH
44216: LD_EXP 58
44220: PUSH
44221: LD_VAR 0 5
44225: ARRAY
44226: PUSH
44227: LD_VAR 0 1
44231: DIFF
44232: PPUSH
44233: CALL_OW 1
44237: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44238: LD_VAR 0 1
44242: PUSH
44243: LD_EXP 59
44247: PUSH
44248: LD_VAR 0 5
44252: ARRAY
44253: IN
44254: IFFALSE 44293
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44256: LD_ADDR_EXP 59
44260: PUSH
44261: LD_EXP 59
44265: PPUSH
44266: LD_VAR 0 5
44270: PPUSH
44271: LD_EXP 59
44275: PUSH
44276: LD_VAR 0 5
44280: ARRAY
44281: PUSH
44282: LD_VAR 0 1
44286: DIFF
44287: PPUSH
44288: CALL_OW 1
44292: ST_TO_ADDR
// break ;
44293: GO 44297
// end ;
44295: GO 44115
44297: POP
44298: POP
// end ;
44299: LD_VAR 0 4
44303: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44304: LD_INT 0
44306: PPUSH
44307: PPUSH
44308: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44309: LD_EXP 50
44313: NOT
44314: PUSH
44315: LD_EXP 48
44319: NOT
44320: OR
44321: PUSH
44322: LD_VAR 0 3
44326: PUSH
44327: LD_EXP 76
44331: IN
44332: NOT
44333: OR
44334: IFFALSE 44338
// exit ;
44336: GO 44461
// for i = 1 to mc_vehicles do
44338: LD_ADDR_VAR 0 6
44342: PUSH
44343: DOUBLE
44344: LD_INT 1
44346: DEC
44347: ST_TO_ADDR
44348: LD_EXP 69
44352: PUSH
44353: FOR_TO
44354: IFFALSE 44459
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44356: LD_VAR 0 2
44360: PUSH
44361: LD_EXP 69
44365: PUSH
44366: LD_VAR 0 6
44370: ARRAY
44371: IN
44372: PUSH
44373: LD_VAR 0 1
44377: PUSH
44378: LD_EXP 69
44382: PUSH
44383: LD_VAR 0 6
44387: ARRAY
44388: IN
44389: OR
44390: IFFALSE 44457
// begin tmp := mc_vehicles [ i ] diff old ;
44392: LD_ADDR_VAR 0 7
44396: PUSH
44397: LD_EXP 69
44401: PUSH
44402: LD_VAR 0 6
44406: ARRAY
44407: PUSH
44408: LD_VAR 0 2
44412: DIFF
44413: ST_TO_ADDR
// tmp := tmp diff new ;
44414: LD_ADDR_VAR 0 7
44418: PUSH
44419: LD_VAR 0 7
44423: PUSH
44424: LD_VAR 0 1
44428: DIFF
44429: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44430: LD_ADDR_EXP 69
44434: PUSH
44435: LD_EXP 69
44439: PPUSH
44440: LD_VAR 0 6
44444: PPUSH
44445: LD_VAR 0 7
44449: PPUSH
44450: CALL_OW 1
44454: ST_TO_ADDR
// break ;
44455: GO 44459
// end ;
44457: GO 44353
44459: POP
44460: POP
// end ;
44461: LD_VAR 0 5
44465: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44466: LD_INT 0
44468: PPUSH
44469: PPUSH
44470: PPUSH
44471: PPUSH
// if not mc_bases or not skirmish then
44472: LD_EXP 50
44476: NOT
44477: PUSH
44478: LD_EXP 48
44482: NOT
44483: OR
44484: IFFALSE 44488
// exit ;
44486: GO 44880
// side := GetSide ( vehicle ) ;
44488: LD_ADDR_VAR 0 5
44492: PUSH
44493: LD_VAR 0 1
44497: PPUSH
44498: CALL_OW 255
44502: ST_TO_ADDR
// for i = 1 to mc_bases do
44503: LD_ADDR_VAR 0 4
44507: PUSH
44508: DOUBLE
44509: LD_INT 1
44511: DEC
44512: ST_TO_ADDR
44513: LD_EXP 50
44517: PUSH
44518: FOR_TO
44519: IFFALSE 44878
// begin if factory in mc_bases [ i ] then
44521: LD_VAR 0 2
44525: PUSH
44526: LD_EXP 50
44530: PUSH
44531: LD_VAR 0 4
44535: ARRAY
44536: IN
44537: IFFALSE 44876
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44539: LD_EXP 72
44543: PUSH
44544: LD_VAR 0 4
44548: ARRAY
44549: PUSH
44550: LD_EXP 61
44554: PUSH
44555: LD_VAR 0 4
44559: ARRAY
44560: LESS
44561: PUSH
44562: LD_VAR 0 1
44566: PPUSH
44567: CALL_OW 264
44571: PUSH
44572: LD_INT 31
44574: PUSH
44575: LD_INT 32
44577: PUSH
44578: LD_INT 51
44580: PUSH
44581: LD_EXP 95
44585: PUSH
44586: LD_INT 12
44588: PUSH
44589: LD_INT 30
44591: PUSH
44592: LD_EXP 94
44596: PUSH
44597: LD_INT 11
44599: PUSH
44600: LD_INT 53
44602: PUSH
44603: LD_INT 14
44605: PUSH
44606: LD_EXP 98
44610: PUSH
44611: LD_INT 29
44613: PUSH
44614: LD_EXP 96
44618: PUSH
44619: LD_INT 13
44621: PUSH
44622: LD_INT 52
44624: PUSH
44625: LD_EXP 100
44629: PUSH
44630: LD_INT 48
44632: PUSH
44633: LD_INT 8
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: LIST
44640: LIST
44641: LIST
44642: LIST
44643: LIST
44644: LIST
44645: LIST
44646: LIST
44647: LIST
44648: LIST
44649: LIST
44650: LIST
44651: LIST
44652: LIST
44653: LIST
44654: LIST
44655: IN
44656: NOT
44657: AND
44658: IFFALSE 44706
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44660: LD_ADDR_EXP 72
44664: PUSH
44665: LD_EXP 72
44669: PPUSH
44670: LD_VAR 0 4
44674: PUSH
44675: LD_EXP 72
44679: PUSH
44680: LD_VAR 0 4
44684: ARRAY
44685: PUSH
44686: LD_INT 1
44688: PLUS
44689: PUSH
44690: EMPTY
44691: LIST
44692: LIST
44693: PPUSH
44694: LD_VAR 0 1
44698: PPUSH
44699: CALL 53541 0 3
44703: ST_TO_ADDR
44704: GO 44750
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44706: LD_ADDR_EXP 69
44710: PUSH
44711: LD_EXP 69
44715: PPUSH
44716: LD_VAR 0 4
44720: PUSH
44721: LD_EXP 69
44725: PUSH
44726: LD_VAR 0 4
44730: ARRAY
44731: PUSH
44732: LD_INT 1
44734: PLUS
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PPUSH
44740: LD_VAR 0 1
44744: PPUSH
44745: CALL 53541 0 3
44749: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44750: LD_VAR 0 1
44754: PPUSH
44755: CALL_OW 263
44759: PUSH
44760: LD_INT 2
44762: EQUAL
44763: IFFALSE 44792
// begin repeat wait ( 0 0$3 ) ;
44765: LD_INT 105
44767: PPUSH
44768: CALL_OW 67
// Connect ( vehicle ) ;
44772: LD_VAR 0 1
44776: PPUSH
44777: CALL 56512 0 1
// until IsControledBy ( vehicle ) ;
44781: LD_VAR 0 1
44785: PPUSH
44786: CALL_OW 312
44790: IFFALSE 44765
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44792: LD_VAR 0 1
44796: PPUSH
44797: LD_EXP 74
44801: PUSH
44802: LD_VAR 0 4
44806: ARRAY
44807: PPUSH
44808: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44812: LD_VAR 0 1
44816: PPUSH
44817: CALL_OW 263
44821: PUSH
44822: LD_INT 1
44824: NONEQUAL
44825: IFFALSE 44829
// break ;
44827: GO 44878
// repeat wait ( 0 0$1 ) ;
44829: LD_INT 35
44831: PPUSH
44832: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44836: LD_VAR 0 1
44840: PPUSH
44841: LD_EXP 74
44845: PUSH
44846: LD_VAR 0 4
44850: ARRAY
44851: PPUSH
44852: CALL_OW 308
44856: IFFALSE 44829
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44858: LD_VAR 0 1
44862: PPUSH
44863: CALL_OW 311
44867: PPUSH
44868: CALL_OW 121
// exit ;
44872: POP
44873: POP
44874: GO 44880
// end ; end ;
44876: GO 44518
44878: POP
44879: POP
// end ;
44880: LD_VAR 0 3
44884: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44885: LD_INT 0
44887: PPUSH
44888: PPUSH
44889: PPUSH
44890: PPUSH
// if not mc_bases or not skirmish then
44891: LD_EXP 50
44895: NOT
44896: PUSH
44897: LD_EXP 48
44901: NOT
44902: OR
44903: IFFALSE 44907
// exit ;
44905: GO 45260
// repeat wait ( 0 0$1 ) ;
44907: LD_INT 35
44909: PPUSH
44910: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
44914: LD_VAR 0 2
44918: PPUSH
44919: LD_VAR 0 3
44923: PPUSH
44924: CALL_OW 284
44928: IFFALSE 44907
// if GetResourceTypeXY ( x , y ) = mat_artefact then
44930: LD_VAR 0 2
44934: PPUSH
44935: LD_VAR 0 3
44939: PPUSH
44940: CALL_OW 283
44944: PUSH
44945: LD_INT 4
44947: EQUAL
44948: IFFALSE 44952
// exit ;
44950: GO 45260
// for i = 1 to mc_bases do
44952: LD_ADDR_VAR 0 7
44956: PUSH
44957: DOUBLE
44958: LD_INT 1
44960: DEC
44961: ST_TO_ADDR
44962: LD_EXP 50
44966: PUSH
44967: FOR_TO
44968: IFFALSE 45258
// begin if mc_crates_area [ i ] then
44970: LD_EXP 68
44974: PUSH
44975: LD_VAR 0 7
44979: ARRAY
44980: IFFALSE 45091
// for j in mc_crates_area [ i ] do
44982: LD_ADDR_VAR 0 8
44986: PUSH
44987: LD_EXP 68
44991: PUSH
44992: LD_VAR 0 7
44996: ARRAY
44997: PUSH
44998: FOR_IN
44999: IFFALSE 45089
// if InArea ( x , y , j ) then
45001: LD_VAR 0 2
45005: PPUSH
45006: LD_VAR 0 3
45010: PPUSH
45011: LD_VAR 0 8
45015: PPUSH
45016: CALL_OW 309
45020: IFFALSE 45087
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45022: LD_ADDR_EXP 66
45026: PUSH
45027: LD_EXP 66
45031: PPUSH
45032: LD_VAR 0 7
45036: PUSH
45037: LD_EXP 66
45041: PUSH
45042: LD_VAR 0 7
45046: ARRAY
45047: PUSH
45048: LD_INT 1
45050: PLUS
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PPUSH
45056: LD_VAR 0 4
45060: PUSH
45061: LD_VAR 0 2
45065: PUSH
45066: LD_VAR 0 3
45070: PUSH
45071: EMPTY
45072: LIST
45073: LIST
45074: LIST
45075: PPUSH
45076: CALL 53541 0 3
45080: ST_TO_ADDR
// exit ;
45081: POP
45082: POP
45083: POP
45084: POP
45085: GO 45260
// end ;
45087: GO 44998
45089: POP
45090: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45091: LD_ADDR_VAR 0 9
45095: PUSH
45096: LD_EXP 50
45100: PUSH
45101: LD_VAR 0 7
45105: ARRAY
45106: PPUSH
45107: LD_INT 2
45109: PUSH
45110: LD_INT 30
45112: PUSH
45113: LD_INT 0
45115: PUSH
45116: EMPTY
45117: LIST
45118: LIST
45119: PUSH
45120: LD_INT 30
45122: PUSH
45123: LD_INT 1
45125: PUSH
45126: EMPTY
45127: LIST
45128: LIST
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: LIST
45134: PPUSH
45135: CALL_OW 72
45139: ST_TO_ADDR
// if not depot then
45140: LD_VAR 0 9
45144: NOT
45145: IFFALSE 45149
// continue ;
45147: GO 44967
// for j in depot do
45149: LD_ADDR_VAR 0 8
45153: PUSH
45154: LD_VAR 0 9
45158: PUSH
45159: FOR_IN
45160: IFFALSE 45254
// if GetDistUnitXY ( j , x , y ) < 30 then
45162: LD_VAR 0 8
45166: PPUSH
45167: LD_VAR 0 2
45171: PPUSH
45172: LD_VAR 0 3
45176: PPUSH
45177: CALL_OW 297
45181: PUSH
45182: LD_INT 30
45184: LESS
45185: IFFALSE 45252
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45187: LD_ADDR_EXP 66
45191: PUSH
45192: LD_EXP 66
45196: PPUSH
45197: LD_VAR 0 7
45201: PUSH
45202: LD_EXP 66
45206: PUSH
45207: LD_VAR 0 7
45211: ARRAY
45212: PUSH
45213: LD_INT 1
45215: PLUS
45216: PUSH
45217: EMPTY
45218: LIST
45219: LIST
45220: PPUSH
45221: LD_VAR 0 4
45225: PUSH
45226: LD_VAR 0 2
45230: PUSH
45231: LD_VAR 0 3
45235: PUSH
45236: EMPTY
45237: LIST
45238: LIST
45239: LIST
45240: PPUSH
45241: CALL 53541 0 3
45245: ST_TO_ADDR
// exit ;
45246: POP
45247: POP
45248: POP
45249: POP
45250: GO 45260
// end ;
45252: GO 45159
45254: POP
45255: POP
// end ;
45256: GO 44967
45258: POP
45259: POP
// end ;
45260: LD_VAR 0 6
45264: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45265: LD_INT 0
45267: PPUSH
45268: PPUSH
45269: PPUSH
45270: PPUSH
// if not mc_bases or not skirmish then
45271: LD_EXP 50
45275: NOT
45276: PUSH
45277: LD_EXP 48
45281: NOT
45282: OR
45283: IFFALSE 45287
// exit ;
45285: GO 45564
// side := GetSide ( lab ) ;
45287: LD_ADDR_VAR 0 4
45291: PUSH
45292: LD_VAR 0 2
45296: PPUSH
45297: CALL_OW 255
45301: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45302: LD_VAR 0 4
45306: PUSH
45307: LD_EXP 76
45311: IN
45312: NOT
45313: PUSH
45314: LD_EXP 77
45318: NOT
45319: OR
45320: PUSH
45321: LD_EXP 50
45325: NOT
45326: OR
45327: IFFALSE 45331
// exit ;
45329: GO 45564
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45331: LD_ADDR_EXP 77
45335: PUSH
45336: LD_EXP 77
45340: PPUSH
45341: LD_VAR 0 4
45345: PPUSH
45346: LD_EXP 77
45350: PUSH
45351: LD_VAR 0 4
45355: ARRAY
45356: PUSH
45357: LD_VAR 0 1
45361: DIFF
45362: PPUSH
45363: CALL_OW 1
45367: ST_TO_ADDR
// for i = 1 to mc_bases do
45368: LD_ADDR_VAR 0 5
45372: PUSH
45373: DOUBLE
45374: LD_INT 1
45376: DEC
45377: ST_TO_ADDR
45378: LD_EXP 50
45382: PUSH
45383: FOR_TO
45384: IFFALSE 45562
// begin if lab in mc_bases [ i ] then
45386: LD_VAR 0 2
45390: PUSH
45391: LD_EXP 50
45395: PUSH
45396: LD_VAR 0 5
45400: ARRAY
45401: IN
45402: IFFALSE 45560
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45404: LD_VAR 0 1
45408: PUSH
45409: LD_INT 11
45411: PUSH
45412: LD_INT 4
45414: PUSH
45415: LD_INT 3
45417: PUSH
45418: LD_INT 2
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: LIST
45425: LIST
45426: IN
45427: PUSH
45428: LD_EXP 80
45432: PUSH
45433: LD_VAR 0 5
45437: ARRAY
45438: AND
45439: IFFALSE 45560
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45441: LD_ADDR_VAR 0 6
45445: PUSH
45446: LD_EXP 80
45450: PUSH
45451: LD_VAR 0 5
45455: ARRAY
45456: PUSH
45457: LD_INT 1
45459: ARRAY
45460: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45461: LD_ADDR_EXP 80
45465: PUSH
45466: LD_EXP 80
45470: PPUSH
45471: LD_VAR 0 5
45475: PPUSH
45476: EMPTY
45477: PPUSH
45478: CALL_OW 1
45482: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45483: LD_VAR 0 6
45487: PPUSH
45488: LD_INT 0
45490: PPUSH
45491: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45495: LD_VAR 0 6
45499: PPUSH
45500: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45504: LD_ADDR_EXP 79
45508: PUSH
45509: LD_EXP 79
45513: PPUSH
45514: LD_VAR 0 5
45518: PPUSH
45519: LD_EXP 79
45523: PUSH
45524: LD_VAR 0 5
45528: ARRAY
45529: PPUSH
45530: LD_INT 1
45532: PPUSH
45533: LD_VAR 0 6
45537: PPUSH
45538: CALL_OW 2
45542: PPUSH
45543: CALL_OW 1
45547: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45548: LD_VAR 0 5
45552: PPUSH
45553: LD_INT 112
45555: PPUSH
45556: CALL 22083 0 2
// end ; end ; end ;
45560: GO 45383
45562: POP
45563: POP
// end ;
45564: LD_VAR 0 3
45568: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45569: LD_INT 0
45571: PPUSH
45572: PPUSH
45573: PPUSH
45574: PPUSH
45575: PPUSH
45576: PPUSH
45577: PPUSH
45578: PPUSH
// if not mc_bases or not skirmish then
45579: LD_EXP 50
45583: NOT
45584: PUSH
45585: LD_EXP 48
45589: NOT
45590: OR
45591: IFFALSE 45595
// exit ;
45593: GO 46966
// for i = 1 to mc_bases do
45595: LD_ADDR_VAR 0 3
45599: PUSH
45600: DOUBLE
45601: LD_INT 1
45603: DEC
45604: ST_TO_ADDR
45605: LD_EXP 50
45609: PUSH
45610: FOR_TO
45611: IFFALSE 46964
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45613: LD_VAR 0 1
45617: PUSH
45618: LD_EXP 50
45622: PUSH
45623: LD_VAR 0 3
45627: ARRAY
45628: IN
45629: PUSH
45630: LD_VAR 0 1
45634: PUSH
45635: LD_EXP 57
45639: PUSH
45640: LD_VAR 0 3
45644: ARRAY
45645: IN
45646: OR
45647: PUSH
45648: LD_VAR 0 1
45652: PUSH
45653: LD_EXP 72
45657: PUSH
45658: LD_VAR 0 3
45662: ARRAY
45663: IN
45664: OR
45665: PUSH
45666: LD_VAR 0 1
45670: PUSH
45671: LD_EXP 69
45675: PUSH
45676: LD_VAR 0 3
45680: ARRAY
45681: IN
45682: OR
45683: PUSH
45684: LD_VAR 0 1
45688: PUSH
45689: LD_EXP 79
45693: PUSH
45694: LD_VAR 0 3
45698: ARRAY
45699: IN
45700: OR
45701: PUSH
45702: LD_VAR 0 1
45706: PUSH
45707: LD_EXP 80
45711: PUSH
45712: LD_VAR 0 3
45716: ARRAY
45717: IN
45718: OR
45719: IFFALSE 46962
// begin if un in mc_ape [ i ] then
45721: LD_VAR 0 1
45725: PUSH
45726: LD_EXP 79
45730: PUSH
45731: LD_VAR 0 3
45735: ARRAY
45736: IN
45737: IFFALSE 45776
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45739: LD_ADDR_EXP 79
45743: PUSH
45744: LD_EXP 79
45748: PPUSH
45749: LD_VAR 0 3
45753: PPUSH
45754: LD_EXP 79
45758: PUSH
45759: LD_VAR 0 3
45763: ARRAY
45764: PUSH
45765: LD_VAR 0 1
45769: DIFF
45770: PPUSH
45771: CALL_OW 1
45775: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45776: LD_VAR 0 1
45780: PUSH
45781: LD_EXP 80
45785: PUSH
45786: LD_VAR 0 3
45790: ARRAY
45791: IN
45792: IFFALSE 45816
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45794: LD_ADDR_EXP 80
45798: PUSH
45799: LD_EXP 80
45803: PPUSH
45804: LD_VAR 0 3
45808: PPUSH
45809: EMPTY
45810: PPUSH
45811: CALL_OW 1
45815: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45816: LD_VAR 0 1
45820: PPUSH
45821: CALL_OW 247
45825: PUSH
45826: LD_INT 2
45828: EQUAL
45829: PUSH
45830: LD_VAR 0 1
45834: PPUSH
45835: CALL_OW 110
45839: PUSH
45840: LD_INT 20
45842: EQUAL
45843: PUSH
45844: LD_VAR 0 1
45848: PUSH
45849: LD_EXP 72
45853: PUSH
45854: LD_VAR 0 3
45858: ARRAY
45859: IN
45860: OR
45861: PUSH
45862: LD_VAR 0 1
45866: PPUSH
45867: CALL_OW 264
45871: PUSH
45872: LD_INT 12
45874: PUSH
45875: LD_INT 51
45877: PUSH
45878: LD_EXP 95
45882: PUSH
45883: LD_INT 32
45885: PUSH
45886: LD_INT 13
45888: PUSH
45889: LD_INT 52
45891: PUSH
45892: LD_INT 31
45894: PUSH
45895: EMPTY
45896: LIST
45897: LIST
45898: LIST
45899: LIST
45900: LIST
45901: LIST
45902: LIST
45903: IN
45904: OR
45905: AND
45906: IFFALSE 46214
// begin if un in mc_defender [ i ] then
45908: LD_VAR 0 1
45912: PUSH
45913: LD_EXP 72
45917: PUSH
45918: LD_VAR 0 3
45922: ARRAY
45923: IN
45924: IFFALSE 45963
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45926: LD_ADDR_EXP 72
45930: PUSH
45931: LD_EXP 72
45935: PPUSH
45936: LD_VAR 0 3
45940: PPUSH
45941: LD_EXP 72
45945: PUSH
45946: LD_VAR 0 3
45950: ARRAY
45951: PUSH
45952: LD_VAR 0 1
45956: DIFF
45957: PPUSH
45958: CALL_OW 1
45962: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
45963: LD_ADDR_VAR 0 8
45967: PUSH
45968: LD_VAR 0 3
45972: PPUSH
45973: LD_INT 3
45975: PPUSH
45976: CALL 42604 0 2
45980: ST_TO_ADDR
// if fac then
45981: LD_VAR 0 8
45985: IFFALSE 46214
// begin for j in fac do
45987: LD_ADDR_VAR 0 4
45991: PUSH
45992: LD_VAR 0 8
45996: PUSH
45997: FOR_IN
45998: IFFALSE 46212
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46000: LD_ADDR_VAR 0 9
46004: PUSH
46005: LD_VAR 0 8
46009: PPUSH
46010: LD_VAR 0 1
46014: PPUSH
46015: CALL_OW 265
46019: PPUSH
46020: LD_VAR 0 1
46024: PPUSH
46025: CALL_OW 262
46029: PPUSH
46030: LD_VAR 0 1
46034: PPUSH
46035: CALL_OW 263
46039: PPUSH
46040: LD_VAR 0 1
46044: PPUSH
46045: CALL_OW 264
46049: PPUSH
46050: CALL 51037 0 5
46054: ST_TO_ADDR
// if components then
46055: LD_VAR 0 9
46059: IFFALSE 46210
// begin if GetWeapon ( un ) = ar_control_tower then
46061: LD_VAR 0 1
46065: PPUSH
46066: CALL_OW 264
46070: PUSH
46071: LD_INT 31
46073: EQUAL
46074: IFFALSE 46191
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46076: LD_VAR 0 1
46080: PPUSH
46081: CALL_OW 311
46085: PPUSH
46086: LD_INT 0
46088: PPUSH
46089: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46093: LD_ADDR_EXP 90
46097: PUSH
46098: LD_EXP 90
46102: PPUSH
46103: LD_VAR 0 3
46107: PPUSH
46108: LD_EXP 90
46112: PUSH
46113: LD_VAR 0 3
46117: ARRAY
46118: PUSH
46119: LD_VAR 0 1
46123: PPUSH
46124: CALL_OW 311
46128: DIFF
46129: PPUSH
46130: CALL_OW 1
46134: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46135: LD_ADDR_VAR 0 7
46139: PUSH
46140: LD_EXP 71
46144: PUSH
46145: LD_VAR 0 3
46149: ARRAY
46150: PPUSH
46151: LD_INT 1
46153: PPUSH
46154: LD_VAR 0 9
46158: PPUSH
46159: CALL_OW 2
46163: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46164: LD_ADDR_EXP 71
46168: PUSH
46169: LD_EXP 71
46173: PPUSH
46174: LD_VAR 0 3
46178: PPUSH
46179: LD_VAR 0 7
46183: PPUSH
46184: CALL_OW 1
46188: ST_TO_ADDR
// end else
46189: GO 46208
// MC_InsertProduceList ( i , [ components ] ) ;
46191: LD_VAR 0 3
46195: PPUSH
46196: LD_VAR 0 9
46200: PUSH
46201: EMPTY
46202: LIST
46203: PPUSH
46204: CALL 42149 0 2
// break ;
46208: GO 46212
// end ; end ;
46210: GO 45997
46212: POP
46213: POP
// end ; end ; if GetType ( un ) = unit_building then
46214: LD_VAR 0 1
46218: PPUSH
46219: CALL_OW 247
46223: PUSH
46224: LD_INT 3
46226: EQUAL
46227: IFFALSE 46630
// begin btype := GetBType ( un ) ;
46229: LD_ADDR_VAR 0 5
46233: PUSH
46234: LD_VAR 0 1
46238: PPUSH
46239: CALL_OW 266
46243: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46244: LD_VAR 0 5
46248: PUSH
46249: LD_INT 29
46251: PUSH
46252: LD_INT 30
46254: PUSH
46255: EMPTY
46256: LIST
46257: LIST
46258: IN
46259: IFFALSE 46332
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46261: LD_VAR 0 1
46265: PPUSH
46266: CALL_OW 250
46270: PPUSH
46271: LD_VAR 0 1
46275: PPUSH
46276: CALL_OW 251
46280: PPUSH
46281: LD_VAR 0 1
46285: PPUSH
46286: CALL_OW 255
46290: PPUSH
46291: CALL_OW 440
46295: NOT
46296: IFFALSE 46332
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46298: LD_VAR 0 1
46302: PPUSH
46303: CALL_OW 250
46307: PPUSH
46308: LD_VAR 0 1
46312: PPUSH
46313: CALL_OW 251
46317: PPUSH
46318: LD_VAR 0 1
46322: PPUSH
46323: CALL_OW 255
46327: PPUSH
46328: CALL_OW 441
// end ; if btype = b_warehouse then
46332: LD_VAR 0 5
46336: PUSH
46337: LD_INT 1
46339: EQUAL
46340: IFFALSE 46358
// begin btype := b_depot ;
46342: LD_ADDR_VAR 0 5
46346: PUSH
46347: LD_INT 0
46349: ST_TO_ADDR
// pos := 1 ;
46350: LD_ADDR_VAR 0 6
46354: PUSH
46355: LD_INT 1
46357: ST_TO_ADDR
// end ; if btype = b_factory then
46358: LD_VAR 0 5
46362: PUSH
46363: LD_INT 3
46365: EQUAL
46366: IFFALSE 46384
// begin btype := b_workshop ;
46368: LD_ADDR_VAR 0 5
46372: PUSH
46373: LD_INT 2
46375: ST_TO_ADDR
// pos := 1 ;
46376: LD_ADDR_VAR 0 6
46380: PUSH
46381: LD_INT 1
46383: ST_TO_ADDR
// end ; if btype = b_barracks then
46384: LD_VAR 0 5
46388: PUSH
46389: LD_INT 5
46391: EQUAL
46392: IFFALSE 46402
// btype := b_armoury ;
46394: LD_ADDR_VAR 0 5
46398: PUSH
46399: LD_INT 4
46401: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46402: LD_VAR 0 5
46406: PUSH
46407: LD_INT 7
46409: PUSH
46410: LD_INT 8
46412: PUSH
46413: EMPTY
46414: LIST
46415: LIST
46416: IN
46417: IFFALSE 46427
// btype := b_lab ;
46419: LD_ADDR_VAR 0 5
46423: PUSH
46424: LD_INT 6
46426: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46427: LD_ADDR_EXP 55
46431: PUSH
46432: LD_EXP 55
46436: PPUSH
46437: LD_VAR 0 3
46441: PUSH
46442: LD_EXP 55
46446: PUSH
46447: LD_VAR 0 3
46451: ARRAY
46452: PUSH
46453: LD_INT 1
46455: PLUS
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: PPUSH
46461: LD_VAR 0 5
46465: PUSH
46466: LD_VAR 0 1
46470: PPUSH
46471: CALL_OW 250
46475: PUSH
46476: LD_VAR 0 1
46480: PPUSH
46481: CALL_OW 251
46485: PUSH
46486: LD_VAR 0 1
46490: PPUSH
46491: CALL_OW 254
46495: PUSH
46496: EMPTY
46497: LIST
46498: LIST
46499: LIST
46500: LIST
46501: PPUSH
46502: CALL 53541 0 3
46506: ST_TO_ADDR
// if pos = 1 then
46507: LD_VAR 0 6
46511: PUSH
46512: LD_INT 1
46514: EQUAL
46515: IFFALSE 46630
// begin tmp := mc_build_list [ i ] ;
46517: LD_ADDR_VAR 0 7
46521: PUSH
46522: LD_EXP 55
46526: PUSH
46527: LD_VAR 0 3
46531: ARRAY
46532: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46533: LD_VAR 0 7
46537: PPUSH
46538: LD_INT 2
46540: PUSH
46541: LD_INT 30
46543: PUSH
46544: LD_INT 0
46546: PUSH
46547: EMPTY
46548: LIST
46549: LIST
46550: PUSH
46551: LD_INT 30
46553: PUSH
46554: LD_INT 1
46556: PUSH
46557: EMPTY
46558: LIST
46559: LIST
46560: PUSH
46561: EMPTY
46562: LIST
46563: LIST
46564: LIST
46565: PPUSH
46566: CALL_OW 72
46570: IFFALSE 46580
// pos := 2 ;
46572: LD_ADDR_VAR 0 6
46576: PUSH
46577: LD_INT 2
46579: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46580: LD_ADDR_VAR 0 7
46584: PUSH
46585: LD_VAR 0 7
46589: PPUSH
46590: LD_VAR 0 6
46594: PPUSH
46595: LD_VAR 0 7
46599: PPUSH
46600: CALL 53867 0 3
46604: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46605: LD_ADDR_EXP 55
46609: PUSH
46610: LD_EXP 55
46614: PPUSH
46615: LD_VAR 0 3
46619: PPUSH
46620: LD_VAR 0 7
46624: PPUSH
46625: CALL_OW 1
46629: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46630: LD_VAR 0 1
46634: PUSH
46635: LD_EXP 50
46639: PUSH
46640: LD_VAR 0 3
46644: ARRAY
46645: IN
46646: IFFALSE 46685
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46648: LD_ADDR_EXP 50
46652: PUSH
46653: LD_EXP 50
46657: PPUSH
46658: LD_VAR 0 3
46662: PPUSH
46663: LD_EXP 50
46667: PUSH
46668: LD_VAR 0 3
46672: ARRAY
46673: PUSH
46674: LD_VAR 0 1
46678: DIFF
46679: PPUSH
46680: CALL_OW 1
46684: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46685: LD_VAR 0 1
46689: PUSH
46690: LD_EXP 57
46694: PUSH
46695: LD_VAR 0 3
46699: ARRAY
46700: IN
46701: IFFALSE 46740
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46703: LD_ADDR_EXP 57
46707: PUSH
46708: LD_EXP 57
46712: PPUSH
46713: LD_VAR 0 3
46717: PPUSH
46718: LD_EXP 57
46722: PUSH
46723: LD_VAR 0 3
46727: ARRAY
46728: PUSH
46729: LD_VAR 0 1
46733: DIFF
46734: PPUSH
46735: CALL_OW 1
46739: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46740: LD_VAR 0 1
46744: PUSH
46745: LD_EXP 69
46749: PUSH
46750: LD_VAR 0 3
46754: ARRAY
46755: IN
46756: IFFALSE 46795
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46758: LD_ADDR_EXP 69
46762: PUSH
46763: LD_EXP 69
46767: PPUSH
46768: LD_VAR 0 3
46772: PPUSH
46773: LD_EXP 69
46777: PUSH
46778: LD_VAR 0 3
46782: ARRAY
46783: PUSH
46784: LD_VAR 0 1
46788: DIFF
46789: PPUSH
46790: CALL_OW 1
46794: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46795: LD_VAR 0 1
46799: PUSH
46800: LD_EXP 72
46804: PUSH
46805: LD_VAR 0 3
46809: ARRAY
46810: IN
46811: IFFALSE 46850
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46813: LD_ADDR_EXP 72
46817: PUSH
46818: LD_EXP 72
46822: PPUSH
46823: LD_VAR 0 3
46827: PPUSH
46828: LD_EXP 72
46832: PUSH
46833: LD_VAR 0 3
46837: ARRAY
46838: PUSH
46839: LD_VAR 0 1
46843: DIFF
46844: PPUSH
46845: CALL_OW 1
46849: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46850: LD_VAR 0 1
46854: PUSH
46855: LD_EXP 59
46859: PUSH
46860: LD_VAR 0 3
46864: ARRAY
46865: IN
46866: IFFALSE 46905
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46868: LD_ADDR_EXP 59
46872: PUSH
46873: LD_EXP 59
46877: PPUSH
46878: LD_VAR 0 3
46882: PPUSH
46883: LD_EXP 59
46887: PUSH
46888: LD_VAR 0 3
46892: ARRAY
46893: PUSH
46894: LD_VAR 0 1
46898: DIFF
46899: PPUSH
46900: CALL_OW 1
46904: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46905: LD_VAR 0 1
46909: PUSH
46910: LD_EXP 58
46914: PUSH
46915: LD_VAR 0 3
46919: ARRAY
46920: IN
46921: IFFALSE 46960
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
46923: LD_ADDR_EXP 58
46927: PUSH
46928: LD_EXP 58
46932: PPUSH
46933: LD_VAR 0 3
46937: PPUSH
46938: LD_EXP 58
46942: PUSH
46943: LD_VAR 0 3
46947: ARRAY
46948: PUSH
46949: LD_VAR 0 1
46953: DIFF
46954: PPUSH
46955: CALL_OW 1
46959: ST_TO_ADDR
// end ; break ;
46960: GO 46964
// end ;
46962: GO 45610
46964: POP
46965: POP
// end ;
46966: LD_VAR 0 2
46970: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
46971: LD_INT 0
46973: PPUSH
46974: PPUSH
46975: PPUSH
// if not mc_bases or not skirmish then
46976: LD_EXP 50
46980: NOT
46981: PUSH
46982: LD_EXP 48
46986: NOT
46987: OR
46988: IFFALSE 46992
// exit ;
46990: GO 47207
// for i = 1 to mc_bases do
46992: LD_ADDR_VAR 0 3
46996: PUSH
46997: DOUBLE
46998: LD_INT 1
47000: DEC
47001: ST_TO_ADDR
47002: LD_EXP 50
47006: PUSH
47007: FOR_TO
47008: IFFALSE 47205
// begin if building in mc_construct_list [ i ] then
47010: LD_VAR 0 1
47014: PUSH
47015: LD_EXP 57
47019: PUSH
47020: LD_VAR 0 3
47024: ARRAY
47025: IN
47026: IFFALSE 47203
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47028: LD_ADDR_EXP 57
47032: PUSH
47033: LD_EXP 57
47037: PPUSH
47038: LD_VAR 0 3
47042: PPUSH
47043: LD_EXP 57
47047: PUSH
47048: LD_VAR 0 3
47052: ARRAY
47053: PUSH
47054: LD_VAR 0 1
47058: DIFF
47059: PPUSH
47060: CALL_OW 1
47064: ST_TO_ADDR
// if building in mc_lab [ i ] then
47065: LD_VAR 0 1
47069: PUSH
47070: LD_EXP 83
47074: PUSH
47075: LD_VAR 0 3
47079: ARRAY
47080: IN
47081: IFFALSE 47136
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47083: LD_ADDR_EXP 84
47087: PUSH
47088: LD_EXP 84
47092: PPUSH
47093: LD_VAR 0 3
47097: PPUSH
47098: LD_EXP 84
47102: PUSH
47103: LD_VAR 0 3
47107: ARRAY
47108: PPUSH
47109: LD_INT 1
47111: PPUSH
47112: LD_EXP 84
47116: PUSH
47117: LD_VAR 0 3
47121: ARRAY
47122: PPUSH
47123: LD_INT 0
47125: PPUSH
47126: CALL 52959 0 4
47130: PPUSH
47131: CALL_OW 1
47135: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47136: LD_VAR 0 1
47140: PUSH
47141: LD_EXP 50
47145: PUSH
47146: LD_VAR 0 3
47150: ARRAY
47151: IN
47152: NOT
47153: IFFALSE 47199
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47155: LD_ADDR_EXP 50
47159: PUSH
47160: LD_EXP 50
47164: PPUSH
47165: LD_VAR 0 3
47169: PUSH
47170: LD_EXP 50
47174: PUSH
47175: LD_VAR 0 3
47179: ARRAY
47180: PUSH
47181: LD_INT 1
47183: PLUS
47184: PUSH
47185: EMPTY
47186: LIST
47187: LIST
47188: PPUSH
47189: LD_VAR 0 1
47193: PPUSH
47194: CALL 53541 0 3
47198: ST_TO_ADDR
// exit ;
47199: POP
47200: POP
47201: GO 47207
// end ; end ;
47203: GO 47007
47205: POP
47206: POP
// end ;
47207: LD_VAR 0 2
47211: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47212: LD_INT 0
47214: PPUSH
47215: PPUSH
47216: PPUSH
47217: PPUSH
47218: PPUSH
47219: PPUSH
47220: PPUSH
// if not mc_bases or not skirmish then
47221: LD_EXP 50
47225: NOT
47226: PUSH
47227: LD_EXP 48
47231: NOT
47232: OR
47233: IFFALSE 47237
// exit ;
47235: GO 47898
// for i = 1 to mc_bases do
47237: LD_ADDR_VAR 0 3
47241: PUSH
47242: DOUBLE
47243: LD_INT 1
47245: DEC
47246: ST_TO_ADDR
47247: LD_EXP 50
47251: PUSH
47252: FOR_TO
47253: IFFALSE 47896
// begin if building in mc_construct_list [ i ] then
47255: LD_VAR 0 1
47259: PUSH
47260: LD_EXP 57
47264: PUSH
47265: LD_VAR 0 3
47269: ARRAY
47270: IN
47271: IFFALSE 47894
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47273: LD_ADDR_EXP 57
47277: PUSH
47278: LD_EXP 57
47282: PPUSH
47283: LD_VAR 0 3
47287: PPUSH
47288: LD_EXP 57
47292: PUSH
47293: LD_VAR 0 3
47297: ARRAY
47298: PUSH
47299: LD_VAR 0 1
47303: DIFF
47304: PPUSH
47305: CALL_OW 1
47309: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47310: LD_ADDR_EXP 50
47314: PUSH
47315: LD_EXP 50
47319: PPUSH
47320: LD_VAR 0 3
47324: PUSH
47325: LD_EXP 50
47329: PUSH
47330: LD_VAR 0 3
47334: ARRAY
47335: PUSH
47336: LD_INT 1
47338: PLUS
47339: PUSH
47340: EMPTY
47341: LIST
47342: LIST
47343: PPUSH
47344: LD_VAR 0 1
47348: PPUSH
47349: CALL 53541 0 3
47353: ST_TO_ADDR
// btype := GetBType ( building ) ;
47354: LD_ADDR_VAR 0 5
47358: PUSH
47359: LD_VAR 0 1
47363: PPUSH
47364: CALL_OW 266
47368: ST_TO_ADDR
// side := GetSide ( building ) ;
47369: LD_ADDR_VAR 0 8
47373: PUSH
47374: LD_VAR 0 1
47378: PPUSH
47379: CALL_OW 255
47383: ST_TO_ADDR
// if btype = b_lab then
47384: LD_VAR 0 5
47388: PUSH
47389: LD_INT 6
47391: EQUAL
47392: IFFALSE 47442
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47394: LD_ADDR_EXP 83
47398: PUSH
47399: LD_EXP 83
47403: PPUSH
47404: LD_VAR 0 3
47408: PUSH
47409: LD_EXP 83
47413: PUSH
47414: LD_VAR 0 3
47418: ARRAY
47419: PUSH
47420: LD_INT 1
47422: PLUS
47423: PUSH
47424: EMPTY
47425: LIST
47426: LIST
47427: PPUSH
47428: LD_VAR 0 1
47432: PPUSH
47433: CALL 53541 0 3
47437: ST_TO_ADDR
// exit ;
47438: POP
47439: POP
47440: GO 47898
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47442: LD_VAR 0 5
47446: PUSH
47447: LD_INT 0
47449: PUSH
47450: LD_INT 2
47452: PUSH
47453: LD_INT 4
47455: PUSH
47456: EMPTY
47457: LIST
47458: LIST
47459: LIST
47460: IN
47461: IFFALSE 47585
// begin if btype = b_armoury then
47463: LD_VAR 0 5
47467: PUSH
47468: LD_INT 4
47470: EQUAL
47471: IFFALSE 47481
// btype := b_barracks ;
47473: LD_ADDR_VAR 0 5
47477: PUSH
47478: LD_INT 5
47480: ST_TO_ADDR
// if btype = b_depot then
47481: LD_VAR 0 5
47485: PUSH
47486: LD_INT 0
47488: EQUAL
47489: IFFALSE 47499
// btype := b_warehouse ;
47491: LD_ADDR_VAR 0 5
47495: PUSH
47496: LD_INT 1
47498: ST_TO_ADDR
// if btype = b_workshop then
47499: LD_VAR 0 5
47503: PUSH
47504: LD_INT 2
47506: EQUAL
47507: IFFALSE 47517
// btype := b_factory ;
47509: LD_ADDR_VAR 0 5
47513: PUSH
47514: LD_INT 3
47516: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47517: LD_VAR 0 5
47521: PPUSH
47522: LD_VAR 0 8
47526: PPUSH
47527: CALL_OW 323
47531: PUSH
47532: LD_INT 1
47534: EQUAL
47535: IFFALSE 47581
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47537: LD_ADDR_EXP 82
47541: PUSH
47542: LD_EXP 82
47546: PPUSH
47547: LD_VAR 0 3
47551: PUSH
47552: LD_EXP 82
47556: PUSH
47557: LD_VAR 0 3
47561: ARRAY
47562: PUSH
47563: LD_INT 1
47565: PLUS
47566: PUSH
47567: EMPTY
47568: LIST
47569: LIST
47570: PPUSH
47571: LD_VAR 0 1
47575: PPUSH
47576: CALL 53541 0 3
47580: ST_TO_ADDR
// exit ;
47581: POP
47582: POP
47583: GO 47898
// end ; if btype in [ b_bunker , b_turret ] then
47585: LD_VAR 0 5
47589: PUSH
47590: LD_INT 32
47592: PUSH
47593: LD_INT 33
47595: PUSH
47596: EMPTY
47597: LIST
47598: LIST
47599: IN
47600: IFFALSE 47890
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47602: LD_ADDR_EXP 58
47606: PUSH
47607: LD_EXP 58
47611: PPUSH
47612: LD_VAR 0 3
47616: PUSH
47617: LD_EXP 58
47621: PUSH
47622: LD_VAR 0 3
47626: ARRAY
47627: PUSH
47628: LD_INT 1
47630: PLUS
47631: PUSH
47632: EMPTY
47633: LIST
47634: LIST
47635: PPUSH
47636: LD_VAR 0 1
47640: PPUSH
47641: CALL 53541 0 3
47645: ST_TO_ADDR
// if btype = b_bunker then
47646: LD_VAR 0 5
47650: PUSH
47651: LD_INT 32
47653: EQUAL
47654: IFFALSE 47890
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47656: LD_ADDR_EXP 59
47660: PUSH
47661: LD_EXP 59
47665: PPUSH
47666: LD_VAR 0 3
47670: PUSH
47671: LD_EXP 59
47675: PUSH
47676: LD_VAR 0 3
47680: ARRAY
47681: PUSH
47682: LD_INT 1
47684: PLUS
47685: PUSH
47686: EMPTY
47687: LIST
47688: LIST
47689: PPUSH
47690: LD_VAR 0 1
47694: PPUSH
47695: CALL 53541 0 3
47699: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47700: LD_ADDR_VAR 0 6
47704: PUSH
47705: LD_EXP 50
47709: PUSH
47710: LD_VAR 0 3
47714: ARRAY
47715: PPUSH
47716: LD_INT 25
47718: PUSH
47719: LD_INT 1
47721: PUSH
47722: EMPTY
47723: LIST
47724: LIST
47725: PUSH
47726: LD_INT 3
47728: PUSH
47729: LD_INT 54
47731: PUSH
47732: EMPTY
47733: LIST
47734: PUSH
47735: EMPTY
47736: LIST
47737: LIST
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PPUSH
47743: CALL_OW 72
47747: ST_TO_ADDR
// if tmp then
47748: LD_VAR 0 6
47752: IFFALSE 47758
// exit ;
47754: POP
47755: POP
47756: GO 47898
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47758: LD_ADDR_VAR 0 6
47762: PUSH
47763: LD_EXP 50
47767: PUSH
47768: LD_VAR 0 3
47772: ARRAY
47773: PPUSH
47774: LD_INT 2
47776: PUSH
47777: LD_INT 30
47779: PUSH
47780: LD_INT 4
47782: PUSH
47783: EMPTY
47784: LIST
47785: LIST
47786: PUSH
47787: LD_INT 30
47789: PUSH
47790: LD_INT 5
47792: PUSH
47793: EMPTY
47794: LIST
47795: LIST
47796: PUSH
47797: EMPTY
47798: LIST
47799: LIST
47800: LIST
47801: PPUSH
47802: CALL_OW 72
47806: ST_TO_ADDR
// if not tmp then
47807: LD_VAR 0 6
47811: NOT
47812: IFFALSE 47818
// exit ;
47814: POP
47815: POP
47816: GO 47898
// for j in tmp do
47818: LD_ADDR_VAR 0 4
47822: PUSH
47823: LD_VAR 0 6
47827: PUSH
47828: FOR_IN
47829: IFFALSE 47888
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47831: LD_ADDR_VAR 0 7
47835: PUSH
47836: LD_VAR 0 4
47840: PPUSH
47841: CALL_OW 313
47845: PPUSH
47846: LD_INT 25
47848: PUSH
47849: LD_INT 1
47851: PUSH
47852: EMPTY
47853: LIST
47854: LIST
47855: PPUSH
47856: CALL_OW 72
47860: ST_TO_ADDR
// if units then
47861: LD_VAR 0 7
47865: IFFALSE 47886
// begin ComExitBuilding ( units [ 1 ] ) ;
47867: LD_VAR 0 7
47871: PUSH
47872: LD_INT 1
47874: ARRAY
47875: PPUSH
47876: CALL_OW 122
// exit ;
47880: POP
47881: POP
47882: POP
47883: POP
47884: GO 47898
// end ; end ;
47886: GO 47828
47888: POP
47889: POP
// end ; end ; exit ;
47890: POP
47891: POP
47892: GO 47898
// end ; end ;
47894: GO 47252
47896: POP
47897: POP
// end ;
47898: LD_VAR 0 2
47902: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47903: LD_INT 0
47905: PPUSH
47906: PPUSH
47907: PPUSH
47908: PPUSH
47909: PPUSH
47910: PPUSH
47911: PPUSH
// if not mc_bases or not skirmish then
47912: LD_EXP 50
47916: NOT
47917: PUSH
47918: LD_EXP 48
47922: NOT
47923: OR
47924: IFFALSE 47928
// exit ;
47926: GO 48193
// btype := GetBType ( building ) ;
47928: LD_ADDR_VAR 0 6
47932: PUSH
47933: LD_VAR 0 1
47937: PPUSH
47938: CALL_OW 266
47942: ST_TO_ADDR
// x := GetX ( building ) ;
47943: LD_ADDR_VAR 0 7
47947: PUSH
47948: LD_VAR 0 1
47952: PPUSH
47953: CALL_OW 250
47957: ST_TO_ADDR
// y := GetY ( building ) ;
47958: LD_ADDR_VAR 0 8
47962: PUSH
47963: LD_VAR 0 1
47967: PPUSH
47968: CALL_OW 251
47972: ST_TO_ADDR
// d := GetDir ( building ) ;
47973: LD_ADDR_VAR 0 9
47977: PUSH
47978: LD_VAR 0 1
47982: PPUSH
47983: CALL_OW 254
47987: ST_TO_ADDR
// for i = 1 to mc_bases do
47988: LD_ADDR_VAR 0 4
47992: PUSH
47993: DOUBLE
47994: LD_INT 1
47996: DEC
47997: ST_TO_ADDR
47998: LD_EXP 50
48002: PUSH
48003: FOR_TO
48004: IFFALSE 48191
// begin if not mc_build_list [ i ] then
48006: LD_EXP 55
48010: PUSH
48011: LD_VAR 0 4
48015: ARRAY
48016: NOT
48017: IFFALSE 48021
// continue ;
48019: GO 48003
// for j := 1 to mc_build_list [ i ] do
48021: LD_ADDR_VAR 0 5
48025: PUSH
48026: DOUBLE
48027: LD_INT 1
48029: DEC
48030: ST_TO_ADDR
48031: LD_EXP 55
48035: PUSH
48036: LD_VAR 0 4
48040: ARRAY
48041: PUSH
48042: FOR_TO
48043: IFFALSE 48187
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48045: LD_VAR 0 6
48049: PUSH
48050: LD_VAR 0 7
48054: PUSH
48055: LD_VAR 0 8
48059: PUSH
48060: LD_VAR 0 9
48064: PUSH
48065: EMPTY
48066: LIST
48067: LIST
48068: LIST
48069: LIST
48070: PPUSH
48071: LD_EXP 55
48075: PUSH
48076: LD_VAR 0 4
48080: ARRAY
48081: PUSH
48082: LD_VAR 0 5
48086: ARRAY
48087: PPUSH
48088: CALL 59723 0 2
48092: IFFALSE 48185
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48094: LD_ADDR_EXP 55
48098: PUSH
48099: LD_EXP 55
48103: PPUSH
48104: LD_VAR 0 4
48108: PPUSH
48109: LD_EXP 55
48113: PUSH
48114: LD_VAR 0 4
48118: ARRAY
48119: PPUSH
48120: LD_VAR 0 5
48124: PPUSH
48125: CALL_OW 3
48129: PPUSH
48130: CALL_OW 1
48134: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48135: LD_ADDR_EXP 57
48139: PUSH
48140: LD_EXP 57
48144: PPUSH
48145: LD_VAR 0 4
48149: PUSH
48150: LD_EXP 57
48154: PUSH
48155: LD_VAR 0 4
48159: ARRAY
48160: PUSH
48161: LD_INT 1
48163: PLUS
48164: PUSH
48165: EMPTY
48166: LIST
48167: LIST
48168: PPUSH
48169: LD_VAR 0 1
48173: PPUSH
48174: CALL 53541 0 3
48178: ST_TO_ADDR
// exit ;
48179: POP
48180: POP
48181: POP
48182: POP
48183: GO 48193
// end ;
48185: GO 48042
48187: POP
48188: POP
// end ;
48189: GO 48003
48191: POP
48192: POP
// end ;
48193: LD_VAR 0 3
48197: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48198: LD_INT 0
48200: PPUSH
48201: PPUSH
48202: PPUSH
// if not mc_bases or not skirmish then
48203: LD_EXP 50
48207: NOT
48208: PUSH
48209: LD_EXP 48
48213: NOT
48214: OR
48215: IFFALSE 48219
// exit ;
48217: GO 48409
// for i = 1 to mc_bases do
48219: LD_ADDR_VAR 0 4
48223: PUSH
48224: DOUBLE
48225: LD_INT 1
48227: DEC
48228: ST_TO_ADDR
48229: LD_EXP 50
48233: PUSH
48234: FOR_TO
48235: IFFALSE 48322
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48237: LD_VAR 0 1
48241: PUSH
48242: LD_EXP 58
48246: PUSH
48247: LD_VAR 0 4
48251: ARRAY
48252: IN
48253: PUSH
48254: LD_VAR 0 1
48258: PUSH
48259: LD_EXP 59
48263: PUSH
48264: LD_VAR 0 4
48268: ARRAY
48269: IN
48270: NOT
48271: AND
48272: IFFALSE 48320
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48274: LD_ADDR_EXP 59
48278: PUSH
48279: LD_EXP 59
48283: PPUSH
48284: LD_VAR 0 4
48288: PUSH
48289: LD_EXP 59
48293: PUSH
48294: LD_VAR 0 4
48298: ARRAY
48299: PUSH
48300: LD_INT 1
48302: PLUS
48303: PUSH
48304: EMPTY
48305: LIST
48306: LIST
48307: PPUSH
48308: LD_VAR 0 1
48312: PPUSH
48313: CALL 53541 0 3
48317: ST_TO_ADDR
// break ;
48318: GO 48322
// end ; end ;
48320: GO 48234
48322: POP
48323: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48324: LD_VAR 0 1
48328: PPUSH
48329: CALL_OW 257
48333: PUSH
48334: LD_EXP 76
48338: IN
48339: PUSH
48340: LD_VAR 0 1
48344: PPUSH
48345: CALL_OW 266
48349: PUSH
48350: LD_INT 5
48352: EQUAL
48353: AND
48354: PUSH
48355: LD_VAR 0 2
48359: PPUSH
48360: CALL_OW 110
48364: PUSH
48365: LD_INT 18
48367: NONEQUAL
48368: AND
48369: IFFALSE 48409
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48371: LD_VAR 0 2
48375: PPUSH
48376: CALL_OW 257
48380: PUSH
48381: LD_INT 5
48383: PUSH
48384: LD_INT 8
48386: PUSH
48387: LD_INT 9
48389: PUSH
48390: EMPTY
48391: LIST
48392: LIST
48393: LIST
48394: IN
48395: IFFALSE 48409
// SetClass ( unit , 1 ) ;
48397: LD_VAR 0 2
48401: PPUSH
48402: LD_INT 1
48404: PPUSH
48405: CALL_OW 336
// end ;
48409: LD_VAR 0 3
48413: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48414: LD_INT 0
48416: PPUSH
48417: PPUSH
// if not mc_bases or not skirmish then
48418: LD_EXP 50
48422: NOT
48423: PUSH
48424: LD_EXP 48
48428: NOT
48429: OR
48430: IFFALSE 48434
// exit ;
48432: GO 48550
// if GetLives ( abandoned_vehicle ) > 250 then
48434: LD_VAR 0 2
48438: PPUSH
48439: CALL_OW 256
48443: PUSH
48444: LD_INT 250
48446: GREATER
48447: IFFALSE 48451
// exit ;
48449: GO 48550
// for i = 1 to mc_bases do
48451: LD_ADDR_VAR 0 6
48455: PUSH
48456: DOUBLE
48457: LD_INT 1
48459: DEC
48460: ST_TO_ADDR
48461: LD_EXP 50
48465: PUSH
48466: FOR_TO
48467: IFFALSE 48548
// begin if driver in mc_bases [ i ] then
48469: LD_VAR 0 1
48473: PUSH
48474: LD_EXP 50
48478: PUSH
48479: LD_VAR 0 6
48483: ARRAY
48484: IN
48485: IFFALSE 48546
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48487: LD_VAR 0 1
48491: PPUSH
48492: LD_EXP 50
48496: PUSH
48497: LD_VAR 0 6
48501: ARRAY
48502: PPUSH
48503: LD_INT 2
48505: PUSH
48506: LD_INT 30
48508: PUSH
48509: LD_INT 0
48511: PUSH
48512: EMPTY
48513: LIST
48514: LIST
48515: PUSH
48516: LD_INT 30
48518: PUSH
48519: LD_INT 1
48521: PUSH
48522: EMPTY
48523: LIST
48524: LIST
48525: PUSH
48526: EMPTY
48527: LIST
48528: LIST
48529: LIST
48530: PPUSH
48531: CALL_OW 72
48535: PUSH
48536: LD_INT 1
48538: ARRAY
48539: PPUSH
48540: CALL 86159 0 2
// break ;
48544: GO 48548
// end ; end ;
48546: GO 48466
48548: POP
48549: POP
// end ; end_of_file
48550: LD_VAR 0 5
48554: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48555: LD_INT 0
48557: PPUSH
48558: PPUSH
// if exist_mode then
48559: LD_VAR 0 2
48563: IFFALSE 48588
// unit := CreateCharacter ( prefix & ident ) else
48565: LD_ADDR_VAR 0 5
48569: PUSH
48570: LD_VAR 0 3
48574: PUSH
48575: LD_VAR 0 1
48579: STR
48580: PPUSH
48581: CALL_OW 34
48585: ST_TO_ADDR
48586: GO 48603
// unit := NewCharacter ( ident ) ;
48588: LD_ADDR_VAR 0 5
48592: PUSH
48593: LD_VAR 0 1
48597: PPUSH
48598: CALL_OW 25
48602: ST_TO_ADDR
// result := unit ;
48603: LD_ADDR_VAR 0 4
48607: PUSH
48608: LD_VAR 0 5
48612: ST_TO_ADDR
// end ;
48613: LD_VAR 0 4
48617: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48618: LD_INT 0
48620: PPUSH
48621: PPUSH
// if not side or not nation then
48622: LD_VAR 0 1
48626: NOT
48627: PUSH
48628: LD_VAR 0 2
48632: NOT
48633: OR
48634: IFFALSE 48638
// exit ;
48636: GO 49406
// case nation of nation_american :
48638: LD_VAR 0 2
48642: PUSH
48643: LD_INT 1
48645: DOUBLE
48646: EQUAL
48647: IFTRUE 48651
48649: GO 48865
48651: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48652: LD_ADDR_VAR 0 4
48656: PUSH
48657: LD_INT 35
48659: PUSH
48660: LD_INT 45
48662: PUSH
48663: LD_INT 46
48665: PUSH
48666: LD_INT 47
48668: PUSH
48669: LD_INT 82
48671: PUSH
48672: LD_INT 83
48674: PUSH
48675: LD_INT 84
48677: PUSH
48678: LD_INT 85
48680: PUSH
48681: LD_INT 86
48683: PUSH
48684: LD_INT 1
48686: PUSH
48687: LD_INT 2
48689: PUSH
48690: LD_INT 6
48692: PUSH
48693: LD_INT 15
48695: PUSH
48696: LD_INT 16
48698: PUSH
48699: LD_INT 7
48701: PUSH
48702: LD_INT 12
48704: PUSH
48705: LD_INT 13
48707: PUSH
48708: LD_INT 10
48710: PUSH
48711: LD_INT 14
48713: PUSH
48714: LD_INT 20
48716: PUSH
48717: LD_INT 21
48719: PUSH
48720: LD_INT 22
48722: PUSH
48723: LD_INT 25
48725: PUSH
48726: LD_INT 32
48728: PUSH
48729: LD_INT 27
48731: PUSH
48732: LD_INT 36
48734: PUSH
48735: LD_INT 69
48737: PUSH
48738: LD_INT 39
48740: PUSH
48741: LD_INT 34
48743: PUSH
48744: LD_INT 40
48746: PUSH
48747: LD_INT 48
48749: PUSH
48750: LD_INT 49
48752: PUSH
48753: LD_INT 50
48755: PUSH
48756: LD_INT 51
48758: PUSH
48759: LD_INT 52
48761: PUSH
48762: LD_INT 53
48764: PUSH
48765: LD_INT 54
48767: PUSH
48768: LD_INT 55
48770: PUSH
48771: LD_INT 56
48773: PUSH
48774: LD_INT 57
48776: PUSH
48777: LD_INT 58
48779: PUSH
48780: LD_INT 59
48782: PUSH
48783: LD_INT 60
48785: PUSH
48786: LD_INT 61
48788: PUSH
48789: LD_INT 62
48791: PUSH
48792: LD_INT 80
48794: PUSH
48795: LD_INT 82
48797: PUSH
48798: LD_INT 83
48800: PUSH
48801: LD_INT 84
48803: PUSH
48804: LD_INT 85
48806: PUSH
48807: LD_INT 86
48809: PUSH
48810: EMPTY
48811: LIST
48812: LIST
48813: LIST
48814: LIST
48815: LIST
48816: LIST
48817: LIST
48818: LIST
48819: LIST
48820: LIST
48821: LIST
48822: LIST
48823: LIST
48824: LIST
48825: LIST
48826: LIST
48827: LIST
48828: LIST
48829: LIST
48830: LIST
48831: LIST
48832: LIST
48833: LIST
48834: LIST
48835: LIST
48836: LIST
48837: LIST
48838: LIST
48839: LIST
48840: LIST
48841: LIST
48842: LIST
48843: LIST
48844: LIST
48845: LIST
48846: LIST
48847: LIST
48848: LIST
48849: LIST
48850: LIST
48851: LIST
48852: LIST
48853: LIST
48854: LIST
48855: LIST
48856: LIST
48857: LIST
48858: LIST
48859: LIST
48860: LIST
48861: LIST
48862: ST_TO_ADDR
48863: GO 49330
48865: LD_INT 2
48867: DOUBLE
48868: EQUAL
48869: IFTRUE 48873
48871: GO 49099
48873: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
48874: LD_ADDR_VAR 0 4
48878: PUSH
48879: LD_INT 35
48881: PUSH
48882: LD_INT 45
48884: PUSH
48885: LD_INT 46
48887: PUSH
48888: LD_INT 47
48890: PUSH
48891: LD_INT 82
48893: PUSH
48894: LD_INT 83
48896: PUSH
48897: LD_INT 84
48899: PUSH
48900: LD_INT 85
48902: PUSH
48903: LD_INT 87
48905: PUSH
48906: LD_INT 70
48908: PUSH
48909: LD_INT 1
48911: PUSH
48912: LD_INT 11
48914: PUSH
48915: LD_INT 3
48917: PUSH
48918: LD_INT 4
48920: PUSH
48921: LD_INT 5
48923: PUSH
48924: LD_INT 6
48926: PUSH
48927: LD_INT 15
48929: PUSH
48930: LD_INT 18
48932: PUSH
48933: LD_INT 7
48935: PUSH
48936: LD_INT 17
48938: PUSH
48939: LD_INT 8
48941: PUSH
48942: LD_INT 20
48944: PUSH
48945: LD_INT 21
48947: PUSH
48948: LD_INT 22
48950: PUSH
48951: LD_INT 72
48953: PUSH
48954: LD_INT 26
48956: PUSH
48957: LD_INT 69
48959: PUSH
48960: LD_INT 39
48962: PUSH
48963: LD_INT 40
48965: PUSH
48966: LD_INT 41
48968: PUSH
48969: LD_INT 42
48971: PUSH
48972: LD_INT 43
48974: PUSH
48975: LD_INT 48
48977: PUSH
48978: LD_INT 49
48980: PUSH
48981: LD_INT 50
48983: PUSH
48984: LD_INT 51
48986: PUSH
48987: LD_INT 52
48989: PUSH
48990: LD_INT 53
48992: PUSH
48993: LD_INT 54
48995: PUSH
48996: LD_INT 55
48998: PUSH
48999: LD_INT 56
49001: PUSH
49002: LD_INT 60
49004: PUSH
49005: LD_INT 61
49007: PUSH
49008: LD_INT 62
49010: PUSH
49011: LD_INT 66
49013: PUSH
49014: LD_INT 67
49016: PUSH
49017: LD_INT 68
49019: PUSH
49020: LD_INT 81
49022: PUSH
49023: LD_INT 82
49025: PUSH
49026: LD_INT 83
49028: PUSH
49029: LD_INT 84
49031: PUSH
49032: LD_INT 85
49034: PUSH
49035: LD_INT 87
49037: PUSH
49038: LD_INT 88
49040: PUSH
49041: EMPTY
49042: LIST
49043: LIST
49044: LIST
49045: LIST
49046: LIST
49047: LIST
49048: LIST
49049: LIST
49050: LIST
49051: LIST
49052: LIST
49053: LIST
49054: LIST
49055: LIST
49056: LIST
49057: LIST
49058: LIST
49059: LIST
49060: LIST
49061: LIST
49062: LIST
49063: LIST
49064: LIST
49065: LIST
49066: LIST
49067: LIST
49068: LIST
49069: LIST
49070: LIST
49071: LIST
49072: LIST
49073: LIST
49074: LIST
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: ST_TO_ADDR
49097: GO 49330
49099: LD_INT 3
49101: DOUBLE
49102: EQUAL
49103: IFTRUE 49107
49105: GO 49329
49107: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49108: LD_ADDR_VAR 0 4
49112: PUSH
49113: LD_INT 46
49115: PUSH
49116: LD_INT 47
49118: PUSH
49119: LD_INT 1
49121: PUSH
49122: LD_INT 2
49124: PUSH
49125: LD_INT 82
49127: PUSH
49128: LD_INT 83
49130: PUSH
49131: LD_INT 84
49133: PUSH
49134: LD_INT 85
49136: PUSH
49137: LD_INT 86
49139: PUSH
49140: LD_INT 11
49142: PUSH
49143: LD_INT 9
49145: PUSH
49146: LD_INT 20
49148: PUSH
49149: LD_INT 19
49151: PUSH
49152: LD_INT 21
49154: PUSH
49155: LD_INT 24
49157: PUSH
49158: LD_INT 22
49160: PUSH
49161: LD_INT 25
49163: PUSH
49164: LD_INT 28
49166: PUSH
49167: LD_INT 29
49169: PUSH
49170: LD_INT 30
49172: PUSH
49173: LD_INT 31
49175: PUSH
49176: LD_INT 37
49178: PUSH
49179: LD_INT 38
49181: PUSH
49182: LD_INT 32
49184: PUSH
49185: LD_INT 27
49187: PUSH
49188: LD_INT 33
49190: PUSH
49191: LD_INT 69
49193: PUSH
49194: LD_INT 39
49196: PUSH
49197: LD_INT 34
49199: PUSH
49200: LD_INT 40
49202: PUSH
49203: LD_INT 71
49205: PUSH
49206: LD_INT 23
49208: PUSH
49209: LD_INT 44
49211: PUSH
49212: LD_INT 48
49214: PUSH
49215: LD_INT 49
49217: PUSH
49218: LD_INT 50
49220: PUSH
49221: LD_INT 51
49223: PUSH
49224: LD_INT 52
49226: PUSH
49227: LD_INT 53
49229: PUSH
49230: LD_INT 54
49232: PUSH
49233: LD_INT 55
49235: PUSH
49236: LD_INT 56
49238: PUSH
49239: LD_INT 57
49241: PUSH
49242: LD_INT 58
49244: PUSH
49245: LD_INT 59
49247: PUSH
49248: LD_INT 63
49250: PUSH
49251: LD_INT 64
49253: PUSH
49254: LD_INT 65
49256: PUSH
49257: LD_INT 82
49259: PUSH
49260: LD_INT 83
49262: PUSH
49263: LD_INT 84
49265: PUSH
49266: LD_INT 85
49268: PUSH
49269: LD_INT 86
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: LIST
49276: LIST
49277: LIST
49278: LIST
49279: LIST
49280: LIST
49281: LIST
49282: LIST
49283: LIST
49284: LIST
49285: LIST
49286: LIST
49287: LIST
49288: LIST
49289: LIST
49290: LIST
49291: LIST
49292: LIST
49293: LIST
49294: LIST
49295: LIST
49296: LIST
49297: LIST
49298: LIST
49299: LIST
49300: LIST
49301: LIST
49302: LIST
49303: LIST
49304: LIST
49305: LIST
49306: LIST
49307: LIST
49308: LIST
49309: LIST
49310: LIST
49311: LIST
49312: LIST
49313: LIST
49314: LIST
49315: LIST
49316: LIST
49317: LIST
49318: LIST
49319: LIST
49320: LIST
49321: LIST
49322: LIST
49323: LIST
49324: LIST
49325: LIST
49326: ST_TO_ADDR
49327: GO 49330
49329: POP
// if state > - 1 and state < 3 then
49330: LD_VAR 0 3
49334: PUSH
49335: LD_INT 1
49337: NEG
49338: GREATER
49339: PUSH
49340: LD_VAR 0 3
49344: PUSH
49345: LD_INT 3
49347: LESS
49348: AND
49349: IFFALSE 49406
// for i in result do
49351: LD_ADDR_VAR 0 5
49355: PUSH
49356: LD_VAR 0 4
49360: PUSH
49361: FOR_IN
49362: IFFALSE 49404
// if GetTech ( i , side ) <> state then
49364: LD_VAR 0 5
49368: PPUSH
49369: LD_VAR 0 1
49373: PPUSH
49374: CALL_OW 321
49378: PUSH
49379: LD_VAR 0 3
49383: NONEQUAL
49384: IFFALSE 49402
// result := result diff i ;
49386: LD_ADDR_VAR 0 4
49390: PUSH
49391: LD_VAR 0 4
49395: PUSH
49396: LD_VAR 0 5
49400: DIFF
49401: ST_TO_ADDR
49402: GO 49361
49404: POP
49405: POP
// end ;
49406: LD_VAR 0 4
49410: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49411: LD_INT 0
49413: PPUSH
49414: PPUSH
49415: PPUSH
// result := true ;
49416: LD_ADDR_VAR 0 3
49420: PUSH
49421: LD_INT 1
49423: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49424: LD_ADDR_VAR 0 5
49428: PUSH
49429: LD_VAR 0 2
49433: PPUSH
49434: CALL_OW 480
49438: ST_TO_ADDR
// if not tmp then
49439: LD_VAR 0 5
49443: NOT
49444: IFFALSE 49448
// exit ;
49446: GO 49497
// for i in tmp do
49448: LD_ADDR_VAR 0 4
49452: PUSH
49453: LD_VAR 0 5
49457: PUSH
49458: FOR_IN
49459: IFFALSE 49495
// if GetTech ( i , side ) <> state_researched then
49461: LD_VAR 0 4
49465: PPUSH
49466: LD_VAR 0 1
49470: PPUSH
49471: CALL_OW 321
49475: PUSH
49476: LD_INT 2
49478: NONEQUAL
49479: IFFALSE 49493
// begin result := false ;
49481: LD_ADDR_VAR 0 3
49485: PUSH
49486: LD_INT 0
49488: ST_TO_ADDR
// exit ;
49489: POP
49490: POP
49491: GO 49497
// end ;
49493: GO 49458
49495: POP
49496: POP
// end ;
49497: LD_VAR 0 3
49501: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49502: LD_INT 0
49504: PPUSH
49505: PPUSH
49506: PPUSH
49507: PPUSH
49508: PPUSH
49509: PPUSH
49510: PPUSH
49511: PPUSH
49512: PPUSH
49513: PPUSH
49514: PPUSH
49515: PPUSH
49516: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49517: LD_VAR 0 1
49521: NOT
49522: PUSH
49523: LD_VAR 0 1
49527: PPUSH
49528: CALL_OW 257
49532: PUSH
49533: LD_INT 9
49535: NONEQUAL
49536: OR
49537: IFFALSE 49541
// exit ;
49539: GO 50114
// side := GetSide ( unit ) ;
49541: LD_ADDR_VAR 0 9
49545: PUSH
49546: LD_VAR 0 1
49550: PPUSH
49551: CALL_OW 255
49555: ST_TO_ADDR
// tech_space := tech_spacanom ;
49556: LD_ADDR_VAR 0 12
49560: PUSH
49561: LD_INT 29
49563: ST_TO_ADDR
// tech_time := tech_taurad ;
49564: LD_ADDR_VAR 0 13
49568: PUSH
49569: LD_INT 28
49571: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49572: LD_ADDR_VAR 0 11
49576: PUSH
49577: LD_VAR 0 1
49581: PPUSH
49582: CALL_OW 310
49586: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49587: LD_VAR 0 11
49591: PPUSH
49592: CALL_OW 247
49596: PUSH
49597: LD_INT 2
49599: EQUAL
49600: IFFALSE 49604
// exit ;
49602: GO 50114
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49604: LD_ADDR_VAR 0 8
49608: PUSH
49609: LD_INT 81
49611: PUSH
49612: LD_VAR 0 9
49616: PUSH
49617: EMPTY
49618: LIST
49619: LIST
49620: PUSH
49621: LD_INT 3
49623: PUSH
49624: LD_INT 21
49626: PUSH
49627: LD_INT 3
49629: PUSH
49630: EMPTY
49631: LIST
49632: LIST
49633: PUSH
49634: EMPTY
49635: LIST
49636: LIST
49637: PUSH
49638: EMPTY
49639: LIST
49640: LIST
49641: PPUSH
49642: CALL_OW 69
49646: ST_TO_ADDR
// if not tmp then
49647: LD_VAR 0 8
49651: NOT
49652: IFFALSE 49656
// exit ;
49654: GO 50114
// if in_unit then
49656: LD_VAR 0 11
49660: IFFALSE 49684
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49662: LD_ADDR_VAR 0 10
49666: PUSH
49667: LD_VAR 0 8
49671: PPUSH
49672: LD_VAR 0 11
49676: PPUSH
49677: CALL_OW 74
49681: ST_TO_ADDR
49682: GO 49704
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49684: LD_ADDR_VAR 0 10
49688: PUSH
49689: LD_VAR 0 8
49693: PPUSH
49694: LD_VAR 0 1
49698: PPUSH
49699: CALL_OW 74
49703: ST_TO_ADDR
// if not enemy then
49704: LD_VAR 0 10
49708: NOT
49709: IFFALSE 49713
// exit ;
49711: GO 50114
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49713: LD_VAR 0 11
49717: PUSH
49718: LD_VAR 0 11
49722: PPUSH
49723: LD_VAR 0 10
49727: PPUSH
49728: CALL_OW 296
49732: PUSH
49733: LD_INT 13
49735: GREATER
49736: AND
49737: PUSH
49738: LD_VAR 0 1
49742: PPUSH
49743: LD_VAR 0 10
49747: PPUSH
49748: CALL_OW 296
49752: PUSH
49753: LD_INT 12
49755: GREATER
49756: OR
49757: IFFALSE 49761
// exit ;
49759: GO 50114
// missile := [ 1 ] ;
49761: LD_ADDR_VAR 0 14
49765: PUSH
49766: LD_INT 1
49768: PUSH
49769: EMPTY
49770: LIST
49771: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49772: LD_VAR 0 9
49776: PPUSH
49777: LD_VAR 0 12
49781: PPUSH
49782: CALL_OW 325
49786: IFFALSE 49815
// missile := Insert ( missile , missile + 1 , 2 ) ;
49788: LD_ADDR_VAR 0 14
49792: PUSH
49793: LD_VAR 0 14
49797: PPUSH
49798: LD_VAR 0 14
49802: PUSH
49803: LD_INT 1
49805: PLUS
49806: PPUSH
49807: LD_INT 2
49809: PPUSH
49810: CALL_OW 2
49814: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49815: LD_VAR 0 9
49819: PPUSH
49820: LD_VAR 0 13
49824: PPUSH
49825: CALL_OW 325
49829: PUSH
49830: LD_VAR 0 10
49834: PPUSH
49835: CALL_OW 255
49839: PPUSH
49840: LD_VAR 0 13
49844: PPUSH
49845: CALL_OW 325
49849: NOT
49850: AND
49851: IFFALSE 49880
// missile := Insert ( missile , missile + 1 , 3 ) ;
49853: LD_ADDR_VAR 0 14
49857: PUSH
49858: LD_VAR 0 14
49862: PPUSH
49863: LD_VAR 0 14
49867: PUSH
49868: LD_INT 1
49870: PLUS
49871: PPUSH
49872: LD_INT 3
49874: PPUSH
49875: CALL_OW 2
49879: ST_TO_ADDR
// if missile < 2 then
49880: LD_VAR 0 14
49884: PUSH
49885: LD_INT 2
49887: LESS
49888: IFFALSE 49892
// exit ;
49890: GO 50114
// x := GetX ( enemy ) ;
49892: LD_ADDR_VAR 0 4
49896: PUSH
49897: LD_VAR 0 10
49901: PPUSH
49902: CALL_OW 250
49906: ST_TO_ADDR
// y := GetY ( enemy ) ;
49907: LD_ADDR_VAR 0 5
49911: PUSH
49912: LD_VAR 0 10
49916: PPUSH
49917: CALL_OW 251
49921: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
49922: LD_ADDR_VAR 0 6
49926: PUSH
49927: LD_VAR 0 4
49931: PUSH
49932: LD_INT 1
49934: NEG
49935: PPUSH
49936: LD_INT 1
49938: PPUSH
49939: CALL_OW 12
49943: PLUS
49944: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
49945: LD_ADDR_VAR 0 7
49949: PUSH
49950: LD_VAR 0 5
49954: PUSH
49955: LD_INT 1
49957: NEG
49958: PPUSH
49959: LD_INT 1
49961: PPUSH
49962: CALL_OW 12
49966: PLUS
49967: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49968: LD_VAR 0 6
49972: PPUSH
49973: LD_VAR 0 7
49977: PPUSH
49978: CALL_OW 488
49982: NOT
49983: IFFALSE 50005
// begin _x := x ;
49985: LD_ADDR_VAR 0 6
49989: PUSH
49990: LD_VAR 0 4
49994: ST_TO_ADDR
// _y := y ;
49995: LD_ADDR_VAR 0 7
49999: PUSH
50000: LD_VAR 0 5
50004: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50005: LD_ADDR_VAR 0 3
50009: PUSH
50010: LD_INT 1
50012: PPUSH
50013: LD_VAR 0 14
50017: PPUSH
50018: CALL_OW 12
50022: ST_TO_ADDR
// case i of 1 :
50023: LD_VAR 0 3
50027: PUSH
50028: LD_INT 1
50030: DOUBLE
50031: EQUAL
50032: IFTRUE 50036
50034: GO 50053
50036: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50037: LD_VAR 0 1
50041: PPUSH
50042: LD_VAR 0 10
50046: PPUSH
50047: CALL_OW 115
50051: GO 50114
50053: LD_INT 2
50055: DOUBLE
50056: EQUAL
50057: IFTRUE 50061
50059: GO 50083
50061: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50062: LD_VAR 0 1
50066: PPUSH
50067: LD_VAR 0 6
50071: PPUSH
50072: LD_VAR 0 7
50076: PPUSH
50077: CALL_OW 153
50081: GO 50114
50083: LD_INT 3
50085: DOUBLE
50086: EQUAL
50087: IFTRUE 50091
50089: GO 50113
50091: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50092: LD_VAR 0 1
50096: PPUSH
50097: LD_VAR 0 6
50101: PPUSH
50102: LD_VAR 0 7
50106: PPUSH
50107: CALL_OW 154
50111: GO 50114
50113: POP
// end ;
50114: LD_VAR 0 2
50118: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50119: LD_INT 0
50121: PPUSH
50122: PPUSH
50123: PPUSH
50124: PPUSH
50125: PPUSH
50126: PPUSH
// if not unit or not building then
50127: LD_VAR 0 1
50131: NOT
50132: PUSH
50133: LD_VAR 0 2
50137: NOT
50138: OR
50139: IFFALSE 50143
// exit ;
50141: GO 50301
// x := GetX ( building ) ;
50143: LD_ADDR_VAR 0 5
50147: PUSH
50148: LD_VAR 0 2
50152: PPUSH
50153: CALL_OW 250
50157: ST_TO_ADDR
// y := GetY ( building ) ;
50158: LD_ADDR_VAR 0 6
50162: PUSH
50163: LD_VAR 0 2
50167: PPUSH
50168: CALL_OW 251
50172: ST_TO_ADDR
// for i = 0 to 5 do
50173: LD_ADDR_VAR 0 4
50177: PUSH
50178: DOUBLE
50179: LD_INT 0
50181: DEC
50182: ST_TO_ADDR
50183: LD_INT 5
50185: PUSH
50186: FOR_TO
50187: IFFALSE 50299
// begin _x := ShiftX ( x , i , 3 ) ;
50189: LD_ADDR_VAR 0 7
50193: PUSH
50194: LD_VAR 0 5
50198: PPUSH
50199: LD_VAR 0 4
50203: PPUSH
50204: LD_INT 3
50206: PPUSH
50207: CALL_OW 272
50211: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50212: LD_ADDR_VAR 0 8
50216: PUSH
50217: LD_VAR 0 6
50221: PPUSH
50222: LD_VAR 0 4
50226: PPUSH
50227: LD_INT 3
50229: PPUSH
50230: CALL_OW 273
50234: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50235: LD_VAR 0 7
50239: PPUSH
50240: LD_VAR 0 8
50244: PPUSH
50245: CALL_OW 488
50249: NOT
50250: IFFALSE 50254
// continue ;
50252: GO 50186
// if HexInfo ( _x , _y ) = 0 then
50254: LD_VAR 0 7
50258: PPUSH
50259: LD_VAR 0 8
50263: PPUSH
50264: CALL_OW 428
50268: PUSH
50269: LD_INT 0
50271: EQUAL
50272: IFFALSE 50297
// begin ComMoveXY ( unit , _x , _y ) ;
50274: LD_VAR 0 1
50278: PPUSH
50279: LD_VAR 0 7
50283: PPUSH
50284: LD_VAR 0 8
50288: PPUSH
50289: CALL_OW 111
// exit ;
50293: POP
50294: POP
50295: GO 50301
// end ; end ;
50297: GO 50186
50299: POP
50300: POP
// end ;
50301: LD_VAR 0 3
50305: RET
// export function ScanBase ( side , base_area ) ; begin
50306: LD_INT 0
50308: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50309: LD_ADDR_VAR 0 3
50313: PUSH
50314: LD_VAR 0 2
50318: PPUSH
50319: LD_INT 81
50321: PUSH
50322: LD_VAR 0 1
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: PPUSH
50331: CALL_OW 70
50335: ST_TO_ADDR
// end ;
50336: LD_VAR 0 3
50340: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50341: LD_INT 0
50343: PPUSH
50344: PPUSH
50345: PPUSH
50346: PPUSH
// result := false ;
50347: LD_ADDR_VAR 0 2
50351: PUSH
50352: LD_INT 0
50354: ST_TO_ADDR
// side := GetSide ( unit ) ;
50355: LD_ADDR_VAR 0 3
50359: PUSH
50360: LD_VAR 0 1
50364: PPUSH
50365: CALL_OW 255
50369: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50370: LD_ADDR_VAR 0 4
50374: PUSH
50375: LD_VAR 0 1
50379: PPUSH
50380: CALL_OW 248
50384: ST_TO_ADDR
// case nat of 1 :
50385: LD_VAR 0 4
50389: PUSH
50390: LD_INT 1
50392: DOUBLE
50393: EQUAL
50394: IFTRUE 50398
50396: GO 50409
50398: POP
// tech := tech_lassight ; 2 :
50399: LD_ADDR_VAR 0 5
50403: PUSH
50404: LD_INT 12
50406: ST_TO_ADDR
50407: GO 50448
50409: LD_INT 2
50411: DOUBLE
50412: EQUAL
50413: IFTRUE 50417
50415: GO 50428
50417: POP
// tech := tech_mortar ; 3 :
50418: LD_ADDR_VAR 0 5
50422: PUSH
50423: LD_INT 41
50425: ST_TO_ADDR
50426: GO 50448
50428: LD_INT 3
50430: DOUBLE
50431: EQUAL
50432: IFTRUE 50436
50434: GO 50447
50436: POP
// tech := tech_bazooka ; end ;
50437: LD_ADDR_VAR 0 5
50441: PUSH
50442: LD_INT 44
50444: ST_TO_ADDR
50445: GO 50448
50447: POP
// if Researched ( side , tech ) then
50448: LD_VAR 0 3
50452: PPUSH
50453: LD_VAR 0 5
50457: PPUSH
50458: CALL_OW 325
50462: IFFALSE 50489
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50464: LD_ADDR_VAR 0 2
50468: PUSH
50469: LD_INT 5
50471: PUSH
50472: LD_INT 8
50474: PUSH
50475: LD_INT 9
50477: PUSH
50478: EMPTY
50479: LIST
50480: LIST
50481: LIST
50482: PUSH
50483: LD_VAR 0 4
50487: ARRAY
50488: ST_TO_ADDR
// end ;
50489: LD_VAR 0 2
50493: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50494: LD_INT 0
50496: PPUSH
50497: PPUSH
50498: PPUSH
// if not mines then
50499: LD_VAR 0 2
50503: NOT
50504: IFFALSE 50508
// exit ;
50506: GO 50652
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50508: LD_ADDR_VAR 0 5
50512: PUSH
50513: LD_INT 81
50515: PUSH
50516: LD_VAR 0 1
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: LD_INT 3
50527: PUSH
50528: LD_INT 21
50530: PUSH
50531: LD_INT 3
50533: PUSH
50534: EMPTY
50535: LIST
50536: LIST
50537: PUSH
50538: EMPTY
50539: LIST
50540: LIST
50541: PUSH
50542: EMPTY
50543: LIST
50544: LIST
50545: PPUSH
50546: CALL_OW 69
50550: ST_TO_ADDR
// for i in mines do
50551: LD_ADDR_VAR 0 4
50555: PUSH
50556: LD_VAR 0 2
50560: PUSH
50561: FOR_IN
50562: IFFALSE 50650
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50564: LD_VAR 0 4
50568: PUSH
50569: LD_INT 1
50571: ARRAY
50572: PPUSH
50573: LD_VAR 0 4
50577: PUSH
50578: LD_INT 2
50580: ARRAY
50581: PPUSH
50582: CALL_OW 458
50586: NOT
50587: IFFALSE 50591
// continue ;
50589: GO 50561
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50591: LD_VAR 0 4
50595: PUSH
50596: LD_INT 1
50598: ARRAY
50599: PPUSH
50600: LD_VAR 0 4
50604: PUSH
50605: LD_INT 2
50607: ARRAY
50608: PPUSH
50609: CALL_OW 428
50613: PUSH
50614: LD_VAR 0 5
50618: IN
50619: IFFALSE 50648
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50621: LD_VAR 0 4
50625: PUSH
50626: LD_INT 1
50628: ARRAY
50629: PPUSH
50630: LD_VAR 0 4
50634: PUSH
50635: LD_INT 2
50637: ARRAY
50638: PPUSH
50639: LD_VAR 0 1
50643: PPUSH
50644: CALL_OW 456
// end ;
50648: GO 50561
50650: POP
50651: POP
// end ;
50652: LD_VAR 0 3
50656: RET
// export function Count ( array ) ; var i ; begin
50657: LD_INT 0
50659: PPUSH
50660: PPUSH
// result := 0 ;
50661: LD_ADDR_VAR 0 2
50665: PUSH
50666: LD_INT 0
50668: ST_TO_ADDR
// for i in array do
50669: LD_ADDR_VAR 0 3
50673: PUSH
50674: LD_VAR 0 1
50678: PUSH
50679: FOR_IN
50680: IFFALSE 50704
// if i then
50682: LD_VAR 0 3
50686: IFFALSE 50702
// result := result + 1 ;
50688: LD_ADDR_VAR 0 2
50692: PUSH
50693: LD_VAR 0 2
50697: PUSH
50698: LD_INT 1
50700: PLUS
50701: ST_TO_ADDR
50702: GO 50679
50704: POP
50705: POP
// end ;
50706: LD_VAR 0 2
50710: RET
// export function IsEmpty ( building ) ; begin
50711: LD_INT 0
50713: PPUSH
// if not building then
50714: LD_VAR 0 1
50718: NOT
50719: IFFALSE 50723
// exit ;
50721: GO 50766
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50723: LD_ADDR_VAR 0 2
50727: PUSH
50728: LD_VAR 0 1
50732: PUSH
50733: LD_INT 22
50735: PUSH
50736: LD_VAR 0 1
50740: PPUSH
50741: CALL_OW 255
50745: PUSH
50746: EMPTY
50747: LIST
50748: LIST
50749: PUSH
50750: LD_INT 58
50752: PUSH
50753: EMPTY
50754: LIST
50755: PUSH
50756: EMPTY
50757: LIST
50758: LIST
50759: PPUSH
50760: CALL_OW 69
50764: IN
50765: ST_TO_ADDR
// end ;
50766: LD_VAR 0 2
50770: RET
// export function IsNotFull ( building ) ; begin
50771: LD_INT 0
50773: PPUSH
// if not building then
50774: LD_VAR 0 1
50778: NOT
50779: IFFALSE 50783
// exit ;
50781: GO 50802
// result := UnitsInside ( building ) < 6 ;
50783: LD_ADDR_VAR 0 2
50787: PUSH
50788: LD_VAR 0 1
50792: PPUSH
50793: CALL_OW 313
50797: PUSH
50798: LD_INT 6
50800: LESS
50801: ST_TO_ADDR
// end ;
50802: LD_VAR 0 2
50806: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
50807: LD_INT 0
50809: PPUSH
50810: PPUSH
50811: PPUSH
50812: PPUSH
// tmp := [ ] ;
50813: LD_ADDR_VAR 0 3
50817: PUSH
50818: EMPTY
50819: ST_TO_ADDR
// list := [ ] ;
50820: LD_ADDR_VAR 0 5
50824: PUSH
50825: EMPTY
50826: ST_TO_ADDR
// for i = 16 to 25 do
50827: LD_ADDR_VAR 0 4
50831: PUSH
50832: DOUBLE
50833: LD_INT 16
50835: DEC
50836: ST_TO_ADDR
50837: LD_INT 25
50839: PUSH
50840: FOR_TO
50841: IFFALSE 50914
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
50843: LD_ADDR_VAR 0 3
50847: PUSH
50848: LD_VAR 0 3
50852: PUSH
50853: LD_INT 22
50855: PUSH
50856: LD_VAR 0 1
50860: PPUSH
50861: CALL_OW 255
50865: PUSH
50866: EMPTY
50867: LIST
50868: LIST
50869: PUSH
50870: LD_INT 91
50872: PUSH
50873: LD_VAR 0 1
50877: PUSH
50878: LD_INT 6
50880: PUSH
50881: EMPTY
50882: LIST
50883: LIST
50884: LIST
50885: PUSH
50886: LD_INT 30
50888: PUSH
50889: LD_VAR 0 4
50893: PUSH
50894: EMPTY
50895: LIST
50896: LIST
50897: PUSH
50898: EMPTY
50899: LIST
50900: LIST
50901: LIST
50902: PUSH
50903: EMPTY
50904: LIST
50905: PPUSH
50906: CALL_OW 69
50910: ADD
50911: ST_TO_ADDR
50912: GO 50840
50914: POP
50915: POP
// for i = 1 to tmp do
50916: LD_ADDR_VAR 0 4
50920: PUSH
50921: DOUBLE
50922: LD_INT 1
50924: DEC
50925: ST_TO_ADDR
50926: LD_VAR 0 3
50930: PUSH
50931: FOR_TO
50932: IFFALSE 51020
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
50934: LD_ADDR_VAR 0 5
50938: PUSH
50939: LD_VAR 0 5
50943: PUSH
50944: LD_VAR 0 3
50948: PUSH
50949: LD_VAR 0 4
50953: ARRAY
50954: PPUSH
50955: CALL_OW 266
50959: PUSH
50960: LD_VAR 0 3
50964: PUSH
50965: LD_VAR 0 4
50969: ARRAY
50970: PPUSH
50971: CALL_OW 250
50975: PUSH
50976: LD_VAR 0 3
50980: PUSH
50981: LD_VAR 0 4
50985: ARRAY
50986: PPUSH
50987: CALL_OW 251
50991: PUSH
50992: LD_VAR 0 3
50996: PUSH
50997: LD_VAR 0 4
51001: ARRAY
51002: PPUSH
51003: CALL_OW 254
51007: PUSH
51008: EMPTY
51009: LIST
51010: LIST
51011: LIST
51012: LIST
51013: PUSH
51014: EMPTY
51015: LIST
51016: ADD
51017: ST_TO_ADDR
51018: GO 50931
51020: POP
51021: POP
// result := list ;
51022: LD_ADDR_VAR 0 2
51026: PUSH
51027: LD_VAR 0 5
51031: ST_TO_ADDR
// end ;
51032: LD_VAR 0 2
51036: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51037: LD_INT 0
51039: PPUSH
51040: PPUSH
51041: PPUSH
51042: PPUSH
51043: PPUSH
51044: PPUSH
51045: PPUSH
// if not factory then
51046: LD_VAR 0 1
51050: NOT
51051: IFFALSE 51055
// exit ;
51053: GO 51648
// if control = control_apeman then
51055: LD_VAR 0 4
51059: PUSH
51060: LD_INT 5
51062: EQUAL
51063: IFFALSE 51172
// begin tmp := UnitsInside ( factory ) ;
51065: LD_ADDR_VAR 0 8
51069: PUSH
51070: LD_VAR 0 1
51074: PPUSH
51075: CALL_OW 313
51079: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51080: LD_VAR 0 8
51084: PPUSH
51085: LD_INT 25
51087: PUSH
51088: LD_INT 12
51090: PUSH
51091: EMPTY
51092: LIST
51093: LIST
51094: PPUSH
51095: CALL_OW 72
51099: NOT
51100: IFFALSE 51110
// control := control_manual ;
51102: LD_ADDR_VAR 0 4
51106: PUSH
51107: LD_INT 1
51109: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51110: LD_ADDR_VAR 0 8
51114: PUSH
51115: LD_VAR 0 1
51119: PPUSH
51120: CALL 50807 0 1
51124: ST_TO_ADDR
// if tmp then
51125: LD_VAR 0 8
51129: IFFALSE 51172
// begin for i in tmp do
51131: LD_ADDR_VAR 0 7
51135: PUSH
51136: LD_VAR 0 8
51140: PUSH
51141: FOR_IN
51142: IFFALSE 51170
// if i [ 1 ] = b_ext_radio then
51144: LD_VAR 0 7
51148: PUSH
51149: LD_INT 1
51151: ARRAY
51152: PUSH
51153: LD_INT 22
51155: EQUAL
51156: IFFALSE 51168
// begin control := control_remote ;
51158: LD_ADDR_VAR 0 4
51162: PUSH
51163: LD_INT 2
51165: ST_TO_ADDR
// break ;
51166: GO 51170
// end ;
51168: GO 51141
51170: POP
51171: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51172: LD_VAR 0 1
51176: PPUSH
51177: LD_VAR 0 2
51181: PPUSH
51182: LD_VAR 0 3
51186: PPUSH
51187: LD_VAR 0 4
51191: PPUSH
51192: LD_VAR 0 5
51196: PPUSH
51197: CALL_OW 448
51201: IFFALSE 51236
// begin result := [ chassis , engine , control , weapon ] ;
51203: LD_ADDR_VAR 0 6
51207: PUSH
51208: LD_VAR 0 2
51212: PUSH
51213: LD_VAR 0 3
51217: PUSH
51218: LD_VAR 0 4
51222: PUSH
51223: LD_VAR 0 5
51227: PUSH
51228: EMPTY
51229: LIST
51230: LIST
51231: LIST
51232: LIST
51233: ST_TO_ADDR
// exit ;
51234: GO 51648
// end ; _chassis := AvailableChassisList ( factory ) ;
51236: LD_ADDR_VAR 0 9
51240: PUSH
51241: LD_VAR 0 1
51245: PPUSH
51246: CALL_OW 475
51250: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51251: LD_ADDR_VAR 0 11
51255: PUSH
51256: LD_VAR 0 1
51260: PPUSH
51261: CALL_OW 476
51265: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51266: LD_ADDR_VAR 0 12
51270: PUSH
51271: LD_VAR 0 1
51275: PPUSH
51276: CALL_OW 477
51280: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51281: LD_ADDR_VAR 0 10
51285: PUSH
51286: LD_VAR 0 1
51290: PPUSH
51291: CALL_OW 478
51295: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51296: LD_VAR 0 9
51300: NOT
51301: PUSH
51302: LD_VAR 0 11
51306: NOT
51307: OR
51308: PUSH
51309: LD_VAR 0 12
51313: NOT
51314: OR
51315: PUSH
51316: LD_VAR 0 10
51320: NOT
51321: OR
51322: IFFALSE 51357
// begin result := [ chassis , engine , control , weapon ] ;
51324: LD_ADDR_VAR 0 6
51328: PUSH
51329: LD_VAR 0 2
51333: PUSH
51334: LD_VAR 0 3
51338: PUSH
51339: LD_VAR 0 4
51343: PUSH
51344: LD_VAR 0 5
51348: PUSH
51349: EMPTY
51350: LIST
51351: LIST
51352: LIST
51353: LIST
51354: ST_TO_ADDR
// exit ;
51355: GO 51648
// end ; if not chassis in _chassis then
51357: LD_VAR 0 2
51361: PUSH
51362: LD_VAR 0 9
51366: IN
51367: NOT
51368: IFFALSE 51394
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51370: LD_ADDR_VAR 0 2
51374: PUSH
51375: LD_VAR 0 9
51379: PUSH
51380: LD_INT 1
51382: PPUSH
51383: LD_VAR 0 9
51387: PPUSH
51388: CALL_OW 12
51392: ARRAY
51393: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51394: LD_VAR 0 2
51398: PPUSH
51399: LD_VAR 0 3
51403: PPUSH
51404: CALL 51653 0 2
51408: NOT
51409: IFFALSE 51468
// repeat engine := _engine [ 1 ] ;
51411: LD_ADDR_VAR 0 3
51415: PUSH
51416: LD_VAR 0 11
51420: PUSH
51421: LD_INT 1
51423: ARRAY
51424: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51425: LD_ADDR_VAR 0 11
51429: PUSH
51430: LD_VAR 0 11
51434: PPUSH
51435: LD_INT 1
51437: PPUSH
51438: CALL_OW 3
51442: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51443: LD_VAR 0 2
51447: PPUSH
51448: LD_VAR 0 3
51452: PPUSH
51453: CALL 51653 0 2
51457: PUSH
51458: LD_VAR 0 11
51462: PUSH
51463: EMPTY
51464: EQUAL
51465: OR
51466: IFFALSE 51411
// if not control in _control then
51468: LD_VAR 0 4
51472: PUSH
51473: LD_VAR 0 12
51477: IN
51478: NOT
51479: IFFALSE 51505
// control := _control [ rand ( 1 , _control ) ] ;
51481: LD_ADDR_VAR 0 4
51485: PUSH
51486: LD_VAR 0 12
51490: PUSH
51491: LD_INT 1
51493: PPUSH
51494: LD_VAR 0 12
51498: PPUSH
51499: CALL_OW 12
51503: ARRAY
51504: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51505: LD_VAR 0 2
51509: PPUSH
51510: LD_VAR 0 5
51514: PPUSH
51515: CALL 51873 0 2
51519: NOT
51520: IFFALSE 51579
// repeat weapon := _weapon [ 1 ] ;
51522: LD_ADDR_VAR 0 5
51526: PUSH
51527: LD_VAR 0 10
51531: PUSH
51532: LD_INT 1
51534: ARRAY
51535: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51536: LD_ADDR_VAR 0 10
51540: PUSH
51541: LD_VAR 0 10
51545: PPUSH
51546: LD_INT 1
51548: PPUSH
51549: CALL_OW 3
51553: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51554: LD_VAR 0 2
51558: PPUSH
51559: LD_VAR 0 5
51563: PPUSH
51564: CALL 51873 0 2
51568: PUSH
51569: LD_VAR 0 10
51573: PUSH
51574: EMPTY
51575: EQUAL
51576: OR
51577: IFFALSE 51522
// result := [ ] ;
51579: LD_ADDR_VAR 0 6
51583: PUSH
51584: EMPTY
51585: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51586: LD_VAR 0 1
51590: PPUSH
51591: LD_VAR 0 2
51595: PPUSH
51596: LD_VAR 0 3
51600: PPUSH
51601: LD_VAR 0 4
51605: PPUSH
51606: LD_VAR 0 5
51610: PPUSH
51611: CALL_OW 448
51615: IFFALSE 51648
// result := [ chassis , engine , control , weapon ] ;
51617: LD_ADDR_VAR 0 6
51621: PUSH
51622: LD_VAR 0 2
51626: PUSH
51627: LD_VAR 0 3
51631: PUSH
51632: LD_VAR 0 4
51636: PUSH
51637: LD_VAR 0 5
51641: PUSH
51642: EMPTY
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: ST_TO_ADDR
// end ;
51648: LD_VAR 0 6
51652: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51653: LD_INT 0
51655: PPUSH
// if not chassis or not engine then
51656: LD_VAR 0 1
51660: NOT
51661: PUSH
51662: LD_VAR 0 2
51666: NOT
51667: OR
51668: IFFALSE 51672
// exit ;
51670: GO 51868
// case engine of engine_solar :
51672: LD_VAR 0 2
51676: PUSH
51677: LD_INT 2
51679: DOUBLE
51680: EQUAL
51681: IFTRUE 51685
51683: GO 51723
51685: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51686: LD_ADDR_VAR 0 3
51690: PUSH
51691: LD_INT 11
51693: PUSH
51694: LD_INT 12
51696: PUSH
51697: LD_INT 13
51699: PUSH
51700: LD_INT 14
51702: PUSH
51703: LD_INT 1
51705: PUSH
51706: LD_INT 2
51708: PUSH
51709: LD_INT 3
51711: PUSH
51712: EMPTY
51713: LIST
51714: LIST
51715: LIST
51716: LIST
51717: LIST
51718: LIST
51719: LIST
51720: ST_TO_ADDR
51721: GO 51852
51723: LD_INT 1
51725: DOUBLE
51726: EQUAL
51727: IFTRUE 51731
51729: GO 51793
51731: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51732: LD_ADDR_VAR 0 3
51736: PUSH
51737: LD_INT 11
51739: PUSH
51740: LD_INT 12
51742: PUSH
51743: LD_INT 13
51745: PUSH
51746: LD_INT 14
51748: PUSH
51749: LD_INT 1
51751: PUSH
51752: LD_INT 2
51754: PUSH
51755: LD_INT 3
51757: PUSH
51758: LD_INT 4
51760: PUSH
51761: LD_INT 5
51763: PUSH
51764: LD_INT 21
51766: PUSH
51767: LD_INT 23
51769: PUSH
51770: LD_INT 22
51772: PUSH
51773: LD_INT 24
51775: PUSH
51776: EMPTY
51777: LIST
51778: LIST
51779: LIST
51780: LIST
51781: LIST
51782: LIST
51783: LIST
51784: LIST
51785: LIST
51786: LIST
51787: LIST
51788: LIST
51789: LIST
51790: ST_TO_ADDR
51791: GO 51852
51793: LD_INT 3
51795: DOUBLE
51796: EQUAL
51797: IFTRUE 51801
51799: GO 51851
51801: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51802: LD_ADDR_VAR 0 3
51806: PUSH
51807: LD_INT 13
51809: PUSH
51810: LD_INT 14
51812: PUSH
51813: LD_INT 2
51815: PUSH
51816: LD_INT 3
51818: PUSH
51819: LD_INT 4
51821: PUSH
51822: LD_INT 5
51824: PUSH
51825: LD_INT 21
51827: PUSH
51828: LD_INT 22
51830: PUSH
51831: LD_INT 23
51833: PUSH
51834: LD_INT 24
51836: PUSH
51837: EMPTY
51838: LIST
51839: LIST
51840: LIST
51841: LIST
51842: LIST
51843: LIST
51844: LIST
51845: LIST
51846: LIST
51847: LIST
51848: ST_TO_ADDR
51849: GO 51852
51851: POP
// result := ( chassis in result ) ;
51852: LD_ADDR_VAR 0 3
51856: PUSH
51857: LD_VAR 0 1
51861: PUSH
51862: LD_VAR 0 3
51866: IN
51867: ST_TO_ADDR
// end ;
51868: LD_VAR 0 3
51872: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
51873: LD_INT 0
51875: PPUSH
// if not chassis or not weapon then
51876: LD_VAR 0 1
51880: NOT
51881: PUSH
51882: LD_VAR 0 2
51886: NOT
51887: OR
51888: IFFALSE 51892
// exit ;
51890: GO 52954
// case weapon of us_machine_gun :
51892: LD_VAR 0 2
51896: PUSH
51897: LD_INT 2
51899: DOUBLE
51900: EQUAL
51901: IFTRUE 51905
51903: GO 51935
51905: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
51906: LD_ADDR_VAR 0 3
51910: PUSH
51911: LD_INT 1
51913: PUSH
51914: LD_INT 2
51916: PUSH
51917: LD_INT 3
51919: PUSH
51920: LD_INT 4
51922: PUSH
51923: LD_INT 5
51925: PUSH
51926: EMPTY
51927: LIST
51928: LIST
51929: LIST
51930: LIST
51931: LIST
51932: ST_TO_ADDR
51933: GO 52938
51935: LD_INT 3
51937: DOUBLE
51938: EQUAL
51939: IFTRUE 51943
51941: GO 51973
51943: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
51944: LD_ADDR_VAR 0 3
51948: PUSH
51949: LD_INT 1
51951: PUSH
51952: LD_INT 2
51954: PUSH
51955: LD_INT 3
51957: PUSH
51958: LD_INT 4
51960: PUSH
51961: LD_INT 5
51963: PUSH
51964: EMPTY
51965: LIST
51966: LIST
51967: LIST
51968: LIST
51969: LIST
51970: ST_TO_ADDR
51971: GO 52938
51973: LD_INT 11
51975: DOUBLE
51976: EQUAL
51977: IFTRUE 51981
51979: GO 52011
51981: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
51982: LD_ADDR_VAR 0 3
51986: PUSH
51987: LD_INT 1
51989: PUSH
51990: LD_INT 2
51992: PUSH
51993: LD_INT 3
51995: PUSH
51996: LD_INT 4
51998: PUSH
51999: LD_INT 5
52001: PUSH
52002: EMPTY
52003: LIST
52004: LIST
52005: LIST
52006: LIST
52007: LIST
52008: ST_TO_ADDR
52009: GO 52938
52011: LD_INT 4
52013: DOUBLE
52014: EQUAL
52015: IFTRUE 52019
52017: GO 52045
52019: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52020: LD_ADDR_VAR 0 3
52024: PUSH
52025: LD_INT 2
52027: PUSH
52028: LD_INT 3
52030: PUSH
52031: LD_INT 4
52033: PUSH
52034: LD_INT 5
52036: PUSH
52037: EMPTY
52038: LIST
52039: LIST
52040: LIST
52041: LIST
52042: ST_TO_ADDR
52043: GO 52938
52045: LD_INT 5
52047: DOUBLE
52048: EQUAL
52049: IFTRUE 52053
52051: GO 52079
52053: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52054: LD_ADDR_VAR 0 3
52058: PUSH
52059: LD_INT 2
52061: PUSH
52062: LD_INT 3
52064: PUSH
52065: LD_INT 4
52067: PUSH
52068: LD_INT 5
52070: PUSH
52071: EMPTY
52072: LIST
52073: LIST
52074: LIST
52075: LIST
52076: ST_TO_ADDR
52077: GO 52938
52079: LD_INT 9
52081: DOUBLE
52082: EQUAL
52083: IFTRUE 52087
52085: GO 52113
52087: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52088: LD_ADDR_VAR 0 3
52092: PUSH
52093: LD_INT 2
52095: PUSH
52096: LD_INT 3
52098: PUSH
52099: LD_INT 4
52101: PUSH
52102: LD_INT 5
52104: PUSH
52105: EMPTY
52106: LIST
52107: LIST
52108: LIST
52109: LIST
52110: ST_TO_ADDR
52111: GO 52938
52113: LD_INT 7
52115: DOUBLE
52116: EQUAL
52117: IFTRUE 52121
52119: GO 52147
52121: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52122: LD_ADDR_VAR 0 3
52126: PUSH
52127: LD_INT 2
52129: PUSH
52130: LD_INT 3
52132: PUSH
52133: LD_INT 4
52135: PUSH
52136: LD_INT 5
52138: PUSH
52139: EMPTY
52140: LIST
52141: LIST
52142: LIST
52143: LIST
52144: ST_TO_ADDR
52145: GO 52938
52147: LD_INT 12
52149: DOUBLE
52150: EQUAL
52151: IFTRUE 52155
52153: GO 52181
52155: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52156: LD_ADDR_VAR 0 3
52160: PUSH
52161: LD_INT 2
52163: PUSH
52164: LD_INT 3
52166: PUSH
52167: LD_INT 4
52169: PUSH
52170: LD_INT 5
52172: PUSH
52173: EMPTY
52174: LIST
52175: LIST
52176: LIST
52177: LIST
52178: ST_TO_ADDR
52179: GO 52938
52181: LD_INT 13
52183: DOUBLE
52184: EQUAL
52185: IFTRUE 52189
52187: GO 52215
52189: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52190: LD_ADDR_VAR 0 3
52194: PUSH
52195: LD_INT 2
52197: PUSH
52198: LD_INT 3
52200: PUSH
52201: LD_INT 4
52203: PUSH
52204: LD_INT 5
52206: PUSH
52207: EMPTY
52208: LIST
52209: LIST
52210: LIST
52211: LIST
52212: ST_TO_ADDR
52213: GO 52938
52215: LD_INT 14
52217: DOUBLE
52218: EQUAL
52219: IFTRUE 52223
52221: GO 52241
52223: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52224: LD_ADDR_VAR 0 3
52228: PUSH
52229: LD_INT 4
52231: PUSH
52232: LD_INT 5
52234: PUSH
52235: EMPTY
52236: LIST
52237: LIST
52238: ST_TO_ADDR
52239: GO 52938
52241: LD_INT 6
52243: DOUBLE
52244: EQUAL
52245: IFTRUE 52249
52247: GO 52267
52249: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52250: LD_ADDR_VAR 0 3
52254: PUSH
52255: LD_INT 4
52257: PUSH
52258: LD_INT 5
52260: PUSH
52261: EMPTY
52262: LIST
52263: LIST
52264: ST_TO_ADDR
52265: GO 52938
52267: LD_INT 10
52269: DOUBLE
52270: EQUAL
52271: IFTRUE 52275
52273: GO 52293
52275: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52276: LD_ADDR_VAR 0 3
52280: PUSH
52281: LD_INT 4
52283: PUSH
52284: LD_INT 5
52286: PUSH
52287: EMPTY
52288: LIST
52289: LIST
52290: ST_TO_ADDR
52291: GO 52938
52293: LD_INT 22
52295: DOUBLE
52296: EQUAL
52297: IFTRUE 52301
52299: GO 52327
52301: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52302: LD_ADDR_VAR 0 3
52306: PUSH
52307: LD_INT 11
52309: PUSH
52310: LD_INT 12
52312: PUSH
52313: LD_INT 13
52315: PUSH
52316: LD_INT 14
52318: PUSH
52319: EMPTY
52320: LIST
52321: LIST
52322: LIST
52323: LIST
52324: ST_TO_ADDR
52325: GO 52938
52327: LD_INT 23
52329: DOUBLE
52330: EQUAL
52331: IFTRUE 52335
52333: GO 52361
52335: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52336: LD_ADDR_VAR 0 3
52340: PUSH
52341: LD_INT 11
52343: PUSH
52344: LD_INT 12
52346: PUSH
52347: LD_INT 13
52349: PUSH
52350: LD_INT 14
52352: PUSH
52353: EMPTY
52354: LIST
52355: LIST
52356: LIST
52357: LIST
52358: ST_TO_ADDR
52359: GO 52938
52361: LD_INT 24
52363: DOUBLE
52364: EQUAL
52365: IFTRUE 52369
52367: GO 52395
52369: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52370: LD_ADDR_VAR 0 3
52374: PUSH
52375: LD_INT 11
52377: PUSH
52378: LD_INT 12
52380: PUSH
52381: LD_INT 13
52383: PUSH
52384: LD_INT 14
52386: PUSH
52387: EMPTY
52388: LIST
52389: LIST
52390: LIST
52391: LIST
52392: ST_TO_ADDR
52393: GO 52938
52395: LD_INT 30
52397: DOUBLE
52398: EQUAL
52399: IFTRUE 52403
52401: GO 52429
52403: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52404: LD_ADDR_VAR 0 3
52408: PUSH
52409: LD_INT 11
52411: PUSH
52412: LD_INT 12
52414: PUSH
52415: LD_INT 13
52417: PUSH
52418: LD_INT 14
52420: PUSH
52421: EMPTY
52422: LIST
52423: LIST
52424: LIST
52425: LIST
52426: ST_TO_ADDR
52427: GO 52938
52429: LD_INT 25
52431: DOUBLE
52432: EQUAL
52433: IFTRUE 52437
52435: GO 52455
52437: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52438: LD_ADDR_VAR 0 3
52442: PUSH
52443: LD_INT 13
52445: PUSH
52446: LD_INT 14
52448: PUSH
52449: EMPTY
52450: LIST
52451: LIST
52452: ST_TO_ADDR
52453: GO 52938
52455: LD_INT 27
52457: DOUBLE
52458: EQUAL
52459: IFTRUE 52463
52461: GO 52481
52463: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52464: LD_ADDR_VAR 0 3
52468: PUSH
52469: LD_INT 13
52471: PUSH
52472: LD_INT 14
52474: PUSH
52475: EMPTY
52476: LIST
52477: LIST
52478: ST_TO_ADDR
52479: GO 52938
52481: LD_EXP 99
52485: DOUBLE
52486: EQUAL
52487: IFTRUE 52491
52489: GO 52517
52491: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52492: LD_ADDR_VAR 0 3
52496: PUSH
52497: LD_INT 11
52499: PUSH
52500: LD_INT 12
52502: PUSH
52503: LD_INT 13
52505: PUSH
52506: LD_INT 14
52508: PUSH
52509: EMPTY
52510: LIST
52511: LIST
52512: LIST
52513: LIST
52514: ST_TO_ADDR
52515: GO 52938
52517: LD_INT 28
52519: DOUBLE
52520: EQUAL
52521: IFTRUE 52525
52523: GO 52543
52525: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52526: LD_ADDR_VAR 0 3
52530: PUSH
52531: LD_INT 13
52533: PUSH
52534: LD_INT 14
52536: PUSH
52537: EMPTY
52538: LIST
52539: LIST
52540: ST_TO_ADDR
52541: GO 52938
52543: LD_INT 29
52545: DOUBLE
52546: EQUAL
52547: IFTRUE 52551
52549: GO 52569
52551: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52552: LD_ADDR_VAR 0 3
52556: PUSH
52557: LD_INT 13
52559: PUSH
52560: LD_INT 14
52562: PUSH
52563: EMPTY
52564: LIST
52565: LIST
52566: ST_TO_ADDR
52567: GO 52938
52569: LD_INT 31
52571: DOUBLE
52572: EQUAL
52573: IFTRUE 52577
52575: GO 52595
52577: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52578: LD_ADDR_VAR 0 3
52582: PUSH
52583: LD_INT 13
52585: PUSH
52586: LD_INT 14
52588: PUSH
52589: EMPTY
52590: LIST
52591: LIST
52592: ST_TO_ADDR
52593: GO 52938
52595: LD_INT 26
52597: DOUBLE
52598: EQUAL
52599: IFTRUE 52603
52601: GO 52621
52603: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52604: LD_ADDR_VAR 0 3
52608: PUSH
52609: LD_INT 13
52611: PUSH
52612: LD_INT 14
52614: PUSH
52615: EMPTY
52616: LIST
52617: LIST
52618: ST_TO_ADDR
52619: GO 52938
52621: LD_INT 42
52623: DOUBLE
52624: EQUAL
52625: IFTRUE 52629
52627: GO 52655
52629: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52630: LD_ADDR_VAR 0 3
52634: PUSH
52635: LD_INT 21
52637: PUSH
52638: LD_INT 22
52640: PUSH
52641: LD_INT 23
52643: PUSH
52644: LD_INT 24
52646: PUSH
52647: EMPTY
52648: LIST
52649: LIST
52650: LIST
52651: LIST
52652: ST_TO_ADDR
52653: GO 52938
52655: LD_INT 43
52657: DOUBLE
52658: EQUAL
52659: IFTRUE 52663
52661: GO 52689
52663: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52664: LD_ADDR_VAR 0 3
52668: PUSH
52669: LD_INT 21
52671: PUSH
52672: LD_INT 22
52674: PUSH
52675: LD_INT 23
52677: PUSH
52678: LD_INT 24
52680: PUSH
52681: EMPTY
52682: LIST
52683: LIST
52684: LIST
52685: LIST
52686: ST_TO_ADDR
52687: GO 52938
52689: LD_INT 44
52691: DOUBLE
52692: EQUAL
52693: IFTRUE 52697
52695: GO 52723
52697: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52698: LD_ADDR_VAR 0 3
52702: PUSH
52703: LD_INT 21
52705: PUSH
52706: LD_INT 22
52708: PUSH
52709: LD_INT 23
52711: PUSH
52712: LD_INT 24
52714: PUSH
52715: EMPTY
52716: LIST
52717: LIST
52718: LIST
52719: LIST
52720: ST_TO_ADDR
52721: GO 52938
52723: LD_INT 45
52725: DOUBLE
52726: EQUAL
52727: IFTRUE 52731
52729: GO 52757
52731: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52732: LD_ADDR_VAR 0 3
52736: PUSH
52737: LD_INT 21
52739: PUSH
52740: LD_INT 22
52742: PUSH
52743: LD_INT 23
52745: PUSH
52746: LD_INT 24
52748: PUSH
52749: EMPTY
52750: LIST
52751: LIST
52752: LIST
52753: LIST
52754: ST_TO_ADDR
52755: GO 52938
52757: LD_INT 49
52759: DOUBLE
52760: EQUAL
52761: IFTRUE 52765
52763: GO 52791
52765: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52766: LD_ADDR_VAR 0 3
52770: PUSH
52771: LD_INT 21
52773: PUSH
52774: LD_INT 22
52776: PUSH
52777: LD_INT 23
52779: PUSH
52780: LD_INT 24
52782: PUSH
52783: EMPTY
52784: LIST
52785: LIST
52786: LIST
52787: LIST
52788: ST_TO_ADDR
52789: GO 52938
52791: LD_INT 51
52793: DOUBLE
52794: EQUAL
52795: IFTRUE 52799
52797: GO 52825
52799: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52800: LD_ADDR_VAR 0 3
52804: PUSH
52805: LD_INT 21
52807: PUSH
52808: LD_INT 22
52810: PUSH
52811: LD_INT 23
52813: PUSH
52814: LD_INT 24
52816: PUSH
52817: EMPTY
52818: LIST
52819: LIST
52820: LIST
52821: LIST
52822: ST_TO_ADDR
52823: GO 52938
52825: LD_INT 52
52827: DOUBLE
52828: EQUAL
52829: IFTRUE 52833
52831: GO 52859
52833: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
52834: LD_ADDR_VAR 0 3
52838: PUSH
52839: LD_INT 21
52841: PUSH
52842: LD_INT 22
52844: PUSH
52845: LD_INT 23
52847: PUSH
52848: LD_INT 24
52850: PUSH
52851: EMPTY
52852: LIST
52853: LIST
52854: LIST
52855: LIST
52856: ST_TO_ADDR
52857: GO 52938
52859: LD_INT 53
52861: DOUBLE
52862: EQUAL
52863: IFTRUE 52867
52865: GO 52885
52867: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
52868: LD_ADDR_VAR 0 3
52872: PUSH
52873: LD_INT 23
52875: PUSH
52876: LD_INT 24
52878: PUSH
52879: EMPTY
52880: LIST
52881: LIST
52882: ST_TO_ADDR
52883: GO 52938
52885: LD_INT 46
52887: DOUBLE
52888: EQUAL
52889: IFTRUE 52893
52891: GO 52911
52893: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
52894: LD_ADDR_VAR 0 3
52898: PUSH
52899: LD_INT 23
52901: PUSH
52902: LD_INT 24
52904: PUSH
52905: EMPTY
52906: LIST
52907: LIST
52908: ST_TO_ADDR
52909: GO 52938
52911: LD_INT 47
52913: DOUBLE
52914: EQUAL
52915: IFTRUE 52919
52917: GO 52937
52919: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52920: LD_ADDR_VAR 0 3
52924: PUSH
52925: LD_INT 23
52927: PUSH
52928: LD_INT 24
52930: PUSH
52931: EMPTY
52932: LIST
52933: LIST
52934: ST_TO_ADDR
52935: GO 52938
52937: POP
// result := ( chassis in result ) ;
52938: LD_ADDR_VAR 0 3
52942: PUSH
52943: LD_VAR 0 1
52947: PUSH
52948: LD_VAR 0 3
52952: IN
52953: ST_TO_ADDR
// end ;
52954: LD_VAR 0 3
52958: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
52959: LD_INT 0
52961: PPUSH
52962: PPUSH
52963: PPUSH
52964: PPUSH
52965: PPUSH
52966: PPUSH
52967: PPUSH
// result := array ;
52968: LD_ADDR_VAR 0 5
52972: PUSH
52973: LD_VAR 0 1
52977: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
52978: LD_VAR 0 1
52982: NOT
52983: PUSH
52984: LD_VAR 0 2
52988: NOT
52989: OR
52990: PUSH
52991: LD_VAR 0 3
52995: NOT
52996: OR
52997: PUSH
52998: LD_VAR 0 2
53002: PUSH
53003: LD_VAR 0 1
53007: GREATER
53008: OR
53009: PUSH
53010: LD_VAR 0 3
53014: PUSH
53015: LD_VAR 0 1
53019: GREATER
53020: OR
53021: IFFALSE 53025
// exit ;
53023: GO 53321
// if direction then
53025: LD_VAR 0 4
53029: IFFALSE 53093
// begin d := 1 ;
53031: LD_ADDR_VAR 0 9
53035: PUSH
53036: LD_INT 1
53038: ST_TO_ADDR
// if i_from > i_to then
53039: LD_VAR 0 2
53043: PUSH
53044: LD_VAR 0 3
53048: GREATER
53049: IFFALSE 53075
// length := ( array - i_from ) + i_to else
53051: LD_ADDR_VAR 0 11
53055: PUSH
53056: LD_VAR 0 1
53060: PUSH
53061: LD_VAR 0 2
53065: MINUS
53066: PUSH
53067: LD_VAR 0 3
53071: PLUS
53072: ST_TO_ADDR
53073: GO 53091
// length := i_to - i_from ;
53075: LD_ADDR_VAR 0 11
53079: PUSH
53080: LD_VAR 0 3
53084: PUSH
53085: LD_VAR 0 2
53089: MINUS
53090: ST_TO_ADDR
// end else
53091: GO 53154
// begin d := - 1 ;
53093: LD_ADDR_VAR 0 9
53097: PUSH
53098: LD_INT 1
53100: NEG
53101: ST_TO_ADDR
// if i_from > i_to then
53102: LD_VAR 0 2
53106: PUSH
53107: LD_VAR 0 3
53111: GREATER
53112: IFFALSE 53132
// length := i_from - i_to else
53114: LD_ADDR_VAR 0 11
53118: PUSH
53119: LD_VAR 0 2
53123: PUSH
53124: LD_VAR 0 3
53128: MINUS
53129: ST_TO_ADDR
53130: GO 53154
// length := ( array - i_to ) + i_from ;
53132: LD_ADDR_VAR 0 11
53136: PUSH
53137: LD_VAR 0 1
53141: PUSH
53142: LD_VAR 0 3
53146: MINUS
53147: PUSH
53148: LD_VAR 0 2
53152: PLUS
53153: ST_TO_ADDR
// end ; if not length then
53154: LD_VAR 0 11
53158: NOT
53159: IFFALSE 53163
// exit ;
53161: GO 53321
// tmp := array ;
53163: LD_ADDR_VAR 0 10
53167: PUSH
53168: LD_VAR 0 1
53172: ST_TO_ADDR
// for i = 1 to length do
53173: LD_ADDR_VAR 0 6
53177: PUSH
53178: DOUBLE
53179: LD_INT 1
53181: DEC
53182: ST_TO_ADDR
53183: LD_VAR 0 11
53187: PUSH
53188: FOR_TO
53189: IFFALSE 53309
// begin for j = 1 to array do
53191: LD_ADDR_VAR 0 7
53195: PUSH
53196: DOUBLE
53197: LD_INT 1
53199: DEC
53200: ST_TO_ADDR
53201: LD_VAR 0 1
53205: PUSH
53206: FOR_TO
53207: IFFALSE 53295
// begin k := j + d ;
53209: LD_ADDR_VAR 0 8
53213: PUSH
53214: LD_VAR 0 7
53218: PUSH
53219: LD_VAR 0 9
53223: PLUS
53224: ST_TO_ADDR
// if k > array then
53225: LD_VAR 0 8
53229: PUSH
53230: LD_VAR 0 1
53234: GREATER
53235: IFFALSE 53245
// k := 1 ;
53237: LD_ADDR_VAR 0 8
53241: PUSH
53242: LD_INT 1
53244: ST_TO_ADDR
// if not k then
53245: LD_VAR 0 8
53249: NOT
53250: IFFALSE 53262
// k := array ;
53252: LD_ADDR_VAR 0 8
53256: PUSH
53257: LD_VAR 0 1
53261: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53262: LD_ADDR_VAR 0 10
53266: PUSH
53267: LD_VAR 0 10
53271: PPUSH
53272: LD_VAR 0 8
53276: PPUSH
53277: LD_VAR 0 1
53281: PUSH
53282: LD_VAR 0 7
53286: ARRAY
53287: PPUSH
53288: CALL_OW 1
53292: ST_TO_ADDR
// end ;
53293: GO 53206
53295: POP
53296: POP
// array := tmp ;
53297: LD_ADDR_VAR 0 1
53301: PUSH
53302: LD_VAR 0 10
53306: ST_TO_ADDR
// end ;
53307: GO 53188
53309: POP
53310: POP
// result := array ;
53311: LD_ADDR_VAR 0 5
53315: PUSH
53316: LD_VAR 0 1
53320: ST_TO_ADDR
// end ;
53321: LD_VAR 0 5
53325: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53326: LD_INT 0
53328: PPUSH
53329: PPUSH
// result := 0 ;
53330: LD_ADDR_VAR 0 3
53334: PUSH
53335: LD_INT 0
53337: ST_TO_ADDR
// if not array or not value in array then
53338: LD_VAR 0 1
53342: NOT
53343: PUSH
53344: LD_VAR 0 2
53348: PUSH
53349: LD_VAR 0 1
53353: IN
53354: NOT
53355: OR
53356: IFFALSE 53360
// exit ;
53358: GO 53414
// for i = 1 to array do
53360: LD_ADDR_VAR 0 4
53364: PUSH
53365: DOUBLE
53366: LD_INT 1
53368: DEC
53369: ST_TO_ADDR
53370: LD_VAR 0 1
53374: PUSH
53375: FOR_TO
53376: IFFALSE 53412
// if value = array [ i ] then
53378: LD_VAR 0 2
53382: PUSH
53383: LD_VAR 0 1
53387: PUSH
53388: LD_VAR 0 4
53392: ARRAY
53393: EQUAL
53394: IFFALSE 53410
// begin result := i ;
53396: LD_ADDR_VAR 0 3
53400: PUSH
53401: LD_VAR 0 4
53405: ST_TO_ADDR
// exit ;
53406: POP
53407: POP
53408: GO 53414
// end ;
53410: GO 53375
53412: POP
53413: POP
// end ;
53414: LD_VAR 0 3
53418: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53419: LD_INT 0
53421: PPUSH
// vc_chassis := chassis ;
53422: LD_ADDR_OWVAR 37
53426: PUSH
53427: LD_VAR 0 1
53431: ST_TO_ADDR
// vc_engine := engine ;
53432: LD_ADDR_OWVAR 39
53436: PUSH
53437: LD_VAR 0 2
53441: ST_TO_ADDR
// vc_control := control ;
53442: LD_ADDR_OWVAR 38
53446: PUSH
53447: LD_VAR 0 3
53451: ST_TO_ADDR
// vc_weapon := weapon ;
53452: LD_ADDR_OWVAR 40
53456: PUSH
53457: LD_VAR 0 4
53461: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53462: LD_ADDR_OWVAR 41
53466: PUSH
53467: LD_VAR 0 5
53471: ST_TO_ADDR
// end ;
53472: LD_VAR 0 6
53476: RET
// export function WantPlant ( unit ) ; var task ; begin
53477: LD_INT 0
53479: PPUSH
53480: PPUSH
// result := false ;
53481: LD_ADDR_VAR 0 2
53485: PUSH
53486: LD_INT 0
53488: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53489: LD_ADDR_VAR 0 3
53493: PUSH
53494: LD_VAR 0 1
53498: PPUSH
53499: CALL_OW 437
53503: ST_TO_ADDR
// if task then
53504: LD_VAR 0 3
53508: IFFALSE 53536
// if task [ 1 ] [ 1 ] = p then
53510: LD_VAR 0 3
53514: PUSH
53515: LD_INT 1
53517: ARRAY
53518: PUSH
53519: LD_INT 1
53521: ARRAY
53522: PUSH
53523: LD_STRING p
53525: EQUAL
53526: IFFALSE 53536
// result := true ;
53528: LD_ADDR_VAR 0 2
53532: PUSH
53533: LD_INT 1
53535: ST_TO_ADDR
// end ;
53536: LD_VAR 0 2
53540: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53541: LD_INT 0
53543: PPUSH
53544: PPUSH
53545: PPUSH
53546: PPUSH
// if pos < 1 then
53547: LD_VAR 0 2
53551: PUSH
53552: LD_INT 1
53554: LESS
53555: IFFALSE 53559
// exit ;
53557: GO 53862
// if pos = 1 then
53559: LD_VAR 0 2
53563: PUSH
53564: LD_INT 1
53566: EQUAL
53567: IFFALSE 53600
// result := Replace ( arr , pos [ 1 ] , value ) else
53569: LD_ADDR_VAR 0 4
53573: PUSH
53574: LD_VAR 0 1
53578: PPUSH
53579: LD_VAR 0 2
53583: PUSH
53584: LD_INT 1
53586: ARRAY
53587: PPUSH
53588: LD_VAR 0 3
53592: PPUSH
53593: CALL_OW 1
53597: ST_TO_ADDR
53598: GO 53862
// begin tmp := arr ;
53600: LD_ADDR_VAR 0 6
53604: PUSH
53605: LD_VAR 0 1
53609: ST_TO_ADDR
// s_arr := [ tmp ] ;
53610: LD_ADDR_VAR 0 7
53614: PUSH
53615: LD_VAR 0 6
53619: PUSH
53620: EMPTY
53621: LIST
53622: ST_TO_ADDR
// for i = 1 to pos - 1 do
53623: LD_ADDR_VAR 0 5
53627: PUSH
53628: DOUBLE
53629: LD_INT 1
53631: DEC
53632: ST_TO_ADDR
53633: LD_VAR 0 2
53637: PUSH
53638: LD_INT 1
53640: MINUS
53641: PUSH
53642: FOR_TO
53643: IFFALSE 53688
// begin tmp := tmp [ pos [ i ] ] ;
53645: LD_ADDR_VAR 0 6
53649: PUSH
53650: LD_VAR 0 6
53654: PUSH
53655: LD_VAR 0 2
53659: PUSH
53660: LD_VAR 0 5
53664: ARRAY
53665: ARRAY
53666: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53667: LD_ADDR_VAR 0 7
53671: PUSH
53672: LD_VAR 0 7
53676: PUSH
53677: LD_VAR 0 6
53681: PUSH
53682: EMPTY
53683: LIST
53684: ADD
53685: ST_TO_ADDR
// end ;
53686: GO 53642
53688: POP
53689: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53690: LD_ADDR_VAR 0 6
53694: PUSH
53695: LD_VAR 0 6
53699: PPUSH
53700: LD_VAR 0 2
53704: PUSH
53705: LD_VAR 0 2
53709: ARRAY
53710: PPUSH
53711: LD_VAR 0 3
53715: PPUSH
53716: CALL_OW 1
53720: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53721: LD_ADDR_VAR 0 7
53725: PUSH
53726: LD_VAR 0 7
53730: PPUSH
53731: LD_VAR 0 7
53735: PPUSH
53736: LD_VAR 0 6
53740: PPUSH
53741: CALL_OW 1
53745: ST_TO_ADDR
// for i = s_arr downto 2 do
53746: LD_ADDR_VAR 0 5
53750: PUSH
53751: DOUBLE
53752: LD_VAR 0 7
53756: INC
53757: ST_TO_ADDR
53758: LD_INT 2
53760: PUSH
53761: FOR_DOWNTO
53762: IFFALSE 53846
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53764: LD_ADDR_VAR 0 6
53768: PUSH
53769: LD_VAR 0 7
53773: PUSH
53774: LD_VAR 0 5
53778: PUSH
53779: LD_INT 1
53781: MINUS
53782: ARRAY
53783: PPUSH
53784: LD_VAR 0 2
53788: PUSH
53789: LD_VAR 0 5
53793: PUSH
53794: LD_INT 1
53796: MINUS
53797: ARRAY
53798: PPUSH
53799: LD_VAR 0 7
53803: PUSH
53804: LD_VAR 0 5
53808: ARRAY
53809: PPUSH
53810: CALL_OW 1
53814: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53815: LD_ADDR_VAR 0 7
53819: PUSH
53820: LD_VAR 0 7
53824: PPUSH
53825: LD_VAR 0 5
53829: PUSH
53830: LD_INT 1
53832: MINUS
53833: PPUSH
53834: LD_VAR 0 6
53838: PPUSH
53839: CALL_OW 1
53843: ST_TO_ADDR
// end ;
53844: GO 53761
53846: POP
53847: POP
// result := s_arr [ 1 ] ;
53848: LD_ADDR_VAR 0 4
53852: PUSH
53853: LD_VAR 0 7
53857: PUSH
53858: LD_INT 1
53860: ARRAY
53861: ST_TO_ADDR
// end ; end ;
53862: LD_VAR 0 4
53866: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
53867: LD_INT 0
53869: PPUSH
53870: PPUSH
// if not list then
53871: LD_VAR 0 1
53875: NOT
53876: IFFALSE 53880
// exit ;
53878: GO 53971
// i := list [ pos1 ] ;
53880: LD_ADDR_VAR 0 5
53884: PUSH
53885: LD_VAR 0 1
53889: PUSH
53890: LD_VAR 0 2
53894: ARRAY
53895: ST_TO_ADDR
// if not i then
53896: LD_VAR 0 5
53900: NOT
53901: IFFALSE 53905
// exit ;
53903: GO 53971
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
53905: LD_ADDR_VAR 0 1
53909: PUSH
53910: LD_VAR 0 1
53914: PPUSH
53915: LD_VAR 0 2
53919: PPUSH
53920: LD_VAR 0 1
53924: PUSH
53925: LD_VAR 0 3
53929: ARRAY
53930: PPUSH
53931: CALL_OW 1
53935: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
53936: LD_ADDR_VAR 0 1
53940: PUSH
53941: LD_VAR 0 1
53945: PPUSH
53946: LD_VAR 0 3
53950: PPUSH
53951: LD_VAR 0 5
53955: PPUSH
53956: CALL_OW 1
53960: ST_TO_ADDR
// result := list ;
53961: LD_ADDR_VAR 0 4
53965: PUSH
53966: LD_VAR 0 1
53970: ST_TO_ADDR
// end ;
53971: LD_VAR 0 4
53975: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
53976: LD_INT 0
53978: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
53979: LD_ADDR_VAR 0 5
53983: PUSH
53984: LD_VAR 0 1
53988: PPUSH
53989: CALL_OW 250
53993: PPUSH
53994: LD_VAR 0 1
53998: PPUSH
53999: CALL_OW 251
54003: PPUSH
54004: LD_VAR 0 2
54008: PPUSH
54009: LD_VAR 0 3
54013: PPUSH
54014: LD_VAR 0 4
54018: PPUSH
54019: CALL 54029 0 5
54023: ST_TO_ADDR
// end ;
54024: LD_VAR 0 5
54028: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54029: LD_INT 0
54031: PPUSH
54032: PPUSH
54033: PPUSH
54034: PPUSH
// if not list then
54035: LD_VAR 0 3
54039: NOT
54040: IFFALSE 54044
// exit ;
54042: GO 54432
// result := [ ] ;
54044: LD_ADDR_VAR 0 6
54048: PUSH
54049: EMPTY
54050: ST_TO_ADDR
// for i in list do
54051: LD_ADDR_VAR 0 7
54055: PUSH
54056: LD_VAR 0 3
54060: PUSH
54061: FOR_IN
54062: IFFALSE 54264
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54064: LD_ADDR_VAR 0 9
54068: PUSH
54069: LD_VAR 0 7
54073: PPUSH
54074: LD_VAR 0 1
54078: PPUSH
54079: LD_VAR 0 2
54083: PPUSH
54084: CALL_OW 297
54088: ST_TO_ADDR
// if not result then
54089: LD_VAR 0 6
54093: NOT
54094: IFFALSE 54120
// result := [ [ i , tmp ] ] else
54096: LD_ADDR_VAR 0 6
54100: PUSH
54101: LD_VAR 0 7
54105: PUSH
54106: LD_VAR 0 9
54110: PUSH
54111: EMPTY
54112: LIST
54113: LIST
54114: PUSH
54115: EMPTY
54116: LIST
54117: ST_TO_ADDR
54118: GO 54262
// begin if result [ result ] [ 2 ] < tmp then
54120: LD_VAR 0 6
54124: PUSH
54125: LD_VAR 0 6
54129: ARRAY
54130: PUSH
54131: LD_INT 2
54133: ARRAY
54134: PUSH
54135: LD_VAR 0 9
54139: LESS
54140: IFFALSE 54182
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54142: LD_ADDR_VAR 0 6
54146: PUSH
54147: LD_VAR 0 6
54151: PPUSH
54152: LD_VAR 0 6
54156: PUSH
54157: LD_INT 1
54159: PLUS
54160: PPUSH
54161: LD_VAR 0 7
54165: PUSH
54166: LD_VAR 0 9
54170: PUSH
54171: EMPTY
54172: LIST
54173: LIST
54174: PPUSH
54175: CALL_OW 2
54179: ST_TO_ADDR
54180: GO 54262
// for j = 1 to result do
54182: LD_ADDR_VAR 0 8
54186: PUSH
54187: DOUBLE
54188: LD_INT 1
54190: DEC
54191: ST_TO_ADDR
54192: LD_VAR 0 6
54196: PUSH
54197: FOR_TO
54198: IFFALSE 54260
// begin if tmp < result [ j ] [ 2 ] then
54200: LD_VAR 0 9
54204: PUSH
54205: LD_VAR 0 6
54209: PUSH
54210: LD_VAR 0 8
54214: ARRAY
54215: PUSH
54216: LD_INT 2
54218: ARRAY
54219: LESS
54220: IFFALSE 54258
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54222: LD_ADDR_VAR 0 6
54226: PUSH
54227: LD_VAR 0 6
54231: PPUSH
54232: LD_VAR 0 8
54236: PPUSH
54237: LD_VAR 0 7
54241: PUSH
54242: LD_VAR 0 9
54246: PUSH
54247: EMPTY
54248: LIST
54249: LIST
54250: PPUSH
54251: CALL_OW 2
54255: ST_TO_ADDR
// break ;
54256: GO 54260
// end ; end ;
54258: GO 54197
54260: POP
54261: POP
// end ; end ;
54262: GO 54061
54264: POP
54265: POP
// if result and not asc then
54266: LD_VAR 0 6
54270: PUSH
54271: LD_VAR 0 4
54275: NOT
54276: AND
54277: IFFALSE 54352
// begin tmp := result ;
54279: LD_ADDR_VAR 0 9
54283: PUSH
54284: LD_VAR 0 6
54288: ST_TO_ADDR
// for i = tmp downto 1 do
54289: LD_ADDR_VAR 0 7
54293: PUSH
54294: DOUBLE
54295: LD_VAR 0 9
54299: INC
54300: ST_TO_ADDR
54301: LD_INT 1
54303: PUSH
54304: FOR_DOWNTO
54305: IFFALSE 54350
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54307: LD_ADDR_VAR 0 6
54311: PUSH
54312: LD_VAR 0 6
54316: PPUSH
54317: LD_VAR 0 9
54321: PUSH
54322: LD_VAR 0 7
54326: MINUS
54327: PUSH
54328: LD_INT 1
54330: PLUS
54331: PPUSH
54332: LD_VAR 0 9
54336: PUSH
54337: LD_VAR 0 7
54341: ARRAY
54342: PPUSH
54343: CALL_OW 1
54347: ST_TO_ADDR
54348: GO 54304
54350: POP
54351: POP
// end ; tmp := [ ] ;
54352: LD_ADDR_VAR 0 9
54356: PUSH
54357: EMPTY
54358: ST_TO_ADDR
// if mode then
54359: LD_VAR 0 5
54363: IFFALSE 54432
// begin for i = 1 to result do
54365: LD_ADDR_VAR 0 7
54369: PUSH
54370: DOUBLE
54371: LD_INT 1
54373: DEC
54374: ST_TO_ADDR
54375: LD_VAR 0 6
54379: PUSH
54380: FOR_TO
54381: IFFALSE 54420
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54383: LD_ADDR_VAR 0 9
54387: PUSH
54388: LD_VAR 0 9
54392: PPUSH
54393: LD_VAR 0 7
54397: PPUSH
54398: LD_VAR 0 6
54402: PUSH
54403: LD_VAR 0 7
54407: ARRAY
54408: PUSH
54409: LD_INT 1
54411: ARRAY
54412: PPUSH
54413: CALL_OW 1
54417: ST_TO_ADDR
54418: GO 54380
54420: POP
54421: POP
// result := tmp ;
54422: LD_ADDR_VAR 0 6
54426: PUSH
54427: LD_VAR 0 9
54431: ST_TO_ADDR
// end ; end ;
54432: LD_VAR 0 6
54436: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54437: LD_INT 0
54439: PPUSH
54440: PPUSH
54441: PPUSH
54442: PPUSH
54443: PPUSH
54444: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54445: LD_ADDR_VAR 0 5
54449: PUSH
54450: LD_INT 0
54452: PUSH
54453: LD_INT 0
54455: PUSH
54456: LD_INT 0
54458: PUSH
54459: EMPTY
54460: PUSH
54461: EMPTY
54462: LIST
54463: LIST
54464: LIST
54465: LIST
54466: ST_TO_ADDR
// if not x or not y then
54467: LD_VAR 0 2
54471: NOT
54472: PUSH
54473: LD_VAR 0 3
54477: NOT
54478: OR
54479: IFFALSE 54483
// exit ;
54481: GO 56135
// if not range then
54483: LD_VAR 0 4
54487: NOT
54488: IFFALSE 54498
// range := 10 ;
54490: LD_ADDR_VAR 0 4
54494: PUSH
54495: LD_INT 10
54497: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54498: LD_ADDR_VAR 0 8
54502: PUSH
54503: LD_INT 81
54505: PUSH
54506: LD_VAR 0 1
54510: PUSH
54511: EMPTY
54512: LIST
54513: LIST
54514: PUSH
54515: LD_INT 92
54517: PUSH
54518: LD_VAR 0 2
54522: PUSH
54523: LD_VAR 0 3
54527: PUSH
54528: LD_VAR 0 4
54532: PUSH
54533: EMPTY
54534: LIST
54535: LIST
54536: LIST
54537: LIST
54538: PUSH
54539: LD_INT 3
54541: PUSH
54542: LD_INT 21
54544: PUSH
54545: LD_INT 3
54547: PUSH
54548: EMPTY
54549: LIST
54550: LIST
54551: PUSH
54552: EMPTY
54553: LIST
54554: LIST
54555: PUSH
54556: EMPTY
54557: LIST
54558: LIST
54559: LIST
54560: PPUSH
54561: CALL_OW 69
54565: ST_TO_ADDR
// if not tmp then
54566: LD_VAR 0 8
54570: NOT
54571: IFFALSE 54575
// exit ;
54573: GO 56135
// for i in tmp do
54575: LD_ADDR_VAR 0 6
54579: PUSH
54580: LD_VAR 0 8
54584: PUSH
54585: FOR_IN
54586: IFFALSE 56110
// begin points := [ 0 , 0 , 0 ] ;
54588: LD_ADDR_VAR 0 9
54592: PUSH
54593: LD_INT 0
54595: PUSH
54596: LD_INT 0
54598: PUSH
54599: LD_INT 0
54601: PUSH
54602: EMPTY
54603: LIST
54604: LIST
54605: LIST
54606: ST_TO_ADDR
// bpoints := 1 ;
54607: LD_ADDR_VAR 0 10
54611: PUSH
54612: LD_INT 1
54614: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54615: LD_VAR 0 6
54619: PPUSH
54620: CALL_OW 247
54624: PUSH
54625: LD_INT 1
54627: DOUBLE
54628: EQUAL
54629: IFTRUE 54633
54631: GO 55211
54633: POP
// begin if GetClass ( i ) = 1 then
54634: LD_VAR 0 6
54638: PPUSH
54639: CALL_OW 257
54643: PUSH
54644: LD_INT 1
54646: EQUAL
54647: IFFALSE 54668
// points := [ 10 , 5 , 3 ] ;
54649: LD_ADDR_VAR 0 9
54653: PUSH
54654: LD_INT 10
54656: PUSH
54657: LD_INT 5
54659: PUSH
54660: LD_INT 3
54662: PUSH
54663: EMPTY
54664: LIST
54665: LIST
54666: LIST
54667: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54668: LD_VAR 0 6
54672: PPUSH
54673: CALL_OW 257
54677: PUSH
54678: LD_INT 2
54680: PUSH
54681: LD_INT 3
54683: PUSH
54684: LD_INT 4
54686: PUSH
54687: EMPTY
54688: LIST
54689: LIST
54690: LIST
54691: IN
54692: IFFALSE 54713
// points := [ 3 , 2 , 1 ] ;
54694: LD_ADDR_VAR 0 9
54698: PUSH
54699: LD_INT 3
54701: PUSH
54702: LD_INT 2
54704: PUSH
54705: LD_INT 1
54707: PUSH
54708: EMPTY
54709: LIST
54710: LIST
54711: LIST
54712: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54713: LD_VAR 0 6
54717: PPUSH
54718: CALL_OW 257
54722: PUSH
54723: LD_INT 5
54725: EQUAL
54726: IFFALSE 54747
// points := [ 130 , 5 , 2 ] ;
54728: LD_ADDR_VAR 0 9
54732: PUSH
54733: LD_INT 130
54735: PUSH
54736: LD_INT 5
54738: PUSH
54739: LD_INT 2
54741: PUSH
54742: EMPTY
54743: LIST
54744: LIST
54745: LIST
54746: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54747: LD_VAR 0 6
54751: PPUSH
54752: CALL_OW 257
54756: PUSH
54757: LD_INT 8
54759: EQUAL
54760: IFFALSE 54781
// points := [ 35 , 35 , 30 ] ;
54762: LD_ADDR_VAR 0 9
54766: PUSH
54767: LD_INT 35
54769: PUSH
54770: LD_INT 35
54772: PUSH
54773: LD_INT 30
54775: PUSH
54776: EMPTY
54777: LIST
54778: LIST
54779: LIST
54780: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54781: LD_VAR 0 6
54785: PPUSH
54786: CALL_OW 257
54790: PUSH
54791: LD_INT 9
54793: EQUAL
54794: IFFALSE 54815
// points := [ 20 , 55 , 40 ] ;
54796: LD_ADDR_VAR 0 9
54800: PUSH
54801: LD_INT 20
54803: PUSH
54804: LD_INT 55
54806: PUSH
54807: LD_INT 40
54809: PUSH
54810: EMPTY
54811: LIST
54812: LIST
54813: LIST
54814: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54815: LD_VAR 0 6
54819: PPUSH
54820: CALL_OW 257
54824: PUSH
54825: LD_INT 12
54827: PUSH
54828: LD_INT 16
54830: PUSH
54831: EMPTY
54832: LIST
54833: LIST
54834: IN
54835: IFFALSE 54856
// points := [ 5 , 3 , 2 ] ;
54837: LD_ADDR_VAR 0 9
54841: PUSH
54842: LD_INT 5
54844: PUSH
54845: LD_INT 3
54847: PUSH
54848: LD_INT 2
54850: PUSH
54851: EMPTY
54852: LIST
54853: LIST
54854: LIST
54855: ST_TO_ADDR
// if GetClass ( i ) = 17 then
54856: LD_VAR 0 6
54860: PPUSH
54861: CALL_OW 257
54865: PUSH
54866: LD_INT 17
54868: EQUAL
54869: IFFALSE 54890
// points := [ 100 , 50 , 75 ] ;
54871: LD_ADDR_VAR 0 9
54875: PUSH
54876: LD_INT 100
54878: PUSH
54879: LD_INT 50
54881: PUSH
54882: LD_INT 75
54884: PUSH
54885: EMPTY
54886: LIST
54887: LIST
54888: LIST
54889: ST_TO_ADDR
// if GetClass ( i ) = 15 then
54890: LD_VAR 0 6
54894: PPUSH
54895: CALL_OW 257
54899: PUSH
54900: LD_INT 15
54902: EQUAL
54903: IFFALSE 54924
// points := [ 10 , 5 , 3 ] ;
54905: LD_ADDR_VAR 0 9
54909: PUSH
54910: LD_INT 10
54912: PUSH
54913: LD_INT 5
54915: PUSH
54916: LD_INT 3
54918: PUSH
54919: EMPTY
54920: LIST
54921: LIST
54922: LIST
54923: ST_TO_ADDR
// if GetClass ( i ) = 14 then
54924: LD_VAR 0 6
54928: PPUSH
54929: CALL_OW 257
54933: PUSH
54934: LD_INT 14
54936: EQUAL
54937: IFFALSE 54958
// points := [ 10 , 0 , 0 ] ;
54939: LD_ADDR_VAR 0 9
54943: PUSH
54944: LD_INT 10
54946: PUSH
54947: LD_INT 0
54949: PUSH
54950: LD_INT 0
54952: PUSH
54953: EMPTY
54954: LIST
54955: LIST
54956: LIST
54957: ST_TO_ADDR
// if GetClass ( i ) = 11 then
54958: LD_VAR 0 6
54962: PPUSH
54963: CALL_OW 257
54967: PUSH
54968: LD_INT 11
54970: EQUAL
54971: IFFALSE 54992
// points := [ 30 , 10 , 5 ] ;
54973: LD_ADDR_VAR 0 9
54977: PUSH
54978: LD_INT 30
54980: PUSH
54981: LD_INT 10
54983: PUSH
54984: LD_INT 5
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: LIST
54991: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
54992: LD_VAR 0 1
54996: PPUSH
54997: LD_INT 5
54999: PPUSH
55000: CALL_OW 321
55004: PUSH
55005: LD_INT 2
55007: EQUAL
55008: IFFALSE 55025
// bpoints := bpoints * 1.8 ;
55010: LD_ADDR_VAR 0 10
55014: PUSH
55015: LD_VAR 0 10
55019: PUSH
55020: LD_REAL  1.80000000000000E+0000
55023: MUL
55024: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55025: LD_VAR 0 6
55029: PPUSH
55030: CALL_OW 257
55034: PUSH
55035: LD_INT 1
55037: PUSH
55038: LD_INT 2
55040: PUSH
55041: LD_INT 3
55043: PUSH
55044: LD_INT 4
55046: PUSH
55047: EMPTY
55048: LIST
55049: LIST
55050: LIST
55051: LIST
55052: IN
55053: PUSH
55054: LD_VAR 0 1
55058: PPUSH
55059: LD_INT 51
55061: PPUSH
55062: CALL_OW 321
55066: PUSH
55067: LD_INT 2
55069: EQUAL
55070: AND
55071: IFFALSE 55088
// bpoints := bpoints * 1.2 ;
55073: LD_ADDR_VAR 0 10
55077: PUSH
55078: LD_VAR 0 10
55082: PUSH
55083: LD_REAL  1.20000000000000E+0000
55086: MUL
55087: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55088: LD_VAR 0 6
55092: PPUSH
55093: CALL_OW 257
55097: PUSH
55098: LD_INT 5
55100: PUSH
55101: LD_INT 7
55103: PUSH
55104: LD_INT 9
55106: PUSH
55107: EMPTY
55108: LIST
55109: LIST
55110: LIST
55111: IN
55112: PUSH
55113: LD_VAR 0 1
55117: PPUSH
55118: LD_INT 52
55120: PPUSH
55121: CALL_OW 321
55125: PUSH
55126: LD_INT 2
55128: EQUAL
55129: AND
55130: IFFALSE 55147
// bpoints := bpoints * 1.5 ;
55132: LD_ADDR_VAR 0 10
55136: PUSH
55137: LD_VAR 0 10
55141: PUSH
55142: LD_REAL  1.50000000000000E+0000
55145: MUL
55146: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55147: LD_VAR 0 1
55151: PPUSH
55152: LD_INT 66
55154: PPUSH
55155: CALL_OW 321
55159: PUSH
55160: LD_INT 2
55162: EQUAL
55163: IFFALSE 55180
// bpoints := bpoints * 1.1 ;
55165: LD_ADDR_VAR 0 10
55169: PUSH
55170: LD_VAR 0 10
55174: PUSH
55175: LD_REAL  1.10000000000000E+0000
55178: MUL
55179: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55180: LD_ADDR_VAR 0 10
55184: PUSH
55185: LD_VAR 0 10
55189: PUSH
55190: LD_VAR 0 6
55194: PPUSH
55195: LD_INT 1
55197: PPUSH
55198: CALL_OW 259
55202: PUSH
55203: LD_REAL  1.15000000000000E+0000
55206: MUL
55207: MUL
55208: ST_TO_ADDR
// end ; unit_vehicle :
55209: GO 56039
55211: LD_INT 2
55213: DOUBLE
55214: EQUAL
55215: IFTRUE 55219
55217: GO 56027
55219: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55220: LD_VAR 0 6
55224: PPUSH
55225: CALL_OW 264
55229: PUSH
55230: LD_INT 2
55232: PUSH
55233: LD_INT 42
55235: PUSH
55236: LD_INT 24
55238: PUSH
55239: EMPTY
55240: LIST
55241: LIST
55242: LIST
55243: IN
55244: IFFALSE 55265
// points := [ 25 , 5 , 3 ] ;
55246: LD_ADDR_VAR 0 9
55250: PUSH
55251: LD_INT 25
55253: PUSH
55254: LD_INT 5
55256: PUSH
55257: LD_INT 3
55259: PUSH
55260: EMPTY
55261: LIST
55262: LIST
55263: LIST
55264: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55265: LD_VAR 0 6
55269: PPUSH
55270: CALL_OW 264
55274: PUSH
55275: LD_INT 4
55277: PUSH
55278: LD_INT 43
55280: PUSH
55281: LD_INT 25
55283: PUSH
55284: EMPTY
55285: LIST
55286: LIST
55287: LIST
55288: IN
55289: IFFALSE 55310
// points := [ 40 , 15 , 5 ] ;
55291: LD_ADDR_VAR 0 9
55295: PUSH
55296: LD_INT 40
55298: PUSH
55299: LD_INT 15
55301: PUSH
55302: LD_INT 5
55304: PUSH
55305: EMPTY
55306: LIST
55307: LIST
55308: LIST
55309: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55310: LD_VAR 0 6
55314: PPUSH
55315: CALL_OW 264
55319: PUSH
55320: LD_INT 3
55322: PUSH
55323: LD_INT 23
55325: PUSH
55326: EMPTY
55327: LIST
55328: LIST
55329: IN
55330: IFFALSE 55351
// points := [ 7 , 25 , 8 ] ;
55332: LD_ADDR_VAR 0 9
55336: PUSH
55337: LD_INT 7
55339: PUSH
55340: LD_INT 25
55342: PUSH
55343: LD_INT 8
55345: PUSH
55346: EMPTY
55347: LIST
55348: LIST
55349: LIST
55350: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55351: LD_VAR 0 6
55355: PPUSH
55356: CALL_OW 264
55360: PUSH
55361: LD_INT 5
55363: PUSH
55364: LD_INT 27
55366: PUSH
55367: LD_INT 44
55369: PUSH
55370: EMPTY
55371: LIST
55372: LIST
55373: LIST
55374: IN
55375: IFFALSE 55396
// points := [ 14 , 50 , 16 ] ;
55377: LD_ADDR_VAR 0 9
55381: PUSH
55382: LD_INT 14
55384: PUSH
55385: LD_INT 50
55387: PUSH
55388: LD_INT 16
55390: PUSH
55391: EMPTY
55392: LIST
55393: LIST
55394: LIST
55395: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55396: LD_VAR 0 6
55400: PPUSH
55401: CALL_OW 264
55405: PUSH
55406: LD_INT 6
55408: PUSH
55409: LD_INT 46
55411: PUSH
55412: EMPTY
55413: LIST
55414: LIST
55415: IN
55416: IFFALSE 55437
// points := [ 32 , 120 , 70 ] ;
55418: LD_ADDR_VAR 0 9
55422: PUSH
55423: LD_INT 32
55425: PUSH
55426: LD_INT 120
55428: PUSH
55429: LD_INT 70
55431: PUSH
55432: EMPTY
55433: LIST
55434: LIST
55435: LIST
55436: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55437: LD_VAR 0 6
55441: PPUSH
55442: CALL_OW 264
55446: PUSH
55447: LD_INT 7
55449: PUSH
55450: LD_INT 28
55452: PUSH
55453: LD_INT 45
55455: PUSH
55456: LD_EXP 99
55460: PUSH
55461: EMPTY
55462: LIST
55463: LIST
55464: LIST
55465: LIST
55466: IN
55467: IFFALSE 55488
// points := [ 35 , 20 , 45 ] ;
55469: LD_ADDR_VAR 0 9
55473: PUSH
55474: LD_INT 35
55476: PUSH
55477: LD_INT 20
55479: PUSH
55480: LD_INT 45
55482: PUSH
55483: EMPTY
55484: LIST
55485: LIST
55486: LIST
55487: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55488: LD_VAR 0 6
55492: PPUSH
55493: CALL_OW 264
55497: PUSH
55498: LD_INT 47
55500: PUSH
55501: EMPTY
55502: LIST
55503: IN
55504: IFFALSE 55525
// points := [ 67 , 45 , 75 ] ;
55506: LD_ADDR_VAR 0 9
55510: PUSH
55511: LD_INT 67
55513: PUSH
55514: LD_INT 45
55516: PUSH
55517: LD_INT 75
55519: PUSH
55520: EMPTY
55521: LIST
55522: LIST
55523: LIST
55524: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55525: LD_VAR 0 6
55529: PPUSH
55530: CALL_OW 264
55534: PUSH
55535: LD_INT 26
55537: PUSH
55538: EMPTY
55539: LIST
55540: IN
55541: IFFALSE 55562
// points := [ 120 , 30 , 80 ] ;
55543: LD_ADDR_VAR 0 9
55547: PUSH
55548: LD_INT 120
55550: PUSH
55551: LD_INT 30
55553: PUSH
55554: LD_INT 80
55556: PUSH
55557: EMPTY
55558: LIST
55559: LIST
55560: LIST
55561: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55562: LD_VAR 0 6
55566: PPUSH
55567: CALL_OW 264
55571: PUSH
55572: LD_INT 22
55574: PUSH
55575: EMPTY
55576: LIST
55577: IN
55578: IFFALSE 55599
// points := [ 40 , 1 , 1 ] ;
55580: LD_ADDR_VAR 0 9
55584: PUSH
55585: LD_INT 40
55587: PUSH
55588: LD_INT 1
55590: PUSH
55591: LD_INT 1
55593: PUSH
55594: EMPTY
55595: LIST
55596: LIST
55597: LIST
55598: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55599: LD_VAR 0 6
55603: PPUSH
55604: CALL_OW 264
55608: PUSH
55609: LD_INT 29
55611: PUSH
55612: EMPTY
55613: LIST
55614: IN
55615: IFFALSE 55636
// points := [ 70 , 200 , 400 ] ;
55617: LD_ADDR_VAR 0 9
55621: PUSH
55622: LD_INT 70
55624: PUSH
55625: LD_INT 200
55627: PUSH
55628: LD_INT 400
55630: PUSH
55631: EMPTY
55632: LIST
55633: LIST
55634: LIST
55635: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55636: LD_VAR 0 6
55640: PPUSH
55641: CALL_OW 264
55645: PUSH
55646: LD_INT 14
55648: PUSH
55649: LD_INT 53
55651: PUSH
55652: EMPTY
55653: LIST
55654: LIST
55655: IN
55656: IFFALSE 55677
// points := [ 40 , 10 , 20 ] ;
55658: LD_ADDR_VAR 0 9
55662: PUSH
55663: LD_INT 40
55665: PUSH
55666: LD_INT 10
55668: PUSH
55669: LD_INT 20
55671: PUSH
55672: EMPTY
55673: LIST
55674: LIST
55675: LIST
55676: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55677: LD_VAR 0 6
55681: PPUSH
55682: CALL_OW 264
55686: PUSH
55687: LD_INT 9
55689: PUSH
55690: EMPTY
55691: LIST
55692: IN
55693: IFFALSE 55714
// points := [ 5 , 70 , 20 ] ;
55695: LD_ADDR_VAR 0 9
55699: PUSH
55700: LD_INT 5
55702: PUSH
55703: LD_INT 70
55705: PUSH
55706: LD_INT 20
55708: PUSH
55709: EMPTY
55710: LIST
55711: LIST
55712: LIST
55713: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55714: LD_VAR 0 6
55718: PPUSH
55719: CALL_OW 264
55723: PUSH
55724: LD_INT 10
55726: PUSH
55727: EMPTY
55728: LIST
55729: IN
55730: IFFALSE 55751
// points := [ 35 , 110 , 70 ] ;
55732: LD_ADDR_VAR 0 9
55736: PUSH
55737: LD_INT 35
55739: PUSH
55740: LD_INT 110
55742: PUSH
55743: LD_INT 70
55745: PUSH
55746: EMPTY
55747: LIST
55748: LIST
55749: LIST
55750: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55751: LD_VAR 0 6
55755: PPUSH
55756: CALL_OW 265
55760: PUSH
55761: LD_INT 25
55763: EQUAL
55764: IFFALSE 55785
// points := [ 80 , 65 , 100 ] ;
55766: LD_ADDR_VAR 0 9
55770: PUSH
55771: LD_INT 80
55773: PUSH
55774: LD_INT 65
55776: PUSH
55777: LD_INT 100
55779: PUSH
55780: EMPTY
55781: LIST
55782: LIST
55783: LIST
55784: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55785: LD_VAR 0 6
55789: PPUSH
55790: CALL_OW 263
55794: PUSH
55795: LD_INT 1
55797: EQUAL
55798: IFFALSE 55833
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55800: LD_ADDR_VAR 0 10
55804: PUSH
55805: LD_VAR 0 10
55809: PUSH
55810: LD_VAR 0 6
55814: PPUSH
55815: CALL_OW 311
55819: PPUSH
55820: LD_INT 3
55822: PPUSH
55823: CALL_OW 259
55827: PUSH
55828: LD_INT 4
55830: MUL
55831: MUL
55832: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
55833: LD_VAR 0 6
55837: PPUSH
55838: CALL_OW 263
55842: PUSH
55843: LD_INT 2
55845: EQUAL
55846: IFFALSE 55897
// begin j := IsControledBy ( i ) ;
55848: LD_ADDR_VAR 0 7
55852: PUSH
55853: LD_VAR 0 6
55857: PPUSH
55858: CALL_OW 312
55862: ST_TO_ADDR
// if j then
55863: LD_VAR 0 7
55867: IFFALSE 55897
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
55869: LD_ADDR_VAR 0 10
55873: PUSH
55874: LD_VAR 0 10
55878: PUSH
55879: LD_VAR 0 7
55883: PPUSH
55884: LD_INT 3
55886: PPUSH
55887: CALL_OW 259
55891: PUSH
55892: LD_INT 3
55894: MUL
55895: MUL
55896: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
55897: LD_VAR 0 6
55901: PPUSH
55902: CALL_OW 264
55906: PUSH
55907: LD_INT 5
55909: PUSH
55910: LD_INT 6
55912: PUSH
55913: LD_INT 46
55915: PUSH
55916: LD_INT 44
55918: PUSH
55919: LD_INT 47
55921: PUSH
55922: LD_INT 45
55924: PUSH
55925: LD_INT 28
55927: PUSH
55928: LD_INT 7
55930: PUSH
55931: LD_INT 27
55933: PUSH
55934: LD_INT 29
55936: PUSH
55937: EMPTY
55938: LIST
55939: LIST
55940: LIST
55941: LIST
55942: LIST
55943: LIST
55944: LIST
55945: LIST
55946: LIST
55947: LIST
55948: IN
55949: PUSH
55950: LD_VAR 0 1
55954: PPUSH
55955: LD_INT 52
55957: PPUSH
55958: CALL_OW 321
55962: PUSH
55963: LD_INT 2
55965: EQUAL
55966: AND
55967: IFFALSE 55984
// bpoints := bpoints * 1.2 ;
55969: LD_ADDR_VAR 0 10
55973: PUSH
55974: LD_VAR 0 10
55978: PUSH
55979: LD_REAL  1.20000000000000E+0000
55982: MUL
55983: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
55984: LD_VAR 0 6
55988: PPUSH
55989: CALL_OW 264
55993: PUSH
55994: LD_INT 6
55996: PUSH
55997: LD_INT 46
55999: PUSH
56000: LD_INT 47
56002: PUSH
56003: EMPTY
56004: LIST
56005: LIST
56006: LIST
56007: IN
56008: IFFALSE 56025
// bpoints := bpoints * 1.2 ;
56010: LD_ADDR_VAR 0 10
56014: PUSH
56015: LD_VAR 0 10
56019: PUSH
56020: LD_REAL  1.20000000000000E+0000
56023: MUL
56024: ST_TO_ADDR
// end ; unit_building :
56025: GO 56039
56027: LD_INT 3
56029: DOUBLE
56030: EQUAL
56031: IFTRUE 56035
56033: GO 56038
56035: POP
// ; end ;
56036: GO 56039
56038: POP
// for j = 1 to 3 do
56039: LD_ADDR_VAR 0 7
56043: PUSH
56044: DOUBLE
56045: LD_INT 1
56047: DEC
56048: ST_TO_ADDR
56049: LD_INT 3
56051: PUSH
56052: FOR_TO
56053: IFFALSE 56106
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56055: LD_ADDR_VAR 0 5
56059: PUSH
56060: LD_VAR 0 5
56064: PPUSH
56065: LD_VAR 0 7
56069: PPUSH
56070: LD_VAR 0 5
56074: PUSH
56075: LD_VAR 0 7
56079: ARRAY
56080: PUSH
56081: LD_VAR 0 9
56085: PUSH
56086: LD_VAR 0 7
56090: ARRAY
56091: PUSH
56092: LD_VAR 0 10
56096: MUL
56097: PLUS
56098: PPUSH
56099: CALL_OW 1
56103: ST_TO_ADDR
56104: GO 56052
56106: POP
56107: POP
// end ;
56108: GO 54585
56110: POP
56111: POP
// result := Replace ( result , 4 , tmp ) ;
56112: LD_ADDR_VAR 0 5
56116: PUSH
56117: LD_VAR 0 5
56121: PPUSH
56122: LD_INT 4
56124: PPUSH
56125: LD_VAR 0 8
56129: PPUSH
56130: CALL_OW 1
56134: ST_TO_ADDR
// end ;
56135: LD_VAR 0 5
56139: RET
// export function DangerAtRange ( unit , range ) ; begin
56140: LD_INT 0
56142: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56143: LD_ADDR_VAR 0 3
56147: PUSH
56148: LD_VAR 0 1
56152: PPUSH
56153: CALL_OW 255
56157: PPUSH
56158: LD_VAR 0 1
56162: PPUSH
56163: CALL_OW 250
56167: PPUSH
56168: LD_VAR 0 1
56172: PPUSH
56173: CALL_OW 251
56177: PPUSH
56178: LD_VAR 0 2
56182: PPUSH
56183: CALL 54437 0 4
56187: ST_TO_ADDR
// end ;
56188: LD_VAR 0 3
56192: RET
// export function DangerInArea ( side , area ) ; begin
56193: LD_INT 0
56195: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56196: LD_ADDR_VAR 0 3
56200: PUSH
56201: LD_VAR 0 2
56205: PPUSH
56206: LD_INT 81
56208: PUSH
56209: LD_VAR 0 1
56213: PUSH
56214: EMPTY
56215: LIST
56216: LIST
56217: PPUSH
56218: CALL_OW 70
56222: ST_TO_ADDR
// end ;
56223: LD_VAR 0 3
56227: RET
// export function IsExtension ( b ) ; begin
56228: LD_INT 0
56230: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56231: LD_ADDR_VAR 0 2
56235: PUSH
56236: LD_VAR 0 1
56240: PUSH
56241: LD_INT 23
56243: PUSH
56244: LD_INT 20
56246: PUSH
56247: LD_INT 22
56249: PUSH
56250: LD_INT 17
56252: PUSH
56253: LD_INT 24
56255: PUSH
56256: LD_INT 21
56258: PUSH
56259: LD_INT 19
56261: PUSH
56262: LD_INT 16
56264: PUSH
56265: LD_INT 25
56267: PUSH
56268: LD_INT 18
56270: PUSH
56271: EMPTY
56272: LIST
56273: LIST
56274: LIST
56275: LIST
56276: LIST
56277: LIST
56278: LIST
56279: LIST
56280: LIST
56281: LIST
56282: IN
56283: ST_TO_ADDR
// end ;
56284: LD_VAR 0 2
56288: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56289: LD_INT 0
56291: PPUSH
56292: PPUSH
56293: PPUSH
// result := [ ] ;
56294: LD_ADDR_VAR 0 4
56298: PUSH
56299: EMPTY
56300: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56301: LD_ADDR_VAR 0 5
56305: PUSH
56306: LD_VAR 0 2
56310: PPUSH
56311: LD_INT 21
56313: PUSH
56314: LD_INT 3
56316: PUSH
56317: EMPTY
56318: LIST
56319: LIST
56320: PPUSH
56321: CALL_OW 70
56325: ST_TO_ADDR
// if not tmp then
56326: LD_VAR 0 5
56330: NOT
56331: IFFALSE 56335
// exit ;
56333: GO 56399
// if checkLink then
56335: LD_VAR 0 3
56339: IFFALSE 56389
// begin for i in tmp do
56341: LD_ADDR_VAR 0 6
56345: PUSH
56346: LD_VAR 0 5
56350: PUSH
56351: FOR_IN
56352: IFFALSE 56387
// if GetBase ( i ) <> base then
56354: LD_VAR 0 6
56358: PPUSH
56359: CALL_OW 274
56363: PUSH
56364: LD_VAR 0 1
56368: NONEQUAL
56369: IFFALSE 56385
// ComLinkToBase ( base , i ) ;
56371: LD_VAR 0 1
56375: PPUSH
56376: LD_VAR 0 6
56380: PPUSH
56381: CALL_OW 169
56385: GO 56351
56387: POP
56388: POP
// end ; result := tmp ;
56389: LD_ADDR_VAR 0 4
56393: PUSH
56394: LD_VAR 0 5
56398: ST_TO_ADDR
// end ;
56399: LD_VAR 0 4
56403: RET
// export function ComComplete ( units , b ) ; var i ; begin
56404: LD_INT 0
56406: PPUSH
56407: PPUSH
// if not units then
56408: LD_VAR 0 1
56412: NOT
56413: IFFALSE 56417
// exit ;
56415: GO 56507
// for i in units do
56417: LD_ADDR_VAR 0 4
56421: PUSH
56422: LD_VAR 0 1
56426: PUSH
56427: FOR_IN
56428: IFFALSE 56505
// if BuildingStatus ( b ) = bs_build then
56430: LD_VAR 0 2
56434: PPUSH
56435: CALL_OW 461
56439: PUSH
56440: LD_INT 1
56442: EQUAL
56443: IFFALSE 56503
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56445: LD_VAR 0 4
56449: PPUSH
56450: LD_STRING h
56452: PUSH
56453: LD_VAR 0 2
56457: PPUSH
56458: CALL_OW 250
56462: PUSH
56463: LD_VAR 0 2
56467: PPUSH
56468: CALL_OW 251
56472: PUSH
56473: LD_VAR 0 2
56477: PUSH
56478: LD_INT 0
56480: PUSH
56481: LD_INT 0
56483: PUSH
56484: LD_INT 0
56486: PUSH
56487: EMPTY
56488: LIST
56489: LIST
56490: LIST
56491: LIST
56492: LIST
56493: LIST
56494: LIST
56495: PUSH
56496: EMPTY
56497: LIST
56498: PPUSH
56499: CALL_OW 446
56503: GO 56427
56505: POP
56506: POP
// end ;
56507: LD_VAR 0 3
56511: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56512: LD_INT 0
56514: PPUSH
56515: PPUSH
56516: PPUSH
56517: PPUSH
56518: PPUSH
56519: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
56520: LD_VAR 0 1
56524: NOT
56525: PUSH
56526: LD_VAR 0 1
56530: PPUSH
56531: CALL_OW 263
56535: PUSH
56536: LD_INT 2
56538: NONEQUAL
56539: OR
56540: IFFALSE 56544
// exit ;
56542: GO 56860
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56544: LD_ADDR_VAR 0 6
56548: PUSH
56549: LD_INT 22
56551: PUSH
56552: LD_VAR 0 1
56556: PPUSH
56557: CALL_OW 255
56561: PUSH
56562: EMPTY
56563: LIST
56564: LIST
56565: PUSH
56566: LD_INT 2
56568: PUSH
56569: LD_INT 30
56571: PUSH
56572: LD_INT 36
56574: PUSH
56575: EMPTY
56576: LIST
56577: LIST
56578: PUSH
56579: LD_INT 34
56581: PUSH
56582: LD_INT 31
56584: PUSH
56585: EMPTY
56586: LIST
56587: LIST
56588: PUSH
56589: EMPTY
56590: LIST
56591: LIST
56592: LIST
56593: PUSH
56594: EMPTY
56595: LIST
56596: LIST
56597: PPUSH
56598: CALL_OW 69
56602: ST_TO_ADDR
// if not tmp then
56603: LD_VAR 0 6
56607: NOT
56608: IFFALSE 56612
// exit ;
56610: GO 56860
// result := [ ] ;
56612: LD_ADDR_VAR 0 2
56616: PUSH
56617: EMPTY
56618: ST_TO_ADDR
// for i in tmp do
56619: LD_ADDR_VAR 0 3
56623: PUSH
56624: LD_VAR 0 6
56628: PUSH
56629: FOR_IN
56630: IFFALSE 56701
// begin t := UnitsInside ( i ) ;
56632: LD_ADDR_VAR 0 4
56636: PUSH
56637: LD_VAR 0 3
56641: PPUSH
56642: CALL_OW 313
56646: ST_TO_ADDR
// if t then
56647: LD_VAR 0 4
56651: IFFALSE 56699
// for j in t do
56653: LD_ADDR_VAR 0 7
56657: PUSH
56658: LD_VAR 0 4
56662: PUSH
56663: FOR_IN
56664: IFFALSE 56697
// result := Replace ( result , result + 1 , j ) ;
56666: LD_ADDR_VAR 0 2
56670: PUSH
56671: LD_VAR 0 2
56675: PPUSH
56676: LD_VAR 0 2
56680: PUSH
56681: LD_INT 1
56683: PLUS
56684: PPUSH
56685: LD_VAR 0 7
56689: PPUSH
56690: CALL_OW 1
56694: ST_TO_ADDR
56695: GO 56663
56697: POP
56698: POP
// end ;
56699: GO 56629
56701: POP
56702: POP
// if not result then
56703: LD_VAR 0 2
56707: NOT
56708: IFFALSE 56712
// exit ;
56710: GO 56860
// mech := result [ 1 ] ;
56712: LD_ADDR_VAR 0 5
56716: PUSH
56717: LD_VAR 0 2
56721: PUSH
56722: LD_INT 1
56724: ARRAY
56725: ST_TO_ADDR
// if result > 1 then
56726: LD_VAR 0 2
56730: PUSH
56731: LD_INT 1
56733: GREATER
56734: IFFALSE 56846
// begin for i = 2 to result do
56736: LD_ADDR_VAR 0 3
56740: PUSH
56741: DOUBLE
56742: LD_INT 2
56744: DEC
56745: ST_TO_ADDR
56746: LD_VAR 0 2
56750: PUSH
56751: FOR_TO
56752: IFFALSE 56844
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56754: LD_ADDR_VAR 0 4
56758: PUSH
56759: LD_VAR 0 2
56763: PUSH
56764: LD_VAR 0 3
56768: ARRAY
56769: PPUSH
56770: LD_INT 3
56772: PPUSH
56773: CALL_OW 259
56777: PUSH
56778: LD_VAR 0 2
56782: PUSH
56783: LD_VAR 0 3
56787: ARRAY
56788: PPUSH
56789: CALL_OW 432
56793: MINUS
56794: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56795: LD_VAR 0 4
56799: PUSH
56800: LD_VAR 0 5
56804: PPUSH
56805: LD_INT 3
56807: PPUSH
56808: CALL_OW 259
56812: PUSH
56813: LD_VAR 0 5
56817: PPUSH
56818: CALL_OW 432
56822: MINUS
56823: GREATEREQUAL
56824: IFFALSE 56842
// mech := result [ i ] ;
56826: LD_ADDR_VAR 0 5
56830: PUSH
56831: LD_VAR 0 2
56835: PUSH
56836: LD_VAR 0 3
56840: ARRAY
56841: ST_TO_ADDR
// end ;
56842: GO 56751
56844: POP
56845: POP
// end ; ComLinkTo ( vehicle , mech ) ;
56846: LD_VAR 0 1
56850: PPUSH
56851: LD_VAR 0 5
56855: PPUSH
56856: CALL_OW 135
// end ;
56860: LD_VAR 0 2
56864: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
56865: LD_INT 0
56867: PPUSH
56868: PPUSH
56869: PPUSH
56870: PPUSH
56871: PPUSH
56872: PPUSH
56873: PPUSH
56874: PPUSH
56875: PPUSH
56876: PPUSH
56877: PPUSH
56878: PPUSH
56879: PPUSH
// result := [ ] ;
56880: LD_ADDR_VAR 0 7
56884: PUSH
56885: EMPTY
56886: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
56887: LD_VAR 0 1
56891: PPUSH
56892: CALL_OW 266
56896: PUSH
56897: LD_INT 0
56899: PUSH
56900: LD_INT 1
56902: PUSH
56903: EMPTY
56904: LIST
56905: LIST
56906: IN
56907: NOT
56908: IFFALSE 56912
// exit ;
56910: GO 58546
// if name then
56912: LD_VAR 0 3
56916: IFFALSE 56932
// SetBName ( base_dep , name ) ;
56918: LD_VAR 0 1
56922: PPUSH
56923: LD_VAR 0 3
56927: PPUSH
56928: CALL_OW 500
// base := GetBase ( base_dep ) ;
56932: LD_ADDR_VAR 0 15
56936: PUSH
56937: LD_VAR 0 1
56941: PPUSH
56942: CALL_OW 274
56946: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
56947: LD_ADDR_VAR 0 16
56951: PUSH
56952: LD_VAR 0 1
56956: PPUSH
56957: CALL_OW 255
56961: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
56962: LD_ADDR_VAR 0 17
56966: PUSH
56967: LD_VAR 0 1
56971: PPUSH
56972: CALL_OW 248
56976: ST_TO_ADDR
// if sources then
56977: LD_VAR 0 5
56981: IFFALSE 57028
// for i = 1 to 3 do
56983: LD_ADDR_VAR 0 8
56987: PUSH
56988: DOUBLE
56989: LD_INT 1
56991: DEC
56992: ST_TO_ADDR
56993: LD_INT 3
56995: PUSH
56996: FOR_TO
56997: IFFALSE 57026
// AddResourceType ( base , i , sources [ i ] ) ;
56999: LD_VAR 0 15
57003: PPUSH
57004: LD_VAR 0 8
57008: PPUSH
57009: LD_VAR 0 5
57013: PUSH
57014: LD_VAR 0 8
57018: ARRAY
57019: PPUSH
57020: CALL_OW 276
57024: GO 56996
57026: POP
57027: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57028: LD_ADDR_VAR 0 18
57032: PUSH
57033: LD_VAR 0 15
57037: PPUSH
57038: LD_VAR 0 2
57042: PPUSH
57043: LD_INT 1
57045: PPUSH
57046: CALL 56289 0 3
57050: ST_TO_ADDR
// InitHc ;
57051: CALL_OW 19
// InitUc ;
57055: CALL_OW 18
// uc_side := side ;
57059: LD_ADDR_OWVAR 20
57063: PUSH
57064: LD_VAR 0 16
57068: ST_TO_ADDR
// uc_nation := nation ;
57069: LD_ADDR_OWVAR 21
57073: PUSH
57074: LD_VAR 0 17
57078: ST_TO_ADDR
// if buildings then
57079: LD_VAR 0 18
57083: IFFALSE 58405
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57085: LD_ADDR_VAR 0 19
57089: PUSH
57090: LD_VAR 0 18
57094: PPUSH
57095: LD_INT 2
57097: PUSH
57098: LD_INT 30
57100: PUSH
57101: LD_INT 29
57103: PUSH
57104: EMPTY
57105: LIST
57106: LIST
57107: PUSH
57108: LD_INT 30
57110: PUSH
57111: LD_INT 30
57113: PUSH
57114: EMPTY
57115: LIST
57116: LIST
57117: PUSH
57118: EMPTY
57119: LIST
57120: LIST
57121: LIST
57122: PPUSH
57123: CALL_OW 72
57127: ST_TO_ADDR
// if tmp then
57128: LD_VAR 0 19
57132: IFFALSE 57180
// for i in tmp do
57134: LD_ADDR_VAR 0 8
57138: PUSH
57139: LD_VAR 0 19
57143: PUSH
57144: FOR_IN
57145: IFFALSE 57178
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57147: LD_VAR 0 8
57151: PPUSH
57152: CALL_OW 250
57156: PPUSH
57157: LD_VAR 0 8
57161: PPUSH
57162: CALL_OW 251
57166: PPUSH
57167: LD_VAR 0 16
57171: PPUSH
57172: CALL_OW 441
57176: GO 57144
57178: POP
57179: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57180: LD_VAR 0 18
57184: PPUSH
57185: LD_INT 2
57187: PUSH
57188: LD_INT 30
57190: PUSH
57191: LD_INT 32
57193: PUSH
57194: EMPTY
57195: LIST
57196: LIST
57197: PUSH
57198: LD_INT 30
57200: PUSH
57201: LD_INT 33
57203: PUSH
57204: EMPTY
57205: LIST
57206: LIST
57207: PUSH
57208: EMPTY
57209: LIST
57210: LIST
57211: LIST
57212: PPUSH
57213: CALL_OW 72
57217: IFFALSE 57305
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57219: LD_ADDR_VAR 0 8
57223: PUSH
57224: LD_VAR 0 18
57228: PPUSH
57229: LD_INT 2
57231: PUSH
57232: LD_INT 30
57234: PUSH
57235: LD_INT 32
57237: PUSH
57238: EMPTY
57239: LIST
57240: LIST
57241: PUSH
57242: LD_INT 30
57244: PUSH
57245: LD_INT 33
57247: PUSH
57248: EMPTY
57249: LIST
57250: LIST
57251: PUSH
57252: EMPTY
57253: LIST
57254: LIST
57255: LIST
57256: PPUSH
57257: CALL_OW 72
57261: PUSH
57262: FOR_IN
57263: IFFALSE 57303
// begin if not GetBWeapon ( i ) then
57265: LD_VAR 0 8
57269: PPUSH
57270: CALL_OW 269
57274: NOT
57275: IFFALSE 57301
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57277: LD_VAR 0 8
57281: PPUSH
57282: LD_VAR 0 8
57286: PPUSH
57287: LD_VAR 0 2
57291: PPUSH
57292: CALL 58551 0 2
57296: PPUSH
57297: CALL_OW 431
// end ;
57301: GO 57262
57303: POP
57304: POP
// end ; for i = 1 to personel do
57305: LD_ADDR_VAR 0 8
57309: PUSH
57310: DOUBLE
57311: LD_INT 1
57313: DEC
57314: ST_TO_ADDR
57315: LD_VAR 0 6
57319: PUSH
57320: FOR_TO
57321: IFFALSE 58385
// begin if i > 4 then
57323: LD_VAR 0 8
57327: PUSH
57328: LD_INT 4
57330: GREATER
57331: IFFALSE 57335
// break ;
57333: GO 58385
// case i of 1 :
57335: LD_VAR 0 8
57339: PUSH
57340: LD_INT 1
57342: DOUBLE
57343: EQUAL
57344: IFTRUE 57348
57346: GO 57428
57348: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57349: LD_ADDR_VAR 0 12
57353: PUSH
57354: LD_VAR 0 18
57358: PPUSH
57359: LD_INT 22
57361: PUSH
57362: LD_VAR 0 16
57366: PUSH
57367: EMPTY
57368: LIST
57369: LIST
57370: PUSH
57371: LD_INT 58
57373: PUSH
57374: EMPTY
57375: LIST
57376: PUSH
57377: LD_INT 2
57379: PUSH
57380: LD_INT 30
57382: PUSH
57383: LD_INT 32
57385: PUSH
57386: EMPTY
57387: LIST
57388: LIST
57389: PUSH
57390: LD_INT 30
57392: PUSH
57393: LD_INT 4
57395: PUSH
57396: EMPTY
57397: LIST
57398: LIST
57399: PUSH
57400: LD_INT 30
57402: PUSH
57403: LD_INT 5
57405: PUSH
57406: EMPTY
57407: LIST
57408: LIST
57409: PUSH
57410: EMPTY
57411: LIST
57412: LIST
57413: LIST
57414: LIST
57415: PUSH
57416: EMPTY
57417: LIST
57418: LIST
57419: LIST
57420: PPUSH
57421: CALL_OW 72
57425: ST_TO_ADDR
57426: GO 57650
57428: LD_INT 2
57430: DOUBLE
57431: EQUAL
57432: IFTRUE 57436
57434: GO 57498
57436: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57437: LD_ADDR_VAR 0 12
57441: PUSH
57442: LD_VAR 0 18
57446: PPUSH
57447: LD_INT 22
57449: PUSH
57450: LD_VAR 0 16
57454: PUSH
57455: EMPTY
57456: LIST
57457: LIST
57458: PUSH
57459: LD_INT 2
57461: PUSH
57462: LD_INT 30
57464: PUSH
57465: LD_INT 0
57467: PUSH
57468: EMPTY
57469: LIST
57470: LIST
57471: PUSH
57472: LD_INT 30
57474: PUSH
57475: LD_INT 1
57477: PUSH
57478: EMPTY
57479: LIST
57480: LIST
57481: PUSH
57482: EMPTY
57483: LIST
57484: LIST
57485: LIST
57486: PUSH
57487: EMPTY
57488: LIST
57489: LIST
57490: PPUSH
57491: CALL_OW 72
57495: ST_TO_ADDR
57496: GO 57650
57498: LD_INT 3
57500: DOUBLE
57501: EQUAL
57502: IFTRUE 57506
57504: GO 57568
57506: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57507: LD_ADDR_VAR 0 12
57511: PUSH
57512: LD_VAR 0 18
57516: PPUSH
57517: LD_INT 22
57519: PUSH
57520: LD_VAR 0 16
57524: PUSH
57525: EMPTY
57526: LIST
57527: LIST
57528: PUSH
57529: LD_INT 2
57531: PUSH
57532: LD_INT 30
57534: PUSH
57535: LD_INT 2
57537: PUSH
57538: EMPTY
57539: LIST
57540: LIST
57541: PUSH
57542: LD_INT 30
57544: PUSH
57545: LD_INT 3
57547: PUSH
57548: EMPTY
57549: LIST
57550: LIST
57551: PUSH
57552: EMPTY
57553: LIST
57554: LIST
57555: LIST
57556: PUSH
57557: EMPTY
57558: LIST
57559: LIST
57560: PPUSH
57561: CALL_OW 72
57565: ST_TO_ADDR
57566: GO 57650
57568: LD_INT 4
57570: DOUBLE
57571: EQUAL
57572: IFTRUE 57576
57574: GO 57649
57576: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57577: LD_ADDR_VAR 0 12
57581: PUSH
57582: LD_VAR 0 18
57586: PPUSH
57587: LD_INT 22
57589: PUSH
57590: LD_VAR 0 16
57594: PUSH
57595: EMPTY
57596: LIST
57597: LIST
57598: PUSH
57599: LD_INT 2
57601: PUSH
57602: LD_INT 30
57604: PUSH
57605: LD_INT 6
57607: PUSH
57608: EMPTY
57609: LIST
57610: LIST
57611: PUSH
57612: LD_INT 30
57614: PUSH
57615: LD_INT 7
57617: PUSH
57618: EMPTY
57619: LIST
57620: LIST
57621: PUSH
57622: LD_INT 30
57624: PUSH
57625: LD_INT 8
57627: PUSH
57628: EMPTY
57629: LIST
57630: LIST
57631: PUSH
57632: EMPTY
57633: LIST
57634: LIST
57635: LIST
57636: LIST
57637: PUSH
57638: EMPTY
57639: LIST
57640: LIST
57641: PPUSH
57642: CALL_OW 72
57646: ST_TO_ADDR
57647: GO 57650
57649: POP
// if i = 1 then
57650: LD_VAR 0 8
57654: PUSH
57655: LD_INT 1
57657: EQUAL
57658: IFFALSE 57769
// begin tmp := [ ] ;
57660: LD_ADDR_VAR 0 19
57664: PUSH
57665: EMPTY
57666: ST_TO_ADDR
// for j in f do
57667: LD_ADDR_VAR 0 9
57671: PUSH
57672: LD_VAR 0 12
57676: PUSH
57677: FOR_IN
57678: IFFALSE 57751
// if GetBType ( j ) = b_bunker then
57680: LD_VAR 0 9
57684: PPUSH
57685: CALL_OW 266
57689: PUSH
57690: LD_INT 32
57692: EQUAL
57693: IFFALSE 57720
// tmp := Insert ( tmp , 1 , j ) else
57695: LD_ADDR_VAR 0 19
57699: PUSH
57700: LD_VAR 0 19
57704: PPUSH
57705: LD_INT 1
57707: PPUSH
57708: LD_VAR 0 9
57712: PPUSH
57713: CALL_OW 2
57717: ST_TO_ADDR
57718: GO 57749
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57720: LD_ADDR_VAR 0 19
57724: PUSH
57725: LD_VAR 0 19
57729: PPUSH
57730: LD_VAR 0 19
57734: PUSH
57735: LD_INT 1
57737: PLUS
57738: PPUSH
57739: LD_VAR 0 9
57743: PPUSH
57744: CALL_OW 2
57748: ST_TO_ADDR
57749: GO 57677
57751: POP
57752: POP
// if tmp then
57753: LD_VAR 0 19
57757: IFFALSE 57769
// f := tmp ;
57759: LD_ADDR_VAR 0 12
57763: PUSH
57764: LD_VAR 0 19
57768: ST_TO_ADDR
// end ; x := personel [ i ] ;
57769: LD_ADDR_VAR 0 13
57773: PUSH
57774: LD_VAR 0 6
57778: PUSH
57779: LD_VAR 0 8
57783: ARRAY
57784: ST_TO_ADDR
// if x = - 1 then
57785: LD_VAR 0 13
57789: PUSH
57790: LD_INT 1
57792: NEG
57793: EQUAL
57794: IFFALSE 58003
// begin for j in f do
57796: LD_ADDR_VAR 0 9
57800: PUSH
57801: LD_VAR 0 12
57805: PUSH
57806: FOR_IN
57807: IFFALSE 57999
// repeat InitHc ;
57809: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57813: LD_VAR 0 9
57817: PPUSH
57818: CALL_OW 266
57822: PUSH
57823: LD_INT 5
57825: EQUAL
57826: IFFALSE 57896
// begin if UnitsInside ( j ) < 3 then
57828: LD_VAR 0 9
57832: PPUSH
57833: CALL_OW 313
57837: PUSH
57838: LD_INT 3
57840: LESS
57841: IFFALSE 57877
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57843: LD_INT 0
57845: PPUSH
57846: LD_INT 5
57848: PUSH
57849: LD_INT 8
57851: PUSH
57852: LD_INT 9
57854: PUSH
57855: EMPTY
57856: LIST
57857: LIST
57858: LIST
57859: PUSH
57860: LD_VAR 0 17
57864: ARRAY
57865: PPUSH
57866: LD_VAR 0 4
57870: PPUSH
57871: CALL_OW 380
57875: GO 57894
// PrepareHuman ( false , i , skill ) ;
57877: LD_INT 0
57879: PPUSH
57880: LD_VAR 0 8
57884: PPUSH
57885: LD_VAR 0 4
57889: PPUSH
57890: CALL_OW 380
// end else
57894: GO 57913
// PrepareHuman ( false , i , skill ) ;
57896: LD_INT 0
57898: PPUSH
57899: LD_VAR 0 8
57903: PPUSH
57904: LD_VAR 0 4
57908: PPUSH
57909: CALL_OW 380
// un := CreateHuman ;
57913: LD_ADDR_VAR 0 14
57917: PUSH
57918: CALL_OW 44
57922: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57923: LD_ADDR_VAR 0 7
57927: PUSH
57928: LD_VAR 0 7
57932: PPUSH
57933: LD_INT 1
57935: PPUSH
57936: LD_VAR 0 14
57940: PPUSH
57941: CALL_OW 2
57945: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
57946: LD_VAR 0 14
57950: PPUSH
57951: LD_VAR 0 9
57955: PPUSH
57956: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
57960: LD_VAR 0 9
57964: PPUSH
57965: CALL_OW 313
57969: PUSH
57970: LD_INT 6
57972: EQUAL
57973: PUSH
57974: LD_VAR 0 9
57978: PPUSH
57979: CALL_OW 266
57983: PUSH
57984: LD_INT 32
57986: PUSH
57987: LD_INT 31
57989: PUSH
57990: EMPTY
57991: LIST
57992: LIST
57993: IN
57994: OR
57995: IFFALSE 57809
57997: GO 57806
57999: POP
58000: POP
// end else
58001: GO 58383
// for j = 1 to x do
58003: LD_ADDR_VAR 0 9
58007: PUSH
58008: DOUBLE
58009: LD_INT 1
58011: DEC
58012: ST_TO_ADDR
58013: LD_VAR 0 13
58017: PUSH
58018: FOR_TO
58019: IFFALSE 58381
// begin InitHc ;
58021: CALL_OW 19
// if not f then
58025: LD_VAR 0 12
58029: NOT
58030: IFFALSE 58119
// begin PrepareHuman ( false , i , skill ) ;
58032: LD_INT 0
58034: PPUSH
58035: LD_VAR 0 8
58039: PPUSH
58040: LD_VAR 0 4
58044: PPUSH
58045: CALL_OW 380
// un := CreateHuman ;
58049: LD_ADDR_VAR 0 14
58053: PUSH
58054: CALL_OW 44
58058: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58059: LD_ADDR_VAR 0 7
58063: PUSH
58064: LD_VAR 0 7
58068: PPUSH
58069: LD_INT 1
58071: PPUSH
58072: LD_VAR 0 14
58076: PPUSH
58077: CALL_OW 2
58081: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58082: LD_VAR 0 14
58086: PPUSH
58087: LD_VAR 0 1
58091: PPUSH
58092: CALL_OW 250
58096: PPUSH
58097: LD_VAR 0 1
58101: PPUSH
58102: CALL_OW 251
58106: PPUSH
58107: LD_INT 10
58109: PPUSH
58110: LD_INT 0
58112: PPUSH
58113: CALL_OW 50
// continue ;
58117: GO 58018
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58119: LD_VAR 0 12
58123: PUSH
58124: LD_INT 1
58126: ARRAY
58127: PPUSH
58128: CALL_OW 313
58132: PUSH
58133: LD_VAR 0 12
58137: PUSH
58138: LD_INT 1
58140: ARRAY
58141: PPUSH
58142: CALL_OW 266
58146: PUSH
58147: LD_INT 32
58149: PUSH
58150: LD_INT 31
58152: PUSH
58153: EMPTY
58154: LIST
58155: LIST
58156: IN
58157: AND
58158: PUSH
58159: LD_VAR 0 12
58163: PUSH
58164: LD_INT 1
58166: ARRAY
58167: PPUSH
58168: CALL_OW 313
58172: PUSH
58173: LD_INT 6
58175: EQUAL
58176: OR
58177: IFFALSE 58197
// f := Delete ( f , 1 ) ;
58179: LD_ADDR_VAR 0 12
58183: PUSH
58184: LD_VAR 0 12
58188: PPUSH
58189: LD_INT 1
58191: PPUSH
58192: CALL_OW 3
58196: ST_TO_ADDR
// if not f then
58197: LD_VAR 0 12
58201: NOT
58202: IFFALSE 58220
// begin x := x + 2 ;
58204: LD_ADDR_VAR 0 13
58208: PUSH
58209: LD_VAR 0 13
58213: PUSH
58214: LD_INT 2
58216: PLUS
58217: ST_TO_ADDR
// continue ;
58218: GO 58018
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58220: LD_VAR 0 12
58224: PUSH
58225: LD_INT 1
58227: ARRAY
58228: PPUSH
58229: CALL_OW 266
58233: PUSH
58234: LD_INT 5
58236: EQUAL
58237: IFFALSE 58311
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58239: LD_VAR 0 12
58243: PUSH
58244: LD_INT 1
58246: ARRAY
58247: PPUSH
58248: CALL_OW 313
58252: PUSH
58253: LD_INT 3
58255: LESS
58256: IFFALSE 58292
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58258: LD_INT 0
58260: PPUSH
58261: LD_INT 5
58263: PUSH
58264: LD_INT 8
58266: PUSH
58267: LD_INT 9
58269: PUSH
58270: EMPTY
58271: LIST
58272: LIST
58273: LIST
58274: PUSH
58275: LD_VAR 0 17
58279: ARRAY
58280: PPUSH
58281: LD_VAR 0 4
58285: PPUSH
58286: CALL_OW 380
58290: GO 58309
// PrepareHuman ( false , i , skill ) ;
58292: LD_INT 0
58294: PPUSH
58295: LD_VAR 0 8
58299: PPUSH
58300: LD_VAR 0 4
58304: PPUSH
58305: CALL_OW 380
// end else
58309: GO 58328
// PrepareHuman ( false , i , skill ) ;
58311: LD_INT 0
58313: PPUSH
58314: LD_VAR 0 8
58318: PPUSH
58319: LD_VAR 0 4
58323: PPUSH
58324: CALL_OW 380
// un := CreateHuman ;
58328: LD_ADDR_VAR 0 14
58332: PUSH
58333: CALL_OW 44
58337: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58338: LD_ADDR_VAR 0 7
58342: PUSH
58343: LD_VAR 0 7
58347: PPUSH
58348: LD_INT 1
58350: PPUSH
58351: LD_VAR 0 14
58355: PPUSH
58356: CALL_OW 2
58360: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58361: LD_VAR 0 14
58365: PPUSH
58366: LD_VAR 0 12
58370: PUSH
58371: LD_INT 1
58373: ARRAY
58374: PPUSH
58375: CALL_OW 52
// end ;
58379: GO 58018
58381: POP
58382: POP
// end ;
58383: GO 57320
58385: POP
58386: POP
// result := result ^ buildings ;
58387: LD_ADDR_VAR 0 7
58391: PUSH
58392: LD_VAR 0 7
58396: PUSH
58397: LD_VAR 0 18
58401: ADD
58402: ST_TO_ADDR
// end else
58403: GO 58546
// begin for i = 1 to personel do
58405: LD_ADDR_VAR 0 8
58409: PUSH
58410: DOUBLE
58411: LD_INT 1
58413: DEC
58414: ST_TO_ADDR
58415: LD_VAR 0 6
58419: PUSH
58420: FOR_TO
58421: IFFALSE 58544
// begin if i > 4 then
58423: LD_VAR 0 8
58427: PUSH
58428: LD_INT 4
58430: GREATER
58431: IFFALSE 58435
// break ;
58433: GO 58544
// x := personel [ i ] ;
58435: LD_ADDR_VAR 0 13
58439: PUSH
58440: LD_VAR 0 6
58444: PUSH
58445: LD_VAR 0 8
58449: ARRAY
58450: ST_TO_ADDR
// if x = - 1 then
58451: LD_VAR 0 13
58455: PUSH
58456: LD_INT 1
58458: NEG
58459: EQUAL
58460: IFFALSE 58464
// continue ;
58462: GO 58420
// PrepareHuman ( false , i , skill ) ;
58464: LD_INT 0
58466: PPUSH
58467: LD_VAR 0 8
58471: PPUSH
58472: LD_VAR 0 4
58476: PPUSH
58477: CALL_OW 380
// un := CreateHuman ;
58481: LD_ADDR_VAR 0 14
58485: PUSH
58486: CALL_OW 44
58490: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58491: LD_VAR 0 14
58495: PPUSH
58496: LD_VAR 0 1
58500: PPUSH
58501: CALL_OW 250
58505: PPUSH
58506: LD_VAR 0 1
58510: PPUSH
58511: CALL_OW 251
58515: PPUSH
58516: LD_INT 10
58518: PPUSH
58519: LD_INT 0
58521: PPUSH
58522: CALL_OW 50
// result := result ^ un ;
58526: LD_ADDR_VAR 0 7
58530: PUSH
58531: LD_VAR 0 7
58535: PUSH
58536: LD_VAR 0 14
58540: ADD
58541: ST_TO_ADDR
// end ;
58542: GO 58420
58544: POP
58545: POP
// end ; end ;
58546: LD_VAR 0 7
58550: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58551: LD_INT 0
58553: PPUSH
58554: PPUSH
58555: PPUSH
58556: PPUSH
58557: PPUSH
58558: PPUSH
58559: PPUSH
58560: PPUSH
58561: PPUSH
58562: PPUSH
58563: PPUSH
58564: PPUSH
58565: PPUSH
58566: PPUSH
58567: PPUSH
58568: PPUSH
// result := false ;
58569: LD_ADDR_VAR 0 3
58573: PUSH
58574: LD_INT 0
58576: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58577: LD_VAR 0 1
58581: NOT
58582: PUSH
58583: LD_VAR 0 1
58587: PPUSH
58588: CALL_OW 266
58592: PUSH
58593: LD_INT 32
58595: PUSH
58596: LD_INT 33
58598: PUSH
58599: EMPTY
58600: LIST
58601: LIST
58602: IN
58603: NOT
58604: OR
58605: IFFALSE 58609
// exit ;
58607: GO 59718
// nat := GetNation ( tower ) ;
58609: LD_ADDR_VAR 0 12
58613: PUSH
58614: LD_VAR 0 1
58618: PPUSH
58619: CALL_OW 248
58623: ST_TO_ADDR
// side := GetSide ( tower ) ;
58624: LD_ADDR_VAR 0 16
58628: PUSH
58629: LD_VAR 0 1
58633: PPUSH
58634: CALL_OW 255
58638: ST_TO_ADDR
// x := GetX ( tower ) ;
58639: LD_ADDR_VAR 0 10
58643: PUSH
58644: LD_VAR 0 1
58648: PPUSH
58649: CALL_OW 250
58653: ST_TO_ADDR
// y := GetY ( tower ) ;
58654: LD_ADDR_VAR 0 11
58658: PUSH
58659: LD_VAR 0 1
58663: PPUSH
58664: CALL_OW 251
58668: ST_TO_ADDR
// if not x or not y then
58669: LD_VAR 0 10
58673: NOT
58674: PUSH
58675: LD_VAR 0 11
58679: NOT
58680: OR
58681: IFFALSE 58685
// exit ;
58683: GO 59718
// weapon := 0 ;
58685: LD_ADDR_VAR 0 18
58689: PUSH
58690: LD_INT 0
58692: ST_TO_ADDR
// fac_list := [ ] ;
58693: LD_ADDR_VAR 0 17
58697: PUSH
58698: EMPTY
58699: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58700: LD_ADDR_VAR 0 6
58704: PUSH
58705: LD_VAR 0 1
58709: PPUSH
58710: CALL_OW 274
58714: PPUSH
58715: LD_VAR 0 2
58719: PPUSH
58720: LD_INT 0
58722: PPUSH
58723: CALL 56289 0 3
58727: PPUSH
58728: LD_INT 30
58730: PUSH
58731: LD_INT 3
58733: PUSH
58734: EMPTY
58735: LIST
58736: LIST
58737: PPUSH
58738: CALL_OW 72
58742: ST_TO_ADDR
// if not factories then
58743: LD_VAR 0 6
58747: NOT
58748: IFFALSE 58752
// exit ;
58750: GO 59718
// for i in factories do
58752: LD_ADDR_VAR 0 8
58756: PUSH
58757: LD_VAR 0 6
58761: PUSH
58762: FOR_IN
58763: IFFALSE 58788
// fac_list := fac_list union AvailableWeaponList ( i ) ;
58765: LD_ADDR_VAR 0 17
58769: PUSH
58770: LD_VAR 0 17
58774: PUSH
58775: LD_VAR 0 8
58779: PPUSH
58780: CALL_OW 478
58784: UNION
58785: ST_TO_ADDR
58786: GO 58762
58788: POP
58789: POP
// if not fac_list then
58790: LD_VAR 0 17
58794: NOT
58795: IFFALSE 58799
// exit ;
58797: GO 59718
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58799: LD_ADDR_VAR 0 5
58803: PUSH
58804: LD_INT 4
58806: PUSH
58807: LD_INT 5
58809: PUSH
58810: LD_INT 9
58812: PUSH
58813: LD_INT 10
58815: PUSH
58816: LD_INT 6
58818: PUSH
58819: LD_INT 7
58821: PUSH
58822: LD_INT 11
58824: PUSH
58825: EMPTY
58826: LIST
58827: LIST
58828: LIST
58829: LIST
58830: LIST
58831: LIST
58832: LIST
58833: PUSH
58834: LD_INT 27
58836: PUSH
58837: LD_INT 28
58839: PUSH
58840: LD_INT 26
58842: PUSH
58843: LD_INT 30
58845: PUSH
58846: EMPTY
58847: LIST
58848: LIST
58849: LIST
58850: LIST
58851: PUSH
58852: LD_INT 43
58854: PUSH
58855: LD_INT 44
58857: PUSH
58858: LD_INT 46
58860: PUSH
58861: LD_INT 45
58863: PUSH
58864: LD_INT 47
58866: PUSH
58867: LD_INT 49
58869: PUSH
58870: EMPTY
58871: LIST
58872: LIST
58873: LIST
58874: LIST
58875: LIST
58876: LIST
58877: PUSH
58878: EMPTY
58879: LIST
58880: LIST
58881: LIST
58882: PUSH
58883: LD_VAR 0 12
58887: ARRAY
58888: ST_TO_ADDR
// list := list isect fac_list ;
58889: LD_ADDR_VAR 0 5
58893: PUSH
58894: LD_VAR 0 5
58898: PUSH
58899: LD_VAR 0 17
58903: ISECT
58904: ST_TO_ADDR
// if not list then
58905: LD_VAR 0 5
58909: NOT
58910: IFFALSE 58914
// exit ;
58912: GO 59718
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
58914: LD_VAR 0 12
58918: PUSH
58919: LD_INT 3
58921: EQUAL
58922: PUSH
58923: LD_INT 49
58925: PUSH
58926: LD_VAR 0 5
58930: IN
58931: AND
58932: PUSH
58933: LD_INT 31
58935: PPUSH
58936: LD_VAR 0 16
58940: PPUSH
58941: CALL_OW 321
58945: PUSH
58946: LD_INT 2
58948: EQUAL
58949: AND
58950: IFFALSE 59010
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
58952: LD_INT 22
58954: PUSH
58955: LD_VAR 0 16
58959: PUSH
58960: EMPTY
58961: LIST
58962: LIST
58963: PUSH
58964: LD_INT 35
58966: PUSH
58967: LD_INT 49
58969: PUSH
58970: EMPTY
58971: LIST
58972: LIST
58973: PUSH
58974: LD_INT 91
58976: PUSH
58977: LD_VAR 0 1
58981: PUSH
58982: LD_INT 10
58984: PUSH
58985: EMPTY
58986: LIST
58987: LIST
58988: LIST
58989: PUSH
58990: EMPTY
58991: LIST
58992: LIST
58993: LIST
58994: PPUSH
58995: CALL_OW 69
58999: NOT
59000: IFFALSE 59010
// weapon := ru_time_lapser ;
59002: LD_ADDR_VAR 0 18
59006: PUSH
59007: LD_INT 49
59009: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59010: LD_VAR 0 12
59014: PUSH
59015: LD_INT 1
59017: PUSH
59018: LD_INT 2
59020: PUSH
59021: EMPTY
59022: LIST
59023: LIST
59024: IN
59025: PUSH
59026: LD_INT 11
59028: PUSH
59029: LD_VAR 0 5
59033: IN
59034: PUSH
59035: LD_INT 30
59037: PUSH
59038: LD_VAR 0 5
59042: IN
59043: OR
59044: AND
59045: PUSH
59046: LD_INT 6
59048: PPUSH
59049: LD_VAR 0 16
59053: PPUSH
59054: CALL_OW 321
59058: PUSH
59059: LD_INT 2
59061: EQUAL
59062: AND
59063: IFFALSE 59228
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59065: LD_INT 22
59067: PUSH
59068: LD_VAR 0 16
59072: PUSH
59073: EMPTY
59074: LIST
59075: LIST
59076: PUSH
59077: LD_INT 2
59079: PUSH
59080: LD_INT 35
59082: PUSH
59083: LD_INT 11
59085: PUSH
59086: EMPTY
59087: LIST
59088: LIST
59089: PUSH
59090: LD_INT 35
59092: PUSH
59093: LD_INT 30
59095: PUSH
59096: EMPTY
59097: LIST
59098: LIST
59099: PUSH
59100: EMPTY
59101: LIST
59102: LIST
59103: LIST
59104: PUSH
59105: LD_INT 91
59107: PUSH
59108: LD_VAR 0 1
59112: PUSH
59113: LD_INT 18
59115: PUSH
59116: EMPTY
59117: LIST
59118: LIST
59119: LIST
59120: PUSH
59121: EMPTY
59122: LIST
59123: LIST
59124: LIST
59125: PPUSH
59126: CALL_OW 69
59130: NOT
59131: PUSH
59132: LD_INT 22
59134: PUSH
59135: LD_VAR 0 16
59139: PUSH
59140: EMPTY
59141: LIST
59142: LIST
59143: PUSH
59144: LD_INT 2
59146: PUSH
59147: LD_INT 30
59149: PUSH
59150: LD_INT 32
59152: PUSH
59153: EMPTY
59154: LIST
59155: LIST
59156: PUSH
59157: LD_INT 30
59159: PUSH
59160: LD_INT 33
59162: PUSH
59163: EMPTY
59164: LIST
59165: LIST
59166: PUSH
59167: EMPTY
59168: LIST
59169: LIST
59170: LIST
59171: PUSH
59172: LD_INT 91
59174: PUSH
59175: LD_VAR 0 1
59179: PUSH
59180: LD_INT 12
59182: PUSH
59183: EMPTY
59184: LIST
59185: LIST
59186: LIST
59187: PUSH
59188: EMPTY
59189: LIST
59190: LIST
59191: LIST
59192: PUSH
59193: EMPTY
59194: LIST
59195: PPUSH
59196: CALL_OW 69
59200: PUSH
59201: LD_INT 2
59203: GREATER
59204: AND
59205: IFFALSE 59228
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59207: LD_ADDR_VAR 0 18
59211: PUSH
59212: LD_INT 11
59214: PUSH
59215: LD_INT 30
59217: PUSH
59218: EMPTY
59219: LIST
59220: LIST
59221: PUSH
59222: LD_VAR 0 12
59226: ARRAY
59227: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59228: LD_VAR 0 18
59232: NOT
59233: PUSH
59234: LD_INT 40
59236: PPUSH
59237: LD_VAR 0 16
59241: PPUSH
59242: CALL_OW 321
59246: PUSH
59247: LD_INT 2
59249: EQUAL
59250: AND
59251: PUSH
59252: LD_INT 7
59254: PUSH
59255: LD_VAR 0 5
59259: IN
59260: PUSH
59261: LD_INT 28
59263: PUSH
59264: LD_VAR 0 5
59268: IN
59269: OR
59270: PUSH
59271: LD_INT 45
59273: PUSH
59274: LD_VAR 0 5
59278: IN
59279: OR
59280: AND
59281: IFFALSE 59535
// begin hex := GetHexInfo ( x , y ) ;
59283: LD_ADDR_VAR 0 4
59287: PUSH
59288: LD_VAR 0 10
59292: PPUSH
59293: LD_VAR 0 11
59297: PPUSH
59298: CALL_OW 546
59302: ST_TO_ADDR
// if hex [ 1 ] then
59303: LD_VAR 0 4
59307: PUSH
59308: LD_INT 1
59310: ARRAY
59311: IFFALSE 59315
// exit ;
59313: GO 59718
// height := hex [ 2 ] ;
59315: LD_ADDR_VAR 0 15
59319: PUSH
59320: LD_VAR 0 4
59324: PUSH
59325: LD_INT 2
59327: ARRAY
59328: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59329: LD_ADDR_VAR 0 14
59333: PUSH
59334: LD_INT 0
59336: PUSH
59337: LD_INT 2
59339: PUSH
59340: LD_INT 3
59342: PUSH
59343: LD_INT 5
59345: PUSH
59346: EMPTY
59347: LIST
59348: LIST
59349: LIST
59350: LIST
59351: ST_TO_ADDR
// for i in tmp do
59352: LD_ADDR_VAR 0 8
59356: PUSH
59357: LD_VAR 0 14
59361: PUSH
59362: FOR_IN
59363: IFFALSE 59533
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59365: LD_ADDR_VAR 0 9
59369: PUSH
59370: LD_VAR 0 10
59374: PPUSH
59375: LD_VAR 0 8
59379: PPUSH
59380: LD_INT 5
59382: PPUSH
59383: CALL_OW 272
59387: PUSH
59388: LD_VAR 0 11
59392: PPUSH
59393: LD_VAR 0 8
59397: PPUSH
59398: LD_INT 5
59400: PPUSH
59401: CALL_OW 273
59405: PUSH
59406: EMPTY
59407: LIST
59408: LIST
59409: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59410: LD_VAR 0 9
59414: PUSH
59415: LD_INT 1
59417: ARRAY
59418: PPUSH
59419: LD_VAR 0 9
59423: PUSH
59424: LD_INT 2
59426: ARRAY
59427: PPUSH
59428: CALL_OW 488
59432: IFFALSE 59531
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59434: LD_ADDR_VAR 0 4
59438: PUSH
59439: LD_VAR 0 9
59443: PUSH
59444: LD_INT 1
59446: ARRAY
59447: PPUSH
59448: LD_VAR 0 9
59452: PUSH
59453: LD_INT 2
59455: ARRAY
59456: PPUSH
59457: CALL_OW 546
59461: ST_TO_ADDR
// if hex [ 1 ] then
59462: LD_VAR 0 4
59466: PUSH
59467: LD_INT 1
59469: ARRAY
59470: IFFALSE 59474
// continue ;
59472: GO 59362
// h := hex [ 2 ] ;
59474: LD_ADDR_VAR 0 13
59478: PUSH
59479: LD_VAR 0 4
59483: PUSH
59484: LD_INT 2
59486: ARRAY
59487: ST_TO_ADDR
// if h + 7 < height then
59488: LD_VAR 0 13
59492: PUSH
59493: LD_INT 7
59495: PLUS
59496: PUSH
59497: LD_VAR 0 15
59501: LESS
59502: IFFALSE 59531
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59504: LD_ADDR_VAR 0 18
59508: PUSH
59509: LD_INT 7
59511: PUSH
59512: LD_INT 28
59514: PUSH
59515: LD_INT 45
59517: PUSH
59518: EMPTY
59519: LIST
59520: LIST
59521: LIST
59522: PUSH
59523: LD_VAR 0 12
59527: ARRAY
59528: ST_TO_ADDR
// break ;
59529: GO 59533
// end ; end ; end ;
59531: GO 59362
59533: POP
59534: POP
// end ; if not weapon then
59535: LD_VAR 0 18
59539: NOT
59540: IFFALSE 59600
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59542: LD_ADDR_VAR 0 5
59546: PUSH
59547: LD_VAR 0 5
59551: PUSH
59552: LD_INT 11
59554: PUSH
59555: LD_INT 30
59557: PUSH
59558: LD_INT 49
59560: PUSH
59561: EMPTY
59562: LIST
59563: LIST
59564: LIST
59565: DIFF
59566: ST_TO_ADDR
// if not list then
59567: LD_VAR 0 5
59571: NOT
59572: IFFALSE 59576
// exit ;
59574: GO 59718
// weapon := list [ rand ( 1 , list ) ] ;
59576: LD_ADDR_VAR 0 18
59580: PUSH
59581: LD_VAR 0 5
59585: PUSH
59586: LD_INT 1
59588: PPUSH
59589: LD_VAR 0 5
59593: PPUSH
59594: CALL_OW 12
59598: ARRAY
59599: ST_TO_ADDR
// end ; if weapon then
59600: LD_VAR 0 18
59604: IFFALSE 59718
// begin tmp := CostOfWeapon ( weapon ) ;
59606: LD_ADDR_VAR 0 14
59610: PUSH
59611: LD_VAR 0 18
59615: PPUSH
59616: CALL_OW 451
59620: ST_TO_ADDR
// j := GetBase ( tower ) ;
59621: LD_ADDR_VAR 0 9
59625: PUSH
59626: LD_VAR 0 1
59630: PPUSH
59631: CALL_OW 274
59635: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59636: LD_VAR 0 9
59640: PPUSH
59641: LD_INT 1
59643: PPUSH
59644: CALL_OW 275
59648: PUSH
59649: LD_VAR 0 14
59653: PUSH
59654: LD_INT 1
59656: ARRAY
59657: GREATEREQUAL
59658: PUSH
59659: LD_VAR 0 9
59663: PPUSH
59664: LD_INT 2
59666: PPUSH
59667: CALL_OW 275
59671: PUSH
59672: LD_VAR 0 14
59676: PUSH
59677: LD_INT 2
59679: ARRAY
59680: GREATEREQUAL
59681: AND
59682: PUSH
59683: LD_VAR 0 9
59687: PPUSH
59688: LD_INT 3
59690: PPUSH
59691: CALL_OW 275
59695: PUSH
59696: LD_VAR 0 14
59700: PUSH
59701: LD_INT 3
59703: ARRAY
59704: GREATEREQUAL
59705: AND
59706: IFFALSE 59718
// result := weapon ;
59708: LD_ADDR_VAR 0 3
59712: PUSH
59713: LD_VAR 0 18
59717: ST_TO_ADDR
// end ; end ;
59718: LD_VAR 0 3
59722: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59723: LD_INT 0
59725: PPUSH
59726: PPUSH
// result := true ;
59727: LD_ADDR_VAR 0 3
59731: PUSH
59732: LD_INT 1
59734: ST_TO_ADDR
// if array1 = array2 then
59735: LD_VAR 0 1
59739: PUSH
59740: LD_VAR 0 2
59744: EQUAL
59745: IFFALSE 59805
// begin for i = 1 to array1 do
59747: LD_ADDR_VAR 0 4
59751: PUSH
59752: DOUBLE
59753: LD_INT 1
59755: DEC
59756: ST_TO_ADDR
59757: LD_VAR 0 1
59761: PUSH
59762: FOR_TO
59763: IFFALSE 59801
// if array1 [ i ] <> array2 [ i ] then
59765: LD_VAR 0 1
59769: PUSH
59770: LD_VAR 0 4
59774: ARRAY
59775: PUSH
59776: LD_VAR 0 2
59780: PUSH
59781: LD_VAR 0 4
59785: ARRAY
59786: NONEQUAL
59787: IFFALSE 59799
// begin result := false ;
59789: LD_ADDR_VAR 0 3
59793: PUSH
59794: LD_INT 0
59796: ST_TO_ADDR
// break ;
59797: GO 59801
// end ;
59799: GO 59762
59801: POP
59802: POP
// end else
59803: GO 59813
// result := false ;
59805: LD_ADDR_VAR 0 3
59809: PUSH
59810: LD_INT 0
59812: ST_TO_ADDR
// end ;
59813: LD_VAR 0 3
59817: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
59818: LD_INT 0
59820: PPUSH
59821: PPUSH
// if not array1 or not array2 then
59822: LD_VAR 0 1
59826: NOT
59827: PUSH
59828: LD_VAR 0 2
59832: NOT
59833: OR
59834: IFFALSE 59838
// exit ;
59836: GO 59902
// result := true ;
59838: LD_ADDR_VAR 0 3
59842: PUSH
59843: LD_INT 1
59845: ST_TO_ADDR
// for i = 1 to array1 do
59846: LD_ADDR_VAR 0 4
59850: PUSH
59851: DOUBLE
59852: LD_INT 1
59854: DEC
59855: ST_TO_ADDR
59856: LD_VAR 0 1
59860: PUSH
59861: FOR_TO
59862: IFFALSE 59900
// if array1 [ i ] <> array2 [ i ] then
59864: LD_VAR 0 1
59868: PUSH
59869: LD_VAR 0 4
59873: ARRAY
59874: PUSH
59875: LD_VAR 0 2
59879: PUSH
59880: LD_VAR 0 4
59884: ARRAY
59885: NONEQUAL
59886: IFFALSE 59898
// begin result := false ;
59888: LD_ADDR_VAR 0 3
59892: PUSH
59893: LD_INT 0
59895: ST_TO_ADDR
// break ;
59896: GO 59900
// end ;
59898: GO 59861
59900: POP
59901: POP
// end ;
59902: LD_VAR 0 3
59906: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
59907: LD_INT 0
59909: PPUSH
59910: PPUSH
59911: PPUSH
// pom := GetBase ( fac ) ;
59912: LD_ADDR_VAR 0 5
59916: PUSH
59917: LD_VAR 0 1
59921: PPUSH
59922: CALL_OW 274
59926: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
59927: LD_ADDR_VAR 0 4
59931: PUSH
59932: LD_VAR 0 2
59936: PUSH
59937: LD_INT 1
59939: ARRAY
59940: PPUSH
59941: LD_VAR 0 2
59945: PUSH
59946: LD_INT 2
59948: ARRAY
59949: PPUSH
59950: LD_VAR 0 2
59954: PUSH
59955: LD_INT 3
59957: ARRAY
59958: PPUSH
59959: LD_VAR 0 2
59963: PUSH
59964: LD_INT 4
59966: ARRAY
59967: PPUSH
59968: CALL_OW 449
59972: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59973: LD_ADDR_VAR 0 3
59977: PUSH
59978: LD_VAR 0 5
59982: PPUSH
59983: LD_INT 1
59985: PPUSH
59986: CALL_OW 275
59990: PUSH
59991: LD_VAR 0 4
59995: PUSH
59996: LD_INT 1
59998: ARRAY
59999: GREATEREQUAL
60000: PUSH
60001: LD_VAR 0 5
60005: PPUSH
60006: LD_INT 2
60008: PPUSH
60009: CALL_OW 275
60013: PUSH
60014: LD_VAR 0 4
60018: PUSH
60019: LD_INT 2
60021: ARRAY
60022: GREATEREQUAL
60023: AND
60024: PUSH
60025: LD_VAR 0 5
60029: PPUSH
60030: LD_INT 3
60032: PPUSH
60033: CALL_OW 275
60037: PUSH
60038: LD_VAR 0 4
60042: PUSH
60043: LD_INT 3
60045: ARRAY
60046: GREATEREQUAL
60047: AND
60048: ST_TO_ADDR
// end ;
60049: LD_VAR 0 3
60053: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60054: LD_INT 0
60056: PPUSH
60057: PPUSH
60058: PPUSH
60059: PPUSH
// pom := GetBase ( building ) ;
60060: LD_ADDR_VAR 0 3
60064: PUSH
60065: LD_VAR 0 1
60069: PPUSH
60070: CALL_OW 274
60074: ST_TO_ADDR
// if not pom then
60075: LD_VAR 0 3
60079: NOT
60080: IFFALSE 60084
// exit ;
60082: GO 60254
// btype := GetBType ( building ) ;
60084: LD_ADDR_VAR 0 5
60088: PUSH
60089: LD_VAR 0 1
60093: PPUSH
60094: CALL_OW 266
60098: ST_TO_ADDR
// if btype = b_armoury then
60099: LD_VAR 0 5
60103: PUSH
60104: LD_INT 4
60106: EQUAL
60107: IFFALSE 60117
// btype := b_barracks ;
60109: LD_ADDR_VAR 0 5
60113: PUSH
60114: LD_INT 5
60116: ST_TO_ADDR
// if btype = b_depot then
60117: LD_VAR 0 5
60121: PUSH
60122: LD_INT 0
60124: EQUAL
60125: IFFALSE 60135
// btype := b_warehouse ;
60127: LD_ADDR_VAR 0 5
60131: PUSH
60132: LD_INT 1
60134: ST_TO_ADDR
// if btype = b_workshop then
60135: LD_VAR 0 5
60139: PUSH
60140: LD_INT 2
60142: EQUAL
60143: IFFALSE 60153
// btype := b_factory ;
60145: LD_ADDR_VAR 0 5
60149: PUSH
60150: LD_INT 3
60152: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60153: LD_ADDR_VAR 0 4
60157: PUSH
60158: LD_VAR 0 5
60162: PPUSH
60163: LD_VAR 0 1
60167: PPUSH
60168: CALL_OW 248
60172: PPUSH
60173: CALL_OW 450
60177: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60178: LD_ADDR_VAR 0 2
60182: PUSH
60183: LD_VAR 0 3
60187: PPUSH
60188: LD_INT 1
60190: PPUSH
60191: CALL_OW 275
60195: PUSH
60196: LD_VAR 0 4
60200: PUSH
60201: LD_INT 1
60203: ARRAY
60204: GREATEREQUAL
60205: PUSH
60206: LD_VAR 0 3
60210: PPUSH
60211: LD_INT 2
60213: PPUSH
60214: CALL_OW 275
60218: PUSH
60219: LD_VAR 0 4
60223: PUSH
60224: LD_INT 2
60226: ARRAY
60227: GREATEREQUAL
60228: AND
60229: PUSH
60230: LD_VAR 0 3
60234: PPUSH
60235: LD_INT 3
60237: PPUSH
60238: CALL_OW 275
60242: PUSH
60243: LD_VAR 0 4
60247: PUSH
60248: LD_INT 3
60250: ARRAY
60251: GREATEREQUAL
60252: AND
60253: ST_TO_ADDR
// end ;
60254: LD_VAR 0 2
60258: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60259: LD_INT 0
60261: PPUSH
60262: PPUSH
60263: PPUSH
// pom := GetBase ( building ) ;
60264: LD_ADDR_VAR 0 4
60268: PUSH
60269: LD_VAR 0 1
60273: PPUSH
60274: CALL_OW 274
60278: ST_TO_ADDR
// if not pom then
60279: LD_VAR 0 4
60283: NOT
60284: IFFALSE 60288
// exit ;
60286: GO 60389
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60288: LD_ADDR_VAR 0 5
60292: PUSH
60293: LD_VAR 0 2
60297: PPUSH
60298: LD_VAR 0 1
60302: PPUSH
60303: CALL_OW 248
60307: PPUSH
60308: CALL_OW 450
60312: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60313: LD_ADDR_VAR 0 3
60317: PUSH
60318: LD_VAR 0 4
60322: PPUSH
60323: LD_INT 1
60325: PPUSH
60326: CALL_OW 275
60330: PUSH
60331: LD_VAR 0 5
60335: PUSH
60336: LD_INT 1
60338: ARRAY
60339: GREATEREQUAL
60340: PUSH
60341: LD_VAR 0 4
60345: PPUSH
60346: LD_INT 2
60348: PPUSH
60349: CALL_OW 275
60353: PUSH
60354: LD_VAR 0 5
60358: PUSH
60359: LD_INT 2
60361: ARRAY
60362: GREATEREQUAL
60363: AND
60364: PUSH
60365: LD_VAR 0 4
60369: PPUSH
60370: LD_INT 3
60372: PPUSH
60373: CALL_OW 275
60377: PUSH
60378: LD_VAR 0 5
60382: PUSH
60383: LD_INT 3
60385: ARRAY
60386: GREATEREQUAL
60387: AND
60388: ST_TO_ADDR
// end ;
60389: LD_VAR 0 3
60393: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60394: LD_INT 0
60396: PPUSH
60397: PPUSH
60398: PPUSH
60399: PPUSH
60400: PPUSH
60401: PPUSH
60402: PPUSH
60403: PPUSH
60404: PPUSH
60405: PPUSH
60406: PPUSH
// result := false ;
60407: LD_ADDR_VAR 0 8
60411: PUSH
60412: LD_INT 0
60414: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60415: LD_VAR 0 5
60419: NOT
60420: PUSH
60421: LD_VAR 0 1
60425: NOT
60426: OR
60427: PUSH
60428: LD_VAR 0 2
60432: NOT
60433: OR
60434: PUSH
60435: LD_VAR 0 3
60439: NOT
60440: OR
60441: IFFALSE 60445
// exit ;
60443: GO 61259
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60445: LD_ADDR_VAR 0 14
60449: PUSH
60450: LD_VAR 0 1
60454: PPUSH
60455: LD_VAR 0 2
60459: PPUSH
60460: LD_VAR 0 3
60464: PPUSH
60465: LD_VAR 0 4
60469: PPUSH
60470: LD_VAR 0 5
60474: PUSH
60475: LD_INT 1
60477: ARRAY
60478: PPUSH
60479: CALL_OW 248
60483: PPUSH
60484: LD_INT 0
60486: PPUSH
60487: CALL 62496 0 6
60491: ST_TO_ADDR
// if not hexes then
60492: LD_VAR 0 14
60496: NOT
60497: IFFALSE 60501
// exit ;
60499: GO 61259
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60501: LD_ADDR_VAR 0 17
60505: PUSH
60506: LD_VAR 0 5
60510: PPUSH
60511: LD_INT 22
60513: PUSH
60514: LD_VAR 0 13
60518: PPUSH
60519: CALL_OW 255
60523: PUSH
60524: EMPTY
60525: LIST
60526: LIST
60527: PUSH
60528: LD_INT 2
60530: PUSH
60531: LD_INT 30
60533: PUSH
60534: LD_INT 0
60536: PUSH
60537: EMPTY
60538: LIST
60539: LIST
60540: PUSH
60541: LD_INT 30
60543: PUSH
60544: LD_INT 1
60546: PUSH
60547: EMPTY
60548: LIST
60549: LIST
60550: PUSH
60551: EMPTY
60552: LIST
60553: LIST
60554: LIST
60555: PUSH
60556: EMPTY
60557: LIST
60558: LIST
60559: PPUSH
60560: CALL_OW 72
60564: ST_TO_ADDR
// for i = 1 to hexes do
60565: LD_ADDR_VAR 0 9
60569: PUSH
60570: DOUBLE
60571: LD_INT 1
60573: DEC
60574: ST_TO_ADDR
60575: LD_VAR 0 14
60579: PUSH
60580: FOR_TO
60581: IFFALSE 61257
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60583: LD_ADDR_VAR 0 13
60587: PUSH
60588: LD_VAR 0 14
60592: PUSH
60593: LD_VAR 0 9
60597: ARRAY
60598: PUSH
60599: LD_INT 1
60601: ARRAY
60602: PPUSH
60603: LD_VAR 0 14
60607: PUSH
60608: LD_VAR 0 9
60612: ARRAY
60613: PUSH
60614: LD_INT 2
60616: ARRAY
60617: PPUSH
60618: CALL_OW 428
60622: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60623: LD_VAR 0 14
60627: PUSH
60628: LD_VAR 0 9
60632: ARRAY
60633: PUSH
60634: LD_INT 1
60636: ARRAY
60637: PPUSH
60638: LD_VAR 0 14
60642: PUSH
60643: LD_VAR 0 9
60647: ARRAY
60648: PUSH
60649: LD_INT 2
60651: ARRAY
60652: PPUSH
60653: CALL_OW 351
60657: PUSH
60658: LD_VAR 0 14
60662: PUSH
60663: LD_VAR 0 9
60667: ARRAY
60668: PUSH
60669: LD_INT 1
60671: ARRAY
60672: PPUSH
60673: LD_VAR 0 14
60677: PUSH
60678: LD_VAR 0 9
60682: ARRAY
60683: PUSH
60684: LD_INT 2
60686: ARRAY
60687: PPUSH
60688: CALL_OW 488
60692: NOT
60693: OR
60694: PUSH
60695: LD_VAR 0 13
60699: PPUSH
60700: CALL_OW 247
60704: PUSH
60705: LD_INT 3
60707: EQUAL
60708: OR
60709: IFFALSE 60715
// exit ;
60711: POP
60712: POP
60713: GO 61259
// if not tmp then
60715: LD_VAR 0 13
60719: NOT
60720: IFFALSE 60724
// continue ;
60722: GO 60580
// result := true ;
60724: LD_ADDR_VAR 0 8
60728: PUSH
60729: LD_INT 1
60731: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60732: LD_VAR 0 6
60736: PUSH
60737: LD_VAR 0 13
60741: PPUSH
60742: CALL_OW 247
60746: PUSH
60747: LD_INT 2
60749: EQUAL
60750: AND
60751: PUSH
60752: LD_VAR 0 13
60756: PPUSH
60757: CALL_OW 263
60761: PUSH
60762: LD_INT 1
60764: EQUAL
60765: AND
60766: IFFALSE 60930
// begin if IsDrivenBy ( tmp ) then
60768: LD_VAR 0 13
60772: PPUSH
60773: CALL_OW 311
60777: IFFALSE 60781
// continue ;
60779: GO 60580
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
60781: LD_VAR 0 6
60785: PPUSH
60786: LD_INT 3
60788: PUSH
60789: LD_INT 60
60791: PUSH
60792: EMPTY
60793: LIST
60794: PUSH
60795: EMPTY
60796: LIST
60797: LIST
60798: PUSH
60799: LD_INT 3
60801: PUSH
60802: LD_INT 55
60804: PUSH
60805: EMPTY
60806: LIST
60807: PUSH
60808: EMPTY
60809: LIST
60810: LIST
60811: PUSH
60812: EMPTY
60813: LIST
60814: LIST
60815: PPUSH
60816: CALL_OW 72
60820: IFFALSE 60928
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
60822: LD_ADDR_VAR 0 18
60826: PUSH
60827: LD_VAR 0 6
60831: PPUSH
60832: LD_INT 3
60834: PUSH
60835: LD_INT 60
60837: PUSH
60838: EMPTY
60839: LIST
60840: PUSH
60841: EMPTY
60842: LIST
60843: LIST
60844: PUSH
60845: LD_INT 3
60847: PUSH
60848: LD_INT 55
60850: PUSH
60851: EMPTY
60852: LIST
60853: PUSH
60854: EMPTY
60855: LIST
60856: LIST
60857: PUSH
60858: EMPTY
60859: LIST
60860: LIST
60861: PPUSH
60862: CALL_OW 72
60866: PUSH
60867: LD_INT 1
60869: ARRAY
60870: ST_TO_ADDR
// if IsInUnit ( driver ) then
60871: LD_VAR 0 18
60875: PPUSH
60876: CALL_OW 310
60880: IFFALSE 60891
// ComExit ( driver ) ;
60882: LD_VAR 0 18
60886: PPUSH
60887: CALL 85680 0 1
// AddComEnterUnit ( driver , tmp ) ;
60891: LD_VAR 0 18
60895: PPUSH
60896: LD_VAR 0 13
60900: PPUSH
60901: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
60905: LD_VAR 0 18
60909: PPUSH
60910: LD_VAR 0 7
60914: PPUSH
60915: CALL_OW 173
// AddComExitVehicle ( driver ) ;
60919: LD_VAR 0 18
60923: PPUSH
60924: CALL_OW 181
// end ; continue ;
60928: GO 60580
// end ; if not cleaners or not tmp in cleaners then
60930: LD_VAR 0 6
60934: NOT
60935: PUSH
60936: LD_VAR 0 13
60940: PUSH
60941: LD_VAR 0 6
60945: IN
60946: NOT
60947: OR
60948: IFFALSE 61255
// begin if dep then
60950: LD_VAR 0 17
60954: IFFALSE 61090
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
60956: LD_ADDR_VAR 0 16
60960: PUSH
60961: LD_VAR 0 17
60965: PUSH
60966: LD_INT 1
60968: ARRAY
60969: PPUSH
60970: CALL_OW 250
60974: PPUSH
60975: LD_VAR 0 17
60979: PUSH
60980: LD_INT 1
60982: ARRAY
60983: PPUSH
60984: CALL_OW 254
60988: PPUSH
60989: LD_INT 5
60991: PPUSH
60992: CALL_OW 272
60996: PUSH
60997: LD_VAR 0 17
61001: PUSH
61002: LD_INT 1
61004: ARRAY
61005: PPUSH
61006: CALL_OW 251
61010: PPUSH
61011: LD_VAR 0 17
61015: PUSH
61016: LD_INT 1
61018: ARRAY
61019: PPUSH
61020: CALL_OW 254
61024: PPUSH
61025: LD_INT 5
61027: PPUSH
61028: CALL_OW 273
61032: PUSH
61033: EMPTY
61034: LIST
61035: LIST
61036: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61037: LD_VAR 0 16
61041: PUSH
61042: LD_INT 1
61044: ARRAY
61045: PPUSH
61046: LD_VAR 0 16
61050: PUSH
61051: LD_INT 2
61053: ARRAY
61054: PPUSH
61055: CALL_OW 488
61059: IFFALSE 61090
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61061: LD_VAR 0 13
61065: PPUSH
61066: LD_VAR 0 16
61070: PUSH
61071: LD_INT 1
61073: ARRAY
61074: PPUSH
61075: LD_VAR 0 16
61079: PUSH
61080: LD_INT 2
61082: ARRAY
61083: PPUSH
61084: CALL_OW 111
// continue ;
61088: GO 60580
// end ; end ; r := GetDir ( tmp ) ;
61090: LD_ADDR_VAR 0 15
61094: PUSH
61095: LD_VAR 0 13
61099: PPUSH
61100: CALL_OW 254
61104: ST_TO_ADDR
// if r = 5 then
61105: LD_VAR 0 15
61109: PUSH
61110: LD_INT 5
61112: EQUAL
61113: IFFALSE 61123
// r := 0 ;
61115: LD_ADDR_VAR 0 15
61119: PUSH
61120: LD_INT 0
61122: ST_TO_ADDR
// for j = r to 5 do
61123: LD_ADDR_VAR 0 10
61127: PUSH
61128: DOUBLE
61129: LD_VAR 0 15
61133: DEC
61134: ST_TO_ADDR
61135: LD_INT 5
61137: PUSH
61138: FOR_TO
61139: IFFALSE 61253
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61141: LD_ADDR_VAR 0 11
61145: PUSH
61146: LD_VAR 0 13
61150: PPUSH
61151: CALL_OW 250
61155: PPUSH
61156: LD_VAR 0 10
61160: PPUSH
61161: LD_INT 2
61163: PPUSH
61164: CALL_OW 272
61168: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61169: LD_ADDR_VAR 0 12
61173: PUSH
61174: LD_VAR 0 13
61178: PPUSH
61179: CALL_OW 251
61183: PPUSH
61184: LD_VAR 0 10
61188: PPUSH
61189: LD_INT 2
61191: PPUSH
61192: CALL_OW 273
61196: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61197: LD_VAR 0 11
61201: PPUSH
61202: LD_VAR 0 12
61206: PPUSH
61207: CALL_OW 488
61211: PUSH
61212: LD_VAR 0 11
61216: PPUSH
61217: LD_VAR 0 12
61221: PPUSH
61222: CALL_OW 428
61226: NOT
61227: AND
61228: IFFALSE 61251
// begin ComMoveXY ( tmp , _x , _y ) ;
61230: LD_VAR 0 13
61234: PPUSH
61235: LD_VAR 0 11
61239: PPUSH
61240: LD_VAR 0 12
61244: PPUSH
61245: CALL_OW 111
// break ;
61249: GO 61253
// end ; end ;
61251: GO 61138
61253: POP
61254: POP
// end ; end ;
61255: GO 60580
61257: POP
61258: POP
// end ;
61259: LD_VAR 0 8
61263: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61264: LD_INT 0
61266: PPUSH
// result := true ;
61267: LD_ADDR_VAR 0 3
61271: PUSH
61272: LD_INT 1
61274: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61275: LD_VAR 0 2
61279: PUSH
61280: LD_INT 24
61282: DOUBLE
61283: EQUAL
61284: IFTRUE 61294
61286: LD_INT 33
61288: DOUBLE
61289: EQUAL
61290: IFTRUE 61294
61292: GO 61319
61294: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61295: LD_ADDR_VAR 0 3
61299: PUSH
61300: LD_INT 32
61302: PPUSH
61303: LD_VAR 0 1
61307: PPUSH
61308: CALL_OW 321
61312: PUSH
61313: LD_INT 2
61315: EQUAL
61316: ST_TO_ADDR
61317: GO 61639
61319: LD_INT 20
61321: DOUBLE
61322: EQUAL
61323: IFTRUE 61327
61325: GO 61352
61327: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61328: LD_ADDR_VAR 0 3
61332: PUSH
61333: LD_INT 6
61335: PPUSH
61336: LD_VAR 0 1
61340: PPUSH
61341: CALL_OW 321
61345: PUSH
61346: LD_INT 2
61348: EQUAL
61349: ST_TO_ADDR
61350: GO 61639
61352: LD_INT 22
61354: DOUBLE
61355: EQUAL
61356: IFTRUE 61366
61358: LD_INT 36
61360: DOUBLE
61361: EQUAL
61362: IFTRUE 61366
61364: GO 61391
61366: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61367: LD_ADDR_VAR 0 3
61371: PUSH
61372: LD_INT 15
61374: PPUSH
61375: LD_VAR 0 1
61379: PPUSH
61380: CALL_OW 321
61384: PUSH
61385: LD_INT 2
61387: EQUAL
61388: ST_TO_ADDR
61389: GO 61639
61391: LD_INT 30
61393: DOUBLE
61394: EQUAL
61395: IFTRUE 61399
61397: GO 61424
61399: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61400: LD_ADDR_VAR 0 3
61404: PUSH
61405: LD_INT 20
61407: PPUSH
61408: LD_VAR 0 1
61412: PPUSH
61413: CALL_OW 321
61417: PUSH
61418: LD_INT 2
61420: EQUAL
61421: ST_TO_ADDR
61422: GO 61639
61424: LD_INT 28
61426: DOUBLE
61427: EQUAL
61428: IFTRUE 61438
61430: LD_INT 21
61432: DOUBLE
61433: EQUAL
61434: IFTRUE 61438
61436: GO 61463
61438: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61439: LD_ADDR_VAR 0 3
61443: PUSH
61444: LD_INT 21
61446: PPUSH
61447: LD_VAR 0 1
61451: PPUSH
61452: CALL_OW 321
61456: PUSH
61457: LD_INT 2
61459: EQUAL
61460: ST_TO_ADDR
61461: GO 61639
61463: LD_INT 16
61465: DOUBLE
61466: EQUAL
61467: IFTRUE 61471
61469: GO 61498
61471: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61472: LD_ADDR_VAR 0 3
61476: PUSH
61477: LD_EXP 106
61481: PPUSH
61482: LD_VAR 0 1
61486: PPUSH
61487: CALL_OW 321
61491: PUSH
61492: LD_INT 2
61494: EQUAL
61495: ST_TO_ADDR
61496: GO 61639
61498: LD_INT 19
61500: DOUBLE
61501: EQUAL
61502: IFTRUE 61512
61504: LD_INT 23
61506: DOUBLE
61507: EQUAL
61508: IFTRUE 61512
61510: GO 61539
61512: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61513: LD_ADDR_VAR 0 3
61517: PUSH
61518: LD_EXP 105
61522: PPUSH
61523: LD_VAR 0 1
61527: PPUSH
61528: CALL_OW 321
61532: PUSH
61533: LD_INT 2
61535: EQUAL
61536: ST_TO_ADDR
61537: GO 61639
61539: LD_INT 17
61541: DOUBLE
61542: EQUAL
61543: IFTRUE 61547
61545: GO 61572
61547: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61548: LD_ADDR_VAR 0 3
61552: PUSH
61553: LD_INT 39
61555: PPUSH
61556: LD_VAR 0 1
61560: PPUSH
61561: CALL_OW 321
61565: PUSH
61566: LD_INT 2
61568: EQUAL
61569: ST_TO_ADDR
61570: GO 61639
61572: LD_INT 18
61574: DOUBLE
61575: EQUAL
61576: IFTRUE 61580
61578: GO 61605
61580: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61581: LD_ADDR_VAR 0 3
61585: PUSH
61586: LD_INT 40
61588: PPUSH
61589: LD_VAR 0 1
61593: PPUSH
61594: CALL_OW 321
61598: PUSH
61599: LD_INT 2
61601: EQUAL
61602: ST_TO_ADDR
61603: GO 61639
61605: LD_INT 27
61607: DOUBLE
61608: EQUAL
61609: IFTRUE 61613
61611: GO 61638
61613: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61614: LD_ADDR_VAR 0 3
61618: PUSH
61619: LD_INT 35
61621: PPUSH
61622: LD_VAR 0 1
61626: PPUSH
61627: CALL_OW 321
61631: PUSH
61632: LD_INT 2
61634: EQUAL
61635: ST_TO_ADDR
61636: GO 61639
61638: POP
// end ;
61639: LD_VAR 0 3
61643: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61644: LD_INT 0
61646: PPUSH
61647: PPUSH
61648: PPUSH
61649: PPUSH
61650: PPUSH
61651: PPUSH
61652: PPUSH
61653: PPUSH
61654: PPUSH
61655: PPUSH
61656: PPUSH
// result := false ;
61657: LD_ADDR_VAR 0 6
61661: PUSH
61662: LD_INT 0
61664: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61665: LD_VAR 0 1
61669: NOT
61670: PUSH
61671: LD_VAR 0 1
61675: PPUSH
61676: CALL_OW 266
61680: PUSH
61681: LD_INT 0
61683: PUSH
61684: LD_INT 1
61686: PUSH
61687: EMPTY
61688: LIST
61689: LIST
61690: IN
61691: NOT
61692: OR
61693: PUSH
61694: LD_VAR 0 2
61698: NOT
61699: OR
61700: PUSH
61701: LD_VAR 0 5
61705: PUSH
61706: LD_INT 0
61708: PUSH
61709: LD_INT 1
61711: PUSH
61712: LD_INT 2
61714: PUSH
61715: LD_INT 3
61717: PUSH
61718: LD_INT 4
61720: PUSH
61721: LD_INT 5
61723: PUSH
61724: EMPTY
61725: LIST
61726: LIST
61727: LIST
61728: LIST
61729: LIST
61730: LIST
61731: IN
61732: NOT
61733: OR
61734: PUSH
61735: LD_VAR 0 3
61739: PPUSH
61740: LD_VAR 0 4
61744: PPUSH
61745: CALL_OW 488
61749: NOT
61750: OR
61751: IFFALSE 61755
// exit ;
61753: GO 62491
// side := GetSide ( depot ) ;
61755: LD_ADDR_VAR 0 9
61759: PUSH
61760: LD_VAR 0 1
61764: PPUSH
61765: CALL_OW 255
61769: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
61770: LD_VAR 0 9
61774: PPUSH
61775: LD_VAR 0 2
61779: PPUSH
61780: CALL 61264 0 2
61784: NOT
61785: IFFALSE 61789
// exit ;
61787: GO 62491
// pom := GetBase ( depot ) ;
61789: LD_ADDR_VAR 0 10
61793: PUSH
61794: LD_VAR 0 1
61798: PPUSH
61799: CALL_OW 274
61803: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
61804: LD_ADDR_VAR 0 11
61808: PUSH
61809: LD_VAR 0 2
61813: PPUSH
61814: LD_VAR 0 1
61818: PPUSH
61819: CALL_OW 248
61823: PPUSH
61824: CALL_OW 450
61828: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
61829: LD_VAR 0 10
61833: PPUSH
61834: LD_INT 1
61836: PPUSH
61837: CALL_OW 275
61841: PUSH
61842: LD_VAR 0 11
61846: PUSH
61847: LD_INT 1
61849: ARRAY
61850: GREATEREQUAL
61851: PUSH
61852: LD_VAR 0 10
61856: PPUSH
61857: LD_INT 2
61859: PPUSH
61860: CALL_OW 275
61864: PUSH
61865: LD_VAR 0 11
61869: PUSH
61870: LD_INT 2
61872: ARRAY
61873: GREATEREQUAL
61874: AND
61875: PUSH
61876: LD_VAR 0 10
61880: PPUSH
61881: LD_INT 3
61883: PPUSH
61884: CALL_OW 275
61888: PUSH
61889: LD_VAR 0 11
61893: PUSH
61894: LD_INT 3
61896: ARRAY
61897: GREATEREQUAL
61898: AND
61899: NOT
61900: IFFALSE 61904
// exit ;
61902: GO 62491
// if GetBType ( depot ) = b_depot then
61904: LD_VAR 0 1
61908: PPUSH
61909: CALL_OW 266
61913: PUSH
61914: LD_INT 0
61916: EQUAL
61917: IFFALSE 61929
// dist := 28 else
61919: LD_ADDR_VAR 0 14
61923: PUSH
61924: LD_INT 28
61926: ST_TO_ADDR
61927: GO 61937
// dist := 36 ;
61929: LD_ADDR_VAR 0 14
61933: PUSH
61934: LD_INT 36
61936: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
61937: LD_VAR 0 1
61941: PPUSH
61942: LD_VAR 0 3
61946: PPUSH
61947: LD_VAR 0 4
61951: PPUSH
61952: CALL_OW 297
61956: PUSH
61957: LD_VAR 0 14
61961: GREATER
61962: IFFALSE 61966
// exit ;
61964: GO 62491
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
61966: LD_ADDR_VAR 0 12
61970: PUSH
61971: LD_VAR 0 2
61975: PPUSH
61976: LD_VAR 0 3
61980: PPUSH
61981: LD_VAR 0 4
61985: PPUSH
61986: LD_VAR 0 5
61990: PPUSH
61991: LD_VAR 0 1
61995: PPUSH
61996: CALL_OW 248
62000: PPUSH
62001: LD_INT 0
62003: PPUSH
62004: CALL 62496 0 6
62008: ST_TO_ADDR
// if not hexes then
62009: LD_VAR 0 12
62013: NOT
62014: IFFALSE 62018
// exit ;
62016: GO 62491
// hex := GetHexInfo ( x , y ) ;
62018: LD_ADDR_VAR 0 15
62022: PUSH
62023: LD_VAR 0 3
62027: PPUSH
62028: LD_VAR 0 4
62032: PPUSH
62033: CALL_OW 546
62037: ST_TO_ADDR
// if hex [ 1 ] then
62038: LD_VAR 0 15
62042: PUSH
62043: LD_INT 1
62045: ARRAY
62046: IFFALSE 62050
// exit ;
62048: GO 62491
// height := hex [ 2 ] ;
62050: LD_ADDR_VAR 0 13
62054: PUSH
62055: LD_VAR 0 15
62059: PUSH
62060: LD_INT 2
62062: ARRAY
62063: ST_TO_ADDR
// for i = 1 to hexes do
62064: LD_ADDR_VAR 0 7
62068: PUSH
62069: DOUBLE
62070: LD_INT 1
62072: DEC
62073: ST_TO_ADDR
62074: LD_VAR 0 12
62078: PUSH
62079: FOR_TO
62080: IFFALSE 62410
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62082: LD_VAR 0 12
62086: PUSH
62087: LD_VAR 0 7
62091: ARRAY
62092: PUSH
62093: LD_INT 1
62095: ARRAY
62096: PPUSH
62097: LD_VAR 0 12
62101: PUSH
62102: LD_VAR 0 7
62106: ARRAY
62107: PUSH
62108: LD_INT 2
62110: ARRAY
62111: PPUSH
62112: CALL_OW 488
62116: NOT
62117: PUSH
62118: LD_VAR 0 12
62122: PUSH
62123: LD_VAR 0 7
62127: ARRAY
62128: PUSH
62129: LD_INT 1
62131: ARRAY
62132: PPUSH
62133: LD_VAR 0 12
62137: PUSH
62138: LD_VAR 0 7
62142: ARRAY
62143: PUSH
62144: LD_INT 2
62146: ARRAY
62147: PPUSH
62148: CALL_OW 428
62152: PUSH
62153: LD_INT 0
62155: GREATER
62156: OR
62157: PUSH
62158: LD_VAR 0 12
62162: PUSH
62163: LD_VAR 0 7
62167: ARRAY
62168: PUSH
62169: LD_INT 1
62171: ARRAY
62172: PPUSH
62173: LD_VAR 0 12
62177: PUSH
62178: LD_VAR 0 7
62182: ARRAY
62183: PUSH
62184: LD_INT 2
62186: ARRAY
62187: PPUSH
62188: CALL_OW 351
62192: OR
62193: IFFALSE 62199
// exit ;
62195: POP
62196: POP
62197: GO 62491
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62199: LD_ADDR_VAR 0 8
62203: PUSH
62204: LD_VAR 0 12
62208: PUSH
62209: LD_VAR 0 7
62213: ARRAY
62214: PUSH
62215: LD_INT 1
62217: ARRAY
62218: PPUSH
62219: LD_VAR 0 12
62223: PUSH
62224: LD_VAR 0 7
62228: ARRAY
62229: PUSH
62230: LD_INT 2
62232: ARRAY
62233: PPUSH
62234: CALL_OW 546
62238: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62239: LD_VAR 0 8
62243: PUSH
62244: LD_INT 1
62246: ARRAY
62247: PUSH
62248: LD_VAR 0 8
62252: PUSH
62253: LD_INT 2
62255: ARRAY
62256: PUSH
62257: LD_VAR 0 13
62261: PUSH
62262: LD_INT 2
62264: PLUS
62265: GREATER
62266: OR
62267: PUSH
62268: LD_VAR 0 8
62272: PUSH
62273: LD_INT 2
62275: ARRAY
62276: PUSH
62277: LD_VAR 0 13
62281: PUSH
62282: LD_INT 2
62284: MINUS
62285: LESS
62286: OR
62287: PUSH
62288: LD_VAR 0 8
62292: PUSH
62293: LD_INT 3
62295: ARRAY
62296: PUSH
62297: LD_INT 0
62299: PUSH
62300: LD_INT 8
62302: PUSH
62303: LD_INT 9
62305: PUSH
62306: LD_INT 10
62308: PUSH
62309: LD_INT 11
62311: PUSH
62312: LD_INT 12
62314: PUSH
62315: LD_INT 13
62317: PUSH
62318: LD_INT 16
62320: PUSH
62321: LD_INT 17
62323: PUSH
62324: LD_INT 18
62326: PUSH
62327: LD_INT 19
62329: PUSH
62330: LD_INT 20
62332: PUSH
62333: LD_INT 21
62335: PUSH
62336: EMPTY
62337: LIST
62338: LIST
62339: LIST
62340: LIST
62341: LIST
62342: LIST
62343: LIST
62344: LIST
62345: LIST
62346: LIST
62347: LIST
62348: LIST
62349: LIST
62350: IN
62351: NOT
62352: OR
62353: PUSH
62354: LD_VAR 0 8
62358: PUSH
62359: LD_INT 5
62361: ARRAY
62362: NOT
62363: OR
62364: PUSH
62365: LD_VAR 0 8
62369: PUSH
62370: LD_INT 6
62372: ARRAY
62373: PUSH
62374: LD_INT 1
62376: PUSH
62377: LD_INT 2
62379: PUSH
62380: LD_INT 7
62382: PUSH
62383: LD_INT 9
62385: PUSH
62386: LD_INT 10
62388: PUSH
62389: LD_INT 11
62391: PUSH
62392: EMPTY
62393: LIST
62394: LIST
62395: LIST
62396: LIST
62397: LIST
62398: LIST
62399: IN
62400: NOT
62401: OR
62402: IFFALSE 62408
// exit ;
62404: POP
62405: POP
62406: GO 62491
// end ;
62408: GO 62079
62410: POP
62411: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62412: LD_VAR 0 9
62416: PPUSH
62417: LD_VAR 0 3
62421: PPUSH
62422: LD_VAR 0 4
62426: PPUSH
62427: LD_INT 20
62429: PPUSH
62430: CALL 54437 0 4
62434: PUSH
62435: LD_INT 4
62437: ARRAY
62438: IFFALSE 62442
// exit ;
62440: GO 62491
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62442: LD_VAR 0 2
62446: PUSH
62447: LD_INT 29
62449: PUSH
62450: LD_INT 30
62452: PUSH
62453: EMPTY
62454: LIST
62455: LIST
62456: IN
62457: PUSH
62458: LD_VAR 0 3
62462: PPUSH
62463: LD_VAR 0 4
62467: PPUSH
62468: LD_VAR 0 9
62472: PPUSH
62473: CALL_OW 440
62477: NOT
62478: AND
62479: IFFALSE 62483
// exit ;
62481: GO 62491
// result := true ;
62483: LD_ADDR_VAR 0 6
62487: PUSH
62488: LD_INT 1
62490: ST_TO_ADDR
// end ;
62491: LD_VAR 0 6
62495: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62496: LD_INT 0
62498: PPUSH
62499: PPUSH
62500: PPUSH
62501: PPUSH
62502: PPUSH
62503: PPUSH
62504: PPUSH
62505: PPUSH
62506: PPUSH
62507: PPUSH
62508: PPUSH
62509: PPUSH
62510: PPUSH
62511: PPUSH
62512: PPUSH
62513: PPUSH
62514: PPUSH
62515: PPUSH
62516: PPUSH
62517: PPUSH
62518: PPUSH
62519: PPUSH
62520: PPUSH
62521: PPUSH
62522: PPUSH
62523: PPUSH
62524: PPUSH
62525: PPUSH
62526: PPUSH
62527: PPUSH
62528: PPUSH
62529: PPUSH
62530: PPUSH
62531: PPUSH
62532: PPUSH
62533: PPUSH
62534: PPUSH
62535: PPUSH
62536: PPUSH
62537: PPUSH
62538: PPUSH
62539: PPUSH
62540: PPUSH
62541: PPUSH
62542: PPUSH
62543: PPUSH
62544: PPUSH
62545: PPUSH
62546: PPUSH
62547: PPUSH
62548: PPUSH
62549: PPUSH
62550: PPUSH
62551: PPUSH
62552: PPUSH
62553: PPUSH
62554: PPUSH
62555: PPUSH
// result = [ ] ;
62556: LD_ADDR_VAR 0 7
62560: PUSH
62561: EMPTY
62562: ST_TO_ADDR
// temp_list = [ ] ;
62563: LD_ADDR_VAR 0 9
62567: PUSH
62568: EMPTY
62569: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62570: LD_VAR 0 4
62574: PUSH
62575: LD_INT 0
62577: PUSH
62578: LD_INT 1
62580: PUSH
62581: LD_INT 2
62583: PUSH
62584: LD_INT 3
62586: PUSH
62587: LD_INT 4
62589: PUSH
62590: LD_INT 5
62592: PUSH
62593: EMPTY
62594: LIST
62595: LIST
62596: LIST
62597: LIST
62598: LIST
62599: LIST
62600: IN
62601: NOT
62602: PUSH
62603: LD_VAR 0 1
62607: PUSH
62608: LD_INT 0
62610: PUSH
62611: LD_INT 1
62613: PUSH
62614: EMPTY
62615: LIST
62616: LIST
62617: IN
62618: PUSH
62619: LD_VAR 0 5
62623: PUSH
62624: LD_INT 1
62626: PUSH
62627: LD_INT 2
62629: PUSH
62630: LD_INT 3
62632: PUSH
62633: EMPTY
62634: LIST
62635: LIST
62636: LIST
62637: IN
62638: NOT
62639: AND
62640: OR
62641: IFFALSE 62645
// exit ;
62643: GO 81036
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62645: LD_VAR 0 1
62649: PUSH
62650: LD_INT 6
62652: PUSH
62653: LD_INT 7
62655: PUSH
62656: LD_INT 8
62658: PUSH
62659: LD_INT 13
62661: PUSH
62662: LD_INT 12
62664: PUSH
62665: LD_INT 15
62667: PUSH
62668: LD_INT 11
62670: PUSH
62671: LD_INT 14
62673: PUSH
62674: LD_INT 10
62676: PUSH
62677: EMPTY
62678: LIST
62679: LIST
62680: LIST
62681: LIST
62682: LIST
62683: LIST
62684: LIST
62685: LIST
62686: LIST
62687: IN
62688: IFFALSE 62698
// btype = b_lab ;
62690: LD_ADDR_VAR 0 1
62694: PUSH
62695: LD_INT 6
62697: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62698: LD_VAR 0 6
62702: PUSH
62703: LD_INT 0
62705: PUSH
62706: LD_INT 1
62708: PUSH
62709: LD_INT 2
62711: PUSH
62712: EMPTY
62713: LIST
62714: LIST
62715: LIST
62716: IN
62717: NOT
62718: PUSH
62719: LD_VAR 0 1
62723: PUSH
62724: LD_INT 0
62726: PUSH
62727: LD_INT 1
62729: PUSH
62730: LD_INT 2
62732: PUSH
62733: LD_INT 3
62735: PUSH
62736: LD_INT 6
62738: PUSH
62739: LD_INT 36
62741: PUSH
62742: LD_INT 4
62744: PUSH
62745: LD_INT 5
62747: PUSH
62748: LD_INT 31
62750: PUSH
62751: LD_INT 32
62753: PUSH
62754: LD_INT 33
62756: PUSH
62757: EMPTY
62758: LIST
62759: LIST
62760: LIST
62761: LIST
62762: LIST
62763: LIST
62764: LIST
62765: LIST
62766: LIST
62767: LIST
62768: LIST
62769: IN
62770: NOT
62771: PUSH
62772: LD_VAR 0 6
62776: PUSH
62777: LD_INT 1
62779: EQUAL
62780: AND
62781: OR
62782: PUSH
62783: LD_VAR 0 1
62787: PUSH
62788: LD_INT 2
62790: PUSH
62791: LD_INT 3
62793: PUSH
62794: EMPTY
62795: LIST
62796: LIST
62797: IN
62798: NOT
62799: PUSH
62800: LD_VAR 0 6
62804: PUSH
62805: LD_INT 2
62807: EQUAL
62808: AND
62809: OR
62810: IFFALSE 62820
// mode = 0 ;
62812: LD_ADDR_VAR 0 6
62816: PUSH
62817: LD_INT 0
62819: ST_TO_ADDR
// case mode of 0 :
62820: LD_VAR 0 6
62824: PUSH
62825: LD_INT 0
62827: DOUBLE
62828: EQUAL
62829: IFTRUE 62833
62831: GO 74286
62833: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
62834: LD_ADDR_VAR 0 11
62838: PUSH
62839: LD_INT 0
62841: PUSH
62842: LD_INT 0
62844: PUSH
62845: EMPTY
62846: LIST
62847: LIST
62848: PUSH
62849: LD_INT 0
62851: PUSH
62852: LD_INT 1
62854: NEG
62855: PUSH
62856: EMPTY
62857: LIST
62858: LIST
62859: PUSH
62860: LD_INT 1
62862: PUSH
62863: LD_INT 0
62865: PUSH
62866: EMPTY
62867: LIST
62868: LIST
62869: PUSH
62870: LD_INT 1
62872: PUSH
62873: LD_INT 1
62875: PUSH
62876: EMPTY
62877: LIST
62878: LIST
62879: PUSH
62880: LD_INT 0
62882: PUSH
62883: LD_INT 1
62885: PUSH
62886: EMPTY
62887: LIST
62888: LIST
62889: PUSH
62890: LD_INT 1
62892: NEG
62893: PUSH
62894: LD_INT 0
62896: PUSH
62897: EMPTY
62898: LIST
62899: LIST
62900: PUSH
62901: LD_INT 1
62903: NEG
62904: PUSH
62905: LD_INT 1
62907: NEG
62908: PUSH
62909: EMPTY
62910: LIST
62911: LIST
62912: PUSH
62913: LD_INT 1
62915: NEG
62916: PUSH
62917: LD_INT 2
62919: NEG
62920: PUSH
62921: EMPTY
62922: LIST
62923: LIST
62924: PUSH
62925: LD_INT 0
62927: PUSH
62928: LD_INT 2
62930: NEG
62931: PUSH
62932: EMPTY
62933: LIST
62934: LIST
62935: PUSH
62936: LD_INT 1
62938: PUSH
62939: LD_INT 1
62941: NEG
62942: PUSH
62943: EMPTY
62944: LIST
62945: LIST
62946: PUSH
62947: LD_INT 1
62949: PUSH
62950: LD_INT 2
62952: PUSH
62953: EMPTY
62954: LIST
62955: LIST
62956: PUSH
62957: LD_INT 0
62959: PUSH
62960: LD_INT 2
62962: PUSH
62963: EMPTY
62964: LIST
62965: LIST
62966: PUSH
62967: LD_INT 1
62969: NEG
62970: PUSH
62971: LD_INT 1
62973: PUSH
62974: EMPTY
62975: LIST
62976: LIST
62977: PUSH
62978: LD_INT 1
62980: PUSH
62981: LD_INT 3
62983: PUSH
62984: EMPTY
62985: LIST
62986: LIST
62987: PUSH
62988: LD_INT 0
62990: PUSH
62991: LD_INT 3
62993: PUSH
62994: EMPTY
62995: LIST
62996: LIST
62997: PUSH
62998: LD_INT 1
63000: NEG
63001: PUSH
63002: LD_INT 2
63004: PUSH
63005: EMPTY
63006: LIST
63007: LIST
63008: PUSH
63009: EMPTY
63010: LIST
63011: LIST
63012: LIST
63013: LIST
63014: LIST
63015: LIST
63016: LIST
63017: LIST
63018: LIST
63019: LIST
63020: LIST
63021: LIST
63022: LIST
63023: LIST
63024: LIST
63025: LIST
63026: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63027: LD_ADDR_VAR 0 12
63031: PUSH
63032: LD_INT 0
63034: PUSH
63035: LD_INT 0
63037: PUSH
63038: EMPTY
63039: LIST
63040: LIST
63041: PUSH
63042: LD_INT 0
63044: PUSH
63045: LD_INT 1
63047: NEG
63048: PUSH
63049: EMPTY
63050: LIST
63051: LIST
63052: PUSH
63053: LD_INT 1
63055: PUSH
63056: LD_INT 0
63058: PUSH
63059: EMPTY
63060: LIST
63061: LIST
63062: PUSH
63063: LD_INT 1
63065: PUSH
63066: LD_INT 1
63068: PUSH
63069: EMPTY
63070: LIST
63071: LIST
63072: PUSH
63073: LD_INT 0
63075: PUSH
63076: LD_INT 1
63078: PUSH
63079: EMPTY
63080: LIST
63081: LIST
63082: PUSH
63083: LD_INT 1
63085: NEG
63086: PUSH
63087: LD_INT 0
63089: PUSH
63090: EMPTY
63091: LIST
63092: LIST
63093: PUSH
63094: LD_INT 1
63096: NEG
63097: PUSH
63098: LD_INT 1
63100: NEG
63101: PUSH
63102: EMPTY
63103: LIST
63104: LIST
63105: PUSH
63106: LD_INT 1
63108: PUSH
63109: LD_INT 1
63111: NEG
63112: PUSH
63113: EMPTY
63114: LIST
63115: LIST
63116: PUSH
63117: LD_INT 2
63119: PUSH
63120: LD_INT 0
63122: PUSH
63123: EMPTY
63124: LIST
63125: LIST
63126: PUSH
63127: LD_INT 2
63129: PUSH
63130: LD_INT 1
63132: PUSH
63133: EMPTY
63134: LIST
63135: LIST
63136: PUSH
63137: LD_INT 1
63139: NEG
63140: PUSH
63141: LD_INT 1
63143: PUSH
63144: EMPTY
63145: LIST
63146: LIST
63147: PUSH
63148: LD_INT 2
63150: NEG
63151: PUSH
63152: LD_INT 0
63154: PUSH
63155: EMPTY
63156: LIST
63157: LIST
63158: PUSH
63159: LD_INT 2
63161: NEG
63162: PUSH
63163: LD_INT 1
63165: NEG
63166: PUSH
63167: EMPTY
63168: LIST
63169: LIST
63170: PUSH
63171: LD_INT 2
63173: NEG
63174: PUSH
63175: LD_INT 1
63177: PUSH
63178: EMPTY
63179: LIST
63180: LIST
63181: PUSH
63182: LD_INT 3
63184: NEG
63185: PUSH
63186: LD_INT 0
63188: PUSH
63189: EMPTY
63190: LIST
63191: LIST
63192: PUSH
63193: LD_INT 3
63195: NEG
63196: PUSH
63197: LD_INT 1
63199: NEG
63200: PUSH
63201: EMPTY
63202: LIST
63203: LIST
63204: PUSH
63205: EMPTY
63206: LIST
63207: LIST
63208: LIST
63209: LIST
63210: LIST
63211: LIST
63212: LIST
63213: LIST
63214: LIST
63215: LIST
63216: LIST
63217: LIST
63218: LIST
63219: LIST
63220: LIST
63221: LIST
63222: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63223: LD_ADDR_VAR 0 13
63227: PUSH
63228: LD_INT 0
63230: PUSH
63231: LD_INT 0
63233: PUSH
63234: EMPTY
63235: LIST
63236: LIST
63237: PUSH
63238: LD_INT 0
63240: PUSH
63241: LD_INT 1
63243: NEG
63244: PUSH
63245: EMPTY
63246: LIST
63247: LIST
63248: PUSH
63249: LD_INT 1
63251: PUSH
63252: LD_INT 0
63254: PUSH
63255: EMPTY
63256: LIST
63257: LIST
63258: PUSH
63259: LD_INT 1
63261: PUSH
63262: LD_INT 1
63264: PUSH
63265: EMPTY
63266: LIST
63267: LIST
63268: PUSH
63269: LD_INT 0
63271: PUSH
63272: LD_INT 1
63274: PUSH
63275: EMPTY
63276: LIST
63277: LIST
63278: PUSH
63279: LD_INT 1
63281: NEG
63282: PUSH
63283: LD_INT 0
63285: PUSH
63286: EMPTY
63287: LIST
63288: LIST
63289: PUSH
63290: LD_INT 1
63292: NEG
63293: PUSH
63294: LD_INT 1
63296: NEG
63297: PUSH
63298: EMPTY
63299: LIST
63300: LIST
63301: PUSH
63302: LD_INT 1
63304: NEG
63305: PUSH
63306: LD_INT 2
63308: NEG
63309: PUSH
63310: EMPTY
63311: LIST
63312: LIST
63313: PUSH
63314: LD_INT 2
63316: PUSH
63317: LD_INT 1
63319: PUSH
63320: EMPTY
63321: LIST
63322: LIST
63323: PUSH
63324: LD_INT 2
63326: PUSH
63327: LD_INT 2
63329: PUSH
63330: EMPTY
63331: LIST
63332: LIST
63333: PUSH
63334: LD_INT 1
63336: PUSH
63337: LD_INT 2
63339: PUSH
63340: EMPTY
63341: LIST
63342: LIST
63343: PUSH
63344: LD_INT 2
63346: NEG
63347: PUSH
63348: LD_INT 1
63350: NEG
63351: PUSH
63352: EMPTY
63353: LIST
63354: LIST
63355: PUSH
63356: LD_INT 2
63358: NEG
63359: PUSH
63360: LD_INT 2
63362: NEG
63363: PUSH
63364: EMPTY
63365: LIST
63366: LIST
63367: PUSH
63368: LD_INT 2
63370: NEG
63371: PUSH
63372: LD_INT 3
63374: NEG
63375: PUSH
63376: EMPTY
63377: LIST
63378: LIST
63379: PUSH
63380: LD_INT 3
63382: NEG
63383: PUSH
63384: LD_INT 2
63386: NEG
63387: PUSH
63388: EMPTY
63389: LIST
63390: LIST
63391: PUSH
63392: LD_INT 3
63394: NEG
63395: PUSH
63396: LD_INT 3
63398: NEG
63399: PUSH
63400: EMPTY
63401: LIST
63402: LIST
63403: PUSH
63404: EMPTY
63405: LIST
63406: LIST
63407: LIST
63408: LIST
63409: LIST
63410: LIST
63411: LIST
63412: LIST
63413: LIST
63414: LIST
63415: LIST
63416: LIST
63417: LIST
63418: LIST
63419: LIST
63420: LIST
63421: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63422: LD_ADDR_VAR 0 14
63426: PUSH
63427: LD_INT 0
63429: PUSH
63430: LD_INT 0
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PUSH
63437: LD_INT 0
63439: PUSH
63440: LD_INT 1
63442: NEG
63443: PUSH
63444: EMPTY
63445: LIST
63446: LIST
63447: PUSH
63448: LD_INT 1
63450: PUSH
63451: LD_INT 0
63453: PUSH
63454: EMPTY
63455: LIST
63456: LIST
63457: PUSH
63458: LD_INT 1
63460: PUSH
63461: LD_INT 1
63463: PUSH
63464: EMPTY
63465: LIST
63466: LIST
63467: PUSH
63468: LD_INT 0
63470: PUSH
63471: LD_INT 1
63473: PUSH
63474: EMPTY
63475: LIST
63476: LIST
63477: PUSH
63478: LD_INT 1
63480: NEG
63481: PUSH
63482: LD_INT 0
63484: PUSH
63485: EMPTY
63486: LIST
63487: LIST
63488: PUSH
63489: LD_INT 1
63491: NEG
63492: PUSH
63493: LD_INT 1
63495: NEG
63496: PUSH
63497: EMPTY
63498: LIST
63499: LIST
63500: PUSH
63501: LD_INT 1
63503: NEG
63504: PUSH
63505: LD_INT 2
63507: NEG
63508: PUSH
63509: EMPTY
63510: LIST
63511: LIST
63512: PUSH
63513: LD_INT 0
63515: PUSH
63516: LD_INT 2
63518: NEG
63519: PUSH
63520: EMPTY
63521: LIST
63522: LIST
63523: PUSH
63524: LD_INT 1
63526: PUSH
63527: LD_INT 1
63529: NEG
63530: PUSH
63531: EMPTY
63532: LIST
63533: LIST
63534: PUSH
63535: LD_INT 1
63537: PUSH
63538: LD_INT 2
63540: PUSH
63541: EMPTY
63542: LIST
63543: LIST
63544: PUSH
63545: LD_INT 0
63547: PUSH
63548: LD_INT 2
63550: PUSH
63551: EMPTY
63552: LIST
63553: LIST
63554: PUSH
63555: LD_INT 1
63557: NEG
63558: PUSH
63559: LD_INT 1
63561: PUSH
63562: EMPTY
63563: LIST
63564: LIST
63565: PUSH
63566: LD_INT 1
63568: NEG
63569: PUSH
63570: LD_INT 3
63572: NEG
63573: PUSH
63574: EMPTY
63575: LIST
63576: LIST
63577: PUSH
63578: LD_INT 0
63580: PUSH
63581: LD_INT 3
63583: NEG
63584: PUSH
63585: EMPTY
63586: LIST
63587: LIST
63588: PUSH
63589: LD_INT 1
63591: PUSH
63592: LD_INT 2
63594: NEG
63595: PUSH
63596: EMPTY
63597: LIST
63598: LIST
63599: PUSH
63600: EMPTY
63601: LIST
63602: LIST
63603: LIST
63604: LIST
63605: LIST
63606: LIST
63607: LIST
63608: LIST
63609: LIST
63610: LIST
63611: LIST
63612: LIST
63613: LIST
63614: LIST
63615: LIST
63616: LIST
63617: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63618: LD_ADDR_VAR 0 15
63622: PUSH
63623: LD_INT 0
63625: PUSH
63626: LD_INT 0
63628: PUSH
63629: EMPTY
63630: LIST
63631: LIST
63632: PUSH
63633: LD_INT 0
63635: PUSH
63636: LD_INT 1
63638: NEG
63639: PUSH
63640: EMPTY
63641: LIST
63642: LIST
63643: PUSH
63644: LD_INT 1
63646: PUSH
63647: LD_INT 0
63649: PUSH
63650: EMPTY
63651: LIST
63652: LIST
63653: PUSH
63654: LD_INT 1
63656: PUSH
63657: LD_INT 1
63659: PUSH
63660: EMPTY
63661: LIST
63662: LIST
63663: PUSH
63664: LD_INT 0
63666: PUSH
63667: LD_INT 1
63669: PUSH
63670: EMPTY
63671: LIST
63672: LIST
63673: PUSH
63674: LD_INT 1
63676: NEG
63677: PUSH
63678: LD_INT 0
63680: PUSH
63681: EMPTY
63682: LIST
63683: LIST
63684: PUSH
63685: LD_INT 1
63687: NEG
63688: PUSH
63689: LD_INT 1
63691: NEG
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PUSH
63697: LD_INT 1
63699: PUSH
63700: LD_INT 1
63702: NEG
63703: PUSH
63704: EMPTY
63705: LIST
63706: LIST
63707: PUSH
63708: LD_INT 2
63710: PUSH
63711: LD_INT 0
63713: PUSH
63714: EMPTY
63715: LIST
63716: LIST
63717: PUSH
63718: LD_INT 2
63720: PUSH
63721: LD_INT 1
63723: PUSH
63724: EMPTY
63725: LIST
63726: LIST
63727: PUSH
63728: LD_INT 1
63730: NEG
63731: PUSH
63732: LD_INT 1
63734: PUSH
63735: EMPTY
63736: LIST
63737: LIST
63738: PUSH
63739: LD_INT 2
63741: NEG
63742: PUSH
63743: LD_INT 0
63745: PUSH
63746: EMPTY
63747: LIST
63748: LIST
63749: PUSH
63750: LD_INT 2
63752: NEG
63753: PUSH
63754: LD_INT 1
63756: NEG
63757: PUSH
63758: EMPTY
63759: LIST
63760: LIST
63761: PUSH
63762: LD_INT 2
63764: PUSH
63765: LD_INT 1
63767: NEG
63768: PUSH
63769: EMPTY
63770: LIST
63771: LIST
63772: PUSH
63773: LD_INT 3
63775: PUSH
63776: LD_INT 0
63778: PUSH
63779: EMPTY
63780: LIST
63781: LIST
63782: PUSH
63783: LD_INT 3
63785: PUSH
63786: LD_INT 1
63788: PUSH
63789: EMPTY
63790: LIST
63791: LIST
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: LIST
63797: LIST
63798: LIST
63799: LIST
63800: LIST
63801: LIST
63802: LIST
63803: LIST
63804: LIST
63805: LIST
63806: LIST
63807: LIST
63808: LIST
63809: LIST
63810: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
63811: LD_ADDR_VAR 0 16
63815: PUSH
63816: LD_INT 0
63818: PUSH
63819: LD_INT 0
63821: PUSH
63822: EMPTY
63823: LIST
63824: LIST
63825: PUSH
63826: LD_INT 0
63828: PUSH
63829: LD_INT 1
63831: NEG
63832: PUSH
63833: EMPTY
63834: LIST
63835: LIST
63836: PUSH
63837: LD_INT 1
63839: PUSH
63840: LD_INT 0
63842: PUSH
63843: EMPTY
63844: LIST
63845: LIST
63846: PUSH
63847: LD_INT 1
63849: PUSH
63850: LD_INT 1
63852: PUSH
63853: EMPTY
63854: LIST
63855: LIST
63856: PUSH
63857: LD_INT 0
63859: PUSH
63860: LD_INT 1
63862: PUSH
63863: EMPTY
63864: LIST
63865: LIST
63866: PUSH
63867: LD_INT 1
63869: NEG
63870: PUSH
63871: LD_INT 0
63873: PUSH
63874: EMPTY
63875: LIST
63876: LIST
63877: PUSH
63878: LD_INT 1
63880: NEG
63881: PUSH
63882: LD_INT 1
63884: NEG
63885: PUSH
63886: EMPTY
63887: LIST
63888: LIST
63889: PUSH
63890: LD_INT 1
63892: NEG
63893: PUSH
63894: LD_INT 2
63896: NEG
63897: PUSH
63898: EMPTY
63899: LIST
63900: LIST
63901: PUSH
63902: LD_INT 2
63904: PUSH
63905: LD_INT 1
63907: PUSH
63908: EMPTY
63909: LIST
63910: LIST
63911: PUSH
63912: LD_INT 2
63914: PUSH
63915: LD_INT 2
63917: PUSH
63918: EMPTY
63919: LIST
63920: LIST
63921: PUSH
63922: LD_INT 1
63924: PUSH
63925: LD_INT 2
63927: PUSH
63928: EMPTY
63929: LIST
63930: LIST
63931: PUSH
63932: LD_INT 2
63934: NEG
63935: PUSH
63936: LD_INT 1
63938: NEG
63939: PUSH
63940: EMPTY
63941: LIST
63942: LIST
63943: PUSH
63944: LD_INT 2
63946: NEG
63947: PUSH
63948: LD_INT 2
63950: NEG
63951: PUSH
63952: EMPTY
63953: LIST
63954: LIST
63955: PUSH
63956: LD_INT 3
63958: PUSH
63959: LD_INT 2
63961: PUSH
63962: EMPTY
63963: LIST
63964: LIST
63965: PUSH
63966: LD_INT 3
63968: PUSH
63969: LD_INT 3
63971: PUSH
63972: EMPTY
63973: LIST
63974: LIST
63975: PUSH
63976: LD_INT 2
63978: PUSH
63979: LD_INT 3
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: PUSH
63986: EMPTY
63987: LIST
63988: LIST
63989: LIST
63990: LIST
63991: LIST
63992: LIST
63993: LIST
63994: LIST
63995: LIST
63996: LIST
63997: LIST
63998: LIST
63999: LIST
64000: LIST
64001: LIST
64002: LIST
64003: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64004: LD_ADDR_VAR 0 17
64008: PUSH
64009: LD_INT 0
64011: PUSH
64012: LD_INT 0
64014: PUSH
64015: EMPTY
64016: LIST
64017: LIST
64018: PUSH
64019: LD_INT 0
64021: PUSH
64022: LD_INT 1
64024: NEG
64025: PUSH
64026: EMPTY
64027: LIST
64028: LIST
64029: PUSH
64030: LD_INT 1
64032: PUSH
64033: LD_INT 0
64035: PUSH
64036: EMPTY
64037: LIST
64038: LIST
64039: PUSH
64040: LD_INT 1
64042: PUSH
64043: LD_INT 1
64045: PUSH
64046: EMPTY
64047: LIST
64048: LIST
64049: PUSH
64050: LD_INT 0
64052: PUSH
64053: LD_INT 1
64055: PUSH
64056: EMPTY
64057: LIST
64058: LIST
64059: PUSH
64060: LD_INT 1
64062: NEG
64063: PUSH
64064: LD_INT 0
64066: PUSH
64067: EMPTY
64068: LIST
64069: LIST
64070: PUSH
64071: LD_INT 1
64073: NEG
64074: PUSH
64075: LD_INT 1
64077: NEG
64078: PUSH
64079: EMPTY
64080: LIST
64081: LIST
64082: PUSH
64083: LD_INT 1
64085: NEG
64086: PUSH
64087: LD_INT 2
64089: NEG
64090: PUSH
64091: EMPTY
64092: LIST
64093: LIST
64094: PUSH
64095: LD_INT 0
64097: PUSH
64098: LD_INT 2
64100: NEG
64101: PUSH
64102: EMPTY
64103: LIST
64104: LIST
64105: PUSH
64106: LD_INT 1
64108: PUSH
64109: LD_INT 1
64111: NEG
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: PUSH
64117: LD_INT 2
64119: PUSH
64120: LD_INT 0
64122: PUSH
64123: EMPTY
64124: LIST
64125: LIST
64126: PUSH
64127: LD_INT 2
64129: PUSH
64130: LD_INT 1
64132: PUSH
64133: EMPTY
64134: LIST
64135: LIST
64136: PUSH
64137: LD_INT 2
64139: PUSH
64140: LD_INT 2
64142: PUSH
64143: EMPTY
64144: LIST
64145: LIST
64146: PUSH
64147: LD_INT 1
64149: PUSH
64150: LD_INT 2
64152: PUSH
64153: EMPTY
64154: LIST
64155: LIST
64156: PUSH
64157: LD_INT 0
64159: PUSH
64160: LD_INT 2
64162: PUSH
64163: EMPTY
64164: LIST
64165: LIST
64166: PUSH
64167: LD_INT 1
64169: NEG
64170: PUSH
64171: LD_INT 1
64173: PUSH
64174: EMPTY
64175: LIST
64176: LIST
64177: PUSH
64178: LD_INT 2
64180: NEG
64181: PUSH
64182: LD_INT 0
64184: PUSH
64185: EMPTY
64186: LIST
64187: LIST
64188: PUSH
64189: LD_INT 2
64191: NEG
64192: PUSH
64193: LD_INT 1
64195: NEG
64196: PUSH
64197: EMPTY
64198: LIST
64199: LIST
64200: PUSH
64201: LD_INT 2
64203: NEG
64204: PUSH
64205: LD_INT 2
64207: NEG
64208: PUSH
64209: EMPTY
64210: LIST
64211: LIST
64212: PUSH
64213: EMPTY
64214: LIST
64215: LIST
64216: LIST
64217: LIST
64218: LIST
64219: LIST
64220: LIST
64221: LIST
64222: LIST
64223: LIST
64224: LIST
64225: LIST
64226: LIST
64227: LIST
64228: LIST
64229: LIST
64230: LIST
64231: LIST
64232: LIST
64233: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64234: LD_ADDR_VAR 0 18
64238: PUSH
64239: LD_INT 0
64241: PUSH
64242: LD_INT 0
64244: PUSH
64245: EMPTY
64246: LIST
64247: LIST
64248: PUSH
64249: LD_INT 0
64251: PUSH
64252: LD_INT 1
64254: NEG
64255: PUSH
64256: EMPTY
64257: LIST
64258: LIST
64259: PUSH
64260: LD_INT 1
64262: PUSH
64263: LD_INT 0
64265: PUSH
64266: EMPTY
64267: LIST
64268: LIST
64269: PUSH
64270: LD_INT 1
64272: PUSH
64273: LD_INT 1
64275: PUSH
64276: EMPTY
64277: LIST
64278: LIST
64279: PUSH
64280: LD_INT 0
64282: PUSH
64283: LD_INT 1
64285: PUSH
64286: EMPTY
64287: LIST
64288: LIST
64289: PUSH
64290: LD_INT 1
64292: NEG
64293: PUSH
64294: LD_INT 0
64296: PUSH
64297: EMPTY
64298: LIST
64299: LIST
64300: PUSH
64301: LD_INT 1
64303: NEG
64304: PUSH
64305: LD_INT 1
64307: NEG
64308: PUSH
64309: EMPTY
64310: LIST
64311: LIST
64312: PUSH
64313: LD_INT 1
64315: NEG
64316: PUSH
64317: LD_INT 2
64319: NEG
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: PUSH
64325: LD_INT 0
64327: PUSH
64328: LD_INT 2
64330: NEG
64331: PUSH
64332: EMPTY
64333: LIST
64334: LIST
64335: PUSH
64336: LD_INT 1
64338: PUSH
64339: LD_INT 1
64341: NEG
64342: PUSH
64343: EMPTY
64344: LIST
64345: LIST
64346: PUSH
64347: LD_INT 2
64349: PUSH
64350: LD_INT 0
64352: PUSH
64353: EMPTY
64354: LIST
64355: LIST
64356: PUSH
64357: LD_INT 2
64359: PUSH
64360: LD_INT 1
64362: PUSH
64363: EMPTY
64364: LIST
64365: LIST
64366: PUSH
64367: LD_INT 2
64369: PUSH
64370: LD_INT 2
64372: PUSH
64373: EMPTY
64374: LIST
64375: LIST
64376: PUSH
64377: LD_INT 1
64379: PUSH
64380: LD_INT 2
64382: PUSH
64383: EMPTY
64384: LIST
64385: LIST
64386: PUSH
64387: LD_INT 0
64389: PUSH
64390: LD_INT 2
64392: PUSH
64393: EMPTY
64394: LIST
64395: LIST
64396: PUSH
64397: LD_INT 1
64399: NEG
64400: PUSH
64401: LD_INT 1
64403: PUSH
64404: EMPTY
64405: LIST
64406: LIST
64407: PUSH
64408: LD_INT 2
64410: NEG
64411: PUSH
64412: LD_INT 0
64414: PUSH
64415: EMPTY
64416: LIST
64417: LIST
64418: PUSH
64419: LD_INT 2
64421: NEG
64422: PUSH
64423: LD_INT 1
64425: NEG
64426: PUSH
64427: EMPTY
64428: LIST
64429: LIST
64430: PUSH
64431: LD_INT 2
64433: NEG
64434: PUSH
64435: LD_INT 2
64437: NEG
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: EMPTY
64444: LIST
64445: LIST
64446: LIST
64447: LIST
64448: LIST
64449: LIST
64450: LIST
64451: LIST
64452: LIST
64453: LIST
64454: LIST
64455: LIST
64456: LIST
64457: LIST
64458: LIST
64459: LIST
64460: LIST
64461: LIST
64462: LIST
64463: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64464: LD_ADDR_VAR 0 19
64468: PUSH
64469: LD_INT 0
64471: PUSH
64472: LD_INT 0
64474: PUSH
64475: EMPTY
64476: LIST
64477: LIST
64478: PUSH
64479: LD_INT 0
64481: PUSH
64482: LD_INT 1
64484: NEG
64485: PUSH
64486: EMPTY
64487: LIST
64488: LIST
64489: PUSH
64490: LD_INT 1
64492: PUSH
64493: LD_INT 0
64495: PUSH
64496: EMPTY
64497: LIST
64498: LIST
64499: PUSH
64500: LD_INT 1
64502: PUSH
64503: LD_INT 1
64505: PUSH
64506: EMPTY
64507: LIST
64508: LIST
64509: PUSH
64510: LD_INT 0
64512: PUSH
64513: LD_INT 1
64515: PUSH
64516: EMPTY
64517: LIST
64518: LIST
64519: PUSH
64520: LD_INT 1
64522: NEG
64523: PUSH
64524: LD_INT 0
64526: PUSH
64527: EMPTY
64528: LIST
64529: LIST
64530: PUSH
64531: LD_INT 1
64533: NEG
64534: PUSH
64535: LD_INT 1
64537: NEG
64538: PUSH
64539: EMPTY
64540: LIST
64541: LIST
64542: PUSH
64543: LD_INT 1
64545: NEG
64546: PUSH
64547: LD_INT 2
64549: NEG
64550: PUSH
64551: EMPTY
64552: LIST
64553: LIST
64554: PUSH
64555: LD_INT 0
64557: PUSH
64558: LD_INT 2
64560: NEG
64561: PUSH
64562: EMPTY
64563: LIST
64564: LIST
64565: PUSH
64566: LD_INT 1
64568: PUSH
64569: LD_INT 1
64571: NEG
64572: PUSH
64573: EMPTY
64574: LIST
64575: LIST
64576: PUSH
64577: LD_INT 2
64579: PUSH
64580: LD_INT 0
64582: PUSH
64583: EMPTY
64584: LIST
64585: LIST
64586: PUSH
64587: LD_INT 2
64589: PUSH
64590: LD_INT 1
64592: PUSH
64593: EMPTY
64594: LIST
64595: LIST
64596: PUSH
64597: LD_INT 2
64599: PUSH
64600: LD_INT 2
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PUSH
64607: LD_INT 1
64609: PUSH
64610: LD_INT 2
64612: PUSH
64613: EMPTY
64614: LIST
64615: LIST
64616: PUSH
64617: LD_INT 0
64619: PUSH
64620: LD_INT 2
64622: PUSH
64623: EMPTY
64624: LIST
64625: LIST
64626: PUSH
64627: LD_INT 1
64629: NEG
64630: PUSH
64631: LD_INT 1
64633: PUSH
64634: EMPTY
64635: LIST
64636: LIST
64637: PUSH
64638: LD_INT 2
64640: NEG
64641: PUSH
64642: LD_INT 0
64644: PUSH
64645: EMPTY
64646: LIST
64647: LIST
64648: PUSH
64649: LD_INT 2
64651: NEG
64652: PUSH
64653: LD_INT 1
64655: NEG
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: PUSH
64661: LD_INT 2
64663: NEG
64664: PUSH
64665: LD_INT 2
64667: NEG
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: PUSH
64673: EMPTY
64674: LIST
64675: LIST
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: LIST
64684: LIST
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64694: LD_ADDR_VAR 0 20
64698: PUSH
64699: LD_INT 0
64701: PUSH
64702: LD_INT 0
64704: PUSH
64705: EMPTY
64706: LIST
64707: LIST
64708: PUSH
64709: LD_INT 0
64711: PUSH
64712: LD_INT 1
64714: NEG
64715: PUSH
64716: EMPTY
64717: LIST
64718: LIST
64719: PUSH
64720: LD_INT 1
64722: PUSH
64723: LD_INT 0
64725: PUSH
64726: EMPTY
64727: LIST
64728: LIST
64729: PUSH
64730: LD_INT 1
64732: PUSH
64733: LD_INT 1
64735: PUSH
64736: EMPTY
64737: LIST
64738: LIST
64739: PUSH
64740: LD_INT 0
64742: PUSH
64743: LD_INT 1
64745: PUSH
64746: EMPTY
64747: LIST
64748: LIST
64749: PUSH
64750: LD_INT 1
64752: NEG
64753: PUSH
64754: LD_INT 0
64756: PUSH
64757: EMPTY
64758: LIST
64759: LIST
64760: PUSH
64761: LD_INT 1
64763: NEG
64764: PUSH
64765: LD_INT 1
64767: NEG
64768: PUSH
64769: EMPTY
64770: LIST
64771: LIST
64772: PUSH
64773: LD_INT 1
64775: NEG
64776: PUSH
64777: LD_INT 2
64779: NEG
64780: PUSH
64781: EMPTY
64782: LIST
64783: LIST
64784: PUSH
64785: LD_INT 0
64787: PUSH
64788: LD_INT 2
64790: NEG
64791: PUSH
64792: EMPTY
64793: LIST
64794: LIST
64795: PUSH
64796: LD_INT 1
64798: PUSH
64799: LD_INT 1
64801: NEG
64802: PUSH
64803: EMPTY
64804: LIST
64805: LIST
64806: PUSH
64807: LD_INT 2
64809: PUSH
64810: LD_INT 0
64812: PUSH
64813: EMPTY
64814: LIST
64815: LIST
64816: PUSH
64817: LD_INT 2
64819: PUSH
64820: LD_INT 1
64822: PUSH
64823: EMPTY
64824: LIST
64825: LIST
64826: PUSH
64827: LD_INT 2
64829: PUSH
64830: LD_INT 2
64832: PUSH
64833: EMPTY
64834: LIST
64835: LIST
64836: PUSH
64837: LD_INT 1
64839: PUSH
64840: LD_INT 2
64842: PUSH
64843: EMPTY
64844: LIST
64845: LIST
64846: PUSH
64847: LD_INT 0
64849: PUSH
64850: LD_INT 2
64852: PUSH
64853: EMPTY
64854: LIST
64855: LIST
64856: PUSH
64857: LD_INT 1
64859: NEG
64860: PUSH
64861: LD_INT 1
64863: PUSH
64864: EMPTY
64865: LIST
64866: LIST
64867: PUSH
64868: LD_INT 2
64870: NEG
64871: PUSH
64872: LD_INT 0
64874: PUSH
64875: EMPTY
64876: LIST
64877: LIST
64878: PUSH
64879: LD_INT 2
64881: NEG
64882: PUSH
64883: LD_INT 1
64885: NEG
64886: PUSH
64887: EMPTY
64888: LIST
64889: LIST
64890: PUSH
64891: LD_INT 2
64893: NEG
64894: PUSH
64895: LD_INT 2
64897: NEG
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: EMPTY
64904: LIST
64905: LIST
64906: LIST
64907: LIST
64908: LIST
64909: LIST
64910: LIST
64911: LIST
64912: LIST
64913: LIST
64914: LIST
64915: LIST
64916: LIST
64917: LIST
64918: LIST
64919: LIST
64920: LIST
64921: LIST
64922: LIST
64923: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64924: LD_ADDR_VAR 0 21
64928: PUSH
64929: LD_INT 0
64931: PUSH
64932: LD_INT 0
64934: PUSH
64935: EMPTY
64936: LIST
64937: LIST
64938: PUSH
64939: LD_INT 0
64941: PUSH
64942: LD_INT 1
64944: NEG
64945: PUSH
64946: EMPTY
64947: LIST
64948: LIST
64949: PUSH
64950: LD_INT 1
64952: PUSH
64953: LD_INT 0
64955: PUSH
64956: EMPTY
64957: LIST
64958: LIST
64959: PUSH
64960: LD_INT 1
64962: PUSH
64963: LD_INT 1
64965: PUSH
64966: EMPTY
64967: LIST
64968: LIST
64969: PUSH
64970: LD_INT 0
64972: PUSH
64973: LD_INT 1
64975: PUSH
64976: EMPTY
64977: LIST
64978: LIST
64979: PUSH
64980: LD_INT 1
64982: NEG
64983: PUSH
64984: LD_INT 0
64986: PUSH
64987: EMPTY
64988: LIST
64989: LIST
64990: PUSH
64991: LD_INT 1
64993: NEG
64994: PUSH
64995: LD_INT 1
64997: NEG
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: PUSH
65003: LD_INT 1
65005: NEG
65006: PUSH
65007: LD_INT 2
65009: NEG
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: PUSH
65015: LD_INT 0
65017: PUSH
65018: LD_INT 2
65020: NEG
65021: PUSH
65022: EMPTY
65023: LIST
65024: LIST
65025: PUSH
65026: LD_INT 1
65028: PUSH
65029: LD_INT 1
65031: NEG
65032: PUSH
65033: EMPTY
65034: LIST
65035: LIST
65036: PUSH
65037: LD_INT 2
65039: PUSH
65040: LD_INT 0
65042: PUSH
65043: EMPTY
65044: LIST
65045: LIST
65046: PUSH
65047: LD_INT 2
65049: PUSH
65050: LD_INT 1
65052: PUSH
65053: EMPTY
65054: LIST
65055: LIST
65056: PUSH
65057: LD_INT 2
65059: PUSH
65060: LD_INT 2
65062: PUSH
65063: EMPTY
65064: LIST
65065: LIST
65066: PUSH
65067: LD_INT 1
65069: PUSH
65070: LD_INT 2
65072: PUSH
65073: EMPTY
65074: LIST
65075: LIST
65076: PUSH
65077: LD_INT 0
65079: PUSH
65080: LD_INT 2
65082: PUSH
65083: EMPTY
65084: LIST
65085: LIST
65086: PUSH
65087: LD_INT 1
65089: NEG
65090: PUSH
65091: LD_INT 1
65093: PUSH
65094: EMPTY
65095: LIST
65096: LIST
65097: PUSH
65098: LD_INT 2
65100: NEG
65101: PUSH
65102: LD_INT 0
65104: PUSH
65105: EMPTY
65106: LIST
65107: LIST
65108: PUSH
65109: LD_INT 2
65111: NEG
65112: PUSH
65113: LD_INT 1
65115: NEG
65116: PUSH
65117: EMPTY
65118: LIST
65119: LIST
65120: PUSH
65121: LD_INT 2
65123: NEG
65124: PUSH
65125: LD_INT 2
65127: NEG
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: PUSH
65133: EMPTY
65134: LIST
65135: LIST
65136: LIST
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65154: LD_ADDR_VAR 0 22
65158: PUSH
65159: LD_INT 0
65161: PUSH
65162: LD_INT 0
65164: PUSH
65165: EMPTY
65166: LIST
65167: LIST
65168: PUSH
65169: LD_INT 0
65171: PUSH
65172: LD_INT 1
65174: NEG
65175: PUSH
65176: EMPTY
65177: LIST
65178: LIST
65179: PUSH
65180: LD_INT 1
65182: PUSH
65183: LD_INT 0
65185: PUSH
65186: EMPTY
65187: LIST
65188: LIST
65189: PUSH
65190: LD_INT 1
65192: PUSH
65193: LD_INT 1
65195: PUSH
65196: EMPTY
65197: LIST
65198: LIST
65199: PUSH
65200: LD_INT 0
65202: PUSH
65203: LD_INT 1
65205: PUSH
65206: EMPTY
65207: LIST
65208: LIST
65209: PUSH
65210: LD_INT 1
65212: NEG
65213: PUSH
65214: LD_INT 0
65216: PUSH
65217: EMPTY
65218: LIST
65219: LIST
65220: PUSH
65221: LD_INT 1
65223: NEG
65224: PUSH
65225: LD_INT 1
65227: NEG
65228: PUSH
65229: EMPTY
65230: LIST
65231: LIST
65232: PUSH
65233: LD_INT 1
65235: NEG
65236: PUSH
65237: LD_INT 2
65239: NEG
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: LD_INT 0
65247: PUSH
65248: LD_INT 2
65250: NEG
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: PUSH
65256: LD_INT 1
65258: PUSH
65259: LD_INT 1
65261: NEG
65262: PUSH
65263: EMPTY
65264: LIST
65265: LIST
65266: PUSH
65267: LD_INT 2
65269: PUSH
65270: LD_INT 0
65272: PUSH
65273: EMPTY
65274: LIST
65275: LIST
65276: PUSH
65277: LD_INT 2
65279: PUSH
65280: LD_INT 1
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: LD_INT 2
65289: PUSH
65290: LD_INT 2
65292: PUSH
65293: EMPTY
65294: LIST
65295: LIST
65296: PUSH
65297: LD_INT 1
65299: PUSH
65300: LD_INT 2
65302: PUSH
65303: EMPTY
65304: LIST
65305: LIST
65306: PUSH
65307: LD_INT 0
65309: PUSH
65310: LD_INT 2
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PUSH
65317: LD_INT 1
65319: NEG
65320: PUSH
65321: LD_INT 1
65323: PUSH
65324: EMPTY
65325: LIST
65326: LIST
65327: PUSH
65328: LD_INT 2
65330: NEG
65331: PUSH
65332: LD_INT 0
65334: PUSH
65335: EMPTY
65336: LIST
65337: LIST
65338: PUSH
65339: LD_INT 2
65341: NEG
65342: PUSH
65343: LD_INT 1
65345: NEG
65346: PUSH
65347: EMPTY
65348: LIST
65349: LIST
65350: PUSH
65351: LD_INT 2
65353: NEG
65354: PUSH
65355: LD_INT 2
65357: NEG
65358: PUSH
65359: EMPTY
65360: LIST
65361: LIST
65362: PUSH
65363: EMPTY
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65384: LD_ADDR_VAR 0 23
65388: PUSH
65389: LD_INT 0
65391: PUSH
65392: LD_INT 0
65394: PUSH
65395: EMPTY
65396: LIST
65397: LIST
65398: PUSH
65399: LD_INT 0
65401: PUSH
65402: LD_INT 1
65404: NEG
65405: PUSH
65406: EMPTY
65407: LIST
65408: LIST
65409: PUSH
65410: LD_INT 1
65412: PUSH
65413: LD_INT 0
65415: PUSH
65416: EMPTY
65417: LIST
65418: LIST
65419: PUSH
65420: LD_INT 1
65422: PUSH
65423: LD_INT 1
65425: PUSH
65426: EMPTY
65427: LIST
65428: LIST
65429: PUSH
65430: LD_INT 0
65432: PUSH
65433: LD_INT 1
65435: PUSH
65436: EMPTY
65437: LIST
65438: LIST
65439: PUSH
65440: LD_INT 1
65442: NEG
65443: PUSH
65444: LD_INT 0
65446: PUSH
65447: EMPTY
65448: LIST
65449: LIST
65450: PUSH
65451: LD_INT 1
65453: NEG
65454: PUSH
65455: LD_INT 1
65457: NEG
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: PUSH
65463: LD_INT 1
65465: NEG
65466: PUSH
65467: LD_INT 2
65469: NEG
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: LD_INT 0
65477: PUSH
65478: LD_INT 2
65480: NEG
65481: PUSH
65482: EMPTY
65483: LIST
65484: LIST
65485: PUSH
65486: LD_INT 1
65488: PUSH
65489: LD_INT 1
65491: NEG
65492: PUSH
65493: EMPTY
65494: LIST
65495: LIST
65496: PUSH
65497: LD_INT 2
65499: PUSH
65500: LD_INT 0
65502: PUSH
65503: EMPTY
65504: LIST
65505: LIST
65506: PUSH
65507: LD_INT 2
65509: PUSH
65510: LD_INT 1
65512: PUSH
65513: EMPTY
65514: LIST
65515: LIST
65516: PUSH
65517: LD_INT 2
65519: PUSH
65520: LD_INT 2
65522: PUSH
65523: EMPTY
65524: LIST
65525: LIST
65526: PUSH
65527: LD_INT 1
65529: PUSH
65530: LD_INT 2
65532: PUSH
65533: EMPTY
65534: LIST
65535: LIST
65536: PUSH
65537: LD_INT 0
65539: PUSH
65540: LD_INT 2
65542: PUSH
65543: EMPTY
65544: LIST
65545: LIST
65546: PUSH
65547: LD_INT 1
65549: NEG
65550: PUSH
65551: LD_INT 1
65553: PUSH
65554: EMPTY
65555: LIST
65556: LIST
65557: PUSH
65558: LD_INT 2
65560: NEG
65561: PUSH
65562: LD_INT 0
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: PUSH
65569: LD_INT 2
65571: NEG
65572: PUSH
65573: LD_INT 1
65575: NEG
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: PUSH
65581: LD_INT 2
65583: NEG
65584: PUSH
65585: LD_INT 2
65587: NEG
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: LD_INT 2
65595: NEG
65596: PUSH
65597: LD_INT 3
65599: NEG
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: LD_INT 1
65607: NEG
65608: PUSH
65609: LD_INT 3
65611: NEG
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: PUSH
65617: LD_INT 1
65619: PUSH
65620: LD_INT 2
65622: NEG
65623: PUSH
65624: EMPTY
65625: LIST
65626: LIST
65627: PUSH
65628: LD_INT 2
65630: PUSH
65631: LD_INT 1
65633: NEG
65634: PUSH
65635: EMPTY
65636: LIST
65637: LIST
65638: PUSH
65639: EMPTY
65640: LIST
65641: LIST
65642: LIST
65643: LIST
65644: LIST
65645: LIST
65646: LIST
65647: LIST
65648: LIST
65649: LIST
65650: LIST
65651: LIST
65652: LIST
65653: LIST
65654: LIST
65655: LIST
65656: LIST
65657: LIST
65658: LIST
65659: LIST
65660: LIST
65661: LIST
65662: LIST
65663: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65664: LD_ADDR_VAR 0 24
65668: PUSH
65669: LD_INT 0
65671: PUSH
65672: LD_INT 0
65674: PUSH
65675: EMPTY
65676: LIST
65677: LIST
65678: PUSH
65679: LD_INT 0
65681: PUSH
65682: LD_INT 1
65684: NEG
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: PUSH
65690: LD_INT 1
65692: PUSH
65693: LD_INT 0
65695: PUSH
65696: EMPTY
65697: LIST
65698: LIST
65699: PUSH
65700: LD_INT 1
65702: PUSH
65703: LD_INT 1
65705: PUSH
65706: EMPTY
65707: LIST
65708: LIST
65709: PUSH
65710: LD_INT 0
65712: PUSH
65713: LD_INT 1
65715: PUSH
65716: EMPTY
65717: LIST
65718: LIST
65719: PUSH
65720: LD_INT 1
65722: NEG
65723: PUSH
65724: LD_INT 0
65726: PUSH
65727: EMPTY
65728: LIST
65729: LIST
65730: PUSH
65731: LD_INT 1
65733: NEG
65734: PUSH
65735: LD_INT 1
65737: NEG
65738: PUSH
65739: EMPTY
65740: LIST
65741: LIST
65742: PUSH
65743: LD_INT 1
65745: NEG
65746: PUSH
65747: LD_INT 2
65749: NEG
65750: PUSH
65751: EMPTY
65752: LIST
65753: LIST
65754: PUSH
65755: LD_INT 0
65757: PUSH
65758: LD_INT 2
65760: NEG
65761: PUSH
65762: EMPTY
65763: LIST
65764: LIST
65765: PUSH
65766: LD_INT 1
65768: PUSH
65769: LD_INT 1
65771: NEG
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: PUSH
65777: LD_INT 2
65779: PUSH
65780: LD_INT 0
65782: PUSH
65783: EMPTY
65784: LIST
65785: LIST
65786: PUSH
65787: LD_INT 2
65789: PUSH
65790: LD_INT 1
65792: PUSH
65793: EMPTY
65794: LIST
65795: LIST
65796: PUSH
65797: LD_INT 2
65799: PUSH
65800: LD_INT 2
65802: PUSH
65803: EMPTY
65804: LIST
65805: LIST
65806: PUSH
65807: LD_INT 1
65809: PUSH
65810: LD_INT 2
65812: PUSH
65813: EMPTY
65814: LIST
65815: LIST
65816: PUSH
65817: LD_INT 0
65819: PUSH
65820: LD_INT 2
65822: PUSH
65823: EMPTY
65824: LIST
65825: LIST
65826: PUSH
65827: LD_INT 1
65829: NEG
65830: PUSH
65831: LD_INT 1
65833: PUSH
65834: EMPTY
65835: LIST
65836: LIST
65837: PUSH
65838: LD_INT 2
65840: NEG
65841: PUSH
65842: LD_INT 0
65844: PUSH
65845: EMPTY
65846: LIST
65847: LIST
65848: PUSH
65849: LD_INT 2
65851: NEG
65852: PUSH
65853: LD_INT 1
65855: NEG
65856: PUSH
65857: EMPTY
65858: LIST
65859: LIST
65860: PUSH
65861: LD_INT 2
65863: NEG
65864: PUSH
65865: LD_INT 2
65867: NEG
65868: PUSH
65869: EMPTY
65870: LIST
65871: LIST
65872: PUSH
65873: LD_INT 1
65875: PUSH
65876: LD_INT 2
65878: NEG
65879: PUSH
65880: EMPTY
65881: LIST
65882: LIST
65883: PUSH
65884: LD_INT 2
65886: PUSH
65887: LD_INT 1
65889: NEG
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PUSH
65895: LD_INT 3
65897: PUSH
65898: LD_INT 1
65900: PUSH
65901: EMPTY
65902: LIST
65903: LIST
65904: PUSH
65905: LD_INT 3
65907: PUSH
65908: LD_INT 2
65910: PUSH
65911: EMPTY
65912: LIST
65913: LIST
65914: PUSH
65915: EMPTY
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: LIST
65939: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
65940: LD_ADDR_VAR 0 25
65944: PUSH
65945: LD_INT 0
65947: PUSH
65948: LD_INT 0
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: PUSH
65955: LD_INT 0
65957: PUSH
65958: LD_INT 1
65960: NEG
65961: PUSH
65962: EMPTY
65963: LIST
65964: LIST
65965: PUSH
65966: LD_INT 1
65968: PUSH
65969: LD_INT 0
65971: PUSH
65972: EMPTY
65973: LIST
65974: LIST
65975: PUSH
65976: LD_INT 1
65978: PUSH
65979: LD_INT 1
65981: PUSH
65982: EMPTY
65983: LIST
65984: LIST
65985: PUSH
65986: LD_INT 0
65988: PUSH
65989: LD_INT 1
65991: PUSH
65992: EMPTY
65993: LIST
65994: LIST
65995: PUSH
65996: LD_INT 1
65998: NEG
65999: PUSH
66000: LD_INT 0
66002: PUSH
66003: EMPTY
66004: LIST
66005: LIST
66006: PUSH
66007: LD_INT 1
66009: NEG
66010: PUSH
66011: LD_INT 1
66013: NEG
66014: PUSH
66015: EMPTY
66016: LIST
66017: LIST
66018: PUSH
66019: LD_INT 1
66021: NEG
66022: PUSH
66023: LD_INT 2
66025: NEG
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PUSH
66031: LD_INT 0
66033: PUSH
66034: LD_INT 2
66036: NEG
66037: PUSH
66038: EMPTY
66039: LIST
66040: LIST
66041: PUSH
66042: LD_INT 1
66044: PUSH
66045: LD_INT 1
66047: NEG
66048: PUSH
66049: EMPTY
66050: LIST
66051: LIST
66052: PUSH
66053: LD_INT 2
66055: PUSH
66056: LD_INT 0
66058: PUSH
66059: EMPTY
66060: LIST
66061: LIST
66062: PUSH
66063: LD_INT 2
66065: PUSH
66066: LD_INT 1
66068: PUSH
66069: EMPTY
66070: LIST
66071: LIST
66072: PUSH
66073: LD_INT 2
66075: PUSH
66076: LD_INT 2
66078: PUSH
66079: EMPTY
66080: LIST
66081: LIST
66082: PUSH
66083: LD_INT 1
66085: PUSH
66086: LD_INT 2
66088: PUSH
66089: EMPTY
66090: LIST
66091: LIST
66092: PUSH
66093: LD_INT 0
66095: PUSH
66096: LD_INT 2
66098: PUSH
66099: EMPTY
66100: LIST
66101: LIST
66102: PUSH
66103: LD_INT 1
66105: NEG
66106: PUSH
66107: LD_INT 1
66109: PUSH
66110: EMPTY
66111: LIST
66112: LIST
66113: PUSH
66114: LD_INT 2
66116: NEG
66117: PUSH
66118: LD_INT 0
66120: PUSH
66121: EMPTY
66122: LIST
66123: LIST
66124: PUSH
66125: LD_INT 2
66127: NEG
66128: PUSH
66129: LD_INT 1
66131: NEG
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PUSH
66137: LD_INT 2
66139: NEG
66140: PUSH
66141: LD_INT 2
66143: NEG
66144: PUSH
66145: EMPTY
66146: LIST
66147: LIST
66148: PUSH
66149: LD_INT 3
66151: PUSH
66152: LD_INT 1
66154: PUSH
66155: EMPTY
66156: LIST
66157: LIST
66158: PUSH
66159: LD_INT 3
66161: PUSH
66162: LD_INT 2
66164: PUSH
66165: EMPTY
66166: LIST
66167: LIST
66168: PUSH
66169: LD_INT 2
66171: PUSH
66172: LD_INT 3
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: PUSH
66179: LD_INT 1
66181: PUSH
66182: LD_INT 3
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: LIST
66193: LIST
66194: LIST
66195: LIST
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: LIST
66212: LIST
66213: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66214: LD_ADDR_VAR 0 26
66218: PUSH
66219: LD_INT 0
66221: PUSH
66222: LD_INT 0
66224: PUSH
66225: EMPTY
66226: LIST
66227: LIST
66228: PUSH
66229: LD_INT 0
66231: PUSH
66232: LD_INT 1
66234: NEG
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: LD_INT 1
66242: PUSH
66243: LD_INT 0
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PUSH
66250: LD_INT 1
66252: PUSH
66253: LD_INT 1
66255: PUSH
66256: EMPTY
66257: LIST
66258: LIST
66259: PUSH
66260: LD_INT 0
66262: PUSH
66263: LD_INT 1
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 1
66272: NEG
66273: PUSH
66274: LD_INT 0
66276: PUSH
66277: EMPTY
66278: LIST
66279: LIST
66280: PUSH
66281: LD_INT 1
66283: NEG
66284: PUSH
66285: LD_INT 1
66287: NEG
66288: PUSH
66289: EMPTY
66290: LIST
66291: LIST
66292: PUSH
66293: LD_INT 1
66295: NEG
66296: PUSH
66297: LD_INT 2
66299: NEG
66300: PUSH
66301: EMPTY
66302: LIST
66303: LIST
66304: PUSH
66305: LD_INT 0
66307: PUSH
66308: LD_INT 2
66310: NEG
66311: PUSH
66312: EMPTY
66313: LIST
66314: LIST
66315: PUSH
66316: LD_INT 1
66318: PUSH
66319: LD_INT 1
66321: NEG
66322: PUSH
66323: EMPTY
66324: LIST
66325: LIST
66326: PUSH
66327: LD_INT 2
66329: PUSH
66330: LD_INT 0
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: LD_INT 2
66339: PUSH
66340: LD_INT 1
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 2
66349: PUSH
66350: LD_INT 2
66352: PUSH
66353: EMPTY
66354: LIST
66355: LIST
66356: PUSH
66357: LD_INT 1
66359: PUSH
66360: LD_INT 2
66362: PUSH
66363: EMPTY
66364: LIST
66365: LIST
66366: PUSH
66367: LD_INT 0
66369: PUSH
66370: LD_INT 2
66372: PUSH
66373: EMPTY
66374: LIST
66375: LIST
66376: PUSH
66377: LD_INT 1
66379: NEG
66380: PUSH
66381: LD_INT 1
66383: PUSH
66384: EMPTY
66385: LIST
66386: LIST
66387: PUSH
66388: LD_INT 2
66390: NEG
66391: PUSH
66392: LD_INT 0
66394: PUSH
66395: EMPTY
66396: LIST
66397: LIST
66398: PUSH
66399: LD_INT 2
66401: NEG
66402: PUSH
66403: LD_INT 1
66405: NEG
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 2
66413: NEG
66414: PUSH
66415: LD_INT 2
66417: NEG
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: PUSH
66423: LD_INT 2
66425: PUSH
66426: LD_INT 3
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PUSH
66433: LD_INT 1
66435: PUSH
66436: LD_INT 3
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 1
66445: NEG
66446: PUSH
66447: LD_INT 2
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 2
66456: NEG
66457: PUSH
66458: LD_INT 1
66460: PUSH
66461: EMPTY
66462: LIST
66463: LIST
66464: PUSH
66465: EMPTY
66466: LIST
66467: LIST
66468: LIST
66469: LIST
66470: LIST
66471: LIST
66472: LIST
66473: LIST
66474: LIST
66475: LIST
66476: LIST
66477: LIST
66478: LIST
66479: LIST
66480: LIST
66481: LIST
66482: LIST
66483: LIST
66484: LIST
66485: LIST
66486: LIST
66487: LIST
66488: LIST
66489: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66490: LD_ADDR_VAR 0 27
66494: PUSH
66495: LD_INT 0
66497: PUSH
66498: LD_INT 0
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PUSH
66505: LD_INT 0
66507: PUSH
66508: LD_INT 1
66510: NEG
66511: PUSH
66512: EMPTY
66513: LIST
66514: LIST
66515: PUSH
66516: LD_INT 1
66518: PUSH
66519: LD_INT 0
66521: PUSH
66522: EMPTY
66523: LIST
66524: LIST
66525: PUSH
66526: LD_INT 1
66528: PUSH
66529: LD_INT 1
66531: PUSH
66532: EMPTY
66533: LIST
66534: LIST
66535: PUSH
66536: LD_INT 0
66538: PUSH
66539: LD_INT 1
66541: PUSH
66542: EMPTY
66543: LIST
66544: LIST
66545: PUSH
66546: LD_INT 1
66548: NEG
66549: PUSH
66550: LD_INT 0
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: PUSH
66557: LD_INT 1
66559: NEG
66560: PUSH
66561: LD_INT 1
66563: NEG
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: PUSH
66569: LD_INT 1
66571: NEG
66572: PUSH
66573: LD_INT 2
66575: NEG
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 0
66583: PUSH
66584: LD_INT 2
66586: NEG
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 1
66594: PUSH
66595: LD_INT 1
66597: NEG
66598: PUSH
66599: EMPTY
66600: LIST
66601: LIST
66602: PUSH
66603: LD_INT 2
66605: PUSH
66606: LD_INT 0
66608: PUSH
66609: EMPTY
66610: LIST
66611: LIST
66612: PUSH
66613: LD_INT 2
66615: PUSH
66616: LD_INT 1
66618: PUSH
66619: EMPTY
66620: LIST
66621: LIST
66622: PUSH
66623: LD_INT 2
66625: PUSH
66626: LD_INT 2
66628: PUSH
66629: EMPTY
66630: LIST
66631: LIST
66632: PUSH
66633: LD_INT 1
66635: PUSH
66636: LD_INT 2
66638: PUSH
66639: EMPTY
66640: LIST
66641: LIST
66642: PUSH
66643: LD_INT 0
66645: PUSH
66646: LD_INT 2
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: LD_INT 1
66655: NEG
66656: PUSH
66657: LD_INT 1
66659: PUSH
66660: EMPTY
66661: LIST
66662: LIST
66663: PUSH
66664: LD_INT 2
66666: NEG
66667: PUSH
66668: LD_INT 0
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: PUSH
66675: LD_INT 2
66677: NEG
66678: PUSH
66679: LD_INT 1
66681: NEG
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: PUSH
66687: LD_INT 2
66689: NEG
66690: PUSH
66691: LD_INT 2
66693: NEG
66694: PUSH
66695: EMPTY
66696: LIST
66697: LIST
66698: PUSH
66699: LD_INT 1
66701: NEG
66702: PUSH
66703: LD_INT 2
66705: PUSH
66706: EMPTY
66707: LIST
66708: LIST
66709: PUSH
66710: LD_INT 2
66712: NEG
66713: PUSH
66714: LD_INT 1
66716: PUSH
66717: EMPTY
66718: LIST
66719: LIST
66720: PUSH
66721: LD_INT 3
66723: NEG
66724: PUSH
66725: LD_INT 1
66727: NEG
66728: PUSH
66729: EMPTY
66730: LIST
66731: LIST
66732: PUSH
66733: LD_INT 3
66735: NEG
66736: PUSH
66737: LD_INT 2
66739: NEG
66740: PUSH
66741: EMPTY
66742: LIST
66743: LIST
66744: PUSH
66745: EMPTY
66746: LIST
66747: LIST
66748: LIST
66749: LIST
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: LIST
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: LIST
66763: LIST
66764: LIST
66765: LIST
66766: LIST
66767: LIST
66768: LIST
66769: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66770: LD_ADDR_VAR 0 28
66774: PUSH
66775: LD_INT 0
66777: PUSH
66778: LD_INT 0
66780: PUSH
66781: EMPTY
66782: LIST
66783: LIST
66784: PUSH
66785: LD_INT 0
66787: PUSH
66788: LD_INT 1
66790: NEG
66791: PUSH
66792: EMPTY
66793: LIST
66794: LIST
66795: PUSH
66796: LD_INT 1
66798: PUSH
66799: LD_INT 0
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: PUSH
66806: LD_INT 1
66808: PUSH
66809: LD_INT 1
66811: PUSH
66812: EMPTY
66813: LIST
66814: LIST
66815: PUSH
66816: LD_INT 0
66818: PUSH
66819: LD_INT 1
66821: PUSH
66822: EMPTY
66823: LIST
66824: LIST
66825: PUSH
66826: LD_INT 1
66828: NEG
66829: PUSH
66830: LD_INT 0
66832: PUSH
66833: EMPTY
66834: LIST
66835: LIST
66836: PUSH
66837: LD_INT 1
66839: NEG
66840: PUSH
66841: LD_INT 1
66843: NEG
66844: PUSH
66845: EMPTY
66846: LIST
66847: LIST
66848: PUSH
66849: LD_INT 1
66851: NEG
66852: PUSH
66853: LD_INT 2
66855: NEG
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: PUSH
66861: LD_INT 0
66863: PUSH
66864: LD_INT 2
66866: NEG
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: LD_INT 1
66874: PUSH
66875: LD_INT 1
66877: NEG
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: PUSH
66883: LD_INT 2
66885: PUSH
66886: LD_INT 0
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 2
66895: PUSH
66896: LD_INT 1
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PUSH
66903: LD_INT 2
66905: PUSH
66906: LD_INT 2
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PUSH
66913: LD_INT 1
66915: PUSH
66916: LD_INT 2
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: PUSH
66923: LD_INT 0
66925: PUSH
66926: LD_INT 2
66928: PUSH
66929: EMPTY
66930: LIST
66931: LIST
66932: PUSH
66933: LD_INT 1
66935: NEG
66936: PUSH
66937: LD_INT 1
66939: PUSH
66940: EMPTY
66941: LIST
66942: LIST
66943: PUSH
66944: LD_INT 2
66946: NEG
66947: PUSH
66948: LD_INT 0
66950: PUSH
66951: EMPTY
66952: LIST
66953: LIST
66954: PUSH
66955: LD_INT 2
66957: NEG
66958: PUSH
66959: LD_INT 1
66961: NEG
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PUSH
66967: LD_INT 2
66969: NEG
66970: PUSH
66971: LD_INT 2
66973: NEG
66974: PUSH
66975: EMPTY
66976: LIST
66977: LIST
66978: PUSH
66979: LD_INT 2
66981: NEG
66982: PUSH
66983: LD_INT 3
66985: NEG
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: PUSH
66991: LD_INT 1
66993: NEG
66994: PUSH
66995: LD_INT 3
66997: NEG
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: PUSH
67003: LD_INT 3
67005: NEG
67006: PUSH
67007: LD_INT 1
67009: NEG
67010: PUSH
67011: EMPTY
67012: LIST
67013: LIST
67014: PUSH
67015: LD_INT 3
67017: NEG
67018: PUSH
67019: LD_INT 2
67021: NEG
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: LIST
67031: LIST
67032: LIST
67033: LIST
67034: LIST
67035: LIST
67036: LIST
67037: LIST
67038: LIST
67039: LIST
67040: LIST
67041: LIST
67042: LIST
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: LIST
67048: LIST
67049: LIST
67050: LIST
67051: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67052: LD_ADDR_VAR 0 29
67056: PUSH
67057: LD_INT 0
67059: PUSH
67060: LD_INT 0
67062: PUSH
67063: EMPTY
67064: LIST
67065: LIST
67066: PUSH
67067: LD_INT 0
67069: PUSH
67070: LD_INT 1
67072: NEG
67073: PUSH
67074: EMPTY
67075: LIST
67076: LIST
67077: PUSH
67078: LD_INT 1
67080: PUSH
67081: LD_INT 0
67083: PUSH
67084: EMPTY
67085: LIST
67086: LIST
67087: PUSH
67088: LD_INT 1
67090: PUSH
67091: LD_INT 1
67093: PUSH
67094: EMPTY
67095: LIST
67096: LIST
67097: PUSH
67098: LD_INT 0
67100: PUSH
67101: LD_INT 1
67103: PUSH
67104: EMPTY
67105: LIST
67106: LIST
67107: PUSH
67108: LD_INT 1
67110: NEG
67111: PUSH
67112: LD_INT 0
67114: PUSH
67115: EMPTY
67116: LIST
67117: LIST
67118: PUSH
67119: LD_INT 1
67121: NEG
67122: PUSH
67123: LD_INT 1
67125: NEG
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: PUSH
67131: LD_INT 1
67133: NEG
67134: PUSH
67135: LD_INT 2
67137: NEG
67138: PUSH
67139: EMPTY
67140: LIST
67141: LIST
67142: PUSH
67143: LD_INT 0
67145: PUSH
67146: LD_INT 2
67148: NEG
67149: PUSH
67150: EMPTY
67151: LIST
67152: LIST
67153: PUSH
67154: LD_INT 1
67156: PUSH
67157: LD_INT 1
67159: NEG
67160: PUSH
67161: EMPTY
67162: LIST
67163: LIST
67164: PUSH
67165: LD_INT 2
67167: PUSH
67168: LD_INT 0
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: PUSH
67175: LD_INT 2
67177: PUSH
67178: LD_INT 1
67180: PUSH
67181: EMPTY
67182: LIST
67183: LIST
67184: PUSH
67185: LD_INT 1
67187: PUSH
67188: LD_INT 2
67190: PUSH
67191: EMPTY
67192: LIST
67193: LIST
67194: PUSH
67195: LD_INT 0
67197: PUSH
67198: LD_INT 2
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 1
67207: NEG
67208: PUSH
67209: LD_INT 1
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PUSH
67216: LD_INT 2
67218: NEG
67219: PUSH
67220: LD_INT 1
67222: NEG
67223: PUSH
67224: EMPTY
67225: LIST
67226: LIST
67227: PUSH
67228: LD_INT 2
67230: NEG
67231: PUSH
67232: LD_INT 2
67234: NEG
67235: PUSH
67236: EMPTY
67237: LIST
67238: LIST
67239: PUSH
67240: LD_INT 2
67242: NEG
67243: PUSH
67244: LD_INT 3
67246: NEG
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PUSH
67252: LD_INT 2
67254: PUSH
67255: LD_INT 1
67257: NEG
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PUSH
67263: LD_INT 3
67265: PUSH
67266: LD_INT 1
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PUSH
67273: LD_INT 1
67275: PUSH
67276: LD_INT 3
67278: PUSH
67279: EMPTY
67280: LIST
67281: LIST
67282: PUSH
67283: LD_INT 1
67285: NEG
67286: PUSH
67287: LD_INT 2
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PUSH
67294: LD_INT 3
67296: NEG
67297: PUSH
67298: LD_INT 2
67300: NEG
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: LIST
67310: LIST
67311: LIST
67312: LIST
67313: LIST
67314: LIST
67315: LIST
67316: LIST
67317: LIST
67318: LIST
67319: LIST
67320: LIST
67321: LIST
67322: LIST
67323: LIST
67324: LIST
67325: LIST
67326: LIST
67327: LIST
67328: LIST
67329: LIST
67330: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67331: LD_ADDR_VAR 0 30
67335: PUSH
67336: LD_INT 0
67338: PUSH
67339: LD_INT 0
67341: PUSH
67342: EMPTY
67343: LIST
67344: LIST
67345: PUSH
67346: LD_INT 0
67348: PUSH
67349: LD_INT 1
67351: NEG
67352: PUSH
67353: EMPTY
67354: LIST
67355: LIST
67356: PUSH
67357: LD_INT 1
67359: PUSH
67360: LD_INT 0
67362: PUSH
67363: EMPTY
67364: LIST
67365: LIST
67366: PUSH
67367: LD_INT 1
67369: PUSH
67370: LD_INT 1
67372: PUSH
67373: EMPTY
67374: LIST
67375: LIST
67376: PUSH
67377: LD_INT 0
67379: PUSH
67380: LD_INT 1
67382: PUSH
67383: EMPTY
67384: LIST
67385: LIST
67386: PUSH
67387: LD_INT 1
67389: NEG
67390: PUSH
67391: LD_INT 0
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: LD_INT 1
67400: NEG
67401: PUSH
67402: LD_INT 1
67404: NEG
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 1
67412: NEG
67413: PUSH
67414: LD_INT 2
67416: NEG
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PUSH
67422: LD_INT 0
67424: PUSH
67425: LD_INT 2
67427: NEG
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: PUSH
67433: LD_INT 1
67435: PUSH
67436: LD_INT 1
67438: NEG
67439: PUSH
67440: EMPTY
67441: LIST
67442: LIST
67443: PUSH
67444: LD_INT 2
67446: PUSH
67447: LD_INT 0
67449: PUSH
67450: EMPTY
67451: LIST
67452: LIST
67453: PUSH
67454: LD_INT 2
67456: PUSH
67457: LD_INT 1
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PUSH
67464: LD_INT 2
67466: PUSH
67467: LD_INT 2
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: LD_INT 1
67476: PUSH
67477: LD_INT 2
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: PUSH
67484: LD_INT 1
67486: NEG
67487: PUSH
67488: LD_INT 1
67490: PUSH
67491: EMPTY
67492: LIST
67493: LIST
67494: PUSH
67495: LD_INT 2
67497: NEG
67498: PUSH
67499: LD_INT 0
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: PUSH
67506: LD_INT 2
67508: NEG
67509: PUSH
67510: LD_INT 1
67512: NEG
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: PUSH
67518: LD_INT 1
67520: NEG
67521: PUSH
67522: LD_INT 3
67524: NEG
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: PUSH
67530: LD_INT 1
67532: PUSH
67533: LD_INT 2
67535: NEG
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: LD_INT 3
67543: PUSH
67544: LD_INT 2
67546: PUSH
67547: EMPTY
67548: LIST
67549: LIST
67550: PUSH
67551: LD_INT 2
67553: PUSH
67554: LD_INT 3
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: PUSH
67561: LD_INT 2
67563: NEG
67564: PUSH
67565: LD_INT 1
67567: PUSH
67568: EMPTY
67569: LIST
67570: LIST
67571: PUSH
67572: LD_INT 3
67574: NEG
67575: PUSH
67576: LD_INT 1
67578: NEG
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: LIST
67588: LIST
67589: LIST
67590: LIST
67591: LIST
67592: LIST
67593: LIST
67594: LIST
67595: LIST
67596: LIST
67597: LIST
67598: LIST
67599: LIST
67600: LIST
67601: LIST
67602: LIST
67603: LIST
67604: LIST
67605: LIST
67606: LIST
67607: LIST
67608: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67609: LD_ADDR_VAR 0 31
67613: PUSH
67614: LD_INT 0
67616: PUSH
67617: LD_INT 0
67619: PUSH
67620: EMPTY
67621: LIST
67622: LIST
67623: PUSH
67624: LD_INT 0
67626: PUSH
67627: LD_INT 1
67629: NEG
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: PUSH
67635: LD_INT 1
67637: PUSH
67638: LD_INT 0
67640: PUSH
67641: EMPTY
67642: LIST
67643: LIST
67644: PUSH
67645: LD_INT 1
67647: PUSH
67648: LD_INT 1
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: PUSH
67655: LD_INT 0
67657: PUSH
67658: LD_INT 1
67660: PUSH
67661: EMPTY
67662: LIST
67663: LIST
67664: PUSH
67665: LD_INT 1
67667: NEG
67668: PUSH
67669: LD_INT 0
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PUSH
67676: LD_INT 1
67678: NEG
67679: PUSH
67680: LD_INT 1
67682: NEG
67683: PUSH
67684: EMPTY
67685: LIST
67686: LIST
67687: PUSH
67688: LD_INT 1
67690: NEG
67691: PUSH
67692: LD_INT 2
67694: NEG
67695: PUSH
67696: EMPTY
67697: LIST
67698: LIST
67699: PUSH
67700: LD_INT 1
67702: PUSH
67703: LD_INT 1
67705: NEG
67706: PUSH
67707: EMPTY
67708: LIST
67709: LIST
67710: PUSH
67711: LD_INT 2
67713: PUSH
67714: LD_INT 0
67716: PUSH
67717: EMPTY
67718: LIST
67719: LIST
67720: PUSH
67721: LD_INT 2
67723: PUSH
67724: LD_INT 1
67726: PUSH
67727: EMPTY
67728: LIST
67729: LIST
67730: PUSH
67731: LD_INT 2
67733: PUSH
67734: LD_INT 2
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: PUSH
67741: LD_INT 1
67743: PUSH
67744: LD_INT 2
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PUSH
67751: LD_INT 0
67753: PUSH
67754: LD_INT 2
67756: PUSH
67757: EMPTY
67758: LIST
67759: LIST
67760: PUSH
67761: LD_INT 1
67763: NEG
67764: PUSH
67765: LD_INT 1
67767: PUSH
67768: EMPTY
67769: LIST
67770: LIST
67771: PUSH
67772: LD_INT 2
67774: NEG
67775: PUSH
67776: LD_INT 1
67778: NEG
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: LD_INT 2
67786: NEG
67787: PUSH
67788: LD_INT 2
67790: NEG
67791: PUSH
67792: EMPTY
67793: LIST
67794: LIST
67795: PUSH
67796: LD_INT 2
67798: NEG
67799: PUSH
67800: LD_INT 3
67802: NEG
67803: PUSH
67804: EMPTY
67805: LIST
67806: LIST
67807: PUSH
67808: LD_INT 2
67810: PUSH
67811: LD_INT 1
67813: NEG
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PUSH
67819: LD_INT 3
67821: PUSH
67822: LD_INT 1
67824: PUSH
67825: EMPTY
67826: LIST
67827: LIST
67828: PUSH
67829: LD_INT 1
67831: PUSH
67832: LD_INT 3
67834: PUSH
67835: EMPTY
67836: LIST
67837: LIST
67838: PUSH
67839: LD_INT 1
67841: NEG
67842: PUSH
67843: LD_INT 2
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: PUSH
67850: LD_INT 3
67852: NEG
67853: PUSH
67854: LD_INT 2
67856: NEG
67857: PUSH
67858: EMPTY
67859: LIST
67860: LIST
67861: PUSH
67862: EMPTY
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: LIST
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: LIST
67880: LIST
67881: LIST
67882: LIST
67883: LIST
67884: LIST
67885: LIST
67886: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67887: LD_ADDR_VAR 0 32
67891: PUSH
67892: LD_INT 0
67894: PUSH
67895: LD_INT 0
67897: PUSH
67898: EMPTY
67899: LIST
67900: LIST
67901: PUSH
67902: LD_INT 0
67904: PUSH
67905: LD_INT 1
67907: NEG
67908: PUSH
67909: EMPTY
67910: LIST
67911: LIST
67912: PUSH
67913: LD_INT 1
67915: PUSH
67916: LD_INT 0
67918: PUSH
67919: EMPTY
67920: LIST
67921: LIST
67922: PUSH
67923: LD_INT 1
67925: PUSH
67926: LD_INT 1
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: PUSH
67933: LD_INT 0
67935: PUSH
67936: LD_INT 1
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: PUSH
67943: LD_INT 1
67945: NEG
67946: PUSH
67947: LD_INT 0
67949: PUSH
67950: EMPTY
67951: LIST
67952: LIST
67953: PUSH
67954: LD_INT 1
67956: NEG
67957: PUSH
67958: LD_INT 1
67960: NEG
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 1
67968: NEG
67969: PUSH
67970: LD_INT 2
67972: NEG
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: PUSH
67978: LD_INT 0
67980: PUSH
67981: LD_INT 2
67983: NEG
67984: PUSH
67985: EMPTY
67986: LIST
67987: LIST
67988: PUSH
67989: LD_INT 1
67991: PUSH
67992: LD_INT 1
67994: NEG
67995: PUSH
67996: EMPTY
67997: LIST
67998: LIST
67999: PUSH
68000: LD_INT 2
68002: PUSH
68003: LD_INT 1
68005: PUSH
68006: EMPTY
68007: LIST
68008: LIST
68009: PUSH
68010: LD_INT 2
68012: PUSH
68013: LD_INT 2
68015: PUSH
68016: EMPTY
68017: LIST
68018: LIST
68019: PUSH
68020: LD_INT 1
68022: PUSH
68023: LD_INT 2
68025: PUSH
68026: EMPTY
68027: LIST
68028: LIST
68029: PUSH
68030: LD_INT 0
68032: PUSH
68033: LD_INT 2
68035: PUSH
68036: EMPTY
68037: LIST
68038: LIST
68039: PUSH
68040: LD_INT 1
68042: NEG
68043: PUSH
68044: LD_INT 1
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: PUSH
68051: LD_INT 2
68053: NEG
68054: PUSH
68055: LD_INT 0
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: PUSH
68062: LD_INT 2
68064: NEG
68065: PUSH
68066: LD_INT 1
68068: NEG
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PUSH
68074: LD_INT 1
68076: NEG
68077: PUSH
68078: LD_INT 3
68080: NEG
68081: PUSH
68082: EMPTY
68083: LIST
68084: LIST
68085: PUSH
68086: LD_INT 1
68088: PUSH
68089: LD_INT 2
68091: NEG
68092: PUSH
68093: EMPTY
68094: LIST
68095: LIST
68096: PUSH
68097: LD_INT 3
68099: PUSH
68100: LD_INT 2
68102: PUSH
68103: EMPTY
68104: LIST
68105: LIST
68106: PUSH
68107: LD_INT 2
68109: PUSH
68110: LD_INT 3
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: PUSH
68117: LD_INT 2
68119: NEG
68120: PUSH
68121: LD_INT 1
68123: PUSH
68124: EMPTY
68125: LIST
68126: LIST
68127: PUSH
68128: LD_INT 3
68130: NEG
68131: PUSH
68132: LD_INT 1
68134: NEG
68135: PUSH
68136: EMPTY
68137: LIST
68138: LIST
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: LIST
68144: LIST
68145: LIST
68146: LIST
68147: LIST
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: LIST
68162: LIST
68163: LIST
68164: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68165: LD_ADDR_VAR 0 33
68169: PUSH
68170: LD_INT 0
68172: PUSH
68173: LD_INT 0
68175: PUSH
68176: EMPTY
68177: LIST
68178: LIST
68179: PUSH
68180: LD_INT 0
68182: PUSH
68183: LD_INT 1
68185: NEG
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: PUSH
68191: LD_INT 1
68193: PUSH
68194: LD_INT 0
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: PUSH
68201: LD_INT 1
68203: PUSH
68204: LD_INT 1
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 0
68213: PUSH
68214: LD_INT 1
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: PUSH
68221: LD_INT 1
68223: NEG
68224: PUSH
68225: LD_INT 0
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PUSH
68232: LD_INT 1
68234: NEG
68235: PUSH
68236: LD_INT 1
68238: NEG
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: LD_INT 1
68246: NEG
68247: PUSH
68248: LD_INT 2
68250: NEG
68251: PUSH
68252: EMPTY
68253: LIST
68254: LIST
68255: PUSH
68256: LD_INT 1
68258: PUSH
68259: LD_INT 1
68261: NEG
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: PUSH
68267: LD_INT 2
68269: PUSH
68270: LD_INT 0
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: PUSH
68277: LD_INT 2
68279: PUSH
68280: LD_INT 1
68282: PUSH
68283: EMPTY
68284: LIST
68285: LIST
68286: PUSH
68287: LD_INT 1
68289: PUSH
68290: LD_INT 2
68292: PUSH
68293: EMPTY
68294: LIST
68295: LIST
68296: PUSH
68297: LD_INT 0
68299: PUSH
68300: LD_INT 2
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: PUSH
68307: LD_INT 1
68309: NEG
68310: PUSH
68311: LD_INT 1
68313: PUSH
68314: EMPTY
68315: LIST
68316: LIST
68317: PUSH
68318: LD_INT 2
68320: NEG
68321: PUSH
68322: LD_INT 0
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: PUSH
68329: LD_INT 2
68331: NEG
68332: PUSH
68333: LD_INT 1
68335: NEG
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: LD_INT 2
68343: NEG
68344: PUSH
68345: LD_INT 2
68347: NEG
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 2
68355: NEG
68356: PUSH
68357: LD_INT 3
68359: NEG
68360: PUSH
68361: EMPTY
68362: LIST
68363: LIST
68364: PUSH
68365: LD_INT 2
68367: PUSH
68368: LD_INT 1
68370: NEG
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: PUSH
68376: LD_INT 3
68378: PUSH
68379: LD_INT 1
68381: PUSH
68382: EMPTY
68383: LIST
68384: LIST
68385: PUSH
68386: LD_INT 1
68388: PUSH
68389: LD_INT 3
68391: PUSH
68392: EMPTY
68393: LIST
68394: LIST
68395: PUSH
68396: LD_INT 1
68398: NEG
68399: PUSH
68400: LD_INT 2
68402: PUSH
68403: EMPTY
68404: LIST
68405: LIST
68406: PUSH
68407: LD_INT 3
68409: NEG
68410: PUSH
68411: LD_INT 2
68413: NEG
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: LIST
68423: LIST
68424: LIST
68425: LIST
68426: LIST
68427: LIST
68428: LIST
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: LIST
68434: LIST
68435: LIST
68436: LIST
68437: LIST
68438: LIST
68439: LIST
68440: LIST
68441: LIST
68442: LIST
68443: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68444: LD_ADDR_VAR 0 34
68448: PUSH
68449: LD_INT 0
68451: PUSH
68452: LD_INT 0
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PUSH
68459: LD_INT 0
68461: PUSH
68462: LD_INT 1
68464: NEG
68465: PUSH
68466: EMPTY
68467: LIST
68468: LIST
68469: PUSH
68470: LD_INT 1
68472: PUSH
68473: LD_INT 0
68475: PUSH
68476: EMPTY
68477: LIST
68478: LIST
68479: PUSH
68480: LD_INT 1
68482: PUSH
68483: LD_INT 1
68485: PUSH
68486: EMPTY
68487: LIST
68488: LIST
68489: PUSH
68490: LD_INT 0
68492: PUSH
68493: LD_INT 1
68495: PUSH
68496: EMPTY
68497: LIST
68498: LIST
68499: PUSH
68500: LD_INT 1
68502: NEG
68503: PUSH
68504: LD_INT 0
68506: PUSH
68507: EMPTY
68508: LIST
68509: LIST
68510: PUSH
68511: LD_INT 1
68513: NEG
68514: PUSH
68515: LD_INT 1
68517: NEG
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: PUSH
68523: LD_INT 1
68525: NEG
68526: PUSH
68527: LD_INT 2
68529: NEG
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: LD_INT 0
68537: PUSH
68538: LD_INT 2
68540: NEG
68541: PUSH
68542: EMPTY
68543: LIST
68544: LIST
68545: PUSH
68546: LD_INT 1
68548: PUSH
68549: LD_INT 1
68551: NEG
68552: PUSH
68553: EMPTY
68554: LIST
68555: LIST
68556: PUSH
68557: LD_INT 2
68559: PUSH
68560: LD_INT 1
68562: PUSH
68563: EMPTY
68564: LIST
68565: LIST
68566: PUSH
68567: LD_INT 2
68569: PUSH
68570: LD_INT 2
68572: PUSH
68573: EMPTY
68574: LIST
68575: LIST
68576: PUSH
68577: LD_INT 1
68579: PUSH
68580: LD_INT 2
68582: PUSH
68583: EMPTY
68584: LIST
68585: LIST
68586: PUSH
68587: LD_INT 1
68589: NEG
68590: PUSH
68591: LD_INT 1
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: PUSH
68598: LD_INT 2
68600: NEG
68601: PUSH
68602: LD_INT 0
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PUSH
68609: LD_INT 2
68611: NEG
68612: PUSH
68613: LD_INT 1
68615: NEG
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: LD_INT 2
68623: NEG
68624: PUSH
68625: LD_INT 2
68627: NEG
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: LD_INT 1
68635: NEG
68636: PUSH
68637: LD_INT 3
68639: NEG
68640: PUSH
68641: EMPTY
68642: LIST
68643: LIST
68644: PUSH
68645: LD_INT 1
68647: PUSH
68648: LD_INT 2
68650: NEG
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: PUSH
68656: LD_INT 3
68658: PUSH
68659: LD_INT 2
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 2
68668: PUSH
68669: LD_INT 3
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: PUSH
68676: LD_INT 2
68678: NEG
68679: PUSH
68680: LD_INT 1
68682: PUSH
68683: EMPTY
68684: LIST
68685: LIST
68686: PUSH
68687: LD_INT 3
68689: NEG
68690: PUSH
68691: LD_INT 1
68693: NEG
68694: PUSH
68695: EMPTY
68696: LIST
68697: LIST
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: LIST
68703: LIST
68704: LIST
68705: LIST
68706: LIST
68707: LIST
68708: LIST
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: LIST
68719: LIST
68720: LIST
68721: LIST
68722: LIST
68723: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68724: LD_ADDR_VAR 0 35
68728: PUSH
68729: LD_INT 0
68731: PUSH
68732: LD_INT 0
68734: PUSH
68735: EMPTY
68736: LIST
68737: LIST
68738: PUSH
68739: LD_INT 0
68741: PUSH
68742: LD_INT 1
68744: NEG
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 1
68752: PUSH
68753: LD_INT 0
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: PUSH
68760: LD_INT 1
68762: PUSH
68763: LD_INT 1
68765: PUSH
68766: EMPTY
68767: LIST
68768: LIST
68769: PUSH
68770: LD_INT 0
68772: PUSH
68773: LD_INT 1
68775: PUSH
68776: EMPTY
68777: LIST
68778: LIST
68779: PUSH
68780: LD_INT 1
68782: NEG
68783: PUSH
68784: LD_INT 0
68786: PUSH
68787: EMPTY
68788: LIST
68789: LIST
68790: PUSH
68791: LD_INT 1
68793: NEG
68794: PUSH
68795: LD_INT 1
68797: NEG
68798: PUSH
68799: EMPTY
68800: LIST
68801: LIST
68802: PUSH
68803: LD_INT 2
68805: PUSH
68806: LD_INT 1
68808: PUSH
68809: EMPTY
68810: LIST
68811: LIST
68812: PUSH
68813: LD_INT 2
68815: NEG
68816: PUSH
68817: LD_INT 1
68819: NEG
68820: PUSH
68821: EMPTY
68822: LIST
68823: LIST
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: LIST
68829: LIST
68830: LIST
68831: LIST
68832: LIST
68833: LIST
68834: LIST
68835: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68836: LD_ADDR_VAR 0 36
68840: PUSH
68841: LD_INT 0
68843: PUSH
68844: LD_INT 0
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: PUSH
68851: LD_INT 0
68853: PUSH
68854: LD_INT 1
68856: NEG
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: LD_INT 1
68864: PUSH
68865: LD_INT 0
68867: PUSH
68868: EMPTY
68869: LIST
68870: LIST
68871: PUSH
68872: LD_INT 1
68874: PUSH
68875: LD_INT 1
68877: PUSH
68878: EMPTY
68879: LIST
68880: LIST
68881: PUSH
68882: LD_INT 0
68884: PUSH
68885: LD_INT 1
68887: PUSH
68888: EMPTY
68889: LIST
68890: LIST
68891: PUSH
68892: LD_INT 1
68894: NEG
68895: PUSH
68896: LD_INT 0
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: PUSH
68903: LD_INT 1
68905: NEG
68906: PUSH
68907: LD_INT 1
68909: NEG
68910: PUSH
68911: EMPTY
68912: LIST
68913: LIST
68914: PUSH
68915: LD_INT 1
68917: NEG
68918: PUSH
68919: LD_INT 2
68921: NEG
68922: PUSH
68923: EMPTY
68924: LIST
68925: LIST
68926: PUSH
68927: LD_INT 1
68929: PUSH
68930: LD_INT 2
68932: PUSH
68933: EMPTY
68934: LIST
68935: LIST
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68948: LD_ADDR_VAR 0 37
68952: PUSH
68953: LD_INT 0
68955: PUSH
68956: LD_INT 0
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PUSH
68963: LD_INT 0
68965: PUSH
68966: LD_INT 1
68968: NEG
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PUSH
68974: LD_INT 1
68976: PUSH
68977: LD_INT 0
68979: PUSH
68980: EMPTY
68981: LIST
68982: LIST
68983: PUSH
68984: LD_INT 1
68986: PUSH
68987: LD_INT 1
68989: PUSH
68990: EMPTY
68991: LIST
68992: LIST
68993: PUSH
68994: LD_INT 0
68996: PUSH
68997: LD_INT 1
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: PUSH
69004: LD_INT 1
69006: NEG
69007: PUSH
69008: LD_INT 0
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: LD_INT 1
69017: NEG
69018: PUSH
69019: LD_INT 1
69021: NEG
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: PUSH
69027: LD_INT 1
69029: PUSH
69030: LD_INT 1
69032: NEG
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 1
69040: NEG
69041: PUSH
69042: LD_INT 1
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: EMPTY
69050: LIST
69051: LIST
69052: LIST
69053: LIST
69054: LIST
69055: LIST
69056: LIST
69057: LIST
69058: LIST
69059: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69060: LD_ADDR_VAR 0 38
69064: PUSH
69065: LD_INT 0
69067: PUSH
69068: LD_INT 0
69070: PUSH
69071: EMPTY
69072: LIST
69073: LIST
69074: PUSH
69075: LD_INT 0
69077: PUSH
69078: LD_INT 1
69080: NEG
69081: PUSH
69082: EMPTY
69083: LIST
69084: LIST
69085: PUSH
69086: LD_INT 1
69088: PUSH
69089: LD_INT 0
69091: PUSH
69092: EMPTY
69093: LIST
69094: LIST
69095: PUSH
69096: LD_INT 1
69098: PUSH
69099: LD_INT 1
69101: PUSH
69102: EMPTY
69103: LIST
69104: LIST
69105: PUSH
69106: LD_INT 0
69108: PUSH
69109: LD_INT 1
69111: PUSH
69112: EMPTY
69113: LIST
69114: LIST
69115: PUSH
69116: LD_INT 1
69118: NEG
69119: PUSH
69120: LD_INT 0
69122: PUSH
69123: EMPTY
69124: LIST
69125: LIST
69126: PUSH
69127: LD_INT 1
69129: NEG
69130: PUSH
69131: LD_INT 1
69133: NEG
69134: PUSH
69135: EMPTY
69136: LIST
69137: LIST
69138: PUSH
69139: LD_INT 2
69141: PUSH
69142: LD_INT 1
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: LD_INT 2
69151: NEG
69152: PUSH
69153: LD_INT 1
69155: NEG
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69172: LD_ADDR_VAR 0 39
69176: PUSH
69177: LD_INT 0
69179: PUSH
69180: LD_INT 0
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PUSH
69187: LD_INT 0
69189: PUSH
69190: LD_INT 1
69192: NEG
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: LD_INT 1
69200: PUSH
69201: LD_INT 0
69203: PUSH
69204: EMPTY
69205: LIST
69206: LIST
69207: PUSH
69208: LD_INT 1
69210: PUSH
69211: LD_INT 1
69213: PUSH
69214: EMPTY
69215: LIST
69216: LIST
69217: PUSH
69218: LD_INT 0
69220: PUSH
69221: LD_INT 1
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: PUSH
69228: LD_INT 1
69230: NEG
69231: PUSH
69232: LD_INT 0
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: PUSH
69239: LD_INT 1
69241: NEG
69242: PUSH
69243: LD_INT 1
69245: NEG
69246: PUSH
69247: EMPTY
69248: LIST
69249: LIST
69250: PUSH
69251: LD_INT 1
69253: NEG
69254: PUSH
69255: LD_INT 2
69257: NEG
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: PUSH
69263: LD_INT 1
69265: PUSH
69266: LD_INT 2
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: PUSH
69273: EMPTY
69274: LIST
69275: LIST
69276: LIST
69277: LIST
69278: LIST
69279: LIST
69280: LIST
69281: LIST
69282: LIST
69283: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69284: LD_ADDR_VAR 0 40
69288: PUSH
69289: LD_INT 0
69291: PUSH
69292: LD_INT 0
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: LD_INT 0
69301: PUSH
69302: LD_INT 1
69304: NEG
69305: PUSH
69306: EMPTY
69307: LIST
69308: LIST
69309: PUSH
69310: LD_INT 1
69312: PUSH
69313: LD_INT 0
69315: PUSH
69316: EMPTY
69317: LIST
69318: LIST
69319: PUSH
69320: LD_INT 1
69322: PUSH
69323: LD_INT 1
69325: PUSH
69326: EMPTY
69327: LIST
69328: LIST
69329: PUSH
69330: LD_INT 0
69332: PUSH
69333: LD_INT 1
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: LD_INT 1
69342: NEG
69343: PUSH
69344: LD_INT 0
69346: PUSH
69347: EMPTY
69348: LIST
69349: LIST
69350: PUSH
69351: LD_INT 1
69353: NEG
69354: PUSH
69355: LD_INT 1
69357: NEG
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: PUSH
69363: LD_INT 1
69365: PUSH
69366: LD_INT 1
69368: NEG
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PUSH
69374: LD_INT 1
69376: NEG
69377: PUSH
69378: LD_INT 1
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PUSH
69385: EMPTY
69386: LIST
69387: LIST
69388: LIST
69389: LIST
69390: LIST
69391: LIST
69392: LIST
69393: LIST
69394: LIST
69395: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69396: LD_ADDR_VAR 0 41
69400: PUSH
69401: LD_INT 0
69403: PUSH
69404: LD_INT 0
69406: PUSH
69407: EMPTY
69408: LIST
69409: LIST
69410: PUSH
69411: LD_INT 0
69413: PUSH
69414: LD_INT 1
69416: NEG
69417: PUSH
69418: EMPTY
69419: LIST
69420: LIST
69421: PUSH
69422: LD_INT 1
69424: PUSH
69425: LD_INT 0
69427: PUSH
69428: EMPTY
69429: LIST
69430: LIST
69431: PUSH
69432: LD_INT 1
69434: PUSH
69435: LD_INT 1
69437: PUSH
69438: EMPTY
69439: LIST
69440: LIST
69441: PUSH
69442: LD_INT 0
69444: PUSH
69445: LD_INT 1
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 1
69454: NEG
69455: PUSH
69456: LD_INT 0
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: PUSH
69463: LD_INT 1
69465: NEG
69466: PUSH
69467: LD_INT 1
69469: NEG
69470: PUSH
69471: EMPTY
69472: LIST
69473: LIST
69474: PUSH
69475: LD_INT 1
69477: NEG
69478: PUSH
69479: LD_INT 2
69481: NEG
69482: PUSH
69483: EMPTY
69484: LIST
69485: LIST
69486: PUSH
69487: LD_INT 1
69489: PUSH
69490: LD_INT 1
69492: NEG
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: LD_INT 2
69500: PUSH
69501: LD_INT 0
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 2
69510: PUSH
69511: LD_INT 1
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: PUSH
69518: LD_INT 2
69520: PUSH
69521: LD_INT 2
69523: PUSH
69524: EMPTY
69525: LIST
69526: LIST
69527: PUSH
69528: LD_INT 1
69530: PUSH
69531: LD_INT 2
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: PUSH
69538: LD_INT 1
69540: NEG
69541: PUSH
69542: LD_INT 1
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: PUSH
69549: LD_INT 2
69551: NEG
69552: PUSH
69553: LD_INT 0
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: LD_INT 2
69562: NEG
69563: PUSH
69564: LD_INT 1
69566: NEG
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: PUSH
69572: LD_INT 2
69574: NEG
69575: PUSH
69576: LD_INT 2
69578: NEG
69579: PUSH
69580: EMPTY
69581: LIST
69582: LIST
69583: PUSH
69584: LD_INT 2
69586: NEG
69587: PUSH
69588: LD_INT 3
69590: NEG
69591: PUSH
69592: EMPTY
69593: LIST
69594: LIST
69595: PUSH
69596: LD_INT 2
69598: PUSH
69599: LD_INT 1
69601: NEG
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: PUSH
69607: LD_INT 3
69609: PUSH
69610: LD_INT 0
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: PUSH
69617: LD_INT 3
69619: PUSH
69620: LD_INT 1
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: LD_INT 3
69629: PUSH
69630: LD_INT 2
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: LD_INT 3
69639: PUSH
69640: LD_INT 3
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: PUSH
69647: LD_INT 2
69649: PUSH
69650: LD_INT 3
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 2
69659: NEG
69660: PUSH
69661: LD_INT 1
69663: PUSH
69664: EMPTY
69665: LIST
69666: LIST
69667: PUSH
69668: LD_INT 3
69670: NEG
69671: PUSH
69672: LD_INT 0
69674: PUSH
69675: EMPTY
69676: LIST
69677: LIST
69678: PUSH
69679: LD_INT 3
69681: NEG
69682: PUSH
69683: LD_INT 1
69685: NEG
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: LD_INT 3
69693: NEG
69694: PUSH
69695: LD_INT 2
69697: NEG
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PUSH
69703: LD_INT 3
69705: NEG
69706: PUSH
69707: LD_INT 3
69709: NEG
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: LIST
69723: LIST
69724: LIST
69725: LIST
69726: LIST
69727: LIST
69728: LIST
69729: LIST
69730: LIST
69731: LIST
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69746: LD_ADDR_VAR 0 42
69750: PUSH
69751: LD_INT 0
69753: PUSH
69754: LD_INT 0
69756: PUSH
69757: EMPTY
69758: LIST
69759: LIST
69760: PUSH
69761: LD_INT 0
69763: PUSH
69764: LD_INT 1
69766: NEG
69767: PUSH
69768: EMPTY
69769: LIST
69770: LIST
69771: PUSH
69772: LD_INT 1
69774: PUSH
69775: LD_INT 0
69777: PUSH
69778: EMPTY
69779: LIST
69780: LIST
69781: PUSH
69782: LD_INT 1
69784: PUSH
69785: LD_INT 1
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: LD_INT 0
69794: PUSH
69795: LD_INT 1
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: PUSH
69802: LD_INT 1
69804: NEG
69805: PUSH
69806: LD_INT 0
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: PUSH
69813: LD_INT 1
69815: NEG
69816: PUSH
69817: LD_INT 1
69819: NEG
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: PUSH
69825: LD_INT 1
69827: NEG
69828: PUSH
69829: LD_INT 2
69831: NEG
69832: PUSH
69833: EMPTY
69834: LIST
69835: LIST
69836: PUSH
69837: LD_INT 0
69839: PUSH
69840: LD_INT 2
69842: NEG
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 1
69850: PUSH
69851: LD_INT 1
69853: NEG
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 2
69861: PUSH
69862: LD_INT 1
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 2
69871: PUSH
69872: LD_INT 2
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 1
69881: PUSH
69882: LD_INT 2
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 0
69891: PUSH
69892: LD_INT 2
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PUSH
69899: LD_INT 1
69901: NEG
69902: PUSH
69903: LD_INT 1
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 2
69912: NEG
69913: PUSH
69914: LD_INT 1
69916: NEG
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PUSH
69922: LD_INT 2
69924: NEG
69925: PUSH
69926: LD_INT 2
69928: NEG
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: LD_INT 2
69936: NEG
69937: PUSH
69938: LD_INT 3
69940: NEG
69941: PUSH
69942: EMPTY
69943: LIST
69944: LIST
69945: PUSH
69946: LD_INT 1
69948: NEG
69949: PUSH
69950: LD_INT 3
69952: NEG
69953: PUSH
69954: EMPTY
69955: LIST
69956: LIST
69957: PUSH
69958: LD_INT 0
69960: PUSH
69961: LD_INT 3
69963: NEG
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: PUSH
69969: LD_INT 1
69971: PUSH
69972: LD_INT 2
69974: NEG
69975: PUSH
69976: EMPTY
69977: LIST
69978: LIST
69979: PUSH
69980: LD_INT 3
69982: PUSH
69983: LD_INT 2
69985: PUSH
69986: EMPTY
69987: LIST
69988: LIST
69989: PUSH
69990: LD_INT 3
69992: PUSH
69993: LD_INT 3
69995: PUSH
69996: EMPTY
69997: LIST
69998: LIST
69999: PUSH
70000: LD_INT 2
70002: PUSH
70003: LD_INT 3
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PUSH
70010: LD_INT 1
70012: PUSH
70013: LD_INT 3
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: PUSH
70020: LD_INT 0
70022: PUSH
70023: LD_INT 3
70025: PUSH
70026: EMPTY
70027: LIST
70028: LIST
70029: PUSH
70030: LD_INT 1
70032: NEG
70033: PUSH
70034: LD_INT 2
70036: PUSH
70037: EMPTY
70038: LIST
70039: LIST
70040: PUSH
70041: LD_INT 3
70043: NEG
70044: PUSH
70045: LD_INT 2
70047: NEG
70048: PUSH
70049: EMPTY
70050: LIST
70051: LIST
70052: PUSH
70053: LD_INT 3
70055: NEG
70056: PUSH
70057: LD_INT 3
70059: NEG
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: PUSH
70065: EMPTY
70066: LIST
70067: LIST
70068: LIST
70069: LIST
70070: LIST
70071: LIST
70072: LIST
70073: LIST
70074: LIST
70075: LIST
70076: LIST
70077: LIST
70078: LIST
70079: LIST
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: LIST
70087: LIST
70088: LIST
70089: LIST
70090: LIST
70091: LIST
70092: LIST
70093: LIST
70094: LIST
70095: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70096: LD_ADDR_VAR 0 43
70100: PUSH
70101: LD_INT 0
70103: PUSH
70104: LD_INT 0
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 0
70113: PUSH
70114: LD_INT 1
70116: NEG
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: PUSH
70122: LD_INT 1
70124: PUSH
70125: LD_INT 0
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 1
70134: PUSH
70135: LD_INT 1
70137: PUSH
70138: EMPTY
70139: LIST
70140: LIST
70141: PUSH
70142: LD_INT 0
70144: PUSH
70145: LD_INT 1
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PUSH
70152: LD_INT 1
70154: NEG
70155: PUSH
70156: LD_INT 0
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: PUSH
70163: LD_INT 1
70165: NEG
70166: PUSH
70167: LD_INT 1
70169: NEG
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: PUSH
70175: LD_INT 1
70177: NEG
70178: PUSH
70179: LD_INT 2
70181: NEG
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: LD_INT 0
70189: PUSH
70190: LD_INT 2
70192: NEG
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: LD_INT 1
70200: PUSH
70201: LD_INT 1
70203: NEG
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: PUSH
70209: LD_INT 2
70211: PUSH
70212: LD_INT 0
70214: PUSH
70215: EMPTY
70216: LIST
70217: LIST
70218: PUSH
70219: LD_INT 2
70221: PUSH
70222: LD_INT 1
70224: PUSH
70225: EMPTY
70226: LIST
70227: LIST
70228: PUSH
70229: LD_INT 1
70231: PUSH
70232: LD_INT 2
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PUSH
70239: LD_INT 0
70241: PUSH
70242: LD_INT 2
70244: PUSH
70245: EMPTY
70246: LIST
70247: LIST
70248: PUSH
70249: LD_INT 1
70251: NEG
70252: PUSH
70253: LD_INT 1
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PUSH
70260: LD_INT 2
70262: NEG
70263: PUSH
70264: LD_INT 0
70266: PUSH
70267: EMPTY
70268: LIST
70269: LIST
70270: PUSH
70271: LD_INT 2
70273: NEG
70274: PUSH
70275: LD_INT 1
70277: NEG
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: PUSH
70283: LD_INT 1
70285: NEG
70286: PUSH
70287: LD_INT 3
70289: NEG
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 0
70297: PUSH
70298: LD_INT 3
70300: NEG
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: PUSH
70306: LD_INT 1
70308: PUSH
70309: LD_INT 2
70311: NEG
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: PUSH
70317: LD_INT 2
70319: PUSH
70320: LD_INT 1
70322: NEG
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 3
70330: PUSH
70331: LD_INT 0
70333: PUSH
70334: EMPTY
70335: LIST
70336: LIST
70337: PUSH
70338: LD_INT 3
70340: PUSH
70341: LD_INT 1
70343: PUSH
70344: EMPTY
70345: LIST
70346: LIST
70347: PUSH
70348: LD_INT 1
70350: PUSH
70351: LD_INT 3
70353: PUSH
70354: EMPTY
70355: LIST
70356: LIST
70357: PUSH
70358: LD_INT 0
70360: PUSH
70361: LD_INT 3
70363: PUSH
70364: EMPTY
70365: LIST
70366: LIST
70367: PUSH
70368: LD_INT 1
70370: NEG
70371: PUSH
70372: LD_INT 2
70374: PUSH
70375: EMPTY
70376: LIST
70377: LIST
70378: PUSH
70379: LD_INT 2
70381: NEG
70382: PUSH
70383: LD_INT 1
70385: PUSH
70386: EMPTY
70387: LIST
70388: LIST
70389: PUSH
70390: LD_INT 3
70392: NEG
70393: PUSH
70394: LD_INT 0
70396: PUSH
70397: EMPTY
70398: LIST
70399: LIST
70400: PUSH
70401: LD_INT 3
70403: NEG
70404: PUSH
70405: LD_INT 1
70407: NEG
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: LIST
70417: LIST
70418: LIST
70419: LIST
70420: LIST
70421: LIST
70422: LIST
70423: LIST
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: LIST
70435: LIST
70436: LIST
70437: LIST
70438: LIST
70439: LIST
70440: LIST
70441: LIST
70442: LIST
70443: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70444: LD_ADDR_VAR 0 44
70448: PUSH
70449: LD_INT 0
70451: PUSH
70452: LD_INT 0
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 0
70461: PUSH
70462: LD_INT 1
70464: NEG
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: PUSH
70470: LD_INT 1
70472: PUSH
70473: LD_INT 0
70475: PUSH
70476: EMPTY
70477: LIST
70478: LIST
70479: PUSH
70480: LD_INT 1
70482: PUSH
70483: LD_INT 1
70485: PUSH
70486: EMPTY
70487: LIST
70488: LIST
70489: PUSH
70490: LD_INT 0
70492: PUSH
70493: LD_INT 1
70495: PUSH
70496: EMPTY
70497: LIST
70498: LIST
70499: PUSH
70500: LD_INT 1
70502: NEG
70503: PUSH
70504: LD_INT 0
70506: PUSH
70507: EMPTY
70508: LIST
70509: LIST
70510: PUSH
70511: LD_INT 1
70513: NEG
70514: PUSH
70515: LD_INT 1
70517: NEG
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: LD_INT 1
70525: NEG
70526: PUSH
70527: LD_INT 2
70529: NEG
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 1
70537: PUSH
70538: LD_INT 1
70540: NEG
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: PUSH
70546: LD_INT 2
70548: PUSH
70549: LD_INT 0
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 2
70558: PUSH
70559: LD_INT 1
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: PUSH
70566: LD_INT 2
70568: PUSH
70569: LD_INT 2
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 1
70578: PUSH
70579: LD_INT 2
70581: PUSH
70582: EMPTY
70583: LIST
70584: LIST
70585: PUSH
70586: LD_INT 1
70588: NEG
70589: PUSH
70590: LD_INT 1
70592: PUSH
70593: EMPTY
70594: LIST
70595: LIST
70596: PUSH
70597: LD_INT 2
70599: NEG
70600: PUSH
70601: LD_INT 0
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 2
70610: NEG
70611: PUSH
70612: LD_INT 1
70614: NEG
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: PUSH
70620: LD_INT 2
70622: NEG
70623: PUSH
70624: LD_INT 2
70626: NEG
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: LD_INT 2
70634: NEG
70635: PUSH
70636: LD_INT 3
70638: NEG
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: PUSH
70644: LD_INT 2
70646: PUSH
70647: LD_INT 1
70649: NEG
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: LD_INT 3
70657: PUSH
70658: LD_INT 0
70660: PUSH
70661: EMPTY
70662: LIST
70663: LIST
70664: PUSH
70665: LD_INT 3
70667: PUSH
70668: LD_INT 1
70670: PUSH
70671: EMPTY
70672: LIST
70673: LIST
70674: PUSH
70675: LD_INT 3
70677: PUSH
70678: LD_INT 2
70680: PUSH
70681: EMPTY
70682: LIST
70683: LIST
70684: PUSH
70685: LD_INT 3
70687: PUSH
70688: LD_INT 3
70690: PUSH
70691: EMPTY
70692: LIST
70693: LIST
70694: PUSH
70695: LD_INT 2
70697: PUSH
70698: LD_INT 3
70700: PUSH
70701: EMPTY
70702: LIST
70703: LIST
70704: PUSH
70705: LD_INT 2
70707: NEG
70708: PUSH
70709: LD_INT 1
70711: PUSH
70712: EMPTY
70713: LIST
70714: LIST
70715: PUSH
70716: LD_INT 3
70718: NEG
70719: PUSH
70720: LD_INT 0
70722: PUSH
70723: EMPTY
70724: LIST
70725: LIST
70726: PUSH
70727: LD_INT 3
70729: NEG
70730: PUSH
70731: LD_INT 1
70733: NEG
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: LD_INT 3
70741: NEG
70742: PUSH
70743: LD_INT 2
70745: NEG
70746: PUSH
70747: EMPTY
70748: LIST
70749: LIST
70750: PUSH
70751: LD_INT 3
70753: NEG
70754: PUSH
70755: LD_INT 3
70757: NEG
70758: PUSH
70759: EMPTY
70760: LIST
70761: LIST
70762: PUSH
70763: EMPTY
70764: LIST
70765: LIST
70766: LIST
70767: LIST
70768: LIST
70769: LIST
70770: LIST
70771: LIST
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70794: LD_ADDR_VAR 0 45
70798: PUSH
70799: LD_INT 0
70801: PUSH
70802: LD_INT 0
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: PUSH
70809: LD_INT 0
70811: PUSH
70812: LD_INT 1
70814: NEG
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 1
70822: PUSH
70823: LD_INT 0
70825: PUSH
70826: EMPTY
70827: LIST
70828: LIST
70829: PUSH
70830: LD_INT 1
70832: PUSH
70833: LD_INT 1
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: PUSH
70840: LD_INT 0
70842: PUSH
70843: LD_INT 1
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: PUSH
70850: LD_INT 1
70852: NEG
70853: PUSH
70854: LD_INT 0
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: PUSH
70861: LD_INT 1
70863: NEG
70864: PUSH
70865: LD_INT 1
70867: NEG
70868: PUSH
70869: EMPTY
70870: LIST
70871: LIST
70872: PUSH
70873: LD_INT 1
70875: NEG
70876: PUSH
70877: LD_INT 2
70879: NEG
70880: PUSH
70881: EMPTY
70882: LIST
70883: LIST
70884: PUSH
70885: LD_INT 0
70887: PUSH
70888: LD_INT 2
70890: NEG
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 1
70898: PUSH
70899: LD_INT 1
70901: NEG
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 2
70909: PUSH
70910: LD_INT 1
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 2
70919: PUSH
70920: LD_INT 2
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 1
70929: PUSH
70930: LD_INT 2
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 0
70939: PUSH
70940: LD_INT 2
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: LD_INT 1
70949: NEG
70950: PUSH
70951: LD_INT 1
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 2
70960: NEG
70961: PUSH
70962: LD_INT 1
70964: NEG
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 2
70972: NEG
70973: PUSH
70974: LD_INT 2
70976: NEG
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: PUSH
70982: LD_INT 2
70984: NEG
70985: PUSH
70986: LD_INT 3
70988: NEG
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: PUSH
70994: LD_INT 1
70996: NEG
70997: PUSH
70998: LD_INT 3
71000: NEG
71001: PUSH
71002: EMPTY
71003: LIST
71004: LIST
71005: PUSH
71006: LD_INT 0
71008: PUSH
71009: LD_INT 3
71011: NEG
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 1
71019: PUSH
71020: LD_INT 2
71022: NEG
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 3
71030: PUSH
71031: LD_INT 2
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: PUSH
71038: LD_INT 3
71040: PUSH
71041: LD_INT 3
71043: PUSH
71044: EMPTY
71045: LIST
71046: LIST
71047: PUSH
71048: LD_INT 2
71050: PUSH
71051: LD_INT 3
71053: PUSH
71054: EMPTY
71055: LIST
71056: LIST
71057: PUSH
71058: LD_INT 1
71060: PUSH
71061: LD_INT 3
71063: PUSH
71064: EMPTY
71065: LIST
71066: LIST
71067: PUSH
71068: LD_INT 0
71070: PUSH
71071: LD_INT 3
71073: PUSH
71074: EMPTY
71075: LIST
71076: LIST
71077: PUSH
71078: LD_INT 1
71080: NEG
71081: PUSH
71082: LD_INT 2
71084: PUSH
71085: EMPTY
71086: LIST
71087: LIST
71088: PUSH
71089: LD_INT 3
71091: NEG
71092: PUSH
71093: LD_INT 2
71095: NEG
71096: PUSH
71097: EMPTY
71098: LIST
71099: LIST
71100: PUSH
71101: LD_INT 3
71103: NEG
71104: PUSH
71105: LD_INT 3
71107: NEG
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: LIST
71117: LIST
71118: LIST
71119: LIST
71120: LIST
71121: LIST
71122: LIST
71123: LIST
71124: LIST
71125: LIST
71126: LIST
71127: LIST
71128: LIST
71129: LIST
71130: LIST
71131: LIST
71132: LIST
71133: LIST
71134: LIST
71135: LIST
71136: LIST
71137: LIST
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: LIST
71143: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71144: LD_ADDR_VAR 0 46
71148: PUSH
71149: LD_INT 0
71151: PUSH
71152: LD_INT 0
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 0
71161: PUSH
71162: LD_INT 1
71164: NEG
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: LD_INT 1
71172: PUSH
71173: LD_INT 0
71175: PUSH
71176: EMPTY
71177: LIST
71178: LIST
71179: PUSH
71180: LD_INT 1
71182: PUSH
71183: LD_INT 1
71185: PUSH
71186: EMPTY
71187: LIST
71188: LIST
71189: PUSH
71190: LD_INT 0
71192: PUSH
71193: LD_INT 1
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 1
71202: NEG
71203: PUSH
71204: LD_INT 0
71206: PUSH
71207: EMPTY
71208: LIST
71209: LIST
71210: PUSH
71211: LD_INT 1
71213: NEG
71214: PUSH
71215: LD_INT 1
71217: NEG
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: PUSH
71223: LD_INT 1
71225: NEG
71226: PUSH
71227: LD_INT 2
71229: NEG
71230: PUSH
71231: EMPTY
71232: LIST
71233: LIST
71234: PUSH
71235: LD_INT 0
71237: PUSH
71238: LD_INT 2
71240: NEG
71241: PUSH
71242: EMPTY
71243: LIST
71244: LIST
71245: PUSH
71246: LD_INT 1
71248: PUSH
71249: LD_INT 1
71251: NEG
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: PUSH
71257: LD_INT 2
71259: PUSH
71260: LD_INT 0
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 2
71269: PUSH
71270: LD_INT 1
71272: PUSH
71273: EMPTY
71274: LIST
71275: LIST
71276: PUSH
71277: LD_INT 1
71279: PUSH
71280: LD_INT 2
71282: PUSH
71283: EMPTY
71284: LIST
71285: LIST
71286: PUSH
71287: LD_INT 0
71289: PUSH
71290: LD_INT 2
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 1
71299: NEG
71300: PUSH
71301: LD_INT 1
71303: PUSH
71304: EMPTY
71305: LIST
71306: LIST
71307: PUSH
71308: LD_INT 2
71310: NEG
71311: PUSH
71312: LD_INT 0
71314: PUSH
71315: EMPTY
71316: LIST
71317: LIST
71318: PUSH
71319: LD_INT 2
71321: NEG
71322: PUSH
71323: LD_INT 1
71325: NEG
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 1
71333: NEG
71334: PUSH
71335: LD_INT 3
71337: NEG
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: LD_INT 0
71345: PUSH
71346: LD_INT 3
71348: NEG
71349: PUSH
71350: EMPTY
71351: LIST
71352: LIST
71353: PUSH
71354: LD_INT 1
71356: PUSH
71357: LD_INT 2
71359: NEG
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: LD_INT 2
71367: PUSH
71368: LD_INT 1
71370: NEG
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: LD_INT 3
71378: PUSH
71379: LD_INT 0
71381: PUSH
71382: EMPTY
71383: LIST
71384: LIST
71385: PUSH
71386: LD_INT 3
71388: PUSH
71389: LD_INT 1
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: PUSH
71396: LD_INT 1
71398: PUSH
71399: LD_INT 3
71401: PUSH
71402: EMPTY
71403: LIST
71404: LIST
71405: PUSH
71406: LD_INT 0
71408: PUSH
71409: LD_INT 3
71411: PUSH
71412: EMPTY
71413: LIST
71414: LIST
71415: PUSH
71416: LD_INT 1
71418: NEG
71419: PUSH
71420: LD_INT 2
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PUSH
71427: LD_INT 2
71429: NEG
71430: PUSH
71431: LD_INT 1
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PUSH
71438: LD_INT 3
71440: NEG
71441: PUSH
71442: LD_INT 0
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 3
71451: NEG
71452: PUSH
71453: LD_INT 1
71455: NEG
71456: PUSH
71457: EMPTY
71458: LIST
71459: LIST
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: LIST
71465: LIST
71466: LIST
71467: LIST
71468: LIST
71469: LIST
71470: LIST
71471: LIST
71472: LIST
71473: LIST
71474: LIST
71475: LIST
71476: LIST
71477: LIST
71478: LIST
71479: LIST
71480: LIST
71481: LIST
71482: LIST
71483: LIST
71484: LIST
71485: LIST
71486: LIST
71487: LIST
71488: LIST
71489: LIST
71490: LIST
71491: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71492: LD_ADDR_VAR 0 47
71496: PUSH
71497: LD_INT 0
71499: PUSH
71500: LD_INT 0
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 0
71509: PUSH
71510: LD_INT 1
71512: NEG
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: PUSH
71518: LD_INT 1
71520: PUSH
71521: LD_INT 0
71523: PUSH
71524: EMPTY
71525: LIST
71526: LIST
71527: PUSH
71528: LD_INT 1
71530: PUSH
71531: LD_INT 1
71533: PUSH
71534: EMPTY
71535: LIST
71536: LIST
71537: PUSH
71538: LD_INT 0
71540: PUSH
71541: LD_INT 1
71543: PUSH
71544: EMPTY
71545: LIST
71546: LIST
71547: PUSH
71548: LD_INT 1
71550: NEG
71551: PUSH
71552: LD_INT 0
71554: PUSH
71555: EMPTY
71556: LIST
71557: LIST
71558: PUSH
71559: LD_INT 1
71561: NEG
71562: PUSH
71563: LD_INT 1
71565: NEG
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PUSH
71571: LD_INT 1
71573: NEG
71574: PUSH
71575: LD_INT 2
71577: NEG
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PUSH
71583: LD_INT 0
71585: PUSH
71586: LD_INT 2
71588: NEG
71589: PUSH
71590: EMPTY
71591: LIST
71592: LIST
71593: PUSH
71594: LD_INT 1
71596: PUSH
71597: LD_INT 1
71599: NEG
71600: PUSH
71601: EMPTY
71602: LIST
71603: LIST
71604: PUSH
71605: LD_INT 2
71607: NEG
71608: PUSH
71609: LD_INT 1
71611: NEG
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: PUSH
71617: LD_INT 2
71619: NEG
71620: PUSH
71621: LD_INT 2
71623: NEG
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: PUSH
71629: EMPTY
71630: LIST
71631: LIST
71632: LIST
71633: LIST
71634: LIST
71635: LIST
71636: LIST
71637: LIST
71638: LIST
71639: LIST
71640: LIST
71641: LIST
71642: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71643: LD_ADDR_VAR 0 48
71647: PUSH
71648: LD_INT 0
71650: PUSH
71651: LD_INT 0
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: PUSH
71658: LD_INT 0
71660: PUSH
71661: LD_INT 1
71663: NEG
71664: PUSH
71665: EMPTY
71666: LIST
71667: LIST
71668: PUSH
71669: LD_INT 1
71671: PUSH
71672: LD_INT 0
71674: PUSH
71675: EMPTY
71676: LIST
71677: LIST
71678: PUSH
71679: LD_INT 1
71681: PUSH
71682: LD_INT 1
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 0
71691: PUSH
71692: LD_INT 1
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: PUSH
71699: LD_INT 1
71701: NEG
71702: PUSH
71703: LD_INT 0
71705: PUSH
71706: EMPTY
71707: LIST
71708: LIST
71709: PUSH
71710: LD_INT 1
71712: NEG
71713: PUSH
71714: LD_INT 1
71716: NEG
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 1
71724: NEG
71725: PUSH
71726: LD_INT 2
71728: NEG
71729: PUSH
71730: EMPTY
71731: LIST
71732: LIST
71733: PUSH
71734: LD_INT 0
71736: PUSH
71737: LD_INT 2
71739: NEG
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: LD_INT 1
71747: PUSH
71748: LD_INT 1
71750: NEG
71751: PUSH
71752: EMPTY
71753: LIST
71754: LIST
71755: PUSH
71756: LD_INT 2
71758: PUSH
71759: LD_INT 0
71761: PUSH
71762: EMPTY
71763: LIST
71764: LIST
71765: PUSH
71766: LD_INT 2
71768: PUSH
71769: LD_INT 1
71771: PUSH
71772: EMPTY
71773: LIST
71774: LIST
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
71790: LD_ADDR_VAR 0 49
71794: PUSH
71795: LD_INT 0
71797: PUSH
71798: LD_INT 0
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 0
71807: PUSH
71808: LD_INT 1
71810: NEG
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 1
71818: PUSH
71819: LD_INT 0
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: PUSH
71826: LD_INT 1
71828: PUSH
71829: LD_INT 1
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 0
71838: PUSH
71839: LD_INT 1
71841: PUSH
71842: EMPTY
71843: LIST
71844: LIST
71845: PUSH
71846: LD_INT 1
71848: NEG
71849: PUSH
71850: LD_INT 0
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: LD_INT 1
71859: NEG
71860: PUSH
71861: LD_INT 1
71863: NEG
71864: PUSH
71865: EMPTY
71866: LIST
71867: LIST
71868: PUSH
71869: LD_INT 1
71871: PUSH
71872: LD_INT 1
71874: NEG
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: PUSH
71880: LD_INT 2
71882: PUSH
71883: LD_INT 0
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: PUSH
71890: LD_INT 2
71892: PUSH
71893: LD_INT 1
71895: PUSH
71896: EMPTY
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 2
71902: PUSH
71903: LD_INT 2
71905: PUSH
71906: EMPTY
71907: LIST
71908: LIST
71909: PUSH
71910: LD_INT 1
71912: PUSH
71913: LD_INT 2
71915: PUSH
71916: EMPTY
71917: LIST
71918: LIST
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: LIST
71924: LIST
71925: LIST
71926: LIST
71927: LIST
71928: LIST
71929: LIST
71930: LIST
71931: LIST
71932: LIST
71933: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
71934: LD_ADDR_VAR 0 50
71938: PUSH
71939: LD_INT 0
71941: PUSH
71942: LD_INT 0
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: PUSH
71949: LD_INT 0
71951: PUSH
71952: LD_INT 1
71954: NEG
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: PUSH
71960: LD_INT 1
71962: PUSH
71963: LD_INT 0
71965: PUSH
71966: EMPTY
71967: LIST
71968: LIST
71969: PUSH
71970: LD_INT 1
71972: PUSH
71973: LD_INT 1
71975: PUSH
71976: EMPTY
71977: LIST
71978: LIST
71979: PUSH
71980: LD_INT 0
71982: PUSH
71983: LD_INT 1
71985: PUSH
71986: EMPTY
71987: LIST
71988: LIST
71989: PUSH
71990: LD_INT 1
71992: NEG
71993: PUSH
71994: LD_INT 0
71996: PUSH
71997: EMPTY
71998: LIST
71999: LIST
72000: PUSH
72001: LD_INT 1
72003: NEG
72004: PUSH
72005: LD_INT 1
72007: NEG
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: PUSH
72013: LD_INT 2
72015: PUSH
72016: LD_INT 1
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 2
72025: PUSH
72026: LD_INT 2
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: PUSH
72033: LD_INT 1
72035: PUSH
72036: LD_INT 2
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: LD_INT 0
72045: PUSH
72046: LD_INT 2
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: PUSH
72053: LD_INT 1
72055: NEG
72056: PUSH
72057: LD_INT 1
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: EMPTY
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: LIST
72071: LIST
72072: LIST
72073: LIST
72074: LIST
72075: LIST
72076: LIST
72077: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72078: LD_ADDR_VAR 0 51
72082: PUSH
72083: LD_INT 0
72085: PUSH
72086: LD_INT 0
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: PUSH
72093: LD_INT 0
72095: PUSH
72096: LD_INT 1
72098: NEG
72099: PUSH
72100: EMPTY
72101: LIST
72102: LIST
72103: PUSH
72104: LD_INT 1
72106: PUSH
72107: LD_INT 0
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: PUSH
72114: LD_INT 1
72116: PUSH
72117: LD_INT 1
72119: PUSH
72120: EMPTY
72121: LIST
72122: LIST
72123: PUSH
72124: LD_INT 0
72126: PUSH
72127: LD_INT 1
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: LD_INT 1
72136: NEG
72137: PUSH
72138: LD_INT 0
72140: PUSH
72141: EMPTY
72142: LIST
72143: LIST
72144: PUSH
72145: LD_INT 1
72147: NEG
72148: PUSH
72149: LD_INT 1
72151: NEG
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: PUSH
72157: LD_INT 1
72159: PUSH
72160: LD_INT 2
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: PUSH
72167: LD_INT 0
72169: PUSH
72170: LD_INT 2
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: PUSH
72177: LD_INT 1
72179: NEG
72180: PUSH
72181: LD_INT 1
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: PUSH
72188: LD_INT 2
72190: NEG
72191: PUSH
72192: LD_INT 0
72194: PUSH
72195: EMPTY
72196: LIST
72197: LIST
72198: PUSH
72199: LD_INT 2
72201: NEG
72202: PUSH
72203: LD_INT 1
72205: NEG
72206: PUSH
72207: EMPTY
72208: LIST
72209: LIST
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: LIST
72215: LIST
72216: LIST
72217: LIST
72218: LIST
72219: LIST
72220: LIST
72221: LIST
72222: LIST
72223: LIST
72224: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72225: LD_ADDR_VAR 0 52
72229: PUSH
72230: LD_INT 0
72232: PUSH
72233: LD_INT 0
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: PUSH
72240: LD_INT 0
72242: PUSH
72243: LD_INT 1
72245: NEG
72246: PUSH
72247: EMPTY
72248: LIST
72249: LIST
72250: PUSH
72251: LD_INT 1
72253: PUSH
72254: LD_INT 0
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: PUSH
72261: LD_INT 1
72263: PUSH
72264: LD_INT 1
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: PUSH
72271: LD_INT 0
72273: PUSH
72274: LD_INT 1
72276: PUSH
72277: EMPTY
72278: LIST
72279: LIST
72280: PUSH
72281: LD_INT 1
72283: NEG
72284: PUSH
72285: LD_INT 0
72287: PUSH
72288: EMPTY
72289: LIST
72290: LIST
72291: PUSH
72292: LD_INT 1
72294: NEG
72295: PUSH
72296: LD_INT 1
72298: NEG
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PUSH
72304: LD_INT 1
72306: NEG
72307: PUSH
72308: LD_INT 2
72310: NEG
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PUSH
72316: LD_INT 1
72318: NEG
72319: PUSH
72320: LD_INT 1
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: LD_INT 2
72329: NEG
72330: PUSH
72331: LD_INT 0
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: PUSH
72338: LD_INT 2
72340: NEG
72341: PUSH
72342: LD_INT 1
72344: NEG
72345: PUSH
72346: EMPTY
72347: LIST
72348: LIST
72349: PUSH
72350: LD_INT 2
72352: NEG
72353: PUSH
72354: LD_INT 2
72356: NEG
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: LIST
72366: LIST
72367: LIST
72368: LIST
72369: LIST
72370: LIST
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72376: LD_ADDR_VAR 0 53
72380: PUSH
72381: LD_INT 0
72383: PUSH
72384: LD_INT 0
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: LD_INT 0
72393: PUSH
72394: LD_INT 1
72396: NEG
72397: PUSH
72398: EMPTY
72399: LIST
72400: LIST
72401: PUSH
72402: LD_INT 1
72404: PUSH
72405: LD_INT 0
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: PUSH
72412: LD_INT 1
72414: PUSH
72415: LD_INT 1
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PUSH
72422: LD_INT 0
72424: PUSH
72425: LD_INT 1
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: PUSH
72432: LD_INT 1
72434: NEG
72435: PUSH
72436: LD_INT 0
72438: PUSH
72439: EMPTY
72440: LIST
72441: LIST
72442: PUSH
72443: LD_INT 1
72445: NEG
72446: PUSH
72447: LD_INT 1
72449: NEG
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: LD_INT 1
72457: NEG
72458: PUSH
72459: LD_INT 2
72461: NEG
72462: PUSH
72463: EMPTY
72464: LIST
72465: LIST
72466: PUSH
72467: LD_INT 0
72469: PUSH
72470: LD_INT 2
72472: NEG
72473: PUSH
72474: EMPTY
72475: LIST
72476: LIST
72477: PUSH
72478: LD_INT 1
72480: PUSH
72481: LD_INT 1
72483: NEG
72484: PUSH
72485: EMPTY
72486: LIST
72487: LIST
72488: PUSH
72489: LD_INT 2
72491: PUSH
72492: LD_INT 0
72494: PUSH
72495: EMPTY
72496: LIST
72497: LIST
72498: PUSH
72499: LD_INT 2
72501: PUSH
72502: LD_INT 1
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: LD_INT 2
72511: PUSH
72512: LD_INT 2
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PUSH
72519: LD_INT 1
72521: PUSH
72522: LD_INT 2
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: PUSH
72529: LD_INT 0
72531: PUSH
72532: LD_INT 2
72534: PUSH
72535: EMPTY
72536: LIST
72537: LIST
72538: PUSH
72539: LD_INT 1
72541: NEG
72542: PUSH
72543: LD_INT 1
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: PUSH
72550: LD_INT 2
72552: NEG
72553: PUSH
72554: LD_INT 0
72556: PUSH
72557: EMPTY
72558: LIST
72559: LIST
72560: PUSH
72561: LD_INT 2
72563: NEG
72564: PUSH
72565: LD_INT 1
72567: NEG
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: PUSH
72573: LD_INT 2
72575: NEG
72576: PUSH
72577: LD_INT 2
72579: NEG
72580: PUSH
72581: EMPTY
72582: LIST
72583: LIST
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: LIST
72589: LIST
72590: LIST
72591: LIST
72592: LIST
72593: LIST
72594: LIST
72595: LIST
72596: LIST
72597: LIST
72598: LIST
72599: LIST
72600: LIST
72601: LIST
72602: LIST
72603: LIST
72604: LIST
72605: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72606: LD_ADDR_VAR 0 54
72610: PUSH
72611: LD_INT 0
72613: PUSH
72614: LD_INT 0
72616: PUSH
72617: EMPTY
72618: LIST
72619: LIST
72620: PUSH
72621: LD_INT 0
72623: PUSH
72624: LD_INT 1
72626: NEG
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: LD_INT 1
72634: PUSH
72635: LD_INT 0
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: PUSH
72642: LD_INT 1
72644: PUSH
72645: LD_INT 1
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: LD_INT 0
72654: PUSH
72655: LD_INT 1
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: LD_INT 1
72664: NEG
72665: PUSH
72666: LD_INT 0
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: PUSH
72673: LD_INT 1
72675: NEG
72676: PUSH
72677: LD_INT 1
72679: NEG
72680: PUSH
72681: EMPTY
72682: LIST
72683: LIST
72684: PUSH
72685: LD_INT 1
72687: NEG
72688: PUSH
72689: LD_INT 2
72691: NEG
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 0
72699: PUSH
72700: LD_INT 2
72702: NEG
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PUSH
72708: LD_INT 1
72710: PUSH
72711: LD_INT 1
72713: NEG
72714: PUSH
72715: EMPTY
72716: LIST
72717: LIST
72718: PUSH
72719: LD_INT 2
72721: PUSH
72722: LD_INT 0
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: PUSH
72729: LD_INT 2
72731: PUSH
72732: LD_INT 1
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: PUSH
72739: LD_INT 2
72741: PUSH
72742: LD_INT 2
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 1
72751: PUSH
72752: LD_INT 2
72754: PUSH
72755: EMPTY
72756: LIST
72757: LIST
72758: PUSH
72759: LD_INT 0
72761: PUSH
72762: LD_INT 2
72764: PUSH
72765: EMPTY
72766: LIST
72767: LIST
72768: PUSH
72769: LD_INT 1
72771: NEG
72772: PUSH
72773: LD_INT 1
72775: PUSH
72776: EMPTY
72777: LIST
72778: LIST
72779: PUSH
72780: LD_INT 2
72782: NEG
72783: PUSH
72784: LD_INT 0
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 2
72793: NEG
72794: PUSH
72795: LD_INT 1
72797: NEG
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: PUSH
72803: LD_INT 2
72805: NEG
72806: PUSH
72807: LD_INT 2
72809: NEG
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: EMPTY
72816: LIST
72817: LIST
72818: LIST
72819: LIST
72820: LIST
72821: LIST
72822: LIST
72823: LIST
72824: LIST
72825: LIST
72826: LIST
72827: LIST
72828: LIST
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72836: LD_ADDR_VAR 0 55
72840: PUSH
72841: LD_INT 0
72843: PUSH
72844: LD_INT 0
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: PUSH
72851: LD_INT 0
72853: PUSH
72854: LD_INT 1
72856: NEG
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 1
72864: PUSH
72865: LD_INT 0
72867: PUSH
72868: EMPTY
72869: LIST
72870: LIST
72871: PUSH
72872: LD_INT 1
72874: PUSH
72875: LD_INT 1
72877: PUSH
72878: EMPTY
72879: LIST
72880: LIST
72881: PUSH
72882: LD_INT 0
72884: PUSH
72885: LD_INT 1
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: PUSH
72892: LD_INT 1
72894: NEG
72895: PUSH
72896: LD_INT 0
72898: PUSH
72899: EMPTY
72900: LIST
72901: LIST
72902: PUSH
72903: LD_INT 1
72905: NEG
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 1
72917: NEG
72918: PUSH
72919: LD_INT 2
72921: NEG
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 0
72929: PUSH
72930: LD_INT 2
72932: NEG
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: PUSH
72938: LD_INT 1
72940: PUSH
72941: LD_INT 1
72943: NEG
72944: PUSH
72945: EMPTY
72946: LIST
72947: LIST
72948: PUSH
72949: LD_INT 2
72951: PUSH
72952: LD_INT 0
72954: PUSH
72955: EMPTY
72956: LIST
72957: LIST
72958: PUSH
72959: LD_INT 2
72961: PUSH
72962: LD_INT 1
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: PUSH
72969: LD_INT 2
72971: PUSH
72972: LD_INT 2
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 1
72981: PUSH
72982: LD_INT 2
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: LD_INT 0
72991: PUSH
72992: LD_INT 2
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: PUSH
72999: LD_INT 1
73001: NEG
73002: PUSH
73003: LD_INT 1
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 2
73012: NEG
73013: PUSH
73014: LD_INT 0
73016: PUSH
73017: EMPTY
73018: LIST
73019: LIST
73020: PUSH
73021: LD_INT 2
73023: NEG
73024: PUSH
73025: LD_INT 1
73027: NEG
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: PUSH
73033: LD_INT 2
73035: NEG
73036: PUSH
73037: LD_INT 2
73039: NEG
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: LIST
73049: LIST
73050: LIST
73051: LIST
73052: LIST
73053: LIST
73054: LIST
73055: LIST
73056: LIST
73057: LIST
73058: LIST
73059: LIST
73060: LIST
73061: LIST
73062: LIST
73063: LIST
73064: LIST
73065: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73066: LD_ADDR_VAR 0 56
73070: PUSH
73071: LD_INT 0
73073: PUSH
73074: LD_INT 0
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: PUSH
73081: LD_INT 0
73083: PUSH
73084: LD_INT 1
73086: NEG
73087: PUSH
73088: EMPTY
73089: LIST
73090: LIST
73091: PUSH
73092: LD_INT 1
73094: PUSH
73095: LD_INT 0
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: PUSH
73102: LD_INT 1
73104: PUSH
73105: LD_INT 1
73107: PUSH
73108: EMPTY
73109: LIST
73110: LIST
73111: PUSH
73112: LD_INT 0
73114: PUSH
73115: LD_INT 1
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: PUSH
73122: LD_INT 1
73124: NEG
73125: PUSH
73126: LD_INT 0
73128: PUSH
73129: EMPTY
73130: LIST
73131: LIST
73132: PUSH
73133: LD_INT 1
73135: NEG
73136: PUSH
73137: LD_INT 1
73139: NEG
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: PUSH
73145: LD_INT 1
73147: NEG
73148: PUSH
73149: LD_INT 2
73151: NEG
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 0
73159: PUSH
73160: LD_INT 2
73162: NEG
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 1
73170: PUSH
73171: LD_INT 1
73173: NEG
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: PUSH
73179: LD_INT 2
73181: PUSH
73182: LD_INT 0
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: PUSH
73189: LD_INT 2
73191: PUSH
73192: LD_INT 1
73194: PUSH
73195: EMPTY
73196: LIST
73197: LIST
73198: PUSH
73199: LD_INT 2
73201: PUSH
73202: LD_INT 2
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: PUSH
73209: LD_INT 1
73211: PUSH
73212: LD_INT 2
73214: PUSH
73215: EMPTY
73216: LIST
73217: LIST
73218: PUSH
73219: LD_INT 0
73221: PUSH
73222: LD_INT 2
73224: PUSH
73225: EMPTY
73226: LIST
73227: LIST
73228: PUSH
73229: LD_INT 1
73231: NEG
73232: PUSH
73233: LD_INT 1
73235: PUSH
73236: EMPTY
73237: LIST
73238: LIST
73239: PUSH
73240: LD_INT 2
73242: NEG
73243: PUSH
73244: LD_INT 0
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PUSH
73251: LD_INT 2
73253: NEG
73254: PUSH
73255: LD_INT 1
73257: NEG
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: PUSH
73263: LD_INT 2
73265: NEG
73266: PUSH
73267: LD_INT 2
73269: NEG
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: LIST
73279: LIST
73280: LIST
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: LIST
73286: LIST
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: LIST
73294: LIST
73295: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73296: LD_ADDR_VAR 0 57
73300: PUSH
73301: LD_INT 0
73303: PUSH
73304: LD_INT 0
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: PUSH
73311: LD_INT 0
73313: PUSH
73314: LD_INT 1
73316: NEG
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PUSH
73322: LD_INT 1
73324: PUSH
73325: LD_INT 0
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: PUSH
73332: LD_INT 1
73334: PUSH
73335: LD_INT 1
73337: PUSH
73338: EMPTY
73339: LIST
73340: LIST
73341: PUSH
73342: LD_INT 0
73344: PUSH
73345: LD_INT 1
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 1
73354: NEG
73355: PUSH
73356: LD_INT 0
73358: PUSH
73359: EMPTY
73360: LIST
73361: LIST
73362: PUSH
73363: LD_INT 1
73365: NEG
73366: PUSH
73367: LD_INT 1
73369: NEG
73370: PUSH
73371: EMPTY
73372: LIST
73373: LIST
73374: PUSH
73375: LD_INT 1
73377: NEG
73378: PUSH
73379: LD_INT 2
73381: NEG
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: LD_INT 2
73392: NEG
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 1
73400: PUSH
73401: LD_INT 1
73403: NEG
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 2
73411: PUSH
73412: LD_INT 0
73414: PUSH
73415: EMPTY
73416: LIST
73417: LIST
73418: PUSH
73419: LD_INT 2
73421: PUSH
73422: LD_INT 1
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 2
73431: PUSH
73432: LD_INT 2
73434: PUSH
73435: EMPTY
73436: LIST
73437: LIST
73438: PUSH
73439: LD_INT 1
73441: PUSH
73442: LD_INT 2
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: PUSH
73449: LD_INT 0
73451: PUSH
73452: LD_INT 2
73454: PUSH
73455: EMPTY
73456: LIST
73457: LIST
73458: PUSH
73459: LD_INT 1
73461: NEG
73462: PUSH
73463: LD_INT 1
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: PUSH
73470: LD_INT 2
73472: NEG
73473: PUSH
73474: LD_INT 0
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: LD_INT 2
73483: NEG
73484: PUSH
73485: LD_INT 1
73487: NEG
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: PUSH
73493: LD_INT 2
73495: NEG
73496: PUSH
73497: LD_INT 2
73499: NEG
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: EMPTY
73506: LIST
73507: LIST
73508: LIST
73509: LIST
73510: LIST
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73526: LD_ADDR_VAR 0 58
73530: PUSH
73531: LD_INT 0
73533: PUSH
73534: LD_INT 0
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: PUSH
73541: LD_INT 0
73543: PUSH
73544: LD_INT 1
73546: NEG
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: PUSH
73552: LD_INT 1
73554: PUSH
73555: LD_INT 0
73557: PUSH
73558: EMPTY
73559: LIST
73560: LIST
73561: PUSH
73562: LD_INT 1
73564: PUSH
73565: LD_INT 1
73567: PUSH
73568: EMPTY
73569: LIST
73570: LIST
73571: PUSH
73572: LD_INT 0
73574: PUSH
73575: LD_INT 1
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 1
73584: NEG
73585: PUSH
73586: LD_INT 0
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: LD_INT 1
73595: NEG
73596: PUSH
73597: LD_INT 1
73599: NEG
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: PUSH
73605: LD_INT 1
73607: NEG
73608: PUSH
73609: LD_INT 2
73611: NEG
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 0
73619: PUSH
73620: LD_INT 2
73622: NEG
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 1
73630: PUSH
73631: LD_INT 1
73633: NEG
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: PUSH
73639: LD_INT 2
73641: PUSH
73642: LD_INT 0
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: LD_INT 2
73651: PUSH
73652: LD_INT 1
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: PUSH
73659: LD_INT 2
73661: PUSH
73662: LD_INT 2
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 1
73671: PUSH
73672: LD_INT 2
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PUSH
73679: LD_INT 0
73681: PUSH
73682: LD_INT 2
73684: PUSH
73685: EMPTY
73686: LIST
73687: LIST
73688: PUSH
73689: LD_INT 1
73691: NEG
73692: PUSH
73693: LD_INT 1
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: LD_INT 2
73702: NEG
73703: PUSH
73704: LD_INT 0
73706: PUSH
73707: EMPTY
73708: LIST
73709: LIST
73710: PUSH
73711: LD_INT 2
73713: NEG
73714: PUSH
73715: LD_INT 1
73717: NEG
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 2
73725: NEG
73726: PUSH
73727: LD_INT 2
73729: NEG
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: LIST
73739: LIST
73740: LIST
73741: LIST
73742: LIST
73743: LIST
73744: LIST
73745: LIST
73746: LIST
73747: LIST
73748: LIST
73749: LIST
73750: LIST
73751: LIST
73752: LIST
73753: LIST
73754: LIST
73755: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73756: LD_ADDR_VAR 0 59
73760: PUSH
73761: LD_INT 0
73763: PUSH
73764: LD_INT 0
73766: PUSH
73767: EMPTY
73768: LIST
73769: LIST
73770: PUSH
73771: LD_INT 0
73773: PUSH
73774: LD_INT 1
73776: NEG
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PUSH
73782: LD_INT 1
73784: PUSH
73785: LD_INT 0
73787: PUSH
73788: EMPTY
73789: LIST
73790: LIST
73791: PUSH
73792: LD_INT 1
73794: PUSH
73795: LD_INT 1
73797: PUSH
73798: EMPTY
73799: LIST
73800: LIST
73801: PUSH
73802: LD_INT 0
73804: PUSH
73805: LD_INT 1
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: LD_INT 1
73814: NEG
73815: PUSH
73816: LD_INT 0
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: PUSH
73823: LD_INT 1
73825: NEG
73826: PUSH
73827: LD_INT 1
73829: NEG
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: LIST
73839: LIST
73840: LIST
73841: LIST
73842: LIST
73843: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73844: LD_ADDR_VAR 0 60
73848: PUSH
73849: LD_INT 0
73851: PUSH
73852: LD_INT 0
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 0
73861: PUSH
73862: LD_INT 1
73864: NEG
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 1
73872: PUSH
73873: LD_INT 0
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: PUSH
73880: LD_INT 1
73882: PUSH
73883: LD_INT 1
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: PUSH
73890: LD_INT 0
73892: PUSH
73893: LD_INT 1
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: PUSH
73900: LD_INT 1
73902: NEG
73903: PUSH
73904: LD_INT 0
73906: PUSH
73907: EMPTY
73908: LIST
73909: LIST
73910: PUSH
73911: LD_INT 1
73913: NEG
73914: PUSH
73915: LD_INT 1
73917: NEG
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: LIST
73927: LIST
73928: LIST
73929: LIST
73930: LIST
73931: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73932: LD_ADDR_VAR 0 61
73936: PUSH
73937: LD_INT 0
73939: PUSH
73940: LD_INT 0
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: LD_INT 0
73949: PUSH
73950: LD_INT 1
73952: NEG
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: PUSH
73958: LD_INT 1
73960: PUSH
73961: LD_INT 0
73963: PUSH
73964: EMPTY
73965: LIST
73966: LIST
73967: PUSH
73968: LD_INT 1
73970: PUSH
73971: LD_INT 1
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: LD_INT 0
73980: PUSH
73981: LD_INT 1
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: PUSH
73988: LD_INT 1
73990: NEG
73991: PUSH
73992: LD_INT 0
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: PUSH
73999: LD_INT 1
74001: NEG
74002: PUSH
74003: LD_INT 1
74005: NEG
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: PUSH
74011: EMPTY
74012: LIST
74013: LIST
74014: LIST
74015: LIST
74016: LIST
74017: LIST
74018: LIST
74019: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74020: LD_ADDR_VAR 0 62
74024: PUSH
74025: LD_INT 0
74027: PUSH
74028: LD_INT 0
74030: PUSH
74031: EMPTY
74032: LIST
74033: LIST
74034: PUSH
74035: LD_INT 0
74037: PUSH
74038: LD_INT 1
74040: NEG
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: LD_INT 1
74048: PUSH
74049: LD_INT 0
74051: PUSH
74052: EMPTY
74053: LIST
74054: LIST
74055: PUSH
74056: LD_INT 1
74058: PUSH
74059: LD_INT 1
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: PUSH
74066: LD_INT 0
74068: PUSH
74069: LD_INT 1
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 1
74078: NEG
74079: PUSH
74080: LD_INT 0
74082: PUSH
74083: EMPTY
74084: LIST
74085: LIST
74086: PUSH
74087: LD_INT 1
74089: NEG
74090: PUSH
74091: LD_INT 1
74093: NEG
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: LIST
74103: LIST
74104: LIST
74105: LIST
74106: LIST
74107: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74108: LD_ADDR_VAR 0 63
74112: PUSH
74113: LD_INT 0
74115: PUSH
74116: LD_INT 0
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: PUSH
74123: LD_INT 0
74125: PUSH
74126: LD_INT 1
74128: NEG
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: PUSH
74134: LD_INT 1
74136: PUSH
74137: LD_INT 0
74139: PUSH
74140: EMPTY
74141: LIST
74142: LIST
74143: PUSH
74144: LD_INT 1
74146: PUSH
74147: LD_INT 1
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: PUSH
74154: LD_INT 0
74156: PUSH
74157: LD_INT 1
74159: PUSH
74160: EMPTY
74161: LIST
74162: LIST
74163: PUSH
74164: LD_INT 1
74166: NEG
74167: PUSH
74168: LD_INT 0
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PUSH
74175: LD_INT 1
74177: NEG
74178: PUSH
74179: LD_INT 1
74181: NEG
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: EMPTY
74188: LIST
74189: LIST
74190: LIST
74191: LIST
74192: LIST
74193: LIST
74194: LIST
74195: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74196: LD_ADDR_VAR 0 64
74200: PUSH
74201: LD_INT 0
74203: PUSH
74204: LD_INT 0
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PUSH
74211: LD_INT 0
74213: PUSH
74214: LD_INT 1
74216: NEG
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 1
74224: PUSH
74225: LD_INT 0
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 1
74234: PUSH
74235: LD_INT 1
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: LD_INT 0
74244: PUSH
74245: LD_INT 1
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: LD_INT 1
74254: NEG
74255: PUSH
74256: LD_INT 0
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: LD_INT 1
74265: NEG
74266: PUSH
74267: LD_INT 1
74269: NEG
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: EMPTY
74276: LIST
74277: LIST
74278: LIST
74279: LIST
74280: LIST
74281: LIST
74282: LIST
74283: ST_TO_ADDR
// end ; 1 :
74284: GO 80181
74286: LD_INT 1
74288: DOUBLE
74289: EQUAL
74290: IFTRUE 74294
74292: GO 76917
74294: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74295: LD_ADDR_VAR 0 11
74299: PUSH
74300: LD_INT 1
74302: NEG
74303: PUSH
74304: LD_INT 3
74306: NEG
74307: PUSH
74308: EMPTY
74309: LIST
74310: LIST
74311: PUSH
74312: LD_INT 0
74314: PUSH
74315: LD_INT 3
74317: NEG
74318: PUSH
74319: EMPTY
74320: LIST
74321: LIST
74322: PUSH
74323: LD_INT 1
74325: PUSH
74326: LD_INT 2
74328: NEG
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: LIST
74338: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74339: LD_ADDR_VAR 0 12
74343: PUSH
74344: LD_INT 2
74346: PUSH
74347: LD_INT 1
74349: NEG
74350: PUSH
74351: EMPTY
74352: LIST
74353: LIST
74354: PUSH
74355: LD_INT 3
74357: PUSH
74358: LD_INT 0
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 3
74367: PUSH
74368: LD_INT 1
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: LIST
74379: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74380: LD_ADDR_VAR 0 13
74384: PUSH
74385: LD_INT 3
74387: PUSH
74388: LD_INT 2
74390: PUSH
74391: EMPTY
74392: LIST
74393: LIST
74394: PUSH
74395: LD_INT 3
74397: PUSH
74398: LD_INT 3
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: LD_INT 2
74407: PUSH
74408: LD_INT 3
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: LIST
74419: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74420: LD_ADDR_VAR 0 14
74424: PUSH
74425: LD_INT 1
74427: PUSH
74428: LD_INT 3
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: PUSH
74435: LD_INT 0
74437: PUSH
74438: LD_INT 3
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: PUSH
74445: LD_INT 1
74447: NEG
74448: PUSH
74449: LD_INT 2
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: LIST
74460: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74461: LD_ADDR_VAR 0 15
74465: PUSH
74466: LD_INT 2
74468: NEG
74469: PUSH
74470: LD_INT 1
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 3
74479: NEG
74480: PUSH
74481: LD_INT 0
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 3
74490: NEG
74491: PUSH
74492: LD_INT 1
74494: NEG
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: LIST
74504: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74505: LD_ADDR_VAR 0 16
74509: PUSH
74510: LD_INT 2
74512: NEG
74513: PUSH
74514: LD_INT 3
74516: NEG
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 3
74524: NEG
74525: PUSH
74526: LD_INT 2
74528: NEG
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: LD_INT 3
74536: NEG
74537: PUSH
74538: LD_INT 3
74540: NEG
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: LIST
74550: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74551: LD_ADDR_VAR 0 17
74555: PUSH
74556: LD_INT 1
74558: NEG
74559: PUSH
74560: LD_INT 3
74562: NEG
74563: PUSH
74564: EMPTY
74565: LIST
74566: LIST
74567: PUSH
74568: LD_INT 0
74570: PUSH
74571: LD_INT 3
74573: NEG
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: PUSH
74579: LD_INT 1
74581: PUSH
74582: LD_INT 2
74584: NEG
74585: PUSH
74586: EMPTY
74587: LIST
74588: LIST
74589: PUSH
74590: EMPTY
74591: LIST
74592: LIST
74593: LIST
74594: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74595: LD_ADDR_VAR 0 18
74599: PUSH
74600: LD_INT 2
74602: PUSH
74603: LD_INT 1
74605: NEG
74606: PUSH
74607: EMPTY
74608: LIST
74609: LIST
74610: PUSH
74611: LD_INT 3
74613: PUSH
74614: LD_INT 0
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: PUSH
74621: LD_INT 3
74623: PUSH
74624: LD_INT 1
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: LIST
74635: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74636: LD_ADDR_VAR 0 19
74640: PUSH
74641: LD_INT 3
74643: PUSH
74644: LD_INT 2
74646: PUSH
74647: EMPTY
74648: LIST
74649: LIST
74650: PUSH
74651: LD_INT 3
74653: PUSH
74654: LD_INT 3
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 2
74663: PUSH
74664: LD_INT 3
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: PUSH
74671: EMPTY
74672: LIST
74673: LIST
74674: LIST
74675: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74676: LD_ADDR_VAR 0 20
74680: PUSH
74681: LD_INT 1
74683: PUSH
74684: LD_INT 3
74686: PUSH
74687: EMPTY
74688: LIST
74689: LIST
74690: PUSH
74691: LD_INT 0
74693: PUSH
74694: LD_INT 3
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: LD_INT 1
74703: NEG
74704: PUSH
74705: LD_INT 2
74707: PUSH
74708: EMPTY
74709: LIST
74710: LIST
74711: PUSH
74712: EMPTY
74713: LIST
74714: LIST
74715: LIST
74716: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74717: LD_ADDR_VAR 0 21
74721: PUSH
74722: LD_INT 2
74724: NEG
74725: PUSH
74726: LD_INT 1
74728: PUSH
74729: EMPTY
74730: LIST
74731: LIST
74732: PUSH
74733: LD_INT 3
74735: NEG
74736: PUSH
74737: LD_INT 0
74739: PUSH
74740: EMPTY
74741: LIST
74742: LIST
74743: PUSH
74744: LD_INT 3
74746: NEG
74747: PUSH
74748: LD_INT 1
74750: NEG
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: LIST
74760: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74761: LD_ADDR_VAR 0 22
74765: PUSH
74766: LD_INT 2
74768: NEG
74769: PUSH
74770: LD_INT 3
74772: NEG
74773: PUSH
74774: EMPTY
74775: LIST
74776: LIST
74777: PUSH
74778: LD_INT 3
74780: NEG
74781: PUSH
74782: LD_INT 2
74784: NEG
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: LD_INT 3
74792: NEG
74793: PUSH
74794: LD_INT 3
74796: NEG
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: LIST
74806: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
74807: LD_ADDR_VAR 0 23
74811: PUSH
74812: LD_INT 0
74814: PUSH
74815: LD_INT 3
74817: NEG
74818: PUSH
74819: EMPTY
74820: LIST
74821: LIST
74822: PUSH
74823: LD_INT 1
74825: NEG
74826: PUSH
74827: LD_INT 4
74829: NEG
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: PUSH
74835: LD_INT 1
74837: PUSH
74838: LD_INT 3
74840: NEG
74841: PUSH
74842: EMPTY
74843: LIST
74844: LIST
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: LIST
74850: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
74851: LD_ADDR_VAR 0 24
74855: PUSH
74856: LD_INT 3
74858: PUSH
74859: LD_INT 0
74861: PUSH
74862: EMPTY
74863: LIST
74864: LIST
74865: PUSH
74866: LD_INT 3
74868: PUSH
74869: LD_INT 1
74871: NEG
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 4
74879: PUSH
74880: LD_INT 1
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: EMPTY
74888: LIST
74889: LIST
74890: LIST
74891: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
74892: LD_ADDR_VAR 0 25
74896: PUSH
74897: LD_INT 3
74899: PUSH
74900: LD_INT 3
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 4
74909: PUSH
74910: LD_INT 3
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 3
74919: PUSH
74920: LD_INT 4
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: EMPTY
74928: LIST
74929: LIST
74930: LIST
74931: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
74932: LD_ADDR_VAR 0 26
74936: PUSH
74937: LD_INT 0
74939: PUSH
74940: LD_INT 3
74942: PUSH
74943: EMPTY
74944: LIST
74945: LIST
74946: PUSH
74947: LD_INT 1
74949: PUSH
74950: LD_INT 4
74952: PUSH
74953: EMPTY
74954: LIST
74955: LIST
74956: PUSH
74957: LD_INT 1
74959: NEG
74960: PUSH
74961: LD_INT 3
74963: PUSH
74964: EMPTY
74965: LIST
74966: LIST
74967: PUSH
74968: EMPTY
74969: LIST
74970: LIST
74971: LIST
74972: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
74973: LD_ADDR_VAR 0 27
74977: PUSH
74978: LD_INT 3
74980: NEG
74981: PUSH
74982: LD_INT 0
74984: PUSH
74985: EMPTY
74986: LIST
74987: LIST
74988: PUSH
74989: LD_INT 3
74991: NEG
74992: PUSH
74993: LD_INT 1
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: PUSH
75000: LD_INT 4
75002: NEG
75003: PUSH
75004: LD_INT 1
75006: NEG
75007: PUSH
75008: EMPTY
75009: LIST
75010: LIST
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: LIST
75016: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75017: LD_ADDR_VAR 0 28
75021: PUSH
75022: LD_INT 3
75024: NEG
75025: PUSH
75026: LD_INT 3
75028: NEG
75029: PUSH
75030: EMPTY
75031: LIST
75032: LIST
75033: PUSH
75034: LD_INT 3
75036: NEG
75037: PUSH
75038: LD_INT 4
75040: NEG
75041: PUSH
75042: EMPTY
75043: LIST
75044: LIST
75045: PUSH
75046: LD_INT 4
75048: NEG
75049: PUSH
75050: LD_INT 3
75052: NEG
75053: PUSH
75054: EMPTY
75055: LIST
75056: LIST
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: LIST
75062: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75063: LD_ADDR_VAR 0 29
75067: PUSH
75068: LD_INT 1
75070: NEG
75071: PUSH
75072: LD_INT 3
75074: NEG
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: PUSH
75080: LD_INT 0
75082: PUSH
75083: LD_INT 3
75085: NEG
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PUSH
75091: LD_INT 1
75093: PUSH
75094: LD_INT 2
75096: NEG
75097: PUSH
75098: EMPTY
75099: LIST
75100: LIST
75101: PUSH
75102: LD_INT 1
75104: NEG
75105: PUSH
75106: LD_INT 4
75108: NEG
75109: PUSH
75110: EMPTY
75111: LIST
75112: LIST
75113: PUSH
75114: LD_INT 0
75116: PUSH
75117: LD_INT 4
75119: NEG
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PUSH
75125: LD_INT 1
75127: PUSH
75128: LD_INT 3
75130: NEG
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 1
75138: NEG
75139: PUSH
75140: LD_INT 5
75142: NEG
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: LD_INT 0
75150: PUSH
75151: LD_INT 5
75153: NEG
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 1
75161: PUSH
75162: LD_INT 4
75164: NEG
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 1
75172: NEG
75173: PUSH
75174: LD_INT 6
75176: NEG
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 0
75184: PUSH
75185: LD_INT 6
75187: NEG
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 1
75195: PUSH
75196: LD_INT 5
75198: NEG
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: LIST
75208: LIST
75209: LIST
75210: LIST
75211: LIST
75212: LIST
75213: LIST
75214: LIST
75215: LIST
75216: LIST
75217: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75218: LD_ADDR_VAR 0 30
75222: PUSH
75223: LD_INT 2
75225: PUSH
75226: LD_INT 1
75228: NEG
75229: PUSH
75230: EMPTY
75231: LIST
75232: LIST
75233: PUSH
75234: LD_INT 3
75236: PUSH
75237: LD_INT 0
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: LD_INT 3
75246: PUSH
75247: LD_INT 1
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 3
75256: PUSH
75257: LD_INT 1
75259: NEG
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PUSH
75265: LD_INT 4
75267: PUSH
75268: LD_INT 0
75270: PUSH
75271: EMPTY
75272: LIST
75273: LIST
75274: PUSH
75275: LD_INT 4
75277: PUSH
75278: LD_INT 1
75280: PUSH
75281: EMPTY
75282: LIST
75283: LIST
75284: PUSH
75285: LD_INT 4
75287: PUSH
75288: LD_INT 1
75290: NEG
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: PUSH
75296: LD_INT 5
75298: PUSH
75299: LD_INT 0
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: LD_INT 5
75308: PUSH
75309: LD_INT 1
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: PUSH
75316: LD_INT 5
75318: PUSH
75319: LD_INT 1
75321: NEG
75322: PUSH
75323: EMPTY
75324: LIST
75325: LIST
75326: PUSH
75327: LD_INT 6
75329: PUSH
75330: LD_INT 0
75332: PUSH
75333: EMPTY
75334: LIST
75335: LIST
75336: PUSH
75337: LD_INT 6
75339: PUSH
75340: LD_INT 1
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: LIST
75353: LIST
75354: LIST
75355: LIST
75356: LIST
75357: LIST
75358: LIST
75359: LIST
75360: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75361: LD_ADDR_VAR 0 31
75365: PUSH
75366: LD_INT 3
75368: PUSH
75369: LD_INT 2
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 3
75378: PUSH
75379: LD_INT 3
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 2
75388: PUSH
75389: LD_INT 3
75391: PUSH
75392: EMPTY
75393: LIST
75394: LIST
75395: PUSH
75396: LD_INT 4
75398: PUSH
75399: LD_INT 3
75401: PUSH
75402: EMPTY
75403: LIST
75404: LIST
75405: PUSH
75406: LD_INT 4
75408: PUSH
75409: LD_INT 4
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: PUSH
75416: LD_INT 3
75418: PUSH
75419: LD_INT 4
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PUSH
75426: LD_INT 5
75428: PUSH
75429: LD_INT 4
75431: PUSH
75432: EMPTY
75433: LIST
75434: LIST
75435: PUSH
75436: LD_INT 5
75438: PUSH
75439: LD_INT 5
75441: PUSH
75442: EMPTY
75443: LIST
75444: LIST
75445: PUSH
75446: LD_INT 4
75448: PUSH
75449: LD_INT 5
75451: PUSH
75452: EMPTY
75453: LIST
75454: LIST
75455: PUSH
75456: LD_INT 6
75458: PUSH
75459: LD_INT 5
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: LD_INT 6
75468: PUSH
75469: LD_INT 6
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: LD_INT 5
75478: PUSH
75479: LD_INT 6
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: LIST
75490: LIST
75491: LIST
75492: LIST
75493: LIST
75494: LIST
75495: LIST
75496: LIST
75497: LIST
75498: LIST
75499: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75500: LD_ADDR_VAR 0 32
75504: PUSH
75505: LD_INT 1
75507: PUSH
75508: LD_INT 3
75510: PUSH
75511: EMPTY
75512: LIST
75513: LIST
75514: PUSH
75515: LD_INT 0
75517: PUSH
75518: LD_INT 3
75520: PUSH
75521: EMPTY
75522: LIST
75523: LIST
75524: PUSH
75525: LD_INT 1
75527: NEG
75528: PUSH
75529: LD_INT 2
75531: PUSH
75532: EMPTY
75533: LIST
75534: LIST
75535: PUSH
75536: LD_INT 1
75538: PUSH
75539: LD_INT 4
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: PUSH
75546: LD_INT 0
75548: PUSH
75549: LD_INT 4
75551: PUSH
75552: EMPTY
75553: LIST
75554: LIST
75555: PUSH
75556: LD_INT 1
75558: NEG
75559: PUSH
75560: LD_INT 3
75562: PUSH
75563: EMPTY
75564: LIST
75565: LIST
75566: PUSH
75567: LD_INT 1
75569: PUSH
75570: LD_INT 5
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: PUSH
75577: LD_INT 0
75579: PUSH
75580: LD_INT 5
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: PUSH
75587: LD_INT 1
75589: NEG
75590: PUSH
75591: LD_INT 4
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: LD_INT 1
75600: PUSH
75601: LD_INT 6
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 0
75610: PUSH
75611: LD_INT 6
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 1
75620: NEG
75621: PUSH
75622: LD_INT 5
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: LIST
75633: LIST
75634: LIST
75635: LIST
75636: LIST
75637: LIST
75638: LIST
75639: LIST
75640: LIST
75641: LIST
75642: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75643: LD_ADDR_VAR 0 33
75647: PUSH
75648: LD_INT 2
75650: NEG
75651: PUSH
75652: LD_INT 1
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 3
75661: NEG
75662: PUSH
75663: LD_INT 0
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PUSH
75670: LD_INT 3
75672: NEG
75673: PUSH
75674: LD_INT 1
75676: NEG
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 3
75684: NEG
75685: PUSH
75686: LD_INT 1
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 4
75695: NEG
75696: PUSH
75697: LD_INT 0
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: PUSH
75704: LD_INT 4
75706: NEG
75707: PUSH
75708: LD_INT 1
75710: NEG
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PUSH
75716: LD_INT 4
75718: NEG
75719: PUSH
75720: LD_INT 1
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PUSH
75727: LD_INT 5
75729: NEG
75730: PUSH
75731: LD_INT 0
75733: PUSH
75734: EMPTY
75735: LIST
75736: LIST
75737: PUSH
75738: LD_INT 5
75740: NEG
75741: PUSH
75742: LD_INT 1
75744: NEG
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PUSH
75750: LD_INT 5
75752: NEG
75753: PUSH
75754: LD_INT 1
75756: PUSH
75757: EMPTY
75758: LIST
75759: LIST
75760: PUSH
75761: LD_INT 6
75763: NEG
75764: PUSH
75765: LD_INT 0
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 6
75774: NEG
75775: PUSH
75776: LD_INT 1
75778: NEG
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: LIST
75788: LIST
75789: LIST
75790: LIST
75791: LIST
75792: LIST
75793: LIST
75794: LIST
75795: LIST
75796: LIST
75797: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
75798: LD_ADDR_VAR 0 34
75802: PUSH
75803: LD_INT 2
75805: NEG
75806: PUSH
75807: LD_INT 3
75809: NEG
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: LD_INT 3
75817: NEG
75818: PUSH
75819: LD_INT 2
75821: NEG
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: PUSH
75827: LD_INT 3
75829: NEG
75830: PUSH
75831: LD_INT 3
75833: NEG
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 3
75841: NEG
75842: PUSH
75843: LD_INT 4
75845: NEG
75846: PUSH
75847: EMPTY
75848: LIST
75849: LIST
75850: PUSH
75851: LD_INT 4
75853: NEG
75854: PUSH
75855: LD_INT 3
75857: NEG
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: LD_INT 4
75865: NEG
75866: PUSH
75867: LD_INT 4
75869: NEG
75870: PUSH
75871: EMPTY
75872: LIST
75873: LIST
75874: PUSH
75875: LD_INT 4
75877: NEG
75878: PUSH
75879: LD_INT 5
75881: NEG
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: PUSH
75887: LD_INT 5
75889: NEG
75890: PUSH
75891: LD_INT 4
75893: NEG
75894: PUSH
75895: EMPTY
75896: LIST
75897: LIST
75898: PUSH
75899: LD_INT 5
75901: NEG
75902: PUSH
75903: LD_INT 5
75905: NEG
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: PUSH
75911: LD_INT 5
75913: NEG
75914: PUSH
75915: LD_INT 6
75917: NEG
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 6
75925: NEG
75926: PUSH
75927: LD_INT 5
75929: NEG
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 6
75937: NEG
75938: PUSH
75939: LD_INT 6
75941: NEG
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: PUSH
75947: EMPTY
75948: LIST
75949: LIST
75950: LIST
75951: LIST
75952: LIST
75953: LIST
75954: LIST
75955: LIST
75956: LIST
75957: LIST
75958: LIST
75959: LIST
75960: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
75961: LD_ADDR_VAR 0 41
75965: PUSH
75966: LD_INT 0
75968: PUSH
75969: LD_INT 2
75971: NEG
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 1
75979: NEG
75980: PUSH
75981: LD_INT 3
75983: NEG
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: PUSH
75989: LD_INT 1
75991: PUSH
75992: LD_INT 2
75994: NEG
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: EMPTY
76001: LIST
76002: LIST
76003: LIST
76004: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76005: LD_ADDR_VAR 0 42
76009: PUSH
76010: LD_INT 2
76012: PUSH
76013: LD_INT 0
76015: PUSH
76016: EMPTY
76017: LIST
76018: LIST
76019: PUSH
76020: LD_INT 2
76022: PUSH
76023: LD_INT 1
76025: NEG
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 3
76033: PUSH
76034: LD_INT 1
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: LIST
76045: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76046: LD_ADDR_VAR 0 43
76050: PUSH
76051: LD_INT 2
76053: PUSH
76054: LD_INT 2
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: PUSH
76061: LD_INT 3
76063: PUSH
76064: LD_INT 2
76066: PUSH
76067: EMPTY
76068: LIST
76069: LIST
76070: PUSH
76071: LD_INT 2
76073: PUSH
76074: LD_INT 3
76076: PUSH
76077: EMPTY
76078: LIST
76079: LIST
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: LIST
76085: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76086: LD_ADDR_VAR 0 44
76090: PUSH
76091: LD_INT 0
76093: PUSH
76094: LD_INT 2
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PUSH
76101: LD_INT 1
76103: PUSH
76104: LD_INT 3
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: PUSH
76111: LD_INT 1
76113: NEG
76114: PUSH
76115: LD_INT 2
76117: PUSH
76118: EMPTY
76119: LIST
76120: LIST
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: LIST
76126: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76127: LD_ADDR_VAR 0 45
76131: PUSH
76132: LD_INT 2
76134: NEG
76135: PUSH
76136: LD_INT 0
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: PUSH
76143: LD_INT 2
76145: NEG
76146: PUSH
76147: LD_INT 1
76149: PUSH
76150: EMPTY
76151: LIST
76152: LIST
76153: PUSH
76154: LD_INT 3
76156: NEG
76157: PUSH
76158: LD_INT 1
76160: NEG
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PUSH
76166: EMPTY
76167: LIST
76168: LIST
76169: LIST
76170: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76171: LD_ADDR_VAR 0 46
76175: PUSH
76176: LD_INT 2
76178: NEG
76179: PUSH
76180: LD_INT 2
76182: NEG
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: PUSH
76188: LD_INT 2
76190: NEG
76191: PUSH
76192: LD_INT 3
76194: NEG
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: PUSH
76200: LD_INT 3
76202: NEG
76203: PUSH
76204: LD_INT 2
76206: NEG
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: PUSH
76212: EMPTY
76213: LIST
76214: LIST
76215: LIST
76216: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76217: LD_ADDR_VAR 0 47
76221: PUSH
76222: LD_INT 2
76224: NEG
76225: PUSH
76226: LD_INT 3
76228: NEG
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 1
76236: NEG
76237: PUSH
76238: LD_INT 3
76240: NEG
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: PUSH
76246: EMPTY
76247: LIST
76248: LIST
76249: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76250: LD_ADDR_VAR 0 48
76254: PUSH
76255: LD_INT 1
76257: PUSH
76258: LD_INT 2
76260: NEG
76261: PUSH
76262: EMPTY
76263: LIST
76264: LIST
76265: PUSH
76266: LD_INT 2
76268: PUSH
76269: LD_INT 1
76271: NEG
76272: PUSH
76273: EMPTY
76274: LIST
76275: LIST
76276: PUSH
76277: EMPTY
76278: LIST
76279: LIST
76280: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76281: LD_ADDR_VAR 0 49
76285: PUSH
76286: LD_INT 3
76288: PUSH
76289: LD_INT 1
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 3
76298: PUSH
76299: LD_INT 2
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76310: LD_ADDR_VAR 0 50
76314: PUSH
76315: LD_INT 2
76317: PUSH
76318: LD_INT 3
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 1
76327: PUSH
76328: LD_INT 3
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PUSH
76335: EMPTY
76336: LIST
76337: LIST
76338: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76339: LD_ADDR_VAR 0 51
76343: PUSH
76344: LD_INT 1
76346: NEG
76347: PUSH
76348: LD_INT 2
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: PUSH
76355: LD_INT 2
76357: NEG
76358: PUSH
76359: LD_INT 1
76361: PUSH
76362: EMPTY
76363: LIST
76364: LIST
76365: PUSH
76366: EMPTY
76367: LIST
76368: LIST
76369: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76370: LD_ADDR_VAR 0 52
76374: PUSH
76375: LD_INT 3
76377: NEG
76378: PUSH
76379: LD_INT 1
76381: NEG
76382: PUSH
76383: EMPTY
76384: LIST
76385: LIST
76386: PUSH
76387: LD_INT 3
76389: NEG
76390: PUSH
76391: LD_INT 2
76393: NEG
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76403: LD_ADDR_VAR 0 53
76407: PUSH
76408: LD_INT 1
76410: NEG
76411: PUSH
76412: LD_INT 3
76414: NEG
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 0
76422: PUSH
76423: LD_INT 3
76425: NEG
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: PUSH
76431: LD_INT 1
76433: PUSH
76434: LD_INT 2
76436: NEG
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: EMPTY
76443: LIST
76444: LIST
76445: LIST
76446: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76447: LD_ADDR_VAR 0 54
76451: PUSH
76452: LD_INT 2
76454: PUSH
76455: LD_INT 1
76457: NEG
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: PUSH
76463: LD_INT 3
76465: PUSH
76466: LD_INT 0
76468: PUSH
76469: EMPTY
76470: LIST
76471: LIST
76472: PUSH
76473: LD_INT 3
76475: PUSH
76476: LD_INT 1
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: LIST
76487: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76488: LD_ADDR_VAR 0 55
76492: PUSH
76493: LD_INT 3
76495: PUSH
76496: LD_INT 2
76498: PUSH
76499: EMPTY
76500: LIST
76501: LIST
76502: PUSH
76503: LD_INT 3
76505: PUSH
76506: LD_INT 3
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: PUSH
76513: LD_INT 2
76515: PUSH
76516: LD_INT 3
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: PUSH
76523: EMPTY
76524: LIST
76525: LIST
76526: LIST
76527: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76528: LD_ADDR_VAR 0 56
76532: PUSH
76533: LD_INT 1
76535: PUSH
76536: LD_INT 3
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 0
76545: PUSH
76546: LD_INT 3
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: PUSH
76553: LD_INT 1
76555: NEG
76556: PUSH
76557: LD_INT 2
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: PUSH
76564: EMPTY
76565: LIST
76566: LIST
76567: LIST
76568: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76569: LD_ADDR_VAR 0 57
76573: PUSH
76574: LD_INT 2
76576: NEG
76577: PUSH
76578: LD_INT 1
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PUSH
76585: LD_INT 3
76587: NEG
76588: PUSH
76589: LD_INT 0
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: PUSH
76596: LD_INT 3
76598: NEG
76599: PUSH
76600: LD_INT 1
76602: NEG
76603: PUSH
76604: EMPTY
76605: LIST
76606: LIST
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: LIST
76612: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76613: LD_ADDR_VAR 0 58
76617: PUSH
76618: LD_INT 2
76620: NEG
76621: PUSH
76622: LD_INT 3
76624: NEG
76625: PUSH
76626: EMPTY
76627: LIST
76628: LIST
76629: PUSH
76630: LD_INT 3
76632: NEG
76633: PUSH
76634: LD_INT 2
76636: NEG
76637: PUSH
76638: EMPTY
76639: LIST
76640: LIST
76641: PUSH
76642: LD_INT 3
76644: NEG
76645: PUSH
76646: LD_INT 3
76648: NEG
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: LIST
76658: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76659: LD_ADDR_VAR 0 59
76663: PUSH
76664: LD_INT 1
76666: NEG
76667: PUSH
76668: LD_INT 2
76670: NEG
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: PUSH
76676: LD_INT 0
76678: PUSH
76679: LD_INT 2
76681: NEG
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 1
76689: PUSH
76690: LD_INT 1
76692: NEG
76693: PUSH
76694: EMPTY
76695: LIST
76696: LIST
76697: PUSH
76698: EMPTY
76699: LIST
76700: LIST
76701: LIST
76702: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76703: LD_ADDR_VAR 0 60
76707: PUSH
76708: LD_INT 1
76710: PUSH
76711: LD_INT 1
76713: NEG
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: PUSH
76719: LD_INT 2
76721: PUSH
76722: LD_INT 0
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: PUSH
76729: LD_INT 2
76731: PUSH
76732: LD_INT 1
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: EMPTY
76740: LIST
76741: LIST
76742: LIST
76743: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76744: LD_ADDR_VAR 0 61
76748: PUSH
76749: LD_INT 2
76751: PUSH
76752: LD_INT 1
76754: PUSH
76755: EMPTY
76756: LIST
76757: LIST
76758: PUSH
76759: LD_INT 2
76761: PUSH
76762: LD_INT 2
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: PUSH
76769: LD_INT 1
76771: PUSH
76772: LD_INT 2
76774: PUSH
76775: EMPTY
76776: LIST
76777: LIST
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: LIST
76783: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76784: LD_ADDR_VAR 0 62
76788: PUSH
76789: LD_INT 1
76791: PUSH
76792: LD_INT 2
76794: PUSH
76795: EMPTY
76796: LIST
76797: LIST
76798: PUSH
76799: LD_INT 0
76801: PUSH
76802: LD_INT 2
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: PUSH
76809: LD_INT 1
76811: NEG
76812: PUSH
76813: LD_INT 1
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: LIST
76824: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76825: LD_ADDR_VAR 0 63
76829: PUSH
76830: LD_INT 1
76832: NEG
76833: PUSH
76834: LD_INT 1
76836: PUSH
76837: EMPTY
76838: LIST
76839: LIST
76840: PUSH
76841: LD_INT 2
76843: NEG
76844: PUSH
76845: LD_INT 0
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: PUSH
76852: LD_INT 2
76854: NEG
76855: PUSH
76856: LD_INT 1
76858: NEG
76859: PUSH
76860: EMPTY
76861: LIST
76862: LIST
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: LIST
76868: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76869: LD_ADDR_VAR 0 64
76873: PUSH
76874: LD_INT 1
76876: NEG
76877: PUSH
76878: LD_INT 2
76880: NEG
76881: PUSH
76882: EMPTY
76883: LIST
76884: LIST
76885: PUSH
76886: LD_INT 2
76888: NEG
76889: PUSH
76890: LD_INT 1
76892: NEG
76893: PUSH
76894: EMPTY
76895: LIST
76896: LIST
76897: PUSH
76898: LD_INT 2
76900: NEG
76901: PUSH
76902: LD_INT 2
76904: NEG
76905: PUSH
76906: EMPTY
76907: LIST
76908: LIST
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: LIST
76914: ST_TO_ADDR
// end ; 2 :
76915: GO 80181
76917: LD_INT 2
76919: DOUBLE
76920: EQUAL
76921: IFTRUE 76925
76923: GO 80180
76925: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
76926: LD_ADDR_VAR 0 29
76930: PUSH
76931: LD_INT 4
76933: PUSH
76934: LD_INT 0
76936: PUSH
76937: EMPTY
76938: LIST
76939: LIST
76940: PUSH
76941: LD_INT 4
76943: PUSH
76944: LD_INT 1
76946: NEG
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: PUSH
76952: LD_INT 5
76954: PUSH
76955: LD_INT 0
76957: PUSH
76958: EMPTY
76959: LIST
76960: LIST
76961: PUSH
76962: LD_INT 5
76964: PUSH
76965: LD_INT 1
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: LD_INT 4
76974: PUSH
76975: LD_INT 1
76977: PUSH
76978: EMPTY
76979: LIST
76980: LIST
76981: PUSH
76982: LD_INT 3
76984: PUSH
76985: LD_INT 0
76987: PUSH
76988: EMPTY
76989: LIST
76990: LIST
76991: PUSH
76992: LD_INT 3
76994: PUSH
76995: LD_INT 1
76997: NEG
76998: PUSH
76999: EMPTY
77000: LIST
77001: LIST
77002: PUSH
77003: LD_INT 3
77005: PUSH
77006: LD_INT 2
77008: NEG
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: PUSH
77014: LD_INT 5
77016: PUSH
77017: LD_INT 2
77019: PUSH
77020: EMPTY
77021: LIST
77022: LIST
77023: PUSH
77024: LD_INT 3
77026: PUSH
77027: LD_INT 3
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: PUSH
77034: LD_INT 3
77036: PUSH
77037: LD_INT 2
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PUSH
77044: LD_INT 4
77046: PUSH
77047: LD_INT 3
77049: PUSH
77050: EMPTY
77051: LIST
77052: LIST
77053: PUSH
77054: LD_INT 4
77056: PUSH
77057: LD_INT 4
77059: PUSH
77060: EMPTY
77061: LIST
77062: LIST
77063: PUSH
77064: LD_INT 3
77066: PUSH
77067: LD_INT 4
77069: PUSH
77070: EMPTY
77071: LIST
77072: LIST
77073: PUSH
77074: LD_INT 2
77076: PUSH
77077: LD_INT 3
77079: PUSH
77080: EMPTY
77081: LIST
77082: LIST
77083: PUSH
77084: LD_INT 2
77086: PUSH
77087: LD_INT 2
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PUSH
77094: LD_INT 4
77096: PUSH
77097: LD_INT 2
77099: PUSH
77100: EMPTY
77101: LIST
77102: LIST
77103: PUSH
77104: LD_INT 2
77106: PUSH
77107: LD_INT 4
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: PUSH
77114: LD_INT 0
77116: PUSH
77117: LD_INT 4
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: PUSH
77124: LD_INT 0
77126: PUSH
77127: LD_INT 3
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PUSH
77134: LD_INT 1
77136: PUSH
77137: LD_INT 4
77139: PUSH
77140: EMPTY
77141: LIST
77142: LIST
77143: PUSH
77144: LD_INT 1
77146: PUSH
77147: LD_INT 5
77149: PUSH
77150: EMPTY
77151: LIST
77152: LIST
77153: PUSH
77154: LD_INT 0
77156: PUSH
77157: LD_INT 5
77159: PUSH
77160: EMPTY
77161: LIST
77162: LIST
77163: PUSH
77164: LD_INT 1
77166: NEG
77167: PUSH
77168: LD_INT 4
77170: PUSH
77171: EMPTY
77172: LIST
77173: LIST
77174: PUSH
77175: LD_INT 1
77177: NEG
77178: PUSH
77179: LD_INT 3
77181: PUSH
77182: EMPTY
77183: LIST
77184: LIST
77185: PUSH
77186: LD_INT 2
77188: PUSH
77189: LD_INT 5
77191: PUSH
77192: EMPTY
77193: LIST
77194: LIST
77195: PUSH
77196: LD_INT 2
77198: NEG
77199: PUSH
77200: LD_INT 3
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PUSH
77207: LD_INT 3
77209: NEG
77210: PUSH
77211: LD_INT 0
77213: PUSH
77214: EMPTY
77215: LIST
77216: LIST
77217: PUSH
77218: LD_INT 3
77220: NEG
77221: PUSH
77222: LD_INT 1
77224: NEG
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: PUSH
77230: LD_INT 2
77232: NEG
77233: PUSH
77234: LD_INT 0
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: PUSH
77241: LD_INT 2
77243: NEG
77244: PUSH
77245: LD_INT 1
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 3
77254: NEG
77255: PUSH
77256: LD_INT 1
77258: PUSH
77259: EMPTY
77260: LIST
77261: LIST
77262: PUSH
77263: LD_INT 4
77265: NEG
77266: PUSH
77267: LD_INT 0
77269: PUSH
77270: EMPTY
77271: LIST
77272: LIST
77273: PUSH
77274: LD_INT 4
77276: NEG
77277: PUSH
77278: LD_INT 1
77280: NEG
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 4
77288: NEG
77289: PUSH
77290: LD_INT 2
77292: NEG
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: PUSH
77298: LD_INT 2
77300: NEG
77301: PUSH
77302: LD_INT 2
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: PUSH
77309: LD_INT 4
77311: NEG
77312: PUSH
77313: LD_INT 4
77315: NEG
77316: PUSH
77317: EMPTY
77318: LIST
77319: LIST
77320: PUSH
77321: LD_INT 4
77323: NEG
77324: PUSH
77325: LD_INT 5
77327: NEG
77328: PUSH
77329: EMPTY
77330: LIST
77331: LIST
77332: PUSH
77333: LD_INT 3
77335: NEG
77336: PUSH
77337: LD_INT 4
77339: NEG
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PUSH
77345: LD_INT 3
77347: NEG
77348: PUSH
77349: LD_INT 3
77351: NEG
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: PUSH
77357: LD_INT 4
77359: NEG
77360: PUSH
77361: LD_INT 3
77363: NEG
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PUSH
77369: LD_INT 5
77371: NEG
77372: PUSH
77373: LD_INT 4
77375: NEG
77376: PUSH
77377: EMPTY
77378: LIST
77379: LIST
77380: PUSH
77381: LD_INT 5
77383: NEG
77384: PUSH
77385: LD_INT 5
77387: NEG
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: PUSH
77393: LD_INT 3
77395: NEG
77396: PUSH
77397: LD_INT 5
77399: NEG
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: PUSH
77405: LD_INT 5
77407: NEG
77408: PUSH
77409: LD_INT 3
77411: NEG
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: LIST
77421: LIST
77422: LIST
77423: LIST
77424: LIST
77425: LIST
77426: LIST
77427: LIST
77428: LIST
77429: LIST
77430: LIST
77431: LIST
77432: LIST
77433: LIST
77434: LIST
77435: LIST
77436: LIST
77437: LIST
77438: LIST
77439: LIST
77440: LIST
77441: LIST
77442: LIST
77443: LIST
77444: LIST
77445: LIST
77446: LIST
77447: LIST
77448: LIST
77449: LIST
77450: LIST
77451: LIST
77452: LIST
77453: LIST
77454: LIST
77455: LIST
77456: LIST
77457: LIST
77458: LIST
77459: LIST
77460: LIST
77461: LIST
77462: LIST
77463: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77464: LD_ADDR_VAR 0 30
77468: PUSH
77469: LD_INT 4
77471: PUSH
77472: LD_INT 4
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: LD_INT 4
77481: PUSH
77482: LD_INT 3
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PUSH
77489: LD_INT 5
77491: PUSH
77492: LD_INT 4
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: PUSH
77499: LD_INT 5
77501: PUSH
77502: LD_INT 5
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: PUSH
77509: LD_INT 4
77511: PUSH
77512: LD_INT 5
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PUSH
77519: LD_INT 3
77521: PUSH
77522: LD_INT 4
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: PUSH
77529: LD_INT 3
77531: PUSH
77532: LD_INT 3
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: PUSH
77539: LD_INT 5
77541: PUSH
77542: LD_INT 3
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: PUSH
77549: LD_INT 3
77551: PUSH
77552: LD_INT 5
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 0
77561: PUSH
77562: LD_INT 3
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: LD_INT 0
77571: PUSH
77572: LD_INT 2
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: PUSH
77579: LD_INT 1
77581: PUSH
77582: LD_INT 3
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: PUSH
77589: LD_INT 1
77591: PUSH
77592: LD_INT 4
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: PUSH
77599: LD_INT 0
77601: PUSH
77602: LD_INT 4
77604: PUSH
77605: EMPTY
77606: LIST
77607: LIST
77608: PUSH
77609: LD_INT 1
77611: NEG
77612: PUSH
77613: LD_INT 3
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: PUSH
77620: LD_INT 1
77622: NEG
77623: PUSH
77624: LD_INT 2
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: LD_INT 2
77633: PUSH
77634: LD_INT 4
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PUSH
77641: LD_INT 2
77643: NEG
77644: PUSH
77645: LD_INT 2
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: PUSH
77652: LD_INT 4
77654: NEG
77655: PUSH
77656: LD_INT 0
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: PUSH
77663: LD_INT 4
77665: NEG
77666: PUSH
77667: LD_INT 1
77669: NEG
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: PUSH
77675: LD_INT 3
77677: NEG
77678: PUSH
77679: LD_INT 0
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: LD_INT 3
77688: NEG
77689: PUSH
77690: LD_INT 1
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: PUSH
77697: LD_INT 4
77699: NEG
77700: PUSH
77701: LD_INT 1
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PUSH
77708: LD_INT 5
77710: NEG
77711: PUSH
77712: LD_INT 0
77714: PUSH
77715: EMPTY
77716: LIST
77717: LIST
77718: PUSH
77719: LD_INT 5
77721: NEG
77722: PUSH
77723: LD_INT 1
77725: NEG
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: PUSH
77731: LD_INT 5
77733: NEG
77734: PUSH
77735: LD_INT 2
77737: NEG
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: PUSH
77743: LD_INT 3
77745: NEG
77746: PUSH
77747: LD_INT 2
77749: PUSH
77750: EMPTY
77751: LIST
77752: LIST
77753: PUSH
77754: LD_INT 3
77756: NEG
77757: PUSH
77758: LD_INT 3
77760: NEG
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: LD_INT 3
77768: NEG
77769: PUSH
77770: LD_INT 4
77772: NEG
77773: PUSH
77774: EMPTY
77775: LIST
77776: LIST
77777: PUSH
77778: LD_INT 2
77780: NEG
77781: PUSH
77782: LD_INT 3
77784: NEG
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 2
77792: NEG
77793: PUSH
77794: LD_INT 2
77796: NEG
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: LD_INT 3
77804: NEG
77805: PUSH
77806: LD_INT 2
77808: NEG
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: PUSH
77814: LD_INT 4
77816: NEG
77817: PUSH
77818: LD_INT 3
77820: NEG
77821: PUSH
77822: EMPTY
77823: LIST
77824: LIST
77825: PUSH
77826: LD_INT 4
77828: NEG
77829: PUSH
77830: LD_INT 4
77832: NEG
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: PUSH
77838: LD_INT 2
77840: NEG
77841: PUSH
77842: LD_INT 4
77844: NEG
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 4
77852: NEG
77853: PUSH
77854: LD_INT 2
77856: NEG
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: LD_INT 0
77864: PUSH
77865: LD_INT 4
77867: NEG
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: LD_INT 0
77875: PUSH
77876: LD_INT 5
77878: NEG
77879: PUSH
77880: EMPTY
77881: LIST
77882: LIST
77883: PUSH
77884: LD_INT 1
77886: PUSH
77887: LD_INT 4
77889: NEG
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 1
77897: PUSH
77898: LD_INT 3
77900: NEG
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 0
77908: PUSH
77909: LD_INT 3
77911: NEG
77912: PUSH
77913: EMPTY
77914: LIST
77915: LIST
77916: PUSH
77917: LD_INT 1
77919: NEG
77920: PUSH
77921: LD_INT 4
77923: NEG
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 1
77931: NEG
77932: PUSH
77933: LD_INT 5
77935: NEG
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: LD_INT 2
77943: PUSH
77944: LD_INT 3
77946: NEG
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: LD_INT 2
77954: NEG
77955: PUSH
77956: LD_INT 5
77958: NEG
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: EMPTY
77965: LIST
77966: LIST
77967: LIST
77968: LIST
77969: LIST
77970: LIST
77971: LIST
77972: LIST
77973: LIST
77974: LIST
77975: LIST
77976: LIST
77977: LIST
77978: LIST
77979: LIST
77980: LIST
77981: LIST
77982: LIST
77983: LIST
77984: LIST
77985: LIST
77986: LIST
77987: LIST
77988: LIST
77989: LIST
77990: LIST
77991: LIST
77992: LIST
77993: LIST
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78011: LD_ADDR_VAR 0 31
78015: PUSH
78016: LD_INT 0
78018: PUSH
78019: LD_INT 4
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: LD_INT 0
78028: PUSH
78029: LD_INT 3
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: PUSH
78036: LD_INT 1
78038: PUSH
78039: LD_INT 4
78041: PUSH
78042: EMPTY
78043: LIST
78044: LIST
78045: PUSH
78046: LD_INT 1
78048: PUSH
78049: LD_INT 5
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 0
78058: PUSH
78059: LD_INT 5
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: LD_INT 1
78068: NEG
78069: PUSH
78070: LD_INT 4
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: PUSH
78077: LD_INT 1
78079: NEG
78080: PUSH
78081: LD_INT 3
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: LD_INT 2
78090: PUSH
78091: LD_INT 5
78093: PUSH
78094: EMPTY
78095: LIST
78096: LIST
78097: PUSH
78098: LD_INT 2
78100: NEG
78101: PUSH
78102: LD_INT 3
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: PUSH
78109: LD_INT 3
78111: NEG
78112: PUSH
78113: LD_INT 0
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 3
78122: NEG
78123: PUSH
78124: LD_INT 1
78126: NEG
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 2
78134: NEG
78135: PUSH
78136: LD_INT 0
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: PUSH
78143: LD_INT 2
78145: NEG
78146: PUSH
78147: LD_INT 1
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: LD_INT 3
78156: NEG
78157: PUSH
78158: LD_INT 1
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PUSH
78165: LD_INT 4
78167: NEG
78168: PUSH
78169: LD_INT 0
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: PUSH
78176: LD_INT 4
78178: NEG
78179: PUSH
78180: LD_INT 1
78182: NEG
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PUSH
78188: LD_INT 4
78190: NEG
78191: PUSH
78192: LD_INT 2
78194: NEG
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: PUSH
78200: LD_INT 2
78202: NEG
78203: PUSH
78204: LD_INT 2
78206: PUSH
78207: EMPTY
78208: LIST
78209: LIST
78210: PUSH
78211: LD_INT 4
78213: NEG
78214: PUSH
78215: LD_INT 4
78217: NEG
78218: PUSH
78219: EMPTY
78220: LIST
78221: LIST
78222: PUSH
78223: LD_INT 4
78225: NEG
78226: PUSH
78227: LD_INT 5
78229: NEG
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 3
78237: NEG
78238: PUSH
78239: LD_INT 4
78241: NEG
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: PUSH
78247: LD_INT 3
78249: NEG
78250: PUSH
78251: LD_INT 3
78253: NEG
78254: PUSH
78255: EMPTY
78256: LIST
78257: LIST
78258: PUSH
78259: LD_INT 4
78261: NEG
78262: PUSH
78263: LD_INT 3
78265: NEG
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: PUSH
78271: LD_INT 5
78273: NEG
78274: PUSH
78275: LD_INT 4
78277: NEG
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: PUSH
78283: LD_INT 5
78285: NEG
78286: PUSH
78287: LD_INT 5
78289: NEG
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: PUSH
78295: LD_INT 3
78297: NEG
78298: PUSH
78299: LD_INT 5
78301: NEG
78302: PUSH
78303: EMPTY
78304: LIST
78305: LIST
78306: PUSH
78307: LD_INT 5
78309: NEG
78310: PUSH
78311: LD_INT 3
78313: NEG
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 0
78321: PUSH
78322: LD_INT 3
78324: NEG
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: PUSH
78330: LD_INT 0
78332: PUSH
78333: LD_INT 4
78335: NEG
78336: PUSH
78337: EMPTY
78338: LIST
78339: LIST
78340: PUSH
78341: LD_INT 1
78343: PUSH
78344: LD_INT 3
78346: NEG
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 1
78354: PUSH
78355: LD_INT 2
78357: NEG
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 0
78365: PUSH
78366: LD_INT 2
78368: NEG
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 1
78376: NEG
78377: PUSH
78378: LD_INT 3
78380: NEG
78381: PUSH
78382: EMPTY
78383: LIST
78384: LIST
78385: PUSH
78386: LD_INT 1
78388: NEG
78389: PUSH
78390: LD_INT 4
78392: NEG
78393: PUSH
78394: EMPTY
78395: LIST
78396: LIST
78397: PUSH
78398: LD_INT 2
78400: PUSH
78401: LD_INT 2
78403: NEG
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: LD_INT 2
78411: NEG
78412: PUSH
78413: LD_INT 4
78415: NEG
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: PUSH
78421: LD_INT 4
78423: PUSH
78424: LD_INT 0
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: LD_INT 4
78433: PUSH
78434: LD_INT 1
78436: NEG
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 5
78444: PUSH
78445: LD_INT 0
78447: PUSH
78448: EMPTY
78449: LIST
78450: LIST
78451: PUSH
78452: LD_INT 5
78454: PUSH
78455: LD_INT 1
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 4
78464: PUSH
78465: LD_INT 1
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 3
78474: PUSH
78475: LD_INT 0
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 3
78484: PUSH
78485: LD_INT 1
78487: NEG
78488: PUSH
78489: EMPTY
78490: LIST
78491: LIST
78492: PUSH
78493: LD_INT 3
78495: PUSH
78496: LD_INT 2
78498: NEG
78499: PUSH
78500: EMPTY
78501: LIST
78502: LIST
78503: PUSH
78504: LD_INT 5
78506: PUSH
78507: LD_INT 2
78509: PUSH
78510: EMPTY
78511: LIST
78512: LIST
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: LIST
78518: LIST
78519: LIST
78520: LIST
78521: LIST
78522: LIST
78523: LIST
78524: LIST
78525: LIST
78526: LIST
78527: LIST
78528: LIST
78529: LIST
78530: LIST
78531: LIST
78532: LIST
78533: LIST
78534: LIST
78535: LIST
78536: LIST
78537: LIST
78538: LIST
78539: LIST
78540: LIST
78541: LIST
78542: LIST
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: LIST
78552: LIST
78553: LIST
78554: LIST
78555: LIST
78556: LIST
78557: LIST
78558: LIST
78559: LIST
78560: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78561: LD_ADDR_VAR 0 32
78565: PUSH
78566: LD_INT 4
78568: NEG
78569: PUSH
78570: LD_INT 0
78572: PUSH
78573: EMPTY
78574: LIST
78575: LIST
78576: PUSH
78577: LD_INT 4
78579: NEG
78580: PUSH
78581: LD_INT 1
78583: NEG
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: LD_INT 3
78591: NEG
78592: PUSH
78593: LD_INT 0
78595: PUSH
78596: EMPTY
78597: LIST
78598: LIST
78599: PUSH
78600: LD_INT 3
78602: NEG
78603: PUSH
78604: LD_INT 1
78606: PUSH
78607: EMPTY
78608: LIST
78609: LIST
78610: PUSH
78611: LD_INT 4
78613: NEG
78614: PUSH
78615: LD_INT 1
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PUSH
78622: LD_INT 5
78624: NEG
78625: PUSH
78626: LD_INT 0
78628: PUSH
78629: EMPTY
78630: LIST
78631: LIST
78632: PUSH
78633: LD_INT 5
78635: NEG
78636: PUSH
78637: LD_INT 1
78639: NEG
78640: PUSH
78641: EMPTY
78642: LIST
78643: LIST
78644: PUSH
78645: LD_INT 5
78647: NEG
78648: PUSH
78649: LD_INT 2
78651: NEG
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: LD_INT 3
78659: NEG
78660: PUSH
78661: LD_INT 2
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: PUSH
78668: LD_INT 3
78670: NEG
78671: PUSH
78672: LD_INT 3
78674: NEG
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: PUSH
78680: LD_INT 3
78682: NEG
78683: PUSH
78684: LD_INT 4
78686: NEG
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 2
78694: NEG
78695: PUSH
78696: LD_INT 3
78698: NEG
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 2
78706: NEG
78707: PUSH
78708: LD_INT 2
78710: NEG
78711: PUSH
78712: EMPTY
78713: LIST
78714: LIST
78715: PUSH
78716: LD_INT 3
78718: NEG
78719: PUSH
78720: LD_INT 2
78722: NEG
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: PUSH
78728: LD_INT 4
78730: NEG
78731: PUSH
78732: LD_INT 3
78734: NEG
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 4
78742: NEG
78743: PUSH
78744: LD_INT 4
78746: NEG
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 2
78754: NEG
78755: PUSH
78756: LD_INT 4
78758: NEG
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 4
78766: NEG
78767: PUSH
78768: LD_INT 2
78770: NEG
78771: PUSH
78772: EMPTY
78773: LIST
78774: LIST
78775: PUSH
78776: LD_INT 0
78778: PUSH
78779: LD_INT 4
78781: NEG
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 0
78789: PUSH
78790: LD_INT 5
78792: NEG
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 1
78800: PUSH
78801: LD_INT 4
78803: NEG
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: LD_INT 1
78811: PUSH
78812: LD_INT 3
78814: NEG
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 0
78822: PUSH
78823: LD_INT 3
78825: NEG
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: PUSH
78831: LD_INT 1
78833: NEG
78834: PUSH
78835: LD_INT 4
78837: NEG
78838: PUSH
78839: EMPTY
78840: LIST
78841: LIST
78842: PUSH
78843: LD_INT 1
78845: NEG
78846: PUSH
78847: LD_INT 5
78849: NEG
78850: PUSH
78851: EMPTY
78852: LIST
78853: LIST
78854: PUSH
78855: LD_INT 2
78857: PUSH
78858: LD_INT 3
78860: NEG
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: PUSH
78866: LD_INT 2
78868: NEG
78869: PUSH
78870: LD_INT 5
78872: NEG
78873: PUSH
78874: EMPTY
78875: LIST
78876: LIST
78877: PUSH
78878: LD_INT 3
78880: PUSH
78881: LD_INT 0
78883: PUSH
78884: EMPTY
78885: LIST
78886: LIST
78887: PUSH
78888: LD_INT 3
78890: PUSH
78891: LD_INT 1
78893: NEG
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 4
78901: PUSH
78902: LD_INT 0
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: PUSH
78909: LD_INT 4
78911: PUSH
78912: LD_INT 1
78914: PUSH
78915: EMPTY
78916: LIST
78917: LIST
78918: PUSH
78919: LD_INT 3
78921: PUSH
78922: LD_INT 1
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 2
78931: PUSH
78932: LD_INT 0
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: PUSH
78939: LD_INT 2
78941: PUSH
78942: LD_INT 1
78944: NEG
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: LD_INT 2
78952: PUSH
78953: LD_INT 2
78955: NEG
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 4
78963: PUSH
78964: LD_INT 2
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: PUSH
78971: LD_INT 4
78973: PUSH
78974: LD_INT 4
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: LD_INT 4
78983: PUSH
78984: LD_INT 3
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PUSH
78991: LD_INT 5
78993: PUSH
78994: LD_INT 4
78996: PUSH
78997: EMPTY
78998: LIST
78999: LIST
79000: PUSH
79001: LD_INT 5
79003: PUSH
79004: LD_INT 5
79006: PUSH
79007: EMPTY
79008: LIST
79009: LIST
79010: PUSH
79011: LD_INT 4
79013: PUSH
79014: LD_INT 5
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 3
79023: PUSH
79024: LD_INT 4
79026: PUSH
79027: EMPTY
79028: LIST
79029: LIST
79030: PUSH
79031: LD_INT 3
79033: PUSH
79034: LD_INT 3
79036: PUSH
79037: EMPTY
79038: LIST
79039: LIST
79040: PUSH
79041: LD_INT 5
79043: PUSH
79044: LD_INT 3
79046: PUSH
79047: EMPTY
79048: LIST
79049: LIST
79050: PUSH
79051: LD_INT 3
79053: PUSH
79054: LD_INT 5
79056: PUSH
79057: EMPTY
79058: LIST
79059: LIST
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: LIST
79065: LIST
79066: LIST
79067: LIST
79068: LIST
79069: LIST
79070: LIST
79071: LIST
79072: LIST
79073: LIST
79074: LIST
79075: LIST
79076: LIST
79077: LIST
79078: LIST
79079: LIST
79080: LIST
79081: LIST
79082: LIST
79083: LIST
79084: LIST
79085: LIST
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: LIST
79092: LIST
79093: LIST
79094: LIST
79095: LIST
79096: LIST
79097: LIST
79098: LIST
79099: LIST
79100: LIST
79101: LIST
79102: LIST
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79108: LD_ADDR_VAR 0 33
79112: PUSH
79113: LD_INT 4
79115: NEG
79116: PUSH
79117: LD_INT 4
79119: NEG
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: PUSH
79125: LD_INT 4
79127: NEG
79128: PUSH
79129: LD_INT 5
79131: NEG
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 3
79139: NEG
79140: PUSH
79141: LD_INT 4
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 3
79151: NEG
79152: PUSH
79153: LD_INT 3
79155: NEG
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 4
79163: NEG
79164: PUSH
79165: LD_INT 3
79167: NEG
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: LD_INT 5
79175: NEG
79176: PUSH
79177: LD_INT 4
79179: NEG
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: LD_INT 5
79187: NEG
79188: PUSH
79189: LD_INT 5
79191: NEG
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: PUSH
79197: LD_INT 3
79199: NEG
79200: PUSH
79201: LD_INT 5
79203: NEG
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: PUSH
79209: LD_INT 5
79211: NEG
79212: PUSH
79213: LD_INT 3
79215: NEG
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: PUSH
79221: LD_INT 0
79223: PUSH
79224: LD_INT 3
79226: NEG
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 0
79234: PUSH
79235: LD_INT 4
79237: NEG
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 1
79245: PUSH
79246: LD_INT 3
79248: NEG
79249: PUSH
79250: EMPTY
79251: LIST
79252: LIST
79253: PUSH
79254: LD_INT 1
79256: PUSH
79257: LD_INT 2
79259: NEG
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PUSH
79265: LD_INT 0
79267: PUSH
79268: LD_INT 2
79270: NEG
79271: PUSH
79272: EMPTY
79273: LIST
79274: LIST
79275: PUSH
79276: LD_INT 1
79278: NEG
79279: PUSH
79280: LD_INT 3
79282: NEG
79283: PUSH
79284: EMPTY
79285: LIST
79286: LIST
79287: PUSH
79288: LD_INT 1
79290: NEG
79291: PUSH
79292: LD_INT 4
79294: NEG
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 2
79302: PUSH
79303: LD_INT 2
79305: NEG
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PUSH
79311: LD_INT 2
79313: NEG
79314: PUSH
79315: LD_INT 4
79317: NEG
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: PUSH
79323: LD_INT 4
79325: PUSH
79326: LD_INT 0
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: LD_INT 4
79335: PUSH
79336: LD_INT 1
79338: NEG
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 5
79346: PUSH
79347: LD_INT 0
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 5
79356: PUSH
79357: LD_INT 1
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 4
79366: PUSH
79367: LD_INT 1
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 3
79376: PUSH
79377: LD_INT 0
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: PUSH
79384: LD_INT 3
79386: PUSH
79387: LD_INT 1
79389: NEG
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: LD_INT 3
79397: PUSH
79398: LD_INT 2
79400: NEG
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 5
79408: PUSH
79409: LD_INT 2
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 3
79418: PUSH
79419: LD_INT 3
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 3
79428: PUSH
79429: LD_INT 2
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: LD_INT 4
79438: PUSH
79439: LD_INT 3
79441: PUSH
79442: EMPTY
79443: LIST
79444: LIST
79445: PUSH
79446: LD_INT 4
79448: PUSH
79449: LD_INT 4
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PUSH
79456: LD_INT 3
79458: PUSH
79459: LD_INT 4
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: PUSH
79466: LD_INT 2
79468: PUSH
79469: LD_INT 3
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 2
79478: PUSH
79479: LD_INT 2
79481: PUSH
79482: EMPTY
79483: LIST
79484: LIST
79485: PUSH
79486: LD_INT 4
79488: PUSH
79489: LD_INT 2
79491: PUSH
79492: EMPTY
79493: LIST
79494: LIST
79495: PUSH
79496: LD_INT 2
79498: PUSH
79499: LD_INT 4
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: LD_INT 0
79508: PUSH
79509: LD_INT 4
79511: PUSH
79512: EMPTY
79513: LIST
79514: LIST
79515: PUSH
79516: LD_INT 0
79518: PUSH
79519: LD_INT 3
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: PUSH
79526: LD_INT 1
79528: PUSH
79529: LD_INT 4
79531: PUSH
79532: EMPTY
79533: LIST
79534: LIST
79535: PUSH
79536: LD_INT 1
79538: PUSH
79539: LD_INT 5
79541: PUSH
79542: EMPTY
79543: LIST
79544: LIST
79545: PUSH
79546: LD_INT 0
79548: PUSH
79549: LD_INT 5
79551: PUSH
79552: EMPTY
79553: LIST
79554: LIST
79555: PUSH
79556: LD_INT 1
79558: NEG
79559: PUSH
79560: LD_INT 4
79562: PUSH
79563: EMPTY
79564: LIST
79565: LIST
79566: PUSH
79567: LD_INT 1
79569: NEG
79570: PUSH
79571: LD_INT 3
79573: PUSH
79574: EMPTY
79575: LIST
79576: LIST
79577: PUSH
79578: LD_INT 2
79580: PUSH
79581: LD_INT 5
79583: PUSH
79584: EMPTY
79585: LIST
79586: LIST
79587: PUSH
79588: LD_INT 2
79590: NEG
79591: PUSH
79592: LD_INT 3
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: LIST
79608: LIST
79609: LIST
79610: LIST
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: LIST
79623: LIST
79624: LIST
79625: LIST
79626: LIST
79627: LIST
79628: LIST
79629: LIST
79630: LIST
79631: LIST
79632: LIST
79633: LIST
79634: LIST
79635: LIST
79636: LIST
79637: LIST
79638: LIST
79639: LIST
79640: LIST
79641: LIST
79642: LIST
79643: LIST
79644: LIST
79645: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79646: LD_ADDR_VAR 0 34
79650: PUSH
79651: LD_INT 0
79653: PUSH
79654: LD_INT 4
79656: NEG
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PUSH
79662: LD_INT 0
79664: PUSH
79665: LD_INT 5
79667: NEG
79668: PUSH
79669: EMPTY
79670: LIST
79671: LIST
79672: PUSH
79673: LD_INT 1
79675: PUSH
79676: LD_INT 4
79678: NEG
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 1
79686: PUSH
79687: LD_INT 3
79689: NEG
79690: PUSH
79691: EMPTY
79692: LIST
79693: LIST
79694: PUSH
79695: LD_INT 0
79697: PUSH
79698: LD_INT 3
79700: NEG
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 1
79708: NEG
79709: PUSH
79710: LD_INT 4
79712: NEG
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 1
79720: NEG
79721: PUSH
79722: LD_INT 5
79724: NEG
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: PUSH
79730: LD_INT 2
79732: PUSH
79733: LD_INT 3
79735: NEG
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PUSH
79741: LD_INT 2
79743: NEG
79744: PUSH
79745: LD_INT 5
79747: NEG
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: LD_INT 3
79755: PUSH
79756: LD_INT 0
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: PUSH
79763: LD_INT 3
79765: PUSH
79766: LD_INT 1
79768: NEG
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: LD_INT 4
79776: PUSH
79777: LD_INT 0
79779: PUSH
79780: EMPTY
79781: LIST
79782: LIST
79783: PUSH
79784: LD_INT 4
79786: PUSH
79787: LD_INT 1
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: PUSH
79794: LD_INT 3
79796: PUSH
79797: LD_INT 1
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: PUSH
79804: LD_INT 2
79806: PUSH
79807: LD_INT 0
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: PUSH
79814: LD_INT 2
79816: PUSH
79817: LD_INT 1
79819: NEG
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: PUSH
79825: LD_INT 2
79827: PUSH
79828: LD_INT 2
79830: NEG
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 4
79838: PUSH
79839: LD_INT 2
79841: PUSH
79842: EMPTY
79843: LIST
79844: LIST
79845: PUSH
79846: LD_INT 4
79848: PUSH
79849: LD_INT 4
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: LD_INT 4
79858: PUSH
79859: LD_INT 3
79861: PUSH
79862: EMPTY
79863: LIST
79864: LIST
79865: PUSH
79866: LD_INT 5
79868: PUSH
79869: LD_INT 4
79871: PUSH
79872: EMPTY
79873: LIST
79874: LIST
79875: PUSH
79876: LD_INT 5
79878: PUSH
79879: LD_INT 5
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 4
79888: PUSH
79889: LD_INT 5
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 3
79898: PUSH
79899: LD_INT 4
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 3
79908: PUSH
79909: LD_INT 3
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: LD_INT 5
79918: PUSH
79919: LD_INT 3
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 3
79928: PUSH
79929: LD_INT 5
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 0
79938: PUSH
79939: LD_INT 3
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: PUSH
79946: LD_INT 0
79948: PUSH
79949: LD_INT 2
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 1
79958: PUSH
79959: LD_INT 3
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: PUSH
79966: LD_INT 1
79968: PUSH
79969: LD_INT 4
79971: PUSH
79972: EMPTY
79973: LIST
79974: LIST
79975: PUSH
79976: LD_INT 0
79978: PUSH
79979: LD_INT 4
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: PUSH
79986: LD_INT 1
79988: NEG
79989: PUSH
79990: LD_INT 3
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 1
79999: NEG
80000: PUSH
80001: LD_INT 2
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: PUSH
80008: LD_INT 2
80010: PUSH
80011: LD_INT 4
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: LD_INT 2
80020: NEG
80021: PUSH
80022: LD_INT 2
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 4
80031: NEG
80032: PUSH
80033: LD_INT 0
80035: PUSH
80036: EMPTY
80037: LIST
80038: LIST
80039: PUSH
80040: LD_INT 4
80042: NEG
80043: PUSH
80044: LD_INT 1
80046: NEG
80047: PUSH
80048: EMPTY
80049: LIST
80050: LIST
80051: PUSH
80052: LD_INT 3
80054: NEG
80055: PUSH
80056: LD_INT 0
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 3
80065: NEG
80066: PUSH
80067: LD_INT 1
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 4
80076: NEG
80077: PUSH
80078: LD_INT 1
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 5
80087: NEG
80088: PUSH
80089: LD_INT 0
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: PUSH
80096: LD_INT 5
80098: NEG
80099: PUSH
80100: LD_INT 1
80102: NEG
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 5
80110: NEG
80111: PUSH
80112: LD_INT 2
80114: NEG
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 3
80122: NEG
80123: PUSH
80124: LD_INT 2
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: EMPTY
80132: LIST
80133: LIST
80134: LIST
80135: LIST
80136: LIST
80137: LIST
80138: LIST
80139: LIST
80140: LIST
80141: LIST
80142: LIST
80143: LIST
80144: LIST
80145: LIST
80146: LIST
80147: LIST
80148: LIST
80149: LIST
80150: LIST
80151: LIST
80152: LIST
80153: LIST
80154: LIST
80155: LIST
80156: LIST
80157: LIST
80158: LIST
80159: LIST
80160: LIST
80161: LIST
80162: LIST
80163: LIST
80164: LIST
80165: LIST
80166: LIST
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: LIST
80175: LIST
80176: LIST
80177: ST_TO_ADDR
// end ; end ;
80178: GO 80181
80180: POP
// case btype of b_depot , b_warehouse :
80181: LD_VAR 0 1
80185: PUSH
80186: LD_INT 0
80188: DOUBLE
80189: EQUAL
80190: IFTRUE 80200
80192: LD_INT 1
80194: DOUBLE
80195: EQUAL
80196: IFTRUE 80200
80198: GO 80401
80200: POP
// case nation of nation_american :
80201: LD_VAR 0 5
80205: PUSH
80206: LD_INT 1
80208: DOUBLE
80209: EQUAL
80210: IFTRUE 80214
80212: GO 80270
80214: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80215: LD_ADDR_VAR 0 9
80219: PUSH
80220: LD_VAR 0 11
80224: PUSH
80225: LD_VAR 0 12
80229: PUSH
80230: LD_VAR 0 13
80234: PUSH
80235: LD_VAR 0 14
80239: PUSH
80240: LD_VAR 0 15
80244: PUSH
80245: LD_VAR 0 16
80249: PUSH
80250: EMPTY
80251: LIST
80252: LIST
80253: LIST
80254: LIST
80255: LIST
80256: LIST
80257: PUSH
80258: LD_VAR 0 4
80262: PUSH
80263: LD_INT 1
80265: PLUS
80266: ARRAY
80267: ST_TO_ADDR
80268: GO 80399
80270: LD_INT 2
80272: DOUBLE
80273: EQUAL
80274: IFTRUE 80278
80276: GO 80334
80278: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80279: LD_ADDR_VAR 0 9
80283: PUSH
80284: LD_VAR 0 17
80288: PUSH
80289: LD_VAR 0 18
80293: PUSH
80294: LD_VAR 0 19
80298: PUSH
80299: LD_VAR 0 20
80303: PUSH
80304: LD_VAR 0 21
80308: PUSH
80309: LD_VAR 0 22
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: LIST
80318: LIST
80319: LIST
80320: LIST
80321: PUSH
80322: LD_VAR 0 4
80326: PUSH
80327: LD_INT 1
80329: PLUS
80330: ARRAY
80331: ST_TO_ADDR
80332: GO 80399
80334: LD_INT 3
80336: DOUBLE
80337: EQUAL
80338: IFTRUE 80342
80340: GO 80398
80342: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80343: LD_ADDR_VAR 0 9
80347: PUSH
80348: LD_VAR 0 23
80352: PUSH
80353: LD_VAR 0 24
80357: PUSH
80358: LD_VAR 0 25
80362: PUSH
80363: LD_VAR 0 26
80367: PUSH
80368: LD_VAR 0 27
80372: PUSH
80373: LD_VAR 0 28
80377: PUSH
80378: EMPTY
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: PUSH
80386: LD_VAR 0 4
80390: PUSH
80391: LD_INT 1
80393: PLUS
80394: ARRAY
80395: ST_TO_ADDR
80396: GO 80399
80398: POP
80399: GO 80954
80401: LD_INT 2
80403: DOUBLE
80404: EQUAL
80405: IFTRUE 80415
80407: LD_INT 3
80409: DOUBLE
80410: EQUAL
80411: IFTRUE 80415
80413: GO 80471
80415: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80416: LD_ADDR_VAR 0 9
80420: PUSH
80421: LD_VAR 0 29
80425: PUSH
80426: LD_VAR 0 30
80430: PUSH
80431: LD_VAR 0 31
80435: PUSH
80436: LD_VAR 0 32
80440: PUSH
80441: LD_VAR 0 33
80445: PUSH
80446: LD_VAR 0 34
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: LIST
80458: PUSH
80459: LD_VAR 0 4
80463: PUSH
80464: LD_INT 1
80466: PLUS
80467: ARRAY
80468: ST_TO_ADDR
80469: GO 80954
80471: LD_INT 16
80473: DOUBLE
80474: EQUAL
80475: IFTRUE 80533
80477: LD_INT 17
80479: DOUBLE
80480: EQUAL
80481: IFTRUE 80533
80483: LD_INT 18
80485: DOUBLE
80486: EQUAL
80487: IFTRUE 80533
80489: LD_INT 19
80491: DOUBLE
80492: EQUAL
80493: IFTRUE 80533
80495: LD_INT 22
80497: DOUBLE
80498: EQUAL
80499: IFTRUE 80533
80501: LD_INT 20
80503: DOUBLE
80504: EQUAL
80505: IFTRUE 80533
80507: LD_INT 21
80509: DOUBLE
80510: EQUAL
80511: IFTRUE 80533
80513: LD_INT 23
80515: DOUBLE
80516: EQUAL
80517: IFTRUE 80533
80519: LD_INT 24
80521: DOUBLE
80522: EQUAL
80523: IFTRUE 80533
80525: LD_INT 25
80527: DOUBLE
80528: EQUAL
80529: IFTRUE 80533
80531: GO 80589
80533: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80534: LD_ADDR_VAR 0 9
80538: PUSH
80539: LD_VAR 0 35
80543: PUSH
80544: LD_VAR 0 36
80548: PUSH
80549: LD_VAR 0 37
80553: PUSH
80554: LD_VAR 0 38
80558: PUSH
80559: LD_VAR 0 39
80563: PUSH
80564: LD_VAR 0 40
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: PUSH
80577: LD_VAR 0 4
80581: PUSH
80582: LD_INT 1
80584: PLUS
80585: ARRAY
80586: ST_TO_ADDR
80587: GO 80954
80589: LD_INT 6
80591: DOUBLE
80592: EQUAL
80593: IFTRUE 80645
80595: LD_INT 7
80597: DOUBLE
80598: EQUAL
80599: IFTRUE 80645
80601: LD_INT 8
80603: DOUBLE
80604: EQUAL
80605: IFTRUE 80645
80607: LD_INT 13
80609: DOUBLE
80610: EQUAL
80611: IFTRUE 80645
80613: LD_INT 12
80615: DOUBLE
80616: EQUAL
80617: IFTRUE 80645
80619: LD_INT 15
80621: DOUBLE
80622: EQUAL
80623: IFTRUE 80645
80625: LD_INT 11
80627: DOUBLE
80628: EQUAL
80629: IFTRUE 80645
80631: LD_INT 14
80633: DOUBLE
80634: EQUAL
80635: IFTRUE 80645
80637: LD_INT 10
80639: DOUBLE
80640: EQUAL
80641: IFTRUE 80645
80643: GO 80701
80645: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80646: LD_ADDR_VAR 0 9
80650: PUSH
80651: LD_VAR 0 41
80655: PUSH
80656: LD_VAR 0 42
80660: PUSH
80661: LD_VAR 0 43
80665: PUSH
80666: LD_VAR 0 44
80670: PUSH
80671: LD_VAR 0 45
80675: PUSH
80676: LD_VAR 0 46
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: LIST
80685: LIST
80686: LIST
80687: LIST
80688: PUSH
80689: LD_VAR 0 4
80693: PUSH
80694: LD_INT 1
80696: PLUS
80697: ARRAY
80698: ST_TO_ADDR
80699: GO 80954
80701: LD_INT 36
80703: DOUBLE
80704: EQUAL
80705: IFTRUE 80709
80707: GO 80765
80709: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80710: LD_ADDR_VAR 0 9
80714: PUSH
80715: LD_VAR 0 47
80719: PUSH
80720: LD_VAR 0 48
80724: PUSH
80725: LD_VAR 0 49
80729: PUSH
80730: LD_VAR 0 50
80734: PUSH
80735: LD_VAR 0 51
80739: PUSH
80740: LD_VAR 0 52
80744: PUSH
80745: EMPTY
80746: LIST
80747: LIST
80748: LIST
80749: LIST
80750: LIST
80751: LIST
80752: PUSH
80753: LD_VAR 0 4
80757: PUSH
80758: LD_INT 1
80760: PLUS
80761: ARRAY
80762: ST_TO_ADDR
80763: GO 80954
80765: LD_INT 4
80767: DOUBLE
80768: EQUAL
80769: IFTRUE 80791
80771: LD_INT 5
80773: DOUBLE
80774: EQUAL
80775: IFTRUE 80791
80777: LD_INT 34
80779: DOUBLE
80780: EQUAL
80781: IFTRUE 80791
80783: LD_INT 37
80785: DOUBLE
80786: EQUAL
80787: IFTRUE 80791
80789: GO 80847
80791: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
80792: LD_ADDR_VAR 0 9
80796: PUSH
80797: LD_VAR 0 53
80801: PUSH
80802: LD_VAR 0 54
80806: PUSH
80807: LD_VAR 0 55
80811: PUSH
80812: LD_VAR 0 56
80816: PUSH
80817: LD_VAR 0 57
80821: PUSH
80822: LD_VAR 0 58
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: LIST
80831: LIST
80832: LIST
80833: LIST
80834: PUSH
80835: LD_VAR 0 4
80839: PUSH
80840: LD_INT 1
80842: PLUS
80843: ARRAY
80844: ST_TO_ADDR
80845: GO 80954
80847: LD_INT 31
80849: DOUBLE
80850: EQUAL
80851: IFTRUE 80897
80853: LD_INT 32
80855: DOUBLE
80856: EQUAL
80857: IFTRUE 80897
80859: LD_INT 33
80861: DOUBLE
80862: EQUAL
80863: IFTRUE 80897
80865: LD_INT 27
80867: DOUBLE
80868: EQUAL
80869: IFTRUE 80897
80871: LD_INT 26
80873: DOUBLE
80874: EQUAL
80875: IFTRUE 80897
80877: LD_INT 28
80879: DOUBLE
80880: EQUAL
80881: IFTRUE 80897
80883: LD_INT 29
80885: DOUBLE
80886: EQUAL
80887: IFTRUE 80897
80889: LD_INT 30
80891: DOUBLE
80892: EQUAL
80893: IFTRUE 80897
80895: GO 80953
80897: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
80898: LD_ADDR_VAR 0 9
80902: PUSH
80903: LD_VAR 0 59
80907: PUSH
80908: LD_VAR 0 60
80912: PUSH
80913: LD_VAR 0 61
80917: PUSH
80918: LD_VAR 0 62
80922: PUSH
80923: LD_VAR 0 63
80927: PUSH
80928: LD_VAR 0 64
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: PUSH
80941: LD_VAR 0 4
80945: PUSH
80946: LD_INT 1
80948: PLUS
80949: ARRAY
80950: ST_TO_ADDR
80951: GO 80954
80953: POP
// temp_list2 = [ ] ;
80954: LD_ADDR_VAR 0 10
80958: PUSH
80959: EMPTY
80960: ST_TO_ADDR
// for i in temp_list do
80961: LD_ADDR_VAR 0 8
80965: PUSH
80966: LD_VAR 0 9
80970: PUSH
80971: FOR_IN
80972: IFFALSE 81024
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
80974: LD_ADDR_VAR 0 10
80978: PUSH
80979: LD_VAR 0 10
80983: PUSH
80984: LD_VAR 0 8
80988: PUSH
80989: LD_INT 1
80991: ARRAY
80992: PUSH
80993: LD_VAR 0 2
80997: PLUS
80998: PUSH
80999: LD_VAR 0 8
81003: PUSH
81004: LD_INT 2
81006: ARRAY
81007: PUSH
81008: LD_VAR 0 3
81012: PLUS
81013: PUSH
81014: EMPTY
81015: LIST
81016: LIST
81017: PUSH
81018: EMPTY
81019: LIST
81020: ADD
81021: ST_TO_ADDR
81022: GO 80971
81024: POP
81025: POP
// result = temp_list2 ;
81026: LD_ADDR_VAR 0 7
81030: PUSH
81031: LD_VAR 0 10
81035: ST_TO_ADDR
// end ;
81036: LD_VAR 0 7
81040: RET
// export function EnemyInRange ( unit , dist ) ; begin
81041: LD_INT 0
81043: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81044: LD_ADDR_VAR 0 3
81048: PUSH
81049: LD_VAR 0 1
81053: PPUSH
81054: CALL_OW 255
81058: PPUSH
81059: LD_VAR 0 1
81063: PPUSH
81064: CALL_OW 250
81068: PPUSH
81069: LD_VAR 0 1
81073: PPUSH
81074: CALL_OW 251
81078: PPUSH
81079: LD_VAR 0 2
81083: PPUSH
81084: CALL 54437 0 4
81088: PUSH
81089: LD_INT 4
81091: ARRAY
81092: ST_TO_ADDR
// end ;
81093: LD_VAR 0 3
81097: RET
// export function PlayerSeeMe ( unit ) ; begin
81098: LD_INT 0
81100: PPUSH
// result := See ( your_side , unit ) ;
81101: LD_ADDR_VAR 0 2
81105: PUSH
81106: LD_OWVAR 2
81110: PPUSH
81111: LD_VAR 0 1
81115: PPUSH
81116: CALL_OW 292
81120: ST_TO_ADDR
// end ;
81121: LD_VAR 0 2
81125: RET
// export function ReverseDir ( unit ) ; begin
81126: LD_INT 0
81128: PPUSH
// if not unit then
81129: LD_VAR 0 1
81133: NOT
81134: IFFALSE 81138
// exit ;
81136: GO 81161
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81138: LD_ADDR_VAR 0 2
81142: PUSH
81143: LD_VAR 0 1
81147: PPUSH
81148: CALL_OW 254
81152: PUSH
81153: LD_INT 3
81155: PLUS
81156: PUSH
81157: LD_INT 6
81159: MOD
81160: ST_TO_ADDR
// end ;
81161: LD_VAR 0 2
81165: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
81166: LD_INT 0
81168: PPUSH
81169: PPUSH
81170: PPUSH
81171: PPUSH
81172: PPUSH
// if not hexes then
81173: LD_VAR 0 2
81177: NOT
81178: IFFALSE 81182
// exit ;
81180: GO 81330
// dist := 9999 ;
81182: LD_ADDR_VAR 0 5
81186: PUSH
81187: LD_INT 9999
81189: ST_TO_ADDR
// for i = 1 to hexes do
81190: LD_ADDR_VAR 0 4
81194: PUSH
81195: DOUBLE
81196: LD_INT 1
81198: DEC
81199: ST_TO_ADDR
81200: LD_VAR 0 2
81204: PUSH
81205: FOR_TO
81206: IFFALSE 81318
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
81208: LD_VAR 0 1
81212: PPUSH
81213: LD_VAR 0 2
81217: PUSH
81218: LD_VAR 0 4
81222: ARRAY
81223: PUSH
81224: LD_INT 1
81226: ARRAY
81227: PPUSH
81228: LD_VAR 0 2
81232: PUSH
81233: LD_VAR 0 4
81237: ARRAY
81238: PUSH
81239: LD_INT 2
81241: ARRAY
81242: PPUSH
81243: CALL_OW 297
81247: PUSH
81248: LD_VAR 0 5
81252: LESS
81253: IFFALSE 81316
// begin hex := hexes [ i ] ;
81255: LD_ADDR_VAR 0 7
81259: PUSH
81260: LD_VAR 0 2
81264: PUSH
81265: LD_VAR 0 4
81269: ARRAY
81270: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81271: LD_ADDR_VAR 0 5
81275: PUSH
81276: LD_VAR 0 1
81280: PPUSH
81281: LD_VAR 0 2
81285: PUSH
81286: LD_VAR 0 4
81290: ARRAY
81291: PUSH
81292: LD_INT 1
81294: ARRAY
81295: PPUSH
81296: LD_VAR 0 2
81300: PUSH
81301: LD_VAR 0 4
81305: ARRAY
81306: PUSH
81307: LD_INT 2
81309: ARRAY
81310: PPUSH
81311: CALL_OW 297
81315: ST_TO_ADDR
// end ; end ;
81316: GO 81205
81318: POP
81319: POP
// result := hex ;
81320: LD_ADDR_VAR 0 3
81324: PUSH
81325: LD_VAR 0 7
81329: ST_TO_ADDR
// end ;
81330: LD_VAR 0 3
81334: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81335: LD_INT 0
81337: PPUSH
81338: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81339: LD_VAR 0 1
81343: NOT
81344: PUSH
81345: LD_VAR 0 1
81349: PUSH
81350: LD_INT 21
81352: PUSH
81353: LD_INT 2
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 23
81362: PUSH
81363: LD_INT 2
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: EMPTY
81371: LIST
81372: LIST
81373: PPUSH
81374: CALL_OW 69
81378: IN
81379: NOT
81380: OR
81381: IFFALSE 81385
// exit ;
81383: GO 81432
// for i = 1 to 3 do
81385: LD_ADDR_VAR 0 3
81389: PUSH
81390: DOUBLE
81391: LD_INT 1
81393: DEC
81394: ST_TO_ADDR
81395: LD_INT 3
81397: PUSH
81398: FOR_TO
81399: IFFALSE 81430
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81401: LD_VAR 0 1
81405: PPUSH
81406: CALL_OW 250
81410: PPUSH
81411: LD_VAR 0 1
81415: PPUSH
81416: CALL_OW 251
81420: PPUSH
81421: LD_INT 1
81423: PPUSH
81424: CALL_OW 453
81428: GO 81398
81430: POP
81431: POP
// end ;
81432: LD_VAR 0 2
81436: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81437: LD_INT 0
81439: PPUSH
81440: PPUSH
81441: PPUSH
81442: PPUSH
81443: PPUSH
81444: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81445: LD_VAR 0 1
81449: NOT
81450: PUSH
81451: LD_VAR 0 2
81455: NOT
81456: OR
81457: PUSH
81458: LD_VAR 0 1
81462: PPUSH
81463: CALL_OW 314
81467: OR
81468: IFFALSE 81472
// exit ;
81470: GO 81913
// x := GetX ( enemy_unit ) ;
81472: LD_ADDR_VAR 0 7
81476: PUSH
81477: LD_VAR 0 2
81481: PPUSH
81482: CALL_OW 250
81486: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81487: LD_ADDR_VAR 0 8
81491: PUSH
81492: LD_VAR 0 2
81496: PPUSH
81497: CALL_OW 251
81501: ST_TO_ADDR
// if not x or not y then
81502: LD_VAR 0 7
81506: NOT
81507: PUSH
81508: LD_VAR 0 8
81512: NOT
81513: OR
81514: IFFALSE 81518
// exit ;
81516: GO 81913
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81518: LD_ADDR_VAR 0 6
81522: PUSH
81523: LD_VAR 0 7
81527: PPUSH
81528: LD_INT 0
81530: PPUSH
81531: LD_INT 4
81533: PPUSH
81534: CALL_OW 272
81538: PUSH
81539: LD_VAR 0 8
81543: PPUSH
81544: LD_INT 0
81546: PPUSH
81547: LD_INT 4
81549: PPUSH
81550: CALL_OW 273
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: LD_VAR 0 7
81563: PPUSH
81564: LD_INT 1
81566: PPUSH
81567: LD_INT 4
81569: PPUSH
81570: CALL_OW 272
81574: PUSH
81575: LD_VAR 0 8
81579: PPUSH
81580: LD_INT 1
81582: PPUSH
81583: LD_INT 4
81585: PPUSH
81586: CALL_OW 273
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: PUSH
81595: LD_VAR 0 7
81599: PPUSH
81600: LD_INT 2
81602: PPUSH
81603: LD_INT 4
81605: PPUSH
81606: CALL_OW 272
81610: PUSH
81611: LD_VAR 0 8
81615: PPUSH
81616: LD_INT 2
81618: PPUSH
81619: LD_INT 4
81621: PPUSH
81622: CALL_OW 273
81626: PUSH
81627: EMPTY
81628: LIST
81629: LIST
81630: PUSH
81631: LD_VAR 0 7
81635: PPUSH
81636: LD_INT 3
81638: PPUSH
81639: LD_INT 4
81641: PPUSH
81642: CALL_OW 272
81646: PUSH
81647: LD_VAR 0 8
81651: PPUSH
81652: LD_INT 3
81654: PPUSH
81655: LD_INT 4
81657: PPUSH
81658: CALL_OW 273
81662: PUSH
81663: EMPTY
81664: LIST
81665: LIST
81666: PUSH
81667: LD_VAR 0 7
81671: PPUSH
81672: LD_INT 4
81674: PPUSH
81675: LD_INT 4
81677: PPUSH
81678: CALL_OW 272
81682: PUSH
81683: LD_VAR 0 8
81687: PPUSH
81688: LD_INT 4
81690: PPUSH
81691: LD_INT 4
81693: PPUSH
81694: CALL_OW 273
81698: PUSH
81699: EMPTY
81700: LIST
81701: LIST
81702: PUSH
81703: LD_VAR 0 7
81707: PPUSH
81708: LD_INT 5
81710: PPUSH
81711: LD_INT 4
81713: PPUSH
81714: CALL_OW 272
81718: PUSH
81719: LD_VAR 0 8
81723: PPUSH
81724: LD_INT 5
81726: PPUSH
81727: LD_INT 4
81729: PPUSH
81730: CALL_OW 273
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: EMPTY
81740: LIST
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: ST_TO_ADDR
// for i = tmp downto 1 do
81747: LD_ADDR_VAR 0 4
81751: PUSH
81752: DOUBLE
81753: LD_VAR 0 6
81757: INC
81758: ST_TO_ADDR
81759: LD_INT 1
81761: PUSH
81762: FOR_DOWNTO
81763: IFFALSE 81864
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
81765: LD_VAR 0 6
81769: PUSH
81770: LD_VAR 0 4
81774: ARRAY
81775: PUSH
81776: LD_INT 1
81778: ARRAY
81779: PPUSH
81780: LD_VAR 0 6
81784: PUSH
81785: LD_VAR 0 4
81789: ARRAY
81790: PUSH
81791: LD_INT 2
81793: ARRAY
81794: PPUSH
81795: CALL_OW 488
81799: NOT
81800: PUSH
81801: LD_VAR 0 6
81805: PUSH
81806: LD_VAR 0 4
81810: ARRAY
81811: PUSH
81812: LD_INT 1
81814: ARRAY
81815: PPUSH
81816: LD_VAR 0 6
81820: PUSH
81821: LD_VAR 0 4
81825: ARRAY
81826: PUSH
81827: LD_INT 2
81829: ARRAY
81830: PPUSH
81831: CALL_OW 428
81835: PUSH
81836: LD_INT 0
81838: NONEQUAL
81839: OR
81840: IFFALSE 81862
// tmp := Delete ( tmp , i ) ;
81842: LD_ADDR_VAR 0 6
81846: PUSH
81847: LD_VAR 0 6
81851: PPUSH
81852: LD_VAR 0 4
81856: PPUSH
81857: CALL_OW 3
81861: ST_TO_ADDR
81862: GO 81762
81864: POP
81865: POP
// j := GetClosestHex ( unit , tmp ) ;
81866: LD_ADDR_VAR 0 5
81870: PUSH
81871: LD_VAR 0 1
81875: PPUSH
81876: LD_VAR 0 6
81880: PPUSH
81881: CALL 81166 0 2
81885: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
81886: LD_VAR 0 1
81890: PPUSH
81891: LD_VAR 0 5
81895: PUSH
81896: LD_INT 1
81898: ARRAY
81899: PPUSH
81900: LD_VAR 0 5
81904: PUSH
81905: LD_INT 2
81907: ARRAY
81908: PPUSH
81909: CALL_OW 111
// end ;
81913: LD_VAR 0 3
81917: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
81918: LD_INT 0
81920: PPUSH
81921: PPUSH
81922: PPUSH
// uc_side = 0 ;
81923: LD_ADDR_OWVAR 20
81927: PUSH
81928: LD_INT 0
81930: ST_TO_ADDR
// uc_nation = 0 ;
81931: LD_ADDR_OWVAR 21
81935: PUSH
81936: LD_INT 0
81938: ST_TO_ADDR
// InitHc_All ( ) ;
81939: CALL_OW 584
// InitVc ;
81943: CALL_OW 20
// if mastodonts then
81947: LD_VAR 0 6
81951: IFFALSE 82018
// for i = 1 to mastodonts do
81953: LD_ADDR_VAR 0 11
81957: PUSH
81958: DOUBLE
81959: LD_INT 1
81961: DEC
81962: ST_TO_ADDR
81963: LD_VAR 0 6
81967: PUSH
81968: FOR_TO
81969: IFFALSE 82016
// begin vc_chassis := 31 ;
81971: LD_ADDR_OWVAR 37
81975: PUSH
81976: LD_INT 31
81978: ST_TO_ADDR
// vc_control := control_rider ;
81979: LD_ADDR_OWVAR 38
81983: PUSH
81984: LD_INT 4
81986: ST_TO_ADDR
// animal := CreateVehicle ;
81987: LD_ADDR_VAR 0 12
81991: PUSH
81992: CALL_OW 45
81996: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81997: LD_VAR 0 12
82001: PPUSH
82002: LD_VAR 0 8
82006: PPUSH
82007: LD_INT 0
82009: PPUSH
82010: CALL 84206 0 3
// end ;
82014: GO 81968
82016: POP
82017: POP
// if horses then
82018: LD_VAR 0 5
82022: IFFALSE 82089
// for i = 1 to horses do
82024: LD_ADDR_VAR 0 11
82028: PUSH
82029: DOUBLE
82030: LD_INT 1
82032: DEC
82033: ST_TO_ADDR
82034: LD_VAR 0 5
82038: PUSH
82039: FOR_TO
82040: IFFALSE 82087
// begin hc_class := 21 ;
82042: LD_ADDR_OWVAR 28
82046: PUSH
82047: LD_INT 21
82049: ST_TO_ADDR
// hc_gallery :=  ;
82050: LD_ADDR_OWVAR 33
82054: PUSH
82055: LD_STRING 
82057: ST_TO_ADDR
// animal := CreateHuman ;
82058: LD_ADDR_VAR 0 12
82062: PUSH
82063: CALL_OW 44
82067: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82068: LD_VAR 0 12
82072: PPUSH
82073: LD_VAR 0 8
82077: PPUSH
82078: LD_INT 0
82080: PPUSH
82081: CALL 84206 0 3
// end ;
82085: GO 82039
82087: POP
82088: POP
// if birds then
82089: LD_VAR 0 1
82093: IFFALSE 82160
// for i = 1 to birds do
82095: LD_ADDR_VAR 0 11
82099: PUSH
82100: DOUBLE
82101: LD_INT 1
82103: DEC
82104: ST_TO_ADDR
82105: LD_VAR 0 1
82109: PUSH
82110: FOR_TO
82111: IFFALSE 82158
// begin hc_class = 18 ;
82113: LD_ADDR_OWVAR 28
82117: PUSH
82118: LD_INT 18
82120: ST_TO_ADDR
// hc_gallery =  ;
82121: LD_ADDR_OWVAR 33
82125: PUSH
82126: LD_STRING 
82128: ST_TO_ADDR
// animal := CreateHuman ;
82129: LD_ADDR_VAR 0 12
82133: PUSH
82134: CALL_OW 44
82138: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82139: LD_VAR 0 12
82143: PPUSH
82144: LD_VAR 0 8
82148: PPUSH
82149: LD_INT 0
82151: PPUSH
82152: CALL 84206 0 3
// end ;
82156: GO 82110
82158: POP
82159: POP
// if tigers then
82160: LD_VAR 0 2
82164: IFFALSE 82248
// for i = 1 to tigers do
82166: LD_ADDR_VAR 0 11
82170: PUSH
82171: DOUBLE
82172: LD_INT 1
82174: DEC
82175: ST_TO_ADDR
82176: LD_VAR 0 2
82180: PUSH
82181: FOR_TO
82182: IFFALSE 82246
// begin hc_class = class_tiger ;
82184: LD_ADDR_OWVAR 28
82188: PUSH
82189: LD_INT 14
82191: ST_TO_ADDR
// hc_gallery =  ;
82192: LD_ADDR_OWVAR 33
82196: PUSH
82197: LD_STRING 
82199: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
82200: LD_ADDR_OWVAR 35
82204: PUSH
82205: LD_INT 7
82207: NEG
82208: PPUSH
82209: LD_INT 7
82211: PPUSH
82212: CALL_OW 12
82216: ST_TO_ADDR
// animal := CreateHuman ;
82217: LD_ADDR_VAR 0 12
82221: PUSH
82222: CALL_OW 44
82226: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82227: LD_VAR 0 12
82231: PPUSH
82232: LD_VAR 0 8
82236: PPUSH
82237: LD_INT 0
82239: PPUSH
82240: CALL 84206 0 3
// end ;
82244: GO 82181
82246: POP
82247: POP
// if apemans then
82248: LD_VAR 0 3
82252: IFFALSE 82375
// for i = 1 to apemans do
82254: LD_ADDR_VAR 0 11
82258: PUSH
82259: DOUBLE
82260: LD_INT 1
82262: DEC
82263: ST_TO_ADDR
82264: LD_VAR 0 3
82268: PUSH
82269: FOR_TO
82270: IFFALSE 82373
// begin hc_class = class_apeman ;
82272: LD_ADDR_OWVAR 28
82276: PUSH
82277: LD_INT 12
82279: ST_TO_ADDR
// hc_gallery =  ;
82280: LD_ADDR_OWVAR 33
82284: PUSH
82285: LD_STRING 
82287: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
82288: LD_ADDR_OWVAR 35
82292: PUSH
82293: LD_INT 2
82295: NEG
82296: PPUSH
82297: LD_INT 2
82299: PPUSH
82300: CALL_OW 12
82304: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
82305: LD_ADDR_OWVAR 31
82309: PUSH
82310: LD_INT 1
82312: PPUSH
82313: LD_INT 3
82315: PPUSH
82316: CALL_OW 12
82320: PUSH
82321: LD_INT 1
82323: PPUSH
82324: LD_INT 3
82326: PPUSH
82327: CALL_OW 12
82331: PUSH
82332: LD_INT 0
82334: PUSH
82335: LD_INT 0
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: ST_TO_ADDR
// animal := CreateHuman ;
82344: LD_ADDR_VAR 0 12
82348: PUSH
82349: CALL_OW 44
82353: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82354: LD_VAR 0 12
82358: PPUSH
82359: LD_VAR 0 8
82363: PPUSH
82364: LD_INT 0
82366: PPUSH
82367: CALL 84206 0 3
// end ;
82371: GO 82269
82373: POP
82374: POP
// if enchidnas then
82375: LD_VAR 0 4
82379: IFFALSE 82446
// for i = 1 to enchidnas do
82381: LD_ADDR_VAR 0 11
82385: PUSH
82386: DOUBLE
82387: LD_INT 1
82389: DEC
82390: ST_TO_ADDR
82391: LD_VAR 0 4
82395: PUSH
82396: FOR_TO
82397: IFFALSE 82444
// begin hc_class = 13 ;
82399: LD_ADDR_OWVAR 28
82403: PUSH
82404: LD_INT 13
82406: ST_TO_ADDR
// hc_gallery =  ;
82407: LD_ADDR_OWVAR 33
82411: PUSH
82412: LD_STRING 
82414: ST_TO_ADDR
// animal := CreateHuman ;
82415: LD_ADDR_VAR 0 12
82419: PUSH
82420: CALL_OW 44
82424: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82425: LD_VAR 0 12
82429: PPUSH
82430: LD_VAR 0 8
82434: PPUSH
82435: LD_INT 0
82437: PPUSH
82438: CALL 84206 0 3
// end ;
82442: GO 82396
82444: POP
82445: POP
// if fishes then
82446: LD_VAR 0 7
82450: IFFALSE 82517
// for i = 1 to fishes do
82452: LD_ADDR_VAR 0 11
82456: PUSH
82457: DOUBLE
82458: LD_INT 1
82460: DEC
82461: ST_TO_ADDR
82462: LD_VAR 0 7
82466: PUSH
82467: FOR_TO
82468: IFFALSE 82515
// begin hc_class = 20 ;
82470: LD_ADDR_OWVAR 28
82474: PUSH
82475: LD_INT 20
82477: ST_TO_ADDR
// hc_gallery =  ;
82478: LD_ADDR_OWVAR 33
82482: PUSH
82483: LD_STRING 
82485: ST_TO_ADDR
// animal := CreateHuman ;
82486: LD_ADDR_VAR 0 12
82490: PUSH
82491: CALL_OW 44
82495: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
82496: LD_VAR 0 12
82500: PPUSH
82501: LD_VAR 0 9
82505: PPUSH
82506: LD_INT 0
82508: PPUSH
82509: CALL 84206 0 3
// end ;
82513: GO 82467
82515: POP
82516: POP
// end ;
82517: LD_VAR 0 10
82521: RET
// export function WantHeal ( sci , unit ) ; begin
82522: LD_INT 0
82524: PPUSH
// if GetTaskList ( sci ) > 0 then
82525: LD_VAR 0 1
82529: PPUSH
82530: CALL_OW 437
82534: PUSH
82535: LD_INT 0
82537: GREATER
82538: IFFALSE 82608
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82540: LD_VAR 0 1
82544: PPUSH
82545: CALL_OW 437
82549: PUSH
82550: LD_INT 1
82552: ARRAY
82553: PUSH
82554: LD_INT 1
82556: ARRAY
82557: PUSH
82558: LD_STRING l
82560: EQUAL
82561: PUSH
82562: LD_VAR 0 1
82566: PPUSH
82567: CALL_OW 437
82571: PUSH
82572: LD_INT 1
82574: ARRAY
82575: PUSH
82576: LD_INT 4
82578: ARRAY
82579: PUSH
82580: LD_VAR 0 2
82584: EQUAL
82585: AND
82586: IFFALSE 82598
// result := true else
82588: LD_ADDR_VAR 0 3
82592: PUSH
82593: LD_INT 1
82595: ST_TO_ADDR
82596: GO 82606
// result := false ;
82598: LD_ADDR_VAR 0 3
82602: PUSH
82603: LD_INT 0
82605: ST_TO_ADDR
// end else
82606: GO 82616
// result := false ;
82608: LD_ADDR_VAR 0 3
82612: PUSH
82613: LD_INT 0
82615: ST_TO_ADDR
// end ;
82616: LD_VAR 0 3
82620: RET
// export function HealTarget ( sci ) ; begin
82621: LD_INT 0
82623: PPUSH
// if not sci then
82624: LD_VAR 0 1
82628: NOT
82629: IFFALSE 82633
// exit ;
82631: GO 82698
// result := 0 ;
82633: LD_ADDR_VAR 0 2
82637: PUSH
82638: LD_INT 0
82640: ST_TO_ADDR
// if GetTaskList ( sci ) then
82641: LD_VAR 0 1
82645: PPUSH
82646: CALL_OW 437
82650: IFFALSE 82698
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82652: LD_VAR 0 1
82656: PPUSH
82657: CALL_OW 437
82661: PUSH
82662: LD_INT 1
82664: ARRAY
82665: PUSH
82666: LD_INT 1
82668: ARRAY
82669: PUSH
82670: LD_STRING l
82672: EQUAL
82673: IFFALSE 82698
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
82675: LD_ADDR_VAR 0 2
82679: PUSH
82680: LD_VAR 0 1
82684: PPUSH
82685: CALL_OW 437
82689: PUSH
82690: LD_INT 1
82692: ARRAY
82693: PUSH
82694: LD_INT 4
82696: ARRAY
82697: ST_TO_ADDR
// end ;
82698: LD_VAR 0 2
82702: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
82703: LD_INT 0
82705: PPUSH
82706: PPUSH
82707: PPUSH
82708: PPUSH
// if not base_units then
82709: LD_VAR 0 1
82713: NOT
82714: IFFALSE 82718
// exit ;
82716: GO 82805
// result := false ;
82718: LD_ADDR_VAR 0 2
82722: PUSH
82723: LD_INT 0
82725: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
82726: LD_ADDR_VAR 0 5
82730: PUSH
82731: LD_VAR 0 1
82735: PPUSH
82736: LD_INT 21
82738: PUSH
82739: LD_INT 3
82741: PUSH
82742: EMPTY
82743: LIST
82744: LIST
82745: PPUSH
82746: CALL_OW 72
82750: ST_TO_ADDR
// if not tmp then
82751: LD_VAR 0 5
82755: NOT
82756: IFFALSE 82760
// exit ;
82758: GO 82805
// for i in tmp do
82760: LD_ADDR_VAR 0 3
82764: PUSH
82765: LD_VAR 0 5
82769: PUSH
82770: FOR_IN
82771: IFFALSE 82803
// begin result := EnemyInRange ( i , 22 ) ;
82773: LD_ADDR_VAR 0 2
82777: PUSH
82778: LD_VAR 0 3
82782: PPUSH
82783: LD_INT 22
82785: PPUSH
82786: CALL 81041 0 2
82790: ST_TO_ADDR
// if result then
82791: LD_VAR 0 2
82795: IFFALSE 82801
// exit ;
82797: POP
82798: POP
82799: GO 82805
// end ;
82801: GO 82770
82803: POP
82804: POP
// end ;
82805: LD_VAR 0 2
82809: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
82810: LD_INT 0
82812: PPUSH
82813: PPUSH
// if not units then
82814: LD_VAR 0 1
82818: NOT
82819: IFFALSE 82823
// exit ;
82821: GO 82893
// result := [ ] ;
82823: LD_ADDR_VAR 0 3
82827: PUSH
82828: EMPTY
82829: ST_TO_ADDR
// for i in units do
82830: LD_ADDR_VAR 0 4
82834: PUSH
82835: LD_VAR 0 1
82839: PUSH
82840: FOR_IN
82841: IFFALSE 82891
// if GetTag ( i ) = tag then
82843: LD_VAR 0 4
82847: PPUSH
82848: CALL_OW 110
82852: PUSH
82853: LD_VAR 0 2
82857: EQUAL
82858: IFFALSE 82889
// result := Replace ( result , result + 1 , i ) ;
82860: LD_ADDR_VAR 0 3
82864: PUSH
82865: LD_VAR 0 3
82869: PPUSH
82870: LD_VAR 0 3
82874: PUSH
82875: LD_INT 1
82877: PLUS
82878: PPUSH
82879: LD_VAR 0 4
82883: PPUSH
82884: CALL_OW 1
82888: ST_TO_ADDR
82889: GO 82840
82891: POP
82892: POP
// end ;
82893: LD_VAR 0 3
82897: RET
// export function IsDriver ( un ) ; begin
82898: LD_INT 0
82900: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
82901: LD_ADDR_VAR 0 2
82905: PUSH
82906: LD_VAR 0 1
82910: PUSH
82911: LD_INT 55
82913: PUSH
82914: EMPTY
82915: LIST
82916: PPUSH
82917: CALL_OW 69
82921: IN
82922: ST_TO_ADDR
// end ;
82923: LD_VAR 0 2
82927: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
82928: LD_INT 0
82930: PPUSH
82931: PPUSH
// list := [ ] ;
82932: LD_ADDR_VAR 0 5
82936: PUSH
82937: EMPTY
82938: ST_TO_ADDR
// case d of 0 :
82939: LD_VAR 0 3
82943: PUSH
82944: LD_INT 0
82946: DOUBLE
82947: EQUAL
82948: IFTRUE 82952
82950: GO 83085
82952: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
82953: LD_ADDR_VAR 0 5
82957: PUSH
82958: LD_VAR 0 1
82962: PUSH
82963: LD_INT 4
82965: MINUS
82966: PUSH
82967: LD_VAR 0 2
82971: PUSH
82972: LD_INT 4
82974: MINUS
82975: PUSH
82976: LD_INT 2
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: LIST
82983: PUSH
82984: LD_VAR 0 1
82988: PUSH
82989: LD_INT 3
82991: MINUS
82992: PUSH
82993: LD_VAR 0 2
82997: PUSH
82998: LD_INT 1
83000: PUSH
83001: EMPTY
83002: LIST
83003: LIST
83004: LIST
83005: PUSH
83006: LD_VAR 0 1
83010: PUSH
83011: LD_INT 4
83013: PLUS
83014: PUSH
83015: LD_VAR 0 2
83019: PUSH
83020: LD_INT 4
83022: PUSH
83023: EMPTY
83024: LIST
83025: LIST
83026: LIST
83027: PUSH
83028: LD_VAR 0 1
83032: PUSH
83033: LD_INT 3
83035: PLUS
83036: PUSH
83037: LD_VAR 0 2
83041: PUSH
83042: LD_INT 3
83044: PLUS
83045: PUSH
83046: LD_INT 5
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: LIST
83053: PUSH
83054: LD_VAR 0 1
83058: PUSH
83059: LD_VAR 0 2
83063: PUSH
83064: LD_INT 4
83066: PLUS
83067: PUSH
83068: LD_INT 0
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: LIST
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: ST_TO_ADDR
// end ; 1 :
83083: GO 83783
83085: LD_INT 1
83087: DOUBLE
83088: EQUAL
83089: IFTRUE 83093
83091: GO 83226
83093: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
83094: LD_ADDR_VAR 0 5
83098: PUSH
83099: LD_VAR 0 1
83103: PUSH
83104: LD_VAR 0 2
83108: PUSH
83109: LD_INT 4
83111: MINUS
83112: PUSH
83113: LD_INT 3
83115: PUSH
83116: EMPTY
83117: LIST
83118: LIST
83119: LIST
83120: PUSH
83121: LD_VAR 0 1
83125: PUSH
83126: LD_INT 3
83128: MINUS
83129: PUSH
83130: LD_VAR 0 2
83134: PUSH
83135: LD_INT 3
83137: MINUS
83138: PUSH
83139: LD_INT 2
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: LIST
83146: PUSH
83147: LD_VAR 0 1
83151: PUSH
83152: LD_INT 4
83154: MINUS
83155: PUSH
83156: LD_VAR 0 2
83160: PUSH
83161: LD_INT 1
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: LIST
83168: PUSH
83169: LD_VAR 0 1
83173: PUSH
83174: LD_VAR 0 2
83178: PUSH
83179: LD_INT 3
83181: PLUS
83182: PUSH
83183: LD_INT 0
83185: PUSH
83186: EMPTY
83187: LIST
83188: LIST
83189: LIST
83190: PUSH
83191: LD_VAR 0 1
83195: PUSH
83196: LD_INT 4
83198: PLUS
83199: PUSH
83200: LD_VAR 0 2
83204: PUSH
83205: LD_INT 4
83207: PLUS
83208: PUSH
83209: LD_INT 5
83211: PUSH
83212: EMPTY
83213: LIST
83214: LIST
83215: LIST
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: LIST
83221: LIST
83222: LIST
83223: ST_TO_ADDR
// end ; 2 :
83224: GO 83783
83226: LD_INT 2
83228: DOUBLE
83229: EQUAL
83230: IFTRUE 83234
83232: GO 83363
83234: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
83235: LD_ADDR_VAR 0 5
83239: PUSH
83240: LD_VAR 0 1
83244: PUSH
83245: LD_VAR 0 2
83249: PUSH
83250: LD_INT 3
83252: MINUS
83253: PUSH
83254: LD_INT 3
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: LIST
83261: PUSH
83262: LD_VAR 0 1
83266: PUSH
83267: LD_INT 4
83269: PLUS
83270: PUSH
83271: LD_VAR 0 2
83275: PUSH
83276: LD_INT 4
83278: PUSH
83279: EMPTY
83280: LIST
83281: LIST
83282: LIST
83283: PUSH
83284: LD_VAR 0 1
83288: PUSH
83289: LD_VAR 0 2
83293: PUSH
83294: LD_INT 4
83296: PLUS
83297: PUSH
83298: LD_INT 0
83300: PUSH
83301: EMPTY
83302: LIST
83303: LIST
83304: LIST
83305: PUSH
83306: LD_VAR 0 1
83310: PUSH
83311: LD_INT 3
83313: MINUS
83314: PUSH
83315: LD_VAR 0 2
83319: PUSH
83320: LD_INT 1
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: LIST
83327: PUSH
83328: LD_VAR 0 1
83332: PUSH
83333: LD_INT 4
83335: MINUS
83336: PUSH
83337: LD_VAR 0 2
83341: PUSH
83342: LD_INT 4
83344: MINUS
83345: PUSH
83346: LD_INT 2
83348: PUSH
83349: EMPTY
83350: LIST
83351: LIST
83352: LIST
83353: PUSH
83354: EMPTY
83355: LIST
83356: LIST
83357: LIST
83358: LIST
83359: LIST
83360: ST_TO_ADDR
// end ; 3 :
83361: GO 83783
83363: LD_INT 3
83365: DOUBLE
83366: EQUAL
83367: IFTRUE 83371
83369: GO 83504
83371: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
83372: LD_ADDR_VAR 0 5
83376: PUSH
83377: LD_VAR 0 1
83381: PUSH
83382: LD_INT 3
83384: PLUS
83385: PUSH
83386: LD_VAR 0 2
83390: PUSH
83391: LD_INT 4
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: LIST
83398: PUSH
83399: LD_VAR 0 1
83403: PUSH
83404: LD_INT 4
83406: PLUS
83407: PUSH
83408: LD_VAR 0 2
83412: PUSH
83413: LD_INT 4
83415: PLUS
83416: PUSH
83417: LD_INT 5
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: LIST
83424: PUSH
83425: LD_VAR 0 1
83429: PUSH
83430: LD_INT 4
83432: MINUS
83433: PUSH
83434: LD_VAR 0 2
83438: PUSH
83439: LD_INT 1
83441: PUSH
83442: EMPTY
83443: LIST
83444: LIST
83445: LIST
83446: PUSH
83447: LD_VAR 0 1
83451: PUSH
83452: LD_VAR 0 2
83456: PUSH
83457: LD_INT 4
83459: MINUS
83460: PUSH
83461: LD_INT 3
83463: PUSH
83464: EMPTY
83465: LIST
83466: LIST
83467: LIST
83468: PUSH
83469: LD_VAR 0 1
83473: PUSH
83474: LD_INT 3
83476: MINUS
83477: PUSH
83478: LD_VAR 0 2
83482: PUSH
83483: LD_INT 3
83485: MINUS
83486: PUSH
83487: LD_INT 2
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: LIST
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: LIST
83499: LIST
83500: LIST
83501: ST_TO_ADDR
// end ; 4 :
83502: GO 83783
83504: LD_INT 4
83506: DOUBLE
83507: EQUAL
83508: IFTRUE 83512
83510: GO 83645
83512: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
83513: LD_ADDR_VAR 0 5
83517: PUSH
83518: LD_VAR 0 1
83522: PUSH
83523: LD_VAR 0 2
83527: PUSH
83528: LD_INT 4
83530: PLUS
83531: PUSH
83532: LD_INT 0
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: LIST
83539: PUSH
83540: LD_VAR 0 1
83544: PUSH
83545: LD_INT 3
83547: PLUS
83548: PUSH
83549: LD_VAR 0 2
83553: PUSH
83554: LD_INT 3
83556: PLUS
83557: PUSH
83558: LD_INT 5
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: LIST
83565: PUSH
83566: LD_VAR 0 1
83570: PUSH
83571: LD_INT 4
83573: PLUS
83574: PUSH
83575: LD_VAR 0 2
83579: PUSH
83580: LD_INT 4
83582: PUSH
83583: EMPTY
83584: LIST
83585: LIST
83586: LIST
83587: PUSH
83588: LD_VAR 0 1
83592: PUSH
83593: LD_VAR 0 2
83597: PUSH
83598: LD_INT 3
83600: MINUS
83601: PUSH
83602: LD_INT 3
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: LIST
83609: PUSH
83610: LD_VAR 0 1
83614: PUSH
83615: LD_INT 4
83617: MINUS
83618: PUSH
83619: LD_VAR 0 2
83623: PUSH
83624: LD_INT 4
83626: MINUS
83627: PUSH
83628: LD_INT 2
83630: PUSH
83631: EMPTY
83632: LIST
83633: LIST
83634: LIST
83635: PUSH
83636: EMPTY
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: ST_TO_ADDR
// end ; 5 :
83643: GO 83783
83645: LD_INT 5
83647: DOUBLE
83648: EQUAL
83649: IFTRUE 83653
83651: GO 83782
83653: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
83654: LD_ADDR_VAR 0 5
83658: PUSH
83659: LD_VAR 0 1
83663: PUSH
83664: LD_INT 4
83666: MINUS
83667: PUSH
83668: LD_VAR 0 2
83672: PUSH
83673: LD_INT 1
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: LIST
83680: PUSH
83681: LD_VAR 0 1
83685: PUSH
83686: LD_VAR 0 2
83690: PUSH
83691: LD_INT 4
83693: MINUS
83694: PUSH
83695: LD_INT 3
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: LIST
83702: PUSH
83703: LD_VAR 0 1
83707: PUSH
83708: LD_INT 4
83710: PLUS
83711: PUSH
83712: LD_VAR 0 2
83716: PUSH
83717: LD_INT 4
83719: PLUS
83720: PUSH
83721: LD_INT 5
83723: PUSH
83724: EMPTY
83725: LIST
83726: LIST
83727: LIST
83728: PUSH
83729: LD_VAR 0 1
83733: PUSH
83734: LD_INT 3
83736: PLUS
83737: PUSH
83738: LD_VAR 0 2
83742: PUSH
83743: LD_INT 4
83745: PUSH
83746: EMPTY
83747: LIST
83748: LIST
83749: LIST
83750: PUSH
83751: LD_VAR 0 1
83755: PUSH
83756: LD_VAR 0 2
83760: PUSH
83761: LD_INT 3
83763: PLUS
83764: PUSH
83765: LD_INT 0
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: LIST
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: ST_TO_ADDR
// end ; end ;
83780: GO 83783
83782: POP
// result := list ;
83783: LD_ADDR_VAR 0 4
83787: PUSH
83788: LD_VAR 0 5
83792: ST_TO_ADDR
// end ;
83793: LD_VAR 0 4
83797: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
83798: LD_INT 0
83800: PPUSH
83801: PPUSH
83802: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
83803: LD_VAR 0 1
83807: NOT
83808: PUSH
83809: LD_VAR 0 2
83813: PUSH
83814: LD_INT 1
83816: PUSH
83817: LD_INT 2
83819: PUSH
83820: LD_INT 3
83822: PUSH
83823: LD_INT 4
83825: PUSH
83826: EMPTY
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: IN
83832: NOT
83833: OR
83834: IFFALSE 83838
// exit ;
83836: GO 83930
// tmp := [ ] ;
83838: LD_ADDR_VAR 0 5
83842: PUSH
83843: EMPTY
83844: ST_TO_ADDR
// for i in units do
83845: LD_ADDR_VAR 0 4
83849: PUSH
83850: LD_VAR 0 1
83854: PUSH
83855: FOR_IN
83856: IFFALSE 83899
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
83858: LD_ADDR_VAR 0 5
83862: PUSH
83863: LD_VAR 0 5
83867: PPUSH
83868: LD_VAR 0 5
83872: PUSH
83873: LD_INT 1
83875: PLUS
83876: PPUSH
83877: LD_VAR 0 4
83881: PPUSH
83882: LD_VAR 0 2
83886: PPUSH
83887: CALL_OW 259
83891: PPUSH
83892: CALL_OW 2
83896: ST_TO_ADDR
83897: GO 83855
83899: POP
83900: POP
// if not tmp then
83901: LD_VAR 0 5
83905: NOT
83906: IFFALSE 83910
// exit ;
83908: GO 83930
// result := SortListByListDesc ( units , tmp ) ;
83910: LD_ADDR_VAR 0 3
83914: PUSH
83915: LD_VAR 0 1
83919: PPUSH
83920: LD_VAR 0 5
83924: PPUSH
83925: CALL_OW 77
83929: ST_TO_ADDR
// end ;
83930: LD_VAR 0 3
83934: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
83935: LD_INT 0
83937: PPUSH
83938: PPUSH
83939: PPUSH
// result := false ;
83940: LD_ADDR_VAR 0 3
83944: PUSH
83945: LD_INT 0
83947: ST_TO_ADDR
// x := GetX ( building ) ;
83948: LD_ADDR_VAR 0 4
83952: PUSH
83953: LD_VAR 0 2
83957: PPUSH
83958: CALL_OW 250
83962: ST_TO_ADDR
// y := GetY ( building ) ;
83963: LD_ADDR_VAR 0 5
83967: PUSH
83968: LD_VAR 0 2
83972: PPUSH
83973: CALL_OW 251
83977: ST_TO_ADDR
// if not building or not x or not y then
83978: LD_VAR 0 2
83982: NOT
83983: PUSH
83984: LD_VAR 0 4
83988: NOT
83989: OR
83990: PUSH
83991: LD_VAR 0 5
83995: NOT
83996: OR
83997: IFFALSE 84001
// exit ;
83999: GO 84093
// if GetTaskList ( unit ) then
84001: LD_VAR 0 1
84005: PPUSH
84006: CALL_OW 437
84010: IFFALSE 84093
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84012: LD_STRING e
84014: PUSH
84015: LD_VAR 0 1
84019: PPUSH
84020: CALL_OW 437
84024: PUSH
84025: LD_INT 1
84027: ARRAY
84028: PUSH
84029: LD_INT 1
84031: ARRAY
84032: EQUAL
84033: PUSH
84034: LD_VAR 0 4
84038: PUSH
84039: LD_VAR 0 1
84043: PPUSH
84044: CALL_OW 437
84048: PUSH
84049: LD_INT 1
84051: ARRAY
84052: PUSH
84053: LD_INT 2
84055: ARRAY
84056: EQUAL
84057: AND
84058: PUSH
84059: LD_VAR 0 5
84063: PUSH
84064: LD_VAR 0 1
84068: PPUSH
84069: CALL_OW 437
84073: PUSH
84074: LD_INT 1
84076: ARRAY
84077: PUSH
84078: LD_INT 3
84080: ARRAY
84081: EQUAL
84082: AND
84083: IFFALSE 84093
// result := true end ;
84085: LD_ADDR_VAR 0 3
84089: PUSH
84090: LD_INT 1
84092: ST_TO_ADDR
// end ;
84093: LD_VAR 0 3
84097: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
84098: LD_INT 0
84100: PPUSH
// result := false ;
84101: LD_ADDR_VAR 0 4
84105: PUSH
84106: LD_INT 0
84108: ST_TO_ADDR
// if GetTaskList ( unit ) then
84109: LD_VAR 0 1
84113: PPUSH
84114: CALL_OW 437
84118: IFFALSE 84201
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84120: LD_STRING M
84122: PUSH
84123: LD_VAR 0 1
84127: PPUSH
84128: CALL_OW 437
84132: PUSH
84133: LD_INT 1
84135: ARRAY
84136: PUSH
84137: LD_INT 1
84139: ARRAY
84140: EQUAL
84141: PUSH
84142: LD_VAR 0 2
84146: PUSH
84147: LD_VAR 0 1
84151: PPUSH
84152: CALL_OW 437
84156: PUSH
84157: LD_INT 1
84159: ARRAY
84160: PUSH
84161: LD_INT 2
84163: ARRAY
84164: EQUAL
84165: AND
84166: PUSH
84167: LD_VAR 0 3
84171: PUSH
84172: LD_VAR 0 1
84176: PPUSH
84177: CALL_OW 437
84181: PUSH
84182: LD_INT 1
84184: ARRAY
84185: PUSH
84186: LD_INT 3
84188: ARRAY
84189: EQUAL
84190: AND
84191: IFFALSE 84201
// result := true ;
84193: LD_ADDR_VAR 0 4
84197: PUSH
84198: LD_INT 1
84200: ST_TO_ADDR
// end ; end ;
84201: LD_VAR 0 4
84205: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
84206: LD_INT 0
84208: PPUSH
84209: PPUSH
84210: PPUSH
84211: PPUSH
// if not unit or not area then
84212: LD_VAR 0 1
84216: NOT
84217: PUSH
84218: LD_VAR 0 2
84222: NOT
84223: OR
84224: IFFALSE 84228
// exit ;
84226: GO 84392
// tmp := AreaToList ( area , i ) ;
84228: LD_ADDR_VAR 0 6
84232: PUSH
84233: LD_VAR 0 2
84237: PPUSH
84238: LD_VAR 0 5
84242: PPUSH
84243: CALL_OW 517
84247: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
84248: LD_ADDR_VAR 0 5
84252: PUSH
84253: DOUBLE
84254: LD_INT 1
84256: DEC
84257: ST_TO_ADDR
84258: LD_VAR 0 6
84262: PUSH
84263: LD_INT 1
84265: ARRAY
84266: PUSH
84267: FOR_TO
84268: IFFALSE 84390
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
84270: LD_ADDR_VAR 0 7
84274: PUSH
84275: LD_VAR 0 6
84279: PUSH
84280: LD_INT 1
84282: ARRAY
84283: PUSH
84284: LD_VAR 0 5
84288: ARRAY
84289: PUSH
84290: LD_VAR 0 6
84294: PUSH
84295: LD_INT 2
84297: ARRAY
84298: PUSH
84299: LD_VAR 0 5
84303: ARRAY
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
84309: LD_VAR 0 7
84313: PUSH
84314: LD_INT 1
84316: ARRAY
84317: PPUSH
84318: LD_VAR 0 7
84322: PUSH
84323: LD_INT 2
84325: ARRAY
84326: PPUSH
84327: CALL_OW 428
84331: PUSH
84332: LD_INT 0
84334: EQUAL
84335: IFFALSE 84388
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
84337: LD_VAR 0 1
84341: PPUSH
84342: LD_VAR 0 7
84346: PUSH
84347: LD_INT 1
84349: ARRAY
84350: PPUSH
84351: LD_VAR 0 7
84355: PUSH
84356: LD_INT 2
84358: ARRAY
84359: PPUSH
84360: LD_VAR 0 3
84364: PPUSH
84365: CALL_OW 48
// result := IsPlaced ( unit ) ;
84369: LD_ADDR_VAR 0 4
84373: PUSH
84374: LD_VAR 0 1
84378: PPUSH
84379: CALL_OW 305
84383: ST_TO_ADDR
// exit ;
84384: POP
84385: POP
84386: GO 84392
// end ; end ;
84388: GO 84267
84390: POP
84391: POP
// end ;
84392: LD_VAR 0 4
84396: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
84397: LD_INT 0
84399: PPUSH
84400: PPUSH
84401: PPUSH
// if not side or side > 8 then
84402: LD_VAR 0 1
84406: NOT
84407: PUSH
84408: LD_VAR 0 1
84412: PUSH
84413: LD_INT 8
84415: GREATER
84416: OR
84417: IFFALSE 84421
// exit ;
84419: GO 84608
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
84421: LD_ADDR_VAR 0 4
84425: PUSH
84426: LD_INT 22
84428: PUSH
84429: LD_VAR 0 1
84433: PUSH
84434: EMPTY
84435: LIST
84436: LIST
84437: PUSH
84438: LD_INT 21
84440: PUSH
84441: LD_INT 3
84443: PUSH
84444: EMPTY
84445: LIST
84446: LIST
84447: PUSH
84448: EMPTY
84449: LIST
84450: LIST
84451: PPUSH
84452: CALL_OW 69
84456: ST_TO_ADDR
// if not tmp then
84457: LD_VAR 0 4
84461: NOT
84462: IFFALSE 84466
// exit ;
84464: GO 84608
// enable_addtolog := true ;
84466: LD_ADDR_OWVAR 81
84470: PUSH
84471: LD_INT 1
84473: ST_TO_ADDR
// AddToLog ( [ ) ;
84474: LD_STRING [
84476: PPUSH
84477: CALL_OW 561
// for i in tmp do
84481: LD_ADDR_VAR 0 3
84485: PUSH
84486: LD_VAR 0 4
84490: PUSH
84491: FOR_IN
84492: IFFALSE 84599
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
84494: LD_STRING [
84496: PUSH
84497: LD_VAR 0 3
84501: PPUSH
84502: CALL_OW 266
84506: STR
84507: PUSH
84508: LD_STRING , 
84510: STR
84511: PUSH
84512: LD_VAR 0 3
84516: PPUSH
84517: CALL_OW 250
84521: STR
84522: PUSH
84523: LD_STRING , 
84525: STR
84526: PUSH
84527: LD_VAR 0 3
84531: PPUSH
84532: CALL_OW 251
84536: STR
84537: PUSH
84538: LD_STRING , 
84540: STR
84541: PUSH
84542: LD_VAR 0 3
84546: PPUSH
84547: CALL_OW 254
84551: STR
84552: PUSH
84553: LD_STRING , 
84555: STR
84556: PUSH
84557: LD_VAR 0 3
84561: PPUSH
84562: LD_INT 1
84564: PPUSH
84565: CALL_OW 268
84569: STR
84570: PUSH
84571: LD_STRING , 
84573: STR
84574: PUSH
84575: LD_VAR 0 3
84579: PPUSH
84580: LD_INT 2
84582: PPUSH
84583: CALL_OW 268
84587: STR
84588: PUSH
84589: LD_STRING ],
84591: STR
84592: PPUSH
84593: CALL_OW 561
// end ;
84597: GO 84491
84599: POP
84600: POP
// AddToLog ( ]; ) ;
84601: LD_STRING ];
84603: PPUSH
84604: CALL_OW 561
// end ;
84608: LD_VAR 0 2
84612: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
84613: LD_INT 0
84615: PPUSH
84616: PPUSH
84617: PPUSH
84618: PPUSH
84619: PPUSH
// if not area or not rate or not max then
84620: LD_VAR 0 1
84624: NOT
84625: PUSH
84626: LD_VAR 0 2
84630: NOT
84631: OR
84632: PUSH
84633: LD_VAR 0 4
84637: NOT
84638: OR
84639: IFFALSE 84643
// exit ;
84641: GO 84835
// while 1 do
84643: LD_INT 1
84645: IFFALSE 84835
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
84647: LD_ADDR_VAR 0 9
84651: PUSH
84652: LD_VAR 0 1
84656: PPUSH
84657: LD_INT 1
84659: PPUSH
84660: CALL_OW 287
84664: PUSH
84665: LD_INT 10
84667: MUL
84668: ST_TO_ADDR
// r := rate / 10 ;
84669: LD_ADDR_VAR 0 7
84673: PUSH
84674: LD_VAR 0 2
84678: PUSH
84679: LD_INT 10
84681: DIVREAL
84682: ST_TO_ADDR
// time := 1 1$00 ;
84683: LD_ADDR_VAR 0 8
84687: PUSH
84688: LD_INT 2100
84690: ST_TO_ADDR
// if amount < min then
84691: LD_VAR 0 9
84695: PUSH
84696: LD_VAR 0 3
84700: LESS
84701: IFFALSE 84719
// r := r * 2 else
84703: LD_ADDR_VAR 0 7
84707: PUSH
84708: LD_VAR 0 7
84712: PUSH
84713: LD_INT 2
84715: MUL
84716: ST_TO_ADDR
84717: GO 84745
// if amount > max then
84719: LD_VAR 0 9
84723: PUSH
84724: LD_VAR 0 4
84728: GREATER
84729: IFFALSE 84745
// r := r / 2 ;
84731: LD_ADDR_VAR 0 7
84735: PUSH
84736: LD_VAR 0 7
84740: PUSH
84741: LD_INT 2
84743: DIVREAL
84744: ST_TO_ADDR
// time := time / r ;
84745: LD_ADDR_VAR 0 8
84749: PUSH
84750: LD_VAR 0 8
84754: PUSH
84755: LD_VAR 0 7
84759: DIVREAL
84760: ST_TO_ADDR
// if time < 0 then
84761: LD_VAR 0 8
84765: PUSH
84766: LD_INT 0
84768: LESS
84769: IFFALSE 84786
// time := time * - 1 ;
84771: LD_ADDR_VAR 0 8
84775: PUSH
84776: LD_VAR 0 8
84780: PUSH
84781: LD_INT 1
84783: NEG
84784: MUL
84785: ST_TO_ADDR
// wait ( time ) ;
84786: LD_VAR 0 8
84790: PPUSH
84791: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
84795: LD_INT 35
84797: PPUSH
84798: LD_INT 875
84800: PPUSH
84801: CALL_OW 12
84805: PPUSH
84806: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
84810: LD_INT 1
84812: PPUSH
84813: LD_INT 5
84815: PPUSH
84816: CALL_OW 12
84820: PPUSH
84821: LD_VAR 0 1
84825: PPUSH
84826: LD_INT 1
84828: PPUSH
84829: CALL_OW 55
// end ;
84833: GO 84643
// end ;
84835: LD_VAR 0 5
84839: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
84840: LD_INT 0
84842: PPUSH
84843: PPUSH
84844: PPUSH
84845: PPUSH
84846: PPUSH
84847: PPUSH
84848: PPUSH
84849: PPUSH
// if not turrets or not factories then
84850: LD_VAR 0 1
84854: NOT
84855: PUSH
84856: LD_VAR 0 2
84860: NOT
84861: OR
84862: IFFALSE 84866
// exit ;
84864: GO 85173
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
84866: LD_ADDR_VAR 0 10
84870: PUSH
84871: LD_INT 5
84873: PUSH
84874: LD_INT 6
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: PUSH
84881: LD_INT 2
84883: PUSH
84884: LD_INT 4
84886: PUSH
84887: EMPTY
84888: LIST
84889: LIST
84890: PUSH
84891: LD_INT 3
84893: PUSH
84894: LD_INT 5
84896: PUSH
84897: EMPTY
84898: LIST
84899: LIST
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 24
84908: PUSH
84909: LD_INT 25
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 23
84918: PUSH
84919: LD_INT 27
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: PUSH
84930: LD_INT 42
84932: PUSH
84933: LD_INT 43
84935: PUSH
84936: EMPTY
84937: LIST
84938: LIST
84939: PUSH
84940: LD_INT 44
84942: PUSH
84943: LD_INT 46
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 45
84952: PUSH
84953: LD_INT 47
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: EMPTY
84961: LIST
84962: LIST
84963: LIST
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: LIST
84969: ST_TO_ADDR
// result := [ ] ;
84970: LD_ADDR_VAR 0 3
84974: PUSH
84975: EMPTY
84976: ST_TO_ADDR
// for i in turrets do
84977: LD_ADDR_VAR 0 4
84981: PUSH
84982: LD_VAR 0 1
84986: PUSH
84987: FOR_IN
84988: IFFALSE 85171
// begin nat := GetNation ( i ) ;
84990: LD_ADDR_VAR 0 7
84994: PUSH
84995: LD_VAR 0 4
84999: PPUSH
85000: CALL_OW 248
85004: ST_TO_ADDR
// weapon := 0 ;
85005: LD_ADDR_VAR 0 8
85009: PUSH
85010: LD_INT 0
85012: ST_TO_ADDR
// if not nat then
85013: LD_VAR 0 7
85017: NOT
85018: IFFALSE 85022
// continue ;
85020: GO 84987
// for j in list [ nat ] do
85022: LD_ADDR_VAR 0 5
85026: PUSH
85027: LD_VAR 0 10
85031: PUSH
85032: LD_VAR 0 7
85036: ARRAY
85037: PUSH
85038: FOR_IN
85039: IFFALSE 85080
// if GetBWeapon ( i ) = j [ 1 ] then
85041: LD_VAR 0 4
85045: PPUSH
85046: CALL_OW 269
85050: PUSH
85051: LD_VAR 0 5
85055: PUSH
85056: LD_INT 1
85058: ARRAY
85059: EQUAL
85060: IFFALSE 85078
// begin weapon := j [ 2 ] ;
85062: LD_ADDR_VAR 0 8
85066: PUSH
85067: LD_VAR 0 5
85071: PUSH
85072: LD_INT 2
85074: ARRAY
85075: ST_TO_ADDR
// break ;
85076: GO 85080
// end ;
85078: GO 85038
85080: POP
85081: POP
// if not weapon then
85082: LD_VAR 0 8
85086: NOT
85087: IFFALSE 85091
// continue ;
85089: GO 84987
// for k in factories do
85091: LD_ADDR_VAR 0 6
85095: PUSH
85096: LD_VAR 0 2
85100: PUSH
85101: FOR_IN
85102: IFFALSE 85167
// begin weapons := AvailableWeaponList ( k ) ;
85104: LD_ADDR_VAR 0 9
85108: PUSH
85109: LD_VAR 0 6
85113: PPUSH
85114: CALL_OW 478
85118: ST_TO_ADDR
// if not weapons then
85119: LD_VAR 0 9
85123: NOT
85124: IFFALSE 85128
// continue ;
85126: GO 85101
// if weapon in weapons then
85128: LD_VAR 0 8
85132: PUSH
85133: LD_VAR 0 9
85137: IN
85138: IFFALSE 85165
// begin result := [ i , weapon ] ;
85140: LD_ADDR_VAR 0 3
85144: PUSH
85145: LD_VAR 0 4
85149: PUSH
85150: LD_VAR 0 8
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: ST_TO_ADDR
// exit ;
85159: POP
85160: POP
85161: POP
85162: POP
85163: GO 85173
// end ; end ;
85165: GO 85101
85167: POP
85168: POP
// end ;
85169: GO 84987
85171: POP
85172: POP
// end ;
85173: LD_VAR 0 3
85177: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
85178: LD_INT 0
85180: PPUSH
// if not side or side > 8 then
85181: LD_VAR 0 3
85185: NOT
85186: PUSH
85187: LD_VAR 0 3
85191: PUSH
85192: LD_INT 8
85194: GREATER
85195: OR
85196: IFFALSE 85200
// exit ;
85198: GO 85259
// if not range then
85200: LD_VAR 0 4
85204: NOT
85205: IFFALSE 85216
// range := - 12 ;
85207: LD_ADDR_VAR 0 4
85211: PUSH
85212: LD_INT 12
85214: NEG
85215: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
85216: LD_VAR 0 1
85220: PPUSH
85221: LD_VAR 0 2
85225: PPUSH
85226: LD_VAR 0 3
85230: PPUSH
85231: LD_VAR 0 4
85235: PPUSH
85236: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
85240: LD_VAR 0 1
85244: PPUSH
85245: LD_VAR 0 2
85249: PPUSH
85250: LD_VAR 0 3
85254: PPUSH
85255: CALL_OW 331
// end ;
85259: LD_VAR 0 5
85263: RET
// export function Video ( mode ) ; begin
85264: LD_INT 0
85266: PPUSH
// ingame_video = mode ;
85267: LD_ADDR_OWVAR 52
85271: PUSH
85272: LD_VAR 0 1
85276: ST_TO_ADDR
// interface_hidden = mode ;
85277: LD_ADDR_OWVAR 54
85281: PUSH
85282: LD_VAR 0 1
85286: ST_TO_ADDR
// end ;
85287: LD_VAR 0 2
85291: RET
// export function Join ( array , element ) ; begin
85292: LD_INT 0
85294: PPUSH
// result := Replace ( array , array + 1 , element ) ;
85295: LD_ADDR_VAR 0 3
85299: PUSH
85300: LD_VAR 0 1
85304: PPUSH
85305: LD_VAR 0 1
85309: PUSH
85310: LD_INT 1
85312: PLUS
85313: PPUSH
85314: LD_VAR 0 2
85318: PPUSH
85319: CALL_OW 1
85323: ST_TO_ADDR
// end ;
85324: LD_VAR 0 3
85328: RET
// export function JoinUnion ( array , element ) ; begin
85329: LD_INT 0
85331: PPUSH
// result := array union element ;
85332: LD_ADDR_VAR 0 3
85336: PUSH
85337: LD_VAR 0 1
85341: PUSH
85342: LD_VAR 0 2
85346: UNION
85347: ST_TO_ADDR
// end ;
85348: LD_VAR 0 3
85352: RET
// export function GetBehemoths ( side ) ; begin
85353: LD_INT 0
85355: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
85356: LD_ADDR_VAR 0 2
85360: PUSH
85361: LD_INT 22
85363: PUSH
85364: LD_VAR 0 1
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: PUSH
85373: LD_INT 31
85375: PUSH
85376: LD_INT 25
85378: PUSH
85379: EMPTY
85380: LIST
85381: LIST
85382: PUSH
85383: EMPTY
85384: LIST
85385: LIST
85386: PPUSH
85387: CALL_OW 69
85391: ST_TO_ADDR
// end ;
85392: LD_VAR 0 2
85396: RET
// export function Shuffle ( array ) ; var i , index ; begin
85397: LD_INT 0
85399: PPUSH
85400: PPUSH
85401: PPUSH
// result := [ ] ;
85402: LD_ADDR_VAR 0 2
85406: PUSH
85407: EMPTY
85408: ST_TO_ADDR
// if not array then
85409: LD_VAR 0 1
85413: NOT
85414: IFFALSE 85418
// exit ;
85416: GO 85517
// Randomize ;
85418: CALL_OW 10
// for i = array downto 1 do
85422: LD_ADDR_VAR 0 3
85426: PUSH
85427: DOUBLE
85428: LD_VAR 0 1
85432: INC
85433: ST_TO_ADDR
85434: LD_INT 1
85436: PUSH
85437: FOR_DOWNTO
85438: IFFALSE 85515
// begin index := rand ( 1 , array ) ;
85440: LD_ADDR_VAR 0 4
85444: PUSH
85445: LD_INT 1
85447: PPUSH
85448: LD_VAR 0 1
85452: PPUSH
85453: CALL_OW 12
85457: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
85458: LD_ADDR_VAR 0 2
85462: PUSH
85463: LD_VAR 0 2
85467: PPUSH
85468: LD_VAR 0 2
85472: PUSH
85473: LD_INT 1
85475: PLUS
85476: PPUSH
85477: LD_VAR 0 1
85481: PUSH
85482: LD_VAR 0 4
85486: ARRAY
85487: PPUSH
85488: CALL_OW 2
85492: ST_TO_ADDR
// array := Delete ( array , index ) ;
85493: LD_ADDR_VAR 0 1
85497: PUSH
85498: LD_VAR 0 1
85502: PPUSH
85503: LD_VAR 0 4
85507: PPUSH
85508: CALL_OW 3
85512: ST_TO_ADDR
// end ;
85513: GO 85437
85515: POP
85516: POP
// end ;
85517: LD_VAR 0 2
85521: RET
// export function GetBaseMaterials ( base ) ; begin
85522: LD_INT 0
85524: PPUSH
// result := [ 0 , 0 , 0 ] ;
85525: LD_ADDR_VAR 0 2
85529: PUSH
85530: LD_INT 0
85532: PUSH
85533: LD_INT 0
85535: PUSH
85536: LD_INT 0
85538: PUSH
85539: EMPTY
85540: LIST
85541: LIST
85542: LIST
85543: ST_TO_ADDR
// if not base then
85544: LD_VAR 0 1
85548: NOT
85549: IFFALSE 85553
// exit ;
85551: GO 85602
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
85553: LD_ADDR_VAR 0 2
85557: PUSH
85558: LD_VAR 0 1
85562: PPUSH
85563: LD_INT 1
85565: PPUSH
85566: CALL_OW 275
85570: PUSH
85571: LD_VAR 0 1
85575: PPUSH
85576: LD_INT 2
85578: PPUSH
85579: CALL_OW 275
85583: PUSH
85584: LD_VAR 0 1
85588: PPUSH
85589: LD_INT 3
85591: PPUSH
85592: CALL_OW 275
85596: PUSH
85597: EMPTY
85598: LIST
85599: LIST
85600: LIST
85601: ST_TO_ADDR
// end ;
85602: LD_VAR 0 2
85606: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
85607: LD_INT 0
85609: PPUSH
85610: PPUSH
// result := array ;
85611: LD_ADDR_VAR 0 3
85615: PUSH
85616: LD_VAR 0 1
85620: ST_TO_ADDR
// if size > 0 then
85621: LD_VAR 0 2
85625: PUSH
85626: LD_INT 0
85628: GREATER
85629: IFFALSE 85675
// for i := array downto size do
85631: LD_ADDR_VAR 0 4
85635: PUSH
85636: DOUBLE
85637: LD_VAR 0 1
85641: INC
85642: ST_TO_ADDR
85643: LD_VAR 0 2
85647: PUSH
85648: FOR_DOWNTO
85649: IFFALSE 85673
// result := Delete ( result , result ) ;
85651: LD_ADDR_VAR 0 3
85655: PUSH
85656: LD_VAR 0 3
85660: PPUSH
85661: LD_VAR 0 3
85665: PPUSH
85666: CALL_OW 3
85670: ST_TO_ADDR
85671: GO 85648
85673: POP
85674: POP
// end ;
85675: LD_VAR 0 3
85679: RET
// export function ComExit ( unit ) ; var tmp ; begin
85680: LD_INT 0
85682: PPUSH
85683: PPUSH
// if not IsInUnit ( unit ) then
85684: LD_VAR 0 1
85688: PPUSH
85689: CALL_OW 310
85693: NOT
85694: IFFALSE 85698
// exit ;
85696: GO 85758
// tmp := IsInUnit ( unit ) ;
85698: LD_ADDR_VAR 0 3
85702: PUSH
85703: LD_VAR 0 1
85707: PPUSH
85708: CALL_OW 310
85712: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
85713: LD_VAR 0 3
85717: PPUSH
85718: CALL_OW 247
85722: PUSH
85723: LD_INT 2
85725: EQUAL
85726: IFFALSE 85739
// ComExitVehicle ( unit ) else
85728: LD_VAR 0 1
85732: PPUSH
85733: CALL_OW 121
85737: GO 85748
// ComExitBuilding ( unit ) ;
85739: LD_VAR 0 1
85743: PPUSH
85744: CALL_OW 122
// result := tmp ;
85748: LD_ADDR_VAR 0 2
85752: PUSH
85753: LD_VAR 0 3
85757: ST_TO_ADDR
// end ;
85758: LD_VAR 0 2
85762: RET
// export function ComExitAll ( units ) ; var i ; begin
85763: LD_INT 0
85765: PPUSH
85766: PPUSH
// if not units then
85767: LD_VAR 0 1
85771: NOT
85772: IFFALSE 85776
// exit ;
85774: GO 85802
// for i in units do
85776: LD_ADDR_VAR 0 3
85780: PUSH
85781: LD_VAR 0 1
85785: PUSH
85786: FOR_IN
85787: IFFALSE 85800
// ComExit ( i ) ;
85789: LD_VAR 0 3
85793: PPUSH
85794: CALL 85680 0 1
85798: GO 85786
85800: POP
85801: POP
// end ;
85802: LD_VAR 0 2
85806: RET
// export function ResetHc ; begin
85807: LD_INT 0
85809: PPUSH
// InitHc ;
85810: CALL_OW 19
// hc_importance := 0 ;
85814: LD_ADDR_OWVAR 32
85818: PUSH
85819: LD_INT 0
85821: ST_TO_ADDR
// end ;
85822: LD_VAR 0 1
85826: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
85827: LD_INT 0
85829: PPUSH
85830: PPUSH
85831: PPUSH
// _x := ( x1 + x2 ) div 2 ;
85832: LD_ADDR_VAR 0 6
85836: PUSH
85837: LD_VAR 0 1
85841: PUSH
85842: LD_VAR 0 3
85846: PLUS
85847: PUSH
85848: LD_INT 2
85850: DIV
85851: ST_TO_ADDR
// if _x < 0 then
85852: LD_VAR 0 6
85856: PUSH
85857: LD_INT 0
85859: LESS
85860: IFFALSE 85877
// _x := _x * - 1 ;
85862: LD_ADDR_VAR 0 6
85866: PUSH
85867: LD_VAR 0 6
85871: PUSH
85872: LD_INT 1
85874: NEG
85875: MUL
85876: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
85877: LD_ADDR_VAR 0 7
85881: PUSH
85882: LD_VAR 0 2
85886: PUSH
85887: LD_VAR 0 4
85891: PLUS
85892: PUSH
85893: LD_INT 2
85895: DIV
85896: ST_TO_ADDR
// if _y < 0 then
85897: LD_VAR 0 7
85901: PUSH
85902: LD_INT 0
85904: LESS
85905: IFFALSE 85922
// _y := _y * - 1 ;
85907: LD_ADDR_VAR 0 7
85911: PUSH
85912: LD_VAR 0 7
85916: PUSH
85917: LD_INT 1
85919: NEG
85920: MUL
85921: ST_TO_ADDR
// result := [ _x , _y ] ;
85922: LD_ADDR_VAR 0 5
85926: PUSH
85927: LD_VAR 0 6
85931: PUSH
85932: LD_VAR 0 7
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: ST_TO_ADDR
// end ;
85941: LD_VAR 0 5
85945: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
85946: LD_INT 0
85948: PPUSH
85949: PPUSH
85950: PPUSH
85951: PPUSH
// task := GetTaskList ( unit ) ;
85952: LD_ADDR_VAR 0 7
85956: PUSH
85957: LD_VAR 0 1
85961: PPUSH
85962: CALL_OW 437
85966: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
85967: LD_VAR 0 7
85971: NOT
85972: PUSH
85973: LD_VAR 0 1
85977: PPUSH
85978: LD_VAR 0 2
85982: PPUSH
85983: CALL_OW 308
85987: NOT
85988: AND
85989: IFFALSE 85993
// exit ;
85991: GO 86111
// if IsInArea ( unit , area ) then
85993: LD_VAR 0 1
85997: PPUSH
85998: LD_VAR 0 2
86002: PPUSH
86003: CALL_OW 308
86007: IFFALSE 86025
// begin ComMoveToArea ( unit , goAway ) ;
86009: LD_VAR 0 1
86013: PPUSH
86014: LD_VAR 0 3
86018: PPUSH
86019: CALL_OW 113
// exit ;
86023: GO 86111
// end ; if task [ 1 ] [ 1 ] <> M then
86025: LD_VAR 0 7
86029: PUSH
86030: LD_INT 1
86032: ARRAY
86033: PUSH
86034: LD_INT 1
86036: ARRAY
86037: PUSH
86038: LD_STRING M
86040: NONEQUAL
86041: IFFALSE 86045
// exit ;
86043: GO 86111
// x := task [ 1 ] [ 2 ] ;
86045: LD_ADDR_VAR 0 5
86049: PUSH
86050: LD_VAR 0 7
86054: PUSH
86055: LD_INT 1
86057: ARRAY
86058: PUSH
86059: LD_INT 2
86061: ARRAY
86062: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
86063: LD_ADDR_VAR 0 6
86067: PUSH
86068: LD_VAR 0 7
86072: PUSH
86073: LD_INT 1
86075: ARRAY
86076: PUSH
86077: LD_INT 3
86079: ARRAY
86080: ST_TO_ADDR
// if InArea ( x , y , area ) then
86081: LD_VAR 0 5
86085: PPUSH
86086: LD_VAR 0 6
86090: PPUSH
86091: LD_VAR 0 2
86095: PPUSH
86096: CALL_OW 309
86100: IFFALSE 86111
// ComStop ( unit ) ;
86102: LD_VAR 0 1
86106: PPUSH
86107: CALL_OW 141
// end ;
86111: LD_VAR 0 4
86115: RET
// export function Abs ( value ) ; begin
86116: LD_INT 0
86118: PPUSH
// result := value ;
86119: LD_ADDR_VAR 0 2
86123: PUSH
86124: LD_VAR 0 1
86128: ST_TO_ADDR
// if value < 0 then
86129: LD_VAR 0 1
86133: PUSH
86134: LD_INT 0
86136: LESS
86137: IFFALSE 86154
// result := value * - 1 ;
86139: LD_ADDR_VAR 0 2
86143: PUSH
86144: LD_VAR 0 1
86148: PUSH
86149: LD_INT 1
86151: NEG
86152: MUL
86153: ST_TO_ADDR
// end ;
86154: LD_VAR 0 2
86158: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
86159: LD_INT 0
86161: PPUSH
86162: PPUSH
86163: PPUSH
86164: PPUSH
86165: PPUSH
86166: PPUSH
86167: PPUSH
86168: PPUSH
// if not unit or not building then
86169: LD_VAR 0 1
86173: NOT
86174: PUSH
86175: LD_VAR 0 2
86179: NOT
86180: OR
86181: IFFALSE 86185
// exit ;
86183: GO 86411
// x := GetX ( building ) ;
86185: LD_ADDR_VAR 0 4
86189: PUSH
86190: LD_VAR 0 2
86194: PPUSH
86195: CALL_OW 250
86199: ST_TO_ADDR
// y := GetY ( building ) ;
86200: LD_ADDR_VAR 0 6
86204: PUSH
86205: LD_VAR 0 2
86209: PPUSH
86210: CALL_OW 251
86214: ST_TO_ADDR
// d := GetDir ( building ) ;
86215: LD_ADDR_VAR 0 8
86219: PUSH
86220: LD_VAR 0 2
86224: PPUSH
86225: CALL_OW 254
86229: ST_TO_ADDR
// r := 4 ;
86230: LD_ADDR_VAR 0 9
86234: PUSH
86235: LD_INT 4
86237: ST_TO_ADDR
// for i := 1 to 5 do
86238: LD_ADDR_VAR 0 10
86242: PUSH
86243: DOUBLE
86244: LD_INT 1
86246: DEC
86247: ST_TO_ADDR
86248: LD_INT 5
86250: PUSH
86251: FOR_TO
86252: IFFALSE 86409
// begin _x := ShiftX ( x , d , r + i ) ;
86254: LD_ADDR_VAR 0 5
86258: PUSH
86259: LD_VAR 0 4
86263: PPUSH
86264: LD_VAR 0 8
86268: PPUSH
86269: LD_VAR 0 9
86273: PUSH
86274: LD_VAR 0 10
86278: PLUS
86279: PPUSH
86280: CALL_OW 272
86284: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
86285: LD_ADDR_VAR 0 7
86289: PUSH
86290: LD_VAR 0 6
86294: PPUSH
86295: LD_VAR 0 8
86299: PPUSH
86300: LD_VAR 0 9
86304: PUSH
86305: LD_VAR 0 10
86309: PLUS
86310: PPUSH
86311: CALL_OW 273
86315: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
86316: LD_VAR 0 5
86320: PPUSH
86321: LD_VAR 0 7
86325: PPUSH
86326: CALL_OW 488
86330: PUSH
86331: LD_VAR 0 5
86335: PPUSH
86336: LD_VAR 0 7
86340: PPUSH
86341: CALL_OW 428
86345: PPUSH
86346: CALL_OW 247
86350: PUSH
86351: LD_INT 3
86353: PUSH
86354: LD_INT 2
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: IN
86361: NOT
86362: AND
86363: IFFALSE 86407
// begin ComMoveXY ( unit , _x , _y ) ;
86365: LD_VAR 0 1
86369: PPUSH
86370: LD_VAR 0 5
86374: PPUSH
86375: LD_VAR 0 7
86379: PPUSH
86380: CALL_OW 111
// result := [ _x , _y ] ;
86384: LD_ADDR_VAR 0 3
86388: PUSH
86389: LD_VAR 0 5
86393: PUSH
86394: LD_VAR 0 7
86398: PUSH
86399: EMPTY
86400: LIST
86401: LIST
86402: ST_TO_ADDR
// exit ;
86403: POP
86404: POP
86405: GO 86411
// end ; end ;
86407: GO 86251
86409: POP
86410: POP
// end ;
86411: LD_VAR 0 3
86415: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
86416: LD_INT 0
86418: PPUSH
86419: PPUSH
86420: PPUSH
// result := 0 ;
86421: LD_ADDR_VAR 0 3
86425: PUSH
86426: LD_INT 0
86428: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
86429: LD_VAR 0 1
86433: PUSH
86434: LD_INT 0
86436: LESS
86437: PUSH
86438: LD_VAR 0 1
86442: PUSH
86443: LD_INT 8
86445: GREATER
86446: OR
86447: PUSH
86448: LD_VAR 0 2
86452: PUSH
86453: LD_INT 0
86455: LESS
86456: OR
86457: PUSH
86458: LD_VAR 0 2
86462: PUSH
86463: LD_INT 8
86465: GREATER
86466: OR
86467: IFFALSE 86471
// exit ;
86469: GO 86546
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
86471: LD_ADDR_VAR 0 4
86475: PUSH
86476: LD_INT 22
86478: PUSH
86479: LD_VAR 0 2
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: PPUSH
86488: CALL_OW 69
86492: PUSH
86493: FOR_IN
86494: IFFALSE 86544
// begin un := UnitShoot ( i ) ;
86496: LD_ADDR_VAR 0 5
86500: PUSH
86501: LD_VAR 0 4
86505: PPUSH
86506: CALL_OW 504
86510: ST_TO_ADDR
// if GetSide ( un ) = side1 then
86511: LD_VAR 0 5
86515: PPUSH
86516: CALL_OW 255
86520: PUSH
86521: LD_VAR 0 1
86525: EQUAL
86526: IFFALSE 86542
// begin result := un ;
86528: LD_ADDR_VAR 0 3
86532: PUSH
86533: LD_VAR 0 5
86537: ST_TO_ADDR
// exit ;
86538: POP
86539: POP
86540: GO 86546
// end ; end ;
86542: GO 86493
86544: POP
86545: POP
// end ;
86546: LD_VAR 0 3
86550: RET
// export function GetCargoBay ( units ) ; begin
86551: LD_INT 0
86553: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
86554: LD_ADDR_VAR 0 2
86558: PUSH
86559: LD_VAR 0 1
86563: PPUSH
86564: LD_INT 2
86566: PUSH
86567: LD_INT 34
86569: PUSH
86570: LD_INT 12
86572: PUSH
86573: EMPTY
86574: LIST
86575: LIST
86576: PUSH
86577: LD_INT 34
86579: PUSH
86580: LD_INT 51
86582: PUSH
86583: EMPTY
86584: LIST
86585: LIST
86586: PUSH
86587: LD_INT 34
86589: PUSH
86590: LD_INT 32
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 34
86599: PUSH
86600: LD_EXP 95
86604: PUSH
86605: EMPTY
86606: LIST
86607: LIST
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: LIST
86613: LIST
86614: LIST
86615: PPUSH
86616: CALL_OW 72
86620: ST_TO_ADDR
// end ;
86621: LD_VAR 0 2
86625: RET
// export function Negate ( value ) ; begin
86626: LD_INT 0
86628: PPUSH
// result := not value ;
86629: LD_ADDR_VAR 0 2
86633: PUSH
86634: LD_VAR 0 1
86638: NOT
86639: ST_TO_ADDR
// end ;
86640: LD_VAR 0 2
86644: RET
// export function Inc ( value ) ; begin
86645: LD_INT 0
86647: PPUSH
// result := value + 1 ;
86648: LD_ADDR_VAR 0 2
86652: PUSH
86653: LD_VAR 0 1
86657: PUSH
86658: LD_INT 1
86660: PLUS
86661: ST_TO_ADDR
// end ;
86662: LD_VAR 0 2
86666: RET
// export function Dec ( value ) ; begin
86667: LD_INT 0
86669: PPUSH
// result := value - 1 ;
86670: LD_ADDR_VAR 0 2
86674: PUSH
86675: LD_VAR 0 1
86679: PUSH
86680: LD_INT 1
86682: MINUS
86683: ST_TO_ADDR
// end ;
86684: LD_VAR 0 2
86688: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
86689: LD_INT 0
86691: PPUSH
86692: PPUSH
86693: PPUSH
86694: PPUSH
86695: PPUSH
86696: PPUSH
86697: PPUSH
86698: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
86699: LD_VAR 0 1
86703: PPUSH
86704: LD_VAR 0 2
86708: PPUSH
86709: CALL_OW 488
86713: NOT
86714: PUSH
86715: LD_VAR 0 3
86719: PPUSH
86720: LD_VAR 0 4
86724: PPUSH
86725: CALL_OW 488
86729: NOT
86730: OR
86731: IFFALSE 86744
// begin result := - 1 ;
86733: LD_ADDR_VAR 0 5
86737: PUSH
86738: LD_INT 1
86740: NEG
86741: ST_TO_ADDR
// exit ;
86742: GO 86979
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
86744: LD_ADDR_VAR 0 12
86748: PUSH
86749: LD_VAR 0 1
86753: PPUSH
86754: LD_VAR 0 2
86758: PPUSH
86759: LD_VAR 0 3
86763: PPUSH
86764: LD_VAR 0 4
86768: PPUSH
86769: CALL 85827 0 4
86773: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
86774: LD_ADDR_VAR 0 11
86778: PUSH
86779: LD_VAR 0 1
86783: PPUSH
86784: LD_VAR 0 2
86788: PPUSH
86789: LD_VAR 0 12
86793: PUSH
86794: LD_INT 1
86796: ARRAY
86797: PPUSH
86798: LD_VAR 0 12
86802: PUSH
86803: LD_INT 2
86805: ARRAY
86806: PPUSH
86807: CALL_OW 298
86811: ST_TO_ADDR
// distance := 9999 ;
86812: LD_ADDR_VAR 0 10
86816: PUSH
86817: LD_INT 9999
86819: ST_TO_ADDR
// for i := 0 to 5 do
86820: LD_ADDR_VAR 0 6
86824: PUSH
86825: DOUBLE
86826: LD_INT 0
86828: DEC
86829: ST_TO_ADDR
86830: LD_INT 5
86832: PUSH
86833: FOR_TO
86834: IFFALSE 86977
// begin _x := ShiftX ( x1 , i , centerDist ) ;
86836: LD_ADDR_VAR 0 7
86840: PUSH
86841: LD_VAR 0 1
86845: PPUSH
86846: LD_VAR 0 6
86850: PPUSH
86851: LD_VAR 0 11
86855: PPUSH
86856: CALL_OW 272
86860: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
86861: LD_ADDR_VAR 0 8
86865: PUSH
86866: LD_VAR 0 2
86870: PPUSH
86871: LD_VAR 0 6
86875: PPUSH
86876: LD_VAR 0 11
86880: PPUSH
86881: CALL_OW 273
86885: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
86886: LD_VAR 0 7
86890: PPUSH
86891: LD_VAR 0 8
86895: PPUSH
86896: CALL_OW 488
86900: NOT
86901: IFFALSE 86905
// continue ;
86903: GO 86833
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
86905: LD_ADDR_VAR 0 9
86909: PUSH
86910: LD_VAR 0 12
86914: PUSH
86915: LD_INT 1
86917: ARRAY
86918: PPUSH
86919: LD_VAR 0 12
86923: PUSH
86924: LD_INT 2
86926: ARRAY
86927: PPUSH
86928: LD_VAR 0 7
86932: PPUSH
86933: LD_VAR 0 8
86937: PPUSH
86938: CALL_OW 298
86942: ST_TO_ADDR
// if tmp < distance then
86943: LD_VAR 0 9
86947: PUSH
86948: LD_VAR 0 10
86952: LESS
86953: IFFALSE 86975
// begin result := i ;
86955: LD_ADDR_VAR 0 5
86959: PUSH
86960: LD_VAR 0 6
86964: ST_TO_ADDR
// distance := tmp ;
86965: LD_ADDR_VAR 0 10
86969: PUSH
86970: LD_VAR 0 9
86974: ST_TO_ADDR
// end ; end ;
86975: GO 86833
86977: POP
86978: POP
// end ;
86979: LD_VAR 0 5
86983: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
86984: LD_INT 0
86986: PPUSH
86987: PPUSH
// if not driver or not IsInUnit ( driver ) then
86988: LD_VAR 0 1
86992: NOT
86993: PUSH
86994: LD_VAR 0 1
86998: PPUSH
86999: CALL_OW 310
87003: NOT
87004: OR
87005: IFFALSE 87009
// exit ;
87007: GO 87099
// vehicle := IsInUnit ( driver ) ;
87009: LD_ADDR_VAR 0 3
87013: PUSH
87014: LD_VAR 0 1
87018: PPUSH
87019: CALL_OW 310
87023: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87024: LD_VAR 0 1
87028: PPUSH
87029: LD_STRING \
87031: PUSH
87032: LD_INT 0
87034: PUSH
87035: LD_INT 0
87037: PUSH
87038: LD_INT 0
87040: PUSH
87041: LD_INT 0
87043: PUSH
87044: LD_INT 0
87046: PUSH
87047: LD_INT 0
87049: PUSH
87050: EMPTY
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: PUSH
87059: LD_STRING E
87061: PUSH
87062: LD_INT 0
87064: PUSH
87065: LD_INT 0
87067: PUSH
87068: LD_VAR 0 3
87072: PUSH
87073: LD_INT 0
87075: PUSH
87076: LD_INT 0
87078: PUSH
87079: LD_INT 0
87081: PUSH
87082: EMPTY
87083: LIST
87084: LIST
87085: LIST
87086: LIST
87087: LIST
87088: LIST
87089: LIST
87090: PUSH
87091: EMPTY
87092: LIST
87093: LIST
87094: PPUSH
87095: CALL_OW 446
// end ;
87099: LD_VAR 0 2
87103: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87104: LD_INT 0
87106: PPUSH
87107: PPUSH
// if not driver or not IsInUnit ( driver ) then
87108: LD_VAR 0 1
87112: NOT
87113: PUSH
87114: LD_VAR 0 1
87118: PPUSH
87119: CALL_OW 310
87123: NOT
87124: OR
87125: IFFALSE 87129
// exit ;
87127: GO 87219
// vehicle := IsInUnit ( driver ) ;
87129: LD_ADDR_VAR 0 3
87133: PUSH
87134: LD_VAR 0 1
87138: PPUSH
87139: CALL_OW 310
87143: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87144: LD_VAR 0 1
87148: PPUSH
87149: LD_STRING \
87151: PUSH
87152: LD_INT 0
87154: PUSH
87155: LD_INT 0
87157: PUSH
87158: LD_INT 0
87160: PUSH
87161: LD_INT 0
87163: PUSH
87164: LD_INT 0
87166: PUSH
87167: LD_INT 0
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: LIST
87178: PUSH
87179: LD_STRING E
87181: PUSH
87182: LD_INT 0
87184: PUSH
87185: LD_INT 0
87187: PUSH
87188: LD_VAR 0 3
87192: PUSH
87193: LD_INT 0
87195: PUSH
87196: LD_INT 0
87198: PUSH
87199: LD_INT 0
87201: PUSH
87202: EMPTY
87203: LIST
87204: LIST
87205: LIST
87206: LIST
87207: LIST
87208: LIST
87209: LIST
87210: PUSH
87211: EMPTY
87212: LIST
87213: LIST
87214: PPUSH
87215: CALL_OW 447
// end ;
87219: LD_VAR 0 2
87223: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
87224: LD_INT 0
87226: PPUSH
87227: PPUSH
87228: PPUSH
// tmp := [ ] ;
87229: LD_ADDR_VAR 0 5
87233: PUSH
87234: EMPTY
87235: ST_TO_ADDR
// for i in units do
87236: LD_ADDR_VAR 0 4
87240: PUSH
87241: LD_VAR 0 1
87245: PUSH
87246: FOR_IN
87247: IFFALSE 87285
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
87249: LD_ADDR_VAR 0 5
87253: PUSH
87254: LD_VAR 0 5
87258: PPUSH
87259: LD_VAR 0 5
87263: PUSH
87264: LD_INT 1
87266: PLUS
87267: PPUSH
87268: LD_VAR 0 4
87272: PPUSH
87273: CALL_OW 256
87277: PPUSH
87278: CALL_OW 2
87282: ST_TO_ADDR
87283: GO 87246
87285: POP
87286: POP
// if not tmp then
87287: LD_VAR 0 5
87291: NOT
87292: IFFALSE 87296
// exit ;
87294: GO 87344
// if asc then
87296: LD_VAR 0 2
87300: IFFALSE 87324
// result := SortListByListAsc ( units , tmp ) else
87302: LD_ADDR_VAR 0 3
87306: PUSH
87307: LD_VAR 0 1
87311: PPUSH
87312: LD_VAR 0 5
87316: PPUSH
87317: CALL_OW 76
87321: ST_TO_ADDR
87322: GO 87344
// result := SortListByListDesc ( units , tmp ) ;
87324: LD_ADDR_VAR 0 3
87328: PUSH
87329: LD_VAR 0 1
87333: PPUSH
87334: LD_VAR 0 5
87338: PPUSH
87339: CALL_OW 77
87343: ST_TO_ADDR
// end ;
87344: LD_VAR 0 3
87348: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
87349: LD_INT 0
87351: PPUSH
87352: PPUSH
// task := GetTaskList ( mech ) ;
87353: LD_ADDR_VAR 0 4
87357: PUSH
87358: LD_VAR 0 1
87362: PPUSH
87363: CALL_OW 437
87367: ST_TO_ADDR
// if not task then
87368: LD_VAR 0 4
87372: NOT
87373: IFFALSE 87377
// exit ;
87375: GO 87419
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
87377: LD_ADDR_VAR 0 3
87381: PUSH
87382: LD_VAR 0 4
87386: PUSH
87387: LD_INT 1
87389: ARRAY
87390: PUSH
87391: LD_INT 1
87393: ARRAY
87394: PUSH
87395: LD_STRING r
87397: EQUAL
87398: PUSH
87399: LD_VAR 0 4
87403: PUSH
87404: LD_INT 1
87406: ARRAY
87407: PUSH
87408: LD_INT 4
87410: ARRAY
87411: PUSH
87412: LD_VAR 0 2
87416: EQUAL
87417: AND
87418: ST_TO_ADDR
// end ;
87419: LD_VAR 0 3
87423: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
87424: LD_INT 0
87426: PPUSH
// SetDir ( unit , d ) ;
87427: LD_VAR 0 1
87431: PPUSH
87432: LD_VAR 0 4
87436: PPUSH
87437: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
87441: LD_VAR 0 1
87445: PPUSH
87446: LD_VAR 0 2
87450: PPUSH
87451: LD_VAR 0 3
87455: PPUSH
87456: LD_VAR 0 5
87460: PPUSH
87461: CALL_OW 48
// end ;
87465: LD_VAR 0 6
87469: RET
// export function ToNaturalNumber ( number ) ; begin
87470: LD_INT 0
87472: PPUSH
// result := number div 1 ;
87473: LD_ADDR_VAR 0 2
87477: PUSH
87478: LD_VAR 0 1
87482: PUSH
87483: LD_INT 1
87485: DIV
87486: ST_TO_ADDR
// if number < 0 then
87487: LD_VAR 0 1
87491: PUSH
87492: LD_INT 0
87494: LESS
87495: IFFALSE 87505
// result := 0 ;
87497: LD_ADDR_VAR 0 2
87501: PUSH
87502: LD_INT 0
87504: ST_TO_ADDR
// end ;
87505: LD_VAR 0 2
87509: RET
// export function SortByClass ( units , class ) ; var un ; begin
87510: LD_INT 0
87512: PPUSH
87513: PPUSH
// if not units or not class then
87514: LD_VAR 0 1
87518: NOT
87519: PUSH
87520: LD_VAR 0 2
87524: NOT
87525: OR
87526: IFFALSE 87530
// exit ;
87528: GO 87625
// result := [ ] ;
87530: LD_ADDR_VAR 0 3
87534: PUSH
87535: EMPTY
87536: ST_TO_ADDR
// for un in units do
87537: LD_ADDR_VAR 0 4
87541: PUSH
87542: LD_VAR 0 1
87546: PUSH
87547: FOR_IN
87548: IFFALSE 87623
// if GetClass ( un ) = class then
87550: LD_VAR 0 4
87554: PPUSH
87555: CALL_OW 257
87559: PUSH
87560: LD_VAR 0 2
87564: EQUAL
87565: IFFALSE 87592
// result := Insert ( result , 1 , un ) else
87567: LD_ADDR_VAR 0 3
87571: PUSH
87572: LD_VAR 0 3
87576: PPUSH
87577: LD_INT 1
87579: PPUSH
87580: LD_VAR 0 4
87584: PPUSH
87585: CALL_OW 2
87589: ST_TO_ADDR
87590: GO 87621
// result := Replace ( result , result + 1 , un ) ;
87592: LD_ADDR_VAR 0 3
87596: PUSH
87597: LD_VAR 0 3
87601: PPUSH
87602: LD_VAR 0 3
87606: PUSH
87607: LD_INT 1
87609: PLUS
87610: PPUSH
87611: LD_VAR 0 4
87615: PPUSH
87616: CALL_OW 1
87620: ST_TO_ADDR
87621: GO 87547
87623: POP
87624: POP
// end ;
87625: LD_VAR 0 3
87629: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
87630: LD_INT 0
87632: PPUSH
87633: PPUSH
87634: PPUSH
87635: PPUSH
87636: PPUSH
87637: PPUSH
87638: PPUSH
// result := [ ] ;
87639: LD_ADDR_VAR 0 4
87643: PUSH
87644: EMPTY
87645: ST_TO_ADDR
// if x - r < 0 then
87646: LD_VAR 0 1
87650: PUSH
87651: LD_VAR 0 3
87655: MINUS
87656: PUSH
87657: LD_INT 0
87659: LESS
87660: IFFALSE 87672
// min_x := 0 else
87662: LD_ADDR_VAR 0 8
87666: PUSH
87667: LD_INT 0
87669: ST_TO_ADDR
87670: GO 87688
// min_x := x - r ;
87672: LD_ADDR_VAR 0 8
87676: PUSH
87677: LD_VAR 0 1
87681: PUSH
87682: LD_VAR 0 3
87686: MINUS
87687: ST_TO_ADDR
// if y - r < 0 then
87688: LD_VAR 0 2
87692: PUSH
87693: LD_VAR 0 3
87697: MINUS
87698: PUSH
87699: LD_INT 0
87701: LESS
87702: IFFALSE 87714
// min_y := 0 else
87704: LD_ADDR_VAR 0 7
87708: PUSH
87709: LD_INT 0
87711: ST_TO_ADDR
87712: GO 87730
// min_y := y - r ;
87714: LD_ADDR_VAR 0 7
87718: PUSH
87719: LD_VAR 0 2
87723: PUSH
87724: LD_VAR 0 3
87728: MINUS
87729: ST_TO_ADDR
// max_x := x + r ;
87730: LD_ADDR_VAR 0 9
87734: PUSH
87735: LD_VAR 0 1
87739: PUSH
87740: LD_VAR 0 3
87744: PLUS
87745: ST_TO_ADDR
// max_y := y + r ;
87746: LD_ADDR_VAR 0 10
87750: PUSH
87751: LD_VAR 0 2
87755: PUSH
87756: LD_VAR 0 3
87760: PLUS
87761: ST_TO_ADDR
// for _x = min_x to max_x do
87762: LD_ADDR_VAR 0 5
87766: PUSH
87767: DOUBLE
87768: LD_VAR 0 8
87772: DEC
87773: ST_TO_ADDR
87774: LD_VAR 0 9
87778: PUSH
87779: FOR_TO
87780: IFFALSE 87881
// for _y = min_y to max_y do
87782: LD_ADDR_VAR 0 6
87786: PUSH
87787: DOUBLE
87788: LD_VAR 0 7
87792: DEC
87793: ST_TO_ADDR
87794: LD_VAR 0 10
87798: PUSH
87799: FOR_TO
87800: IFFALSE 87877
// begin if not ValidHex ( _x , _y ) then
87802: LD_VAR 0 5
87806: PPUSH
87807: LD_VAR 0 6
87811: PPUSH
87812: CALL_OW 488
87816: NOT
87817: IFFALSE 87821
// continue ;
87819: GO 87799
// if GetResourceTypeXY ( _x , _y ) then
87821: LD_VAR 0 5
87825: PPUSH
87826: LD_VAR 0 6
87830: PPUSH
87831: CALL_OW 283
87835: IFFALSE 87875
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
87837: LD_ADDR_VAR 0 4
87841: PUSH
87842: LD_VAR 0 4
87846: PPUSH
87847: LD_VAR 0 4
87851: PUSH
87852: LD_INT 1
87854: PLUS
87855: PPUSH
87856: LD_VAR 0 5
87860: PUSH
87861: LD_VAR 0 6
87865: PUSH
87866: EMPTY
87867: LIST
87868: LIST
87869: PPUSH
87870: CALL_OW 1
87874: ST_TO_ADDR
// end ;
87875: GO 87799
87877: POP
87878: POP
87879: GO 87779
87881: POP
87882: POP
// end ;
87883: LD_VAR 0 4
87887: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
87888: LD_INT 0
87890: PPUSH
87891: PPUSH
87892: PPUSH
87893: PPUSH
87894: PPUSH
87895: PPUSH
87896: PPUSH
87897: PPUSH
// if not units then
87898: LD_VAR 0 1
87902: NOT
87903: IFFALSE 87907
// exit ;
87905: GO 88332
// result := UnitFilter ( units , [ f_ok ] ) ;
87907: LD_ADDR_VAR 0 3
87911: PUSH
87912: LD_VAR 0 1
87916: PPUSH
87917: LD_INT 50
87919: PUSH
87920: EMPTY
87921: LIST
87922: PPUSH
87923: CALL_OW 72
87927: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
87928: LD_ADDR_VAR 0 8
87932: PUSH
87933: LD_VAR 0 1
87937: PUSH
87938: LD_INT 1
87940: ARRAY
87941: PPUSH
87942: CALL_OW 255
87946: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
87947: LD_ADDR_VAR 0 10
87951: PUSH
87952: LD_INT 29
87954: PUSH
87955: LD_EXP 98
87959: PUSH
87960: EMPTY
87961: LIST
87962: LIST
87963: ST_TO_ADDR
// if not result then
87964: LD_VAR 0 3
87968: NOT
87969: IFFALSE 87973
// exit ;
87971: GO 88332
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
87973: LD_ADDR_VAR 0 5
87977: PUSH
87978: LD_INT 81
87980: PUSH
87981: LD_VAR 0 8
87985: PUSH
87986: EMPTY
87987: LIST
87988: LIST
87989: PPUSH
87990: CALL_OW 69
87994: ST_TO_ADDR
// for i in result do
87995: LD_ADDR_VAR 0 4
87999: PUSH
88000: LD_VAR 0 3
88004: PUSH
88005: FOR_IN
88006: IFFALSE 88330
// begin tag := GetTag ( i ) + 1 ;
88008: LD_ADDR_VAR 0 9
88012: PUSH
88013: LD_VAR 0 4
88017: PPUSH
88018: CALL_OW 110
88022: PUSH
88023: LD_INT 1
88025: PLUS
88026: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
88027: LD_ADDR_VAR 0 7
88031: PUSH
88032: LD_VAR 0 4
88036: PPUSH
88037: CALL_OW 250
88041: PPUSH
88042: LD_VAR 0 4
88046: PPUSH
88047: CALL_OW 251
88051: PPUSH
88052: LD_INT 6
88054: PPUSH
88055: CALL 87630 0 3
88059: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
88060: LD_VAR 0 7
88064: PUSH
88065: LD_VAR 0 4
88069: PPUSH
88070: CALL_OW 264
88074: PUSH
88075: LD_VAR 0 10
88079: IN
88080: NOT
88081: AND
88082: IFFALSE 88121
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
88084: LD_VAR 0 4
88088: PPUSH
88089: LD_VAR 0 7
88093: PUSH
88094: LD_INT 1
88096: ARRAY
88097: PUSH
88098: LD_INT 1
88100: ARRAY
88101: PPUSH
88102: LD_VAR 0 7
88106: PUSH
88107: LD_INT 1
88109: ARRAY
88110: PUSH
88111: LD_INT 2
88113: ARRAY
88114: PPUSH
88115: CALL_OW 116
88119: GO 88328
// if path > tag then
88121: LD_VAR 0 2
88125: PUSH
88126: LD_VAR 0 9
88130: GREATER
88131: IFFALSE 88298
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
88133: LD_ADDR_VAR 0 6
88137: PUSH
88138: LD_VAR 0 5
88142: PPUSH
88143: LD_INT 91
88145: PUSH
88146: LD_VAR 0 4
88150: PUSH
88151: LD_INT 12
88153: PUSH
88154: EMPTY
88155: LIST
88156: LIST
88157: LIST
88158: PPUSH
88159: CALL_OW 72
88163: ST_TO_ADDR
// if nearEnemy then
88164: LD_VAR 0 6
88168: IFFALSE 88196
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
88170: LD_VAR 0 4
88174: PPUSH
88175: LD_VAR 0 6
88179: PPUSH
88180: LD_VAR 0 4
88184: PPUSH
88185: CALL_OW 74
88189: PPUSH
88190: CALL_OW 115
88194: GO 88296
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
88196: LD_VAR 0 4
88200: PPUSH
88201: LD_VAR 0 2
88205: PUSH
88206: LD_VAR 0 9
88210: ARRAY
88211: PUSH
88212: LD_INT 1
88214: ARRAY
88215: PPUSH
88216: LD_VAR 0 2
88220: PUSH
88221: LD_VAR 0 9
88225: ARRAY
88226: PUSH
88227: LD_INT 2
88229: ARRAY
88230: PPUSH
88231: CALL_OW 297
88235: PUSH
88236: LD_INT 6
88238: GREATER
88239: IFFALSE 88282
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
88241: LD_VAR 0 4
88245: PPUSH
88246: LD_VAR 0 2
88250: PUSH
88251: LD_VAR 0 9
88255: ARRAY
88256: PUSH
88257: LD_INT 1
88259: ARRAY
88260: PPUSH
88261: LD_VAR 0 2
88265: PUSH
88266: LD_VAR 0 9
88270: ARRAY
88271: PUSH
88272: LD_INT 2
88274: ARRAY
88275: PPUSH
88276: CALL_OW 114
88280: GO 88296
// SetTag ( i , tag ) ;
88282: LD_VAR 0 4
88286: PPUSH
88287: LD_VAR 0 9
88291: PPUSH
88292: CALL_OW 109
// end else
88296: GO 88328
// if enemy then
88298: LD_VAR 0 5
88302: IFFALSE 88328
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
88304: LD_VAR 0 4
88308: PPUSH
88309: LD_VAR 0 5
88313: PPUSH
88314: LD_VAR 0 4
88318: PPUSH
88319: CALL_OW 74
88323: PPUSH
88324: CALL_OW 115
// end ;
88328: GO 88005
88330: POP
88331: POP
// end ;
88332: LD_VAR 0 3
88336: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
88337: LD_INT 0
88339: PPUSH
88340: PPUSH
88341: PPUSH
// if not unit or IsInUnit ( unit ) then
88342: LD_VAR 0 1
88346: NOT
88347: PUSH
88348: LD_VAR 0 1
88352: PPUSH
88353: CALL_OW 310
88357: OR
88358: IFFALSE 88362
// exit ;
88360: GO 88453
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
88362: LD_ADDR_VAR 0 4
88366: PUSH
88367: LD_VAR 0 1
88371: PPUSH
88372: CALL_OW 250
88376: PPUSH
88377: LD_VAR 0 2
88381: PPUSH
88382: LD_INT 1
88384: PPUSH
88385: CALL_OW 272
88389: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
88390: LD_ADDR_VAR 0 5
88394: PUSH
88395: LD_VAR 0 1
88399: PPUSH
88400: CALL_OW 251
88404: PPUSH
88405: LD_VAR 0 2
88409: PPUSH
88410: LD_INT 1
88412: PPUSH
88413: CALL_OW 273
88417: ST_TO_ADDR
// if ValidHex ( x , y ) then
88418: LD_VAR 0 4
88422: PPUSH
88423: LD_VAR 0 5
88427: PPUSH
88428: CALL_OW 488
88432: IFFALSE 88453
// ComTurnXY ( unit , x , y ) ;
88434: LD_VAR 0 1
88438: PPUSH
88439: LD_VAR 0 4
88443: PPUSH
88444: LD_VAR 0 5
88448: PPUSH
88449: CALL_OW 118
// end ;
88453: LD_VAR 0 3
88457: RET
// export function SeeUnits ( side , units ) ; var i ; begin
88458: LD_INT 0
88460: PPUSH
88461: PPUSH
// result := false ;
88462: LD_ADDR_VAR 0 3
88466: PUSH
88467: LD_INT 0
88469: ST_TO_ADDR
// if not units then
88470: LD_VAR 0 2
88474: NOT
88475: IFFALSE 88479
// exit ;
88477: GO 88524
// for i in units do
88479: LD_ADDR_VAR 0 4
88483: PUSH
88484: LD_VAR 0 2
88488: PUSH
88489: FOR_IN
88490: IFFALSE 88522
// if See ( side , i ) then
88492: LD_VAR 0 1
88496: PPUSH
88497: LD_VAR 0 4
88501: PPUSH
88502: CALL_OW 292
88506: IFFALSE 88520
// begin result := true ;
88508: LD_ADDR_VAR 0 3
88512: PUSH
88513: LD_INT 1
88515: ST_TO_ADDR
// exit ;
88516: POP
88517: POP
88518: GO 88524
// end ;
88520: GO 88489
88522: POP
88523: POP
// end ;
88524: LD_VAR 0 3
88528: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
88529: LD_INT 0
88531: PPUSH
88532: PPUSH
88533: PPUSH
88534: PPUSH
// if not unit or not points then
88535: LD_VAR 0 1
88539: NOT
88540: PUSH
88541: LD_VAR 0 2
88545: NOT
88546: OR
88547: IFFALSE 88551
// exit ;
88549: GO 88641
// dist := 99999 ;
88551: LD_ADDR_VAR 0 5
88555: PUSH
88556: LD_INT 99999
88558: ST_TO_ADDR
// for i in points do
88559: LD_ADDR_VAR 0 4
88563: PUSH
88564: LD_VAR 0 2
88568: PUSH
88569: FOR_IN
88570: IFFALSE 88639
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
88572: LD_ADDR_VAR 0 6
88576: PUSH
88577: LD_VAR 0 1
88581: PPUSH
88582: LD_VAR 0 4
88586: PUSH
88587: LD_INT 1
88589: ARRAY
88590: PPUSH
88591: LD_VAR 0 4
88595: PUSH
88596: LD_INT 2
88598: ARRAY
88599: PPUSH
88600: CALL_OW 297
88604: ST_TO_ADDR
// if tmpDist < dist then
88605: LD_VAR 0 6
88609: PUSH
88610: LD_VAR 0 5
88614: LESS
88615: IFFALSE 88637
// begin result := i ;
88617: LD_ADDR_VAR 0 3
88621: PUSH
88622: LD_VAR 0 4
88626: ST_TO_ADDR
// dist := tmpDist ;
88627: LD_ADDR_VAR 0 5
88631: PUSH
88632: LD_VAR 0 6
88636: ST_TO_ADDR
// end ; end ;
88637: GO 88569
88639: POP
88640: POP
// end ; end_of_file
88641: LD_VAR 0 3
88645: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
88646: LD_INT 0
88648: PPUSH
// ar_miner := 81 ;
88649: LD_ADDR_EXP 101
88653: PUSH
88654: LD_INT 81
88656: ST_TO_ADDR
// ar_crane := 88 ;
88657: LD_ADDR_EXP 100
88661: PUSH
88662: LD_INT 88
88664: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
88665: LD_ADDR_EXP 95
88669: PUSH
88670: LD_INT 89
88672: ST_TO_ADDR
// us_hack := 99 ;
88673: LD_ADDR_EXP 96
88677: PUSH
88678: LD_INT 99
88680: ST_TO_ADDR
// us_artillery := 97 ;
88681: LD_ADDR_EXP 97
88685: PUSH
88686: LD_INT 97
88688: ST_TO_ADDR
// ar_bio_bomb := 91 ;
88689: LD_ADDR_EXP 98
88693: PUSH
88694: LD_INT 91
88696: ST_TO_ADDR
// ar_mortar := 92 ;
88697: LD_ADDR_EXP 99
88701: PUSH
88702: LD_INT 92
88704: ST_TO_ADDR
// ru_radar := 98 ;
88705: LD_ADDR_EXP 94
88709: PUSH
88710: LD_INT 98
88712: ST_TO_ADDR
// tech_Artillery := 80 ;
88713: LD_ADDR_EXP 102
88717: PUSH
88718: LD_INT 80
88720: ST_TO_ADDR
// tech_RadMat := 81 ;
88721: LD_ADDR_EXP 103
88725: PUSH
88726: LD_INT 81
88728: ST_TO_ADDR
// tech_BasicTools := 82 ;
88729: LD_ADDR_EXP 104
88733: PUSH
88734: LD_INT 82
88736: ST_TO_ADDR
// tech_Cargo := 83 ;
88737: LD_ADDR_EXP 105
88741: PUSH
88742: LD_INT 83
88744: ST_TO_ADDR
// tech_Track := 84 ;
88745: LD_ADDR_EXP 106
88749: PUSH
88750: LD_INT 84
88752: ST_TO_ADDR
// tech_Crane := 85 ;
88753: LD_ADDR_EXP 107
88757: PUSH
88758: LD_INT 85
88760: ST_TO_ADDR
// tech_Bulldozer := 86 ;
88761: LD_ADDR_EXP 108
88765: PUSH
88766: LD_INT 86
88768: ST_TO_ADDR
// tech_Hovercraft := 87 ;
88769: LD_ADDR_EXP 109
88773: PUSH
88774: LD_INT 87
88776: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
88777: LD_ADDR_EXP 110
88781: PUSH
88782: LD_INT 88
88784: ST_TO_ADDR
// class_mastodont := 31 ;
88785: LD_ADDR_EXP 111
88789: PUSH
88790: LD_INT 31
88792: ST_TO_ADDR
// class_horse := 21 ;
88793: LD_ADDR_EXP 112
88797: PUSH
88798: LD_INT 21
88800: ST_TO_ADDR
// end ;
88801: LD_VAR 0 1
88805: RET
// every 1 do
88806: GO 88808
88808: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
88809: CALL 88646 0 0
88813: END
// every 0 0$1 do
88814: GO 88816
88816: DISABLE
// begin enable ;
88817: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
88818: LD_STRING updateTimer(
88820: PUSH
88821: LD_OWVAR 1
88825: STR
88826: PUSH
88827: LD_STRING );
88829: STR
88830: PPUSH
88831: CALL_OW 559
// end ;
88835: END
// on MapStart ( p ) do begin if streamModeActive then
88836: LD_EXP 113
88840: IFFALSE 88849
// DefineStreamItems ( true ) ;
88842: LD_INT 1
88844: PPUSH
88845: CALL 90497 0 1
// UpdateFactoryWaypoints ( ) ;
88849: CALL 104081 0 0
// end ;
88853: PPOPN 1
88855: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
88856: LD_INT 0
88858: PPUSH
// if p2 = 100 then
88859: LD_VAR 0 2
88863: PUSH
88864: LD_INT 100
88866: EQUAL
88867: IFFALSE 89870
// begin if not StreamModeActive then
88869: LD_EXP 113
88873: NOT
88874: IFFALSE 88884
// StreamModeActive := true ;
88876: LD_ADDR_EXP 113
88880: PUSH
88881: LD_INT 1
88883: ST_TO_ADDR
// if p3 = 0 then
88884: LD_VAR 0 3
88888: PUSH
88889: LD_INT 0
88891: EQUAL
88892: IFFALSE 88898
// InitStreamMode ;
88894: CALL 90033 0 0
// if p3 = 1 then
88898: LD_VAR 0 3
88902: PUSH
88903: LD_INT 1
88905: EQUAL
88906: IFFALSE 88916
// sRocket := true ;
88908: LD_ADDR_EXP 118
88912: PUSH
88913: LD_INT 1
88915: ST_TO_ADDR
// if p3 = 2 then
88916: LD_VAR 0 3
88920: PUSH
88921: LD_INT 2
88923: EQUAL
88924: IFFALSE 88934
// sSpeed := true ;
88926: LD_ADDR_EXP 117
88930: PUSH
88931: LD_INT 1
88933: ST_TO_ADDR
// if p3 = 3 then
88934: LD_VAR 0 3
88938: PUSH
88939: LD_INT 3
88941: EQUAL
88942: IFFALSE 88952
// sEngine := true ;
88944: LD_ADDR_EXP 119
88948: PUSH
88949: LD_INT 1
88951: ST_TO_ADDR
// if p3 = 4 then
88952: LD_VAR 0 3
88956: PUSH
88957: LD_INT 4
88959: EQUAL
88960: IFFALSE 88970
// sSpec := true ;
88962: LD_ADDR_EXP 116
88966: PUSH
88967: LD_INT 1
88969: ST_TO_ADDR
// if p3 = 5 then
88970: LD_VAR 0 3
88974: PUSH
88975: LD_INT 5
88977: EQUAL
88978: IFFALSE 88988
// sLevel := true ;
88980: LD_ADDR_EXP 120
88984: PUSH
88985: LD_INT 1
88987: ST_TO_ADDR
// if p3 = 6 then
88988: LD_VAR 0 3
88992: PUSH
88993: LD_INT 6
88995: EQUAL
88996: IFFALSE 89006
// sArmoury := true ;
88998: LD_ADDR_EXP 121
89002: PUSH
89003: LD_INT 1
89005: ST_TO_ADDR
// if p3 = 7 then
89006: LD_VAR 0 3
89010: PUSH
89011: LD_INT 7
89013: EQUAL
89014: IFFALSE 89024
// sRadar := true ;
89016: LD_ADDR_EXP 122
89020: PUSH
89021: LD_INT 1
89023: ST_TO_ADDR
// if p3 = 8 then
89024: LD_VAR 0 3
89028: PUSH
89029: LD_INT 8
89031: EQUAL
89032: IFFALSE 89042
// sBunker := true ;
89034: LD_ADDR_EXP 123
89038: PUSH
89039: LD_INT 1
89041: ST_TO_ADDR
// if p3 = 9 then
89042: LD_VAR 0 3
89046: PUSH
89047: LD_INT 9
89049: EQUAL
89050: IFFALSE 89060
// sHack := true ;
89052: LD_ADDR_EXP 124
89056: PUSH
89057: LD_INT 1
89059: ST_TO_ADDR
// if p3 = 10 then
89060: LD_VAR 0 3
89064: PUSH
89065: LD_INT 10
89067: EQUAL
89068: IFFALSE 89078
// sFire := true ;
89070: LD_ADDR_EXP 125
89074: PUSH
89075: LD_INT 1
89077: ST_TO_ADDR
// if p3 = 11 then
89078: LD_VAR 0 3
89082: PUSH
89083: LD_INT 11
89085: EQUAL
89086: IFFALSE 89096
// sRefresh := true ;
89088: LD_ADDR_EXP 126
89092: PUSH
89093: LD_INT 1
89095: ST_TO_ADDR
// if p3 = 12 then
89096: LD_VAR 0 3
89100: PUSH
89101: LD_INT 12
89103: EQUAL
89104: IFFALSE 89114
// sExp := true ;
89106: LD_ADDR_EXP 127
89110: PUSH
89111: LD_INT 1
89113: ST_TO_ADDR
// if p3 = 13 then
89114: LD_VAR 0 3
89118: PUSH
89119: LD_INT 13
89121: EQUAL
89122: IFFALSE 89132
// sDepot := true ;
89124: LD_ADDR_EXP 128
89128: PUSH
89129: LD_INT 1
89131: ST_TO_ADDR
// if p3 = 14 then
89132: LD_VAR 0 3
89136: PUSH
89137: LD_INT 14
89139: EQUAL
89140: IFFALSE 89150
// sFlag := true ;
89142: LD_ADDR_EXP 129
89146: PUSH
89147: LD_INT 1
89149: ST_TO_ADDR
// if p3 = 15 then
89150: LD_VAR 0 3
89154: PUSH
89155: LD_INT 15
89157: EQUAL
89158: IFFALSE 89168
// sKamikadze := true ;
89160: LD_ADDR_EXP 137
89164: PUSH
89165: LD_INT 1
89167: ST_TO_ADDR
// if p3 = 16 then
89168: LD_VAR 0 3
89172: PUSH
89173: LD_INT 16
89175: EQUAL
89176: IFFALSE 89186
// sTroll := true ;
89178: LD_ADDR_EXP 138
89182: PUSH
89183: LD_INT 1
89185: ST_TO_ADDR
// if p3 = 17 then
89186: LD_VAR 0 3
89190: PUSH
89191: LD_INT 17
89193: EQUAL
89194: IFFALSE 89204
// sSlow := true ;
89196: LD_ADDR_EXP 139
89200: PUSH
89201: LD_INT 1
89203: ST_TO_ADDR
// if p3 = 18 then
89204: LD_VAR 0 3
89208: PUSH
89209: LD_INT 18
89211: EQUAL
89212: IFFALSE 89222
// sLack := true ;
89214: LD_ADDR_EXP 140
89218: PUSH
89219: LD_INT 1
89221: ST_TO_ADDR
// if p3 = 19 then
89222: LD_VAR 0 3
89226: PUSH
89227: LD_INT 19
89229: EQUAL
89230: IFFALSE 89240
// sTank := true ;
89232: LD_ADDR_EXP 142
89236: PUSH
89237: LD_INT 1
89239: ST_TO_ADDR
// if p3 = 20 then
89240: LD_VAR 0 3
89244: PUSH
89245: LD_INT 20
89247: EQUAL
89248: IFFALSE 89258
// sRemote := true ;
89250: LD_ADDR_EXP 143
89254: PUSH
89255: LD_INT 1
89257: ST_TO_ADDR
// if p3 = 21 then
89258: LD_VAR 0 3
89262: PUSH
89263: LD_INT 21
89265: EQUAL
89266: IFFALSE 89276
// sPowell := true ;
89268: LD_ADDR_EXP 144
89272: PUSH
89273: LD_INT 1
89275: ST_TO_ADDR
// if p3 = 22 then
89276: LD_VAR 0 3
89280: PUSH
89281: LD_INT 22
89283: EQUAL
89284: IFFALSE 89294
// sTeleport := true ;
89286: LD_ADDR_EXP 147
89290: PUSH
89291: LD_INT 1
89293: ST_TO_ADDR
// if p3 = 23 then
89294: LD_VAR 0 3
89298: PUSH
89299: LD_INT 23
89301: EQUAL
89302: IFFALSE 89312
// sOilTower := true ;
89304: LD_ADDR_EXP 149
89308: PUSH
89309: LD_INT 1
89311: ST_TO_ADDR
// if p3 = 24 then
89312: LD_VAR 0 3
89316: PUSH
89317: LD_INT 24
89319: EQUAL
89320: IFFALSE 89330
// sShovel := true ;
89322: LD_ADDR_EXP 150
89326: PUSH
89327: LD_INT 1
89329: ST_TO_ADDR
// if p3 = 25 then
89330: LD_VAR 0 3
89334: PUSH
89335: LD_INT 25
89337: EQUAL
89338: IFFALSE 89348
// sSheik := true ;
89340: LD_ADDR_EXP 151
89344: PUSH
89345: LD_INT 1
89347: ST_TO_ADDR
// if p3 = 26 then
89348: LD_VAR 0 3
89352: PUSH
89353: LD_INT 26
89355: EQUAL
89356: IFFALSE 89366
// sEarthquake := true ;
89358: LD_ADDR_EXP 153
89362: PUSH
89363: LD_INT 1
89365: ST_TO_ADDR
// if p3 = 27 then
89366: LD_VAR 0 3
89370: PUSH
89371: LD_INT 27
89373: EQUAL
89374: IFFALSE 89384
// sAI := true ;
89376: LD_ADDR_EXP 154
89380: PUSH
89381: LD_INT 1
89383: ST_TO_ADDR
// if p3 = 28 then
89384: LD_VAR 0 3
89388: PUSH
89389: LD_INT 28
89391: EQUAL
89392: IFFALSE 89402
// sCargo := true ;
89394: LD_ADDR_EXP 157
89398: PUSH
89399: LD_INT 1
89401: ST_TO_ADDR
// if p3 = 29 then
89402: LD_VAR 0 3
89406: PUSH
89407: LD_INT 29
89409: EQUAL
89410: IFFALSE 89420
// sDLaser := true ;
89412: LD_ADDR_EXP 158
89416: PUSH
89417: LD_INT 1
89419: ST_TO_ADDR
// if p3 = 30 then
89420: LD_VAR 0 3
89424: PUSH
89425: LD_INT 30
89427: EQUAL
89428: IFFALSE 89438
// sExchange := true ;
89430: LD_ADDR_EXP 159
89434: PUSH
89435: LD_INT 1
89437: ST_TO_ADDR
// if p3 = 31 then
89438: LD_VAR 0 3
89442: PUSH
89443: LD_INT 31
89445: EQUAL
89446: IFFALSE 89456
// sFac := true ;
89448: LD_ADDR_EXP 160
89452: PUSH
89453: LD_INT 1
89455: ST_TO_ADDR
// if p3 = 32 then
89456: LD_VAR 0 3
89460: PUSH
89461: LD_INT 32
89463: EQUAL
89464: IFFALSE 89474
// sPower := true ;
89466: LD_ADDR_EXP 161
89470: PUSH
89471: LD_INT 1
89473: ST_TO_ADDR
// if p3 = 33 then
89474: LD_VAR 0 3
89478: PUSH
89479: LD_INT 33
89481: EQUAL
89482: IFFALSE 89492
// sRandom := true ;
89484: LD_ADDR_EXP 162
89488: PUSH
89489: LD_INT 1
89491: ST_TO_ADDR
// if p3 = 34 then
89492: LD_VAR 0 3
89496: PUSH
89497: LD_INT 34
89499: EQUAL
89500: IFFALSE 89510
// sShield := true ;
89502: LD_ADDR_EXP 163
89506: PUSH
89507: LD_INT 1
89509: ST_TO_ADDR
// if p3 = 35 then
89510: LD_VAR 0 3
89514: PUSH
89515: LD_INT 35
89517: EQUAL
89518: IFFALSE 89528
// sTime := true ;
89520: LD_ADDR_EXP 164
89524: PUSH
89525: LD_INT 1
89527: ST_TO_ADDR
// if p3 = 36 then
89528: LD_VAR 0 3
89532: PUSH
89533: LD_INT 36
89535: EQUAL
89536: IFFALSE 89546
// sTools := true ;
89538: LD_ADDR_EXP 165
89542: PUSH
89543: LD_INT 1
89545: ST_TO_ADDR
// if p3 = 101 then
89546: LD_VAR 0 3
89550: PUSH
89551: LD_INT 101
89553: EQUAL
89554: IFFALSE 89564
// sSold := true ;
89556: LD_ADDR_EXP 130
89560: PUSH
89561: LD_INT 1
89563: ST_TO_ADDR
// if p3 = 102 then
89564: LD_VAR 0 3
89568: PUSH
89569: LD_INT 102
89571: EQUAL
89572: IFFALSE 89582
// sDiff := true ;
89574: LD_ADDR_EXP 131
89578: PUSH
89579: LD_INT 1
89581: ST_TO_ADDR
// if p3 = 103 then
89582: LD_VAR 0 3
89586: PUSH
89587: LD_INT 103
89589: EQUAL
89590: IFFALSE 89600
// sFog := true ;
89592: LD_ADDR_EXP 134
89596: PUSH
89597: LD_INT 1
89599: ST_TO_ADDR
// if p3 = 104 then
89600: LD_VAR 0 3
89604: PUSH
89605: LD_INT 104
89607: EQUAL
89608: IFFALSE 89618
// sReset := true ;
89610: LD_ADDR_EXP 135
89614: PUSH
89615: LD_INT 1
89617: ST_TO_ADDR
// if p3 = 105 then
89618: LD_VAR 0 3
89622: PUSH
89623: LD_INT 105
89625: EQUAL
89626: IFFALSE 89636
// sSun := true ;
89628: LD_ADDR_EXP 136
89632: PUSH
89633: LD_INT 1
89635: ST_TO_ADDR
// if p3 = 106 then
89636: LD_VAR 0 3
89640: PUSH
89641: LD_INT 106
89643: EQUAL
89644: IFFALSE 89654
// sTiger := true ;
89646: LD_ADDR_EXP 132
89650: PUSH
89651: LD_INT 1
89653: ST_TO_ADDR
// if p3 = 107 then
89654: LD_VAR 0 3
89658: PUSH
89659: LD_INT 107
89661: EQUAL
89662: IFFALSE 89672
// sBomb := true ;
89664: LD_ADDR_EXP 133
89668: PUSH
89669: LD_INT 1
89671: ST_TO_ADDR
// if p3 = 108 then
89672: LD_VAR 0 3
89676: PUSH
89677: LD_INT 108
89679: EQUAL
89680: IFFALSE 89690
// sWound := true ;
89682: LD_ADDR_EXP 141
89686: PUSH
89687: LD_INT 1
89689: ST_TO_ADDR
// if p3 = 109 then
89690: LD_VAR 0 3
89694: PUSH
89695: LD_INT 109
89697: EQUAL
89698: IFFALSE 89708
// sBetray := true ;
89700: LD_ADDR_EXP 145
89704: PUSH
89705: LD_INT 1
89707: ST_TO_ADDR
// if p3 = 110 then
89708: LD_VAR 0 3
89712: PUSH
89713: LD_INT 110
89715: EQUAL
89716: IFFALSE 89726
// sContamin := true ;
89718: LD_ADDR_EXP 146
89722: PUSH
89723: LD_INT 1
89725: ST_TO_ADDR
// if p3 = 111 then
89726: LD_VAR 0 3
89730: PUSH
89731: LD_INT 111
89733: EQUAL
89734: IFFALSE 89744
// sOil := true ;
89736: LD_ADDR_EXP 148
89740: PUSH
89741: LD_INT 1
89743: ST_TO_ADDR
// if p3 = 112 then
89744: LD_VAR 0 3
89748: PUSH
89749: LD_INT 112
89751: EQUAL
89752: IFFALSE 89762
// sStu := true ;
89754: LD_ADDR_EXP 152
89758: PUSH
89759: LD_INT 1
89761: ST_TO_ADDR
// if p3 = 113 then
89762: LD_VAR 0 3
89766: PUSH
89767: LD_INT 113
89769: EQUAL
89770: IFFALSE 89780
// sBazooka := true ;
89772: LD_ADDR_EXP 155
89776: PUSH
89777: LD_INT 1
89779: ST_TO_ADDR
// if p3 = 114 then
89780: LD_VAR 0 3
89784: PUSH
89785: LD_INT 114
89787: EQUAL
89788: IFFALSE 89798
// sMortar := true ;
89790: LD_ADDR_EXP 156
89794: PUSH
89795: LD_INT 1
89797: ST_TO_ADDR
// if p3 = 115 then
89798: LD_VAR 0 3
89802: PUSH
89803: LD_INT 115
89805: EQUAL
89806: IFFALSE 89816
// sRanger := true ;
89808: LD_ADDR_EXP 166
89812: PUSH
89813: LD_INT 1
89815: ST_TO_ADDR
// if p3 = 116 then
89816: LD_VAR 0 3
89820: PUSH
89821: LD_INT 116
89823: EQUAL
89824: IFFALSE 89834
// sComputer := true ;
89826: LD_ADDR_EXP 167
89830: PUSH
89831: LD_INT 1
89833: ST_TO_ADDR
// if p3 = 117 then
89834: LD_VAR 0 3
89838: PUSH
89839: LD_INT 117
89841: EQUAL
89842: IFFALSE 89852
// s30 := true ;
89844: LD_ADDR_EXP 168
89848: PUSH
89849: LD_INT 1
89851: ST_TO_ADDR
// if p3 = 118 then
89852: LD_VAR 0 3
89856: PUSH
89857: LD_INT 118
89859: EQUAL
89860: IFFALSE 89870
// s60 := true ;
89862: LD_ADDR_EXP 169
89866: PUSH
89867: LD_INT 1
89869: ST_TO_ADDR
// end ; if p2 = 101 then
89870: LD_VAR 0 2
89874: PUSH
89875: LD_INT 101
89877: EQUAL
89878: IFFALSE 90006
// begin case p3 of 1 :
89880: LD_VAR 0 3
89884: PUSH
89885: LD_INT 1
89887: DOUBLE
89888: EQUAL
89889: IFTRUE 89893
89891: GO 89900
89893: POP
// hHackUnlimitedResources ; 2 :
89894: CALL 102104 0 0
89898: GO 90006
89900: LD_INT 2
89902: DOUBLE
89903: EQUAL
89904: IFTRUE 89908
89906: GO 89915
89908: POP
// hHackSetLevel10 ; 3 :
89909: CALL 102237 0 0
89913: GO 90006
89915: LD_INT 3
89917: DOUBLE
89918: EQUAL
89919: IFTRUE 89923
89921: GO 89930
89923: POP
// hHackSetLevel10YourUnits ; 4 :
89924: CALL 102322 0 0
89928: GO 90006
89930: LD_INT 4
89932: DOUBLE
89933: EQUAL
89934: IFTRUE 89938
89936: GO 89945
89938: POP
// hHackInvincible ; 5 :
89939: CALL 102770 0 0
89943: GO 90006
89945: LD_INT 5
89947: DOUBLE
89948: EQUAL
89949: IFTRUE 89953
89951: GO 89960
89953: POP
// hHackInvisible ; 6 :
89954: CALL 102881 0 0
89958: GO 90006
89960: LD_INT 6
89962: DOUBLE
89963: EQUAL
89964: IFTRUE 89968
89966: GO 89975
89968: POP
// hHackChangeYourSide ; 7 :
89969: CALL 102938 0 0
89973: GO 90006
89975: LD_INT 7
89977: DOUBLE
89978: EQUAL
89979: IFTRUE 89983
89981: GO 89990
89983: POP
// hHackChangeUnitSide ; 8 :
89984: CALL 102980 0 0
89988: GO 90006
89990: LD_INT 8
89992: DOUBLE
89993: EQUAL
89994: IFTRUE 89998
89996: GO 90005
89998: POP
// hHackFog ; end ;
89999: CALL 103081 0 0
90003: GO 90006
90005: POP
// end ; end ;
90006: LD_VAR 0 7
90010: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
90011: GO 90013
90013: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
90014: LD_STRING initStreamRollete();
90016: PPUSH
90017: CALL_OW 559
// InitStreamMode ;
90021: CALL 90033 0 0
// DefineStreamItems ( false ) ;
90025: LD_INT 0
90027: PPUSH
90028: CALL 90497 0 1
// end ;
90032: END
// function InitStreamMode ; begin
90033: LD_INT 0
90035: PPUSH
// streamModeActive := false ;
90036: LD_ADDR_EXP 113
90040: PUSH
90041: LD_INT 0
90043: ST_TO_ADDR
// normalCounter := 36 ;
90044: LD_ADDR_EXP 114
90048: PUSH
90049: LD_INT 36
90051: ST_TO_ADDR
// hardcoreCounter := 18 ;
90052: LD_ADDR_EXP 115
90056: PUSH
90057: LD_INT 18
90059: ST_TO_ADDR
// sRocket := false ;
90060: LD_ADDR_EXP 118
90064: PUSH
90065: LD_INT 0
90067: ST_TO_ADDR
// sSpeed := false ;
90068: LD_ADDR_EXP 117
90072: PUSH
90073: LD_INT 0
90075: ST_TO_ADDR
// sEngine := false ;
90076: LD_ADDR_EXP 119
90080: PUSH
90081: LD_INT 0
90083: ST_TO_ADDR
// sSpec := false ;
90084: LD_ADDR_EXP 116
90088: PUSH
90089: LD_INT 0
90091: ST_TO_ADDR
// sLevel := false ;
90092: LD_ADDR_EXP 120
90096: PUSH
90097: LD_INT 0
90099: ST_TO_ADDR
// sArmoury := false ;
90100: LD_ADDR_EXP 121
90104: PUSH
90105: LD_INT 0
90107: ST_TO_ADDR
// sRadar := false ;
90108: LD_ADDR_EXP 122
90112: PUSH
90113: LD_INT 0
90115: ST_TO_ADDR
// sBunker := false ;
90116: LD_ADDR_EXP 123
90120: PUSH
90121: LD_INT 0
90123: ST_TO_ADDR
// sHack := false ;
90124: LD_ADDR_EXP 124
90128: PUSH
90129: LD_INT 0
90131: ST_TO_ADDR
// sFire := false ;
90132: LD_ADDR_EXP 125
90136: PUSH
90137: LD_INT 0
90139: ST_TO_ADDR
// sRefresh := false ;
90140: LD_ADDR_EXP 126
90144: PUSH
90145: LD_INT 0
90147: ST_TO_ADDR
// sExp := false ;
90148: LD_ADDR_EXP 127
90152: PUSH
90153: LD_INT 0
90155: ST_TO_ADDR
// sDepot := false ;
90156: LD_ADDR_EXP 128
90160: PUSH
90161: LD_INT 0
90163: ST_TO_ADDR
// sFlag := false ;
90164: LD_ADDR_EXP 129
90168: PUSH
90169: LD_INT 0
90171: ST_TO_ADDR
// sKamikadze := false ;
90172: LD_ADDR_EXP 137
90176: PUSH
90177: LD_INT 0
90179: ST_TO_ADDR
// sTroll := false ;
90180: LD_ADDR_EXP 138
90184: PUSH
90185: LD_INT 0
90187: ST_TO_ADDR
// sSlow := false ;
90188: LD_ADDR_EXP 139
90192: PUSH
90193: LD_INT 0
90195: ST_TO_ADDR
// sLack := false ;
90196: LD_ADDR_EXP 140
90200: PUSH
90201: LD_INT 0
90203: ST_TO_ADDR
// sTank := false ;
90204: LD_ADDR_EXP 142
90208: PUSH
90209: LD_INT 0
90211: ST_TO_ADDR
// sRemote := false ;
90212: LD_ADDR_EXP 143
90216: PUSH
90217: LD_INT 0
90219: ST_TO_ADDR
// sPowell := false ;
90220: LD_ADDR_EXP 144
90224: PUSH
90225: LD_INT 0
90227: ST_TO_ADDR
// sTeleport := false ;
90228: LD_ADDR_EXP 147
90232: PUSH
90233: LD_INT 0
90235: ST_TO_ADDR
// sOilTower := false ;
90236: LD_ADDR_EXP 149
90240: PUSH
90241: LD_INT 0
90243: ST_TO_ADDR
// sShovel := false ;
90244: LD_ADDR_EXP 150
90248: PUSH
90249: LD_INT 0
90251: ST_TO_ADDR
// sSheik := false ;
90252: LD_ADDR_EXP 151
90256: PUSH
90257: LD_INT 0
90259: ST_TO_ADDR
// sEarthquake := false ;
90260: LD_ADDR_EXP 153
90264: PUSH
90265: LD_INT 0
90267: ST_TO_ADDR
// sAI := false ;
90268: LD_ADDR_EXP 154
90272: PUSH
90273: LD_INT 0
90275: ST_TO_ADDR
// sCargo := false ;
90276: LD_ADDR_EXP 157
90280: PUSH
90281: LD_INT 0
90283: ST_TO_ADDR
// sDLaser := false ;
90284: LD_ADDR_EXP 158
90288: PUSH
90289: LD_INT 0
90291: ST_TO_ADDR
// sExchange := false ;
90292: LD_ADDR_EXP 159
90296: PUSH
90297: LD_INT 0
90299: ST_TO_ADDR
// sFac := false ;
90300: LD_ADDR_EXP 160
90304: PUSH
90305: LD_INT 0
90307: ST_TO_ADDR
// sPower := false ;
90308: LD_ADDR_EXP 161
90312: PUSH
90313: LD_INT 0
90315: ST_TO_ADDR
// sRandom := false ;
90316: LD_ADDR_EXP 162
90320: PUSH
90321: LD_INT 0
90323: ST_TO_ADDR
// sShield := false ;
90324: LD_ADDR_EXP 163
90328: PUSH
90329: LD_INT 0
90331: ST_TO_ADDR
// sTime := false ;
90332: LD_ADDR_EXP 164
90336: PUSH
90337: LD_INT 0
90339: ST_TO_ADDR
// sTools := false ;
90340: LD_ADDR_EXP 165
90344: PUSH
90345: LD_INT 0
90347: ST_TO_ADDR
// sSold := false ;
90348: LD_ADDR_EXP 130
90352: PUSH
90353: LD_INT 0
90355: ST_TO_ADDR
// sDiff := false ;
90356: LD_ADDR_EXP 131
90360: PUSH
90361: LD_INT 0
90363: ST_TO_ADDR
// sFog := false ;
90364: LD_ADDR_EXP 134
90368: PUSH
90369: LD_INT 0
90371: ST_TO_ADDR
// sReset := false ;
90372: LD_ADDR_EXP 135
90376: PUSH
90377: LD_INT 0
90379: ST_TO_ADDR
// sSun := false ;
90380: LD_ADDR_EXP 136
90384: PUSH
90385: LD_INT 0
90387: ST_TO_ADDR
// sTiger := false ;
90388: LD_ADDR_EXP 132
90392: PUSH
90393: LD_INT 0
90395: ST_TO_ADDR
// sBomb := false ;
90396: LD_ADDR_EXP 133
90400: PUSH
90401: LD_INT 0
90403: ST_TO_ADDR
// sWound := false ;
90404: LD_ADDR_EXP 141
90408: PUSH
90409: LD_INT 0
90411: ST_TO_ADDR
// sBetray := false ;
90412: LD_ADDR_EXP 145
90416: PUSH
90417: LD_INT 0
90419: ST_TO_ADDR
// sContamin := false ;
90420: LD_ADDR_EXP 146
90424: PUSH
90425: LD_INT 0
90427: ST_TO_ADDR
// sOil := false ;
90428: LD_ADDR_EXP 148
90432: PUSH
90433: LD_INT 0
90435: ST_TO_ADDR
// sStu := false ;
90436: LD_ADDR_EXP 152
90440: PUSH
90441: LD_INT 0
90443: ST_TO_ADDR
// sBazooka := false ;
90444: LD_ADDR_EXP 155
90448: PUSH
90449: LD_INT 0
90451: ST_TO_ADDR
// sMortar := false ;
90452: LD_ADDR_EXP 156
90456: PUSH
90457: LD_INT 0
90459: ST_TO_ADDR
// sRanger := false ;
90460: LD_ADDR_EXP 166
90464: PUSH
90465: LD_INT 0
90467: ST_TO_ADDR
// sComputer := false ;
90468: LD_ADDR_EXP 167
90472: PUSH
90473: LD_INT 0
90475: ST_TO_ADDR
// s30 := false ;
90476: LD_ADDR_EXP 168
90480: PUSH
90481: LD_INT 0
90483: ST_TO_ADDR
// s60 := false ;
90484: LD_ADDR_EXP 169
90488: PUSH
90489: LD_INT 0
90491: ST_TO_ADDR
// end ;
90492: LD_VAR 0 1
90496: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
90497: LD_INT 0
90499: PPUSH
90500: PPUSH
90501: PPUSH
90502: PPUSH
90503: PPUSH
90504: PPUSH
90505: PPUSH
// result := [ ] ;
90506: LD_ADDR_VAR 0 2
90510: PUSH
90511: EMPTY
90512: ST_TO_ADDR
// if campaign_id = 1 then
90513: LD_OWVAR 69
90517: PUSH
90518: LD_INT 1
90520: EQUAL
90521: IFFALSE 93687
// begin case mission_number of 1 :
90523: LD_OWVAR 70
90527: PUSH
90528: LD_INT 1
90530: DOUBLE
90531: EQUAL
90532: IFTRUE 90536
90534: GO 90612
90536: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
90537: LD_ADDR_VAR 0 2
90541: PUSH
90542: LD_INT 2
90544: PUSH
90545: LD_INT 4
90547: PUSH
90548: LD_INT 11
90550: PUSH
90551: LD_INT 12
90553: PUSH
90554: LD_INT 15
90556: PUSH
90557: LD_INT 16
90559: PUSH
90560: LD_INT 22
90562: PUSH
90563: LD_INT 23
90565: PUSH
90566: LD_INT 26
90568: PUSH
90569: EMPTY
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: PUSH
90580: LD_INT 101
90582: PUSH
90583: LD_INT 102
90585: PUSH
90586: LD_INT 106
90588: PUSH
90589: LD_INT 116
90591: PUSH
90592: LD_INT 117
90594: PUSH
90595: LD_INT 118
90597: PUSH
90598: EMPTY
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: PUSH
90606: EMPTY
90607: LIST
90608: LIST
90609: ST_TO_ADDR
90610: GO 93685
90612: LD_INT 2
90614: DOUBLE
90615: EQUAL
90616: IFTRUE 90620
90618: GO 90704
90620: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
90621: LD_ADDR_VAR 0 2
90625: PUSH
90626: LD_INT 2
90628: PUSH
90629: LD_INT 4
90631: PUSH
90632: LD_INT 11
90634: PUSH
90635: LD_INT 12
90637: PUSH
90638: LD_INT 15
90640: PUSH
90641: LD_INT 16
90643: PUSH
90644: LD_INT 22
90646: PUSH
90647: LD_INT 23
90649: PUSH
90650: LD_INT 26
90652: PUSH
90653: EMPTY
90654: LIST
90655: LIST
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: PUSH
90664: LD_INT 101
90666: PUSH
90667: LD_INT 102
90669: PUSH
90670: LD_INT 105
90672: PUSH
90673: LD_INT 106
90675: PUSH
90676: LD_INT 108
90678: PUSH
90679: LD_INT 116
90681: PUSH
90682: LD_INT 117
90684: PUSH
90685: LD_INT 118
90687: PUSH
90688: EMPTY
90689: LIST
90690: LIST
90691: LIST
90692: LIST
90693: LIST
90694: LIST
90695: LIST
90696: LIST
90697: PUSH
90698: EMPTY
90699: LIST
90700: LIST
90701: ST_TO_ADDR
90702: GO 93685
90704: LD_INT 3
90706: DOUBLE
90707: EQUAL
90708: IFTRUE 90712
90710: GO 90800
90712: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
90713: LD_ADDR_VAR 0 2
90717: PUSH
90718: LD_INT 2
90720: PUSH
90721: LD_INT 4
90723: PUSH
90724: LD_INT 5
90726: PUSH
90727: LD_INT 11
90729: PUSH
90730: LD_INT 12
90732: PUSH
90733: LD_INT 15
90735: PUSH
90736: LD_INT 16
90738: PUSH
90739: LD_INT 22
90741: PUSH
90742: LD_INT 26
90744: PUSH
90745: LD_INT 36
90747: PUSH
90748: EMPTY
90749: LIST
90750: LIST
90751: LIST
90752: LIST
90753: LIST
90754: LIST
90755: LIST
90756: LIST
90757: LIST
90758: LIST
90759: PUSH
90760: LD_INT 101
90762: PUSH
90763: LD_INT 102
90765: PUSH
90766: LD_INT 105
90768: PUSH
90769: LD_INT 106
90771: PUSH
90772: LD_INT 108
90774: PUSH
90775: LD_INT 116
90777: PUSH
90778: LD_INT 117
90780: PUSH
90781: LD_INT 118
90783: PUSH
90784: EMPTY
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: PUSH
90794: EMPTY
90795: LIST
90796: LIST
90797: ST_TO_ADDR
90798: GO 93685
90800: LD_INT 4
90802: DOUBLE
90803: EQUAL
90804: IFTRUE 90808
90806: GO 90904
90808: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
90809: LD_ADDR_VAR 0 2
90813: PUSH
90814: LD_INT 2
90816: PUSH
90817: LD_INT 4
90819: PUSH
90820: LD_INT 5
90822: PUSH
90823: LD_INT 8
90825: PUSH
90826: LD_INT 11
90828: PUSH
90829: LD_INT 12
90831: PUSH
90832: LD_INT 15
90834: PUSH
90835: LD_INT 16
90837: PUSH
90838: LD_INT 22
90840: PUSH
90841: LD_INT 23
90843: PUSH
90844: LD_INT 26
90846: PUSH
90847: LD_INT 36
90849: PUSH
90850: EMPTY
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: LIST
90856: LIST
90857: LIST
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: PUSH
90864: LD_INT 101
90866: PUSH
90867: LD_INT 102
90869: PUSH
90870: LD_INT 105
90872: PUSH
90873: LD_INT 106
90875: PUSH
90876: LD_INT 108
90878: PUSH
90879: LD_INT 116
90881: PUSH
90882: LD_INT 117
90884: PUSH
90885: LD_INT 118
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: LIST
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: ST_TO_ADDR
90902: GO 93685
90904: LD_INT 5
90906: DOUBLE
90907: EQUAL
90908: IFTRUE 90912
90910: GO 91024
90912: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
90913: LD_ADDR_VAR 0 2
90917: PUSH
90918: LD_INT 2
90920: PUSH
90921: LD_INT 4
90923: PUSH
90924: LD_INT 5
90926: PUSH
90927: LD_INT 6
90929: PUSH
90930: LD_INT 8
90932: PUSH
90933: LD_INT 11
90935: PUSH
90936: LD_INT 12
90938: PUSH
90939: LD_INT 15
90941: PUSH
90942: LD_INT 16
90944: PUSH
90945: LD_INT 22
90947: PUSH
90948: LD_INT 23
90950: PUSH
90951: LD_INT 25
90953: PUSH
90954: LD_INT 26
90956: PUSH
90957: LD_INT 36
90959: PUSH
90960: EMPTY
90961: LIST
90962: LIST
90963: LIST
90964: LIST
90965: LIST
90966: LIST
90967: LIST
90968: LIST
90969: LIST
90970: LIST
90971: LIST
90972: LIST
90973: LIST
90974: LIST
90975: PUSH
90976: LD_INT 101
90978: PUSH
90979: LD_INT 102
90981: PUSH
90982: LD_INT 105
90984: PUSH
90985: LD_INT 106
90987: PUSH
90988: LD_INT 108
90990: PUSH
90991: LD_INT 109
90993: PUSH
90994: LD_INT 112
90996: PUSH
90997: LD_INT 116
90999: PUSH
91000: LD_INT 117
91002: PUSH
91003: LD_INT 118
91005: PUSH
91006: EMPTY
91007: LIST
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: PUSH
91018: EMPTY
91019: LIST
91020: LIST
91021: ST_TO_ADDR
91022: GO 93685
91024: LD_INT 6
91026: DOUBLE
91027: EQUAL
91028: IFTRUE 91032
91030: GO 91164
91032: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
91033: LD_ADDR_VAR 0 2
91037: PUSH
91038: LD_INT 2
91040: PUSH
91041: LD_INT 4
91043: PUSH
91044: LD_INT 5
91046: PUSH
91047: LD_INT 6
91049: PUSH
91050: LD_INT 8
91052: PUSH
91053: LD_INT 11
91055: PUSH
91056: LD_INT 12
91058: PUSH
91059: LD_INT 15
91061: PUSH
91062: LD_INT 16
91064: PUSH
91065: LD_INT 20
91067: PUSH
91068: LD_INT 21
91070: PUSH
91071: LD_INT 22
91073: PUSH
91074: LD_INT 23
91076: PUSH
91077: LD_INT 25
91079: PUSH
91080: LD_INT 26
91082: PUSH
91083: LD_INT 30
91085: PUSH
91086: LD_INT 31
91088: PUSH
91089: LD_INT 32
91091: PUSH
91092: LD_INT 36
91094: PUSH
91095: EMPTY
91096: LIST
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: LIST
91102: LIST
91103: LIST
91104: LIST
91105: LIST
91106: LIST
91107: LIST
91108: LIST
91109: LIST
91110: LIST
91111: LIST
91112: LIST
91113: LIST
91114: LIST
91115: PUSH
91116: LD_INT 101
91118: PUSH
91119: LD_INT 102
91121: PUSH
91122: LD_INT 105
91124: PUSH
91125: LD_INT 106
91127: PUSH
91128: LD_INT 108
91130: PUSH
91131: LD_INT 109
91133: PUSH
91134: LD_INT 112
91136: PUSH
91137: LD_INT 116
91139: PUSH
91140: LD_INT 117
91142: PUSH
91143: LD_INT 118
91145: PUSH
91146: EMPTY
91147: LIST
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: LIST
91154: LIST
91155: LIST
91156: LIST
91157: PUSH
91158: EMPTY
91159: LIST
91160: LIST
91161: ST_TO_ADDR
91162: GO 93685
91164: LD_INT 7
91166: DOUBLE
91167: EQUAL
91168: IFTRUE 91172
91170: GO 91284
91172: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
91173: LD_ADDR_VAR 0 2
91177: PUSH
91178: LD_INT 2
91180: PUSH
91181: LD_INT 4
91183: PUSH
91184: LD_INT 5
91186: PUSH
91187: LD_INT 7
91189: PUSH
91190: LD_INT 11
91192: PUSH
91193: LD_INT 12
91195: PUSH
91196: LD_INT 15
91198: PUSH
91199: LD_INT 16
91201: PUSH
91202: LD_INT 20
91204: PUSH
91205: LD_INT 21
91207: PUSH
91208: LD_INT 22
91210: PUSH
91211: LD_INT 23
91213: PUSH
91214: LD_INT 25
91216: PUSH
91217: LD_INT 26
91219: PUSH
91220: EMPTY
91221: LIST
91222: LIST
91223: LIST
91224: LIST
91225: LIST
91226: LIST
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: LIST
91232: LIST
91233: LIST
91234: LIST
91235: PUSH
91236: LD_INT 101
91238: PUSH
91239: LD_INT 102
91241: PUSH
91242: LD_INT 103
91244: PUSH
91245: LD_INT 105
91247: PUSH
91248: LD_INT 106
91250: PUSH
91251: LD_INT 108
91253: PUSH
91254: LD_INT 112
91256: PUSH
91257: LD_INT 116
91259: PUSH
91260: LD_INT 117
91262: PUSH
91263: LD_INT 118
91265: PUSH
91266: EMPTY
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: LIST
91273: LIST
91274: LIST
91275: LIST
91276: LIST
91277: PUSH
91278: EMPTY
91279: LIST
91280: LIST
91281: ST_TO_ADDR
91282: GO 93685
91284: LD_INT 8
91286: DOUBLE
91287: EQUAL
91288: IFTRUE 91292
91290: GO 91432
91292: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
91293: LD_ADDR_VAR 0 2
91297: PUSH
91298: LD_INT 2
91300: PUSH
91301: LD_INT 4
91303: PUSH
91304: LD_INT 5
91306: PUSH
91307: LD_INT 6
91309: PUSH
91310: LD_INT 7
91312: PUSH
91313: LD_INT 8
91315: PUSH
91316: LD_INT 11
91318: PUSH
91319: LD_INT 12
91321: PUSH
91322: LD_INT 15
91324: PUSH
91325: LD_INT 16
91327: PUSH
91328: LD_INT 20
91330: PUSH
91331: LD_INT 21
91333: PUSH
91334: LD_INT 22
91336: PUSH
91337: LD_INT 23
91339: PUSH
91340: LD_INT 25
91342: PUSH
91343: LD_INT 26
91345: PUSH
91346: LD_INT 30
91348: PUSH
91349: LD_INT 31
91351: PUSH
91352: LD_INT 32
91354: PUSH
91355: LD_INT 36
91357: PUSH
91358: EMPTY
91359: LIST
91360: LIST
91361: LIST
91362: LIST
91363: LIST
91364: LIST
91365: LIST
91366: LIST
91367: LIST
91368: LIST
91369: LIST
91370: LIST
91371: LIST
91372: LIST
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: LIST
91379: PUSH
91380: LD_INT 101
91382: PUSH
91383: LD_INT 102
91385: PUSH
91386: LD_INT 103
91388: PUSH
91389: LD_INT 105
91391: PUSH
91392: LD_INT 106
91394: PUSH
91395: LD_INT 108
91397: PUSH
91398: LD_INT 109
91400: PUSH
91401: LD_INT 112
91403: PUSH
91404: LD_INT 116
91406: PUSH
91407: LD_INT 117
91409: PUSH
91410: LD_INT 118
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: LIST
91417: LIST
91418: LIST
91419: LIST
91420: LIST
91421: LIST
91422: LIST
91423: LIST
91424: LIST
91425: PUSH
91426: EMPTY
91427: LIST
91428: LIST
91429: ST_TO_ADDR
91430: GO 93685
91432: LD_INT 9
91434: DOUBLE
91435: EQUAL
91436: IFTRUE 91440
91438: GO 91588
91440: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
91441: LD_ADDR_VAR 0 2
91445: PUSH
91446: LD_INT 2
91448: PUSH
91449: LD_INT 4
91451: PUSH
91452: LD_INT 5
91454: PUSH
91455: LD_INT 6
91457: PUSH
91458: LD_INT 7
91460: PUSH
91461: LD_INT 8
91463: PUSH
91464: LD_INT 11
91466: PUSH
91467: LD_INT 12
91469: PUSH
91470: LD_INT 15
91472: PUSH
91473: LD_INT 16
91475: PUSH
91476: LD_INT 20
91478: PUSH
91479: LD_INT 21
91481: PUSH
91482: LD_INT 22
91484: PUSH
91485: LD_INT 23
91487: PUSH
91488: LD_INT 25
91490: PUSH
91491: LD_INT 26
91493: PUSH
91494: LD_INT 28
91496: PUSH
91497: LD_INT 30
91499: PUSH
91500: LD_INT 31
91502: PUSH
91503: LD_INT 32
91505: PUSH
91506: LD_INT 36
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: LIST
91516: LIST
91517: LIST
91518: LIST
91519: LIST
91520: LIST
91521: LIST
91522: LIST
91523: LIST
91524: LIST
91525: LIST
91526: LIST
91527: LIST
91528: LIST
91529: LIST
91530: LIST
91531: PUSH
91532: LD_INT 101
91534: PUSH
91535: LD_INT 102
91537: PUSH
91538: LD_INT 103
91540: PUSH
91541: LD_INT 105
91543: PUSH
91544: LD_INT 106
91546: PUSH
91547: LD_INT 108
91549: PUSH
91550: LD_INT 109
91552: PUSH
91553: LD_INT 112
91555: PUSH
91556: LD_INT 114
91558: PUSH
91559: LD_INT 116
91561: PUSH
91562: LD_INT 117
91564: PUSH
91565: LD_INT 118
91567: PUSH
91568: EMPTY
91569: LIST
91570: LIST
91571: LIST
91572: LIST
91573: LIST
91574: LIST
91575: LIST
91576: LIST
91577: LIST
91578: LIST
91579: LIST
91580: LIST
91581: PUSH
91582: EMPTY
91583: LIST
91584: LIST
91585: ST_TO_ADDR
91586: GO 93685
91588: LD_INT 10
91590: DOUBLE
91591: EQUAL
91592: IFTRUE 91596
91594: GO 91792
91596: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
91597: LD_ADDR_VAR 0 2
91601: PUSH
91602: LD_INT 2
91604: PUSH
91605: LD_INT 4
91607: PUSH
91608: LD_INT 5
91610: PUSH
91611: LD_INT 6
91613: PUSH
91614: LD_INT 7
91616: PUSH
91617: LD_INT 8
91619: PUSH
91620: LD_INT 9
91622: PUSH
91623: LD_INT 10
91625: PUSH
91626: LD_INT 11
91628: PUSH
91629: LD_INT 12
91631: PUSH
91632: LD_INT 13
91634: PUSH
91635: LD_INT 14
91637: PUSH
91638: LD_INT 15
91640: PUSH
91641: LD_INT 16
91643: PUSH
91644: LD_INT 17
91646: PUSH
91647: LD_INT 18
91649: PUSH
91650: LD_INT 19
91652: PUSH
91653: LD_INT 20
91655: PUSH
91656: LD_INT 21
91658: PUSH
91659: LD_INT 22
91661: PUSH
91662: LD_INT 23
91664: PUSH
91665: LD_INT 24
91667: PUSH
91668: LD_INT 25
91670: PUSH
91671: LD_INT 26
91673: PUSH
91674: LD_INT 28
91676: PUSH
91677: LD_INT 30
91679: PUSH
91680: LD_INT 31
91682: PUSH
91683: LD_INT 32
91685: PUSH
91686: LD_INT 36
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: LIST
91702: LIST
91703: LIST
91704: LIST
91705: LIST
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: PUSH
91720: LD_INT 101
91722: PUSH
91723: LD_INT 102
91725: PUSH
91726: LD_INT 103
91728: PUSH
91729: LD_INT 104
91731: PUSH
91732: LD_INT 105
91734: PUSH
91735: LD_INT 106
91737: PUSH
91738: LD_INT 107
91740: PUSH
91741: LD_INT 108
91743: PUSH
91744: LD_INT 109
91746: PUSH
91747: LD_INT 110
91749: PUSH
91750: LD_INT 111
91752: PUSH
91753: LD_INT 112
91755: PUSH
91756: LD_INT 114
91758: PUSH
91759: LD_INT 116
91761: PUSH
91762: LD_INT 117
91764: PUSH
91765: LD_INT 118
91767: PUSH
91768: EMPTY
91769: LIST
91770: LIST
91771: LIST
91772: LIST
91773: LIST
91774: LIST
91775: LIST
91776: LIST
91777: LIST
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: LIST
91785: PUSH
91786: EMPTY
91787: LIST
91788: LIST
91789: ST_TO_ADDR
91790: GO 93685
91792: LD_INT 11
91794: DOUBLE
91795: EQUAL
91796: IFTRUE 91800
91798: GO 92004
91800: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
91801: LD_ADDR_VAR 0 2
91805: PUSH
91806: LD_INT 2
91808: PUSH
91809: LD_INT 3
91811: PUSH
91812: LD_INT 4
91814: PUSH
91815: LD_INT 5
91817: PUSH
91818: LD_INT 6
91820: PUSH
91821: LD_INT 7
91823: PUSH
91824: LD_INT 8
91826: PUSH
91827: LD_INT 9
91829: PUSH
91830: LD_INT 10
91832: PUSH
91833: LD_INT 11
91835: PUSH
91836: LD_INT 12
91838: PUSH
91839: LD_INT 13
91841: PUSH
91842: LD_INT 14
91844: PUSH
91845: LD_INT 15
91847: PUSH
91848: LD_INT 16
91850: PUSH
91851: LD_INT 17
91853: PUSH
91854: LD_INT 18
91856: PUSH
91857: LD_INT 19
91859: PUSH
91860: LD_INT 20
91862: PUSH
91863: LD_INT 21
91865: PUSH
91866: LD_INT 22
91868: PUSH
91869: LD_INT 23
91871: PUSH
91872: LD_INT 24
91874: PUSH
91875: LD_INT 25
91877: PUSH
91878: LD_INT 26
91880: PUSH
91881: LD_INT 28
91883: PUSH
91884: LD_INT 30
91886: PUSH
91887: LD_INT 31
91889: PUSH
91890: LD_INT 32
91892: PUSH
91893: LD_INT 34
91895: PUSH
91896: LD_INT 36
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: LIST
91903: LIST
91904: LIST
91905: LIST
91906: LIST
91907: LIST
91908: LIST
91909: LIST
91910: LIST
91911: LIST
91912: LIST
91913: LIST
91914: LIST
91915: LIST
91916: LIST
91917: LIST
91918: LIST
91919: LIST
91920: LIST
91921: LIST
91922: LIST
91923: LIST
91924: LIST
91925: LIST
91926: LIST
91927: LIST
91928: LIST
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 101
91934: PUSH
91935: LD_INT 102
91937: PUSH
91938: LD_INT 103
91940: PUSH
91941: LD_INT 104
91943: PUSH
91944: LD_INT 105
91946: PUSH
91947: LD_INT 106
91949: PUSH
91950: LD_INT 107
91952: PUSH
91953: LD_INT 108
91955: PUSH
91956: LD_INT 109
91958: PUSH
91959: LD_INT 110
91961: PUSH
91962: LD_INT 111
91964: PUSH
91965: LD_INT 112
91967: PUSH
91968: LD_INT 114
91970: PUSH
91971: LD_INT 116
91973: PUSH
91974: LD_INT 117
91976: PUSH
91977: LD_INT 118
91979: PUSH
91980: EMPTY
91981: LIST
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: PUSH
91998: EMPTY
91999: LIST
92000: LIST
92001: ST_TO_ADDR
92002: GO 93685
92004: LD_INT 12
92006: DOUBLE
92007: EQUAL
92008: IFTRUE 92012
92010: GO 92232
92012: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
92013: LD_ADDR_VAR 0 2
92017: PUSH
92018: LD_INT 1
92020: PUSH
92021: LD_INT 2
92023: PUSH
92024: LD_INT 3
92026: PUSH
92027: LD_INT 4
92029: PUSH
92030: LD_INT 5
92032: PUSH
92033: LD_INT 6
92035: PUSH
92036: LD_INT 7
92038: PUSH
92039: LD_INT 8
92041: PUSH
92042: LD_INT 9
92044: PUSH
92045: LD_INT 10
92047: PUSH
92048: LD_INT 11
92050: PUSH
92051: LD_INT 12
92053: PUSH
92054: LD_INT 13
92056: PUSH
92057: LD_INT 14
92059: PUSH
92060: LD_INT 15
92062: PUSH
92063: LD_INT 16
92065: PUSH
92066: LD_INT 17
92068: PUSH
92069: LD_INT 18
92071: PUSH
92072: LD_INT 19
92074: PUSH
92075: LD_INT 20
92077: PUSH
92078: LD_INT 21
92080: PUSH
92081: LD_INT 22
92083: PUSH
92084: LD_INT 23
92086: PUSH
92087: LD_INT 24
92089: PUSH
92090: LD_INT 25
92092: PUSH
92093: LD_INT 26
92095: PUSH
92096: LD_INT 27
92098: PUSH
92099: LD_INT 28
92101: PUSH
92102: LD_INT 30
92104: PUSH
92105: LD_INT 31
92107: PUSH
92108: LD_INT 32
92110: PUSH
92111: LD_INT 33
92113: PUSH
92114: LD_INT 34
92116: PUSH
92117: LD_INT 36
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: LIST
92124: LIST
92125: LIST
92126: LIST
92127: LIST
92128: LIST
92129: LIST
92130: LIST
92131: LIST
92132: LIST
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: LIST
92140: LIST
92141: LIST
92142: LIST
92143: LIST
92144: LIST
92145: LIST
92146: LIST
92147: LIST
92148: LIST
92149: LIST
92150: LIST
92151: LIST
92152: LIST
92153: LIST
92154: LIST
92155: PUSH
92156: LD_INT 101
92158: PUSH
92159: LD_INT 102
92161: PUSH
92162: LD_INT 103
92164: PUSH
92165: LD_INT 104
92167: PUSH
92168: LD_INT 105
92170: PUSH
92171: LD_INT 106
92173: PUSH
92174: LD_INT 107
92176: PUSH
92177: LD_INT 108
92179: PUSH
92180: LD_INT 109
92182: PUSH
92183: LD_INT 110
92185: PUSH
92186: LD_INT 111
92188: PUSH
92189: LD_INT 112
92191: PUSH
92192: LD_INT 113
92194: PUSH
92195: LD_INT 114
92197: PUSH
92198: LD_INT 116
92200: PUSH
92201: LD_INT 117
92203: PUSH
92204: LD_INT 118
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: LIST
92215: LIST
92216: LIST
92217: LIST
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: LIST
92225: PUSH
92226: EMPTY
92227: LIST
92228: LIST
92229: ST_TO_ADDR
92230: GO 93685
92232: LD_INT 13
92234: DOUBLE
92235: EQUAL
92236: IFTRUE 92240
92238: GO 92448
92240: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
92241: LD_ADDR_VAR 0 2
92245: PUSH
92246: LD_INT 1
92248: PUSH
92249: LD_INT 2
92251: PUSH
92252: LD_INT 3
92254: PUSH
92255: LD_INT 4
92257: PUSH
92258: LD_INT 5
92260: PUSH
92261: LD_INT 8
92263: PUSH
92264: LD_INT 9
92266: PUSH
92267: LD_INT 10
92269: PUSH
92270: LD_INT 11
92272: PUSH
92273: LD_INT 12
92275: PUSH
92276: LD_INT 14
92278: PUSH
92279: LD_INT 15
92281: PUSH
92282: LD_INT 16
92284: PUSH
92285: LD_INT 17
92287: PUSH
92288: LD_INT 18
92290: PUSH
92291: LD_INT 19
92293: PUSH
92294: LD_INT 20
92296: PUSH
92297: LD_INT 21
92299: PUSH
92300: LD_INT 22
92302: PUSH
92303: LD_INT 23
92305: PUSH
92306: LD_INT 24
92308: PUSH
92309: LD_INT 25
92311: PUSH
92312: LD_INT 26
92314: PUSH
92315: LD_INT 27
92317: PUSH
92318: LD_INT 28
92320: PUSH
92321: LD_INT 30
92323: PUSH
92324: LD_INT 31
92326: PUSH
92327: LD_INT 32
92329: PUSH
92330: LD_INT 33
92332: PUSH
92333: LD_INT 34
92335: PUSH
92336: LD_INT 36
92338: PUSH
92339: EMPTY
92340: LIST
92341: LIST
92342: LIST
92343: LIST
92344: LIST
92345: LIST
92346: LIST
92347: LIST
92348: LIST
92349: LIST
92350: LIST
92351: LIST
92352: LIST
92353: LIST
92354: LIST
92355: LIST
92356: LIST
92357: LIST
92358: LIST
92359: LIST
92360: LIST
92361: LIST
92362: LIST
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: PUSH
92372: LD_INT 101
92374: PUSH
92375: LD_INT 102
92377: PUSH
92378: LD_INT 103
92380: PUSH
92381: LD_INT 104
92383: PUSH
92384: LD_INT 105
92386: PUSH
92387: LD_INT 106
92389: PUSH
92390: LD_INT 107
92392: PUSH
92393: LD_INT 108
92395: PUSH
92396: LD_INT 109
92398: PUSH
92399: LD_INT 110
92401: PUSH
92402: LD_INT 111
92404: PUSH
92405: LD_INT 112
92407: PUSH
92408: LD_INT 113
92410: PUSH
92411: LD_INT 114
92413: PUSH
92414: LD_INT 116
92416: PUSH
92417: LD_INT 117
92419: PUSH
92420: LD_INT 118
92422: PUSH
92423: EMPTY
92424: LIST
92425: LIST
92426: LIST
92427: LIST
92428: LIST
92429: LIST
92430: LIST
92431: LIST
92432: LIST
92433: LIST
92434: LIST
92435: LIST
92436: LIST
92437: LIST
92438: LIST
92439: LIST
92440: LIST
92441: PUSH
92442: EMPTY
92443: LIST
92444: LIST
92445: ST_TO_ADDR
92446: GO 93685
92448: LD_INT 14
92450: DOUBLE
92451: EQUAL
92452: IFTRUE 92456
92454: GO 92680
92456: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
92457: LD_ADDR_VAR 0 2
92461: PUSH
92462: LD_INT 1
92464: PUSH
92465: LD_INT 2
92467: PUSH
92468: LD_INT 3
92470: PUSH
92471: LD_INT 4
92473: PUSH
92474: LD_INT 5
92476: PUSH
92477: LD_INT 6
92479: PUSH
92480: LD_INT 7
92482: PUSH
92483: LD_INT 8
92485: PUSH
92486: LD_INT 9
92488: PUSH
92489: LD_INT 10
92491: PUSH
92492: LD_INT 11
92494: PUSH
92495: LD_INT 12
92497: PUSH
92498: LD_INT 13
92500: PUSH
92501: LD_INT 14
92503: PUSH
92504: LD_INT 15
92506: PUSH
92507: LD_INT 16
92509: PUSH
92510: LD_INT 17
92512: PUSH
92513: LD_INT 18
92515: PUSH
92516: LD_INT 19
92518: PUSH
92519: LD_INT 20
92521: PUSH
92522: LD_INT 21
92524: PUSH
92525: LD_INT 22
92527: PUSH
92528: LD_INT 23
92530: PUSH
92531: LD_INT 24
92533: PUSH
92534: LD_INT 25
92536: PUSH
92537: LD_INT 26
92539: PUSH
92540: LD_INT 27
92542: PUSH
92543: LD_INT 28
92545: PUSH
92546: LD_INT 29
92548: PUSH
92549: LD_INT 30
92551: PUSH
92552: LD_INT 31
92554: PUSH
92555: LD_INT 32
92557: PUSH
92558: LD_INT 33
92560: PUSH
92561: LD_INT 34
92563: PUSH
92564: LD_INT 36
92566: PUSH
92567: EMPTY
92568: LIST
92569: LIST
92570: LIST
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: LIST
92576: LIST
92577: LIST
92578: LIST
92579: LIST
92580: LIST
92581: LIST
92582: LIST
92583: LIST
92584: LIST
92585: LIST
92586: LIST
92587: LIST
92588: LIST
92589: LIST
92590: LIST
92591: LIST
92592: LIST
92593: LIST
92594: LIST
92595: LIST
92596: LIST
92597: LIST
92598: LIST
92599: LIST
92600: LIST
92601: LIST
92602: LIST
92603: PUSH
92604: LD_INT 101
92606: PUSH
92607: LD_INT 102
92609: PUSH
92610: LD_INT 103
92612: PUSH
92613: LD_INT 104
92615: PUSH
92616: LD_INT 105
92618: PUSH
92619: LD_INT 106
92621: PUSH
92622: LD_INT 107
92624: PUSH
92625: LD_INT 108
92627: PUSH
92628: LD_INT 109
92630: PUSH
92631: LD_INT 110
92633: PUSH
92634: LD_INT 111
92636: PUSH
92637: LD_INT 112
92639: PUSH
92640: LD_INT 113
92642: PUSH
92643: LD_INT 114
92645: PUSH
92646: LD_INT 116
92648: PUSH
92649: LD_INT 117
92651: PUSH
92652: LD_INT 118
92654: PUSH
92655: EMPTY
92656: LIST
92657: LIST
92658: LIST
92659: LIST
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: PUSH
92674: EMPTY
92675: LIST
92676: LIST
92677: ST_TO_ADDR
92678: GO 93685
92680: LD_INT 15
92682: DOUBLE
92683: EQUAL
92684: IFTRUE 92688
92686: GO 92912
92688: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
92689: LD_ADDR_VAR 0 2
92693: PUSH
92694: LD_INT 1
92696: PUSH
92697: LD_INT 2
92699: PUSH
92700: LD_INT 3
92702: PUSH
92703: LD_INT 4
92705: PUSH
92706: LD_INT 5
92708: PUSH
92709: LD_INT 6
92711: PUSH
92712: LD_INT 7
92714: PUSH
92715: LD_INT 8
92717: PUSH
92718: LD_INT 9
92720: PUSH
92721: LD_INT 10
92723: PUSH
92724: LD_INT 11
92726: PUSH
92727: LD_INT 12
92729: PUSH
92730: LD_INT 13
92732: PUSH
92733: LD_INT 14
92735: PUSH
92736: LD_INT 15
92738: PUSH
92739: LD_INT 16
92741: PUSH
92742: LD_INT 17
92744: PUSH
92745: LD_INT 18
92747: PUSH
92748: LD_INT 19
92750: PUSH
92751: LD_INT 20
92753: PUSH
92754: LD_INT 21
92756: PUSH
92757: LD_INT 22
92759: PUSH
92760: LD_INT 23
92762: PUSH
92763: LD_INT 24
92765: PUSH
92766: LD_INT 25
92768: PUSH
92769: LD_INT 26
92771: PUSH
92772: LD_INT 27
92774: PUSH
92775: LD_INT 28
92777: PUSH
92778: LD_INT 29
92780: PUSH
92781: LD_INT 30
92783: PUSH
92784: LD_INT 31
92786: PUSH
92787: LD_INT 32
92789: PUSH
92790: LD_INT 33
92792: PUSH
92793: LD_INT 34
92795: PUSH
92796: LD_INT 36
92798: PUSH
92799: EMPTY
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: LIST
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: PUSH
92836: LD_INT 101
92838: PUSH
92839: LD_INT 102
92841: PUSH
92842: LD_INT 103
92844: PUSH
92845: LD_INT 104
92847: PUSH
92848: LD_INT 105
92850: PUSH
92851: LD_INT 106
92853: PUSH
92854: LD_INT 107
92856: PUSH
92857: LD_INT 108
92859: PUSH
92860: LD_INT 109
92862: PUSH
92863: LD_INT 110
92865: PUSH
92866: LD_INT 111
92868: PUSH
92869: LD_INT 112
92871: PUSH
92872: LD_INT 113
92874: PUSH
92875: LD_INT 114
92877: PUSH
92878: LD_INT 116
92880: PUSH
92881: LD_INT 117
92883: PUSH
92884: LD_INT 118
92886: PUSH
92887: EMPTY
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: LIST
92896: LIST
92897: LIST
92898: LIST
92899: LIST
92900: LIST
92901: LIST
92902: LIST
92903: LIST
92904: LIST
92905: PUSH
92906: EMPTY
92907: LIST
92908: LIST
92909: ST_TO_ADDR
92910: GO 93685
92912: LD_INT 16
92914: DOUBLE
92915: EQUAL
92916: IFTRUE 92920
92918: GO 93056
92920: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
92921: LD_ADDR_VAR 0 2
92925: PUSH
92926: LD_INT 2
92928: PUSH
92929: LD_INT 4
92931: PUSH
92932: LD_INT 5
92934: PUSH
92935: LD_INT 7
92937: PUSH
92938: LD_INT 11
92940: PUSH
92941: LD_INT 12
92943: PUSH
92944: LD_INT 15
92946: PUSH
92947: LD_INT 16
92949: PUSH
92950: LD_INT 20
92952: PUSH
92953: LD_INT 21
92955: PUSH
92956: LD_INT 22
92958: PUSH
92959: LD_INT 23
92961: PUSH
92962: LD_INT 25
92964: PUSH
92965: LD_INT 26
92967: PUSH
92968: LD_INT 30
92970: PUSH
92971: LD_INT 31
92973: PUSH
92974: LD_INT 32
92976: PUSH
92977: LD_INT 33
92979: PUSH
92980: LD_INT 34
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: LIST
92989: LIST
92990: LIST
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: LIST
92999: LIST
93000: LIST
93001: LIST
93002: LIST
93003: PUSH
93004: LD_INT 101
93006: PUSH
93007: LD_INT 102
93009: PUSH
93010: LD_INT 103
93012: PUSH
93013: LD_INT 106
93015: PUSH
93016: LD_INT 108
93018: PUSH
93019: LD_INT 112
93021: PUSH
93022: LD_INT 113
93024: PUSH
93025: LD_INT 114
93027: PUSH
93028: LD_INT 116
93030: PUSH
93031: LD_INT 117
93033: PUSH
93034: LD_INT 118
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: LIST
93046: LIST
93047: LIST
93048: LIST
93049: PUSH
93050: EMPTY
93051: LIST
93052: LIST
93053: ST_TO_ADDR
93054: GO 93685
93056: LD_INT 17
93058: DOUBLE
93059: EQUAL
93060: IFTRUE 93064
93062: GO 93288
93064: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
93065: LD_ADDR_VAR 0 2
93069: PUSH
93070: LD_INT 1
93072: PUSH
93073: LD_INT 2
93075: PUSH
93076: LD_INT 3
93078: PUSH
93079: LD_INT 4
93081: PUSH
93082: LD_INT 5
93084: PUSH
93085: LD_INT 6
93087: PUSH
93088: LD_INT 7
93090: PUSH
93091: LD_INT 8
93093: PUSH
93094: LD_INT 9
93096: PUSH
93097: LD_INT 10
93099: PUSH
93100: LD_INT 11
93102: PUSH
93103: LD_INT 12
93105: PUSH
93106: LD_INT 13
93108: PUSH
93109: LD_INT 14
93111: PUSH
93112: LD_INT 15
93114: PUSH
93115: LD_INT 16
93117: PUSH
93118: LD_INT 17
93120: PUSH
93121: LD_INT 18
93123: PUSH
93124: LD_INT 19
93126: PUSH
93127: LD_INT 20
93129: PUSH
93130: LD_INT 21
93132: PUSH
93133: LD_INT 22
93135: PUSH
93136: LD_INT 23
93138: PUSH
93139: LD_INT 24
93141: PUSH
93142: LD_INT 25
93144: PUSH
93145: LD_INT 26
93147: PUSH
93148: LD_INT 27
93150: PUSH
93151: LD_INT 28
93153: PUSH
93154: LD_INT 29
93156: PUSH
93157: LD_INT 30
93159: PUSH
93160: LD_INT 31
93162: PUSH
93163: LD_INT 32
93165: PUSH
93166: LD_INT 33
93168: PUSH
93169: LD_INT 34
93171: PUSH
93172: LD_INT 36
93174: PUSH
93175: EMPTY
93176: LIST
93177: LIST
93178: LIST
93179: LIST
93180: LIST
93181: LIST
93182: LIST
93183: LIST
93184: LIST
93185: LIST
93186: LIST
93187: LIST
93188: LIST
93189: LIST
93190: LIST
93191: LIST
93192: LIST
93193: LIST
93194: LIST
93195: LIST
93196: LIST
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: PUSH
93212: LD_INT 101
93214: PUSH
93215: LD_INT 102
93217: PUSH
93218: LD_INT 103
93220: PUSH
93221: LD_INT 104
93223: PUSH
93224: LD_INT 105
93226: PUSH
93227: LD_INT 106
93229: PUSH
93230: LD_INT 107
93232: PUSH
93233: LD_INT 108
93235: PUSH
93236: LD_INT 109
93238: PUSH
93239: LD_INT 110
93241: PUSH
93242: LD_INT 111
93244: PUSH
93245: LD_INT 112
93247: PUSH
93248: LD_INT 113
93250: PUSH
93251: LD_INT 114
93253: PUSH
93254: LD_INT 116
93256: PUSH
93257: LD_INT 117
93259: PUSH
93260: LD_INT 118
93262: PUSH
93263: EMPTY
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: LIST
93270: LIST
93271: LIST
93272: LIST
93273: LIST
93274: LIST
93275: LIST
93276: LIST
93277: LIST
93278: LIST
93279: LIST
93280: LIST
93281: PUSH
93282: EMPTY
93283: LIST
93284: LIST
93285: ST_TO_ADDR
93286: GO 93685
93288: LD_INT 18
93290: DOUBLE
93291: EQUAL
93292: IFTRUE 93296
93294: GO 93444
93296: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
93297: LD_ADDR_VAR 0 2
93301: PUSH
93302: LD_INT 2
93304: PUSH
93305: LD_INT 4
93307: PUSH
93308: LD_INT 5
93310: PUSH
93311: LD_INT 7
93313: PUSH
93314: LD_INT 11
93316: PUSH
93317: LD_INT 12
93319: PUSH
93320: LD_INT 15
93322: PUSH
93323: LD_INT 16
93325: PUSH
93326: LD_INT 20
93328: PUSH
93329: LD_INT 21
93331: PUSH
93332: LD_INT 22
93334: PUSH
93335: LD_INT 23
93337: PUSH
93338: LD_INT 25
93340: PUSH
93341: LD_INT 26
93343: PUSH
93344: LD_INT 30
93346: PUSH
93347: LD_INT 31
93349: PUSH
93350: LD_INT 32
93352: PUSH
93353: LD_INT 33
93355: PUSH
93356: LD_INT 34
93358: PUSH
93359: LD_INT 35
93361: PUSH
93362: LD_INT 36
93364: PUSH
93365: EMPTY
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: PUSH
93388: LD_INT 101
93390: PUSH
93391: LD_INT 102
93393: PUSH
93394: LD_INT 103
93396: PUSH
93397: LD_INT 106
93399: PUSH
93400: LD_INT 108
93402: PUSH
93403: LD_INT 112
93405: PUSH
93406: LD_INT 113
93408: PUSH
93409: LD_INT 114
93411: PUSH
93412: LD_INT 115
93414: PUSH
93415: LD_INT 116
93417: PUSH
93418: LD_INT 117
93420: PUSH
93421: LD_INT 118
93423: PUSH
93424: EMPTY
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: LIST
93435: LIST
93436: LIST
93437: PUSH
93438: EMPTY
93439: LIST
93440: LIST
93441: ST_TO_ADDR
93442: GO 93685
93444: LD_INT 19
93446: DOUBLE
93447: EQUAL
93448: IFTRUE 93452
93450: GO 93684
93452: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
93453: LD_ADDR_VAR 0 2
93457: PUSH
93458: LD_INT 1
93460: PUSH
93461: LD_INT 2
93463: PUSH
93464: LD_INT 3
93466: PUSH
93467: LD_INT 4
93469: PUSH
93470: LD_INT 5
93472: PUSH
93473: LD_INT 6
93475: PUSH
93476: LD_INT 7
93478: PUSH
93479: LD_INT 8
93481: PUSH
93482: LD_INT 9
93484: PUSH
93485: LD_INT 10
93487: PUSH
93488: LD_INT 11
93490: PUSH
93491: LD_INT 12
93493: PUSH
93494: LD_INT 13
93496: PUSH
93497: LD_INT 14
93499: PUSH
93500: LD_INT 15
93502: PUSH
93503: LD_INT 16
93505: PUSH
93506: LD_INT 17
93508: PUSH
93509: LD_INT 18
93511: PUSH
93512: LD_INT 19
93514: PUSH
93515: LD_INT 20
93517: PUSH
93518: LD_INT 21
93520: PUSH
93521: LD_INT 22
93523: PUSH
93524: LD_INT 23
93526: PUSH
93527: LD_INT 24
93529: PUSH
93530: LD_INT 25
93532: PUSH
93533: LD_INT 26
93535: PUSH
93536: LD_INT 27
93538: PUSH
93539: LD_INT 28
93541: PUSH
93542: LD_INT 29
93544: PUSH
93545: LD_INT 30
93547: PUSH
93548: LD_INT 31
93550: PUSH
93551: LD_INT 32
93553: PUSH
93554: LD_INT 33
93556: PUSH
93557: LD_INT 34
93559: PUSH
93560: LD_INT 35
93562: PUSH
93563: LD_INT 36
93565: PUSH
93566: EMPTY
93567: LIST
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: LIST
93587: LIST
93588: LIST
93589: LIST
93590: LIST
93591: LIST
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: PUSH
93604: LD_INT 101
93606: PUSH
93607: LD_INT 102
93609: PUSH
93610: LD_INT 103
93612: PUSH
93613: LD_INT 104
93615: PUSH
93616: LD_INT 105
93618: PUSH
93619: LD_INT 106
93621: PUSH
93622: LD_INT 107
93624: PUSH
93625: LD_INT 108
93627: PUSH
93628: LD_INT 109
93630: PUSH
93631: LD_INT 110
93633: PUSH
93634: LD_INT 111
93636: PUSH
93637: LD_INT 112
93639: PUSH
93640: LD_INT 113
93642: PUSH
93643: LD_INT 114
93645: PUSH
93646: LD_INT 115
93648: PUSH
93649: LD_INT 116
93651: PUSH
93652: LD_INT 117
93654: PUSH
93655: LD_INT 118
93657: PUSH
93658: EMPTY
93659: LIST
93660: LIST
93661: LIST
93662: LIST
93663: LIST
93664: LIST
93665: LIST
93666: LIST
93667: LIST
93668: LIST
93669: LIST
93670: LIST
93671: LIST
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: PUSH
93678: EMPTY
93679: LIST
93680: LIST
93681: ST_TO_ADDR
93682: GO 93685
93684: POP
// end else
93685: GO 93916
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
93687: LD_ADDR_VAR 0 2
93691: PUSH
93692: LD_INT 1
93694: PUSH
93695: LD_INT 2
93697: PUSH
93698: LD_INT 3
93700: PUSH
93701: LD_INT 4
93703: PUSH
93704: LD_INT 5
93706: PUSH
93707: LD_INT 6
93709: PUSH
93710: LD_INT 7
93712: PUSH
93713: LD_INT 8
93715: PUSH
93716: LD_INT 9
93718: PUSH
93719: LD_INT 10
93721: PUSH
93722: LD_INT 11
93724: PUSH
93725: LD_INT 12
93727: PUSH
93728: LD_INT 13
93730: PUSH
93731: LD_INT 14
93733: PUSH
93734: LD_INT 15
93736: PUSH
93737: LD_INT 16
93739: PUSH
93740: LD_INT 17
93742: PUSH
93743: LD_INT 18
93745: PUSH
93746: LD_INT 19
93748: PUSH
93749: LD_INT 20
93751: PUSH
93752: LD_INT 21
93754: PUSH
93755: LD_INT 22
93757: PUSH
93758: LD_INT 23
93760: PUSH
93761: LD_INT 24
93763: PUSH
93764: LD_INT 25
93766: PUSH
93767: LD_INT 26
93769: PUSH
93770: LD_INT 27
93772: PUSH
93773: LD_INT 28
93775: PUSH
93776: LD_INT 29
93778: PUSH
93779: LD_INT 30
93781: PUSH
93782: LD_INT 31
93784: PUSH
93785: LD_INT 32
93787: PUSH
93788: LD_INT 33
93790: PUSH
93791: LD_INT 34
93793: PUSH
93794: LD_INT 35
93796: PUSH
93797: LD_INT 36
93799: PUSH
93800: EMPTY
93801: LIST
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: LIST
93807: LIST
93808: LIST
93809: LIST
93810: LIST
93811: LIST
93812: LIST
93813: LIST
93814: LIST
93815: LIST
93816: LIST
93817: LIST
93818: LIST
93819: LIST
93820: LIST
93821: LIST
93822: LIST
93823: LIST
93824: LIST
93825: LIST
93826: LIST
93827: LIST
93828: LIST
93829: LIST
93830: LIST
93831: LIST
93832: LIST
93833: LIST
93834: LIST
93835: LIST
93836: LIST
93837: PUSH
93838: LD_INT 101
93840: PUSH
93841: LD_INT 102
93843: PUSH
93844: LD_INT 103
93846: PUSH
93847: LD_INT 104
93849: PUSH
93850: LD_INT 105
93852: PUSH
93853: LD_INT 106
93855: PUSH
93856: LD_INT 107
93858: PUSH
93859: LD_INT 108
93861: PUSH
93862: LD_INT 109
93864: PUSH
93865: LD_INT 110
93867: PUSH
93868: LD_INT 111
93870: PUSH
93871: LD_INT 112
93873: PUSH
93874: LD_INT 113
93876: PUSH
93877: LD_INT 114
93879: PUSH
93880: LD_INT 115
93882: PUSH
93883: LD_INT 116
93885: PUSH
93886: LD_INT 117
93888: PUSH
93889: LD_INT 118
93891: PUSH
93892: EMPTY
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: PUSH
93912: EMPTY
93913: LIST
93914: LIST
93915: ST_TO_ADDR
// if result then
93916: LD_VAR 0 2
93920: IFFALSE 94706
// begin normal :=  ;
93922: LD_ADDR_VAR 0 5
93926: PUSH
93927: LD_STRING 
93929: ST_TO_ADDR
// hardcore :=  ;
93930: LD_ADDR_VAR 0 6
93934: PUSH
93935: LD_STRING 
93937: ST_TO_ADDR
// active :=  ;
93938: LD_ADDR_VAR 0 7
93942: PUSH
93943: LD_STRING 
93945: ST_TO_ADDR
// for i = 1 to normalCounter do
93946: LD_ADDR_VAR 0 8
93950: PUSH
93951: DOUBLE
93952: LD_INT 1
93954: DEC
93955: ST_TO_ADDR
93956: LD_EXP 114
93960: PUSH
93961: FOR_TO
93962: IFFALSE 94063
// begin tmp := 0 ;
93964: LD_ADDR_VAR 0 3
93968: PUSH
93969: LD_STRING 0
93971: ST_TO_ADDR
// if result [ 1 ] then
93972: LD_VAR 0 2
93976: PUSH
93977: LD_INT 1
93979: ARRAY
93980: IFFALSE 94045
// if result [ 1 ] [ 1 ] = i then
93982: LD_VAR 0 2
93986: PUSH
93987: LD_INT 1
93989: ARRAY
93990: PUSH
93991: LD_INT 1
93993: ARRAY
93994: PUSH
93995: LD_VAR 0 8
93999: EQUAL
94000: IFFALSE 94045
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
94002: LD_ADDR_VAR 0 2
94006: PUSH
94007: LD_VAR 0 2
94011: PPUSH
94012: LD_INT 1
94014: PPUSH
94015: LD_VAR 0 2
94019: PUSH
94020: LD_INT 1
94022: ARRAY
94023: PPUSH
94024: LD_INT 1
94026: PPUSH
94027: CALL_OW 3
94031: PPUSH
94032: CALL_OW 1
94036: ST_TO_ADDR
// tmp := 1 ;
94037: LD_ADDR_VAR 0 3
94041: PUSH
94042: LD_STRING 1
94044: ST_TO_ADDR
// end ; normal := normal & tmp ;
94045: LD_ADDR_VAR 0 5
94049: PUSH
94050: LD_VAR 0 5
94054: PUSH
94055: LD_VAR 0 3
94059: STR
94060: ST_TO_ADDR
// end ;
94061: GO 93961
94063: POP
94064: POP
// for i = 1 to hardcoreCounter do
94065: LD_ADDR_VAR 0 8
94069: PUSH
94070: DOUBLE
94071: LD_INT 1
94073: DEC
94074: ST_TO_ADDR
94075: LD_EXP 115
94079: PUSH
94080: FOR_TO
94081: IFFALSE 94186
// begin tmp := 0 ;
94083: LD_ADDR_VAR 0 3
94087: PUSH
94088: LD_STRING 0
94090: ST_TO_ADDR
// if result [ 2 ] then
94091: LD_VAR 0 2
94095: PUSH
94096: LD_INT 2
94098: ARRAY
94099: IFFALSE 94168
// if result [ 2 ] [ 1 ] = 100 + i then
94101: LD_VAR 0 2
94105: PUSH
94106: LD_INT 2
94108: ARRAY
94109: PUSH
94110: LD_INT 1
94112: ARRAY
94113: PUSH
94114: LD_INT 100
94116: PUSH
94117: LD_VAR 0 8
94121: PLUS
94122: EQUAL
94123: IFFALSE 94168
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
94125: LD_ADDR_VAR 0 2
94129: PUSH
94130: LD_VAR 0 2
94134: PPUSH
94135: LD_INT 2
94137: PPUSH
94138: LD_VAR 0 2
94142: PUSH
94143: LD_INT 2
94145: ARRAY
94146: PPUSH
94147: LD_INT 1
94149: PPUSH
94150: CALL_OW 3
94154: PPUSH
94155: CALL_OW 1
94159: ST_TO_ADDR
// tmp := 1 ;
94160: LD_ADDR_VAR 0 3
94164: PUSH
94165: LD_STRING 1
94167: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
94168: LD_ADDR_VAR 0 6
94172: PUSH
94173: LD_VAR 0 6
94177: PUSH
94178: LD_VAR 0 3
94182: STR
94183: ST_TO_ADDR
// end ;
94184: GO 94080
94186: POP
94187: POP
// if isGameLoad then
94188: LD_VAR 0 1
94192: IFFALSE 94667
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
94194: LD_ADDR_VAR 0 4
94198: PUSH
94199: LD_EXP 118
94203: PUSH
94204: LD_EXP 117
94208: PUSH
94209: LD_EXP 119
94213: PUSH
94214: LD_EXP 116
94218: PUSH
94219: LD_EXP 120
94223: PUSH
94224: LD_EXP 121
94228: PUSH
94229: LD_EXP 122
94233: PUSH
94234: LD_EXP 123
94238: PUSH
94239: LD_EXP 124
94243: PUSH
94244: LD_EXP 125
94248: PUSH
94249: LD_EXP 126
94253: PUSH
94254: LD_EXP 127
94258: PUSH
94259: LD_EXP 128
94263: PUSH
94264: LD_EXP 129
94268: PUSH
94269: LD_EXP 137
94273: PUSH
94274: LD_EXP 138
94278: PUSH
94279: LD_EXP 139
94283: PUSH
94284: LD_EXP 140
94288: PUSH
94289: LD_EXP 142
94293: PUSH
94294: LD_EXP 143
94298: PUSH
94299: LD_EXP 144
94303: PUSH
94304: LD_EXP 147
94308: PUSH
94309: LD_EXP 149
94313: PUSH
94314: LD_EXP 150
94318: PUSH
94319: LD_EXP 151
94323: PUSH
94324: LD_EXP 153
94328: PUSH
94329: LD_EXP 154
94333: PUSH
94334: LD_EXP 157
94338: PUSH
94339: LD_EXP 158
94343: PUSH
94344: LD_EXP 159
94348: PUSH
94349: LD_EXP 160
94353: PUSH
94354: LD_EXP 161
94358: PUSH
94359: LD_EXP 162
94363: PUSH
94364: LD_EXP 163
94368: PUSH
94369: LD_EXP 164
94373: PUSH
94374: LD_EXP 165
94378: PUSH
94379: LD_EXP 130
94383: PUSH
94384: LD_EXP 131
94388: PUSH
94389: LD_EXP 134
94393: PUSH
94394: LD_EXP 135
94398: PUSH
94399: LD_EXP 136
94403: PUSH
94404: LD_EXP 132
94408: PUSH
94409: LD_EXP 133
94413: PUSH
94414: LD_EXP 141
94418: PUSH
94419: LD_EXP 145
94423: PUSH
94424: LD_EXP 146
94428: PUSH
94429: LD_EXP 148
94433: PUSH
94434: LD_EXP 152
94438: PUSH
94439: LD_EXP 155
94443: PUSH
94444: LD_EXP 156
94448: PUSH
94449: LD_EXP 166
94453: PUSH
94454: LD_EXP 167
94458: PUSH
94459: LD_EXP 168
94463: PUSH
94464: LD_EXP 169
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: LIST
94497: LIST
94498: LIST
94499: LIST
94500: LIST
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: LIST
94513: LIST
94514: LIST
94515: LIST
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: ST_TO_ADDR
// tmp :=  ;
94525: LD_ADDR_VAR 0 3
94529: PUSH
94530: LD_STRING 
94532: ST_TO_ADDR
// for i = 1 to normalCounter do
94533: LD_ADDR_VAR 0 8
94537: PUSH
94538: DOUBLE
94539: LD_INT 1
94541: DEC
94542: ST_TO_ADDR
94543: LD_EXP 114
94547: PUSH
94548: FOR_TO
94549: IFFALSE 94585
// begin if flags [ i ] then
94551: LD_VAR 0 4
94555: PUSH
94556: LD_VAR 0 8
94560: ARRAY
94561: IFFALSE 94583
// tmp := tmp & i & ; ;
94563: LD_ADDR_VAR 0 3
94567: PUSH
94568: LD_VAR 0 3
94572: PUSH
94573: LD_VAR 0 8
94577: STR
94578: PUSH
94579: LD_STRING ;
94581: STR
94582: ST_TO_ADDR
// end ;
94583: GO 94548
94585: POP
94586: POP
// for i = 1 to hardcoreCounter do
94587: LD_ADDR_VAR 0 8
94591: PUSH
94592: DOUBLE
94593: LD_INT 1
94595: DEC
94596: ST_TO_ADDR
94597: LD_EXP 115
94601: PUSH
94602: FOR_TO
94603: IFFALSE 94649
// begin if flags [ normalCounter + i ] then
94605: LD_VAR 0 4
94609: PUSH
94610: LD_EXP 114
94614: PUSH
94615: LD_VAR 0 8
94619: PLUS
94620: ARRAY
94621: IFFALSE 94647
// tmp := tmp & ( 100 + i ) & ; ;
94623: LD_ADDR_VAR 0 3
94627: PUSH
94628: LD_VAR 0 3
94632: PUSH
94633: LD_INT 100
94635: PUSH
94636: LD_VAR 0 8
94640: PLUS
94641: STR
94642: PUSH
94643: LD_STRING ;
94645: STR
94646: ST_TO_ADDR
// end ;
94647: GO 94602
94649: POP
94650: POP
// if tmp then
94651: LD_VAR 0 3
94655: IFFALSE 94667
// active := tmp ;
94657: LD_ADDR_VAR 0 7
94661: PUSH
94662: LD_VAR 0 3
94666: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
94667: LD_STRING getStreamItemsFromMission("
94669: PUSH
94670: LD_VAR 0 5
94674: STR
94675: PUSH
94676: LD_STRING ","
94678: STR
94679: PUSH
94680: LD_VAR 0 6
94684: STR
94685: PUSH
94686: LD_STRING ","
94688: STR
94689: PUSH
94690: LD_VAR 0 7
94694: STR
94695: PUSH
94696: LD_STRING ")
94698: STR
94699: PPUSH
94700: CALL_OW 559
// end else
94704: GO 94713
// ToLua ( getStreamItemsFromMission("","","") ) ;
94706: LD_STRING getStreamItemsFromMission("","","")
94708: PPUSH
94709: CALL_OW 559
// end ;
94713: LD_VAR 0 2
94717: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
94718: LD_EXP 113
94722: PUSH
94723: LD_EXP 118
94727: AND
94728: IFFALSE 94852
94730: GO 94732
94732: DISABLE
94733: LD_INT 0
94735: PPUSH
94736: PPUSH
// begin enable ;
94737: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
94738: LD_ADDR_VAR 0 2
94742: PUSH
94743: LD_INT 22
94745: PUSH
94746: LD_OWVAR 2
94750: PUSH
94751: EMPTY
94752: LIST
94753: LIST
94754: PUSH
94755: LD_INT 2
94757: PUSH
94758: LD_INT 34
94760: PUSH
94761: LD_INT 7
94763: PUSH
94764: EMPTY
94765: LIST
94766: LIST
94767: PUSH
94768: LD_INT 34
94770: PUSH
94771: LD_INT 45
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: PUSH
94778: LD_INT 34
94780: PUSH
94781: LD_INT 28
94783: PUSH
94784: EMPTY
94785: LIST
94786: LIST
94787: PUSH
94788: LD_INT 34
94790: PUSH
94791: LD_INT 47
94793: PUSH
94794: EMPTY
94795: LIST
94796: LIST
94797: PUSH
94798: EMPTY
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: PUSH
94805: EMPTY
94806: LIST
94807: LIST
94808: PPUSH
94809: CALL_OW 69
94813: ST_TO_ADDR
// if not tmp then
94814: LD_VAR 0 2
94818: NOT
94819: IFFALSE 94823
// exit ;
94821: GO 94852
// for i in tmp do
94823: LD_ADDR_VAR 0 1
94827: PUSH
94828: LD_VAR 0 2
94832: PUSH
94833: FOR_IN
94834: IFFALSE 94850
// begin SetLives ( i , 0 ) ;
94836: LD_VAR 0 1
94840: PPUSH
94841: LD_INT 0
94843: PPUSH
94844: CALL_OW 234
// end ;
94848: GO 94833
94850: POP
94851: POP
// end ;
94852: PPOPN 2
94854: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
94855: LD_EXP 113
94859: PUSH
94860: LD_EXP 119
94864: AND
94865: IFFALSE 94949
94867: GO 94869
94869: DISABLE
94870: LD_INT 0
94872: PPUSH
94873: PPUSH
// begin enable ;
94874: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
94875: LD_ADDR_VAR 0 2
94879: PUSH
94880: LD_INT 22
94882: PUSH
94883: LD_OWVAR 2
94887: PUSH
94888: EMPTY
94889: LIST
94890: LIST
94891: PUSH
94892: LD_INT 32
94894: PUSH
94895: LD_INT 3
94897: PUSH
94898: EMPTY
94899: LIST
94900: LIST
94901: PUSH
94902: EMPTY
94903: LIST
94904: LIST
94905: PPUSH
94906: CALL_OW 69
94910: ST_TO_ADDR
// if not tmp then
94911: LD_VAR 0 2
94915: NOT
94916: IFFALSE 94920
// exit ;
94918: GO 94949
// for i in tmp do
94920: LD_ADDR_VAR 0 1
94924: PUSH
94925: LD_VAR 0 2
94929: PUSH
94930: FOR_IN
94931: IFFALSE 94947
// begin SetLives ( i , 0 ) ;
94933: LD_VAR 0 1
94937: PPUSH
94938: LD_INT 0
94940: PPUSH
94941: CALL_OW 234
// end ;
94945: GO 94930
94947: POP
94948: POP
// end ;
94949: PPOPN 2
94951: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
94952: LD_EXP 113
94956: PUSH
94957: LD_EXP 116
94961: AND
94962: IFFALSE 95055
94964: GO 94966
94966: DISABLE
94967: LD_INT 0
94969: PPUSH
// begin enable ;
94970: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
94971: LD_ADDR_VAR 0 1
94975: PUSH
94976: LD_INT 22
94978: PUSH
94979: LD_OWVAR 2
94983: PUSH
94984: EMPTY
94985: LIST
94986: LIST
94987: PUSH
94988: LD_INT 2
94990: PUSH
94991: LD_INT 25
94993: PUSH
94994: LD_INT 5
94996: PUSH
94997: EMPTY
94998: LIST
94999: LIST
95000: PUSH
95001: LD_INT 25
95003: PUSH
95004: LD_INT 9
95006: PUSH
95007: EMPTY
95008: LIST
95009: LIST
95010: PUSH
95011: LD_INT 25
95013: PUSH
95014: LD_INT 8
95016: PUSH
95017: EMPTY
95018: LIST
95019: LIST
95020: PUSH
95021: EMPTY
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: PUSH
95027: EMPTY
95028: LIST
95029: LIST
95030: PPUSH
95031: CALL_OW 69
95035: PUSH
95036: FOR_IN
95037: IFFALSE 95053
// begin SetClass ( i , 1 ) ;
95039: LD_VAR 0 1
95043: PPUSH
95044: LD_INT 1
95046: PPUSH
95047: CALL_OW 336
// end ;
95051: GO 95036
95053: POP
95054: POP
// end ;
95055: PPOPN 1
95057: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
95058: LD_EXP 113
95062: PUSH
95063: LD_EXP 117
95067: AND
95068: PUSH
95069: LD_OWVAR 65
95073: PUSH
95074: LD_INT 7
95076: LESS
95077: AND
95078: IFFALSE 95092
95080: GO 95082
95082: DISABLE
// begin enable ;
95083: ENABLE
// game_speed := 7 ;
95084: LD_ADDR_OWVAR 65
95088: PUSH
95089: LD_INT 7
95091: ST_TO_ADDR
// end ;
95092: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
95093: LD_EXP 113
95097: PUSH
95098: LD_EXP 120
95102: AND
95103: IFFALSE 95305
95105: GO 95107
95107: DISABLE
95108: LD_INT 0
95110: PPUSH
95111: PPUSH
95112: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
95113: LD_ADDR_VAR 0 3
95117: PUSH
95118: LD_INT 81
95120: PUSH
95121: LD_OWVAR 2
95125: PUSH
95126: EMPTY
95127: LIST
95128: LIST
95129: PUSH
95130: LD_INT 21
95132: PUSH
95133: LD_INT 1
95135: PUSH
95136: EMPTY
95137: LIST
95138: LIST
95139: PUSH
95140: EMPTY
95141: LIST
95142: LIST
95143: PPUSH
95144: CALL_OW 69
95148: ST_TO_ADDR
// if not tmp then
95149: LD_VAR 0 3
95153: NOT
95154: IFFALSE 95158
// exit ;
95156: GO 95305
// if tmp > 5 then
95158: LD_VAR 0 3
95162: PUSH
95163: LD_INT 5
95165: GREATER
95166: IFFALSE 95178
// k := 5 else
95168: LD_ADDR_VAR 0 2
95172: PUSH
95173: LD_INT 5
95175: ST_TO_ADDR
95176: GO 95188
// k := tmp ;
95178: LD_ADDR_VAR 0 2
95182: PUSH
95183: LD_VAR 0 3
95187: ST_TO_ADDR
// for i := 1 to k do
95188: LD_ADDR_VAR 0 1
95192: PUSH
95193: DOUBLE
95194: LD_INT 1
95196: DEC
95197: ST_TO_ADDR
95198: LD_VAR 0 2
95202: PUSH
95203: FOR_TO
95204: IFFALSE 95303
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
95206: LD_VAR 0 3
95210: PUSH
95211: LD_VAR 0 1
95215: ARRAY
95216: PPUSH
95217: LD_VAR 0 1
95221: PUSH
95222: LD_INT 4
95224: MOD
95225: PUSH
95226: LD_INT 1
95228: PLUS
95229: PPUSH
95230: CALL_OW 259
95234: PUSH
95235: LD_INT 10
95237: LESS
95238: IFFALSE 95301
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
95240: LD_VAR 0 3
95244: PUSH
95245: LD_VAR 0 1
95249: ARRAY
95250: PPUSH
95251: LD_VAR 0 1
95255: PUSH
95256: LD_INT 4
95258: MOD
95259: PUSH
95260: LD_INT 1
95262: PLUS
95263: PPUSH
95264: LD_VAR 0 3
95268: PUSH
95269: LD_VAR 0 1
95273: ARRAY
95274: PPUSH
95275: LD_VAR 0 1
95279: PUSH
95280: LD_INT 4
95282: MOD
95283: PUSH
95284: LD_INT 1
95286: PLUS
95287: PPUSH
95288: CALL_OW 259
95292: PUSH
95293: LD_INT 1
95295: PLUS
95296: PPUSH
95297: CALL_OW 237
95301: GO 95203
95303: POP
95304: POP
// end ;
95305: PPOPN 3
95307: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
95308: LD_EXP 113
95312: PUSH
95313: LD_EXP 121
95317: AND
95318: IFFALSE 95338
95320: GO 95322
95322: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
95323: LD_INT 4
95325: PPUSH
95326: LD_OWVAR 2
95330: PPUSH
95331: LD_INT 0
95333: PPUSH
95334: CALL_OW 324
95338: END
// every 0 0$1 trigger StreamModeActive and sShovel do
95339: LD_EXP 113
95343: PUSH
95344: LD_EXP 150
95348: AND
95349: IFFALSE 95369
95351: GO 95353
95353: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
95354: LD_INT 19
95356: PPUSH
95357: LD_OWVAR 2
95361: PPUSH
95362: LD_INT 0
95364: PPUSH
95365: CALL_OW 324
95369: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
95370: LD_EXP 113
95374: PUSH
95375: LD_EXP 122
95379: AND
95380: IFFALSE 95482
95382: GO 95384
95384: DISABLE
95385: LD_INT 0
95387: PPUSH
95388: PPUSH
// begin enable ;
95389: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
95390: LD_ADDR_VAR 0 2
95394: PUSH
95395: LD_INT 22
95397: PUSH
95398: LD_OWVAR 2
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: PUSH
95407: LD_INT 2
95409: PUSH
95410: LD_INT 34
95412: PUSH
95413: LD_INT 11
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: PUSH
95420: LD_INT 34
95422: PUSH
95423: LD_INT 30
95425: PUSH
95426: EMPTY
95427: LIST
95428: LIST
95429: PUSH
95430: EMPTY
95431: LIST
95432: LIST
95433: LIST
95434: PUSH
95435: EMPTY
95436: LIST
95437: LIST
95438: PPUSH
95439: CALL_OW 69
95443: ST_TO_ADDR
// if not tmp then
95444: LD_VAR 0 2
95448: NOT
95449: IFFALSE 95453
// exit ;
95451: GO 95482
// for i in tmp do
95453: LD_ADDR_VAR 0 1
95457: PUSH
95458: LD_VAR 0 2
95462: PUSH
95463: FOR_IN
95464: IFFALSE 95480
// begin SetLives ( i , 0 ) ;
95466: LD_VAR 0 1
95470: PPUSH
95471: LD_INT 0
95473: PPUSH
95474: CALL_OW 234
// end ;
95478: GO 95463
95480: POP
95481: POP
// end ;
95482: PPOPN 2
95484: END
// every 0 0$1 trigger StreamModeActive and sBunker do
95485: LD_EXP 113
95489: PUSH
95490: LD_EXP 123
95494: AND
95495: IFFALSE 95515
95497: GO 95499
95499: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
95500: LD_INT 32
95502: PPUSH
95503: LD_OWVAR 2
95507: PPUSH
95508: LD_INT 0
95510: PPUSH
95511: CALL_OW 324
95515: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
95516: LD_EXP 113
95520: PUSH
95521: LD_EXP 124
95525: AND
95526: IFFALSE 95707
95528: GO 95530
95530: DISABLE
95531: LD_INT 0
95533: PPUSH
95534: PPUSH
95535: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
95536: LD_ADDR_VAR 0 2
95540: PUSH
95541: LD_INT 22
95543: PUSH
95544: LD_OWVAR 2
95548: PUSH
95549: EMPTY
95550: LIST
95551: LIST
95552: PUSH
95553: LD_INT 33
95555: PUSH
95556: LD_INT 3
95558: PUSH
95559: EMPTY
95560: LIST
95561: LIST
95562: PUSH
95563: EMPTY
95564: LIST
95565: LIST
95566: PPUSH
95567: CALL_OW 69
95571: ST_TO_ADDR
// if not tmp then
95572: LD_VAR 0 2
95576: NOT
95577: IFFALSE 95581
// exit ;
95579: GO 95707
// side := 0 ;
95581: LD_ADDR_VAR 0 3
95585: PUSH
95586: LD_INT 0
95588: ST_TO_ADDR
// for i := 1 to 8 do
95589: LD_ADDR_VAR 0 1
95593: PUSH
95594: DOUBLE
95595: LD_INT 1
95597: DEC
95598: ST_TO_ADDR
95599: LD_INT 8
95601: PUSH
95602: FOR_TO
95603: IFFALSE 95651
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
95605: LD_OWVAR 2
95609: PUSH
95610: LD_VAR 0 1
95614: NONEQUAL
95615: PUSH
95616: LD_OWVAR 2
95620: PPUSH
95621: LD_VAR 0 1
95625: PPUSH
95626: CALL_OW 81
95630: PUSH
95631: LD_INT 2
95633: EQUAL
95634: AND
95635: IFFALSE 95649
// begin side := i ;
95637: LD_ADDR_VAR 0 3
95641: PUSH
95642: LD_VAR 0 1
95646: ST_TO_ADDR
// break ;
95647: GO 95651
// end ;
95649: GO 95602
95651: POP
95652: POP
// if not side then
95653: LD_VAR 0 3
95657: NOT
95658: IFFALSE 95662
// exit ;
95660: GO 95707
// for i := 1 to tmp do
95662: LD_ADDR_VAR 0 1
95666: PUSH
95667: DOUBLE
95668: LD_INT 1
95670: DEC
95671: ST_TO_ADDR
95672: LD_VAR 0 2
95676: PUSH
95677: FOR_TO
95678: IFFALSE 95705
// if Prob ( 60 ) then
95680: LD_INT 60
95682: PPUSH
95683: CALL_OW 13
95687: IFFALSE 95703
// SetSide ( i , side ) ;
95689: LD_VAR 0 1
95693: PPUSH
95694: LD_VAR 0 3
95698: PPUSH
95699: CALL_OW 235
95703: GO 95677
95705: POP
95706: POP
// end ;
95707: PPOPN 3
95709: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
95710: LD_EXP 113
95714: PUSH
95715: LD_EXP 126
95719: AND
95720: IFFALSE 95839
95722: GO 95724
95724: DISABLE
95725: LD_INT 0
95727: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
95728: LD_ADDR_VAR 0 1
95732: PUSH
95733: LD_INT 22
95735: PUSH
95736: LD_OWVAR 2
95740: PUSH
95741: EMPTY
95742: LIST
95743: LIST
95744: PUSH
95745: LD_INT 21
95747: PUSH
95748: LD_INT 1
95750: PUSH
95751: EMPTY
95752: LIST
95753: LIST
95754: PUSH
95755: LD_INT 3
95757: PUSH
95758: LD_INT 23
95760: PUSH
95761: LD_INT 0
95763: PUSH
95764: EMPTY
95765: LIST
95766: LIST
95767: PUSH
95768: EMPTY
95769: LIST
95770: LIST
95771: PUSH
95772: EMPTY
95773: LIST
95774: LIST
95775: LIST
95776: PPUSH
95777: CALL_OW 69
95781: PUSH
95782: FOR_IN
95783: IFFALSE 95837
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
95785: LD_VAR 0 1
95789: PPUSH
95790: CALL_OW 257
95794: PUSH
95795: LD_INT 1
95797: PUSH
95798: LD_INT 2
95800: PUSH
95801: LD_INT 3
95803: PUSH
95804: LD_INT 4
95806: PUSH
95807: EMPTY
95808: LIST
95809: LIST
95810: LIST
95811: LIST
95812: IN
95813: IFFALSE 95835
// SetClass ( un , rand ( 1 , 4 ) ) ;
95815: LD_VAR 0 1
95819: PPUSH
95820: LD_INT 1
95822: PPUSH
95823: LD_INT 4
95825: PPUSH
95826: CALL_OW 12
95830: PPUSH
95831: CALL_OW 336
95835: GO 95782
95837: POP
95838: POP
// end ;
95839: PPOPN 1
95841: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
95842: LD_EXP 113
95846: PUSH
95847: LD_EXP 125
95851: AND
95852: IFFALSE 95931
95854: GO 95856
95856: DISABLE
95857: LD_INT 0
95859: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95860: LD_ADDR_VAR 0 1
95864: PUSH
95865: LD_INT 22
95867: PUSH
95868: LD_OWVAR 2
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: PUSH
95877: LD_INT 21
95879: PUSH
95880: LD_INT 3
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: EMPTY
95888: LIST
95889: LIST
95890: PPUSH
95891: CALL_OW 69
95895: ST_TO_ADDR
// if not tmp then
95896: LD_VAR 0 1
95900: NOT
95901: IFFALSE 95905
// exit ;
95903: GO 95931
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
95905: LD_VAR 0 1
95909: PUSH
95910: LD_INT 1
95912: PPUSH
95913: LD_VAR 0 1
95917: PPUSH
95918: CALL_OW 12
95922: ARRAY
95923: PPUSH
95924: LD_INT 100
95926: PPUSH
95927: CALL_OW 234
// end ;
95931: PPOPN 1
95933: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
95934: LD_EXP 113
95938: PUSH
95939: LD_EXP 127
95943: AND
95944: IFFALSE 96042
95946: GO 95948
95948: DISABLE
95949: LD_INT 0
95951: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95952: LD_ADDR_VAR 0 1
95956: PUSH
95957: LD_INT 22
95959: PUSH
95960: LD_OWVAR 2
95964: PUSH
95965: EMPTY
95966: LIST
95967: LIST
95968: PUSH
95969: LD_INT 21
95971: PUSH
95972: LD_INT 1
95974: PUSH
95975: EMPTY
95976: LIST
95977: LIST
95978: PUSH
95979: EMPTY
95980: LIST
95981: LIST
95982: PPUSH
95983: CALL_OW 69
95987: ST_TO_ADDR
// if not tmp then
95988: LD_VAR 0 1
95992: NOT
95993: IFFALSE 95997
// exit ;
95995: GO 96042
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
95997: LD_VAR 0 1
96001: PUSH
96002: LD_INT 1
96004: PPUSH
96005: LD_VAR 0 1
96009: PPUSH
96010: CALL_OW 12
96014: ARRAY
96015: PPUSH
96016: LD_INT 1
96018: PPUSH
96019: LD_INT 4
96021: PPUSH
96022: CALL_OW 12
96026: PPUSH
96027: LD_INT 3000
96029: PPUSH
96030: LD_INT 9000
96032: PPUSH
96033: CALL_OW 12
96037: PPUSH
96038: CALL_OW 492
// end ;
96042: PPOPN 1
96044: END
// every 0 0$1 trigger StreamModeActive and sDepot do
96045: LD_EXP 113
96049: PUSH
96050: LD_EXP 128
96054: AND
96055: IFFALSE 96075
96057: GO 96059
96059: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
96060: LD_INT 1
96062: PPUSH
96063: LD_OWVAR 2
96067: PPUSH
96068: LD_INT 0
96070: PPUSH
96071: CALL_OW 324
96075: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
96076: LD_EXP 113
96080: PUSH
96081: LD_EXP 129
96085: AND
96086: IFFALSE 96169
96088: GO 96090
96090: DISABLE
96091: LD_INT 0
96093: PPUSH
96094: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96095: LD_ADDR_VAR 0 2
96099: PUSH
96100: LD_INT 22
96102: PUSH
96103: LD_OWVAR 2
96107: PUSH
96108: EMPTY
96109: LIST
96110: LIST
96111: PUSH
96112: LD_INT 21
96114: PUSH
96115: LD_INT 3
96117: PUSH
96118: EMPTY
96119: LIST
96120: LIST
96121: PUSH
96122: EMPTY
96123: LIST
96124: LIST
96125: PPUSH
96126: CALL_OW 69
96130: ST_TO_ADDR
// if not tmp then
96131: LD_VAR 0 2
96135: NOT
96136: IFFALSE 96140
// exit ;
96138: GO 96169
// for i in tmp do
96140: LD_ADDR_VAR 0 1
96144: PUSH
96145: LD_VAR 0 2
96149: PUSH
96150: FOR_IN
96151: IFFALSE 96167
// SetBLevel ( i , 10 ) ;
96153: LD_VAR 0 1
96157: PPUSH
96158: LD_INT 10
96160: PPUSH
96161: CALL_OW 241
96165: GO 96150
96167: POP
96168: POP
// end ;
96169: PPOPN 2
96171: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
96172: LD_EXP 113
96176: PUSH
96177: LD_EXP 130
96181: AND
96182: IFFALSE 96293
96184: GO 96186
96186: DISABLE
96187: LD_INT 0
96189: PPUSH
96190: PPUSH
96191: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96192: LD_ADDR_VAR 0 3
96196: PUSH
96197: LD_INT 22
96199: PUSH
96200: LD_OWVAR 2
96204: PUSH
96205: EMPTY
96206: LIST
96207: LIST
96208: PUSH
96209: LD_INT 25
96211: PUSH
96212: LD_INT 1
96214: PUSH
96215: EMPTY
96216: LIST
96217: LIST
96218: PUSH
96219: EMPTY
96220: LIST
96221: LIST
96222: PPUSH
96223: CALL_OW 69
96227: ST_TO_ADDR
// if not tmp then
96228: LD_VAR 0 3
96232: NOT
96233: IFFALSE 96237
// exit ;
96235: GO 96293
// un := tmp [ rand ( 1 , tmp ) ] ;
96237: LD_ADDR_VAR 0 2
96241: PUSH
96242: LD_VAR 0 3
96246: PUSH
96247: LD_INT 1
96249: PPUSH
96250: LD_VAR 0 3
96254: PPUSH
96255: CALL_OW 12
96259: ARRAY
96260: ST_TO_ADDR
// if Crawls ( un ) then
96261: LD_VAR 0 2
96265: PPUSH
96266: CALL_OW 318
96270: IFFALSE 96281
// ComWalk ( un ) ;
96272: LD_VAR 0 2
96276: PPUSH
96277: CALL_OW 138
// SetClass ( un , class_sniper ) ;
96281: LD_VAR 0 2
96285: PPUSH
96286: LD_INT 5
96288: PPUSH
96289: CALL_OW 336
// end ;
96293: PPOPN 3
96295: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
96296: LD_EXP 113
96300: PUSH
96301: LD_EXP 131
96305: AND
96306: PUSH
96307: LD_OWVAR 67
96311: PUSH
96312: LD_INT 4
96314: LESS
96315: AND
96316: IFFALSE 96335
96318: GO 96320
96320: DISABLE
// begin Difficulty := Difficulty + 1 ;
96321: LD_ADDR_OWVAR 67
96325: PUSH
96326: LD_OWVAR 67
96330: PUSH
96331: LD_INT 1
96333: PLUS
96334: ST_TO_ADDR
// end ;
96335: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
96336: LD_EXP 113
96340: PUSH
96341: LD_EXP 132
96345: AND
96346: IFFALSE 96449
96348: GO 96350
96350: DISABLE
96351: LD_INT 0
96353: PPUSH
// begin for i := 1 to 5 do
96354: LD_ADDR_VAR 0 1
96358: PUSH
96359: DOUBLE
96360: LD_INT 1
96362: DEC
96363: ST_TO_ADDR
96364: LD_INT 5
96366: PUSH
96367: FOR_TO
96368: IFFALSE 96447
// begin uc_nation := nation_nature ;
96370: LD_ADDR_OWVAR 21
96374: PUSH
96375: LD_INT 0
96377: ST_TO_ADDR
// uc_side := 0 ;
96378: LD_ADDR_OWVAR 20
96382: PUSH
96383: LD_INT 0
96385: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96386: LD_ADDR_OWVAR 29
96390: PUSH
96391: LD_INT 12
96393: PUSH
96394: LD_INT 12
96396: PUSH
96397: EMPTY
96398: LIST
96399: LIST
96400: ST_TO_ADDR
// hc_agressivity := 20 ;
96401: LD_ADDR_OWVAR 35
96405: PUSH
96406: LD_INT 20
96408: ST_TO_ADDR
// hc_class := class_tiger ;
96409: LD_ADDR_OWVAR 28
96413: PUSH
96414: LD_INT 14
96416: ST_TO_ADDR
// hc_gallery :=  ;
96417: LD_ADDR_OWVAR 33
96421: PUSH
96422: LD_STRING 
96424: ST_TO_ADDR
// hc_name :=  ;
96425: LD_ADDR_OWVAR 26
96429: PUSH
96430: LD_STRING 
96432: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
96433: CALL_OW 44
96437: PPUSH
96438: LD_INT 0
96440: PPUSH
96441: CALL_OW 51
// end ;
96445: GO 96367
96447: POP
96448: POP
// end ;
96449: PPOPN 1
96451: END
// every 0 0$1 trigger StreamModeActive and sBomb do
96452: LD_EXP 113
96456: PUSH
96457: LD_EXP 133
96461: AND
96462: IFFALSE 96471
96464: GO 96466
96466: DISABLE
// StreamSibBomb ;
96467: CALL 96472 0 0
96471: END
// export function StreamSibBomb ; var i , x , y ; begin
96472: LD_INT 0
96474: PPUSH
96475: PPUSH
96476: PPUSH
96477: PPUSH
// result := false ;
96478: LD_ADDR_VAR 0 1
96482: PUSH
96483: LD_INT 0
96485: ST_TO_ADDR
// for i := 1 to 16 do
96486: LD_ADDR_VAR 0 2
96490: PUSH
96491: DOUBLE
96492: LD_INT 1
96494: DEC
96495: ST_TO_ADDR
96496: LD_INT 16
96498: PUSH
96499: FOR_TO
96500: IFFALSE 96699
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96502: LD_ADDR_VAR 0 3
96506: PUSH
96507: LD_INT 10
96509: PUSH
96510: LD_INT 20
96512: PUSH
96513: LD_INT 30
96515: PUSH
96516: LD_INT 40
96518: PUSH
96519: LD_INT 50
96521: PUSH
96522: LD_INT 60
96524: PUSH
96525: LD_INT 70
96527: PUSH
96528: LD_INT 80
96530: PUSH
96531: LD_INT 90
96533: PUSH
96534: LD_INT 100
96536: PUSH
96537: LD_INT 110
96539: PUSH
96540: LD_INT 120
96542: PUSH
96543: LD_INT 130
96545: PUSH
96546: LD_INT 140
96548: PUSH
96549: LD_INT 150
96551: PUSH
96552: EMPTY
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: LIST
96568: PUSH
96569: LD_INT 1
96571: PPUSH
96572: LD_INT 15
96574: PPUSH
96575: CALL_OW 12
96579: ARRAY
96580: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96581: LD_ADDR_VAR 0 4
96585: PUSH
96586: LD_INT 10
96588: PUSH
96589: LD_INT 20
96591: PUSH
96592: LD_INT 30
96594: PUSH
96595: LD_INT 40
96597: PUSH
96598: LD_INT 50
96600: PUSH
96601: LD_INT 60
96603: PUSH
96604: LD_INT 70
96606: PUSH
96607: LD_INT 80
96609: PUSH
96610: LD_INT 90
96612: PUSH
96613: LD_INT 100
96615: PUSH
96616: LD_INT 110
96618: PUSH
96619: LD_INT 120
96621: PUSH
96622: LD_INT 130
96624: PUSH
96625: LD_INT 140
96627: PUSH
96628: LD_INT 150
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: LIST
96642: LIST
96643: LIST
96644: LIST
96645: LIST
96646: LIST
96647: PUSH
96648: LD_INT 1
96650: PPUSH
96651: LD_INT 15
96653: PPUSH
96654: CALL_OW 12
96658: ARRAY
96659: ST_TO_ADDR
// if ValidHex ( x , y ) then
96660: LD_VAR 0 3
96664: PPUSH
96665: LD_VAR 0 4
96669: PPUSH
96670: CALL_OW 488
96674: IFFALSE 96697
// begin result := [ x , y ] ;
96676: LD_ADDR_VAR 0 1
96680: PUSH
96681: LD_VAR 0 3
96685: PUSH
96686: LD_VAR 0 4
96690: PUSH
96691: EMPTY
96692: LIST
96693: LIST
96694: ST_TO_ADDR
// break ;
96695: GO 96699
// end ; end ;
96697: GO 96499
96699: POP
96700: POP
// if result then
96701: LD_VAR 0 1
96705: IFFALSE 96765
// begin ToLua ( playSibBomb() ) ;
96707: LD_STRING playSibBomb()
96709: PPUSH
96710: CALL_OW 559
// wait ( 0 0$14 ) ;
96714: LD_INT 490
96716: PPUSH
96717: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
96721: LD_VAR 0 1
96725: PUSH
96726: LD_INT 1
96728: ARRAY
96729: PPUSH
96730: LD_VAR 0 1
96734: PUSH
96735: LD_INT 2
96737: ARRAY
96738: PPUSH
96739: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
96743: LD_VAR 0 1
96747: PUSH
96748: LD_INT 1
96750: ARRAY
96751: PPUSH
96752: LD_VAR 0 1
96756: PUSH
96757: LD_INT 2
96759: ARRAY
96760: PPUSH
96761: CALL_OW 429
// end ; end ;
96765: LD_VAR 0 1
96769: RET
// every 0 0$1 trigger StreamModeActive and sReset do
96770: LD_EXP 113
96774: PUSH
96775: LD_EXP 135
96779: AND
96780: IFFALSE 96792
96782: GO 96784
96784: DISABLE
// YouLost (  ) ;
96785: LD_STRING 
96787: PPUSH
96788: CALL_OW 104
96792: END
// every 0 0$1 trigger StreamModeActive and sFog do
96793: LD_EXP 113
96797: PUSH
96798: LD_EXP 134
96802: AND
96803: IFFALSE 96817
96805: GO 96807
96807: DISABLE
// FogOff ( your_side ) ;
96808: LD_OWVAR 2
96812: PPUSH
96813: CALL_OW 344
96817: END
// every 0 0$1 trigger StreamModeActive and sSun do
96818: LD_EXP 113
96822: PUSH
96823: LD_EXP 136
96827: AND
96828: IFFALSE 96856
96830: GO 96832
96832: DISABLE
// begin solar_recharge_percent := 0 ;
96833: LD_ADDR_OWVAR 79
96837: PUSH
96838: LD_INT 0
96840: ST_TO_ADDR
// wait ( 5 5$00 ) ;
96841: LD_INT 10500
96843: PPUSH
96844: CALL_OW 67
// solar_recharge_percent := 100 ;
96848: LD_ADDR_OWVAR 79
96852: PUSH
96853: LD_INT 100
96855: ST_TO_ADDR
// end ;
96856: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
96857: LD_EXP 113
96861: PUSH
96862: LD_EXP 137
96866: AND
96867: IFFALSE 97106
96869: GO 96871
96871: DISABLE
96872: LD_INT 0
96874: PPUSH
96875: PPUSH
96876: PPUSH
// begin tmp := [ ] ;
96877: LD_ADDR_VAR 0 3
96881: PUSH
96882: EMPTY
96883: ST_TO_ADDR
// for i := 1 to 6 do
96884: LD_ADDR_VAR 0 1
96888: PUSH
96889: DOUBLE
96890: LD_INT 1
96892: DEC
96893: ST_TO_ADDR
96894: LD_INT 6
96896: PUSH
96897: FOR_TO
96898: IFFALSE 97003
// begin uc_nation := nation_nature ;
96900: LD_ADDR_OWVAR 21
96904: PUSH
96905: LD_INT 0
96907: ST_TO_ADDR
// uc_side := 0 ;
96908: LD_ADDR_OWVAR 20
96912: PUSH
96913: LD_INT 0
96915: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96916: LD_ADDR_OWVAR 29
96920: PUSH
96921: LD_INT 12
96923: PUSH
96924: LD_INT 12
96926: PUSH
96927: EMPTY
96928: LIST
96929: LIST
96930: ST_TO_ADDR
// hc_agressivity := 20 ;
96931: LD_ADDR_OWVAR 35
96935: PUSH
96936: LD_INT 20
96938: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
96939: LD_ADDR_OWVAR 28
96943: PUSH
96944: LD_INT 17
96946: ST_TO_ADDR
// hc_gallery :=  ;
96947: LD_ADDR_OWVAR 33
96951: PUSH
96952: LD_STRING 
96954: ST_TO_ADDR
// hc_name :=  ;
96955: LD_ADDR_OWVAR 26
96959: PUSH
96960: LD_STRING 
96962: ST_TO_ADDR
// un := CreateHuman ;
96963: LD_ADDR_VAR 0 2
96967: PUSH
96968: CALL_OW 44
96972: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
96973: LD_VAR 0 2
96977: PPUSH
96978: LD_INT 1
96980: PPUSH
96981: CALL_OW 51
// tmp := tmp ^ un ;
96985: LD_ADDR_VAR 0 3
96989: PUSH
96990: LD_VAR 0 3
96994: PUSH
96995: LD_VAR 0 2
96999: ADD
97000: ST_TO_ADDR
// end ;
97001: GO 96897
97003: POP
97004: POP
// repeat wait ( 0 0$1 ) ;
97005: LD_INT 35
97007: PPUSH
97008: CALL_OW 67
// for un in tmp do
97012: LD_ADDR_VAR 0 2
97016: PUSH
97017: LD_VAR 0 3
97021: PUSH
97022: FOR_IN
97023: IFFALSE 97097
// begin if IsDead ( un ) then
97025: LD_VAR 0 2
97029: PPUSH
97030: CALL_OW 301
97034: IFFALSE 97054
// begin tmp := tmp diff un ;
97036: LD_ADDR_VAR 0 3
97040: PUSH
97041: LD_VAR 0 3
97045: PUSH
97046: LD_VAR 0 2
97050: DIFF
97051: ST_TO_ADDR
// continue ;
97052: GO 97022
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
97054: LD_VAR 0 2
97058: PPUSH
97059: LD_INT 3
97061: PUSH
97062: LD_INT 22
97064: PUSH
97065: LD_INT 0
97067: PUSH
97068: EMPTY
97069: LIST
97070: LIST
97071: PUSH
97072: EMPTY
97073: LIST
97074: LIST
97075: PPUSH
97076: CALL_OW 69
97080: PPUSH
97081: LD_VAR 0 2
97085: PPUSH
97086: CALL_OW 74
97090: PPUSH
97091: CALL_OW 115
// end ;
97095: GO 97022
97097: POP
97098: POP
// until not tmp ;
97099: LD_VAR 0 3
97103: NOT
97104: IFFALSE 97005
// end ;
97106: PPOPN 3
97108: END
// every 0 0$1 trigger StreamModeActive and sTroll do
97109: LD_EXP 113
97113: PUSH
97114: LD_EXP 138
97118: AND
97119: IFFALSE 97173
97121: GO 97123
97123: DISABLE
// begin ToLua ( displayTroll(); ) ;
97124: LD_STRING displayTroll();
97126: PPUSH
97127: CALL_OW 559
// wait ( 3 3$00 ) ;
97131: LD_INT 6300
97133: PPUSH
97134: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97138: LD_STRING hideTroll();
97140: PPUSH
97141: CALL_OW 559
// wait ( 1 1$00 ) ;
97145: LD_INT 2100
97147: PPUSH
97148: CALL_OW 67
// ToLua ( displayTroll(); ) ;
97152: LD_STRING displayTroll();
97154: PPUSH
97155: CALL_OW 559
// wait ( 1 1$00 ) ;
97159: LD_INT 2100
97161: PPUSH
97162: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97166: LD_STRING hideTroll();
97168: PPUSH
97169: CALL_OW 559
// end ;
97173: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
97174: LD_EXP 113
97178: PUSH
97179: LD_EXP 139
97183: AND
97184: IFFALSE 97247
97186: GO 97188
97188: DISABLE
97189: LD_INT 0
97191: PPUSH
// begin p := 0 ;
97192: LD_ADDR_VAR 0 1
97196: PUSH
97197: LD_INT 0
97199: ST_TO_ADDR
// repeat game_speed := 1 ;
97200: LD_ADDR_OWVAR 65
97204: PUSH
97205: LD_INT 1
97207: ST_TO_ADDR
// wait ( 0 0$1 ) ;
97208: LD_INT 35
97210: PPUSH
97211: CALL_OW 67
// p := p + 1 ;
97215: LD_ADDR_VAR 0 1
97219: PUSH
97220: LD_VAR 0 1
97224: PUSH
97225: LD_INT 1
97227: PLUS
97228: ST_TO_ADDR
// until p >= 60 ;
97229: LD_VAR 0 1
97233: PUSH
97234: LD_INT 60
97236: GREATEREQUAL
97237: IFFALSE 97200
// game_speed := 4 ;
97239: LD_ADDR_OWVAR 65
97243: PUSH
97244: LD_INT 4
97246: ST_TO_ADDR
// end ;
97247: PPOPN 1
97249: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
97250: LD_EXP 113
97254: PUSH
97255: LD_EXP 140
97259: AND
97260: IFFALSE 97406
97262: GO 97264
97264: DISABLE
97265: LD_INT 0
97267: PPUSH
97268: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97269: LD_ADDR_VAR 0 1
97273: PUSH
97274: LD_INT 22
97276: PUSH
97277: LD_OWVAR 2
97281: PUSH
97282: EMPTY
97283: LIST
97284: LIST
97285: PUSH
97286: LD_INT 2
97288: PUSH
97289: LD_INT 30
97291: PUSH
97292: LD_INT 0
97294: PUSH
97295: EMPTY
97296: LIST
97297: LIST
97298: PUSH
97299: LD_INT 30
97301: PUSH
97302: LD_INT 1
97304: PUSH
97305: EMPTY
97306: LIST
97307: LIST
97308: PUSH
97309: EMPTY
97310: LIST
97311: LIST
97312: LIST
97313: PUSH
97314: EMPTY
97315: LIST
97316: LIST
97317: PPUSH
97318: CALL_OW 69
97322: ST_TO_ADDR
// if not depot then
97323: LD_VAR 0 1
97327: NOT
97328: IFFALSE 97332
// exit ;
97330: GO 97406
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
97332: LD_ADDR_VAR 0 2
97336: PUSH
97337: LD_VAR 0 1
97341: PUSH
97342: LD_INT 1
97344: PPUSH
97345: LD_VAR 0 1
97349: PPUSH
97350: CALL_OW 12
97354: ARRAY
97355: PPUSH
97356: CALL_OW 274
97360: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
97361: LD_VAR 0 2
97365: PPUSH
97366: LD_INT 1
97368: PPUSH
97369: LD_INT 0
97371: PPUSH
97372: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
97376: LD_VAR 0 2
97380: PPUSH
97381: LD_INT 2
97383: PPUSH
97384: LD_INT 0
97386: PPUSH
97387: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
97391: LD_VAR 0 2
97395: PPUSH
97396: LD_INT 3
97398: PPUSH
97399: LD_INT 0
97401: PPUSH
97402: CALL_OW 277
// end ;
97406: PPOPN 2
97408: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
97409: LD_EXP 113
97413: PUSH
97414: LD_EXP 141
97418: AND
97419: IFFALSE 97516
97421: GO 97423
97423: DISABLE
97424: LD_INT 0
97426: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97427: LD_ADDR_VAR 0 1
97431: PUSH
97432: LD_INT 22
97434: PUSH
97435: LD_OWVAR 2
97439: PUSH
97440: EMPTY
97441: LIST
97442: LIST
97443: PUSH
97444: LD_INT 21
97446: PUSH
97447: LD_INT 1
97449: PUSH
97450: EMPTY
97451: LIST
97452: LIST
97453: PUSH
97454: LD_INT 3
97456: PUSH
97457: LD_INT 23
97459: PUSH
97460: LD_INT 0
97462: PUSH
97463: EMPTY
97464: LIST
97465: LIST
97466: PUSH
97467: EMPTY
97468: LIST
97469: LIST
97470: PUSH
97471: EMPTY
97472: LIST
97473: LIST
97474: LIST
97475: PPUSH
97476: CALL_OW 69
97480: ST_TO_ADDR
// if not tmp then
97481: LD_VAR 0 1
97485: NOT
97486: IFFALSE 97490
// exit ;
97488: GO 97516
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
97490: LD_VAR 0 1
97494: PUSH
97495: LD_INT 1
97497: PPUSH
97498: LD_VAR 0 1
97502: PPUSH
97503: CALL_OW 12
97507: ARRAY
97508: PPUSH
97509: LD_INT 200
97511: PPUSH
97512: CALL_OW 234
// end ;
97516: PPOPN 1
97518: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
97519: LD_EXP 113
97523: PUSH
97524: LD_EXP 142
97528: AND
97529: IFFALSE 97608
97531: GO 97533
97533: DISABLE
97534: LD_INT 0
97536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
97537: LD_ADDR_VAR 0 1
97541: PUSH
97542: LD_INT 22
97544: PUSH
97545: LD_OWVAR 2
97549: PUSH
97550: EMPTY
97551: LIST
97552: LIST
97553: PUSH
97554: LD_INT 21
97556: PUSH
97557: LD_INT 2
97559: PUSH
97560: EMPTY
97561: LIST
97562: LIST
97563: PUSH
97564: EMPTY
97565: LIST
97566: LIST
97567: PPUSH
97568: CALL_OW 69
97572: ST_TO_ADDR
// if not tmp then
97573: LD_VAR 0 1
97577: NOT
97578: IFFALSE 97582
// exit ;
97580: GO 97608
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
97582: LD_VAR 0 1
97586: PUSH
97587: LD_INT 1
97589: PPUSH
97590: LD_VAR 0 1
97594: PPUSH
97595: CALL_OW 12
97599: ARRAY
97600: PPUSH
97601: LD_INT 60
97603: PPUSH
97604: CALL_OW 234
// end ;
97608: PPOPN 1
97610: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
97611: LD_EXP 113
97615: PUSH
97616: LD_EXP 143
97620: AND
97621: IFFALSE 97720
97623: GO 97625
97625: DISABLE
97626: LD_INT 0
97628: PPUSH
97629: PPUSH
// begin enable ;
97630: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
97631: LD_ADDR_VAR 0 1
97635: PUSH
97636: LD_INT 22
97638: PUSH
97639: LD_OWVAR 2
97643: PUSH
97644: EMPTY
97645: LIST
97646: LIST
97647: PUSH
97648: LD_INT 61
97650: PUSH
97651: EMPTY
97652: LIST
97653: PUSH
97654: LD_INT 33
97656: PUSH
97657: LD_INT 2
97659: PUSH
97660: EMPTY
97661: LIST
97662: LIST
97663: PUSH
97664: EMPTY
97665: LIST
97666: LIST
97667: LIST
97668: PPUSH
97669: CALL_OW 69
97673: ST_TO_ADDR
// if not tmp then
97674: LD_VAR 0 1
97678: NOT
97679: IFFALSE 97683
// exit ;
97681: GO 97720
// for i in tmp do
97683: LD_ADDR_VAR 0 2
97687: PUSH
97688: LD_VAR 0 1
97692: PUSH
97693: FOR_IN
97694: IFFALSE 97718
// if IsControledBy ( i ) then
97696: LD_VAR 0 2
97700: PPUSH
97701: CALL_OW 312
97705: IFFALSE 97716
// ComUnlink ( i ) ;
97707: LD_VAR 0 2
97711: PPUSH
97712: CALL_OW 136
97716: GO 97693
97718: POP
97719: POP
// end ;
97720: PPOPN 2
97722: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
97723: LD_EXP 113
97727: PUSH
97728: LD_EXP 144
97732: AND
97733: IFFALSE 97873
97735: GO 97737
97737: DISABLE
97738: LD_INT 0
97740: PPUSH
97741: PPUSH
// begin ToLua ( displayPowell(); ) ;
97742: LD_STRING displayPowell();
97744: PPUSH
97745: CALL_OW 559
// uc_side := 0 ;
97749: LD_ADDR_OWVAR 20
97753: PUSH
97754: LD_INT 0
97756: ST_TO_ADDR
// uc_nation := 2 ;
97757: LD_ADDR_OWVAR 21
97761: PUSH
97762: LD_INT 2
97764: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
97765: LD_ADDR_OWVAR 37
97769: PUSH
97770: LD_INT 14
97772: ST_TO_ADDR
// vc_engine := engine_siberite ;
97773: LD_ADDR_OWVAR 39
97777: PUSH
97778: LD_INT 3
97780: ST_TO_ADDR
// vc_control := control_apeman ;
97781: LD_ADDR_OWVAR 38
97785: PUSH
97786: LD_INT 5
97788: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
97789: LD_ADDR_OWVAR 40
97793: PUSH
97794: LD_INT 29
97796: ST_TO_ADDR
// un := CreateVehicle ;
97797: LD_ADDR_VAR 0 2
97801: PUSH
97802: CALL_OW 45
97806: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97807: LD_VAR 0 2
97811: PPUSH
97812: LD_INT 1
97814: PPUSH
97815: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97819: LD_INT 35
97821: PPUSH
97822: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97826: LD_VAR 0 2
97830: PPUSH
97831: LD_INT 22
97833: PUSH
97834: LD_OWVAR 2
97838: PUSH
97839: EMPTY
97840: LIST
97841: LIST
97842: PPUSH
97843: CALL_OW 69
97847: PPUSH
97848: LD_VAR 0 2
97852: PPUSH
97853: CALL_OW 74
97857: PPUSH
97858: CALL_OW 115
// until IsDead ( un ) ;
97862: LD_VAR 0 2
97866: PPUSH
97867: CALL_OW 301
97871: IFFALSE 97819
// end ;
97873: PPOPN 2
97875: END
// every 0 0$1 trigger StreamModeActive and sStu do
97876: LD_EXP 113
97880: PUSH
97881: LD_EXP 152
97885: AND
97886: IFFALSE 97902
97888: GO 97890
97890: DISABLE
// begin ToLua ( displayStucuk(); ) ;
97891: LD_STRING displayStucuk();
97893: PPUSH
97894: CALL_OW 559
// ResetFog ;
97898: CALL_OW 335
// end ;
97902: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
97903: LD_EXP 113
97907: PUSH
97908: LD_EXP 145
97912: AND
97913: IFFALSE 98054
97915: GO 97917
97917: DISABLE
97918: LD_INT 0
97920: PPUSH
97921: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97922: LD_ADDR_VAR 0 2
97926: PUSH
97927: LD_INT 22
97929: PUSH
97930: LD_OWVAR 2
97934: PUSH
97935: EMPTY
97936: LIST
97937: LIST
97938: PUSH
97939: LD_INT 21
97941: PUSH
97942: LD_INT 1
97944: PUSH
97945: EMPTY
97946: LIST
97947: LIST
97948: PUSH
97949: EMPTY
97950: LIST
97951: LIST
97952: PPUSH
97953: CALL_OW 69
97957: ST_TO_ADDR
// if not tmp then
97958: LD_VAR 0 2
97962: NOT
97963: IFFALSE 97967
// exit ;
97965: GO 98054
// un := tmp [ rand ( 1 , tmp ) ] ;
97967: LD_ADDR_VAR 0 1
97971: PUSH
97972: LD_VAR 0 2
97976: PUSH
97977: LD_INT 1
97979: PPUSH
97980: LD_VAR 0 2
97984: PPUSH
97985: CALL_OW 12
97989: ARRAY
97990: ST_TO_ADDR
// SetSide ( un , 0 ) ;
97991: LD_VAR 0 1
97995: PPUSH
97996: LD_INT 0
97998: PPUSH
97999: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
98003: LD_VAR 0 1
98007: PPUSH
98008: LD_OWVAR 3
98012: PUSH
98013: LD_VAR 0 1
98017: DIFF
98018: PPUSH
98019: LD_VAR 0 1
98023: PPUSH
98024: CALL_OW 74
98028: PPUSH
98029: CALL_OW 115
// wait ( 0 0$20 ) ;
98033: LD_INT 700
98035: PPUSH
98036: CALL_OW 67
// SetSide ( un , your_side ) ;
98040: LD_VAR 0 1
98044: PPUSH
98045: LD_OWVAR 2
98049: PPUSH
98050: CALL_OW 235
// end ;
98054: PPOPN 2
98056: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
98057: LD_EXP 113
98061: PUSH
98062: LD_EXP 146
98066: AND
98067: IFFALSE 98173
98069: GO 98071
98071: DISABLE
98072: LD_INT 0
98074: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98075: LD_ADDR_VAR 0 1
98079: PUSH
98080: LD_INT 22
98082: PUSH
98083: LD_OWVAR 2
98087: PUSH
98088: EMPTY
98089: LIST
98090: LIST
98091: PUSH
98092: LD_INT 2
98094: PUSH
98095: LD_INT 30
98097: PUSH
98098: LD_INT 0
98100: PUSH
98101: EMPTY
98102: LIST
98103: LIST
98104: PUSH
98105: LD_INT 30
98107: PUSH
98108: LD_INT 1
98110: PUSH
98111: EMPTY
98112: LIST
98113: LIST
98114: PUSH
98115: EMPTY
98116: LIST
98117: LIST
98118: LIST
98119: PUSH
98120: EMPTY
98121: LIST
98122: LIST
98123: PPUSH
98124: CALL_OW 69
98128: ST_TO_ADDR
// if not depot then
98129: LD_VAR 0 1
98133: NOT
98134: IFFALSE 98138
// exit ;
98136: GO 98173
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
98138: LD_VAR 0 1
98142: PUSH
98143: LD_INT 1
98145: ARRAY
98146: PPUSH
98147: CALL_OW 250
98151: PPUSH
98152: LD_VAR 0 1
98156: PUSH
98157: LD_INT 1
98159: ARRAY
98160: PPUSH
98161: CALL_OW 251
98165: PPUSH
98166: LD_INT 70
98168: PPUSH
98169: CALL_OW 495
// end ;
98173: PPOPN 1
98175: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
98176: LD_EXP 113
98180: PUSH
98181: LD_EXP 147
98185: AND
98186: IFFALSE 98397
98188: GO 98190
98190: DISABLE
98191: LD_INT 0
98193: PPUSH
98194: PPUSH
98195: PPUSH
98196: PPUSH
98197: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98198: LD_ADDR_VAR 0 5
98202: PUSH
98203: LD_INT 22
98205: PUSH
98206: LD_OWVAR 2
98210: PUSH
98211: EMPTY
98212: LIST
98213: LIST
98214: PUSH
98215: LD_INT 21
98217: PUSH
98218: LD_INT 1
98220: PUSH
98221: EMPTY
98222: LIST
98223: LIST
98224: PUSH
98225: EMPTY
98226: LIST
98227: LIST
98228: PPUSH
98229: CALL_OW 69
98233: ST_TO_ADDR
// if not tmp then
98234: LD_VAR 0 5
98238: NOT
98239: IFFALSE 98243
// exit ;
98241: GO 98397
// for i in tmp do
98243: LD_ADDR_VAR 0 1
98247: PUSH
98248: LD_VAR 0 5
98252: PUSH
98253: FOR_IN
98254: IFFALSE 98395
// begin d := rand ( 0 , 5 ) ;
98256: LD_ADDR_VAR 0 4
98260: PUSH
98261: LD_INT 0
98263: PPUSH
98264: LD_INT 5
98266: PPUSH
98267: CALL_OW 12
98271: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
98272: LD_ADDR_VAR 0 2
98276: PUSH
98277: LD_VAR 0 1
98281: PPUSH
98282: CALL_OW 250
98286: PPUSH
98287: LD_VAR 0 4
98291: PPUSH
98292: LD_INT 3
98294: PPUSH
98295: LD_INT 12
98297: PPUSH
98298: CALL_OW 12
98302: PPUSH
98303: CALL_OW 272
98307: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
98308: LD_ADDR_VAR 0 3
98312: PUSH
98313: LD_VAR 0 1
98317: PPUSH
98318: CALL_OW 251
98322: PPUSH
98323: LD_VAR 0 4
98327: PPUSH
98328: LD_INT 3
98330: PPUSH
98331: LD_INT 12
98333: PPUSH
98334: CALL_OW 12
98338: PPUSH
98339: CALL_OW 273
98343: ST_TO_ADDR
// if ValidHex ( x , y ) then
98344: LD_VAR 0 2
98348: PPUSH
98349: LD_VAR 0 3
98353: PPUSH
98354: CALL_OW 488
98358: IFFALSE 98393
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
98360: LD_VAR 0 1
98364: PPUSH
98365: LD_VAR 0 2
98369: PPUSH
98370: LD_VAR 0 3
98374: PPUSH
98375: LD_INT 3
98377: PPUSH
98378: LD_INT 6
98380: PPUSH
98381: CALL_OW 12
98385: PPUSH
98386: LD_INT 1
98388: PPUSH
98389: CALL_OW 483
// end ;
98393: GO 98253
98395: POP
98396: POP
// end ;
98397: PPOPN 5
98399: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
98400: LD_EXP 113
98404: PUSH
98405: LD_EXP 148
98409: AND
98410: IFFALSE 98504
98412: GO 98414
98414: DISABLE
98415: LD_INT 0
98417: PPUSH
98418: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
98419: LD_ADDR_VAR 0 2
98423: PUSH
98424: LD_INT 22
98426: PUSH
98427: LD_OWVAR 2
98431: PUSH
98432: EMPTY
98433: LIST
98434: LIST
98435: PUSH
98436: LD_INT 32
98438: PUSH
98439: LD_INT 1
98441: PUSH
98442: EMPTY
98443: LIST
98444: LIST
98445: PUSH
98446: LD_INT 21
98448: PUSH
98449: LD_INT 2
98451: PUSH
98452: EMPTY
98453: LIST
98454: LIST
98455: PUSH
98456: EMPTY
98457: LIST
98458: LIST
98459: LIST
98460: PPUSH
98461: CALL_OW 69
98465: ST_TO_ADDR
// if not tmp then
98466: LD_VAR 0 2
98470: NOT
98471: IFFALSE 98475
// exit ;
98473: GO 98504
// for i in tmp do
98475: LD_ADDR_VAR 0 1
98479: PUSH
98480: LD_VAR 0 2
98484: PUSH
98485: FOR_IN
98486: IFFALSE 98502
// SetFuel ( i , 0 ) ;
98488: LD_VAR 0 1
98492: PPUSH
98493: LD_INT 0
98495: PPUSH
98496: CALL_OW 240
98500: GO 98485
98502: POP
98503: POP
// end ;
98504: PPOPN 2
98506: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
98507: LD_EXP 113
98511: PUSH
98512: LD_EXP 149
98516: AND
98517: IFFALSE 98583
98519: GO 98521
98521: DISABLE
98522: LD_INT 0
98524: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98525: LD_ADDR_VAR 0 1
98529: PUSH
98530: LD_INT 22
98532: PUSH
98533: LD_OWVAR 2
98537: PUSH
98538: EMPTY
98539: LIST
98540: LIST
98541: PUSH
98542: LD_INT 30
98544: PUSH
98545: LD_INT 29
98547: PUSH
98548: EMPTY
98549: LIST
98550: LIST
98551: PUSH
98552: EMPTY
98553: LIST
98554: LIST
98555: PPUSH
98556: CALL_OW 69
98560: ST_TO_ADDR
// if not tmp then
98561: LD_VAR 0 1
98565: NOT
98566: IFFALSE 98570
// exit ;
98568: GO 98583
// DestroyUnit ( tmp [ 1 ] ) ;
98570: LD_VAR 0 1
98574: PUSH
98575: LD_INT 1
98577: ARRAY
98578: PPUSH
98579: CALL_OW 65
// end ;
98583: PPOPN 1
98585: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
98586: LD_EXP 113
98590: PUSH
98591: LD_EXP 151
98595: AND
98596: IFFALSE 98725
98598: GO 98600
98600: DISABLE
98601: LD_INT 0
98603: PPUSH
// begin uc_side := 0 ;
98604: LD_ADDR_OWVAR 20
98608: PUSH
98609: LD_INT 0
98611: ST_TO_ADDR
// uc_nation := nation_arabian ;
98612: LD_ADDR_OWVAR 21
98616: PUSH
98617: LD_INT 2
98619: ST_TO_ADDR
// hc_gallery :=  ;
98620: LD_ADDR_OWVAR 33
98624: PUSH
98625: LD_STRING 
98627: ST_TO_ADDR
// hc_name :=  ;
98628: LD_ADDR_OWVAR 26
98632: PUSH
98633: LD_STRING 
98635: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
98636: LD_INT 1
98638: PPUSH
98639: LD_INT 11
98641: PPUSH
98642: LD_INT 10
98644: PPUSH
98645: CALL_OW 380
// un := CreateHuman ;
98649: LD_ADDR_VAR 0 1
98653: PUSH
98654: CALL_OW 44
98658: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98659: LD_VAR 0 1
98663: PPUSH
98664: LD_INT 1
98666: PPUSH
98667: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98671: LD_INT 35
98673: PPUSH
98674: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98678: LD_VAR 0 1
98682: PPUSH
98683: LD_INT 22
98685: PUSH
98686: LD_OWVAR 2
98690: PUSH
98691: EMPTY
98692: LIST
98693: LIST
98694: PPUSH
98695: CALL_OW 69
98699: PPUSH
98700: LD_VAR 0 1
98704: PPUSH
98705: CALL_OW 74
98709: PPUSH
98710: CALL_OW 115
// until IsDead ( un ) ;
98714: LD_VAR 0 1
98718: PPUSH
98719: CALL_OW 301
98723: IFFALSE 98671
// end ;
98725: PPOPN 1
98727: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
98728: LD_EXP 113
98732: PUSH
98733: LD_EXP 153
98737: AND
98738: IFFALSE 98750
98740: GO 98742
98742: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
98743: LD_STRING earthquake(getX(game), 0, 32)
98745: PPUSH
98746: CALL_OW 559
98750: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
98751: LD_EXP 113
98755: PUSH
98756: LD_EXP 154
98760: AND
98761: IFFALSE 98852
98763: GO 98765
98765: DISABLE
98766: LD_INT 0
98768: PPUSH
// begin enable ;
98769: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
98770: LD_ADDR_VAR 0 1
98774: PUSH
98775: LD_INT 22
98777: PUSH
98778: LD_OWVAR 2
98782: PUSH
98783: EMPTY
98784: LIST
98785: LIST
98786: PUSH
98787: LD_INT 21
98789: PUSH
98790: LD_INT 2
98792: PUSH
98793: EMPTY
98794: LIST
98795: LIST
98796: PUSH
98797: LD_INT 33
98799: PUSH
98800: LD_INT 3
98802: PUSH
98803: EMPTY
98804: LIST
98805: LIST
98806: PUSH
98807: EMPTY
98808: LIST
98809: LIST
98810: LIST
98811: PPUSH
98812: CALL_OW 69
98816: ST_TO_ADDR
// if not tmp then
98817: LD_VAR 0 1
98821: NOT
98822: IFFALSE 98826
// exit ;
98824: GO 98852
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98826: LD_VAR 0 1
98830: PUSH
98831: LD_INT 1
98833: PPUSH
98834: LD_VAR 0 1
98838: PPUSH
98839: CALL_OW 12
98843: ARRAY
98844: PPUSH
98845: LD_INT 1
98847: PPUSH
98848: CALL_OW 234
// end ;
98852: PPOPN 1
98854: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
98855: LD_EXP 113
98859: PUSH
98860: LD_EXP 155
98864: AND
98865: IFFALSE 99006
98867: GO 98869
98869: DISABLE
98870: LD_INT 0
98872: PPUSH
98873: PPUSH
98874: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98875: LD_ADDR_VAR 0 3
98879: PUSH
98880: LD_INT 22
98882: PUSH
98883: LD_OWVAR 2
98887: PUSH
98888: EMPTY
98889: LIST
98890: LIST
98891: PUSH
98892: LD_INT 25
98894: PUSH
98895: LD_INT 1
98897: PUSH
98898: EMPTY
98899: LIST
98900: LIST
98901: PUSH
98902: EMPTY
98903: LIST
98904: LIST
98905: PPUSH
98906: CALL_OW 69
98910: ST_TO_ADDR
// if not tmp then
98911: LD_VAR 0 3
98915: NOT
98916: IFFALSE 98920
// exit ;
98918: GO 99006
// un := tmp [ rand ( 1 , tmp ) ] ;
98920: LD_ADDR_VAR 0 2
98924: PUSH
98925: LD_VAR 0 3
98929: PUSH
98930: LD_INT 1
98932: PPUSH
98933: LD_VAR 0 3
98937: PPUSH
98938: CALL_OW 12
98942: ARRAY
98943: ST_TO_ADDR
// if Crawls ( un ) then
98944: LD_VAR 0 2
98948: PPUSH
98949: CALL_OW 318
98953: IFFALSE 98964
// ComWalk ( un ) ;
98955: LD_VAR 0 2
98959: PPUSH
98960: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
98964: LD_VAR 0 2
98968: PPUSH
98969: LD_INT 9
98971: PPUSH
98972: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
98976: LD_INT 28
98978: PPUSH
98979: LD_OWVAR 2
98983: PPUSH
98984: LD_INT 2
98986: PPUSH
98987: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
98991: LD_INT 29
98993: PPUSH
98994: LD_OWVAR 2
98998: PPUSH
98999: LD_INT 2
99001: PPUSH
99002: CALL_OW 322
// end ;
99006: PPOPN 3
99008: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
99009: LD_EXP 113
99013: PUSH
99014: LD_EXP 156
99018: AND
99019: IFFALSE 99130
99021: GO 99023
99023: DISABLE
99024: LD_INT 0
99026: PPUSH
99027: PPUSH
99028: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99029: LD_ADDR_VAR 0 3
99033: PUSH
99034: LD_INT 22
99036: PUSH
99037: LD_OWVAR 2
99041: PUSH
99042: EMPTY
99043: LIST
99044: LIST
99045: PUSH
99046: LD_INT 25
99048: PUSH
99049: LD_INT 1
99051: PUSH
99052: EMPTY
99053: LIST
99054: LIST
99055: PUSH
99056: EMPTY
99057: LIST
99058: LIST
99059: PPUSH
99060: CALL_OW 69
99064: ST_TO_ADDR
// if not tmp then
99065: LD_VAR 0 3
99069: NOT
99070: IFFALSE 99074
// exit ;
99072: GO 99130
// un := tmp [ rand ( 1 , tmp ) ] ;
99074: LD_ADDR_VAR 0 2
99078: PUSH
99079: LD_VAR 0 3
99083: PUSH
99084: LD_INT 1
99086: PPUSH
99087: LD_VAR 0 3
99091: PPUSH
99092: CALL_OW 12
99096: ARRAY
99097: ST_TO_ADDR
// if Crawls ( un ) then
99098: LD_VAR 0 2
99102: PPUSH
99103: CALL_OW 318
99107: IFFALSE 99118
// ComWalk ( un ) ;
99109: LD_VAR 0 2
99113: PPUSH
99114: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99118: LD_VAR 0 2
99122: PPUSH
99123: LD_INT 8
99125: PPUSH
99126: CALL_OW 336
// end ;
99130: PPOPN 3
99132: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
99133: LD_EXP 113
99137: PUSH
99138: LD_EXP 157
99142: AND
99143: IFFALSE 99287
99145: GO 99147
99147: DISABLE
99148: LD_INT 0
99150: PPUSH
99151: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
99152: LD_ADDR_VAR 0 2
99156: PUSH
99157: LD_INT 22
99159: PUSH
99160: LD_OWVAR 2
99164: PUSH
99165: EMPTY
99166: LIST
99167: LIST
99168: PUSH
99169: LD_INT 21
99171: PUSH
99172: LD_INT 2
99174: PUSH
99175: EMPTY
99176: LIST
99177: LIST
99178: PUSH
99179: LD_INT 2
99181: PUSH
99182: LD_INT 34
99184: PUSH
99185: LD_INT 12
99187: PUSH
99188: EMPTY
99189: LIST
99190: LIST
99191: PUSH
99192: LD_INT 34
99194: PUSH
99195: LD_INT 51
99197: PUSH
99198: EMPTY
99199: LIST
99200: LIST
99201: PUSH
99202: LD_INT 34
99204: PUSH
99205: LD_INT 32
99207: PUSH
99208: EMPTY
99209: LIST
99210: LIST
99211: PUSH
99212: EMPTY
99213: LIST
99214: LIST
99215: LIST
99216: LIST
99217: PUSH
99218: EMPTY
99219: LIST
99220: LIST
99221: LIST
99222: PPUSH
99223: CALL_OW 69
99227: ST_TO_ADDR
// if not tmp then
99228: LD_VAR 0 2
99232: NOT
99233: IFFALSE 99237
// exit ;
99235: GO 99287
// for i in tmp do
99237: LD_ADDR_VAR 0 1
99241: PUSH
99242: LD_VAR 0 2
99246: PUSH
99247: FOR_IN
99248: IFFALSE 99285
// if GetCargo ( i , mat_artifact ) = 0 then
99250: LD_VAR 0 1
99254: PPUSH
99255: LD_INT 4
99257: PPUSH
99258: CALL_OW 289
99262: PUSH
99263: LD_INT 0
99265: EQUAL
99266: IFFALSE 99283
// SetCargo ( i , mat_siberit , 100 ) ;
99268: LD_VAR 0 1
99272: PPUSH
99273: LD_INT 3
99275: PPUSH
99276: LD_INT 100
99278: PPUSH
99279: CALL_OW 290
99283: GO 99247
99285: POP
99286: POP
// end ;
99287: PPOPN 2
99289: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
99290: LD_EXP 113
99294: PUSH
99295: LD_EXP 158
99299: AND
99300: IFFALSE 99483
99302: GO 99304
99304: DISABLE
99305: LD_INT 0
99307: PPUSH
99308: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99309: LD_ADDR_VAR 0 2
99313: PUSH
99314: LD_INT 22
99316: PUSH
99317: LD_OWVAR 2
99321: PUSH
99322: EMPTY
99323: LIST
99324: LIST
99325: PPUSH
99326: CALL_OW 69
99330: ST_TO_ADDR
// if not tmp then
99331: LD_VAR 0 2
99335: NOT
99336: IFFALSE 99340
// exit ;
99338: GO 99483
// for i := 1 to 2 do
99340: LD_ADDR_VAR 0 1
99344: PUSH
99345: DOUBLE
99346: LD_INT 1
99348: DEC
99349: ST_TO_ADDR
99350: LD_INT 2
99352: PUSH
99353: FOR_TO
99354: IFFALSE 99481
// begin uc_side := your_side ;
99356: LD_ADDR_OWVAR 20
99360: PUSH
99361: LD_OWVAR 2
99365: ST_TO_ADDR
// uc_nation := nation_american ;
99366: LD_ADDR_OWVAR 21
99370: PUSH
99371: LD_INT 1
99373: ST_TO_ADDR
// vc_chassis := us_morphling ;
99374: LD_ADDR_OWVAR 37
99378: PUSH
99379: LD_INT 5
99381: ST_TO_ADDR
// vc_engine := engine_siberite ;
99382: LD_ADDR_OWVAR 39
99386: PUSH
99387: LD_INT 3
99389: ST_TO_ADDR
// vc_control := control_computer ;
99390: LD_ADDR_OWVAR 38
99394: PUSH
99395: LD_INT 3
99397: ST_TO_ADDR
// vc_weapon := us_double_laser ;
99398: LD_ADDR_OWVAR 40
99402: PUSH
99403: LD_INT 10
99405: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
99406: LD_VAR 0 2
99410: PUSH
99411: LD_INT 1
99413: ARRAY
99414: PPUSH
99415: CALL_OW 310
99419: NOT
99420: IFFALSE 99467
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
99422: CALL_OW 45
99426: PPUSH
99427: LD_VAR 0 2
99431: PUSH
99432: LD_INT 1
99434: ARRAY
99435: PPUSH
99436: CALL_OW 250
99440: PPUSH
99441: LD_VAR 0 2
99445: PUSH
99446: LD_INT 1
99448: ARRAY
99449: PPUSH
99450: CALL_OW 251
99454: PPUSH
99455: LD_INT 12
99457: PPUSH
99458: LD_INT 1
99460: PPUSH
99461: CALL_OW 50
99465: GO 99479
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
99467: CALL_OW 45
99471: PPUSH
99472: LD_INT 1
99474: PPUSH
99475: CALL_OW 51
// end ;
99479: GO 99353
99481: POP
99482: POP
// end ;
99483: PPOPN 2
99485: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
99486: LD_EXP 113
99490: PUSH
99491: LD_EXP 159
99495: AND
99496: IFFALSE 99718
99498: GO 99500
99500: DISABLE
99501: LD_INT 0
99503: PPUSH
99504: PPUSH
99505: PPUSH
99506: PPUSH
99507: PPUSH
99508: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99509: LD_ADDR_VAR 0 6
99513: PUSH
99514: LD_INT 22
99516: PUSH
99517: LD_OWVAR 2
99521: PUSH
99522: EMPTY
99523: LIST
99524: LIST
99525: PUSH
99526: LD_INT 21
99528: PUSH
99529: LD_INT 1
99531: PUSH
99532: EMPTY
99533: LIST
99534: LIST
99535: PUSH
99536: LD_INT 3
99538: PUSH
99539: LD_INT 23
99541: PUSH
99542: LD_INT 0
99544: PUSH
99545: EMPTY
99546: LIST
99547: LIST
99548: PUSH
99549: EMPTY
99550: LIST
99551: LIST
99552: PUSH
99553: EMPTY
99554: LIST
99555: LIST
99556: LIST
99557: PPUSH
99558: CALL_OW 69
99562: ST_TO_ADDR
// if not tmp then
99563: LD_VAR 0 6
99567: NOT
99568: IFFALSE 99572
// exit ;
99570: GO 99718
// s1 := rand ( 1 , 4 ) ;
99572: LD_ADDR_VAR 0 2
99576: PUSH
99577: LD_INT 1
99579: PPUSH
99580: LD_INT 4
99582: PPUSH
99583: CALL_OW 12
99587: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
99588: LD_ADDR_VAR 0 4
99592: PUSH
99593: LD_VAR 0 6
99597: PUSH
99598: LD_INT 1
99600: ARRAY
99601: PPUSH
99602: LD_VAR 0 2
99606: PPUSH
99607: CALL_OW 259
99611: ST_TO_ADDR
// if s1 = 1 then
99612: LD_VAR 0 2
99616: PUSH
99617: LD_INT 1
99619: EQUAL
99620: IFFALSE 99640
// s2 := rand ( 2 , 4 ) else
99622: LD_ADDR_VAR 0 3
99626: PUSH
99627: LD_INT 2
99629: PPUSH
99630: LD_INT 4
99632: PPUSH
99633: CALL_OW 12
99637: ST_TO_ADDR
99638: GO 99648
// s2 := 1 ;
99640: LD_ADDR_VAR 0 3
99644: PUSH
99645: LD_INT 1
99647: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
99648: LD_ADDR_VAR 0 5
99652: PUSH
99653: LD_VAR 0 6
99657: PUSH
99658: LD_INT 1
99660: ARRAY
99661: PPUSH
99662: LD_VAR 0 3
99666: PPUSH
99667: CALL_OW 259
99671: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
99672: LD_VAR 0 6
99676: PUSH
99677: LD_INT 1
99679: ARRAY
99680: PPUSH
99681: LD_VAR 0 2
99685: PPUSH
99686: LD_VAR 0 5
99690: PPUSH
99691: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
99695: LD_VAR 0 6
99699: PUSH
99700: LD_INT 1
99702: ARRAY
99703: PPUSH
99704: LD_VAR 0 3
99708: PPUSH
99709: LD_VAR 0 4
99713: PPUSH
99714: CALL_OW 237
// end ;
99718: PPOPN 6
99720: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
99721: LD_EXP 113
99725: PUSH
99726: LD_EXP 160
99730: AND
99731: IFFALSE 99810
99733: GO 99735
99735: DISABLE
99736: LD_INT 0
99738: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
99739: LD_ADDR_VAR 0 1
99743: PUSH
99744: LD_INT 22
99746: PUSH
99747: LD_OWVAR 2
99751: PUSH
99752: EMPTY
99753: LIST
99754: LIST
99755: PUSH
99756: LD_INT 30
99758: PUSH
99759: LD_INT 3
99761: PUSH
99762: EMPTY
99763: LIST
99764: LIST
99765: PUSH
99766: EMPTY
99767: LIST
99768: LIST
99769: PPUSH
99770: CALL_OW 69
99774: ST_TO_ADDR
// if not tmp then
99775: LD_VAR 0 1
99779: NOT
99780: IFFALSE 99784
// exit ;
99782: GO 99810
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99784: LD_VAR 0 1
99788: PUSH
99789: LD_INT 1
99791: PPUSH
99792: LD_VAR 0 1
99796: PPUSH
99797: CALL_OW 12
99801: ARRAY
99802: PPUSH
99803: LD_INT 1
99805: PPUSH
99806: CALL_OW 234
// end ;
99810: PPOPN 1
99812: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
99813: LD_EXP 113
99817: PUSH
99818: LD_EXP 161
99822: AND
99823: IFFALSE 99935
99825: GO 99827
99827: DISABLE
99828: LD_INT 0
99830: PPUSH
99831: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
99832: LD_ADDR_VAR 0 2
99836: PUSH
99837: LD_INT 22
99839: PUSH
99840: LD_OWVAR 2
99844: PUSH
99845: EMPTY
99846: LIST
99847: LIST
99848: PUSH
99849: LD_INT 2
99851: PUSH
99852: LD_INT 30
99854: PUSH
99855: LD_INT 27
99857: PUSH
99858: EMPTY
99859: LIST
99860: LIST
99861: PUSH
99862: LD_INT 30
99864: PUSH
99865: LD_INT 26
99867: PUSH
99868: EMPTY
99869: LIST
99870: LIST
99871: PUSH
99872: LD_INT 30
99874: PUSH
99875: LD_INT 28
99877: PUSH
99878: EMPTY
99879: LIST
99880: LIST
99881: PUSH
99882: EMPTY
99883: LIST
99884: LIST
99885: LIST
99886: LIST
99887: PUSH
99888: EMPTY
99889: LIST
99890: LIST
99891: PPUSH
99892: CALL_OW 69
99896: ST_TO_ADDR
// if not tmp then
99897: LD_VAR 0 2
99901: NOT
99902: IFFALSE 99906
// exit ;
99904: GO 99935
// for i in tmp do
99906: LD_ADDR_VAR 0 1
99910: PUSH
99911: LD_VAR 0 2
99915: PUSH
99916: FOR_IN
99917: IFFALSE 99933
// SetLives ( i , 1 ) ;
99919: LD_VAR 0 1
99923: PPUSH
99924: LD_INT 1
99926: PPUSH
99927: CALL_OW 234
99931: GO 99916
99933: POP
99934: POP
// end ;
99935: PPOPN 2
99937: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
99938: LD_EXP 113
99942: PUSH
99943: LD_EXP 162
99947: AND
99948: IFFALSE 100235
99950: GO 99952
99952: DISABLE
99953: LD_INT 0
99955: PPUSH
99956: PPUSH
99957: PPUSH
// begin i := rand ( 1 , 7 ) ;
99958: LD_ADDR_VAR 0 1
99962: PUSH
99963: LD_INT 1
99965: PPUSH
99966: LD_INT 7
99968: PPUSH
99969: CALL_OW 12
99973: ST_TO_ADDR
// case i of 1 :
99974: LD_VAR 0 1
99978: PUSH
99979: LD_INT 1
99981: DOUBLE
99982: EQUAL
99983: IFTRUE 99987
99985: GO 99997
99987: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
99988: LD_STRING earthquake(getX(game), 0, 32)
99990: PPUSH
99991: CALL_OW 559
99995: GO 100235
99997: LD_INT 2
99999: DOUBLE
100000: EQUAL
100001: IFTRUE 100005
100003: GO 100019
100005: POP
// begin ToLua ( displayStucuk(); ) ;
100006: LD_STRING displayStucuk();
100008: PPUSH
100009: CALL_OW 559
// ResetFog ;
100013: CALL_OW 335
// end ; 3 :
100017: GO 100235
100019: LD_INT 3
100021: DOUBLE
100022: EQUAL
100023: IFTRUE 100027
100025: GO 100131
100027: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100028: LD_ADDR_VAR 0 2
100032: PUSH
100033: LD_INT 22
100035: PUSH
100036: LD_OWVAR 2
100040: PUSH
100041: EMPTY
100042: LIST
100043: LIST
100044: PUSH
100045: LD_INT 25
100047: PUSH
100048: LD_INT 1
100050: PUSH
100051: EMPTY
100052: LIST
100053: LIST
100054: PUSH
100055: EMPTY
100056: LIST
100057: LIST
100058: PPUSH
100059: CALL_OW 69
100063: ST_TO_ADDR
// if not tmp then
100064: LD_VAR 0 2
100068: NOT
100069: IFFALSE 100073
// exit ;
100071: GO 100235
// un := tmp [ rand ( 1 , tmp ) ] ;
100073: LD_ADDR_VAR 0 3
100077: PUSH
100078: LD_VAR 0 2
100082: PUSH
100083: LD_INT 1
100085: PPUSH
100086: LD_VAR 0 2
100090: PPUSH
100091: CALL_OW 12
100095: ARRAY
100096: ST_TO_ADDR
// if Crawls ( un ) then
100097: LD_VAR 0 3
100101: PPUSH
100102: CALL_OW 318
100106: IFFALSE 100117
// ComWalk ( un ) ;
100108: LD_VAR 0 3
100112: PPUSH
100113: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100117: LD_VAR 0 3
100121: PPUSH
100122: LD_INT 8
100124: PPUSH
100125: CALL_OW 336
// end ; 4 :
100129: GO 100235
100131: LD_INT 4
100133: DOUBLE
100134: EQUAL
100135: IFTRUE 100139
100137: GO 100213
100139: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100140: LD_ADDR_VAR 0 2
100144: PUSH
100145: LD_INT 22
100147: PUSH
100148: LD_OWVAR 2
100152: PUSH
100153: EMPTY
100154: LIST
100155: LIST
100156: PUSH
100157: LD_INT 30
100159: PUSH
100160: LD_INT 29
100162: PUSH
100163: EMPTY
100164: LIST
100165: LIST
100166: PUSH
100167: EMPTY
100168: LIST
100169: LIST
100170: PPUSH
100171: CALL_OW 69
100175: ST_TO_ADDR
// if not tmp then
100176: LD_VAR 0 2
100180: NOT
100181: IFFALSE 100185
// exit ;
100183: GO 100235
// CenterNowOnUnits ( tmp [ 1 ] ) ;
100185: LD_VAR 0 2
100189: PUSH
100190: LD_INT 1
100192: ARRAY
100193: PPUSH
100194: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
100198: LD_VAR 0 2
100202: PUSH
100203: LD_INT 1
100205: ARRAY
100206: PPUSH
100207: CALL_OW 65
// end ; 5 .. 7 :
100211: GO 100235
100213: LD_INT 5
100215: DOUBLE
100216: GREATEREQUAL
100217: IFFALSE 100225
100219: LD_INT 7
100221: DOUBLE
100222: LESSEQUAL
100223: IFTRUE 100227
100225: GO 100234
100227: POP
// StreamSibBomb ; end ;
100228: CALL 96472 0 0
100232: GO 100235
100234: POP
// end ;
100235: PPOPN 3
100237: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
100238: LD_EXP 113
100242: PUSH
100243: LD_EXP 163
100247: AND
100248: IFFALSE 100404
100250: GO 100252
100252: DISABLE
100253: LD_INT 0
100255: PPUSH
100256: PPUSH
100257: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
100258: LD_ADDR_VAR 0 2
100262: PUSH
100263: LD_INT 81
100265: PUSH
100266: LD_OWVAR 2
100270: PUSH
100271: EMPTY
100272: LIST
100273: LIST
100274: PUSH
100275: LD_INT 2
100277: PUSH
100278: LD_INT 21
100280: PUSH
100281: LD_INT 1
100283: PUSH
100284: EMPTY
100285: LIST
100286: LIST
100287: PUSH
100288: LD_INT 21
100290: PUSH
100291: LD_INT 2
100293: PUSH
100294: EMPTY
100295: LIST
100296: LIST
100297: PUSH
100298: EMPTY
100299: LIST
100300: LIST
100301: LIST
100302: PUSH
100303: EMPTY
100304: LIST
100305: LIST
100306: PPUSH
100307: CALL_OW 69
100311: ST_TO_ADDR
// if not tmp then
100312: LD_VAR 0 2
100316: NOT
100317: IFFALSE 100321
// exit ;
100319: GO 100404
// p := 0 ;
100321: LD_ADDR_VAR 0 3
100325: PUSH
100326: LD_INT 0
100328: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100329: LD_INT 35
100331: PPUSH
100332: CALL_OW 67
// p := p + 1 ;
100336: LD_ADDR_VAR 0 3
100340: PUSH
100341: LD_VAR 0 3
100345: PUSH
100346: LD_INT 1
100348: PLUS
100349: ST_TO_ADDR
// for i in tmp do
100350: LD_ADDR_VAR 0 1
100354: PUSH
100355: LD_VAR 0 2
100359: PUSH
100360: FOR_IN
100361: IFFALSE 100392
// if GetLives ( i ) < 1000 then
100363: LD_VAR 0 1
100367: PPUSH
100368: CALL_OW 256
100372: PUSH
100373: LD_INT 1000
100375: LESS
100376: IFFALSE 100390
// SetLives ( i , 1000 ) ;
100378: LD_VAR 0 1
100382: PPUSH
100383: LD_INT 1000
100385: PPUSH
100386: CALL_OW 234
100390: GO 100360
100392: POP
100393: POP
// until p > 20 ;
100394: LD_VAR 0 3
100398: PUSH
100399: LD_INT 20
100401: GREATER
100402: IFFALSE 100329
// end ;
100404: PPOPN 3
100406: END
// every 0 0$1 trigger StreamModeActive and sTime do
100407: LD_EXP 113
100411: PUSH
100412: LD_EXP 164
100416: AND
100417: IFFALSE 100452
100419: GO 100421
100421: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
100422: LD_INT 28
100424: PPUSH
100425: LD_OWVAR 2
100429: PPUSH
100430: LD_INT 2
100432: PPUSH
100433: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
100437: LD_INT 30
100439: PPUSH
100440: LD_OWVAR 2
100444: PPUSH
100445: LD_INT 2
100447: PPUSH
100448: CALL_OW 322
// end ;
100452: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
100453: LD_EXP 113
100457: PUSH
100458: LD_EXP 165
100462: AND
100463: IFFALSE 100584
100465: GO 100467
100467: DISABLE
100468: LD_INT 0
100470: PPUSH
100471: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100472: LD_ADDR_VAR 0 2
100476: PUSH
100477: LD_INT 22
100479: PUSH
100480: LD_OWVAR 2
100484: PUSH
100485: EMPTY
100486: LIST
100487: LIST
100488: PUSH
100489: LD_INT 21
100491: PUSH
100492: LD_INT 1
100494: PUSH
100495: EMPTY
100496: LIST
100497: LIST
100498: PUSH
100499: LD_INT 3
100501: PUSH
100502: LD_INT 23
100504: PUSH
100505: LD_INT 0
100507: PUSH
100508: EMPTY
100509: LIST
100510: LIST
100511: PUSH
100512: EMPTY
100513: LIST
100514: LIST
100515: PUSH
100516: EMPTY
100517: LIST
100518: LIST
100519: LIST
100520: PPUSH
100521: CALL_OW 69
100525: ST_TO_ADDR
// if not tmp then
100526: LD_VAR 0 2
100530: NOT
100531: IFFALSE 100535
// exit ;
100533: GO 100584
// for i in tmp do
100535: LD_ADDR_VAR 0 1
100539: PUSH
100540: LD_VAR 0 2
100544: PUSH
100545: FOR_IN
100546: IFFALSE 100582
// begin if Crawls ( i ) then
100548: LD_VAR 0 1
100552: PPUSH
100553: CALL_OW 318
100557: IFFALSE 100568
// ComWalk ( i ) ;
100559: LD_VAR 0 1
100563: PPUSH
100564: CALL_OW 138
// SetClass ( i , 2 ) ;
100568: LD_VAR 0 1
100572: PPUSH
100573: LD_INT 2
100575: PPUSH
100576: CALL_OW 336
// end ;
100580: GO 100545
100582: POP
100583: POP
// end ;
100584: PPOPN 2
100586: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
100587: LD_EXP 113
100591: PUSH
100592: LD_EXP 166
100596: AND
100597: IFFALSE 100885
100599: GO 100601
100601: DISABLE
100602: LD_INT 0
100604: PPUSH
100605: PPUSH
100606: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
100607: LD_OWVAR 2
100611: PPUSH
100612: LD_INT 9
100614: PPUSH
100615: LD_INT 1
100617: PPUSH
100618: LD_INT 1
100620: PPUSH
100621: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
100625: LD_INT 9
100627: PPUSH
100628: LD_OWVAR 2
100632: PPUSH
100633: CALL_OW 343
// uc_side := 9 ;
100637: LD_ADDR_OWVAR 20
100641: PUSH
100642: LD_INT 9
100644: ST_TO_ADDR
// uc_nation := 2 ;
100645: LD_ADDR_OWVAR 21
100649: PUSH
100650: LD_INT 2
100652: ST_TO_ADDR
// hc_name := Dark Warrior ;
100653: LD_ADDR_OWVAR 26
100657: PUSH
100658: LD_STRING Dark Warrior
100660: ST_TO_ADDR
// hc_gallery :=  ;
100661: LD_ADDR_OWVAR 33
100665: PUSH
100666: LD_STRING 
100668: ST_TO_ADDR
// hc_noskilllimit := true ;
100669: LD_ADDR_OWVAR 76
100673: PUSH
100674: LD_INT 1
100676: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
100677: LD_ADDR_OWVAR 31
100681: PUSH
100682: LD_INT 30
100684: PUSH
100685: LD_INT 30
100687: PUSH
100688: LD_INT 30
100690: PUSH
100691: LD_INT 30
100693: PUSH
100694: EMPTY
100695: LIST
100696: LIST
100697: LIST
100698: LIST
100699: ST_TO_ADDR
// un := CreateHuman ;
100700: LD_ADDR_VAR 0 3
100704: PUSH
100705: CALL_OW 44
100709: ST_TO_ADDR
// hc_noskilllimit := false ;
100710: LD_ADDR_OWVAR 76
100714: PUSH
100715: LD_INT 0
100717: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100718: LD_VAR 0 3
100722: PPUSH
100723: LD_INT 1
100725: PPUSH
100726: CALL_OW 51
// ToLua ( playRanger() ) ;
100730: LD_STRING playRanger()
100732: PPUSH
100733: CALL_OW 559
// p := 0 ;
100737: LD_ADDR_VAR 0 2
100741: PUSH
100742: LD_INT 0
100744: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100745: LD_INT 35
100747: PPUSH
100748: CALL_OW 67
// p := p + 1 ;
100752: LD_ADDR_VAR 0 2
100756: PUSH
100757: LD_VAR 0 2
100761: PUSH
100762: LD_INT 1
100764: PLUS
100765: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
100766: LD_VAR 0 3
100770: PPUSH
100771: CALL_OW 256
100775: PUSH
100776: LD_INT 1000
100778: LESS
100779: IFFALSE 100793
// SetLives ( un , 1000 ) ;
100781: LD_VAR 0 3
100785: PPUSH
100786: LD_INT 1000
100788: PPUSH
100789: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
100793: LD_VAR 0 3
100797: PPUSH
100798: LD_INT 81
100800: PUSH
100801: LD_OWVAR 2
100805: PUSH
100806: EMPTY
100807: LIST
100808: LIST
100809: PUSH
100810: LD_INT 91
100812: PUSH
100813: LD_VAR 0 3
100817: PUSH
100818: LD_INT 30
100820: PUSH
100821: EMPTY
100822: LIST
100823: LIST
100824: LIST
100825: PUSH
100826: EMPTY
100827: LIST
100828: LIST
100829: PPUSH
100830: CALL_OW 69
100834: PPUSH
100835: LD_VAR 0 3
100839: PPUSH
100840: CALL_OW 74
100844: PPUSH
100845: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
100849: LD_VAR 0 2
100853: PUSH
100854: LD_INT 80
100856: GREATER
100857: PUSH
100858: LD_VAR 0 3
100862: PPUSH
100863: CALL_OW 301
100867: OR
100868: IFFALSE 100745
// if un then
100870: LD_VAR 0 3
100874: IFFALSE 100885
// RemoveUnit ( un ) ;
100876: LD_VAR 0 3
100880: PPUSH
100881: CALL_OW 64
// end ;
100885: PPOPN 3
100887: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
100888: LD_EXP 167
100892: IFFALSE 101008
100894: GO 100896
100896: DISABLE
100897: LD_INT 0
100899: PPUSH
100900: PPUSH
100901: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100902: LD_ADDR_VAR 0 2
100906: PUSH
100907: LD_INT 81
100909: PUSH
100910: LD_OWVAR 2
100914: PUSH
100915: EMPTY
100916: LIST
100917: LIST
100918: PUSH
100919: LD_INT 21
100921: PUSH
100922: LD_INT 1
100924: PUSH
100925: EMPTY
100926: LIST
100927: LIST
100928: PUSH
100929: EMPTY
100930: LIST
100931: LIST
100932: PPUSH
100933: CALL_OW 69
100937: ST_TO_ADDR
// ToLua ( playComputer() ) ;
100938: LD_STRING playComputer()
100940: PPUSH
100941: CALL_OW 559
// if not tmp then
100945: LD_VAR 0 2
100949: NOT
100950: IFFALSE 100954
// exit ;
100952: GO 101008
// for i in tmp do
100954: LD_ADDR_VAR 0 1
100958: PUSH
100959: LD_VAR 0 2
100963: PUSH
100964: FOR_IN
100965: IFFALSE 101006
// for j := 1 to 4 do
100967: LD_ADDR_VAR 0 3
100971: PUSH
100972: DOUBLE
100973: LD_INT 1
100975: DEC
100976: ST_TO_ADDR
100977: LD_INT 4
100979: PUSH
100980: FOR_TO
100981: IFFALSE 101002
// SetSkill ( i , j , 10 ) ;
100983: LD_VAR 0 1
100987: PPUSH
100988: LD_VAR 0 3
100992: PPUSH
100993: LD_INT 10
100995: PPUSH
100996: CALL_OW 237
101000: GO 100980
101002: POP
101003: POP
101004: GO 100964
101006: POP
101007: POP
// end ;
101008: PPOPN 3
101010: END
// every 0 0$1 trigger s30 do var i , tmp ;
101011: LD_EXP 168
101015: IFFALSE 101084
101017: GO 101019
101019: DISABLE
101020: LD_INT 0
101022: PPUSH
101023: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101024: LD_ADDR_VAR 0 2
101028: PUSH
101029: LD_INT 22
101031: PUSH
101032: LD_OWVAR 2
101036: PUSH
101037: EMPTY
101038: LIST
101039: LIST
101040: PPUSH
101041: CALL_OW 69
101045: ST_TO_ADDR
// if not tmp then
101046: LD_VAR 0 2
101050: NOT
101051: IFFALSE 101055
// exit ;
101053: GO 101084
// for i in tmp do
101055: LD_ADDR_VAR 0 1
101059: PUSH
101060: LD_VAR 0 2
101064: PUSH
101065: FOR_IN
101066: IFFALSE 101082
// SetLives ( i , 300 ) ;
101068: LD_VAR 0 1
101072: PPUSH
101073: LD_INT 300
101075: PPUSH
101076: CALL_OW 234
101080: GO 101065
101082: POP
101083: POP
// end ;
101084: PPOPN 2
101086: END
// every 0 0$1 trigger s60 do var i , tmp ;
101087: LD_EXP 169
101091: IFFALSE 101160
101093: GO 101095
101095: DISABLE
101096: LD_INT 0
101098: PPUSH
101099: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101100: LD_ADDR_VAR 0 2
101104: PUSH
101105: LD_INT 22
101107: PUSH
101108: LD_OWVAR 2
101112: PUSH
101113: EMPTY
101114: LIST
101115: LIST
101116: PPUSH
101117: CALL_OW 69
101121: ST_TO_ADDR
// if not tmp then
101122: LD_VAR 0 2
101126: NOT
101127: IFFALSE 101131
// exit ;
101129: GO 101160
// for i in tmp do
101131: LD_ADDR_VAR 0 1
101135: PUSH
101136: LD_VAR 0 2
101140: PUSH
101141: FOR_IN
101142: IFFALSE 101158
// SetLives ( i , 600 ) ;
101144: LD_VAR 0 1
101148: PPUSH
101149: LD_INT 600
101151: PPUSH
101152: CALL_OW 234
101156: GO 101141
101158: POP
101159: POP
// end ;
101160: PPOPN 2
101162: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
101163: LD_INT 0
101165: PPUSH
// case cmd of 301 :
101166: LD_VAR 0 1
101170: PUSH
101171: LD_INT 301
101173: DOUBLE
101174: EQUAL
101175: IFTRUE 101179
101177: GO 101211
101179: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
101180: LD_VAR 0 6
101184: PPUSH
101185: LD_VAR 0 7
101189: PPUSH
101190: LD_VAR 0 8
101194: PPUSH
101195: LD_VAR 0 4
101199: PPUSH
101200: LD_VAR 0 5
101204: PPUSH
101205: CALL 102412 0 5
101209: GO 101332
101211: LD_INT 302
101213: DOUBLE
101214: EQUAL
101215: IFTRUE 101219
101217: GO 101256
101219: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
101220: LD_VAR 0 6
101224: PPUSH
101225: LD_VAR 0 7
101229: PPUSH
101230: LD_VAR 0 8
101234: PPUSH
101235: LD_VAR 0 9
101239: PPUSH
101240: LD_VAR 0 4
101244: PPUSH
101245: LD_VAR 0 5
101249: PPUSH
101250: CALL 102503 0 6
101254: GO 101332
101256: LD_INT 303
101258: DOUBLE
101259: EQUAL
101260: IFTRUE 101264
101262: GO 101301
101264: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
101265: LD_VAR 0 6
101269: PPUSH
101270: LD_VAR 0 7
101274: PPUSH
101275: LD_VAR 0 8
101279: PPUSH
101280: LD_VAR 0 9
101284: PPUSH
101285: LD_VAR 0 4
101289: PPUSH
101290: LD_VAR 0 5
101294: PPUSH
101295: CALL 101337 0 6
101299: GO 101332
101301: LD_INT 304
101303: DOUBLE
101304: EQUAL
101305: IFTRUE 101309
101307: GO 101331
101309: POP
// hHackTeleport ( unit , x , y ) ; end ;
101310: LD_VAR 0 2
101314: PPUSH
101315: LD_VAR 0 4
101319: PPUSH
101320: LD_VAR 0 5
101324: PPUSH
101325: CALL 103096 0 3
101329: GO 101332
101331: POP
// end ;
101332: LD_VAR 0 12
101336: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
101337: LD_INT 0
101339: PPUSH
101340: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
101341: LD_VAR 0 1
101345: PUSH
101346: LD_INT 1
101348: LESS
101349: PUSH
101350: LD_VAR 0 1
101354: PUSH
101355: LD_INT 3
101357: GREATER
101358: OR
101359: PUSH
101360: LD_VAR 0 5
101364: PPUSH
101365: LD_VAR 0 6
101369: PPUSH
101370: CALL_OW 428
101374: OR
101375: IFFALSE 101379
// exit ;
101377: GO 102099
// uc_side := your_side ;
101379: LD_ADDR_OWVAR 20
101383: PUSH
101384: LD_OWVAR 2
101388: ST_TO_ADDR
// uc_nation := nation ;
101389: LD_ADDR_OWVAR 21
101393: PUSH
101394: LD_VAR 0 1
101398: ST_TO_ADDR
// bc_level = 1 ;
101399: LD_ADDR_OWVAR 43
101403: PUSH
101404: LD_INT 1
101406: ST_TO_ADDR
// case btype of 1 :
101407: LD_VAR 0 2
101411: PUSH
101412: LD_INT 1
101414: DOUBLE
101415: EQUAL
101416: IFTRUE 101420
101418: GO 101431
101420: POP
// bc_type := b_depot ; 2 :
101421: LD_ADDR_OWVAR 42
101425: PUSH
101426: LD_INT 0
101428: ST_TO_ADDR
101429: GO 102043
101431: LD_INT 2
101433: DOUBLE
101434: EQUAL
101435: IFTRUE 101439
101437: GO 101450
101439: POP
// bc_type := b_warehouse ; 3 :
101440: LD_ADDR_OWVAR 42
101444: PUSH
101445: LD_INT 1
101447: ST_TO_ADDR
101448: GO 102043
101450: LD_INT 3
101452: DOUBLE
101453: EQUAL
101454: IFTRUE 101458
101456: GO 101469
101458: POP
// bc_type := b_lab ; 4 .. 9 :
101459: LD_ADDR_OWVAR 42
101463: PUSH
101464: LD_INT 6
101466: ST_TO_ADDR
101467: GO 102043
101469: LD_INT 4
101471: DOUBLE
101472: GREATEREQUAL
101473: IFFALSE 101481
101475: LD_INT 9
101477: DOUBLE
101478: LESSEQUAL
101479: IFTRUE 101483
101481: GO 101535
101483: POP
// begin bc_type := b_lab_half ;
101484: LD_ADDR_OWVAR 42
101488: PUSH
101489: LD_INT 7
101491: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
101492: LD_ADDR_OWVAR 44
101496: PUSH
101497: LD_INT 10
101499: PUSH
101500: LD_INT 11
101502: PUSH
101503: LD_INT 12
101505: PUSH
101506: LD_INT 15
101508: PUSH
101509: LD_INT 14
101511: PUSH
101512: LD_INT 13
101514: PUSH
101515: EMPTY
101516: LIST
101517: LIST
101518: LIST
101519: LIST
101520: LIST
101521: LIST
101522: PUSH
101523: LD_VAR 0 2
101527: PUSH
101528: LD_INT 3
101530: MINUS
101531: ARRAY
101532: ST_TO_ADDR
// end ; 10 .. 13 :
101533: GO 102043
101535: LD_INT 10
101537: DOUBLE
101538: GREATEREQUAL
101539: IFFALSE 101547
101541: LD_INT 13
101543: DOUBLE
101544: LESSEQUAL
101545: IFTRUE 101549
101547: GO 101626
101549: POP
// begin bc_type := b_lab_full ;
101550: LD_ADDR_OWVAR 42
101554: PUSH
101555: LD_INT 8
101557: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
101558: LD_ADDR_OWVAR 44
101562: PUSH
101563: LD_INT 10
101565: PUSH
101566: LD_INT 12
101568: PUSH
101569: LD_INT 14
101571: PUSH
101572: LD_INT 13
101574: PUSH
101575: EMPTY
101576: LIST
101577: LIST
101578: LIST
101579: LIST
101580: PUSH
101581: LD_VAR 0 2
101585: PUSH
101586: LD_INT 9
101588: MINUS
101589: ARRAY
101590: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
101591: LD_ADDR_OWVAR 45
101595: PUSH
101596: LD_INT 11
101598: PUSH
101599: LD_INT 15
101601: PUSH
101602: LD_INT 12
101604: PUSH
101605: LD_INT 15
101607: PUSH
101608: EMPTY
101609: LIST
101610: LIST
101611: LIST
101612: LIST
101613: PUSH
101614: LD_VAR 0 2
101618: PUSH
101619: LD_INT 9
101621: MINUS
101622: ARRAY
101623: ST_TO_ADDR
// end ; 14 :
101624: GO 102043
101626: LD_INT 14
101628: DOUBLE
101629: EQUAL
101630: IFTRUE 101634
101632: GO 101645
101634: POP
// bc_type := b_workshop ; 15 :
101635: LD_ADDR_OWVAR 42
101639: PUSH
101640: LD_INT 2
101642: ST_TO_ADDR
101643: GO 102043
101645: LD_INT 15
101647: DOUBLE
101648: EQUAL
101649: IFTRUE 101653
101651: GO 101664
101653: POP
// bc_type := b_factory ; 16 :
101654: LD_ADDR_OWVAR 42
101658: PUSH
101659: LD_INT 3
101661: ST_TO_ADDR
101662: GO 102043
101664: LD_INT 16
101666: DOUBLE
101667: EQUAL
101668: IFTRUE 101672
101670: GO 101683
101672: POP
// bc_type := b_ext_gun ; 17 :
101673: LD_ADDR_OWVAR 42
101677: PUSH
101678: LD_INT 17
101680: ST_TO_ADDR
101681: GO 102043
101683: LD_INT 17
101685: DOUBLE
101686: EQUAL
101687: IFTRUE 101691
101689: GO 101719
101691: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
101692: LD_ADDR_OWVAR 42
101696: PUSH
101697: LD_INT 19
101699: PUSH
101700: LD_INT 23
101702: PUSH
101703: LD_INT 19
101705: PUSH
101706: EMPTY
101707: LIST
101708: LIST
101709: LIST
101710: PUSH
101711: LD_VAR 0 1
101715: ARRAY
101716: ST_TO_ADDR
101717: GO 102043
101719: LD_INT 18
101721: DOUBLE
101722: EQUAL
101723: IFTRUE 101727
101725: GO 101738
101727: POP
// bc_type := b_ext_radar ; 19 :
101728: LD_ADDR_OWVAR 42
101732: PUSH
101733: LD_INT 20
101735: ST_TO_ADDR
101736: GO 102043
101738: LD_INT 19
101740: DOUBLE
101741: EQUAL
101742: IFTRUE 101746
101744: GO 101757
101746: POP
// bc_type := b_ext_radio ; 20 :
101747: LD_ADDR_OWVAR 42
101751: PUSH
101752: LD_INT 22
101754: ST_TO_ADDR
101755: GO 102043
101757: LD_INT 20
101759: DOUBLE
101760: EQUAL
101761: IFTRUE 101765
101763: GO 101776
101765: POP
// bc_type := b_ext_siberium ; 21 :
101766: LD_ADDR_OWVAR 42
101770: PUSH
101771: LD_INT 21
101773: ST_TO_ADDR
101774: GO 102043
101776: LD_INT 21
101778: DOUBLE
101779: EQUAL
101780: IFTRUE 101784
101782: GO 101795
101784: POP
// bc_type := b_ext_computer ; 22 :
101785: LD_ADDR_OWVAR 42
101789: PUSH
101790: LD_INT 24
101792: ST_TO_ADDR
101793: GO 102043
101795: LD_INT 22
101797: DOUBLE
101798: EQUAL
101799: IFTRUE 101803
101801: GO 101814
101803: POP
// bc_type := b_ext_track ; 23 :
101804: LD_ADDR_OWVAR 42
101808: PUSH
101809: LD_INT 16
101811: ST_TO_ADDR
101812: GO 102043
101814: LD_INT 23
101816: DOUBLE
101817: EQUAL
101818: IFTRUE 101822
101820: GO 101833
101822: POP
// bc_type := b_ext_laser ; 24 :
101823: LD_ADDR_OWVAR 42
101827: PUSH
101828: LD_INT 25
101830: ST_TO_ADDR
101831: GO 102043
101833: LD_INT 24
101835: DOUBLE
101836: EQUAL
101837: IFTRUE 101841
101839: GO 101852
101841: POP
// bc_type := b_control_tower ; 25 :
101842: LD_ADDR_OWVAR 42
101846: PUSH
101847: LD_INT 36
101849: ST_TO_ADDR
101850: GO 102043
101852: LD_INT 25
101854: DOUBLE
101855: EQUAL
101856: IFTRUE 101860
101858: GO 101871
101860: POP
// bc_type := b_breastwork ; 26 :
101861: LD_ADDR_OWVAR 42
101865: PUSH
101866: LD_INT 31
101868: ST_TO_ADDR
101869: GO 102043
101871: LD_INT 26
101873: DOUBLE
101874: EQUAL
101875: IFTRUE 101879
101877: GO 101890
101879: POP
// bc_type := b_bunker ; 27 :
101880: LD_ADDR_OWVAR 42
101884: PUSH
101885: LD_INT 32
101887: ST_TO_ADDR
101888: GO 102043
101890: LD_INT 27
101892: DOUBLE
101893: EQUAL
101894: IFTRUE 101898
101896: GO 101909
101898: POP
// bc_type := b_turret ; 28 :
101899: LD_ADDR_OWVAR 42
101903: PUSH
101904: LD_INT 33
101906: ST_TO_ADDR
101907: GO 102043
101909: LD_INT 28
101911: DOUBLE
101912: EQUAL
101913: IFTRUE 101917
101915: GO 101928
101917: POP
// bc_type := b_armoury ; 29 :
101918: LD_ADDR_OWVAR 42
101922: PUSH
101923: LD_INT 4
101925: ST_TO_ADDR
101926: GO 102043
101928: LD_INT 29
101930: DOUBLE
101931: EQUAL
101932: IFTRUE 101936
101934: GO 101947
101936: POP
// bc_type := b_barracks ; 30 :
101937: LD_ADDR_OWVAR 42
101941: PUSH
101942: LD_INT 5
101944: ST_TO_ADDR
101945: GO 102043
101947: LD_INT 30
101949: DOUBLE
101950: EQUAL
101951: IFTRUE 101955
101953: GO 101966
101955: POP
// bc_type := b_solar_power ; 31 :
101956: LD_ADDR_OWVAR 42
101960: PUSH
101961: LD_INT 27
101963: ST_TO_ADDR
101964: GO 102043
101966: LD_INT 31
101968: DOUBLE
101969: EQUAL
101970: IFTRUE 101974
101972: GO 101985
101974: POP
// bc_type := b_oil_power ; 32 :
101975: LD_ADDR_OWVAR 42
101979: PUSH
101980: LD_INT 26
101982: ST_TO_ADDR
101983: GO 102043
101985: LD_INT 32
101987: DOUBLE
101988: EQUAL
101989: IFTRUE 101993
101991: GO 102004
101993: POP
// bc_type := b_siberite_power ; 33 :
101994: LD_ADDR_OWVAR 42
101998: PUSH
101999: LD_INT 28
102001: ST_TO_ADDR
102002: GO 102043
102004: LD_INT 33
102006: DOUBLE
102007: EQUAL
102008: IFTRUE 102012
102010: GO 102023
102012: POP
// bc_type := b_oil_mine ; 34 :
102013: LD_ADDR_OWVAR 42
102017: PUSH
102018: LD_INT 29
102020: ST_TO_ADDR
102021: GO 102043
102023: LD_INT 34
102025: DOUBLE
102026: EQUAL
102027: IFTRUE 102031
102029: GO 102042
102031: POP
// bc_type := b_siberite_mine ; end ;
102032: LD_ADDR_OWVAR 42
102036: PUSH
102037: LD_INT 30
102039: ST_TO_ADDR
102040: GO 102043
102042: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
102043: LD_ADDR_VAR 0 8
102047: PUSH
102048: LD_VAR 0 5
102052: PPUSH
102053: LD_VAR 0 6
102057: PPUSH
102058: LD_VAR 0 3
102062: PPUSH
102063: CALL_OW 47
102067: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
102068: LD_OWVAR 42
102072: PUSH
102073: LD_INT 32
102075: PUSH
102076: LD_INT 33
102078: PUSH
102079: EMPTY
102080: LIST
102081: LIST
102082: IN
102083: IFFALSE 102099
// PlaceWeaponTurret ( b , weapon ) ;
102085: LD_VAR 0 8
102089: PPUSH
102090: LD_VAR 0 4
102094: PPUSH
102095: CALL_OW 431
// end ;
102099: LD_VAR 0 7
102103: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
102104: LD_INT 0
102106: PPUSH
102107: PPUSH
102108: PPUSH
102109: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102110: LD_ADDR_VAR 0 4
102114: PUSH
102115: LD_INT 22
102117: PUSH
102118: LD_OWVAR 2
102122: PUSH
102123: EMPTY
102124: LIST
102125: LIST
102126: PUSH
102127: LD_INT 2
102129: PUSH
102130: LD_INT 30
102132: PUSH
102133: LD_INT 0
102135: PUSH
102136: EMPTY
102137: LIST
102138: LIST
102139: PUSH
102140: LD_INT 30
102142: PUSH
102143: LD_INT 1
102145: PUSH
102146: EMPTY
102147: LIST
102148: LIST
102149: PUSH
102150: EMPTY
102151: LIST
102152: LIST
102153: LIST
102154: PUSH
102155: EMPTY
102156: LIST
102157: LIST
102158: PPUSH
102159: CALL_OW 69
102163: ST_TO_ADDR
// if not tmp then
102164: LD_VAR 0 4
102168: NOT
102169: IFFALSE 102173
// exit ;
102171: GO 102232
// for i in tmp do
102173: LD_ADDR_VAR 0 2
102177: PUSH
102178: LD_VAR 0 4
102182: PUSH
102183: FOR_IN
102184: IFFALSE 102230
// for j = 1 to 3 do
102186: LD_ADDR_VAR 0 3
102190: PUSH
102191: DOUBLE
102192: LD_INT 1
102194: DEC
102195: ST_TO_ADDR
102196: LD_INT 3
102198: PUSH
102199: FOR_TO
102200: IFFALSE 102226
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
102202: LD_VAR 0 2
102206: PPUSH
102207: CALL_OW 274
102211: PPUSH
102212: LD_VAR 0 3
102216: PPUSH
102217: LD_INT 99999
102219: PPUSH
102220: CALL_OW 277
102224: GO 102199
102226: POP
102227: POP
102228: GO 102183
102230: POP
102231: POP
// end ;
102232: LD_VAR 0 1
102236: RET
// export function hHackSetLevel10 ; var i , j ; begin
102237: LD_INT 0
102239: PPUSH
102240: PPUSH
102241: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102242: LD_ADDR_VAR 0 2
102246: PUSH
102247: LD_INT 21
102249: PUSH
102250: LD_INT 1
102252: PUSH
102253: EMPTY
102254: LIST
102255: LIST
102256: PPUSH
102257: CALL_OW 69
102261: PUSH
102262: FOR_IN
102263: IFFALSE 102315
// if IsSelected ( i ) then
102265: LD_VAR 0 2
102269: PPUSH
102270: CALL_OW 306
102274: IFFALSE 102313
// begin for j := 1 to 4 do
102276: LD_ADDR_VAR 0 3
102280: PUSH
102281: DOUBLE
102282: LD_INT 1
102284: DEC
102285: ST_TO_ADDR
102286: LD_INT 4
102288: PUSH
102289: FOR_TO
102290: IFFALSE 102311
// SetSkill ( i , j , 10 ) ;
102292: LD_VAR 0 2
102296: PPUSH
102297: LD_VAR 0 3
102301: PPUSH
102302: LD_INT 10
102304: PPUSH
102305: CALL_OW 237
102309: GO 102289
102311: POP
102312: POP
// end ;
102313: GO 102262
102315: POP
102316: POP
// end ;
102317: LD_VAR 0 1
102321: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
102322: LD_INT 0
102324: PPUSH
102325: PPUSH
102326: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
102327: LD_ADDR_VAR 0 2
102331: PUSH
102332: LD_INT 22
102334: PUSH
102335: LD_OWVAR 2
102339: PUSH
102340: EMPTY
102341: LIST
102342: LIST
102343: PUSH
102344: LD_INT 21
102346: PUSH
102347: LD_INT 1
102349: PUSH
102350: EMPTY
102351: LIST
102352: LIST
102353: PUSH
102354: EMPTY
102355: LIST
102356: LIST
102357: PPUSH
102358: CALL_OW 69
102362: PUSH
102363: FOR_IN
102364: IFFALSE 102405
// begin for j := 1 to 4 do
102366: LD_ADDR_VAR 0 3
102370: PUSH
102371: DOUBLE
102372: LD_INT 1
102374: DEC
102375: ST_TO_ADDR
102376: LD_INT 4
102378: PUSH
102379: FOR_TO
102380: IFFALSE 102401
// SetSkill ( i , j , 10 ) ;
102382: LD_VAR 0 2
102386: PPUSH
102387: LD_VAR 0 3
102391: PPUSH
102392: LD_INT 10
102394: PPUSH
102395: CALL_OW 237
102399: GO 102379
102401: POP
102402: POP
// end ;
102403: GO 102363
102405: POP
102406: POP
// end ;
102407: LD_VAR 0 1
102411: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
102412: LD_INT 0
102414: PPUSH
// uc_side := your_side ;
102415: LD_ADDR_OWVAR 20
102419: PUSH
102420: LD_OWVAR 2
102424: ST_TO_ADDR
// uc_nation := nation ;
102425: LD_ADDR_OWVAR 21
102429: PUSH
102430: LD_VAR 0 1
102434: ST_TO_ADDR
// InitHc ;
102435: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
102439: LD_INT 0
102441: PPUSH
102442: LD_VAR 0 2
102446: PPUSH
102447: LD_VAR 0 3
102451: PPUSH
102452: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
102456: LD_VAR 0 4
102460: PPUSH
102461: LD_VAR 0 5
102465: PPUSH
102466: CALL_OW 428
102470: PUSH
102471: LD_INT 0
102473: EQUAL
102474: IFFALSE 102498
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
102476: CALL_OW 44
102480: PPUSH
102481: LD_VAR 0 4
102485: PPUSH
102486: LD_VAR 0 5
102490: PPUSH
102491: LD_INT 1
102493: PPUSH
102494: CALL_OW 48
// end ;
102498: LD_VAR 0 6
102502: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
102503: LD_INT 0
102505: PPUSH
102506: PPUSH
// uc_side := your_side ;
102507: LD_ADDR_OWVAR 20
102511: PUSH
102512: LD_OWVAR 2
102516: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
102517: LD_VAR 0 1
102521: PUSH
102522: LD_INT 1
102524: PUSH
102525: LD_INT 2
102527: PUSH
102528: LD_INT 3
102530: PUSH
102531: LD_INT 4
102533: PUSH
102534: LD_INT 5
102536: PUSH
102537: EMPTY
102538: LIST
102539: LIST
102540: LIST
102541: LIST
102542: LIST
102543: IN
102544: IFFALSE 102556
// uc_nation := nation_american else
102546: LD_ADDR_OWVAR 21
102550: PUSH
102551: LD_INT 1
102553: ST_TO_ADDR
102554: GO 102599
// if chassis in [ 11 , 12 , 13 , 14 ] then
102556: LD_VAR 0 1
102560: PUSH
102561: LD_INT 11
102563: PUSH
102564: LD_INT 12
102566: PUSH
102567: LD_INT 13
102569: PUSH
102570: LD_INT 14
102572: PUSH
102573: EMPTY
102574: LIST
102575: LIST
102576: LIST
102577: LIST
102578: IN
102579: IFFALSE 102591
// uc_nation := nation_arabian else
102581: LD_ADDR_OWVAR 21
102585: PUSH
102586: LD_INT 2
102588: ST_TO_ADDR
102589: GO 102599
// uc_nation := nation_russian ;
102591: LD_ADDR_OWVAR 21
102595: PUSH
102596: LD_INT 3
102598: ST_TO_ADDR
// vc_chassis := chassis ;
102599: LD_ADDR_OWVAR 37
102603: PUSH
102604: LD_VAR 0 1
102608: ST_TO_ADDR
// vc_engine := engine ;
102609: LD_ADDR_OWVAR 39
102613: PUSH
102614: LD_VAR 0 2
102618: ST_TO_ADDR
// vc_control := control ;
102619: LD_ADDR_OWVAR 38
102623: PUSH
102624: LD_VAR 0 3
102628: ST_TO_ADDR
// vc_weapon := weapon ;
102629: LD_ADDR_OWVAR 40
102633: PUSH
102634: LD_VAR 0 4
102638: ST_TO_ADDR
// un := CreateVehicle ;
102639: LD_ADDR_VAR 0 8
102643: PUSH
102644: CALL_OW 45
102648: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
102649: LD_VAR 0 8
102653: PPUSH
102654: LD_INT 0
102656: PPUSH
102657: LD_INT 5
102659: PPUSH
102660: CALL_OW 12
102664: PPUSH
102665: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
102669: LD_VAR 0 8
102673: PPUSH
102674: LD_VAR 0 5
102678: PPUSH
102679: LD_VAR 0 6
102683: PPUSH
102684: LD_INT 1
102686: PPUSH
102687: CALL_OW 48
// end ;
102691: LD_VAR 0 7
102695: RET
// export hInvincible ; every 1 do
102696: GO 102698
102698: DISABLE
// hInvincible := [ ] ;
102699: LD_ADDR_EXP 170
102703: PUSH
102704: EMPTY
102705: ST_TO_ADDR
102706: END
// every 10 do var i ;
102707: GO 102709
102709: DISABLE
102710: LD_INT 0
102712: PPUSH
// begin enable ;
102713: ENABLE
// if not hInvincible then
102714: LD_EXP 170
102718: NOT
102719: IFFALSE 102723
// exit ;
102721: GO 102767
// for i in hInvincible do
102723: LD_ADDR_VAR 0 1
102727: PUSH
102728: LD_EXP 170
102732: PUSH
102733: FOR_IN
102734: IFFALSE 102765
// if GetLives ( i ) < 1000 then
102736: LD_VAR 0 1
102740: PPUSH
102741: CALL_OW 256
102745: PUSH
102746: LD_INT 1000
102748: LESS
102749: IFFALSE 102763
// SetLives ( i , 1000 ) ;
102751: LD_VAR 0 1
102755: PPUSH
102756: LD_INT 1000
102758: PPUSH
102759: CALL_OW 234
102763: GO 102733
102765: POP
102766: POP
// end ;
102767: PPOPN 1
102769: END
// export function hHackInvincible ; var i ; begin
102770: LD_INT 0
102772: PPUSH
102773: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
102774: LD_ADDR_VAR 0 2
102778: PUSH
102779: LD_INT 2
102781: PUSH
102782: LD_INT 21
102784: PUSH
102785: LD_INT 1
102787: PUSH
102788: EMPTY
102789: LIST
102790: LIST
102791: PUSH
102792: LD_INT 21
102794: PUSH
102795: LD_INT 2
102797: PUSH
102798: EMPTY
102799: LIST
102800: LIST
102801: PUSH
102802: EMPTY
102803: LIST
102804: LIST
102805: LIST
102806: PPUSH
102807: CALL_OW 69
102811: PUSH
102812: FOR_IN
102813: IFFALSE 102874
// if IsSelected ( i ) then
102815: LD_VAR 0 2
102819: PPUSH
102820: CALL_OW 306
102824: IFFALSE 102872
// begin if i in hInvincible then
102826: LD_VAR 0 2
102830: PUSH
102831: LD_EXP 170
102835: IN
102836: IFFALSE 102856
// hInvincible := hInvincible diff i else
102838: LD_ADDR_EXP 170
102842: PUSH
102843: LD_EXP 170
102847: PUSH
102848: LD_VAR 0 2
102852: DIFF
102853: ST_TO_ADDR
102854: GO 102872
// hInvincible := hInvincible union i ;
102856: LD_ADDR_EXP 170
102860: PUSH
102861: LD_EXP 170
102865: PUSH
102866: LD_VAR 0 2
102870: UNION
102871: ST_TO_ADDR
// end ;
102872: GO 102812
102874: POP
102875: POP
// end ;
102876: LD_VAR 0 1
102880: RET
// export function hHackInvisible ; var i , j ; begin
102881: LD_INT 0
102883: PPUSH
102884: PPUSH
102885: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102886: LD_ADDR_VAR 0 2
102890: PUSH
102891: LD_INT 21
102893: PUSH
102894: LD_INT 1
102896: PUSH
102897: EMPTY
102898: LIST
102899: LIST
102900: PPUSH
102901: CALL_OW 69
102905: PUSH
102906: FOR_IN
102907: IFFALSE 102931
// if IsSelected ( i ) then
102909: LD_VAR 0 2
102913: PPUSH
102914: CALL_OW 306
102918: IFFALSE 102929
// ComForceInvisible ( i ) ;
102920: LD_VAR 0 2
102924: PPUSH
102925: CALL_OW 496
102929: GO 102906
102931: POP
102932: POP
// end ;
102933: LD_VAR 0 1
102937: RET
// export function hHackChangeYourSide ; begin
102938: LD_INT 0
102940: PPUSH
// if your_side = 8 then
102941: LD_OWVAR 2
102945: PUSH
102946: LD_INT 8
102948: EQUAL
102949: IFFALSE 102961
// your_side := 0 else
102951: LD_ADDR_OWVAR 2
102955: PUSH
102956: LD_INT 0
102958: ST_TO_ADDR
102959: GO 102975
// your_side := your_side + 1 ;
102961: LD_ADDR_OWVAR 2
102965: PUSH
102966: LD_OWVAR 2
102970: PUSH
102971: LD_INT 1
102973: PLUS
102974: ST_TO_ADDR
// end ;
102975: LD_VAR 0 1
102979: RET
// export function hHackChangeUnitSide ; var i , j ; begin
102980: LD_INT 0
102982: PPUSH
102983: PPUSH
102984: PPUSH
// for i in all_units do
102985: LD_ADDR_VAR 0 2
102989: PUSH
102990: LD_OWVAR 3
102994: PUSH
102995: FOR_IN
102996: IFFALSE 103074
// if IsSelected ( i ) then
102998: LD_VAR 0 2
103002: PPUSH
103003: CALL_OW 306
103007: IFFALSE 103072
// begin j := GetSide ( i ) ;
103009: LD_ADDR_VAR 0 3
103013: PUSH
103014: LD_VAR 0 2
103018: PPUSH
103019: CALL_OW 255
103023: ST_TO_ADDR
// if j = 8 then
103024: LD_VAR 0 3
103028: PUSH
103029: LD_INT 8
103031: EQUAL
103032: IFFALSE 103044
// j := 0 else
103034: LD_ADDR_VAR 0 3
103038: PUSH
103039: LD_INT 0
103041: ST_TO_ADDR
103042: GO 103058
// j := j + 1 ;
103044: LD_ADDR_VAR 0 3
103048: PUSH
103049: LD_VAR 0 3
103053: PUSH
103054: LD_INT 1
103056: PLUS
103057: ST_TO_ADDR
// SetSide ( i , j ) ;
103058: LD_VAR 0 2
103062: PPUSH
103063: LD_VAR 0 3
103067: PPUSH
103068: CALL_OW 235
// end ;
103072: GO 102995
103074: POP
103075: POP
// end ;
103076: LD_VAR 0 1
103080: RET
// export function hHackFog ; begin
103081: LD_INT 0
103083: PPUSH
// FogOff ( true ) ;
103084: LD_INT 1
103086: PPUSH
103087: CALL_OW 344
// end ;
103091: LD_VAR 0 1
103095: RET
// export function hHackTeleport ( unit , x , y ) ; begin
103096: LD_INT 0
103098: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
103099: LD_VAR 0 1
103103: PPUSH
103104: LD_VAR 0 2
103108: PPUSH
103109: LD_VAR 0 3
103113: PPUSH
103114: LD_INT 1
103116: PPUSH
103117: LD_INT 1
103119: PPUSH
103120: CALL_OW 483
// CenterOnXY ( x , y ) ;
103124: LD_VAR 0 2
103128: PPUSH
103129: LD_VAR 0 3
103133: PPUSH
103134: CALL_OW 84
// end ; end_of_file
103138: LD_VAR 0 4
103142: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
103143: LD_INT 0
103145: PPUSH
103146: PPUSH
103147: PPUSH
103148: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
103149: LD_VAR 0 1
103153: PPUSH
103154: CALL_OW 264
103158: PUSH
103159: LD_EXP 98
103163: EQUAL
103164: IFFALSE 103236
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
103166: LD_INT 68
103168: PPUSH
103169: LD_VAR 0 1
103173: PPUSH
103174: CALL_OW 255
103178: PPUSH
103179: CALL_OW 321
103183: PUSH
103184: LD_INT 2
103186: EQUAL
103187: IFFALSE 103199
// eff := 70 else
103189: LD_ADDR_VAR 0 4
103193: PUSH
103194: LD_INT 70
103196: ST_TO_ADDR
103197: GO 103207
// eff := 30 ;
103199: LD_ADDR_VAR 0 4
103203: PUSH
103204: LD_INT 30
103206: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
103207: LD_VAR 0 1
103211: PPUSH
103212: CALL_OW 250
103216: PPUSH
103217: LD_VAR 0 1
103221: PPUSH
103222: CALL_OW 251
103226: PPUSH
103227: LD_VAR 0 4
103231: PPUSH
103232: CALL_OW 495
// end ; end ;
103236: LD_VAR 0 2
103240: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
103241: LD_INT 0
103243: PPUSH
// end ;
103244: LD_VAR 0 4
103248: RET
// export function SOS_Command ( cmd ) ; begin
103249: LD_INT 0
103251: PPUSH
// end ;
103252: LD_VAR 0 2
103256: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
103257: LD_INT 0
103259: PPUSH
// end ;
103260: LD_VAR 0 6
103264: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
103265: LD_INT 0
103267: PPUSH
103268: PPUSH
// if not vehicle or not factory then
103269: LD_VAR 0 1
103273: NOT
103274: PUSH
103275: LD_VAR 0 2
103279: NOT
103280: OR
103281: IFFALSE 103285
// exit ;
103283: GO 103516
// if factoryWaypoints >= factory then
103285: LD_EXP 171
103289: PUSH
103290: LD_VAR 0 2
103294: GREATEREQUAL
103295: IFFALSE 103516
// if factoryWaypoints [ factory ] then
103297: LD_EXP 171
103301: PUSH
103302: LD_VAR 0 2
103306: ARRAY
103307: IFFALSE 103516
// begin if GetControl ( vehicle ) = control_manual then
103309: LD_VAR 0 1
103313: PPUSH
103314: CALL_OW 263
103318: PUSH
103319: LD_INT 1
103321: EQUAL
103322: IFFALSE 103403
// begin driver := IsDrivenBy ( vehicle ) ;
103324: LD_ADDR_VAR 0 4
103328: PUSH
103329: LD_VAR 0 1
103333: PPUSH
103334: CALL_OW 311
103338: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
103339: LD_VAR 0 4
103343: PPUSH
103344: LD_EXP 171
103348: PUSH
103349: LD_VAR 0 2
103353: ARRAY
103354: PUSH
103355: LD_INT 1
103357: ARRAY
103358: PPUSH
103359: LD_EXP 171
103363: PUSH
103364: LD_VAR 0 2
103368: ARRAY
103369: PUSH
103370: LD_INT 2
103372: ARRAY
103373: PPUSH
103374: CALL_OW 171
// AddComExitVehicle ( driver ) ;
103378: LD_VAR 0 4
103382: PPUSH
103383: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
103387: LD_VAR 0 4
103391: PPUSH
103392: LD_VAR 0 2
103396: PPUSH
103397: CALL_OW 180
// end else
103401: GO 103516
// if GetControl ( vehicle ) = control_remote then
103403: LD_VAR 0 1
103407: PPUSH
103408: CALL_OW 263
103412: PUSH
103413: LD_INT 2
103415: EQUAL
103416: IFFALSE 103477
// begin wait ( 0 0$2 ) ;
103418: LD_INT 70
103420: PPUSH
103421: CALL_OW 67
// if Connect ( vehicle ) then
103425: LD_VAR 0 1
103429: PPUSH
103430: CALL 56512 0 1
103434: IFFALSE 103475
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
103436: LD_VAR 0 1
103440: PPUSH
103441: LD_EXP 171
103445: PUSH
103446: LD_VAR 0 2
103450: ARRAY
103451: PUSH
103452: LD_INT 1
103454: ARRAY
103455: PPUSH
103456: LD_EXP 171
103460: PUSH
103461: LD_VAR 0 2
103465: ARRAY
103466: PUSH
103467: LD_INT 2
103469: ARRAY
103470: PPUSH
103471: CALL_OW 171
// end else
103475: GO 103516
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
103477: LD_VAR 0 1
103481: PPUSH
103482: LD_EXP 171
103486: PUSH
103487: LD_VAR 0 2
103491: ARRAY
103492: PUSH
103493: LD_INT 1
103495: ARRAY
103496: PPUSH
103497: LD_EXP 171
103501: PUSH
103502: LD_VAR 0 2
103506: ARRAY
103507: PUSH
103508: LD_INT 2
103510: ARRAY
103511: PPUSH
103512: CALL_OW 171
// end ; end ;
103516: LD_VAR 0 3
103520: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
103521: LD_INT 0
103523: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
103524: LD_VAR 0 1
103528: PUSH
103529: LD_INT 250
103531: EQUAL
103532: PUSH
103533: LD_VAR 0 2
103537: PPUSH
103538: CALL_OW 264
103542: PUSH
103543: LD_EXP 101
103547: EQUAL
103548: AND
103549: IFFALSE 103570
// MinerPlaceMine ( unit , x , y ) ;
103551: LD_VAR 0 2
103555: PPUSH
103556: LD_VAR 0 4
103560: PPUSH
103561: LD_VAR 0 5
103565: PPUSH
103566: CALL 106298 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
103570: LD_VAR 0 1
103574: PUSH
103575: LD_INT 251
103577: EQUAL
103578: PUSH
103579: LD_VAR 0 2
103583: PPUSH
103584: CALL_OW 264
103588: PUSH
103589: LD_EXP 101
103593: EQUAL
103594: AND
103595: IFFALSE 103616
// MinerDetonateMine ( unit , x , y ) ;
103597: LD_VAR 0 2
103601: PPUSH
103602: LD_VAR 0 4
103606: PPUSH
103607: LD_VAR 0 5
103611: PPUSH
103612: CALL 106575 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
103616: LD_VAR 0 1
103620: PUSH
103621: LD_INT 252
103623: EQUAL
103624: PUSH
103625: LD_VAR 0 2
103629: PPUSH
103630: CALL_OW 264
103634: PUSH
103635: LD_EXP 101
103639: EQUAL
103640: AND
103641: IFFALSE 103662
// MinerCreateMinefield ( unit , x , y ) ;
103643: LD_VAR 0 2
103647: PPUSH
103648: LD_VAR 0 4
103652: PPUSH
103653: LD_VAR 0 5
103657: PPUSH
103658: CALL 106992 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
103662: LD_VAR 0 1
103666: PUSH
103667: LD_INT 253
103669: EQUAL
103670: PUSH
103671: LD_VAR 0 2
103675: PPUSH
103676: CALL_OW 257
103680: PUSH
103681: LD_INT 5
103683: EQUAL
103684: AND
103685: IFFALSE 103706
// ComBinocular ( unit , x , y ) ;
103687: LD_VAR 0 2
103691: PPUSH
103692: LD_VAR 0 4
103696: PPUSH
103697: LD_VAR 0 5
103701: PPUSH
103702: CALL 107363 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
103706: LD_VAR 0 1
103710: PUSH
103711: LD_INT 254
103713: EQUAL
103714: PUSH
103715: LD_VAR 0 2
103719: PPUSH
103720: CALL_OW 264
103724: PUSH
103725: LD_EXP 96
103729: EQUAL
103730: AND
103731: PUSH
103732: LD_VAR 0 3
103736: PPUSH
103737: CALL_OW 263
103741: PUSH
103742: LD_INT 3
103744: EQUAL
103745: AND
103746: IFFALSE 103762
// HackDestroyVehicle ( unit , selectedUnit ) ;
103748: LD_VAR 0 2
103752: PPUSH
103753: LD_VAR 0 3
103757: PPUSH
103758: CALL 105658 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
103762: LD_VAR 0 1
103766: PUSH
103767: LD_INT 255
103769: EQUAL
103770: PUSH
103771: LD_VAR 0 2
103775: PPUSH
103776: CALL_OW 264
103780: PUSH
103781: LD_INT 14
103783: PUSH
103784: LD_INT 53
103786: PUSH
103787: EMPTY
103788: LIST
103789: LIST
103790: IN
103791: AND
103792: PUSH
103793: LD_VAR 0 4
103797: PPUSH
103798: LD_VAR 0 5
103802: PPUSH
103803: CALL_OW 488
103807: AND
103808: IFFALSE 103832
// CutTreeXYR ( unit , x , y , 12 ) ;
103810: LD_VAR 0 2
103814: PPUSH
103815: LD_VAR 0 4
103819: PPUSH
103820: LD_VAR 0 5
103824: PPUSH
103825: LD_INT 12
103827: PPUSH
103828: CALL 104224 0 4
// if cmd = 256 then
103832: LD_VAR 0 1
103836: PUSH
103837: LD_INT 256
103839: EQUAL
103840: IFFALSE 103861
// SetFactoryWaypoint ( unit , x , y ) ;
103842: LD_VAR 0 2
103846: PPUSH
103847: LD_VAR 0 4
103851: PPUSH
103852: LD_VAR 0 5
103856: PPUSH
103857: CALL 103866 0 3
// end ;
103861: LD_VAR 0 6
103865: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
103866: LD_INT 0
103868: PPUSH
103869: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
103870: LD_VAR 0 1
103874: NOT
103875: PUSH
103876: LD_VAR 0 2
103880: PPUSH
103881: LD_VAR 0 3
103885: PPUSH
103886: CALL_OW 488
103890: NOT
103891: OR
103892: PUSH
103893: LD_VAR 0 1
103897: PPUSH
103898: CALL_OW 266
103902: PUSH
103903: LD_INT 3
103905: NONEQUAL
103906: PUSH
103907: LD_VAR 0 1
103911: PPUSH
103912: CALL_OW 247
103916: PUSH
103917: LD_INT 1
103919: EQUAL
103920: NOT
103921: AND
103922: OR
103923: IFFALSE 103927
// exit ;
103925: GO 104076
// if GetType ( factory ) = unit_human then
103927: LD_VAR 0 1
103931: PPUSH
103932: CALL_OW 247
103936: PUSH
103937: LD_INT 1
103939: EQUAL
103940: IFFALSE 103957
// factory := IsInUnit ( factory ) ;
103942: LD_ADDR_VAR 0 1
103946: PUSH
103947: LD_VAR 0 1
103951: PPUSH
103952: CALL_OW 310
103956: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
103957: LD_VAR 0 1
103961: PPUSH
103962: CALL_OW 266
103966: PUSH
103967: LD_INT 3
103969: NONEQUAL
103970: IFFALSE 103974
// exit ;
103972: GO 104076
// if HexInfo ( x , y ) = factory then
103974: LD_VAR 0 2
103978: PPUSH
103979: LD_VAR 0 3
103983: PPUSH
103984: CALL_OW 428
103988: PUSH
103989: LD_VAR 0 1
103993: EQUAL
103994: IFFALSE 104021
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
103996: LD_ADDR_EXP 171
104000: PUSH
104001: LD_EXP 171
104005: PPUSH
104006: LD_VAR 0 1
104010: PPUSH
104011: LD_INT 0
104013: PPUSH
104014: CALL_OW 1
104018: ST_TO_ADDR
104019: GO 104072
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104021: LD_ADDR_EXP 171
104025: PUSH
104026: LD_EXP 171
104030: PPUSH
104031: LD_VAR 0 1
104035: PPUSH
104036: LD_VAR 0 1
104040: PPUSH
104041: CALL_OW 255
104045: PUSH
104046: LD_VAR 0 1
104050: PUSH
104051: LD_VAR 0 2
104055: PUSH
104056: LD_VAR 0 3
104060: PUSH
104061: EMPTY
104062: LIST
104063: LIST
104064: LIST
104065: LIST
104066: PPUSH
104067: CALL_OW 1
104071: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104072: CALL 104081 0 0
// end ;
104076: LD_VAR 0 4
104080: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
104081: LD_INT 0
104083: PPUSH
104084: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104085: LD_STRING resetFactoryWaypoint();
104087: PPUSH
104088: CALL_OW 559
// if factoryWaypoints then
104092: LD_EXP 171
104096: IFFALSE 104219
// begin for i := 1 to factoryWaypoints do
104098: LD_ADDR_VAR 0 2
104102: PUSH
104103: DOUBLE
104104: LD_INT 1
104106: DEC
104107: ST_TO_ADDR
104108: LD_EXP 171
104112: PUSH
104113: FOR_TO
104114: IFFALSE 104217
// if factoryWaypoints [ i ] then
104116: LD_EXP 171
104120: PUSH
104121: LD_VAR 0 2
104125: ARRAY
104126: IFFALSE 104215
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
104128: LD_STRING setFactoryWaypointXY(
104130: PUSH
104131: LD_EXP 171
104135: PUSH
104136: LD_VAR 0 2
104140: ARRAY
104141: PUSH
104142: LD_INT 1
104144: ARRAY
104145: STR
104146: PUSH
104147: LD_STRING ,
104149: STR
104150: PUSH
104151: LD_EXP 171
104155: PUSH
104156: LD_VAR 0 2
104160: ARRAY
104161: PUSH
104162: LD_INT 2
104164: ARRAY
104165: STR
104166: PUSH
104167: LD_STRING ,
104169: STR
104170: PUSH
104171: LD_EXP 171
104175: PUSH
104176: LD_VAR 0 2
104180: ARRAY
104181: PUSH
104182: LD_INT 3
104184: ARRAY
104185: STR
104186: PUSH
104187: LD_STRING ,
104189: STR
104190: PUSH
104191: LD_EXP 171
104195: PUSH
104196: LD_VAR 0 2
104200: ARRAY
104201: PUSH
104202: LD_INT 4
104204: ARRAY
104205: STR
104206: PUSH
104207: LD_STRING )
104209: STR
104210: PPUSH
104211: CALL_OW 559
104215: GO 104113
104217: POP
104218: POP
// end ; end ;
104219: LD_VAR 0 1
104223: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
104224: LD_INT 0
104226: PPUSH
104227: PPUSH
104228: PPUSH
104229: PPUSH
104230: PPUSH
104231: PPUSH
104232: PPUSH
104233: PPUSH
104234: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
104235: LD_VAR 0 1
104239: NOT
104240: PUSH
104241: LD_VAR 0 2
104245: PPUSH
104246: LD_VAR 0 3
104250: PPUSH
104251: CALL_OW 488
104255: NOT
104256: OR
104257: PUSH
104258: LD_VAR 0 4
104262: NOT
104263: OR
104264: IFFALSE 104268
// exit ;
104266: GO 104608
// list := [ ] ;
104268: LD_ADDR_VAR 0 13
104272: PUSH
104273: EMPTY
104274: ST_TO_ADDR
// if x - r < 0 then
104275: LD_VAR 0 2
104279: PUSH
104280: LD_VAR 0 4
104284: MINUS
104285: PUSH
104286: LD_INT 0
104288: LESS
104289: IFFALSE 104301
// min_x := 0 else
104291: LD_ADDR_VAR 0 7
104295: PUSH
104296: LD_INT 0
104298: ST_TO_ADDR
104299: GO 104317
// min_x := x - r ;
104301: LD_ADDR_VAR 0 7
104305: PUSH
104306: LD_VAR 0 2
104310: PUSH
104311: LD_VAR 0 4
104315: MINUS
104316: ST_TO_ADDR
// if y - r < 0 then
104317: LD_VAR 0 3
104321: PUSH
104322: LD_VAR 0 4
104326: MINUS
104327: PUSH
104328: LD_INT 0
104330: LESS
104331: IFFALSE 104343
// min_y := 0 else
104333: LD_ADDR_VAR 0 8
104337: PUSH
104338: LD_INT 0
104340: ST_TO_ADDR
104341: GO 104359
// min_y := y - r ;
104343: LD_ADDR_VAR 0 8
104347: PUSH
104348: LD_VAR 0 3
104352: PUSH
104353: LD_VAR 0 4
104357: MINUS
104358: ST_TO_ADDR
// max_x := x + r ;
104359: LD_ADDR_VAR 0 9
104363: PUSH
104364: LD_VAR 0 2
104368: PUSH
104369: LD_VAR 0 4
104373: PLUS
104374: ST_TO_ADDR
// max_y := y + r ;
104375: LD_ADDR_VAR 0 10
104379: PUSH
104380: LD_VAR 0 3
104384: PUSH
104385: LD_VAR 0 4
104389: PLUS
104390: ST_TO_ADDR
// for _x = min_x to max_x do
104391: LD_ADDR_VAR 0 11
104395: PUSH
104396: DOUBLE
104397: LD_VAR 0 7
104401: DEC
104402: ST_TO_ADDR
104403: LD_VAR 0 9
104407: PUSH
104408: FOR_TO
104409: IFFALSE 104526
// for _y = min_y to max_y do
104411: LD_ADDR_VAR 0 12
104415: PUSH
104416: DOUBLE
104417: LD_VAR 0 8
104421: DEC
104422: ST_TO_ADDR
104423: LD_VAR 0 10
104427: PUSH
104428: FOR_TO
104429: IFFALSE 104522
// begin if not ValidHex ( _x , _y ) then
104431: LD_VAR 0 11
104435: PPUSH
104436: LD_VAR 0 12
104440: PPUSH
104441: CALL_OW 488
104445: NOT
104446: IFFALSE 104450
// continue ;
104448: GO 104428
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
104450: LD_VAR 0 11
104454: PPUSH
104455: LD_VAR 0 12
104459: PPUSH
104460: CALL_OW 351
104464: PUSH
104465: LD_VAR 0 11
104469: PPUSH
104470: LD_VAR 0 12
104474: PPUSH
104475: CALL_OW 554
104479: AND
104480: IFFALSE 104520
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
104482: LD_ADDR_VAR 0 13
104486: PUSH
104487: LD_VAR 0 13
104491: PPUSH
104492: LD_VAR 0 13
104496: PUSH
104497: LD_INT 1
104499: PLUS
104500: PPUSH
104501: LD_VAR 0 11
104505: PUSH
104506: LD_VAR 0 12
104510: PUSH
104511: EMPTY
104512: LIST
104513: LIST
104514: PPUSH
104515: CALL_OW 2
104519: ST_TO_ADDR
// end ;
104520: GO 104428
104522: POP
104523: POP
104524: GO 104408
104526: POP
104527: POP
// if not list then
104528: LD_VAR 0 13
104532: NOT
104533: IFFALSE 104537
// exit ;
104535: GO 104608
// for i in list do
104537: LD_ADDR_VAR 0 6
104541: PUSH
104542: LD_VAR 0 13
104546: PUSH
104547: FOR_IN
104548: IFFALSE 104606
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
104550: LD_VAR 0 1
104554: PPUSH
104555: LD_STRING M
104557: PUSH
104558: LD_VAR 0 6
104562: PUSH
104563: LD_INT 1
104565: ARRAY
104566: PUSH
104567: LD_VAR 0 6
104571: PUSH
104572: LD_INT 2
104574: ARRAY
104575: PUSH
104576: LD_INT 0
104578: PUSH
104579: LD_INT 0
104581: PUSH
104582: LD_INT 0
104584: PUSH
104585: LD_INT 0
104587: PUSH
104588: EMPTY
104589: LIST
104590: LIST
104591: LIST
104592: LIST
104593: LIST
104594: LIST
104595: LIST
104596: PUSH
104597: EMPTY
104598: LIST
104599: PPUSH
104600: CALL_OW 447
104604: GO 104547
104606: POP
104607: POP
// end ;
104608: LD_VAR 0 5
104612: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
104613: LD_EXP 172
104617: NOT
104618: IFFALSE 104668
104620: GO 104622
104622: DISABLE
// begin initHack := true ;
104623: LD_ADDR_EXP 172
104627: PUSH
104628: LD_INT 1
104630: ST_TO_ADDR
// hackTanks := [ ] ;
104631: LD_ADDR_EXP 173
104635: PUSH
104636: EMPTY
104637: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
104638: LD_ADDR_EXP 174
104642: PUSH
104643: EMPTY
104644: ST_TO_ADDR
// hackLimit := 3 ;
104645: LD_ADDR_EXP 175
104649: PUSH
104650: LD_INT 3
104652: ST_TO_ADDR
// hackDist := 12 ;
104653: LD_ADDR_EXP 176
104657: PUSH
104658: LD_INT 12
104660: ST_TO_ADDR
// hackCounter := [ ] ;
104661: LD_ADDR_EXP 177
104665: PUSH
104666: EMPTY
104667: ST_TO_ADDR
// end ;
104668: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
104669: LD_EXP 172
104673: PUSH
104674: LD_INT 34
104676: PUSH
104677: LD_EXP 96
104681: PUSH
104682: EMPTY
104683: LIST
104684: LIST
104685: PPUSH
104686: CALL_OW 69
104690: AND
104691: IFFALSE 104946
104693: GO 104695
104695: DISABLE
104696: LD_INT 0
104698: PPUSH
104699: PPUSH
// begin enable ;
104700: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
104701: LD_ADDR_VAR 0 1
104705: PUSH
104706: LD_INT 34
104708: PUSH
104709: LD_EXP 96
104713: PUSH
104714: EMPTY
104715: LIST
104716: LIST
104717: PPUSH
104718: CALL_OW 69
104722: PUSH
104723: FOR_IN
104724: IFFALSE 104944
// begin if not i in hackTanks then
104726: LD_VAR 0 1
104730: PUSH
104731: LD_EXP 173
104735: IN
104736: NOT
104737: IFFALSE 104820
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
104739: LD_ADDR_EXP 173
104743: PUSH
104744: LD_EXP 173
104748: PPUSH
104749: LD_EXP 173
104753: PUSH
104754: LD_INT 1
104756: PLUS
104757: PPUSH
104758: LD_VAR 0 1
104762: PPUSH
104763: CALL_OW 1
104767: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
104768: LD_ADDR_EXP 174
104772: PUSH
104773: LD_EXP 174
104777: PPUSH
104778: LD_EXP 174
104782: PUSH
104783: LD_INT 1
104785: PLUS
104786: PPUSH
104787: EMPTY
104788: PPUSH
104789: CALL_OW 1
104793: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
104794: LD_ADDR_EXP 177
104798: PUSH
104799: LD_EXP 177
104803: PPUSH
104804: LD_EXP 177
104808: PUSH
104809: LD_INT 1
104811: PLUS
104812: PPUSH
104813: EMPTY
104814: PPUSH
104815: CALL_OW 1
104819: ST_TO_ADDR
// end ; if not IsOk ( i ) then
104820: LD_VAR 0 1
104824: PPUSH
104825: CALL_OW 302
104829: NOT
104830: IFFALSE 104843
// begin HackUnlinkAll ( i ) ;
104832: LD_VAR 0 1
104836: PPUSH
104837: CALL 104949 0 1
// continue ;
104841: GO 104723
// end ; HackCheckCapturedStatus ( i ) ;
104843: LD_VAR 0 1
104847: PPUSH
104848: CALL 105392 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
104852: LD_ADDR_VAR 0 2
104856: PUSH
104857: LD_INT 81
104859: PUSH
104860: LD_VAR 0 1
104864: PPUSH
104865: CALL_OW 255
104869: PUSH
104870: EMPTY
104871: LIST
104872: LIST
104873: PUSH
104874: LD_INT 33
104876: PUSH
104877: LD_INT 3
104879: PUSH
104880: EMPTY
104881: LIST
104882: LIST
104883: PUSH
104884: LD_INT 91
104886: PUSH
104887: LD_VAR 0 1
104891: PUSH
104892: LD_EXP 176
104896: PUSH
104897: EMPTY
104898: LIST
104899: LIST
104900: LIST
104901: PUSH
104902: LD_INT 50
104904: PUSH
104905: EMPTY
104906: LIST
104907: PUSH
104908: EMPTY
104909: LIST
104910: LIST
104911: LIST
104912: LIST
104913: PPUSH
104914: CALL_OW 69
104918: ST_TO_ADDR
// if not tmp then
104919: LD_VAR 0 2
104923: NOT
104924: IFFALSE 104928
// continue ;
104926: GO 104723
// HackLink ( i , tmp ) ;
104928: LD_VAR 0 1
104932: PPUSH
104933: LD_VAR 0 2
104937: PPUSH
104938: CALL 105085 0 2
// end ;
104942: GO 104723
104944: POP
104945: POP
// end ;
104946: PPOPN 2
104948: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
104949: LD_INT 0
104951: PPUSH
104952: PPUSH
104953: PPUSH
// if not hack in hackTanks then
104954: LD_VAR 0 1
104958: PUSH
104959: LD_EXP 173
104963: IN
104964: NOT
104965: IFFALSE 104969
// exit ;
104967: GO 105080
// index := GetElementIndex ( hackTanks , hack ) ;
104969: LD_ADDR_VAR 0 4
104973: PUSH
104974: LD_EXP 173
104978: PPUSH
104979: LD_VAR 0 1
104983: PPUSH
104984: CALL 53326 0 2
104988: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
104989: LD_EXP 174
104993: PUSH
104994: LD_VAR 0 4
104998: ARRAY
104999: IFFALSE 105080
// begin for i in hackTanksCaptured [ index ] do
105001: LD_ADDR_VAR 0 3
105005: PUSH
105006: LD_EXP 174
105010: PUSH
105011: LD_VAR 0 4
105015: ARRAY
105016: PUSH
105017: FOR_IN
105018: IFFALSE 105044
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
105020: LD_VAR 0 3
105024: PUSH
105025: LD_INT 1
105027: ARRAY
105028: PPUSH
105029: LD_VAR 0 3
105033: PUSH
105034: LD_INT 2
105036: ARRAY
105037: PPUSH
105038: CALL_OW 235
105042: GO 105017
105044: POP
105045: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
105046: LD_ADDR_EXP 174
105050: PUSH
105051: LD_EXP 174
105055: PPUSH
105056: LD_VAR 0 4
105060: PPUSH
105061: EMPTY
105062: PPUSH
105063: CALL_OW 1
105067: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
105068: LD_VAR 0 1
105072: PPUSH
105073: LD_INT 0
105075: PPUSH
105076: CALL_OW 505
// end ; end ;
105080: LD_VAR 0 2
105084: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
105085: LD_INT 0
105087: PPUSH
105088: PPUSH
105089: PPUSH
// if not hack in hackTanks or not vehicles then
105090: LD_VAR 0 1
105094: PUSH
105095: LD_EXP 173
105099: IN
105100: NOT
105101: PUSH
105102: LD_VAR 0 2
105106: NOT
105107: OR
105108: IFFALSE 105112
// exit ;
105110: GO 105387
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
105112: LD_ADDR_VAR 0 2
105116: PUSH
105117: LD_VAR 0 1
105121: PPUSH
105122: LD_VAR 0 2
105126: PPUSH
105127: LD_INT 1
105129: PPUSH
105130: LD_INT 1
105132: PPUSH
105133: CALL 53976 0 4
105137: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
105138: LD_ADDR_VAR 0 5
105142: PUSH
105143: LD_EXP 173
105147: PPUSH
105148: LD_VAR 0 1
105152: PPUSH
105153: CALL 53326 0 2
105157: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
105158: LD_EXP 174
105162: PUSH
105163: LD_VAR 0 5
105167: ARRAY
105168: PUSH
105169: LD_EXP 175
105173: LESS
105174: IFFALSE 105363
// begin for i := 1 to vehicles do
105176: LD_ADDR_VAR 0 4
105180: PUSH
105181: DOUBLE
105182: LD_INT 1
105184: DEC
105185: ST_TO_ADDR
105186: LD_VAR 0 2
105190: PUSH
105191: FOR_TO
105192: IFFALSE 105361
// begin if hackTanksCaptured [ index ] = hackLimit then
105194: LD_EXP 174
105198: PUSH
105199: LD_VAR 0 5
105203: ARRAY
105204: PUSH
105205: LD_EXP 175
105209: EQUAL
105210: IFFALSE 105214
// break ;
105212: GO 105361
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
105214: LD_ADDR_EXP 177
105218: PUSH
105219: LD_EXP 177
105223: PPUSH
105224: LD_VAR 0 5
105228: PPUSH
105229: LD_EXP 177
105233: PUSH
105234: LD_VAR 0 5
105238: ARRAY
105239: PUSH
105240: LD_INT 1
105242: PLUS
105243: PPUSH
105244: CALL_OW 1
105248: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
105249: LD_ADDR_EXP 174
105253: PUSH
105254: LD_EXP 174
105258: PPUSH
105259: LD_VAR 0 5
105263: PUSH
105264: LD_EXP 174
105268: PUSH
105269: LD_VAR 0 5
105273: ARRAY
105274: PUSH
105275: LD_INT 1
105277: PLUS
105278: PUSH
105279: EMPTY
105280: LIST
105281: LIST
105282: PPUSH
105283: LD_VAR 0 2
105287: PUSH
105288: LD_VAR 0 4
105292: ARRAY
105293: PUSH
105294: LD_VAR 0 2
105298: PUSH
105299: LD_VAR 0 4
105303: ARRAY
105304: PPUSH
105305: CALL_OW 255
105309: PUSH
105310: EMPTY
105311: LIST
105312: LIST
105313: PPUSH
105314: CALL 53541 0 3
105318: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
105319: LD_VAR 0 2
105323: PUSH
105324: LD_VAR 0 4
105328: ARRAY
105329: PPUSH
105330: LD_VAR 0 1
105334: PPUSH
105335: CALL_OW 255
105339: PPUSH
105340: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
105344: LD_VAR 0 2
105348: PUSH
105349: LD_VAR 0 4
105353: ARRAY
105354: PPUSH
105355: CALL_OW 141
// end ;
105359: GO 105191
105361: POP
105362: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105363: LD_VAR 0 1
105367: PPUSH
105368: LD_EXP 174
105372: PUSH
105373: LD_VAR 0 5
105377: ARRAY
105378: PUSH
105379: LD_INT 0
105381: PLUS
105382: PPUSH
105383: CALL_OW 505
// end ;
105387: LD_VAR 0 3
105391: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
105392: LD_INT 0
105394: PPUSH
105395: PPUSH
105396: PPUSH
105397: PPUSH
// if not hack in hackTanks then
105398: LD_VAR 0 1
105402: PUSH
105403: LD_EXP 173
105407: IN
105408: NOT
105409: IFFALSE 105413
// exit ;
105411: GO 105653
// index := GetElementIndex ( hackTanks , hack ) ;
105413: LD_ADDR_VAR 0 4
105417: PUSH
105418: LD_EXP 173
105422: PPUSH
105423: LD_VAR 0 1
105427: PPUSH
105428: CALL 53326 0 2
105432: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
105433: LD_ADDR_VAR 0 3
105437: PUSH
105438: DOUBLE
105439: LD_EXP 174
105443: PUSH
105444: LD_VAR 0 4
105448: ARRAY
105449: INC
105450: ST_TO_ADDR
105451: LD_INT 1
105453: PUSH
105454: FOR_DOWNTO
105455: IFFALSE 105627
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
105457: LD_ADDR_VAR 0 5
105461: PUSH
105462: LD_EXP 174
105466: PUSH
105467: LD_VAR 0 4
105471: ARRAY
105472: PUSH
105473: LD_VAR 0 3
105477: ARRAY
105478: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
105479: LD_VAR 0 5
105483: PUSH
105484: LD_INT 1
105486: ARRAY
105487: PPUSH
105488: CALL_OW 302
105492: NOT
105493: PUSH
105494: LD_VAR 0 5
105498: PUSH
105499: LD_INT 1
105501: ARRAY
105502: PPUSH
105503: CALL_OW 255
105507: PUSH
105508: LD_VAR 0 1
105512: PPUSH
105513: CALL_OW 255
105517: NONEQUAL
105518: OR
105519: IFFALSE 105625
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
105521: LD_VAR 0 5
105525: PUSH
105526: LD_INT 1
105528: ARRAY
105529: PPUSH
105530: CALL_OW 305
105534: PUSH
105535: LD_VAR 0 5
105539: PUSH
105540: LD_INT 1
105542: ARRAY
105543: PPUSH
105544: CALL_OW 255
105548: PUSH
105549: LD_VAR 0 1
105553: PPUSH
105554: CALL_OW 255
105558: EQUAL
105559: AND
105560: IFFALSE 105584
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
105562: LD_VAR 0 5
105566: PUSH
105567: LD_INT 1
105569: ARRAY
105570: PPUSH
105571: LD_VAR 0 5
105575: PUSH
105576: LD_INT 2
105578: ARRAY
105579: PPUSH
105580: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
105584: LD_ADDR_EXP 174
105588: PUSH
105589: LD_EXP 174
105593: PPUSH
105594: LD_VAR 0 4
105598: PPUSH
105599: LD_EXP 174
105603: PUSH
105604: LD_VAR 0 4
105608: ARRAY
105609: PPUSH
105610: LD_VAR 0 3
105614: PPUSH
105615: CALL_OW 3
105619: PPUSH
105620: CALL_OW 1
105624: ST_TO_ADDR
// end ; end ;
105625: GO 105454
105627: POP
105628: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105629: LD_VAR 0 1
105633: PPUSH
105634: LD_EXP 174
105638: PUSH
105639: LD_VAR 0 4
105643: ARRAY
105644: PUSH
105645: LD_INT 0
105647: PLUS
105648: PPUSH
105649: CALL_OW 505
// end ;
105653: LD_VAR 0 2
105657: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
105658: LD_INT 0
105660: PPUSH
105661: PPUSH
105662: PPUSH
105663: PPUSH
// if not hack in hackTanks then
105664: LD_VAR 0 1
105668: PUSH
105669: LD_EXP 173
105673: IN
105674: NOT
105675: IFFALSE 105679
// exit ;
105677: GO 105764
// index := GetElementIndex ( hackTanks , hack ) ;
105679: LD_ADDR_VAR 0 5
105683: PUSH
105684: LD_EXP 173
105688: PPUSH
105689: LD_VAR 0 1
105693: PPUSH
105694: CALL 53326 0 2
105698: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
105699: LD_ADDR_VAR 0 4
105703: PUSH
105704: DOUBLE
105705: LD_INT 1
105707: DEC
105708: ST_TO_ADDR
105709: LD_EXP 174
105713: PUSH
105714: LD_VAR 0 5
105718: ARRAY
105719: PUSH
105720: FOR_TO
105721: IFFALSE 105762
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
105723: LD_EXP 174
105727: PUSH
105728: LD_VAR 0 5
105732: ARRAY
105733: PUSH
105734: LD_VAR 0 4
105738: ARRAY
105739: PUSH
105740: LD_INT 1
105742: ARRAY
105743: PUSH
105744: LD_VAR 0 2
105748: EQUAL
105749: IFFALSE 105760
// KillUnit ( vehicle ) ;
105751: LD_VAR 0 2
105755: PPUSH
105756: CALL_OW 66
105760: GO 105720
105762: POP
105763: POP
// end ;
105764: LD_VAR 0 3
105768: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
105769: LD_EXP 178
105773: NOT
105774: IFFALSE 105809
105776: GO 105778
105778: DISABLE
// begin initMiner := true ;
105779: LD_ADDR_EXP 178
105783: PUSH
105784: LD_INT 1
105786: ST_TO_ADDR
// minersList := [ ] ;
105787: LD_ADDR_EXP 179
105791: PUSH
105792: EMPTY
105793: ST_TO_ADDR
// minerMinesList := [ ] ;
105794: LD_ADDR_EXP 180
105798: PUSH
105799: EMPTY
105800: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
105801: LD_ADDR_EXP 181
105805: PUSH
105806: LD_INT 5
105808: ST_TO_ADDR
// end ;
105809: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
105810: LD_EXP 178
105814: PUSH
105815: LD_INT 34
105817: PUSH
105818: LD_EXP 101
105822: PUSH
105823: EMPTY
105824: LIST
105825: LIST
105826: PPUSH
105827: CALL_OW 69
105831: AND
105832: IFFALSE 106295
105834: GO 105836
105836: DISABLE
105837: LD_INT 0
105839: PPUSH
105840: PPUSH
105841: PPUSH
105842: PPUSH
// begin enable ;
105843: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
105844: LD_ADDR_VAR 0 1
105848: PUSH
105849: LD_INT 34
105851: PUSH
105852: LD_EXP 101
105856: PUSH
105857: EMPTY
105858: LIST
105859: LIST
105860: PPUSH
105861: CALL_OW 69
105865: PUSH
105866: FOR_IN
105867: IFFALSE 105939
// begin if not i in minersList then
105869: LD_VAR 0 1
105873: PUSH
105874: LD_EXP 179
105878: IN
105879: NOT
105880: IFFALSE 105937
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
105882: LD_ADDR_EXP 179
105886: PUSH
105887: LD_EXP 179
105891: PPUSH
105892: LD_EXP 179
105896: PUSH
105897: LD_INT 1
105899: PLUS
105900: PPUSH
105901: LD_VAR 0 1
105905: PPUSH
105906: CALL_OW 1
105910: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
105911: LD_ADDR_EXP 180
105915: PUSH
105916: LD_EXP 180
105920: PPUSH
105921: LD_EXP 180
105925: PUSH
105926: LD_INT 1
105928: PLUS
105929: PPUSH
105930: EMPTY
105931: PPUSH
105932: CALL_OW 1
105936: ST_TO_ADDR
// end end ;
105937: GO 105866
105939: POP
105940: POP
// for i := minerMinesList downto 1 do
105941: LD_ADDR_VAR 0 1
105945: PUSH
105946: DOUBLE
105947: LD_EXP 180
105951: INC
105952: ST_TO_ADDR
105953: LD_INT 1
105955: PUSH
105956: FOR_DOWNTO
105957: IFFALSE 106293
// begin if IsLive ( minersList [ i ] ) then
105959: LD_EXP 179
105963: PUSH
105964: LD_VAR 0 1
105968: ARRAY
105969: PPUSH
105970: CALL_OW 300
105974: IFFALSE 106002
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
105976: LD_EXP 179
105980: PUSH
105981: LD_VAR 0 1
105985: ARRAY
105986: PPUSH
105987: LD_EXP 180
105991: PUSH
105992: LD_VAR 0 1
105996: ARRAY
105997: PPUSH
105998: CALL_OW 505
// if not minerMinesList [ i ] then
106002: LD_EXP 180
106006: PUSH
106007: LD_VAR 0 1
106011: ARRAY
106012: NOT
106013: IFFALSE 106017
// continue ;
106015: GO 105956
// for j := minerMinesList [ i ] downto 1 do
106017: LD_ADDR_VAR 0 2
106021: PUSH
106022: DOUBLE
106023: LD_EXP 180
106027: PUSH
106028: LD_VAR 0 1
106032: ARRAY
106033: INC
106034: ST_TO_ADDR
106035: LD_INT 1
106037: PUSH
106038: FOR_DOWNTO
106039: IFFALSE 106289
// begin side := GetSide ( minersList [ i ] ) ;
106041: LD_ADDR_VAR 0 3
106045: PUSH
106046: LD_EXP 179
106050: PUSH
106051: LD_VAR 0 1
106055: ARRAY
106056: PPUSH
106057: CALL_OW 255
106061: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
106062: LD_ADDR_VAR 0 4
106066: PUSH
106067: LD_EXP 180
106071: PUSH
106072: LD_VAR 0 1
106076: ARRAY
106077: PUSH
106078: LD_VAR 0 2
106082: ARRAY
106083: PUSH
106084: LD_INT 1
106086: ARRAY
106087: PPUSH
106088: LD_EXP 180
106092: PUSH
106093: LD_VAR 0 1
106097: ARRAY
106098: PUSH
106099: LD_VAR 0 2
106103: ARRAY
106104: PUSH
106105: LD_INT 2
106107: ARRAY
106108: PPUSH
106109: CALL_OW 428
106113: ST_TO_ADDR
// if not tmp then
106114: LD_VAR 0 4
106118: NOT
106119: IFFALSE 106123
// continue ;
106121: GO 106038
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
106123: LD_VAR 0 4
106127: PUSH
106128: LD_INT 81
106130: PUSH
106131: LD_VAR 0 3
106135: PUSH
106136: EMPTY
106137: LIST
106138: LIST
106139: PPUSH
106140: CALL_OW 69
106144: IN
106145: PUSH
106146: LD_EXP 180
106150: PUSH
106151: LD_VAR 0 1
106155: ARRAY
106156: PUSH
106157: LD_VAR 0 2
106161: ARRAY
106162: PUSH
106163: LD_INT 1
106165: ARRAY
106166: PPUSH
106167: LD_EXP 180
106171: PUSH
106172: LD_VAR 0 1
106176: ARRAY
106177: PUSH
106178: LD_VAR 0 2
106182: ARRAY
106183: PUSH
106184: LD_INT 2
106186: ARRAY
106187: PPUSH
106188: CALL_OW 458
106192: AND
106193: IFFALSE 106287
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
106195: LD_EXP 180
106199: PUSH
106200: LD_VAR 0 1
106204: ARRAY
106205: PUSH
106206: LD_VAR 0 2
106210: ARRAY
106211: PUSH
106212: LD_INT 1
106214: ARRAY
106215: PPUSH
106216: LD_EXP 180
106220: PUSH
106221: LD_VAR 0 1
106225: ARRAY
106226: PUSH
106227: LD_VAR 0 2
106231: ARRAY
106232: PUSH
106233: LD_INT 2
106235: ARRAY
106236: PPUSH
106237: LD_VAR 0 3
106241: PPUSH
106242: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
106246: LD_ADDR_EXP 180
106250: PUSH
106251: LD_EXP 180
106255: PPUSH
106256: LD_VAR 0 1
106260: PPUSH
106261: LD_EXP 180
106265: PUSH
106266: LD_VAR 0 1
106270: ARRAY
106271: PPUSH
106272: LD_VAR 0 2
106276: PPUSH
106277: CALL_OW 3
106281: PPUSH
106282: CALL_OW 1
106286: ST_TO_ADDR
// end ; end ;
106287: GO 106038
106289: POP
106290: POP
// end ;
106291: GO 105956
106293: POP
106294: POP
// end ;
106295: PPOPN 4
106297: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
106298: LD_INT 0
106300: PPUSH
106301: PPUSH
// result := false ;
106302: LD_ADDR_VAR 0 4
106306: PUSH
106307: LD_INT 0
106309: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
106310: LD_VAR 0 1
106314: PPUSH
106315: CALL_OW 264
106319: PUSH
106320: LD_EXP 101
106324: EQUAL
106325: NOT
106326: IFFALSE 106330
// exit ;
106328: GO 106570
// index := GetElementIndex ( minersList , unit ) ;
106330: LD_ADDR_VAR 0 5
106334: PUSH
106335: LD_EXP 179
106339: PPUSH
106340: LD_VAR 0 1
106344: PPUSH
106345: CALL 53326 0 2
106349: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
106350: LD_EXP 180
106354: PUSH
106355: LD_VAR 0 5
106359: ARRAY
106360: PUSH
106361: LD_EXP 181
106365: GREATEREQUAL
106366: IFFALSE 106370
// exit ;
106368: GO 106570
// ComMoveXY ( unit , x , y ) ;
106370: LD_VAR 0 1
106374: PPUSH
106375: LD_VAR 0 2
106379: PPUSH
106380: LD_VAR 0 3
106384: PPUSH
106385: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106389: LD_INT 35
106391: PPUSH
106392: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
106396: LD_VAR 0 1
106400: PPUSH
106401: LD_VAR 0 2
106405: PPUSH
106406: LD_VAR 0 3
106410: PPUSH
106411: CALL 84098 0 3
106415: NOT
106416: PUSH
106417: LD_VAR 0 1
106421: PPUSH
106422: CALL_OW 314
106426: AND
106427: IFFALSE 106431
// exit ;
106429: GO 106570
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
106431: LD_VAR 0 2
106435: PPUSH
106436: LD_VAR 0 3
106440: PPUSH
106441: CALL_OW 428
106445: PUSH
106446: LD_VAR 0 1
106450: EQUAL
106451: PUSH
106452: LD_VAR 0 1
106456: PPUSH
106457: CALL_OW 314
106461: NOT
106462: AND
106463: IFFALSE 106389
// PlaySoundXY ( x , y , PlantMine ) ;
106465: LD_VAR 0 2
106469: PPUSH
106470: LD_VAR 0 3
106474: PPUSH
106475: LD_STRING PlantMine
106477: PPUSH
106478: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
106482: LD_VAR 0 2
106486: PPUSH
106487: LD_VAR 0 3
106491: PPUSH
106492: LD_VAR 0 1
106496: PPUSH
106497: CALL_OW 255
106501: PPUSH
106502: LD_INT 0
106504: PPUSH
106505: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
106509: LD_ADDR_EXP 180
106513: PUSH
106514: LD_EXP 180
106518: PPUSH
106519: LD_VAR 0 5
106523: PUSH
106524: LD_EXP 180
106528: PUSH
106529: LD_VAR 0 5
106533: ARRAY
106534: PUSH
106535: LD_INT 1
106537: PLUS
106538: PUSH
106539: EMPTY
106540: LIST
106541: LIST
106542: PPUSH
106543: LD_VAR 0 2
106547: PUSH
106548: LD_VAR 0 3
106552: PUSH
106553: EMPTY
106554: LIST
106555: LIST
106556: PPUSH
106557: CALL 53541 0 3
106561: ST_TO_ADDR
// result := true ;
106562: LD_ADDR_VAR 0 4
106566: PUSH
106567: LD_INT 1
106569: ST_TO_ADDR
// end ;
106570: LD_VAR 0 4
106574: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
106575: LD_INT 0
106577: PPUSH
106578: PPUSH
106579: PPUSH
// if not unit in minersList then
106580: LD_VAR 0 1
106584: PUSH
106585: LD_EXP 179
106589: IN
106590: NOT
106591: IFFALSE 106595
// exit ;
106593: GO 106987
// index := GetElementIndex ( minersList , unit ) ;
106595: LD_ADDR_VAR 0 6
106599: PUSH
106600: LD_EXP 179
106604: PPUSH
106605: LD_VAR 0 1
106609: PPUSH
106610: CALL 53326 0 2
106614: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
106615: LD_ADDR_VAR 0 5
106619: PUSH
106620: DOUBLE
106621: LD_EXP 180
106625: PUSH
106626: LD_VAR 0 6
106630: ARRAY
106631: INC
106632: ST_TO_ADDR
106633: LD_INT 1
106635: PUSH
106636: FOR_DOWNTO
106637: IFFALSE 106798
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
106639: LD_EXP 180
106643: PUSH
106644: LD_VAR 0 6
106648: ARRAY
106649: PUSH
106650: LD_VAR 0 5
106654: ARRAY
106655: PUSH
106656: LD_INT 1
106658: ARRAY
106659: PUSH
106660: LD_VAR 0 2
106664: EQUAL
106665: PUSH
106666: LD_EXP 180
106670: PUSH
106671: LD_VAR 0 6
106675: ARRAY
106676: PUSH
106677: LD_VAR 0 5
106681: ARRAY
106682: PUSH
106683: LD_INT 2
106685: ARRAY
106686: PUSH
106687: LD_VAR 0 3
106691: EQUAL
106692: AND
106693: IFFALSE 106796
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106695: LD_EXP 180
106699: PUSH
106700: LD_VAR 0 6
106704: ARRAY
106705: PUSH
106706: LD_VAR 0 5
106710: ARRAY
106711: PUSH
106712: LD_INT 1
106714: ARRAY
106715: PPUSH
106716: LD_EXP 180
106720: PUSH
106721: LD_VAR 0 6
106725: ARRAY
106726: PUSH
106727: LD_VAR 0 5
106731: ARRAY
106732: PUSH
106733: LD_INT 2
106735: ARRAY
106736: PPUSH
106737: LD_VAR 0 1
106741: PPUSH
106742: CALL_OW 255
106746: PPUSH
106747: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106751: LD_ADDR_EXP 180
106755: PUSH
106756: LD_EXP 180
106760: PPUSH
106761: LD_VAR 0 6
106765: PPUSH
106766: LD_EXP 180
106770: PUSH
106771: LD_VAR 0 6
106775: ARRAY
106776: PPUSH
106777: LD_VAR 0 5
106781: PPUSH
106782: CALL_OW 3
106786: PPUSH
106787: CALL_OW 1
106791: ST_TO_ADDR
// exit ;
106792: POP
106793: POP
106794: GO 106987
// end ; end ;
106796: GO 106636
106798: POP
106799: POP
// for i := minerMinesList [ index ] downto 1 do
106800: LD_ADDR_VAR 0 5
106804: PUSH
106805: DOUBLE
106806: LD_EXP 180
106810: PUSH
106811: LD_VAR 0 6
106815: ARRAY
106816: INC
106817: ST_TO_ADDR
106818: LD_INT 1
106820: PUSH
106821: FOR_DOWNTO
106822: IFFALSE 106985
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
106824: LD_EXP 180
106828: PUSH
106829: LD_VAR 0 6
106833: ARRAY
106834: PUSH
106835: LD_VAR 0 5
106839: ARRAY
106840: PUSH
106841: LD_INT 1
106843: ARRAY
106844: PPUSH
106845: LD_EXP 180
106849: PUSH
106850: LD_VAR 0 6
106854: ARRAY
106855: PUSH
106856: LD_VAR 0 5
106860: ARRAY
106861: PUSH
106862: LD_INT 2
106864: ARRAY
106865: PPUSH
106866: LD_VAR 0 2
106870: PPUSH
106871: LD_VAR 0 3
106875: PPUSH
106876: CALL_OW 298
106880: PUSH
106881: LD_INT 6
106883: LESS
106884: IFFALSE 106983
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106886: LD_EXP 180
106890: PUSH
106891: LD_VAR 0 6
106895: ARRAY
106896: PUSH
106897: LD_VAR 0 5
106901: ARRAY
106902: PUSH
106903: LD_INT 1
106905: ARRAY
106906: PPUSH
106907: LD_EXP 180
106911: PUSH
106912: LD_VAR 0 6
106916: ARRAY
106917: PUSH
106918: LD_VAR 0 5
106922: ARRAY
106923: PUSH
106924: LD_INT 2
106926: ARRAY
106927: PPUSH
106928: LD_VAR 0 1
106932: PPUSH
106933: CALL_OW 255
106937: PPUSH
106938: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106942: LD_ADDR_EXP 180
106946: PUSH
106947: LD_EXP 180
106951: PPUSH
106952: LD_VAR 0 6
106956: PPUSH
106957: LD_EXP 180
106961: PUSH
106962: LD_VAR 0 6
106966: ARRAY
106967: PPUSH
106968: LD_VAR 0 5
106972: PPUSH
106973: CALL_OW 3
106977: PPUSH
106978: CALL_OW 1
106982: ST_TO_ADDR
// end ; end ;
106983: GO 106821
106985: POP
106986: POP
// end ;
106987: LD_VAR 0 4
106991: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
106992: LD_INT 0
106994: PPUSH
106995: PPUSH
106996: PPUSH
106997: PPUSH
106998: PPUSH
106999: PPUSH
107000: PPUSH
107001: PPUSH
107002: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
107003: LD_VAR 0 1
107007: PPUSH
107008: CALL_OW 264
107012: PUSH
107013: LD_EXP 101
107017: EQUAL
107018: NOT
107019: PUSH
107020: LD_VAR 0 1
107024: PUSH
107025: LD_EXP 179
107029: IN
107030: NOT
107031: OR
107032: IFFALSE 107036
// exit ;
107034: GO 107358
// index := GetElementIndex ( minersList , unit ) ;
107036: LD_ADDR_VAR 0 6
107040: PUSH
107041: LD_EXP 179
107045: PPUSH
107046: LD_VAR 0 1
107050: PPUSH
107051: CALL 53326 0 2
107055: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
107056: LD_ADDR_VAR 0 8
107060: PUSH
107061: LD_EXP 181
107065: PUSH
107066: LD_EXP 180
107070: PUSH
107071: LD_VAR 0 6
107075: ARRAY
107076: MINUS
107077: ST_TO_ADDR
// if not minesFreeAmount then
107078: LD_VAR 0 8
107082: NOT
107083: IFFALSE 107087
// exit ;
107085: GO 107358
// tmp := [ ] ;
107087: LD_ADDR_VAR 0 7
107091: PUSH
107092: EMPTY
107093: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
107094: LD_ADDR_VAR 0 5
107098: PUSH
107099: DOUBLE
107100: LD_INT 1
107102: DEC
107103: ST_TO_ADDR
107104: LD_VAR 0 8
107108: PUSH
107109: FOR_TO
107110: IFFALSE 107305
// begin _d := rand ( 0 , 5 ) ;
107112: LD_ADDR_VAR 0 11
107116: PUSH
107117: LD_INT 0
107119: PPUSH
107120: LD_INT 5
107122: PPUSH
107123: CALL_OW 12
107127: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
107128: LD_ADDR_VAR 0 12
107132: PUSH
107133: LD_INT 2
107135: PPUSH
107136: LD_INT 6
107138: PPUSH
107139: CALL_OW 12
107143: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
107144: LD_ADDR_VAR 0 9
107148: PUSH
107149: LD_VAR 0 2
107153: PPUSH
107154: LD_VAR 0 11
107158: PPUSH
107159: LD_VAR 0 12
107163: PPUSH
107164: CALL_OW 272
107168: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
107169: LD_ADDR_VAR 0 10
107173: PUSH
107174: LD_VAR 0 3
107178: PPUSH
107179: LD_VAR 0 11
107183: PPUSH
107184: LD_VAR 0 12
107188: PPUSH
107189: CALL_OW 273
107193: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
107194: LD_VAR 0 9
107198: PPUSH
107199: LD_VAR 0 10
107203: PPUSH
107204: CALL_OW 488
107208: PUSH
107209: LD_VAR 0 9
107213: PUSH
107214: LD_VAR 0 10
107218: PUSH
107219: EMPTY
107220: LIST
107221: LIST
107222: PUSH
107223: LD_VAR 0 7
107227: IN
107228: NOT
107229: AND
107230: PUSH
107231: LD_VAR 0 9
107235: PPUSH
107236: LD_VAR 0 10
107240: PPUSH
107241: CALL_OW 458
107245: NOT
107246: AND
107247: IFFALSE 107289
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
107249: LD_ADDR_VAR 0 7
107253: PUSH
107254: LD_VAR 0 7
107258: PPUSH
107259: LD_VAR 0 7
107263: PUSH
107264: LD_INT 1
107266: PLUS
107267: PPUSH
107268: LD_VAR 0 9
107272: PUSH
107273: LD_VAR 0 10
107277: PUSH
107278: EMPTY
107279: LIST
107280: LIST
107281: PPUSH
107282: CALL_OW 1
107286: ST_TO_ADDR
107287: GO 107303
// i := i - 1 ;
107289: LD_ADDR_VAR 0 5
107293: PUSH
107294: LD_VAR 0 5
107298: PUSH
107299: LD_INT 1
107301: MINUS
107302: ST_TO_ADDR
// end ;
107303: GO 107109
107305: POP
107306: POP
// for i in tmp do
107307: LD_ADDR_VAR 0 5
107311: PUSH
107312: LD_VAR 0 7
107316: PUSH
107317: FOR_IN
107318: IFFALSE 107356
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
107320: LD_VAR 0 1
107324: PPUSH
107325: LD_VAR 0 5
107329: PUSH
107330: LD_INT 1
107332: ARRAY
107333: PPUSH
107334: LD_VAR 0 5
107338: PUSH
107339: LD_INT 2
107341: ARRAY
107342: PPUSH
107343: CALL 106298 0 3
107347: NOT
107348: IFFALSE 107354
// exit ;
107350: POP
107351: POP
107352: GO 107358
107354: GO 107317
107356: POP
107357: POP
// end ;
107358: LD_VAR 0 4
107362: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
107363: LD_INT 0
107365: PPUSH
107366: PPUSH
107367: PPUSH
107368: PPUSH
107369: PPUSH
107370: PPUSH
107371: PPUSH
// if not GetClass ( unit ) = class_sniper then
107372: LD_VAR 0 1
107376: PPUSH
107377: CALL_OW 257
107381: PUSH
107382: LD_INT 5
107384: EQUAL
107385: NOT
107386: IFFALSE 107390
// exit ;
107388: GO 107778
// dist := 8 ;
107390: LD_ADDR_VAR 0 5
107394: PUSH
107395: LD_INT 8
107397: ST_TO_ADDR
// viewRange := 12 ;
107398: LD_ADDR_VAR 0 7
107402: PUSH
107403: LD_INT 12
107405: ST_TO_ADDR
// side := GetSide ( unit ) ;
107406: LD_ADDR_VAR 0 6
107410: PUSH
107411: LD_VAR 0 1
107415: PPUSH
107416: CALL_OW 255
107420: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
107421: LD_INT 61
107423: PPUSH
107424: LD_VAR 0 6
107428: PPUSH
107429: CALL_OW 321
107433: PUSH
107434: LD_INT 2
107436: EQUAL
107437: IFFALSE 107447
// viewRange := 16 ;
107439: LD_ADDR_VAR 0 7
107443: PUSH
107444: LD_INT 16
107446: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
107447: LD_VAR 0 1
107451: PPUSH
107452: LD_VAR 0 2
107456: PPUSH
107457: LD_VAR 0 3
107461: PPUSH
107462: CALL_OW 297
107466: PUSH
107467: LD_VAR 0 5
107471: GREATER
107472: IFFALSE 107551
// begin ComMoveXY ( unit , x , y ) ;
107474: LD_VAR 0 1
107478: PPUSH
107479: LD_VAR 0 2
107483: PPUSH
107484: LD_VAR 0 3
107488: PPUSH
107489: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
107493: LD_INT 35
107495: PPUSH
107496: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
107500: LD_VAR 0 1
107504: PPUSH
107505: LD_VAR 0 2
107509: PPUSH
107510: LD_VAR 0 3
107514: PPUSH
107515: CALL 84098 0 3
107519: NOT
107520: IFFALSE 107524
// exit ;
107522: GO 107778
// until GetDistUnitXY ( unit , x , y ) < dist ;
107524: LD_VAR 0 1
107528: PPUSH
107529: LD_VAR 0 2
107533: PPUSH
107534: LD_VAR 0 3
107538: PPUSH
107539: CALL_OW 297
107543: PUSH
107544: LD_VAR 0 5
107548: LESS
107549: IFFALSE 107493
// end ; ComTurnXY ( unit , x , y ) ;
107551: LD_VAR 0 1
107555: PPUSH
107556: LD_VAR 0 2
107560: PPUSH
107561: LD_VAR 0 3
107565: PPUSH
107566: CALL_OW 118
// wait ( 5 ) ;
107570: LD_INT 5
107572: PPUSH
107573: CALL_OW 67
// _d := GetDir ( unit ) ;
107577: LD_ADDR_VAR 0 10
107581: PUSH
107582: LD_VAR 0 1
107586: PPUSH
107587: CALL_OW 254
107591: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
107592: LD_ADDR_VAR 0 8
107596: PUSH
107597: LD_VAR 0 1
107601: PPUSH
107602: CALL_OW 250
107606: PPUSH
107607: LD_VAR 0 10
107611: PPUSH
107612: LD_VAR 0 5
107616: PPUSH
107617: CALL_OW 272
107621: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
107622: LD_ADDR_VAR 0 9
107626: PUSH
107627: LD_VAR 0 1
107631: PPUSH
107632: CALL_OW 251
107636: PPUSH
107637: LD_VAR 0 10
107641: PPUSH
107642: LD_VAR 0 5
107646: PPUSH
107647: CALL_OW 273
107651: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
107652: LD_VAR 0 8
107656: PPUSH
107657: LD_VAR 0 9
107661: PPUSH
107662: CALL_OW 488
107666: NOT
107667: IFFALSE 107671
// exit ;
107669: GO 107778
// ComAnimCustom ( unit , 1 ) ;
107671: LD_VAR 0 1
107675: PPUSH
107676: LD_INT 1
107678: PPUSH
107679: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
107683: LD_VAR 0 8
107687: PPUSH
107688: LD_VAR 0 9
107692: PPUSH
107693: LD_VAR 0 6
107697: PPUSH
107698: LD_VAR 0 7
107702: PPUSH
107703: CALL_OW 330
// repeat wait ( 1 ) ;
107707: LD_INT 1
107709: PPUSH
107710: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
107714: LD_VAR 0 1
107718: PPUSH
107719: CALL_OW 316
107723: PUSH
107724: LD_VAR 0 1
107728: PPUSH
107729: CALL_OW 314
107733: OR
107734: PUSH
107735: LD_VAR 0 1
107739: PPUSH
107740: CALL_OW 302
107744: NOT
107745: OR
107746: PUSH
107747: LD_VAR 0 1
107751: PPUSH
107752: CALL_OW 301
107756: OR
107757: IFFALSE 107707
// RemoveSeeing ( _x , _y , side ) ;
107759: LD_VAR 0 8
107763: PPUSH
107764: LD_VAR 0 9
107768: PPUSH
107769: LD_VAR 0 6
107773: PPUSH
107774: CALL_OW 331
// end ; end_of_file
107778: LD_VAR 0 4
107782: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
107783: LD_INT 0
107785: PPUSH
107786: PPUSH
107787: PPUSH
107788: PPUSH
107789: PPUSH
107790: PPUSH
107791: PPUSH
107792: PPUSH
107793: PPUSH
107794: PPUSH
107795: PPUSH
107796: PPUSH
107797: PPUSH
107798: PPUSH
107799: PPUSH
107800: PPUSH
107801: PPUSH
107802: PPUSH
107803: PPUSH
107804: PPUSH
107805: PPUSH
107806: PPUSH
107807: PPUSH
107808: PPUSH
107809: PPUSH
107810: PPUSH
107811: PPUSH
107812: PPUSH
107813: PPUSH
107814: PPUSH
107815: PPUSH
107816: PPUSH
107817: PPUSH
107818: PPUSH
// if not list then
107819: LD_VAR 0 1
107823: NOT
107824: IFFALSE 107828
// exit ;
107826: GO 112487
// base := list [ 1 ] ;
107828: LD_ADDR_VAR 0 3
107832: PUSH
107833: LD_VAR 0 1
107837: PUSH
107838: LD_INT 1
107840: ARRAY
107841: ST_TO_ADDR
// group := list [ 2 ] ;
107842: LD_ADDR_VAR 0 4
107846: PUSH
107847: LD_VAR 0 1
107851: PUSH
107852: LD_INT 2
107854: ARRAY
107855: ST_TO_ADDR
// path := list [ 3 ] ;
107856: LD_ADDR_VAR 0 5
107860: PUSH
107861: LD_VAR 0 1
107865: PUSH
107866: LD_INT 3
107868: ARRAY
107869: ST_TO_ADDR
// flags := list [ 4 ] ;
107870: LD_ADDR_VAR 0 6
107874: PUSH
107875: LD_VAR 0 1
107879: PUSH
107880: LD_INT 4
107882: ARRAY
107883: ST_TO_ADDR
// mined := [ ] ;
107884: LD_ADDR_VAR 0 27
107888: PUSH
107889: EMPTY
107890: ST_TO_ADDR
// bombed := [ ] ;
107891: LD_ADDR_VAR 0 28
107895: PUSH
107896: EMPTY
107897: ST_TO_ADDR
// healers := [ ] ;
107898: LD_ADDR_VAR 0 31
107902: PUSH
107903: EMPTY
107904: ST_TO_ADDR
// to_heal := [ ] ;
107905: LD_ADDR_VAR 0 30
107909: PUSH
107910: EMPTY
107911: ST_TO_ADDR
// repairs := [ ] ;
107912: LD_ADDR_VAR 0 33
107916: PUSH
107917: EMPTY
107918: ST_TO_ADDR
// to_repair := [ ] ;
107919: LD_ADDR_VAR 0 32
107923: PUSH
107924: EMPTY
107925: ST_TO_ADDR
// if not group or not path then
107926: LD_VAR 0 4
107930: NOT
107931: PUSH
107932: LD_VAR 0 5
107936: NOT
107937: OR
107938: IFFALSE 107942
// exit ;
107940: GO 112487
// side := GetSide ( group [ 1 ] ) ;
107942: LD_ADDR_VAR 0 35
107946: PUSH
107947: LD_VAR 0 4
107951: PUSH
107952: LD_INT 1
107954: ARRAY
107955: PPUSH
107956: CALL_OW 255
107960: ST_TO_ADDR
// if flags then
107961: LD_VAR 0 6
107965: IFFALSE 108109
// begin f_ignore_area := flags [ 1 ] ;
107967: LD_ADDR_VAR 0 17
107971: PUSH
107972: LD_VAR 0 6
107976: PUSH
107977: LD_INT 1
107979: ARRAY
107980: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
107981: LD_ADDR_VAR 0 18
107985: PUSH
107986: LD_VAR 0 6
107990: PUSH
107991: LD_INT 2
107993: ARRAY
107994: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
107995: LD_ADDR_VAR 0 19
107999: PUSH
108000: LD_VAR 0 6
108004: PUSH
108005: LD_INT 3
108007: ARRAY
108008: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
108009: LD_ADDR_VAR 0 20
108013: PUSH
108014: LD_VAR 0 6
108018: PUSH
108019: LD_INT 4
108021: ARRAY
108022: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
108023: LD_ADDR_VAR 0 21
108027: PUSH
108028: LD_VAR 0 6
108032: PUSH
108033: LD_INT 5
108035: ARRAY
108036: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
108037: LD_ADDR_VAR 0 22
108041: PUSH
108042: LD_VAR 0 6
108046: PUSH
108047: LD_INT 6
108049: ARRAY
108050: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
108051: LD_ADDR_VAR 0 23
108055: PUSH
108056: LD_VAR 0 6
108060: PUSH
108061: LD_INT 7
108063: ARRAY
108064: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
108065: LD_ADDR_VAR 0 24
108069: PUSH
108070: LD_VAR 0 6
108074: PUSH
108075: LD_INT 8
108077: ARRAY
108078: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
108079: LD_ADDR_VAR 0 25
108083: PUSH
108084: LD_VAR 0 6
108088: PUSH
108089: LD_INT 9
108091: ARRAY
108092: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
108093: LD_ADDR_VAR 0 26
108097: PUSH
108098: LD_VAR 0 6
108102: PUSH
108103: LD_INT 10
108105: ARRAY
108106: ST_TO_ADDR
// end else
108107: GO 108189
// begin f_ignore_area := false ;
108109: LD_ADDR_VAR 0 17
108113: PUSH
108114: LD_INT 0
108116: ST_TO_ADDR
// f_capture := false ;
108117: LD_ADDR_VAR 0 18
108121: PUSH
108122: LD_INT 0
108124: ST_TO_ADDR
// f_ignore_civ := false ;
108125: LD_ADDR_VAR 0 19
108129: PUSH
108130: LD_INT 0
108132: ST_TO_ADDR
// f_murder := false ;
108133: LD_ADDR_VAR 0 20
108137: PUSH
108138: LD_INT 0
108140: ST_TO_ADDR
// f_mines := false ;
108141: LD_ADDR_VAR 0 21
108145: PUSH
108146: LD_INT 0
108148: ST_TO_ADDR
// f_repair := false ;
108149: LD_ADDR_VAR 0 22
108153: PUSH
108154: LD_INT 0
108156: ST_TO_ADDR
// f_heal := false ;
108157: LD_ADDR_VAR 0 23
108161: PUSH
108162: LD_INT 0
108164: ST_TO_ADDR
// f_spacetime := false ;
108165: LD_ADDR_VAR 0 24
108169: PUSH
108170: LD_INT 0
108172: ST_TO_ADDR
// f_attack_depot := false ;
108173: LD_ADDR_VAR 0 25
108177: PUSH
108178: LD_INT 0
108180: ST_TO_ADDR
// f_crawl := false ;
108181: LD_ADDR_VAR 0 26
108185: PUSH
108186: LD_INT 0
108188: ST_TO_ADDR
// end ; if f_heal then
108189: LD_VAR 0 23
108193: IFFALSE 108220
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
108195: LD_ADDR_VAR 0 31
108199: PUSH
108200: LD_VAR 0 4
108204: PPUSH
108205: LD_INT 25
108207: PUSH
108208: LD_INT 4
108210: PUSH
108211: EMPTY
108212: LIST
108213: LIST
108214: PPUSH
108215: CALL_OW 72
108219: ST_TO_ADDR
// if f_repair then
108220: LD_VAR 0 22
108224: IFFALSE 108251
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
108226: LD_ADDR_VAR 0 33
108230: PUSH
108231: LD_VAR 0 4
108235: PPUSH
108236: LD_INT 25
108238: PUSH
108239: LD_INT 3
108241: PUSH
108242: EMPTY
108243: LIST
108244: LIST
108245: PPUSH
108246: CALL_OW 72
108250: ST_TO_ADDR
// units_path := [ ] ;
108251: LD_ADDR_VAR 0 16
108255: PUSH
108256: EMPTY
108257: ST_TO_ADDR
// for i = 1 to group do
108258: LD_ADDR_VAR 0 7
108262: PUSH
108263: DOUBLE
108264: LD_INT 1
108266: DEC
108267: ST_TO_ADDR
108268: LD_VAR 0 4
108272: PUSH
108273: FOR_TO
108274: IFFALSE 108303
// units_path := Replace ( units_path , i , path ) ;
108276: LD_ADDR_VAR 0 16
108280: PUSH
108281: LD_VAR 0 16
108285: PPUSH
108286: LD_VAR 0 7
108290: PPUSH
108291: LD_VAR 0 5
108295: PPUSH
108296: CALL_OW 1
108300: ST_TO_ADDR
108301: GO 108273
108303: POP
108304: POP
// repeat for i = group downto 1 do
108305: LD_ADDR_VAR 0 7
108309: PUSH
108310: DOUBLE
108311: LD_VAR 0 4
108315: INC
108316: ST_TO_ADDR
108317: LD_INT 1
108319: PUSH
108320: FOR_DOWNTO
108321: IFFALSE 112443
// begin wait ( 5 ) ;
108323: LD_INT 5
108325: PPUSH
108326: CALL_OW 67
// tmp := [ ] ;
108330: LD_ADDR_VAR 0 14
108334: PUSH
108335: EMPTY
108336: ST_TO_ADDR
// attacking := false ;
108337: LD_ADDR_VAR 0 29
108341: PUSH
108342: LD_INT 0
108344: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
108345: LD_VAR 0 4
108349: PUSH
108350: LD_VAR 0 7
108354: ARRAY
108355: PPUSH
108356: CALL_OW 301
108360: PUSH
108361: LD_VAR 0 4
108365: PUSH
108366: LD_VAR 0 7
108370: ARRAY
108371: NOT
108372: OR
108373: IFFALSE 108482
// begin if GetType ( group [ i ] ) = unit_human then
108375: LD_VAR 0 4
108379: PUSH
108380: LD_VAR 0 7
108384: ARRAY
108385: PPUSH
108386: CALL_OW 247
108390: PUSH
108391: LD_INT 1
108393: EQUAL
108394: IFFALSE 108440
// begin to_heal := to_heal diff group [ i ] ;
108396: LD_ADDR_VAR 0 30
108400: PUSH
108401: LD_VAR 0 30
108405: PUSH
108406: LD_VAR 0 4
108410: PUSH
108411: LD_VAR 0 7
108415: ARRAY
108416: DIFF
108417: ST_TO_ADDR
// healers := healers diff group [ i ] ;
108418: LD_ADDR_VAR 0 31
108422: PUSH
108423: LD_VAR 0 31
108427: PUSH
108428: LD_VAR 0 4
108432: PUSH
108433: LD_VAR 0 7
108437: ARRAY
108438: DIFF
108439: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
108440: LD_ADDR_VAR 0 4
108444: PUSH
108445: LD_VAR 0 4
108449: PPUSH
108450: LD_VAR 0 7
108454: PPUSH
108455: CALL_OW 3
108459: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
108460: LD_ADDR_VAR 0 16
108464: PUSH
108465: LD_VAR 0 16
108469: PPUSH
108470: LD_VAR 0 7
108474: PPUSH
108475: CALL_OW 3
108479: ST_TO_ADDR
// continue ;
108480: GO 108320
// end ; if f_repair then
108482: LD_VAR 0 22
108486: IFFALSE 108975
// begin if GetType ( group [ i ] ) = unit_vehicle then
108488: LD_VAR 0 4
108492: PUSH
108493: LD_VAR 0 7
108497: ARRAY
108498: PPUSH
108499: CALL_OW 247
108503: PUSH
108504: LD_INT 2
108506: EQUAL
108507: IFFALSE 108697
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
108509: LD_VAR 0 4
108513: PUSH
108514: LD_VAR 0 7
108518: ARRAY
108519: PPUSH
108520: CALL_OW 256
108524: PUSH
108525: LD_INT 700
108527: LESS
108528: PUSH
108529: LD_VAR 0 4
108533: PUSH
108534: LD_VAR 0 7
108538: ARRAY
108539: PUSH
108540: LD_VAR 0 32
108544: IN
108545: NOT
108546: AND
108547: IFFALSE 108571
// to_repair := to_repair union group [ i ] ;
108549: LD_ADDR_VAR 0 32
108553: PUSH
108554: LD_VAR 0 32
108558: PUSH
108559: LD_VAR 0 4
108563: PUSH
108564: LD_VAR 0 7
108568: ARRAY
108569: UNION
108570: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
108571: LD_VAR 0 4
108575: PUSH
108576: LD_VAR 0 7
108580: ARRAY
108581: PPUSH
108582: CALL_OW 256
108586: PUSH
108587: LD_INT 1000
108589: EQUAL
108590: PUSH
108591: LD_VAR 0 4
108595: PUSH
108596: LD_VAR 0 7
108600: ARRAY
108601: PUSH
108602: LD_VAR 0 32
108606: IN
108607: AND
108608: IFFALSE 108632
// to_repair := to_repair diff group [ i ] ;
108610: LD_ADDR_VAR 0 32
108614: PUSH
108615: LD_VAR 0 32
108619: PUSH
108620: LD_VAR 0 4
108624: PUSH
108625: LD_VAR 0 7
108629: ARRAY
108630: DIFF
108631: ST_TO_ADDR
// if group [ i ] in to_repair then
108632: LD_VAR 0 4
108636: PUSH
108637: LD_VAR 0 7
108641: ARRAY
108642: PUSH
108643: LD_VAR 0 32
108647: IN
108648: IFFALSE 108695
// begin if not IsInArea ( group [ i ] , f_repair ) then
108650: LD_VAR 0 4
108654: PUSH
108655: LD_VAR 0 7
108659: ARRAY
108660: PPUSH
108661: LD_VAR 0 22
108665: PPUSH
108666: CALL_OW 308
108670: NOT
108671: IFFALSE 108693
// ComMoveToArea ( group [ i ] , f_repair ) ;
108673: LD_VAR 0 4
108677: PUSH
108678: LD_VAR 0 7
108682: ARRAY
108683: PPUSH
108684: LD_VAR 0 22
108688: PPUSH
108689: CALL_OW 113
// continue ;
108693: GO 108320
// end ; end else
108695: GO 108975
// if group [ i ] in repairs then
108697: LD_VAR 0 4
108701: PUSH
108702: LD_VAR 0 7
108706: ARRAY
108707: PUSH
108708: LD_VAR 0 33
108712: IN
108713: IFFALSE 108975
// begin if IsInUnit ( group [ i ] ) then
108715: LD_VAR 0 4
108719: PUSH
108720: LD_VAR 0 7
108724: ARRAY
108725: PPUSH
108726: CALL_OW 310
108730: IFFALSE 108798
// begin z := IsInUnit ( group [ i ] ) ;
108732: LD_ADDR_VAR 0 13
108736: PUSH
108737: LD_VAR 0 4
108741: PUSH
108742: LD_VAR 0 7
108746: ARRAY
108747: PPUSH
108748: CALL_OW 310
108752: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
108753: LD_VAR 0 13
108757: PUSH
108758: LD_VAR 0 32
108762: IN
108763: PUSH
108764: LD_VAR 0 13
108768: PPUSH
108769: LD_VAR 0 22
108773: PPUSH
108774: CALL_OW 308
108778: AND
108779: IFFALSE 108796
// ComExitVehicle ( group [ i ] ) ;
108781: LD_VAR 0 4
108785: PUSH
108786: LD_VAR 0 7
108790: ARRAY
108791: PPUSH
108792: CALL_OW 121
// end else
108796: GO 108975
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
108798: LD_ADDR_VAR 0 13
108802: PUSH
108803: LD_VAR 0 4
108807: PPUSH
108808: LD_INT 95
108810: PUSH
108811: LD_VAR 0 22
108815: PUSH
108816: EMPTY
108817: LIST
108818: LIST
108819: PUSH
108820: LD_INT 58
108822: PUSH
108823: EMPTY
108824: LIST
108825: PUSH
108826: EMPTY
108827: LIST
108828: LIST
108829: PPUSH
108830: CALL_OW 72
108834: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
108835: LD_VAR 0 4
108839: PUSH
108840: LD_VAR 0 7
108844: ARRAY
108845: PPUSH
108846: CALL_OW 314
108850: NOT
108851: IFFALSE 108973
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
108853: LD_ADDR_VAR 0 10
108857: PUSH
108858: LD_VAR 0 13
108862: PPUSH
108863: LD_VAR 0 4
108867: PUSH
108868: LD_VAR 0 7
108872: ARRAY
108873: PPUSH
108874: CALL_OW 74
108878: ST_TO_ADDR
// if not x then
108879: LD_VAR 0 10
108883: NOT
108884: IFFALSE 108888
// continue ;
108886: GO 108320
// if GetLives ( x ) < 1000 then
108888: LD_VAR 0 10
108892: PPUSH
108893: CALL_OW 256
108897: PUSH
108898: LD_INT 1000
108900: LESS
108901: IFFALSE 108925
// ComRepairVehicle ( group [ i ] , x ) else
108903: LD_VAR 0 4
108907: PUSH
108908: LD_VAR 0 7
108912: ARRAY
108913: PPUSH
108914: LD_VAR 0 10
108918: PPUSH
108919: CALL_OW 129
108923: GO 108973
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
108925: LD_VAR 0 23
108929: PUSH
108930: LD_VAR 0 4
108934: PUSH
108935: LD_VAR 0 7
108939: ARRAY
108940: PPUSH
108941: CALL_OW 256
108945: PUSH
108946: LD_INT 1000
108948: LESS
108949: AND
108950: NOT
108951: IFFALSE 108973
// ComEnterUnit ( group [ i ] , x ) ;
108953: LD_VAR 0 4
108957: PUSH
108958: LD_VAR 0 7
108962: ARRAY
108963: PPUSH
108964: LD_VAR 0 10
108968: PPUSH
108969: CALL_OW 120
// end ; continue ;
108973: GO 108320
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
108975: LD_VAR 0 23
108979: PUSH
108980: LD_VAR 0 4
108984: PUSH
108985: LD_VAR 0 7
108989: ARRAY
108990: PPUSH
108991: CALL_OW 247
108995: PUSH
108996: LD_INT 1
108998: EQUAL
108999: AND
109000: IFFALSE 109478
// begin if group [ i ] in healers then
109002: LD_VAR 0 4
109006: PUSH
109007: LD_VAR 0 7
109011: ARRAY
109012: PUSH
109013: LD_VAR 0 31
109017: IN
109018: IFFALSE 109291
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
109020: LD_VAR 0 4
109024: PUSH
109025: LD_VAR 0 7
109029: ARRAY
109030: PPUSH
109031: LD_VAR 0 23
109035: PPUSH
109036: CALL_OW 308
109040: NOT
109041: PUSH
109042: LD_VAR 0 4
109046: PUSH
109047: LD_VAR 0 7
109051: ARRAY
109052: PPUSH
109053: CALL_OW 314
109057: NOT
109058: AND
109059: IFFALSE 109083
// ComMoveToArea ( group [ i ] , f_heal ) else
109061: LD_VAR 0 4
109065: PUSH
109066: LD_VAR 0 7
109070: ARRAY
109071: PPUSH
109072: LD_VAR 0 23
109076: PPUSH
109077: CALL_OW 113
109081: GO 109289
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
109083: LD_VAR 0 4
109087: PUSH
109088: LD_VAR 0 7
109092: ARRAY
109093: PPUSH
109094: CALL 82621 0 1
109098: PPUSH
109099: CALL_OW 256
109103: PUSH
109104: LD_INT 1000
109106: EQUAL
109107: IFFALSE 109126
// ComStop ( group [ i ] ) else
109109: LD_VAR 0 4
109113: PUSH
109114: LD_VAR 0 7
109118: ARRAY
109119: PPUSH
109120: CALL_OW 141
109124: GO 109289
// if not HasTask ( group [ i ] ) and to_heal then
109126: LD_VAR 0 4
109130: PUSH
109131: LD_VAR 0 7
109135: ARRAY
109136: PPUSH
109137: CALL_OW 314
109141: NOT
109142: PUSH
109143: LD_VAR 0 30
109147: AND
109148: IFFALSE 109289
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
109150: LD_ADDR_VAR 0 13
109154: PUSH
109155: LD_VAR 0 30
109159: PPUSH
109160: LD_INT 3
109162: PUSH
109163: LD_INT 54
109165: PUSH
109166: EMPTY
109167: LIST
109168: PUSH
109169: EMPTY
109170: LIST
109171: LIST
109172: PPUSH
109173: CALL_OW 72
109177: PPUSH
109178: LD_VAR 0 4
109182: PUSH
109183: LD_VAR 0 7
109187: ARRAY
109188: PPUSH
109189: CALL_OW 74
109193: ST_TO_ADDR
// if z then
109194: LD_VAR 0 13
109198: IFFALSE 109289
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
109200: LD_INT 91
109202: PUSH
109203: LD_VAR 0 13
109207: PUSH
109208: LD_INT 10
109210: PUSH
109211: EMPTY
109212: LIST
109213: LIST
109214: LIST
109215: PUSH
109216: LD_INT 81
109218: PUSH
109219: LD_VAR 0 13
109223: PPUSH
109224: CALL_OW 255
109228: PUSH
109229: EMPTY
109230: LIST
109231: LIST
109232: PUSH
109233: EMPTY
109234: LIST
109235: LIST
109236: PPUSH
109237: CALL_OW 69
109241: PUSH
109242: LD_INT 0
109244: EQUAL
109245: IFFALSE 109269
// ComHeal ( group [ i ] , z ) else
109247: LD_VAR 0 4
109251: PUSH
109252: LD_VAR 0 7
109256: ARRAY
109257: PPUSH
109258: LD_VAR 0 13
109262: PPUSH
109263: CALL_OW 128
109267: GO 109289
// ComMoveToArea ( group [ i ] , f_heal ) ;
109269: LD_VAR 0 4
109273: PUSH
109274: LD_VAR 0 7
109278: ARRAY
109279: PPUSH
109280: LD_VAR 0 23
109284: PPUSH
109285: CALL_OW 113
// end ; continue ;
109289: GO 108320
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
109291: LD_VAR 0 4
109295: PUSH
109296: LD_VAR 0 7
109300: ARRAY
109301: PPUSH
109302: CALL_OW 256
109306: PUSH
109307: LD_INT 700
109309: LESS
109310: PUSH
109311: LD_VAR 0 4
109315: PUSH
109316: LD_VAR 0 7
109320: ARRAY
109321: PUSH
109322: LD_VAR 0 30
109326: IN
109327: NOT
109328: AND
109329: IFFALSE 109353
// to_heal := to_heal union group [ i ] ;
109331: LD_ADDR_VAR 0 30
109335: PUSH
109336: LD_VAR 0 30
109340: PUSH
109341: LD_VAR 0 4
109345: PUSH
109346: LD_VAR 0 7
109350: ARRAY
109351: UNION
109352: ST_TO_ADDR
// if group [ i ] in to_heal then
109353: LD_VAR 0 4
109357: PUSH
109358: LD_VAR 0 7
109362: ARRAY
109363: PUSH
109364: LD_VAR 0 30
109368: IN
109369: IFFALSE 109478
// begin if GetLives ( group [ i ] ) = 1000 then
109371: LD_VAR 0 4
109375: PUSH
109376: LD_VAR 0 7
109380: ARRAY
109381: PPUSH
109382: CALL_OW 256
109386: PUSH
109387: LD_INT 1000
109389: EQUAL
109390: IFFALSE 109416
// to_heal := to_heal diff group [ i ] else
109392: LD_ADDR_VAR 0 30
109396: PUSH
109397: LD_VAR 0 30
109401: PUSH
109402: LD_VAR 0 4
109406: PUSH
109407: LD_VAR 0 7
109411: ARRAY
109412: DIFF
109413: ST_TO_ADDR
109414: GO 109478
// begin if not IsInArea ( group [ i ] , to_heal ) then
109416: LD_VAR 0 4
109420: PUSH
109421: LD_VAR 0 7
109425: ARRAY
109426: PPUSH
109427: LD_VAR 0 30
109431: PPUSH
109432: CALL_OW 308
109436: NOT
109437: IFFALSE 109461
// ComMoveToArea ( group [ i ] , f_heal ) else
109439: LD_VAR 0 4
109443: PUSH
109444: LD_VAR 0 7
109448: ARRAY
109449: PPUSH
109450: LD_VAR 0 23
109454: PPUSH
109455: CALL_OW 113
109459: GO 109476
// ComHold ( group [ i ] ) ;
109461: LD_VAR 0 4
109465: PUSH
109466: LD_VAR 0 7
109470: ARRAY
109471: PPUSH
109472: CALL_OW 140
// continue ;
109476: GO 108320
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
109478: LD_VAR 0 4
109482: PUSH
109483: LD_VAR 0 7
109487: ARRAY
109488: PPUSH
109489: LD_INT 10
109491: PPUSH
109492: CALL 81041 0 2
109496: NOT
109497: PUSH
109498: LD_VAR 0 16
109502: PUSH
109503: LD_VAR 0 7
109507: ARRAY
109508: PUSH
109509: EMPTY
109510: EQUAL
109511: NOT
109512: AND
109513: IFFALSE 109779
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
109515: LD_VAR 0 4
109519: PUSH
109520: LD_VAR 0 7
109524: ARRAY
109525: PPUSH
109526: CALL_OW 262
109530: PUSH
109531: LD_INT 1
109533: PUSH
109534: LD_INT 2
109536: PUSH
109537: EMPTY
109538: LIST
109539: LIST
109540: IN
109541: IFFALSE 109582
// if GetFuel ( group [ i ] ) < 10 then
109543: LD_VAR 0 4
109547: PUSH
109548: LD_VAR 0 7
109552: ARRAY
109553: PPUSH
109554: CALL_OW 261
109558: PUSH
109559: LD_INT 10
109561: LESS
109562: IFFALSE 109582
// SetFuel ( group [ i ] , 12 ) ;
109564: LD_VAR 0 4
109568: PUSH
109569: LD_VAR 0 7
109573: ARRAY
109574: PPUSH
109575: LD_INT 12
109577: PPUSH
109578: CALL_OW 240
// if units_path [ i ] then
109582: LD_VAR 0 16
109586: PUSH
109587: LD_VAR 0 7
109591: ARRAY
109592: IFFALSE 109777
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
109594: LD_VAR 0 4
109598: PUSH
109599: LD_VAR 0 7
109603: ARRAY
109604: PPUSH
109605: LD_VAR 0 16
109609: PUSH
109610: LD_VAR 0 7
109614: ARRAY
109615: PUSH
109616: LD_INT 1
109618: ARRAY
109619: PUSH
109620: LD_INT 1
109622: ARRAY
109623: PPUSH
109624: LD_VAR 0 16
109628: PUSH
109629: LD_VAR 0 7
109633: ARRAY
109634: PUSH
109635: LD_INT 1
109637: ARRAY
109638: PUSH
109639: LD_INT 2
109641: ARRAY
109642: PPUSH
109643: CALL_OW 297
109647: PUSH
109648: LD_INT 6
109650: GREATER
109651: IFFALSE 109726
// begin if not HasTask ( group [ i ] ) then
109653: LD_VAR 0 4
109657: PUSH
109658: LD_VAR 0 7
109662: ARRAY
109663: PPUSH
109664: CALL_OW 314
109668: NOT
109669: IFFALSE 109724
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
109671: LD_VAR 0 4
109675: PUSH
109676: LD_VAR 0 7
109680: ARRAY
109681: PPUSH
109682: LD_VAR 0 16
109686: PUSH
109687: LD_VAR 0 7
109691: ARRAY
109692: PUSH
109693: LD_INT 1
109695: ARRAY
109696: PUSH
109697: LD_INT 1
109699: ARRAY
109700: PPUSH
109701: LD_VAR 0 16
109705: PUSH
109706: LD_VAR 0 7
109710: ARRAY
109711: PUSH
109712: LD_INT 1
109714: ARRAY
109715: PUSH
109716: LD_INT 2
109718: ARRAY
109719: PPUSH
109720: CALL_OW 114
// end else
109724: GO 109777
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
109726: LD_ADDR_VAR 0 15
109730: PUSH
109731: LD_VAR 0 16
109735: PUSH
109736: LD_VAR 0 7
109740: ARRAY
109741: PPUSH
109742: LD_INT 1
109744: PPUSH
109745: CALL_OW 3
109749: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
109750: LD_ADDR_VAR 0 16
109754: PUSH
109755: LD_VAR 0 16
109759: PPUSH
109760: LD_VAR 0 7
109764: PPUSH
109765: LD_VAR 0 15
109769: PPUSH
109770: CALL_OW 1
109774: ST_TO_ADDR
// continue ;
109775: GO 108320
// end ; end ; end else
109777: GO 112441
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
109779: LD_ADDR_VAR 0 14
109783: PUSH
109784: LD_INT 81
109786: PUSH
109787: LD_VAR 0 4
109791: PUSH
109792: LD_VAR 0 7
109796: ARRAY
109797: PPUSH
109798: CALL_OW 255
109802: PUSH
109803: EMPTY
109804: LIST
109805: LIST
109806: PPUSH
109807: CALL_OW 69
109811: ST_TO_ADDR
// if not tmp then
109812: LD_VAR 0 14
109816: NOT
109817: IFFALSE 109821
// continue ;
109819: GO 108320
// if f_ignore_area then
109821: LD_VAR 0 17
109825: IFFALSE 109913
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
109827: LD_ADDR_VAR 0 15
109831: PUSH
109832: LD_VAR 0 14
109836: PPUSH
109837: LD_INT 3
109839: PUSH
109840: LD_INT 92
109842: PUSH
109843: LD_VAR 0 17
109847: PUSH
109848: LD_INT 1
109850: ARRAY
109851: PUSH
109852: LD_VAR 0 17
109856: PUSH
109857: LD_INT 2
109859: ARRAY
109860: PUSH
109861: LD_VAR 0 17
109865: PUSH
109866: LD_INT 3
109868: ARRAY
109869: PUSH
109870: EMPTY
109871: LIST
109872: LIST
109873: LIST
109874: LIST
109875: PUSH
109876: EMPTY
109877: LIST
109878: LIST
109879: PPUSH
109880: CALL_OW 72
109884: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109885: LD_VAR 0 14
109889: PUSH
109890: LD_VAR 0 15
109894: DIFF
109895: IFFALSE 109913
// tmp := tmp diff tmp2 ;
109897: LD_ADDR_VAR 0 14
109901: PUSH
109902: LD_VAR 0 14
109906: PUSH
109907: LD_VAR 0 15
109911: DIFF
109912: ST_TO_ADDR
// end ; if not f_murder then
109913: LD_VAR 0 20
109917: NOT
109918: IFFALSE 109976
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
109920: LD_ADDR_VAR 0 15
109924: PUSH
109925: LD_VAR 0 14
109929: PPUSH
109930: LD_INT 3
109932: PUSH
109933: LD_INT 50
109935: PUSH
109936: EMPTY
109937: LIST
109938: PUSH
109939: EMPTY
109940: LIST
109941: LIST
109942: PPUSH
109943: CALL_OW 72
109947: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109948: LD_VAR 0 14
109952: PUSH
109953: LD_VAR 0 15
109957: DIFF
109958: IFFALSE 109976
// tmp := tmp diff tmp2 ;
109960: LD_ADDR_VAR 0 14
109964: PUSH
109965: LD_VAR 0 14
109969: PUSH
109970: LD_VAR 0 15
109974: DIFF
109975: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
109976: LD_ADDR_VAR 0 14
109980: PUSH
109981: LD_VAR 0 4
109985: PUSH
109986: LD_VAR 0 7
109990: ARRAY
109991: PPUSH
109992: LD_VAR 0 14
109996: PPUSH
109997: LD_INT 1
109999: PPUSH
110000: LD_INT 1
110002: PPUSH
110003: CALL 53976 0 4
110007: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
110008: LD_VAR 0 4
110012: PUSH
110013: LD_VAR 0 7
110017: ARRAY
110018: PPUSH
110019: CALL_OW 257
110023: PUSH
110024: LD_INT 1
110026: EQUAL
110027: IFFALSE 110475
// begin if WantPlant ( group [ i ] ) then
110029: LD_VAR 0 4
110033: PUSH
110034: LD_VAR 0 7
110038: ARRAY
110039: PPUSH
110040: CALL 53477 0 1
110044: IFFALSE 110048
// continue ;
110046: GO 108320
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
110048: LD_VAR 0 18
110052: PUSH
110053: LD_VAR 0 4
110057: PUSH
110058: LD_VAR 0 7
110062: ARRAY
110063: PPUSH
110064: CALL_OW 310
110068: NOT
110069: AND
110070: PUSH
110071: LD_VAR 0 14
110075: PUSH
110076: LD_INT 1
110078: ARRAY
110079: PUSH
110080: LD_VAR 0 14
110084: PPUSH
110085: LD_INT 21
110087: PUSH
110088: LD_INT 2
110090: PUSH
110091: EMPTY
110092: LIST
110093: LIST
110094: PUSH
110095: LD_INT 58
110097: PUSH
110098: EMPTY
110099: LIST
110100: PUSH
110101: EMPTY
110102: LIST
110103: LIST
110104: PPUSH
110105: CALL_OW 72
110109: IN
110110: AND
110111: IFFALSE 110147
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
110113: LD_VAR 0 4
110117: PUSH
110118: LD_VAR 0 7
110122: ARRAY
110123: PPUSH
110124: LD_VAR 0 14
110128: PUSH
110129: LD_INT 1
110131: ARRAY
110132: PPUSH
110133: CALL_OW 120
// attacking := true ;
110137: LD_ADDR_VAR 0 29
110141: PUSH
110142: LD_INT 1
110144: ST_TO_ADDR
// continue ;
110145: GO 108320
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
110147: LD_VAR 0 26
110151: PUSH
110152: LD_VAR 0 4
110156: PUSH
110157: LD_VAR 0 7
110161: ARRAY
110162: PPUSH
110163: CALL_OW 257
110167: PUSH
110168: LD_INT 1
110170: EQUAL
110171: AND
110172: PUSH
110173: LD_VAR 0 4
110177: PUSH
110178: LD_VAR 0 7
110182: ARRAY
110183: PPUSH
110184: CALL_OW 256
110188: PUSH
110189: LD_INT 800
110191: LESS
110192: AND
110193: PUSH
110194: LD_VAR 0 4
110198: PUSH
110199: LD_VAR 0 7
110203: ARRAY
110204: PPUSH
110205: CALL_OW 318
110209: NOT
110210: AND
110211: IFFALSE 110228
// ComCrawl ( group [ i ] ) ;
110213: LD_VAR 0 4
110217: PUSH
110218: LD_VAR 0 7
110222: ARRAY
110223: PPUSH
110224: CALL_OW 137
// if f_mines then
110228: LD_VAR 0 21
110232: IFFALSE 110475
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
110234: LD_VAR 0 14
110238: PUSH
110239: LD_INT 1
110241: ARRAY
110242: PPUSH
110243: CALL_OW 247
110247: PUSH
110248: LD_INT 3
110250: EQUAL
110251: PUSH
110252: LD_VAR 0 14
110256: PUSH
110257: LD_INT 1
110259: ARRAY
110260: PUSH
110261: LD_VAR 0 27
110265: IN
110266: NOT
110267: AND
110268: IFFALSE 110475
// begin x := GetX ( tmp [ 1 ] ) ;
110270: LD_ADDR_VAR 0 10
110274: PUSH
110275: LD_VAR 0 14
110279: PUSH
110280: LD_INT 1
110282: ARRAY
110283: PPUSH
110284: CALL_OW 250
110288: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
110289: LD_ADDR_VAR 0 11
110293: PUSH
110294: LD_VAR 0 14
110298: PUSH
110299: LD_INT 1
110301: ARRAY
110302: PPUSH
110303: CALL_OW 251
110307: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
110308: LD_ADDR_VAR 0 12
110312: PUSH
110313: LD_VAR 0 4
110317: PUSH
110318: LD_VAR 0 7
110322: ARRAY
110323: PPUSH
110324: CALL 81126 0 1
110328: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
110329: LD_VAR 0 4
110333: PUSH
110334: LD_VAR 0 7
110338: ARRAY
110339: PPUSH
110340: LD_VAR 0 10
110344: PPUSH
110345: LD_VAR 0 11
110349: PPUSH
110350: LD_VAR 0 14
110354: PUSH
110355: LD_INT 1
110357: ARRAY
110358: PPUSH
110359: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
110363: LD_VAR 0 4
110367: PUSH
110368: LD_VAR 0 7
110372: ARRAY
110373: PPUSH
110374: LD_VAR 0 10
110378: PPUSH
110379: LD_VAR 0 12
110383: PPUSH
110384: LD_INT 7
110386: PPUSH
110387: CALL_OW 272
110391: PPUSH
110392: LD_VAR 0 11
110396: PPUSH
110397: LD_VAR 0 12
110401: PPUSH
110402: LD_INT 7
110404: PPUSH
110405: CALL_OW 273
110409: PPUSH
110410: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
110414: LD_VAR 0 4
110418: PUSH
110419: LD_VAR 0 7
110423: ARRAY
110424: PPUSH
110425: LD_INT 71
110427: PPUSH
110428: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
110432: LD_ADDR_VAR 0 27
110436: PUSH
110437: LD_VAR 0 27
110441: PPUSH
110442: LD_VAR 0 27
110446: PUSH
110447: LD_INT 1
110449: PLUS
110450: PPUSH
110451: LD_VAR 0 14
110455: PUSH
110456: LD_INT 1
110458: ARRAY
110459: PPUSH
110460: CALL_OW 1
110464: ST_TO_ADDR
// attacking := true ;
110465: LD_ADDR_VAR 0 29
110469: PUSH
110470: LD_INT 1
110472: ST_TO_ADDR
// continue ;
110473: GO 108320
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
110475: LD_VAR 0 4
110479: PUSH
110480: LD_VAR 0 7
110484: ARRAY
110485: PPUSH
110486: CALL_OW 257
110490: PUSH
110491: LD_INT 17
110493: EQUAL
110494: PUSH
110495: LD_VAR 0 4
110499: PUSH
110500: LD_VAR 0 7
110504: ARRAY
110505: PPUSH
110506: CALL_OW 110
110510: PUSH
110511: LD_INT 71
110513: EQUAL
110514: NOT
110515: AND
110516: IFFALSE 110662
// begin attacking := false ;
110518: LD_ADDR_VAR 0 29
110522: PUSH
110523: LD_INT 0
110525: ST_TO_ADDR
// k := 5 ;
110526: LD_ADDR_VAR 0 9
110530: PUSH
110531: LD_INT 5
110533: ST_TO_ADDR
// if tmp < k then
110534: LD_VAR 0 14
110538: PUSH
110539: LD_VAR 0 9
110543: LESS
110544: IFFALSE 110556
// k := tmp ;
110546: LD_ADDR_VAR 0 9
110550: PUSH
110551: LD_VAR 0 14
110555: ST_TO_ADDR
// for j = 1 to k do
110556: LD_ADDR_VAR 0 8
110560: PUSH
110561: DOUBLE
110562: LD_INT 1
110564: DEC
110565: ST_TO_ADDR
110566: LD_VAR 0 9
110570: PUSH
110571: FOR_TO
110572: IFFALSE 110660
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
110574: LD_VAR 0 14
110578: PUSH
110579: LD_VAR 0 8
110583: ARRAY
110584: PUSH
110585: LD_VAR 0 14
110589: PPUSH
110590: LD_INT 58
110592: PUSH
110593: EMPTY
110594: LIST
110595: PPUSH
110596: CALL_OW 72
110600: IN
110601: NOT
110602: IFFALSE 110658
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110604: LD_VAR 0 4
110608: PUSH
110609: LD_VAR 0 7
110613: ARRAY
110614: PPUSH
110615: LD_VAR 0 14
110619: PUSH
110620: LD_VAR 0 8
110624: ARRAY
110625: PPUSH
110626: CALL_OW 115
// attacking := true ;
110630: LD_ADDR_VAR 0 29
110634: PUSH
110635: LD_INT 1
110637: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
110638: LD_VAR 0 4
110642: PUSH
110643: LD_VAR 0 7
110647: ARRAY
110648: PPUSH
110649: LD_INT 71
110651: PPUSH
110652: CALL_OW 109
// continue ;
110656: GO 110571
// end ; end ;
110658: GO 110571
110660: POP
110661: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
110662: LD_VAR 0 4
110666: PUSH
110667: LD_VAR 0 7
110671: ARRAY
110672: PPUSH
110673: CALL_OW 257
110677: PUSH
110678: LD_INT 8
110680: EQUAL
110681: PUSH
110682: LD_VAR 0 4
110686: PUSH
110687: LD_VAR 0 7
110691: ARRAY
110692: PPUSH
110693: CALL_OW 264
110697: PUSH
110698: LD_INT 28
110700: PUSH
110701: LD_INT 45
110703: PUSH
110704: LD_INT 7
110706: PUSH
110707: LD_INT 47
110709: PUSH
110710: EMPTY
110711: LIST
110712: LIST
110713: LIST
110714: LIST
110715: IN
110716: OR
110717: IFFALSE 110973
// begin attacking := false ;
110719: LD_ADDR_VAR 0 29
110723: PUSH
110724: LD_INT 0
110726: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
110727: LD_VAR 0 14
110731: PUSH
110732: LD_INT 1
110734: ARRAY
110735: PPUSH
110736: CALL_OW 266
110740: PUSH
110741: LD_INT 32
110743: PUSH
110744: LD_INT 31
110746: PUSH
110747: LD_INT 33
110749: PUSH
110750: LD_INT 4
110752: PUSH
110753: LD_INT 5
110755: PUSH
110756: EMPTY
110757: LIST
110758: LIST
110759: LIST
110760: LIST
110761: LIST
110762: IN
110763: IFFALSE 110949
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
110765: LD_ADDR_VAR 0 9
110769: PUSH
110770: LD_VAR 0 14
110774: PUSH
110775: LD_INT 1
110777: ARRAY
110778: PPUSH
110779: CALL_OW 266
110783: PPUSH
110784: LD_VAR 0 14
110788: PUSH
110789: LD_INT 1
110791: ARRAY
110792: PPUSH
110793: CALL_OW 250
110797: PPUSH
110798: LD_VAR 0 14
110802: PUSH
110803: LD_INT 1
110805: ARRAY
110806: PPUSH
110807: CALL_OW 251
110811: PPUSH
110812: LD_VAR 0 14
110816: PUSH
110817: LD_INT 1
110819: ARRAY
110820: PPUSH
110821: CALL_OW 254
110825: PPUSH
110826: LD_VAR 0 14
110830: PUSH
110831: LD_INT 1
110833: ARRAY
110834: PPUSH
110835: CALL_OW 248
110839: PPUSH
110840: LD_INT 0
110842: PPUSH
110843: CALL 62496 0 6
110847: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
110848: LD_ADDR_VAR 0 8
110852: PUSH
110853: LD_VAR 0 4
110857: PUSH
110858: LD_VAR 0 7
110862: ARRAY
110863: PPUSH
110864: LD_VAR 0 9
110868: PPUSH
110869: CALL 81166 0 2
110873: ST_TO_ADDR
// if j then
110874: LD_VAR 0 8
110878: IFFALSE 110947
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
110880: LD_VAR 0 8
110884: PUSH
110885: LD_INT 1
110887: ARRAY
110888: PPUSH
110889: LD_VAR 0 8
110893: PUSH
110894: LD_INT 2
110896: ARRAY
110897: PPUSH
110898: CALL_OW 488
110902: IFFALSE 110947
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
110904: LD_VAR 0 4
110908: PUSH
110909: LD_VAR 0 7
110913: ARRAY
110914: PPUSH
110915: LD_VAR 0 8
110919: PUSH
110920: LD_INT 1
110922: ARRAY
110923: PPUSH
110924: LD_VAR 0 8
110928: PUSH
110929: LD_INT 2
110931: ARRAY
110932: PPUSH
110933: CALL_OW 116
// attacking := true ;
110937: LD_ADDR_VAR 0 29
110941: PUSH
110942: LD_INT 1
110944: ST_TO_ADDR
// continue ;
110945: GO 108320
// end ; end else
110947: GO 110973
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110949: LD_VAR 0 4
110953: PUSH
110954: LD_VAR 0 7
110958: ARRAY
110959: PPUSH
110960: LD_VAR 0 14
110964: PUSH
110965: LD_INT 1
110967: ARRAY
110968: PPUSH
110969: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
110973: LD_VAR 0 4
110977: PUSH
110978: LD_VAR 0 7
110982: ARRAY
110983: PPUSH
110984: CALL_OW 265
110988: PUSH
110989: LD_INT 11
110991: EQUAL
110992: IFFALSE 111270
// begin k := 10 ;
110994: LD_ADDR_VAR 0 9
110998: PUSH
110999: LD_INT 10
111001: ST_TO_ADDR
// x := 0 ;
111002: LD_ADDR_VAR 0 10
111006: PUSH
111007: LD_INT 0
111009: ST_TO_ADDR
// if tmp < k then
111010: LD_VAR 0 14
111014: PUSH
111015: LD_VAR 0 9
111019: LESS
111020: IFFALSE 111032
// k := tmp ;
111022: LD_ADDR_VAR 0 9
111026: PUSH
111027: LD_VAR 0 14
111031: ST_TO_ADDR
// for j = k downto 1 do
111032: LD_ADDR_VAR 0 8
111036: PUSH
111037: DOUBLE
111038: LD_VAR 0 9
111042: INC
111043: ST_TO_ADDR
111044: LD_INT 1
111046: PUSH
111047: FOR_DOWNTO
111048: IFFALSE 111123
// begin if GetType ( tmp [ j ] ) = unit_human then
111050: LD_VAR 0 14
111054: PUSH
111055: LD_VAR 0 8
111059: ARRAY
111060: PPUSH
111061: CALL_OW 247
111065: PUSH
111066: LD_INT 1
111068: EQUAL
111069: IFFALSE 111121
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
111071: LD_VAR 0 4
111075: PUSH
111076: LD_VAR 0 7
111080: ARRAY
111081: PPUSH
111082: LD_VAR 0 14
111086: PUSH
111087: LD_VAR 0 8
111091: ARRAY
111092: PPUSH
111093: CALL 81437 0 2
// x := tmp [ j ] ;
111097: LD_ADDR_VAR 0 10
111101: PUSH
111102: LD_VAR 0 14
111106: PUSH
111107: LD_VAR 0 8
111111: ARRAY
111112: ST_TO_ADDR
// attacking := true ;
111113: LD_ADDR_VAR 0 29
111117: PUSH
111118: LD_INT 1
111120: ST_TO_ADDR
// end ; end ;
111121: GO 111047
111123: POP
111124: POP
// if not x then
111125: LD_VAR 0 10
111129: NOT
111130: IFFALSE 111270
// begin attacking := true ;
111132: LD_ADDR_VAR 0 29
111136: PUSH
111137: LD_INT 1
111139: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
111140: LD_VAR 0 4
111144: PUSH
111145: LD_VAR 0 7
111149: ARRAY
111150: PPUSH
111151: CALL_OW 250
111155: PPUSH
111156: LD_VAR 0 4
111160: PUSH
111161: LD_VAR 0 7
111165: ARRAY
111166: PPUSH
111167: CALL_OW 251
111171: PPUSH
111172: CALL_OW 546
111176: PUSH
111177: LD_INT 2
111179: ARRAY
111180: PUSH
111181: LD_VAR 0 14
111185: PUSH
111186: LD_INT 1
111188: ARRAY
111189: PPUSH
111190: CALL_OW 250
111194: PPUSH
111195: LD_VAR 0 14
111199: PUSH
111200: LD_INT 1
111202: ARRAY
111203: PPUSH
111204: CALL_OW 251
111208: PPUSH
111209: CALL_OW 546
111213: PUSH
111214: LD_INT 2
111216: ARRAY
111217: EQUAL
111218: IFFALSE 111246
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
111220: LD_VAR 0 4
111224: PUSH
111225: LD_VAR 0 7
111229: ARRAY
111230: PPUSH
111231: LD_VAR 0 14
111235: PUSH
111236: LD_INT 1
111238: ARRAY
111239: PPUSH
111240: CALL 81437 0 2
111244: GO 111270
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111246: LD_VAR 0 4
111250: PUSH
111251: LD_VAR 0 7
111255: ARRAY
111256: PPUSH
111257: LD_VAR 0 14
111261: PUSH
111262: LD_INT 1
111264: ARRAY
111265: PPUSH
111266: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
111270: LD_VAR 0 4
111274: PUSH
111275: LD_VAR 0 7
111279: ARRAY
111280: PPUSH
111281: CALL_OW 264
111285: PUSH
111286: LD_INT 29
111288: EQUAL
111289: IFFALSE 111655
// begin if WantsToAttack ( group [ i ] ) in bombed then
111291: LD_VAR 0 4
111295: PUSH
111296: LD_VAR 0 7
111300: ARRAY
111301: PPUSH
111302: CALL_OW 319
111306: PUSH
111307: LD_VAR 0 28
111311: IN
111312: IFFALSE 111316
// continue ;
111314: GO 108320
// k := 8 ;
111316: LD_ADDR_VAR 0 9
111320: PUSH
111321: LD_INT 8
111323: ST_TO_ADDR
// x := 0 ;
111324: LD_ADDR_VAR 0 10
111328: PUSH
111329: LD_INT 0
111331: ST_TO_ADDR
// if tmp < k then
111332: LD_VAR 0 14
111336: PUSH
111337: LD_VAR 0 9
111341: LESS
111342: IFFALSE 111354
// k := tmp ;
111344: LD_ADDR_VAR 0 9
111348: PUSH
111349: LD_VAR 0 14
111353: ST_TO_ADDR
// for j = 1 to k do
111354: LD_ADDR_VAR 0 8
111358: PUSH
111359: DOUBLE
111360: LD_INT 1
111362: DEC
111363: ST_TO_ADDR
111364: LD_VAR 0 9
111368: PUSH
111369: FOR_TO
111370: IFFALSE 111502
// begin if GetType ( tmp [ j ] ) = unit_building then
111372: LD_VAR 0 14
111376: PUSH
111377: LD_VAR 0 8
111381: ARRAY
111382: PPUSH
111383: CALL_OW 247
111387: PUSH
111388: LD_INT 3
111390: EQUAL
111391: IFFALSE 111500
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
111393: LD_VAR 0 14
111397: PUSH
111398: LD_VAR 0 8
111402: ARRAY
111403: PUSH
111404: LD_VAR 0 28
111408: IN
111409: NOT
111410: PUSH
111411: LD_VAR 0 14
111415: PUSH
111416: LD_VAR 0 8
111420: ARRAY
111421: PPUSH
111422: CALL_OW 313
111426: AND
111427: IFFALSE 111500
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111429: LD_VAR 0 4
111433: PUSH
111434: LD_VAR 0 7
111438: ARRAY
111439: PPUSH
111440: LD_VAR 0 14
111444: PUSH
111445: LD_VAR 0 8
111449: ARRAY
111450: PPUSH
111451: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
111455: LD_ADDR_VAR 0 28
111459: PUSH
111460: LD_VAR 0 28
111464: PPUSH
111465: LD_VAR 0 28
111469: PUSH
111470: LD_INT 1
111472: PLUS
111473: PPUSH
111474: LD_VAR 0 14
111478: PUSH
111479: LD_VAR 0 8
111483: ARRAY
111484: PPUSH
111485: CALL_OW 1
111489: ST_TO_ADDR
// attacking := true ;
111490: LD_ADDR_VAR 0 29
111494: PUSH
111495: LD_INT 1
111497: ST_TO_ADDR
// break ;
111498: GO 111502
// end ; end ;
111500: GO 111369
111502: POP
111503: POP
// if not attacking and f_attack_depot then
111504: LD_VAR 0 29
111508: NOT
111509: PUSH
111510: LD_VAR 0 25
111514: AND
111515: IFFALSE 111610
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111517: LD_ADDR_VAR 0 13
111521: PUSH
111522: LD_VAR 0 14
111526: PPUSH
111527: LD_INT 2
111529: PUSH
111530: LD_INT 30
111532: PUSH
111533: LD_INT 0
111535: PUSH
111536: EMPTY
111537: LIST
111538: LIST
111539: PUSH
111540: LD_INT 30
111542: PUSH
111543: LD_INT 1
111545: PUSH
111546: EMPTY
111547: LIST
111548: LIST
111549: PUSH
111550: EMPTY
111551: LIST
111552: LIST
111553: LIST
111554: PPUSH
111555: CALL_OW 72
111559: ST_TO_ADDR
// if z then
111560: LD_VAR 0 13
111564: IFFALSE 111610
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
111566: LD_VAR 0 4
111570: PUSH
111571: LD_VAR 0 7
111575: ARRAY
111576: PPUSH
111577: LD_VAR 0 13
111581: PPUSH
111582: LD_VAR 0 4
111586: PUSH
111587: LD_VAR 0 7
111591: ARRAY
111592: PPUSH
111593: CALL_OW 74
111597: PPUSH
111598: CALL_OW 115
// attacking := true ;
111602: LD_ADDR_VAR 0 29
111606: PUSH
111607: LD_INT 1
111609: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
111610: LD_VAR 0 4
111614: PUSH
111615: LD_VAR 0 7
111619: ARRAY
111620: PPUSH
111621: CALL_OW 256
111625: PUSH
111626: LD_INT 500
111628: LESS
111629: IFFALSE 111655
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111631: LD_VAR 0 4
111635: PUSH
111636: LD_VAR 0 7
111640: ARRAY
111641: PPUSH
111642: LD_VAR 0 14
111646: PUSH
111647: LD_INT 1
111649: ARRAY
111650: PPUSH
111651: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
111655: LD_VAR 0 4
111659: PUSH
111660: LD_VAR 0 7
111664: ARRAY
111665: PPUSH
111666: CALL_OW 264
111670: PUSH
111671: LD_INT 49
111673: EQUAL
111674: IFFALSE 111795
// begin if not HasTask ( group [ i ] ) then
111676: LD_VAR 0 4
111680: PUSH
111681: LD_VAR 0 7
111685: ARRAY
111686: PPUSH
111687: CALL_OW 314
111691: NOT
111692: IFFALSE 111795
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
111694: LD_ADDR_VAR 0 9
111698: PUSH
111699: LD_INT 81
111701: PUSH
111702: LD_VAR 0 4
111706: PUSH
111707: LD_VAR 0 7
111711: ARRAY
111712: PPUSH
111713: CALL_OW 255
111717: PUSH
111718: EMPTY
111719: LIST
111720: LIST
111721: PPUSH
111722: CALL_OW 69
111726: PPUSH
111727: LD_VAR 0 4
111731: PUSH
111732: LD_VAR 0 7
111736: ARRAY
111737: PPUSH
111738: CALL_OW 74
111742: ST_TO_ADDR
// if k then
111743: LD_VAR 0 9
111747: IFFALSE 111795
// if GetDistUnits ( group [ i ] , k ) > 10 then
111749: LD_VAR 0 4
111753: PUSH
111754: LD_VAR 0 7
111758: ARRAY
111759: PPUSH
111760: LD_VAR 0 9
111764: PPUSH
111765: CALL_OW 296
111769: PUSH
111770: LD_INT 10
111772: GREATER
111773: IFFALSE 111795
// ComMoveUnit ( group [ i ] , k ) ;
111775: LD_VAR 0 4
111779: PUSH
111780: LD_VAR 0 7
111784: ARRAY
111785: PPUSH
111786: LD_VAR 0 9
111790: PPUSH
111791: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
111795: LD_VAR 0 4
111799: PUSH
111800: LD_VAR 0 7
111804: ARRAY
111805: PPUSH
111806: CALL_OW 256
111810: PUSH
111811: LD_INT 250
111813: LESS
111814: PUSH
111815: LD_VAR 0 4
111819: PUSH
111820: LD_VAR 0 7
111824: ARRAY
111825: PUSH
111826: LD_INT 21
111828: PUSH
111829: LD_INT 2
111831: PUSH
111832: EMPTY
111833: LIST
111834: LIST
111835: PUSH
111836: LD_INT 23
111838: PUSH
111839: LD_INT 2
111841: PUSH
111842: EMPTY
111843: LIST
111844: LIST
111845: PUSH
111846: EMPTY
111847: LIST
111848: LIST
111849: PPUSH
111850: CALL_OW 69
111854: IN
111855: AND
111856: IFFALSE 111981
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
111858: LD_ADDR_VAR 0 9
111862: PUSH
111863: LD_OWVAR 3
111867: PUSH
111868: LD_VAR 0 4
111872: PUSH
111873: LD_VAR 0 7
111877: ARRAY
111878: DIFF
111879: PPUSH
111880: LD_VAR 0 4
111884: PUSH
111885: LD_VAR 0 7
111889: ARRAY
111890: PPUSH
111891: CALL_OW 74
111895: ST_TO_ADDR
// if not k then
111896: LD_VAR 0 9
111900: NOT
111901: IFFALSE 111905
// continue ;
111903: GO 108320
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
111905: LD_VAR 0 9
111909: PUSH
111910: LD_INT 81
111912: PUSH
111913: LD_VAR 0 4
111917: PUSH
111918: LD_VAR 0 7
111922: ARRAY
111923: PPUSH
111924: CALL_OW 255
111928: PUSH
111929: EMPTY
111930: LIST
111931: LIST
111932: PPUSH
111933: CALL_OW 69
111937: IN
111938: PUSH
111939: LD_VAR 0 9
111943: PPUSH
111944: LD_VAR 0 4
111948: PUSH
111949: LD_VAR 0 7
111953: ARRAY
111954: PPUSH
111955: CALL_OW 296
111959: PUSH
111960: LD_INT 5
111962: LESS
111963: AND
111964: IFFALSE 111981
// ComAutodestruct ( group [ i ] ) ;
111966: LD_VAR 0 4
111970: PUSH
111971: LD_VAR 0 7
111975: ARRAY
111976: PPUSH
111977: CALL 81335 0 1
// end ; if f_attack_depot then
111981: LD_VAR 0 25
111985: IFFALSE 112097
// begin k := 6 ;
111987: LD_ADDR_VAR 0 9
111991: PUSH
111992: LD_INT 6
111994: ST_TO_ADDR
// if tmp < k then
111995: LD_VAR 0 14
111999: PUSH
112000: LD_VAR 0 9
112004: LESS
112005: IFFALSE 112017
// k := tmp ;
112007: LD_ADDR_VAR 0 9
112011: PUSH
112012: LD_VAR 0 14
112016: ST_TO_ADDR
// for j = 1 to k do
112017: LD_ADDR_VAR 0 8
112021: PUSH
112022: DOUBLE
112023: LD_INT 1
112025: DEC
112026: ST_TO_ADDR
112027: LD_VAR 0 9
112031: PUSH
112032: FOR_TO
112033: IFFALSE 112095
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
112035: LD_VAR 0 8
112039: PPUSH
112040: CALL_OW 266
112044: PUSH
112045: LD_INT 0
112047: PUSH
112048: LD_INT 1
112050: PUSH
112051: EMPTY
112052: LIST
112053: LIST
112054: IN
112055: IFFALSE 112093
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112057: LD_VAR 0 4
112061: PUSH
112062: LD_VAR 0 7
112066: ARRAY
112067: PPUSH
112068: LD_VAR 0 14
112072: PUSH
112073: LD_VAR 0 8
112077: ARRAY
112078: PPUSH
112079: CALL_OW 115
// attacking := true ;
112083: LD_ADDR_VAR 0 29
112087: PUSH
112088: LD_INT 1
112090: ST_TO_ADDR
// break ;
112091: GO 112095
// end ;
112093: GO 112032
112095: POP
112096: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
112097: LD_VAR 0 4
112101: PUSH
112102: LD_VAR 0 7
112106: ARRAY
112107: PPUSH
112108: CALL_OW 302
112112: PUSH
112113: LD_VAR 0 29
112117: NOT
112118: AND
112119: IFFALSE 112441
// begin if GetTag ( group [ i ] ) = 71 then
112121: LD_VAR 0 4
112125: PUSH
112126: LD_VAR 0 7
112130: ARRAY
112131: PPUSH
112132: CALL_OW 110
112136: PUSH
112137: LD_INT 71
112139: EQUAL
112140: IFFALSE 112181
// begin if HasTask ( group [ i ] ) then
112142: LD_VAR 0 4
112146: PUSH
112147: LD_VAR 0 7
112151: ARRAY
112152: PPUSH
112153: CALL_OW 314
112157: IFFALSE 112163
// continue else
112159: GO 108320
112161: GO 112181
// SetTag ( group [ i ] , 0 ) ;
112163: LD_VAR 0 4
112167: PUSH
112168: LD_VAR 0 7
112172: ARRAY
112173: PPUSH
112174: LD_INT 0
112176: PPUSH
112177: CALL_OW 109
// end ; k := 8 ;
112181: LD_ADDR_VAR 0 9
112185: PUSH
112186: LD_INT 8
112188: ST_TO_ADDR
// x := 0 ;
112189: LD_ADDR_VAR 0 10
112193: PUSH
112194: LD_INT 0
112196: ST_TO_ADDR
// if tmp < k then
112197: LD_VAR 0 14
112201: PUSH
112202: LD_VAR 0 9
112206: LESS
112207: IFFALSE 112219
// k := tmp ;
112209: LD_ADDR_VAR 0 9
112213: PUSH
112214: LD_VAR 0 14
112218: ST_TO_ADDR
// for j = 1 to k do
112219: LD_ADDR_VAR 0 8
112223: PUSH
112224: DOUBLE
112225: LD_INT 1
112227: DEC
112228: ST_TO_ADDR
112229: LD_VAR 0 9
112233: PUSH
112234: FOR_TO
112235: IFFALSE 112333
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
112237: LD_VAR 0 14
112241: PUSH
112242: LD_VAR 0 8
112246: ARRAY
112247: PPUSH
112248: CALL_OW 247
112252: PUSH
112253: LD_INT 1
112255: EQUAL
112256: PUSH
112257: LD_VAR 0 14
112261: PUSH
112262: LD_VAR 0 8
112266: ARRAY
112267: PPUSH
112268: CALL_OW 256
112272: PUSH
112273: LD_INT 250
112275: LESS
112276: PUSH
112277: LD_VAR 0 20
112281: AND
112282: PUSH
112283: LD_VAR 0 20
112287: NOT
112288: PUSH
112289: LD_VAR 0 14
112293: PUSH
112294: LD_VAR 0 8
112298: ARRAY
112299: PPUSH
112300: CALL_OW 256
112304: PUSH
112305: LD_INT 250
112307: GREATEREQUAL
112308: AND
112309: OR
112310: AND
112311: IFFALSE 112331
// begin x := tmp [ j ] ;
112313: LD_ADDR_VAR 0 10
112317: PUSH
112318: LD_VAR 0 14
112322: PUSH
112323: LD_VAR 0 8
112327: ARRAY
112328: ST_TO_ADDR
// break ;
112329: GO 112333
// end ;
112331: GO 112234
112333: POP
112334: POP
// if x then
112335: LD_VAR 0 10
112339: IFFALSE 112363
// ComAttackUnit ( group [ i ] , x ) else
112341: LD_VAR 0 4
112345: PUSH
112346: LD_VAR 0 7
112350: ARRAY
112351: PPUSH
112352: LD_VAR 0 10
112356: PPUSH
112357: CALL_OW 115
112361: GO 112387
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112363: LD_VAR 0 4
112367: PUSH
112368: LD_VAR 0 7
112372: ARRAY
112373: PPUSH
112374: LD_VAR 0 14
112378: PUSH
112379: LD_INT 1
112381: ARRAY
112382: PPUSH
112383: CALL_OW 115
// if not HasTask ( group [ i ] ) then
112387: LD_VAR 0 4
112391: PUSH
112392: LD_VAR 0 7
112396: ARRAY
112397: PPUSH
112398: CALL_OW 314
112402: NOT
112403: IFFALSE 112441
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
112405: LD_VAR 0 4
112409: PUSH
112410: LD_VAR 0 7
112414: ARRAY
112415: PPUSH
112416: LD_VAR 0 14
112420: PPUSH
112421: LD_VAR 0 4
112425: PUSH
112426: LD_VAR 0 7
112430: ARRAY
112431: PPUSH
112432: CALL_OW 74
112436: PPUSH
112437: CALL_OW 115
// end ; end ; end ;
112441: GO 108320
112443: POP
112444: POP
// wait ( 0 0$2 ) ;
112445: LD_INT 70
112447: PPUSH
112448: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
112452: LD_VAR 0 4
112456: NOT
112457: PUSH
112458: LD_VAR 0 4
112462: PUSH
112463: EMPTY
112464: EQUAL
112465: OR
112466: PUSH
112467: LD_INT 81
112469: PUSH
112470: LD_VAR 0 35
112474: PUSH
112475: EMPTY
112476: LIST
112477: LIST
112478: PPUSH
112479: CALL_OW 69
112483: NOT
112484: OR
112485: IFFALSE 108305
// end ;
112487: LD_VAR 0 2
112491: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
112492: LD_INT 0
112494: PPUSH
112495: PPUSH
112496: PPUSH
112497: PPUSH
112498: PPUSH
112499: PPUSH
// if not base or not mc_bases [ base ] or not solds then
112500: LD_VAR 0 1
112504: NOT
112505: PUSH
112506: LD_EXP 50
112510: PUSH
112511: LD_VAR 0 1
112515: ARRAY
112516: NOT
112517: OR
112518: PUSH
112519: LD_VAR 0 2
112523: NOT
112524: OR
112525: IFFALSE 112529
// exit ;
112527: GO 113083
// side := mc_sides [ base ] ;
112529: LD_ADDR_VAR 0 6
112533: PUSH
112534: LD_EXP 76
112538: PUSH
112539: LD_VAR 0 1
112543: ARRAY
112544: ST_TO_ADDR
// if not side then
112545: LD_VAR 0 6
112549: NOT
112550: IFFALSE 112554
// exit ;
112552: GO 113083
// for i in solds do
112554: LD_ADDR_VAR 0 7
112558: PUSH
112559: LD_VAR 0 2
112563: PUSH
112564: FOR_IN
112565: IFFALSE 112626
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
112567: LD_VAR 0 7
112571: PPUSH
112572: CALL_OW 310
112576: PPUSH
112577: CALL_OW 266
112581: PUSH
112582: LD_INT 32
112584: PUSH
112585: LD_INT 31
112587: PUSH
112588: EMPTY
112589: LIST
112590: LIST
112591: IN
112592: IFFALSE 112612
// solds := solds diff i else
112594: LD_ADDR_VAR 0 2
112598: PUSH
112599: LD_VAR 0 2
112603: PUSH
112604: LD_VAR 0 7
112608: DIFF
112609: ST_TO_ADDR
112610: GO 112624
// SetTag ( i , 18 ) ;
112612: LD_VAR 0 7
112616: PPUSH
112617: LD_INT 18
112619: PPUSH
112620: CALL_OW 109
112624: GO 112564
112626: POP
112627: POP
// if not solds then
112628: LD_VAR 0 2
112632: NOT
112633: IFFALSE 112637
// exit ;
112635: GO 113083
// repeat wait ( 0 0$2 ) ;
112637: LD_INT 70
112639: PPUSH
112640: CALL_OW 67
// enemy := mc_scan [ base ] ;
112644: LD_ADDR_VAR 0 4
112648: PUSH
112649: LD_EXP 73
112653: PUSH
112654: LD_VAR 0 1
112658: ARRAY
112659: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112660: LD_EXP 50
112664: PUSH
112665: LD_VAR 0 1
112669: ARRAY
112670: NOT
112671: PUSH
112672: LD_EXP 50
112676: PUSH
112677: LD_VAR 0 1
112681: ARRAY
112682: PUSH
112683: EMPTY
112684: EQUAL
112685: OR
112686: IFFALSE 112723
// begin for i in solds do
112688: LD_ADDR_VAR 0 7
112692: PUSH
112693: LD_VAR 0 2
112697: PUSH
112698: FOR_IN
112699: IFFALSE 112712
// ComStop ( i ) ;
112701: LD_VAR 0 7
112705: PPUSH
112706: CALL_OW 141
112710: GO 112698
112712: POP
112713: POP
// solds := [ ] ;
112714: LD_ADDR_VAR 0 2
112718: PUSH
112719: EMPTY
112720: ST_TO_ADDR
// exit ;
112721: GO 113083
// end ; for i in solds do
112723: LD_ADDR_VAR 0 7
112727: PUSH
112728: LD_VAR 0 2
112732: PUSH
112733: FOR_IN
112734: IFFALSE 113055
// begin if IsInUnit ( i ) then
112736: LD_VAR 0 7
112740: PPUSH
112741: CALL_OW 310
112745: IFFALSE 112756
// ComExitBuilding ( i ) ;
112747: LD_VAR 0 7
112751: PPUSH
112752: CALL_OW 122
// if GetLives ( i ) > 500 then
112756: LD_VAR 0 7
112760: PPUSH
112761: CALL_OW 256
112765: PUSH
112766: LD_INT 500
112768: GREATER
112769: IFFALSE 112822
// begin e := NearestUnitToUnit ( enemy , i ) ;
112771: LD_ADDR_VAR 0 5
112775: PUSH
112776: LD_VAR 0 4
112780: PPUSH
112781: LD_VAR 0 7
112785: PPUSH
112786: CALL_OW 74
112790: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
112791: LD_VAR 0 7
112795: PPUSH
112796: LD_VAR 0 5
112800: PPUSH
112801: CALL_OW 250
112805: PPUSH
112806: LD_VAR 0 5
112810: PPUSH
112811: CALL_OW 251
112815: PPUSH
112816: CALL_OW 114
// end else
112820: GO 113053
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
112822: LD_VAR 0 7
112826: PPUSH
112827: LD_EXP 50
112831: PUSH
112832: LD_VAR 0 1
112836: ARRAY
112837: PPUSH
112838: LD_INT 2
112840: PUSH
112841: LD_INT 30
112843: PUSH
112844: LD_INT 0
112846: PUSH
112847: EMPTY
112848: LIST
112849: LIST
112850: PUSH
112851: LD_INT 30
112853: PUSH
112854: LD_INT 1
112856: PUSH
112857: EMPTY
112858: LIST
112859: LIST
112860: PUSH
112861: LD_INT 30
112863: PUSH
112864: LD_INT 6
112866: PUSH
112867: EMPTY
112868: LIST
112869: LIST
112870: PUSH
112871: EMPTY
112872: LIST
112873: LIST
112874: LIST
112875: LIST
112876: PPUSH
112877: CALL_OW 72
112881: PPUSH
112882: LD_VAR 0 7
112886: PPUSH
112887: CALL_OW 74
112891: PPUSH
112892: CALL_OW 296
112896: PUSH
112897: LD_INT 10
112899: GREATER
112900: IFFALSE 113053
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
112902: LD_ADDR_VAR 0 8
112906: PUSH
112907: LD_EXP 50
112911: PUSH
112912: LD_VAR 0 1
112916: ARRAY
112917: PPUSH
112918: LD_INT 2
112920: PUSH
112921: LD_INT 30
112923: PUSH
112924: LD_INT 0
112926: PUSH
112927: EMPTY
112928: LIST
112929: LIST
112930: PUSH
112931: LD_INT 30
112933: PUSH
112934: LD_INT 1
112936: PUSH
112937: EMPTY
112938: LIST
112939: LIST
112940: PUSH
112941: LD_INT 30
112943: PUSH
112944: LD_INT 6
112946: PUSH
112947: EMPTY
112948: LIST
112949: LIST
112950: PUSH
112951: EMPTY
112952: LIST
112953: LIST
112954: LIST
112955: LIST
112956: PPUSH
112957: CALL_OW 72
112961: PPUSH
112962: LD_VAR 0 7
112966: PPUSH
112967: CALL_OW 74
112971: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
112972: LD_VAR 0 7
112976: PPUSH
112977: LD_VAR 0 8
112981: PPUSH
112982: CALL_OW 250
112986: PPUSH
112987: LD_INT 3
112989: PPUSH
112990: LD_INT 5
112992: PPUSH
112993: CALL_OW 272
112997: PPUSH
112998: LD_VAR 0 8
113002: PPUSH
113003: CALL_OW 251
113007: PPUSH
113008: LD_INT 3
113010: PPUSH
113011: LD_INT 5
113013: PPUSH
113014: CALL_OW 273
113018: PPUSH
113019: CALL_OW 111
// SetTag ( i , 0 ) ;
113023: LD_VAR 0 7
113027: PPUSH
113028: LD_INT 0
113030: PPUSH
113031: CALL_OW 109
// solds := solds diff i ;
113035: LD_ADDR_VAR 0 2
113039: PUSH
113040: LD_VAR 0 2
113044: PUSH
113045: LD_VAR 0 7
113049: DIFF
113050: ST_TO_ADDR
// continue ;
113051: GO 112733
// end ; end ;
113053: GO 112733
113055: POP
113056: POP
// until not solds or not enemy ;
113057: LD_VAR 0 2
113061: NOT
113062: PUSH
113063: LD_VAR 0 4
113067: NOT
113068: OR
113069: IFFALSE 112637
// MC_Reset ( base , 18 ) ;
113071: LD_VAR 0 1
113075: PPUSH
113076: LD_INT 18
113078: PPUSH
113079: CALL 22083 0 2
// end ;
113083: LD_VAR 0 3
113087: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
113088: LD_INT 0
113090: PPUSH
113091: PPUSH
113092: PPUSH
113093: PPUSH
113094: PPUSH
113095: PPUSH
113096: PPUSH
113097: PPUSH
113098: PPUSH
113099: PPUSH
113100: PPUSH
113101: PPUSH
113102: PPUSH
113103: PPUSH
113104: PPUSH
113105: PPUSH
113106: PPUSH
113107: PPUSH
113108: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
113109: LD_ADDR_VAR 0 12
113113: PUSH
113114: LD_EXP 50
113118: PUSH
113119: LD_VAR 0 1
113123: ARRAY
113124: PPUSH
113125: LD_INT 25
113127: PUSH
113128: LD_INT 3
113130: PUSH
113131: EMPTY
113132: LIST
113133: LIST
113134: PPUSH
113135: CALL_OW 72
113139: ST_TO_ADDR
// if mc_remote_driver [ base ] then
113140: LD_EXP 90
113144: PUSH
113145: LD_VAR 0 1
113149: ARRAY
113150: IFFALSE 113174
// mechs := mechs diff mc_remote_driver [ base ] ;
113152: LD_ADDR_VAR 0 12
113156: PUSH
113157: LD_VAR 0 12
113161: PUSH
113162: LD_EXP 90
113166: PUSH
113167: LD_VAR 0 1
113171: ARRAY
113172: DIFF
113173: ST_TO_ADDR
// for i in mechs do
113174: LD_ADDR_VAR 0 4
113178: PUSH
113179: LD_VAR 0 12
113183: PUSH
113184: FOR_IN
113185: IFFALSE 113220
// if GetTag ( i ) > 0 then
113187: LD_VAR 0 4
113191: PPUSH
113192: CALL_OW 110
113196: PUSH
113197: LD_INT 0
113199: GREATER
113200: IFFALSE 113218
// mechs := mechs diff i ;
113202: LD_ADDR_VAR 0 12
113206: PUSH
113207: LD_VAR 0 12
113211: PUSH
113212: LD_VAR 0 4
113216: DIFF
113217: ST_TO_ADDR
113218: GO 113184
113220: POP
113221: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113222: LD_ADDR_VAR 0 8
113226: PUSH
113227: LD_EXP 50
113231: PUSH
113232: LD_VAR 0 1
113236: ARRAY
113237: PPUSH
113238: LD_INT 2
113240: PUSH
113241: LD_INT 25
113243: PUSH
113244: LD_INT 1
113246: PUSH
113247: EMPTY
113248: LIST
113249: LIST
113250: PUSH
113251: LD_INT 25
113253: PUSH
113254: LD_INT 5
113256: PUSH
113257: EMPTY
113258: LIST
113259: LIST
113260: PUSH
113261: LD_INT 25
113263: PUSH
113264: LD_INT 8
113266: PUSH
113267: EMPTY
113268: LIST
113269: LIST
113270: PUSH
113271: LD_INT 25
113273: PUSH
113274: LD_INT 9
113276: PUSH
113277: EMPTY
113278: LIST
113279: LIST
113280: PUSH
113281: EMPTY
113282: LIST
113283: LIST
113284: LIST
113285: LIST
113286: LIST
113287: PPUSH
113288: CALL_OW 72
113292: ST_TO_ADDR
// if not defenders and not solds then
113293: LD_VAR 0 2
113297: NOT
113298: PUSH
113299: LD_VAR 0 8
113303: NOT
113304: AND
113305: IFFALSE 113309
// exit ;
113307: GO 115079
// depot_under_attack := false ;
113309: LD_ADDR_VAR 0 16
113313: PUSH
113314: LD_INT 0
113316: ST_TO_ADDR
// sold_defenders := [ ] ;
113317: LD_ADDR_VAR 0 17
113321: PUSH
113322: EMPTY
113323: ST_TO_ADDR
// if mechs then
113324: LD_VAR 0 12
113328: IFFALSE 113481
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
113330: LD_ADDR_VAR 0 4
113334: PUSH
113335: LD_VAR 0 2
113339: PPUSH
113340: LD_INT 21
113342: PUSH
113343: LD_INT 2
113345: PUSH
113346: EMPTY
113347: LIST
113348: LIST
113349: PPUSH
113350: CALL_OW 72
113354: PUSH
113355: FOR_IN
113356: IFFALSE 113479
// begin if GetTag ( i ) <> 20 then
113358: LD_VAR 0 4
113362: PPUSH
113363: CALL_OW 110
113367: PUSH
113368: LD_INT 20
113370: NONEQUAL
113371: IFFALSE 113385
// SetTag ( i , 20 ) ;
113373: LD_VAR 0 4
113377: PPUSH
113378: LD_INT 20
113380: PPUSH
113381: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
113385: LD_VAR 0 4
113389: PPUSH
113390: CALL_OW 263
113394: PUSH
113395: LD_INT 1
113397: EQUAL
113398: PUSH
113399: LD_VAR 0 4
113403: PPUSH
113404: CALL_OW 311
113408: NOT
113409: AND
113410: IFFALSE 113477
// begin un := mechs [ 1 ] ;
113412: LD_ADDR_VAR 0 10
113416: PUSH
113417: LD_VAR 0 12
113421: PUSH
113422: LD_INT 1
113424: ARRAY
113425: ST_TO_ADDR
// ComExit ( un ) ;
113426: LD_VAR 0 10
113430: PPUSH
113431: CALL 85680 0 1
// AddComEnterUnit ( un , i ) ;
113435: LD_VAR 0 10
113439: PPUSH
113440: LD_VAR 0 4
113444: PPUSH
113445: CALL_OW 180
// SetTag ( un , 19 ) ;
113449: LD_VAR 0 10
113453: PPUSH
113454: LD_INT 19
113456: PPUSH
113457: CALL_OW 109
// mechs := mechs diff un ;
113461: LD_ADDR_VAR 0 12
113465: PUSH
113466: LD_VAR 0 12
113470: PUSH
113471: LD_VAR 0 10
113475: DIFF
113476: ST_TO_ADDR
// end ; end ;
113477: GO 113355
113479: POP
113480: POP
// if solds then
113481: LD_VAR 0 8
113485: IFFALSE 113544
// for i in solds do
113487: LD_ADDR_VAR 0 4
113491: PUSH
113492: LD_VAR 0 8
113496: PUSH
113497: FOR_IN
113498: IFFALSE 113542
// if not GetTag ( i ) then
113500: LD_VAR 0 4
113504: PPUSH
113505: CALL_OW 110
113509: NOT
113510: IFFALSE 113540
// begin defenders := defenders union i ;
113512: LD_ADDR_VAR 0 2
113516: PUSH
113517: LD_VAR 0 2
113521: PUSH
113522: LD_VAR 0 4
113526: UNION
113527: ST_TO_ADDR
// SetTag ( i , 18 ) ;
113528: LD_VAR 0 4
113532: PPUSH
113533: LD_INT 18
113535: PPUSH
113536: CALL_OW 109
// end ;
113540: GO 113497
113542: POP
113543: POP
// repeat wait ( 0 0$2 ) ;
113544: LD_INT 70
113546: PPUSH
113547: CALL_OW 67
// enemy := mc_scan [ base ] ;
113551: LD_ADDR_VAR 0 21
113555: PUSH
113556: LD_EXP 73
113560: PUSH
113561: LD_VAR 0 1
113565: ARRAY
113566: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113567: LD_EXP 50
113571: PUSH
113572: LD_VAR 0 1
113576: ARRAY
113577: NOT
113578: PUSH
113579: LD_EXP 50
113583: PUSH
113584: LD_VAR 0 1
113588: ARRAY
113589: PUSH
113590: EMPTY
113591: EQUAL
113592: OR
113593: IFFALSE 113630
// begin for i in defenders do
113595: LD_ADDR_VAR 0 4
113599: PUSH
113600: LD_VAR 0 2
113604: PUSH
113605: FOR_IN
113606: IFFALSE 113619
// ComStop ( i ) ;
113608: LD_VAR 0 4
113612: PPUSH
113613: CALL_OW 141
113617: GO 113605
113619: POP
113620: POP
// defenders := [ ] ;
113621: LD_ADDR_VAR 0 2
113625: PUSH
113626: EMPTY
113627: ST_TO_ADDR
// exit ;
113628: GO 115079
// end ; for i in defenders do
113630: LD_ADDR_VAR 0 4
113634: PUSH
113635: LD_VAR 0 2
113639: PUSH
113640: FOR_IN
113641: IFFALSE 114539
// begin e := NearestUnitToUnit ( enemy , i ) ;
113643: LD_ADDR_VAR 0 13
113647: PUSH
113648: LD_VAR 0 21
113652: PPUSH
113653: LD_VAR 0 4
113657: PPUSH
113658: CALL_OW 74
113662: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113663: LD_ADDR_VAR 0 7
113667: PUSH
113668: LD_EXP 50
113672: PUSH
113673: LD_VAR 0 1
113677: ARRAY
113678: PPUSH
113679: LD_INT 2
113681: PUSH
113682: LD_INT 30
113684: PUSH
113685: LD_INT 0
113687: PUSH
113688: EMPTY
113689: LIST
113690: LIST
113691: PUSH
113692: LD_INT 30
113694: PUSH
113695: LD_INT 1
113697: PUSH
113698: EMPTY
113699: LIST
113700: LIST
113701: PUSH
113702: EMPTY
113703: LIST
113704: LIST
113705: LIST
113706: PPUSH
113707: CALL_OW 72
113711: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
113712: LD_ADDR_VAR 0 16
113716: PUSH
113717: LD_VAR 0 7
113721: NOT
113722: PUSH
113723: LD_VAR 0 7
113727: PPUSH
113728: LD_INT 3
113730: PUSH
113731: LD_INT 24
113733: PUSH
113734: LD_INT 600
113736: PUSH
113737: EMPTY
113738: LIST
113739: LIST
113740: PUSH
113741: EMPTY
113742: LIST
113743: LIST
113744: PPUSH
113745: CALL_OW 72
113749: OR
113750: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
113751: LD_VAR 0 4
113755: PPUSH
113756: CALL_OW 247
113760: PUSH
113761: LD_INT 2
113763: DOUBLE
113764: EQUAL
113765: IFTRUE 113769
113767: GO 114165
113769: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
113770: LD_VAR 0 4
113774: PPUSH
113775: CALL_OW 256
113779: PUSH
113780: LD_INT 1000
113782: EQUAL
113783: PUSH
113784: LD_VAR 0 4
113788: PPUSH
113789: LD_VAR 0 13
113793: PPUSH
113794: CALL_OW 296
113798: PUSH
113799: LD_INT 40
113801: LESS
113802: PUSH
113803: LD_VAR 0 13
113807: PPUSH
113808: LD_EXP 75
113812: PUSH
113813: LD_VAR 0 1
113817: ARRAY
113818: PPUSH
113819: CALL_OW 308
113823: OR
113824: AND
113825: IFFALSE 113947
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
113827: LD_VAR 0 4
113831: PPUSH
113832: CALL_OW 262
113836: PUSH
113837: LD_INT 1
113839: EQUAL
113840: PUSH
113841: LD_VAR 0 4
113845: PPUSH
113846: CALL_OW 261
113850: PUSH
113851: LD_INT 30
113853: LESS
113854: AND
113855: PUSH
113856: LD_VAR 0 7
113860: AND
113861: IFFALSE 113931
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
113863: LD_VAR 0 4
113867: PPUSH
113868: LD_VAR 0 7
113872: PPUSH
113873: LD_VAR 0 4
113877: PPUSH
113878: CALL_OW 74
113882: PPUSH
113883: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
113887: LD_VAR 0 4
113891: PPUSH
113892: LD_VAR 0 7
113896: PPUSH
113897: LD_VAR 0 4
113901: PPUSH
113902: CALL_OW 74
113906: PPUSH
113907: CALL_OW 296
113911: PUSH
113912: LD_INT 6
113914: LESS
113915: IFFALSE 113929
// SetFuel ( i , 100 ) ;
113917: LD_VAR 0 4
113921: PPUSH
113922: LD_INT 100
113924: PPUSH
113925: CALL_OW 240
// end else
113929: GO 113945
// ComAttackUnit ( i , e ) ;
113931: LD_VAR 0 4
113935: PPUSH
113936: LD_VAR 0 13
113940: PPUSH
113941: CALL_OW 115
// end else
113945: GO 114048
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
113947: LD_VAR 0 13
113951: PPUSH
113952: LD_EXP 75
113956: PUSH
113957: LD_VAR 0 1
113961: ARRAY
113962: PPUSH
113963: CALL_OW 308
113967: NOT
113968: PUSH
113969: LD_VAR 0 4
113973: PPUSH
113974: LD_VAR 0 13
113978: PPUSH
113979: CALL_OW 296
113983: PUSH
113984: LD_INT 40
113986: GREATEREQUAL
113987: AND
113988: PUSH
113989: LD_VAR 0 4
113993: PPUSH
113994: CALL_OW 256
113998: PUSH
113999: LD_INT 650
114001: LESSEQUAL
114002: OR
114003: PUSH
114004: LD_VAR 0 4
114008: PPUSH
114009: LD_EXP 74
114013: PUSH
114014: LD_VAR 0 1
114018: ARRAY
114019: PPUSH
114020: CALL_OW 308
114024: NOT
114025: AND
114026: IFFALSE 114048
// ComMoveToArea ( i , mc_parking [ base ] ) ;
114028: LD_VAR 0 4
114032: PPUSH
114033: LD_EXP 74
114037: PUSH
114038: LD_VAR 0 1
114042: ARRAY
114043: PPUSH
114044: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
114048: LD_VAR 0 4
114052: PPUSH
114053: CALL_OW 256
114057: PUSH
114058: LD_INT 1000
114060: LESS
114061: PUSH
114062: LD_VAR 0 4
114066: PPUSH
114067: CALL_OW 263
114071: PUSH
114072: LD_INT 1
114074: EQUAL
114075: AND
114076: PUSH
114077: LD_VAR 0 4
114081: PPUSH
114082: CALL_OW 311
114086: AND
114087: PUSH
114088: LD_VAR 0 4
114092: PPUSH
114093: LD_EXP 74
114097: PUSH
114098: LD_VAR 0 1
114102: ARRAY
114103: PPUSH
114104: CALL_OW 308
114108: AND
114109: IFFALSE 114163
// begin mech := IsDrivenBy ( i ) ;
114111: LD_ADDR_VAR 0 9
114115: PUSH
114116: LD_VAR 0 4
114120: PPUSH
114121: CALL_OW 311
114125: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
114126: LD_VAR 0 9
114130: PPUSH
114131: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
114135: LD_VAR 0 9
114139: PPUSH
114140: LD_VAR 0 4
114144: PPUSH
114145: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
114149: LD_VAR 0 9
114153: PPUSH
114154: LD_VAR 0 4
114158: PPUSH
114159: CALL_OW 180
// end ; end ; unit_human :
114163: GO 114510
114165: LD_INT 1
114167: DOUBLE
114168: EQUAL
114169: IFTRUE 114173
114171: GO 114509
114173: POP
// begin b := IsInUnit ( i ) ;
114174: LD_ADDR_VAR 0 18
114178: PUSH
114179: LD_VAR 0 4
114183: PPUSH
114184: CALL_OW 310
114188: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
114189: LD_ADDR_VAR 0 19
114193: PUSH
114194: LD_VAR 0 18
114198: NOT
114199: PUSH
114200: LD_VAR 0 18
114204: PPUSH
114205: CALL_OW 266
114209: PUSH
114210: LD_INT 32
114212: PUSH
114213: LD_INT 31
114215: PUSH
114216: EMPTY
114217: LIST
114218: LIST
114219: IN
114220: OR
114221: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
114222: LD_VAR 0 18
114226: PPUSH
114227: CALL_OW 266
114231: PUSH
114232: LD_INT 5
114234: EQUAL
114235: PUSH
114236: LD_VAR 0 4
114240: PPUSH
114241: CALL_OW 257
114245: PUSH
114246: LD_INT 1
114248: PUSH
114249: LD_INT 2
114251: PUSH
114252: LD_INT 3
114254: PUSH
114255: LD_INT 4
114257: PUSH
114258: EMPTY
114259: LIST
114260: LIST
114261: LIST
114262: LIST
114263: IN
114264: AND
114265: IFFALSE 114302
// begin class := AllowSpecClass ( i ) ;
114267: LD_ADDR_VAR 0 20
114271: PUSH
114272: LD_VAR 0 4
114276: PPUSH
114277: CALL 50341 0 1
114281: ST_TO_ADDR
// if class then
114282: LD_VAR 0 20
114286: IFFALSE 114302
// ComChangeProfession ( i , class ) ;
114288: LD_VAR 0 4
114292: PPUSH
114293: LD_VAR 0 20
114297: PPUSH
114298: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
114302: LD_VAR 0 16
114306: PUSH
114307: LD_VAR 0 2
114311: PPUSH
114312: LD_INT 21
114314: PUSH
114315: LD_INT 2
114317: PUSH
114318: EMPTY
114319: LIST
114320: LIST
114321: PPUSH
114322: CALL_OW 72
114326: PUSH
114327: LD_INT 1
114329: LESSEQUAL
114330: OR
114331: PUSH
114332: LD_VAR 0 19
114336: AND
114337: PUSH
114338: LD_VAR 0 4
114342: PUSH
114343: LD_VAR 0 17
114347: IN
114348: NOT
114349: AND
114350: IFFALSE 114443
// begin if b then
114352: LD_VAR 0 18
114356: IFFALSE 114405
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
114358: LD_VAR 0 18
114362: PPUSH
114363: LD_VAR 0 21
114367: PPUSH
114368: LD_VAR 0 18
114372: PPUSH
114373: CALL_OW 74
114377: PPUSH
114378: CALL_OW 296
114382: PUSH
114383: LD_INT 10
114385: LESS
114386: PUSH
114387: LD_VAR 0 18
114391: PPUSH
114392: CALL_OW 461
114396: PUSH
114397: LD_INT 7
114399: NONEQUAL
114400: AND
114401: IFFALSE 114405
// continue ;
114403: GO 113640
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
114405: LD_ADDR_VAR 0 17
114409: PUSH
114410: LD_VAR 0 17
114414: PPUSH
114415: LD_VAR 0 17
114419: PUSH
114420: LD_INT 1
114422: PLUS
114423: PPUSH
114424: LD_VAR 0 4
114428: PPUSH
114429: CALL_OW 1
114433: ST_TO_ADDR
// ComExitBuilding ( i ) ;
114434: LD_VAR 0 4
114438: PPUSH
114439: CALL_OW 122
// end ; if sold_defenders then
114443: LD_VAR 0 17
114447: IFFALSE 114507
// if i in sold_defenders then
114449: LD_VAR 0 4
114453: PUSH
114454: LD_VAR 0 17
114458: IN
114459: IFFALSE 114507
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
114461: LD_VAR 0 4
114465: PPUSH
114466: CALL_OW 314
114470: NOT
114471: PUSH
114472: LD_VAR 0 4
114476: PPUSH
114477: LD_VAR 0 13
114481: PPUSH
114482: CALL_OW 296
114486: PUSH
114487: LD_INT 30
114489: LESS
114490: AND
114491: IFFALSE 114507
// ComAttackUnit ( i , e ) ;
114493: LD_VAR 0 4
114497: PPUSH
114498: LD_VAR 0 13
114502: PPUSH
114503: CALL_OW 115
// end ; end ; end ;
114507: GO 114510
114509: POP
// if IsDead ( i ) then
114510: LD_VAR 0 4
114514: PPUSH
114515: CALL_OW 301
114519: IFFALSE 114537
// defenders := defenders diff i ;
114521: LD_ADDR_VAR 0 2
114525: PUSH
114526: LD_VAR 0 2
114530: PUSH
114531: LD_VAR 0 4
114535: DIFF
114536: ST_TO_ADDR
// end ;
114537: GO 113640
114539: POP
114540: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
114541: LD_VAR 0 21
114545: NOT
114546: PUSH
114547: LD_VAR 0 2
114551: NOT
114552: OR
114553: PUSH
114554: LD_EXP 50
114558: PUSH
114559: LD_VAR 0 1
114563: ARRAY
114564: NOT
114565: OR
114566: IFFALSE 113544
// MC_Reset ( base , 18 ) ;
114568: LD_VAR 0 1
114572: PPUSH
114573: LD_INT 18
114575: PPUSH
114576: CALL 22083 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
114580: LD_ADDR_VAR 0 2
114584: PUSH
114585: LD_VAR 0 2
114589: PUSH
114590: LD_VAR 0 2
114594: PPUSH
114595: LD_INT 2
114597: PUSH
114598: LD_INT 25
114600: PUSH
114601: LD_INT 1
114603: PUSH
114604: EMPTY
114605: LIST
114606: LIST
114607: PUSH
114608: LD_INT 25
114610: PUSH
114611: LD_INT 5
114613: PUSH
114614: EMPTY
114615: LIST
114616: LIST
114617: PUSH
114618: LD_INT 25
114620: PUSH
114621: LD_INT 8
114623: PUSH
114624: EMPTY
114625: LIST
114626: LIST
114627: PUSH
114628: LD_INT 25
114630: PUSH
114631: LD_INT 9
114633: PUSH
114634: EMPTY
114635: LIST
114636: LIST
114637: PUSH
114638: EMPTY
114639: LIST
114640: LIST
114641: LIST
114642: LIST
114643: LIST
114644: PPUSH
114645: CALL_OW 72
114649: DIFF
114650: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
114651: LD_VAR 0 21
114655: NOT
114656: PUSH
114657: LD_VAR 0 2
114661: PPUSH
114662: LD_INT 21
114664: PUSH
114665: LD_INT 2
114667: PUSH
114668: EMPTY
114669: LIST
114670: LIST
114671: PPUSH
114672: CALL_OW 72
114676: AND
114677: IFFALSE 115015
// begin tmp := FilterByTag ( defenders , 19 ) ;
114679: LD_ADDR_VAR 0 11
114683: PUSH
114684: LD_VAR 0 2
114688: PPUSH
114689: LD_INT 19
114691: PPUSH
114692: CALL 82810 0 2
114696: ST_TO_ADDR
// if tmp then
114697: LD_VAR 0 11
114701: IFFALSE 114771
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
114703: LD_ADDR_VAR 0 11
114707: PUSH
114708: LD_VAR 0 11
114712: PPUSH
114713: LD_INT 25
114715: PUSH
114716: LD_INT 3
114718: PUSH
114719: EMPTY
114720: LIST
114721: LIST
114722: PPUSH
114723: CALL_OW 72
114727: ST_TO_ADDR
// if tmp then
114728: LD_VAR 0 11
114732: IFFALSE 114771
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
114734: LD_ADDR_EXP 62
114738: PUSH
114739: LD_EXP 62
114743: PPUSH
114744: LD_VAR 0 1
114748: PPUSH
114749: LD_EXP 62
114753: PUSH
114754: LD_VAR 0 1
114758: ARRAY
114759: PUSH
114760: LD_VAR 0 11
114764: UNION
114765: PPUSH
114766: CALL_OW 1
114770: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
114771: LD_VAR 0 1
114775: PPUSH
114776: LD_INT 19
114778: PPUSH
114779: CALL 22083 0 2
// repeat wait ( 0 0$1 ) ;
114783: LD_INT 35
114785: PPUSH
114786: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114790: LD_EXP 50
114794: PUSH
114795: LD_VAR 0 1
114799: ARRAY
114800: NOT
114801: PUSH
114802: LD_EXP 50
114806: PUSH
114807: LD_VAR 0 1
114811: ARRAY
114812: PUSH
114813: EMPTY
114814: EQUAL
114815: OR
114816: IFFALSE 114853
// begin for i in defenders do
114818: LD_ADDR_VAR 0 4
114822: PUSH
114823: LD_VAR 0 2
114827: PUSH
114828: FOR_IN
114829: IFFALSE 114842
// ComStop ( i ) ;
114831: LD_VAR 0 4
114835: PPUSH
114836: CALL_OW 141
114840: GO 114828
114842: POP
114843: POP
// defenders := [ ] ;
114844: LD_ADDR_VAR 0 2
114848: PUSH
114849: EMPTY
114850: ST_TO_ADDR
// exit ;
114851: GO 115079
// end ; for i in defenders do
114853: LD_ADDR_VAR 0 4
114857: PUSH
114858: LD_VAR 0 2
114862: PUSH
114863: FOR_IN
114864: IFFALSE 114953
// begin if not IsInArea ( i , mc_parking [ base ] ) then
114866: LD_VAR 0 4
114870: PPUSH
114871: LD_EXP 74
114875: PUSH
114876: LD_VAR 0 1
114880: ARRAY
114881: PPUSH
114882: CALL_OW 308
114886: NOT
114887: IFFALSE 114911
// ComMoveToArea ( i , mc_parking [ base ] ) else
114889: LD_VAR 0 4
114893: PPUSH
114894: LD_EXP 74
114898: PUSH
114899: LD_VAR 0 1
114903: ARRAY
114904: PPUSH
114905: CALL_OW 113
114909: GO 114951
// if GetControl ( i ) = control_manual then
114911: LD_VAR 0 4
114915: PPUSH
114916: CALL_OW 263
114920: PUSH
114921: LD_INT 1
114923: EQUAL
114924: IFFALSE 114951
// if IsDrivenBy ( i ) then
114926: LD_VAR 0 4
114930: PPUSH
114931: CALL_OW 311
114935: IFFALSE 114951
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
114937: LD_VAR 0 4
114941: PPUSH
114942: CALL_OW 311
114946: PPUSH
114947: CALL_OW 121
// end ;
114951: GO 114863
114953: POP
114954: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
114955: LD_VAR 0 2
114959: PPUSH
114960: LD_INT 95
114962: PUSH
114963: LD_EXP 74
114967: PUSH
114968: LD_VAR 0 1
114972: ARRAY
114973: PUSH
114974: EMPTY
114975: LIST
114976: LIST
114977: PPUSH
114978: CALL_OW 72
114982: PUSH
114983: LD_VAR 0 2
114987: EQUAL
114988: PUSH
114989: LD_EXP 73
114993: PUSH
114994: LD_VAR 0 1
114998: ARRAY
114999: OR
115000: PUSH
115001: LD_EXP 50
115005: PUSH
115006: LD_VAR 0 1
115010: ARRAY
115011: NOT
115012: OR
115013: IFFALSE 114783
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
115015: LD_ADDR_EXP 72
115019: PUSH
115020: LD_EXP 72
115024: PPUSH
115025: LD_VAR 0 1
115029: PPUSH
115030: LD_VAR 0 2
115034: PPUSH
115035: LD_INT 21
115037: PUSH
115038: LD_INT 2
115040: PUSH
115041: EMPTY
115042: LIST
115043: LIST
115044: PPUSH
115045: CALL_OW 72
115049: PPUSH
115050: CALL_OW 1
115054: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
115055: LD_VAR 0 1
115059: PPUSH
115060: LD_INT 19
115062: PPUSH
115063: CALL 22083 0 2
// MC_Reset ( base , 20 ) ;
115067: LD_VAR 0 1
115071: PPUSH
115072: LD_INT 20
115074: PPUSH
115075: CALL 22083 0 2
// end ; end_of_file
115079: LD_VAR 0 3
115083: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
115084: LD_VAR 0 1
115088: PUSH
115089: LD_INT 200
115091: DOUBLE
115092: GREATEREQUAL
115093: IFFALSE 115101
115095: LD_INT 299
115097: DOUBLE
115098: LESSEQUAL
115099: IFTRUE 115103
115101: GO 115135
115103: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
115104: LD_VAR 0 1
115108: PPUSH
115109: LD_VAR 0 2
115113: PPUSH
115114: LD_VAR 0 3
115118: PPUSH
115119: LD_VAR 0 4
115123: PPUSH
115124: LD_VAR 0 5
115128: PPUSH
115129: CALL 103521 0 5
115133: GO 115212
115135: LD_INT 300
115137: DOUBLE
115138: GREATEREQUAL
115139: IFFALSE 115147
115141: LD_INT 399
115143: DOUBLE
115144: LESSEQUAL
115145: IFTRUE 115149
115147: GO 115211
115149: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
115150: LD_VAR 0 1
115154: PPUSH
115155: LD_VAR 0 2
115159: PPUSH
115160: LD_VAR 0 3
115164: PPUSH
115165: LD_VAR 0 4
115169: PPUSH
115170: LD_VAR 0 5
115174: PPUSH
115175: LD_VAR 0 6
115179: PPUSH
115180: LD_VAR 0 7
115184: PPUSH
115185: LD_VAR 0 8
115189: PPUSH
115190: LD_VAR 0 9
115194: PPUSH
115195: LD_VAR 0 10
115199: PPUSH
115200: LD_VAR 0 11
115204: PPUSH
115205: CALL 101163 0 11
115209: GO 115212
115211: POP
// end ;
115212: PPOPN 11
115214: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
115215: LD_VAR 0 1
115219: PPUSH
115220: LD_VAR 0 2
115224: PPUSH
115225: LD_VAR 0 3
115229: PPUSH
115230: LD_VAR 0 4
115234: PPUSH
115235: LD_VAR 0 5
115239: PPUSH
115240: CALL 103257 0 5
// end ; end_of_file
115244: PPOPN 5
115246: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
115247: LD_VAR 0 1
115251: PPUSH
115252: LD_VAR 0 2
115256: PPUSH
115257: LD_VAR 0 3
115261: PPUSH
115262: LD_VAR 0 4
115266: PPUSH
115267: LD_VAR 0 5
115271: PPUSH
115272: LD_VAR 0 6
115276: PPUSH
115277: CALL 88856 0 6
// end ;
115281: PPOPN 6
115283: END
