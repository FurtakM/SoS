// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17382 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 80036 0 9
// PrepareAmerican ;
  77: CALL 562 0 0
// PrepareArabian ;
  81: CALL 2234 0 0
// MC_Start ( ) ;
  85: CALL 19494 0 0
// Action ;
  89: CALL 8072 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: EMPTY
 227: LIST
 228: LIST
 229: LIST
 230: PUSH
 231: LD_OWVAR 67
 235: ARRAY
 236: ST_TO_ADDR
// powell_warn := false ;
 237: LD_ADDR_EXP 16
 241: PUSH
 242: LD_INT 0
 244: ST_TO_ADDR
// loses_counter := 0 ;
 245: LD_ADDR_EXP 17
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// artifact_oncargo := false ;
 253: LD_ADDR_EXP 14
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 261: LD_ADDR_EXP 18
 265: PUSH
 266: LD_STRING 10_GensherEscape_1
 268: PPUSH
 269: LD_EXP 1
 273: PPUSH
 274: CALL_OW 30
 278: ST_TO_ADDR
// can_kamikazed := false ;
 279: LD_ADDR_EXP 10
 283: PUSH
 284: LD_INT 0
 286: ST_TO_ADDR
// am_veh_consturcted := false ;
 287: LD_ADDR_EXP 20
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// end ;
 295: LD_VAR 0 1
 299: RET
// export function CustomInitMacro ; var i ; begin
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 304: LD_ADDR_EXP 74
 308: PUSH
 309: LD_INT 20
 311: PUSH
 312: LD_INT 21
 314: PUSH
 315: LD_INT 22
 317: PUSH
 318: EMPTY
 319: LIST
 320: LIST
 321: LIST
 322: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 323: LD_ADDR_EXP 75
 327: PUSH
 328: LD_INT 28
 330: PUSH
 331: LD_INT 24
 333: PUSH
 334: LD_INT 26
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 4
 347: PUSH
 348: LD_INT 6
 350: PUSH
 351: LD_INT 9
 353: PUSH
 354: EMPTY
 355: LIST
 356: LIST
 357: LIST
 358: PUSH
 359: LD_OWVAR 67
 363: ARRAY
 364: PPUSH
 365: LD_INT 3
 367: PPUSH
 368: CALL 40711 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 372: LD_INT 2
 374: PPUSH
 375: LD_INT 4
 377: PUSH
 378: LD_INT 6
 380: PUSH
 381: LD_INT 9
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_OWVAR 67
 393: ARRAY
 394: PPUSH
 395: LD_INT 2
 397: PPUSH
 398: CALL 40711 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield3_left ) ;
 402: LD_INT 3
 404: PPUSH
 405: LD_INT 4
 407: PUSH
 408: LD_INT 6
 410: PUSH
 411: LD_INT 9
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: PUSH
 419: LD_OWVAR 67
 423: ARRAY
 424: PPUSH
 425: LD_INT 1
 427: PPUSH
 428: CALL 40711 0 3
// for i = 1 to mc_bases do
 432: LD_ADDR_VAR 0 2
 436: PUSH
 437: DOUBLE
 438: LD_INT 1
 440: DEC
 441: ST_TO_ADDR
 442: LD_EXP 50
 446: PUSH
 447: FOR_TO
 448: IFFALSE 472
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 450: LD_VAR 0 2
 454: PPUSH
 455: LD_EXP 43
 459: PUSH
 460: LD_VAR 0 2
 464: ARRAY
 465: PPUSH
 466: CALL 41137 0 2
 470: GO 447
 472: POP
 473: POP
// end ;
 474: LD_VAR 0 1
 478: RET
// function Debuger ; var i ; begin
 479: LD_INT 0
 481: PPUSH
 482: PPUSH
// if not debug then
 483: LD_EXP 1
 487: NOT
 488: IFFALSE 492
// exit ;
 490: GO 528
// game_speed := 5 ;
 492: LD_ADDR_OWVAR 65
 496: PUSH
 497: LD_INT 5
 499: ST_TO_ADDR
// uc_side := 1 ;
 500: LD_ADDR_OWVAR 20
 504: PUSH
 505: LD_INT 1
 507: ST_TO_ADDR
// uc_nation := 1 ;
 508: LD_ADDR_OWVAR 21
 512: PUSH
 513: LD_INT 1
 515: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 516: LD_EXP 36
 520: PPUSH
 521: LD_INT 1
 523: PPUSH
 524: CALL_OW 235
// end ;
 528: LD_VAR 0 1
 532: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 533: LD_INT 94
 535: PPUSH
 536: CALL_OW 301
 540: PUSH
 541: LD_INT 45
 543: PPUSH
 544: CALL_OW 302
 548: AND
 549: IFFALSE 561
 551: GO 553
 553: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 554: LD_STRING ACH_EAST
 556: PPUSH
 557: CALL_OW 543
 561: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 562: LD_INT 0
 564: PPUSH
 565: PPUSH
 566: PPUSH
 567: PPUSH
 568: PPUSH
 569: PPUSH
 570: PPUSH
 571: PPUSH
// uc_side := 4 ;
 572: LD_ADDR_OWVAR 20
 576: PUSH
 577: LD_INT 4
 579: ST_TO_ADDR
// uc_nation := 1 ;
 580: LD_ADDR_OWVAR 21
 584: PUSH
 585: LD_INT 1
 587: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 588: LD_ADDR_EXP 30
 592: PUSH
 593: LD_STRING Powell
 595: PPUSH
 596: LD_INT 0
 598: PPUSH
 599: LD_STRING 
 601: PPUSH
 602: CALL 47421 0 3
 606: ST_TO_ADDR
// uc_side := 1 ;
 607: LD_ADDR_OWVAR 20
 611: PUSH
 612: LD_INT 1
 614: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 615: LD_ADDR_EXP 21
 619: PUSH
 620: LD_STRING JMM
 622: PPUSH
 623: LD_EXP 1
 627: NOT
 628: PPUSH
 629: LD_EXP 4
 633: PPUSH
 634: CALL 47421 0 3
 638: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 639: LD_EXP 21
 643: PPUSH
 644: CALL_OW 257
 648: PUSH
 649: LD_INT 4
 651: GREATER
 652: IFFALSE 666
// SetClass ( JMM , 1 ) ;
 654: LD_EXP 21
 658: PPUSH
 659: LD_INT 1
 661: PPUSH
 662: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 666: LD_ADDR_EXP 22
 670: PUSH
 671: LD_STRING Lisa
 673: PPUSH
 674: LD_EXP 1
 678: NOT
 679: PPUSH
 680: LD_EXP 4
 684: PPUSH
 685: CALL 47421 0 3
 689: ST_TO_ADDR
// if not Lisa then
 690: LD_EXP 22
 694: NOT
 695: IFFALSE 710
// Lisa := CreateCharacter ( 10_Lisa ) ;
 697: LD_ADDR_EXP 22
 701: PUSH
 702: LD_STRING 10_Lisa
 704: PPUSH
 705: CALL_OW 34
 709: ST_TO_ADDR
// if not Lisa then
 710: LD_EXP 22
 714: NOT
 715: IFFALSE 730
// Lisa := CreateCharacter ( 09_Lisa ) ;
 717: LD_ADDR_EXP 22
 721: PUSH
 722: LD_STRING 09_Lisa
 724: PPUSH
 725: CALL_OW 34
 729: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 730: LD_ADDR_EXP 31
 734: PUSH
 735: LD_STRING Cornel
 737: PPUSH
 738: LD_EXP 1
 742: NOT
 743: PPUSH
 744: LD_EXP 4
 748: PPUSH
 749: CALL 47421 0 3
 753: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 754: LD_ADDR_EXP 23
 758: PUSH
 759: LD_STRING Donaldson
 761: PPUSH
 762: LD_EXP 1
 766: NOT
 767: PPUSH
 768: LD_EXP 4
 772: PPUSH
 773: CALL 47421 0 3
 777: ST_TO_ADDR
// if not Donaldson then
 778: LD_EXP 23
 782: NOT
 783: IFFALSE 798
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 785: LD_ADDR_EXP 23
 789: PUSH
 790: LD_STRING 10_Donaldson
 792: PPUSH
 793: CALL_OW 34
 797: ST_TO_ADDR
// if not Donaldson then
 798: LD_EXP 23
 802: NOT
 803: IFFALSE 818
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 805: LD_ADDR_EXP 23
 809: PUSH
 810: LD_STRING 09_Donaldson
 812: PPUSH
 813: CALL_OW 34
 817: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 818: LD_ADDR_EXP 24
 822: PUSH
 823: LD_STRING Bobby
 825: PPUSH
 826: LD_EXP 1
 830: NOT
 831: PPUSH
 832: LD_EXP 4
 836: PPUSH
 837: CALL 47421 0 3
 841: ST_TO_ADDR
// if not Bobby then
 842: LD_EXP 24
 846: NOT
 847: IFFALSE 862
// Bobby := CreateCharacter ( 10_Bobby ) ;
 849: LD_ADDR_EXP 24
 853: PUSH
 854: LD_STRING 10_Bobby
 856: PPUSH
 857: CALL_OW 34
 861: ST_TO_ADDR
// if not Bobby then
 862: LD_EXP 24
 866: NOT
 867: IFFALSE 882
// Bobby := CreateCharacter ( 09_Bobby ) ;
 869: LD_ADDR_EXP 24
 873: PUSH
 874: LD_STRING 09_Bobby
 876: PPUSH
 877: CALL_OW 34
 881: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 882: LD_ADDR_EXP 25
 886: PUSH
 887: LD_STRING Cyrus
 889: PPUSH
 890: LD_EXP 1
 894: NOT
 895: PPUSH
 896: LD_EXP 4
 900: PPUSH
 901: CALL 47421 0 3
 905: ST_TO_ADDR
// if not Cyrus then
 906: LD_EXP 25
 910: NOT
 911: IFFALSE 926
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 913: LD_ADDR_EXP 25
 917: PUSH
 918: LD_STRING 10_Cyrus
 920: PPUSH
 921: CALL_OW 34
 925: ST_TO_ADDR
// if not Cyrus then
 926: LD_EXP 25
 930: NOT
 931: IFFALSE 946
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 933: LD_ADDR_EXP 25
 937: PUSH
 938: LD_STRING 09_Cyrus
 940: PPUSH
 941: CALL_OW 34
 945: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 946: LD_ADDR_EXP 26
 950: PUSH
 951: LD_STRING Denis
 953: PPUSH
 954: LD_EXP 1
 958: NOT
 959: PPUSH
 960: LD_EXP 4
 964: PPUSH
 965: CALL 47421 0 3
 969: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 970: LD_ADDR_EXP 27
 974: PUSH
 975: LD_STRING Brown
 977: PPUSH
 978: LD_EXP 1
 982: NOT
 983: PPUSH
 984: LD_EXP 4
 988: PPUSH
 989: CALL 47421 0 3
 993: ST_TO_ADDR
// if not Brown then
 994: LD_EXP 27
 998: NOT
 999: IFFALSE 1014
// Brown := CreateCharacter ( 10_Brown ) ;
1001: LD_ADDR_EXP 27
1005: PUSH
1006: LD_STRING 10_Brown
1008: PPUSH
1009: CALL_OW 34
1013: ST_TO_ADDR
// if not Brown then
1014: LD_EXP 27
1018: NOT
1019: IFFALSE 1034
// Brown := CreateCharacter ( 08_Brown ) ;
1021: LD_ADDR_EXP 27
1025: PUSH
1026: LD_STRING 08_Brown
1028: PPUSH
1029: CALL_OW 34
1033: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1034: LD_ADDR_EXP 28
1038: PUSH
1039: LD_STRING Gladstone
1041: PPUSH
1042: LD_EXP 1
1046: NOT
1047: PPUSH
1048: LD_EXP 4
1052: PPUSH
1053: CALL 47421 0 3
1057: ST_TO_ADDR
// if not Gladstone then
1058: LD_EXP 28
1062: NOT
1063: IFFALSE 1078
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1065: LD_ADDR_EXP 28
1069: PUSH
1070: LD_STRING 10_Gladstone
1072: PPUSH
1073: CALL_OW 34
1077: ST_TO_ADDR
// if not Gladstone then
1078: LD_EXP 28
1082: NOT
1083: IFFALSE 1098
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1085: LD_ADDR_EXP 28
1089: PUSH
1090: LD_STRING 08_Gladstone
1092: PPUSH
1093: CALL_OW 34
1097: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1098: LD_ADDR_EXP 29
1102: PUSH
1103: LD_STRING Houten
1105: PPUSH
1106: LD_EXP 1
1110: NOT
1111: PPUSH
1112: LD_EXP 4
1116: PPUSH
1117: CALL 47421 0 3
1121: ST_TO_ADDR
// if not Houten then
1122: LD_EXP 29
1126: NOT
1127: IFFALSE 1142
// Houten := CreateCharacter ( 10_Houten ) ;
1129: LD_ADDR_EXP 29
1133: PUSH
1134: LD_STRING 10_Houten
1136: PPUSH
1137: CALL_OW 34
1141: ST_TO_ADDR
// if not Houten then
1142: LD_EXP 29
1146: NOT
1147: IFFALSE 1162
// Houten := CreateCharacter ( 09_Houten ) ;
1149: LD_ADDR_EXP 29
1153: PUSH
1154: LD_STRING 09_Houten
1156: PPUSH
1157: CALL_OW 34
1161: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1162: LD_ADDR_EXP 31
1166: PUSH
1167: LD_STRING Cornell
1169: PPUSH
1170: LD_EXP 1
1174: NOT
1175: PPUSH
1176: LD_EXP 4
1180: PPUSH
1181: CALL 47421 0 3
1185: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1186: LD_ADDR_EXP 32
1190: PUSH
1191: LD_STRING Gary
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_EXP 4
1204: PPUSH
1205: CALL 47421 0 3
1209: ST_TO_ADDR
// if not Gary then
1210: LD_EXP 32
1214: NOT
1215: IFFALSE 1230
// Gary := CreateCharacter ( 10_Gary ) ;
1217: LD_ADDR_EXP 32
1221: PUSH
1222: LD_STRING 10_Gary
1224: PPUSH
1225: CALL_OW 34
1229: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1230: LD_ADDR_EXP 33
1234: PUSH
1235: LD_STRING Frank
1237: PPUSH
1238: LD_EXP 1
1242: NOT
1243: PPUSH
1244: LD_EXP 4
1248: PPUSH
1249: CALL 47421 0 3
1253: ST_TO_ADDR
// if not Frank then
1254: LD_EXP 33
1258: NOT
1259: IFFALSE 1274
// Frank := CreateCharacter ( 08_Frank ) ;
1261: LD_ADDR_EXP 33
1265: PUSH
1266: LD_STRING 08_Frank
1268: PPUSH
1269: CALL_OW 34
1273: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1274: LD_ADDR_EXP 34
1278: PUSH
1279: LD_STRING Kikuchi
1281: PPUSH
1282: LD_EXP 1
1286: NOT
1287: PPUSH
1288: LD_EXP 4
1292: PPUSH
1293: CALL 47421 0 3
1297: ST_TO_ADDR
// if not Kikuchi then
1298: LD_EXP 34
1302: NOT
1303: IFFALSE 1318
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1305: LD_ADDR_EXP 34
1309: PUSH
1310: LD_STRING 08_Kikuchi
1312: PPUSH
1313: CALL_OW 34
1317: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1318: LD_ADDR_VAR 0 5
1322: PUSH
1323: LD_EXP 22
1327: PUSH
1328: LD_EXP 23
1332: PUSH
1333: LD_EXP 24
1337: PUSH
1338: LD_EXP 25
1342: PUSH
1343: LD_EXP 26
1347: PUSH
1348: LD_EXP 27
1352: PUSH
1353: LD_EXP 28
1357: PUSH
1358: LD_EXP 29
1362: PUSH
1363: LD_EXP 31
1367: PUSH
1368: LD_EXP 32
1372: PUSH
1373: LD_EXP 33
1377: PUSH
1378: LD_EXP 34
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: ST_TO_ADDR
// tmp := tmp diff 0 ;
1397: LD_ADDR_VAR 0 5
1401: PUSH
1402: LD_VAR 0 5
1406: PUSH
1407: LD_INT 0
1409: DIFF
1410: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1411: LD_ADDR_VAR 0 5
1415: PUSH
1416: LD_VAR 0 5
1420: PUSH
1421: LD_STRING 10_lock
1423: PPUSH
1424: CALL_OW 31
1428: UNION
1429: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1430: LD_ADDR_VAR 0 5
1434: PUSH
1435: LD_VAR 0 5
1439: PUSH
1440: LD_STRING 10c_lock
1442: PPUSH
1443: CALL_OW 31
1447: UNION
1448: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1449: LD_STRING 10_lock
1451: PPUSH
1452: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1456: LD_STRING 10c_lock
1458: PPUSH
1459: CALL_OW 40
// for i in tmp do
1463: LD_ADDR_VAR 0 2
1467: PUSH
1468: LD_VAR 0 5
1472: PUSH
1473: FOR_IN
1474: IFFALSE 1512
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1476: LD_VAR 0 2
1480: PPUSH
1481: CALL_OW 257
1485: PUSH
1486: LD_INT 8
1488: PUSH
1489: LD_INT 2
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: IN
1496: IFFALSE 1510
// SetClass ( i , class_soldier ) ;
1498: LD_VAR 0 2
1502: PPUSH
1503: LD_INT 1
1505: PPUSH
1506: CALL_OW 336
1510: GO 1473
1512: POP
1513: POP
// if tmp < 12 then
1514: LD_VAR 0 5
1518: PUSH
1519: LD_INT 12
1521: LESS
1522: IFFALSE 1616
// begin k := 16 - tmp ;
1524: LD_ADDR_VAR 0 3
1528: PUSH
1529: LD_INT 16
1531: PUSH
1532: LD_VAR 0 5
1536: MINUS
1537: ST_TO_ADDR
// for i = 1 to k do
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: DOUBLE
1544: LD_INT 1
1546: DEC
1547: ST_TO_ADDR
1548: LD_VAR 0 3
1552: PUSH
1553: FOR_TO
1554: IFFALSE 1614
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1556: LD_INT 0
1558: PPUSH
1559: LD_INT 1
1561: PUSH
1562: LD_INT 1
1564: PUSH
1565: LD_INT 3
1567: PUSH
1568: LD_INT 4
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: LIST
1575: LIST
1576: PUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 4
1582: PPUSH
1583: CALL_OW 12
1587: ARRAY
1588: PPUSH
1589: LD_INT 6
1591: PPUSH
1592: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1596: LD_ADDR_VAR 0 5
1600: PUSH
1601: LD_VAR 0 5
1605: PUSH
1606: CALL_OW 44
1610: ADD
1611: ST_TO_ADDR
// end ;
1612: GO 1553
1614: POP
1615: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1616: LD_ADDR_EXP 19
1620: PUSH
1621: LD_STRING 1
1623: PPUSH
1624: LD_INT 12
1626: PPUSH
1627: LD_INT 12
1629: PPUSH
1630: LD_INT -5
1632: PUSH
1633: LD_EXP 21
1637: PUSH
1638: LD_INT -2
1640: PUSH
1641: LD_INT -3
1643: PUSH
1644: LD_INT -5
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: PUSH
1654: LD_VAR 0 5
1658: ADD
1659: PUSH
1660: LD_INT -6
1662: PUSH
1663: LD_INT -4
1665: PUSH
1666: LD_EXP 30
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: LIST
1675: ADD
1676: PPUSH
1677: LD_INT 1
1679: PUSH
1680: LD_INT 4
1682: PUSH
1683: EMPTY
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 3
1689: PUSH
1690: LD_INT 0
1692: PUSH
1693: LD_INT 5
1695: PUSH
1696: EMPTY
1697: LIST
1698: LIST
1699: LIST
1700: PUSH
1701: LD_INT 4
1703: PUSH
1704: LD_INT 0
1706: PUSH
1707: LD_INT 3
1709: PUSH
1710: EMPTY
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 5
1717: PUSH
1718: LD_INT 0
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: PPUSH
1735: CALL_OW 42
1739: ST_TO_ADDR
// others := tmp diff selected ;
1740: LD_ADDR_VAR 0 8
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 19
1754: DIFF
1755: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1756: LD_ADDR_VAR 0 8
1760: PUSH
1761: LD_VAR 0 8
1765: PUSH
1766: LD_EXP 22
1770: PUSH
1771: LD_EXP 23
1775: PUSH
1776: LD_EXP 24
1780: PUSH
1781: LD_EXP 25
1785: PUSH
1786: LD_EXP 26
1790: PUSH
1791: LD_EXP 27
1795: PUSH
1796: LD_EXP 28
1800: PUSH
1801: LD_EXP 29
1805: PUSH
1806: LD_EXP 31
1810: PUSH
1811: LD_EXP 32
1815: PUSH
1816: LD_EXP 33
1820: PUSH
1821: LD_EXP 34
1825: PUSH
1826: EMPTY
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: DIFF
1840: ST_TO_ADDR
// if others then
1841: LD_VAR 0 8
1845: IFFALSE 1859
// SaveCharacters ( others , 11_others ) ;
1847: LD_VAR 0 8
1851: PPUSH
1852: LD_STRING 11_others
1854: PPUSH
1855: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1859: LD_ADDR_VAR 0 6
1863: PUSH
1864: LD_INT 3
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 1
1872: PUSH
1873: LD_INT 4
1875: PUSH
1876: EMPTY
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: PUSH
1882: LD_INT 2
1884: PUSH
1885: LD_INT 2
1887: PUSH
1888: LD_INT 1
1890: PUSH
1891: LD_INT 5
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: PUSH
1900: LD_INT 4
1902: PUSH
1903: LD_INT 1
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: LD_INT 5
1911: PUSH
1912: EMPTY
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: PUSH
1918: LD_INT 2
1920: PUSH
1921: LD_INT 1
1923: PUSH
1924: LD_INT 1
1926: PUSH
1927: LD_INT 7
1929: PUSH
1930: EMPTY
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: PUSH
1936: LD_INT 3
1938: PUSH
1939: LD_INT 2
1941: PUSH
1942: LD_INT 1
1944: PUSH
1945: LD_INT 7
1947: PUSH
1948: EMPTY
1949: LIST
1950: LIST
1951: LIST
1952: LIST
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: LIST
1960: ST_TO_ADDR
// for i in JMM ^ selected do
1961: LD_ADDR_VAR 0 2
1965: PUSH
1966: LD_EXP 21
1970: PUSH
1971: LD_EXP 19
1975: ADD
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2167
// begin if GetClass ( i ) = 3 then
1980: LD_VAR 0 2
1984: PPUSH
1985: CALL_OW 257
1989: PUSH
1990: LD_INT 3
1992: EQUAL
1993: IFFALSE 2150
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1995: LD_ADDR_OWVAR 37
1999: PUSH
2000: LD_VAR 0 6
2004: PUSH
2005: LD_INT 1
2007: ARRAY
2008: PUSH
2009: LD_INT 1
2011: ARRAY
2012: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2013: LD_ADDR_OWVAR 39
2017: PUSH
2018: LD_VAR 0 6
2022: PUSH
2023: LD_INT 1
2025: ARRAY
2026: PUSH
2027: LD_INT 2
2029: ARRAY
2030: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2031: LD_ADDR_OWVAR 38
2035: PUSH
2036: LD_VAR 0 6
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PUSH
2045: LD_INT 3
2047: ARRAY
2048: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2049: LD_ADDR_OWVAR 40
2053: PUSH
2054: LD_VAR 0 6
2058: PUSH
2059: LD_INT 1
2061: ARRAY
2062: PUSH
2063: LD_INT 4
2065: ARRAY
2066: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2067: LD_ADDR_VAR 0 6
2071: PUSH
2072: LD_VAR 0 6
2076: PPUSH
2077: LD_INT 1
2079: PPUSH
2080: CALL_OW 3
2084: ST_TO_ADDR
// veh := CreateVehicle ;
2085: LD_ADDR_VAR 0 7
2089: PUSH
2090: CALL_OW 45
2094: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2095: LD_VAR 0 7
2099: PPUSH
2100: LD_INT 8
2102: PPUSH
2103: LD_INT 0
2105: PPUSH
2106: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2110: LD_VAR 0 2
2114: PPUSH
2115: LD_VAR 0 7
2119: PPUSH
2120: CALL_OW 52
// if i = JMM then
2124: LD_VAR 0 2
2128: PUSH
2129: LD_EXP 21
2133: EQUAL
2134: IFFALSE 2148
// SetMark ( veh , 1 ) ;
2136: LD_VAR 0 7
2140: PPUSH
2141: LD_INT 1
2143: PPUSH
2144: CALL_OW 242
// end else
2148: GO 2165
// PlaceUnitArea ( i , am_hum_start , false ) ;
2150: LD_VAR 0 2
2154: PPUSH
2155: LD_INT 9
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: CALL_OW 49
// end ;
2165: GO 1977
2167: POP
2168: POP
// vc_chassis := us_medium_tracked ;
2169: LD_ADDR_OWVAR 37
2173: PUSH
2174: LD_INT 3
2176: ST_TO_ADDR
// vc_engine := engine_solar ;
2177: LD_ADDR_OWVAR 39
2181: PUSH
2182: LD_INT 2
2184: ST_TO_ADDR
// vc_control := control_computer ;
2185: LD_ADDR_OWVAR 38
2189: PUSH
2190: LD_INT 3
2192: ST_TO_ADDR
// vc_weapon := us_radar ;
2193: LD_ADDR_OWVAR 40
2197: PUSH
2198: LD_INT 11
2200: ST_TO_ADDR
// veh := CreateVehicle ;
2201: LD_ADDR_VAR 0 7
2205: PUSH
2206: CALL_OW 45
2210: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2211: LD_VAR 0 7
2215: PPUSH
2216: LD_INT 87
2218: PPUSH
2219: LD_INT 142
2221: PPUSH
2222: LD_INT 0
2224: PPUSH
2225: CALL_OW 48
// end ; end_of_file
2229: LD_VAR 0 1
2233: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2234: LD_INT 0
2236: PPUSH
2237: PPUSH
2238: PPUSH
2239: PPUSH
2240: PPUSH
2241: PPUSH
// if Difficulty = 1 then
2242: LD_OWVAR 67
2246: PUSH
2247: LD_INT 1
2249: EQUAL
2250: IFFALSE 2347
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2252: LD_ADDR_VAR 0 6
2256: PUSH
2257: LD_INT 129
2259: PUSH
2260: LD_INT 45
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: LD_INT 143
2269: PUSH
2270: LD_INT 58
2272: PUSH
2273: EMPTY
2274: LIST
2275: LIST
2276: PUSH
2277: LD_INT 184
2279: PUSH
2280: LD_INT 113
2282: PUSH
2283: EMPTY
2284: LIST
2285: LIST
2286: PUSH
2287: LD_INT 163
2289: PUSH
2290: LD_INT 107
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: EMPTY
2298: LIST
2299: LIST
2300: LIST
2301: LIST
2302: ST_TO_ADDR
// for i in tmp do
2303: LD_ADDR_VAR 0 2
2307: PUSH
2308: LD_VAR 0 6
2312: PUSH
2313: FOR_IN
2314: IFFALSE 2345
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2316: LD_VAR 0 2
2320: PUSH
2321: LD_INT 1
2323: ARRAY
2324: PPUSH
2325: LD_VAR 0 2
2329: PUSH
2330: LD_INT 2
2332: ARRAY
2333: PPUSH
2334: CALL_OW 428
2338: PPUSH
2339: CALL_OW 64
2343: GO 2313
2345: POP
2346: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2347: LD_ADDR_VAR 0 2
2351: PUSH
2352: LD_INT 21
2354: PUSH
2355: LD_INT 3
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PPUSH
2362: CALL_OW 69
2366: PUSH
2367: FOR_IN
2368: IFFALSE 2401
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
2370: LD_VAR 0 2
2374: PPUSH
2375: LD_INT 5
2377: PUSH
2378: LD_INT 6
2380: PUSH
2381: LD_INT 7
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: LIST
2388: PUSH
2389: LD_OWVAR 67
2393: ARRAY
2394: PPUSH
2395: CALL_OW 241
2399: GO 2367
2401: POP
2402: POP
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2403: LD_ADDR_VAR 0 5
2407: PUSH
2408: LD_INT 5
2410: PUSH
2411: LD_INT 6
2413: PUSH
2414: LD_INT 7
2416: PUSH
2417: EMPTY
2418: LIST
2419: LIST
2420: LIST
2421: PUSH
2422: LD_OWVAR 67
2426: ARRAY
2427: ST_TO_ADDR
// uc_side := 2 ;
2428: LD_ADDR_OWVAR 20
2432: PUSH
2433: LD_INT 2
2435: ST_TO_ADDR
// uc_nation := 2 ;
2436: LD_ADDR_OWVAR 21
2440: PUSH
2441: LD_INT 2
2443: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2444: LD_ADDR_OWVAR 37
2448: PUSH
2449: LD_INT 14
2451: ST_TO_ADDR
// vc_engine := engine_siberite ;
2452: LD_ADDR_OWVAR 39
2456: PUSH
2457: LD_INT 3
2459: ST_TO_ADDR
// vc_control := control_manual ;
2460: LD_ADDR_OWVAR 38
2464: PUSH
2465: LD_INT 1
2467: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2468: LD_ADDR_OWVAR 40
2472: PUSH
2473: LD_INT 31
2475: ST_TO_ADDR
// for i = 1 to 3 do
2476: LD_ADDR_VAR 0 2
2480: PUSH
2481: DOUBLE
2482: LD_INT 1
2484: DEC
2485: ST_TO_ADDR
2486: LD_INT 3
2488: PUSH
2489: FOR_TO
2490: IFFALSE 2574
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2492: LD_INT 0
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: LD_VAR 0 5
2502: PPUSH
2503: CALL_OW 380
// un := CreateVehicle ;
2507: LD_ADDR_VAR 0 4
2511: PUSH
2512: CALL_OW 45
2516: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2517: LD_VAR 0 4
2521: PPUSH
2522: LD_INT 0
2524: PPUSH
2525: LD_INT 5
2527: PPUSH
2528: CALL_OW 12
2532: PPUSH
2533: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2537: LD_VAR 0 4
2541: PPUSH
2542: LD_INT 156
2544: PPUSH
2545: LD_INT 15
2547: PPUSH
2548: LD_INT 6
2550: PPUSH
2551: LD_INT 0
2553: PPUSH
2554: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2558: CALL_OW 44
2562: PPUSH
2563: LD_VAR 0 4
2567: PPUSH
2568: CALL_OW 52
// end ;
2572: GO 2489
2574: POP
2575: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 16 , [ 2 , 3 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2576: LD_ADDR_EXP 37
2580: PUSH
2581: LD_INT 94
2583: PPUSH
2584: LD_INT 28
2586: PPUSH
2587: LD_STRING dammam
2589: PPUSH
2590: LD_VAR 0 5
2594: PPUSH
2595: LD_INT 10000
2597: PUSH
2598: LD_INT 1000
2600: PUSH
2601: LD_INT 300
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: LIST
2608: PPUSH
2609: LD_INT 16
2611: PUSH
2612: LD_INT 2
2614: PUSH
2615: LD_INT 3
2617: PUSH
2618: LD_INT 4
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: LIST
2625: PUSH
2626: LD_OWVAR 67
2630: ARRAY
2631: PUSH
2632: LD_INT 1
2634: NEG
2635: PUSH
2636: LD_INT 4
2638: PUSH
2639: EMPTY
2640: LIST
2641: LIST
2642: LIST
2643: LIST
2644: PPUSH
2645: CALL 55654 0 6
2649: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ - 1 , [ 2 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
2650: LD_ADDR_EXP 37
2654: PUSH
2655: LD_EXP 37
2659: PUSH
2660: LD_INT 122
2662: PPUSH
2663: LD_INT 25
2665: PPUSH
2666: LD_STRING 
2668: PPUSH
2669: LD_VAR 0 5
2673: PPUSH
2674: LD_INT 500
2676: PUSH
2677: LD_INT 60
2679: PUSH
2680: LD_INT 0
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: LIST
2687: PPUSH
2688: LD_INT 1
2690: NEG
2691: PUSH
2692: LD_INT 2
2694: PUSH
2695: LD_INT 3
2697: PUSH
2698: LD_INT 4
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: LIST
2705: PUSH
2706: LD_OWVAR 67
2710: ARRAY
2711: PUSH
2712: LD_INT 2
2714: PUSH
2715: LD_INT 0
2717: PUSH
2718: EMPTY
2719: LIST
2720: LIST
2721: LIST
2722: LIST
2723: PPUSH
2724: CALL 55654 0 6
2728: UNION
2729: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
2730: LD_ADDR_EXP 35
2734: PUSH
2735: LD_INT 45
2737: PPUSH
2738: LD_INT 24
2740: PPUSH
2741: LD_STRING jeddah
2743: PPUSH
2744: LD_VAR 0 5
2748: PPUSH
2749: LD_INT 700
2751: PUSH
2752: LD_INT 300
2754: PUSH
2755: LD_INT 10
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: LIST
2762: PPUSH
2763: LD_INT 12
2765: PUSH
2766: LD_INT 4
2768: PUSH
2769: LD_INT 3
2771: PUSH
2772: LD_INT 2
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: LIST
2779: LIST
2780: PPUSH
2781: CALL 55654 0 6
2785: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2786: LD_ADDR_EXP 36
2790: PUSH
2791: LD_INT 7
2793: PPUSH
2794: LD_INT 27
2796: PPUSH
2797: LD_STRING riyadh
2799: PPUSH
2800: LD_VAR 0 5
2804: PPUSH
2805: LD_INT 500
2807: PUSH
2808: LD_INT 60
2810: PUSH
2811: LD_INT 0
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: PPUSH
2819: LD_INT 4
2821: PUSH
2822: LD_INT 2
2824: PUSH
2825: LD_INT 3
2827: PUSH
2828: LD_INT 1
2830: PUSH
2831: EMPTY
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: PPUSH
2837: CALL 55654 0 6
2841: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 10 , 3 , 3 , 2 ] ) ;
2842: LD_ADDR_EXP 39
2846: PUSH
2847: LD_INT 204
2849: PPUSH
2850: LD_INT 26
2852: PPUSH
2853: LD_STRING 
2855: PPUSH
2856: LD_VAR 0 5
2860: PPUSH
2861: LD_INT 500
2863: PUSH
2864: LD_INT 50
2866: PUSH
2867: LD_INT 0
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: LIST
2874: PPUSH
2875: LD_INT 10
2877: PUSH
2878: LD_INT 3
2880: PUSH
2881: LD_INT 3
2883: PUSH
2884: LD_INT 2
2886: PUSH
2887: EMPTY
2888: LIST
2889: LIST
2890: LIST
2891: LIST
2892: PPUSH
2893: CALL 55654 0 6
2897: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2898: LD_ADDR_EXP 50
2902: PUSH
2903: LD_EXP 37
2907: PUSH
2908: LD_EXP 35
2912: PUSH
2913: LD_EXP 39
2917: PUSH
2918: EMPTY
2919: LIST
2920: LIST
2921: LIST
2922: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2923: LD_ADDR_VAR 0 2
2927: PUSH
2928: LD_INT 22
2930: PUSH
2931: LD_INT 2
2933: PUSH
2934: EMPTY
2935: LIST
2936: LIST
2937: PUSH
2938: LD_INT 30
2940: PUSH
2941: LD_INT 31
2943: PUSH
2944: EMPTY
2945: LIST
2946: LIST
2947: PUSH
2948: LD_INT 58
2950: PUSH
2951: EMPTY
2952: LIST
2953: PUSH
2954: EMPTY
2955: LIST
2956: LIST
2957: LIST
2958: PPUSH
2959: CALL_OW 69
2963: PUSH
2964: FOR_IN
2965: IFFALSE 3090
// begin if GetBase ( i ) then
2967: LD_VAR 0 2
2971: PPUSH
2972: CALL_OW 274
2976: IFFALSE 2980
// continue ;
2978: GO 2964
// d := GetDir ( i ) ;
2980: LD_ADDR_VAR 0 3
2984: PUSH
2985: LD_VAR 0 2
2989: PPUSH
2990: CALL_OW 254
2994: ST_TO_ADDR
// if d < 3 then
2995: LD_VAR 0 3
2999: PUSH
3000: LD_INT 3
3002: LESS
3003: IFFALSE 3021
// d := d + 3 else
3005: LD_ADDR_VAR 0 3
3009: PUSH
3010: LD_VAR 0 3
3014: PUSH
3015: LD_INT 3
3017: PLUS
3018: ST_TO_ADDR
3019: GO 3035
// d := d - 3 ;
3021: LD_ADDR_VAR 0 3
3025: PUSH
3026: LD_VAR 0 3
3030: PUSH
3031: LD_INT 3
3033: MINUS
3034: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3035: LD_INT 0
3037: PPUSH
3038: LD_INT 8
3040: PPUSH
3041: LD_VAR 0 5
3045: PPUSH
3046: CALL_OW 380
// un := CreateHuman ;
3050: LD_ADDR_VAR 0 4
3054: PUSH
3055: CALL_OW 44
3059: ST_TO_ADDR
// SetDir ( un , d ) ;
3060: LD_VAR 0 4
3064: PPUSH
3065: LD_VAR 0 3
3069: PPUSH
3070: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3074: LD_VAR 0 4
3078: PPUSH
3079: LD_VAR 0 2
3083: PPUSH
3084: CALL_OW 52
// end ;
3088: GO 2964
3090: POP
3091: POP
// if Difficulty > 1 then
3092: LD_OWVAR 67
3096: PUSH
3097: LD_INT 1
3099: GREATER
3100: IFFALSE 3471
// begin ar_kamikadze := [ ] ;
3102: LD_ADDR_EXP 42
3106: PUSH
3107: EMPTY
3108: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3109: LD_INT 0
3111: PPUSH
3112: LD_INT 1
3114: PPUSH
3115: LD_VAR 0 5
3119: PPUSH
3120: CALL_OW 380
// un := CreateHuman ;
3124: LD_ADDR_VAR 0 4
3128: PUSH
3129: CALL_OW 44
3133: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3134: LD_VAR 0 4
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3146: LD_VAR 0 4
3150: PPUSH
3151: LD_INT 23
3153: PPUSH
3154: LD_INT 44
3156: PPUSH
3157: LD_INT 0
3159: PPUSH
3160: CALL_OW 48
// ComCrawl ( un ) ;
3164: LD_VAR 0 4
3168: PPUSH
3169: CALL_OW 137
// un := CreateHuman ;
3173: LD_ADDR_VAR 0 4
3177: PUSH
3178: CALL_OW 44
3182: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3183: LD_VAR 0 4
3187: PPUSH
3188: LD_INT 3
3190: PPUSH
3191: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3195: LD_VAR 0 4
3199: PPUSH
3200: LD_INT 30
3202: PPUSH
3203: LD_INT 39
3205: PPUSH
3206: LD_INT 0
3208: PPUSH
3209: CALL_OW 48
// ComCrawl ( un ) ;
3213: LD_VAR 0 4
3217: PPUSH
3218: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3222: LD_INT 0
3224: PPUSH
3225: LD_INT 17
3227: PPUSH
3228: LD_VAR 0 5
3232: PPUSH
3233: CALL_OW 380
// un := CreateHuman ;
3237: LD_ADDR_VAR 0 4
3241: PUSH
3242: CALL_OW 44
3246: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3247: LD_VAR 0 4
3251: PPUSH
3252: LD_INT 3
3254: PPUSH
3255: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3259: LD_VAR 0 4
3263: PPUSH
3264: LD_INT 45
3266: PPUSH
3267: LD_INT 86
3269: PPUSH
3270: LD_INT 0
3272: PPUSH
3273: CALL_OW 48
// ComHold ( un ) ;
3277: LD_VAR 0 4
3281: PPUSH
3282: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3286: LD_ADDR_EXP 42
3290: PUSH
3291: LD_EXP 42
3295: PPUSH
3296: LD_EXP 42
3300: PUSH
3301: LD_INT 1
3303: PLUS
3304: PPUSH
3305: LD_VAR 0 4
3309: PPUSH
3310: CALL_OW 1
3314: ST_TO_ADDR
// un := CreateHuman ;
3315: LD_ADDR_VAR 0 4
3319: PUSH
3320: CALL_OW 44
3324: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3325: LD_VAR 0 4
3329: PPUSH
3330: LD_INT 3
3332: PPUSH
3333: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3337: LD_VAR 0 4
3341: PPUSH
3342: LD_INT 60
3344: PPUSH
3345: LD_INT 85
3347: PPUSH
3348: LD_INT 0
3350: PPUSH
3351: CALL_OW 48
// ComHold ( un ) ;
3355: LD_VAR 0 4
3359: PPUSH
3360: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3364: LD_ADDR_EXP 42
3368: PUSH
3369: LD_EXP 42
3373: PPUSH
3374: LD_EXP 42
3378: PUSH
3379: LD_INT 1
3381: PLUS
3382: PPUSH
3383: LD_VAR 0 4
3387: PPUSH
3388: CALL_OW 1
3392: ST_TO_ADDR
// un := CreateHuman ;
3393: LD_ADDR_VAR 0 4
3397: PUSH
3398: CALL_OW 44
3402: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3403: LD_VAR 0 4
3407: PPUSH
3408: LD_INT 3
3410: PPUSH
3411: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3415: LD_VAR 0 4
3419: PPUSH
3420: LD_INT 222
3422: PPUSH
3423: LD_INT 166
3425: PPUSH
3426: LD_INT 0
3428: PPUSH
3429: CALL_OW 48
// ComHold ( un ) ;
3433: LD_VAR 0 4
3437: PPUSH
3438: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3442: LD_ADDR_EXP 42
3446: PUSH
3447: LD_EXP 42
3451: PPUSH
3452: LD_EXP 42
3456: PUSH
3457: LD_INT 1
3459: PLUS
3460: PPUSH
3461: LD_VAR 0 4
3465: PPUSH
3466: CALL_OW 1
3470: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3471: LD_ADDR_EXP 40
3475: PUSH
3476: EMPTY
3477: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3478: LD_INT 1
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_VAR 0 5
3488: PPUSH
3489: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3493: LD_ADDR_OWVAR 26
3497: PUSH
3498: LD_STRING Pavel Grigorovic
3500: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3501: LD_ADDR_OWVAR 33
3505: PUSH
3506: LD_STRING SecondCharsGal
3508: ST_TO_ADDR
// hc_face_number := 4 ;
3509: LD_ADDR_OWVAR 34
3513: PUSH
3514: LD_INT 4
3516: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3517: LD_ADDR_EXP 40
3521: PUSH
3522: LD_EXP 40
3526: PPUSH
3527: LD_INT 1
3529: PPUSH
3530: CALL_OW 44
3534: PPUSH
3535: CALL_OW 1
3539: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3540: LD_INT 2
3542: PPUSH
3543: LD_INT 4
3545: PPUSH
3546: LD_INT 2
3548: PPUSH
3549: CALL_OW 380
// hc_name := Lucy Sebel ;
3553: LD_ADDR_OWVAR 26
3557: PUSH
3558: LD_STRING Lucy Sebel
3560: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3561: LD_ADDR_OWVAR 33
3565: PUSH
3566: LD_STRING SecondCharsGal
3568: ST_TO_ADDR
// hc_face_number := 15 ;
3569: LD_ADDR_OWVAR 34
3573: PUSH
3574: LD_INT 15
3576: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3577: LD_ADDR_EXP 40
3581: PUSH
3582: LD_EXP 40
3586: PPUSH
3587: LD_INT 2
3589: PPUSH
3590: CALL_OW 44
3594: PPUSH
3595: CALL_OW 1
3599: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3600: LD_INT 2
3602: PPUSH
3603: LD_INT 4
3605: PPUSH
3606: LD_INT 2
3608: PPUSH
3609: CALL_OW 380
// hc_gallery :=  ;
3613: LD_ADDR_OWVAR 33
3617: PUSH
3618: LD_STRING 
3620: ST_TO_ADDR
// hc_name :=  ;
3621: LD_ADDR_OWVAR 26
3625: PUSH
3626: LD_STRING 
3628: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3629: LD_ADDR_EXP 40
3633: PUSH
3634: LD_EXP 40
3638: PPUSH
3639: LD_INT 3
3641: PPUSH
3642: CALL_OW 44
3646: PPUSH
3647: CALL_OW 1
3651: ST_TO_ADDR
// hc_sex := sex_male ;
3652: LD_ADDR_OWVAR 27
3656: PUSH
3657: LD_INT 1
3659: ST_TO_ADDR
// hc_class = 11 ;
3660: LD_ADDR_OWVAR 28
3664: PUSH
3665: LD_INT 11
3667: ST_TO_ADDR
// hc_gallery = sandar ;
3668: LD_ADDR_OWVAR 33
3672: PUSH
3673: LD_STRING sandar
3675: ST_TO_ADDR
// hc_face_number = 33 ;
3676: LD_ADDR_OWVAR 34
3680: PUSH
3681: LD_INT 33
3683: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3684: LD_ADDR_OWVAR 26
3688: PUSH
3689: LD_STRING Thabit Muhair Saliba
3691: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3692: LD_ADDR_OWVAR 31
3696: PUSH
3697: LD_INT 0
3699: PUSH
3700: LD_INT 0
3702: PUSH
3703: LD_INT 0
3705: PUSH
3706: LD_INT 0
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: LIST
3713: LIST
3714: ST_TO_ADDR
// Saliba = CreateHuman ;
3715: LD_ADDR_EXP 44
3719: PUSH
3720: CALL_OW 44
3724: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3725: LD_EXP 44
3729: PPUSH
3730: LD_INT 7
3732: PPUSH
3733: CALL_OW 52
// if gensher_active then
3737: LD_EXP 18
3741: IFFALSE 3768
// begin Gensher = NewCharacter ( Dietrich ) ;
3743: LD_ADDR_EXP 45
3747: PUSH
3748: LD_STRING Dietrich
3750: PPUSH
3751: CALL_OW 25
3755: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3756: LD_EXP 45
3760: PPUSH
3761: LD_INT 94
3763: PPUSH
3764: CALL_OW 52
// end ; InitHc ;
3768: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3772: LD_ADDR_EXP 41
3776: PUSH
3777: EMPTY
3778: ST_TO_ADDR
// for i = 1 to 5 do
3779: LD_ADDR_VAR 0 2
3783: PUSH
3784: DOUBLE
3785: LD_INT 1
3787: DEC
3788: ST_TO_ADDR
3789: LD_INT 5
3791: PUSH
3792: FOR_TO
3793: IFFALSE 3965
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3795: LD_INT 13
3797: PUSH
3798: LD_INT 14
3800: PUSH
3801: EMPTY
3802: LIST
3803: LIST
3804: PUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 2
3810: PPUSH
3811: CALL_OW 12
3815: ARRAY
3816: PPUSH
3817: LD_INT 1
3819: PUSH
3820: LD_INT 2
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: PUSH
3827: LD_INT 1
3829: PPUSH
3830: LD_INT 2
3832: PPUSH
3833: CALL_OW 12
3837: ARRAY
3838: PPUSH
3839: LD_INT 1
3841: PPUSH
3842: LD_INT 25
3844: PUSH
3845: LD_INT 27
3847: PUSH
3848: LD_INT 26
3850: PUSH
3851: EMPTY
3852: LIST
3853: LIST
3854: LIST
3855: PUSH
3856: LD_INT 1
3858: PPUSH
3859: LD_INT 3
3861: PPUSH
3862: CALL_OW 12
3866: ARRAY
3867: PPUSH
3868: LD_INT 60
3870: PPUSH
3871: LD_INT 100
3873: PPUSH
3874: CALL_OW 12
3878: PPUSH
3879: CALL 52245 0 5
// un := CreateVehicle ;
3883: LD_ADDR_VAR 0 4
3887: PUSH
3888: CALL_OW 45
3892: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3893: LD_ADDR_EXP 41
3897: PUSH
3898: LD_EXP 41
3902: PPUSH
3903: LD_EXP 41
3907: PUSH
3908: LD_INT 1
3910: PLUS
3911: PPUSH
3912: LD_VAR 0 4
3916: PPUSH
3917: CALL_OW 1
3921: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3922: LD_VAR 0 4
3926: PPUSH
3927: LD_INT 0
3929: PPUSH
3930: LD_INT 5
3932: PPUSH
3933: CALL_OW 12
3937: PPUSH
3938: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
3942: LD_VAR 0 4
3946: PPUSH
3947: LD_INT 124
3949: PPUSH
3950: LD_INT 141
3952: PPUSH
3953: LD_INT 8
3955: PPUSH
3956: LD_INT 0
3958: PPUSH
3959: CALL_OW 50
// end ;
3963: GO 3792
3965: POP
3966: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3967: LD_ADDR_EXP 43
3971: PUSH
3972: EMPTY
3973: PUSH
3974: EMPTY
3975: PUSH
3976: EMPTY
3977: PUSH
3978: EMPTY
3979: LIST
3980: LIST
3981: LIST
3982: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3983: LD_ADDR_VAR 0 3
3987: PUSH
3988: DOUBLE
3989: LD_INT 1
3991: DEC
3992: ST_TO_ADDR
3993: LD_INT 3
3995: PUSH
3996: LD_INT 3
3998: PUSH
3999: LD_INT 4
4001: PUSH
4002: EMPTY
4003: LIST
4004: LIST
4005: LIST
4006: PUSH
4007: LD_OWVAR 67
4011: ARRAY
4012: PUSH
4013: FOR_TO
4014: IFFALSE 4228
// for i = 1 to 3 do
4016: LD_ADDR_VAR 0 2
4020: PUSH
4021: DOUBLE
4022: LD_INT 1
4024: DEC
4025: ST_TO_ADDR
4026: LD_INT 3
4028: PUSH
4029: FOR_TO
4030: IFFALSE 4224
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4032: LD_INT 14
4034: PPUSH
4035: LD_INT 3
4037: PUSH
4038: LD_INT 2
4040: PUSH
4041: EMPTY
4042: LIST
4043: LIST
4044: PUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 2
4050: PPUSH
4051: CALL_OW 12
4055: ARRAY
4056: PPUSH
4057: LD_INT 1
4059: PUSH
4060: LD_INT 5
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: PUSH
4067: LD_INT 1
4069: PPUSH
4070: LD_INT 2
4072: PPUSH
4073: CALL_OW 12
4077: ARRAY
4078: PPUSH
4079: LD_INT 25
4081: PUSH
4082: LD_INT 27
4084: PUSH
4085: LD_INT 26
4087: PUSH
4088: LD_INT 28
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: LIST
4095: LIST
4096: PUSH
4097: LD_INT 1
4099: PPUSH
4100: LD_INT 4
4102: PPUSH
4103: CALL_OW 12
4107: ARRAY
4108: PPUSH
4109: LD_INT 100
4111: PPUSH
4112: CALL 52245 0 5
// un := CreateVehicle ;
4116: LD_ADDR_VAR 0 4
4120: PUSH
4121: CALL_OW 45
4125: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4126: LD_ADDR_EXP 43
4130: PUSH
4131: LD_EXP 43
4135: PPUSH
4136: LD_VAR 0 2
4140: PUSH
4141: LD_EXP 43
4145: PUSH
4146: LD_VAR 0 2
4150: ARRAY
4151: PUSH
4152: LD_INT 1
4154: PLUS
4155: PUSH
4156: EMPTY
4157: LIST
4158: LIST
4159: PPUSH
4160: LD_VAR 0 4
4164: PPUSH
4165: CALL 52367 0 3
4169: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4170: LD_VAR 0 4
4174: PPUSH
4175: LD_INT 0
4177: PPUSH
4178: LD_INT 5
4180: PPUSH
4181: CALL_OW 12
4185: PPUSH
4186: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4190: LD_VAR 0 4
4194: PPUSH
4195: LD_INT 20
4197: PUSH
4198: LD_INT 21
4200: PUSH
4201: LD_INT 22
4203: PUSH
4204: EMPTY
4205: LIST
4206: LIST
4207: LIST
4208: PUSH
4209: LD_VAR 0 2
4213: ARRAY
4214: PPUSH
4215: LD_INT 0
4217: PPUSH
4218: CALL_OW 49
// end ;
4222: GO 4029
4224: POP
4225: POP
4226: GO 4013
4228: POP
4229: POP
// InitHc ;
4230: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4234: LD_INT 4
4236: PPUSH
4237: LD_INT 5
4239: PPUSH
4240: LD_INT 10
4242: PPUSH
4243: LD_INT 5
4245: PPUSH
4246: LD_INT 0
4248: PPUSH
4249: CALL_OW 58
// end ;
4253: LD_VAR 0 1
4257: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4258: LD_EXP 42
4262: IFFALSE 4336
4264: GO 4266
4266: DISABLE
4267: LD_INT 0
4269: PPUSH
// begin enable ;
4270: ENABLE
// for i in ar_kamikadze do
4271: LD_ADDR_VAR 0 1
4275: PUSH
4276: LD_EXP 42
4280: PUSH
4281: FOR_IN
4282: IFFALSE 4334
// if See ( 1 , i ) then
4284: LD_INT 1
4286: PPUSH
4287: LD_VAR 0 1
4291: PPUSH
4292: CALL_OW 292
4296: IFFALSE 4332
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4298: LD_VAR 0 1
4302: PPUSH
4303: LD_INT 81
4305: PUSH
4306: LD_INT 2
4308: PUSH
4309: EMPTY
4310: LIST
4311: LIST
4312: PPUSH
4313: CALL_OW 69
4317: PPUSH
4318: LD_VAR 0 1
4322: PPUSH
4323: CALL_OW 74
4327: PPUSH
4328: CALL_OW 115
4332: GO 4281
4334: POP
4335: POP
// end ;
4336: PPOPN 1
4338: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4339: LD_EXP 13
4343: IFFALSE 4660
4345: GO 4347
4347: DISABLE
4348: LD_INT 0
4350: PPUSH
4351: PPUSH
4352: PPUSH
4353: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4354: LD_INT 35
4356: PPUSH
4357: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4361: LD_INT 1
4363: PPUSH
4364: CALL 41425 0 1
4368: PUSH
4369: LD_INT 0
4371: EQUAL
4372: IFFALSE 4354
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4374: LD_INT 1
4376: PPUSH
4377: LD_INT 14
4379: PUSH
4380: LD_INT 3
4382: PUSH
4383: LD_INT 2
4385: PUSH
4386: LD_INT 32
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: PUSH
4395: EMPTY
4396: LIST
4397: PPUSH
4398: CALL 41029 0 2
// repeat wait ( 0 0$1 ) ;
4402: LD_INT 35
4404: PPUSH
4405: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4409: LD_EXP 69
4413: PUSH
4414: LD_INT 1
4416: ARRAY
4417: PPUSH
4418: LD_INT 33
4420: PUSH
4421: LD_INT 2
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: LD_INT 34
4430: PUSH
4431: LD_INT 32
4433: PUSH
4434: EMPTY
4435: LIST
4436: LIST
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: PPUSH
4442: CALL_OW 72
4446: IFFALSE 4402
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4448: LD_ADDR_VAR 0 2
4452: PUSH
4453: LD_EXP 69
4457: PUSH
4458: LD_INT 1
4460: ARRAY
4461: PPUSH
4462: LD_INT 33
4464: PUSH
4465: LD_INT 2
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PUSH
4472: LD_INT 34
4474: PUSH
4475: LD_INT 32
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: EMPTY
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 72
4490: PUSH
4491: LD_INT 1
4493: ARRAY
4494: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4495: LD_ADDR_VAR 0 4
4499: PUSH
4500: LD_INT 5
4502: PPUSH
4503: CALL_OW 469
4507: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4508: LD_INT 35
4510: PPUSH
4511: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4515: LD_ADDR_VAR 0 4
4519: PUSH
4520: LD_INT 5
4522: PPUSH
4523: CALL_OW 469
4527: ST_TO_ADDR
// tmp := 100 ;
4528: LD_ADDR_VAR 0 3
4532: PUSH
4533: LD_INT 100
4535: ST_TO_ADDR
// if pos then
4536: LD_VAR 0 4
4540: IFFALSE 4580
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4542: LD_ADDR_VAR 0 3
4546: PUSH
4547: LD_INT 2
4549: PPUSH
4550: LD_VAR 0 4
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_VAR 0 4
4563: PUSH
4564: LD_INT 2
4566: ARRAY
4567: PPUSH
4568: LD_INT 20
4570: PPUSH
4571: CALL 53263 0 4
4575: PUSH
4576: LD_INT 4
4578: ARRAY
4579: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4580: LD_VAR 0 4
4584: PUSH
4585: LD_EXP 14
4589: NOT
4590: AND
4591: PUSH
4592: LD_VAR 0 3
4596: PUSH
4597: LD_INT 10
4599: LESS
4600: AND
4601: IFFALSE 4508
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4603: LD_VAR 0 2
4607: PPUSH
4608: LD_VAR 0 4
4612: PUSH
4613: LD_INT 1
4615: ARRAY
4616: PPUSH
4617: LD_VAR 0 4
4621: PUSH
4622: LD_INT 2
4624: ARRAY
4625: PPUSH
4626: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4630: LD_VAR 0 2
4634: PPUSH
4635: LD_INT 198
4637: PPUSH
4638: LD_INT 113
4640: PPUSH
4641: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4645: LD_VAR 0 2
4649: PPUSH
4650: LD_INT 124
4652: PPUSH
4653: LD_INT 7
4655: PPUSH
4656: CALL_OW 171
// end ;
4660: PPOPN 4
4662: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4663: LD_EXP 6
4667: IFFALSE 7448
4669: GO 4671
4671: DISABLE
4672: LD_INT 0
4674: PPUSH
4675: PPUSH
4676: PPUSH
4677: PPUSH
4678: PPUSH
4679: PPUSH
4680: PPUSH
4681: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4682: LD_ADDR_VAR 0 4
4686: PUSH
4687: LD_INT 5
4689: PUSH
4690: LD_INT 6
4692: PUSH
4693: LD_INT 7
4695: PUSH
4696: EMPTY
4697: LIST
4698: LIST
4699: LIST
4700: PUSH
4701: LD_OWVAR 67
4705: ARRAY
4706: ST_TO_ADDR
// coords := [ ] ;
4707: LD_ADDR_VAR 0 5
4711: PUSH
4712: EMPTY
4713: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4714: LD_ADDR_VAR 0 6
4718: PUSH
4719: LD_INT 0
4721: PUSH
4722: LD_INT 0
4724: PUSH
4725: LD_INT 0
4727: PUSH
4728: LD_INT 0
4730: PUSH
4731: LD_INT 1
4733: PUSH
4734: LD_INT 0
4736: PUSH
4737: LD_INT 0
4739: PUSH
4740: LD_INT 0
4742: PUSH
4743: LD_INT 1
4745: PUSH
4746: LD_INT 0
4748: PUSH
4749: EMPTY
4750: LIST
4751: LIST
4752: LIST
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4761: LD_INT 1
4763: PPUSH
4764: LD_INT 14
4766: PUSH
4767: LD_INT 1
4769: PUSH
4770: LD_INT 2
4772: PUSH
4773: LD_INT 28
4775: PUSH
4776: EMPTY
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: PUSH
4782: LD_INT 14
4784: PUSH
4785: LD_INT 1
4787: PUSH
4788: LD_INT 2
4790: PUSH
4791: LD_INT 25
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: LIST
4798: LIST
4799: PUSH
4800: LD_INT 14
4802: PUSH
4803: LD_INT 1
4805: PUSH
4806: LD_INT 2
4808: PUSH
4809: LD_INT 28
4811: PUSH
4812: EMPTY
4813: LIST
4814: LIST
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 14
4820: PUSH
4821: LD_INT 1
4823: PUSH
4824: LD_INT 2
4826: PUSH
4827: LD_INT 29
4829: PUSH
4830: EMPTY
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: PUSH
4836: EMPTY
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: PPUSH
4842: CALL 41029 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4846: LD_INT 21000
4848: PUSH
4849: LD_INT 19950
4851: PUSH
4852: LD_INT 18900
4854: PUSH
4855: EMPTY
4856: LIST
4857: LIST
4858: LIST
4859: PUSH
4860: LD_OWVAR 67
4864: ARRAY
4865: PPUSH
4866: CALL_OW 67
// InitHc ;
4870: CALL_OW 19
// InitUc ;
4874: CALL_OW 18
// uc_side := 2 ;
4878: LD_ADDR_OWVAR 20
4882: PUSH
4883: LD_INT 2
4885: ST_TO_ADDR
// uc_nation := 2 ;
4886: LD_ADDR_OWVAR 21
4890: PUSH
4891: LD_INT 2
4893: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4894: LD_ADDR_VAR 0 3
4898: PUSH
4899: EMPTY
4900: PUSH
4901: EMPTY
4902: PUSH
4903: EMPTY
4904: PUSH
4905: EMPTY
4906: PUSH
4907: EMPTY
4908: PUSH
4909: EMPTY
4910: LIST
4911: LIST
4912: LIST
4913: LIST
4914: LIST
4915: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4916: LD_ADDR_VAR 0 3
4920: PUSH
4921: LD_VAR 0 3
4925: PPUSH
4926: LD_INT 1
4928: PPUSH
4929: LD_EXP 69
4933: PUSH
4934: LD_INT 1
4936: ARRAY
4937: PUSH
4938: LD_INT 34
4940: PUSH
4941: LD_INT 32
4943: PUSH
4944: EMPTY
4945: LIST
4946: LIST
4947: PPUSH
4948: CALL_OW 69
4952: DIFF
4953: PPUSH
4954: CALL_OW 1
4958: ST_TO_ADDR
// for i = 1 to Difficulty do
4959: LD_ADDR_VAR 0 1
4963: PUSH
4964: DOUBLE
4965: LD_INT 1
4967: DEC
4968: ST_TO_ADDR
4969: LD_OWVAR 67
4973: PUSH
4974: FOR_TO
4975: IFFALSE 5113
// begin uc_side := 2 ;
4977: LD_ADDR_OWVAR 20
4981: PUSH
4982: LD_INT 2
4984: ST_TO_ADDR
// uc_nation := 2 ;
4985: LD_ADDR_OWVAR 21
4989: PUSH
4990: LD_INT 2
4992: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4993: LD_INT 13
4995: PPUSH
4996: LD_INT 3
4998: PPUSH
4999: LD_INT 5
5001: PPUSH
5002: LD_INT 29
5004: PPUSH
5005: LD_INT 100
5007: PPUSH
5008: CALL 52245 0 5
// un := CreateVehicle ;
5012: LD_ADDR_VAR 0 2
5016: PUSH
5017: CALL_OW 45
5021: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5022: LD_ADDR_VAR 0 3
5026: PUSH
5027: LD_VAR 0 3
5031: PPUSH
5032: LD_INT 1
5034: PUSH
5035: LD_VAR 0 3
5039: PUSH
5040: LD_INT 1
5042: ARRAY
5043: PUSH
5044: LD_INT 1
5046: PLUS
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PPUSH
5052: LD_VAR 0 2
5056: PPUSH
5057: CALL 52367 0 3
5061: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5062: LD_VAR 0 2
5066: PPUSH
5067: LD_INT 3
5069: PPUSH
5070: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5074: LD_VAR 0 2
5078: PPUSH
5079: LD_INT 16
5081: PPUSH
5082: LD_INT 0
5084: PPUSH
5085: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5089: LD_VAR 0 2
5093: PPUSH
5094: LD_INT 51
5096: PPUSH
5097: LD_INT 10
5099: PPUSH
5100: CALL_OW 111
// wait ( 0 0$2 ) ;
5104: LD_INT 70
5106: PPUSH
5107: CALL_OW 67
// end ;
5111: GO 4974
5113: POP
5114: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5115: LD_ADDR_VAR 0 5
5119: PUSH
5120: LD_INT 51
5122: PUSH
5123: LD_INT 24
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: LD_INT 75
5132: PUSH
5133: LD_INT 90
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5144: LD_INT 1
5146: PPUSH
5147: LD_VAR 0 3
5151: PUSH
5152: LD_INT 1
5154: ARRAY
5155: PPUSH
5156: LD_VAR 0 5
5160: PPUSH
5161: LD_VAR 0 6
5165: PPUSH
5166: CALL 41262 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5170: LD_ADDR_VAR 0 1
5174: PUSH
5175: DOUBLE
5176: LD_INT 1
5178: DEC
5179: ST_TO_ADDR
5180: LD_INT 1
5182: PUSH
5183: LD_INT 3
5185: PUSH
5186: LD_INT 3
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_OWVAR 67
5198: ARRAY
5199: PUSH
5200: FOR_TO
5201: IFFALSE 5301
// begin uc_side := 2 ;
5203: LD_ADDR_OWVAR 20
5207: PUSH
5208: LD_INT 2
5210: ST_TO_ADDR
// uc_nation := 2 ;
5211: LD_ADDR_OWVAR 21
5215: PUSH
5216: LD_INT 2
5218: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5219: LD_INT 0
5221: PPUSH
5222: LD_INT 17
5224: PPUSH
5225: LD_VAR 0 4
5229: PPUSH
5230: CALL_OW 380
// un := CreateHuman ;
5234: LD_ADDR_VAR 0 2
5238: PUSH
5239: CALL_OW 44
5243: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5244: LD_ADDR_VAR 0 3
5248: PUSH
5249: LD_VAR 0 3
5253: PPUSH
5254: LD_INT 2
5256: PUSH
5257: LD_VAR 0 3
5261: PUSH
5262: LD_INT 2
5264: ARRAY
5265: PUSH
5266: LD_INT 1
5268: PLUS
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: PPUSH
5274: LD_VAR 0 2
5278: PPUSH
5279: CALL 52367 0 3
5283: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5284: LD_VAR 0 2
5288: PPUSH
5289: LD_INT 13
5291: PPUSH
5292: LD_INT 0
5294: PPUSH
5295: CALL_OW 49
// end ;
5299: GO 5200
5301: POP
5302: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5303: LD_ADDR_VAR 0 1
5307: PUSH
5308: DOUBLE
5309: LD_INT 1
5311: DEC
5312: ST_TO_ADDR
5313: LD_INT 3
5315: PUSH
5316: LD_INT 4
5318: PUSH
5319: LD_INT 4
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: LIST
5326: PUSH
5327: LD_OWVAR 67
5331: ARRAY
5332: PUSH
5333: FOR_TO
5334: IFFALSE 5455
// begin uc_side := 2 ;
5336: LD_ADDR_OWVAR 20
5340: PUSH
5341: LD_INT 2
5343: ST_TO_ADDR
// uc_nation := 2 ;
5344: LD_ADDR_OWVAR 21
5348: PUSH
5349: LD_INT 2
5351: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5352: LD_INT 0
5354: PPUSH
5355: LD_INT 1
5357: PUSH
5358: LD_INT 8
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: PUSH
5365: LD_VAR 0 1
5369: PUSH
5370: LD_INT 2
5372: MOD
5373: PUSH
5374: LD_INT 1
5376: PLUS
5377: ARRAY
5378: PPUSH
5379: LD_VAR 0 4
5383: PPUSH
5384: CALL_OW 380
// un := CreateHuman ;
5388: LD_ADDR_VAR 0 2
5392: PUSH
5393: CALL_OW 44
5397: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5398: LD_ADDR_VAR 0 3
5402: PUSH
5403: LD_VAR 0 3
5407: PPUSH
5408: LD_INT 2
5410: PUSH
5411: LD_VAR 0 3
5415: PUSH
5416: LD_INT 2
5418: ARRAY
5419: PUSH
5420: LD_INT 1
5422: PLUS
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: PPUSH
5428: LD_VAR 0 2
5432: PPUSH
5433: CALL 52367 0 3
5437: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5438: LD_VAR 0 2
5442: PPUSH
5443: LD_INT 13
5445: PPUSH
5446: LD_INT 0
5448: PPUSH
5449: CALL_OW 49
// end ;
5453: GO 5333
5455: POP
5456: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5457: LD_ADDR_VAR 0 5
5461: PUSH
5462: LD_INT 67
5464: PUSH
5465: LD_INT 112
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: PUSH
5472: LD_INT 85
5474: PUSH
5475: LD_INT 130
5477: PUSH
5478: EMPTY
5479: LIST
5480: LIST
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5486: LD_INT 2
5488: PPUSH
5489: LD_VAR 0 3
5493: PUSH
5494: LD_INT 2
5496: ARRAY
5497: PPUSH
5498: LD_VAR 0 5
5502: PPUSH
5503: LD_VAR 0 6
5507: PPUSH
5508: CALL 41262 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5512: LD_ADDR_VAR 0 1
5516: PUSH
5517: DOUBLE
5518: LD_INT 1
5520: DEC
5521: ST_TO_ADDR
5522: LD_INT 1
5524: PUSH
5525: LD_INT 2
5527: PUSH
5528: LD_INT 3
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: PUSH
5536: LD_OWVAR 67
5540: ARRAY
5541: PUSH
5542: FOR_TO
5543: IFFALSE 5643
// begin uc_side := 2 ;
5545: LD_ADDR_OWVAR 20
5549: PUSH
5550: LD_INT 2
5552: ST_TO_ADDR
// uc_nation := 2 ;
5553: LD_ADDR_OWVAR 21
5557: PUSH
5558: LD_INT 2
5560: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5561: LD_INT 0
5563: PPUSH
5564: LD_INT 17
5566: PPUSH
5567: LD_VAR 0 4
5571: PPUSH
5572: CALL_OW 380
// un := CreateHuman ;
5576: LD_ADDR_VAR 0 2
5580: PUSH
5581: CALL_OW 44
5585: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5586: LD_ADDR_VAR 0 3
5590: PUSH
5591: LD_VAR 0 3
5595: PPUSH
5596: LD_INT 3
5598: PUSH
5599: LD_VAR 0 3
5603: PUSH
5604: LD_INT 3
5606: ARRAY
5607: PUSH
5608: LD_INT 1
5610: PLUS
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PPUSH
5616: LD_VAR 0 2
5620: PPUSH
5621: CALL 52367 0 3
5625: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5626: LD_VAR 0 2
5630: PPUSH
5631: LD_INT 14
5633: PPUSH
5634: LD_INT 0
5636: PPUSH
5637: CALL_OW 49
// end ;
5641: GO 5542
5643: POP
5644: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5645: LD_ADDR_VAR 0 5
5649: PUSH
5650: LD_INT 148
5652: PUSH
5653: LD_INT 158
5655: PUSH
5656: EMPTY
5657: LIST
5658: LIST
5659: PUSH
5660: LD_INT 148
5662: PUSH
5663: LD_INT 158
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5674: LD_INT 3
5676: PPUSH
5677: LD_VAR 0 3
5681: PUSH
5682: LD_INT 3
5684: ARRAY
5685: PPUSH
5686: LD_VAR 0 5
5690: PPUSH
5691: LD_VAR 0 6
5695: PPUSH
5696: CALL 41262 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
5700: LD_ADDR_VAR 0 1
5704: PUSH
5705: DOUBLE
5706: LD_INT 1
5708: DEC
5709: ST_TO_ADDR
5710: LD_INT 2
5712: PUSH
5713: LD_INT 4
5715: PUSH
5716: LD_INT 4
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: LIST
5723: PUSH
5724: LD_OWVAR 67
5728: ARRAY
5729: PUSH
5730: FOR_TO
5731: IFFALSE 5955
// begin uc_side := 2 ;
5733: LD_ADDR_OWVAR 20
5737: PUSH
5738: LD_INT 2
5740: ST_TO_ADDR
// uc_nation := 2 ;
5741: LD_ADDR_OWVAR 21
5745: PUSH
5746: LD_INT 2
5748: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5749: LD_INT 14
5751: PPUSH
5752: LD_INT 3
5754: PPUSH
5755: LD_INT 1
5757: PUSH
5758: LD_INT 5
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 1
5767: PPUSH
5768: LD_INT 2
5770: PPUSH
5771: CALL_OW 12
5775: ARRAY
5776: PPUSH
5777: LD_INT 27
5779: PUSH
5780: LD_INT 26
5782: PUSH
5783: LD_INT 28
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 1
5793: PPUSH
5794: LD_INT 3
5796: PPUSH
5797: CALL_OW 12
5801: ARRAY
5802: PPUSH
5803: LD_INT 100
5805: PPUSH
5806: CALL 52245 0 5
// un := CreateVehicle ;
5810: LD_ADDR_VAR 0 2
5814: PUSH
5815: CALL_OW 45
5819: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5820: LD_ADDR_VAR 0 3
5824: PUSH
5825: LD_VAR 0 3
5829: PPUSH
5830: LD_INT 4
5832: PUSH
5833: LD_VAR 0 3
5837: PUSH
5838: LD_INT 4
5840: ARRAY
5841: PUSH
5842: LD_INT 1
5844: PLUS
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: PPUSH
5850: LD_VAR 0 2
5854: PPUSH
5855: CALL 52367 0 3
5859: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5860: LD_VAR 0 2
5864: PPUSH
5865: LD_INT 5
5867: PPUSH
5868: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5872: LD_VAR 0 2
5876: PPUSH
5877: LD_INT 15
5879: PPUSH
5880: LD_INT 0
5882: PPUSH
5883: CALL_OW 49
// if GetControl ( un ) = control_manual then
5887: LD_VAR 0 2
5891: PPUSH
5892: CALL_OW 263
5896: PUSH
5897: LD_INT 1
5899: EQUAL
5900: IFFALSE 5931
// begin PrepareHuman ( false , 3 , skill ) ;
5902: LD_INT 0
5904: PPUSH
5905: LD_INT 3
5907: PPUSH
5908: LD_VAR 0 4
5912: PPUSH
5913: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5917: CALL_OW 44
5921: PPUSH
5922: LD_VAR 0 2
5926: PPUSH
5927: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5931: LD_VAR 0 2
5935: PPUSH
5936: LD_INT 179
5938: PPUSH
5939: LD_INT 135
5941: PPUSH
5942: CALL_OW 111
// wait ( 0 0$2 ) ;
5946: LD_INT 70
5948: PPUSH
5949: CALL_OW 67
// end ;
5953: GO 5730
5955: POP
5956: POP
// vc_chassis := 15 ;
5957: LD_ADDR_OWVAR 37
5961: PUSH
5962: LD_INT 15
5964: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5965: LD_ADDR_VAR 0 3
5969: PUSH
5970: LD_VAR 0 3
5974: PPUSH
5975: LD_INT 4
5977: PUSH
5978: LD_VAR 0 3
5982: PUSH
5983: LD_INT 4
5985: ARRAY
5986: PUSH
5987: LD_INT 1
5989: PLUS
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PPUSH
5995: CALL_OW 45
5999: PPUSH
6000: CALL 52367 0 3
6004: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6005: LD_VAR 0 3
6009: PUSH
6010: LD_INT 4
6012: ARRAY
6013: PUSH
6014: LD_VAR 0 3
6018: PUSH
6019: LD_INT 4
6021: ARRAY
6022: ARRAY
6023: PPUSH
6024: LD_INT 15
6026: PPUSH
6027: LD_INT 0
6029: PPUSH
6030: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6034: LD_INT 0
6036: PPUSH
6037: LD_INT 11
6039: PPUSH
6040: LD_VAR 0 4
6044: PPUSH
6045: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6049: LD_ADDR_VAR 0 3
6053: PUSH
6054: LD_VAR 0 3
6058: PPUSH
6059: LD_INT 4
6061: PUSH
6062: LD_VAR 0 3
6066: PUSH
6067: LD_INT 4
6069: ARRAY
6070: PUSH
6071: LD_INT 1
6073: PLUS
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: PPUSH
6079: CALL_OW 44
6083: PPUSH
6084: CALL 52367 0 3
6088: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6089: LD_VAR 0 3
6093: PUSH
6094: LD_INT 4
6096: ARRAY
6097: PUSH
6098: LD_VAR 0 3
6102: PUSH
6103: LD_INT 4
6105: ARRAY
6106: ARRAY
6107: PPUSH
6108: LD_VAR 0 3
6112: PUSH
6113: LD_INT 4
6115: ARRAY
6116: PUSH
6117: LD_VAR 0 3
6121: PUSH
6122: LD_INT 4
6124: ARRAY
6125: PUSH
6126: LD_INT 1
6128: MINUS
6129: ARRAY
6130: PPUSH
6131: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6135: LD_ADDR_VAR 0 5
6139: PUSH
6140: LD_INT 148
6142: PUSH
6143: LD_INT 140
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: PUSH
6150: EMPTY
6151: LIST
6152: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6153: LD_INT 1
6155: PPUSH
6156: LD_VAR 0 3
6160: PUSH
6161: LD_INT 4
6163: ARRAY
6164: PPUSH
6165: LD_VAR 0 5
6169: PPUSH
6170: LD_VAR 0 6
6174: PPUSH
6175: CALL 41262 0 4
// if gensher_active then
6179: LD_EXP 18
6183: IFFALSE 6585
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6185: LD_EXP 45
6189: PPUSH
6190: LD_STRING D10-Diet-1
6192: PPUSH
6193: CALL_OW 94
// for i = 1 to 2 do
6197: LD_ADDR_VAR 0 1
6201: PUSH
6202: DOUBLE
6203: LD_INT 1
6205: DEC
6206: ST_TO_ADDR
6207: LD_INT 2
6209: PUSH
6210: FOR_TO
6211: IFFALSE 6349
// begin uc_side := 2 ;
6213: LD_ADDR_OWVAR 20
6217: PUSH
6218: LD_INT 2
6220: ST_TO_ADDR
// uc_nation := 2 ;
6221: LD_ADDR_OWVAR 21
6225: PUSH
6226: LD_INT 2
6228: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6229: LD_INT 13
6231: PPUSH
6232: LD_INT 3
6234: PPUSH
6235: LD_INT 5
6237: PPUSH
6238: LD_INT 29
6240: PPUSH
6241: LD_INT 100
6243: PPUSH
6244: CALL 52245 0 5
// un := CreateVehicle ;
6248: LD_ADDR_VAR 0 2
6252: PUSH
6253: CALL_OW 45
6257: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6258: LD_ADDR_VAR 0 3
6262: PUSH
6263: LD_VAR 0 3
6267: PPUSH
6268: LD_INT 5
6270: PUSH
6271: LD_VAR 0 3
6275: PUSH
6276: LD_INT 5
6278: ARRAY
6279: PUSH
6280: LD_INT 1
6282: PLUS
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: PPUSH
6288: LD_VAR 0 2
6292: PPUSH
6293: CALL 52367 0 3
6297: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6298: LD_VAR 0 2
6302: PPUSH
6303: LD_INT 0
6305: PPUSH
6306: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6310: LD_VAR 0 2
6314: PPUSH
6315: LD_INT 23
6317: PPUSH
6318: LD_INT 0
6320: PPUSH
6321: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6325: LD_VAR 0 2
6329: PPUSH
6330: LD_INT 85
6332: PPUSH
6333: LD_INT 152
6335: PPUSH
6336: CALL_OW 111
// wait ( 0 0$2 ) ;
6340: LD_INT 70
6342: PPUSH
6343: CALL_OW 67
// end ;
6347: GO 6210
6349: POP
6350: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6351: LD_ADDR_VAR 0 1
6355: PUSH
6356: DOUBLE
6357: LD_INT 1
6359: DEC
6360: ST_TO_ADDR
6361: LD_INT 2
6363: PUSH
6364: LD_INT 3
6366: PUSH
6367: LD_INT 3
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: LD_OWVAR 67
6379: ARRAY
6380: PUSH
6381: FOR_TO
6382: IFFALSE 6539
// begin uc_side := 2 ;
6384: LD_ADDR_OWVAR 20
6388: PUSH
6389: LD_INT 2
6391: ST_TO_ADDR
// uc_nation := 2 ;
6392: LD_ADDR_OWVAR 21
6396: PUSH
6397: LD_INT 2
6399: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6400: LD_INT 14
6402: PPUSH
6403: LD_INT 3
6405: PPUSH
6406: LD_INT 5
6408: PPUSH
6409: LD_INT 27
6411: PUSH
6412: LD_INT 28
6414: PUSH
6415: EMPTY
6416: LIST
6417: LIST
6418: PUSH
6419: LD_INT 1
6421: PPUSH
6422: LD_INT 2
6424: PPUSH
6425: CALL_OW 12
6429: ARRAY
6430: PPUSH
6431: LD_INT 100
6433: PPUSH
6434: CALL 52245 0 5
// un := CreateVehicle ;
6438: LD_ADDR_VAR 0 2
6442: PUSH
6443: CALL_OW 45
6447: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6448: LD_ADDR_VAR 0 3
6452: PUSH
6453: LD_VAR 0 3
6457: PPUSH
6458: LD_INT 5
6460: PUSH
6461: LD_VAR 0 3
6465: PUSH
6466: LD_INT 5
6468: ARRAY
6469: PUSH
6470: LD_INT 1
6472: PLUS
6473: PUSH
6474: EMPTY
6475: LIST
6476: LIST
6477: PPUSH
6478: LD_VAR 0 2
6482: PPUSH
6483: CALL 52367 0 3
6487: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6488: LD_VAR 0 2
6492: PPUSH
6493: LD_INT 0
6495: PPUSH
6496: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6500: LD_VAR 0 2
6504: PPUSH
6505: LD_INT 23
6507: PPUSH
6508: LD_INT 0
6510: PPUSH
6511: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6515: LD_VAR 0 2
6519: PPUSH
6520: LD_INT 85
6522: PPUSH
6523: LD_INT 152
6525: PPUSH
6526: CALL_OW 111
// wait ( 0 0$2 ) ;
6530: LD_INT 70
6532: PPUSH
6533: CALL_OW 67
// end ;
6537: GO 6381
6539: POP
6540: POP
// coords := [ [ 97 , 143 ] ] ;
6541: LD_ADDR_VAR 0 5
6545: PUSH
6546: LD_INT 97
6548: PUSH
6549: LD_INT 143
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: PUSH
6556: EMPTY
6557: LIST
6558: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6559: LD_INT 1
6561: PPUSH
6562: LD_VAR 0 3
6566: PUSH
6567: LD_INT 5
6569: ARRAY
6570: PPUSH
6571: LD_VAR 0 5
6575: PPUSH
6576: LD_VAR 0 6
6580: PPUSH
6581: CALL 41262 0 4
// end ; Wait ( 13 13$00 ) ;
6585: LD_INT 27300
6587: PPUSH
6588: CALL_OW 67
// tmp := [ ] ;
6592: LD_ADDR_VAR 0 3
6596: PUSH
6597: EMPTY
6598: ST_TO_ADDR
// w := 1 ;
6599: LD_ADDR_VAR 0 7
6603: PUSH
6604: LD_INT 1
6606: ST_TO_ADDR
// repeat tmp := [ ] ;
6607: LD_ADDR_VAR 0 3
6611: PUSH
6612: EMPTY
6613: ST_TO_ADDR
// if w mod 4 = 0 then
6614: LD_VAR 0 7
6618: PUSH
6619: LD_INT 4
6621: MOD
6622: PUSH
6623: LD_INT 0
6625: EQUAL
6626: IFFALSE 6713
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6628: LD_ADDR_VAR 0 8
6632: PUSH
6633: LD_INT 11
6635: PUSH
6636: LD_INT 1
6638: PUSH
6639: LD_INT 2
6641: PUSH
6642: LD_INT 24
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 11
6653: PUSH
6654: LD_INT 1
6656: PUSH
6657: LD_INT 2
6659: PUSH
6660: LD_INT 24
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 11
6671: PUSH
6672: LD_INT 1
6674: PUSH
6675: LD_INT 2
6677: PUSH
6678: LD_INT 24
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 11
6689: PUSH
6690: LD_INT 1
6692: PUSH
6693: LD_INT 2
6695: PUSH
6696: LD_INT 24
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: EMPTY
6706: LIST
6707: LIST
6708: LIST
6709: LIST
6710: ST_TO_ADDR
6711: GO 6815
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6713: LD_ADDR_VAR 0 8
6717: PUSH
6718: LD_INT 14
6720: PUSH
6721: LD_INT 1
6723: PUSH
6724: LD_INT 2
6726: PUSH
6727: LD_INT 28
6729: PUSH
6730: EMPTY
6731: LIST
6732: LIST
6733: LIST
6734: LIST
6735: PUSH
6736: LD_INT 14
6738: PUSH
6739: LD_INT 1
6741: PUSH
6742: LD_INT 2
6744: PUSH
6745: LD_INT 25
6747: PUSH
6748: EMPTY
6749: LIST
6750: LIST
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 14
6756: PUSH
6757: LD_INT 1
6759: PUSH
6760: LD_INT 2
6762: PUSH
6763: LD_INT 28
6765: PUSH
6766: EMPTY
6767: LIST
6768: LIST
6769: LIST
6770: LIST
6771: PUSH
6772: LD_INT 14
6774: PUSH
6775: LD_INT 1
6777: PUSH
6778: LD_INT 2
6780: PUSH
6781: LD_INT 29
6783: PUSH
6784: EMPTY
6785: LIST
6786: LIST
6787: LIST
6788: LIST
6789: PUSH
6790: LD_INT 11
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: LD_INT 2
6798: PUSH
6799: LD_INT 24
6801: PUSH
6802: EMPTY
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: LIST
6812: LIST
6813: LIST
6814: ST_TO_ADDR
// if w mod 3 = 0 then
6815: LD_VAR 0 7
6819: PUSH
6820: LD_INT 3
6822: MOD
6823: PUSH
6824: LD_INT 0
6826: EQUAL
6827: IFFALSE 6903
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6829: LD_ADDR_VAR 0 8
6833: PUSH
6834: LD_VAR 0 8
6838: PPUSH
6839: LD_INT 1
6841: PUSH
6842: LD_VAR 0 8
6846: PUSH
6847: LD_VAR 0 1
6851: ARRAY
6852: PUSH
6853: LD_INT 1
6855: PLUS
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: LD_INT 14
6863: PUSH
6864: LD_INT 1
6866: PUSH
6867: LD_INT 2
6869: PUSH
6870: LD_INT 25
6872: PUSH
6873: LD_INT 28
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: PUSH
6880: LD_INT 1
6882: PPUSH
6883: LD_INT 2
6885: PPUSH
6886: CALL_OW 12
6890: ARRAY
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: LIST
6897: PPUSH
6898: CALL 52367 0 3
6902: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6903: LD_INT 1
6905: PPUSH
6906: LD_VAR 0 8
6910: PPUSH
6911: CALL 41029 0 2
// if GetSide ( ar_dep_w ) = 2 then
6915: LD_INT 45
6917: PPUSH
6918: CALL_OW 255
6922: PUSH
6923: LD_INT 2
6925: EQUAL
6926: IFFALSE 7011
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6928: LD_ADDR_VAR 0 8
6932: PUSH
6933: LD_INT 14
6935: PUSH
6936: LD_INT 1
6938: PUSH
6939: LD_INT 2
6941: PUSH
6942: LD_INT 28
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: LIST
6949: LIST
6950: PUSH
6951: LD_INT 14
6953: PUSH
6954: LD_INT 1
6956: PUSH
6957: LD_INT 2
6959: PUSH
6960: LD_INT 27
6962: PUSH
6963: EMPTY
6964: LIST
6965: LIST
6966: LIST
6967: LIST
6968: PUSH
6969: LD_INT 14
6971: PUSH
6972: LD_INT 1
6974: PUSH
6975: LD_INT 2
6977: PUSH
6978: LD_INT 27
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: LIST
6985: LIST
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: LIST
6991: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6992: LD_INT 2
6994: PPUSH
6995: LD_VAR 0 8
6999: PPUSH
7000: CALL 41029 0 2
// wait ( 0 0$50 ) ;
7004: LD_INT 1750
7006: PPUSH
7007: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7011: LD_INT 35
7013: PPUSH
7014: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
7018: LD_EXP 69
7022: PUSH
7023: LD_INT 1
7025: ARRAY
7026: PPUSH
7027: LD_INT 3
7029: PUSH
7030: LD_INT 34
7032: PUSH
7033: LD_INT 32
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PUSH
7040: EMPTY
7041: LIST
7042: LIST
7043: PPUSH
7044: CALL_OW 72
7048: PUSH
7049: LD_INT 4
7051: GREATEREQUAL
7052: IFFALSE 7011
// wait ( 0 0$10 ) ;
7054: LD_INT 350
7056: PPUSH
7057: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
7061: LD_ADDR_VAR 0 3
7065: PUSH
7066: LD_EXP 69
7070: PUSH
7071: LD_INT 1
7073: ARRAY
7074: PPUSH
7075: LD_INT 3
7077: PUSH
7078: LD_INT 34
7080: PUSH
7081: LD_INT 32
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PPUSH
7092: CALL_OW 72
7096: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7097: LD_INT 100
7099: PPUSH
7100: CALL_OW 13
7104: PUSH
7105: LD_INT 50
7107: LESS
7108: IFFALSE 7141
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7110: LD_ADDR_VAR 0 5
7114: PUSH
7115: LD_INT 55
7117: PUSH
7118: LD_INT 7
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 75
7127: PUSH
7128: LD_INT 90
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: ST_TO_ADDR
7139: GO 7170
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7141: LD_ADDR_VAR 0 5
7145: PUSH
7146: LD_INT 128
7148: PUSH
7149: LD_INT 94
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PUSH
7156: LD_INT 180
7158: PUSH
7159: LD_INT 135
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: ST_TO_ADDR
// if w mod 4 = 0 then
7170: LD_VAR 0 7
7174: PUSH
7175: LD_INT 4
7177: MOD
7178: PUSH
7179: LD_INT 0
7181: EQUAL
7182: IFFALSE 7213
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7184: LD_ADDR_VAR 0 5
7188: PUSH
7189: LD_INT 91
7191: PUSH
7192: LD_INT 58
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: PUSH
7199: LD_INT 117
7201: PUSH
7202: LD_INT 107
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: PUSH
7209: EMPTY
7210: LIST
7211: LIST
7212: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7213: LD_VAR 0 3
7217: PPUSH
7218: LD_VAR 0 5
7222: PUSH
7223: LD_INT 1
7225: ARRAY
7226: PPUSH
7227: LD_VAR 0 5
7231: PUSH
7232: LD_INT 2
7234: ARRAY
7235: PPUSH
7236: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7240: LD_INT 35
7242: PPUSH
7243: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7247: LD_VAR 0 3
7251: PPUSH
7252: LD_INT 60
7254: PUSH
7255: EMPTY
7256: LIST
7257: PPUSH
7258: CALL_OW 72
7262: PUSH
7263: LD_INT 0
7265: EQUAL
7266: IFFALSE 7240
// repeat wait ( 0 0$2 ) ;
7268: LD_INT 70
7270: PPUSH
7271: CALL_OW 67
// for i in tmp do
7275: LD_ADDR_VAR 0 1
7279: PUSH
7280: LD_VAR 0 3
7284: PUSH
7285: FOR_IN
7286: IFFALSE 7375
// if GetChassis ( i ) = ar_hovercraft then
7288: LD_VAR 0 1
7292: PPUSH
7293: CALL_OW 265
7297: PUSH
7298: LD_INT 11
7300: EQUAL
7301: IFFALSE 7339
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7303: LD_VAR 0 1
7307: PPUSH
7308: LD_INT 22
7310: PUSH
7311: LD_INT 1
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: PPUSH
7318: CALL_OW 69
7322: PPUSH
7323: LD_VAR 0 1
7327: PPUSH
7328: CALL_OW 74
7332: PPUSH
7333: CALL 79555 0 2
7337: GO 7373
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7339: LD_VAR 0 1
7343: PPUSH
7344: LD_INT 22
7346: PUSH
7347: LD_INT 1
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: PPUSH
7354: CALL_OW 69
7358: PPUSH
7359: LD_VAR 0 1
7363: PPUSH
7364: CALL_OW 74
7368: PPUSH
7369: CALL_OW 115
7373: GO 7285
7375: POP
7376: POP
// until not tmp ;
7377: LD_VAR 0 3
7381: NOT
7382: IFFALSE 7268
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7384: LD_INT 22050
7386: PPUSH
7387: LD_INT 28350
7389: PPUSH
7390: CALL_OW 12
7394: PPUSH
7395: CALL_OW 67
// w := w + 1 ;
7399: LD_ADDR_VAR 0 7
7403: PUSH
7404: LD_VAR 0 7
7408: PUSH
7409: LD_INT 1
7411: PLUS
7412: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7413: LD_INT 94
7415: PPUSH
7416: CALL_OW 301
7420: PUSH
7421: LD_EXP 50
7425: PUSH
7426: LD_INT 1
7428: ARRAY
7429: PPUSH
7430: LD_INT 30
7432: PUSH
7433: LD_INT 3
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: PPUSH
7440: CALL_OW 72
7444: NOT
7445: OR
7446: IFFALSE 6607
// end ;
7448: PPOPN 8
7450: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7451: LD_INT 204
7453: IFFALSE 7919
7455: GO 7457
7457: DISABLE
7458: LD_INT 0
7460: PPUSH
7461: PPUSH
7462: PPUSH
7463: PPUSH
// begin enable ;
7464: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7465: LD_INT 35
7467: PPUSH
7468: LD_INT 1190
7470: PPUSH
7471: CALL_OW 12
7475: PPUSH
7476: CALL_OW 67
// tmp := [ ] ;
7480: LD_ADDR_VAR 0 2
7484: PUSH
7485: EMPTY
7486: ST_TO_ADDR
// uc_side := 8 ;
7487: LD_ADDR_OWVAR 20
7491: PUSH
7492: LD_INT 8
7494: ST_TO_ADDR
// uc_nation := 2 ;
7495: LD_ADDR_OWVAR 21
7499: PUSH
7500: LD_INT 2
7502: ST_TO_ADDR
// InitHc ;
7503: CALL_OW 19
// for i = 1 to 3 do
7507: LD_ADDR_VAR 0 1
7511: PUSH
7512: DOUBLE
7513: LD_INT 1
7515: DEC
7516: ST_TO_ADDR
7517: LD_INT 3
7519: PUSH
7520: FOR_TO
7521: IFFALSE 7648
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7523: LD_INT 13
7525: PUSH
7526: LD_INT 14
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: PUSH
7533: LD_INT 1
7535: PPUSH
7536: LD_INT 2
7538: PPUSH
7539: CALL_OW 12
7543: ARRAY
7544: PPUSH
7545: LD_INT 3
7547: PPUSH
7548: LD_INT 5
7550: PPUSH
7551: LD_INT 27
7553: PUSH
7554: LD_INT 28
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PUSH
7561: LD_INT 1
7563: PPUSH
7564: LD_INT 2
7566: PPUSH
7567: CALL_OW 12
7571: ARRAY
7572: PPUSH
7573: LD_INT 100
7575: PPUSH
7576: CALL 52245 0 5
// un := CreateVehicle ;
7580: LD_ADDR_VAR 0 3
7584: PUSH
7585: CALL_OW 45
7589: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7590: LD_VAR 0 3
7594: PPUSH
7595: LD_INT 4
7597: PPUSH
7598: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7602: LD_VAR 0 3
7606: PPUSH
7607: LD_INT 15
7609: PPUSH
7610: LD_INT 0
7612: PPUSH
7613: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7617: LD_ADDR_VAR 0 2
7621: PUSH
7622: LD_VAR 0 2
7626: PPUSH
7627: LD_VAR 0 2
7631: PUSH
7632: LD_INT 1
7634: PLUS
7635: PPUSH
7636: LD_VAR 0 3
7640: PPUSH
7641: CALL_OW 1
7645: ST_TO_ADDR
// end ;
7646: GO 7520
7648: POP
7649: POP
// for i = 1 to 4 do
7650: LD_ADDR_VAR 0 1
7654: PUSH
7655: DOUBLE
7656: LD_INT 1
7658: DEC
7659: ST_TO_ADDR
7660: LD_INT 4
7662: PUSH
7663: FOR_TO
7664: IFFALSE 7735
// begin PrepareHuman ( false , 1 , 6 ) ;
7666: LD_INT 0
7668: PPUSH
7669: LD_INT 1
7671: PPUSH
7672: LD_INT 6
7674: PPUSH
7675: CALL_OW 380
// un := CreateHuman ;
7679: LD_ADDR_VAR 0 3
7683: PUSH
7684: CALL_OW 44
7688: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7689: LD_VAR 0 3
7693: PPUSH
7694: LD_INT 15
7696: PPUSH
7697: LD_INT 0
7699: PPUSH
7700: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7704: LD_ADDR_VAR 0 2
7708: PUSH
7709: LD_VAR 0 2
7713: PPUSH
7714: LD_VAR 0 2
7718: PUSH
7719: LD_INT 1
7721: PLUS
7722: PPUSH
7723: LD_VAR 0 3
7727: PPUSH
7728: CALL_OW 1
7732: ST_TO_ADDR
// end ;
7733: GO 7663
7735: POP
7736: POP
// wait ( 0 0$3 ) ;
7737: LD_INT 105
7739: PPUSH
7740: CALL_OW 67
// for i in tmp do
7744: LD_ADDR_VAR 0 1
7748: PUSH
7749: LD_VAR 0 2
7753: PUSH
7754: FOR_IN
7755: IFFALSE 7823
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
7757: LD_VAR 0 1
7761: PPUSH
7762: CALL_OW 257
7766: PUSH
7767: LD_INT 1
7769: EQUAL
7770: PUSH
7771: LD_VAR 0 1
7775: PPUSH
7776: CALL_OW 247
7780: PUSH
7781: LD_INT 2
7783: EQUAL
7784: OR
7785: IFFALSE 7821
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7787: LD_VAR 0 1
7791: PPUSH
7792: LD_INT 81
7794: PUSH
7795: LD_INT 8
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: PPUSH
7802: CALL_OW 69
7806: PPUSH
7807: LD_VAR 0 1
7811: PPUSH
7812: CALL_OW 74
7816: PPUSH
7817: CALL_OW 115
7821: GO 7754
7823: POP
7824: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
7825: LD_VAR 0 2
7829: PPUSH
7830: LD_INT 210
7832: PPUSH
7833: LD_INT 178
7835: PPUSH
7836: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7840: LD_ADDR_VAR 0 4
7844: PUSH
7845: LD_INT 10
7847: PPUSH
7848: LD_INT 22
7850: PUSH
7851: LD_INT 8
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PPUSH
7858: CALL_OW 70
7862: ST_TO_ADDR
// if x then
7863: LD_VAR 0 4
7867: IFFALSE 7895
// for i in x do
7869: LD_ADDR_VAR 0 1
7873: PUSH
7874: LD_VAR 0 4
7878: PUSH
7879: FOR_IN
7880: IFFALSE 7893
// RemoveUnit ( i ) ;
7882: LD_VAR 0 1
7886: PPUSH
7887: CALL_OW 64
7891: GO 7879
7893: POP
7894: POP
// wait ( 0 0$1 ) ;
7895: LD_INT 35
7897: PPUSH
7898: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
7902: LD_INT 22
7904: PUSH
7905: LD_INT 8
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PPUSH
7912: CALL_OW 69
7916: NOT
7917: IFFALSE 7825
// end ;
7919: PPOPN 4
7921: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
7922: LD_INT 22
7924: PUSH
7925: LD_INT 2
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PUSH
7932: LD_INT 34
7934: PUSH
7935: LD_INT 31
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PUSH
7942: LD_INT 3
7944: PUSH
7945: LD_INT 24
7947: PUSH
7948: LD_INT 1000
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: PUSH
7955: EMPTY
7956: LIST
7957: LIST
7958: PUSH
7959: EMPTY
7960: LIST
7961: LIST
7962: LIST
7963: PPUSH
7964: CALL_OW 69
7968: IFFALSE 8071
7970: GO 7972
7972: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
7973: LD_INT 45
7975: PPUSH
7976: CALL_OW 302
7980: PUSH
7981: LD_INT 45
7983: PPUSH
7984: CALL_OW 255
7988: AND
7989: IFFALSE 8032
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
7991: LD_INT 22
7993: PUSH
7994: LD_INT 2
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 34
8003: PUSH
8004: LD_INT 31
8006: PUSH
8007: EMPTY
8008: LIST
8009: LIST
8010: PUSH
8011: EMPTY
8012: LIST
8013: LIST
8014: PPUSH
8015: CALL_OW 69
8019: PPUSH
8020: LD_INT 18
8022: PPUSH
8023: LD_INT 8
8025: PPUSH
8026: CALL_OW 111
8030: GO 8071
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8032: LD_INT 22
8034: PUSH
8035: LD_INT 2
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: LD_INT 34
8044: PUSH
8045: LD_INT 31
8047: PUSH
8048: EMPTY
8049: LIST
8050: LIST
8051: PUSH
8052: EMPTY
8053: LIST
8054: LIST
8055: PPUSH
8056: CALL_OW 69
8060: PPUSH
8061: LD_INT 106
8063: PPUSH
8064: LD_INT 14
8066: PPUSH
8067: CALL_OW 111
// end ; end_of_file
8071: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8072: LD_INT 0
8074: PPUSH
8075: PPUSH
8076: PPUSH
8077: PPUSH
8078: PPUSH
8079: PPUSH
// InGameOn ;
8080: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8084: LD_EXP 21
8088: PPUSH
8089: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8093: LD_INT 2
8095: PPUSH
8096: LD_INT 1
8098: PPUSH
8099: LD_INT 1
8101: PPUSH
8102: LD_INT 1
8104: PPUSH
8105: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8109: LD_ADDR_VAR 0 2
8113: PUSH
8114: LD_INT 22
8116: PUSH
8117: LD_INT 1
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: PUSH
8124: LD_INT 25
8126: PUSH
8127: LD_INT 1
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PPUSH
8138: CALL_OW 69
8142: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8143: LD_ADDR_VAR 0 4
8147: PUSH
8148: LD_INT 22
8150: PUSH
8151: LD_INT 1
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: LD_INT 34
8160: PUSH
8161: LD_INT 11
8163: PUSH
8164: EMPTY
8165: LIST
8166: LIST
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PPUSH
8172: CALL_OW 69
8176: PUSH
8177: LD_INT 1
8179: ARRAY
8180: ST_TO_ADDR
// for i = 1 to tmp do
8181: LD_ADDR_VAR 0 6
8185: PUSH
8186: DOUBLE
8187: LD_INT 1
8189: DEC
8190: ST_TO_ADDR
8191: LD_VAR 0 2
8195: PUSH
8196: FOR_TO
8197: IFFALSE 8244
// begin if i = 5 then
8199: LD_VAR 0 6
8203: PUSH
8204: LD_INT 5
8206: EQUAL
8207: IFFALSE 8211
// break ;
8209: GO 8244
// sols := Replace ( sols , i , tmp [ i ] ) ;
8211: LD_ADDR_VAR 0 5
8215: PUSH
8216: LD_VAR 0 5
8220: PPUSH
8221: LD_VAR 0 6
8225: PPUSH
8226: LD_VAR 0 2
8230: PUSH
8231: LD_VAR 0 6
8235: ARRAY
8236: PPUSH
8237: CALL_OW 1
8241: ST_TO_ADDR
// end ;
8242: GO 8196
8244: POP
8245: POP
// tmp := ar_force_tmp ;
8246: LD_ADDR_VAR 0 2
8250: PUSH
8251: LD_EXP 40
8255: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8256: LD_VAR 0 2
8260: PUSH
8261: LD_INT 1
8263: ARRAY
8264: PPUSH
8265: LD_INT 108
8267: PPUSH
8268: LD_INT 139
8270: PPUSH
8271: LD_INT 0
8273: PPUSH
8274: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8278: LD_VAR 0 2
8282: PUSH
8283: LD_INT 1
8285: ARRAY
8286: PPUSH
8287: LD_EXP 21
8291: PPUSH
8292: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8296: LD_VAR 0 2
8300: PUSH
8301: LD_INT 2
8303: ARRAY
8304: PPUSH
8305: LD_INT 114
8307: PPUSH
8308: LD_INT 132
8310: PPUSH
8311: LD_INT 0
8313: PPUSH
8314: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8318: LD_VAR 0 2
8322: PUSH
8323: LD_INT 3
8325: ARRAY
8326: PPUSH
8327: LD_INT 115
8329: PPUSH
8330: LD_INT 132
8332: PPUSH
8333: LD_INT 0
8335: PPUSH
8336: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8340: LD_VAR 0 2
8344: PUSH
8345: LD_INT 2
8347: ARRAY
8348: PUSH
8349: LD_VAR 0 2
8353: PUSH
8354: LD_INT 3
8356: ARRAY
8357: PUSH
8358: EMPTY
8359: LIST
8360: LIST
8361: PPUSH
8362: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8366: LD_VAR 0 4
8370: PPUSH
8371: LD_INT 83
8373: PPUSH
8374: LD_INT 123
8376: PPUSH
8377: CALL_OW 111
// Wait ( 0 0$01 ) ;
8381: LD_INT 35
8383: PPUSH
8384: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8388: LD_INT 90
8390: PPUSH
8391: LD_INT 144
8393: PPUSH
8394: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8398: LD_VAR 0 5
8402: PPUSH
8403: LD_INT 88
8405: PPUSH
8406: LD_INT 129
8408: PPUSH
8409: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8413: LD_ADDR_VAR 0 3
8417: PUSH
8418: LD_INT 92
8420: PUSH
8421: LD_INT 131
8423: PUSH
8424: EMPTY
8425: LIST
8426: LIST
8427: PUSH
8428: LD_INT 88
8430: PUSH
8431: LD_INT 127
8433: PUSH
8434: EMPTY
8435: LIST
8436: LIST
8437: PUSH
8438: LD_INT 91
8440: PUSH
8441: LD_INT 132
8443: PUSH
8444: EMPTY
8445: LIST
8446: LIST
8447: PUSH
8448: LD_INT 92
8450: PUSH
8451: LD_INT 134
8453: PUSH
8454: EMPTY
8455: LIST
8456: LIST
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: LIST
8462: LIST
8463: ST_TO_ADDR
// for i = 1 to sols do
8464: LD_ADDR_VAR 0 6
8468: PUSH
8469: DOUBLE
8470: LD_INT 1
8472: DEC
8473: ST_TO_ADDR
8474: LD_VAR 0 5
8478: PUSH
8479: FOR_TO
8480: IFFALSE 8553
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8482: LD_VAR 0 5
8486: PUSH
8487: LD_VAR 0 6
8491: ARRAY
8492: PPUSH
8493: LD_VAR 0 3
8497: PUSH
8498: LD_VAR 0 6
8502: ARRAY
8503: PUSH
8504: LD_INT 1
8506: ARRAY
8507: PPUSH
8508: LD_VAR 0 3
8512: PUSH
8513: LD_VAR 0 6
8517: ARRAY
8518: PUSH
8519: LD_INT 2
8521: ARRAY
8522: PPUSH
8523: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8527: LD_VAR 0 5
8531: PUSH
8532: LD_VAR 0 6
8536: ARRAY
8537: PPUSH
8538: CALL_OW 197
// AddComHold ( sols ) ;
8542: LD_VAR 0 5
8546: PPUSH
8547: CALL_OW 200
// end ;
8551: GO 8479
8553: POP
8554: POP
// repeat wait ( 0 0$1 ) ;
8555: LD_INT 35
8557: PPUSH
8558: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8562: LD_VAR 0 5
8566: PUSH
8567: LD_INT 1
8569: ARRAY
8570: PPUSH
8571: LD_INT 92
8573: PPUSH
8574: LD_INT 131
8576: PPUSH
8577: CALL_OW 297
8581: PUSH
8582: LD_INT 4
8584: LESS
8585: IFFALSE 8555
// CenterOnXY ( 96 , 139 ) ;
8587: LD_INT 96
8589: PPUSH
8590: LD_INT 139
8592: PPUSH
8593: CALL_OW 84
// wait ( 0 0$3 ) ;
8597: LD_INT 105
8599: PPUSH
8600: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8604: LD_INT 111
8606: PPUSH
8607: LD_INT 135
8609: PPUSH
8610: LD_INT 1
8612: PPUSH
8613: LD_INT 25
8615: NEG
8616: PPUSH
8617: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8621: LD_VAR 0 2
8625: PUSH
8626: LD_INT 2
8628: ARRAY
8629: PPUSH
8630: LD_VAR 0 2
8634: PUSH
8635: LD_INT 1
8637: ARRAY
8638: PPUSH
8639: CALL_OW 250
8643: PUSH
8644: LD_INT 3
8646: PLUS
8647: PPUSH
8648: LD_VAR 0 2
8652: PUSH
8653: LD_INT 1
8655: ARRAY
8656: PPUSH
8657: CALL_OW 251
8661: PPUSH
8662: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8666: LD_VAR 0 2
8670: PUSH
8671: LD_INT 3
8673: ARRAY
8674: PPUSH
8675: LD_INT 7
8677: PPUSH
8678: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8682: LD_VAR 0 2
8686: PUSH
8687: LD_INT 2
8689: ARRAY
8690: PPUSH
8691: LD_VAR 0 2
8695: PUSH
8696: LD_INT 1
8698: ARRAY
8699: PPUSH
8700: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8704: LD_INT 35
8706: PPUSH
8707: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8711: LD_VAR 0 2
8715: PUSH
8716: LD_INT 1
8718: ARRAY
8719: PPUSH
8720: LD_VAR 0 2
8724: PUSH
8725: LD_INT 2
8727: ARRAY
8728: PPUSH
8729: CALL_OW 296
8733: PUSH
8734: LD_INT 5
8736: LESS
8737: IFFALSE 8704
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8739: LD_VAR 0 2
8743: PUSH
8744: LD_INT 1
8746: ARRAY
8747: PPUSH
8748: LD_VAR 0 2
8752: PUSH
8753: LD_INT 2
8755: ARRAY
8756: PPUSH
8757: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8761: LD_VAR 0 2
8765: PUSH
8766: LD_INT 1
8768: ARRAY
8769: PPUSH
8770: LD_STRING D1a-Merc1-1
8772: PPUSH
8773: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8777: LD_VAR 0 2
8781: PUSH
8782: LD_INT 2
8784: ARRAY
8785: PPUSH
8786: LD_STRING D1a-FMerc2-1
8788: PPUSH
8789: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8793: LD_VAR 0 2
8797: PUSH
8798: LD_INT 2
8800: ARRAY
8801: PPUSH
8802: LD_VAR 0 2
8806: PUSH
8807: LD_INT 1
8809: ARRAY
8810: PPUSH
8811: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8815: LD_VAR 0 2
8819: PUSH
8820: LD_INT 1
8822: ARRAY
8823: PPUSH
8824: LD_INT 500
8826: PPUSH
8827: CALL_OW 234
// wait ( 0 0$2 ) ;
8831: LD_INT 70
8833: PPUSH
8834: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8838: LD_VAR 0 2
8842: PUSH
8843: LD_INT 1
8845: ARRAY
8846: PPUSH
8847: LD_INT 2
8849: PPUSH
8850: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8854: LD_INT 10
8856: PPUSH
8857: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8861: LD_VAR 0 2
8865: PUSH
8866: LD_INT 1
8868: ARRAY
8869: PPUSH
8870: LD_STRING D1a-Merc1-2
8872: PPUSH
8873: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8877: LD_INT 7
8879: PPUSH
8880: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8884: LD_VAR 0 2
8888: PUSH
8889: LD_INT 1
8891: ARRAY
8892: PPUSH
8893: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8897: LD_VAR 0 2
8901: PUSH
8902: LD_INT 2
8904: ARRAY
8905: PPUSH
8906: LD_INT 10
8908: PPUSH
8909: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8913: LD_VAR 0 2
8917: PUSH
8918: LD_INT 2
8920: ARRAY
8921: PPUSH
8922: LD_STRING D1a-FMerc2-2
8924: PPUSH
8925: CALL_OW 88
// wait ( 0 0$1 ) ;
8929: LD_INT 35
8931: PPUSH
8932: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8936: LD_INT 7
8938: PPUSH
8939: CALL_OW 85
// wait ( 0 0$2 ) ;
8943: LD_INT 70
8945: PPUSH
8946: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8950: LD_EXP 44
8954: PPUSH
8955: LD_STRING D1a-Saliba-1
8957: PPUSH
8958: CALL_OW 91
// KillUnit ( Saliba ) ;
8962: LD_EXP 44
8966: PPUSH
8967: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8971: LD_VAR 0 2
8975: PUSH
8976: LD_INT 3
8978: ARRAY
8979: PPUSH
8980: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8984: LD_EXP 21
8988: PPUSH
8989: CALL_OW 85
// wait ( 0 0$1 ) ;
8993: LD_INT 35
8995: PPUSH
8996: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9000: LD_VAR 0 5
9004: PPUSH
9005: LD_INT 88
9007: PPUSH
9008: LD_INT 141
9010: PPUSH
9011: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9015: LD_VAR 0 5
9019: PPUSH
9020: LD_INT 70
9022: PPUSH
9023: CALL_OW 202
// wait ( 0 0$2 ) ;
9027: LD_INT 70
9029: PPUSH
9030: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9034: LD_INT 2
9036: PPUSH
9037: LD_INT 1
9039: PPUSH
9040: LD_INT 2
9042: PPUSH
9043: LD_INT 1
9045: PPUSH
9046: CALL_OW 80
// InGameOff ;
9050: CALL_OW 9
// ComWalk ( sols ) ;
9054: LD_VAR 0 5
9058: PPUSH
9059: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9063: LD_STRING M1
9065: PPUSH
9066: CALL_OW 337
// game_speed := 4 ;
9070: LD_ADDR_OWVAR 65
9074: PUSH
9075: LD_INT 4
9077: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9078: LD_INT 111
9080: PPUSH
9081: LD_INT 135
9083: PPUSH
9084: LD_INT 1
9086: PPUSH
9087: CALL_OW 331
// SaveForQuickRestart ;
9091: CALL_OW 22
// ar_run := true ;
9095: LD_ADDR_EXP 5
9099: PUSH
9100: LD_INT 1
9102: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9103: LD_INT 35
9105: PPUSH
9106: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9110: LD_INT 22
9112: PUSH
9113: LD_INT 1
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: PUSH
9120: LD_INT 91
9122: PUSH
9123: LD_INT 7
9125: PUSH
9126: LD_INT 10
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: LIST
9133: PUSH
9134: EMPTY
9135: LIST
9136: LIST
9137: PPUSH
9138: CALL_OW 69
9142: PUSH
9143: LD_INT 7
9145: PPUSH
9146: CALL_OW 256
9150: PUSH
9151: LD_INT 999
9153: LESS
9154: OR
9155: IFFALSE 9103
// if GetSide ( ar_dep_s ) = 2 then
9157: LD_INT 7
9159: PPUSH
9160: CALL_OW 255
9164: PUSH
9165: LD_INT 2
9167: EQUAL
9168: IFFALSE 9180
// SetSide ( ar_dep_s , 1 ) ;
9170: LD_INT 7
9172: PPUSH
9173: LD_INT 1
9175: PPUSH
9176: CALL_OW 235
// end ;
9180: LD_VAR 0 1
9184: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9185: LD_EXP 5
9189: IFFALSE 9549
9191: GO 9193
9193: DISABLE
9194: LD_INT 0
9196: PPUSH
9197: PPUSH
9198: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9199: LD_ADDR_VAR 0 2
9203: PUSH
9204: LD_EXP 40
9208: PUSH
9209: LD_EXP 36
9213: PPUSH
9214: LD_INT 2
9216: PUSH
9217: LD_INT 21
9219: PUSH
9220: LD_INT 2
9222: PUSH
9223: EMPTY
9224: LIST
9225: LIST
9226: PUSH
9227: LD_INT 21
9229: PUSH
9230: LD_INT 1
9232: PUSH
9233: EMPTY
9234: LIST
9235: LIST
9236: PUSH
9237: EMPTY
9238: LIST
9239: LIST
9240: LIST
9241: PPUSH
9242: CALL_OW 72
9246: ADD
9247: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9248: LD_VAR 0 2
9252: PPUSH
9253: LD_INT 5
9255: PPUSH
9256: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9260: LD_INT 5
9262: PPUSH
9263: LD_INT 1
9265: PPUSH
9266: CALL_OW 343
// k := 1 ;
9270: LD_ADDR_VAR 0 3
9274: PUSH
9275: LD_INT 1
9277: ST_TO_ADDR
// for i in tmp do
9278: LD_ADDR_VAR 0 1
9282: PUSH
9283: LD_VAR 0 2
9287: PUSH
9288: FOR_IN
9289: IFFALSE 9374
// begin if IsInUnit ( i ) then
9291: LD_VAR 0 1
9295: PPUSH
9296: CALL_OW 310
9300: IFFALSE 9311
// ComExitBuilding ( i ) ;
9302: LD_VAR 0 1
9306: PPUSH
9307: CALL_OW 122
// if GetClass ( i ) = 3 then
9311: LD_VAR 0 1
9315: PPUSH
9316: CALL_OW 257
9320: PUSH
9321: LD_INT 3
9323: EQUAL
9324: IFFALSE 9360
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9326: LD_VAR 0 1
9330: PPUSH
9331: LD_EXP 41
9335: PUSH
9336: LD_VAR 0 3
9340: ARRAY
9341: PPUSH
9342: CALL_OW 180
// k := k + 1 ;
9346: LD_ADDR_VAR 0 3
9350: PUSH
9351: LD_VAR 0 3
9355: PUSH
9356: LD_INT 1
9358: PLUS
9359: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9360: LD_VAR 0 1
9364: PPUSH
9365: LD_INT 10
9367: PPUSH
9368: CALL_OW 173
// end ;
9372: GO 9288
9374: POP
9375: POP
// ar_patrol := true ;
9376: LD_ADDR_EXP 7
9380: PUSH
9381: LD_INT 1
9383: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9384: LD_INT 10
9386: PPUSH
9387: CALL_OW 67
// for i in tmp do
9391: LD_ADDR_VAR 0 1
9395: PUSH
9396: LD_VAR 0 2
9400: PUSH
9401: FOR_IN
9402: IFFALSE 9430
// if not HasTask ( i ) then
9404: LD_VAR 0 1
9408: PPUSH
9409: CALL_OW 314
9413: NOT
9414: IFFALSE 9428
// ComMoveToArea ( i , escape_area ) ;
9416: LD_VAR 0 1
9420: PPUSH
9421: LD_INT 10
9423: PPUSH
9424: CALL_OW 113
9428: GO 9401
9430: POP
9431: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9432: LD_ADDR_VAR 0 3
9436: PUSH
9437: LD_VAR 0 2
9441: PPUSH
9442: LD_INT 95
9444: PUSH
9445: LD_INT 10
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PPUSH
9452: CALL_OW 72
9456: ST_TO_ADDR
// if k then
9457: LD_VAR 0 3
9461: IFFALSE 9530
// for i in k do
9463: LD_ADDR_VAR 0 1
9467: PUSH
9468: LD_VAR 0 3
9472: PUSH
9473: FOR_IN
9474: IFFALSE 9528
// begin if IsInUnit ( i ) then
9476: LD_VAR 0 1
9480: PPUSH
9481: CALL_OW 310
9485: IFFALSE 9501
// RemoveUnit ( IsInUnit ( i ) ) ;
9487: LD_VAR 0 1
9491: PPUSH
9492: CALL_OW 310
9496: PPUSH
9497: CALL_OW 64
// RemoveUnit ( i ) ;
9501: LD_VAR 0 1
9505: PPUSH
9506: CALL_OW 64
// tmp := tmp diff i ;
9510: LD_ADDR_VAR 0 2
9514: PUSH
9515: LD_VAR 0 2
9519: PUSH
9520: LD_VAR 0 1
9524: DIFF
9525: ST_TO_ADDR
// end ;
9526: GO 9473
9528: POP
9529: POP
// until tmp = [ ] ;
9530: LD_VAR 0 2
9534: PUSH
9535: EMPTY
9536: EQUAL
9537: IFFALSE 9384
// ChangeSideFog ( 5 , 5 ) ;
9539: LD_INT 5
9541: PPUSH
9542: LD_INT 5
9544: PPUSH
9545: CALL_OW 343
// end ;
9549: PPOPN 3
9551: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9552: LD_EXP 7
9556: IFFALSE 9846
9558: GO 9560
9560: DISABLE
9561: LD_INT 0
9563: PPUSH
9564: PPUSH
9565: PPUSH
// begin uc_side := 2 ;
9566: LD_ADDR_OWVAR 20
9570: PUSH
9571: LD_INT 2
9573: ST_TO_ADDR
// uc_nation := 2 ;
9574: LD_ADDR_OWVAR 21
9578: PUSH
9579: LD_INT 2
9581: ST_TO_ADDR
// InitHc ;
9582: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9586: LD_INT 1
9588: PPUSH
9589: LD_INT 1
9591: PPUSH
9592: LD_INT 6
9594: PPUSH
9595: CALL_OW 380
// un := CreateHuman ;
9599: LD_ADDR_VAR 0 2
9603: PUSH
9604: CALL_OW 44
9608: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9609: LD_INT 14
9611: PPUSH
9612: LD_INT 1
9614: PPUSH
9615: LD_INT 1
9617: PPUSH
9618: LD_INT 27
9620: PPUSH
9621: LD_INT 98
9623: PPUSH
9624: CALL 52245 0 5
// veh := CreateVehicle ;
9628: LD_ADDR_VAR 0 3
9632: PUSH
9633: CALL_OW 45
9637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9638: LD_VAR 0 3
9642: PPUSH
9643: LD_INT 4
9645: PPUSH
9646: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9650: LD_VAR 0 3
9654: PPUSH
9655: LD_INT 179
9657: PPUSH
9658: LD_INT 135
9660: PPUSH
9661: LD_INT 0
9663: PPUSH
9664: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9668: LD_VAR 0 2
9672: PPUSH
9673: LD_VAR 0 3
9677: PPUSH
9678: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9682: LD_VAR 0 2
9686: PPUSH
9687: LD_INT 126
9689: PPUSH
9690: LD_INT 133
9692: PPUSH
9693: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9697: LD_INT 10
9699: PPUSH
9700: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9704: LD_INT 1
9706: PPUSH
9707: LD_VAR 0 3
9711: PPUSH
9712: CALL_OW 292
9716: PUSH
9717: LD_VAR 0 3
9721: PPUSH
9722: LD_INT 7
9724: PPUSH
9725: CALL_OW 296
9729: PUSH
9730: LD_INT 9
9732: LESS
9733: OR
9734: IFFALSE 9697
// ComHold ( veh ) ;
9736: LD_VAR 0 3
9740: PPUSH
9741: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9745: LD_VAR 0 2
9749: PPUSH
9750: LD_STRING D2aa-Ar1-1
9752: PPUSH
9753: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9757: LD_VAR 0 2
9761: PPUSH
9762: LD_INT 177
9764: PPUSH
9765: LD_INT 96
9767: PPUSH
9768: CALL_OW 111
// AddComExitVehicle ( un ) ;
9772: LD_VAR 0 2
9776: PPUSH
9777: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9781: LD_INT 35
9783: PPUSH
9784: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9788: LD_VAR 0 2
9792: PPUSH
9793: LD_INT 204
9795: PPUSH
9796: CALL_OW 296
9800: PUSH
9801: LD_INT 15
9803: LESS
9804: IFFALSE 9781
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9806: LD_ADDR_EXP 50
9810: PUSH
9811: LD_EXP 50
9815: PPUSH
9816: LD_INT 3
9818: PUSH
9819: LD_EXP 50
9823: PUSH
9824: LD_INT 3
9826: ARRAY
9827: PUSH
9828: LD_INT 1
9830: PLUS
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: PPUSH
9836: LD_VAR 0 2
9840: PPUSH
9841: CALL 52367 0 3
9845: ST_TO_ADDR
// end ;
9846: PPOPN 3
9848: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9849: LD_INT 7
9851: PPUSH
9852: CALL_OW 255
9856: PUSH
9857: LD_INT 1
9859: EQUAL
9860: PUSH
9861: LD_INT 7
9863: PPUSH
9864: CALL_OW 301
9868: OR
9869: IFFALSE 12293
9871: GO 9873
9873: DISABLE
9874: LD_INT 0
9876: PPUSH
9877: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9878: LD_ADDR_VAR 0 1
9882: PUSH
9883: LD_EXP 36
9887: PPUSH
9888: LD_INT 21
9890: PUSH
9891: LD_INT 3
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: PPUSH
9898: CALL_OW 72
9902: PUSH
9903: FOR_IN
9904: IFFALSE 9920
// SetSide ( i , 1 ) ;
9906: LD_VAR 0 1
9910: PPUSH
9911: LD_INT 1
9913: PPUSH
9914: CALL_OW 235
9918: GO 9903
9920: POP
9921: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9922: LD_ADDR_VAR 0 2
9926: PUSH
9927: LD_INT 46
9929: PUSH
9930: LD_INT 41
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: PUSH
9937: LD_INT 50
9939: PUSH
9940: LD_INT 25
9942: PUSH
9943: EMPTY
9944: LIST
9945: LIST
9946: PUSH
9947: LD_INT 57
9949: PUSH
9950: LD_INT 75
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PUSH
9957: LD_INT 75
9959: PUSH
9960: LD_INT 89
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: PUSH
9967: LD_INT 51
9969: PUSH
9970: LD_INT 45
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: PUSH
9977: LD_INT 95
9979: PUSH
9980: LD_INT 95
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: PUSH
9987: LD_INT 84
9989: PUSH
9990: LD_INT 77
9992: PUSH
9993: EMPTY
9994: LIST
9995: LIST
9996: PUSH
9997: LD_INT 101
9999: PUSH
10000: LD_INT 76
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: PUSH
10007: LD_INT 118
10009: PUSH
10010: LD_INT 81
10012: PUSH
10013: EMPTY
10014: LIST
10015: LIST
10016: PUSH
10017: LD_INT 139
10019: PUSH
10020: LD_INT 97
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: PUSH
10027: LD_INT 129
10029: PUSH
10030: LD_INT 114
10032: PUSH
10033: EMPTY
10034: LIST
10035: LIST
10036: PUSH
10037: LD_INT 154
10039: PUSH
10040: LD_INT 111
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: LIST
10051: LIST
10052: LIST
10053: LIST
10054: LIST
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: LIST
10060: ST_TO_ADDR
// base_captured := true ;
10061: LD_ADDR_EXP 6
10065: PUSH
10066: LD_INT 1
10068: ST_TO_ADDR
// DialogueOn ;
10069: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10073: LD_EXP 21
10077: PPUSH
10078: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10082: LD_EXP 21
10086: PPUSH
10087: LD_STRING D2-JMM-1
10089: PPUSH
10090: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10094: LD_EXP 30
10098: PPUSH
10099: LD_STRING D2-Pow-1
10101: PPUSH
10102: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10106: LD_EXP 21
10110: PPUSH
10111: LD_STRING D2-JMM-2
10113: PPUSH
10114: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10118: LD_EXP 30
10122: PPUSH
10123: LD_STRING D2-Pow-2
10125: PPUSH
10126: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10130: LD_EXP 21
10134: PPUSH
10135: LD_STRING D2-JMM-3
10137: PPUSH
10138: CALL_OW 88
// DialogueOff ;
10142: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10146: LD_STRING M2
10148: PPUSH
10149: CALL_OW 337
// Wait ( 0 0$2 ) ;
10153: LD_INT 70
10155: PPUSH
10156: CALL_OW 67
// if IsOk ( Gary ) then
10160: LD_EXP 32
10164: PPUSH
10165: CALL_OW 302
10169: IFFALSE 10183
// Say ( Gary , D2a-Gary-1 ) ;
10171: LD_EXP 32
10175: PPUSH
10176: LD_STRING D2a-Gary-1
10178: PPUSH
10179: CALL_OW 88
// if IsOk ( Bobby ) then
10183: LD_EXP 24
10187: PPUSH
10188: CALL_OW 302
10192: IFFALSE 10206
// Say ( Bobby , D2a-Bobby-1 ) ;
10194: LD_EXP 24
10198: PPUSH
10199: LD_STRING D2a-Bobby-1
10201: PPUSH
10202: CALL_OW 88
// if IsOk ( Cyrus ) then
10206: LD_EXP 25
10210: PPUSH
10211: CALL_OW 302
10215: IFFALSE 10229
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10217: LD_EXP 25
10221: PPUSH
10222: LD_STRING D2a-Cyrus-1
10224: PPUSH
10225: CALL_OW 88
// if IsOk ( Lisa ) then
10229: LD_EXP 22
10233: PPUSH
10234: CALL_OW 302
10238: IFFALSE 10252
// Say ( Lisa , D2a-Lisa-1 ) ;
10240: LD_EXP 22
10244: PPUSH
10245: LD_STRING D2a-Lisa-1
10247: PPUSH
10248: CALL_OW 88
// if IsOk ( Frank ) then
10252: LD_EXP 33
10256: PPUSH
10257: CALL_OW 302
10261: IFFALSE 10275
// Say ( Frank , D2a-Frank-1 ) ;
10263: LD_EXP 33
10267: PPUSH
10268: LD_STRING D2a-Frank-1
10270: PPUSH
10271: CALL_OW 88
// if IsOk ( Cornel ) then
10275: LD_EXP 31
10279: PPUSH
10280: CALL_OW 302
10284: IFFALSE 10298
// Say ( Cornel , D2a-Corn-1 ) ;
10286: LD_EXP 31
10290: PPUSH
10291: LD_STRING D2a-Corn-1
10293: PPUSH
10294: CALL_OW 88
// if IsOk ( Donaldson ) then
10298: LD_EXP 23
10302: PPUSH
10303: CALL_OW 302
10307: IFFALSE 10321
// Say ( Donaldson , D2a-Don-1 ) ;
10309: LD_EXP 23
10313: PPUSH
10314: LD_STRING D2a-Don-1
10316: PPUSH
10317: CALL_OW 88
// if IsOk ( Brown ) then
10321: LD_EXP 27
10325: PPUSH
10326: CALL_OW 302
10330: IFFALSE 10344
// Say ( Brown , D2a-Brown-1 ) ;
10332: LD_EXP 27
10336: PPUSH
10337: LD_STRING D2a-Brown-1
10339: PPUSH
10340: CALL_OW 88
// Wait ( 0 0$30 ) ;
10344: LD_INT 1050
10346: PPUSH
10347: CALL_OW 67
// if IsOk ( Frank ) then
10351: LD_EXP 33
10355: PPUSH
10356: CALL_OW 302
10360: IFFALSE 10626
// begin DialogueOn ;
10362: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10366: LD_EXP 21
10370: PUSH
10371: LD_EXP 33
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PPUSH
10380: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10384: LD_EXP 33
10388: PPUSH
10389: LD_STRING D3F-Frank-1
10391: PPUSH
10392: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10396: LD_EXP 21
10400: PPUSH
10401: LD_STRING D3F-JMM-1
10403: PPUSH
10404: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10408: LD_EXP 33
10412: PPUSH
10413: LD_STRING D3F-Frank-2
10415: PPUSH
10416: CALL_OW 88
// case Query ( QFrank ) of 1 :
10420: LD_STRING QFrank
10422: PPUSH
10423: CALL_OW 97
10427: PUSH
10428: LD_INT 1
10430: DOUBLE
10431: EQUAL
10432: IFTRUE 10436
10434: GO 10459
10436: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10437: LD_EXP 21
10441: PPUSH
10442: LD_STRING D3Fa-JMM-1
10444: PPUSH
10445: CALL_OW 88
// us_scout := 1 ;
10449: LD_ADDR_EXP 8
10453: PUSH
10454: LD_INT 1
10456: ST_TO_ADDR
// end ; 2 :
10457: GO 10622
10459: LD_INT 2
10461: DOUBLE
10462: EQUAL
10463: IFTRUE 10467
10465: GO 10589
10467: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10468: LD_EXP 21
10472: PPUSH
10473: LD_STRING D3Fb-JMM-1
10475: PPUSH
10476: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10480: LD_EXP 33
10484: PPUSH
10485: LD_STRING D3Fb-Frank-1
10487: PPUSH
10488: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10492: LD_STRING QFrank2
10494: PPUSH
10495: CALL_OW 97
10499: PUSH
10500: LD_INT 1
10502: DOUBLE
10503: EQUAL
10504: IFTRUE 10508
10506: GO 10555
10508: POP
// begin us_scout := 2 ;
10509: LD_ADDR_EXP 8
10513: PUSH
10514: LD_INT 2
10516: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10517: LD_EXP 21
10521: PPUSH
10522: LD_STRING D3Fba-JMM-1
10524: PPUSH
10525: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10529: LD_EXP 33
10533: PPUSH
10534: LD_STRING D3Fba-Frank-1
10536: PPUSH
10537: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10541: LD_EXP 21
10545: PPUSH
10546: LD_STRING D3Fba-JMM-2
10548: PPUSH
10549: CALL_OW 88
// end ; 2 :
10553: GO 10587
10555: LD_INT 2
10557: DOUBLE
10558: EQUAL
10559: IFTRUE 10563
10561: GO 10586
10563: POP
// begin us_scout := 0 ;
10564: LD_ADDR_EXP 8
10568: PUSH
10569: LD_INT 0
10571: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10572: LD_EXP 21
10576: PPUSH
10577: LD_STRING D3Fbb-JMM-1
10579: PPUSH
10580: CALL_OW 88
// end ; end ;
10584: GO 10587
10586: POP
// end ; 3 :
10587: GO 10622
10589: LD_INT 3
10591: DOUBLE
10592: EQUAL
10593: IFTRUE 10597
10595: GO 10621
10597: POP
// begin us_scout := - 1 ;
10598: LD_ADDR_EXP 8
10602: PUSH
10603: LD_INT 1
10605: NEG
10606: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10607: LD_EXP 21
10611: PPUSH
10612: LD_STRING D3Fc-JMM-1
10614: PPUSH
10615: CALL_OW 88
// end ; end ;
10619: GO 10622
10621: POP
// DialogueOff ;
10622: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10626: LD_EXP 8
10630: PUSH
10631: LD_INT 1
10633: NEG
10634: PUSH
10635: LD_INT 0
10637: PUSH
10638: EMPTY
10639: LIST
10640: LIST
10641: IN
10642: IFFALSE 10646
// exit ;
10644: GO 12293
// if us_scout in [ 1 , 2 ] then
10646: LD_EXP 8
10650: PUSH
10651: LD_INT 1
10653: PUSH
10654: LD_INT 2
10656: PUSH
10657: EMPTY
10658: LIST
10659: LIST
10660: IN
10661: IFFALSE 11360
// begin if IsInUnit ( Frank ) then
10663: LD_EXP 33
10667: PPUSH
10668: CALL_OW 310
10672: IFFALSE 10683
// ComExitBuilding ( Frank ) ;
10674: LD_EXP 33
10678: PPUSH
10679: CALL_OW 122
// if IsDrivenBy ( Frank ) then
10683: LD_EXP 33
10687: PPUSH
10688: CALL_OW 311
10692: IFFALSE 10703
// ComExitVehicle ( Frank ) ;
10694: LD_EXP 33
10698: PPUSH
10699: CALL_OW 121
// SetSide ( Frank , 4 ) ;
10703: LD_EXP 33
10707: PPUSH
10708: LD_INT 4
10710: PPUSH
10711: CALL_OW 235
// wait ( 0 0$1 ) ;
10715: LD_INT 35
10717: PPUSH
10718: CALL_OW 67
// if us_scout = 2 then
10722: LD_EXP 8
10726: PUSH
10727: LD_INT 2
10729: EQUAL
10730: IFFALSE 11098
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10732: LD_EXP 33
10736: PPUSH
10737: LD_INT 75
10739: PPUSH
10740: LD_INT 63
10742: PPUSH
10743: CALL_OW 111
// AddComHold ( Frank ) ;
10747: LD_EXP 33
10751: PPUSH
10752: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10756: LD_EXP 33
10760: PPUSH
10761: LD_INT 770
10763: PPUSH
10764: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10768: LD_EXP 33
10772: PPUSH
10773: LD_INT 100
10775: PPUSH
10776: LD_INT 75
10778: PPUSH
10779: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10783: LD_EXP 33
10787: PPUSH
10788: LD_INT 123
10790: PPUSH
10791: LD_INT 103
10793: PPUSH
10794: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10798: LD_EXP 33
10802: PPUSH
10803: LD_INT 138
10805: PPUSH
10806: LD_INT 108
10808: PPUSH
10809: CALL_OW 171
// AddComHold ( Frank ) ;
10813: LD_EXP 33
10817: PPUSH
10818: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10822: LD_INT 35
10824: PPUSH
10825: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10829: LD_EXP 33
10833: PPUSH
10834: LD_INT 138
10836: PPUSH
10837: LD_INT 108
10839: PPUSH
10840: CALL_OW 307
10844: IFFALSE 10822
// AddComMoveXY ( Frank , 125 , 132 ) ;
10846: LD_EXP 33
10850: PPUSH
10851: LD_INT 125
10853: PPUSH
10854: LD_INT 132
10856: PPUSH
10857: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10861: LD_INT 35
10863: PPUSH
10864: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10868: LD_INT 1
10870: PPUSH
10871: LD_EXP 33
10875: PPUSH
10876: CALL_OW 292
10880: PUSH
10881: LD_EXP 33
10885: PPUSH
10886: LD_INT 7
10888: PPUSH
10889: CALL_OW 296
10893: PUSH
10894: LD_INT 7
10896: LESS
10897: OR
10898: IFFALSE 10861
// DialogueOn ;
10900: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10904: LD_EXP 33
10908: PPUSH
10909: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10913: LD_INT 10
10915: PPUSH
10916: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10920: LD_EXP 21
10924: PPUSH
10925: LD_STRING D4Fa-JMM-1
10927: PPUSH
10928: CALL_OW 88
// for i in points do
10932: LD_ADDR_VAR 0 1
10936: PUSH
10937: LD_VAR 0 2
10941: PUSH
10942: FOR_IN
10943: IFFALSE 11001
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10945: LD_VAR 0 1
10949: PUSH
10950: LD_INT 1
10952: ARRAY
10953: PPUSH
10954: LD_VAR 0 1
10958: PUSH
10959: LD_INT 2
10961: ARRAY
10962: PPUSH
10963: LD_INT 1
10965: PPUSH
10966: LD_INT 20
10968: NEG
10969: PPUSH
10970: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10974: LD_VAR 0 1
10978: PUSH
10979: LD_INT 1
10981: ARRAY
10982: PPUSH
10983: LD_VAR 0 1
10987: PUSH
10988: LD_INT 2
10990: ARRAY
10991: PPUSH
10992: LD_INT 1
10994: PPUSH
10995: CALL_OW 331
// end ;
10999: GO 10942
11001: POP
11002: POP
// dwait ( 0 0$0.5 ) ;
11003: LD_INT 18
11005: PPUSH
11006: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11010: LD_INT 42
11012: PPUSH
11013: LD_INT 27
11015: PPUSH
11016: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11020: LD_EXP 33
11024: PPUSH
11025: LD_STRING D4Fa-Frank-1
11027: PPUSH
11028: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11032: LD_INT 18
11034: PPUSH
11035: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11039: LD_EXP 21
11043: PPUSH
11044: LD_STRING D4Fa-JMM-2
11046: PPUSH
11047: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11051: LD_INT 118
11053: PPUSH
11054: LD_INT 80
11056: PPUSH
11057: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11061: LD_EXP 33
11065: PPUSH
11066: LD_STRING D4Fa-Frank-2
11068: PPUSH
11069: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11073: LD_INT 10
11075: PPUSH
11076: CALL_OW 68
// DialogueOff ;
11080: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11084: LD_EXP 33
11088: PPUSH
11089: LD_INT 1
11091: PPUSH
11092: CALL_OW 235
// end else
11096: GO 11360
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11098: LD_INT 2
11100: PPUSH
11101: LD_INT 4
11103: PPUSH
11104: LD_INT 2
11106: PPUSH
11107: LD_INT 1
11109: PPUSH
11110: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11114: LD_EXP 33
11118: PPUSH
11119: LD_INT 75
11121: PPUSH
11122: LD_INT 63
11124: PPUSH
11125: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11129: LD_EXP 33
11133: PPUSH
11134: LD_INT 175
11136: PPUSH
11137: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11141: LD_EXP 33
11145: PPUSH
11146: LD_INT 102
11148: PPUSH
11149: LD_INT 76
11151: PPUSH
11152: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11156: LD_EXP 33
11160: PPUSH
11161: LD_INT 108
11163: PPUSH
11164: LD_INT 70
11166: PPUSH
11167: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11171: LD_INT 35
11173: PPUSH
11174: CALL_OW 67
// until See ( 2 , Frank ) ;
11178: LD_INT 2
11180: PPUSH
11181: LD_EXP 33
11185: PPUSH
11186: CALL_OW 292
11190: IFFALSE 11171
// ComMoveXY ( Frank , 112 , 118 ) ;
11192: LD_EXP 33
11196: PPUSH
11197: LD_INT 112
11199: PPUSH
11200: LD_INT 118
11202: PPUSH
11203: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11207: LD_EXP 33
11211: PPUSH
11212: CALL_OW 256
11216: PUSH
11217: LD_INT 750
11219: GREATEREQUAL
11220: IFFALSE 11234
// SetLives ( Frank , 700 ) ;
11222: LD_EXP 33
11226: PPUSH
11227: LD_INT 700
11229: PPUSH
11230: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11234: LD_INT 35
11236: PPUSH
11237: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11241: LD_INT 1
11243: PPUSH
11244: LD_EXP 33
11248: PPUSH
11249: CALL_OW 292
11253: PUSH
11254: LD_EXP 33
11258: PPUSH
11259: LD_INT 7
11261: PPUSH
11262: CALL_OW 296
11266: PUSH
11267: LD_INT 17
11269: LESS
11270: OR
11271: IFFALSE 11234
// DialogueOn ;
11273: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11277: LD_EXP 33
11281: PPUSH
11282: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11286: LD_EXP 33
11290: PPUSH
11291: LD_STRING D4Fb-Frank-1
11293: PPUSH
11294: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11298: LD_EXP 21
11302: PPUSH
11303: LD_STRING D4Fb-JMM-1
11305: PPUSH
11306: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11310: LD_INT 2
11312: PPUSH
11313: LD_STRING D4Fb-FSci1-1
11315: PPUSH
11316: CALL 16197 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11320: LD_EXP 33
11324: PPUSH
11325: LD_STRING D4Fb-Frank-2
11327: PPUSH
11328: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11332: LD_EXP 21
11336: PPUSH
11337: LD_STRING D4Fb-JMM-2
11339: PPUSH
11340: CALL_OW 88
// DialogueOff ;
11344: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11348: LD_EXP 33
11352: PPUSH
11353: LD_INT 1
11355: PPUSH
11356: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11360: LD_EXP 34
11364: PPUSH
11365: CALL_OW 302
11369: PUSH
11370: LD_EXP 33
11374: NOT
11375: AND
11376: IFFALSE 11524
// begin DialogueOn ;
11378: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11382: LD_EXP 21
11386: PUSH
11387: LD_EXP 34
11391: PUSH
11392: EMPTY
11393: LIST
11394: LIST
11395: PPUSH
11396: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11400: LD_EXP 34
11404: PPUSH
11405: LD_STRING D3Y-Yam-1
11407: PPUSH
11408: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11412: LD_EXP 21
11416: PPUSH
11417: LD_STRING D3Y-JMM-1
11419: PPUSH
11420: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11424: LD_EXP 34
11428: PPUSH
11429: LD_STRING D3Y-Yam-2
11431: PPUSH
11432: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11436: LD_STRING QYamoko
11438: PPUSH
11439: CALL_OW 97
11443: PUSH
11444: LD_INT 1
11446: DOUBLE
11447: EQUAL
11448: IFTRUE 11452
11450: GO 11487
11452: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11453: LD_EXP 21
11457: PPUSH
11458: LD_STRING D3Ya-JMM-1
11460: PPUSH
11461: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11465: LD_EXP 34
11469: PPUSH
11470: LD_STRING D3Ya-Yam-1
11472: PPUSH
11473: CALL_OW 88
// us_scout := 1 ;
11477: LD_ADDR_EXP 8
11481: PUSH
11482: LD_INT 1
11484: ST_TO_ADDR
// end ; 2 :
11485: GO 11520
11487: LD_INT 2
11489: DOUBLE
11490: EQUAL
11491: IFTRUE 11495
11493: GO 11519
11495: POP
// begin us_scout := - 1 ;
11496: LD_ADDR_EXP 8
11500: PUSH
11501: LD_INT 1
11503: NEG
11504: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11505: LD_EXP 21
11509: PPUSH
11510: LD_STRING D3Yb-JMM-1
11512: PPUSH
11513: CALL_OW 88
// end ; end ;
11517: GO 11520
11519: POP
// DialogueOff ;
11520: CALL_OW 7
// end ; if Frank then
11524: LD_EXP 33
11528: IFFALSE 11532
// exit ;
11530: GO 12293
// if us_scout in [ - 1 , 0 ] then
11532: LD_EXP 8
11536: PUSH
11537: LD_INT 1
11539: NEG
11540: PUSH
11541: LD_INT 0
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: IN
11548: IFFALSE 11552
// exit ;
11550: GO 12293
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11552: LD_ADDR_EXP 8
11556: PUSH
11557: LD_INT 2
11559: PUSH
11560: LD_INT 2
11562: PUSH
11563: LD_INT 1
11565: PUSH
11566: EMPTY
11567: LIST
11568: LIST
11569: LIST
11570: PUSH
11571: LD_OWVAR 67
11575: ARRAY
11576: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11577: LD_EXP 8
11581: PUSH
11582: LD_INT 1
11584: PUSH
11585: LD_INT 2
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: IN
11592: IFFALSE 12293
// begin if IsInUnit ( Kikuchi ) then
11594: LD_EXP 34
11598: PPUSH
11599: CALL_OW 310
11603: IFFALSE 11614
// ComExitBuilding ( Kikuchi ) ;
11605: LD_EXP 34
11609: PPUSH
11610: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11614: LD_EXP 34
11618: PPUSH
11619: CALL_OW 311
11623: IFFALSE 11634
// ComExitVehicle ( Kikuchi ) ;
11625: LD_EXP 34
11629: PPUSH
11630: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11634: LD_EXP 34
11638: PPUSH
11639: LD_INT 4
11641: PPUSH
11642: CALL_OW 235
// wait ( 0 0$1 ) ;
11646: LD_INT 35
11648: PPUSH
11649: CALL_OW 67
// if us_scout = 2 then
11653: LD_EXP 8
11657: PUSH
11658: LD_INT 2
11660: EQUAL
11661: IFFALSE 12041
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11663: LD_EXP 34
11667: PPUSH
11668: LD_INT 75
11670: PPUSH
11671: LD_INT 63
11673: PPUSH
11674: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11678: LD_EXP 34
11682: PPUSH
11683: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11687: LD_EXP 34
11691: PPUSH
11692: LD_INT 770
11694: PPUSH
11695: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11699: LD_EXP 34
11703: PPUSH
11704: LD_INT 100
11706: PPUSH
11707: LD_INT 75
11709: PPUSH
11710: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11714: LD_EXP 34
11718: PPUSH
11719: LD_INT 123
11721: PPUSH
11722: LD_INT 103
11724: PPUSH
11725: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11729: LD_EXP 34
11733: PPUSH
11734: LD_INT 138
11736: PPUSH
11737: LD_INT 108
11739: PPUSH
11740: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11744: LD_EXP 34
11748: PPUSH
11749: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11753: LD_INT 35
11755: PPUSH
11756: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11760: LD_EXP 34
11764: PPUSH
11765: LD_INT 138
11767: PPUSH
11768: LD_INT 108
11770: PPUSH
11771: CALL_OW 307
11775: IFFALSE 11753
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11777: LD_EXP 34
11781: PPUSH
11782: LD_INT 125
11784: PPUSH
11785: LD_INT 132
11787: PPUSH
11788: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11792: LD_INT 35
11794: PPUSH
11795: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11799: LD_INT 1
11801: PPUSH
11802: LD_EXP 34
11806: PPUSH
11807: CALL_OW 292
11811: PUSH
11812: LD_EXP 34
11816: PPUSH
11817: LD_INT 7
11819: PPUSH
11820: CALL_OW 296
11824: PUSH
11825: LD_INT 7
11827: LESS
11828: OR
11829: IFFALSE 11792
// DialogueOn ;
11831: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11835: LD_EXP 34
11839: PPUSH
11840: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11844: LD_INT 10
11846: PPUSH
11847: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11851: LD_EXP 34
11855: PPUSH
11856: LD_STRING D4Ya-Yam-1
11858: PPUSH
11859: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11863: LD_EXP 21
11867: PPUSH
11868: LD_STRING D4Ya-JMM-1
11870: PPUSH
11871: CALL_OW 88
// for i in points do
11875: LD_ADDR_VAR 0 1
11879: PUSH
11880: LD_VAR 0 2
11884: PUSH
11885: FOR_IN
11886: IFFALSE 11944
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11888: LD_VAR 0 1
11892: PUSH
11893: LD_INT 1
11895: ARRAY
11896: PPUSH
11897: LD_VAR 0 1
11901: PUSH
11902: LD_INT 2
11904: ARRAY
11905: PPUSH
11906: LD_INT 1
11908: PPUSH
11909: LD_INT 20
11911: NEG
11912: PPUSH
11913: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11917: LD_VAR 0 1
11921: PUSH
11922: LD_INT 1
11924: ARRAY
11925: PPUSH
11926: LD_VAR 0 1
11930: PUSH
11931: LD_INT 2
11933: ARRAY
11934: PPUSH
11935: LD_INT 1
11937: PPUSH
11938: CALL_OW 331
// end ;
11942: GO 11885
11944: POP
11945: POP
// dwait ( 0 0$0.5 ) ;
11946: LD_INT 18
11948: PPUSH
11949: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11953: LD_INT 42
11955: PPUSH
11956: LD_INT 27
11958: PPUSH
11959: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11963: LD_EXP 34
11967: PPUSH
11968: LD_STRING D4Ya-Yam-2
11970: PPUSH
11971: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11975: LD_INT 18
11977: PPUSH
11978: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11982: LD_INT 118
11984: PPUSH
11985: LD_INT 80
11987: PPUSH
11988: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11992: LD_EXP 21
11996: PPUSH
11997: LD_STRING D4Ya-JMM-2
11999: PPUSH
12000: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12004: LD_EXP 34
12008: PPUSH
12009: LD_STRING D4Ya-Yam-3
12011: PPUSH
12012: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12016: LD_INT 10
12018: PPUSH
12019: CALL_OW 68
// DialogueOff ;
12023: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12027: LD_EXP 34
12031: PPUSH
12032: LD_INT 1
12034: PPUSH
12035: CALL_OW 235
// end else
12039: GO 12293
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12041: LD_INT 2
12043: PPUSH
12044: LD_INT 4
12046: PPUSH
12047: LD_INT 2
12049: PPUSH
12050: LD_INT 1
12052: PPUSH
12053: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12057: LD_EXP 34
12061: PPUSH
12062: LD_INT 75
12064: PPUSH
12065: LD_INT 63
12067: PPUSH
12068: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12072: LD_EXP 34
12076: PPUSH
12077: LD_INT 175
12079: PPUSH
12080: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12084: LD_EXP 34
12088: PPUSH
12089: LD_INT 102
12091: PPUSH
12092: LD_INT 76
12094: PPUSH
12095: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12099: LD_EXP 34
12103: PPUSH
12104: LD_INT 108
12106: PPUSH
12107: LD_INT 70
12109: PPUSH
12110: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12114: LD_INT 35
12116: PPUSH
12117: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12121: LD_INT 2
12123: PPUSH
12124: LD_EXP 34
12128: PPUSH
12129: CALL_OW 292
12133: IFFALSE 12114
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12135: LD_EXP 34
12139: PPUSH
12140: LD_INT 112
12142: PPUSH
12143: LD_INT 118
12145: PPUSH
12146: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12150: LD_EXP 34
12154: PPUSH
12155: CALL_OW 256
12159: PUSH
12160: LD_INT 750
12162: GREATEREQUAL
12163: IFFALSE 12177
// SetLives ( Kikuchi , 700 ) ;
12165: LD_EXP 34
12169: PPUSH
12170: LD_INT 700
12172: PPUSH
12173: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12177: LD_INT 35
12179: PPUSH
12180: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12184: LD_INT 1
12186: PPUSH
12187: LD_EXP 34
12191: PPUSH
12192: CALL_OW 292
12196: PUSH
12197: LD_EXP 34
12201: PPUSH
12202: LD_INT 7
12204: PPUSH
12205: CALL_OW 296
12209: PUSH
12210: LD_INT 17
12212: LESS
12213: OR
12214: IFFALSE 12177
// DialogueOn ;
12216: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12220: LD_EXP 34
12224: PPUSH
12225: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12229: LD_EXP 34
12233: PPUSH
12234: LD_STRING D4Yb-Yam-1
12236: PPUSH
12237: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12241: LD_EXP 21
12245: PPUSH
12246: LD_STRING D4Yb-JMM-1
12248: PPUSH
12249: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12253: LD_EXP 34
12257: PPUSH
12258: LD_STRING D4Yb-Yam-2
12260: PPUSH
12261: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12265: LD_EXP 21
12269: PPUSH
12270: LD_STRING D4Yb-JMM-2
12272: PPUSH
12273: CALL_OW 88
// DialogueOff ;
12277: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12281: LD_EXP 34
12285: PPUSH
12286: LD_INT 1
12288: PPUSH
12289: CALL_OW 235
// end ; end ; end ;
12293: PPOPN 2
12295: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12296: LD_EXP 6
12300: IFFALSE 13333
12302: GO 12304
12304: DISABLE
12305: LD_INT 0
12307: PPUSH
12308: PPUSH
12309: PPUSH
12310: PPUSH
// begin enable ;
12311: ENABLE
// if not seen [ 1 ] then
12312: LD_EXP 9
12316: PUSH
12317: LD_INT 1
12319: ARRAY
12320: NOT
12321: IFFALSE 12501
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12323: LD_ADDR_VAR 0 2
12327: PUSH
12328: LD_INT 22
12330: PUSH
12331: LD_INT 2
12333: PUSH
12334: EMPTY
12335: LIST
12336: LIST
12337: PUSH
12338: LD_INT 2
12340: PUSH
12341: LD_INT 25
12343: PUSH
12344: LD_INT 11
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PUSH
12351: LD_INT 33
12353: PUSH
12354: LD_INT 4
12356: PUSH
12357: EMPTY
12358: LIST
12359: LIST
12360: PUSH
12361: EMPTY
12362: LIST
12363: LIST
12364: LIST
12365: PUSH
12366: EMPTY
12367: LIST
12368: LIST
12369: PPUSH
12370: CALL_OW 69
12374: ST_TO_ADDR
// if tmp then
12375: LD_VAR 0 2
12379: IFFALSE 12501
// for i in tmp do
12381: LD_ADDR_VAR 0 1
12385: PUSH
12386: LD_VAR 0 2
12390: PUSH
12391: FOR_IN
12392: IFFALSE 12499
// if See ( 1 , i ) then
12394: LD_INT 1
12396: PPUSH
12397: LD_VAR 0 1
12401: PPUSH
12402: CALL_OW 292
12406: IFFALSE 12497
// begin seen := Replace ( seen , 1 , true ) ;
12408: LD_ADDR_EXP 9
12412: PUSH
12413: LD_EXP 9
12417: PPUSH
12418: LD_INT 1
12420: PPUSH
12421: LD_INT 1
12423: PPUSH
12424: CALL_OW 1
12428: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12429: LD_INT 1
12431: PPUSH
12432: CALL 16019 0 1
12436: IFFALSE 12497
// begin DialogueOn ;
12438: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12442: LD_VAR 0 1
12446: PPUSH
12447: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12451: LD_INT 10
12453: PPUSH
12454: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12458: LD_ADDR_VAR 0 3
12462: PUSH
12463: LD_INT 1
12465: PPUSH
12466: LD_STRING D5a-Sol2-1
12468: PPUSH
12469: CALL 16197 0 2
12473: ST_TO_ADDR
// if not un then
12474: LD_VAR 0 3
12478: NOT
12479: IFFALSE 12491
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12481: LD_INT 2
12483: PPUSH
12484: LD_STRING D5a-FSol2-1
12486: PPUSH
12487: CALL 16197 0 2
// DialogueOff ;
12491: CALL_OW 7
// break ;
12495: GO 12499
// end ; end ;
12497: GO 12391
12499: POP
12500: POP
// end ; if not seen [ 2 ] then
12501: LD_EXP 9
12505: PUSH
12506: LD_INT 2
12508: ARRAY
12509: NOT
12510: IFFALSE 12735
// begin can_kamikazed := true ;
12512: LD_ADDR_EXP 10
12516: PUSH
12517: LD_INT 1
12519: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12520: LD_ADDR_VAR 0 2
12524: PUSH
12525: LD_INT 22
12527: PUSH
12528: LD_INT 2
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PUSH
12535: LD_INT 25
12537: PUSH
12538: LD_INT 17
12540: PUSH
12541: EMPTY
12542: LIST
12543: LIST
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PPUSH
12549: CALL_OW 69
12553: ST_TO_ADDR
// if tmp then
12554: LD_VAR 0 2
12558: IFFALSE 12735
// for i in tmp do
12560: LD_ADDR_VAR 0 1
12564: PUSH
12565: LD_VAR 0 2
12569: PUSH
12570: FOR_IN
12571: IFFALSE 12733
// if See ( 1 , i ) then
12573: LD_INT 1
12575: PPUSH
12576: LD_VAR 0 1
12580: PPUSH
12581: CALL_OW 292
12585: IFFALSE 12731
// begin seen := Replace ( seen , 2 , true ) ;
12587: LD_ADDR_EXP 9
12591: PUSH
12592: LD_EXP 9
12596: PPUSH
12597: LD_INT 2
12599: PPUSH
12600: LD_INT 1
12602: PPUSH
12603: CALL_OW 1
12607: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12608: LD_INT 1
12610: PPUSH
12611: CALL 16019 0 1
12615: IFFALSE 12731
// begin DialogueOn ;
12617: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12621: LD_VAR 0 1
12625: PPUSH
12626: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12630: LD_INT 10
12632: PPUSH
12633: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12637: LD_ADDR_VAR 0 3
12641: PUSH
12642: LD_INT 1
12644: PPUSH
12645: LD_STRING D5b-Sol1-1
12647: PPUSH
12648: CALL 16197 0 2
12652: ST_TO_ADDR
// if not un then
12653: LD_VAR 0 3
12657: NOT
12658: IFFALSE 12676
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12660: LD_ADDR_VAR 0 3
12664: PUSH
12665: LD_INT 2
12667: PPUSH
12668: LD_STRING D5b-FSol1-1
12670: PPUSH
12671: CALL 16197 0 2
12675: ST_TO_ADDR
// if un then
12676: LD_VAR 0 3
12680: IFFALSE 12725
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12682: LD_ADDR_VAR 0 4
12686: PUSH
12687: LD_INT 1
12689: PPUSH
12690: LD_STRING D5b-Sol2-1
12692: PPUSH
12693: LD_VAR 0 3
12697: PPUSH
12698: CALL 16423 0 3
12702: ST_TO_ADDR
// if not un2 then
12703: LD_VAR 0 4
12707: NOT
12708: IFFALSE 12725
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12710: LD_INT 2
12712: PPUSH
12713: LD_STRING D5b-FSol2-1
12715: PPUSH
12716: LD_VAR 0 3
12720: PPUSH
12721: CALL 16423 0 3
// end ; DialogueOff ;
12725: CALL_OW 7
// break ;
12729: GO 12733
// end ; end ;
12731: GO 12570
12733: POP
12734: POP
// end ; if not seen [ 3 ] then
12735: LD_EXP 9
12739: PUSH
12740: LD_INT 3
12742: ARRAY
12743: NOT
12744: IFFALSE 12918
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12746: LD_ADDR_VAR 0 2
12750: PUSH
12751: LD_INT 22
12753: PUSH
12754: LD_INT 2
12756: PUSH
12757: EMPTY
12758: LIST
12759: LIST
12760: PUSH
12761: LD_INT 33
12763: PUSH
12764: LD_INT 2
12766: PUSH
12767: EMPTY
12768: LIST
12769: LIST
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PPUSH
12775: CALL_OW 69
12779: ST_TO_ADDR
// if tmp then
12780: LD_VAR 0 2
12784: IFFALSE 12918
// for i in tmp do
12786: LD_ADDR_VAR 0 1
12790: PUSH
12791: LD_VAR 0 2
12795: PUSH
12796: FOR_IN
12797: IFFALSE 12916
// if See ( 1 , i ) then
12799: LD_INT 1
12801: PPUSH
12802: LD_VAR 0 1
12806: PPUSH
12807: CALL_OW 292
12811: IFFALSE 12914
// begin seen := Replace ( seen , 3 , true ) ;
12813: LD_ADDR_EXP 9
12817: PUSH
12818: LD_EXP 9
12822: PPUSH
12823: LD_INT 3
12825: PPUSH
12826: LD_INT 1
12828: PPUSH
12829: CALL_OW 1
12833: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12834: LD_INT 1
12836: PPUSH
12837: CALL 16019 0 1
12841: IFFALSE 12914
// begin DialogueOn ;
12843: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12847: LD_VAR 0 1
12851: PPUSH
12852: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12856: LD_INT 10
12858: PPUSH
12859: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12863: LD_ADDR_VAR 0 3
12867: PUSH
12868: LD_INT 1
12870: PPUSH
12871: LD_STRING D8-Sol1-1
12873: PPUSH
12874: CALL 16197 0 2
12878: ST_TO_ADDR
// if not un then
12879: LD_VAR 0 3
12883: NOT
12884: IFFALSE 12896
// SayRand ( sex_female , D8-FSol1-1 ) ;
12886: LD_INT 2
12888: PPUSH
12889: LD_STRING D8-FSol1-1
12891: PPUSH
12892: CALL 16197 0 2
// Say ( JMM , D8-JMM-1 ) ;
12896: LD_EXP 21
12900: PPUSH
12901: LD_STRING D8-JMM-1
12903: PPUSH
12904: CALL_OW 88
// DialogueOff ;
12908: CALL_OW 7
// break ;
12912: GO 12916
// end ; end ;
12914: GO 12796
12916: POP
12917: POP
// end ; if not seen [ 4 ] then
12918: LD_EXP 9
12922: PUSH
12923: LD_INT 4
12925: ARRAY
12926: NOT
12927: IFFALSE 13089
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12929: LD_ADDR_VAR 0 2
12933: PUSH
12934: LD_INT 22
12936: PUSH
12937: LD_INT 2
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: PUSH
12944: LD_INT 33
12946: PUSH
12947: LD_INT 5
12949: PUSH
12950: EMPTY
12951: LIST
12952: LIST
12953: PUSH
12954: EMPTY
12955: LIST
12956: LIST
12957: PPUSH
12958: CALL_OW 69
12962: ST_TO_ADDR
// if tmp then
12963: LD_VAR 0 2
12967: IFFALSE 13089
// for i in tmp do
12969: LD_ADDR_VAR 0 1
12973: PUSH
12974: LD_VAR 0 2
12978: PUSH
12979: FOR_IN
12980: IFFALSE 13087
// if See ( 1 , i ) then
12982: LD_INT 1
12984: PPUSH
12985: LD_VAR 0 1
12989: PPUSH
12990: CALL_OW 292
12994: IFFALSE 13085
// begin seen := Replace ( seen , 4 , true ) ;
12996: LD_ADDR_EXP 9
13000: PUSH
13001: LD_EXP 9
13005: PPUSH
13006: LD_INT 4
13008: PPUSH
13009: LD_INT 1
13011: PPUSH
13012: CALL_OW 1
13016: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13017: LD_INT 1
13019: PPUSH
13020: CALL 16019 0 1
13024: IFFALSE 13085
// begin DialogueOn ;
13026: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13030: LD_VAR 0 1
13034: PPUSH
13035: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13039: LD_INT 10
13041: PPUSH
13042: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13046: LD_ADDR_VAR 0 3
13050: PUSH
13051: LD_INT 1
13053: PPUSH
13054: LD_STRING D5a-Sol1-1
13056: PPUSH
13057: CALL 16197 0 2
13061: ST_TO_ADDR
// if not un then
13062: LD_VAR 0 3
13066: NOT
13067: IFFALSE 13079
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13069: LD_INT 2
13071: PPUSH
13072: LD_STRING D5a-FSol1-1
13074: PPUSH
13075: CALL 16197 0 2
// DialogueOff ;
13079: CALL_OW 7
// break ;
13083: GO 13087
// end ; end ;
13085: GO 12979
13087: POP
13088: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13089: LD_EXP 9
13093: PUSH
13094: LD_INT 5
13096: ARRAY
13097: NOT
13098: PUSH
13099: LD_EXP 9
13103: PUSH
13104: LD_INT 3
13106: ARRAY
13107: AND
13108: IFFALSE 13282
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_INT 22
13117: PUSH
13118: LD_INT 2
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: PUSH
13125: LD_INT 34
13127: PUSH
13128: LD_INT 31
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: CALL_OW 69
13143: ST_TO_ADDR
// if tmp then
13144: LD_VAR 0 2
13148: IFFALSE 13282
// for i in tmp do
13150: LD_ADDR_VAR 0 1
13154: PUSH
13155: LD_VAR 0 2
13159: PUSH
13160: FOR_IN
13161: IFFALSE 13280
// if See ( 1 , i ) then
13163: LD_INT 1
13165: PPUSH
13166: LD_VAR 0 1
13170: PPUSH
13171: CALL_OW 292
13175: IFFALSE 13278
// begin seen := Replace ( seen , 5 , true ) ;
13177: LD_ADDR_EXP 9
13181: PUSH
13182: LD_EXP 9
13186: PPUSH
13187: LD_INT 5
13189: PPUSH
13190: LD_INT 1
13192: PPUSH
13193: CALL_OW 1
13197: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13198: LD_INT 1
13200: PPUSH
13201: CALL 16019 0 1
13205: IFFALSE 13278
// begin DialogueOn ;
13207: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13211: LD_VAR 0 1
13215: PPUSH
13216: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13220: LD_INT 10
13222: PPUSH
13223: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13227: LD_ADDR_VAR 0 3
13231: PUSH
13232: LD_INT 1
13234: PPUSH
13235: LD_STRING D8a-Sol2-1
13237: PPUSH
13238: CALL 16197 0 2
13242: ST_TO_ADDR
// if not un then
13243: LD_VAR 0 3
13247: NOT
13248: IFFALSE 13260
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13250: LD_INT 2
13252: PPUSH
13253: LD_STRING D8a-FSol2-1
13255: PPUSH
13256: CALL 16197 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13260: LD_EXP 21
13264: PPUSH
13265: LD_STRING D8a-JMM-1
13267: PPUSH
13268: CALL_OW 88
// DialogueOff ;
13272: CALL_OW 7
// break ;
13276: GO 13280
// end ; end ;
13278: GO 13160
13280: POP
13281: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13282: LD_EXP 9
13286: PUSH
13287: LD_INT 1
13289: ARRAY
13290: PUSH
13291: LD_EXP 9
13295: PUSH
13296: LD_INT 2
13298: ARRAY
13299: AND
13300: PUSH
13301: LD_EXP 9
13305: PUSH
13306: LD_INT 3
13308: ARRAY
13309: AND
13310: PUSH
13311: LD_EXP 9
13315: PUSH
13316: LD_INT 4
13318: ARRAY
13319: AND
13320: PUSH
13321: LD_EXP 9
13325: PUSH
13326: LD_INT 5
13328: ARRAY
13329: AND
13330: IFFALSE 13333
// disable ;
13332: DISABLE
// end ;
13333: PPOPN 4
13335: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13336: LD_EXP 10
13340: PUSH
13341: LD_EXP 11
13345: AND
13346: IFFALSE 13544
13348: GO 13350
13350: DISABLE
13351: LD_INT 0
13353: PPUSH
// begin DialogueOn ;
13354: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13358: LD_EXP 11
13362: PPUSH
13363: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13367: LD_ADDR_VAR 0 1
13371: PUSH
13372: LD_INT 1
13374: PPUSH
13375: LD_STRING D5c-Sol1-1
13377: PPUSH
13378: CALL 16197 0 2
13382: ST_TO_ADDR
// if not un then
13383: LD_VAR 0 1
13387: NOT
13388: IFFALSE 13406
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13390: LD_ADDR_VAR 0 1
13394: PUSH
13395: LD_INT 2
13397: PPUSH
13398: LD_STRING D5c-FSol1-1
13400: PPUSH
13401: CALL 16197 0 2
13405: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13406: LD_EXP 21
13410: PPUSH
13411: LD_STRING D5c-JMM-1
13413: PPUSH
13414: CALL_OW 88
// if IsOk ( Lisa ) then
13418: LD_EXP 22
13422: PPUSH
13423: CALL_OW 302
13427: IFFALSE 13443
// Say ( Lisa , D5d-Lisa-1 ) else
13429: LD_EXP 22
13433: PPUSH
13434: LD_STRING D5d-Lisa-1
13436: PPUSH
13437: CALL_OW 88
13441: GO 13528
// if IsOk ( Cyrus ) then
13443: LD_EXP 25
13447: PPUSH
13448: CALL_OW 302
13452: IFFALSE 13468
// Say ( Cyrus , D5d-Cyrus-1 ) else
13454: LD_EXP 25
13458: PPUSH
13459: LD_STRING D5d-Cyrus-1
13461: PPUSH
13462: CALL_OW 88
13466: GO 13528
// if IsOk ( Gary ) then
13468: LD_EXP 32
13472: PPUSH
13473: CALL_OW 302
13477: IFFALSE 13493
// Say ( Gary , D5d-Gary-1 ) else
13479: LD_EXP 32
13483: PPUSH
13484: LD_STRING D5d-Gary-1
13486: PPUSH
13487: CALL_OW 88
13491: GO 13528
// if GetSex ( un ) = sex_male then
13493: LD_VAR 0 1
13497: PPUSH
13498: CALL_OW 258
13502: PUSH
13503: LD_INT 1
13505: EQUAL
13506: IFFALSE 13522
// Say ( un , D5d-Sol1-1 ) else
13508: LD_VAR 0 1
13512: PPUSH
13513: LD_STRING D5d-Sol1-1
13515: PPUSH
13516: CALL_OW 88
13520: GO 13528
// begin DialogueOff ;
13522: CALL_OW 7
// exit ;
13526: GO 13544
// end ; Say ( JMM , D5d-JMM-1 ) ;
13528: LD_EXP 21
13532: PPUSH
13533: LD_STRING D5d-JMM-1
13535: PPUSH
13536: CALL_OW 88
// DialogueOff ;
13540: CALL_OW 7
// end ;
13544: PPOPN 1
13546: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13547: LD_INT 1
13549: PPUSH
13550: LD_INT 17
13552: PPUSH
13553: CALL_OW 294
13557: PUSH
13558: LD_INT 2
13560: GREATEREQUAL
13561: IFFALSE 13682
13563: GO 13565
13565: DISABLE
13566: LD_INT 0
13568: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13569: LD_INT 10
13571: PPUSH
13572: LD_INT 5
13574: PPUSH
13575: LD_INT 1
13577: PPUSH
13578: LD_INT 10
13580: NEG
13581: PPUSH
13582: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13586: LD_INT 10
13588: PPUSH
13589: LD_INT 5
13591: PPUSH
13592: LD_INT 1
13594: PPUSH
13595: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13599: LD_INT 10
13601: PPUSH
13602: LD_INT 5
13604: PPUSH
13605: CALL_OW 86
// DialogueOn ;
13609: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13613: LD_ADDR_VAR 0 1
13617: PUSH
13618: LD_INT 1
13620: PPUSH
13621: LD_STRING D6-Sci1-1
13623: PPUSH
13624: CALL 16197 0 2
13628: ST_TO_ADDR
// if un then
13629: LD_VAR 0 1
13633: IFFALSE 13671
// begin Say ( JMM , D6-JMM-1 ) ;
13635: LD_EXP 21
13639: PPUSH
13640: LD_STRING D6-JMM-1
13642: PPUSH
13643: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13647: LD_VAR 0 1
13651: PPUSH
13652: LD_STRING D6-Sci1-2
13654: PPUSH
13655: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13659: LD_EXP 21
13663: PPUSH
13664: LD_STRING D6-JMM-2
13666: PPUSH
13667: CALL_OW 88
// end ; DialogueOff ;
13671: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13675: LD_STRING M3
13677: PPUSH
13678: CALL_OW 337
// end ;
13682: PPOPN 1
13684: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
13685: LD_OWVAR 1
13689: PUSH
13690: LD_INT 42000
13692: GREATEREQUAL
13693: PUSH
13694: LD_INT 2
13696: PPUSH
13697: LD_INT 169
13699: PPUSH
13700: LD_INT 90
13702: PPUSH
13703: LD_INT 10
13705: PPUSH
13706: CALL 53263 0 4
13710: PUSH
13711: LD_INT 4
13713: ARRAY
13714: PUSH
13715: LD_INT 0
13717: EQUAL
13718: PUSH
13719: LD_INT 45
13721: PPUSH
13722: CALL_OW 301
13726: OR
13727: PUSH
13728: LD_INT 45
13730: PPUSH
13731: CALL_OW 255
13735: PUSH
13736: LD_INT 1
13738: EQUAL
13739: OR
13740: AND
13741: PUSH
13742: LD_INT 94
13744: PPUSH
13745: CALL_OW 301
13749: NOT
13750: AND
13751: IFFALSE 14956
13753: GO 13755
13755: DISABLE
13756: LD_INT 0
13758: PPUSH
13759: PPUSH
13760: PPUSH
13761: PPUSH
13762: PPUSH
// begin uc_side := 5 ;
13763: LD_ADDR_OWVAR 20
13767: PUSH
13768: LD_INT 5
13770: ST_TO_ADDR
// uc_nation := 2 ;
13771: LD_ADDR_OWVAR 21
13775: PUSH
13776: LD_INT 2
13778: ST_TO_ADDR
// InitHc ;
13779: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13783: LD_INT 1
13785: PPUSH
13786: LD_INT 3
13788: PPUSH
13789: LD_INT 8
13791: PPUSH
13792: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13796: LD_ADDR_OWVAR 29
13800: PUSH
13801: LD_INT 12
13803: PUSH
13804: LD_INT 12
13806: PUSH
13807: EMPTY
13808: LIST
13809: LIST
13810: ST_TO_ADDR
// hc_name := Hans Felige ;
13811: LD_ADDR_OWVAR 26
13815: PUSH
13816: LD_STRING Hans Felige
13818: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13819: LD_ADDR_OWVAR 33
13823: PUSH
13824: LD_STRING SecondCharsGal
13826: ST_TO_ADDR
// hc_face_number := 7 ;
13827: LD_ADDR_OWVAR 34
13831: PUSH
13832: LD_INT 7
13834: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13835: LD_ADDR_EXP 46
13839: PUSH
13840: CALL_OW 44
13844: ST_TO_ADDR
// InitHc ;
13845: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13849: LD_INT 1
13851: PPUSH
13852: LD_INT 16
13854: PPUSH
13855: LD_INT 2
13857: PPUSH
13858: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13862: LD_ADDR_OWVAR 29
13866: PUSH
13867: LD_INT 12
13869: PUSH
13870: LD_INT 12
13872: PUSH
13873: EMPTY
13874: LIST
13875: LIST
13876: ST_TO_ADDR
// hc_name :=  ;
13877: LD_ADDR_OWVAR 26
13881: PUSH
13882: LD_STRING 
13884: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13885: LD_ADDR_EXP 47
13889: PUSH
13890: CALL_OW 44
13894: ST_TO_ADDR
// InitHc ;
13895: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13899: LD_INT 35
13901: PPUSH
13902: CALL_OW 67
// until not InBattle ( 1 ) ;
13906: LD_INT 1
13908: PPUSH
13909: CALL_OW 463
13913: NOT
13914: IFFALSE 13899
// wait ( 0 0$5 ) ;
13916: LD_INT 175
13918: PPUSH
13919: CALL_OW 67
// DialogueOn ;
13923: CALL_OW 6
// InGameOn ;
13927: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13931: LD_ADDR_VAR 0 1
13935: PUSH
13936: LD_INT 22
13938: PUSH
13939: LD_INT 1
13941: PUSH
13942: EMPTY
13943: LIST
13944: LIST
13945: PUSH
13946: LD_INT 2
13948: PUSH
13949: LD_INT 25
13951: PUSH
13952: LD_INT 1
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PUSH
13959: LD_INT 25
13961: PUSH
13962: LD_INT 2
13964: PUSH
13965: EMPTY
13966: LIST
13967: LIST
13968: PUSH
13969: LD_INT 25
13971: PUSH
13972: LD_INT 3
13974: PUSH
13975: EMPTY
13976: LIST
13977: LIST
13978: PUSH
13979: LD_INT 25
13981: PUSH
13982: LD_INT 4
13984: PUSH
13985: EMPTY
13986: LIST
13987: LIST
13988: PUSH
13989: LD_INT 25
13991: PUSH
13992: LD_INT 5
13994: PUSH
13995: EMPTY
13996: LIST
13997: LIST
13998: PUSH
13999: LD_INT 25
14001: PUSH
14002: LD_INT 8
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: PUSH
14009: EMPTY
14010: LIST
14011: LIST
14012: LIST
14013: LIST
14014: LIST
14015: LIST
14016: LIST
14017: PUSH
14018: EMPTY
14019: LIST
14020: LIST
14021: PPUSH
14022: CALL_OW 69
14026: PUSH
14027: LD_EXP 21
14031: PUSH
14032: LD_EXP 22
14036: PUSH
14037: LD_EXP 23
14041: PUSH
14042: LD_EXP 24
14046: PUSH
14047: LD_EXP 25
14051: PUSH
14052: LD_EXP 26
14056: PUSH
14057: LD_EXP 27
14061: PUSH
14062: LD_EXP 28
14066: PUSH
14067: LD_EXP 29
14071: PUSH
14072: LD_EXP 31
14076: PUSH
14077: LD_EXP 32
14081: PUSH
14082: LD_EXP 33
14086: PUSH
14087: LD_EXP 34
14091: PUSH
14092: EMPTY
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: DIFF
14107: PPUSH
14108: LD_INT 26
14110: PUSH
14111: LD_INT 1
14113: PUSH
14114: EMPTY
14115: LIST
14116: LIST
14117: PPUSH
14118: CALL_OW 72
14122: PUSH
14123: LD_INT 1
14125: ARRAY
14126: ST_TO_ADDR
// if Brown then
14127: LD_EXP 27
14131: IFFALSE 14143
// un := Brown ;
14133: LD_ADDR_VAR 0 1
14137: PUSH
14138: LD_EXP 27
14142: ST_TO_ADDR
// if un then
14143: LD_VAR 0 1
14147: IFFALSE 14173
// begin Say ( un , D7-Sol1-1 ) ;
14149: LD_VAR 0 1
14153: PPUSH
14154: LD_STRING D7-Sol1-1
14156: PPUSH
14157: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14161: LD_EXP 21
14165: PPUSH
14166: LD_STRING D7-JMM-1
14168: PPUSH
14169: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14173: LD_EXP 46
14177: PPUSH
14178: LD_STRING D7-Ar1-1
14180: PPUSH
14181: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14185: LD_EXP 21
14189: PPUSH
14190: LD_STRING D7-JMM-2
14192: PPUSH
14193: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14197: LD_EXP 46
14201: PPUSH
14202: LD_STRING D7-Ar1-2
14204: PPUSH
14205: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14209: LD_EXP 21
14213: PPUSH
14214: LD_STRING D7-JMM-3
14216: PPUSH
14217: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14221: LD_EXP 46
14225: PPUSH
14226: LD_STRING D7-Ar1-3
14228: PPUSH
14229: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14233: LD_EXP 21
14237: PPUSH
14238: LD_STRING D7-JMM-4
14240: PPUSH
14241: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14245: LD_EXP 46
14249: PPUSH
14250: LD_STRING D7-Ar1-4
14252: PPUSH
14253: CALL_OW 94
// InGameOff ;
14257: CALL_OW 9
// DialogueOff ;
14261: CALL_OW 7
// case Query ( QCameras ) of 1 :
14265: LD_STRING QCameras
14267: PPUSH
14268: CALL_OW 97
14272: PUSH
14273: LD_INT 1
14275: DOUBLE
14276: EQUAL
14277: IFTRUE 14281
14279: GO 14284
14281: POP
// ; 2 :
14282: GO 14298
14284: LD_INT 2
14286: DOUBLE
14287: EQUAL
14288: IFTRUE 14292
14290: GO 14297
14292: POP
// exit ; end ;
14293: GO 14956
14295: GO 14298
14297: POP
// ChangeMissionObjectives ( MCar ) ;
14298: LD_STRING MCar
14300: PPUSH
14301: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14305: LD_INT 124
14307: PPUSH
14308: LD_INT 90
14310: PPUSH
14311: LD_INT 1
14313: PPUSH
14314: LD_INT 6
14316: NEG
14317: PPUSH
14318: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14322: LD_INT 124
14324: PPUSH
14325: LD_INT 90
14327: PPUSH
14328: LD_INT 1
14330: PPUSH
14331: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14335: LD_INT 12
14337: PPUSH
14338: LD_INT 1
14340: PPUSH
14341: CALL_OW 424
// wait ( 3 ) ;
14345: LD_INT 3
14347: PPUSH
14348: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14352: LD_INT 124
14354: PPUSH
14355: LD_INT 90
14357: PPUSH
14358: CALL_OW 86
// cargo := false ;
14362: LD_ADDR_VAR 0 3
14366: PUSH
14367: LD_INT 0
14369: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14370: LD_INT 35
14372: PPUSH
14373: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14377: LD_ADDR_VAR 0 3
14381: PUSH
14382: LD_INT 12
14384: PPUSH
14385: LD_INT 32
14387: PUSH
14388: LD_INT 3
14390: PUSH
14391: EMPTY
14392: LIST
14393: LIST
14394: PUSH
14395: LD_INT 34
14397: PUSH
14398: LD_INT 32
14400: PUSH
14401: EMPTY
14402: LIST
14403: LIST
14404: PUSH
14405: LD_INT 58
14407: PUSH
14408: EMPTY
14409: LIST
14410: PUSH
14411: EMPTY
14412: LIST
14413: LIST
14414: LIST
14415: PPUSH
14416: CALL_OW 70
14420: ST_TO_ADDR
// until cargo ;
14421: LD_VAR 0 3
14425: IFFALSE 14370
// cargo := cargo [ 1 ] ;
14427: LD_ADDR_VAR 0 3
14431: PUSH
14432: LD_VAR 0 3
14436: PUSH
14437: LD_INT 1
14439: ARRAY
14440: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14441: LD_VAR 0 3
14445: PPUSH
14446: LD_INT 5
14448: PPUSH
14449: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14453: LD_INT 12
14455: PPUSH
14456: LD_INT 0
14458: PPUSH
14459: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14463: LD_EXP 46
14467: PPUSH
14468: LD_INT 11
14470: PPUSH
14471: LD_INT 0
14473: PPUSH
14474: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14478: LD_EXP 47
14482: PPUSH
14483: LD_INT 11
14485: PPUSH
14486: LD_INT 0
14488: PPUSH
14489: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14493: LD_EXP 46
14497: PUSH
14498: LD_EXP 47
14502: PUSH
14503: EMPTY
14504: LIST
14505: LIST
14506: PPUSH
14507: LD_INT 12
14509: PPUSH
14510: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14514: LD_EXP 46
14518: PPUSH
14519: LD_VAR 0 3
14523: PPUSH
14524: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14528: LD_EXP 46
14532: PUSH
14533: LD_EXP 47
14537: PUSH
14538: EMPTY
14539: LIST
14540: LIST
14541: PPUSH
14542: LD_INT 209
14544: PPUSH
14545: LD_INT 178
14547: PPUSH
14548: CALL_OW 171
// escaped := 0 ;
14552: LD_ADDR_VAR 0 5
14556: PUSH
14557: LD_INT 0
14559: ST_TO_ADDR
// while ( true ) do
14560: LD_INT 1
14562: IFFALSE 14778
// begin wait ( 0 0$1 ) ;
14564: LD_INT 35
14566: PPUSH
14567: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14571: LD_EXP 46
14575: PPUSH
14576: CALL_OW 314
14580: NOT
14581: PUSH
14582: LD_EXP 47
14586: PPUSH
14587: CALL_OW 314
14591: NOT
14592: OR
14593: IFFALSE 14619
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14595: LD_EXP 46
14599: PUSH
14600: LD_EXP 47
14604: PUSH
14605: EMPTY
14606: LIST
14607: LIST
14608: PPUSH
14609: LD_INT 209
14611: PPUSH
14612: LD_INT 178
14614: PPUSH
14615: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14619: LD_EXP 46
14623: PPUSH
14624: LD_INT 10
14626: PPUSH
14627: CALL_OW 308
14631: IFFALSE 14656
// begin RemoveUnit ( ar_mechanic ) ;
14633: LD_EXP 46
14637: PPUSH
14638: CALL_OW 64
// escaped := escaped + 1 ;
14642: LD_ADDR_VAR 0 5
14646: PUSH
14647: LD_VAR 0 5
14651: PUSH
14652: LD_INT 1
14654: PLUS
14655: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
14656: LD_EXP 47
14660: PPUSH
14661: LD_INT 10
14663: PPUSH
14664: CALL_OW 308
14668: IFFALSE 14693
// begin RemoveUnit ( ar_mechanic_friend ) ;
14670: LD_EXP 47
14674: PPUSH
14675: CALL_OW 64
// escaped := escaped + 1 ;
14679: LD_ADDR_VAR 0 5
14683: PUSH
14684: LD_VAR 0 5
14688: PUSH
14689: LD_INT 1
14691: PLUS
14692: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
14693: LD_VAR 0 3
14697: PPUSH
14698: LD_INT 10
14700: PPUSH
14701: CALL_OW 308
14705: IFFALSE 14716
// RemoveUnit ( cargo ) ;
14707: LD_VAR 0 3
14711: PPUSH
14712: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
14716: LD_EXP 46
14720: PPUSH
14721: CALL_OW 305
14725: NOT
14726: PUSH
14727: LD_VAR 0 5
14731: PUSH
14732: LD_INT 2
14734: GREATEREQUAL
14735: AND
14736: IFFALSE 14740
// break ;
14738: GO 14778
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
14740: LD_EXP 46
14744: PPUSH
14745: CALL_OW 305
14749: NOT
14750: PUSH
14751: LD_EXP 47
14755: PPUSH
14756: CALL_OW 305
14760: NOT
14761: AND
14762: PUSH
14763: LD_VAR 0 5
14767: PUSH
14768: LD_INT 2
14770: LESS
14771: AND
14772: IFFALSE 14776
// exit ;
14774: GO 14956
// end ;
14776: GO 14560
// wait ( 0 0$2 ) ;
14778: LD_INT 70
14780: PPUSH
14781: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14785: LD_EXP 46
14789: PPUSH
14790: LD_STRING D7a-Ar1-1
14792: PPUSH
14793: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14797: LD_ADDR_VAR 0 4
14801: PUSH
14802: LD_INT 129
14804: PUSH
14805: LD_INT 10
14807: PUSH
14808: EMPTY
14809: LIST
14810: LIST
14811: PUSH
14812: LD_INT 103
14814: PUSH
14815: LD_INT 6
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: PUSH
14822: LD_INT 148
14824: PUSH
14825: LD_INT 47
14827: PUSH
14828: EMPTY
14829: LIST
14830: LIST
14831: PUSH
14832: LD_INT 155
14834: PUSH
14835: LD_INT 16
14837: PUSH
14838: EMPTY
14839: LIST
14840: LIST
14841: PUSH
14842: EMPTY
14843: LIST
14844: LIST
14845: LIST
14846: LIST
14847: ST_TO_ADDR
// if Difficulty = 1 then
14848: LD_OWVAR 67
14852: PUSH
14853: LD_INT 1
14855: EQUAL
14856: IFFALSE 14893
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14858: LD_ADDR_VAR 0 4
14862: PUSH
14863: LD_VAR 0 4
14867: PUSH
14868: LD_INT 78
14870: PUSH
14871: LD_INT 7
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: LD_INT 104
14880: PUSH
14881: LD_INT 43
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PUSH
14888: EMPTY
14889: LIST
14890: LIST
14891: ADD
14892: ST_TO_ADDR
// for i in tmp do
14893: LD_ADDR_VAR 0 2
14897: PUSH
14898: LD_VAR 0 4
14902: PUSH
14903: FOR_IN
14904: IFFALSE 14937
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14906: LD_VAR 0 2
14910: PUSH
14911: LD_INT 1
14913: ARRAY
14914: PPUSH
14915: LD_VAR 0 2
14919: PUSH
14920: LD_INT 2
14922: ARRAY
14923: PPUSH
14924: LD_INT 1
14926: PPUSH
14927: LD_INT 9
14929: NEG
14930: PPUSH
14931: CALL_OW 330
14935: GO 14903
14937: POP
14938: POP
// SetAchievement ( ACH_FRIEND ) ;
14939: LD_STRING ACH_FRIEND
14941: PPUSH
14942: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
14946: LD_INT 129
14948: PPUSH
14949: LD_INT 10
14951: PPUSH
14952: CALL_OW 84
// end ;
14956: PPOPN 5
14958: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14959: LD_EXP 15
14963: PUSH
14964: LD_INT 21000
14966: MINUS
14967: PUSH
14968: LD_OWVAR 1
14972: LESSEQUAL
14973: IFFALSE 15013
14975: GO 14977
14977: DISABLE
// begin powell_warn := true ;
14978: LD_ADDR_EXP 16
14982: PUSH
14983: LD_INT 1
14985: ST_TO_ADDR
// DialogueOn ;
14986: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14990: LD_EXP 30
14994: PPUSH
14995: LD_STRING D9-Pow-1
14997: PPUSH
14998: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15002: LD_INT 10
15004: PPUSH
15005: CALL_OW 68
// DialogueOff ;
15009: CALL_OW 7
// end ;
15013: END
// every 0 0$1 trigger game_time <= tick do
15014: LD_EXP 15
15018: PUSH
15019: LD_OWVAR 1
15023: LESSEQUAL
15024: IFFALSE 15063
15026: GO 15028
15028: DISABLE
// begin DialogueOn ;
15029: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15033: LD_EXP 30
15037: PPUSH
15038: LD_STRING D9a-Pow-1
15040: PPUSH
15041: CALL_OW 94
// dwait ( 0 0$2 ) ;
15045: LD_INT 70
15047: PPUSH
15048: CALL_OW 68
// DialogueOff ;
15052: CALL_OW 7
// YouLost ( Command ) ;
15056: LD_STRING Command
15058: PPUSH
15059: CALL_OW 104
// end ;
15063: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15064: LD_INT 22
15066: PUSH
15067: LD_INT 2
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: PUSH
15074: LD_INT 30
15076: PUSH
15077: LD_INT 1
15079: PUSH
15080: EMPTY
15081: LIST
15082: LIST
15083: PUSH
15084: EMPTY
15085: LIST
15086: LIST
15087: PPUSH
15088: CALL_OW 69
15092: PUSH
15093: LD_INT 0
15095: EQUAL
15096: PUSH
15097: LD_EXP 21
15101: PPUSH
15102: CALL_OW 302
15106: AND
15107: IFFALSE 16016
15109: GO 15111
15111: DISABLE
15112: LD_INT 0
15114: PPUSH
15115: PPUSH
15116: PPUSH
15117: PPUSH
// begin m1 := false ;
15118: LD_ADDR_VAR 0 2
15122: PUSH
15123: LD_INT 0
15125: ST_TO_ADDR
// m2 := false ;
15126: LD_ADDR_VAR 0 3
15130: PUSH
15131: LD_INT 0
15133: ST_TO_ADDR
// m3 := false ;
15134: LD_ADDR_VAR 0 4
15138: PUSH
15139: LD_INT 0
15141: ST_TO_ADDR
// if not am_veh_consturcted then
15142: LD_EXP 20
15146: NOT
15147: IFFALSE 15156
// SetAchievement ( ACH_ARABTECH ) ;
15149: LD_STRING ACH_ARABTECH
15151: PPUSH
15152: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
15156: LD_OWVAR 1
15160: PUSH
15161: LD_INT 252000
15163: PUSH
15164: LD_INT 210000
15166: PUSH
15167: LD_INT 199500
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: LIST
15174: PUSH
15175: LD_OWVAR 67
15179: ARRAY
15180: LESS
15181: IFFALSE 15203
// begin m3 := true ;
15183: LD_ADDR_VAR 0 4
15187: PUSH
15188: LD_INT 1
15190: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15191: LD_STRING Time1
15193: PPUSH
15194: LD_INT 1
15196: PPUSH
15197: CALL_OW 101
// end else
15201: GO 15234
// if not powell_warn then
15203: LD_EXP 16
15207: NOT
15208: IFFALSE 15223
// AddMedal ( Time1 , - 1 ) else
15210: LD_STRING Time1
15212: PPUSH
15213: LD_INT 1
15215: NEG
15216: PPUSH
15217: CALL_OW 101
15221: GO 15234
// AddMedal ( Time1 , - 2 ) ;
15223: LD_STRING Time1
15225: PPUSH
15226: LD_INT 2
15228: NEG
15229: PPUSH
15230: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15234: LD_EXP 17
15238: PUSH
15239: LD_INT 5
15241: PUSH
15242: LD_INT 4
15244: PUSH
15245: LD_INT 3
15247: PUSH
15248: EMPTY
15249: LIST
15250: LIST
15251: LIST
15252: PUSH
15253: LD_OWVAR 67
15257: ARRAY
15258: GREATEREQUAL
15259: IFFALSE 15274
// AddMedal ( Destroy , - 2 ) else
15261: LD_STRING Destroy
15263: PPUSH
15264: LD_INT 2
15266: NEG
15267: PPUSH
15268: CALL_OW 101
15272: GO 15407
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15274: LD_INT 22
15276: PUSH
15277: LD_INT 2
15279: PUSH
15280: EMPTY
15281: LIST
15282: LIST
15283: PUSH
15284: LD_INT 21
15286: PUSH
15287: LD_INT 3
15289: PUSH
15290: EMPTY
15291: LIST
15292: LIST
15293: PUSH
15294: LD_INT 50
15296: PUSH
15297: EMPTY
15298: LIST
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: LIST
15304: PPUSH
15305: CALL_OW 69
15309: PUSH
15310: LD_INT 25
15312: GREATEREQUAL
15313: IFFALSE 15328
// AddMedal ( Destroy , - 1 ) else
15315: LD_STRING Destroy
15317: PPUSH
15318: LD_INT 1
15320: NEG
15321: PPUSH
15322: CALL_OW 101
15326: GO 15407
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15328: LD_INT 22
15330: PUSH
15331: LD_INT 2
15333: PUSH
15334: EMPTY
15335: LIST
15336: LIST
15337: PUSH
15338: LD_INT 21
15340: PUSH
15341: LD_INT 3
15343: PUSH
15344: EMPTY
15345: LIST
15346: LIST
15347: PUSH
15348: LD_INT 50
15350: PUSH
15351: EMPTY
15352: LIST
15353: PUSH
15354: EMPTY
15355: LIST
15356: LIST
15357: LIST
15358: PPUSH
15359: CALL_OW 69
15363: PUSH
15364: LD_INT 15
15366: GREATEREQUAL
15367: IFFALSE 15389
// begin m1 := true ;
15369: LD_ADDR_VAR 0 2
15373: PUSH
15374: LD_INT 1
15376: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15377: LD_STRING Destroy
15379: PPUSH
15380: LD_INT 1
15382: PPUSH
15383: CALL_OW 101
// end else
15387: GO 15407
// begin m1 := true ;
15389: LD_ADDR_VAR 0 2
15393: PUSH
15394: LD_INT 1
15396: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15397: LD_STRING Destroy
15399: PPUSH
15400: LD_INT 2
15402: PPUSH
15403: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15407: LD_EXP 13
15411: PPUSH
15412: LD_STRING 11_artifact_captured
15414: PPUSH
15415: CALL_OW 39
// if artifact_get then
15419: LD_EXP 13
15423: IFFALSE 15445
// begin m2 := true ;
15425: LD_ADDR_VAR 0 3
15429: PUSH
15430: LD_INT 1
15432: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15433: LD_STRING Artefact
15435: PPUSH
15436: LD_INT 1
15438: PPUSH
15439: CALL_OW 101
// end else
15443: GO 15456
// AddMedal ( Artefact , - 1 ) ;
15445: LD_STRING Artefact
15447: PPUSH
15448: LD_INT 1
15450: NEG
15451: PPUSH
15452: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15456: LD_VAR 0 2
15460: PUSH
15461: LD_VAR 0 3
15465: AND
15466: PUSH
15467: LD_VAR 0 4
15471: AND
15472: PUSH
15473: LD_OWVAR 67
15477: PUSH
15478: LD_INT 3
15480: EQUAL
15481: AND
15482: IFFALSE 15494
// SetAchievementEX ( ACH_AMER , 11 ) ;
15484: LD_STRING ACH_AMER
15486: PPUSH
15487: LD_INT 11
15489: PPUSH
15490: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15494: LD_VAR 0 2
15498: PUSH
15499: LD_VAR 0 3
15503: AND
15504: PUSH
15505: LD_VAR 0 4
15509: AND
15510: PUSH
15511: LD_EXP 17
15515: PUSH
15516: LD_INT 0
15518: EQUAL
15519: AND
15520: IFFALSE 15536
// begin wait ( 3 ) ;
15522: LD_INT 3
15524: PPUSH
15525: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15529: LD_STRING ACH_GENERAL
15531: PPUSH
15532: CALL_OW 543
// end ; if tick <= 100 100$00 then
15536: LD_OWVAR 1
15540: PUSH
15541: LD_INT 210000
15543: LESSEQUAL
15544: IFFALSE 15560
// begin wait ( 3 ) ;
15546: LD_INT 3
15548: PPUSH
15549: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15553: LD_STRING ACH_ASPEED_11
15555: PPUSH
15556: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15560: LD_STRING MAIN
15562: PPUSH
15563: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15567: LD_ADDR_EXP 19
15571: PUSH
15572: LD_EXP 19
15576: PPUSH
15577: LD_INT 51
15579: PUSH
15580: EMPTY
15581: LIST
15582: PPUSH
15583: CALL_OW 72
15587: ST_TO_ADDR
// tmp := JMM ^ selected ;
15588: LD_ADDR_VAR 0 1
15592: PUSH
15593: LD_EXP 21
15597: PUSH
15598: LD_EXP 19
15602: ADD
15603: ST_TO_ADDR
// RewardPeople ( tmp ) ;
15604: LD_VAR 0 1
15608: PPUSH
15609: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
15613: LD_VAR 0 1
15617: PUSH
15618: LD_EXP 21
15622: PUSH
15623: LD_EXP 22
15627: PUSH
15628: LD_EXP 23
15632: PUSH
15633: LD_EXP 24
15637: PUSH
15638: LD_EXP 25
15642: PUSH
15643: LD_EXP 26
15647: PUSH
15648: LD_EXP 27
15652: PUSH
15653: LD_EXP 28
15657: PUSH
15658: LD_EXP 29
15662: PUSH
15663: LD_EXP 31
15667: PUSH
15668: LD_EXP 32
15672: PUSH
15673: LD_EXP 33
15677: PUSH
15678: LD_EXP 34
15682: PUSH
15683: EMPTY
15684: LIST
15685: LIST
15686: LIST
15687: LIST
15688: LIST
15689: LIST
15690: LIST
15691: LIST
15692: LIST
15693: LIST
15694: LIST
15695: LIST
15696: LIST
15697: DIFF
15698: PPUSH
15699: LD_STRING 11c_others
15701: PPUSH
15702: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15706: LD_EXP 21
15710: PPUSH
15711: LD_EXP 3
15715: PUSH
15716: LD_STRING JMM
15718: STR
15719: PPUSH
15720: CALL_OW 38
// if Lisa then
15724: LD_EXP 22
15728: IFFALSE 15748
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15730: LD_EXP 22
15734: PPUSH
15735: LD_EXP 3
15739: PUSH
15740: LD_STRING Lisa
15742: STR
15743: PPUSH
15744: CALL_OW 38
// if Donaldson then
15748: LD_EXP 23
15752: IFFALSE 15772
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15754: LD_EXP 23
15758: PPUSH
15759: LD_EXP 3
15763: PUSH
15764: LD_STRING Donaldson
15766: STR
15767: PPUSH
15768: CALL_OW 38
// if Bobby then
15772: LD_EXP 24
15776: IFFALSE 15796
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15778: LD_EXP 24
15782: PPUSH
15783: LD_EXP 3
15787: PUSH
15788: LD_STRING Bobby
15790: STR
15791: PPUSH
15792: CALL_OW 38
// if Cyrus then
15796: LD_EXP 25
15800: IFFALSE 15820
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15802: LD_EXP 25
15806: PPUSH
15807: LD_EXP 3
15811: PUSH
15812: LD_STRING Cyrus
15814: STR
15815: PPUSH
15816: CALL_OW 38
// if Denis then
15820: LD_EXP 26
15824: IFFALSE 15844
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15826: LD_EXP 26
15830: PPUSH
15831: LD_EXP 3
15835: PUSH
15836: LD_STRING Denis
15838: STR
15839: PPUSH
15840: CALL_OW 38
// if Brown then
15844: LD_EXP 27
15848: IFFALSE 15868
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15850: LD_EXP 27
15854: PPUSH
15855: LD_EXP 3
15859: PUSH
15860: LD_STRING Brown
15862: STR
15863: PPUSH
15864: CALL_OW 38
// if Gladstone then
15868: LD_EXP 28
15872: IFFALSE 15892
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15874: LD_EXP 28
15878: PPUSH
15879: LD_EXP 3
15883: PUSH
15884: LD_STRING Gladstone
15886: STR
15887: PPUSH
15888: CALL_OW 38
// if Houten then
15892: LD_EXP 29
15896: IFFALSE 15916
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15898: LD_EXP 29
15902: PPUSH
15903: LD_EXP 3
15907: PUSH
15908: LD_STRING Houten
15910: STR
15911: PPUSH
15912: CALL_OW 38
// if Cornel then
15916: LD_EXP 31
15920: IFFALSE 15940
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
15922: LD_EXP 31
15926: PPUSH
15927: LD_EXP 3
15931: PUSH
15932: LD_STRING Cornell
15934: STR
15935: PPUSH
15936: CALL_OW 38
// if Gary then
15940: LD_EXP 32
15944: IFFALSE 15964
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
15946: LD_EXP 32
15950: PPUSH
15951: LD_EXP 3
15955: PUSH
15956: LD_STRING Gary
15958: STR
15959: PPUSH
15960: CALL_OW 38
// if Frank then
15964: LD_EXP 33
15968: IFFALSE 15988
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
15970: LD_EXP 33
15974: PPUSH
15975: LD_EXP 3
15979: PUSH
15980: LD_STRING Frank
15982: STR
15983: PPUSH
15984: CALL_OW 38
// if Kikuchi then
15988: LD_EXP 34
15992: IFFALSE 16012
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
15994: LD_EXP 34
15998: PPUSH
15999: LD_EXP 3
16003: PUSH
16004: LD_STRING Kikuchi
16006: STR
16007: PPUSH
16008: CALL_OW 38
// YouWin ;
16012: CALL_OW 103
// end ;
16016: PPOPN 4
16018: END
// export function CanSayRand ( side ) ; begin
16019: LD_INT 0
16021: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16022: LD_ADDR_VAR 0 2
16026: PUSH
16027: LD_INT 52
16029: PUSH
16030: EMPTY
16031: LIST
16032: PUSH
16033: LD_INT 22
16035: PUSH
16036: LD_VAR 0 1
16040: PUSH
16041: EMPTY
16042: LIST
16043: LIST
16044: PUSH
16045: LD_INT 2
16047: PUSH
16048: LD_INT 25
16050: PUSH
16051: LD_INT 1
16053: PUSH
16054: EMPTY
16055: LIST
16056: LIST
16057: PUSH
16058: LD_INT 25
16060: PUSH
16061: LD_INT 2
16063: PUSH
16064: EMPTY
16065: LIST
16066: LIST
16067: PUSH
16068: LD_INT 25
16070: PUSH
16071: LD_INT 3
16073: PUSH
16074: EMPTY
16075: LIST
16076: LIST
16077: PUSH
16078: LD_INT 25
16080: PUSH
16081: LD_INT 4
16083: PUSH
16084: EMPTY
16085: LIST
16086: LIST
16087: PUSH
16088: EMPTY
16089: LIST
16090: LIST
16091: LIST
16092: LIST
16093: LIST
16094: PUSH
16095: EMPTY
16096: LIST
16097: LIST
16098: LIST
16099: PPUSH
16100: CALL_OW 69
16104: PUSH
16105: LD_EXP 21
16109: PUSH
16110: LD_EXP 33
16114: PUSH
16115: LD_EXP 22
16119: PUSH
16120: LD_EXP 23
16124: PUSH
16125: LD_EXP 24
16129: PUSH
16130: LD_EXP 25
16134: PUSH
16135: LD_EXP 26
16139: PUSH
16140: LD_EXP 27
16144: PUSH
16145: LD_EXP 28
16149: PUSH
16150: LD_EXP 29
16154: PUSH
16155: LD_EXP 30
16159: PUSH
16160: LD_EXP 31
16164: PUSH
16165: LD_EXP 32
16169: PUSH
16170: LD_EXP 34
16174: PUSH
16175: EMPTY
16176: LIST
16177: LIST
16178: LIST
16179: LIST
16180: LIST
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: LIST
16186: LIST
16187: LIST
16188: LIST
16189: LIST
16190: DIFF
16191: ST_TO_ADDR
// end ;
16192: LD_VAR 0 2
16196: RET
// export function SayRand ( sex , dial ) ; begin
16197: LD_INT 0
16199: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16200: LD_ADDR_VAR 0 3
16204: PUSH
16205: LD_INT 52
16207: PUSH
16208: EMPTY
16209: LIST
16210: PUSH
16211: LD_INT 22
16213: PUSH
16214: LD_INT 1
16216: PUSH
16217: EMPTY
16218: LIST
16219: LIST
16220: PUSH
16221: LD_INT 26
16223: PUSH
16224: LD_VAR 0 1
16228: PUSH
16229: EMPTY
16230: LIST
16231: LIST
16232: PUSH
16233: LD_INT 2
16235: PUSH
16236: LD_INT 25
16238: PUSH
16239: LD_INT 1
16241: PUSH
16242: EMPTY
16243: LIST
16244: LIST
16245: PUSH
16246: LD_INT 25
16248: PUSH
16249: LD_INT 2
16251: PUSH
16252: EMPTY
16253: LIST
16254: LIST
16255: PUSH
16256: LD_INT 25
16258: PUSH
16259: LD_INT 3
16261: PUSH
16262: EMPTY
16263: LIST
16264: LIST
16265: PUSH
16266: LD_INT 25
16268: PUSH
16269: LD_INT 4
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: LIST
16280: LIST
16281: LIST
16282: PUSH
16283: EMPTY
16284: LIST
16285: LIST
16286: LIST
16287: LIST
16288: PPUSH
16289: CALL_OW 69
16293: PUSH
16294: LD_EXP 21
16298: PUSH
16299: LD_EXP 33
16303: PUSH
16304: LD_EXP 22
16308: PUSH
16309: LD_EXP 23
16313: PUSH
16314: LD_EXP 24
16318: PUSH
16319: LD_EXP 25
16323: PUSH
16324: LD_EXP 26
16328: PUSH
16329: LD_EXP 27
16333: PUSH
16334: LD_EXP 28
16338: PUSH
16339: LD_EXP 29
16343: PUSH
16344: LD_EXP 30
16348: PUSH
16349: LD_EXP 31
16353: PUSH
16354: LD_EXP 32
16358: PUSH
16359: LD_EXP 34
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: LIST
16368: LIST
16369: LIST
16370: LIST
16371: LIST
16372: LIST
16373: LIST
16374: LIST
16375: LIST
16376: LIST
16377: LIST
16378: LIST
16379: DIFF
16380: ST_TO_ADDR
// if not result then
16381: LD_VAR 0 3
16385: NOT
16386: IFFALSE 16390
// exit ;
16388: GO 16418
// result := result [ 1 ] ;
16390: LD_ADDR_VAR 0 3
16394: PUSH
16395: LD_VAR 0 3
16399: PUSH
16400: LD_INT 1
16402: ARRAY
16403: ST_TO_ADDR
// Say ( result , dial ) ;
16404: LD_VAR 0 3
16408: PPUSH
16409: LD_VAR 0 2
16413: PPUSH
16414: CALL_OW 88
// end ;
16418: LD_VAR 0 3
16422: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16423: LD_INT 0
16425: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16426: LD_ADDR_VAR 0 4
16430: PUSH
16431: LD_INT 22
16433: PUSH
16434: LD_INT 1
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: PUSH
16441: LD_INT 26
16443: PUSH
16444: LD_VAR 0 1
16448: PUSH
16449: EMPTY
16450: LIST
16451: LIST
16452: PUSH
16453: LD_INT 2
16455: PUSH
16456: LD_INT 25
16458: PUSH
16459: LD_INT 1
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: PUSH
16466: LD_INT 25
16468: PUSH
16469: LD_INT 2
16471: PUSH
16472: EMPTY
16473: LIST
16474: LIST
16475: PUSH
16476: LD_INT 25
16478: PUSH
16479: LD_INT 3
16481: PUSH
16482: EMPTY
16483: LIST
16484: LIST
16485: PUSH
16486: LD_INT 25
16488: PUSH
16489: LD_INT 4
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PUSH
16496: EMPTY
16497: LIST
16498: LIST
16499: LIST
16500: LIST
16501: LIST
16502: PUSH
16503: EMPTY
16504: LIST
16505: LIST
16506: LIST
16507: PPUSH
16508: CALL_OW 69
16512: PUSH
16513: LD_EXP 21
16517: PUSH
16518: LD_EXP 33
16522: PUSH
16523: LD_EXP 22
16527: PUSH
16528: LD_EXP 23
16532: PUSH
16533: LD_EXP 24
16537: PUSH
16538: LD_EXP 25
16542: PUSH
16543: LD_EXP 26
16547: PUSH
16548: LD_EXP 27
16552: PUSH
16553: LD_EXP 28
16557: PUSH
16558: LD_EXP 29
16562: PUSH
16563: LD_EXP 30
16567: PUSH
16568: LD_EXP 31
16572: PUSH
16573: LD_EXP 32
16577: PUSH
16578: LD_EXP 34
16582: PUSH
16583: EMPTY
16584: LIST
16585: LIST
16586: LIST
16587: LIST
16588: LIST
16589: LIST
16590: LIST
16591: LIST
16592: LIST
16593: LIST
16594: LIST
16595: LIST
16596: LIST
16597: LIST
16598: PUSH
16599: LD_VAR 0 3
16603: ADD
16604: DIFF
16605: ST_TO_ADDR
// if not result then
16606: LD_VAR 0 4
16610: NOT
16611: IFFALSE 16615
// exit ;
16613: GO 16643
// result := result [ 1 ] ;
16615: LD_ADDR_VAR 0 4
16619: PUSH
16620: LD_VAR 0 4
16624: PUSH
16625: LD_INT 1
16627: ARRAY
16628: ST_TO_ADDR
// Say ( result , dial ) ;
16629: LD_VAR 0 4
16633: PPUSH
16634: LD_VAR 0 2
16638: PPUSH
16639: CALL_OW 88
// end ; end_of_file
16643: LD_VAR 0 4
16647: RET
// export function CustomEvent ( event ) ; begin
16648: LD_INT 0
16650: PPUSH
// end ;
16651: LD_VAR 0 2
16655: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
16656: LD_VAR 0 1
16660: PPUSH
16661: CALL_OW 255
16665: PUSH
16666: LD_INT 1
16668: EQUAL
16669: IFFALSE 16679
// artifact_get := true ;
16671: LD_ADDR_EXP 13
16675: PUSH
16676: LD_INT 1
16678: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
16679: LD_VAR 0 1
16683: PPUSH
16684: CALL_OW 255
16688: PUSH
16689: LD_INT 2
16691: EQUAL
16692: IFFALSE 16710
// begin artifact_get := false ;
16694: LD_ADDR_EXP 13
16698: PUSH
16699: LD_INT 0
16701: ST_TO_ADDR
// artifact_stolen := true ;
16702: LD_ADDR_EXP 12
16706: PUSH
16707: LD_INT 1
16709: ST_TO_ADDR
// end ; artifact_oncargo := true ;
16710: LD_ADDR_EXP 14
16714: PUSH
16715: LD_INT 1
16717: ST_TO_ADDR
// end ;
16718: PPOPN 2
16720: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
16721: LD_ADDR_EXP 14
16725: PUSH
16726: LD_INT 0
16728: ST_TO_ADDR
// end ;
16729: PPOPN 2
16731: END
// on UnitDestroyed ( un ) do begin if un = JMM then
16732: LD_VAR 0 1
16736: PUSH
16737: LD_EXP 21
16741: EQUAL
16742: IFFALSE 16753
// begin YouLost ( JMM ) ;
16744: LD_STRING JMM
16746: PPUSH
16747: CALL_OW 104
// exit ;
16751: GO 16885
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
16753: LD_VAR 0 1
16757: PUSH
16758: LD_INT 22
16760: PUSH
16761: LD_INT 1
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: PUSH
16768: LD_INT 21
16770: PUSH
16771: LD_INT 1
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: PUSH
16778: LD_INT 2
16780: PUSH
16781: LD_INT 25
16783: PUSH
16784: LD_INT 1
16786: PUSH
16787: EMPTY
16788: LIST
16789: LIST
16790: PUSH
16791: LD_INT 25
16793: PUSH
16794: LD_INT 2
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PUSH
16801: LD_INT 25
16803: PUSH
16804: LD_INT 3
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: PUSH
16811: LD_INT 25
16813: PUSH
16814: LD_INT 4
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: PUSH
16821: LD_INT 25
16823: PUSH
16824: LD_INT 5
16826: PUSH
16827: EMPTY
16828: LIST
16829: LIST
16830: PUSH
16831: LD_INT 25
16833: PUSH
16834: LD_INT 8
16836: PUSH
16837: EMPTY
16838: LIST
16839: LIST
16840: PUSH
16841: EMPTY
16842: LIST
16843: LIST
16844: LIST
16845: LIST
16846: LIST
16847: LIST
16848: LIST
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: LIST
16854: PPUSH
16855: CALL_OW 69
16859: IN
16860: IFFALSE 16876
// loses_counter := loses_counter + 1 ;
16862: LD_ADDR_EXP 17
16866: PUSH
16867: LD_EXP 17
16871: PUSH
16872: LD_INT 1
16874: PLUS
16875: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16876: LD_VAR 0 1
16880: PPUSH
16881: CALL 44469 0 1
// end ;
16885: PPOPN 1
16887: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16888: LD_VAR 0 1
16892: PPUSH
16893: LD_VAR 0 2
16897: PPUSH
16898: CALL 46803 0 2
// end ;
16902: PPOPN 2
16904: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16905: LD_VAR 0 1
16909: PPUSH
16910: CALL 46112 0 1
// end ;
16914: PPOPN 1
16916: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16917: LD_VAR 0 1
16921: PPUSH
16922: LD_VAR 0 2
16926: PPUSH
16927: LD_VAR 0 3
16931: PPUSH
16932: LD_VAR 0 4
16936: PPUSH
16937: LD_VAR 0 5
16941: PPUSH
16942: CALL 43785 0 5
// end ;
16946: PPOPN 5
16948: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
16949: LD_VAR 0 1
16953: PPUSH
16954: CALL_OW 248
16958: PUSH
16959: LD_INT 1
16961: EQUAL
16962: IFFALSE 16972
// am_veh_consturcted := true ;
16964: LD_ADDR_EXP 20
16968: PUSH
16969: LD_INT 1
16971: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
16972: LD_VAR 0 1
16976: PPUSH
16977: LD_VAR 0 2
16981: PPUSH
16982: CALL 43381 0 2
// end ;
16986: PPOPN 2
16988: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
16989: LD_VAR 0 1
16993: PPUSH
16994: CALL_OW 247
16998: PUSH
16999: LD_INT 2
17001: EQUAL
17002: IFFALSE 17006
// exit ;
17004: GO 17023
// if not kamikazed then
17006: LD_EXP 11
17010: NOT
17011: IFFALSE 17023
// kamikazed := unit ;
17013: LD_ADDR_EXP 11
17017: PUSH
17018: LD_VAR 0 1
17022: ST_TO_ADDR
// end ;
17023: PPOPN 1
17025: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17026: LD_INT 0
17028: PPUSH
17029: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17030: LD_VAR 0 1
17034: PPUSH
17035: LD_VAR 0 2
17039: PPUSH
17040: LD_VAR 0 3
17044: PPUSH
17045: LD_VAR 0 4
17049: PPUSH
17050: CALL 43219 0 4
// end ;
17054: PPOPN 6
17056: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17057: LD_VAR 0 1
17061: PPUSH
17062: LD_VAR 0 2
17066: PPUSH
17067: LD_VAR 0 3
17071: PPUSH
17072: CALL 42994 0 3
// end ;
17076: PPOPN 3
17078: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17079: LD_VAR 0 1
17083: PPUSH
17084: LD_VAR 0 2
17088: PPUSH
17089: CALL 44165 0 2
// end ;
17093: PPOPN 2
17095: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17096: LD_VAR 0 1
17100: PPUSH
17101: LD_VAR 0 2
17105: PPUSH
17106: CALL 42688 0 2
// end ;
17110: PPOPN 2
17112: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17113: LD_VAR 0 1
17117: PPUSH
17118: LD_VAR 0 2
17122: PPUSH
17123: CALL 42879 0 2
// end ;
17127: PPOPN 2
17129: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17130: LD_VAR 0 1
17134: PPUSH
17135: CALL 45871 0 1
// end ;
17139: PPOPN 1
17141: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17142: LD_VAR 0 1
17146: PPUSH
17147: LD_VAR 0 2
17151: PPUSH
17152: CALL 47064 0 2
// end ;
17156: PPOPN 2
17158: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17159: LD_VAR 0 1
17163: PPUSH
17164: LD_VAR 0 2
17168: PPUSH
17169: LD_VAR 0 3
17173: PPUSH
17174: LD_VAR 0 4
17178: PPUSH
17179: CALL 47280 0 4
// end ;
17183: PPOPN 4
17185: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17186: LD_VAR 0 1
17190: PPUSH
17191: CALL 94828 0 1
// end ; end_of_file
17195: PPOPN 1
17197: END
// every 0 0$1 trigger game do
17198: LD_EXP 2
17202: IFFALSE 17232
17204: GO 17206
17206: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17207: LD_INT 7
17209: PUSH
17210: LD_INT 6
17212: PUSH
17213: LD_INT 4
17215: PUSH
17216: LD_INT 6
17218: PUSH
17219: EMPTY
17220: LIST
17221: LIST
17222: LIST
17223: LIST
17224: PPUSH
17225: LD_INT 1750
17227: PPUSH
17228: CALL 17233 0 2
17232: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17233: LD_INT 0
17235: PPUSH
17236: PPUSH
17237: PPUSH
// if not areas then
17238: LD_VAR 0 1
17242: NOT
17243: IFFALSE 17247
// exit ;
17245: GO 17377
// repeat wait ( time ) ;
17247: LD_VAR 0 2
17251: PPUSH
17252: CALL_OW 67
// p := rand ( 1 , 90 ) ;
17256: LD_ADDR_VAR 0 5
17260: PUSH
17261: LD_INT 1
17263: PPUSH
17264: LD_INT 90
17266: PPUSH
17267: CALL_OW 12
17271: ST_TO_ADDR
// for i in areas do
17272: LD_ADDR_VAR 0 4
17276: PUSH
17277: LD_VAR 0 1
17281: PUSH
17282: FOR_IN
17283: IFFALSE 17336
// begin if Prob ( p ) then
17285: LD_VAR 0 5
17289: PPUSH
17290: CALL_OW 13
17294: IFFALSE 17334
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
17296: LD_INT 1
17298: PPUSH
17299: LD_INT 5
17301: PPUSH
17302: CALL_OW 12
17306: PPUSH
17307: LD_VAR 0 4
17311: PPUSH
17312: LD_INT 1
17314: PPUSH
17315: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
17319: LD_INT 385
17321: PPUSH
17322: LD_INT 595
17324: PPUSH
17325: CALL_OW 12
17329: PPUSH
17330: CALL_OW 67
// end ; end ;
17334: GO 17282
17336: POP
17337: POP
// time := time + 0 0$3 ;
17338: LD_ADDR_VAR 0 2
17342: PUSH
17343: LD_VAR 0 2
17347: PUSH
17348: LD_INT 105
17350: PLUS
17351: ST_TO_ADDR
// if time > 7 7$00 then
17352: LD_VAR 0 2
17356: PUSH
17357: LD_INT 14700
17359: GREATER
17360: IFFALSE 17370
// time := 0 0$40 ;
17362: LD_ADDR_VAR 0 2
17366: PUSH
17367: LD_INT 1400
17369: ST_TO_ADDR
// until not game ;
17370: LD_EXP 2
17374: NOT
17375: IFFALSE 17247
// end ; end_of_file
17377: LD_VAR 0 3
17381: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
17382: LD_INT 0
17384: PPUSH
17385: PPUSH
// skirmish := false ;
17386: LD_ADDR_EXP 48
17390: PUSH
17391: LD_INT 0
17393: ST_TO_ADDR
// debug_mc := false ;
17394: LD_ADDR_EXP 49
17398: PUSH
17399: LD_INT 0
17401: ST_TO_ADDR
// mc_bases := [ ] ;
17402: LD_ADDR_EXP 50
17406: PUSH
17407: EMPTY
17408: ST_TO_ADDR
// mc_sides := [ ] ;
17409: LD_ADDR_EXP 76
17413: PUSH
17414: EMPTY
17415: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17416: LD_ADDR_EXP 51
17420: PUSH
17421: EMPTY
17422: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17423: LD_ADDR_EXP 52
17427: PUSH
17428: EMPTY
17429: ST_TO_ADDR
// mc_need_heal := [ ] ;
17430: LD_ADDR_EXP 53
17434: PUSH
17435: EMPTY
17436: ST_TO_ADDR
// mc_healers := [ ] ;
17437: LD_ADDR_EXP 54
17441: PUSH
17442: EMPTY
17443: ST_TO_ADDR
// mc_build_list := [ ] ;
17444: LD_ADDR_EXP 55
17448: PUSH
17449: EMPTY
17450: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17451: LD_ADDR_EXP 82
17455: PUSH
17456: EMPTY
17457: ST_TO_ADDR
// mc_builders := [ ] ;
17458: LD_ADDR_EXP 56
17462: PUSH
17463: EMPTY
17464: ST_TO_ADDR
// mc_construct_list := [ ] ;
17465: LD_ADDR_EXP 57
17469: PUSH
17470: EMPTY
17471: ST_TO_ADDR
// mc_turret_list := [ ] ;
17472: LD_ADDR_EXP 58
17476: PUSH
17477: EMPTY
17478: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17479: LD_ADDR_EXP 59
17483: PUSH
17484: EMPTY
17485: ST_TO_ADDR
// mc_miners := [ ] ;
17486: LD_ADDR_EXP 64
17490: PUSH
17491: EMPTY
17492: ST_TO_ADDR
// mc_mines := [ ] ;
17493: LD_ADDR_EXP 63
17497: PUSH
17498: EMPTY
17499: ST_TO_ADDR
// mc_minefields := [ ] ;
17500: LD_ADDR_EXP 65
17504: PUSH
17505: EMPTY
17506: ST_TO_ADDR
// mc_crates := [ ] ;
17507: LD_ADDR_EXP 66
17511: PUSH
17512: EMPTY
17513: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17514: LD_ADDR_EXP 67
17518: PUSH
17519: EMPTY
17520: ST_TO_ADDR
// mc_crates_area := [ ] ;
17521: LD_ADDR_EXP 68
17525: PUSH
17526: EMPTY
17527: ST_TO_ADDR
// mc_vehicles := [ ] ;
17528: LD_ADDR_EXP 69
17532: PUSH
17533: EMPTY
17534: ST_TO_ADDR
// mc_attack := [ ] ;
17535: LD_ADDR_EXP 70
17539: PUSH
17540: EMPTY
17541: ST_TO_ADDR
// mc_produce := [ ] ;
17542: LD_ADDR_EXP 71
17546: PUSH
17547: EMPTY
17548: ST_TO_ADDR
// mc_defender := [ ] ;
17549: LD_ADDR_EXP 72
17553: PUSH
17554: EMPTY
17555: ST_TO_ADDR
// mc_parking := [ ] ;
17556: LD_ADDR_EXP 74
17560: PUSH
17561: EMPTY
17562: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
17563: LD_ADDR_EXP 60
17567: PUSH
17568: EMPTY
17569: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
17570: LD_ADDR_EXP 62
17574: PUSH
17575: EMPTY
17576: ST_TO_ADDR
// mc_scan := [ ] ;
17577: LD_ADDR_EXP 73
17581: PUSH
17582: EMPTY
17583: ST_TO_ADDR
// mc_scan_area := [ ] ;
17584: LD_ADDR_EXP 75
17588: PUSH
17589: EMPTY
17590: ST_TO_ADDR
// mc_tech := [ ] ;
17591: LD_ADDR_EXP 77
17595: PUSH
17596: EMPTY
17597: ST_TO_ADDR
// mc_class := [ ] ;
17598: LD_ADDR_EXP 91
17602: PUSH
17603: EMPTY
17604: ST_TO_ADDR
// mc_class_case_use := [ ] ;
17605: LD_ADDR_EXP 92
17609: PUSH
17610: EMPTY
17611: ST_TO_ADDR
// end ;
17612: LD_VAR 0 1
17616: RET
// export function MC_Kill ( base ) ; begin
17617: LD_INT 0
17619: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
17620: LD_ADDR_EXP 50
17624: PUSH
17625: LD_EXP 50
17629: PPUSH
17630: LD_VAR 0 1
17634: PPUSH
17635: EMPTY
17636: PPUSH
17637: CALL_OW 1
17641: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
17642: LD_ADDR_EXP 51
17646: PUSH
17647: LD_EXP 51
17651: PPUSH
17652: LD_VAR 0 1
17656: PPUSH
17657: EMPTY
17658: PPUSH
17659: CALL_OW 1
17663: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
17664: LD_ADDR_EXP 52
17668: PUSH
17669: LD_EXP 52
17673: PPUSH
17674: LD_VAR 0 1
17678: PPUSH
17679: EMPTY
17680: PPUSH
17681: CALL_OW 1
17685: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
17686: LD_ADDR_EXP 53
17690: PUSH
17691: LD_EXP 53
17695: PPUSH
17696: LD_VAR 0 1
17700: PPUSH
17701: EMPTY
17702: PPUSH
17703: CALL_OW 1
17707: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
17708: LD_ADDR_EXP 54
17712: PUSH
17713: LD_EXP 54
17717: PPUSH
17718: LD_VAR 0 1
17722: PPUSH
17723: EMPTY
17724: PPUSH
17725: CALL_OW 1
17729: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
17730: LD_ADDR_EXP 55
17734: PUSH
17735: LD_EXP 55
17739: PPUSH
17740: LD_VAR 0 1
17744: PPUSH
17745: EMPTY
17746: PPUSH
17747: CALL_OW 1
17751: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
17752: LD_ADDR_EXP 56
17756: PUSH
17757: LD_EXP 56
17761: PPUSH
17762: LD_VAR 0 1
17766: PPUSH
17767: EMPTY
17768: PPUSH
17769: CALL_OW 1
17773: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
17774: LD_ADDR_EXP 57
17778: PUSH
17779: LD_EXP 57
17783: PPUSH
17784: LD_VAR 0 1
17788: PPUSH
17789: EMPTY
17790: PPUSH
17791: CALL_OW 1
17795: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17796: LD_ADDR_EXP 58
17800: PUSH
17801: LD_EXP 58
17805: PPUSH
17806: LD_VAR 0 1
17810: PPUSH
17811: EMPTY
17812: PPUSH
17813: CALL_OW 1
17817: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17818: LD_ADDR_EXP 59
17822: PUSH
17823: LD_EXP 59
17827: PPUSH
17828: LD_VAR 0 1
17832: PPUSH
17833: EMPTY
17834: PPUSH
17835: CALL_OW 1
17839: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17840: LD_ADDR_EXP 60
17844: PUSH
17845: LD_EXP 60
17849: PPUSH
17850: LD_VAR 0 1
17854: PPUSH
17855: EMPTY
17856: PPUSH
17857: CALL_OW 1
17861: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17862: LD_ADDR_EXP 61
17866: PUSH
17867: LD_EXP 61
17871: PPUSH
17872: LD_VAR 0 1
17876: PPUSH
17877: LD_INT 0
17879: PPUSH
17880: CALL_OW 1
17884: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17885: LD_ADDR_EXP 62
17889: PUSH
17890: LD_EXP 62
17894: PPUSH
17895: LD_VAR 0 1
17899: PPUSH
17900: EMPTY
17901: PPUSH
17902: CALL_OW 1
17906: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17907: LD_ADDR_EXP 63
17911: PUSH
17912: LD_EXP 63
17916: PPUSH
17917: LD_VAR 0 1
17921: PPUSH
17922: EMPTY
17923: PPUSH
17924: CALL_OW 1
17928: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17929: LD_ADDR_EXP 64
17933: PUSH
17934: LD_EXP 64
17938: PPUSH
17939: LD_VAR 0 1
17943: PPUSH
17944: EMPTY
17945: PPUSH
17946: CALL_OW 1
17950: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
17951: LD_ADDR_EXP 65
17955: PUSH
17956: LD_EXP 65
17960: PPUSH
17961: LD_VAR 0 1
17965: PPUSH
17966: EMPTY
17967: PPUSH
17968: CALL_OW 1
17972: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
17973: LD_ADDR_EXP 66
17977: PUSH
17978: LD_EXP 66
17982: PPUSH
17983: LD_VAR 0 1
17987: PPUSH
17988: EMPTY
17989: PPUSH
17990: CALL_OW 1
17994: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
17995: LD_ADDR_EXP 67
17999: PUSH
18000: LD_EXP 67
18004: PPUSH
18005: LD_VAR 0 1
18009: PPUSH
18010: EMPTY
18011: PPUSH
18012: CALL_OW 1
18016: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18017: LD_ADDR_EXP 68
18021: PUSH
18022: LD_EXP 68
18026: PPUSH
18027: LD_VAR 0 1
18031: PPUSH
18032: EMPTY
18033: PPUSH
18034: CALL_OW 1
18038: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18039: LD_ADDR_EXP 69
18043: PUSH
18044: LD_EXP 69
18048: PPUSH
18049: LD_VAR 0 1
18053: PPUSH
18054: EMPTY
18055: PPUSH
18056: CALL_OW 1
18060: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18061: LD_ADDR_EXP 70
18065: PUSH
18066: LD_EXP 70
18070: PPUSH
18071: LD_VAR 0 1
18075: PPUSH
18076: EMPTY
18077: PPUSH
18078: CALL_OW 1
18082: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18083: LD_ADDR_EXP 71
18087: PUSH
18088: LD_EXP 71
18092: PPUSH
18093: LD_VAR 0 1
18097: PPUSH
18098: EMPTY
18099: PPUSH
18100: CALL_OW 1
18104: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18105: LD_ADDR_EXP 72
18109: PUSH
18110: LD_EXP 72
18114: PPUSH
18115: LD_VAR 0 1
18119: PPUSH
18120: EMPTY
18121: PPUSH
18122: CALL_OW 1
18126: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18127: LD_ADDR_EXP 73
18131: PUSH
18132: LD_EXP 73
18136: PPUSH
18137: LD_VAR 0 1
18141: PPUSH
18142: EMPTY
18143: PPUSH
18144: CALL_OW 1
18148: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18149: LD_ADDR_EXP 74
18153: PUSH
18154: LD_EXP 74
18158: PPUSH
18159: LD_VAR 0 1
18163: PPUSH
18164: EMPTY
18165: PPUSH
18166: CALL_OW 1
18170: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18171: LD_ADDR_EXP 75
18175: PUSH
18176: LD_EXP 75
18180: PPUSH
18181: LD_VAR 0 1
18185: PPUSH
18186: EMPTY
18187: PPUSH
18188: CALL_OW 1
18192: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18193: LD_ADDR_EXP 77
18197: PUSH
18198: LD_EXP 77
18202: PPUSH
18203: LD_VAR 0 1
18207: PPUSH
18208: EMPTY
18209: PPUSH
18210: CALL_OW 1
18214: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18215: LD_ADDR_EXP 79
18219: PUSH
18220: LD_EXP 79
18224: PPUSH
18225: LD_VAR 0 1
18229: PPUSH
18230: EMPTY
18231: PPUSH
18232: CALL_OW 1
18236: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18237: LD_ADDR_EXP 80
18241: PUSH
18242: LD_EXP 80
18246: PPUSH
18247: LD_VAR 0 1
18251: PPUSH
18252: EMPTY
18253: PPUSH
18254: CALL_OW 1
18258: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18259: LD_ADDR_EXP 81
18263: PUSH
18264: LD_EXP 81
18268: PPUSH
18269: LD_VAR 0 1
18273: PPUSH
18274: EMPTY
18275: PPUSH
18276: CALL_OW 1
18280: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18281: LD_ADDR_EXP 82
18285: PUSH
18286: LD_EXP 82
18290: PPUSH
18291: LD_VAR 0 1
18295: PPUSH
18296: EMPTY
18297: PPUSH
18298: CALL_OW 1
18302: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18303: LD_ADDR_EXP 83
18307: PUSH
18308: LD_EXP 83
18312: PPUSH
18313: LD_VAR 0 1
18317: PPUSH
18318: EMPTY
18319: PPUSH
18320: CALL_OW 1
18324: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18325: LD_ADDR_EXP 84
18329: PUSH
18330: LD_EXP 84
18334: PPUSH
18335: LD_VAR 0 1
18339: PPUSH
18340: EMPTY
18341: PPUSH
18342: CALL_OW 1
18346: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18347: LD_ADDR_EXP 85
18351: PUSH
18352: LD_EXP 85
18356: PPUSH
18357: LD_VAR 0 1
18361: PPUSH
18362: EMPTY
18363: PPUSH
18364: CALL_OW 1
18368: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18369: LD_ADDR_EXP 86
18373: PUSH
18374: LD_EXP 86
18378: PPUSH
18379: LD_VAR 0 1
18383: PPUSH
18384: EMPTY
18385: PPUSH
18386: CALL_OW 1
18390: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18391: LD_ADDR_EXP 87
18395: PUSH
18396: LD_EXP 87
18400: PPUSH
18401: LD_VAR 0 1
18405: PPUSH
18406: EMPTY
18407: PPUSH
18408: CALL_OW 1
18412: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18413: LD_ADDR_EXP 88
18417: PUSH
18418: LD_EXP 88
18422: PPUSH
18423: LD_VAR 0 1
18427: PPUSH
18428: EMPTY
18429: PPUSH
18430: CALL_OW 1
18434: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18435: LD_ADDR_EXP 89
18439: PUSH
18440: LD_EXP 89
18444: PPUSH
18445: LD_VAR 0 1
18449: PPUSH
18450: EMPTY
18451: PPUSH
18452: CALL_OW 1
18456: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18457: LD_ADDR_EXP 90
18461: PUSH
18462: LD_EXP 90
18466: PPUSH
18467: LD_VAR 0 1
18471: PPUSH
18472: EMPTY
18473: PPUSH
18474: CALL_OW 1
18478: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18479: LD_ADDR_EXP 91
18483: PUSH
18484: LD_EXP 91
18488: PPUSH
18489: LD_VAR 0 1
18493: PPUSH
18494: EMPTY
18495: PPUSH
18496: CALL_OW 1
18500: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18501: LD_ADDR_EXP 92
18505: PUSH
18506: LD_EXP 92
18510: PPUSH
18511: LD_VAR 0 1
18515: PPUSH
18516: LD_INT 0
18518: PPUSH
18519: CALL_OW 1
18523: ST_TO_ADDR
// end ;
18524: LD_VAR 0 2
18528: RET
// export function MC_Add ( side , units ) ; var base ; begin
18529: LD_INT 0
18531: PPUSH
18532: PPUSH
// base := mc_bases + 1 ;
18533: LD_ADDR_VAR 0 4
18537: PUSH
18538: LD_EXP 50
18542: PUSH
18543: LD_INT 1
18545: PLUS
18546: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
18547: LD_ADDR_EXP 76
18551: PUSH
18552: LD_EXP 76
18556: PPUSH
18557: LD_VAR 0 4
18561: PPUSH
18562: LD_VAR 0 1
18566: PPUSH
18567: CALL_OW 1
18571: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
18572: LD_ADDR_EXP 50
18576: PUSH
18577: LD_EXP 50
18581: PPUSH
18582: LD_VAR 0 4
18586: PPUSH
18587: LD_VAR 0 2
18591: PPUSH
18592: CALL_OW 1
18596: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18597: LD_ADDR_EXP 51
18601: PUSH
18602: LD_EXP 51
18606: PPUSH
18607: LD_VAR 0 4
18611: PPUSH
18612: EMPTY
18613: PPUSH
18614: CALL_OW 1
18618: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18619: LD_ADDR_EXP 52
18623: PUSH
18624: LD_EXP 52
18628: PPUSH
18629: LD_VAR 0 4
18633: PPUSH
18634: EMPTY
18635: PPUSH
18636: CALL_OW 1
18640: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18641: LD_ADDR_EXP 53
18645: PUSH
18646: LD_EXP 53
18650: PPUSH
18651: LD_VAR 0 4
18655: PPUSH
18656: EMPTY
18657: PPUSH
18658: CALL_OW 1
18662: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18663: LD_ADDR_EXP 54
18667: PUSH
18668: LD_EXP 54
18672: PPUSH
18673: LD_VAR 0 4
18677: PPUSH
18678: EMPTY
18679: PPUSH
18680: CALL_OW 1
18684: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18685: LD_ADDR_EXP 55
18689: PUSH
18690: LD_EXP 55
18694: PPUSH
18695: LD_VAR 0 4
18699: PPUSH
18700: EMPTY
18701: PPUSH
18702: CALL_OW 1
18706: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18707: LD_ADDR_EXP 56
18711: PUSH
18712: LD_EXP 56
18716: PPUSH
18717: LD_VAR 0 4
18721: PPUSH
18722: EMPTY
18723: PPUSH
18724: CALL_OW 1
18728: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18729: LD_ADDR_EXP 57
18733: PUSH
18734: LD_EXP 57
18738: PPUSH
18739: LD_VAR 0 4
18743: PPUSH
18744: EMPTY
18745: PPUSH
18746: CALL_OW 1
18750: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18751: LD_ADDR_EXP 58
18755: PUSH
18756: LD_EXP 58
18760: PPUSH
18761: LD_VAR 0 4
18765: PPUSH
18766: EMPTY
18767: PPUSH
18768: CALL_OW 1
18772: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18773: LD_ADDR_EXP 59
18777: PUSH
18778: LD_EXP 59
18782: PPUSH
18783: LD_VAR 0 4
18787: PPUSH
18788: EMPTY
18789: PPUSH
18790: CALL_OW 1
18794: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18795: LD_ADDR_EXP 60
18799: PUSH
18800: LD_EXP 60
18804: PPUSH
18805: LD_VAR 0 4
18809: PPUSH
18810: EMPTY
18811: PPUSH
18812: CALL_OW 1
18816: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18817: LD_ADDR_EXP 61
18821: PUSH
18822: LD_EXP 61
18826: PPUSH
18827: LD_VAR 0 4
18831: PPUSH
18832: LD_INT 0
18834: PPUSH
18835: CALL_OW 1
18839: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18840: LD_ADDR_EXP 62
18844: PUSH
18845: LD_EXP 62
18849: PPUSH
18850: LD_VAR 0 4
18854: PPUSH
18855: EMPTY
18856: PPUSH
18857: CALL_OW 1
18861: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18862: LD_ADDR_EXP 63
18866: PUSH
18867: LD_EXP 63
18871: PPUSH
18872: LD_VAR 0 4
18876: PPUSH
18877: EMPTY
18878: PPUSH
18879: CALL_OW 1
18883: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18884: LD_ADDR_EXP 64
18888: PUSH
18889: LD_EXP 64
18893: PPUSH
18894: LD_VAR 0 4
18898: PPUSH
18899: EMPTY
18900: PPUSH
18901: CALL_OW 1
18905: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18906: LD_ADDR_EXP 65
18910: PUSH
18911: LD_EXP 65
18915: PPUSH
18916: LD_VAR 0 4
18920: PPUSH
18921: EMPTY
18922: PPUSH
18923: CALL_OW 1
18927: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18928: LD_ADDR_EXP 66
18932: PUSH
18933: LD_EXP 66
18937: PPUSH
18938: LD_VAR 0 4
18942: PPUSH
18943: EMPTY
18944: PPUSH
18945: CALL_OW 1
18949: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18950: LD_ADDR_EXP 67
18954: PUSH
18955: LD_EXP 67
18959: PPUSH
18960: LD_VAR 0 4
18964: PPUSH
18965: EMPTY
18966: PPUSH
18967: CALL_OW 1
18971: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18972: LD_ADDR_EXP 68
18976: PUSH
18977: LD_EXP 68
18981: PPUSH
18982: LD_VAR 0 4
18986: PPUSH
18987: EMPTY
18988: PPUSH
18989: CALL_OW 1
18993: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18994: LD_ADDR_EXP 69
18998: PUSH
18999: LD_EXP 69
19003: PPUSH
19004: LD_VAR 0 4
19008: PPUSH
19009: EMPTY
19010: PPUSH
19011: CALL_OW 1
19015: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19016: LD_ADDR_EXP 70
19020: PUSH
19021: LD_EXP 70
19025: PPUSH
19026: LD_VAR 0 4
19030: PPUSH
19031: EMPTY
19032: PPUSH
19033: CALL_OW 1
19037: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19038: LD_ADDR_EXP 71
19042: PUSH
19043: LD_EXP 71
19047: PPUSH
19048: LD_VAR 0 4
19052: PPUSH
19053: EMPTY
19054: PPUSH
19055: CALL_OW 1
19059: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19060: LD_ADDR_EXP 72
19064: PUSH
19065: LD_EXP 72
19069: PPUSH
19070: LD_VAR 0 4
19074: PPUSH
19075: EMPTY
19076: PPUSH
19077: CALL_OW 1
19081: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19082: LD_ADDR_EXP 73
19086: PUSH
19087: LD_EXP 73
19091: PPUSH
19092: LD_VAR 0 4
19096: PPUSH
19097: EMPTY
19098: PPUSH
19099: CALL_OW 1
19103: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19104: LD_ADDR_EXP 74
19108: PUSH
19109: LD_EXP 74
19113: PPUSH
19114: LD_VAR 0 4
19118: PPUSH
19119: EMPTY
19120: PPUSH
19121: CALL_OW 1
19125: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19126: LD_ADDR_EXP 75
19130: PUSH
19131: LD_EXP 75
19135: PPUSH
19136: LD_VAR 0 4
19140: PPUSH
19141: EMPTY
19142: PPUSH
19143: CALL_OW 1
19147: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19148: LD_ADDR_EXP 77
19152: PUSH
19153: LD_EXP 77
19157: PPUSH
19158: LD_VAR 0 4
19162: PPUSH
19163: EMPTY
19164: PPUSH
19165: CALL_OW 1
19169: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19170: LD_ADDR_EXP 79
19174: PUSH
19175: LD_EXP 79
19179: PPUSH
19180: LD_VAR 0 4
19184: PPUSH
19185: EMPTY
19186: PPUSH
19187: CALL_OW 1
19191: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19192: LD_ADDR_EXP 80
19196: PUSH
19197: LD_EXP 80
19201: PPUSH
19202: LD_VAR 0 4
19206: PPUSH
19207: EMPTY
19208: PPUSH
19209: CALL_OW 1
19213: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19214: LD_ADDR_EXP 81
19218: PUSH
19219: LD_EXP 81
19223: PPUSH
19224: LD_VAR 0 4
19228: PPUSH
19229: EMPTY
19230: PPUSH
19231: CALL_OW 1
19235: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19236: LD_ADDR_EXP 82
19240: PUSH
19241: LD_EXP 82
19245: PPUSH
19246: LD_VAR 0 4
19250: PPUSH
19251: EMPTY
19252: PPUSH
19253: CALL_OW 1
19257: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19258: LD_ADDR_EXP 83
19262: PUSH
19263: LD_EXP 83
19267: PPUSH
19268: LD_VAR 0 4
19272: PPUSH
19273: EMPTY
19274: PPUSH
19275: CALL_OW 1
19279: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19280: LD_ADDR_EXP 84
19284: PUSH
19285: LD_EXP 84
19289: PPUSH
19290: LD_VAR 0 4
19294: PPUSH
19295: EMPTY
19296: PPUSH
19297: CALL_OW 1
19301: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19302: LD_ADDR_EXP 85
19306: PUSH
19307: LD_EXP 85
19311: PPUSH
19312: LD_VAR 0 4
19316: PPUSH
19317: EMPTY
19318: PPUSH
19319: CALL_OW 1
19323: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19324: LD_ADDR_EXP 86
19328: PUSH
19329: LD_EXP 86
19333: PPUSH
19334: LD_VAR 0 4
19338: PPUSH
19339: EMPTY
19340: PPUSH
19341: CALL_OW 1
19345: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19346: LD_ADDR_EXP 87
19350: PUSH
19351: LD_EXP 87
19355: PPUSH
19356: LD_VAR 0 4
19360: PPUSH
19361: EMPTY
19362: PPUSH
19363: CALL_OW 1
19367: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19368: LD_ADDR_EXP 88
19372: PUSH
19373: LD_EXP 88
19377: PPUSH
19378: LD_VAR 0 4
19382: PPUSH
19383: EMPTY
19384: PPUSH
19385: CALL_OW 1
19389: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19390: LD_ADDR_EXP 89
19394: PUSH
19395: LD_EXP 89
19399: PPUSH
19400: LD_VAR 0 4
19404: PPUSH
19405: EMPTY
19406: PPUSH
19407: CALL_OW 1
19411: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19412: LD_ADDR_EXP 90
19416: PUSH
19417: LD_EXP 90
19421: PPUSH
19422: LD_VAR 0 4
19426: PPUSH
19427: EMPTY
19428: PPUSH
19429: CALL_OW 1
19433: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19434: LD_ADDR_EXP 91
19438: PUSH
19439: LD_EXP 91
19443: PPUSH
19444: LD_VAR 0 4
19448: PPUSH
19449: EMPTY
19450: PPUSH
19451: CALL_OW 1
19455: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19456: LD_ADDR_EXP 92
19460: PUSH
19461: LD_EXP 92
19465: PPUSH
19466: LD_VAR 0 4
19470: PPUSH
19471: LD_INT 0
19473: PPUSH
19474: CALL_OW 1
19478: ST_TO_ADDR
// result := base ;
19479: LD_ADDR_VAR 0 3
19483: PUSH
19484: LD_VAR 0 4
19488: ST_TO_ADDR
// end ;
19489: LD_VAR 0 3
19493: RET
// export function MC_Start ( ) ; var i ; begin
19494: LD_INT 0
19496: PPUSH
19497: PPUSH
// for i = 1 to mc_bases do
19498: LD_ADDR_VAR 0 2
19502: PUSH
19503: DOUBLE
19504: LD_INT 1
19506: DEC
19507: ST_TO_ADDR
19508: LD_EXP 50
19512: PUSH
19513: FOR_TO
19514: IFFALSE 20591
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
19516: LD_ADDR_EXP 50
19520: PUSH
19521: LD_EXP 50
19525: PPUSH
19526: LD_VAR 0 2
19530: PPUSH
19531: LD_EXP 50
19535: PUSH
19536: LD_VAR 0 2
19540: ARRAY
19541: PUSH
19542: LD_INT 0
19544: DIFF
19545: PPUSH
19546: CALL_OW 1
19550: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
19551: LD_ADDR_EXP 51
19555: PUSH
19556: LD_EXP 51
19560: PPUSH
19561: LD_VAR 0 2
19565: PPUSH
19566: EMPTY
19567: PPUSH
19568: CALL_OW 1
19572: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19573: LD_ADDR_EXP 52
19577: PUSH
19578: LD_EXP 52
19582: PPUSH
19583: LD_VAR 0 2
19587: PPUSH
19588: EMPTY
19589: PPUSH
19590: CALL_OW 1
19594: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
19595: LD_ADDR_EXP 53
19599: PUSH
19600: LD_EXP 53
19604: PPUSH
19605: LD_VAR 0 2
19609: PPUSH
19610: EMPTY
19611: PPUSH
19612: CALL_OW 1
19616: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
19617: LD_ADDR_EXP 54
19621: PUSH
19622: LD_EXP 54
19626: PPUSH
19627: LD_VAR 0 2
19631: PPUSH
19632: EMPTY
19633: PUSH
19634: EMPTY
19635: PUSH
19636: EMPTY
19637: LIST
19638: LIST
19639: PPUSH
19640: CALL_OW 1
19644: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
19645: LD_ADDR_EXP 55
19649: PUSH
19650: LD_EXP 55
19654: PPUSH
19655: LD_VAR 0 2
19659: PPUSH
19660: EMPTY
19661: PPUSH
19662: CALL_OW 1
19666: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
19667: LD_ADDR_EXP 82
19671: PUSH
19672: LD_EXP 82
19676: PPUSH
19677: LD_VAR 0 2
19681: PPUSH
19682: EMPTY
19683: PPUSH
19684: CALL_OW 1
19688: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
19689: LD_ADDR_EXP 56
19693: PUSH
19694: LD_EXP 56
19698: PPUSH
19699: LD_VAR 0 2
19703: PPUSH
19704: EMPTY
19705: PPUSH
19706: CALL_OW 1
19710: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
19711: LD_ADDR_EXP 57
19715: PUSH
19716: LD_EXP 57
19720: PPUSH
19721: LD_VAR 0 2
19725: PPUSH
19726: EMPTY
19727: PPUSH
19728: CALL_OW 1
19732: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
19733: LD_ADDR_EXP 58
19737: PUSH
19738: LD_EXP 58
19742: PPUSH
19743: LD_VAR 0 2
19747: PPUSH
19748: LD_EXP 50
19752: PUSH
19753: LD_VAR 0 2
19757: ARRAY
19758: PPUSH
19759: LD_INT 2
19761: PUSH
19762: LD_INT 30
19764: PUSH
19765: LD_INT 32
19767: PUSH
19768: EMPTY
19769: LIST
19770: LIST
19771: PUSH
19772: LD_INT 30
19774: PUSH
19775: LD_INT 33
19777: PUSH
19778: EMPTY
19779: LIST
19780: LIST
19781: PUSH
19782: EMPTY
19783: LIST
19784: LIST
19785: LIST
19786: PPUSH
19787: CALL_OW 72
19791: PPUSH
19792: CALL_OW 1
19796: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
19797: LD_ADDR_EXP 59
19801: PUSH
19802: LD_EXP 59
19806: PPUSH
19807: LD_VAR 0 2
19811: PPUSH
19812: LD_EXP 50
19816: PUSH
19817: LD_VAR 0 2
19821: ARRAY
19822: PPUSH
19823: LD_INT 2
19825: PUSH
19826: LD_INT 30
19828: PUSH
19829: LD_INT 32
19831: PUSH
19832: EMPTY
19833: LIST
19834: LIST
19835: PUSH
19836: LD_INT 30
19838: PUSH
19839: LD_INT 31
19841: PUSH
19842: EMPTY
19843: LIST
19844: LIST
19845: PUSH
19846: EMPTY
19847: LIST
19848: LIST
19849: LIST
19850: PUSH
19851: LD_INT 58
19853: PUSH
19854: EMPTY
19855: LIST
19856: PUSH
19857: EMPTY
19858: LIST
19859: LIST
19860: PPUSH
19861: CALL_OW 72
19865: PPUSH
19866: CALL_OW 1
19870: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
19871: LD_ADDR_EXP 60
19875: PUSH
19876: LD_EXP 60
19880: PPUSH
19881: LD_VAR 0 2
19885: PPUSH
19886: EMPTY
19887: PPUSH
19888: CALL_OW 1
19892: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
19893: LD_ADDR_EXP 64
19897: PUSH
19898: LD_EXP 64
19902: PPUSH
19903: LD_VAR 0 2
19907: PPUSH
19908: EMPTY
19909: PPUSH
19910: CALL_OW 1
19914: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
19915: LD_ADDR_EXP 63
19919: PUSH
19920: LD_EXP 63
19924: PPUSH
19925: LD_VAR 0 2
19929: PPUSH
19930: EMPTY
19931: PPUSH
19932: CALL_OW 1
19936: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
19937: LD_ADDR_EXP 65
19941: PUSH
19942: LD_EXP 65
19946: PPUSH
19947: LD_VAR 0 2
19951: PPUSH
19952: EMPTY
19953: PPUSH
19954: CALL_OW 1
19958: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
19959: LD_ADDR_EXP 66
19963: PUSH
19964: LD_EXP 66
19968: PPUSH
19969: LD_VAR 0 2
19973: PPUSH
19974: EMPTY
19975: PPUSH
19976: CALL_OW 1
19980: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
19981: LD_ADDR_EXP 67
19985: PUSH
19986: LD_EXP 67
19990: PPUSH
19991: LD_VAR 0 2
19995: PPUSH
19996: EMPTY
19997: PPUSH
19998: CALL_OW 1
20002: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20003: LD_ADDR_EXP 68
20007: PUSH
20008: LD_EXP 68
20012: PPUSH
20013: LD_VAR 0 2
20017: PPUSH
20018: EMPTY
20019: PPUSH
20020: CALL_OW 1
20024: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20025: LD_ADDR_EXP 69
20029: PUSH
20030: LD_EXP 69
20034: PPUSH
20035: LD_VAR 0 2
20039: PPUSH
20040: EMPTY
20041: PPUSH
20042: CALL_OW 1
20046: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20047: LD_ADDR_EXP 70
20051: PUSH
20052: LD_EXP 70
20056: PPUSH
20057: LD_VAR 0 2
20061: PPUSH
20062: EMPTY
20063: PPUSH
20064: CALL_OW 1
20068: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20069: LD_ADDR_EXP 71
20073: PUSH
20074: LD_EXP 71
20078: PPUSH
20079: LD_VAR 0 2
20083: PPUSH
20084: EMPTY
20085: PPUSH
20086: CALL_OW 1
20090: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20091: LD_ADDR_EXP 72
20095: PUSH
20096: LD_EXP 72
20100: PPUSH
20101: LD_VAR 0 2
20105: PPUSH
20106: EMPTY
20107: PPUSH
20108: CALL_OW 1
20112: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20113: LD_ADDR_EXP 61
20117: PUSH
20118: LD_EXP 61
20122: PPUSH
20123: LD_VAR 0 2
20127: PPUSH
20128: LD_INT 0
20130: PPUSH
20131: CALL_OW 1
20135: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20136: LD_ADDR_EXP 74
20140: PUSH
20141: LD_EXP 74
20145: PPUSH
20146: LD_VAR 0 2
20150: PPUSH
20151: LD_INT 0
20153: PPUSH
20154: CALL_OW 1
20158: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20159: LD_ADDR_EXP 62
20163: PUSH
20164: LD_EXP 62
20168: PPUSH
20169: LD_VAR 0 2
20173: PPUSH
20174: EMPTY
20175: PPUSH
20176: CALL_OW 1
20180: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20181: LD_ADDR_EXP 73
20185: PUSH
20186: LD_EXP 73
20190: PPUSH
20191: LD_VAR 0 2
20195: PPUSH
20196: LD_INT 0
20198: PPUSH
20199: CALL_OW 1
20203: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20204: LD_ADDR_EXP 75
20208: PUSH
20209: LD_EXP 75
20213: PPUSH
20214: LD_VAR 0 2
20218: PPUSH
20219: EMPTY
20220: PPUSH
20221: CALL_OW 1
20225: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20226: LD_ADDR_EXP 78
20230: PUSH
20231: LD_EXP 78
20235: PPUSH
20236: LD_VAR 0 2
20240: PPUSH
20241: LD_INT 0
20243: PPUSH
20244: CALL_OW 1
20248: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20249: LD_ADDR_EXP 79
20253: PUSH
20254: LD_EXP 79
20258: PPUSH
20259: LD_VAR 0 2
20263: PPUSH
20264: EMPTY
20265: PPUSH
20266: CALL_OW 1
20270: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20271: LD_ADDR_EXP 80
20275: PUSH
20276: LD_EXP 80
20280: PPUSH
20281: LD_VAR 0 2
20285: PPUSH
20286: EMPTY
20287: PPUSH
20288: CALL_OW 1
20292: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20293: LD_ADDR_EXP 81
20297: PUSH
20298: LD_EXP 81
20302: PPUSH
20303: LD_VAR 0 2
20307: PPUSH
20308: EMPTY
20309: PPUSH
20310: CALL_OW 1
20314: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20315: LD_ADDR_EXP 83
20319: PUSH
20320: LD_EXP 83
20324: PPUSH
20325: LD_VAR 0 2
20329: PPUSH
20330: LD_EXP 50
20334: PUSH
20335: LD_VAR 0 2
20339: ARRAY
20340: PPUSH
20341: LD_INT 2
20343: PUSH
20344: LD_INT 30
20346: PUSH
20347: LD_INT 6
20349: PUSH
20350: EMPTY
20351: LIST
20352: LIST
20353: PUSH
20354: LD_INT 30
20356: PUSH
20357: LD_INT 7
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: PUSH
20364: LD_INT 30
20366: PUSH
20367: LD_INT 8
20369: PUSH
20370: EMPTY
20371: LIST
20372: LIST
20373: PUSH
20374: EMPTY
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: PPUSH
20380: CALL_OW 72
20384: PPUSH
20385: CALL_OW 1
20389: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20390: LD_ADDR_EXP 84
20394: PUSH
20395: LD_EXP 84
20399: PPUSH
20400: LD_VAR 0 2
20404: PPUSH
20405: EMPTY
20406: PPUSH
20407: CALL_OW 1
20411: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20412: LD_ADDR_EXP 85
20416: PUSH
20417: LD_EXP 85
20421: PPUSH
20422: LD_VAR 0 2
20426: PPUSH
20427: EMPTY
20428: PPUSH
20429: CALL_OW 1
20433: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20434: LD_ADDR_EXP 86
20438: PUSH
20439: LD_EXP 86
20443: PPUSH
20444: LD_VAR 0 2
20448: PPUSH
20449: EMPTY
20450: PPUSH
20451: CALL_OW 1
20455: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20456: LD_ADDR_EXP 87
20460: PUSH
20461: LD_EXP 87
20465: PPUSH
20466: LD_VAR 0 2
20470: PPUSH
20471: EMPTY
20472: PPUSH
20473: CALL_OW 1
20477: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20478: LD_ADDR_EXP 88
20482: PUSH
20483: LD_EXP 88
20487: PPUSH
20488: LD_VAR 0 2
20492: PPUSH
20493: EMPTY
20494: PPUSH
20495: CALL_OW 1
20499: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
20500: LD_ADDR_EXP 89
20504: PUSH
20505: LD_EXP 89
20509: PPUSH
20510: LD_VAR 0 2
20514: PPUSH
20515: EMPTY
20516: PPUSH
20517: CALL_OW 1
20521: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
20522: LD_ADDR_EXP 90
20526: PUSH
20527: LD_EXP 90
20531: PPUSH
20532: LD_VAR 0 2
20536: PPUSH
20537: EMPTY
20538: PPUSH
20539: CALL_OW 1
20543: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
20544: LD_ADDR_EXP 91
20548: PUSH
20549: LD_EXP 91
20553: PPUSH
20554: LD_VAR 0 2
20558: PPUSH
20559: EMPTY
20560: PPUSH
20561: CALL_OW 1
20565: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
20566: LD_ADDR_EXP 92
20570: PUSH
20571: LD_EXP 92
20575: PPUSH
20576: LD_VAR 0 2
20580: PPUSH
20581: LD_INT 0
20583: PPUSH
20584: CALL_OW 1
20588: ST_TO_ADDR
// end ;
20589: GO 19513
20591: POP
20592: POP
// MC_InitSides ( ) ;
20593: CALL 20879 0 0
// MC_InitResearch ( ) ;
20597: CALL 20618 0 0
// CustomInitMacro ( ) ;
20601: CALL 300 0 0
// skirmish := true ;
20605: LD_ADDR_EXP 48
20609: PUSH
20610: LD_INT 1
20612: ST_TO_ADDR
// end ;
20613: LD_VAR 0 1
20617: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
20618: LD_INT 0
20620: PPUSH
20621: PPUSH
20622: PPUSH
20623: PPUSH
20624: PPUSH
20625: PPUSH
// if not mc_bases then
20626: LD_EXP 50
20630: NOT
20631: IFFALSE 20635
// exit ;
20633: GO 20874
// for i = 1 to 8 do
20635: LD_ADDR_VAR 0 2
20639: PUSH
20640: DOUBLE
20641: LD_INT 1
20643: DEC
20644: ST_TO_ADDR
20645: LD_INT 8
20647: PUSH
20648: FOR_TO
20649: IFFALSE 20675
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
20651: LD_ADDR_EXP 77
20655: PUSH
20656: LD_EXP 77
20660: PPUSH
20661: LD_VAR 0 2
20665: PPUSH
20666: EMPTY
20667: PPUSH
20668: CALL_OW 1
20672: ST_TO_ADDR
20673: GO 20648
20675: POP
20676: POP
// tmp := [ ] ;
20677: LD_ADDR_VAR 0 5
20681: PUSH
20682: EMPTY
20683: ST_TO_ADDR
// for i = 1 to mc_sides do
20684: LD_ADDR_VAR 0 2
20688: PUSH
20689: DOUBLE
20690: LD_INT 1
20692: DEC
20693: ST_TO_ADDR
20694: LD_EXP 76
20698: PUSH
20699: FOR_TO
20700: IFFALSE 20758
// if not mc_sides [ i ] in tmp then
20702: LD_EXP 76
20706: PUSH
20707: LD_VAR 0 2
20711: ARRAY
20712: PUSH
20713: LD_VAR 0 5
20717: IN
20718: NOT
20719: IFFALSE 20756
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
20721: LD_ADDR_VAR 0 5
20725: PUSH
20726: LD_VAR 0 5
20730: PPUSH
20731: LD_VAR 0 5
20735: PUSH
20736: LD_INT 1
20738: PLUS
20739: PPUSH
20740: LD_EXP 76
20744: PUSH
20745: LD_VAR 0 2
20749: ARRAY
20750: PPUSH
20751: CALL_OW 2
20755: ST_TO_ADDR
20756: GO 20699
20758: POP
20759: POP
// if not tmp then
20760: LD_VAR 0 5
20764: NOT
20765: IFFALSE 20769
// exit ;
20767: GO 20874
// for j in tmp do
20769: LD_ADDR_VAR 0 3
20773: PUSH
20774: LD_VAR 0 5
20778: PUSH
20779: FOR_IN
20780: IFFALSE 20872
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
20782: LD_ADDR_VAR 0 6
20786: PUSH
20787: LD_INT 22
20789: PUSH
20790: LD_VAR 0 3
20794: PUSH
20795: EMPTY
20796: LIST
20797: LIST
20798: PPUSH
20799: CALL_OW 69
20803: ST_TO_ADDR
// if not un then
20804: LD_VAR 0 6
20808: NOT
20809: IFFALSE 20813
// continue ;
20811: GO 20779
// nation := GetNation ( un [ 1 ] ) ;
20813: LD_ADDR_VAR 0 4
20817: PUSH
20818: LD_VAR 0 6
20822: PUSH
20823: LD_INT 1
20825: ARRAY
20826: PPUSH
20827: CALL_OW 248
20831: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
20832: LD_ADDR_EXP 77
20836: PUSH
20837: LD_EXP 77
20841: PPUSH
20842: LD_VAR 0 3
20846: PPUSH
20847: LD_VAR 0 3
20851: PPUSH
20852: LD_VAR 0 4
20856: PPUSH
20857: LD_INT 1
20859: PPUSH
20860: CALL 47484 0 3
20864: PPUSH
20865: CALL_OW 1
20869: ST_TO_ADDR
// end ;
20870: GO 20779
20872: POP
20873: POP
// end ;
20874: LD_VAR 0 1
20878: RET
// export function MC_InitSides ( ) ; var i ; begin
20879: LD_INT 0
20881: PPUSH
20882: PPUSH
// if not mc_bases then
20883: LD_EXP 50
20887: NOT
20888: IFFALSE 20892
// exit ;
20890: GO 20966
// for i = 1 to mc_bases do
20892: LD_ADDR_VAR 0 2
20896: PUSH
20897: DOUBLE
20898: LD_INT 1
20900: DEC
20901: ST_TO_ADDR
20902: LD_EXP 50
20906: PUSH
20907: FOR_TO
20908: IFFALSE 20964
// if mc_bases [ i ] then
20910: LD_EXP 50
20914: PUSH
20915: LD_VAR 0 2
20919: ARRAY
20920: IFFALSE 20962
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
20922: LD_ADDR_EXP 76
20926: PUSH
20927: LD_EXP 76
20931: PPUSH
20932: LD_VAR 0 2
20936: PPUSH
20937: LD_EXP 50
20941: PUSH
20942: LD_VAR 0 2
20946: ARRAY
20947: PUSH
20948: LD_INT 1
20950: ARRAY
20951: PPUSH
20952: CALL_OW 255
20956: PPUSH
20957: CALL_OW 1
20961: ST_TO_ADDR
20962: GO 20907
20964: POP
20965: POP
// end ;
20966: LD_VAR 0 1
20970: RET
// every 0 0$01 trigger skirmish do
20971: LD_EXP 48
20975: IFFALSE 21129
20977: GO 20979
20979: DISABLE
// begin enable ;
20980: ENABLE
// MC_CheckBuildings ( ) ;
20981: CALL 25627 0 0
// MC_CheckPeopleLife ( ) ;
20985: CALL 25752 0 0
// RaiseSailEvent ( 100 ) ;
20989: LD_INT 100
20991: PPUSH
20992: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
20996: LD_INT 103
20998: PPUSH
20999: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21003: LD_INT 104
21005: PPUSH
21006: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21010: LD_INT 105
21012: PPUSH
21013: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21017: LD_INT 106
21019: PPUSH
21020: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21024: LD_INT 107
21026: PPUSH
21027: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21031: LD_INT 108
21033: PPUSH
21034: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21038: LD_INT 109
21040: PPUSH
21041: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21045: LD_INT 110
21047: PPUSH
21048: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21052: LD_INT 111
21054: PPUSH
21055: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21059: LD_INT 112
21061: PPUSH
21062: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21066: LD_INT 113
21068: PPUSH
21069: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21073: LD_INT 120
21075: PPUSH
21076: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21080: LD_INT 121
21082: PPUSH
21083: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21087: LD_INT 122
21089: PPUSH
21090: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21094: LD_INT 123
21096: PPUSH
21097: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21101: LD_INT 124
21103: PPUSH
21104: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21108: LD_INT 125
21110: PPUSH
21111: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21115: LD_INT 126
21117: PPUSH
21118: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21122: LD_INT 200
21124: PPUSH
21125: CALL_OW 427
// end ;
21129: END
// on SailEvent ( event ) do begin if event < 100 then
21130: LD_VAR 0 1
21134: PUSH
21135: LD_INT 100
21137: LESS
21138: IFFALSE 21149
// CustomEvent ( event ) ;
21140: LD_VAR 0 1
21144: PPUSH
21145: CALL 16648 0 1
// if event = 100 then
21149: LD_VAR 0 1
21153: PUSH
21154: LD_INT 100
21156: EQUAL
21157: IFFALSE 21163
// MC_ClassManager ( ) ;
21159: CALL 21555 0 0
// if event = 101 then
21163: LD_VAR 0 1
21167: PUSH
21168: LD_INT 101
21170: EQUAL
21171: IFFALSE 21177
// MC_RepairBuildings ( ) ;
21173: CALL 26348 0 0
// if event = 102 then
21177: LD_VAR 0 1
21181: PUSH
21182: LD_INT 102
21184: EQUAL
21185: IFFALSE 21191
// MC_Heal ( ) ;
21187: CALL 27212 0 0
// if event = 103 then
21191: LD_VAR 0 1
21195: PUSH
21196: LD_INT 103
21198: EQUAL
21199: IFFALSE 21205
// MC_Build ( ) ;
21201: CALL 27634 0 0
// if event = 104 then
21205: LD_VAR 0 1
21209: PUSH
21210: LD_INT 104
21212: EQUAL
21213: IFFALSE 21219
// MC_TurretWeapon ( ) ;
21215: CALL 29247 0 0
// if event = 105 then
21219: LD_VAR 0 1
21223: PUSH
21224: LD_INT 105
21226: EQUAL
21227: IFFALSE 21233
// MC_BuildUpgrade ( ) ;
21229: CALL 28798 0 0
// if event = 106 then
21233: LD_VAR 0 1
21237: PUSH
21238: LD_INT 106
21240: EQUAL
21241: IFFALSE 21247
// MC_PlantMines ( ) ;
21243: CALL 29677 0 0
// if event = 107 then
21247: LD_VAR 0 1
21251: PUSH
21252: LD_INT 107
21254: EQUAL
21255: IFFALSE 21261
// MC_CollectCrates ( ) ;
21257: CALL 30475 0 0
// if event = 108 then
21261: LD_VAR 0 1
21265: PUSH
21266: LD_INT 108
21268: EQUAL
21269: IFFALSE 21275
// MC_LinkRemoteControl ( ) ;
21271: CALL 32251 0 0
// if event = 109 then
21275: LD_VAR 0 1
21279: PUSH
21280: LD_INT 109
21282: EQUAL
21283: IFFALSE 21289
// MC_ProduceVehicle ( ) ;
21285: CALL 32432 0 0
// if event = 110 then
21289: LD_VAR 0 1
21293: PUSH
21294: LD_INT 110
21296: EQUAL
21297: IFFALSE 21303
// MC_SendAttack ( ) ;
21299: CALL 32898 0 0
// if event = 111 then
21303: LD_VAR 0 1
21307: PUSH
21308: LD_INT 111
21310: EQUAL
21311: IFFALSE 21317
// MC_Defend ( ) ;
21313: CALL 33006 0 0
// if event = 112 then
21317: LD_VAR 0 1
21321: PUSH
21322: LD_INT 112
21324: EQUAL
21325: IFFALSE 21331
// MC_Research ( ) ;
21327: CALL 33611 0 0
// if event = 113 then
21331: LD_VAR 0 1
21335: PUSH
21336: LD_INT 113
21338: EQUAL
21339: IFFALSE 21345
// MC_MinesTrigger ( ) ;
21341: CALL 34725 0 0
// if event = 120 then
21345: LD_VAR 0 1
21349: PUSH
21350: LD_INT 120
21352: EQUAL
21353: IFFALSE 21359
// MC_RepairVehicle ( ) ;
21355: CALL 34824 0 0
// if event = 121 then
21359: LD_VAR 0 1
21363: PUSH
21364: LD_INT 121
21366: EQUAL
21367: IFFALSE 21373
// MC_TameApe ( ) ;
21369: CALL 35554 0 0
// if event = 122 then
21373: LD_VAR 0 1
21377: PUSH
21378: LD_INT 122
21380: EQUAL
21381: IFFALSE 21387
// MC_ChangeApeClass ( ) ;
21383: CALL 36383 0 0
// if event = 123 then
21387: LD_VAR 0 1
21391: PUSH
21392: LD_INT 123
21394: EQUAL
21395: IFFALSE 21401
// MC_Bazooka ( ) ;
21397: CALL 37033 0 0
// if event = 124 then
21401: LD_VAR 0 1
21405: PUSH
21406: LD_INT 124
21408: EQUAL
21409: IFFALSE 21415
// MC_TeleportExit ( ) ;
21411: CALL 37231 0 0
// if event = 125 then
21415: LD_VAR 0 1
21419: PUSH
21420: LD_INT 125
21422: EQUAL
21423: IFFALSE 21429
// MC_Deposits ( ) ;
21425: CALL 37878 0 0
// if event = 126 then
21429: LD_VAR 0 1
21433: PUSH
21434: LD_INT 126
21436: EQUAL
21437: IFFALSE 21443
// MC_RemoteDriver ( ) ;
21439: CALL 38503 0 0
// if event = 200 then
21443: LD_VAR 0 1
21447: PUSH
21448: LD_INT 200
21450: EQUAL
21451: IFFALSE 21457
// MC_Idle ( ) ;
21453: CALL 40452 0 0
// end ;
21457: PPOPN 1
21459: END
// export function MC_Reset ( base , tag ) ; var i ; begin
21460: LD_INT 0
21462: PPUSH
21463: PPUSH
// if not mc_bases [ base ] or not tag then
21464: LD_EXP 50
21468: PUSH
21469: LD_VAR 0 1
21473: ARRAY
21474: NOT
21475: PUSH
21476: LD_VAR 0 2
21480: NOT
21481: OR
21482: IFFALSE 21486
// exit ;
21484: GO 21550
// for i in mc_bases [ base ] union mc_ape [ base ] do
21486: LD_ADDR_VAR 0 4
21490: PUSH
21491: LD_EXP 50
21495: PUSH
21496: LD_VAR 0 1
21500: ARRAY
21501: PUSH
21502: LD_EXP 79
21506: PUSH
21507: LD_VAR 0 1
21511: ARRAY
21512: UNION
21513: PUSH
21514: FOR_IN
21515: IFFALSE 21548
// if GetTag ( i ) = tag then
21517: LD_VAR 0 4
21521: PPUSH
21522: CALL_OW 110
21526: PUSH
21527: LD_VAR 0 2
21531: EQUAL
21532: IFFALSE 21546
// SetTag ( i , 0 ) ;
21534: LD_VAR 0 4
21538: PPUSH
21539: LD_INT 0
21541: PPUSH
21542: CALL_OW 109
21546: GO 21514
21548: POP
21549: POP
// end ;
21550: LD_VAR 0 3
21554: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
21555: LD_INT 0
21557: PPUSH
21558: PPUSH
21559: PPUSH
21560: PPUSH
21561: PPUSH
21562: PPUSH
21563: PPUSH
21564: PPUSH
// if not mc_bases then
21565: LD_EXP 50
21569: NOT
21570: IFFALSE 21574
// exit ;
21572: GO 22032
// for i = 1 to mc_bases do
21574: LD_ADDR_VAR 0 2
21578: PUSH
21579: DOUBLE
21580: LD_INT 1
21582: DEC
21583: ST_TO_ADDR
21584: LD_EXP 50
21588: PUSH
21589: FOR_TO
21590: IFFALSE 22030
// begin tmp := MC_ClassCheckReq ( i ) ;
21592: LD_ADDR_VAR 0 4
21596: PUSH
21597: LD_VAR 0 2
21601: PPUSH
21602: CALL 22037 0 1
21606: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
21607: LD_ADDR_EXP 91
21611: PUSH
21612: LD_EXP 91
21616: PPUSH
21617: LD_VAR 0 2
21621: PPUSH
21622: LD_VAR 0 4
21626: PPUSH
21627: CALL_OW 1
21631: ST_TO_ADDR
// if not tmp then
21632: LD_VAR 0 4
21636: NOT
21637: IFFALSE 21641
// continue ;
21639: GO 21589
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
21641: LD_ADDR_VAR 0 6
21645: PUSH
21646: LD_EXP 50
21650: PUSH
21651: LD_VAR 0 2
21655: ARRAY
21656: PPUSH
21657: LD_INT 2
21659: PUSH
21660: LD_INT 30
21662: PUSH
21663: LD_INT 4
21665: PUSH
21666: EMPTY
21667: LIST
21668: LIST
21669: PUSH
21670: LD_INT 30
21672: PUSH
21673: LD_INT 5
21675: PUSH
21676: EMPTY
21677: LIST
21678: LIST
21679: PUSH
21680: EMPTY
21681: LIST
21682: LIST
21683: LIST
21684: PPUSH
21685: CALL_OW 72
21689: PUSH
21690: LD_EXP 50
21694: PUSH
21695: LD_VAR 0 2
21699: ARRAY
21700: PPUSH
21701: LD_INT 2
21703: PUSH
21704: LD_INT 30
21706: PUSH
21707: LD_INT 0
21709: PUSH
21710: EMPTY
21711: LIST
21712: LIST
21713: PUSH
21714: LD_INT 30
21716: PUSH
21717: LD_INT 1
21719: PUSH
21720: EMPTY
21721: LIST
21722: LIST
21723: PUSH
21724: EMPTY
21725: LIST
21726: LIST
21727: LIST
21728: PPUSH
21729: CALL_OW 72
21733: PUSH
21734: LD_EXP 50
21738: PUSH
21739: LD_VAR 0 2
21743: ARRAY
21744: PPUSH
21745: LD_INT 30
21747: PUSH
21748: LD_INT 3
21750: PUSH
21751: EMPTY
21752: LIST
21753: LIST
21754: PPUSH
21755: CALL_OW 72
21759: PUSH
21760: LD_EXP 50
21764: PUSH
21765: LD_VAR 0 2
21769: ARRAY
21770: PPUSH
21771: LD_INT 2
21773: PUSH
21774: LD_INT 30
21776: PUSH
21777: LD_INT 6
21779: PUSH
21780: EMPTY
21781: LIST
21782: LIST
21783: PUSH
21784: LD_INT 30
21786: PUSH
21787: LD_INT 7
21789: PUSH
21790: EMPTY
21791: LIST
21792: LIST
21793: PUSH
21794: LD_INT 30
21796: PUSH
21797: LD_INT 8
21799: PUSH
21800: EMPTY
21801: LIST
21802: LIST
21803: PUSH
21804: EMPTY
21805: LIST
21806: LIST
21807: LIST
21808: LIST
21809: PPUSH
21810: CALL_OW 72
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: LIST
21819: LIST
21820: ST_TO_ADDR
// for j = 1 to 4 do
21821: LD_ADDR_VAR 0 3
21825: PUSH
21826: DOUBLE
21827: LD_INT 1
21829: DEC
21830: ST_TO_ADDR
21831: LD_INT 4
21833: PUSH
21834: FOR_TO
21835: IFFALSE 22026
// begin if not tmp [ j ] then
21837: LD_VAR 0 4
21841: PUSH
21842: LD_VAR 0 3
21846: ARRAY
21847: NOT
21848: IFFALSE 21852
// continue ;
21850: GO 21834
// for p in tmp [ j ] do
21852: LD_ADDR_VAR 0 5
21856: PUSH
21857: LD_VAR 0 4
21861: PUSH
21862: LD_VAR 0 3
21866: ARRAY
21867: PUSH
21868: FOR_IN
21869: IFFALSE 22022
// begin if not b [ j ] then
21871: LD_VAR 0 6
21875: PUSH
21876: LD_VAR 0 3
21880: ARRAY
21881: NOT
21882: IFFALSE 21886
// break ;
21884: GO 22022
// e := 0 ;
21886: LD_ADDR_VAR 0 7
21890: PUSH
21891: LD_INT 0
21893: ST_TO_ADDR
// for k in b [ j ] do
21894: LD_ADDR_VAR 0 8
21898: PUSH
21899: LD_VAR 0 6
21903: PUSH
21904: LD_VAR 0 3
21908: ARRAY
21909: PUSH
21910: FOR_IN
21911: IFFALSE 21938
// if IsNotFull ( k ) then
21913: LD_VAR 0 8
21917: PPUSH
21918: CALL 49633 0 1
21922: IFFALSE 21936
// begin e := k ;
21924: LD_ADDR_VAR 0 7
21928: PUSH
21929: LD_VAR 0 8
21933: ST_TO_ADDR
// break ;
21934: GO 21938
// end ;
21936: GO 21910
21938: POP
21939: POP
// if e and not UnitGoingToBuilding ( p , e ) then
21940: LD_VAR 0 7
21944: PUSH
21945: LD_VAR 0 5
21949: PPUSH
21950: LD_VAR 0 7
21954: PPUSH
21955: CALL 82053 0 2
21959: NOT
21960: AND
21961: IFFALSE 22020
// begin if IsInUnit ( p ) then
21963: LD_VAR 0 5
21967: PPUSH
21968: CALL_OW 310
21972: IFFALSE 21983
// ComExitBuilding ( p ) ;
21974: LD_VAR 0 5
21978: PPUSH
21979: CALL_OW 122
// ComEnterUnit ( p , e ) ;
21983: LD_VAR 0 5
21987: PPUSH
21988: LD_VAR 0 7
21992: PPUSH
21993: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
21997: LD_VAR 0 5
22001: PPUSH
22002: LD_VAR 0 3
22006: PPUSH
22007: CALL_OW 183
// AddComExitBuilding ( p ) ;
22011: LD_VAR 0 5
22015: PPUSH
22016: CALL_OW 182
// end ; end ;
22020: GO 21868
22022: POP
22023: POP
// end ;
22024: GO 21834
22026: POP
22027: POP
// end ;
22028: GO 21589
22030: POP
22031: POP
// end ;
22032: LD_VAR 0 1
22036: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22037: LD_INT 0
22039: PPUSH
22040: PPUSH
22041: PPUSH
22042: PPUSH
22043: PPUSH
22044: PPUSH
22045: PPUSH
22046: PPUSH
22047: PPUSH
22048: PPUSH
22049: PPUSH
22050: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22051: LD_VAR 0 1
22055: NOT
22056: PUSH
22057: LD_EXP 50
22061: PUSH
22062: LD_VAR 0 1
22066: ARRAY
22067: NOT
22068: OR
22069: PUSH
22070: LD_EXP 50
22074: PUSH
22075: LD_VAR 0 1
22079: ARRAY
22080: PPUSH
22081: LD_INT 2
22083: PUSH
22084: LD_INT 30
22086: PUSH
22087: LD_INT 0
22089: PUSH
22090: EMPTY
22091: LIST
22092: LIST
22093: PUSH
22094: LD_INT 30
22096: PUSH
22097: LD_INT 1
22099: PUSH
22100: EMPTY
22101: LIST
22102: LIST
22103: PUSH
22104: EMPTY
22105: LIST
22106: LIST
22107: LIST
22108: PPUSH
22109: CALL_OW 72
22113: NOT
22114: OR
22115: IFFALSE 22119
// exit ;
22117: GO 25622
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22119: LD_ADDR_VAR 0 4
22123: PUSH
22124: LD_EXP 50
22128: PUSH
22129: LD_VAR 0 1
22133: ARRAY
22134: PPUSH
22135: LD_INT 2
22137: PUSH
22138: LD_INT 25
22140: PUSH
22141: LD_INT 1
22143: PUSH
22144: EMPTY
22145: LIST
22146: LIST
22147: PUSH
22148: LD_INT 25
22150: PUSH
22151: LD_INT 2
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: PUSH
22158: LD_INT 25
22160: PUSH
22161: LD_INT 3
22163: PUSH
22164: EMPTY
22165: LIST
22166: LIST
22167: PUSH
22168: LD_INT 25
22170: PUSH
22171: LD_INT 4
22173: PUSH
22174: EMPTY
22175: LIST
22176: LIST
22177: PUSH
22178: LD_INT 25
22180: PUSH
22181: LD_INT 5
22183: PUSH
22184: EMPTY
22185: LIST
22186: LIST
22187: PUSH
22188: LD_INT 25
22190: PUSH
22191: LD_INT 8
22193: PUSH
22194: EMPTY
22195: LIST
22196: LIST
22197: PUSH
22198: LD_INT 25
22200: PUSH
22201: LD_INT 9
22203: PUSH
22204: EMPTY
22205: LIST
22206: LIST
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: LIST
22212: LIST
22213: LIST
22214: LIST
22215: LIST
22216: LIST
22217: PPUSH
22218: CALL_OW 72
22222: ST_TO_ADDR
// if not tmp then
22223: LD_VAR 0 4
22227: NOT
22228: IFFALSE 22232
// exit ;
22230: GO 25622
// for i in tmp do
22232: LD_ADDR_VAR 0 3
22236: PUSH
22237: LD_VAR 0 4
22241: PUSH
22242: FOR_IN
22243: IFFALSE 22274
// if GetTag ( i ) then
22245: LD_VAR 0 3
22249: PPUSH
22250: CALL_OW 110
22254: IFFALSE 22272
// tmp := tmp diff i ;
22256: LD_ADDR_VAR 0 4
22260: PUSH
22261: LD_VAR 0 4
22265: PUSH
22266: LD_VAR 0 3
22270: DIFF
22271: ST_TO_ADDR
22272: GO 22242
22274: POP
22275: POP
// if not tmp then
22276: LD_VAR 0 4
22280: NOT
22281: IFFALSE 22285
// exit ;
22283: GO 25622
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22285: LD_ADDR_VAR 0 5
22289: PUSH
22290: LD_EXP 50
22294: PUSH
22295: LD_VAR 0 1
22299: ARRAY
22300: PPUSH
22301: LD_INT 2
22303: PUSH
22304: LD_INT 25
22306: PUSH
22307: LD_INT 1
22309: PUSH
22310: EMPTY
22311: LIST
22312: LIST
22313: PUSH
22314: LD_INT 25
22316: PUSH
22317: LD_INT 5
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: PUSH
22324: LD_INT 25
22326: PUSH
22327: LD_INT 8
22329: PUSH
22330: EMPTY
22331: LIST
22332: LIST
22333: PUSH
22334: LD_INT 25
22336: PUSH
22337: LD_INT 9
22339: PUSH
22340: EMPTY
22341: LIST
22342: LIST
22343: PUSH
22344: EMPTY
22345: LIST
22346: LIST
22347: LIST
22348: LIST
22349: LIST
22350: PPUSH
22351: CALL_OW 72
22355: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22356: LD_ADDR_VAR 0 6
22360: PUSH
22361: LD_EXP 50
22365: PUSH
22366: LD_VAR 0 1
22370: ARRAY
22371: PPUSH
22372: LD_INT 25
22374: PUSH
22375: LD_INT 2
22377: PUSH
22378: EMPTY
22379: LIST
22380: LIST
22381: PPUSH
22382: CALL_OW 72
22386: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22387: LD_ADDR_VAR 0 7
22391: PUSH
22392: LD_EXP 50
22396: PUSH
22397: LD_VAR 0 1
22401: ARRAY
22402: PPUSH
22403: LD_INT 25
22405: PUSH
22406: LD_INT 3
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: PPUSH
22413: CALL_OW 72
22417: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22418: LD_ADDR_VAR 0 8
22422: PUSH
22423: LD_EXP 50
22427: PUSH
22428: LD_VAR 0 1
22432: ARRAY
22433: PPUSH
22434: LD_INT 25
22436: PUSH
22437: LD_INT 4
22439: PUSH
22440: EMPTY
22441: LIST
22442: LIST
22443: PUSH
22444: LD_INT 24
22446: PUSH
22447: LD_INT 251
22449: PUSH
22450: EMPTY
22451: LIST
22452: LIST
22453: PUSH
22454: EMPTY
22455: LIST
22456: LIST
22457: PPUSH
22458: CALL_OW 72
22462: ST_TO_ADDR
// if mc_scan [ base ] then
22463: LD_EXP 73
22467: PUSH
22468: LD_VAR 0 1
22472: ARRAY
22473: IFFALSE 22934
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
22475: LD_ADDR_EXP 92
22479: PUSH
22480: LD_EXP 92
22484: PPUSH
22485: LD_VAR 0 1
22489: PPUSH
22490: LD_INT 4
22492: PPUSH
22493: CALL_OW 1
22497: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
22498: LD_ADDR_VAR 0 12
22502: PUSH
22503: LD_EXP 50
22507: PUSH
22508: LD_VAR 0 1
22512: ARRAY
22513: PPUSH
22514: LD_INT 2
22516: PUSH
22517: LD_INT 30
22519: PUSH
22520: LD_INT 4
22522: PUSH
22523: EMPTY
22524: LIST
22525: LIST
22526: PUSH
22527: LD_INT 30
22529: PUSH
22530: LD_INT 5
22532: PUSH
22533: EMPTY
22534: LIST
22535: LIST
22536: PUSH
22537: EMPTY
22538: LIST
22539: LIST
22540: LIST
22541: PPUSH
22542: CALL_OW 72
22546: ST_TO_ADDR
// if not b then
22547: LD_VAR 0 12
22551: NOT
22552: IFFALSE 22556
// exit ;
22554: GO 25622
// p := [ ] ;
22556: LD_ADDR_VAR 0 11
22560: PUSH
22561: EMPTY
22562: ST_TO_ADDR
// if sci >= 2 then
22563: LD_VAR 0 8
22567: PUSH
22568: LD_INT 2
22570: GREATEREQUAL
22571: IFFALSE 22602
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
22573: LD_ADDR_VAR 0 8
22577: PUSH
22578: LD_VAR 0 8
22582: PUSH
22583: LD_INT 1
22585: ARRAY
22586: PUSH
22587: LD_VAR 0 8
22591: PUSH
22592: LD_INT 2
22594: ARRAY
22595: PUSH
22596: EMPTY
22597: LIST
22598: LIST
22599: ST_TO_ADDR
22600: GO 22663
// if sci = 1 then
22602: LD_VAR 0 8
22606: PUSH
22607: LD_INT 1
22609: EQUAL
22610: IFFALSE 22631
// sci := [ sci [ 1 ] ] else
22612: LD_ADDR_VAR 0 8
22616: PUSH
22617: LD_VAR 0 8
22621: PUSH
22622: LD_INT 1
22624: ARRAY
22625: PUSH
22626: EMPTY
22627: LIST
22628: ST_TO_ADDR
22629: GO 22663
// if sci = 0 then
22631: LD_VAR 0 8
22635: PUSH
22636: LD_INT 0
22638: EQUAL
22639: IFFALSE 22663
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
22641: LD_ADDR_VAR 0 11
22645: PUSH
22646: LD_VAR 0 4
22650: PPUSH
22651: LD_INT 4
22653: PPUSH
22654: CALL 81916 0 2
22658: PUSH
22659: LD_INT 1
22661: ARRAY
22662: ST_TO_ADDR
// if eng > 4 then
22663: LD_VAR 0 6
22667: PUSH
22668: LD_INT 4
22670: GREATER
22671: IFFALSE 22717
// for i = eng downto 4 do
22673: LD_ADDR_VAR 0 3
22677: PUSH
22678: DOUBLE
22679: LD_VAR 0 6
22683: INC
22684: ST_TO_ADDR
22685: LD_INT 4
22687: PUSH
22688: FOR_DOWNTO
22689: IFFALSE 22715
// eng := eng diff eng [ i ] ;
22691: LD_ADDR_VAR 0 6
22695: PUSH
22696: LD_VAR 0 6
22700: PUSH
22701: LD_VAR 0 6
22705: PUSH
22706: LD_VAR 0 3
22710: ARRAY
22711: DIFF
22712: ST_TO_ADDR
22713: GO 22688
22715: POP
22716: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
22717: LD_ADDR_VAR 0 4
22721: PUSH
22722: LD_VAR 0 4
22726: PUSH
22727: LD_VAR 0 5
22731: PUSH
22732: LD_VAR 0 6
22736: UNION
22737: PUSH
22738: LD_VAR 0 7
22742: UNION
22743: PUSH
22744: LD_VAR 0 8
22748: UNION
22749: DIFF
22750: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
22751: LD_ADDR_VAR 0 13
22755: PUSH
22756: LD_EXP 50
22760: PUSH
22761: LD_VAR 0 1
22765: ARRAY
22766: PPUSH
22767: LD_INT 2
22769: PUSH
22770: LD_INT 30
22772: PUSH
22773: LD_INT 32
22775: PUSH
22776: EMPTY
22777: LIST
22778: LIST
22779: PUSH
22780: LD_INT 30
22782: PUSH
22783: LD_INT 31
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: LIST
22794: PPUSH
22795: CALL_OW 72
22799: PUSH
22800: LD_EXP 50
22804: PUSH
22805: LD_VAR 0 1
22809: ARRAY
22810: PPUSH
22811: LD_INT 2
22813: PUSH
22814: LD_INT 30
22816: PUSH
22817: LD_INT 4
22819: PUSH
22820: EMPTY
22821: LIST
22822: LIST
22823: PUSH
22824: LD_INT 30
22826: PUSH
22827: LD_INT 5
22829: PUSH
22830: EMPTY
22831: LIST
22832: LIST
22833: PUSH
22834: EMPTY
22835: LIST
22836: LIST
22837: LIST
22838: PPUSH
22839: CALL_OW 72
22843: PUSH
22844: LD_INT 6
22846: MUL
22847: PLUS
22848: ST_TO_ADDR
// if bcount < tmp then
22849: LD_VAR 0 13
22853: PUSH
22854: LD_VAR 0 4
22858: LESS
22859: IFFALSE 22905
// for i = tmp downto bcount do
22861: LD_ADDR_VAR 0 3
22865: PUSH
22866: DOUBLE
22867: LD_VAR 0 4
22871: INC
22872: ST_TO_ADDR
22873: LD_VAR 0 13
22877: PUSH
22878: FOR_DOWNTO
22879: IFFALSE 22903
// tmp := Delete ( tmp , tmp ) ;
22881: LD_ADDR_VAR 0 4
22885: PUSH
22886: LD_VAR 0 4
22890: PPUSH
22891: LD_VAR 0 4
22895: PPUSH
22896: CALL_OW 3
22900: ST_TO_ADDR
22901: GO 22878
22903: POP
22904: POP
// result := [ tmp , 0 , 0 , p ] ;
22905: LD_ADDR_VAR 0 2
22909: PUSH
22910: LD_VAR 0 4
22914: PUSH
22915: LD_INT 0
22917: PUSH
22918: LD_INT 0
22920: PUSH
22921: LD_VAR 0 11
22925: PUSH
22926: EMPTY
22927: LIST
22928: LIST
22929: LIST
22930: LIST
22931: ST_TO_ADDR
// exit ;
22932: GO 25622
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22934: LD_EXP 50
22938: PUSH
22939: LD_VAR 0 1
22943: ARRAY
22944: PPUSH
22945: LD_INT 2
22947: PUSH
22948: LD_INT 30
22950: PUSH
22951: LD_INT 6
22953: PUSH
22954: EMPTY
22955: LIST
22956: LIST
22957: PUSH
22958: LD_INT 30
22960: PUSH
22961: LD_INT 7
22963: PUSH
22964: EMPTY
22965: LIST
22966: LIST
22967: PUSH
22968: LD_INT 30
22970: PUSH
22971: LD_INT 8
22973: PUSH
22974: EMPTY
22975: LIST
22976: LIST
22977: PUSH
22978: EMPTY
22979: LIST
22980: LIST
22981: LIST
22982: LIST
22983: PPUSH
22984: CALL_OW 72
22988: NOT
22989: PUSH
22990: LD_EXP 50
22994: PUSH
22995: LD_VAR 0 1
22999: ARRAY
23000: PPUSH
23001: LD_INT 30
23003: PUSH
23004: LD_INT 3
23006: PUSH
23007: EMPTY
23008: LIST
23009: LIST
23010: PPUSH
23011: CALL_OW 72
23015: NOT
23016: AND
23017: IFFALSE 23089
// begin if eng = tmp then
23019: LD_VAR 0 6
23023: PUSH
23024: LD_VAR 0 4
23028: EQUAL
23029: IFFALSE 23033
// exit ;
23031: GO 25622
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23033: LD_ADDR_EXP 92
23037: PUSH
23038: LD_EXP 92
23042: PPUSH
23043: LD_VAR 0 1
23047: PPUSH
23048: LD_INT 1
23050: PPUSH
23051: CALL_OW 1
23055: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23056: LD_ADDR_VAR 0 2
23060: PUSH
23061: LD_INT 0
23063: PUSH
23064: LD_VAR 0 4
23068: PUSH
23069: LD_VAR 0 6
23073: DIFF
23074: PUSH
23075: LD_INT 0
23077: PUSH
23078: LD_INT 0
23080: PUSH
23081: EMPTY
23082: LIST
23083: LIST
23084: LIST
23085: LIST
23086: ST_TO_ADDR
// exit ;
23087: GO 25622
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23089: LD_EXP 77
23093: PUSH
23094: LD_EXP 76
23098: PUSH
23099: LD_VAR 0 1
23103: ARRAY
23104: ARRAY
23105: PUSH
23106: LD_EXP 50
23110: PUSH
23111: LD_VAR 0 1
23115: ARRAY
23116: PPUSH
23117: LD_INT 2
23119: PUSH
23120: LD_INT 30
23122: PUSH
23123: LD_INT 6
23125: PUSH
23126: EMPTY
23127: LIST
23128: LIST
23129: PUSH
23130: LD_INT 30
23132: PUSH
23133: LD_INT 7
23135: PUSH
23136: EMPTY
23137: LIST
23138: LIST
23139: PUSH
23140: LD_INT 30
23142: PUSH
23143: LD_INT 8
23145: PUSH
23146: EMPTY
23147: LIST
23148: LIST
23149: PUSH
23150: EMPTY
23151: LIST
23152: LIST
23153: LIST
23154: LIST
23155: PPUSH
23156: CALL_OW 72
23160: AND
23161: PUSH
23162: LD_EXP 50
23166: PUSH
23167: LD_VAR 0 1
23171: ARRAY
23172: PPUSH
23173: LD_INT 30
23175: PUSH
23176: LD_INT 3
23178: PUSH
23179: EMPTY
23180: LIST
23181: LIST
23182: PPUSH
23183: CALL_OW 72
23187: NOT
23188: AND
23189: IFFALSE 23403
// begin if sci >= 6 then
23191: LD_VAR 0 8
23195: PUSH
23196: LD_INT 6
23198: GREATEREQUAL
23199: IFFALSE 23203
// exit ;
23201: GO 25622
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23203: LD_ADDR_EXP 92
23207: PUSH
23208: LD_EXP 92
23212: PPUSH
23213: LD_VAR 0 1
23217: PPUSH
23218: LD_INT 2
23220: PPUSH
23221: CALL_OW 1
23225: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23226: LD_ADDR_VAR 0 9
23230: PUSH
23231: LD_VAR 0 4
23235: PUSH
23236: LD_VAR 0 8
23240: DIFF
23241: PPUSH
23242: LD_INT 4
23244: PPUSH
23245: CALL 81916 0 2
23249: ST_TO_ADDR
// p := [ ] ;
23250: LD_ADDR_VAR 0 11
23254: PUSH
23255: EMPTY
23256: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23257: LD_VAR 0 8
23261: PUSH
23262: LD_INT 6
23264: LESS
23265: PUSH
23266: LD_VAR 0 9
23270: PUSH
23271: LD_INT 6
23273: GREATER
23274: AND
23275: IFFALSE 23356
// begin for i = 1 to 6 - sci do
23277: LD_ADDR_VAR 0 3
23281: PUSH
23282: DOUBLE
23283: LD_INT 1
23285: DEC
23286: ST_TO_ADDR
23287: LD_INT 6
23289: PUSH
23290: LD_VAR 0 8
23294: MINUS
23295: PUSH
23296: FOR_TO
23297: IFFALSE 23352
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23299: LD_ADDR_VAR 0 11
23303: PUSH
23304: LD_VAR 0 11
23308: PPUSH
23309: LD_VAR 0 11
23313: PUSH
23314: LD_INT 1
23316: PLUS
23317: PPUSH
23318: LD_VAR 0 9
23322: PUSH
23323: LD_INT 1
23325: ARRAY
23326: PPUSH
23327: CALL_OW 2
23331: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23332: LD_ADDR_VAR 0 9
23336: PUSH
23337: LD_VAR 0 9
23341: PPUSH
23342: LD_INT 1
23344: PPUSH
23345: CALL_OW 3
23349: ST_TO_ADDR
// end ;
23350: GO 23296
23352: POP
23353: POP
// end else
23354: GO 23376
// if sort then
23356: LD_VAR 0 9
23360: IFFALSE 23376
// p := sort [ 1 ] ;
23362: LD_ADDR_VAR 0 11
23366: PUSH
23367: LD_VAR 0 9
23371: PUSH
23372: LD_INT 1
23374: ARRAY
23375: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23376: LD_ADDR_VAR 0 2
23380: PUSH
23381: LD_INT 0
23383: PUSH
23384: LD_INT 0
23386: PUSH
23387: LD_INT 0
23389: PUSH
23390: LD_VAR 0 11
23394: PUSH
23395: EMPTY
23396: LIST
23397: LIST
23398: LIST
23399: LIST
23400: ST_TO_ADDR
// exit ;
23401: GO 25622
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23403: LD_EXP 77
23407: PUSH
23408: LD_EXP 76
23412: PUSH
23413: LD_VAR 0 1
23417: ARRAY
23418: ARRAY
23419: PUSH
23420: LD_EXP 50
23424: PUSH
23425: LD_VAR 0 1
23429: ARRAY
23430: PPUSH
23431: LD_INT 2
23433: PUSH
23434: LD_INT 30
23436: PUSH
23437: LD_INT 6
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: PUSH
23444: LD_INT 30
23446: PUSH
23447: LD_INT 7
23449: PUSH
23450: EMPTY
23451: LIST
23452: LIST
23453: PUSH
23454: LD_INT 30
23456: PUSH
23457: LD_INT 8
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: LIST
23468: LIST
23469: PPUSH
23470: CALL_OW 72
23474: AND
23475: PUSH
23476: LD_EXP 50
23480: PUSH
23481: LD_VAR 0 1
23485: ARRAY
23486: PPUSH
23487: LD_INT 30
23489: PUSH
23490: LD_INT 3
23492: PUSH
23493: EMPTY
23494: LIST
23495: LIST
23496: PPUSH
23497: CALL_OW 72
23501: AND
23502: IFFALSE 24236
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
23504: LD_ADDR_EXP 92
23508: PUSH
23509: LD_EXP 92
23513: PPUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: LD_INT 3
23521: PPUSH
23522: CALL_OW 1
23526: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23527: LD_ADDR_VAR 0 2
23531: PUSH
23532: LD_INT 0
23534: PUSH
23535: LD_INT 0
23537: PUSH
23538: LD_INT 0
23540: PUSH
23541: LD_INT 0
23543: PUSH
23544: EMPTY
23545: LIST
23546: LIST
23547: LIST
23548: LIST
23549: ST_TO_ADDR
// if not eng then
23550: LD_VAR 0 6
23554: NOT
23555: IFFALSE 23618
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
23557: LD_ADDR_VAR 0 11
23561: PUSH
23562: LD_VAR 0 4
23566: PPUSH
23567: LD_INT 2
23569: PPUSH
23570: CALL 81916 0 2
23574: PUSH
23575: LD_INT 1
23577: ARRAY
23578: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
23579: LD_ADDR_VAR 0 2
23583: PUSH
23584: LD_VAR 0 2
23588: PPUSH
23589: LD_INT 2
23591: PPUSH
23592: LD_VAR 0 11
23596: PPUSH
23597: CALL_OW 1
23601: ST_TO_ADDR
// tmp := tmp diff p ;
23602: LD_ADDR_VAR 0 4
23606: PUSH
23607: LD_VAR 0 4
23611: PUSH
23612: LD_VAR 0 11
23616: DIFF
23617: ST_TO_ADDR
// end ; if tmp and sci < 6 then
23618: LD_VAR 0 4
23622: PUSH
23623: LD_VAR 0 8
23627: PUSH
23628: LD_INT 6
23630: LESS
23631: AND
23632: IFFALSE 23820
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
23634: LD_ADDR_VAR 0 9
23638: PUSH
23639: LD_VAR 0 4
23643: PUSH
23644: LD_VAR 0 8
23648: PUSH
23649: LD_VAR 0 7
23653: UNION
23654: DIFF
23655: PPUSH
23656: LD_INT 4
23658: PPUSH
23659: CALL 81916 0 2
23663: ST_TO_ADDR
// p := [ ] ;
23664: LD_ADDR_VAR 0 11
23668: PUSH
23669: EMPTY
23670: ST_TO_ADDR
// if sort then
23671: LD_VAR 0 9
23675: IFFALSE 23791
// for i = 1 to 6 - sci do
23677: LD_ADDR_VAR 0 3
23681: PUSH
23682: DOUBLE
23683: LD_INT 1
23685: DEC
23686: ST_TO_ADDR
23687: LD_INT 6
23689: PUSH
23690: LD_VAR 0 8
23694: MINUS
23695: PUSH
23696: FOR_TO
23697: IFFALSE 23789
// begin if i = sort then
23699: LD_VAR 0 3
23703: PUSH
23704: LD_VAR 0 9
23708: EQUAL
23709: IFFALSE 23713
// break ;
23711: GO 23789
// if GetClass ( i ) = 4 then
23713: LD_VAR 0 3
23717: PPUSH
23718: CALL_OW 257
23722: PUSH
23723: LD_INT 4
23725: EQUAL
23726: IFFALSE 23730
// continue ;
23728: GO 23696
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23730: LD_ADDR_VAR 0 11
23734: PUSH
23735: LD_VAR 0 11
23739: PPUSH
23740: LD_VAR 0 11
23744: PUSH
23745: LD_INT 1
23747: PLUS
23748: PPUSH
23749: LD_VAR 0 9
23753: PUSH
23754: LD_VAR 0 3
23758: ARRAY
23759: PPUSH
23760: CALL_OW 2
23764: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23765: LD_ADDR_VAR 0 4
23769: PUSH
23770: LD_VAR 0 4
23774: PUSH
23775: LD_VAR 0 9
23779: PUSH
23780: LD_VAR 0 3
23784: ARRAY
23785: DIFF
23786: ST_TO_ADDR
// end ;
23787: GO 23696
23789: POP
23790: POP
// if p then
23791: LD_VAR 0 11
23795: IFFALSE 23820
// result := Replace ( result , 4 , p ) ;
23797: LD_ADDR_VAR 0 2
23801: PUSH
23802: LD_VAR 0 2
23806: PPUSH
23807: LD_INT 4
23809: PPUSH
23810: LD_VAR 0 11
23814: PPUSH
23815: CALL_OW 1
23819: ST_TO_ADDR
// end ; if tmp and mech < 6 then
23820: LD_VAR 0 4
23824: PUSH
23825: LD_VAR 0 7
23829: PUSH
23830: LD_INT 6
23832: LESS
23833: AND
23834: IFFALSE 24022
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
23836: LD_ADDR_VAR 0 9
23840: PUSH
23841: LD_VAR 0 4
23845: PUSH
23846: LD_VAR 0 8
23850: PUSH
23851: LD_VAR 0 7
23855: UNION
23856: DIFF
23857: PPUSH
23858: LD_INT 3
23860: PPUSH
23861: CALL 81916 0 2
23865: ST_TO_ADDR
// p := [ ] ;
23866: LD_ADDR_VAR 0 11
23870: PUSH
23871: EMPTY
23872: ST_TO_ADDR
// if sort then
23873: LD_VAR 0 9
23877: IFFALSE 23993
// for i = 1 to 6 - mech do
23879: LD_ADDR_VAR 0 3
23883: PUSH
23884: DOUBLE
23885: LD_INT 1
23887: DEC
23888: ST_TO_ADDR
23889: LD_INT 6
23891: PUSH
23892: LD_VAR 0 7
23896: MINUS
23897: PUSH
23898: FOR_TO
23899: IFFALSE 23991
// begin if i = sort then
23901: LD_VAR 0 3
23905: PUSH
23906: LD_VAR 0 9
23910: EQUAL
23911: IFFALSE 23915
// break ;
23913: GO 23991
// if GetClass ( i ) = 3 then
23915: LD_VAR 0 3
23919: PPUSH
23920: CALL_OW 257
23924: PUSH
23925: LD_INT 3
23927: EQUAL
23928: IFFALSE 23932
// continue ;
23930: GO 23898
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23932: LD_ADDR_VAR 0 11
23936: PUSH
23937: LD_VAR 0 11
23941: PPUSH
23942: LD_VAR 0 11
23946: PUSH
23947: LD_INT 1
23949: PLUS
23950: PPUSH
23951: LD_VAR 0 9
23955: PUSH
23956: LD_VAR 0 3
23960: ARRAY
23961: PPUSH
23962: CALL_OW 2
23966: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23967: LD_ADDR_VAR 0 4
23971: PUSH
23972: LD_VAR 0 4
23976: PUSH
23977: LD_VAR 0 9
23981: PUSH
23982: LD_VAR 0 3
23986: ARRAY
23987: DIFF
23988: ST_TO_ADDR
// end ;
23989: GO 23898
23991: POP
23992: POP
// if p then
23993: LD_VAR 0 11
23997: IFFALSE 24022
// result := Replace ( result , 3 , p ) ;
23999: LD_ADDR_VAR 0 2
24003: PUSH
24004: LD_VAR 0 2
24008: PPUSH
24009: LD_INT 3
24011: PPUSH
24012: LD_VAR 0 11
24016: PPUSH
24017: CALL_OW 1
24021: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24022: LD_VAR 0 4
24026: PUSH
24027: LD_INT 6
24029: GREATER
24030: PUSH
24031: LD_VAR 0 6
24035: PUSH
24036: LD_INT 6
24038: LESS
24039: AND
24040: IFFALSE 24234
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24042: LD_ADDR_VAR 0 9
24046: PUSH
24047: LD_VAR 0 4
24051: PUSH
24052: LD_VAR 0 8
24056: PUSH
24057: LD_VAR 0 7
24061: UNION
24062: PUSH
24063: LD_VAR 0 6
24067: UNION
24068: DIFF
24069: PPUSH
24070: LD_INT 2
24072: PPUSH
24073: CALL 81916 0 2
24077: ST_TO_ADDR
// p := [ ] ;
24078: LD_ADDR_VAR 0 11
24082: PUSH
24083: EMPTY
24084: ST_TO_ADDR
// if sort then
24085: LD_VAR 0 9
24089: IFFALSE 24205
// for i = 1 to 6 - eng do
24091: LD_ADDR_VAR 0 3
24095: PUSH
24096: DOUBLE
24097: LD_INT 1
24099: DEC
24100: ST_TO_ADDR
24101: LD_INT 6
24103: PUSH
24104: LD_VAR 0 6
24108: MINUS
24109: PUSH
24110: FOR_TO
24111: IFFALSE 24203
// begin if i = sort then
24113: LD_VAR 0 3
24117: PUSH
24118: LD_VAR 0 9
24122: EQUAL
24123: IFFALSE 24127
// break ;
24125: GO 24203
// if GetClass ( i ) = 2 then
24127: LD_VAR 0 3
24131: PPUSH
24132: CALL_OW 257
24136: PUSH
24137: LD_INT 2
24139: EQUAL
24140: IFFALSE 24144
// continue ;
24142: GO 24110
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24144: LD_ADDR_VAR 0 11
24148: PUSH
24149: LD_VAR 0 11
24153: PPUSH
24154: LD_VAR 0 11
24158: PUSH
24159: LD_INT 1
24161: PLUS
24162: PPUSH
24163: LD_VAR 0 9
24167: PUSH
24168: LD_VAR 0 3
24172: ARRAY
24173: PPUSH
24174: CALL_OW 2
24178: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24179: LD_ADDR_VAR 0 4
24183: PUSH
24184: LD_VAR 0 4
24188: PUSH
24189: LD_VAR 0 9
24193: PUSH
24194: LD_VAR 0 3
24198: ARRAY
24199: DIFF
24200: ST_TO_ADDR
// end ;
24201: GO 24110
24203: POP
24204: POP
// if p then
24205: LD_VAR 0 11
24209: IFFALSE 24234
// result := Replace ( result , 2 , p ) ;
24211: LD_ADDR_VAR 0 2
24215: PUSH
24216: LD_VAR 0 2
24220: PPUSH
24221: LD_INT 2
24223: PPUSH
24224: LD_VAR 0 11
24228: PPUSH
24229: CALL_OW 1
24233: ST_TO_ADDR
// end ; exit ;
24234: GO 25622
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24236: LD_EXP 77
24240: PUSH
24241: LD_EXP 76
24245: PUSH
24246: LD_VAR 0 1
24250: ARRAY
24251: ARRAY
24252: NOT
24253: PUSH
24254: LD_EXP 50
24258: PUSH
24259: LD_VAR 0 1
24263: ARRAY
24264: PPUSH
24265: LD_INT 30
24267: PUSH
24268: LD_INT 3
24270: PUSH
24271: EMPTY
24272: LIST
24273: LIST
24274: PPUSH
24275: CALL_OW 72
24279: AND
24280: PUSH
24281: LD_EXP 55
24285: PUSH
24286: LD_VAR 0 1
24290: ARRAY
24291: AND
24292: IFFALSE 24900
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24294: LD_ADDR_EXP 92
24298: PUSH
24299: LD_EXP 92
24303: PPUSH
24304: LD_VAR 0 1
24308: PPUSH
24309: LD_INT 5
24311: PPUSH
24312: CALL_OW 1
24316: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24317: LD_ADDR_VAR 0 2
24321: PUSH
24322: LD_INT 0
24324: PUSH
24325: LD_INT 0
24327: PUSH
24328: LD_INT 0
24330: PUSH
24331: LD_INT 0
24333: PUSH
24334: EMPTY
24335: LIST
24336: LIST
24337: LIST
24338: LIST
24339: ST_TO_ADDR
// if sci > 1 then
24340: LD_VAR 0 8
24344: PUSH
24345: LD_INT 1
24347: GREATER
24348: IFFALSE 24376
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24350: LD_ADDR_VAR 0 4
24354: PUSH
24355: LD_VAR 0 4
24359: PUSH
24360: LD_VAR 0 8
24364: PUSH
24365: LD_VAR 0 8
24369: PUSH
24370: LD_INT 1
24372: ARRAY
24373: DIFF
24374: DIFF
24375: ST_TO_ADDR
// if tmp and not sci then
24376: LD_VAR 0 4
24380: PUSH
24381: LD_VAR 0 8
24385: NOT
24386: AND
24387: IFFALSE 24456
// begin sort := SortBySkill ( tmp , 4 ) ;
24389: LD_ADDR_VAR 0 9
24393: PUSH
24394: LD_VAR 0 4
24398: PPUSH
24399: LD_INT 4
24401: PPUSH
24402: CALL 81916 0 2
24406: ST_TO_ADDR
// if sort then
24407: LD_VAR 0 9
24411: IFFALSE 24427
// p := sort [ 1 ] ;
24413: LD_ADDR_VAR 0 11
24417: PUSH
24418: LD_VAR 0 9
24422: PUSH
24423: LD_INT 1
24425: ARRAY
24426: ST_TO_ADDR
// if p then
24427: LD_VAR 0 11
24431: IFFALSE 24456
// result := Replace ( result , 4 , p ) ;
24433: LD_ADDR_VAR 0 2
24437: PUSH
24438: LD_VAR 0 2
24442: PPUSH
24443: LD_INT 4
24445: PPUSH
24446: LD_VAR 0 11
24450: PPUSH
24451: CALL_OW 1
24455: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24456: LD_ADDR_VAR 0 4
24460: PUSH
24461: LD_VAR 0 4
24465: PUSH
24466: LD_VAR 0 7
24470: DIFF
24471: ST_TO_ADDR
// if tmp and mech < 6 then
24472: LD_VAR 0 4
24476: PUSH
24477: LD_VAR 0 7
24481: PUSH
24482: LD_INT 6
24484: LESS
24485: AND
24486: IFFALSE 24674
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24488: LD_ADDR_VAR 0 9
24492: PUSH
24493: LD_VAR 0 4
24497: PUSH
24498: LD_VAR 0 8
24502: PUSH
24503: LD_VAR 0 7
24507: UNION
24508: DIFF
24509: PPUSH
24510: LD_INT 3
24512: PPUSH
24513: CALL 81916 0 2
24517: ST_TO_ADDR
// p := [ ] ;
24518: LD_ADDR_VAR 0 11
24522: PUSH
24523: EMPTY
24524: ST_TO_ADDR
// if sort then
24525: LD_VAR 0 9
24529: IFFALSE 24645
// for i = 1 to 6 - mech do
24531: LD_ADDR_VAR 0 3
24535: PUSH
24536: DOUBLE
24537: LD_INT 1
24539: DEC
24540: ST_TO_ADDR
24541: LD_INT 6
24543: PUSH
24544: LD_VAR 0 7
24548: MINUS
24549: PUSH
24550: FOR_TO
24551: IFFALSE 24643
// begin if i = sort then
24553: LD_VAR 0 3
24557: PUSH
24558: LD_VAR 0 9
24562: EQUAL
24563: IFFALSE 24567
// break ;
24565: GO 24643
// if GetClass ( i ) = 3 then
24567: LD_VAR 0 3
24571: PPUSH
24572: CALL_OW 257
24576: PUSH
24577: LD_INT 3
24579: EQUAL
24580: IFFALSE 24584
// continue ;
24582: GO 24550
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24584: LD_ADDR_VAR 0 11
24588: PUSH
24589: LD_VAR 0 11
24593: PPUSH
24594: LD_VAR 0 11
24598: PUSH
24599: LD_INT 1
24601: PLUS
24602: PPUSH
24603: LD_VAR 0 9
24607: PUSH
24608: LD_VAR 0 3
24612: ARRAY
24613: PPUSH
24614: CALL_OW 2
24618: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24619: LD_ADDR_VAR 0 4
24623: PUSH
24624: LD_VAR 0 4
24628: PUSH
24629: LD_VAR 0 9
24633: PUSH
24634: LD_VAR 0 3
24638: ARRAY
24639: DIFF
24640: ST_TO_ADDR
// end ;
24641: GO 24550
24643: POP
24644: POP
// if p then
24645: LD_VAR 0 11
24649: IFFALSE 24674
// result := Replace ( result , 3 , p ) ;
24651: LD_ADDR_VAR 0 2
24655: PUSH
24656: LD_VAR 0 2
24660: PPUSH
24661: LD_INT 3
24663: PPUSH
24664: LD_VAR 0 11
24668: PPUSH
24669: CALL_OW 1
24673: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
24674: LD_ADDR_VAR 0 4
24678: PUSH
24679: LD_VAR 0 4
24683: PUSH
24684: LD_VAR 0 6
24688: DIFF
24689: ST_TO_ADDR
// if tmp and eng < 6 then
24690: LD_VAR 0 4
24694: PUSH
24695: LD_VAR 0 6
24699: PUSH
24700: LD_INT 6
24702: LESS
24703: AND
24704: IFFALSE 24898
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24706: LD_ADDR_VAR 0 9
24710: PUSH
24711: LD_VAR 0 4
24715: PUSH
24716: LD_VAR 0 8
24720: PUSH
24721: LD_VAR 0 7
24725: UNION
24726: PUSH
24727: LD_VAR 0 6
24731: UNION
24732: DIFF
24733: PPUSH
24734: LD_INT 2
24736: PPUSH
24737: CALL 81916 0 2
24741: ST_TO_ADDR
// p := [ ] ;
24742: LD_ADDR_VAR 0 11
24746: PUSH
24747: EMPTY
24748: ST_TO_ADDR
// if sort then
24749: LD_VAR 0 9
24753: IFFALSE 24869
// for i = 1 to 6 - eng do
24755: LD_ADDR_VAR 0 3
24759: PUSH
24760: DOUBLE
24761: LD_INT 1
24763: DEC
24764: ST_TO_ADDR
24765: LD_INT 6
24767: PUSH
24768: LD_VAR 0 6
24772: MINUS
24773: PUSH
24774: FOR_TO
24775: IFFALSE 24867
// begin if i = sort then
24777: LD_VAR 0 3
24781: PUSH
24782: LD_VAR 0 9
24786: EQUAL
24787: IFFALSE 24791
// break ;
24789: GO 24867
// if GetClass ( i ) = 2 then
24791: LD_VAR 0 3
24795: PPUSH
24796: CALL_OW 257
24800: PUSH
24801: LD_INT 2
24803: EQUAL
24804: IFFALSE 24808
// continue ;
24806: GO 24774
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24808: LD_ADDR_VAR 0 11
24812: PUSH
24813: LD_VAR 0 11
24817: PPUSH
24818: LD_VAR 0 11
24822: PUSH
24823: LD_INT 1
24825: PLUS
24826: PPUSH
24827: LD_VAR 0 9
24831: PUSH
24832: LD_VAR 0 3
24836: ARRAY
24837: PPUSH
24838: CALL_OW 2
24842: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24843: LD_ADDR_VAR 0 4
24847: PUSH
24848: LD_VAR 0 4
24852: PUSH
24853: LD_VAR 0 9
24857: PUSH
24858: LD_VAR 0 3
24862: ARRAY
24863: DIFF
24864: ST_TO_ADDR
// end ;
24865: GO 24774
24867: POP
24868: POP
// if p then
24869: LD_VAR 0 11
24873: IFFALSE 24898
// result := Replace ( result , 2 , p ) ;
24875: LD_ADDR_VAR 0 2
24879: PUSH
24880: LD_VAR 0 2
24884: PPUSH
24885: LD_INT 2
24887: PPUSH
24888: LD_VAR 0 11
24892: PPUSH
24893: CALL_OW 1
24897: ST_TO_ADDR
// end ; exit ;
24898: GO 25622
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
24900: LD_EXP 77
24904: PUSH
24905: LD_EXP 76
24909: PUSH
24910: LD_VAR 0 1
24914: ARRAY
24915: ARRAY
24916: NOT
24917: PUSH
24918: LD_EXP 50
24922: PUSH
24923: LD_VAR 0 1
24927: ARRAY
24928: PPUSH
24929: LD_INT 30
24931: PUSH
24932: LD_INT 3
24934: PUSH
24935: EMPTY
24936: LIST
24937: LIST
24938: PPUSH
24939: CALL_OW 72
24943: AND
24944: PUSH
24945: LD_EXP 55
24949: PUSH
24950: LD_VAR 0 1
24954: ARRAY
24955: NOT
24956: AND
24957: IFFALSE 25622
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
24959: LD_ADDR_EXP 92
24963: PUSH
24964: LD_EXP 92
24968: PPUSH
24969: LD_VAR 0 1
24973: PPUSH
24974: LD_INT 6
24976: PPUSH
24977: CALL_OW 1
24981: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24982: LD_ADDR_VAR 0 2
24986: PUSH
24987: LD_INT 0
24989: PUSH
24990: LD_INT 0
24992: PUSH
24993: LD_INT 0
24995: PUSH
24996: LD_INT 0
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: LIST
25003: LIST
25004: ST_TO_ADDR
// if sci >= 1 then
25005: LD_VAR 0 8
25009: PUSH
25010: LD_INT 1
25012: GREATEREQUAL
25013: IFFALSE 25035
// tmp := tmp diff sci [ 1 ] ;
25015: LD_ADDR_VAR 0 4
25019: PUSH
25020: LD_VAR 0 4
25024: PUSH
25025: LD_VAR 0 8
25029: PUSH
25030: LD_INT 1
25032: ARRAY
25033: DIFF
25034: ST_TO_ADDR
// if tmp and not sci then
25035: LD_VAR 0 4
25039: PUSH
25040: LD_VAR 0 8
25044: NOT
25045: AND
25046: IFFALSE 25115
// begin sort := SortBySkill ( tmp , 4 ) ;
25048: LD_ADDR_VAR 0 9
25052: PUSH
25053: LD_VAR 0 4
25057: PPUSH
25058: LD_INT 4
25060: PPUSH
25061: CALL 81916 0 2
25065: ST_TO_ADDR
// if sort then
25066: LD_VAR 0 9
25070: IFFALSE 25086
// p := sort [ 1 ] ;
25072: LD_ADDR_VAR 0 11
25076: PUSH
25077: LD_VAR 0 9
25081: PUSH
25082: LD_INT 1
25084: ARRAY
25085: ST_TO_ADDR
// if p then
25086: LD_VAR 0 11
25090: IFFALSE 25115
// result := Replace ( result , 4 , p ) ;
25092: LD_ADDR_VAR 0 2
25096: PUSH
25097: LD_VAR 0 2
25101: PPUSH
25102: LD_INT 4
25104: PPUSH
25105: LD_VAR 0 11
25109: PPUSH
25110: CALL_OW 1
25114: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25115: LD_ADDR_VAR 0 4
25119: PUSH
25120: LD_VAR 0 4
25124: PUSH
25125: LD_VAR 0 7
25129: DIFF
25130: ST_TO_ADDR
// if tmp and mech < 6 then
25131: LD_VAR 0 4
25135: PUSH
25136: LD_VAR 0 7
25140: PUSH
25141: LD_INT 6
25143: LESS
25144: AND
25145: IFFALSE 25327
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25147: LD_ADDR_VAR 0 9
25151: PUSH
25152: LD_VAR 0 4
25156: PUSH
25157: LD_VAR 0 7
25161: DIFF
25162: PPUSH
25163: LD_INT 3
25165: PPUSH
25166: CALL 81916 0 2
25170: ST_TO_ADDR
// p := [ ] ;
25171: LD_ADDR_VAR 0 11
25175: PUSH
25176: EMPTY
25177: ST_TO_ADDR
// if sort then
25178: LD_VAR 0 9
25182: IFFALSE 25298
// for i = 1 to 6 - mech do
25184: LD_ADDR_VAR 0 3
25188: PUSH
25189: DOUBLE
25190: LD_INT 1
25192: DEC
25193: ST_TO_ADDR
25194: LD_INT 6
25196: PUSH
25197: LD_VAR 0 7
25201: MINUS
25202: PUSH
25203: FOR_TO
25204: IFFALSE 25296
// begin if i = sort then
25206: LD_VAR 0 3
25210: PUSH
25211: LD_VAR 0 9
25215: EQUAL
25216: IFFALSE 25220
// break ;
25218: GO 25296
// if GetClass ( i ) = 3 then
25220: LD_VAR 0 3
25224: PPUSH
25225: CALL_OW 257
25229: PUSH
25230: LD_INT 3
25232: EQUAL
25233: IFFALSE 25237
// continue ;
25235: GO 25203
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25237: LD_ADDR_VAR 0 11
25241: PUSH
25242: LD_VAR 0 11
25246: PPUSH
25247: LD_VAR 0 11
25251: PUSH
25252: LD_INT 1
25254: PLUS
25255: PPUSH
25256: LD_VAR 0 9
25260: PUSH
25261: LD_VAR 0 3
25265: ARRAY
25266: PPUSH
25267: CALL_OW 2
25271: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25272: LD_ADDR_VAR 0 4
25276: PUSH
25277: LD_VAR 0 4
25281: PUSH
25282: LD_VAR 0 9
25286: PUSH
25287: LD_VAR 0 3
25291: ARRAY
25292: DIFF
25293: ST_TO_ADDR
// end ;
25294: GO 25203
25296: POP
25297: POP
// if p then
25298: LD_VAR 0 11
25302: IFFALSE 25327
// result := Replace ( result , 3 , p ) ;
25304: LD_ADDR_VAR 0 2
25308: PUSH
25309: LD_VAR 0 2
25313: PPUSH
25314: LD_INT 3
25316: PPUSH
25317: LD_VAR 0 11
25321: PPUSH
25322: CALL_OW 1
25326: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25327: LD_ADDR_VAR 0 4
25331: PUSH
25332: LD_VAR 0 4
25336: PUSH
25337: LD_VAR 0 6
25341: DIFF
25342: ST_TO_ADDR
// if tmp and eng < 4 then
25343: LD_VAR 0 4
25347: PUSH
25348: LD_VAR 0 6
25352: PUSH
25353: LD_INT 4
25355: LESS
25356: AND
25357: IFFALSE 25547
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25359: LD_ADDR_VAR 0 9
25363: PUSH
25364: LD_VAR 0 4
25368: PUSH
25369: LD_VAR 0 7
25373: PUSH
25374: LD_VAR 0 6
25378: UNION
25379: DIFF
25380: PPUSH
25381: LD_INT 2
25383: PPUSH
25384: CALL 81916 0 2
25388: ST_TO_ADDR
// p := [ ] ;
25389: LD_ADDR_VAR 0 11
25393: PUSH
25394: EMPTY
25395: ST_TO_ADDR
// if sort then
25396: LD_VAR 0 9
25400: IFFALSE 25516
// for i = 1 to 4 - eng do
25402: LD_ADDR_VAR 0 3
25406: PUSH
25407: DOUBLE
25408: LD_INT 1
25410: DEC
25411: ST_TO_ADDR
25412: LD_INT 4
25414: PUSH
25415: LD_VAR 0 6
25419: MINUS
25420: PUSH
25421: FOR_TO
25422: IFFALSE 25514
// begin if i = sort then
25424: LD_VAR 0 3
25428: PUSH
25429: LD_VAR 0 9
25433: EQUAL
25434: IFFALSE 25438
// break ;
25436: GO 25514
// if GetClass ( i ) = 2 then
25438: LD_VAR 0 3
25442: PPUSH
25443: CALL_OW 257
25447: PUSH
25448: LD_INT 2
25450: EQUAL
25451: IFFALSE 25455
// continue ;
25453: GO 25421
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25455: LD_ADDR_VAR 0 11
25459: PUSH
25460: LD_VAR 0 11
25464: PPUSH
25465: LD_VAR 0 11
25469: PUSH
25470: LD_INT 1
25472: PLUS
25473: PPUSH
25474: LD_VAR 0 9
25478: PUSH
25479: LD_VAR 0 3
25483: ARRAY
25484: PPUSH
25485: CALL_OW 2
25489: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25490: LD_ADDR_VAR 0 4
25494: PUSH
25495: LD_VAR 0 4
25499: PUSH
25500: LD_VAR 0 9
25504: PUSH
25505: LD_VAR 0 3
25509: ARRAY
25510: DIFF
25511: ST_TO_ADDR
// end ;
25512: GO 25421
25514: POP
25515: POP
// if p then
25516: LD_VAR 0 11
25520: IFFALSE 25545
// result := Replace ( result , 2 , p ) ;
25522: LD_ADDR_VAR 0 2
25526: PUSH
25527: LD_VAR 0 2
25531: PPUSH
25532: LD_INT 2
25534: PPUSH
25535: LD_VAR 0 11
25539: PPUSH
25540: CALL_OW 1
25544: ST_TO_ADDR
// end else
25545: GO 25591
// for i = eng downto 5 do
25547: LD_ADDR_VAR 0 3
25551: PUSH
25552: DOUBLE
25553: LD_VAR 0 6
25557: INC
25558: ST_TO_ADDR
25559: LD_INT 5
25561: PUSH
25562: FOR_DOWNTO
25563: IFFALSE 25589
// tmp := tmp union eng [ i ] ;
25565: LD_ADDR_VAR 0 4
25569: PUSH
25570: LD_VAR 0 4
25574: PUSH
25575: LD_VAR 0 6
25579: PUSH
25580: LD_VAR 0 3
25584: ARRAY
25585: UNION
25586: ST_TO_ADDR
25587: GO 25562
25589: POP
25590: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
25591: LD_ADDR_VAR 0 2
25595: PUSH
25596: LD_VAR 0 2
25600: PPUSH
25601: LD_INT 1
25603: PPUSH
25604: LD_VAR 0 4
25608: PUSH
25609: LD_VAR 0 5
25613: DIFF
25614: PPUSH
25615: CALL_OW 1
25619: ST_TO_ADDR
// exit ;
25620: GO 25622
// end ; end ;
25622: LD_VAR 0 2
25626: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
25627: LD_INT 0
25629: PPUSH
25630: PPUSH
25631: PPUSH
// if not mc_bases then
25632: LD_EXP 50
25636: NOT
25637: IFFALSE 25641
// exit ;
25639: GO 25747
// for i = 1 to mc_bases do
25641: LD_ADDR_VAR 0 2
25645: PUSH
25646: DOUBLE
25647: LD_INT 1
25649: DEC
25650: ST_TO_ADDR
25651: LD_EXP 50
25655: PUSH
25656: FOR_TO
25657: IFFALSE 25738
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
25659: LD_ADDR_VAR 0 3
25663: PUSH
25664: LD_EXP 50
25668: PUSH
25669: LD_VAR 0 2
25673: ARRAY
25674: PPUSH
25675: LD_INT 21
25677: PUSH
25678: LD_INT 3
25680: PUSH
25681: EMPTY
25682: LIST
25683: LIST
25684: PUSH
25685: LD_INT 3
25687: PUSH
25688: LD_INT 24
25690: PUSH
25691: LD_INT 1000
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: EMPTY
25699: LIST
25700: LIST
25701: PUSH
25702: EMPTY
25703: LIST
25704: LIST
25705: PPUSH
25706: CALL_OW 72
25710: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
25711: LD_ADDR_EXP 51
25715: PUSH
25716: LD_EXP 51
25720: PPUSH
25721: LD_VAR 0 2
25725: PPUSH
25726: LD_VAR 0 3
25730: PPUSH
25731: CALL_OW 1
25735: ST_TO_ADDR
// end ;
25736: GO 25656
25738: POP
25739: POP
// RaiseSailEvent ( 101 ) ;
25740: LD_INT 101
25742: PPUSH
25743: CALL_OW 427
// end ;
25747: LD_VAR 0 1
25751: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
25752: LD_INT 0
25754: PPUSH
25755: PPUSH
25756: PPUSH
25757: PPUSH
25758: PPUSH
25759: PPUSH
25760: PPUSH
// if not mc_bases then
25761: LD_EXP 50
25765: NOT
25766: IFFALSE 25770
// exit ;
25768: GO 26343
// for i = 1 to mc_bases do
25770: LD_ADDR_VAR 0 2
25774: PUSH
25775: DOUBLE
25776: LD_INT 1
25778: DEC
25779: ST_TO_ADDR
25780: LD_EXP 50
25784: PUSH
25785: FOR_TO
25786: IFFALSE 26334
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
25788: LD_ADDR_VAR 0 5
25792: PUSH
25793: LD_EXP 50
25797: PUSH
25798: LD_VAR 0 2
25802: ARRAY
25803: PUSH
25804: LD_EXP 79
25808: PUSH
25809: LD_VAR 0 2
25813: ARRAY
25814: UNION
25815: PPUSH
25816: LD_INT 21
25818: PUSH
25819: LD_INT 1
25821: PUSH
25822: EMPTY
25823: LIST
25824: LIST
25825: PUSH
25826: LD_INT 1
25828: PUSH
25829: LD_INT 3
25831: PUSH
25832: LD_INT 54
25834: PUSH
25835: EMPTY
25836: LIST
25837: PUSH
25838: EMPTY
25839: LIST
25840: LIST
25841: PUSH
25842: LD_INT 3
25844: PUSH
25845: LD_INT 24
25847: PUSH
25848: LD_INT 800
25850: PUSH
25851: EMPTY
25852: LIST
25853: LIST
25854: PUSH
25855: EMPTY
25856: LIST
25857: LIST
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: LIST
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: PPUSH
25868: CALL_OW 72
25872: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
25873: LD_ADDR_VAR 0 6
25877: PUSH
25878: LD_EXP 50
25882: PUSH
25883: LD_VAR 0 2
25887: ARRAY
25888: PPUSH
25889: LD_INT 21
25891: PUSH
25892: LD_INT 1
25894: PUSH
25895: EMPTY
25896: LIST
25897: LIST
25898: PUSH
25899: LD_INT 1
25901: PUSH
25902: LD_INT 3
25904: PUSH
25905: LD_INT 54
25907: PUSH
25908: EMPTY
25909: LIST
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PUSH
25915: LD_INT 3
25917: PUSH
25918: LD_INT 24
25920: PUSH
25921: LD_INT 250
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: PUSH
25928: EMPTY
25929: LIST
25930: LIST
25931: PUSH
25932: EMPTY
25933: LIST
25934: LIST
25935: LIST
25936: PUSH
25937: EMPTY
25938: LIST
25939: LIST
25940: PPUSH
25941: CALL_OW 72
25945: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
25946: LD_ADDR_VAR 0 7
25950: PUSH
25951: LD_VAR 0 5
25955: PUSH
25956: LD_VAR 0 6
25960: DIFF
25961: ST_TO_ADDR
// if not need_heal_1 then
25962: LD_VAR 0 6
25966: NOT
25967: IFFALSE 26000
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
25969: LD_ADDR_EXP 53
25973: PUSH
25974: LD_EXP 53
25978: PPUSH
25979: LD_VAR 0 2
25983: PUSH
25984: LD_INT 1
25986: PUSH
25987: EMPTY
25988: LIST
25989: LIST
25990: PPUSH
25991: EMPTY
25992: PPUSH
25993: CALL 52367 0 3
25997: ST_TO_ADDR
25998: GO 26070
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26000: LD_ADDR_EXP 53
26004: PUSH
26005: LD_EXP 53
26009: PPUSH
26010: LD_VAR 0 2
26014: PUSH
26015: LD_INT 1
26017: PUSH
26018: EMPTY
26019: LIST
26020: LIST
26021: PPUSH
26022: LD_EXP 53
26026: PUSH
26027: LD_VAR 0 2
26031: ARRAY
26032: PUSH
26033: LD_INT 1
26035: ARRAY
26036: PPUSH
26037: LD_INT 3
26039: PUSH
26040: LD_INT 24
26042: PUSH
26043: LD_INT 1000
26045: PUSH
26046: EMPTY
26047: LIST
26048: LIST
26049: PUSH
26050: EMPTY
26051: LIST
26052: LIST
26053: PPUSH
26054: CALL_OW 72
26058: PUSH
26059: LD_VAR 0 6
26063: UNION
26064: PPUSH
26065: CALL 52367 0 3
26069: ST_TO_ADDR
// if not need_heal_2 then
26070: LD_VAR 0 7
26074: NOT
26075: IFFALSE 26108
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26077: LD_ADDR_EXP 53
26081: PUSH
26082: LD_EXP 53
26086: PPUSH
26087: LD_VAR 0 2
26091: PUSH
26092: LD_INT 2
26094: PUSH
26095: EMPTY
26096: LIST
26097: LIST
26098: PPUSH
26099: EMPTY
26100: PPUSH
26101: CALL 52367 0 3
26105: ST_TO_ADDR
26106: GO 26140
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26108: LD_ADDR_EXP 53
26112: PUSH
26113: LD_EXP 53
26117: PPUSH
26118: LD_VAR 0 2
26122: PUSH
26123: LD_INT 2
26125: PUSH
26126: EMPTY
26127: LIST
26128: LIST
26129: PPUSH
26130: LD_VAR 0 7
26134: PPUSH
26135: CALL 52367 0 3
26139: ST_TO_ADDR
// if need_heal_2 then
26140: LD_VAR 0 7
26144: IFFALSE 26316
// for j in need_heal_2 do
26146: LD_ADDR_VAR 0 3
26150: PUSH
26151: LD_VAR 0 7
26155: PUSH
26156: FOR_IN
26157: IFFALSE 26314
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
26159: LD_ADDR_VAR 0 5
26163: PUSH
26164: LD_EXP 50
26168: PUSH
26169: LD_VAR 0 2
26173: ARRAY
26174: PPUSH
26175: LD_INT 2
26177: PUSH
26178: LD_INT 30
26180: PUSH
26181: LD_INT 6
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 30
26190: PUSH
26191: LD_INT 7
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: PUSH
26198: LD_INT 30
26200: PUSH
26201: LD_INT 8
26203: PUSH
26204: EMPTY
26205: LIST
26206: LIST
26207: PUSH
26208: LD_INT 30
26210: PUSH
26211: LD_INT 0
26213: PUSH
26214: EMPTY
26215: LIST
26216: LIST
26217: PUSH
26218: LD_INT 30
26220: PUSH
26221: LD_INT 1
26223: PUSH
26224: EMPTY
26225: LIST
26226: LIST
26227: PUSH
26228: LD_INT 25
26230: PUSH
26231: LD_INT 4
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: PUSH
26238: EMPTY
26239: LIST
26240: LIST
26241: LIST
26242: LIST
26243: LIST
26244: LIST
26245: LIST
26246: PPUSH
26247: CALL_OW 72
26251: ST_TO_ADDR
// if tmp then
26252: LD_VAR 0 5
26256: IFFALSE 26312
// begin k := NearestUnitToUnit ( tmp , j ) ;
26258: LD_ADDR_VAR 0 4
26262: PUSH
26263: LD_VAR 0 5
26267: PPUSH
26268: LD_VAR 0 3
26272: PPUSH
26273: CALL_OW 74
26277: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
26278: LD_VAR 0 3
26282: PPUSH
26283: LD_VAR 0 4
26287: PPUSH
26288: CALL_OW 296
26292: PUSH
26293: LD_INT 7
26295: GREATER
26296: IFFALSE 26312
// ComMoveUnit ( j , k ) ;
26298: LD_VAR 0 3
26302: PPUSH
26303: LD_VAR 0 4
26307: PPUSH
26308: CALL_OW 112
// end ; end ;
26312: GO 26156
26314: POP
26315: POP
// if not need_heal_1 and not need_heal_2 then
26316: LD_VAR 0 6
26320: NOT
26321: PUSH
26322: LD_VAR 0 7
26326: NOT
26327: AND
26328: IFFALSE 26332
// continue ;
26330: GO 25785
// end ;
26332: GO 25785
26334: POP
26335: POP
// RaiseSailEvent ( 102 ) ;
26336: LD_INT 102
26338: PPUSH
26339: CALL_OW 427
// end ;
26343: LD_VAR 0 1
26347: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26348: LD_INT 0
26350: PPUSH
26351: PPUSH
26352: PPUSH
26353: PPUSH
26354: PPUSH
26355: PPUSH
26356: PPUSH
26357: PPUSH
// if not mc_bases then
26358: LD_EXP 50
26362: NOT
26363: IFFALSE 26367
// exit ;
26365: GO 27207
// for i = 1 to mc_bases do
26367: LD_ADDR_VAR 0 2
26371: PUSH
26372: DOUBLE
26373: LD_INT 1
26375: DEC
26376: ST_TO_ADDR
26377: LD_EXP 50
26381: PUSH
26382: FOR_TO
26383: IFFALSE 27205
// begin if not mc_building_need_repair [ i ] then
26385: LD_EXP 51
26389: PUSH
26390: LD_VAR 0 2
26394: ARRAY
26395: NOT
26396: IFFALSE 26570
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
26398: LD_ADDR_VAR 0 6
26402: PUSH
26403: LD_EXP 69
26407: PUSH
26408: LD_VAR 0 2
26412: ARRAY
26413: PPUSH
26414: LD_INT 3
26416: PUSH
26417: LD_INT 24
26419: PUSH
26420: LD_INT 1000
26422: PUSH
26423: EMPTY
26424: LIST
26425: LIST
26426: PUSH
26427: EMPTY
26428: LIST
26429: LIST
26430: PUSH
26431: LD_INT 2
26433: PUSH
26434: LD_INT 34
26436: PUSH
26437: LD_INT 13
26439: PUSH
26440: EMPTY
26441: LIST
26442: LIST
26443: PUSH
26444: LD_INT 34
26446: PUSH
26447: LD_INT 52
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: PUSH
26454: EMPTY
26455: LIST
26456: LIST
26457: LIST
26458: PUSH
26459: EMPTY
26460: LIST
26461: LIST
26462: PPUSH
26463: CALL_OW 72
26467: ST_TO_ADDR
// if cranes then
26468: LD_VAR 0 6
26472: IFFALSE 26534
// for j in cranes do
26474: LD_ADDR_VAR 0 3
26478: PUSH
26479: LD_VAR 0 6
26483: PUSH
26484: FOR_IN
26485: IFFALSE 26532
// if not IsInArea ( j , mc_parking [ i ] ) then
26487: LD_VAR 0 3
26491: PPUSH
26492: LD_EXP 74
26496: PUSH
26497: LD_VAR 0 2
26501: ARRAY
26502: PPUSH
26503: CALL_OW 308
26507: NOT
26508: IFFALSE 26530
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26510: LD_VAR 0 3
26514: PPUSH
26515: LD_EXP 74
26519: PUSH
26520: LD_VAR 0 2
26524: ARRAY
26525: PPUSH
26526: CALL_OW 113
26530: GO 26484
26532: POP
26533: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
26534: LD_ADDR_EXP 52
26538: PUSH
26539: LD_EXP 52
26543: PPUSH
26544: LD_VAR 0 2
26548: PPUSH
26549: EMPTY
26550: PPUSH
26551: CALL_OW 1
26555: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
26556: LD_VAR 0 2
26560: PPUSH
26561: LD_INT 101
26563: PPUSH
26564: CALL 21460 0 2
// continue ;
26568: GO 26382
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
26570: LD_ADDR_EXP 56
26574: PUSH
26575: LD_EXP 56
26579: PPUSH
26580: LD_VAR 0 2
26584: PPUSH
26585: EMPTY
26586: PPUSH
26587: CALL_OW 1
26591: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
26592: LD_VAR 0 2
26596: PPUSH
26597: LD_INT 103
26599: PPUSH
26600: CALL 21460 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
26604: LD_ADDR_VAR 0 5
26608: PUSH
26609: LD_EXP 50
26613: PUSH
26614: LD_VAR 0 2
26618: ARRAY
26619: PUSH
26620: LD_EXP 79
26624: PUSH
26625: LD_VAR 0 2
26629: ARRAY
26630: UNION
26631: PPUSH
26632: LD_INT 2
26634: PUSH
26635: LD_INT 25
26637: PUSH
26638: LD_INT 2
26640: PUSH
26641: EMPTY
26642: LIST
26643: LIST
26644: PUSH
26645: LD_INT 25
26647: PUSH
26648: LD_INT 16
26650: PUSH
26651: EMPTY
26652: LIST
26653: LIST
26654: PUSH
26655: EMPTY
26656: LIST
26657: LIST
26658: LIST
26659: PUSH
26660: EMPTY
26661: LIST
26662: PPUSH
26663: CALL_OW 72
26667: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
26668: LD_ADDR_VAR 0 6
26672: PUSH
26673: LD_EXP 69
26677: PUSH
26678: LD_VAR 0 2
26682: ARRAY
26683: PPUSH
26684: LD_INT 2
26686: PUSH
26687: LD_INT 34
26689: PUSH
26690: LD_INT 13
26692: PUSH
26693: EMPTY
26694: LIST
26695: LIST
26696: PUSH
26697: LD_INT 34
26699: PUSH
26700: LD_INT 52
26702: PUSH
26703: EMPTY
26704: LIST
26705: LIST
26706: PUSH
26707: EMPTY
26708: LIST
26709: LIST
26710: LIST
26711: PPUSH
26712: CALL_OW 72
26716: ST_TO_ADDR
// if cranes then
26717: LD_VAR 0 6
26721: IFFALSE 26857
// begin for j in cranes do
26723: LD_ADDR_VAR 0 3
26727: PUSH
26728: LD_VAR 0 6
26732: PUSH
26733: FOR_IN
26734: IFFALSE 26855
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
26736: LD_VAR 0 3
26740: PPUSH
26741: CALL_OW 256
26745: PUSH
26746: LD_INT 500
26748: GREATEREQUAL
26749: PUSH
26750: LD_VAR 0 3
26754: PPUSH
26755: CALL_OW 314
26759: NOT
26760: AND
26761: IFFALSE 26795
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
26763: LD_VAR 0 3
26767: PPUSH
26768: LD_EXP 51
26772: PUSH
26773: LD_VAR 0 2
26777: ARRAY
26778: PPUSH
26779: LD_VAR 0 3
26783: PPUSH
26784: CALL_OW 74
26788: PPUSH
26789: CALL_OW 130
26793: GO 26853
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
26795: LD_VAR 0 3
26799: PPUSH
26800: CALL_OW 256
26804: PUSH
26805: LD_INT 500
26807: LESS
26808: PUSH
26809: LD_VAR 0 3
26813: PPUSH
26814: LD_EXP 74
26818: PUSH
26819: LD_VAR 0 2
26823: ARRAY
26824: PPUSH
26825: CALL_OW 308
26829: NOT
26830: AND
26831: IFFALSE 26853
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26833: LD_VAR 0 3
26837: PPUSH
26838: LD_EXP 74
26842: PUSH
26843: LD_VAR 0 2
26847: ARRAY
26848: PPUSH
26849: CALL_OW 113
26853: GO 26733
26855: POP
26856: POP
// end ; if not tmp then
26857: LD_VAR 0 5
26861: NOT
26862: IFFALSE 26866
// continue ;
26864: GO 26382
// for j in tmp do
26866: LD_ADDR_VAR 0 3
26870: PUSH
26871: LD_VAR 0 5
26875: PUSH
26876: FOR_IN
26877: IFFALSE 27201
// begin if mc_need_heal [ i ] then
26879: LD_EXP 53
26883: PUSH
26884: LD_VAR 0 2
26888: ARRAY
26889: IFFALSE 26937
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
26891: LD_VAR 0 3
26895: PUSH
26896: LD_EXP 53
26900: PUSH
26901: LD_VAR 0 2
26905: ARRAY
26906: PUSH
26907: LD_INT 1
26909: ARRAY
26910: IN
26911: PUSH
26912: LD_VAR 0 3
26916: PUSH
26917: LD_EXP 53
26921: PUSH
26922: LD_VAR 0 2
26926: ARRAY
26927: PUSH
26928: LD_INT 2
26930: ARRAY
26931: IN
26932: OR
26933: IFFALSE 26937
// continue ;
26935: GO 26876
// if IsInUnit ( j ) then
26937: LD_VAR 0 3
26941: PPUSH
26942: CALL_OW 310
26946: IFFALSE 26957
// ComExitBuilding ( j ) ;
26948: LD_VAR 0 3
26952: PPUSH
26953: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
26957: LD_VAR 0 3
26961: PUSH
26962: LD_EXP 52
26966: PUSH
26967: LD_VAR 0 2
26971: ARRAY
26972: IN
26973: NOT
26974: IFFALSE 27032
// begin SetTag ( j , 101 ) ;
26976: LD_VAR 0 3
26980: PPUSH
26981: LD_INT 101
26983: PPUSH
26984: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
26988: LD_ADDR_EXP 52
26992: PUSH
26993: LD_EXP 52
26997: PPUSH
26998: LD_VAR 0 2
27002: PUSH
27003: LD_EXP 52
27007: PUSH
27008: LD_VAR 0 2
27012: ARRAY
27013: PUSH
27014: LD_INT 1
27016: PLUS
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PPUSH
27022: LD_VAR 0 3
27026: PPUSH
27027: CALL 52367 0 3
27031: ST_TO_ADDR
// end ; wait ( 1 ) ;
27032: LD_INT 1
27034: PPUSH
27035: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27039: LD_ADDR_VAR 0 7
27043: PUSH
27044: LD_EXP 51
27048: PUSH
27049: LD_VAR 0 2
27053: ARRAY
27054: ST_TO_ADDR
// if mc_scan [ i ] then
27055: LD_EXP 73
27059: PUSH
27060: LD_VAR 0 2
27064: ARRAY
27065: IFFALSE 27134
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
27067: LD_ADDR_VAR 0 7
27071: PUSH
27072: LD_EXP 51
27076: PUSH
27077: LD_VAR 0 2
27081: ARRAY
27082: PPUSH
27083: LD_INT 3
27085: PUSH
27086: LD_INT 2
27088: PUSH
27089: LD_INT 30
27091: PUSH
27092: LD_INT 32
27094: PUSH
27095: EMPTY
27096: LIST
27097: LIST
27098: PUSH
27099: LD_INT 30
27101: PUSH
27102: LD_INT 33
27104: PUSH
27105: EMPTY
27106: LIST
27107: LIST
27108: PUSH
27109: LD_INT 30
27111: PUSH
27112: LD_INT 31
27114: PUSH
27115: EMPTY
27116: LIST
27117: LIST
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: LIST
27123: LIST
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: PPUSH
27129: CALL_OW 72
27133: ST_TO_ADDR
// if not to_repair_tmp then
27134: LD_VAR 0 7
27138: NOT
27139: IFFALSE 27143
// continue ;
27141: GO 26876
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27143: LD_ADDR_VAR 0 8
27147: PUSH
27148: LD_VAR 0 7
27152: PPUSH
27153: LD_VAR 0 3
27157: PPUSH
27158: CALL_OW 74
27162: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
27163: LD_VAR 0 8
27167: PPUSH
27168: LD_INT 14
27170: PPUSH
27171: CALL 54960 0 2
27175: PUSH
27176: LD_INT 4
27178: ARRAY
27179: PUSH
27180: LD_INT 5
27182: LESS
27183: IFFALSE 27199
// ComRepairBuilding ( j , to_repair ) ;
27185: LD_VAR 0 3
27189: PPUSH
27190: LD_VAR 0 8
27194: PPUSH
27195: CALL_OW 130
// end ;
27199: GO 26876
27201: POP
27202: POP
// end ;
27203: GO 26382
27205: POP
27206: POP
// end ;
27207: LD_VAR 0 1
27211: RET
// export function MC_Heal ; var i , j , tmp ; begin
27212: LD_INT 0
27214: PPUSH
27215: PPUSH
27216: PPUSH
27217: PPUSH
// if not mc_bases then
27218: LD_EXP 50
27222: NOT
27223: IFFALSE 27227
// exit ;
27225: GO 27629
// for i = 1 to mc_bases do
27227: LD_ADDR_VAR 0 2
27231: PUSH
27232: DOUBLE
27233: LD_INT 1
27235: DEC
27236: ST_TO_ADDR
27237: LD_EXP 50
27241: PUSH
27242: FOR_TO
27243: IFFALSE 27627
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27245: LD_EXP 53
27249: PUSH
27250: LD_VAR 0 2
27254: ARRAY
27255: PUSH
27256: LD_INT 1
27258: ARRAY
27259: NOT
27260: PUSH
27261: LD_EXP 53
27265: PUSH
27266: LD_VAR 0 2
27270: ARRAY
27271: PUSH
27272: LD_INT 2
27274: ARRAY
27275: NOT
27276: AND
27277: IFFALSE 27315
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27279: LD_ADDR_EXP 54
27283: PUSH
27284: LD_EXP 54
27288: PPUSH
27289: LD_VAR 0 2
27293: PPUSH
27294: EMPTY
27295: PPUSH
27296: CALL_OW 1
27300: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27301: LD_VAR 0 2
27305: PPUSH
27306: LD_INT 102
27308: PPUSH
27309: CALL 21460 0 2
// continue ;
27313: GO 27242
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27315: LD_ADDR_VAR 0 4
27319: PUSH
27320: LD_EXP 50
27324: PUSH
27325: LD_VAR 0 2
27329: ARRAY
27330: PPUSH
27331: LD_INT 25
27333: PUSH
27334: LD_INT 4
27336: PUSH
27337: EMPTY
27338: LIST
27339: LIST
27340: PPUSH
27341: CALL_OW 72
27345: ST_TO_ADDR
// if not tmp then
27346: LD_VAR 0 4
27350: NOT
27351: IFFALSE 27355
// continue ;
27353: GO 27242
// if mc_taming [ i ] then
27355: LD_EXP 81
27359: PUSH
27360: LD_VAR 0 2
27364: ARRAY
27365: IFFALSE 27389
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27367: LD_ADDR_EXP 81
27371: PUSH
27372: LD_EXP 81
27376: PPUSH
27377: LD_VAR 0 2
27381: PPUSH
27382: EMPTY
27383: PPUSH
27384: CALL_OW 1
27388: ST_TO_ADDR
// for j in tmp do
27389: LD_ADDR_VAR 0 3
27393: PUSH
27394: LD_VAR 0 4
27398: PUSH
27399: FOR_IN
27400: IFFALSE 27623
// begin if IsInUnit ( j ) then
27402: LD_VAR 0 3
27406: PPUSH
27407: CALL_OW 310
27411: IFFALSE 27422
// ComExitBuilding ( j ) ;
27413: LD_VAR 0 3
27417: PPUSH
27418: CALL_OW 122
// if not j in mc_healers [ i ] then
27422: LD_VAR 0 3
27426: PUSH
27427: LD_EXP 54
27431: PUSH
27432: LD_VAR 0 2
27436: ARRAY
27437: IN
27438: NOT
27439: IFFALSE 27485
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27441: LD_ADDR_EXP 54
27445: PUSH
27446: LD_EXP 54
27450: PPUSH
27451: LD_VAR 0 2
27455: PUSH
27456: LD_EXP 54
27460: PUSH
27461: LD_VAR 0 2
27465: ARRAY
27466: PUSH
27467: LD_INT 1
27469: PLUS
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: PPUSH
27475: LD_VAR 0 3
27479: PPUSH
27480: CALL 52367 0 3
27484: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
27485: LD_VAR 0 3
27489: PPUSH
27490: CALL_OW 110
27494: PUSH
27495: LD_INT 102
27497: NONEQUAL
27498: IFFALSE 27512
// SetTag ( j , 102 ) ;
27500: LD_VAR 0 3
27504: PPUSH
27505: LD_INT 102
27507: PPUSH
27508: CALL_OW 109
// Wait ( 3 ) ;
27512: LD_INT 3
27514: PPUSH
27515: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
27519: LD_EXP 53
27523: PUSH
27524: LD_VAR 0 2
27528: ARRAY
27529: PUSH
27530: LD_INT 1
27532: ARRAY
27533: IFFALSE 27565
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
27535: LD_VAR 0 3
27539: PPUSH
27540: LD_EXP 53
27544: PUSH
27545: LD_VAR 0 2
27549: ARRAY
27550: PUSH
27551: LD_INT 1
27553: ARRAY
27554: PUSH
27555: LD_INT 1
27557: ARRAY
27558: PPUSH
27559: CALL_OW 128
27563: GO 27621
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
27565: LD_VAR 0 3
27569: PPUSH
27570: CALL_OW 314
27574: NOT
27575: PUSH
27576: LD_EXP 53
27580: PUSH
27581: LD_VAR 0 2
27585: ARRAY
27586: PUSH
27587: LD_INT 2
27589: ARRAY
27590: AND
27591: IFFALSE 27621
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
27593: LD_VAR 0 3
27597: PPUSH
27598: LD_EXP 53
27602: PUSH
27603: LD_VAR 0 2
27607: ARRAY
27608: PUSH
27609: LD_INT 2
27611: ARRAY
27612: PUSH
27613: LD_INT 1
27615: ARRAY
27616: PPUSH
27617: CALL_OW 128
// end ;
27621: GO 27399
27623: POP
27624: POP
// end ;
27625: GO 27242
27627: POP
27628: POP
// end ;
27629: LD_VAR 0 1
27633: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
27634: LD_INT 0
27636: PPUSH
27637: PPUSH
27638: PPUSH
27639: PPUSH
27640: PPUSH
// if not mc_bases then
27641: LD_EXP 50
27645: NOT
27646: IFFALSE 27650
// exit ;
27648: GO 28793
// for i = 1 to mc_bases do
27650: LD_ADDR_VAR 0 2
27654: PUSH
27655: DOUBLE
27656: LD_INT 1
27658: DEC
27659: ST_TO_ADDR
27660: LD_EXP 50
27664: PUSH
27665: FOR_TO
27666: IFFALSE 28791
// begin if mc_scan [ i ] then
27668: LD_EXP 73
27672: PUSH
27673: LD_VAR 0 2
27677: ARRAY
27678: IFFALSE 27682
// continue ;
27680: GO 27665
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
27682: LD_EXP 55
27686: PUSH
27687: LD_VAR 0 2
27691: ARRAY
27692: NOT
27693: PUSH
27694: LD_EXP 57
27698: PUSH
27699: LD_VAR 0 2
27703: ARRAY
27704: NOT
27705: AND
27706: PUSH
27707: LD_EXP 56
27711: PUSH
27712: LD_VAR 0 2
27716: ARRAY
27717: AND
27718: IFFALSE 27756
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
27720: LD_ADDR_EXP 56
27724: PUSH
27725: LD_EXP 56
27729: PPUSH
27730: LD_VAR 0 2
27734: PPUSH
27735: EMPTY
27736: PPUSH
27737: CALL_OW 1
27741: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27742: LD_VAR 0 2
27746: PPUSH
27747: LD_INT 103
27749: PPUSH
27750: CALL 21460 0 2
// continue ;
27754: GO 27665
// end ; if mc_construct_list [ i ] then
27756: LD_EXP 57
27760: PUSH
27761: LD_VAR 0 2
27765: ARRAY
27766: IFFALSE 27986
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27768: LD_ADDR_VAR 0 4
27772: PUSH
27773: LD_EXP 50
27777: PUSH
27778: LD_VAR 0 2
27782: ARRAY
27783: PPUSH
27784: LD_INT 25
27786: PUSH
27787: LD_INT 2
27789: PUSH
27790: EMPTY
27791: LIST
27792: LIST
27793: PPUSH
27794: CALL_OW 72
27798: PUSH
27799: LD_EXP 52
27803: PUSH
27804: LD_VAR 0 2
27808: ARRAY
27809: DIFF
27810: ST_TO_ADDR
// if not tmp then
27811: LD_VAR 0 4
27815: NOT
27816: IFFALSE 27820
// continue ;
27818: GO 27665
// for j in tmp do
27820: LD_ADDR_VAR 0 3
27824: PUSH
27825: LD_VAR 0 4
27829: PUSH
27830: FOR_IN
27831: IFFALSE 27982
// begin if not mc_builders [ i ] then
27833: LD_EXP 56
27837: PUSH
27838: LD_VAR 0 2
27842: ARRAY
27843: NOT
27844: IFFALSE 27902
// begin SetTag ( j , 103 ) ;
27846: LD_VAR 0 3
27850: PPUSH
27851: LD_INT 103
27853: PPUSH
27854: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
27858: LD_ADDR_EXP 56
27862: PUSH
27863: LD_EXP 56
27867: PPUSH
27868: LD_VAR 0 2
27872: PUSH
27873: LD_EXP 56
27877: PUSH
27878: LD_VAR 0 2
27882: ARRAY
27883: PUSH
27884: LD_INT 1
27886: PLUS
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PPUSH
27892: LD_VAR 0 3
27896: PPUSH
27897: CALL 52367 0 3
27901: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
27902: LD_VAR 0 3
27906: PPUSH
27907: CALL_OW 310
27911: IFFALSE 27922
// ComExitBuilding ( j ) ;
27913: LD_VAR 0 3
27917: PPUSH
27918: CALL_OW 122
// wait ( 3 ) ;
27922: LD_INT 3
27924: PPUSH
27925: CALL_OW 67
// if not mc_construct_list [ i ] then
27929: LD_EXP 57
27933: PUSH
27934: LD_VAR 0 2
27938: ARRAY
27939: NOT
27940: IFFALSE 27944
// break ;
27942: GO 27982
// if not HasTask ( j ) then
27944: LD_VAR 0 3
27948: PPUSH
27949: CALL_OW 314
27953: NOT
27954: IFFALSE 27980
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
27956: LD_VAR 0 3
27960: PPUSH
27961: LD_EXP 57
27965: PUSH
27966: LD_VAR 0 2
27970: ARRAY
27971: PUSH
27972: LD_INT 1
27974: ARRAY
27975: PPUSH
27976: CALL 55218 0 2
// end ;
27980: GO 27830
27982: POP
27983: POP
// end else
27984: GO 28789
// if mc_build_list [ i ] then
27986: LD_EXP 55
27990: PUSH
27991: LD_VAR 0 2
27995: ARRAY
27996: IFFALSE 28789
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27998: LD_ADDR_VAR 0 5
28002: PUSH
28003: LD_EXP 50
28007: PUSH
28008: LD_VAR 0 2
28012: ARRAY
28013: PPUSH
28014: LD_INT 2
28016: PUSH
28017: LD_INT 30
28019: PUSH
28020: LD_INT 0
28022: PUSH
28023: EMPTY
28024: LIST
28025: LIST
28026: PUSH
28027: LD_INT 30
28029: PUSH
28030: LD_INT 1
28032: PUSH
28033: EMPTY
28034: LIST
28035: LIST
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: LIST
28041: PPUSH
28042: CALL_OW 72
28046: ST_TO_ADDR
// if depot then
28047: LD_VAR 0 5
28051: IFFALSE 28069
// depot := depot [ 1 ] else
28053: LD_ADDR_VAR 0 5
28057: PUSH
28058: LD_VAR 0 5
28062: PUSH
28063: LD_INT 1
28065: ARRAY
28066: ST_TO_ADDR
28067: GO 28077
// depot := 0 ;
28069: LD_ADDR_VAR 0 5
28073: PUSH
28074: LD_INT 0
28076: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28077: LD_EXP 55
28081: PUSH
28082: LD_VAR 0 2
28086: ARRAY
28087: PUSH
28088: LD_INT 1
28090: ARRAY
28091: PUSH
28092: LD_INT 1
28094: ARRAY
28095: PPUSH
28096: CALL 55048 0 1
28100: PUSH
28101: LD_EXP 50
28105: PUSH
28106: LD_VAR 0 2
28110: ARRAY
28111: PPUSH
28112: LD_INT 2
28114: PUSH
28115: LD_INT 30
28117: PUSH
28118: LD_INT 2
28120: PUSH
28121: EMPTY
28122: LIST
28123: LIST
28124: PUSH
28125: LD_INT 30
28127: PUSH
28128: LD_INT 3
28130: PUSH
28131: EMPTY
28132: LIST
28133: LIST
28134: PUSH
28135: EMPTY
28136: LIST
28137: LIST
28138: LIST
28139: PPUSH
28140: CALL_OW 72
28144: NOT
28145: AND
28146: IFFALSE 28251
// begin for j = 1 to mc_build_list [ i ] do
28148: LD_ADDR_VAR 0 3
28152: PUSH
28153: DOUBLE
28154: LD_INT 1
28156: DEC
28157: ST_TO_ADDR
28158: LD_EXP 55
28162: PUSH
28163: LD_VAR 0 2
28167: ARRAY
28168: PUSH
28169: FOR_TO
28170: IFFALSE 28249
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28172: LD_EXP 55
28176: PUSH
28177: LD_VAR 0 2
28181: ARRAY
28182: PUSH
28183: LD_VAR 0 3
28187: ARRAY
28188: PUSH
28189: LD_INT 1
28191: ARRAY
28192: PUSH
28193: LD_INT 2
28195: EQUAL
28196: IFFALSE 28247
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28198: LD_ADDR_EXP 55
28202: PUSH
28203: LD_EXP 55
28207: PPUSH
28208: LD_VAR 0 2
28212: PPUSH
28213: LD_EXP 55
28217: PUSH
28218: LD_VAR 0 2
28222: ARRAY
28223: PPUSH
28224: LD_VAR 0 3
28228: PPUSH
28229: LD_INT 1
28231: PPUSH
28232: LD_INT 0
28234: PPUSH
28235: CALL 51785 0 4
28239: PPUSH
28240: CALL_OW 1
28244: ST_TO_ADDR
// break ;
28245: GO 28249
// end ;
28247: GO 28169
28249: POP
28250: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28251: LD_EXP 55
28255: PUSH
28256: LD_VAR 0 2
28260: ARRAY
28261: PUSH
28262: LD_INT 1
28264: ARRAY
28265: PUSH
28266: LD_INT 1
28268: ARRAY
28269: PUSH
28270: LD_INT 0
28272: EQUAL
28273: PUSH
28274: LD_VAR 0 5
28278: PUSH
28279: LD_VAR 0 5
28283: PPUSH
28284: LD_EXP 55
28288: PUSH
28289: LD_VAR 0 2
28293: ARRAY
28294: PUSH
28295: LD_INT 1
28297: ARRAY
28298: PUSH
28299: LD_INT 1
28301: ARRAY
28302: PPUSH
28303: LD_EXP 55
28307: PUSH
28308: LD_VAR 0 2
28312: ARRAY
28313: PUSH
28314: LD_INT 1
28316: ARRAY
28317: PUSH
28318: LD_INT 2
28320: ARRAY
28321: PPUSH
28322: LD_EXP 55
28326: PUSH
28327: LD_VAR 0 2
28331: ARRAY
28332: PUSH
28333: LD_INT 1
28335: ARRAY
28336: PUSH
28337: LD_INT 3
28339: ARRAY
28340: PPUSH
28341: LD_EXP 55
28345: PUSH
28346: LD_VAR 0 2
28350: ARRAY
28351: PUSH
28352: LD_INT 1
28354: ARRAY
28355: PUSH
28356: LD_INT 4
28358: ARRAY
28359: PPUSH
28360: CALL 59782 0 5
28364: AND
28365: OR
28366: IFFALSE 28647
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28368: LD_ADDR_VAR 0 4
28372: PUSH
28373: LD_EXP 50
28377: PUSH
28378: LD_VAR 0 2
28382: ARRAY
28383: PPUSH
28384: LD_INT 25
28386: PUSH
28387: LD_INT 2
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PPUSH
28394: CALL_OW 72
28398: PUSH
28399: LD_EXP 52
28403: PUSH
28404: LD_VAR 0 2
28408: ARRAY
28409: DIFF
28410: ST_TO_ADDR
// if not tmp then
28411: LD_VAR 0 4
28415: NOT
28416: IFFALSE 28420
// continue ;
28418: GO 27665
// for j in tmp do
28420: LD_ADDR_VAR 0 3
28424: PUSH
28425: LD_VAR 0 4
28429: PUSH
28430: FOR_IN
28431: IFFALSE 28643
// begin if not mc_builders [ i ] then
28433: LD_EXP 56
28437: PUSH
28438: LD_VAR 0 2
28442: ARRAY
28443: NOT
28444: IFFALSE 28502
// begin SetTag ( j , 103 ) ;
28446: LD_VAR 0 3
28450: PPUSH
28451: LD_INT 103
28453: PPUSH
28454: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28458: LD_ADDR_EXP 56
28462: PUSH
28463: LD_EXP 56
28467: PPUSH
28468: LD_VAR 0 2
28472: PUSH
28473: LD_EXP 56
28477: PUSH
28478: LD_VAR 0 2
28482: ARRAY
28483: PUSH
28484: LD_INT 1
28486: PLUS
28487: PUSH
28488: EMPTY
28489: LIST
28490: LIST
28491: PPUSH
28492: LD_VAR 0 3
28496: PPUSH
28497: CALL 52367 0 3
28501: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28502: LD_VAR 0 3
28506: PPUSH
28507: CALL_OW 310
28511: IFFALSE 28522
// ComExitBuilding ( j ) ;
28513: LD_VAR 0 3
28517: PPUSH
28518: CALL_OW 122
// wait ( 3 ) ;
28522: LD_INT 3
28524: PPUSH
28525: CALL_OW 67
// if not mc_build_list [ i ] then
28529: LD_EXP 55
28533: PUSH
28534: LD_VAR 0 2
28538: ARRAY
28539: NOT
28540: IFFALSE 28544
// break ;
28542: GO 28643
// if not HasTask ( j ) then
28544: LD_VAR 0 3
28548: PPUSH
28549: CALL_OW 314
28553: NOT
28554: IFFALSE 28641
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
28556: LD_VAR 0 3
28560: PPUSH
28561: LD_EXP 55
28565: PUSH
28566: LD_VAR 0 2
28570: ARRAY
28571: PUSH
28572: LD_INT 1
28574: ARRAY
28575: PUSH
28576: LD_INT 1
28578: ARRAY
28579: PPUSH
28580: LD_EXP 55
28584: PUSH
28585: LD_VAR 0 2
28589: ARRAY
28590: PUSH
28591: LD_INT 1
28593: ARRAY
28594: PUSH
28595: LD_INT 2
28597: ARRAY
28598: PPUSH
28599: LD_EXP 55
28603: PUSH
28604: LD_VAR 0 2
28608: ARRAY
28609: PUSH
28610: LD_INT 1
28612: ARRAY
28613: PUSH
28614: LD_INT 3
28616: ARRAY
28617: PPUSH
28618: LD_EXP 55
28622: PUSH
28623: LD_VAR 0 2
28627: ARRAY
28628: PUSH
28629: LD_INT 1
28631: ARRAY
28632: PUSH
28633: LD_INT 4
28635: ARRAY
28636: PPUSH
28637: CALL_OW 145
// end ;
28641: GO 28430
28643: POP
28644: POP
// end else
28645: GO 28789
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
28647: LD_EXP 50
28651: PUSH
28652: LD_VAR 0 2
28656: ARRAY
28657: PPUSH
28658: LD_EXP 55
28662: PUSH
28663: LD_VAR 0 2
28667: ARRAY
28668: PUSH
28669: LD_INT 1
28671: ARRAY
28672: PUSH
28673: LD_INT 1
28675: ARRAY
28676: PPUSH
28677: LD_EXP 55
28681: PUSH
28682: LD_VAR 0 2
28686: ARRAY
28687: PUSH
28688: LD_INT 1
28690: ARRAY
28691: PUSH
28692: LD_INT 2
28694: ARRAY
28695: PPUSH
28696: LD_EXP 55
28700: PUSH
28701: LD_VAR 0 2
28705: ARRAY
28706: PUSH
28707: LD_INT 1
28709: ARRAY
28710: PUSH
28711: LD_INT 3
28713: ARRAY
28714: PPUSH
28715: LD_EXP 55
28719: PUSH
28720: LD_VAR 0 2
28724: ARRAY
28725: PUSH
28726: LD_INT 1
28728: ARRAY
28729: PUSH
28730: LD_INT 4
28732: ARRAY
28733: PPUSH
28734: CALL 59118 0 5
28738: NOT
28739: IFFALSE 28789
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
28741: LD_ADDR_EXP 55
28745: PUSH
28746: LD_EXP 55
28750: PPUSH
28751: LD_VAR 0 2
28755: PPUSH
28756: LD_EXP 55
28760: PUSH
28761: LD_VAR 0 2
28765: ARRAY
28766: PPUSH
28767: LD_INT 1
28769: PPUSH
28770: LD_INT 1
28772: NEG
28773: PPUSH
28774: LD_INT 0
28776: PPUSH
28777: CALL 51785 0 4
28781: PPUSH
28782: CALL_OW 1
28786: ST_TO_ADDR
// continue ;
28787: GO 27665
// end ; end ; end ;
28789: GO 27665
28791: POP
28792: POP
// end ;
28793: LD_VAR 0 1
28797: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
28798: LD_INT 0
28800: PPUSH
28801: PPUSH
28802: PPUSH
28803: PPUSH
28804: PPUSH
28805: PPUSH
// if not mc_bases then
28806: LD_EXP 50
28810: NOT
28811: IFFALSE 28815
// exit ;
28813: GO 29242
// for i = 1 to mc_bases do
28815: LD_ADDR_VAR 0 2
28819: PUSH
28820: DOUBLE
28821: LD_INT 1
28823: DEC
28824: ST_TO_ADDR
28825: LD_EXP 50
28829: PUSH
28830: FOR_TO
28831: IFFALSE 29240
// begin tmp := mc_build_upgrade [ i ] ;
28833: LD_ADDR_VAR 0 4
28837: PUSH
28838: LD_EXP 82
28842: PUSH
28843: LD_VAR 0 2
28847: ARRAY
28848: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
28849: LD_ADDR_VAR 0 6
28853: PUSH
28854: LD_EXP 83
28858: PUSH
28859: LD_VAR 0 2
28863: ARRAY
28864: PPUSH
28865: LD_INT 2
28867: PUSH
28868: LD_INT 30
28870: PUSH
28871: LD_INT 6
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: LD_INT 30
28880: PUSH
28881: LD_INT 7
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: LIST
28892: PPUSH
28893: CALL_OW 72
28897: ST_TO_ADDR
// if not tmp and not lab then
28898: LD_VAR 0 4
28902: NOT
28903: PUSH
28904: LD_VAR 0 6
28908: NOT
28909: AND
28910: IFFALSE 28914
// continue ;
28912: GO 28830
// if tmp then
28914: LD_VAR 0 4
28918: IFFALSE 29038
// for j in tmp do
28920: LD_ADDR_VAR 0 3
28924: PUSH
28925: LD_VAR 0 4
28929: PUSH
28930: FOR_IN
28931: IFFALSE 29036
// begin if UpgradeCost ( j ) then
28933: LD_VAR 0 3
28937: PPUSH
28938: CALL 58778 0 1
28942: IFFALSE 29034
// begin ComUpgrade ( j ) ;
28944: LD_VAR 0 3
28948: PPUSH
28949: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
28953: LD_ADDR_EXP 82
28957: PUSH
28958: LD_EXP 82
28962: PPUSH
28963: LD_VAR 0 2
28967: PPUSH
28968: LD_EXP 82
28972: PUSH
28973: LD_VAR 0 2
28977: ARRAY
28978: PUSH
28979: LD_VAR 0 3
28983: DIFF
28984: PPUSH
28985: CALL_OW 1
28989: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28990: LD_ADDR_EXP 57
28994: PUSH
28995: LD_EXP 57
28999: PPUSH
29000: LD_VAR 0 2
29004: PUSH
29005: LD_EXP 57
29009: PUSH
29010: LD_VAR 0 2
29014: ARRAY
29015: PUSH
29016: LD_INT 1
29018: PLUS
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: PPUSH
29024: LD_VAR 0 3
29028: PPUSH
29029: CALL 52367 0 3
29033: ST_TO_ADDR
// end ; end ;
29034: GO 28930
29036: POP
29037: POP
// if not lab or not mc_lab_upgrade [ i ] then
29038: LD_VAR 0 6
29042: NOT
29043: PUSH
29044: LD_EXP 84
29048: PUSH
29049: LD_VAR 0 2
29053: ARRAY
29054: NOT
29055: OR
29056: IFFALSE 29060
// continue ;
29058: GO 28830
// for j in lab do
29060: LD_ADDR_VAR 0 3
29064: PUSH
29065: LD_VAR 0 6
29069: PUSH
29070: FOR_IN
29071: IFFALSE 29236
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29073: LD_VAR 0 3
29077: PPUSH
29078: CALL_OW 266
29082: PUSH
29083: LD_INT 6
29085: PUSH
29086: LD_INT 7
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: IN
29093: PUSH
29094: LD_VAR 0 3
29098: PPUSH
29099: CALL_OW 461
29103: PUSH
29104: LD_INT 1
29106: NONEQUAL
29107: AND
29108: IFFALSE 29234
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29110: LD_VAR 0 3
29114: PPUSH
29115: LD_EXP 84
29119: PUSH
29120: LD_VAR 0 2
29124: ARRAY
29125: PUSH
29126: LD_INT 1
29128: ARRAY
29129: PPUSH
29130: CALL 58983 0 2
29134: IFFALSE 29234
// begin ComCancel ( j ) ;
29136: LD_VAR 0 3
29140: PPUSH
29141: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29145: LD_VAR 0 3
29149: PPUSH
29150: LD_EXP 84
29154: PUSH
29155: LD_VAR 0 2
29159: ARRAY
29160: PUSH
29161: LD_INT 1
29163: ARRAY
29164: PPUSH
29165: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29169: LD_VAR 0 3
29173: PUSH
29174: LD_EXP 57
29178: PUSH
29179: LD_VAR 0 2
29183: ARRAY
29184: IN
29185: NOT
29186: IFFALSE 29232
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29188: LD_ADDR_EXP 57
29192: PUSH
29193: LD_EXP 57
29197: PPUSH
29198: LD_VAR 0 2
29202: PUSH
29203: LD_EXP 57
29207: PUSH
29208: LD_VAR 0 2
29212: ARRAY
29213: PUSH
29214: LD_INT 1
29216: PLUS
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PPUSH
29222: LD_VAR 0 3
29226: PPUSH
29227: CALL 52367 0 3
29231: ST_TO_ADDR
// break ;
29232: GO 29236
// end ; end ; end ;
29234: GO 29070
29236: POP
29237: POP
// end ;
29238: GO 28830
29240: POP
29241: POP
// end ;
29242: LD_VAR 0 1
29246: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29247: LD_INT 0
29249: PPUSH
29250: PPUSH
29251: PPUSH
29252: PPUSH
29253: PPUSH
29254: PPUSH
29255: PPUSH
29256: PPUSH
29257: PPUSH
// if not mc_bases then
29258: LD_EXP 50
29262: NOT
29263: IFFALSE 29267
// exit ;
29265: GO 29672
// for i = 1 to mc_bases do
29267: LD_ADDR_VAR 0 2
29271: PUSH
29272: DOUBLE
29273: LD_INT 1
29275: DEC
29276: ST_TO_ADDR
29277: LD_EXP 50
29281: PUSH
29282: FOR_TO
29283: IFFALSE 29670
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
29285: LD_EXP 58
29289: PUSH
29290: LD_VAR 0 2
29294: ARRAY
29295: NOT
29296: PUSH
29297: LD_EXP 50
29301: PUSH
29302: LD_VAR 0 2
29306: ARRAY
29307: PPUSH
29308: LD_INT 30
29310: PUSH
29311: LD_INT 3
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: PPUSH
29318: CALL_OW 72
29322: NOT
29323: OR
29324: IFFALSE 29328
// continue ;
29326: GO 29282
// busy := false ;
29328: LD_ADDR_VAR 0 8
29332: PUSH
29333: LD_INT 0
29335: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29336: LD_ADDR_VAR 0 4
29340: PUSH
29341: LD_EXP 50
29345: PUSH
29346: LD_VAR 0 2
29350: ARRAY
29351: PPUSH
29352: LD_INT 30
29354: PUSH
29355: LD_INT 3
29357: PUSH
29358: EMPTY
29359: LIST
29360: LIST
29361: PPUSH
29362: CALL_OW 72
29366: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
29367: LD_ADDR_VAR 0 6
29371: PUSH
29372: LD_EXP 58
29376: PUSH
29377: LD_VAR 0 2
29381: ARRAY
29382: PPUSH
29383: LD_INT 2
29385: PUSH
29386: LD_INT 30
29388: PUSH
29389: LD_INT 32
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: LD_INT 30
29398: PUSH
29399: LD_INT 33
29401: PUSH
29402: EMPTY
29403: LIST
29404: LIST
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: LIST
29410: PPUSH
29411: CALL_OW 72
29415: ST_TO_ADDR
// if not t then
29416: LD_VAR 0 6
29420: NOT
29421: IFFALSE 29425
// continue ;
29423: GO 29282
// for j in tmp do
29425: LD_ADDR_VAR 0 3
29429: PUSH
29430: LD_VAR 0 4
29434: PUSH
29435: FOR_IN
29436: IFFALSE 29466
// if not BuildingStatus ( j ) = bs_idle then
29438: LD_VAR 0 3
29442: PPUSH
29443: CALL_OW 461
29447: PUSH
29448: LD_INT 2
29450: EQUAL
29451: NOT
29452: IFFALSE 29464
// begin busy := true ;
29454: LD_ADDR_VAR 0 8
29458: PUSH
29459: LD_INT 1
29461: ST_TO_ADDR
// break ;
29462: GO 29466
// end ;
29464: GO 29435
29466: POP
29467: POP
// if busy then
29468: LD_VAR 0 8
29472: IFFALSE 29476
// continue ;
29474: GO 29282
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
29476: LD_ADDR_VAR 0 7
29480: PUSH
29481: LD_VAR 0 6
29485: PPUSH
29486: LD_INT 35
29488: PUSH
29489: LD_INT 0
29491: PUSH
29492: EMPTY
29493: LIST
29494: LIST
29495: PPUSH
29496: CALL_OW 72
29500: ST_TO_ADDR
// if tw then
29501: LD_VAR 0 7
29505: IFFALSE 29582
// begin tw := tw [ 1 ] ;
29507: LD_ADDR_VAR 0 7
29511: PUSH
29512: LD_VAR 0 7
29516: PUSH
29517: LD_INT 1
29519: ARRAY
29520: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
29521: LD_ADDR_VAR 0 9
29525: PUSH
29526: LD_VAR 0 7
29530: PPUSH
29531: LD_EXP 75
29535: PUSH
29536: LD_VAR 0 2
29540: ARRAY
29541: PPUSH
29542: CALL 57337 0 2
29546: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
29547: LD_EXP 89
29551: PUSH
29552: LD_VAR 0 2
29556: ARRAY
29557: IFFALSE 29580
// if not weapon in mc_allowed_tower_weapons [ i ] then
29559: LD_VAR 0 9
29563: PUSH
29564: LD_EXP 89
29568: PUSH
29569: LD_VAR 0 2
29573: ARRAY
29574: IN
29575: NOT
29576: IFFALSE 29580
// continue ;
29578: GO 29282
// end else
29580: GO 29645
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
29582: LD_ADDR_VAR 0 5
29586: PUSH
29587: LD_EXP 58
29591: PUSH
29592: LD_VAR 0 2
29596: ARRAY
29597: PPUSH
29598: LD_VAR 0 4
29602: PPUSH
29603: CALL 82839 0 2
29607: ST_TO_ADDR
// if not tmp2 then
29608: LD_VAR 0 5
29612: NOT
29613: IFFALSE 29617
// continue ;
29615: GO 29282
// tw := tmp2 [ 1 ] ;
29617: LD_ADDR_VAR 0 7
29621: PUSH
29622: LD_VAR 0 5
29626: PUSH
29627: LD_INT 1
29629: ARRAY
29630: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
29631: LD_ADDR_VAR 0 9
29635: PUSH
29636: LD_VAR 0 5
29640: PUSH
29641: LD_INT 2
29643: ARRAY
29644: ST_TO_ADDR
// end ; if not weapon then
29645: LD_VAR 0 9
29649: NOT
29650: IFFALSE 29654
// continue ;
29652: GO 29282
// ComPlaceWeapon ( tw , weapon ) ;
29654: LD_VAR 0 7
29658: PPUSH
29659: LD_VAR 0 9
29663: PPUSH
29664: CALL_OW 148
// end ;
29668: GO 29282
29670: POP
29671: POP
// end ;
29672: LD_VAR 0 1
29676: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
29677: LD_INT 0
29679: PPUSH
29680: PPUSH
29681: PPUSH
29682: PPUSH
29683: PPUSH
29684: PPUSH
// if not mc_bases then
29685: LD_EXP 50
29689: NOT
29690: IFFALSE 29694
// exit ;
29692: GO 30470
// for i = 1 to mc_bases do
29694: LD_ADDR_VAR 0 2
29698: PUSH
29699: DOUBLE
29700: LD_INT 1
29702: DEC
29703: ST_TO_ADDR
29704: LD_EXP 50
29708: PUSH
29709: FOR_TO
29710: IFFALSE 30468
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
29712: LD_EXP 63
29716: PUSH
29717: LD_VAR 0 2
29721: ARRAY
29722: NOT
29723: PUSH
29724: LD_EXP 63
29728: PUSH
29729: LD_VAR 0 2
29733: ARRAY
29734: PUSH
29735: LD_EXP 64
29739: PUSH
29740: LD_VAR 0 2
29744: ARRAY
29745: EQUAL
29746: OR
29747: PUSH
29748: LD_EXP 73
29752: PUSH
29753: LD_VAR 0 2
29757: ARRAY
29758: OR
29759: IFFALSE 29763
// continue ;
29761: GO 29709
// if mc_miners [ i ] then
29763: LD_EXP 64
29767: PUSH
29768: LD_VAR 0 2
29772: ARRAY
29773: IFFALSE 30155
// begin for j = mc_miners [ i ] downto 1 do
29775: LD_ADDR_VAR 0 3
29779: PUSH
29780: DOUBLE
29781: LD_EXP 64
29785: PUSH
29786: LD_VAR 0 2
29790: ARRAY
29791: INC
29792: ST_TO_ADDR
29793: LD_INT 1
29795: PUSH
29796: FOR_DOWNTO
29797: IFFALSE 30153
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
29799: LD_EXP 64
29803: PUSH
29804: LD_VAR 0 2
29808: ARRAY
29809: PUSH
29810: LD_VAR 0 3
29814: ARRAY
29815: PPUSH
29816: CALL_OW 301
29820: PUSH
29821: LD_EXP 64
29825: PUSH
29826: LD_VAR 0 2
29830: ARRAY
29831: PUSH
29832: LD_VAR 0 3
29836: ARRAY
29837: PPUSH
29838: CALL_OW 257
29842: PUSH
29843: LD_INT 1
29845: NONEQUAL
29846: OR
29847: IFFALSE 29910
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
29849: LD_ADDR_VAR 0 5
29853: PUSH
29854: LD_EXP 64
29858: PUSH
29859: LD_VAR 0 2
29863: ARRAY
29864: PUSH
29865: LD_EXP 64
29869: PUSH
29870: LD_VAR 0 2
29874: ARRAY
29875: PUSH
29876: LD_VAR 0 3
29880: ARRAY
29881: DIFF
29882: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
29883: LD_ADDR_EXP 64
29887: PUSH
29888: LD_EXP 64
29892: PPUSH
29893: LD_VAR 0 2
29897: PPUSH
29898: LD_VAR 0 5
29902: PPUSH
29903: CALL_OW 1
29907: ST_TO_ADDR
// continue ;
29908: GO 29796
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
29910: LD_EXP 64
29914: PUSH
29915: LD_VAR 0 2
29919: ARRAY
29920: PUSH
29921: LD_VAR 0 3
29925: ARRAY
29926: PPUSH
29927: CALL_OW 257
29931: PUSH
29932: LD_INT 1
29934: EQUAL
29935: PUSH
29936: LD_EXP 64
29940: PUSH
29941: LD_VAR 0 2
29945: ARRAY
29946: PUSH
29947: LD_VAR 0 3
29951: ARRAY
29952: PPUSH
29953: CALL_OW 459
29957: NOT
29958: AND
29959: PUSH
29960: LD_EXP 64
29964: PUSH
29965: LD_VAR 0 2
29969: ARRAY
29970: PUSH
29971: LD_VAR 0 3
29975: ARRAY
29976: PPUSH
29977: CALL_OW 314
29981: NOT
29982: AND
29983: IFFALSE 30151
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
29985: LD_EXP 64
29989: PUSH
29990: LD_VAR 0 2
29994: ARRAY
29995: PUSH
29996: LD_VAR 0 3
30000: ARRAY
30001: PPUSH
30002: CALL_OW 310
30006: IFFALSE 30029
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30008: LD_EXP 64
30012: PUSH
30013: LD_VAR 0 2
30017: ARRAY
30018: PUSH
30019: LD_VAR 0 3
30023: ARRAY
30024: PPUSH
30025: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30029: LD_EXP 64
30033: PUSH
30034: LD_VAR 0 2
30038: ARRAY
30039: PUSH
30040: LD_VAR 0 3
30044: ARRAY
30045: PPUSH
30046: CALL_OW 314
30050: NOT
30051: IFFALSE 30151
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
30053: LD_EXP 64
30057: PUSH
30058: LD_VAR 0 2
30062: ARRAY
30063: PUSH
30064: LD_VAR 0 3
30068: ARRAY
30069: PPUSH
30070: LD_EXP 63
30074: PUSH
30075: LD_VAR 0 2
30079: ARRAY
30080: PUSH
30081: LD_VAR 0 3
30085: PUSH
30086: LD_EXP 63
30090: PUSH
30091: LD_VAR 0 2
30095: ARRAY
30096: MOD
30097: PUSH
30098: LD_INT 1
30100: PLUS
30101: ARRAY
30102: PUSH
30103: LD_INT 1
30105: ARRAY
30106: PPUSH
30107: LD_EXP 63
30111: PUSH
30112: LD_VAR 0 2
30116: ARRAY
30117: PUSH
30118: LD_VAR 0 3
30122: PUSH
30123: LD_EXP 63
30127: PUSH
30128: LD_VAR 0 2
30132: ARRAY
30133: MOD
30134: PUSH
30135: LD_INT 1
30137: PLUS
30138: ARRAY
30139: PUSH
30140: LD_INT 2
30142: ARRAY
30143: PPUSH
30144: LD_INT 0
30146: PPUSH
30147: CALL_OW 193
// end ; end ;
30151: GO 29796
30153: POP
30154: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30155: LD_ADDR_VAR 0 5
30159: PUSH
30160: LD_EXP 50
30164: PUSH
30165: LD_VAR 0 2
30169: ARRAY
30170: PPUSH
30171: LD_INT 2
30173: PUSH
30174: LD_INT 30
30176: PUSH
30177: LD_INT 4
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: PUSH
30184: LD_INT 30
30186: PUSH
30187: LD_INT 5
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 30
30196: PUSH
30197: LD_INT 32
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: LIST
30208: LIST
30209: PPUSH
30210: CALL_OW 72
30214: ST_TO_ADDR
// if not tmp then
30215: LD_VAR 0 5
30219: NOT
30220: IFFALSE 30224
// continue ;
30222: GO 29709
// list := [ ] ;
30224: LD_ADDR_VAR 0 6
30228: PUSH
30229: EMPTY
30230: ST_TO_ADDR
// for j in tmp do
30231: LD_ADDR_VAR 0 3
30235: PUSH
30236: LD_VAR 0 5
30240: PUSH
30241: FOR_IN
30242: IFFALSE 30311
// begin for k in UnitsInside ( j ) do
30244: LD_ADDR_VAR 0 4
30248: PUSH
30249: LD_VAR 0 3
30253: PPUSH
30254: CALL_OW 313
30258: PUSH
30259: FOR_IN
30260: IFFALSE 30307
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30262: LD_VAR 0 4
30266: PPUSH
30267: CALL_OW 257
30271: PUSH
30272: LD_INT 1
30274: EQUAL
30275: PUSH
30276: LD_VAR 0 4
30280: PPUSH
30281: CALL_OW 459
30285: NOT
30286: AND
30287: IFFALSE 30305
// list := list ^ k ;
30289: LD_ADDR_VAR 0 6
30293: PUSH
30294: LD_VAR 0 6
30298: PUSH
30299: LD_VAR 0 4
30303: ADD
30304: ST_TO_ADDR
30305: GO 30259
30307: POP
30308: POP
// end ;
30309: GO 30241
30311: POP
30312: POP
// list := list diff mc_miners [ i ] ;
30313: LD_ADDR_VAR 0 6
30317: PUSH
30318: LD_VAR 0 6
30322: PUSH
30323: LD_EXP 64
30327: PUSH
30328: LD_VAR 0 2
30332: ARRAY
30333: DIFF
30334: ST_TO_ADDR
// if not list then
30335: LD_VAR 0 6
30339: NOT
30340: IFFALSE 30344
// continue ;
30342: GO 29709
// k := mc_mines [ i ] - mc_miners [ i ] ;
30344: LD_ADDR_VAR 0 4
30348: PUSH
30349: LD_EXP 63
30353: PUSH
30354: LD_VAR 0 2
30358: ARRAY
30359: PUSH
30360: LD_EXP 64
30364: PUSH
30365: LD_VAR 0 2
30369: ARRAY
30370: MINUS
30371: ST_TO_ADDR
// if k > list then
30372: LD_VAR 0 4
30376: PUSH
30377: LD_VAR 0 6
30381: GREATER
30382: IFFALSE 30394
// k := list ;
30384: LD_ADDR_VAR 0 4
30388: PUSH
30389: LD_VAR 0 6
30393: ST_TO_ADDR
// for j = 1 to k do
30394: LD_ADDR_VAR 0 3
30398: PUSH
30399: DOUBLE
30400: LD_INT 1
30402: DEC
30403: ST_TO_ADDR
30404: LD_VAR 0 4
30408: PUSH
30409: FOR_TO
30410: IFFALSE 30464
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30412: LD_ADDR_EXP 64
30416: PUSH
30417: LD_EXP 64
30421: PPUSH
30422: LD_VAR 0 2
30426: PUSH
30427: LD_EXP 64
30431: PUSH
30432: LD_VAR 0 2
30436: ARRAY
30437: PUSH
30438: LD_INT 1
30440: PLUS
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PPUSH
30446: LD_VAR 0 6
30450: PUSH
30451: LD_VAR 0 3
30455: ARRAY
30456: PPUSH
30457: CALL 52367 0 3
30461: ST_TO_ADDR
30462: GO 30409
30464: POP
30465: POP
// end ;
30466: GO 29709
30468: POP
30469: POP
// end ;
30470: LD_VAR 0 1
30474: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30475: LD_INT 0
30477: PPUSH
30478: PPUSH
30479: PPUSH
30480: PPUSH
30481: PPUSH
30482: PPUSH
30483: PPUSH
30484: PPUSH
30485: PPUSH
30486: PPUSH
// if not mc_bases then
30487: LD_EXP 50
30491: NOT
30492: IFFALSE 30496
// exit ;
30494: GO 32246
// for i = 1 to mc_bases do
30496: LD_ADDR_VAR 0 2
30500: PUSH
30501: DOUBLE
30502: LD_INT 1
30504: DEC
30505: ST_TO_ADDR
30506: LD_EXP 50
30510: PUSH
30511: FOR_TO
30512: IFFALSE 32244
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
30514: LD_EXP 50
30518: PUSH
30519: LD_VAR 0 2
30523: ARRAY
30524: NOT
30525: PUSH
30526: LD_EXP 57
30530: PUSH
30531: LD_VAR 0 2
30535: ARRAY
30536: OR
30537: IFFALSE 30541
// continue ;
30539: GO 30511
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
30541: LD_EXP 66
30545: PUSH
30546: LD_VAR 0 2
30550: ARRAY
30551: NOT
30552: PUSH
30553: LD_EXP 67
30557: PUSH
30558: LD_VAR 0 2
30562: ARRAY
30563: AND
30564: IFFALSE 30602
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
30566: LD_ADDR_EXP 67
30570: PUSH
30571: LD_EXP 67
30575: PPUSH
30576: LD_VAR 0 2
30580: PPUSH
30581: EMPTY
30582: PPUSH
30583: CALL_OW 1
30587: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
30588: LD_VAR 0 2
30592: PPUSH
30593: LD_INT 107
30595: PPUSH
30596: CALL 21460 0 2
// continue ;
30600: GO 30511
// end ; target := [ ] ;
30602: LD_ADDR_VAR 0 6
30606: PUSH
30607: EMPTY
30608: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
30609: LD_ADDR_VAR 0 3
30613: PUSH
30614: DOUBLE
30615: LD_EXP 66
30619: PUSH
30620: LD_VAR 0 2
30624: ARRAY
30625: INC
30626: ST_TO_ADDR
30627: LD_INT 1
30629: PUSH
30630: FOR_DOWNTO
30631: IFFALSE 30891
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
30633: LD_EXP 66
30637: PUSH
30638: LD_VAR 0 2
30642: ARRAY
30643: PUSH
30644: LD_VAR 0 3
30648: ARRAY
30649: PUSH
30650: LD_INT 2
30652: ARRAY
30653: PPUSH
30654: LD_EXP 66
30658: PUSH
30659: LD_VAR 0 2
30663: ARRAY
30664: PUSH
30665: LD_VAR 0 3
30669: ARRAY
30670: PUSH
30671: LD_INT 3
30673: ARRAY
30674: PPUSH
30675: CALL_OW 488
30679: PUSH
30680: LD_EXP 66
30684: PUSH
30685: LD_VAR 0 2
30689: ARRAY
30690: PUSH
30691: LD_VAR 0 3
30695: ARRAY
30696: PUSH
30697: LD_INT 2
30699: ARRAY
30700: PPUSH
30701: LD_EXP 66
30705: PUSH
30706: LD_VAR 0 2
30710: ARRAY
30711: PUSH
30712: LD_VAR 0 3
30716: ARRAY
30717: PUSH
30718: LD_INT 3
30720: ARRAY
30721: PPUSH
30722: CALL_OW 284
30726: PUSH
30727: LD_INT 0
30729: EQUAL
30730: AND
30731: IFFALSE 30786
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
30733: LD_ADDR_VAR 0 5
30737: PUSH
30738: LD_EXP 66
30742: PUSH
30743: LD_VAR 0 2
30747: ARRAY
30748: PPUSH
30749: LD_VAR 0 3
30753: PPUSH
30754: CALL_OW 3
30758: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
30759: LD_ADDR_EXP 66
30763: PUSH
30764: LD_EXP 66
30768: PPUSH
30769: LD_VAR 0 2
30773: PPUSH
30774: LD_VAR 0 5
30778: PPUSH
30779: CALL_OW 1
30783: ST_TO_ADDR
// continue ;
30784: GO 30630
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
30786: LD_EXP 50
30790: PUSH
30791: LD_VAR 0 2
30795: ARRAY
30796: PUSH
30797: LD_INT 1
30799: ARRAY
30800: PPUSH
30801: CALL_OW 255
30805: PPUSH
30806: LD_EXP 66
30810: PUSH
30811: LD_VAR 0 2
30815: ARRAY
30816: PUSH
30817: LD_VAR 0 3
30821: ARRAY
30822: PUSH
30823: LD_INT 2
30825: ARRAY
30826: PPUSH
30827: LD_EXP 66
30831: PUSH
30832: LD_VAR 0 2
30836: ARRAY
30837: PUSH
30838: LD_VAR 0 3
30842: ARRAY
30843: PUSH
30844: LD_INT 3
30846: ARRAY
30847: PPUSH
30848: LD_INT 30
30850: PPUSH
30851: CALL 53263 0 4
30855: PUSH
30856: LD_INT 4
30858: ARRAY
30859: PUSH
30860: LD_INT 0
30862: EQUAL
30863: IFFALSE 30889
// begin target := mc_crates [ i ] [ j ] ;
30865: LD_ADDR_VAR 0 6
30869: PUSH
30870: LD_EXP 66
30874: PUSH
30875: LD_VAR 0 2
30879: ARRAY
30880: PUSH
30881: LD_VAR 0 3
30885: ARRAY
30886: ST_TO_ADDR
// break ;
30887: GO 30891
// end ; end ;
30889: GO 30630
30891: POP
30892: POP
// if not target then
30893: LD_VAR 0 6
30897: NOT
30898: IFFALSE 30902
// continue ;
30900: GO 30511
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
30902: LD_ADDR_VAR 0 7
30906: PUSH
30907: LD_EXP 69
30911: PUSH
30912: LD_VAR 0 2
30916: ARRAY
30917: PPUSH
30918: LD_INT 2
30920: PUSH
30921: LD_INT 3
30923: PUSH
30924: LD_INT 58
30926: PUSH
30927: EMPTY
30928: LIST
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 61
30936: PUSH
30937: EMPTY
30938: LIST
30939: PUSH
30940: LD_INT 33
30942: PUSH
30943: LD_INT 5
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PUSH
30950: LD_INT 33
30952: PUSH
30953: LD_INT 3
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: LIST
30964: LIST
30965: LIST
30966: PUSH
30967: LD_INT 2
30969: PUSH
30970: LD_INT 34
30972: PUSH
30973: LD_INT 32
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PUSH
30980: LD_INT 34
30982: PUSH
30983: LD_INT 51
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 34
30992: PUSH
30993: LD_INT 12
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: EMPTY
31001: LIST
31002: LIST
31003: LIST
31004: LIST
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PPUSH
31010: CALL_OW 72
31014: ST_TO_ADDR
// if not cargo then
31015: LD_VAR 0 7
31019: NOT
31020: IFFALSE 31663
// begin if mc_crates_collector [ i ] < 5 then
31022: LD_EXP 67
31026: PUSH
31027: LD_VAR 0 2
31031: ARRAY
31032: PUSH
31033: LD_INT 5
31035: LESS
31036: IFFALSE 31402
// begin if mc_ape [ i ] then
31038: LD_EXP 79
31042: PUSH
31043: LD_VAR 0 2
31047: ARRAY
31048: IFFALSE 31095
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31050: LD_ADDR_VAR 0 5
31054: PUSH
31055: LD_EXP 79
31059: PUSH
31060: LD_VAR 0 2
31064: ARRAY
31065: PPUSH
31066: LD_INT 25
31068: PUSH
31069: LD_INT 16
31071: PUSH
31072: EMPTY
31073: LIST
31074: LIST
31075: PUSH
31076: LD_INT 24
31078: PUSH
31079: LD_INT 750
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PPUSH
31090: CALL_OW 72
31094: ST_TO_ADDR
// if not tmp then
31095: LD_VAR 0 5
31099: NOT
31100: IFFALSE 31147
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31102: LD_ADDR_VAR 0 5
31106: PUSH
31107: LD_EXP 50
31111: PUSH
31112: LD_VAR 0 2
31116: ARRAY
31117: PPUSH
31118: LD_INT 25
31120: PUSH
31121: LD_INT 2
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 24
31130: PUSH
31131: LD_INT 750
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PPUSH
31142: CALL_OW 72
31146: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31147: LD_EXP 79
31151: PUSH
31152: LD_VAR 0 2
31156: ARRAY
31157: PUSH
31158: LD_EXP 50
31162: PUSH
31163: LD_VAR 0 2
31167: ARRAY
31168: PPUSH
31169: LD_INT 25
31171: PUSH
31172: LD_INT 2
31174: PUSH
31175: EMPTY
31176: LIST
31177: LIST
31178: PUSH
31179: LD_INT 24
31181: PUSH
31182: LD_INT 750
31184: PUSH
31185: EMPTY
31186: LIST
31187: LIST
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PPUSH
31193: CALL_OW 72
31197: AND
31198: PUSH
31199: LD_VAR 0 5
31203: PUSH
31204: LD_INT 5
31206: LESS
31207: AND
31208: IFFALSE 31290
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31210: LD_ADDR_VAR 0 3
31214: PUSH
31215: LD_EXP 50
31219: PUSH
31220: LD_VAR 0 2
31224: ARRAY
31225: PPUSH
31226: LD_INT 25
31228: PUSH
31229: LD_INT 2
31231: PUSH
31232: EMPTY
31233: LIST
31234: LIST
31235: PUSH
31236: LD_INT 24
31238: PUSH
31239: LD_INT 750
31241: PUSH
31242: EMPTY
31243: LIST
31244: LIST
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PPUSH
31250: CALL_OW 72
31254: PUSH
31255: FOR_IN
31256: IFFALSE 31288
// begin tmp := tmp union j ;
31258: LD_ADDR_VAR 0 5
31262: PUSH
31263: LD_VAR 0 5
31267: PUSH
31268: LD_VAR 0 3
31272: UNION
31273: ST_TO_ADDR
// if tmp >= 5 then
31274: LD_VAR 0 5
31278: PUSH
31279: LD_INT 5
31281: GREATEREQUAL
31282: IFFALSE 31286
// break ;
31284: GO 31288
// end ;
31286: GO 31255
31288: POP
31289: POP
// end ; if not tmp then
31290: LD_VAR 0 5
31294: NOT
31295: IFFALSE 31299
// continue ;
31297: GO 30511
// for j in tmp do
31299: LD_ADDR_VAR 0 3
31303: PUSH
31304: LD_VAR 0 5
31308: PUSH
31309: FOR_IN
31310: IFFALSE 31400
// if not GetTag ( j ) then
31312: LD_VAR 0 3
31316: PPUSH
31317: CALL_OW 110
31321: NOT
31322: IFFALSE 31398
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31324: LD_ADDR_EXP 67
31328: PUSH
31329: LD_EXP 67
31333: PPUSH
31334: LD_VAR 0 2
31338: PUSH
31339: LD_EXP 67
31343: PUSH
31344: LD_VAR 0 2
31348: ARRAY
31349: PUSH
31350: LD_INT 1
31352: PLUS
31353: PUSH
31354: EMPTY
31355: LIST
31356: LIST
31357: PPUSH
31358: LD_VAR 0 3
31362: PPUSH
31363: CALL 52367 0 3
31367: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31368: LD_VAR 0 3
31372: PPUSH
31373: LD_INT 107
31375: PPUSH
31376: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31380: LD_EXP 67
31384: PUSH
31385: LD_VAR 0 2
31389: ARRAY
31390: PUSH
31391: LD_INT 5
31393: GREATEREQUAL
31394: IFFALSE 31398
// break ;
31396: GO 31400
// end ;
31398: GO 31309
31400: POP
31401: POP
// end ; if mc_crates_collector [ i ] and target then
31402: LD_EXP 67
31406: PUSH
31407: LD_VAR 0 2
31411: ARRAY
31412: PUSH
31413: LD_VAR 0 6
31417: AND
31418: IFFALSE 31661
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31420: LD_EXP 67
31424: PUSH
31425: LD_VAR 0 2
31429: ARRAY
31430: PUSH
31431: LD_VAR 0 6
31435: PUSH
31436: LD_INT 1
31438: ARRAY
31439: LESS
31440: IFFALSE 31460
// tmp := mc_crates_collector [ i ] else
31442: LD_ADDR_VAR 0 5
31446: PUSH
31447: LD_EXP 67
31451: PUSH
31452: LD_VAR 0 2
31456: ARRAY
31457: ST_TO_ADDR
31458: GO 31474
// tmp := target [ 1 ] ;
31460: LD_ADDR_VAR 0 5
31464: PUSH
31465: LD_VAR 0 6
31469: PUSH
31470: LD_INT 1
31472: ARRAY
31473: ST_TO_ADDR
// k := 0 ;
31474: LD_ADDR_VAR 0 4
31478: PUSH
31479: LD_INT 0
31481: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31482: LD_ADDR_VAR 0 3
31486: PUSH
31487: LD_EXP 67
31491: PUSH
31492: LD_VAR 0 2
31496: ARRAY
31497: PUSH
31498: FOR_IN
31499: IFFALSE 31659
// begin k := k + 1 ;
31501: LD_ADDR_VAR 0 4
31505: PUSH
31506: LD_VAR 0 4
31510: PUSH
31511: LD_INT 1
31513: PLUS
31514: ST_TO_ADDR
// if k > tmp then
31515: LD_VAR 0 4
31519: PUSH
31520: LD_VAR 0 5
31524: GREATER
31525: IFFALSE 31529
// break ;
31527: GO 31659
// if not GetClass ( j ) in [ 2 , 16 ] then
31529: LD_VAR 0 3
31533: PPUSH
31534: CALL_OW 257
31538: PUSH
31539: LD_INT 2
31541: PUSH
31542: LD_INT 16
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: IN
31549: NOT
31550: IFFALSE 31603
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
31552: LD_ADDR_EXP 67
31556: PUSH
31557: LD_EXP 67
31561: PPUSH
31562: LD_VAR 0 2
31566: PPUSH
31567: LD_EXP 67
31571: PUSH
31572: LD_VAR 0 2
31576: ARRAY
31577: PUSH
31578: LD_VAR 0 3
31582: DIFF
31583: PPUSH
31584: CALL_OW 1
31588: ST_TO_ADDR
// SetTag ( j , 0 ) ;
31589: LD_VAR 0 3
31593: PPUSH
31594: LD_INT 0
31596: PPUSH
31597: CALL_OW 109
// continue ;
31601: GO 31498
// end ; if IsInUnit ( j ) then
31603: LD_VAR 0 3
31607: PPUSH
31608: CALL_OW 310
31612: IFFALSE 31623
// ComExitBuilding ( j ) ;
31614: LD_VAR 0 3
31618: PPUSH
31619: CALL_OW 122
// wait ( 3 ) ;
31623: LD_INT 3
31625: PPUSH
31626: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
31630: LD_VAR 0 3
31634: PPUSH
31635: LD_VAR 0 6
31639: PUSH
31640: LD_INT 2
31642: ARRAY
31643: PPUSH
31644: LD_VAR 0 6
31648: PUSH
31649: LD_INT 3
31651: ARRAY
31652: PPUSH
31653: CALL_OW 117
// end ;
31657: GO 31498
31659: POP
31660: POP
// end ; end else
31661: GO 32242
// begin for j in cargo do
31663: LD_ADDR_VAR 0 3
31667: PUSH
31668: LD_VAR 0 7
31672: PUSH
31673: FOR_IN
31674: IFFALSE 32240
// begin if GetTag ( j ) <> 0 then
31676: LD_VAR 0 3
31680: PPUSH
31681: CALL_OW 110
31685: PUSH
31686: LD_INT 0
31688: NONEQUAL
31689: IFFALSE 31693
// continue ;
31691: GO 31673
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
31693: LD_VAR 0 3
31697: PPUSH
31698: CALL_OW 256
31702: PUSH
31703: LD_INT 1000
31705: LESS
31706: PUSH
31707: LD_VAR 0 3
31711: PPUSH
31712: LD_EXP 74
31716: PUSH
31717: LD_VAR 0 2
31721: ARRAY
31722: PPUSH
31723: CALL_OW 308
31727: NOT
31728: AND
31729: IFFALSE 31751
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31731: LD_VAR 0 3
31735: PPUSH
31736: LD_EXP 74
31740: PUSH
31741: LD_VAR 0 2
31745: ARRAY
31746: PPUSH
31747: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
31751: LD_VAR 0 3
31755: PPUSH
31756: CALL_OW 256
31760: PUSH
31761: LD_INT 1000
31763: LESS
31764: PUSH
31765: LD_VAR 0 3
31769: PPUSH
31770: LD_EXP 74
31774: PUSH
31775: LD_VAR 0 2
31779: ARRAY
31780: PPUSH
31781: CALL_OW 308
31785: AND
31786: IFFALSE 31790
// continue ;
31788: GO 31673
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
31790: LD_VAR 0 3
31794: PPUSH
31795: CALL_OW 262
31799: PUSH
31800: LD_INT 2
31802: EQUAL
31803: PUSH
31804: LD_VAR 0 3
31808: PPUSH
31809: CALL_OW 261
31813: PUSH
31814: LD_INT 15
31816: LESS
31817: AND
31818: IFFALSE 31822
// continue ;
31820: GO 31673
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
31822: LD_VAR 0 3
31826: PPUSH
31827: CALL_OW 262
31831: PUSH
31832: LD_INT 1
31834: EQUAL
31835: PUSH
31836: LD_VAR 0 3
31840: PPUSH
31841: CALL_OW 261
31845: PUSH
31846: LD_INT 10
31848: LESS
31849: AND
31850: IFFALSE 32179
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31852: LD_ADDR_VAR 0 8
31856: PUSH
31857: LD_EXP 50
31861: PUSH
31862: LD_VAR 0 2
31866: ARRAY
31867: PPUSH
31868: LD_INT 2
31870: PUSH
31871: LD_INT 30
31873: PUSH
31874: LD_INT 0
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 30
31883: PUSH
31884: LD_INT 1
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: LIST
31895: PPUSH
31896: CALL_OW 72
31900: ST_TO_ADDR
// if not depot then
31901: LD_VAR 0 8
31905: NOT
31906: IFFALSE 31910
// continue ;
31908: GO 31673
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
31910: LD_VAR 0 3
31914: PPUSH
31915: LD_VAR 0 8
31919: PPUSH
31920: LD_VAR 0 3
31924: PPUSH
31925: CALL_OW 74
31929: PPUSH
31930: CALL_OW 296
31934: PUSH
31935: LD_INT 6
31937: LESS
31938: IFFALSE 31954
// SetFuel ( j , 100 ) else
31940: LD_VAR 0 3
31944: PPUSH
31945: LD_INT 100
31947: PPUSH
31948: CALL_OW 240
31952: GO 32179
// if GetFuel ( j ) = 0 then
31954: LD_VAR 0 3
31958: PPUSH
31959: CALL_OW 261
31963: PUSH
31964: LD_INT 0
31966: EQUAL
31967: IFFALSE 32179
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
31969: LD_ADDR_EXP 69
31973: PUSH
31974: LD_EXP 69
31978: PPUSH
31979: LD_VAR 0 2
31983: PPUSH
31984: LD_EXP 69
31988: PUSH
31989: LD_VAR 0 2
31993: ARRAY
31994: PUSH
31995: LD_VAR 0 3
31999: DIFF
32000: PPUSH
32001: CALL_OW 1
32005: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32006: LD_VAR 0 3
32010: PPUSH
32011: CALL_OW 263
32015: PUSH
32016: LD_INT 1
32018: EQUAL
32019: IFFALSE 32035
// ComExitVehicle ( IsInUnit ( j ) ) ;
32021: LD_VAR 0 3
32025: PPUSH
32026: CALL_OW 310
32030: PPUSH
32031: CALL_OW 121
// if GetControl ( j ) = control_remote then
32035: LD_VAR 0 3
32039: PPUSH
32040: CALL_OW 263
32044: PUSH
32045: LD_INT 2
32047: EQUAL
32048: IFFALSE 32059
// ComUnlink ( j ) ;
32050: LD_VAR 0 3
32054: PPUSH
32055: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32059: LD_ADDR_VAR 0 9
32063: PUSH
32064: LD_VAR 0 2
32068: PPUSH
32069: LD_INT 3
32071: PPUSH
32072: CALL 41532 0 2
32076: ST_TO_ADDR
// if fac then
32077: LD_VAR 0 9
32081: IFFALSE 32177
// begin for k in fac do
32083: LD_ADDR_VAR 0 4
32087: PUSH
32088: LD_VAR 0 9
32092: PUSH
32093: FOR_IN
32094: IFFALSE 32175
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32096: LD_ADDR_VAR 0 10
32100: PUSH
32101: LD_VAR 0 9
32105: PPUSH
32106: LD_VAR 0 3
32110: PPUSH
32111: CALL_OW 265
32115: PPUSH
32116: LD_VAR 0 3
32120: PPUSH
32121: CALL_OW 262
32125: PPUSH
32126: LD_VAR 0 3
32130: PPUSH
32131: CALL_OW 263
32135: PPUSH
32136: LD_VAR 0 3
32140: PPUSH
32141: CALL_OW 264
32145: PPUSH
32146: CALL 49899 0 5
32150: ST_TO_ADDR
// if components then
32151: LD_VAR 0 10
32155: IFFALSE 32173
// begin MC_InsertProduceList ( i , components ) ;
32157: LD_VAR 0 2
32161: PPUSH
32162: LD_VAR 0 10
32166: PPUSH
32167: CALL 41077 0 2
// break ;
32171: GO 32175
// end ; end ;
32173: GO 32093
32175: POP
32176: POP
// end ; continue ;
32177: GO 31673
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32179: LD_VAR 0 3
32183: PPUSH
32184: LD_INT 1
32186: PPUSH
32187: CALL_OW 289
32191: PUSH
32192: LD_INT 100
32194: LESS
32195: PUSH
32196: LD_VAR 0 3
32200: PPUSH
32201: CALL_OW 314
32205: NOT
32206: AND
32207: IFFALSE 32236
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32209: LD_VAR 0 3
32213: PPUSH
32214: LD_VAR 0 6
32218: PUSH
32219: LD_INT 2
32221: ARRAY
32222: PPUSH
32223: LD_VAR 0 6
32227: PUSH
32228: LD_INT 3
32230: ARRAY
32231: PPUSH
32232: CALL_OW 117
// break ;
32236: GO 32240
// end ;
32238: GO 31673
32240: POP
32241: POP
// end ; end ;
32242: GO 30511
32244: POP
32245: POP
// end ;
32246: LD_VAR 0 1
32250: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32251: LD_INT 0
32253: PPUSH
32254: PPUSH
32255: PPUSH
32256: PPUSH
// if not mc_bases then
32257: LD_EXP 50
32261: NOT
32262: IFFALSE 32266
// exit ;
32264: GO 32427
// for i = 1 to mc_bases do
32266: LD_ADDR_VAR 0 2
32270: PUSH
32271: DOUBLE
32272: LD_INT 1
32274: DEC
32275: ST_TO_ADDR
32276: LD_EXP 50
32280: PUSH
32281: FOR_TO
32282: IFFALSE 32425
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32284: LD_ADDR_VAR 0 4
32288: PUSH
32289: LD_EXP 69
32293: PUSH
32294: LD_VAR 0 2
32298: ARRAY
32299: PUSH
32300: LD_EXP 72
32304: PUSH
32305: LD_VAR 0 2
32309: ARRAY
32310: UNION
32311: PPUSH
32312: LD_INT 33
32314: PUSH
32315: LD_INT 2
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PPUSH
32322: CALL_OW 72
32326: ST_TO_ADDR
// if tmp then
32327: LD_VAR 0 4
32331: IFFALSE 32423
// for j in tmp do
32333: LD_ADDR_VAR 0 3
32337: PUSH
32338: LD_VAR 0 4
32342: PUSH
32343: FOR_IN
32344: IFFALSE 32421
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32346: LD_VAR 0 3
32350: PPUSH
32351: CALL_OW 312
32355: NOT
32356: PUSH
32357: LD_VAR 0 3
32361: PPUSH
32362: CALL_OW 256
32366: PUSH
32367: LD_INT 250
32369: GREATEREQUAL
32370: AND
32371: IFFALSE 32384
// Connect ( j ) else
32373: LD_VAR 0 3
32377: PPUSH
32378: CALL 55300 0 1
32382: GO 32419
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32384: LD_VAR 0 3
32388: PPUSH
32389: CALL_OW 256
32393: PUSH
32394: LD_INT 250
32396: LESS
32397: PUSH
32398: LD_VAR 0 3
32402: PPUSH
32403: CALL_OW 312
32407: AND
32408: IFFALSE 32419
// ComUnlink ( j ) ;
32410: LD_VAR 0 3
32414: PPUSH
32415: CALL_OW 136
32419: GO 32343
32421: POP
32422: POP
// end ;
32423: GO 32281
32425: POP
32426: POP
// end ;
32427: LD_VAR 0 1
32431: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
32432: LD_INT 0
32434: PPUSH
32435: PPUSH
32436: PPUSH
32437: PPUSH
32438: PPUSH
// if not mc_bases then
32439: LD_EXP 50
32443: NOT
32444: IFFALSE 32448
// exit ;
32446: GO 32893
// for i = 1 to mc_bases do
32448: LD_ADDR_VAR 0 2
32452: PUSH
32453: DOUBLE
32454: LD_INT 1
32456: DEC
32457: ST_TO_ADDR
32458: LD_EXP 50
32462: PUSH
32463: FOR_TO
32464: IFFALSE 32891
// begin if not mc_produce [ i ] then
32466: LD_EXP 71
32470: PUSH
32471: LD_VAR 0 2
32475: ARRAY
32476: NOT
32477: IFFALSE 32481
// continue ;
32479: GO 32463
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32481: LD_ADDR_VAR 0 5
32485: PUSH
32486: LD_EXP 50
32490: PUSH
32491: LD_VAR 0 2
32495: ARRAY
32496: PPUSH
32497: LD_INT 30
32499: PUSH
32500: LD_INT 3
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PPUSH
32507: CALL_OW 72
32511: ST_TO_ADDR
// if not fac then
32512: LD_VAR 0 5
32516: NOT
32517: IFFALSE 32521
// continue ;
32519: GO 32463
// for j in fac do
32521: LD_ADDR_VAR 0 3
32525: PUSH
32526: LD_VAR 0 5
32530: PUSH
32531: FOR_IN
32532: IFFALSE 32887
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
32534: LD_VAR 0 3
32538: PPUSH
32539: CALL_OW 461
32543: PUSH
32544: LD_INT 2
32546: NONEQUAL
32547: PUSH
32548: LD_VAR 0 3
32552: PPUSH
32553: LD_INT 15
32555: PPUSH
32556: CALL 54960 0 2
32560: PUSH
32561: LD_INT 4
32563: ARRAY
32564: OR
32565: IFFALSE 32569
// continue ;
32567: GO 32531
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
32569: LD_VAR 0 3
32573: PPUSH
32574: LD_EXP 71
32578: PUSH
32579: LD_VAR 0 2
32583: ARRAY
32584: PUSH
32585: LD_INT 1
32587: ARRAY
32588: PUSH
32589: LD_INT 1
32591: ARRAY
32592: PPUSH
32593: LD_EXP 71
32597: PUSH
32598: LD_VAR 0 2
32602: ARRAY
32603: PUSH
32604: LD_INT 1
32606: ARRAY
32607: PUSH
32608: LD_INT 2
32610: ARRAY
32611: PPUSH
32612: LD_EXP 71
32616: PUSH
32617: LD_VAR 0 2
32621: ARRAY
32622: PUSH
32623: LD_INT 1
32625: ARRAY
32626: PUSH
32627: LD_INT 3
32629: ARRAY
32630: PPUSH
32631: LD_EXP 71
32635: PUSH
32636: LD_VAR 0 2
32640: ARRAY
32641: PUSH
32642: LD_INT 1
32644: ARRAY
32645: PUSH
32646: LD_INT 4
32648: ARRAY
32649: PPUSH
32650: CALL_OW 448
32654: PUSH
32655: LD_VAR 0 3
32659: PPUSH
32660: LD_EXP 71
32664: PUSH
32665: LD_VAR 0 2
32669: ARRAY
32670: PUSH
32671: LD_INT 1
32673: ARRAY
32674: PUSH
32675: LD_INT 1
32677: ARRAY
32678: PUSH
32679: LD_EXP 71
32683: PUSH
32684: LD_VAR 0 2
32688: ARRAY
32689: PUSH
32690: LD_INT 1
32692: ARRAY
32693: PUSH
32694: LD_INT 2
32696: ARRAY
32697: PUSH
32698: LD_EXP 71
32702: PUSH
32703: LD_VAR 0 2
32707: ARRAY
32708: PUSH
32709: LD_INT 1
32711: ARRAY
32712: PUSH
32713: LD_INT 3
32715: ARRAY
32716: PUSH
32717: LD_EXP 71
32721: PUSH
32722: LD_VAR 0 2
32726: ARRAY
32727: PUSH
32728: LD_INT 1
32730: ARRAY
32731: PUSH
32732: LD_INT 4
32734: ARRAY
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: LIST
32740: LIST
32741: PPUSH
32742: CALL 58631 0 2
32746: AND
32747: IFFALSE 32885
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
32749: LD_VAR 0 3
32753: PPUSH
32754: LD_EXP 71
32758: PUSH
32759: LD_VAR 0 2
32763: ARRAY
32764: PUSH
32765: LD_INT 1
32767: ARRAY
32768: PUSH
32769: LD_INT 1
32771: ARRAY
32772: PPUSH
32773: LD_EXP 71
32777: PUSH
32778: LD_VAR 0 2
32782: ARRAY
32783: PUSH
32784: LD_INT 1
32786: ARRAY
32787: PUSH
32788: LD_INT 2
32790: ARRAY
32791: PPUSH
32792: LD_EXP 71
32796: PUSH
32797: LD_VAR 0 2
32801: ARRAY
32802: PUSH
32803: LD_INT 1
32805: ARRAY
32806: PUSH
32807: LD_INT 3
32809: ARRAY
32810: PPUSH
32811: LD_EXP 71
32815: PUSH
32816: LD_VAR 0 2
32820: ARRAY
32821: PUSH
32822: LD_INT 1
32824: ARRAY
32825: PUSH
32826: LD_INT 4
32828: ARRAY
32829: PPUSH
32830: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
32834: LD_ADDR_VAR 0 4
32838: PUSH
32839: LD_EXP 71
32843: PUSH
32844: LD_VAR 0 2
32848: ARRAY
32849: PPUSH
32850: LD_INT 1
32852: PPUSH
32853: CALL_OW 3
32857: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
32858: LD_ADDR_EXP 71
32862: PUSH
32863: LD_EXP 71
32867: PPUSH
32868: LD_VAR 0 2
32872: PPUSH
32873: LD_VAR 0 4
32877: PPUSH
32878: CALL_OW 1
32882: ST_TO_ADDR
// break ;
32883: GO 32887
// end ; end ;
32885: GO 32531
32887: POP
32888: POP
// end ;
32889: GO 32463
32891: POP
32892: POP
// end ;
32893: LD_VAR 0 1
32897: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
32898: LD_INT 0
32900: PPUSH
32901: PPUSH
32902: PPUSH
// if not mc_bases then
32903: LD_EXP 50
32907: NOT
32908: IFFALSE 32912
// exit ;
32910: GO 33001
// for i = 1 to mc_bases do
32912: LD_ADDR_VAR 0 2
32916: PUSH
32917: DOUBLE
32918: LD_INT 1
32920: DEC
32921: ST_TO_ADDR
32922: LD_EXP 50
32926: PUSH
32927: FOR_TO
32928: IFFALSE 32999
// begin if mc_attack [ i ] then
32930: LD_EXP 70
32934: PUSH
32935: LD_VAR 0 2
32939: ARRAY
32940: IFFALSE 32997
// begin tmp := mc_attack [ i ] [ 1 ] ;
32942: LD_ADDR_VAR 0 3
32946: PUSH
32947: LD_EXP 70
32951: PUSH
32952: LD_VAR 0 2
32956: ARRAY
32957: PUSH
32958: LD_INT 1
32960: ARRAY
32961: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
32962: LD_ADDR_EXP 70
32966: PUSH
32967: LD_EXP 70
32971: PPUSH
32972: LD_VAR 0 2
32976: PPUSH
32977: EMPTY
32978: PPUSH
32979: CALL_OW 1
32983: ST_TO_ADDR
// Attack ( tmp ) ;
32984: LD_VAR 0 3
32988: PPUSH
32989: CALL 95298 0 1
// exit ;
32993: POP
32994: POP
32995: GO 33001
// end ; end ;
32997: GO 32927
32999: POP
33000: POP
// end ;
33001: LD_VAR 0 1
33005: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33006: LD_INT 0
33008: PPUSH
33009: PPUSH
33010: PPUSH
33011: PPUSH
33012: PPUSH
33013: PPUSH
33014: PPUSH
// if not mc_bases then
33015: LD_EXP 50
33019: NOT
33020: IFFALSE 33024
// exit ;
33022: GO 33606
// for i = 1 to mc_bases do
33024: LD_ADDR_VAR 0 2
33028: PUSH
33029: DOUBLE
33030: LD_INT 1
33032: DEC
33033: ST_TO_ADDR
33034: LD_EXP 50
33038: PUSH
33039: FOR_TO
33040: IFFALSE 33604
// begin if not mc_bases [ i ] then
33042: LD_EXP 50
33046: PUSH
33047: LD_VAR 0 2
33051: ARRAY
33052: NOT
33053: IFFALSE 33057
// continue ;
33055: GO 33039
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33057: LD_ADDR_VAR 0 7
33061: PUSH
33062: LD_EXP 50
33066: PUSH
33067: LD_VAR 0 2
33071: ARRAY
33072: PUSH
33073: LD_INT 1
33075: ARRAY
33076: PPUSH
33077: CALL 49203 0 1
33081: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33082: LD_ADDR_EXP 73
33086: PUSH
33087: LD_EXP 73
33091: PPUSH
33092: LD_VAR 0 2
33096: PPUSH
33097: LD_EXP 50
33101: PUSH
33102: LD_VAR 0 2
33106: ARRAY
33107: PUSH
33108: LD_INT 1
33110: ARRAY
33111: PPUSH
33112: CALL_OW 255
33116: PPUSH
33117: LD_EXP 75
33121: PUSH
33122: LD_VAR 0 2
33126: ARRAY
33127: PPUSH
33128: CALL 49168 0 2
33132: PPUSH
33133: CALL_OW 1
33137: ST_TO_ADDR
// if not mc_scan [ i ] then
33138: LD_EXP 73
33142: PUSH
33143: LD_VAR 0 2
33147: ARRAY
33148: NOT
33149: IFFALSE 33304
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33151: LD_ADDR_VAR 0 4
33155: PUSH
33156: LD_EXP 50
33160: PUSH
33161: LD_VAR 0 2
33165: ARRAY
33166: PPUSH
33167: LD_INT 2
33169: PUSH
33170: LD_INT 25
33172: PUSH
33173: LD_INT 5
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PUSH
33180: LD_INT 25
33182: PUSH
33183: LD_INT 8
33185: PUSH
33186: EMPTY
33187: LIST
33188: LIST
33189: PUSH
33190: LD_INT 25
33192: PUSH
33193: LD_INT 9
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: PPUSH
33206: CALL_OW 72
33210: ST_TO_ADDR
// if not tmp then
33211: LD_VAR 0 4
33215: NOT
33216: IFFALSE 33220
// continue ;
33218: GO 33039
// for j in tmp do
33220: LD_ADDR_VAR 0 3
33224: PUSH
33225: LD_VAR 0 4
33229: PUSH
33230: FOR_IN
33231: IFFALSE 33302
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33233: LD_VAR 0 3
33237: PPUSH
33238: CALL_OW 310
33242: PPUSH
33243: CALL_OW 266
33247: PUSH
33248: LD_INT 5
33250: EQUAL
33251: PUSH
33252: LD_VAR 0 3
33256: PPUSH
33257: CALL_OW 257
33261: PUSH
33262: LD_INT 1
33264: EQUAL
33265: AND
33266: PUSH
33267: LD_VAR 0 3
33271: PPUSH
33272: CALL_OW 459
33276: NOT
33277: AND
33278: PUSH
33279: LD_VAR 0 7
33283: AND
33284: IFFALSE 33300
// ComChangeProfession ( j , class ) ;
33286: LD_VAR 0 3
33290: PPUSH
33291: LD_VAR 0 7
33295: PPUSH
33296: CALL_OW 123
33300: GO 33230
33302: POP
33303: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33304: LD_EXP 73
33308: PUSH
33309: LD_VAR 0 2
33313: ARRAY
33314: PUSH
33315: LD_EXP 72
33319: PUSH
33320: LD_VAR 0 2
33324: ARRAY
33325: NOT
33326: AND
33327: PUSH
33328: LD_EXP 50
33332: PUSH
33333: LD_VAR 0 2
33337: ARRAY
33338: PPUSH
33339: LD_INT 30
33341: PUSH
33342: LD_INT 32
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PPUSH
33349: CALL_OW 72
33353: NOT
33354: AND
33355: PUSH
33356: LD_EXP 50
33360: PUSH
33361: LD_VAR 0 2
33365: ARRAY
33366: PPUSH
33367: LD_INT 2
33369: PUSH
33370: LD_INT 30
33372: PUSH
33373: LD_INT 4
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 30
33382: PUSH
33383: LD_INT 5
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: EMPTY
33391: LIST
33392: LIST
33393: LIST
33394: PPUSH
33395: CALL_OW 72
33399: NOT
33400: AND
33401: IFFALSE 33533
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33403: LD_ADDR_VAR 0 4
33407: PUSH
33408: LD_EXP 50
33412: PUSH
33413: LD_VAR 0 2
33417: ARRAY
33418: PPUSH
33419: LD_INT 2
33421: PUSH
33422: LD_INT 25
33424: PUSH
33425: LD_INT 1
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PUSH
33432: LD_INT 25
33434: PUSH
33435: LD_INT 5
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 25
33444: PUSH
33445: LD_INT 8
33447: PUSH
33448: EMPTY
33449: LIST
33450: LIST
33451: PUSH
33452: LD_INT 25
33454: PUSH
33455: LD_INT 9
33457: PUSH
33458: EMPTY
33459: LIST
33460: LIST
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: LIST
33466: LIST
33467: LIST
33468: PPUSH
33469: CALL_OW 72
33473: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33474: LD_ADDR_VAR 0 4
33478: PUSH
33479: LD_VAR 0 4
33483: PUSH
33484: LD_VAR 0 4
33488: PPUSH
33489: LD_INT 18
33491: PPUSH
33492: CALL 80928 0 2
33496: DIFF
33497: ST_TO_ADDR
// if tmp then
33498: LD_VAR 0 4
33502: IFFALSE 33533
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
33504: LD_VAR 0 2
33508: PPUSH
33509: LD_VAR 0 4
33513: PPUSH
33514: LD_EXP 75
33518: PUSH
33519: LD_VAR 0 2
33523: ARRAY
33524: PPUSH
33525: CALL 100007 0 3
// exit ;
33529: POP
33530: POP
33531: GO 33606
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
33533: LD_EXP 73
33537: PUSH
33538: LD_VAR 0 2
33542: ARRAY
33543: PUSH
33544: LD_EXP 72
33548: PUSH
33549: LD_VAR 0 2
33553: ARRAY
33554: AND
33555: IFFALSE 33602
// begin tmp := mc_defender [ i ] ;
33557: LD_ADDR_VAR 0 4
33561: PUSH
33562: LD_EXP 72
33566: PUSH
33567: LD_VAR 0 2
33571: ARRAY
33572: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
33573: LD_VAR 0 2
33577: PPUSH
33578: LD_VAR 0 4
33582: PPUSH
33583: LD_EXP 73
33587: PUSH
33588: LD_VAR 0 2
33592: ARRAY
33593: PPUSH
33594: CALL 100568 0 3
// exit ;
33598: POP
33599: POP
33600: GO 33606
// end ; end ;
33602: GO 33039
33604: POP
33605: POP
// end ;
33606: LD_VAR 0 1
33610: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
33611: LD_INT 0
33613: PPUSH
33614: PPUSH
33615: PPUSH
33616: PPUSH
33617: PPUSH
33618: PPUSH
33619: PPUSH
33620: PPUSH
33621: PPUSH
33622: PPUSH
33623: PPUSH
// if not mc_bases then
33624: LD_EXP 50
33628: NOT
33629: IFFALSE 33633
// exit ;
33631: GO 34720
// for i = 1 to mc_bases do
33633: LD_ADDR_VAR 0 2
33637: PUSH
33638: DOUBLE
33639: LD_INT 1
33641: DEC
33642: ST_TO_ADDR
33643: LD_EXP 50
33647: PUSH
33648: FOR_TO
33649: IFFALSE 34718
// begin tmp := mc_lab [ i ] ;
33651: LD_ADDR_VAR 0 6
33655: PUSH
33656: LD_EXP 83
33660: PUSH
33661: LD_VAR 0 2
33665: ARRAY
33666: ST_TO_ADDR
// if not tmp then
33667: LD_VAR 0 6
33671: NOT
33672: IFFALSE 33676
// continue ;
33674: GO 33648
// idle_lab := 0 ;
33676: LD_ADDR_VAR 0 11
33680: PUSH
33681: LD_INT 0
33683: ST_TO_ADDR
// for j in tmp do
33684: LD_ADDR_VAR 0 3
33688: PUSH
33689: LD_VAR 0 6
33693: PUSH
33694: FOR_IN
33695: IFFALSE 34714
// begin researching := false ;
33697: LD_ADDR_VAR 0 10
33701: PUSH
33702: LD_INT 0
33704: ST_TO_ADDR
// side := GetSide ( j ) ;
33705: LD_ADDR_VAR 0 4
33709: PUSH
33710: LD_VAR 0 3
33714: PPUSH
33715: CALL_OW 255
33719: ST_TO_ADDR
// if not mc_tech [ side ] then
33720: LD_EXP 77
33724: PUSH
33725: LD_VAR 0 4
33729: ARRAY
33730: NOT
33731: IFFALSE 33735
// continue ;
33733: GO 33694
// if BuildingStatus ( j ) = bs_idle then
33735: LD_VAR 0 3
33739: PPUSH
33740: CALL_OW 461
33744: PUSH
33745: LD_INT 2
33747: EQUAL
33748: IFFALSE 33936
// begin if idle_lab and UnitsInside ( j ) < 6 then
33750: LD_VAR 0 11
33754: PUSH
33755: LD_VAR 0 3
33759: PPUSH
33760: CALL_OW 313
33764: PUSH
33765: LD_INT 6
33767: LESS
33768: AND
33769: IFFALSE 33840
// begin tmp2 := UnitsInside ( idle_lab ) ;
33771: LD_ADDR_VAR 0 9
33775: PUSH
33776: LD_VAR 0 11
33780: PPUSH
33781: CALL_OW 313
33785: ST_TO_ADDR
// if tmp2 then
33786: LD_VAR 0 9
33790: IFFALSE 33832
// for x in tmp2 do
33792: LD_ADDR_VAR 0 7
33796: PUSH
33797: LD_VAR 0 9
33801: PUSH
33802: FOR_IN
33803: IFFALSE 33830
// begin ComExitBuilding ( x ) ;
33805: LD_VAR 0 7
33809: PPUSH
33810: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
33814: LD_VAR 0 7
33818: PPUSH
33819: LD_VAR 0 3
33823: PPUSH
33824: CALL_OW 180
// end ;
33828: GO 33802
33830: POP
33831: POP
// idle_lab := 0 ;
33832: LD_ADDR_VAR 0 11
33836: PUSH
33837: LD_INT 0
33839: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
33840: LD_ADDR_VAR 0 5
33844: PUSH
33845: LD_EXP 77
33849: PUSH
33850: LD_VAR 0 4
33854: ARRAY
33855: PUSH
33856: FOR_IN
33857: IFFALSE 33917
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
33859: LD_VAR 0 3
33863: PPUSH
33864: LD_VAR 0 5
33868: PPUSH
33869: CALL_OW 430
33873: PUSH
33874: LD_VAR 0 4
33878: PPUSH
33879: LD_VAR 0 5
33883: PPUSH
33884: CALL 48273 0 2
33888: AND
33889: IFFALSE 33915
// begin researching := true ;
33891: LD_ADDR_VAR 0 10
33895: PUSH
33896: LD_INT 1
33898: ST_TO_ADDR
// ComResearch ( j , t ) ;
33899: LD_VAR 0 3
33903: PPUSH
33904: LD_VAR 0 5
33908: PPUSH
33909: CALL_OW 124
// break ;
33913: GO 33917
// end ;
33915: GO 33856
33917: POP
33918: POP
// if not researching then
33919: LD_VAR 0 10
33923: NOT
33924: IFFALSE 33936
// idle_lab := j ;
33926: LD_ADDR_VAR 0 11
33930: PUSH
33931: LD_VAR 0 3
33935: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
33936: LD_VAR 0 3
33940: PPUSH
33941: CALL_OW 461
33945: PUSH
33946: LD_INT 10
33948: EQUAL
33949: IFFALSE 34537
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
33951: LD_EXP 79
33955: PUSH
33956: LD_VAR 0 2
33960: ARRAY
33961: NOT
33962: PUSH
33963: LD_EXP 80
33967: PUSH
33968: LD_VAR 0 2
33972: ARRAY
33973: NOT
33974: AND
33975: PUSH
33976: LD_EXP 77
33980: PUSH
33981: LD_VAR 0 4
33985: ARRAY
33986: PUSH
33987: LD_INT 1
33989: GREATER
33990: AND
33991: IFFALSE 34122
// begin ComCancel ( j ) ;
33993: LD_VAR 0 3
33997: PPUSH
33998: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
34002: LD_ADDR_EXP 77
34006: PUSH
34007: LD_EXP 77
34011: PPUSH
34012: LD_VAR 0 4
34016: PPUSH
34017: LD_EXP 77
34021: PUSH
34022: LD_VAR 0 4
34026: ARRAY
34027: PPUSH
34028: LD_EXP 77
34032: PUSH
34033: LD_VAR 0 4
34037: ARRAY
34038: PUSH
34039: LD_INT 1
34041: MINUS
34042: PPUSH
34043: LD_EXP 77
34047: PUSH
34048: LD_VAR 0 4
34052: ARRAY
34053: PPUSH
34054: LD_INT 0
34056: PPUSH
34057: CALL 51785 0 4
34061: PPUSH
34062: CALL_OW 1
34066: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
34067: LD_ADDR_EXP 77
34071: PUSH
34072: LD_EXP 77
34076: PPUSH
34077: LD_VAR 0 4
34081: PPUSH
34082: LD_EXP 77
34086: PUSH
34087: LD_VAR 0 4
34091: ARRAY
34092: PPUSH
34093: LD_EXP 77
34097: PUSH
34098: LD_VAR 0 4
34102: ARRAY
34103: PPUSH
34104: LD_INT 1
34106: PPUSH
34107: LD_INT 0
34109: PPUSH
34110: CALL 51785 0 4
34114: PPUSH
34115: CALL_OW 1
34119: ST_TO_ADDR
// continue ;
34120: GO 33694
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
34122: LD_EXP 79
34126: PUSH
34127: LD_VAR 0 2
34131: ARRAY
34132: PUSH
34133: LD_EXP 80
34137: PUSH
34138: LD_VAR 0 2
34142: ARRAY
34143: NOT
34144: AND
34145: IFFALSE 34272
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
34147: LD_ADDR_EXP 80
34151: PUSH
34152: LD_EXP 80
34156: PPUSH
34157: LD_VAR 0 2
34161: PUSH
34162: LD_EXP 80
34166: PUSH
34167: LD_VAR 0 2
34171: ARRAY
34172: PUSH
34173: LD_INT 1
34175: PLUS
34176: PUSH
34177: EMPTY
34178: LIST
34179: LIST
34180: PPUSH
34181: LD_EXP 79
34185: PUSH
34186: LD_VAR 0 2
34190: ARRAY
34191: PUSH
34192: LD_INT 1
34194: ARRAY
34195: PPUSH
34196: CALL 52367 0 3
34200: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34201: LD_EXP 79
34205: PUSH
34206: LD_VAR 0 2
34210: ARRAY
34211: PUSH
34212: LD_INT 1
34214: ARRAY
34215: PPUSH
34216: LD_INT 112
34218: PPUSH
34219: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34223: LD_ADDR_VAR 0 9
34227: PUSH
34228: LD_EXP 79
34232: PUSH
34233: LD_VAR 0 2
34237: ARRAY
34238: PPUSH
34239: LD_INT 1
34241: PPUSH
34242: CALL_OW 3
34246: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34247: LD_ADDR_EXP 79
34251: PUSH
34252: LD_EXP 79
34256: PPUSH
34257: LD_VAR 0 2
34261: PPUSH
34262: LD_VAR 0 9
34266: PPUSH
34267: CALL_OW 1
34271: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34272: LD_EXP 79
34276: PUSH
34277: LD_VAR 0 2
34281: ARRAY
34282: PUSH
34283: LD_EXP 80
34287: PUSH
34288: LD_VAR 0 2
34292: ARRAY
34293: AND
34294: PUSH
34295: LD_EXP 80
34299: PUSH
34300: LD_VAR 0 2
34304: ARRAY
34305: PUSH
34306: LD_INT 1
34308: ARRAY
34309: PPUSH
34310: CALL_OW 310
34314: NOT
34315: AND
34316: PUSH
34317: LD_VAR 0 3
34321: PPUSH
34322: CALL_OW 313
34326: PUSH
34327: LD_INT 6
34329: EQUAL
34330: AND
34331: IFFALSE 34387
// begin tmp2 := UnitsInside ( j ) ;
34333: LD_ADDR_VAR 0 9
34337: PUSH
34338: LD_VAR 0 3
34342: PPUSH
34343: CALL_OW 313
34347: ST_TO_ADDR
// if tmp2 = 6 then
34348: LD_VAR 0 9
34352: PUSH
34353: LD_INT 6
34355: EQUAL
34356: IFFALSE 34387
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
34358: LD_VAR 0 9
34362: PUSH
34363: LD_INT 1
34365: ARRAY
34366: PPUSH
34367: LD_INT 112
34369: PPUSH
34370: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
34374: LD_VAR 0 9
34378: PUSH
34379: LD_INT 1
34381: ARRAY
34382: PPUSH
34383: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
34387: LD_EXP 80
34391: PUSH
34392: LD_VAR 0 2
34396: ARRAY
34397: PUSH
34398: LD_EXP 80
34402: PUSH
34403: LD_VAR 0 2
34407: ARRAY
34408: PUSH
34409: LD_INT 1
34411: ARRAY
34412: PPUSH
34413: CALL_OW 314
34417: NOT
34418: AND
34419: PUSH
34420: LD_EXP 80
34424: PUSH
34425: LD_VAR 0 2
34429: ARRAY
34430: PUSH
34431: LD_INT 1
34433: ARRAY
34434: PPUSH
34435: CALL_OW 310
34439: NOT
34440: AND
34441: IFFALSE 34467
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
34443: LD_EXP 80
34447: PUSH
34448: LD_VAR 0 2
34452: ARRAY
34453: PUSH
34454: LD_INT 1
34456: ARRAY
34457: PPUSH
34458: LD_VAR 0 3
34462: PPUSH
34463: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34467: LD_EXP 80
34471: PUSH
34472: LD_VAR 0 2
34476: ARRAY
34477: PUSH
34478: LD_INT 1
34480: ARRAY
34481: PPUSH
34482: CALL_OW 310
34486: PUSH
34487: LD_EXP 80
34491: PUSH
34492: LD_VAR 0 2
34496: ARRAY
34497: PUSH
34498: LD_INT 1
34500: ARRAY
34501: PPUSH
34502: CALL_OW 310
34506: PPUSH
34507: CALL_OW 461
34511: PUSH
34512: LD_INT 3
34514: NONEQUAL
34515: AND
34516: IFFALSE 34537
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
34518: LD_EXP 80
34522: PUSH
34523: LD_VAR 0 2
34527: ARRAY
34528: PUSH
34529: LD_INT 1
34531: ARRAY
34532: PPUSH
34533: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
34537: LD_VAR 0 3
34541: PPUSH
34542: CALL_OW 461
34546: PUSH
34547: LD_INT 6
34549: EQUAL
34550: PUSH
34551: LD_VAR 0 6
34555: PUSH
34556: LD_INT 1
34558: GREATER
34559: AND
34560: IFFALSE 34712
// begin sci := [ ] ;
34562: LD_ADDR_VAR 0 8
34566: PUSH
34567: EMPTY
34568: ST_TO_ADDR
// for x in ( tmp diff j ) do
34569: LD_ADDR_VAR 0 7
34573: PUSH
34574: LD_VAR 0 6
34578: PUSH
34579: LD_VAR 0 3
34583: DIFF
34584: PUSH
34585: FOR_IN
34586: IFFALSE 34638
// begin if sci = 6 then
34588: LD_VAR 0 8
34592: PUSH
34593: LD_INT 6
34595: EQUAL
34596: IFFALSE 34600
// break ;
34598: GO 34638
// if BuildingStatus ( x ) = bs_idle then
34600: LD_VAR 0 7
34604: PPUSH
34605: CALL_OW 461
34609: PUSH
34610: LD_INT 2
34612: EQUAL
34613: IFFALSE 34636
// sci := sci ^ UnitsInside ( x ) ;
34615: LD_ADDR_VAR 0 8
34619: PUSH
34620: LD_VAR 0 8
34624: PUSH
34625: LD_VAR 0 7
34629: PPUSH
34630: CALL_OW 313
34634: ADD
34635: ST_TO_ADDR
// end ;
34636: GO 34585
34638: POP
34639: POP
// if not sci then
34640: LD_VAR 0 8
34644: NOT
34645: IFFALSE 34649
// continue ;
34647: GO 33694
// for x in sci do
34649: LD_ADDR_VAR 0 7
34653: PUSH
34654: LD_VAR 0 8
34658: PUSH
34659: FOR_IN
34660: IFFALSE 34710
// if IsInUnit ( x ) and not HasTask ( x ) then
34662: LD_VAR 0 7
34666: PPUSH
34667: CALL_OW 310
34671: PUSH
34672: LD_VAR 0 7
34676: PPUSH
34677: CALL_OW 314
34681: NOT
34682: AND
34683: IFFALSE 34708
// begin ComExitBuilding ( x ) ;
34685: LD_VAR 0 7
34689: PPUSH
34690: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34694: LD_VAR 0 7
34698: PPUSH
34699: LD_VAR 0 3
34703: PPUSH
34704: CALL_OW 180
// end ;
34708: GO 34659
34710: POP
34711: POP
// end ; end ;
34712: GO 33694
34714: POP
34715: POP
// end ;
34716: GO 33648
34718: POP
34719: POP
// end ;
34720: LD_VAR 0 1
34724: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
34725: LD_INT 0
34727: PPUSH
34728: PPUSH
// if not mc_bases then
34729: LD_EXP 50
34733: NOT
34734: IFFALSE 34738
// exit ;
34736: GO 34819
// for i = 1 to mc_bases do
34738: LD_ADDR_VAR 0 2
34742: PUSH
34743: DOUBLE
34744: LD_INT 1
34746: DEC
34747: ST_TO_ADDR
34748: LD_EXP 50
34752: PUSH
34753: FOR_TO
34754: IFFALSE 34817
// if mc_mines [ i ] and mc_miners [ i ] then
34756: LD_EXP 63
34760: PUSH
34761: LD_VAR 0 2
34765: ARRAY
34766: PUSH
34767: LD_EXP 64
34771: PUSH
34772: LD_VAR 0 2
34776: ARRAY
34777: AND
34778: IFFALSE 34815
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
34780: LD_EXP 64
34784: PUSH
34785: LD_VAR 0 2
34789: ARRAY
34790: PUSH
34791: LD_INT 1
34793: ARRAY
34794: PPUSH
34795: CALL_OW 255
34799: PPUSH
34800: LD_EXP 63
34804: PUSH
34805: LD_VAR 0 2
34809: ARRAY
34810: PPUSH
34811: CALL 49356 0 2
34815: GO 34753
34817: POP
34818: POP
// end ;
34819: LD_VAR 0 1
34823: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
34824: LD_INT 0
34826: PPUSH
34827: PPUSH
34828: PPUSH
34829: PPUSH
34830: PPUSH
34831: PPUSH
34832: PPUSH
34833: PPUSH
// if not mc_bases or not mc_parking then
34834: LD_EXP 50
34838: NOT
34839: PUSH
34840: LD_EXP 74
34844: NOT
34845: OR
34846: IFFALSE 34850
// exit ;
34848: GO 35549
// for i = 1 to mc_bases do
34850: LD_ADDR_VAR 0 2
34854: PUSH
34855: DOUBLE
34856: LD_INT 1
34858: DEC
34859: ST_TO_ADDR
34860: LD_EXP 50
34864: PUSH
34865: FOR_TO
34866: IFFALSE 35547
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
34868: LD_EXP 50
34872: PUSH
34873: LD_VAR 0 2
34877: ARRAY
34878: NOT
34879: PUSH
34880: LD_EXP 74
34884: PUSH
34885: LD_VAR 0 2
34889: ARRAY
34890: NOT
34891: OR
34892: IFFALSE 34896
// continue ;
34894: GO 34865
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34896: LD_ADDR_VAR 0 5
34900: PUSH
34901: LD_EXP 50
34905: PUSH
34906: LD_VAR 0 2
34910: ARRAY
34911: PUSH
34912: LD_INT 1
34914: ARRAY
34915: PPUSH
34916: CALL_OW 255
34920: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34921: LD_ADDR_VAR 0 6
34925: PUSH
34926: LD_EXP 50
34930: PUSH
34931: LD_VAR 0 2
34935: ARRAY
34936: PPUSH
34937: LD_INT 30
34939: PUSH
34940: LD_INT 3
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PPUSH
34947: CALL_OW 72
34951: ST_TO_ADDR
// if not fac then
34952: LD_VAR 0 6
34956: NOT
34957: IFFALSE 35008
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34959: LD_ADDR_VAR 0 6
34963: PUSH
34964: LD_EXP 50
34968: PUSH
34969: LD_VAR 0 2
34973: ARRAY
34974: PPUSH
34975: LD_INT 2
34977: PUSH
34978: LD_INT 30
34980: PUSH
34981: LD_INT 0
34983: PUSH
34984: EMPTY
34985: LIST
34986: LIST
34987: PUSH
34988: LD_INT 30
34990: PUSH
34991: LD_INT 1
34993: PUSH
34994: EMPTY
34995: LIST
34996: LIST
34997: PUSH
34998: EMPTY
34999: LIST
35000: LIST
35001: LIST
35002: PPUSH
35003: CALL_OW 72
35007: ST_TO_ADDR
// if not fac then
35008: LD_VAR 0 6
35012: NOT
35013: IFFALSE 35017
// continue ;
35015: GO 34865
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35017: LD_ADDR_VAR 0 7
35021: PUSH
35022: LD_EXP 74
35026: PUSH
35027: LD_VAR 0 2
35031: ARRAY
35032: PPUSH
35033: LD_INT 22
35035: PUSH
35036: LD_VAR 0 5
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: LD_INT 21
35047: PUSH
35048: LD_INT 2
35050: PUSH
35051: EMPTY
35052: LIST
35053: LIST
35054: PUSH
35055: LD_INT 3
35057: PUSH
35058: LD_INT 24
35060: PUSH
35061: LD_INT 1000
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: EMPTY
35073: LIST
35074: LIST
35075: LIST
35076: PPUSH
35077: CALL_OW 70
35081: ST_TO_ADDR
// for j in fac do
35082: LD_ADDR_VAR 0 3
35086: PUSH
35087: LD_VAR 0 6
35091: PUSH
35092: FOR_IN
35093: IFFALSE 35174
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35095: LD_ADDR_VAR 0 7
35099: PUSH
35100: LD_VAR 0 7
35104: PUSH
35105: LD_INT 22
35107: PUSH
35108: LD_VAR 0 5
35112: PUSH
35113: EMPTY
35114: LIST
35115: LIST
35116: PUSH
35117: LD_INT 91
35119: PUSH
35120: LD_VAR 0 3
35124: PUSH
35125: LD_INT 15
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: LIST
35132: PUSH
35133: LD_INT 21
35135: PUSH
35136: LD_INT 2
35138: PUSH
35139: EMPTY
35140: LIST
35141: LIST
35142: PUSH
35143: LD_INT 3
35145: PUSH
35146: LD_INT 24
35148: PUSH
35149: LD_INT 1000
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: LIST
35164: LIST
35165: PPUSH
35166: CALL_OW 69
35170: UNION
35171: ST_TO_ADDR
35172: GO 35092
35174: POP
35175: POP
// if not vehs then
35176: LD_VAR 0 7
35180: NOT
35181: IFFALSE 35207
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35183: LD_ADDR_EXP 62
35187: PUSH
35188: LD_EXP 62
35192: PPUSH
35193: LD_VAR 0 2
35197: PPUSH
35198: EMPTY
35199: PPUSH
35200: CALL_OW 1
35204: ST_TO_ADDR
// continue ;
35205: GO 34865
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35207: LD_ADDR_VAR 0 8
35211: PUSH
35212: LD_EXP 50
35216: PUSH
35217: LD_VAR 0 2
35221: ARRAY
35222: PPUSH
35223: LD_INT 30
35225: PUSH
35226: LD_INT 3
35228: PUSH
35229: EMPTY
35230: LIST
35231: LIST
35232: PPUSH
35233: CALL_OW 72
35237: ST_TO_ADDR
// if tmp then
35238: LD_VAR 0 8
35242: IFFALSE 35345
// begin for j in tmp do
35244: LD_ADDR_VAR 0 3
35248: PUSH
35249: LD_VAR 0 8
35253: PUSH
35254: FOR_IN
35255: IFFALSE 35343
// for k in UnitsInside ( j ) do
35257: LD_ADDR_VAR 0 4
35261: PUSH
35262: LD_VAR 0 3
35266: PPUSH
35267: CALL_OW 313
35271: PUSH
35272: FOR_IN
35273: IFFALSE 35339
// if k then
35275: LD_VAR 0 4
35279: IFFALSE 35337
// if not k in mc_repair_vehicle [ i ] then
35281: LD_VAR 0 4
35285: PUSH
35286: LD_EXP 62
35290: PUSH
35291: LD_VAR 0 2
35295: ARRAY
35296: IN
35297: NOT
35298: IFFALSE 35337
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35300: LD_ADDR_EXP 62
35304: PUSH
35305: LD_EXP 62
35309: PPUSH
35310: LD_VAR 0 2
35314: PPUSH
35315: LD_EXP 62
35319: PUSH
35320: LD_VAR 0 2
35324: ARRAY
35325: PUSH
35326: LD_VAR 0 4
35330: UNION
35331: PPUSH
35332: CALL_OW 1
35336: ST_TO_ADDR
35337: GO 35272
35339: POP
35340: POP
35341: GO 35254
35343: POP
35344: POP
// end ; if not mc_repair_vehicle [ i ] then
35345: LD_EXP 62
35349: PUSH
35350: LD_VAR 0 2
35354: ARRAY
35355: NOT
35356: IFFALSE 35360
// continue ;
35358: GO 34865
// for j in mc_repair_vehicle [ i ] do
35360: LD_ADDR_VAR 0 3
35364: PUSH
35365: LD_EXP 62
35369: PUSH
35370: LD_VAR 0 2
35374: ARRAY
35375: PUSH
35376: FOR_IN
35377: IFFALSE 35543
// begin if GetClass ( j ) <> 3 then
35379: LD_VAR 0 3
35383: PPUSH
35384: CALL_OW 257
35388: PUSH
35389: LD_INT 3
35391: NONEQUAL
35392: IFFALSE 35433
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
35394: LD_ADDR_EXP 62
35398: PUSH
35399: LD_EXP 62
35403: PPUSH
35404: LD_VAR 0 2
35408: PPUSH
35409: LD_EXP 62
35413: PUSH
35414: LD_VAR 0 2
35418: ARRAY
35419: PUSH
35420: LD_VAR 0 3
35424: DIFF
35425: PPUSH
35426: CALL_OW 1
35430: ST_TO_ADDR
// continue ;
35431: GO 35376
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
35433: LD_VAR 0 3
35437: PPUSH
35438: CALL_OW 311
35442: NOT
35443: PUSH
35444: LD_VAR 0 3
35448: PUSH
35449: LD_EXP 53
35453: PUSH
35454: LD_VAR 0 2
35458: ARRAY
35459: PUSH
35460: LD_INT 1
35462: ARRAY
35463: IN
35464: NOT
35465: AND
35466: PUSH
35467: LD_VAR 0 3
35471: PUSH
35472: LD_EXP 53
35476: PUSH
35477: LD_VAR 0 2
35481: ARRAY
35482: PUSH
35483: LD_INT 2
35485: ARRAY
35486: IN
35487: NOT
35488: AND
35489: IFFALSE 35541
// begin if IsInUnit ( j ) then
35491: LD_VAR 0 3
35495: PPUSH
35496: CALL_OW 310
35500: IFFALSE 35511
// ComExitBuilding ( j ) ;
35502: LD_VAR 0 3
35506: PPUSH
35507: CALL_OW 122
// if not HasTask ( j ) then
35511: LD_VAR 0 3
35515: PPUSH
35516: CALL_OW 314
35520: NOT
35521: IFFALSE 35541
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
35523: LD_VAR 0 3
35527: PPUSH
35528: LD_VAR 0 7
35532: PUSH
35533: LD_INT 1
35535: ARRAY
35536: PPUSH
35537: CALL_OW 189
// end ; end ;
35541: GO 35376
35543: POP
35544: POP
// end ;
35545: GO 34865
35547: POP
35548: POP
// end ;
35549: LD_VAR 0 1
35553: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
35554: LD_INT 0
35556: PPUSH
35557: PPUSH
35558: PPUSH
35559: PPUSH
35560: PPUSH
35561: PPUSH
35562: PPUSH
35563: PPUSH
35564: PPUSH
35565: PPUSH
35566: PPUSH
// if not mc_bases then
35567: LD_EXP 50
35571: NOT
35572: IFFALSE 35576
// exit ;
35574: GO 36378
// for i = 1 to mc_bases do
35576: LD_ADDR_VAR 0 2
35580: PUSH
35581: DOUBLE
35582: LD_INT 1
35584: DEC
35585: ST_TO_ADDR
35586: LD_EXP 50
35590: PUSH
35591: FOR_TO
35592: IFFALSE 36376
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
35594: LD_EXP 78
35598: PUSH
35599: LD_VAR 0 2
35603: ARRAY
35604: NOT
35605: PUSH
35606: LD_EXP 53
35610: PUSH
35611: LD_VAR 0 2
35615: ARRAY
35616: PUSH
35617: LD_INT 1
35619: ARRAY
35620: OR
35621: PUSH
35622: LD_EXP 53
35626: PUSH
35627: LD_VAR 0 2
35631: ARRAY
35632: PUSH
35633: LD_INT 2
35635: ARRAY
35636: OR
35637: PUSH
35638: LD_EXP 76
35642: PUSH
35643: LD_VAR 0 2
35647: ARRAY
35648: PPUSH
35649: LD_INT 1
35651: PPUSH
35652: CALL_OW 325
35656: NOT
35657: OR
35658: PUSH
35659: LD_EXP 73
35663: PUSH
35664: LD_VAR 0 2
35668: ARRAY
35669: OR
35670: IFFALSE 35674
// continue ;
35672: GO 35591
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
35674: LD_ADDR_VAR 0 8
35678: PUSH
35679: LD_EXP 50
35683: PUSH
35684: LD_VAR 0 2
35688: ARRAY
35689: PPUSH
35690: LD_INT 25
35692: PUSH
35693: LD_INT 4
35695: PUSH
35696: EMPTY
35697: LIST
35698: LIST
35699: PUSH
35700: LD_INT 50
35702: PUSH
35703: EMPTY
35704: LIST
35705: PUSH
35706: LD_INT 3
35708: PUSH
35709: LD_INT 60
35711: PUSH
35712: EMPTY
35713: LIST
35714: PUSH
35715: EMPTY
35716: LIST
35717: LIST
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: LIST
35723: PPUSH
35724: CALL_OW 72
35728: PUSH
35729: LD_EXP 54
35733: PUSH
35734: LD_VAR 0 2
35738: ARRAY
35739: DIFF
35740: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35741: LD_ADDR_VAR 0 9
35745: PUSH
35746: LD_EXP 50
35750: PUSH
35751: LD_VAR 0 2
35755: ARRAY
35756: PPUSH
35757: LD_INT 2
35759: PUSH
35760: LD_INT 30
35762: PUSH
35763: LD_INT 0
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 30
35772: PUSH
35773: LD_INT 1
35775: PUSH
35776: EMPTY
35777: LIST
35778: LIST
35779: PUSH
35780: EMPTY
35781: LIST
35782: LIST
35783: LIST
35784: PPUSH
35785: CALL_OW 72
35789: ST_TO_ADDR
// if not tmp or not dep then
35790: LD_VAR 0 8
35794: NOT
35795: PUSH
35796: LD_VAR 0 9
35800: NOT
35801: OR
35802: IFFALSE 35806
// continue ;
35804: GO 35591
// side := GetSide ( tmp [ 1 ] ) ;
35806: LD_ADDR_VAR 0 11
35810: PUSH
35811: LD_VAR 0 8
35815: PUSH
35816: LD_INT 1
35818: ARRAY
35819: PPUSH
35820: CALL_OW 255
35824: ST_TO_ADDR
// dep := dep [ 1 ] ;
35825: LD_ADDR_VAR 0 9
35829: PUSH
35830: LD_VAR 0 9
35834: PUSH
35835: LD_INT 1
35837: ARRAY
35838: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
35839: LD_ADDR_VAR 0 7
35843: PUSH
35844: LD_EXP 78
35848: PUSH
35849: LD_VAR 0 2
35853: ARRAY
35854: PPUSH
35855: LD_INT 22
35857: PUSH
35858: LD_INT 0
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: PUSH
35865: LD_INT 25
35867: PUSH
35868: LD_INT 12
35870: PUSH
35871: EMPTY
35872: LIST
35873: LIST
35874: PUSH
35875: EMPTY
35876: LIST
35877: LIST
35878: PPUSH
35879: CALL_OW 70
35883: PUSH
35884: LD_INT 22
35886: PUSH
35887: LD_INT 0
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 25
35896: PUSH
35897: LD_INT 12
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: PUSH
35904: LD_INT 91
35906: PUSH
35907: LD_VAR 0 9
35911: PUSH
35912: LD_INT 20
35914: PUSH
35915: EMPTY
35916: LIST
35917: LIST
35918: LIST
35919: PUSH
35920: EMPTY
35921: LIST
35922: LIST
35923: LIST
35924: PPUSH
35925: CALL_OW 69
35929: UNION
35930: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
35931: LD_ADDR_VAR 0 10
35935: PUSH
35936: LD_EXP 78
35940: PUSH
35941: LD_VAR 0 2
35945: ARRAY
35946: PPUSH
35947: LD_INT 81
35949: PUSH
35950: LD_VAR 0 11
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PPUSH
35959: CALL_OW 70
35963: ST_TO_ADDR
// if not apes or danger_at_area then
35964: LD_VAR 0 7
35968: NOT
35969: PUSH
35970: LD_VAR 0 10
35974: OR
35975: IFFALSE 36025
// begin if mc_taming [ i ] then
35977: LD_EXP 81
35981: PUSH
35982: LD_VAR 0 2
35986: ARRAY
35987: IFFALSE 36023
// begin MC_Reset ( i , 121 ) ;
35989: LD_VAR 0 2
35993: PPUSH
35994: LD_INT 121
35996: PPUSH
35997: CALL 21460 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36001: LD_ADDR_EXP 81
36005: PUSH
36006: LD_EXP 81
36010: PPUSH
36011: LD_VAR 0 2
36015: PPUSH
36016: EMPTY
36017: PPUSH
36018: CALL_OW 1
36022: ST_TO_ADDR
// end ; continue ;
36023: GO 35591
// end ; for j in tmp do
36025: LD_ADDR_VAR 0 3
36029: PUSH
36030: LD_VAR 0 8
36034: PUSH
36035: FOR_IN
36036: IFFALSE 36372
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
36038: LD_VAR 0 3
36042: PUSH
36043: LD_EXP 81
36047: PUSH
36048: LD_VAR 0 2
36052: ARRAY
36053: IN
36054: NOT
36055: PUSH
36056: LD_EXP 81
36060: PUSH
36061: LD_VAR 0 2
36065: ARRAY
36066: PUSH
36067: LD_INT 3
36069: LESS
36070: AND
36071: IFFALSE 36129
// begin SetTag ( j , 121 ) ;
36073: LD_VAR 0 3
36077: PPUSH
36078: LD_INT 121
36080: PPUSH
36081: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
36085: LD_ADDR_EXP 81
36089: PUSH
36090: LD_EXP 81
36094: PPUSH
36095: LD_VAR 0 2
36099: PUSH
36100: LD_EXP 81
36104: PUSH
36105: LD_VAR 0 2
36109: ARRAY
36110: PUSH
36111: LD_INT 1
36113: PLUS
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PPUSH
36119: LD_VAR 0 3
36123: PPUSH
36124: CALL 52367 0 3
36128: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
36129: LD_VAR 0 3
36133: PUSH
36134: LD_EXP 81
36138: PUSH
36139: LD_VAR 0 2
36143: ARRAY
36144: IN
36145: IFFALSE 36370
// begin if GetClass ( j ) <> 4 then
36147: LD_VAR 0 3
36151: PPUSH
36152: CALL_OW 257
36156: PUSH
36157: LD_INT 4
36159: NONEQUAL
36160: IFFALSE 36213
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
36162: LD_ADDR_EXP 81
36166: PUSH
36167: LD_EXP 81
36171: PPUSH
36172: LD_VAR 0 2
36176: PPUSH
36177: LD_EXP 81
36181: PUSH
36182: LD_VAR 0 2
36186: ARRAY
36187: PUSH
36188: LD_VAR 0 3
36192: DIFF
36193: PPUSH
36194: CALL_OW 1
36198: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36199: LD_VAR 0 3
36203: PPUSH
36204: LD_INT 0
36206: PPUSH
36207: CALL_OW 109
// continue ;
36211: GO 36035
// end ; if IsInUnit ( j ) then
36213: LD_VAR 0 3
36217: PPUSH
36218: CALL_OW 310
36222: IFFALSE 36233
// ComExitBuilding ( j ) ;
36224: LD_VAR 0 3
36228: PPUSH
36229: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36233: LD_ADDR_VAR 0 6
36237: PUSH
36238: LD_VAR 0 7
36242: PPUSH
36243: LD_VAR 0 3
36247: PPUSH
36248: CALL_OW 74
36252: ST_TO_ADDR
// if not ape then
36253: LD_VAR 0 6
36257: NOT
36258: IFFALSE 36262
// break ;
36260: GO 36372
// x := GetX ( ape ) ;
36262: LD_ADDR_VAR 0 4
36266: PUSH
36267: LD_VAR 0 6
36271: PPUSH
36272: CALL_OW 250
36276: ST_TO_ADDR
// y := GetY ( ape ) ;
36277: LD_ADDR_VAR 0 5
36281: PUSH
36282: LD_VAR 0 6
36286: PPUSH
36287: CALL_OW 251
36291: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36292: LD_VAR 0 4
36296: PPUSH
36297: LD_VAR 0 5
36301: PPUSH
36302: CALL_OW 488
36306: NOT
36307: PUSH
36308: LD_VAR 0 11
36312: PPUSH
36313: LD_VAR 0 4
36317: PPUSH
36318: LD_VAR 0 5
36322: PPUSH
36323: LD_INT 20
36325: PPUSH
36326: CALL 53263 0 4
36330: PUSH
36331: LD_INT 4
36333: ARRAY
36334: OR
36335: IFFALSE 36339
// break ;
36337: GO 36372
// if not HasTask ( j ) then
36339: LD_VAR 0 3
36343: PPUSH
36344: CALL_OW 314
36348: NOT
36349: IFFALSE 36370
// ComTameXY ( j , x , y ) ;
36351: LD_VAR 0 3
36355: PPUSH
36356: LD_VAR 0 4
36360: PPUSH
36361: LD_VAR 0 5
36365: PPUSH
36366: CALL_OW 131
// end ; end ;
36370: GO 36035
36372: POP
36373: POP
// end ;
36374: GO 35591
36376: POP
36377: POP
// end ;
36378: LD_VAR 0 1
36382: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
36383: LD_INT 0
36385: PPUSH
36386: PPUSH
36387: PPUSH
36388: PPUSH
36389: PPUSH
36390: PPUSH
36391: PPUSH
36392: PPUSH
// if not mc_bases then
36393: LD_EXP 50
36397: NOT
36398: IFFALSE 36402
// exit ;
36400: GO 37028
// for i = 1 to mc_bases do
36402: LD_ADDR_VAR 0 2
36406: PUSH
36407: DOUBLE
36408: LD_INT 1
36410: DEC
36411: ST_TO_ADDR
36412: LD_EXP 50
36416: PUSH
36417: FOR_TO
36418: IFFALSE 37026
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
36420: LD_EXP 79
36424: PUSH
36425: LD_VAR 0 2
36429: ARRAY
36430: NOT
36431: PUSH
36432: LD_EXP 79
36436: PUSH
36437: LD_VAR 0 2
36441: ARRAY
36442: PPUSH
36443: LD_INT 25
36445: PUSH
36446: LD_INT 12
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PPUSH
36453: CALL_OW 72
36457: NOT
36458: OR
36459: IFFALSE 36463
// continue ;
36461: GO 36417
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36463: LD_ADDR_VAR 0 5
36467: PUSH
36468: LD_EXP 79
36472: PUSH
36473: LD_VAR 0 2
36477: ARRAY
36478: PUSH
36479: LD_INT 1
36481: ARRAY
36482: PPUSH
36483: CALL_OW 255
36487: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
36488: LD_VAR 0 5
36492: PPUSH
36493: LD_INT 2
36495: PPUSH
36496: CALL_OW 325
36500: IFFALSE 36753
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36502: LD_ADDR_VAR 0 4
36506: PUSH
36507: LD_EXP 79
36511: PUSH
36512: LD_VAR 0 2
36516: ARRAY
36517: PPUSH
36518: LD_INT 25
36520: PUSH
36521: LD_INT 16
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: PPUSH
36528: CALL_OW 72
36532: ST_TO_ADDR
// if tmp < 6 then
36533: LD_VAR 0 4
36537: PUSH
36538: LD_INT 6
36540: LESS
36541: IFFALSE 36753
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36543: LD_ADDR_VAR 0 6
36547: PUSH
36548: LD_EXP 50
36552: PUSH
36553: LD_VAR 0 2
36557: ARRAY
36558: PPUSH
36559: LD_INT 2
36561: PUSH
36562: LD_INT 30
36564: PUSH
36565: LD_INT 0
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 30
36574: PUSH
36575: LD_INT 1
36577: PUSH
36578: EMPTY
36579: LIST
36580: LIST
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: LIST
36586: PPUSH
36587: CALL_OW 72
36591: ST_TO_ADDR
// if depot then
36592: LD_VAR 0 6
36596: IFFALSE 36753
// begin selected := 0 ;
36598: LD_ADDR_VAR 0 7
36602: PUSH
36603: LD_INT 0
36605: ST_TO_ADDR
// for j in depot do
36606: LD_ADDR_VAR 0 3
36610: PUSH
36611: LD_VAR 0 6
36615: PUSH
36616: FOR_IN
36617: IFFALSE 36648
// begin if UnitsInside ( j ) < 6 then
36619: LD_VAR 0 3
36623: PPUSH
36624: CALL_OW 313
36628: PUSH
36629: LD_INT 6
36631: LESS
36632: IFFALSE 36646
// begin selected := j ;
36634: LD_ADDR_VAR 0 7
36638: PUSH
36639: LD_VAR 0 3
36643: ST_TO_ADDR
// break ;
36644: GO 36648
// end ; end ;
36646: GO 36616
36648: POP
36649: POP
// if selected then
36650: LD_VAR 0 7
36654: IFFALSE 36753
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36656: LD_ADDR_VAR 0 3
36660: PUSH
36661: LD_EXP 79
36665: PUSH
36666: LD_VAR 0 2
36670: ARRAY
36671: PPUSH
36672: LD_INT 25
36674: PUSH
36675: LD_INT 12
36677: PUSH
36678: EMPTY
36679: LIST
36680: LIST
36681: PPUSH
36682: CALL_OW 72
36686: PUSH
36687: FOR_IN
36688: IFFALSE 36751
// if not HasTask ( j ) then
36690: LD_VAR 0 3
36694: PPUSH
36695: CALL_OW 314
36699: NOT
36700: IFFALSE 36749
// begin if not IsInUnit ( j ) then
36702: LD_VAR 0 3
36706: PPUSH
36707: CALL_OW 310
36711: NOT
36712: IFFALSE 36728
// ComEnterUnit ( j , selected ) ;
36714: LD_VAR 0 3
36718: PPUSH
36719: LD_VAR 0 7
36723: PPUSH
36724: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
36728: LD_VAR 0 3
36732: PPUSH
36733: LD_INT 16
36735: PPUSH
36736: CALL_OW 183
// AddComExitBuilding ( j ) ;
36740: LD_VAR 0 3
36744: PPUSH
36745: CALL_OW 182
// end ;
36749: GO 36687
36751: POP
36752: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
36753: LD_VAR 0 5
36757: PPUSH
36758: LD_INT 11
36760: PPUSH
36761: CALL_OW 325
36765: IFFALSE 37024
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36767: LD_ADDR_VAR 0 4
36771: PUSH
36772: LD_EXP 79
36776: PUSH
36777: LD_VAR 0 2
36781: ARRAY
36782: PPUSH
36783: LD_INT 25
36785: PUSH
36786: LD_INT 16
36788: PUSH
36789: EMPTY
36790: LIST
36791: LIST
36792: PPUSH
36793: CALL_OW 72
36797: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
36798: LD_VAR 0 4
36802: PUSH
36803: LD_INT 6
36805: GREATEREQUAL
36806: PUSH
36807: LD_VAR 0 5
36811: PPUSH
36812: LD_INT 2
36814: PPUSH
36815: CALL_OW 325
36819: NOT
36820: OR
36821: IFFALSE 37024
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
36823: LD_ADDR_VAR 0 8
36827: PUSH
36828: LD_EXP 50
36832: PUSH
36833: LD_VAR 0 2
36837: ARRAY
36838: PPUSH
36839: LD_INT 2
36841: PUSH
36842: LD_INT 30
36844: PUSH
36845: LD_INT 4
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 30
36854: PUSH
36855: LD_INT 5
36857: PUSH
36858: EMPTY
36859: LIST
36860: LIST
36861: PUSH
36862: EMPTY
36863: LIST
36864: LIST
36865: LIST
36866: PPUSH
36867: CALL_OW 72
36871: ST_TO_ADDR
// if barracks then
36872: LD_VAR 0 8
36876: IFFALSE 37024
// begin selected := 0 ;
36878: LD_ADDR_VAR 0 7
36882: PUSH
36883: LD_INT 0
36885: ST_TO_ADDR
// for j in barracks do
36886: LD_ADDR_VAR 0 3
36890: PUSH
36891: LD_VAR 0 8
36895: PUSH
36896: FOR_IN
36897: IFFALSE 36928
// begin if UnitsInside ( j ) < 6 then
36899: LD_VAR 0 3
36903: PPUSH
36904: CALL_OW 313
36908: PUSH
36909: LD_INT 6
36911: LESS
36912: IFFALSE 36926
// begin selected := j ;
36914: LD_ADDR_VAR 0 7
36918: PUSH
36919: LD_VAR 0 3
36923: ST_TO_ADDR
// break ;
36924: GO 36928
// end ; end ;
36926: GO 36896
36928: POP
36929: POP
// if selected then
36930: LD_VAR 0 7
36934: IFFALSE 37024
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36936: LD_ADDR_VAR 0 3
36940: PUSH
36941: LD_EXP 79
36945: PUSH
36946: LD_VAR 0 2
36950: ARRAY
36951: PPUSH
36952: LD_INT 25
36954: PUSH
36955: LD_INT 12
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PPUSH
36962: CALL_OW 72
36966: PUSH
36967: FOR_IN
36968: IFFALSE 37022
// if not IsInUnit ( j ) and not HasTask ( j ) then
36970: LD_VAR 0 3
36974: PPUSH
36975: CALL_OW 310
36979: NOT
36980: PUSH
36981: LD_VAR 0 3
36985: PPUSH
36986: CALL_OW 314
36990: NOT
36991: AND
36992: IFFALSE 37020
// begin ComEnterUnit ( j , selected ) ;
36994: LD_VAR 0 3
36998: PPUSH
36999: LD_VAR 0 7
37003: PPUSH
37004: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
37008: LD_VAR 0 3
37012: PPUSH
37013: LD_INT 15
37015: PPUSH
37016: CALL_OW 183
// end ;
37020: GO 36967
37022: POP
37023: POP
// end ; end ; end ; end ; end ;
37024: GO 36417
37026: POP
37027: POP
// end ;
37028: LD_VAR 0 1
37032: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
37033: LD_INT 0
37035: PPUSH
37036: PPUSH
37037: PPUSH
37038: PPUSH
// if not mc_bases then
37039: LD_EXP 50
37043: NOT
37044: IFFALSE 37048
// exit ;
37046: GO 37226
// for i = 1 to mc_bases do
37048: LD_ADDR_VAR 0 2
37052: PUSH
37053: DOUBLE
37054: LD_INT 1
37056: DEC
37057: ST_TO_ADDR
37058: LD_EXP 50
37062: PUSH
37063: FOR_TO
37064: IFFALSE 37224
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
37066: LD_ADDR_VAR 0 4
37070: PUSH
37071: LD_EXP 50
37075: PUSH
37076: LD_VAR 0 2
37080: ARRAY
37081: PPUSH
37082: LD_INT 25
37084: PUSH
37085: LD_INT 9
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PPUSH
37092: CALL_OW 72
37096: ST_TO_ADDR
// if not tmp then
37097: LD_VAR 0 4
37101: NOT
37102: IFFALSE 37106
// continue ;
37104: GO 37063
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
37106: LD_EXP 76
37110: PUSH
37111: LD_VAR 0 2
37115: ARRAY
37116: PPUSH
37117: LD_INT 29
37119: PPUSH
37120: CALL_OW 325
37124: NOT
37125: PUSH
37126: LD_EXP 76
37130: PUSH
37131: LD_VAR 0 2
37135: ARRAY
37136: PPUSH
37137: LD_INT 28
37139: PPUSH
37140: CALL_OW 325
37144: NOT
37145: AND
37146: IFFALSE 37150
// continue ;
37148: GO 37063
// for j in tmp do
37150: LD_ADDR_VAR 0 3
37154: PUSH
37155: LD_VAR 0 4
37159: PUSH
37160: FOR_IN
37161: IFFALSE 37220
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37163: LD_VAR 0 3
37167: PUSH
37168: LD_EXP 53
37172: PUSH
37173: LD_VAR 0 2
37177: ARRAY
37178: PUSH
37179: LD_INT 1
37181: ARRAY
37182: IN
37183: NOT
37184: PUSH
37185: LD_VAR 0 3
37189: PUSH
37190: LD_EXP 53
37194: PUSH
37195: LD_VAR 0 2
37199: ARRAY
37200: PUSH
37201: LD_INT 2
37203: ARRAY
37204: IN
37205: NOT
37206: AND
37207: IFFALSE 37218
// ComSpaceTimeShoot ( j ) ;
37209: LD_VAR 0 3
37213: PPUSH
37214: CALL 48364 0 1
37218: GO 37160
37220: POP
37221: POP
// end ;
37222: GO 37063
37224: POP
37225: POP
// end ;
37226: LD_VAR 0 1
37230: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37231: LD_INT 0
37233: PPUSH
37234: PPUSH
37235: PPUSH
37236: PPUSH
37237: PPUSH
37238: PPUSH
37239: PPUSH
37240: PPUSH
37241: PPUSH
// if not mc_bases then
37242: LD_EXP 50
37246: NOT
37247: IFFALSE 37251
// exit ;
37249: GO 37873
// for i = 1 to mc_bases do
37251: LD_ADDR_VAR 0 2
37255: PUSH
37256: DOUBLE
37257: LD_INT 1
37259: DEC
37260: ST_TO_ADDR
37261: LD_EXP 50
37265: PUSH
37266: FOR_TO
37267: IFFALSE 37871
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37269: LD_EXP 85
37273: PUSH
37274: LD_VAR 0 2
37278: ARRAY
37279: NOT
37280: PUSH
37281: LD_INT 38
37283: PPUSH
37284: LD_EXP 76
37288: PUSH
37289: LD_VAR 0 2
37293: ARRAY
37294: PPUSH
37295: CALL_OW 321
37299: PUSH
37300: LD_INT 2
37302: NONEQUAL
37303: OR
37304: IFFALSE 37308
// continue ;
37306: GO 37266
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37308: LD_ADDR_VAR 0 8
37312: PUSH
37313: LD_EXP 50
37317: PUSH
37318: LD_VAR 0 2
37322: ARRAY
37323: PPUSH
37324: LD_INT 30
37326: PUSH
37327: LD_INT 34
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PPUSH
37334: CALL_OW 72
37338: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
37339: LD_ADDR_VAR 0 9
37343: PUSH
37344: LD_EXP 50
37348: PUSH
37349: LD_VAR 0 2
37353: ARRAY
37354: PPUSH
37355: LD_INT 25
37357: PUSH
37358: LD_INT 4
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PPUSH
37365: CALL_OW 72
37369: PPUSH
37370: LD_INT 0
37372: PPUSH
37373: CALL 80928 0 2
37377: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
37378: LD_VAR 0 9
37382: NOT
37383: PUSH
37384: LD_VAR 0 8
37388: NOT
37389: OR
37390: PUSH
37391: LD_EXP 50
37395: PUSH
37396: LD_VAR 0 2
37400: ARRAY
37401: PPUSH
37402: LD_INT 124
37404: PPUSH
37405: CALL 80928 0 2
37409: OR
37410: IFFALSE 37414
// continue ;
37412: GO 37266
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
37414: LD_EXP 86
37418: PUSH
37419: LD_VAR 0 2
37423: ARRAY
37424: PUSH
37425: LD_EXP 85
37429: PUSH
37430: LD_VAR 0 2
37434: ARRAY
37435: LESS
37436: PUSH
37437: LD_EXP 86
37441: PUSH
37442: LD_VAR 0 2
37446: ARRAY
37447: PUSH
37448: LD_VAR 0 8
37452: LESS
37453: AND
37454: IFFALSE 37869
// begin tmp := sci [ 1 ] ;
37456: LD_ADDR_VAR 0 7
37460: PUSH
37461: LD_VAR 0 9
37465: PUSH
37466: LD_INT 1
37468: ARRAY
37469: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37470: LD_VAR 0 7
37474: PPUSH
37475: LD_INT 124
37477: PPUSH
37478: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
37482: LD_ADDR_VAR 0 3
37486: PUSH
37487: DOUBLE
37488: LD_EXP 85
37492: PUSH
37493: LD_VAR 0 2
37497: ARRAY
37498: INC
37499: ST_TO_ADDR
37500: LD_EXP 85
37504: PUSH
37505: LD_VAR 0 2
37509: ARRAY
37510: PUSH
37511: FOR_DOWNTO
37512: IFFALSE 37855
// begin if IsInUnit ( tmp ) then
37514: LD_VAR 0 7
37518: PPUSH
37519: CALL_OW 310
37523: IFFALSE 37534
// ComExitBuilding ( tmp ) ;
37525: LD_VAR 0 7
37529: PPUSH
37530: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
37534: LD_INT 35
37536: PPUSH
37537: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
37541: LD_VAR 0 7
37545: PPUSH
37546: CALL_OW 310
37550: NOT
37551: PUSH
37552: LD_VAR 0 7
37556: PPUSH
37557: CALL_OW 314
37561: NOT
37562: AND
37563: IFFALSE 37534
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
37565: LD_ADDR_VAR 0 6
37569: PUSH
37570: LD_VAR 0 7
37574: PPUSH
37575: CALL_OW 250
37579: PUSH
37580: LD_VAR 0 7
37584: PPUSH
37585: CALL_OW 251
37589: PUSH
37590: EMPTY
37591: LIST
37592: LIST
37593: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37594: LD_INT 35
37596: PPUSH
37597: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
37601: LD_ADDR_VAR 0 4
37605: PUSH
37606: LD_EXP 85
37610: PUSH
37611: LD_VAR 0 2
37615: ARRAY
37616: PUSH
37617: LD_VAR 0 3
37621: ARRAY
37622: PUSH
37623: LD_INT 1
37625: ARRAY
37626: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
37627: LD_ADDR_VAR 0 5
37631: PUSH
37632: LD_EXP 85
37636: PUSH
37637: LD_VAR 0 2
37641: ARRAY
37642: PUSH
37643: LD_VAR 0 3
37647: ARRAY
37648: PUSH
37649: LD_INT 2
37651: ARRAY
37652: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
37653: LD_VAR 0 7
37657: PPUSH
37658: LD_INT 10
37660: PPUSH
37661: CALL 54960 0 2
37665: PUSH
37666: LD_INT 4
37668: ARRAY
37669: IFFALSE 37707
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
37671: LD_VAR 0 7
37675: PPUSH
37676: LD_VAR 0 6
37680: PUSH
37681: LD_INT 1
37683: ARRAY
37684: PPUSH
37685: LD_VAR 0 6
37689: PUSH
37690: LD_INT 2
37692: ARRAY
37693: PPUSH
37694: CALL_OW 111
// wait ( 0 0$10 ) ;
37698: LD_INT 350
37700: PPUSH
37701: CALL_OW 67
// end else
37705: GO 37733
// begin ComMoveXY ( tmp , x , y ) ;
37707: LD_VAR 0 7
37711: PPUSH
37712: LD_VAR 0 4
37716: PPUSH
37717: LD_VAR 0 5
37721: PPUSH
37722: CALL_OW 111
// wait ( 0 0$3 ) ;
37726: LD_INT 105
37728: PPUSH
37729: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
37733: LD_VAR 0 7
37737: PPUSH
37738: LD_VAR 0 4
37742: PPUSH
37743: LD_VAR 0 5
37747: PPUSH
37748: CALL_OW 307
37752: IFFALSE 37594
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
37754: LD_VAR 0 7
37758: PPUSH
37759: LD_VAR 0 4
37763: PPUSH
37764: LD_VAR 0 5
37768: PPUSH
37769: LD_VAR 0 8
37773: PUSH
37774: LD_VAR 0 3
37778: ARRAY
37779: PPUSH
37780: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
37784: LD_INT 35
37786: PPUSH
37787: CALL_OW 67
// until not HasTask ( tmp ) ;
37791: LD_VAR 0 7
37795: PPUSH
37796: CALL_OW 314
37800: NOT
37801: IFFALSE 37784
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
37803: LD_ADDR_EXP 86
37807: PUSH
37808: LD_EXP 86
37812: PPUSH
37813: LD_VAR 0 2
37817: PUSH
37818: LD_EXP 86
37822: PUSH
37823: LD_VAR 0 2
37827: ARRAY
37828: PUSH
37829: LD_INT 1
37831: PLUS
37832: PUSH
37833: EMPTY
37834: LIST
37835: LIST
37836: PPUSH
37837: LD_VAR 0 8
37841: PUSH
37842: LD_VAR 0 3
37846: ARRAY
37847: PPUSH
37848: CALL 52367 0 3
37852: ST_TO_ADDR
// end ;
37853: GO 37511
37855: POP
37856: POP
// MC_Reset ( i , 124 ) ;
37857: LD_VAR 0 2
37861: PPUSH
37862: LD_INT 124
37864: PPUSH
37865: CALL 21460 0 2
// end ; end ;
37869: GO 37266
37871: POP
37872: POP
// end ;
37873: LD_VAR 0 1
37877: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
37878: LD_INT 0
37880: PPUSH
37881: PPUSH
37882: PPUSH
// if not mc_bases then
37883: LD_EXP 50
37887: NOT
37888: IFFALSE 37892
// exit ;
37890: GO 38498
// for i = 1 to mc_bases do
37892: LD_ADDR_VAR 0 2
37896: PUSH
37897: DOUBLE
37898: LD_INT 1
37900: DEC
37901: ST_TO_ADDR
37902: LD_EXP 50
37906: PUSH
37907: FOR_TO
37908: IFFALSE 38496
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
37910: LD_ADDR_VAR 0 3
37914: PUSH
37915: LD_EXP 50
37919: PUSH
37920: LD_VAR 0 2
37924: ARRAY
37925: PPUSH
37926: LD_INT 25
37928: PUSH
37929: LD_INT 4
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: PPUSH
37936: CALL_OW 72
37940: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
37941: LD_VAR 0 3
37945: NOT
37946: PUSH
37947: LD_EXP 87
37951: PUSH
37952: LD_VAR 0 2
37956: ARRAY
37957: NOT
37958: OR
37959: PUSH
37960: LD_EXP 50
37964: PUSH
37965: LD_VAR 0 2
37969: ARRAY
37970: PPUSH
37971: LD_INT 2
37973: PUSH
37974: LD_INT 30
37976: PUSH
37977: LD_INT 0
37979: PUSH
37980: EMPTY
37981: LIST
37982: LIST
37983: PUSH
37984: LD_INT 30
37986: PUSH
37987: LD_INT 1
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: LIST
37998: PPUSH
37999: CALL_OW 72
38003: NOT
38004: OR
38005: IFFALSE 38055
// begin if mc_deposits_finder [ i ] then
38007: LD_EXP 88
38011: PUSH
38012: LD_VAR 0 2
38016: ARRAY
38017: IFFALSE 38053
// begin MC_Reset ( i , 125 ) ;
38019: LD_VAR 0 2
38023: PPUSH
38024: LD_INT 125
38026: PPUSH
38027: CALL 21460 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38031: LD_ADDR_EXP 88
38035: PUSH
38036: LD_EXP 88
38040: PPUSH
38041: LD_VAR 0 2
38045: PPUSH
38046: EMPTY
38047: PPUSH
38048: CALL_OW 1
38052: ST_TO_ADDR
// end ; continue ;
38053: GO 37907
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
38055: LD_EXP 87
38059: PUSH
38060: LD_VAR 0 2
38064: ARRAY
38065: PUSH
38066: LD_INT 1
38068: ARRAY
38069: PUSH
38070: LD_INT 3
38072: ARRAY
38073: PUSH
38074: LD_INT 1
38076: EQUAL
38077: PUSH
38078: LD_INT 20
38080: PPUSH
38081: LD_EXP 76
38085: PUSH
38086: LD_VAR 0 2
38090: ARRAY
38091: PPUSH
38092: CALL_OW 321
38096: PUSH
38097: LD_INT 2
38099: NONEQUAL
38100: AND
38101: IFFALSE 38151
// begin if mc_deposits_finder [ i ] then
38103: LD_EXP 88
38107: PUSH
38108: LD_VAR 0 2
38112: ARRAY
38113: IFFALSE 38149
// begin MC_Reset ( i , 125 ) ;
38115: LD_VAR 0 2
38119: PPUSH
38120: LD_INT 125
38122: PPUSH
38123: CALL 21460 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38127: LD_ADDR_EXP 88
38131: PUSH
38132: LD_EXP 88
38136: PPUSH
38137: LD_VAR 0 2
38141: PPUSH
38142: EMPTY
38143: PPUSH
38144: CALL_OW 1
38148: ST_TO_ADDR
// end ; continue ;
38149: GO 37907
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
38151: LD_EXP 87
38155: PUSH
38156: LD_VAR 0 2
38160: ARRAY
38161: PUSH
38162: LD_INT 1
38164: ARRAY
38165: PUSH
38166: LD_INT 1
38168: ARRAY
38169: PPUSH
38170: LD_EXP 87
38174: PUSH
38175: LD_VAR 0 2
38179: ARRAY
38180: PUSH
38181: LD_INT 1
38183: ARRAY
38184: PUSH
38185: LD_INT 2
38187: ARRAY
38188: PPUSH
38189: LD_EXP 76
38193: PUSH
38194: LD_VAR 0 2
38198: ARRAY
38199: PPUSH
38200: CALL_OW 440
38204: IFFALSE 38247
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38206: LD_ADDR_EXP 87
38210: PUSH
38211: LD_EXP 87
38215: PPUSH
38216: LD_VAR 0 2
38220: PPUSH
38221: LD_EXP 87
38225: PUSH
38226: LD_VAR 0 2
38230: ARRAY
38231: PPUSH
38232: LD_INT 1
38234: PPUSH
38235: CALL_OW 3
38239: PPUSH
38240: CALL_OW 1
38244: ST_TO_ADDR
38245: GO 38494
// begin if not mc_deposits_finder [ i ] then
38247: LD_EXP 88
38251: PUSH
38252: LD_VAR 0 2
38256: ARRAY
38257: NOT
38258: IFFALSE 38310
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38260: LD_ADDR_EXP 88
38264: PUSH
38265: LD_EXP 88
38269: PPUSH
38270: LD_VAR 0 2
38274: PPUSH
38275: LD_VAR 0 3
38279: PUSH
38280: LD_INT 1
38282: ARRAY
38283: PUSH
38284: EMPTY
38285: LIST
38286: PPUSH
38287: CALL_OW 1
38291: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38292: LD_VAR 0 3
38296: PUSH
38297: LD_INT 1
38299: ARRAY
38300: PPUSH
38301: LD_INT 125
38303: PPUSH
38304: CALL_OW 109
// end else
38308: GO 38494
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
38310: LD_EXP 88
38314: PUSH
38315: LD_VAR 0 2
38319: ARRAY
38320: PUSH
38321: LD_INT 1
38323: ARRAY
38324: PPUSH
38325: CALL_OW 310
38329: IFFALSE 38352
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
38331: LD_EXP 88
38335: PUSH
38336: LD_VAR 0 2
38340: ARRAY
38341: PUSH
38342: LD_INT 1
38344: ARRAY
38345: PPUSH
38346: CALL_OW 122
38350: GO 38494
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
38352: LD_EXP 88
38356: PUSH
38357: LD_VAR 0 2
38361: ARRAY
38362: PUSH
38363: LD_INT 1
38365: ARRAY
38366: PPUSH
38367: CALL_OW 314
38371: NOT
38372: PUSH
38373: LD_EXP 88
38377: PUSH
38378: LD_VAR 0 2
38382: ARRAY
38383: PUSH
38384: LD_INT 1
38386: ARRAY
38387: PPUSH
38388: LD_EXP 87
38392: PUSH
38393: LD_VAR 0 2
38397: ARRAY
38398: PUSH
38399: LD_INT 1
38401: ARRAY
38402: PUSH
38403: LD_INT 1
38405: ARRAY
38406: PPUSH
38407: LD_EXP 87
38411: PUSH
38412: LD_VAR 0 2
38416: ARRAY
38417: PUSH
38418: LD_INT 1
38420: ARRAY
38421: PUSH
38422: LD_INT 2
38424: ARRAY
38425: PPUSH
38426: CALL_OW 297
38430: PUSH
38431: LD_INT 6
38433: GREATER
38434: AND
38435: IFFALSE 38494
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
38437: LD_EXP 88
38441: PUSH
38442: LD_VAR 0 2
38446: ARRAY
38447: PUSH
38448: LD_INT 1
38450: ARRAY
38451: PPUSH
38452: LD_EXP 87
38456: PUSH
38457: LD_VAR 0 2
38461: ARRAY
38462: PUSH
38463: LD_INT 1
38465: ARRAY
38466: PUSH
38467: LD_INT 1
38469: ARRAY
38470: PPUSH
38471: LD_EXP 87
38475: PUSH
38476: LD_VAR 0 2
38480: ARRAY
38481: PUSH
38482: LD_INT 1
38484: ARRAY
38485: PUSH
38486: LD_INT 2
38488: ARRAY
38489: PPUSH
38490: CALL_OW 111
// end ; end ; end ;
38494: GO 37907
38496: POP
38497: POP
// end ;
38498: LD_VAR 0 1
38502: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
38503: LD_INT 0
38505: PPUSH
38506: PPUSH
38507: PPUSH
38508: PPUSH
38509: PPUSH
38510: PPUSH
38511: PPUSH
38512: PPUSH
38513: PPUSH
38514: PPUSH
38515: PPUSH
// if not mc_bases then
38516: LD_EXP 50
38520: NOT
38521: IFFALSE 38525
// exit ;
38523: GO 39465
// for i = 1 to mc_bases do
38525: LD_ADDR_VAR 0 2
38529: PUSH
38530: DOUBLE
38531: LD_INT 1
38533: DEC
38534: ST_TO_ADDR
38535: LD_EXP 50
38539: PUSH
38540: FOR_TO
38541: IFFALSE 39463
// begin if not mc_bases [ i ] or mc_scan [ i ] then
38543: LD_EXP 50
38547: PUSH
38548: LD_VAR 0 2
38552: ARRAY
38553: NOT
38554: PUSH
38555: LD_EXP 73
38559: PUSH
38560: LD_VAR 0 2
38564: ARRAY
38565: OR
38566: IFFALSE 38570
// continue ;
38568: GO 38540
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
38570: LD_ADDR_VAR 0 7
38574: PUSH
38575: LD_EXP 50
38579: PUSH
38580: LD_VAR 0 2
38584: ARRAY
38585: PUSH
38586: LD_INT 1
38588: ARRAY
38589: PPUSH
38590: CALL_OW 248
38594: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
38595: LD_VAR 0 7
38599: PUSH
38600: LD_INT 3
38602: EQUAL
38603: PUSH
38604: LD_EXP 69
38608: PUSH
38609: LD_VAR 0 2
38613: ARRAY
38614: PUSH
38615: LD_EXP 72
38619: PUSH
38620: LD_VAR 0 2
38624: ARRAY
38625: UNION
38626: PPUSH
38627: LD_INT 33
38629: PUSH
38630: LD_INT 2
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PPUSH
38637: CALL_OW 72
38641: NOT
38642: OR
38643: IFFALSE 38647
// continue ;
38645: GO 38540
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
38647: LD_ADDR_VAR 0 9
38651: PUSH
38652: LD_EXP 50
38656: PUSH
38657: LD_VAR 0 2
38661: ARRAY
38662: PPUSH
38663: LD_INT 30
38665: PUSH
38666: LD_INT 36
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PPUSH
38673: CALL_OW 72
38677: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
38678: LD_ADDR_VAR 0 10
38682: PUSH
38683: LD_EXP 69
38687: PUSH
38688: LD_VAR 0 2
38692: ARRAY
38693: PPUSH
38694: LD_INT 34
38696: PUSH
38697: LD_INT 31
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PPUSH
38704: CALL_OW 72
38708: ST_TO_ADDR
// if not cts and not mcts then
38709: LD_VAR 0 9
38713: NOT
38714: PUSH
38715: LD_VAR 0 10
38719: NOT
38720: AND
38721: IFFALSE 38725
// continue ;
38723: GO 38540
// x := cts ;
38725: LD_ADDR_VAR 0 11
38729: PUSH
38730: LD_VAR 0 9
38734: ST_TO_ADDR
// if not x then
38735: LD_VAR 0 11
38739: NOT
38740: IFFALSE 38752
// x := mcts ;
38742: LD_ADDR_VAR 0 11
38746: PUSH
38747: LD_VAR 0 10
38751: ST_TO_ADDR
// if not x then
38752: LD_VAR 0 11
38756: NOT
38757: IFFALSE 38761
// continue ;
38759: GO 38540
// if mc_remote_driver [ i ] then
38761: LD_EXP 90
38765: PUSH
38766: LD_VAR 0 2
38770: ARRAY
38771: IFFALSE 39158
// for j in mc_remote_driver [ i ] do
38773: LD_ADDR_VAR 0 3
38777: PUSH
38778: LD_EXP 90
38782: PUSH
38783: LD_VAR 0 2
38787: ARRAY
38788: PUSH
38789: FOR_IN
38790: IFFALSE 39156
// begin if GetClass ( j ) <> 3 then
38792: LD_VAR 0 3
38796: PPUSH
38797: CALL_OW 257
38801: PUSH
38802: LD_INT 3
38804: NONEQUAL
38805: IFFALSE 38858
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
38807: LD_ADDR_EXP 90
38811: PUSH
38812: LD_EXP 90
38816: PPUSH
38817: LD_VAR 0 2
38821: PPUSH
38822: LD_EXP 90
38826: PUSH
38827: LD_VAR 0 2
38831: ARRAY
38832: PUSH
38833: LD_VAR 0 3
38837: DIFF
38838: PPUSH
38839: CALL_OW 1
38843: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38844: LD_VAR 0 3
38848: PPUSH
38849: LD_INT 0
38851: PPUSH
38852: CALL_OW 109
// continue ;
38856: GO 38789
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
38858: LD_EXP 69
38862: PUSH
38863: LD_VAR 0 2
38867: ARRAY
38868: PPUSH
38869: LD_INT 34
38871: PUSH
38872: LD_INT 31
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 58
38881: PUSH
38882: EMPTY
38883: LIST
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PPUSH
38889: CALL_OW 72
38893: PUSH
38894: LD_VAR 0 3
38898: PPUSH
38899: CALL 81016 0 1
38903: NOT
38904: AND
38905: IFFALSE 38976
// begin if IsInUnit ( j ) then
38907: LD_VAR 0 3
38911: PPUSH
38912: CALL_OW 310
38916: IFFALSE 38927
// ComExitBuilding ( j ) ;
38918: LD_VAR 0 3
38922: PPUSH
38923: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
38927: LD_VAR 0 3
38931: PPUSH
38932: LD_EXP 69
38936: PUSH
38937: LD_VAR 0 2
38941: ARRAY
38942: PPUSH
38943: LD_INT 34
38945: PUSH
38946: LD_INT 31
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PUSH
38953: LD_INT 58
38955: PUSH
38956: EMPTY
38957: LIST
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PPUSH
38963: CALL_OW 72
38967: PUSH
38968: LD_INT 1
38970: ARRAY
38971: PPUSH
38972: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
38976: LD_VAR 0 3
38980: PPUSH
38981: CALL_OW 310
38985: NOT
38986: PUSH
38987: LD_VAR 0 3
38991: PPUSH
38992: CALL_OW 310
38996: PPUSH
38997: CALL_OW 266
39001: PUSH
39002: LD_INT 36
39004: NONEQUAL
39005: PUSH
39006: LD_VAR 0 3
39010: PPUSH
39011: CALL 81016 0 1
39015: NOT
39016: AND
39017: OR
39018: IFFALSE 39154
// begin if IsInUnit ( j ) then
39020: LD_VAR 0 3
39024: PPUSH
39025: CALL_OW 310
39029: IFFALSE 39040
// ComExitBuilding ( j ) ;
39031: LD_VAR 0 3
39035: PPUSH
39036: CALL_OW 122
// ct := 0 ;
39040: LD_ADDR_VAR 0 8
39044: PUSH
39045: LD_INT 0
39047: ST_TO_ADDR
// for k in x do
39048: LD_ADDR_VAR 0 4
39052: PUSH
39053: LD_VAR 0 11
39057: PUSH
39058: FOR_IN
39059: IFFALSE 39132
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
39061: LD_VAR 0 4
39065: PPUSH
39066: CALL_OW 264
39070: PUSH
39071: LD_INT 31
39073: EQUAL
39074: PUSH
39075: LD_VAR 0 4
39079: PPUSH
39080: CALL_OW 311
39084: NOT
39085: AND
39086: PUSH
39087: LD_VAR 0 4
39091: PPUSH
39092: CALL_OW 266
39096: PUSH
39097: LD_INT 36
39099: EQUAL
39100: PUSH
39101: LD_VAR 0 4
39105: PPUSH
39106: CALL_OW 313
39110: PUSH
39111: LD_INT 3
39113: LESS
39114: AND
39115: OR
39116: IFFALSE 39130
// begin ct := k ;
39118: LD_ADDR_VAR 0 8
39122: PUSH
39123: LD_VAR 0 4
39127: ST_TO_ADDR
// break ;
39128: GO 39132
// end ;
39130: GO 39058
39132: POP
39133: POP
// if ct then
39134: LD_VAR 0 8
39138: IFFALSE 39154
// ComEnterUnit ( j , ct ) ;
39140: LD_VAR 0 3
39144: PPUSH
39145: LD_VAR 0 8
39149: PPUSH
39150: CALL_OW 120
// end ; end ;
39154: GO 38789
39156: POP
39157: POP
// places := 0 ;
39158: LD_ADDR_VAR 0 5
39162: PUSH
39163: LD_INT 0
39165: ST_TO_ADDR
// for j = 1 to x do
39166: LD_ADDR_VAR 0 3
39170: PUSH
39171: DOUBLE
39172: LD_INT 1
39174: DEC
39175: ST_TO_ADDR
39176: LD_VAR 0 11
39180: PUSH
39181: FOR_TO
39182: IFFALSE 39258
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39184: LD_VAR 0 11
39188: PUSH
39189: LD_VAR 0 3
39193: ARRAY
39194: PPUSH
39195: CALL_OW 264
39199: PUSH
39200: LD_INT 31
39202: EQUAL
39203: IFFALSE 39221
// places := places + 1 else
39205: LD_ADDR_VAR 0 5
39209: PUSH
39210: LD_VAR 0 5
39214: PUSH
39215: LD_INT 1
39217: PLUS
39218: ST_TO_ADDR
39219: GO 39256
// if GetBType ( x [ j ] ) = b_control_tower then
39221: LD_VAR 0 11
39225: PUSH
39226: LD_VAR 0 3
39230: ARRAY
39231: PPUSH
39232: CALL_OW 266
39236: PUSH
39237: LD_INT 36
39239: EQUAL
39240: IFFALSE 39256
// places := places + 3 ;
39242: LD_ADDR_VAR 0 5
39246: PUSH
39247: LD_VAR 0 5
39251: PUSH
39252: LD_INT 3
39254: PLUS
39255: ST_TO_ADDR
39256: GO 39181
39258: POP
39259: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39260: LD_VAR 0 5
39264: PUSH
39265: LD_INT 0
39267: EQUAL
39268: PUSH
39269: LD_VAR 0 5
39273: PUSH
39274: LD_EXP 90
39278: PUSH
39279: LD_VAR 0 2
39283: ARRAY
39284: LESSEQUAL
39285: OR
39286: IFFALSE 39290
// continue ;
39288: GO 38540
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39290: LD_ADDR_VAR 0 6
39294: PUSH
39295: LD_EXP 50
39299: PUSH
39300: LD_VAR 0 2
39304: ARRAY
39305: PPUSH
39306: LD_INT 25
39308: PUSH
39309: LD_INT 3
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PPUSH
39316: CALL_OW 72
39320: PUSH
39321: LD_EXP 90
39325: PUSH
39326: LD_VAR 0 2
39330: ARRAY
39331: DIFF
39332: PPUSH
39333: LD_INT 3
39335: PPUSH
39336: CALL 81916 0 2
39340: ST_TO_ADDR
// for j in tmp do
39341: LD_ADDR_VAR 0 3
39345: PUSH
39346: LD_VAR 0 6
39350: PUSH
39351: FOR_IN
39352: IFFALSE 39387
// if GetTag ( j ) > 0 then
39354: LD_VAR 0 3
39358: PPUSH
39359: CALL_OW 110
39363: PUSH
39364: LD_INT 0
39366: GREATER
39367: IFFALSE 39385
// tmp := tmp diff j ;
39369: LD_ADDR_VAR 0 6
39373: PUSH
39374: LD_VAR 0 6
39378: PUSH
39379: LD_VAR 0 3
39383: DIFF
39384: ST_TO_ADDR
39385: GO 39351
39387: POP
39388: POP
// if not tmp then
39389: LD_VAR 0 6
39393: NOT
39394: IFFALSE 39398
// continue ;
39396: GO 38540
// if places then
39398: LD_VAR 0 5
39402: IFFALSE 39461
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
39404: LD_ADDR_EXP 90
39408: PUSH
39409: LD_EXP 90
39413: PPUSH
39414: LD_VAR 0 2
39418: PPUSH
39419: LD_EXP 90
39423: PUSH
39424: LD_VAR 0 2
39428: ARRAY
39429: PUSH
39430: LD_VAR 0 6
39434: PUSH
39435: LD_INT 1
39437: ARRAY
39438: UNION
39439: PPUSH
39440: CALL_OW 1
39444: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
39445: LD_VAR 0 6
39449: PUSH
39450: LD_INT 1
39452: ARRAY
39453: PPUSH
39454: LD_INT 126
39456: PPUSH
39457: CALL_OW 109
// end ; end ;
39461: GO 38540
39463: POP
39464: POP
// end ;
39465: LD_VAR 0 1
39469: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
39470: LD_INT 0
39472: PPUSH
39473: PPUSH
39474: PPUSH
39475: PPUSH
39476: PPUSH
39477: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
39478: LD_VAR 0 1
39482: NOT
39483: PUSH
39484: LD_VAR 0 2
39488: NOT
39489: OR
39490: PUSH
39491: LD_VAR 0 3
39495: NOT
39496: OR
39497: PUSH
39498: LD_VAR 0 4
39502: PUSH
39503: LD_INT 1
39505: PUSH
39506: LD_INT 2
39508: PUSH
39509: LD_INT 3
39511: PUSH
39512: LD_INT 4
39514: PUSH
39515: LD_INT 5
39517: PUSH
39518: LD_INT 8
39520: PUSH
39521: LD_INT 9
39523: PUSH
39524: LD_INT 15
39526: PUSH
39527: LD_INT 16
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: LIST
39538: LIST
39539: LIST
39540: IN
39541: NOT
39542: OR
39543: IFFALSE 39547
// exit ;
39545: GO 40447
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
39547: LD_ADDR_VAR 0 2
39551: PUSH
39552: LD_VAR 0 2
39556: PPUSH
39557: LD_INT 21
39559: PUSH
39560: LD_INT 3
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 24
39569: PUSH
39570: LD_INT 250
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PPUSH
39581: CALL_OW 72
39585: ST_TO_ADDR
// case class of 1 , 15 :
39586: LD_VAR 0 4
39590: PUSH
39591: LD_INT 1
39593: DOUBLE
39594: EQUAL
39595: IFTRUE 39605
39597: LD_INT 15
39599: DOUBLE
39600: EQUAL
39601: IFTRUE 39605
39603: GO 39690
39605: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
39606: LD_ADDR_VAR 0 8
39610: PUSH
39611: LD_VAR 0 2
39615: PPUSH
39616: LD_INT 2
39618: PUSH
39619: LD_INT 30
39621: PUSH
39622: LD_INT 32
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: PUSH
39629: LD_INT 30
39631: PUSH
39632: LD_INT 31
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: LIST
39643: PPUSH
39644: CALL_OW 72
39648: PUSH
39649: LD_VAR 0 2
39653: PPUSH
39654: LD_INT 2
39656: PUSH
39657: LD_INT 30
39659: PUSH
39660: LD_INT 4
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 30
39669: PUSH
39670: LD_INT 5
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: LIST
39681: PPUSH
39682: CALL_OW 72
39686: ADD
39687: ST_TO_ADDR
39688: GO 39936
39690: LD_INT 2
39692: DOUBLE
39693: EQUAL
39694: IFTRUE 39704
39696: LD_INT 16
39698: DOUBLE
39699: EQUAL
39700: IFTRUE 39704
39702: GO 39750
39704: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
39705: LD_ADDR_VAR 0 8
39709: PUSH
39710: LD_VAR 0 2
39714: PPUSH
39715: LD_INT 2
39717: PUSH
39718: LD_INT 30
39720: PUSH
39721: LD_INT 0
39723: PUSH
39724: EMPTY
39725: LIST
39726: LIST
39727: PUSH
39728: LD_INT 30
39730: PUSH
39731: LD_INT 1
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: LIST
39742: PPUSH
39743: CALL_OW 72
39747: ST_TO_ADDR
39748: GO 39936
39750: LD_INT 3
39752: DOUBLE
39753: EQUAL
39754: IFTRUE 39758
39756: GO 39804
39758: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
39759: LD_ADDR_VAR 0 8
39763: PUSH
39764: LD_VAR 0 2
39768: PPUSH
39769: LD_INT 2
39771: PUSH
39772: LD_INT 30
39774: PUSH
39775: LD_INT 2
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: PUSH
39782: LD_INT 30
39784: PUSH
39785: LD_INT 3
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: LIST
39796: PPUSH
39797: CALL_OW 72
39801: ST_TO_ADDR
39802: GO 39936
39804: LD_INT 4
39806: DOUBLE
39807: EQUAL
39808: IFTRUE 39812
39810: GO 39869
39812: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
39813: LD_ADDR_VAR 0 8
39817: PUSH
39818: LD_VAR 0 2
39822: PPUSH
39823: LD_INT 2
39825: PUSH
39826: LD_INT 30
39828: PUSH
39829: LD_INT 6
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: LD_INT 30
39838: PUSH
39839: LD_INT 7
39841: PUSH
39842: EMPTY
39843: LIST
39844: LIST
39845: PUSH
39846: LD_INT 30
39848: PUSH
39849: LD_INT 8
39851: PUSH
39852: EMPTY
39853: LIST
39854: LIST
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: LIST
39860: LIST
39861: PPUSH
39862: CALL_OW 72
39866: ST_TO_ADDR
39867: GO 39936
39869: LD_INT 5
39871: DOUBLE
39872: EQUAL
39873: IFTRUE 39889
39875: LD_INT 8
39877: DOUBLE
39878: EQUAL
39879: IFTRUE 39889
39881: LD_INT 9
39883: DOUBLE
39884: EQUAL
39885: IFTRUE 39889
39887: GO 39935
39889: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
39890: LD_ADDR_VAR 0 8
39894: PUSH
39895: LD_VAR 0 2
39899: PPUSH
39900: LD_INT 2
39902: PUSH
39903: LD_INT 30
39905: PUSH
39906: LD_INT 4
39908: PUSH
39909: EMPTY
39910: LIST
39911: LIST
39912: PUSH
39913: LD_INT 30
39915: PUSH
39916: LD_INT 5
39918: PUSH
39919: EMPTY
39920: LIST
39921: LIST
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: LIST
39927: PPUSH
39928: CALL_OW 72
39932: ST_TO_ADDR
39933: GO 39936
39935: POP
// if not tmp then
39936: LD_VAR 0 8
39940: NOT
39941: IFFALSE 39945
// exit ;
39943: GO 40447
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
39945: LD_VAR 0 4
39949: PUSH
39950: LD_INT 1
39952: PUSH
39953: LD_INT 15
39955: PUSH
39956: EMPTY
39957: LIST
39958: LIST
39959: IN
39960: PUSH
39961: LD_EXP 59
39965: PUSH
39966: LD_VAR 0 1
39970: ARRAY
39971: AND
39972: IFFALSE 40128
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
39974: LD_ADDR_VAR 0 9
39978: PUSH
39979: LD_EXP 59
39983: PUSH
39984: LD_VAR 0 1
39988: ARRAY
39989: PUSH
39990: LD_INT 1
39992: ARRAY
39993: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
39994: LD_VAR 0 9
39998: PUSH
39999: LD_EXP 60
40003: PUSH
40004: LD_VAR 0 1
40008: ARRAY
40009: IN
40010: NOT
40011: IFFALSE 40126
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
40013: LD_ADDR_EXP 60
40017: PUSH
40018: LD_EXP 60
40022: PPUSH
40023: LD_VAR 0 1
40027: PUSH
40028: LD_EXP 60
40032: PUSH
40033: LD_VAR 0 1
40037: ARRAY
40038: PUSH
40039: LD_INT 1
40041: PLUS
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PPUSH
40047: LD_VAR 0 9
40051: PPUSH
40052: CALL 52367 0 3
40056: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
40057: LD_ADDR_EXP 59
40061: PUSH
40062: LD_EXP 59
40066: PPUSH
40067: LD_VAR 0 1
40071: PPUSH
40072: LD_EXP 59
40076: PUSH
40077: LD_VAR 0 1
40081: ARRAY
40082: PUSH
40083: LD_VAR 0 9
40087: DIFF
40088: PPUSH
40089: CALL_OW 1
40093: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
40094: LD_VAR 0 3
40098: PPUSH
40099: LD_EXP 60
40103: PUSH
40104: LD_VAR 0 1
40108: ARRAY
40109: PUSH
40110: LD_EXP 60
40114: PUSH
40115: LD_VAR 0 1
40119: ARRAY
40120: ARRAY
40121: PPUSH
40122: CALL_OW 120
// end ; exit ;
40126: GO 40447
// end ; if tmp > 1 then
40128: LD_VAR 0 8
40132: PUSH
40133: LD_INT 1
40135: GREATER
40136: IFFALSE 40240
// for i = 2 to tmp do
40138: LD_ADDR_VAR 0 6
40142: PUSH
40143: DOUBLE
40144: LD_INT 2
40146: DEC
40147: ST_TO_ADDR
40148: LD_VAR 0 8
40152: PUSH
40153: FOR_TO
40154: IFFALSE 40238
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
40156: LD_VAR 0 8
40160: PUSH
40161: LD_VAR 0 6
40165: ARRAY
40166: PPUSH
40167: CALL_OW 461
40171: PUSH
40172: LD_INT 6
40174: EQUAL
40175: IFFALSE 40236
// begin x := tmp [ i ] ;
40177: LD_ADDR_VAR 0 9
40181: PUSH
40182: LD_VAR 0 8
40186: PUSH
40187: LD_VAR 0 6
40191: ARRAY
40192: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40193: LD_ADDR_VAR 0 8
40197: PUSH
40198: LD_VAR 0 8
40202: PPUSH
40203: LD_VAR 0 6
40207: PPUSH
40208: CALL_OW 3
40212: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40213: LD_ADDR_VAR 0 8
40217: PUSH
40218: LD_VAR 0 8
40222: PPUSH
40223: LD_INT 1
40225: PPUSH
40226: LD_VAR 0 9
40230: PPUSH
40231: CALL_OW 2
40235: ST_TO_ADDR
// end ;
40236: GO 40153
40238: POP
40239: POP
// for i in tmp do
40240: LD_ADDR_VAR 0 6
40244: PUSH
40245: LD_VAR 0 8
40249: PUSH
40250: FOR_IN
40251: IFFALSE 40320
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40253: LD_VAR 0 6
40257: PPUSH
40258: CALL_OW 313
40262: PUSH
40263: LD_INT 6
40265: LESS
40266: PUSH
40267: LD_VAR 0 6
40271: PPUSH
40272: CALL_OW 266
40276: PUSH
40277: LD_INT 31
40279: PUSH
40280: LD_INT 32
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: IN
40287: NOT
40288: AND
40289: PUSH
40290: LD_VAR 0 6
40294: PPUSH
40295: CALL_OW 313
40299: PUSH
40300: LD_INT 0
40302: EQUAL
40303: OR
40304: IFFALSE 40318
// begin j := i ;
40306: LD_ADDR_VAR 0 7
40310: PUSH
40311: LD_VAR 0 6
40315: ST_TO_ADDR
// break ;
40316: GO 40320
// end ; end ;
40318: GO 40250
40320: POP
40321: POP
// if j then
40322: LD_VAR 0 7
40326: IFFALSE 40344
// ComEnterUnit ( unit , j ) else
40328: LD_VAR 0 3
40332: PPUSH
40333: LD_VAR 0 7
40337: PPUSH
40338: CALL_OW 120
40342: GO 40447
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40344: LD_ADDR_VAR 0 10
40348: PUSH
40349: LD_VAR 0 2
40353: PPUSH
40354: LD_INT 2
40356: PUSH
40357: LD_INT 30
40359: PUSH
40360: LD_INT 0
40362: PUSH
40363: EMPTY
40364: LIST
40365: LIST
40366: PUSH
40367: LD_INT 30
40369: PUSH
40370: LD_INT 1
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: LIST
40381: PPUSH
40382: CALL_OW 72
40386: ST_TO_ADDR
// if depot then
40387: LD_VAR 0 10
40391: IFFALSE 40447
// begin depot := NearestUnitToUnit ( depot , unit ) ;
40393: LD_ADDR_VAR 0 10
40397: PUSH
40398: LD_VAR 0 10
40402: PPUSH
40403: LD_VAR 0 3
40407: PPUSH
40408: CALL_OW 74
40412: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
40413: LD_VAR 0 3
40417: PPUSH
40418: LD_VAR 0 10
40422: PPUSH
40423: CALL_OW 296
40427: PUSH
40428: LD_INT 10
40430: GREATER
40431: IFFALSE 40447
// ComStandNearbyBuilding ( unit , depot ) ;
40433: LD_VAR 0 3
40437: PPUSH
40438: LD_VAR 0 10
40442: PPUSH
40443: CALL 48981 0 2
// end ; end ; end ;
40447: LD_VAR 0 5
40451: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
40452: LD_INT 0
40454: PPUSH
40455: PPUSH
40456: PPUSH
40457: PPUSH
// if not mc_bases then
40458: LD_EXP 50
40462: NOT
40463: IFFALSE 40467
// exit ;
40465: GO 40706
// for i = 1 to mc_bases do
40467: LD_ADDR_VAR 0 2
40471: PUSH
40472: DOUBLE
40473: LD_INT 1
40475: DEC
40476: ST_TO_ADDR
40477: LD_EXP 50
40481: PUSH
40482: FOR_TO
40483: IFFALSE 40704
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
40485: LD_ADDR_VAR 0 4
40489: PUSH
40490: LD_EXP 50
40494: PUSH
40495: LD_VAR 0 2
40499: ARRAY
40500: PPUSH
40501: LD_INT 21
40503: PUSH
40504: LD_INT 1
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PPUSH
40511: CALL_OW 72
40515: PUSH
40516: LD_EXP 79
40520: PUSH
40521: LD_VAR 0 2
40525: ARRAY
40526: UNION
40527: ST_TO_ADDR
// if not tmp then
40528: LD_VAR 0 4
40532: NOT
40533: IFFALSE 40537
// continue ;
40535: GO 40482
// for j in tmp do
40537: LD_ADDR_VAR 0 3
40541: PUSH
40542: LD_VAR 0 4
40546: PUSH
40547: FOR_IN
40548: IFFALSE 40700
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
40550: LD_VAR 0 3
40554: PPUSH
40555: CALL_OW 110
40559: NOT
40560: PUSH
40561: LD_VAR 0 3
40565: PPUSH
40566: CALL_OW 314
40570: NOT
40571: AND
40572: PUSH
40573: LD_VAR 0 3
40577: PPUSH
40578: CALL_OW 311
40582: NOT
40583: AND
40584: PUSH
40585: LD_VAR 0 3
40589: PPUSH
40590: CALL_OW 310
40594: NOT
40595: AND
40596: PUSH
40597: LD_VAR 0 3
40601: PUSH
40602: LD_EXP 53
40606: PUSH
40607: LD_VAR 0 2
40611: ARRAY
40612: PUSH
40613: LD_INT 1
40615: ARRAY
40616: IN
40617: NOT
40618: AND
40619: PUSH
40620: LD_VAR 0 3
40624: PUSH
40625: LD_EXP 53
40629: PUSH
40630: LD_VAR 0 2
40634: ARRAY
40635: PUSH
40636: LD_INT 2
40638: ARRAY
40639: IN
40640: NOT
40641: AND
40642: PUSH
40643: LD_VAR 0 3
40647: PUSH
40648: LD_EXP 62
40652: PUSH
40653: LD_VAR 0 2
40657: ARRAY
40658: IN
40659: NOT
40660: AND
40661: IFFALSE 40698
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
40663: LD_VAR 0 2
40667: PPUSH
40668: LD_EXP 50
40672: PUSH
40673: LD_VAR 0 2
40677: ARRAY
40678: PPUSH
40679: LD_VAR 0 3
40683: PPUSH
40684: LD_VAR 0 3
40688: PPUSH
40689: CALL_OW 257
40693: PPUSH
40694: CALL 39470 0 4
// end ;
40698: GO 40547
40700: POP
40701: POP
// end ;
40702: GO 40482
40704: POP
40705: POP
// end ;
40706: LD_VAR 0 1
40710: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
40711: LD_INT 0
40713: PPUSH
40714: PPUSH
40715: PPUSH
40716: PPUSH
40717: PPUSH
40718: PPUSH
// if not mc_bases [ base ] then
40719: LD_EXP 50
40723: PUSH
40724: LD_VAR 0 1
40728: ARRAY
40729: NOT
40730: IFFALSE 40734
// exit ;
40732: GO 40916
// tmp := [ ] ;
40734: LD_ADDR_VAR 0 6
40738: PUSH
40739: EMPTY
40740: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
40741: LD_ADDR_VAR 0 7
40745: PUSH
40746: LD_VAR 0 3
40750: PPUSH
40751: LD_INT 0
40753: PPUSH
40754: CALL_OW 517
40758: ST_TO_ADDR
// if not list then
40759: LD_VAR 0 7
40763: NOT
40764: IFFALSE 40768
// exit ;
40766: GO 40916
// for i = 1 to amount do
40768: LD_ADDR_VAR 0 5
40772: PUSH
40773: DOUBLE
40774: LD_INT 1
40776: DEC
40777: ST_TO_ADDR
40778: LD_VAR 0 2
40782: PUSH
40783: FOR_TO
40784: IFFALSE 40864
// begin x := rand ( 1 , list [ 1 ] ) ;
40786: LD_ADDR_VAR 0 8
40790: PUSH
40791: LD_INT 1
40793: PPUSH
40794: LD_VAR 0 7
40798: PUSH
40799: LD_INT 1
40801: ARRAY
40802: PPUSH
40803: CALL_OW 12
40807: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
40808: LD_ADDR_VAR 0 6
40812: PUSH
40813: LD_VAR 0 6
40817: PPUSH
40818: LD_VAR 0 5
40822: PPUSH
40823: LD_VAR 0 7
40827: PUSH
40828: LD_INT 1
40830: ARRAY
40831: PUSH
40832: LD_VAR 0 8
40836: ARRAY
40837: PUSH
40838: LD_VAR 0 7
40842: PUSH
40843: LD_INT 2
40845: ARRAY
40846: PUSH
40847: LD_VAR 0 8
40851: ARRAY
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PPUSH
40857: CALL_OW 1
40861: ST_TO_ADDR
// end ;
40862: GO 40783
40864: POP
40865: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
40866: LD_ADDR_EXP 63
40870: PUSH
40871: LD_EXP 63
40875: PPUSH
40876: LD_VAR 0 1
40880: PPUSH
40881: LD_VAR 0 6
40885: PPUSH
40886: CALL_OW 1
40890: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
40891: LD_ADDR_EXP 65
40895: PUSH
40896: LD_EXP 65
40900: PPUSH
40901: LD_VAR 0 1
40905: PPUSH
40906: LD_VAR 0 3
40910: PPUSH
40911: CALL_OW 1
40915: ST_TO_ADDR
// end ;
40916: LD_VAR 0 4
40920: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
40921: LD_INT 0
40923: PPUSH
// if not mc_bases [ base ] then
40924: LD_EXP 50
40928: PUSH
40929: LD_VAR 0 1
40933: ARRAY
40934: NOT
40935: IFFALSE 40939
// exit ;
40937: GO 40964
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
40939: LD_ADDR_EXP 55
40943: PUSH
40944: LD_EXP 55
40948: PPUSH
40949: LD_VAR 0 1
40953: PPUSH
40954: LD_VAR 0 2
40958: PPUSH
40959: CALL_OW 1
40963: ST_TO_ADDR
// end ;
40964: LD_VAR 0 3
40968: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
40969: LD_INT 0
40971: PPUSH
// if not mc_bases [ base ] then
40972: LD_EXP 50
40976: PUSH
40977: LD_VAR 0 1
40981: ARRAY
40982: NOT
40983: IFFALSE 40987
// exit ;
40985: GO 41024
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
40987: LD_ADDR_EXP 55
40991: PUSH
40992: LD_EXP 55
40996: PPUSH
40997: LD_VAR 0 1
41001: PPUSH
41002: LD_EXP 55
41006: PUSH
41007: LD_VAR 0 1
41011: ARRAY
41012: PUSH
41013: LD_VAR 0 2
41017: UNION
41018: PPUSH
41019: CALL_OW 1
41023: ST_TO_ADDR
// end ;
41024: LD_VAR 0 3
41028: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
41029: LD_INT 0
41031: PPUSH
// if not mc_bases [ base ] then
41032: LD_EXP 50
41036: PUSH
41037: LD_VAR 0 1
41041: ARRAY
41042: NOT
41043: IFFALSE 41047
// exit ;
41045: GO 41072
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
41047: LD_ADDR_EXP 71
41051: PUSH
41052: LD_EXP 71
41056: PPUSH
41057: LD_VAR 0 1
41061: PPUSH
41062: LD_VAR 0 2
41066: PPUSH
41067: CALL_OW 1
41071: ST_TO_ADDR
// end ;
41072: LD_VAR 0 3
41076: RET
// export function MC_InsertProduceList ( base , components ) ; begin
41077: LD_INT 0
41079: PPUSH
// if not mc_bases [ base ] then
41080: LD_EXP 50
41084: PUSH
41085: LD_VAR 0 1
41089: ARRAY
41090: NOT
41091: IFFALSE 41095
// exit ;
41093: GO 41132
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
41095: LD_ADDR_EXP 71
41099: PUSH
41100: LD_EXP 71
41104: PPUSH
41105: LD_VAR 0 1
41109: PPUSH
41110: LD_EXP 71
41114: PUSH
41115: LD_VAR 0 1
41119: ARRAY
41120: PUSH
41121: LD_VAR 0 2
41125: ADD
41126: PPUSH
41127: CALL_OW 1
41131: ST_TO_ADDR
// end ;
41132: LD_VAR 0 3
41136: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
41137: LD_INT 0
41139: PPUSH
// if not mc_bases [ base ] then
41140: LD_EXP 50
41144: PUSH
41145: LD_VAR 0 1
41149: ARRAY
41150: NOT
41151: IFFALSE 41155
// exit ;
41153: GO 41209
// mc_defender := Replace ( mc_defender , base , deflist ) ;
41155: LD_ADDR_EXP 72
41159: PUSH
41160: LD_EXP 72
41164: PPUSH
41165: LD_VAR 0 1
41169: PPUSH
41170: LD_VAR 0 2
41174: PPUSH
41175: CALL_OW 1
41179: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
41180: LD_ADDR_EXP 61
41184: PUSH
41185: LD_EXP 61
41189: PPUSH
41190: LD_VAR 0 1
41194: PPUSH
41195: LD_VAR 0 2
41199: PUSH
41200: LD_INT 0
41202: PLUS
41203: PPUSH
41204: CALL_OW 1
41208: ST_TO_ADDR
// end ;
41209: LD_VAR 0 3
41213: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41214: LD_INT 0
41216: PPUSH
// if not mc_bases [ base ] then
41217: LD_EXP 50
41221: PUSH
41222: LD_VAR 0 1
41226: ARRAY
41227: NOT
41228: IFFALSE 41232
// exit ;
41230: GO 41257
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41232: LD_ADDR_EXP 61
41236: PUSH
41237: LD_EXP 61
41241: PPUSH
41242: LD_VAR 0 1
41246: PPUSH
41247: LD_VAR 0 2
41251: PPUSH
41252: CALL_OW 1
41256: ST_TO_ADDR
// end ;
41257: LD_VAR 0 3
41261: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41262: LD_INT 0
41264: PPUSH
41265: PPUSH
41266: PPUSH
41267: PPUSH
// if not mc_bases [ base ] then
41268: LD_EXP 50
41272: PUSH
41273: LD_VAR 0 1
41277: ARRAY
41278: NOT
41279: IFFALSE 41283
// exit ;
41281: GO 41348
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41283: LD_ADDR_EXP 70
41287: PUSH
41288: LD_EXP 70
41292: PPUSH
41293: LD_VAR 0 1
41297: PUSH
41298: LD_EXP 70
41302: PUSH
41303: LD_VAR 0 1
41307: ARRAY
41308: PUSH
41309: LD_INT 1
41311: PLUS
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PPUSH
41317: LD_VAR 0 1
41321: PUSH
41322: LD_VAR 0 2
41326: PUSH
41327: LD_VAR 0 3
41331: PUSH
41332: LD_VAR 0 4
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: LIST
41341: LIST
41342: PPUSH
41343: CALL 52367 0 3
41347: ST_TO_ADDR
// end ;
41348: LD_VAR 0 5
41352: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
41353: LD_INT 0
41355: PPUSH
// if not mc_bases [ base ] then
41356: LD_EXP 50
41360: PUSH
41361: LD_VAR 0 1
41365: ARRAY
41366: NOT
41367: IFFALSE 41371
// exit ;
41369: GO 41396
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
41371: LD_ADDR_EXP 87
41375: PUSH
41376: LD_EXP 87
41380: PPUSH
41381: LD_VAR 0 1
41385: PPUSH
41386: LD_VAR 0 2
41390: PPUSH
41391: CALL_OW 1
41395: ST_TO_ADDR
// end ;
41396: LD_VAR 0 3
41400: RET
// export function MC_GetMinesField ( base ) ; begin
41401: LD_INT 0
41403: PPUSH
// result := mc_mines [ base ] ;
41404: LD_ADDR_VAR 0 2
41408: PUSH
41409: LD_EXP 63
41413: PUSH
41414: LD_VAR 0 1
41418: ARRAY
41419: ST_TO_ADDR
// end ;
41420: LD_VAR 0 2
41424: RET
// export function MC_GetProduceList ( base ) ; begin
41425: LD_INT 0
41427: PPUSH
// result := mc_produce [ base ] ;
41428: LD_ADDR_VAR 0 2
41432: PUSH
41433: LD_EXP 71
41437: PUSH
41438: LD_VAR 0 1
41442: ARRAY
41443: ST_TO_ADDR
// end ;
41444: LD_VAR 0 2
41448: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
41449: LD_INT 0
41451: PPUSH
41452: PPUSH
// if not mc_bases then
41453: LD_EXP 50
41457: NOT
41458: IFFALSE 41462
// exit ;
41460: GO 41527
// if mc_bases [ base ] then
41462: LD_EXP 50
41466: PUSH
41467: LD_VAR 0 1
41471: ARRAY
41472: IFFALSE 41527
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41474: LD_ADDR_VAR 0 3
41478: PUSH
41479: LD_EXP 50
41483: PUSH
41484: LD_VAR 0 1
41488: ARRAY
41489: PPUSH
41490: LD_INT 30
41492: PUSH
41493: LD_VAR 0 2
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PPUSH
41502: CALL_OW 72
41506: ST_TO_ADDR
// if result then
41507: LD_VAR 0 3
41511: IFFALSE 41527
// result := result [ 1 ] ;
41513: LD_ADDR_VAR 0 3
41517: PUSH
41518: LD_VAR 0 3
41522: PUSH
41523: LD_INT 1
41525: ARRAY
41526: ST_TO_ADDR
// end ; end ;
41527: LD_VAR 0 3
41531: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
41532: LD_INT 0
41534: PPUSH
41535: PPUSH
// if not mc_bases then
41536: LD_EXP 50
41540: NOT
41541: IFFALSE 41545
// exit ;
41543: GO 41590
// if mc_bases [ base ] then
41545: LD_EXP 50
41549: PUSH
41550: LD_VAR 0 1
41554: ARRAY
41555: IFFALSE 41590
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41557: LD_ADDR_VAR 0 3
41561: PUSH
41562: LD_EXP 50
41566: PUSH
41567: LD_VAR 0 1
41571: ARRAY
41572: PPUSH
41573: LD_INT 30
41575: PUSH
41576: LD_VAR 0 2
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PPUSH
41585: CALL_OW 72
41589: ST_TO_ADDR
// end ;
41590: LD_VAR 0 3
41594: RET
// export function MC_SetTame ( base , area ) ; begin
41595: LD_INT 0
41597: PPUSH
// if not mc_bases or not base then
41598: LD_EXP 50
41602: NOT
41603: PUSH
41604: LD_VAR 0 1
41608: NOT
41609: OR
41610: IFFALSE 41614
// exit ;
41612: GO 41639
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
41614: LD_ADDR_EXP 78
41618: PUSH
41619: LD_EXP 78
41623: PPUSH
41624: LD_VAR 0 1
41628: PPUSH
41629: LD_VAR 0 2
41633: PPUSH
41634: CALL_OW 1
41638: ST_TO_ADDR
// end ;
41639: LD_VAR 0 3
41643: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
41644: LD_INT 0
41646: PPUSH
41647: PPUSH
// if not mc_bases or not base then
41648: LD_EXP 50
41652: NOT
41653: PUSH
41654: LD_VAR 0 1
41658: NOT
41659: OR
41660: IFFALSE 41664
// exit ;
41662: GO 41766
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41664: LD_ADDR_VAR 0 4
41668: PUSH
41669: LD_EXP 50
41673: PUSH
41674: LD_VAR 0 1
41678: ARRAY
41679: PPUSH
41680: LD_INT 30
41682: PUSH
41683: LD_VAR 0 2
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PPUSH
41692: CALL_OW 72
41696: ST_TO_ADDR
// if not tmp then
41697: LD_VAR 0 4
41701: NOT
41702: IFFALSE 41706
// exit ;
41704: GO 41766
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
41706: LD_ADDR_EXP 82
41710: PUSH
41711: LD_EXP 82
41715: PPUSH
41716: LD_VAR 0 1
41720: PPUSH
41721: LD_EXP 82
41725: PUSH
41726: LD_VAR 0 1
41730: ARRAY
41731: PPUSH
41732: LD_EXP 82
41736: PUSH
41737: LD_VAR 0 1
41741: ARRAY
41742: PUSH
41743: LD_INT 1
41745: PLUS
41746: PPUSH
41747: LD_VAR 0 4
41751: PUSH
41752: LD_INT 1
41754: ARRAY
41755: PPUSH
41756: CALL_OW 2
41760: PPUSH
41761: CALL_OW 1
41765: ST_TO_ADDR
// end ;
41766: LD_VAR 0 3
41770: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
41771: LD_INT 0
41773: PPUSH
41774: PPUSH
// if not mc_bases or not base or not kinds then
41775: LD_EXP 50
41779: NOT
41780: PUSH
41781: LD_VAR 0 1
41785: NOT
41786: OR
41787: PUSH
41788: LD_VAR 0 2
41792: NOT
41793: OR
41794: IFFALSE 41798
// exit ;
41796: GO 41859
// for i in kinds do
41798: LD_ADDR_VAR 0 4
41802: PUSH
41803: LD_VAR 0 2
41807: PUSH
41808: FOR_IN
41809: IFFALSE 41857
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
41811: LD_ADDR_EXP 84
41815: PUSH
41816: LD_EXP 84
41820: PPUSH
41821: LD_VAR 0 1
41825: PUSH
41826: LD_EXP 84
41830: PUSH
41831: LD_VAR 0 1
41835: ARRAY
41836: PUSH
41837: LD_INT 1
41839: PLUS
41840: PUSH
41841: EMPTY
41842: LIST
41843: LIST
41844: PPUSH
41845: LD_VAR 0 4
41849: PPUSH
41850: CALL 52367 0 3
41854: ST_TO_ADDR
41855: GO 41808
41857: POP
41858: POP
// end ;
41859: LD_VAR 0 3
41863: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
41864: LD_INT 0
41866: PPUSH
// if not mc_bases or not base or not areas then
41867: LD_EXP 50
41871: NOT
41872: PUSH
41873: LD_VAR 0 1
41877: NOT
41878: OR
41879: PUSH
41880: LD_VAR 0 2
41884: NOT
41885: OR
41886: IFFALSE 41890
// exit ;
41888: GO 41915
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
41890: LD_ADDR_EXP 68
41894: PUSH
41895: LD_EXP 68
41899: PPUSH
41900: LD_VAR 0 1
41904: PPUSH
41905: LD_VAR 0 2
41909: PPUSH
41910: CALL_OW 1
41914: ST_TO_ADDR
// end ;
41915: LD_VAR 0 3
41919: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
41920: LD_INT 0
41922: PPUSH
// if not mc_bases or not base or not teleports_exit then
41923: LD_EXP 50
41927: NOT
41928: PUSH
41929: LD_VAR 0 1
41933: NOT
41934: OR
41935: PUSH
41936: LD_VAR 0 2
41940: NOT
41941: OR
41942: IFFALSE 41946
// exit ;
41944: GO 41971
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
41946: LD_ADDR_EXP 85
41950: PUSH
41951: LD_EXP 85
41955: PPUSH
41956: LD_VAR 0 1
41960: PPUSH
41961: LD_VAR 0 2
41965: PPUSH
41966: CALL_OW 1
41970: ST_TO_ADDR
// end ;
41971: LD_VAR 0 3
41975: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
41976: LD_INT 0
41978: PPUSH
41979: PPUSH
41980: PPUSH
// if not mc_bases or not base or not ext_list then
41981: LD_EXP 50
41985: NOT
41986: PUSH
41987: LD_VAR 0 1
41991: NOT
41992: OR
41993: PUSH
41994: LD_VAR 0 5
41998: NOT
41999: OR
42000: IFFALSE 42004
// exit ;
42002: GO 42177
// tmp := GetFacExtXYD ( x , y , d ) ;
42004: LD_ADDR_VAR 0 8
42008: PUSH
42009: LD_VAR 0 2
42013: PPUSH
42014: LD_VAR 0 3
42018: PPUSH
42019: LD_VAR 0 4
42023: PPUSH
42024: CALL 81046 0 3
42028: ST_TO_ADDR
// if not tmp then
42029: LD_VAR 0 8
42033: NOT
42034: IFFALSE 42038
// exit ;
42036: GO 42177
// for i in tmp do
42038: LD_ADDR_VAR 0 7
42042: PUSH
42043: LD_VAR 0 8
42047: PUSH
42048: FOR_IN
42049: IFFALSE 42175
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
42051: LD_ADDR_EXP 55
42055: PUSH
42056: LD_EXP 55
42060: PPUSH
42061: LD_VAR 0 1
42065: PPUSH
42066: LD_EXP 55
42070: PUSH
42071: LD_VAR 0 1
42075: ARRAY
42076: PPUSH
42077: LD_EXP 55
42081: PUSH
42082: LD_VAR 0 1
42086: ARRAY
42087: PUSH
42088: LD_INT 1
42090: PLUS
42091: PPUSH
42092: LD_VAR 0 5
42096: PUSH
42097: LD_INT 1
42099: ARRAY
42100: PUSH
42101: LD_VAR 0 7
42105: PUSH
42106: LD_INT 1
42108: ARRAY
42109: PUSH
42110: LD_VAR 0 7
42114: PUSH
42115: LD_INT 2
42117: ARRAY
42118: PUSH
42119: LD_VAR 0 7
42123: PUSH
42124: LD_INT 3
42126: ARRAY
42127: PUSH
42128: EMPTY
42129: LIST
42130: LIST
42131: LIST
42132: LIST
42133: PPUSH
42134: CALL_OW 2
42138: PPUSH
42139: CALL_OW 1
42143: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
42144: LD_ADDR_VAR 0 5
42148: PUSH
42149: LD_VAR 0 5
42153: PPUSH
42154: LD_INT 1
42156: PPUSH
42157: CALL_OW 3
42161: ST_TO_ADDR
// if not ext_list then
42162: LD_VAR 0 5
42166: NOT
42167: IFFALSE 42173
// exit ;
42169: POP
42170: POP
42171: GO 42177
// end ;
42173: GO 42048
42175: POP
42176: POP
// end ;
42177: LD_VAR 0 6
42181: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42182: LD_INT 0
42184: PPUSH
// if not mc_bases or not base or not weapon_list then
42185: LD_EXP 50
42189: NOT
42190: PUSH
42191: LD_VAR 0 1
42195: NOT
42196: OR
42197: PUSH
42198: LD_VAR 0 2
42202: NOT
42203: OR
42204: IFFALSE 42208
// exit ;
42206: GO 42233
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42208: LD_ADDR_EXP 89
42212: PUSH
42213: LD_EXP 89
42217: PPUSH
42218: LD_VAR 0 1
42222: PPUSH
42223: LD_VAR 0 2
42227: PPUSH
42228: CALL_OW 1
42232: ST_TO_ADDR
// end ;
42233: LD_VAR 0 3
42237: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42238: LD_INT 0
42240: PPUSH
// if not mc_bases or not base or not tech_list then
42241: LD_EXP 50
42245: NOT
42246: PUSH
42247: LD_VAR 0 1
42251: NOT
42252: OR
42253: PUSH
42254: LD_VAR 0 2
42258: NOT
42259: OR
42260: IFFALSE 42264
// exit ;
42262: GO 42289
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42264: LD_ADDR_EXP 77
42268: PUSH
42269: LD_EXP 77
42273: PPUSH
42274: LD_VAR 0 1
42278: PPUSH
42279: LD_VAR 0 2
42283: PPUSH
42284: CALL_OW 1
42288: ST_TO_ADDR
// end ;
42289: LD_VAR 0 3
42293: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42294: LD_INT 0
42296: PPUSH
// if not mc_bases or not parking_area or not base then
42297: LD_EXP 50
42301: NOT
42302: PUSH
42303: LD_VAR 0 2
42307: NOT
42308: OR
42309: PUSH
42310: LD_VAR 0 1
42314: NOT
42315: OR
42316: IFFALSE 42320
// exit ;
42318: GO 42345
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
42320: LD_ADDR_EXP 74
42324: PUSH
42325: LD_EXP 74
42329: PPUSH
42330: LD_VAR 0 1
42334: PPUSH
42335: LD_VAR 0 2
42339: PPUSH
42340: CALL_OW 1
42344: ST_TO_ADDR
// end ;
42345: LD_VAR 0 3
42349: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
42350: LD_INT 0
42352: PPUSH
// if not mc_bases or not base or not scan_area then
42353: LD_EXP 50
42357: NOT
42358: PUSH
42359: LD_VAR 0 1
42363: NOT
42364: OR
42365: PUSH
42366: LD_VAR 0 2
42370: NOT
42371: OR
42372: IFFALSE 42376
// exit ;
42374: GO 42401
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
42376: LD_ADDR_EXP 75
42380: PUSH
42381: LD_EXP 75
42385: PPUSH
42386: LD_VAR 0 1
42390: PPUSH
42391: LD_VAR 0 2
42395: PPUSH
42396: CALL_OW 1
42400: ST_TO_ADDR
// end ;
42401: LD_VAR 0 3
42405: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
42406: LD_INT 0
42408: PPUSH
42409: PPUSH
// if not mc_bases or not base then
42410: LD_EXP 50
42414: NOT
42415: PUSH
42416: LD_VAR 0 1
42420: NOT
42421: OR
42422: IFFALSE 42426
// exit ;
42424: GO 42490
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
42426: LD_ADDR_VAR 0 3
42430: PUSH
42431: LD_INT 1
42433: PUSH
42434: LD_INT 2
42436: PUSH
42437: LD_INT 3
42439: PUSH
42440: LD_INT 4
42442: PUSH
42443: LD_INT 11
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
42453: LD_ADDR_EXP 77
42457: PUSH
42458: LD_EXP 77
42462: PPUSH
42463: LD_VAR 0 1
42467: PPUSH
42468: LD_EXP 77
42472: PUSH
42473: LD_VAR 0 1
42477: ARRAY
42478: PUSH
42479: LD_VAR 0 3
42483: DIFF
42484: PPUSH
42485: CALL_OW 1
42489: ST_TO_ADDR
// end ;
42490: LD_VAR 0 2
42494: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
42495: LD_INT 0
42497: PPUSH
// result := mc_vehicles [ base ] ;
42498: LD_ADDR_VAR 0 3
42502: PUSH
42503: LD_EXP 69
42507: PUSH
42508: LD_VAR 0 1
42512: ARRAY
42513: ST_TO_ADDR
// if onlyCombat then
42514: LD_VAR 0 2
42518: IFFALSE 42683
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
42520: LD_ADDR_VAR 0 3
42524: PUSH
42525: LD_VAR 0 3
42529: PUSH
42530: LD_VAR 0 3
42534: PPUSH
42535: LD_INT 2
42537: PUSH
42538: LD_INT 34
42540: PUSH
42541: LD_INT 12
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_INT 34
42550: PUSH
42551: LD_INT 51
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 34
42560: PUSH
42561: LD_EXP 94
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 34
42572: PUSH
42573: LD_INT 32
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: LD_INT 34
42582: PUSH
42583: LD_INT 13
42585: PUSH
42586: EMPTY
42587: LIST
42588: LIST
42589: PUSH
42590: LD_INT 34
42592: PUSH
42593: LD_INT 52
42595: PUSH
42596: EMPTY
42597: LIST
42598: LIST
42599: PUSH
42600: LD_INT 34
42602: PUSH
42603: LD_INT 14
42605: PUSH
42606: EMPTY
42607: LIST
42608: LIST
42609: PUSH
42610: LD_INT 34
42612: PUSH
42613: LD_INT 53
42615: PUSH
42616: EMPTY
42617: LIST
42618: LIST
42619: PUSH
42620: LD_INT 34
42622: PUSH
42623: LD_EXP 93
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 34
42634: PUSH
42635: LD_INT 31
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PUSH
42642: LD_INT 34
42644: PUSH
42645: LD_INT 48
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 34
42654: PUSH
42655: LD_INT 8
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: LIST
42666: LIST
42667: LIST
42668: LIST
42669: LIST
42670: LIST
42671: LIST
42672: LIST
42673: LIST
42674: LIST
42675: LIST
42676: PPUSH
42677: CALL_OW 72
42681: DIFF
42682: ST_TO_ADDR
// end ; end_of_file
42683: LD_VAR 0 3
42687: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
42688: LD_INT 0
42690: PPUSH
42691: PPUSH
42692: PPUSH
// if not mc_bases or not skirmish then
42693: LD_EXP 50
42697: NOT
42698: PUSH
42699: LD_EXP 48
42703: NOT
42704: OR
42705: IFFALSE 42709
// exit ;
42707: GO 42874
// for i = 1 to mc_bases do
42709: LD_ADDR_VAR 0 4
42713: PUSH
42714: DOUBLE
42715: LD_INT 1
42717: DEC
42718: ST_TO_ADDR
42719: LD_EXP 50
42723: PUSH
42724: FOR_TO
42725: IFFALSE 42872
// begin if sci in mc_bases [ i ] then
42727: LD_VAR 0 2
42731: PUSH
42732: LD_EXP 50
42736: PUSH
42737: LD_VAR 0 4
42741: ARRAY
42742: IN
42743: IFFALSE 42870
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
42745: LD_ADDR_EXP 79
42749: PUSH
42750: LD_EXP 79
42754: PPUSH
42755: LD_VAR 0 4
42759: PUSH
42760: LD_EXP 79
42764: PUSH
42765: LD_VAR 0 4
42769: ARRAY
42770: PUSH
42771: LD_INT 1
42773: PLUS
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PPUSH
42779: LD_VAR 0 1
42783: PPUSH
42784: CALL 52367 0 3
42788: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
42789: LD_ADDR_VAR 0 5
42793: PUSH
42794: LD_EXP 50
42798: PUSH
42799: LD_VAR 0 4
42803: ARRAY
42804: PPUSH
42805: LD_INT 2
42807: PUSH
42808: LD_INT 30
42810: PUSH
42811: LD_INT 0
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: PUSH
42818: LD_INT 30
42820: PUSH
42821: LD_INT 1
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: LIST
42832: PPUSH
42833: CALL_OW 72
42837: PPUSH
42838: LD_VAR 0 1
42842: PPUSH
42843: CALL_OW 74
42847: ST_TO_ADDR
// if tmp then
42848: LD_VAR 0 5
42852: IFFALSE 42868
// ComStandNearbyBuilding ( ape , tmp ) ;
42854: LD_VAR 0 1
42858: PPUSH
42859: LD_VAR 0 5
42863: PPUSH
42864: CALL 48981 0 2
// break ;
42868: GO 42872
// end ; end ;
42870: GO 42724
42872: POP
42873: POP
// end ;
42874: LD_VAR 0 3
42878: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
42879: LD_INT 0
42881: PPUSH
42882: PPUSH
42883: PPUSH
// if not mc_bases or not skirmish then
42884: LD_EXP 50
42888: NOT
42889: PUSH
42890: LD_EXP 48
42894: NOT
42895: OR
42896: IFFALSE 42900
// exit ;
42898: GO 42989
// for i = 1 to mc_bases do
42900: LD_ADDR_VAR 0 4
42904: PUSH
42905: DOUBLE
42906: LD_INT 1
42908: DEC
42909: ST_TO_ADDR
42910: LD_EXP 50
42914: PUSH
42915: FOR_TO
42916: IFFALSE 42987
// begin if building in mc_busy_turret_list [ i ] then
42918: LD_VAR 0 1
42922: PUSH
42923: LD_EXP 60
42927: PUSH
42928: LD_VAR 0 4
42932: ARRAY
42933: IN
42934: IFFALSE 42985
// begin tmp := mc_busy_turret_list [ i ] diff building ;
42936: LD_ADDR_VAR 0 5
42940: PUSH
42941: LD_EXP 60
42945: PUSH
42946: LD_VAR 0 4
42950: ARRAY
42951: PUSH
42952: LD_VAR 0 1
42956: DIFF
42957: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
42958: LD_ADDR_EXP 60
42962: PUSH
42963: LD_EXP 60
42967: PPUSH
42968: LD_VAR 0 4
42972: PPUSH
42973: LD_VAR 0 5
42977: PPUSH
42978: CALL_OW 1
42982: ST_TO_ADDR
// break ;
42983: GO 42987
// end ; end ;
42985: GO 42915
42987: POP
42988: POP
// end ;
42989: LD_VAR 0 3
42993: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
42994: LD_INT 0
42996: PPUSH
42997: PPUSH
42998: PPUSH
// if not mc_bases or not skirmish then
42999: LD_EXP 50
43003: NOT
43004: PUSH
43005: LD_EXP 48
43009: NOT
43010: OR
43011: IFFALSE 43015
// exit ;
43013: GO 43214
// for i = 1 to mc_bases do
43015: LD_ADDR_VAR 0 5
43019: PUSH
43020: DOUBLE
43021: LD_INT 1
43023: DEC
43024: ST_TO_ADDR
43025: LD_EXP 50
43029: PUSH
43030: FOR_TO
43031: IFFALSE 43212
// if building in mc_bases [ i ] then
43033: LD_VAR 0 1
43037: PUSH
43038: LD_EXP 50
43042: PUSH
43043: LD_VAR 0 5
43047: ARRAY
43048: IN
43049: IFFALSE 43210
// begin tmp := mc_bases [ i ] diff building ;
43051: LD_ADDR_VAR 0 6
43055: PUSH
43056: LD_EXP 50
43060: PUSH
43061: LD_VAR 0 5
43065: ARRAY
43066: PUSH
43067: LD_VAR 0 1
43071: DIFF
43072: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
43073: LD_ADDR_EXP 50
43077: PUSH
43078: LD_EXP 50
43082: PPUSH
43083: LD_VAR 0 5
43087: PPUSH
43088: LD_VAR 0 6
43092: PPUSH
43093: CALL_OW 1
43097: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
43098: LD_VAR 0 1
43102: PUSH
43103: LD_EXP 58
43107: PUSH
43108: LD_VAR 0 5
43112: ARRAY
43113: IN
43114: IFFALSE 43153
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
43116: LD_ADDR_EXP 58
43120: PUSH
43121: LD_EXP 58
43125: PPUSH
43126: LD_VAR 0 5
43130: PPUSH
43131: LD_EXP 58
43135: PUSH
43136: LD_VAR 0 5
43140: ARRAY
43141: PUSH
43142: LD_VAR 0 1
43146: DIFF
43147: PPUSH
43148: CALL_OW 1
43152: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
43153: LD_VAR 0 1
43157: PUSH
43158: LD_EXP 59
43162: PUSH
43163: LD_VAR 0 5
43167: ARRAY
43168: IN
43169: IFFALSE 43208
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
43171: LD_ADDR_EXP 59
43175: PUSH
43176: LD_EXP 59
43180: PPUSH
43181: LD_VAR 0 5
43185: PPUSH
43186: LD_EXP 59
43190: PUSH
43191: LD_VAR 0 5
43195: ARRAY
43196: PUSH
43197: LD_VAR 0 1
43201: DIFF
43202: PPUSH
43203: CALL_OW 1
43207: ST_TO_ADDR
// break ;
43208: GO 43212
// end ;
43210: GO 43030
43212: POP
43213: POP
// end ;
43214: LD_VAR 0 4
43218: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43219: LD_INT 0
43221: PPUSH
43222: PPUSH
43223: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43224: LD_EXP 50
43228: NOT
43229: PUSH
43230: LD_EXP 48
43234: NOT
43235: OR
43236: PUSH
43237: LD_VAR 0 3
43241: PUSH
43242: LD_EXP 76
43246: IN
43247: NOT
43248: OR
43249: IFFALSE 43253
// exit ;
43251: GO 43376
// for i = 1 to mc_vehicles do
43253: LD_ADDR_VAR 0 6
43257: PUSH
43258: DOUBLE
43259: LD_INT 1
43261: DEC
43262: ST_TO_ADDR
43263: LD_EXP 69
43267: PUSH
43268: FOR_TO
43269: IFFALSE 43374
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43271: LD_VAR 0 2
43275: PUSH
43276: LD_EXP 69
43280: PUSH
43281: LD_VAR 0 6
43285: ARRAY
43286: IN
43287: PUSH
43288: LD_VAR 0 1
43292: PUSH
43293: LD_EXP 69
43297: PUSH
43298: LD_VAR 0 6
43302: ARRAY
43303: IN
43304: OR
43305: IFFALSE 43372
// begin tmp := mc_vehicles [ i ] diff old ;
43307: LD_ADDR_VAR 0 7
43311: PUSH
43312: LD_EXP 69
43316: PUSH
43317: LD_VAR 0 6
43321: ARRAY
43322: PUSH
43323: LD_VAR 0 2
43327: DIFF
43328: ST_TO_ADDR
// tmp := tmp diff new ;
43329: LD_ADDR_VAR 0 7
43333: PUSH
43334: LD_VAR 0 7
43338: PUSH
43339: LD_VAR 0 1
43343: DIFF
43344: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
43345: LD_ADDR_EXP 69
43349: PUSH
43350: LD_EXP 69
43354: PPUSH
43355: LD_VAR 0 6
43359: PPUSH
43360: LD_VAR 0 7
43364: PPUSH
43365: CALL_OW 1
43369: ST_TO_ADDR
// break ;
43370: GO 43374
// end ;
43372: GO 43268
43374: POP
43375: POP
// end ;
43376: LD_VAR 0 5
43380: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
43381: LD_INT 0
43383: PPUSH
43384: PPUSH
43385: PPUSH
43386: PPUSH
// if not mc_bases or not skirmish then
43387: LD_EXP 50
43391: NOT
43392: PUSH
43393: LD_EXP 48
43397: NOT
43398: OR
43399: IFFALSE 43403
// exit ;
43401: GO 43780
// side := GetSide ( vehicle ) ;
43403: LD_ADDR_VAR 0 5
43407: PUSH
43408: LD_VAR 0 1
43412: PPUSH
43413: CALL_OW 255
43417: ST_TO_ADDR
// for i = 1 to mc_bases do
43418: LD_ADDR_VAR 0 4
43422: PUSH
43423: DOUBLE
43424: LD_INT 1
43426: DEC
43427: ST_TO_ADDR
43428: LD_EXP 50
43432: PUSH
43433: FOR_TO
43434: IFFALSE 43778
// begin if factory in mc_bases [ i ] then
43436: LD_VAR 0 2
43440: PUSH
43441: LD_EXP 50
43445: PUSH
43446: LD_VAR 0 4
43450: ARRAY
43451: IN
43452: IFFALSE 43776
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
43454: LD_EXP 72
43458: PUSH
43459: LD_VAR 0 4
43463: ARRAY
43464: PUSH
43465: LD_EXP 61
43469: PUSH
43470: LD_VAR 0 4
43474: ARRAY
43475: LESS
43476: PUSH
43477: LD_VAR 0 1
43481: PPUSH
43482: CALL_OW 264
43486: PUSH
43487: LD_INT 31
43489: PUSH
43490: LD_INT 32
43492: PUSH
43493: LD_INT 51
43495: PUSH
43496: LD_EXP 94
43500: PUSH
43501: LD_INT 12
43503: PUSH
43504: LD_INT 30
43506: PUSH
43507: LD_EXP 93
43511: PUSH
43512: LD_INT 11
43514: PUSH
43515: LD_INT 53
43517: PUSH
43518: LD_INT 14
43520: PUSH
43521: LD_EXP 97
43525: PUSH
43526: LD_INT 29
43528: PUSH
43529: LD_EXP 95
43533: PUSH
43534: LD_INT 13
43536: PUSH
43537: LD_INT 52
43539: PUSH
43540: LD_INT 48
43542: PUSH
43543: LD_INT 8
43545: PUSH
43546: EMPTY
43547: LIST
43548: LIST
43549: LIST
43550: LIST
43551: LIST
43552: LIST
43553: LIST
43554: LIST
43555: LIST
43556: LIST
43557: LIST
43558: LIST
43559: LIST
43560: LIST
43561: LIST
43562: LIST
43563: LIST
43564: IN
43565: NOT
43566: AND
43567: IFFALSE 43615
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
43569: LD_ADDR_EXP 72
43573: PUSH
43574: LD_EXP 72
43578: PPUSH
43579: LD_VAR 0 4
43583: PUSH
43584: LD_EXP 72
43588: PUSH
43589: LD_VAR 0 4
43593: ARRAY
43594: PUSH
43595: LD_INT 1
43597: PLUS
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: PPUSH
43603: LD_VAR 0 1
43607: PPUSH
43608: CALL 52367 0 3
43612: ST_TO_ADDR
43613: GO 43659
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
43615: LD_ADDR_EXP 69
43619: PUSH
43620: LD_EXP 69
43624: PPUSH
43625: LD_VAR 0 4
43629: PUSH
43630: LD_EXP 69
43634: PUSH
43635: LD_VAR 0 4
43639: ARRAY
43640: PUSH
43641: LD_INT 1
43643: PLUS
43644: PUSH
43645: EMPTY
43646: LIST
43647: LIST
43648: PPUSH
43649: LD_VAR 0 1
43653: PPUSH
43654: CALL 52367 0 3
43658: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
43659: LD_VAR 0 1
43663: PPUSH
43664: CALL_OW 263
43668: PUSH
43669: LD_INT 2
43671: EQUAL
43672: IFFALSE 43692
// begin repeat wait ( 0 0$1 ) ;
43674: LD_INT 35
43676: PPUSH
43677: CALL_OW 67
// until IsControledBy ( vehicle ) ;
43681: LD_VAR 0 1
43685: PPUSH
43686: CALL_OW 312
43690: IFFALSE 43674
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
43692: LD_VAR 0 1
43696: PPUSH
43697: LD_EXP 74
43701: PUSH
43702: LD_VAR 0 4
43706: ARRAY
43707: PPUSH
43708: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
43712: LD_VAR 0 1
43716: PPUSH
43717: CALL_OW 263
43721: PUSH
43722: LD_INT 1
43724: NONEQUAL
43725: IFFALSE 43729
// break ;
43727: GO 43778
// repeat wait ( 0 0$1 ) ;
43729: LD_INT 35
43731: PPUSH
43732: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
43736: LD_VAR 0 1
43740: PPUSH
43741: LD_EXP 74
43745: PUSH
43746: LD_VAR 0 4
43750: ARRAY
43751: PPUSH
43752: CALL_OW 308
43756: IFFALSE 43729
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
43758: LD_VAR 0 1
43762: PPUSH
43763: CALL_OW 311
43767: PPUSH
43768: CALL_OW 121
// exit ;
43772: POP
43773: POP
43774: GO 43780
// end ; end ;
43776: GO 43433
43778: POP
43779: POP
// end ;
43780: LD_VAR 0 3
43784: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
43785: LD_INT 0
43787: PPUSH
43788: PPUSH
43789: PPUSH
43790: PPUSH
// if not mc_bases or not skirmish then
43791: LD_EXP 50
43795: NOT
43796: PUSH
43797: LD_EXP 48
43801: NOT
43802: OR
43803: IFFALSE 43807
// exit ;
43805: GO 44160
// repeat wait ( 0 0$1 ) ;
43807: LD_INT 35
43809: PPUSH
43810: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
43814: LD_VAR 0 2
43818: PPUSH
43819: LD_VAR 0 3
43823: PPUSH
43824: CALL_OW 284
43828: IFFALSE 43807
// if GetResourceTypeXY ( x , y ) = mat_artefact then
43830: LD_VAR 0 2
43834: PPUSH
43835: LD_VAR 0 3
43839: PPUSH
43840: CALL_OW 283
43844: PUSH
43845: LD_INT 4
43847: EQUAL
43848: IFFALSE 43852
// exit ;
43850: GO 44160
// for i = 1 to mc_bases do
43852: LD_ADDR_VAR 0 7
43856: PUSH
43857: DOUBLE
43858: LD_INT 1
43860: DEC
43861: ST_TO_ADDR
43862: LD_EXP 50
43866: PUSH
43867: FOR_TO
43868: IFFALSE 44158
// begin if mc_crates_area [ i ] then
43870: LD_EXP 68
43874: PUSH
43875: LD_VAR 0 7
43879: ARRAY
43880: IFFALSE 43991
// for j in mc_crates_area [ i ] do
43882: LD_ADDR_VAR 0 8
43886: PUSH
43887: LD_EXP 68
43891: PUSH
43892: LD_VAR 0 7
43896: ARRAY
43897: PUSH
43898: FOR_IN
43899: IFFALSE 43989
// if InArea ( x , y , j ) then
43901: LD_VAR 0 2
43905: PPUSH
43906: LD_VAR 0 3
43910: PPUSH
43911: LD_VAR 0 8
43915: PPUSH
43916: CALL_OW 309
43920: IFFALSE 43987
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43922: LD_ADDR_EXP 66
43926: PUSH
43927: LD_EXP 66
43931: PPUSH
43932: LD_VAR 0 7
43936: PUSH
43937: LD_EXP 66
43941: PUSH
43942: LD_VAR 0 7
43946: ARRAY
43947: PUSH
43948: LD_INT 1
43950: PLUS
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: PPUSH
43956: LD_VAR 0 4
43960: PUSH
43961: LD_VAR 0 2
43965: PUSH
43966: LD_VAR 0 3
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: LIST
43975: PPUSH
43976: CALL 52367 0 3
43980: ST_TO_ADDR
// exit ;
43981: POP
43982: POP
43983: POP
43984: POP
43985: GO 44160
// end ;
43987: GO 43898
43989: POP
43990: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43991: LD_ADDR_VAR 0 9
43995: PUSH
43996: LD_EXP 50
44000: PUSH
44001: LD_VAR 0 7
44005: ARRAY
44006: PPUSH
44007: LD_INT 2
44009: PUSH
44010: LD_INT 30
44012: PUSH
44013: LD_INT 0
44015: PUSH
44016: EMPTY
44017: LIST
44018: LIST
44019: PUSH
44020: LD_INT 30
44022: PUSH
44023: LD_INT 1
44025: PUSH
44026: EMPTY
44027: LIST
44028: LIST
44029: PUSH
44030: EMPTY
44031: LIST
44032: LIST
44033: LIST
44034: PPUSH
44035: CALL_OW 72
44039: ST_TO_ADDR
// if not depot then
44040: LD_VAR 0 9
44044: NOT
44045: IFFALSE 44049
// continue ;
44047: GO 43867
// for j in depot do
44049: LD_ADDR_VAR 0 8
44053: PUSH
44054: LD_VAR 0 9
44058: PUSH
44059: FOR_IN
44060: IFFALSE 44154
// if GetDistUnitXY ( j , x , y ) < 30 then
44062: LD_VAR 0 8
44066: PPUSH
44067: LD_VAR 0 2
44071: PPUSH
44072: LD_VAR 0 3
44076: PPUSH
44077: CALL_OW 297
44081: PUSH
44082: LD_INT 30
44084: LESS
44085: IFFALSE 44152
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44087: LD_ADDR_EXP 66
44091: PUSH
44092: LD_EXP 66
44096: PPUSH
44097: LD_VAR 0 7
44101: PUSH
44102: LD_EXP 66
44106: PUSH
44107: LD_VAR 0 7
44111: ARRAY
44112: PUSH
44113: LD_INT 1
44115: PLUS
44116: PUSH
44117: EMPTY
44118: LIST
44119: LIST
44120: PPUSH
44121: LD_VAR 0 4
44125: PUSH
44126: LD_VAR 0 2
44130: PUSH
44131: LD_VAR 0 3
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: LIST
44140: PPUSH
44141: CALL 52367 0 3
44145: ST_TO_ADDR
// exit ;
44146: POP
44147: POP
44148: POP
44149: POP
44150: GO 44160
// end ;
44152: GO 44059
44154: POP
44155: POP
// end ;
44156: GO 43867
44158: POP
44159: POP
// end ;
44160: LD_VAR 0 6
44164: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
44165: LD_INT 0
44167: PPUSH
44168: PPUSH
44169: PPUSH
44170: PPUSH
// if not mc_bases or not skirmish then
44171: LD_EXP 50
44175: NOT
44176: PUSH
44177: LD_EXP 48
44181: NOT
44182: OR
44183: IFFALSE 44187
// exit ;
44185: GO 44464
// side := GetSide ( lab ) ;
44187: LD_ADDR_VAR 0 4
44191: PUSH
44192: LD_VAR 0 2
44196: PPUSH
44197: CALL_OW 255
44201: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44202: LD_VAR 0 4
44206: PUSH
44207: LD_EXP 76
44211: IN
44212: NOT
44213: PUSH
44214: LD_EXP 77
44218: NOT
44219: OR
44220: PUSH
44221: LD_EXP 50
44225: NOT
44226: OR
44227: IFFALSE 44231
// exit ;
44229: GO 44464
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44231: LD_ADDR_EXP 77
44235: PUSH
44236: LD_EXP 77
44240: PPUSH
44241: LD_VAR 0 4
44245: PPUSH
44246: LD_EXP 77
44250: PUSH
44251: LD_VAR 0 4
44255: ARRAY
44256: PUSH
44257: LD_VAR 0 1
44261: DIFF
44262: PPUSH
44263: CALL_OW 1
44267: ST_TO_ADDR
// for i = 1 to mc_bases do
44268: LD_ADDR_VAR 0 5
44272: PUSH
44273: DOUBLE
44274: LD_INT 1
44276: DEC
44277: ST_TO_ADDR
44278: LD_EXP 50
44282: PUSH
44283: FOR_TO
44284: IFFALSE 44462
// begin if lab in mc_bases [ i ] then
44286: LD_VAR 0 2
44290: PUSH
44291: LD_EXP 50
44295: PUSH
44296: LD_VAR 0 5
44300: ARRAY
44301: IN
44302: IFFALSE 44460
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
44304: LD_VAR 0 1
44308: PUSH
44309: LD_INT 11
44311: PUSH
44312: LD_INT 4
44314: PUSH
44315: LD_INT 3
44317: PUSH
44318: LD_INT 2
44320: PUSH
44321: EMPTY
44322: LIST
44323: LIST
44324: LIST
44325: LIST
44326: IN
44327: PUSH
44328: LD_EXP 80
44332: PUSH
44333: LD_VAR 0 5
44337: ARRAY
44338: AND
44339: IFFALSE 44460
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
44341: LD_ADDR_VAR 0 6
44345: PUSH
44346: LD_EXP 80
44350: PUSH
44351: LD_VAR 0 5
44355: ARRAY
44356: PUSH
44357: LD_INT 1
44359: ARRAY
44360: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44361: LD_ADDR_EXP 80
44365: PUSH
44366: LD_EXP 80
44370: PPUSH
44371: LD_VAR 0 5
44375: PPUSH
44376: EMPTY
44377: PPUSH
44378: CALL_OW 1
44382: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
44383: LD_VAR 0 6
44387: PPUSH
44388: LD_INT 0
44390: PPUSH
44391: CALL_OW 109
// ComExitBuilding ( tmp ) ;
44395: LD_VAR 0 6
44399: PPUSH
44400: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
44404: LD_ADDR_EXP 79
44408: PUSH
44409: LD_EXP 79
44413: PPUSH
44414: LD_VAR 0 5
44418: PPUSH
44419: LD_EXP 79
44423: PUSH
44424: LD_VAR 0 5
44428: ARRAY
44429: PPUSH
44430: LD_INT 1
44432: PPUSH
44433: LD_VAR 0 6
44437: PPUSH
44438: CALL_OW 2
44442: PPUSH
44443: CALL_OW 1
44447: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
44448: LD_VAR 0 5
44452: PPUSH
44453: LD_INT 112
44455: PPUSH
44456: CALL 21460 0 2
// end ; end ; end ;
44460: GO 44283
44462: POP
44463: POP
// end ;
44464: LD_VAR 0 3
44468: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
44469: LD_INT 0
44471: PPUSH
44472: PPUSH
44473: PPUSH
44474: PPUSH
44475: PPUSH
44476: PPUSH
44477: PPUSH
44478: PPUSH
// if not mc_bases or not skirmish then
44479: LD_EXP 50
44483: NOT
44484: PUSH
44485: LD_EXP 48
44489: NOT
44490: OR
44491: IFFALSE 44495
// exit ;
44493: GO 45866
// for i = 1 to mc_bases do
44495: LD_ADDR_VAR 0 3
44499: PUSH
44500: DOUBLE
44501: LD_INT 1
44503: DEC
44504: ST_TO_ADDR
44505: LD_EXP 50
44509: PUSH
44510: FOR_TO
44511: IFFALSE 45864
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
44513: LD_VAR 0 1
44517: PUSH
44518: LD_EXP 50
44522: PUSH
44523: LD_VAR 0 3
44527: ARRAY
44528: IN
44529: PUSH
44530: LD_VAR 0 1
44534: PUSH
44535: LD_EXP 57
44539: PUSH
44540: LD_VAR 0 3
44544: ARRAY
44545: IN
44546: OR
44547: PUSH
44548: LD_VAR 0 1
44552: PUSH
44553: LD_EXP 72
44557: PUSH
44558: LD_VAR 0 3
44562: ARRAY
44563: IN
44564: OR
44565: PUSH
44566: LD_VAR 0 1
44570: PUSH
44571: LD_EXP 69
44575: PUSH
44576: LD_VAR 0 3
44580: ARRAY
44581: IN
44582: OR
44583: PUSH
44584: LD_VAR 0 1
44588: PUSH
44589: LD_EXP 79
44593: PUSH
44594: LD_VAR 0 3
44598: ARRAY
44599: IN
44600: OR
44601: PUSH
44602: LD_VAR 0 1
44606: PUSH
44607: LD_EXP 80
44611: PUSH
44612: LD_VAR 0 3
44616: ARRAY
44617: IN
44618: OR
44619: IFFALSE 45862
// begin if un in mc_ape [ i ] then
44621: LD_VAR 0 1
44625: PUSH
44626: LD_EXP 79
44630: PUSH
44631: LD_VAR 0 3
44635: ARRAY
44636: IN
44637: IFFALSE 44676
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
44639: LD_ADDR_EXP 79
44643: PUSH
44644: LD_EXP 79
44648: PPUSH
44649: LD_VAR 0 3
44653: PPUSH
44654: LD_EXP 79
44658: PUSH
44659: LD_VAR 0 3
44663: ARRAY
44664: PUSH
44665: LD_VAR 0 1
44669: DIFF
44670: PPUSH
44671: CALL_OW 1
44675: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
44676: LD_VAR 0 1
44680: PUSH
44681: LD_EXP 80
44685: PUSH
44686: LD_VAR 0 3
44690: ARRAY
44691: IN
44692: IFFALSE 44716
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44694: LD_ADDR_EXP 80
44698: PUSH
44699: LD_EXP 80
44703: PPUSH
44704: LD_VAR 0 3
44708: PPUSH
44709: EMPTY
44710: PPUSH
44711: CALL_OW 1
44715: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
44716: LD_VAR 0 1
44720: PPUSH
44721: CALL_OW 247
44725: PUSH
44726: LD_INT 2
44728: EQUAL
44729: PUSH
44730: LD_VAR 0 1
44734: PPUSH
44735: CALL_OW 110
44739: PUSH
44740: LD_INT 20
44742: EQUAL
44743: PUSH
44744: LD_VAR 0 1
44748: PUSH
44749: LD_EXP 72
44753: PUSH
44754: LD_VAR 0 3
44758: ARRAY
44759: IN
44760: OR
44761: PUSH
44762: LD_VAR 0 1
44766: PPUSH
44767: CALL_OW 264
44771: PUSH
44772: LD_INT 12
44774: PUSH
44775: LD_INT 51
44777: PUSH
44778: LD_EXP 94
44782: PUSH
44783: LD_INT 32
44785: PUSH
44786: LD_INT 13
44788: PUSH
44789: LD_INT 52
44791: PUSH
44792: LD_INT 31
44794: PUSH
44795: EMPTY
44796: LIST
44797: LIST
44798: LIST
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: IN
44804: OR
44805: AND
44806: IFFALSE 45114
// begin if un in mc_defender [ i ] then
44808: LD_VAR 0 1
44812: PUSH
44813: LD_EXP 72
44817: PUSH
44818: LD_VAR 0 3
44822: ARRAY
44823: IN
44824: IFFALSE 44863
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
44826: LD_ADDR_EXP 72
44830: PUSH
44831: LD_EXP 72
44835: PPUSH
44836: LD_VAR 0 3
44840: PPUSH
44841: LD_EXP 72
44845: PUSH
44846: LD_VAR 0 3
44850: ARRAY
44851: PUSH
44852: LD_VAR 0 1
44856: DIFF
44857: PPUSH
44858: CALL_OW 1
44862: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
44863: LD_ADDR_VAR 0 8
44867: PUSH
44868: LD_VAR 0 3
44872: PPUSH
44873: LD_INT 3
44875: PPUSH
44876: CALL 41532 0 2
44880: ST_TO_ADDR
// if fac then
44881: LD_VAR 0 8
44885: IFFALSE 45114
// begin for j in fac do
44887: LD_ADDR_VAR 0 4
44891: PUSH
44892: LD_VAR 0 8
44896: PUSH
44897: FOR_IN
44898: IFFALSE 45112
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
44900: LD_ADDR_VAR 0 9
44904: PUSH
44905: LD_VAR 0 8
44909: PPUSH
44910: LD_VAR 0 1
44914: PPUSH
44915: CALL_OW 265
44919: PPUSH
44920: LD_VAR 0 1
44924: PPUSH
44925: CALL_OW 262
44929: PPUSH
44930: LD_VAR 0 1
44934: PPUSH
44935: CALL_OW 263
44939: PPUSH
44940: LD_VAR 0 1
44944: PPUSH
44945: CALL_OW 264
44949: PPUSH
44950: CALL 49899 0 5
44954: ST_TO_ADDR
// if components then
44955: LD_VAR 0 9
44959: IFFALSE 45110
// begin if GetWeapon ( un ) = ar_control_tower then
44961: LD_VAR 0 1
44965: PPUSH
44966: CALL_OW 264
44970: PUSH
44971: LD_INT 31
44973: EQUAL
44974: IFFALSE 45091
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
44976: LD_VAR 0 1
44980: PPUSH
44981: CALL_OW 311
44985: PPUSH
44986: LD_INT 0
44988: PPUSH
44989: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
44993: LD_ADDR_EXP 90
44997: PUSH
44998: LD_EXP 90
45002: PPUSH
45003: LD_VAR 0 3
45007: PPUSH
45008: LD_EXP 90
45012: PUSH
45013: LD_VAR 0 3
45017: ARRAY
45018: PUSH
45019: LD_VAR 0 1
45023: PPUSH
45024: CALL_OW 311
45028: DIFF
45029: PPUSH
45030: CALL_OW 1
45034: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
45035: LD_ADDR_VAR 0 7
45039: PUSH
45040: LD_EXP 71
45044: PUSH
45045: LD_VAR 0 3
45049: ARRAY
45050: PPUSH
45051: LD_INT 1
45053: PPUSH
45054: LD_VAR 0 9
45058: PPUSH
45059: CALL_OW 2
45063: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
45064: LD_ADDR_EXP 71
45068: PUSH
45069: LD_EXP 71
45073: PPUSH
45074: LD_VAR 0 3
45078: PPUSH
45079: LD_VAR 0 7
45083: PPUSH
45084: CALL_OW 1
45088: ST_TO_ADDR
// end else
45089: GO 45108
// MC_InsertProduceList ( i , [ components ] ) ;
45091: LD_VAR 0 3
45095: PPUSH
45096: LD_VAR 0 9
45100: PUSH
45101: EMPTY
45102: LIST
45103: PPUSH
45104: CALL 41077 0 2
// break ;
45108: GO 45112
// end ; end ;
45110: GO 44897
45112: POP
45113: POP
// end ; end ; if GetType ( un ) = unit_building then
45114: LD_VAR 0 1
45118: PPUSH
45119: CALL_OW 247
45123: PUSH
45124: LD_INT 3
45126: EQUAL
45127: IFFALSE 45530
// begin btype := GetBType ( un ) ;
45129: LD_ADDR_VAR 0 5
45133: PUSH
45134: LD_VAR 0 1
45138: PPUSH
45139: CALL_OW 266
45143: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
45144: LD_VAR 0 5
45148: PUSH
45149: LD_INT 29
45151: PUSH
45152: LD_INT 30
45154: PUSH
45155: EMPTY
45156: LIST
45157: LIST
45158: IN
45159: IFFALSE 45232
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
45161: LD_VAR 0 1
45165: PPUSH
45166: CALL_OW 250
45170: PPUSH
45171: LD_VAR 0 1
45175: PPUSH
45176: CALL_OW 251
45180: PPUSH
45181: LD_VAR 0 1
45185: PPUSH
45186: CALL_OW 255
45190: PPUSH
45191: CALL_OW 440
45195: NOT
45196: IFFALSE 45232
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45198: LD_VAR 0 1
45202: PPUSH
45203: CALL_OW 250
45207: PPUSH
45208: LD_VAR 0 1
45212: PPUSH
45213: CALL_OW 251
45217: PPUSH
45218: LD_VAR 0 1
45222: PPUSH
45223: CALL_OW 255
45227: PPUSH
45228: CALL_OW 441
// end ; if btype = b_warehouse then
45232: LD_VAR 0 5
45236: PUSH
45237: LD_INT 1
45239: EQUAL
45240: IFFALSE 45258
// begin btype := b_depot ;
45242: LD_ADDR_VAR 0 5
45246: PUSH
45247: LD_INT 0
45249: ST_TO_ADDR
// pos := 1 ;
45250: LD_ADDR_VAR 0 6
45254: PUSH
45255: LD_INT 1
45257: ST_TO_ADDR
// end ; if btype = b_factory then
45258: LD_VAR 0 5
45262: PUSH
45263: LD_INT 3
45265: EQUAL
45266: IFFALSE 45284
// begin btype := b_workshop ;
45268: LD_ADDR_VAR 0 5
45272: PUSH
45273: LD_INT 2
45275: ST_TO_ADDR
// pos := 1 ;
45276: LD_ADDR_VAR 0 6
45280: PUSH
45281: LD_INT 1
45283: ST_TO_ADDR
// end ; if btype = b_barracks then
45284: LD_VAR 0 5
45288: PUSH
45289: LD_INT 5
45291: EQUAL
45292: IFFALSE 45302
// btype := b_armoury ;
45294: LD_ADDR_VAR 0 5
45298: PUSH
45299: LD_INT 4
45301: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
45302: LD_VAR 0 5
45306: PUSH
45307: LD_INT 7
45309: PUSH
45310: LD_INT 8
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: IN
45317: IFFALSE 45327
// btype := b_lab ;
45319: LD_ADDR_VAR 0 5
45323: PUSH
45324: LD_INT 6
45326: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
45327: LD_ADDR_EXP 55
45331: PUSH
45332: LD_EXP 55
45336: PPUSH
45337: LD_VAR 0 3
45341: PUSH
45342: LD_EXP 55
45346: PUSH
45347: LD_VAR 0 3
45351: ARRAY
45352: PUSH
45353: LD_INT 1
45355: PLUS
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: PPUSH
45361: LD_VAR 0 5
45365: PUSH
45366: LD_VAR 0 1
45370: PPUSH
45371: CALL_OW 250
45375: PUSH
45376: LD_VAR 0 1
45380: PPUSH
45381: CALL_OW 251
45385: PUSH
45386: LD_VAR 0 1
45390: PPUSH
45391: CALL_OW 254
45395: PUSH
45396: EMPTY
45397: LIST
45398: LIST
45399: LIST
45400: LIST
45401: PPUSH
45402: CALL 52367 0 3
45406: ST_TO_ADDR
// if pos = 1 then
45407: LD_VAR 0 6
45411: PUSH
45412: LD_INT 1
45414: EQUAL
45415: IFFALSE 45530
// begin tmp := mc_build_list [ i ] ;
45417: LD_ADDR_VAR 0 7
45421: PUSH
45422: LD_EXP 55
45426: PUSH
45427: LD_VAR 0 3
45431: ARRAY
45432: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45433: LD_VAR 0 7
45437: PPUSH
45438: LD_INT 2
45440: PUSH
45441: LD_INT 30
45443: PUSH
45444: LD_INT 0
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PUSH
45451: LD_INT 30
45453: PUSH
45454: LD_INT 1
45456: PUSH
45457: EMPTY
45458: LIST
45459: LIST
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: LIST
45465: PPUSH
45466: CALL_OW 72
45470: IFFALSE 45480
// pos := 2 ;
45472: LD_ADDR_VAR 0 6
45476: PUSH
45477: LD_INT 2
45479: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
45480: LD_ADDR_VAR 0 7
45484: PUSH
45485: LD_VAR 0 7
45489: PPUSH
45490: LD_VAR 0 6
45494: PPUSH
45495: LD_VAR 0 7
45499: PPUSH
45500: CALL 52693 0 3
45504: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
45505: LD_ADDR_EXP 55
45509: PUSH
45510: LD_EXP 55
45514: PPUSH
45515: LD_VAR 0 3
45519: PPUSH
45520: LD_VAR 0 7
45524: PPUSH
45525: CALL_OW 1
45529: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
45530: LD_VAR 0 1
45534: PUSH
45535: LD_EXP 50
45539: PUSH
45540: LD_VAR 0 3
45544: ARRAY
45545: IN
45546: IFFALSE 45585
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
45548: LD_ADDR_EXP 50
45552: PUSH
45553: LD_EXP 50
45557: PPUSH
45558: LD_VAR 0 3
45562: PPUSH
45563: LD_EXP 50
45567: PUSH
45568: LD_VAR 0 3
45572: ARRAY
45573: PUSH
45574: LD_VAR 0 1
45578: DIFF
45579: PPUSH
45580: CALL_OW 1
45584: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
45585: LD_VAR 0 1
45589: PUSH
45590: LD_EXP 57
45594: PUSH
45595: LD_VAR 0 3
45599: ARRAY
45600: IN
45601: IFFALSE 45640
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
45603: LD_ADDR_EXP 57
45607: PUSH
45608: LD_EXP 57
45612: PPUSH
45613: LD_VAR 0 3
45617: PPUSH
45618: LD_EXP 57
45622: PUSH
45623: LD_VAR 0 3
45627: ARRAY
45628: PUSH
45629: LD_VAR 0 1
45633: DIFF
45634: PPUSH
45635: CALL_OW 1
45639: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
45640: LD_VAR 0 1
45644: PUSH
45645: LD_EXP 69
45649: PUSH
45650: LD_VAR 0 3
45654: ARRAY
45655: IN
45656: IFFALSE 45695
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
45658: LD_ADDR_EXP 69
45662: PUSH
45663: LD_EXP 69
45667: PPUSH
45668: LD_VAR 0 3
45672: PPUSH
45673: LD_EXP 69
45677: PUSH
45678: LD_VAR 0 3
45682: ARRAY
45683: PUSH
45684: LD_VAR 0 1
45688: DIFF
45689: PPUSH
45690: CALL_OW 1
45694: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
45695: LD_VAR 0 1
45699: PUSH
45700: LD_EXP 72
45704: PUSH
45705: LD_VAR 0 3
45709: ARRAY
45710: IN
45711: IFFALSE 45750
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45713: LD_ADDR_EXP 72
45717: PUSH
45718: LD_EXP 72
45722: PPUSH
45723: LD_VAR 0 3
45727: PPUSH
45728: LD_EXP 72
45732: PUSH
45733: LD_VAR 0 3
45737: ARRAY
45738: PUSH
45739: LD_VAR 0 1
45743: DIFF
45744: PPUSH
45745: CALL_OW 1
45749: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
45750: LD_VAR 0 1
45754: PUSH
45755: LD_EXP 59
45759: PUSH
45760: LD_VAR 0 3
45764: ARRAY
45765: IN
45766: IFFALSE 45805
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
45768: LD_ADDR_EXP 59
45772: PUSH
45773: LD_EXP 59
45777: PPUSH
45778: LD_VAR 0 3
45782: PPUSH
45783: LD_EXP 59
45787: PUSH
45788: LD_VAR 0 3
45792: ARRAY
45793: PUSH
45794: LD_VAR 0 1
45798: DIFF
45799: PPUSH
45800: CALL_OW 1
45804: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
45805: LD_VAR 0 1
45809: PUSH
45810: LD_EXP 58
45814: PUSH
45815: LD_VAR 0 3
45819: ARRAY
45820: IN
45821: IFFALSE 45860
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
45823: LD_ADDR_EXP 58
45827: PUSH
45828: LD_EXP 58
45832: PPUSH
45833: LD_VAR 0 3
45837: PPUSH
45838: LD_EXP 58
45842: PUSH
45843: LD_VAR 0 3
45847: ARRAY
45848: PUSH
45849: LD_VAR 0 1
45853: DIFF
45854: PPUSH
45855: CALL_OW 1
45859: ST_TO_ADDR
// end ; break ;
45860: GO 45864
// end ;
45862: GO 44510
45864: POP
45865: POP
// end ;
45866: LD_VAR 0 2
45870: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
45871: LD_INT 0
45873: PPUSH
45874: PPUSH
45875: PPUSH
// if not mc_bases or not skirmish then
45876: LD_EXP 50
45880: NOT
45881: PUSH
45882: LD_EXP 48
45886: NOT
45887: OR
45888: IFFALSE 45892
// exit ;
45890: GO 46107
// for i = 1 to mc_bases do
45892: LD_ADDR_VAR 0 3
45896: PUSH
45897: DOUBLE
45898: LD_INT 1
45900: DEC
45901: ST_TO_ADDR
45902: LD_EXP 50
45906: PUSH
45907: FOR_TO
45908: IFFALSE 46105
// begin if building in mc_construct_list [ i ] then
45910: LD_VAR 0 1
45914: PUSH
45915: LD_EXP 57
45919: PUSH
45920: LD_VAR 0 3
45924: ARRAY
45925: IN
45926: IFFALSE 46103
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
45928: LD_ADDR_EXP 57
45932: PUSH
45933: LD_EXP 57
45937: PPUSH
45938: LD_VAR 0 3
45942: PPUSH
45943: LD_EXP 57
45947: PUSH
45948: LD_VAR 0 3
45952: ARRAY
45953: PUSH
45954: LD_VAR 0 1
45958: DIFF
45959: PPUSH
45960: CALL_OW 1
45964: ST_TO_ADDR
// if building in mc_lab [ i ] then
45965: LD_VAR 0 1
45969: PUSH
45970: LD_EXP 83
45974: PUSH
45975: LD_VAR 0 3
45979: ARRAY
45980: IN
45981: IFFALSE 46036
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
45983: LD_ADDR_EXP 84
45987: PUSH
45988: LD_EXP 84
45992: PPUSH
45993: LD_VAR 0 3
45997: PPUSH
45998: LD_EXP 84
46002: PUSH
46003: LD_VAR 0 3
46007: ARRAY
46008: PPUSH
46009: LD_INT 1
46011: PPUSH
46012: LD_EXP 84
46016: PUSH
46017: LD_VAR 0 3
46021: ARRAY
46022: PPUSH
46023: LD_INT 0
46025: PPUSH
46026: CALL 51785 0 4
46030: PPUSH
46031: CALL_OW 1
46035: ST_TO_ADDR
// if not building in mc_bases [ i ] then
46036: LD_VAR 0 1
46040: PUSH
46041: LD_EXP 50
46045: PUSH
46046: LD_VAR 0 3
46050: ARRAY
46051: IN
46052: NOT
46053: IFFALSE 46099
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46055: LD_ADDR_EXP 50
46059: PUSH
46060: LD_EXP 50
46064: PPUSH
46065: LD_VAR 0 3
46069: PUSH
46070: LD_EXP 50
46074: PUSH
46075: LD_VAR 0 3
46079: ARRAY
46080: PUSH
46081: LD_INT 1
46083: PLUS
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PPUSH
46089: LD_VAR 0 1
46093: PPUSH
46094: CALL 52367 0 3
46098: ST_TO_ADDR
// exit ;
46099: POP
46100: POP
46101: GO 46107
// end ; end ;
46103: GO 45907
46105: POP
46106: POP
// end ;
46107: LD_VAR 0 2
46111: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
46112: LD_INT 0
46114: PPUSH
46115: PPUSH
46116: PPUSH
46117: PPUSH
46118: PPUSH
46119: PPUSH
46120: PPUSH
// if not mc_bases or not skirmish then
46121: LD_EXP 50
46125: NOT
46126: PUSH
46127: LD_EXP 48
46131: NOT
46132: OR
46133: IFFALSE 46137
// exit ;
46135: GO 46798
// for i = 1 to mc_bases do
46137: LD_ADDR_VAR 0 3
46141: PUSH
46142: DOUBLE
46143: LD_INT 1
46145: DEC
46146: ST_TO_ADDR
46147: LD_EXP 50
46151: PUSH
46152: FOR_TO
46153: IFFALSE 46796
// begin if building in mc_construct_list [ i ] then
46155: LD_VAR 0 1
46159: PUSH
46160: LD_EXP 57
46164: PUSH
46165: LD_VAR 0 3
46169: ARRAY
46170: IN
46171: IFFALSE 46794
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46173: LD_ADDR_EXP 57
46177: PUSH
46178: LD_EXP 57
46182: PPUSH
46183: LD_VAR 0 3
46187: PPUSH
46188: LD_EXP 57
46192: PUSH
46193: LD_VAR 0 3
46197: ARRAY
46198: PUSH
46199: LD_VAR 0 1
46203: DIFF
46204: PPUSH
46205: CALL_OW 1
46209: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46210: LD_ADDR_EXP 50
46214: PUSH
46215: LD_EXP 50
46219: PPUSH
46220: LD_VAR 0 3
46224: PUSH
46225: LD_EXP 50
46229: PUSH
46230: LD_VAR 0 3
46234: ARRAY
46235: PUSH
46236: LD_INT 1
46238: PLUS
46239: PUSH
46240: EMPTY
46241: LIST
46242: LIST
46243: PPUSH
46244: LD_VAR 0 1
46248: PPUSH
46249: CALL 52367 0 3
46253: ST_TO_ADDR
// btype := GetBType ( building ) ;
46254: LD_ADDR_VAR 0 5
46258: PUSH
46259: LD_VAR 0 1
46263: PPUSH
46264: CALL_OW 266
46268: ST_TO_ADDR
// side := GetSide ( building ) ;
46269: LD_ADDR_VAR 0 8
46273: PUSH
46274: LD_VAR 0 1
46278: PPUSH
46279: CALL_OW 255
46283: ST_TO_ADDR
// if btype = b_lab then
46284: LD_VAR 0 5
46288: PUSH
46289: LD_INT 6
46291: EQUAL
46292: IFFALSE 46342
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
46294: LD_ADDR_EXP 83
46298: PUSH
46299: LD_EXP 83
46303: PPUSH
46304: LD_VAR 0 3
46308: PUSH
46309: LD_EXP 83
46313: PUSH
46314: LD_VAR 0 3
46318: ARRAY
46319: PUSH
46320: LD_INT 1
46322: PLUS
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: PPUSH
46328: LD_VAR 0 1
46332: PPUSH
46333: CALL 52367 0 3
46337: ST_TO_ADDR
// exit ;
46338: POP
46339: POP
46340: GO 46798
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
46342: LD_VAR 0 5
46346: PUSH
46347: LD_INT 0
46349: PUSH
46350: LD_INT 2
46352: PUSH
46353: LD_INT 4
46355: PUSH
46356: EMPTY
46357: LIST
46358: LIST
46359: LIST
46360: IN
46361: IFFALSE 46485
// begin if btype = b_armoury then
46363: LD_VAR 0 5
46367: PUSH
46368: LD_INT 4
46370: EQUAL
46371: IFFALSE 46381
// btype := b_barracks ;
46373: LD_ADDR_VAR 0 5
46377: PUSH
46378: LD_INT 5
46380: ST_TO_ADDR
// if btype = b_depot then
46381: LD_VAR 0 5
46385: PUSH
46386: LD_INT 0
46388: EQUAL
46389: IFFALSE 46399
// btype := b_warehouse ;
46391: LD_ADDR_VAR 0 5
46395: PUSH
46396: LD_INT 1
46398: ST_TO_ADDR
// if btype = b_workshop then
46399: LD_VAR 0 5
46403: PUSH
46404: LD_INT 2
46406: EQUAL
46407: IFFALSE 46417
// btype := b_factory ;
46409: LD_ADDR_VAR 0 5
46413: PUSH
46414: LD_INT 3
46416: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
46417: LD_VAR 0 5
46421: PPUSH
46422: LD_VAR 0 8
46426: PPUSH
46427: CALL_OW 323
46431: PUSH
46432: LD_INT 1
46434: EQUAL
46435: IFFALSE 46481
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
46437: LD_ADDR_EXP 82
46441: PUSH
46442: LD_EXP 82
46446: PPUSH
46447: LD_VAR 0 3
46451: PUSH
46452: LD_EXP 82
46456: PUSH
46457: LD_VAR 0 3
46461: ARRAY
46462: PUSH
46463: LD_INT 1
46465: PLUS
46466: PUSH
46467: EMPTY
46468: LIST
46469: LIST
46470: PPUSH
46471: LD_VAR 0 1
46475: PPUSH
46476: CALL 52367 0 3
46480: ST_TO_ADDR
// exit ;
46481: POP
46482: POP
46483: GO 46798
// end ; if btype in [ b_bunker , b_turret ] then
46485: LD_VAR 0 5
46489: PUSH
46490: LD_INT 32
46492: PUSH
46493: LD_INT 33
46495: PUSH
46496: EMPTY
46497: LIST
46498: LIST
46499: IN
46500: IFFALSE 46790
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
46502: LD_ADDR_EXP 58
46506: PUSH
46507: LD_EXP 58
46511: PPUSH
46512: LD_VAR 0 3
46516: PUSH
46517: LD_EXP 58
46521: PUSH
46522: LD_VAR 0 3
46526: ARRAY
46527: PUSH
46528: LD_INT 1
46530: PLUS
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: PPUSH
46536: LD_VAR 0 1
46540: PPUSH
46541: CALL 52367 0 3
46545: ST_TO_ADDR
// if btype = b_bunker then
46546: LD_VAR 0 5
46550: PUSH
46551: LD_INT 32
46553: EQUAL
46554: IFFALSE 46790
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46556: LD_ADDR_EXP 59
46560: PUSH
46561: LD_EXP 59
46565: PPUSH
46566: LD_VAR 0 3
46570: PUSH
46571: LD_EXP 59
46575: PUSH
46576: LD_VAR 0 3
46580: ARRAY
46581: PUSH
46582: LD_INT 1
46584: PLUS
46585: PUSH
46586: EMPTY
46587: LIST
46588: LIST
46589: PPUSH
46590: LD_VAR 0 1
46594: PPUSH
46595: CALL 52367 0 3
46599: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
46600: LD_ADDR_VAR 0 6
46604: PUSH
46605: LD_EXP 50
46609: PUSH
46610: LD_VAR 0 3
46614: ARRAY
46615: PPUSH
46616: LD_INT 25
46618: PUSH
46619: LD_INT 1
46621: PUSH
46622: EMPTY
46623: LIST
46624: LIST
46625: PUSH
46626: LD_INT 3
46628: PUSH
46629: LD_INT 54
46631: PUSH
46632: EMPTY
46633: LIST
46634: PUSH
46635: EMPTY
46636: LIST
46637: LIST
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: PPUSH
46643: CALL_OW 72
46647: ST_TO_ADDR
// if tmp then
46648: LD_VAR 0 6
46652: IFFALSE 46658
// exit ;
46654: POP
46655: POP
46656: GO 46798
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
46658: LD_ADDR_VAR 0 6
46662: PUSH
46663: LD_EXP 50
46667: PUSH
46668: LD_VAR 0 3
46672: ARRAY
46673: PPUSH
46674: LD_INT 2
46676: PUSH
46677: LD_INT 30
46679: PUSH
46680: LD_INT 4
46682: PUSH
46683: EMPTY
46684: LIST
46685: LIST
46686: PUSH
46687: LD_INT 30
46689: PUSH
46690: LD_INT 5
46692: PUSH
46693: EMPTY
46694: LIST
46695: LIST
46696: PUSH
46697: EMPTY
46698: LIST
46699: LIST
46700: LIST
46701: PPUSH
46702: CALL_OW 72
46706: ST_TO_ADDR
// if not tmp then
46707: LD_VAR 0 6
46711: NOT
46712: IFFALSE 46718
// exit ;
46714: POP
46715: POP
46716: GO 46798
// for j in tmp do
46718: LD_ADDR_VAR 0 4
46722: PUSH
46723: LD_VAR 0 6
46727: PUSH
46728: FOR_IN
46729: IFFALSE 46788
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
46731: LD_ADDR_VAR 0 7
46735: PUSH
46736: LD_VAR 0 4
46740: PPUSH
46741: CALL_OW 313
46745: PPUSH
46746: LD_INT 25
46748: PUSH
46749: LD_INT 1
46751: PUSH
46752: EMPTY
46753: LIST
46754: LIST
46755: PPUSH
46756: CALL_OW 72
46760: ST_TO_ADDR
// if units then
46761: LD_VAR 0 7
46765: IFFALSE 46786
// begin ComExitBuilding ( units [ 1 ] ) ;
46767: LD_VAR 0 7
46771: PUSH
46772: LD_INT 1
46774: ARRAY
46775: PPUSH
46776: CALL_OW 122
// exit ;
46780: POP
46781: POP
46782: POP
46783: POP
46784: GO 46798
// end ; end ;
46786: GO 46728
46788: POP
46789: POP
// end ; end ; exit ;
46790: POP
46791: POP
46792: GO 46798
// end ; end ;
46794: GO 46152
46796: POP
46797: POP
// end ;
46798: LD_VAR 0 2
46802: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
46803: LD_INT 0
46805: PPUSH
46806: PPUSH
46807: PPUSH
46808: PPUSH
46809: PPUSH
46810: PPUSH
46811: PPUSH
// if not mc_bases or not skirmish then
46812: LD_EXP 50
46816: NOT
46817: PUSH
46818: LD_EXP 48
46822: NOT
46823: OR
46824: IFFALSE 46828
// exit ;
46826: GO 47059
// btype := GetBType ( building ) ;
46828: LD_ADDR_VAR 0 6
46832: PUSH
46833: LD_VAR 0 1
46837: PPUSH
46838: CALL_OW 266
46842: ST_TO_ADDR
// x := GetX ( building ) ;
46843: LD_ADDR_VAR 0 7
46847: PUSH
46848: LD_VAR 0 1
46852: PPUSH
46853: CALL_OW 250
46857: ST_TO_ADDR
// y := GetY ( building ) ;
46858: LD_ADDR_VAR 0 8
46862: PUSH
46863: LD_VAR 0 1
46867: PPUSH
46868: CALL_OW 251
46872: ST_TO_ADDR
// d := GetDir ( building ) ;
46873: LD_ADDR_VAR 0 9
46877: PUSH
46878: LD_VAR 0 1
46882: PPUSH
46883: CALL_OW 254
46887: ST_TO_ADDR
// for i = 1 to mc_bases do
46888: LD_ADDR_VAR 0 4
46892: PUSH
46893: DOUBLE
46894: LD_INT 1
46896: DEC
46897: ST_TO_ADDR
46898: LD_EXP 50
46902: PUSH
46903: FOR_TO
46904: IFFALSE 47057
// begin if not mc_build_list [ i ] then
46906: LD_EXP 55
46910: PUSH
46911: LD_VAR 0 4
46915: ARRAY
46916: NOT
46917: IFFALSE 46921
// continue ;
46919: GO 46903
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
46921: LD_VAR 0 6
46925: PUSH
46926: LD_VAR 0 7
46930: PUSH
46931: LD_VAR 0 8
46935: PUSH
46936: LD_VAR 0 9
46940: PUSH
46941: EMPTY
46942: LIST
46943: LIST
46944: LIST
46945: LIST
46946: PPUSH
46947: LD_EXP 55
46951: PUSH
46952: LD_VAR 0 4
46956: ARRAY
46957: PUSH
46958: LD_INT 1
46960: ARRAY
46961: PPUSH
46962: CALL 58536 0 2
46966: IFFALSE 47055
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
46968: LD_ADDR_EXP 55
46972: PUSH
46973: LD_EXP 55
46977: PPUSH
46978: LD_VAR 0 4
46982: PPUSH
46983: LD_EXP 55
46987: PUSH
46988: LD_VAR 0 4
46992: ARRAY
46993: PPUSH
46994: LD_INT 1
46996: PPUSH
46997: CALL_OW 3
47001: PPUSH
47002: CALL_OW 1
47006: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
47007: LD_ADDR_EXP 57
47011: PUSH
47012: LD_EXP 57
47016: PPUSH
47017: LD_VAR 0 4
47021: PUSH
47022: LD_EXP 57
47026: PUSH
47027: LD_VAR 0 4
47031: ARRAY
47032: PUSH
47033: LD_INT 1
47035: PLUS
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: PPUSH
47041: LD_VAR 0 1
47045: PPUSH
47046: CALL 52367 0 3
47050: ST_TO_ADDR
// exit ;
47051: POP
47052: POP
47053: GO 47059
// end ; end ;
47055: GO 46903
47057: POP
47058: POP
// end ;
47059: LD_VAR 0 3
47063: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
47064: LD_INT 0
47066: PPUSH
47067: PPUSH
47068: PPUSH
// if not mc_bases or not skirmish then
47069: LD_EXP 50
47073: NOT
47074: PUSH
47075: LD_EXP 48
47079: NOT
47080: OR
47081: IFFALSE 47085
// exit ;
47083: GO 47275
// for i = 1 to mc_bases do
47085: LD_ADDR_VAR 0 4
47089: PUSH
47090: DOUBLE
47091: LD_INT 1
47093: DEC
47094: ST_TO_ADDR
47095: LD_EXP 50
47099: PUSH
47100: FOR_TO
47101: IFFALSE 47188
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
47103: LD_VAR 0 1
47107: PUSH
47108: LD_EXP 58
47112: PUSH
47113: LD_VAR 0 4
47117: ARRAY
47118: IN
47119: PUSH
47120: LD_VAR 0 1
47124: PUSH
47125: LD_EXP 59
47129: PUSH
47130: LD_VAR 0 4
47134: ARRAY
47135: IN
47136: NOT
47137: AND
47138: IFFALSE 47186
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47140: LD_ADDR_EXP 59
47144: PUSH
47145: LD_EXP 59
47149: PPUSH
47150: LD_VAR 0 4
47154: PUSH
47155: LD_EXP 59
47159: PUSH
47160: LD_VAR 0 4
47164: ARRAY
47165: PUSH
47166: LD_INT 1
47168: PLUS
47169: PUSH
47170: EMPTY
47171: LIST
47172: LIST
47173: PPUSH
47174: LD_VAR 0 1
47178: PPUSH
47179: CALL 52367 0 3
47183: ST_TO_ADDR
// break ;
47184: GO 47188
// end ; end ;
47186: GO 47100
47188: POP
47189: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47190: LD_VAR 0 1
47194: PPUSH
47195: CALL_OW 257
47199: PUSH
47200: LD_EXP 76
47204: IN
47205: PUSH
47206: LD_VAR 0 1
47210: PPUSH
47211: CALL_OW 266
47215: PUSH
47216: LD_INT 5
47218: EQUAL
47219: AND
47220: PUSH
47221: LD_VAR 0 2
47225: PPUSH
47226: CALL_OW 110
47230: PUSH
47231: LD_INT 18
47233: NONEQUAL
47234: AND
47235: IFFALSE 47275
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47237: LD_VAR 0 2
47241: PPUSH
47242: CALL_OW 257
47246: PUSH
47247: LD_INT 5
47249: PUSH
47250: LD_INT 8
47252: PUSH
47253: LD_INT 9
47255: PUSH
47256: EMPTY
47257: LIST
47258: LIST
47259: LIST
47260: IN
47261: IFFALSE 47275
// SetClass ( unit , 1 ) ;
47263: LD_VAR 0 2
47267: PPUSH
47268: LD_INT 1
47270: PPUSH
47271: CALL_OW 336
// end ;
47275: LD_VAR 0 3
47279: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
47280: LD_INT 0
47282: PPUSH
47283: PPUSH
// if not mc_bases or not skirmish then
47284: LD_EXP 50
47288: NOT
47289: PUSH
47290: LD_EXP 48
47294: NOT
47295: OR
47296: IFFALSE 47300
// exit ;
47298: GO 47416
// if GetLives ( abandoned_vehicle ) > 250 then
47300: LD_VAR 0 2
47304: PPUSH
47305: CALL_OW 256
47309: PUSH
47310: LD_INT 250
47312: GREATER
47313: IFFALSE 47317
// exit ;
47315: GO 47416
// for i = 1 to mc_bases do
47317: LD_ADDR_VAR 0 6
47321: PUSH
47322: DOUBLE
47323: LD_INT 1
47325: DEC
47326: ST_TO_ADDR
47327: LD_EXP 50
47331: PUSH
47332: FOR_TO
47333: IFFALSE 47414
// begin if driver in mc_bases [ i ] then
47335: LD_VAR 0 1
47339: PUSH
47340: LD_EXP 50
47344: PUSH
47345: LD_VAR 0 6
47349: ARRAY
47350: IN
47351: IFFALSE 47412
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
47353: LD_VAR 0 1
47357: PPUSH
47358: LD_EXP 50
47362: PUSH
47363: LD_VAR 0 6
47367: ARRAY
47368: PPUSH
47369: LD_INT 2
47371: PUSH
47372: LD_INT 30
47374: PUSH
47375: LD_INT 0
47377: PUSH
47378: EMPTY
47379: LIST
47380: LIST
47381: PUSH
47382: LD_INT 30
47384: PUSH
47385: LD_INT 1
47387: PUSH
47388: EMPTY
47389: LIST
47390: LIST
47391: PUSH
47392: EMPTY
47393: LIST
47394: LIST
47395: LIST
47396: PPUSH
47397: CALL_OW 72
47401: PUSH
47402: LD_INT 1
47404: ARRAY
47405: PPUSH
47406: CALL_OW 112
// break ;
47410: GO 47414
// end ; end ;
47412: GO 47332
47414: POP
47415: POP
// end ; end_of_file
47416: LD_VAR 0 5
47420: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
47421: LD_INT 0
47423: PPUSH
47424: PPUSH
// if exist_mode then
47425: LD_VAR 0 2
47429: IFFALSE 47454
// unit := CreateCharacter ( prefix & ident ) else
47431: LD_ADDR_VAR 0 5
47435: PUSH
47436: LD_VAR 0 3
47440: PUSH
47441: LD_VAR 0 1
47445: STR
47446: PPUSH
47447: CALL_OW 34
47451: ST_TO_ADDR
47452: GO 47469
// unit := NewCharacter ( ident ) ;
47454: LD_ADDR_VAR 0 5
47458: PUSH
47459: LD_VAR 0 1
47463: PPUSH
47464: CALL_OW 25
47468: ST_TO_ADDR
// result := unit ;
47469: LD_ADDR_VAR 0 4
47473: PUSH
47474: LD_VAR 0 5
47478: ST_TO_ADDR
// end ;
47479: LD_VAR 0 4
47483: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
47484: LD_INT 0
47486: PPUSH
47487: PPUSH
// if not side or not nation then
47488: LD_VAR 0 1
47492: NOT
47493: PUSH
47494: LD_VAR 0 2
47498: NOT
47499: OR
47500: IFFALSE 47504
// exit ;
47502: GO 48268
// case nation of nation_american :
47504: LD_VAR 0 2
47508: PUSH
47509: LD_INT 1
47511: DOUBLE
47512: EQUAL
47513: IFTRUE 47517
47515: GO 47731
47517: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
47518: LD_ADDR_VAR 0 4
47522: PUSH
47523: LD_INT 35
47525: PUSH
47526: LD_INT 45
47528: PUSH
47529: LD_INT 46
47531: PUSH
47532: LD_INT 47
47534: PUSH
47535: LD_INT 82
47537: PUSH
47538: LD_INT 83
47540: PUSH
47541: LD_INT 84
47543: PUSH
47544: LD_INT 85
47546: PUSH
47547: LD_INT 86
47549: PUSH
47550: LD_INT 1
47552: PUSH
47553: LD_INT 2
47555: PUSH
47556: LD_INT 6
47558: PUSH
47559: LD_INT 15
47561: PUSH
47562: LD_INT 16
47564: PUSH
47565: LD_INT 7
47567: PUSH
47568: LD_INT 12
47570: PUSH
47571: LD_INT 13
47573: PUSH
47574: LD_INT 10
47576: PUSH
47577: LD_INT 14
47579: PUSH
47580: LD_INT 20
47582: PUSH
47583: LD_INT 21
47585: PUSH
47586: LD_INT 22
47588: PUSH
47589: LD_INT 25
47591: PUSH
47592: LD_INT 32
47594: PUSH
47595: LD_INT 27
47597: PUSH
47598: LD_INT 36
47600: PUSH
47601: LD_INT 69
47603: PUSH
47604: LD_INT 39
47606: PUSH
47607: LD_INT 34
47609: PUSH
47610: LD_INT 40
47612: PUSH
47613: LD_INT 48
47615: PUSH
47616: LD_INT 49
47618: PUSH
47619: LD_INT 50
47621: PUSH
47622: LD_INT 51
47624: PUSH
47625: LD_INT 52
47627: PUSH
47628: LD_INT 53
47630: PUSH
47631: LD_INT 54
47633: PUSH
47634: LD_INT 55
47636: PUSH
47637: LD_INT 56
47639: PUSH
47640: LD_INT 57
47642: PUSH
47643: LD_INT 58
47645: PUSH
47646: LD_INT 59
47648: PUSH
47649: LD_INT 60
47651: PUSH
47652: LD_INT 61
47654: PUSH
47655: LD_INT 62
47657: PUSH
47658: LD_INT 80
47660: PUSH
47661: LD_INT 82
47663: PUSH
47664: LD_INT 83
47666: PUSH
47667: LD_INT 84
47669: PUSH
47670: LD_INT 85
47672: PUSH
47673: LD_INT 86
47675: PUSH
47676: EMPTY
47677: LIST
47678: LIST
47679: LIST
47680: LIST
47681: LIST
47682: LIST
47683: LIST
47684: LIST
47685: LIST
47686: LIST
47687: LIST
47688: LIST
47689: LIST
47690: LIST
47691: LIST
47692: LIST
47693: LIST
47694: LIST
47695: LIST
47696: LIST
47697: LIST
47698: LIST
47699: LIST
47700: LIST
47701: LIST
47702: LIST
47703: LIST
47704: LIST
47705: LIST
47706: LIST
47707: LIST
47708: LIST
47709: LIST
47710: LIST
47711: LIST
47712: LIST
47713: LIST
47714: LIST
47715: LIST
47716: LIST
47717: LIST
47718: LIST
47719: LIST
47720: LIST
47721: LIST
47722: LIST
47723: LIST
47724: LIST
47725: LIST
47726: LIST
47727: LIST
47728: ST_TO_ADDR
47729: GO 48192
47731: LD_INT 2
47733: DOUBLE
47734: EQUAL
47735: IFTRUE 47739
47737: GO 47961
47739: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
47740: LD_ADDR_VAR 0 4
47744: PUSH
47745: LD_INT 35
47747: PUSH
47748: LD_INT 45
47750: PUSH
47751: LD_INT 46
47753: PUSH
47754: LD_INT 47
47756: PUSH
47757: LD_INT 82
47759: PUSH
47760: LD_INT 83
47762: PUSH
47763: LD_INT 84
47765: PUSH
47766: LD_INT 85
47768: PUSH
47769: LD_INT 87
47771: PUSH
47772: LD_INT 70
47774: PUSH
47775: LD_INT 1
47777: PUSH
47778: LD_INT 11
47780: PUSH
47781: LD_INT 3
47783: PUSH
47784: LD_INT 4
47786: PUSH
47787: LD_INT 5
47789: PUSH
47790: LD_INT 6
47792: PUSH
47793: LD_INT 15
47795: PUSH
47796: LD_INT 18
47798: PUSH
47799: LD_INT 7
47801: PUSH
47802: LD_INT 17
47804: PUSH
47805: LD_INT 8
47807: PUSH
47808: LD_INT 20
47810: PUSH
47811: LD_INT 21
47813: PUSH
47814: LD_INT 22
47816: PUSH
47817: LD_INT 72
47819: PUSH
47820: LD_INT 26
47822: PUSH
47823: LD_INT 69
47825: PUSH
47826: LD_INT 39
47828: PUSH
47829: LD_INT 40
47831: PUSH
47832: LD_INT 41
47834: PUSH
47835: LD_INT 42
47837: PUSH
47838: LD_INT 43
47840: PUSH
47841: LD_INT 48
47843: PUSH
47844: LD_INT 49
47846: PUSH
47847: LD_INT 50
47849: PUSH
47850: LD_INT 51
47852: PUSH
47853: LD_INT 52
47855: PUSH
47856: LD_INT 53
47858: PUSH
47859: LD_INT 54
47861: PUSH
47862: LD_INT 55
47864: PUSH
47865: LD_INT 56
47867: PUSH
47868: LD_INT 60
47870: PUSH
47871: LD_INT 61
47873: PUSH
47874: LD_INT 62
47876: PUSH
47877: LD_INT 66
47879: PUSH
47880: LD_INT 67
47882: PUSH
47883: LD_INT 68
47885: PUSH
47886: LD_INT 81
47888: PUSH
47889: LD_INT 82
47891: PUSH
47892: LD_INT 83
47894: PUSH
47895: LD_INT 84
47897: PUSH
47898: LD_INT 85
47900: PUSH
47901: LD_INT 87
47903: PUSH
47904: EMPTY
47905: LIST
47906: LIST
47907: LIST
47908: LIST
47909: LIST
47910: LIST
47911: LIST
47912: LIST
47913: LIST
47914: LIST
47915: LIST
47916: LIST
47917: LIST
47918: LIST
47919: LIST
47920: LIST
47921: LIST
47922: LIST
47923: LIST
47924: LIST
47925: LIST
47926: LIST
47927: LIST
47928: LIST
47929: LIST
47930: LIST
47931: LIST
47932: LIST
47933: LIST
47934: LIST
47935: LIST
47936: LIST
47937: LIST
47938: LIST
47939: LIST
47940: LIST
47941: LIST
47942: LIST
47943: LIST
47944: LIST
47945: LIST
47946: LIST
47947: LIST
47948: LIST
47949: LIST
47950: LIST
47951: LIST
47952: LIST
47953: LIST
47954: LIST
47955: LIST
47956: LIST
47957: LIST
47958: ST_TO_ADDR
47959: GO 48192
47961: LD_INT 3
47963: DOUBLE
47964: EQUAL
47965: IFTRUE 47969
47967: GO 48191
47969: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
47970: LD_ADDR_VAR 0 4
47974: PUSH
47975: LD_INT 46
47977: PUSH
47978: LD_INT 47
47980: PUSH
47981: LD_INT 1
47983: PUSH
47984: LD_INT 2
47986: PUSH
47987: LD_INT 82
47989: PUSH
47990: LD_INT 83
47992: PUSH
47993: LD_INT 84
47995: PUSH
47996: LD_INT 85
47998: PUSH
47999: LD_INT 86
48001: PUSH
48002: LD_INT 11
48004: PUSH
48005: LD_INT 9
48007: PUSH
48008: LD_INT 20
48010: PUSH
48011: LD_INT 19
48013: PUSH
48014: LD_INT 21
48016: PUSH
48017: LD_INT 24
48019: PUSH
48020: LD_INT 22
48022: PUSH
48023: LD_INT 25
48025: PUSH
48026: LD_INT 28
48028: PUSH
48029: LD_INT 29
48031: PUSH
48032: LD_INT 30
48034: PUSH
48035: LD_INT 31
48037: PUSH
48038: LD_INT 37
48040: PUSH
48041: LD_INT 38
48043: PUSH
48044: LD_INT 32
48046: PUSH
48047: LD_INT 27
48049: PUSH
48050: LD_INT 33
48052: PUSH
48053: LD_INT 69
48055: PUSH
48056: LD_INT 39
48058: PUSH
48059: LD_INT 34
48061: PUSH
48062: LD_INT 40
48064: PUSH
48065: LD_INT 71
48067: PUSH
48068: LD_INT 23
48070: PUSH
48071: LD_INT 44
48073: PUSH
48074: LD_INT 48
48076: PUSH
48077: LD_INT 49
48079: PUSH
48080: LD_INT 50
48082: PUSH
48083: LD_INT 51
48085: PUSH
48086: LD_INT 52
48088: PUSH
48089: LD_INT 53
48091: PUSH
48092: LD_INT 54
48094: PUSH
48095: LD_INT 55
48097: PUSH
48098: LD_INT 56
48100: PUSH
48101: LD_INT 57
48103: PUSH
48104: LD_INT 58
48106: PUSH
48107: LD_INT 59
48109: PUSH
48110: LD_INT 63
48112: PUSH
48113: LD_INT 64
48115: PUSH
48116: LD_INT 65
48118: PUSH
48119: LD_INT 82
48121: PUSH
48122: LD_INT 83
48124: PUSH
48125: LD_INT 84
48127: PUSH
48128: LD_INT 85
48130: PUSH
48131: LD_INT 86
48133: PUSH
48134: EMPTY
48135: LIST
48136: LIST
48137: LIST
48138: LIST
48139: LIST
48140: LIST
48141: LIST
48142: LIST
48143: LIST
48144: LIST
48145: LIST
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: LIST
48153: LIST
48154: LIST
48155: LIST
48156: LIST
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: LIST
48162: LIST
48163: LIST
48164: LIST
48165: LIST
48166: LIST
48167: LIST
48168: LIST
48169: LIST
48170: LIST
48171: LIST
48172: LIST
48173: LIST
48174: LIST
48175: LIST
48176: LIST
48177: LIST
48178: LIST
48179: LIST
48180: LIST
48181: LIST
48182: LIST
48183: LIST
48184: LIST
48185: LIST
48186: LIST
48187: LIST
48188: ST_TO_ADDR
48189: GO 48192
48191: POP
// if state > - 1 and state < 3 then
48192: LD_VAR 0 3
48196: PUSH
48197: LD_INT 1
48199: NEG
48200: GREATER
48201: PUSH
48202: LD_VAR 0 3
48206: PUSH
48207: LD_INT 3
48209: LESS
48210: AND
48211: IFFALSE 48268
// for i in result do
48213: LD_ADDR_VAR 0 5
48217: PUSH
48218: LD_VAR 0 4
48222: PUSH
48223: FOR_IN
48224: IFFALSE 48266
// if GetTech ( i , side ) <> state then
48226: LD_VAR 0 5
48230: PPUSH
48231: LD_VAR 0 1
48235: PPUSH
48236: CALL_OW 321
48240: PUSH
48241: LD_VAR 0 3
48245: NONEQUAL
48246: IFFALSE 48264
// result := result diff i ;
48248: LD_ADDR_VAR 0 4
48252: PUSH
48253: LD_VAR 0 4
48257: PUSH
48258: LD_VAR 0 5
48262: DIFF
48263: ST_TO_ADDR
48264: GO 48223
48266: POP
48267: POP
// end ;
48268: LD_VAR 0 4
48272: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
48273: LD_INT 0
48275: PPUSH
48276: PPUSH
48277: PPUSH
// result := true ;
48278: LD_ADDR_VAR 0 3
48282: PUSH
48283: LD_INT 1
48285: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
48286: LD_ADDR_VAR 0 5
48290: PUSH
48291: LD_VAR 0 2
48295: PPUSH
48296: CALL_OW 480
48300: ST_TO_ADDR
// if not tmp then
48301: LD_VAR 0 5
48305: NOT
48306: IFFALSE 48310
// exit ;
48308: GO 48359
// for i in tmp do
48310: LD_ADDR_VAR 0 4
48314: PUSH
48315: LD_VAR 0 5
48319: PUSH
48320: FOR_IN
48321: IFFALSE 48357
// if GetTech ( i , side ) <> state_researched then
48323: LD_VAR 0 4
48327: PPUSH
48328: LD_VAR 0 1
48332: PPUSH
48333: CALL_OW 321
48337: PUSH
48338: LD_INT 2
48340: NONEQUAL
48341: IFFALSE 48355
// begin result := false ;
48343: LD_ADDR_VAR 0 3
48347: PUSH
48348: LD_INT 0
48350: ST_TO_ADDR
// exit ;
48351: POP
48352: POP
48353: GO 48359
// end ;
48355: GO 48320
48357: POP
48358: POP
// end ;
48359: LD_VAR 0 3
48363: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
48364: LD_INT 0
48366: PPUSH
48367: PPUSH
48368: PPUSH
48369: PPUSH
48370: PPUSH
48371: PPUSH
48372: PPUSH
48373: PPUSH
48374: PPUSH
48375: PPUSH
48376: PPUSH
48377: PPUSH
48378: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
48379: LD_VAR 0 1
48383: NOT
48384: PUSH
48385: LD_VAR 0 1
48389: PPUSH
48390: CALL_OW 257
48394: PUSH
48395: LD_INT 9
48397: NONEQUAL
48398: OR
48399: IFFALSE 48403
// exit ;
48401: GO 48976
// side := GetSide ( unit ) ;
48403: LD_ADDR_VAR 0 9
48407: PUSH
48408: LD_VAR 0 1
48412: PPUSH
48413: CALL_OW 255
48417: ST_TO_ADDR
// tech_space := tech_spacanom ;
48418: LD_ADDR_VAR 0 12
48422: PUSH
48423: LD_INT 29
48425: ST_TO_ADDR
// tech_time := tech_taurad ;
48426: LD_ADDR_VAR 0 13
48430: PUSH
48431: LD_INT 28
48433: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
48434: LD_ADDR_VAR 0 11
48438: PUSH
48439: LD_VAR 0 1
48443: PPUSH
48444: CALL_OW 310
48448: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
48449: LD_VAR 0 11
48453: PPUSH
48454: CALL_OW 247
48458: PUSH
48459: LD_INT 2
48461: EQUAL
48462: IFFALSE 48466
// exit ;
48464: GO 48976
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48466: LD_ADDR_VAR 0 8
48470: PUSH
48471: LD_INT 81
48473: PUSH
48474: LD_VAR 0 9
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: PUSH
48483: LD_INT 3
48485: PUSH
48486: LD_INT 21
48488: PUSH
48489: LD_INT 3
48491: PUSH
48492: EMPTY
48493: LIST
48494: LIST
48495: PUSH
48496: EMPTY
48497: LIST
48498: LIST
48499: PUSH
48500: EMPTY
48501: LIST
48502: LIST
48503: PPUSH
48504: CALL_OW 69
48508: ST_TO_ADDR
// if not tmp then
48509: LD_VAR 0 8
48513: NOT
48514: IFFALSE 48518
// exit ;
48516: GO 48976
// if in_unit then
48518: LD_VAR 0 11
48522: IFFALSE 48546
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
48524: LD_ADDR_VAR 0 10
48528: PUSH
48529: LD_VAR 0 8
48533: PPUSH
48534: LD_VAR 0 11
48538: PPUSH
48539: CALL_OW 74
48543: ST_TO_ADDR
48544: GO 48566
// enemy := NearestUnitToUnit ( tmp , unit ) ;
48546: LD_ADDR_VAR 0 10
48550: PUSH
48551: LD_VAR 0 8
48555: PPUSH
48556: LD_VAR 0 1
48560: PPUSH
48561: CALL_OW 74
48565: ST_TO_ADDR
// if not enemy then
48566: LD_VAR 0 10
48570: NOT
48571: IFFALSE 48575
// exit ;
48573: GO 48976
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
48575: LD_VAR 0 11
48579: PUSH
48580: LD_VAR 0 11
48584: PPUSH
48585: LD_VAR 0 10
48589: PPUSH
48590: CALL_OW 296
48594: PUSH
48595: LD_INT 13
48597: GREATER
48598: AND
48599: PUSH
48600: LD_VAR 0 1
48604: PPUSH
48605: LD_VAR 0 10
48609: PPUSH
48610: CALL_OW 296
48614: PUSH
48615: LD_INT 12
48617: GREATER
48618: OR
48619: IFFALSE 48623
// exit ;
48621: GO 48976
// missile := [ 1 ] ;
48623: LD_ADDR_VAR 0 14
48627: PUSH
48628: LD_INT 1
48630: PUSH
48631: EMPTY
48632: LIST
48633: ST_TO_ADDR
// if Researched ( side , tech_space ) then
48634: LD_VAR 0 9
48638: PPUSH
48639: LD_VAR 0 12
48643: PPUSH
48644: CALL_OW 325
48648: IFFALSE 48677
// missile := Insert ( missile , missile + 1 , 2 ) ;
48650: LD_ADDR_VAR 0 14
48654: PUSH
48655: LD_VAR 0 14
48659: PPUSH
48660: LD_VAR 0 14
48664: PUSH
48665: LD_INT 1
48667: PLUS
48668: PPUSH
48669: LD_INT 2
48671: PPUSH
48672: CALL_OW 2
48676: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
48677: LD_VAR 0 9
48681: PPUSH
48682: LD_VAR 0 13
48686: PPUSH
48687: CALL_OW 325
48691: PUSH
48692: LD_VAR 0 10
48696: PPUSH
48697: CALL_OW 255
48701: PPUSH
48702: LD_VAR 0 13
48706: PPUSH
48707: CALL_OW 325
48711: NOT
48712: AND
48713: IFFALSE 48742
// missile := Insert ( missile , missile + 1 , 3 ) ;
48715: LD_ADDR_VAR 0 14
48719: PUSH
48720: LD_VAR 0 14
48724: PPUSH
48725: LD_VAR 0 14
48729: PUSH
48730: LD_INT 1
48732: PLUS
48733: PPUSH
48734: LD_INT 3
48736: PPUSH
48737: CALL_OW 2
48741: ST_TO_ADDR
// if missile < 2 then
48742: LD_VAR 0 14
48746: PUSH
48747: LD_INT 2
48749: LESS
48750: IFFALSE 48754
// exit ;
48752: GO 48976
// x := GetX ( enemy ) ;
48754: LD_ADDR_VAR 0 4
48758: PUSH
48759: LD_VAR 0 10
48763: PPUSH
48764: CALL_OW 250
48768: ST_TO_ADDR
// y := GetY ( enemy ) ;
48769: LD_ADDR_VAR 0 5
48773: PUSH
48774: LD_VAR 0 10
48778: PPUSH
48779: CALL_OW 251
48783: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
48784: LD_ADDR_VAR 0 6
48788: PUSH
48789: LD_VAR 0 4
48793: PUSH
48794: LD_INT 1
48796: NEG
48797: PPUSH
48798: LD_INT 1
48800: PPUSH
48801: CALL_OW 12
48805: PLUS
48806: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
48807: LD_ADDR_VAR 0 7
48811: PUSH
48812: LD_VAR 0 5
48816: PUSH
48817: LD_INT 1
48819: NEG
48820: PPUSH
48821: LD_INT 1
48823: PPUSH
48824: CALL_OW 12
48828: PLUS
48829: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48830: LD_VAR 0 6
48834: PPUSH
48835: LD_VAR 0 7
48839: PPUSH
48840: CALL_OW 488
48844: NOT
48845: IFFALSE 48867
// begin _x := x ;
48847: LD_ADDR_VAR 0 6
48851: PUSH
48852: LD_VAR 0 4
48856: ST_TO_ADDR
// _y := y ;
48857: LD_ADDR_VAR 0 7
48861: PUSH
48862: LD_VAR 0 5
48866: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
48867: LD_ADDR_VAR 0 3
48871: PUSH
48872: LD_INT 1
48874: PPUSH
48875: LD_VAR 0 14
48879: PPUSH
48880: CALL_OW 12
48884: ST_TO_ADDR
// case i of 1 :
48885: LD_VAR 0 3
48889: PUSH
48890: LD_INT 1
48892: DOUBLE
48893: EQUAL
48894: IFTRUE 48898
48896: GO 48915
48898: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
48899: LD_VAR 0 1
48903: PPUSH
48904: LD_VAR 0 10
48908: PPUSH
48909: CALL_OW 115
48913: GO 48976
48915: LD_INT 2
48917: DOUBLE
48918: EQUAL
48919: IFTRUE 48923
48921: GO 48945
48923: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
48924: LD_VAR 0 1
48928: PPUSH
48929: LD_VAR 0 6
48933: PPUSH
48934: LD_VAR 0 7
48938: PPUSH
48939: CALL_OW 153
48943: GO 48976
48945: LD_INT 3
48947: DOUBLE
48948: EQUAL
48949: IFTRUE 48953
48951: GO 48975
48953: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
48954: LD_VAR 0 1
48958: PPUSH
48959: LD_VAR 0 6
48963: PPUSH
48964: LD_VAR 0 7
48968: PPUSH
48969: CALL_OW 154
48973: GO 48976
48975: POP
// end ;
48976: LD_VAR 0 2
48980: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
48981: LD_INT 0
48983: PPUSH
48984: PPUSH
48985: PPUSH
48986: PPUSH
48987: PPUSH
48988: PPUSH
// if not unit or not building then
48989: LD_VAR 0 1
48993: NOT
48994: PUSH
48995: LD_VAR 0 2
48999: NOT
49000: OR
49001: IFFALSE 49005
// exit ;
49003: GO 49163
// x := GetX ( building ) ;
49005: LD_ADDR_VAR 0 5
49009: PUSH
49010: LD_VAR 0 2
49014: PPUSH
49015: CALL_OW 250
49019: ST_TO_ADDR
// y := GetY ( building ) ;
49020: LD_ADDR_VAR 0 6
49024: PUSH
49025: LD_VAR 0 2
49029: PPUSH
49030: CALL_OW 251
49034: ST_TO_ADDR
// for i = 0 to 5 do
49035: LD_ADDR_VAR 0 4
49039: PUSH
49040: DOUBLE
49041: LD_INT 0
49043: DEC
49044: ST_TO_ADDR
49045: LD_INT 5
49047: PUSH
49048: FOR_TO
49049: IFFALSE 49161
// begin _x := ShiftX ( x , i , 3 ) ;
49051: LD_ADDR_VAR 0 7
49055: PUSH
49056: LD_VAR 0 5
49060: PPUSH
49061: LD_VAR 0 4
49065: PPUSH
49066: LD_INT 3
49068: PPUSH
49069: CALL_OW 272
49073: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
49074: LD_ADDR_VAR 0 8
49078: PUSH
49079: LD_VAR 0 6
49083: PPUSH
49084: LD_VAR 0 4
49088: PPUSH
49089: LD_INT 3
49091: PPUSH
49092: CALL_OW 273
49096: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49097: LD_VAR 0 7
49101: PPUSH
49102: LD_VAR 0 8
49106: PPUSH
49107: CALL_OW 488
49111: NOT
49112: IFFALSE 49116
// continue ;
49114: GO 49048
// if HexInfo ( _x , _y ) = 0 then
49116: LD_VAR 0 7
49120: PPUSH
49121: LD_VAR 0 8
49125: PPUSH
49126: CALL_OW 428
49130: PUSH
49131: LD_INT 0
49133: EQUAL
49134: IFFALSE 49159
// begin ComMoveXY ( unit , _x , _y ) ;
49136: LD_VAR 0 1
49140: PPUSH
49141: LD_VAR 0 7
49145: PPUSH
49146: LD_VAR 0 8
49150: PPUSH
49151: CALL_OW 111
// exit ;
49155: POP
49156: POP
49157: GO 49163
// end ; end ;
49159: GO 49048
49161: POP
49162: POP
// end ;
49163: LD_VAR 0 3
49167: RET
// export function ScanBase ( side , base_area ) ; begin
49168: LD_INT 0
49170: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
49171: LD_ADDR_VAR 0 3
49175: PUSH
49176: LD_VAR 0 2
49180: PPUSH
49181: LD_INT 81
49183: PUSH
49184: LD_VAR 0 1
49188: PUSH
49189: EMPTY
49190: LIST
49191: LIST
49192: PPUSH
49193: CALL_OW 70
49197: ST_TO_ADDR
// end ;
49198: LD_VAR 0 3
49202: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
49203: LD_INT 0
49205: PPUSH
49206: PPUSH
49207: PPUSH
49208: PPUSH
// result := false ;
49209: LD_ADDR_VAR 0 2
49213: PUSH
49214: LD_INT 0
49216: ST_TO_ADDR
// side := GetSide ( unit ) ;
49217: LD_ADDR_VAR 0 3
49221: PUSH
49222: LD_VAR 0 1
49226: PPUSH
49227: CALL_OW 255
49231: ST_TO_ADDR
// nat := GetNation ( unit ) ;
49232: LD_ADDR_VAR 0 4
49236: PUSH
49237: LD_VAR 0 1
49241: PPUSH
49242: CALL_OW 248
49246: ST_TO_ADDR
// case nat of 1 :
49247: LD_VAR 0 4
49251: PUSH
49252: LD_INT 1
49254: DOUBLE
49255: EQUAL
49256: IFTRUE 49260
49258: GO 49271
49260: POP
// tech := tech_lassight ; 2 :
49261: LD_ADDR_VAR 0 5
49265: PUSH
49266: LD_INT 12
49268: ST_TO_ADDR
49269: GO 49310
49271: LD_INT 2
49273: DOUBLE
49274: EQUAL
49275: IFTRUE 49279
49277: GO 49290
49279: POP
// tech := tech_mortar ; 3 :
49280: LD_ADDR_VAR 0 5
49284: PUSH
49285: LD_INT 41
49287: ST_TO_ADDR
49288: GO 49310
49290: LD_INT 3
49292: DOUBLE
49293: EQUAL
49294: IFTRUE 49298
49296: GO 49309
49298: POP
// tech := tech_bazooka ; end ;
49299: LD_ADDR_VAR 0 5
49303: PUSH
49304: LD_INT 44
49306: ST_TO_ADDR
49307: GO 49310
49309: POP
// if Researched ( side , tech ) then
49310: LD_VAR 0 3
49314: PPUSH
49315: LD_VAR 0 5
49319: PPUSH
49320: CALL_OW 325
49324: IFFALSE 49351
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
49326: LD_ADDR_VAR 0 2
49330: PUSH
49331: LD_INT 5
49333: PUSH
49334: LD_INT 8
49336: PUSH
49337: LD_INT 9
49339: PUSH
49340: EMPTY
49341: LIST
49342: LIST
49343: LIST
49344: PUSH
49345: LD_VAR 0 4
49349: ARRAY
49350: ST_TO_ADDR
// end ;
49351: LD_VAR 0 2
49355: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
49356: LD_INT 0
49358: PPUSH
49359: PPUSH
49360: PPUSH
// if not mines then
49361: LD_VAR 0 2
49365: NOT
49366: IFFALSE 49370
// exit ;
49368: GO 49514
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49370: LD_ADDR_VAR 0 5
49374: PUSH
49375: LD_INT 81
49377: PUSH
49378: LD_VAR 0 1
49382: PUSH
49383: EMPTY
49384: LIST
49385: LIST
49386: PUSH
49387: LD_INT 3
49389: PUSH
49390: LD_INT 21
49392: PUSH
49393: LD_INT 3
49395: PUSH
49396: EMPTY
49397: LIST
49398: LIST
49399: PUSH
49400: EMPTY
49401: LIST
49402: LIST
49403: PUSH
49404: EMPTY
49405: LIST
49406: LIST
49407: PPUSH
49408: CALL_OW 69
49412: ST_TO_ADDR
// for i in mines do
49413: LD_ADDR_VAR 0 4
49417: PUSH
49418: LD_VAR 0 2
49422: PUSH
49423: FOR_IN
49424: IFFALSE 49512
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
49426: LD_VAR 0 4
49430: PUSH
49431: LD_INT 1
49433: ARRAY
49434: PPUSH
49435: LD_VAR 0 4
49439: PUSH
49440: LD_INT 2
49442: ARRAY
49443: PPUSH
49444: CALL_OW 458
49448: NOT
49449: IFFALSE 49453
// continue ;
49451: GO 49423
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
49453: LD_VAR 0 4
49457: PUSH
49458: LD_INT 1
49460: ARRAY
49461: PPUSH
49462: LD_VAR 0 4
49466: PUSH
49467: LD_INT 2
49469: ARRAY
49470: PPUSH
49471: CALL_OW 428
49475: PUSH
49476: LD_VAR 0 5
49480: IN
49481: IFFALSE 49510
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
49483: LD_VAR 0 4
49487: PUSH
49488: LD_INT 1
49490: ARRAY
49491: PPUSH
49492: LD_VAR 0 4
49496: PUSH
49497: LD_INT 2
49499: ARRAY
49500: PPUSH
49501: LD_VAR 0 1
49505: PPUSH
49506: CALL_OW 456
// end ;
49510: GO 49423
49512: POP
49513: POP
// end ;
49514: LD_VAR 0 3
49518: RET
// export function Count ( array ) ; var i ; begin
49519: LD_INT 0
49521: PPUSH
49522: PPUSH
// result := 0 ;
49523: LD_ADDR_VAR 0 2
49527: PUSH
49528: LD_INT 0
49530: ST_TO_ADDR
// for i in array do
49531: LD_ADDR_VAR 0 3
49535: PUSH
49536: LD_VAR 0 1
49540: PUSH
49541: FOR_IN
49542: IFFALSE 49566
// if i then
49544: LD_VAR 0 3
49548: IFFALSE 49564
// result := result + 1 ;
49550: LD_ADDR_VAR 0 2
49554: PUSH
49555: LD_VAR 0 2
49559: PUSH
49560: LD_INT 1
49562: PLUS
49563: ST_TO_ADDR
49564: GO 49541
49566: POP
49567: POP
// end ;
49568: LD_VAR 0 2
49572: RET
// export function IsEmpty ( building ) ; begin
49573: LD_INT 0
49575: PPUSH
// if not building then
49576: LD_VAR 0 1
49580: NOT
49581: IFFALSE 49585
// exit ;
49583: GO 49628
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
49585: LD_ADDR_VAR 0 2
49589: PUSH
49590: LD_VAR 0 1
49594: PUSH
49595: LD_INT 22
49597: PUSH
49598: LD_VAR 0 1
49602: PPUSH
49603: CALL_OW 255
49607: PUSH
49608: EMPTY
49609: LIST
49610: LIST
49611: PUSH
49612: LD_INT 58
49614: PUSH
49615: EMPTY
49616: LIST
49617: PUSH
49618: EMPTY
49619: LIST
49620: LIST
49621: PPUSH
49622: CALL_OW 69
49626: IN
49627: ST_TO_ADDR
// end ;
49628: LD_VAR 0 2
49632: RET
// export function IsNotFull ( building ) ; begin
49633: LD_INT 0
49635: PPUSH
// if not building then
49636: LD_VAR 0 1
49640: NOT
49641: IFFALSE 49645
// exit ;
49643: GO 49664
// result := UnitsInside ( building ) < 6 ;
49645: LD_ADDR_VAR 0 2
49649: PUSH
49650: LD_VAR 0 1
49654: PPUSH
49655: CALL_OW 313
49659: PUSH
49660: LD_INT 6
49662: LESS
49663: ST_TO_ADDR
// end ;
49664: LD_VAR 0 2
49668: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
49669: LD_INT 0
49671: PPUSH
49672: PPUSH
49673: PPUSH
49674: PPUSH
// tmp := [ ] ;
49675: LD_ADDR_VAR 0 3
49679: PUSH
49680: EMPTY
49681: ST_TO_ADDR
// list := [ ] ;
49682: LD_ADDR_VAR 0 5
49686: PUSH
49687: EMPTY
49688: ST_TO_ADDR
// for i = 16 to 25 do
49689: LD_ADDR_VAR 0 4
49693: PUSH
49694: DOUBLE
49695: LD_INT 16
49697: DEC
49698: ST_TO_ADDR
49699: LD_INT 25
49701: PUSH
49702: FOR_TO
49703: IFFALSE 49776
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
49705: LD_ADDR_VAR 0 3
49709: PUSH
49710: LD_VAR 0 3
49714: PUSH
49715: LD_INT 22
49717: PUSH
49718: LD_VAR 0 1
49722: PPUSH
49723: CALL_OW 255
49727: PUSH
49728: EMPTY
49729: LIST
49730: LIST
49731: PUSH
49732: LD_INT 91
49734: PUSH
49735: LD_VAR 0 1
49739: PUSH
49740: LD_INT 6
49742: PUSH
49743: EMPTY
49744: LIST
49745: LIST
49746: LIST
49747: PUSH
49748: LD_INT 30
49750: PUSH
49751: LD_VAR 0 4
49755: PUSH
49756: EMPTY
49757: LIST
49758: LIST
49759: PUSH
49760: EMPTY
49761: LIST
49762: LIST
49763: LIST
49764: PUSH
49765: EMPTY
49766: LIST
49767: PPUSH
49768: CALL_OW 69
49772: ADD
49773: ST_TO_ADDR
49774: GO 49702
49776: POP
49777: POP
// for i = 1 to tmp do
49778: LD_ADDR_VAR 0 4
49782: PUSH
49783: DOUBLE
49784: LD_INT 1
49786: DEC
49787: ST_TO_ADDR
49788: LD_VAR 0 3
49792: PUSH
49793: FOR_TO
49794: IFFALSE 49882
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
49796: LD_ADDR_VAR 0 5
49800: PUSH
49801: LD_VAR 0 5
49805: PUSH
49806: LD_VAR 0 3
49810: PUSH
49811: LD_VAR 0 4
49815: ARRAY
49816: PPUSH
49817: CALL_OW 266
49821: PUSH
49822: LD_VAR 0 3
49826: PUSH
49827: LD_VAR 0 4
49831: ARRAY
49832: PPUSH
49833: CALL_OW 250
49837: PUSH
49838: LD_VAR 0 3
49842: PUSH
49843: LD_VAR 0 4
49847: ARRAY
49848: PPUSH
49849: CALL_OW 251
49853: PUSH
49854: LD_VAR 0 3
49858: PUSH
49859: LD_VAR 0 4
49863: ARRAY
49864: PPUSH
49865: CALL_OW 254
49869: PUSH
49870: EMPTY
49871: LIST
49872: LIST
49873: LIST
49874: LIST
49875: PUSH
49876: EMPTY
49877: LIST
49878: ADD
49879: ST_TO_ADDR
49880: GO 49793
49882: POP
49883: POP
// result := list ;
49884: LD_ADDR_VAR 0 2
49888: PUSH
49889: LD_VAR 0 5
49893: ST_TO_ADDR
// end ;
49894: LD_VAR 0 2
49898: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
49899: LD_INT 0
49901: PPUSH
49902: PPUSH
49903: PPUSH
49904: PPUSH
49905: PPUSH
49906: PPUSH
49907: PPUSH
// if not factory then
49908: LD_VAR 0 1
49912: NOT
49913: IFFALSE 49917
// exit ;
49915: GO 50510
// if control = control_apeman then
49917: LD_VAR 0 4
49921: PUSH
49922: LD_INT 5
49924: EQUAL
49925: IFFALSE 50034
// begin tmp := UnitsInside ( factory ) ;
49927: LD_ADDR_VAR 0 8
49931: PUSH
49932: LD_VAR 0 1
49936: PPUSH
49937: CALL_OW 313
49941: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
49942: LD_VAR 0 8
49946: PPUSH
49947: LD_INT 25
49949: PUSH
49950: LD_INT 12
49952: PUSH
49953: EMPTY
49954: LIST
49955: LIST
49956: PPUSH
49957: CALL_OW 72
49961: NOT
49962: IFFALSE 49972
// control := control_manual ;
49964: LD_ADDR_VAR 0 4
49968: PUSH
49969: LD_INT 1
49971: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
49972: LD_ADDR_VAR 0 8
49976: PUSH
49977: LD_VAR 0 1
49981: PPUSH
49982: CALL 49669 0 1
49986: ST_TO_ADDR
// if tmp then
49987: LD_VAR 0 8
49991: IFFALSE 50034
// begin for i in tmp do
49993: LD_ADDR_VAR 0 7
49997: PUSH
49998: LD_VAR 0 8
50002: PUSH
50003: FOR_IN
50004: IFFALSE 50032
// if i [ 1 ] = b_ext_radio then
50006: LD_VAR 0 7
50010: PUSH
50011: LD_INT 1
50013: ARRAY
50014: PUSH
50015: LD_INT 22
50017: EQUAL
50018: IFFALSE 50030
// begin control := control_remote ;
50020: LD_ADDR_VAR 0 4
50024: PUSH
50025: LD_INT 2
50027: ST_TO_ADDR
// break ;
50028: GO 50032
// end ;
50030: GO 50003
50032: POP
50033: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50034: LD_VAR 0 1
50038: PPUSH
50039: LD_VAR 0 2
50043: PPUSH
50044: LD_VAR 0 3
50048: PPUSH
50049: LD_VAR 0 4
50053: PPUSH
50054: LD_VAR 0 5
50058: PPUSH
50059: CALL_OW 448
50063: IFFALSE 50098
// begin result := [ chassis , engine , control , weapon ] ;
50065: LD_ADDR_VAR 0 6
50069: PUSH
50070: LD_VAR 0 2
50074: PUSH
50075: LD_VAR 0 3
50079: PUSH
50080: LD_VAR 0 4
50084: PUSH
50085: LD_VAR 0 5
50089: PUSH
50090: EMPTY
50091: LIST
50092: LIST
50093: LIST
50094: LIST
50095: ST_TO_ADDR
// exit ;
50096: GO 50510
// end ; _chassis := AvailableChassisList ( factory ) ;
50098: LD_ADDR_VAR 0 9
50102: PUSH
50103: LD_VAR 0 1
50107: PPUSH
50108: CALL_OW 475
50112: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
50113: LD_ADDR_VAR 0 11
50117: PUSH
50118: LD_VAR 0 1
50122: PPUSH
50123: CALL_OW 476
50127: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
50128: LD_ADDR_VAR 0 12
50132: PUSH
50133: LD_VAR 0 1
50137: PPUSH
50138: CALL_OW 477
50142: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
50143: LD_ADDR_VAR 0 10
50147: PUSH
50148: LD_VAR 0 1
50152: PPUSH
50153: CALL_OW 478
50157: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
50158: LD_VAR 0 9
50162: NOT
50163: PUSH
50164: LD_VAR 0 11
50168: NOT
50169: OR
50170: PUSH
50171: LD_VAR 0 12
50175: NOT
50176: OR
50177: PUSH
50178: LD_VAR 0 10
50182: NOT
50183: OR
50184: IFFALSE 50219
// begin result := [ chassis , engine , control , weapon ] ;
50186: LD_ADDR_VAR 0 6
50190: PUSH
50191: LD_VAR 0 2
50195: PUSH
50196: LD_VAR 0 3
50200: PUSH
50201: LD_VAR 0 4
50205: PUSH
50206: LD_VAR 0 5
50210: PUSH
50211: EMPTY
50212: LIST
50213: LIST
50214: LIST
50215: LIST
50216: ST_TO_ADDR
// exit ;
50217: GO 50510
// end ; if not chassis in _chassis then
50219: LD_VAR 0 2
50223: PUSH
50224: LD_VAR 0 9
50228: IN
50229: NOT
50230: IFFALSE 50256
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
50232: LD_ADDR_VAR 0 2
50236: PUSH
50237: LD_VAR 0 9
50241: PUSH
50242: LD_INT 1
50244: PPUSH
50245: LD_VAR 0 9
50249: PPUSH
50250: CALL_OW 12
50254: ARRAY
50255: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
50256: LD_VAR 0 2
50260: PPUSH
50261: LD_VAR 0 3
50265: PPUSH
50266: CALL 50515 0 2
50270: NOT
50271: IFFALSE 50330
// repeat engine := _engine [ 1 ] ;
50273: LD_ADDR_VAR 0 3
50277: PUSH
50278: LD_VAR 0 11
50282: PUSH
50283: LD_INT 1
50285: ARRAY
50286: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
50287: LD_ADDR_VAR 0 11
50291: PUSH
50292: LD_VAR 0 11
50296: PPUSH
50297: LD_INT 1
50299: PPUSH
50300: CALL_OW 3
50304: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
50305: LD_VAR 0 2
50309: PPUSH
50310: LD_VAR 0 3
50314: PPUSH
50315: CALL 50515 0 2
50319: PUSH
50320: LD_VAR 0 11
50324: PUSH
50325: EMPTY
50326: EQUAL
50327: OR
50328: IFFALSE 50273
// if not control in _control then
50330: LD_VAR 0 4
50334: PUSH
50335: LD_VAR 0 12
50339: IN
50340: NOT
50341: IFFALSE 50367
// control := _control [ rand ( 1 , _control ) ] ;
50343: LD_ADDR_VAR 0 4
50347: PUSH
50348: LD_VAR 0 12
50352: PUSH
50353: LD_INT 1
50355: PPUSH
50356: LD_VAR 0 12
50360: PPUSH
50361: CALL_OW 12
50365: ARRAY
50366: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
50367: LD_VAR 0 2
50371: PPUSH
50372: LD_VAR 0 5
50376: PPUSH
50377: CALL 50735 0 2
50381: NOT
50382: IFFALSE 50441
// repeat weapon := _weapon [ 1 ] ;
50384: LD_ADDR_VAR 0 5
50388: PUSH
50389: LD_VAR 0 10
50393: PUSH
50394: LD_INT 1
50396: ARRAY
50397: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
50398: LD_ADDR_VAR 0 10
50402: PUSH
50403: LD_VAR 0 10
50407: PPUSH
50408: LD_INT 1
50410: PPUSH
50411: CALL_OW 3
50415: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
50416: LD_VAR 0 2
50420: PPUSH
50421: LD_VAR 0 5
50425: PPUSH
50426: CALL 50735 0 2
50430: PUSH
50431: LD_VAR 0 10
50435: PUSH
50436: EMPTY
50437: EQUAL
50438: OR
50439: IFFALSE 50384
// result := [ ] ;
50441: LD_ADDR_VAR 0 6
50445: PUSH
50446: EMPTY
50447: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50448: LD_VAR 0 1
50452: PPUSH
50453: LD_VAR 0 2
50457: PPUSH
50458: LD_VAR 0 3
50462: PPUSH
50463: LD_VAR 0 4
50467: PPUSH
50468: LD_VAR 0 5
50472: PPUSH
50473: CALL_OW 448
50477: IFFALSE 50510
// result := [ chassis , engine , control , weapon ] ;
50479: LD_ADDR_VAR 0 6
50483: PUSH
50484: LD_VAR 0 2
50488: PUSH
50489: LD_VAR 0 3
50493: PUSH
50494: LD_VAR 0 4
50498: PUSH
50499: LD_VAR 0 5
50503: PUSH
50504: EMPTY
50505: LIST
50506: LIST
50507: LIST
50508: LIST
50509: ST_TO_ADDR
// end ;
50510: LD_VAR 0 6
50514: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
50515: LD_INT 0
50517: PPUSH
// if not chassis or not engine then
50518: LD_VAR 0 1
50522: NOT
50523: PUSH
50524: LD_VAR 0 2
50528: NOT
50529: OR
50530: IFFALSE 50534
// exit ;
50532: GO 50730
// case engine of engine_solar :
50534: LD_VAR 0 2
50538: PUSH
50539: LD_INT 2
50541: DOUBLE
50542: EQUAL
50543: IFTRUE 50547
50545: GO 50585
50547: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
50548: LD_ADDR_VAR 0 3
50552: PUSH
50553: LD_INT 11
50555: PUSH
50556: LD_INT 12
50558: PUSH
50559: LD_INT 13
50561: PUSH
50562: LD_INT 14
50564: PUSH
50565: LD_INT 1
50567: PUSH
50568: LD_INT 2
50570: PUSH
50571: LD_INT 3
50573: PUSH
50574: EMPTY
50575: LIST
50576: LIST
50577: LIST
50578: LIST
50579: LIST
50580: LIST
50581: LIST
50582: ST_TO_ADDR
50583: GO 50714
50585: LD_INT 1
50587: DOUBLE
50588: EQUAL
50589: IFTRUE 50593
50591: GO 50655
50593: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
50594: LD_ADDR_VAR 0 3
50598: PUSH
50599: LD_INT 11
50601: PUSH
50602: LD_INT 12
50604: PUSH
50605: LD_INT 13
50607: PUSH
50608: LD_INT 14
50610: PUSH
50611: LD_INT 1
50613: PUSH
50614: LD_INT 2
50616: PUSH
50617: LD_INT 3
50619: PUSH
50620: LD_INT 4
50622: PUSH
50623: LD_INT 5
50625: PUSH
50626: LD_INT 21
50628: PUSH
50629: LD_INT 23
50631: PUSH
50632: LD_INT 22
50634: PUSH
50635: LD_INT 24
50637: PUSH
50638: EMPTY
50639: LIST
50640: LIST
50641: LIST
50642: LIST
50643: LIST
50644: LIST
50645: LIST
50646: LIST
50647: LIST
50648: LIST
50649: LIST
50650: LIST
50651: LIST
50652: ST_TO_ADDR
50653: GO 50714
50655: LD_INT 3
50657: DOUBLE
50658: EQUAL
50659: IFTRUE 50663
50661: GO 50713
50663: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
50664: LD_ADDR_VAR 0 3
50668: PUSH
50669: LD_INT 13
50671: PUSH
50672: LD_INT 14
50674: PUSH
50675: LD_INT 2
50677: PUSH
50678: LD_INT 3
50680: PUSH
50681: LD_INT 4
50683: PUSH
50684: LD_INT 5
50686: PUSH
50687: LD_INT 21
50689: PUSH
50690: LD_INT 22
50692: PUSH
50693: LD_INT 23
50695: PUSH
50696: LD_INT 24
50698: PUSH
50699: EMPTY
50700: LIST
50701: LIST
50702: LIST
50703: LIST
50704: LIST
50705: LIST
50706: LIST
50707: LIST
50708: LIST
50709: LIST
50710: ST_TO_ADDR
50711: GO 50714
50713: POP
// result := ( chassis in result ) ;
50714: LD_ADDR_VAR 0 3
50718: PUSH
50719: LD_VAR 0 1
50723: PUSH
50724: LD_VAR 0 3
50728: IN
50729: ST_TO_ADDR
// end ;
50730: LD_VAR 0 3
50734: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
50735: LD_INT 0
50737: PPUSH
// if not chassis or not weapon then
50738: LD_VAR 0 1
50742: NOT
50743: PUSH
50744: LD_VAR 0 2
50748: NOT
50749: OR
50750: IFFALSE 50754
// exit ;
50752: GO 51780
// case weapon of us_machine_gun :
50754: LD_VAR 0 2
50758: PUSH
50759: LD_INT 2
50761: DOUBLE
50762: EQUAL
50763: IFTRUE 50767
50765: GO 50797
50767: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
50768: LD_ADDR_VAR 0 3
50772: PUSH
50773: LD_INT 1
50775: PUSH
50776: LD_INT 2
50778: PUSH
50779: LD_INT 3
50781: PUSH
50782: LD_INT 4
50784: PUSH
50785: LD_INT 5
50787: PUSH
50788: EMPTY
50789: LIST
50790: LIST
50791: LIST
50792: LIST
50793: LIST
50794: ST_TO_ADDR
50795: GO 51764
50797: LD_INT 3
50799: DOUBLE
50800: EQUAL
50801: IFTRUE 50805
50803: GO 50835
50805: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
50806: LD_ADDR_VAR 0 3
50810: PUSH
50811: LD_INT 1
50813: PUSH
50814: LD_INT 2
50816: PUSH
50817: LD_INT 3
50819: PUSH
50820: LD_INT 4
50822: PUSH
50823: LD_INT 5
50825: PUSH
50826: EMPTY
50827: LIST
50828: LIST
50829: LIST
50830: LIST
50831: LIST
50832: ST_TO_ADDR
50833: GO 51764
50835: LD_INT 11
50837: DOUBLE
50838: EQUAL
50839: IFTRUE 50843
50841: GO 50873
50843: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
50844: LD_ADDR_VAR 0 3
50848: PUSH
50849: LD_INT 1
50851: PUSH
50852: LD_INT 2
50854: PUSH
50855: LD_INT 3
50857: PUSH
50858: LD_INT 4
50860: PUSH
50861: LD_INT 5
50863: PUSH
50864: EMPTY
50865: LIST
50866: LIST
50867: LIST
50868: LIST
50869: LIST
50870: ST_TO_ADDR
50871: GO 51764
50873: LD_INT 4
50875: DOUBLE
50876: EQUAL
50877: IFTRUE 50881
50879: GO 50907
50881: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
50882: LD_ADDR_VAR 0 3
50886: PUSH
50887: LD_INT 2
50889: PUSH
50890: LD_INT 3
50892: PUSH
50893: LD_INT 4
50895: PUSH
50896: LD_INT 5
50898: PUSH
50899: EMPTY
50900: LIST
50901: LIST
50902: LIST
50903: LIST
50904: ST_TO_ADDR
50905: GO 51764
50907: LD_INT 5
50909: DOUBLE
50910: EQUAL
50911: IFTRUE 50915
50913: GO 50941
50915: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
50916: LD_ADDR_VAR 0 3
50920: PUSH
50921: LD_INT 2
50923: PUSH
50924: LD_INT 3
50926: PUSH
50927: LD_INT 4
50929: PUSH
50930: LD_INT 5
50932: PUSH
50933: EMPTY
50934: LIST
50935: LIST
50936: LIST
50937: LIST
50938: ST_TO_ADDR
50939: GO 51764
50941: LD_INT 9
50943: DOUBLE
50944: EQUAL
50945: IFTRUE 50949
50947: GO 50975
50949: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
50950: LD_ADDR_VAR 0 3
50954: PUSH
50955: LD_INT 2
50957: PUSH
50958: LD_INT 3
50960: PUSH
50961: LD_INT 4
50963: PUSH
50964: LD_INT 5
50966: PUSH
50967: EMPTY
50968: LIST
50969: LIST
50970: LIST
50971: LIST
50972: ST_TO_ADDR
50973: GO 51764
50975: LD_INT 7
50977: DOUBLE
50978: EQUAL
50979: IFTRUE 50983
50981: GO 51009
50983: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
50984: LD_ADDR_VAR 0 3
50988: PUSH
50989: LD_INT 2
50991: PUSH
50992: LD_INT 3
50994: PUSH
50995: LD_INT 4
50997: PUSH
50998: LD_INT 5
51000: PUSH
51001: EMPTY
51002: LIST
51003: LIST
51004: LIST
51005: LIST
51006: ST_TO_ADDR
51007: GO 51764
51009: LD_INT 12
51011: DOUBLE
51012: EQUAL
51013: IFTRUE 51017
51015: GO 51043
51017: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
51018: LD_ADDR_VAR 0 3
51022: PUSH
51023: LD_INT 2
51025: PUSH
51026: LD_INT 3
51028: PUSH
51029: LD_INT 4
51031: PUSH
51032: LD_INT 5
51034: PUSH
51035: EMPTY
51036: LIST
51037: LIST
51038: LIST
51039: LIST
51040: ST_TO_ADDR
51041: GO 51764
51043: LD_INT 13
51045: DOUBLE
51046: EQUAL
51047: IFTRUE 51051
51049: GO 51077
51051: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
51052: LD_ADDR_VAR 0 3
51056: PUSH
51057: LD_INT 2
51059: PUSH
51060: LD_INT 3
51062: PUSH
51063: LD_INT 4
51065: PUSH
51066: LD_INT 5
51068: PUSH
51069: EMPTY
51070: LIST
51071: LIST
51072: LIST
51073: LIST
51074: ST_TO_ADDR
51075: GO 51764
51077: LD_INT 14
51079: DOUBLE
51080: EQUAL
51081: IFTRUE 51085
51083: GO 51103
51085: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
51086: LD_ADDR_VAR 0 3
51090: PUSH
51091: LD_INT 4
51093: PUSH
51094: LD_INT 5
51096: PUSH
51097: EMPTY
51098: LIST
51099: LIST
51100: ST_TO_ADDR
51101: GO 51764
51103: LD_INT 6
51105: DOUBLE
51106: EQUAL
51107: IFTRUE 51111
51109: GO 51129
51111: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
51112: LD_ADDR_VAR 0 3
51116: PUSH
51117: LD_INT 4
51119: PUSH
51120: LD_INT 5
51122: PUSH
51123: EMPTY
51124: LIST
51125: LIST
51126: ST_TO_ADDR
51127: GO 51764
51129: LD_INT 10
51131: DOUBLE
51132: EQUAL
51133: IFTRUE 51137
51135: GO 51155
51137: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
51138: LD_ADDR_VAR 0 3
51142: PUSH
51143: LD_INT 4
51145: PUSH
51146: LD_INT 5
51148: PUSH
51149: EMPTY
51150: LIST
51151: LIST
51152: ST_TO_ADDR
51153: GO 51764
51155: LD_INT 22
51157: DOUBLE
51158: EQUAL
51159: IFTRUE 51163
51161: GO 51189
51163: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
51164: LD_ADDR_VAR 0 3
51168: PUSH
51169: LD_INT 11
51171: PUSH
51172: LD_INT 12
51174: PUSH
51175: LD_INT 13
51177: PUSH
51178: LD_INT 14
51180: PUSH
51181: EMPTY
51182: LIST
51183: LIST
51184: LIST
51185: LIST
51186: ST_TO_ADDR
51187: GO 51764
51189: LD_INT 23
51191: DOUBLE
51192: EQUAL
51193: IFTRUE 51197
51195: GO 51223
51197: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
51198: LD_ADDR_VAR 0 3
51202: PUSH
51203: LD_INT 11
51205: PUSH
51206: LD_INT 12
51208: PUSH
51209: LD_INT 13
51211: PUSH
51212: LD_INT 14
51214: PUSH
51215: EMPTY
51216: LIST
51217: LIST
51218: LIST
51219: LIST
51220: ST_TO_ADDR
51221: GO 51764
51223: LD_INT 24
51225: DOUBLE
51226: EQUAL
51227: IFTRUE 51231
51229: GO 51257
51231: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
51232: LD_ADDR_VAR 0 3
51236: PUSH
51237: LD_INT 11
51239: PUSH
51240: LD_INT 12
51242: PUSH
51243: LD_INT 13
51245: PUSH
51246: LD_INT 14
51248: PUSH
51249: EMPTY
51250: LIST
51251: LIST
51252: LIST
51253: LIST
51254: ST_TO_ADDR
51255: GO 51764
51257: LD_INT 30
51259: DOUBLE
51260: EQUAL
51261: IFTRUE 51265
51263: GO 51291
51265: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
51266: LD_ADDR_VAR 0 3
51270: PUSH
51271: LD_INT 11
51273: PUSH
51274: LD_INT 12
51276: PUSH
51277: LD_INT 13
51279: PUSH
51280: LD_INT 14
51282: PUSH
51283: EMPTY
51284: LIST
51285: LIST
51286: LIST
51287: LIST
51288: ST_TO_ADDR
51289: GO 51764
51291: LD_INT 25
51293: DOUBLE
51294: EQUAL
51295: IFTRUE 51299
51297: GO 51317
51299: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
51300: LD_ADDR_VAR 0 3
51304: PUSH
51305: LD_INT 13
51307: PUSH
51308: LD_INT 14
51310: PUSH
51311: EMPTY
51312: LIST
51313: LIST
51314: ST_TO_ADDR
51315: GO 51764
51317: LD_INT 27
51319: DOUBLE
51320: EQUAL
51321: IFTRUE 51325
51323: GO 51343
51325: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
51326: LD_ADDR_VAR 0 3
51330: PUSH
51331: LD_INT 13
51333: PUSH
51334: LD_INT 14
51336: PUSH
51337: EMPTY
51338: LIST
51339: LIST
51340: ST_TO_ADDR
51341: GO 51764
51343: LD_INT 28
51345: DOUBLE
51346: EQUAL
51347: IFTRUE 51351
51349: GO 51369
51351: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
51352: LD_ADDR_VAR 0 3
51356: PUSH
51357: LD_INT 13
51359: PUSH
51360: LD_INT 14
51362: PUSH
51363: EMPTY
51364: LIST
51365: LIST
51366: ST_TO_ADDR
51367: GO 51764
51369: LD_INT 29
51371: DOUBLE
51372: EQUAL
51373: IFTRUE 51377
51375: GO 51395
51377: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
51378: LD_ADDR_VAR 0 3
51382: PUSH
51383: LD_INT 13
51385: PUSH
51386: LD_INT 14
51388: PUSH
51389: EMPTY
51390: LIST
51391: LIST
51392: ST_TO_ADDR
51393: GO 51764
51395: LD_INT 31
51397: DOUBLE
51398: EQUAL
51399: IFTRUE 51403
51401: GO 51421
51403: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
51404: LD_ADDR_VAR 0 3
51408: PUSH
51409: LD_INT 13
51411: PUSH
51412: LD_INT 14
51414: PUSH
51415: EMPTY
51416: LIST
51417: LIST
51418: ST_TO_ADDR
51419: GO 51764
51421: LD_INT 26
51423: DOUBLE
51424: EQUAL
51425: IFTRUE 51429
51427: GO 51447
51429: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
51430: LD_ADDR_VAR 0 3
51434: PUSH
51435: LD_INT 13
51437: PUSH
51438: LD_INT 14
51440: PUSH
51441: EMPTY
51442: LIST
51443: LIST
51444: ST_TO_ADDR
51445: GO 51764
51447: LD_INT 42
51449: DOUBLE
51450: EQUAL
51451: IFTRUE 51455
51453: GO 51481
51455: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
51456: LD_ADDR_VAR 0 3
51460: PUSH
51461: LD_INT 21
51463: PUSH
51464: LD_INT 22
51466: PUSH
51467: LD_INT 23
51469: PUSH
51470: LD_INT 24
51472: PUSH
51473: EMPTY
51474: LIST
51475: LIST
51476: LIST
51477: LIST
51478: ST_TO_ADDR
51479: GO 51764
51481: LD_INT 43
51483: DOUBLE
51484: EQUAL
51485: IFTRUE 51489
51487: GO 51515
51489: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
51490: LD_ADDR_VAR 0 3
51494: PUSH
51495: LD_INT 21
51497: PUSH
51498: LD_INT 22
51500: PUSH
51501: LD_INT 23
51503: PUSH
51504: LD_INT 24
51506: PUSH
51507: EMPTY
51508: LIST
51509: LIST
51510: LIST
51511: LIST
51512: ST_TO_ADDR
51513: GO 51764
51515: LD_INT 44
51517: DOUBLE
51518: EQUAL
51519: IFTRUE 51523
51521: GO 51549
51523: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
51524: LD_ADDR_VAR 0 3
51528: PUSH
51529: LD_INT 21
51531: PUSH
51532: LD_INT 22
51534: PUSH
51535: LD_INT 23
51537: PUSH
51538: LD_INT 24
51540: PUSH
51541: EMPTY
51542: LIST
51543: LIST
51544: LIST
51545: LIST
51546: ST_TO_ADDR
51547: GO 51764
51549: LD_INT 45
51551: DOUBLE
51552: EQUAL
51553: IFTRUE 51557
51555: GO 51583
51557: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
51558: LD_ADDR_VAR 0 3
51562: PUSH
51563: LD_INT 21
51565: PUSH
51566: LD_INT 22
51568: PUSH
51569: LD_INT 23
51571: PUSH
51572: LD_INT 24
51574: PUSH
51575: EMPTY
51576: LIST
51577: LIST
51578: LIST
51579: LIST
51580: ST_TO_ADDR
51581: GO 51764
51583: LD_INT 49
51585: DOUBLE
51586: EQUAL
51587: IFTRUE 51591
51589: GO 51617
51591: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
51592: LD_ADDR_VAR 0 3
51596: PUSH
51597: LD_INT 21
51599: PUSH
51600: LD_INT 22
51602: PUSH
51603: LD_INT 23
51605: PUSH
51606: LD_INT 24
51608: PUSH
51609: EMPTY
51610: LIST
51611: LIST
51612: LIST
51613: LIST
51614: ST_TO_ADDR
51615: GO 51764
51617: LD_INT 51
51619: DOUBLE
51620: EQUAL
51621: IFTRUE 51625
51623: GO 51651
51625: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
51626: LD_ADDR_VAR 0 3
51630: PUSH
51631: LD_INT 21
51633: PUSH
51634: LD_INT 22
51636: PUSH
51637: LD_INT 23
51639: PUSH
51640: LD_INT 24
51642: PUSH
51643: EMPTY
51644: LIST
51645: LIST
51646: LIST
51647: LIST
51648: ST_TO_ADDR
51649: GO 51764
51651: LD_INT 52
51653: DOUBLE
51654: EQUAL
51655: IFTRUE 51659
51657: GO 51685
51659: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
51660: LD_ADDR_VAR 0 3
51664: PUSH
51665: LD_INT 21
51667: PUSH
51668: LD_INT 22
51670: PUSH
51671: LD_INT 23
51673: PUSH
51674: LD_INT 24
51676: PUSH
51677: EMPTY
51678: LIST
51679: LIST
51680: LIST
51681: LIST
51682: ST_TO_ADDR
51683: GO 51764
51685: LD_INT 53
51687: DOUBLE
51688: EQUAL
51689: IFTRUE 51693
51691: GO 51711
51693: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
51694: LD_ADDR_VAR 0 3
51698: PUSH
51699: LD_INT 23
51701: PUSH
51702: LD_INT 24
51704: PUSH
51705: EMPTY
51706: LIST
51707: LIST
51708: ST_TO_ADDR
51709: GO 51764
51711: LD_INT 46
51713: DOUBLE
51714: EQUAL
51715: IFTRUE 51719
51717: GO 51737
51719: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
51720: LD_ADDR_VAR 0 3
51724: PUSH
51725: LD_INT 23
51727: PUSH
51728: LD_INT 24
51730: PUSH
51731: EMPTY
51732: LIST
51733: LIST
51734: ST_TO_ADDR
51735: GO 51764
51737: LD_INT 47
51739: DOUBLE
51740: EQUAL
51741: IFTRUE 51745
51743: GO 51763
51745: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51746: LD_ADDR_VAR 0 3
51750: PUSH
51751: LD_INT 23
51753: PUSH
51754: LD_INT 24
51756: PUSH
51757: EMPTY
51758: LIST
51759: LIST
51760: ST_TO_ADDR
51761: GO 51764
51763: POP
// result := ( chassis in result ) ;
51764: LD_ADDR_VAR 0 3
51768: PUSH
51769: LD_VAR 0 1
51773: PUSH
51774: LD_VAR 0 3
51778: IN
51779: ST_TO_ADDR
// end ;
51780: LD_VAR 0 3
51784: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
51785: LD_INT 0
51787: PPUSH
51788: PPUSH
51789: PPUSH
51790: PPUSH
51791: PPUSH
51792: PPUSH
51793: PPUSH
// result := array ;
51794: LD_ADDR_VAR 0 5
51798: PUSH
51799: LD_VAR 0 1
51803: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
51804: LD_VAR 0 1
51808: NOT
51809: PUSH
51810: LD_VAR 0 2
51814: NOT
51815: OR
51816: PUSH
51817: LD_VAR 0 3
51821: NOT
51822: OR
51823: PUSH
51824: LD_VAR 0 2
51828: PUSH
51829: LD_VAR 0 1
51833: GREATER
51834: OR
51835: PUSH
51836: LD_VAR 0 3
51840: PUSH
51841: LD_VAR 0 1
51845: GREATER
51846: OR
51847: IFFALSE 51851
// exit ;
51849: GO 52147
// if direction then
51851: LD_VAR 0 4
51855: IFFALSE 51919
// begin d := 1 ;
51857: LD_ADDR_VAR 0 9
51861: PUSH
51862: LD_INT 1
51864: ST_TO_ADDR
// if i_from > i_to then
51865: LD_VAR 0 2
51869: PUSH
51870: LD_VAR 0 3
51874: GREATER
51875: IFFALSE 51901
// length := ( array - i_from ) + i_to else
51877: LD_ADDR_VAR 0 11
51881: PUSH
51882: LD_VAR 0 1
51886: PUSH
51887: LD_VAR 0 2
51891: MINUS
51892: PUSH
51893: LD_VAR 0 3
51897: PLUS
51898: ST_TO_ADDR
51899: GO 51917
// length := i_to - i_from ;
51901: LD_ADDR_VAR 0 11
51905: PUSH
51906: LD_VAR 0 3
51910: PUSH
51911: LD_VAR 0 2
51915: MINUS
51916: ST_TO_ADDR
// end else
51917: GO 51980
// begin d := - 1 ;
51919: LD_ADDR_VAR 0 9
51923: PUSH
51924: LD_INT 1
51926: NEG
51927: ST_TO_ADDR
// if i_from > i_to then
51928: LD_VAR 0 2
51932: PUSH
51933: LD_VAR 0 3
51937: GREATER
51938: IFFALSE 51958
// length := i_from - i_to else
51940: LD_ADDR_VAR 0 11
51944: PUSH
51945: LD_VAR 0 2
51949: PUSH
51950: LD_VAR 0 3
51954: MINUS
51955: ST_TO_ADDR
51956: GO 51980
// length := ( array - i_to ) + i_from ;
51958: LD_ADDR_VAR 0 11
51962: PUSH
51963: LD_VAR 0 1
51967: PUSH
51968: LD_VAR 0 3
51972: MINUS
51973: PUSH
51974: LD_VAR 0 2
51978: PLUS
51979: ST_TO_ADDR
// end ; if not length then
51980: LD_VAR 0 11
51984: NOT
51985: IFFALSE 51989
// exit ;
51987: GO 52147
// tmp := array ;
51989: LD_ADDR_VAR 0 10
51993: PUSH
51994: LD_VAR 0 1
51998: ST_TO_ADDR
// for i = 1 to length do
51999: LD_ADDR_VAR 0 6
52003: PUSH
52004: DOUBLE
52005: LD_INT 1
52007: DEC
52008: ST_TO_ADDR
52009: LD_VAR 0 11
52013: PUSH
52014: FOR_TO
52015: IFFALSE 52135
// begin for j = 1 to array do
52017: LD_ADDR_VAR 0 7
52021: PUSH
52022: DOUBLE
52023: LD_INT 1
52025: DEC
52026: ST_TO_ADDR
52027: LD_VAR 0 1
52031: PUSH
52032: FOR_TO
52033: IFFALSE 52121
// begin k := j + d ;
52035: LD_ADDR_VAR 0 8
52039: PUSH
52040: LD_VAR 0 7
52044: PUSH
52045: LD_VAR 0 9
52049: PLUS
52050: ST_TO_ADDR
// if k > array then
52051: LD_VAR 0 8
52055: PUSH
52056: LD_VAR 0 1
52060: GREATER
52061: IFFALSE 52071
// k := 1 ;
52063: LD_ADDR_VAR 0 8
52067: PUSH
52068: LD_INT 1
52070: ST_TO_ADDR
// if not k then
52071: LD_VAR 0 8
52075: NOT
52076: IFFALSE 52088
// k := array ;
52078: LD_ADDR_VAR 0 8
52082: PUSH
52083: LD_VAR 0 1
52087: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
52088: LD_ADDR_VAR 0 10
52092: PUSH
52093: LD_VAR 0 10
52097: PPUSH
52098: LD_VAR 0 8
52102: PPUSH
52103: LD_VAR 0 1
52107: PUSH
52108: LD_VAR 0 7
52112: ARRAY
52113: PPUSH
52114: CALL_OW 1
52118: ST_TO_ADDR
// end ;
52119: GO 52032
52121: POP
52122: POP
// array := tmp ;
52123: LD_ADDR_VAR 0 1
52127: PUSH
52128: LD_VAR 0 10
52132: ST_TO_ADDR
// end ;
52133: GO 52014
52135: POP
52136: POP
// result := array ;
52137: LD_ADDR_VAR 0 5
52141: PUSH
52142: LD_VAR 0 1
52146: ST_TO_ADDR
// end ;
52147: LD_VAR 0 5
52151: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
52152: LD_INT 0
52154: PPUSH
52155: PPUSH
// result := 0 ;
52156: LD_ADDR_VAR 0 3
52160: PUSH
52161: LD_INT 0
52163: ST_TO_ADDR
// if not array or not value in array then
52164: LD_VAR 0 1
52168: NOT
52169: PUSH
52170: LD_VAR 0 2
52174: PUSH
52175: LD_VAR 0 1
52179: IN
52180: NOT
52181: OR
52182: IFFALSE 52186
// exit ;
52184: GO 52240
// for i = 1 to array do
52186: LD_ADDR_VAR 0 4
52190: PUSH
52191: DOUBLE
52192: LD_INT 1
52194: DEC
52195: ST_TO_ADDR
52196: LD_VAR 0 1
52200: PUSH
52201: FOR_TO
52202: IFFALSE 52238
// if value = array [ i ] then
52204: LD_VAR 0 2
52208: PUSH
52209: LD_VAR 0 1
52213: PUSH
52214: LD_VAR 0 4
52218: ARRAY
52219: EQUAL
52220: IFFALSE 52236
// begin result := i ;
52222: LD_ADDR_VAR 0 3
52226: PUSH
52227: LD_VAR 0 4
52231: ST_TO_ADDR
// exit ;
52232: POP
52233: POP
52234: GO 52240
// end ;
52236: GO 52201
52238: POP
52239: POP
// end ;
52240: LD_VAR 0 3
52244: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
52245: LD_INT 0
52247: PPUSH
// vc_chassis := chassis ;
52248: LD_ADDR_OWVAR 37
52252: PUSH
52253: LD_VAR 0 1
52257: ST_TO_ADDR
// vc_engine := engine ;
52258: LD_ADDR_OWVAR 39
52262: PUSH
52263: LD_VAR 0 2
52267: ST_TO_ADDR
// vc_control := control ;
52268: LD_ADDR_OWVAR 38
52272: PUSH
52273: LD_VAR 0 3
52277: ST_TO_ADDR
// vc_weapon := weapon ;
52278: LD_ADDR_OWVAR 40
52282: PUSH
52283: LD_VAR 0 4
52287: ST_TO_ADDR
// vc_fuel_battery := fuel ;
52288: LD_ADDR_OWVAR 41
52292: PUSH
52293: LD_VAR 0 5
52297: ST_TO_ADDR
// end ;
52298: LD_VAR 0 6
52302: RET
// export function WantPlant ( unit ) ; var task ; begin
52303: LD_INT 0
52305: PPUSH
52306: PPUSH
// result := false ;
52307: LD_ADDR_VAR 0 2
52311: PUSH
52312: LD_INT 0
52314: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
52315: LD_ADDR_VAR 0 3
52319: PUSH
52320: LD_VAR 0 1
52324: PPUSH
52325: CALL_OW 437
52329: ST_TO_ADDR
// if task then
52330: LD_VAR 0 3
52334: IFFALSE 52362
// if task [ 1 ] [ 1 ] = p then
52336: LD_VAR 0 3
52340: PUSH
52341: LD_INT 1
52343: ARRAY
52344: PUSH
52345: LD_INT 1
52347: ARRAY
52348: PUSH
52349: LD_STRING p
52351: EQUAL
52352: IFFALSE 52362
// result := true ;
52354: LD_ADDR_VAR 0 2
52358: PUSH
52359: LD_INT 1
52361: ST_TO_ADDR
// end ;
52362: LD_VAR 0 2
52366: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
52367: LD_INT 0
52369: PPUSH
52370: PPUSH
52371: PPUSH
52372: PPUSH
// if pos < 1 then
52373: LD_VAR 0 2
52377: PUSH
52378: LD_INT 1
52380: LESS
52381: IFFALSE 52385
// exit ;
52383: GO 52688
// if pos = 1 then
52385: LD_VAR 0 2
52389: PUSH
52390: LD_INT 1
52392: EQUAL
52393: IFFALSE 52426
// result := Replace ( arr , pos [ 1 ] , value ) else
52395: LD_ADDR_VAR 0 4
52399: PUSH
52400: LD_VAR 0 1
52404: PPUSH
52405: LD_VAR 0 2
52409: PUSH
52410: LD_INT 1
52412: ARRAY
52413: PPUSH
52414: LD_VAR 0 3
52418: PPUSH
52419: CALL_OW 1
52423: ST_TO_ADDR
52424: GO 52688
// begin tmp := arr ;
52426: LD_ADDR_VAR 0 6
52430: PUSH
52431: LD_VAR 0 1
52435: ST_TO_ADDR
// s_arr := [ tmp ] ;
52436: LD_ADDR_VAR 0 7
52440: PUSH
52441: LD_VAR 0 6
52445: PUSH
52446: EMPTY
52447: LIST
52448: ST_TO_ADDR
// for i = 1 to pos - 1 do
52449: LD_ADDR_VAR 0 5
52453: PUSH
52454: DOUBLE
52455: LD_INT 1
52457: DEC
52458: ST_TO_ADDR
52459: LD_VAR 0 2
52463: PUSH
52464: LD_INT 1
52466: MINUS
52467: PUSH
52468: FOR_TO
52469: IFFALSE 52514
// begin tmp := tmp [ pos [ i ] ] ;
52471: LD_ADDR_VAR 0 6
52475: PUSH
52476: LD_VAR 0 6
52480: PUSH
52481: LD_VAR 0 2
52485: PUSH
52486: LD_VAR 0 5
52490: ARRAY
52491: ARRAY
52492: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
52493: LD_ADDR_VAR 0 7
52497: PUSH
52498: LD_VAR 0 7
52502: PUSH
52503: LD_VAR 0 6
52507: PUSH
52508: EMPTY
52509: LIST
52510: ADD
52511: ST_TO_ADDR
// end ;
52512: GO 52468
52514: POP
52515: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
52516: LD_ADDR_VAR 0 6
52520: PUSH
52521: LD_VAR 0 6
52525: PPUSH
52526: LD_VAR 0 2
52530: PUSH
52531: LD_VAR 0 2
52535: ARRAY
52536: PPUSH
52537: LD_VAR 0 3
52541: PPUSH
52542: CALL_OW 1
52546: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
52547: LD_ADDR_VAR 0 7
52551: PUSH
52552: LD_VAR 0 7
52556: PPUSH
52557: LD_VAR 0 7
52561: PPUSH
52562: LD_VAR 0 6
52566: PPUSH
52567: CALL_OW 1
52571: ST_TO_ADDR
// for i = s_arr downto 2 do
52572: LD_ADDR_VAR 0 5
52576: PUSH
52577: DOUBLE
52578: LD_VAR 0 7
52582: INC
52583: ST_TO_ADDR
52584: LD_INT 2
52586: PUSH
52587: FOR_DOWNTO
52588: IFFALSE 52672
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
52590: LD_ADDR_VAR 0 6
52594: PUSH
52595: LD_VAR 0 7
52599: PUSH
52600: LD_VAR 0 5
52604: PUSH
52605: LD_INT 1
52607: MINUS
52608: ARRAY
52609: PPUSH
52610: LD_VAR 0 2
52614: PUSH
52615: LD_VAR 0 5
52619: PUSH
52620: LD_INT 1
52622: MINUS
52623: ARRAY
52624: PPUSH
52625: LD_VAR 0 7
52629: PUSH
52630: LD_VAR 0 5
52634: ARRAY
52635: PPUSH
52636: CALL_OW 1
52640: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
52641: LD_ADDR_VAR 0 7
52645: PUSH
52646: LD_VAR 0 7
52650: PPUSH
52651: LD_VAR 0 5
52655: PUSH
52656: LD_INT 1
52658: MINUS
52659: PPUSH
52660: LD_VAR 0 6
52664: PPUSH
52665: CALL_OW 1
52669: ST_TO_ADDR
// end ;
52670: GO 52587
52672: POP
52673: POP
// result := s_arr [ 1 ] ;
52674: LD_ADDR_VAR 0 4
52678: PUSH
52679: LD_VAR 0 7
52683: PUSH
52684: LD_INT 1
52686: ARRAY
52687: ST_TO_ADDR
// end ; end ;
52688: LD_VAR 0 4
52692: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
52693: LD_INT 0
52695: PPUSH
52696: PPUSH
// if not list then
52697: LD_VAR 0 1
52701: NOT
52702: IFFALSE 52706
// exit ;
52704: GO 52797
// i := list [ pos1 ] ;
52706: LD_ADDR_VAR 0 5
52710: PUSH
52711: LD_VAR 0 1
52715: PUSH
52716: LD_VAR 0 2
52720: ARRAY
52721: ST_TO_ADDR
// if not i then
52722: LD_VAR 0 5
52726: NOT
52727: IFFALSE 52731
// exit ;
52729: GO 52797
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
52731: LD_ADDR_VAR 0 1
52735: PUSH
52736: LD_VAR 0 1
52740: PPUSH
52741: LD_VAR 0 2
52745: PPUSH
52746: LD_VAR 0 1
52750: PUSH
52751: LD_VAR 0 3
52755: ARRAY
52756: PPUSH
52757: CALL_OW 1
52761: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
52762: LD_ADDR_VAR 0 1
52766: PUSH
52767: LD_VAR 0 1
52771: PPUSH
52772: LD_VAR 0 3
52776: PPUSH
52777: LD_VAR 0 5
52781: PPUSH
52782: CALL_OW 1
52786: ST_TO_ADDR
// result := list ;
52787: LD_ADDR_VAR 0 4
52791: PUSH
52792: LD_VAR 0 1
52796: ST_TO_ADDR
// end ;
52797: LD_VAR 0 4
52801: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
52802: LD_INT 0
52804: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
52805: LD_ADDR_VAR 0 5
52809: PUSH
52810: LD_VAR 0 1
52814: PPUSH
52815: CALL_OW 250
52819: PPUSH
52820: LD_VAR 0 1
52824: PPUSH
52825: CALL_OW 251
52829: PPUSH
52830: LD_VAR 0 2
52834: PPUSH
52835: LD_VAR 0 3
52839: PPUSH
52840: LD_VAR 0 4
52844: PPUSH
52845: CALL 52855 0 5
52849: ST_TO_ADDR
// end ;
52850: LD_VAR 0 5
52854: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
52855: LD_INT 0
52857: PPUSH
52858: PPUSH
52859: PPUSH
52860: PPUSH
// if not list then
52861: LD_VAR 0 3
52865: NOT
52866: IFFALSE 52870
// exit ;
52868: GO 53258
// result := [ ] ;
52870: LD_ADDR_VAR 0 6
52874: PUSH
52875: EMPTY
52876: ST_TO_ADDR
// for i in list do
52877: LD_ADDR_VAR 0 7
52881: PUSH
52882: LD_VAR 0 3
52886: PUSH
52887: FOR_IN
52888: IFFALSE 53090
// begin tmp := GetDistUnitXY ( i , x , y ) ;
52890: LD_ADDR_VAR 0 9
52894: PUSH
52895: LD_VAR 0 7
52899: PPUSH
52900: LD_VAR 0 1
52904: PPUSH
52905: LD_VAR 0 2
52909: PPUSH
52910: CALL_OW 297
52914: ST_TO_ADDR
// if not result then
52915: LD_VAR 0 6
52919: NOT
52920: IFFALSE 52946
// result := [ [ i , tmp ] ] else
52922: LD_ADDR_VAR 0 6
52926: PUSH
52927: LD_VAR 0 7
52931: PUSH
52932: LD_VAR 0 9
52936: PUSH
52937: EMPTY
52938: LIST
52939: LIST
52940: PUSH
52941: EMPTY
52942: LIST
52943: ST_TO_ADDR
52944: GO 53088
// begin if result [ result ] [ 2 ] < tmp then
52946: LD_VAR 0 6
52950: PUSH
52951: LD_VAR 0 6
52955: ARRAY
52956: PUSH
52957: LD_INT 2
52959: ARRAY
52960: PUSH
52961: LD_VAR 0 9
52965: LESS
52966: IFFALSE 53008
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
52968: LD_ADDR_VAR 0 6
52972: PUSH
52973: LD_VAR 0 6
52977: PPUSH
52978: LD_VAR 0 6
52982: PUSH
52983: LD_INT 1
52985: PLUS
52986: PPUSH
52987: LD_VAR 0 7
52991: PUSH
52992: LD_VAR 0 9
52996: PUSH
52997: EMPTY
52998: LIST
52999: LIST
53000: PPUSH
53001: CALL_OW 2
53005: ST_TO_ADDR
53006: GO 53088
// for j = 1 to result do
53008: LD_ADDR_VAR 0 8
53012: PUSH
53013: DOUBLE
53014: LD_INT 1
53016: DEC
53017: ST_TO_ADDR
53018: LD_VAR 0 6
53022: PUSH
53023: FOR_TO
53024: IFFALSE 53086
// begin if tmp < result [ j ] [ 2 ] then
53026: LD_VAR 0 9
53030: PUSH
53031: LD_VAR 0 6
53035: PUSH
53036: LD_VAR 0 8
53040: ARRAY
53041: PUSH
53042: LD_INT 2
53044: ARRAY
53045: LESS
53046: IFFALSE 53084
// begin result := Insert ( result , j , [ i , tmp ] ) ;
53048: LD_ADDR_VAR 0 6
53052: PUSH
53053: LD_VAR 0 6
53057: PPUSH
53058: LD_VAR 0 8
53062: PPUSH
53063: LD_VAR 0 7
53067: PUSH
53068: LD_VAR 0 9
53072: PUSH
53073: EMPTY
53074: LIST
53075: LIST
53076: PPUSH
53077: CALL_OW 2
53081: ST_TO_ADDR
// break ;
53082: GO 53086
// end ; end ;
53084: GO 53023
53086: POP
53087: POP
// end ; end ;
53088: GO 52887
53090: POP
53091: POP
// if result and not asc then
53092: LD_VAR 0 6
53096: PUSH
53097: LD_VAR 0 4
53101: NOT
53102: AND
53103: IFFALSE 53178
// begin tmp := result ;
53105: LD_ADDR_VAR 0 9
53109: PUSH
53110: LD_VAR 0 6
53114: ST_TO_ADDR
// for i = tmp downto 1 do
53115: LD_ADDR_VAR 0 7
53119: PUSH
53120: DOUBLE
53121: LD_VAR 0 9
53125: INC
53126: ST_TO_ADDR
53127: LD_INT 1
53129: PUSH
53130: FOR_DOWNTO
53131: IFFALSE 53176
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
53133: LD_ADDR_VAR 0 6
53137: PUSH
53138: LD_VAR 0 6
53142: PPUSH
53143: LD_VAR 0 9
53147: PUSH
53148: LD_VAR 0 7
53152: MINUS
53153: PUSH
53154: LD_INT 1
53156: PLUS
53157: PPUSH
53158: LD_VAR 0 9
53162: PUSH
53163: LD_VAR 0 7
53167: ARRAY
53168: PPUSH
53169: CALL_OW 1
53173: ST_TO_ADDR
53174: GO 53130
53176: POP
53177: POP
// end ; tmp := [ ] ;
53178: LD_ADDR_VAR 0 9
53182: PUSH
53183: EMPTY
53184: ST_TO_ADDR
// if mode then
53185: LD_VAR 0 5
53189: IFFALSE 53258
// begin for i = 1 to result do
53191: LD_ADDR_VAR 0 7
53195: PUSH
53196: DOUBLE
53197: LD_INT 1
53199: DEC
53200: ST_TO_ADDR
53201: LD_VAR 0 6
53205: PUSH
53206: FOR_TO
53207: IFFALSE 53246
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
53209: LD_ADDR_VAR 0 9
53213: PUSH
53214: LD_VAR 0 9
53218: PPUSH
53219: LD_VAR 0 7
53223: PPUSH
53224: LD_VAR 0 6
53228: PUSH
53229: LD_VAR 0 7
53233: ARRAY
53234: PUSH
53235: LD_INT 1
53237: ARRAY
53238: PPUSH
53239: CALL_OW 1
53243: ST_TO_ADDR
53244: GO 53206
53246: POP
53247: POP
// result := tmp ;
53248: LD_ADDR_VAR 0 6
53252: PUSH
53253: LD_VAR 0 9
53257: ST_TO_ADDR
// end ; end ;
53258: LD_VAR 0 6
53262: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
53263: LD_INT 0
53265: PPUSH
53266: PPUSH
53267: PPUSH
53268: PPUSH
53269: PPUSH
53270: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
53271: LD_ADDR_VAR 0 5
53275: PUSH
53276: LD_INT 0
53278: PUSH
53279: LD_INT 0
53281: PUSH
53282: LD_INT 0
53284: PUSH
53285: EMPTY
53286: PUSH
53287: EMPTY
53288: LIST
53289: LIST
53290: LIST
53291: LIST
53292: ST_TO_ADDR
// if not x or not y then
53293: LD_VAR 0 2
53297: NOT
53298: PUSH
53299: LD_VAR 0 3
53303: NOT
53304: OR
53305: IFFALSE 53309
// exit ;
53307: GO 54955
// if not range then
53309: LD_VAR 0 4
53313: NOT
53314: IFFALSE 53324
// range := 10 ;
53316: LD_ADDR_VAR 0 4
53320: PUSH
53321: LD_INT 10
53323: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53324: LD_ADDR_VAR 0 8
53328: PUSH
53329: LD_INT 81
53331: PUSH
53332: LD_VAR 0 1
53336: PUSH
53337: EMPTY
53338: LIST
53339: LIST
53340: PUSH
53341: LD_INT 92
53343: PUSH
53344: LD_VAR 0 2
53348: PUSH
53349: LD_VAR 0 3
53353: PUSH
53354: LD_VAR 0 4
53358: PUSH
53359: EMPTY
53360: LIST
53361: LIST
53362: LIST
53363: LIST
53364: PUSH
53365: LD_INT 3
53367: PUSH
53368: LD_INT 21
53370: PUSH
53371: LD_INT 3
53373: PUSH
53374: EMPTY
53375: LIST
53376: LIST
53377: PUSH
53378: EMPTY
53379: LIST
53380: LIST
53381: PUSH
53382: EMPTY
53383: LIST
53384: LIST
53385: LIST
53386: PPUSH
53387: CALL_OW 69
53391: ST_TO_ADDR
// if not tmp then
53392: LD_VAR 0 8
53396: NOT
53397: IFFALSE 53401
// exit ;
53399: GO 54955
// for i in tmp do
53401: LD_ADDR_VAR 0 6
53405: PUSH
53406: LD_VAR 0 8
53410: PUSH
53411: FOR_IN
53412: IFFALSE 54930
// begin points := [ 0 , 0 , 0 ] ;
53414: LD_ADDR_VAR 0 9
53418: PUSH
53419: LD_INT 0
53421: PUSH
53422: LD_INT 0
53424: PUSH
53425: LD_INT 0
53427: PUSH
53428: EMPTY
53429: LIST
53430: LIST
53431: LIST
53432: ST_TO_ADDR
// bpoints := 1 ;
53433: LD_ADDR_VAR 0 10
53437: PUSH
53438: LD_INT 1
53440: ST_TO_ADDR
// case GetType ( i ) of unit_human :
53441: LD_VAR 0 6
53445: PPUSH
53446: CALL_OW 247
53450: PUSH
53451: LD_INT 1
53453: DOUBLE
53454: EQUAL
53455: IFTRUE 53459
53457: GO 54037
53459: POP
// begin if GetClass ( i ) = 1 then
53460: LD_VAR 0 6
53464: PPUSH
53465: CALL_OW 257
53469: PUSH
53470: LD_INT 1
53472: EQUAL
53473: IFFALSE 53494
// points := [ 10 , 5 , 3 ] ;
53475: LD_ADDR_VAR 0 9
53479: PUSH
53480: LD_INT 10
53482: PUSH
53483: LD_INT 5
53485: PUSH
53486: LD_INT 3
53488: PUSH
53489: EMPTY
53490: LIST
53491: LIST
53492: LIST
53493: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
53494: LD_VAR 0 6
53498: PPUSH
53499: CALL_OW 257
53503: PUSH
53504: LD_INT 2
53506: PUSH
53507: LD_INT 3
53509: PUSH
53510: LD_INT 4
53512: PUSH
53513: EMPTY
53514: LIST
53515: LIST
53516: LIST
53517: IN
53518: IFFALSE 53539
// points := [ 3 , 2 , 1 ] ;
53520: LD_ADDR_VAR 0 9
53524: PUSH
53525: LD_INT 3
53527: PUSH
53528: LD_INT 2
53530: PUSH
53531: LD_INT 1
53533: PUSH
53534: EMPTY
53535: LIST
53536: LIST
53537: LIST
53538: ST_TO_ADDR
// if GetClass ( i ) = 5 then
53539: LD_VAR 0 6
53543: PPUSH
53544: CALL_OW 257
53548: PUSH
53549: LD_INT 5
53551: EQUAL
53552: IFFALSE 53573
// points := [ 130 , 5 , 2 ] ;
53554: LD_ADDR_VAR 0 9
53558: PUSH
53559: LD_INT 130
53561: PUSH
53562: LD_INT 5
53564: PUSH
53565: LD_INT 2
53567: PUSH
53568: EMPTY
53569: LIST
53570: LIST
53571: LIST
53572: ST_TO_ADDR
// if GetClass ( i ) = 8 then
53573: LD_VAR 0 6
53577: PPUSH
53578: CALL_OW 257
53582: PUSH
53583: LD_INT 8
53585: EQUAL
53586: IFFALSE 53607
// points := [ 35 , 35 , 30 ] ;
53588: LD_ADDR_VAR 0 9
53592: PUSH
53593: LD_INT 35
53595: PUSH
53596: LD_INT 35
53598: PUSH
53599: LD_INT 30
53601: PUSH
53602: EMPTY
53603: LIST
53604: LIST
53605: LIST
53606: ST_TO_ADDR
// if GetClass ( i ) = 9 then
53607: LD_VAR 0 6
53611: PPUSH
53612: CALL_OW 257
53616: PUSH
53617: LD_INT 9
53619: EQUAL
53620: IFFALSE 53641
// points := [ 20 , 55 , 40 ] ;
53622: LD_ADDR_VAR 0 9
53626: PUSH
53627: LD_INT 20
53629: PUSH
53630: LD_INT 55
53632: PUSH
53633: LD_INT 40
53635: PUSH
53636: EMPTY
53637: LIST
53638: LIST
53639: LIST
53640: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
53641: LD_VAR 0 6
53645: PPUSH
53646: CALL_OW 257
53650: PUSH
53651: LD_INT 12
53653: PUSH
53654: LD_INT 16
53656: PUSH
53657: EMPTY
53658: LIST
53659: LIST
53660: IN
53661: IFFALSE 53682
// points := [ 5 , 3 , 2 ] ;
53663: LD_ADDR_VAR 0 9
53667: PUSH
53668: LD_INT 5
53670: PUSH
53671: LD_INT 3
53673: PUSH
53674: LD_INT 2
53676: PUSH
53677: EMPTY
53678: LIST
53679: LIST
53680: LIST
53681: ST_TO_ADDR
// if GetClass ( i ) = 17 then
53682: LD_VAR 0 6
53686: PPUSH
53687: CALL_OW 257
53691: PUSH
53692: LD_INT 17
53694: EQUAL
53695: IFFALSE 53716
// points := [ 100 , 50 , 75 ] ;
53697: LD_ADDR_VAR 0 9
53701: PUSH
53702: LD_INT 100
53704: PUSH
53705: LD_INT 50
53707: PUSH
53708: LD_INT 75
53710: PUSH
53711: EMPTY
53712: LIST
53713: LIST
53714: LIST
53715: ST_TO_ADDR
// if GetClass ( i ) = 15 then
53716: LD_VAR 0 6
53720: PPUSH
53721: CALL_OW 257
53725: PUSH
53726: LD_INT 15
53728: EQUAL
53729: IFFALSE 53750
// points := [ 10 , 5 , 3 ] ;
53731: LD_ADDR_VAR 0 9
53735: PUSH
53736: LD_INT 10
53738: PUSH
53739: LD_INT 5
53741: PUSH
53742: LD_INT 3
53744: PUSH
53745: EMPTY
53746: LIST
53747: LIST
53748: LIST
53749: ST_TO_ADDR
// if GetClass ( i ) = 14 then
53750: LD_VAR 0 6
53754: PPUSH
53755: CALL_OW 257
53759: PUSH
53760: LD_INT 14
53762: EQUAL
53763: IFFALSE 53784
// points := [ 10 , 0 , 0 ] ;
53765: LD_ADDR_VAR 0 9
53769: PUSH
53770: LD_INT 10
53772: PUSH
53773: LD_INT 0
53775: PUSH
53776: LD_INT 0
53778: PUSH
53779: EMPTY
53780: LIST
53781: LIST
53782: LIST
53783: ST_TO_ADDR
// if GetClass ( i ) = 11 then
53784: LD_VAR 0 6
53788: PPUSH
53789: CALL_OW 257
53793: PUSH
53794: LD_INT 11
53796: EQUAL
53797: IFFALSE 53818
// points := [ 30 , 10 , 5 ] ;
53799: LD_ADDR_VAR 0 9
53803: PUSH
53804: LD_INT 30
53806: PUSH
53807: LD_INT 10
53809: PUSH
53810: LD_INT 5
53812: PUSH
53813: EMPTY
53814: LIST
53815: LIST
53816: LIST
53817: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
53818: LD_VAR 0 1
53822: PPUSH
53823: LD_INT 5
53825: PPUSH
53826: CALL_OW 321
53830: PUSH
53831: LD_INT 2
53833: EQUAL
53834: IFFALSE 53851
// bpoints := bpoints * 1.8 ;
53836: LD_ADDR_VAR 0 10
53840: PUSH
53841: LD_VAR 0 10
53845: PUSH
53846: LD_REAL  1.80000000000000E+0000
53849: MUL
53850: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
53851: LD_VAR 0 6
53855: PPUSH
53856: CALL_OW 257
53860: PUSH
53861: LD_INT 1
53863: PUSH
53864: LD_INT 2
53866: PUSH
53867: LD_INT 3
53869: PUSH
53870: LD_INT 4
53872: PUSH
53873: EMPTY
53874: LIST
53875: LIST
53876: LIST
53877: LIST
53878: IN
53879: PUSH
53880: LD_VAR 0 1
53884: PPUSH
53885: LD_INT 51
53887: PPUSH
53888: CALL_OW 321
53892: PUSH
53893: LD_INT 2
53895: EQUAL
53896: AND
53897: IFFALSE 53914
// bpoints := bpoints * 1.2 ;
53899: LD_ADDR_VAR 0 10
53903: PUSH
53904: LD_VAR 0 10
53908: PUSH
53909: LD_REAL  1.20000000000000E+0000
53912: MUL
53913: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
53914: LD_VAR 0 6
53918: PPUSH
53919: CALL_OW 257
53923: PUSH
53924: LD_INT 5
53926: PUSH
53927: LD_INT 7
53929: PUSH
53930: LD_INT 9
53932: PUSH
53933: EMPTY
53934: LIST
53935: LIST
53936: LIST
53937: IN
53938: PUSH
53939: LD_VAR 0 1
53943: PPUSH
53944: LD_INT 52
53946: PPUSH
53947: CALL_OW 321
53951: PUSH
53952: LD_INT 2
53954: EQUAL
53955: AND
53956: IFFALSE 53973
// bpoints := bpoints * 1.5 ;
53958: LD_ADDR_VAR 0 10
53962: PUSH
53963: LD_VAR 0 10
53967: PUSH
53968: LD_REAL  1.50000000000000E+0000
53971: MUL
53972: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
53973: LD_VAR 0 1
53977: PPUSH
53978: LD_INT 66
53980: PPUSH
53981: CALL_OW 321
53985: PUSH
53986: LD_INT 2
53988: EQUAL
53989: IFFALSE 54006
// bpoints := bpoints * 1.1 ;
53991: LD_ADDR_VAR 0 10
53995: PUSH
53996: LD_VAR 0 10
54000: PUSH
54001: LD_REAL  1.10000000000000E+0000
54004: MUL
54005: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
54006: LD_ADDR_VAR 0 10
54010: PUSH
54011: LD_VAR 0 10
54015: PUSH
54016: LD_VAR 0 6
54020: PPUSH
54021: LD_INT 1
54023: PPUSH
54024: CALL_OW 259
54028: PUSH
54029: LD_REAL  1.15000000000000E+0000
54032: MUL
54033: MUL
54034: ST_TO_ADDR
// end ; unit_vehicle :
54035: GO 54859
54037: LD_INT 2
54039: DOUBLE
54040: EQUAL
54041: IFTRUE 54045
54043: GO 54847
54045: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
54046: LD_VAR 0 6
54050: PPUSH
54051: CALL_OW 264
54055: PUSH
54056: LD_INT 2
54058: PUSH
54059: LD_INT 42
54061: PUSH
54062: LD_INT 24
54064: PUSH
54065: EMPTY
54066: LIST
54067: LIST
54068: LIST
54069: IN
54070: IFFALSE 54091
// points := [ 25 , 5 , 3 ] ;
54072: LD_ADDR_VAR 0 9
54076: PUSH
54077: LD_INT 25
54079: PUSH
54080: LD_INT 5
54082: PUSH
54083: LD_INT 3
54085: PUSH
54086: EMPTY
54087: LIST
54088: LIST
54089: LIST
54090: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
54091: LD_VAR 0 6
54095: PPUSH
54096: CALL_OW 264
54100: PUSH
54101: LD_INT 4
54103: PUSH
54104: LD_INT 43
54106: PUSH
54107: LD_INT 25
54109: PUSH
54110: EMPTY
54111: LIST
54112: LIST
54113: LIST
54114: IN
54115: IFFALSE 54136
// points := [ 40 , 15 , 5 ] ;
54117: LD_ADDR_VAR 0 9
54121: PUSH
54122: LD_INT 40
54124: PUSH
54125: LD_INT 15
54127: PUSH
54128: LD_INT 5
54130: PUSH
54131: EMPTY
54132: LIST
54133: LIST
54134: LIST
54135: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
54136: LD_VAR 0 6
54140: PPUSH
54141: CALL_OW 264
54145: PUSH
54146: LD_INT 3
54148: PUSH
54149: LD_INT 23
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: IN
54156: IFFALSE 54177
// points := [ 7 , 25 , 8 ] ;
54158: LD_ADDR_VAR 0 9
54162: PUSH
54163: LD_INT 7
54165: PUSH
54166: LD_INT 25
54168: PUSH
54169: LD_INT 8
54171: PUSH
54172: EMPTY
54173: LIST
54174: LIST
54175: LIST
54176: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
54177: LD_VAR 0 6
54181: PPUSH
54182: CALL_OW 264
54186: PUSH
54187: LD_INT 5
54189: PUSH
54190: LD_INT 27
54192: PUSH
54193: LD_INT 44
54195: PUSH
54196: EMPTY
54197: LIST
54198: LIST
54199: LIST
54200: IN
54201: IFFALSE 54222
// points := [ 14 , 50 , 16 ] ;
54203: LD_ADDR_VAR 0 9
54207: PUSH
54208: LD_INT 14
54210: PUSH
54211: LD_INT 50
54213: PUSH
54214: LD_INT 16
54216: PUSH
54217: EMPTY
54218: LIST
54219: LIST
54220: LIST
54221: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
54222: LD_VAR 0 6
54226: PPUSH
54227: CALL_OW 264
54231: PUSH
54232: LD_INT 6
54234: PUSH
54235: LD_INT 46
54237: PUSH
54238: EMPTY
54239: LIST
54240: LIST
54241: IN
54242: IFFALSE 54263
// points := [ 32 , 120 , 70 ] ;
54244: LD_ADDR_VAR 0 9
54248: PUSH
54249: LD_INT 32
54251: PUSH
54252: LD_INT 120
54254: PUSH
54255: LD_INT 70
54257: PUSH
54258: EMPTY
54259: LIST
54260: LIST
54261: LIST
54262: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
54263: LD_VAR 0 6
54267: PPUSH
54268: CALL_OW 264
54272: PUSH
54273: LD_INT 7
54275: PUSH
54276: LD_INT 28
54278: PUSH
54279: LD_INT 45
54281: PUSH
54282: EMPTY
54283: LIST
54284: LIST
54285: LIST
54286: IN
54287: IFFALSE 54308
// points := [ 35 , 20 , 45 ] ;
54289: LD_ADDR_VAR 0 9
54293: PUSH
54294: LD_INT 35
54296: PUSH
54297: LD_INT 20
54299: PUSH
54300: LD_INT 45
54302: PUSH
54303: EMPTY
54304: LIST
54305: LIST
54306: LIST
54307: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
54308: LD_VAR 0 6
54312: PPUSH
54313: CALL_OW 264
54317: PUSH
54318: LD_INT 47
54320: PUSH
54321: EMPTY
54322: LIST
54323: IN
54324: IFFALSE 54345
// points := [ 67 , 45 , 75 ] ;
54326: LD_ADDR_VAR 0 9
54330: PUSH
54331: LD_INT 67
54333: PUSH
54334: LD_INT 45
54336: PUSH
54337: LD_INT 75
54339: PUSH
54340: EMPTY
54341: LIST
54342: LIST
54343: LIST
54344: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
54345: LD_VAR 0 6
54349: PPUSH
54350: CALL_OW 264
54354: PUSH
54355: LD_INT 26
54357: PUSH
54358: EMPTY
54359: LIST
54360: IN
54361: IFFALSE 54382
// points := [ 120 , 30 , 80 ] ;
54363: LD_ADDR_VAR 0 9
54367: PUSH
54368: LD_INT 120
54370: PUSH
54371: LD_INT 30
54373: PUSH
54374: LD_INT 80
54376: PUSH
54377: EMPTY
54378: LIST
54379: LIST
54380: LIST
54381: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
54382: LD_VAR 0 6
54386: PPUSH
54387: CALL_OW 264
54391: PUSH
54392: LD_INT 22
54394: PUSH
54395: EMPTY
54396: LIST
54397: IN
54398: IFFALSE 54419
// points := [ 40 , 1 , 1 ] ;
54400: LD_ADDR_VAR 0 9
54404: PUSH
54405: LD_INT 40
54407: PUSH
54408: LD_INT 1
54410: PUSH
54411: LD_INT 1
54413: PUSH
54414: EMPTY
54415: LIST
54416: LIST
54417: LIST
54418: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
54419: LD_VAR 0 6
54423: PPUSH
54424: CALL_OW 264
54428: PUSH
54429: LD_INT 29
54431: PUSH
54432: EMPTY
54433: LIST
54434: IN
54435: IFFALSE 54456
// points := [ 70 , 200 , 400 ] ;
54437: LD_ADDR_VAR 0 9
54441: PUSH
54442: LD_INT 70
54444: PUSH
54445: LD_INT 200
54447: PUSH
54448: LD_INT 400
54450: PUSH
54451: EMPTY
54452: LIST
54453: LIST
54454: LIST
54455: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
54456: LD_VAR 0 6
54460: PPUSH
54461: CALL_OW 264
54465: PUSH
54466: LD_INT 14
54468: PUSH
54469: LD_INT 53
54471: PUSH
54472: EMPTY
54473: LIST
54474: LIST
54475: IN
54476: IFFALSE 54497
// points := [ 40 , 10 , 20 ] ;
54478: LD_ADDR_VAR 0 9
54482: PUSH
54483: LD_INT 40
54485: PUSH
54486: LD_INT 10
54488: PUSH
54489: LD_INT 20
54491: PUSH
54492: EMPTY
54493: LIST
54494: LIST
54495: LIST
54496: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
54497: LD_VAR 0 6
54501: PPUSH
54502: CALL_OW 264
54506: PUSH
54507: LD_INT 9
54509: PUSH
54510: EMPTY
54511: LIST
54512: IN
54513: IFFALSE 54534
// points := [ 5 , 70 , 20 ] ;
54515: LD_ADDR_VAR 0 9
54519: PUSH
54520: LD_INT 5
54522: PUSH
54523: LD_INT 70
54525: PUSH
54526: LD_INT 20
54528: PUSH
54529: EMPTY
54530: LIST
54531: LIST
54532: LIST
54533: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
54534: LD_VAR 0 6
54538: PPUSH
54539: CALL_OW 264
54543: PUSH
54544: LD_INT 10
54546: PUSH
54547: EMPTY
54548: LIST
54549: IN
54550: IFFALSE 54571
// points := [ 35 , 110 , 70 ] ;
54552: LD_ADDR_VAR 0 9
54556: PUSH
54557: LD_INT 35
54559: PUSH
54560: LD_INT 110
54562: PUSH
54563: LD_INT 70
54565: PUSH
54566: EMPTY
54567: LIST
54568: LIST
54569: LIST
54570: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
54571: LD_VAR 0 6
54575: PPUSH
54576: CALL_OW 265
54580: PUSH
54581: LD_INT 25
54583: EQUAL
54584: IFFALSE 54605
// points := [ 80 , 65 , 100 ] ;
54586: LD_ADDR_VAR 0 9
54590: PUSH
54591: LD_INT 80
54593: PUSH
54594: LD_INT 65
54596: PUSH
54597: LD_INT 100
54599: PUSH
54600: EMPTY
54601: LIST
54602: LIST
54603: LIST
54604: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
54605: LD_VAR 0 6
54609: PPUSH
54610: CALL_OW 263
54614: PUSH
54615: LD_INT 1
54617: EQUAL
54618: IFFALSE 54653
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
54620: LD_ADDR_VAR 0 10
54624: PUSH
54625: LD_VAR 0 10
54629: PUSH
54630: LD_VAR 0 6
54634: PPUSH
54635: CALL_OW 311
54639: PPUSH
54640: LD_INT 3
54642: PPUSH
54643: CALL_OW 259
54647: PUSH
54648: LD_INT 4
54650: MUL
54651: MUL
54652: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
54653: LD_VAR 0 6
54657: PPUSH
54658: CALL_OW 263
54662: PUSH
54663: LD_INT 2
54665: EQUAL
54666: IFFALSE 54717
// begin j := IsControledBy ( i ) ;
54668: LD_ADDR_VAR 0 7
54672: PUSH
54673: LD_VAR 0 6
54677: PPUSH
54678: CALL_OW 312
54682: ST_TO_ADDR
// if j then
54683: LD_VAR 0 7
54687: IFFALSE 54717
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
54689: LD_ADDR_VAR 0 10
54693: PUSH
54694: LD_VAR 0 10
54698: PUSH
54699: LD_VAR 0 7
54703: PPUSH
54704: LD_INT 3
54706: PPUSH
54707: CALL_OW 259
54711: PUSH
54712: LD_INT 3
54714: MUL
54715: MUL
54716: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
54717: LD_VAR 0 6
54721: PPUSH
54722: CALL_OW 264
54726: PUSH
54727: LD_INT 5
54729: PUSH
54730: LD_INT 6
54732: PUSH
54733: LD_INT 46
54735: PUSH
54736: LD_INT 44
54738: PUSH
54739: LD_INT 47
54741: PUSH
54742: LD_INT 45
54744: PUSH
54745: LD_INT 28
54747: PUSH
54748: LD_INT 7
54750: PUSH
54751: LD_INT 27
54753: PUSH
54754: LD_INT 29
54756: PUSH
54757: EMPTY
54758: LIST
54759: LIST
54760: LIST
54761: LIST
54762: LIST
54763: LIST
54764: LIST
54765: LIST
54766: LIST
54767: LIST
54768: IN
54769: PUSH
54770: LD_VAR 0 1
54774: PPUSH
54775: LD_INT 52
54777: PPUSH
54778: CALL_OW 321
54782: PUSH
54783: LD_INT 2
54785: EQUAL
54786: AND
54787: IFFALSE 54804
// bpoints := bpoints * 1.2 ;
54789: LD_ADDR_VAR 0 10
54793: PUSH
54794: LD_VAR 0 10
54798: PUSH
54799: LD_REAL  1.20000000000000E+0000
54802: MUL
54803: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
54804: LD_VAR 0 6
54808: PPUSH
54809: CALL_OW 264
54813: PUSH
54814: LD_INT 6
54816: PUSH
54817: LD_INT 46
54819: PUSH
54820: LD_INT 47
54822: PUSH
54823: EMPTY
54824: LIST
54825: LIST
54826: LIST
54827: IN
54828: IFFALSE 54845
// bpoints := bpoints * 1.2 ;
54830: LD_ADDR_VAR 0 10
54834: PUSH
54835: LD_VAR 0 10
54839: PUSH
54840: LD_REAL  1.20000000000000E+0000
54843: MUL
54844: ST_TO_ADDR
// end ; unit_building :
54845: GO 54859
54847: LD_INT 3
54849: DOUBLE
54850: EQUAL
54851: IFTRUE 54855
54853: GO 54858
54855: POP
// ; end ;
54856: GO 54859
54858: POP
// for j = 1 to 3 do
54859: LD_ADDR_VAR 0 7
54863: PUSH
54864: DOUBLE
54865: LD_INT 1
54867: DEC
54868: ST_TO_ADDR
54869: LD_INT 3
54871: PUSH
54872: FOR_TO
54873: IFFALSE 54926
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
54875: LD_ADDR_VAR 0 5
54879: PUSH
54880: LD_VAR 0 5
54884: PPUSH
54885: LD_VAR 0 7
54889: PPUSH
54890: LD_VAR 0 5
54894: PUSH
54895: LD_VAR 0 7
54899: ARRAY
54900: PUSH
54901: LD_VAR 0 9
54905: PUSH
54906: LD_VAR 0 7
54910: ARRAY
54911: PUSH
54912: LD_VAR 0 10
54916: MUL
54917: PLUS
54918: PPUSH
54919: CALL_OW 1
54923: ST_TO_ADDR
54924: GO 54872
54926: POP
54927: POP
// end ;
54928: GO 53411
54930: POP
54931: POP
// result := Replace ( result , 4 , tmp ) ;
54932: LD_ADDR_VAR 0 5
54936: PUSH
54937: LD_VAR 0 5
54941: PPUSH
54942: LD_INT 4
54944: PPUSH
54945: LD_VAR 0 8
54949: PPUSH
54950: CALL_OW 1
54954: ST_TO_ADDR
// end ;
54955: LD_VAR 0 5
54959: RET
// export function DangerAtRange ( unit , range ) ; begin
54960: LD_INT 0
54962: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
54963: LD_ADDR_VAR 0 3
54967: PUSH
54968: LD_VAR 0 1
54972: PPUSH
54973: CALL_OW 255
54977: PPUSH
54978: LD_VAR 0 1
54982: PPUSH
54983: CALL_OW 250
54987: PPUSH
54988: LD_VAR 0 1
54992: PPUSH
54993: CALL_OW 251
54997: PPUSH
54998: LD_VAR 0 2
55002: PPUSH
55003: CALL 53263 0 4
55007: ST_TO_ADDR
// end ;
55008: LD_VAR 0 3
55012: RET
// export function DangerInArea ( side , area ) ; begin
55013: LD_INT 0
55015: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
55016: LD_ADDR_VAR 0 3
55020: PUSH
55021: LD_VAR 0 2
55025: PPUSH
55026: LD_INT 81
55028: PUSH
55029: LD_VAR 0 1
55033: PUSH
55034: EMPTY
55035: LIST
55036: LIST
55037: PPUSH
55038: CALL_OW 70
55042: ST_TO_ADDR
// end ;
55043: LD_VAR 0 3
55047: RET
// export function IsExtension ( b ) ; begin
55048: LD_INT 0
55050: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
55051: LD_ADDR_VAR 0 2
55055: PUSH
55056: LD_VAR 0 1
55060: PUSH
55061: LD_INT 23
55063: PUSH
55064: LD_INT 20
55066: PUSH
55067: LD_INT 22
55069: PUSH
55070: LD_INT 17
55072: PUSH
55073: LD_INT 24
55075: PUSH
55076: LD_INT 21
55078: PUSH
55079: LD_INT 19
55081: PUSH
55082: LD_INT 16
55084: PUSH
55085: LD_INT 25
55087: PUSH
55088: LD_INT 18
55090: PUSH
55091: EMPTY
55092: LIST
55093: LIST
55094: LIST
55095: LIST
55096: LIST
55097: LIST
55098: LIST
55099: LIST
55100: LIST
55101: LIST
55102: IN
55103: ST_TO_ADDR
// end ;
55104: LD_VAR 0 2
55108: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
55109: LD_INT 0
55111: PPUSH
55112: PPUSH
55113: PPUSH
// result := [ ] ;
55114: LD_ADDR_VAR 0 3
55118: PUSH
55119: EMPTY
55120: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
55121: LD_ADDR_VAR 0 4
55125: PUSH
55126: LD_VAR 0 2
55130: PPUSH
55131: LD_INT 21
55133: PUSH
55134: LD_INT 3
55136: PUSH
55137: EMPTY
55138: LIST
55139: LIST
55140: PPUSH
55141: CALL_OW 70
55145: ST_TO_ADDR
// if not tmp then
55146: LD_VAR 0 4
55150: NOT
55151: IFFALSE 55155
// exit ;
55153: GO 55213
// for i in tmp do
55155: LD_ADDR_VAR 0 5
55159: PUSH
55160: LD_VAR 0 4
55164: PUSH
55165: FOR_IN
55166: IFFALSE 55201
// if GetBase ( i ) <> base then
55168: LD_VAR 0 5
55172: PPUSH
55173: CALL_OW 274
55177: PUSH
55178: LD_VAR 0 1
55182: NONEQUAL
55183: IFFALSE 55199
// ComLinkToBase ( base , i ) ;
55185: LD_VAR 0 1
55189: PPUSH
55190: LD_VAR 0 5
55194: PPUSH
55195: CALL_OW 169
55199: GO 55165
55201: POP
55202: POP
// result := tmp ;
55203: LD_ADDR_VAR 0 3
55207: PUSH
55208: LD_VAR 0 4
55212: ST_TO_ADDR
// end ;
55213: LD_VAR 0 3
55217: RET
// export function ComComplete ( unit , b ) ; var i ; begin
55218: LD_INT 0
55220: PPUSH
55221: PPUSH
// if BuildingStatus ( b ) = bs_build then
55222: LD_VAR 0 2
55226: PPUSH
55227: CALL_OW 461
55231: PUSH
55232: LD_INT 1
55234: EQUAL
55235: IFFALSE 55295
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
55237: LD_VAR 0 1
55241: PPUSH
55242: LD_STRING h
55244: PUSH
55245: LD_VAR 0 2
55249: PPUSH
55250: CALL_OW 250
55254: PUSH
55255: LD_VAR 0 2
55259: PPUSH
55260: CALL_OW 251
55264: PUSH
55265: LD_VAR 0 2
55269: PUSH
55270: LD_INT 0
55272: PUSH
55273: LD_INT 0
55275: PUSH
55276: LD_INT 0
55278: PUSH
55279: EMPTY
55280: LIST
55281: LIST
55282: LIST
55283: LIST
55284: LIST
55285: LIST
55286: LIST
55287: PUSH
55288: EMPTY
55289: LIST
55290: PPUSH
55291: CALL_OW 446
// end ;
55295: LD_VAR 0 3
55299: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
55300: LD_INT 0
55302: PPUSH
55303: PPUSH
55304: PPUSH
55305: PPUSH
55306: PPUSH
55307: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
55308: LD_VAR 0 1
55312: NOT
55313: PUSH
55314: LD_VAR 0 1
55318: PPUSH
55319: CALL_OW 263
55323: PUSH
55324: LD_INT 2
55326: EQUAL
55327: NOT
55328: OR
55329: IFFALSE 55333
// exit ;
55331: GO 55649
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
55333: LD_ADDR_VAR 0 6
55337: PUSH
55338: LD_INT 22
55340: PUSH
55341: LD_VAR 0 1
55345: PPUSH
55346: CALL_OW 255
55350: PUSH
55351: EMPTY
55352: LIST
55353: LIST
55354: PUSH
55355: LD_INT 2
55357: PUSH
55358: LD_INT 30
55360: PUSH
55361: LD_INT 36
55363: PUSH
55364: EMPTY
55365: LIST
55366: LIST
55367: PUSH
55368: LD_INT 34
55370: PUSH
55371: LD_INT 31
55373: PUSH
55374: EMPTY
55375: LIST
55376: LIST
55377: PUSH
55378: EMPTY
55379: LIST
55380: LIST
55381: LIST
55382: PUSH
55383: EMPTY
55384: LIST
55385: LIST
55386: PPUSH
55387: CALL_OW 69
55391: ST_TO_ADDR
// if not tmp then
55392: LD_VAR 0 6
55396: NOT
55397: IFFALSE 55401
// exit ;
55399: GO 55649
// result := [ ] ;
55401: LD_ADDR_VAR 0 2
55405: PUSH
55406: EMPTY
55407: ST_TO_ADDR
// for i in tmp do
55408: LD_ADDR_VAR 0 3
55412: PUSH
55413: LD_VAR 0 6
55417: PUSH
55418: FOR_IN
55419: IFFALSE 55490
// begin t := UnitsInside ( i ) ;
55421: LD_ADDR_VAR 0 4
55425: PUSH
55426: LD_VAR 0 3
55430: PPUSH
55431: CALL_OW 313
55435: ST_TO_ADDR
// if t then
55436: LD_VAR 0 4
55440: IFFALSE 55488
// for j in t do
55442: LD_ADDR_VAR 0 7
55446: PUSH
55447: LD_VAR 0 4
55451: PUSH
55452: FOR_IN
55453: IFFALSE 55486
// result := Insert ( result , result + 1 , j ) ;
55455: LD_ADDR_VAR 0 2
55459: PUSH
55460: LD_VAR 0 2
55464: PPUSH
55465: LD_VAR 0 2
55469: PUSH
55470: LD_INT 1
55472: PLUS
55473: PPUSH
55474: LD_VAR 0 7
55478: PPUSH
55479: CALL_OW 2
55483: ST_TO_ADDR
55484: GO 55452
55486: POP
55487: POP
// end ;
55488: GO 55418
55490: POP
55491: POP
// if not result then
55492: LD_VAR 0 2
55496: NOT
55497: IFFALSE 55501
// exit ;
55499: GO 55649
// mech := result [ 1 ] ;
55501: LD_ADDR_VAR 0 5
55505: PUSH
55506: LD_VAR 0 2
55510: PUSH
55511: LD_INT 1
55513: ARRAY
55514: ST_TO_ADDR
// if result > 1 then
55515: LD_VAR 0 2
55519: PUSH
55520: LD_INT 1
55522: GREATER
55523: IFFALSE 55635
// for i = 2 to result do
55525: LD_ADDR_VAR 0 3
55529: PUSH
55530: DOUBLE
55531: LD_INT 2
55533: DEC
55534: ST_TO_ADDR
55535: LD_VAR 0 2
55539: PUSH
55540: FOR_TO
55541: IFFALSE 55633
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
55543: LD_ADDR_VAR 0 4
55547: PUSH
55548: LD_VAR 0 2
55552: PUSH
55553: LD_VAR 0 3
55557: ARRAY
55558: PPUSH
55559: LD_INT 3
55561: PPUSH
55562: CALL_OW 259
55566: PUSH
55567: LD_VAR 0 2
55571: PUSH
55572: LD_VAR 0 3
55576: ARRAY
55577: PPUSH
55578: CALL_OW 432
55582: MINUS
55583: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
55584: LD_VAR 0 4
55588: PUSH
55589: LD_VAR 0 5
55593: PPUSH
55594: LD_INT 3
55596: PPUSH
55597: CALL_OW 259
55601: PUSH
55602: LD_VAR 0 5
55606: PPUSH
55607: CALL_OW 432
55611: MINUS
55612: GREATEREQUAL
55613: IFFALSE 55631
// mech := result [ i ] ;
55615: LD_ADDR_VAR 0 5
55619: PUSH
55620: LD_VAR 0 2
55624: PUSH
55625: LD_VAR 0 3
55629: ARRAY
55630: ST_TO_ADDR
// end ;
55631: GO 55540
55633: POP
55634: POP
// ComLinkTo ( vehicle , mech ) ;
55635: LD_VAR 0 1
55639: PPUSH
55640: LD_VAR 0 5
55644: PPUSH
55645: CALL_OW 135
// end ;
55649: LD_VAR 0 2
55653: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
55654: LD_INT 0
55656: PPUSH
55657: PPUSH
55658: PPUSH
55659: PPUSH
55660: PPUSH
55661: PPUSH
55662: PPUSH
55663: PPUSH
55664: PPUSH
55665: PPUSH
55666: PPUSH
55667: PPUSH
55668: PPUSH
// result := [ ] ;
55669: LD_ADDR_VAR 0 7
55673: PUSH
55674: EMPTY
55675: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
55676: LD_VAR 0 1
55680: PPUSH
55681: CALL_OW 266
55685: PUSH
55686: LD_INT 0
55688: PUSH
55689: LD_INT 1
55691: PUSH
55692: EMPTY
55693: LIST
55694: LIST
55695: IN
55696: NOT
55697: IFFALSE 55701
// exit ;
55699: GO 57332
// if name then
55701: LD_VAR 0 3
55705: IFFALSE 55721
// SetBName ( base_dep , name ) ;
55707: LD_VAR 0 1
55711: PPUSH
55712: LD_VAR 0 3
55716: PPUSH
55717: CALL_OW 500
// base := GetBase ( base_dep ) ;
55721: LD_ADDR_VAR 0 15
55725: PUSH
55726: LD_VAR 0 1
55730: PPUSH
55731: CALL_OW 274
55735: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
55736: LD_ADDR_VAR 0 16
55740: PUSH
55741: LD_VAR 0 1
55745: PPUSH
55746: CALL_OW 255
55750: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
55751: LD_ADDR_VAR 0 17
55755: PUSH
55756: LD_VAR 0 1
55760: PPUSH
55761: CALL_OW 248
55765: ST_TO_ADDR
// if sources then
55766: LD_VAR 0 5
55770: IFFALSE 55817
// for i = 1 to 3 do
55772: LD_ADDR_VAR 0 8
55776: PUSH
55777: DOUBLE
55778: LD_INT 1
55780: DEC
55781: ST_TO_ADDR
55782: LD_INT 3
55784: PUSH
55785: FOR_TO
55786: IFFALSE 55815
// AddResourceType ( base , i , sources [ i ] ) ;
55788: LD_VAR 0 15
55792: PPUSH
55793: LD_VAR 0 8
55797: PPUSH
55798: LD_VAR 0 5
55802: PUSH
55803: LD_VAR 0 8
55807: ARRAY
55808: PPUSH
55809: CALL_OW 276
55813: GO 55785
55815: POP
55816: POP
// buildings := GetBaseBuildings ( base , area ) ;
55817: LD_ADDR_VAR 0 18
55821: PUSH
55822: LD_VAR 0 15
55826: PPUSH
55827: LD_VAR 0 2
55831: PPUSH
55832: CALL 55109 0 2
55836: ST_TO_ADDR
// InitHc ;
55837: CALL_OW 19
// InitUc ;
55841: CALL_OW 18
// uc_side := side ;
55845: LD_ADDR_OWVAR 20
55849: PUSH
55850: LD_VAR 0 16
55854: ST_TO_ADDR
// uc_nation := nation ;
55855: LD_ADDR_OWVAR 21
55859: PUSH
55860: LD_VAR 0 17
55864: ST_TO_ADDR
// if buildings then
55865: LD_VAR 0 18
55869: IFFALSE 57191
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
55871: LD_ADDR_VAR 0 19
55875: PUSH
55876: LD_VAR 0 18
55880: PPUSH
55881: LD_INT 2
55883: PUSH
55884: LD_INT 30
55886: PUSH
55887: LD_INT 29
55889: PUSH
55890: EMPTY
55891: LIST
55892: LIST
55893: PUSH
55894: LD_INT 30
55896: PUSH
55897: LD_INT 30
55899: PUSH
55900: EMPTY
55901: LIST
55902: LIST
55903: PUSH
55904: EMPTY
55905: LIST
55906: LIST
55907: LIST
55908: PPUSH
55909: CALL_OW 72
55913: ST_TO_ADDR
// if tmp then
55914: LD_VAR 0 19
55918: IFFALSE 55966
// for i in tmp do
55920: LD_ADDR_VAR 0 8
55924: PUSH
55925: LD_VAR 0 19
55929: PUSH
55930: FOR_IN
55931: IFFALSE 55964
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
55933: LD_VAR 0 8
55937: PPUSH
55938: CALL_OW 250
55942: PPUSH
55943: LD_VAR 0 8
55947: PPUSH
55948: CALL_OW 251
55952: PPUSH
55953: LD_VAR 0 16
55957: PPUSH
55958: CALL_OW 441
55962: GO 55930
55964: POP
55965: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
55966: LD_VAR 0 18
55970: PPUSH
55971: LD_INT 2
55973: PUSH
55974: LD_INT 30
55976: PUSH
55977: LD_INT 32
55979: PUSH
55980: EMPTY
55981: LIST
55982: LIST
55983: PUSH
55984: LD_INT 30
55986: PUSH
55987: LD_INT 33
55989: PUSH
55990: EMPTY
55991: LIST
55992: LIST
55993: PUSH
55994: EMPTY
55995: LIST
55996: LIST
55997: LIST
55998: PPUSH
55999: CALL_OW 72
56003: IFFALSE 56091
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
56005: LD_ADDR_VAR 0 8
56009: PUSH
56010: LD_VAR 0 18
56014: PPUSH
56015: LD_INT 2
56017: PUSH
56018: LD_INT 30
56020: PUSH
56021: LD_INT 32
56023: PUSH
56024: EMPTY
56025: LIST
56026: LIST
56027: PUSH
56028: LD_INT 30
56030: PUSH
56031: LD_INT 33
56033: PUSH
56034: EMPTY
56035: LIST
56036: LIST
56037: PUSH
56038: EMPTY
56039: LIST
56040: LIST
56041: LIST
56042: PPUSH
56043: CALL_OW 72
56047: PUSH
56048: FOR_IN
56049: IFFALSE 56089
// begin if not GetBWeapon ( i ) then
56051: LD_VAR 0 8
56055: PPUSH
56056: CALL_OW 269
56060: NOT
56061: IFFALSE 56087
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
56063: LD_VAR 0 8
56067: PPUSH
56068: LD_VAR 0 8
56072: PPUSH
56073: LD_VAR 0 2
56077: PPUSH
56078: CALL 57337 0 2
56082: PPUSH
56083: CALL_OW 431
// end ;
56087: GO 56048
56089: POP
56090: POP
// end ; for i = 1 to personel do
56091: LD_ADDR_VAR 0 8
56095: PUSH
56096: DOUBLE
56097: LD_INT 1
56099: DEC
56100: ST_TO_ADDR
56101: LD_VAR 0 6
56105: PUSH
56106: FOR_TO
56107: IFFALSE 57171
// begin if i > 4 then
56109: LD_VAR 0 8
56113: PUSH
56114: LD_INT 4
56116: GREATER
56117: IFFALSE 56121
// break ;
56119: GO 57171
// case i of 1 :
56121: LD_VAR 0 8
56125: PUSH
56126: LD_INT 1
56128: DOUBLE
56129: EQUAL
56130: IFTRUE 56134
56132: GO 56214
56134: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
56135: LD_ADDR_VAR 0 12
56139: PUSH
56140: LD_VAR 0 18
56144: PPUSH
56145: LD_INT 22
56147: PUSH
56148: LD_VAR 0 16
56152: PUSH
56153: EMPTY
56154: LIST
56155: LIST
56156: PUSH
56157: LD_INT 58
56159: PUSH
56160: EMPTY
56161: LIST
56162: PUSH
56163: LD_INT 2
56165: PUSH
56166: LD_INT 30
56168: PUSH
56169: LD_INT 32
56171: PUSH
56172: EMPTY
56173: LIST
56174: LIST
56175: PUSH
56176: LD_INT 30
56178: PUSH
56179: LD_INT 4
56181: PUSH
56182: EMPTY
56183: LIST
56184: LIST
56185: PUSH
56186: LD_INT 30
56188: PUSH
56189: LD_INT 5
56191: PUSH
56192: EMPTY
56193: LIST
56194: LIST
56195: PUSH
56196: EMPTY
56197: LIST
56198: LIST
56199: LIST
56200: LIST
56201: PUSH
56202: EMPTY
56203: LIST
56204: LIST
56205: LIST
56206: PPUSH
56207: CALL_OW 72
56211: ST_TO_ADDR
56212: GO 56436
56214: LD_INT 2
56216: DOUBLE
56217: EQUAL
56218: IFTRUE 56222
56220: GO 56284
56222: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
56223: LD_ADDR_VAR 0 12
56227: PUSH
56228: LD_VAR 0 18
56232: PPUSH
56233: LD_INT 22
56235: PUSH
56236: LD_VAR 0 16
56240: PUSH
56241: EMPTY
56242: LIST
56243: LIST
56244: PUSH
56245: LD_INT 2
56247: PUSH
56248: LD_INT 30
56250: PUSH
56251: LD_INT 0
56253: PUSH
56254: EMPTY
56255: LIST
56256: LIST
56257: PUSH
56258: LD_INT 30
56260: PUSH
56261: LD_INT 1
56263: PUSH
56264: EMPTY
56265: LIST
56266: LIST
56267: PUSH
56268: EMPTY
56269: LIST
56270: LIST
56271: LIST
56272: PUSH
56273: EMPTY
56274: LIST
56275: LIST
56276: PPUSH
56277: CALL_OW 72
56281: ST_TO_ADDR
56282: GO 56436
56284: LD_INT 3
56286: DOUBLE
56287: EQUAL
56288: IFTRUE 56292
56290: GO 56354
56292: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
56293: LD_ADDR_VAR 0 12
56297: PUSH
56298: LD_VAR 0 18
56302: PPUSH
56303: LD_INT 22
56305: PUSH
56306: LD_VAR 0 16
56310: PUSH
56311: EMPTY
56312: LIST
56313: LIST
56314: PUSH
56315: LD_INT 2
56317: PUSH
56318: LD_INT 30
56320: PUSH
56321: LD_INT 2
56323: PUSH
56324: EMPTY
56325: LIST
56326: LIST
56327: PUSH
56328: LD_INT 30
56330: PUSH
56331: LD_INT 3
56333: PUSH
56334: EMPTY
56335: LIST
56336: LIST
56337: PUSH
56338: EMPTY
56339: LIST
56340: LIST
56341: LIST
56342: PUSH
56343: EMPTY
56344: LIST
56345: LIST
56346: PPUSH
56347: CALL_OW 72
56351: ST_TO_ADDR
56352: GO 56436
56354: LD_INT 4
56356: DOUBLE
56357: EQUAL
56358: IFTRUE 56362
56360: GO 56435
56362: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
56363: LD_ADDR_VAR 0 12
56367: PUSH
56368: LD_VAR 0 18
56372: PPUSH
56373: LD_INT 22
56375: PUSH
56376: LD_VAR 0 16
56380: PUSH
56381: EMPTY
56382: LIST
56383: LIST
56384: PUSH
56385: LD_INT 2
56387: PUSH
56388: LD_INT 30
56390: PUSH
56391: LD_INT 6
56393: PUSH
56394: EMPTY
56395: LIST
56396: LIST
56397: PUSH
56398: LD_INT 30
56400: PUSH
56401: LD_INT 7
56403: PUSH
56404: EMPTY
56405: LIST
56406: LIST
56407: PUSH
56408: LD_INT 30
56410: PUSH
56411: LD_INT 8
56413: PUSH
56414: EMPTY
56415: LIST
56416: LIST
56417: PUSH
56418: EMPTY
56419: LIST
56420: LIST
56421: LIST
56422: LIST
56423: PUSH
56424: EMPTY
56425: LIST
56426: LIST
56427: PPUSH
56428: CALL_OW 72
56432: ST_TO_ADDR
56433: GO 56436
56435: POP
// if i = 1 then
56436: LD_VAR 0 8
56440: PUSH
56441: LD_INT 1
56443: EQUAL
56444: IFFALSE 56555
// begin tmp := [ ] ;
56446: LD_ADDR_VAR 0 19
56450: PUSH
56451: EMPTY
56452: ST_TO_ADDR
// for j in f do
56453: LD_ADDR_VAR 0 9
56457: PUSH
56458: LD_VAR 0 12
56462: PUSH
56463: FOR_IN
56464: IFFALSE 56537
// if GetBType ( j ) = b_bunker then
56466: LD_VAR 0 9
56470: PPUSH
56471: CALL_OW 266
56475: PUSH
56476: LD_INT 32
56478: EQUAL
56479: IFFALSE 56506
// tmp := Insert ( tmp , 1 , j ) else
56481: LD_ADDR_VAR 0 19
56485: PUSH
56486: LD_VAR 0 19
56490: PPUSH
56491: LD_INT 1
56493: PPUSH
56494: LD_VAR 0 9
56498: PPUSH
56499: CALL_OW 2
56503: ST_TO_ADDR
56504: GO 56535
// tmp := Insert ( tmp , tmp + 1 , j ) ;
56506: LD_ADDR_VAR 0 19
56510: PUSH
56511: LD_VAR 0 19
56515: PPUSH
56516: LD_VAR 0 19
56520: PUSH
56521: LD_INT 1
56523: PLUS
56524: PPUSH
56525: LD_VAR 0 9
56529: PPUSH
56530: CALL_OW 2
56534: ST_TO_ADDR
56535: GO 56463
56537: POP
56538: POP
// if tmp then
56539: LD_VAR 0 19
56543: IFFALSE 56555
// f := tmp ;
56545: LD_ADDR_VAR 0 12
56549: PUSH
56550: LD_VAR 0 19
56554: ST_TO_ADDR
// end ; x := personel [ i ] ;
56555: LD_ADDR_VAR 0 13
56559: PUSH
56560: LD_VAR 0 6
56564: PUSH
56565: LD_VAR 0 8
56569: ARRAY
56570: ST_TO_ADDR
// if x = - 1 then
56571: LD_VAR 0 13
56575: PUSH
56576: LD_INT 1
56578: NEG
56579: EQUAL
56580: IFFALSE 56789
// begin for j in f do
56582: LD_ADDR_VAR 0 9
56586: PUSH
56587: LD_VAR 0 12
56591: PUSH
56592: FOR_IN
56593: IFFALSE 56785
// repeat InitHc ;
56595: CALL_OW 19
// if GetBType ( j ) = b_barracks then
56599: LD_VAR 0 9
56603: PPUSH
56604: CALL_OW 266
56608: PUSH
56609: LD_INT 5
56611: EQUAL
56612: IFFALSE 56682
// begin if UnitsInside ( j ) < 3 then
56614: LD_VAR 0 9
56618: PPUSH
56619: CALL_OW 313
56623: PUSH
56624: LD_INT 3
56626: LESS
56627: IFFALSE 56663
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
56629: LD_INT 0
56631: PPUSH
56632: LD_INT 5
56634: PUSH
56635: LD_INT 8
56637: PUSH
56638: LD_INT 9
56640: PUSH
56641: EMPTY
56642: LIST
56643: LIST
56644: LIST
56645: PUSH
56646: LD_VAR 0 17
56650: ARRAY
56651: PPUSH
56652: LD_VAR 0 4
56656: PPUSH
56657: CALL_OW 380
56661: GO 56680
// PrepareHuman ( false , i , skill ) ;
56663: LD_INT 0
56665: PPUSH
56666: LD_VAR 0 8
56670: PPUSH
56671: LD_VAR 0 4
56675: PPUSH
56676: CALL_OW 380
// end else
56680: GO 56699
// PrepareHuman ( false , i , skill ) ;
56682: LD_INT 0
56684: PPUSH
56685: LD_VAR 0 8
56689: PPUSH
56690: LD_VAR 0 4
56694: PPUSH
56695: CALL_OW 380
// un := CreateHuman ;
56699: LD_ADDR_VAR 0 14
56703: PUSH
56704: CALL_OW 44
56708: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
56709: LD_ADDR_VAR 0 7
56713: PUSH
56714: LD_VAR 0 7
56718: PPUSH
56719: LD_INT 1
56721: PPUSH
56722: LD_VAR 0 14
56726: PPUSH
56727: CALL_OW 2
56731: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
56732: LD_VAR 0 14
56736: PPUSH
56737: LD_VAR 0 9
56741: PPUSH
56742: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
56746: LD_VAR 0 9
56750: PPUSH
56751: CALL_OW 313
56755: PUSH
56756: LD_INT 6
56758: EQUAL
56759: PUSH
56760: LD_VAR 0 9
56764: PPUSH
56765: CALL_OW 266
56769: PUSH
56770: LD_INT 32
56772: PUSH
56773: LD_INT 31
56775: PUSH
56776: EMPTY
56777: LIST
56778: LIST
56779: IN
56780: OR
56781: IFFALSE 56595
56783: GO 56592
56785: POP
56786: POP
// end else
56787: GO 57169
// for j = 1 to x do
56789: LD_ADDR_VAR 0 9
56793: PUSH
56794: DOUBLE
56795: LD_INT 1
56797: DEC
56798: ST_TO_ADDR
56799: LD_VAR 0 13
56803: PUSH
56804: FOR_TO
56805: IFFALSE 57167
// begin InitHc ;
56807: CALL_OW 19
// if not f then
56811: LD_VAR 0 12
56815: NOT
56816: IFFALSE 56905
// begin PrepareHuman ( false , i , skill ) ;
56818: LD_INT 0
56820: PPUSH
56821: LD_VAR 0 8
56825: PPUSH
56826: LD_VAR 0 4
56830: PPUSH
56831: CALL_OW 380
// un := CreateHuman ;
56835: LD_ADDR_VAR 0 14
56839: PUSH
56840: CALL_OW 44
56844: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
56845: LD_ADDR_VAR 0 7
56849: PUSH
56850: LD_VAR 0 7
56854: PPUSH
56855: LD_INT 1
56857: PPUSH
56858: LD_VAR 0 14
56862: PPUSH
56863: CALL_OW 2
56867: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
56868: LD_VAR 0 14
56872: PPUSH
56873: LD_VAR 0 1
56877: PPUSH
56878: CALL_OW 250
56882: PPUSH
56883: LD_VAR 0 1
56887: PPUSH
56888: CALL_OW 251
56892: PPUSH
56893: LD_INT 10
56895: PPUSH
56896: LD_INT 0
56898: PPUSH
56899: CALL_OW 50
// continue ;
56903: GO 56804
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
56905: LD_VAR 0 12
56909: PUSH
56910: LD_INT 1
56912: ARRAY
56913: PPUSH
56914: CALL_OW 313
56918: PUSH
56919: LD_VAR 0 12
56923: PUSH
56924: LD_INT 1
56926: ARRAY
56927: PPUSH
56928: CALL_OW 266
56932: PUSH
56933: LD_INT 32
56935: PUSH
56936: LD_INT 31
56938: PUSH
56939: EMPTY
56940: LIST
56941: LIST
56942: IN
56943: AND
56944: PUSH
56945: LD_VAR 0 12
56949: PUSH
56950: LD_INT 1
56952: ARRAY
56953: PPUSH
56954: CALL_OW 313
56958: PUSH
56959: LD_INT 6
56961: EQUAL
56962: OR
56963: IFFALSE 56983
// f := Delete ( f , 1 ) ;
56965: LD_ADDR_VAR 0 12
56969: PUSH
56970: LD_VAR 0 12
56974: PPUSH
56975: LD_INT 1
56977: PPUSH
56978: CALL_OW 3
56982: ST_TO_ADDR
// if not f then
56983: LD_VAR 0 12
56987: NOT
56988: IFFALSE 57006
// begin x := x + 2 ;
56990: LD_ADDR_VAR 0 13
56994: PUSH
56995: LD_VAR 0 13
56999: PUSH
57000: LD_INT 2
57002: PLUS
57003: ST_TO_ADDR
// continue ;
57004: GO 56804
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
57006: LD_VAR 0 12
57010: PUSH
57011: LD_INT 1
57013: ARRAY
57014: PPUSH
57015: CALL_OW 266
57019: PUSH
57020: LD_INT 5
57022: EQUAL
57023: IFFALSE 57097
// begin if UnitsInside ( f [ 1 ] ) < 3 then
57025: LD_VAR 0 12
57029: PUSH
57030: LD_INT 1
57032: ARRAY
57033: PPUSH
57034: CALL_OW 313
57038: PUSH
57039: LD_INT 3
57041: LESS
57042: IFFALSE 57078
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57044: LD_INT 0
57046: PPUSH
57047: LD_INT 5
57049: PUSH
57050: LD_INT 8
57052: PUSH
57053: LD_INT 9
57055: PUSH
57056: EMPTY
57057: LIST
57058: LIST
57059: LIST
57060: PUSH
57061: LD_VAR 0 17
57065: ARRAY
57066: PPUSH
57067: LD_VAR 0 4
57071: PPUSH
57072: CALL_OW 380
57076: GO 57095
// PrepareHuman ( false , i , skill ) ;
57078: LD_INT 0
57080: PPUSH
57081: LD_VAR 0 8
57085: PPUSH
57086: LD_VAR 0 4
57090: PPUSH
57091: CALL_OW 380
// end else
57095: GO 57114
// PrepareHuman ( false , i , skill ) ;
57097: LD_INT 0
57099: PPUSH
57100: LD_VAR 0 8
57104: PPUSH
57105: LD_VAR 0 4
57109: PPUSH
57110: CALL_OW 380
// un := CreateHuman ;
57114: LD_ADDR_VAR 0 14
57118: PUSH
57119: CALL_OW 44
57123: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57124: LD_ADDR_VAR 0 7
57128: PUSH
57129: LD_VAR 0 7
57133: PPUSH
57134: LD_INT 1
57136: PPUSH
57137: LD_VAR 0 14
57141: PPUSH
57142: CALL_OW 2
57146: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
57147: LD_VAR 0 14
57151: PPUSH
57152: LD_VAR 0 12
57156: PUSH
57157: LD_INT 1
57159: ARRAY
57160: PPUSH
57161: CALL_OW 52
// end ;
57165: GO 56804
57167: POP
57168: POP
// end ;
57169: GO 56106
57171: POP
57172: POP
// result := result ^ buildings ;
57173: LD_ADDR_VAR 0 7
57177: PUSH
57178: LD_VAR 0 7
57182: PUSH
57183: LD_VAR 0 18
57187: ADD
57188: ST_TO_ADDR
// end else
57189: GO 57332
// begin for i = 1 to personel do
57191: LD_ADDR_VAR 0 8
57195: PUSH
57196: DOUBLE
57197: LD_INT 1
57199: DEC
57200: ST_TO_ADDR
57201: LD_VAR 0 6
57205: PUSH
57206: FOR_TO
57207: IFFALSE 57330
// begin if i > 4 then
57209: LD_VAR 0 8
57213: PUSH
57214: LD_INT 4
57216: GREATER
57217: IFFALSE 57221
// break ;
57219: GO 57330
// x := personel [ i ] ;
57221: LD_ADDR_VAR 0 13
57225: PUSH
57226: LD_VAR 0 6
57230: PUSH
57231: LD_VAR 0 8
57235: ARRAY
57236: ST_TO_ADDR
// if x = - 1 then
57237: LD_VAR 0 13
57241: PUSH
57242: LD_INT 1
57244: NEG
57245: EQUAL
57246: IFFALSE 57250
// continue ;
57248: GO 57206
// PrepareHuman ( false , i , skill ) ;
57250: LD_INT 0
57252: PPUSH
57253: LD_VAR 0 8
57257: PPUSH
57258: LD_VAR 0 4
57262: PPUSH
57263: CALL_OW 380
// un := CreateHuman ;
57267: LD_ADDR_VAR 0 14
57271: PUSH
57272: CALL_OW 44
57276: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57277: LD_VAR 0 14
57281: PPUSH
57282: LD_VAR 0 1
57286: PPUSH
57287: CALL_OW 250
57291: PPUSH
57292: LD_VAR 0 1
57296: PPUSH
57297: CALL_OW 251
57301: PPUSH
57302: LD_INT 10
57304: PPUSH
57305: LD_INT 0
57307: PPUSH
57308: CALL_OW 50
// result := result ^ un ;
57312: LD_ADDR_VAR 0 7
57316: PUSH
57317: LD_VAR 0 7
57321: PUSH
57322: LD_VAR 0 14
57326: ADD
57327: ST_TO_ADDR
// end ;
57328: GO 57206
57330: POP
57331: POP
// end ; end ;
57332: LD_VAR 0 7
57336: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
57337: LD_INT 0
57339: PPUSH
57340: PPUSH
57341: PPUSH
57342: PPUSH
57343: PPUSH
57344: PPUSH
57345: PPUSH
57346: PPUSH
57347: PPUSH
57348: PPUSH
57349: PPUSH
57350: PPUSH
57351: PPUSH
57352: PPUSH
57353: PPUSH
57354: PPUSH
// result := false ;
57355: LD_ADDR_VAR 0 3
57359: PUSH
57360: LD_INT 0
57362: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
57363: LD_VAR 0 1
57367: NOT
57368: PUSH
57369: LD_VAR 0 1
57373: PPUSH
57374: CALL_OW 266
57378: PUSH
57379: LD_INT 32
57381: PUSH
57382: LD_INT 33
57384: PUSH
57385: EMPTY
57386: LIST
57387: LIST
57388: IN
57389: NOT
57390: OR
57391: IFFALSE 57395
// exit ;
57393: GO 58531
// nat := GetNation ( tower ) ;
57395: LD_ADDR_VAR 0 12
57399: PUSH
57400: LD_VAR 0 1
57404: PPUSH
57405: CALL_OW 248
57409: ST_TO_ADDR
// side := GetSide ( tower ) ;
57410: LD_ADDR_VAR 0 16
57414: PUSH
57415: LD_VAR 0 1
57419: PPUSH
57420: CALL_OW 255
57424: ST_TO_ADDR
// x := GetX ( tower ) ;
57425: LD_ADDR_VAR 0 10
57429: PUSH
57430: LD_VAR 0 1
57434: PPUSH
57435: CALL_OW 250
57439: ST_TO_ADDR
// y := GetY ( tower ) ;
57440: LD_ADDR_VAR 0 11
57444: PUSH
57445: LD_VAR 0 1
57449: PPUSH
57450: CALL_OW 251
57454: ST_TO_ADDR
// if not x or not y then
57455: LD_VAR 0 10
57459: NOT
57460: PUSH
57461: LD_VAR 0 11
57465: NOT
57466: OR
57467: IFFALSE 57471
// exit ;
57469: GO 58531
// weapon := 0 ;
57471: LD_ADDR_VAR 0 18
57475: PUSH
57476: LD_INT 0
57478: ST_TO_ADDR
// fac_list := [ ] ;
57479: LD_ADDR_VAR 0 17
57483: PUSH
57484: EMPTY
57485: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
57486: LD_ADDR_VAR 0 6
57490: PUSH
57491: LD_VAR 0 1
57495: PPUSH
57496: CALL_OW 274
57500: PPUSH
57501: LD_VAR 0 2
57505: PPUSH
57506: CALL 55109 0 2
57510: PPUSH
57511: LD_INT 30
57513: PUSH
57514: LD_INT 3
57516: PUSH
57517: EMPTY
57518: LIST
57519: LIST
57520: PPUSH
57521: CALL_OW 72
57525: ST_TO_ADDR
// if not factories then
57526: LD_VAR 0 6
57530: NOT
57531: IFFALSE 57535
// exit ;
57533: GO 58531
// for i in factories do
57535: LD_ADDR_VAR 0 8
57539: PUSH
57540: LD_VAR 0 6
57544: PUSH
57545: FOR_IN
57546: IFFALSE 57571
// fac_list := fac_list union AvailableWeaponList ( i ) ;
57548: LD_ADDR_VAR 0 17
57552: PUSH
57553: LD_VAR 0 17
57557: PUSH
57558: LD_VAR 0 8
57562: PPUSH
57563: CALL_OW 478
57567: UNION
57568: ST_TO_ADDR
57569: GO 57545
57571: POP
57572: POP
// if not fac_list then
57573: LD_VAR 0 17
57577: NOT
57578: IFFALSE 57582
// exit ;
57580: GO 58531
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
57582: LD_ADDR_VAR 0 5
57586: PUSH
57587: LD_INT 4
57589: PUSH
57590: LD_INT 5
57592: PUSH
57593: LD_INT 9
57595: PUSH
57596: LD_INT 10
57598: PUSH
57599: LD_INT 6
57601: PUSH
57602: LD_INT 7
57604: PUSH
57605: LD_INT 11
57607: PUSH
57608: EMPTY
57609: LIST
57610: LIST
57611: LIST
57612: LIST
57613: LIST
57614: LIST
57615: LIST
57616: PUSH
57617: LD_INT 27
57619: PUSH
57620: LD_INT 28
57622: PUSH
57623: LD_INT 26
57625: PUSH
57626: LD_INT 30
57628: PUSH
57629: EMPTY
57630: LIST
57631: LIST
57632: LIST
57633: LIST
57634: PUSH
57635: LD_INT 43
57637: PUSH
57638: LD_INT 44
57640: PUSH
57641: LD_INT 46
57643: PUSH
57644: LD_INT 45
57646: PUSH
57647: LD_INT 47
57649: PUSH
57650: LD_INT 49
57652: PUSH
57653: EMPTY
57654: LIST
57655: LIST
57656: LIST
57657: LIST
57658: LIST
57659: LIST
57660: PUSH
57661: EMPTY
57662: LIST
57663: LIST
57664: LIST
57665: PUSH
57666: LD_VAR 0 12
57670: ARRAY
57671: ST_TO_ADDR
// for i in list do
57672: LD_ADDR_VAR 0 8
57676: PUSH
57677: LD_VAR 0 5
57681: PUSH
57682: FOR_IN
57683: IFFALSE 57716
// if not i in fac_list then
57685: LD_VAR 0 8
57689: PUSH
57690: LD_VAR 0 17
57694: IN
57695: NOT
57696: IFFALSE 57714
// list := list diff i ;
57698: LD_ADDR_VAR 0 5
57702: PUSH
57703: LD_VAR 0 5
57707: PUSH
57708: LD_VAR 0 8
57712: DIFF
57713: ST_TO_ADDR
57714: GO 57682
57716: POP
57717: POP
// if not list then
57718: LD_VAR 0 5
57722: NOT
57723: IFFALSE 57727
// exit ;
57725: GO 58531
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
57727: LD_VAR 0 12
57731: PUSH
57732: LD_INT 3
57734: EQUAL
57735: PUSH
57736: LD_INT 49
57738: PUSH
57739: LD_VAR 0 5
57743: IN
57744: AND
57745: PUSH
57746: LD_INT 31
57748: PPUSH
57749: LD_VAR 0 16
57753: PPUSH
57754: CALL_OW 321
57758: PUSH
57759: LD_INT 2
57761: EQUAL
57762: AND
57763: IFFALSE 57823
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
57765: LD_INT 22
57767: PUSH
57768: LD_VAR 0 16
57772: PUSH
57773: EMPTY
57774: LIST
57775: LIST
57776: PUSH
57777: LD_INT 35
57779: PUSH
57780: LD_INT 49
57782: PUSH
57783: EMPTY
57784: LIST
57785: LIST
57786: PUSH
57787: LD_INT 91
57789: PUSH
57790: LD_VAR 0 1
57794: PUSH
57795: LD_INT 10
57797: PUSH
57798: EMPTY
57799: LIST
57800: LIST
57801: LIST
57802: PUSH
57803: EMPTY
57804: LIST
57805: LIST
57806: LIST
57807: PPUSH
57808: CALL_OW 69
57812: NOT
57813: IFFALSE 57823
// weapon := ru_time_lapser ;
57815: LD_ADDR_VAR 0 18
57819: PUSH
57820: LD_INT 49
57822: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
57823: LD_VAR 0 12
57827: PUSH
57828: LD_INT 1
57830: PUSH
57831: LD_INT 2
57833: PUSH
57834: EMPTY
57835: LIST
57836: LIST
57837: IN
57838: PUSH
57839: LD_INT 11
57841: PUSH
57842: LD_VAR 0 5
57846: IN
57847: PUSH
57848: LD_INT 30
57850: PUSH
57851: LD_VAR 0 5
57855: IN
57856: OR
57857: AND
57858: PUSH
57859: LD_INT 6
57861: PPUSH
57862: LD_VAR 0 16
57866: PPUSH
57867: CALL_OW 321
57871: PUSH
57872: LD_INT 2
57874: EQUAL
57875: AND
57876: IFFALSE 58041
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
57878: LD_INT 22
57880: PUSH
57881: LD_VAR 0 16
57885: PUSH
57886: EMPTY
57887: LIST
57888: LIST
57889: PUSH
57890: LD_INT 2
57892: PUSH
57893: LD_INT 35
57895: PUSH
57896: LD_INT 11
57898: PUSH
57899: EMPTY
57900: LIST
57901: LIST
57902: PUSH
57903: LD_INT 35
57905: PUSH
57906: LD_INT 30
57908: PUSH
57909: EMPTY
57910: LIST
57911: LIST
57912: PUSH
57913: EMPTY
57914: LIST
57915: LIST
57916: LIST
57917: PUSH
57918: LD_INT 91
57920: PUSH
57921: LD_VAR 0 1
57925: PUSH
57926: LD_INT 18
57928: PUSH
57929: EMPTY
57930: LIST
57931: LIST
57932: LIST
57933: PUSH
57934: EMPTY
57935: LIST
57936: LIST
57937: LIST
57938: PPUSH
57939: CALL_OW 69
57943: NOT
57944: PUSH
57945: LD_INT 22
57947: PUSH
57948: LD_VAR 0 16
57952: PUSH
57953: EMPTY
57954: LIST
57955: LIST
57956: PUSH
57957: LD_INT 2
57959: PUSH
57960: LD_INT 30
57962: PUSH
57963: LD_INT 32
57965: PUSH
57966: EMPTY
57967: LIST
57968: LIST
57969: PUSH
57970: LD_INT 30
57972: PUSH
57973: LD_INT 33
57975: PUSH
57976: EMPTY
57977: LIST
57978: LIST
57979: PUSH
57980: EMPTY
57981: LIST
57982: LIST
57983: LIST
57984: PUSH
57985: LD_INT 91
57987: PUSH
57988: LD_VAR 0 1
57992: PUSH
57993: LD_INT 12
57995: PUSH
57996: EMPTY
57997: LIST
57998: LIST
57999: LIST
58000: PUSH
58001: EMPTY
58002: LIST
58003: LIST
58004: LIST
58005: PUSH
58006: EMPTY
58007: LIST
58008: PPUSH
58009: CALL_OW 69
58013: PUSH
58014: LD_INT 2
58016: GREATER
58017: AND
58018: IFFALSE 58041
// weapon := [ us_radar , ar_radar ] [ nat ] ;
58020: LD_ADDR_VAR 0 18
58024: PUSH
58025: LD_INT 11
58027: PUSH
58028: LD_INT 30
58030: PUSH
58031: EMPTY
58032: LIST
58033: LIST
58034: PUSH
58035: LD_VAR 0 12
58039: ARRAY
58040: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
58041: LD_VAR 0 18
58045: NOT
58046: PUSH
58047: LD_INT 40
58049: PPUSH
58050: LD_VAR 0 16
58054: PPUSH
58055: CALL_OW 321
58059: PUSH
58060: LD_INT 2
58062: EQUAL
58063: AND
58064: PUSH
58065: LD_INT 7
58067: PUSH
58068: LD_VAR 0 5
58072: IN
58073: PUSH
58074: LD_INT 28
58076: PUSH
58077: LD_VAR 0 5
58081: IN
58082: OR
58083: PUSH
58084: LD_INT 45
58086: PUSH
58087: LD_VAR 0 5
58091: IN
58092: OR
58093: AND
58094: IFFALSE 58348
// begin hex := GetHexInfo ( x , y ) ;
58096: LD_ADDR_VAR 0 4
58100: PUSH
58101: LD_VAR 0 10
58105: PPUSH
58106: LD_VAR 0 11
58110: PPUSH
58111: CALL_OW 546
58115: ST_TO_ADDR
// if hex [ 1 ] then
58116: LD_VAR 0 4
58120: PUSH
58121: LD_INT 1
58123: ARRAY
58124: IFFALSE 58128
// exit ;
58126: GO 58531
// height := hex [ 2 ] ;
58128: LD_ADDR_VAR 0 15
58132: PUSH
58133: LD_VAR 0 4
58137: PUSH
58138: LD_INT 2
58140: ARRAY
58141: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
58142: LD_ADDR_VAR 0 14
58146: PUSH
58147: LD_INT 0
58149: PUSH
58150: LD_INT 2
58152: PUSH
58153: LD_INT 3
58155: PUSH
58156: LD_INT 5
58158: PUSH
58159: EMPTY
58160: LIST
58161: LIST
58162: LIST
58163: LIST
58164: ST_TO_ADDR
// for i in tmp do
58165: LD_ADDR_VAR 0 8
58169: PUSH
58170: LD_VAR 0 14
58174: PUSH
58175: FOR_IN
58176: IFFALSE 58346
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
58178: LD_ADDR_VAR 0 9
58182: PUSH
58183: LD_VAR 0 10
58187: PPUSH
58188: LD_VAR 0 8
58192: PPUSH
58193: LD_INT 5
58195: PPUSH
58196: CALL_OW 272
58200: PUSH
58201: LD_VAR 0 11
58205: PPUSH
58206: LD_VAR 0 8
58210: PPUSH
58211: LD_INT 5
58213: PPUSH
58214: CALL_OW 273
58218: PUSH
58219: EMPTY
58220: LIST
58221: LIST
58222: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
58223: LD_VAR 0 9
58227: PUSH
58228: LD_INT 1
58230: ARRAY
58231: PPUSH
58232: LD_VAR 0 9
58236: PUSH
58237: LD_INT 2
58239: ARRAY
58240: PPUSH
58241: CALL_OW 488
58245: IFFALSE 58344
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
58247: LD_ADDR_VAR 0 4
58251: PUSH
58252: LD_VAR 0 9
58256: PUSH
58257: LD_INT 1
58259: ARRAY
58260: PPUSH
58261: LD_VAR 0 9
58265: PUSH
58266: LD_INT 2
58268: ARRAY
58269: PPUSH
58270: CALL_OW 546
58274: ST_TO_ADDR
// if hex [ 1 ] then
58275: LD_VAR 0 4
58279: PUSH
58280: LD_INT 1
58282: ARRAY
58283: IFFALSE 58287
// continue ;
58285: GO 58175
// h := hex [ 2 ] ;
58287: LD_ADDR_VAR 0 13
58291: PUSH
58292: LD_VAR 0 4
58296: PUSH
58297: LD_INT 2
58299: ARRAY
58300: ST_TO_ADDR
// if h + 7 < height then
58301: LD_VAR 0 13
58305: PUSH
58306: LD_INT 7
58308: PLUS
58309: PUSH
58310: LD_VAR 0 15
58314: LESS
58315: IFFALSE 58344
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
58317: LD_ADDR_VAR 0 18
58321: PUSH
58322: LD_INT 7
58324: PUSH
58325: LD_INT 28
58327: PUSH
58328: LD_INT 45
58330: PUSH
58331: EMPTY
58332: LIST
58333: LIST
58334: LIST
58335: PUSH
58336: LD_VAR 0 12
58340: ARRAY
58341: ST_TO_ADDR
// break ;
58342: GO 58346
// end ; end ; end ;
58344: GO 58175
58346: POP
58347: POP
// end ; if not weapon then
58348: LD_VAR 0 18
58352: NOT
58353: IFFALSE 58413
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
58355: LD_ADDR_VAR 0 5
58359: PUSH
58360: LD_VAR 0 5
58364: PUSH
58365: LD_INT 11
58367: PUSH
58368: LD_INT 30
58370: PUSH
58371: LD_INT 49
58373: PUSH
58374: EMPTY
58375: LIST
58376: LIST
58377: LIST
58378: DIFF
58379: ST_TO_ADDR
// if not list then
58380: LD_VAR 0 5
58384: NOT
58385: IFFALSE 58389
// exit ;
58387: GO 58531
// weapon := list [ rand ( 1 , list ) ] ;
58389: LD_ADDR_VAR 0 18
58393: PUSH
58394: LD_VAR 0 5
58398: PUSH
58399: LD_INT 1
58401: PPUSH
58402: LD_VAR 0 5
58406: PPUSH
58407: CALL_OW 12
58411: ARRAY
58412: ST_TO_ADDR
// end ; if weapon then
58413: LD_VAR 0 18
58417: IFFALSE 58531
// begin tmp := CostOfWeapon ( weapon ) ;
58419: LD_ADDR_VAR 0 14
58423: PUSH
58424: LD_VAR 0 18
58428: PPUSH
58429: CALL_OW 451
58433: ST_TO_ADDR
// j := GetBase ( tower ) ;
58434: LD_ADDR_VAR 0 9
58438: PUSH
58439: LD_VAR 0 1
58443: PPUSH
58444: CALL_OW 274
58448: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
58449: LD_VAR 0 9
58453: PPUSH
58454: LD_INT 1
58456: PPUSH
58457: CALL_OW 275
58461: PUSH
58462: LD_VAR 0 14
58466: PUSH
58467: LD_INT 1
58469: ARRAY
58470: GREATEREQUAL
58471: PUSH
58472: LD_VAR 0 9
58476: PPUSH
58477: LD_INT 2
58479: PPUSH
58480: CALL_OW 275
58484: PUSH
58485: LD_VAR 0 14
58489: PUSH
58490: LD_INT 2
58492: ARRAY
58493: GREATEREQUAL
58494: AND
58495: PUSH
58496: LD_VAR 0 9
58500: PPUSH
58501: LD_INT 3
58503: PPUSH
58504: CALL_OW 275
58508: PUSH
58509: LD_VAR 0 14
58513: PUSH
58514: LD_INT 3
58516: ARRAY
58517: GREATEREQUAL
58518: AND
58519: IFFALSE 58531
// result := weapon ;
58521: LD_ADDR_VAR 0 3
58525: PUSH
58526: LD_VAR 0 18
58530: ST_TO_ADDR
// end ; end ;
58531: LD_VAR 0 3
58535: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
58536: LD_INT 0
58538: PPUSH
58539: PPUSH
// result := true ;
58540: LD_ADDR_VAR 0 3
58544: PUSH
58545: LD_INT 1
58547: ST_TO_ADDR
// if array1 = array2 then
58548: LD_VAR 0 1
58552: PUSH
58553: LD_VAR 0 2
58557: EQUAL
58558: IFFALSE 58618
// begin for i = 1 to array1 do
58560: LD_ADDR_VAR 0 4
58564: PUSH
58565: DOUBLE
58566: LD_INT 1
58568: DEC
58569: ST_TO_ADDR
58570: LD_VAR 0 1
58574: PUSH
58575: FOR_TO
58576: IFFALSE 58614
// if array1 [ i ] <> array2 [ i ] then
58578: LD_VAR 0 1
58582: PUSH
58583: LD_VAR 0 4
58587: ARRAY
58588: PUSH
58589: LD_VAR 0 2
58593: PUSH
58594: LD_VAR 0 4
58598: ARRAY
58599: NONEQUAL
58600: IFFALSE 58612
// begin result := false ;
58602: LD_ADDR_VAR 0 3
58606: PUSH
58607: LD_INT 0
58609: ST_TO_ADDR
// break ;
58610: GO 58614
// end ;
58612: GO 58575
58614: POP
58615: POP
// end else
58616: GO 58626
// result := false ;
58618: LD_ADDR_VAR 0 3
58622: PUSH
58623: LD_INT 0
58625: ST_TO_ADDR
// end ;
58626: LD_VAR 0 3
58630: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
58631: LD_INT 0
58633: PPUSH
58634: PPUSH
58635: PPUSH
// pom := GetBase ( fac ) ;
58636: LD_ADDR_VAR 0 5
58640: PUSH
58641: LD_VAR 0 1
58645: PPUSH
58646: CALL_OW 274
58650: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
58651: LD_ADDR_VAR 0 4
58655: PUSH
58656: LD_VAR 0 2
58660: PUSH
58661: LD_INT 1
58663: ARRAY
58664: PPUSH
58665: LD_VAR 0 2
58669: PUSH
58670: LD_INT 2
58672: ARRAY
58673: PPUSH
58674: LD_VAR 0 2
58678: PUSH
58679: LD_INT 3
58681: ARRAY
58682: PPUSH
58683: LD_VAR 0 2
58687: PUSH
58688: LD_INT 4
58690: ARRAY
58691: PPUSH
58692: CALL_OW 449
58696: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
58697: LD_ADDR_VAR 0 3
58701: PUSH
58702: LD_VAR 0 5
58706: PPUSH
58707: LD_INT 1
58709: PPUSH
58710: CALL_OW 275
58714: PUSH
58715: LD_VAR 0 4
58719: PUSH
58720: LD_INT 1
58722: ARRAY
58723: GREATEREQUAL
58724: PUSH
58725: LD_VAR 0 5
58729: PPUSH
58730: LD_INT 2
58732: PPUSH
58733: CALL_OW 275
58737: PUSH
58738: LD_VAR 0 4
58742: PUSH
58743: LD_INT 2
58745: ARRAY
58746: GREATEREQUAL
58747: AND
58748: PUSH
58749: LD_VAR 0 5
58753: PPUSH
58754: LD_INT 3
58756: PPUSH
58757: CALL_OW 275
58761: PUSH
58762: LD_VAR 0 4
58766: PUSH
58767: LD_INT 3
58769: ARRAY
58770: GREATEREQUAL
58771: AND
58772: ST_TO_ADDR
// end ;
58773: LD_VAR 0 3
58777: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
58778: LD_INT 0
58780: PPUSH
58781: PPUSH
58782: PPUSH
58783: PPUSH
// pom := GetBase ( building ) ;
58784: LD_ADDR_VAR 0 3
58788: PUSH
58789: LD_VAR 0 1
58793: PPUSH
58794: CALL_OW 274
58798: ST_TO_ADDR
// if not pom then
58799: LD_VAR 0 3
58803: NOT
58804: IFFALSE 58808
// exit ;
58806: GO 58978
// btype := GetBType ( building ) ;
58808: LD_ADDR_VAR 0 5
58812: PUSH
58813: LD_VAR 0 1
58817: PPUSH
58818: CALL_OW 266
58822: ST_TO_ADDR
// if btype = b_armoury then
58823: LD_VAR 0 5
58827: PUSH
58828: LD_INT 4
58830: EQUAL
58831: IFFALSE 58841
// btype := b_barracks ;
58833: LD_ADDR_VAR 0 5
58837: PUSH
58838: LD_INT 5
58840: ST_TO_ADDR
// if btype = b_depot then
58841: LD_VAR 0 5
58845: PUSH
58846: LD_INT 0
58848: EQUAL
58849: IFFALSE 58859
// btype := b_warehouse ;
58851: LD_ADDR_VAR 0 5
58855: PUSH
58856: LD_INT 1
58858: ST_TO_ADDR
// if btype = b_workshop then
58859: LD_VAR 0 5
58863: PUSH
58864: LD_INT 2
58866: EQUAL
58867: IFFALSE 58877
// btype := b_factory ;
58869: LD_ADDR_VAR 0 5
58873: PUSH
58874: LD_INT 3
58876: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
58877: LD_ADDR_VAR 0 4
58881: PUSH
58882: LD_VAR 0 5
58886: PPUSH
58887: LD_VAR 0 1
58891: PPUSH
58892: CALL_OW 248
58896: PPUSH
58897: CALL_OW 450
58901: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
58902: LD_ADDR_VAR 0 2
58906: PUSH
58907: LD_VAR 0 3
58911: PPUSH
58912: LD_INT 1
58914: PPUSH
58915: CALL_OW 275
58919: PUSH
58920: LD_VAR 0 4
58924: PUSH
58925: LD_INT 1
58927: ARRAY
58928: GREATEREQUAL
58929: PUSH
58930: LD_VAR 0 3
58934: PPUSH
58935: LD_INT 2
58937: PPUSH
58938: CALL_OW 275
58942: PUSH
58943: LD_VAR 0 4
58947: PUSH
58948: LD_INT 2
58950: ARRAY
58951: GREATEREQUAL
58952: AND
58953: PUSH
58954: LD_VAR 0 3
58958: PPUSH
58959: LD_INT 3
58961: PPUSH
58962: CALL_OW 275
58966: PUSH
58967: LD_VAR 0 4
58971: PUSH
58972: LD_INT 3
58974: ARRAY
58975: GREATEREQUAL
58976: AND
58977: ST_TO_ADDR
// end ;
58978: LD_VAR 0 2
58982: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
58983: LD_INT 0
58985: PPUSH
58986: PPUSH
58987: PPUSH
// pom := GetBase ( building ) ;
58988: LD_ADDR_VAR 0 4
58992: PUSH
58993: LD_VAR 0 1
58997: PPUSH
58998: CALL_OW 274
59002: ST_TO_ADDR
// if not pom then
59003: LD_VAR 0 4
59007: NOT
59008: IFFALSE 59012
// exit ;
59010: GO 59113
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
59012: LD_ADDR_VAR 0 5
59016: PUSH
59017: LD_VAR 0 2
59021: PPUSH
59022: LD_VAR 0 1
59026: PPUSH
59027: CALL_OW 248
59031: PPUSH
59032: CALL_OW 450
59036: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59037: LD_ADDR_VAR 0 3
59041: PUSH
59042: LD_VAR 0 4
59046: PPUSH
59047: LD_INT 1
59049: PPUSH
59050: CALL_OW 275
59054: PUSH
59055: LD_VAR 0 5
59059: PUSH
59060: LD_INT 1
59062: ARRAY
59063: GREATEREQUAL
59064: PUSH
59065: LD_VAR 0 4
59069: PPUSH
59070: LD_INT 2
59072: PPUSH
59073: CALL_OW 275
59077: PUSH
59078: LD_VAR 0 5
59082: PUSH
59083: LD_INT 2
59085: ARRAY
59086: GREATEREQUAL
59087: AND
59088: PUSH
59089: LD_VAR 0 4
59093: PPUSH
59094: LD_INT 3
59096: PPUSH
59097: CALL_OW 275
59101: PUSH
59102: LD_VAR 0 5
59106: PUSH
59107: LD_INT 3
59109: ARRAY
59110: GREATEREQUAL
59111: AND
59112: ST_TO_ADDR
// end ;
59113: LD_VAR 0 3
59117: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
59118: LD_INT 0
59120: PPUSH
59121: PPUSH
59122: PPUSH
59123: PPUSH
59124: PPUSH
59125: PPUSH
59126: PPUSH
59127: PPUSH
59128: PPUSH
59129: PPUSH
// result := false ;
59130: LD_ADDR_VAR 0 6
59134: PUSH
59135: LD_INT 0
59137: ST_TO_ADDR
// if not base or not btype or not x or not y then
59138: LD_VAR 0 1
59142: NOT
59143: PUSH
59144: LD_VAR 0 2
59148: NOT
59149: OR
59150: PUSH
59151: LD_VAR 0 3
59155: NOT
59156: OR
59157: PUSH
59158: LD_VAR 0 4
59162: NOT
59163: OR
59164: IFFALSE 59168
// exit ;
59166: GO 59777
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
59168: LD_ADDR_VAR 0 12
59172: PUSH
59173: LD_VAR 0 2
59177: PPUSH
59178: LD_VAR 0 3
59182: PPUSH
59183: LD_VAR 0 4
59187: PPUSH
59188: LD_VAR 0 5
59192: PPUSH
59193: LD_VAR 0 1
59197: PUSH
59198: LD_INT 1
59200: ARRAY
59201: PPUSH
59202: CALL_OW 248
59206: PPUSH
59207: LD_INT 0
59209: PPUSH
59210: CALL 60614 0 6
59214: ST_TO_ADDR
// if not hexes then
59215: LD_VAR 0 12
59219: NOT
59220: IFFALSE 59224
// exit ;
59222: GO 59777
// for i = 1 to hexes do
59224: LD_ADDR_VAR 0 7
59228: PUSH
59229: DOUBLE
59230: LD_INT 1
59232: DEC
59233: ST_TO_ADDR
59234: LD_VAR 0 12
59238: PUSH
59239: FOR_TO
59240: IFFALSE 59775
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
59242: LD_ADDR_VAR 0 11
59246: PUSH
59247: LD_VAR 0 12
59251: PUSH
59252: LD_VAR 0 7
59256: ARRAY
59257: PUSH
59258: LD_INT 1
59260: ARRAY
59261: PPUSH
59262: LD_VAR 0 12
59266: PUSH
59267: LD_VAR 0 7
59271: ARRAY
59272: PUSH
59273: LD_INT 2
59275: ARRAY
59276: PPUSH
59277: CALL_OW 428
59281: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
59282: LD_VAR 0 12
59286: PUSH
59287: LD_VAR 0 7
59291: ARRAY
59292: PUSH
59293: LD_INT 1
59295: ARRAY
59296: PPUSH
59297: LD_VAR 0 12
59301: PUSH
59302: LD_VAR 0 7
59306: ARRAY
59307: PUSH
59308: LD_INT 2
59310: ARRAY
59311: PPUSH
59312: CALL_OW 351
59316: PUSH
59317: LD_VAR 0 12
59321: PUSH
59322: LD_VAR 0 7
59326: ARRAY
59327: PUSH
59328: LD_INT 1
59330: ARRAY
59331: PPUSH
59332: LD_VAR 0 12
59336: PUSH
59337: LD_VAR 0 7
59341: ARRAY
59342: PUSH
59343: LD_INT 2
59345: ARRAY
59346: PPUSH
59347: CALL_OW 488
59351: NOT
59352: OR
59353: PUSH
59354: LD_VAR 0 11
59358: PPUSH
59359: CALL_OW 247
59363: PUSH
59364: LD_INT 3
59366: EQUAL
59367: OR
59368: IFFALSE 59374
// exit ;
59370: POP
59371: POP
59372: GO 59777
// if not tmp or not tmp in base then
59374: LD_VAR 0 11
59378: NOT
59379: PUSH
59380: LD_VAR 0 11
59384: PUSH
59385: LD_VAR 0 1
59389: IN
59390: NOT
59391: OR
59392: IFFALSE 59396
// continue ;
59394: GO 59239
// result := true ;
59396: LD_ADDR_VAR 0 6
59400: PUSH
59401: LD_INT 1
59403: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
59404: LD_ADDR_VAR 0 15
59408: PUSH
59409: LD_VAR 0 1
59413: PPUSH
59414: LD_INT 22
59416: PUSH
59417: LD_VAR 0 11
59421: PPUSH
59422: CALL_OW 255
59426: PUSH
59427: EMPTY
59428: LIST
59429: LIST
59430: PUSH
59431: LD_INT 2
59433: PUSH
59434: LD_INT 30
59436: PUSH
59437: LD_INT 0
59439: PUSH
59440: EMPTY
59441: LIST
59442: LIST
59443: PUSH
59444: LD_INT 30
59446: PUSH
59447: LD_INT 1
59449: PUSH
59450: EMPTY
59451: LIST
59452: LIST
59453: PUSH
59454: EMPTY
59455: LIST
59456: LIST
59457: LIST
59458: PUSH
59459: EMPTY
59460: LIST
59461: LIST
59462: PPUSH
59463: CALL_OW 72
59467: ST_TO_ADDR
// if dep then
59468: LD_VAR 0 15
59472: IFFALSE 59608
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
59474: LD_ADDR_VAR 0 14
59478: PUSH
59479: LD_VAR 0 15
59483: PUSH
59484: LD_INT 1
59486: ARRAY
59487: PPUSH
59488: CALL_OW 250
59492: PPUSH
59493: LD_VAR 0 15
59497: PUSH
59498: LD_INT 1
59500: ARRAY
59501: PPUSH
59502: CALL_OW 254
59506: PPUSH
59507: LD_INT 5
59509: PPUSH
59510: CALL_OW 272
59514: PUSH
59515: LD_VAR 0 15
59519: PUSH
59520: LD_INT 1
59522: ARRAY
59523: PPUSH
59524: CALL_OW 251
59528: PPUSH
59529: LD_VAR 0 15
59533: PUSH
59534: LD_INT 1
59536: ARRAY
59537: PPUSH
59538: CALL_OW 254
59542: PPUSH
59543: LD_INT 5
59545: PPUSH
59546: CALL_OW 273
59550: PUSH
59551: EMPTY
59552: LIST
59553: LIST
59554: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
59555: LD_VAR 0 14
59559: PUSH
59560: LD_INT 1
59562: ARRAY
59563: PPUSH
59564: LD_VAR 0 14
59568: PUSH
59569: LD_INT 2
59571: ARRAY
59572: PPUSH
59573: CALL_OW 488
59577: IFFALSE 59608
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
59579: LD_VAR 0 11
59583: PPUSH
59584: LD_VAR 0 14
59588: PUSH
59589: LD_INT 1
59591: ARRAY
59592: PPUSH
59593: LD_VAR 0 14
59597: PUSH
59598: LD_INT 2
59600: ARRAY
59601: PPUSH
59602: CALL_OW 111
// continue ;
59606: GO 59239
// end ; end ; r := GetDir ( tmp ) ;
59608: LD_ADDR_VAR 0 13
59612: PUSH
59613: LD_VAR 0 11
59617: PPUSH
59618: CALL_OW 254
59622: ST_TO_ADDR
// if r = 5 then
59623: LD_VAR 0 13
59627: PUSH
59628: LD_INT 5
59630: EQUAL
59631: IFFALSE 59641
// r := 0 ;
59633: LD_ADDR_VAR 0 13
59637: PUSH
59638: LD_INT 0
59640: ST_TO_ADDR
// for j = r to 5 do
59641: LD_ADDR_VAR 0 8
59645: PUSH
59646: DOUBLE
59647: LD_VAR 0 13
59651: DEC
59652: ST_TO_ADDR
59653: LD_INT 5
59655: PUSH
59656: FOR_TO
59657: IFFALSE 59771
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
59659: LD_ADDR_VAR 0 9
59663: PUSH
59664: LD_VAR 0 11
59668: PPUSH
59669: CALL_OW 250
59673: PPUSH
59674: LD_VAR 0 8
59678: PPUSH
59679: LD_INT 2
59681: PPUSH
59682: CALL_OW 272
59686: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
59687: LD_ADDR_VAR 0 10
59691: PUSH
59692: LD_VAR 0 11
59696: PPUSH
59697: CALL_OW 251
59701: PPUSH
59702: LD_VAR 0 8
59706: PPUSH
59707: LD_INT 2
59709: PPUSH
59710: CALL_OW 273
59714: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
59715: LD_VAR 0 9
59719: PPUSH
59720: LD_VAR 0 10
59724: PPUSH
59725: CALL_OW 488
59729: PUSH
59730: LD_VAR 0 9
59734: PPUSH
59735: LD_VAR 0 10
59739: PPUSH
59740: CALL_OW 428
59744: NOT
59745: AND
59746: IFFALSE 59769
// begin ComMoveXY ( tmp , _x , _y ) ;
59748: LD_VAR 0 11
59752: PPUSH
59753: LD_VAR 0 9
59757: PPUSH
59758: LD_VAR 0 10
59762: PPUSH
59763: CALL_OW 111
// break ;
59767: GO 59771
// end ; end ;
59769: GO 59656
59771: POP
59772: POP
// end ;
59773: GO 59239
59775: POP
59776: POP
// end ;
59777: LD_VAR 0 6
59781: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
59782: LD_INT 0
59784: PPUSH
59785: PPUSH
59786: PPUSH
59787: PPUSH
59788: PPUSH
59789: PPUSH
59790: PPUSH
59791: PPUSH
59792: PPUSH
59793: PPUSH
// result := false ;
59794: LD_ADDR_VAR 0 6
59798: PUSH
59799: LD_INT 0
59801: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
59802: LD_VAR 0 1
59806: NOT
59807: PUSH
59808: LD_VAR 0 1
59812: PPUSH
59813: CALL_OW 266
59817: PUSH
59818: LD_INT 0
59820: PUSH
59821: LD_INT 1
59823: PUSH
59824: EMPTY
59825: LIST
59826: LIST
59827: IN
59828: NOT
59829: OR
59830: PUSH
59831: LD_VAR 0 2
59835: NOT
59836: OR
59837: PUSH
59838: LD_VAR 0 5
59842: PUSH
59843: LD_INT 0
59845: PUSH
59846: LD_INT 1
59848: PUSH
59849: LD_INT 2
59851: PUSH
59852: LD_INT 3
59854: PUSH
59855: LD_INT 4
59857: PUSH
59858: LD_INT 5
59860: PUSH
59861: EMPTY
59862: LIST
59863: LIST
59864: LIST
59865: LIST
59866: LIST
59867: LIST
59868: IN
59869: NOT
59870: OR
59871: PUSH
59872: LD_VAR 0 3
59876: PPUSH
59877: LD_VAR 0 4
59881: PPUSH
59882: CALL_OW 488
59886: NOT
59887: OR
59888: IFFALSE 59892
// exit ;
59890: GO 60609
// pom := GetBase ( depot ) ;
59892: LD_ADDR_VAR 0 10
59896: PUSH
59897: LD_VAR 0 1
59901: PPUSH
59902: CALL_OW 274
59906: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
59907: LD_ADDR_VAR 0 11
59911: PUSH
59912: LD_VAR 0 2
59916: PPUSH
59917: LD_VAR 0 1
59921: PPUSH
59922: CALL_OW 248
59926: PPUSH
59927: CALL_OW 450
59931: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
59932: LD_VAR 0 10
59936: PPUSH
59937: LD_INT 1
59939: PPUSH
59940: CALL_OW 275
59944: PUSH
59945: LD_VAR 0 11
59949: PUSH
59950: LD_INT 1
59952: ARRAY
59953: GREATEREQUAL
59954: PUSH
59955: LD_VAR 0 10
59959: PPUSH
59960: LD_INT 2
59962: PPUSH
59963: CALL_OW 275
59967: PUSH
59968: LD_VAR 0 11
59972: PUSH
59973: LD_INT 2
59975: ARRAY
59976: GREATEREQUAL
59977: AND
59978: PUSH
59979: LD_VAR 0 10
59983: PPUSH
59984: LD_INT 3
59986: PPUSH
59987: CALL_OW 275
59991: PUSH
59992: LD_VAR 0 11
59996: PUSH
59997: LD_INT 3
59999: ARRAY
60000: GREATEREQUAL
60001: AND
60002: NOT
60003: IFFALSE 60007
// exit ;
60005: GO 60609
// if GetBType ( depot ) = b_depot then
60007: LD_VAR 0 1
60011: PPUSH
60012: CALL_OW 266
60016: PUSH
60017: LD_INT 0
60019: EQUAL
60020: IFFALSE 60032
// dist := 28 else
60022: LD_ADDR_VAR 0 14
60026: PUSH
60027: LD_INT 28
60029: ST_TO_ADDR
60030: GO 60040
// dist := 36 ;
60032: LD_ADDR_VAR 0 14
60036: PUSH
60037: LD_INT 36
60039: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
60040: LD_VAR 0 1
60044: PPUSH
60045: LD_VAR 0 3
60049: PPUSH
60050: LD_VAR 0 4
60054: PPUSH
60055: CALL_OW 297
60059: PUSH
60060: LD_VAR 0 14
60064: GREATER
60065: IFFALSE 60069
// exit ;
60067: GO 60609
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
60069: LD_ADDR_VAR 0 12
60073: PUSH
60074: LD_VAR 0 2
60078: PPUSH
60079: LD_VAR 0 3
60083: PPUSH
60084: LD_VAR 0 4
60088: PPUSH
60089: LD_VAR 0 5
60093: PPUSH
60094: LD_VAR 0 1
60098: PPUSH
60099: CALL_OW 248
60103: PPUSH
60104: LD_INT 0
60106: PPUSH
60107: CALL 60614 0 6
60111: ST_TO_ADDR
// if not hexes then
60112: LD_VAR 0 12
60116: NOT
60117: IFFALSE 60121
// exit ;
60119: GO 60609
// hex := GetHexInfo ( x , y ) ;
60121: LD_ADDR_VAR 0 15
60125: PUSH
60126: LD_VAR 0 3
60130: PPUSH
60131: LD_VAR 0 4
60135: PPUSH
60136: CALL_OW 546
60140: ST_TO_ADDR
// if hex [ 1 ] then
60141: LD_VAR 0 15
60145: PUSH
60146: LD_INT 1
60148: ARRAY
60149: IFFALSE 60153
// exit ;
60151: GO 60609
// height := hex [ 2 ] ;
60153: LD_ADDR_VAR 0 13
60157: PUSH
60158: LD_VAR 0 15
60162: PUSH
60163: LD_INT 2
60165: ARRAY
60166: ST_TO_ADDR
// for i = 1 to hexes do
60167: LD_ADDR_VAR 0 7
60171: PUSH
60172: DOUBLE
60173: LD_INT 1
60175: DEC
60176: ST_TO_ADDR
60177: LD_VAR 0 12
60181: PUSH
60182: FOR_TO
60183: IFFALSE 60513
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
60185: LD_VAR 0 12
60189: PUSH
60190: LD_VAR 0 7
60194: ARRAY
60195: PUSH
60196: LD_INT 1
60198: ARRAY
60199: PPUSH
60200: LD_VAR 0 12
60204: PUSH
60205: LD_VAR 0 7
60209: ARRAY
60210: PUSH
60211: LD_INT 2
60213: ARRAY
60214: PPUSH
60215: CALL_OW 488
60219: NOT
60220: PUSH
60221: LD_VAR 0 12
60225: PUSH
60226: LD_VAR 0 7
60230: ARRAY
60231: PUSH
60232: LD_INT 1
60234: ARRAY
60235: PPUSH
60236: LD_VAR 0 12
60240: PUSH
60241: LD_VAR 0 7
60245: ARRAY
60246: PUSH
60247: LD_INT 2
60249: ARRAY
60250: PPUSH
60251: CALL_OW 428
60255: PUSH
60256: LD_INT 0
60258: GREATER
60259: OR
60260: PUSH
60261: LD_VAR 0 12
60265: PUSH
60266: LD_VAR 0 7
60270: ARRAY
60271: PUSH
60272: LD_INT 1
60274: ARRAY
60275: PPUSH
60276: LD_VAR 0 12
60280: PUSH
60281: LD_VAR 0 7
60285: ARRAY
60286: PUSH
60287: LD_INT 2
60289: ARRAY
60290: PPUSH
60291: CALL_OW 351
60295: OR
60296: IFFALSE 60302
// exit ;
60298: POP
60299: POP
60300: GO 60609
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60302: LD_ADDR_VAR 0 8
60306: PUSH
60307: LD_VAR 0 12
60311: PUSH
60312: LD_VAR 0 7
60316: ARRAY
60317: PUSH
60318: LD_INT 1
60320: ARRAY
60321: PPUSH
60322: LD_VAR 0 12
60326: PUSH
60327: LD_VAR 0 7
60331: ARRAY
60332: PUSH
60333: LD_INT 2
60335: ARRAY
60336: PPUSH
60337: CALL_OW 546
60341: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
60342: LD_VAR 0 8
60346: PUSH
60347: LD_INT 1
60349: ARRAY
60350: PUSH
60351: LD_VAR 0 8
60355: PUSH
60356: LD_INT 2
60358: ARRAY
60359: PUSH
60360: LD_VAR 0 13
60364: PUSH
60365: LD_INT 2
60367: PLUS
60368: GREATER
60369: OR
60370: PUSH
60371: LD_VAR 0 8
60375: PUSH
60376: LD_INT 2
60378: ARRAY
60379: PUSH
60380: LD_VAR 0 13
60384: PUSH
60385: LD_INT 2
60387: MINUS
60388: LESS
60389: OR
60390: PUSH
60391: LD_VAR 0 8
60395: PUSH
60396: LD_INT 3
60398: ARRAY
60399: PUSH
60400: LD_INT 0
60402: PUSH
60403: LD_INT 8
60405: PUSH
60406: LD_INT 9
60408: PUSH
60409: LD_INT 10
60411: PUSH
60412: LD_INT 11
60414: PUSH
60415: LD_INT 12
60417: PUSH
60418: LD_INT 13
60420: PUSH
60421: LD_INT 16
60423: PUSH
60424: LD_INT 17
60426: PUSH
60427: LD_INT 18
60429: PUSH
60430: LD_INT 19
60432: PUSH
60433: LD_INT 20
60435: PUSH
60436: LD_INT 21
60438: PUSH
60439: EMPTY
60440: LIST
60441: LIST
60442: LIST
60443: LIST
60444: LIST
60445: LIST
60446: LIST
60447: LIST
60448: LIST
60449: LIST
60450: LIST
60451: LIST
60452: LIST
60453: IN
60454: NOT
60455: OR
60456: PUSH
60457: LD_VAR 0 8
60461: PUSH
60462: LD_INT 5
60464: ARRAY
60465: NOT
60466: OR
60467: PUSH
60468: LD_VAR 0 8
60472: PUSH
60473: LD_INT 6
60475: ARRAY
60476: PUSH
60477: LD_INT 1
60479: PUSH
60480: LD_INT 2
60482: PUSH
60483: LD_INT 7
60485: PUSH
60486: LD_INT 9
60488: PUSH
60489: LD_INT 10
60491: PUSH
60492: LD_INT 11
60494: PUSH
60495: EMPTY
60496: LIST
60497: LIST
60498: LIST
60499: LIST
60500: LIST
60501: LIST
60502: IN
60503: NOT
60504: OR
60505: IFFALSE 60511
// exit ;
60507: POP
60508: POP
60509: GO 60609
// end ;
60511: GO 60182
60513: POP
60514: POP
// side := GetSide ( depot ) ;
60515: LD_ADDR_VAR 0 9
60519: PUSH
60520: LD_VAR 0 1
60524: PPUSH
60525: CALL_OW 255
60529: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
60530: LD_VAR 0 9
60534: PPUSH
60535: LD_VAR 0 3
60539: PPUSH
60540: LD_VAR 0 4
60544: PPUSH
60545: LD_INT 20
60547: PPUSH
60548: CALL 53263 0 4
60552: PUSH
60553: LD_INT 4
60555: ARRAY
60556: IFFALSE 60560
// exit ;
60558: GO 60609
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
60560: LD_VAR 0 2
60564: PUSH
60565: LD_INT 29
60567: PUSH
60568: LD_INT 30
60570: PUSH
60571: EMPTY
60572: LIST
60573: LIST
60574: IN
60575: PUSH
60576: LD_VAR 0 3
60580: PPUSH
60581: LD_VAR 0 4
60585: PPUSH
60586: LD_VAR 0 9
60590: PPUSH
60591: CALL_OW 440
60595: NOT
60596: AND
60597: IFFALSE 60601
// exit ;
60599: GO 60609
// result := true ;
60601: LD_ADDR_VAR 0 6
60605: PUSH
60606: LD_INT 1
60608: ST_TO_ADDR
// end ;
60609: LD_VAR 0 6
60613: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
60614: LD_INT 0
60616: PPUSH
60617: PPUSH
60618: PPUSH
60619: PPUSH
60620: PPUSH
60621: PPUSH
60622: PPUSH
60623: PPUSH
60624: PPUSH
60625: PPUSH
60626: PPUSH
60627: PPUSH
60628: PPUSH
60629: PPUSH
60630: PPUSH
60631: PPUSH
60632: PPUSH
60633: PPUSH
60634: PPUSH
60635: PPUSH
60636: PPUSH
60637: PPUSH
60638: PPUSH
60639: PPUSH
60640: PPUSH
60641: PPUSH
60642: PPUSH
60643: PPUSH
60644: PPUSH
60645: PPUSH
60646: PPUSH
60647: PPUSH
60648: PPUSH
60649: PPUSH
60650: PPUSH
60651: PPUSH
60652: PPUSH
60653: PPUSH
60654: PPUSH
60655: PPUSH
60656: PPUSH
60657: PPUSH
60658: PPUSH
60659: PPUSH
60660: PPUSH
60661: PPUSH
60662: PPUSH
60663: PPUSH
60664: PPUSH
60665: PPUSH
60666: PPUSH
60667: PPUSH
60668: PPUSH
60669: PPUSH
60670: PPUSH
60671: PPUSH
60672: PPUSH
60673: PPUSH
// result = [ ] ;
60674: LD_ADDR_VAR 0 7
60678: PUSH
60679: EMPTY
60680: ST_TO_ADDR
// temp_list = [ ] ;
60681: LD_ADDR_VAR 0 9
60685: PUSH
60686: EMPTY
60687: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
60688: LD_VAR 0 4
60692: PUSH
60693: LD_INT 0
60695: PUSH
60696: LD_INT 1
60698: PUSH
60699: LD_INT 2
60701: PUSH
60702: LD_INT 3
60704: PUSH
60705: LD_INT 4
60707: PUSH
60708: LD_INT 5
60710: PUSH
60711: EMPTY
60712: LIST
60713: LIST
60714: LIST
60715: LIST
60716: LIST
60717: LIST
60718: IN
60719: NOT
60720: PUSH
60721: LD_VAR 0 1
60725: PUSH
60726: LD_INT 0
60728: PUSH
60729: LD_INT 1
60731: PUSH
60732: EMPTY
60733: LIST
60734: LIST
60735: IN
60736: PUSH
60737: LD_VAR 0 5
60741: PUSH
60742: LD_INT 1
60744: PUSH
60745: LD_INT 2
60747: PUSH
60748: LD_INT 3
60750: PUSH
60751: EMPTY
60752: LIST
60753: LIST
60754: LIST
60755: IN
60756: NOT
60757: AND
60758: OR
60759: IFFALSE 60763
// exit ;
60761: GO 79154
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
60763: LD_VAR 0 1
60767: PUSH
60768: LD_INT 6
60770: PUSH
60771: LD_INT 7
60773: PUSH
60774: LD_INT 8
60776: PUSH
60777: LD_INT 13
60779: PUSH
60780: LD_INT 12
60782: PUSH
60783: LD_INT 15
60785: PUSH
60786: LD_INT 11
60788: PUSH
60789: LD_INT 14
60791: PUSH
60792: LD_INT 10
60794: PUSH
60795: EMPTY
60796: LIST
60797: LIST
60798: LIST
60799: LIST
60800: LIST
60801: LIST
60802: LIST
60803: LIST
60804: LIST
60805: IN
60806: IFFALSE 60816
// btype = b_lab ;
60808: LD_ADDR_VAR 0 1
60812: PUSH
60813: LD_INT 6
60815: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
60816: LD_VAR 0 6
60820: PUSH
60821: LD_INT 0
60823: PUSH
60824: LD_INT 1
60826: PUSH
60827: LD_INT 2
60829: PUSH
60830: EMPTY
60831: LIST
60832: LIST
60833: LIST
60834: IN
60835: NOT
60836: PUSH
60837: LD_VAR 0 1
60841: PUSH
60842: LD_INT 0
60844: PUSH
60845: LD_INT 1
60847: PUSH
60848: LD_INT 2
60850: PUSH
60851: LD_INT 3
60853: PUSH
60854: LD_INT 6
60856: PUSH
60857: LD_INT 36
60859: PUSH
60860: LD_INT 4
60862: PUSH
60863: LD_INT 5
60865: PUSH
60866: LD_INT 31
60868: PUSH
60869: LD_INT 32
60871: PUSH
60872: LD_INT 33
60874: PUSH
60875: EMPTY
60876: LIST
60877: LIST
60878: LIST
60879: LIST
60880: LIST
60881: LIST
60882: LIST
60883: LIST
60884: LIST
60885: LIST
60886: LIST
60887: IN
60888: NOT
60889: PUSH
60890: LD_VAR 0 6
60894: PUSH
60895: LD_INT 1
60897: EQUAL
60898: AND
60899: OR
60900: PUSH
60901: LD_VAR 0 1
60905: PUSH
60906: LD_INT 2
60908: PUSH
60909: LD_INT 3
60911: PUSH
60912: EMPTY
60913: LIST
60914: LIST
60915: IN
60916: NOT
60917: PUSH
60918: LD_VAR 0 6
60922: PUSH
60923: LD_INT 2
60925: EQUAL
60926: AND
60927: OR
60928: IFFALSE 60938
// mode = 0 ;
60930: LD_ADDR_VAR 0 6
60934: PUSH
60935: LD_INT 0
60937: ST_TO_ADDR
// case mode of 0 :
60938: LD_VAR 0 6
60942: PUSH
60943: LD_INT 0
60945: DOUBLE
60946: EQUAL
60947: IFTRUE 60951
60949: GO 72404
60951: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
60952: LD_ADDR_VAR 0 11
60956: PUSH
60957: LD_INT 0
60959: PUSH
60960: LD_INT 0
60962: PUSH
60963: EMPTY
60964: LIST
60965: LIST
60966: PUSH
60967: LD_INT 0
60969: PUSH
60970: LD_INT 1
60972: NEG
60973: PUSH
60974: EMPTY
60975: LIST
60976: LIST
60977: PUSH
60978: LD_INT 1
60980: PUSH
60981: LD_INT 0
60983: PUSH
60984: EMPTY
60985: LIST
60986: LIST
60987: PUSH
60988: LD_INT 1
60990: PUSH
60991: LD_INT 1
60993: PUSH
60994: EMPTY
60995: LIST
60996: LIST
60997: PUSH
60998: LD_INT 0
61000: PUSH
61001: LD_INT 1
61003: PUSH
61004: EMPTY
61005: LIST
61006: LIST
61007: PUSH
61008: LD_INT 1
61010: NEG
61011: PUSH
61012: LD_INT 0
61014: PUSH
61015: EMPTY
61016: LIST
61017: LIST
61018: PUSH
61019: LD_INT 1
61021: NEG
61022: PUSH
61023: LD_INT 1
61025: NEG
61026: PUSH
61027: EMPTY
61028: LIST
61029: LIST
61030: PUSH
61031: LD_INT 1
61033: NEG
61034: PUSH
61035: LD_INT 2
61037: NEG
61038: PUSH
61039: EMPTY
61040: LIST
61041: LIST
61042: PUSH
61043: LD_INT 0
61045: PUSH
61046: LD_INT 2
61048: NEG
61049: PUSH
61050: EMPTY
61051: LIST
61052: LIST
61053: PUSH
61054: LD_INT 1
61056: PUSH
61057: LD_INT 1
61059: NEG
61060: PUSH
61061: EMPTY
61062: LIST
61063: LIST
61064: PUSH
61065: LD_INT 1
61067: PUSH
61068: LD_INT 2
61070: PUSH
61071: EMPTY
61072: LIST
61073: LIST
61074: PUSH
61075: LD_INT 0
61077: PUSH
61078: LD_INT 2
61080: PUSH
61081: EMPTY
61082: LIST
61083: LIST
61084: PUSH
61085: LD_INT 1
61087: NEG
61088: PUSH
61089: LD_INT 1
61091: PUSH
61092: EMPTY
61093: LIST
61094: LIST
61095: PUSH
61096: LD_INT 1
61098: PUSH
61099: LD_INT 3
61101: PUSH
61102: EMPTY
61103: LIST
61104: LIST
61105: PUSH
61106: LD_INT 0
61108: PUSH
61109: LD_INT 3
61111: PUSH
61112: EMPTY
61113: LIST
61114: LIST
61115: PUSH
61116: LD_INT 1
61118: NEG
61119: PUSH
61120: LD_INT 2
61122: PUSH
61123: EMPTY
61124: LIST
61125: LIST
61126: PUSH
61127: EMPTY
61128: LIST
61129: LIST
61130: LIST
61131: LIST
61132: LIST
61133: LIST
61134: LIST
61135: LIST
61136: LIST
61137: LIST
61138: LIST
61139: LIST
61140: LIST
61141: LIST
61142: LIST
61143: LIST
61144: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
61145: LD_ADDR_VAR 0 12
61149: PUSH
61150: LD_INT 0
61152: PUSH
61153: LD_INT 0
61155: PUSH
61156: EMPTY
61157: LIST
61158: LIST
61159: PUSH
61160: LD_INT 0
61162: PUSH
61163: LD_INT 1
61165: NEG
61166: PUSH
61167: EMPTY
61168: LIST
61169: LIST
61170: PUSH
61171: LD_INT 1
61173: PUSH
61174: LD_INT 0
61176: PUSH
61177: EMPTY
61178: LIST
61179: LIST
61180: PUSH
61181: LD_INT 1
61183: PUSH
61184: LD_INT 1
61186: PUSH
61187: EMPTY
61188: LIST
61189: LIST
61190: PUSH
61191: LD_INT 0
61193: PUSH
61194: LD_INT 1
61196: PUSH
61197: EMPTY
61198: LIST
61199: LIST
61200: PUSH
61201: LD_INT 1
61203: NEG
61204: PUSH
61205: LD_INT 0
61207: PUSH
61208: EMPTY
61209: LIST
61210: LIST
61211: PUSH
61212: LD_INT 1
61214: NEG
61215: PUSH
61216: LD_INT 1
61218: NEG
61219: PUSH
61220: EMPTY
61221: LIST
61222: LIST
61223: PUSH
61224: LD_INT 1
61226: PUSH
61227: LD_INT 1
61229: NEG
61230: PUSH
61231: EMPTY
61232: LIST
61233: LIST
61234: PUSH
61235: LD_INT 2
61237: PUSH
61238: LD_INT 0
61240: PUSH
61241: EMPTY
61242: LIST
61243: LIST
61244: PUSH
61245: LD_INT 2
61247: PUSH
61248: LD_INT 1
61250: PUSH
61251: EMPTY
61252: LIST
61253: LIST
61254: PUSH
61255: LD_INT 1
61257: NEG
61258: PUSH
61259: LD_INT 1
61261: PUSH
61262: EMPTY
61263: LIST
61264: LIST
61265: PUSH
61266: LD_INT 2
61268: NEG
61269: PUSH
61270: LD_INT 0
61272: PUSH
61273: EMPTY
61274: LIST
61275: LIST
61276: PUSH
61277: LD_INT 2
61279: NEG
61280: PUSH
61281: LD_INT 1
61283: NEG
61284: PUSH
61285: EMPTY
61286: LIST
61287: LIST
61288: PUSH
61289: LD_INT 2
61291: NEG
61292: PUSH
61293: LD_INT 1
61295: PUSH
61296: EMPTY
61297: LIST
61298: LIST
61299: PUSH
61300: LD_INT 3
61302: NEG
61303: PUSH
61304: LD_INT 0
61306: PUSH
61307: EMPTY
61308: LIST
61309: LIST
61310: PUSH
61311: LD_INT 3
61313: NEG
61314: PUSH
61315: LD_INT 1
61317: NEG
61318: PUSH
61319: EMPTY
61320: LIST
61321: LIST
61322: PUSH
61323: EMPTY
61324: LIST
61325: LIST
61326: LIST
61327: LIST
61328: LIST
61329: LIST
61330: LIST
61331: LIST
61332: LIST
61333: LIST
61334: LIST
61335: LIST
61336: LIST
61337: LIST
61338: LIST
61339: LIST
61340: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
61341: LD_ADDR_VAR 0 13
61345: PUSH
61346: LD_INT 0
61348: PUSH
61349: LD_INT 0
61351: PUSH
61352: EMPTY
61353: LIST
61354: LIST
61355: PUSH
61356: LD_INT 0
61358: PUSH
61359: LD_INT 1
61361: NEG
61362: PUSH
61363: EMPTY
61364: LIST
61365: LIST
61366: PUSH
61367: LD_INT 1
61369: PUSH
61370: LD_INT 0
61372: PUSH
61373: EMPTY
61374: LIST
61375: LIST
61376: PUSH
61377: LD_INT 1
61379: PUSH
61380: LD_INT 1
61382: PUSH
61383: EMPTY
61384: LIST
61385: LIST
61386: PUSH
61387: LD_INT 0
61389: PUSH
61390: LD_INT 1
61392: PUSH
61393: EMPTY
61394: LIST
61395: LIST
61396: PUSH
61397: LD_INT 1
61399: NEG
61400: PUSH
61401: LD_INT 0
61403: PUSH
61404: EMPTY
61405: LIST
61406: LIST
61407: PUSH
61408: LD_INT 1
61410: NEG
61411: PUSH
61412: LD_INT 1
61414: NEG
61415: PUSH
61416: EMPTY
61417: LIST
61418: LIST
61419: PUSH
61420: LD_INT 1
61422: NEG
61423: PUSH
61424: LD_INT 2
61426: NEG
61427: PUSH
61428: EMPTY
61429: LIST
61430: LIST
61431: PUSH
61432: LD_INT 2
61434: PUSH
61435: LD_INT 1
61437: PUSH
61438: EMPTY
61439: LIST
61440: LIST
61441: PUSH
61442: LD_INT 2
61444: PUSH
61445: LD_INT 2
61447: PUSH
61448: EMPTY
61449: LIST
61450: LIST
61451: PUSH
61452: LD_INT 1
61454: PUSH
61455: LD_INT 2
61457: PUSH
61458: EMPTY
61459: LIST
61460: LIST
61461: PUSH
61462: LD_INT 2
61464: NEG
61465: PUSH
61466: LD_INT 1
61468: NEG
61469: PUSH
61470: EMPTY
61471: LIST
61472: LIST
61473: PUSH
61474: LD_INT 2
61476: NEG
61477: PUSH
61478: LD_INT 2
61480: NEG
61481: PUSH
61482: EMPTY
61483: LIST
61484: LIST
61485: PUSH
61486: LD_INT 2
61488: NEG
61489: PUSH
61490: LD_INT 3
61492: NEG
61493: PUSH
61494: EMPTY
61495: LIST
61496: LIST
61497: PUSH
61498: LD_INT 3
61500: NEG
61501: PUSH
61502: LD_INT 2
61504: NEG
61505: PUSH
61506: EMPTY
61507: LIST
61508: LIST
61509: PUSH
61510: LD_INT 3
61512: NEG
61513: PUSH
61514: LD_INT 3
61516: NEG
61517: PUSH
61518: EMPTY
61519: LIST
61520: LIST
61521: PUSH
61522: EMPTY
61523: LIST
61524: LIST
61525: LIST
61526: LIST
61527: LIST
61528: LIST
61529: LIST
61530: LIST
61531: LIST
61532: LIST
61533: LIST
61534: LIST
61535: LIST
61536: LIST
61537: LIST
61538: LIST
61539: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
61540: LD_ADDR_VAR 0 14
61544: PUSH
61545: LD_INT 0
61547: PUSH
61548: LD_INT 0
61550: PUSH
61551: EMPTY
61552: LIST
61553: LIST
61554: PUSH
61555: LD_INT 0
61557: PUSH
61558: LD_INT 1
61560: NEG
61561: PUSH
61562: EMPTY
61563: LIST
61564: LIST
61565: PUSH
61566: LD_INT 1
61568: PUSH
61569: LD_INT 0
61571: PUSH
61572: EMPTY
61573: LIST
61574: LIST
61575: PUSH
61576: LD_INT 1
61578: PUSH
61579: LD_INT 1
61581: PUSH
61582: EMPTY
61583: LIST
61584: LIST
61585: PUSH
61586: LD_INT 0
61588: PUSH
61589: LD_INT 1
61591: PUSH
61592: EMPTY
61593: LIST
61594: LIST
61595: PUSH
61596: LD_INT 1
61598: NEG
61599: PUSH
61600: LD_INT 0
61602: PUSH
61603: EMPTY
61604: LIST
61605: LIST
61606: PUSH
61607: LD_INT 1
61609: NEG
61610: PUSH
61611: LD_INT 1
61613: NEG
61614: PUSH
61615: EMPTY
61616: LIST
61617: LIST
61618: PUSH
61619: LD_INT 1
61621: NEG
61622: PUSH
61623: LD_INT 2
61625: NEG
61626: PUSH
61627: EMPTY
61628: LIST
61629: LIST
61630: PUSH
61631: LD_INT 0
61633: PUSH
61634: LD_INT 2
61636: NEG
61637: PUSH
61638: EMPTY
61639: LIST
61640: LIST
61641: PUSH
61642: LD_INT 1
61644: PUSH
61645: LD_INT 1
61647: NEG
61648: PUSH
61649: EMPTY
61650: LIST
61651: LIST
61652: PUSH
61653: LD_INT 1
61655: PUSH
61656: LD_INT 2
61658: PUSH
61659: EMPTY
61660: LIST
61661: LIST
61662: PUSH
61663: LD_INT 0
61665: PUSH
61666: LD_INT 2
61668: PUSH
61669: EMPTY
61670: LIST
61671: LIST
61672: PUSH
61673: LD_INT 1
61675: NEG
61676: PUSH
61677: LD_INT 1
61679: PUSH
61680: EMPTY
61681: LIST
61682: LIST
61683: PUSH
61684: LD_INT 1
61686: NEG
61687: PUSH
61688: LD_INT 3
61690: NEG
61691: PUSH
61692: EMPTY
61693: LIST
61694: LIST
61695: PUSH
61696: LD_INT 0
61698: PUSH
61699: LD_INT 3
61701: NEG
61702: PUSH
61703: EMPTY
61704: LIST
61705: LIST
61706: PUSH
61707: LD_INT 1
61709: PUSH
61710: LD_INT 2
61712: NEG
61713: PUSH
61714: EMPTY
61715: LIST
61716: LIST
61717: PUSH
61718: EMPTY
61719: LIST
61720: LIST
61721: LIST
61722: LIST
61723: LIST
61724: LIST
61725: LIST
61726: LIST
61727: LIST
61728: LIST
61729: LIST
61730: LIST
61731: LIST
61732: LIST
61733: LIST
61734: LIST
61735: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
61736: LD_ADDR_VAR 0 15
61740: PUSH
61741: LD_INT 0
61743: PUSH
61744: LD_INT 0
61746: PUSH
61747: EMPTY
61748: LIST
61749: LIST
61750: PUSH
61751: LD_INT 0
61753: PUSH
61754: LD_INT 1
61756: NEG
61757: PUSH
61758: EMPTY
61759: LIST
61760: LIST
61761: PUSH
61762: LD_INT 1
61764: PUSH
61765: LD_INT 0
61767: PUSH
61768: EMPTY
61769: LIST
61770: LIST
61771: PUSH
61772: LD_INT 1
61774: PUSH
61775: LD_INT 1
61777: PUSH
61778: EMPTY
61779: LIST
61780: LIST
61781: PUSH
61782: LD_INT 0
61784: PUSH
61785: LD_INT 1
61787: PUSH
61788: EMPTY
61789: LIST
61790: LIST
61791: PUSH
61792: LD_INT 1
61794: NEG
61795: PUSH
61796: LD_INT 0
61798: PUSH
61799: EMPTY
61800: LIST
61801: LIST
61802: PUSH
61803: LD_INT 1
61805: NEG
61806: PUSH
61807: LD_INT 1
61809: NEG
61810: PUSH
61811: EMPTY
61812: LIST
61813: LIST
61814: PUSH
61815: LD_INT 1
61817: PUSH
61818: LD_INT 1
61820: NEG
61821: PUSH
61822: EMPTY
61823: LIST
61824: LIST
61825: PUSH
61826: LD_INT 2
61828: PUSH
61829: LD_INT 0
61831: PUSH
61832: EMPTY
61833: LIST
61834: LIST
61835: PUSH
61836: LD_INT 2
61838: PUSH
61839: LD_INT 1
61841: PUSH
61842: EMPTY
61843: LIST
61844: LIST
61845: PUSH
61846: LD_INT 1
61848: NEG
61849: PUSH
61850: LD_INT 1
61852: PUSH
61853: EMPTY
61854: LIST
61855: LIST
61856: PUSH
61857: LD_INT 2
61859: NEG
61860: PUSH
61861: LD_INT 0
61863: PUSH
61864: EMPTY
61865: LIST
61866: LIST
61867: PUSH
61868: LD_INT 2
61870: NEG
61871: PUSH
61872: LD_INT 1
61874: NEG
61875: PUSH
61876: EMPTY
61877: LIST
61878: LIST
61879: PUSH
61880: LD_INT 2
61882: PUSH
61883: LD_INT 1
61885: NEG
61886: PUSH
61887: EMPTY
61888: LIST
61889: LIST
61890: PUSH
61891: LD_INT 3
61893: PUSH
61894: LD_INT 0
61896: PUSH
61897: EMPTY
61898: LIST
61899: LIST
61900: PUSH
61901: LD_INT 3
61903: PUSH
61904: LD_INT 1
61906: PUSH
61907: EMPTY
61908: LIST
61909: LIST
61910: PUSH
61911: EMPTY
61912: LIST
61913: LIST
61914: LIST
61915: LIST
61916: LIST
61917: LIST
61918: LIST
61919: LIST
61920: LIST
61921: LIST
61922: LIST
61923: LIST
61924: LIST
61925: LIST
61926: LIST
61927: LIST
61928: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
61929: LD_ADDR_VAR 0 16
61933: PUSH
61934: LD_INT 0
61936: PUSH
61937: LD_INT 0
61939: PUSH
61940: EMPTY
61941: LIST
61942: LIST
61943: PUSH
61944: LD_INT 0
61946: PUSH
61947: LD_INT 1
61949: NEG
61950: PUSH
61951: EMPTY
61952: LIST
61953: LIST
61954: PUSH
61955: LD_INT 1
61957: PUSH
61958: LD_INT 0
61960: PUSH
61961: EMPTY
61962: LIST
61963: LIST
61964: PUSH
61965: LD_INT 1
61967: PUSH
61968: LD_INT 1
61970: PUSH
61971: EMPTY
61972: LIST
61973: LIST
61974: PUSH
61975: LD_INT 0
61977: PUSH
61978: LD_INT 1
61980: PUSH
61981: EMPTY
61982: LIST
61983: LIST
61984: PUSH
61985: LD_INT 1
61987: NEG
61988: PUSH
61989: LD_INT 0
61991: PUSH
61992: EMPTY
61993: LIST
61994: LIST
61995: PUSH
61996: LD_INT 1
61998: NEG
61999: PUSH
62000: LD_INT 1
62002: NEG
62003: PUSH
62004: EMPTY
62005: LIST
62006: LIST
62007: PUSH
62008: LD_INT 1
62010: NEG
62011: PUSH
62012: LD_INT 2
62014: NEG
62015: PUSH
62016: EMPTY
62017: LIST
62018: LIST
62019: PUSH
62020: LD_INT 2
62022: PUSH
62023: LD_INT 1
62025: PUSH
62026: EMPTY
62027: LIST
62028: LIST
62029: PUSH
62030: LD_INT 2
62032: PUSH
62033: LD_INT 2
62035: PUSH
62036: EMPTY
62037: LIST
62038: LIST
62039: PUSH
62040: LD_INT 1
62042: PUSH
62043: LD_INT 2
62045: PUSH
62046: EMPTY
62047: LIST
62048: LIST
62049: PUSH
62050: LD_INT 2
62052: NEG
62053: PUSH
62054: LD_INT 1
62056: NEG
62057: PUSH
62058: EMPTY
62059: LIST
62060: LIST
62061: PUSH
62062: LD_INT 2
62064: NEG
62065: PUSH
62066: LD_INT 2
62068: NEG
62069: PUSH
62070: EMPTY
62071: LIST
62072: LIST
62073: PUSH
62074: LD_INT 3
62076: PUSH
62077: LD_INT 2
62079: PUSH
62080: EMPTY
62081: LIST
62082: LIST
62083: PUSH
62084: LD_INT 3
62086: PUSH
62087: LD_INT 3
62089: PUSH
62090: EMPTY
62091: LIST
62092: LIST
62093: PUSH
62094: LD_INT 2
62096: PUSH
62097: LD_INT 3
62099: PUSH
62100: EMPTY
62101: LIST
62102: LIST
62103: PUSH
62104: EMPTY
62105: LIST
62106: LIST
62107: LIST
62108: LIST
62109: LIST
62110: LIST
62111: LIST
62112: LIST
62113: LIST
62114: LIST
62115: LIST
62116: LIST
62117: LIST
62118: LIST
62119: LIST
62120: LIST
62121: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62122: LD_ADDR_VAR 0 17
62126: PUSH
62127: LD_INT 0
62129: PUSH
62130: LD_INT 0
62132: PUSH
62133: EMPTY
62134: LIST
62135: LIST
62136: PUSH
62137: LD_INT 0
62139: PUSH
62140: LD_INT 1
62142: NEG
62143: PUSH
62144: EMPTY
62145: LIST
62146: LIST
62147: PUSH
62148: LD_INT 1
62150: PUSH
62151: LD_INT 0
62153: PUSH
62154: EMPTY
62155: LIST
62156: LIST
62157: PUSH
62158: LD_INT 1
62160: PUSH
62161: LD_INT 1
62163: PUSH
62164: EMPTY
62165: LIST
62166: LIST
62167: PUSH
62168: LD_INT 0
62170: PUSH
62171: LD_INT 1
62173: PUSH
62174: EMPTY
62175: LIST
62176: LIST
62177: PUSH
62178: LD_INT 1
62180: NEG
62181: PUSH
62182: LD_INT 0
62184: PUSH
62185: EMPTY
62186: LIST
62187: LIST
62188: PUSH
62189: LD_INT 1
62191: NEG
62192: PUSH
62193: LD_INT 1
62195: NEG
62196: PUSH
62197: EMPTY
62198: LIST
62199: LIST
62200: PUSH
62201: LD_INT 1
62203: NEG
62204: PUSH
62205: LD_INT 2
62207: NEG
62208: PUSH
62209: EMPTY
62210: LIST
62211: LIST
62212: PUSH
62213: LD_INT 0
62215: PUSH
62216: LD_INT 2
62218: NEG
62219: PUSH
62220: EMPTY
62221: LIST
62222: LIST
62223: PUSH
62224: LD_INT 1
62226: PUSH
62227: LD_INT 1
62229: NEG
62230: PUSH
62231: EMPTY
62232: LIST
62233: LIST
62234: PUSH
62235: LD_INT 2
62237: PUSH
62238: LD_INT 0
62240: PUSH
62241: EMPTY
62242: LIST
62243: LIST
62244: PUSH
62245: LD_INT 2
62247: PUSH
62248: LD_INT 1
62250: PUSH
62251: EMPTY
62252: LIST
62253: LIST
62254: PUSH
62255: LD_INT 2
62257: PUSH
62258: LD_INT 2
62260: PUSH
62261: EMPTY
62262: LIST
62263: LIST
62264: PUSH
62265: LD_INT 1
62267: PUSH
62268: LD_INT 2
62270: PUSH
62271: EMPTY
62272: LIST
62273: LIST
62274: PUSH
62275: LD_INT 0
62277: PUSH
62278: LD_INT 2
62280: PUSH
62281: EMPTY
62282: LIST
62283: LIST
62284: PUSH
62285: LD_INT 1
62287: NEG
62288: PUSH
62289: LD_INT 1
62291: PUSH
62292: EMPTY
62293: LIST
62294: LIST
62295: PUSH
62296: LD_INT 2
62298: NEG
62299: PUSH
62300: LD_INT 0
62302: PUSH
62303: EMPTY
62304: LIST
62305: LIST
62306: PUSH
62307: LD_INT 2
62309: NEG
62310: PUSH
62311: LD_INT 1
62313: NEG
62314: PUSH
62315: EMPTY
62316: LIST
62317: LIST
62318: PUSH
62319: LD_INT 2
62321: NEG
62322: PUSH
62323: LD_INT 2
62325: NEG
62326: PUSH
62327: EMPTY
62328: LIST
62329: LIST
62330: PUSH
62331: EMPTY
62332: LIST
62333: LIST
62334: LIST
62335: LIST
62336: LIST
62337: LIST
62338: LIST
62339: LIST
62340: LIST
62341: LIST
62342: LIST
62343: LIST
62344: LIST
62345: LIST
62346: LIST
62347: LIST
62348: LIST
62349: LIST
62350: LIST
62351: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62352: LD_ADDR_VAR 0 18
62356: PUSH
62357: LD_INT 0
62359: PUSH
62360: LD_INT 0
62362: PUSH
62363: EMPTY
62364: LIST
62365: LIST
62366: PUSH
62367: LD_INT 0
62369: PUSH
62370: LD_INT 1
62372: NEG
62373: PUSH
62374: EMPTY
62375: LIST
62376: LIST
62377: PUSH
62378: LD_INT 1
62380: PUSH
62381: LD_INT 0
62383: PUSH
62384: EMPTY
62385: LIST
62386: LIST
62387: PUSH
62388: LD_INT 1
62390: PUSH
62391: LD_INT 1
62393: PUSH
62394: EMPTY
62395: LIST
62396: LIST
62397: PUSH
62398: LD_INT 0
62400: PUSH
62401: LD_INT 1
62403: PUSH
62404: EMPTY
62405: LIST
62406: LIST
62407: PUSH
62408: LD_INT 1
62410: NEG
62411: PUSH
62412: LD_INT 0
62414: PUSH
62415: EMPTY
62416: LIST
62417: LIST
62418: PUSH
62419: LD_INT 1
62421: NEG
62422: PUSH
62423: LD_INT 1
62425: NEG
62426: PUSH
62427: EMPTY
62428: LIST
62429: LIST
62430: PUSH
62431: LD_INT 1
62433: NEG
62434: PUSH
62435: LD_INT 2
62437: NEG
62438: PUSH
62439: EMPTY
62440: LIST
62441: LIST
62442: PUSH
62443: LD_INT 0
62445: PUSH
62446: LD_INT 2
62448: NEG
62449: PUSH
62450: EMPTY
62451: LIST
62452: LIST
62453: PUSH
62454: LD_INT 1
62456: PUSH
62457: LD_INT 1
62459: NEG
62460: PUSH
62461: EMPTY
62462: LIST
62463: LIST
62464: PUSH
62465: LD_INT 2
62467: PUSH
62468: LD_INT 0
62470: PUSH
62471: EMPTY
62472: LIST
62473: LIST
62474: PUSH
62475: LD_INT 2
62477: PUSH
62478: LD_INT 1
62480: PUSH
62481: EMPTY
62482: LIST
62483: LIST
62484: PUSH
62485: LD_INT 2
62487: PUSH
62488: LD_INT 2
62490: PUSH
62491: EMPTY
62492: LIST
62493: LIST
62494: PUSH
62495: LD_INT 1
62497: PUSH
62498: LD_INT 2
62500: PUSH
62501: EMPTY
62502: LIST
62503: LIST
62504: PUSH
62505: LD_INT 0
62507: PUSH
62508: LD_INT 2
62510: PUSH
62511: EMPTY
62512: LIST
62513: LIST
62514: PUSH
62515: LD_INT 1
62517: NEG
62518: PUSH
62519: LD_INT 1
62521: PUSH
62522: EMPTY
62523: LIST
62524: LIST
62525: PUSH
62526: LD_INT 2
62528: NEG
62529: PUSH
62530: LD_INT 0
62532: PUSH
62533: EMPTY
62534: LIST
62535: LIST
62536: PUSH
62537: LD_INT 2
62539: NEG
62540: PUSH
62541: LD_INT 1
62543: NEG
62544: PUSH
62545: EMPTY
62546: LIST
62547: LIST
62548: PUSH
62549: LD_INT 2
62551: NEG
62552: PUSH
62553: LD_INT 2
62555: NEG
62556: PUSH
62557: EMPTY
62558: LIST
62559: LIST
62560: PUSH
62561: EMPTY
62562: LIST
62563: LIST
62564: LIST
62565: LIST
62566: LIST
62567: LIST
62568: LIST
62569: LIST
62570: LIST
62571: LIST
62572: LIST
62573: LIST
62574: LIST
62575: LIST
62576: LIST
62577: LIST
62578: LIST
62579: LIST
62580: LIST
62581: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62582: LD_ADDR_VAR 0 19
62586: PUSH
62587: LD_INT 0
62589: PUSH
62590: LD_INT 0
62592: PUSH
62593: EMPTY
62594: LIST
62595: LIST
62596: PUSH
62597: LD_INT 0
62599: PUSH
62600: LD_INT 1
62602: NEG
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: PUSH
62608: LD_INT 1
62610: PUSH
62611: LD_INT 0
62613: PUSH
62614: EMPTY
62615: LIST
62616: LIST
62617: PUSH
62618: LD_INT 1
62620: PUSH
62621: LD_INT 1
62623: PUSH
62624: EMPTY
62625: LIST
62626: LIST
62627: PUSH
62628: LD_INT 0
62630: PUSH
62631: LD_INT 1
62633: PUSH
62634: EMPTY
62635: LIST
62636: LIST
62637: PUSH
62638: LD_INT 1
62640: NEG
62641: PUSH
62642: LD_INT 0
62644: PUSH
62645: EMPTY
62646: LIST
62647: LIST
62648: PUSH
62649: LD_INT 1
62651: NEG
62652: PUSH
62653: LD_INT 1
62655: NEG
62656: PUSH
62657: EMPTY
62658: LIST
62659: LIST
62660: PUSH
62661: LD_INT 1
62663: NEG
62664: PUSH
62665: LD_INT 2
62667: NEG
62668: PUSH
62669: EMPTY
62670: LIST
62671: LIST
62672: PUSH
62673: LD_INT 0
62675: PUSH
62676: LD_INT 2
62678: NEG
62679: PUSH
62680: EMPTY
62681: LIST
62682: LIST
62683: PUSH
62684: LD_INT 1
62686: PUSH
62687: LD_INT 1
62689: NEG
62690: PUSH
62691: EMPTY
62692: LIST
62693: LIST
62694: PUSH
62695: LD_INT 2
62697: PUSH
62698: LD_INT 0
62700: PUSH
62701: EMPTY
62702: LIST
62703: LIST
62704: PUSH
62705: LD_INT 2
62707: PUSH
62708: LD_INT 1
62710: PUSH
62711: EMPTY
62712: LIST
62713: LIST
62714: PUSH
62715: LD_INT 2
62717: PUSH
62718: LD_INT 2
62720: PUSH
62721: EMPTY
62722: LIST
62723: LIST
62724: PUSH
62725: LD_INT 1
62727: PUSH
62728: LD_INT 2
62730: PUSH
62731: EMPTY
62732: LIST
62733: LIST
62734: PUSH
62735: LD_INT 0
62737: PUSH
62738: LD_INT 2
62740: PUSH
62741: EMPTY
62742: LIST
62743: LIST
62744: PUSH
62745: LD_INT 1
62747: NEG
62748: PUSH
62749: LD_INT 1
62751: PUSH
62752: EMPTY
62753: LIST
62754: LIST
62755: PUSH
62756: LD_INT 2
62758: NEG
62759: PUSH
62760: LD_INT 0
62762: PUSH
62763: EMPTY
62764: LIST
62765: LIST
62766: PUSH
62767: LD_INT 2
62769: NEG
62770: PUSH
62771: LD_INT 1
62773: NEG
62774: PUSH
62775: EMPTY
62776: LIST
62777: LIST
62778: PUSH
62779: LD_INT 2
62781: NEG
62782: PUSH
62783: LD_INT 2
62785: NEG
62786: PUSH
62787: EMPTY
62788: LIST
62789: LIST
62790: PUSH
62791: EMPTY
62792: LIST
62793: LIST
62794: LIST
62795: LIST
62796: LIST
62797: LIST
62798: LIST
62799: LIST
62800: LIST
62801: LIST
62802: LIST
62803: LIST
62804: LIST
62805: LIST
62806: LIST
62807: LIST
62808: LIST
62809: LIST
62810: LIST
62811: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62812: LD_ADDR_VAR 0 20
62816: PUSH
62817: LD_INT 0
62819: PUSH
62820: LD_INT 0
62822: PUSH
62823: EMPTY
62824: LIST
62825: LIST
62826: PUSH
62827: LD_INT 0
62829: PUSH
62830: LD_INT 1
62832: NEG
62833: PUSH
62834: EMPTY
62835: LIST
62836: LIST
62837: PUSH
62838: LD_INT 1
62840: PUSH
62841: LD_INT 0
62843: PUSH
62844: EMPTY
62845: LIST
62846: LIST
62847: PUSH
62848: LD_INT 1
62850: PUSH
62851: LD_INT 1
62853: PUSH
62854: EMPTY
62855: LIST
62856: LIST
62857: PUSH
62858: LD_INT 0
62860: PUSH
62861: LD_INT 1
62863: PUSH
62864: EMPTY
62865: LIST
62866: LIST
62867: PUSH
62868: LD_INT 1
62870: NEG
62871: PUSH
62872: LD_INT 0
62874: PUSH
62875: EMPTY
62876: LIST
62877: LIST
62878: PUSH
62879: LD_INT 1
62881: NEG
62882: PUSH
62883: LD_INT 1
62885: NEG
62886: PUSH
62887: EMPTY
62888: LIST
62889: LIST
62890: PUSH
62891: LD_INT 1
62893: NEG
62894: PUSH
62895: LD_INT 2
62897: NEG
62898: PUSH
62899: EMPTY
62900: LIST
62901: LIST
62902: PUSH
62903: LD_INT 0
62905: PUSH
62906: LD_INT 2
62908: NEG
62909: PUSH
62910: EMPTY
62911: LIST
62912: LIST
62913: PUSH
62914: LD_INT 1
62916: PUSH
62917: LD_INT 1
62919: NEG
62920: PUSH
62921: EMPTY
62922: LIST
62923: LIST
62924: PUSH
62925: LD_INT 2
62927: PUSH
62928: LD_INT 0
62930: PUSH
62931: EMPTY
62932: LIST
62933: LIST
62934: PUSH
62935: LD_INT 2
62937: PUSH
62938: LD_INT 1
62940: PUSH
62941: EMPTY
62942: LIST
62943: LIST
62944: PUSH
62945: LD_INT 2
62947: PUSH
62948: LD_INT 2
62950: PUSH
62951: EMPTY
62952: LIST
62953: LIST
62954: PUSH
62955: LD_INT 1
62957: PUSH
62958: LD_INT 2
62960: PUSH
62961: EMPTY
62962: LIST
62963: LIST
62964: PUSH
62965: LD_INT 0
62967: PUSH
62968: LD_INT 2
62970: PUSH
62971: EMPTY
62972: LIST
62973: LIST
62974: PUSH
62975: LD_INT 1
62977: NEG
62978: PUSH
62979: LD_INT 1
62981: PUSH
62982: EMPTY
62983: LIST
62984: LIST
62985: PUSH
62986: LD_INT 2
62988: NEG
62989: PUSH
62990: LD_INT 0
62992: PUSH
62993: EMPTY
62994: LIST
62995: LIST
62996: PUSH
62997: LD_INT 2
62999: NEG
63000: PUSH
63001: LD_INT 1
63003: NEG
63004: PUSH
63005: EMPTY
63006: LIST
63007: LIST
63008: PUSH
63009: LD_INT 2
63011: NEG
63012: PUSH
63013: LD_INT 2
63015: NEG
63016: PUSH
63017: EMPTY
63018: LIST
63019: LIST
63020: PUSH
63021: EMPTY
63022: LIST
63023: LIST
63024: LIST
63025: LIST
63026: LIST
63027: LIST
63028: LIST
63029: LIST
63030: LIST
63031: LIST
63032: LIST
63033: LIST
63034: LIST
63035: LIST
63036: LIST
63037: LIST
63038: LIST
63039: LIST
63040: LIST
63041: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63042: LD_ADDR_VAR 0 21
63046: PUSH
63047: LD_INT 0
63049: PUSH
63050: LD_INT 0
63052: PUSH
63053: EMPTY
63054: LIST
63055: LIST
63056: PUSH
63057: LD_INT 0
63059: PUSH
63060: LD_INT 1
63062: NEG
63063: PUSH
63064: EMPTY
63065: LIST
63066: LIST
63067: PUSH
63068: LD_INT 1
63070: PUSH
63071: LD_INT 0
63073: PUSH
63074: EMPTY
63075: LIST
63076: LIST
63077: PUSH
63078: LD_INT 1
63080: PUSH
63081: LD_INT 1
63083: PUSH
63084: EMPTY
63085: LIST
63086: LIST
63087: PUSH
63088: LD_INT 0
63090: PUSH
63091: LD_INT 1
63093: PUSH
63094: EMPTY
63095: LIST
63096: LIST
63097: PUSH
63098: LD_INT 1
63100: NEG
63101: PUSH
63102: LD_INT 0
63104: PUSH
63105: EMPTY
63106: LIST
63107: LIST
63108: PUSH
63109: LD_INT 1
63111: NEG
63112: PUSH
63113: LD_INT 1
63115: NEG
63116: PUSH
63117: EMPTY
63118: LIST
63119: LIST
63120: PUSH
63121: LD_INT 1
63123: NEG
63124: PUSH
63125: LD_INT 2
63127: NEG
63128: PUSH
63129: EMPTY
63130: LIST
63131: LIST
63132: PUSH
63133: LD_INT 0
63135: PUSH
63136: LD_INT 2
63138: NEG
63139: PUSH
63140: EMPTY
63141: LIST
63142: LIST
63143: PUSH
63144: LD_INT 1
63146: PUSH
63147: LD_INT 1
63149: NEG
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: PUSH
63155: LD_INT 2
63157: PUSH
63158: LD_INT 0
63160: PUSH
63161: EMPTY
63162: LIST
63163: LIST
63164: PUSH
63165: LD_INT 2
63167: PUSH
63168: LD_INT 1
63170: PUSH
63171: EMPTY
63172: LIST
63173: LIST
63174: PUSH
63175: LD_INT 2
63177: PUSH
63178: LD_INT 2
63180: PUSH
63181: EMPTY
63182: LIST
63183: LIST
63184: PUSH
63185: LD_INT 1
63187: PUSH
63188: LD_INT 2
63190: PUSH
63191: EMPTY
63192: LIST
63193: LIST
63194: PUSH
63195: LD_INT 0
63197: PUSH
63198: LD_INT 2
63200: PUSH
63201: EMPTY
63202: LIST
63203: LIST
63204: PUSH
63205: LD_INT 1
63207: NEG
63208: PUSH
63209: LD_INT 1
63211: PUSH
63212: EMPTY
63213: LIST
63214: LIST
63215: PUSH
63216: LD_INT 2
63218: NEG
63219: PUSH
63220: LD_INT 0
63222: PUSH
63223: EMPTY
63224: LIST
63225: LIST
63226: PUSH
63227: LD_INT 2
63229: NEG
63230: PUSH
63231: LD_INT 1
63233: NEG
63234: PUSH
63235: EMPTY
63236: LIST
63237: LIST
63238: PUSH
63239: LD_INT 2
63241: NEG
63242: PUSH
63243: LD_INT 2
63245: NEG
63246: PUSH
63247: EMPTY
63248: LIST
63249: LIST
63250: PUSH
63251: EMPTY
63252: LIST
63253: LIST
63254: LIST
63255: LIST
63256: LIST
63257: LIST
63258: LIST
63259: LIST
63260: LIST
63261: LIST
63262: LIST
63263: LIST
63264: LIST
63265: LIST
63266: LIST
63267: LIST
63268: LIST
63269: LIST
63270: LIST
63271: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63272: LD_ADDR_VAR 0 22
63276: PUSH
63277: LD_INT 0
63279: PUSH
63280: LD_INT 0
63282: PUSH
63283: EMPTY
63284: LIST
63285: LIST
63286: PUSH
63287: LD_INT 0
63289: PUSH
63290: LD_INT 1
63292: NEG
63293: PUSH
63294: EMPTY
63295: LIST
63296: LIST
63297: PUSH
63298: LD_INT 1
63300: PUSH
63301: LD_INT 0
63303: PUSH
63304: EMPTY
63305: LIST
63306: LIST
63307: PUSH
63308: LD_INT 1
63310: PUSH
63311: LD_INT 1
63313: PUSH
63314: EMPTY
63315: LIST
63316: LIST
63317: PUSH
63318: LD_INT 0
63320: PUSH
63321: LD_INT 1
63323: PUSH
63324: EMPTY
63325: LIST
63326: LIST
63327: PUSH
63328: LD_INT 1
63330: NEG
63331: PUSH
63332: LD_INT 0
63334: PUSH
63335: EMPTY
63336: LIST
63337: LIST
63338: PUSH
63339: LD_INT 1
63341: NEG
63342: PUSH
63343: LD_INT 1
63345: NEG
63346: PUSH
63347: EMPTY
63348: LIST
63349: LIST
63350: PUSH
63351: LD_INT 1
63353: NEG
63354: PUSH
63355: LD_INT 2
63357: NEG
63358: PUSH
63359: EMPTY
63360: LIST
63361: LIST
63362: PUSH
63363: LD_INT 0
63365: PUSH
63366: LD_INT 2
63368: NEG
63369: PUSH
63370: EMPTY
63371: LIST
63372: LIST
63373: PUSH
63374: LD_INT 1
63376: PUSH
63377: LD_INT 1
63379: NEG
63380: PUSH
63381: EMPTY
63382: LIST
63383: LIST
63384: PUSH
63385: LD_INT 2
63387: PUSH
63388: LD_INT 0
63390: PUSH
63391: EMPTY
63392: LIST
63393: LIST
63394: PUSH
63395: LD_INT 2
63397: PUSH
63398: LD_INT 1
63400: PUSH
63401: EMPTY
63402: LIST
63403: LIST
63404: PUSH
63405: LD_INT 2
63407: PUSH
63408: LD_INT 2
63410: PUSH
63411: EMPTY
63412: LIST
63413: LIST
63414: PUSH
63415: LD_INT 1
63417: PUSH
63418: LD_INT 2
63420: PUSH
63421: EMPTY
63422: LIST
63423: LIST
63424: PUSH
63425: LD_INT 0
63427: PUSH
63428: LD_INT 2
63430: PUSH
63431: EMPTY
63432: LIST
63433: LIST
63434: PUSH
63435: LD_INT 1
63437: NEG
63438: PUSH
63439: LD_INT 1
63441: PUSH
63442: EMPTY
63443: LIST
63444: LIST
63445: PUSH
63446: LD_INT 2
63448: NEG
63449: PUSH
63450: LD_INT 0
63452: PUSH
63453: EMPTY
63454: LIST
63455: LIST
63456: PUSH
63457: LD_INT 2
63459: NEG
63460: PUSH
63461: LD_INT 1
63463: NEG
63464: PUSH
63465: EMPTY
63466: LIST
63467: LIST
63468: PUSH
63469: LD_INT 2
63471: NEG
63472: PUSH
63473: LD_INT 2
63475: NEG
63476: PUSH
63477: EMPTY
63478: LIST
63479: LIST
63480: PUSH
63481: EMPTY
63482: LIST
63483: LIST
63484: LIST
63485: LIST
63486: LIST
63487: LIST
63488: LIST
63489: LIST
63490: LIST
63491: LIST
63492: LIST
63493: LIST
63494: LIST
63495: LIST
63496: LIST
63497: LIST
63498: LIST
63499: LIST
63500: LIST
63501: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
63502: LD_ADDR_VAR 0 23
63506: PUSH
63507: LD_INT 0
63509: PUSH
63510: LD_INT 0
63512: PUSH
63513: EMPTY
63514: LIST
63515: LIST
63516: PUSH
63517: LD_INT 0
63519: PUSH
63520: LD_INT 1
63522: NEG
63523: PUSH
63524: EMPTY
63525: LIST
63526: LIST
63527: PUSH
63528: LD_INT 1
63530: PUSH
63531: LD_INT 0
63533: PUSH
63534: EMPTY
63535: LIST
63536: LIST
63537: PUSH
63538: LD_INT 1
63540: PUSH
63541: LD_INT 1
63543: PUSH
63544: EMPTY
63545: LIST
63546: LIST
63547: PUSH
63548: LD_INT 0
63550: PUSH
63551: LD_INT 1
63553: PUSH
63554: EMPTY
63555: LIST
63556: LIST
63557: PUSH
63558: LD_INT 1
63560: NEG
63561: PUSH
63562: LD_INT 0
63564: PUSH
63565: EMPTY
63566: LIST
63567: LIST
63568: PUSH
63569: LD_INT 1
63571: NEG
63572: PUSH
63573: LD_INT 1
63575: NEG
63576: PUSH
63577: EMPTY
63578: LIST
63579: LIST
63580: PUSH
63581: LD_INT 1
63583: NEG
63584: PUSH
63585: LD_INT 2
63587: NEG
63588: PUSH
63589: EMPTY
63590: LIST
63591: LIST
63592: PUSH
63593: LD_INT 0
63595: PUSH
63596: LD_INT 2
63598: NEG
63599: PUSH
63600: EMPTY
63601: LIST
63602: LIST
63603: PUSH
63604: LD_INT 1
63606: PUSH
63607: LD_INT 1
63609: NEG
63610: PUSH
63611: EMPTY
63612: LIST
63613: LIST
63614: PUSH
63615: LD_INT 2
63617: PUSH
63618: LD_INT 0
63620: PUSH
63621: EMPTY
63622: LIST
63623: LIST
63624: PUSH
63625: LD_INT 2
63627: PUSH
63628: LD_INT 1
63630: PUSH
63631: EMPTY
63632: LIST
63633: LIST
63634: PUSH
63635: LD_INT 2
63637: PUSH
63638: LD_INT 2
63640: PUSH
63641: EMPTY
63642: LIST
63643: LIST
63644: PUSH
63645: LD_INT 1
63647: PUSH
63648: LD_INT 2
63650: PUSH
63651: EMPTY
63652: LIST
63653: LIST
63654: PUSH
63655: LD_INT 0
63657: PUSH
63658: LD_INT 2
63660: PUSH
63661: EMPTY
63662: LIST
63663: LIST
63664: PUSH
63665: LD_INT 1
63667: NEG
63668: PUSH
63669: LD_INT 1
63671: PUSH
63672: EMPTY
63673: LIST
63674: LIST
63675: PUSH
63676: LD_INT 2
63678: NEG
63679: PUSH
63680: LD_INT 0
63682: PUSH
63683: EMPTY
63684: LIST
63685: LIST
63686: PUSH
63687: LD_INT 2
63689: NEG
63690: PUSH
63691: LD_INT 1
63693: NEG
63694: PUSH
63695: EMPTY
63696: LIST
63697: LIST
63698: PUSH
63699: LD_INT 2
63701: NEG
63702: PUSH
63703: LD_INT 2
63705: NEG
63706: PUSH
63707: EMPTY
63708: LIST
63709: LIST
63710: PUSH
63711: LD_INT 2
63713: NEG
63714: PUSH
63715: LD_INT 3
63717: NEG
63718: PUSH
63719: EMPTY
63720: LIST
63721: LIST
63722: PUSH
63723: LD_INT 1
63725: NEG
63726: PUSH
63727: LD_INT 3
63729: NEG
63730: PUSH
63731: EMPTY
63732: LIST
63733: LIST
63734: PUSH
63735: LD_INT 1
63737: PUSH
63738: LD_INT 2
63740: NEG
63741: PUSH
63742: EMPTY
63743: LIST
63744: LIST
63745: PUSH
63746: LD_INT 2
63748: PUSH
63749: LD_INT 1
63751: NEG
63752: PUSH
63753: EMPTY
63754: LIST
63755: LIST
63756: PUSH
63757: EMPTY
63758: LIST
63759: LIST
63760: LIST
63761: LIST
63762: LIST
63763: LIST
63764: LIST
63765: LIST
63766: LIST
63767: LIST
63768: LIST
63769: LIST
63770: LIST
63771: LIST
63772: LIST
63773: LIST
63774: LIST
63775: LIST
63776: LIST
63777: LIST
63778: LIST
63779: LIST
63780: LIST
63781: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
63782: LD_ADDR_VAR 0 24
63786: PUSH
63787: LD_INT 0
63789: PUSH
63790: LD_INT 0
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: PUSH
63797: LD_INT 0
63799: PUSH
63800: LD_INT 1
63802: NEG
63803: PUSH
63804: EMPTY
63805: LIST
63806: LIST
63807: PUSH
63808: LD_INT 1
63810: PUSH
63811: LD_INT 0
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PUSH
63818: LD_INT 1
63820: PUSH
63821: LD_INT 1
63823: PUSH
63824: EMPTY
63825: LIST
63826: LIST
63827: PUSH
63828: LD_INT 0
63830: PUSH
63831: LD_INT 1
63833: PUSH
63834: EMPTY
63835: LIST
63836: LIST
63837: PUSH
63838: LD_INT 1
63840: NEG
63841: PUSH
63842: LD_INT 0
63844: PUSH
63845: EMPTY
63846: LIST
63847: LIST
63848: PUSH
63849: LD_INT 1
63851: NEG
63852: PUSH
63853: LD_INT 1
63855: NEG
63856: PUSH
63857: EMPTY
63858: LIST
63859: LIST
63860: PUSH
63861: LD_INT 1
63863: NEG
63864: PUSH
63865: LD_INT 2
63867: NEG
63868: PUSH
63869: EMPTY
63870: LIST
63871: LIST
63872: PUSH
63873: LD_INT 0
63875: PUSH
63876: LD_INT 2
63878: NEG
63879: PUSH
63880: EMPTY
63881: LIST
63882: LIST
63883: PUSH
63884: LD_INT 1
63886: PUSH
63887: LD_INT 1
63889: NEG
63890: PUSH
63891: EMPTY
63892: LIST
63893: LIST
63894: PUSH
63895: LD_INT 2
63897: PUSH
63898: LD_INT 0
63900: PUSH
63901: EMPTY
63902: LIST
63903: LIST
63904: PUSH
63905: LD_INT 2
63907: PUSH
63908: LD_INT 1
63910: PUSH
63911: EMPTY
63912: LIST
63913: LIST
63914: PUSH
63915: LD_INT 2
63917: PUSH
63918: LD_INT 2
63920: PUSH
63921: EMPTY
63922: LIST
63923: LIST
63924: PUSH
63925: LD_INT 1
63927: PUSH
63928: LD_INT 2
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: PUSH
63935: LD_INT 0
63937: PUSH
63938: LD_INT 2
63940: PUSH
63941: EMPTY
63942: LIST
63943: LIST
63944: PUSH
63945: LD_INT 1
63947: NEG
63948: PUSH
63949: LD_INT 1
63951: PUSH
63952: EMPTY
63953: LIST
63954: LIST
63955: PUSH
63956: LD_INT 2
63958: NEG
63959: PUSH
63960: LD_INT 0
63962: PUSH
63963: EMPTY
63964: LIST
63965: LIST
63966: PUSH
63967: LD_INT 2
63969: NEG
63970: PUSH
63971: LD_INT 1
63973: NEG
63974: PUSH
63975: EMPTY
63976: LIST
63977: LIST
63978: PUSH
63979: LD_INT 2
63981: NEG
63982: PUSH
63983: LD_INT 2
63985: NEG
63986: PUSH
63987: EMPTY
63988: LIST
63989: LIST
63990: PUSH
63991: LD_INT 1
63993: PUSH
63994: LD_INT 2
63996: NEG
63997: PUSH
63998: EMPTY
63999: LIST
64000: LIST
64001: PUSH
64002: LD_INT 2
64004: PUSH
64005: LD_INT 1
64007: NEG
64008: PUSH
64009: EMPTY
64010: LIST
64011: LIST
64012: PUSH
64013: LD_INT 3
64015: PUSH
64016: LD_INT 1
64018: PUSH
64019: EMPTY
64020: LIST
64021: LIST
64022: PUSH
64023: LD_INT 3
64025: PUSH
64026: LD_INT 2
64028: PUSH
64029: EMPTY
64030: LIST
64031: LIST
64032: PUSH
64033: EMPTY
64034: LIST
64035: LIST
64036: LIST
64037: LIST
64038: LIST
64039: LIST
64040: LIST
64041: LIST
64042: LIST
64043: LIST
64044: LIST
64045: LIST
64046: LIST
64047: LIST
64048: LIST
64049: LIST
64050: LIST
64051: LIST
64052: LIST
64053: LIST
64054: LIST
64055: LIST
64056: LIST
64057: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
64058: LD_ADDR_VAR 0 25
64062: PUSH
64063: LD_INT 0
64065: PUSH
64066: LD_INT 0
64068: PUSH
64069: EMPTY
64070: LIST
64071: LIST
64072: PUSH
64073: LD_INT 0
64075: PUSH
64076: LD_INT 1
64078: NEG
64079: PUSH
64080: EMPTY
64081: LIST
64082: LIST
64083: PUSH
64084: LD_INT 1
64086: PUSH
64087: LD_INT 0
64089: PUSH
64090: EMPTY
64091: LIST
64092: LIST
64093: PUSH
64094: LD_INT 1
64096: PUSH
64097: LD_INT 1
64099: PUSH
64100: EMPTY
64101: LIST
64102: LIST
64103: PUSH
64104: LD_INT 0
64106: PUSH
64107: LD_INT 1
64109: PUSH
64110: EMPTY
64111: LIST
64112: LIST
64113: PUSH
64114: LD_INT 1
64116: NEG
64117: PUSH
64118: LD_INT 0
64120: PUSH
64121: EMPTY
64122: LIST
64123: LIST
64124: PUSH
64125: LD_INT 1
64127: NEG
64128: PUSH
64129: LD_INT 1
64131: NEG
64132: PUSH
64133: EMPTY
64134: LIST
64135: LIST
64136: PUSH
64137: LD_INT 1
64139: NEG
64140: PUSH
64141: LD_INT 2
64143: NEG
64144: PUSH
64145: EMPTY
64146: LIST
64147: LIST
64148: PUSH
64149: LD_INT 0
64151: PUSH
64152: LD_INT 2
64154: NEG
64155: PUSH
64156: EMPTY
64157: LIST
64158: LIST
64159: PUSH
64160: LD_INT 1
64162: PUSH
64163: LD_INT 1
64165: NEG
64166: PUSH
64167: EMPTY
64168: LIST
64169: LIST
64170: PUSH
64171: LD_INT 2
64173: PUSH
64174: LD_INT 0
64176: PUSH
64177: EMPTY
64178: LIST
64179: LIST
64180: PUSH
64181: LD_INT 2
64183: PUSH
64184: LD_INT 1
64186: PUSH
64187: EMPTY
64188: LIST
64189: LIST
64190: PUSH
64191: LD_INT 2
64193: PUSH
64194: LD_INT 2
64196: PUSH
64197: EMPTY
64198: LIST
64199: LIST
64200: PUSH
64201: LD_INT 1
64203: PUSH
64204: LD_INT 2
64206: PUSH
64207: EMPTY
64208: LIST
64209: LIST
64210: PUSH
64211: LD_INT 0
64213: PUSH
64214: LD_INT 2
64216: PUSH
64217: EMPTY
64218: LIST
64219: LIST
64220: PUSH
64221: LD_INT 1
64223: NEG
64224: PUSH
64225: LD_INT 1
64227: PUSH
64228: EMPTY
64229: LIST
64230: LIST
64231: PUSH
64232: LD_INT 2
64234: NEG
64235: PUSH
64236: LD_INT 0
64238: PUSH
64239: EMPTY
64240: LIST
64241: LIST
64242: PUSH
64243: LD_INT 2
64245: NEG
64246: PUSH
64247: LD_INT 1
64249: NEG
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: PUSH
64255: LD_INT 2
64257: NEG
64258: PUSH
64259: LD_INT 2
64261: NEG
64262: PUSH
64263: EMPTY
64264: LIST
64265: LIST
64266: PUSH
64267: LD_INT 3
64269: PUSH
64270: LD_INT 1
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: PUSH
64277: LD_INT 3
64279: PUSH
64280: LD_INT 2
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: PUSH
64287: LD_INT 2
64289: PUSH
64290: LD_INT 3
64292: PUSH
64293: EMPTY
64294: LIST
64295: LIST
64296: PUSH
64297: LD_INT 1
64299: PUSH
64300: LD_INT 3
64302: PUSH
64303: EMPTY
64304: LIST
64305: LIST
64306: PUSH
64307: EMPTY
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: LIST
64316: LIST
64317: LIST
64318: LIST
64319: LIST
64320: LIST
64321: LIST
64322: LIST
64323: LIST
64324: LIST
64325: LIST
64326: LIST
64327: LIST
64328: LIST
64329: LIST
64330: LIST
64331: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
64332: LD_ADDR_VAR 0 26
64336: PUSH
64337: LD_INT 0
64339: PUSH
64340: LD_INT 0
64342: PUSH
64343: EMPTY
64344: LIST
64345: LIST
64346: PUSH
64347: LD_INT 0
64349: PUSH
64350: LD_INT 1
64352: NEG
64353: PUSH
64354: EMPTY
64355: LIST
64356: LIST
64357: PUSH
64358: LD_INT 1
64360: PUSH
64361: LD_INT 0
64363: PUSH
64364: EMPTY
64365: LIST
64366: LIST
64367: PUSH
64368: LD_INT 1
64370: PUSH
64371: LD_INT 1
64373: PUSH
64374: EMPTY
64375: LIST
64376: LIST
64377: PUSH
64378: LD_INT 0
64380: PUSH
64381: LD_INT 1
64383: PUSH
64384: EMPTY
64385: LIST
64386: LIST
64387: PUSH
64388: LD_INT 1
64390: NEG
64391: PUSH
64392: LD_INT 0
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: PUSH
64399: LD_INT 1
64401: NEG
64402: PUSH
64403: LD_INT 1
64405: NEG
64406: PUSH
64407: EMPTY
64408: LIST
64409: LIST
64410: PUSH
64411: LD_INT 1
64413: NEG
64414: PUSH
64415: LD_INT 2
64417: NEG
64418: PUSH
64419: EMPTY
64420: LIST
64421: LIST
64422: PUSH
64423: LD_INT 0
64425: PUSH
64426: LD_INT 2
64428: NEG
64429: PUSH
64430: EMPTY
64431: LIST
64432: LIST
64433: PUSH
64434: LD_INT 1
64436: PUSH
64437: LD_INT 1
64439: NEG
64440: PUSH
64441: EMPTY
64442: LIST
64443: LIST
64444: PUSH
64445: LD_INT 2
64447: PUSH
64448: LD_INT 0
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: PUSH
64455: LD_INT 2
64457: PUSH
64458: LD_INT 1
64460: PUSH
64461: EMPTY
64462: LIST
64463: LIST
64464: PUSH
64465: LD_INT 2
64467: PUSH
64468: LD_INT 2
64470: PUSH
64471: EMPTY
64472: LIST
64473: LIST
64474: PUSH
64475: LD_INT 1
64477: PUSH
64478: LD_INT 2
64480: PUSH
64481: EMPTY
64482: LIST
64483: LIST
64484: PUSH
64485: LD_INT 0
64487: PUSH
64488: LD_INT 2
64490: PUSH
64491: EMPTY
64492: LIST
64493: LIST
64494: PUSH
64495: LD_INT 1
64497: NEG
64498: PUSH
64499: LD_INT 1
64501: PUSH
64502: EMPTY
64503: LIST
64504: LIST
64505: PUSH
64506: LD_INT 2
64508: NEG
64509: PUSH
64510: LD_INT 0
64512: PUSH
64513: EMPTY
64514: LIST
64515: LIST
64516: PUSH
64517: LD_INT 2
64519: NEG
64520: PUSH
64521: LD_INT 1
64523: NEG
64524: PUSH
64525: EMPTY
64526: LIST
64527: LIST
64528: PUSH
64529: LD_INT 2
64531: NEG
64532: PUSH
64533: LD_INT 2
64535: NEG
64536: PUSH
64537: EMPTY
64538: LIST
64539: LIST
64540: PUSH
64541: LD_INT 2
64543: PUSH
64544: LD_INT 3
64546: PUSH
64547: EMPTY
64548: LIST
64549: LIST
64550: PUSH
64551: LD_INT 1
64553: PUSH
64554: LD_INT 3
64556: PUSH
64557: EMPTY
64558: LIST
64559: LIST
64560: PUSH
64561: LD_INT 1
64563: NEG
64564: PUSH
64565: LD_INT 2
64567: PUSH
64568: EMPTY
64569: LIST
64570: LIST
64571: PUSH
64572: LD_INT 2
64574: NEG
64575: PUSH
64576: LD_INT 1
64578: PUSH
64579: EMPTY
64580: LIST
64581: LIST
64582: PUSH
64583: EMPTY
64584: LIST
64585: LIST
64586: LIST
64587: LIST
64588: LIST
64589: LIST
64590: LIST
64591: LIST
64592: LIST
64593: LIST
64594: LIST
64595: LIST
64596: LIST
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: LIST
64602: LIST
64603: LIST
64604: LIST
64605: LIST
64606: LIST
64607: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
64608: LD_ADDR_VAR 0 27
64612: PUSH
64613: LD_INT 0
64615: PUSH
64616: LD_INT 0
64618: PUSH
64619: EMPTY
64620: LIST
64621: LIST
64622: PUSH
64623: LD_INT 0
64625: PUSH
64626: LD_INT 1
64628: NEG
64629: PUSH
64630: EMPTY
64631: LIST
64632: LIST
64633: PUSH
64634: LD_INT 1
64636: PUSH
64637: LD_INT 0
64639: PUSH
64640: EMPTY
64641: LIST
64642: LIST
64643: PUSH
64644: LD_INT 1
64646: PUSH
64647: LD_INT 1
64649: PUSH
64650: EMPTY
64651: LIST
64652: LIST
64653: PUSH
64654: LD_INT 0
64656: PUSH
64657: LD_INT 1
64659: PUSH
64660: EMPTY
64661: LIST
64662: LIST
64663: PUSH
64664: LD_INT 1
64666: NEG
64667: PUSH
64668: LD_INT 0
64670: PUSH
64671: EMPTY
64672: LIST
64673: LIST
64674: PUSH
64675: LD_INT 1
64677: NEG
64678: PUSH
64679: LD_INT 1
64681: NEG
64682: PUSH
64683: EMPTY
64684: LIST
64685: LIST
64686: PUSH
64687: LD_INT 1
64689: NEG
64690: PUSH
64691: LD_INT 2
64693: NEG
64694: PUSH
64695: EMPTY
64696: LIST
64697: LIST
64698: PUSH
64699: LD_INT 0
64701: PUSH
64702: LD_INT 2
64704: NEG
64705: PUSH
64706: EMPTY
64707: LIST
64708: LIST
64709: PUSH
64710: LD_INT 1
64712: PUSH
64713: LD_INT 1
64715: NEG
64716: PUSH
64717: EMPTY
64718: LIST
64719: LIST
64720: PUSH
64721: LD_INT 2
64723: PUSH
64724: LD_INT 0
64726: PUSH
64727: EMPTY
64728: LIST
64729: LIST
64730: PUSH
64731: LD_INT 2
64733: PUSH
64734: LD_INT 1
64736: PUSH
64737: EMPTY
64738: LIST
64739: LIST
64740: PUSH
64741: LD_INT 2
64743: PUSH
64744: LD_INT 2
64746: PUSH
64747: EMPTY
64748: LIST
64749: LIST
64750: PUSH
64751: LD_INT 1
64753: PUSH
64754: LD_INT 2
64756: PUSH
64757: EMPTY
64758: LIST
64759: LIST
64760: PUSH
64761: LD_INT 0
64763: PUSH
64764: LD_INT 2
64766: PUSH
64767: EMPTY
64768: LIST
64769: LIST
64770: PUSH
64771: LD_INT 1
64773: NEG
64774: PUSH
64775: LD_INT 1
64777: PUSH
64778: EMPTY
64779: LIST
64780: LIST
64781: PUSH
64782: LD_INT 2
64784: NEG
64785: PUSH
64786: LD_INT 0
64788: PUSH
64789: EMPTY
64790: LIST
64791: LIST
64792: PUSH
64793: LD_INT 2
64795: NEG
64796: PUSH
64797: LD_INT 1
64799: NEG
64800: PUSH
64801: EMPTY
64802: LIST
64803: LIST
64804: PUSH
64805: LD_INT 2
64807: NEG
64808: PUSH
64809: LD_INT 2
64811: NEG
64812: PUSH
64813: EMPTY
64814: LIST
64815: LIST
64816: PUSH
64817: LD_INT 1
64819: NEG
64820: PUSH
64821: LD_INT 2
64823: PUSH
64824: EMPTY
64825: LIST
64826: LIST
64827: PUSH
64828: LD_INT 2
64830: NEG
64831: PUSH
64832: LD_INT 1
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: PUSH
64839: LD_INT 3
64841: NEG
64842: PUSH
64843: LD_INT 1
64845: NEG
64846: PUSH
64847: EMPTY
64848: LIST
64849: LIST
64850: PUSH
64851: LD_INT 3
64853: NEG
64854: PUSH
64855: LD_INT 2
64857: NEG
64858: PUSH
64859: EMPTY
64860: LIST
64861: LIST
64862: PUSH
64863: EMPTY
64864: LIST
64865: LIST
64866: LIST
64867: LIST
64868: LIST
64869: LIST
64870: LIST
64871: LIST
64872: LIST
64873: LIST
64874: LIST
64875: LIST
64876: LIST
64877: LIST
64878: LIST
64879: LIST
64880: LIST
64881: LIST
64882: LIST
64883: LIST
64884: LIST
64885: LIST
64886: LIST
64887: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
64888: LD_ADDR_VAR 0 28
64892: PUSH
64893: LD_INT 0
64895: PUSH
64896: LD_INT 0
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: LD_INT 0
64905: PUSH
64906: LD_INT 1
64908: NEG
64909: PUSH
64910: EMPTY
64911: LIST
64912: LIST
64913: PUSH
64914: LD_INT 1
64916: PUSH
64917: LD_INT 0
64919: PUSH
64920: EMPTY
64921: LIST
64922: LIST
64923: PUSH
64924: LD_INT 1
64926: PUSH
64927: LD_INT 1
64929: PUSH
64930: EMPTY
64931: LIST
64932: LIST
64933: PUSH
64934: LD_INT 0
64936: PUSH
64937: LD_INT 1
64939: PUSH
64940: EMPTY
64941: LIST
64942: LIST
64943: PUSH
64944: LD_INT 1
64946: NEG
64947: PUSH
64948: LD_INT 0
64950: PUSH
64951: EMPTY
64952: LIST
64953: LIST
64954: PUSH
64955: LD_INT 1
64957: NEG
64958: PUSH
64959: LD_INT 1
64961: NEG
64962: PUSH
64963: EMPTY
64964: LIST
64965: LIST
64966: PUSH
64967: LD_INT 1
64969: NEG
64970: PUSH
64971: LD_INT 2
64973: NEG
64974: PUSH
64975: EMPTY
64976: LIST
64977: LIST
64978: PUSH
64979: LD_INT 0
64981: PUSH
64982: LD_INT 2
64984: NEG
64985: PUSH
64986: EMPTY
64987: LIST
64988: LIST
64989: PUSH
64990: LD_INT 1
64992: PUSH
64993: LD_INT 1
64995: NEG
64996: PUSH
64997: EMPTY
64998: LIST
64999: LIST
65000: PUSH
65001: LD_INT 2
65003: PUSH
65004: LD_INT 0
65006: PUSH
65007: EMPTY
65008: LIST
65009: LIST
65010: PUSH
65011: LD_INT 2
65013: PUSH
65014: LD_INT 1
65016: PUSH
65017: EMPTY
65018: LIST
65019: LIST
65020: PUSH
65021: LD_INT 2
65023: PUSH
65024: LD_INT 2
65026: PUSH
65027: EMPTY
65028: LIST
65029: LIST
65030: PUSH
65031: LD_INT 1
65033: PUSH
65034: LD_INT 2
65036: PUSH
65037: EMPTY
65038: LIST
65039: LIST
65040: PUSH
65041: LD_INT 0
65043: PUSH
65044: LD_INT 2
65046: PUSH
65047: EMPTY
65048: LIST
65049: LIST
65050: PUSH
65051: LD_INT 1
65053: NEG
65054: PUSH
65055: LD_INT 1
65057: PUSH
65058: EMPTY
65059: LIST
65060: LIST
65061: PUSH
65062: LD_INT 2
65064: NEG
65065: PUSH
65066: LD_INT 0
65068: PUSH
65069: EMPTY
65070: LIST
65071: LIST
65072: PUSH
65073: LD_INT 2
65075: NEG
65076: PUSH
65077: LD_INT 1
65079: NEG
65080: PUSH
65081: EMPTY
65082: LIST
65083: LIST
65084: PUSH
65085: LD_INT 2
65087: NEG
65088: PUSH
65089: LD_INT 2
65091: NEG
65092: PUSH
65093: EMPTY
65094: LIST
65095: LIST
65096: PUSH
65097: LD_INT 2
65099: NEG
65100: PUSH
65101: LD_INT 3
65103: NEG
65104: PUSH
65105: EMPTY
65106: LIST
65107: LIST
65108: PUSH
65109: LD_INT 1
65111: NEG
65112: PUSH
65113: LD_INT 3
65115: NEG
65116: PUSH
65117: EMPTY
65118: LIST
65119: LIST
65120: PUSH
65121: LD_INT 3
65123: NEG
65124: PUSH
65125: LD_INT 1
65127: NEG
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: PUSH
65133: LD_INT 3
65135: NEG
65136: PUSH
65137: LD_INT 2
65139: NEG
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: PUSH
65145: EMPTY
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: LIST
65154: LIST
65155: LIST
65156: LIST
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
65170: LD_ADDR_VAR 0 29
65174: PUSH
65175: LD_INT 0
65177: PUSH
65178: LD_INT 0
65180: PUSH
65181: EMPTY
65182: LIST
65183: LIST
65184: PUSH
65185: LD_INT 0
65187: PUSH
65188: LD_INT 1
65190: NEG
65191: PUSH
65192: EMPTY
65193: LIST
65194: LIST
65195: PUSH
65196: LD_INT 1
65198: PUSH
65199: LD_INT 0
65201: PUSH
65202: EMPTY
65203: LIST
65204: LIST
65205: PUSH
65206: LD_INT 1
65208: PUSH
65209: LD_INT 1
65211: PUSH
65212: EMPTY
65213: LIST
65214: LIST
65215: PUSH
65216: LD_INT 0
65218: PUSH
65219: LD_INT 1
65221: PUSH
65222: EMPTY
65223: LIST
65224: LIST
65225: PUSH
65226: LD_INT 1
65228: NEG
65229: PUSH
65230: LD_INT 0
65232: PUSH
65233: EMPTY
65234: LIST
65235: LIST
65236: PUSH
65237: LD_INT 1
65239: NEG
65240: PUSH
65241: LD_INT 1
65243: NEG
65244: PUSH
65245: EMPTY
65246: LIST
65247: LIST
65248: PUSH
65249: LD_INT 1
65251: NEG
65252: PUSH
65253: LD_INT 2
65255: NEG
65256: PUSH
65257: EMPTY
65258: LIST
65259: LIST
65260: PUSH
65261: LD_INT 0
65263: PUSH
65264: LD_INT 2
65266: NEG
65267: PUSH
65268: EMPTY
65269: LIST
65270: LIST
65271: PUSH
65272: LD_INT 1
65274: PUSH
65275: LD_INT 1
65277: NEG
65278: PUSH
65279: EMPTY
65280: LIST
65281: LIST
65282: PUSH
65283: LD_INT 2
65285: PUSH
65286: LD_INT 0
65288: PUSH
65289: EMPTY
65290: LIST
65291: LIST
65292: PUSH
65293: LD_INT 2
65295: PUSH
65296: LD_INT 1
65298: PUSH
65299: EMPTY
65300: LIST
65301: LIST
65302: PUSH
65303: LD_INT 1
65305: PUSH
65306: LD_INT 2
65308: PUSH
65309: EMPTY
65310: LIST
65311: LIST
65312: PUSH
65313: LD_INT 0
65315: PUSH
65316: LD_INT 2
65318: PUSH
65319: EMPTY
65320: LIST
65321: LIST
65322: PUSH
65323: LD_INT 1
65325: NEG
65326: PUSH
65327: LD_INT 1
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: LD_INT 2
65336: NEG
65337: PUSH
65338: LD_INT 1
65340: NEG
65341: PUSH
65342: EMPTY
65343: LIST
65344: LIST
65345: PUSH
65346: LD_INT 2
65348: NEG
65349: PUSH
65350: LD_INT 2
65352: NEG
65353: PUSH
65354: EMPTY
65355: LIST
65356: LIST
65357: PUSH
65358: LD_INT 2
65360: NEG
65361: PUSH
65362: LD_INT 3
65364: NEG
65365: PUSH
65366: EMPTY
65367: LIST
65368: LIST
65369: PUSH
65370: LD_INT 2
65372: PUSH
65373: LD_INT 1
65375: NEG
65376: PUSH
65377: EMPTY
65378: LIST
65379: LIST
65380: PUSH
65381: LD_INT 3
65383: PUSH
65384: LD_INT 1
65386: PUSH
65387: EMPTY
65388: LIST
65389: LIST
65390: PUSH
65391: LD_INT 1
65393: PUSH
65394: LD_INT 3
65396: PUSH
65397: EMPTY
65398: LIST
65399: LIST
65400: PUSH
65401: LD_INT 1
65403: NEG
65404: PUSH
65405: LD_INT 2
65407: PUSH
65408: EMPTY
65409: LIST
65410: LIST
65411: PUSH
65412: LD_INT 3
65414: NEG
65415: PUSH
65416: LD_INT 2
65418: NEG
65419: PUSH
65420: EMPTY
65421: LIST
65422: LIST
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: LIST
65428: LIST
65429: LIST
65430: LIST
65431: LIST
65432: LIST
65433: LIST
65434: LIST
65435: LIST
65436: LIST
65437: LIST
65438: LIST
65439: LIST
65440: LIST
65441: LIST
65442: LIST
65443: LIST
65444: LIST
65445: LIST
65446: LIST
65447: LIST
65448: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
65449: LD_ADDR_VAR 0 30
65453: PUSH
65454: LD_INT 0
65456: PUSH
65457: LD_INT 0
65459: PUSH
65460: EMPTY
65461: LIST
65462: LIST
65463: PUSH
65464: LD_INT 0
65466: PUSH
65467: LD_INT 1
65469: NEG
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: LD_INT 1
65477: PUSH
65478: LD_INT 0
65480: PUSH
65481: EMPTY
65482: LIST
65483: LIST
65484: PUSH
65485: LD_INT 1
65487: PUSH
65488: LD_INT 1
65490: PUSH
65491: EMPTY
65492: LIST
65493: LIST
65494: PUSH
65495: LD_INT 0
65497: PUSH
65498: LD_INT 1
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: PUSH
65505: LD_INT 1
65507: NEG
65508: PUSH
65509: LD_INT 0
65511: PUSH
65512: EMPTY
65513: LIST
65514: LIST
65515: PUSH
65516: LD_INT 1
65518: NEG
65519: PUSH
65520: LD_INT 1
65522: NEG
65523: PUSH
65524: EMPTY
65525: LIST
65526: LIST
65527: PUSH
65528: LD_INT 1
65530: NEG
65531: PUSH
65532: LD_INT 2
65534: NEG
65535: PUSH
65536: EMPTY
65537: LIST
65538: LIST
65539: PUSH
65540: LD_INT 0
65542: PUSH
65543: LD_INT 2
65545: NEG
65546: PUSH
65547: EMPTY
65548: LIST
65549: LIST
65550: PUSH
65551: LD_INT 1
65553: PUSH
65554: LD_INT 1
65556: NEG
65557: PUSH
65558: EMPTY
65559: LIST
65560: LIST
65561: PUSH
65562: LD_INT 2
65564: PUSH
65565: LD_INT 0
65567: PUSH
65568: EMPTY
65569: LIST
65570: LIST
65571: PUSH
65572: LD_INT 2
65574: PUSH
65575: LD_INT 1
65577: PUSH
65578: EMPTY
65579: LIST
65580: LIST
65581: PUSH
65582: LD_INT 2
65584: PUSH
65585: LD_INT 2
65587: PUSH
65588: EMPTY
65589: LIST
65590: LIST
65591: PUSH
65592: LD_INT 1
65594: PUSH
65595: LD_INT 2
65597: PUSH
65598: EMPTY
65599: LIST
65600: LIST
65601: PUSH
65602: LD_INT 1
65604: NEG
65605: PUSH
65606: LD_INT 1
65608: PUSH
65609: EMPTY
65610: LIST
65611: LIST
65612: PUSH
65613: LD_INT 2
65615: NEG
65616: PUSH
65617: LD_INT 0
65619: PUSH
65620: EMPTY
65621: LIST
65622: LIST
65623: PUSH
65624: LD_INT 2
65626: NEG
65627: PUSH
65628: LD_INT 1
65630: NEG
65631: PUSH
65632: EMPTY
65633: LIST
65634: LIST
65635: PUSH
65636: LD_INT 1
65638: NEG
65639: PUSH
65640: LD_INT 3
65642: NEG
65643: PUSH
65644: EMPTY
65645: LIST
65646: LIST
65647: PUSH
65648: LD_INT 1
65650: PUSH
65651: LD_INT 2
65653: NEG
65654: PUSH
65655: EMPTY
65656: LIST
65657: LIST
65658: PUSH
65659: LD_INT 3
65661: PUSH
65662: LD_INT 2
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: PUSH
65669: LD_INT 2
65671: PUSH
65672: LD_INT 3
65674: PUSH
65675: EMPTY
65676: LIST
65677: LIST
65678: PUSH
65679: LD_INT 2
65681: NEG
65682: PUSH
65683: LD_INT 1
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: PUSH
65690: LD_INT 3
65692: NEG
65693: PUSH
65694: LD_INT 1
65696: NEG
65697: PUSH
65698: EMPTY
65699: LIST
65700: LIST
65701: PUSH
65702: EMPTY
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: LIST
65719: LIST
65720: LIST
65721: LIST
65722: LIST
65723: LIST
65724: LIST
65725: LIST
65726: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
65727: LD_ADDR_VAR 0 31
65731: PUSH
65732: LD_INT 0
65734: PUSH
65735: LD_INT 0
65737: PUSH
65738: EMPTY
65739: LIST
65740: LIST
65741: PUSH
65742: LD_INT 0
65744: PUSH
65745: LD_INT 1
65747: NEG
65748: PUSH
65749: EMPTY
65750: LIST
65751: LIST
65752: PUSH
65753: LD_INT 1
65755: PUSH
65756: LD_INT 0
65758: PUSH
65759: EMPTY
65760: LIST
65761: LIST
65762: PUSH
65763: LD_INT 1
65765: PUSH
65766: LD_INT 1
65768: PUSH
65769: EMPTY
65770: LIST
65771: LIST
65772: PUSH
65773: LD_INT 0
65775: PUSH
65776: LD_INT 1
65778: PUSH
65779: EMPTY
65780: LIST
65781: LIST
65782: PUSH
65783: LD_INT 1
65785: NEG
65786: PUSH
65787: LD_INT 0
65789: PUSH
65790: EMPTY
65791: LIST
65792: LIST
65793: PUSH
65794: LD_INT 1
65796: NEG
65797: PUSH
65798: LD_INT 1
65800: NEG
65801: PUSH
65802: EMPTY
65803: LIST
65804: LIST
65805: PUSH
65806: LD_INT 1
65808: NEG
65809: PUSH
65810: LD_INT 2
65812: NEG
65813: PUSH
65814: EMPTY
65815: LIST
65816: LIST
65817: PUSH
65818: LD_INT 1
65820: PUSH
65821: LD_INT 1
65823: NEG
65824: PUSH
65825: EMPTY
65826: LIST
65827: LIST
65828: PUSH
65829: LD_INT 2
65831: PUSH
65832: LD_INT 0
65834: PUSH
65835: EMPTY
65836: LIST
65837: LIST
65838: PUSH
65839: LD_INT 2
65841: PUSH
65842: LD_INT 1
65844: PUSH
65845: EMPTY
65846: LIST
65847: LIST
65848: PUSH
65849: LD_INT 2
65851: PUSH
65852: LD_INT 2
65854: PUSH
65855: EMPTY
65856: LIST
65857: LIST
65858: PUSH
65859: LD_INT 1
65861: PUSH
65862: LD_INT 2
65864: PUSH
65865: EMPTY
65866: LIST
65867: LIST
65868: PUSH
65869: LD_INT 0
65871: PUSH
65872: LD_INT 2
65874: PUSH
65875: EMPTY
65876: LIST
65877: LIST
65878: PUSH
65879: LD_INT 1
65881: NEG
65882: PUSH
65883: LD_INT 1
65885: PUSH
65886: EMPTY
65887: LIST
65888: LIST
65889: PUSH
65890: LD_INT 2
65892: NEG
65893: PUSH
65894: LD_INT 1
65896: NEG
65897: PUSH
65898: EMPTY
65899: LIST
65900: LIST
65901: PUSH
65902: LD_INT 2
65904: NEG
65905: PUSH
65906: LD_INT 2
65908: NEG
65909: PUSH
65910: EMPTY
65911: LIST
65912: LIST
65913: PUSH
65914: LD_INT 2
65916: NEG
65917: PUSH
65918: LD_INT 3
65920: NEG
65921: PUSH
65922: EMPTY
65923: LIST
65924: LIST
65925: PUSH
65926: LD_INT 2
65928: PUSH
65929: LD_INT 1
65931: NEG
65932: PUSH
65933: EMPTY
65934: LIST
65935: LIST
65936: PUSH
65937: LD_INT 3
65939: PUSH
65940: LD_INT 1
65942: PUSH
65943: EMPTY
65944: LIST
65945: LIST
65946: PUSH
65947: LD_INT 1
65949: PUSH
65950: LD_INT 3
65952: PUSH
65953: EMPTY
65954: LIST
65955: LIST
65956: PUSH
65957: LD_INT 1
65959: NEG
65960: PUSH
65961: LD_INT 2
65963: PUSH
65964: EMPTY
65965: LIST
65966: LIST
65967: PUSH
65968: LD_INT 3
65970: NEG
65971: PUSH
65972: LD_INT 2
65974: NEG
65975: PUSH
65976: EMPTY
65977: LIST
65978: LIST
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: LIST
65984: LIST
65985: LIST
65986: LIST
65987: LIST
65988: LIST
65989: LIST
65990: LIST
65991: LIST
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: LIST
66003: LIST
66004: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66005: LD_ADDR_VAR 0 32
66009: PUSH
66010: LD_INT 0
66012: PUSH
66013: LD_INT 0
66015: PUSH
66016: EMPTY
66017: LIST
66018: LIST
66019: PUSH
66020: LD_INT 0
66022: PUSH
66023: LD_INT 1
66025: NEG
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PUSH
66031: LD_INT 1
66033: PUSH
66034: LD_INT 0
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: PUSH
66041: LD_INT 1
66043: PUSH
66044: LD_INT 1
66046: PUSH
66047: EMPTY
66048: LIST
66049: LIST
66050: PUSH
66051: LD_INT 0
66053: PUSH
66054: LD_INT 1
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PUSH
66061: LD_INT 1
66063: NEG
66064: PUSH
66065: LD_INT 0
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: PUSH
66072: LD_INT 1
66074: NEG
66075: PUSH
66076: LD_INT 1
66078: NEG
66079: PUSH
66080: EMPTY
66081: LIST
66082: LIST
66083: PUSH
66084: LD_INT 1
66086: NEG
66087: PUSH
66088: LD_INT 2
66090: NEG
66091: PUSH
66092: EMPTY
66093: LIST
66094: LIST
66095: PUSH
66096: LD_INT 0
66098: PUSH
66099: LD_INT 2
66101: NEG
66102: PUSH
66103: EMPTY
66104: LIST
66105: LIST
66106: PUSH
66107: LD_INT 1
66109: PUSH
66110: LD_INT 1
66112: NEG
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PUSH
66118: LD_INT 2
66120: PUSH
66121: LD_INT 1
66123: PUSH
66124: EMPTY
66125: LIST
66126: LIST
66127: PUSH
66128: LD_INT 2
66130: PUSH
66131: LD_INT 2
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: PUSH
66138: LD_INT 1
66140: PUSH
66141: LD_INT 2
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: PUSH
66148: LD_INT 0
66150: PUSH
66151: LD_INT 2
66153: PUSH
66154: EMPTY
66155: LIST
66156: LIST
66157: PUSH
66158: LD_INT 1
66160: NEG
66161: PUSH
66162: LD_INT 1
66164: PUSH
66165: EMPTY
66166: LIST
66167: LIST
66168: PUSH
66169: LD_INT 2
66171: NEG
66172: PUSH
66173: LD_INT 0
66175: PUSH
66176: EMPTY
66177: LIST
66178: LIST
66179: PUSH
66180: LD_INT 2
66182: NEG
66183: PUSH
66184: LD_INT 1
66186: NEG
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: LD_INT 1
66194: NEG
66195: PUSH
66196: LD_INT 3
66198: NEG
66199: PUSH
66200: EMPTY
66201: LIST
66202: LIST
66203: PUSH
66204: LD_INT 1
66206: PUSH
66207: LD_INT 2
66209: NEG
66210: PUSH
66211: EMPTY
66212: LIST
66213: LIST
66214: PUSH
66215: LD_INT 3
66217: PUSH
66218: LD_INT 2
66220: PUSH
66221: EMPTY
66222: LIST
66223: LIST
66224: PUSH
66225: LD_INT 2
66227: PUSH
66228: LD_INT 3
66230: PUSH
66231: EMPTY
66232: LIST
66233: LIST
66234: PUSH
66235: LD_INT 2
66237: NEG
66238: PUSH
66239: LD_INT 1
66241: PUSH
66242: EMPTY
66243: LIST
66244: LIST
66245: PUSH
66246: LD_INT 3
66248: NEG
66249: PUSH
66250: LD_INT 1
66252: NEG
66253: PUSH
66254: EMPTY
66255: LIST
66256: LIST
66257: PUSH
66258: EMPTY
66259: LIST
66260: LIST
66261: LIST
66262: LIST
66263: LIST
66264: LIST
66265: LIST
66266: LIST
66267: LIST
66268: LIST
66269: LIST
66270: LIST
66271: LIST
66272: LIST
66273: LIST
66274: LIST
66275: LIST
66276: LIST
66277: LIST
66278: LIST
66279: LIST
66280: LIST
66281: LIST
66282: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66283: LD_ADDR_VAR 0 33
66287: PUSH
66288: LD_INT 0
66290: PUSH
66291: LD_INT 0
66293: PUSH
66294: EMPTY
66295: LIST
66296: LIST
66297: PUSH
66298: LD_INT 0
66300: PUSH
66301: LD_INT 1
66303: NEG
66304: PUSH
66305: EMPTY
66306: LIST
66307: LIST
66308: PUSH
66309: LD_INT 1
66311: PUSH
66312: LD_INT 0
66314: PUSH
66315: EMPTY
66316: LIST
66317: LIST
66318: PUSH
66319: LD_INT 1
66321: PUSH
66322: LD_INT 1
66324: PUSH
66325: EMPTY
66326: LIST
66327: LIST
66328: PUSH
66329: LD_INT 0
66331: PUSH
66332: LD_INT 1
66334: PUSH
66335: EMPTY
66336: LIST
66337: LIST
66338: PUSH
66339: LD_INT 1
66341: NEG
66342: PUSH
66343: LD_INT 0
66345: PUSH
66346: EMPTY
66347: LIST
66348: LIST
66349: PUSH
66350: LD_INT 1
66352: NEG
66353: PUSH
66354: LD_INT 1
66356: NEG
66357: PUSH
66358: EMPTY
66359: LIST
66360: LIST
66361: PUSH
66362: LD_INT 1
66364: NEG
66365: PUSH
66366: LD_INT 2
66368: NEG
66369: PUSH
66370: EMPTY
66371: LIST
66372: LIST
66373: PUSH
66374: LD_INT 1
66376: PUSH
66377: LD_INT 1
66379: NEG
66380: PUSH
66381: EMPTY
66382: LIST
66383: LIST
66384: PUSH
66385: LD_INT 2
66387: PUSH
66388: LD_INT 0
66390: PUSH
66391: EMPTY
66392: LIST
66393: LIST
66394: PUSH
66395: LD_INT 2
66397: PUSH
66398: LD_INT 1
66400: PUSH
66401: EMPTY
66402: LIST
66403: LIST
66404: PUSH
66405: LD_INT 1
66407: PUSH
66408: LD_INT 2
66410: PUSH
66411: EMPTY
66412: LIST
66413: LIST
66414: PUSH
66415: LD_INT 0
66417: PUSH
66418: LD_INT 2
66420: PUSH
66421: EMPTY
66422: LIST
66423: LIST
66424: PUSH
66425: LD_INT 1
66427: NEG
66428: PUSH
66429: LD_INT 1
66431: PUSH
66432: EMPTY
66433: LIST
66434: LIST
66435: PUSH
66436: LD_INT 2
66438: NEG
66439: PUSH
66440: LD_INT 0
66442: PUSH
66443: EMPTY
66444: LIST
66445: LIST
66446: PUSH
66447: LD_INT 2
66449: NEG
66450: PUSH
66451: LD_INT 1
66453: NEG
66454: PUSH
66455: EMPTY
66456: LIST
66457: LIST
66458: PUSH
66459: LD_INT 2
66461: NEG
66462: PUSH
66463: LD_INT 2
66465: NEG
66466: PUSH
66467: EMPTY
66468: LIST
66469: LIST
66470: PUSH
66471: LD_INT 2
66473: NEG
66474: PUSH
66475: LD_INT 3
66477: NEG
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: LD_INT 2
66485: PUSH
66486: LD_INT 1
66488: NEG
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: PUSH
66494: LD_INT 3
66496: PUSH
66497: LD_INT 1
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PUSH
66504: LD_INT 1
66506: PUSH
66507: LD_INT 3
66509: PUSH
66510: EMPTY
66511: LIST
66512: LIST
66513: PUSH
66514: LD_INT 1
66516: NEG
66517: PUSH
66518: LD_INT 2
66520: PUSH
66521: EMPTY
66522: LIST
66523: LIST
66524: PUSH
66525: LD_INT 3
66527: NEG
66528: PUSH
66529: LD_INT 2
66531: NEG
66532: PUSH
66533: EMPTY
66534: LIST
66535: LIST
66536: PUSH
66537: EMPTY
66538: LIST
66539: LIST
66540: LIST
66541: LIST
66542: LIST
66543: LIST
66544: LIST
66545: LIST
66546: LIST
66547: LIST
66548: LIST
66549: LIST
66550: LIST
66551: LIST
66552: LIST
66553: LIST
66554: LIST
66555: LIST
66556: LIST
66557: LIST
66558: LIST
66559: LIST
66560: LIST
66561: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66562: LD_ADDR_VAR 0 34
66566: PUSH
66567: LD_INT 0
66569: PUSH
66570: LD_INT 0
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: LD_INT 0
66579: PUSH
66580: LD_INT 1
66582: NEG
66583: PUSH
66584: EMPTY
66585: LIST
66586: LIST
66587: PUSH
66588: LD_INT 1
66590: PUSH
66591: LD_INT 0
66593: PUSH
66594: EMPTY
66595: LIST
66596: LIST
66597: PUSH
66598: LD_INT 1
66600: PUSH
66601: LD_INT 1
66603: PUSH
66604: EMPTY
66605: LIST
66606: LIST
66607: PUSH
66608: LD_INT 0
66610: PUSH
66611: LD_INT 1
66613: PUSH
66614: EMPTY
66615: LIST
66616: LIST
66617: PUSH
66618: LD_INT 1
66620: NEG
66621: PUSH
66622: LD_INT 0
66624: PUSH
66625: EMPTY
66626: LIST
66627: LIST
66628: PUSH
66629: LD_INT 1
66631: NEG
66632: PUSH
66633: LD_INT 1
66635: NEG
66636: PUSH
66637: EMPTY
66638: LIST
66639: LIST
66640: PUSH
66641: LD_INT 1
66643: NEG
66644: PUSH
66645: LD_INT 2
66647: NEG
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: LD_INT 0
66655: PUSH
66656: LD_INT 2
66658: NEG
66659: PUSH
66660: EMPTY
66661: LIST
66662: LIST
66663: PUSH
66664: LD_INT 1
66666: PUSH
66667: LD_INT 1
66669: NEG
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: PUSH
66675: LD_INT 2
66677: PUSH
66678: LD_INT 1
66680: PUSH
66681: EMPTY
66682: LIST
66683: LIST
66684: PUSH
66685: LD_INT 2
66687: PUSH
66688: LD_INT 2
66690: PUSH
66691: EMPTY
66692: LIST
66693: LIST
66694: PUSH
66695: LD_INT 1
66697: PUSH
66698: LD_INT 2
66700: PUSH
66701: EMPTY
66702: LIST
66703: LIST
66704: PUSH
66705: LD_INT 1
66707: NEG
66708: PUSH
66709: LD_INT 1
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: PUSH
66716: LD_INT 2
66718: NEG
66719: PUSH
66720: LD_INT 0
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: PUSH
66727: LD_INT 2
66729: NEG
66730: PUSH
66731: LD_INT 1
66733: NEG
66734: PUSH
66735: EMPTY
66736: LIST
66737: LIST
66738: PUSH
66739: LD_INT 2
66741: NEG
66742: PUSH
66743: LD_INT 2
66745: NEG
66746: PUSH
66747: EMPTY
66748: LIST
66749: LIST
66750: PUSH
66751: LD_INT 1
66753: NEG
66754: PUSH
66755: LD_INT 3
66757: NEG
66758: PUSH
66759: EMPTY
66760: LIST
66761: LIST
66762: PUSH
66763: LD_INT 1
66765: PUSH
66766: LD_INT 2
66768: NEG
66769: PUSH
66770: EMPTY
66771: LIST
66772: LIST
66773: PUSH
66774: LD_INT 3
66776: PUSH
66777: LD_INT 2
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PUSH
66784: LD_INT 2
66786: PUSH
66787: LD_INT 3
66789: PUSH
66790: EMPTY
66791: LIST
66792: LIST
66793: PUSH
66794: LD_INT 2
66796: NEG
66797: PUSH
66798: LD_INT 1
66800: PUSH
66801: EMPTY
66802: LIST
66803: LIST
66804: PUSH
66805: LD_INT 3
66807: NEG
66808: PUSH
66809: LD_INT 1
66811: NEG
66812: PUSH
66813: EMPTY
66814: LIST
66815: LIST
66816: PUSH
66817: EMPTY
66818: LIST
66819: LIST
66820: LIST
66821: LIST
66822: LIST
66823: LIST
66824: LIST
66825: LIST
66826: LIST
66827: LIST
66828: LIST
66829: LIST
66830: LIST
66831: LIST
66832: LIST
66833: LIST
66834: LIST
66835: LIST
66836: LIST
66837: LIST
66838: LIST
66839: LIST
66840: LIST
66841: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
66842: LD_ADDR_VAR 0 35
66846: PUSH
66847: LD_INT 0
66849: PUSH
66850: LD_INT 0
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: PUSH
66857: LD_INT 0
66859: PUSH
66860: LD_INT 1
66862: NEG
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: PUSH
66868: LD_INT 1
66870: PUSH
66871: LD_INT 0
66873: PUSH
66874: EMPTY
66875: LIST
66876: LIST
66877: PUSH
66878: LD_INT 1
66880: PUSH
66881: LD_INT 1
66883: PUSH
66884: EMPTY
66885: LIST
66886: LIST
66887: PUSH
66888: LD_INT 0
66890: PUSH
66891: LD_INT 1
66893: PUSH
66894: EMPTY
66895: LIST
66896: LIST
66897: PUSH
66898: LD_INT 1
66900: NEG
66901: PUSH
66902: LD_INT 0
66904: PUSH
66905: EMPTY
66906: LIST
66907: LIST
66908: PUSH
66909: LD_INT 1
66911: NEG
66912: PUSH
66913: LD_INT 1
66915: NEG
66916: PUSH
66917: EMPTY
66918: LIST
66919: LIST
66920: PUSH
66921: LD_INT 2
66923: PUSH
66924: LD_INT 1
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: PUSH
66931: LD_INT 2
66933: NEG
66934: PUSH
66935: LD_INT 1
66937: NEG
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: PUSH
66943: EMPTY
66944: LIST
66945: LIST
66946: LIST
66947: LIST
66948: LIST
66949: LIST
66950: LIST
66951: LIST
66952: LIST
66953: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
66954: LD_ADDR_VAR 0 36
66958: PUSH
66959: LD_INT 0
66961: PUSH
66962: LD_INT 0
66964: PUSH
66965: EMPTY
66966: LIST
66967: LIST
66968: PUSH
66969: LD_INT 0
66971: PUSH
66972: LD_INT 1
66974: NEG
66975: PUSH
66976: EMPTY
66977: LIST
66978: LIST
66979: PUSH
66980: LD_INT 1
66982: PUSH
66983: LD_INT 0
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: LD_INT 1
66992: PUSH
66993: LD_INT 1
66995: PUSH
66996: EMPTY
66997: LIST
66998: LIST
66999: PUSH
67000: LD_INT 0
67002: PUSH
67003: LD_INT 1
67005: PUSH
67006: EMPTY
67007: LIST
67008: LIST
67009: PUSH
67010: LD_INT 1
67012: NEG
67013: PUSH
67014: LD_INT 0
67016: PUSH
67017: EMPTY
67018: LIST
67019: LIST
67020: PUSH
67021: LD_INT 1
67023: NEG
67024: PUSH
67025: LD_INT 1
67027: NEG
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: PUSH
67033: LD_INT 1
67035: NEG
67036: PUSH
67037: LD_INT 2
67039: NEG
67040: PUSH
67041: EMPTY
67042: LIST
67043: LIST
67044: PUSH
67045: LD_INT 1
67047: PUSH
67048: LD_INT 2
67050: PUSH
67051: EMPTY
67052: LIST
67053: LIST
67054: PUSH
67055: EMPTY
67056: LIST
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
67066: LD_ADDR_VAR 0 37
67070: PUSH
67071: LD_INT 0
67073: PUSH
67074: LD_INT 0
67076: PUSH
67077: EMPTY
67078: LIST
67079: LIST
67080: PUSH
67081: LD_INT 0
67083: PUSH
67084: LD_INT 1
67086: NEG
67087: PUSH
67088: EMPTY
67089: LIST
67090: LIST
67091: PUSH
67092: LD_INT 1
67094: PUSH
67095: LD_INT 0
67097: PUSH
67098: EMPTY
67099: LIST
67100: LIST
67101: PUSH
67102: LD_INT 1
67104: PUSH
67105: LD_INT 1
67107: PUSH
67108: EMPTY
67109: LIST
67110: LIST
67111: PUSH
67112: LD_INT 0
67114: PUSH
67115: LD_INT 1
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 1
67124: NEG
67125: PUSH
67126: LD_INT 0
67128: PUSH
67129: EMPTY
67130: LIST
67131: LIST
67132: PUSH
67133: LD_INT 1
67135: NEG
67136: PUSH
67137: LD_INT 1
67139: NEG
67140: PUSH
67141: EMPTY
67142: LIST
67143: LIST
67144: PUSH
67145: LD_INT 1
67147: PUSH
67148: LD_INT 1
67150: NEG
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: PUSH
67156: LD_INT 1
67158: NEG
67159: PUSH
67160: LD_INT 1
67162: PUSH
67163: EMPTY
67164: LIST
67165: LIST
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: LIST
67171: LIST
67172: LIST
67173: LIST
67174: LIST
67175: LIST
67176: LIST
67177: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
67178: LD_ADDR_VAR 0 38
67182: PUSH
67183: LD_INT 0
67185: PUSH
67186: LD_INT 0
67188: PUSH
67189: EMPTY
67190: LIST
67191: LIST
67192: PUSH
67193: LD_INT 0
67195: PUSH
67196: LD_INT 1
67198: NEG
67199: PUSH
67200: EMPTY
67201: LIST
67202: LIST
67203: PUSH
67204: LD_INT 1
67206: PUSH
67207: LD_INT 0
67209: PUSH
67210: EMPTY
67211: LIST
67212: LIST
67213: PUSH
67214: LD_INT 1
67216: PUSH
67217: LD_INT 1
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PUSH
67224: LD_INT 0
67226: PUSH
67227: LD_INT 1
67229: PUSH
67230: EMPTY
67231: LIST
67232: LIST
67233: PUSH
67234: LD_INT 1
67236: NEG
67237: PUSH
67238: LD_INT 0
67240: PUSH
67241: EMPTY
67242: LIST
67243: LIST
67244: PUSH
67245: LD_INT 1
67247: NEG
67248: PUSH
67249: LD_INT 1
67251: NEG
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 2
67259: PUSH
67260: LD_INT 1
67262: PUSH
67263: EMPTY
67264: LIST
67265: LIST
67266: PUSH
67267: LD_INT 2
67269: NEG
67270: PUSH
67271: LD_INT 1
67273: NEG
67274: PUSH
67275: EMPTY
67276: LIST
67277: LIST
67278: PUSH
67279: EMPTY
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
67290: LD_ADDR_VAR 0 39
67294: PUSH
67295: LD_INT 0
67297: PUSH
67298: LD_INT 0
67300: PUSH
67301: EMPTY
67302: LIST
67303: LIST
67304: PUSH
67305: LD_INT 0
67307: PUSH
67308: LD_INT 1
67310: NEG
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 1
67318: PUSH
67319: LD_INT 0
67321: PUSH
67322: EMPTY
67323: LIST
67324: LIST
67325: PUSH
67326: LD_INT 1
67328: PUSH
67329: LD_INT 1
67331: PUSH
67332: EMPTY
67333: LIST
67334: LIST
67335: PUSH
67336: LD_INT 0
67338: PUSH
67339: LD_INT 1
67341: PUSH
67342: EMPTY
67343: LIST
67344: LIST
67345: PUSH
67346: LD_INT 1
67348: NEG
67349: PUSH
67350: LD_INT 0
67352: PUSH
67353: EMPTY
67354: LIST
67355: LIST
67356: PUSH
67357: LD_INT 1
67359: NEG
67360: PUSH
67361: LD_INT 1
67363: NEG
67364: PUSH
67365: EMPTY
67366: LIST
67367: LIST
67368: PUSH
67369: LD_INT 1
67371: NEG
67372: PUSH
67373: LD_INT 2
67375: NEG
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: PUSH
67381: LD_INT 1
67383: PUSH
67384: LD_INT 2
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: PUSH
67391: EMPTY
67392: LIST
67393: LIST
67394: LIST
67395: LIST
67396: LIST
67397: LIST
67398: LIST
67399: LIST
67400: LIST
67401: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
67402: LD_ADDR_VAR 0 40
67406: PUSH
67407: LD_INT 0
67409: PUSH
67410: LD_INT 0
67412: PUSH
67413: EMPTY
67414: LIST
67415: LIST
67416: PUSH
67417: LD_INT 0
67419: PUSH
67420: LD_INT 1
67422: NEG
67423: PUSH
67424: EMPTY
67425: LIST
67426: LIST
67427: PUSH
67428: LD_INT 1
67430: PUSH
67431: LD_INT 0
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: PUSH
67438: LD_INT 1
67440: PUSH
67441: LD_INT 1
67443: PUSH
67444: EMPTY
67445: LIST
67446: LIST
67447: PUSH
67448: LD_INT 0
67450: PUSH
67451: LD_INT 1
67453: PUSH
67454: EMPTY
67455: LIST
67456: LIST
67457: PUSH
67458: LD_INT 1
67460: NEG
67461: PUSH
67462: LD_INT 0
67464: PUSH
67465: EMPTY
67466: LIST
67467: LIST
67468: PUSH
67469: LD_INT 1
67471: NEG
67472: PUSH
67473: LD_INT 1
67475: NEG
67476: PUSH
67477: EMPTY
67478: LIST
67479: LIST
67480: PUSH
67481: LD_INT 1
67483: PUSH
67484: LD_INT 1
67486: NEG
67487: PUSH
67488: EMPTY
67489: LIST
67490: LIST
67491: PUSH
67492: LD_INT 1
67494: NEG
67495: PUSH
67496: LD_INT 1
67498: PUSH
67499: EMPTY
67500: LIST
67501: LIST
67502: PUSH
67503: EMPTY
67504: LIST
67505: LIST
67506: LIST
67507: LIST
67508: LIST
67509: LIST
67510: LIST
67511: LIST
67512: LIST
67513: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67514: LD_ADDR_VAR 0 41
67518: PUSH
67519: LD_INT 0
67521: PUSH
67522: LD_INT 0
67524: PUSH
67525: EMPTY
67526: LIST
67527: LIST
67528: PUSH
67529: LD_INT 0
67531: PUSH
67532: LD_INT 1
67534: NEG
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: PUSH
67540: LD_INT 1
67542: PUSH
67543: LD_INT 0
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: PUSH
67550: LD_INT 1
67552: PUSH
67553: LD_INT 1
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PUSH
67560: LD_INT 0
67562: PUSH
67563: LD_INT 1
67565: PUSH
67566: EMPTY
67567: LIST
67568: LIST
67569: PUSH
67570: LD_INT 1
67572: NEG
67573: PUSH
67574: LD_INT 0
67576: PUSH
67577: EMPTY
67578: LIST
67579: LIST
67580: PUSH
67581: LD_INT 1
67583: NEG
67584: PUSH
67585: LD_INT 1
67587: NEG
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: PUSH
67593: LD_INT 1
67595: NEG
67596: PUSH
67597: LD_INT 2
67599: NEG
67600: PUSH
67601: EMPTY
67602: LIST
67603: LIST
67604: PUSH
67605: LD_INT 1
67607: PUSH
67608: LD_INT 1
67610: NEG
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: PUSH
67616: LD_INT 2
67618: PUSH
67619: LD_INT 0
67621: PUSH
67622: EMPTY
67623: LIST
67624: LIST
67625: PUSH
67626: LD_INT 2
67628: PUSH
67629: LD_INT 1
67631: PUSH
67632: EMPTY
67633: LIST
67634: LIST
67635: PUSH
67636: LD_INT 2
67638: PUSH
67639: LD_INT 2
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PUSH
67646: LD_INT 1
67648: PUSH
67649: LD_INT 2
67651: PUSH
67652: EMPTY
67653: LIST
67654: LIST
67655: PUSH
67656: LD_INT 1
67658: NEG
67659: PUSH
67660: LD_INT 1
67662: PUSH
67663: EMPTY
67664: LIST
67665: LIST
67666: PUSH
67667: LD_INT 2
67669: NEG
67670: PUSH
67671: LD_INT 0
67673: PUSH
67674: EMPTY
67675: LIST
67676: LIST
67677: PUSH
67678: LD_INT 2
67680: NEG
67681: PUSH
67682: LD_INT 1
67684: NEG
67685: PUSH
67686: EMPTY
67687: LIST
67688: LIST
67689: PUSH
67690: LD_INT 2
67692: NEG
67693: PUSH
67694: LD_INT 2
67696: NEG
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: PUSH
67702: LD_INT 2
67704: NEG
67705: PUSH
67706: LD_INT 3
67708: NEG
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PUSH
67714: LD_INT 2
67716: PUSH
67717: LD_INT 1
67719: NEG
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: PUSH
67725: LD_INT 3
67727: PUSH
67728: LD_INT 0
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: LD_INT 3
67737: PUSH
67738: LD_INT 1
67740: PUSH
67741: EMPTY
67742: LIST
67743: LIST
67744: PUSH
67745: LD_INT 3
67747: PUSH
67748: LD_INT 2
67750: PUSH
67751: EMPTY
67752: LIST
67753: LIST
67754: PUSH
67755: LD_INT 3
67757: PUSH
67758: LD_INT 3
67760: PUSH
67761: EMPTY
67762: LIST
67763: LIST
67764: PUSH
67765: LD_INT 2
67767: PUSH
67768: LD_INT 3
67770: PUSH
67771: EMPTY
67772: LIST
67773: LIST
67774: PUSH
67775: LD_INT 2
67777: NEG
67778: PUSH
67779: LD_INT 1
67781: PUSH
67782: EMPTY
67783: LIST
67784: LIST
67785: PUSH
67786: LD_INT 3
67788: NEG
67789: PUSH
67790: LD_INT 0
67792: PUSH
67793: EMPTY
67794: LIST
67795: LIST
67796: PUSH
67797: LD_INT 3
67799: NEG
67800: PUSH
67801: LD_INT 1
67803: NEG
67804: PUSH
67805: EMPTY
67806: LIST
67807: LIST
67808: PUSH
67809: LD_INT 3
67811: NEG
67812: PUSH
67813: LD_INT 2
67815: NEG
67816: PUSH
67817: EMPTY
67818: LIST
67819: LIST
67820: PUSH
67821: LD_INT 3
67823: NEG
67824: PUSH
67825: LD_INT 3
67827: NEG
67828: PUSH
67829: EMPTY
67830: LIST
67831: LIST
67832: PUSH
67833: EMPTY
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: LIST
67862: LIST
67863: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67864: LD_ADDR_VAR 0 42
67868: PUSH
67869: LD_INT 0
67871: PUSH
67872: LD_INT 0
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: LD_INT 0
67881: PUSH
67882: LD_INT 1
67884: NEG
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 1
67892: PUSH
67893: LD_INT 0
67895: PUSH
67896: EMPTY
67897: LIST
67898: LIST
67899: PUSH
67900: LD_INT 1
67902: PUSH
67903: LD_INT 1
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: PUSH
67910: LD_INT 0
67912: PUSH
67913: LD_INT 1
67915: PUSH
67916: EMPTY
67917: LIST
67918: LIST
67919: PUSH
67920: LD_INT 1
67922: NEG
67923: PUSH
67924: LD_INT 0
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: PUSH
67931: LD_INT 1
67933: NEG
67934: PUSH
67935: LD_INT 1
67937: NEG
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: PUSH
67943: LD_INT 1
67945: NEG
67946: PUSH
67947: LD_INT 2
67949: NEG
67950: PUSH
67951: EMPTY
67952: LIST
67953: LIST
67954: PUSH
67955: LD_INT 0
67957: PUSH
67958: LD_INT 2
67960: NEG
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 1
67968: PUSH
67969: LD_INT 1
67971: NEG
67972: PUSH
67973: EMPTY
67974: LIST
67975: LIST
67976: PUSH
67977: LD_INT 2
67979: PUSH
67980: LD_INT 1
67982: PUSH
67983: EMPTY
67984: LIST
67985: LIST
67986: PUSH
67987: LD_INT 2
67989: PUSH
67990: LD_INT 2
67992: PUSH
67993: EMPTY
67994: LIST
67995: LIST
67996: PUSH
67997: LD_INT 1
67999: PUSH
68000: LD_INT 2
68002: PUSH
68003: EMPTY
68004: LIST
68005: LIST
68006: PUSH
68007: LD_INT 0
68009: PUSH
68010: LD_INT 2
68012: PUSH
68013: EMPTY
68014: LIST
68015: LIST
68016: PUSH
68017: LD_INT 1
68019: NEG
68020: PUSH
68021: LD_INT 1
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: PUSH
68028: LD_INT 2
68030: NEG
68031: PUSH
68032: LD_INT 1
68034: NEG
68035: PUSH
68036: EMPTY
68037: LIST
68038: LIST
68039: PUSH
68040: LD_INT 2
68042: NEG
68043: PUSH
68044: LD_INT 2
68046: NEG
68047: PUSH
68048: EMPTY
68049: LIST
68050: LIST
68051: PUSH
68052: LD_INT 2
68054: NEG
68055: PUSH
68056: LD_INT 3
68058: NEG
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PUSH
68064: LD_INT 1
68066: NEG
68067: PUSH
68068: LD_INT 3
68070: NEG
68071: PUSH
68072: EMPTY
68073: LIST
68074: LIST
68075: PUSH
68076: LD_INT 0
68078: PUSH
68079: LD_INT 3
68081: NEG
68082: PUSH
68083: EMPTY
68084: LIST
68085: LIST
68086: PUSH
68087: LD_INT 1
68089: PUSH
68090: LD_INT 2
68092: NEG
68093: PUSH
68094: EMPTY
68095: LIST
68096: LIST
68097: PUSH
68098: LD_INT 3
68100: PUSH
68101: LD_INT 2
68103: PUSH
68104: EMPTY
68105: LIST
68106: LIST
68107: PUSH
68108: LD_INT 3
68110: PUSH
68111: LD_INT 3
68113: PUSH
68114: EMPTY
68115: LIST
68116: LIST
68117: PUSH
68118: LD_INT 2
68120: PUSH
68121: LD_INT 3
68123: PUSH
68124: EMPTY
68125: LIST
68126: LIST
68127: PUSH
68128: LD_INT 1
68130: PUSH
68131: LD_INT 3
68133: PUSH
68134: EMPTY
68135: LIST
68136: LIST
68137: PUSH
68138: LD_INT 0
68140: PUSH
68141: LD_INT 3
68143: PUSH
68144: EMPTY
68145: LIST
68146: LIST
68147: PUSH
68148: LD_INT 1
68150: NEG
68151: PUSH
68152: LD_INT 2
68154: PUSH
68155: EMPTY
68156: LIST
68157: LIST
68158: PUSH
68159: LD_INT 3
68161: NEG
68162: PUSH
68163: LD_INT 2
68165: NEG
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: PUSH
68171: LD_INT 3
68173: NEG
68174: PUSH
68175: LD_INT 3
68177: NEG
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: LIST
68193: LIST
68194: LIST
68195: LIST
68196: LIST
68197: LIST
68198: LIST
68199: LIST
68200: LIST
68201: LIST
68202: LIST
68203: LIST
68204: LIST
68205: LIST
68206: LIST
68207: LIST
68208: LIST
68209: LIST
68210: LIST
68211: LIST
68212: LIST
68213: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68214: LD_ADDR_VAR 0 43
68218: PUSH
68219: LD_INT 0
68221: PUSH
68222: LD_INT 0
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 0
68231: PUSH
68232: LD_INT 1
68234: NEG
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: PUSH
68240: LD_INT 1
68242: PUSH
68243: LD_INT 0
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: PUSH
68250: LD_INT 1
68252: PUSH
68253: LD_INT 1
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PUSH
68260: LD_INT 0
68262: PUSH
68263: LD_INT 1
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 1
68272: NEG
68273: PUSH
68274: LD_INT 0
68276: PUSH
68277: EMPTY
68278: LIST
68279: LIST
68280: PUSH
68281: LD_INT 1
68283: NEG
68284: PUSH
68285: LD_INT 1
68287: NEG
68288: PUSH
68289: EMPTY
68290: LIST
68291: LIST
68292: PUSH
68293: LD_INT 1
68295: NEG
68296: PUSH
68297: LD_INT 2
68299: NEG
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: PUSH
68305: LD_INT 0
68307: PUSH
68308: LD_INT 2
68310: NEG
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: PUSH
68316: LD_INT 1
68318: PUSH
68319: LD_INT 1
68321: NEG
68322: PUSH
68323: EMPTY
68324: LIST
68325: LIST
68326: PUSH
68327: LD_INT 2
68329: PUSH
68330: LD_INT 0
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: LD_INT 2
68339: PUSH
68340: LD_INT 1
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: PUSH
68347: LD_INT 1
68349: PUSH
68350: LD_INT 2
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 0
68359: PUSH
68360: LD_INT 2
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: PUSH
68367: LD_INT 1
68369: NEG
68370: PUSH
68371: LD_INT 1
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: PUSH
68378: LD_INT 2
68380: NEG
68381: PUSH
68382: LD_INT 0
68384: PUSH
68385: EMPTY
68386: LIST
68387: LIST
68388: PUSH
68389: LD_INT 2
68391: NEG
68392: PUSH
68393: LD_INT 1
68395: NEG
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: PUSH
68401: LD_INT 1
68403: NEG
68404: PUSH
68405: LD_INT 3
68407: NEG
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 0
68415: PUSH
68416: LD_INT 3
68418: NEG
68419: PUSH
68420: EMPTY
68421: LIST
68422: LIST
68423: PUSH
68424: LD_INT 1
68426: PUSH
68427: LD_INT 2
68429: NEG
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 2
68437: PUSH
68438: LD_INT 1
68440: NEG
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: PUSH
68446: LD_INT 3
68448: PUSH
68449: LD_INT 0
68451: PUSH
68452: EMPTY
68453: LIST
68454: LIST
68455: PUSH
68456: LD_INT 3
68458: PUSH
68459: LD_INT 1
68461: PUSH
68462: EMPTY
68463: LIST
68464: LIST
68465: PUSH
68466: LD_INT 1
68468: PUSH
68469: LD_INT 3
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PUSH
68476: LD_INT 0
68478: PUSH
68479: LD_INT 3
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PUSH
68486: LD_INT 1
68488: NEG
68489: PUSH
68490: LD_INT 2
68492: PUSH
68493: EMPTY
68494: LIST
68495: LIST
68496: PUSH
68497: LD_INT 2
68499: NEG
68500: PUSH
68501: LD_INT 1
68503: PUSH
68504: EMPTY
68505: LIST
68506: LIST
68507: PUSH
68508: LD_INT 3
68510: NEG
68511: PUSH
68512: LD_INT 0
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: PUSH
68519: LD_INT 3
68521: NEG
68522: PUSH
68523: LD_INT 1
68525: NEG
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: LIST
68535: LIST
68536: LIST
68537: LIST
68538: LIST
68539: LIST
68540: LIST
68541: LIST
68542: LIST
68543: LIST
68544: LIST
68545: LIST
68546: LIST
68547: LIST
68548: LIST
68549: LIST
68550: LIST
68551: LIST
68552: LIST
68553: LIST
68554: LIST
68555: LIST
68556: LIST
68557: LIST
68558: LIST
68559: LIST
68560: LIST
68561: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68562: LD_ADDR_VAR 0 44
68566: PUSH
68567: LD_INT 0
68569: PUSH
68570: LD_INT 0
68572: PUSH
68573: EMPTY
68574: LIST
68575: LIST
68576: PUSH
68577: LD_INT 0
68579: PUSH
68580: LD_INT 1
68582: NEG
68583: PUSH
68584: EMPTY
68585: LIST
68586: LIST
68587: PUSH
68588: LD_INT 1
68590: PUSH
68591: LD_INT 0
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: PUSH
68598: LD_INT 1
68600: PUSH
68601: LD_INT 1
68603: PUSH
68604: EMPTY
68605: LIST
68606: LIST
68607: PUSH
68608: LD_INT 0
68610: PUSH
68611: LD_INT 1
68613: PUSH
68614: EMPTY
68615: LIST
68616: LIST
68617: PUSH
68618: LD_INT 1
68620: NEG
68621: PUSH
68622: LD_INT 0
68624: PUSH
68625: EMPTY
68626: LIST
68627: LIST
68628: PUSH
68629: LD_INT 1
68631: NEG
68632: PUSH
68633: LD_INT 1
68635: NEG
68636: PUSH
68637: EMPTY
68638: LIST
68639: LIST
68640: PUSH
68641: LD_INT 1
68643: NEG
68644: PUSH
68645: LD_INT 2
68647: NEG
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PUSH
68653: LD_INT 1
68655: PUSH
68656: LD_INT 1
68658: NEG
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: PUSH
68664: LD_INT 2
68666: PUSH
68667: LD_INT 0
68669: PUSH
68670: EMPTY
68671: LIST
68672: LIST
68673: PUSH
68674: LD_INT 2
68676: PUSH
68677: LD_INT 1
68679: PUSH
68680: EMPTY
68681: LIST
68682: LIST
68683: PUSH
68684: LD_INT 2
68686: PUSH
68687: LD_INT 2
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: PUSH
68694: LD_INT 1
68696: PUSH
68697: LD_INT 2
68699: PUSH
68700: EMPTY
68701: LIST
68702: LIST
68703: PUSH
68704: LD_INT 1
68706: NEG
68707: PUSH
68708: LD_INT 1
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: PUSH
68715: LD_INT 2
68717: NEG
68718: PUSH
68719: LD_INT 0
68721: PUSH
68722: EMPTY
68723: LIST
68724: LIST
68725: PUSH
68726: LD_INT 2
68728: NEG
68729: PUSH
68730: LD_INT 1
68732: NEG
68733: PUSH
68734: EMPTY
68735: LIST
68736: LIST
68737: PUSH
68738: LD_INT 2
68740: NEG
68741: PUSH
68742: LD_INT 2
68744: NEG
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 2
68752: NEG
68753: PUSH
68754: LD_INT 3
68756: NEG
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: PUSH
68762: LD_INT 2
68764: PUSH
68765: LD_INT 1
68767: NEG
68768: PUSH
68769: EMPTY
68770: LIST
68771: LIST
68772: PUSH
68773: LD_INT 3
68775: PUSH
68776: LD_INT 0
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PUSH
68783: LD_INT 3
68785: PUSH
68786: LD_INT 1
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 3
68795: PUSH
68796: LD_INT 2
68798: PUSH
68799: EMPTY
68800: LIST
68801: LIST
68802: PUSH
68803: LD_INT 3
68805: PUSH
68806: LD_INT 3
68808: PUSH
68809: EMPTY
68810: LIST
68811: LIST
68812: PUSH
68813: LD_INT 2
68815: PUSH
68816: LD_INT 3
68818: PUSH
68819: EMPTY
68820: LIST
68821: LIST
68822: PUSH
68823: LD_INT 2
68825: NEG
68826: PUSH
68827: LD_INT 1
68829: PUSH
68830: EMPTY
68831: LIST
68832: LIST
68833: PUSH
68834: LD_INT 3
68836: NEG
68837: PUSH
68838: LD_INT 0
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: PUSH
68845: LD_INT 3
68847: NEG
68848: PUSH
68849: LD_INT 1
68851: NEG
68852: PUSH
68853: EMPTY
68854: LIST
68855: LIST
68856: PUSH
68857: LD_INT 3
68859: NEG
68860: PUSH
68861: LD_INT 2
68863: NEG
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: PUSH
68869: LD_INT 3
68871: NEG
68872: PUSH
68873: LD_INT 3
68875: NEG
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: PUSH
68881: EMPTY
68882: LIST
68883: LIST
68884: LIST
68885: LIST
68886: LIST
68887: LIST
68888: LIST
68889: LIST
68890: LIST
68891: LIST
68892: LIST
68893: LIST
68894: LIST
68895: LIST
68896: LIST
68897: LIST
68898: LIST
68899: LIST
68900: LIST
68901: LIST
68902: LIST
68903: LIST
68904: LIST
68905: LIST
68906: LIST
68907: LIST
68908: LIST
68909: LIST
68910: LIST
68911: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68912: LD_ADDR_VAR 0 45
68916: PUSH
68917: LD_INT 0
68919: PUSH
68920: LD_INT 0
68922: PUSH
68923: EMPTY
68924: LIST
68925: LIST
68926: PUSH
68927: LD_INT 0
68929: PUSH
68930: LD_INT 1
68932: NEG
68933: PUSH
68934: EMPTY
68935: LIST
68936: LIST
68937: PUSH
68938: LD_INT 1
68940: PUSH
68941: LD_INT 0
68943: PUSH
68944: EMPTY
68945: LIST
68946: LIST
68947: PUSH
68948: LD_INT 1
68950: PUSH
68951: LD_INT 1
68953: PUSH
68954: EMPTY
68955: LIST
68956: LIST
68957: PUSH
68958: LD_INT 0
68960: PUSH
68961: LD_INT 1
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: LD_INT 1
68970: NEG
68971: PUSH
68972: LD_INT 0
68974: PUSH
68975: EMPTY
68976: LIST
68977: LIST
68978: PUSH
68979: LD_INT 1
68981: NEG
68982: PUSH
68983: LD_INT 1
68985: NEG
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: PUSH
68991: LD_INT 1
68993: NEG
68994: PUSH
68995: LD_INT 2
68997: NEG
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 0
69005: PUSH
69006: LD_INT 2
69008: NEG
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: LD_INT 1
69016: PUSH
69017: LD_INT 1
69019: NEG
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: PUSH
69025: LD_INT 2
69027: PUSH
69028: LD_INT 1
69030: PUSH
69031: EMPTY
69032: LIST
69033: LIST
69034: PUSH
69035: LD_INT 2
69037: PUSH
69038: LD_INT 2
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: PUSH
69045: LD_INT 1
69047: PUSH
69048: LD_INT 2
69050: PUSH
69051: EMPTY
69052: LIST
69053: LIST
69054: PUSH
69055: LD_INT 0
69057: PUSH
69058: LD_INT 2
69060: PUSH
69061: EMPTY
69062: LIST
69063: LIST
69064: PUSH
69065: LD_INT 1
69067: NEG
69068: PUSH
69069: LD_INT 1
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: LD_INT 2
69078: NEG
69079: PUSH
69080: LD_INT 1
69082: NEG
69083: PUSH
69084: EMPTY
69085: LIST
69086: LIST
69087: PUSH
69088: LD_INT 2
69090: NEG
69091: PUSH
69092: LD_INT 2
69094: NEG
69095: PUSH
69096: EMPTY
69097: LIST
69098: LIST
69099: PUSH
69100: LD_INT 2
69102: NEG
69103: PUSH
69104: LD_INT 3
69106: NEG
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: PUSH
69112: LD_INT 1
69114: NEG
69115: PUSH
69116: LD_INT 3
69118: NEG
69119: PUSH
69120: EMPTY
69121: LIST
69122: LIST
69123: PUSH
69124: LD_INT 0
69126: PUSH
69127: LD_INT 3
69129: NEG
69130: PUSH
69131: EMPTY
69132: LIST
69133: LIST
69134: PUSH
69135: LD_INT 1
69137: PUSH
69138: LD_INT 2
69140: NEG
69141: PUSH
69142: EMPTY
69143: LIST
69144: LIST
69145: PUSH
69146: LD_INT 3
69148: PUSH
69149: LD_INT 2
69151: PUSH
69152: EMPTY
69153: LIST
69154: LIST
69155: PUSH
69156: LD_INT 3
69158: PUSH
69159: LD_INT 3
69161: PUSH
69162: EMPTY
69163: LIST
69164: LIST
69165: PUSH
69166: LD_INT 2
69168: PUSH
69169: LD_INT 3
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: PUSH
69176: LD_INT 1
69178: PUSH
69179: LD_INT 3
69181: PUSH
69182: EMPTY
69183: LIST
69184: LIST
69185: PUSH
69186: LD_INT 0
69188: PUSH
69189: LD_INT 3
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: PUSH
69196: LD_INT 1
69198: NEG
69199: PUSH
69200: LD_INT 2
69202: PUSH
69203: EMPTY
69204: LIST
69205: LIST
69206: PUSH
69207: LD_INT 3
69209: NEG
69210: PUSH
69211: LD_INT 2
69213: NEG
69214: PUSH
69215: EMPTY
69216: LIST
69217: LIST
69218: PUSH
69219: LD_INT 3
69221: NEG
69222: PUSH
69223: LD_INT 3
69225: NEG
69226: PUSH
69227: EMPTY
69228: LIST
69229: LIST
69230: PUSH
69231: EMPTY
69232: LIST
69233: LIST
69234: LIST
69235: LIST
69236: LIST
69237: LIST
69238: LIST
69239: LIST
69240: LIST
69241: LIST
69242: LIST
69243: LIST
69244: LIST
69245: LIST
69246: LIST
69247: LIST
69248: LIST
69249: LIST
69250: LIST
69251: LIST
69252: LIST
69253: LIST
69254: LIST
69255: LIST
69256: LIST
69257: LIST
69258: LIST
69259: LIST
69260: LIST
69261: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69262: LD_ADDR_VAR 0 46
69266: PUSH
69267: LD_INT 0
69269: PUSH
69270: LD_INT 0
69272: PUSH
69273: EMPTY
69274: LIST
69275: LIST
69276: PUSH
69277: LD_INT 0
69279: PUSH
69280: LD_INT 1
69282: NEG
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PUSH
69288: LD_INT 1
69290: PUSH
69291: LD_INT 0
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: PUSH
69298: LD_INT 1
69300: PUSH
69301: LD_INT 1
69303: PUSH
69304: EMPTY
69305: LIST
69306: LIST
69307: PUSH
69308: LD_INT 0
69310: PUSH
69311: LD_INT 1
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: PUSH
69318: LD_INT 1
69320: NEG
69321: PUSH
69322: LD_INT 0
69324: PUSH
69325: EMPTY
69326: LIST
69327: LIST
69328: PUSH
69329: LD_INT 1
69331: NEG
69332: PUSH
69333: LD_INT 1
69335: NEG
69336: PUSH
69337: EMPTY
69338: LIST
69339: LIST
69340: PUSH
69341: LD_INT 1
69343: NEG
69344: PUSH
69345: LD_INT 2
69347: NEG
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: PUSH
69353: LD_INT 0
69355: PUSH
69356: LD_INT 2
69358: NEG
69359: PUSH
69360: EMPTY
69361: LIST
69362: LIST
69363: PUSH
69364: LD_INT 1
69366: PUSH
69367: LD_INT 1
69369: NEG
69370: PUSH
69371: EMPTY
69372: LIST
69373: LIST
69374: PUSH
69375: LD_INT 2
69377: PUSH
69378: LD_INT 0
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PUSH
69385: LD_INT 2
69387: PUSH
69388: LD_INT 1
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: PUSH
69395: LD_INT 1
69397: PUSH
69398: LD_INT 2
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: PUSH
69405: LD_INT 0
69407: PUSH
69408: LD_INT 2
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: PUSH
69415: LD_INT 1
69417: NEG
69418: PUSH
69419: LD_INT 1
69421: PUSH
69422: EMPTY
69423: LIST
69424: LIST
69425: PUSH
69426: LD_INT 2
69428: NEG
69429: PUSH
69430: LD_INT 0
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 2
69439: NEG
69440: PUSH
69441: LD_INT 1
69443: NEG
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 1
69451: NEG
69452: PUSH
69453: LD_INT 3
69455: NEG
69456: PUSH
69457: EMPTY
69458: LIST
69459: LIST
69460: PUSH
69461: LD_INT 0
69463: PUSH
69464: LD_INT 3
69466: NEG
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: PUSH
69472: LD_INT 1
69474: PUSH
69475: LD_INT 2
69477: NEG
69478: PUSH
69479: EMPTY
69480: LIST
69481: LIST
69482: PUSH
69483: LD_INT 2
69485: PUSH
69486: LD_INT 1
69488: NEG
69489: PUSH
69490: EMPTY
69491: LIST
69492: LIST
69493: PUSH
69494: LD_INT 3
69496: PUSH
69497: LD_INT 0
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PUSH
69504: LD_INT 3
69506: PUSH
69507: LD_INT 1
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: LD_INT 1
69516: PUSH
69517: LD_INT 3
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: LD_INT 0
69526: PUSH
69527: LD_INT 3
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PUSH
69534: LD_INT 1
69536: NEG
69537: PUSH
69538: LD_INT 2
69540: PUSH
69541: EMPTY
69542: LIST
69543: LIST
69544: PUSH
69545: LD_INT 2
69547: NEG
69548: PUSH
69549: LD_INT 1
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: PUSH
69556: LD_INT 3
69558: NEG
69559: PUSH
69560: LD_INT 0
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: LD_INT 3
69569: NEG
69570: PUSH
69571: LD_INT 1
69573: NEG
69574: PUSH
69575: EMPTY
69576: LIST
69577: LIST
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: LIST
69598: LIST
69599: LIST
69600: LIST
69601: LIST
69602: LIST
69603: LIST
69604: LIST
69605: LIST
69606: LIST
69607: LIST
69608: LIST
69609: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69610: LD_ADDR_VAR 0 47
69614: PUSH
69615: LD_INT 0
69617: PUSH
69618: LD_INT 0
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: PUSH
69625: LD_INT 0
69627: PUSH
69628: LD_INT 1
69630: NEG
69631: PUSH
69632: EMPTY
69633: LIST
69634: LIST
69635: PUSH
69636: LD_INT 1
69638: PUSH
69639: LD_INT 0
69641: PUSH
69642: EMPTY
69643: LIST
69644: LIST
69645: PUSH
69646: LD_INT 1
69648: PUSH
69649: LD_INT 1
69651: PUSH
69652: EMPTY
69653: LIST
69654: LIST
69655: PUSH
69656: LD_INT 0
69658: PUSH
69659: LD_INT 1
69661: PUSH
69662: EMPTY
69663: LIST
69664: LIST
69665: PUSH
69666: LD_INT 1
69668: NEG
69669: PUSH
69670: LD_INT 0
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 1
69679: NEG
69680: PUSH
69681: LD_INT 1
69683: NEG
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: PUSH
69689: LD_INT 1
69691: NEG
69692: PUSH
69693: LD_INT 2
69695: NEG
69696: PUSH
69697: EMPTY
69698: LIST
69699: LIST
69700: PUSH
69701: LD_INT 0
69703: PUSH
69704: LD_INT 2
69706: NEG
69707: PUSH
69708: EMPTY
69709: LIST
69710: LIST
69711: PUSH
69712: LD_INT 1
69714: PUSH
69715: LD_INT 1
69717: NEG
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: PUSH
69723: LD_INT 2
69725: NEG
69726: PUSH
69727: LD_INT 1
69729: NEG
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: PUSH
69735: LD_INT 2
69737: NEG
69738: PUSH
69739: LD_INT 2
69741: NEG
69742: PUSH
69743: EMPTY
69744: LIST
69745: LIST
69746: PUSH
69747: EMPTY
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: LIST
69755: LIST
69756: LIST
69757: LIST
69758: LIST
69759: LIST
69760: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
69761: LD_ADDR_VAR 0 48
69765: PUSH
69766: LD_INT 0
69768: PUSH
69769: LD_INT 0
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: PUSH
69776: LD_INT 0
69778: PUSH
69779: LD_INT 1
69781: NEG
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: LD_INT 1
69789: PUSH
69790: LD_INT 0
69792: PUSH
69793: EMPTY
69794: LIST
69795: LIST
69796: PUSH
69797: LD_INT 1
69799: PUSH
69800: LD_INT 1
69802: PUSH
69803: EMPTY
69804: LIST
69805: LIST
69806: PUSH
69807: LD_INT 0
69809: PUSH
69810: LD_INT 1
69812: PUSH
69813: EMPTY
69814: LIST
69815: LIST
69816: PUSH
69817: LD_INT 1
69819: NEG
69820: PUSH
69821: LD_INT 0
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: PUSH
69828: LD_INT 1
69830: NEG
69831: PUSH
69832: LD_INT 1
69834: NEG
69835: PUSH
69836: EMPTY
69837: LIST
69838: LIST
69839: PUSH
69840: LD_INT 1
69842: NEG
69843: PUSH
69844: LD_INT 2
69846: NEG
69847: PUSH
69848: EMPTY
69849: LIST
69850: LIST
69851: PUSH
69852: LD_INT 0
69854: PUSH
69855: LD_INT 2
69857: NEG
69858: PUSH
69859: EMPTY
69860: LIST
69861: LIST
69862: PUSH
69863: LD_INT 1
69865: PUSH
69866: LD_INT 1
69868: NEG
69869: PUSH
69870: EMPTY
69871: LIST
69872: LIST
69873: PUSH
69874: LD_INT 2
69876: PUSH
69877: LD_INT 0
69879: PUSH
69880: EMPTY
69881: LIST
69882: LIST
69883: PUSH
69884: LD_INT 2
69886: PUSH
69887: LD_INT 1
69889: PUSH
69890: EMPTY
69891: LIST
69892: LIST
69893: PUSH
69894: EMPTY
69895: LIST
69896: LIST
69897: LIST
69898: LIST
69899: LIST
69900: LIST
69901: LIST
69902: LIST
69903: LIST
69904: LIST
69905: LIST
69906: LIST
69907: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
69908: LD_ADDR_VAR 0 49
69912: PUSH
69913: LD_INT 0
69915: PUSH
69916: LD_INT 0
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: PUSH
69923: LD_INT 0
69925: PUSH
69926: LD_INT 1
69928: NEG
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: LD_INT 1
69936: PUSH
69937: LD_INT 0
69939: PUSH
69940: EMPTY
69941: LIST
69942: LIST
69943: PUSH
69944: LD_INT 1
69946: PUSH
69947: LD_INT 1
69949: PUSH
69950: EMPTY
69951: LIST
69952: LIST
69953: PUSH
69954: LD_INT 0
69956: PUSH
69957: LD_INT 1
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: PUSH
69964: LD_INT 1
69966: NEG
69967: PUSH
69968: LD_INT 0
69970: PUSH
69971: EMPTY
69972: LIST
69973: LIST
69974: PUSH
69975: LD_INT 1
69977: NEG
69978: PUSH
69979: LD_INT 1
69981: NEG
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: PUSH
69987: LD_INT 1
69989: PUSH
69990: LD_INT 1
69992: NEG
69993: PUSH
69994: EMPTY
69995: LIST
69996: LIST
69997: PUSH
69998: LD_INT 2
70000: PUSH
70001: LD_INT 0
70003: PUSH
70004: EMPTY
70005: LIST
70006: LIST
70007: PUSH
70008: LD_INT 2
70010: PUSH
70011: LD_INT 1
70013: PUSH
70014: EMPTY
70015: LIST
70016: LIST
70017: PUSH
70018: LD_INT 2
70020: PUSH
70021: LD_INT 2
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: PUSH
70028: LD_INT 1
70030: PUSH
70031: LD_INT 2
70033: PUSH
70034: EMPTY
70035: LIST
70036: LIST
70037: PUSH
70038: EMPTY
70039: LIST
70040: LIST
70041: LIST
70042: LIST
70043: LIST
70044: LIST
70045: LIST
70046: LIST
70047: LIST
70048: LIST
70049: LIST
70050: LIST
70051: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
70052: LD_ADDR_VAR 0 50
70056: PUSH
70057: LD_INT 0
70059: PUSH
70060: LD_INT 0
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 0
70069: PUSH
70070: LD_INT 1
70072: NEG
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: LD_INT 1
70080: PUSH
70081: LD_INT 0
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PUSH
70088: LD_INT 1
70090: PUSH
70091: LD_INT 1
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 0
70100: PUSH
70101: LD_INT 1
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: LD_INT 1
70110: NEG
70111: PUSH
70112: LD_INT 0
70114: PUSH
70115: EMPTY
70116: LIST
70117: LIST
70118: PUSH
70119: LD_INT 1
70121: NEG
70122: PUSH
70123: LD_INT 1
70125: NEG
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: LD_INT 2
70133: PUSH
70134: LD_INT 1
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 2
70143: PUSH
70144: LD_INT 2
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: PUSH
70151: LD_INT 1
70153: PUSH
70154: LD_INT 2
70156: PUSH
70157: EMPTY
70158: LIST
70159: LIST
70160: PUSH
70161: LD_INT 0
70163: PUSH
70164: LD_INT 2
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: PUSH
70171: LD_INT 1
70173: NEG
70174: PUSH
70175: LD_INT 1
70177: PUSH
70178: EMPTY
70179: LIST
70180: LIST
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: LIST
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
70196: LD_ADDR_VAR 0 51
70200: PUSH
70201: LD_INT 0
70203: PUSH
70204: LD_INT 0
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 0
70213: PUSH
70214: LD_INT 1
70216: NEG
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PUSH
70222: LD_INT 1
70224: PUSH
70225: LD_INT 0
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 1
70234: PUSH
70235: LD_INT 1
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: LD_INT 0
70244: PUSH
70245: LD_INT 1
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 1
70254: NEG
70255: PUSH
70256: LD_INT 0
70258: PUSH
70259: EMPTY
70260: LIST
70261: LIST
70262: PUSH
70263: LD_INT 1
70265: NEG
70266: PUSH
70267: LD_INT 1
70269: NEG
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 1
70277: PUSH
70278: LD_INT 2
70280: PUSH
70281: EMPTY
70282: LIST
70283: LIST
70284: PUSH
70285: LD_INT 0
70287: PUSH
70288: LD_INT 2
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 1
70297: NEG
70298: PUSH
70299: LD_INT 1
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: PUSH
70306: LD_INT 2
70308: NEG
70309: PUSH
70310: LD_INT 0
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: PUSH
70317: LD_INT 2
70319: NEG
70320: PUSH
70321: LD_INT 1
70323: NEG
70324: PUSH
70325: EMPTY
70326: LIST
70327: LIST
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: LIST
70335: LIST
70336: LIST
70337: LIST
70338: LIST
70339: LIST
70340: LIST
70341: LIST
70342: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70343: LD_ADDR_VAR 0 52
70347: PUSH
70348: LD_INT 0
70350: PUSH
70351: LD_INT 0
70353: PUSH
70354: EMPTY
70355: LIST
70356: LIST
70357: PUSH
70358: LD_INT 0
70360: PUSH
70361: LD_INT 1
70363: NEG
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 1
70371: PUSH
70372: LD_INT 0
70374: PUSH
70375: EMPTY
70376: LIST
70377: LIST
70378: PUSH
70379: LD_INT 1
70381: PUSH
70382: LD_INT 1
70384: PUSH
70385: EMPTY
70386: LIST
70387: LIST
70388: PUSH
70389: LD_INT 0
70391: PUSH
70392: LD_INT 1
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PUSH
70399: LD_INT 1
70401: NEG
70402: PUSH
70403: LD_INT 0
70405: PUSH
70406: EMPTY
70407: LIST
70408: LIST
70409: PUSH
70410: LD_INT 1
70412: NEG
70413: PUSH
70414: LD_INT 1
70416: NEG
70417: PUSH
70418: EMPTY
70419: LIST
70420: LIST
70421: PUSH
70422: LD_INT 1
70424: NEG
70425: PUSH
70426: LD_INT 2
70428: NEG
70429: PUSH
70430: EMPTY
70431: LIST
70432: LIST
70433: PUSH
70434: LD_INT 1
70436: NEG
70437: PUSH
70438: LD_INT 1
70440: PUSH
70441: EMPTY
70442: LIST
70443: LIST
70444: PUSH
70445: LD_INT 2
70447: NEG
70448: PUSH
70449: LD_INT 0
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PUSH
70456: LD_INT 2
70458: NEG
70459: PUSH
70460: LD_INT 1
70462: NEG
70463: PUSH
70464: EMPTY
70465: LIST
70466: LIST
70467: PUSH
70468: LD_INT 2
70470: NEG
70471: PUSH
70472: LD_INT 2
70474: NEG
70475: PUSH
70476: EMPTY
70477: LIST
70478: LIST
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: LIST
70484: LIST
70485: LIST
70486: LIST
70487: LIST
70488: LIST
70489: LIST
70490: LIST
70491: LIST
70492: LIST
70493: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70494: LD_ADDR_VAR 0 53
70498: PUSH
70499: LD_INT 0
70501: PUSH
70502: LD_INT 0
70504: PUSH
70505: EMPTY
70506: LIST
70507: LIST
70508: PUSH
70509: LD_INT 0
70511: PUSH
70512: LD_INT 1
70514: NEG
70515: PUSH
70516: EMPTY
70517: LIST
70518: LIST
70519: PUSH
70520: LD_INT 1
70522: PUSH
70523: LD_INT 0
70525: PUSH
70526: EMPTY
70527: LIST
70528: LIST
70529: PUSH
70530: LD_INT 1
70532: PUSH
70533: LD_INT 1
70535: PUSH
70536: EMPTY
70537: LIST
70538: LIST
70539: PUSH
70540: LD_INT 0
70542: PUSH
70543: LD_INT 1
70545: PUSH
70546: EMPTY
70547: LIST
70548: LIST
70549: PUSH
70550: LD_INT 1
70552: NEG
70553: PUSH
70554: LD_INT 0
70556: PUSH
70557: EMPTY
70558: LIST
70559: LIST
70560: PUSH
70561: LD_INT 1
70563: NEG
70564: PUSH
70565: LD_INT 1
70567: NEG
70568: PUSH
70569: EMPTY
70570: LIST
70571: LIST
70572: PUSH
70573: LD_INT 1
70575: NEG
70576: PUSH
70577: LD_INT 2
70579: NEG
70580: PUSH
70581: EMPTY
70582: LIST
70583: LIST
70584: PUSH
70585: LD_INT 0
70587: PUSH
70588: LD_INT 2
70590: NEG
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: LD_INT 1
70598: PUSH
70599: LD_INT 1
70601: NEG
70602: PUSH
70603: EMPTY
70604: LIST
70605: LIST
70606: PUSH
70607: LD_INT 2
70609: PUSH
70610: LD_INT 0
70612: PUSH
70613: EMPTY
70614: LIST
70615: LIST
70616: PUSH
70617: LD_INT 2
70619: PUSH
70620: LD_INT 1
70622: PUSH
70623: EMPTY
70624: LIST
70625: LIST
70626: PUSH
70627: LD_INT 2
70629: PUSH
70630: LD_INT 2
70632: PUSH
70633: EMPTY
70634: LIST
70635: LIST
70636: PUSH
70637: LD_INT 1
70639: PUSH
70640: LD_INT 2
70642: PUSH
70643: EMPTY
70644: LIST
70645: LIST
70646: PUSH
70647: LD_INT 0
70649: PUSH
70650: LD_INT 2
70652: PUSH
70653: EMPTY
70654: LIST
70655: LIST
70656: PUSH
70657: LD_INT 1
70659: NEG
70660: PUSH
70661: LD_INT 1
70663: PUSH
70664: EMPTY
70665: LIST
70666: LIST
70667: PUSH
70668: LD_INT 2
70670: NEG
70671: PUSH
70672: LD_INT 0
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: PUSH
70679: LD_INT 2
70681: NEG
70682: PUSH
70683: LD_INT 1
70685: NEG
70686: PUSH
70687: EMPTY
70688: LIST
70689: LIST
70690: PUSH
70691: LD_INT 2
70693: NEG
70694: PUSH
70695: LD_INT 2
70697: NEG
70698: PUSH
70699: EMPTY
70700: LIST
70701: LIST
70702: PUSH
70703: EMPTY
70704: LIST
70705: LIST
70706: LIST
70707: LIST
70708: LIST
70709: LIST
70710: LIST
70711: LIST
70712: LIST
70713: LIST
70714: LIST
70715: LIST
70716: LIST
70717: LIST
70718: LIST
70719: LIST
70720: LIST
70721: LIST
70722: LIST
70723: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70724: LD_ADDR_VAR 0 54
70728: PUSH
70729: LD_INT 0
70731: PUSH
70732: LD_INT 0
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: LD_INT 0
70741: PUSH
70742: LD_INT 1
70744: NEG
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 1
70752: PUSH
70753: LD_INT 0
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: PUSH
70760: LD_INT 1
70762: PUSH
70763: LD_INT 1
70765: PUSH
70766: EMPTY
70767: LIST
70768: LIST
70769: PUSH
70770: LD_INT 0
70772: PUSH
70773: LD_INT 1
70775: PUSH
70776: EMPTY
70777: LIST
70778: LIST
70779: PUSH
70780: LD_INT 1
70782: NEG
70783: PUSH
70784: LD_INT 0
70786: PUSH
70787: EMPTY
70788: LIST
70789: LIST
70790: PUSH
70791: LD_INT 1
70793: NEG
70794: PUSH
70795: LD_INT 1
70797: NEG
70798: PUSH
70799: EMPTY
70800: LIST
70801: LIST
70802: PUSH
70803: LD_INT 1
70805: NEG
70806: PUSH
70807: LD_INT 2
70809: NEG
70810: PUSH
70811: EMPTY
70812: LIST
70813: LIST
70814: PUSH
70815: LD_INT 0
70817: PUSH
70818: LD_INT 2
70820: NEG
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: PUSH
70826: LD_INT 1
70828: PUSH
70829: LD_INT 1
70831: NEG
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: PUSH
70837: LD_INT 2
70839: PUSH
70840: LD_INT 0
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 2
70849: PUSH
70850: LD_INT 1
70852: PUSH
70853: EMPTY
70854: LIST
70855: LIST
70856: PUSH
70857: LD_INT 2
70859: PUSH
70860: LD_INT 2
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: PUSH
70867: LD_INT 1
70869: PUSH
70870: LD_INT 2
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: PUSH
70877: LD_INT 0
70879: PUSH
70880: LD_INT 2
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 1
70889: NEG
70890: PUSH
70891: LD_INT 1
70893: PUSH
70894: EMPTY
70895: LIST
70896: LIST
70897: PUSH
70898: LD_INT 2
70900: NEG
70901: PUSH
70902: LD_INT 0
70904: PUSH
70905: EMPTY
70906: LIST
70907: LIST
70908: PUSH
70909: LD_INT 2
70911: NEG
70912: PUSH
70913: LD_INT 1
70915: NEG
70916: PUSH
70917: EMPTY
70918: LIST
70919: LIST
70920: PUSH
70921: LD_INT 2
70923: NEG
70924: PUSH
70925: LD_INT 2
70927: NEG
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: LIST
70937: LIST
70938: LIST
70939: LIST
70940: LIST
70941: LIST
70942: LIST
70943: LIST
70944: LIST
70945: LIST
70946: LIST
70947: LIST
70948: LIST
70949: LIST
70950: LIST
70951: LIST
70952: LIST
70953: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70954: LD_ADDR_VAR 0 55
70958: PUSH
70959: LD_INT 0
70961: PUSH
70962: LD_INT 0
70964: PUSH
70965: EMPTY
70966: LIST
70967: LIST
70968: PUSH
70969: LD_INT 0
70971: PUSH
70972: LD_INT 1
70974: NEG
70975: PUSH
70976: EMPTY
70977: LIST
70978: LIST
70979: PUSH
70980: LD_INT 1
70982: PUSH
70983: LD_INT 0
70985: PUSH
70986: EMPTY
70987: LIST
70988: LIST
70989: PUSH
70990: LD_INT 1
70992: PUSH
70993: LD_INT 1
70995: PUSH
70996: EMPTY
70997: LIST
70998: LIST
70999: PUSH
71000: LD_INT 0
71002: PUSH
71003: LD_INT 1
71005: PUSH
71006: EMPTY
71007: LIST
71008: LIST
71009: PUSH
71010: LD_INT 1
71012: NEG
71013: PUSH
71014: LD_INT 0
71016: PUSH
71017: EMPTY
71018: LIST
71019: LIST
71020: PUSH
71021: LD_INT 1
71023: NEG
71024: PUSH
71025: LD_INT 1
71027: NEG
71028: PUSH
71029: EMPTY
71030: LIST
71031: LIST
71032: PUSH
71033: LD_INT 1
71035: NEG
71036: PUSH
71037: LD_INT 2
71039: NEG
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: PUSH
71045: LD_INT 0
71047: PUSH
71048: LD_INT 2
71050: NEG
71051: PUSH
71052: EMPTY
71053: LIST
71054: LIST
71055: PUSH
71056: LD_INT 1
71058: PUSH
71059: LD_INT 1
71061: NEG
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: LD_INT 2
71069: PUSH
71070: LD_INT 0
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: PUSH
71077: LD_INT 2
71079: PUSH
71080: LD_INT 1
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PUSH
71087: LD_INT 2
71089: PUSH
71090: LD_INT 2
71092: PUSH
71093: EMPTY
71094: LIST
71095: LIST
71096: PUSH
71097: LD_INT 1
71099: PUSH
71100: LD_INT 2
71102: PUSH
71103: EMPTY
71104: LIST
71105: LIST
71106: PUSH
71107: LD_INT 0
71109: PUSH
71110: LD_INT 2
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: PUSH
71117: LD_INT 1
71119: NEG
71120: PUSH
71121: LD_INT 1
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PUSH
71128: LD_INT 2
71130: NEG
71131: PUSH
71132: LD_INT 0
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PUSH
71139: LD_INT 2
71141: NEG
71142: PUSH
71143: LD_INT 1
71145: NEG
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: PUSH
71151: LD_INT 2
71153: NEG
71154: PUSH
71155: LD_INT 2
71157: NEG
71158: PUSH
71159: EMPTY
71160: LIST
71161: LIST
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: LIST
71167: LIST
71168: LIST
71169: LIST
71170: LIST
71171: LIST
71172: LIST
71173: LIST
71174: LIST
71175: LIST
71176: LIST
71177: LIST
71178: LIST
71179: LIST
71180: LIST
71181: LIST
71182: LIST
71183: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71184: LD_ADDR_VAR 0 56
71188: PUSH
71189: LD_INT 0
71191: PUSH
71192: LD_INT 0
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PUSH
71199: LD_INT 0
71201: PUSH
71202: LD_INT 1
71204: NEG
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PUSH
71210: LD_INT 1
71212: PUSH
71213: LD_INT 0
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: LD_INT 1
71222: PUSH
71223: LD_INT 1
71225: PUSH
71226: EMPTY
71227: LIST
71228: LIST
71229: PUSH
71230: LD_INT 0
71232: PUSH
71233: LD_INT 1
71235: PUSH
71236: EMPTY
71237: LIST
71238: LIST
71239: PUSH
71240: LD_INT 1
71242: NEG
71243: PUSH
71244: LD_INT 0
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: LD_INT 1
71253: NEG
71254: PUSH
71255: LD_INT 1
71257: NEG
71258: PUSH
71259: EMPTY
71260: LIST
71261: LIST
71262: PUSH
71263: LD_INT 1
71265: NEG
71266: PUSH
71267: LD_INT 2
71269: NEG
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PUSH
71275: LD_INT 0
71277: PUSH
71278: LD_INT 2
71280: NEG
71281: PUSH
71282: EMPTY
71283: LIST
71284: LIST
71285: PUSH
71286: LD_INT 1
71288: PUSH
71289: LD_INT 1
71291: NEG
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 2
71299: PUSH
71300: LD_INT 0
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: LD_INT 2
71309: PUSH
71310: LD_INT 1
71312: PUSH
71313: EMPTY
71314: LIST
71315: LIST
71316: PUSH
71317: LD_INT 2
71319: PUSH
71320: LD_INT 2
71322: PUSH
71323: EMPTY
71324: LIST
71325: LIST
71326: PUSH
71327: LD_INT 1
71329: PUSH
71330: LD_INT 2
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: PUSH
71337: LD_INT 0
71339: PUSH
71340: LD_INT 2
71342: PUSH
71343: EMPTY
71344: LIST
71345: LIST
71346: PUSH
71347: LD_INT 1
71349: NEG
71350: PUSH
71351: LD_INT 1
71353: PUSH
71354: EMPTY
71355: LIST
71356: LIST
71357: PUSH
71358: LD_INT 2
71360: NEG
71361: PUSH
71362: LD_INT 0
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: PUSH
71369: LD_INT 2
71371: NEG
71372: PUSH
71373: LD_INT 1
71375: NEG
71376: PUSH
71377: EMPTY
71378: LIST
71379: LIST
71380: PUSH
71381: LD_INT 2
71383: NEG
71384: PUSH
71385: LD_INT 2
71387: NEG
71388: PUSH
71389: EMPTY
71390: LIST
71391: LIST
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: LIST
71397: LIST
71398: LIST
71399: LIST
71400: LIST
71401: LIST
71402: LIST
71403: LIST
71404: LIST
71405: LIST
71406: LIST
71407: LIST
71408: LIST
71409: LIST
71410: LIST
71411: LIST
71412: LIST
71413: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71414: LD_ADDR_VAR 0 57
71418: PUSH
71419: LD_INT 0
71421: PUSH
71422: LD_INT 0
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PUSH
71429: LD_INT 0
71431: PUSH
71432: LD_INT 1
71434: NEG
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: PUSH
71440: LD_INT 1
71442: PUSH
71443: LD_INT 0
71445: PUSH
71446: EMPTY
71447: LIST
71448: LIST
71449: PUSH
71450: LD_INT 1
71452: PUSH
71453: LD_INT 1
71455: PUSH
71456: EMPTY
71457: LIST
71458: LIST
71459: PUSH
71460: LD_INT 0
71462: PUSH
71463: LD_INT 1
71465: PUSH
71466: EMPTY
71467: LIST
71468: LIST
71469: PUSH
71470: LD_INT 1
71472: NEG
71473: PUSH
71474: LD_INT 0
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 1
71483: NEG
71484: PUSH
71485: LD_INT 1
71487: NEG
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: PUSH
71493: LD_INT 1
71495: NEG
71496: PUSH
71497: LD_INT 2
71499: NEG
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: PUSH
71505: LD_INT 0
71507: PUSH
71508: LD_INT 2
71510: NEG
71511: PUSH
71512: EMPTY
71513: LIST
71514: LIST
71515: PUSH
71516: LD_INT 1
71518: PUSH
71519: LD_INT 1
71521: NEG
71522: PUSH
71523: EMPTY
71524: LIST
71525: LIST
71526: PUSH
71527: LD_INT 2
71529: PUSH
71530: LD_INT 0
71532: PUSH
71533: EMPTY
71534: LIST
71535: LIST
71536: PUSH
71537: LD_INT 2
71539: PUSH
71540: LD_INT 1
71542: PUSH
71543: EMPTY
71544: LIST
71545: LIST
71546: PUSH
71547: LD_INT 2
71549: PUSH
71550: LD_INT 2
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PUSH
71557: LD_INT 1
71559: PUSH
71560: LD_INT 2
71562: PUSH
71563: EMPTY
71564: LIST
71565: LIST
71566: PUSH
71567: LD_INT 0
71569: PUSH
71570: LD_INT 2
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: PUSH
71577: LD_INT 1
71579: NEG
71580: PUSH
71581: LD_INT 1
71583: PUSH
71584: EMPTY
71585: LIST
71586: LIST
71587: PUSH
71588: LD_INT 2
71590: NEG
71591: PUSH
71592: LD_INT 0
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: PUSH
71599: LD_INT 2
71601: NEG
71602: PUSH
71603: LD_INT 1
71605: NEG
71606: PUSH
71607: EMPTY
71608: LIST
71609: LIST
71610: PUSH
71611: LD_INT 2
71613: NEG
71614: PUSH
71615: LD_INT 2
71617: NEG
71618: PUSH
71619: EMPTY
71620: LIST
71621: LIST
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: LIST
71627: LIST
71628: LIST
71629: LIST
71630: LIST
71631: LIST
71632: LIST
71633: LIST
71634: LIST
71635: LIST
71636: LIST
71637: LIST
71638: LIST
71639: LIST
71640: LIST
71641: LIST
71642: LIST
71643: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71644: LD_ADDR_VAR 0 58
71648: PUSH
71649: LD_INT 0
71651: PUSH
71652: LD_INT 0
71654: PUSH
71655: EMPTY
71656: LIST
71657: LIST
71658: PUSH
71659: LD_INT 0
71661: PUSH
71662: LD_INT 1
71664: NEG
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 1
71672: PUSH
71673: LD_INT 0
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PUSH
71680: LD_INT 1
71682: PUSH
71683: LD_INT 1
71685: PUSH
71686: EMPTY
71687: LIST
71688: LIST
71689: PUSH
71690: LD_INT 0
71692: PUSH
71693: LD_INT 1
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: PUSH
71700: LD_INT 1
71702: NEG
71703: PUSH
71704: LD_INT 0
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: LD_INT 1
71713: NEG
71714: PUSH
71715: LD_INT 1
71717: NEG
71718: PUSH
71719: EMPTY
71720: LIST
71721: LIST
71722: PUSH
71723: LD_INT 1
71725: NEG
71726: PUSH
71727: LD_INT 2
71729: NEG
71730: PUSH
71731: EMPTY
71732: LIST
71733: LIST
71734: PUSH
71735: LD_INT 0
71737: PUSH
71738: LD_INT 2
71740: NEG
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: PUSH
71746: LD_INT 1
71748: PUSH
71749: LD_INT 1
71751: NEG
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 2
71759: PUSH
71760: LD_INT 0
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: PUSH
71767: LD_INT 2
71769: PUSH
71770: LD_INT 1
71772: PUSH
71773: EMPTY
71774: LIST
71775: LIST
71776: PUSH
71777: LD_INT 2
71779: PUSH
71780: LD_INT 2
71782: PUSH
71783: EMPTY
71784: LIST
71785: LIST
71786: PUSH
71787: LD_INT 1
71789: PUSH
71790: LD_INT 2
71792: PUSH
71793: EMPTY
71794: LIST
71795: LIST
71796: PUSH
71797: LD_INT 0
71799: PUSH
71800: LD_INT 2
71802: PUSH
71803: EMPTY
71804: LIST
71805: LIST
71806: PUSH
71807: LD_INT 1
71809: NEG
71810: PUSH
71811: LD_INT 1
71813: PUSH
71814: EMPTY
71815: LIST
71816: LIST
71817: PUSH
71818: LD_INT 2
71820: NEG
71821: PUSH
71822: LD_INT 0
71824: PUSH
71825: EMPTY
71826: LIST
71827: LIST
71828: PUSH
71829: LD_INT 2
71831: NEG
71832: PUSH
71833: LD_INT 1
71835: NEG
71836: PUSH
71837: EMPTY
71838: LIST
71839: LIST
71840: PUSH
71841: LD_INT 2
71843: NEG
71844: PUSH
71845: LD_INT 2
71847: NEG
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: LIST
71857: LIST
71858: LIST
71859: LIST
71860: LIST
71861: LIST
71862: LIST
71863: LIST
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: LIST
71873: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
71874: LD_ADDR_VAR 0 59
71878: PUSH
71879: LD_INT 0
71881: PUSH
71882: LD_INT 0
71884: PUSH
71885: EMPTY
71886: LIST
71887: LIST
71888: PUSH
71889: LD_INT 0
71891: PUSH
71892: LD_INT 1
71894: NEG
71895: PUSH
71896: EMPTY
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 1
71902: PUSH
71903: LD_INT 0
71905: PUSH
71906: EMPTY
71907: LIST
71908: LIST
71909: PUSH
71910: LD_INT 1
71912: PUSH
71913: LD_INT 1
71915: PUSH
71916: EMPTY
71917: LIST
71918: LIST
71919: PUSH
71920: LD_INT 0
71922: PUSH
71923: LD_INT 1
71925: PUSH
71926: EMPTY
71927: LIST
71928: LIST
71929: PUSH
71930: LD_INT 1
71932: NEG
71933: PUSH
71934: LD_INT 0
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: PUSH
71941: LD_INT 1
71943: NEG
71944: PUSH
71945: LD_INT 1
71947: NEG
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: LIST
71957: LIST
71958: LIST
71959: LIST
71960: LIST
71961: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
71962: LD_ADDR_VAR 0 60
71966: PUSH
71967: LD_INT 0
71969: PUSH
71970: LD_INT 0
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: PUSH
71977: LD_INT 0
71979: PUSH
71980: LD_INT 1
71982: NEG
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: LD_INT 1
71990: PUSH
71991: LD_INT 0
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 1
72000: PUSH
72001: LD_INT 1
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: PUSH
72008: LD_INT 0
72010: PUSH
72011: LD_INT 1
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: PUSH
72018: LD_INT 1
72020: NEG
72021: PUSH
72022: LD_INT 0
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: PUSH
72029: LD_INT 1
72031: NEG
72032: PUSH
72033: LD_INT 1
72035: NEG
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: EMPTY
72042: LIST
72043: LIST
72044: LIST
72045: LIST
72046: LIST
72047: LIST
72048: LIST
72049: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72050: LD_ADDR_VAR 0 61
72054: PUSH
72055: LD_INT 0
72057: PUSH
72058: LD_INT 0
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: PUSH
72065: LD_INT 0
72067: PUSH
72068: LD_INT 1
72070: NEG
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 1
72078: PUSH
72079: LD_INT 0
72081: PUSH
72082: EMPTY
72083: LIST
72084: LIST
72085: PUSH
72086: LD_INT 1
72088: PUSH
72089: LD_INT 1
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 0
72098: PUSH
72099: LD_INT 1
72101: PUSH
72102: EMPTY
72103: LIST
72104: LIST
72105: PUSH
72106: LD_INT 1
72108: NEG
72109: PUSH
72110: LD_INT 0
72112: PUSH
72113: EMPTY
72114: LIST
72115: LIST
72116: PUSH
72117: LD_INT 1
72119: NEG
72120: PUSH
72121: LD_INT 1
72123: NEG
72124: PUSH
72125: EMPTY
72126: LIST
72127: LIST
72128: PUSH
72129: EMPTY
72130: LIST
72131: LIST
72132: LIST
72133: LIST
72134: LIST
72135: LIST
72136: LIST
72137: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72138: LD_ADDR_VAR 0 62
72142: PUSH
72143: LD_INT 0
72145: PUSH
72146: LD_INT 0
72148: PUSH
72149: EMPTY
72150: LIST
72151: LIST
72152: PUSH
72153: LD_INT 0
72155: PUSH
72156: LD_INT 1
72158: NEG
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: PUSH
72164: LD_INT 1
72166: PUSH
72167: LD_INT 0
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PUSH
72174: LD_INT 1
72176: PUSH
72177: LD_INT 1
72179: PUSH
72180: EMPTY
72181: LIST
72182: LIST
72183: PUSH
72184: LD_INT 0
72186: PUSH
72187: LD_INT 1
72189: PUSH
72190: EMPTY
72191: LIST
72192: LIST
72193: PUSH
72194: LD_INT 1
72196: NEG
72197: PUSH
72198: LD_INT 0
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: PUSH
72205: LD_INT 1
72207: NEG
72208: PUSH
72209: LD_INT 1
72211: NEG
72212: PUSH
72213: EMPTY
72214: LIST
72215: LIST
72216: PUSH
72217: EMPTY
72218: LIST
72219: LIST
72220: LIST
72221: LIST
72222: LIST
72223: LIST
72224: LIST
72225: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72226: LD_ADDR_VAR 0 63
72230: PUSH
72231: LD_INT 0
72233: PUSH
72234: LD_INT 0
72236: PUSH
72237: EMPTY
72238: LIST
72239: LIST
72240: PUSH
72241: LD_INT 0
72243: PUSH
72244: LD_INT 1
72246: NEG
72247: PUSH
72248: EMPTY
72249: LIST
72250: LIST
72251: PUSH
72252: LD_INT 1
72254: PUSH
72255: LD_INT 0
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: PUSH
72262: LD_INT 1
72264: PUSH
72265: LD_INT 1
72267: PUSH
72268: EMPTY
72269: LIST
72270: LIST
72271: PUSH
72272: LD_INT 0
72274: PUSH
72275: LD_INT 1
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: PUSH
72282: LD_INT 1
72284: NEG
72285: PUSH
72286: LD_INT 0
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PUSH
72293: LD_INT 1
72295: NEG
72296: PUSH
72297: LD_INT 1
72299: NEG
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: EMPTY
72306: LIST
72307: LIST
72308: LIST
72309: LIST
72310: LIST
72311: LIST
72312: LIST
72313: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72314: LD_ADDR_VAR 0 64
72318: PUSH
72319: LD_INT 0
72321: PUSH
72322: LD_INT 0
72324: PUSH
72325: EMPTY
72326: LIST
72327: LIST
72328: PUSH
72329: LD_INT 0
72331: PUSH
72332: LD_INT 1
72334: NEG
72335: PUSH
72336: EMPTY
72337: LIST
72338: LIST
72339: PUSH
72340: LD_INT 1
72342: PUSH
72343: LD_INT 0
72345: PUSH
72346: EMPTY
72347: LIST
72348: LIST
72349: PUSH
72350: LD_INT 1
72352: PUSH
72353: LD_INT 1
72355: PUSH
72356: EMPTY
72357: LIST
72358: LIST
72359: PUSH
72360: LD_INT 0
72362: PUSH
72363: LD_INT 1
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: PUSH
72370: LD_INT 1
72372: NEG
72373: PUSH
72374: LD_INT 0
72376: PUSH
72377: EMPTY
72378: LIST
72379: LIST
72380: PUSH
72381: LD_INT 1
72383: NEG
72384: PUSH
72385: LD_INT 1
72387: NEG
72388: PUSH
72389: EMPTY
72390: LIST
72391: LIST
72392: PUSH
72393: EMPTY
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: LIST
72401: ST_TO_ADDR
// end ; 1 :
72402: GO 78299
72404: LD_INT 1
72406: DOUBLE
72407: EQUAL
72408: IFTRUE 72412
72410: GO 75035
72412: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72413: LD_ADDR_VAR 0 11
72417: PUSH
72418: LD_INT 1
72420: NEG
72421: PUSH
72422: LD_INT 3
72424: NEG
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 0
72432: PUSH
72433: LD_INT 3
72435: NEG
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: PUSH
72441: LD_INT 1
72443: PUSH
72444: LD_INT 2
72446: NEG
72447: PUSH
72448: EMPTY
72449: LIST
72450: LIST
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: LIST
72456: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72457: LD_ADDR_VAR 0 12
72461: PUSH
72462: LD_INT 2
72464: PUSH
72465: LD_INT 1
72467: NEG
72468: PUSH
72469: EMPTY
72470: LIST
72471: LIST
72472: PUSH
72473: LD_INT 3
72475: PUSH
72476: LD_INT 0
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: PUSH
72483: LD_INT 3
72485: PUSH
72486: LD_INT 1
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: LIST
72497: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72498: LD_ADDR_VAR 0 13
72502: PUSH
72503: LD_INT 3
72505: PUSH
72506: LD_INT 2
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: LD_INT 3
72515: PUSH
72516: LD_INT 3
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PUSH
72523: LD_INT 2
72525: PUSH
72526: LD_INT 3
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: PUSH
72533: EMPTY
72534: LIST
72535: LIST
72536: LIST
72537: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
72538: LD_ADDR_VAR 0 14
72542: PUSH
72543: LD_INT 1
72545: PUSH
72546: LD_INT 3
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PUSH
72553: LD_INT 0
72555: PUSH
72556: LD_INT 3
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: PUSH
72563: LD_INT 1
72565: NEG
72566: PUSH
72567: LD_INT 2
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PUSH
72574: EMPTY
72575: LIST
72576: LIST
72577: LIST
72578: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72579: LD_ADDR_VAR 0 15
72583: PUSH
72584: LD_INT 2
72586: NEG
72587: PUSH
72588: LD_INT 1
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 3
72597: NEG
72598: PUSH
72599: LD_INT 0
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: PUSH
72606: LD_INT 3
72608: NEG
72609: PUSH
72610: LD_INT 1
72612: NEG
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: PUSH
72618: EMPTY
72619: LIST
72620: LIST
72621: LIST
72622: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72623: LD_ADDR_VAR 0 16
72627: PUSH
72628: LD_INT 2
72630: NEG
72631: PUSH
72632: LD_INT 3
72634: NEG
72635: PUSH
72636: EMPTY
72637: LIST
72638: LIST
72639: PUSH
72640: LD_INT 3
72642: NEG
72643: PUSH
72644: LD_INT 2
72646: NEG
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: LD_INT 3
72654: NEG
72655: PUSH
72656: LD_INT 3
72658: NEG
72659: PUSH
72660: EMPTY
72661: LIST
72662: LIST
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: LIST
72668: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72669: LD_ADDR_VAR 0 17
72673: PUSH
72674: LD_INT 1
72676: NEG
72677: PUSH
72678: LD_INT 3
72680: NEG
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 0
72688: PUSH
72689: LD_INT 3
72691: NEG
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 1
72699: PUSH
72700: LD_INT 2
72702: NEG
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PUSH
72708: EMPTY
72709: LIST
72710: LIST
72711: LIST
72712: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72713: LD_ADDR_VAR 0 18
72717: PUSH
72718: LD_INT 2
72720: PUSH
72721: LD_INT 1
72723: NEG
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: PUSH
72729: LD_INT 3
72731: PUSH
72732: LD_INT 0
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: PUSH
72739: LD_INT 3
72741: PUSH
72742: LD_INT 1
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: LIST
72753: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72754: LD_ADDR_VAR 0 19
72758: PUSH
72759: LD_INT 3
72761: PUSH
72762: LD_INT 2
72764: PUSH
72765: EMPTY
72766: LIST
72767: LIST
72768: PUSH
72769: LD_INT 3
72771: PUSH
72772: LD_INT 3
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: PUSH
72779: LD_INT 2
72781: PUSH
72782: LD_INT 3
72784: PUSH
72785: EMPTY
72786: LIST
72787: LIST
72788: PUSH
72789: EMPTY
72790: LIST
72791: LIST
72792: LIST
72793: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
72794: LD_ADDR_VAR 0 20
72798: PUSH
72799: LD_INT 1
72801: PUSH
72802: LD_INT 3
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: PUSH
72809: LD_INT 0
72811: PUSH
72812: LD_INT 3
72814: PUSH
72815: EMPTY
72816: LIST
72817: LIST
72818: PUSH
72819: LD_INT 1
72821: NEG
72822: PUSH
72823: LD_INT 2
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: LIST
72834: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72835: LD_ADDR_VAR 0 21
72839: PUSH
72840: LD_INT 2
72842: NEG
72843: PUSH
72844: LD_INT 1
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: PUSH
72851: LD_INT 3
72853: NEG
72854: PUSH
72855: LD_INT 0
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 3
72864: NEG
72865: PUSH
72866: LD_INT 1
72868: NEG
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: LIST
72878: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72879: LD_ADDR_VAR 0 22
72883: PUSH
72884: LD_INT 2
72886: NEG
72887: PUSH
72888: LD_INT 3
72890: NEG
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PUSH
72896: LD_INT 3
72898: NEG
72899: PUSH
72900: LD_INT 2
72902: NEG
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 3
72910: NEG
72911: PUSH
72912: LD_INT 3
72914: NEG
72915: PUSH
72916: EMPTY
72917: LIST
72918: LIST
72919: PUSH
72920: EMPTY
72921: LIST
72922: LIST
72923: LIST
72924: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
72925: LD_ADDR_VAR 0 23
72929: PUSH
72930: LD_INT 0
72932: PUSH
72933: LD_INT 3
72935: NEG
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: LD_INT 1
72943: NEG
72944: PUSH
72945: LD_INT 4
72947: NEG
72948: PUSH
72949: EMPTY
72950: LIST
72951: LIST
72952: PUSH
72953: LD_INT 1
72955: PUSH
72956: LD_INT 3
72958: NEG
72959: PUSH
72960: EMPTY
72961: LIST
72962: LIST
72963: PUSH
72964: EMPTY
72965: LIST
72966: LIST
72967: LIST
72968: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
72969: LD_ADDR_VAR 0 24
72973: PUSH
72974: LD_INT 3
72976: PUSH
72977: LD_INT 0
72979: PUSH
72980: EMPTY
72981: LIST
72982: LIST
72983: PUSH
72984: LD_INT 3
72986: PUSH
72987: LD_INT 1
72989: NEG
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: PUSH
72995: LD_INT 4
72997: PUSH
72998: LD_INT 1
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: LIST
73009: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
73010: LD_ADDR_VAR 0 25
73014: PUSH
73015: LD_INT 3
73017: PUSH
73018: LD_INT 3
73020: PUSH
73021: EMPTY
73022: LIST
73023: LIST
73024: PUSH
73025: LD_INT 4
73027: PUSH
73028: LD_INT 3
73030: PUSH
73031: EMPTY
73032: LIST
73033: LIST
73034: PUSH
73035: LD_INT 3
73037: PUSH
73038: LD_INT 4
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: LIST
73049: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
73050: LD_ADDR_VAR 0 26
73054: PUSH
73055: LD_INT 0
73057: PUSH
73058: LD_INT 3
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: PUSH
73065: LD_INT 1
73067: PUSH
73068: LD_INT 4
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: PUSH
73075: LD_INT 1
73077: NEG
73078: PUSH
73079: LD_INT 3
73081: PUSH
73082: EMPTY
73083: LIST
73084: LIST
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: LIST
73090: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
73091: LD_ADDR_VAR 0 27
73095: PUSH
73096: LD_INT 3
73098: NEG
73099: PUSH
73100: LD_INT 0
73102: PUSH
73103: EMPTY
73104: LIST
73105: LIST
73106: PUSH
73107: LD_INT 3
73109: NEG
73110: PUSH
73111: LD_INT 1
73113: PUSH
73114: EMPTY
73115: LIST
73116: LIST
73117: PUSH
73118: LD_INT 4
73120: NEG
73121: PUSH
73122: LD_INT 1
73124: NEG
73125: PUSH
73126: EMPTY
73127: LIST
73128: LIST
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: LIST
73134: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
73135: LD_ADDR_VAR 0 28
73139: PUSH
73140: LD_INT 3
73142: NEG
73143: PUSH
73144: LD_INT 3
73146: NEG
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: PUSH
73152: LD_INT 3
73154: NEG
73155: PUSH
73156: LD_INT 4
73158: NEG
73159: PUSH
73160: EMPTY
73161: LIST
73162: LIST
73163: PUSH
73164: LD_INT 4
73166: NEG
73167: PUSH
73168: LD_INT 3
73170: NEG
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: LIST
73180: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
73181: LD_ADDR_VAR 0 29
73185: PUSH
73186: LD_INT 1
73188: NEG
73189: PUSH
73190: LD_INT 3
73192: NEG
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: PUSH
73198: LD_INT 0
73200: PUSH
73201: LD_INT 3
73203: NEG
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: PUSH
73209: LD_INT 1
73211: PUSH
73212: LD_INT 2
73214: NEG
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PUSH
73220: LD_INT 1
73222: NEG
73223: PUSH
73224: LD_INT 4
73226: NEG
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 0
73234: PUSH
73235: LD_INT 4
73237: NEG
73238: PUSH
73239: EMPTY
73240: LIST
73241: LIST
73242: PUSH
73243: LD_INT 1
73245: PUSH
73246: LD_INT 3
73248: NEG
73249: PUSH
73250: EMPTY
73251: LIST
73252: LIST
73253: PUSH
73254: LD_INT 1
73256: NEG
73257: PUSH
73258: LD_INT 5
73260: NEG
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: PUSH
73266: LD_INT 0
73268: PUSH
73269: LD_INT 5
73271: NEG
73272: PUSH
73273: EMPTY
73274: LIST
73275: LIST
73276: PUSH
73277: LD_INT 1
73279: PUSH
73280: LD_INT 4
73282: NEG
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: PUSH
73288: LD_INT 1
73290: NEG
73291: PUSH
73292: LD_INT 6
73294: NEG
73295: PUSH
73296: EMPTY
73297: LIST
73298: LIST
73299: PUSH
73300: LD_INT 0
73302: PUSH
73303: LD_INT 6
73305: NEG
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: PUSH
73311: LD_INT 1
73313: PUSH
73314: LD_INT 5
73316: NEG
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PUSH
73322: EMPTY
73323: LIST
73324: LIST
73325: LIST
73326: LIST
73327: LIST
73328: LIST
73329: LIST
73330: LIST
73331: LIST
73332: LIST
73333: LIST
73334: LIST
73335: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
73336: LD_ADDR_VAR 0 30
73340: PUSH
73341: LD_INT 2
73343: PUSH
73344: LD_INT 1
73346: NEG
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 3
73354: PUSH
73355: LD_INT 0
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: LD_INT 3
73364: PUSH
73365: LD_INT 1
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: LD_INT 3
73374: PUSH
73375: LD_INT 1
73377: NEG
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: PUSH
73383: LD_INT 4
73385: PUSH
73386: LD_INT 0
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 4
73395: PUSH
73396: LD_INT 1
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: LD_INT 4
73405: PUSH
73406: LD_INT 1
73408: NEG
73409: PUSH
73410: EMPTY
73411: LIST
73412: LIST
73413: PUSH
73414: LD_INT 5
73416: PUSH
73417: LD_INT 0
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: PUSH
73424: LD_INT 5
73426: PUSH
73427: LD_INT 1
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: PUSH
73434: LD_INT 5
73436: PUSH
73437: LD_INT 1
73439: NEG
73440: PUSH
73441: EMPTY
73442: LIST
73443: LIST
73444: PUSH
73445: LD_INT 6
73447: PUSH
73448: LD_INT 0
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: PUSH
73455: LD_INT 6
73457: PUSH
73458: LD_INT 1
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: EMPTY
73466: LIST
73467: LIST
73468: LIST
73469: LIST
73470: LIST
73471: LIST
73472: LIST
73473: LIST
73474: LIST
73475: LIST
73476: LIST
73477: LIST
73478: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
73479: LD_ADDR_VAR 0 31
73483: PUSH
73484: LD_INT 3
73486: PUSH
73487: LD_INT 2
73489: PUSH
73490: EMPTY
73491: LIST
73492: LIST
73493: PUSH
73494: LD_INT 3
73496: PUSH
73497: LD_INT 3
73499: PUSH
73500: EMPTY
73501: LIST
73502: LIST
73503: PUSH
73504: LD_INT 2
73506: PUSH
73507: LD_INT 3
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: PUSH
73514: LD_INT 4
73516: PUSH
73517: LD_INT 3
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: PUSH
73524: LD_INT 4
73526: PUSH
73527: LD_INT 4
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PUSH
73534: LD_INT 3
73536: PUSH
73537: LD_INT 4
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PUSH
73544: LD_INT 5
73546: PUSH
73547: LD_INT 4
73549: PUSH
73550: EMPTY
73551: LIST
73552: LIST
73553: PUSH
73554: LD_INT 5
73556: PUSH
73557: LD_INT 5
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: PUSH
73564: LD_INT 4
73566: PUSH
73567: LD_INT 5
73569: PUSH
73570: EMPTY
73571: LIST
73572: LIST
73573: PUSH
73574: LD_INT 6
73576: PUSH
73577: LD_INT 5
73579: PUSH
73580: EMPTY
73581: LIST
73582: LIST
73583: PUSH
73584: LD_INT 6
73586: PUSH
73587: LD_INT 6
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: LD_INT 5
73596: PUSH
73597: LD_INT 6
73599: PUSH
73600: EMPTY
73601: LIST
73602: LIST
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: LIST
73608: LIST
73609: LIST
73610: LIST
73611: LIST
73612: LIST
73613: LIST
73614: LIST
73615: LIST
73616: LIST
73617: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
73618: LD_ADDR_VAR 0 32
73622: PUSH
73623: LD_INT 1
73625: PUSH
73626: LD_INT 3
73628: PUSH
73629: EMPTY
73630: LIST
73631: LIST
73632: PUSH
73633: LD_INT 0
73635: PUSH
73636: LD_INT 3
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: PUSH
73643: LD_INT 1
73645: NEG
73646: PUSH
73647: LD_INT 2
73649: PUSH
73650: EMPTY
73651: LIST
73652: LIST
73653: PUSH
73654: LD_INT 1
73656: PUSH
73657: LD_INT 4
73659: PUSH
73660: EMPTY
73661: LIST
73662: LIST
73663: PUSH
73664: LD_INT 0
73666: PUSH
73667: LD_INT 4
73669: PUSH
73670: EMPTY
73671: LIST
73672: LIST
73673: PUSH
73674: LD_INT 1
73676: NEG
73677: PUSH
73678: LD_INT 3
73680: PUSH
73681: EMPTY
73682: LIST
73683: LIST
73684: PUSH
73685: LD_INT 1
73687: PUSH
73688: LD_INT 5
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: PUSH
73695: LD_INT 0
73697: PUSH
73698: LD_INT 5
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: PUSH
73705: LD_INT 1
73707: NEG
73708: PUSH
73709: LD_INT 4
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: PUSH
73716: LD_INT 1
73718: PUSH
73719: LD_INT 6
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: PUSH
73726: LD_INT 0
73728: PUSH
73729: LD_INT 6
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: PUSH
73736: LD_INT 1
73738: NEG
73739: PUSH
73740: LD_INT 5
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: EMPTY
73748: LIST
73749: LIST
73750: LIST
73751: LIST
73752: LIST
73753: LIST
73754: LIST
73755: LIST
73756: LIST
73757: LIST
73758: LIST
73759: LIST
73760: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
73761: LD_ADDR_VAR 0 33
73765: PUSH
73766: LD_INT 2
73768: NEG
73769: PUSH
73770: LD_INT 1
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: LD_INT 3
73779: NEG
73780: PUSH
73781: LD_INT 0
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: LD_INT 3
73790: NEG
73791: PUSH
73792: LD_INT 1
73794: NEG
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PUSH
73800: LD_INT 3
73802: NEG
73803: PUSH
73804: LD_INT 1
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: LD_INT 4
73813: NEG
73814: PUSH
73815: LD_INT 0
73817: PUSH
73818: EMPTY
73819: LIST
73820: LIST
73821: PUSH
73822: LD_INT 4
73824: NEG
73825: PUSH
73826: LD_INT 1
73828: NEG
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: LD_INT 4
73836: NEG
73837: PUSH
73838: LD_INT 1
73840: PUSH
73841: EMPTY
73842: LIST
73843: LIST
73844: PUSH
73845: LD_INT 5
73847: NEG
73848: PUSH
73849: LD_INT 0
73851: PUSH
73852: EMPTY
73853: LIST
73854: LIST
73855: PUSH
73856: LD_INT 5
73858: NEG
73859: PUSH
73860: LD_INT 1
73862: NEG
73863: PUSH
73864: EMPTY
73865: LIST
73866: LIST
73867: PUSH
73868: LD_INT 5
73870: NEG
73871: PUSH
73872: LD_INT 1
73874: PUSH
73875: EMPTY
73876: LIST
73877: LIST
73878: PUSH
73879: LD_INT 6
73881: NEG
73882: PUSH
73883: LD_INT 0
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: PUSH
73890: LD_INT 6
73892: NEG
73893: PUSH
73894: LD_INT 1
73896: NEG
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: PUSH
73902: EMPTY
73903: LIST
73904: LIST
73905: LIST
73906: LIST
73907: LIST
73908: LIST
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: LIST
73914: LIST
73915: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
73916: LD_ADDR_VAR 0 34
73920: PUSH
73921: LD_INT 2
73923: NEG
73924: PUSH
73925: LD_INT 3
73927: NEG
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 3
73935: NEG
73936: PUSH
73937: LD_INT 2
73939: NEG
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: LD_INT 3
73947: NEG
73948: PUSH
73949: LD_INT 3
73951: NEG
73952: PUSH
73953: EMPTY
73954: LIST
73955: LIST
73956: PUSH
73957: LD_INT 3
73959: NEG
73960: PUSH
73961: LD_INT 4
73963: NEG
73964: PUSH
73965: EMPTY
73966: LIST
73967: LIST
73968: PUSH
73969: LD_INT 4
73971: NEG
73972: PUSH
73973: LD_INT 3
73975: NEG
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: PUSH
73981: LD_INT 4
73983: NEG
73984: PUSH
73985: LD_INT 4
73987: NEG
73988: PUSH
73989: EMPTY
73990: LIST
73991: LIST
73992: PUSH
73993: LD_INT 4
73995: NEG
73996: PUSH
73997: LD_INT 5
73999: NEG
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: PUSH
74005: LD_INT 5
74007: NEG
74008: PUSH
74009: LD_INT 4
74011: NEG
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 5
74019: NEG
74020: PUSH
74021: LD_INT 5
74023: NEG
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: LD_INT 5
74031: NEG
74032: PUSH
74033: LD_INT 6
74035: NEG
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: LD_INT 6
74043: NEG
74044: PUSH
74045: LD_INT 5
74047: NEG
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PUSH
74053: LD_INT 6
74055: NEG
74056: PUSH
74057: LD_INT 6
74059: NEG
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: PUSH
74065: EMPTY
74066: LIST
74067: LIST
74068: LIST
74069: LIST
74070: LIST
74071: LIST
74072: LIST
74073: LIST
74074: LIST
74075: LIST
74076: LIST
74077: LIST
74078: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
74079: LD_ADDR_VAR 0 41
74083: PUSH
74084: LD_INT 0
74086: PUSH
74087: LD_INT 2
74089: NEG
74090: PUSH
74091: EMPTY
74092: LIST
74093: LIST
74094: PUSH
74095: LD_INT 1
74097: NEG
74098: PUSH
74099: LD_INT 3
74101: NEG
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: LD_INT 1
74109: PUSH
74110: LD_INT 2
74112: NEG
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: LIST
74122: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
74123: LD_ADDR_VAR 0 42
74127: PUSH
74128: LD_INT 2
74130: PUSH
74131: LD_INT 0
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 2
74140: PUSH
74141: LD_INT 1
74143: NEG
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 3
74151: PUSH
74152: LD_INT 1
74154: PUSH
74155: EMPTY
74156: LIST
74157: LIST
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: LIST
74163: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
74164: LD_ADDR_VAR 0 43
74168: PUSH
74169: LD_INT 2
74171: PUSH
74172: LD_INT 2
74174: PUSH
74175: EMPTY
74176: LIST
74177: LIST
74178: PUSH
74179: LD_INT 3
74181: PUSH
74182: LD_INT 2
74184: PUSH
74185: EMPTY
74186: LIST
74187: LIST
74188: PUSH
74189: LD_INT 2
74191: PUSH
74192: LD_INT 3
74194: PUSH
74195: EMPTY
74196: LIST
74197: LIST
74198: PUSH
74199: EMPTY
74200: LIST
74201: LIST
74202: LIST
74203: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
74204: LD_ADDR_VAR 0 44
74208: PUSH
74209: LD_INT 0
74211: PUSH
74212: LD_INT 2
74214: PUSH
74215: EMPTY
74216: LIST
74217: LIST
74218: PUSH
74219: LD_INT 1
74221: PUSH
74222: LD_INT 3
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PUSH
74229: LD_INT 1
74231: NEG
74232: PUSH
74233: LD_INT 2
74235: PUSH
74236: EMPTY
74237: LIST
74238: LIST
74239: PUSH
74240: EMPTY
74241: LIST
74242: LIST
74243: LIST
74244: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
74245: LD_ADDR_VAR 0 45
74249: PUSH
74250: LD_INT 2
74252: NEG
74253: PUSH
74254: LD_INT 0
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: PUSH
74261: LD_INT 2
74263: NEG
74264: PUSH
74265: LD_INT 1
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 3
74274: NEG
74275: PUSH
74276: LD_INT 1
74278: NEG
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: EMPTY
74285: LIST
74286: LIST
74287: LIST
74288: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
74289: LD_ADDR_VAR 0 46
74293: PUSH
74294: LD_INT 2
74296: NEG
74297: PUSH
74298: LD_INT 2
74300: NEG
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PUSH
74306: LD_INT 2
74308: NEG
74309: PUSH
74310: LD_INT 3
74312: NEG
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: PUSH
74318: LD_INT 3
74320: NEG
74321: PUSH
74322: LD_INT 2
74324: NEG
74325: PUSH
74326: EMPTY
74327: LIST
74328: LIST
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: LIST
74334: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
74335: LD_ADDR_VAR 0 47
74339: PUSH
74340: LD_INT 2
74342: NEG
74343: PUSH
74344: LD_INT 3
74346: NEG
74347: PUSH
74348: EMPTY
74349: LIST
74350: LIST
74351: PUSH
74352: LD_INT 1
74354: NEG
74355: PUSH
74356: LD_INT 3
74358: NEG
74359: PUSH
74360: EMPTY
74361: LIST
74362: LIST
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
74368: LD_ADDR_VAR 0 48
74372: PUSH
74373: LD_INT 1
74375: PUSH
74376: LD_INT 2
74378: NEG
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: LD_INT 2
74386: PUSH
74387: LD_INT 1
74389: NEG
74390: PUSH
74391: EMPTY
74392: LIST
74393: LIST
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
74399: LD_ADDR_VAR 0 49
74403: PUSH
74404: LD_INT 3
74406: PUSH
74407: LD_INT 1
74409: PUSH
74410: EMPTY
74411: LIST
74412: LIST
74413: PUSH
74414: LD_INT 3
74416: PUSH
74417: LD_INT 2
74419: PUSH
74420: EMPTY
74421: LIST
74422: LIST
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
74428: LD_ADDR_VAR 0 50
74432: PUSH
74433: LD_INT 2
74435: PUSH
74436: LD_INT 3
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: PUSH
74443: LD_INT 1
74445: PUSH
74446: LD_INT 3
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: PUSH
74453: EMPTY
74454: LIST
74455: LIST
74456: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
74457: LD_ADDR_VAR 0 51
74461: PUSH
74462: LD_INT 1
74464: NEG
74465: PUSH
74466: LD_INT 2
74468: PUSH
74469: EMPTY
74470: LIST
74471: LIST
74472: PUSH
74473: LD_INT 2
74475: NEG
74476: PUSH
74477: LD_INT 1
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
74488: LD_ADDR_VAR 0 52
74492: PUSH
74493: LD_INT 3
74495: NEG
74496: PUSH
74497: LD_INT 1
74499: NEG
74500: PUSH
74501: EMPTY
74502: LIST
74503: LIST
74504: PUSH
74505: LD_INT 3
74507: NEG
74508: PUSH
74509: LD_INT 2
74511: NEG
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: EMPTY
74518: LIST
74519: LIST
74520: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74521: LD_ADDR_VAR 0 53
74525: PUSH
74526: LD_INT 1
74528: NEG
74529: PUSH
74530: LD_INT 3
74532: NEG
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: LD_INT 0
74540: PUSH
74541: LD_INT 3
74543: NEG
74544: PUSH
74545: EMPTY
74546: LIST
74547: LIST
74548: PUSH
74549: LD_INT 1
74551: PUSH
74552: LD_INT 2
74554: NEG
74555: PUSH
74556: EMPTY
74557: LIST
74558: LIST
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: LIST
74564: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74565: LD_ADDR_VAR 0 54
74569: PUSH
74570: LD_INT 2
74572: PUSH
74573: LD_INT 1
74575: NEG
74576: PUSH
74577: EMPTY
74578: LIST
74579: LIST
74580: PUSH
74581: LD_INT 3
74583: PUSH
74584: LD_INT 0
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: PUSH
74591: LD_INT 3
74593: PUSH
74594: LD_INT 1
74596: PUSH
74597: EMPTY
74598: LIST
74599: LIST
74600: PUSH
74601: EMPTY
74602: LIST
74603: LIST
74604: LIST
74605: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74606: LD_ADDR_VAR 0 55
74610: PUSH
74611: LD_INT 3
74613: PUSH
74614: LD_INT 2
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: PUSH
74621: LD_INT 3
74623: PUSH
74624: LD_INT 3
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: LD_INT 2
74633: PUSH
74634: LD_INT 3
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PUSH
74641: EMPTY
74642: LIST
74643: LIST
74644: LIST
74645: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74646: LD_ADDR_VAR 0 56
74650: PUSH
74651: LD_INT 1
74653: PUSH
74654: LD_INT 3
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 0
74663: PUSH
74664: LD_INT 3
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: PUSH
74671: LD_INT 1
74673: NEG
74674: PUSH
74675: LD_INT 2
74677: PUSH
74678: EMPTY
74679: LIST
74680: LIST
74681: PUSH
74682: EMPTY
74683: LIST
74684: LIST
74685: LIST
74686: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74687: LD_ADDR_VAR 0 57
74691: PUSH
74692: LD_INT 2
74694: NEG
74695: PUSH
74696: LD_INT 1
74698: PUSH
74699: EMPTY
74700: LIST
74701: LIST
74702: PUSH
74703: LD_INT 3
74705: NEG
74706: PUSH
74707: LD_INT 0
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: PUSH
74714: LD_INT 3
74716: NEG
74717: PUSH
74718: LD_INT 1
74720: NEG
74721: PUSH
74722: EMPTY
74723: LIST
74724: LIST
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: LIST
74730: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74731: LD_ADDR_VAR 0 58
74735: PUSH
74736: LD_INT 2
74738: NEG
74739: PUSH
74740: LD_INT 3
74742: NEG
74743: PUSH
74744: EMPTY
74745: LIST
74746: LIST
74747: PUSH
74748: LD_INT 3
74750: NEG
74751: PUSH
74752: LD_INT 2
74754: NEG
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: PUSH
74760: LD_INT 3
74762: NEG
74763: PUSH
74764: LD_INT 3
74766: NEG
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: LIST
74776: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
74777: LD_ADDR_VAR 0 59
74781: PUSH
74782: LD_INT 1
74784: NEG
74785: PUSH
74786: LD_INT 2
74788: NEG
74789: PUSH
74790: EMPTY
74791: LIST
74792: LIST
74793: PUSH
74794: LD_INT 0
74796: PUSH
74797: LD_INT 2
74799: NEG
74800: PUSH
74801: EMPTY
74802: LIST
74803: LIST
74804: PUSH
74805: LD_INT 1
74807: PUSH
74808: LD_INT 1
74810: NEG
74811: PUSH
74812: EMPTY
74813: LIST
74814: LIST
74815: PUSH
74816: EMPTY
74817: LIST
74818: LIST
74819: LIST
74820: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74821: LD_ADDR_VAR 0 60
74825: PUSH
74826: LD_INT 1
74828: PUSH
74829: LD_INT 1
74831: NEG
74832: PUSH
74833: EMPTY
74834: LIST
74835: LIST
74836: PUSH
74837: LD_INT 2
74839: PUSH
74840: LD_INT 0
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: PUSH
74847: LD_INT 2
74849: PUSH
74850: LD_INT 1
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: LIST
74861: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74862: LD_ADDR_VAR 0 61
74866: PUSH
74867: LD_INT 2
74869: PUSH
74870: LD_INT 1
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 2
74879: PUSH
74880: LD_INT 2
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 1
74889: PUSH
74890: LD_INT 2
74892: PUSH
74893: EMPTY
74894: LIST
74895: LIST
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: LIST
74901: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74902: LD_ADDR_VAR 0 62
74906: PUSH
74907: LD_INT 1
74909: PUSH
74910: LD_INT 2
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 0
74919: PUSH
74920: LD_INT 2
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: LD_INT 1
74929: NEG
74930: PUSH
74931: LD_INT 1
74933: PUSH
74934: EMPTY
74935: LIST
74936: LIST
74937: PUSH
74938: EMPTY
74939: LIST
74940: LIST
74941: LIST
74942: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74943: LD_ADDR_VAR 0 63
74947: PUSH
74948: LD_INT 1
74950: NEG
74951: PUSH
74952: LD_INT 1
74954: PUSH
74955: EMPTY
74956: LIST
74957: LIST
74958: PUSH
74959: LD_INT 2
74961: NEG
74962: PUSH
74963: LD_INT 0
74965: PUSH
74966: EMPTY
74967: LIST
74968: LIST
74969: PUSH
74970: LD_INT 2
74972: NEG
74973: PUSH
74974: LD_INT 1
74976: NEG
74977: PUSH
74978: EMPTY
74979: LIST
74980: LIST
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: LIST
74986: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74987: LD_ADDR_VAR 0 64
74991: PUSH
74992: LD_INT 1
74994: NEG
74995: PUSH
74996: LD_INT 2
74998: NEG
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: PUSH
75004: LD_INT 2
75006: NEG
75007: PUSH
75008: LD_INT 1
75010: NEG
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PUSH
75016: LD_INT 2
75018: NEG
75019: PUSH
75020: LD_INT 2
75022: NEG
75023: PUSH
75024: EMPTY
75025: LIST
75026: LIST
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: LIST
75032: ST_TO_ADDR
// end ; 2 :
75033: GO 78299
75035: LD_INT 2
75037: DOUBLE
75038: EQUAL
75039: IFTRUE 75043
75041: GO 78298
75043: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
75044: LD_ADDR_VAR 0 29
75048: PUSH
75049: LD_INT 4
75051: PUSH
75052: LD_INT 0
75054: PUSH
75055: EMPTY
75056: LIST
75057: LIST
75058: PUSH
75059: LD_INT 4
75061: PUSH
75062: LD_INT 1
75064: NEG
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: PUSH
75070: LD_INT 5
75072: PUSH
75073: LD_INT 0
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: PUSH
75080: LD_INT 5
75082: PUSH
75083: LD_INT 1
75085: PUSH
75086: EMPTY
75087: LIST
75088: LIST
75089: PUSH
75090: LD_INT 4
75092: PUSH
75093: LD_INT 1
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PUSH
75100: LD_INT 3
75102: PUSH
75103: LD_INT 0
75105: PUSH
75106: EMPTY
75107: LIST
75108: LIST
75109: PUSH
75110: LD_INT 3
75112: PUSH
75113: LD_INT 1
75115: NEG
75116: PUSH
75117: EMPTY
75118: LIST
75119: LIST
75120: PUSH
75121: LD_INT 3
75123: PUSH
75124: LD_INT 2
75126: NEG
75127: PUSH
75128: EMPTY
75129: LIST
75130: LIST
75131: PUSH
75132: LD_INT 5
75134: PUSH
75135: LD_INT 2
75137: PUSH
75138: EMPTY
75139: LIST
75140: LIST
75141: PUSH
75142: LD_INT 3
75144: PUSH
75145: LD_INT 3
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PUSH
75152: LD_INT 3
75154: PUSH
75155: LD_INT 2
75157: PUSH
75158: EMPTY
75159: LIST
75160: LIST
75161: PUSH
75162: LD_INT 4
75164: PUSH
75165: LD_INT 3
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 4
75174: PUSH
75175: LD_INT 4
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 3
75184: PUSH
75185: LD_INT 4
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: LD_INT 2
75194: PUSH
75195: LD_INT 3
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: PUSH
75202: LD_INT 2
75204: PUSH
75205: LD_INT 2
75207: PUSH
75208: EMPTY
75209: LIST
75210: LIST
75211: PUSH
75212: LD_INT 4
75214: PUSH
75215: LD_INT 2
75217: PUSH
75218: EMPTY
75219: LIST
75220: LIST
75221: PUSH
75222: LD_INT 2
75224: PUSH
75225: LD_INT 4
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PUSH
75232: LD_INT 0
75234: PUSH
75235: LD_INT 4
75237: PUSH
75238: EMPTY
75239: LIST
75240: LIST
75241: PUSH
75242: LD_INT 0
75244: PUSH
75245: LD_INT 3
75247: PUSH
75248: EMPTY
75249: LIST
75250: LIST
75251: PUSH
75252: LD_INT 1
75254: PUSH
75255: LD_INT 4
75257: PUSH
75258: EMPTY
75259: LIST
75260: LIST
75261: PUSH
75262: LD_INT 1
75264: PUSH
75265: LD_INT 5
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PUSH
75272: LD_INT 0
75274: PUSH
75275: LD_INT 5
75277: PUSH
75278: EMPTY
75279: LIST
75280: LIST
75281: PUSH
75282: LD_INT 1
75284: NEG
75285: PUSH
75286: LD_INT 4
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: PUSH
75293: LD_INT 1
75295: NEG
75296: PUSH
75297: LD_INT 3
75299: PUSH
75300: EMPTY
75301: LIST
75302: LIST
75303: PUSH
75304: LD_INT 2
75306: PUSH
75307: LD_INT 5
75309: PUSH
75310: EMPTY
75311: LIST
75312: LIST
75313: PUSH
75314: LD_INT 2
75316: NEG
75317: PUSH
75318: LD_INT 3
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 3
75327: NEG
75328: PUSH
75329: LD_INT 0
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 3
75338: NEG
75339: PUSH
75340: LD_INT 1
75342: NEG
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: PUSH
75348: LD_INT 2
75350: NEG
75351: PUSH
75352: LD_INT 0
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: PUSH
75359: LD_INT 2
75361: NEG
75362: PUSH
75363: LD_INT 1
75365: PUSH
75366: EMPTY
75367: LIST
75368: LIST
75369: PUSH
75370: LD_INT 3
75372: NEG
75373: PUSH
75374: LD_INT 1
75376: PUSH
75377: EMPTY
75378: LIST
75379: LIST
75380: PUSH
75381: LD_INT 4
75383: NEG
75384: PUSH
75385: LD_INT 0
75387: PUSH
75388: EMPTY
75389: LIST
75390: LIST
75391: PUSH
75392: LD_INT 4
75394: NEG
75395: PUSH
75396: LD_INT 1
75398: NEG
75399: PUSH
75400: EMPTY
75401: LIST
75402: LIST
75403: PUSH
75404: LD_INT 4
75406: NEG
75407: PUSH
75408: LD_INT 2
75410: NEG
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: PUSH
75416: LD_INT 2
75418: NEG
75419: PUSH
75420: LD_INT 2
75422: PUSH
75423: EMPTY
75424: LIST
75425: LIST
75426: PUSH
75427: LD_INT 4
75429: NEG
75430: PUSH
75431: LD_INT 4
75433: NEG
75434: PUSH
75435: EMPTY
75436: LIST
75437: LIST
75438: PUSH
75439: LD_INT 4
75441: NEG
75442: PUSH
75443: LD_INT 5
75445: NEG
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: LD_INT 3
75453: NEG
75454: PUSH
75455: LD_INT 4
75457: NEG
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 3
75465: NEG
75466: PUSH
75467: LD_INT 3
75469: NEG
75470: PUSH
75471: EMPTY
75472: LIST
75473: LIST
75474: PUSH
75475: LD_INT 4
75477: NEG
75478: PUSH
75479: LD_INT 3
75481: NEG
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: PUSH
75487: LD_INT 5
75489: NEG
75490: PUSH
75491: LD_INT 4
75493: NEG
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 5
75501: NEG
75502: PUSH
75503: LD_INT 5
75505: NEG
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: PUSH
75511: LD_INT 3
75513: NEG
75514: PUSH
75515: LD_INT 5
75517: NEG
75518: PUSH
75519: EMPTY
75520: LIST
75521: LIST
75522: PUSH
75523: LD_INT 5
75525: NEG
75526: PUSH
75527: LD_INT 3
75529: NEG
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: LIST
75539: LIST
75540: LIST
75541: LIST
75542: LIST
75543: LIST
75544: LIST
75545: LIST
75546: LIST
75547: LIST
75548: LIST
75549: LIST
75550: LIST
75551: LIST
75552: LIST
75553: LIST
75554: LIST
75555: LIST
75556: LIST
75557: LIST
75558: LIST
75559: LIST
75560: LIST
75561: LIST
75562: LIST
75563: LIST
75564: LIST
75565: LIST
75566: LIST
75567: LIST
75568: LIST
75569: LIST
75570: LIST
75571: LIST
75572: LIST
75573: LIST
75574: LIST
75575: LIST
75576: LIST
75577: LIST
75578: LIST
75579: LIST
75580: LIST
75581: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
75582: LD_ADDR_VAR 0 30
75586: PUSH
75587: LD_INT 4
75589: PUSH
75590: LD_INT 4
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: PUSH
75597: LD_INT 4
75599: PUSH
75600: LD_INT 3
75602: PUSH
75603: EMPTY
75604: LIST
75605: LIST
75606: PUSH
75607: LD_INT 5
75609: PUSH
75610: LD_INT 4
75612: PUSH
75613: EMPTY
75614: LIST
75615: LIST
75616: PUSH
75617: LD_INT 5
75619: PUSH
75620: LD_INT 5
75622: PUSH
75623: EMPTY
75624: LIST
75625: LIST
75626: PUSH
75627: LD_INT 4
75629: PUSH
75630: LD_INT 5
75632: PUSH
75633: EMPTY
75634: LIST
75635: LIST
75636: PUSH
75637: LD_INT 3
75639: PUSH
75640: LD_INT 4
75642: PUSH
75643: EMPTY
75644: LIST
75645: LIST
75646: PUSH
75647: LD_INT 3
75649: PUSH
75650: LD_INT 3
75652: PUSH
75653: EMPTY
75654: LIST
75655: LIST
75656: PUSH
75657: LD_INT 5
75659: PUSH
75660: LD_INT 3
75662: PUSH
75663: EMPTY
75664: LIST
75665: LIST
75666: PUSH
75667: LD_INT 3
75669: PUSH
75670: LD_INT 5
75672: PUSH
75673: EMPTY
75674: LIST
75675: LIST
75676: PUSH
75677: LD_INT 0
75679: PUSH
75680: LD_INT 3
75682: PUSH
75683: EMPTY
75684: LIST
75685: LIST
75686: PUSH
75687: LD_INT 0
75689: PUSH
75690: LD_INT 2
75692: PUSH
75693: EMPTY
75694: LIST
75695: LIST
75696: PUSH
75697: LD_INT 1
75699: PUSH
75700: LD_INT 3
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: PUSH
75707: LD_INT 1
75709: PUSH
75710: LD_INT 4
75712: PUSH
75713: EMPTY
75714: LIST
75715: LIST
75716: PUSH
75717: LD_INT 0
75719: PUSH
75720: LD_INT 4
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PUSH
75727: LD_INT 1
75729: NEG
75730: PUSH
75731: LD_INT 3
75733: PUSH
75734: EMPTY
75735: LIST
75736: LIST
75737: PUSH
75738: LD_INT 1
75740: NEG
75741: PUSH
75742: LD_INT 2
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: PUSH
75749: LD_INT 2
75751: PUSH
75752: LD_INT 4
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: PUSH
75759: LD_INT 2
75761: NEG
75762: PUSH
75763: LD_INT 2
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 4
75772: NEG
75773: PUSH
75774: LD_INT 0
75776: PUSH
75777: EMPTY
75778: LIST
75779: LIST
75780: PUSH
75781: LD_INT 4
75783: NEG
75784: PUSH
75785: LD_INT 1
75787: NEG
75788: PUSH
75789: EMPTY
75790: LIST
75791: LIST
75792: PUSH
75793: LD_INT 3
75795: NEG
75796: PUSH
75797: LD_INT 0
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: PUSH
75804: LD_INT 3
75806: NEG
75807: PUSH
75808: LD_INT 1
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: LD_INT 4
75817: NEG
75818: PUSH
75819: LD_INT 1
75821: PUSH
75822: EMPTY
75823: LIST
75824: LIST
75825: PUSH
75826: LD_INT 5
75828: NEG
75829: PUSH
75830: LD_INT 0
75832: PUSH
75833: EMPTY
75834: LIST
75835: LIST
75836: PUSH
75837: LD_INT 5
75839: NEG
75840: PUSH
75841: LD_INT 1
75843: NEG
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: PUSH
75849: LD_INT 5
75851: NEG
75852: PUSH
75853: LD_INT 2
75855: NEG
75856: PUSH
75857: EMPTY
75858: LIST
75859: LIST
75860: PUSH
75861: LD_INT 3
75863: NEG
75864: PUSH
75865: LD_INT 2
75867: PUSH
75868: EMPTY
75869: LIST
75870: LIST
75871: PUSH
75872: LD_INT 3
75874: NEG
75875: PUSH
75876: LD_INT 3
75878: NEG
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: PUSH
75884: LD_INT 3
75886: NEG
75887: PUSH
75888: LD_INT 4
75890: NEG
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PUSH
75896: LD_INT 2
75898: NEG
75899: PUSH
75900: LD_INT 3
75902: NEG
75903: PUSH
75904: EMPTY
75905: LIST
75906: LIST
75907: PUSH
75908: LD_INT 2
75910: NEG
75911: PUSH
75912: LD_INT 2
75914: NEG
75915: PUSH
75916: EMPTY
75917: LIST
75918: LIST
75919: PUSH
75920: LD_INT 3
75922: NEG
75923: PUSH
75924: LD_INT 2
75926: NEG
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: LD_INT 4
75934: NEG
75935: PUSH
75936: LD_INT 3
75938: NEG
75939: PUSH
75940: EMPTY
75941: LIST
75942: LIST
75943: PUSH
75944: LD_INT 4
75946: NEG
75947: PUSH
75948: LD_INT 4
75950: NEG
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: PUSH
75956: LD_INT 2
75958: NEG
75959: PUSH
75960: LD_INT 4
75962: NEG
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: PUSH
75968: LD_INT 4
75970: NEG
75971: PUSH
75972: LD_INT 2
75974: NEG
75975: PUSH
75976: EMPTY
75977: LIST
75978: LIST
75979: PUSH
75980: LD_INT 0
75982: PUSH
75983: LD_INT 4
75985: NEG
75986: PUSH
75987: EMPTY
75988: LIST
75989: LIST
75990: PUSH
75991: LD_INT 0
75993: PUSH
75994: LD_INT 5
75996: NEG
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: PUSH
76002: LD_INT 1
76004: PUSH
76005: LD_INT 4
76007: NEG
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: PUSH
76013: LD_INT 1
76015: PUSH
76016: LD_INT 3
76018: NEG
76019: PUSH
76020: EMPTY
76021: LIST
76022: LIST
76023: PUSH
76024: LD_INT 0
76026: PUSH
76027: LD_INT 3
76029: NEG
76030: PUSH
76031: EMPTY
76032: LIST
76033: LIST
76034: PUSH
76035: LD_INT 1
76037: NEG
76038: PUSH
76039: LD_INT 4
76041: NEG
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: PUSH
76047: LD_INT 1
76049: NEG
76050: PUSH
76051: LD_INT 5
76053: NEG
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: PUSH
76059: LD_INT 2
76061: PUSH
76062: LD_INT 3
76064: NEG
76065: PUSH
76066: EMPTY
76067: LIST
76068: LIST
76069: PUSH
76070: LD_INT 2
76072: NEG
76073: PUSH
76074: LD_INT 5
76076: NEG
76077: PUSH
76078: EMPTY
76079: LIST
76080: LIST
76081: PUSH
76082: EMPTY
76083: LIST
76084: LIST
76085: LIST
76086: LIST
76087: LIST
76088: LIST
76089: LIST
76090: LIST
76091: LIST
76092: LIST
76093: LIST
76094: LIST
76095: LIST
76096: LIST
76097: LIST
76098: LIST
76099: LIST
76100: LIST
76101: LIST
76102: LIST
76103: LIST
76104: LIST
76105: LIST
76106: LIST
76107: LIST
76108: LIST
76109: LIST
76110: LIST
76111: LIST
76112: LIST
76113: LIST
76114: LIST
76115: LIST
76116: LIST
76117: LIST
76118: LIST
76119: LIST
76120: LIST
76121: LIST
76122: LIST
76123: LIST
76124: LIST
76125: LIST
76126: LIST
76127: LIST
76128: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
76129: LD_ADDR_VAR 0 31
76133: PUSH
76134: LD_INT 0
76136: PUSH
76137: LD_INT 4
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: PUSH
76144: LD_INT 0
76146: PUSH
76147: LD_INT 3
76149: PUSH
76150: EMPTY
76151: LIST
76152: LIST
76153: PUSH
76154: LD_INT 1
76156: PUSH
76157: LD_INT 4
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: PUSH
76164: LD_INT 1
76166: PUSH
76167: LD_INT 5
76169: PUSH
76170: EMPTY
76171: LIST
76172: LIST
76173: PUSH
76174: LD_INT 0
76176: PUSH
76177: LD_INT 5
76179: PUSH
76180: EMPTY
76181: LIST
76182: LIST
76183: PUSH
76184: LD_INT 1
76186: NEG
76187: PUSH
76188: LD_INT 4
76190: PUSH
76191: EMPTY
76192: LIST
76193: LIST
76194: PUSH
76195: LD_INT 1
76197: NEG
76198: PUSH
76199: LD_INT 3
76201: PUSH
76202: EMPTY
76203: LIST
76204: LIST
76205: PUSH
76206: LD_INT 2
76208: PUSH
76209: LD_INT 5
76211: PUSH
76212: EMPTY
76213: LIST
76214: LIST
76215: PUSH
76216: LD_INT 2
76218: NEG
76219: PUSH
76220: LD_INT 3
76222: PUSH
76223: EMPTY
76224: LIST
76225: LIST
76226: PUSH
76227: LD_INT 3
76229: NEG
76230: PUSH
76231: LD_INT 0
76233: PUSH
76234: EMPTY
76235: LIST
76236: LIST
76237: PUSH
76238: LD_INT 3
76240: NEG
76241: PUSH
76242: LD_INT 1
76244: NEG
76245: PUSH
76246: EMPTY
76247: LIST
76248: LIST
76249: PUSH
76250: LD_INT 2
76252: NEG
76253: PUSH
76254: LD_INT 0
76256: PUSH
76257: EMPTY
76258: LIST
76259: LIST
76260: PUSH
76261: LD_INT 2
76263: NEG
76264: PUSH
76265: LD_INT 1
76267: PUSH
76268: EMPTY
76269: LIST
76270: LIST
76271: PUSH
76272: LD_INT 3
76274: NEG
76275: PUSH
76276: LD_INT 1
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: LD_INT 4
76285: NEG
76286: PUSH
76287: LD_INT 0
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: PUSH
76294: LD_INT 4
76296: NEG
76297: PUSH
76298: LD_INT 1
76300: NEG
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: LD_INT 4
76308: NEG
76309: PUSH
76310: LD_INT 2
76312: NEG
76313: PUSH
76314: EMPTY
76315: LIST
76316: LIST
76317: PUSH
76318: LD_INT 2
76320: NEG
76321: PUSH
76322: LD_INT 2
76324: PUSH
76325: EMPTY
76326: LIST
76327: LIST
76328: PUSH
76329: LD_INT 4
76331: NEG
76332: PUSH
76333: LD_INT 4
76335: NEG
76336: PUSH
76337: EMPTY
76338: LIST
76339: LIST
76340: PUSH
76341: LD_INT 4
76343: NEG
76344: PUSH
76345: LD_INT 5
76347: NEG
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 3
76355: NEG
76356: PUSH
76357: LD_INT 4
76359: NEG
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: LD_INT 3
76367: NEG
76368: PUSH
76369: LD_INT 3
76371: NEG
76372: PUSH
76373: EMPTY
76374: LIST
76375: LIST
76376: PUSH
76377: LD_INT 4
76379: NEG
76380: PUSH
76381: LD_INT 3
76383: NEG
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: LD_INT 5
76391: NEG
76392: PUSH
76393: LD_INT 4
76395: NEG
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: PUSH
76401: LD_INT 5
76403: NEG
76404: PUSH
76405: LD_INT 5
76407: NEG
76408: PUSH
76409: EMPTY
76410: LIST
76411: LIST
76412: PUSH
76413: LD_INT 3
76415: NEG
76416: PUSH
76417: LD_INT 5
76419: NEG
76420: PUSH
76421: EMPTY
76422: LIST
76423: LIST
76424: PUSH
76425: LD_INT 5
76427: NEG
76428: PUSH
76429: LD_INT 3
76431: NEG
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: PUSH
76437: LD_INT 0
76439: PUSH
76440: LD_INT 3
76442: NEG
76443: PUSH
76444: EMPTY
76445: LIST
76446: LIST
76447: PUSH
76448: LD_INT 0
76450: PUSH
76451: LD_INT 4
76453: NEG
76454: PUSH
76455: EMPTY
76456: LIST
76457: LIST
76458: PUSH
76459: LD_INT 1
76461: PUSH
76462: LD_INT 3
76464: NEG
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PUSH
76470: LD_INT 1
76472: PUSH
76473: LD_INT 2
76475: NEG
76476: PUSH
76477: EMPTY
76478: LIST
76479: LIST
76480: PUSH
76481: LD_INT 0
76483: PUSH
76484: LD_INT 2
76486: NEG
76487: PUSH
76488: EMPTY
76489: LIST
76490: LIST
76491: PUSH
76492: LD_INT 1
76494: NEG
76495: PUSH
76496: LD_INT 3
76498: NEG
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: LD_INT 1
76506: NEG
76507: PUSH
76508: LD_INT 4
76510: NEG
76511: PUSH
76512: EMPTY
76513: LIST
76514: LIST
76515: PUSH
76516: LD_INT 2
76518: PUSH
76519: LD_INT 2
76521: NEG
76522: PUSH
76523: EMPTY
76524: LIST
76525: LIST
76526: PUSH
76527: LD_INT 2
76529: NEG
76530: PUSH
76531: LD_INT 4
76533: NEG
76534: PUSH
76535: EMPTY
76536: LIST
76537: LIST
76538: PUSH
76539: LD_INT 4
76541: PUSH
76542: LD_INT 0
76544: PUSH
76545: EMPTY
76546: LIST
76547: LIST
76548: PUSH
76549: LD_INT 4
76551: PUSH
76552: LD_INT 1
76554: NEG
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PUSH
76560: LD_INT 5
76562: PUSH
76563: LD_INT 0
76565: PUSH
76566: EMPTY
76567: LIST
76568: LIST
76569: PUSH
76570: LD_INT 5
76572: PUSH
76573: LD_INT 1
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: LD_INT 4
76582: PUSH
76583: LD_INT 1
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: LD_INT 3
76592: PUSH
76593: LD_INT 0
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: PUSH
76600: LD_INT 3
76602: PUSH
76603: LD_INT 1
76605: NEG
76606: PUSH
76607: EMPTY
76608: LIST
76609: LIST
76610: PUSH
76611: LD_INT 3
76613: PUSH
76614: LD_INT 2
76616: NEG
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: PUSH
76622: LD_INT 5
76624: PUSH
76625: LD_INT 2
76627: PUSH
76628: EMPTY
76629: LIST
76630: LIST
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: LIST
76636: LIST
76637: LIST
76638: LIST
76639: LIST
76640: LIST
76641: LIST
76642: LIST
76643: LIST
76644: LIST
76645: LIST
76646: LIST
76647: LIST
76648: LIST
76649: LIST
76650: LIST
76651: LIST
76652: LIST
76653: LIST
76654: LIST
76655: LIST
76656: LIST
76657: LIST
76658: LIST
76659: LIST
76660: LIST
76661: LIST
76662: LIST
76663: LIST
76664: LIST
76665: LIST
76666: LIST
76667: LIST
76668: LIST
76669: LIST
76670: LIST
76671: LIST
76672: LIST
76673: LIST
76674: LIST
76675: LIST
76676: LIST
76677: LIST
76678: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
76679: LD_ADDR_VAR 0 32
76683: PUSH
76684: LD_INT 4
76686: NEG
76687: PUSH
76688: LD_INT 0
76690: PUSH
76691: EMPTY
76692: LIST
76693: LIST
76694: PUSH
76695: LD_INT 4
76697: NEG
76698: PUSH
76699: LD_INT 1
76701: NEG
76702: PUSH
76703: EMPTY
76704: LIST
76705: LIST
76706: PUSH
76707: LD_INT 3
76709: NEG
76710: PUSH
76711: LD_INT 0
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: PUSH
76718: LD_INT 3
76720: NEG
76721: PUSH
76722: LD_INT 1
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: PUSH
76729: LD_INT 4
76731: NEG
76732: PUSH
76733: LD_INT 1
76735: PUSH
76736: EMPTY
76737: LIST
76738: LIST
76739: PUSH
76740: LD_INT 5
76742: NEG
76743: PUSH
76744: LD_INT 0
76746: PUSH
76747: EMPTY
76748: LIST
76749: LIST
76750: PUSH
76751: LD_INT 5
76753: NEG
76754: PUSH
76755: LD_INT 1
76757: NEG
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: LD_INT 5
76765: NEG
76766: PUSH
76767: LD_INT 2
76769: NEG
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: PUSH
76775: LD_INT 3
76777: NEG
76778: PUSH
76779: LD_INT 2
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: LD_INT 3
76788: NEG
76789: PUSH
76790: LD_INT 3
76792: NEG
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: PUSH
76798: LD_INT 3
76800: NEG
76801: PUSH
76802: LD_INT 4
76804: NEG
76805: PUSH
76806: EMPTY
76807: LIST
76808: LIST
76809: PUSH
76810: LD_INT 2
76812: NEG
76813: PUSH
76814: LD_INT 3
76816: NEG
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: PUSH
76822: LD_INT 2
76824: NEG
76825: PUSH
76826: LD_INT 2
76828: NEG
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: PUSH
76834: LD_INT 3
76836: NEG
76837: PUSH
76838: LD_INT 2
76840: NEG
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: LD_INT 4
76848: NEG
76849: PUSH
76850: LD_INT 3
76852: NEG
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: LD_INT 4
76860: NEG
76861: PUSH
76862: LD_INT 4
76864: NEG
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 2
76872: NEG
76873: PUSH
76874: LD_INT 4
76876: NEG
76877: PUSH
76878: EMPTY
76879: LIST
76880: LIST
76881: PUSH
76882: LD_INT 4
76884: NEG
76885: PUSH
76886: LD_INT 2
76888: NEG
76889: PUSH
76890: EMPTY
76891: LIST
76892: LIST
76893: PUSH
76894: LD_INT 0
76896: PUSH
76897: LD_INT 4
76899: NEG
76900: PUSH
76901: EMPTY
76902: LIST
76903: LIST
76904: PUSH
76905: LD_INT 0
76907: PUSH
76908: LD_INT 5
76910: NEG
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: PUSH
76916: LD_INT 1
76918: PUSH
76919: LD_INT 4
76921: NEG
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 1
76929: PUSH
76930: LD_INT 3
76932: NEG
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: PUSH
76938: LD_INT 0
76940: PUSH
76941: LD_INT 3
76943: NEG
76944: PUSH
76945: EMPTY
76946: LIST
76947: LIST
76948: PUSH
76949: LD_INT 1
76951: NEG
76952: PUSH
76953: LD_INT 4
76955: NEG
76956: PUSH
76957: EMPTY
76958: LIST
76959: LIST
76960: PUSH
76961: LD_INT 1
76963: NEG
76964: PUSH
76965: LD_INT 5
76967: NEG
76968: PUSH
76969: EMPTY
76970: LIST
76971: LIST
76972: PUSH
76973: LD_INT 2
76975: PUSH
76976: LD_INT 3
76978: NEG
76979: PUSH
76980: EMPTY
76981: LIST
76982: LIST
76983: PUSH
76984: LD_INT 2
76986: NEG
76987: PUSH
76988: LD_INT 5
76990: NEG
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: PUSH
76996: LD_INT 3
76998: PUSH
76999: LD_INT 0
77001: PUSH
77002: EMPTY
77003: LIST
77004: LIST
77005: PUSH
77006: LD_INT 3
77008: PUSH
77009: LD_INT 1
77011: NEG
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: PUSH
77017: LD_INT 4
77019: PUSH
77020: LD_INT 0
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: LD_INT 4
77029: PUSH
77030: LD_INT 1
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: PUSH
77037: LD_INT 3
77039: PUSH
77040: LD_INT 1
77042: PUSH
77043: EMPTY
77044: LIST
77045: LIST
77046: PUSH
77047: LD_INT 2
77049: PUSH
77050: LD_INT 0
77052: PUSH
77053: EMPTY
77054: LIST
77055: LIST
77056: PUSH
77057: LD_INT 2
77059: PUSH
77060: LD_INT 1
77062: NEG
77063: PUSH
77064: EMPTY
77065: LIST
77066: LIST
77067: PUSH
77068: LD_INT 2
77070: PUSH
77071: LD_INT 2
77073: NEG
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PUSH
77079: LD_INT 4
77081: PUSH
77082: LD_INT 2
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: LD_INT 4
77091: PUSH
77092: LD_INT 4
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 4
77101: PUSH
77102: LD_INT 3
77104: PUSH
77105: EMPTY
77106: LIST
77107: LIST
77108: PUSH
77109: LD_INT 5
77111: PUSH
77112: LD_INT 4
77114: PUSH
77115: EMPTY
77116: LIST
77117: LIST
77118: PUSH
77119: LD_INT 5
77121: PUSH
77122: LD_INT 5
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: PUSH
77129: LD_INT 4
77131: PUSH
77132: LD_INT 5
77134: PUSH
77135: EMPTY
77136: LIST
77137: LIST
77138: PUSH
77139: LD_INT 3
77141: PUSH
77142: LD_INT 4
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: PUSH
77149: LD_INT 3
77151: PUSH
77152: LD_INT 3
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PUSH
77159: LD_INT 5
77161: PUSH
77162: LD_INT 3
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PUSH
77169: LD_INT 3
77171: PUSH
77172: LD_INT 5
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: LIST
77183: LIST
77184: LIST
77185: LIST
77186: LIST
77187: LIST
77188: LIST
77189: LIST
77190: LIST
77191: LIST
77192: LIST
77193: LIST
77194: LIST
77195: LIST
77196: LIST
77197: LIST
77198: LIST
77199: LIST
77200: LIST
77201: LIST
77202: LIST
77203: LIST
77204: LIST
77205: LIST
77206: LIST
77207: LIST
77208: LIST
77209: LIST
77210: LIST
77211: LIST
77212: LIST
77213: LIST
77214: LIST
77215: LIST
77216: LIST
77217: LIST
77218: LIST
77219: LIST
77220: LIST
77221: LIST
77222: LIST
77223: LIST
77224: LIST
77225: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
77226: LD_ADDR_VAR 0 33
77230: PUSH
77231: LD_INT 4
77233: NEG
77234: PUSH
77235: LD_INT 4
77237: NEG
77238: PUSH
77239: EMPTY
77240: LIST
77241: LIST
77242: PUSH
77243: LD_INT 4
77245: NEG
77246: PUSH
77247: LD_INT 5
77249: NEG
77250: PUSH
77251: EMPTY
77252: LIST
77253: LIST
77254: PUSH
77255: LD_INT 3
77257: NEG
77258: PUSH
77259: LD_INT 4
77261: NEG
77262: PUSH
77263: EMPTY
77264: LIST
77265: LIST
77266: PUSH
77267: LD_INT 3
77269: NEG
77270: PUSH
77271: LD_INT 3
77273: NEG
77274: PUSH
77275: EMPTY
77276: LIST
77277: LIST
77278: PUSH
77279: LD_INT 4
77281: NEG
77282: PUSH
77283: LD_INT 3
77285: NEG
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PUSH
77291: LD_INT 5
77293: NEG
77294: PUSH
77295: LD_INT 4
77297: NEG
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: LD_INT 5
77305: NEG
77306: PUSH
77307: LD_INT 5
77309: NEG
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: PUSH
77315: LD_INT 3
77317: NEG
77318: PUSH
77319: LD_INT 5
77321: NEG
77322: PUSH
77323: EMPTY
77324: LIST
77325: LIST
77326: PUSH
77327: LD_INT 5
77329: NEG
77330: PUSH
77331: LD_INT 3
77333: NEG
77334: PUSH
77335: EMPTY
77336: LIST
77337: LIST
77338: PUSH
77339: LD_INT 0
77341: PUSH
77342: LD_INT 3
77344: NEG
77345: PUSH
77346: EMPTY
77347: LIST
77348: LIST
77349: PUSH
77350: LD_INT 0
77352: PUSH
77353: LD_INT 4
77355: NEG
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: PUSH
77361: LD_INT 1
77363: PUSH
77364: LD_INT 3
77366: NEG
77367: PUSH
77368: EMPTY
77369: LIST
77370: LIST
77371: PUSH
77372: LD_INT 1
77374: PUSH
77375: LD_INT 2
77377: NEG
77378: PUSH
77379: EMPTY
77380: LIST
77381: LIST
77382: PUSH
77383: LD_INT 0
77385: PUSH
77386: LD_INT 2
77388: NEG
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: LD_INT 1
77396: NEG
77397: PUSH
77398: LD_INT 3
77400: NEG
77401: PUSH
77402: EMPTY
77403: LIST
77404: LIST
77405: PUSH
77406: LD_INT 1
77408: NEG
77409: PUSH
77410: LD_INT 4
77412: NEG
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: LD_INT 2
77420: PUSH
77421: LD_INT 2
77423: NEG
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: LD_INT 2
77431: NEG
77432: PUSH
77433: LD_INT 4
77435: NEG
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: PUSH
77441: LD_INT 4
77443: PUSH
77444: LD_INT 0
77446: PUSH
77447: EMPTY
77448: LIST
77449: LIST
77450: PUSH
77451: LD_INT 4
77453: PUSH
77454: LD_INT 1
77456: NEG
77457: PUSH
77458: EMPTY
77459: LIST
77460: LIST
77461: PUSH
77462: LD_INT 5
77464: PUSH
77465: LD_INT 0
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: LD_INT 5
77474: PUSH
77475: LD_INT 1
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: PUSH
77482: LD_INT 4
77484: PUSH
77485: LD_INT 1
77487: PUSH
77488: EMPTY
77489: LIST
77490: LIST
77491: PUSH
77492: LD_INT 3
77494: PUSH
77495: LD_INT 0
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 3
77504: PUSH
77505: LD_INT 1
77507: NEG
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 3
77515: PUSH
77516: LD_INT 2
77518: NEG
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PUSH
77524: LD_INT 5
77526: PUSH
77527: LD_INT 2
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: PUSH
77534: LD_INT 3
77536: PUSH
77537: LD_INT 3
77539: PUSH
77540: EMPTY
77541: LIST
77542: LIST
77543: PUSH
77544: LD_INT 3
77546: PUSH
77547: LD_INT 2
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: PUSH
77554: LD_INT 4
77556: PUSH
77557: LD_INT 3
77559: PUSH
77560: EMPTY
77561: LIST
77562: LIST
77563: PUSH
77564: LD_INT 4
77566: PUSH
77567: LD_INT 4
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: PUSH
77574: LD_INT 3
77576: PUSH
77577: LD_INT 4
77579: PUSH
77580: EMPTY
77581: LIST
77582: LIST
77583: PUSH
77584: LD_INT 2
77586: PUSH
77587: LD_INT 3
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 2
77596: PUSH
77597: LD_INT 2
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 4
77606: PUSH
77607: LD_INT 2
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: LD_INT 2
77616: PUSH
77617: LD_INT 4
77619: PUSH
77620: EMPTY
77621: LIST
77622: LIST
77623: PUSH
77624: LD_INT 0
77626: PUSH
77627: LD_INT 4
77629: PUSH
77630: EMPTY
77631: LIST
77632: LIST
77633: PUSH
77634: LD_INT 0
77636: PUSH
77637: LD_INT 3
77639: PUSH
77640: EMPTY
77641: LIST
77642: LIST
77643: PUSH
77644: LD_INT 1
77646: PUSH
77647: LD_INT 4
77649: PUSH
77650: EMPTY
77651: LIST
77652: LIST
77653: PUSH
77654: LD_INT 1
77656: PUSH
77657: LD_INT 5
77659: PUSH
77660: EMPTY
77661: LIST
77662: LIST
77663: PUSH
77664: LD_INT 0
77666: PUSH
77667: LD_INT 5
77669: PUSH
77670: EMPTY
77671: LIST
77672: LIST
77673: PUSH
77674: LD_INT 1
77676: NEG
77677: PUSH
77678: LD_INT 4
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: LD_INT 1
77687: NEG
77688: PUSH
77689: LD_INT 3
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: PUSH
77696: LD_INT 2
77698: PUSH
77699: LD_INT 5
77701: PUSH
77702: EMPTY
77703: LIST
77704: LIST
77705: PUSH
77706: LD_INT 2
77708: NEG
77709: PUSH
77710: LD_INT 3
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: EMPTY
77718: LIST
77719: LIST
77720: LIST
77721: LIST
77722: LIST
77723: LIST
77724: LIST
77725: LIST
77726: LIST
77727: LIST
77728: LIST
77729: LIST
77730: LIST
77731: LIST
77732: LIST
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: LIST
77738: LIST
77739: LIST
77740: LIST
77741: LIST
77742: LIST
77743: LIST
77744: LIST
77745: LIST
77746: LIST
77747: LIST
77748: LIST
77749: LIST
77750: LIST
77751: LIST
77752: LIST
77753: LIST
77754: LIST
77755: LIST
77756: LIST
77757: LIST
77758: LIST
77759: LIST
77760: LIST
77761: LIST
77762: LIST
77763: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
77764: LD_ADDR_VAR 0 34
77768: PUSH
77769: LD_INT 0
77771: PUSH
77772: LD_INT 4
77774: NEG
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: PUSH
77780: LD_INT 0
77782: PUSH
77783: LD_INT 5
77785: NEG
77786: PUSH
77787: EMPTY
77788: LIST
77789: LIST
77790: PUSH
77791: LD_INT 1
77793: PUSH
77794: LD_INT 4
77796: NEG
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: LD_INT 1
77804: PUSH
77805: LD_INT 3
77807: NEG
77808: PUSH
77809: EMPTY
77810: LIST
77811: LIST
77812: PUSH
77813: LD_INT 0
77815: PUSH
77816: LD_INT 3
77818: NEG
77819: PUSH
77820: EMPTY
77821: LIST
77822: LIST
77823: PUSH
77824: LD_INT 1
77826: NEG
77827: PUSH
77828: LD_INT 4
77830: NEG
77831: PUSH
77832: EMPTY
77833: LIST
77834: LIST
77835: PUSH
77836: LD_INT 1
77838: NEG
77839: PUSH
77840: LD_INT 5
77842: NEG
77843: PUSH
77844: EMPTY
77845: LIST
77846: LIST
77847: PUSH
77848: LD_INT 2
77850: PUSH
77851: LD_INT 3
77853: NEG
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PUSH
77859: LD_INT 2
77861: NEG
77862: PUSH
77863: LD_INT 5
77865: NEG
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PUSH
77871: LD_INT 3
77873: PUSH
77874: LD_INT 0
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: PUSH
77881: LD_INT 3
77883: PUSH
77884: LD_INT 1
77886: NEG
77887: PUSH
77888: EMPTY
77889: LIST
77890: LIST
77891: PUSH
77892: LD_INT 4
77894: PUSH
77895: LD_INT 0
77897: PUSH
77898: EMPTY
77899: LIST
77900: LIST
77901: PUSH
77902: LD_INT 4
77904: PUSH
77905: LD_INT 1
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: PUSH
77912: LD_INT 3
77914: PUSH
77915: LD_INT 1
77917: PUSH
77918: EMPTY
77919: LIST
77920: LIST
77921: PUSH
77922: LD_INT 2
77924: PUSH
77925: LD_INT 0
77927: PUSH
77928: EMPTY
77929: LIST
77930: LIST
77931: PUSH
77932: LD_INT 2
77934: PUSH
77935: LD_INT 1
77937: NEG
77938: PUSH
77939: EMPTY
77940: LIST
77941: LIST
77942: PUSH
77943: LD_INT 2
77945: PUSH
77946: LD_INT 2
77948: NEG
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: PUSH
77954: LD_INT 4
77956: PUSH
77957: LD_INT 2
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: LD_INT 4
77966: PUSH
77967: LD_INT 4
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 4
77976: PUSH
77977: LD_INT 3
77979: PUSH
77980: EMPTY
77981: LIST
77982: LIST
77983: PUSH
77984: LD_INT 5
77986: PUSH
77987: LD_INT 4
77989: PUSH
77990: EMPTY
77991: LIST
77992: LIST
77993: PUSH
77994: LD_INT 5
77996: PUSH
77997: LD_INT 5
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: PUSH
78004: LD_INT 4
78006: PUSH
78007: LD_INT 5
78009: PUSH
78010: EMPTY
78011: LIST
78012: LIST
78013: PUSH
78014: LD_INT 3
78016: PUSH
78017: LD_INT 4
78019: PUSH
78020: EMPTY
78021: LIST
78022: LIST
78023: PUSH
78024: LD_INT 3
78026: PUSH
78027: LD_INT 3
78029: PUSH
78030: EMPTY
78031: LIST
78032: LIST
78033: PUSH
78034: LD_INT 5
78036: PUSH
78037: LD_INT 3
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: LD_INT 3
78046: PUSH
78047: LD_INT 5
78049: PUSH
78050: EMPTY
78051: LIST
78052: LIST
78053: PUSH
78054: LD_INT 0
78056: PUSH
78057: LD_INT 3
78059: PUSH
78060: EMPTY
78061: LIST
78062: LIST
78063: PUSH
78064: LD_INT 0
78066: PUSH
78067: LD_INT 2
78069: PUSH
78070: EMPTY
78071: LIST
78072: LIST
78073: PUSH
78074: LD_INT 1
78076: PUSH
78077: LD_INT 3
78079: PUSH
78080: EMPTY
78081: LIST
78082: LIST
78083: PUSH
78084: LD_INT 1
78086: PUSH
78087: LD_INT 4
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: LD_INT 0
78096: PUSH
78097: LD_INT 4
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: PUSH
78104: LD_INT 1
78106: NEG
78107: PUSH
78108: LD_INT 3
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: LD_INT 1
78117: NEG
78118: PUSH
78119: LD_INT 2
78121: PUSH
78122: EMPTY
78123: LIST
78124: LIST
78125: PUSH
78126: LD_INT 2
78128: PUSH
78129: LD_INT 4
78131: PUSH
78132: EMPTY
78133: LIST
78134: LIST
78135: PUSH
78136: LD_INT 2
78138: NEG
78139: PUSH
78140: LD_INT 2
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: PUSH
78147: LD_INT 4
78149: NEG
78150: PUSH
78151: LD_INT 0
78153: PUSH
78154: EMPTY
78155: LIST
78156: LIST
78157: PUSH
78158: LD_INT 4
78160: NEG
78161: PUSH
78162: LD_INT 1
78164: NEG
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: PUSH
78170: LD_INT 3
78172: NEG
78173: PUSH
78174: LD_INT 0
78176: PUSH
78177: EMPTY
78178: LIST
78179: LIST
78180: PUSH
78181: LD_INT 3
78183: NEG
78184: PUSH
78185: LD_INT 1
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: PUSH
78192: LD_INT 4
78194: NEG
78195: PUSH
78196: LD_INT 1
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: PUSH
78203: LD_INT 5
78205: NEG
78206: PUSH
78207: LD_INT 0
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: PUSH
78214: LD_INT 5
78216: NEG
78217: PUSH
78218: LD_INT 1
78220: NEG
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: PUSH
78226: LD_INT 5
78228: NEG
78229: PUSH
78230: LD_INT 2
78232: NEG
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 3
78240: NEG
78241: PUSH
78242: LD_INT 2
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: EMPTY
78250: LIST
78251: LIST
78252: LIST
78253: LIST
78254: LIST
78255: LIST
78256: LIST
78257: LIST
78258: LIST
78259: LIST
78260: LIST
78261: LIST
78262: LIST
78263: LIST
78264: LIST
78265: LIST
78266: LIST
78267: LIST
78268: LIST
78269: LIST
78270: LIST
78271: LIST
78272: LIST
78273: LIST
78274: LIST
78275: LIST
78276: LIST
78277: LIST
78278: LIST
78279: LIST
78280: LIST
78281: LIST
78282: LIST
78283: LIST
78284: LIST
78285: LIST
78286: LIST
78287: LIST
78288: LIST
78289: LIST
78290: LIST
78291: LIST
78292: LIST
78293: LIST
78294: LIST
78295: ST_TO_ADDR
// end ; end ;
78296: GO 78299
78298: POP
// case btype of b_depot , b_warehouse :
78299: LD_VAR 0 1
78303: PUSH
78304: LD_INT 0
78306: DOUBLE
78307: EQUAL
78308: IFTRUE 78318
78310: LD_INT 1
78312: DOUBLE
78313: EQUAL
78314: IFTRUE 78318
78316: GO 78519
78318: POP
// case nation of nation_american :
78319: LD_VAR 0 5
78323: PUSH
78324: LD_INT 1
78326: DOUBLE
78327: EQUAL
78328: IFTRUE 78332
78330: GO 78388
78332: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
78333: LD_ADDR_VAR 0 9
78337: PUSH
78338: LD_VAR 0 11
78342: PUSH
78343: LD_VAR 0 12
78347: PUSH
78348: LD_VAR 0 13
78352: PUSH
78353: LD_VAR 0 14
78357: PUSH
78358: LD_VAR 0 15
78362: PUSH
78363: LD_VAR 0 16
78367: PUSH
78368: EMPTY
78369: LIST
78370: LIST
78371: LIST
78372: LIST
78373: LIST
78374: LIST
78375: PUSH
78376: LD_VAR 0 4
78380: PUSH
78381: LD_INT 1
78383: PLUS
78384: ARRAY
78385: ST_TO_ADDR
78386: GO 78517
78388: LD_INT 2
78390: DOUBLE
78391: EQUAL
78392: IFTRUE 78396
78394: GO 78452
78396: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
78397: LD_ADDR_VAR 0 9
78401: PUSH
78402: LD_VAR 0 17
78406: PUSH
78407: LD_VAR 0 18
78411: PUSH
78412: LD_VAR 0 19
78416: PUSH
78417: LD_VAR 0 20
78421: PUSH
78422: LD_VAR 0 21
78426: PUSH
78427: LD_VAR 0 22
78431: PUSH
78432: EMPTY
78433: LIST
78434: LIST
78435: LIST
78436: LIST
78437: LIST
78438: LIST
78439: PUSH
78440: LD_VAR 0 4
78444: PUSH
78445: LD_INT 1
78447: PLUS
78448: ARRAY
78449: ST_TO_ADDR
78450: GO 78517
78452: LD_INT 3
78454: DOUBLE
78455: EQUAL
78456: IFTRUE 78460
78458: GO 78516
78460: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
78461: LD_ADDR_VAR 0 9
78465: PUSH
78466: LD_VAR 0 23
78470: PUSH
78471: LD_VAR 0 24
78475: PUSH
78476: LD_VAR 0 25
78480: PUSH
78481: LD_VAR 0 26
78485: PUSH
78486: LD_VAR 0 27
78490: PUSH
78491: LD_VAR 0 28
78495: PUSH
78496: EMPTY
78497: LIST
78498: LIST
78499: LIST
78500: LIST
78501: LIST
78502: LIST
78503: PUSH
78504: LD_VAR 0 4
78508: PUSH
78509: LD_INT 1
78511: PLUS
78512: ARRAY
78513: ST_TO_ADDR
78514: GO 78517
78516: POP
78517: GO 79072
78519: LD_INT 2
78521: DOUBLE
78522: EQUAL
78523: IFTRUE 78533
78525: LD_INT 3
78527: DOUBLE
78528: EQUAL
78529: IFTRUE 78533
78531: GO 78589
78533: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
78534: LD_ADDR_VAR 0 9
78538: PUSH
78539: LD_VAR 0 29
78543: PUSH
78544: LD_VAR 0 30
78548: PUSH
78549: LD_VAR 0 31
78553: PUSH
78554: LD_VAR 0 32
78558: PUSH
78559: LD_VAR 0 33
78563: PUSH
78564: LD_VAR 0 34
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: LIST
78573: LIST
78574: LIST
78575: LIST
78576: PUSH
78577: LD_VAR 0 4
78581: PUSH
78582: LD_INT 1
78584: PLUS
78585: ARRAY
78586: ST_TO_ADDR
78587: GO 79072
78589: LD_INT 16
78591: DOUBLE
78592: EQUAL
78593: IFTRUE 78651
78595: LD_INT 17
78597: DOUBLE
78598: EQUAL
78599: IFTRUE 78651
78601: LD_INT 18
78603: DOUBLE
78604: EQUAL
78605: IFTRUE 78651
78607: LD_INT 19
78609: DOUBLE
78610: EQUAL
78611: IFTRUE 78651
78613: LD_INT 22
78615: DOUBLE
78616: EQUAL
78617: IFTRUE 78651
78619: LD_INT 20
78621: DOUBLE
78622: EQUAL
78623: IFTRUE 78651
78625: LD_INT 21
78627: DOUBLE
78628: EQUAL
78629: IFTRUE 78651
78631: LD_INT 23
78633: DOUBLE
78634: EQUAL
78635: IFTRUE 78651
78637: LD_INT 24
78639: DOUBLE
78640: EQUAL
78641: IFTRUE 78651
78643: LD_INT 25
78645: DOUBLE
78646: EQUAL
78647: IFTRUE 78651
78649: GO 78707
78651: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
78652: LD_ADDR_VAR 0 9
78656: PUSH
78657: LD_VAR 0 35
78661: PUSH
78662: LD_VAR 0 36
78666: PUSH
78667: LD_VAR 0 37
78671: PUSH
78672: LD_VAR 0 38
78676: PUSH
78677: LD_VAR 0 39
78681: PUSH
78682: LD_VAR 0 40
78686: PUSH
78687: EMPTY
78688: LIST
78689: LIST
78690: LIST
78691: LIST
78692: LIST
78693: LIST
78694: PUSH
78695: LD_VAR 0 4
78699: PUSH
78700: LD_INT 1
78702: PLUS
78703: ARRAY
78704: ST_TO_ADDR
78705: GO 79072
78707: LD_INT 6
78709: DOUBLE
78710: EQUAL
78711: IFTRUE 78763
78713: LD_INT 7
78715: DOUBLE
78716: EQUAL
78717: IFTRUE 78763
78719: LD_INT 8
78721: DOUBLE
78722: EQUAL
78723: IFTRUE 78763
78725: LD_INT 13
78727: DOUBLE
78728: EQUAL
78729: IFTRUE 78763
78731: LD_INT 12
78733: DOUBLE
78734: EQUAL
78735: IFTRUE 78763
78737: LD_INT 15
78739: DOUBLE
78740: EQUAL
78741: IFTRUE 78763
78743: LD_INT 11
78745: DOUBLE
78746: EQUAL
78747: IFTRUE 78763
78749: LD_INT 14
78751: DOUBLE
78752: EQUAL
78753: IFTRUE 78763
78755: LD_INT 10
78757: DOUBLE
78758: EQUAL
78759: IFTRUE 78763
78761: GO 78819
78763: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
78764: LD_ADDR_VAR 0 9
78768: PUSH
78769: LD_VAR 0 41
78773: PUSH
78774: LD_VAR 0 42
78778: PUSH
78779: LD_VAR 0 43
78783: PUSH
78784: LD_VAR 0 44
78788: PUSH
78789: LD_VAR 0 45
78793: PUSH
78794: LD_VAR 0 46
78798: PUSH
78799: EMPTY
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: PUSH
78807: LD_VAR 0 4
78811: PUSH
78812: LD_INT 1
78814: PLUS
78815: ARRAY
78816: ST_TO_ADDR
78817: GO 79072
78819: LD_INT 36
78821: DOUBLE
78822: EQUAL
78823: IFTRUE 78827
78825: GO 78883
78827: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
78828: LD_ADDR_VAR 0 9
78832: PUSH
78833: LD_VAR 0 47
78837: PUSH
78838: LD_VAR 0 48
78842: PUSH
78843: LD_VAR 0 49
78847: PUSH
78848: LD_VAR 0 50
78852: PUSH
78853: LD_VAR 0 51
78857: PUSH
78858: LD_VAR 0 52
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: LIST
78867: LIST
78868: LIST
78869: LIST
78870: PUSH
78871: LD_VAR 0 4
78875: PUSH
78876: LD_INT 1
78878: PLUS
78879: ARRAY
78880: ST_TO_ADDR
78881: GO 79072
78883: LD_INT 4
78885: DOUBLE
78886: EQUAL
78887: IFTRUE 78909
78889: LD_INT 5
78891: DOUBLE
78892: EQUAL
78893: IFTRUE 78909
78895: LD_INT 34
78897: DOUBLE
78898: EQUAL
78899: IFTRUE 78909
78901: LD_INT 37
78903: DOUBLE
78904: EQUAL
78905: IFTRUE 78909
78907: GO 78965
78909: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
78910: LD_ADDR_VAR 0 9
78914: PUSH
78915: LD_VAR 0 53
78919: PUSH
78920: LD_VAR 0 54
78924: PUSH
78925: LD_VAR 0 55
78929: PUSH
78930: LD_VAR 0 56
78934: PUSH
78935: LD_VAR 0 57
78939: PUSH
78940: LD_VAR 0 58
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: LIST
78949: LIST
78950: LIST
78951: LIST
78952: PUSH
78953: LD_VAR 0 4
78957: PUSH
78958: LD_INT 1
78960: PLUS
78961: ARRAY
78962: ST_TO_ADDR
78963: GO 79072
78965: LD_INT 31
78967: DOUBLE
78968: EQUAL
78969: IFTRUE 79015
78971: LD_INT 32
78973: DOUBLE
78974: EQUAL
78975: IFTRUE 79015
78977: LD_INT 33
78979: DOUBLE
78980: EQUAL
78981: IFTRUE 79015
78983: LD_INT 27
78985: DOUBLE
78986: EQUAL
78987: IFTRUE 79015
78989: LD_INT 26
78991: DOUBLE
78992: EQUAL
78993: IFTRUE 79015
78995: LD_INT 28
78997: DOUBLE
78998: EQUAL
78999: IFTRUE 79015
79001: LD_INT 29
79003: DOUBLE
79004: EQUAL
79005: IFTRUE 79015
79007: LD_INT 30
79009: DOUBLE
79010: EQUAL
79011: IFTRUE 79015
79013: GO 79071
79015: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
79016: LD_ADDR_VAR 0 9
79020: PUSH
79021: LD_VAR 0 59
79025: PUSH
79026: LD_VAR 0 60
79030: PUSH
79031: LD_VAR 0 61
79035: PUSH
79036: LD_VAR 0 62
79040: PUSH
79041: LD_VAR 0 63
79045: PUSH
79046: LD_VAR 0 64
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: LIST
79055: LIST
79056: LIST
79057: LIST
79058: PUSH
79059: LD_VAR 0 4
79063: PUSH
79064: LD_INT 1
79066: PLUS
79067: ARRAY
79068: ST_TO_ADDR
79069: GO 79072
79071: POP
// temp_list2 = [ ] ;
79072: LD_ADDR_VAR 0 10
79076: PUSH
79077: EMPTY
79078: ST_TO_ADDR
// for i in temp_list do
79079: LD_ADDR_VAR 0 8
79083: PUSH
79084: LD_VAR 0 9
79088: PUSH
79089: FOR_IN
79090: IFFALSE 79142
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
79092: LD_ADDR_VAR 0 10
79096: PUSH
79097: LD_VAR 0 10
79101: PUSH
79102: LD_VAR 0 8
79106: PUSH
79107: LD_INT 1
79109: ARRAY
79110: PUSH
79111: LD_VAR 0 2
79115: PLUS
79116: PUSH
79117: LD_VAR 0 8
79121: PUSH
79122: LD_INT 2
79124: ARRAY
79125: PUSH
79126: LD_VAR 0 3
79130: PLUS
79131: PUSH
79132: EMPTY
79133: LIST
79134: LIST
79135: PUSH
79136: EMPTY
79137: LIST
79138: ADD
79139: ST_TO_ADDR
79140: GO 79089
79142: POP
79143: POP
// result = temp_list2 ;
79144: LD_ADDR_VAR 0 7
79148: PUSH
79149: LD_VAR 0 10
79153: ST_TO_ADDR
// end ;
79154: LD_VAR 0 7
79158: RET
// export function EnemyInRange ( unit , dist ) ; begin
79159: LD_INT 0
79161: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
79162: LD_ADDR_VAR 0 3
79166: PUSH
79167: LD_VAR 0 1
79171: PPUSH
79172: CALL_OW 255
79176: PPUSH
79177: LD_VAR 0 1
79181: PPUSH
79182: CALL_OW 250
79186: PPUSH
79187: LD_VAR 0 1
79191: PPUSH
79192: CALL_OW 251
79196: PPUSH
79197: LD_VAR 0 2
79201: PPUSH
79202: CALL 53263 0 4
79206: PUSH
79207: LD_INT 4
79209: ARRAY
79210: ST_TO_ADDR
// end ;
79211: LD_VAR 0 3
79215: RET
// export function PlayerSeeMe ( unit ) ; begin
79216: LD_INT 0
79218: PPUSH
// result := See ( your_side , unit ) ;
79219: LD_ADDR_VAR 0 2
79223: PUSH
79224: LD_OWVAR 2
79228: PPUSH
79229: LD_VAR 0 1
79233: PPUSH
79234: CALL_OW 292
79238: ST_TO_ADDR
// end ;
79239: LD_VAR 0 2
79243: RET
// export function ReverseDir ( unit ) ; begin
79244: LD_INT 0
79246: PPUSH
// if not unit then
79247: LD_VAR 0 1
79251: NOT
79252: IFFALSE 79256
// exit ;
79254: GO 79279
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
79256: LD_ADDR_VAR 0 2
79260: PUSH
79261: LD_VAR 0 1
79265: PPUSH
79266: CALL_OW 254
79270: PUSH
79271: LD_INT 3
79273: PLUS
79274: PUSH
79275: LD_INT 6
79277: MOD
79278: ST_TO_ADDR
// end ;
79279: LD_VAR 0 2
79283: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
79284: LD_INT 0
79286: PPUSH
79287: PPUSH
79288: PPUSH
79289: PPUSH
79290: PPUSH
// if not hexes then
79291: LD_VAR 0 2
79295: NOT
79296: IFFALSE 79300
// exit ;
79298: GO 79448
// dist := 9999 ;
79300: LD_ADDR_VAR 0 5
79304: PUSH
79305: LD_INT 9999
79307: ST_TO_ADDR
// for i = 1 to hexes do
79308: LD_ADDR_VAR 0 4
79312: PUSH
79313: DOUBLE
79314: LD_INT 1
79316: DEC
79317: ST_TO_ADDR
79318: LD_VAR 0 2
79322: PUSH
79323: FOR_TO
79324: IFFALSE 79436
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
79326: LD_VAR 0 1
79330: PPUSH
79331: LD_VAR 0 2
79335: PUSH
79336: LD_VAR 0 4
79340: ARRAY
79341: PUSH
79342: LD_INT 1
79344: ARRAY
79345: PPUSH
79346: LD_VAR 0 2
79350: PUSH
79351: LD_VAR 0 4
79355: ARRAY
79356: PUSH
79357: LD_INT 2
79359: ARRAY
79360: PPUSH
79361: CALL_OW 297
79365: PUSH
79366: LD_VAR 0 5
79370: LESS
79371: IFFALSE 79434
// begin hex := hexes [ i ] ;
79373: LD_ADDR_VAR 0 7
79377: PUSH
79378: LD_VAR 0 2
79382: PUSH
79383: LD_VAR 0 4
79387: ARRAY
79388: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79389: LD_ADDR_VAR 0 5
79393: PUSH
79394: LD_VAR 0 1
79398: PPUSH
79399: LD_VAR 0 2
79403: PUSH
79404: LD_VAR 0 4
79408: ARRAY
79409: PUSH
79410: LD_INT 1
79412: ARRAY
79413: PPUSH
79414: LD_VAR 0 2
79418: PUSH
79419: LD_VAR 0 4
79423: ARRAY
79424: PUSH
79425: LD_INT 2
79427: ARRAY
79428: PPUSH
79429: CALL_OW 297
79433: ST_TO_ADDR
// end ; end ;
79434: GO 79323
79436: POP
79437: POP
// result := hex ;
79438: LD_ADDR_VAR 0 3
79442: PUSH
79443: LD_VAR 0 7
79447: ST_TO_ADDR
// end ;
79448: LD_VAR 0 3
79452: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
79453: LD_INT 0
79455: PPUSH
79456: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
79457: LD_VAR 0 1
79461: NOT
79462: PUSH
79463: LD_VAR 0 1
79467: PUSH
79468: LD_INT 21
79470: PUSH
79471: LD_INT 2
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 23
79480: PUSH
79481: LD_INT 2
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: PPUSH
79492: CALL_OW 69
79496: IN
79497: NOT
79498: OR
79499: IFFALSE 79503
// exit ;
79501: GO 79550
// for i = 1 to 3 do
79503: LD_ADDR_VAR 0 3
79507: PUSH
79508: DOUBLE
79509: LD_INT 1
79511: DEC
79512: ST_TO_ADDR
79513: LD_INT 3
79515: PUSH
79516: FOR_TO
79517: IFFALSE 79548
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
79519: LD_VAR 0 1
79523: PPUSH
79524: CALL_OW 250
79528: PPUSH
79529: LD_VAR 0 1
79533: PPUSH
79534: CALL_OW 251
79538: PPUSH
79539: LD_INT 1
79541: PPUSH
79542: CALL_OW 453
79546: GO 79516
79548: POP
79549: POP
// end ;
79550: LD_VAR 0 2
79554: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
79555: LD_INT 0
79557: PPUSH
79558: PPUSH
79559: PPUSH
79560: PPUSH
79561: PPUSH
79562: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
79563: LD_VAR 0 1
79567: NOT
79568: PUSH
79569: LD_VAR 0 2
79573: NOT
79574: OR
79575: PUSH
79576: LD_VAR 0 1
79580: PPUSH
79581: CALL_OW 314
79585: OR
79586: IFFALSE 79590
// exit ;
79588: GO 80031
// x := GetX ( enemy_unit ) ;
79590: LD_ADDR_VAR 0 7
79594: PUSH
79595: LD_VAR 0 2
79599: PPUSH
79600: CALL_OW 250
79604: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
79605: LD_ADDR_VAR 0 8
79609: PUSH
79610: LD_VAR 0 2
79614: PPUSH
79615: CALL_OW 251
79619: ST_TO_ADDR
// if not x or not y then
79620: LD_VAR 0 7
79624: NOT
79625: PUSH
79626: LD_VAR 0 8
79630: NOT
79631: OR
79632: IFFALSE 79636
// exit ;
79634: GO 80031
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
79636: LD_ADDR_VAR 0 6
79640: PUSH
79641: LD_VAR 0 7
79645: PPUSH
79646: LD_INT 0
79648: PPUSH
79649: LD_INT 4
79651: PPUSH
79652: CALL_OW 272
79656: PUSH
79657: LD_VAR 0 8
79661: PPUSH
79662: LD_INT 0
79664: PPUSH
79665: LD_INT 4
79667: PPUSH
79668: CALL_OW 273
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: PUSH
79677: LD_VAR 0 7
79681: PPUSH
79682: LD_INT 1
79684: PPUSH
79685: LD_INT 4
79687: PPUSH
79688: CALL_OW 272
79692: PUSH
79693: LD_VAR 0 8
79697: PPUSH
79698: LD_INT 1
79700: PPUSH
79701: LD_INT 4
79703: PPUSH
79704: CALL_OW 273
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: LD_VAR 0 7
79717: PPUSH
79718: LD_INT 2
79720: PPUSH
79721: LD_INT 4
79723: PPUSH
79724: CALL_OW 272
79728: PUSH
79729: LD_VAR 0 8
79733: PPUSH
79734: LD_INT 2
79736: PPUSH
79737: LD_INT 4
79739: PPUSH
79740: CALL_OW 273
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_VAR 0 7
79753: PPUSH
79754: LD_INT 3
79756: PPUSH
79757: LD_INT 4
79759: PPUSH
79760: CALL_OW 272
79764: PUSH
79765: LD_VAR 0 8
79769: PPUSH
79770: LD_INT 3
79772: PPUSH
79773: LD_INT 4
79775: PPUSH
79776: CALL_OW 273
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PUSH
79785: LD_VAR 0 7
79789: PPUSH
79790: LD_INT 4
79792: PPUSH
79793: LD_INT 4
79795: PPUSH
79796: CALL_OW 272
79800: PUSH
79801: LD_VAR 0 8
79805: PPUSH
79806: LD_INT 4
79808: PPUSH
79809: LD_INT 4
79811: PPUSH
79812: CALL_OW 273
79816: PUSH
79817: EMPTY
79818: LIST
79819: LIST
79820: PUSH
79821: LD_VAR 0 7
79825: PPUSH
79826: LD_INT 5
79828: PPUSH
79829: LD_INT 4
79831: PPUSH
79832: CALL_OW 272
79836: PUSH
79837: LD_VAR 0 8
79841: PPUSH
79842: LD_INT 5
79844: PPUSH
79845: LD_INT 4
79847: PPUSH
79848: CALL_OW 273
79852: PUSH
79853: EMPTY
79854: LIST
79855: LIST
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: LIST
79861: LIST
79862: LIST
79863: LIST
79864: ST_TO_ADDR
// for i = tmp downto 1 do
79865: LD_ADDR_VAR 0 4
79869: PUSH
79870: DOUBLE
79871: LD_VAR 0 6
79875: INC
79876: ST_TO_ADDR
79877: LD_INT 1
79879: PUSH
79880: FOR_DOWNTO
79881: IFFALSE 79982
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
79883: LD_VAR 0 6
79887: PUSH
79888: LD_VAR 0 4
79892: ARRAY
79893: PUSH
79894: LD_INT 1
79896: ARRAY
79897: PPUSH
79898: LD_VAR 0 6
79902: PUSH
79903: LD_VAR 0 4
79907: ARRAY
79908: PUSH
79909: LD_INT 2
79911: ARRAY
79912: PPUSH
79913: CALL_OW 488
79917: NOT
79918: PUSH
79919: LD_VAR 0 6
79923: PUSH
79924: LD_VAR 0 4
79928: ARRAY
79929: PUSH
79930: LD_INT 1
79932: ARRAY
79933: PPUSH
79934: LD_VAR 0 6
79938: PUSH
79939: LD_VAR 0 4
79943: ARRAY
79944: PUSH
79945: LD_INT 2
79947: ARRAY
79948: PPUSH
79949: CALL_OW 428
79953: PUSH
79954: LD_INT 0
79956: NONEQUAL
79957: OR
79958: IFFALSE 79980
// tmp := Delete ( tmp , i ) ;
79960: LD_ADDR_VAR 0 6
79964: PUSH
79965: LD_VAR 0 6
79969: PPUSH
79970: LD_VAR 0 4
79974: PPUSH
79975: CALL_OW 3
79979: ST_TO_ADDR
79980: GO 79880
79982: POP
79983: POP
// j := GetClosestHex ( unit , tmp ) ;
79984: LD_ADDR_VAR 0 5
79988: PUSH
79989: LD_VAR 0 1
79993: PPUSH
79994: LD_VAR 0 6
79998: PPUSH
79999: CALL 79284 0 2
80003: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
80004: LD_VAR 0 1
80008: PPUSH
80009: LD_VAR 0 5
80013: PUSH
80014: LD_INT 1
80016: ARRAY
80017: PPUSH
80018: LD_VAR 0 5
80022: PUSH
80023: LD_INT 2
80025: ARRAY
80026: PPUSH
80027: CALL_OW 111
// end ;
80031: LD_VAR 0 3
80035: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
80036: LD_INT 0
80038: PPUSH
80039: PPUSH
80040: PPUSH
// uc_side = 0 ;
80041: LD_ADDR_OWVAR 20
80045: PUSH
80046: LD_INT 0
80048: ST_TO_ADDR
// uc_nation = 0 ;
80049: LD_ADDR_OWVAR 21
80053: PUSH
80054: LD_INT 0
80056: ST_TO_ADDR
// InitHc ;
80057: CALL_OW 19
// InitVc ;
80061: CALL_OW 20
// if mastodonts then
80065: LD_VAR 0 6
80069: IFFALSE 80136
// for i = 1 to mastodonts do
80071: LD_ADDR_VAR 0 11
80075: PUSH
80076: DOUBLE
80077: LD_INT 1
80079: DEC
80080: ST_TO_ADDR
80081: LD_VAR 0 6
80085: PUSH
80086: FOR_TO
80087: IFFALSE 80134
// begin vc_chassis := 31 ;
80089: LD_ADDR_OWVAR 37
80093: PUSH
80094: LD_INT 31
80096: ST_TO_ADDR
// vc_control := control_rider ;
80097: LD_ADDR_OWVAR 38
80101: PUSH
80102: LD_INT 4
80104: ST_TO_ADDR
// animal := CreateVehicle ;
80105: LD_ADDR_VAR 0 12
80109: PUSH
80110: CALL_OW 45
80114: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80115: LD_VAR 0 12
80119: PPUSH
80120: LD_VAR 0 8
80124: PPUSH
80125: LD_INT 0
80127: PPUSH
80128: CALL 82205 0 3
// end ;
80132: GO 80086
80134: POP
80135: POP
// if horses then
80136: LD_VAR 0 5
80140: IFFALSE 80207
// for i = 1 to horses do
80142: LD_ADDR_VAR 0 11
80146: PUSH
80147: DOUBLE
80148: LD_INT 1
80150: DEC
80151: ST_TO_ADDR
80152: LD_VAR 0 5
80156: PUSH
80157: FOR_TO
80158: IFFALSE 80205
// begin hc_class := 21 ;
80160: LD_ADDR_OWVAR 28
80164: PUSH
80165: LD_INT 21
80167: ST_TO_ADDR
// hc_gallery :=  ;
80168: LD_ADDR_OWVAR 33
80172: PUSH
80173: LD_STRING 
80175: ST_TO_ADDR
// animal := CreateHuman ;
80176: LD_ADDR_VAR 0 12
80180: PUSH
80181: CALL_OW 44
80185: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80186: LD_VAR 0 12
80190: PPUSH
80191: LD_VAR 0 8
80195: PPUSH
80196: LD_INT 0
80198: PPUSH
80199: CALL 82205 0 3
// end ;
80203: GO 80157
80205: POP
80206: POP
// if birds then
80207: LD_VAR 0 1
80211: IFFALSE 80278
// for i = 1 to birds do
80213: LD_ADDR_VAR 0 11
80217: PUSH
80218: DOUBLE
80219: LD_INT 1
80221: DEC
80222: ST_TO_ADDR
80223: LD_VAR 0 1
80227: PUSH
80228: FOR_TO
80229: IFFALSE 80276
// begin hc_class = 18 ;
80231: LD_ADDR_OWVAR 28
80235: PUSH
80236: LD_INT 18
80238: ST_TO_ADDR
// hc_gallery =  ;
80239: LD_ADDR_OWVAR 33
80243: PUSH
80244: LD_STRING 
80246: ST_TO_ADDR
// animal := CreateHuman ;
80247: LD_ADDR_VAR 0 12
80251: PUSH
80252: CALL_OW 44
80256: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80257: LD_VAR 0 12
80261: PPUSH
80262: LD_VAR 0 8
80266: PPUSH
80267: LD_INT 0
80269: PPUSH
80270: CALL 82205 0 3
// end ;
80274: GO 80228
80276: POP
80277: POP
// if tigers then
80278: LD_VAR 0 2
80282: IFFALSE 80366
// for i = 1 to tigers do
80284: LD_ADDR_VAR 0 11
80288: PUSH
80289: DOUBLE
80290: LD_INT 1
80292: DEC
80293: ST_TO_ADDR
80294: LD_VAR 0 2
80298: PUSH
80299: FOR_TO
80300: IFFALSE 80364
// begin hc_class = class_tiger ;
80302: LD_ADDR_OWVAR 28
80306: PUSH
80307: LD_INT 14
80309: ST_TO_ADDR
// hc_gallery =  ;
80310: LD_ADDR_OWVAR 33
80314: PUSH
80315: LD_STRING 
80317: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
80318: LD_ADDR_OWVAR 35
80322: PUSH
80323: LD_INT 7
80325: NEG
80326: PPUSH
80327: LD_INT 7
80329: PPUSH
80330: CALL_OW 12
80334: ST_TO_ADDR
// animal := CreateHuman ;
80335: LD_ADDR_VAR 0 12
80339: PUSH
80340: CALL_OW 44
80344: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80345: LD_VAR 0 12
80349: PPUSH
80350: LD_VAR 0 8
80354: PPUSH
80355: LD_INT 0
80357: PPUSH
80358: CALL 82205 0 3
// end ;
80362: GO 80299
80364: POP
80365: POP
// if apemans then
80366: LD_VAR 0 3
80370: IFFALSE 80493
// for i = 1 to apemans do
80372: LD_ADDR_VAR 0 11
80376: PUSH
80377: DOUBLE
80378: LD_INT 1
80380: DEC
80381: ST_TO_ADDR
80382: LD_VAR 0 3
80386: PUSH
80387: FOR_TO
80388: IFFALSE 80491
// begin hc_class = class_apeman ;
80390: LD_ADDR_OWVAR 28
80394: PUSH
80395: LD_INT 12
80397: ST_TO_ADDR
// hc_gallery =  ;
80398: LD_ADDR_OWVAR 33
80402: PUSH
80403: LD_STRING 
80405: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
80406: LD_ADDR_OWVAR 35
80410: PUSH
80411: LD_INT 5
80413: NEG
80414: PPUSH
80415: LD_INT 5
80417: PPUSH
80418: CALL_OW 12
80422: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
80423: LD_ADDR_OWVAR 31
80427: PUSH
80428: LD_INT 1
80430: PPUSH
80431: LD_INT 3
80433: PPUSH
80434: CALL_OW 12
80438: PUSH
80439: LD_INT 1
80441: PPUSH
80442: LD_INT 3
80444: PPUSH
80445: CALL_OW 12
80449: PUSH
80450: LD_INT 0
80452: PUSH
80453: LD_INT 0
80455: PUSH
80456: EMPTY
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: ST_TO_ADDR
// animal := CreateHuman ;
80462: LD_ADDR_VAR 0 12
80466: PUSH
80467: CALL_OW 44
80471: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80472: LD_VAR 0 12
80476: PPUSH
80477: LD_VAR 0 8
80481: PPUSH
80482: LD_INT 0
80484: PPUSH
80485: CALL 82205 0 3
// end ;
80489: GO 80387
80491: POP
80492: POP
// if enchidnas then
80493: LD_VAR 0 4
80497: IFFALSE 80564
// for i = 1 to enchidnas do
80499: LD_ADDR_VAR 0 11
80503: PUSH
80504: DOUBLE
80505: LD_INT 1
80507: DEC
80508: ST_TO_ADDR
80509: LD_VAR 0 4
80513: PUSH
80514: FOR_TO
80515: IFFALSE 80562
// begin hc_class = 13 ;
80517: LD_ADDR_OWVAR 28
80521: PUSH
80522: LD_INT 13
80524: ST_TO_ADDR
// hc_gallery =  ;
80525: LD_ADDR_OWVAR 33
80529: PUSH
80530: LD_STRING 
80532: ST_TO_ADDR
// animal := CreateHuman ;
80533: LD_ADDR_VAR 0 12
80537: PUSH
80538: CALL_OW 44
80542: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80543: LD_VAR 0 12
80547: PPUSH
80548: LD_VAR 0 8
80552: PPUSH
80553: LD_INT 0
80555: PPUSH
80556: CALL 82205 0 3
// end ;
80560: GO 80514
80562: POP
80563: POP
// if fishes then
80564: LD_VAR 0 7
80568: IFFALSE 80635
// for i = 1 to fishes do
80570: LD_ADDR_VAR 0 11
80574: PUSH
80575: DOUBLE
80576: LD_INT 1
80578: DEC
80579: ST_TO_ADDR
80580: LD_VAR 0 7
80584: PUSH
80585: FOR_TO
80586: IFFALSE 80633
// begin hc_class = 20 ;
80588: LD_ADDR_OWVAR 28
80592: PUSH
80593: LD_INT 20
80595: ST_TO_ADDR
// hc_gallery =  ;
80596: LD_ADDR_OWVAR 33
80600: PUSH
80601: LD_STRING 
80603: ST_TO_ADDR
// animal := CreateHuman ;
80604: LD_ADDR_VAR 0 12
80608: PUSH
80609: CALL_OW 44
80613: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
80614: LD_VAR 0 12
80618: PPUSH
80619: LD_VAR 0 9
80623: PPUSH
80624: LD_INT 0
80626: PPUSH
80627: CALL 82205 0 3
// end ;
80631: GO 80585
80633: POP
80634: POP
// end ;
80635: LD_VAR 0 10
80639: RET
// export function WantHeal ( sci , unit ) ; begin
80640: LD_INT 0
80642: PPUSH
// if GetTaskList ( sci ) > 0 then
80643: LD_VAR 0 1
80647: PPUSH
80648: CALL_OW 437
80652: PUSH
80653: LD_INT 0
80655: GREATER
80656: IFFALSE 80726
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
80658: LD_VAR 0 1
80662: PPUSH
80663: CALL_OW 437
80667: PUSH
80668: LD_INT 1
80670: ARRAY
80671: PUSH
80672: LD_INT 1
80674: ARRAY
80675: PUSH
80676: LD_STRING l
80678: EQUAL
80679: PUSH
80680: LD_VAR 0 1
80684: PPUSH
80685: CALL_OW 437
80689: PUSH
80690: LD_INT 1
80692: ARRAY
80693: PUSH
80694: LD_INT 4
80696: ARRAY
80697: PUSH
80698: LD_VAR 0 2
80702: EQUAL
80703: AND
80704: IFFALSE 80716
// result := true else
80706: LD_ADDR_VAR 0 3
80710: PUSH
80711: LD_INT 1
80713: ST_TO_ADDR
80714: GO 80724
// result := false ;
80716: LD_ADDR_VAR 0 3
80720: PUSH
80721: LD_INT 0
80723: ST_TO_ADDR
// end else
80724: GO 80734
// result := false ;
80726: LD_ADDR_VAR 0 3
80730: PUSH
80731: LD_INT 0
80733: ST_TO_ADDR
// end ;
80734: LD_VAR 0 3
80738: RET
// export function HealTarget ( sci ) ; begin
80739: LD_INT 0
80741: PPUSH
// if not sci then
80742: LD_VAR 0 1
80746: NOT
80747: IFFALSE 80751
// exit ;
80749: GO 80816
// result := 0 ;
80751: LD_ADDR_VAR 0 2
80755: PUSH
80756: LD_INT 0
80758: ST_TO_ADDR
// if GetTaskList ( sci ) then
80759: LD_VAR 0 1
80763: PPUSH
80764: CALL_OW 437
80768: IFFALSE 80816
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
80770: LD_VAR 0 1
80774: PPUSH
80775: CALL_OW 437
80779: PUSH
80780: LD_INT 1
80782: ARRAY
80783: PUSH
80784: LD_INT 1
80786: ARRAY
80787: PUSH
80788: LD_STRING l
80790: EQUAL
80791: IFFALSE 80816
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
80793: LD_ADDR_VAR 0 2
80797: PUSH
80798: LD_VAR 0 1
80802: PPUSH
80803: CALL_OW 437
80807: PUSH
80808: LD_INT 1
80810: ARRAY
80811: PUSH
80812: LD_INT 4
80814: ARRAY
80815: ST_TO_ADDR
// end ;
80816: LD_VAR 0 2
80820: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
80821: LD_INT 0
80823: PPUSH
80824: PPUSH
80825: PPUSH
80826: PPUSH
// if not base_units then
80827: LD_VAR 0 1
80831: NOT
80832: IFFALSE 80836
// exit ;
80834: GO 80923
// result := false ;
80836: LD_ADDR_VAR 0 2
80840: PUSH
80841: LD_INT 0
80843: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
80844: LD_ADDR_VAR 0 5
80848: PUSH
80849: LD_VAR 0 1
80853: PPUSH
80854: LD_INT 21
80856: PUSH
80857: LD_INT 3
80859: PUSH
80860: EMPTY
80861: LIST
80862: LIST
80863: PPUSH
80864: CALL_OW 72
80868: ST_TO_ADDR
// if not tmp then
80869: LD_VAR 0 5
80873: NOT
80874: IFFALSE 80878
// exit ;
80876: GO 80923
// for i in tmp do
80878: LD_ADDR_VAR 0 3
80882: PUSH
80883: LD_VAR 0 5
80887: PUSH
80888: FOR_IN
80889: IFFALSE 80921
// begin result := EnemyInRange ( i , 22 ) ;
80891: LD_ADDR_VAR 0 2
80895: PUSH
80896: LD_VAR 0 3
80900: PPUSH
80901: LD_INT 22
80903: PPUSH
80904: CALL 79159 0 2
80908: ST_TO_ADDR
// if result then
80909: LD_VAR 0 2
80913: IFFALSE 80919
// exit ;
80915: POP
80916: POP
80917: GO 80923
// end ;
80919: GO 80888
80921: POP
80922: POP
// end ;
80923: LD_VAR 0 2
80927: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
80928: LD_INT 0
80930: PPUSH
80931: PPUSH
// if not units then
80932: LD_VAR 0 1
80936: NOT
80937: IFFALSE 80941
// exit ;
80939: GO 81011
// result := [ ] ;
80941: LD_ADDR_VAR 0 3
80945: PUSH
80946: EMPTY
80947: ST_TO_ADDR
// for i in units do
80948: LD_ADDR_VAR 0 4
80952: PUSH
80953: LD_VAR 0 1
80957: PUSH
80958: FOR_IN
80959: IFFALSE 81009
// if GetTag ( i ) = tag then
80961: LD_VAR 0 4
80965: PPUSH
80966: CALL_OW 110
80970: PUSH
80971: LD_VAR 0 2
80975: EQUAL
80976: IFFALSE 81007
// result := Insert ( result , result + 1 , i ) ;
80978: LD_ADDR_VAR 0 3
80982: PUSH
80983: LD_VAR 0 3
80987: PPUSH
80988: LD_VAR 0 3
80992: PUSH
80993: LD_INT 1
80995: PLUS
80996: PPUSH
80997: LD_VAR 0 4
81001: PPUSH
81002: CALL_OW 2
81006: ST_TO_ADDR
81007: GO 80958
81009: POP
81010: POP
// end ;
81011: LD_VAR 0 3
81015: RET
// export function IsDriver ( un ) ; begin
81016: LD_INT 0
81018: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
81019: LD_ADDR_VAR 0 2
81023: PUSH
81024: LD_VAR 0 1
81028: PUSH
81029: LD_INT 55
81031: PUSH
81032: EMPTY
81033: LIST
81034: PPUSH
81035: CALL_OW 69
81039: IN
81040: ST_TO_ADDR
// end ;
81041: LD_VAR 0 2
81045: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
81046: LD_INT 0
81048: PPUSH
81049: PPUSH
// list := [ ] ;
81050: LD_ADDR_VAR 0 5
81054: PUSH
81055: EMPTY
81056: ST_TO_ADDR
// case d of 0 :
81057: LD_VAR 0 3
81061: PUSH
81062: LD_INT 0
81064: DOUBLE
81065: EQUAL
81066: IFTRUE 81070
81068: GO 81203
81070: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
81071: LD_ADDR_VAR 0 5
81075: PUSH
81076: LD_VAR 0 1
81080: PUSH
81081: LD_INT 4
81083: MINUS
81084: PUSH
81085: LD_VAR 0 2
81089: PUSH
81090: LD_INT 4
81092: MINUS
81093: PUSH
81094: LD_INT 2
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: LIST
81101: PUSH
81102: LD_VAR 0 1
81106: PUSH
81107: LD_INT 3
81109: MINUS
81110: PUSH
81111: LD_VAR 0 2
81115: PUSH
81116: LD_INT 1
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: LIST
81123: PUSH
81124: LD_VAR 0 1
81128: PUSH
81129: LD_INT 4
81131: PLUS
81132: PUSH
81133: LD_VAR 0 2
81137: PUSH
81138: LD_INT 4
81140: PUSH
81141: EMPTY
81142: LIST
81143: LIST
81144: LIST
81145: PUSH
81146: LD_VAR 0 1
81150: PUSH
81151: LD_INT 3
81153: PLUS
81154: PUSH
81155: LD_VAR 0 2
81159: PUSH
81160: LD_INT 3
81162: PLUS
81163: PUSH
81164: LD_INT 5
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: LIST
81171: PUSH
81172: LD_VAR 0 1
81176: PUSH
81177: LD_VAR 0 2
81181: PUSH
81182: LD_INT 4
81184: PLUS
81185: PUSH
81186: LD_INT 0
81188: PUSH
81189: EMPTY
81190: LIST
81191: LIST
81192: LIST
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: LIST
81198: LIST
81199: LIST
81200: ST_TO_ADDR
// end ; 1 :
81201: GO 81901
81203: LD_INT 1
81205: DOUBLE
81206: EQUAL
81207: IFTRUE 81211
81209: GO 81344
81211: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
81212: LD_ADDR_VAR 0 5
81216: PUSH
81217: LD_VAR 0 1
81221: PUSH
81222: LD_VAR 0 2
81226: PUSH
81227: LD_INT 4
81229: MINUS
81230: PUSH
81231: LD_INT 3
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: LIST
81238: PUSH
81239: LD_VAR 0 1
81243: PUSH
81244: LD_INT 3
81246: MINUS
81247: PUSH
81248: LD_VAR 0 2
81252: PUSH
81253: LD_INT 3
81255: MINUS
81256: PUSH
81257: LD_INT 2
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: LIST
81264: PUSH
81265: LD_VAR 0 1
81269: PUSH
81270: LD_INT 4
81272: MINUS
81273: PUSH
81274: LD_VAR 0 2
81278: PUSH
81279: LD_INT 1
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: LIST
81286: PUSH
81287: LD_VAR 0 1
81291: PUSH
81292: LD_VAR 0 2
81296: PUSH
81297: LD_INT 3
81299: PLUS
81300: PUSH
81301: LD_INT 0
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: LIST
81308: PUSH
81309: LD_VAR 0 1
81313: PUSH
81314: LD_INT 4
81316: PLUS
81317: PUSH
81318: LD_VAR 0 2
81322: PUSH
81323: LD_INT 4
81325: PLUS
81326: PUSH
81327: LD_INT 5
81329: PUSH
81330: EMPTY
81331: LIST
81332: LIST
81333: LIST
81334: PUSH
81335: EMPTY
81336: LIST
81337: LIST
81338: LIST
81339: LIST
81340: LIST
81341: ST_TO_ADDR
// end ; 2 :
81342: GO 81901
81344: LD_INT 2
81346: DOUBLE
81347: EQUAL
81348: IFTRUE 81352
81350: GO 81481
81352: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
81353: LD_ADDR_VAR 0 5
81357: PUSH
81358: LD_VAR 0 1
81362: PUSH
81363: LD_VAR 0 2
81367: PUSH
81368: LD_INT 3
81370: MINUS
81371: PUSH
81372: LD_INT 3
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: LIST
81379: PUSH
81380: LD_VAR 0 1
81384: PUSH
81385: LD_INT 4
81387: PLUS
81388: PUSH
81389: LD_VAR 0 2
81393: PUSH
81394: LD_INT 4
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: LIST
81401: PUSH
81402: LD_VAR 0 1
81406: PUSH
81407: LD_VAR 0 2
81411: PUSH
81412: LD_INT 4
81414: PLUS
81415: PUSH
81416: LD_INT 0
81418: PUSH
81419: EMPTY
81420: LIST
81421: LIST
81422: LIST
81423: PUSH
81424: LD_VAR 0 1
81428: PUSH
81429: LD_INT 3
81431: MINUS
81432: PUSH
81433: LD_VAR 0 2
81437: PUSH
81438: LD_INT 1
81440: PUSH
81441: EMPTY
81442: LIST
81443: LIST
81444: LIST
81445: PUSH
81446: LD_VAR 0 1
81450: PUSH
81451: LD_INT 4
81453: MINUS
81454: PUSH
81455: LD_VAR 0 2
81459: PUSH
81460: LD_INT 4
81462: MINUS
81463: PUSH
81464: LD_INT 2
81466: PUSH
81467: EMPTY
81468: LIST
81469: LIST
81470: LIST
81471: PUSH
81472: EMPTY
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: ST_TO_ADDR
// end ; 3 :
81479: GO 81901
81481: LD_INT 3
81483: DOUBLE
81484: EQUAL
81485: IFTRUE 81489
81487: GO 81622
81489: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
81490: LD_ADDR_VAR 0 5
81494: PUSH
81495: LD_VAR 0 1
81499: PUSH
81500: LD_INT 3
81502: PLUS
81503: PUSH
81504: LD_VAR 0 2
81508: PUSH
81509: LD_INT 4
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: LIST
81516: PUSH
81517: LD_VAR 0 1
81521: PUSH
81522: LD_INT 4
81524: PLUS
81525: PUSH
81526: LD_VAR 0 2
81530: PUSH
81531: LD_INT 4
81533: PLUS
81534: PUSH
81535: LD_INT 5
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: LIST
81542: PUSH
81543: LD_VAR 0 1
81547: PUSH
81548: LD_INT 4
81550: MINUS
81551: PUSH
81552: LD_VAR 0 2
81556: PUSH
81557: LD_INT 1
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: LIST
81564: PUSH
81565: LD_VAR 0 1
81569: PUSH
81570: LD_VAR 0 2
81574: PUSH
81575: LD_INT 4
81577: MINUS
81578: PUSH
81579: LD_INT 3
81581: PUSH
81582: EMPTY
81583: LIST
81584: LIST
81585: LIST
81586: PUSH
81587: LD_VAR 0 1
81591: PUSH
81592: LD_INT 3
81594: MINUS
81595: PUSH
81596: LD_VAR 0 2
81600: PUSH
81601: LD_INT 3
81603: MINUS
81604: PUSH
81605: LD_INT 2
81607: PUSH
81608: EMPTY
81609: LIST
81610: LIST
81611: LIST
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: ST_TO_ADDR
// end ; 4 :
81620: GO 81901
81622: LD_INT 4
81624: DOUBLE
81625: EQUAL
81626: IFTRUE 81630
81628: GO 81763
81630: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
81631: LD_ADDR_VAR 0 5
81635: PUSH
81636: LD_VAR 0 1
81640: PUSH
81641: LD_VAR 0 2
81645: PUSH
81646: LD_INT 4
81648: PLUS
81649: PUSH
81650: LD_INT 0
81652: PUSH
81653: EMPTY
81654: LIST
81655: LIST
81656: LIST
81657: PUSH
81658: LD_VAR 0 1
81662: PUSH
81663: LD_INT 3
81665: PLUS
81666: PUSH
81667: LD_VAR 0 2
81671: PUSH
81672: LD_INT 3
81674: PLUS
81675: PUSH
81676: LD_INT 5
81678: PUSH
81679: EMPTY
81680: LIST
81681: LIST
81682: LIST
81683: PUSH
81684: LD_VAR 0 1
81688: PUSH
81689: LD_INT 4
81691: PLUS
81692: PUSH
81693: LD_VAR 0 2
81697: PUSH
81698: LD_INT 4
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: LIST
81705: PUSH
81706: LD_VAR 0 1
81710: PUSH
81711: LD_VAR 0 2
81715: PUSH
81716: LD_INT 3
81718: MINUS
81719: PUSH
81720: LD_INT 3
81722: PUSH
81723: EMPTY
81724: LIST
81725: LIST
81726: LIST
81727: PUSH
81728: LD_VAR 0 1
81732: PUSH
81733: LD_INT 4
81735: MINUS
81736: PUSH
81737: LD_VAR 0 2
81741: PUSH
81742: LD_INT 4
81744: MINUS
81745: PUSH
81746: LD_INT 2
81748: PUSH
81749: EMPTY
81750: LIST
81751: LIST
81752: LIST
81753: PUSH
81754: EMPTY
81755: LIST
81756: LIST
81757: LIST
81758: LIST
81759: LIST
81760: ST_TO_ADDR
// end ; 5 :
81761: GO 81901
81763: LD_INT 5
81765: DOUBLE
81766: EQUAL
81767: IFTRUE 81771
81769: GO 81900
81771: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
81772: LD_ADDR_VAR 0 5
81776: PUSH
81777: LD_VAR 0 1
81781: PUSH
81782: LD_INT 4
81784: MINUS
81785: PUSH
81786: LD_VAR 0 2
81790: PUSH
81791: LD_INT 1
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: LIST
81798: PUSH
81799: LD_VAR 0 1
81803: PUSH
81804: LD_VAR 0 2
81808: PUSH
81809: LD_INT 4
81811: MINUS
81812: PUSH
81813: LD_INT 3
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: LIST
81820: PUSH
81821: LD_VAR 0 1
81825: PUSH
81826: LD_INT 4
81828: PLUS
81829: PUSH
81830: LD_VAR 0 2
81834: PUSH
81835: LD_INT 4
81837: PLUS
81838: PUSH
81839: LD_INT 5
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: LIST
81846: PUSH
81847: LD_VAR 0 1
81851: PUSH
81852: LD_INT 3
81854: PLUS
81855: PUSH
81856: LD_VAR 0 2
81860: PUSH
81861: LD_INT 4
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: LIST
81868: PUSH
81869: LD_VAR 0 1
81873: PUSH
81874: LD_VAR 0 2
81878: PUSH
81879: LD_INT 3
81881: PLUS
81882: PUSH
81883: LD_INT 0
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: LIST
81890: PUSH
81891: EMPTY
81892: LIST
81893: LIST
81894: LIST
81895: LIST
81896: LIST
81897: ST_TO_ADDR
// end ; end ;
81898: GO 81901
81900: POP
// result := list ;
81901: LD_ADDR_VAR 0 4
81905: PUSH
81906: LD_VAR 0 5
81910: ST_TO_ADDR
// end ;
81911: LD_VAR 0 4
81915: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
81916: LD_INT 0
81918: PPUSH
81919: PPUSH
81920: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
81921: LD_VAR 0 1
81925: NOT
81926: PUSH
81927: LD_VAR 0 2
81931: PUSH
81932: LD_INT 1
81934: PUSH
81935: LD_INT 2
81937: PUSH
81938: LD_INT 3
81940: PUSH
81941: LD_INT 4
81943: PUSH
81944: EMPTY
81945: LIST
81946: LIST
81947: LIST
81948: LIST
81949: IN
81950: NOT
81951: OR
81952: IFFALSE 81956
// exit ;
81954: GO 82048
// tmp := [ ] ;
81956: LD_ADDR_VAR 0 5
81960: PUSH
81961: EMPTY
81962: ST_TO_ADDR
// for i in units do
81963: LD_ADDR_VAR 0 4
81967: PUSH
81968: LD_VAR 0 1
81972: PUSH
81973: FOR_IN
81974: IFFALSE 82017
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
81976: LD_ADDR_VAR 0 5
81980: PUSH
81981: LD_VAR 0 5
81985: PPUSH
81986: LD_VAR 0 5
81990: PUSH
81991: LD_INT 1
81993: PLUS
81994: PPUSH
81995: LD_VAR 0 4
81999: PPUSH
82000: LD_VAR 0 2
82004: PPUSH
82005: CALL_OW 259
82009: PPUSH
82010: CALL_OW 2
82014: ST_TO_ADDR
82015: GO 81973
82017: POP
82018: POP
// if not tmp then
82019: LD_VAR 0 5
82023: NOT
82024: IFFALSE 82028
// exit ;
82026: GO 82048
// result := SortListByListDesc ( units , tmp ) ;
82028: LD_ADDR_VAR 0 3
82032: PUSH
82033: LD_VAR 0 1
82037: PPUSH
82038: LD_VAR 0 5
82042: PPUSH
82043: CALL_OW 77
82047: ST_TO_ADDR
// end ;
82048: LD_VAR 0 3
82052: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
82053: LD_INT 0
82055: PPUSH
82056: PPUSH
82057: PPUSH
// x := GetX ( building ) ;
82058: LD_ADDR_VAR 0 4
82062: PUSH
82063: LD_VAR 0 2
82067: PPUSH
82068: CALL_OW 250
82072: ST_TO_ADDR
// y := GetY ( building ) ;
82073: LD_ADDR_VAR 0 5
82077: PUSH
82078: LD_VAR 0 2
82082: PPUSH
82083: CALL_OW 251
82087: ST_TO_ADDR
// if GetTaskList ( unit ) then
82088: LD_VAR 0 1
82092: PPUSH
82093: CALL_OW 437
82097: IFFALSE 82192
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
82099: LD_STRING e
82101: PUSH
82102: LD_VAR 0 1
82106: PPUSH
82107: CALL_OW 437
82111: PUSH
82112: LD_INT 1
82114: ARRAY
82115: PUSH
82116: LD_INT 1
82118: ARRAY
82119: EQUAL
82120: PUSH
82121: LD_VAR 0 4
82125: PUSH
82126: LD_VAR 0 1
82130: PPUSH
82131: CALL_OW 437
82135: PUSH
82136: LD_INT 1
82138: ARRAY
82139: PUSH
82140: LD_INT 2
82142: ARRAY
82143: EQUAL
82144: AND
82145: PUSH
82146: LD_VAR 0 5
82150: PUSH
82151: LD_VAR 0 1
82155: PPUSH
82156: CALL_OW 437
82160: PUSH
82161: LD_INT 1
82163: ARRAY
82164: PUSH
82165: LD_INT 3
82167: ARRAY
82168: EQUAL
82169: AND
82170: IFFALSE 82182
// result := true else
82172: LD_ADDR_VAR 0 3
82176: PUSH
82177: LD_INT 1
82179: ST_TO_ADDR
82180: GO 82190
// result := false ;
82182: LD_ADDR_VAR 0 3
82186: PUSH
82187: LD_INT 0
82189: ST_TO_ADDR
// end else
82190: GO 82200
// result := false ;
82192: LD_ADDR_VAR 0 3
82196: PUSH
82197: LD_INT 0
82199: ST_TO_ADDR
// end ;
82200: LD_VAR 0 3
82204: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
82205: LD_INT 0
82207: PPUSH
82208: PPUSH
82209: PPUSH
82210: PPUSH
// if not unit or not area then
82211: LD_VAR 0 1
82215: NOT
82216: PUSH
82217: LD_VAR 0 2
82221: NOT
82222: OR
82223: IFFALSE 82227
// exit ;
82225: GO 82391
// tmp := AreaToList ( area , i ) ;
82227: LD_ADDR_VAR 0 6
82231: PUSH
82232: LD_VAR 0 2
82236: PPUSH
82237: LD_VAR 0 5
82241: PPUSH
82242: CALL_OW 517
82246: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
82247: LD_ADDR_VAR 0 5
82251: PUSH
82252: DOUBLE
82253: LD_INT 1
82255: DEC
82256: ST_TO_ADDR
82257: LD_VAR 0 6
82261: PUSH
82262: LD_INT 1
82264: ARRAY
82265: PUSH
82266: FOR_TO
82267: IFFALSE 82389
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
82269: LD_ADDR_VAR 0 7
82273: PUSH
82274: LD_VAR 0 6
82278: PUSH
82279: LD_INT 1
82281: ARRAY
82282: PUSH
82283: LD_VAR 0 5
82287: ARRAY
82288: PUSH
82289: LD_VAR 0 6
82293: PUSH
82294: LD_INT 2
82296: ARRAY
82297: PUSH
82298: LD_VAR 0 5
82302: ARRAY
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
82308: LD_VAR 0 7
82312: PUSH
82313: LD_INT 1
82315: ARRAY
82316: PPUSH
82317: LD_VAR 0 7
82321: PUSH
82322: LD_INT 2
82324: ARRAY
82325: PPUSH
82326: CALL_OW 428
82330: PUSH
82331: LD_INT 0
82333: EQUAL
82334: IFFALSE 82387
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
82336: LD_VAR 0 1
82340: PPUSH
82341: LD_VAR 0 7
82345: PUSH
82346: LD_INT 1
82348: ARRAY
82349: PPUSH
82350: LD_VAR 0 7
82354: PUSH
82355: LD_INT 2
82357: ARRAY
82358: PPUSH
82359: LD_VAR 0 3
82363: PPUSH
82364: CALL_OW 48
// result := IsPlaced ( unit ) ;
82368: LD_ADDR_VAR 0 4
82372: PUSH
82373: LD_VAR 0 1
82377: PPUSH
82378: CALL_OW 305
82382: ST_TO_ADDR
// exit ;
82383: POP
82384: POP
82385: GO 82391
// end ; end ;
82387: GO 82266
82389: POP
82390: POP
// end ;
82391: LD_VAR 0 4
82395: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
82396: LD_INT 0
82398: PPUSH
82399: PPUSH
82400: PPUSH
// if not side or side > 8 then
82401: LD_VAR 0 1
82405: NOT
82406: PUSH
82407: LD_VAR 0 1
82411: PUSH
82412: LD_INT 8
82414: GREATER
82415: OR
82416: IFFALSE 82420
// exit ;
82418: GO 82607
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
82420: LD_ADDR_VAR 0 4
82424: PUSH
82425: LD_INT 22
82427: PUSH
82428: LD_VAR 0 1
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 21
82439: PUSH
82440: LD_INT 3
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: PUSH
82447: EMPTY
82448: LIST
82449: LIST
82450: PPUSH
82451: CALL_OW 69
82455: ST_TO_ADDR
// if not tmp then
82456: LD_VAR 0 4
82460: NOT
82461: IFFALSE 82465
// exit ;
82463: GO 82607
// enable_addtolog := true ;
82465: LD_ADDR_OWVAR 81
82469: PUSH
82470: LD_INT 1
82472: ST_TO_ADDR
// AddToLog ( [ ) ;
82473: LD_STRING [
82475: PPUSH
82476: CALL_OW 561
// for i in tmp do
82480: LD_ADDR_VAR 0 3
82484: PUSH
82485: LD_VAR 0 4
82489: PUSH
82490: FOR_IN
82491: IFFALSE 82598
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
82493: LD_STRING [
82495: PUSH
82496: LD_VAR 0 3
82500: PPUSH
82501: CALL_OW 266
82505: STR
82506: PUSH
82507: LD_STRING , 
82509: STR
82510: PUSH
82511: LD_VAR 0 3
82515: PPUSH
82516: CALL_OW 250
82520: STR
82521: PUSH
82522: LD_STRING , 
82524: STR
82525: PUSH
82526: LD_VAR 0 3
82530: PPUSH
82531: CALL_OW 251
82535: STR
82536: PUSH
82537: LD_STRING , 
82539: STR
82540: PUSH
82541: LD_VAR 0 3
82545: PPUSH
82546: CALL_OW 254
82550: STR
82551: PUSH
82552: LD_STRING , 
82554: STR
82555: PUSH
82556: LD_VAR 0 3
82560: PPUSH
82561: LD_INT 1
82563: PPUSH
82564: CALL_OW 268
82568: STR
82569: PUSH
82570: LD_STRING , 
82572: STR
82573: PUSH
82574: LD_VAR 0 3
82578: PPUSH
82579: LD_INT 2
82581: PPUSH
82582: CALL_OW 268
82586: STR
82587: PUSH
82588: LD_STRING ],
82590: STR
82591: PPUSH
82592: CALL_OW 561
// end ;
82596: GO 82490
82598: POP
82599: POP
// AddToLog ( ]; ) ;
82600: LD_STRING ];
82602: PPUSH
82603: CALL_OW 561
// end ;
82607: LD_VAR 0 2
82611: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
82612: LD_INT 0
82614: PPUSH
82615: PPUSH
82616: PPUSH
82617: PPUSH
82618: PPUSH
// if not area or not rate or not max then
82619: LD_VAR 0 1
82623: NOT
82624: PUSH
82625: LD_VAR 0 2
82629: NOT
82630: OR
82631: PUSH
82632: LD_VAR 0 4
82636: NOT
82637: OR
82638: IFFALSE 82642
// exit ;
82640: GO 82834
// while 1 do
82642: LD_INT 1
82644: IFFALSE 82834
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
82646: LD_ADDR_VAR 0 9
82650: PUSH
82651: LD_VAR 0 1
82655: PPUSH
82656: LD_INT 1
82658: PPUSH
82659: CALL_OW 287
82663: PUSH
82664: LD_INT 10
82666: MUL
82667: ST_TO_ADDR
// r := rate / 10 ;
82668: LD_ADDR_VAR 0 7
82672: PUSH
82673: LD_VAR 0 2
82677: PUSH
82678: LD_INT 10
82680: DIVREAL
82681: ST_TO_ADDR
// time := 1 1$00 ;
82682: LD_ADDR_VAR 0 8
82686: PUSH
82687: LD_INT 2100
82689: ST_TO_ADDR
// if amount < min then
82690: LD_VAR 0 9
82694: PUSH
82695: LD_VAR 0 3
82699: LESS
82700: IFFALSE 82718
// r := r * 2 else
82702: LD_ADDR_VAR 0 7
82706: PUSH
82707: LD_VAR 0 7
82711: PUSH
82712: LD_INT 2
82714: MUL
82715: ST_TO_ADDR
82716: GO 82744
// if amount > max then
82718: LD_VAR 0 9
82722: PUSH
82723: LD_VAR 0 4
82727: GREATER
82728: IFFALSE 82744
// r := r / 2 ;
82730: LD_ADDR_VAR 0 7
82734: PUSH
82735: LD_VAR 0 7
82739: PUSH
82740: LD_INT 2
82742: DIVREAL
82743: ST_TO_ADDR
// time := time / r ;
82744: LD_ADDR_VAR 0 8
82748: PUSH
82749: LD_VAR 0 8
82753: PUSH
82754: LD_VAR 0 7
82758: DIVREAL
82759: ST_TO_ADDR
// if time < 0 then
82760: LD_VAR 0 8
82764: PUSH
82765: LD_INT 0
82767: LESS
82768: IFFALSE 82785
// time := time * - 1 ;
82770: LD_ADDR_VAR 0 8
82774: PUSH
82775: LD_VAR 0 8
82779: PUSH
82780: LD_INT 1
82782: NEG
82783: MUL
82784: ST_TO_ADDR
// wait ( time ) ;
82785: LD_VAR 0 8
82789: PPUSH
82790: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
82794: LD_INT 35
82796: PPUSH
82797: LD_INT 875
82799: PPUSH
82800: CALL_OW 12
82804: PPUSH
82805: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
82809: LD_INT 1
82811: PPUSH
82812: LD_INT 5
82814: PPUSH
82815: CALL_OW 12
82819: PPUSH
82820: LD_VAR 0 1
82824: PPUSH
82825: LD_INT 1
82827: PPUSH
82828: CALL_OW 55
// end ;
82832: GO 82642
// end ;
82834: LD_VAR 0 5
82838: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
82839: LD_INT 0
82841: PPUSH
82842: PPUSH
82843: PPUSH
82844: PPUSH
82845: PPUSH
82846: PPUSH
82847: PPUSH
82848: PPUSH
// if not turrets or not factories then
82849: LD_VAR 0 1
82853: NOT
82854: PUSH
82855: LD_VAR 0 2
82859: NOT
82860: OR
82861: IFFALSE 82865
// exit ;
82863: GO 83172
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
82865: LD_ADDR_VAR 0 10
82869: PUSH
82870: LD_INT 5
82872: PUSH
82873: LD_INT 6
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 2
82882: PUSH
82883: LD_INT 4
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 3
82892: PUSH
82893: LD_INT 5
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PUSH
82900: EMPTY
82901: LIST
82902: LIST
82903: LIST
82904: PUSH
82905: LD_INT 24
82907: PUSH
82908: LD_INT 25
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: PUSH
82915: LD_INT 23
82917: PUSH
82918: LD_INT 27
82920: PUSH
82921: EMPTY
82922: LIST
82923: LIST
82924: PUSH
82925: EMPTY
82926: LIST
82927: LIST
82928: PUSH
82929: LD_INT 42
82931: PUSH
82932: LD_INT 43
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 44
82941: PUSH
82942: LD_INT 46
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: PUSH
82949: LD_INT 45
82951: PUSH
82952: LD_INT 47
82954: PUSH
82955: EMPTY
82956: LIST
82957: LIST
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: LIST
82963: PUSH
82964: EMPTY
82965: LIST
82966: LIST
82967: LIST
82968: ST_TO_ADDR
// result := [ ] ;
82969: LD_ADDR_VAR 0 3
82973: PUSH
82974: EMPTY
82975: ST_TO_ADDR
// for i in turrets do
82976: LD_ADDR_VAR 0 4
82980: PUSH
82981: LD_VAR 0 1
82985: PUSH
82986: FOR_IN
82987: IFFALSE 83170
// begin nat := GetNation ( i ) ;
82989: LD_ADDR_VAR 0 7
82993: PUSH
82994: LD_VAR 0 4
82998: PPUSH
82999: CALL_OW 248
83003: ST_TO_ADDR
// weapon := 0 ;
83004: LD_ADDR_VAR 0 8
83008: PUSH
83009: LD_INT 0
83011: ST_TO_ADDR
// if not nat then
83012: LD_VAR 0 7
83016: NOT
83017: IFFALSE 83021
// continue ;
83019: GO 82986
// for j in list [ nat ] do
83021: LD_ADDR_VAR 0 5
83025: PUSH
83026: LD_VAR 0 10
83030: PUSH
83031: LD_VAR 0 7
83035: ARRAY
83036: PUSH
83037: FOR_IN
83038: IFFALSE 83079
// if GetBWeapon ( i ) = j [ 1 ] then
83040: LD_VAR 0 4
83044: PPUSH
83045: CALL_OW 269
83049: PUSH
83050: LD_VAR 0 5
83054: PUSH
83055: LD_INT 1
83057: ARRAY
83058: EQUAL
83059: IFFALSE 83077
// begin weapon := j [ 2 ] ;
83061: LD_ADDR_VAR 0 8
83065: PUSH
83066: LD_VAR 0 5
83070: PUSH
83071: LD_INT 2
83073: ARRAY
83074: ST_TO_ADDR
// break ;
83075: GO 83079
// end ;
83077: GO 83037
83079: POP
83080: POP
// if not weapon then
83081: LD_VAR 0 8
83085: NOT
83086: IFFALSE 83090
// continue ;
83088: GO 82986
// for k in factories do
83090: LD_ADDR_VAR 0 6
83094: PUSH
83095: LD_VAR 0 2
83099: PUSH
83100: FOR_IN
83101: IFFALSE 83166
// begin weapons := AvailableWeaponList ( k ) ;
83103: LD_ADDR_VAR 0 9
83107: PUSH
83108: LD_VAR 0 6
83112: PPUSH
83113: CALL_OW 478
83117: ST_TO_ADDR
// if not weapons then
83118: LD_VAR 0 9
83122: NOT
83123: IFFALSE 83127
// continue ;
83125: GO 83100
// if weapon in weapons then
83127: LD_VAR 0 8
83131: PUSH
83132: LD_VAR 0 9
83136: IN
83137: IFFALSE 83164
// begin result := [ i , weapon ] ;
83139: LD_ADDR_VAR 0 3
83143: PUSH
83144: LD_VAR 0 4
83148: PUSH
83149: LD_VAR 0 8
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: ST_TO_ADDR
// exit ;
83158: POP
83159: POP
83160: POP
83161: POP
83162: GO 83172
// end ; end ;
83164: GO 83100
83166: POP
83167: POP
// end ;
83168: GO 82986
83170: POP
83171: POP
// end ;
83172: LD_VAR 0 3
83176: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
83177: LD_INT 0
83179: PPUSH
// if not side or side > 8 then
83180: LD_VAR 0 3
83184: NOT
83185: PUSH
83186: LD_VAR 0 3
83190: PUSH
83191: LD_INT 8
83193: GREATER
83194: OR
83195: IFFALSE 83199
// exit ;
83197: GO 83258
// if not range then
83199: LD_VAR 0 4
83203: NOT
83204: IFFALSE 83215
// range := - 12 ;
83206: LD_ADDR_VAR 0 4
83210: PUSH
83211: LD_INT 12
83213: NEG
83214: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
83215: LD_VAR 0 1
83219: PPUSH
83220: LD_VAR 0 2
83224: PPUSH
83225: LD_VAR 0 3
83229: PPUSH
83230: LD_VAR 0 4
83234: PPUSH
83235: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
83239: LD_VAR 0 1
83243: PPUSH
83244: LD_VAR 0 2
83248: PPUSH
83249: LD_VAR 0 3
83253: PPUSH
83254: CALL_OW 331
// end ;
83258: LD_VAR 0 5
83262: RET
// export function Video ( mode ) ; begin
83263: LD_INT 0
83265: PPUSH
// ingame_video = mode ;
83266: LD_ADDR_OWVAR 52
83270: PUSH
83271: LD_VAR 0 1
83275: ST_TO_ADDR
// interface_hidden = mode ;
83276: LD_ADDR_OWVAR 54
83280: PUSH
83281: LD_VAR 0 1
83285: ST_TO_ADDR
// end ;
83286: LD_VAR 0 2
83290: RET
// export function Join ( array , element ) ; begin
83291: LD_INT 0
83293: PPUSH
// result := array ^ element ;
83294: LD_ADDR_VAR 0 3
83298: PUSH
83299: LD_VAR 0 1
83303: PUSH
83304: LD_VAR 0 2
83308: ADD
83309: ST_TO_ADDR
// end ;
83310: LD_VAR 0 3
83314: RET
// export function JoinUnion ( array , element ) ; begin
83315: LD_INT 0
83317: PPUSH
// result := array union element ;
83318: LD_ADDR_VAR 0 3
83322: PUSH
83323: LD_VAR 0 1
83327: PUSH
83328: LD_VAR 0 2
83332: UNION
83333: ST_TO_ADDR
// end ;
83334: LD_VAR 0 3
83338: RET
// export function GetBehemoths ( side ) ; begin
83339: LD_INT 0
83341: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
83342: LD_ADDR_VAR 0 2
83346: PUSH
83347: LD_INT 22
83349: PUSH
83350: LD_VAR 0 1
83354: PUSH
83355: EMPTY
83356: LIST
83357: LIST
83358: PUSH
83359: LD_INT 31
83361: PUSH
83362: LD_INT 25
83364: PUSH
83365: EMPTY
83366: LIST
83367: LIST
83368: PUSH
83369: EMPTY
83370: LIST
83371: LIST
83372: PPUSH
83373: CALL_OW 69
83377: ST_TO_ADDR
// end ;
83378: LD_VAR 0 2
83382: RET
// export function Shuffle ( array ) ; var i , index ; begin
83383: LD_INT 0
83385: PPUSH
83386: PPUSH
83387: PPUSH
// result := [ ] ;
83388: LD_ADDR_VAR 0 2
83392: PUSH
83393: EMPTY
83394: ST_TO_ADDR
// if not array then
83395: LD_VAR 0 1
83399: NOT
83400: IFFALSE 83404
// exit ;
83402: GO 83503
// Randomize ;
83404: CALL_OW 10
// for i = array downto 1 do
83408: LD_ADDR_VAR 0 3
83412: PUSH
83413: DOUBLE
83414: LD_VAR 0 1
83418: INC
83419: ST_TO_ADDR
83420: LD_INT 1
83422: PUSH
83423: FOR_DOWNTO
83424: IFFALSE 83501
// begin index := rand ( 1 , array ) ;
83426: LD_ADDR_VAR 0 4
83430: PUSH
83431: LD_INT 1
83433: PPUSH
83434: LD_VAR 0 1
83438: PPUSH
83439: CALL_OW 12
83443: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
83444: LD_ADDR_VAR 0 2
83448: PUSH
83449: LD_VAR 0 2
83453: PPUSH
83454: LD_VAR 0 2
83458: PUSH
83459: LD_INT 1
83461: PLUS
83462: PPUSH
83463: LD_VAR 0 1
83467: PUSH
83468: LD_VAR 0 4
83472: ARRAY
83473: PPUSH
83474: CALL_OW 2
83478: ST_TO_ADDR
// array := Delete ( array , index ) ;
83479: LD_ADDR_VAR 0 1
83483: PUSH
83484: LD_VAR 0 1
83488: PPUSH
83489: LD_VAR 0 4
83493: PPUSH
83494: CALL_OW 3
83498: ST_TO_ADDR
// end ;
83499: GO 83423
83501: POP
83502: POP
// end ;
83503: LD_VAR 0 2
83507: RET
// export function GetBaseMaterials ( base ) ; begin
83508: LD_INT 0
83510: PPUSH
// result := [ 0 , 0 , 0 ] ;
83511: LD_ADDR_VAR 0 2
83515: PUSH
83516: LD_INT 0
83518: PUSH
83519: LD_INT 0
83521: PUSH
83522: LD_INT 0
83524: PUSH
83525: EMPTY
83526: LIST
83527: LIST
83528: LIST
83529: ST_TO_ADDR
// if not base then
83530: LD_VAR 0 1
83534: NOT
83535: IFFALSE 83539
// exit ;
83537: GO 83588
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
83539: LD_ADDR_VAR 0 2
83543: PUSH
83544: LD_VAR 0 1
83548: PPUSH
83549: LD_INT 1
83551: PPUSH
83552: CALL_OW 275
83556: PUSH
83557: LD_VAR 0 1
83561: PPUSH
83562: LD_INT 2
83564: PPUSH
83565: CALL_OW 275
83569: PUSH
83570: LD_VAR 0 1
83574: PPUSH
83575: LD_INT 3
83577: PPUSH
83578: CALL_OW 275
83582: PUSH
83583: EMPTY
83584: LIST
83585: LIST
83586: LIST
83587: ST_TO_ADDR
// end ; end_of_file
83588: LD_VAR 0 2
83592: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
83593: GO 83595
83595: DISABLE
// begin ru_radar := 98 ;
83596: LD_ADDR_EXP 93
83600: PUSH
83601: LD_INT 98
83603: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
83604: LD_ADDR_EXP 94
83608: PUSH
83609: LD_INT 89
83611: ST_TO_ADDR
// us_hack := 99 ;
83612: LD_ADDR_EXP 95
83616: PUSH
83617: LD_INT 99
83619: ST_TO_ADDR
// us_artillery := 97 ;
83620: LD_ADDR_EXP 96
83624: PUSH
83625: LD_INT 97
83627: ST_TO_ADDR
// ar_bio_bomb := 91 ;
83628: LD_ADDR_EXP 97
83632: PUSH
83633: LD_INT 91
83635: ST_TO_ADDR
// tech_Artillery := 80 ;
83636: LD_ADDR_EXP 98
83640: PUSH
83641: LD_INT 80
83643: ST_TO_ADDR
// tech_RadMat := 81 ;
83644: LD_ADDR_EXP 99
83648: PUSH
83649: LD_INT 81
83651: ST_TO_ADDR
// tech_BasicTools := 82 ;
83652: LD_ADDR_EXP 100
83656: PUSH
83657: LD_INT 82
83659: ST_TO_ADDR
// tech_Cargo := 83 ;
83660: LD_ADDR_EXP 101
83664: PUSH
83665: LD_INT 83
83667: ST_TO_ADDR
// tech_Track := 84 ;
83668: LD_ADDR_EXP 102
83672: PUSH
83673: LD_INT 84
83675: ST_TO_ADDR
// tech_Crane := 85 ;
83676: LD_ADDR_EXP 103
83680: PUSH
83681: LD_INT 85
83683: ST_TO_ADDR
// tech_Bulldozer := 86 ;
83684: LD_ADDR_EXP 104
83688: PUSH
83689: LD_INT 86
83691: ST_TO_ADDR
// tech_Hovercraft := 87 ;
83692: LD_ADDR_EXP 105
83696: PUSH
83697: LD_INT 87
83699: ST_TO_ADDR
// end ; end_of_file end_of_file
83700: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
83701: GO 83703
83703: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
83704: LD_STRING initStreamRollete();
83706: PPUSH
83707: CALL_OW 559
// InitStreamMode ;
83711: CALL 83720 0 0
// DefineStreamItems ( ) ;
83715: CALL 84160 0 0
// end ;
83719: END
// function InitStreamMode ; begin
83720: LD_INT 0
83722: PPUSH
// streamModeActive := false ;
83723: LD_ADDR_EXP 106
83727: PUSH
83728: LD_INT 0
83730: ST_TO_ADDR
// normalCounter := 36 ;
83731: LD_ADDR_EXP 107
83735: PUSH
83736: LD_INT 36
83738: ST_TO_ADDR
// hardcoreCounter := 16 ;
83739: LD_ADDR_EXP 108
83743: PUSH
83744: LD_INT 16
83746: ST_TO_ADDR
// sRocket := false ;
83747: LD_ADDR_EXP 111
83751: PUSH
83752: LD_INT 0
83754: ST_TO_ADDR
// sSpeed := false ;
83755: LD_ADDR_EXP 110
83759: PUSH
83760: LD_INT 0
83762: ST_TO_ADDR
// sEngine := false ;
83763: LD_ADDR_EXP 112
83767: PUSH
83768: LD_INT 0
83770: ST_TO_ADDR
// sSpec := false ;
83771: LD_ADDR_EXP 109
83775: PUSH
83776: LD_INT 0
83778: ST_TO_ADDR
// sLevel := false ;
83779: LD_ADDR_EXP 113
83783: PUSH
83784: LD_INT 0
83786: ST_TO_ADDR
// sArmoury := false ;
83787: LD_ADDR_EXP 114
83791: PUSH
83792: LD_INT 0
83794: ST_TO_ADDR
// sRadar := false ;
83795: LD_ADDR_EXP 115
83799: PUSH
83800: LD_INT 0
83802: ST_TO_ADDR
// sBunker := false ;
83803: LD_ADDR_EXP 116
83807: PUSH
83808: LD_INT 0
83810: ST_TO_ADDR
// sHack := false ;
83811: LD_ADDR_EXP 117
83815: PUSH
83816: LD_INT 0
83818: ST_TO_ADDR
// sFire := false ;
83819: LD_ADDR_EXP 118
83823: PUSH
83824: LD_INT 0
83826: ST_TO_ADDR
// sRefresh := false ;
83827: LD_ADDR_EXP 119
83831: PUSH
83832: LD_INT 0
83834: ST_TO_ADDR
// sExp := false ;
83835: LD_ADDR_EXP 120
83839: PUSH
83840: LD_INT 0
83842: ST_TO_ADDR
// sDepot := false ;
83843: LD_ADDR_EXP 121
83847: PUSH
83848: LD_INT 0
83850: ST_TO_ADDR
// sFlag := false ;
83851: LD_ADDR_EXP 122
83855: PUSH
83856: LD_INT 0
83858: ST_TO_ADDR
// sKamikadze := false ;
83859: LD_ADDR_EXP 130
83863: PUSH
83864: LD_INT 0
83866: ST_TO_ADDR
// sTroll := false ;
83867: LD_ADDR_EXP 131
83871: PUSH
83872: LD_INT 0
83874: ST_TO_ADDR
// sSlow := false ;
83875: LD_ADDR_EXP 132
83879: PUSH
83880: LD_INT 0
83882: ST_TO_ADDR
// sLack := false ;
83883: LD_ADDR_EXP 133
83887: PUSH
83888: LD_INT 0
83890: ST_TO_ADDR
// sTank := false ;
83891: LD_ADDR_EXP 135
83895: PUSH
83896: LD_INT 0
83898: ST_TO_ADDR
// sRemote := false ;
83899: LD_ADDR_EXP 136
83903: PUSH
83904: LD_INT 0
83906: ST_TO_ADDR
// sPowell := false ;
83907: LD_ADDR_EXP 137
83911: PUSH
83912: LD_INT 0
83914: ST_TO_ADDR
// sTeleport := false ;
83915: LD_ADDR_EXP 140
83919: PUSH
83920: LD_INT 0
83922: ST_TO_ADDR
// sOilTower := false ;
83923: LD_ADDR_EXP 142
83927: PUSH
83928: LD_INT 0
83930: ST_TO_ADDR
// sShovel := false ;
83931: LD_ADDR_EXP 143
83935: PUSH
83936: LD_INT 0
83938: ST_TO_ADDR
// sSheik := false ;
83939: LD_ADDR_EXP 144
83943: PUSH
83944: LD_INT 0
83946: ST_TO_ADDR
// sEarthquake := false ;
83947: LD_ADDR_EXP 146
83951: PUSH
83952: LD_INT 0
83954: ST_TO_ADDR
// sAI := false ;
83955: LD_ADDR_EXP 147
83959: PUSH
83960: LD_INT 0
83962: ST_TO_ADDR
// sCargo := false ;
83963: LD_ADDR_EXP 150
83967: PUSH
83968: LD_INT 0
83970: ST_TO_ADDR
// sDLaser := false ;
83971: LD_ADDR_EXP 151
83975: PUSH
83976: LD_INT 0
83978: ST_TO_ADDR
// sExchange := false ;
83979: LD_ADDR_EXP 152
83983: PUSH
83984: LD_INT 0
83986: ST_TO_ADDR
// sFac := false ;
83987: LD_ADDR_EXP 153
83991: PUSH
83992: LD_INT 0
83994: ST_TO_ADDR
// sPower := false ;
83995: LD_ADDR_EXP 154
83999: PUSH
84000: LD_INT 0
84002: ST_TO_ADDR
// sRandom := false ;
84003: LD_ADDR_EXP 155
84007: PUSH
84008: LD_INT 0
84010: ST_TO_ADDR
// sShield := false ;
84011: LD_ADDR_EXP 156
84015: PUSH
84016: LD_INT 0
84018: ST_TO_ADDR
// sTime := false ;
84019: LD_ADDR_EXP 157
84023: PUSH
84024: LD_INT 0
84026: ST_TO_ADDR
// sTools := false ;
84027: LD_ADDR_EXP 158
84031: PUSH
84032: LD_INT 0
84034: ST_TO_ADDR
// sSold := false ;
84035: LD_ADDR_EXP 123
84039: PUSH
84040: LD_INT 0
84042: ST_TO_ADDR
// sDiff := false ;
84043: LD_ADDR_EXP 124
84047: PUSH
84048: LD_INT 0
84050: ST_TO_ADDR
// sFog := false ;
84051: LD_ADDR_EXP 127
84055: PUSH
84056: LD_INT 0
84058: ST_TO_ADDR
// sReset := false ;
84059: LD_ADDR_EXP 128
84063: PUSH
84064: LD_INT 0
84066: ST_TO_ADDR
// sSun := false ;
84067: LD_ADDR_EXP 129
84071: PUSH
84072: LD_INT 0
84074: ST_TO_ADDR
// sTiger := false ;
84075: LD_ADDR_EXP 125
84079: PUSH
84080: LD_INT 0
84082: ST_TO_ADDR
// sBomb := false ;
84083: LD_ADDR_EXP 126
84087: PUSH
84088: LD_INT 0
84090: ST_TO_ADDR
// sWound := false ;
84091: LD_ADDR_EXP 134
84095: PUSH
84096: LD_INT 0
84098: ST_TO_ADDR
// sBetray := false ;
84099: LD_ADDR_EXP 138
84103: PUSH
84104: LD_INT 0
84106: ST_TO_ADDR
// sContamin := false ;
84107: LD_ADDR_EXP 139
84111: PUSH
84112: LD_INT 0
84114: ST_TO_ADDR
// sOil := false ;
84115: LD_ADDR_EXP 141
84119: PUSH
84120: LD_INT 0
84122: ST_TO_ADDR
// sStu := false ;
84123: LD_ADDR_EXP 145
84127: PUSH
84128: LD_INT 0
84130: ST_TO_ADDR
// sBazooka := false ;
84131: LD_ADDR_EXP 148
84135: PUSH
84136: LD_INT 0
84138: ST_TO_ADDR
// sMortar := false ;
84139: LD_ADDR_EXP 149
84143: PUSH
84144: LD_INT 0
84146: ST_TO_ADDR
// sRanger := false ;
84147: LD_ADDR_EXP 159
84151: PUSH
84152: LD_INT 0
84154: ST_TO_ADDR
// end ;
84155: LD_VAR 0 1
84159: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
84160: LD_INT 0
84162: PPUSH
84163: PPUSH
84164: PPUSH
84165: PPUSH
84166: PPUSH
// result := [ ] ;
84167: LD_ADDR_VAR 0 1
84171: PUSH
84172: EMPTY
84173: ST_TO_ADDR
// if campaign_id = 1 then
84174: LD_OWVAR 69
84178: PUSH
84179: LD_INT 1
84181: EQUAL
84182: IFFALSE 87120
// begin case mission_number of 1 :
84184: LD_OWVAR 70
84188: PUSH
84189: LD_INT 1
84191: DOUBLE
84192: EQUAL
84193: IFTRUE 84197
84195: GO 84261
84197: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
84198: LD_ADDR_VAR 0 1
84202: PUSH
84203: LD_INT 2
84205: PUSH
84206: LD_INT 4
84208: PUSH
84209: LD_INT 11
84211: PUSH
84212: LD_INT 12
84214: PUSH
84215: LD_INT 15
84217: PUSH
84218: LD_INT 16
84220: PUSH
84221: LD_INT 22
84223: PUSH
84224: LD_INT 23
84226: PUSH
84227: LD_INT 26
84229: PUSH
84230: EMPTY
84231: LIST
84232: LIST
84233: LIST
84234: LIST
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: PUSH
84241: LD_INT 101
84243: PUSH
84244: LD_INT 102
84246: PUSH
84247: LD_INT 106
84249: PUSH
84250: EMPTY
84251: LIST
84252: LIST
84253: LIST
84254: PUSH
84255: EMPTY
84256: LIST
84257: LIST
84258: ST_TO_ADDR
84259: GO 87118
84261: LD_INT 2
84263: DOUBLE
84264: EQUAL
84265: IFTRUE 84269
84267: GO 84341
84269: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
84270: LD_ADDR_VAR 0 1
84274: PUSH
84275: LD_INT 2
84277: PUSH
84278: LD_INT 4
84280: PUSH
84281: LD_INT 11
84283: PUSH
84284: LD_INT 12
84286: PUSH
84287: LD_INT 15
84289: PUSH
84290: LD_INT 16
84292: PUSH
84293: LD_INT 22
84295: PUSH
84296: LD_INT 23
84298: PUSH
84299: LD_INT 26
84301: PUSH
84302: EMPTY
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: PUSH
84313: LD_INT 101
84315: PUSH
84316: LD_INT 102
84318: PUSH
84319: LD_INT 105
84321: PUSH
84322: LD_INT 106
84324: PUSH
84325: LD_INT 108
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: ST_TO_ADDR
84339: GO 87118
84341: LD_INT 3
84343: DOUBLE
84344: EQUAL
84345: IFTRUE 84349
84347: GO 84425
84349: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
84350: LD_ADDR_VAR 0 1
84354: PUSH
84355: LD_INT 2
84357: PUSH
84358: LD_INT 4
84360: PUSH
84361: LD_INT 5
84363: PUSH
84364: LD_INT 11
84366: PUSH
84367: LD_INT 12
84369: PUSH
84370: LD_INT 15
84372: PUSH
84373: LD_INT 16
84375: PUSH
84376: LD_INT 22
84378: PUSH
84379: LD_INT 26
84381: PUSH
84382: LD_INT 36
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: LIST
84389: LIST
84390: LIST
84391: LIST
84392: LIST
84393: LIST
84394: LIST
84395: LIST
84396: PUSH
84397: LD_INT 101
84399: PUSH
84400: LD_INT 102
84402: PUSH
84403: LD_INT 105
84405: PUSH
84406: LD_INT 106
84408: PUSH
84409: LD_INT 108
84411: PUSH
84412: EMPTY
84413: LIST
84414: LIST
84415: LIST
84416: LIST
84417: LIST
84418: PUSH
84419: EMPTY
84420: LIST
84421: LIST
84422: ST_TO_ADDR
84423: GO 87118
84425: LD_INT 4
84427: DOUBLE
84428: EQUAL
84429: IFTRUE 84433
84431: GO 84517
84433: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
84434: LD_ADDR_VAR 0 1
84438: PUSH
84439: LD_INT 2
84441: PUSH
84442: LD_INT 4
84444: PUSH
84445: LD_INT 5
84447: PUSH
84448: LD_INT 8
84450: PUSH
84451: LD_INT 11
84453: PUSH
84454: LD_INT 12
84456: PUSH
84457: LD_INT 15
84459: PUSH
84460: LD_INT 16
84462: PUSH
84463: LD_INT 22
84465: PUSH
84466: LD_INT 23
84468: PUSH
84469: LD_INT 26
84471: PUSH
84472: LD_INT 36
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: PUSH
84489: LD_INT 101
84491: PUSH
84492: LD_INT 102
84494: PUSH
84495: LD_INT 105
84497: PUSH
84498: LD_INT 106
84500: PUSH
84501: LD_INT 108
84503: PUSH
84504: EMPTY
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: ST_TO_ADDR
84515: GO 87118
84517: LD_INT 5
84519: DOUBLE
84520: EQUAL
84521: IFTRUE 84525
84523: GO 84625
84525: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
84526: LD_ADDR_VAR 0 1
84530: PUSH
84531: LD_INT 2
84533: PUSH
84534: LD_INT 4
84536: PUSH
84537: LD_INT 5
84539: PUSH
84540: LD_INT 6
84542: PUSH
84543: LD_INT 8
84545: PUSH
84546: LD_INT 11
84548: PUSH
84549: LD_INT 12
84551: PUSH
84552: LD_INT 15
84554: PUSH
84555: LD_INT 16
84557: PUSH
84558: LD_INT 22
84560: PUSH
84561: LD_INT 23
84563: PUSH
84564: LD_INT 25
84566: PUSH
84567: LD_INT 26
84569: PUSH
84570: LD_INT 36
84572: PUSH
84573: EMPTY
84574: LIST
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: PUSH
84589: LD_INT 101
84591: PUSH
84592: LD_INT 102
84594: PUSH
84595: LD_INT 105
84597: PUSH
84598: LD_INT 106
84600: PUSH
84601: LD_INT 108
84603: PUSH
84604: LD_INT 109
84606: PUSH
84607: LD_INT 112
84609: PUSH
84610: EMPTY
84611: LIST
84612: LIST
84613: LIST
84614: LIST
84615: LIST
84616: LIST
84617: LIST
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: ST_TO_ADDR
84623: GO 87118
84625: LD_INT 6
84627: DOUBLE
84628: EQUAL
84629: IFTRUE 84633
84631: GO 84753
84633: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
84634: LD_ADDR_VAR 0 1
84638: PUSH
84639: LD_INT 2
84641: PUSH
84642: LD_INT 4
84644: PUSH
84645: LD_INT 5
84647: PUSH
84648: LD_INT 6
84650: PUSH
84651: LD_INT 8
84653: PUSH
84654: LD_INT 11
84656: PUSH
84657: LD_INT 12
84659: PUSH
84660: LD_INT 15
84662: PUSH
84663: LD_INT 16
84665: PUSH
84666: LD_INT 20
84668: PUSH
84669: LD_INT 21
84671: PUSH
84672: LD_INT 22
84674: PUSH
84675: LD_INT 23
84677: PUSH
84678: LD_INT 25
84680: PUSH
84681: LD_INT 26
84683: PUSH
84684: LD_INT 30
84686: PUSH
84687: LD_INT 31
84689: PUSH
84690: LD_INT 32
84692: PUSH
84693: LD_INT 36
84695: PUSH
84696: EMPTY
84697: LIST
84698: LIST
84699: LIST
84700: LIST
84701: LIST
84702: LIST
84703: LIST
84704: LIST
84705: LIST
84706: LIST
84707: LIST
84708: LIST
84709: LIST
84710: LIST
84711: LIST
84712: LIST
84713: LIST
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 101
84719: PUSH
84720: LD_INT 102
84722: PUSH
84723: LD_INT 105
84725: PUSH
84726: LD_INT 106
84728: PUSH
84729: LD_INT 108
84731: PUSH
84732: LD_INT 109
84734: PUSH
84735: LD_INT 112
84737: PUSH
84738: EMPTY
84739: LIST
84740: LIST
84741: LIST
84742: LIST
84743: LIST
84744: LIST
84745: LIST
84746: PUSH
84747: EMPTY
84748: LIST
84749: LIST
84750: ST_TO_ADDR
84751: GO 87118
84753: LD_INT 7
84755: DOUBLE
84756: EQUAL
84757: IFTRUE 84761
84759: GO 84861
84761: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
84762: LD_ADDR_VAR 0 1
84766: PUSH
84767: LD_INT 2
84769: PUSH
84770: LD_INT 4
84772: PUSH
84773: LD_INT 5
84775: PUSH
84776: LD_INT 7
84778: PUSH
84779: LD_INT 11
84781: PUSH
84782: LD_INT 12
84784: PUSH
84785: LD_INT 15
84787: PUSH
84788: LD_INT 16
84790: PUSH
84791: LD_INT 20
84793: PUSH
84794: LD_INT 21
84796: PUSH
84797: LD_INT 22
84799: PUSH
84800: LD_INT 23
84802: PUSH
84803: LD_INT 25
84805: PUSH
84806: LD_INT 26
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: LIST
84818: LIST
84819: LIST
84820: LIST
84821: LIST
84822: LIST
84823: LIST
84824: PUSH
84825: LD_INT 101
84827: PUSH
84828: LD_INT 102
84830: PUSH
84831: LD_INT 103
84833: PUSH
84834: LD_INT 105
84836: PUSH
84837: LD_INT 106
84839: PUSH
84840: LD_INT 108
84842: PUSH
84843: LD_INT 112
84845: PUSH
84846: EMPTY
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: ST_TO_ADDR
84859: GO 87118
84861: LD_INT 8
84863: DOUBLE
84864: EQUAL
84865: IFTRUE 84869
84867: GO 84997
84869: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
84870: LD_ADDR_VAR 0 1
84874: PUSH
84875: LD_INT 2
84877: PUSH
84878: LD_INT 4
84880: PUSH
84881: LD_INT 5
84883: PUSH
84884: LD_INT 6
84886: PUSH
84887: LD_INT 7
84889: PUSH
84890: LD_INT 8
84892: PUSH
84893: LD_INT 11
84895: PUSH
84896: LD_INT 12
84898: PUSH
84899: LD_INT 15
84901: PUSH
84902: LD_INT 16
84904: PUSH
84905: LD_INT 20
84907: PUSH
84908: LD_INT 21
84910: PUSH
84911: LD_INT 22
84913: PUSH
84914: LD_INT 23
84916: PUSH
84917: LD_INT 25
84919: PUSH
84920: LD_INT 26
84922: PUSH
84923: LD_INT 30
84925: PUSH
84926: LD_INT 31
84928: PUSH
84929: LD_INT 32
84931: PUSH
84932: LD_INT 36
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: LIST
84946: LIST
84947: LIST
84948: LIST
84949: LIST
84950: LIST
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: PUSH
84957: LD_INT 101
84959: PUSH
84960: LD_INT 102
84962: PUSH
84963: LD_INT 103
84965: PUSH
84966: LD_INT 105
84968: PUSH
84969: LD_INT 106
84971: PUSH
84972: LD_INT 108
84974: PUSH
84975: LD_INT 109
84977: PUSH
84978: LD_INT 112
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: LIST
84985: LIST
84986: LIST
84987: LIST
84988: LIST
84989: LIST
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: ST_TO_ADDR
84995: GO 87118
84997: LD_INT 9
84999: DOUBLE
85000: EQUAL
85001: IFTRUE 85005
85003: GO 85141
85005: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
85006: LD_ADDR_VAR 0 1
85010: PUSH
85011: LD_INT 2
85013: PUSH
85014: LD_INT 4
85016: PUSH
85017: LD_INT 5
85019: PUSH
85020: LD_INT 6
85022: PUSH
85023: LD_INT 7
85025: PUSH
85026: LD_INT 8
85028: PUSH
85029: LD_INT 11
85031: PUSH
85032: LD_INT 12
85034: PUSH
85035: LD_INT 15
85037: PUSH
85038: LD_INT 16
85040: PUSH
85041: LD_INT 20
85043: PUSH
85044: LD_INT 21
85046: PUSH
85047: LD_INT 22
85049: PUSH
85050: LD_INT 23
85052: PUSH
85053: LD_INT 25
85055: PUSH
85056: LD_INT 26
85058: PUSH
85059: LD_INT 28
85061: PUSH
85062: LD_INT 30
85064: PUSH
85065: LD_INT 31
85067: PUSH
85068: LD_INT 32
85070: PUSH
85071: LD_INT 36
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: LIST
85082: LIST
85083: LIST
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: PUSH
85097: LD_INT 101
85099: PUSH
85100: LD_INT 102
85102: PUSH
85103: LD_INT 103
85105: PUSH
85106: LD_INT 105
85108: PUSH
85109: LD_INT 106
85111: PUSH
85112: LD_INT 108
85114: PUSH
85115: LD_INT 109
85117: PUSH
85118: LD_INT 112
85120: PUSH
85121: LD_INT 114
85123: PUSH
85124: EMPTY
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: LIST
85133: LIST
85134: PUSH
85135: EMPTY
85136: LIST
85137: LIST
85138: ST_TO_ADDR
85139: GO 87118
85141: LD_INT 10
85143: DOUBLE
85144: EQUAL
85145: IFTRUE 85149
85147: GO 85333
85149: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
85150: LD_ADDR_VAR 0 1
85154: PUSH
85155: LD_INT 2
85157: PUSH
85158: LD_INT 4
85160: PUSH
85161: LD_INT 5
85163: PUSH
85164: LD_INT 6
85166: PUSH
85167: LD_INT 7
85169: PUSH
85170: LD_INT 8
85172: PUSH
85173: LD_INT 9
85175: PUSH
85176: LD_INT 10
85178: PUSH
85179: LD_INT 11
85181: PUSH
85182: LD_INT 12
85184: PUSH
85185: LD_INT 13
85187: PUSH
85188: LD_INT 14
85190: PUSH
85191: LD_INT 15
85193: PUSH
85194: LD_INT 16
85196: PUSH
85197: LD_INT 17
85199: PUSH
85200: LD_INT 18
85202: PUSH
85203: LD_INT 19
85205: PUSH
85206: LD_INT 20
85208: PUSH
85209: LD_INT 21
85211: PUSH
85212: LD_INT 22
85214: PUSH
85215: LD_INT 23
85217: PUSH
85218: LD_INT 24
85220: PUSH
85221: LD_INT 25
85223: PUSH
85224: LD_INT 26
85226: PUSH
85227: LD_INT 28
85229: PUSH
85230: LD_INT 30
85232: PUSH
85233: LD_INT 31
85235: PUSH
85236: LD_INT 32
85238: PUSH
85239: LD_INT 36
85241: PUSH
85242: EMPTY
85243: LIST
85244: LIST
85245: LIST
85246: LIST
85247: LIST
85248: LIST
85249: LIST
85250: LIST
85251: LIST
85252: LIST
85253: LIST
85254: LIST
85255: LIST
85256: LIST
85257: LIST
85258: LIST
85259: LIST
85260: LIST
85261: LIST
85262: LIST
85263: LIST
85264: LIST
85265: LIST
85266: LIST
85267: LIST
85268: LIST
85269: LIST
85270: LIST
85271: LIST
85272: PUSH
85273: LD_INT 101
85275: PUSH
85276: LD_INT 102
85278: PUSH
85279: LD_INT 103
85281: PUSH
85282: LD_INT 104
85284: PUSH
85285: LD_INT 105
85287: PUSH
85288: LD_INT 106
85290: PUSH
85291: LD_INT 107
85293: PUSH
85294: LD_INT 108
85296: PUSH
85297: LD_INT 109
85299: PUSH
85300: LD_INT 110
85302: PUSH
85303: LD_INT 111
85305: PUSH
85306: LD_INT 112
85308: PUSH
85309: LD_INT 114
85311: PUSH
85312: EMPTY
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: ST_TO_ADDR
85331: GO 87118
85333: LD_INT 11
85335: DOUBLE
85336: EQUAL
85337: IFTRUE 85341
85339: GO 85533
85341: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
85342: LD_ADDR_VAR 0 1
85346: PUSH
85347: LD_INT 2
85349: PUSH
85350: LD_INT 3
85352: PUSH
85353: LD_INT 4
85355: PUSH
85356: LD_INT 5
85358: PUSH
85359: LD_INT 6
85361: PUSH
85362: LD_INT 7
85364: PUSH
85365: LD_INT 8
85367: PUSH
85368: LD_INT 9
85370: PUSH
85371: LD_INT 10
85373: PUSH
85374: LD_INT 11
85376: PUSH
85377: LD_INT 12
85379: PUSH
85380: LD_INT 13
85382: PUSH
85383: LD_INT 14
85385: PUSH
85386: LD_INT 15
85388: PUSH
85389: LD_INT 16
85391: PUSH
85392: LD_INT 17
85394: PUSH
85395: LD_INT 18
85397: PUSH
85398: LD_INT 19
85400: PUSH
85401: LD_INT 20
85403: PUSH
85404: LD_INT 21
85406: PUSH
85407: LD_INT 22
85409: PUSH
85410: LD_INT 23
85412: PUSH
85413: LD_INT 24
85415: PUSH
85416: LD_INT 25
85418: PUSH
85419: LD_INT 26
85421: PUSH
85422: LD_INT 28
85424: PUSH
85425: LD_INT 30
85427: PUSH
85428: LD_INT 31
85430: PUSH
85431: LD_INT 32
85433: PUSH
85434: LD_INT 34
85436: PUSH
85437: LD_INT 36
85439: PUSH
85440: EMPTY
85441: LIST
85442: LIST
85443: LIST
85444: LIST
85445: LIST
85446: LIST
85447: LIST
85448: LIST
85449: LIST
85450: LIST
85451: LIST
85452: LIST
85453: LIST
85454: LIST
85455: LIST
85456: LIST
85457: LIST
85458: LIST
85459: LIST
85460: LIST
85461: LIST
85462: LIST
85463: LIST
85464: LIST
85465: LIST
85466: LIST
85467: LIST
85468: LIST
85469: LIST
85470: LIST
85471: LIST
85472: PUSH
85473: LD_INT 101
85475: PUSH
85476: LD_INT 102
85478: PUSH
85479: LD_INT 103
85481: PUSH
85482: LD_INT 104
85484: PUSH
85485: LD_INT 105
85487: PUSH
85488: LD_INT 106
85490: PUSH
85491: LD_INT 107
85493: PUSH
85494: LD_INT 108
85496: PUSH
85497: LD_INT 109
85499: PUSH
85500: LD_INT 110
85502: PUSH
85503: LD_INT 111
85505: PUSH
85506: LD_INT 112
85508: PUSH
85509: LD_INT 114
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: LIST
85516: LIST
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: PUSH
85527: EMPTY
85528: LIST
85529: LIST
85530: ST_TO_ADDR
85531: GO 87118
85533: LD_INT 12
85535: DOUBLE
85536: EQUAL
85537: IFTRUE 85541
85539: GO 85749
85541: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
85542: LD_ADDR_VAR 0 1
85546: PUSH
85547: LD_INT 1
85549: PUSH
85550: LD_INT 2
85552: PUSH
85553: LD_INT 3
85555: PUSH
85556: LD_INT 4
85558: PUSH
85559: LD_INT 5
85561: PUSH
85562: LD_INT 6
85564: PUSH
85565: LD_INT 7
85567: PUSH
85568: LD_INT 8
85570: PUSH
85571: LD_INT 9
85573: PUSH
85574: LD_INT 10
85576: PUSH
85577: LD_INT 11
85579: PUSH
85580: LD_INT 12
85582: PUSH
85583: LD_INT 13
85585: PUSH
85586: LD_INT 14
85588: PUSH
85589: LD_INT 15
85591: PUSH
85592: LD_INT 16
85594: PUSH
85595: LD_INT 17
85597: PUSH
85598: LD_INT 18
85600: PUSH
85601: LD_INT 19
85603: PUSH
85604: LD_INT 20
85606: PUSH
85607: LD_INT 21
85609: PUSH
85610: LD_INT 22
85612: PUSH
85613: LD_INT 23
85615: PUSH
85616: LD_INT 24
85618: PUSH
85619: LD_INT 25
85621: PUSH
85622: LD_INT 26
85624: PUSH
85625: LD_INT 27
85627: PUSH
85628: LD_INT 28
85630: PUSH
85631: LD_INT 30
85633: PUSH
85634: LD_INT 31
85636: PUSH
85637: LD_INT 32
85639: PUSH
85640: LD_INT 33
85642: PUSH
85643: LD_INT 34
85645: PUSH
85646: LD_INT 36
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: LIST
85653: LIST
85654: LIST
85655: LIST
85656: LIST
85657: LIST
85658: LIST
85659: LIST
85660: LIST
85661: LIST
85662: LIST
85663: LIST
85664: LIST
85665: LIST
85666: LIST
85667: LIST
85668: LIST
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: PUSH
85685: LD_INT 101
85687: PUSH
85688: LD_INT 102
85690: PUSH
85691: LD_INT 103
85693: PUSH
85694: LD_INT 104
85696: PUSH
85697: LD_INT 105
85699: PUSH
85700: LD_INT 106
85702: PUSH
85703: LD_INT 107
85705: PUSH
85706: LD_INT 108
85708: PUSH
85709: LD_INT 109
85711: PUSH
85712: LD_INT 110
85714: PUSH
85715: LD_INT 111
85717: PUSH
85718: LD_INT 112
85720: PUSH
85721: LD_INT 113
85723: PUSH
85724: LD_INT 114
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: LIST
85731: LIST
85732: LIST
85733: LIST
85734: LIST
85735: LIST
85736: LIST
85737: LIST
85738: LIST
85739: LIST
85740: LIST
85741: LIST
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: ST_TO_ADDR
85747: GO 87118
85749: LD_INT 13
85751: DOUBLE
85752: EQUAL
85753: IFTRUE 85757
85755: GO 85953
85757: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
85758: LD_ADDR_VAR 0 1
85762: PUSH
85763: LD_INT 1
85765: PUSH
85766: LD_INT 2
85768: PUSH
85769: LD_INT 3
85771: PUSH
85772: LD_INT 4
85774: PUSH
85775: LD_INT 5
85777: PUSH
85778: LD_INT 8
85780: PUSH
85781: LD_INT 9
85783: PUSH
85784: LD_INT 10
85786: PUSH
85787: LD_INT 11
85789: PUSH
85790: LD_INT 12
85792: PUSH
85793: LD_INT 14
85795: PUSH
85796: LD_INT 15
85798: PUSH
85799: LD_INT 16
85801: PUSH
85802: LD_INT 17
85804: PUSH
85805: LD_INT 18
85807: PUSH
85808: LD_INT 19
85810: PUSH
85811: LD_INT 20
85813: PUSH
85814: LD_INT 21
85816: PUSH
85817: LD_INT 22
85819: PUSH
85820: LD_INT 23
85822: PUSH
85823: LD_INT 24
85825: PUSH
85826: LD_INT 25
85828: PUSH
85829: LD_INT 26
85831: PUSH
85832: LD_INT 27
85834: PUSH
85835: LD_INT 28
85837: PUSH
85838: LD_INT 30
85840: PUSH
85841: LD_INT 31
85843: PUSH
85844: LD_INT 32
85846: PUSH
85847: LD_INT 33
85849: PUSH
85850: LD_INT 34
85852: PUSH
85853: LD_INT 36
85855: PUSH
85856: EMPTY
85857: LIST
85858: LIST
85859: LIST
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: LIST
85866: LIST
85867: LIST
85868: LIST
85869: LIST
85870: LIST
85871: LIST
85872: LIST
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: PUSH
85889: LD_INT 101
85891: PUSH
85892: LD_INT 102
85894: PUSH
85895: LD_INT 103
85897: PUSH
85898: LD_INT 104
85900: PUSH
85901: LD_INT 105
85903: PUSH
85904: LD_INT 106
85906: PUSH
85907: LD_INT 107
85909: PUSH
85910: LD_INT 108
85912: PUSH
85913: LD_INT 109
85915: PUSH
85916: LD_INT 110
85918: PUSH
85919: LD_INT 111
85921: PUSH
85922: LD_INT 112
85924: PUSH
85925: LD_INT 113
85927: PUSH
85928: LD_INT 114
85930: PUSH
85931: EMPTY
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: LIST
85946: PUSH
85947: EMPTY
85948: LIST
85949: LIST
85950: ST_TO_ADDR
85951: GO 87118
85953: LD_INT 14
85955: DOUBLE
85956: EQUAL
85957: IFTRUE 85961
85959: GO 86173
85961: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
85962: LD_ADDR_VAR 0 1
85966: PUSH
85967: LD_INT 1
85969: PUSH
85970: LD_INT 2
85972: PUSH
85973: LD_INT 3
85975: PUSH
85976: LD_INT 4
85978: PUSH
85979: LD_INT 5
85981: PUSH
85982: LD_INT 6
85984: PUSH
85985: LD_INT 7
85987: PUSH
85988: LD_INT 8
85990: PUSH
85991: LD_INT 9
85993: PUSH
85994: LD_INT 10
85996: PUSH
85997: LD_INT 11
85999: PUSH
86000: LD_INT 12
86002: PUSH
86003: LD_INT 13
86005: PUSH
86006: LD_INT 14
86008: PUSH
86009: LD_INT 15
86011: PUSH
86012: LD_INT 16
86014: PUSH
86015: LD_INT 17
86017: PUSH
86018: LD_INT 18
86020: PUSH
86021: LD_INT 19
86023: PUSH
86024: LD_INT 20
86026: PUSH
86027: LD_INT 21
86029: PUSH
86030: LD_INT 22
86032: PUSH
86033: LD_INT 23
86035: PUSH
86036: LD_INT 24
86038: PUSH
86039: LD_INT 25
86041: PUSH
86042: LD_INT 26
86044: PUSH
86045: LD_INT 27
86047: PUSH
86048: LD_INT 28
86050: PUSH
86051: LD_INT 29
86053: PUSH
86054: LD_INT 30
86056: PUSH
86057: LD_INT 31
86059: PUSH
86060: LD_INT 32
86062: PUSH
86063: LD_INT 33
86065: PUSH
86066: LD_INT 34
86068: PUSH
86069: LD_INT 36
86071: PUSH
86072: EMPTY
86073: LIST
86074: LIST
86075: LIST
86076: LIST
86077: LIST
86078: LIST
86079: LIST
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: LIST
86086: LIST
86087: LIST
86088: LIST
86089: LIST
86090: LIST
86091: LIST
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: LIST
86097: LIST
86098: LIST
86099: LIST
86100: LIST
86101: LIST
86102: LIST
86103: LIST
86104: LIST
86105: LIST
86106: LIST
86107: LIST
86108: PUSH
86109: LD_INT 101
86111: PUSH
86112: LD_INT 102
86114: PUSH
86115: LD_INT 103
86117: PUSH
86118: LD_INT 104
86120: PUSH
86121: LD_INT 105
86123: PUSH
86124: LD_INT 106
86126: PUSH
86127: LD_INT 107
86129: PUSH
86130: LD_INT 108
86132: PUSH
86133: LD_INT 109
86135: PUSH
86136: LD_INT 110
86138: PUSH
86139: LD_INT 111
86141: PUSH
86142: LD_INT 112
86144: PUSH
86145: LD_INT 113
86147: PUSH
86148: LD_INT 114
86150: PUSH
86151: EMPTY
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: PUSH
86167: EMPTY
86168: LIST
86169: LIST
86170: ST_TO_ADDR
86171: GO 87118
86173: LD_INT 15
86175: DOUBLE
86176: EQUAL
86177: IFTRUE 86181
86179: GO 86393
86181: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
86182: LD_ADDR_VAR 0 1
86186: PUSH
86187: LD_INT 1
86189: PUSH
86190: LD_INT 2
86192: PUSH
86193: LD_INT 3
86195: PUSH
86196: LD_INT 4
86198: PUSH
86199: LD_INT 5
86201: PUSH
86202: LD_INT 6
86204: PUSH
86205: LD_INT 7
86207: PUSH
86208: LD_INT 8
86210: PUSH
86211: LD_INT 9
86213: PUSH
86214: LD_INT 10
86216: PUSH
86217: LD_INT 11
86219: PUSH
86220: LD_INT 12
86222: PUSH
86223: LD_INT 13
86225: PUSH
86226: LD_INT 14
86228: PUSH
86229: LD_INT 15
86231: PUSH
86232: LD_INT 16
86234: PUSH
86235: LD_INT 17
86237: PUSH
86238: LD_INT 18
86240: PUSH
86241: LD_INT 19
86243: PUSH
86244: LD_INT 20
86246: PUSH
86247: LD_INT 21
86249: PUSH
86250: LD_INT 22
86252: PUSH
86253: LD_INT 23
86255: PUSH
86256: LD_INT 24
86258: PUSH
86259: LD_INT 25
86261: PUSH
86262: LD_INT 26
86264: PUSH
86265: LD_INT 27
86267: PUSH
86268: LD_INT 28
86270: PUSH
86271: LD_INT 29
86273: PUSH
86274: LD_INT 30
86276: PUSH
86277: LD_INT 31
86279: PUSH
86280: LD_INT 32
86282: PUSH
86283: LD_INT 33
86285: PUSH
86286: LD_INT 34
86288: PUSH
86289: LD_INT 36
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: LIST
86296: LIST
86297: LIST
86298: LIST
86299: LIST
86300: LIST
86301: LIST
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: LIST
86326: LIST
86327: LIST
86328: PUSH
86329: LD_INT 101
86331: PUSH
86332: LD_INT 102
86334: PUSH
86335: LD_INT 103
86337: PUSH
86338: LD_INT 104
86340: PUSH
86341: LD_INT 105
86343: PUSH
86344: LD_INT 106
86346: PUSH
86347: LD_INT 107
86349: PUSH
86350: LD_INT 108
86352: PUSH
86353: LD_INT 109
86355: PUSH
86356: LD_INT 110
86358: PUSH
86359: LD_INT 111
86361: PUSH
86362: LD_INT 112
86364: PUSH
86365: LD_INT 113
86367: PUSH
86368: LD_INT 114
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: LIST
86375: LIST
86376: LIST
86377: LIST
86378: LIST
86379: LIST
86380: LIST
86381: LIST
86382: LIST
86383: LIST
86384: LIST
86385: LIST
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: ST_TO_ADDR
86391: GO 87118
86393: LD_INT 16
86395: DOUBLE
86396: EQUAL
86397: IFTRUE 86401
86399: GO 86525
86401: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
86402: LD_ADDR_VAR 0 1
86406: PUSH
86407: LD_INT 2
86409: PUSH
86410: LD_INT 4
86412: PUSH
86413: LD_INT 5
86415: PUSH
86416: LD_INT 7
86418: PUSH
86419: LD_INT 11
86421: PUSH
86422: LD_INT 12
86424: PUSH
86425: LD_INT 15
86427: PUSH
86428: LD_INT 16
86430: PUSH
86431: LD_INT 20
86433: PUSH
86434: LD_INT 21
86436: PUSH
86437: LD_INT 22
86439: PUSH
86440: LD_INT 23
86442: PUSH
86443: LD_INT 25
86445: PUSH
86446: LD_INT 26
86448: PUSH
86449: LD_INT 30
86451: PUSH
86452: LD_INT 31
86454: PUSH
86455: LD_INT 32
86457: PUSH
86458: LD_INT 33
86460: PUSH
86461: LD_INT 34
86463: PUSH
86464: EMPTY
86465: LIST
86466: LIST
86467: LIST
86468: LIST
86469: LIST
86470: LIST
86471: LIST
86472: LIST
86473: LIST
86474: LIST
86475: LIST
86476: LIST
86477: LIST
86478: LIST
86479: LIST
86480: LIST
86481: LIST
86482: LIST
86483: LIST
86484: PUSH
86485: LD_INT 101
86487: PUSH
86488: LD_INT 102
86490: PUSH
86491: LD_INT 103
86493: PUSH
86494: LD_INT 106
86496: PUSH
86497: LD_INT 108
86499: PUSH
86500: LD_INT 112
86502: PUSH
86503: LD_INT 113
86505: PUSH
86506: LD_INT 114
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: PUSH
86519: EMPTY
86520: LIST
86521: LIST
86522: ST_TO_ADDR
86523: GO 87118
86525: LD_INT 17
86527: DOUBLE
86528: EQUAL
86529: IFTRUE 86533
86531: GO 86745
86533: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
86534: LD_ADDR_VAR 0 1
86538: PUSH
86539: LD_INT 1
86541: PUSH
86542: LD_INT 2
86544: PUSH
86545: LD_INT 3
86547: PUSH
86548: LD_INT 4
86550: PUSH
86551: LD_INT 5
86553: PUSH
86554: LD_INT 6
86556: PUSH
86557: LD_INT 7
86559: PUSH
86560: LD_INT 8
86562: PUSH
86563: LD_INT 9
86565: PUSH
86566: LD_INT 10
86568: PUSH
86569: LD_INT 11
86571: PUSH
86572: LD_INT 12
86574: PUSH
86575: LD_INT 13
86577: PUSH
86578: LD_INT 14
86580: PUSH
86581: LD_INT 15
86583: PUSH
86584: LD_INT 16
86586: PUSH
86587: LD_INT 17
86589: PUSH
86590: LD_INT 18
86592: PUSH
86593: LD_INT 19
86595: PUSH
86596: LD_INT 20
86598: PUSH
86599: LD_INT 21
86601: PUSH
86602: LD_INT 22
86604: PUSH
86605: LD_INT 23
86607: PUSH
86608: LD_INT 24
86610: PUSH
86611: LD_INT 25
86613: PUSH
86614: LD_INT 26
86616: PUSH
86617: LD_INT 27
86619: PUSH
86620: LD_INT 28
86622: PUSH
86623: LD_INT 29
86625: PUSH
86626: LD_INT 30
86628: PUSH
86629: LD_INT 31
86631: PUSH
86632: LD_INT 32
86634: PUSH
86635: LD_INT 33
86637: PUSH
86638: LD_INT 34
86640: PUSH
86641: LD_INT 36
86643: PUSH
86644: EMPTY
86645: LIST
86646: LIST
86647: LIST
86648: LIST
86649: LIST
86650: LIST
86651: LIST
86652: LIST
86653: LIST
86654: LIST
86655: LIST
86656: LIST
86657: LIST
86658: LIST
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: LIST
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: LIST
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: PUSH
86681: LD_INT 101
86683: PUSH
86684: LD_INT 102
86686: PUSH
86687: LD_INT 103
86689: PUSH
86690: LD_INT 104
86692: PUSH
86693: LD_INT 105
86695: PUSH
86696: LD_INT 106
86698: PUSH
86699: LD_INT 107
86701: PUSH
86702: LD_INT 108
86704: PUSH
86705: LD_INT 109
86707: PUSH
86708: LD_INT 110
86710: PUSH
86711: LD_INT 111
86713: PUSH
86714: LD_INT 112
86716: PUSH
86717: LD_INT 113
86719: PUSH
86720: LD_INT 114
86722: PUSH
86723: EMPTY
86724: LIST
86725: LIST
86726: LIST
86727: LIST
86728: LIST
86729: LIST
86730: LIST
86731: LIST
86732: LIST
86733: LIST
86734: LIST
86735: LIST
86736: LIST
86737: LIST
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: ST_TO_ADDR
86743: GO 87118
86745: LD_INT 18
86747: DOUBLE
86748: EQUAL
86749: IFTRUE 86753
86751: GO 86889
86753: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
86754: LD_ADDR_VAR 0 1
86758: PUSH
86759: LD_INT 2
86761: PUSH
86762: LD_INT 4
86764: PUSH
86765: LD_INT 5
86767: PUSH
86768: LD_INT 7
86770: PUSH
86771: LD_INT 11
86773: PUSH
86774: LD_INT 12
86776: PUSH
86777: LD_INT 15
86779: PUSH
86780: LD_INT 16
86782: PUSH
86783: LD_INT 20
86785: PUSH
86786: LD_INT 21
86788: PUSH
86789: LD_INT 22
86791: PUSH
86792: LD_INT 23
86794: PUSH
86795: LD_INT 25
86797: PUSH
86798: LD_INT 26
86800: PUSH
86801: LD_INT 30
86803: PUSH
86804: LD_INT 31
86806: PUSH
86807: LD_INT 32
86809: PUSH
86810: LD_INT 33
86812: PUSH
86813: LD_INT 34
86815: PUSH
86816: LD_INT 35
86818: PUSH
86819: LD_INT 36
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: LIST
86826: LIST
86827: LIST
86828: LIST
86829: LIST
86830: LIST
86831: LIST
86832: LIST
86833: LIST
86834: LIST
86835: LIST
86836: LIST
86837: LIST
86838: LIST
86839: LIST
86840: LIST
86841: LIST
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 101
86847: PUSH
86848: LD_INT 102
86850: PUSH
86851: LD_INT 103
86853: PUSH
86854: LD_INT 106
86856: PUSH
86857: LD_INT 108
86859: PUSH
86860: LD_INT 112
86862: PUSH
86863: LD_INT 113
86865: PUSH
86866: LD_INT 114
86868: PUSH
86869: LD_INT 115
86871: PUSH
86872: EMPTY
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: PUSH
86883: EMPTY
86884: LIST
86885: LIST
86886: ST_TO_ADDR
86887: GO 87118
86889: LD_INT 19
86891: DOUBLE
86892: EQUAL
86893: IFTRUE 86897
86895: GO 87117
86897: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
86898: LD_ADDR_VAR 0 1
86902: PUSH
86903: LD_INT 1
86905: PUSH
86906: LD_INT 2
86908: PUSH
86909: LD_INT 3
86911: PUSH
86912: LD_INT 4
86914: PUSH
86915: LD_INT 5
86917: PUSH
86918: LD_INT 6
86920: PUSH
86921: LD_INT 7
86923: PUSH
86924: LD_INT 8
86926: PUSH
86927: LD_INT 9
86929: PUSH
86930: LD_INT 10
86932: PUSH
86933: LD_INT 11
86935: PUSH
86936: LD_INT 12
86938: PUSH
86939: LD_INT 13
86941: PUSH
86942: LD_INT 14
86944: PUSH
86945: LD_INT 15
86947: PUSH
86948: LD_INT 16
86950: PUSH
86951: LD_INT 17
86953: PUSH
86954: LD_INT 18
86956: PUSH
86957: LD_INT 19
86959: PUSH
86960: LD_INT 20
86962: PUSH
86963: LD_INT 21
86965: PUSH
86966: LD_INT 22
86968: PUSH
86969: LD_INT 23
86971: PUSH
86972: LD_INT 24
86974: PUSH
86975: LD_INT 25
86977: PUSH
86978: LD_INT 26
86980: PUSH
86981: LD_INT 27
86983: PUSH
86984: LD_INT 28
86986: PUSH
86987: LD_INT 29
86989: PUSH
86990: LD_INT 30
86992: PUSH
86993: LD_INT 31
86995: PUSH
86996: LD_INT 32
86998: PUSH
86999: LD_INT 33
87001: PUSH
87002: LD_INT 34
87004: PUSH
87005: LD_INT 35
87007: PUSH
87008: LD_INT 36
87010: PUSH
87011: EMPTY
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: LIST
87027: LIST
87028: LIST
87029: LIST
87030: LIST
87031: LIST
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: PUSH
87049: LD_INT 101
87051: PUSH
87052: LD_INT 102
87054: PUSH
87055: LD_INT 103
87057: PUSH
87058: LD_INT 104
87060: PUSH
87061: LD_INT 105
87063: PUSH
87064: LD_INT 106
87066: PUSH
87067: LD_INT 107
87069: PUSH
87070: LD_INT 108
87072: PUSH
87073: LD_INT 109
87075: PUSH
87076: LD_INT 110
87078: PUSH
87079: LD_INT 111
87081: PUSH
87082: LD_INT 112
87084: PUSH
87085: LD_INT 113
87087: PUSH
87088: LD_INT 114
87090: PUSH
87091: LD_INT 115
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: LIST
87098: LIST
87099: LIST
87100: LIST
87101: LIST
87102: LIST
87103: LIST
87104: LIST
87105: LIST
87106: LIST
87107: LIST
87108: LIST
87109: LIST
87110: PUSH
87111: EMPTY
87112: LIST
87113: LIST
87114: ST_TO_ADDR
87115: GO 87118
87117: POP
// end else
87118: GO 87337
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
87120: LD_ADDR_VAR 0 1
87124: PUSH
87125: LD_INT 1
87127: PUSH
87128: LD_INT 2
87130: PUSH
87131: LD_INT 3
87133: PUSH
87134: LD_INT 4
87136: PUSH
87137: LD_INT 5
87139: PUSH
87140: LD_INT 6
87142: PUSH
87143: LD_INT 7
87145: PUSH
87146: LD_INT 8
87148: PUSH
87149: LD_INT 9
87151: PUSH
87152: LD_INT 10
87154: PUSH
87155: LD_INT 11
87157: PUSH
87158: LD_INT 12
87160: PUSH
87161: LD_INT 13
87163: PUSH
87164: LD_INT 14
87166: PUSH
87167: LD_INT 15
87169: PUSH
87170: LD_INT 16
87172: PUSH
87173: LD_INT 17
87175: PUSH
87176: LD_INT 18
87178: PUSH
87179: LD_INT 19
87181: PUSH
87182: LD_INT 20
87184: PUSH
87185: LD_INT 21
87187: PUSH
87188: LD_INT 22
87190: PUSH
87191: LD_INT 23
87193: PUSH
87194: LD_INT 24
87196: PUSH
87197: LD_INT 25
87199: PUSH
87200: LD_INT 26
87202: PUSH
87203: LD_INT 27
87205: PUSH
87206: LD_INT 28
87208: PUSH
87209: LD_INT 29
87211: PUSH
87212: LD_INT 30
87214: PUSH
87215: LD_INT 31
87217: PUSH
87218: LD_INT 32
87220: PUSH
87221: LD_INT 33
87223: PUSH
87224: LD_INT 34
87226: PUSH
87227: LD_INT 35
87229: PUSH
87230: LD_INT 36
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: LIST
87265: LIST
87266: LIST
87267: LIST
87268: LIST
87269: LIST
87270: PUSH
87271: LD_INT 101
87273: PUSH
87274: LD_INT 102
87276: PUSH
87277: LD_INT 103
87279: PUSH
87280: LD_INT 104
87282: PUSH
87283: LD_INT 105
87285: PUSH
87286: LD_INT 106
87288: PUSH
87289: LD_INT 107
87291: PUSH
87292: LD_INT 108
87294: PUSH
87295: LD_INT 109
87297: PUSH
87298: LD_INT 110
87300: PUSH
87301: LD_INT 111
87303: PUSH
87304: LD_INT 112
87306: PUSH
87307: LD_INT 113
87309: PUSH
87310: LD_INT 114
87312: PUSH
87313: LD_INT 115
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: LIST
87320: LIST
87321: LIST
87322: LIST
87323: LIST
87324: LIST
87325: LIST
87326: LIST
87327: LIST
87328: LIST
87329: LIST
87330: LIST
87331: LIST
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: ST_TO_ADDR
// if result then
87337: LD_VAR 0 1
87341: IFFALSE 87630
// begin normal :=  ;
87343: LD_ADDR_VAR 0 3
87347: PUSH
87348: LD_STRING 
87350: ST_TO_ADDR
// hardcore :=  ;
87351: LD_ADDR_VAR 0 4
87355: PUSH
87356: LD_STRING 
87358: ST_TO_ADDR
// for i = 1 to normalCounter do
87359: LD_ADDR_VAR 0 5
87363: PUSH
87364: DOUBLE
87365: LD_INT 1
87367: DEC
87368: ST_TO_ADDR
87369: LD_EXP 107
87373: PUSH
87374: FOR_TO
87375: IFFALSE 87476
// begin tmp := 0 ;
87377: LD_ADDR_VAR 0 2
87381: PUSH
87382: LD_STRING 0
87384: ST_TO_ADDR
// if result [ 1 ] then
87385: LD_VAR 0 1
87389: PUSH
87390: LD_INT 1
87392: ARRAY
87393: IFFALSE 87458
// if result [ 1 ] [ 1 ] = i then
87395: LD_VAR 0 1
87399: PUSH
87400: LD_INT 1
87402: ARRAY
87403: PUSH
87404: LD_INT 1
87406: ARRAY
87407: PUSH
87408: LD_VAR 0 5
87412: EQUAL
87413: IFFALSE 87458
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
87415: LD_ADDR_VAR 0 1
87419: PUSH
87420: LD_VAR 0 1
87424: PPUSH
87425: LD_INT 1
87427: PPUSH
87428: LD_VAR 0 1
87432: PUSH
87433: LD_INT 1
87435: ARRAY
87436: PPUSH
87437: LD_INT 1
87439: PPUSH
87440: CALL_OW 3
87444: PPUSH
87445: CALL_OW 1
87449: ST_TO_ADDR
// tmp := 1 ;
87450: LD_ADDR_VAR 0 2
87454: PUSH
87455: LD_STRING 1
87457: ST_TO_ADDR
// end ; normal := normal & tmp ;
87458: LD_ADDR_VAR 0 3
87462: PUSH
87463: LD_VAR 0 3
87467: PUSH
87468: LD_VAR 0 2
87472: STR
87473: ST_TO_ADDR
// end ;
87474: GO 87374
87476: POP
87477: POP
// for i = 1 to hardcoreCounter do
87478: LD_ADDR_VAR 0 5
87482: PUSH
87483: DOUBLE
87484: LD_INT 1
87486: DEC
87487: ST_TO_ADDR
87488: LD_EXP 108
87492: PUSH
87493: FOR_TO
87494: IFFALSE 87599
// begin tmp := 0 ;
87496: LD_ADDR_VAR 0 2
87500: PUSH
87501: LD_STRING 0
87503: ST_TO_ADDR
// if result [ 2 ] then
87504: LD_VAR 0 1
87508: PUSH
87509: LD_INT 2
87511: ARRAY
87512: IFFALSE 87581
// if result [ 2 ] [ 1 ] = 100 + i then
87514: LD_VAR 0 1
87518: PUSH
87519: LD_INT 2
87521: ARRAY
87522: PUSH
87523: LD_INT 1
87525: ARRAY
87526: PUSH
87527: LD_INT 100
87529: PUSH
87530: LD_VAR 0 5
87534: PLUS
87535: EQUAL
87536: IFFALSE 87581
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
87538: LD_ADDR_VAR 0 1
87542: PUSH
87543: LD_VAR 0 1
87547: PPUSH
87548: LD_INT 2
87550: PPUSH
87551: LD_VAR 0 1
87555: PUSH
87556: LD_INT 2
87558: ARRAY
87559: PPUSH
87560: LD_INT 1
87562: PPUSH
87563: CALL_OW 3
87567: PPUSH
87568: CALL_OW 1
87572: ST_TO_ADDR
// tmp := 1 ;
87573: LD_ADDR_VAR 0 2
87577: PUSH
87578: LD_STRING 1
87580: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
87581: LD_ADDR_VAR 0 4
87585: PUSH
87586: LD_VAR 0 4
87590: PUSH
87591: LD_VAR 0 2
87595: STR
87596: ST_TO_ADDR
// end ;
87597: GO 87493
87599: POP
87600: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
87601: LD_STRING getStreamItemsFromMission("
87603: PUSH
87604: LD_VAR 0 3
87608: STR
87609: PUSH
87610: LD_STRING ","
87612: STR
87613: PUSH
87614: LD_VAR 0 4
87618: STR
87619: PUSH
87620: LD_STRING ")
87622: STR
87623: PPUSH
87624: CALL_OW 559
// end else
87628: GO 87637
// ToLua ( getStreamItemsFromMission("","") ) ;
87630: LD_STRING getStreamItemsFromMission("","")
87632: PPUSH
87633: CALL_OW 559
// end ;
87637: LD_VAR 0 1
87641: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
87642: LD_VAR 0 2
87646: PUSH
87647: LD_INT 100
87649: EQUAL
87650: IFFALSE 88599
// begin if not StreamModeActive then
87652: LD_EXP 106
87656: NOT
87657: IFFALSE 87667
// StreamModeActive := true ;
87659: LD_ADDR_EXP 106
87663: PUSH
87664: LD_INT 1
87666: ST_TO_ADDR
// if p3 = 0 then
87667: LD_VAR 0 3
87671: PUSH
87672: LD_INT 0
87674: EQUAL
87675: IFFALSE 87681
// InitStreamMode ;
87677: CALL 83720 0 0
// if p3 = 1 then
87681: LD_VAR 0 3
87685: PUSH
87686: LD_INT 1
87688: EQUAL
87689: IFFALSE 87699
// sRocket := true ;
87691: LD_ADDR_EXP 111
87695: PUSH
87696: LD_INT 1
87698: ST_TO_ADDR
// if p3 = 2 then
87699: LD_VAR 0 3
87703: PUSH
87704: LD_INT 2
87706: EQUAL
87707: IFFALSE 87717
// sSpeed := true ;
87709: LD_ADDR_EXP 110
87713: PUSH
87714: LD_INT 1
87716: ST_TO_ADDR
// if p3 = 3 then
87717: LD_VAR 0 3
87721: PUSH
87722: LD_INT 3
87724: EQUAL
87725: IFFALSE 87735
// sEngine := true ;
87727: LD_ADDR_EXP 112
87731: PUSH
87732: LD_INT 1
87734: ST_TO_ADDR
// if p3 = 4 then
87735: LD_VAR 0 3
87739: PUSH
87740: LD_INT 4
87742: EQUAL
87743: IFFALSE 87753
// sSpec := true ;
87745: LD_ADDR_EXP 109
87749: PUSH
87750: LD_INT 1
87752: ST_TO_ADDR
// if p3 = 5 then
87753: LD_VAR 0 3
87757: PUSH
87758: LD_INT 5
87760: EQUAL
87761: IFFALSE 87771
// sLevel := true ;
87763: LD_ADDR_EXP 113
87767: PUSH
87768: LD_INT 1
87770: ST_TO_ADDR
// if p3 = 6 then
87771: LD_VAR 0 3
87775: PUSH
87776: LD_INT 6
87778: EQUAL
87779: IFFALSE 87789
// sArmoury := true ;
87781: LD_ADDR_EXP 114
87785: PUSH
87786: LD_INT 1
87788: ST_TO_ADDR
// if p3 = 7 then
87789: LD_VAR 0 3
87793: PUSH
87794: LD_INT 7
87796: EQUAL
87797: IFFALSE 87807
// sRadar := true ;
87799: LD_ADDR_EXP 115
87803: PUSH
87804: LD_INT 1
87806: ST_TO_ADDR
// if p3 = 8 then
87807: LD_VAR 0 3
87811: PUSH
87812: LD_INT 8
87814: EQUAL
87815: IFFALSE 87825
// sBunker := true ;
87817: LD_ADDR_EXP 116
87821: PUSH
87822: LD_INT 1
87824: ST_TO_ADDR
// if p3 = 9 then
87825: LD_VAR 0 3
87829: PUSH
87830: LD_INT 9
87832: EQUAL
87833: IFFALSE 87843
// sHack := true ;
87835: LD_ADDR_EXP 117
87839: PUSH
87840: LD_INT 1
87842: ST_TO_ADDR
// if p3 = 10 then
87843: LD_VAR 0 3
87847: PUSH
87848: LD_INT 10
87850: EQUAL
87851: IFFALSE 87861
// sFire := true ;
87853: LD_ADDR_EXP 118
87857: PUSH
87858: LD_INT 1
87860: ST_TO_ADDR
// if p3 = 11 then
87861: LD_VAR 0 3
87865: PUSH
87866: LD_INT 11
87868: EQUAL
87869: IFFALSE 87879
// sRefresh := true ;
87871: LD_ADDR_EXP 119
87875: PUSH
87876: LD_INT 1
87878: ST_TO_ADDR
// if p3 = 12 then
87879: LD_VAR 0 3
87883: PUSH
87884: LD_INT 12
87886: EQUAL
87887: IFFALSE 87897
// sExp := true ;
87889: LD_ADDR_EXP 120
87893: PUSH
87894: LD_INT 1
87896: ST_TO_ADDR
// if p3 = 13 then
87897: LD_VAR 0 3
87901: PUSH
87902: LD_INT 13
87904: EQUAL
87905: IFFALSE 87915
// sDepot := true ;
87907: LD_ADDR_EXP 121
87911: PUSH
87912: LD_INT 1
87914: ST_TO_ADDR
// if p3 = 14 then
87915: LD_VAR 0 3
87919: PUSH
87920: LD_INT 14
87922: EQUAL
87923: IFFALSE 87933
// sFlag := true ;
87925: LD_ADDR_EXP 122
87929: PUSH
87930: LD_INT 1
87932: ST_TO_ADDR
// if p3 = 15 then
87933: LD_VAR 0 3
87937: PUSH
87938: LD_INT 15
87940: EQUAL
87941: IFFALSE 87951
// sKamikadze := true ;
87943: LD_ADDR_EXP 130
87947: PUSH
87948: LD_INT 1
87950: ST_TO_ADDR
// if p3 = 16 then
87951: LD_VAR 0 3
87955: PUSH
87956: LD_INT 16
87958: EQUAL
87959: IFFALSE 87969
// sTroll := true ;
87961: LD_ADDR_EXP 131
87965: PUSH
87966: LD_INT 1
87968: ST_TO_ADDR
// if p3 = 17 then
87969: LD_VAR 0 3
87973: PUSH
87974: LD_INT 17
87976: EQUAL
87977: IFFALSE 87987
// sSlow := true ;
87979: LD_ADDR_EXP 132
87983: PUSH
87984: LD_INT 1
87986: ST_TO_ADDR
// if p3 = 18 then
87987: LD_VAR 0 3
87991: PUSH
87992: LD_INT 18
87994: EQUAL
87995: IFFALSE 88005
// sLack := true ;
87997: LD_ADDR_EXP 133
88001: PUSH
88002: LD_INT 1
88004: ST_TO_ADDR
// if p3 = 19 then
88005: LD_VAR 0 3
88009: PUSH
88010: LD_INT 19
88012: EQUAL
88013: IFFALSE 88023
// sTank := true ;
88015: LD_ADDR_EXP 135
88019: PUSH
88020: LD_INT 1
88022: ST_TO_ADDR
// if p3 = 20 then
88023: LD_VAR 0 3
88027: PUSH
88028: LD_INT 20
88030: EQUAL
88031: IFFALSE 88041
// sRemote := true ;
88033: LD_ADDR_EXP 136
88037: PUSH
88038: LD_INT 1
88040: ST_TO_ADDR
// if p3 = 21 then
88041: LD_VAR 0 3
88045: PUSH
88046: LD_INT 21
88048: EQUAL
88049: IFFALSE 88059
// sPowell := true ;
88051: LD_ADDR_EXP 137
88055: PUSH
88056: LD_INT 1
88058: ST_TO_ADDR
// if p3 = 22 then
88059: LD_VAR 0 3
88063: PUSH
88064: LD_INT 22
88066: EQUAL
88067: IFFALSE 88077
// sTeleport := true ;
88069: LD_ADDR_EXP 140
88073: PUSH
88074: LD_INT 1
88076: ST_TO_ADDR
// if p3 = 23 then
88077: LD_VAR 0 3
88081: PUSH
88082: LD_INT 23
88084: EQUAL
88085: IFFALSE 88095
// sOilTower := true ;
88087: LD_ADDR_EXP 142
88091: PUSH
88092: LD_INT 1
88094: ST_TO_ADDR
// if p3 = 24 then
88095: LD_VAR 0 3
88099: PUSH
88100: LD_INT 24
88102: EQUAL
88103: IFFALSE 88113
// sShovel := true ;
88105: LD_ADDR_EXP 143
88109: PUSH
88110: LD_INT 1
88112: ST_TO_ADDR
// if p3 = 25 then
88113: LD_VAR 0 3
88117: PUSH
88118: LD_INT 25
88120: EQUAL
88121: IFFALSE 88131
// sSheik := true ;
88123: LD_ADDR_EXP 144
88127: PUSH
88128: LD_INT 1
88130: ST_TO_ADDR
// if p3 = 26 then
88131: LD_VAR 0 3
88135: PUSH
88136: LD_INT 26
88138: EQUAL
88139: IFFALSE 88149
// sEarthquake := true ;
88141: LD_ADDR_EXP 146
88145: PUSH
88146: LD_INT 1
88148: ST_TO_ADDR
// if p3 = 27 then
88149: LD_VAR 0 3
88153: PUSH
88154: LD_INT 27
88156: EQUAL
88157: IFFALSE 88167
// sAI := true ;
88159: LD_ADDR_EXP 147
88163: PUSH
88164: LD_INT 1
88166: ST_TO_ADDR
// if p3 = 28 then
88167: LD_VAR 0 3
88171: PUSH
88172: LD_INT 28
88174: EQUAL
88175: IFFALSE 88185
// sCargo := true ;
88177: LD_ADDR_EXP 150
88181: PUSH
88182: LD_INT 1
88184: ST_TO_ADDR
// if p3 = 29 then
88185: LD_VAR 0 3
88189: PUSH
88190: LD_INT 29
88192: EQUAL
88193: IFFALSE 88203
// sDLaser := true ;
88195: LD_ADDR_EXP 151
88199: PUSH
88200: LD_INT 1
88202: ST_TO_ADDR
// if p3 = 30 then
88203: LD_VAR 0 3
88207: PUSH
88208: LD_INT 30
88210: EQUAL
88211: IFFALSE 88221
// sExchange := true ;
88213: LD_ADDR_EXP 152
88217: PUSH
88218: LD_INT 1
88220: ST_TO_ADDR
// if p3 = 31 then
88221: LD_VAR 0 3
88225: PUSH
88226: LD_INT 31
88228: EQUAL
88229: IFFALSE 88239
// sFac := true ;
88231: LD_ADDR_EXP 153
88235: PUSH
88236: LD_INT 1
88238: ST_TO_ADDR
// if p3 = 32 then
88239: LD_VAR 0 3
88243: PUSH
88244: LD_INT 32
88246: EQUAL
88247: IFFALSE 88257
// sPower := true ;
88249: LD_ADDR_EXP 154
88253: PUSH
88254: LD_INT 1
88256: ST_TO_ADDR
// if p3 = 33 then
88257: LD_VAR 0 3
88261: PUSH
88262: LD_INT 33
88264: EQUAL
88265: IFFALSE 88275
// sRandom := true ;
88267: LD_ADDR_EXP 155
88271: PUSH
88272: LD_INT 1
88274: ST_TO_ADDR
// if p3 = 34 then
88275: LD_VAR 0 3
88279: PUSH
88280: LD_INT 34
88282: EQUAL
88283: IFFALSE 88293
// sShield := true ;
88285: LD_ADDR_EXP 156
88289: PUSH
88290: LD_INT 1
88292: ST_TO_ADDR
// if p3 = 35 then
88293: LD_VAR 0 3
88297: PUSH
88298: LD_INT 35
88300: EQUAL
88301: IFFALSE 88311
// sTime := true ;
88303: LD_ADDR_EXP 157
88307: PUSH
88308: LD_INT 1
88310: ST_TO_ADDR
// if p3 = 36 then
88311: LD_VAR 0 3
88315: PUSH
88316: LD_INT 36
88318: EQUAL
88319: IFFALSE 88329
// sTools := true ;
88321: LD_ADDR_EXP 158
88325: PUSH
88326: LD_INT 1
88328: ST_TO_ADDR
// if p3 = 101 then
88329: LD_VAR 0 3
88333: PUSH
88334: LD_INT 101
88336: EQUAL
88337: IFFALSE 88347
// sSold := true ;
88339: LD_ADDR_EXP 123
88343: PUSH
88344: LD_INT 1
88346: ST_TO_ADDR
// if p3 = 102 then
88347: LD_VAR 0 3
88351: PUSH
88352: LD_INT 102
88354: EQUAL
88355: IFFALSE 88365
// sDiff := true ;
88357: LD_ADDR_EXP 124
88361: PUSH
88362: LD_INT 1
88364: ST_TO_ADDR
// if p3 = 103 then
88365: LD_VAR 0 3
88369: PUSH
88370: LD_INT 103
88372: EQUAL
88373: IFFALSE 88383
// sFog := true ;
88375: LD_ADDR_EXP 127
88379: PUSH
88380: LD_INT 1
88382: ST_TO_ADDR
// if p3 = 104 then
88383: LD_VAR 0 3
88387: PUSH
88388: LD_INT 104
88390: EQUAL
88391: IFFALSE 88401
// sReset := true ;
88393: LD_ADDR_EXP 128
88397: PUSH
88398: LD_INT 1
88400: ST_TO_ADDR
// if p3 = 105 then
88401: LD_VAR 0 3
88405: PUSH
88406: LD_INT 105
88408: EQUAL
88409: IFFALSE 88419
// sSun := true ;
88411: LD_ADDR_EXP 129
88415: PUSH
88416: LD_INT 1
88418: ST_TO_ADDR
// if p3 = 106 then
88419: LD_VAR 0 3
88423: PUSH
88424: LD_INT 106
88426: EQUAL
88427: IFFALSE 88437
// sTiger := true ;
88429: LD_ADDR_EXP 125
88433: PUSH
88434: LD_INT 1
88436: ST_TO_ADDR
// if p3 = 107 then
88437: LD_VAR 0 3
88441: PUSH
88442: LD_INT 107
88444: EQUAL
88445: IFFALSE 88455
// sBomb := true ;
88447: LD_ADDR_EXP 126
88451: PUSH
88452: LD_INT 1
88454: ST_TO_ADDR
// if p3 = 108 then
88455: LD_VAR 0 3
88459: PUSH
88460: LD_INT 108
88462: EQUAL
88463: IFFALSE 88473
// sWound := true ;
88465: LD_ADDR_EXP 134
88469: PUSH
88470: LD_INT 1
88472: ST_TO_ADDR
// if p3 = 109 then
88473: LD_VAR 0 3
88477: PUSH
88478: LD_INT 109
88480: EQUAL
88481: IFFALSE 88491
// sBetray := true ;
88483: LD_ADDR_EXP 138
88487: PUSH
88488: LD_INT 1
88490: ST_TO_ADDR
// if p3 = 110 then
88491: LD_VAR 0 3
88495: PUSH
88496: LD_INT 110
88498: EQUAL
88499: IFFALSE 88509
// sContamin := true ;
88501: LD_ADDR_EXP 139
88505: PUSH
88506: LD_INT 1
88508: ST_TO_ADDR
// if p3 = 111 then
88509: LD_VAR 0 3
88513: PUSH
88514: LD_INT 111
88516: EQUAL
88517: IFFALSE 88527
// sOil := true ;
88519: LD_ADDR_EXP 141
88523: PUSH
88524: LD_INT 1
88526: ST_TO_ADDR
// if p3 = 112 then
88527: LD_VAR 0 3
88531: PUSH
88532: LD_INT 112
88534: EQUAL
88535: IFFALSE 88545
// sStu := true ;
88537: LD_ADDR_EXP 145
88541: PUSH
88542: LD_INT 1
88544: ST_TO_ADDR
// if p3 = 113 then
88545: LD_VAR 0 3
88549: PUSH
88550: LD_INT 113
88552: EQUAL
88553: IFFALSE 88563
// sBazooka := true ;
88555: LD_ADDR_EXP 148
88559: PUSH
88560: LD_INT 1
88562: ST_TO_ADDR
// if p3 = 114 then
88563: LD_VAR 0 3
88567: PUSH
88568: LD_INT 114
88570: EQUAL
88571: IFFALSE 88581
// sMortar := true ;
88573: LD_ADDR_EXP 149
88577: PUSH
88578: LD_INT 1
88580: ST_TO_ADDR
// if p3 = 115 then
88581: LD_VAR 0 3
88585: PUSH
88586: LD_INT 115
88588: EQUAL
88589: IFFALSE 88599
// sRanger := true ;
88591: LD_ADDR_EXP 159
88595: PUSH
88596: LD_INT 1
88598: ST_TO_ADDR
// end ; end ;
88599: PPOPN 6
88601: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
88602: LD_EXP 106
88606: PUSH
88607: LD_EXP 111
88611: AND
88612: IFFALSE 88736
88614: GO 88616
88616: DISABLE
88617: LD_INT 0
88619: PPUSH
88620: PPUSH
// begin enable ;
88621: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
88622: LD_ADDR_VAR 0 2
88626: PUSH
88627: LD_INT 22
88629: PUSH
88630: LD_OWVAR 2
88634: PUSH
88635: EMPTY
88636: LIST
88637: LIST
88638: PUSH
88639: LD_INT 2
88641: PUSH
88642: LD_INT 34
88644: PUSH
88645: LD_INT 7
88647: PUSH
88648: EMPTY
88649: LIST
88650: LIST
88651: PUSH
88652: LD_INT 34
88654: PUSH
88655: LD_INT 45
88657: PUSH
88658: EMPTY
88659: LIST
88660: LIST
88661: PUSH
88662: LD_INT 34
88664: PUSH
88665: LD_INT 28
88667: PUSH
88668: EMPTY
88669: LIST
88670: LIST
88671: PUSH
88672: LD_INT 34
88674: PUSH
88675: LD_INT 47
88677: PUSH
88678: EMPTY
88679: LIST
88680: LIST
88681: PUSH
88682: EMPTY
88683: LIST
88684: LIST
88685: LIST
88686: LIST
88687: LIST
88688: PUSH
88689: EMPTY
88690: LIST
88691: LIST
88692: PPUSH
88693: CALL_OW 69
88697: ST_TO_ADDR
// if not tmp then
88698: LD_VAR 0 2
88702: NOT
88703: IFFALSE 88707
// exit ;
88705: GO 88736
// for i in tmp do
88707: LD_ADDR_VAR 0 1
88711: PUSH
88712: LD_VAR 0 2
88716: PUSH
88717: FOR_IN
88718: IFFALSE 88734
// begin SetLives ( i , 0 ) ;
88720: LD_VAR 0 1
88724: PPUSH
88725: LD_INT 0
88727: PPUSH
88728: CALL_OW 234
// end ;
88732: GO 88717
88734: POP
88735: POP
// end ;
88736: PPOPN 2
88738: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
88739: LD_EXP 106
88743: PUSH
88744: LD_EXP 112
88748: AND
88749: IFFALSE 88833
88751: GO 88753
88753: DISABLE
88754: LD_INT 0
88756: PPUSH
88757: PPUSH
// begin enable ;
88758: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
88759: LD_ADDR_VAR 0 2
88763: PUSH
88764: LD_INT 22
88766: PUSH
88767: LD_OWVAR 2
88771: PUSH
88772: EMPTY
88773: LIST
88774: LIST
88775: PUSH
88776: LD_INT 32
88778: PUSH
88779: LD_INT 3
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: PUSH
88786: EMPTY
88787: LIST
88788: LIST
88789: PPUSH
88790: CALL_OW 69
88794: ST_TO_ADDR
// if not tmp then
88795: LD_VAR 0 2
88799: NOT
88800: IFFALSE 88804
// exit ;
88802: GO 88833
// for i in tmp do
88804: LD_ADDR_VAR 0 1
88808: PUSH
88809: LD_VAR 0 2
88813: PUSH
88814: FOR_IN
88815: IFFALSE 88831
// begin SetLives ( i , 0 ) ;
88817: LD_VAR 0 1
88821: PPUSH
88822: LD_INT 0
88824: PPUSH
88825: CALL_OW 234
// end ;
88829: GO 88814
88831: POP
88832: POP
// end ;
88833: PPOPN 2
88835: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
88836: LD_EXP 106
88840: PUSH
88841: LD_EXP 109
88845: AND
88846: IFFALSE 88939
88848: GO 88850
88850: DISABLE
88851: LD_INT 0
88853: PPUSH
// begin enable ;
88854: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
88855: LD_ADDR_VAR 0 1
88859: PUSH
88860: LD_INT 22
88862: PUSH
88863: LD_OWVAR 2
88867: PUSH
88868: EMPTY
88869: LIST
88870: LIST
88871: PUSH
88872: LD_INT 2
88874: PUSH
88875: LD_INT 25
88877: PUSH
88878: LD_INT 5
88880: PUSH
88881: EMPTY
88882: LIST
88883: LIST
88884: PUSH
88885: LD_INT 25
88887: PUSH
88888: LD_INT 9
88890: PUSH
88891: EMPTY
88892: LIST
88893: LIST
88894: PUSH
88895: LD_INT 25
88897: PUSH
88898: LD_INT 8
88900: PUSH
88901: EMPTY
88902: LIST
88903: LIST
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: PPUSH
88915: CALL_OW 69
88919: PUSH
88920: FOR_IN
88921: IFFALSE 88937
// begin SetClass ( i , 1 ) ;
88923: LD_VAR 0 1
88927: PPUSH
88928: LD_INT 1
88930: PPUSH
88931: CALL_OW 336
// end ;
88935: GO 88920
88937: POP
88938: POP
// end ;
88939: PPOPN 1
88941: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
88942: LD_EXP 106
88946: PUSH
88947: LD_EXP 110
88951: AND
88952: PUSH
88953: LD_OWVAR 65
88957: PUSH
88958: LD_INT 7
88960: LESS
88961: AND
88962: IFFALSE 88976
88964: GO 88966
88966: DISABLE
// begin enable ;
88967: ENABLE
// game_speed := 7 ;
88968: LD_ADDR_OWVAR 65
88972: PUSH
88973: LD_INT 7
88975: ST_TO_ADDR
// end ;
88976: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
88977: LD_EXP 106
88981: PUSH
88982: LD_EXP 113
88986: AND
88987: IFFALSE 89189
88989: GO 88991
88991: DISABLE
88992: LD_INT 0
88994: PPUSH
88995: PPUSH
88996: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
88997: LD_ADDR_VAR 0 3
89001: PUSH
89002: LD_INT 81
89004: PUSH
89005: LD_OWVAR 2
89009: PUSH
89010: EMPTY
89011: LIST
89012: LIST
89013: PUSH
89014: LD_INT 21
89016: PUSH
89017: LD_INT 1
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: PUSH
89024: EMPTY
89025: LIST
89026: LIST
89027: PPUSH
89028: CALL_OW 69
89032: ST_TO_ADDR
// if not tmp then
89033: LD_VAR 0 3
89037: NOT
89038: IFFALSE 89042
// exit ;
89040: GO 89189
// if tmp > 5 then
89042: LD_VAR 0 3
89046: PUSH
89047: LD_INT 5
89049: GREATER
89050: IFFALSE 89062
// k := 5 else
89052: LD_ADDR_VAR 0 2
89056: PUSH
89057: LD_INT 5
89059: ST_TO_ADDR
89060: GO 89072
// k := tmp ;
89062: LD_ADDR_VAR 0 2
89066: PUSH
89067: LD_VAR 0 3
89071: ST_TO_ADDR
// for i := 1 to k do
89072: LD_ADDR_VAR 0 1
89076: PUSH
89077: DOUBLE
89078: LD_INT 1
89080: DEC
89081: ST_TO_ADDR
89082: LD_VAR 0 2
89086: PUSH
89087: FOR_TO
89088: IFFALSE 89187
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
89090: LD_VAR 0 3
89094: PUSH
89095: LD_VAR 0 1
89099: ARRAY
89100: PPUSH
89101: LD_VAR 0 1
89105: PUSH
89106: LD_INT 4
89108: MOD
89109: PUSH
89110: LD_INT 1
89112: PLUS
89113: PPUSH
89114: CALL_OW 259
89118: PUSH
89119: LD_INT 10
89121: LESS
89122: IFFALSE 89185
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
89124: LD_VAR 0 3
89128: PUSH
89129: LD_VAR 0 1
89133: ARRAY
89134: PPUSH
89135: LD_VAR 0 1
89139: PUSH
89140: LD_INT 4
89142: MOD
89143: PUSH
89144: LD_INT 1
89146: PLUS
89147: PPUSH
89148: LD_VAR 0 3
89152: PUSH
89153: LD_VAR 0 1
89157: ARRAY
89158: PPUSH
89159: LD_VAR 0 1
89163: PUSH
89164: LD_INT 4
89166: MOD
89167: PUSH
89168: LD_INT 1
89170: PLUS
89171: PPUSH
89172: CALL_OW 259
89176: PUSH
89177: LD_INT 1
89179: PLUS
89180: PPUSH
89181: CALL_OW 237
89185: GO 89087
89187: POP
89188: POP
// end ;
89189: PPOPN 3
89191: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
89192: LD_EXP 106
89196: PUSH
89197: LD_EXP 114
89201: AND
89202: IFFALSE 89222
89204: GO 89206
89206: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
89207: LD_INT 4
89209: PPUSH
89210: LD_OWVAR 2
89214: PPUSH
89215: LD_INT 0
89217: PPUSH
89218: CALL_OW 324
89222: END
// every 0 0$1 trigger StreamModeActive and sShovel do
89223: LD_EXP 106
89227: PUSH
89228: LD_EXP 143
89232: AND
89233: IFFALSE 89253
89235: GO 89237
89237: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
89238: LD_INT 19
89240: PPUSH
89241: LD_OWVAR 2
89245: PPUSH
89246: LD_INT 0
89248: PPUSH
89249: CALL_OW 324
89253: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
89254: LD_EXP 106
89258: PUSH
89259: LD_EXP 115
89263: AND
89264: IFFALSE 89366
89266: GO 89268
89268: DISABLE
89269: LD_INT 0
89271: PPUSH
89272: PPUSH
// begin enable ;
89273: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
89274: LD_ADDR_VAR 0 2
89278: PUSH
89279: LD_INT 22
89281: PUSH
89282: LD_OWVAR 2
89286: PUSH
89287: EMPTY
89288: LIST
89289: LIST
89290: PUSH
89291: LD_INT 2
89293: PUSH
89294: LD_INT 34
89296: PUSH
89297: LD_INT 11
89299: PUSH
89300: EMPTY
89301: LIST
89302: LIST
89303: PUSH
89304: LD_INT 34
89306: PUSH
89307: LD_INT 30
89309: PUSH
89310: EMPTY
89311: LIST
89312: LIST
89313: PUSH
89314: EMPTY
89315: LIST
89316: LIST
89317: LIST
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PPUSH
89323: CALL_OW 69
89327: ST_TO_ADDR
// if not tmp then
89328: LD_VAR 0 2
89332: NOT
89333: IFFALSE 89337
// exit ;
89335: GO 89366
// for i in tmp do
89337: LD_ADDR_VAR 0 1
89341: PUSH
89342: LD_VAR 0 2
89346: PUSH
89347: FOR_IN
89348: IFFALSE 89364
// begin SetLives ( i , 0 ) ;
89350: LD_VAR 0 1
89354: PPUSH
89355: LD_INT 0
89357: PPUSH
89358: CALL_OW 234
// end ;
89362: GO 89347
89364: POP
89365: POP
// end ;
89366: PPOPN 2
89368: END
// every 0 0$1 trigger StreamModeActive and sBunker do
89369: LD_EXP 106
89373: PUSH
89374: LD_EXP 116
89378: AND
89379: IFFALSE 89399
89381: GO 89383
89383: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
89384: LD_INT 32
89386: PPUSH
89387: LD_OWVAR 2
89391: PPUSH
89392: LD_INT 0
89394: PPUSH
89395: CALL_OW 324
89399: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
89400: LD_EXP 106
89404: PUSH
89405: LD_EXP 117
89409: AND
89410: IFFALSE 89591
89412: GO 89414
89414: DISABLE
89415: LD_INT 0
89417: PPUSH
89418: PPUSH
89419: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
89420: LD_ADDR_VAR 0 2
89424: PUSH
89425: LD_INT 22
89427: PUSH
89428: LD_OWVAR 2
89432: PUSH
89433: EMPTY
89434: LIST
89435: LIST
89436: PUSH
89437: LD_INT 33
89439: PUSH
89440: LD_INT 3
89442: PUSH
89443: EMPTY
89444: LIST
89445: LIST
89446: PUSH
89447: EMPTY
89448: LIST
89449: LIST
89450: PPUSH
89451: CALL_OW 69
89455: ST_TO_ADDR
// if not tmp then
89456: LD_VAR 0 2
89460: NOT
89461: IFFALSE 89465
// exit ;
89463: GO 89591
// side := 0 ;
89465: LD_ADDR_VAR 0 3
89469: PUSH
89470: LD_INT 0
89472: ST_TO_ADDR
// for i := 1 to 8 do
89473: LD_ADDR_VAR 0 1
89477: PUSH
89478: DOUBLE
89479: LD_INT 1
89481: DEC
89482: ST_TO_ADDR
89483: LD_INT 8
89485: PUSH
89486: FOR_TO
89487: IFFALSE 89535
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
89489: LD_OWVAR 2
89493: PUSH
89494: LD_VAR 0 1
89498: NONEQUAL
89499: PUSH
89500: LD_OWVAR 2
89504: PPUSH
89505: LD_VAR 0 1
89509: PPUSH
89510: CALL_OW 81
89514: PUSH
89515: LD_INT 2
89517: EQUAL
89518: AND
89519: IFFALSE 89533
// begin side := i ;
89521: LD_ADDR_VAR 0 3
89525: PUSH
89526: LD_VAR 0 1
89530: ST_TO_ADDR
// break ;
89531: GO 89535
// end ;
89533: GO 89486
89535: POP
89536: POP
// if not side then
89537: LD_VAR 0 3
89541: NOT
89542: IFFALSE 89546
// exit ;
89544: GO 89591
// for i := 1 to tmp do
89546: LD_ADDR_VAR 0 1
89550: PUSH
89551: DOUBLE
89552: LD_INT 1
89554: DEC
89555: ST_TO_ADDR
89556: LD_VAR 0 2
89560: PUSH
89561: FOR_TO
89562: IFFALSE 89589
// if Prob ( 60 ) then
89564: LD_INT 60
89566: PPUSH
89567: CALL_OW 13
89571: IFFALSE 89587
// SetSide ( i , side ) ;
89573: LD_VAR 0 1
89577: PPUSH
89578: LD_VAR 0 3
89582: PPUSH
89583: CALL_OW 235
89587: GO 89561
89589: POP
89590: POP
// end ;
89591: PPOPN 3
89593: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
89594: LD_EXP 106
89598: PUSH
89599: LD_EXP 119
89603: AND
89604: IFFALSE 89723
89606: GO 89608
89608: DISABLE
89609: LD_INT 0
89611: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
89612: LD_ADDR_VAR 0 1
89616: PUSH
89617: LD_INT 22
89619: PUSH
89620: LD_OWVAR 2
89624: PUSH
89625: EMPTY
89626: LIST
89627: LIST
89628: PUSH
89629: LD_INT 21
89631: PUSH
89632: LD_INT 1
89634: PUSH
89635: EMPTY
89636: LIST
89637: LIST
89638: PUSH
89639: LD_INT 3
89641: PUSH
89642: LD_INT 23
89644: PUSH
89645: LD_INT 0
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: PUSH
89656: EMPTY
89657: LIST
89658: LIST
89659: LIST
89660: PPUSH
89661: CALL_OW 69
89665: PUSH
89666: FOR_IN
89667: IFFALSE 89721
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
89669: LD_VAR 0 1
89673: PPUSH
89674: CALL_OW 257
89678: PUSH
89679: LD_INT 1
89681: PUSH
89682: LD_INT 2
89684: PUSH
89685: LD_INT 3
89687: PUSH
89688: LD_INT 4
89690: PUSH
89691: EMPTY
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: IN
89697: IFFALSE 89719
// SetClass ( un , rand ( 1 , 4 ) ) ;
89699: LD_VAR 0 1
89703: PPUSH
89704: LD_INT 1
89706: PPUSH
89707: LD_INT 4
89709: PPUSH
89710: CALL_OW 12
89714: PPUSH
89715: CALL_OW 336
89719: GO 89666
89721: POP
89722: POP
// end ;
89723: PPOPN 1
89725: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
89726: LD_EXP 106
89730: PUSH
89731: LD_EXP 118
89735: AND
89736: IFFALSE 89815
89738: GO 89740
89740: DISABLE
89741: LD_INT 0
89743: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
89744: LD_ADDR_VAR 0 1
89748: PUSH
89749: LD_INT 22
89751: PUSH
89752: LD_OWVAR 2
89756: PUSH
89757: EMPTY
89758: LIST
89759: LIST
89760: PUSH
89761: LD_INT 21
89763: PUSH
89764: LD_INT 3
89766: PUSH
89767: EMPTY
89768: LIST
89769: LIST
89770: PUSH
89771: EMPTY
89772: LIST
89773: LIST
89774: PPUSH
89775: CALL_OW 69
89779: ST_TO_ADDR
// if not tmp then
89780: LD_VAR 0 1
89784: NOT
89785: IFFALSE 89789
// exit ;
89787: GO 89815
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
89789: LD_VAR 0 1
89793: PUSH
89794: LD_INT 1
89796: PPUSH
89797: LD_VAR 0 1
89801: PPUSH
89802: CALL_OW 12
89806: ARRAY
89807: PPUSH
89808: LD_INT 100
89810: PPUSH
89811: CALL_OW 234
// end ;
89815: PPOPN 1
89817: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
89818: LD_EXP 106
89822: PUSH
89823: LD_EXP 120
89827: AND
89828: IFFALSE 89926
89830: GO 89832
89832: DISABLE
89833: LD_INT 0
89835: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89836: LD_ADDR_VAR 0 1
89840: PUSH
89841: LD_INT 22
89843: PUSH
89844: LD_OWVAR 2
89848: PUSH
89849: EMPTY
89850: LIST
89851: LIST
89852: PUSH
89853: LD_INT 21
89855: PUSH
89856: LD_INT 1
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: PUSH
89863: EMPTY
89864: LIST
89865: LIST
89866: PPUSH
89867: CALL_OW 69
89871: ST_TO_ADDR
// if not tmp then
89872: LD_VAR 0 1
89876: NOT
89877: IFFALSE 89881
// exit ;
89879: GO 89926
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
89881: LD_VAR 0 1
89885: PUSH
89886: LD_INT 1
89888: PPUSH
89889: LD_VAR 0 1
89893: PPUSH
89894: CALL_OW 12
89898: ARRAY
89899: PPUSH
89900: LD_INT 1
89902: PPUSH
89903: LD_INT 4
89905: PPUSH
89906: CALL_OW 12
89910: PPUSH
89911: LD_INT 3000
89913: PPUSH
89914: LD_INT 9000
89916: PPUSH
89917: CALL_OW 12
89921: PPUSH
89922: CALL_OW 492
// end ;
89926: PPOPN 1
89928: END
// every 0 0$1 trigger StreamModeActive and sDepot do
89929: LD_EXP 106
89933: PUSH
89934: LD_EXP 121
89938: AND
89939: IFFALSE 89959
89941: GO 89943
89943: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
89944: LD_INT 1
89946: PPUSH
89947: LD_OWVAR 2
89951: PPUSH
89952: LD_INT 0
89954: PPUSH
89955: CALL_OW 324
89959: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
89960: LD_EXP 106
89964: PUSH
89965: LD_EXP 122
89969: AND
89970: IFFALSE 90053
89972: GO 89974
89974: DISABLE
89975: LD_INT 0
89977: PPUSH
89978: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
89979: LD_ADDR_VAR 0 2
89983: PUSH
89984: LD_INT 22
89986: PUSH
89987: LD_OWVAR 2
89991: PUSH
89992: EMPTY
89993: LIST
89994: LIST
89995: PUSH
89996: LD_INT 21
89998: PUSH
89999: LD_INT 3
90001: PUSH
90002: EMPTY
90003: LIST
90004: LIST
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PPUSH
90010: CALL_OW 69
90014: ST_TO_ADDR
// if not tmp then
90015: LD_VAR 0 2
90019: NOT
90020: IFFALSE 90024
// exit ;
90022: GO 90053
// for i in tmp do
90024: LD_ADDR_VAR 0 1
90028: PUSH
90029: LD_VAR 0 2
90033: PUSH
90034: FOR_IN
90035: IFFALSE 90051
// SetBLevel ( i , 10 ) ;
90037: LD_VAR 0 1
90041: PPUSH
90042: LD_INT 10
90044: PPUSH
90045: CALL_OW 241
90049: GO 90034
90051: POP
90052: POP
// end ;
90053: PPOPN 2
90055: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
90056: LD_EXP 106
90060: PUSH
90061: LD_EXP 123
90065: AND
90066: IFFALSE 90177
90068: GO 90070
90070: DISABLE
90071: LD_INT 0
90073: PPUSH
90074: PPUSH
90075: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90076: LD_ADDR_VAR 0 3
90080: PUSH
90081: LD_INT 22
90083: PUSH
90084: LD_OWVAR 2
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: PUSH
90093: LD_INT 25
90095: PUSH
90096: LD_INT 1
90098: PUSH
90099: EMPTY
90100: LIST
90101: LIST
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: PPUSH
90107: CALL_OW 69
90111: ST_TO_ADDR
// if not tmp then
90112: LD_VAR 0 3
90116: NOT
90117: IFFALSE 90121
// exit ;
90119: GO 90177
// un := tmp [ rand ( 1 , tmp ) ] ;
90121: LD_ADDR_VAR 0 2
90125: PUSH
90126: LD_VAR 0 3
90130: PUSH
90131: LD_INT 1
90133: PPUSH
90134: LD_VAR 0 3
90138: PPUSH
90139: CALL_OW 12
90143: ARRAY
90144: ST_TO_ADDR
// if Crawls ( un ) then
90145: LD_VAR 0 2
90149: PPUSH
90150: CALL_OW 318
90154: IFFALSE 90165
// ComWalk ( un ) ;
90156: LD_VAR 0 2
90160: PPUSH
90161: CALL_OW 138
// SetClass ( un , class_sniper ) ;
90165: LD_VAR 0 2
90169: PPUSH
90170: LD_INT 5
90172: PPUSH
90173: CALL_OW 336
// end ;
90177: PPOPN 3
90179: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
90180: LD_EXP 106
90184: PUSH
90185: LD_EXP 124
90189: AND
90190: PUSH
90191: LD_OWVAR 67
90195: PUSH
90196: LD_INT 3
90198: LESS
90199: AND
90200: IFFALSE 90219
90202: GO 90204
90204: DISABLE
// Difficulty := Difficulty + 1 ;
90205: LD_ADDR_OWVAR 67
90209: PUSH
90210: LD_OWVAR 67
90214: PUSH
90215: LD_INT 1
90217: PLUS
90218: ST_TO_ADDR
90219: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
90220: LD_EXP 106
90224: PUSH
90225: LD_EXP 125
90229: AND
90230: IFFALSE 90333
90232: GO 90234
90234: DISABLE
90235: LD_INT 0
90237: PPUSH
// begin for i := 1 to 5 do
90238: LD_ADDR_VAR 0 1
90242: PUSH
90243: DOUBLE
90244: LD_INT 1
90246: DEC
90247: ST_TO_ADDR
90248: LD_INT 5
90250: PUSH
90251: FOR_TO
90252: IFFALSE 90331
// begin uc_nation := nation_nature ;
90254: LD_ADDR_OWVAR 21
90258: PUSH
90259: LD_INT 0
90261: ST_TO_ADDR
// uc_side := 0 ;
90262: LD_ADDR_OWVAR 20
90266: PUSH
90267: LD_INT 0
90269: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
90270: LD_ADDR_OWVAR 29
90274: PUSH
90275: LD_INT 12
90277: PUSH
90278: LD_INT 12
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: ST_TO_ADDR
// hc_agressivity := 20 ;
90285: LD_ADDR_OWVAR 35
90289: PUSH
90290: LD_INT 20
90292: ST_TO_ADDR
// hc_class := class_tiger ;
90293: LD_ADDR_OWVAR 28
90297: PUSH
90298: LD_INT 14
90300: ST_TO_ADDR
// hc_gallery :=  ;
90301: LD_ADDR_OWVAR 33
90305: PUSH
90306: LD_STRING 
90308: ST_TO_ADDR
// hc_name :=  ;
90309: LD_ADDR_OWVAR 26
90313: PUSH
90314: LD_STRING 
90316: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
90317: CALL_OW 44
90321: PPUSH
90322: LD_INT 0
90324: PPUSH
90325: CALL_OW 51
// end ;
90329: GO 90251
90331: POP
90332: POP
// end ;
90333: PPOPN 1
90335: END
// every 0 0$1 trigger StreamModeActive and sBomb do
90336: LD_EXP 106
90340: PUSH
90341: LD_EXP 126
90345: AND
90346: IFFALSE 90355
90348: GO 90350
90350: DISABLE
// StreamSibBomb ;
90351: CALL 90356 0 0
90355: END
// export function StreamSibBomb ; var i , x , y ; begin
90356: LD_INT 0
90358: PPUSH
90359: PPUSH
90360: PPUSH
90361: PPUSH
// result := false ;
90362: LD_ADDR_VAR 0 1
90366: PUSH
90367: LD_INT 0
90369: ST_TO_ADDR
// for i := 1 to 16 do
90370: LD_ADDR_VAR 0 2
90374: PUSH
90375: DOUBLE
90376: LD_INT 1
90378: DEC
90379: ST_TO_ADDR
90380: LD_INT 16
90382: PUSH
90383: FOR_TO
90384: IFFALSE 90583
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
90386: LD_ADDR_VAR 0 3
90390: PUSH
90391: LD_INT 10
90393: PUSH
90394: LD_INT 20
90396: PUSH
90397: LD_INT 30
90399: PUSH
90400: LD_INT 40
90402: PUSH
90403: LD_INT 50
90405: PUSH
90406: LD_INT 60
90408: PUSH
90409: LD_INT 70
90411: PUSH
90412: LD_INT 80
90414: PUSH
90415: LD_INT 90
90417: PUSH
90418: LD_INT 100
90420: PUSH
90421: LD_INT 110
90423: PUSH
90424: LD_INT 120
90426: PUSH
90427: LD_INT 130
90429: PUSH
90430: LD_INT 140
90432: PUSH
90433: LD_INT 150
90435: PUSH
90436: EMPTY
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: LIST
90445: LIST
90446: LIST
90447: LIST
90448: LIST
90449: LIST
90450: LIST
90451: LIST
90452: PUSH
90453: LD_INT 1
90455: PPUSH
90456: LD_INT 15
90458: PPUSH
90459: CALL_OW 12
90463: ARRAY
90464: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
90465: LD_ADDR_VAR 0 4
90469: PUSH
90470: LD_INT 10
90472: PUSH
90473: LD_INT 20
90475: PUSH
90476: LD_INT 30
90478: PUSH
90479: LD_INT 40
90481: PUSH
90482: LD_INT 50
90484: PUSH
90485: LD_INT 60
90487: PUSH
90488: LD_INT 70
90490: PUSH
90491: LD_INT 80
90493: PUSH
90494: LD_INT 90
90496: PUSH
90497: LD_INT 100
90499: PUSH
90500: LD_INT 110
90502: PUSH
90503: LD_INT 120
90505: PUSH
90506: LD_INT 130
90508: PUSH
90509: LD_INT 140
90511: PUSH
90512: LD_INT 150
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: LIST
90519: LIST
90520: LIST
90521: LIST
90522: LIST
90523: LIST
90524: LIST
90525: LIST
90526: LIST
90527: LIST
90528: LIST
90529: LIST
90530: LIST
90531: PUSH
90532: LD_INT 1
90534: PPUSH
90535: LD_INT 15
90537: PPUSH
90538: CALL_OW 12
90542: ARRAY
90543: ST_TO_ADDR
// if ValidHex ( x , y ) then
90544: LD_VAR 0 3
90548: PPUSH
90549: LD_VAR 0 4
90553: PPUSH
90554: CALL_OW 488
90558: IFFALSE 90581
// begin result := [ x , y ] ;
90560: LD_ADDR_VAR 0 1
90564: PUSH
90565: LD_VAR 0 3
90569: PUSH
90570: LD_VAR 0 4
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: ST_TO_ADDR
// break ;
90579: GO 90583
// end ; end ;
90581: GO 90383
90583: POP
90584: POP
// if result then
90585: LD_VAR 0 1
90589: IFFALSE 90649
// begin ToLua ( playSibBomb() ) ;
90591: LD_STRING playSibBomb()
90593: PPUSH
90594: CALL_OW 559
// wait ( 0 0$14 ) ;
90598: LD_INT 490
90600: PPUSH
90601: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
90605: LD_VAR 0 1
90609: PUSH
90610: LD_INT 1
90612: ARRAY
90613: PPUSH
90614: LD_VAR 0 1
90618: PUSH
90619: LD_INT 2
90621: ARRAY
90622: PPUSH
90623: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
90627: LD_VAR 0 1
90631: PUSH
90632: LD_INT 1
90634: ARRAY
90635: PPUSH
90636: LD_VAR 0 1
90640: PUSH
90641: LD_INT 2
90643: ARRAY
90644: PPUSH
90645: CALL_OW 429
// end ; end ;
90649: LD_VAR 0 1
90653: RET
// every 0 0$1 trigger StreamModeActive and sReset do
90654: LD_EXP 106
90658: PUSH
90659: LD_EXP 128
90663: AND
90664: IFFALSE 90676
90666: GO 90668
90668: DISABLE
// YouLost (  ) ;
90669: LD_STRING 
90671: PPUSH
90672: CALL_OW 104
90676: END
// every 0 0$1 trigger StreamModeActive and sFog do
90677: LD_EXP 106
90681: PUSH
90682: LD_EXP 127
90686: AND
90687: IFFALSE 90701
90689: GO 90691
90691: DISABLE
// FogOff ( your_side ) ;
90692: LD_OWVAR 2
90696: PPUSH
90697: CALL_OW 344
90701: END
// every 0 0$1 trigger StreamModeActive and sSun do
90702: LD_EXP 106
90706: PUSH
90707: LD_EXP 129
90711: AND
90712: IFFALSE 90740
90714: GO 90716
90716: DISABLE
// begin solar_recharge_percent := 0 ;
90717: LD_ADDR_OWVAR 79
90721: PUSH
90722: LD_INT 0
90724: ST_TO_ADDR
// wait ( 5 5$00 ) ;
90725: LD_INT 10500
90727: PPUSH
90728: CALL_OW 67
// solar_recharge_percent := 100 ;
90732: LD_ADDR_OWVAR 79
90736: PUSH
90737: LD_INT 100
90739: ST_TO_ADDR
// end ;
90740: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
90741: LD_EXP 106
90745: PUSH
90746: LD_EXP 130
90750: AND
90751: IFFALSE 90990
90753: GO 90755
90755: DISABLE
90756: LD_INT 0
90758: PPUSH
90759: PPUSH
90760: PPUSH
// begin tmp := [ ] ;
90761: LD_ADDR_VAR 0 3
90765: PUSH
90766: EMPTY
90767: ST_TO_ADDR
// for i := 1 to 6 do
90768: LD_ADDR_VAR 0 1
90772: PUSH
90773: DOUBLE
90774: LD_INT 1
90776: DEC
90777: ST_TO_ADDR
90778: LD_INT 6
90780: PUSH
90781: FOR_TO
90782: IFFALSE 90887
// begin uc_nation := nation_nature ;
90784: LD_ADDR_OWVAR 21
90788: PUSH
90789: LD_INT 0
90791: ST_TO_ADDR
// uc_side := 0 ;
90792: LD_ADDR_OWVAR 20
90796: PUSH
90797: LD_INT 0
90799: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
90800: LD_ADDR_OWVAR 29
90804: PUSH
90805: LD_INT 12
90807: PUSH
90808: LD_INT 12
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: ST_TO_ADDR
// hc_agressivity := 20 ;
90815: LD_ADDR_OWVAR 35
90819: PUSH
90820: LD_INT 20
90822: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
90823: LD_ADDR_OWVAR 28
90827: PUSH
90828: LD_INT 17
90830: ST_TO_ADDR
// hc_gallery :=  ;
90831: LD_ADDR_OWVAR 33
90835: PUSH
90836: LD_STRING 
90838: ST_TO_ADDR
// hc_name :=  ;
90839: LD_ADDR_OWVAR 26
90843: PUSH
90844: LD_STRING 
90846: ST_TO_ADDR
// un := CreateHuman ;
90847: LD_ADDR_VAR 0 2
90851: PUSH
90852: CALL_OW 44
90856: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
90857: LD_VAR 0 2
90861: PPUSH
90862: LD_INT 1
90864: PPUSH
90865: CALL_OW 51
// tmp := tmp ^ un ;
90869: LD_ADDR_VAR 0 3
90873: PUSH
90874: LD_VAR 0 3
90878: PUSH
90879: LD_VAR 0 2
90883: ADD
90884: ST_TO_ADDR
// end ;
90885: GO 90781
90887: POP
90888: POP
// repeat wait ( 0 0$1 ) ;
90889: LD_INT 35
90891: PPUSH
90892: CALL_OW 67
// for un in tmp do
90896: LD_ADDR_VAR 0 2
90900: PUSH
90901: LD_VAR 0 3
90905: PUSH
90906: FOR_IN
90907: IFFALSE 90981
// begin if IsDead ( un ) then
90909: LD_VAR 0 2
90913: PPUSH
90914: CALL_OW 301
90918: IFFALSE 90938
// begin tmp := tmp diff un ;
90920: LD_ADDR_VAR 0 3
90924: PUSH
90925: LD_VAR 0 3
90929: PUSH
90930: LD_VAR 0 2
90934: DIFF
90935: ST_TO_ADDR
// continue ;
90936: GO 90906
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
90938: LD_VAR 0 2
90942: PPUSH
90943: LD_INT 3
90945: PUSH
90946: LD_INT 22
90948: PUSH
90949: LD_INT 0
90951: PUSH
90952: EMPTY
90953: LIST
90954: LIST
90955: PUSH
90956: EMPTY
90957: LIST
90958: LIST
90959: PPUSH
90960: CALL_OW 69
90964: PPUSH
90965: LD_VAR 0 2
90969: PPUSH
90970: CALL_OW 74
90974: PPUSH
90975: CALL_OW 115
// end ;
90979: GO 90906
90981: POP
90982: POP
// until not tmp ;
90983: LD_VAR 0 3
90987: NOT
90988: IFFALSE 90889
// end ;
90990: PPOPN 3
90992: END
// every 0 0$1 trigger StreamModeActive and sTroll do
90993: LD_EXP 106
90997: PUSH
90998: LD_EXP 131
91002: AND
91003: IFFALSE 91057
91005: GO 91007
91007: DISABLE
// begin ToLua ( displayTroll(); ) ;
91008: LD_STRING displayTroll();
91010: PPUSH
91011: CALL_OW 559
// wait ( 3 3$00 ) ;
91015: LD_INT 6300
91017: PPUSH
91018: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91022: LD_STRING hideTroll();
91024: PPUSH
91025: CALL_OW 559
// wait ( 1 1$00 ) ;
91029: LD_INT 2100
91031: PPUSH
91032: CALL_OW 67
// ToLua ( displayTroll(); ) ;
91036: LD_STRING displayTroll();
91038: PPUSH
91039: CALL_OW 559
// wait ( 1 1$00 ) ;
91043: LD_INT 2100
91045: PPUSH
91046: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91050: LD_STRING hideTroll();
91052: PPUSH
91053: CALL_OW 559
// end ;
91057: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
91058: LD_EXP 106
91062: PUSH
91063: LD_EXP 132
91067: AND
91068: IFFALSE 91131
91070: GO 91072
91072: DISABLE
91073: LD_INT 0
91075: PPUSH
// begin p := 0 ;
91076: LD_ADDR_VAR 0 1
91080: PUSH
91081: LD_INT 0
91083: ST_TO_ADDR
// repeat game_speed := 1 ;
91084: LD_ADDR_OWVAR 65
91088: PUSH
91089: LD_INT 1
91091: ST_TO_ADDR
// wait ( 0 0$1 ) ;
91092: LD_INT 35
91094: PPUSH
91095: CALL_OW 67
// p := p + 1 ;
91099: LD_ADDR_VAR 0 1
91103: PUSH
91104: LD_VAR 0 1
91108: PUSH
91109: LD_INT 1
91111: PLUS
91112: ST_TO_ADDR
// until p >= 60 ;
91113: LD_VAR 0 1
91117: PUSH
91118: LD_INT 60
91120: GREATEREQUAL
91121: IFFALSE 91084
// game_speed := 4 ;
91123: LD_ADDR_OWVAR 65
91127: PUSH
91128: LD_INT 4
91130: ST_TO_ADDR
// end ;
91131: PPOPN 1
91133: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
91134: LD_EXP 106
91138: PUSH
91139: LD_EXP 133
91143: AND
91144: IFFALSE 91290
91146: GO 91148
91148: DISABLE
91149: LD_INT 0
91151: PPUSH
91152: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91153: LD_ADDR_VAR 0 1
91157: PUSH
91158: LD_INT 22
91160: PUSH
91161: LD_OWVAR 2
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: PUSH
91170: LD_INT 2
91172: PUSH
91173: LD_INT 30
91175: PUSH
91176: LD_INT 0
91178: PUSH
91179: EMPTY
91180: LIST
91181: LIST
91182: PUSH
91183: LD_INT 30
91185: PUSH
91186: LD_INT 1
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: LIST
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: PPUSH
91202: CALL_OW 69
91206: ST_TO_ADDR
// if not depot then
91207: LD_VAR 0 1
91211: NOT
91212: IFFALSE 91216
// exit ;
91214: GO 91290
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
91216: LD_ADDR_VAR 0 2
91220: PUSH
91221: LD_VAR 0 1
91225: PUSH
91226: LD_INT 1
91228: PPUSH
91229: LD_VAR 0 1
91233: PPUSH
91234: CALL_OW 12
91238: ARRAY
91239: PPUSH
91240: CALL_OW 274
91244: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
91245: LD_VAR 0 2
91249: PPUSH
91250: LD_INT 1
91252: PPUSH
91253: LD_INT 0
91255: PPUSH
91256: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
91260: LD_VAR 0 2
91264: PPUSH
91265: LD_INT 2
91267: PPUSH
91268: LD_INT 0
91270: PPUSH
91271: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
91275: LD_VAR 0 2
91279: PPUSH
91280: LD_INT 3
91282: PPUSH
91283: LD_INT 0
91285: PPUSH
91286: CALL_OW 277
// end ;
91290: PPOPN 2
91292: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
91293: LD_EXP 106
91297: PUSH
91298: LD_EXP 134
91302: AND
91303: IFFALSE 91400
91305: GO 91307
91307: DISABLE
91308: LD_INT 0
91310: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91311: LD_ADDR_VAR 0 1
91315: PUSH
91316: LD_INT 22
91318: PUSH
91319: LD_OWVAR 2
91323: PUSH
91324: EMPTY
91325: LIST
91326: LIST
91327: PUSH
91328: LD_INT 21
91330: PUSH
91331: LD_INT 1
91333: PUSH
91334: EMPTY
91335: LIST
91336: LIST
91337: PUSH
91338: LD_INT 3
91340: PUSH
91341: LD_INT 23
91343: PUSH
91344: LD_INT 0
91346: PUSH
91347: EMPTY
91348: LIST
91349: LIST
91350: PUSH
91351: EMPTY
91352: LIST
91353: LIST
91354: PUSH
91355: EMPTY
91356: LIST
91357: LIST
91358: LIST
91359: PPUSH
91360: CALL_OW 69
91364: ST_TO_ADDR
// if not tmp then
91365: LD_VAR 0 1
91369: NOT
91370: IFFALSE 91374
// exit ;
91372: GO 91400
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
91374: LD_VAR 0 1
91378: PUSH
91379: LD_INT 1
91381: PPUSH
91382: LD_VAR 0 1
91386: PPUSH
91387: CALL_OW 12
91391: ARRAY
91392: PPUSH
91393: LD_INT 200
91395: PPUSH
91396: CALL_OW 234
// end ;
91400: PPOPN 1
91402: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
91403: LD_EXP 106
91407: PUSH
91408: LD_EXP 135
91412: AND
91413: IFFALSE 91492
91415: GO 91417
91417: DISABLE
91418: LD_INT 0
91420: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
91421: LD_ADDR_VAR 0 1
91425: PUSH
91426: LD_INT 22
91428: PUSH
91429: LD_OWVAR 2
91433: PUSH
91434: EMPTY
91435: LIST
91436: LIST
91437: PUSH
91438: LD_INT 21
91440: PUSH
91441: LD_INT 2
91443: PUSH
91444: EMPTY
91445: LIST
91446: LIST
91447: PUSH
91448: EMPTY
91449: LIST
91450: LIST
91451: PPUSH
91452: CALL_OW 69
91456: ST_TO_ADDR
// if not tmp then
91457: LD_VAR 0 1
91461: NOT
91462: IFFALSE 91466
// exit ;
91464: GO 91492
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
91466: LD_VAR 0 1
91470: PUSH
91471: LD_INT 1
91473: PPUSH
91474: LD_VAR 0 1
91478: PPUSH
91479: CALL_OW 12
91483: ARRAY
91484: PPUSH
91485: LD_INT 60
91487: PPUSH
91488: CALL_OW 234
// end ;
91492: PPOPN 1
91494: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
91495: LD_EXP 106
91499: PUSH
91500: LD_EXP 136
91504: AND
91505: IFFALSE 91604
91507: GO 91509
91509: DISABLE
91510: LD_INT 0
91512: PPUSH
91513: PPUSH
// begin enable ;
91514: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
91515: LD_ADDR_VAR 0 1
91519: PUSH
91520: LD_INT 22
91522: PUSH
91523: LD_OWVAR 2
91527: PUSH
91528: EMPTY
91529: LIST
91530: LIST
91531: PUSH
91532: LD_INT 61
91534: PUSH
91535: EMPTY
91536: LIST
91537: PUSH
91538: LD_INT 33
91540: PUSH
91541: LD_INT 2
91543: PUSH
91544: EMPTY
91545: LIST
91546: LIST
91547: PUSH
91548: EMPTY
91549: LIST
91550: LIST
91551: LIST
91552: PPUSH
91553: CALL_OW 69
91557: ST_TO_ADDR
// if not tmp then
91558: LD_VAR 0 1
91562: NOT
91563: IFFALSE 91567
// exit ;
91565: GO 91604
// for i in tmp do
91567: LD_ADDR_VAR 0 2
91571: PUSH
91572: LD_VAR 0 1
91576: PUSH
91577: FOR_IN
91578: IFFALSE 91602
// if IsControledBy ( i ) then
91580: LD_VAR 0 2
91584: PPUSH
91585: CALL_OW 312
91589: IFFALSE 91600
// ComUnlink ( i ) ;
91591: LD_VAR 0 2
91595: PPUSH
91596: CALL_OW 136
91600: GO 91577
91602: POP
91603: POP
// end ;
91604: PPOPN 2
91606: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
91607: LD_EXP 106
91611: PUSH
91612: LD_EXP 137
91616: AND
91617: IFFALSE 91757
91619: GO 91621
91621: DISABLE
91622: LD_INT 0
91624: PPUSH
91625: PPUSH
// begin ToLua ( displayPowell(); ) ;
91626: LD_STRING displayPowell();
91628: PPUSH
91629: CALL_OW 559
// uc_side := 0 ;
91633: LD_ADDR_OWVAR 20
91637: PUSH
91638: LD_INT 0
91640: ST_TO_ADDR
// uc_nation := 2 ;
91641: LD_ADDR_OWVAR 21
91645: PUSH
91646: LD_INT 2
91648: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
91649: LD_ADDR_OWVAR 37
91653: PUSH
91654: LD_INT 14
91656: ST_TO_ADDR
// vc_engine := engine_siberite ;
91657: LD_ADDR_OWVAR 39
91661: PUSH
91662: LD_INT 3
91664: ST_TO_ADDR
// vc_control := control_apeman ;
91665: LD_ADDR_OWVAR 38
91669: PUSH
91670: LD_INT 5
91672: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
91673: LD_ADDR_OWVAR 40
91677: PUSH
91678: LD_INT 29
91680: ST_TO_ADDR
// un := CreateVehicle ;
91681: LD_ADDR_VAR 0 2
91685: PUSH
91686: CALL_OW 45
91690: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91691: LD_VAR 0 2
91695: PPUSH
91696: LD_INT 1
91698: PPUSH
91699: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
91703: LD_INT 35
91705: PPUSH
91706: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
91710: LD_VAR 0 2
91714: PPUSH
91715: LD_INT 22
91717: PUSH
91718: LD_OWVAR 2
91722: PUSH
91723: EMPTY
91724: LIST
91725: LIST
91726: PPUSH
91727: CALL_OW 69
91731: PPUSH
91732: LD_VAR 0 2
91736: PPUSH
91737: CALL_OW 74
91741: PPUSH
91742: CALL_OW 115
// until IsDead ( un ) ;
91746: LD_VAR 0 2
91750: PPUSH
91751: CALL_OW 301
91755: IFFALSE 91703
// end ;
91757: PPOPN 2
91759: END
// every 0 0$1 trigger StreamModeActive and sStu do
91760: LD_EXP 106
91764: PUSH
91765: LD_EXP 145
91769: AND
91770: IFFALSE 91786
91772: GO 91774
91774: DISABLE
// begin ToLua ( displayStucuk(); ) ;
91775: LD_STRING displayStucuk();
91777: PPUSH
91778: CALL_OW 559
// ResetFog ;
91782: CALL_OW 335
// end ;
91786: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
91787: LD_EXP 106
91791: PUSH
91792: LD_EXP 138
91796: AND
91797: IFFALSE 91938
91799: GO 91801
91801: DISABLE
91802: LD_INT 0
91804: PPUSH
91805: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91806: LD_ADDR_VAR 0 2
91810: PUSH
91811: LD_INT 22
91813: PUSH
91814: LD_OWVAR 2
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: PUSH
91823: LD_INT 21
91825: PUSH
91826: LD_INT 1
91828: PUSH
91829: EMPTY
91830: LIST
91831: LIST
91832: PUSH
91833: EMPTY
91834: LIST
91835: LIST
91836: PPUSH
91837: CALL_OW 69
91841: ST_TO_ADDR
// if not tmp then
91842: LD_VAR 0 2
91846: NOT
91847: IFFALSE 91851
// exit ;
91849: GO 91938
// un := tmp [ rand ( 1 , tmp ) ] ;
91851: LD_ADDR_VAR 0 1
91855: PUSH
91856: LD_VAR 0 2
91860: PUSH
91861: LD_INT 1
91863: PPUSH
91864: LD_VAR 0 2
91868: PPUSH
91869: CALL_OW 12
91873: ARRAY
91874: ST_TO_ADDR
// SetSide ( un , 0 ) ;
91875: LD_VAR 0 1
91879: PPUSH
91880: LD_INT 0
91882: PPUSH
91883: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
91887: LD_VAR 0 1
91891: PPUSH
91892: LD_OWVAR 3
91896: PUSH
91897: LD_VAR 0 1
91901: DIFF
91902: PPUSH
91903: LD_VAR 0 1
91907: PPUSH
91908: CALL_OW 74
91912: PPUSH
91913: CALL_OW 115
// wait ( 0 0$20 ) ;
91917: LD_INT 700
91919: PPUSH
91920: CALL_OW 67
// SetSide ( un , your_side ) ;
91924: LD_VAR 0 1
91928: PPUSH
91929: LD_OWVAR 2
91933: PPUSH
91934: CALL_OW 235
// end ;
91938: PPOPN 2
91940: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
91941: LD_EXP 106
91945: PUSH
91946: LD_EXP 139
91950: AND
91951: IFFALSE 92057
91953: GO 91955
91955: DISABLE
91956: LD_INT 0
91958: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91959: LD_ADDR_VAR 0 1
91963: PUSH
91964: LD_INT 22
91966: PUSH
91967: LD_OWVAR 2
91971: PUSH
91972: EMPTY
91973: LIST
91974: LIST
91975: PUSH
91976: LD_INT 2
91978: PUSH
91979: LD_INT 30
91981: PUSH
91982: LD_INT 0
91984: PUSH
91985: EMPTY
91986: LIST
91987: LIST
91988: PUSH
91989: LD_INT 30
91991: PUSH
91992: LD_INT 1
91994: PUSH
91995: EMPTY
91996: LIST
91997: LIST
91998: PUSH
91999: EMPTY
92000: LIST
92001: LIST
92002: LIST
92003: PUSH
92004: EMPTY
92005: LIST
92006: LIST
92007: PPUSH
92008: CALL_OW 69
92012: ST_TO_ADDR
// if not depot then
92013: LD_VAR 0 1
92017: NOT
92018: IFFALSE 92022
// exit ;
92020: GO 92057
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
92022: LD_VAR 0 1
92026: PUSH
92027: LD_INT 1
92029: ARRAY
92030: PPUSH
92031: CALL_OW 250
92035: PPUSH
92036: LD_VAR 0 1
92040: PUSH
92041: LD_INT 1
92043: ARRAY
92044: PPUSH
92045: CALL_OW 251
92049: PPUSH
92050: LD_INT 70
92052: PPUSH
92053: CALL_OW 495
// end ;
92057: PPOPN 1
92059: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
92060: LD_EXP 106
92064: PUSH
92065: LD_EXP 140
92069: AND
92070: IFFALSE 92281
92072: GO 92074
92074: DISABLE
92075: LD_INT 0
92077: PPUSH
92078: PPUSH
92079: PPUSH
92080: PPUSH
92081: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92082: LD_ADDR_VAR 0 5
92086: PUSH
92087: LD_INT 22
92089: PUSH
92090: LD_OWVAR 2
92094: PUSH
92095: EMPTY
92096: LIST
92097: LIST
92098: PUSH
92099: LD_INT 21
92101: PUSH
92102: LD_INT 1
92104: PUSH
92105: EMPTY
92106: LIST
92107: LIST
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: PPUSH
92113: CALL_OW 69
92117: ST_TO_ADDR
// if not tmp then
92118: LD_VAR 0 5
92122: NOT
92123: IFFALSE 92127
// exit ;
92125: GO 92281
// for i in tmp do
92127: LD_ADDR_VAR 0 1
92131: PUSH
92132: LD_VAR 0 5
92136: PUSH
92137: FOR_IN
92138: IFFALSE 92279
// begin d := rand ( 0 , 5 ) ;
92140: LD_ADDR_VAR 0 4
92144: PUSH
92145: LD_INT 0
92147: PPUSH
92148: LD_INT 5
92150: PPUSH
92151: CALL_OW 12
92155: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
92156: LD_ADDR_VAR 0 2
92160: PUSH
92161: LD_VAR 0 1
92165: PPUSH
92166: CALL_OW 250
92170: PPUSH
92171: LD_VAR 0 4
92175: PPUSH
92176: LD_INT 3
92178: PPUSH
92179: LD_INT 12
92181: PPUSH
92182: CALL_OW 12
92186: PPUSH
92187: CALL_OW 272
92191: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
92192: LD_ADDR_VAR 0 3
92196: PUSH
92197: LD_VAR 0 1
92201: PPUSH
92202: CALL_OW 251
92206: PPUSH
92207: LD_VAR 0 4
92211: PPUSH
92212: LD_INT 3
92214: PPUSH
92215: LD_INT 12
92217: PPUSH
92218: CALL_OW 12
92222: PPUSH
92223: CALL_OW 273
92227: ST_TO_ADDR
// if ValidHex ( x , y ) then
92228: LD_VAR 0 2
92232: PPUSH
92233: LD_VAR 0 3
92237: PPUSH
92238: CALL_OW 488
92242: IFFALSE 92277
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
92244: LD_VAR 0 1
92248: PPUSH
92249: LD_VAR 0 2
92253: PPUSH
92254: LD_VAR 0 3
92258: PPUSH
92259: LD_INT 3
92261: PPUSH
92262: LD_INT 6
92264: PPUSH
92265: CALL_OW 12
92269: PPUSH
92270: LD_INT 1
92272: PPUSH
92273: CALL_OW 483
// end ;
92277: GO 92137
92279: POP
92280: POP
// end ;
92281: PPOPN 5
92283: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
92284: LD_EXP 106
92288: PUSH
92289: LD_EXP 141
92293: AND
92294: IFFALSE 92388
92296: GO 92298
92298: DISABLE
92299: LD_INT 0
92301: PPUSH
92302: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
92303: LD_ADDR_VAR 0 2
92307: PUSH
92308: LD_INT 22
92310: PUSH
92311: LD_OWVAR 2
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: PUSH
92320: LD_INT 32
92322: PUSH
92323: LD_INT 1
92325: PUSH
92326: EMPTY
92327: LIST
92328: LIST
92329: PUSH
92330: LD_INT 21
92332: PUSH
92333: LD_INT 2
92335: PUSH
92336: EMPTY
92337: LIST
92338: LIST
92339: PUSH
92340: EMPTY
92341: LIST
92342: LIST
92343: LIST
92344: PPUSH
92345: CALL_OW 69
92349: ST_TO_ADDR
// if not tmp then
92350: LD_VAR 0 2
92354: NOT
92355: IFFALSE 92359
// exit ;
92357: GO 92388
// for i in tmp do
92359: LD_ADDR_VAR 0 1
92363: PUSH
92364: LD_VAR 0 2
92368: PUSH
92369: FOR_IN
92370: IFFALSE 92386
// SetFuel ( i , 0 ) ;
92372: LD_VAR 0 1
92376: PPUSH
92377: LD_INT 0
92379: PPUSH
92380: CALL_OW 240
92384: GO 92369
92386: POP
92387: POP
// end ;
92388: PPOPN 2
92390: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
92391: LD_EXP 106
92395: PUSH
92396: LD_EXP 142
92400: AND
92401: IFFALSE 92467
92403: GO 92405
92405: DISABLE
92406: LD_INT 0
92408: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
92409: LD_ADDR_VAR 0 1
92413: PUSH
92414: LD_INT 22
92416: PUSH
92417: LD_OWVAR 2
92421: PUSH
92422: EMPTY
92423: LIST
92424: LIST
92425: PUSH
92426: LD_INT 30
92428: PUSH
92429: LD_INT 29
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: PUSH
92436: EMPTY
92437: LIST
92438: LIST
92439: PPUSH
92440: CALL_OW 69
92444: ST_TO_ADDR
// if not tmp then
92445: LD_VAR 0 1
92449: NOT
92450: IFFALSE 92454
// exit ;
92452: GO 92467
// DestroyUnit ( tmp [ 1 ] ) ;
92454: LD_VAR 0 1
92458: PUSH
92459: LD_INT 1
92461: ARRAY
92462: PPUSH
92463: CALL_OW 65
// end ;
92467: PPOPN 1
92469: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
92470: LD_EXP 106
92474: PUSH
92475: LD_EXP 144
92479: AND
92480: IFFALSE 92609
92482: GO 92484
92484: DISABLE
92485: LD_INT 0
92487: PPUSH
// begin uc_side := 0 ;
92488: LD_ADDR_OWVAR 20
92492: PUSH
92493: LD_INT 0
92495: ST_TO_ADDR
// uc_nation := nation_arabian ;
92496: LD_ADDR_OWVAR 21
92500: PUSH
92501: LD_INT 2
92503: ST_TO_ADDR
// hc_gallery :=  ;
92504: LD_ADDR_OWVAR 33
92508: PUSH
92509: LD_STRING 
92511: ST_TO_ADDR
// hc_name :=  ;
92512: LD_ADDR_OWVAR 26
92516: PUSH
92517: LD_STRING 
92519: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
92520: LD_INT 1
92522: PPUSH
92523: LD_INT 11
92525: PPUSH
92526: LD_INT 10
92528: PPUSH
92529: CALL_OW 380
// un := CreateHuman ;
92533: LD_ADDR_VAR 0 1
92537: PUSH
92538: CALL_OW 44
92542: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92543: LD_VAR 0 1
92547: PPUSH
92548: LD_INT 1
92550: PPUSH
92551: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
92555: LD_INT 35
92557: PPUSH
92558: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
92562: LD_VAR 0 1
92566: PPUSH
92567: LD_INT 22
92569: PUSH
92570: LD_OWVAR 2
92574: PUSH
92575: EMPTY
92576: LIST
92577: LIST
92578: PPUSH
92579: CALL_OW 69
92583: PPUSH
92584: LD_VAR 0 1
92588: PPUSH
92589: CALL_OW 74
92593: PPUSH
92594: CALL_OW 115
// until IsDead ( un ) ;
92598: LD_VAR 0 1
92602: PPUSH
92603: CALL_OW 301
92607: IFFALSE 92555
// end ;
92609: PPOPN 1
92611: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
92612: LD_EXP 106
92616: PUSH
92617: LD_EXP 146
92621: AND
92622: IFFALSE 92634
92624: GO 92626
92626: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
92627: LD_STRING earthquake(getX(game), 0, 32)
92629: PPUSH
92630: CALL_OW 559
92634: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
92635: LD_EXP 106
92639: PUSH
92640: LD_EXP 147
92644: AND
92645: IFFALSE 92736
92647: GO 92649
92649: DISABLE
92650: LD_INT 0
92652: PPUSH
// begin enable ;
92653: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
92654: LD_ADDR_VAR 0 1
92658: PUSH
92659: LD_INT 22
92661: PUSH
92662: LD_OWVAR 2
92666: PUSH
92667: EMPTY
92668: LIST
92669: LIST
92670: PUSH
92671: LD_INT 21
92673: PUSH
92674: LD_INT 2
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: PUSH
92681: LD_INT 33
92683: PUSH
92684: LD_INT 3
92686: PUSH
92687: EMPTY
92688: LIST
92689: LIST
92690: PUSH
92691: EMPTY
92692: LIST
92693: LIST
92694: LIST
92695: PPUSH
92696: CALL_OW 69
92700: ST_TO_ADDR
// if not tmp then
92701: LD_VAR 0 1
92705: NOT
92706: IFFALSE 92710
// exit ;
92708: GO 92736
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
92710: LD_VAR 0 1
92714: PUSH
92715: LD_INT 1
92717: PPUSH
92718: LD_VAR 0 1
92722: PPUSH
92723: CALL_OW 12
92727: ARRAY
92728: PPUSH
92729: LD_INT 1
92731: PPUSH
92732: CALL_OW 234
// end ;
92736: PPOPN 1
92738: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
92739: LD_EXP 106
92743: PUSH
92744: LD_EXP 148
92748: AND
92749: IFFALSE 92890
92751: GO 92753
92753: DISABLE
92754: LD_INT 0
92756: PPUSH
92757: PPUSH
92758: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92759: LD_ADDR_VAR 0 3
92763: PUSH
92764: LD_INT 22
92766: PUSH
92767: LD_OWVAR 2
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: PUSH
92776: LD_INT 25
92778: PUSH
92779: LD_INT 1
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: PUSH
92786: EMPTY
92787: LIST
92788: LIST
92789: PPUSH
92790: CALL_OW 69
92794: ST_TO_ADDR
// if not tmp then
92795: LD_VAR 0 3
92799: NOT
92800: IFFALSE 92804
// exit ;
92802: GO 92890
// un := tmp [ rand ( 1 , tmp ) ] ;
92804: LD_ADDR_VAR 0 2
92808: PUSH
92809: LD_VAR 0 3
92813: PUSH
92814: LD_INT 1
92816: PPUSH
92817: LD_VAR 0 3
92821: PPUSH
92822: CALL_OW 12
92826: ARRAY
92827: ST_TO_ADDR
// if Crawls ( un ) then
92828: LD_VAR 0 2
92832: PPUSH
92833: CALL_OW 318
92837: IFFALSE 92848
// ComWalk ( un ) ;
92839: LD_VAR 0 2
92843: PPUSH
92844: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
92848: LD_VAR 0 2
92852: PPUSH
92853: LD_INT 9
92855: PPUSH
92856: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
92860: LD_INT 28
92862: PPUSH
92863: LD_OWVAR 2
92867: PPUSH
92868: LD_INT 2
92870: PPUSH
92871: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
92875: LD_INT 29
92877: PPUSH
92878: LD_OWVAR 2
92882: PPUSH
92883: LD_INT 2
92885: PPUSH
92886: CALL_OW 322
// end ;
92890: PPOPN 3
92892: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
92893: LD_EXP 106
92897: PUSH
92898: LD_EXP 149
92902: AND
92903: IFFALSE 93014
92905: GO 92907
92907: DISABLE
92908: LD_INT 0
92910: PPUSH
92911: PPUSH
92912: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92913: LD_ADDR_VAR 0 3
92917: PUSH
92918: LD_INT 22
92920: PUSH
92921: LD_OWVAR 2
92925: PUSH
92926: EMPTY
92927: LIST
92928: LIST
92929: PUSH
92930: LD_INT 25
92932: PUSH
92933: LD_INT 1
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: PUSH
92940: EMPTY
92941: LIST
92942: LIST
92943: PPUSH
92944: CALL_OW 69
92948: ST_TO_ADDR
// if not tmp then
92949: LD_VAR 0 3
92953: NOT
92954: IFFALSE 92958
// exit ;
92956: GO 93014
// un := tmp [ rand ( 1 , tmp ) ] ;
92958: LD_ADDR_VAR 0 2
92962: PUSH
92963: LD_VAR 0 3
92967: PUSH
92968: LD_INT 1
92970: PPUSH
92971: LD_VAR 0 3
92975: PPUSH
92976: CALL_OW 12
92980: ARRAY
92981: ST_TO_ADDR
// if Crawls ( un ) then
92982: LD_VAR 0 2
92986: PPUSH
92987: CALL_OW 318
92991: IFFALSE 93002
// ComWalk ( un ) ;
92993: LD_VAR 0 2
92997: PPUSH
92998: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93002: LD_VAR 0 2
93006: PPUSH
93007: LD_INT 8
93009: PPUSH
93010: CALL_OW 336
// end ;
93014: PPOPN 3
93016: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
93017: LD_EXP 106
93021: PUSH
93022: LD_EXP 150
93026: AND
93027: IFFALSE 93171
93029: GO 93031
93031: DISABLE
93032: LD_INT 0
93034: PPUSH
93035: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
93036: LD_ADDR_VAR 0 2
93040: PUSH
93041: LD_INT 22
93043: PUSH
93044: LD_OWVAR 2
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: LD_INT 21
93055: PUSH
93056: LD_INT 2
93058: PUSH
93059: EMPTY
93060: LIST
93061: LIST
93062: PUSH
93063: LD_INT 2
93065: PUSH
93066: LD_INT 34
93068: PUSH
93069: LD_INT 12
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: LD_INT 34
93078: PUSH
93079: LD_INT 51
93081: PUSH
93082: EMPTY
93083: LIST
93084: LIST
93085: PUSH
93086: LD_INT 34
93088: PUSH
93089: LD_INT 32
93091: PUSH
93092: EMPTY
93093: LIST
93094: LIST
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: LIST
93100: LIST
93101: PUSH
93102: EMPTY
93103: LIST
93104: LIST
93105: LIST
93106: PPUSH
93107: CALL_OW 69
93111: ST_TO_ADDR
// if not tmp then
93112: LD_VAR 0 2
93116: NOT
93117: IFFALSE 93121
// exit ;
93119: GO 93171
// for i in tmp do
93121: LD_ADDR_VAR 0 1
93125: PUSH
93126: LD_VAR 0 2
93130: PUSH
93131: FOR_IN
93132: IFFALSE 93169
// if GetCargo ( i , mat_artifact ) = 0 then
93134: LD_VAR 0 1
93138: PPUSH
93139: LD_INT 4
93141: PPUSH
93142: CALL_OW 289
93146: PUSH
93147: LD_INT 0
93149: EQUAL
93150: IFFALSE 93167
// SetCargo ( i , mat_siberit , 100 ) ;
93152: LD_VAR 0 1
93156: PPUSH
93157: LD_INT 3
93159: PPUSH
93160: LD_INT 100
93162: PPUSH
93163: CALL_OW 290
93167: GO 93131
93169: POP
93170: POP
// end ;
93171: PPOPN 2
93173: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
93174: LD_EXP 106
93178: PUSH
93179: LD_EXP 151
93183: AND
93184: IFFALSE 93337
93186: GO 93188
93188: DISABLE
93189: LD_INT 0
93191: PPUSH
93192: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
93193: LD_ADDR_VAR 0 2
93197: PUSH
93198: LD_INT 22
93200: PUSH
93201: LD_OWVAR 2
93205: PUSH
93206: EMPTY
93207: LIST
93208: LIST
93209: PPUSH
93210: CALL_OW 69
93214: ST_TO_ADDR
// if not tmp then
93215: LD_VAR 0 2
93219: NOT
93220: IFFALSE 93224
// exit ;
93222: GO 93337
// for i := 1 to 2 do
93224: LD_ADDR_VAR 0 1
93228: PUSH
93229: DOUBLE
93230: LD_INT 1
93232: DEC
93233: ST_TO_ADDR
93234: LD_INT 2
93236: PUSH
93237: FOR_TO
93238: IFFALSE 93335
// begin uc_side := your_side ;
93240: LD_ADDR_OWVAR 20
93244: PUSH
93245: LD_OWVAR 2
93249: ST_TO_ADDR
// uc_nation := nation_american ;
93250: LD_ADDR_OWVAR 21
93254: PUSH
93255: LD_INT 1
93257: ST_TO_ADDR
// vc_chassis := us_morphling ;
93258: LD_ADDR_OWVAR 37
93262: PUSH
93263: LD_INT 5
93265: ST_TO_ADDR
// vc_engine := engine_siberite ;
93266: LD_ADDR_OWVAR 39
93270: PUSH
93271: LD_INT 3
93273: ST_TO_ADDR
// vc_control := control_computer ;
93274: LD_ADDR_OWVAR 38
93278: PUSH
93279: LD_INT 3
93281: ST_TO_ADDR
// vc_weapon := us_double_laser ;
93282: LD_ADDR_OWVAR 40
93286: PUSH
93287: LD_INT 10
93289: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
93290: CALL_OW 45
93294: PPUSH
93295: LD_VAR 0 2
93299: PUSH
93300: LD_INT 1
93302: ARRAY
93303: PPUSH
93304: CALL_OW 250
93308: PPUSH
93309: LD_VAR 0 2
93313: PUSH
93314: LD_INT 1
93316: ARRAY
93317: PPUSH
93318: CALL_OW 251
93322: PPUSH
93323: LD_INT 12
93325: PPUSH
93326: LD_INT 1
93328: PPUSH
93329: CALL_OW 50
// end ;
93333: GO 93237
93335: POP
93336: POP
// end ;
93337: PPOPN 2
93339: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
93340: LD_EXP 106
93344: PUSH
93345: LD_EXP 152
93349: AND
93350: IFFALSE 93572
93352: GO 93354
93354: DISABLE
93355: LD_INT 0
93357: PPUSH
93358: PPUSH
93359: PPUSH
93360: PPUSH
93361: PPUSH
93362: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93363: LD_ADDR_VAR 0 6
93367: PUSH
93368: LD_INT 22
93370: PUSH
93371: LD_OWVAR 2
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PUSH
93380: LD_INT 21
93382: PUSH
93383: LD_INT 1
93385: PUSH
93386: EMPTY
93387: LIST
93388: LIST
93389: PUSH
93390: LD_INT 3
93392: PUSH
93393: LD_INT 23
93395: PUSH
93396: LD_INT 0
93398: PUSH
93399: EMPTY
93400: LIST
93401: LIST
93402: PUSH
93403: EMPTY
93404: LIST
93405: LIST
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: LIST
93411: PPUSH
93412: CALL_OW 69
93416: ST_TO_ADDR
// if not tmp then
93417: LD_VAR 0 6
93421: NOT
93422: IFFALSE 93426
// exit ;
93424: GO 93572
// s1 := rand ( 1 , 4 ) ;
93426: LD_ADDR_VAR 0 2
93430: PUSH
93431: LD_INT 1
93433: PPUSH
93434: LD_INT 4
93436: PPUSH
93437: CALL_OW 12
93441: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
93442: LD_ADDR_VAR 0 4
93446: PUSH
93447: LD_VAR 0 6
93451: PUSH
93452: LD_INT 1
93454: ARRAY
93455: PPUSH
93456: LD_VAR 0 2
93460: PPUSH
93461: CALL_OW 259
93465: ST_TO_ADDR
// if s1 = 1 then
93466: LD_VAR 0 2
93470: PUSH
93471: LD_INT 1
93473: EQUAL
93474: IFFALSE 93494
// s2 := rand ( 2 , 4 ) else
93476: LD_ADDR_VAR 0 3
93480: PUSH
93481: LD_INT 2
93483: PPUSH
93484: LD_INT 4
93486: PPUSH
93487: CALL_OW 12
93491: ST_TO_ADDR
93492: GO 93502
// s2 := 1 ;
93494: LD_ADDR_VAR 0 3
93498: PUSH
93499: LD_INT 1
93501: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
93502: LD_ADDR_VAR 0 5
93506: PUSH
93507: LD_VAR 0 6
93511: PUSH
93512: LD_INT 1
93514: ARRAY
93515: PPUSH
93516: LD_VAR 0 3
93520: PPUSH
93521: CALL_OW 259
93525: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
93526: LD_VAR 0 6
93530: PUSH
93531: LD_INT 1
93533: ARRAY
93534: PPUSH
93535: LD_VAR 0 2
93539: PPUSH
93540: LD_VAR 0 5
93544: PPUSH
93545: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
93549: LD_VAR 0 6
93553: PUSH
93554: LD_INT 1
93556: ARRAY
93557: PPUSH
93558: LD_VAR 0 3
93562: PPUSH
93563: LD_VAR 0 4
93567: PPUSH
93568: CALL_OW 237
// end ;
93572: PPOPN 6
93574: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
93575: LD_EXP 106
93579: PUSH
93580: LD_EXP 153
93584: AND
93585: IFFALSE 93664
93587: GO 93589
93589: DISABLE
93590: LD_INT 0
93592: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
93593: LD_ADDR_VAR 0 1
93597: PUSH
93598: LD_INT 22
93600: PUSH
93601: LD_OWVAR 2
93605: PUSH
93606: EMPTY
93607: LIST
93608: LIST
93609: PUSH
93610: LD_INT 30
93612: PUSH
93613: LD_INT 3
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: PUSH
93620: EMPTY
93621: LIST
93622: LIST
93623: PPUSH
93624: CALL_OW 69
93628: ST_TO_ADDR
// if not tmp then
93629: LD_VAR 0 1
93633: NOT
93634: IFFALSE 93638
// exit ;
93636: GO 93664
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
93638: LD_VAR 0 1
93642: PUSH
93643: LD_INT 1
93645: PPUSH
93646: LD_VAR 0 1
93650: PPUSH
93651: CALL_OW 12
93655: ARRAY
93656: PPUSH
93657: LD_INT 1
93659: PPUSH
93660: CALL_OW 234
// end ;
93664: PPOPN 1
93666: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
93667: LD_EXP 106
93671: PUSH
93672: LD_EXP 154
93676: AND
93677: IFFALSE 93789
93679: GO 93681
93681: DISABLE
93682: LD_INT 0
93684: PPUSH
93685: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
93686: LD_ADDR_VAR 0 2
93690: PUSH
93691: LD_INT 22
93693: PUSH
93694: LD_OWVAR 2
93698: PUSH
93699: EMPTY
93700: LIST
93701: LIST
93702: PUSH
93703: LD_INT 2
93705: PUSH
93706: LD_INT 30
93708: PUSH
93709: LD_INT 27
93711: PUSH
93712: EMPTY
93713: LIST
93714: LIST
93715: PUSH
93716: LD_INT 30
93718: PUSH
93719: LD_INT 26
93721: PUSH
93722: EMPTY
93723: LIST
93724: LIST
93725: PUSH
93726: LD_INT 30
93728: PUSH
93729: LD_INT 28
93731: PUSH
93732: EMPTY
93733: LIST
93734: LIST
93735: PUSH
93736: EMPTY
93737: LIST
93738: LIST
93739: LIST
93740: LIST
93741: PUSH
93742: EMPTY
93743: LIST
93744: LIST
93745: PPUSH
93746: CALL_OW 69
93750: ST_TO_ADDR
// if not tmp then
93751: LD_VAR 0 2
93755: NOT
93756: IFFALSE 93760
// exit ;
93758: GO 93789
// for i in tmp do
93760: LD_ADDR_VAR 0 1
93764: PUSH
93765: LD_VAR 0 2
93769: PUSH
93770: FOR_IN
93771: IFFALSE 93787
// SetLives ( i , 1 ) ;
93773: LD_VAR 0 1
93777: PPUSH
93778: LD_INT 1
93780: PPUSH
93781: CALL_OW 234
93785: GO 93770
93787: POP
93788: POP
// end ;
93789: PPOPN 2
93791: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
93792: LD_EXP 106
93796: PUSH
93797: LD_EXP 155
93801: AND
93802: IFFALSE 94076
93804: GO 93806
93806: DISABLE
93807: LD_INT 0
93809: PPUSH
93810: PPUSH
93811: PPUSH
// begin i := rand ( 1 , 7 ) ;
93812: LD_ADDR_VAR 0 1
93816: PUSH
93817: LD_INT 1
93819: PPUSH
93820: LD_INT 7
93822: PPUSH
93823: CALL_OW 12
93827: ST_TO_ADDR
// case i of 1 :
93828: LD_VAR 0 1
93832: PUSH
93833: LD_INT 1
93835: DOUBLE
93836: EQUAL
93837: IFTRUE 93841
93839: GO 93851
93841: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
93842: LD_STRING earthquake(getX(game), 0, 32)
93844: PPUSH
93845: CALL_OW 559
93849: GO 94076
93851: LD_INT 2
93853: DOUBLE
93854: EQUAL
93855: IFTRUE 93859
93857: GO 93873
93859: POP
// begin ToLua ( displayStucuk(); ) ;
93860: LD_STRING displayStucuk();
93862: PPUSH
93863: CALL_OW 559
// ResetFog ;
93867: CALL_OW 335
// end ; 3 :
93871: GO 94076
93873: LD_INT 3
93875: DOUBLE
93876: EQUAL
93877: IFTRUE 93881
93879: GO 93985
93881: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93882: LD_ADDR_VAR 0 2
93886: PUSH
93887: LD_INT 22
93889: PUSH
93890: LD_OWVAR 2
93894: PUSH
93895: EMPTY
93896: LIST
93897: LIST
93898: PUSH
93899: LD_INT 25
93901: PUSH
93902: LD_INT 1
93904: PUSH
93905: EMPTY
93906: LIST
93907: LIST
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: PPUSH
93913: CALL_OW 69
93917: ST_TO_ADDR
// if not tmp then
93918: LD_VAR 0 2
93922: NOT
93923: IFFALSE 93927
// exit ;
93925: GO 94076
// un := tmp [ rand ( 1 , tmp ) ] ;
93927: LD_ADDR_VAR 0 3
93931: PUSH
93932: LD_VAR 0 2
93936: PUSH
93937: LD_INT 1
93939: PPUSH
93940: LD_VAR 0 2
93944: PPUSH
93945: CALL_OW 12
93949: ARRAY
93950: ST_TO_ADDR
// if Crawls ( un ) then
93951: LD_VAR 0 3
93955: PPUSH
93956: CALL_OW 318
93960: IFFALSE 93971
// ComWalk ( un ) ;
93962: LD_VAR 0 3
93966: PPUSH
93967: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93971: LD_VAR 0 3
93975: PPUSH
93976: LD_INT 8
93978: PPUSH
93979: CALL_OW 336
// end ; 4 :
93983: GO 94076
93985: LD_INT 4
93987: DOUBLE
93988: EQUAL
93989: IFTRUE 93993
93991: GO 94054
93993: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93994: LD_ADDR_VAR 0 2
93998: PUSH
93999: LD_INT 22
94001: PUSH
94002: LD_OWVAR 2
94006: PUSH
94007: EMPTY
94008: LIST
94009: LIST
94010: PUSH
94011: LD_INT 30
94013: PUSH
94014: LD_INT 29
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PUSH
94021: EMPTY
94022: LIST
94023: LIST
94024: PPUSH
94025: CALL_OW 69
94029: ST_TO_ADDR
// if not tmp then
94030: LD_VAR 0 2
94034: NOT
94035: IFFALSE 94039
// exit ;
94037: GO 94076
// DestroyUnit ( tmp [ 1 ] ) ;
94039: LD_VAR 0 2
94043: PUSH
94044: LD_INT 1
94046: ARRAY
94047: PPUSH
94048: CALL_OW 65
// end ; 5 .. 7 :
94052: GO 94076
94054: LD_INT 5
94056: DOUBLE
94057: GREATEREQUAL
94058: IFFALSE 94066
94060: LD_INT 7
94062: DOUBLE
94063: LESSEQUAL
94064: IFTRUE 94068
94066: GO 94075
94068: POP
// StreamSibBomb ; end ;
94069: CALL 90356 0 0
94073: GO 94076
94075: POP
// end ;
94076: PPOPN 3
94078: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
94079: LD_EXP 106
94083: PUSH
94084: LD_EXP 156
94088: AND
94089: IFFALSE 94245
94091: GO 94093
94093: DISABLE
94094: LD_INT 0
94096: PPUSH
94097: PPUSH
94098: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
94099: LD_ADDR_VAR 0 2
94103: PUSH
94104: LD_INT 81
94106: PUSH
94107: LD_OWVAR 2
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: LD_INT 2
94118: PUSH
94119: LD_INT 21
94121: PUSH
94122: LD_INT 1
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: PUSH
94129: LD_INT 21
94131: PUSH
94132: LD_INT 2
94134: PUSH
94135: EMPTY
94136: LIST
94137: LIST
94138: PUSH
94139: EMPTY
94140: LIST
94141: LIST
94142: LIST
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PPUSH
94148: CALL_OW 69
94152: ST_TO_ADDR
// if not tmp then
94153: LD_VAR 0 2
94157: NOT
94158: IFFALSE 94162
// exit ;
94160: GO 94245
// p := 0 ;
94162: LD_ADDR_VAR 0 3
94166: PUSH
94167: LD_INT 0
94169: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
94170: LD_INT 35
94172: PPUSH
94173: CALL_OW 67
// p := p + 1 ;
94177: LD_ADDR_VAR 0 3
94181: PUSH
94182: LD_VAR 0 3
94186: PUSH
94187: LD_INT 1
94189: PLUS
94190: ST_TO_ADDR
// for i in tmp do
94191: LD_ADDR_VAR 0 1
94195: PUSH
94196: LD_VAR 0 2
94200: PUSH
94201: FOR_IN
94202: IFFALSE 94233
// if GetLives ( i ) < 1000 then
94204: LD_VAR 0 1
94208: PPUSH
94209: CALL_OW 256
94213: PUSH
94214: LD_INT 1000
94216: LESS
94217: IFFALSE 94231
// SetLives ( i , 1000 ) ;
94219: LD_VAR 0 1
94223: PPUSH
94224: LD_INT 1000
94226: PPUSH
94227: CALL_OW 234
94231: GO 94201
94233: POP
94234: POP
// until p > 20 ;
94235: LD_VAR 0 3
94239: PUSH
94240: LD_INT 20
94242: GREATER
94243: IFFALSE 94170
// end ;
94245: PPOPN 3
94247: END
// every 0 0$1 trigger StreamModeActive and sTime do
94248: LD_EXP 106
94252: PUSH
94253: LD_EXP 157
94257: AND
94258: IFFALSE 94293
94260: GO 94262
94262: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
94263: LD_INT 28
94265: PPUSH
94266: LD_OWVAR 2
94270: PPUSH
94271: LD_INT 2
94273: PPUSH
94274: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
94278: LD_INT 30
94280: PPUSH
94281: LD_OWVAR 2
94285: PPUSH
94286: LD_INT 2
94288: PPUSH
94289: CALL_OW 322
// end ;
94293: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
94294: LD_EXP 106
94298: PUSH
94299: LD_EXP 158
94303: AND
94304: IFFALSE 94425
94306: GO 94308
94308: DISABLE
94309: LD_INT 0
94311: PPUSH
94312: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94313: LD_ADDR_VAR 0 2
94317: PUSH
94318: LD_INT 22
94320: PUSH
94321: LD_OWVAR 2
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: LD_INT 21
94332: PUSH
94333: LD_INT 1
94335: PUSH
94336: EMPTY
94337: LIST
94338: LIST
94339: PUSH
94340: LD_INT 3
94342: PUSH
94343: LD_INT 23
94345: PUSH
94346: LD_INT 0
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: PUSH
94353: EMPTY
94354: LIST
94355: LIST
94356: PUSH
94357: EMPTY
94358: LIST
94359: LIST
94360: LIST
94361: PPUSH
94362: CALL_OW 69
94366: ST_TO_ADDR
// if not tmp then
94367: LD_VAR 0 2
94371: NOT
94372: IFFALSE 94376
// exit ;
94374: GO 94425
// for i in tmp do
94376: LD_ADDR_VAR 0 1
94380: PUSH
94381: LD_VAR 0 2
94385: PUSH
94386: FOR_IN
94387: IFFALSE 94423
// begin if Crawls ( i ) then
94389: LD_VAR 0 1
94393: PPUSH
94394: CALL_OW 318
94398: IFFALSE 94409
// ComWalk ( i ) ;
94400: LD_VAR 0 1
94404: PPUSH
94405: CALL_OW 138
// SetClass ( i , 2 ) ;
94409: LD_VAR 0 1
94413: PPUSH
94414: LD_INT 2
94416: PPUSH
94417: CALL_OW 336
// end ;
94421: GO 94386
94423: POP
94424: POP
// end ;
94425: PPOPN 2
94427: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
94428: LD_EXP 106
94432: PUSH
94433: LD_EXP 159
94437: AND
94438: IFFALSE 94719
94440: GO 94442
94442: DISABLE
94443: LD_INT 0
94445: PPUSH
94446: PPUSH
94447: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
94448: LD_OWVAR 2
94452: PPUSH
94453: LD_INT 9
94455: PPUSH
94456: LD_INT 1
94458: PPUSH
94459: LD_INT 1
94461: PPUSH
94462: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
94466: LD_INT 9
94468: PPUSH
94469: LD_OWVAR 2
94473: PPUSH
94474: CALL_OW 343
// uc_side := 9 ;
94478: LD_ADDR_OWVAR 20
94482: PUSH
94483: LD_INT 9
94485: ST_TO_ADDR
// uc_nation := 2 ;
94486: LD_ADDR_OWVAR 21
94490: PUSH
94491: LD_INT 2
94493: ST_TO_ADDR
// hc_name := Dark Warrior ;
94494: LD_ADDR_OWVAR 26
94498: PUSH
94499: LD_STRING Dark Warrior
94501: ST_TO_ADDR
// hc_gallery :=  ;
94502: LD_ADDR_OWVAR 33
94506: PUSH
94507: LD_STRING 
94509: ST_TO_ADDR
// hc_noskilllimit := true ;
94510: LD_ADDR_OWVAR 76
94514: PUSH
94515: LD_INT 1
94517: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
94518: LD_ADDR_OWVAR 31
94522: PUSH
94523: LD_INT 30
94525: PUSH
94526: LD_INT 30
94528: PUSH
94529: LD_INT 30
94531: PUSH
94532: LD_INT 30
94534: PUSH
94535: EMPTY
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: ST_TO_ADDR
// un := CreateHuman ;
94541: LD_ADDR_VAR 0 3
94545: PUSH
94546: CALL_OW 44
94550: ST_TO_ADDR
// hc_noskilllimit := false ;
94551: LD_ADDR_OWVAR 76
94555: PUSH
94556: LD_INT 0
94558: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94559: LD_VAR 0 3
94563: PPUSH
94564: LD_INT 1
94566: PPUSH
94567: CALL_OW 51
// p := 0 ;
94571: LD_ADDR_VAR 0 2
94575: PUSH
94576: LD_INT 0
94578: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
94579: LD_INT 35
94581: PPUSH
94582: CALL_OW 67
// p := p + 1 ;
94586: LD_ADDR_VAR 0 2
94590: PUSH
94591: LD_VAR 0 2
94595: PUSH
94596: LD_INT 1
94598: PLUS
94599: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
94600: LD_VAR 0 3
94604: PPUSH
94605: CALL_OW 256
94609: PUSH
94610: LD_INT 1000
94612: LESS
94613: IFFALSE 94627
// SetLives ( un , 1000 ) ;
94615: LD_VAR 0 3
94619: PPUSH
94620: LD_INT 1000
94622: PPUSH
94623: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
94627: LD_VAR 0 3
94631: PPUSH
94632: LD_INT 81
94634: PUSH
94635: LD_OWVAR 2
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PUSH
94644: LD_INT 91
94646: PUSH
94647: LD_VAR 0 3
94651: PUSH
94652: LD_INT 30
94654: PUSH
94655: EMPTY
94656: LIST
94657: LIST
94658: LIST
94659: PUSH
94660: EMPTY
94661: LIST
94662: LIST
94663: PPUSH
94664: CALL_OW 69
94668: PPUSH
94669: LD_VAR 0 3
94673: PPUSH
94674: CALL_OW 74
94678: PPUSH
94679: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
94683: LD_VAR 0 2
94687: PUSH
94688: LD_INT 60
94690: GREATER
94691: PUSH
94692: LD_VAR 0 3
94696: PPUSH
94697: CALL_OW 301
94701: OR
94702: IFFALSE 94579
// if un then
94704: LD_VAR 0 3
94708: IFFALSE 94719
// RemoveUnit ( un ) ;
94710: LD_VAR 0 3
94714: PPUSH
94715: CALL_OW 64
// end ; end_of_file
94719: PPOPN 3
94721: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
94722: LD_INT 0
94724: PPUSH
94725: PPUSH
94726: PPUSH
94727: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
94728: LD_VAR 0 1
94732: PPUSH
94733: CALL_OW 264
94737: PUSH
94738: LD_EXP 97
94742: EQUAL
94743: IFFALSE 94815
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
94745: LD_INT 68
94747: PPUSH
94748: LD_VAR 0 1
94752: PPUSH
94753: CALL_OW 255
94757: PPUSH
94758: CALL_OW 321
94762: PUSH
94763: LD_INT 2
94765: EQUAL
94766: IFFALSE 94778
// eff := 70 else
94768: LD_ADDR_VAR 0 4
94772: PUSH
94773: LD_INT 70
94775: ST_TO_ADDR
94776: GO 94786
// eff := 30 ;
94778: LD_ADDR_VAR 0 4
94782: PUSH
94783: LD_INT 30
94785: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
94786: LD_VAR 0 1
94790: PPUSH
94791: CALL_OW 250
94795: PPUSH
94796: LD_VAR 0 1
94800: PPUSH
94801: CALL_OW 251
94805: PPUSH
94806: LD_VAR 0 4
94810: PPUSH
94811: CALL_OW 495
// end ; end ;
94815: LD_VAR 0 2
94819: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
94820: LD_INT 0
94822: PPUSH
// end ;
94823: LD_VAR 0 4
94827: RET
// export function SOS_Command ( cmd ) ; begin
94828: LD_INT 0
94830: PPUSH
// end ;
94831: LD_VAR 0 2
94835: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
94836: LD_VAR 0 1
94840: PUSH
94841: LD_INT 255
94843: EQUAL
94844: PUSH
94845: LD_VAR 0 2
94849: PPUSH
94850: CALL_OW 264
94854: PUSH
94855: LD_INT 14
94857: PUSH
94858: LD_INT 53
94860: PUSH
94861: EMPTY
94862: LIST
94863: LIST
94864: IN
94865: AND
94866: PUSH
94867: LD_VAR 0 4
94871: PPUSH
94872: LD_VAR 0 5
94876: PPUSH
94877: CALL_OW 488
94881: AND
94882: IFFALSE 94906
// CutTreeXYR ( unit , x , y , 12 ) ;
94884: LD_VAR 0 2
94888: PPUSH
94889: LD_VAR 0 4
94893: PPUSH
94894: LD_VAR 0 5
94898: PPUSH
94899: LD_INT 12
94901: PPUSH
94902: CALL 94909 0 4
// end ;
94906: PPOPN 5
94908: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
94909: LD_INT 0
94911: PPUSH
94912: PPUSH
94913: PPUSH
94914: PPUSH
94915: PPUSH
94916: PPUSH
94917: PPUSH
94918: PPUSH
94919: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
94920: LD_VAR 0 1
94924: NOT
94925: PUSH
94926: LD_VAR 0 2
94930: PPUSH
94931: LD_VAR 0 3
94935: PPUSH
94936: CALL_OW 488
94940: NOT
94941: OR
94942: PUSH
94943: LD_VAR 0 4
94947: NOT
94948: OR
94949: IFFALSE 94953
// exit ;
94951: GO 95293
// list := [ ] ;
94953: LD_ADDR_VAR 0 13
94957: PUSH
94958: EMPTY
94959: ST_TO_ADDR
// if x - r < 0 then
94960: LD_VAR 0 2
94964: PUSH
94965: LD_VAR 0 4
94969: MINUS
94970: PUSH
94971: LD_INT 0
94973: LESS
94974: IFFALSE 94986
// min_x := 0 else
94976: LD_ADDR_VAR 0 7
94980: PUSH
94981: LD_INT 0
94983: ST_TO_ADDR
94984: GO 95002
// min_x := x - r ;
94986: LD_ADDR_VAR 0 7
94990: PUSH
94991: LD_VAR 0 2
94995: PUSH
94996: LD_VAR 0 4
95000: MINUS
95001: ST_TO_ADDR
// if y - r < 0 then
95002: LD_VAR 0 3
95006: PUSH
95007: LD_VAR 0 4
95011: MINUS
95012: PUSH
95013: LD_INT 0
95015: LESS
95016: IFFALSE 95028
// min_y := 0 else
95018: LD_ADDR_VAR 0 8
95022: PUSH
95023: LD_INT 0
95025: ST_TO_ADDR
95026: GO 95044
// min_y := y - r ;
95028: LD_ADDR_VAR 0 8
95032: PUSH
95033: LD_VAR 0 3
95037: PUSH
95038: LD_VAR 0 4
95042: MINUS
95043: ST_TO_ADDR
// max_x := x + r ;
95044: LD_ADDR_VAR 0 9
95048: PUSH
95049: LD_VAR 0 2
95053: PUSH
95054: LD_VAR 0 4
95058: PLUS
95059: ST_TO_ADDR
// max_y := y + r ;
95060: LD_ADDR_VAR 0 10
95064: PUSH
95065: LD_VAR 0 3
95069: PUSH
95070: LD_VAR 0 4
95074: PLUS
95075: ST_TO_ADDR
// for _x = min_x to max_x do
95076: LD_ADDR_VAR 0 11
95080: PUSH
95081: DOUBLE
95082: LD_VAR 0 7
95086: DEC
95087: ST_TO_ADDR
95088: LD_VAR 0 9
95092: PUSH
95093: FOR_TO
95094: IFFALSE 95211
// for _y = min_y to max_y do
95096: LD_ADDR_VAR 0 12
95100: PUSH
95101: DOUBLE
95102: LD_VAR 0 8
95106: DEC
95107: ST_TO_ADDR
95108: LD_VAR 0 10
95112: PUSH
95113: FOR_TO
95114: IFFALSE 95207
// begin if not ValidHex ( _x , _y ) then
95116: LD_VAR 0 11
95120: PPUSH
95121: LD_VAR 0 12
95125: PPUSH
95126: CALL_OW 488
95130: NOT
95131: IFFALSE 95135
// continue ;
95133: GO 95113
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
95135: LD_VAR 0 11
95139: PPUSH
95140: LD_VAR 0 12
95144: PPUSH
95145: CALL_OW 351
95149: PUSH
95150: LD_VAR 0 11
95154: PPUSH
95155: LD_VAR 0 12
95159: PPUSH
95160: CALL_OW 554
95164: AND
95165: IFFALSE 95205
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
95167: LD_ADDR_VAR 0 13
95171: PUSH
95172: LD_VAR 0 13
95176: PPUSH
95177: LD_VAR 0 13
95181: PUSH
95182: LD_INT 1
95184: PLUS
95185: PPUSH
95186: LD_VAR 0 11
95190: PUSH
95191: LD_VAR 0 12
95195: PUSH
95196: EMPTY
95197: LIST
95198: LIST
95199: PPUSH
95200: CALL_OW 2
95204: ST_TO_ADDR
// end ;
95205: GO 95113
95207: POP
95208: POP
95209: GO 95093
95211: POP
95212: POP
// if not list then
95213: LD_VAR 0 13
95217: NOT
95218: IFFALSE 95222
// exit ;
95220: GO 95293
// for i in list do
95222: LD_ADDR_VAR 0 6
95226: PUSH
95227: LD_VAR 0 13
95231: PUSH
95232: FOR_IN
95233: IFFALSE 95291
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
95235: LD_VAR 0 1
95239: PPUSH
95240: LD_STRING M
95242: PUSH
95243: LD_VAR 0 6
95247: PUSH
95248: LD_INT 1
95250: ARRAY
95251: PUSH
95252: LD_VAR 0 6
95256: PUSH
95257: LD_INT 2
95259: ARRAY
95260: PUSH
95261: LD_INT 0
95263: PUSH
95264: LD_INT 0
95266: PUSH
95267: LD_INT 0
95269: PUSH
95270: LD_INT 0
95272: PUSH
95273: EMPTY
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: PUSH
95282: EMPTY
95283: LIST
95284: PPUSH
95285: CALL_OW 447
95289: GO 95232
95291: POP
95292: POP
// end ; end_of_file
95293: LD_VAR 0 5
95297: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
95298: LD_INT 0
95300: PPUSH
95301: PPUSH
95302: PPUSH
95303: PPUSH
95304: PPUSH
95305: PPUSH
95306: PPUSH
95307: PPUSH
95308: PPUSH
95309: PPUSH
95310: PPUSH
95311: PPUSH
95312: PPUSH
95313: PPUSH
95314: PPUSH
95315: PPUSH
95316: PPUSH
95317: PPUSH
95318: PPUSH
95319: PPUSH
95320: PPUSH
95321: PPUSH
95322: PPUSH
95323: PPUSH
95324: PPUSH
95325: PPUSH
95326: PPUSH
95327: PPUSH
95328: PPUSH
95329: PPUSH
95330: PPUSH
95331: PPUSH
95332: PPUSH
95333: PPUSH
// if not list then
95334: LD_VAR 0 1
95338: NOT
95339: IFFALSE 95343
// exit ;
95341: GO 100002
// base := list [ 1 ] ;
95343: LD_ADDR_VAR 0 3
95347: PUSH
95348: LD_VAR 0 1
95352: PUSH
95353: LD_INT 1
95355: ARRAY
95356: ST_TO_ADDR
// group := list [ 2 ] ;
95357: LD_ADDR_VAR 0 4
95361: PUSH
95362: LD_VAR 0 1
95366: PUSH
95367: LD_INT 2
95369: ARRAY
95370: ST_TO_ADDR
// path := list [ 3 ] ;
95371: LD_ADDR_VAR 0 5
95375: PUSH
95376: LD_VAR 0 1
95380: PUSH
95381: LD_INT 3
95383: ARRAY
95384: ST_TO_ADDR
// flags := list [ 4 ] ;
95385: LD_ADDR_VAR 0 6
95389: PUSH
95390: LD_VAR 0 1
95394: PUSH
95395: LD_INT 4
95397: ARRAY
95398: ST_TO_ADDR
// mined := [ ] ;
95399: LD_ADDR_VAR 0 27
95403: PUSH
95404: EMPTY
95405: ST_TO_ADDR
// bombed := [ ] ;
95406: LD_ADDR_VAR 0 28
95410: PUSH
95411: EMPTY
95412: ST_TO_ADDR
// healers := [ ] ;
95413: LD_ADDR_VAR 0 31
95417: PUSH
95418: EMPTY
95419: ST_TO_ADDR
// to_heal := [ ] ;
95420: LD_ADDR_VAR 0 30
95424: PUSH
95425: EMPTY
95426: ST_TO_ADDR
// repairs := [ ] ;
95427: LD_ADDR_VAR 0 33
95431: PUSH
95432: EMPTY
95433: ST_TO_ADDR
// to_repair := [ ] ;
95434: LD_ADDR_VAR 0 32
95438: PUSH
95439: EMPTY
95440: ST_TO_ADDR
// if not group or not path then
95441: LD_VAR 0 4
95445: NOT
95446: PUSH
95447: LD_VAR 0 5
95451: NOT
95452: OR
95453: IFFALSE 95457
// exit ;
95455: GO 100002
// side := GetSide ( group [ 1 ] ) ;
95457: LD_ADDR_VAR 0 35
95461: PUSH
95462: LD_VAR 0 4
95466: PUSH
95467: LD_INT 1
95469: ARRAY
95470: PPUSH
95471: CALL_OW 255
95475: ST_TO_ADDR
// if flags then
95476: LD_VAR 0 6
95480: IFFALSE 95624
// begin f_ignore_area := flags [ 1 ] ;
95482: LD_ADDR_VAR 0 17
95486: PUSH
95487: LD_VAR 0 6
95491: PUSH
95492: LD_INT 1
95494: ARRAY
95495: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
95496: LD_ADDR_VAR 0 18
95500: PUSH
95501: LD_VAR 0 6
95505: PUSH
95506: LD_INT 2
95508: ARRAY
95509: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
95510: LD_ADDR_VAR 0 19
95514: PUSH
95515: LD_VAR 0 6
95519: PUSH
95520: LD_INT 3
95522: ARRAY
95523: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
95524: LD_ADDR_VAR 0 20
95528: PUSH
95529: LD_VAR 0 6
95533: PUSH
95534: LD_INT 4
95536: ARRAY
95537: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
95538: LD_ADDR_VAR 0 21
95542: PUSH
95543: LD_VAR 0 6
95547: PUSH
95548: LD_INT 5
95550: ARRAY
95551: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
95552: LD_ADDR_VAR 0 22
95556: PUSH
95557: LD_VAR 0 6
95561: PUSH
95562: LD_INT 6
95564: ARRAY
95565: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
95566: LD_ADDR_VAR 0 23
95570: PUSH
95571: LD_VAR 0 6
95575: PUSH
95576: LD_INT 7
95578: ARRAY
95579: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
95580: LD_ADDR_VAR 0 24
95584: PUSH
95585: LD_VAR 0 6
95589: PUSH
95590: LD_INT 8
95592: ARRAY
95593: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
95594: LD_ADDR_VAR 0 25
95598: PUSH
95599: LD_VAR 0 6
95603: PUSH
95604: LD_INT 9
95606: ARRAY
95607: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
95608: LD_ADDR_VAR 0 26
95612: PUSH
95613: LD_VAR 0 6
95617: PUSH
95618: LD_INT 10
95620: ARRAY
95621: ST_TO_ADDR
// end else
95622: GO 95704
// begin f_ignore_area := false ;
95624: LD_ADDR_VAR 0 17
95628: PUSH
95629: LD_INT 0
95631: ST_TO_ADDR
// f_capture := false ;
95632: LD_ADDR_VAR 0 18
95636: PUSH
95637: LD_INT 0
95639: ST_TO_ADDR
// f_ignore_civ := false ;
95640: LD_ADDR_VAR 0 19
95644: PUSH
95645: LD_INT 0
95647: ST_TO_ADDR
// f_murder := false ;
95648: LD_ADDR_VAR 0 20
95652: PUSH
95653: LD_INT 0
95655: ST_TO_ADDR
// f_mines := false ;
95656: LD_ADDR_VAR 0 21
95660: PUSH
95661: LD_INT 0
95663: ST_TO_ADDR
// f_repair := false ;
95664: LD_ADDR_VAR 0 22
95668: PUSH
95669: LD_INT 0
95671: ST_TO_ADDR
// f_heal := false ;
95672: LD_ADDR_VAR 0 23
95676: PUSH
95677: LD_INT 0
95679: ST_TO_ADDR
// f_spacetime := false ;
95680: LD_ADDR_VAR 0 24
95684: PUSH
95685: LD_INT 0
95687: ST_TO_ADDR
// f_attack_depot := false ;
95688: LD_ADDR_VAR 0 25
95692: PUSH
95693: LD_INT 0
95695: ST_TO_ADDR
// f_crawl := false ;
95696: LD_ADDR_VAR 0 26
95700: PUSH
95701: LD_INT 0
95703: ST_TO_ADDR
// end ; if f_heal then
95704: LD_VAR 0 23
95708: IFFALSE 95735
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
95710: LD_ADDR_VAR 0 31
95714: PUSH
95715: LD_VAR 0 4
95719: PPUSH
95720: LD_INT 25
95722: PUSH
95723: LD_INT 4
95725: PUSH
95726: EMPTY
95727: LIST
95728: LIST
95729: PPUSH
95730: CALL_OW 72
95734: ST_TO_ADDR
// if f_repair then
95735: LD_VAR 0 22
95739: IFFALSE 95766
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
95741: LD_ADDR_VAR 0 33
95745: PUSH
95746: LD_VAR 0 4
95750: PPUSH
95751: LD_INT 25
95753: PUSH
95754: LD_INT 3
95756: PUSH
95757: EMPTY
95758: LIST
95759: LIST
95760: PPUSH
95761: CALL_OW 72
95765: ST_TO_ADDR
// units_path := [ ] ;
95766: LD_ADDR_VAR 0 16
95770: PUSH
95771: EMPTY
95772: ST_TO_ADDR
// for i = 1 to group do
95773: LD_ADDR_VAR 0 7
95777: PUSH
95778: DOUBLE
95779: LD_INT 1
95781: DEC
95782: ST_TO_ADDR
95783: LD_VAR 0 4
95787: PUSH
95788: FOR_TO
95789: IFFALSE 95818
// units_path := Replace ( units_path , i , path ) ;
95791: LD_ADDR_VAR 0 16
95795: PUSH
95796: LD_VAR 0 16
95800: PPUSH
95801: LD_VAR 0 7
95805: PPUSH
95806: LD_VAR 0 5
95810: PPUSH
95811: CALL_OW 1
95815: ST_TO_ADDR
95816: GO 95788
95818: POP
95819: POP
// repeat for i = group downto 1 do
95820: LD_ADDR_VAR 0 7
95824: PUSH
95825: DOUBLE
95826: LD_VAR 0 4
95830: INC
95831: ST_TO_ADDR
95832: LD_INT 1
95834: PUSH
95835: FOR_DOWNTO
95836: IFFALSE 99958
// begin wait ( 5 ) ;
95838: LD_INT 5
95840: PPUSH
95841: CALL_OW 67
// tmp := [ ] ;
95845: LD_ADDR_VAR 0 14
95849: PUSH
95850: EMPTY
95851: ST_TO_ADDR
// attacking := false ;
95852: LD_ADDR_VAR 0 29
95856: PUSH
95857: LD_INT 0
95859: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
95860: LD_VAR 0 4
95864: PUSH
95865: LD_VAR 0 7
95869: ARRAY
95870: PPUSH
95871: CALL_OW 301
95875: PUSH
95876: LD_VAR 0 4
95880: PUSH
95881: LD_VAR 0 7
95885: ARRAY
95886: NOT
95887: OR
95888: IFFALSE 95997
// begin if GetType ( group [ i ] ) = unit_human then
95890: LD_VAR 0 4
95894: PUSH
95895: LD_VAR 0 7
95899: ARRAY
95900: PPUSH
95901: CALL_OW 247
95905: PUSH
95906: LD_INT 1
95908: EQUAL
95909: IFFALSE 95955
// begin to_heal := to_heal diff group [ i ] ;
95911: LD_ADDR_VAR 0 30
95915: PUSH
95916: LD_VAR 0 30
95920: PUSH
95921: LD_VAR 0 4
95925: PUSH
95926: LD_VAR 0 7
95930: ARRAY
95931: DIFF
95932: ST_TO_ADDR
// healers := healers diff group [ i ] ;
95933: LD_ADDR_VAR 0 31
95937: PUSH
95938: LD_VAR 0 31
95942: PUSH
95943: LD_VAR 0 4
95947: PUSH
95948: LD_VAR 0 7
95952: ARRAY
95953: DIFF
95954: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
95955: LD_ADDR_VAR 0 4
95959: PUSH
95960: LD_VAR 0 4
95964: PPUSH
95965: LD_VAR 0 7
95969: PPUSH
95970: CALL_OW 3
95974: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
95975: LD_ADDR_VAR 0 16
95979: PUSH
95980: LD_VAR 0 16
95984: PPUSH
95985: LD_VAR 0 7
95989: PPUSH
95990: CALL_OW 3
95994: ST_TO_ADDR
// continue ;
95995: GO 95835
// end ; if f_repair then
95997: LD_VAR 0 22
96001: IFFALSE 96490
// begin if GetType ( group [ i ] ) = unit_vehicle then
96003: LD_VAR 0 4
96007: PUSH
96008: LD_VAR 0 7
96012: ARRAY
96013: PPUSH
96014: CALL_OW 247
96018: PUSH
96019: LD_INT 2
96021: EQUAL
96022: IFFALSE 96212
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
96024: LD_VAR 0 4
96028: PUSH
96029: LD_VAR 0 7
96033: ARRAY
96034: PPUSH
96035: CALL_OW 256
96039: PUSH
96040: LD_INT 700
96042: LESS
96043: PUSH
96044: LD_VAR 0 4
96048: PUSH
96049: LD_VAR 0 7
96053: ARRAY
96054: PUSH
96055: LD_VAR 0 32
96059: IN
96060: NOT
96061: AND
96062: IFFALSE 96086
// to_repair := to_repair union group [ i ] ;
96064: LD_ADDR_VAR 0 32
96068: PUSH
96069: LD_VAR 0 32
96073: PUSH
96074: LD_VAR 0 4
96078: PUSH
96079: LD_VAR 0 7
96083: ARRAY
96084: UNION
96085: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
96086: LD_VAR 0 4
96090: PUSH
96091: LD_VAR 0 7
96095: ARRAY
96096: PPUSH
96097: CALL_OW 256
96101: PUSH
96102: LD_INT 1000
96104: EQUAL
96105: PUSH
96106: LD_VAR 0 4
96110: PUSH
96111: LD_VAR 0 7
96115: ARRAY
96116: PUSH
96117: LD_VAR 0 32
96121: IN
96122: AND
96123: IFFALSE 96147
// to_repair := to_repair diff group [ i ] ;
96125: LD_ADDR_VAR 0 32
96129: PUSH
96130: LD_VAR 0 32
96134: PUSH
96135: LD_VAR 0 4
96139: PUSH
96140: LD_VAR 0 7
96144: ARRAY
96145: DIFF
96146: ST_TO_ADDR
// if group [ i ] in to_repair then
96147: LD_VAR 0 4
96151: PUSH
96152: LD_VAR 0 7
96156: ARRAY
96157: PUSH
96158: LD_VAR 0 32
96162: IN
96163: IFFALSE 96210
// begin if not IsInArea ( group [ i ] , f_repair ) then
96165: LD_VAR 0 4
96169: PUSH
96170: LD_VAR 0 7
96174: ARRAY
96175: PPUSH
96176: LD_VAR 0 22
96180: PPUSH
96181: CALL_OW 308
96185: NOT
96186: IFFALSE 96208
// ComMoveToArea ( group [ i ] , f_repair ) ;
96188: LD_VAR 0 4
96192: PUSH
96193: LD_VAR 0 7
96197: ARRAY
96198: PPUSH
96199: LD_VAR 0 22
96203: PPUSH
96204: CALL_OW 113
// continue ;
96208: GO 95835
// end ; end else
96210: GO 96490
// if group [ i ] in repairs then
96212: LD_VAR 0 4
96216: PUSH
96217: LD_VAR 0 7
96221: ARRAY
96222: PUSH
96223: LD_VAR 0 33
96227: IN
96228: IFFALSE 96490
// begin if IsInUnit ( group [ i ] ) then
96230: LD_VAR 0 4
96234: PUSH
96235: LD_VAR 0 7
96239: ARRAY
96240: PPUSH
96241: CALL_OW 310
96245: IFFALSE 96313
// begin z := IsInUnit ( group [ i ] ) ;
96247: LD_ADDR_VAR 0 13
96251: PUSH
96252: LD_VAR 0 4
96256: PUSH
96257: LD_VAR 0 7
96261: ARRAY
96262: PPUSH
96263: CALL_OW 310
96267: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
96268: LD_VAR 0 13
96272: PUSH
96273: LD_VAR 0 32
96277: IN
96278: PUSH
96279: LD_VAR 0 13
96283: PPUSH
96284: LD_VAR 0 22
96288: PPUSH
96289: CALL_OW 308
96293: AND
96294: IFFALSE 96311
// ComExitVehicle ( group [ i ] ) ;
96296: LD_VAR 0 4
96300: PUSH
96301: LD_VAR 0 7
96305: ARRAY
96306: PPUSH
96307: CALL_OW 121
// end else
96311: GO 96490
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
96313: LD_ADDR_VAR 0 13
96317: PUSH
96318: LD_VAR 0 4
96322: PPUSH
96323: LD_INT 95
96325: PUSH
96326: LD_VAR 0 22
96330: PUSH
96331: EMPTY
96332: LIST
96333: LIST
96334: PUSH
96335: LD_INT 58
96337: PUSH
96338: EMPTY
96339: LIST
96340: PUSH
96341: EMPTY
96342: LIST
96343: LIST
96344: PPUSH
96345: CALL_OW 72
96349: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
96350: LD_VAR 0 4
96354: PUSH
96355: LD_VAR 0 7
96359: ARRAY
96360: PPUSH
96361: CALL_OW 314
96365: NOT
96366: IFFALSE 96488
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
96368: LD_ADDR_VAR 0 10
96372: PUSH
96373: LD_VAR 0 13
96377: PPUSH
96378: LD_VAR 0 4
96382: PUSH
96383: LD_VAR 0 7
96387: ARRAY
96388: PPUSH
96389: CALL_OW 74
96393: ST_TO_ADDR
// if not x then
96394: LD_VAR 0 10
96398: NOT
96399: IFFALSE 96403
// continue ;
96401: GO 95835
// if GetLives ( x ) < 1000 then
96403: LD_VAR 0 10
96407: PPUSH
96408: CALL_OW 256
96412: PUSH
96413: LD_INT 1000
96415: LESS
96416: IFFALSE 96440
// ComRepairVehicle ( group [ i ] , x ) else
96418: LD_VAR 0 4
96422: PUSH
96423: LD_VAR 0 7
96427: ARRAY
96428: PPUSH
96429: LD_VAR 0 10
96433: PPUSH
96434: CALL_OW 129
96438: GO 96488
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
96440: LD_VAR 0 23
96444: PUSH
96445: LD_VAR 0 4
96449: PUSH
96450: LD_VAR 0 7
96454: ARRAY
96455: PPUSH
96456: CALL_OW 256
96460: PUSH
96461: LD_INT 1000
96463: LESS
96464: AND
96465: NOT
96466: IFFALSE 96488
// ComEnterUnit ( group [ i ] , x ) ;
96468: LD_VAR 0 4
96472: PUSH
96473: LD_VAR 0 7
96477: ARRAY
96478: PPUSH
96479: LD_VAR 0 10
96483: PPUSH
96484: CALL_OW 120
// end ; continue ;
96488: GO 95835
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
96490: LD_VAR 0 23
96494: PUSH
96495: LD_VAR 0 4
96499: PUSH
96500: LD_VAR 0 7
96504: ARRAY
96505: PPUSH
96506: CALL_OW 247
96510: PUSH
96511: LD_INT 1
96513: EQUAL
96514: AND
96515: IFFALSE 96993
// begin if group [ i ] in healers then
96517: LD_VAR 0 4
96521: PUSH
96522: LD_VAR 0 7
96526: ARRAY
96527: PUSH
96528: LD_VAR 0 31
96532: IN
96533: IFFALSE 96806
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
96535: LD_VAR 0 4
96539: PUSH
96540: LD_VAR 0 7
96544: ARRAY
96545: PPUSH
96546: LD_VAR 0 23
96550: PPUSH
96551: CALL_OW 308
96555: NOT
96556: PUSH
96557: LD_VAR 0 4
96561: PUSH
96562: LD_VAR 0 7
96566: ARRAY
96567: PPUSH
96568: CALL_OW 314
96572: NOT
96573: AND
96574: IFFALSE 96598
// ComMoveToArea ( group [ i ] , f_heal ) else
96576: LD_VAR 0 4
96580: PUSH
96581: LD_VAR 0 7
96585: ARRAY
96586: PPUSH
96587: LD_VAR 0 23
96591: PPUSH
96592: CALL_OW 113
96596: GO 96804
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
96598: LD_VAR 0 4
96602: PUSH
96603: LD_VAR 0 7
96607: ARRAY
96608: PPUSH
96609: CALL 80739 0 1
96613: PPUSH
96614: CALL_OW 256
96618: PUSH
96619: LD_INT 1000
96621: EQUAL
96622: IFFALSE 96641
// ComStop ( group [ i ] ) else
96624: LD_VAR 0 4
96628: PUSH
96629: LD_VAR 0 7
96633: ARRAY
96634: PPUSH
96635: CALL_OW 141
96639: GO 96804
// if not HasTask ( group [ i ] ) and to_heal then
96641: LD_VAR 0 4
96645: PUSH
96646: LD_VAR 0 7
96650: ARRAY
96651: PPUSH
96652: CALL_OW 314
96656: NOT
96657: PUSH
96658: LD_VAR 0 30
96662: AND
96663: IFFALSE 96804
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
96665: LD_ADDR_VAR 0 13
96669: PUSH
96670: LD_VAR 0 30
96674: PPUSH
96675: LD_INT 3
96677: PUSH
96678: LD_INT 54
96680: PUSH
96681: EMPTY
96682: LIST
96683: PUSH
96684: EMPTY
96685: LIST
96686: LIST
96687: PPUSH
96688: CALL_OW 72
96692: PPUSH
96693: LD_VAR 0 4
96697: PUSH
96698: LD_VAR 0 7
96702: ARRAY
96703: PPUSH
96704: CALL_OW 74
96708: ST_TO_ADDR
// if z then
96709: LD_VAR 0 13
96713: IFFALSE 96804
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
96715: LD_INT 91
96717: PUSH
96718: LD_VAR 0 13
96722: PUSH
96723: LD_INT 10
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: LIST
96730: PUSH
96731: LD_INT 81
96733: PUSH
96734: LD_VAR 0 13
96738: PPUSH
96739: CALL_OW 255
96743: PUSH
96744: EMPTY
96745: LIST
96746: LIST
96747: PUSH
96748: EMPTY
96749: LIST
96750: LIST
96751: PPUSH
96752: CALL_OW 69
96756: PUSH
96757: LD_INT 0
96759: EQUAL
96760: IFFALSE 96784
// ComHeal ( group [ i ] , z ) else
96762: LD_VAR 0 4
96766: PUSH
96767: LD_VAR 0 7
96771: ARRAY
96772: PPUSH
96773: LD_VAR 0 13
96777: PPUSH
96778: CALL_OW 128
96782: GO 96804
// ComMoveToArea ( group [ i ] , f_heal ) ;
96784: LD_VAR 0 4
96788: PUSH
96789: LD_VAR 0 7
96793: ARRAY
96794: PPUSH
96795: LD_VAR 0 23
96799: PPUSH
96800: CALL_OW 113
// end ; continue ;
96804: GO 95835
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
96806: LD_VAR 0 4
96810: PUSH
96811: LD_VAR 0 7
96815: ARRAY
96816: PPUSH
96817: CALL_OW 256
96821: PUSH
96822: LD_INT 700
96824: LESS
96825: PUSH
96826: LD_VAR 0 4
96830: PUSH
96831: LD_VAR 0 7
96835: ARRAY
96836: PUSH
96837: LD_VAR 0 30
96841: IN
96842: NOT
96843: AND
96844: IFFALSE 96868
// to_heal := to_heal union group [ i ] ;
96846: LD_ADDR_VAR 0 30
96850: PUSH
96851: LD_VAR 0 30
96855: PUSH
96856: LD_VAR 0 4
96860: PUSH
96861: LD_VAR 0 7
96865: ARRAY
96866: UNION
96867: ST_TO_ADDR
// if group [ i ] in to_heal then
96868: LD_VAR 0 4
96872: PUSH
96873: LD_VAR 0 7
96877: ARRAY
96878: PUSH
96879: LD_VAR 0 30
96883: IN
96884: IFFALSE 96993
// begin if GetLives ( group [ i ] ) = 1000 then
96886: LD_VAR 0 4
96890: PUSH
96891: LD_VAR 0 7
96895: ARRAY
96896: PPUSH
96897: CALL_OW 256
96901: PUSH
96902: LD_INT 1000
96904: EQUAL
96905: IFFALSE 96931
// to_heal := to_heal diff group [ i ] else
96907: LD_ADDR_VAR 0 30
96911: PUSH
96912: LD_VAR 0 30
96916: PUSH
96917: LD_VAR 0 4
96921: PUSH
96922: LD_VAR 0 7
96926: ARRAY
96927: DIFF
96928: ST_TO_ADDR
96929: GO 96993
// begin if not IsInArea ( group [ i ] , to_heal ) then
96931: LD_VAR 0 4
96935: PUSH
96936: LD_VAR 0 7
96940: ARRAY
96941: PPUSH
96942: LD_VAR 0 30
96946: PPUSH
96947: CALL_OW 308
96951: NOT
96952: IFFALSE 96976
// ComMoveToArea ( group [ i ] , f_heal ) else
96954: LD_VAR 0 4
96958: PUSH
96959: LD_VAR 0 7
96963: ARRAY
96964: PPUSH
96965: LD_VAR 0 23
96969: PPUSH
96970: CALL_OW 113
96974: GO 96991
// ComHold ( group [ i ] ) ;
96976: LD_VAR 0 4
96980: PUSH
96981: LD_VAR 0 7
96985: ARRAY
96986: PPUSH
96987: CALL_OW 140
// continue ;
96991: GO 95835
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
96993: LD_VAR 0 4
96997: PUSH
96998: LD_VAR 0 7
97002: ARRAY
97003: PPUSH
97004: LD_INT 10
97006: PPUSH
97007: CALL 79159 0 2
97011: NOT
97012: PUSH
97013: LD_VAR 0 16
97017: PUSH
97018: LD_VAR 0 7
97022: ARRAY
97023: PUSH
97024: EMPTY
97025: EQUAL
97026: NOT
97027: AND
97028: IFFALSE 97294
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
97030: LD_VAR 0 4
97034: PUSH
97035: LD_VAR 0 7
97039: ARRAY
97040: PPUSH
97041: CALL_OW 262
97045: PUSH
97046: LD_INT 1
97048: PUSH
97049: LD_INT 2
97051: PUSH
97052: EMPTY
97053: LIST
97054: LIST
97055: IN
97056: IFFALSE 97097
// if GetFuel ( group [ i ] ) < 10 then
97058: LD_VAR 0 4
97062: PUSH
97063: LD_VAR 0 7
97067: ARRAY
97068: PPUSH
97069: CALL_OW 261
97073: PUSH
97074: LD_INT 10
97076: LESS
97077: IFFALSE 97097
// SetFuel ( group [ i ] , 12 ) ;
97079: LD_VAR 0 4
97083: PUSH
97084: LD_VAR 0 7
97088: ARRAY
97089: PPUSH
97090: LD_INT 12
97092: PPUSH
97093: CALL_OW 240
// if units_path [ i ] then
97097: LD_VAR 0 16
97101: PUSH
97102: LD_VAR 0 7
97106: ARRAY
97107: IFFALSE 97292
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
97109: LD_VAR 0 4
97113: PUSH
97114: LD_VAR 0 7
97118: ARRAY
97119: PPUSH
97120: LD_VAR 0 16
97124: PUSH
97125: LD_VAR 0 7
97129: ARRAY
97130: PUSH
97131: LD_INT 1
97133: ARRAY
97134: PUSH
97135: LD_INT 1
97137: ARRAY
97138: PPUSH
97139: LD_VAR 0 16
97143: PUSH
97144: LD_VAR 0 7
97148: ARRAY
97149: PUSH
97150: LD_INT 1
97152: ARRAY
97153: PUSH
97154: LD_INT 2
97156: ARRAY
97157: PPUSH
97158: CALL_OW 297
97162: PUSH
97163: LD_INT 6
97165: GREATER
97166: IFFALSE 97241
// begin if not HasTask ( group [ i ] ) then
97168: LD_VAR 0 4
97172: PUSH
97173: LD_VAR 0 7
97177: ARRAY
97178: PPUSH
97179: CALL_OW 314
97183: NOT
97184: IFFALSE 97239
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
97186: LD_VAR 0 4
97190: PUSH
97191: LD_VAR 0 7
97195: ARRAY
97196: PPUSH
97197: LD_VAR 0 16
97201: PUSH
97202: LD_VAR 0 7
97206: ARRAY
97207: PUSH
97208: LD_INT 1
97210: ARRAY
97211: PUSH
97212: LD_INT 1
97214: ARRAY
97215: PPUSH
97216: LD_VAR 0 16
97220: PUSH
97221: LD_VAR 0 7
97225: ARRAY
97226: PUSH
97227: LD_INT 1
97229: ARRAY
97230: PUSH
97231: LD_INT 2
97233: ARRAY
97234: PPUSH
97235: CALL_OW 114
// end else
97239: GO 97292
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
97241: LD_ADDR_VAR 0 15
97245: PUSH
97246: LD_VAR 0 16
97250: PUSH
97251: LD_VAR 0 7
97255: ARRAY
97256: PPUSH
97257: LD_INT 1
97259: PPUSH
97260: CALL_OW 3
97264: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
97265: LD_ADDR_VAR 0 16
97269: PUSH
97270: LD_VAR 0 16
97274: PPUSH
97275: LD_VAR 0 7
97279: PPUSH
97280: LD_VAR 0 15
97284: PPUSH
97285: CALL_OW 1
97289: ST_TO_ADDR
// continue ;
97290: GO 95835
// end ; end ; end else
97292: GO 99956
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
97294: LD_ADDR_VAR 0 14
97298: PUSH
97299: LD_INT 81
97301: PUSH
97302: LD_VAR 0 4
97306: PUSH
97307: LD_VAR 0 7
97311: ARRAY
97312: PPUSH
97313: CALL_OW 255
97317: PUSH
97318: EMPTY
97319: LIST
97320: LIST
97321: PPUSH
97322: CALL_OW 69
97326: ST_TO_ADDR
// if not tmp then
97327: LD_VAR 0 14
97331: NOT
97332: IFFALSE 97336
// continue ;
97334: GO 95835
// if f_ignore_area then
97336: LD_VAR 0 17
97340: IFFALSE 97428
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
97342: LD_ADDR_VAR 0 15
97346: PUSH
97347: LD_VAR 0 14
97351: PPUSH
97352: LD_INT 3
97354: PUSH
97355: LD_INT 92
97357: PUSH
97358: LD_VAR 0 17
97362: PUSH
97363: LD_INT 1
97365: ARRAY
97366: PUSH
97367: LD_VAR 0 17
97371: PUSH
97372: LD_INT 2
97374: ARRAY
97375: PUSH
97376: LD_VAR 0 17
97380: PUSH
97381: LD_INT 3
97383: ARRAY
97384: PUSH
97385: EMPTY
97386: LIST
97387: LIST
97388: LIST
97389: LIST
97390: PUSH
97391: EMPTY
97392: LIST
97393: LIST
97394: PPUSH
97395: CALL_OW 72
97399: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
97400: LD_VAR 0 14
97404: PUSH
97405: LD_VAR 0 15
97409: DIFF
97410: IFFALSE 97428
// tmp := tmp diff tmp2 ;
97412: LD_ADDR_VAR 0 14
97416: PUSH
97417: LD_VAR 0 14
97421: PUSH
97422: LD_VAR 0 15
97426: DIFF
97427: ST_TO_ADDR
// end ; if not f_murder then
97428: LD_VAR 0 20
97432: NOT
97433: IFFALSE 97491
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
97435: LD_ADDR_VAR 0 15
97439: PUSH
97440: LD_VAR 0 14
97444: PPUSH
97445: LD_INT 3
97447: PUSH
97448: LD_INT 50
97450: PUSH
97451: EMPTY
97452: LIST
97453: PUSH
97454: EMPTY
97455: LIST
97456: LIST
97457: PPUSH
97458: CALL_OW 72
97462: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
97463: LD_VAR 0 14
97467: PUSH
97468: LD_VAR 0 15
97472: DIFF
97473: IFFALSE 97491
// tmp := tmp diff tmp2 ;
97475: LD_ADDR_VAR 0 14
97479: PUSH
97480: LD_VAR 0 14
97484: PUSH
97485: LD_VAR 0 15
97489: DIFF
97490: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
97491: LD_ADDR_VAR 0 14
97495: PUSH
97496: LD_VAR 0 4
97500: PUSH
97501: LD_VAR 0 7
97505: ARRAY
97506: PPUSH
97507: LD_VAR 0 14
97511: PPUSH
97512: LD_INT 1
97514: PPUSH
97515: LD_INT 1
97517: PPUSH
97518: CALL 52802 0 4
97522: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
97523: LD_VAR 0 4
97527: PUSH
97528: LD_VAR 0 7
97532: ARRAY
97533: PPUSH
97534: CALL_OW 257
97538: PUSH
97539: LD_INT 1
97541: EQUAL
97542: IFFALSE 97990
// begin if WantPlant ( group [ i ] ) then
97544: LD_VAR 0 4
97548: PUSH
97549: LD_VAR 0 7
97553: ARRAY
97554: PPUSH
97555: CALL 52303 0 1
97559: IFFALSE 97563
// continue ;
97561: GO 95835
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
97563: LD_VAR 0 18
97567: PUSH
97568: LD_VAR 0 4
97572: PUSH
97573: LD_VAR 0 7
97577: ARRAY
97578: PPUSH
97579: CALL_OW 310
97583: NOT
97584: AND
97585: PUSH
97586: LD_VAR 0 14
97590: PUSH
97591: LD_INT 1
97593: ARRAY
97594: PUSH
97595: LD_VAR 0 14
97599: PPUSH
97600: LD_INT 21
97602: PUSH
97603: LD_INT 2
97605: PUSH
97606: EMPTY
97607: LIST
97608: LIST
97609: PUSH
97610: LD_INT 58
97612: PUSH
97613: EMPTY
97614: LIST
97615: PUSH
97616: EMPTY
97617: LIST
97618: LIST
97619: PPUSH
97620: CALL_OW 72
97624: IN
97625: AND
97626: IFFALSE 97662
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
97628: LD_VAR 0 4
97632: PUSH
97633: LD_VAR 0 7
97637: ARRAY
97638: PPUSH
97639: LD_VAR 0 14
97643: PUSH
97644: LD_INT 1
97646: ARRAY
97647: PPUSH
97648: CALL_OW 120
// attacking := true ;
97652: LD_ADDR_VAR 0 29
97656: PUSH
97657: LD_INT 1
97659: ST_TO_ADDR
// continue ;
97660: GO 95835
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
97662: LD_VAR 0 26
97666: PUSH
97667: LD_VAR 0 4
97671: PUSH
97672: LD_VAR 0 7
97676: ARRAY
97677: PPUSH
97678: CALL_OW 257
97682: PUSH
97683: LD_INT 1
97685: EQUAL
97686: AND
97687: PUSH
97688: LD_VAR 0 4
97692: PUSH
97693: LD_VAR 0 7
97697: ARRAY
97698: PPUSH
97699: CALL_OW 256
97703: PUSH
97704: LD_INT 800
97706: LESS
97707: AND
97708: PUSH
97709: LD_VAR 0 4
97713: PUSH
97714: LD_VAR 0 7
97718: ARRAY
97719: PPUSH
97720: CALL_OW 318
97724: NOT
97725: AND
97726: IFFALSE 97743
// ComCrawl ( group [ i ] ) ;
97728: LD_VAR 0 4
97732: PUSH
97733: LD_VAR 0 7
97737: ARRAY
97738: PPUSH
97739: CALL_OW 137
// if f_mines then
97743: LD_VAR 0 21
97747: IFFALSE 97990
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
97749: LD_VAR 0 14
97753: PUSH
97754: LD_INT 1
97756: ARRAY
97757: PPUSH
97758: CALL_OW 247
97762: PUSH
97763: LD_INT 3
97765: EQUAL
97766: PUSH
97767: LD_VAR 0 14
97771: PUSH
97772: LD_INT 1
97774: ARRAY
97775: PUSH
97776: LD_VAR 0 27
97780: IN
97781: NOT
97782: AND
97783: IFFALSE 97990
// begin x := GetX ( tmp [ 1 ] ) ;
97785: LD_ADDR_VAR 0 10
97789: PUSH
97790: LD_VAR 0 14
97794: PUSH
97795: LD_INT 1
97797: ARRAY
97798: PPUSH
97799: CALL_OW 250
97803: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
97804: LD_ADDR_VAR 0 11
97808: PUSH
97809: LD_VAR 0 14
97813: PUSH
97814: LD_INT 1
97816: ARRAY
97817: PPUSH
97818: CALL_OW 251
97822: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
97823: LD_ADDR_VAR 0 12
97827: PUSH
97828: LD_VAR 0 4
97832: PUSH
97833: LD_VAR 0 7
97837: ARRAY
97838: PPUSH
97839: CALL 79244 0 1
97843: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
97844: LD_VAR 0 4
97848: PUSH
97849: LD_VAR 0 7
97853: ARRAY
97854: PPUSH
97855: LD_VAR 0 10
97859: PPUSH
97860: LD_VAR 0 11
97864: PPUSH
97865: LD_VAR 0 14
97869: PUSH
97870: LD_INT 1
97872: ARRAY
97873: PPUSH
97874: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
97878: LD_VAR 0 4
97882: PUSH
97883: LD_VAR 0 7
97887: ARRAY
97888: PPUSH
97889: LD_VAR 0 10
97893: PPUSH
97894: LD_VAR 0 12
97898: PPUSH
97899: LD_INT 7
97901: PPUSH
97902: CALL_OW 272
97906: PPUSH
97907: LD_VAR 0 11
97911: PPUSH
97912: LD_VAR 0 12
97916: PPUSH
97917: LD_INT 7
97919: PPUSH
97920: CALL_OW 273
97924: PPUSH
97925: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
97929: LD_VAR 0 4
97933: PUSH
97934: LD_VAR 0 7
97938: ARRAY
97939: PPUSH
97940: LD_INT 71
97942: PPUSH
97943: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
97947: LD_ADDR_VAR 0 27
97951: PUSH
97952: LD_VAR 0 27
97956: PPUSH
97957: LD_VAR 0 27
97961: PUSH
97962: LD_INT 1
97964: PLUS
97965: PPUSH
97966: LD_VAR 0 14
97970: PUSH
97971: LD_INT 1
97973: ARRAY
97974: PPUSH
97975: CALL_OW 1
97979: ST_TO_ADDR
// attacking := true ;
97980: LD_ADDR_VAR 0 29
97984: PUSH
97985: LD_INT 1
97987: ST_TO_ADDR
// continue ;
97988: GO 95835
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
97990: LD_VAR 0 4
97994: PUSH
97995: LD_VAR 0 7
97999: ARRAY
98000: PPUSH
98001: CALL_OW 257
98005: PUSH
98006: LD_INT 17
98008: EQUAL
98009: PUSH
98010: LD_VAR 0 4
98014: PUSH
98015: LD_VAR 0 7
98019: ARRAY
98020: PPUSH
98021: CALL_OW 110
98025: PUSH
98026: LD_INT 71
98028: EQUAL
98029: NOT
98030: AND
98031: IFFALSE 98177
// begin attacking := false ;
98033: LD_ADDR_VAR 0 29
98037: PUSH
98038: LD_INT 0
98040: ST_TO_ADDR
// k := 5 ;
98041: LD_ADDR_VAR 0 9
98045: PUSH
98046: LD_INT 5
98048: ST_TO_ADDR
// if tmp < k then
98049: LD_VAR 0 14
98053: PUSH
98054: LD_VAR 0 9
98058: LESS
98059: IFFALSE 98071
// k := tmp ;
98061: LD_ADDR_VAR 0 9
98065: PUSH
98066: LD_VAR 0 14
98070: ST_TO_ADDR
// for j = 1 to k do
98071: LD_ADDR_VAR 0 8
98075: PUSH
98076: DOUBLE
98077: LD_INT 1
98079: DEC
98080: ST_TO_ADDR
98081: LD_VAR 0 9
98085: PUSH
98086: FOR_TO
98087: IFFALSE 98175
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
98089: LD_VAR 0 14
98093: PUSH
98094: LD_VAR 0 8
98098: ARRAY
98099: PUSH
98100: LD_VAR 0 14
98104: PPUSH
98105: LD_INT 58
98107: PUSH
98108: EMPTY
98109: LIST
98110: PPUSH
98111: CALL_OW 72
98115: IN
98116: NOT
98117: IFFALSE 98173
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
98119: LD_VAR 0 4
98123: PUSH
98124: LD_VAR 0 7
98128: ARRAY
98129: PPUSH
98130: LD_VAR 0 14
98134: PUSH
98135: LD_VAR 0 8
98139: ARRAY
98140: PPUSH
98141: CALL_OW 115
// attacking := true ;
98145: LD_ADDR_VAR 0 29
98149: PUSH
98150: LD_INT 1
98152: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
98153: LD_VAR 0 4
98157: PUSH
98158: LD_VAR 0 7
98162: ARRAY
98163: PPUSH
98164: LD_INT 71
98166: PPUSH
98167: CALL_OW 109
// continue ;
98171: GO 98086
// end ; end ;
98173: GO 98086
98175: POP
98176: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
98177: LD_VAR 0 4
98181: PUSH
98182: LD_VAR 0 7
98186: ARRAY
98187: PPUSH
98188: CALL_OW 257
98192: PUSH
98193: LD_INT 8
98195: EQUAL
98196: PUSH
98197: LD_VAR 0 4
98201: PUSH
98202: LD_VAR 0 7
98206: ARRAY
98207: PPUSH
98208: CALL_OW 264
98212: PUSH
98213: LD_INT 28
98215: PUSH
98216: LD_INT 45
98218: PUSH
98219: LD_INT 7
98221: PUSH
98222: LD_INT 47
98224: PUSH
98225: EMPTY
98226: LIST
98227: LIST
98228: LIST
98229: LIST
98230: IN
98231: OR
98232: IFFALSE 98488
// begin attacking := false ;
98234: LD_ADDR_VAR 0 29
98238: PUSH
98239: LD_INT 0
98241: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
98242: LD_VAR 0 14
98246: PUSH
98247: LD_INT 1
98249: ARRAY
98250: PPUSH
98251: CALL_OW 266
98255: PUSH
98256: LD_INT 32
98258: PUSH
98259: LD_INT 31
98261: PUSH
98262: LD_INT 33
98264: PUSH
98265: LD_INT 4
98267: PUSH
98268: LD_INT 5
98270: PUSH
98271: EMPTY
98272: LIST
98273: LIST
98274: LIST
98275: LIST
98276: LIST
98277: IN
98278: IFFALSE 98464
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
98280: LD_ADDR_VAR 0 9
98284: PUSH
98285: LD_VAR 0 14
98289: PUSH
98290: LD_INT 1
98292: ARRAY
98293: PPUSH
98294: CALL_OW 266
98298: PPUSH
98299: LD_VAR 0 14
98303: PUSH
98304: LD_INT 1
98306: ARRAY
98307: PPUSH
98308: CALL_OW 250
98312: PPUSH
98313: LD_VAR 0 14
98317: PUSH
98318: LD_INT 1
98320: ARRAY
98321: PPUSH
98322: CALL_OW 251
98326: PPUSH
98327: LD_VAR 0 14
98331: PUSH
98332: LD_INT 1
98334: ARRAY
98335: PPUSH
98336: CALL_OW 254
98340: PPUSH
98341: LD_VAR 0 14
98345: PUSH
98346: LD_INT 1
98348: ARRAY
98349: PPUSH
98350: CALL_OW 248
98354: PPUSH
98355: LD_INT 0
98357: PPUSH
98358: CALL 60614 0 6
98362: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
98363: LD_ADDR_VAR 0 8
98367: PUSH
98368: LD_VAR 0 4
98372: PUSH
98373: LD_VAR 0 7
98377: ARRAY
98378: PPUSH
98379: LD_VAR 0 9
98383: PPUSH
98384: CALL 79284 0 2
98388: ST_TO_ADDR
// if j then
98389: LD_VAR 0 8
98393: IFFALSE 98462
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
98395: LD_VAR 0 8
98399: PUSH
98400: LD_INT 1
98402: ARRAY
98403: PPUSH
98404: LD_VAR 0 8
98408: PUSH
98409: LD_INT 2
98411: ARRAY
98412: PPUSH
98413: CALL_OW 488
98417: IFFALSE 98462
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
98419: LD_VAR 0 4
98423: PUSH
98424: LD_VAR 0 7
98428: ARRAY
98429: PPUSH
98430: LD_VAR 0 8
98434: PUSH
98435: LD_INT 1
98437: ARRAY
98438: PPUSH
98439: LD_VAR 0 8
98443: PUSH
98444: LD_INT 2
98446: ARRAY
98447: PPUSH
98448: CALL_OW 116
// attacking := true ;
98452: LD_ADDR_VAR 0 29
98456: PUSH
98457: LD_INT 1
98459: ST_TO_ADDR
// continue ;
98460: GO 95835
// end ; end else
98462: GO 98488
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
98464: LD_VAR 0 4
98468: PUSH
98469: LD_VAR 0 7
98473: ARRAY
98474: PPUSH
98475: LD_VAR 0 14
98479: PUSH
98480: LD_INT 1
98482: ARRAY
98483: PPUSH
98484: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
98488: LD_VAR 0 4
98492: PUSH
98493: LD_VAR 0 7
98497: ARRAY
98498: PPUSH
98499: CALL_OW 265
98503: PUSH
98504: LD_INT 11
98506: EQUAL
98507: IFFALSE 98785
// begin k := 10 ;
98509: LD_ADDR_VAR 0 9
98513: PUSH
98514: LD_INT 10
98516: ST_TO_ADDR
// x := 0 ;
98517: LD_ADDR_VAR 0 10
98521: PUSH
98522: LD_INT 0
98524: ST_TO_ADDR
// if tmp < k then
98525: LD_VAR 0 14
98529: PUSH
98530: LD_VAR 0 9
98534: LESS
98535: IFFALSE 98547
// k := tmp ;
98537: LD_ADDR_VAR 0 9
98541: PUSH
98542: LD_VAR 0 14
98546: ST_TO_ADDR
// for j = k downto 1 do
98547: LD_ADDR_VAR 0 8
98551: PUSH
98552: DOUBLE
98553: LD_VAR 0 9
98557: INC
98558: ST_TO_ADDR
98559: LD_INT 1
98561: PUSH
98562: FOR_DOWNTO
98563: IFFALSE 98638
// begin if GetType ( tmp [ j ] ) = unit_human then
98565: LD_VAR 0 14
98569: PUSH
98570: LD_VAR 0 8
98574: ARRAY
98575: PPUSH
98576: CALL_OW 247
98580: PUSH
98581: LD_INT 1
98583: EQUAL
98584: IFFALSE 98636
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
98586: LD_VAR 0 4
98590: PUSH
98591: LD_VAR 0 7
98595: ARRAY
98596: PPUSH
98597: LD_VAR 0 14
98601: PUSH
98602: LD_VAR 0 8
98606: ARRAY
98607: PPUSH
98608: CALL 79555 0 2
// x := tmp [ j ] ;
98612: LD_ADDR_VAR 0 10
98616: PUSH
98617: LD_VAR 0 14
98621: PUSH
98622: LD_VAR 0 8
98626: ARRAY
98627: ST_TO_ADDR
// attacking := true ;
98628: LD_ADDR_VAR 0 29
98632: PUSH
98633: LD_INT 1
98635: ST_TO_ADDR
// end ; end ;
98636: GO 98562
98638: POP
98639: POP
// if not x then
98640: LD_VAR 0 10
98644: NOT
98645: IFFALSE 98785
// begin attacking := true ;
98647: LD_ADDR_VAR 0 29
98651: PUSH
98652: LD_INT 1
98654: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
98655: LD_VAR 0 4
98659: PUSH
98660: LD_VAR 0 7
98664: ARRAY
98665: PPUSH
98666: CALL_OW 250
98670: PPUSH
98671: LD_VAR 0 4
98675: PUSH
98676: LD_VAR 0 7
98680: ARRAY
98681: PPUSH
98682: CALL_OW 251
98686: PPUSH
98687: CALL_OW 546
98691: PUSH
98692: LD_INT 2
98694: ARRAY
98695: PUSH
98696: LD_VAR 0 14
98700: PUSH
98701: LD_INT 1
98703: ARRAY
98704: PPUSH
98705: CALL_OW 250
98709: PPUSH
98710: LD_VAR 0 14
98714: PUSH
98715: LD_INT 1
98717: ARRAY
98718: PPUSH
98719: CALL_OW 251
98723: PPUSH
98724: CALL_OW 546
98728: PUSH
98729: LD_INT 2
98731: ARRAY
98732: EQUAL
98733: IFFALSE 98761
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
98735: LD_VAR 0 4
98739: PUSH
98740: LD_VAR 0 7
98744: ARRAY
98745: PPUSH
98746: LD_VAR 0 14
98750: PUSH
98751: LD_INT 1
98753: ARRAY
98754: PPUSH
98755: CALL 79555 0 2
98759: GO 98785
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
98761: LD_VAR 0 4
98765: PUSH
98766: LD_VAR 0 7
98770: ARRAY
98771: PPUSH
98772: LD_VAR 0 14
98776: PUSH
98777: LD_INT 1
98779: ARRAY
98780: PPUSH
98781: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
98785: LD_VAR 0 4
98789: PUSH
98790: LD_VAR 0 7
98794: ARRAY
98795: PPUSH
98796: CALL_OW 264
98800: PUSH
98801: LD_INT 29
98803: EQUAL
98804: IFFALSE 99170
// begin if WantsToAttack ( group [ i ] ) in bombed then
98806: LD_VAR 0 4
98810: PUSH
98811: LD_VAR 0 7
98815: ARRAY
98816: PPUSH
98817: CALL_OW 319
98821: PUSH
98822: LD_VAR 0 28
98826: IN
98827: IFFALSE 98831
// continue ;
98829: GO 95835
// k := 8 ;
98831: LD_ADDR_VAR 0 9
98835: PUSH
98836: LD_INT 8
98838: ST_TO_ADDR
// x := 0 ;
98839: LD_ADDR_VAR 0 10
98843: PUSH
98844: LD_INT 0
98846: ST_TO_ADDR
// if tmp < k then
98847: LD_VAR 0 14
98851: PUSH
98852: LD_VAR 0 9
98856: LESS
98857: IFFALSE 98869
// k := tmp ;
98859: LD_ADDR_VAR 0 9
98863: PUSH
98864: LD_VAR 0 14
98868: ST_TO_ADDR
// for j = 1 to k do
98869: LD_ADDR_VAR 0 8
98873: PUSH
98874: DOUBLE
98875: LD_INT 1
98877: DEC
98878: ST_TO_ADDR
98879: LD_VAR 0 9
98883: PUSH
98884: FOR_TO
98885: IFFALSE 99017
// begin if GetType ( tmp [ j ] ) = unit_building then
98887: LD_VAR 0 14
98891: PUSH
98892: LD_VAR 0 8
98896: ARRAY
98897: PPUSH
98898: CALL_OW 247
98902: PUSH
98903: LD_INT 3
98905: EQUAL
98906: IFFALSE 99015
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
98908: LD_VAR 0 14
98912: PUSH
98913: LD_VAR 0 8
98917: ARRAY
98918: PUSH
98919: LD_VAR 0 28
98923: IN
98924: NOT
98925: PUSH
98926: LD_VAR 0 14
98930: PUSH
98931: LD_VAR 0 8
98935: ARRAY
98936: PPUSH
98937: CALL_OW 313
98941: AND
98942: IFFALSE 99015
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
98944: LD_VAR 0 4
98948: PUSH
98949: LD_VAR 0 7
98953: ARRAY
98954: PPUSH
98955: LD_VAR 0 14
98959: PUSH
98960: LD_VAR 0 8
98964: ARRAY
98965: PPUSH
98966: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
98970: LD_ADDR_VAR 0 28
98974: PUSH
98975: LD_VAR 0 28
98979: PPUSH
98980: LD_VAR 0 28
98984: PUSH
98985: LD_INT 1
98987: PLUS
98988: PPUSH
98989: LD_VAR 0 14
98993: PUSH
98994: LD_VAR 0 8
98998: ARRAY
98999: PPUSH
99000: CALL_OW 1
99004: ST_TO_ADDR
// attacking := true ;
99005: LD_ADDR_VAR 0 29
99009: PUSH
99010: LD_INT 1
99012: ST_TO_ADDR
// break ;
99013: GO 99017
// end ; end ;
99015: GO 98884
99017: POP
99018: POP
// if not attacking and f_attack_depot then
99019: LD_VAR 0 29
99023: NOT
99024: PUSH
99025: LD_VAR 0 25
99029: AND
99030: IFFALSE 99125
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
99032: LD_ADDR_VAR 0 13
99036: PUSH
99037: LD_VAR 0 14
99041: PPUSH
99042: LD_INT 2
99044: PUSH
99045: LD_INT 30
99047: PUSH
99048: LD_INT 0
99050: PUSH
99051: EMPTY
99052: LIST
99053: LIST
99054: PUSH
99055: LD_INT 30
99057: PUSH
99058: LD_INT 1
99060: PUSH
99061: EMPTY
99062: LIST
99063: LIST
99064: PUSH
99065: EMPTY
99066: LIST
99067: LIST
99068: LIST
99069: PPUSH
99070: CALL_OW 72
99074: ST_TO_ADDR
// if z then
99075: LD_VAR 0 13
99079: IFFALSE 99125
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
99081: LD_VAR 0 4
99085: PUSH
99086: LD_VAR 0 7
99090: ARRAY
99091: PPUSH
99092: LD_VAR 0 13
99096: PPUSH
99097: LD_VAR 0 4
99101: PUSH
99102: LD_VAR 0 7
99106: ARRAY
99107: PPUSH
99108: CALL_OW 74
99112: PPUSH
99113: CALL_OW 115
// attacking := true ;
99117: LD_ADDR_VAR 0 29
99121: PUSH
99122: LD_INT 1
99124: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
99125: LD_VAR 0 4
99129: PUSH
99130: LD_VAR 0 7
99134: ARRAY
99135: PPUSH
99136: CALL_OW 256
99140: PUSH
99141: LD_INT 500
99143: LESS
99144: IFFALSE 99170
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
99146: LD_VAR 0 4
99150: PUSH
99151: LD_VAR 0 7
99155: ARRAY
99156: PPUSH
99157: LD_VAR 0 14
99161: PUSH
99162: LD_INT 1
99164: ARRAY
99165: PPUSH
99166: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
99170: LD_VAR 0 4
99174: PUSH
99175: LD_VAR 0 7
99179: ARRAY
99180: PPUSH
99181: CALL_OW 264
99185: PUSH
99186: LD_INT 49
99188: EQUAL
99189: IFFALSE 99310
// begin if not HasTask ( group [ i ] ) then
99191: LD_VAR 0 4
99195: PUSH
99196: LD_VAR 0 7
99200: ARRAY
99201: PPUSH
99202: CALL_OW 314
99206: NOT
99207: IFFALSE 99310
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
99209: LD_ADDR_VAR 0 9
99213: PUSH
99214: LD_INT 81
99216: PUSH
99217: LD_VAR 0 4
99221: PUSH
99222: LD_VAR 0 7
99226: ARRAY
99227: PPUSH
99228: CALL_OW 255
99232: PUSH
99233: EMPTY
99234: LIST
99235: LIST
99236: PPUSH
99237: CALL_OW 69
99241: PPUSH
99242: LD_VAR 0 4
99246: PUSH
99247: LD_VAR 0 7
99251: ARRAY
99252: PPUSH
99253: CALL_OW 74
99257: ST_TO_ADDR
// if k then
99258: LD_VAR 0 9
99262: IFFALSE 99310
// if GetDistUnits ( group [ i ] , k ) > 10 then
99264: LD_VAR 0 4
99268: PUSH
99269: LD_VAR 0 7
99273: ARRAY
99274: PPUSH
99275: LD_VAR 0 9
99279: PPUSH
99280: CALL_OW 296
99284: PUSH
99285: LD_INT 10
99287: GREATER
99288: IFFALSE 99310
// ComMoveUnit ( group [ i ] , k ) ;
99290: LD_VAR 0 4
99294: PUSH
99295: LD_VAR 0 7
99299: ARRAY
99300: PPUSH
99301: LD_VAR 0 9
99305: PPUSH
99306: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
99310: LD_VAR 0 4
99314: PUSH
99315: LD_VAR 0 7
99319: ARRAY
99320: PPUSH
99321: CALL_OW 256
99325: PUSH
99326: LD_INT 250
99328: LESS
99329: PUSH
99330: LD_VAR 0 4
99334: PUSH
99335: LD_VAR 0 7
99339: ARRAY
99340: PUSH
99341: LD_INT 21
99343: PUSH
99344: LD_INT 2
99346: PUSH
99347: EMPTY
99348: LIST
99349: LIST
99350: PUSH
99351: LD_INT 23
99353: PUSH
99354: LD_INT 2
99356: PUSH
99357: EMPTY
99358: LIST
99359: LIST
99360: PUSH
99361: EMPTY
99362: LIST
99363: LIST
99364: PPUSH
99365: CALL_OW 69
99369: IN
99370: AND
99371: IFFALSE 99496
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
99373: LD_ADDR_VAR 0 9
99377: PUSH
99378: LD_OWVAR 3
99382: PUSH
99383: LD_VAR 0 4
99387: PUSH
99388: LD_VAR 0 7
99392: ARRAY
99393: DIFF
99394: PPUSH
99395: LD_VAR 0 4
99399: PUSH
99400: LD_VAR 0 7
99404: ARRAY
99405: PPUSH
99406: CALL_OW 74
99410: ST_TO_ADDR
// if not k then
99411: LD_VAR 0 9
99415: NOT
99416: IFFALSE 99420
// continue ;
99418: GO 95835
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
99420: LD_VAR 0 9
99424: PUSH
99425: LD_INT 81
99427: PUSH
99428: LD_VAR 0 4
99432: PUSH
99433: LD_VAR 0 7
99437: ARRAY
99438: PPUSH
99439: CALL_OW 255
99443: PUSH
99444: EMPTY
99445: LIST
99446: LIST
99447: PPUSH
99448: CALL_OW 69
99452: IN
99453: PUSH
99454: LD_VAR 0 9
99458: PPUSH
99459: LD_VAR 0 4
99463: PUSH
99464: LD_VAR 0 7
99468: ARRAY
99469: PPUSH
99470: CALL_OW 296
99474: PUSH
99475: LD_INT 5
99477: LESS
99478: AND
99479: IFFALSE 99496
// ComAutodestruct ( group [ i ] ) ;
99481: LD_VAR 0 4
99485: PUSH
99486: LD_VAR 0 7
99490: ARRAY
99491: PPUSH
99492: CALL 79453 0 1
// end ; if f_attack_depot then
99496: LD_VAR 0 25
99500: IFFALSE 99612
// begin k := 6 ;
99502: LD_ADDR_VAR 0 9
99506: PUSH
99507: LD_INT 6
99509: ST_TO_ADDR
// if tmp < k then
99510: LD_VAR 0 14
99514: PUSH
99515: LD_VAR 0 9
99519: LESS
99520: IFFALSE 99532
// k := tmp ;
99522: LD_ADDR_VAR 0 9
99526: PUSH
99527: LD_VAR 0 14
99531: ST_TO_ADDR
// for j = 1 to k do
99532: LD_ADDR_VAR 0 8
99536: PUSH
99537: DOUBLE
99538: LD_INT 1
99540: DEC
99541: ST_TO_ADDR
99542: LD_VAR 0 9
99546: PUSH
99547: FOR_TO
99548: IFFALSE 99610
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
99550: LD_VAR 0 8
99554: PPUSH
99555: CALL_OW 266
99559: PUSH
99560: LD_INT 0
99562: PUSH
99563: LD_INT 1
99565: PUSH
99566: EMPTY
99567: LIST
99568: LIST
99569: IN
99570: IFFALSE 99608
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
99572: LD_VAR 0 4
99576: PUSH
99577: LD_VAR 0 7
99581: ARRAY
99582: PPUSH
99583: LD_VAR 0 14
99587: PUSH
99588: LD_VAR 0 8
99592: ARRAY
99593: PPUSH
99594: CALL_OW 115
// attacking := true ;
99598: LD_ADDR_VAR 0 29
99602: PUSH
99603: LD_INT 1
99605: ST_TO_ADDR
// break ;
99606: GO 99610
// end ;
99608: GO 99547
99610: POP
99611: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
99612: LD_VAR 0 4
99616: PUSH
99617: LD_VAR 0 7
99621: ARRAY
99622: PPUSH
99623: CALL_OW 302
99627: PUSH
99628: LD_VAR 0 29
99632: NOT
99633: AND
99634: IFFALSE 99956
// begin if GetTag ( group [ i ] ) = 71 then
99636: LD_VAR 0 4
99640: PUSH
99641: LD_VAR 0 7
99645: ARRAY
99646: PPUSH
99647: CALL_OW 110
99651: PUSH
99652: LD_INT 71
99654: EQUAL
99655: IFFALSE 99696
// begin if HasTask ( group [ i ] ) then
99657: LD_VAR 0 4
99661: PUSH
99662: LD_VAR 0 7
99666: ARRAY
99667: PPUSH
99668: CALL_OW 314
99672: IFFALSE 99678
// continue else
99674: GO 95835
99676: GO 99696
// SetTag ( group [ i ] , 0 ) ;
99678: LD_VAR 0 4
99682: PUSH
99683: LD_VAR 0 7
99687: ARRAY
99688: PPUSH
99689: LD_INT 0
99691: PPUSH
99692: CALL_OW 109
// end ; k := 8 ;
99696: LD_ADDR_VAR 0 9
99700: PUSH
99701: LD_INT 8
99703: ST_TO_ADDR
// x := 0 ;
99704: LD_ADDR_VAR 0 10
99708: PUSH
99709: LD_INT 0
99711: ST_TO_ADDR
// if tmp < k then
99712: LD_VAR 0 14
99716: PUSH
99717: LD_VAR 0 9
99721: LESS
99722: IFFALSE 99734
// k := tmp ;
99724: LD_ADDR_VAR 0 9
99728: PUSH
99729: LD_VAR 0 14
99733: ST_TO_ADDR
// for j = 1 to k do
99734: LD_ADDR_VAR 0 8
99738: PUSH
99739: DOUBLE
99740: LD_INT 1
99742: DEC
99743: ST_TO_ADDR
99744: LD_VAR 0 9
99748: PUSH
99749: FOR_TO
99750: IFFALSE 99848
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
99752: LD_VAR 0 14
99756: PUSH
99757: LD_VAR 0 8
99761: ARRAY
99762: PPUSH
99763: CALL_OW 247
99767: PUSH
99768: LD_INT 1
99770: EQUAL
99771: PUSH
99772: LD_VAR 0 14
99776: PUSH
99777: LD_VAR 0 8
99781: ARRAY
99782: PPUSH
99783: CALL_OW 256
99787: PUSH
99788: LD_INT 250
99790: LESS
99791: PUSH
99792: LD_VAR 0 20
99796: AND
99797: PUSH
99798: LD_VAR 0 20
99802: NOT
99803: PUSH
99804: LD_VAR 0 14
99808: PUSH
99809: LD_VAR 0 8
99813: ARRAY
99814: PPUSH
99815: CALL_OW 256
99819: PUSH
99820: LD_INT 250
99822: GREATEREQUAL
99823: AND
99824: OR
99825: AND
99826: IFFALSE 99846
// begin x := tmp [ j ] ;
99828: LD_ADDR_VAR 0 10
99832: PUSH
99833: LD_VAR 0 14
99837: PUSH
99838: LD_VAR 0 8
99842: ARRAY
99843: ST_TO_ADDR
// break ;
99844: GO 99848
// end ;
99846: GO 99749
99848: POP
99849: POP
// if x then
99850: LD_VAR 0 10
99854: IFFALSE 99878
// ComAttackUnit ( group [ i ] , x ) else
99856: LD_VAR 0 4
99860: PUSH
99861: LD_VAR 0 7
99865: ARRAY
99866: PPUSH
99867: LD_VAR 0 10
99871: PPUSH
99872: CALL_OW 115
99876: GO 99902
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
99878: LD_VAR 0 4
99882: PUSH
99883: LD_VAR 0 7
99887: ARRAY
99888: PPUSH
99889: LD_VAR 0 14
99893: PUSH
99894: LD_INT 1
99896: ARRAY
99897: PPUSH
99898: CALL_OW 115
// if not HasTask ( group [ i ] ) then
99902: LD_VAR 0 4
99906: PUSH
99907: LD_VAR 0 7
99911: ARRAY
99912: PPUSH
99913: CALL_OW 314
99917: NOT
99918: IFFALSE 99956
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
99920: LD_VAR 0 4
99924: PUSH
99925: LD_VAR 0 7
99929: ARRAY
99930: PPUSH
99931: LD_VAR 0 14
99935: PPUSH
99936: LD_VAR 0 4
99940: PUSH
99941: LD_VAR 0 7
99945: ARRAY
99946: PPUSH
99947: CALL_OW 74
99951: PPUSH
99952: CALL_OW 115
// end ; end ; end ;
99956: GO 95835
99958: POP
99959: POP
// wait ( 0 0$2 ) ;
99960: LD_INT 70
99962: PPUSH
99963: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
99967: LD_VAR 0 4
99971: NOT
99972: PUSH
99973: LD_VAR 0 4
99977: PUSH
99978: EMPTY
99979: EQUAL
99980: OR
99981: PUSH
99982: LD_INT 81
99984: PUSH
99985: LD_VAR 0 35
99989: PUSH
99990: EMPTY
99991: LIST
99992: LIST
99993: PPUSH
99994: CALL_OW 69
99998: NOT
99999: OR
100000: IFFALSE 95820
// end ;
100002: LD_VAR 0 2
100006: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
100007: LD_INT 0
100009: PPUSH
100010: PPUSH
100011: PPUSH
100012: PPUSH
100013: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
100014: LD_VAR 0 1
100018: NOT
100019: PUSH
100020: LD_EXP 50
100024: PUSH
100025: LD_VAR 0 1
100029: ARRAY
100030: NOT
100031: OR
100032: PUSH
100033: LD_VAR 0 2
100037: NOT
100038: OR
100039: PUSH
100040: LD_VAR 0 3
100044: NOT
100045: OR
100046: IFFALSE 100050
// exit ;
100048: GO 100563
// side := mc_sides [ base ] ;
100050: LD_ADDR_VAR 0 6
100054: PUSH
100055: LD_EXP 76
100059: PUSH
100060: LD_VAR 0 1
100064: ARRAY
100065: ST_TO_ADDR
// if not side then
100066: LD_VAR 0 6
100070: NOT
100071: IFFALSE 100075
// exit ;
100073: GO 100563
// for i in solds do
100075: LD_ADDR_VAR 0 7
100079: PUSH
100080: LD_VAR 0 2
100084: PUSH
100085: FOR_IN
100086: IFFALSE 100147
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
100088: LD_VAR 0 7
100092: PPUSH
100093: CALL_OW 310
100097: PPUSH
100098: CALL_OW 266
100102: PUSH
100103: LD_INT 32
100105: PUSH
100106: LD_INT 31
100108: PUSH
100109: EMPTY
100110: LIST
100111: LIST
100112: IN
100113: IFFALSE 100133
// solds := solds diff i else
100115: LD_ADDR_VAR 0 2
100119: PUSH
100120: LD_VAR 0 2
100124: PUSH
100125: LD_VAR 0 7
100129: DIFF
100130: ST_TO_ADDR
100131: GO 100145
// SetTag ( i , 18 ) ;
100133: LD_VAR 0 7
100137: PPUSH
100138: LD_INT 18
100140: PPUSH
100141: CALL_OW 109
100145: GO 100085
100147: POP
100148: POP
// if not solds then
100149: LD_VAR 0 2
100153: NOT
100154: IFFALSE 100158
// exit ;
100156: GO 100563
// repeat wait ( 0 0$1 ) ;
100158: LD_INT 35
100160: PPUSH
100161: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
100165: LD_ADDR_VAR 0 5
100169: PUSH
100170: LD_VAR 0 6
100174: PPUSH
100175: LD_VAR 0 3
100179: PPUSH
100180: CALL 49168 0 2
100184: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
100185: LD_EXP 50
100189: PUSH
100190: LD_VAR 0 1
100194: ARRAY
100195: NOT
100196: PUSH
100197: LD_EXP 50
100201: PUSH
100202: LD_VAR 0 1
100206: ARRAY
100207: PUSH
100208: EMPTY
100209: EQUAL
100210: OR
100211: IFFALSE 100248
// begin for i in solds do
100213: LD_ADDR_VAR 0 7
100217: PUSH
100218: LD_VAR 0 2
100222: PUSH
100223: FOR_IN
100224: IFFALSE 100237
// ComStop ( i ) ;
100226: LD_VAR 0 7
100230: PPUSH
100231: CALL_OW 141
100235: GO 100223
100237: POP
100238: POP
// solds := [ ] ;
100239: LD_ADDR_VAR 0 2
100243: PUSH
100244: EMPTY
100245: ST_TO_ADDR
// exit ;
100246: GO 100563
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
100248: LD_VAR 0 5
100252: NOT
100253: PUSH
100254: LD_VAR 0 5
100258: PUSH
100259: LD_INT 3
100261: GREATER
100262: OR
100263: PUSH
100264: LD_EXP 72
100268: PUSH
100269: LD_VAR 0 1
100273: ARRAY
100274: OR
100275: IFFALSE 100316
// begin for i in solds do
100277: LD_ADDR_VAR 0 7
100281: PUSH
100282: LD_VAR 0 2
100286: PUSH
100287: FOR_IN
100288: IFFALSE 100312
// if HasTask ( i ) then
100290: LD_VAR 0 7
100294: PPUSH
100295: CALL_OW 314
100299: IFFALSE 100310
// ComStop ( i ) ;
100301: LD_VAR 0 7
100305: PPUSH
100306: CALL_OW 141
100310: GO 100287
100312: POP
100313: POP
// break ;
100314: GO 100551
// end ; for i in solds do
100316: LD_ADDR_VAR 0 7
100320: PUSH
100321: LD_VAR 0 2
100325: PUSH
100326: FOR_IN
100327: IFFALSE 100543
// begin if IsInUnit ( i ) then
100329: LD_VAR 0 7
100333: PPUSH
100334: CALL_OW 310
100338: IFFALSE 100349
// ComExitBuilding ( i ) ;
100340: LD_VAR 0 7
100344: PPUSH
100345: CALL_OW 122
// if GetLives ( i ) > 333 then
100349: LD_VAR 0 7
100353: PPUSH
100354: CALL_OW 256
100358: PUSH
100359: LD_INT 333
100361: GREATER
100362: IFFALSE 100390
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
100364: LD_VAR 0 7
100368: PPUSH
100369: LD_VAR 0 5
100373: PPUSH
100374: LD_VAR 0 7
100378: PPUSH
100379: CALL_OW 74
100383: PPUSH
100384: CALL_OW 115
100388: GO 100541
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
100390: LD_ADDR_VAR 0 8
100394: PUSH
100395: LD_EXP 50
100399: PUSH
100400: LD_VAR 0 1
100404: ARRAY
100405: PPUSH
100406: LD_INT 2
100408: PUSH
100409: LD_INT 30
100411: PUSH
100412: LD_INT 0
100414: PUSH
100415: EMPTY
100416: LIST
100417: LIST
100418: PUSH
100419: LD_INT 30
100421: PUSH
100422: LD_INT 1
100424: PUSH
100425: EMPTY
100426: LIST
100427: LIST
100428: PUSH
100429: LD_INT 30
100431: PUSH
100432: LD_INT 6
100434: PUSH
100435: EMPTY
100436: LIST
100437: LIST
100438: PUSH
100439: EMPTY
100440: LIST
100441: LIST
100442: LIST
100443: LIST
100444: PPUSH
100445: CALL_OW 72
100449: PPUSH
100450: LD_VAR 0 7
100454: PPUSH
100455: CALL_OW 74
100459: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
100460: LD_VAR 0 7
100464: PPUSH
100465: LD_VAR 0 8
100469: PPUSH
100470: CALL_OW 250
100474: PPUSH
100475: LD_INT 3
100477: PPUSH
100478: LD_INT 5
100480: PPUSH
100481: CALL_OW 272
100485: PPUSH
100486: LD_VAR 0 8
100490: PPUSH
100491: CALL_OW 251
100495: PPUSH
100496: LD_INT 3
100498: PPUSH
100499: LD_INT 5
100501: PPUSH
100502: CALL_OW 273
100506: PPUSH
100507: CALL_OW 111
// SetTag ( i , 0 ) ;
100511: LD_VAR 0 7
100515: PPUSH
100516: LD_INT 0
100518: PPUSH
100519: CALL_OW 109
// solds := solds diff i ;
100523: LD_ADDR_VAR 0 2
100527: PUSH
100528: LD_VAR 0 2
100532: PUSH
100533: LD_VAR 0 7
100537: DIFF
100538: ST_TO_ADDR
// continue ;
100539: GO 100326
// end ; end ;
100541: GO 100326
100543: POP
100544: POP
// until solds ;
100545: LD_VAR 0 2
100549: IFFALSE 100158
// MC_Reset ( base , 18 ) ;
100551: LD_VAR 0 1
100555: PPUSH
100556: LD_INT 18
100558: PPUSH
100559: CALL 21460 0 2
// end ;
100563: LD_VAR 0 4
100567: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
100568: LD_INT 0
100570: PPUSH
100571: PPUSH
100572: PPUSH
100573: PPUSH
100574: PPUSH
100575: PPUSH
100576: PPUSH
100577: PPUSH
100578: PPUSH
100579: PPUSH
100580: PPUSH
100581: PPUSH
100582: PPUSH
100583: PPUSH
100584: PPUSH
100585: PPUSH
100586: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
100587: LD_ADDR_VAR 0 13
100591: PUSH
100592: LD_EXP 50
100596: PUSH
100597: LD_VAR 0 1
100601: ARRAY
100602: PPUSH
100603: LD_INT 25
100605: PUSH
100606: LD_INT 3
100608: PUSH
100609: EMPTY
100610: LIST
100611: LIST
100612: PPUSH
100613: CALL_OW 72
100617: ST_TO_ADDR
// if mc_remote_driver [ base ] then
100618: LD_EXP 90
100622: PUSH
100623: LD_VAR 0 1
100627: ARRAY
100628: IFFALSE 100652
// mechs := mechs diff mc_remote_driver [ base ] ;
100630: LD_ADDR_VAR 0 13
100634: PUSH
100635: LD_VAR 0 13
100639: PUSH
100640: LD_EXP 90
100644: PUSH
100645: LD_VAR 0 1
100649: ARRAY
100650: DIFF
100651: ST_TO_ADDR
// for i in mechs do
100652: LD_ADDR_VAR 0 5
100656: PUSH
100657: LD_VAR 0 13
100661: PUSH
100662: FOR_IN
100663: IFFALSE 100698
// if GetTag ( i ) > 0 then
100665: LD_VAR 0 5
100669: PPUSH
100670: CALL_OW 110
100674: PUSH
100675: LD_INT 0
100677: GREATER
100678: IFFALSE 100696
// mechs := mechs diff i ;
100680: LD_ADDR_VAR 0 13
100684: PUSH
100685: LD_VAR 0 13
100689: PUSH
100690: LD_VAR 0 5
100694: DIFF
100695: ST_TO_ADDR
100696: GO 100662
100698: POP
100699: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
100700: LD_ADDR_VAR 0 9
100704: PUSH
100705: LD_EXP 50
100709: PUSH
100710: LD_VAR 0 1
100714: ARRAY
100715: PPUSH
100716: LD_INT 2
100718: PUSH
100719: LD_INT 25
100721: PUSH
100722: LD_INT 1
100724: PUSH
100725: EMPTY
100726: LIST
100727: LIST
100728: PUSH
100729: LD_INT 25
100731: PUSH
100732: LD_INT 5
100734: PUSH
100735: EMPTY
100736: LIST
100737: LIST
100738: PUSH
100739: LD_INT 25
100741: PUSH
100742: LD_INT 8
100744: PUSH
100745: EMPTY
100746: LIST
100747: LIST
100748: PUSH
100749: LD_INT 25
100751: PUSH
100752: LD_INT 9
100754: PUSH
100755: EMPTY
100756: LIST
100757: LIST
100758: PUSH
100759: EMPTY
100760: LIST
100761: LIST
100762: LIST
100763: LIST
100764: LIST
100765: PPUSH
100766: CALL_OW 72
100770: ST_TO_ADDR
// if not defenders and not solds then
100771: LD_VAR 0 2
100775: NOT
100776: PUSH
100777: LD_VAR 0 9
100781: NOT
100782: AND
100783: IFFALSE 100787
// exit ;
100785: GO 102413
// depot_under_attack := false ;
100787: LD_ADDR_VAR 0 17
100791: PUSH
100792: LD_INT 0
100794: ST_TO_ADDR
// sold_defenders := [ ] ;
100795: LD_ADDR_VAR 0 18
100799: PUSH
100800: EMPTY
100801: ST_TO_ADDR
// if mechs then
100802: LD_VAR 0 13
100806: IFFALSE 100935
// for i in defenders do
100808: LD_ADDR_VAR 0 5
100812: PUSH
100813: LD_VAR 0 2
100817: PUSH
100818: FOR_IN
100819: IFFALSE 100933
// begin SetTag ( i , 20 ) ;
100821: LD_VAR 0 5
100825: PPUSH
100826: LD_INT 20
100828: PPUSH
100829: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
100833: LD_VAR 0 5
100837: PPUSH
100838: CALL_OW 263
100842: PUSH
100843: LD_INT 1
100845: EQUAL
100846: PUSH
100847: LD_VAR 0 5
100851: PPUSH
100852: CALL_OW 311
100856: NOT
100857: AND
100858: PUSH
100859: LD_VAR 0 13
100863: AND
100864: IFFALSE 100931
// begin un := mechs [ 1 ] ;
100866: LD_ADDR_VAR 0 11
100870: PUSH
100871: LD_VAR 0 13
100875: PUSH
100876: LD_INT 1
100878: ARRAY
100879: ST_TO_ADDR
// ComExitBuilding ( un ) ;
100880: LD_VAR 0 11
100884: PPUSH
100885: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
100889: LD_VAR 0 11
100893: PPUSH
100894: LD_VAR 0 5
100898: PPUSH
100899: CALL_OW 180
// SetTag ( un , 19 ) ;
100903: LD_VAR 0 11
100907: PPUSH
100908: LD_INT 19
100910: PPUSH
100911: CALL_OW 109
// mechs := mechs diff un ;
100915: LD_ADDR_VAR 0 13
100919: PUSH
100920: LD_VAR 0 13
100924: PUSH
100925: LD_VAR 0 11
100929: DIFF
100930: ST_TO_ADDR
// end ; end ;
100931: GO 100818
100933: POP
100934: POP
// if solds then
100935: LD_VAR 0 9
100939: IFFALSE 100998
// for i in solds do
100941: LD_ADDR_VAR 0 5
100945: PUSH
100946: LD_VAR 0 9
100950: PUSH
100951: FOR_IN
100952: IFFALSE 100996
// if not GetTag ( i ) then
100954: LD_VAR 0 5
100958: PPUSH
100959: CALL_OW 110
100963: NOT
100964: IFFALSE 100994
// begin defenders := defenders union i ;
100966: LD_ADDR_VAR 0 2
100970: PUSH
100971: LD_VAR 0 2
100975: PUSH
100976: LD_VAR 0 5
100980: UNION
100981: ST_TO_ADDR
// SetTag ( i , 18 ) ;
100982: LD_VAR 0 5
100986: PPUSH
100987: LD_INT 18
100989: PPUSH
100990: CALL_OW 109
// end ;
100994: GO 100951
100996: POP
100997: POP
// repeat wait ( 0 0$1 ) ;
100998: LD_INT 35
101000: PPUSH
101001: CALL_OW 67
// enemy := mc_scan [ base ] ;
101005: LD_ADDR_VAR 0 3
101009: PUSH
101010: LD_EXP 73
101014: PUSH
101015: LD_VAR 0 1
101019: ARRAY
101020: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
101021: LD_EXP 50
101025: PUSH
101026: LD_VAR 0 1
101030: ARRAY
101031: NOT
101032: PUSH
101033: LD_EXP 50
101037: PUSH
101038: LD_VAR 0 1
101042: ARRAY
101043: PUSH
101044: EMPTY
101045: EQUAL
101046: OR
101047: IFFALSE 101084
// begin for i in defenders do
101049: LD_ADDR_VAR 0 5
101053: PUSH
101054: LD_VAR 0 2
101058: PUSH
101059: FOR_IN
101060: IFFALSE 101073
// ComStop ( i ) ;
101062: LD_VAR 0 5
101066: PPUSH
101067: CALL_OW 141
101071: GO 101059
101073: POP
101074: POP
// defenders := [ ] ;
101075: LD_ADDR_VAR 0 2
101079: PUSH
101080: EMPTY
101081: ST_TO_ADDR
// exit ;
101082: GO 102413
// end ; for i in defenders do
101084: LD_ADDR_VAR 0 5
101088: PUSH
101089: LD_VAR 0 2
101093: PUSH
101094: FOR_IN
101095: IFFALSE 101913
// begin e := NearestUnitToUnit ( enemy , i ) ;
101097: LD_ADDR_VAR 0 14
101101: PUSH
101102: LD_VAR 0 3
101106: PPUSH
101107: LD_VAR 0 5
101111: PPUSH
101112: CALL_OW 74
101116: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101117: LD_ADDR_VAR 0 8
101121: PUSH
101122: LD_EXP 50
101126: PUSH
101127: LD_VAR 0 1
101131: ARRAY
101132: PPUSH
101133: LD_INT 2
101135: PUSH
101136: LD_INT 30
101138: PUSH
101139: LD_INT 0
101141: PUSH
101142: EMPTY
101143: LIST
101144: LIST
101145: PUSH
101146: LD_INT 30
101148: PUSH
101149: LD_INT 1
101151: PUSH
101152: EMPTY
101153: LIST
101154: LIST
101155: PUSH
101156: EMPTY
101157: LIST
101158: LIST
101159: LIST
101160: PPUSH
101161: CALL_OW 72
101165: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
101166: LD_ADDR_VAR 0 17
101170: PUSH
101171: LD_VAR 0 8
101175: NOT
101176: PUSH
101177: LD_VAR 0 8
101181: PPUSH
101182: LD_INT 3
101184: PUSH
101185: LD_INT 24
101187: PUSH
101188: LD_INT 600
101190: PUSH
101191: EMPTY
101192: LIST
101193: LIST
101194: PUSH
101195: EMPTY
101196: LIST
101197: LIST
101198: PPUSH
101199: CALL_OW 72
101203: OR
101204: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
101205: LD_VAR 0 5
101209: PPUSH
101210: CALL_OW 247
101214: PUSH
101215: LD_INT 2
101217: DOUBLE
101218: EQUAL
101219: IFTRUE 101223
101221: GO 101619
101223: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
101224: LD_VAR 0 5
101228: PPUSH
101229: CALL_OW 256
101233: PUSH
101234: LD_INT 650
101236: GREATER
101237: PUSH
101238: LD_VAR 0 5
101242: PPUSH
101243: LD_VAR 0 14
101247: PPUSH
101248: CALL_OW 296
101252: PUSH
101253: LD_INT 40
101255: LESS
101256: PUSH
101257: LD_VAR 0 14
101261: PPUSH
101262: LD_EXP 75
101266: PUSH
101267: LD_VAR 0 1
101271: ARRAY
101272: PPUSH
101273: CALL_OW 308
101277: OR
101278: AND
101279: IFFALSE 101401
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
101281: LD_VAR 0 5
101285: PPUSH
101286: CALL_OW 262
101290: PUSH
101291: LD_INT 1
101293: EQUAL
101294: PUSH
101295: LD_VAR 0 5
101299: PPUSH
101300: CALL_OW 261
101304: PUSH
101305: LD_INT 30
101307: LESS
101308: AND
101309: PUSH
101310: LD_VAR 0 8
101314: AND
101315: IFFALSE 101385
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
101317: LD_VAR 0 5
101321: PPUSH
101322: LD_VAR 0 8
101326: PPUSH
101327: LD_VAR 0 5
101331: PPUSH
101332: CALL_OW 74
101336: PPUSH
101337: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
101341: LD_VAR 0 5
101345: PPUSH
101346: LD_VAR 0 8
101350: PPUSH
101351: LD_VAR 0 5
101355: PPUSH
101356: CALL_OW 74
101360: PPUSH
101361: CALL_OW 296
101365: PUSH
101366: LD_INT 6
101368: LESS
101369: IFFALSE 101383
// SetFuel ( i , 100 ) ;
101371: LD_VAR 0 5
101375: PPUSH
101376: LD_INT 100
101378: PPUSH
101379: CALL_OW 240
// end else
101383: GO 101399
// ComAttackUnit ( i , e ) ;
101385: LD_VAR 0 5
101389: PPUSH
101390: LD_VAR 0 14
101394: PPUSH
101395: CALL_OW 115
// end else
101399: GO 101502
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
101401: LD_VAR 0 14
101405: PPUSH
101406: LD_EXP 75
101410: PUSH
101411: LD_VAR 0 1
101415: ARRAY
101416: PPUSH
101417: CALL_OW 308
101421: NOT
101422: PUSH
101423: LD_VAR 0 5
101427: PPUSH
101428: LD_VAR 0 14
101432: PPUSH
101433: CALL_OW 296
101437: PUSH
101438: LD_INT 40
101440: GREATEREQUAL
101441: AND
101442: PUSH
101443: LD_VAR 0 5
101447: PPUSH
101448: CALL_OW 256
101452: PUSH
101453: LD_INT 650
101455: LESSEQUAL
101456: OR
101457: PUSH
101458: LD_VAR 0 5
101462: PPUSH
101463: LD_EXP 74
101467: PUSH
101468: LD_VAR 0 1
101472: ARRAY
101473: PPUSH
101474: CALL_OW 308
101478: NOT
101479: AND
101480: IFFALSE 101502
// ComMoveToArea ( i , mc_parking [ base ] ) ;
101482: LD_VAR 0 5
101486: PPUSH
101487: LD_EXP 74
101491: PUSH
101492: LD_VAR 0 1
101496: ARRAY
101497: PPUSH
101498: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
101502: LD_VAR 0 5
101506: PPUSH
101507: CALL_OW 256
101511: PUSH
101512: LD_INT 998
101514: LESS
101515: PUSH
101516: LD_VAR 0 5
101520: PPUSH
101521: CALL_OW 263
101525: PUSH
101526: LD_INT 1
101528: EQUAL
101529: AND
101530: PUSH
101531: LD_VAR 0 5
101535: PPUSH
101536: CALL_OW 311
101540: AND
101541: PUSH
101542: LD_VAR 0 5
101546: PPUSH
101547: LD_EXP 74
101551: PUSH
101552: LD_VAR 0 1
101556: ARRAY
101557: PPUSH
101558: CALL_OW 308
101562: AND
101563: IFFALSE 101617
// begin mech := IsDrivenBy ( i ) ;
101565: LD_ADDR_VAR 0 10
101569: PUSH
101570: LD_VAR 0 5
101574: PPUSH
101575: CALL_OW 311
101579: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
101580: LD_VAR 0 10
101584: PPUSH
101585: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
101589: LD_VAR 0 10
101593: PPUSH
101594: LD_VAR 0 5
101598: PPUSH
101599: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
101603: LD_VAR 0 10
101607: PPUSH
101608: LD_VAR 0 5
101612: PPUSH
101613: CALL_OW 180
// end ; end ; unit_human :
101617: GO 101884
101619: LD_INT 1
101621: DOUBLE
101622: EQUAL
101623: IFTRUE 101627
101625: GO 101883
101627: POP
// begin b := IsInUnit ( i ) ;
101628: LD_ADDR_VAR 0 19
101632: PUSH
101633: LD_VAR 0 5
101637: PPUSH
101638: CALL_OW 310
101642: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
101643: LD_ADDR_VAR 0 20
101647: PUSH
101648: LD_VAR 0 19
101652: NOT
101653: PUSH
101654: LD_VAR 0 19
101658: PPUSH
101659: CALL_OW 266
101663: PUSH
101664: LD_INT 32
101666: PUSH
101667: LD_INT 31
101669: PUSH
101670: EMPTY
101671: LIST
101672: LIST
101673: IN
101674: OR
101675: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
101676: LD_VAR 0 17
101680: PUSH
101681: LD_VAR 0 2
101685: PPUSH
101686: LD_INT 21
101688: PUSH
101689: LD_INT 2
101691: PUSH
101692: EMPTY
101693: LIST
101694: LIST
101695: PPUSH
101696: CALL_OW 72
101700: PUSH
101701: LD_INT 1
101703: LESSEQUAL
101704: OR
101705: PUSH
101706: LD_VAR 0 20
101710: AND
101711: PUSH
101712: LD_VAR 0 5
101716: PUSH
101717: LD_VAR 0 18
101721: IN
101722: NOT
101723: AND
101724: IFFALSE 101817
// begin if b then
101726: LD_VAR 0 19
101730: IFFALSE 101779
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
101732: LD_VAR 0 19
101736: PPUSH
101737: LD_VAR 0 3
101741: PPUSH
101742: LD_VAR 0 19
101746: PPUSH
101747: CALL_OW 74
101751: PPUSH
101752: CALL_OW 296
101756: PUSH
101757: LD_INT 10
101759: LESS
101760: PUSH
101761: LD_VAR 0 19
101765: PPUSH
101766: CALL_OW 461
101770: PUSH
101771: LD_INT 7
101773: NONEQUAL
101774: AND
101775: IFFALSE 101779
// continue ;
101777: GO 101094
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
101779: LD_ADDR_VAR 0 18
101783: PUSH
101784: LD_VAR 0 18
101788: PPUSH
101789: LD_VAR 0 18
101793: PUSH
101794: LD_INT 1
101796: PLUS
101797: PPUSH
101798: LD_VAR 0 5
101802: PPUSH
101803: CALL_OW 1
101807: ST_TO_ADDR
// ComExitBuilding ( i ) ;
101808: LD_VAR 0 5
101812: PPUSH
101813: CALL_OW 122
// end ; if sold_defenders then
101817: LD_VAR 0 18
101821: IFFALSE 101881
// if i in sold_defenders then
101823: LD_VAR 0 5
101827: PUSH
101828: LD_VAR 0 18
101832: IN
101833: IFFALSE 101881
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
101835: LD_VAR 0 5
101839: PPUSH
101840: CALL_OW 314
101844: NOT
101845: PUSH
101846: LD_VAR 0 5
101850: PPUSH
101851: LD_VAR 0 14
101855: PPUSH
101856: CALL_OW 296
101860: PUSH
101861: LD_INT 30
101863: LESS
101864: AND
101865: IFFALSE 101881
// ComAttackUnit ( i , e ) ;
101867: LD_VAR 0 5
101871: PPUSH
101872: LD_VAR 0 14
101876: PPUSH
101877: CALL_OW 115
// end ; end ; end ;
101881: GO 101884
101883: POP
// if IsDead ( i ) then
101884: LD_VAR 0 5
101888: PPUSH
101889: CALL_OW 301
101893: IFFALSE 101911
// defenders := defenders diff i ;
101895: LD_ADDR_VAR 0 2
101899: PUSH
101900: LD_VAR 0 2
101904: PUSH
101905: LD_VAR 0 5
101909: DIFF
101910: ST_TO_ADDR
// end ;
101911: GO 101094
101913: POP
101914: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
101915: LD_VAR 0 3
101919: NOT
101920: PUSH
101921: LD_VAR 0 2
101925: NOT
101926: OR
101927: PUSH
101928: LD_EXP 50
101932: PUSH
101933: LD_VAR 0 1
101937: ARRAY
101938: NOT
101939: OR
101940: IFFALSE 100998
// MC_Reset ( base , 18 ) ;
101942: LD_VAR 0 1
101946: PPUSH
101947: LD_INT 18
101949: PPUSH
101950: CALL 21460 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
101954: LD_ADDR_VAR 0 2
101958: PUSH
101959: LD_VAR 0 2
101963: PUSH
101964: LD_VAR 0 2
101968: PPUSH
101969: LD_INT 2
101971: PUSH
101972: LD_INT 25
101974: PUSH
101975: LD_INT 1
101977: PUSH
101978: EMPTY
101979: LIST
101980: LIST
101981: PUSH
101982: LD_INT 25
101984: PUSH
101985: LD_INT 5
101987: PUSH
101988: EMPTY
101989: LIST
101990: LIST
101991: PUSH
101992: LD_INT 25
101994: PUSH
101995: LD_INT 8
101997: PUSH
101998: EMPTY
101999: LIST
102000: LIST
102001: PUSH
102002: LD_INT 25
102004: PUSH
102005: LD_INT 9
102007: PUSH
102008: EMPTY
102009: LIST
102010: LIST
102011: PUSH
102012: EMPTY
102013: LIST
102014: LIST
102015: LIST
102016: LIST
102017: LIST
102018: PPUSH
102019: CALL_OW 72
102023: DIFF
102024: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
102025: LD_VAR 0 3
102029: NOT
102030: PUSH
102031: LD_VAR 0 2
102035: PPUSH
102036: LD_INT 21
102038: PUSH
102039: LD_INT 2
102041: PUSH
102042: EMPTY
102043: LIST
102044: LIST
102045: PPUSH
102046: CALL_OW 72
102050: AND
102051: IFFALSE 102389
// begin tmp := FilterByTag ( defenders , 19 ) ;
102053: LD_ADDR_VAR 0 12
102057: PUSH
102058: LD_VAR 0 2
102062: PPUSH
102063: LD_INT 19
102065: PPUSH
102066: CALL 80928 0 2
102070: ST_TO_ADDR
// if tmp then
102071: LD_VAR 0 12
102075: IFFALSE 102145
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
102077: LD_ADDR_VAR 0 12
102081: PUSH
102082: LD_VAR 0 12
102086: PPUSH
102087: LD_INT 25
102089: PUSH
102090: LD_INT 3
102092: PUSH
102093: EMPTY
102094: LIST
102095: LIST
102096: PPUSH
102097: CALL_OW 72
102101: ST_TO_ADDR
// if tmp then
102102: LD_VAR 0 12
102106: IFFALSE 102145
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
102108: LD_ADDR_EXP 62
102112: PUSH
102113: LD_EXP 62
102117: PPUSH
102118: LD_VAR 0 1
102122: PPUSH
102123: LD_EXP 62
102127: PUSH
102128: LD_VAR 0 1
102132: ARRAY
102133: PUSH
102134: LD_VAR 0 12
102138: UNION
102139: PPUSH
102140: CALL_OW 1
102144: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
102145: LD_VAR 0 1
102149: PPUSH
102150: LD_INT 19
102152: PPUSH
102153: CALL 21460 0 2
// repeat wait ( 0 0$1 ) ;
102157: LD_INT 35
102159: PPUSH
102160: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
102164: LD_EXP 50
102168: PUSH
102169: LD_VAR 0 1
102173: ARRAY
102174: NOT
102175: PUSH
102176: LD_EXP 50
102180: PUSH
102181: LD_VAR 0 1
102185: ARRAY
102186: PUSH
102187: EMPTY
102188: EQUAL
102189: OR
102190: IFFALSE 102227
// begin for i in defenders do
102192: LD_ADDR_VAR 0 5
102196: PUSH
102197: LD_VAR 0 2
102201: PUSH
102202: FOR_IN
102203: IFFALSE 102216
// ComStop ( i ) ;
102205: LD_VAR 0 5
102209: PPUSH
102210: CALL_OW 141
102214: GO 102202
102216: POP
102217: POP
// defenders := [ ] ;
102218: LD_ADDR_VAR 0 2
102222: PUSH
102223: EMPTY
102224: ST_TO_ADDR
// exit ;
102225: GO 102413
// end ; for i in defenders do
102227: LD_ADDR_VAR 0 5
102231: PUSH
102232: LD_VAR 0 2
102236: PUSH
102237: FOR_IN
102238: IFFALSE 102327
// begin if not IsInArea ( i , mc_parking [ base ] ) then
102240: LD_VAR 0 5
102244: PPUSH
102245: LD_EXP 74
102249: PUSH
102250: LD_VAR 0 1
102254: ARRAY
102255: PPUSH
102256: CALL_OW 308
102260: NOT
102261: IFFALSE 102285
// ComMoveToArea ( i , mc_parking [ base ] ) else
102263: LD_VAR 0 5
102267: PPUSH
102268: LD_EXP 74
102272: PUSH
102273: LD_VAR 0 1
102277: ARRAY
102278: PPUSH
102279: CALL_OW 113
102283: GO 102325
// if GetControl ( i ) = control_manual then
102285: LD_VAR 0 5
102289: PPUSH
102290: CALL_OW 263
102294: PUSH
102295: LD_INT 1
102297: EQUAL
102298: IFFALSE 102325
// if IsDrivenBy ( i ) then
102300: LD_VAR 0 5
102304: PPUSH
102305: CALL_OW 311
102309: IFFALSE 102325
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
102311: LD_VAR 0 5
102315: PPUSH
102316: CALL_OW 311
102320: PPUSH
102321: CALL_OW 121
// end ;
102325: GO 102237
102327: POP
102328: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
102329: LD_VAR 0 2
102333: PPUSH
102334: LD_INT 95
102336: PUSH
102337: LD_EXP 74
102341: PUSH
102342: LD_VAR 0 1
102346: ARRAY
102347: PUSH
102348: EMPTY
102349: LIST
102350: LIST
102351: PPUSH
102352: CALL_OW 72
102356: PUSH
102357: LD_VAR 0 2
102361: EQUAL
102362: PUSH
102363: LD_EXP 73
102367: PUSH
102368: LD_VAR 0 1
102372: ARRAY
102373: OR
102374: PUSH
102375: LD_EXP 50
102379: PUSH
102380: LD_VAR 0 1
102384: ARRAY
102385: NOT
102386: OR
102387: IFFALSE 102157
// end ; MC_Reset ( base , 19 ) ;
102389: LD_VAR 0 1
102393: PPUSH
102394: LD_INT 19
102396: PPUSH
102397: CALL 21460 0 2
// MC_Reset ( base , 20 ) ;
102401: LD_VAR 0 1
102405: PPUSH
102406: LD_INT 20
102408: PPUSH
102409: CALL 21460 0 2
// end ;
102413: LD_VAR 0 4
102417: RET
