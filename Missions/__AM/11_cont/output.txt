// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 98 0 0
// InitGlobalVariables ;
  19: CALL 88613 0 0
// InitMacro ;
  23: CALL 17952 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  40: LD_INT 8
  42: PPUSH
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  50: LD_INT 4
  52: PPUSH
  53: LD_INT 3
  55: PPUSH
  56: LD_INT 6
  58: PPUSH
  59: LD_INT 3
  61: PPUSH
  62: LD_INT 2
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 7
  70: PPUSH
  71: LD_INT 18
  73: PPUSH
  74: LD_INT 19
  76: PPUSH
  77: CALL 81941 0 9
// PrepareAmerican ;
  81: CALL 663 0 0
// PrepareArabian ;
  85: CALL 2614 0 0
// MC_Start ( ) ;
  89: CALL 20117 0 0
// Action ;
  93: CALL 8559 0 0
// end ;
  97: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  98: LD_INT 0
 100: PPUSH
// debug := false ;
 101: LD_ADDR_EXP 1
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// game := true ;
 109: LD_ADDR_EXP 2
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// mission_prefix := 11_ ;
 117: LD_ADDR_EXP 3
 121: PUSH
 122: LD_STRING 11_
 124: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 125: LD_ADDR_EXP 4
 129: PUSH
 130: LD_STRING 10c_
 132: ST_TO_ADDR
// ar_run := false ;
 133: LD_ADDR_EXP 5
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// ar_patrol := false ;
 141: LD_ADDR_EXP 7
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// base_captured := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// us_scout := 0 ;
 157: LD_ADDR_EXP 8
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 165: LD_ADDR_EXP 9
 169: PUSH
 170: LD_INT 0
 172: PUSH
 173: LD_INT 0
 175: PUSH
 176: LD_INT 0
 178: PUSH
 179: LD_INT 0
 181: PUSH
 182: LD_INT 0
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: LIST
 189: LIST
 190: LIST
 191: ST_TO_ADDR
// kamikazed := false ;
 192: LD_ADDR_EXP 11
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifact_stolen := false ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// artifact_get := false ;
 208: LD_ADDR_EXP 13
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 273000
 223: PUSH
 224: LD_INT 252000
 226: PUSH
 227: LD_INT 241500
 229: PUSH
 230: LD_INT 235200
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: ST_TO_ADDR
// powell_warn := false ;
 245: LD_ADDR_EXP 16
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// loses_counter := 0 ;
 253: LD_ADDR_EXP 17
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// artifact_oncargo := false ;
 261: LD_ADDR_EXP 14
 265: PUSH
 266: LD_INT 0
 268: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 269: LD_ADDR_EXP 18
 273: PUSH
 274: LD_STRING 10_GensherEscape_1
 276: PPUSH
 277: LD_EXP 1
 281: PPUSH
 282: CALL_OW 30
 286: ST_TO_ADDR
// can_kamikazed := false ;
 287: LD_ADDR_EXP 10
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// am_veh_consturcted := false ;
 295: LD_ADDR_EXP 20
 299: PUSH
 300: LD_INT 0
 302: ST_TO_ADDR
// end ;
 303: LD_VAR 0 1
 307: RET
// export function CustomInitMacro ; var i ; begin
 308: LD_INT 0
 310: PPUSH
 311: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 312: LD_ADDR_EXP 74
 316: PUSH
 317: LD_INT 20
 319: PUSH
 320: LD_INT 21
 322: PUSH
 323: LD_INT 22
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 331: LD_ADDR_EXP 75
 335: PUSH
 336: LD_INT 28
 338: PUSH
 339: LD_INT 24
 341: PUSH
 342: LD_INT 26
 344: PUSH
 345: EMPTY
 346: LIST
 347: LIST
 348: LIST
 349: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 4
 355: PUSH
 356: LD_INT 6
 358: PUSH
 359: LD_INT 8
 361: PUSH
 362: LD_INT 9
 364: PUSH
 365: EMPTY
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: PUSH
 371: LD_OWVAR 67
 375: ARRAY
 376: PPUSH
 377: LD_INT 3
 379: PPUSH
 380: CALL 41806 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 384: LD_INT 2
 386: PPUSH
 387: LD_INT 4
 389: PUSH
 390: LD_INT 6
 392: PUSH
 393: LD_INT 8
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: LIST
 404: PUSH
 405: LD_OWVAR 67
 409: ARRAY
 410: PPUSH
 411: LD_INT 2
 413: PPUSH
 414: CALL 41806 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 418: LD_INT 3
 420: PPUSH
 421: LD_INT 4
 423: PUSH
 424: LD_INT 6
 426: PUSH
 427: LD_INT 8
 429: PUSH
 430: LD_INT 9
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_OWVAR 67
 443: ARRAY
 444: PPUSH
 445: LD_INT 1
 447: PPUSH
 448: CALL 41806 0 3
// for i = 1 to mc_bases do
 452: LD_ADDR_VAR 0 2
 456: PUSH
 457: DOUBLE
 458: LD_INT 1
 460: DEC
 461: ST_TO_ADDR
 462: LD_EXP 50
 466: PUSH
 467: FOR_TO
 468: IFFALSE 492
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 470: LD_VAR 0 2
 474: PPUSH
 475: LD_EXP 43
 479: PUSH
 480: LD_VAR 0 2
 484: ARRAY
 485: PPUSH
 486: CALL 42232 0 2
 490: GO 467
 492: POP
 493: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 494: LD_INT 1
 496: PPUSH
 497: LD_INT 14
 499: PUSH
 500: LD_INT 1
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_EXP 100
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: PUSH
 517: LD_INT 14
 519: PUSH
 520: LD_INT 1
 522: PUSH
 523: LD_INT 2
 525: PUSH
 526: LD_EXP 100
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL 42124 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 545: LD_INT 2
 547: PPUSH
 548: LD_INT 14
 550: PUSH
 551: LD_INT 1
 553: PUSH
 554: LD_INT 2
 556: PUSH
 557: LD_EXP 100
 561: PUSH
 562: EMPTY
 563: LIST
 564: LIST
 565: LIST
 566: LIST
 567: PUSH
 568: EMPTY
 569: LIST
 570: PPUSH
 571: CALL 42124 0 2
// end ;
 575: LD_VAR 0 1
 579: RET
// function Debuger ; var i ; begin
 580: LD_INT 0
 582: PPUSH
 583: PPUSH
// if not debug then
 584: LD_EXP 1
 588: NOT
 589: IFFALSE 593
// exit ;
 591: GO 629
// game_speed := 5 ;
 593: LD_ADDR_OWVAR 65
 597: PUSH
 598: LD_INT 5
 600: ST_TO_ADDR
// uc_side := 1 ;
 601: LD_ADDR_OWVAR 20
 605: PUSH
 606: LD_INT 1
 608: ST_TO_ADDR
// uc_nation := 1 ;
 609: LD_ADDR_OWVAR 21
 613: PUSH
 614: LD_INT 1
 616: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 617: LD_EXP 36
 621: PPUSH
 622: LD_INT 1
 624: PPUSH
 625: CALL_OW 235
// end ;
 629: LD_VAR 0 1
 633: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 634: LD_INT 94
 636: PPUSH
 637: CALL_OW 301
 641: PUSH
 642: LD_INT 45
 644: PPUSH
 645: CALL_OW 302
 649: AND
 650: IFFALSE 662
 652: GO 654
 654: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 655: LD_STRING ACH_EAST
 657: PPUSH
 658: CALL_OW 543
 662: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 663: LD_INT 0
 665: PPUSH
 666: PPUSH
 667: PPUSH
 668: PPUSH
 669: PPUSH
 670: PPUSH
 671: PPUSH
 672: PPUSH
// uc_side := 4 ;
 673: LD_ADDR_OWVAR 20
 677: PUSH
 678: LD_INT 4
 680: ST_TO_ADDR
// uc_nation := 1 ;
 681: LD_ADDR_OWVAR 21
 685: PUSH
 686: LD_INT 1
 688: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 689: LD_ADDR_EXP 30
 693: PUSH
 694: LD_STRING Powell
 696: PPUSH
 697: LD_INT 0
 699: PPUSH
 700: LD_STRING 
 702: PPUSH
 703: CALL 48578 0 3
 707: ST_TO_ADDR
// uc_side := 1 ;
 708: LD_ADDR_OWVAR 20
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 716: LD_ADDR_EXP 21
 720: PUSH
 721: LD_STRING JMM
 723: PPUSH
 724: LD_EXP 1
 728: NOT
 729: PPUSH
 730: LD_EXP 4
 734: PPUSH
 735: CALL 48578 0 3
 739: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 740: LD_EXP 21
 744: PPUSH
 745: CALL_OW 257
 749: PUSH
 750: LD_INT 4
 752: GREATER
 753: IFFALSE 767
// SetClass ( JMM , 1 ) ;
 755: LD_EXP 21
 759: PPUSH
 760: LD_INT 1
 762: PPUSH
 763: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 767: LD_ADDR_EXP 22
 771: PUSH
 772: LD_STRING Lisa
 774: PPUSH
 775: LD_EXP 1
 779: NOT
 780: PPUSH
 781: LD_EXP 4
 785: PPUSH
 786: CALL 48578 0 3
 790: ST_TO_ADDR
// if not Lisa then
 791: LD_EXP 22
 795: NOT
 796: IFFALSE 811
// Lisa := CreateCharacter ( 10_Lisa ) ;
 798: LD_ADDR_EXP 22
 802: PUSH
 803: LD_STRING 10_Lisa
 805: PPUSH
 806: CALL_OW 34
 810: ST_TO_ADDR
// if not Lisa then
 811: LD_EXP 22
 815: NOT
 816: IFFALSE 831
// Lisa := CreateCharacter ( 09_Lisa ) ;
 818: LD_ADDR_EXP 22
 822: PUSH
 823: LD_STRING 09_Lisa
 825: PPUSH
 826: CALL_OW 34
 830: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 831: LD_ADDR_EXP 31
 835: PUSH
 836: LD_STRING Cornel
 838: PPUSH
 839: LD_EXP 1
 843: NOT
 844: PPUSH
 845: LD_EXP 4
 849: PPUSH
 850: CALL 48578 0 3
 854: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 855: LD_ADDR_EXP 23
 859: PUSH
 860: LD_STRING Donaldson
 862: PPUSH
 863: LD_EXP 1
 867: NOT
 868: PPUSH
 869: LD_EXP 4
 873: PPUSH
 874: CALL 48578 0 3
 878: ST_TO_ADDR
// if not Donaldson then
 879: LD_EXP 23
 883: NOT
 884: IFFALSE 899
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 886: LD_ADDR_EXP 23
 890: PUSH
 891: LD_STRING 10_Donaldson
 893: PPUSH
 894: CALL_OW 34
 898: ST_TO_ADDR
// if not Donaldson then
 899: LD_EXP 23
 903: NOT
 904: IFFALSE 919
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 906: LD_ADDR_EXP 23
 910: PUSH
 911: LD_STRING 09_Donaldson
 913: PPUSH
 914: CALL_OW 34
 918: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 919: LD_ADDR_EXP 24
 923: PUSH
 924: LD_STRING Bobby
 926: PPUSH
 927: LD_EXP 1
 931: NOT
 932: PPUSH
 933: LD_EXP 4
 937: PPUSH
 938: CALL 48578 0 3
 942: ST_TO_ADDR
// if not Bobby then
 943: LD_EXP 24
 947: NOT
 948: IFFALSE 963
// Bobby := CreateCharacter ( 10_Bobby ) ;
 950: LD_ADDR_EXP 24
 954: PUSH
 955: LD_STRING 10_Bobby
 957: PPUSH
 958: CALL_OW 34
 962: ST_TO_ADDR
// if not Bobby then
 963: LD_EXP 24
 967: NOT
 968: IFFALSE 983
// Bobby := CreateCharacter ( 09_Bobby ) ;
 970: LD_ADDR_EXP 24
 974: PUSH
 975: LD_STRING 09_Bobby
 977: PPUSH
 978: CALL_OW 34
 982: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 983: LD_ADDR_EXP 25
 987: PUSH
 988: LD_STRING Cyrus
 990: PPUSH
 991: LD_EXP 1
 995: NOT
 996: PPUSH
 997: LD_EXP 4
1001: PPUSH
1002: CALL 48578 0 3
1006: ST_TO_ADDR
// if not Cyrus then
1007: LD_EXP 25
1011: NOT
1012: IFFALSE 1027
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1014: LD_ADDR_EXP 25
1018: PUSH
1019: LD_STRING 10_Cyrus
1021: PPUSH
1022: CALL_OW 34
1026: ST_TO_ADDR
// if not Cyrus then
1027: LD_EXP 25
1031: NOT
1032: IFFALSE 1047
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1034: LD_ADDR_EXP 25
1038: PUSH
1039: LD_STRING 09_Cyrus
1041: PPUSH
1042: CALL_OW 34
1046: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1047: LD_ADDR_EXP 26
1051: PUSH
1052: LD_STRING Denis
1054: PPUSH
1055: LD_EXP 1
1059: NOT
1060: PPUSH
1061: LD_EXP 4
1065: PPUSH
1066: CALL 48578 0 3
1070: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1071: LD_ADDR_EXP 27
1075: PUSH
1076: LD_STRING Brown
1078: PPUSH
1079: LD_EXP 1
1083: NOT
1084: PPUSH
1085: LD_EXP 4
1089: PPUSH
1090: CALL 48578 0 3
1094: ST_TO_ADDR
// if not Brown then
1095: LD_EXP 27
1099: NOT
1100: IFFALSE 1115
// Brown := CreateCharacter ( 10_Brown ) ;
1102: LD_ADDR_EXP 27
1106: PUSH
1107: LD_STRING 10_Brown
1109: PPUSH
1110: CALL_OW 34
1114: ST_TO_ADDR
// if not Brown then
1115: LD_EXP 27
1119: NOT
1120: IFFALSE 1135
// Brown := CreateCharacter ( 08_Brown ) ;
1122: LD_ADDR_EXP 27
1126: PUSH
1127: LD_STRING 08_Brown
1129: PPUSH
1130: CALL_OW 34
1134: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1135: LD_ADDR_EXP 28
1139: PUSH
1140: LD_STRING Gladstone
1142: PPUSH
1143: LD_EXP 1
1147: NOT
1148: PPUSH
1149: LD_EXP 4
1153: PPUSH
1154: CALL 48578 0 3
1158: ST_TO_ADDR
// if not Gladstone then
1159: LD_EXP 28
1163: NOT
1164: IFFALSE 1179
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1166: LD_ADDR_EXP 28
1170: PUSH
1171: LD_STRING 10_Gladstone
1173: PPUSH
1174: CALL_OW 34
1178: ST_TO_ADDR
// if not Gladstone then
1179: LD_EXP 28
1183: NOT
1184: IFFALSE 1199
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1186: LD_ADDR_EXP 28
1190: PUSH
1191: LD_STRING 08_Gladstone
1193: PPUSH
1194: CALL_OW 34
1198: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1199: LD_ADDR_EXP 29
1203: PUSH
1204: LD_STRING Houten
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_EXP 4
1217: PPUSH
1218: CALL 48578 0 3
1222: ST_TO_ADDR
// if not Houten then
1223: LD_EXP 29
1227: NOT
1228: IFFALSE 1243
// Houten := CreateCharacter ( 10_Houten ) ;
1230: LD_ADDR_EXP 29
1234: PUSH
1235: LD_STRING 10_Houten
1237: PPUSH
1238: CALL_OW 34
1242: ST_TO_ADDR
// if not Houten then
1243: LD_EXP 29
1247: NOT
1248: IFFALSE 1263
// Houten := CreateCharacter ( 09_Houten ) ;
1250: LD_ADDR_EXP 29
1254: PUSH
1255: LD_STRING 09_Houten
1257: PPUSH
1258: CALL_OW 34
1262: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1263: LD_ADDR_EXP 31
1267: PUSH
1268: LD_STRING Cornell
1270: PPUSH
1271: LD_EXP 1
1275: NOT
1276: PPUSH
1277: LD_EXP 4
1281: PPUSH
1282: CALL 48578 0 3
1286: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1287: LD_ADDR_EXP 32
1291: PUSH
1292: LD_STRING Gary
1294: PPUSH
1295: LD_EXP 1
1299: NOT
1300: PPUSH
1301: LD_EXP 4
1305: PPUSH
1306: CALL 48578 0 3
1310: ST_TO_ADDR
// if not Gary then
1311: LD_EXP 32
1315: NOT
1316: IFFALSE 1331
// Gary := CreateCharacter ( 10_Gary ) ;
1318: LD_ADDR_EXP 32
1322: PUSH
1323: LD_STRING 10_Gary
1325: PPUSH
1326: CALL_OW 34
1330: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1331: LD_ADDR_EXP 33
1335: PUSH
1336: LD_STRING Frank
1338: PPUSH
1339: LD_EXP 1
1343: NOT
1344: PPUSH
1345: LD_EXP 4
1349: PPUSH
1350: CALL 48578 0 3
1354: ST_TO_ADDR
// if not Frank then
1355: LD_EXP 33
1359: NOT
1360: IFFALSE 1375
// Frank := CreateCharacter ( 08_Frank ) ;
1362: LD_ADDR_EXP 33
1366: PUSH
1367: LD_STRING 08_Frank
1369: PPUSH
1370: CALL_OW 34
1374: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1375: LD_ADDR_EXP 34
1379: PUSH
1380: LD_STRING Kikuchi
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_EXP 4
1393: PPUSH
1394: CALL 48578 0 3
1398: ST_TO_ADDR
// if not Kikuchi then
1399: LD_EXP 34
1403: NOT
1404: IFFALSE 1419
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1406: LD_ADDR_EXP 34
1410: PUSH
1411: LD_STRING 08_Kikuchi
1413: PPUSH
1414: CALL_OW 34
1418: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1419: LD_ADDR_VAR 0 5
1423: PUSH
1424: LD_EXP 22
1428: PUSH
1429: LD_EXP 23
1433: PUSH
1434: LD_EXP 24
1438: PUSH
1439: LD_EXP 25
1443: PUSH
1444: LD_EXP 26
1448: PUSH
1449: LD_EXP 27
1453: PUSH
1454: LD_EXP 28
1458: PUSH
1459: LD_EXP 29
1463: PUSH
1464: LD_EXP 31
1468: PUSH
1469: LD_EXP 32
1473: PUSH
1474: LD_EXP 33
1478: PUSH
1479: LD_EXP 34
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: ST_TO_ADDR
// tmp := tmp diff 0 ;
1498: LD_ADDR_VAR 0 5
1502: PUSH
1503: LD_VAR 0 5
1507: PUSH
1508: LD_INT 0
1510: DIFF
1511: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1512: LD_ADDR_VAR 0 5
1516: PUSH
1517: LD_VAR 0 5
1521: PUSH
1522: LD_STRING 10_lock
1524: PPUSH
1525: CALL_OW 31
1529: UNION
1530: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1531: LD_ADDR_VAR 0 5
1535: PUSH
1536: LD_VAR 0 5
1540: PUSH
1541: LD_STRING 10c_lock
1543: PPUSH
1544: CALL_OW 31
1548: UNION
1549: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1550: LD_STRING 10_lock
1552: PPUSH
1553: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1557: LD_STRING 10c_lock
1559: PPUSH
1560: CALL_OW 40
// for i in tmp do
1564: LD_ADDR_VAR 0 2
1568: PUSH
1569: LD_VAR 0 5
1573: PUSH
1574: FOR_IN
1575: IFFALSE 1613
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1577: LD_VAR 0 2
1581: PPUSH
1582: CALL_OW 257
1586: PUSH
1587: LD_INT 8
1589: PUSH
1590: LD_INT 2
1592: PUSH
1593: EMPTY
1594: LIST
1595: LIST
1596: IN
1597: IFFALSE 1611
// SetClass ( i , class_soldier ) ;
1599: LD_VAR 0 2
1603: PPUSH
1604: LD_INT 1
1606: PPUSH
1607: CALL_OW 336
1611: GO 1574
1613: POP
1614: POP
// if tmp < 12 then
1615: LD_VAR 0 5
1619: PUSH
1620: LD_INT 12
1622: LESS
1623: IFFALSE 1717
// begin k := 16 - tmp ;
1625: LD_ADDR_VAR 0 3
1629: PUSH
1630: LD_INT 16
1632: PUSH
1633: LD_VAR 0 5
1637: MINUS
1638: ST_TO_ADDR
// for i = 1 to k do
1639: LD_ADDR_VAR 0 2
1643: PUSH
1644: DOUBLE
1645: LD_INT 1
1647: DEC
1648: ST_TO_ADDR
1649: LD_VAR 0 3
1653: PUSH
1654: FOR_TO
1655: IFFALSE 1715
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1657: LD_INT 0
1659: PPUSH
1660: LD_INT 1
1662: PUSH
1663: LD_INT 1
1665: PUSH
1666: LD_INT 3
1668: PUSH
1669: LD_INT 4
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: PUSH
1678: LD_INT 1
1680: PPUSH
1681: LD_INT 4
1683: PPUSH
1684: CALL_OW 12
1688: ARRAY
1689: PPUSH
1690: LD_INT 6
1692: PPUSH
1693: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1697: LD_ADDR_VAR 0 5
1701: PUSH
1702: LD_VAR 0 5
1706: PUSH
1707: CALL_OW 44
1711: ADD
1712: ST_TO_ADDR
// end ;
1713: GO 1654
1715: POP
1716: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1717: LD_ADDR_EXP 19
1721: PUSH
1722: LD_STRING 1
1724: PPUSH
1725: LD_INT 12
1727: PPUSH
1728: LD_INT 12
1730: PPUSH
1731: LD_INT -5
1733: PUSH
1734: LD_EXP 21
1738: PUSH
1739: LD_INT -2
1741: PUSH
1742: LD_INT -3
1744: PUSH
1745: LD_INT -5
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: PUSH
1755: LD_VAR 0 5
1759: ADD
1760: PUSH
1761: LD_INT -6
1763: PUSH
1764: LD_INT -4
1766: PUSH
1767: LD_EXP 30
1771: PUSH
1772: EMPTY
1773: LIST
1774: LIST
1775: LIST
1776: ADD
1777: PPUSH
1778: LD_INT 1
1780: PUSH
1781: LD_INT 4
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: PUSH
1788: LD_INT 3
1790: PUSH
1791: LD_INT 0
1793: PUSH
1794: LD_INT 5
1796: PUSH
1797: EMPTY
1798: LIST
1799: LIST
1800: LIST
1801: PUSH
1802: LD_INT 4
1804: PUSH
1805: LD_INT 0
1807: PUSH
1808: LD_INT 3
1810: PUSH
1811: EMPTY
1812: LIST
1813: LIST
1814: LIST
1815: PUSH
1816: LD_INT 5
1818: PUSH
1819: LD_INT 0
1821: PUSH
1822: LD_INT 2
1824: PUSH
1825: EMPTY
1826: LIST
1827: LIST
1828: LIST
1829: PUSH
1830: EMPTY
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: PPUSH
1836: CALL_OW 42
1840: ST_TO_ADDR
// others := tmp diff selected ;
1841: LD_ADDR_VAR 0 8
1845: PUSH
1846: LD_VAR 0 5
1850: PUSH
1851: LD_EXP 19
1855: DIFF
1856: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1857: LD_ADDR_VAR 0 8
1861: PUSH
1862: LD_VAR 0 8
1866: PUSH
1867: LD_EXP 22
1871: PUSH
1872: LD_EXP 23
1876: PUSH
1877: LD_EXP 24
1881: PUSH
1882: LD_EXP 25
1886: PUSH
1887: LD_EXP 26
1891: PUSH
1892: LD_EXP 27
1896: PUSH
1897: LD_EXP 28
1901: PUSH
1902: LD_EXP 29
1906: PUSH
1907: LD_EXP 31
1911: PUSH
1912: LD_EXP 32
1916: PUSH
1917: LD_EXP 33
1921: PUSH
1922: LD_EXP 34
1926: PUSH
1927: EMPTY
1928: LIST
1929: LIST
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: DIFF
1941: ST_TO_ADDR
// if others then
1942: LD_VAR 0 8
1946: IFFALSE 1960
// SaveCharacters ( others , 11_others ) ;
1948: LD_VAR 0 8
1952: PPUSH
1953: LD_STRING 11_others
1955: PPUSH
1956: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1960: LD_ADDR_VAR 0 6
1964: PUSH
1965: LD_INT 3
1967: PUSH
1968: LD_INT 1
1970: PUSH
1971: LD_INT 1
1973: PUSH
1974: LD_INT 4
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: PUSH
1983: LD_INT 2
1985: PUSH
1986: LD_INT 2
1988: PUSH
1989: LD_INT 1
1991: PUSH
1992: LD_INT 5
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: PUSH
2001: LD_INT 4
2003: PUSH
2004: LD_INT 1
2006: PUSH
2007: LD_INT 1
2009: PUSH
2010: LD_INT 5
2012: PUSH
2013: EMPTY
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: PUSH
2019: LD_INT 2
2021: PUSH
2022: LD_INT 1
2024: PUSH
2025: LD_INT 1
2027: PUSH
2028: LD_INT 7
2030: PUSH
2031: EMPTY
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: PUSH
2037: LD_INT 3
2039: PUSH
2040: LD_INT 2
2042: PUSH
2043: LD_INT 1
2045: PUSH
2046: LD_INT 7
2048: PUSH
2049: EMPTY
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PUSH
2055: EMPTY
2056: LIST
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: ST_TO_ADDR
// for i in JMM ^ selected do
2062: LD_ADDR_VAR 0 2
2066: PUSH
2067: LD_EXP 21
2071: PUSH
2072: LD_EXP 19
2076: ADD
2077: PUSH
2078: FOR_IN
2079: IFFALSE 2268
// begin if GetClass ( i ) = 3 then
2081: LD_VAR 0 2
2085: PPUSH
2086: CALL_OW 257
2090: PUSH
2091: LD_INT 3
2093: EQUAL
2094: IFFALSE 2251
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2096: LD_ADDR_OWVAR 37
2100: PUSH
2101: LD_VAR 0 6
2105: PUSH
2106: LD_INT 1
2108: ARRAY
2109: PUSH
2110: LD_INT 1
2112: ARRAY
2113: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2114: LD_ADDR_OWVAR 39
2118: PUSH
2119: LD_VAR 0 6
2123: PUSH
2124: LD_INT 1
2126: ARRAY
2127: PUSH
2128: LD_INT 2
2130: ARRAY
2131: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2132: LD_ADDR_OWVAR 38
2136: PUSH
2137: LD_VAR 0 6
2141: PUSH
2142: LD_INT 1
2144: ARRAY
2145: PUSH
2146: LD_INT 3
2148: ARRAY
2149: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2150: LD_ADDR_OWVAR 40
2154: PUSH
2155: LD_VAR 0 6
2159: PUSH
2160: LD_INT 1
2162: ARRAY
2163: PUSH
2164: LD_INT 4
2166: ARRAY
2167: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2168: LD_ADDR_VAR 0 6
2172: PUSH
2173: LD_VAR 0 6
2177: PPUSH
2178: LD_INT 1
2180: PPUSH
2181: CALL_OW 3
2185: ST_TO_ADDR
// veh := CreateVehicle ;
2186: LD_ADDR_VAR 0 7
2190: PUSH
2191: CALL_OW 45
2195: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2196: LD_VAR 0 7
2200: PPUSH
2201: LD_INT 8
2203: PPUSH
2204: LD_INT 0
2206: PPUSH
2207: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2211: LD_VAR 0 2
2215: PPUSH
2216: LD_VAR 0 7
2220: PPUSH
2221: CALL_OW 52
// if i = JMM then
2225: LD_VAR 0 2
2229: PUSH
2230: LD_EXP 21
2234: EQUAL
2235: IFFALSE 2249
// SetMark ( veh , 1 ) ;
2237: LD_VAR 0 7
2241: PPUSH
2242: LD_INT 1
2244: PPUSH
2245: CALL_OW 242
// end else
2249: GO 2266
// PlaceUnitArea ( i , am_hum_start , false ) ;
2251: LD_VAR 0 2
2255: PPUSH
2256: LD_INT 9
2258: PPUSH
2259: LD_INT 0
2261: PPUSH
2262: CALL_OW 49
// end ;
2266: GO 2078
2268: POP
2269: POP
// vc_chassis := us_medium_tracked ;
2270: LD_ADDR_OWVAR 37
2274: PUSH
2275: LD_INT 3
2277: ST_TO_ADDR
// vc_engine := engine_solar ;
2278: LD_ADDR_OWVAR 39
2282: PUSH
2283: LD_INT 2
2285: ST_TO_ADDR
// vc_control := control_computer ;
2286: LD_ADDR_OWVAR 38
2290: PUSH
2291: LD_INT 3
2293: ST_TO_ADDR
// vc_weapon := us_radar ;
2294: LD_ADDR_OWVAR 40
2298: PUSH
2299: LD_INT 11
2301: ST_TO_ADDR
// veh := CreateVehicle ;
2302: LD_ADDR_VAR 0 7
2306: PUSH
2307: CALL_OW 45
2311: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2312: LD_VAR 0 7
2316: PPUSH
2317: LD_INT 87
2319: PPUSH
2320: LD_INT 142
2322: PPUSH
2323: LD_INT 0
2325: PPUSH
2326: CALL_OW 48
// end ;
2330: LD_VAR 0 1
2334: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2335: LD_INT 0
2337: PPUSH
2338: PPUSH
2339: PPUSH
2340: PPUSH
// uc_side := 1 ;
2341: LD_ADDR_OWVAR 20
2345: PUSH
2346: LD_INT 1
2348: ST_TO_ADDR
// uc_nation := 1 ;
2349: LD_ADDR_OWVAR 21
2353: PUSH
2354: LD_INT 1
2356: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2357: LD_ADDR_VAR 0 3
2361: PUSH
2362: LD_INT 3
2364: PUSH
2365: LD_INT 1
2367: PUSH
2368: LD_INT 3
2370: PUSH
2371: LD_INT 5
2373: PUSH
2374: EMPTY
2375: LIST
2376: LIST
2377: LIST
2378: LIST
2379: PUSH
2380: LD_INT 3
2382: PUSH
2383: LD_INT 1
2385: PUSH
2386: LD_INT 3
2388: PUSH
2389: LD_INT 7
2391: PUSH
2392: EMPTY
2393: LIST
2394: LIST
2395: LIST
2396: LIST
2397: PUSH
2398: LD_INT 3
2400: PUSH
2401: LD_INT 1
2403: PUSH
2404: LD_INT 3
2406: PUSH
2407: LD_INT 7
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 1
2421: PUSH
2422: LD_INT 3
2424: PUSH
2425: LD_INT 11
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: PUSH
2434: LD_INT 4
2436: PUSH
2437: LD_INT 1
2439: PUSH
2440: LD_INT 3
2442: PUSH
2443: LD_INT 6
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: LIST
2450: LIST
2451: PUSH
2452: LD_INT 4
2454: PUSH
2455: LD_INT 1
2457: PUSH
2458: LD_INT 3
2460: PUSH
2461: LD_INT 5
2463: PUSH
2464: EMPTY
2465: LIST
2466: LIST
2467: LIST
2468: LIST
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: LIST
2477: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2478: LD_ADDR_VAR 0 2
2482: PUSH
2483: DOUBLE
2484: LD_INT 1
2486: DEC
2487: ST_TO_ADDR
2488: LD_INT 7
2490: PUSH
2491: LD_OWVAR 67
2495: MINUS
2496: PUSH
2497: FOR_TO
2498: IFFALSE 2607
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2500: LD_ADDR_OWVAR 37
2504: PUSH
2505: LD_VAR 0 3
2509: PUSH
2510: LD_VAR 0 2
2514: ARRAY
2515: PUSH
2516: LD_INT 1
2518: ARRAY
2519: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2520: LD_ADDR_OWVAR 39
2524: PUSH
2525: LD_VAR 0 3
2529: PUSH
2530: LD_VAR 0 2
2534: ARRAY
2535: PUSH
2536: LD_INT 2
2538: ARRAY
2539: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2540: LD_ADDR_OWVAR 38
2544: PUSH
2545: LD_VAR 0 3
2549: PUSH
2550: LD_VAR 0 2
2554: ARRAY
2555: PUSH
2556: LD_INT 3
2558: ARRAY
2559: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2560: LD_ADDR_OWVAR 40
2564: PUSH
2565: LD_VAR 0 3
2569: PUSH
2570: LD_VAR 0 2
2574: ARRAY
2575: PUSH
2576: LD_INT 4
2578: ARRAY
2579: ST_TO_ADDR
// veh := CreateVehicle ;
2580: LD_ADDR_VAR 0 4
2584: PUSH
2585: CALL_OW 45
2589: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2590: LD_VAR 0 4
2594: PPUSH
2595: LD_INT 8
2597: PPUSH
2598: LD_INT 0
2600: PPUSH
2601: CALL_OW 49
// end ;
2605: GO 2497
2607: POP
2608: POP
// end ; end_of_file
2609: LD_VAR 0 1
2613: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2614: LD_INT 0
2616: PPUSH
2617: PPUSH
2618: PPUSH
2619: PPUSH
2620: PPUSH
2621: PPUSH
// if Difficulty = 1 then
2622: LD_OWVAR 67
2626: PUSH
2627: LD_INT 1
2629: EQUAL
2630: IFFALSE 2727
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2632: LD_ADDR_VAR 0 6
2636: PUSH
2637: LD_INT 129
2639: PUSH
2640: LD_INT 45
2642: PUSH
2643: EMPTY
2644: LIST
2645: LIST
2646: PUSH
2647: LD_INT 143
2649: PUSH
2650: LD_INT 58
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 184
2659: PUSH
2660: LD_INT 113
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PUSH
2667: LD_INT 163
2669: PUSH
2670: LD_INT 107
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PUSH
2677: EMPTY
2678: LIST
2679: LIST
2680: LIST
2681: LIST
2682: ST_TO_ADDR
// for i in tmp do
2683: LD_ADDR_VAR 0 2
2687: PUSH
2688: LD_VAR 0 6
2692: PUSH
2693: FOR_IN
2694: IFFALSE 2725
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2696: LD_VAR 0 2
2700: PUSH
2701: LD_INT 1
2703: ARRAY
2704: PPUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_INT 2
2712: ARRAY
2713: PPUSH
2714: CALL_OW 428
2718: PPUSH
2719: CALL_OW 64
2723: GO 2693
2725: POP
2726: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2727: LD_ADDR_VAR 0 2
2731: PUSH
2732: LD_INT 21
2734: PUSH
2735: LD_INT 3
2737: PUSH
2738: EMPTY
2739: LIST
2740: LIST
2741: PPUSH
2742: CALL_OW 69
2746: PUSH
2747: FOR_IN
2748: IFFALSE 2785
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2750: LD_VAR 0 2
2754: PPUSH
2755: LD_INT 5
2757: PUSH
2758: LD_INT 6
2760: PUSH
2761: LD_INT 7
2763: PUSH
2764: LD_INT 8
2766: PUSH
2767: EMPTY
2768: LIST
2769: LIST
2770: LIST
2771: LIST
2772: PUSH
2773: LD_OWVAR 67
2777: ARRAY
2778: PPUSH
2779: CALL_OW 241
2783: GO 2747
2785: POP
2786: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2787: LD_ADDR_VAR 0 5
2791: PUSH
2792: LD_INT 5
2794: PUSH
2795: LD_INT 6
2797: PUSH
2798: LD_INT 7
2800: PUSH
2801: LD_INT 8
2803: PUSH
2804: EMPTY
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: PUSH
2810: LD_OWVAR 67
2814: ARRAY
2815: ST_TO_ADDR
// uc_side := 2 ;
2816: LD_ADDR_OWVAR 20
2820: PUSH
2821: LD_INT 2
2823: ST_TO_ADDR
// uc_nation := 2 ;
2824: LD_ADDR_OWVAR 21
2828: PUSH
2829: LD_INT 2
2831: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2832: LD_ADDR_OWVAR 37
2836: PUSH
2837: LD_INT 14
2839: ST_TO_ADDR
// vc_engine := engine_siberite ;
2840: LD_ADDR_OWVAR 39
2844: PUSH
2845: LD_INT 3
2847: ST_TO_ADDR
// vc_control := control_manual ;
2848: LD_ADDR_OWVAR 38
2852: PUSH
2853: LD_INT 1
2855: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2856: LD_ADDR_OWVAR 40
2860: PUSH
2861: LD_INT 31
2863: ST_TO_ADDR
// for i = 1 to 3 do
2864: LD_ADDR_VAR 0 2
2868: PUSH
2869: DOUBLE
2870: LD_INT 1
2872: DEC
2873: ST_TO_ADDR
2874: LD_INT 3
2876: PUSH
2877: FOR_TO
2878: IFFALSE 2962
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2880: LD_INT 0
2882: PPUSH
2883: LD_INT 3
2885: PPUSH
2886: LD_VAR 0 5
2890: PPUSH
2891: CALL_OW 380
// un := CreateVehicle ;
2895: LD_ADDR_VAR 0 4
2899: PUSH
2900: CALL_OW 45
2904: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2905: LD_VAR 0 4
2909: PPUSH
2910: LD_INT 0
2912: PPUSH
2913: LD_INT 5
2915: PPUSH
2916: CALL_OW 12
2920: PPUSH
2921: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2925: LD_VAR 0 4
2929: PPUSH
2930: LD_INT 156
2932: PPUSH
2933: LD_INT 15
2935: PPUSH
2936: LD_INT 6
2938: PPUSH
2939: LD_INT 0
2941: PPUSH
2942: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2946: CALL_OW 44
2950: PPUSH
2951: LD_VAR 0 4
2955: PPUSH
2956: CALL_OW 52
// end ;
2960: GO 2877
2962: POP
2963: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2964: LD_ADDR_EXP 37
2968: PUSH
2969: LD_INT 94
2971: PPUSH
2972: LD_INT 28
2974: PPUSH
2975: LD_STRING dammam
2977: PPUSH
2978: LD_VAR 0 5
2982: PPUSH
2983: LD_INT 10000
2985: PUSH
2986: LD_INT 1000
2988: PUSH
2989: LD_INT 300
2991: PUSH
2992: EMPTY
2993: LIST
2994: LIST
2995: LIST
2996: PPUSH
2997: LD_INT 12
2999: PUSH
3000: LD_INT 2
3002: PUSH
3003: LD_INT 3
3005: PUSH
3006: LD_INT 4
3008: PUSH
3009: LD_INT 4
3011: PUSH
3012: EMPTY
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: PUSH
3018: LD_OWVAR 67
3022: ARRAY
3023: PUSH
3024: LD_INT 1
3026: NEG
3027: PUSH
3028: LD_INT 4
3030: PUSH
3031: EMPTY
3032: LIST
3033: LIST
3034: LIST
3035: LIST
3036: PPUSH
3037: CALL 56888 0 6
3041: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3042: LD_ADDR_EXP 37
3046: PUSH
3047: LD_EXP 37
3051: PUSH
3052: LD_INT 122
3054: PPUSH
3055: LD_INT 25
3057: PPUSH
3058: LD_STRING 
3060: PPUSH
3061: LD_VAR 0 5
3065: PPUSH
3066: LD_INT 500
3068: PUSH
3069: LD_INT 60
3071: PUSH
3072: LD_INT 0
3074: PUSH
3075: EMPTY
3076: LIST
3077: LIST
3078: LIST
3079: PPUSH
3080: LD_INT 8
3082: PUSH
3083: LD_INT 2
3085: PUSH
3086: LD_INT 3
3088: PUSH
3089: LD_INT 4
3091: PUSH
3092: LD_INT 5
3094: PUSH
3095: EMPTY
3096: LIST
3097: LIST
3098: LIST
3099: LIST
3100: PUSH
3101: LD_OWVAR 67
3105: ARRAY
3106: PUSH
3107: LD_INT 2
3109: PUSH
3110: LD_INT 0
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: LIST
3117: LIST
3118: PPUSH
3119: CALL 56888 0 6
3123: UNION
3124: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3125: LD_ADDR_EXP 35
3129: PUSH
3130: LD_INT 45
3132: PPUSH
3133: LD_INT 24
3135: PPUSH
3136: LD_STRING jeddah
3138: PPUSH
3139: LD_VAR 0 5
3143: PPUSH
3144: LD_INT 700
3146: PUSH
3147: LD_INT 300
3149: PUSH
3150: LD_INT 10
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: LIST
3157: PPUSH
3158: LD_INT 9
3160: PUSH
3161: LD_INT 4
3163: PUSH
3164: LD_INT 3
3166: PUSH
3167: LD_INT 2
3169: PUSH
3170: EMPTY
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: PPUSH
3176: CALL 56888 0 6
3180: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3181: LD_ADDR_EXP 36
3185: PUSH
3186: LD_INT 7
3188: PPUSH
3189: LD_INT 27
3191: PPUSH
3192: LD_STRING riyadh
3194: PPUSH
3195: LD_VAR 0 5
3199: PPUSH
3200: LD_INT 500
3202: PUSH
3203: LD_INT 60
3205: PUSH
3206: LD_INT 0
3208: PUSH
3209: EMPTY
3210: LIST
3211: LIST
3212: LIST
3213: PPUSH
3214: LD_INT 4
3216: PUSH
3217: LD_INT 2
3219: PUSH
3220: LD_INT 3
3222: PUSH
3223: LD_INT 1
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: PPUSH
3232: CALL 56888 0 6
3236: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3237: LD_ADDR_EXP 39
3241: PUSH
3242: LD_INT 204
3244: PPUSH
3245: LD_INT 26
3247: PPUSH
3248: LD_STRING 
3250: PPUSH
3251: LD_VAR 0 5
3255: PPUSH
3256: LD_INT 500
3258: PUSH
3259: LD_INT 50
3261: PUSH
3262: LD_INT 0
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: LIST
3269: PPUSH
3270: LD_INT 9
3272: PUSH
3273: LD_INT 2
3275: PUSH
3276: LD_INT 3
3278: PUSH
3279: LD_INT 1
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: PPUSH
3288: CALL 56888 0 6
3292: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3293: LD_ADDR_EXP 50
3297: PUSH
3298: LD_EXP 37
3302: PUSH
3303: LD_EXP 35
3307: PUSH
3308: LD_EXP 39
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: LIST
3317: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3318: LD_ADDR_VAR 0 2
3322: PUSH
3323: LD_INT 22
3325: PUSH
3326: LD_INT 2
3328: PUSH
3329: EMPTY
3330: LIST
3331: LIST
3332: PUSH
3333: LD_INT 30
3335: PUSH
3336: LD_INT 31
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 58
3345: PUSH
3346: EMPTY
3347: LIST
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: PPUSH
3354: CALL_OW 69
3358: PUSH
3359: FOR_IN
3360: IFFALSE 3485
// begin if GetBase ( i ) then
3362: LD_VAR 0 2
3366: PPUSH
3367: CALL_OW 274
3371: IFFALSE 3375
// continue ;
3373: GO 3359
// d := GetDir ( i ) ;
3375: LD_ADDR_VAR 0 3
3379: PUSH
3380: LD_VAR 0 2
3384: PPUSH
3385: CALL_OW 254
3389: ST_TO_ADDR
// if d < 3 then
3390: LD_VAR 0 3
3394: PUSH
3395: LD_INT 3
3397: LESS
3398: IFFALSE 3416
// d := d + 3 else
3400: LD_ADDR_VAR 0 3
3404: PUSH
3405: LD_VAR 0 3
3409: PUSH
3410: LD_INT 3
3412: PLUS
3413: ST_TO_ADDR
3414: GO 3430
// d := d - 3 ;
3416: LD_ADDR_VAR 0 3
3420: PUSH
3421: LD_VAR 0 3
3425: PUSH
3426: LD_INT 3
3428: MINUS
3429: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3430: LD_INT 0
3432: PPUSH
3433: LD_INT 8
3435: PPUSH
3436: LD_VAR 0 5
3440: PPUSH
3441: CALL_OW 380
// un := CreateHuman ;
3445: LD_ADDR_VAR 0 4
3449: PUSH
3450: CALL_OW 44
3454: ST_TO_ADDR
// SetDir ( un , d ) ;
3455: LD_VAR 0 4
3459: PPUSH
3460: LD_VAR 0 3
3464: PPUSH
3465: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3469: LD_VAR 0 4
3473: PPUSH
3474: LD_VAR 0 2
3478: PPUSH
3479: CALL_OW 52
// end ;
3483: GO 3359
3485: POP
3486: POP
// if Difficulty > 1 then
3487: LD_OWVAR 67
3491: PUSH
3492: LD_INT 1
3494: GREATER
3495: IFFALSE 3866
// begin ar_kamikadze := [ ] ;
3497: LD_ADDR_EXP 42
3501: PUSH
3502: EMPTY
3503: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3504: LD_INT 0
3506: PPUSH
3507: LD_INT 1
3509: PPUSH
3510: LD_VAR 0 5
3514: PPUSH
3515: CALL_OW 380
// un := CreateHuman ;
3519: LD_ADDR_VAR 0 4
3523: PUSH
3524: CALL_OW 44
3528: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3529: LD_VAR 0 4
3533: PPUSH
3534: LD_INT 3
3536: PPUSH
3537: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3541: LD_VAR 0 4
3545: PPUSH
3546: LD_INT 23
3548: PPUSH
3549: LD_INT 44
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// ComCrawl ( un ) ;
3559: LD_VAR 0 4
3563: PPUSH
3564: CALL_OW 137
// un := CreateHuman ;
3568: LD_ADDR_VAR 0 4
3572: PUSH
3573: CALL_OW 44
3577: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3578: LD_VAR 0 4
3582: PPUSH
3583: LD_INT 3
3585: PPUSH
3586: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3590: LD_VAR 0 4
3594: PPUSH
3595: LD_INT 30
3597: PPUSH
3598: LD_INT 39
3600: PPUSH
3601: LD_INT 0
3603: PPUSH
3604: CALL_OW 48
// ComCrawl ( un ) ;
3608: LD_VAR 0 4
3612: PPUSH
3613: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3617: LD_INT 0
3619: PPUSH
3620: LD_INT 17
3622: PPUSH
3623: LD_VAR 0 5
3627: PPUSH
3628: CALL_OW 380
// un := CreateHuman ;
3632: LD_ADDR_VAR 0 4
3636: PUSH
3637: CALL_OW 44
3641: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3642: LD_VAR 0 4
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3654: LD_VAR 0 4
3658: PPUSH
3659: LD_INT 45
3661: PPUSH
3662: LD_INT 86
3664: PPUSH
3665: LD_INT 0
3667: PPUSH
3668: CALL_OW 48
// ComHold ( un ) ;
3672: LD_VAR 0 4
3676: PPUSH
3677: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3681: LD_ADDR_EXP 42
3685: PUSH
3686: LD_EXP 42
3690: PPUSH
3691: LD_EXP 42
3695: PUSH
3696: LD_INT 1
3698: PLUS
3699: PPUSH
3700: LD_VAR 0 4
3704: PPUSH
3705: CALL_OW 1
3709: ST_TO_ADDR
// un := CreateHuman ;
3710: LD_ADDR_VAR 0 4
3714: PUSH
3715: CALL_OW 44
3719: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3720: LD_VAR 0 4
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3732: LD_VAR 0 4
3736: PPUSH
3737: LD_INT 60
3739: PPUSH
3740: LD_INT 85
3742: PPUSH
3743: LD_INT 0
3745: PPUSH
3746: CALL_OW 48
// ComHold ( un ) ;
3750: LD_VAR 0 4
3754: PPUSH
3755: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3759: LD_ADDR_EXP 42
3763: PUSH
3764: LD_EXP 42
3768: PPUSH
3769: LD_EXP 42
3773: PUSH
3774: LD_INT 1
3776: PLUS
3777: PPUSH
3778: LD_VAR 0 4
3782: PPUSH
3783: CALL_OW 1
3787: ST_TO_ADDR
// un := CreateHuman ;
3788: LD_ADDR_VAR 0 4
3792: PUSH
3793: CALL_OW 44
3797: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3798: LD_VAR 0 4
3802: PPUSH
3803: LD_INT 3
3805: PPUSH
3806: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3810: LD_VAR 0 4
3814: PPUSH
3815: LD_INT 222
3817: PPUSH
3818: LD_INT 166
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 48
// ComHold ( un ) ;
3828: LD_VAR 0 4
3832: PPUSH
3833: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3837: LD_ADDR_EXP 42
3841: PUSH
3842: LD_EXP 42
3846: PPUSH
3847: LD_EXP 42
3851: PUSH
3852: LD_INT 1
3854: PLUS
3855: PPUSH
3856: LD_VAR 0 4
3860: PPUSH
3861: CALL_OW 1
3865: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3866: LD_ADDR_EXP 40
3870: PUSH
3871: EMPTY
3872: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3873: LD_INT 1
3875: PPUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_VAR 0 5
3883: PPUSH
3884: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3888: LD_ADDR_OWVAR 26
3892: PUSH
3893: LD_STRING Pavel Grigorovic
3895: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3896: LD_ADDR_OWVAR 33
3900: PUSH
3901: LD_STRING SecondCharsGal
3903: ST_TO_ADDR
// hc_face_number := 4 ;
3904: LD_ADDR_OWVAR 34
3908: PUSH
3909: LD_INT 4
3911: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3912: LD_ADDR_EXP 40
3916: PUSH
3917: LD_EXP 40
3921: PPUSH
3922: LD_INT 1
3924: PPUSH
3925: CALL_OW 44
3929: PPUSH
3930: CALL_OW 1
3934: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3935: LD_INT 2
3937: PPUSH
3938: LD_INT 4
3940: PPUSH
3941: LD_INT 2
3943: PPUSH
3944: CALL_OW 380
// hc_name := Lucy Sebel ;
3948: LD_ADDR_OWVAR 26
3952: PUSH
3953: LD_STRING Lucy Sebel
3955: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3956: LD_ADDR_OWVAR 33
3960: PUSH
3961: LD_STRING SecondCharsGal
3963: ST_TO_ADDR
// hc_face_number := 15 ;
3964: LD_ADDR_OWVAR 34
3968: PUSH
3969: LD_INT 15
3971: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3972: LD_ADDR_EXP 40
3976: PUSH
3977: LD_EXP 40
3981: PPUSH
3982: LD_INT 2
3984: PPUSH
3985: CALL_OW 44
3989: PPUSH
3990: CALL_OW 1
3994: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3995: LD_INT 2
3997: PPUSH
3998: LD_INT 4
4000: PPUSH
4001: LD_INT 2
4003: PPUSH
4004: CALL_OW 380
// hc_gallery :=  ;
4008: LD_ADDR_OWVAR 33
4012: PUSH
4013: LD_STRING 
4015: ST_TO_ADDR
// hc_name :=  ;
4016: LD_ADDR_OWVAR 26
4020: PUSH
4021: LD_STRING 
4023: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4024: LD_ADDR_EXP 40
4028: PUSH
4029: LD_EXP 40
4033: PPUSH
4034: LD_INT 3
4036: PPUSH
4037: CALL_OW 44
4041: PPUSH
4042: CALL_OW 1
4046: ST_TO_ADDR
// hc_sex := sex_male ;
4047: LD_ADDR_OWVAR 27
4051: PUSH
4052: LD_INT 1
4054: ST_TO_ADDR
// hc_class = 11 ;
4055: LD_ADDR_OWVAR 28
4059: PUSH
4060: LD_INT 11
4062: ST_TO_ADDR
// hc_gallery = sandar ;
4063: LD_ADDR_OWVAR 33
4067: PUSH
4068: LD_STRING sandar
4070: ST_TO_ADDR
// hc_face_number = 33 ;
4071: LD_ADDR_OWVAR 34
4075: PUSH
4076: LD_INT 33
4078: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4079: LD_ADDR_OWVAR 26
4083: PUSH
4084: LD_STRING Thabit Muhair Saliba
4086: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4087: LD_ADDR_OWVAR 31
4091: PUSH
4092: LD_INT 0
4094: PUSH
4095: LD_INT 0
4097: PUSH
4098: LD_INT 0
4100: PUSH
4101: LD_INT 0
4103: PUSH
4104: EMPTY
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: ST_TO_ADDR
// Saliba = CreateHuman ;
4110: LD_ADDR_EXP 44
4114: PUSH
4115: CALL_OW 44
4119: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4120: LD_EXP 44
4124: PPUSH
4125: LD_INT 7
4127: PPUSH
4128: CALL_OW 52
// if gensher_active then
4132: LD_EXP 18
4136: IFFALSE 4163
// begin Gensher = NewCharacter ( Dietrich ) ;
4138: LD_ADDR_EXP 45
4142: PUSH
4143: LD_STRING Dietrich
4145: PPUSH
4146: CALL_OW 25
4150: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4151: LD_EXP 45
4155: PPUSH
4156: LD_INT 94
4158: PPUSH
4159: CALL_OW 52
// end ; InitHc ;
4163: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4167: LD_ADDR_EXP 41
4171: PUSH
4172: EMPTY
4173: ST_TO_ADDR
// for i = 1 to 5 do
4174: LD_ADDR_VAR 0 2
4178: PUSH
4179: DOUBLE
4180: LD_INT 1
4182: DEC
4183: ST_TO_ADDR
4184: LD_INT 5
4186: PUSH
4187: FOR_TO
4188: IFFALSE 4360
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4190: LD_INT 13
4192: PUSH
4193: LD_INT 14
4195: PUSH
4196: EMPTY
4197: LIST
4198: LIST
4199: PUSH
4200: LD_INT 1
4202: PPUSH
4203: LD_INT 2
4205: PPUSH
4206: CALL_OW 12
4210: ARRAY
4211: PPUSH
4212: LD_INT 1
4214: PUSH
4215: LD_INT 2
4217: PUSH
4218: EMPTY
4219: LIST
4220: LIST
4221: PUSH
4222: LD_INT 1
4224: PPUSH
4225: LD_INT 2
4227: PPUSH
4228: CALL_OW 12
4232: ARRAY
4233: PPUSH
4234: LD_INT 1
4236: PPUSH
4237: LD_INT 25
4239: PUSH
4240: LD_INT 27
4242: PUSH
4243: LD_INT 26
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: LIST
4250: PUSH
4251: LD_INT 1
4253: PPUSH
4254: LD_INT 3
4256: PPUSH
4257: CALL_OW 12
4261: ARRAY
4262: PPUSH
4263: LD_INT 60
4265: PPUSH
4266: LD_INT 100
4268: PPUSH
4269: CALL_OW 12
4273: PPUSH
4274: CALL 53442 0 5
// un := CreateVehicle ;
4278: LD_ADDR_VAR 0 4
4282: PUSH
4283: CALL_OW 45
4287: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4288: LD_ADDR_EXP 41
4292: PUSH
4293: LD_EXP 41
4297: PPUSH
4298: LD_EXP 41
4302: PUSH
4303: LD_INT 1
4305: PLUS
4306: PPUSH
4307: LD_VAR 0 4
4311: PPUSH
4312: CALL_OW 1
4316: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4317: LD_VAR 0 4
4321: PPUSH
4322: LD_INT 0
4324: PPUSH
4325: LD_INT 5
4327: PPUSH
4328: CALL_OW 12
4332: PPUSH
4333: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4337: LD_VAR 0 4
4341: PPUSH
4342: LD_INT 124
4344: PPUSH
4345: LD_INT 141
4347: PPUSH
4348: LD_INT 8
4350: PPUSH
4351: LD_INT 0
4353: PPUSH
4354: CALL_OW 50
// end ;
4358: GO 4187
4360: POP
4361: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4362: LD_ADDR_EXP 43
4366: PUSH
4367: EMPTY
4368: PUSH
4369: EMPTY
4370: PUSH
4371: EMPTY
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: LIST
4377: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4378: LD_ADDR_VAR 0 3
4382: PUSH
4383: DOUBLE
4384: LD_INT 1
4386: DEC
4387: ST_TO_ADDR
4388: LD_INT 3
4390: PUSH
4391: LD_INT 3
4393: PUSH
4394: LD_INT 4
4396: PUSH
4397: LD_INT 4
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: LIST
4404: LIST
4405: PUSH
4406: LD_OWVAR 67
4410: ARRAY
4411: PUSH
4412: FOR_TO
4413: IFFALSE 4627
// for i = 1 to 3 do
4415: LD_ADDR_VAR 0 2
4419: PUSH
4420: DOUBLE
4421: LD_INT 1
4423: DEC
4424: ST_TO_ADDR
4425: LD_INT 3
4427: PUSH
4428: FOR_TO
4429: IFFALSE 4623
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4431: LD_INT 14
4433: PPUSH
4434: LD_INT 3
4436: PUSH
4437: LD_INT 2
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: PUSH
4444: LD_INT 1
4446: PPUSH
4447: LD_INT 2
4449: PPUSH
4450: CALL_OW 12
4454: ARRAY
4455: PPUSH
4456: LD_INT 1
4458: PUSH
4459: LD_INT 5
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 1
4468: PPUSH
4469: LD_INT 2
4471: PPUSH
4472: CALL_OW 12
4476: ARRAY
4477: PPUSH
4478: LD_INT 25
4480: PUSH
4481: LD_INT 27
4483: PUSH
4484: LD_INT 26
4486: PUSH
4487: LD_INT 28
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: PUSH
4496: LD_INT 1
4498: PPUSH
4499: LD_INT 4
4501: PPUSH
4502: CALL_OW 12
4506: ARRAY
4507: PPUSH
4508: LD_INT 100
4510: PPUSH
4511: CALL 53442 0 5
// un := CreateVehicle ;
4515: LD_ADDR_VAR 0 4
4519: PUSH
4520: CALL_OW 45
4524: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4525: LD_ADDR_EXP 43
4529: PUSH
4530: LD_EXP 43
4534: PPUSH
4535: LD_VAR 0 2
4539: PUSH
4540: LD_EXP 43
4544: PUSH
4545: LD_VAR 0 2
4549: ARRAY
4550: PUSH
4551: LD_INT 1
4553: PLUS
4554: PUSH
4555: EMPTY
4556: LIST
4557: LIST
4558: PPUSH
4559: LD_VAR 0 4
4563: PPUSH
4564: CALL 53564 0 3
4568: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4569: LD_VAR 0 4
4573: PPUSH
4574: LD_INT 0
4576: PPUSH
4577: LD_INT 5
4579: PPUSH
4580: CALL_OW 12
4584: PPUSH
4585: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4589: LD_VAR 0 4
4593: PPUSH
4594: LD_INT 20
4596: PUSH
4597: LD_INT 21
4599: PUSH
4600: LD_INT 22
4602: PUSH
4603: EMPTY
4604: LIST
4605: LIST
4606: LIST
4607: PUSH
4608: LD_VAR 0 2
4612: ARRAY
4613: PPUSH
4614: LD_INT 0
4616: PPUSH
4617: CALL_OW 49
// end ;
4621: GO 4428
4623: POP
4624: POP
4625: GO 4412
4627: POP
4628: POP
// InitHc ;
4629: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4633: LD_INT 4
4635: PPUSH
4636: LD_INT 5
4638: PPUSH
4639: LD_INT 10
4641: PPUSH
4642: LD_INT 5
4644: PPUSH
4645: LD_INT 0
4647: PPUSH
4648: CALL_OW 58
// end ;
4652: LD_VAR 0 1
4656: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4657: LD_EXP 42
4661: IFFALSE 4735
4663: GO 4665
4665: DISABLE
4666: LD_INT 0
4668: PPUSH
// begin enable ;
4669: ENABLE
// for i in ar_kamikadze do
4670: LD_ADDR_VAR 0 1
4674: PUSH
4675: LD_EXP 42
4679: PUSH
4680: FOR_IN
4681: IFFALSE 4733
// if See ( 1 , i ) then
4683: LD_INT 1
4685: PPUSH
4686: LD_VAR 0 1
4690: PPUSH
4691: CALL_OW 292
4695: IFFALSE 4731
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4697: LD_VAR 0 1
4701: PPUSH
4702: LD_INT 81
4704: PUSH
4705: LD_INT 2
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PPUSH
4712: CALL_OW 69
4716: PPUSH
4717: LD_VAR 0 1
4721: PPUSH
4722: CALL_OW 74
4726: PPUSH
4727: CALL_OW 115
4731: GO 4680
4733: POP
4734: POP
// end ;
4735: PPOPN 1
4737: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4738: LD_EXP 13
4742: IFFALSE 5059
4744: GO 4746
4746: DISABLE
4747: LD_INT 0
4749: PPUSH
4750: PPUSH
4751: PPUSH
4752: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4753: LD_INT 35
4755: PPUSH
4756: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4760: LD_INT 1
4762: PPUSH
4763: CALL 42520 0 1
4767: PUSH
4768: LD_INT 0
4770: EQUAL
4771: IFFALSE 4753
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 14
4778: PUSH
4779: LD_INT 3
4781: PUSH
4782: LD_INT 2
4784: PUSH
4785: LD_INT 32
4787: PUSH
4788: EMPTY
4789: LIST
4790: LIST
4791: LIST
4792: LIST
4793: PUSH
4794: EMPTY
4795: LIST
4796: PPUSH
4797: CALL 42124 0 2
// repeat wait ( 0 0$1 ) ;
4801: LD_INT 35
4803: PPUSH
4804: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4808: LD_EXP 69
4812: PUSH
4813: LD_INT 1
4815: ARRAY
4816: PPUSH
4817: LD_INT 33
4819: PUSH
4820: LD_INT 2
4822: PUSH
4823: EMPTY
4824: LIST
4825: LIST
4826: PUSH
4827: LD_INT 34
4829: PUSH
4830: LD_INT 32
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: PPUSH
4841: CALL_OW 72
4845: IFFALSE 4801
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4847: LD_ADDR_VAR 0 2
4851: PUSH
4852: LD_EXP 69
4856: PUSH
4857: LD_INT 1
4859: ARRAY
4860: PPUSH
4861: LD_INT 33
4863: PUSH
4864: LD_INT 2
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: PUSH
4871: LD_INT 34
4873: PUSH
4874: LD_INT 32
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: EMPTY
4882: LIST
4883: LIST
4884: PPUSH
4885: CALL_OW 72
4889: PUSH
4890: LD_INT 1
4892: ARRAY
4893: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4894: LD_ADDR_VAR 0 4
4898: PUSH
4899: LD_INT 5
4901: PPUSH
4902: CALL_OW 469
4906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4907: LD_INT 35
4909: PPUSH
4910: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4914: LD_ADDR_VAR 0 4
4918: PUSH
4919: LD_INT 5
4921: PPUSH
4922: CALL_OW 469
4926: ST_TO_ADDR
// tmp := 100 ;
4927: LD_ADDR_VAR 0 3
4931: PUSH
4932: LD_INT 100
4934: ST_TO_ADDR
// if pos then
4935: LD_VAR 0 4
4939: IFFALSE 4979
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4941: LD_ADDR_VAR 0 3
4945: PUSH
4946: LD_INT 2
4948: PPUSH
4949: LD_VAR 0 4
4953: PUSH
4954: LD_INT 1
4956: ARRAY
4957: PPUSH
4958: LD_VAR 0 4
4962: PUSH
4963: LD_INT 2
4965: ARRAY
4966: PPUSH
4967: LD_INT 20
4969: PPUSH
4970: CALL 54460 0 4
4974: PUSH
4975: LD_INT 4
4977: ARRAY
4978: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4979: LD_VAR 0 4
4983: PUSH
4984: LD_EXP 14
4988: NOT
4989: AND
4990: PUSH
4991: LD_VAR 0 3
4995: PUSH
4996: LD_INT 10
4998: LESS
4999: AND
5000: IFFALSE 4907
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5002: LD_VAR 0 2
5006: PPUSH
5007: LD_VAR 0 4
5011: PUSH
5012: LD_INT 1
5014: ARRAY
5015: PPUSH
5016: LD_VAR 0 4
5020: PUSH
5021: LD_INT 2
5023: ARRAY
5024: PPUSH
5025: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5029: LD_VAR 0 2
5033: PPUSH
5034: LD_INT 198
5036: PPUSH
5037: LD_INT 113
5039: PPUSH
5040: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5044: LD_VAR 0 2
5048: PPUSH
5049: LD_INT 124
5051: PPUSH
5052: LD_INT 7
5054: PPUSH
5055: CALL_OW 171
// end ;
5059: PPOPN 4
5061: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5062: LD_EXP 6
5066: IFFALSE 7935
5068: GO 5070
5070: DISABLE
5071: LD_INT 0
5073: PPUSH
5074: PPUSH
5075: PPUSH
5076: PPUSH
5077: PPUSH
5078: PPUSH
5079: PPUSH
5080: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5081: LD_ADDR_VAR 0 4
5085: PUSH
5086: LD_INT 5
5088: PUSH
5089: LD_INT 6
5091: PUSH
5092: LD_INT 7
5094: PUSH
5095: LD_INT 8
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: LIST
5102: LIST
5103: PUSH
5104: LD_OWVAR 67
5108: ARRAY
5109: ST_TO_ADDR
// coords := [ ] ;
5110: LD_ADDR_VAR 0 5
5114: PUSH
5115: EMPTY
5116: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5117: LD_ADDR_VAR 0 6
5121: PUSH
5122: LD_INT 0
5124: PUSH
5125: LD_INT 0
5127: PUSH
5128: LD_INT 0
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 1
5136: PUSH
5137: LD_INT 0
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: LD_INT 0
5145: PUSH
5146: LD_INT 1
5148: PUSH
5149: LD_INT 0
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: LIST
5157: LIST
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: LIST
5163: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5164: LD_INT 1
5166: PPUSH
5167: LD_INT 14
5169: PUSH
5170: LD_INT 1
5172: PUSH
5173: LD_INT 2
5175: PUSH
5176: LD_INT 28
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: LIST
5183: LIST
5184: PUSH
5185: LD_INT 14
5187: PUSH
5188: LD_INT 1
5190: PUSH
5191: LD_INT 2
5193: PUSH
5194: LD_INT 25
5196: PUSH
5197: EMPTY
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: PUSH
5203: LD_INT 14
5205: PUSH
5206: LD_INT 1
5208: PUSH
5209: LD_INT 2
5211: PUSH
5212: LD_INT 28
5214: PUSH
5215: EMPTY
5216: LIST
5217: LIST
5218: LIST
5219: LIST
5220: PUSH
5221: LD_INT 14
5223: PUSH
5224: LD_INT 1
5226: PUSH
5227: LD_INT 2
5229: PUSH
5230: LD_INT 29
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: LIST
5237: LIST
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: LIST
5243: LIST
5244: PPUSH
5245: CALL 42124 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5249: LD_INT 21000
5251: PUSH
5252: LD_INT 19950
5254: PUSH
5255: LD_INT 18900
5257: PUSH
5258: LD_INT 18200
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: LIST
5265: LIST
5266: PUSH
5267: LD_OWVAR 67
5271: ARRAY
5272: PPUSH
5273: CALL_OW 67
// InitHc ;
5277: CALL_OW 19
// InitUc ;
5281: CALL_OW 18
// uc_side := 2 ;
5285: LD_ADDR_OWVAR 20
5289: PUSH
5290: LD_INT 2
5292: ST_TO_ADDR
// uc_nation := 2 ;
5293: LD_ADDR_OWVAR 21
5297: PUSH
5298: LD_INT 2
5300: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5301: LD_ADDR_VAR 0 3
5305: PUSH
5306: EMPTY
5307: PUSH
5308: EMPTY
5309: PUSH
5310: EMPTY
5311: PUSH
5312: EMPTY
5313: PUSH
5314: EMPTY
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: LIST
5320: LIST
5321: LIST
5322: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5323: LD_ADDR_VAR 0 3
5327: PUSH
5328: LD_VAR 0 3
5332: PPUSH
5333: LD_INT 1
5335: PPUSH
5336: LD_EXP 69
5340: PUSH
5341: LD_INT 1
5343: ARRAY
5344: PUSH
5345: LD_INT 2
5347: PUSH
5348: LD_INT 34
5350: PUSH
5351: LD_EXP 100
5355: PUSH
5356: EMPTY
5357: LIST
5358: LIST
5359: PUSH
5360: LD_INT 34
5362: PUSH
5363: LD_INT 32
5365: PUSH
5366: EMPTY
5367: LIST
5368: LIST
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: LIST
5374: PPUSH
5375: CALL_OW 69
5379: DIFF
5380: PPUSH
5381: CALL_OW 1
5385: ST_TO_ADDR
// for i = 1 to Difficulty do
5386: LD_ADDR_VAR 0 1
5390: PUSH
5391: DOUBLE
5392: LD_INT 1
5394: DEC
5395: ST_TO_ADDR
5396: LD_OWVAR 67
5400: PUSH
5401: FOR_TO
5402: IFFALSE 5540
// begin uc_side := 2 ;
5404: LD_ADDR_OWVAR 20
5408: PUSH
5409: LD_INT 2
5411: ST_TO_ADDR
// uc_nation := 2 ;
5412: LD_ADDR_OWVAR 21
5416: PUSH
5417: LD_INT 2
5419: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5420: LD_INT 13
5422: PPUSH
5423: LD_INT 3
5425: PPUSH
5426: LD_INT 5
5428: PPUSH
5429: LD_INT 29
5431: PPUSH
5432: LD_INT 100
5434: PPUSH
5435: CALL 53442 0 5
// un := CreateVehicle ;
5439: LD_ADDR_VAR 0 2
5443: PUSH
5444: CALL_OW 45
5448: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5449: LD_ADDR_VAR 0 3
5453: PUSH
5454: LD_VAR 0 3
5458: PPUSH
5459: LD_INT 1
5461: PUSH
5462: LD_VAR 0 3
5466: PUSH
5467: LD_INT 1
5469: ARRAY
5470: PUSH
5471: LD_INT 1
5473: PLUS
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PPUSH
5479: LD_VAR 0 2
5483: PPUSH
5484: CALL 53564 0 3
5488: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5489: LD_VAR 0 2
5493: PPUSH
5494: LD_INT 3
5496: PPUSH
5497: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5501: LD_VAR 0 2
5505: PPUSH
5506: LD_INT 16
5508: PPUSH
5509: LD_INT 0
5511: PPUSH
5512: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5516: LD_VAR 0 2
5520: PPUSH
5521: LD_INT 51
5523: PPUSH
5524: LD_INT 10
5526: PPUSH
5527: CALL_OW 111
// wait ( 0 0$2 ) ;
5531: LD_INT 70
5533: PPUSH
5534: CALL_OW 67
// end ;
5538: GO 5401
5540: POP
5541: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5542: LD_ADDR_VAR 0 5
5546: PUSH
5547: LD_INT 51
5549: PUSH
5550: LD_INT 24
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PUSH
5557: LD_INT 75
5559: PUSH
5560: LD_INT 90
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5571: LD_INT 1
5573: PPUSH
5574: LD_VAR 0 3
5578: PUSH
5579: LD_INT 1
5581: ARRAY
5582: PPUSH
5583: LD_VAR 0 5
5587: PPUSH
5588: LD_VAR 0 6
5592: PPUSH
5593: CALL 42357 0 4
// for i = 1 to [ 1 , 3 , 3 , 3 ] [ Difficulty ] do
5597: LD_ADDR_VAR 0 1
5601: PUSH
5602: DOUBLE
5603: LD_INT 1
5605: DEC
5606: ST_TO_ADDR
5607: LD_INT 1
5609: PUSH
5610: LD_INT 3
5612: PUSH
5613: LD_INT 3
5615: PUSH
5616: LD_INT 3
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: LIST
5623: LIST
5624: PUSH
5625: LD_OWVAR 67
5629: ARRAY
5630: PUSH
5631: FOR_TO
5632: IFFALSE 5732
// begin uc_side := 2 ;
5634: LD_ADDR_OWVAR 20
5638: PUSH
5639: LD_INT 2
5641: ST_TO_ADDR
// uc_nation := 2 ;
5642: LD_ADDR_OWVAR 21
5646: PUSH
5647: LD_INT 2
5649: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5650: LD_INT 0
5652: PPUSH
5653: LD_INT 17
5655: PPUSH
5656: LD_VAR 0 4
5660: PPUSH
5661: CALL_OW 380
// un := CreateHuman ;
5665: LD_ADDR_VAR 0 2
5669: PUSH
5670: CALL_OW 44
5674: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5675: LD_ADDR_VAR 0 3
5679: PUSH
5680: LD_VAR 0 3
5684: PPUSH
5685: LD_INT 2
5687: PUSH
5688: LD_VAR 0 3
5692: PUSH
5693: LD_INT 2
5695: ARRAY
5696: PUSH
5697: LD_INT 1
5699: PLUS
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: PPUSH
5705: LD_VAR 0 2
5709: PPUSH
5710: CALL 53564 0 3
5714: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5715: LD_VAR 0 2
5719: PPUSH
5720: LD_INT 13
5722: PPUSH
5723: LD_INT 0
5725: PPUSH
5726: CALL_OW 49
// end ;
5730: GO 5631
5732: POP
5733: POP
// for i = 1 to [ 3 , 4 , 4 , 4 ] [ Difficulty ] do
5734: LD_ADDR_VAR 0 1
5738: PUSH
5739: DOUBLE
5740: LD_INT 1
5742: DEC
5743: ST_TO_ADDR
5744: LD_INT 3
5746: PUSH
5747: LD_INT 4
5749: PUSH
5750: LD_INT 4
5752: PUSH
5753: LD_INT 4
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: PUSH
5762: LD_OWVAR 67
5766: ARRAY
5767: PUSH
5768: FOR_TO
5769: IFFALSE 5890
// begin uc_side := 2 ;
5771: LD_ADDR_OWVAR 20
5775: PUSH
5776: LD_INT 2
5778: ST_TO_ADDR
// uc_nation := 2 ;
5779: LD_ADDR_OWVAR 21
5783: PUSH
5784: LD_INT 2
5786: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5787: LD_INT 0
5789: PPUSH
5790: LD_INT 1
5792: PUSH
5793: LD_INT 8
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: PUSH
5800: LD_VAR 0 1
5804: PUSH
5805: LD_INT 2
5807: MOD
5808: PUSH
5809: LD_INT 1
5811: PLUS
5812: ARRAY
5813: PPUSH
5814: LD_VAR 0 4
5818: PPUSH
5819: CALL_OW 380
// un := CreateHuman ;
5823: LD_ADDR_VAR 0 2
5827: PUSH
5828: CALL_OW 44
5832: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5833: LD_ADDR_VAR 0 3
5837: PUSH
5838: LD_VAR 0 3
5842: PPUSH
5843: LD_INT 2
5845: PUSH
5846: LD_VAR 0 3
5850: PUSH
5851: LD_INT 2
5853: ARRAY
5854: PUSH
5855: LD_INT 1
5857: PLUS
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PPUSH
5863: LD_VAR 0 2
5867: PPUSH
5868: CALL 53564 0 3
5872: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5873: LD_VAR 0 2
5877: PPUSH
5878: LD_INT 13
5880: PPUSH
5881: LD_INT 0
5883: PPUSH
5884: CALL_OW 49
// end ;
5888: GO 5768
5890: POP
5891: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5892: LD_ADDR_VAR 0 5
5896: PUSH
5897: LD_INT 67
5899: PUSH
5900: LD_INT 112
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PUSH
5907: LD_INT 85
5909: PUSH
5910: LD_INT 130
5912: PUSH
5913: EMPTY
5914: LIST
5915: LIST
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5921: LD_INT 2
5923: PPUSH
5924: LD_VAR 0 3
5928: PUSH
5929: LD_INT 2
5931: ARRAY
5932: PPUSH
5933: LD_VAR 0 5
5937: PPUSH
5938: LD_VAR 0 6
5942: PPUSH
5943: CALL 42357 0 4
// for i = 1 to [ 1 , 2 , 3 , 4 ] [ Difficulty ] do
5947: LD_ADDR_VAR 0 1
5951: PUSH
5952: DOUBLE
5953: LD_INT 1
5955: DEC
5956: ST_TO_ADDR
5957: LD_INT 1
5959: PUSH
5960: LD_INT 2
5962: PUSH
5963: LD_INT 3
5965: PUSH
5966: LD_INT 4
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: LIST
5973: LIST
5974: PUSH
5975: LD_OWVAR 67
5979: ARRAY
5980: PUSH
5981: FOR_TO
5982: IFFALSE 6082
// begin uc_side := 2 ;
5984: LD_ADDR_OWVAR 20
5988: PUSH
5989: LD_INT 2
5991: ST_TO_ADDR
// uc_nation := 2 ;
5992: LD_ADDR_OWVAR 21
5996: PUSH
5997: LD_INT 2
5999: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6000: LD_INT 0
6002: PPUSH
6003: LD_INT 17
6005: PPUSH
6006: LD_VAR 0 4
6010: PPUSH
6011: CALL_OW 380
// un := CreateHuman ;
6015: LD_ADDR_VAR 0 2
6019: PUSH
6020: CALL_OW 44
6024: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6025: LD_ADDR_VAR 0 3
6029: PUSH
6030: LD_VAR 0 3
6034: PPUSH
6035: LD_INT 3
6037: PUSH
6038: LD_VAR 0 3
6042: PUSH
6043: LD_INT 3
6045: ARRAY
6046: PUSH
6047: LD_INT 1
6049: PLUS
6050: PUSH
6051: EMPTY
6052: LIST
6053: LIST
6054: PPUSH
6055: LD_VAR 0 2
6059: PPUSH
6060: CALL 53564 0 3
6064: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6065: LD_VAR 0 2
6069: PPUSH
6070: LD_INT 14
6072: PPUSH
6073: LD_INT 0
6075: PPUSH
6076: CALL_OW 49
// end ;
6080: GO 5981
6082: POP
6083: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6084: LD_ADDR_VAR 0 5
6088: PUSH
6089: LD_INT 148
6091: PUSH
6092: LD_INT 158
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PUSH
6099: LD_INT 148
6101: PUSH
6102: LD_INT 158
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6113: LD_INT 3
6115: PPUSH
6116: LD_VAR 0 3
6120: PUSH
6121: LD_INT 3
6123: ARRAY
6124: PPUSH
6125: LD_VAR 0 5
6129: PPUSH
6130: LD_VAR 0 6
6134: PPUSH
6135: CALL 42357 0 4
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
6139: LD_ADDR_VAR 0 1
6143: PUSH
6144: DOUBLE
6145: LD_INT 1
6147: DEC
6148: ST_TO_ADDR
6149: LD_INT 2
6151: PUSH
6152: LD_INT 3
6154: PUSH
6155: LD_INT 4
6157: PUSH
6158: LD_INT 4
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: LIST
6165: LIST
6166: PUSH
6167: LD_OWVAR 67
6171: ARRAY
6172: PUSH
6173: FOR_TO
6174: IFFALSE 6398
// begin uc_side := 2 ;
6176: LD_ADDR_OWVAR 20
6180: PUSH
6181: LD_INT 2
6183: ST_TO_ADDR
// uc_nation := 2 ;
6184: LD_ADDR_OWVAR 21
6188: PUSH
6189: LD_INT 2
6191: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6192: LD_INT 14
6194: PPUSH
6195: LD_INT 3
6197: PPUSH
6198: LD_INT 1
6200: PUSH
6201: LD_INT 5
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: PUSH
6208: LD_INT 1
6210: PPUSH
6211: LD_INT 2
6213: PPUSH
6214: CALL_OW 12
6218: ARRAY
6219: PPUSH
6220: LD_INT 27
6222: PUSH
6223: LD_INT 26
6225: PUSH
6226: LD_INT 28
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: PUSH
6234: LD_INT 1
6236: PPUSH
6237: LD_INT 3
6239: PPUSH
6240: CALL_OW 12
6244: ARRAY
6245: PPUSH
6246: LD_INT 100
6248: PPUSH
6249: CALL 53442 0 5
// un := CreateVehicle ;
6253: LD_ADDR_VAR 0 2
6257: PUSH
6258: CALL_OW 45
6262: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6263: LD_ADDR_VAR 0 3
6267: PUSH
6268: LD_VAR 0 3
6272: PPUSH
6273: LD_INT 4
6275: PUSH
6276: LD_VAR 0 3
6280: PUSH
6281: LD_INT 4
6283: ARRAY
6284: PUSH
6285: LD_INT 1
6287: PLUS
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: PPUSH
6293: LD_VAR 0 2
6297: PPUSH
6298: CALL 53564 0 3
6302: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6303: LD_VAR 0 2
6307: PPUSH
6308: LD_INT 5
6310: PPUSH
6311: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6315: LD_VAR 0 2
6319: PPUSH
6320: LD_INT 15
6322: PPUSH
6323: LD_INT 0
6325: PPUSH
6326: CALL_OW 49
// if GetControl ( un ) = control_manual then
6330: LD_VAR 0 2
6334: PPUSH
6335: CALL_OW 263
6339: PUSH
6340: LD_INT 1
6342: EQUAL
6343: IFFALSE 6374
// begin PrepareHuman ( false , 3 , skill ) ;
6345: LD_INT 0
6347: PPUSH
6348: LD_INT 3
6350: PPUSH
6351: LD_VAR 0 4
6355: PPUSH
6356: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6360: CALL_OW 44
6364: PPUSH
6365: LD_VAR 0 2
6369: PPUSH
6370: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6374: LD_VAR 0 2
6378: PPUSH
6379: LD_INT 179
6381: PPUSH
6382: LD_INT 135
6384: PPUSH
6385: CALL_OW 111
// wait ( 0 0$2 ) ;
6389: LD_INT 70
6391: PPUSH
6392: CALL_OW 67
// end ;
6396: GO 6173
6398: POP
6399: POP
// vc_chassis := 15 ;
6400: LD_ADDR_OWVAR 37
6404: PUSH
6405: LD_INT 15
6407: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6408: LD_ADDR_VAR 0 3
6412: PUSH
6413: LD_VAR 0 3
6417: PPUSH
6418: LD_INT 4
6420: PUSH
6421: LD_VAR 0 3
6425: PUSH
6426: LD_INT 4
6428: ARRAY
6429: PUSH
6430: LD_INT 1
6432: PLUS
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: PPUSH
6438: CALL_OW 45
6442: PPUSH
6443: CALL 53564 0 3
6447: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6448: LD_VAR 0 3
6452: PUSH
6453: LD_INT 4
6455: ARRAY
6456: PUSH
6457: LD_VAR 0 3
6461: PUSH
6462: LD_INT 4
6464: ARRAY
6465: ARRAY
6466: PPUSH
6467: LD_INT 15
6469: PPUSH
6470: LD_INT 0
6472: PPUSH
6473: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6477: LD_INT 0
6479: PPUSH
6480: LD_INT 11
6482: PPUSH
6483: LD_VAR 0 4
6487: PPUSH
6488: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6492: LD_ADDR_VAR 0 3
6496: PUSH
6497: LD_VAR 0 3
6501: PPUSH
6502: LD_INT 4
6504: PUSH
6505: LD_VAR 0 3
6509: PUSH
6510: LD_INT 4
6512: ARRAY
6513: PUSH
6514: LD_INT 1
6516: PLUS
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PPUSH
6522: CALL_OW 44
6526: PPUSH
6527: CALL 53564 0 3
6531: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6532: LD_VAR 0 3
6536: PUSH
6537: LD_INT 4
6539: ARRAY
6540: PUSH
6541: LD_VAR 0 3
6545: PUSH
6546: LD_INT 4
6548: ARRAY
6549: ARRAY
6550: PPUSH
6551: LD_VAR 0 3
6555: PUSH
6556: LD_INT 4
6558: ARRAY
6559: PUSH
6560: LD_VAR 0 3
6564: PUSH
6565: LD_INT 4
6567: ARRAY
6568: PUSH
6569: LD_INT 1
6571: MINUS
6572: ARRAY
6573: PPUSH
6574: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6578: LD_ADDR_VAR 0 5
6582: PUSH
6583: LD_INT 148
6585: PUSH
6586: LD_INT 140
6588: PUSH
6589: EMPTY
6590: LIST
6591: LIST
6592: PUSH
6593: EMPTY
6594: LIST
6595: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6596: LD_INT 1
6598: PPUSH
6599: LD_VAR 0 3
6603: PUSH
6604: LD_INT 4
6606: ARRAY
6607: PPUSH
6608: LD_VAR 0 5
6612: PPUSH
6613: LD_VAR 0 6
6617: PPUSH
6618: CALL 42357 0 4
// if gensher_active then
6622: LD_EXP 18
6626: IFFALSE 7032
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6628: LD_EXP 45
6632: PPUSH
6633: LD_STRING D10-Diet-1
6635: PPUSH
6636: CALL_OW 94
// for i = 1 to 2 do
6640: LD_ADDR_VAR 0 1
6644: PUSH
6645: DOUBLE
6646: LD_INT 1
6648: DEC
6649: ST_TO_ADDR
6650: LD_INT 2
6652: PUSH
6653: FOR_TO
6654: IFFALSE 6792
// begin uc_side := 2 ;
6656: LD_ADDR_OWVAR 20
6660: PUSH
6661: LD_INT 2
6663: ST_TO_ADDR
// uc_nation := 2 ;
6664: LD_ADDR_OWVAR 21
6668: PUSH
6669: LD_INT 2
6671: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6672: LD_INT 13
6674: PPUSH
6675: LD_INT 3
6677: PPUSH
6678: LD_INT 5
6680: PPUSH
6681: LD_INT 29
6683: PPUSH
6684: LD_INT 100
6686: PPUSH
6687: CALL 53442 0 5
// un := CreateVehicle ;
6691: LD_ADDR_VAR 0 2
6695: PUSH
6696: CALL_OW 45
6700: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6701: LD_ADDR_VAR 0 3
6705: PUSH
6706: LD_VAR 0 3
6710: PPUSH
6711: LD_INT 5
6713: PUSH
6714: LD_VAR 0 3
6718: PUSH
6719: LD_INT 5
6721: ARRAY
6722: PUSH
6723: LD_INT 1
6725: PLUS
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PPUSH
6731: LD_VAR 0 2
6735: PPUSH
6736: CALL 53564 0 3
6740: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6741: LD_VAR 0 2
6745: PPUSH
6746: LD_INT 0
6748: PPUSH
6749: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6753: LD_VAR 0 2
6757: PPUSH
6758: LD_INT 23
6760: PPUSH
6761: LD_INT 0
6763: PPUSH
6764: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6768: LD_VAR 0 2
6772: PPUSH
6773: LD_INT 85
6775: PPUSH
6776: LD_INT 152
6778: PPUSH
6779: CALL_OW 111
// wait ( 0 0$2 ) ;
6783: LD_INT 70
6785: PPUSH
6786: CALL_OW 67
// end ;
6790: GO 6653
6792: POP
6793: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6794: LD_ADDR_VAR 0 1
6798: PUSH
6799: DOUBLE
6800: LD_INT 1
6802: DEC
6803: ST_TO_ADDR
6804: LD_INT 2
6806: PUSH
6807: LD_INT 3
6809: PUSH
6810: LD_INT 3
6812: PUSH
6813: LD_INT 4
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: PUSH
6822: LD_OWVAR 67
6826: ARRAY
6827: PUSH
6828: FOR_TO
6829: IFFALSE 6986
// begin uc_side := 2 ;
6831: LD_ADDR_OWVAR 20
6835: PUSH
6836: LD_INT 2
6838: ST_TO_ADDR
// uc_nation := 2 ;
6839: LD_ADDR_OWVAR 21
6843: PUSH
6844: LD_INT 2
6846: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6847: LD_INT 14
6849: PPUSH
6850: LD_INT 3
6852: PPUSH
6853: LD_INT 5
6855: PPUSH
6856: LD_INT 27
6858: PUSH
6859: LD_INT 28
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: PUSH
6866: LD_INT 1
6868: PPUSH
6869: LD_INT 2
6871: PPUSH
6872: CALL_OW 12
6876: ARRAY
6877: PPUSH
6878: LD_INT 100
6880: PPUSH
6881: CALL 53442 0 5
// un := CreateVehicle ;
6885: LD_ADDR_VAR 0 2
6889: PUSH
6890: CALL_OW 45
6894: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6895: LD_ADDR_VAR 0 3
6899: PUSH
6900: LD_VAR 0 3
6904: PPUSH
6905: LD_INT 5
6907: PUSH
6908: LD_VAR 0 3
6912: PUSH
6913: LD_INT 5
6915: ARRAY
6916: PUSH
6917: LD_INT 1
6919: PLUS
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: PPUSH
6925: LD_VAR 0 2
6929: PPUSH
6930: CALL 53564 0 3
6934: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6935: LD_VAR 0 2
6939: PPUSH
6940: LD_INT 0
6942: PPUSH
6943: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6947: LD_VAR 0 2
6951: PPUSH
6952: LD_INT 23
6954: PPUSH
6955: LD_INT 0
6957: PPUSH
6958: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6962: LD_VAR 0 2
6966: PPUSH
6967: LD_INT 85
6969: PPUSH
6970: LD_INT 152
6972: PPUSH
6973: CALL_OW 111
// wait ( 0 0$2 ) ;
6977: LD_INT 70
6979: PPUSH
6980: CALL_OW 67
// end ;
6984: GO 6828
6986: POP
6987: POP
// coords := [ [ 97 , 143 ] ] ;
6988: LD_ADDR_VAR 0 5
6992: PUSH
6993: LD_INT 97
6995: PUSH
6996: LD_INT 143
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: PUSH
7003: EMPTY
7004: LIST
7005: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7006: LD_INT 1
7008: PPUSH
7009: LD_VAR 0 3
7013: PUSH
7014: LD_INT 5
7016: ARRAY
7017: PPUSH
7018: LD_VAR 0 5
7022: PPUSH
7023: LD_VAR 0 6
7027: PPUSH
7028: CALL 42357 0 4
// end ; Wait ( 13 13$00 ) ;
7032: LD_INT 27300
7034: PPUSH
7035: CALL_OW 67
// tmp := [ ] ;
7039: LD_ADDR_VAR 0 3
7043: PUSH
7044: EMPTY
7045: ST_TO_ADDR
// w := 1 ;
7046: LD_ADDR_VAR 0 7
7050: PUSH
7051: LD_INT 1
7053: ST_TO_ADDR
// repeat tmp := [ ] ;
7054: LD_ADDR_VAR 0 3
7058: PUSH
7059: EMPTY
7060: ST_TO_ADDR
// if w mod 4 = 0 then
7061: LD_VAR 0 7
7065: PUSH
7066: LD_INT 4
7068: MOD
7069: PUSH
7070: LD_INT 0
7072: EQUAL
7073: IFFALSE 7160
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7075: LD_ADDR_VAR 0 8
7079: PUSH
7080: LD_INT 11
7082: PUSH
7083: LD_INT 1
7085: PUSH
7086: LD_INT 2
7088: PUSH
7089: LD_INT 24
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: LIST
7096: LIST
7097: PUSH
7098: LD_INT 11
7100: PUSH
7101: LD_INT 1
7103: PUSH
7104: LD_INT 2
7106: PUSH
7107: LD_INT 24
7109: PUSH
7110: EMPTY
7111: LIST
7112: LIST
7113: LIST
7114: LIST
7115: PUSH
7116: LD_INT 11
7118: PUSH
7119: LD_INT 1
7121: PUSH
7122: LD_INT 2
7124: PUSH
7125: LD_INT 24
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: LIST
7132: LIST
7133: PUSH
7134: LD_INT 11
7136: PUSH
7137: LD_INT 1
7139: PUSH
7140: LD_INT 2
7142: PUSH
7143: LD_INT 24
7145: PUSH
7146: EMPTY
7147: LIST
7148: LIST
7149: LIST
7150: LIST
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: LIST
7156: LIST
7157: ST_TO_ADDR
7158: GO 7262
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7160: LD_ADDR_VAR 0 8
7164: PUSH
7165: LD_INT 14
7167: PUSH
7168: LD_INT 1
7170: PUSH
7171: LD_INT 2
7173: PUSH
7174: LD_INT 28
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: LIST
7181: LIST
7182: PUSH
7183: LD_INT 14
7185: PUSH
7186: LD_INT 1
7188: PUSH
7189: LD_INT 2
7191: PUSH
7192: LD_INT 25
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: LIST
7200: PUSH
7201: LD_INT 14
7203: PUSH
7204: LD_INT 1
7206: PUSH
7207: LD_INT 2
7209: PUSH
7210: LD_INT 28
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 14
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: LD_INT 2
7227: PUSH
7228: LD_INT 29
7230: PUSH
7231: EMPTY
7232: LIST
7233: LIST
7234: LIST
7235: LIST
7236: PUSH
7237: LD_INT 11
7239: PUSH
7240: LD_INT 1
7242: PUSH
7243: LD_INT 2
7245: PUSH
7246: LD_INT 24
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: LIST
7253: LIST
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: ST_TO_ADDR
// if w mod 3 = 0 then
7262: LD_VAR 0 7
7266: PUSH
7267: LD_INT 3
7269: MOD
7270: PUSH
7271: LD_INT 0
7273: EQUAL
7274: IFFALSE 7350
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7276: LD_ADDR_VAR 0 8
7280: PUSH
7281: LD_VAR 0 8
7285: PPUSH
7286: LD_INT 1
7288: PUSH
7289: LD_VAR 0 8
7293: PUSH
7294: LD_VAR 0 1
7298: ARRAY
7299: PUSH
7300: LD_INT 1
7302: PLUS
7303: PUSH
7304: EMPTY
7305: LIST
7306: LIST
7307: PPUSH
7308: LD_INT 14
7310: PUSH
7311: LD_INT 1
7313: PUSH
7314: LD_INT 2
7316: PUSH
7317: LD_INT 25
7319: PUSH
7320: LD_INT 28
7322: PUSH
7323: EMPTY
7324: LIST
7325: LIST
7326: PUSH
7327: LD_INT 1
7329: PPUSH
7330: LD_INT 2
7332: PPUSH
7333: CALL_OW 12
7337: ARRAY
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL 53564 0 3
7349: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7350: LD_INT 1
7352: PPUSH
7353: LD_VAR 0 8
7357: PPUSH
7358: CALL 42124 0 2
// if GetSide ( ar_dep_w ) = 2 then
7362: LD_INT 45
7364: PPUSH
7365: CALL_OW 255
7369: PUSH
7370: LD_INT 2
7372: EQUAL
7373: IFFALSE 7458
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7375: LD_ADDR_VAR 0 8
7379: PUSH
7380: LD_INT 14
7382: PUSH
7383: LD_INT 1
7385: PUSH
7386: LD_INT 2
7388: PUSH
7389: LD_INT 28
7391: PUSH
7392: EMPTY
7393: LIST
7394: LIST
7395: LIST
7396: LIST
7397: PUSH
7398: LD_INT 14
7400: PUSH
7401: LD_INT 1
7403: PUSH
7404: LD_INT 2
7406: PUSH
7407: LD_INT 27
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: PUSH
7416: LD_INT 14
7418: PUSH
7419: LD_INT 1
7421: PUSH
7422: LD_INT 2
7424: PUSH
7425: LD_INT 27
7427: PUSH
7428: EMPTY
7429: LIST
7430: LIST
7431: LIST
7432: LIST
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: LIST
7438: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7439: LD_INT 2
7441: PPUSH
7442: LD_VAR 0 8
7446: PPUSH
7447: CALL 42124 0 2
// wait ( 0 0$50 ) ;
7451: LD_INT 1750
7453: PPUSH
7454: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7458: LD_INT 35
7460: PPUSH
7461: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7465: LD_EXP 69
7469: PUSH
7470: LD_INT 1
7472: ARRAY
7473: PPUSH
7474: LD_INT 3
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: LD_INT 34
7482: PUSH
7483: LD_INT 32
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 34
7492: PUSH
7493: LD_EXP 100
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: EMPTY
7508: LIST
7509: LIST
7510: PPUSH
7511: CALL_OW 72
7515: PUSH
7516: LD_INT 4
7518: GREATEREQUAL
7519: IFFALSE 7458
// wait ( 0 0$10 ) ;
7521: LD_INT 350
7523: PPUSH
7524: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7528: LD_ADDR_VAR 0 3
7532: PUSH
7533: LD_EXP 69
7537: PUSH
7538: LD_INT 1
7540: ARRAY
7541: PPUSH
7542: LD_INT 3
7544: PUSH
7545: LD_INT 2
7547: PUSH
7548: LD_INT 34
7550: PUSH
7551: LD_INT 32
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PUSH
7558: LD_INT 34
7560: PUSH
7561: LD_EXP 100
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: LIST
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PPUSH
7579: CALL_OW 72
7583: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7584: LD_INT 100
7586: PPUSH
7587: CALL_OW 13
7591: PUSH
7592: LD_INT 50
7594: LESS
7595: IFFALSE 7628
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7597: LD_ADDR_VAR 0 5
7601: PUSH
7602: LD_INT 55
7604: PUSH
7605: LD_INT 7
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: LD_INT 75
7614: PUSH
7615: LD_INT 90
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: EMPTY
7623: LIST
7624: LIST
7625: ST_TO_ADDR
7626: GO 7657
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7628: LD_ADDR_VAR 0 5
7632: PUSH
7633: LD_INT 128
7635: PUSH
7636: LD_INT 94
7638: PUSH
7639: EMPTY
7640: LIST
7641: LIST
7642: PUSH
7643: LD_INT 180
7645: PUSH
7646: LD_INT 135
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: ST_TO_ADDR
// if w mod 4 = 0 then
7657: LD_VAR 0 7
7661: PUSH
7662: LD_INT 4
7664: MOD
7665: PUSH
7666: LD_INT 0
7668: EQUAL
7669: IFFALSE 7700
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7671: LD_ADDR_VAR 0 5
7675: PUSH
7676: LD_INT 91
7678: PUSH
7679: LD_INT 58
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 117
7688: PUSH
7689: LD_INT 107
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7700: LD_VAR 0 3
7704: PPUSH
7705: LD_VAR 0 5
7709: PUSH
7710: LD_INT 1
7712: ARRAY
7713: PPUSH
7714: LD_VAR 0 5
7718: PUSH
7719: LD_INT 2
7721: ARRAY
7722: PPUSH
7723: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7734: LD_VAR 0 3
7738: PPUSH
7739: LD_INT 60
7741: PUSH
7742: EMPTY
7743: LIST
7744: PPUSH
7745: CALL_OW 72
7749: PUSH
7750: LD_INT 0
7752: EQUAL
7753: IFFALSE 7727
// repeat wait ( 0 0$2 ) ;
7755: LD_INT 70
7757: PPUSH
7758: CALL_OW 67
// for i in tmp do
7762: LD_ADDR_VAR 0 1
7766: PUSH
7767: LD_VAR 0 3
7771: PUSH
7772: FOR_IN
7773: IFFALSE 7862
// if GetChassis ( i ) = ar_hovercraft then
7775: LD_VAR 0 1
7779: PPUSH
7780: CALL_OW 265
7784: PUSH
7785: LD_INT 11
7787: EQUAL
7788: IFFALSE 7826
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7790: LD_VAR 0 1
7794: PPUSH
7795: LD_INT 22
7797: PUSH
7798: LD_INT 1
7800: PUSH
7801: EMPTY
7802: LIST
7803: LIST
7804: PPUSH
7805: CALL_OW 69
7809: PPUSH
7810: LD_VAR 0 1
7814: PPUSH
7815: CALL_OW 74
7819: PPUSH
7820: CALL 81460 0 2
7824: GO 7860
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7826: LD_VAR 0 1
7830: PPUSH
7831: LD_INT 22
7833: PUSH
7834: LD_INT 1
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PPUSH
7841: CALL_OW 69
7845: PPUSH
7846: LD_VAR 0 1
7850: PPUSH
7851: CALL_OW 74
7855: PPUSH
7856: CALL_OW 115
7860: GO 7772
7862: POP
7863: POP
// until not tmp ;
7864: LD_VAR 0 3
7868: NOT
7869: IFFALSE 7755
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7871: LD_INT 22050
7873: PPUSH
7874: LD_INT 28350
7876: PPUSH
7877: CALL_OW 12
7881: PPUSH
7882: CALL_OW 67
// w := w + 1 ;
7886: LD_ADDR_VAR 0 7
7890: PUSH
7891: LD_VAR 0 7
7895: PUSH
7896: LD_INT 1
7898: PLUS
7899: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7900: LD_INT 94
7902: PPUSH
7903: CALL_OW 301
7907: PUSH
7908: LD_EXP 50
7912: PUSH
7913: LD_INT 1
7915: ARRAY
7916: PPUSH
7917: LD_INT 30
7919: PUSH
7920: LD_INT 3
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PPUSH
7927: CALL_OW 72
7931: NOT
7932: OR
7933: IFFALSE 7054
// end ;
7935: PPOPN 8
7937: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7938: LD_INT 204
7940: IFFALSE 8406
7942: GO 7944
7944: DISABLE
7945: LD_INT 0
7947: PPUSH
7948: PPUSH
7949: PPUSH
7950: PPUSH
// begin enable ;
7951: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7952: LD_INT 35
7954: PPUSH
7955: LD_INT 1190
7957: PPUSH
7958: CALL_OW 12
7962: PPUSH
7963: CALL_OW 67
// tmp := [ ] ;
7967: LD_ADDR_VAR 0 2
7971: PUSH
7972: EMPTY
7973: ST_TO_ADDR
// uc_side := 8 ;
7974: LD_ADDR_OWVAR 20
7978: PUSH
7979: LD_INT 8
7981: ST_TO_ADDR
// uc_nation := 2 ;
7982: LD_ADDR_OWVAR 21
7986: PUSH
7987: LD_INT 2
7989: ST_TO_ADDR
// InitHc ;
7990: CALL_OW 19
// for i = 1 to 3 do
7994: LD_ADDR_VAR 0 1
7998: PUSH
7999: DOUBLE
8000: LD_INT 1
8002: DEC
8003: ST_TO_ADDR
8004: LD_INT 3
8006: PUSH
8007: FOR_TO
8008: IFFALSE 8135
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8010: LD_INT 13
8012: PUSH
8013: LD_INT 14
8015: PUSH
8016: EMPTY
8017: LIST
8018: LIST
8019: PUSH
8020: LD_INT 1
8022: PPUSH
8023: LD_INT 2
8025: PPUSH
8026: CALL_OW 12
8030: ARRAY
8031: PPUSH
8032: LD_INT 3
8034: PPUSH
8035: LD_INT 5
8037: PPUSH
8038: LD_INT 27
8040: PUSH
8041: LD_INT 28
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 1
8050: PPUSH
8051: LD_INT 2
8053: PPUSH
8054: CALL_OW 12
8058: ARRAY
8059: PPUSH
8060: LD_INT 100
8062: PPUSH
8063: CALL 53442 0 5
// un := CreateVehicle ;
8067: LD_ADDR_VAR 0 3
8071: PUSH
8072: CALL_OW 45
8076: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8077: LD_VAR 0 3
8081: PPUSH
8082: LD_INT 4
8084: PPUSH
8085: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8089: LD_VAR 0 3
8093: PPUSH
8094: LD_INT 15
8096: PPUSH
8097: LD_INT 0
8099: PPUSH
8100: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8104: LD_ADDR_VAR 0 2
8108: PUSH
8109: LD_VAR 0 2
8113: PPUSH
8114: LD_VAR 0 2
8118: PUSH
8119: LD_INT 1
8121: PLUS
8122: PPUSH
8123: LD_VAR 0 3
8127: PPUSH
8128: CALL_OW 1
8132: ST_TO_ADDR
// end ;
8133: GO 8007
8135: POP
8136: POP
// for i = 1 to 4 do
8137: LD_ADDR_VAR 0 1
8141: PUSH
8142: DOUBLE
8143: LD_INT 1
8145: DEC
8146: ST_TO_ADDR
8147: LD_INT 4
8149: PUSH
8150: FOR_TO
8151: IFFALSE 8222
// begin PrepareHuman ( false , 1 , 6 ) ;
8153: LD_INT 0
8155: PPUSH
8156: LD_INT 1
8158: PPUSH
8159: LD_INT 6
8161: PPUSH
8162: CALL_OW 380
// un := CreateHuman ;
8166: LD_ADDR_VAR 0 3
8170: PUSH
8171: CALL_OW 44
8175: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8176: LD_VAR 0 3
8180: PPUSH
8181: LD_INT 15
8183: PPUSH
8184: LD_INT 0
8186: PPUSH
8187: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8191: LD_ADDR_VAR 0 2
8195: PUSH
8196: LD_VAR 0 2
8200: PPUSH
8201: LD_VAR 0 2
8205: PUSH
8206: LD_INT 1
8208: PLUS
8209: PPUSH
8210: LD_VAR 0 3
8214: PPUSH
8215: CALL_OW 1
8219: ST_TO_ADDR
// end ;
8220: GO 8150
8222: POP
8223: POP
// wait ( 0 0$3 ) ;
8224: LD_INT 105
8226: PPUSH
8227: CALL_OW 67
// for i in tmp do
8231: LD_ADDR_VAR 0 1
8235: PUSH
8236: LD_VAR 0 2
8240: PUSH
8241: FOR_IN
8242: IFFALSE 8310
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8244: LD_VAR 0 1
8248: PPUSH
8249: CALL_OW 257
8253: PUSH
8254: LD_INT 1
8256: EQUAL
8257: PUSH
8258: LD_VAR 0 1
8262: PPUSH
8263: CALL_OW 247
8267: PUSH
8268: LD_INT 2
8270: EQUAL
8271: OR
8272: IFFALSE 8308
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8274: LD_VAR 0 1
8278: PPUSH
8279: LD_INT 81
8281: PUSH
8282: LD_INT 8
8284: PUSH
8285: EMPTY
8286: LIST
8287: LIST
8288: PPUSH
8289: CALL_OW 69
8293: PPUSH
8294: LD_VAR 0 1
8298: PPUSH
8299: CALL_OW 74
8303: PPUSH
8304: CALL_OW 115
8308: GO 8241
8310: POP
8311: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8312: LD_VAR 0 2
8316: PPUSH
8317: LD_INT 210
8319: PPUSH
8320: LD_INT 178
8322: PPUSH
8323: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8327: LD_ADDR_VAR 0 4
8331: PUSH
8332: LD_INT 10
8334: PPUSH
8335: LD_INT 22
8337: PUSH
8338: LD_INT 8
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: PPUSH
8345: CALL_OW 70
8349: ST_TO_ADDR
// if x then
8350: LD_VAR 0 4
8354: IFFALSE 8382
// for i in x do
8356: LD_ADDR_VAR 0 1
8360: PUSH
8361: LD_VAR 0 4
8365: PUSH
8366: FOR_IN
8367: IFFALSE 8380
// RemoveUnit ( i ) ;
8369: LD_VAR 0 1
8373: PPUSH
8374: CALL_OW 64
8378: GO 8366
8380: POP
8381: POP
// wait ( 0 0$1 ) ;
8382: LD_INT 35
8384: PPUSH
8385: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8389: LD_INT 22
8391: PUSH
8392: LD_INT 8
8394: PUSH
8395: EMPTY
8396: LIST
8397: LIST
8398: PPUSH
8399: CALL_OW 69
8403: NOT
8404: IFFALSE 8312
// end ;
8406: PPOPN 4
8408: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8409: LD_INT 22
8411: PUSH
8412: LD_INT 2
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: PUSH
8419: LD_INT 34
8421: PUSH
8422: LD_INT 31
8424: PUSH
8425: EMPTY
8426: LIST
8427: LIST
8428: PUSH
8429: LD_INT 3
8431: PUSH
8432: LD_INT 24
8434: PUSH
8435: LD_INT 1000
8437: PUSH
8438: EMPTY
8439: LIST
8440: LIST
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: PPUSH
8451: CALL_OW 69
8455: IFFALSE 8558
8457: GO 8459
8459: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8460: LD_INT 45
8462: PPUSH
8463: CALL_OW 302
8467: PUSH
8468: LD_INT 45
8470: PPUSH
8471: CALL_OW 255
8475: AND
8476: IFFALSE 8519
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8478: LD_INT 22
8480: PUSH
8481: LD_INT 2
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 34
8490: PUSH
8491: LD_INT 31
8493: PUSH
8494: EMPTY
8495: LIST
8496: LIST
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: PPUSH
8502: CALL_OW 69
8506: PPUSH
8507: LD_INT 18
8509: PPUSH
8510: LD_INT 8
8512: PPUSH
8513: CALL_OW 111
8517: GO 8558
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8519: LD_INT 22
8521: PUSH
8522: LD_INT 2
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PUSH
8529: LD_INT 34
8531: PUSH
8532: LD_INT 31
8534: PUSH
8535: EMPTY
8536: LIST
8537: LIST
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: PPUSH
8543: CALL_OW 69
8547: PPUSH
8548: LD_INT 106
8550: PPUSH
8551: LD_INT 14
8553: PPUSH
8554: CALL_OW 111
// end ; end_of_file
8558: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8559: LD_INT 0
8561: PPUSH
8562: PPUSH
8563: PPUSH
8564: PPUSH
8565: PPUSH
8566: PPUSH
// InGameOn ;
8567: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8571: LD_EXP 21
8575: PPUSH
8576: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8580: LD_INT 2
8582: PPUSH
8583: LD_INT 1
8585: PPUSH
8586: LD_INT 1
8588: PPUSH
8589: LD_INT 1
8591: PPUSH
8592: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8596: LD_ADDR_VAR 0 2
8600: PUSH
8601: LD_INT 22
8603: PUSH
8604: LD_INT 1
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PUSH
8611: LD_INT 25
8613: PUSH
8614: LD_INT 1
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: PPUSH
8625: CALL_OW 69
8629: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8630: LD_ADDR_VAR 0 4
8634: PUSH
8635: LD_INT 22
8637: PUSH
8638: LD_INT 1
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: PUSH
8645: LD_INT 34
8647: PUSH
8648: LD_INT 11
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: PPUSH
8659: CALL_OW 69
8663: PUSH
8664: LD_INT 1
8666: ARRAY
8667: ST_TO_ADDR
// for i = 1 to tmp do
8668: LD_ADDR_VAR 0 6
8672: PUSH
8673: DOUBLE
8674: LD_INT 1
8676: DEC
8677: ST_TO_ADDR
8678: LD_VAR 0 2
8682: PUSH
8683: FOR_TO
8684: IFFALSE 8731
// begin if i = 5 then
8686: LD_VAR 0 6
8690: PUSH
8691: LD_INT 5
8693: EQUAL
8694: IFFALSE 8698
// break ;
8696: GO 8731
// sols := Replace ( sols , i , tmp [ i ] ) ;
8698: LD_ADDR_VAR 0 5
8702: PUSH
8703: LD_VAR 0 5
8707: PPUSH
8708: LD_VAR 0 6
8712: PPUSH
8713: LD_VAR 0 2
8717: PUSH
8718: LD_VAR 0 6
8722: ARRAY
8723: PPUSH
8724: CALL_OW 1
8728: ST_TO_ADDR
// end ;
8729: GO 8683
8731: POP
8732: POP
// tmp := ar_force_tmp ;
8733: LD_ADDR_VAR 0 2
8737: PUSH
8738: LD_EXP 40
8742: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8743: LD_VAR 0 2
8747: PUSH
8748: LD_INT 1
8750: ARRAY
8751: PPUSH
8752: LD_INT 108
8754: PPUSH
8755: LD_INT 139
8757: PPUSH
8758: LD_INT 0
8760: PPUSH
8761: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8765: LD_VAR 0 2
8769: PUSH
8770: LD_INT 1
8772: ARRAY
8773: PPUSH
8774: LD_EXP 21
8778: PPUSH
8779: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8783: LD_VAR 0 2
8787: PUSH
8788: LD_INT 2
8790: ARRAY
8791: PPUSH
8792: LD_INT 114
8794: PPUSH
8795: LD_INT 132
8797: PPUSH
8798: LD_INT 0
8800: PPUSH
8801: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8805: LD_VAR 0 2
8809: PUSH
8810: LD_INT 3
8812: ARRAY
8813: PPUSH
8814: LD_INT 115
8816: PPUSH
8817: LD_INT 132
8819: PPUSH
8820: LD_INT 0
8822: PPUSH
8823: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8827: LD_VAR 0 2
8831: PUSH
8832: LD_INT 2
8834: ARRAY
8835: PUSH
8836: LD_VAR 0 2
8840: PUSH
8841: LD_INT 3
8843: ARRAY
8844: PUSH
8845: EMPTY
8846: LIST
8847: LIST
8848: PPUSH
8849: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_INT 83
8860: PPUSH
8861: LD_INT 123
8863: PPUSH
8864: CALL_OW 111
// Wait ( 0 0$01 ) ;
8868: LD_INT 35
8870: PPUSH
8871: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8875: LD_INT 90
8877: PPUSH
8878: LD_INT 144
8880: PPUSH
8881: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8885: LD_VAR 0 5
8889: PPUSH
8890: LD_INT 88
8892: PPUSH
8893: LD_INT 129
8895: PPUSH
8896: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8900: LD_ADDR_VAR 0 3
8904: PUSH
8905: LD_INT 92
8907: PUSH
8908: LD_INT 131
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: LD_INT 88
8917: PUSH
8918: LD_INT 127
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 91
8927: PUSH
8928: LD_INT 132
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: LD_INT 92
8937: PUSH
8938: LD_INT 134
8940: PUSH
8941: EMPTY
8942: LIST
8943: LIST
8944: PUSH
8945: EMPTY
8946: LIST
8947: LIST
8948: LIST
8949: LIST
8950: ST_TO_ADDR
// for i = 1 to sols do
8951: LD_ADDR_VAR 0 6
8955: PUSH
8956: DOUBLE
8957: LD_INT 1
8959: DEC
8960: ST_TO_ADDR
8961: LD_VAR 0 5
8965: PUSH
8966: FOR_TO
8967: IFFALSE 9040
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8969: LD_VAR 0 5
8973: PUSH
8974: LD_VAR 0 6
8978: ARRAY
8979: PPUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_VAR 0 6
8989: ARRAY
8990: PUSH
8991: LD_INT 1
8993: ARRAY
8994: PPUSH
8995: LD_VAR 0 3
8999: PUSH
9000: LD_VAR 0 6
9004: ARRAY
9005: PUSH
9006: LD_INT 2
9008: ARRAY
9009: PPUSH
9010: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9014: LD_VAR 0 5
9018: PUSH
9019: LD_VAR 0 6
9023: ARRAY
9024: PPUSH
9025: CALL_OW 197
// AddComHold ( sols ) ;
9029: LD_VAR 0 5
9033: PPUSH
9034: CALL_OW 200
// end ;
9038: GO 8966
9040: POP
9041: POP
// repeat wait ( 0 0$1 ) ;
9042: LD_INT 35
9044: PPUSH
9045: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9049: LD_VAR 0 5
9053: PUSH
9054: LD_INT 1
9056: ARRAY
9057: PPUSH
9058: LD_INT 92
9060: PPUSH
9061: LD_INT 131
9063: PPUSH
9064: CALL_OW 297
9068: PUSH
9069: LD_INT 4
9071: LESS
9072: IFFALSE 9042
// CenterOnXY ( 96 , 139 ) ;
9074: LD_INT 96
9076: PPUSH
9077: LD_INT 139
9079: PPUSH
9080: CALL_OW 84
// wait ( 0 0$3 ) ;
9084: LD_INT 105
9086: PPUSH
9087: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9091: LD_INT 111
9093: PPUSH
9094: LD_INT 135
9096: PPUSH
9097: LD_INT 1
9099: PPUSH
9100: LD_INT 25
9102: NEG
9103: PPUSH
9104: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9108: LD_VAR 0 2
9112: PUSH
9113: LD_INT 2
9115: ARRAY
9116: PPUSH
9117: LD_VAR 0 2
9121: PUSH
9122: LD_INT 1
9124: ARRAY
9125: PPUSH
9126: CALL_OW 250
9130: PUSH
9131: LD_INT 3
9133: PLUS
9134: PPUSH
9135: LD_VAR 0 2
9139: PUSH
9140: LD_INT 1
9142: ARRAY
9143: PPUSH
9144: CALL_OW 251
9148: PPUSH
9149: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9153: LD_VAR 0 2
9157: PUSH
9158: LD_INT 3
9160: ARRAY
9161: PPUSH
9162: LD_INT 7
9164: PPUSH
9165: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9169: LD_VAR 0 2
9173: PUSH
9174: LD_INT 2
9176: ARRAY
9177: PPUSH
9178: LD_VAR 0 2
9182: PUSH
9183: LD_INT 1
9185: ARRAY
9186: PPUSH
9187: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9191: LD_INT 35
9193: PPUSH
9194: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9198: LD_VAR 0 2
9202: PUSH
9203: LD_INT 1
9205: ARRAY
9206: PPUSH
9207: LD_VAR 0 2
9211: PUSH
9212: LD_INT 2
9214: ARRAY
9215: PPUSH
9216: CALL_OW 296
9220: PUSH
9221: LD_INT 5
9223: LESS
9224: IFFALSE 9191
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9226: LD_VAR 0 2
9230: PUSH
9231: LD_INT 1
9233: ARRAY
9234: PPUSH
9235: LD_VAR 0 2
9239: PUSH
9240: LD_INT 2
9242: ARRAY
9243: PPUSH
9244: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9248: LD_VAR 0 2
9252: PUSH
9253: LD_INT 1
9255: ARRAY
9256: PPUSH
9257: LD_STRING D1a-Merc1-1
9259: PPUSH
9260: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9264: LD_VAR 0 2
9268: PUSH
9269: LD_INT 2
9271: ARRAY
9272: PPUSH
9273: LD_STRING D1a-FMerc2-1
9275: PPUSH
9276: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9280: LD_VAR 0 2
9284: PUSH
9285: LD_INT 2
9287: ARRAY
9288: PPUSH
9289: LD_VAR 0 2
9293: PUSH
9294: LD_INT 1
9296: ARRAY
9297: PPUSH
9298: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9302: LD_VAR 0 2
9306: PUSH
9307: LD_INT 1
9309: ARRAY
9310: PPUSH
9311: LD_INT 500
9313: PPUSH
9314: CALL_OW 234
// wait ( 0 0$2 ) ;
9318: LD_INT 70
9320: PPUSH
9321: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9325: LD_VAR 0 2
9329: PUSH
9330: LD_INT 1
9332: ARRAY
9333: PPUSH
9334: LD_INT 2
9336: PPUSH
9337: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9341: LD_INT 10
9343: PPUSH
9344: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9348: LD_VAR 0 2
9352: PUSH
9353: LD_INT 1
9355: ARRAY
9356: PPUSH
9357: LD_STRING D1a-Merc1-2
9359: PPUSH
9360: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9364: LD_INT 7
9366: PPUSH
9367: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9371: LD_VAR 0 2
9375: PUSH
9376: LD_INT 1
9378: ARRAY
9379: PPUSH
9380: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9384: LD_VAR 0 2
9388: PUSH
9389: LD_INT 2
9391: ARRAY
9392: PPUSH
9393: LD_INT 10
9395: PPUSH
9396: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9400: LD_VAR 0 2
9404: PUSH
9405: LD_INT 2
9407: ARRAY
9408: PPUSH
9409: LD_STRING D1a-FMerc2-2
9411: PPUSH
9412: CALL_OW 88
// wait ( 0 0$1 ) ;
9416: LD_INT 35
9418: PPUSH
9419: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9423: LD_INT 7
9425: PPUSH
9426: CALL_OW 85
// wait ( 0 0$2 ) ;
9430: LD_INT 70
9432: PPUSH
9433: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9437: LD_EXP 44
9441: PPUSH
9442: LD_STRING D1a-Saliba-1
9444: PPUSH
9445: CALL_OW 91
// KillUnit ( Saliba ) ;
9449: LD_EXP 44
9453: PPUSH
9454: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9458: LD_VAR 0 2
9462: PUSH
9463: LD_INT 3
9465: ARRAY
9466: PPUSH
9467: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9471: LD_EXP 21
9475: PPUSH
9476: CALL_OW 85
// wait ( 0 0$1 ) ;
9480: LD_INT 35
9482: PPUSH
9483: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9487: LD_VAR 0 5
9491: PPUSH
9492: LD_INT 88
9494: PPUSH
9495: LD_INT 141
9497: PPUSH
9498: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9502: LD_VAR 0 5
9506: PPUSH
9507: LD_INT 70
9509: PPUSH
9510: CALL_OW 202
// wait ( 0 0$2 ) ;
9514: LD_INT 70
9516: PPUSH
9517: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9521: LD_INT 2
9523: PPUSH
9524: LD_INT 1
9526: PPUSH
9527: LD_INT 2
9529: PPUSH
9530: LD_INT 1
9532: PPUSH
9533: CALL_OW 80
// InGameOff ;
9537: CALL_OW 9
// ComWalk ( sols ) ;
9541: LD_VAR 0 5
9545: PPUSH
9546: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9550: LD_STRING M1
9552: PPUSH
9553: CALL_OW 337
// game_speed := 4 ;
9557: LD_ADDR_OWVAR 65
9561: PUSH
9562: LD_INT 4
9564: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9565: LD_INT 111
9567: PPUSH
9568: LD_INT 135
9570: PPUSH
9571: LD_INT 1
9573: PPUSH
9574: CALL_OW 331
// SaveForQuickRestart ;
9578: CALL_OW 22
// ar_run := true ;
9582: LD_ADDR_EXP 5
9586: PUSH
9587: LD_INT 1
9589: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9590: LD_INT 35
9592: PPUSH
9593: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9597: LD_INT 22
9599: PUSH
9600: LD_INT 1
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PUSH
9607: LD_INT 91
9609: PUSH
9610: LD_INT 7
9612: PUSH
9613: LD_INT 10
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: LIST
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: PPUSH
9625: CALL_OW 69
9629: PUSH
9630: LD_INT 7
9632: PPUSH
9633: CALL_OW 256
9637: PUSH
9638: LD_INT 999
9640: LESS
9641: OR
9642: IFFALSE 9590
// if GetSide ( ar_dep_s ) = 2 then
9644: LD_INT 7
9646: PPUSH
9647: CALL_OW 255
9651: PUSH
9652: LD_INT 2
9654: EQUAL
9655: IFFALSE 9667
// SetSide ( ar_dep_s , 1 ) ;
9657: LD_INT 7
9659: PPUSH
9660: LD_INT 1
9662: PPUSH
9663: CALL_OW 235
// end ;
9667: LD_VAR 0 1
9671: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9672: LD_EXP 5
9676: IFFALSE 10036
9678: GO 9680
9680: DISABLE
9681: LD_INT 0
9683: PPUSH
9684: PPUSH
9685: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9686: LD_ADDR_VAR 0 2
9690: PUSH
9691: LD_EXP 40
9695: PUSH
9696: LD_EXP 36
9700: PPUSH
9701: LD_INT 2
9703: PUSH
9704: LD_INT 21
9706: PUSH
9707: LD_INT 2
9709: PUSH
9710: EMPTY
9711: LIST
9712: LIST
9713: PUSH
9714: LD_INT 21
9716: PUSH
9717: LD_INT 1
9719: PUSH
9720: EMPTY
9721: LIST
9722: LIST
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: LIST
9728: PPUSH
9729: CALL_OW 72
9733: ADD
9734: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9735: LD_VAR 0 2
9739: PPUSH
9740: LD_INT 5
9742: PPUSH
9743: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9747: LD_INT 5
9749: PPUSH
9750: LD_INT 1
9752: PPUSH
9753: CALL_OW 343
// k := 1 ;
9757: LD_ADDR_VAR 0 3
9761: PUSH
9762: LD_INT 1
9764: ST_TO_ADDR
// for i in tmp do
9765: LD_ADDR_VAR 0 1
9769: PUSH
9770: LD_VAR 0 2
9774: PUSH
9775: FOR_IN
9776: IFFALSE 9861
// begin if IsInUnit ( i ) then
9778: LD_VAR 0 1
9782: PPUSH
9783: CALL_OW 310
9787: IFFALSE 9798
// ComExitBuilding ( i ) ;
9789: LD_VAR 0 1
9793: PPUSH
9794: CALL_OW 122
// if GetClass ( i ) = 3 then
9798: LD_VAR 0 1
9802: PPUSH
9803: CALL_OW 257
9807: PUSH
9808: LD_INT 3
9810: EQUAL
9811: IFFALSE 9847
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9813: LD_VAR 0 1
9817: PPUSH
9818: LD_EXP 41
9822: PUSH
9823: LD_VAR 0 3
9827: ARRAY
9828: PPUSH
9829: CALL_OW 180
// k := k + 1 ;
9833: LD_ADDR_VAR 0 3
9837: PUSH
9838: LD_VAR 0 3
9842: PUSH
9843: LD_INT 1
9845: PLUS
9846: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9847: LD_VAR 0 1
9851: PPUSH
9852: LD_INT 10
9854: PPUSH
9855: CALL_OW 173
// end ;
9859: GO 9775
9861: POP
9862: POP
// ar_patrol := true ;
9863: LD_ADDR_EXP 7
9867: PUSH
9868: LD_INT 1
9870: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9871: LD_INT 10
9873: PPUSH
9874: CALL_OW 67
// for i in tmp do
9878: LD_ADDR_VAR 0 1
9882: PUSH
9883: LD_VAR 0 2
9887: PUSH
9888: FOR_IN
9889: IFFALSE 9917
// if not HasTask ( i ) then
9891: LD_VAR 0 1
9895: PPUSH
9896: CALL_OW 314
9900: NOT
9901: IFFALSE 9915
// ComMoveToArea ( i , escape_area ) ;
9903: LD_VAR 0 1
9907: PPUSH
9908: LD_INT 10
9910: PPUSH
9911: CALL_OW 113
9915: GO 9888
9917: POP
9918: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9919: LD_ADDR_VAR 0 3
9923: PUSH
9924: LD_VAR 0 2
9928: PPUSH
9929: LD_INT 95
9931: PUSH
9932: LD_INT 10
9934: PUSH
9935: EMPTY
9936: LIST
9937: LIST
9938: PPUSH
9939: CALL_OW 72
9943: ST_TO_ADDR
// if k then
9944: LD_VAR 0 3
9948: IFFALSE 10017
// for i in k do
9950: LD_ADDR_VAR 0 1
9954: PUSH
9955: LD_VAR 0 3
9959: PUSH
9960: FOR_IN
9961: IFFALSE 10015
// begin if IsInUnit ( i ) then
9963: LD_VAR 0 1
9967: PPUSH
9968: CALL_OW 310
9972: IFFALSE 9988
// RemoveUnit ( IsInUnit ( i ) ) ;
9974: LD_VAR 0 1
9978: PPUSH
9979: CALL_OW 310
9983: PPUSH
9984: CALL_OW 64
// RemoveUnit ( i ) ;
9988: LD_VAR 0 1
9992: PPUSH
9993: CALL_OW 64
// tmp := tmp diff i ;
9997: LD_ADDR_VAR 0 2
10001: PUSH
10002: LD_VAR 0 2
10006: PUSH
10007: LD_VAR 0 1
10011: DIFF
10012: ST_TO_ADDR
// end ;
10013: GO 9960
10015: POP
10016: POP
// until tmp = [ ] ;
10017: LD_VAR 0 2
10021: PUSH
10022: EMPTY
10023: EQUAL
10024: IFFALSE 9871
// ChangeSideFog ( 5 , 5 ) ;
10026: LD_INT 5
10028: PPUSH
10029: LD_INT 5
10031: PPUSH
10032: CALL_OW 343
// end ;
10036: PPOPN 3
10038: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10039: LD_EXP 7
10043: IFFALSE 10333
10045: GO 10047
10047: DISABLE
10048: LD_INT 0
10050: PPUSH
10051: PPUSH
10052: PPUSH
// begin uc_side := 2 ;
10053: LD_ADDR_OWVAR 20
10057: PUSH
10058: LD_INT 2
10060: ST_TO_ADDR
// uc_nation := 2 ;
10061: LD_ADDR_OWVAR 21
10065: PUSH
10066: LD_INT 2
10068: ST_TO_ADDR
// InitHc ;
10069: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10073: LD_INT 1
10075: PPUSH
10076: LD_INT 1
10078: PPUSH
10079: LD_INT 6
10081: PPUSH
10082: CALL_OW 380
// un := CreateHuman ;
10086: LD_ADDR_VAR 0 2
10090: PUSH
10091: CALL_OW 44
10095: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10096: LD_INT 14
10098: PPUSH
10099: LD_INT 1
10101: PPUSH
10102: LD_INT 1
10104: PPUSH
10105: LD_INT 27
10107: PPUSH
10108: LD_INT 98
10110: PPUSH
10111: CALL 53442 0 5
// veh := CreateVehicle ;
10115: LD_ADDR_VAR 0 3
10119: PUSH
10120: CALL_OW 45
10124: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10125: LD_VAR 0 3
10129: PPUSH
10130: LD_INT 4
10132: PPUSH
10133: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10137: LD_VAR 0 3
10141: PPUSH
10142: LD_INT 179
10144: PPUSH
10145: LD_INT 135
10147: PPUSH
10148: LD_INT 0
10150: PPUSH
10151: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10155: LD_VAR 0 2
10159: PPUSH
10160: LD_VAR 0 3
10164: PPUSH
10165: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10169: LD_VAR 0 2
10173: PPUSH
10174: LD_INT 126
10176: PPUSH
10177: LD_INT 133
10179: PPUSH
10180: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10184: LD_INT 10
10186: PPUSH
10187: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10191: LD_INT 1
10193: PPUSH
10194: LD_VAR 0 3
10198: PPUSH
10199: CALL_OW 292
10203: PUSH
10204: LD_VAR 0 3
10208: PPUSH
10209: LD_INT 7
10211: PPUSH
10212: CALL_OW 296
10216: PUSH
10217: LD_INT 9
10219: LESS
10220: OR
10221: IFFALSE 10184
// ComHold ( veh ) ;
10223: LD_VAR 0 3
10227: PPUSH
10228: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10232: LD_VAR 0 2
10236: PPUSH
10237: LD_STRING D2aa-Ar1-1
10239: PPUSH
10240: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10244: LD_VAR 0 2
10248: PPUSH
10249: LD_INT 177
10251: PPUSH
10252: LD_INT 96
10254: PPUSH
10255: CALL_OW 111
// AddComExitVehicle ( un ) ;
10259: LD_VAR 0 2
10263: PPUSH
10264: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10268: LD_INT 35
10270: PPUSH
10271: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10275: LD_VAR 0 2
10279: PPUSH
10280: LD_INT 204
10282: PPUSH
10283: CALL_OW 296
10287: PUSH
10288: LD_INT 15
10290: LESS
10291: IFFALSE 10268
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10293: LD_ADDR_EXP 50
10297: PUSH
10298: LD_EXP 50
10302: PPUSH
10303: LD_INT 3
10305: PUSH
10306: LD_EXP 50
10310: PUSH
10311: LD_INT 3
10313: ARRAY
10314: PUSH
10315: LD_INT 1
10317: PLUS
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: PPUSH
10323: LD_VAR 0 2
10327: PPUSH
10328: CALL 53564 0 3
10332: ST_TO_ADDR
// end ;
10333: PPOPN 3
10335: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10336: LD_INT 7
10338: PPUSH
10339: CALL_OW 255
10343: PUSH
10344: LD_INT 1
10346: EQUAL
10347: PUSH
10348: LD_INT 7
10350: PPUSH
10351: CALL_OW 301
10355: OR
10356: IFFALSE 12764
10358: GO 10360
10360: DISABLE
10361: LD_INT 0
10363: PPUSH
10364: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10365: LD_ADDR_VAR 0 1
10369: PUSH
10370: LD_EXP 36
10374: PPUSH
10375: LD_INT 21
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: EMPTY
10382: LIST
10383: LIST
10384: PPUSH
10385: CALL_OW 72
10389: PUSH
10390: FOR_IN
10391: IFFALSE 10407
// SetSide ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 235
10405: GO 10390
10407: POP
10408: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10409: LD_ADDR_VAR 0 2
10413: PUSH
10414: LD_INT 46
10416: PUSH
10417: LD_INT 41
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: PUSH
10424: LD_INT 50
10426: PUSH
10427: LD_INT 25
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: PUSH
10434: LD_INT 57
10436: PUSH
10437: LD_INT 75
10439: PUSH
10440: EMPTY
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 75
10446: PUSH
10447: LD_INT 89
10449: PUSH
10450: EMPTY
10451: LIST
10452: LIST
10453: PUSH
10454: LD_INT 51
10456: PUSH
10457: LD_INT 45
10459: PUSH
10460: EMPTY
10461: LIST
10462: LIST
10463: PUSH
10464: LD_INT 95
10466: PUSH
10467: LD_INT 95
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: PUSH
10474: LD_INT 84
10476: PUSH
10477: LD_INT 77
10479: PUSH
10480: EMPTY
10481: LIST
10482: LIST
10483: PUSH
10484: LD_INT 101
10486: PUSH
10487: LD_INT 76
10489: PUSH
10490: EMPTY
10491: LIST
10492: LIST
10493: PUSH
10494: LD_INT 118
10496: PUSH
10497: LD_INT 81
10499: PUSH
10500: EMPTY
10501: LIST
10502: LIST
10503: PUSH
10504: LD_INT 139
10506: PUSH
10507: LD_INT 97
10509: PUSH
10510: EMPTY
10511: LIST
10512: LIST
10513: PUSH
10514: LD_INT 129
10516: PUSH
10517: LD_INT 114
10519: PUSH
10520: EMPTY
10521: LIST
10522: LIST
10523: PUSH
10524: LD_INT 154
10526: PUSH
10527: LD_INT 111
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PUSH
10534: EMPTY
10535: LIST
10536: LIST
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: ST_TO_ADDR
// base_captured := true ;
10548: LD_ADDR_EXP 6
10552: PUSH
10553: LD_INT 1
10555: ST_TO_ADDR
// DialogueOn ;
10556: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10560: LD_EXP 21
10564: PPUSH
10565: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10569: LD_EXP 21
10573: PPUSH
10574: LD_STRING D2-JMM-1
10576: PPUSH
10577: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10581: LD_EXP 30
10585: PPUSH
10586: LD_STRING D2-Pow-1
10588: PPUSH
10589: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10593: LD_EXP 21
10597: PPUSH
10598: LD_STRING D2-JMM-2
10600: PPUSH
10601: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10605: LD_EXP 30
10609: PPUSH
10610: LD_STRING D2-Pow-2
10612: PPUSH
10613: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10617: LD_EXP 21
10621: PPUSH
10622: LD_STRING D2-JMM-3
10624: PPUSH
10625: CALL_OW 88
// DialogueOff ;
10629: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10633: LD_STRING M2
10635: PPUSH
10636: CALL_OW 337
// Wait ( 0 0$2 ) ;
10640: LD_INT 70
10642: PPUSH
10643: CALL_OW 67
// if IsOk ( Gary ) then
10647: LD_EXP 32
10651: PPUSH
10652: CALL_OW 302
10656: IFFALSE 10670
// Say ( Gary , D2a-Gary-1 ) ;
10658: LD_EXP 32
10662: PPUSH
10663: LD_STRING D2a-Gary-1
10665: PPUSH
10666: CALL_OW 88
// if IsOk ( Bobby ) then
10670: LD_EXP 24
10674: PPUSH
10675: CALL_OW 302
10679: IFFALSE 10693
// Say ( Bobby , D2a-Bobby-1 ) ;
10681: LD_EXP 24
10685: PPUSH
10686: LD_STRING D2a-Bobby-1
10688: PPUSH
10689: CALL_OW 88
// if IsOk ( Cyrus ) then
10693: LD_EXP 25
10697: PPUSH
10698: CALL_OW 302
10702: IFFALSE 10716
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10704: LD_EXP 25
10708: PPUSH
10709: LD_STRING D2a-Cyrus-1
10711: PPUSH
10712: CALL_OW 88
// if IsOk ( Lisa ) then
10716: LD_EXP 22
10720: PPUSH
10721: CALL_OW 302
10725: IFFALSE 10739
// Say ( Lisa , D2a-Lisa-1 ) ;
10727: LD_EXP 22
10731: PPUSH
10732: LD_STRING D2a-Lisa-1
10734: PPUSH
10735: CALL_OW 88
// if IsOk ( Frank ) then
10739: LD_EXP 33
10743: PPUSH
10744: CALL_OW 302
10748: IFFALSE 10762
// Say ( Frank , D2a-Frank-1 ) ;
10750: LD_EXP 33
10754: PPUSH
10755: LD_STRING D2a-Frank-1
10757: PPUSH
10758: CALL_OW 88
// if IsOk ( Cornel ) then
10762: LD_EXP 31
10766: PPUSH
10767: CALL_OW 302
10771: IFFALSE 10785
// Say ( Cornel , D2a-Corn-1 ) ;
10773: LD_EXP 31
10777: PPUSH
10778: LD_STRING D2a-Corn-1
10780: PPUSH
10781: CALL_OW 88
// if IsOk ( Donaldson ) then
10785: LD_EXP 23
10789: PPUSH
10790: CALL_OW 302
10794: IFFALSE 10808
// Say ( Donaldson , D2a-Don-1 ) ;
10796: LD_EXP 23
10800: PPUSH
10801: LD_STRING D2a-Don-1
10803: PPUSH
10804: CALL_OW 88
// if IsOk ( Brown ) then
10808: LD_EXP 27
10812: PPUSH
10813: CALL_OW 302
10817: IFFALSE 10831
// Say ( Brown , D2a-Brown-1 ) ;
10819: LD_EXP 27
10823: PPUSH
10824: LD_STRING D2a-Brown-1
10826: PPUSH
10827: CALL_OW 88
// Wait ( 0 0$30 ) ;
10831: LD_INT 1050
10833: PPUSH
10834: CALL_OW 67
// if IsOk ( Frank ) then
10838: LD_EXP 33
10842: PPUSH
10843: CALL_OW 302
10847: IFFALSE 11113
// begin DialogueOn ;
10849: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10853: LD_EXP 21
10857: PUSH
10858: LD_EXP 33
10862: PUSH
10863: EMPTY
10864: LIST
10865: LIST
10866: PPUSH
10867: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10871: LD_EXP 33
10875: PPUSH
10876: LD_STRING D3F-Frank-1
10878: PPUSH
10879: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10883: LD_EXP 21
10887: PPUSH
10888: LD_STRING D3F-JMM-1
10890: PPUSH
10891: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10895: LD_EXP 33
10899: PPUSH
10900: LD_STRING D3F-Frank-2
10902: PPUSH
10903: CALL_OW 88
// case Query ( QFrank ) of 1 :
10907: LD_STRING QFrank
10909: PPUSH
10910: CALL_OW 97
10914: PUSH
10915: LD_INT 1
10917: DOUBLE
10918: EQUAL
10919: IFTRUE 10923
10921: GO 10946
10923: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10924: LD_EXP 21
10928: PPUSH
10929: LD_STRING D3Fa-JMM-1
10931: PPUSH
10932: CALL_OW 88
// us_scout := 1 ;
10936: LD_ADDR_EXP 8
10940: PUSH
10941: LD_INT 1
10943: ST_TO_ADDR
// end ; 2 :
10944: GO 11109
10946: LD_INT 2
10948: DOUBLE
10949: EQUAL
10950: IFTRUE 10954
10952: GO 11076
10954: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10955: LD_EXP 21
10959: PPUSH
10960: LD_STRING D3Fb-JMM-1
10962: PPUSH
10963: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10967: LD_EXP 33
10971: PPUSH
10972: LD_STRING D3Fb-Frank-1
10974: PPUSH
10975: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10979: LD_STRING QFrank2
10981: PPUSH
10982: CALL_OW 97
10986: PUSH
10987: LD_INT 1
10989: DOUBLE
10990: EQUAL
10991: IFTRUE 10995
10993: GO 11042
10995: POP
// begin us_scout := 2 ;
10996: LD_ADDR_EXP 8
11000: PUSH
11001: LD_INT 2
11003: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11004: LD_EXP 21
11008: PPUSH
11009: LD_STRING D3Fba-JMM-1
11011: PPUSH
11012: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11016: LD_EXP 33
11020: PPUSH
11021: LD_STRING D3Fba-Frank-1
11023: PPUSH
11024: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11028: LD_EXP 21
11032: PPUSH
11033: LD_STRING D3Fba-JMM-2
11035: PPUSH
11036: CALL_OW 88
// end ; 2 :
11040: GO 11074
11042: LD_INT 2
11044: DOUBLE
11045: EQUAL
11046: IFTRUE 11050
11048: GO 11073
11050: POP
// begin us_scout := 0 ;
11051: LD_ADDR_EXP 8
11055: PUSH
11056: LD_INT 0
11058: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11059: LD_EXP 21
11063: PPUSH
11064: LD_STRING D3Fbb-JMM-1
11066: PPUSH
11067: CALL_OW 88
// end ; end ;
11071: GO 11074
11073: POP
// end ; 3 :
11074: GO 11109
11076: LD_INT 3
11078: DOUBLE
11079: EQUAL
11080: IFTRUE 11084
11082: GO 11108
11084: POP
// begin us_scout := - 1 ;
11085: LD_ADDR_EXP 8
11089: PUSH
11090: LD_INT 1
11092: NEG
11093: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11094: LD_EXP 21
11098: PPUSH
11099: LD_STRING D3Fc-JMM-1
11101: PPUSH
11102: CALL_OW 88
// end ; end ;
11106: GO 11109
11108: POP
// DialogueOff ;
11109: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
11113: LD_EXP 8
11117: PUSH
11118: LD_INT 1
11120: NEG
11121: PUSH
11122: LD_INT 0
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: IN
11129: IFFALSE 11133
// exit ;
11131: GO 12764
// if us_scout in [ 1 , 2 ] then
11133: LD_EXP 8
11137: PUSH
11138: LD_INT 1
11140: PUSH
11141: LD_INT 2
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: IN
11148: IFFALSE 11827
// begin if IsInUnit ( Frank ) then
11150: LD_EXP 33
11154: PPUSH
11155: CALL_OW 310
11159: IFFALSE 11170
// ComExit ( Frank ) ;
11161: LD_EXP 33
11165: PPUSH
11166: CALL 85647 0 1
// SetSide ( Frank , 4 ) ;
11170: LD_EXP 33
11174: PPUSH
11175: LD_INT 4
11177: PPUSH
11178: CALL_OW 235
// wait ( 0 0$1 ) ;
11182: LD_INT 35
11184: PPUSH
11185: CALL_OW 67
// if us_scout = 2 then
11189: LD_EXP 8
11193: PUSH
11194: LD_INT 2
11196: EQUAL
11197: IFFALSE 11565
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11199: LD_EXP 33
11203: PPUSH
11204: LD_INT 75
11206: PPUSH
11207: LD_INT 63
11209: PPUSH
11210: CALL_OW 111
// AddComHold ( Frank ) ;
11214: LD_EXP 33
11218: PPUSH
11219: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11223: LD_EXP 33
11227: PPUSH
11228: LD_INT 770
11230: PPUSH
11231: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11235: LD_EXP 33
11239: PPUSH
11240: LD_INT 100
11242: PPUSH
11243: LD_INT 75
11245: PPUSH
11246: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11250: LD_EXP 33
11254: PPUSH
11255: LD_INT 123
11257: PPUSH
11258: LD_INT 103
11260: PPUSH
11261: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11265: LD_EXP 33
11269: PPUSH
11270: LD_INT 138
11272: PPUSH
11273: LD_INT 108
11275: PPUSH
11276: CALL_OW 171
// AddComHold ( Frank ) ;
11280: LD_EXP 33
11284: PPUSH
11285: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11289: LD_INT 35
11291: PPUSH
11292: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11296: LD_EXP 33
11300: PPUSH
11301: LD_INT 138
11303: PPUSH
11304: LD_INT 108
11306: PPUSH
11307: CALL_OW 307
11311: IFFALSE 11289
// AddComMoveXY ( Frank , 125 , 132 ) ;
11313: LD_EXP 33
11317: PPUSH
11318: LD_INT 125
11320: PPUSH
11321: LD_INT 132
11323: PPUSH
11324: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11328: LD_INT 35
11330: PPUSH
11331: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11335: LD_INT 1
11337: PPUSH
11338: LD_EXP 33
11342: PPUSH
11343: CALL_OW 292
11347: PUSH
11348: LD_EXP 33
11352: PPUSH
11353: LD_INT 7
11355: PPUSH
11356: CALL_OW 296
11360: PUSH
11361: LD_INT 7
11363: LESS
11364: OR
11365: IFFALSE 11328
// DialogueOn ;
11367: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11371: LD_EXP 33
11375: PPUSH
11376: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11380: LD_INT 10
11382: PPUSH
11383: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11387: LD_EXP 21
11391: PPUSH
11392: LD_STRING D4Fa-JMM-1
11394: PPUSH
11395: CALL_OW 88
// for i in points do
11399: LD_ADDR_VAR 0 1
11403: PUSH
11404: LD_VAR 0 2
11408: PUSH
11409: FOR_IN
11410: IFFALSE 11468
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11412: LD_VAR 0 1
11416: PUSH
11417: LD_INT 1
11419: ARRAY
11420: PPUSH
11421: LD_VAR 0 1
11425: PUSH
11426: LD_INT 2
11428: ARRAY
11429: PPUSH
11430: LD_INT 1
11432: PPUSH
11433: LD_INT 20
11435: NEG
11436: PPUSH
11437: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11441: LD_VAR 0 1
11445: PUSH
11446: LD_INT 1
11448: ARRAY
11449: PPUSH
11450: LD_VAR 0 1
11454: PUSH
11455: LD_INT 2
11457: ARRAY
11458: PPUSH
11459: LD_INT 1
11461: PPUSH
11462: CALL_OW 331
// end ;
11466: GO 11409
11468: POP
11469: POP
// dwait ( 0 0$0.5 ) ;
11470: LD_INT 18
11472: PPUSH
11473: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11477: LD_INT 42
11479: PPUSH
11480: LD_INT 27
11482: PPUSH
11483: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11487: LD_EXP 33
11491: PPUSH
11492: LD_STRING D4Fa-Frank-1
11494: PPUSH
11495: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11499: LD_INT 18
11501: PPUSH
11502: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11506: LD_EXP 21
11510: PPUSH
11511: LD_STRING D4Fa-JMM-2
11513: PPUSH
11514: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11518: LD_INT 118
11520: PPUSH
11521: LD_INT 80
11523: PPUSH
11524: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11528: LD_EXP 33
11532: PPUSH
11533: LD_STRING D4Fa-Frank-2
11535: PPUSH
11536: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11540: LD_INT 10
11542: PPUSH
11543: CALL_OW 68
// DialogueOff ;
11547: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11551: LD_EXP 33
11555: PPUSH
11556: LD_INT 1
11558: PPUSH
11559: CALL_OW 235
// end else
11563: GO 11827
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11565: LD_INT 2
11567: PPUSH
11568: LD_INT 4
11570: PPUSH
11571: LD_INT 2
11573: PPUSH
11574: LD_INT 1
11576: PPUSH
11577: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11581: LD_EXP 33
11585: PPUSH
11586: LD_INT 75
11588: PPUSH
11589: LD_INT 63
11591: PPUSH
11592: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11596: LD_EXP 33
11600: PPUSH
11601: LD_INT 175
11603: PPUSH
11604: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11608: LD_EXP 33
11612: PPUSH
11613: LD_INT 102
11615: PPUSH
11616: LD_INT 76
11618: PPUSH
11619: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11623: LD_EXP 33
11627: PPUSH
11628: LD_INT 108
11630: PPUSH
11631: LD_INT 70
11633: PPUSH
11634: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11638: LD_INT 35
11640: PPUSH
11641: CALL_OW 67
// until See ( 2 , Frank ) ;
11645: LD_INT 2
11647: PPUSH
11648: LD_EXP 33
11652: PPUSH
11653: CALL_OW 292
11657: IFFALSE 11638
// ComMoveXY ( Frank , 112 , 118 ) ;
11659: LD_EXP 33
11663: PPUSH
11664: LD_INT 112
11666: PPUSH
11667: LD_INT 118
11669: PPUSH
11670: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11674: LD_EXP 33
11678: PPUSH
11679: CALL_OW 256
11683: PUSH
11684: LD_INT 750
11686: GREATEREQUAL
11687: IFFALSE 11701
// SetLives ( Frank , 700 ) ;
11689: LD_EXP 33
11693: PPUSH
11694: LD_INT 700
11696: PPUSH
11697: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11701: LD_INT 35
11703: PPUSH
11704: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11708: LD_INT 1
11710: PPUSH
11711: LD_EXP 33
11715: PPUSH
11716: CALL_OW 292
11720: PUSH
11721: LD_EXP 33
11725: PPUSH
11726: LD_INT 7
11728: PPUSH
11729: CALL_OW 296
11733: PUSH
11734: LD_INT 17
11736: LESS
11737: OR
11738: IFFALSE 11701
// DialogueOn ;
11740: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11744: LD_EXP 33
11748: PPUSH
11749: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11753: LD_EXP 33
11757: PPUSH
11758: LD_STRING D4Fb-Frank-1
11760: PPUSH
11761: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11765: LD_EXP 21
11769: PPUSH
11770: LD_STRING D4Fb-JMM-1
11772: PPUSH
11773: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11777: LD_INT 2
11779: PPUSH
11780: LD_STRING D4Fb-FSci1-1
11782: PPUSH
11783: CALL 16687 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11787: LD_EXP 33
11791: PPUSH
11792: LD_STRING D4Fb-Frank-2
11794: PPUSH
11795: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11799: LD_EXP 21
11803: PPUSH
11804: LD_STRING D4Fb-JMM-2
11806: PPUSH
11807: CALL_OW 88
// DialogueOff ;
11811: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11815: LD_EXP 33
11819: PPUSH
11820: LD_INT 1
11822: PPUSH
11823: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11827: LD_EXP 34
11831: PPUSH
11832: CALL_OW 302
11836: PUSH
11837: LD_EXP 33
11841: NOT
11842: AND
11843: IFFALSE 11991
// begin DialogueOn ;
11845: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11849: LD_EXP 21
11853: PUSH
11854: LD_EXP 34
11858: PUSH
11859: EMPTY
11860: LIST
11861: LIST
11862: PPUSH
11863: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11867: LD_EXP 34
11871: PPUSH
11872: LD_STRING D3Y-Yam-1
11874: PPUSH
11875: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11879: LD_EXP 21
11883: PPUSH
11884: LD_STRING D3Y-JMM-1
11886: PPUSH
11887: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11891: LD_EXP 34
11895: PPUSH
11896: LD_STRING D3Y-Yam-2
11898: PPUSH
11899: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11903: LD_STRING QYamoko
11905: PPUSH
11906: CALL_OW 97
11910: PUSH
11911: LD_INT 1
11913: DOUBLE
11914: EQUAL
11915: IFTRUE 11919
11917: GO 11954
11919: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11920: LD_EXP 21
11924: PPUSH
11925: LD_STRING D3Ya-JMM-1
11927: PPUSH
11928: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11932: LD_EXP 34
11936: PPUSH
11937: LD_STRING D3Ya-Yam-1
11939: PPUSH
11940: CALL_OW 88
// us_scout := 1 ;
11944: LD_ADDR_EXP 8
11948: PUSH
11949: LD_INT 1
11951: ST_TO_ADDR
// end ; 2 :
11952: GO 11987
11954: LD_INT 2
11956: DOUBLE
11957: EQUAL
11958: IFTRUE 11962
11960: GO 11986
11962: POP
// begin us_scout := - 1 ;
11963: LD_ADDR_EXP 8
11967: PUSH
11968: LD_INT 1
11970: NEG
11971: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11972: LD_EXP 21
11976: PPUSH
11977: LD_STRING D3Yb-JMM-1
11979: PPUSH
11980: CALL_OW 88
// end ; end ;
11984: GO 11987
11986: POP
// DialogueOff ;
11987: CALL_OW 7
// end ; if Frank then
11991: LD_EXP 33
11995: IFFALSE 11999
// exit ;
11997: GO 12764
// if us_scout in [ - 1 , 0 ] then
11999: LD_EXP 8
12003: PUSH
12004: LD_INT 1
12006: NEG
12007: PUSH
12008: LD_INT 0
12010: PUSH
12011: EMPTY
12012: LIST
12013: LIST
12014: IN
12015: IFFALSE 12019
// exit ;
12017: GO 12764
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12019: LD_ADDR_EXP 8
12023: PUSH
12024: LD_INT 2
12026: PUSH
12027: LD_INT 2
12029: PUSH
12030: LD_INT 1
12032: PUSH
12033: LD_INT 1
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: LIST
12040: LIST
12041: PUSH
12042: LD_OWVAR 67
12046: ARRAY
12047: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12048: LD_EXP 8
12052: PUSH
12053: LD_INT 1
12055: PUSH
12056: LD_INT 2
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: IN
12063: IFFALSE 12764
// begin if IsInUnit ( Kikuchi ) then
12065: LD_EXP 34
12069: PPUSH
12070: CALL_OW 310
12074: IFFALSE 12085
// ComExitBuilding ( Kikuchi ) ;
12076: LD_EXP 34
12080: PPUSH
12081: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12085: LD_EXP 34
12089: PPUSH
12090: CALL_OW 311
12094: IFFALSE 12105
// ComExitVehicle ( Kikuchi ) ;
12096: LD_EXP 34
12100: PPUSH
12101: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12105: LD_EXP 34
12109: PPUSH
12110: LD_INT 4
12112: PPUSH
12113: CALL_OW 235
// wait ( 0 0$1 ) ;
12117: LD_INT 35
12119: PPUSH
12120: CALL_OW 67
// if us_scout = 2 then
12124: LD_EXP 8
12128: PUSH
12129: LD_INT 2
12131: EQUAL
12132: IFFALSE 12512
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12134: LD_EXP 34
12138: PPUSH
12139: LD_INT 75
12141: PPUSH
12142: LD_INT 63
12144: PPUSH
12145: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12149: LD_EXP 34
12153: PPUSH
12154: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12158: LD_EXP 34
12162: PPUSH
12163: LD_INT 770
12165: PPUSH
12166: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12170: LD_EXP 34
12174: PPUSH
12175: LD_INT 100
12177: PPUSH
12178: LD_INT 75
12180: PPUSH
12181: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12185: LD_EXP 34
12189: PPUSH
12190: LD_INT 123
12192: PPUSH
12193: LD_INT 103
12195: PPUSH
12196: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12200: LD_EXP 34
12204: PPUSH
12205: LD_INT 138
12207: PPUSH
12208: LD_INT 108
12210: PPUSH
12211: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12215: LD_EXP 34
12219: PPUSH
12220: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12224: LD_INT 35
12226: PPUSH
12227: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12231: LD_EXP 34
12235: PPUSH
12236: LD_INT 138
12238: PPUSH
12239: LD_INT 108
12241: PPUSH
12242: CALL_OW 307
12246: IFFALSE 12224
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12248: LD_EXP 34
12252: PPUSH
12253: LD_INT 125
12255: PPUSH
12256: LD_INT 132
12258: PPUSH
12259: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12263: LD_INT 35
12265: PPUSH
12266: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12270: LD_INT 1
12272: PPUSH
12273: LD_EXP 34
12277: PPUSH
12278: CALL_OW 292
12282: PUSH
12283: LD_EXP 34
12287: PPUSH
12288: LD_INT 7
12290: PPUSH
12291: CALL_OW 296
12295: PUSH
12296: LD_INT 7
12298: LESS
12299: OR
12300: IFFALSE 12263
// DialogueOn ;
12302: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12306: LD_EXP 34
12310: PPUSH
12311: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12315: LD_INT 10
12317: PPUSH
12318: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12322: LD_EXP 34
12326: PPUSH
12327: LD_STRING D4Ya-Yam-1
12329: PPUSH
12330: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12334: LD_EXP 21
12338: PPUSH
12339: LD_STRING D4Ya-JMM-1
12341: PPUSH
12342: CALL_OW 88
// for i in points do
12346: LD_ADDR_VAR 0 1
12350: PUSH
12351: LD_VAR 0 2
12355: PUSH
12356: FOR_IN
12357: IFFALSE 12415
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12359: LD_VAR 0 1
12363: PUSH
12364: LD_INT 1
12366: ARRAY
12367: PPUSH
12368: LD_VAR 0 1
12372: PUSH
12373: LD_INT 2
12375: ARRAY
12376: PPUSH
12377: LD_INT 1
12379: PPUSH
12380: LD_INT 20
12382: NEG
12383: PPUSH
12384: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12388: LD_VAR 0 1
12392: PUSH
12393: LD_INT 1
12395: ARRAY
12396: PPUSH
12397: LD_VAR 0 1
12401: PUSH
12402: LD_INT 2
12404: ARRAY
12405: PPUSH
12406: LD_INT 1
12408: PPUSH
12409: CALL_OW 331
// end ;
12413: GO 12356
12415: POP
12416: POP
// dwait ( 0 0$0.5 ) ;
12417: LD_INT 18
12419: PPUSH
12420: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12424: LD_INT 42
12426: PPUSH
12427: LD_INT 27
12429: PPUSH
12430: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12434: LD_EXP 34
12438: PPUSH
12439: LD_STRING D4Ya-Yam-2
12441: PPUSH
12442: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12446: LD_INT 18
12448: PPUSH
12449: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12453: LD_INT 118
12455: PPUSH
12456: LD_INT 80
12458: PPUSH
12459: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12463: LD_EXP 21
12467: PPUSH
12468: LD_STRING D4Ya-JMM-2
12470: PPUSH
12471: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12475: LD_EXP 34
12479: PPUSH
12480: LD_STRING D4Ya-Yam-3
12482: PPUSH
12483: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12487: LD_INT 10
12489: PPUSH
12490: CALL_OW 68
// DialogueOff ;
12494: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12498: LD_EXP 34
12502: PPUSH
12503: LD_INT 1
12505: PPUSH
12506: CALL_OW 235
// end else
12510: GO 12764
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12512: LD_INT 2
12514: PPUSH
12515: LD_INT 4
12517: PPUSH
12518: LD_INT 2
12520: PPUSH
12521: LD_INT 1
12523: PPUSH
12524: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_INT 75
12535: PPUSH
12536: LD_INT 63
12538: PPUSH
12539: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12543: LD_EXP 34
12547: PPUSH
12548: LD_INT 175
12550: PPUSH
12551: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12555: LD_EXP 34
12559: PPUSH
12560: LD_INT 102
12562: PPUSH
12563: LD_INT 76
12565: PPUSH
12566: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12570: LD_EXP 34
12574: PPUSH
12575: LD_INT 108
12577: PPUSH
12578: LD_INT 70
12580: PPUSH
12581: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12585: LD_INT 35
12587: PPUSH
12588: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12592: LD_INT 2
12594: PPUSH
12595: LD_EXP 34
12599: PPUSH
12600: CALL_OW 292
12604: IFFALSE 12585
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12606: LD_EXP 34
12610: PPUSH
12611: LD_INT 112
12613: PPUSH
12614: LD_INT 118
12616: PPUSH
12617: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12621: LD_EXP 34
12625: PPUSH
12626: CALL_OW 256
12630: PUSH
12631: LD_INT 750
12633: GREATEREQUAL
12634: IFFALSE 12648
// SetLives ( Kikuchi , 700 ) ;
12636: LD_EXP 34
12640: PPUSH
12641: LD_INT 700
12643: PPUSH
12644: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12648: LD_INT 35
12650: PPUSH
12651: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12655: LD_INT 1
12657: PPUSH
12658: LD_EXP 34
12662: PPUSH
12663: CALL_OW 292
12667: PUSH
12668: LD_EXP 34
12672: PPUSH
12673: LD_INT 7
12675: PPUSH
12676: CALL_OW 296
12680: PUSH
12681: LD_INT 17
12683: LESS
12684: OR
12685: IFFALSE 12648
// DialogueOn ;
12687: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12691: LD_EXP 34
12695: PPUSH
12696: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12700: LD_EXP 34
12704: PPUSH
12705: LD_STRING D4Yb-Yam-1
12707: PPUSH
12708: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12712: LD_EXP 21
12716: PPUSH
12717: LD_STRING D4Yb-JMM-1
12719: PPUSH
12720: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12724: LD_EXP 34
12728: PPUSH
12729: LD_STRING D4Yb-Yam-2
12731: PPUSH
12732: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12736: LD_EXP 21
12740: PPUSH
12741: LD_STRING D4Yb-JMM-2
12743: PPUSH
12744: CALL_OW 88
// DialogueOff ;
12748: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12752: LD_EXP 34
12756: PPUSH
12757: LD_INT 1
12759: PPUSH
12760: CALL_OW 235
// end ; end ; end ;
12764: PPOPN 2
12766: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12767: LD_EXP 6
12771: IFFALSE 13804
12773: GO 12775
12775: DISABLE
12776: LD_INT 0
12778: PPUSH
12779: PPUSH
12780: PPUSH
12781: PPUSH
// begin enable ;
12782: ENABLE
// if not seen [ 1 ] then
12783: LD_EXP 9
12787: PUSH
12788: LD_INT 1
12790: ARRAY
12791: NOT
12792: IFFALSE 12972
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12794: LD_ADDR_VAR 0 2
12798: PUSH
12799: LD_INT 22
12801: PUSH
12802: LD_INT 2
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: PUSH
12809: LD_INT 2
12811: PUSH
12812: LD_INT 25
12814: PUSH
12815: LD_INT 11
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: PUSH
12822: LD_INT 33
12824: PUSH
12825: LD_INT 4
12827: PUSH
12828: EMPTY
12829: LIST
12830: LIST
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: LIST
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PPUSH
12841: CALL_OW 69
12845: ST_TO_ADDR
// if tmp then
12846: LD_VAR 0 2
12850: IFFALSE 12972
// for i in tmp do
12852: LD_ADDR_VAR 0 1
12856: PUSH
12857: LD_VAR 0 2
12861: PUSH
12862: FOR_IN
12863: IFFALSE 12970
// if See ( 1 , i ) then
12865: LD_INT 1
12867: PPUSH
12868: LD_VAR 0 1
12872: PPUSH
12873: CALL_OW 292
12877: IFFALSE 12968
// begin seen := Replace ( seen , 1 , true ) ;
12879: LD_ADDR_EXP 9
12883: PUSH
12884: LD_EXP 9
12888: PPUSH
12889: LD_INT 1
12891: PPUSH
12892: LD_INT 1
12894: PPUSH
12895: CALL_OW 1
12899: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12900: LD_INT 1
12902: PPUSH
12903: CALL 16509 0 1
12907: IFFALSE 12968
// begin DialogueOn ;
12909: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12913: LD_VAR 0 1
12917: PPUSH
12918: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12922: LD_INT 10
12924: PPUSH
12925: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12929: LD_ADDR_VAR 0 3
12933: PUSH
12934: LD_INT 1
12936: PPUSH
12937: LD_STRING D5a-Sol2-1
12939: PPUSH
12940: CALL 16687 0 2
12944: ST_TO_ADDR
// if not un then
12945: LD_VAR 0 3
12949: NOT
12950: IFFALSE 12962
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12952: LD_INT 2
12954: PPUSH
12955: LD_STRING D5a-FSol2-1
12957: PPUSH
12958: CALL 16687 0 2
// DialogueOff ;
12962: CALL_OW 7
// break ;
12966: GO 12970
// end ; end ;
12968: GO 12862
12970: POP
12971: POP
// end ; if not seen [ 2 ] then
12972: LD_EXP 9
12976: PUSH
12977: LD_INT 2
12979: ARRAY
12980: NOT
12981: IFFALSE 13206
// begin can_kamikazed := true ;
12983: LD_ADDR_EXP 10
12987: PUSH
12988: LD_INT 1
12990: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12991: LD_ADDR_VAR 0 2
12995: PUSH
12996: LD_INT 22
12998: PUSH
12999: LD_INT 2
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: PUSH
13006: LD_INT 25
13008: PUSH
13009: LD_INT 17
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: PUSH
13016: EMPTY
13017: LIST
13018: LIST
13019: PPUSH
13020: CALL_OW 69
13024: ST_TO_ADDR
// if tmp then
13025: LD_VAR 0 2
13029: IFFALSE 13206
// for i in tmp do
13031: LD_ADDR_VAR 0 1
13035: PUSH
13036: LD_VAR 0 2
13040: PUSH
13041: FOR_IN
13042: IFFALSE 13204
// if See ( 1 , i ) then
13044: LD_INT 1
13046: PPUSH
13047: LD_VAR 0 1
13051: PPUSH
13052: CALL_OW 292
13056: IFFALSE 13202
// begin seen := Replace ( seen , 2 , true ) ;
13058: LD_ADDR_EXP 9
13062: PUSH
13063: LD_EXP 9
13067: PPUSH
13068: LD_INT 2
13070: PPUSH
13071: LD_INT 1
13073: PPUSH
13074: CALL_OW 1
13078: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13079: LD_INT 1
13081: PPUSH
13082: CALL 16509 0 1
13086: IFFALSE 13202
// begin DialogueOn ;
13088: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13092: LD_VAR 0 1
13096: PPUSH
13097: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13101: LD_INT 10
13103: PPUSH
13104: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13108: LD_ADDR_VAR 0 3
13112: PUSH
13113: LD_INT 1
13115: PPUSH
13116: LD_STRING D5b-Sol1-1
13118: PPUSH
13119: CALL 16687 0 2
13123: ST_TO_ADDR
// if not un then
13124: LD_VAR 0 3
13128: NOT
13129: IFFALSE 13147
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13131: LD_ADDR_VAR 0 3
13135: PUSH
13136: LD_INT 2
13138: PPUSH
13139: LD_STRING D5b-FSol1-1
13141: PPUSH
13142: CALL 16687 0 2
13146: ST_TO_ADDR
// if un then
13147: LD_VAR 0 3
13151: IFFALSE 13196
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13153: LD_ADDR_VAR 0 4
13157: PUSH
13158: LD_INT 1
13160: PPUSH
13161: LD_STRING D5b-Sol2-1
13163: PPUSH
13164: LD_VAR 0 3
13168: PPUSH
13169: CALL 16913 0 3
13173: ST_TO_ADDR
// if not un2 then
13174: LD_VAR 0 4
13178: NOT
13179: IFFALSE 13196
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13181: LD_INT 2
13183: PPUSH
13184: LD_STRING D5b-FSol2-1
13186: PPUSH
13187: LD_VAR 0 3
13191: PPUSH
13192: CALL 16913 0 3
// end ; DialogueOff ;
13196: CALL_OW 7
// break ;
13200: GO 13204
// end ; end ;
13202: GO 13041
13204: POP
13205: POP
// end ; if not seen [ 3 ] then
13206: LD_EXP 9
13210: PUSH
13211: LD_INT 3
13213: ARRAY
13214: NOT
13215: IFFALSE 13389
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13217: LD_ADDR_VAR 0 2
13221: PUSH
13222: LD_INT 22
13224: PUSH
13225: LD_INT 2
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PUSH
13232: LD_INT 33
13234: PUSH
13235: LD_INT 2
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: PPUSH
13246: CALL_OW 69
13250: ST_TO_ADDR
// if tmp then
13251: LD_VAR 0 2
13255: IFFALSE 13389
// for i in tmp do
13257: LD_ADDR_VAR 0 1
13261: PUSH
13262: LD_VAR 0 2
13266: PUSH
13267: FOR_IN
13268: IFFALSE 13387
// if See ( 1 , i ) then
13270: LD_INT 1
13272: PPUSH
13273: LD_VAR 0 1
13277: PPUSH
13278: CALL_OW 292
13282: IFFALSE 13385
// begin seen := Replace ( seen , 3 , true ) ;
13284: LD_ADDR_EXP 9
13288: PUSH
13289: LD_EXP 9
13293: PPUSH
13294: LD_INT 3
13296: PPUSH
13297: LD_INT 1
13299: PPUSH
13300: CALL_OW 1
13304: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13305: LD_INT 1
13307: PPUSH
13308: CALL 16509 0 1
13312: IFFALSE 13385
// begin DialogueOn ;
13314: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13318: LD_VAR 0 1
13322: PPUSH
13323: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13327: LD_INT 10
13329: PPUSH
13330: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13334: LD_ADDR_VAR 0 3
13338: PUSH
13339: LD_INT 1
13341: PPUSH
13342: LD_STRING D8-Sol1-1
13344: PPUSH
13345: CALL 16687 0 2
13349: ST_TO_ADDR
// if not un then
13350: LD_VAR 0 3
13354: NOT
13355: IFFALSE 13367
// SayRand ( sex_female , D8-FSol1-1 ) ;
13357: LD_INT 2
13359: PPUSH
13360: LD_STRING D8-FSol1-1
13362: PPUSH
13363: CALL 16687 0 2
// Say ( JMM , D8-JMM-1 ) ;
13367: LD_EXP 21
13371: PPUSH
13372: LD_STRING D8-JMM-1
13374: PPUSH
13375: CALL_OW 88
// DialogueOff ;
13379: CALL_OW 7
// break ;
13383: GO 13387
// end ; end ;
13385: GO 13267
13387: POP
13388: POP
// end ; if not seen [ 4 ] then
13389: LD_EXP 9
13393: PUSH
13394: LD_INT 4
13396: ARRAY
13397: NOT
13398: IFFALSE 13560
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13400: LD_ADDR_VAR 0 2
13404: PUSH
13405: LD_INT 22
13407: PUSH
13408: LD_INT 2
13410: PUSH
13411: EMPTY
13412: LIST
13413: LIST
13414: PUSH
13415: LD_INT 33
13417: PUSH
13418: LD_INT 5
13420: PUSH
13421: EMPTY
13422: LIST
13423: LIST
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: PPUSH
13429: CALL_OW 69
13433: ST_TO_ADDR
// if tmp then
13434: LD_VAR 0 2
13438: IFFALSE 13560
// for i in tmp do
13440: LD_ADDR_VAR 0 1
13444: PUSH
13445: LD_VAR 0 2
13449: PUSH
13450: FOR_IN
13451: IFFALSE 13558
// if See ( 1 , i ) then
13453: LD_INT 1
13455: PPUSH
13456: LD_VAR 0 1
13460: PPUSH
13461: CALL_OW 292
13465: IFFALSE 13556
// begin seen := Replace ( seen , 4 , true ) ;
13467: LD_ADDR_EXP 9
13471: PUSH
13472: LD_EXP 9
13476: PPUSH
13477: LD_INT 4
13479: PPUSH
13480: LD_INT 1
13482: PPUSH
13483: CALL_OW 1
13487: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13488: LD_INT 1
13490: PPUSH
13491: CALL 16509 0 1
13495: IFFALSE 13556
// begin DialogueOn ;
13497: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13501: LD_VAR 0 1
13505: PPUSH
13506: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13510: LD_INT 10
13512: PPUSH
13513: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13517: LD_ADDR_VAR 0 3
13521: PUSH
13522: LD_INT 1
13524: PPUSH
13525: LD_STRING D5a-Sol1-1
13527: PPUSH
13528: CALL 16687 0 2
13532: ST_TO_ADDR
// if not un then
13533: LD_VAR 0 3
13537: NOT
13538: IFFALSE 13550
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13540: LD_INT 2
13542: PPUSH
13543: LD_STRING D5a-FSol1-1
13545: PPUSH
13546: CALL 16687 0 2
// DialogueOff ;
13550: CALL_OW 7
// break ;
13554: GO 13558
// end ; end ;
13556: GO 13450
13558: POP
13559: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13560: LD_EXP 9
13564: PUSH
13565: LD_INT 5
13567: ARRAY
13568: NOT
13569: PUSH
13570: LD_EXP 9
13574: PUSH
13575: LD_INT 3
13577: ARRAY
13578: AND
13579: IFFALSE 13753
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13581: LD_ADDR_VAR 0 2
13585: PUSH
13586: LD_INT 22
13588: PUSH
13589: LD_INT 2
13591: PUSH
13592: EMPTY
13593: LIST
13594: LIST
13595: PUSH
13596: LD_INT 34
13598: PUSH
13599: LD_INT 31
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: PUSH
13606: EMPTY
13607: LIST
13608: LIST
13609: PPUSH
13610: CALL_OW 69
13614: ST_TO_ADDR
// if tmp then
13615: LD_VAR 0 2
13619: IFFALSE 13753
// for i in tmp do
13621: LD_ADDR_VAR 0 1
13625: PUSH
13626: LD_VAR 0 2
13630: PUSH
13631: FOR_IN
13632: IFFALSE 13751
// if See ( 1 , i ) then
13634: LD_INT 1
13636: PPUSH
13637: LD_VAR 0 1
13641: PPUSH
13642: CALL_OW 292
13646: IFFALSE 13749
// begin seen := Replace ( seen , 5 , true ) ;
13648: LD_ADDR_EXP 9
13652: PUSH
13653: LD_EXP 9
13657: PPUSH
13658: LD_INT 5
13660: PPUSH
13661: LD_INT 1
13663: PPUSH
13664: CALL_OW 1
13668: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13669: LD_INT 1
13671: PPUSH
13672: CALL 16509 0 1
13676: IFFALSE 13749
// begin DialogueOn ;
13678: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13682: LD_VAR 0 1
13686: PPUSH
13687: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13691: LD_INT 10
13693: PPUSH
13694: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13698: LD_ADDR_VAR 0 3
13702: PUSH
13703: LD_INT 1
13705: PPUSH
13706: LD_STRING D8a-Sol2-1
13708: PPUSH
13709: CALL 16687 0 2
13713: ST_TO_ADDR
// if not un then
13714: LD_VAR 0 3
13718: NOT
13719: IFFALSE 13731
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13721: LD_INT 2
13723: PPUSH
13724: LD_STRING D8a-FSol2-1
13726: PPUSH
13727: CALL 16687 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13731: LD_EXP 21
13735: PPUSH
13736: LD_STRING D8a-JMM-1
13738: PPUSH
13739: CALL_OW 88
// DialogueOff ;
13743: CALL_OW 7
// break ;
13747: GO 13751
// end ; end ;
13749: GO 13631
13751: POP
13752: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13753: LD_EXP 9
13757: PUSH
13758: LD_INT 1
13760: ARRAY
13761: PUSH
13762: LD_EXP 9
13766: PUSH
13767: LD_INT 2
13769: ARRAY
13770: AND
13771: PUSH
13772: LD_EXP 9
13776: PUSH
13777: LD_INT 3
13779: ARRAY
13780: AND
13781: PUSH
13782: LD_EXP 9
13786: PUSH
13787: LD_INT 4
13789: ARRAY
13790: AND
13791: PUSH
13792: LD_EXP 9
13796: PUSH
13797: LD_INT 5
13799: ARRAY
13800: AND
13801: IFFALSE 13804
// disable ;
13803: DISABLE
// end ;
13804: PPOPN 4
13806: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13807: LD_EXP 10
13811: PUSH
13812: LD_EXP 11
13816: AND
13817: IFFALSE 14015
13819: GO 13821
13821: DISABLE
13822: LD_INT 0
13824: PPUSH
// begin DialogueOn ;
13825: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13829: LD_EXP 11
13833: PPUSH
13834: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13838: LD_ADDR_VAR 0 1
13842: PUSH
13843: LD_INT 1
13845: PPUSH
13846: LD_STRING D5c-Sol1-1
13848: PPUSH
13849: CALL 16687 0 2
13853: ST_TO_ADDR
// if not un then
13854: LD_VAR 0 1
13858: NOT
13859: IFFALSE 13877
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13861: LD_ADDR_VAR 0 1
13865: PUSH
13866: LD_INT 2
13868: PPUSH
13869: LD_STRING D5c-FSol1-1
13871: PPUSH
13872: CALL 16687 0 2
13876: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13877: LD_EXP 21
13881: PPUSH
13882: LD_STRING D5c-JMM-1
13884: PPUSH
13885: CALL_OW 88
// if IsOk ( Lisa ) then
13889: LD_EXP 22
13893: PPUSH
13894: CALL_OW 302
13898: IFFALSE 13914
// Say ( Lisa , D5d-Lisa-1 ) else
13900: LD_EXP 22
13904: PPUSH
13905: LD_STRING D5d-Lisa-1
13907: PPUSH
13908: CALL_OW 88
13912: GO 13999
// if IsOk ( Cyrus ) then
13914: LD_EXP 25
13918: PPUSH
13919: CALL_OW 302
13923: IFFALSE 13939
// Say ( Cyrus , D5d-Cyrus-1 ) else
13925: LD_EXP 25
13929: PPUSH
13930: LD_STRING D5d-Cyrus-1
13932: PPUSH
13933: CALL_OW 88
13937: GO 13999
// if IsOk ( Gary ) then
13939: LD_EXP 32
13943: PPUSH
13944: CALL_OW 302
13948: IFFALSE 13964
// Say ( Gary , D5d-Gary-1 ) else
13950: LD_EXP 32
13954: PPUSH
13955: LD_STRING D5d-Gary-1
13957: PPUSH
13958: CALL_OW 88
13962: GO 13999
// if GetSex ( un ) = sex_male then
13964: LD_VAR 0 1
13968: PPUSH
13969: CALL_OW 258
13973: PUSH
13974: LD_INT 1
13976: EQUAL
13977: IFFALSE 13993
// Say ( un , D5d-Sol1-1 ) else
13979: LD_VAR 0 1
13983: PPUSH
13984: LD_STRING D5d-Sol1-1
13986: PPUSH
13987: CALL_OW 88
13991: GO 13999
// begin DialogueOff ;
13993: CALL_OW 7
// exit ;
13997: GO 14015
// end ; Say ( JMM , D5d-JMM-1 ) ;
13999: LD_EXP 21
14003: PPUSH
14004: LD_STRING D5d-JMM-1
14006: PPUSH
14007: CALL_OW 88
// DialogueOff ;
14011: CALL_OW 7
// end ;
14015: PPOPN 1
14017: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14018: LD_INT 1
14020: PPUSH
14021: LD_INT 17
14023: PPUSH
14024: CALL_OW 294
14028: PUSH
14029: LD_INT 2
14031: GREATEREQUAL
14032: IFFALSE 14164
14034: GO 14036
14036: DISABLE
14037: LD_INT 0
14039: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14040: LD_INT 10
14042: PPUSH
14043: LD_INT 5
14045: PPUSH
14046: LD_INT 1
14048: PPUSH
14049: LD_INT 10
14051: NEG
14052: PPUSH
14053: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14057: LD_INT 10
14059: PPUSH
14060: LD_INT 5
14062: PPUSH
14063: LD_INT 1
14065: PPUSH
14066: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14070: LD_INT 10
14072: PPUSH
14073: LD_INT 5
14075: PPUSH
14076: CALL_OW 86
// DialogueOn ;
14080: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14084: LD_ADDR_VAR 0 1
14088: PUSH
14089: LD_INT 1
14091: PPUSH
14092: LD_STRING D6-Sci1-1
14094: PPUSH
14095: CALL 16687 0 2
14099: ST_TO_ADDR
// if un then
14100: LD_VAR 0 1
14104: IFFALSE 14142
// begin Say ( JMM , D6-JMM-1 ) ;
14106: LD_EXP 21
14110: PPUSH
14111: LD_STRING D6-JMM-1
14113: PPUSH
14114: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14118: LD_VAR 0 1
14122: PPUSH
14123: LD_STRING D6-Sci1-2
14125: PPUSH
14126: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14130: LD_EXP 21
14134: PPUSH
14135: LD_STRING D6-JMM-2
14137: PPUSH
14138: CALL_OW 88
// end ; DialogueOff ;
14142: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14146: LD_STRING M3
14148: PPUSH
14149: CALL_OW 337
// wait ( 0 0$30 ) ;
14153: LD_INT 1050
14155: PPUSH
14156: CALL_OW 67
// AmericanReinforcements ;
14160: CALL 2335 0 0
// end ;
14164: PPOPN 1
14166: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14167: LD_OWVAR 1
14171: PUSH
14172: LD_INT 42000
14174: GREATEREQUAL
14175: PUSH
14176: LD_INT 2
14178: PPUSH
14179: LD_INT 169
14181: PPUSH
14182: LD_INT 90
14184: PPUSH
14185: LD_INT 10
14187: PPUSH
14188: CALL 54460 0 4
14192: PUSH
14193: LD_INT 4
14195: ARRAY
14196: PUSH
14197: LD_INT 0
14199: EQUAL
14200: PUSH
14201: LD_INT 45
14203: PPUSH
14204: CALL_OW 301
14208: OR
14209: PUSH
14210: LD_INT 45
14212: PPUSH
14213: CALL_OW 255
14217: PUSH
14218: LD_INT 1
14220: EQUAL
14221: OR
14222: AND
14223: PUSH
14224: LD_INT 94
14226: PPUSH
14227: CALL_OW 301
14231: NOT
14232: AND
14233: IFFALSE 15438
14235: GO 14237
14237: DISABLE
14238: LD_INT 0
14240: PPUSH
14241: PPUSH
14242: PPUSH
14243: PPUSH
14244: PPUSH
// begin uc_side := 5 ;
14245: LD_ADDR_OWVAR 20
14249: PUSH
14250: LD_INT 5
14252: ST_TO_ADDR
// uc_nation := 2 ;
14253: LD_ADDR_OWVAR 21
14257: PUSH
14258: LD_INT 2
14260: ST_TO_ADDR
// InitHc ;
14261: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14265: LD_INT 1
14267: PPUSH
14268: LD_INT 3
14270: PPUSH
14271: LD_INT 8
14273: PPUSH
14274: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14278: LD_ADDR_OWVAR 29
14282: PUSH
14283: LD_INT 12
14285: PUSH
14286: LD_INT 12
14288: PUSH
14289: EMPTY
14290: LIST
14291: LIST
14292: ST_TO_ADDR
// hc_name := Hans Fliege ;
14293: LD_ADDR_OWVAR 26
14297: PUSH
14298: LD_STRING Hans Fliege
14300: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14301: LD_ADDR_OWVAR 33
14305: PUSH
14306: LD_STRING SecondCharsGal
14308: ST_TO_ADDR
// hc_face_number := 7 ;
14309: LD_ADDR_OWVAR 34
14313: PUSH
14314: LD_INT 7
14316: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14317: LD_ADDR_EXP 46
14321: PUSH
14322: CALL_OW 44
14326: ST_TO_ADDR
// InitHc ;
14327: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14331: LD_INT 1
14333: PPUSH
14334: LD_INT 16
14336: PPUSH
14337: LD_INT 2
14339: PPUSH
14340: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14344: LD_ADDR_OWVAR 29
14348: PUSH
14349: LD_INT 12
14351: PUSH
14352: LD_INT 12
14354: PUSH
14355: EMPTY
14356: LIST
14357: LIST
14358: ST_TO_ADDR
// hc_name :=  ;
14359: LD_ADDR_OWVAR 26
14363: PUSH
14364: LD_STRING 
14366: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14367: LD_ADDR_EXP 47
14371: PUSH
14372: CALL_OW 44
14376: ST_TO_ADDR
// InitHc ;
14377: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14381: LD_INT 35
14383: PPUSH
14384: CALL_OW 67
// until not InBattle ( 1 ) ;
14388: LD_INT 1
14390: PPUSH
14391: CALL_OW 463
14395: NOT
14396: IFFALSE 14381
// wait ( 0 0$5 ) ;
14398: LD_INT 175
14400: PPUSH
14401: CALL_OW 67
// DialogueOn ;
14405: CALL_OW 6
// InGameOn ;
14409: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14413: LD_ADDR_VAR 0 1
14417: PUSH
14418: LD_INT 22
14420: PUSH
14421: LD_INT 1
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PUSH
14428: LD_INT 2
14430: PUSH
14431: LD_INT 25
14433: PUSH
14434: LD_INT 1
14436: PUSH
14437: EMPTY
14438: LIST
14439: LIST
14440: PUSH
14441: LD_INT 25
14443: PUSH
14444: LD_INT 2
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: LD_INT 25
14453: PUSH
14454: LD_INT 3
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: LD_INT 25
14463: PUSH
14464: LD_INT 4
14466: PUSH
14467: EMPTY
14468: LIST
14469: LIST
14470: PUSH
14471: LD_INT 25
14473: PUSH
14474: LD_INT 5
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: PUSH
14481: LD_INT 25
14483: PUSH
14484: LD_INT 8
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: EMPTY
14492: LIST
14493: LIST
14494: LIST
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: PUSH
14500: EMPTY
14501: LIST
14502: LIST
14503: PPUSH
14504: CALL_OW 69
14508: PUSH
14509: LD_EXP 21
14513: PUSH
14514: LD_EXP 22
14518: PUSH
14519: LD_EXP 23
14523: PUSH
14524: LD_EXP 24
14528: PUSH
14529: LD_EXP 25
14533: PUSH
14534: LD_EXP 26
14538: PUSH
14539: LD_EXP 27
14543: PUSH
14544: LD_EXP 28
14548: PUSH
14549: LD_EXP 29
14553: PUSH
14554: LD_EXP 31
14558: PUSH
14559: LD_EXP 32
14563: PUSH
14564: LD_EXP 33
14568: PUSH
14569: LD_EXP 34
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: DIFF
14589: PPUSH
14590: LD_INT 26
14592: PUSH
14593: LD_INT 1
14595: PUSH
14596: EMPTY
14597: LIST
14598: LIST
14599: PPUSH
14600: CALL_OW 72
14604: PUSH
14605: LD_INT 1
14607: ARRAY
14608: ST_TO_ADDR
// if Brown then
14609: LD_EXP 27
14613: IFFALSE 14625
// un := Brown ;
14615: LD_ADDR_VAR 0 1
14619: PUSH
14620: LD_EXP 27
14624: ST_TO_ADDR
// if un then
14625: LD_VAR 0 1
14629: IFFALSE 14655
// begin Say ( un , D7-Sol1-1 ) ;
14631: LD_VAR 0 1
14635: PPUSH
14636: LD_STRING D7-Sol1-1
14638: PPUSH
14639: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14643: LD_EXP 21
14647: PPUSH
14648: LD_STRING D7-JMM-1
14650: PPUSH
14651: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14655: LD_EXP 46
14659: PPUSH
14660: LD_STRING D7-Ar1-1
14662: PPUSH
14663: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14667: LD_EXP 21
14671: PPUSH
14672: LD_STRING D7-JMM-2
14674: PPUSH
14675: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14679: LD_EXP 46
14683: PPUSH
14684: LD_STRING D7-Ar1-2
14686: PPUSH
14687: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14691: LD_EXP 21
14695: PPUSH
14696: LD_STRING D7-JMM-3
14698: PPUSH
14699: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14703: LD_EXP 46
14707: PPUSH
14708: LD_STRING D7-Ar1-3
14710: PPUSH
14711: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14715: LD_EXP 21
14719: PPUSH
14720: LD_STRING D7-JMM-4
14722: PPUSH
14723: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14727: LD_EXP 46
14731: PPUSH
14732: LD_STRING D7-Ar1-4
14734: PPUSH
14735: CALL_OW 94
// InGameOff ;
14739: CALL_OW 9
// DialogueOff ;
14743: CALL_OW 7
// case Query ( QCameras ) of 1 :
14747: LD_STRING QCameras
14749: PPUSH
14750: CALL_OW 97
14754: PUSH
14755: LD_INT 1
14757: DOUBLE
14758: EQUAL
14759: IFTRUE 14763
14761: GO 14766
14763: POP
// ; 2 :
14764: GO 14780
14766: LD_INT 2
14768: DOUBLE
14769: EQUAL
14770: IFTRUE 14774
14772: GO 14779
14774: POP
// exit ; end ;
14775: GO 15438
14777: GO 14780
14779: POP
// ChangeMissionObjectives ( MCar ) ;
14780: LD_STRING MCar
14782: PPUSH
14783: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14787: LD_INT 124
14789: PPUSH
14790: LD_INT 90
14792: PPUSH
14793: LD_INT 1
14795: PPUSH
14796: LD_INT 6
14798: NEG
14799: PPUSH
14800: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14804: LD_INT 124
14806: PPUSH
14807: LD_INT 90
14809: PPUSH
14810: LD_INT 1
14812: PPUSH
14813: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14817: LD_INT 12
14819: PPUSH
14820: LD_INT 1
14822: PPUSH
14823: CALL_OW 424
// wait ( 3 ) ;
14827: LD_INT 3
14829: PPUSH
14830: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14834: LD_INT 124
14836: PPUSH
14837: LD_INT 90
14839: PPUSH
14840: CALL_OW 86
// cargo := false ;
14844: LD_ADDR_VAR 0 3
14848: PUSH
14849: LD_INT 0
14851: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14852: LD_INT 35
14854: PPUSH
14855: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14859: LD_ADDR_VAR 0 3
14863: PUSH
14864: LD_INT 12
14866: PPUSH
14867: LD_INT 32
14869: PUSH
14870: LD_INT 3
14872: PUSH
14873: EMPTY
14874: LIST
14875: LIST
14876: PUSH
14877: LD_INT 34
14879: PUSH
14880: LD_INT 32
14882: PUSH
14883: EMPTY
14884: LIST
14885: LIST
14886: PUSH
14887: LD_INT 58
14889: PUSH
14890: EMPTY
14891: LIST
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: LIST
14897: PPUSH
14898: CALL_OW 70
14902: ST_TO_ADDR
// until cargo ;
14903: LD_VAR 0 3
14907: IFFALSE 14852
// cargo := cargo [ 1 ] ;
14909: LD_ADDR_VAR 0 3
14913: PUSH
14914: LD_VAR 0 3
14918: PUSH
14919: LD_INT 1
14921: ARRAY
14922: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14923: LD_VAR 0 3
14927: PPUSH
14928: LD_INT 5
14930: PPUSH
14931: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14935: LD_INT 12
14937: PPUSH
14938: LD_INT 0
14940: PPUSH
14941: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14945: LD_EXP 46
14949: PPUSH
14950: LD_INT 11
14952: PPUSH
14953: LD_INT 0
14955: PPUSH
14956: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14960: LD_EXP 47
14964: PPUSH
14965: LD_INT 11
14967: PPUSH
14968: LD_INT 0
14970: PPUSH
14971: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14975: LD_EXP 46
14979: PUSH
14980: LD_EXP 47
14984: PUSH
14985: EMPTY
14986: LIST
14987: LIST
14988: PPUSH
14989: LD_INT 12
14991: PPUSH
14992: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14996: LD_EXP 46
15000: PPUSH
15001: LD_VAR 0 3
15005: PPUSH
15006: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15010: LD_EXP 46
15014: PUSH
15015: LD_EXP 47
15019: PUSH
15020: EMPTY
15021: LIST
15022: LIST
15023: PPUSH
15024: LD_INT 209
15026: PPUSH
15027: LD_INT 178
15029: PPUSH
15030: CALL_OW 171
// escaped := 0 ;
15034: LD_ADDR_VAR 0 5
15038: PUSH
15039: LD_INT 0
15041: ST_TO_ADDR
// while ( true ) do
15042: LD_INT 1
15044: IFFALSE 15260
// begin wait ( 0 0$1 ) ;
15046: LD_INT 35
15048: PPUSH
15049: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15053: LD_EXP 46
15057: PPUSH
15058: CALL_OW 314
15062: NOT
15063: PUSH
15064: LD_EXP 47
15068: PPUSH
15069: CALL_OW 314
15073: NOT
15074: OR
15075: IFFALSE 15101
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15077: LD_EXP 46
15081: PUSH
15082: LD_EXP 47
15086: PUSH
15087: EMPTY
15088: LIST
15089: LIST
15090: PPUSH
15091: LD_INT 209
15093: PPUSH
15094: LD_INT 178
15096: PPUSH
15097: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15101: LD_EXP 46
15105: PPUSH
15106: LD_INT 10
15108: PPUSH
15109: CALL_OW 308
15113: IFFALSE 15138
// begin RemoveUnit ( ar_mechanic ) ;
15115: LD_EXP 46
15119: PPUSH
15120: CALL_OW 64
// escaped := escaped + 1 ;
15124: LD_ADDR_VAR 0 5
15128: PUSH
15129: LD_VAR 0 5
15133: PUSH
15134: LD_INT 1
15136: PLUS
15137: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15138: LD_EXP 47
15142: PPUSH
15143: LD_INT 10
15145: PPUSH
15146: CALL_OW 308
15150: IFFALSE 15175
// begin RemoveUnit ( ar_mechanic_friend ) ;
15152: LD_EXP 47
15156: PPUSH
15157: CALL_OW 64
// escaped := escaped + 1 ;
15161: LD_ADDR_VAR 0 5
15165: PUSH
15166: LD_VAR 0 5
15170: PUSH
15171: LD_INT 1
15173: PLUS
15174: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15175: LD_VAR 0 3
15179: PPUSH
15180: LD_INT 10
15182: PPUSH
15183: CALL_OW 308
15187: IFFALSE 15198
// RemoveUnit ( cargo ) ;
15189: LD_VAR 0 3
15193: PPUSH
15194: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15198: LD_EXP 46
15202: PPUSH
15203: CALL_OW 305
15207: NOT
15208: PUSH
15209: LD_VAR 0 5
15213: PUSH
15214: LD_INT 2
15216: GREATEREQUAL
15217: AND
15218: IFFALSE 15222
// break ;
15220: GO 15260
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15222: LD_EXP 46
15226: PPUSH
15227: CALL_OW 305
15231: NOT
15232: PUSH
15233: LD_EXP 47
15237: PPUSH
15238: CALL_OW 305
15242: NOT
15243: AND
15244: PUSH
15245: LD_VAR 0 5
15249: PUSH
15250: LD_INT 2
15252: LESS
15253: AND
15254: IFFALSE 15258
// exit ;
15256: GO 15438
// end ;
15258: GO 15042
// wait ( 0 0$2 ) ;
15260: LD_INT 70
15262: PPUSH
15263: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15267: LD_EXP 46
15271: PPUSH
15272: LD_STRING D7a-Ar1-1
15274: PPUSH
15275: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15279: LD_ADDR_VAR 0 4
15283: PUSH
15284: LD_INT 129
15286: PUSH
15287: LD_INT 10
15289: PUSH
15290: EMPTY
15291: LIST
15292: LIST
15293: PUSH
15294: LD_INT 103
15296: PUSH
15297: LD_INT 6
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: PUSH
15304: LD_INT 148
15306: PUSH
15307: LD_INT 47
15309: PUSH
15310: EMPTY
15311: LIST
15312: LIST
15313: PUSH
15314: LD_INT 155
15316: PUSH
15317: LD_INT 16
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: LIST
15328: LIST
15329: ST_TO_ADDR
// if Difficulty = 1 then
15330: LD_OWVAR 67
15334: PUSH
15335: LD_INT 1
15337: EQUAL
15338: IFFALSE 15375
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15340: LD_ADDR_VAR 0 4
15344: PUSH
15345: LD_VAR 0 4
15349: PUSH
15350: LD_INT 78
15352: PUSH
15353: LD_INT 7
15355: PUSH
15356: EMPTY
15357: LIST
15358: LIST
15359: PUSH
15360: LD_INT 104
15362: PUSH
15363: LD_INT 43
15365: PUSH
15366: EMPTY
15367: LIST
15368: LIST
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: ADD
15374: ST_TO_ADDR
// for i in tmp do
15375: LD_ADDR_VAR 0 2
15379: PUSH
15380: LD_VAR 0 4
15384: PUSH
15385: FOR_IN
15386: IFFALSE 15419
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15388: LD_VAR 0 2
15392: PUSH
15393: LD_INT 1
15395: ARRAY
15396: PPUSH
15397: LD_VAR 0 2
15401: PUSH
15402: LD_INT 2
15404: ARRAY
15405: PPUSH
15406: LD_INT 1
15408: PPUSH
15409: LD_INT 9
15411: NEG
15412: PPUSH
15413: CALL_OW 330
15417: GO 15385
15419: POP
15420: POP
// SetAchievement ( ACH_FRIEND ) ;
15421: LD_STRING ACH_FRIEND
15423: PPUSH
15424: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15428: LD_INT 129
15430: PPUSH
15431: LD_INT 10
15433: PPUSH
15434: CALL_OW 84
// end ;
15438: PPOPN 5
15440: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15441: LD_EXP 15
15445: PUSH
15446: LD_INT 21000
15448: MINUS
15449: PUSH
15450: LD_OWVAR 1
15454: LESSEQUAL
15455: IFFALSE 15495
15457: GO 15459
15459: DISABLE
// begin powell_warn := true ;
15460: LD_ADDR_EXP 16
15464: PUSH
15465: LD_INT 1
15467: ST_TO_ADDR
// DialogueOn ;
15468: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15472: LD_EXP 30
15476: PPUSH
15477: LD_STRING D9-Pow-1
15479: PPUSH
15480: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15484: LD_INT 10
15486: PPUSH
15487: CALL_OW 68
// DialogueOff ;
15491: CALL_OW 7
// end ;
15495: END
// every 0 0$1 trigger game_time <= tick do
15496: LD_EXP 15
15500: PUSH
15501: LD_OWVAR 1
15505: LESSEQUAL
15506: IFFALSE 15545
15508: GO 15510
15510: DISABLE
// begin DialogueOn ;
15511: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15515: LD_EXP 30
15519: PPUSH
15520: LD_STRING D9a-Pow-1
15522: PPUSH
15523: CALL_OW 94
// dwait ( 0 0$2 ) ;
15527: LD_INT 70
15529: PPUSH
15530: CALL_OW 68
// DialogueOff ;
15534: CALL_OW 7
// YouLost ( Command ) ;
15538: LD_STRING Command
15540: PPUSH
15541: CALL_OW 104
// end ;
15545: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15546: LD_INT 22
15548: PUSH
15549: LD_INT 2
15551: PUSH
15552: EMPTY
15553: LIST
15554: LIST
15555: PUSH
15556: LD_INT 30
15558: PUSH
15559: LD_INT 1
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: EMPTY
15567: LIST
15568: LIST
15569: PPUSH
15570: CALL_OW 69
15574: PUSH
15575: LD_INT 0
15577: EQUAL
15578: PUSH
15579: LD_EXP 21
15583: PPUSH
15584: CALL_OW 302
15588: AND
15589: IFFALSE 16506
15591: GO 15593
15593: DISABLE
15594: LD_INT 0
15596: PPUSH
15597: PPUSH
15598: PPUSH
15599: PPUSH
// begin m1 := false ;
15600: LD_ADDR_VAR 0 2
15604: PUSH
15605: LD_INT 0
15607: ST_TO_ADDR
// m2 := false ;
15608: LD_ADDR_VAR 0 3
15612: PUSH
15613: LD_INT 0
15615: ST_TO_ADDR
// m3 := false ;
15616: LD_ADDR_VAR 0 4
15620: PUSH
15621: LD_INT 0
15623: ST_TO_ADDR
// if not am_veh_consturcted then
15624: LD_EXP 20
15628: NOT
15629: IFFALSE 15638
// SetAchievement ( ACH_ARABTECH ) ;
15631: LD_STRING ACH_ARABTECH
15633: PPUSH
15634: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15638: LD_OWVAR 1
15642: PUSH
15643: LD_INT 252000
15645: PUSH
15646: LD_INT 210000
15648: PUSH
15649: LD_INT 199500
15651: PUSH
15652: LD_INT 193200
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: LIST
15659: LIST
15660: PUSH
15661: LD_OWVAR 67
15665: ARRAY
15666: LESS
15667: IFFALSE 15689
// begin m3 := true ;
15669: LD_ADDR_VAR 0 4
15673: PUSH
15674: LD_INT 1
15676: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15677: LD_STRING Time1
15679: PPUSH
15680: LD_INT 1
15682: PPUSH
15683: CALL_OW 101
// end else
15687: GO 15720
// if not powell_warn then
15689: LD_EXP 16
15693: NOT
15694: IFFALSE 15709
// AddMedal ( Time1 , - 1 ) else
15696: LD_STRING Time1
15698: PPUSH
15699: LD_INT 1
15701: NEG
15702: PPUSH
15703: CALL_OW 101
15707: GO 15720
// AddMedal ( Time1 , - 2 ) ;
15709: LD_STRING Time1
15711: PPUSH
15712: LD_INT 2
15714: NEG
15715: PPUSH
15716: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15720: LD_EXP 17
15724: PUSH
15725: LD_INT 5
15727: PUSH
15728: LD_INT 4
15730: PUSH
15731: LD_INT 3
15733: PUSH
15734: LD_INT 3
15736: PUSH
15737: EMPTY
15738: LIST
15739: LIST
15740: LIST
15741: LIST
15742: PUSH
15743: LD_OWVAR 67
15747: ARRAY
15748: GREATEREQUAL
15749: IFFALSE 15764
// AddMedal ( Destroy , - 2 ) else
15751: LD_STRING Destroy
15753: PPUSH
15754: LD_INT 2
15756: NEG
15757: PPUSH
15758: CALL_OW 101
15762: GO 15897
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15764: LD_INT 22
15766: PUSH
15767: LD_INT 2
15769: PUSH
15770: EMPTY
15771: LIST
15772: LIST
15773: PUSH
15774: LD_INT 21
15776: PUSH
15777: LD_INT 3
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PUSH
15784: LD_INT 50
15786: PUSH
15787: EMPTY
15788: LIST
15789: PUSH
15790: EMPTY
15791: LIST
15792: LIST
15793: LIST
15794: PPUSH
15795: CALL_OW 69
15799: PUSH
15800: LD_INT 25
15802: GREATEREQUAL
15803: IFFALSE 15818
// AddMedal ( Destroy , - 1 ) else
15805: LD_STRING Destroy
15807: PPUSH
15808: LD_INT 1
15810: NEG
15811: PPUSH
15812: CALL_OW 101
15816: GO 15897
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15818: LD_INT 22
15820: PUSH
15821: LD_INT 2
15823: PUSH
15824: EMPTY
15825: LIST
15826: LIST
15827: PUSH
15828: LD_INT 21
15830: PUSH
15831: LD_INT 3
15833: PUSH
15834: EMPTY
15835: LIST
15836: LIST
15837: PUSH
15838: LD_INT 50
15840: PUSH
15841: EMPTY
15842: LIST
15843: PUSH
15844: EMPTY
15845: LIST
15846: LIST
15847: LIST
15848: PPUSH
15849: CALL_OW 69
15853: PUSH
15854: LD_INT 15
15856: GREATEREQUAL
15857: IFFALSE 15879
// begin m1 := true ;
15859: LD_ADDR_VAR 0 2
15863: PUSH
15864: LD_INT 1
15866: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15867: LD_STRING Destroy
15869: PPUSH
15870: LD_INT 1
15872: PPUSH
15873: CALL_OW 101
// end else
15877: GO 15897
// begin m1 := true ;
15879: LD_ADDR_VAR 0 2
15883: PUSH
15884: LD_INT 1
15886: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15887: LD_STRING Destroy
15889: PPUSH
15890: LD_INT 2
15892: PPUSH
15893: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15897: LD_EXP 13
15901: PPUSH
15902: LD_STRING 11_artifact_captured
15904: PPUSH
15905: CALL_OW 39
// if artifact_get then
15909: LD_EXP 13
15913: IFFALSE 15935
// begin m2 := true ;
15915: LD_ADDR_VAR 0 3
15919: PUSH
15920: LD_INT 1
15922: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15923: LD_STRING Artefact
15925: PPUSH
15926: LD_INT 1
15928: PPUSH
15929: CALL_OW 101
// end else
15933: GO 15946
// AddMedal ( Artefact , - 1 ) ;
15935: LD_STRING Artefact
15937: PPUSH
15938: LD_INT 1
15940: NEG
15941: PPUSH
15942: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
15946: LD_VAR 0 2
15950: PUSH
15951: LD_VAR 0 3
15955: AND
15956: PUSH
15957: LD_VAR 0 4
15961: AND
15962: PUSH
15963: LD_OWVAR 67
15967: PUSH
15968: LD_INT 3
15970: GREATEREQUAL
15971: AND
15972: IFFALSE 15984
// SetAchievementEX ( ACH_AMER , 11 ) ;
15974: LD_STRING ACH_AMER
15976: PPUSH
15977: LD_INT 11
15979: PPUSH
15980: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15984: LD_VAR 0 2
15988: PUSH
15989: LD_VAR 0 3
15993: AND
15994: PUSH
15995: LD_VAR 0 4
15999: AND
16000: PUSH
16001: LD_EXP 17
16005: PUSH
16006: LD_INT 0
16008: EQUAL
16009: AND
16010: IFFALSE 16026
// begin wait ( 3 ) ;
16012: LD_INT 3
16014: PPUSH
16015: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16019: LD_STRING ACH_GENERAL
16021: PPUSH
16022: CALL_OW 543
// end ; if tick <= 100 100$00 then
16026: LD_OWVAR 1
16030: PUSH
16031: LD_INT 210000
16033: LESSEQUAL
16034: IFFALSE 16050
// begin wait ( 3 ) ;
16036: LD_INT 3
16038: PPUSH
16039: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16043: LD_STRING ACH_ASPEED_11
16045: PPUSH
16046: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16050: LD_STRING MAIN
16052: PPUSH
16053: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16057: LD_ADDR_EXP 19
16061: PUSH
16062: LD_EXP 19
16066: PPUSH
16067: LD_INT 51
16069: PUSH
16070: EMPTY
16071: LIST
16072: PPUSH
16073: CALL_OW 72
16077: ST_TO_ADDR
// tmp := JMM ^ selected ;
16078: LD_ADDR_VAR 0 1
16082: PUSH
16083: LD_EXP 21
16087: PUSH
16088: LD_EXP 19
16092: ADD
16093: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16094: LD_VAR 0 1
16098: PPUSH
16099: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16103: LD_VAR 0 1
16107: PUSH
16108: LD_EXP 21
16112: PUSH
16113: LD_EXP 22
16117: PUSH
16118: LD_EXP 23
16122: PUSH
16123: LD_EXP 24
16127: PUSH
16128: LD_EXP 25
16132: PUSH
16133: LD_EXP 26
16137: PUSH
16138: LD_EXP 27
16142: PUSH
16143: LD_EXP 28
16147: PUSH
16148: LD_EXP 29
16152: PUSH
16153: LD_EXP 31
16157: PUSH
16158: LD_EXP 32
16162: PUSH
16163: LD_EXP 33
16167: PUSH
16168: LD_EXP 34
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: LIST
16177: LIST
16178: LIST
16179: LIST
16180: LIST
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: LIST
16186: LIST
16187: DIFF
16188: PPUSH
16189: LD_STRING 11c_others
16191: PPUSH
16192: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16196: LD_EXP 21
16200: PPUSH
16201: LD_EXP 3
16205: PUSH
16206: LD_STRING JMM
16208: STR
16209: PPUSH
16210: CALL_OW 38
// if Lisa then
16214: LD_EXP 22
16218: IFFALSE 16238
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16220: LD_EXP 22
16224: PPUSH
16225: LD_EXP 3
16229: PUSH
16230: LD_STRING Lisa
16232: STR
16233: PPUSH
16234: CALL_OW 38
// if Donaldson then
16238: LD_EXP 23
16242: IFFALSE 16262
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16244: LD_EXP 23
16248: PPUSH
16249: LD_EXP 3
16253: PUSH
16254: LD_STRING Donaldson
16256: STR
16257: PPUSH
16258: CALL_OW 38
// if Bobby then
16262: LD_EXP 24
16266: IFFALSE 16286
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16268: LD_EXP 24
16272: PPUSH
16273: LD_EXP 3
16277: PUSH
16278: LD_STRING Bobby
16280: STR
16281: PPUSH
16282: CALL_OW 38
// if Cyrus then
16286: LD_EXP 25
16290: IFFALSE 16310
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16292: LD_EXP 25
16296: PPUSH
16297: LD_EXP 3
16301: PUSH
16302: LD_STRING Cyrus
16304: STR
16305: PPUSH
16306: CALL_OW 38
// if Denis then
16310: LD_EXP 26
16314: IFFALSE 16334
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16316: LD_EXP 26
16320: PPUSH
16321: LD_EXP 3
16325: PUSH
16326: LD_STRING Denis
16328: STR
16329: PPUSH
16330: CALL_OW 38
// if Brown then
16334: LD_EXP 27
16338: IFFALSE 16358
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16340: LD_EXP 27
16344: PPUSH
16345: LD_EXP 3
16349: PUSH
16350: LD_STRING Brown
16352: STR
16353: PPUSH
16354: CALL_OW 38
// if Gladstone then
16358: LD_EXP 28
16362: IFFALSE 16382
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16364: LD_EXP 28
16368: PPUSH
16369: LD_EXP 3
16373: PUSH
16374: LD_STRING Gladstone
16376: STR
16377: PPUSH
16378: CALL_OW 38
// if Houten then
16382: LD_EXP 29
16386: IFFALSE 16406
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16388: LD_EXP 29
16392: PPUSH
16393: LD_EXP 3
16397: PUSH
16398: LD_STRING Houten
16400: STR
16401: PPUSH
16402: CALL_OW 38
// if Cornel then
16406: LD_EXP 31
16410: IFFALSE 16430
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16412: LD_EXP 31
16416: PPUSH
16417: LD_EXP 3
16421: PUSH
16422: LD_STRING Cornell
16424: STR
16425: PPUSH
16426: CALL_OW 38
// if Gary then
16430: LD_EXP 32
16434: IFFALSE 16454
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16436: LD_EXP 32
16440: PPUSH
16441: LD_EXP 3
16445: PUSH
16446: LD_STRING Gary
16448: STR
16449: PPUSH
16450: CALL_OW 38
// if Frank then
16454: LD_EXP 33
16458: IFFALSE 16478
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16460: LD_EXP 33
16464: PPUSH
16465: LD_EXP 3
16469: PUSH
16470: LD_STRING Frank
16472: STR
16473: PPUSH
16474: CALL_OW 38
// if Kikuchi then
16478: LD_EXP 34
16482: IFFALSE 16502
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16484: LD_EXP 34
16488: PPUSH
16489: LD_EXP 3
16493: PUSH
16494: LD_STRING Kikuchi
16496: STR
16497: PPUSH
16498: CALL_OW 38
// YouWin ;
16502: CALL_OW 103
// end ;
16506: PPOPN 4
16508: END
// export function CanSayRand ( side ) ; begin
16509: LD_INT 0
16511: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16512: LD_ADDR_VAR 0 2
16516: PUSH
16517: LD_INT 52
16519: PUSH
16520: EMPTY
16521: LIST
16522: PUSH
16523: LD_INT 22
16525: PUSH
16526: LD_VAR 0 1
16530: PUSH
16531: EMPTY
16532: LIST
16533: LIST
16534: PUSH
16535: LD_INT 2
16537: PUSH
16538: LD_INT 25
16540: PUSH
16541: LD_INT 1
16543: PUSH
16544: EMPTY
16545: LIST
16546: LIST
16547: PUSH
16548: LD_INT 25
16550: PUSH
16551: LD_INT 2
16553: PUSH
16554: EMPTY
16555: LIST
16556: LIST
16557: PUSH
16558: LD_INT 25
16560: PUSH
16561: LD_INT 3
16563: PUSH
16564: EMPTY
16565: LIST
16566: LIST
16567: PUSH
16568: LD_INT 25
16570: PUSH
16571: LD_INT 4
16573: PUSH
16574: EMPTY
16575: LIST
16576: LIST
16577: PUSH
16578: EMPTY
16579: LIST
16580: LIST
16581: LIST
16582: LIST
16583: LIST
16584: PUSH
16585: EMPTY
16586: LIST
16587: LIST
16588: LIST
16589: PPUSH
16590: CALL_OW 69
16594: PUSH
16595: LD_EXP 21
16599: PUSH
16600: LD_EXP 33
16604: PUSH
16605: LD_EXP 22
16609: PUSH
16610: LD_EXP 23
16614: PUSH
16615: LD_EXP 24
16619: PUSH
16620: LD_EXP 25
16624: PUSH
16625: LD_EXP 26
16629: PUSH
16630: LD_EXP 27
16634: PUSH
16635: LD_EXP 28
16639: PUSH
16640: LD_EXP 29
16644: PUSH
16645: LD_EXP 30
16649: PUSH
16650: LD_EXP 31
16654: PUSH
16655: LD_EXP 32
16659: PUSH
16660: LD_EXP 34
16664: PUSH
16665: EMPTY
16666: LIST
16667: LIST
16668: LIST
16669: LIST
16670: LIST
16671: LIST
16672: LIST
16673: LIST
16674: LIST
16675: LIST
16676: LIST
16677: LIST
16678: LIST
16679: LIST
16680: DIFF
16681: ST_TO_ADDR
// end ;
16682: LD_VAR 0 2
16686: RET
// export function SayRand ( sex , dial ) ; begin
16687: LD_INT 0
16689: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16690: LD_ADDR_VAR 0 3
16694: PUSH
16695: LD_INT 52
16697: PUSH
16698: EMPTY
16699: LIST
16700: PUSH
16701: LD_INT 22
16703: PUSH
16704: LD_INT 1
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: PUSH
16711: LD_INT 26
16713: PUSH
16714: LD_VAR 0 1
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: PUSH
16723: LD_INT 2
16725: PUSH
16726: LD_INT 25
16728: PUSH
16729: LD_INT 1
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: LD_INT 25
16738: PUSH
16739: LD_INT 2
16741: PUSH
16742: EMPTY
16743: LIST
16744: LIST
16745: PUSH
16746: LD_INT 25
16748: PUSH
16749: LD_INT 3
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: PUSH
16756: LD_INT 25
16758: PUSH
16759: LD_INT 4
16761: PUSH
16762: EMPTY
16763: LIST
16764: LIST
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: LIST
16770: LIST
16771: LIST
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: LIST
16777: LIST
16778: PPUSH
16779: CALL_OW 69
16783: PUSH
16784: LD_EXP 21
16788: PUSH
16789: LD_EXP 33
16793: PUSH
16794: LD_EXP 22
16798: PUSH
16799: LD_EXP 23
16803: PUSH
16804: LD_EXP 24
16808: PUSH
16809: LD_EXP 25
16813: PUSH
16814: LD_EXP 26
16818: PUSH
16819: LD_EXP 27
16823: PUSH
16824: LD_EXP 28
16828: PUSH
16829: LD_EXP 29
16833: PUSH
16834: LD_EXP 30
16838: PUSH
16839: LD_EXP 31
16843: PUSH
16844: LD_EXP 32
16848: PUSH
16849: LD_EXP 34
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: LIST
16858: LIST
16859: LIST
16860: LIST
16861: LIST
16862: LIST
16863: LIST
16864: LIST
16865: LIST
16866: LIST
16867: LIST
16868: LIST
16869: DIFF
16870: ST_TO_ADDR
// if not result then
16871: LD_VAR 0 3
16875: NOT
16876: IFFALSE 16880
// exit ;
16878: GO 16908
// result := result [ 1 ] ;
16880: LD_ADDR_VAR 0 3
16884: PUSH
16885: LD_VAR 0 3
16889: PUSH
16890: LD_INT 1
16892: ARRAY
16893: ST_TO_ADDR
// Say ( result , dial ) ;
16894: LD_VAR 0 3
16898: PPUSH
16899: LD_VAR 0 2
16903: PPUSH
16904: CALL_OW 88
// end ;
16908: LD_VAR 0 3
16912: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16913: LD_INT 0
16915: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16916: LD_ADDR_VAR 0 4
16920: PUSH
16921: LD_INT 22
16923: PUSH
16924: LD_INT 1
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: PUSH
16931: LD_INT 26
16933: PUSH
16934: LD_VAR 0 1
16938: PUSH
16939: EMPTY
16940: LIST
16941: LIST
16942: PUSH
16943: LD_INT 2
16945: PUSH
16946: LD_INT 25
16948: PUSH
16949: LD_INT 1
16951: PUSH
16952: EMPTY
16953: LIST
16954: LIST
16955: PUSH
16956: LD_INT 25
16958: PUSH
16959: LD_INT 2
16961: PUSH
16962: EMPTY
16963: LIST
16964: LIST
16965: PUSH
16966: LD_INT 25
16968: PUSH
16969: LD_INT 3
16971: PUSH
16972: EMPTY
16973: LIST
16974: LIST
16975: PUSH
16976: LD_INT 25
16978: PUSH
16979: LD_INT 4
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: LIST
16997: PPUSH
16998: CALL_OW 69
17002: PUSH
17003: LD_EXP 21
17007: PUSH
17008: LD_EXP 33
17012: PUSH
17013: LD_EXP 22
17017: PUSH
17018: LD_EXP 23
17022: PUSH
17023: LD_EXP 24
17027: PUSH
17028: LD_EXP 25
17032: PUSH
17033: LD_EXP 26
17037: PUSH
17038: LD_EXP 27
17042: PUSH
17043: LD_EXP 28
17047: PUSH
17048: LD_EXP 29
17052: PUSH
17053: LD_EXP 30
17057: PUSH
17058: LD_EXP 31
17062: PUSH
17063: LD_EXP 32
17067: PUSH
17068: LD_EXP 34
17072: PUSH
17073: EMPTY
17074: LIST
17075: LIST
17076: LIST
17077: LIST
17078: LIST
17079: LIST
17080: LIST
17081: LIST
17082: LIST
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: LIST
17088: PUSH
17089: LD_VAR 0 3
17093: ADD
17094: DIFF
17095: ST_TO_ADDR
// if not result then
17096: LD_VAR 0 4
17100: NOT
17101: IFFALSE 17105
// exit ;
17103: GO 17133
// result := result [ 1 ] ;
17105: LD_ADDR_VAR 0 4
17109: PUSH
17110: LD_VAR 0 4
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: ST_TO_ADDR
// Say ( result , dial ) ;
17119: LD_VAR 0 4
17123: PPUSH
17124: LD_VAR 0 2
17128: PPUSH
17129: CALL_OW 88
// end ; end_of_file
17133: LD_VAR 0 4
17137: RET
// export function CustomEvent ( event ) ; begin
17138: LD_INT 0
17140: PPUSH
// end ;
17141: LD_VAR 0 2
17145: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17146: LD_VAR 0 1
17150: PPUSH
17151: CALL_OW 255
17155: PUSH
17156: LD_INT 1
17158: EQUAL
17159: IFFALSE 17169
// artifact_get := true ;
17161: LD_ADDR_EXP 13
17165: PUSH
17166: LD_INT 1
17168: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17169: LD_VAR 0 1
17173: PPUSH
17174: CALL_OW 255
17178: PUSH
17179: LD_INT 2
17181: EQUAL
17182: IFFALSE 17200
// begin artifact_get := false ;
17184: LD_ADDR_EXP 13
17188: PUSH
17189: LD_INT 0
17191: ST_TO_ADDR
// artifact_stolen := true ;
17192: LD_ADDR_EXP 12
17196: PUSH
17197: LD_INT 1
17199: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17200: LD_ADDR_EXP 14
17204: PUSH
17205: LD_INT 1
17207: ST_TO_ADDR
// end ;
17208: PPOPN 2
17210: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17211: LD_ADDR_EXP 14
17215: PUSH
17216: LD_INT 0
17218: ST_TO_ADDR
// end ;
17219: PPOPN 2
17221: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17222: LD_VAR 0 1
17226: PPUSH
17227: CALL 103115 0 1
// if un = JMM then
17231: LD_VAR 0 1
17235: PUSH
17236: LD_EXP 21
17240: EQUAL
17241: IFFALSE 17252
// begin YouLost ( JMM ) ;
17243: LD_STRING JMM
17245: PPUSH
17246: CALL_OW 104
// exit ;
17250: GO 17384
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17252: LD_VAR 0 1
17256: PUSH
17257: LD_INT 22
17259: PUSH
17260: LD_INT 1
17262: PUSH
17263: EMPTY
17264: LIST
17265: LIST
17266: PUSH
17267: LD_INT 21
17269: PUSH
17270: LD_INT 1
17272: PUSH
17273: EMPTY
17274: LIST
17275: LIST
17276: PUSH
17277: LD_INT 2
17279: PUSH
17280: LD_INT 25
17282: PUSH
17283: LD_INT 1
17285: PUSH
17286: EMPTY
17287: LIST
17288: LIST
17289: PUSH
17290: LD_INT 25
17292: PUSH
17293: LD_INT 2
17295: PUSH
17296: EMPTY
17297: LIST
17298: LIST
17299: PUSH
17300: LD_INT 25
17302: PUSH
17303: LD_INT 3
17305: PUSH
17306: EMPTY
17307: LIST
17308: LIST
17309: PUSH
17310: LD_INT 25
17312: PUSH
17313: LD_INT 4
17315: PUSH
17316: EMPTY
17317: LIST
17318: LIST
17319: PUSH
17320: LD_INT 25
17322: PUSH
17323: LD_INT 5
17325: PUSH
17326: EMPTY
17327: LIST
17328: LIST
17329: PUSH
17330: LD_INT 25
17332: PUSH
17333: LD_INT 8
17335: PUSH
17336: EMPTY
17337: LIST
17338: LIST
17339: PUSH
17340: EMPTY
17341: LIST
17342: LIST
17343: LIST
17344: LIST
17345: LIST
17346: LIST
17347: LIST
17348: PUSH
17349: EMPTY
17350: LIST
17351: LIST
17352: LIST
17353: PPUSH
17354: CALL_OW 69
17358: IN
17359: IFFALSE 17375
// loses_counter := loses_counter + 1 ;
17361: LD_ADDR_EXP 17
17365: PUSH
17366: LD_EXP 17
17370: PUSH
17371: LD_INT 1
17373: PLUS
17374: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17375: LD_VAR 0 1
17379: PPUSH
17380: CALL 45592 0 1
// end ;
17384: PPOPN 1
17386: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17387: LD_VAR 0 1
17391: PPUSH
17392: LD_VAR 0 2
17396: PPUSH
17397: CALL 47926 0 2
// end ;
17401: PPOPN 2
17403: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17404: LD_VAR 0 1
17408: PPUSH
17409: CALL 47235 0 1
// end ;
17413: PPOPN 1
17415: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17416: LD_VAR 0 1
17420: PPUSH
17421: LD_VAR 0 2
17425: PPUSH
17426: LD_VAR 0 3
17430: PPUSH
17431: LD_VAR 0 4
17435: PPUSH
17436: LD_VAR 0 5
17440: PPUSH
17441: CALL 44908 0 5
// end ;
17445: PPOPN 5
17447: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17448: LD_VAR 0 1
17452: PPUSH
17453: LD_VAR 0 2
17457: PPUSH
17458: CALL 103237 0 2
// if GetNation ( vehicle ) = nation_american then
17462: LD_VAR 0 1
17466: PPUSH
17467: CALL_OW 248
17471: PUSH
17472: LD_INT 1
17474: EQUAL
17475: IFFALSE 17485
// am_veh_consturcted := true ;
17477: LD_ADDR_EXP 20
17481: PUSH
17482: LD_INT 1
17484: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17485: LD_VAR 0 1
17489: PPUSH
17490: LD_VAR 0 2
17494: PPUSH
17495: CALL 44489 0 2
// end ;
17499: PPOPN 2
17501: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17502: LD_VAR 0 1
17506: PPUSH
17507: CALL_OW 247
17511: PUSH
17512: LD_INT 2
17514: EQUAL
17515: IFFALSE 17519
// exit ;
17517: GO 17536
// if not kamikazed then
17519: LD_EXP 11
17523: NOT
17524: IFFALSE 17536
// kamikazed := unit ;
17526: LD_ADDR_EXP 11
17530: PUSH
17531: LD_VAR 0 1
17535: ST_TO_ADDR
// end ;
17536: PPOPN 1
17538: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17539: LD_INT 0
17541: PPUSH
17542: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17543: LD_VAR 0 1
17547: PPUSH
17548: LD_VAR 0 2
17552: PPUSH
17553: LD_VAR 0 3
17557: PPUSH
17558: LD_VAR 0 4
17562: PPUSH
17563: CALL 44327 0 4
// end ;
17567: PPOPN 6
17569: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17570: LD_VAR 0 1
17574: PPUSH
17575: LD_VAR 0 2
17579: PPUSH
17580: LD_VAR 0 3
17584: PPUSH
17585: CALL 44102 0 3
// end ;
17589: PPOPN 3
17591: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17592: LD_VAR 0 1
17596: PPUSH
17597: LD_VAR 0 2
17601: PPUSH
17602: CALL 45288 0 2
// end ;
17606: PPOPN 2
17608: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17609: LD_VAR 0 1
17613: PPUSH
17614: LD_VAR 0 2
17618: PPUSH
17619: CALL 43796 0 2
// end ;
17623: PPOPN 2
17625: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17626: LD_VAR 0 1
17630: PPUSH
17631: LD_VAR 0 2
17635: PPUSH
17636: CALL 43987 0 2
// end ;
17640: PPOPN 2
17642: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17643: LD_VAR 0 1
17647: PPUSH
17648: CALL 46994 0 1
// end ;
17652: PPOPN 1
17654: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17655: LD_VAR 0 1
17659: PPUSH
17660: LD_VAR 0 2
17664: PPUSH
17665: CALL 48221 0 2
// end ;
17669: PPOPN 2
17671: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17672: LD_VAR 0 1
17676: PPUSH
17677: LD_VAR 0 2
17681: PPUSH
17682: LD_VAR 0 3
17686: PPUSH
17687: LD_VAR 0 4
17691: PPUSH
17692: CALL 48437 0 4
// end ;
17696: PPOPN 4
17698: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17699: LD_VAR 0 1
17703: PPUSH
17704: CALL 103221 0 1
// end ; end_of_file
17708: PPOPN 1
17710: END
// every 0 0$1 trigger game do
17711: LD_EXP 2
17715: IFFALSE 17745
17717: GO 17719
17719: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17720: LD_INT 7
17722: PUSH
17723: LD_INT 6
17725: PUSH
17726: LD_INT 4
17728: PUSH
17729: LD_INT 6
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: LIST
17736: LIST
17737: PPUSH
17738: LD_INT 1750
17740: PPUSH
17741: CALL 17746 0 2
17745: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17746: LD_INT 0
17748: PPUSH
17749: PPUSH
17750: PPUSH
// if not areas then
17751: LD_VAR 0 1
17755: NOT
17756: IFFALSE 17760
// exit ;
17758: GO 17890
// repeat wait ( time ) ;
17760: LD_VAR 0 2
17764: PPUSH
17765: CALL_OW 67
// for i in areas do
17769: LD_ADDR_VAR 0 4
17773: PUSH
17774: LD_VAR 0 1
17778: PUSH
17779: FOR_IN
17780: IFFALSE 17849
// begin p := rand ( 1 , 90 ) ;
17782: LD_ADDR_VAR 0 5
17786: PUSH
17787: LD_INT 1
17789: PPUSH
17790: LD_INT 90
17792: PPUSH
17793: CALL_OW 12
17797: ST_TO_ADDR
// if Prob ( p ) then
17798: LD_VAR 0 5
17802: PPUSH
17803: CALL_OW 13
17807: IFFALSE 17847
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17809: LD_INT 2
17811: PPUSH
17812: LD_INT 5
17814: PPUSH
17815: CALL_OW 12
17819: PPUSH
17820: LD_VAR 0 4
17824: PPUSH
17825: LD_INT 1
17827: PPUSH
17828: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17832: LD_INT 735
17834: PPUSH
17835: LD_INT 1295
17837: PPUSH
17838: CALL_OW 12
17842: PPUSH
17843: CALL_OW 67
// end ; end ;
17847: GO 17779
17849: POP
17850: POP
// time := time + 0 0$3 ;
17851: LD_ADDR_VAR 0 2
17855: PUSH
17856: LD_VAR 0 2
17860: PUSH
17861: LD_INT 105
17863: PLUS
17864: ST_TO_ADDR
// if time > 6 6$00 then
17865: LD_VAR 0 2
17869: PUSH
17870: LD_INT 12600
17872: GREATER
17873: IFFALSE 17883
// time := 0 0$40 ;
17875: LD_ADDR_VAR 0 2
17879: PUSH
17880: LD_INT 1400
17882: ST_TO_ADDR
// until not game ;
17883: LD_EXP 2
17887: NOT
17888: IFFALSE 17760
// end ;
17890: LD_VAR 0 3
17894: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
17895: LD_OWVAR 1
17899: PUSH
17900: LD_INT 84000
17902: PUSH
17903: LD_INT 73500
17905: PUSH
17906: LD_INT 63000
17908: PUSH
17909: LD_INT 52500
17911: PUSH
17912: EMPTY
17913: LIST
17914: LIST
17915: LIST
17916: LIST
17917: PUSH
17918: LD_OWVAR 67
17922: ARRAY
17923: LESS
17924: IFFALSE 17951
17926: GO 17928
17928: DISABLE
// begin enable ;
17929: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17930: LD_INT 1
17932: PPUSH
17933: LD_INT 5
17935: PPUSH
17936: CALL_OW 12
17940: PPUSH
17941: LD_INT 7
17943: PPUSH
17944: LD_INT 1
17946: PPUSH
17947: CALL_OW 55
// end ; end_of_file
17951: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17952: LD_INT 0
17954: PPUSH
17955: PPUSH
// skirmish := false ;
17956: LD_ADDR_EXP 48
17960: PUSH
17961: LD_INT 0
17963: ST_TO_ADDR
// debug_mc := false ;
17964: LD_ADDR_EXP 49
17968: PUSH
17969: LD_INT 0
17971: ST_TO_ADDR
// mc_bases := [ ] ;
17972: LD_ADDR_EXP 50
17976: PUSH
17977: EMPTY
17978: ST_TO_ADDR
// mc_sides := [ ] ;
17979: LD_ADDR_EXP 76
17983: PUSH
17984: EMPTY
17985: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17986: LD_ADDR_EXP 51
17990: PUSH
17991: EMPTY
17992: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17993: LD_ADDR_EXP 52
17997: PUSH
17998: EMPTY
17999: ST_TO_ADDR
// mc_need_heal := [ ] ;
18000: LD_ADDR_EXP 53
18004: PUSH
18005: EMPTY
18006: ST_TO_ADDR
// mc_healers := [ ] ;
18007: LD_ADDR_EXP 54
18011: PUSH
18012: EMPTY
18013: ST_TO_ADDR
// mc_build_list := [ ] ;
18014: LD_ADDR_EXP 55
18018: PUSH
18019: EMPTY
18020: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18021: LD_ADDR_EXP 82
18025: PUSH
18026: EMPTY
18027: ST_TO_ADDR
// mc_builders := [ ] ;
18028: LD_ADDR_EXP 56
18032: PUSH
18033: EMPTY
18034: ST_TO_ADDR
// mc_construct_list := [ ] ;
18035: LD_ADDR_EXP 57
18039: PUSH
18040: EMPTY
18041: ST_TO_ADDR
// mc_turret_list := [ ] ;
18042: LD_ADDR_EXP 58
18046: PUSH
18047: EMPTY
18048: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18049: LD_ADDR_EXP 59
18053: PUSH
18054: EMPTY
18055: ST_TO_ADDR
// mc_miners := [ ] ;
18056: LD_ADDR_EXP 64
18060: PUSH
18061: EMPTY
18062: ST_TO_ADDR
// mc_mines := [ ] ;
18063: LD_ADDR_EXP 63
18067: PUSH
18068: EMPTY
18069: ST_TO_ADDR
// mc_minefields := [ ] ;
18070: LD_ADDR_EXP 65
18074: PUSH
18075: EMPTY
18076: ST_TO_ADDR
// mc_crates := [ ] ;
18077: LD_ADDR_EXP 66
18081: PUSH
18082: EMPTY
18083: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18084: LD_ADDR_EXP 67
18088: PUSH
18089: EMPTY
18090: ST_TO_ADDR
// mc_crates_area := [ ] ;
18091: LD_ADDR_EXP 68
18095: PUSH
18096: EMPTY
18097: ST_TO_ADDR
// mc_vehicles := [ ] ;
18098: LD_ADDR_EXP 69
18102: PUSH
18103: EMPTY
18104: ST_TO_ADDR
// mc_attack := [ ] ;
18105: LD_ADDR_EXP 70
18109: PUSH
18110: EMPTY
18111: ST_TO_ADDR
// mc_produce := [ ] ;
18112: LD_ADDR_EXP 71
18116: PUSH
18117: EMPTY
18118: ST_TO_ADDR
// mc_defender := [ ] ;
18119: LD_ADDR_EXP 72
18123: PUSH
18124: EMPTY
18125: ST_TO_ADDR
// mc_parking := [ ] ;
18126: LD_ADDR_EXP 74
18130: PUSH
18131: EMPTY
18132: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18133: LD_ADDR_EXP 60
18137: PUSH
18138: EMPTY
18139: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18140: LD_ADDR_EXP 62
18144: PUSH
18145: EMPTY
18146: ST_TO_ADDR
// mc_scan := [ ] ;
18147: LD_ADDR_EXP 73
18151: PUSH
18152: EMPTY
18153: ST_TO_ADDR
// mc_scan_area := [ ] ;
18154: LD_ADDR_EXP 75
18158: PUSH
18159: EMPTY
18160: ST_TO_ADDR
// mc_tech := [ ] ;
18161: LD_ADDR_EXP 77
18165: PUSH
18166: EMPTY
18167: ST_TO_ADDR
// mc_class := [ ] ;
18168: LD_ADDR_EXP 91
18172: PUSH
18173: EMPTY
18174: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18175: LD_ADDR_EXP 92
18179: PUSH
18180: EMPTY
18181: ST_TO_ADDR
// mc_is_defending := [ ] ;
18182: LD_ADDR_EXP 93
18186: PUSH
18187: EMPTY
18188: ST_TO_ADDR
// end ;
18189: LD_VAR 0 1
18193: RET
// export function MC_Kill ( base ) ; begin
18194: LD_INT 0
18196: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18197: LD_ADDR_EXP 50
18201: PUSH
18202: LD_EXP 50
18206: PPUSH
18207: LD_VAR 0 1
18211: PPUSH
18212: EMPTY
18213: PPUSH
18214: CALL_OW 1
18218: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18219: LD_ADDR_EXP 51
18223: PUSH
18224: LD_EXP 51
18228: PPUSH
18229: LD_VAR 0 1
18233: PPUSH
18234: EMPTY
18235: PPUSH
18236: CALL_OW 1
18240: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18241: LD_ADDR_EXP 52
18245: PUSH
18246: LD_EXP 52
18250: PPUSH
18251: LD_VAR 0 1
18255: PPUSH
18256: EMPTY
18257: PPUSH
18258: CALL_OW 1
18262: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18263: LD_ADDR_EXP 53
18267: PUSH
18268: LD_EXP 53
18272: PPUSH
18273: LD_VAR 0 1
18277: PPUSH
18278: EMPTY
18279: PPUSH
18280: CALL_OW 1
18284: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18285: LD_ADDR_EXP 54
18289: PUSH
18290: LD_EXP 54
18294: PPUSH
18295: LD_VAR 0 1
18299: PPUSH
18300: EMPTY
18301: PPUSH
18302: CALL_OW 1
18306: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18307: LD_ADDR_EXP 55
18311: PUSH
18312: LD_EXP 55
18316: PPUSH
18317: LD_VAR 0 1
18321: PPUSH
18322: EMPTY
18323: PPUSH
18324: CALL_OW 1
18328: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18329: LD_ADDR_EXP 56
18333: PUSH
18334: LD_EXP 56
18338: PPUSH
18339: LD_VAR 0 1
18343: PPUSH
18344: EMPTY
18345: PPUSH
18346: CALL_OW 1
18350: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18351: LD_ADDR_EXP 57
18355: PUSH
18356: LD_EXP 57
18360: PPUSH
18361: LD_VAR 0 1
18365: PPUSH
18366: EMPTY
18367: PPUSH
18368: CALL_OW 1
18372: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18373: LD_ADDR_EXP 58
18377: PUSH
18378: LD_EXP 58
18382: PPUSH
18383: LD_VAR 0 1
18387: PPUSH
18388: EMPTY
18389: PPUSH
18390: CALL_OW 1
18394: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18395: LD_ADDR_EXP 59
18399: PUSH
18400: LD_EXP 59
18404: PPUSH
18405: LD_VAR 0 1
18409: PPUSH
18410: EMPTY
18411: PPUSH
18412: CALL_OW 1
18416: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18417: LD_ADDR_EXP 60
18421: PUSH
18422: LD_EXP 60
18426: PPUSH
18427: LD_VAR 0 1
18431: PPUSH
18432: EMPTY
18433: PPUSH
18434: CALL_OW 1
18438: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18439: LD_ADDR_EXP 61
18443: PUSH
18444: LD_EXP 61
18448: PPUSH
18449: LD_VAR 0 1
18453: PPUSH
18454: LD_INT 0
18456: PPUSH
18457: CALL_OW 1
18461: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18462: LD_ADDR_EXP 62
18466: PUSH
18467: LD_EXP 62
18471: PPUSH
18472: LD_VAR 0 1
18476: PPUSH
18477: EMPTY
18478: PPUSH
18479: CALL_OW 1
18483: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18484: LD_ADDR_EXP 63
18488: PUSH
18489: LD_EXP 63
18493: PPUSH
18494: LD_VAR 0 1
18498: PPUSH
18499: EMPTY
18500: PPUSH
18501: CALL_OW 1
18505: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18506: LD_ADDR_EXP 64
18510: PUSH
18511: LD_EXP 64
18515: PPUSH
18516: LD_VAR 0 1
18520: PPUSH
18521: EMPTY
18522: PPUSH
18523: CALL_OW 1
18527: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18528: LD_ADDR_EXP 65
18532: PUSH
18533: LD_EXP 65
18537: PPUSH
18538: LD_VAR 0 1
18542: PPUSH
18543: EMPTY
18544: PPUSH
18545: CALL_OW 1
18549: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18550: LD_ADDR_EXP 66
18554: PUSH
18555: LD_EXP 66
18559: PPUSH
18560: LD_VAR 0 1
18564: PPUSH
18565: EMPTY
18566: PPUSH
18567: CALL_OW 1
18571: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18572: LD_ADDR_EXP 67
18576: PUSH
18577: LD_EXP 67
18581: PPUSH
18582: LD_VAR 0 1
18586: PPUSH
18587: EMPTY
18588: PPUSH
18589: CALL_OW 1
18593: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18594: LD_ADDR_EXP 68
18598: PUSH
18599: LD_EXP 68
18603: PPUSH
18604: LD_VAR 0 1
18608: PPUSH
18609: EMPTY
18610: PPUSH
18611: CALL_OW 1
18615: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18616: LD_ADDR_EXP 69
18620: PUSH
18621: LD_EXP 69
18625: PPUSH
18626: LD_VAR 0 1
18630: PPUSH
18631: EMPTY
18632: PPUSH
18633: CALL_OW 1
18637: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18638: LD_ADDR_EXP 70
18642: PUSH
18643: LD_EXP 70
18647: PPUSH
18648: LD_VAR 0 1
18652: PPUSH
18653: EMPTY
18654: PPUSH
18655: CALL_OW 1
18659: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18660: LD_ADDR_EXP 71
18664: PUSH
18665: LD_EXP 71
18669: PPUSH
18670: LD_VAR 0 1
18674: PPUSH
18675: EMPTY
18676: PPUSH
18677: CALL_OW 1
18681: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18682: LD_ADDR_EXP 72
18686: PUSH
18687: LD_EXP 72
18691: PPUSH
18692: LD_VAR 0 1
18696: PPUSH
18697: EMPTY
18698: PPUSH
18699: CALL_OW 1
18703: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18704: LD_ADDR_EXP 73
18708: PUSH
18709: LD_EXP 73
18713: PPUSH
18714: LD_VAR 0 1
18718: PPUSH
18719: EMPTY
18720: PPUSH
18721: CALL_OW 1
18725: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18726: LD_ADDR_EXP 74
18730: PUSH
18731: LD_EXP 74
18735: PPUSH
18736: LD_VAR 0 1
18740: PPUSH
18741: EMPTY
18742: PPUSH
18743: CALL_OW 1
18747: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18748: LD_ADDR_EXP 75
18752: PUSH
18753: LD_EXP 75
18757: PPUSH
18758: LD_VAR 0 1
18762: PPUSH
18763: EMPTY
18764: PPUSH
18765: CALL_OW 1
18769: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18770: LD_ADDR_EXP 77
18774: PUSH
18775: LD_EXP 77
18779: PPUSH
18780: LD_VAR 0 1
18784: PPUSH
18785: EMPTY
18786: PPUSH
18787: CALL_OW 1
18791: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18792: LD_ADDR_EXP 79
18796: PUSH
18797: LD_EXP 79
18801: PPUSH
18802: LD_VAR 0 1
18806: PPUSH
18807: EMPTY
18808: PPUSH
18809: CALL_OW 1
18813: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18814: LD_ADDR_EXP 80
18818: PUSH
18819: LD_EXP 80
18823: PPUSH
18824: LD_VAR 0 1
18828: PPUSH
18829: EMPTY
18830: PPUSH
18831: CALL_OW 1
18835: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18836: LD_ADDR_EXP 81
18840: PUSH
18841: LD_EXP 81
18845: PPUSH
18846: LD_VAR 0 1
18850: PPUSH
18851: EMPTY
18852: PPUSH
18853: CALL_OW 1
18857: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18858: LD_ADDR_EXP 82
18862: PUSH
18863: LD_EXP 82
18867: PPUSH
18868: LD_VAR 0 1
18872: PPUSH
18873: EMPTY
18874: PPUSH
18875: CALL_OW 1
18879: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18880: LD_ADDR_EXP 83
18884: PUSH
18885: LD_EXP 83
18889: PPUSH
18890: LD_VAR 0 1
18894: PPUSH
18895: EMPTY
18896: PPUSH
18897: CALL_OW 1
18901: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18902: LD_ADDR_EXP 84
18906: PUSH
18907: LD_EXP 84
18911: PPUSH
18912: LD_VAR 0 1
18916: PPUSH
18917: EMPTY
18918: PPUSH
18919: CALL_OW 1
18923: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18924: LD_ADDR_EXP 85
18928: PUSH
18929: LD_EXP 85
18933: PPUSH
18934: LD_VAR 0 1
18938: PPUSH
18939: EMPTY
18940: PPUSH
18941: CALL_OW 1
18945: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18946: LD_ADDR_EXP 86
18950: PUSH
18951: LD_EXP 86
18955: PPUSH
18956: LD_VAR 0 1
18960: PPUSH
18961: EMPTY
18962: PPUSH
18963: CALL_OW 1
18967: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18968: LD_ADDR_EXP 87
18972: PUSH
18973: LD_EXP 87
18977: PPUSH
18978: LD_VAR 0 1
18982: PPUSH
18983: EMPTY
18984: PPUSH
18985: CALL_OW 1
18989: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18990: LD_ADDR_EXP 88
18994: PUSH
18995: LD_EXP 88
18999: PPUSH
19000: LD_VAR 0 1
19004: PPUSH
19005: EMPTY
19006: PPUSH
19007: CALL_OW 1
19011: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19012: LD_ADDR_EXP 89
19016: PUSH
19017: LD_EXP 89
19021: PPUSH
19022: LD_VAR 0 1
19026: PPUSH
19027: EMPTY
19028: PPUSH
19029: CALL_OW 1
19033: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19034: LD_ADDR_EXP 90
19038: PUSH
19039: LD_EXP 90
19043: PPUSH
19044: LD_VAR 0 1
19048: PPUSH
19049: EMPTY
19050: PPUSH
19051: CALL_OW 1
19055: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19056: LD_ADDR_EXP 91
19060: PUSH
19061: LD_EXP 91
19065: PPUSH
19066: LD_VAR 0 1
19070: PPUSH
19071: EMPTY
19072: PPUSH
19073: CALL_OW 1
19077: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19078: LD_ADDR_EXP 92
19082: PUSH
19083: LD_EXP 92
19087: PPUSH
19088: LD_VAR 0 1
19092: PPUSH
19093: LD_INT 0
19095: PPUSH
19096: CALL_OW 1
19100: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19101: LD_ADDR_EXP 93
19105: PUSH
19106: LD_EXP 93
19110: PPUSH
19111: LD_VAR 0 1
19115: PPUSH
19116: LD_INT 0
19118: PPUSH
19119: CALL_OW 1
19123: ST_TO_ADDR
// end ;
19124: LD_VAR 0 2
19128: RET
// export function MC_Add ( side , units ) ; var base ; begin
19129: LD_INT 0
19131: PPUSH
19132: PPUSH
// base := mc_bases + 1 ;
19133: LD_ADDR_VAR 0 4
19137: PUSH
19138: LD_EXP 50
19142: PUSH
19143: LD_INT 1
19145: PLUS
19146: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19147: LD_ADDR_EXP 76
19151: PUSH
19152: LD_EXP 76
19156: PPUSH
19157: LD_VAR 0 4
19161: PPUSH
19162: LD_VAR 0 1
19166: PPUSH
19167: CALL_OW 1
19171: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19172: LD_ADDR_EXP 50
19176: PUSH
19177: LD_EXP 50
19181: PPUSH
19182: LD_VAR 0 4
19186: PPUSH
19187: LD_VAR 0 2
19191: PPUSH
19192: CALL_OW 1
19196: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19197: LD_ADDR_EXP 51
19201: PUSH
19202: LD_EXP 51
19206: PPUSH
19207: LD_VAR 0 4
19211: PPUSH
19212: EMPTY
19213: PPUSH
19214: CALL_OW 1
19218: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19219: LD_ADDR_EXP 52
19223: PUSH
19224: LD_EXP 52
19228: PPUSH
19229: LD_VAR 0 4
19233: PPUSH
19234: EMPTY
19235: PPUSH
19236: CALL_OW 1
19240: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19241: LD_ADDR_EXP 53
19245: PUSH
19246: LD_EXP 53
19250: PPUSH
19251: LD_VAR 0 4
19255: PPUSH
19256: EMPTY
19257: PPUSH
19258: CALL_OW 1
19262: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19263: LD_ADDR_EXP 54
19267: PUSH
19268: LD_EXP 54
19272: PPUSH
19273: LD_VAR 0 4
19277: PPUSH
19278: EMPTY
19279: PPUSH
19280: CALL_OW 1
19284: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19285: LD_ADDR_EXP 55
19289: PUSH
19290: LD_EXP 55
19294: PPUSH
19295: LD_VAR 0 4
19299: PPUSH
19300: EMPTY
19301: PPUSH
19302: CALL_OW 1
19306: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19307: LD_ADDR_EXP 56
19311: PUSH
19312: LD_EXP 56
19316: PPUSH
19317: LD_VAR 0 4
19321: PPUSH
19322: EMPTY
19323: PPUSH
19324: CALL_OW 1
19328: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19329: LD_ADDR_EXP 57
19333: PUSH
19334: LD_EXP 57
19338: PPUSH
19339: LD_VAR 0 4
19343: PPUSH
19344: EMPTY
19345: PPUSH
19346: CALL_OW 1
19350: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19351: LD_ADDR_EXP 58
19355: PUSH
19356: LD_EXP 58
19360: PPUSH
19361: LD_VAR 0 4
19365: PPUSH
19366: EMPTY
19367: PPUSH
19368: CALL_OW 1
19372: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19373: LD_ADDR_EXP 59
19377: PUSH
19378: LD_EXP 59
19382: PPUSH
19383: LD_VAR 0 4
19387: PPUSH
19388: EMPTY
19389: PPUSH
19390: CALL_OW 1
19394: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19395: LD_ADDR_EXP 60
19399: PUSH
19400: LD_EXP 60
19404: PPUSH
19405: LD_VAR 0 4
19409: PPUSH
19410: EMPTY
19411: PPUSH
19412: CALL_OW 1
19416: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19417: LD_ADDR_EXP 61
19421: PUSH
19422: LD_EXP 61
19426: PPUSH
19427: LD_VAR 0 4
19431: PPUSH
19432: LD_INT 0
19434: PPUSH
19435: CALL_OW 1
19439: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19440: LD_ADDR_EXP 62
19444: PUSH
19445: LD_EXP 62
19449: PPUSH
19450: LD_VAR 0 4
19454: PPUSH
19455: EMPTY
19456: PPUSH
19457: CALL_OW 1
19461: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19462: LD_ADDR_EXP 63
19466: PUSH
19467: LD_EXP 63
19471: PPUSH
19472: LD_VAR 0 4
19476: PPUSH
19477: EMPTY
19478: PPUSH
19479: CALL_OW 1
19483: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19484: LD_ADDR_EXP 64
19488: PUSH
19489: LD_EXP 64
19493: PPUSH
19494: LD_VAR 0 4
19498: PPUSH
19499: EMPTY
19500: PPUSH
19501: CALL_OW 1
19505: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19506: LD_ADDR_EXP 65
19510: PUSH
19511: LD_EXP 65
19515: PPUSH
19516: LD_VAR 0 4
19520: PPUSH
19521: EMPTY
19522: PPUSH
19523: CALL_OW 1
19527: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19528: LD_ADDR_EXP 66
19532: PUSH
19533: LD_EXP 66
19537: PPUSH
19538: LD_VAR 0 4
19542: PPUSH
19543: EMPTY
19544: PPUSH
19545: CALL_OW 1
19549: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19550: LD_ADDR_EXP 67
19554: PUSH
19555: LD_EXP 67
19559: PPUSH
19560: LD_VAR 0 4
19564: PPUSH
19565: EMPTY
19566: PPUSH
19567: CALL_OW 1
19571: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19572: LD_ADDR_EXP 68
19576: PUSH
19577: LD_EXP 68
19581: PPUSH
19582: LD_VAR 0 4
19586: PPUSH
19587: EMPTY
19588: PPUSH
19589: CALL_OW 1
19593: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19594: LD_ADDR_EXP 69
19598: PUSH
19599: LD_EXP 69
19603: PPUSH
19604: LD_VAR 0 4
19608: PPUSH
19609: EMPTY
19610: PPUSH
19611: CALL_OW 1
19615: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19616: LD_ADDR_EXP 70
19620: PUSH
19621: LD_EXP 70
19625: PPUSH
19626: LD_VAR 0 4
19630: PPUSH
19631: EMPTY
19632: PPUSH
19633: CALL_OW 1
19637: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19638: LD_ADDR_EXP 71
19642: PUSH
19643: LD_EXP 71
19647: PPUSH
19648: LD_VAR 0 4
19652: PPUSH
19653: EMPTY
19654: PPUSH
19655: CALL_OW 1
19659: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19660: LD_ADDR_EXP 72
19664: PUSH
19665: LD_EXP 72
19669: PPUSH
19670: LD_VAR 0 4
19674: PPUSH
19675: EMPTY
19676: PPUSH
19677: CALL_OW 1
19681: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19682: LD_ADDR_EXP 73
19686: PUSH
19687: LD_EXP 73
19691: PPUSH
19692: LD_VAR 0 4
19696: PPUSH
19697: EMPTY
19698: PPUSH
19699: CALL_OW 1
19703: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19704: LD_ADDR_EXP 74
19708: PUSH
19709: LD_EXP 74
19713: PPUSH
19714: LD_VAR 0 4
19718: PPUSH
19719: EMPTY
19720: PPUSH
19721: CALL_OW 1
19725: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19726: LD_ADDR_EXP 75
19730: PUSH
19731: LD_EXP 75
19735: PPUSH
19736: LD_VAR 0 4
19740: PPUSH
19741: EMPTY
19742: PPUSH
19743: CALL_OW 1
19747: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19748: LD_ADDR_EXP 77
19752: PUSH
19753: LD_EXP 77
19757: PPUSH
19758: LD_VAR 0 4
19762: PPUSH
19763: EMPTY
19764: PPUSH
19765: CALL_OW 1
19769: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19770: LD_ADDR_EXP 79
19774: PUSH
19775: LD_EXP 79
19779: PPUSH
19780: LD_VAR 0 4
19784: PPUSH
19785: EMPTY
19786: PPUSH
19787: CALL_OW 1
19791: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19792: LD_ADDR_EXP 80
19796: PUSH
19797: LD_EXP 80
19801: PPUSH
19802: LD_VAR 0 4
19806: PPUSH
19807: EMPTY
19808: PPUSH
19809: CALL_OW 1
19813: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19814: LD_ADDR_EXP 81
19818: PUSH
19819: LD_EXP 81
19823: PPUSH
19824: LD_VAR 0 4
19828: PPUSH
19829: EMPTY
19830: PPUSH
19831: CALL_OW 1
19835: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19836: LD_ADDR_EXP 82
19840: PUSH
19841: LD_EXP 82
19845: PPUSH
19846: LD_VAR 0 4
19850: PPUSH
19851: EMPTY
19852: PPUSH
19853: CALL_OW 1
19857: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19858: LD_ADDR_EXP 83
19862: PUSH
19863: LD_EXP 83
19867: PPUSH
19868: LD_VAR 0 4
19872: PPUSH
19873: EMPTY
19874: PPUSH
19875: CALL_OW 1
19879: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19880: LD_ADDR_EXP 84
19884: PUSH
19885: LD_EXP 84
19889: PPUSH
19890: LD_VAR 0 4
19894: PPUSH
19895: EMPTY
19896: PPUSH
19897: CALL_OW 1
19901: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19902: LD_ADDR_EXP 85
19906: PUSH
19907: LD_EXP 85
19911: PPUSH
19912: LD_VAR 0 4
19916: PPUSH
19917: EMPTY
19918: PPUSH
19919: CALL_OW 1
19923: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19924: LD_ADDR_EXP 86
19928: PUSH
19929: LD_EXP 86
19933: PPUSH
19934: LD_VAR 0 4
19938: PPUSH
19939: EMPTY
19940: PPUSH
19941: CALL_OW 1
19945: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19946: LD_ADDR_EXP 87
19950: PUSH
19951: LD_EXP 87
19955: PPUSH
19956: LD_VAR 0 4
19960: PPUSH
19961: EMPTY
19962: PPUSH
19963: CALL_OW 1
19967: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19968: LD_ADDR_EXP 88
19972: PUSH
19973: LD_EXP 88
19977: PPUSH
19978: LD_VAR 0 4
19982: PPUSH
19983: EMPTY
19984: PPUSH
19985: CALL_OW 1
19989: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19990: LD_ADDR_EXP 89
19994: PUSH
19995: LD_EXP 89
19999: PPUSH
20000: LD_VAR 0 4
20004: PPUSH
20005: EMPTY
20006: PPUSH
20007: CALL_OW 1
20011: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20012: LD_ADDR_EXP 90
20016: PUSH
20017: LD_EXP 90
20021: PPUSH
20022: LD_VAR 0 4
20026: PPUSH
20027: EMPTY
20028: PPUSH
20029: CALL_OW 1
20033: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20034: LD_ADDR_EXP 91
20038: PUSH
20039: LD_EXP 91
20043: PPUSH
20044: LD_VAR 0 4
20048: PPUSH
20049: EMPTY
20050: PPUSH
20051: CALL_OW 1
20055: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20056: LD_ADDR_EXP 92
20060: PUSH
20061: LD_EXP 92
20065: PPUSH
20066: LD_VAR 0 4
20070: PPUSH
20071: LD_INT 0
20073: PPUSH
20074: CALL_OW 1
20078: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20079: LD_ADDR_EXP 93
20083: PUSH
20084: LD_EXP 93
20088: PPUSH
20089: LD_VAR 0 4
20093: PPUSH
20094: LD_INT 0
20096: PPUSH
20097: CALL_OW 1
20101: ST_TO_ADDR
// result := base ;
20102: LD_ADDR_VAR 0 3
20106: PUSH
20107: LD_VAR 0 4
20111: ST_TO_ADDR
// end ;
20112: LD_VAR 0 3
20116: RET
// export function MC_Start ( ) ; var i ; begin
20117: LD_INT 0
20119: PPUSH
20120: PPUSH
// for i = 1 to mc_bases do
20121: LD_ADDR_VAR 0 2
20125: PUSH
20126: DOUBLE
20127: LD_INT 1
20129: DEC
20130: ST_TO_ADDR
20131: LD_EXP 50
20135: PUSH
20136: FOR_TO
20137: IFFALSE 21237
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20139: LD_ADDR_EXP 50
20143: PUSH
20144: LD_EXP 50
20148: PPUSH
20149: LD_VAR 0 2
20153: PPUSH
20154: LD_EXP 50
20158: PUSH
20159: LD_VAR 0 2
20163: ARRAY
20164: PUSH
20165: LD_INT 0
20167: DIFF
20168: PPUSH
20169: CALL_OW 1
20173: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20174: LD_ADDR_EXP 51
20178: PUSH
20179: LD_EXP 51
20183: PPUSH
20184: LD_VAR 0 2
20188: PPUSH
20189: EMPTY
20190: PPUSH
20191: CALL_OW 1
20195: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20196: LD_ADDR_EXP 52
20200: PUSH
20201: LD_EXP 52
20205: PPUSH
20206: LD_VAR 0 2
20210: PPUSH
20211: EMPTY
20212: PPUSH
20213: CALL_OW 1
20217: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20218: LD_ADDR_EXP 53
20222: PUSH
20223: LD_EXP 53
20227: PPUSH
20228: LD_VAR 0 2
20232: PPUSH
20233: EMPTY
20234: PPUSH
20235: CALL_OW 1
20239: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20240: LD_ADDR_EXP 54
20244: PUSH
20245: LD_EXP 54
20249: PPUSH
20250: LD_VAR 0 2
20254: PPUSH
20255: EMPTY
20256: PUSH
20257: EMPTY
20258: PUSH
20259: EMPTY
20260: LIST
20261: LIST
20262: PPUSH
20263: CALL_OW 1
20267: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20268: LD_ADDR_EXP 55
20272: PUSH
20273: LD_EXP 55
20277: PPUSH
20278: LD_VAR 0 2
20282: PPUSH
20283: EMPTY
20284: PPUSH
20285: CALL_OW 1
20289: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20290: LD_ADDR_EXP 82
20294: PUSH
20295: LD_EXP 82
20299: PPUSH
20300: LD_VAR 0 2
20304: PPUSH
20305: EMPTY
20306: PPUSH
20307: CALL_OW 1
20311: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20312: LD_ADDR_EXP 56
20316: PUSH
20317: LD_EXP 56
20321: PPUSH
20322: LD_VAR 0 2
20326: PPUSH
20327: EMPTY
20328: PPUSH
20329: CALL_OW 1
20333: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20334: LD_ADDR_EXP 57
20338: PUSH
20339: LD_EXP 57
20343: PPUSH
20344: LD_VAR 0 2
20348: PPUSH
20349: EMPTY
20350: PPUSH
20351: CALL_OW 1
20355: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20356: LD_ADDR_EXP 58
20360: PUSH
20361: LD_EXP 58
20365: PPUSH
20366: LD_VAR 0 2
20370: PPUSH
20371: LD_EXP 50
20375: PUSH
20376: LD_VAR 0 2
20380: ARRAY
20381: PPUSH
20382: LD_INT 2
20384: PUSH
20385: LD_INT 30
20387: PUSH
20388: LD_INT 32
20390: PUSH
20391: EMPTY
20392: LIST
20393: LIST
20394: PUSH
20395: LD_INT 30
20397: PUSH
20398: LD_INT 33
20400: PUSH
20401: EMPTY
20402: LIST
20403: LIST
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: LIST
20409: PPUSH
20410: CALL_OW 72
20414: PPUSH
20415: CALL_OW 1
20419: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20420: LD_ADDR_EXP 59
20424: PUSH
20425: LD_EXP 59
20429: PPUSH
20430: LD_VAR 0 2
20434: PPUSH
20435: LD_EXP 50
20439: PUSH
20440: LD_VAR 0 2
20444: ARRAY
20445: PPUSH
20446: LD_INT 2
20448: PUSH
20449: LD_INT 30
20451: PUSH
20452: LD_INT 32
20454: PUSH
20455: EMPTY
20456: LIST
20457: LIST
20458: PUSH
20459: LD_INT 30
20461: PUSH
20462: LD_INT 31
20464: PUSH
20465: EMPTY
20466: LIST
20467: LIST
20468: PUSH
20469: EMPTY
20470: LIST
20471: LIST
20472: LIST
20473: PUSH
20474: LD_INT 58
20476: PUSH
20477: EMPTY
20478: LIST
20479: PUSH
20480: EMPTY
20481: LIST
20482: LIST
20483: PPUSH
20484: CALL_OW 72
20488: PPUSH
20489: CALL_OW 1
20493: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20494: LD_ADDR_EXP 60
20498: PUSH
20499: LD_EXP 60
20503: PPUSH
20504: LD_VAR 0 2
20508: PPUSH
20509: EMPTY
20510: PPUSH
20511: CALL_OW 1
20515: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20516: LD_ADDR_EXP 64
20520: PUSH
20521: LD_EXP 64
20525: PPUSH
20526: LD_VAR 0 2
20530: PPUSH
20531: EMPTY
20532: PPUSH
20533: CALL_OW 1
20537: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20538: LD_ADDR_EXP 63
20542: PUSH
20543: LD_EXP 63
20547: PPUSH
20548: LD_VAR 0 2
20552: PPUSH
20553: EMPTY
20554: PPUSH
20555: CALL_OW 1
20559: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20560: LD_ADDR_EXP 65
20564: PUSH
20565: LD_EXP 65
20569: PPUSH
20570: LD_VAR 0 2
20574: PPUSH
20575: EMPTY
20576: PPUSH
20577: CALL_OW 1
20581: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20582: LD_ADDR_EXP 66
20586: PUSH
20587: LD_EXP 66
20591: PPUSH
20592: LD_VAR 0 2
20596: PPUSH
20597: EMPTY
20598: PPUSH
20599: CALL_OW 1
20603: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20604: LD_ADDR_EXP 67
20608: PUSH
20609: LD_EXP 67
20613: PPUSH
20614: LD_VAR 0 2
20618: PPUSH
20619: EMPTY
20620: PPUSH
20621: CALL_OW 1
20625: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20626: LD_ADDR_EXP 68
20630: PUSH
20631: LD_EXP 68
20635: PPUSH
20636: LD_VAR 0 2
20640: PPUSH
20641: EMPTY
20642: PPUSH
20643: CALL_OW 1
20647: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20648: LD_ADDR_EXP 69
20652: PUSH
20653: LD_EXP 69
20657: PPUSH
20658: LD_VAR 0 2
20662: PPUSH
20663: EMPTY
20664: PPUSH
20665: CALL_OW 1
20669: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20670: LD_ADDR_EXP 70
20674: PUSH
20675: LD_EXP 70
20679: PPUSH
20680: LD_VAR 0 2
20684: PPUSH
20685: EMPTY
20686: PPUSH
20687: CALL_OW 1
20691: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20692: LD_ADDR_EXP 71
20696: PUSH
20697: LD_EXP 71
20701: PPUSH
20702: LD_VAR 0 2
20706: PPUSH
20707: EMPTY
20708: PPUSH
20709: CALL_OW 1
20713: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20714: LD_ADDR_EXP 72
20718: PUSH
20719: LD_EXP 72
20723: PPUSH
20724: LD_VAR 0 2
20728: PPUSH
20729: EMPTY
20730: PPUSH
20731: CALL_OW 1
20735: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20736: LD_ADDR_EXP 61
20740: PUSH
20741: LD_EXP 61
20745: PPUSH
20746: LD_VAR 0 2
20750: PPUSH
20751: LD_INT 0
20753: PPUSH
20754: CALL_OW 1
20758: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20759: LD_ADDR_EXP 74
20763: PUSH
20764: LD_EXP 74
20768: PPUSH
20769: LD_VAR 0 2
20773: PPUSH
20774: LD_INT 0
20776: PPUSH
20777: CALL_OW 1
20781: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20782: LD_ADDR_EXP 62
20786: PUSH
20787: LD_EXP 62
20791: PPUSH
20792: LD_VAR 0 2
20796: PPUSH
20797: EMPTY
20798: PPUSH
20799: CALL_OW 1
20803: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20804: LD_ADDR_EXP 73
20808: PUSH
20809: LD_EXP 73
20813: PPUSH
20814: LD_VAR 0 2
20818: PPUSH
20819: LD_INT 0
20821: PPUSH
20822: CALL_OW 1
20826: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20827: LD_ADDR_EXP 75
20831: PUSH
20832: LD_EXP 75
20836: PPUSH
20837: LD_VAR 0 2
20841: PPUSH
20842: EMPTY
20843: PPUSH
20844: CALL_OW 1
20848: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20849: LD_ADDR_EXP 78
20853: PUSH
20854: LD_EXP 78
20858: PPUSH
20859: LD_VAR 0 2
20863: PPUSH
20864: LD_INT 0
20866: PPUSH
20867: CALL_OW 1
20871: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20872: LD_ADDR_EXP 79
20876: PUSH
20877: LD_EXP 79
20881: PPUSH
20882: LD_VAR 0 2
20886: PPUSH
20887: EMPTY
20888: PPUSH
20889: CALL_OW 1
20893: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20894: LD_ADDR_EXP 80
20898: PUSH
20899: LD_EXP 80
20903: PPUSH
20904: LD_VAR 0 2
20908: PPUSH
20909: EMPTY
20910: PPUSH
20911: CALL_OW 1
20915: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20916: LD_ADDR_EXP 81
20920: PUSH
20921: LD_EXP 81
20925: PPUSH
20926: LD_VAR 0 2
20930: PPUSH
20931: EMPTY
20932: PPUSH
20933: CALL_OW 1
20937: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20938: LD_ADDR_EXP 83
20942: PUSH
20943: LD_EXP 83
20947: PPUSH
20948: LD_VAR 0 2
20952: PPUSH
20953: LD_EXP 50
20957: PUSH
20958: LD_VAR 0 2
20962: ARRAY
20963: PPUSH
20964: LD_INT 2
20966: PUSH
20967: LD_INT 30
20969: PUSH
20970: LD_INT 6
20972: PUSH
20973: EMPTY
20974: LIST
20975: LIST
20976: PUSH
20977: LD_INT 30
20979: PUSH
20980: LD_INT 7
20982: PUSH
20983: EMPTY
20984: LIST
20985: LIST
20986: PUSH
20987: LD_INT 30
20989: PUSH
20990: LD_INT 8
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: PUSH
20997: EMPTY
20998: LIST
20999: LIST
21000: LIST
21001: LIST
21002: PPUSH
21003: CALL_OW 72
21007: PPUSH
21008: CALL_OW 1
21012: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21013: LD_ADDR_EXP 84
21017: PUSH
21018: LD_EXP 84
21022: PPUSH
21023: LD_VAR 0 2
21027: PPUSH
21028: EMPTY
21029: PPUSH
21030: CALL_OW 1
21034: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21035: LD_ADDR_EXP 85
21039: PUSH
21040: LD_EXP 85
21044: PPUSH
21045: LD_VAR 0 2
21049: PPUSH
21050: EMPTY
21051: PPUSH
21052: CALL_OW 1
21056: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21057: LD_ADDR_EXP 86
21061: PUSH
21062: LD_EXP 86
21066: PPUSH
21067: LD_VAR 0 2
21071: PPUSH
21072: EMPTY
21073: PPUSH
21074: CALL_OW 1
21078: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21079: LD_ADDR_EXP 87
21083: PUSH
21084: LD_EXP 87
21088: PPUSH
21089: LD_VAR 0 2
21093: PPUSH
21094: EMPTY
21095: PPUSH
21096: CALL_OW 1
21100: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21101: LD_ADDR_EXP 88
21105: PUSH
21106: LD_EXP 88
21110: PPUSH
21111: LD_VAR 0 2
21115: PPUSH
21116: EMPTY
21117: PPUSH
21118: CALL_OW 1
21122: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21123: LD_ADDR_EXP 89
21127: PUSH
21128: LD_EXP 89
21132: PPUSH
21133: LD_VAR 0 2
21137: PPUSH
21138: EMPTY
21139: PPUSH
21140: CALL_OW 1
21144: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21145: LD_ADDR_EXP 90
21149: PUSH
21150: LD_EXP 90
21154: PPUSH
21155: LD_VAR 0 2
21159: PPUSH
21160: EMPTY
21161: PPUSH
21162: CALL_OW 1
21166: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21167: LD_ADDR_EXP 91
21171: PUSH
21172: LD_EXP 91
21176: PPUSH
21177: LD_VAR 0 2
21181: PPUSH
21182: EMPTY
21183: PPUSH
21184: CALL_OW 1
21188: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21189: LD_ADDR_EXP 92
21193: PUSH
21194: LD_EXP 92
21198: PPUSH
21199: LD_VAR 0 2
21203: PPUSH
21204: LD_INT 0
21206: PPUSH
21207: CALL_OW 1
21211: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21212: LD_ADDR_EXP 93
21216: PUSH
21217: LD_EXP 93
21221: PPUSH
21222: LD_VAR 0 2
21226: PPUSH
21227: LD_INT 0
21229: PPUSH
21230: CALL_OW 1
21234: ST_TO_ADDR
// end ;
21235: GO 20136
21237: POP
21238: POP
// MC_InitSides ( ) ;
21239: CALL 21525 0 0
// MC_InitResearch ( ) ;
21243: CALL 21264 0 0
// CustomInitMacro ( ) ;
21247: CALL 308 0 0
// skirmish := true ;
21251: LD_ADDR_EXP 48
21255: PUSH
21256: LD_INT 1
21258: ST_TO_ADDR
// end ;
21259: LD_VAR 0 1
21263: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21264: LD_INT 0
21266: PPUSH
21267: PPUSH
21268: PPUSH
21269: PPUSH
21270: PPUSH
21271: PPUSH
// if not mc_bases then
21272: LD_EXP 50
21276: NOT
21277: IFFALSE 21281
// exit ;
21279: GO 21520
// for i = 1 to 8 do
21281: LD_ADDR_VAR 0 2
21285: PUSH
21286: DOUBLE
21287: LD_INT 1
21289: DEC
21290: ST_TO_ADDR
21291: LD_INT 8
21293: PUSH
21294: FOR_TO
21295: IFFALSE 21321
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21297: LD_ADDR_EXP 77
21301: PUSH
21302: LD_EXP 77
21306: PPUSH
21307: LD_VAR 0 2
21311: PPUSH
21312: EMPTY
21313: PPUSH
21314: CALL_OW 1
21318: ST_TO_ADDR
21319: GO 21294
21321: POP
21322: POP
// tmp := [ ] ;
21323: LD_ADDR_VAR 0 5
21327: PUSH
21328: EMPTY
21329: ST_TO_ADDR
// for i = 1 to mc_sides do
21330: LD_ADDR_VAR 0 2
21334: PUSH
21335: DOUBLE
21336: LD_INT 1
21338: DEC
21339: ST_TO_ADDR
21340: LD_EXP 76
21344: PUSH
21345: FOR_TO
21346: IFFALSE 21404
// if not mc_sides [ i ] in tmp then
21348: LD_EXP 76
21352: PUSH
21353: LD_VAR 0 2
21357: ARRAY
21358: PUSH
21359: LD_VAR 0 5
21363: IN
21364: NOT
21365: IFFALSE 21402
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21367: LD_ADDR_VAR 0 5
21371: PUSH
21372: LD_VAR 0 5
21376: PPUSH
21377: LD_VAR 0 5
21381: PUSH
21382: LD_INT 1
21384: PLUS
21385: PPUSH
21386: LD_EXP 76
21390: PUSH
21391: LD_VAR 0 2
21395: ARRAY
21396: PPUSH
21397: CALL_OW 2
21401: ST_TO_ADDR
21402: GO 21345
21404: POP
21405: POP
// if not tmp then
21406: LD_VAR 0 5
21410: NOT
21411: IFFALSE 21415
// exit ;
21413: GO 21520
// for j in tmp do
21415: LD_ADDR_VAR 0 3
21419: PUSH
21420: LD_VAR 0 5
21424: PUSH
21425: FOR_IN
21426: IFFALSE 21518
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21428: LD_ADDR_VAR 0 6
21432: PUSH
21433: LD_INT 22
21435: PUSH
21436: LD_VAR 0 3
21440: PUSH
21441: EMPTY
21442: LIST
21443: LIST
21444: PPUSH
21445: CALL_OW 69
21449: ST_TO_ADDR
// if not un then
21450: LD_VAR 0 6
21454: NOT
21455: IFFALSE 21459
// continue ;
21457: GO 21425
// nation := GetNation ( un [ 1 ] ) ;
21459: LD_ADDR_VAR 0 4
21463: PUSH
21464: LD_VAR 0 6
21468: PUSH
21469: LD_INT 1
21471: ARRAY
21472: PPUSH
21473: CALL_OW 248
21477: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21478: LD_ADDR_EXP 77
21482: PUSH
21483: LD_EXP 77
21487: PPUSH
21488: LD_VAR 0 3
21492: PPUSH
21493: LD_VAR 0 3
21497: PPUSH
21498: LD_VAR 0 4
21502: PPUSH
21503: LD_INT 1
21505: PPUSH
21506: CALL 48641 0 3
21510: PPUSH
21511: CALL_OW 1
21515: ST_TO_ADDR
// end ;
21516: GO 21425
21518: POP
21519: POP
// end ;
21520: LD_VAR 0 1
21524: RET
// export function MC_InitSides ( ) ; var i ; begin
21525: LD_INT 0
21527: PPUSH
21528: PPUSH
// if not mc_bases then
21529: LD_EXP 50
21533: NOT
21534: IFFALSE 21538
// exit ;
21536: GO 21612
// for i = 1 to mc_bases do
21538: LD_ADDR_VAR 0 2
21542: PUSH
21543: DOUBLE
21544: LD_INT 1
21546: DEC
21547: ST_TO_ADDR
21548: LD_EXP 50
21552: PUSH
21553: FOR_TO
21554: IFFALSE 21610
// if mc_bases [ i ] then
21556: LD_EXP 50
21560: PUSH
21561: LD_VAR 0 2
21565: ARRAY
21566: IFFALSE 21608
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21568: LD_ADDR_EXP 76
21572: PUSH
21573: LD_EXP 76
21577: PPUSH
21578: LD_VAR 0 2
21582: PPUSH
21583: LD_EXP 50
21587: PUSH
21588: LD_VAR 0 2
21592: ARRAY
21593: PUSH
21594: LD_INT 1
21596: ARRAY
21597: PPUSH
21598: CALL_OW 255
21602: PPUSH
21603: CALL_OW 1
21607: ST_TO_ADDR
21608: GO 21553
21610: POP
21611: POP
// end ;
21612: LD_VAR 0 1
21616: RET
// every 0 0$03 trigger skirmish do
21617: LD_EXP 48
21621: IFFALSE 21775
21623: GO 21625
21625: DISABLE
// begin enable ;
21626: ENABLE
// MC_CheckBuildings ( ) ;
21627: CALL 26273 0 0
// MC_CheckPeopleLife ( ) ;
21631: CALL 26434 0 0
// RaiseSailEvent ( 100 ) ;
21635: LD_INT 100
21637: PPUSH
21638: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21642: LD_INT 103
21644: PPUSH
21645: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21649: LD_INT 104
21651: PPUSH
21652: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21656: LD_INT 105
21658: PPUSH
21659: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21663: LD_INT 106
21665: PPUSH
21666: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21670: LD_INT 107
21672: PPUSH
21673: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21677: LD_INT 108
21679: PPUSH
21680: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21684: LD_INT 109
21686: PPUSH
21687: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21691: LD_INT 110
21693: PPUSH
21694: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21698: LD_INT 111
21700: PPUSH
21701: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21705: LD_INT 112
21707: PPUSH
21708: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21712: LD_INT 113
21714: PPUSH
21715: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21719: LD_INT 120
21721: PPUSH
21722: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21726: LD_INT 121
21728: PPUSH
21729: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21733: LD_INT 122
21735: PPUSH
21736: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21740: LD_INT 123
21742: PPUSH
21743: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21747: LD_INT 124
21749: PPUSH
21750: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21754: LD_INT 125
21756: PPUSH
21757: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21761: LD_INT 126
21763: PPUSH
21764: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21768: LD_INT 200
21770: PPUSH
21771: CALL_OW 427
// end ;
21775: END
// on SailEvent ( event ) do begin if event < 100 then
21776: LD_VAR 0 1
21780: PUSH
21781: LD_INT 100
21783: LESS
21784: IFFALSE 21795
// CustomEvent ( event ) ;
21786: LD_VAR 0 1
21790: PPUSH
21791: CALL 17138 0 1
// if event = 100 then
21795: LD_VAR 0 1
21799: PUSH
21800: LD_INT 100
21802: EQUAL
21803: IFFALSE 21809
// MC_ClassManager ( ) ;
21805: CALL 22201 0 0
// if event = 101 then
21809: LD_VAR 0 1
21813: PUSH
21814: LD_INT 101
21816: EQUAL
21817: IFFALSE 21823
// MC_RepairBuildings ( ) ;
21819: CALL 27019 0 0
// if event = 102 then
21823: LD_VAR 0 1
21827: PUSH
21828: LD_INT 102
21830: EQUAL
21831: IFFALSE 21837
// MC_Heal ( ) ;
21833: CALL 27926 0 0
// if event = 103 then
21837: LD_VAR 0 1
21841: PUSH
21842: LD_INT 103
21844: EQUAL
21845: IFFALSE 21851
// MC_Build ( ) ;
21847: CALL 28348 0 0
// if event = 104 then
21851: LD_VAR 0 1
21855: PUSH
21856: LD_INT 104
21858: EQUAL
21859: IFFALSE 21865
// MC_TurretWeapon ( ) ;
21861: CALL 29989 0 0
// if event = 105 then
21865: LD_VAR 0 1
21869: PUSH
21870: LD_INT 105
21872: EQUAL
21873: IFFALSE 21879
// MC_BuildUpgrade ( ) ;
21875: CALL 29540 0 0
// if event = 106 then
21879: LD_VAR 0 1
21883: PUSH
21884: LD_INT 106
21886: EQUAL
21887: IFFALSE 21893
// MC_PlantMines ( ) ;
21889: CALL 30419 0 0
// if event = 107 then
21893: LD_VAR 0 1
21897: PUSH
21898: LD_INT 107
21900: EQUAL
21901: IFFALSE 21907
// MC_CollectCrates ( ) ;
21903: CALL 31210 0 0
// if event = 108 then
21907: LD_VAR 0 1
21911: PUSH
21912: LD_INT 108
21914: EQUAL
21915: IFFALSE 21921
// MC_LinkRemoteControl ( ) ;
21917: CALL 33060 0 0
// if event = 109 then
21921: LD_VAR 0 1
21925: PUSH
21926: LD_INT 109
21928: EQUAL
21929: IFFALSE 21935
// MC_ProduceVehicle ( ) ;
21931: CALL 33241 0 0
// if event = 110 then
21935: LD_VAR 0 1
21939: PUSH
21940: LD_INT 110
21942: EQUAL
21943: IFFALSE 21949
// MC_SendAttack ( ) ;
21945: CALL 33707 0 0
// if event = 111 then
21949: LD_VAR 0 1
21953: PUSH
21954: LD_INT 111
21956: EQUAL
21957: IFFALSE 21963
// MC_Defend ( ) ;
21959: CALL 33815 0 0
// if event = 112 then
21963: LD_VAR 0 1
21967: PUSH
21968: LD_INT 112
21970: EQUAL
21971: IFFALSE 21977
// MC_Research ( ) ;
21973: CALL 34695 0 0
// if event = 113 then
21977: LD_VAR 0 1
21981: PUSH
21982: LD_INT 113
21984: EQUAL
21985: IFFALSE 21991
// MC_MinesTrigger ( ) ;
21987: CALL 35809 0 0
// if event = 120 then
21991: LD_VAR 0 1
21995: PUSH
21996: LD_INT 120
21998: EQUAL
21999: IFFALSE 22005
// MC_RepairVehicle ( ) ;
22001: CALL 35908 0 0
// if event = 121 then
22005: LD_VAR 0 1
22009: PUSH
22010: LD_INT 121
22012: EQUAL
22013: IFFALSE 22019
// MC_TameApe ( ) ;
22015: CALL 36649 0 0
// if event = 122 then
22019: LD_VAR 0 1
22023: PUSH
22024: LD_INT 122
22026: EQUAL
22027: IFFALSE 22033
// MC_ChangeApeClass ( ) ;
22029: CALL 37478 0 0
// if event = 123 then
22033: LD_VAR 0 1
22037: PUSH
22038: LD_INT 123
22040: EQUAL
22041: IFFALSE 22047
// MC_Bazooka ( ) ;
22043: CALL 38128 0 0
// if event = 124 then
22047: LD_VAR 0 1
22051: PUSH
22052: LD_INT 124
22054: EQUAL
22055: IFFALSE 22061
// MC_TeleportExit ( ) ;
22057: CALL 38326 0 0
// if event = 125 then
22061: LD_VAR 0 1
22065: PUSH
22066: LD_INT 125
22068: EQUAL
22069: IFFALSE 22075
// MC_Deposits ( ) ;
22071: CALL 38973 0 0
// if event = 126 then
22075: LD_VAR 0 1
22079: PUSH
22080: LD_INT 126
22082: EQUAL
22083: IFFALSE 22089
// MC_RemoteDriver ( ) ;
22085: CALL 39598 0 0
// if event = 200 then
22089: LD_VAR 0 1
22093: PUSH
22094: LD_INT 200
22096: EQUAL
22097: IFFALSE 22103
// MC_Idle ( ) ;
22099: CALL 41547 0 0
// end ;
22103: PPOPN 1
22105: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22106: LD_INT 0
22108: PPUSH
22109: PPUSH
// if not mc_bases [ base ] or not tag then
22110: LD_EXP 50
22114: PUSH
22115: LD_VAR 0 1
22119: ARRAY
22120: NOT
22121: PUSH
22122: LD_VAR 0 2
22126: NOT
22127: OR
22128: IFFALSE 22132
// exit ;
22130: GO 22196
// for i in mc_bases [ base ] union mc_ape [ base ] do
22132: LD_ADDR_VAR 0 4
22136: PUSH
22137: LD_EXP 50
22141: PUSH
22142: LD_VAR 0 1
22146: ARRAY
22147: PUSH
22148: LD_EXP 79
22152: PUSH
22153: LD_VAR 0 1
22157: ARRAY
22158: UNION
22159: PUSH
22160: FOR_IN
22161: IFFALSE 22194
// if GetTag ( i ) = tag then
22163: LD_VAR 0 4
22167: PPUSH
22168: CALL_OW 110
22172: PUSH
22173: LD_VAR 0 2
22177: EQUAL
22178: IFFALSE 22192
// SetTag ( i , 0 ) ;
22180: LD_VAR 0 4
22184: PPUSH
22185: LD_INT 0
22187: PPUSH
22188: CALL_OW 109
22192: GO 22160
22194: POP
22195: POP
// end ;
22196: LD_VAR 0 3
22200: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22201: LD_INT 0
22203: PPUSH
22204: PPUSH
22205: PPUSH
22206: PPUSH
22207: PPUSH
22208: PPUSH
22209: PPUSH
22210: PPUSH
// if not mc_bases then
22211: LD_EXP 50
22215: NOT
22216: IFFALSE 22220
// exit ;
22218: GO 22678
// for i = 1 to mc_bases do
22220: LD_ADDR_VAR 0 2
22224: PUSH
22225: DOUBLE
22226: LD_INT 1
22228: DEC
22229: ST_TO_ADDR
22230: LD_EXP 50
22234: PUSH
22235: FOR_TO
22236: IFFALSE 22676
// begin tmp := MC_ClassCheckReq ( i ) ;
22238: LD_ADDR_VAR 0 4
22242: PUSH
22243: LD_VAR 0 2
22247: PPUSH
22248: CALL 22683 0 1
22252: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22253: LD_ADDR_EXP 91
22257: PUSH
22258: LD_EXP 91
22262: PPUSH
22263: LD_VAR 0 2
22267: PPUSH
22268: LD_VAR 0 4
22272: PPUSH
22273: CALL_OW 1
22277: ST_TO_ADDR
// if not tmp then
22278: LD_VAR 0 4
22282: NOT
22283: IFFALSE 22287
// continue ;
22285: GO 22235
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22287: LD_ADDR_VAR 0 6
22291: PUSH
22292: LD_EXP 50
22296: PUSH
22297: LD_VAR 0 2
22301: ARRAY
22302: PPUSH
22303: LD_INT 2
22305: PUSH
22306: LD_INT 30
22308: PUSH
22309: LD_INT 4
22311: PUSH
22312: EMPTY
22313: LIST
22314: LIST
22315: PUSH
22316: LD_INT 30
22318: PUSH
22319: LD_INT 5
22321: PUSH
22322: EMPTY
22323: LIST
22324: LIST
22325: PUSH
22326: EMPTY
22327: LIST
22328: LIST
22329: LIST
22330: PPUSH
22331: CALL_OW 72
22335: PUSH
22336: LD_EXP 50
22340: PUSH
22341: LD_VAR 0 2
22345: ARRAY
22346: PPUSH
22347: LD_INT 2
22349: PUSH
22350: LD_INT 30
22352: PUSH
22353: LD_INT 0
22355: PUSH
22356: EMPTY
22357: LIST
22358: LIST
22359: PUSH
22360: LD_INT 30
22362: PUSH
22363: LD_INT 1
22365: PUSH
22366: EMPTY
22367: LIST
22368: LIST
22369: PUSH
22370: EMPTY
22371: LIST
22372: LIST
22373: LIST
22374: PPUSH
22375: CALL_OW 72
22379: PUSH
22380: LD_EXP 50
22384: PUSH
22385: LD_VAR 0 2
22389: ARRAY
22390: PPUSH
22391: LD_INT 30
22393: PUSH
22394: LD_INT 3
22396: PUSH
22397: EMPTY
22398: LIST
22399: LIST
22400: PPUSH
22401: CALL_OW 72
22405: PUSH
22406: LD_EXP 50
22410: PUSH
22411: LD_VAR 0 2
22415: ARRAY
22416: PPUSH
22417: LD_INT 2
22419: PUSH
22420: LD_INT 30
22422: PUSH
22423: LD_INT 6
22425: PUSH
22426: EMPTY
22427: LIST
22428: LIST
22429: PUSH
22430: LD_INT 30
22432: PUSH
22433: LD_INT 7
22435: PUSH
22436: EMPTY
22437: LIST
22438: LIST
22439: PUSH
22440: LD_INT 30
22442: PUSH
22443: LD_INT 8
22445: PUSH
22446: EMPTY
22447: LIST
22448: LIST
22449: PUSH
22450: EMPTY
22451: LIST
22452: LIST
22453: LIST
22454: LIST
22455: PPUSH
22456: CALL_OW 72
22460: PUSH
22461: EMPTY
22462: LIST
22463: LIST
22464: LIST
22465: LIST
22466: ST_TO_ADDR
// for j = 1 to 4 do
22467: LD_ADDR_VAR 0 3
22471: PUSH
22472: DOUBLE
22473: LD_INT 1
22475: DEC
22476: ST_TO_ADDR
22477: LD_INT 4
22479: PUSH
22480: FOR_TO
22481: IFFALSE 22672
// begin if not tmp [ j ] then
22483: LD_VAR 0 4
22487: PUSH
22488: LD_VAR 0 3
22492: ARRAY
22493: NOT
22494: IFFALSE 22498
// continue ;
22496: GO 22480
// for p in tmp [ j ] do
22498: LD_ADDR_VAR 0 5
22502: PUSH
22503: LD_VAR 0 4
22507: PUSH
22508: LD_VAR 0 3
22512: ARRAY
22513: PUSH
22514: FOR_IN
22515: IFFALSE 22668
// begin if not b [ j ] then
22517: LD_VAR 0 6
22521: PUSH
22522: LD_VAR 0 3
22526: ARRAY
22527: NOT
22528: IFFALSE 22532
// break ;
22530: GO 22668
// e := 0 ;
22532: LD_ADDR_VAR 0 7
22536: PUSH
22537: LD_INT 0
22539: ST_TO_ADDR
// for k in b [ j ] do
22540: LD_ADDR_VAR 0 8
22544: PUSH
22545: LD_VAR 0 6
22549: PUSH
22550: LD_VAR 0 3
22554: ARRAY
22555: PUSH
22556: FOR_IN
22557: IFFALSE 22584
// if IsNotFull ( k ) then
22559: LD_VAR 0 8
22563: PPUSH
22564: CALL 50794 0 1
22568: IFFALSE 22582
// begin e := k ;
22570: LD_ADDR_VAR 0 7
22574: PUSH
22575: LD_VAR 0 8
22579: ST_TO_ADDR
// break ;
22580: GO 22584
// end ;
22582: GO 22556
22584: POP
22585: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22586: LD_VAR 0 7
22590: PUSH
22591: LD_VAR 0 5
22595: PPUSH
22596: LD_VAR 0 7
22600: PPUSH
22601: CALL 83905 0 2
22605: NOT
22606: AND
22607: IFFALSE 22666
// begin if IsInUnit ( p ) then
22609: LD_VAR 0 5
22613: PPUSH
22614: CALL_OW 310
22618: IFFALSE 22629
// ComExitBuilding ( p ) ;
22620: LD_VAR 0 5
22624: PPUSH
22625: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22629: LD_VAR 0 5
22633: PPUSH
22634: LD_VAR 0 7
22638: PPUSH
22639: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22643: LD_VAR 0 5
22647: PPUSH
22648: LD_VAR 0 3
22652: PPUSH
22653: CALL_OW 183
// AddComExitBuilding ( p ) ;
22657: LD_VAR 0 5
22661: PPUSH
22662: CALL_OW 182
// end ; end ;
22666: GO 22514
22668: POP
22669: POP
// end ;
22670: GO 22480
22672: POP
22673: POP
// end ;
22674: GO 22235
22676: POP
22677: POP
// end ;
22678: LD_VAR 0 1
22682: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22683: LD_INT 0
22685: PPUSH
22686: PPUSH
22687: PPUSH
22688: PPUSH
22689: PPUSH
22690: PPUSH
22691: PPUSH
22692: PPUSH
22693: PPUSH
22694: PPUSH
22695: PPUSH
22696: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22697: LD_VAR 0 1
22701: NOT
22702: PUSH
22703: LD_EXP 50
22707: PUSH
22708: LD_VAR 0 1
22712: ARRAY
22713: NOT
22714: OR
22715: PUSH
22716: LD_EXP 50
22720: PUSH
22721: LD_VAR 0 1
22725: ARRAY
22726: PPUSH
22727: LD_INT 2
22729: PUSH
22730: LD_INT 30
22732: PUSH
22733: LD_INT 0
22735: PUSH
22736: EMPTY
22737: LIST
22738: LIST
22739: PUSH
22740: LD_INT 30
22742: PUSH
22743: LD_INT 1
22745: PUSH
22746: EMPTY
22747: LIST
22748: LIST
22749: PUSH
22750: EMPTY
22751: LIST
22752: LIST
22753: LIST
22754: PPUSH
22755: CALL_OW 72
22759: NOT
22760: OR
22761: IFFALSE 22765
// exit ;
22763: GO 26268
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22765: LD_ADDR_VAR 0 4
22769: PUSH
22770: LD_EXP 50
22774: PUSH
22775: LD_VAR 0 1
22779: ARRAY
22780: PPUSH
22781: LD_INT 2
22783: PUSH
22784: LD_INT 25
22786: PUSH
22787: LD_INT 1
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: PUSH
22794: LD_INT 25
22796: PUSH
22797: LD_INT 2
22799: PUSH
22800: EMPTY
22801: LIST
22802: LIST
22803: PUSH
22804: LD_INT 25
22806: PUSH
22807: LD_INT 3
22809: PUSH
22810: EMPTY
22811: LIST
22812: LIST
22813: PUSH
22814: LD_INT 25
22816: PUSH
22817: LD_INT 4
22819: PUSH
22820: EMPTY
22821: LIST
22822: LIST
22823: PUSH
22824: LD_INT 25
22826: PUSH
22827: LD_INT 5
22829: PUSH
22830: EMPTY
22831: LIST
22832: LIST
22833: PUSH
22834: LD_INT 25
22836: PUSH
22837: LD_INT 8
22839: PUSH
22840: EMPTY
22841: LIST
22842: LIST
22843: PUSH
22844: LD_INT 25
22846: PUSH
22847: LD_INT 9
22849: PUSH
22850: EMPTY
22851: LIST
22852: LIST
22853: PUSH
22854: EMPTY
22855: LIST
22856: LIST
22857: LIST
22858: LIST
22859: LIST
22860: LIST
22861: LIST
22862: LIST
22863: PPUSH
22864: CALL_OW 72
22868: ST_TO_ADDR
// if not tmp then
22869: LD_VAR 0 4
22873: NOT
22874: IFFALSE 22878
// exit ;
22876: GO 26268
// for i in tmp do
22878: LD_ADDR_VAR 0 3
22882: PUSH
22883: LD_VAR 0 4
22887: PUSH
22888: FOR_IN
22889: IFFALSE 22920
// if GetTag ( i ) then
22891: LD_VAR 0 3
22895: PPUSH
22896: CALL_OW 110
22900: IFFALSE 22918
// tmp := tmp diff i ;
22902: LD_ADDR_VAR 0 4
22906: PUSH
22907: LD_VAR 0 4
22911: PUSH
22912: LD_VAR 0 3
22916: DIFF
22917: ST_TO_ADDR
22918: GO 22888
22920: POP
22921: POP
// if not tmp then
22922: LD_VAR 0 4
22926: NOT
22927: IFFALSE 22931
// exit ;
22929: GO 26268
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22931: LD_ADDR_VAR 0 5
22935: PUSH
22936: LD_EXP 50
22940: PUSH
22941: LD_VAR 0 1
22945: ARRAY
22946: PPUSH
22947: LD_INT 2
22949: PUSH
22950: LD_INT 25
22952: PUSH
22953: LD_INT 1
22955: PUSH
22956: EMPTY
22957: LIST
22958: LIST
22959: PUSH
22960: LD_INT 25
22962: PUSH
22963: LD_INT 5
22965: PUSH
22966: EMPTY
22967: LIST
22968: LIST
22969: PUSH
22970: LD_INT 25
22972: PUSH
22973: LD_INT 8
22975: PUSH
22976: EMPTY
22977: LIST
22978: LIST
22979: PUSH
22980: LD_INT 25
22982: PUSH
22983: LD_INT 9
22985: PUSH
22986: EMPTY
22987: LIST
22988: LIST
22989: PUSH
22990: EMPTY
22991: LIST
22992: LIST
22993: LIST
22994: LIST
22995: LIST
22996: PPUSH
22997: CALL_OW 72
23001: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23002: LD_ADDR_VAR 0 6
23006: PUSH
23007: LD_EXP 50
23011: PUSH
23012: LD_VAR 0 1
23016: ARRAY
23017: PPUSH
23018: LD_INT 25
23020: PUSH
23021: LD_INT 2
23023: PUSH
23024: EMPTY
23025: LIST
23026: LIST
23027: PPUSH
23028: CALL_OW 72
23032: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23033: LD_ADDR_VAR 0 7
23037: PUSH
23038: LD_EXP 50
23042: PUSH
23043: LD_VAR 0 1
23047: ARRAY
23048: PPUSH
23049: LD_INT 25
23051: PUSH
23052: LD_INT 3
23054: PUSH
23055: EMPTY
23056: LIST
23057: LIST
23058: PPUSH
23059: CALL_OW 72
23063: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23064: LD_ADDR_VAR 0 8
23068: PUSH
23069: LD_EXP 50
23073: PUSH
23074: LD_VAR 0 1
23078: ARRAY
23079: PPUSH
23080: LD_INT 25
23082: PUSH
23083: LD_INT 4
23085: PUSH
23086: EMPTY
23087: LIST
23088: LIST
23089: PUSH
23090: LD_INT 24
23092: PUSH
23093: LD_INT 251
23095: PUSH
23096: EMPTY
23097: LIST
23098: LIST
23099: PUSH
23100: EMPTY
23101: LIST
23102: LIST
23103: PPUSH
23104: CALL_OW 72
23108: ST_TO_ADDR
// if mc_is_defending [ base ] then
23109: LD_EXP 93
23113: PUSH
23114: LD_VAR 0 1
23118: ARRAY
23119: IFFALSE 23580
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23121: LD_ADDR_EXP 92
23125: PUSH
23126: LD_EXP 92
23130: PPUSH
23131: LD_VAR 0 1
23135: PPUSH
23136: LD_INT 4
23138: PPUSH
23139: CALL_OW 1
23143: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23144: LD_ADDR_VAR 0 12
23148: PUSH
23149: LD_EXP 50
23153: PUSH
23154: LD_VAR 0 1
23158: ARRAY
23159: PPUSH
23160: LD_INT 2
23162: PUSH
23163: LD_INT 30
23165: PUSH
23166: LD_INT 4
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: PUSH
23173: LD_INT 30
23175: PUSH
23176: LD_INT 5
23178: PUSH
23179: EMPTY
23180: LIST
23181: LIST
23182: PUSH
23183: EMPTY
23184: LIST
23185: LIST
23186: LIST
23187: PPUSH
23188: CALL_OW 72
23192: ST_TO_ADDR
// if not b then
23193: LD_VAR 0 12
23197: NOT
23198: IFFALSE 23202
// exit ;
23200: GO 26268
// p := [ ] ;
23202: LD_ADDR_VAR 0 11
23206: PUSH
23207: EMPTY
23208: ST_TO_ADDR
// if sci >= 2 then
23209: LD_VAR 0 8
23213: PUSH
23214: LD_INT 2
23216: GREATEREQUAL
23217: IFFALSE 23248
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23219: LD_ADDR_VAR 0 8
23223: PUSH
23224: LD_VAR 0 8
23228: PUSH
23229: LD_INT 1
23231: ARRAY
23232: PUSH
23233: LD_VAR 0 8
23237: PUSH
23238: LD_INT 2
23240: ARRAY
23241: PUSH
23242: EMPTY
23243: LIST
23244: LIST
23245: ST_TO_ADDR
23246: GO 23309
// if sci = 1 then
23248: LD_VAR 0 8
23252: PUSH
23253: LD_INT 1
23255: EQUAL
23256: IFFALSE 23277
// sci := [ sci [ 1 ] ] else
23258: LD_ADDR_VAR 0 8
23262: PUSH
23263: LD_VAR 0 8
23267: PUSH
23268: LD_INT 1
23270: ARRAY
23271: PUSH
23272: EMPTY
23273: LIST
23274: ST_TO_ADDR
23275: GO 23309
// if sci = 0 then
23277: LD_VAR 0 8
23281: PUSH
23282: LD_INT 0
23284: EQUAL
23285: IFFALSE 23309
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23287: LD_ADDR_VAR 0 11
23291: PUSH
23292: LD_VAR 0 4
23296: PPUSH
23297: LD_INT 4
23299: PPUSH
23300: CALL 83768 0 2
23304: PUSH
23305: LD_INT 1
23307: ARRAY
23308: ST_TO_ADDR
// if eng > 4 then
23309: LD_VAR 0 6
23313: PUSH
23314: LD_INT 4
23316: GREATER
23317: IFFALSE 23363
// for i = eng downto 4 do
23319: LD_ADDR_VAR 0 3
23323: PUSH
23324: DOUBLE
23325: LD_VAR 0 6
23329: INC
23330: ST_TO_ADDR
23331: LD_INT 4
23333: PUSH
23334: FOR_DOWNTO
23335: IFFALSE 23361
// eng := eng diff eng [ i ] ;
23337: LD_ADDR_VAR 0 6
23341: PUSH
23342: LD_VAR 0 6
23346: PUSH
23347: LD_VAR 0 6
23351: PUSH
23352: LD_VAR 0 3
23356: ARRAY
23357: DIFF
23358: ST_TO_ADDR
23359: GO 23334
23361: POP
23362: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23363: LD_ADDR_VAR 0 4
23367: PUSH
23368: LD_VAR 0 4
23372: PUSH
23373: LD_VAR 0 5
23377: PUSH
23378: LD_VAR 0 6
23382: UNION
23383: PUSH
23384: LD_VAR 0 7
23388: UNION
23389: PUSH
23390: LD_VAR 0 8
23394: UNION
23395: DIFF
23396: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23397: LD_ADDR_VAR 0 13
23401: PUSH
23402: LD_EXP 50
23406: PUSH
23407: LD_VAR 0 1
23411: ARRAY
23412: PPUSH
23413: LD_INT 2
23415: PUSH
23416: LD_INT 30
23418: PUSH
23419: LD_INT 32
23421: PUSH
23422: EMPTY
23423: LIST
23424: LIST
23425: PUSH
23426: LD_INT 30
23428: PUSH
23429: LD_INT 31
23431: PUSH
23432: EMPTY
23433: LIST
23434: LIST
23435: PUSH
23436: EMPTY
23437: LIST
23438: LIST
23439: LIST
23440: PPUSH
23441: CALL_OW 72
23445: PUSH
23446: LD_EXP 50
23450: PUSH
23451: LD_VAR 0 1
23455: ARRAY
23456: PPUSH
23457: LD_INT 2
23459: PUSH
23460: LD_INT 30
23462: PUSH
23463: LD_INT 4
23465: PUSH
23466: EMPTY
23467: LIST
23468: LIST
23469: PUSH
23470: LD_INT 30
23472: PUSH
23473: LD_INT 5
23475: PUSH
23476: EMPTY
23477: LIST
23478: LIST
23479: PUSH
23480: EMPTY
23481: LIST
23482: LIST
23483: LIST
23484: PPUSH
23485: CALL_OW 72
23489: PUSH
23490: LD_INT 6
23492: MUL
23493: PLUS
23494: ST_TO_ADDR
// if bcount < tmp then
23495: LD_VAR 0 13
23499: PUSH
23500: LD_VAR 0 4
23504: LESS
23505: IFFALSE 23551
// for i = tmp downto bcount do
23507: LD_ADDR_VAR 0 3
23511: PUSH
23512: DOUBLE
23513: LD_VAR 0 4
23517: INC
23518: ST_TO_ADDR
23519: LD_VAR 0 13
23523: PUSH
23524: FOR_DOWNTO
23525: IFFALSE 23549
// tmp := Delete ( tmp , tmp ) ;
23527: LD_ADDR_VAR 0 4
23531: PUSH
23532: LD_VAR 0 4
23536: PPUSH
23537: LD_VAR 0 4
23541: PPUSH
23542: CALL_OW 3
23546: ST_TO_ADDR
23547: GO 23524
23549: POP
23550: POP
// result := [ tmp , 0 , 0 , p ] ;
23551: LD_ADDR_VAR 0 2
23555: PUSH
23556: LD_VAR 0 4
23560: PUSH
23561: LD_INT 0
23563: PUSH
23564: LD_INT 0
23566: PUSH
23567: LD_VAR 0 11
23571: PUSH
23572: EMPTY
23573: LIST
23574: LIST
23575: LIST
23576: LIST
23577: ST_TO_ADDR
// exit ;
23578: GO 26268
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23580: LD_EXP 50
23584: PUSH
23585: LD_VAR 0 1
23589: ARRAY
23590: PPUSH
23591: LD_INT 2
23593: PUSH
23594: LD_INT 30
23596: PUSH
23597: LD_INT 6
23599: PUSH
23600: EMPTY
23601: LIST
23602: LIST
23603: PUSH
23604: LD_INT 30
23606: PUSH
23607: LD_INT 7
23609: PUSH
23610: EMPTY
23611: LIST
23612: LIST
23613: PUSH
23614: LD_INT 30
23616: PUSH
23617: LD_INT 8
23619: PUSH
23620: EMPTY
23621: LIST
23622: LIST
23623: PUSH
23624: EMPTY
23625: LIST
23626: LIST
23627: LIST
23628: LIST
23629: PPUSH
23630: CALL_OW 72
23634: NOT
23635: PUSH
23636: LD_EXP 50
23640: PUSH
23641: LD_VAR 0 1
23645: ARRAY
23646: PPUSH
23647: LD_INT 30
23649: PUSH
23650: LD_INT 3
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: PPUSH
23657: CALL_OW 72
23661: NOT
23662: AND
23663: IFFALSE 23735
// begin if eng = tmp then
23665: LD_VAR 0 6
23669: PUSH
23670: LD_VAR 0 4
23674: EQUAL
23675: IFFALSE 23679
// exit ;
23677: GO 26268
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23679: LD_ADDR_EXP 92
23683: PUSH
23684: LD_EXP 92
23688: PPUSH
23689: LD_VAR 0 1
23693: PPUSH
23694: LD_INT 1
23696: PPUSH
23697: CALL_OW 1
23701: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23702: LD_ADDR_VAR 0 2
23706: PUSH
23707: LD_INT 0
23709: PUSH
23710: LD_VAR 0 4
23714: PUSH
23715: LD_VAR 0 6
23719: DIFF
23720: PUSH
23721: LD_INT 0
23723: PUSH
23724: LD_INT 0
23726: PUSH
23727: EMPTY
23728: LIST
23729: LIST
23730: LIST
23731: LIST
23732: ST_TO_ADDR
// exit ;
23733: GO 26268
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23735: LD_EXP 77
23739: PUSH
23740: LD_EXP 76
23744: PUSH
23745: LD_VAR 0 1
23749: ARRAY
23750: ARRAY
23751: PUSH
23752: LD_EXP 50
23756: PUSH
23757: LD_VAR 0 1
23761: ARRAY
23762: PPUSH
23763: LD_INT 2
23765: PUSH
23766: LD_INT 30
23768: PUSH
23769: LD_INT 6
23771: PUSH
23772: EMPTY
23773: LIST
23774: LIST
23775: PUSH
23776: LD_INT 30
23778: PUSH
23779: LD_INT 7
23781: PUSH
23782: EMPTY
23783: LIST
23784: LIST
23785: PUSH
23786: LD_INT 30
23788: PUSH
23789: LD_INT 8
23791: PUSH
23792: EMPTY
23793: LIST
23794: LIST
23795: PUSH
23796: EMPTY
23797: LIST
23798: LIST
23799: LIST
23800: LIST
23801: PPUSH
23802: CALL_OW 72
23806: AND
23807: PUSH
23808: LD_EXP 50
23812: PUSH
23813: LD_VAR 0 1
23817: ARRAY
23818: PPUSH
23819: LD_INT 30
23821: PUSH
23822: LD_INT 3
23824: PUSH
23825: EMPTY
23826: LIST
23827: LIST
23828: PPUSH
23829: CALL_OW 72
23833: NOT
23834: AND
23835: IFFALSE 24049
// begin if sci >= 6 then
23837: LD_VAR 0 8
23841: PUSH
23842: LD_INT 6
23844: GREATEREQUAL
23845: IFFALSE 23849
// exit ;
23847: GO 26268
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23849: LD_ADDR_EXP 92
23853: PUSH
23854: LD_EXP 92
23858: PPUSH
23859: LD_VAR 0 1
23863: PPUSH
23864: LD_INT 2
23866: PPUSH
23867: CALL_OW 1
23871: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23872: LD_ADDR_VAR 0 9
23876: PUSH
23877: LD_VAR 0 4
23881: PUSH
23882: LD_VAR 0 8
23886: DIFF
23887: PPUSH
23888: LD_INT 4
23890: PPUSH
23891: CALL 83768 0 2
23895: ST_TO_ADDR
// p := [ ] ;
23896: LD_ADDR_VAR 0 11
23900: PUSH
23901: EMPTY
23902: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23903: LD_VAR 0 8
23907: PUSH
23908: LD_INT 6
23910: LESS
23911: PUSH
23912: LD_VAR 0 9
23916: PUSH
23917: LD_INT 6
23919: GREATER
23920: AND
23921: IFFALSE 24002
// begin for i = 1 to 6 - sci do
23923: LD_ADDR_VAR 0 3
23927: PUSH
23928: DOUBLE
23929: LD_INT 1
23931: DEC
23932: ST_TO_ADDR
23933: LD_INT 6
23935: PUSH
23936: LD_VAR 0 8
23940: MINUS
23941: PUSH
23942: FOR_TO
23943: IFFALSE 23998
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23945: LD_ADDR_VAR 0 11
23949: PUSH
23950: LD_VAR 0 11
23954: PPUSH
23955: LD_VAR 0 11
23959: PUSH
23960: LD_INT 1
23962: PLUS
23963: PPUSH
23964: LD_VAR 0 9
23968: PUSH
23969: LD_INT 1
23971: ARRAY
23972: PPUSH
23973: CALL_OW 2
23977: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23978: LD_ADDR_VAR 0 9
23982: PUSH
23983: LD_VAR 0 9
23987: PPUSH
23988: LD_INT 1
23990: PPUSH
23991: CALL_OW 3
23995: ST_TO_ADDR
// end ;
23996: GO 23942
23998: POP
23999: POP
// end else
24000: GO 24022
// if sort then
24002: LD_VAR 0 9
24006: IFFALSE 24022
// p := sort [ 1 ] ;
24008: LD_ADDR_VAR 0 11
24012: PUSH
24013: LD_VAR 0 9
24017: PUSH
24018: LD_INT 1
24020: ARRAY
24021: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24022: LD_ADDR_VAR 0 2
24026: PUSH
24027: LD_INT 0
24029: PUSH
24030: LD_INT 0
24032: PUSH
24033: LD_INT 0
24035: PUSH
24036: LD_VAR 0 11
24040: PUSH
24041: EMPTY
24042: LIST
24043: LIST
24044: LIST
24045: LIST
24046: ST_TO_ADDR
// exit ;
24047: GO 26268
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24049: LD_EXP 77
24053: PUSH
24054: LD_EXP 76
24058: PUSH
24059: LD_VAR 0 1
24063: ARRAY
24064: ARRAY
24065: PUSH
24066: LD_EXP 50
24070: PUSH
24071: LD_VAR 0 1
24075: ARRAY
24076: PPUSH
24077: LD_INT 2
24079: PUSH
24080: LD_INT 30
24082: PUSH
24083: LD_INT 6
24085: PUSH
24086: EMPTY
24087: LIST
24088: LIST
24089: PUSH
24090: LD_INT 30
24092: PUSH
24093: LD_INT 7
24095: PUSH
24096: EMPTY
24097: LIST
24098: LIST
24099: PUSH
24100: LD_INT 30
24102: PUSH
24103: LD_INT 8
24105: PUSH
24106: EMPTY
24107: LIST
24108: LIST
24109: PUSH
24110: EMPTY
24111: LIST
24112: LIST
24113: LIST
24114: LIST
24115: PPUSH
24116: CALL_OW 72
24120: AND
24121: PUSH
24122: LD_EXP 50
24126: PUSH
24127: LD_VAR 0 1
24131: ARRAY
24132: PPUSH
24133: LD_INT 30
24135: PUSH
24136: LD_INT 3
24138: PUSH
24139: EMPTY
24140: LIST
24141: LIST
24142: PPUSH
24143: CALL_OW 72
24147: AND
24148: IFFALSE 24882
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24150: LD_ADDR_EXP 92
24154: PUSH
24155: LD_EXP 92
24159: PPUSH
24160: LD_VAR 0 1
24164: PPUSH
24165: LD_INT 3
24167: PPUSH
24168: CALL_OW 1
24172: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24173: LD_ADDR_VAR 0 2
24177: PUSH
24178: LD_INT 0
24180: PUSH
24181: LD_INT 0
24183: PUSH
24184: LD_INT 0
24186: PUSH
24187: LD_INT 0
24189: PUSH
24190: EMPTY
24191: LIST
24192: LIST
24193: LIST
24194: LIST
24195: ST_TO_ADDR
// if not eng then
24196: LD_VAR 0 6
24200: NOT
24201: IFFALSE 24264
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24203: LD_ADDR_VAR 0 11
24207: PUSH
24208: LD_VAR 0 4
24212: PPUSH
24213: LD_INT 2
24215: PPUSH
24216: CALL 83768 0 2
24220: PUSH
24221: LD_INT 1
24223: ARRAY
24224: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24225: LD_ADDR_VAR 0 2
24229: PUSH
24230: LD_VAR 0 2
24234: PPUSH
24235: LD_INT 2
24237: PPUSH
24238: LD_VAR 0 11
24242: PPUSH
24243: CALL_OW 1
24247: ST_TO_ADDR
// tmp := tmp diff p ;
24248: LD_ADDR_VAR 0 4
24252: PUSH
24253: LD_VAR 0 4
24257: PUSH
24258: LD_VAR 0 11
24262: DIFF
24263: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24264: LD_VAR 0 4
24268: PUSH
24269: LD_VAR 0 8
24273: PUSH
24274: LD_INT 6
24276: LESS
24277: AND
24278: IFFALSE 24466
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24280: LD_ADDR_VAR 0 9
24284: PUSH
24285: LD_VAR 0 4
24289: PUSH
24290: LD_VAR 0 8
24294: PUSH
24295: LD_VAR 0 7
24299: UNION
24300: DIFF
24301: PPUSH
24302: LD_INT 4
24304: PPUSH
24305: CALL 83768 0 2
24309: ST_TO_ADDR
// p := [ ] ;
24310: LD_ADDR_VAR 0 11
24314: PUSH
24315: EMPTY
24316: ST_TO_ADDR
// if sort then
24317: LD_VAR 0 9
24321: IFFALSE 24437
// for i = 1 to 6 - sci do
24323: LD_ADDR_VAR 0 3
24327: PUSH
24328: DOUBLE
24329: LD_INT 1
24331: DEC
24332: ST_TO_ADDR
24333: LD_INT 6
24335: PUSH
24336: LD_VAR 0 8
24340: MINUS
24341: PUSH
24342: FOR_TO
24343: IFFALSE 24435
// begin if i = sort then
24345: LD_VAR 0 3
24349: PUSH
24350: LD_VAR 0 9
24354: EQUAL
24355: IFFALSE 24359
// break ;
24357: GO 24435
// if GetClass ( i ) = 4 then
24359: LD_VAR 0 3
24363: PPUSH
24364: CALL_OW 257
24368: PUSH
24369: LD_INT 4
24371: EQUAL
24372: IFFALSE 24376
// continue ;
24374: GO 24342
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24376: LD_ADDR_VAR 0 11
24380: PUSH
24381: LD_VAR 0 11
24385: PPUSH
24386: LD_VAR 0 11
24390: PUSH
24391: LD_INT 1
24393: PLUS
24394: PPUSH
24395: LD_VAR 0 9
24399: PUSH
24400: LD_VAR 0 3
24404: ARRAY
24405: PPUSH
24406: CALL_OW 2
24410: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24411: LD_ADDR_VAR 0 4
24415: PUSH
24416: LD_VAR 0 4
24420: PUSH
24421: LD_VAR 0 9
24425: PUSH
24426: LD_VAR 0 3
24430: ARRAY
24431: DIFF
24432: ST_TO_ADDR
// end ;
24433: GO 24342
24435: POP
24436: POP
// if p then
24437: LD_VAR 0 11
24441: IFFALSE 24466
// result := Replace ( result , 4 , p ) ;
24443: LD_ADDR_VAR 0 2
24447: PUSH
24448: LD_VAR 0 2
24452: PPUSH
24453: LD_INT 4
24455: PPUSH
24456: LD_VAR 0 11
24460: PPUSH
24461: CALL_OW 1
24465: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24466: LD_VAR 0 4
24470: PUSH
24471: LD_VAR 0 7
24475: PUSH
24476: LD_INT 6
24478: LESS
24479: AND
24480: IFFALSE 24668
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24482: LD_ADDR_VAR 0 9
24486: PUSH
24487: LD_VAR 0 4
24491: PUSH
24492: LD_VAR 0 8
24496: PUSH
24497: LD_VAR 0 7
24501: UNION
24502: DIFF
24503: PPUSH
24504: LD_INT 3
24506: PPUSH
24507: CALL 83768 0 2
24511: ST_TO_ADDR
// p := [ ] ;
24512: LD_ADDR_VAR 0 11
24516: PUSH
24517: EMPTY
24518: ST_TO_ADDR
// if sort then
24519: LD_VAR 0 9
24523: IFFALSE 24639
// for i = 1 to 6 - mech do
24525: LD_ADDR_VAR 0 3
24529: PUSH
24530: DOUBLE
24531: LD_INT 1
24533: DEC
24534: ST_TO_ADDR
24535: LD_INT 6
24537: PUSH
24538: LD_VAR 0 7
24542: MINUS
24543: PUSH
24544: FOR_TO
24545: IFFALSE 24637
// begin if i = sort then
24547: LD_VAR 0 3
24551: PUSH
24552: LD_VAR 0 9
24556: EQUAL
24557: IFFALSE 24561
// break ;
24559: GO 24637
// if GetClass ( i ) = 3 then
24561: LD_VAR 0 3
24565: PPUSH
24566: CALL_OW 257
24570: PUSH
24571: LD_INT 3
24573: EQUAL
24574: IFFALSE 24578
// continue ;
24576: GO 24544
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24578: LD_ADDR_VAR 0 11
24582: PUSH
24583: LD_VAR 0 11
24587: PPUSH
24588: LD_VAR 0 11
24592: PUSH
24593: LD_INT 1
24595: PLUS
24596: PPUSH
24597: LD_VAR 0 9
24601: PUSH
24602: LD_VAR 0 3
24606: ARRAY
24607: PPUSH
24608: CALL_OW 2
24612: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24613: LD_ADDR_VAR 0 4
24617: PUSH
24618: LD_VAR 0 4
24622: PUSH
24623: LD_VAR 0 9
24627: PUSH
24628: LD_VAR 0 3
24632: ARRAY
24633: DIFF
24634: ST_TO_ADDR
// end ;
24635: GO 24544
24637: POP
24638: POP
// if p then
24639: LD_VAR 0 11
24643: IFFALSE 24668
// result := Replace ( result , 3 , p ) ;
24645: LD_ADDR_VAR 0 2
24649: PUSH
24650: LD_VAR 0 2
24654: PPUSH
24655: LD_INT 3
24657: PPUSH
24658: LD_VAR 0 11
24662: PPUSH
24663: CALL_OW 1
24667: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24668: LD_VAR 0 4
24672: PUSH
24673: LD_INT 6
24675: GREATER
24676: PUSH
24677: LD_VAR 0 6
24681: PUSH
24682: LD_INT 6
24684: LESS
24685: AND
24686: IFFALSE 24880
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24688: LD_ADDR_VAR 0 9
24692: PUSH
24693: LD_VAR 0 4
24697: PUSH
24698: LD_VAR 0 8
24702: PUSH
24703: LD_VAR 0 7
24707: UNION
24708: PUSH
24709: LD_VAR 0 6
24713: UNION
24714: DIFF
24715: PPUSH
24716: LD_INT 2
24718: PPUSH
24719: CALL 83768 0 2
24723: ST_TO_ADDR
// p := [ ] ;
24724: LD_ADDR_VAR 0 11
24728: PUSH
24729: EMPTY
24730: ST_TO_ADDR
// if sort then
24731: LD_VAR 0 9
24735: IFFALSE 24851
// for i = 1 to 6 - eng do
24737: LD_ADDR_VAR 0 3
24741: PUSH
24742: DOUBLE
24743: LD_INT 1
24745: DEC
24746: ST_TO_ADDR
24747: LD_INT 6
24749: PUSH
24750: LD_VAR 0 6
24754: MINUS
24755: PUSH
24756: FOR_TO
24757: IFFALSE 24849
// begin if i = sort then
24759: LD_VAR 0 3
24763: PUSH
24764: LD_VAR 0 9
24768: EQUAL
24769: IFFALSE 24773
// break ;
24771: GO 24849
// if GetClass ( i ) = 2 then
24773: LD_VAR 0 3
24777: PPUSH
24778: CALL_OW 257
24782: PUSH
24783: LD_INT 2
24785: EQUAL
24786: IFFALSE 24790
// continue ;
24788: GO 24756
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24790: LD_ADDR_VAR 0 11
24794: PUSH
24795: LD_VAR 0 11
24799: PPUSH
24800: LD_VAR 0 11
24804: PUSH
24805: LD_INT 1
24807: PLUS
24808: PPUSH
24809: LD_VAR 0 9
24813: PUSH
24814: LD_VAR 0 3
24818: ARRAY
24819: PPUSH
24820: CALL_OW 2
24824: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24825: LD_ADDR_VAR 0 4
24829: PUSH
24830: LD_VAR 0 4
24834: PUSH
24835: LD_VAR 0 9
24839: PUSH
24840: LD_VAR 0 3
24844: ARRAY
24845: DIFF
24846: ST_TO_ADDR
// end ;
24847: GO 24756
24849: POP
24850: POP
// if p then
24851: LD_VAR 0 11
24855: IFFALSE 24880
// result := Replace ( result , 2 , p ) ;
24857: LD_ADDR_VAR 0 2
24861: PUSH
24862: LD_VAR 0 2
24866: PPUSH
24867: LD_INT 2
24869: PPUSH
24870: LD_VAR 0 11
24874: PPUSH
24875: CALL_OW 1
24879: ST_TO_ADDR
// end ; exit ;
24880: GO 26268
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24882: LD_EXP 77
24886: PUSH
24887: LD_EXP 76
24891: PUSH
24892: LD_VAR 0 1
24896: ARRAY
24897: ARRAY
24898: NOT
24899: PUSH
24900: LD_EXP 50
24904: PUSH
24905: LD_VAR 0 1
24909: ARRAY
24910: PPUSH
24911: LD_INT 30
24913: PUSH
24914: LD_INT 3
24916: PUSH
24917: EMPTY
24918: LIST
24919: LIST
24920: PPUSH
24921: CALL_OW 72
24925: AND
24926: PUSH
24927: LD_EXP 55
24931: PUSH
24932: LD_VAR 0 1
24936: ARRAY
24937: AND
24938: IFFALSE 25546
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24940: LD_ADDR_EXP 92
24944: PUSH
24945: LD_EXP 92
24949: PPUSH
24950: LD_VAR 0 1
24954: PPUSH
24955: LD_INT 5
24957: PPUSH
24958: CALL_OW 1
24962: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24963: LD_ADDR_VAR 0 2
24967: PUSH
24968: LD_INT 0
24970: PUSH
24971: LD_INT 0
24973: PUSH
24974: LD_INT 0
24976: PUSH
24977: LD_INT 0
24979: PUSH
24980: EMPTY
24981: LIST
24982: LIST
24983: LIST
24984: LIST
24985: ST_TO_ADDR
// if sci > 1 then
24986: LD_VAR 0 8
24990: PUSH
24991: LD_INT 1
24993: GREATER
24994: IFFALSE 25022
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24996: LD_ADDR_VAR 0 4
25000: PUSH
25001: LD_VAR 0 4
25005: PUSH
25006: LD_VAR 0 8
25010: PUSH
25011: LD_VAR 0 8
25015: PUSH
25016: LD_INT 1
25018: ARRAY
25019: DIFF
25020: DIFF
25021: ST_TO_ADDR
// if tmp and not sci then
25022: LD_VAR 0 4
25026: PUSH
25027: LD_VAR 0 8
25031: NOT
25032: AND
25033: IFFALSE 25102
// begin sort := SortBySkill ( tmp , 4 ) ;
25035: LD_ADDR_VAR 0 9
25039: PUSH
25040: LD_VAR 0 4
25044: PPUSH
25045: LD_INT 4
25047: PPUSH
25048: CALL 83768 0 2
25052: ST_TO_ADDR
// if sort then
25053: LD_VAR 0 9
25057: IFFALSE 25073
// p := sort [ 1 ] ;
25059: LD_ADDR_VAR 0 11
25063: PUSH
25064: LD_VAR 0 9
25068: PUSH
25069: LD_INT 1
25071: ARRAY
25072: ST_TO_ADDR
// if p then
25073: LD_VAR 0 11
25077: IFFALSE 25102
// result := Replace ( result , 4 , p ) ;
25079: LD_ADDR_VAR 0 2
25083: PUSH
25084: LD_VAR 0 2
25088: PPUSH
25089: LD_INT 4
25091: PPUSH
25092: LD_VAR 0 11
25096: PPUSH
25097: CALL_OW 1
25101: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25102: LD_ADDR_VAR 0 4
25106: PUSH
25107: LD_VAR 0 4
25111: PUSH
25112: LD_VAR 0 7
25116: DIFF
25117: ST_TO_ADDR
// if tmp and mech < 6 then
25118: LD_VAR 0 4
25122: PUSH
25123: LD_VAR 0 7
25127: PUSH
25128: LD_INT 6
25130: LESS
25131: AND
25132: IFFALSE 25320
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25134: LD_ADDR_VAR 0 9
25138: PUSH
25139: LD_VAR 0 4
25143: PUSH
25144: LD_VAR 0 8
25148: PUSH
25149: LD_VAR 0 7
25153: UNION
25154: DIFF
25155: PPUSH
25156: LD_INT 3
25158: PPUSH
25159: CALL 83768 0 2
25163: ST_TO_ADDR
// p := [ ] ;
25164: LD_ADDR_VAR 0 11
25168: PUSH
25169: EMPTY
25170: ST_TO_ADDR
// if sort then
25171: LD_VAR 0 9
25175: IFFALSE 25291
// for i = 1 to 6 - mech do
25177: LD_ADDR_VAR 0 3
25181: PUSH
25182: DOUBLE
25183: LD_INT 1
25185: DEC
25186: ST_TO_ADDR
25187: LD_INT 6
25189: PUSH
25190: LD_VAR 0 7
25194: MINUS
25195: PUSH
25196: FOR_TO
25197: IFFALSE 25289
// begin if i = sort then
25199: LD_VAR 0 3
25203: PUSH
25204: LD_VAR 0 9
25208: EQUAL
25209: IFFALSE 25213
// break ;
25211: GO 25289
// if GetClass ( i ) = 3 then
25213: LD_VAR 0 3
25217: PPUSH
25218: CALL_OW 257
25222: PUSH
25223: LD_INT 3
25225: EQUAL
25226: IFFALSE 25230
// continue ;
25228: GO 25196
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25230: LD_ADDR_VAR 0 11
25234: PUSH
25235: LD_VAR 0 11
25239: PPUSH
25240: LD_VAR 0 11
25244: PUSH
25245: LD_INT 1
25247: PLUS
25248: PPUSH
25249: LD_VAR 0 9
25253: PUSH
25254: LD_VAR 0 3
25258: ARRAY
25259: PPUSH
25260: CALL_OW 2
25264: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25265: LD_ADDR_VAR 0 4
25269: PUSH
25270: LD_VAR 0 4
25274: PUSH
25275: LD_VAR 0 9
25279: PUSH
25280: LD_VAR 0 3
25284: ARRAY
25285: DIFF
25286: ST_TO_ADDR
// end ;
25287: GO 25196
25289: POP
25290: POP
// if p then
25291: LD_VAR 0 11
25295: IFFALSE 25320
// result := Replace ( result , 3 , p ) ;
25297: LD_ADDR_VAR 0 2
25301: PUSH
25302: LD_VAR 0 2
25306: PPUSH
25307: LD_INT 3
25309: PPUSH
25310: LD_VAR 0 11
25314: PPUSH
25315: CALL_OW 1
25319: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25320: LD_ADDR_VAR 0 4
25324: PUSH
25325: LD_VAR 0 4
25329: PUSH
25330: LD_VAR 0 6
25334: DIFF
25335: ST_TO_ADDR
// if tmp and eng < 6 then
25336: LD_VAR 0 4
25340: PUSH
25341: LD_VAR 0 6
25345: PUSH
25346: LD_INT 6
25348: LESS
25349: AND
25350: IFFALSE 25544
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25352: LD_ADDR_VAR 0 9
25356: PUSH
25357: LD_VAR 0 4
25361: PUSH
25362: LD_VAR 0 8
25366: PUSH
25367: LD_VAR 0 7
25371: UNION
25372: PUSH
25373: LD_VAR 0 6
25377: UNION
25378: DIFF
25379: PPUSH
25380: LD_INT 2
25382: PPUSH
25383: CALL 83768 0 2
25387: ST_TO_ADDR
// p := [ ] ;
25388: LD_ADDR_VAR 0 11
25392: PUSH
25393: EMPTY
25394: ST_TO_ADDR
// if sort then
25395: LD_VAR 0 9
25399: IFFALSE 25515
// for i = 1 to 6 - eng do
25401: LD_ADDR_VAR 0 3
25405: PUSH
25406: DOUBLE
25407: LD_INT 1
25409: DEC
25410: ST_TO_ADDR
25411: LD_INT 6
25413: PUSH
25414: LD_VAR 0 6
25418: MINUS
25419: PUSH
25420: FOR_TO
25421: IFFALSE 25513
// begin if i = sort then
25423: LD_VAR 0 3
25427: PUSH
25428: LD_VAR 0 9
25432: EQUAL
25433: IFFALSE 25437
// break ;
25435: GO 25513
// if GetClass ( i ) = 2 then
25437: LD_VAR 0 3
25441: PPUSH
25442: CALL_OW 257
25446: PUSH
25447: LD_INT 2
25449: EQUAL
25450: IFFALSE 25454
// continue ;
25452: GO 25420
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25454: LD_ADDR_VAR 0 11
25458: PUSH
25459: LD_VAR 0 11
25463: PPUSH
25464: LD_VAR 0 11
25468: PUSH
25469: LD_INT 1
25471: PLUS
25472: PPUSH
25473: LD_VAR 0 9
25477: PUSH
25478: LD_VAR 0 3
25482: ARRAY
25483: PPUSH
25484: CALL_OW 2
25488: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25489: LD_ADDR_VAR 0 4
25493: PUSH
25494: LD_VAR 0 4
25498: PUSH
25499: LD_VAR 0 9
25503: PUSH
25504: LD_VAR 0 3
25508: ARRAY
25509: DIFF
25510: ST_TO_ADDR
// end ;
25511: GO 25420
25513: POP
25514: POP
// if p then
25515: LD_VAR 0 11
25519: IFFALSE 25544
// result := Replace ( result , 2 , p ) ;
25521: LD_ADDR_VAR 0 2
25525: PUSH
25526: LD_VAR 0 2
25530: PPUSH
25531: LD_INT 2
25533: PPUSH
25534: LD_VAR 0 11
25538: PPUSH
25539: CALL_OW 1
25543: ST_TO_ADDR
// end ; exit ;
25544: GO 26268
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25546: LD_EXP 77
25550: PUSH
25551: LD_EXP 76
25555: PUSH
25556: LD_VAR 0 1
25560: ARRAY
25561: ARRAY
25562: NOT
25563: PUSH
25564: LD_EXP 50
25568: PUSH
25569: LD_VAR 0 1
25573: ARRAY
25574: PPUSH
25575: LD_INT 30
25577: PUSH
25578: LD_INT 3
25580: PUSH
25581: EMPTY
25582: LIST
25583: LIST
25584: PPUSH
25585: CALL_OW 72
25589: AND
25590: PUSH
25591: LD_EXP 55
25595: PUSH
25596: LD_VAR 0 1
25600: ARRAY
25601: NOT
25602: AND
25603: IFFALSE 26268
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25605: LD_ADDR_EXP 92
25609: PUSH
25610: LD_EXP 92
25614: PPUSH
25615: LD_VAR 0 1
25619: PPUSH
25620: LD_INT 6
25622: PPUSH
25623: CALL_OW 1
25627: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25628: LD_ADDR_VAR 0 2
25632: PUSH
25633: LD_INT 0
25635: PUSH
25636: LD_INT 0
25638: PUSH
25639: LD_INT 0
25641: PUSH
25642: LD_INT 0
25644: PUSH
25645: EMPTY
25646: LIST
25647: LIST
25648: LIST
25649: LIST
25650: ST_TO_ADDR
// if sci >= 1 then
25651: LD_VAR 0 8
25655: PUSH
25656: LD_INT 1
25658: GREATEREQUAL
25659: IFFALSE 25681
// tmp := tmp diff sci [ 1 ] ;
25661: LD_ADDR_VAR 0 4
25665: PUSH
25666: LD_VAR 0 4
25670: PUSH
25671: LD_VAR 0 8
25675: PUSH
25676: LD_INT 1
25678: ARRAY
25679: DIFF
25680: ST_TO_ADDR
// if tmp and not sci then
25681: LD_VAR 0 4
25685: PUSH
25686: LD_VAR 0 8
25690: NOT
25691: AND
25692: IFFALSE 25761
// begin sort := SortBySkill ( tmp , 4 ) ;
25694: LD_ADDR_VAR 0 9
25698: PUSH
25699: LD_VAR 0 4
25703: PPUSH
25704: LD_INT 4
25706: PPUSH
25707: CALL 83768 0 2
25711: ST_TO_ADDR
// if sort then
25712: LD_VAR 0 9
25716: IFFALSE 25732
// p := sort [ 1 ] ;
25718: LD_ADDR_VAR 0 11
25722: PUSH
25723: LD_VAR 0 9
25727: PUSH
25728: LD_INT 1
25730: ARRAY
25731: ST_TO_ADDR
// if p then
25732: LD_VAR 0 11
25736: IFFALSE 25761
// result := Replace ( result , 4 , p ) ;
25738: LD_ADDR_VAR 0 2
25742: PUSH
25743: LD_VAR 0 2
25747: PPUSH
25748: LD_INT 4
25750: PPUSH
25751: LD_VAR 0 11
25755: PPUSH
25756: CALL_OW 1
25760: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25761: LD_ADDR_VAR 0 4
25765: PUSH
25766: LD_VAR 0 4
25770: PUSH
25771: LD_VAR 0 7
25775: DIFF
25776: ST_TO_ADDR
// if tmp and mech < 6 then
25777: LD_VAR 0 4
25781: PUSH
25782: LD_VAR 0 7
25786: PUSH
25787: LD_INT 6
25789: LESS
25790: AND
25791: IFFALSE 25973
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25793: LD_ADDR_VAR 0 9
25797: PUSH
25798: LD_VAR 0 4
25802: PUSH
25803: LD_VAR 0 7
25807: DIFF
25808: PPUSH
25809: LD_INT 3
25811: PPUSH
25812: CALL 83768 0 2
25816: ST_TO_ADDR
// p := [ ] ;
25817: LD_ADDR_VAR 0 11
25821: PUSH
25822: EMPTY
25823: ST_TO_ADDR
// if sort then
25824: LD_VAR 0 9
25828: IFFALSE 25944
// for i = 1 to 6 - mech do
25830: LD_ADDR_VAR 0 3
25834: PUSH
25835: DOUBLE
25836: LD_INT 1
25838: DEC
25839: ST_TO_ADDR
25840: LD_INT 6
25842: PUSH
25843: LD_VAR 0 7
25847: MINUS
25848: PUSH
25849: FOR_TO
25850: IFFALSE 25942
// begin if i = sort then
25852: LD_VAR 0 3
25856: PUSH
25857: LD_VAR 0 9
25861: EQUAL
25862: IFFALSE 25866
// break ;
25864: GO 25942
// if GetClass ( i ) = 3 then
25866: LD_VAR 0 3
25870: PPUSH
25871: CALL_OW 257
25875: PUSH
25876: LD_INT 3
25878: EQUAL
25879: IFFALSE 25883
// continue ;
25881: GO 25849
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25883: LD_ADDR_VAR 0 11
25887: PUSH
25888: LD_VAR 0 11
25892: PPUSH
25893: LD_VAR 0 11
25897: PUSH
25898: LD_INT 1
25900: PLUS
25901: PPUSH
25902: LD_VAR 0 9
25906: PUSH
25907: LD_VAR 0 3
25911: ARRAY
25912: PPUSH
25913: CALL_OW 2
25917: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25918: LD_ADDR_VAR 0 4
25922: PUSH
25923: LD_VAR 0 4
25927: PUSH
25928: LD_VAR 0 9
25932: PUSH
25933: LD_VAR 0 3
25937: ARRAY
25938: DIFF
25939: ST_TO_ADDR
// end ;
25940: GO 25849
25942: POP
25943: POP
// if p then
25944: LD_VAR 0 11
25948: IFFALSE 25973
// result := Replace ( result , 3 , p ) ;
25950: LD_ADDR_VAR 0 2
25954: PUSH
25955: LD_VAR 0 2
25959: PPUSH
25960: LD_INT 3
25962: PPUSH
25963: LD_VAR 0 11
25967: PPUSH
25968: CALL_OW 1
25972: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25973: LD_ADDR_VAR 0 4
25977: PUSH
25978: LD_VAR 0 4
25982: PUSH
25983: LD_VAR 0 6
25987: DIFF
25988: ST_TO_ADDR
// if tmp and eng < 4 then
25989: LD_VAR 0 4
25993: PUSH
25994: LD_VAR 0 6
25998: PUSH
25999: LD_INT 4
26001: LESS
26002: AND
26003: IFFALSE 26193
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26005: LD_ADDR_VAR 0 9
26009: PUSH
26010: LD_VAR 0 4
26014: PUSH
26015: LD_VAR 0 7
26019: PUSH
26020: LD_VAR 0 6
26024: UNION
26025: DIFF
26026: PPUSH
26027: LD_INT 2
26029: PPUSH
26030: CALL 83768 0 2
26034: ST_TO_ADDR
// p := [ ] ;
26035: LD_ADDR_VAR 0 11
26039: PUSH
26040: EMPTY
26041: ST_TO_ADDR
// if sort then
26042: LD_VAR 0 9
26046: IFFALSE 26162
// for i = 1 to 4 - eng do
26048: LD_ADDR_VAR 0 3
26052: PUSH
26053: DOUBLE
26054: LD_INT 1
26056: DEC
26057: ST_TO_ADDR
26058: LD_INT 4
26060: PUSH
26061: LD_VAR 0 6
26065: MINUS
26066: PUSH
26067: FOR_TO
26068: IFFALSE 26160
// begin if i = sort then
26070: LD_VAR 0 3
26074: PUSH
26075: LD_VAR 0 9
26079: EQUAL
26080: IFFALSE 26084
// break ;
26082: GO 26160
// if GetClass ( i ) = 2 then
26084: LD_VAR 0 3
26088: PPUSH
26089: CALL_OW 257
26093: PUSH
26094: LD_INT 2
26096: EQUAL
26097: IFFALSE 26101
// continue ;
26099: GO 26067
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26101: LD_ADDR_VAR 0 11
26105: PUSH
26106: LD_VAR 0 11
26110: PPUSH
26111: LD_VAR 0 11
26115: PUSH
26116: LD_INT 1
26118: PLUS
26119: PPUSH
26120: LD_VAR 0 9
26124: PUSH
26125: LD_VAR 0 3
26129: ARRAY
26130: PPUSH
26131: CALL_OW 2
26135: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26136: LD_ADDR_VAR 0 4
26140: PUSH
26141: LD_VAR 0 4
26145: PUSH
26146: LD_VAR 0 9
26150: PUSH
26151: LD_VAR 0 3
26155: ARRAY
26156: DIFF
26157: ST_TO_ADDR
// end ;
26158: GO 26067
26160: POP
26161: POP
// if p then
26162: LD_VAR 0 11
26166: IFFALSE 26191
// result := Replace ( result , 2 , p ) ;
26168: LD_ADDR_VAR 0 2
26172: PUSH
26173: LD_VAR 0 2
26177: PPUSH
26178: LD_INT 2
26180: PPUSH
26181: LD_VAR 0 11
26185: PPUSH
26186: CALL_OW 1
26190: ST_TO_ADDR
// end else
26191: GO 26237
// for i = eng downto 5 do
26193: LD_ADDR_VAR 0 3
26197: PUSH
26198: DOUBLE
26199: LD_VAR 0 6
26203: INC
26204: ST_TO_ADDR
26205: LD_INT 5
26207: PUSH
26208: FOR_DOWNTO
26209: IFFALSE 26235
// tmp := tmp union eng [ i ] ;
26211: LD_ADDR_VAR 0 4
26215: PUSH
26216: LD_VAR 0 4
26220: PUSH
26221: LD_VAR 0 6
26225: PUSH
26226: LD_VAR 0 3
26230: ARRAY
26231: UNION
26232: ST_TO_ADDR
26233: GO 26208
26235: POP
26236: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26237: LD_ADDR_VAR 0 2
26241: PUSH
26242: LD_VAR 0 2
26246: PPUSH
26247: LD_INT 1
26249: PPUSH
26250: LD_VAR 0 4
26254: PUSH
26255: LD_VAR 0 5
26259: DIFF
26260: PPUSH
26261: CALL_OW 1
26265: ST_TO_ADDR
// exit ;
26266: GO 26268
// end ; end ;
26268: LD_VAR 0 2
26272: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26273: LD_INT 0
26275: PPUSH
26276: PPUSH
26277: PPUSH
// if not mc_bases then
26278: LD_EXP 50
26282: NOT
26283: IFFALSE 26287
// exit ;
26285: GO 26429
// for i = 1 to mc_bases do
26287: LD_ADDR_VAR 0 2
26291: PUSH
26292: DOUBLE
26293: LD_INT 1
26295: DEC
26296: ST_TO_ADDR
26297: LD_EXP 50
26301: PUSH
26302: FOR_TO
26303: IFFALSE 26420
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26305: LD_ADDR_VAR 0 3
26309: PUSH
26310: LD_EXP 50
26314: PUSH
26315: LD_VAR 0 2
26319: ARRAY
26320: PPUSH
26321: LD_INT 21
26323: PUSH
26324: LD_INT 3
26326: PUSH
26327: EMPTY
26328: LIST
26329: LIST
26330: PUSH
26331: LD_INT 3
26333: PUSH
26334: LD_INT 2
26336: PUSH
26337: LD_INT 30
26339: PUSH
26340: LD_INT 29
26342: PUSH
26343: EMPTY
26344: LIST
26345: LIST
26346: PUSH
26347: LD_INT 30
26349: PUSH
26350: LD_INT 30
26352: PUSH
26353: EMPTY
26354: LIST
26355: LIST
26356: PUSH
26357: EMPTY
26358: LIST
26359: LIST
26360: LIST
26361: PUSH
26362: EMPTY
26363: LIST
26364: LIST
26365: PUSH
26366: LD_INT 3
26368: PUSH
26369: LD_INT 24
26371: PUSH
26372: LD_INT 1000
26374: PUSH
26375: EMPTY
26376: LIST
26377: LIST
26378: PUSH
26379: EMPTY
26380: LIST
26381: LIST
26382: PUSH
26383: EMPTY
26384: LIST
26385: LIST
26386: LIST
26387: PPUSH
26388: CALL_OW 72
26392: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26393: LD_ADDR_EXP 51
26397: PUSH
26398: LD_EXP 51
26402: PPUSH
26403: LD_VAR 0 2
26407: PPUSH
26408: LD_VAR 0 3
26412: PPUSH
26413: CALL_OW 1
26417: ST_TO_ADDR
// end ;
26418: GO 26302
26420: POP
26421: POP
// RaiseSailEvent ( 101 ) ;
26422: LD_INT 101
26424: PPUSH
26425: CALL_OW 427
// end ;
26429: LD_VAR 0 1
26433: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26434: LD_INT 0
26436: PPUSH
26437: PPUSH
26438: PPUSH
26439: PPUSH
26440: PPUSH
26441: PPUSH
26442: PPUSH
// if not mc_bases then
26443: LD_EXP 50
26447: NOT
26448: IFFALSE 26452
// exit ;
26450: GO 27014
// for i = 1 to mc_bases do
26452: LD_ADDR_VAR 0 2
26456: PUSH
26457: DOUBLE
26458: LD_INT 1
26460: DEC
26461: ST_TO_ADDR
26462: LD_EXP 50
26466: PUSH
26467: FOR_TO
26468: IFFALSE 27005
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26470: LD_ADDR_VAR 0 5
26474: PUSH
26475: LD_EXP 50
26479: PUSH
26480: LD_VAR 0 2
26484: ARRAY
26485: PUSH
26486: LD_EXP 79
26490: PUSH
26491: LD_VAR 0 2
26495: ARRAY
26496: UNION
26497: PPUSH
26498: LD_INT 21
26500: PUSH
26501: LD_INT 1
26503: PUSH
26504: EMPTY
26505: LIST
26506: LIST
26507: PUSH
26508: LD_INT 1
26510: PUSH
26511: LD_INT 3
26513: PUSH
26514: LD_INT 54
26516: PUSH
26517: EMPTY
26518: LIST
26519: PUSH
26520: EMPTY
26521: LIST
26522: LIST
26523: PUSH
26524: LD_INT 3
26526: PUSH
26527: LD_INT 24
26529: PUSH
26530: LD_INT 1000
26532: PUSH
26533: EMPTY
26534: LIST
26535: LIST
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: PUSH
26541: EMPTY
26542: LIST
26543: LIST
26544: LIST
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: PPUSH
26550: CALL_OW 72
26554: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26555: LD_ADDR_VAR 0 6
26559: PUSH
26560: LD_EXP 50
26564: PUSH
26565: LD_VAR 0 2
26569: ARRAY
26570: PPUSH
26571: LD_INT 21
26573: PUSH
26574: LD_INT 1
26576: PUSH
26577: EMPTY
26578: LIST
26579: LIST
26580: PUSH
26581: LD_INT 1
26583: PUSH
26584: LD_INT 3
26586: PUSH
26587: LD_INT 54
26589: PUSH
26590: EMPTY
26591: LIST
26592: PUSH
26593: EMPTY
26594: LIST
26595: LIST
26596: PUSH
26597: LD_INT 3
26599: PUSH
26600: LD_INT 24
26602: PUSH
26603: LD_INT 250
26605: PUSH
26606: EMPTY
26607: LIST
26608: LIST
26609: PUSH
26610: EMPTY
26611: LIST
26612: LIST
26613: PUSH
26614: EMPTY
26615: LIST
26616: LIST
26617: LIST
26618: PUSH
26619: EMPTY
26620: LIST
26621: LIST
26622: PPUSH
26623: CALL_OW 72
26627: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26628: LD_ADDR_VAR 0 7
26632: PUSH
26633: LD_VAR 0 5
26637: PUSH
26638: LD_VAR 0 6
26642: DIFF
26643: ST_TO_ADDR
// if not need_heal_1 then
26644: LD_VAR 0 6
26648: NOT
26649: IFFALSE 26682
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26651: LD_ADDR_EXP 53
26655: PUSH
26656: LD_EXP 53
26660: PPUSH
26661: LD_VAR 0 2
26665: PUSH
26666: LD_INT 1
26668: PUSH
26669: EMPTY
26670: LIST
26671: LIST
26672: PPUSH
26673: EMPTY
26674: PPUSH
26675: CALL 53564 0 3
26679: ST_TO_ADDR
26680: GO 26752
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26682: LD_ADDR_EXP 53
26686: PUSH
26687: LD_EXP 53
26691: PPUSH
26692: LD_VAR 0 2
26696: PUSH
26697: LD_INT 1
26699: PUSH
26700: EMPTY
26701: LIST
26702: LIST
26703: PPUSH
26704: LD_EXP 53
26708: PUSH
26709: LD_VAR 0 2
26713: ARRAY
26714: PUSH
26715: LD_INT 1
26717: ARRAY
26718: PPUSH
26719: LD_INT 3
26721: PUSH
26722: LD_INT 24
26724: PUSH
26725: LD_INT 1000
26727: PUSH
26728: EMPTY
26729: LIST
26730: LIST
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PPUSH
26736: CALL_OW 72
26740: PUSH
26741: LD_VAR 0 6
26745: UNION
26746: PPUSH
26747: CALL 53564 0 3
26751: ST_TO_ADDR
// if not need_heal_2 then
26752: LD_VAR 0 7
26756: NOT
26757: IFFALSE 26790
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26759: LD_ADDR_EXP 53
26763: PUSH
26764: LD_EXP 53
26768: PPUSH
26769: LD_VAR 0 2
26773: PUSH
26774: LD_INT 2
26776: PUSH
26777: EMPTY
26778: LIST
26779: LIST
26780: PPUSH
26781: EMPTY
26782: PPUSH
26783: CALL 53564 0 3
26787: ST_TO_ADDR
26788: GO 26822
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26790: LD_ADDR_EXP 53
26794: PUSH
26795: LD_EXP 53
26799: PPUSH
26800: LD_VAR 0 2
26804: PUSH
26805: LD_INT 2
26807: PUSH
26808: EMPTY
26809: LIST
26810: LIST
26811: PPUSH
26812: LD_VAR 0 7
26816: PPUSH
26817: CALL 53564 0 3
26821: ST_TO_ADDR
// if need_heal_2 then
26822: LD_VAR 0 7
26826: IFFALSE 26987
// for j in need_heal_2 do
26828: LD_ADDR_VAR 0 3
26832: PUSH
26833: LD_VAR 0 7
26837: PUSH
26838: FOR_IN
26839: IFFALSE 26985
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26841: LD_ADDR_VAR 0 5
26845: PUSH
26846: LD_EXP 50
26850: PUSH
26851: LD_VAR 0 2
26855: ARRAY
26856: PPUSH
26857: LD_INT 2
26859: PUSH
26860: LD_INT 30
26862: PUSH
26863: LD_INT 6
26865: PUSH
26866: EMPTY
26867: LIST
26868: LIST
26869: PUSH
26870: LD_INT 30
26872: PUSH
26873: LD_INT 7
26875: PUSH
26876: EMPTY
26877: LIST
26878: LIST
26879: PUSH
26880: LD_INT 30
26882: PUSH
26883: LD_INT 8
26885: PUSH
26886: EMPTY
26887: LIST
26888: LIST
26889: PUSH
26890: LD_INT 30
26892: PUSH
26893: LD_INT 0
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: PUSH
26900: LD_INT 30
26902: PUSH
26903: LD_INT 1
26905: PUSH
26906: EMPTY
26907: LIST
26908: LIST
26909: PUSH
26910: EMPTY
26911: LIST
26912: LIST
26913: LIST
26914: LIST
26915: LIST
26916: LIST
26917: PPUSH
26918: CALL_OW 72
26922: ST_TO_ADDR
// if tmp then
26923: LD_VAR 0 5
26927: IFFALSE 26983
// begin k := NearestUnitToUnit ( tmp , j ) ;
26929: LD_ADDR_VAR 0 4
26933: PUSH
26934: LD_VAR 0 5
26938: PPUSH
26939: LD_VAR 0 3
26943: PPUSH
26944: CALL_OW 74
26948: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26949: LD_VAR 0 3
26953: PPUSH
26954: LD_VAR 0 4
26958: PPUSH
26959: CALL_OW 296
26963: PUSH
26964: LD_INT 5
26966: GREATER
26967: IFFALSE 26983
// ComMoveToNearbyEntrance ( j , k ) ;
26969: LD_VAR 0 3
26973: PPUSH
26974: LD_VAR 0 4
26978: PPUSH
26979: CALL 86126 0 2
// end ; end ;
26983: GO 26838
26985: POP
26986: POP
// if not need_heal_1 and not need_heal_2 then
26987: LD_VAR 0 6
26991: NOT
26992: PUSH
26993: LD_VAR 0 7
26997: NOT
26998: AND
26999: IFFALSE 27003
// continue ;
27001: GO 26467
// end ;
27003: GO 26467
27005: POP
27006: POP
// RaiseSailEvent ( 102 ) ;
27007: LD_INT 102
27009: PPUSH
27010: CALL_OW 427
// end ;
27014: LD_VAR 0 1
27018: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27019: LD_INT 0
27021: PPUSH
27022: PPUSH
27023: PPUSH
27024: PPUSH
27025: PPUSH
27026: PPUSH
27027: PPUSH
27028: PPUSH
// if not mc_bases then
27029: LD_EXP 50
27033: NOT
27034: IFFALSE 27038
// exit ;
27036: GO 27921
// for i = 1 to mc_bases do
27038: LD_ADDR_VAR 0 2
27042: PUSH
27043: DOUBLE
27044: LD_INT 1
27046: DEC
27047: ST_TO_ADDR
27048: LD_EXP 50
27052: PUSH
27053: FOR_TO
27054: IFFALSE 27919
// begin if not mc_building_need_repair [ i ] then
27056: LD_EXP 51
27060: PUSH
27061: LD_VAR 0 2
27065: ARRAY
27066: NOT
27067: IFFALSE 27254
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27069: LD_ADDR_VAR 0 6
27073: PUSH
27074: LD_EXP 69
27078: PUSH
27079: LD_VAR 0 2
27083: ARRAY
27084: PPUSH
27085: LD_INT 3
27087: PUSH
27088: LD_INT 24
27090: PUSH
27091: LD_INT 1000
27093: PUSH
27094: EMPTY
27095: LIST
27096: LIST
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PUSH
27102: LD_INT 2
27104: PUSH
27105: LD_INT 34
27107: PUSH
27108: LD_INT 13
27110: PUSH
27111: EMPTY
27112: LIST
27113: LIST
27114: PUSH
27115: LD_INT 34
27117: PUSH
27118: LD_INT 52
27120: PUSH
27121: EMPTY
27122: LIST
27123: LIST
27124: PUSH
27125: LD_INT 34
27127: PUSH
27128: LD_EXP 100
27132: PUSH
27133: EMPTY
27134: LIST
27135: LIST
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: LIST
27141: LIST
27142: PUSH
27143: EMPTY
27144: LIST
27145: LIST
27146: PPUSH
27147: CALL_OW 72
27151: ST_TO_ADDR
// if cranes then
27152: LD_VAR 0 6
27156: IFFALSE 27218
// for j in cranes do
27158: LD_ADDR_VAR 0 3
27162: PUSH
27163: LD_VAR 0 6
27167: PUSH
27168: FOR_IN
27169: IFFALSE 27216
// if not IsInArea ( j , mc_parking [ i ] ) then
27171: LD_VAR 0 3
27175: PPUSH
27176: LD_EXP 74
27180: PUSH
27181: LD_VAR 0 2
27185: ARRAY
27186: PPUSH
27187: CALL_OW 308
27191: NOT
27192: IFFALSE 27214
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27194: LD_VAR 0 3
27198: PPUSH
27199: LD_EXP 74
27203: PUSH
27204: LD_VAR 0 2
27208: ARRAY
27209: PPUSH
27210: CALL_OW 113
27214: GO 27168
27216: POP
27217: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27218: LD_ADDR_EXP 52
27222: PUSH
27223: LD_EXP 52
27227: PPUSH
27228: LD_VAR 0 2
27232: PPUSH
27233: EMPTY
27234: PPUSH
27235: CALL_OW 1
27239: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27240: LD_VAR 0 2
27244: PPUSH
27245: LD_INT 101
27247: PPUSH
27248: CALL 22106 0 2
// continue ;
27252: GO 27053
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27254: LD_ADDR_EXP 56
27258: PUSH
27259: LD_EXP 56
27263: PPUSH
27264: LD_VAR 0 2
27268: PPUSH
27269: EMPTY
27270: PPUSH
27271: CALL_OW 1
27275: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27276: LD_VAR 0 2
27280: PPUSH
27281: LD_INT 103
27283: PPUSH
27284: CALL 22106 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27288: LD_ADDR_VAR 0 5
27292: PUSH
27293: LD_EXP 50
27297: PUSH
27298: LD_VAR 0 2
27302: ARRAY
27303: PUSH
27304: LD_EXP 79
27308: PUSH
27309: LD_VAR 0 2
27313: ARRAY
27314: UNION
27315: PPUSH
27316: LD_INT 2
27318: PUSH
27319: LD_INT 25
27321: PUSH
27322: LD_INT 2
27324: PUSH
27325: EMPTY
27326: LIST
27327: LIST
27328: PUSH
27329: LD_INT 25
27331: PUSH
27332: LD_INT 16
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: PUSH
27339: EMPTY
27340: LIST
27341: LIST
27342: LIST
27343: PUSH
27344: EMPTY
27345: LIST
27346: PPUSH
27347: CALL_OW 72
27351: ST_TO_ADDR
// if mc_need_heal [ i ] then
27352: LD_EXP 53
27356: PUSH
27357: LD_VAR 0 2
27361: ARRAY
27362: IFFALSE 27406
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27364: LD_ADDR_VAR 0 5
27368: PUSH
27369: LD_VAR 0 5
27373: PUSH
27374: LD_EXP 53
27378: PUSH
27379: LD_VAR 0 2
27383: ARRAY
27384: PUSH
27385: LD_INT 1
27387: ARRAY
27388: PUSH
27389: LD_EXP 53
27393: PUSH
27394: LD_VAR 0 2
27398: ARRAY
27399: PUSH
27400: LD_INT 2
27402: ARRAY
27403: UNION
27404: DIFF
27405: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27406: LD_ADDR_VAR 0 6
27410: PUSH
27411: LD_EXP 69
27415: PUSH
27416: LD_VAR 0 2
27420: ARRAY
27421: PPUSH
27422: LD_INT 2
27424: PUSH
27425: LD_INT 34
27427: PUSH
27428: LD_INT 13
27430: PUSH
27431: EMPTY
27432: LIST
27433: LIST
27434: PUSH
27435: LD_INT 34
27437: PUSH
27438: LD_INT 52
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: LD_INT 34
27447: PUSH
27448: LD_EXP 100
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: EMPTY
27458: LIST
27459: LIST
27460: LIST
27461: LIST
27462: PPUSH
27463: CALL_OW 72
27467: ST_TO_ADDR
// if cranes then
27468: LD_VAR 0 6
27472: IFFALSE 27608
// begin for j in cranes do
27474: LD_ADDR_VAR 0 3
27478: PUSH
27479: LD_VAR 0 6
27483: PUSH
27484: FOR_IN
27485: IFFALSE 27606
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27487: LD_VAR 0 3
27491: PPUSH
27492: CALL_OW 256
27496: PUSH
27497: LD_INT 1000
27499: EQUAL
27500: PUSH
27501: LD_VAR 0 3
27505: PPUSH
27506: CALL_OW 314
27510: NOT
27511: AND
27512: IFFALSE 27546
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
27514: LD_VAR 0 3
27518: PPUSH
27519: LD_EXP 51
27523: PUSH
27524: LD_VAR 0 2
27528: ARRAY
27529: PPUSH
27530: LD_VAR 0 3
27534: PPUSH
27535: CALL_OW 74
27539: PPUSH
27540: CALL_OW 130
27544: GO 27604
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27546: LD_VAR 0 3
27550: PPUSH
27551: CALL_OW 256
27555: PUSH
27556: LD_INT 500
27558: LESS
27559: PUSH
27560: LD_VAR 0 3
27564: PPUSH
27565: LD_EXP 74
27569: PUSH
27570: LD_VAR 0 2
27574: ARRAY
27575: PPUSH
27576: CALL_OW 308
27580: NOT
27581: AND
27582: IFFALSE 27604
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27584: LD_VAR 0 3
27588: PPUSH
27589: LD_EXP 74
27593: PUSH
27594: LD_VAR 0 2
27598: ARRAY
27599: PPUSH
27600: CALL_OW 113
// end ;
27604: GO 27484
27606: POP
27607: POP
// end ; if tmp > 3 then
27608: LD_VAR 0 5
27612: PUSH
27613: LD_INT 3
27615: GREATER
27616: IFFALSE 27636
// tmp := ShrinkArray ( tmp , 4 ) ;
27618: LD_ADDR_VAR 0 5
27622: PUSH
27623: LD_VAR 0 5
27627: PPUSH
27628: LD_INT 4
27630: PPUSH
27631: CALL 85574 0 2
27635: ST_TO_ADDR
// if not tmp then
27636: LD_VAR 0 5
27640: NOT
27641: IFFALSE 27645
// continue ;
27643: GO 27053
// for j in tmp do
27645: LD_ADDR_VAR 0 3
27649: PUSH
27650: LD_VAR 0 5
27654: PUSH
27655: FOR_IN
27656: IFFALSE 27915
// begin if IsInUnit ( j ) then
27658: LD_VAR 0 3
27662: PPUSH
27663: CALL_OW 310
27667: IFFALSE 27678
// ComExitBuilding ( j ) ;
27669: LD_VAR 0 3
27673: PPUSH
27674: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27678: LD_VAR 0 3
27682: PUSH
27683: LD_EXP 52
27687: PUSH
27688: LD_VAR 0 2
27692: ARRAY
27693: IN
27694: NOT
27695: IFFALSE 27753
// begin SetTag ( j , 101 ) ;
27697: LD_VAR 0 3
27701: PPUSH
27702: LD_INT 101
27704: PPUSH
27705: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27709: LD_ADDR_EXP 52
27713: PUSH
27714: LD_EXP 52
27718: PPUSH
27719: LD_VAR 0 2
27723: PUSH
27724: LD_EXP 52
27728: PUSH
27729: LD_VAR 0 2
27733: ARRAY
27734: PUSH
27735: LD_INT 1
27737: PLUS
27738: PUSH
27739: EMPTY
27740: LIST
27741: LIST
27742: PPUSH
27743: LD_VAR 0 3
27747: PPUSH
27748: CALL 53564 0 3
27752: ST_TO_ADDR
// end ; wait ( 1 ) ;
27753: LD_INT 1
27755: PPUSH
27756: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27760: LD_ADDR_VAR 0 7
27764: PUSH
27765: LD_EXP 51
27769: PUSH
27770: LD_VAR 0 2
27774: ARRAY
27775: ST_TO_ADDR
// if mc_scan [ i ] then
27776: LD_EXP 73
27780: PUSH
27781: LD_VAR 0 2
27785: ARRAY
27786: IFFALSE 27848
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27788: LD_ADDR_VAR 0 7
27792: PUSH
27793: LD_EXP 51
27797: PUSH
27798: LD_VAR 0 2
27802: ARRAY
27803: PPUSH
27804: LD_INT 3
27806: PUSH
27807: LD_INT 30
27809: PUSH
27810: LD_INT 32
27812: PUSH
27813: EMPTY
27814: LIST
27815: LIST
27816: PUSH
27817: LD_INT 30
27819: PUSH
27820: LD_INT 33
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: PUSH
27827: LD_INT 30
27829: PUSH
27830: LD_INT 31
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PUSH
27837: EMPTY
27838: LIST
27839: LIST
27840: LIST
27841: LIST
27842: PPUSH
27843: CALL_OW 72
27847: ST_TO_ADDR
// if not to_repair_tmp then
27848: LD_VAR 0 7
27852: NOT
27853: IFFALSE 27857
// continue ;
27855: GO 27655
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27857: LD_ADDR_VAR 0 8
27861: PUSH
27862: LD_VAR 0 7
27866: PPUSH
27867: LD_VAR 0 3
27871: PPUSH
27872: CALL_OW 74
27876: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27877: LD_VAR 0 8
27881: PPUSH
27882: LD_INT 16
27884: PPUSH
27885: CALL 56163 0 2
27889: PUSH
27890: LD_INT 4
27892: ARRAY
27893: PUSH
27894: LD_INT 10
27896: LESS
27897: IFFALSE 27913
// ComRepairBuilding ( j , to_repair ) ;
27899: LD_VAR 0 3
27903: PPUSH
27904: LD_VAR 0 8
27908: PPUSH
27909: CALL_OW 130
// end ;
27913: GO 27655
27915: POP
27916: POP
// end ;
27917: GO 27053
27919: POP
27920: POP
// end ;
27921: LD_VAR 0 1
27925: RET
// export function MC_Heal ; var i , j , tmp ; begin
27926: LD_INT 0
27928: PPUSH
27929: PPUSH
27930: PPUSH
27931: PPUSH
// if not mc_bases then
27932: LD_EXP 50
27936: NOT
27937: IFFALSE 27941
// exit ;
27939: GO 28343
// for i = 1 to mc_bases do
27941: LD_ADDR_VAR 0 2
27945: PUSH
27946: DOUBLE
27947: LD_INT 1
27949: DEC
27950: ST_TO_ADDR
27951: LD_EXP 50
27955: PUSH
27956: FOR_TO
27957: IFFALSE 28341
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27959: LD_EXP 53
27963: PUSH
27964: LD_VAR 0 2
27968: ARRAY
27969: PUSH
27970: LD_INT 1
27972: ARRAY
27973: NOT
27974: PUSH
27975: LD_EXP 53
27979: PUSH
27980: LD_VAR 0 2
27984: ARRAY
27985: PUSH
27986: LD_INT 2
27988: ARRAY
27989: NOT
27990: AND
27991: IFFALSE 28029
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27993: LD_ADDR_EXP 54
27997: PUSH
27998: LD_EXP 54
28002: PPUSH
28003: LD_VAR 0 2
28007: PPUSH
28008: EMPTY
28009: PPUSH
28010: CALL_OW 1
28014: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28015: LD_VAR 0 2
28019: PPUSH
28020: LD_INT 102
28022: PPUSH
28023: CALL 22106 0 2
// continue ;
28027: GO 27956
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28029: LD_ADDR_VAR 0 4
28033: PUSH
28034: LD_EXP 50
28038: PUSH
28039: LD_VAR 0 2
28043: ARRAY
28044: PPUSH
28045: LD_INT 25
28047: PUSH
28048: LD_INT 4
28050: PUSH
28051: EMPTY
28052: LIST
28053: LIST
28054: PPUSH
28055: CALL_OW 72
28059: ST_TO_ADDR
// if not tmp then
28060: LD_VAR 0 4
28064: NOT
28065: IFFALSE 28069
// continue ;
28067: GO 27956
// if mc_taming [ i ] then
28069: LD_EXP 81
28073: PUSH
28074: LD_VAR 0 2
28078: ARRAY
28079: IFFALSE 28103
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28081: LD_ADDR_EXP 81
28085: PUSH
28086: LD_EXP 81
28090: PPUSH
28091: LD_VAR 0 2
28095: PPUSH
28096: EMPTY
28097: PPUSH
28098: CALL_OW 1
28102: ST_TO_ADDR
// for j in tmp do
28103: LD_ADDR_VAR 0 3
28107: PUSH
28108: LD_VAR 0 4
28112: PUSH
28113: FOR_IN
28114: IFFALSE 28337
// begin if IsInUnit ( j ) then
28116: LD_VAR 0 3
28120: PPUSH
28121: CALL_OW 310
28125: IFFALSE 28136
// ComExitBuilding ( j ) ;
28127: LD_VAR 0 3
28131: PPUSH
28132: CALL_OW 122
// if not j in mc_healers [ i ] then
28136: LD_VAR 0 3
28140: PUSH
28141: LD_EXP 54
28145: PUSH
28146: LD_VAR 0 2
28150: ARRAY
28151: IN
28152: NOT
28153: IFFALSE 28199
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28155: LD_ADDR_EXP 54
28159: PUSH
28160: LD_EXP 54
28164: PPUSH
28165: LD_VAR 0 2
28169: PUSH
28170: LD_EXP 54
28174: PUSH
28175: LD_VAR 0 2
28179: ARRAY
28180: PUSH
28181: LD_INT 1
28183: PLUS
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PPUSH
28189: LD_VAR 0 3
28193: PPUSH
28194: CALL 53564 0 3
28198: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28199: LD_VAR 0 3
28203: PPUSH
28204: CALL_OW 110
28208: PUSH
28209: LD_INT 102
28211: NONEQUAL
28212: IFFALSE 28226
// SetTag ( j , 102 ) ;
28214: LD_VAR 0 3
28218: PPUSH
28219: LD_INT 102
28221: PPUSH
28222: CALL_OW 109
// Wait ( 3 ) ;
28226: LD_INT 3
28228: PPUSH
28229: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28233: LD_EXP 53
28237: PUSH
28238: LD_VAR 0 2
28242: ARRAY
28243: PUSH
28244: LD_INT 1
28246: ARRAY
28247: IFFALSE 28279
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28249: LD_VAR 0 3
28253: PPUSH
28254: LD_EXP 53
28258: PUSH
28259: LD_VAR 0 2
28263: ARRAY
28264: PUSH
28265: LD_INT 1
28267: ARRAY
28268: PUSH
28269: LD_INT 1
28271: ARRAY
28272: PPUSH
28273: CALL_OW 128
28277: GO 28335
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28279: LD_VAR 0 3
28283: PPUSH
28284: CALL_OW 314
28288: NOT
28289: PUSH
28290: LD_EXP 53
28294: PUSH
28295: LD_VAR 0 2
28299: ARRAY
28300: PUSH
28301: LD_INT 2
28303: ARRAY
28304: AND
28305: IFFALSE 28335
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28307: LD_VAR 0 3
28311: PPUSH
28312: LD_EXP 53
28316: PUSH
28317: LD_VAR 0 2
28321: ARRAY
28322: PUSH
28323: LD_INT 2
28325: ARRAY
28326: PUSH
28327: LD_INT 1
28329: ARRAY
28330: PPUSH
28331: CALL_OW 128
// end ;
28335: GO 28113
28337: POP
28338: POP
// end ;
28339: GO 27956
28341: POP
28342: POP
// end ;
28343: LD_VAR 0 1
28347: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
28348: LD_INT 0
28350: PPUSH
28351: PPUSH
28352: PPUSH
28353: PPUSH
28354: PPUSH
// if not mc_bases then
28355: LD_EXP 50
28359: NOT
28360: IFFALSE 28364
// exit ;
28362: GO 29535
// for i = 1 to mc_bases do
28364: LD_ADDR_VAR 0 2
28368: PUSH
28369: DOUBLE
28370: LD_INT 1
28372: DEC
28373: ST_TO_ADDR
28374: LD_EXP 50
28378: PUSH
28379: FOR_TO
28380: IFFALSE 29533
// begin if mc_scan [ i ] then
28382: LD_EXP 73
28386: PUSH
28387: LD_VAR 0 2
28391: ARRAY
28392: IFFALSE 28396
// continue ;
28394: GO 28379
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28396: LD_EXP 55
28400: PUSH
28401: LD_VAR 0 2
28405: ARRAY
28406: NOT
28407: PUSH
28408: LD_EXP 57
28412: PUSH
28413: LD_VAR 0 2
28417: ARRAY
28418: NOT
28419: AND
28420: PUSH
28421: LD_EXP 56
28425: PUSH
28426: LD_VAR 0 2
28430: ARRAY
28431: AND
28432: IFFALSE 28470
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28434: LD_ADDR_EXP 56
28438: PUSH
28439: LD_EXP 56
28443: PPUSH
28444: LD_VAR 0 2
28448: PPUSH
28449: EMPTY
28450: PPUSH
28451: CALL_OW 1
28455: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28456: LD_VAR 0 2
28460: PPUSH
28461: LD_INT 103
28463: PPUSH
28464: CALL 22106 0 2
// continue ;
28468: GO 28379
// end ; if mc_construct_list [ i ] then
28470: LD_EXP 57
28474: PUSH
28475: LD_VAR 0 2
28479: ARRAY
28480: IFFALSE 28700
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28482: LD_ADDR_VAR 0 4
28486: PUSH
28487: LD_EXP 50
28491: PUSH
28492: LD_VAR 0 2
28496: ARRAY
28497: PPUSH
28498: LD_INT 25
28500: PUSH
28501: LD_INT 2
28503: PUSH
28504: EMPTY
28505: LIST
28506: LIST
28507: PPUSH
28508: CALL_OW 72
28512: PUSH
28513: LD_EXP 52
28517: PUSH
28518: LD_VAR 0 2
28522: ARRAY
28523: DIFF
28524: ST_TO_ADDR
// if not tmp then
28525: LD_VAR 0 4
28529: NOT
28530: IFFALSE 28534
// continue ;
28532: GO 28379
// for j in tmp do
28534: LD_ADDR_VAR 0 3
28538: PUSH
28539: LD_VAR 0 4
28543: PUSH
28544: FOR_IN
28545: IFFALSE 28696
// begin if not mc_builders [ i ] then
28547: LD_EXP 56
28551: PUSH
28552: LD_VAR 0 2
28556: ARRAY
28557: NOT
28558: IFFALSE 28616
// begin SetTag ( j , 103 ) ;
28560: LD_VAR 0 3
28564: PPUSH
28565: LD_INT 103
28567: PPUSH
28568: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28572: LD_ADDR_EXP 56
28576: PUSH
28577: LD_EXP 56
28581: PPUSH
28582: LD_VAR 0 2
28586: PUSH
28587: LD_EXP 56
28591: PUSH
28592: LD_VAR 0 2
28596: ARRAY
28597: PUSH
28598: LD_INT 1
28600: PLUS
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PPUSH
28606: LD_VAR 0 3
28610: PPUSH
28611: CALL 53564 0 3
28615: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28616: LD_VAR 0 3
28620: PPUSH
28621: CALL_OW 310
28625: IFFALSE 28636
// ComExitBuilding ( j ) ;
28627: LD_VAR 0 3
28631: PPUSH
28632: CALL_OW 122
// wait ( 3 ) ;
28636: LD_INT 3
28638: PPUSH
28639: CALL_OW 67
// if not mc_construct_list [ i ] then
28643: LD_EXP 57
28647: PUSH
28648: LD_VAR 0 2
28652: ARRAY
28653: NOT
28654: IFFALSE 28658
// break ;
28656: GO 28696
// if not HasTask ( j ) then
28658: LD_VAR 0 3
28662: PPUSH
28663: CALL_OW 314
28667: NOT
28668: IFFALSE 28694
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28670: LD_VAR 0 3
28674: PPUSH
28675: LD_EXP 57
28679: PUSH
28680: LD_VAR 0 2
28684: ARRAY
28685: PUSH
28686: LD_INT 1
28688: ARRAY
28689: PPUSH
28690: CALL 56427 0 2
// end ;
28694: GO 28544
28696: POP
28697: POP
// end else
28698: GO 29531
// if mc_build_list [ i ] then
28700: LD_EXP 55
28704: PUSH
28705: LD_VAR 0 2
28709: ARRAY
28710: IFFALSE 29531
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28712: LD_ADDR_VAR 0 5
28716: PUSH
28717: LD_EXP 50
28721: PUSH
28722: LD_VAR 0 2
28726: ARRAY
28727: PPUSH
28728: LD_INT 2
28730: PUSH
28731: LD_INT 30
28733: PUSH
28734: LD_INT 0
28736: PUSH
28737: EMPTY
28738: LIST
28739: LIST
28740: PUSH
28741: LD_INT 30
28743: PUSH
28744: LD_INT 1
28746: PUSH
28747: EMPTY
28748: LIST
28749: LIST
28750: PUSH
28751: EMPTY
28752: LIST
28753: LIST
28754: LIST
28755: PPUSH
28756: CALL_OW 72
28760: ST_TO_ADDR
// if depot then
28761: LD_VAR 0 5
28765: IFFALSE 28783
// depot := depot [ 1 ] else
28767: LD_ADDR_VAR 0 5
28771: PUSH
28772: LD_VAR 0 5
28776: PUSH
28777: LD_INT 1
28779: ARRAY
28780: ST_TO_ADDR
28781: GO 28791
// depot := 0 ;
28783: LD_ADDR_VAR 0 5
28787: PUSH
28788: LD_INT 0
28790: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28791: LD_EXP 55
28795: PUSH
28796: LD_VAR 0 2
28800: ARRAY
28801: PUSH
28802: LD_INT 1
28804: ARRAY
28805: PUSH
28806: LD_INT 1
28808: ARRAY
28809: PPUSH
28810: CALL 56251 0 1
28814: PUSH
28815: LD_EXP 50
28819: PUSH
28820: LD_VAR 0 2
28824: ARRAY
28825: PPUSH
28826: LD_INT 2
28828: PUSH
28829: LD_INT 30
28831: PUSH
28832: LD_INT 2
28834: PUSH
28835: EMPTY
28836: LIST
28837: LIST
28838: PUSH
28839: LD_INT 30
28841: PUSH
28842: LD_INT 3
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: PUSH
28849: EMPTY
28850: LIST
28851: LIST
28852: LIST
28853: PPUSH
28854: CALL_OW 72
28858: NOT
28859: AND
28860: IFFALSE 28965
// begin for j = 1 to mc_build_list [ i ] do
28862: LD_ADDR_VAR 0 3
28866: PUSH
28867: DOUBLE
28868: LD_INT 1
28870: DEC
28871: ST_TO_ADDR
28872: LD_EXP 55
28876: PUSH
28877: LD_VAR 0 2
28881: ARRAY
28882: PUSH
28883: FOR_TO
28884: IFFALSE 28963
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28886: LD_EXP 55
28890: PUSH
28891: LD_VAR 0 2
28895: ARRAY
28896: PUSH
28897: LD_VAR 0 3
28901: ARRAY
28902: PUSH
28903: LD_INT 1
28905: ARRAY
28906: PUSH
28907: LD_INT 2
28909: EQUAL
28910: IFFALSE 28961
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28912: LD_ADDR_EXP 55
28916: PUSH
28917: LD_EXP 55
28921: PPUSH
28922: LD_VAR 0 2
28926: PPUSH
28927: LD_EXP 55
28931: PUSH
28932: LD_VAR 0 2
28936: ARRAY
28937: PPUSH
28938: LD_VAR 0 3
28942: PPUSH
28943: LD_INT 1
28945: PPUSH
28946: LD_INT 0
28948: PPUSH
28949: CALL 52982 0 4
28953: PPUSH
28954: CALL_OW 1
28958: ST_TO_ADDR
// break ;
28959: GO 28963
// end ;
28961: GO 28883
28963: POP
28964: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28965: LD_EXP 55
28969: PUSH
28970: LD_VAR 0 2
28974: ARRAY
28975: PUSH
28976: LD_INT 1
28978: ARRAY
28979: PUSH
28980: LD_INT 1
28982: ARRAY
28983: PUSH
28984: LD_INT 0
28986: EQUAL
28987: PUSH
28988: LD_VAR 0 5
28992: PUSH
28993: LD_VAR 0 5
28997: PPUSH
28998: LD_EXP 55
29002: PUSH
29003: LD_VAR 0 2
29007: ARRAY
29008: PUSH
29009: LD_INT 1
29011: ARRAY
29012: PUSH
29013: LD_INT 1
29015: ARRAY
29016: PPUSH
29017: LD_EXP 55
29021: PUSH
29022: LD_VAR 0 2
29026: ARRAY
29027: PUSH
29028: LD_INT 1
29030: ARRAY
29031: PUSH
29032: LD_INT 2
29034: ARRAY
29035: PPUSH
29036: LD_EXP 55
29040: PUSH
29041: LD_VAR 0 2
29045: ARRAY
29046: PUSH
29047: LD_INT 1
29049: ARRAY
29050: PUSH
29051: LD_INT 3
29053: ARRAY
29054: PPUSH
29055: LD_EXP 55
29059: PUSH
29060: LD_VAR 0 2
29064: ARRAY
29065: PUSH
29066: LD_INT 1
29068: ARRAY
29069: PUSH
29070: LD_INT 4
29072: ARRAY
29073: PPUSH
29074: CALL 61667 0 5
29078: AND
29079: OR
29080: IFFALSE 29361
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29082: LD_ADDR_VAR 0 4
29086: PUSH
29087: LD_EXP 50
29091: PUSH
29092: LD_VAR 0 2
29096: ARRAY
29097: PPUSH
29098: LD_INT 25
29100: PUSH
29101: LD_INT 2
29103: PUSH
29104: EMPTY
29105: LIST
29106: LIST
29107: PPUSH
29108: CALL_OW 72
29112: PUSH
29113: LD_EXP 52
29117: PUSH
29118: LD_VAR 0 2
29122: ARRAY
29123: DIFF
29124: ST_TO_ADDR
// if not tmp then
29125: LD_VAR 0 4
29129: NOT
29130: IFFALSE 29134
// continue ;
29132: GO 28379
// for j in tmp do
29134: LD_ADDR_VAR 0 3
29138: PUSH
29139: LD_VAR 0 4
29143: PUSH
29144: FOR_IN
29145: IFFALSE 29357
// begin if not mc_builders [ i ] then
29147: LD_EXP 56
29151: PUSH
29152: LD_VAR 0 2
29156: ARRAY
29157: NOT
29158: IFFALSE 29216
// begin SetTag ( j , 103 ) ;
29160: LD_VAR 0 3
29164: PPUSH
29165: LD_INT 103
29167: PPUSH
29168: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29172: LD_ADDR_EXP 56
29176: PUSH
29177: LD_EXP 56
29181: PPUSH
29182: LD_VAR 0 2
29186: PUSH
29187: LD_EXP 56
29191: PUSH
29192: LD_VAR 0 2
29196: ARRAY
29197: PUSH
29198: LD_INT 1
29200: PLUS
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: PPUSH
29206: LD_VAR 0 3
29210: PPUSH
29211: CALL 53564 0 3
29215: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29216: LD_VAR 0 3
29220: PPUSH
29221: CALL_OW 310
29225: IFFALSE 29236
// ComExitBuilding ( j ) ;
29227: LD_VAR 0 3
29231: PPUSH
29232: CALL_OW 122
// wait ( 3 ) ;
29236: LD_INT 3
29238: PPUSH
29239: CALL_OW 67
// if not mc_build_list [ i ] then
29243: LD_EXP 55
29247: PUSH
29248: LD_VAR 0 2
29252: ARRAY
29253: NOT
29254: IFFALSE 29258
// break ;
29256: GO 29357
// if not HasTask ( j ) then
29258: LD_VAR 0 3
29262: PPUSH
29263: CALL_OW 314
29267: NOT
29268: IFFALSE 29355
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29270: LD_VAR 0 3
29274: PPUSH
29275: LD_EXP 55
29279: PUSH
29280: LD_VAR 0 2
29284: ARRAY
29285: PUSH
29286: LD_INT 1
29288: ARRAY
29289: PUSH
29290: LD_INT 1
29292: ARRAY
29293: PPUSH
29294: LD_EXP 55
29298: PUSH
29299: LD_VAR 0 2
29303: ARRAY
29304: PUSH
29305: LD_INT 1
29307: ARRAY
29308: PUSH
29309: LD_INT 2
29311: ARRAY
29312: PPUSH
29313: LD_EXP 55
29317: PUSH
29318: LD_VAR 0 2
29322: ARRAY
29323: PUSH
29324: LD_INT 1
29326: ARRAY
29327: PUSH
29328: LD_INT 3
29330: ARRAY
29331: PPUSH
29332: LD_EXP 55
29336: PUSH
29337: LD_VAR 0 2
29341: ARRAY
29342: PUSH
29343: LD_INT 1
29345: ARRAY
29346: PUSH
29347: LD_INT 4
29349: ARRAY
29350: PPUSH
29351: CALL_OW 145
// end ;
29355: GO 29144
29357: POP
29358: POP
// end else
29359: GO 29531
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29361: LD_EXP 50
29365: PUSH
29366: LD_VAR 0 2
29370: ARRAY
29371: PPUSH
29372: LD_EXP 55
29376: PUSH
29377: LD_VAR 0 2
29381: ARRAY
29382: PUSH
29383: LD_INT 1
29385: ARRAY
29386: PUSH
29387: LD_INT 1
29389: ARRAY
29390: PPUSH
29391: LD_EXP 55
29395: PUSH
29396: LD_VAR 0 2
29400: ARRAY
29401: PUSH
29402: LD_INT 1
29404: ARRAY
29405: PUSH
29406: LD_INT 2
29408: ARRAY
29409: PPUSH
29410: LD_EXP 55
29414: PUSH
29415: LD_VAR 0 2
29419: ARRAY
29420: PUSH
29421: LD_INT 1
29423: ARRAY
29424: PUSH
29425: LD_INT 3
29427: ARRAY
29428: PPUSH
29429: LD_EXP 55
29433: PUSH
29434: LD_VAR 0 2
29438: ARRAY
29439: PUSH
29440: LD_INT 1
29442: ARRAY
29443: PUSH
29444: LD_INT 4
29446: ARRAY
29447: PPUSH
29448: LD_EXP 50
29452: PUSH
29453: LD_VAR 0 2
29457: ARRAY
29458: PPUSH
29459: LD_INT 21
29461: PUSH
29462: LD_INT 3
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PPUSH
29469: CALL_OW 72
29473: PPUSH
29474: EMPTY
29475: PPUSH
29476: CALL 60417 0 7
29480: NOT
29481: IFFALSE 29531
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29483: LD_ADDR_EXP 55
29487: PUSH
29488: LD_EXP 55
29492: PPUSH
29493: LD_VAR 0 2
29497: PPUSH
29498: LD_EXP 55
29502: PUSH
29503: LD_VAR 0 2
29507: ARRAY
29508: PPUSH
29509: LD_INT 1
29511: PPUSH
29512: LD_INT 1
29514: NEG
29515: PPUSH
29516: LD_INT 0
29518: PPUSH
29519: CALL 52982 0 4
29523: PPUSH
29524: CALL_OW 1
29528: ST_TO_ADDR
// continue ;
29529: GO 28379
// end ; end ; end ;
29531: GO 28379
29533: POP
29534: POP
// end ;
29535: LD_VAR 0 1
29539: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29540: LD_INT 0
29542: PPUSH
29543: PPUSH
29544: PPUSH
29545: PPUSH
29546: PPUSH
29547: PPUSH
// if not mc_bases then
29548: LD_EXP 50
29552: NOT
29553: IFFALSE 29557
// exit ;
29555: GO 29984
// for i = 1 to mc_bases do
29557: LD_ADDR_VAR 0 2
29561: PUSH
29562: DOUBLE
29563: LD_INT 1
29565: DEC
29566: ST_TO_ADDR
29567: LD_EXP 50
29571: PUSH
29572: FOR_TO
29573: IFFALSE 29982
// begin tmp := mc_build_upgrade [ i ] ;
29575: LD_ADDR_VAR 0 4
29579: PUSH
29580: LD_EXP 82
29584: PUSH
29585: LD_VAR 0 2
29589: ARRAY
29590: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29591: LD_ADDR_VAR 0 6
29595: PUSH
29596: LD_EXP 83
29600: PUSH
29601: LD_VAR 0 2
29605: ARRAY
29606: PPUSH
29607: LD_INT 2
29609: PUSH
29610: LD_INT 30
29612: PUSH
29613: LD_INT 6
29615: PUSH
29616: EMPTY
29617: LIST
29618: LIST
29619: PUSH
29620: LD_INT 30
29622: PUSH
29623: LD_INT 7
29625: PUSH
29626: EMPTY
29627: LIST
29628: LIST
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: LIST
29634: PPUSH
29635: CALL_OW 72
29639: ST_TO_ADDR
// if not tmp and not lab then
29640: LD_VAR 0 4
29644: NOT
29645: PUSH
29646: LD_VAR 0 6
29650: NOT
29651: AND
29652: IFFALSE 29656
// continue ;
29654: GO 29572
// if tmp then
29656: LD_VAR 0 4
29660: IFFALSE 29780
// for j in tmp do
29662: LD_ADDR_VAR 0 3
29666: PUSH
29667: LD_VAR 0 4
29671: PUSH
29672: FOR_IN
29673: IFFALSE 29778
// begin if UpgradeCost ( j ) then
29675: LD_VAR 0 3
29679: PPUSH
29680: CALL 60077 0 1
29684: IFFALSE 29776
// begin ComUpgrade ( j ) ;
29686: LD_VAR 0 3
29690: PPUSH
29691: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29695: LD_ADDR_EXP 82
29699: PUSH
29700: LD_EXP 82
29704: PPUSH
29705: LD_VAR 0 2
29709: PPUSH
29710: LD_EXP 82
29714: PUSH
29715: LD_VAR 0 2
29719: ARRAY
29720: PUSH
29721: LD_VAR 0 3
29725: DIFF
29726: PPUSH
29727: CALL_OW 1
29731: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29732: LD_ADDR_EXP 57
29736: PUSH
29737: LD_EXP 57
29741: PPUSH
29742: LD_VAR 0 2
29746: PUSH
29747: LD_EXP 57
29751: PUSH
29752: LD_VAR 0 2
29756: ARRAY
29757: PUSH
29758: LD_INT 1
29760: PLUS
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PPUSH
29766: LD_VAR 0 3
29770: PPUSH
29771: CALL 53564 0 3
29775: ST_TO_ADDR
// end ; end ;
29776: GO 29672
29778: POP
29779: POP
// if not lab or not mc_lab_upgrade [ i ] then
29780: LD_VAR 0 6
29784: NOT
29785: PUSH
29786: LD_EXP 84
29790: PUSH
29791: LD_VAR 0 2
29795: ARRAY
29796: NOT
29797: OR
29798: IFFALSE 29802
// continue ;
29800: GO 29572
// for j in lab do
29802: LD_ADDR_VAR 0 3
29806: PUSH
29807: LD_VAR 0 6
29811: PUSH
29812: FOR_IN
29813: IFFALSE 29978
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29815: LD_VAR 0 3
29819: PPUSH
29820: CALL_OW 266
29824: PUSH
29825: LD_INT 6
29827: PUSH
29828: LD_INT 7
29830: PUSH
29831: EMPTY
29832: LIST
29833: LIST
29834: IN
29835: PUSH
29836: LD_VAR 0 3
29840: PPUSH
29841: CALL_OW 461
29845: PUSH
29846: LD_INT 1
29848: NONEQUAL
29849: AND
29850: IFFALSE 29976
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29852: LD_VAR 0 3
29856: PPUSH
29857: LD_EXP 84
29861: PUSH
29862: LD_VAR 0 2
29866: ARRAY
29867: PUSH
29868: LD_INT 1
29870: ARRAY
29871: PPUSH
29872: CALL 60282 0 2
29876: IFFALSE 29976
// begin ComCancel ( j ) ;
29878: LD_VAR 0 3
29882: PPUSH
29883: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29887: LD_VAR 0 3
29891: PPUSH
29892: LD_EXP 84
29896: PUSH
29897: LD_VAR 0 2
29901: ARRAY
29902: PUSH
29903: LD_INT 1
29905: ARRAY
29906: PPUSH
29907: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29911: LD_VAR 0 3
29915: PUSH
29916: LD_EXP 57
29920: PUSH
29921: LD_VAR 0 2
29925: ARRAY
29926: IN
29927: NOT
29928: IFFALSE 29974
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29930: LD_ADDR_EXP 57
29934: PUSH
29935: LD_EXP 57
29939: PPUSH
29940: LD_VAR 0 2
29944: PUSH
29945: LD_EXP 57
29949: PUSH
29950: LD_VAR 0 2
29954: ARRAY
29955: PUSH
29956: LD_INT 1
29958: PLUS
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PPUSH
29964: LD_VAR 0 3
29968: PPUSH
29969: CALL 53564 0 3
29973: ST_TO_ADDR
// break ;
29974: GO 29978
// end ; end ; end ;
29976: GO 29812
29978: POP
29979: POP
// end ;
29980: GO 29572
29982: POP
29983: POP
// end ;
29984: LD_VAR 0 1
29988: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29989: LD_INT 0
29991: PPUSH
29992: PPUSH
29993: PPUSH
29994: PPUSH
29995: PPUSH
29996: PPUSH
29997: PPUSH
29998: PPUSH
29999: PPUSH
// if not mc_bases then
30000: LD_EXP 50
30004: NOT
30005: IFFALSE 30009
// exit ;
30007: GO 30414
// for i = 1 to mc_bases do
30009: LD_ADDR_VAR 0 2
30013: PUSH
30014: DOUBLE
30015: LD_INT 1
30017: DEC
30018: ST_TO_ADDR
30019: LD_EXP 50
30023: PUSH
30024: FOR_TO
30025: IFFALSE 30412
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30027: LD_EXP 58
30031: PUSH
30032: LD_VAR 0 2
30036: ARRAY
30037: NOT
30038: PUSH
30039: LD_EXP 50
30043: PUSH
30044: LD_VAR 0 2
30048: ARRAY
30049: PPUSH
30050: LD_INT 30
30052: PUSH
30053: LD_INT 3
30055: PUSH
30056: EMPTY
30057: LIST
30058: LIST
30059: PPUSH
30060: CALL_OW 72
30064: NOT
30065: OR
30066: IFFALSE 30070
// continue ;
30068: GO 30024
// busy := false ;
30070: LD_ADDR_VAR 0 8
30074: PUSH
30075: LD_INT 0
30077: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30078: LD_ADDR_VAR 0 4
30082: PUSH
30083: LD_EXP 50
30087: PUSH
30088: LD_VAR 0 2
30092: ARRAY
30093: PPUSH
30094: LD_INT 30
30096: PUSH
30097: LD_INT 3
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PPUSH
30104: CALL_OW 72
30108: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30109: LD_ADDR_VAR 0 6
30113: PUSH
30114: LD_EXP 58
30118: PUSH
30119: LD_VAR 0 2
30123: ARRAY
30124: PPUSH
30125: LD_INT 2
30127: PUSH
30128: LD_INT 30
30130: PUSH
30131: LD_INT 32
30133: PUSH
30134: EMPTY
30135: LIST
30136: LIST
30137: PUSH
30138: LD_INT 30
30140: PUSH
30141: LD_INT 33
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: LIST
30152: PPUSH
30153: CALL_OW 72
30157: ST_TO_ADDR
// if not t then
30158: LD_VAR 0 6
30162: NOT
30163: IFFALSE 30167
// continue ;
30165: GO 30024
// for j in tmp do
30167: LD_ADDR_VAR 0 3
30171: PUSH
30172: LD_VAR 0 4
30176: PUSH
30177: FOR_IN
30178: IFFALSE 30208
// if not BuildingStatus ( j ) = bs_idle then
30180: LD_VAR 0 3
30184: PPUSH
30185: CALL_OW 461
30189: PUSH
30190: LD_INT 2
30192: EQUAL
30193: NOT
30194: IFFALSE 30206
// begin busy := true ;
30196: LD_ADDR_VAR 0 8
30200: PUSH
30201: LD_INT 1
30203: ST_TO_ADDR
// break ;
30204: GO 30208
// end ;
30206: GO 30177
30208: POP
30209: POP
// if busy then
30210: LD_VAR 0 8
30214: IFFALSE 30218
// continue ;
30216: GO 30024
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30218: LD_ADDR_VAR 0 7
30222: PUSH
30223: LD_VAR 0 6
30227: PPUSH
30228: LD_INT 35
30230: PUSH
30231: LD_INT 0
30233: PUSH
30234: EMPTY
30235: LIST
30236: LIST
30237: PPUSH
30238: CALL_OW 72
30242: ST_TO_ADDR
// if tw then
30243: LD_VAR 0 7
30247: IFFALSE 30324
// begin tw := tw [ 1 ] ;
30249: LD_ADDR_VAR 0 7
30253: PUSH
30254: LD_VAR 0 7
30258: PUSH
30259: LD_INT 1
30261: ARRAY
30262: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30263: LD_ADDR_VAR 0 9
30267: PUSH
30268: LD_VAR 0 7
30272: PPUSH
30273: LD_EXP 75
30277: PUSH
30278: LD_VAR 0 2
30282: ARRAY
30283: PPUSH
30284: CALL 58574 0 2
30288: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30289: LD_EXP 89
30293: PUSH
30294: LD_VAR 0 2
30298: ARRAY
30299: IFFALSE 30322
// if not weapon in mc_allowed_tower_weapons [ i ] then
30301: LD_VAR 0 9
30305: PUSH
30306: LD_EXP 89
30310: PUSH
30311: LD_VAR 0 2
30315: ARRAY
30316: IN
30317: NOT
30318: IFFALSE 30322
// continue ;
30320: GO 30024
// end else
30322: GO 30387
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30324: LD_ADDR_VAR 0 5
30328: PUSH
30329: LD_EXP 58
30333: PUSH
30334: LD_VAR 0 2
30338: ARRAY
30339: PPUSH
30340: LD_VAR 0 4
30344: PPUSH
30345: CALL 84807 0 2
30349: ST_TO_ADDR
// if not tmp2 then
30350: LD_VAR 0 5
30354: NOT
30355: IFFALSE 30359
// continue ;
30357: GO 30024
// tw := tmp2 [ 1 ] ;
30359: LD_ADDR_VAR 0 7
30363: PUSH
30364: LD_VAR 0 5
30368: PUSH
30369: LD_INT 1
30371: ARRAY
30372: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30373: LD_ADDR_VAR 0 9
30377: PUSH
30378: LD_VAR 0 5
30382: PUSH
30383: LD_INT 2
30385: ARRAY
30386: ST_TO_ADDR
// end ; if not weapon then
30387: LD_VAR 0 9
30391: NOT
30392: IFFALSE 30396
// continue ;
30394: GO 30024
// ComPlaceWeapon ( tw , weapon ) ;
30396: LD_VAR 0 7
30400: PPUSH
30401: LD_VAR 0 9
30405: PPUSH
30406: CALL_OW 148
// end ;
30410: GO 30024
30412: POP
30413: POP
// end ;
30414: LD_VAR 0 1
30418: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30419: LD_INT 0
30421: PPUSH
30422: PPUSH
30423: PPUSH
30424: PPUSH
30425: PPUSH
30426: PPUSH
30427: PPUSH
// if not mc_bases then
30428: LD_EXP 50
30432: NOT
30433: IFFALSE 30437
// exit ;
30435: GO 31205
// for i = 1 to mc_bases do
30437: LD_ADDR_VAR 0 2
30441: PUSH
30442: DOUBLE
30443: LD_INT 1
30445: DEC
30446: ST_TO_ADDR
30447: LD_EXP 50
30451: PUSH
30452: FOR_TO
30453: IFFALSE 31203
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30455: LD_EXP 63
30459: PUSH
30460: LD_VAR 0 2
30464: ARRAY
30465: NOT
30466: PUSH
30467: LD_EXP 63
30471: PUSH
30472: LD_VAR 0 2
30476: ARRAY
30477: PUSH
30478: LD_EXP 64
30482: PUSH
30483: LD_VAR 0 2
30487: ARRAY
30488: EQUAL
30489: OR
30490: PUSH
30491: LD_EXP 73
30495: PUSH
30496: LD_VAR 0 2
30500: ARRAY
30501: OR
30502: IFFALSE 30506
// continue ;
30504: GO 30452
// if mc_miners [ i ] then
30506: LD_EXP 64
30510: PUSH
30511: LD_VAR 0 2
30515: ARRAY
30516: IFFALSE 30890
// begin for j = mc_miners [ i ] downto 1 do
30518: LD_ADDR_VAR 0 3
30522: PUSH
30523: DOUBLE
30524: LD_EXP 64
30528: PUSH
30529: LD_VAR 0 2
30533: ARRAY
30534: INC
30535: ST_TO_ADDR
30536: LD_INT 1
30538: PUSH
30539: FOR_DOWNTO
30540: IFFALSE 30888
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30542: LD_EXP 64
30546: PUSH
30547: LD_VAR 0 2
30551: ARRAY
30552: PUSH
30553: LD_VAR 0 3
30557: ARRAY
30558: PPUSH
30559: CALL_OW 301
30563: PUSH
30564: LD_EXP 64
30568: PUSH
30569: LD_VAR 0 2
30573: ARRAY
30574: PUSH
30575: LD_VAR 0 3
30579: ARRAY
30580: PPUSH
30581: CALL_OW 257
30585: PUSH
30586: LD_INT 1
30588: NONEQUAL
30589: OR
30590: IFFALSE 30653
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30592: LD_ADDR_VAR 0 5
30596: PUSH
30597: LD_EXP 64
30601: PUSH
30602: LD_VAR 0 2
30606: ARRAY
30607: PUSH
30608: LD_EXP 64
30612: PUSH
30613: LD_VAR 0 2
30617: ARRAY
30618: PUSH
30619: LD_VAR 0 3
30623: ARRAY
30624: DIFF
30625: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30626: LD_ADDR_EXP 64
30630: PUSH
30631: LD_EXP 64
30635: PPUSH
30636: LD_VAR 0 2
30640: PPUSH
30641: LD_VAR 0 5
30645: PPUSH
30646: CALL_OW 1
30650: ST_TO_ADDR
// continue ;
30651: GO 30539
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30653: LD_EXP 64
30657: PUSH
30658: LD_VAR 0 2
30662: ARRAY
30663: PUSH
30664: LD_VAR 0 3
30668: ARRAY
30669: PPUSH
30670: CALL_OW 257
30674: PUSH
30675: LD_INT 1
30677: EQUAL
30678: PUSH
30679: LD_EXP 64
30683: PUSH
30684: LD_VAR 0 2
30688: ARRAY
30689: PUSH
30690: LD_VAR 0 3
30694: ARRAY
30695: PPUSH
30696: CALL_OW 459
30700: NOT
30701: AND
30702: PUSH
30703: LD_EXP 64
30707: PUSH
30708: LD_VAR 0 2
30712: ARRAY
30713: PUSH
30714: LD_VAR 0 3
30718: ARRAY
30719: PPUSH
30720: CALL_OW 314
30724: NOT
30725: AND
30726: IFFALSE 30886
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30728: LD_EXP 64
30732: PUSH
30733: LD_VAR 0 2
30737: ARRAY
30738: PUSH
30739: LD_VAR 0 3
30743: ARRAY
30744: PPUSH
30745: CALL_OW 310
30749: IFFALSE 30772
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30751: LD_EXP 64
30755: PUSH
30756: LD_VAR 0 2
30760: ARRAY
30761: PUSH
30762: LD_VAR 0 3
30766: ARRAY
30767: PPUSH
30768: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30772: LD_EXP 64
30776: PUSH
30777: LD_VAR 0 2
30781: ARRAY
30782: PUSH
30783: LD_VAR 0 3
30787: ARRAY
30788: PPUSH
30789: CALL_OW 314
30793: NOT
30794: IFFALSE 30886
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30796: LD_ADDR_VAR 0 7
30800: PUSH
30801: LD_INT 1
30803: PPUSH
30804: LD_EXP 63
30808: PUSH
30809: LD_VAR 0 2
30813: ARRAY
30814: PPUSH
30815: CALL_OW 12
30819: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30820: LD_EXP 64
30824: PUSH
30825: LD_VAR 0 2
30829: ARRAY
30830: PUSH
30831: LD_VAR 0 3
30835: ARRAY
30836: PPUSH
30837: LD_EXP 63
30841: PUSH
30842: LD_VAR 0 2
30846: ARRAY
30847: PUSH
30848: LD_VAR 0 7
30852: ARRAY
30853: PUSH
30854: LD_INT 1
30856: ARRAY
30857: PPUSH
30858: LD_EXP 63
30862: PUSH
30863: LD_VAR 0 2
30867: ARRAY
30868: PUSH
30869: LD_VAR 0 7
30873: ARRAY
30874: PUSH
30875: LD_INT 2
30877: ARRAY
30878: PPUSH
30879: LD_INT 0
30881: PPUSH
30882: CALL_OW 193
// end ; end ; end ;
30886: GO 30539
30888: POP
30889: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30890: LD_ADDR_VAR 0 5
30894: PUSH
30895: LD_EXP 50
30899: PUSH
30900: LD_VAR 0 2
30904: ARRAY
30905: PPUSH
30906: LD_INT 2
30908: PUSH
30909: LD_INT 30
30911: PUSH
30912: LD_INT 4
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 30
30921: PUSH
30922: LD_INT 5
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 30
30931: PUSH
30932: LD_INT 32
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: EMPTY
30940: LIST
30941: LIST
30942: LIST
30943: LIST
30944: PPUSH
30945: CALL_OW 72
30949: ST_TO_ADDR
// if not tmp then
30950: LD_VAR 0 5
30954: NOT
30955: IFFALSE 30959
// continue ;
30957: GO 30452
// list := [ ] ;
30959: LD_ADDR_VAR 0 6
30963: PUSH
30964: EMPTY
30965: ST_TO_ADDR
// for j in tmp do
30966: LD_ADDR_VAR 0 3
30970: PUSH
30971: LD_VAR 0 5
30975: PUSH
30976: FOR_IN
30977: IFFALSE 31046
// begin for k in UnitsInside ( j ) do
30979: LD_ADDR_VAR 0 4
30983: PUSH
30984: LD_VAR 0 3
30988: PPUSH
30989: CALL_OW 313
30993: PUSH
30994: FOR_IN
30995: IFFALSE 31042
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30997: LD_VAR 0 4
31001: PPUSH
31002: CALL_OW 257
31006: PUSH
31007: LD_INT 1
31009: EQUAL
31010: PUSH
31011: LD_VAR 0 4
31015: PPUSH
31016: CALL_OW 459
31020: NOT
31021: AND
31022: IFFALSE 31040
// list := list ^ k ;
31024: LD_ADDR_VAR 0 6
31028: PUSH
31029: LD_VAR 0 6
31033: PUSH
31034: LD_VAR 0 4
31038: ADD
31039: ST_TO_ADDR
31040: GO 30994
31042: POP
31043: POP
// end ;
31044: GO 30976
31046: POP
31047: POP
// list := list diff mc_miners [ i ] ;
31048: LD_ADDR_VAR 0 6
31052: PUSH
31053: LD_VAR 0 6
31057: PUSH
31058: LD_EXP 64
31062: PUSH
31063: LD_VAR 0 2
31067: ARRAY
31068: DIFF
31069: ST_TO_ADDR
// if not list then
31070: LD_VAR 0 6
31074: NOT
31075: IFFALSE 31079
// continue ;
31077: GO 30452
// k := mc_mines [ i ] - mc_miners [ i ] ;
31079: LD_ADDR_VAR 0 4
31083: PUSH
31084: LD_EXP 63
31088: PUSH
31089: LD_VAR 0 2
31093: ARRAY
31094: PUSH
31095: LD_EXP 64
31099: PUSH
31100: LD_VAR 0 2
31104: ARRAY
31105: MINUS
31106: ST_TO_ADDR
// if k > list then
31107: LD_VAR 0 4
31111: PUSH
31112: LD_VAR 0 6
31116: GREATER
31117: IFFALSE 31129
// k := list ;
31119: LD_ADDR_VAR 0 4
31123: PUSH
31124: LD_VAR 0 6
31128: ST_TO_ADDR
// for j = 1 to k do
31129: LD_ADDR_VAR 0 3
31133: PUSH
31134: DOUBLE
31135: LD_INT 1
31137: DEC
31138: ST_TO_ADDR
31139: LD_VAR 0 4
31143: PUSH
31144: FOR_TO
31145: IFFALSE 31199
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31147: LD_ADDR_EXP 64
31151: PUSH
31152: LD_EXP 64
31156: PPUSH
31157: LD_VAR 0 2
31161: PUSH
31162: LD_EXP 64
31166: PUSH
31167: LD_VAR 0 2
31171: ARRAY
31172: PUSH
31173: LD_INT 1
31175: PLUS
31176: PUSH
31177: EMPTY
31178: LIST
31179: LIST
31180: PPUSH
31181: LD_VAR 0 6
31185: PUSH
31186: LD_VAR 0 3
31190: ARRAY
31191: PPUSH
31192: CALL 53564 0 3
31196: ST_TO_ADDR
31197: GO 31144
31199: POP
31200: POP
// end ;
31201: GO 30452
31203: POP
31204: POP
// end ;
31205: LD_VAR 0 1
31209: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31210: LD_INT 0
31212: PPUSH
31213: PPUSH
31214: PPUSH
31215: PPUSH
31216: PPUSH
31217: PPUSH
31218: PPUSH
31219: PPUSH
31220: PPUSH
31221: PPUSH
31222: PPUSH
// if not mc_bases then
31223: LD_EXP 50
31227: NOT
31228: IFFALSE 31232
// exit ;
31230: GO 33055
// for i = 1 to mc_bases do
31232: LD_ADDR_VAR 0 2
31236: PUSH
31237: DOUBLE
31238: LD_INT 1
31240: DEC
31241: ST_TO_ADDR
31242: LD_EXP 50
31246: PUSH
31247: FOR_TO
31248: IFFALSE 33053
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31250: LD_EXP 50
31254: PUSH
31255: LD_VAR 0 2
31259: ARRAY
31260: NOT
31261: PUSH
31262: LD_EXP 57
31266: PUSH
31267: LD_VAR 0 2
31271: ARRAY
31272: OR
31273: IFFALSE 31277
// continue ;
31275: GO 31247
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31277: LD_EXP 66
31281: PUSH
31282: LD_VAR 0 2
31286: ARRAY
31287: NOT
31288: PUSH
31289: LD_EXP 67
31293: PUSH
31294: LD_VAR 0 2
31298: ARRAY
31299: AND
31300: IFFALSE 31338
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31302: LD_ADDR_EXP 67
31306: PUSH
31307: LD_EXP 67
31311: PPUSH
31312: LD_VAR 0 2
31316: PPUSH
31317: EMPTY
31318: PPUSH
31319: CALL_OW 1
31323: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31324: LD_VAR 0 2
31328: PPUSH
31329: LD_INT 107
31331: PPUSH
31332: CALL 22106 0 2
// continue ;
31336: GO 31247
// end ; target := [ ] ;
31338: LD_ADDR_VAR 0 7
31342: PUSH
31343: EMPTY
31344: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31345: LD_ADDR_VAR 0 6
31349: PUSH
31350: LD_EXP 50
31354: PUSH
31355: LD_VAR 0 2
31359: ARRAY
31360: PUSH
31361: LD_INT 1
31363: ARRAY
31364: PPUSH
31365: CALL_OW 255
31369: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31370: LD_ADDR_VAR 0 9
31374: PUSH
31375: LD_EXP 50
31379: PUSH
31380: LD_VAR 0 2
31384: ARRAY
31385: PPUSH
31386: LD_INT 2
31388: PUSH
31389: LD_INT 30
31391: PUSH
31392: LD_INT 0
31394: PUSH
31395: EMPTY
31396: LIST
31397: LIST
31398: PUSH
31399: LD_INT 30
31401: PUSH
31402: LD_INT 1
31404: PUSH
31405: EMPTY
31406: LIST
31407: LIST
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: LIST
31413: PPUSH
31414: CALL_OW 72
31418: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31419: LD_ADDR_VAR 0 3
31423: PUSH
31424: DOUBLE
31425: LD_EXP 66
31429: PUSH
31430: LD_VAR 0 2
31434: ARRAY
31435: INC
31436: ST_TO_ADDR
31437: LD_INT 1
31439: PUSH
31440: FOR_DOWNTO
31441: IFFALSE 31686
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31443: LD_EXP 66
31447: PUSH
31448: LD_VAR 0 2
31452: ARRAY
31453: PUSH
31454: LD_VAR 0 3
31458: ARRAY
31459: PUSH
31460: LD_INT 2
31462: ARRAY
31463: PPUSH
31464: LD_EXP 66
31468: PUSH
31469: LD_VAR 0 2
31473: ARRAY
31474: PUSH
31475: LD_VAR 0 3
31479: ARRAY
31480: PUSH
31481: LD_INT 3
31483: ARRAY
31484: PPUSH
31485: CALL_OW 488
31489: PUSH
31490: LD_EXP 66
31494: PUSH
31495: LD_VAR 0 2
31499: ARRAY
31500: PUSH
31501: LD_VAR 0 3
31505: ARRAY
31506: PUSH
31507: LD_INT 2
31509: ARRAY
31510: PPUSH
31511: LD_EXP 66
31515: PUSH
31516: LD_VAR 0 2
31520: ARRAY
31521: PUSH
31522: LD_VAR 0 3
31526: ARRAY
31527: PUSH
31528: LD_INT 3
31530: ARRAY
31531: PPUSH
31532: CALL_OW 284
31536: PUSH
31537: LD_INT 0
31539: EQUAL
31540: AND
31541: IFFALSE 31596
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31543: LD_ADDR_VAR 0 5
31547: PUSH
31548: LD_EXP 66
31552: PUSH
31553: LD_VAR 0 2
31557: ARRAY
31558: PPUSH
31559: LD_VAR 0 3
31563: PPUSH
31564: CALL_OW 3
31568: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31569: LD_ADDR_EXP 66
31573: PUSH
31574: LD_EXP 66
31578: PPUSH
31579: LD_VAR 0 2
31583: PPUSH
31584: LD_VAR 0 5
31588: PPUSH
31589: CALL_OW 1
31593: ST_TO_ADDR
// continue ;
31594: GO 31440
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31596: LD_VAR 0 6
31600: PPUSH
31601: LD_EXP 66
31605: PUSH
31606: LD_VAR 0 2
31610: ARRAY
31611: PUSH
31612: LD_VAR 0 3
31616: ARRAY
31617: PUSH
31618: LD_INT 2
31620: ARRAY
31621: PPUSH
31622: LD_EXP 66
31626: PUSH
31627: LD_VAR 0 2
31631: ARRAY
31632: PUSH
31633: LD_VAR 0 3
31637: ARRAY
31638: PUSH
31639: LD_INT 3
31641: ARRAY
31642: PPUSH
31643: LD_INT 30
31645: PPUSH
31646: CALL 54460 0 4
31650: PUSH
31651: LD_INT 4
31653: ARRAY
31654: PUSH
31655: LD_INT 0
31657: EQUAL
31658: IFFALSE 31684
// begin target := mc_crates [ i ] [ j ] ;
31660: LD_ADDR_VAR 0 7
31664: PUSH
31665: LD_EXP 66
31669: PUSH
31670: LD_VAR 0 2
31674: ARRAY
31675: PUSH
31676: LD_VAR 0 3
31680: ARRAY
31681: ST_TO_ADDR
// break ;
31682: GO 31686
// end ; end ;
31684: GO 31440
31686: POP
31687: POP
// if not target then
31688: LD_VAR 0 7
31692: NOT
31693: IFFALSE 31697
// continue ;
31695: GO 31247
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31697: LD_ADDR_VAR 0 8
31701: PUSH
31702: LD_EXP 69
31706: PUSH
31707: LD_VAR 0 2
31711: ARRAY
31712: PPUSH
31713: LD_INT 2
31715: PUSH
31716: LD_INT 3
31718: PUSH
31719: LD_INT 58
31721: PUSH
31722: EMPTY
31723: LIST
31724: PUSH
31725: EMPTY
31726: LIST
31727: LIST
31728: PUSH
31729: LD_INT 61
31731: PUSH
31732: EMPTY
31733: LIST
31734: PUSH
31735: LD_INT 33
31737: PUSH
31738: LD_INT 5
31740: PUSH
31741: EMPTY
31742: LIST
31743: LIST
31744: PUSH
31745: LD_INT 33
31747: PUSH
31748: LD_INT 3
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: LIST
31759: LIST
31760: LIST
31761: PUSH
31762: LD_INT 2
31764: PUSH
31765: LD_INT 34
31767: PUSH
31768: LD_INT 32
31770: PUSH
31771: EMPTY
31772: LIST
31773: LIST
31774: PUSH
31775: LD_INT 34
31777: PUSH
31778: LD_INT 51
31780: PUSH
31781: EMPTY
31782: LIST
31783: LIST
31784: PUSH
31785: LD_INT 34
31787: PUSH
31788: LD_INT 12
31790: PUSH
31791: EMPTY
31792: LIST
31793: LIST
31794: PUSH
31795: EMPTY
31796: LIST
31797: LIST
31798: LIST
31799: LIST
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PPUSH
31805: CALL_OW 72
31809: ST_TO_ADDR
// if not cargo then
31810: LD_VAR 0 8
31814: NOT
31815: IFFALSE 32521
// begin if mc_crates_collector [ i ] < 5 then
31817: LD_EXP 67
31821: PUSH
31822: LD_VAR 0 2
31826: ARRAY
31827: PUSH
31828: LD_INT 5
31830: LESS
31831: IFFALSE 32197
// begin if mc_ape [ i ] then
31833: LD_EXP 79
31837: PUSH
31838: LD_VAR 0 2
31842: ARRAY
31843: IFFALSE 31890
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31845: LD_ADDR_VAR 0 5
31849: PUSH
31850: LD_EXP 79
31854: PUSH
31855: LD_VAR 0 2
31859: ARRAY
31860: PPUSH
31861: LD_INT 25
31863: PUSH
31864: LD_INT 16
31866: PUSH
31867: EMPTY
31868: LIST
31869: LIST
31870: PUSH
31871: LD_INT 24
31873: PUSH
31874: LD_INT 750
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: EMPTY
31882: LIST
31883: LIST
31884: PPUSH
31885: CALL_OW 72
31889: ST_TO_ADDR
// if not tmp then
31890: LD_VAR 0 5
31894: NOT
31895: IFFALSE 31942
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31897: LD_ADDR_VAR 0 5
31901: PUSH
31902: LD_EXP 50
31906: PUSH
31907: LD_VAR 0 2
31911: ARRAY
31912: PPUSH
31913: LD_INT 25
31915: PUSH
31916: LD_INT 2
31918: PUSH
31919: EMPTY
31920: LIST
31921: LIST
31922: PUSH
31923: LD_INT 24
31925: PUSH
31926: LD_INT 750
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PPUSH
31937: CALL_OW 72
31941: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31942: LD_EXP 79
31946: PUSH
31947: LD_VAR 0 2
31951: ARRAY
31952: PUSH
31953: LD_EXP 50
31957: PUSH
31958: LD_VAR 0 2
31962: ARRAY
31963: PPUSH
31964: LD_INT 25
31966: PUSH
31967: LD_INT 2
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 24
31976: PUSH
31977: LD_INT 750
31979: PUSH
31980: EMPTY
31981: LIST
31982: LIST
31983: PUSH
31984: EMPTY
31985: LIST
31986: LIST
31987: PPUSH
31988: CALL_OW 72
31992: AND
31993: PUSH
31994: LD_VAR 0 5
31998: PUSH
31999: LD_INT 5
32001: LESS
32002: AND
32003: IFFALSE 32085
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32005: LD_ADDR_VAR 0 3
32009: PUSH
32010: LD_EXP 50
32014: PUSH
32015: LD_VAR 0 2
32019: ARRAY
32020: PPUSH
32021: LD_INT 25
32023: PUSH
32024: LD_INT 2
32026: PUSH
32027: EMPTY
32028: LIST
32029: LIST
32030: PUSH
32031: LD_INT 24
32033: PUSH
32034: LD_INT 750
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PPUSH
32045: CALL_OW 72
32049: PUSH
32050: FOR_IN
32051: IFFALSE 32083
// begin tmp := tmp union j ;
32053: LD_ADDR_VAR 0 5
32057: PUSH
32058: LD_VAR 0 5
32062: PUSH
32063: LD_VAR 0 3
32067: UNION
32068: ST_TO_ADDR
// if tmp >= 5 then
32069: LD_VAR 0 5
32073: PUSH
32074: LD_INT 5
32076: GREATEREQUAL
32077: IFFALSE 32081
// break ;
32079: GO 32083
// end ;
32081: GO 32050
32083: POP
32084: POP
// end ; if not tmp then
32085: LD_VAR 0 5
32089: NOT
32090: IFFALSE 32094
// continue ;
32092: GO 31247
// for j in tmp do
32094: LD_ADDR_VAR 0 3
32098: PUSH
32099: LD_VAR 0 5
32103: PUSH
32104: FOR_IN
32105: IFFALSE 32195
// if not GetTag ( j ) then
32107: LD_VAR 0 3
32111: PPUSH
32112: CALL_OW 110
32116: NOT
32117: IFFALSE 32193
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32119: LD_ADDR_EXP 67
32123: PUSH
32124: LD_EXP 67
32128: PPUSH
32129: LD_VAR 0 2
32133: PUSH
32134: LD_EXP 67
32138: PUSH
32139: LD_VAR 0 2
32143: ARRAY
32144: PUSH
32145: LD_INT 1
32147: PLUS
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PPUSH
32153: LD_VAR 0 3
32157: PPUSH
32158: CALL 53564 0 3
32162: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32163: LD_VAR 0 3
32167: PPUSH
32168: LD_INT 107
32170: PPUSH
32171: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32175: LD_EXP 67
32179: PUSH
32180: LD_VAR 0 2
32184: ARRAY
32185: PUSH
32186: LD_INT 5
32188: GREATEREQUAL
32189: IFFALSE 32193
// break ;
32191: GO 32195
// end ;
32193: GO 32104
32195: POP
32196: POP
// end ; if mc_crates_collector [ i ] and target then
32197: LD_EXP 67
32201: PUSH
32202: LD_VAR 0 2
32206: ARRAY
32207: PUSH
32208: LD_VAR 0 7
32212: AND
32213: IFFALSE 32519
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32215: LD_EXP 67
32219: PUSH
32220: LD_VAR 0 2
32224: ARRAY
32225: PUSH
32226: LD_VAR 0 7
32230: PUSH
32231: LD_INT 1
32233: ARRAY
32234: LESS
32235: IFFALSE 32255
// tmp := mc_crates_collector [ i ] else
32237: LD_ADDR_VAR 0 5
32241: PUSH
32242: LD_EXP 67
32246: PUSH
32247: LD_VAR 0 2
32251: ARRAY
32252: ST_TO_ADDR
32253: GO 32269
// tmp := target [ 1 ] ;
32255: LD_ADDR_VAR 0 5
32259: PUSH
32260: LD_VAR 0 7
32264: PUSH
32265: LD_INT 1
32267: ARRAY
32268: ST_TO_ADDR
// k := 0 ;
32269: LD_ADDR_VAR 0 4
32273: PUSH
32274: LD_INT 0
32276: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32277: LD_ADDR_VAR 0 3
32281: PUSH
32282: LD_EXP 67
32286: PUSH
32287: LD_VAR 0 2
32291: ARRAY
32292: PUSH
32293: FOR_IN
32294: IFFALSE 32517
// begin k := k + 1 ;
32296: LD_ADDR_VAR 0 4
32300: PUSH
32301: LD_VAR 0 4
32305: PUSH
32306: LD_INT 1
32308: PLUS
32309: ST_TO_ADDR
// if k > tmp then
32310: LD_VAR 0 4
32314: PUSH
32315: LD_VAR 0 5
32319: GREATER
32320: IFFALSE 32324
// break ;
32322: GO 32517
// if not GetClass ( j ) in [ 2 , 16 ] then
32324: LD_VAR 0 3
32328: PPUSH
32329: CALL_OW 257
32333: PUSH
32334: LD_INT 2
32336: PUSH
32337: LD_INT 16
32339: PUSH
32340: EMPTY
32341: LIST
32342: LIST
32343: IN
32344: NOT
32345: IFFALSE 32398
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32347: LD_ADDR_EXP 67
32351: PUSH
32352: LD_EXP 67
32356: PPUSH
32357: LD_VAR 0 2
32361: PPUSH
32362: LD_EXP 67
32366: PUSH
32367: LD_VAR 0 2
32371: ARRAY
32372: PUSH
32373: LD_VAR 0 3
32377: DIFF
32378: PPUSH
32379: CALL_OW 1
32383: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32384: LD_VAR 0 3
32388: PPUSH
32389: LD_INT 0
32391: PPUSH
32392: CALL_OW 109
// continue ;
32396: GO 32293
// end ; if IsInUnit ( j ) then
32398: LD_VAR 0 3
32402: PPUSH
32403: CALL_OW 310
32407: IFFALSE 32418
// ComExitBuilding ( j ) ;
32409: LD_VAR 0 3
32413: PPUSH
32414: CALL_OW 122
// wait ( 3 ) ;
32418: LD_INT 3
32420: PPUSH
32421: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32425: LD_VAR 0 3
32429: PPUSH
32430: CALL_OW 314
32434: PUSH
32435: LD_VAR 0 6
32439: PPUSH
32440: LD_VAR 0 7
32444: PUSH
32445: LD_INT 2
32447: ARRAY
32448: PPUSH
32449: LD_VAR 0 7
32453: PUSH
32454: LD_INT 3
32456: ARRAY
32457: PPUSH
32458: LD_INT 30
32460: PPUSH
32461: CALL 54460 0 4
32465: PUSH
32466: LD_INT 4
32468: ARRAY
32469: AND
32470: IFFALSE 32488
// ComStandNearbyBuilding ( j , depot ) else
32472: LD_VAR 0 3
32476: PPUSH
32477: LD_VAR 0 9
32481: PPUSH
32482: CALL 50142 0 2
32486: GO 32515
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32488: LD_VAR 0 3
32492: PPUSH
32493: LD_VAR 0 7
32497: PUSH
32498: LD_INT 2
32500: ARRAY
32501: PPUSH
32502: LD_VAR 0 7
32506: PUSH
32507: LD_INT 3
32509: ARRAY
32510: PPUSH
32511: CALL_OW 117
// end ;
32515: GO 32293
32517: POP
32518: POP
// end ; end else
32519: GO 33051
// begin for j in cargo do
32521: LD_ADDR_VAR 0 3
32525: PUSH
32526: LD_VAR 0 8
32530: PUSH
32531: FOR_IN
32532: IFFALSE 33049
// begin if GetTag ( j ) <> 0 then
32534: LD_VAR 0 3
32538: PPUSH
32539: CALL_OW 110
32543: PUSH
32544: LD_INT 0
32546: NONEQUAL
32547: IFFALSE 32551
// continue ;
32549: GO 32531
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32551: LD_VAR 0 3
32555: PPUSH
32556: CALL_OW 256
32560: PUSH
32561: LD_INT 1000
32563: LESS
32564: PUSH
32565: LD_VAR 0 3
32569: PPUSH
32570: LD_EXP 74
32574: PUSH
32575: LD_VAR 0 2
32579: ARRAY
32580: PPUSH
32581: CALL_OW 308
32585: NOT
32586: AND
32587: IFFALSE 32609
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32589: LD_VAR 0 3
32593: PPUSH
32594: LD_EXP 74
32598: PUSH
32599: LD_VAR 0 2
32603: ARRAY
32604: PPUSH
32605: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32609: LD_VAR 0 3
32613: PPUSH
32614: CALL_OW 256
32618: PUSH
32619: LD_INT 1000
32621: LESS
32622: PUSH
32623: LD_VAR 0 3
32627: PPUSH
32628: LD_EXP 74
32632: PUSH
32633: LD_VAR 0 2
32637: ARRAY
32638: PPUSH
32639: CALL_OW 308
32643: AND
32644: IFFALSE 32648
// continue ;
32646: GO 32531
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32648: LD_VAR 0 3
32652: PPUSH
32653: CALL_OW 262
32657: PUSH
32658: LD_INT 2
32660: EQUAL
32661: PUSH
32662: LD_VAR 0 3
32666: PPUSH
32667: CALL_OW 261
32671: PUSH
32672: LD_INT 15
32674: LESS
32675: AND
32676: IFFALSE 32680
// continue ;
32678: GO 32531
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32680: LD_VAR 0 3
32684: PPUSH
32685: CALL_OW 262
32689: PUSH
32690: LD_INT 1
32692: EQUAL
32693: PUSH
32694: LD_VAR 0 3
32698: PPUSH
32699: CALL_OW 261
32703: PUSH
32704: LD_INT 10
32706: LESS
32707: AND
32708: IFFALSE 32988
// begin if not depot then
32710: LD_VAR 0 9
32714: NOT
32715: IFFALSE 32719
// continue ;
32717: GO 32531
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32719: LD_VAR 0 3
32723: PPUSH
32724: LD_VAR 0 9
32728: PPUSH
32729: LD_VAR 0 3
32733: PPUSH
32734: CALL_OW 74
32738: PPUSH
32739: CALL_OW 296
32743: PUSH
32744: LD_INT 6
32746: LESS
32747: IFFALSE 32763
// SetFuel ( j , 100 ) else
32749: LD_VAR 0 3
32753: PPUSH
32754: LD_INT 100
32756: PPUSH
32757: CALL_OW 240
32761: GO 32988
// if GetFuel ( j ) = 0 then
32763: LD_VAR 0 3
32767: PPUSH
32768: CALL_OW 261
32772: PUSH
32773: LD_INT 0
32775: EQUAL
32776: IFFALSE 32988
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32778: LD_ADDR_EXP 69
32782: PUSH
32783: LD_EXP 69
32787: PPUSH
32788: LD_VAR 0 2
32792: PPUSH
32793: LD_EXP 69
32797: PUSH
32798: LD_VAR 0 2
32802: ARRAY
32803: PUSH
32804: LD_VAR 0 3
32808: DIFF
32809: PPUSH
32810: CALL_OW 1
32814: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32815: LD_VAR 0 3
32819: PPUSH
32820: CALL_OW 263
32824: PUSH
32825: LD_INT 1
32827: EQUAL
32828: IFFALSE 32844
// ComExitVehicle ( IsInUnit ( j ) ) ;
32830: LD_VAR 0 3
32834: PPUSH
32835: CALL_OW 310
32839: PPUSH
32840: CALL_OW 121
// if GetControl ( j ) = control_remote then
32844: LD_VAR 0 3
32848: PPUSH
32849: CALL_OW 263
32853: PUSH
32854: LD_INT 2
32856: EQUAL
32857: IFFALSE 32868
// ComUnlink ( j ) ;
32859: LD_VAR 0 3
32863: PPUSH
32864: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32868: LD_ADDR_VAR 0 10
32872: PUSH
32873: LD_VAR 0 2
32877: PPUSH
32878: LD_INT 3
32880: PPUSH
32881: CALL 42627 0 2
32885: ST_TO_ADDR
// if fac then
32886: LD_VAR 0 10
32890: IFFALSE 32986
// begin for k in fac do
32892: LD_ADDR_VAR 0 4
32896: PUSH
32897: LD_VAR 0 10
32901: PUSH
32902: FOR_IN
32903: IFFALSE 32984
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32905: LD_ADDR_VAR 0 11
32909: PUSH
32910: LD_VAR 0 10
32914: PPUSH
32915: LD_VAR 0 3
32919: PPUSH
32920: CALL_OW 265
32924: PPUSH
32925: LD_VAR 0 3
32929: PPUSH
32930: CALL_OW 262
32934: PPUSH
32935: LD_VAR 0 3
32939: PPUSH
32940: CALL_OW 263
32944: PPUSH
32945: LD_VAR 0 3
32949: PPUSH
32950: CALL_OW 264
32954: PPUSH
32955: CALL 51060 0 5
32959: ST_TO_ADDR
// if components then
32960: LD_VAR 0 11
32964: IFFALSE 32982
// begin MC_InsertProduceList ( i , components ) ;
32966: LD_VAR 0 2
32970: PPUSH
32971: LD_VAR 0 11
32975: PPUSH
32976: CALL 42172 0 2
// break ;
32980: GO 32984
// end ; end ;
32982: GO 32902
32984: POP
32985: POP
// end ; continue ;
32986: GO 32531
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32988: LD_VAR 0 3
32992: PPUSH
32993: LD_INT 1
32995: PPUSH
32996: CALL_OW 289
33000: PUSH
33001: LD_INT 100
33003: LESS
33004: PUSH
33005: LD_VAR 0 3
33009: PPUSH
33010: CALL_OW 314
33014: NOT
33015: AND
33016: IFFALSE 33045
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33018: LD_VAR 0 3
33022: PPUSH
33023: LD_VAR 0 7
33027: PUSH
33028: LD_INT 2
33030: ARRAY
33031: PPUSH
33032: LD_VAR 0 7
33036: PUSH
33037: LD_INT 3
33039: ARRAY
33040: PPUSH
33041: CALL_OW 117
// break ;
33045: GO 33049
// end ;
33047: GO 32531
33049: POP
33050: POP
// end ; end ;
33051: GO 31247
33053: POP
33054: POP
// end ;
33055: LD_VAR 0 1
33059: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33060: LD_INT 0
33062: PPUSH
33063: PPUSH
33064: PPUSH
33065: PPUSH
// if not mc_bases then
33066: LD_EXP 50
33070: NOT
33071: IFFALSE 33075
// exit ;
33073: GO 33236
// for i = 1 to mc_bases do
33075: LD_ADDR_VAR 0 2
33079: PUSH
33080: DOUBLE
33081: LD_INT 1
33083: DEC
33084: ST_TO_ADDR
33085: LD_EXP 50
33089: PUSH
33090: FOR_TO
33091: IFFALSE 33234
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33093: LD_ADDR_VAR 0 4
33097: PUSH
33098: LD_EXP 69
33102: PUSH
33103: LD_VAR 0 2
33107: ARRAY
33108: PUSH
33109: LD_EXP 72
33113: PUSH
33114: LD_VAR 0 2
33118: ARRAY
33119: UNION
33120: PPUSH
33121: LD_INT 33
33123: PUSH
33124: LD_INT 2
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PPUSH
33131: CALL_OW 72
33135: ST_TO_ADDR
// if tmp then
33136: LD_VAR 0 4
33140: IFFALSE 33232
// for j in tmp do
33142: LD_ADDR_VAR 0 3
33146: PUSH
33147: LD_VAR 0 4
33151: PUSH
33152: FOR_IN
33153: IFFALSE 33230
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33155: LD_VAR 0 3
33159: PPUSH
33160: CALL_OW 312
33164: NOT
33165: PUSH
33166: LD_VAR 0 3
33170: PPUSH
33171: CALL_OW 256
33175: PUSH
33176: LD_INT 250
33178: GREATEREQUAL
33179: AND
33180: IFFALSE 33193
// Connect ( j ) else
33182: LD_VAR 0 3
33186: PPUSH
33187: CALL 56535 0 1
33191: GO 33228
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33193: LD_VAR 0 3
33197: PPUSH
33198: CALL_OW 256
33202: PUSH
33203: LD_INT 250
33205: LESS
33206: PUSH
33207: LD_VAR 0 3
33211: PPUSH
33212: CALL_OW 312
33216: AND
33217: IFFALSE 33228
// ComUnlink ( j ) ;
33219: LD_VAR 0 3
33223: PPUSH
33224: CALL_OW 136
33228: GO 33152
33230: POP
33231: POP
// end ;
33232: GO 33090
33234: POP
33235: POP
// end ;
33236: LD_VAR 0 1
33240: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33241: LD_INT 0
33243: PPUSH
33244: PPUSH
33245: PPUSH
33246: PPUSH
33247: PPUSH
// if not mc_bases then
33248: LD_EXP 50
33252: NOT
33253: IFFALSE 33257
// exit ;
33255: GO 33702
// for i = 1 to mc_bases do
33257: LD_ADDR_VAR 0 2
33261: PUSH
33262: DOUBLE
33263: LD_INT 1
33265: DEC
33266: ST_TO_ADDR
33267: LD_EXP 50
33271: PUSH
33272: FOR_TO
33273: IFFALSE 33700
// begin if not mc_produce [ i ] then
33275: LD_EXP 71
33279: PUSH
33280: LD_VAR 0 2
33284: ARRAY
33285: NOT
33286: IFFALSE 33290
// continue ;
33288: GO 33272
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33290: LD_ADDR_VAR 0 5
33294: PUSH
33295: LD_EXP 50
33299: PUSH
33300: LD_VAR 0 2
33304: ARRAY
33305: PPUSH
33306: LD_INT 30
33308: PUSH
33309: LD_INT 3
33311: PUSH
33312: EMPTY
33313: LIST
33314: LIST
33315: PPUSH
33316: CALL_OW 72
33320: ST_TO_ADDR
// if not fac then
33321: LD_VAR 0 5
33325: NOT
33326: IFFALSE 33330
// continue ;
33328: GO 33272
// for j in fac do
33330: LD_ADDR_VAR 0 3
33334: PUSH
33335: LD_VAR 0 5
33339: PUSH
33340: FOR_IN
33341: IFFALSE 33696
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33343: LD_VAR 0 3
33347: PPUSH
33348: CALL_OW 461
33352: PUSH
33353: LD_INT 2
33355: NONEQUAL
33356: PUSH
33357: LD_VAR 0 3
33361: PPUSH
33362: LD_INT 15
33364: PPUSH
33365: CALL 56163 0 2
33369: PUSH
33370: LD_INT 4
33372: ARRAY
33373: OR
33374: IFFALSE 33378
// continue ;
33376: GO 33340
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33378: LD_VAR 0 3
33382: PPUSH
33383: LD_EXP 71
33387: PUSH
33388: LD_VAR 0 2
33392: ARRAY
33393: PUSH
33394: LD_INT 1
33396: ARRAY
33397: PUSH
33398: LD_INT 1
33400: ARRAY
33401: PPUSH
33402: LD_EXP 71
33406: PUSH
33407: LD_VAR 0 2
33411: ARRAY
33412: PUSH
33413: LD_INT 1
33415: ARRAY
33416: PUSH
33417: LD_INT 2
33419: ARRAY
33420: PPUSH
33421: LD_EXP 71
33425: PUSH
33426: LD_VAR 0 2
33430: ARRAY
33431: PUSH
33432: LD_INT 1
33434: ARRAY
33435: PUSH
33436: LD_INT 3
33438: ARRAY
33439: PPUSH
33440: LD_EXP 71
33444: PUSH
33445: LD_VAR 0 2
33449: ARRAY
33450: PUSH
33451: LD_INT 1
33453: ARRAY
33454: PUSH
33455: LD_INT 4
33457: ARRAY
33458: PPUSH
33459: CALL_OW 448
33463: PUSH
33464: LD_VAR 0 3
33468: PPUSH
33469: LD_EXP 71
33473: PUSH
33474: LD_VAR 0 2
33478: ARRAY
33479: PUSH
33480: LD_INT 1
33482: ARRAY
33483: PUSH
33484: LD_INT 1
33486: ARRAY
33487: PUSH
33488: LD_EXP 71
33492: PUSH
33493: LD_VAR 0 2
33497: ARRAY
33498: PUSH
33499: LD_INT 1
33501: ARRAY
33502: PUSH
33503: LD_INT 2
33505: ARRAY
33506: PUSH
33507: LD_EXP 71
33511: PUSH
33512: LD_VAR 0 2
33516: ARRAY
33517: PUSH
33518: LD_INT 1
33520: ARRAY
33521: PUSH
33522: LD_INT 3
33524: ARRAY
33525: PUSH
33526: LD_EXP 71
33530: PUSH
33531: LD_VAR 0 2
33535: ARRAY
33536: PUSH
33537: LD_INT 1
33539: ARRAY
33540: PUSH
33541: LD_INT 4
33543: ARRAY
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: LIST
33549: LIST
33550: PPUSH
33551: CALL 59930 0 2
33555: AND
33556: IFFALSE 33694
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33558: LD_VAR 0 3
33562: PPUSH
33563: LD_EXP 71
33567: PUSH
33568: LD_VAR 0 2
33572: ARRAY
33573: PUSH
33574: LD_INT 1
33576: ARRAY
33577: PUSH
33578: LD_INT 1
33580: ARRAY
33581: PPUSH
33582: LD_EXP 71
33586: PUSH
33587: LD_VAR 0 2
33591: ARRAY
33592: PUSH
33593: LD_INT 1
33595: ARRAY
33596: PUSH
33597: LD_INT 2
33599: ARRAY
33600: PPUSH
33601: LD_EXP 71
33605: PUSH
33606: LD_VAR 0 2
33610: ARRAY
33611: PUSH
33612: LD_INT 1
33614: ARRAY
33615: PUSH
33616: LD_INT 3
33618: ARRAY
33619: PPUSH
33620: LD_EXP 71
33624: PUSH
33625: LD_VAR 0 2
33629: ARRAY
33630: PUSH
33631: LD_INT 1
33633: ARRAY
33634: PUSH
33635: LD_INT 4
33637: ARRAY
33638: PPUSH
33639: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33643: LD_ADDR_VAR 0 4
33647: PUSH
33648: LD_EXP 71
33652: PUSH
33653: LD_VAR 0 2
33657: ARRAY
33658: PPUSH
33659: LD_INT 1
33661: PPUSH
33662: CALL_OW 3
33666: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33667: LD_ADDR_EXP 71
33671: PUSH
33672: LD_EXP 71
33676: PPUSH
33677: LD_VAR 0 2
33681: PPUSH
33682: LD_VAR 0 4
33686: PPUSH
33687: CALL_OW 1
33691: ST_TO_ADDR
// break ;
33692: GO 33696
// end ; end ;
33694: GO 33340
33696: POP
33697: POP
// end ;
33698: GO 33272
33700: POP
33701: POP
// end ;
33702: LD_VAR 0 1
33706: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33707: LD_INT 0
33709: PPUSH
33710: PPUSH
33711: PPUSH
// if not mc_bases then
33712: LD_EXP 50
33716: NOT
33717: IFFALSE 33721
// exit ;
33719: GO 33810
// for i = 1 to mc_bases do
33721: LD_ADDR_VAR 0 2
33725: PUSH
33726: DOUBLE
33727: LD_INT 1
33729: DEC
33730: ST_TO_ADDR
33731: LD_EXP 50
33735: PUSH
33736: FOR_TO
33737: IFFALSE 33808
// begin if mc_attack [ i ] then
33739: LD_EXP 70
33743: PUSH
33744: LD_VAR 0 2
33748: ARRAY
33749: IFFALSE 33806
// begin tmp := mc_attack [ i ] [ 1 ] ;
33751: LD_ADDR_VAR 0 3
33755: PUSH
33756: LD_EXP 70
33760: PUSH
33761: LD_VAR 0 2
33765: ARRAY
33766: PUSH
33767: LD_INT 1
33769: ARRAY
33770: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33771: LD_ADDR_EXP 70
33775: PUSH
33776: LD_EXP 70
33780: PPUSH
33781: LD_VAR 0 2
33785: PPUSH
33786: EMPTY
33787: PPUSH
33788: CALL_OW 1
33792: ST_TO_ADDR
// Attack ( tmp ) ;
33793: LD_VAR 0 3
33797: PPUSH
33798: CALL 107755 0 1
// exit ;
33802: POP
33803: POP
33804: GO 33810
// end ; end ;
33806: GO 33736
33808: POP
33809: POP
// end ;
33810: LD_VAR 0 1
33814: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33815: LD_INT 0
33817: PPUSH
33818: PPUSH
33819: PPUSH
33820: PPUSH
33821: PPUSH
33822: PPUSH
33823: PPUSH
// if not mc_bases then
33824: LD_EXP 50
33828: NOT
33829: IFFALSE 33833
// exit ;
33831: GO 34690
// for i = 1 to mc_bases do
33833: LD_ADDR_VAR 0 2
33837: PUSH
33838: DOUBLE
33839: LD_INT 1
33841: DEC
33842: ST_TO_ADDR
33843: LD_EXP 50
33847: PUSH
33848: FOR_TO
33849: IFFALSE 34688
// begin if not mc_bases [ i ] then
33851: LD_EXP 50
33855: PUSH
33856: LD_VAR 0 2
33860: ARRAY
33861: NOT
33862: IFFALSE 33866
// continue ;
33864: GO 33848
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33866: LD_ADDR_VAR 0 7
33870: PUSH
33871: LD_EXP 50
33875: PUSH
33876: LD_VAR 0 2
33880: ARRAY
33881: PUSH
33882: LD_INT 1
33884: ARRAY
33885: PPUSH
33886: CALL 50364 0 1
33890: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33891: LD_ADDR_EXP 73
33895: PUSH
33896: LD_EXP 73
33900: PPUSH
33901: LD_VAR 0 2
33905: PPUSH
33906: LD_EXP 50
33910: PUSH
33911: LD_VAR 0 2
33915: ARRAY
33916: PUSH
33917: LD_INT 1
33919: ARRAY
33920: PPUSH
33921: CALL_OW 255
33925: PPUSH
33926: LD_EXP 75
33930: PUSH
33931: LD_VAR 0 2
33935: ARRAY
33936: PPUSH
33937: CALL 50329 0 2
33941: PPUSH
33942: CALL_OW 1
33946: ST_TO_ADDR
// if not mc_scan [ i ] then
33947: LD_EXP 73
33951: PUSH
33952: LD_VAR 0 2
33956: ARRAY
33957: NOT
33958: IFFALSE 34136
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
33960: LD_ADDR_EXP 93
33964: PUSH
33965: LD_EXP 93
33969: PPUSH
33970: LD_VAR 0 2
33974: PPUSH
33975: LD_INT 0
33977: PPUSH
33978: CALL_OW 1
33982: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33983: LD_ADDR_VAR 0 4
33987: PUSH
33988: LD_EXP 50
33992: PUSH
33993: LD_VAR 0 2
33997: ARRAY
33998: PPUSH
33999: LD_INT 2
34001: PUSH
34002: LD_INT 25
34004: PUSH
34005: LD_INT 5
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 25
34014: PUSH
34015: LD_INT 8
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PUSH
34022: LD_INT 25
34024: PUSH
34025: LD_INT 9
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: PPUSH
34038: CALL_OW 72
34042: ST_TO_ADDR
// if not tmp then
34043: LD_VAR 0 4
34047: NOT
34048: IFFALSE 34052
// continue ;
34050: GO 33848
// for j in tmp do
34052: LD_ADDR_VAR 0 3
34056: PUSH
34057: LD_VAR 0 4
34061: PUSH
34062: FOR_IN
34063: IFFALSE 34134
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34065: LD_VAR 0 3
34069: PPUSH
34070: CALL_OW 310
34074: PPUSH
34075: CALL_OW 266
34079: PUSH
34080: LD_INT 5
34082: EQUAL
34083: PUSH
34084: LD_VAR 0 3
34088: PPUSH
34089: CALL_OW 257
34093: PUSH
34094: LD_INT 1
34096: EQUAL
34097: AND
34098: PUSH
34099: LD_VAR 0 3
34103: PPUSH
34104: CALL_OW 459
34108: NOT
34109: AND
34110: PUSH
34111: LD_VAR 0 7
34115: AND
34116: IFFALSE 34132
// ComChangeProfession ( j , class ) ;
34118: LD_VAR 0 3
34122: PPUSH
34123: LD_VAR 0 7
34127: PPUSH
34128: CALL_OW 123
34132: GO 34062
34134: POP
34135: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34136: LD_EXP 73
34140: PUSH
34141: LD_VAR 0 2
34145: ARRAY
34146: PUSH
34147: LD_EXP 93
34151: PUSH
34152: LD_VAR 0 2
34156: ARRAY
34157: NOT
34158: AND
34159: PUSH
34160: LD_EXP 72
34164: PUSH
34165: LD_VAR 0 2
34169: ARRAY
34170: NOT
34171: AND
34172: PUSH
34173: LD_EXP 50
34177: PUSH
34178: LD_VAR 0 2
34182: ARRAY
34183: PPUSH
34184: LD_INT 50
34186: PUSH
34187: EMPTY
34188: LIST
34189: PUSH
34190: LD_INT 2
34192: PUSH
34193: LD_INT 30
34195: PUSH
34196: LD_INT 32
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 30
34205: PUSH
34206: LD_INT 33
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 30
34215: PUSH
34216: LD_INT 4
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 30
34225: PUSH
34226: LD_INT 5
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PPUSH
34244: CALL_OW 72
34248: PUSH
34249: LD_INT 4
34251: LESS
34252: PUSH
34253: LD_EXP 50
34257: PUSH
34258: LD_VAR 0 2
34262: ARRAY
34263: PPUSH
34264: LD_INT 3
34266: PUSH
34267: LD_INT 24
34269: PUSH
34270: LD_INT 1000
34272: PUSH
34273: EMPTY
34274: LIST
34275: LIST
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 2
34283: PUSH
34284: LD_INT 30
34286: PUSH
34287: LD_INT 0
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PUSH
34294: LD_INT 30
34296: PUSH
34297: LD_INT 1
34299: PUSH
34300: EMPTY
34301: LIST
34302: LIST
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: LIST
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PPUSH
34313: CALL_OW 72
34317: OR
34318: AND
34319: IFFALSE 34570
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34321: LD_ADDR_EXP 93
34325: PUSH
34326: LD_EXP 93
34330: PPUSH
34331: LD_VAR 0 2
34335: PPUSH
34336: LD_INT 1
34338: PPUSH
34339: CALL_OW 1
34343: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34344: LD_ADDR_VAR 0 4
34348: PUSH
34349: LD_EXP 50
34353: PUSH
34354: LD_VAR 0 2
34358: ARRAY
34359: PPUSH
34360: LD_INT 2
34362: PUSH
34363: LD_INT 25
34365: PUSH
34366: LD_INT 1
34368: PUSH
34369: EMPTY
34370: LIST
34371: LIST
34372: PUSH
34373: LD_INT 25
34375: PUSH
34376: LD_INT 5
34378: PUSH
34379: EMPTY
34380: LIST
34381: LIST
34382: PUSH
34383: LD_INT 25
34385: PUSH
34386: LD_INT 8
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 25
34395: PUSH
34396: LD_INT 9
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: PPUSH
34410: CALL_OW 72
34414: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34415: LD_ADDR_VAR 0 4
34419: PUSH
34420: LD_VAR 0 4
34424: PUSH
34425: LD_VAR 0 4
34429: PPUSH
34430: LD_INT 18
34432: PPUSH
34433: CALL 82833 0 2
34437: DIFF
34438: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34439: LD_VAR 0 4
34443: NOT
34444: PUSH
34445: LD_EXP 50
34449: PUSH
34450: LD_VAR 0 2
34454: ARRAY
34455: PPUSH
34456: LD_INT 2
34458: PUSH
34459: LD_INT 30
34461: PUSH
34462: LD_INT 4
34464: PUSH
34465: EMPTY
34466: LIST
34467: LIST
34468: PUSH
34469: LD_INT 30
34471: PUSH
34472: LD_INT 5
34474: PUSH
34475: EMPTY
34476: LIST
34477: LIST
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: LIST
34483: PPUSH
34484: CALL_OW 72
34488: NOT
34489: AND
34490: IFFALSE 34552
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34492: LD_ADDR_VAR 0 4
34496: PUSH
34497: LD_EXP 50
34501: PUSH
34502: LD_VAR 0 2
34506: ARRAY
34507: PPUSH
34508: LD_INT 2
34510: PUSH
34511: LD_INT 25
34513: PUSH
34514: LD_INT 2
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 25
34523: PUSH
34524: LD_INT 3
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PUSH
34531: LD_INT 25
34533: PUSH
34534: LD_INT 4
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: LIST
34545: LIST
34546: PPUSH
34547: CALL_OW 72
34551: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34552: LD_VAR 0 2
34556: PPUSH
34557: LD_VAR 0 4
34561: PPUSH
34562: CALL 112464 0 2
// exit ;
34566: POP
34567: POP
34568: GO 34690
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34570: LD_EXP 73
34574: PUSH
34575: LD_VAR 0 2
34579: ARRAY
34580: PUSH
34581: LD_EXP 93
34585: PUSH
34586: LD_VAR 0 2
34590: ARRAY
34591: NOT
34592: AND
34593: PUSH
34594: LD_EXP 72
34598: PUSH
34599: LD_VAR 0 2
34603: ARRAY
34604: AND
34605: IFFALSE 34686
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34607: LD_ADDR_EXP 93
34611: PUSH
34612: LD_EXP 93
34616: PPUSH
34617: LD_VAR 0 2
34621: PPUSH
34622: LD_INT 1
34624: PPUSH
34625: CALL_OW 1
34629: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34630: LD_ADDR_VAR 0 4
34634: PUSH
34635: LD_EXP 72
34639: PUSH
34640: LD_VAR 0 2
34644: ARRAY
34645: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34646: LD_ADDR_EXP 72
34650: PUSH
34651: LD_EXP 72
34655: PPUSH
34656: LD_VAR 0 2
34660: PPUSH
34661: EMPTY
34662: PPUSH
34663: CALL_OW 1
34667: ST_TO_ADDR
// Defend ( i , tmp ) ;
34668: LD_VAR 0 2
34672: PPUSH
34673: LD_VAR 0 4
34677: PPUSH
34678: CALL 113060 0 2
// exit ;
34682: POP
34683: POP
34684: GO 34690
// end ; end ;
34686: GO 33848
34688: POP
34689: POP
// end ;
34690: LD_VAR 0 1
34694: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34695: LD_INT 0
34697: PPUSH
34698: PPUSH
34699: PPUSH
34700: PPUSH
34701: PPUSH
34702: PPUSH
34703: PPUSH
34704: PPUSH
34705: PPUSH
34706: PPUSH
34707: PPUSH
// if not mc_bases then
34708: LD_EXP 50
34712: NOT
34713: IFFALSE 34717
// exit ;
34715: GO 35804
// for i = 1 to mc_bases do
34717: LD_ADDR_VAR 0 2
34721: PUSH
34722: DOUBLE
34723: LD_INT 1
34725: DEC
34726: ST_TO_ADDR
34727: LD_EXP 50
34731: PUSH
34732: FOR_TO
34733: IFFALSE 35802
// begin tmp := mc_lab [ i ] ;
34735: LD_ADDR_VAR 0 6
34739: PUSH
34740: LD_EXP 83
34744: PUSH
34745: LD_VAR 0 2
34749: ARRAY
34750: ST_TO_ADDR
// if not tmp then
34751: LD_VAR 0 6
34755: NOT
34756: IFFALSE 34760
// continue ;
34758: GO 34732
// idle_lab := 0 ;
34760: LD_ADDR_VAR 0 11
34764: PUSH
34765: LD_INT 0
34767: ST_TO_ADDR
// for j in tmp do
34768: LD_ADDR_VAR 0 3
34772: PUSH
34773: LD_VAR 0 6
34777: PUSH
34778: FOR_IN
34779: IFFALSE 35798
// begin researching := false ;
34781: LD_ADDR_VAR 0 10
34785: PUSH
34786: LD_INT 0
34788: ST_TO_ADDR
// side := GetSide ( j ) ;
34789: LD_ADDR_VAR 0 4
34793: PUSH
34794: LD_VAR 0 3
34798: PPUSH
34799: CALL_OW 255
34803: ST_TO_ADDR
// if not mc_tech [ side ] then
34804: LD_EXP 77
34808: PUSH
34809: LD_VAR 0 4
34813: ARRAY
34814: NOT
34815: IFFALSE 34819
// continue ;
34817: GO 34778
// if BuildingStatus ( j ) = bs_idle then
34819: LD_VAR 0 3
34823: PPUSH
34824: CALL_OW 461
34828: PUSH
34829: LD_INT 2
34831: EQUAL
34832: IFFALSE 35020
// begin if idle_lab and UnitsInside ( j ) < 6 then
34834: LD_VAR 0 11
34838: PUSH
34839: LD_VAR 0 3
34843: PPUSH
34844: CALL_OW 313
34848: PUSH
34849: LD_INT 6
34851: LESS
34852: AND
34853: IFFALSE 34924
// begin tmp2 := UnitsInside ( idle_lab ) ;
34855: LD_ADDR_VAR 0 9
34859: PUSH
34860: LD_VAR 0 11
34864: PPUSH
34865: CALL_OW 313
34869: ST_TO_ADDR
// if tmp2 then
34870: LD_VAR 0 9
34874: IFFALSE 34916
// for x in tmp2 do
34876: LD_ADDR_VAR 0 7
34880: PUSH
34881: LD_VAR 0 9
34885: PUSH
34886: FOR_IN
34887: IFFALSE 34914
// begin ComExitBuilding ( x ) ;
34889: LD_VAR 0 7
34893: PPUSH
34894: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34898: LD_VAR 0 7
34902: PPUSH
34903: LD_VAR 0 3
34907: PPUSH
34908: CALL_OW 180
// end ;
34912: GO 34886
34914: POP
34915: POP
// idle_lab := 0 ;
34916: LD_ADDR_VAR 0 11
34920: PUSH
34921: LD_INT 0
34923: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34924: LD_ADDR_VAR 0 5
34928: PUSH
34929: LD_EXP 77
34933: PUSH
34934: LD_VAR 0 4
34938: ARRAY
34939: PUSH
34940: FOR_IN
34941: IFFALSE 35001
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
34943: LD_VAR 0 3
34947: PPUSH
34948: LD_VAR 0 5
34952: PPUSH
34953: CALL_OW 430
34957: PUSH
34958: LD_VAR 0 4
34962: PPUSH
34963: LD_VAR 0 5
34967: PPUSH
34968: CALL 49434 0 2
34972: AND
34973: IFFALSE 34999
// begin researching := true ;
34975: LD_ADDR_VAR 0 10
34979: PUSH
34980: LD_INT 1
34982: ST_TO_ADDR
// ComResearch ( j , t ) ;
34983: LD_VAR 0 3
34987: PPUSH
34988: LD_VAR 0 5
34992: PPUSH
34993: CALL_OW 124
// break ;
34997: GO 35001
// end ;
34999: GO 34940
35001: POP
35002: POP
// if not researching then
35003: LD_VAR 0 10
35007: NOT
35008: IFFALSE 35020
// idle_lab := j ;
35010: LD_ADDR_VAR 0 11
35014: PUSH
35015: LD_VAR 0 3
35019: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35020: LD_VAR 0 3
35024: PPUSH
35025: CALL_OW 461
35029: PUSH
35030: LD_INT 10
35032: EQUAL
35033: IFFALSE 35621
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35035: LD_EXP 79
35039: PUSH
35040: LD_VAR 0 2
35044: ARRAY
35045: NOT
35046: PUSH
35047: LD_EXP 80
35051: PUSH
35052: LD_VAR 0 2
35056: ARRAY
35057: NOT
35058: AND
35059: PUSH
35060: LD_EXP 77
35064: PUSH
35065: LD_VAR 0 4
35069: ARRAY
35070: PUSH
35071: LD_INT 1
35073: GREATER
35074: AND
35075: IFFALSE 35206
// begin ComCancel ( j ) ;
35077: LD_VAR 0 3
35081: PPUSH
35082: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35086: LD_ADDR_EXP 77
35090: PUSH
35091: LD_EXP 77
35095: PPUSH
35096: LD_VAR 0 4
35100: PPUSH
35101: LD_EXP 77
35105: PUSH
35106: LD_VAR 0 4
35110: ARRAY
35111: PPUSH
35112: LD_EXP 77
35116: PUSH
35117: LD_VAR 0 4
35121: ARRAY
35122: PUSH
35123: LD_INT 1
35125: MINUS
35126: PPUSH
35127: LD_EXP 77
35131: PUSH
35132: LD_VAR 0 4
35136: ARRAY
35137: PPUSH
35138: LD_INT 0
35140: PPUSH
35141: CALL 52982 0 4
35145: PPUSH
35146: CALL_OW 1
35150: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35151: LD_ADDR_EXP 77
35155: PUSH
35156: LD_EXP 77
35160: PPUSH
35161: LD_VAR 0 4
35165: PPUSH
35166: LD_EXP 77
35170: PUSH
35171: LD_VAR 0 4
35175: ARRAY
35176: PPUSH
35177: LD_EXP 77
35181: PUSH
35182: LD_VAR 0 4
35186: ARRAY
35187: PPUSH
35188: LD_INT 1
35190: PPUSH
35191: LD_INT 0
35193: PPUSH
35194: CALL 52982 0 4
35198: PPUSH
35199: CALL_OW 1
35203: ST_TO_ADDR
// continue ;
35204: GO 34778
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35206: LD_EXP 79
35210: PUSH
35211: LD_VAR 0 2
35215: ARRAY
35216: PUSH
35217: LD_EXP 80
35221: PUSH
35222: LD_VAR 0 2
35226: ARRAY
35227: NOT
35228: AND
35229: IFFALSE 35356
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35231: LD_ADDR_EXP 80
35235: PUSH
35236: LD_EXP 80
35240: PPUSH
35241: LD_VAR 0 2
35245: PUSH
35246: LD_EXP 80
35250: PUSH
35251: LD_VAR 0 2
35255: ARRAY
35256: PUSH
35257: LD_INT 1
35259: PLUS
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PPUSH
35265: LD_EXP 79
35269: PUSH
35270: LD_VAR 0 2
35274: ARRAY
35275: PUSH
35276: LD_INT 1
35278: ARRAY
35279: PPUSH
35280: CALL 53564 0 3
35284: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35285: LD_EXP 79
35289: PUSH
35290: LD_VAR 0 2
35294: ARRAY
35295: PUSH
35296: LD_INT 1
35298: ARRAY
35299: PPUSH
35300: LD_INT 112
35302: PPUSH
35303: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35307: LD_ADDR_VAR 0 9
35311: PUSH
35312: LD_EXP 79
35316: PUSH
35317: LD_VAR 0 2
35321: ARRAY
35322: PPUSH
35323: LD_INT 1
35325: PPUSH
35326: CALL_OW 3
35330: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35331: LD_ADDR_EXP 79
35335: PUSH
35336: LD_EXP 79
35340: PPUSH
35341: LD_VAR 0 2
35345: PPUSH
35346: LD_VAR 0 9
35350: PPUSH
35351: CALL_OW 1
35355: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35356: LD_EXP 79
35360: PUSH
35361: LD_VAR 0 2
35365: ARRAY
35366: PUSH
35367: LD_EXP 80
35371: PUSH
35372: LD_VAR 0 2
35376: ARRAY
35377: AND
35378: PUSH
35379: LD_EXP 80
35383: PUSH
35384: LD_VAR 0 2
35388: ARRAY
35389: PUSH
35390: LD_INT 1
35392: ARRAY
35393: PPUSH
35394: CALL_OW 310
35398: NOT
35399: AND
35400: PUSH
35401: LD_VAR 0 3
35405: PPUSH
35406: CALL_OW 313
35410: PUSH
35411: LD_INT 6
35413: EQUAL
35414: AND
35415: IFFALSE 35471
// begin tmp2 := UnitsInside ( j ) ;
35417: LD_ADDR_VAR 0 9
35421: PUSH
35422: LD_VAR 0 3
35426: PPUSH
35427: CALL_OW 313
35431: ST_TO_ADDR
// if tmp2 = 6 then
35432: LD_VAR 0 9
35436: PUSH
35437: LD_INT 6
35439: EQUAL
35440: IFFALSE 35471
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35442: LD_VAR 0 9
35446: PUSH
35447: LD_INT 1
35449: ARRAY
35450: PPUSH
35451: LD_INT 112
35453: PPUSH
35454: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35458: LD_VAR 0 9
35462: PUSH
35463: LD_INT 1
35465: ARRAY
35466: PPUSH
35467: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35471: LD_EXP 80
35475: PUSH
35476: LD_VAR 0 2
35480: ARRAY
35481: PUSH
35482: LD_EXP 80
35486: PUSH
35487: LD_VAR 0 2
35491: ARRAY
35492: PUSH
35493: LD_INT 1
35495: ARRAY
35496: PPUSH
35497: CALL_OW 314
35501: NOT
35502: AND
35503: PUSH
35504: LD_EXP 80
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: PUSH
35515: LD_INT 1
35517: ARRAY
35518: PPUSH
35519: CALL_OW 310
35523: NOT
35524: AND
35525: IFFALSE 35551
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35527: LD_EXP 80
35531: PUSH
35532: LD_VAR 0 2
35536: ARRAY
35537: PUSH
35538: LD_INT 1
35540: ARRAY
35541: PPUSH
35542: LD_VAR 0 3
35546: PPUSH
35547: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35551: LD_EXP 80
35555: PUSH
35556: LD_VAR 0 2
35560: ARRAY
35561: PUSH
35562: LD_INT 1
35564: ARRAY
35565: PPUSH
35566: CALL_OW 310
35570: PUSH
35571: LD_EXP 80
35575: PUSH
35576: LD_VAR 0 2
35580: ARRAY
35581: PUSH
35582: LD_INT 1
35584: ARRAY
35585: PPUSH
35586: CALL_OW 310
35590: PPUSH
35591: CALL_OW 461
35595: PUSH
35596: LD_INT 3
35598: NONEQUAL
35599: AND
35600: IFFALSE 35621
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35602: LD_EXP 80
35606: PUSH
35607: LD_VAR 0 2
35611: ARRAY
35612: PUSH
35613: LD_INT 1
35615: ARRAY
35616: PPUSH
35617: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35621: LD_VAR 0 3
35625: PPUSH
35626: CALL_OW 461
35630: PUSH
35631: LD_INT 6
35633: EQUAL
35634: PUSH
35635: LD_VAR 0 6
35639: PUSH
35640: LD_INT 1
35642: GREATER
35643: AND
35644: IFFALSE 35796
// begin sci := [ ] ;
35646: LD_ADDR_VAR 0 8
35650: PUSH
35651: EMPTY
35652: ST_TO_ADDR
// for x in ( tmp diff j ) do
35653: LD_ADDR_VAR 0 7
35657: PUSH
35658: LD_VAR 0 6
35662: PUSH
35663: LD_VAR 0 3
35667: DIFF
35668: PUSH
35669: FOR_IN
35670: IFFALSE 35722
// begin if sci = 6 then
35672: LD_VAR 0 8
35676: PUSH
35677: LD_INT 6
35679: EQUAL
35680: IFFALSE 35684
// break ;
35682: GO 35722
// if BuildingStatus ( x ) = bs_idle then
35684: LD_VAR 0 7
35688: PPUSH
35689: CALL_OW 461
35693: PUSH
35694: LD_INT 2
35696: EQUAL
35697: IFFALSE 35720
// sci := sci ^ UnitsInside ( x ) ;
35699: LD_ADDR_VAR 0 8
35703: PUSH
35704: LD_VAR 0 8
35708: PUSH
35709: LD_VAR 0 7
35713: PPUSH
35714: CALL_OW 313
35718: ADD
35719: ST_TO_ADDR
// end ;
35720: GO 35669
35722: POP
35723: POP
// if not sci then
35724: LD_VAR 0 8
35728: NOT
35729: IFFALSE 35733
// continue ;
35731: GO 34778
// for x in sci do
35733: LD_ADDR_VAR 0 7
35737: PUSH
35738: LD_VAR 0 8
35742: PUSH
35743: FOR_IN
35744: IFFALSE 35794
// if IsInUnit ( x ) and not HasTask ( x ) then
35746: LD_VAR 0 7
35750: PPUSH
35751: CALL_OW 310
35755: PUSH
35756: LD_VAR 0 7
35760: PPUSH
35761: CALL_OW 314
35765: NOT
35766: AND
35767: IFFALSE 35792
// begin ComExitBuilding ( x ) ;
35769: LD_VAR 0 7
35773: PPUSH
35774: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35778: LD_VAR 0 7
35782: PPUSH
35783: LD_VAR 0 3
35787: PPUSH
35788: CALL_OW 180
// end ;
35792: GO 35743
35794: POP
35795: POP
// end ; end ;
35796: GO 34778
35798: POP
35799: POP
// end ;
35800: GO 34732
35802: POP
35803: POP
// end ;
35804: LD_VAR 0 1
35808: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35809: LD_INT 0
35811: PPUSH
35812: PPUSH
// if not mc_bases then
35813: LD_EXP 50
35817: NOT
35818: IFFALSE 35822
// exit ;
35820: GO 35903
// for i = 1 to mc_bases do
35822: LD_ADDR_VAR 0 2
35826: PUSH
35827: DOUBLE
35828: LD_INT 1
35830: DEC
35831: ST_TO_ADDR
35832: LD_EXP 50
35836: PUSH
35837: FOR_TO
35838: IFFALSE 35901
// if mc_mines [ i ] and mc_miners [ i ] then
35840: LD_EXP 63
35844: PUSH
35845: LD_VAR 0 2
35849: ARRAY
35850: PUSH
35851: LD_EXP 64
35855: PUSH
35856: LD_VAR 0 2
35860: ARRAY
35861: AND
35862: IFFALSE 35899
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35864: LD_EXP 64
35868: PUSH
35869: LD_VAR 0 2
35873: ARRAY
35874: PUSH
35875: LD_INT 1
35877: ARRAY
35878: PPUSH
35879: CALL_OW 255
35883: PPUSH
35884: LD_EXP 63
35888: PUSH
35889: LD_VAR 0 2
35893: ARRAY
35894: PPUSH
35895: CALL 50517 0 2
35899: GO 35837
35901: POP
35902: POP
// end ;
35903: LD_VAR 0 1
35907: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35908: LD_INT 0
35910: PPUSH
35911: PPUSH
35912: PPUSH
35913: PPUSH
35914: PPUSH
35915: PPUSH
35916: PPUSH
35917: PPUSH
// if not mc_bases or not mc_parking then
35918: LD_EXP 50
35922: NOT
35923: PUSH
35924: LD_EXP 74
35928: NOT
35929: OR
35930: IFFALSE 35934
// exit ;
35932: GO 36644
// for i = 1 to mc_bases do
35934: LD_ADDR_VAR 0 2
35938: PUSH
35939: DOUBLE
35940: LD_INT 1
35942: DEC
35943: ST_TO_ADDR
35944: LD_EXP 50
35948: PUSH
35949: FOR_TO
35950: IFFALSE 36642
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
35952: LD_EXP 50
35956: PUSH
35957: LD_VAR 0 2
35961: ARRAY
35962: NOT
35963: PUSH
35964: LD_EXP 74
35968: PUSH
35969: LD_VAR 0 2
35973: ARRAY
35974: NOT
35975: OR
35976: IFFALSE 35980
// continue ;
35978: GO 35949
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35980: LD_ADDR_VAR 0 5
35984: PUSH
35985: LD_EXP 50
35989: PUSH
35990: LD_VAR 0 2
35994: ARRAY
35995: PUSH
35996: LD_INT 1
35998: ARRAY
35999: PPUSH
36000: CALL_OW 255
36004: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36005: LD_ADDR_VAR 0 6
36009: PUSH
36010: LD_EXP 50
36014: PUSH
36015: LD_VAR 0 2
36019: ARRAY
36020: PPUSH
36021: LD_INT 30
36023: PUSH
36024: LD_INT 3
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PPUSH
36031: CALL_OW 72
36035: ST_TO_ADDR
// if not fac then
36036: LD_VAR 0 6
36040: NOT
36041: IFFALSE 36092
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36043: LD_ADDR_VAR 0 6
36047: PUSH
36048: LD_EXP 50
36052: PUSH
36053: LD_VAR 0 2
36057: ARRAY
36058: PPUSH
36059: LD_INT 2
36061: PUSH
36062: LD_INT 30
36064: PUSH
36065: LD_INT 0
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 30
36074: PUSH
36075: LD_INT 1
36077: PUSH
36078: EMPTY
36079: LIST
36080: LIST
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: LIST
36086: PPUSH
36087: CALL_OW 72
36091: ST_TO_ADDR
// if not fac then
36092: LD_VAR 0 6
36096: NOT
36097: IFFALSE 36101
// continue ;
36099: GO 35949
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36101: LD_ADDR_VAR 0 7
36105: PUSH
36106: LD_EXP 74
36110: PUSH
36111: LD_VAR 0 2
36115: ARRAY
36116: PPUSH
36117: LD_INT 22
36119: PUSH
36120: LD_VAR 0 5
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: LD_INT 21
36131: PUSH
36132: LD_INT 2
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 3
36141: PUSH
36142: LD_INT 24
36144: PUSH
36145: LD_INT 1000
36147: PUSH
36148: EMPTY
36149: LIST
36150: LIST
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: LIST
36160: PPUSH
36161: CALL_OW 70
36165: ST_TO_ADDR
// for j in fac do
36166: LD_ADDR_VAR 0 3
36170: PUSH
36171: LD_VAR 0 6
36175: PUSH
36176: FOR_IN
36177: IFFALSE 36258
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36179: LD_ADDR_VAR 0 7
36183: PUSH
36184: LD_VAR 0 7
36188: PUSH
36189: LD_INT 22
36191: PUSH
36192: LD_VAR 0 5
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: PUSH
36201: LD_INT 91
36203: PUSH
36204: LD_VAR 0 3
36208: PUSH
36209: LD_INT 15
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: LIST
36216: PUSH
36217: LD_INT 21
36219: PUSH
36220: LD_INT 2
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 3
36229: PUSH
36230: LD_INT 24
36232: PUSH
36233: LD_INT 1000
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: EMPTY
36241: LIST
36242: LIST
36243: PUSH
36244: EMPTY
36245: LIST
36246: LIST
36247: LIST
36248: LIST
36249: PPUSH
36250: CALL_OW 69
36254: UNION
36255: ST_TO_ADDR
36256: GO 36176
36258: POP
36259: POP
// if not vehs then
36260: LD_VAR 0 7
36264: NOT
36265: IFFALSE 36291
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36267: LD_ADDR_EXP 62
36271: PUSH
36272: LD_EXP 62
36276: PPUSH
36277: LD_VAR 0 2
36281: PPUSH
36282: EMPTY
36283: PPUSH
36284: CALL_OW 1
36288: ST_TO_ADDR
// continue ;
36289: GO 35949
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36291: LD_ADDR_VAR 0 8
36295: PUSH
36296: LD_EXP 50
36300: PUSH
36301: LD_VAR 0 2
36305: ARRAY
36306: PPUSH
36307: LD_INT 30
36309: PUSH
36310: LD_INT 3
36312: PUSH
36313: EMPTY
36314: LIST
36315: LIST
36316: PPUSH
36317: CALL_OW 72
36321: ST_TO_ADDR
// if tmp then
36322: LD_VAR 0 8
36326: IFFALSE 36429
// begin for j in tmp do
36328: LD_ADDR_VAR 0 3
36332: PUSH
36333: LD_VAR 0 8
36337: PUSH
36338: FOR_IN
36339: IFFALSE 36427
// for k in UnitsInside ( j ) do
36341: LD_ADDR_VAR 0 4
36345: PUSH
36346: LD_VAR 0 3
36350: PPUSH
36351: CALL_OW 313
36355: PUSH
36356: FOR_IN
36357: IFFALSE 36423
// if k then
36359: LD_VAR 0 4
36363: IFFALSE 36421
// if not k in mc_repair_vehicle [ i ] then
36365: LD_VAR 0 4
36369: PUSH
36370: LD_EXP 62
36374: PUSH
36375: LD_VAR 0 2
36379: ARRAY
36380: IN
36381: NOT
36382: IFFALSE 36421
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36384: LD_ADDR_EXP 62
36388: PUSH
36389: LD_EXP 62
36393: PPUSH
36394: LD_VAR 0 2
36398: PPUSH
36399: LD_EXP 62
36403: PUSH
36404: LD_VAR 0 2
36408: ARRAY
36409: PUSH
36410: LD_VAR 0 4
36414: UNION
36415: PPUSH
36416: CALL_OW 1
36420: ST_TO_ADDR
36421: GO 36356
36423: POP
36424: POP
36425: GO 36338
36427: POP
36428: POP
// end ; if not mc_repair_vehicle [ i ] then
36429: LD_EXP 62
36433: PUSH
36434: LD_VAR 0 2
36438: ARRAY
36439: NOT
36440: IFFALSE 36444
// continue ;
36442: GO 35949
// for j in mc_repair_vehicle [ i ] do
36444: LD_ADDR_VAR 0 3
36448: PUSH
36449: LD_EXP 62
36453: PUSH
36454: LD_VAR 0 2
36458: ARRAY
36459: PUSH
36460: FOR_IN
36461: IFFALSE 36638
// begin if GetClass ( j ) <> 3 then
36463: LD_VAR 0 3
36467: PPUSH
36468: CALL_OW 257
36472: PUSH
36473: LD_INT 3
36475: NONEQUAL
36476: IFFALSE 36517
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36478: LD_ADDR_EXP 62
36482: PUSH
36483: LD_EXP 62
36487: PPUSH
36488: LD_VAR 0 2
36492: PPUSH
36493: LD_EXP 62
36497: PUSH
36498: LD_VAR 0 2
36502: ARRAY
36503: PUSH
36504: LD_VAR 0 3
36508: DIFF
36509: PPUSH
36510: CALL_OW 1
36514: ST_TO_ADDR
// continue ;
36515: GO 36460
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36517: LD_VAR 0 3
36521: PPUSH
36522: CALL_OW 311
36526: NOT
36527: PUSH
36528: LD_VAR 0 3
36532: PUSH
36533: LD_EXP 53
36537: PUSH
36538: LD_VAR 0 2
36542: ARRAY
36543: PUSH
36544: LD_INT 1
36546: ARRAY
36547: IN
36548: NOT
36549: AND
36550: PUSH
36551: LD_VAR 0 3
36555: PUSH
36556: LD_EXP 53
36560: PUSH
36561: LD_VAR 0 2
36565: ARRAY
36566: PUSH
36567: LD_INT 2
36569: ARRAY
36570: IN
36571: NOT
36572: AND
36573: IFFALSE 36636
// begin if IsInUnit ( j ) then
36575: LD_VAR 0 3
36579: PPUSH
36580: CALL_OW 310
36584: IFFALSE 36597
// ComExitBuilding ( j ) else
36586: LD_VAR 0 3
36590: PPUSH
36591: CALL_OW 122
36595: GO 36636
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36597: LD_VAR 0 3
36601: PPUSH
36602: LD_VAR 0 7
36606: PUSH
36607: LD_INT 1
36609: ARRAY
36610: PPUSH
36611: CALL 87316 0 2
36615: NOT
36616: IFFALSE 36636
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
36618: LD_VAR 0 3
36622: PPUSH
36623: LD_VAR 0 7
36627: PUSH
36628: LD_INT 1
36630: ARRAY
36631: PPUSH
36632: CALL_OW 129
// end ; end ;
36636: GO 36460
36638: POP
36639: POP
// end ;
36640: GO 35949
36642: POP
36643: POP
// end ;
36644: LD_VAR 0 1
36648: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36649: LD_INT 0
36651: PPUSH
36652: PPUSH
36653: PPUSH
36654: PPUSH
36655: PPUSH
36656: PPUSH
36657: PPUSH
36658: PPUSH
36659: PPUSH
36660: PPUSH
36661: PPUSH
// if not mc_bases then
36662: LD_EXP 50
36666: NOT
36667: IFFALSE 36671
// exit ;
36669: GO 37473
// for i = 1 to mc_bases do
36671: LD_ADDR_VAR 0 2
36675: PUSH
36676: DOUBLE
36677: LD_INT 1
36679: DEC
36680: ST_TO_ADDR
36681: LD_EXP 50
36685: PUSH
36686: FOR_TO
36687: IFFALSE 37471
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36689: LD_EXP 78
36693: PUSH
36694: LD_VAR 0 2
36698: ARRAY
36699: NOT
36700: PUSH
36701: LD_EXP 53
36705: PUSH
36706: LD_VAR 0 2
36710: ARRAY
36711: PUSH
36712: LD_INT 1
36714: ARRAY
36715: OR
36716: PUSH
36717: LD_EXP 53
36721: PUSH
36722: LD_VAR 0 2
36726: ARRAY
36727: PUSH
36728: LD_INT 2
36730: ARRAY
36731: OR
36732: PUSH
36733: LD_EXP 76
36737: PUSH
36738: LD_VAR 0 2
36742: ARRAY
36743: PPUSH
36744: LD_INT 1
36746: PPUSH
36747: CALL_OW 325
36751: NOT
36752: OR
36753: PUSH
36754: LD_EXP 73
36758: PUSH
36759: LD_VAR 0 2
36763: ARRAY
36764: OR
36765: IFFALSE 36769
// continue ;
36767: GO 36686
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36769: LD_ADDR_VAR 0 8
36773: PUSH
36774: LD_EXP 50
36778: PUSH
36779: LD_VAR 0 2
36783: ARRAY
36784: PPUSH
36785: LD_INT 25
36787: PUSH
36788: LD_INT 4
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 50
36797: PUSH
36798: EMPTY
36799: LIST
36800: PUSH
36801: LD_INT 3
36803: PUSH
36804: LD_INT 60
36806: PUSH
36807: EMPTY
36808: LIST
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: LIST
36818: PPUSH
36819: CALL_OW 72
36823: PUSH
36824: LD_EXP 54
36828: PUSH
36829: LD_VAR 0 2
36833: ARRAY
36834: DIFF
36835: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36836: LD_ADDR_VAR 0 9
36840: PUSH
36841: LD_EXP 50
36845: PUSH
36846: LD_VAR 0 2
36850: ARRAY
36851: PPUSH
36852: LD_INT 2
36854: PUSH
36855: LD_INT 30
36857: PUSH
36858: LD_INT 0
36860: PUSH
36861: EMPTY
36862: LIST
36863: LIST
36864: PUSH
36865: LD_INT 30
36867: PUSH
36868: LD_INT 1
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: LIST
36879: PPUSH
36880: CALL_OW 72
36884: ST_TO_ADDR
// if not tmp or not dep then
36885: LD_VAR 0 8
36889: NOT
36890: PUSH
36891: LD_VAR 0 9
36895: NOT
36896: OR
36897: IFFALSE 36901
// continue ;
36899: GO 36686
// side := GetSide ( tmp [ 1 ] ) ;
36901: LD_ADDR_VAR 0 11
36905: PUSH
36906: LD_VAR 0 8
36910: PUSH
36911: LD_INT 1
36913: ARRAY
36914: PPUSH
36915: CALL_OW 255
36919: ST_TO_ADDR
// dep := dep [ 1 ] ;
36920: LD_ADDR_VAR 0 9
36924: PUSH
36925: LD_VAR 0 9
36929: PUSH
36930: LD_INT 1
36932: ARRAY
36933: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
36934: LD_ADDR_VAR 0 7
36938: PUSH
36939: LD_EXP 78
36943: PUSH
36944: LD_VAR 0 2
36948: ARRAY
36949: PPUSH
36950: LD_INT 22
36952: PUSH
36953: LD_INT 0
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 25
36962: PUSH
36963: LD_INT 12
36965: PUSH
36966: EMPTY
36967: LIST
36968: LIST
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PPUSH
36974: CALL_OW 70
36978: PUSH
36979: LD_INT 22
36981: PUSH
36982: LD_INT 0
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: PUSH
36989: LD_INT 25
36991: PUSH
36992: LD_INT 12
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: PUSH
36999: LD_INT 91
37001: PUSH
37002: LD_VAR 0 9
37006: PUSH
37007: LD_INT 20
37009: PUSH
37010: EMPTY
37011: LIST
37012: LIST
37013: LIST
37014: PUSH
37015: EMPTY
37016: LIST
37017: LIST
37018: LIST
37019: PPUSH
37020: CALL_OW 69
37024: UNION
37025: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37026: LD_ADDR_VAR 0 10
37030: PUSH
37031: LD_EXP 78
37035: PUSH
37036: LD_VAR 0 2
37040: ARRAY
37041: PPUSH
37042: LD_INT 81
37044: PUSH
37045: LD_VAR 0 11
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PPUSH
37054: CALL_OW 70
37058: ST_TO_ADDR
// if not apes or danger_at_area then
37059: LD_VAR 0 7
37063: NOT
37064: PUSH
37065: LD_VAR 0 10
37069: OR
37070: IFFALSE 37120
// begin if mc_taming [ i ] then
37072: LD_EXP 81
37076: PUSH
37077: LD_VAR 0 2
37081: ARRAY
37082: IFFALSE 37118
// begin MC_Reset ( i , 121 ) ;
37084: LD_VAR 0 2
37088: PPUSH
37089: LD_INT 121
37091: PPUSH
37092: CALL 22106 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37096: LD_ADDR_EXP 81
37100: PUSH
37101: LD_EXP 81
37105: PPUSH
37106: LD_VAR 0 2
37110: PPUSH
37111: EMPTY
37112: PPUSH
37113: CALL_OW 1
37117: ST_TO_ADDR
// end ; continue ;
37118: GO 36686
// end ; for j in tmp do
37120: LD_ADDR_VAR 0 3
37124: PUSH
37125: LD_VAR 0 8
37129: PUSH
37130: FOR_IN
37131: IFFALSE 37467
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37133: LD_VAR 0 3
37137: PUSH
37138: LD_EXP 81
37142: PUSH
37143: LD_VAR 0 2
37147: ARRAY
37148: IN
37149: NOT
37150: PUSH
37151: LD_EXP 81
37155: PUSH
37156: LD_VAR 0 2
37160: ARRAY
37161: PUSH
37162: LD_INT 3
37164: LESS
37165: AND
37166: IFFALSE 37224
// begin SetTag ( j , 121 ) ;
37168: LD_VAR 0 3
37172: PPUSH
37173: LD_INT 121
37175: PPUSH
37176: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37180: LD_ADDR_EXP 81
37184: PUSH
37185: LD_EXP 81
37189: PPUSH
37190: LD_VAR 0 2
37194: PUSH
37195: LD_EXP 81
37199: PUSH
37200: LD_VAR 0 2
37204: ARRAY
37205: PUSH
37206: LD_INT 1
37208: PLUS
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PPUSH
37214: LD_VAR 0 3
37218: PPUSH
37219: CALL 53564 0 3
37223: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37224: LD_VAR 0 3
37228: PUSH
37229: LD_EXP 81
37233: PUSH
37234: LD_VAR 0 2
37238: ARRAY
37239: IN
37240: IFFALSE 37465
// begin if GetClass ( j ) <> 4 then
37242: LD_VAR 0 3
37246: PPUSH
37247: CALL_OW 257
37251: PUSH
37252: LD_INT 4
37254: NONEQUAL
37255: IFFALSE 37308
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37257: LD_ADDR_EXP 81
37261: PUSH
37262: LD_EXP 81
37266: PPUSH
37267: LD_VAR 0 2
37271: PPUSH
37272: LD_EXP 81
37276: PUSH
37277: LD_VAR 0 2
37281: ARRAY
37282: PUSH
37283: LD_VAR 0 3
37287: DIFF
37288: PPUSH
37289: CALL_OW 1
37293: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37294: LD_VAR 0 3
37298: PPUSH
37299: LD_INT 0
37301: PPUSH
37302: CALL_OW 109
// continue ;
37306: GO 37130
// end ; if IsInUnit ( j ) then
37308: LD_VAR 0 3
37312: PPUSH
37313: CALL_OW 310
37317: IFFALSE 37328
// ComExitBuilding ( j ) ;
37319: LD_VAR 0 3
37323: PPUSH
37324: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37328: LD_ADDR_VAR 0 6
37332: PUSH
37333: LD_VAR 0 7
37337: PPUSH
37338: LD_VAR 0 3
37342: PPUSH
37343: CALL_OW 74
37347: ST_TO_ADDR
// if not ape then
37348: LD_VAR 0 6
37352: NOT
37353: IFFALSE 37357
// break ;
37355: GO 37467
// x := GetX ( ape ) ;
37357: LD_ADDR_VAR 0 4
37361: PUSH
37362: LD_VAR 0 6
37366: PPUSH
37367: CALL_OW 250
37371: ST_TO_ADDR
// y := GetY ( ape ) ;
37372: LD_ADDR_VAR 0 5
37376: PUSH
37377: LD_VAR 0 6
37381: PPUSH
37382: CALL_OW 251
37386: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37387: LD_VAR 0 4
37391: PPUSH
37392: LD_VAR 0 5
37396: PPUSH
37397: CALL_OW 488
37401: NOT
37402: PUSH
37403: LD_VAR 0 11
37407: PPUSH
37408: LD_VAR 0 4
37412: PPUSH
37413: LD_VAR 0 5
37417: PPUSH
37418: LD_INT 20
37420: PPUSH
37421: CALL 54460 0 4
37425: PUSH
37426: LD_INT 4
37428: ARRAY
37429: OR
37430: IFFALSE 37434
// break ;
37432: GO 37467
// if not HasTask ( j ) then
37434: LD_VAR 0 3
37438: PPUSH
37439: CALL_OW 314
37443: NOT
37444: IFFALSE 37465
// ComTameXY ( j , x , y ) ;
37446: LD_VAR 0 3
37450: PPUSH
37451: LD_VAR 0 4
37455: PPUSH
37456: LD_VAR 0 5
37460: PPUSH
37461: CALL_OW 131
// end ; end ;
37465: GO 37130
37467: POP
37468: POP
// end ;
37469: GO 36686
37471: POP
37472: POP
// end ;
37473: LD_VAR 0 1
37477: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37478: LD_INT 0
37480: PPUSH
37481: PPUSH
37482: PPUSH
37483: PPUSH
37484: PPUSH
37485: PPUSH
37486: PPUSH
37487: PPUSH
// if not mc_bases then
37488: LD_EXP 50
37492: NOT
37493: IFFALSE 37497
// exit ;
37495: GO 38123
// for i = 1 to mc_bases do
37497: LD_ADDR_VAR 0 2
37501: PUSH
37502: DOUBLE
37503: LD_INT 1
37505: DEC
37506: ST_TO_ADDR
37507: LD_EXP 50
37511: PUSH
37512: FOR_TO
37513: IFFALSE 38121
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37515: LD_EXP 79
37519: PUSH
37520: LD_VAR 0 2
37524: ARRAY
37525: NOT
37526: PUSH
37527: LD_EXP 79
37531: PUSH
37532: LD_VAR 0 2
37536: ARRAY
37537: PPUSH
37538: LD_INT 25
37540: PUSH
37541: LD_INT 12
37543: PUSH
37544: EMPTY
37545: LIST
37546: LIST
37547: PPUSH
37548: CALL_OW 72
37552: NOT
37553: OR
37554: IFFALSE 37558
// continue ;
37556: GO 37512
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37558: LD_ADDR_VAR 0 5
37562: PUSH
37563: LD_EXP 79
37567: PUSH
37568: LD_VAR 0 2
37572: ARRAY
37573: PUSH
37574: LD_INT 1
37576: ARRAY
37577: PPUSH
37578: CALL_OW 255
37582: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37583: LD_VAR 0 5
37587: PPUSH
37588: LD_INT 2
37590: PPUSH
37591: CALL_OW 325
37595: IFFALSE 37848
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37597: LD_ADDR_VAR 0 4
37601: PUSH
37602: LD_EXP 79
37606: PUSH
37607: LD_VAR 0 2
37611: ARRAY
37612: PPUSH
37613: LD_INT 25
37615: PUSH
37616: LD_INT 16
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PPUSH
37623: CALL_OW 72
37627: ST_TO_ADDR
// if tmp < 6 then
37628: LD_VAR 0 4
37632: PUSH
37633: LD_INT 6
37635: LESS
37636: IFFALSE 37848
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37638: LD_ADDR_VAR 0 6
37642: PUSH
37643: LD_EXP 50
37647: PUSH
37648: LD_VAR 0 2
37652: ARRAY
37653: PPUSH
37654: LD_INT 2
37656: PUSH
37657: LD_INT 30
37659: PUSH
37660: LD_INT 0
37662: PUSH
37663: EMPTY
37664: LIST
37665: LIST
37666: PUSH
37667: LD_INT 30
37669: PUSH
37670: LD_INT 1
37672: PUSH
37673: EMPTY
37674: LIST
37675: LIST
37676: PUSH
37677: EMPTY
37678: LIST
37679: LIST
37680: LIST
37681: PPUSH
37682: CALL_OW 72
37686: ST_TO_ADDR
// if depot then
37687: LD_VAR 0 6
37691: IFFALSE 37848
// begin selected := 0 ;
37693: LD_ADDR_VAR 0 7
37697: PUSH
37698: LD_INT 0
37700: ST_TO_ADDR
// for j in depot do
37701: LD_ADDR_VAR 0 3
37705: PUSH
37706: LD_VAR 0 6
37710: PUSH
37711: FOR_IN
37712: IFFALSE 37743
// begin if UnitsInside ( j ) < 6 then
37714: LD_VAR 0 3
37718: PPUSH
37719: CALL_OW 313
37723: PUSH
37724: LD_INT 6
37726: LESS
37727: IFFALSE 37741
// begin selected := j ;
37729: LD_ADDR_VAR 0 7
37733: PUSH
37734: LD_VAR 0 3
37738: ST_TO_ADDR
// break ;
37739: GO 37743
// end ; end ;
37741: GO 37711
37743: POP
37744: POP
// if selected then
37745: LD_VAR 0 7
37749: IFFALSE 37848
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37751: LD_ADDR_VAR 0 3
37755: PUSH
37756: LD_EXP 79
37760: PUSH
37761: LD_VAR 0 2
37765: ARRAY
37766: PPUSH
37767: LD_INT 25
37769: PUSH
37770: LD_INT 12
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PPUSH
37777: CALL_OW 72
37781: PUSH
37782: FOR_IN
37783: IFFALSE 37846
// if not HasTask ( j ) then
37785: LD_VAR 0 3
37789: PPUSH
37790: CALL_OW 314
37794: NOT
37795: IFFALSE 37844
// begin if not IsInUnit ( j ) then
37797: LD_VAR 0 3
37801: PPUSH
37802: CALL_OW 310
37806: NOT
37807: IFFALSE 37823
// ComEnterUnit ( j , selected ) ;
37809: LD_VAR 0 3
37813: PPUSH
37814: LD_VAR 0 7
37818: PPUSH
37819: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37823: LD_VAR 0 3
37827: PPUSH
37828: LD_INT 16
37830: PPUSH
37831: CALL_OW 183
// AddComExitBuilding ( j ) ;
37835: LD_VAR 0 3
37839: PPUSH
37840: CALL_OW 182
// end ;
37844: GO 37782
37846: POP
37847: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37848: LD_VAR 0 5
37852: PPUSH
37853: LD_INT 11
37855: PPUSH
37856: CALL_OW 325
37860: IFFALSE 38119
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37862: LD_ADDR_VAR 0 4
37866: PUSH
37867: LD_EXP 79
37871: PUSH
37872: LD_VAR 0 2
37876: ARRAY
37877: PPUSH
37878: LD_INT 25
37880: PUSH
37881: LD_INT 16
37883: PUSH
37884: EMPTY
37885: LIST
37886: LIST
37887: PPUSH
37888: CALL_OW 72
37892: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37893: LD_VAR 0 4
37897: PUSH
37898: LD_INT 6
37900: GREATEREQUAL
37901: PUSH
37902: LD_VAR 0 5
37906: PPUSH
37907: LD_INT 2
37909: PPUSH
37910: CALL_OW 325
37914: NOT
37915: OR
37916: IFFALSE 38119
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37918: LD_ADDR_VAR 0 8
37922: PUSH
37923: LD_EXP 50
37927: PUSH
37928: LD_VAR 0 2
37932: ARRAY
37933: PPUSH
37934: LD_INT 2
37936: PUSH
37937: LD_INT 30
37939: PUSH
37940: LD_INT 4
37942: PUSH
37943: EMPTY
37944: LIST
37945: LIST
37946: PUSH
37947: LD_INT 30
37949: PUSH
37950: LD_INT 5
37952: PUSH
37953: EMPTY
37954: LIST
37955: LIST
37956: PUSH
37957: EMPTY
37958: LIST
37959: LIST
37960: LIST
37961: PPUSH
37962: CALL_OW 72
37966: ST_TO_ADDR
// if barracks then
37967: LD_VAR 0 8
37971: IFFALSE 38119
// begin selected := 0 ;
37973: LD_ADDR_VAR 0 7
37977: PUSH
37978: LD_INT 0
37980: ST_TO_ADDR
// for j in barracks do
37981: LD_ADDR_VAR 0 3
37985: PUSH
37986: LD_VAR 0 8
37990: PUSH
37991: FOR_IN
37992: IFFALSE 38023
// begin if UnitsInside ( j ) < 6 then
37994: LD_VAR 0 3
37998: PPUSH
37999: CALL_OW 313
38003: PUSH
38004: LD_INT 6
38006: LESS
38007: IFFALSE 38021
// begin selected := j ;
38009: LD_ADDR_VAR 0 7
38013: PUSH
38014: LD_VAR 0 3
38018: ST_TO_ADDR
// break ;
38019: GO 38023
// end ; end ;
38021: GO 37991
38023: POP
38024: POP
// if selected then
38025: LD_VAR 0 7
38029: IFFALSE 38119
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38031: LD_ADDR_VAR 0 3
38035: PUSH
38036: LD_EXP 79
38040: PUSH
38041: LD_VAR 0 2
38045: ARRAY
38046: PPUSH
38047: LD_INT 25
38049: PUSH
38050: LD_INT 12
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PPUSH
38057: CALL_OW 72
38061: PUSH
38062: FOR_IN
38063: IFFALSE 38117
// if not IsInUnit ( j ) and not HasTask ( j ) then
38065: LD_VAR 0 3
38069: PPUSH
38070: CALL_OW 310
38074: NOT
38075: PUSH
38076: LD_VAR 0 3
38080: PPUSH
38081: CALL_OW 314
38085: NOT
38086: AND
38087: IFFALSE 38115
// begin ComEnterUnit ( j , selected ) ;
38089: LD_VAR 0 3
38093: PPUSH
38094: LD_VAR 0 7
38098: PPUSH
38099: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38103: LD_VAR 0 3
38107: PPUSH
38108: LD_INT 15
38110: PPUSH
38111: CALL_OW 183
// end ;
38115: GO 38062
38117: POP
38118: POP
// end ; end ; end ; end ; end ;
38119: GO 37512
38121: POP
38122: POP
// end ;
38123: LD_VAR 0 1
38127: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38128: LD_INT 0
38130: PPUSH
38131: PPUSH
38132: PPUSH
38133: PPUSH
// if not mc_bases then
38134: LD_EXP 50
38138: NOT
38139: IFFALSE 38143
// exit ;
38141: GO 38321
// for i = 1 to mc_bases do
38143: LD_ADDR_VAR 0 2
38147: PUSH
38148: DOUBLE
38149: LD_INT 1
38151: DEC
38152: ST_TO_ADDR
38153: LD_EXP 50
38157: PUSH
38158: FOR_TO
38159: IFFALSE 38319
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38161: LD_ADDR_VAR 0 4
38165: PUSH
38166: LD_EXP 50
38170: PUSH
38171: LD_VAR 0 2
38175: ARRAY
38176: PPUSH
38177: LD_INT 25
38179: PUSH
38180: LD_INT 9
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PPUSH
38187: CALL_OW 72
38191: ST_TO_ADDR
// if not tmp then
38192: LD_VAR 0 4
38196: NOT
38197: IFFALSE 38201
// continue ;
38199: GO 38158
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38201: LD_EXP 76
38205: PUSH
38206: LD_VAR 0 2
38210: ARRAY
38211: PPUSH
38212: LD_INT 29
38214: PPUSH
38215: CALL_OW 325
38219: NOT
38220: PUSH
38221: LD_EXP 76
38225: PUSH
38226: LD_VAR 0 2
38230: ARRAY
38231: PPUSH
38232: LD_INT 28
38234: PPUSH
38235: CALL_OW 325
38239: NOT
38240: AND
38241: IFFALSE 38245
// continue ;
38243: GO 38158
// for j in tmp do
38245: LD_ADDR_VAR 0 3
38249: PUSH
38250: LD_VAR 0 4
38254: PUSH
38255: FOR_IN
38256: IFFALSE 38315
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38258: LD_VAR 0 3
38262: PUSH
38263: LD_EXP 53
38267: PUSH
38268: LD_VAR 0 2
38272: ARRAY
38273: PUSH
38274: LD_INT 1
38276: ARRAY
38277: IN
38278: NOT
38279: PUSH
38280: LD_VAR 0 3
38284: PUSH
38285: LD_EXP 53
38289: PUSH
38290: LD_VAR 0 2
38294: ARRAY
38295: PUSH
38296: LD_INT 2
38298: ARRAY
38299: IN
38300: NOT
38301: AND
38302: IFFALSE 38313
// ComSpaceTimeShoot ( j ) ;
38304: LD_VAR 0 3
38308: PPUSH
38309: CALL 49525 0 1
38313: GO 38255
38315: POP
38316: POP
// end ;
38317: GO 38158
38319: POP
38320: POP
// end ;
38321: LD_VAR 0 1
38325: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38326: LD_INT 0
38328: PPUSH
38329: PPUSH
38330: PPUSH
38331: PPUSH
38332: PPUSH
38333: PPUSH
38334: PPUSH
38335: PPUSH
38336: PPUSH
// if not mc_bases then
38337: LD_EXP 50
38341: NOT
38342: IFFALSE 38346
// exit ;
38344: GO 38968
// for i = 1 to mc_bases do
38346: LD_ADDR_VAR 0 2
38350: PUSH
38351: DOUBLE
38352: LD_INT 1
38354: DEC
38355: ST_TO_ADDR
38356: LD_EXP 50
38360: PUSH
38361: FOR_TO
38362: IFFALSE 38966
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38364: LD_EXP 85
38368: PUSH
38369: LD_VAR 0 2
38373: ARRAY
38374: NOT
38375: PUSH
38376: LD_INT 38
38378: PPUSH
38379: LD_EXP 76
38383: PUSH
38384: LD_VAR 0 2
38388: ARRAY
38389: PPUSH
38390: CALL_OW 321
38394: PUSH
38395: LD_INT 2
38397: NONEQUAL
38398: OR
38399: IFFALSE 38403
// continue ;
38401: GO 38361
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38403: LD_ADDR_VAR 0 8
38407: PUSH
38408: LD_EXP 50
38412: PUSH
38413: LD_VAR 0 2
38417: ARRAY
38418: PPUSH
38419: LD_INT 30
38421: PUSH
38422: LD_INT 34
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PPUSH
38429: CALL_OW 72
38433: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38434: LD_ADDR_VAR 0 9
38438: PUSH
38439: LD_EXP 50
38443: PUSH
38444: LD_VAR 0 2
38448: ARRAY
38449: PPUSH
38450: LD_INT 25
38452: PUSH
38453: LD_INT 4
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PPUSH
38460: CALL_OW 72
38464: PPUSH
38465: LD_INT 0
38467: PPUSH
38468: CALL 82833 0 2
38472: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38473: LD_VAR 0 9
38477: NOT
38478: PUSH
38479: LD_VAR 0 8
38483: NOT
38484: OR
38485: PUSH
38486: LD_EXP 50
38490: PUSH
38491: LD_VAR 0 2
38495: ARRAY
38496: PPUSH
38497: LD_INT 124
38499: PPUSH
38500: CALL 82833 0 2
38504: OR
38505: IFFALSE 38509
// continue ;
38507: GO 38361
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38509: LD_EXP 86
38513: PUSH
38514: LD_VAR 0 2
38518: ARRAY
38519: PUSH
38520: LD_EXP 85
38524: PUSH
38525: LD_VAR 0 2
38529: ARRAY
38530: LESS
38531: PUSH
38532: LD_EXP 86
38536: PUSH
38537: LD_VAR 0 2
38541: ARRAY
38542: PUSH
38543: LD_VAR 0 8
38547: LESS
38548: AND
38549: IFFALSE 38964
// begin tmp := sci [ 1 ] ;
38551: LD_ADDR_VAR 0 7
38555: PUSH
38556: LD_VAR 0 9
38560: PUSH
38561: LD_INT 1
38563: ARRAY
38564: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38565: LD_VAR 0 7
38569: PPUSH
38570: LD_INT 124
38572: PPUSH
38573: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38577: LD_ADDR_VAR 0 3
38581: PUSH
38582: DOUBLE
38583: LD_EXP 85
38587: PUSH
38588: LD_VAR 0 2
38592: ARRAY
38593: INC
38594: ST_TO_ADDR
38595: LD_EXP 85
38599: PUSH
38600: LD_VAR 0 2
38604: ARRAY
38605: PUSH
38606: FOR_DOWNTO
38607: IFFALSE 38950
// begin if IsInUnit ( tmp ) then
38609: LD_VAR 0 7
38613: PPUSH
38614: CALL_OW 310
38618: IFFALSE 38629
// ComExitBuilding ( tmp ) ;
38620: LD_VAR 0 7
38624: PPUSH
38625: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38629: LD_INT 35
38631: PPUSH
38632: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38636: LD_VAR 0 7
38640: PPUSH
38641: CALL_OW 310
38645: NOT
38646: PUSH
38647: LD_VAR 0 7
38651: PPUSH
38652: CALL_OW 314
38656: NOT
38657: AND
38658: IFFALSE 38629
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38660: LD_ADDR_VAR 0 6
38664: PUSH
38665: LD_VAR 0 7
38669: PPUSH
38670: CALL_OW 250
38674: PUSH
38675: LD_VAR 0 7
38679: PPUSH
38680: CALL_OW 251
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38689: LD_INT 35
38691: PPUSH
38692: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38696: LD_ADDR_VAR 0 4
38700: PUSH
38701: LD_EXP 85
38705: PUSH
38706: LD_VAR 0 2
38710: ARRAY
38711: PUSH
38712: LD_VAR 0 3
38716: ARRAY
38717: PUSH
38718: LD_INT 1
38720: ARRAY
38721: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38722: LD_ADDR_VAR 0 5
38726: PUSH
38727: LD_EXP 85
38731: PUSH
38732: LD_VAR 0 2
38736: ARRAY
38737: PUSH
38738: LD_VAR 0 3
38742: ARRAY
38743: PUSH
38744: LD_INT 2
38746: ARRAY
38747: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38748: LD_VAR 0 7
38752: PPUSH
38753: LD_INT 10
38755: PPUSH
38756: CALL 56163 0 2
38760: PUSH
38761: LD_INT 4
38763: ARRAY
38764: IFFALSE 38802
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38766: LD_VAR 0 7
38770: PPUSH
38771: LD_VAR 0 6
38775: PUSH
38776: LD_INT 1
38778: ARRAY
38779: PPUSH
38780: LD_VAR 0 6
38784: PUSH
38785: LD_INT 2
38787: ARRAY
38788: PPUSH
38789: CALL_OW 111
// wait ( 0 0$10 ) ;
38793: LD_INT 350
38795: PPUSH
38796: CALL_OW 67
// end else
38800: GO 38828
// begin ComMoveXY ( tmp , x , y ) ;
38802: LD_VAR 0 7
38806: PPUSH
38807: LD_VAR 0 4
38811: PPUSH
38812: LD_VAR 0 5
38816: PPUSH
38817: CALL_OW 111
// wait ( 0 0$3 ) ;
38821: LD_INT 105
38823: PPUSH
38824: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38828: LD_VAR 0 7
38832: PPUSH
38833: LD_VAR 0 4
38837: PPUSH
38838: LD_VAR 0 5
38842: PPUSH
38843: CALL_OW 307
38847: IFFALSE 38689
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38849: LD_VAR 0 7
38853: PPUSH
38854: LD_VAR 0 4
38858: PPUSH
38859: LD_VAR 0 5
38863: PPUSH
38864: LD_VAR 0 8
38868: PUSH
38869: LD_VAR 0 3
38873: ARRAY
38874: PPUSH
38875: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38879: LD_INT 35
38881: PPUSH
38882: CALL_OW 67
// until not HasTask ( tmp ) ;
38886: LD_VAR 0 7
38890: PPUSH
38891: CALL_OW 314
38895: NOT
38896: IFFALSE 38879
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38898: LD_ADDR_EXP 86
38902: PUSH
38903: LD_EXP 86
38907: PPUSH
38908: LD_VAR 0 2
38912: PUSH
38913: LD_EXP 86
38917: PUSH
38918: LD_VAR 0 2
38922: ARRAY
38923: PUSH
38924: LD_INT 1
38926: PLUS
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PPUSH
38932: LD_VAR 0 8
38936: PUSH
38937: LD_VAR 0 3
38941: ARRAY
38942: PPUSH
38943: CALL 53564 0 3
38947: ST_TO_ADDR
// end ;
38948: GO 38606
38950: POP
38951: POP
// MC_Reset ( i , 124 ) ;
38952: LD_VAR 0 2
38956: PPUSH
38957: LD_INT 124
38959: PPUSH
38960: CALL 22106 0 2
// end ; end ;
38964: GO 38361
38966: POP
38967: POP
// end ;
38968: LD_VAR 0 1
38972: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
38973: LD_INT 0
38975: PPUSH
38976: PPUSH
38977: PPUSH
// if not mc_bases then
38978: LD_EXP 50
38982: NOT
38983: IFFALSE 38987
// exit ;
38985: GO 39593
// for i = 1 to mc_bases do
38987: LD_ADDR_VAR 0 2
38991: PUSH
38992: DOUBLE
38993: LD_INT 1
38995: DEC
38996: ST_TO_ADDR
38997: LD_EXP 50
39001: PUSH
39002: FOR_TO
39003: IFFALSE 39591
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39005: LD_ADDR_VAR 0 3
39009: PUSH
39010: LD_EXP 50
39014: PUSH
39015: LD_VAR 0 2
39019: ARRAY
39020: PPUSH
39021: LD_INT 25
39023: PUSH
39024: LD_INT 4
39026: PUSH
39027: EMPTY
39028: LIST
39029: LIST
39030: PPUSH
39031: CALL_OW 72
39035: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39036: LD_VAR 0 3
39040: NOT
39041: PUSH
39042: LD_EXP 87
39046: PUSH
39047: LD_VAR 0 2
39051: ARRAY
39052: NOT
39053: OR
39054: PUSH
39055: LD_EXP 50
39059: PUSH
39060: LD_VAR 0 2
39064: ARRAY
39065: PPUSH
39066: LD_INT 2
39068: PUSH
39069: LD_INT 30
39071: PUSH
39072: LD_INT 0
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 30
39081: PUSH
39082: LD_INT 1
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: LIST
39093: PPUSH
39094: CALL_OW 72
39098: NOT
39099: OR
39100: IFFALSE 39150
// begin if mc_deposits_finder [ i ] then
39102: LD_EXP 88
39106: PUSH
39107: LD_VAR 0 2
39111: ARRAY
39112: IFFALSE 39148
// begin MC_Reset ( i , 125 ) ;
39114: LD_VAR 0 2
39118: PPUSH
39119: LD_INT 125
39121: PPUSH
39122: CALL 22106 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39126: LD_ADDR_EXP 88
39130: PUSH
39131: LD_EXP 88
39135: PPUSH
39136: LD_VAR 0 2
39140: PPUSH
39141: EMPTY
39142: PPUSH
39143: CALL_OW 1
39147: ST_TO_ADDR
// end ; continue ;
39148: GO 39002
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39150: LD_EXP 87
39154: PUSH
39155: LD_VAR 0 2
39159: ARRAY
39160: PUSH
39161: LD_INT 1
39163: ARRAY
39164: PUSH
39165: LD_INT 3
39167: ARRAY
39168: PUSH
39169: LD_INT 1
39171: EQUAL
39172: PUSH
39173: LD_INT 20
39175: PPUSH
39176: LD_EXP 76
39180: PUSH
39181: LD_VAR 0 2
39185: ARRAY
39186: PPUSH
39187: CALL_OW 321
39191: PUSH
39192: LD_INT 2
39194: NONEQUAL
39195: AND
39196: IFFALSE 39246
// begin if mc_deposits_finder [ i ] then
39198: LD_EXP 88
39202: PUSH
39203: LD_VAR 0 2
39207: ARRAY
39208: IFFALSE 39244
// begin MC_Reset ( i , 125 ) ;
39210: LD_VAR 0 2
39214: PPUSH
39215: LD_INT 125
39217: PPUSH
39218: CALL 22106 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39222: LD_ADDR_EXP 88
39226: PUSH
39227: LD_EXP 88
39231: PPUSH
39232: LD_VAR 0 2
39236: PPUSH
39237: EMPTY
39238: PPUSH
39239: CALL_OW 1
39243: ST_TO_ADDR
// end ; continue ;
39244: GO 39002
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39246: LD_EXP 87
39250: PUSH
39251: LD_VAR 0 2
39255: ARRAY
39256: PUSH
39257: LD_INT 1
39259: ARRAY
39260: PUSH
39261: LD_INT 1
39263: ARRAY
39264: PPUSH
39265: LD_EXP 87
39269: PUSH
39270: LD_VAR 0 2
39274: ARRAY
39275: PUSH
39276: LD_INT 1
39278: ARRAY
39279: PUSH
39280: LD_INT 2
39282: ARRAY
39283: PPUSH
39284: LD_EXP 76
39288: PUSH
39289: LD_VAR 0 2
39293: ARRAY
39294: PPUSH
39295: CALL_OW 440
39299: IFFALSE 39342
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39301: LD_ADDR_EXP 87
39305: PUSH
39306: LD_EXP 87
39310: PPUSH
39311: LD_VAR 0 2
39315: PPUSH
39316: LD_EXP 87
39320: PUSH
39321: LD_VAR 0 2
39325: ARRAY
39326: PPUSH
39327: LD_INT 1
39329: PPUSH
39330: CALL_OW 3
39334: PPUSH
39335: CALL_OW 1
39339: ST_TO_ADDR
39340: GO 39589
// begin if not mc_deposits_finder [ i ] then
39342: LD_EXP 88
39346: PUSH
39347: LD_VAR 0 2
39351: ARRAY
39352: NOT
39353: IFFALSE 39405
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39355: LD_ADDR_EXP 88
39359: PUSH
39360: LD_EXP 88
39364: PPUSH
39365: LD_VAR 0 2
39369: PPUSH
39370: LD_VAR 0 3
39374: PUSH
39375: LD_INT 1
39377: ARRAY
39378: PUSH
39379: EMPTY
39380: LIST
39381: PPUSH
39382: CALL_OW 1
39386: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39387: LD_VAR 0 3
39391: PUSH
39392: LD_INT 1
39394: ARRAY
39395: PPUSH
39396: LD_INT 125
39398: PPUSH
39399: CALL_OW 109
// end else
39403: GO 39589
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39405: LD_EXP 88
39409: PUSH
39410: LD_VAR 0 2
39414: ARRAY
39415: PUSH
39416: LD_INT 1
39418: ARRAY
39419: PPUSH
39420: CALL_OW 310
39424: IFFALSE 39447
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39426: LD_EXP 88
39430: PUSH
39431: LD_VAR 0 2
39435: ARRAY
39436: PUSH
39437: LD_INT 1
39439: ARRAY
39440: PPUSH
39441: CALL_OW 122
39445: GO 39589
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39447: LD_EXP 88
39451: PUSH
39452: LD_VAR 0 2
39456: ARRAY
39457: PUSH
39458: LD_INT 1
39460: ARRAY
39461: PPUSH
39462: CALL_OW 314
39466: NOT
39467: PUSH
39468: LD_EXP 88
39472: PUSH
39473: LD_VAR 0 2
39477: ARRAY
39478: PUSH
39479: LD_INT 1
39481: ARRAY
39482: PPUSH
39483: LD_EXP 87
39487: PUSH
39488: LD_VAR 0 2
39492: ARRAY
39493: PUSH
39494: LD_INT 1
39496: ARRAY
39497: PUSH
39498: LD_INT 1
39500: ARRAY
39501: PPUSH
39502: LD_EXP 87
39506: PUSH
39507: LD_VAR 0 2
39511: ARRAY
39512: PUSH
39513: LD_INT 1
39515: ARRAY
39516: PUSH
39517: LD_INT 2
39519: ARRAY
39520: PPUSH
39521: CALL_OW 297
39525: PUSH
39526: LD_INT 6
39528: GREATER
39529: AND
39530: IFFALSE 39589
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39532: LD_EXP 88
39536: PUSH
39537: LD_VAR 0 2
39541: ARRAY
39542: PUSH
39543: LD_INT 1
39545: ARRAY
39546: PPUSH
39547: LD_EXP 87
39551: PUSH
39552: LD_VAR 0 2
39556: ARRAY
39557: PUSH
39558: LD_INT 1
39560: ARRAY
39561: PUSH
39562: LD_INT 1
39564: ARRAY
39565: PPUSH
39566: LD_EXP 87
39570: PUSH
39571: LD_VAR 0 2
39575: ARRAY
39576: PUSH
39577: LD_INT 1
39579: ARRAY
39580: PUSH
39581: LD_INT 2
39583: ARRAY
39584: PPUSH
39585: CALL_OW 111
// end ; end ; end ;
39589: GO 39002
39591: POP
39592: POP
// end ;
39593: LD_VAR 0 1
39597: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39598: LD_INT 0
39600: PPUSH
39601: PPUSH
39602: PPUSH
39603: PPUSH
39604: PPUSH
39605: PPUSH
39606: PPUSH
39607: PPUSH
39608: PPUSH
39609: PPUSH
39610: PPUSH
// if not mc_bases then
39611: LD_EXP 50
39615: NOT
39616: IFFALSE 39620
// exit ;
39618: GO 40560
// for i = 1 to mc_bases do
39620: LD_ADDR_VAR 0 2
39624: PUSH
39625: DOUBLE
39626: LD_INT 1
39628: DEC
39629: ST_TO_ADDR
39630: LD_EXP 50
39634: PUSH
39635: FOR_TO
39636: IFFALSE 40558
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39638: LD_EXP 50
39642: PUSH
39643: LD_VAR 0 2
39647: ARRAY
39648: NOT
39649: PUSH
39650: LD_EXP 73
39654: PUSH
39655: LD_VAR 0 2
39659: ARRAY
39660: OR
39661: IFFALSE 39665
// continue ;
39663: GO 39635
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39665: LD_ADDR_VAR 0 7
39669: PUSH
39670: LD_EXP 50
39674: PUSH
39675: LD_VAR 0 2
39679: ARRAY
39680: PUSH
39681: LD_INT 1
39683: ARRAY
39684: PPUSH
39685: CALL_OW 248
39689: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39690: LD_VAR 0 7
39694: PUSH
39695: LD_INT 3
39697: EQUAL
39698: PUSH
39699: LD_EXP 69
39703: PUSH
39704: LD_VAR 0 2
39708: ARRAY
39709: PUSH
39710: LD_EXP 72
39714: PUSH
39715: LD_VAR 0 2
39719: ARRAY
39720: UNION
39721: PPUSH
39722: LD_INT 33
39724: PUSH
39725: LD_INT 2
39727: PUSH
39728: EMPTY
39729: LIST
39730: LIST
39731: PPUSH
39732: CALL_OW 72
39736: NOT
39737: OR
39738: IFFALSE 39742
// continue ;
39740: GO 39635
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39742: LD_ADDR_VAR 0 9
39746: PUSH
39747: LD_EXP 50
39751: PUSH
39752: LD_VAR 0 2
39756: ARRAY
39757: PPUSH
39758: LD_INT 30
39760: PUSH
39761: LD_INT 36
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PPUSH
39768: CALL_OW 72
39772: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39773: LD_ADDR_VAR 0 10
39777: PUSH
39778: LD_EXP 69
39782: PUSH
39783: LD_VAR 0 2
39787: ARRAY
39788: PPUSH
39789: LD_INT 34
39791: PUSH
39792: LD_INT 31
39794: PUSH
39795: EMPTY
39796: LIST
39797: LIST
39798: PPUSH
39799: CALL_OW 72
39803: ST_TO_ADDR
// if not cts and not mcts then
39804: LD_VAR 0 9
39808: NOT
39809: PUSH
39810: LD_VAR 0 10
39814: NOT
39815: AND
39816: IFFALSE 39820
// continue ;
39818: GO 39635
// x := cts ;
39820: LD_ADDR_VAR 0 11
39824: PUSH
39825: LD_VAR 0 9
39829: ST_TO_ADDR
// if not x then
39830: LD_VAR 0 11
39834: NOT
39835: IFFALSE 39847
// x := mcts ;
39837: LD_ADDR_VAR 0 11
39841: PUSH
39842: LD_VAR 0 10
39846: ST_TO_ADDR
// if not x then
39847: LD_VAR 0 11
39851: NOT
39852: IFFALSE 39856
// continue ;
39854: GO 39635
// if mc_remote_driver [ i ] then
39856: LD_EXP 90
39860: PUSH
39861: LD_VAR 0 2
39865: ARRAY
39866: IFFALSE 40253
// for j in mc_remote_driver [ i ] do
39868: LD_ADDR_VAR 0 3
39872: PUSH
39873: LD_EXP 90
39877: PUSH
39878: LD_VAR 0 2
39882: ARRAY
39883: PUSH
39884: FOR_IN
39885: IFFALSE 40251
// begin if GetClass ( j ) <> 3 then
39887: LD_VAR 0 3
39891: PPUSH
39892: CALL_OW 257
39896: PUSH
39897: LD_INT 3
39899: NONEQUAL
39900: IFFALSE 39953
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39902: LD_ADDR_EXP 90
39906: PUSH
39907: LD_EXP 90
39911: PPUSH
39912: LD_VAR 0 2
39916: PPUSH
39917: LD_EXP 90
39921: PUSH
39922: LD_VAR 0 2
39926: ARRAY
39927: PUSH
39928: LD_VAR 0 3
39932: DIFF
39933: PPUSH
39934: CALL_OW 1
39938: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39939: LD_VAR 0 3
39943: PPUSH
39944: LD_INT 0
39946: PPUSH
39947: CALL_OW 109
// continue ;
39951: GO 39884
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
39953: LD_EXP 69
39957: PUSH
39958: LD_VAR 0 2
39962: ARRAY
39963: PPUSH
39964: LD_INT 34
39966: PUSH
39967: LD_INT 31
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: LD_INT 58
39976: PUSH
39977: EMPTY
39978: LIST
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PPUSH
39984: CALL_OW 72
39988: PUSH
39989: LD_VAR 0 3
39993: PPUSH
39994: CALL 82868 0 1
39998: NOT
39999: AND
40000: IFFALSE 40071
// begin if IsInUnit ( j ) then
40002: LD_VAR 0 3
40006: PPUSH
40007: CALL_OW 310
40011: IFFALSE 40022
// ComExitBuilding ( j ) ;
40013: LD_VAR 0 3
40017: PPUSH
40018: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40022: LD_VAR 0 3
40026: PPUSH
40027: LD_EXP 69
40031: PUSH
40032: LD_VAR 0 2
40036: ARRAY
40037: PPUSH
40038: LD_INT 34
40040: PUSH
40041: LD_INT 31
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 58
40050: PUSH
40051: EMPTY
40052: LIST
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PPUSH
40058: CALL_OW 72
40062: PUSH
40063: LD_INT 1
40065: ARRAY
40066: PPUSH
40067: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40071: LD_VAR 0 3
40075: PPUSH
40076: CALL_OW 310
40080: NOT
40081: PUSH
40082: LD_VAR 0 3
40086: PPUSH
40087: CALL_OW 310
40091: PPUSH
40092: CALL_OW 266
40096: PUSH
40097: LD_INT 36
40099: NONEQUAL
40100: PUSH
40101: LD_VAR 0 3
40105: PPUSH
40106: CALL 82868 0 1
40110: NOT
40111: AND
40112: OR
40113: IFFALSE 40249
// begin if IsInUnit ( j ) then
40115: LD_VAR 0 3
40119: PPUSH
40120: CALL_OW 310
40124: IFFALSE 40135
// ComExitBuilding ( j ) ;
40126: LD_VAR 0 3
40130: PPUSH
40131: CALL_OW 122
// ct := 0 ;
40135: LD_ADDR_VAR 0 8
40139: PUSH
40140: LD_INT 0
40142: ST_TO_ADDR
// for k in x do
40143: LD_ADDR_VAR 0 4
40147: PUSH
40148: LD_VAR 0 11
40152: PUSH
40153: FOR_IN
40154: IFFALSE 40227
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40156: LD_VAR 0 4
40160: PPUSH
40161: CALL_OW 264
40165: PUSH
40166: LD_INT 31
40168: EQUAL
40169: PUSH
40170: LD_VAR 0 4
40174: PPUSH
40175: CALL_OW 311
40179: NOT
40180: AND
40181: PUSH
40182: LD_VAR 0 4
40186: PPUSH
40187: CALL_OW 266
40191: PUSH
40192: LD_INT 36
40194: EQUAL
40195: PUSH
40196: LD_VAR 0 4
40200: PPUSH
40201: CALL_OW 313
40205: PUSH
40206: LD_INT 3
40208: LESS
40209: AND
40210: OR
40211: IFFALSE 40225
// begin ct := k ;
40213: LD_ADDR_VAR 0 8
40217: PUSH
40218: LD_VAR 0 4
40222: ST_TO_ADDR
// break ;
40223: GO 40227
// end ;
40225: GO 40153
40227: POP
40228: POP
// if ct then
40229: LD_VAR 0 8
40233: IFFALSE 40249
// ComEnterUnit ( j , ct ) ;
40235: LD_VAR 0 3
40239: PPUSH
40240: LD_VAR 0 8
40244: PPUSH
40245: CALL_OW 120
// end ; end ;
40249: GO 39884
40251: POP
40252: POP
// places := 0 ;
40253: LD_ADDR_VAR 0 5
40257: PUSH
40258: LD_INT 0
40260: ST_TO_ADDR
// for j = 1 to x do
40261: LD_ADDR_VAR 0 3
40265: PUSH
40266: DOUBLE
40267: LD_INT 1
40269: DEC
40270: ST_TO_ADDR
40271: LD_VAR 0 11
40275: PUSH
40276: FOR_TO
40277: IFFALSE 40353
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40279: LD_VAR 0 11
40283: PUSH
40284: LD_VAR 0 3
40288: ARRAY
40289: PPUSH
40290: CALL_OW 264
40294: PUSH
40295: LD_INT 31
40297: EQUAL
40298: IFFALSE 40316
// places := places + 1 else
40300: LD_ADDR_VAR 0 5
40304: PUSH
40305: LD_VAR 0 5
40309: PUSH
40310: LD_INT 1
40312: PLUS
40313: ST_TO_ADDR
40314: GO 40351
// if GetBType ( x [ j ] ) = b_control_tower then
40316: LD_VAR 0 11
40320: PUSH
40321: LD_VAR 0 3
40325: ARRAY
40326: PPUSH
40327: CALL_OW 266
40331: PUSH
40332: LD_INT 36
40334: EQUAL
40335: IFFALSE 40351
// places := places + 3 ;
40337: LD_ADDR_VAR 0 5
40341: PUSH
40342: LD_VAR 0 5
40346: PUSH
40347: LD_INT 3
40349: PLUS
40350: ST_TO_ADDR
40351: GO 40276
40353: POP
40354: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40355: LD_VAR 0 5
40359: PUSH
40360: LD_INT 0
40362: EQUAL
40363: PUSH
40364: LD_VAR 0 5
40368: PUSH
40369: LD_EXP 90
40373: PUSH
40374: LD_VAR 0 2
40378: ARRAY
40379: LESSEQUAL
40380: OR
40381: IFFALSE 40385
// continue ;
40383: GO 39635
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40385: LD_ADDR_VAR 0 6
40389: PUSH
40390: LD_EXP 50
40394: PUSH
40395: LD_VAR 0 2
40399: ARRAY
40400: PPUSH
40401: LD_INT 25
40403: PUSH
40404: LD_INT 3
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PPUSH
40411: CALL_OW 72
40415: PUSH
40416: LD_EXP 90
40420: PUSH
40421: LD_VAR 0 2
40425: ARRAY
40426: DIFF
40427: PPUSH
40428: LD_INT 3
40430: PPUSH
40431: CALL 83768 0 2
40435: ST_TO_ADDR
// for j in tmp do
40436: LD_ADDR_VAR 0 3
40440: PUSH
40441: LD_VAR 0 6
40445: PUSH
40446: FOR_IN
40447: IFFALSE 40482
// if GetTag ( j ) > 0 then
40449: LD_VAR 0 3
40453: PPUSH
40454: CALL_OW 110
40458: PUSH
40459: LD_INT 0
40461: GREATER
40462: IFFALSE 40480
// tmp := tmp diff j ;
40464: LD_ADDR_VAR 0 6
40468: PUSH
40469: LD_VAR 0 6
40473: PUSH
40474: LD_VAR 0 3
40478: DIFF
40479: ST_TO_ADDR
40480: GO 40446
40482: POP
40483: POP
// if not tmp then
40484: LD_VAR 0 6
40488: NOT
40489: IFFALSE 40493
// continue ;
40491: GO 39635
// if places then
40493: LD_VAR 0 5
40497: IFFALSE 40556
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40499: LD_ADDR_EXP 90
40503: PUSH
40504: LD_EXP 90
40508: PPUSH
40509: LD_VAR 0 2
40513: PPUSH
40514: LD_EXP 90
40518: PUSH
40519: LD_VAR 0 2
40523: ARRAY
40524: PUSH
40525: LD_VAR 0 6
40529: PUSH
40530: LD_INT 1
40532: ARRAY
40533: UNION
40534: PPUSH
40535: CALL_OW 1
40539: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40540: LD_VAR 0 6
40544: PUSH
40545: LD_INT 1
40547: ARRAY
40548: PPUSH
40549: LD_INT 126
40551: PPUSH
40552: CALL_OW 109
// end ; end ;
40556: GO 39635
40558: POP
40559: POP
// end ;
40560: LD_VAR 0 1
40564: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40565: LD_INT 0
40567: PPUSH
40568: PPUSH
40569: PPUSH
40570: PPUSH
40571: PPUSH
40572: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40573: LD_VAR 0 1
40577: NOT
40578: PUSH
40579: LD_VAR 0 2
40583: NOT
40584: OR
40585: PUSH
40586: LD_VAR 0 3
40590: NOT
40591: OR
40592: PUSH
40593: LD_VAR 0 4
40597: PUSH
40598: LD_INT 1
40600: PUSH
40601: LD_INT 2
40603: PUSH
40604: LD_INT 3
40606: PUSH
40607: LD_INT 4
40609: PUSH
40610: LD_INT 5
40612: PUSH
40613: LD_INT 8
40615: PUSH
40616: LD_INT 9
40618: PUSH
40619: LD_INT 15
40621: PUSH
40622: LD_INT 16
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: LIST
40629: LIST
40630: LIST
40631: LIST
40632: LIST
40633: LIST
40634: LIST
40635: IN
40636: NOT
40637: OR
40638: IFFALSE 40642
// exit ;
40640: GO 41542
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40642: LD_ADDR_VAR 0 2
40646: PUSH
40647: LD_VAR 0 2
40651: PPUSH
40652: LD_INT 21
40654: PUSH
40655: LD_INT 3
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PUSH
40662: LD_INT 24
40664: PUSH
40665: LD_INT 250
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: EMPTY
40673: LIST
40674: LIST
40675: PPUSH
40676: CALL_OW 72
40680: ST_TO_ADDR
// case class of 1 , 15 :
40681: LD_VAR 0 4
40685: PUSH
40686: LD_INT 1
40688: DOUBLE
40689: EQUAL
40690: IFTRUE 40700
40692: LD_INT 15
40694: DOUBLE
40695: EQUAL
40696: IFTRUE 40700
40698: GO 40785
40700: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40701: LD_ADDR_VAR 0 8
40705: PUSH
40706: LD_VAR 0 2
40710: PPUSH
40711: LD_INT 2
40713: PUSH
40714: LD_INT 30
40716: PUSH
40717: LD_INT 32
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: PUSH
40724: LD_INT 30
40726: PUSH
40727: LD_INT 31
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: LIST
40738: PPUSH
40739: CALL_OW 72
40743: PUSH
40744: LD_VAR 0 2
40748: PPUSH
40749: LD_INT 2
40751: PUSH
40752: LD_INT 30
40754: PUSH
40755: LD_INT 4
40757: PUSH
40758: EMPTY
40759: LIST
40760: LIST
40761: PUSH
40762: LD_INT 30
40764: PUSH
40765: LD_INT 5
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: LIST
40776: PPUSH
40777: CALL_OW 72
40781: ADD
40782: ST_TO_ADDR
40783: GO 41031
40785: LD_INT 2
40787: DOUBLE
40788: EQUAL
40789: IFTRUE 40799
40791: LD_INT 16
40793: DOUBLE
40794: EQUAL
40795: IFTRUE 40799
40797: GO 40845
40799: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40800: LD_ADDR_VAR 0 8
40804: PUSH
40805: LD_VAR 0 2
40809: PPUSH
40810: LD_INT 2
40812: PUSH
40813: LD_INT 30
40815: PUSH
40816: LD_INT 0
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PUSH
40823: LD_INT 30
40825: PUSH
40826: LD_INT 1
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: LIST
40837: PPUSH
40838: CALL_OW 72
40842: ST_TO_ADDR
40843: GO 41031
40845: LD_INT 3
40847: DOUBLE
40848: EQUAL
40849: IFTRUE 40853
40851: GO 40899
40853: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40854: LD_ADDR_VAR 0 8
40858: PUSH
40859: LD_VAR 0 2
40863: PPUSH
40864: LD_INT 2
40866: PUSH
40867: LD_INT 30
40869: PUSH
40870: LD_INT 2
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: LD_INT 30
40879: PUSH
40880: LD_INT 3
40882: PUSH
40883: EMPTY
40884: LIST
40885: LIST
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: LIST
40891: PPUSH
40892: CALL_OW 72
40896: ST_TO_ADDR
40897: GO 41031
40899: LD_INT 4
40901: DOUBLE
40902: EQUAL
40903: IFTRUE 40907
40905: GO 40964
40907: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40908: LD_ADDR_VAR 0 8
40912: PUSH
40913: LD_VAR 0 2
40917: PPUSH
40918: LD_INT 2
40920: PUSH
40921: LD_INT 30
40923: PUSH
40924: LD_INT 6
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: LD_INT 30
40933: PUSH
40934: LD_INT 7
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PUSH
40941: LD_INT 30
40943: PUSH
40944: LD_INT 8
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: LIST
40955: LIST
40956: PPUSH
40957: CALL_OW 72
40961: ST_TO_ADDR
40962: GO 41031
40964: LD_INT 5
40966: DOUBLE
40967: EQUAL
40968: IFTRUE 40984
40970: LD_INT 8
40972: DOUBLE
40973: EQUAL
40974: IFTRUE 40984
40976: LD_INT 9
40978: DOUBLE
40979: EQUAL
40980: IFTRUE 40984
40982: GO 41030
40984: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
40985: LD_ADDR_VAR 0 8
40989: PUSH
40990: LD_VAR 0 2
40994: PPUSH
40995: LD_INT 2
40997: PUSH
40998: LD_INT 30
41000: PUSH
41001: LD_INT 4
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: LD_INT 30
41010: PUSH
41011: LD_INT 5
41013: PUSH
41014: EMPTY
41015: LIST
41016: LIST
41017: PUSH
41018: EMPTY
41019: LIST
41020: LIST
41021: LIST
41022: PPUSH
41023: CALL_OW 72
41027: ST_TO_ADDR
41028: GO 41031
41030: POP
// if not tmp then
41031: LD_VAR 0 8
41035: NOT
41036: IFFALSE 41040
// exit ;
41038: GO 41542
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41040: LD_VAR 0 4
41044: PUSH
41045: LD_INT 1
41047: PUSH
41048: LD_INT 15
41050: PUSH
41051: EMPTY
41052: LIST
41053: LIST
41054: IN
41055: PUSH
41056: LD_EXP 59
41060: PUSH
41061: LD_VAR 0 1
41065: ARRAY
41066: AND
41067: IFFALSE 41223
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41069: LD_ADDR_VAR 0 9
41073: PUSH
41074: LD_EXP 59
41078: PUSH
41079: LD_VAR 0 1
41083: ARRAY
41084: PUSH
41085: LD_INT 1
41087: ARRAY
41088: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41089: LD_VAR 0 9
41093: PUSH
41094: LD_EXP 60
41098: PUSH
41099: LD_VAR 0 1
41103: ARRAY
41104: IN
41105: NOT
41106: IFFALSE 41221
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41108: LD_ADDR_EXP 60
41112: PUSH
41113: LD_EXP 60
41117: PPUSH
41118: LD_VAR 0 1
41122: PUSH
41123: LD_EXP 60
41127: PUSH
41128: LD_VAR 0 1
41132: ARRAY
41133: PUSH
41134: LD_INT 1
41136: PLUS
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PPUSH
41142: LD_VAR 0 9
41146: PPUSH
41147: CALL 53564 0 3
41151: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41152: LD_ADDR_EXP 59
41156: PUSH
41157: LD_EXP 59
41161: PPUSH
41162: LD_VAR 0 1
41166: PPUSH
41167: LD_EXP 59
41171: PUSH
41172: LD_VAR 0 1
41176: ARRAY
41177: PUSH
41178: LD_VAR 0 9
41182: DIFF
41183: PPUSH
41184: CALL_OW 1
41188: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41189: LD_VAR 0 3
41193: PPUSH
41194: LD_EXP 60
41198: PUSH
41199: LD_VAR 0 1
41203: ARRAY
41204: PUSH
41205: LD_EXP 60
41209: PUSH
41210: LD_VAR 0 1
41214: ARRAY
41215: ARRAY
41216: PPUSH
41217: CALL_OW 120
// end ; exit ;
41221: GO 41542
// end ; if tmp > 1 then
41223: LD_VAR 0 8
41227: PUSH
41228: LD_INT 1
41230: GREATER
41231: IFFALSE 41335
// for i = 2 to tmp do
41233: LD_ADDR_VAR 0 6
41237: PUSH
41238: DOUBLE
41239: LD_INT 2
41241: DEC
41242: ST_TO_ADDR
41243: LD_VAR 0 8
41247: PUSH
41248: FOR_TO
41249: IFFALSE 41333
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41251: LD_VAR 0 8
41255: PUSH
41256: LD_VAR 0 6
41260: ARRAY
41261: PPUSH
41262: CALL_OW 461
41266: PUSH
41267: LD_INT 6
41269: EQUAL
41270: IFFALSE 41331
// begin x := tmp [ i ] ;
41272: LD_ADDR_VAR 0 9
41276: PUSH
41277: LD_VAR 0 8
41281: PUSH
41282: LD_VAR 0 6
41286: ARRAY
41287: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41288: LD_ADDR_VAR 0 8
41292: PUSH
41293: LD_VAR 0 8
41297: PPUSH
41298: LD_VAR 0 6
41302: PPUSH
41303: CALL_OW 3
41307: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41308: LD_ADDR_VAR 0 8
41312: PUSH
41313: LD_VAR 0 8
41317: PPUSH
41318: LD_INT 1
41320: PPUSH
41321: LD_VAR 0 9
41325: PPUSH
41326: CALL_OW 2
41330: ST_TO_ADDR
// end ;
41331: GO 41248
41333: POP
41334: POP
// for i in tmp do
41335: LD_ADDR_VAR 0 6
41339: PUSH
41340: LD_VAR 0 8
41344: PUSH
41345: FOR_IN
41346: IFFALSE 41415
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41348: LD_VAR 0 6
41352: PPUSH
41353: CALL_OW 313
41357: PUSH
41358: LD_INT 6
41360: LESS
41361: PUSH
41362: LD_VAR 0 6
41366: PPUSH
41367: CALL_OW 266
41371: PUSH
41372: LD_INT 31
41374: PUSH
41375: LD_INT 32
41377: PUSH
41378: EMPTY
41379: LIST
41380: LIST
41381: IN
41382: NOT
41383: AND
41384: PUSH
41385: LD_VAR 0 6
41389: PPUSH
41390: CALL_OW 313
41394: PUSH
41395: LD_INT 0
41397: EQUAL
41398: OR
41399: IFFALSE 41413
// begin j := i ;
41401: LD_ADDR_VAR 0 7
41405: PUSH
41406: LD_VAR 0 6
41410: ST_TO_ADDR
// break ;
41411: GO 41415
// end ; end ;
41413: GO 41345
41415: POP
41416: POP
// if j then
41417: LD_VAR 0 7
41421: IFFALSE 41439
// ComEnterUnit ( unit , j ) else
41423: LD_VAR 0 3
41427: PPUSH
41428: LD_VAR 0 7
41432: PPUSH
41433: CALL_OW 120
41437: GO 41542
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41439: LD_ADDR_VAR 0 10
41443: PUSH
41444: LD_VAR 0 2
41448: PPUSH
41449: LD_INT 2
41451: PUSH
41452: LD_INT 30
41454: PUSH
41455: LD_INT 0
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 30
41464: PUSH
41465: LD_INT 1
41467: PUSH
41468: EMPTY
41469: LIST
41470: LIST
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: LIST
41476: PPUSH
41477: CALL_OW 72
41481: ST_TO_ADDR
// if depot then
41482: LD_VAR 0 10
41486: IFFALSE 41542
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41488: LD_ADDR_VAR 0 10
41492: PUSH
41493: LD_VAR 0 10
41497: PPUSH
41498: LD_VAR 0 3
41502: PPUSH
41503: CALL_OW 74
41507: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41508: LD_VAR 0 3
41512: PPUSH
41513: LD_VAR 0 10
41517: PPUSH
41518: CALL_OW 296
41522: PUSH
41523: LD_INT 10
41525: GREATER
41526: IFFALSE 41542
// ComStandNearbyBuilding ( unit , depot ) ;
41528: LD_VAR 0 3
41532: PPUSH
41533: LD_VAR 0 10
41537: PPUSH
41538: CALL 50142 0 2
// end ; end ; end ;
41542: LD_VAR 0 5
41546: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41547: LD_INT 0
41549: PPUSH
41550: PPUSH
41551: PPUSH
41552: PPUSH
// if not mc_bases then
41553: LD_EXP 50
41557: NOT
41558: IFFALSE 41562
// exit ;
41560: GO 41801
// for i = 1 to mc_bases do
41562: LD_ADDR_VAR 0 2
41566: PUSH
41567: DOUBLE
41568: LD_INT 1
41570: DEC
41571: ST_TO_ADDR
41572: LD_EXP 50
41576: PUSH
41577: FOR_TO
41578: IFFALSE 41799
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41580: LD_ADDR_VAR 0 4
41584: PUSH
41585: LD_EXP 50
41589: PUSH
41590: LD_VAR 0 2
41594: ARRAY
41595: PPUSH
41596: LD_INT 21
41598: PUSH
41599: LD_INT 1
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PPUSH
41606: CALL_OW 72
41610: PUSH
41611: LD_EXP 79
41615: PUSH
41616: LD_VAR 0 2
41620: ARRAY
41621: UNION
41622: ST_TO_ADDR
// if not tmp then
41623: LD_VAR 0 4
41627: NOT
41628: IFFALSE 41632
// continue ;
41630: GO 41577
// for j in tmp do
41632: LD_ADDR_VAR 0 3
41636: PUSH
41637: LD_VAR 0 4
41641: PUSH
41642: FOR_IN
41643: IFFALSE 41795
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41645: LD_VAR 0 3
41649: PPUSH
41650: CALL_OW 110
41654: NOT
41655: PUSH
41656: LD_VAR 0 3
41660: PPUSH
41661: CALL_OW 314
41665: NOT
41666: AND
41667: PUSH
41668: LD_VAR 0 3
41672: PPUSH
41673: CALL_OW 311
41677: NOT
41678: AND
41679: PUSH
41680: LD_VAR 0 3
41684: PPUSH
41685: CALL_OW 310
41689: NOT
41690: AND
41691: PUSH
41692: LD_VAR 0 3
41696: PUSH
41697: LD_EXP 53
41701: PUSH
41702: LD_VAR 0 2
41706: ARRAY
41707: PUSH
41708: LD_INT 1
41710: ARRAY
41711: IN
41712: NOT
41713: AND
41714: PUSH
41715: LD_VAR 0 3
41719: PUSH
41720: LD_EXP 53
41724: PUSH
41725: LD_VAR 0 2
41729: ARRAY
41730: PUSH
41731: LD_INT 2
41733: ARRAY
41734: IN
41735: NOT
41736: AND
41737: PUSH
41738: LD_VAR 0 3
41742: PUSH
41743: LD_EXP 62
41747: PUSH
41748: LD_VAR 0 2
41752: ARRAY
41753: IN
41754: NOT
41755: AND
41756: IFFALSE 41793
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41758: LD_VAR 0 2
41762: PPUSH
41763: LD_EXP 50
41767: PUSH
41768: LD_VAR 0 2
41772: ARRAY
41773: PPUSH
41774: LD_VAR 0 3
41778: PPUSH
41779: LD_VAR 0 3
41783: PPUSH
41784: CALL_OW 257
41788: PPUSH
41789: CALL 40565 0 4
// end ;
41793: GO 41642
41795: POP
41796: POP
// end ;
41797: GO 41577
41799: POP
41800: POP
// end ;
41801: LD_VAR 0 1
41805: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41806: LD_INT 0
41808: PPUSH
41809: PPUSH
41810: PPUSH
41811: PPUSH
41812: PPUSH
41813: PPUSH
// if not mc_bases [ base ] then
41814: LD_EXP 50
41818: PUSH
41819: LD_VAR 0 1
41823: ARRAY
41824: NOT
41825: IFFALSE 41829
// exit ;
41827: GO 42011
// tmp := [ ] ;
41829: LD_ADDR_VAR 0 6
41833: PUSH
41834: EMPTY
41835: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41836: LD_ADDR_VAR 0 7
41840: PUSH
41841: LD_VAR 0 3
41845: PPUSH
41846: LD_INT 0
41848: PPUSH
41849: CALL_OW 517
41853: ST_TO_ADDR
// if not list then
41854: LD_VAR 0 7
41858: NOT
41859: IFFALSE 41863
// exit ;
41861: GO 42011
// for i = 1 to amount do
41863: LD_ADDR_VAR 0 5
41867: PUSH
41868: DOUBLE
41869: LD_INT 1
41871: DEC
41872: ST_TO_ADDR
41873: LD_VAR 0 2
41877: PUSH
41878: FOR_TO
41879: IFFALSE 41959
// begin x := rand ( 1 , list [ 1 ] ) ;
41881: LD_ADDR_VAR 0 8
41885: PUSH
41886: LD_INT 1
41888: PPUSH
41889: LD_VAR 0 7
41893: PUSH
41894: LD_INT 1
41896: ARRAY
41897: PPUSH
41898: CALL_OW 12
41902: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41903: LD_ADDR_VAR 0 6
41907: PUSH
41908: LD_VAR 0 6
41912: PPUSH
41913: LD_VAR 0 5
41917: PPUSH
41918: LD_VAR 0 7
41922: PUSH
41923: LD_INT 1
41925: ARRAY
41926: PUSH
41927: LD_VAR 0 8
41931: ARRAY
41932: PUSH
41933: LD_VAR 0 7
41937: PUSH
41938: LD_INT 2
41940: ARRAY
41941: PUSH
41942: LD_VAR 0 8
41946: ARRAY
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: PPUSH
41952: CALL_OW 1
41956: ST_TO_ADDR
// end ;
41957: GO 41878
41959: POP
41960: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
41961: LD_ADDR_EXP 63
41965: PUSH
41966: LD_EXP 63
41970: PPUSH
41971: LD_VAR 0 1
41975: PPUSH
41976: LD_VAR 0 6
41980: PPUSH
41981: CALL_OW 1
41985: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
41986: LD_ADDR_EXP 65
41990: PUSH
41991: LD_EXP 65
41995: PPUSH
41996: LD_VAR 0 1
42000: PPUSH
42001: LD_VAR 0 3
42005: PPUSH
42006: CALL_OW 1
42010: ST_TO_ADDR
// end ;
42011: LD_VAR 0 4
42015: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42016: LD_INT 0
42018: PPUSH
// if not mc_bases [ base ] then
42019: LD_EXP 50
42023: PUSH
42024: LD_VAR 0 1
42028: ARRAY
42029: NOT
42030: IFFALSE 42034
// exit ;
42032: GO 42059
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42034: LD_ADDR_EXP 55
42038: PUSH
42039: LD_EXP 55
42043: PPUSH
42044: LD_VAR 0 1
42048: PPUSH
42049: LD_VAR 0 2
42053: PPUSH
42054: CALL_OW 1
42058: ST_TO_ADDR
// end ;
42059: LD_VAR 0 3
42063: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42064: LD_INT 0
42066: PPUSH
// if not mc_bases [ base ] then
42067: LD_EXP 50
42071: PUSH
42072: LD_VAR 0 1
42076: ARRAY
42077: NOT
42078: IFFALSE 42082
// exit ;
42080: GO 42119
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42082: LD_ADDR_EXP 55
42086: PUSH
42087: LD_EXP 55
42091: PPUSH
42092: LD_VAR 0 1
42096: PPUSH
42097: LD_EXP 55
42101: PUSH
42102: LD_VAR 0 1
42106: ARRAY
42107: PUSH
42108: LD_VAR 0 2
42112: UNION
42113: PPUSH
42114: CALL_OW 1
42118: ST_TO_ADDR
// end ;
42119: LD_VAR 0 3
42123: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42124: LD_INT 0
42126: PPUSH
// if not mc_bases [ base ] then
42127: LD_EXP 50
42131: PUSH
42132: LD_VAR 0 1
42136: ARRAY
42137: NOT
42138: IFFALSE 42142
// exit ;
42140: GO 42167
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42142: LD_ADDR_EXP 71
42146: PUSH
42147: LD_EXP 71
42151: PPUSH
42152: LD_VAR 0 1
42156: PPUSH
42157: LD_VAR 0 2
42161: PPUSH
42162: CALL_OW 1
42166: ST_TO_ADDR
// end ;
42167: LD_VAR 0 3
42171: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42172: LD_INT 0
42174: PPUSH
// if not mc_bases [ base ] then
42175: LD_EXP 50
42179: PUSH
42180: LD_VAR 0 1
42184: ARRAY
42185: NOT
42186: IFFALSE 42190
// exit ;
42188: GO 42227
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42190: LD_ADDR_EXP 71
42194: PUSH
42195: LD_EXP 71
42199: PPUSH
42200: LD_VAR 0 1
42204: PPUSH
42205: LD_EXP 71
42209: PUSH
42210: LD_VAR 0 1
42214: ARRAY
42215: PUSH
42216: LD_VAR 0 2
42220: ADD
42221: PPUSH
42222: CALL_OW 1
42226: ST_TO_ADDR
// end ;
42227: LD_VAR 0 3
42231: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42232: LD_INT 0
42234: PPUSH
// if not mc_bases [ base ] then
42235: LD_EXP 50
42239: PUSH
42240: LD_VAR 0 1
42244: ARRAY
42245: NOT
42246: IFFALSE 42250
// exit ;
42248: GO 42304
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42250: LD_ADDR_EXP 72
42254: PUSH
42255: LD_EXP 72
42259: PPUSH
42260: LD_VAR 0 1
42264: PPUSH
42265: LD_VAR 0 2
42269: PPUSH
42270: CALL_OW 1
42274: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42275: LD_ADDR_EXP 61
42279: PUSH
42280: LD_EXP 61
42284: PPUSH
42285: LD_VAR 0 1
42289: PPUSH
42290: LD_VAR 0 2
42294: PUSH
42295: LD_INT 0
42297: PLUS
42298: PPUSH
42299: CALL_OW 1
42303: ST_TO_ADDR
// end ;
42304: LD_VAR 0 3
42308: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42309: LD_INT 0
42311: PPUSH
// if not mc_bases [ base ] then
42312: LD_EXP 50
42316: PUSH
42317: LD_VAR 0 1
42321: ARRAY
42322: NOT
42323: IFFALSE 42327
// exit ;
42325: GO 42352
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42327: LD_ADDR_EXP 61
42331: PUSH
42332: LD_EXP 61
42336: PPUSH
42337: LD_VAR 0 1
42341: PPUSH
42342: LD_VAR 0 2
42346: PPUSH
42347: CALL_OW 1
42351: ST_TO_ADDR
// end ;
42352: LD_VAR 0 3
42356: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42357: LD_INT 0
42359: PPUSH
42360: PPUSH
42361: PPUSH
42362: PPUSH
// if not mc_bases [ base ] then
42363: LD_EXP 50
42367: PUSH
42368: LD_VAR 0 1
42372: ARRAY
42373: NOT
42374: IFFALSE 42378
// exit ;
42376: GO 42443
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42378: LD_ADDR_EXP 70
42382: PUSH
42383: LD_EXP 70
42387: PPUSH
42388: LD_VAR 0 1
42392: PUSH
42393: LD_EXP 70
42397: PUSH
42398: LD_VAR 0 1
42402: ARRAY
42403: PUSH
42404: LD_INT 1
42406: PLUS
42407: PUSH
42408: EMPTY
42409: LIST
42410: LIST
42411: PPUSH
42412: LD_VAR 0 1
42416: PUSH
42417: LD_VAR 0 2
42421: PUSH
42422: LD_VAR 0 3
42426: PUSH
42427: LD_VAR 0 4
42431: PUSH
42432: EMPTY
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: PPUSH
42438: CALL 53564 0 3
42442: ST_TO_ADDR
// end ;
42443: LD_VAR 0 5
42447: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42448: LD_INT 0
42450: PPUSH
// if not mc_bases [ base ] then
42451: LD_EXP 50
42455: PUSH
42456: LD_VAR 0 1
42460: ARRAY
42461: NOT
42462: IFFALSE 42466
// exit ;
42464: GO 42491
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42466: LD_ADDR_EXP 87
42470: PUSH
42471: LD_EXP 87
42475: PPUSH
42476: LD_VAR 0 1
42480: PPUSH
42481: LD_VAR 0 2
42485: PPUSH
42486: CALL_OW 1
42490: ST_TO_ADDR
// end ;
42491: LD_VAR 0 3
42495: RET
// export function MC_GetMinesField ( base ) ; begin
42496: LD_INT 0
42498: PPUSH
// result := mc_mines [ base ] ;
42499: LD_ADDR_VAR 0 2
42503: PUSH
42504: LD_EXP 63
42508: PUSH
42509: LD_VAR 0 1
42513: ARRAY
42514: ST_TO_ADDR
// end ;
42515: LD_VAR 0 2
42519: RET
// export function MC_GetProduceList ( base ) ; begin
42520: LD_INT 0
42522: PPUSH
// result := mc_produce [ base ] ;
42523: LD_ADDR_VAR 0 2
42527: PUSH
42528: LD_EXP 71
42532: PUSH
42533: LD_VAR 0 1
42537: ARRAY
42538: ST_TO_ADDR
// end ;
42539: LD_VAR 0 2
42543: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42544: LD_INT 0
42546: PPUSH
42547: PPUSH
// if not mc_bases then
42548: LD_EXP 50
42552: NOT
42553: IFFALSE 42557
// exit ;
42555: GO 42622
// if mc_bases [ base ] then
42557: LD_EXP 50
42561: PUSH
42562: LD_VAR 0 1
42566: ARRAY
42567: IFFALSE 42622
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42569: LD_ADDR_VAR 0 3
42573: PUSH
42574: LD_EXP 50
42578: PUSH
42579: LD_VAR 0 1
42583: ARRAY
42584: PPUSH
42585: LD_INT 30
42587: PUSH
42588: LD_VAR 0 2
42592: PUSH
42593: EMPTY
42594: LIST
42595: LIST
42596: PPUSH
42597: CALL_OW 72
42601: ST_TO_ADDR
// if result then
42602: LD_VAR 0 3
42606: IFFALSE 42622
// result := result [ 1 ] ;
42608: LD_ADDR_VAR 0 3
42612: PUSH
42613: LD_VAR 0 3
42617: PUSH
42618: LD_INT 1
42620: ARRAY
42621: ST_TO_ADDR
// end ; end ;
42622: LD_VAR 0 3
42626: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42627: LD_INT 0
42629: PPUSH
42630: PPUSH
// if not mc_bases then
42631: LD_EXP 50
42635: NOT
42636: IFFALSE 42640
// exit ;
42638: GO 42685
// if mc_bases [ base ] then
42640: LD_EXP 50
42644: PUSH
42645: LD_VAR 0 1
42649: ARRAY
42650: IFFALSE 42685
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42652: LD_ADDR_VAR 0 3
42656: PUSH
42657: LD_EXP 50
42661: PUSH
42662: LD_VAR 0 1
42666: ARRAY
42667: PPUSH
42668: LD_INT 30
42670: PUSH
42671: LD_VAR 0 2
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PPUSH
42680: CALL_OW 72
42684: ST_TO_ADDR
// end ;
42685: LD_VAR 0 3
42689: RET
// export function MC_SetTame ( base , area ) ; begin
42690: LD_INT 0
42692: PPUSH
// if not mc_bases or not base then
42693: LD_EXP 50
42697: NOT
42698: PUSH
42699: LD_VAR 0 1
42703: NOT
42704: OR
42705: IFFALSE 42709
// exit ;
42707: GO 42734
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42709: LD_ADDR_EXP 78
42713: PUSH
42714: LD_EXP 78
42718: PPUSH
42719: LD_VAR 0 1
42723: PPUSH
42724: LD_VAR 0 2
42728: PPUSH
42729: CALL_OW 1
42733: ST_TO_ADDR
// end ;
42734: LD_VAR 0 3
42738: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42739: LD_INT 0
42741: PPUSH
42742: PPUSH
// if not mc_bases or not base then
42743: LD_EXP 50
42747: NOT
42748: PUSH
42749: LD_VAR 0 1
42753: NOT
42754: OR
42755: IFFALSE 42759
// exit ;
42757: GO 42861
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42759: LD_ADDR_VAR 0 4
42763: PUSH
42764: LD_EXP 50
42768: PUSH
42769: LD_VAR 0 1
42773: ARRAY
42774: PPUSH
42775: LD_INT 30
42777: PUSH
42778: LD_VAR 0 2
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: PPUSH
42787: CALL_OW 72
42791: ST_TO_ADDR
// if not tmp then
42792: LD_VAR 0 4
42796: NOT
42797: IFFALSE 42801
// exit ;
42799: GO 42861
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42801: LD_ADDR_EXP 82
42805: PUSH
42806: LD_EXP 82
42810: PPUSH
42811: LD_VAR 0 1
42815: PPUSH
42816: LD_EXP 82
42820: PUSH
42821: LD_VAR 0 1
42825: ARRAY
42826: PPUSH
42827: LD_EXP 82
42831: PUSH
42832: LD_VAR 0 1
42836: ARRAY
42837: PUSH
42838: LD_INT 1
42840: PLUS
42841: PPUSH
42842: LD_VAR 0 4
42846: PUSH
42847: LD_INT 1
42849: ARRAY
42850: PPUSH
42851: CALL_OW 2
42855: PPUSH
42856: CALL_OW 1
42860: ST_TO_ADDR
// end ;
42861: LD_VAR 0 3
42865: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42866: LD_INT 0
42868: PPUSH
42869: PPUSH
// if not mc_bases or not base or not kinds then
42870: LD_EXP 50
42874: NOT
42875: PUSH
42876: LD_VAR 0 1
42880: NOT
42881: OR
42882: PUSH
42883: LD_VAR 0 2
42887: NOT
42888: OR
42889: IFFALSE 42893
// exit ;
42891: GO 42954
// for i in kinds do
42893: LD_ADDR_VAR 0 4
42897: PUSH
42898: LD_VAR 0 2
42902: PUSH
42903: FOR_IN
42904: IFFALSE 42952
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42906: LD_ADDR_EXP 84
42910: PUSH
42911: LD_EXP 84
42915: PPUSH
42916: LD_VAR 0 1
42920: PUSH
42921: LD_EXP 84
42925: PUSH
42926: LD_VAR 0 1
42930: ARRAY
42931: PUSH
42932: LD_INT 1
42934: PLUS
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: PPUSH
42940: LD_VAR 0 4
42944: PPUSH
42945: CALL 53564 0 3
42949: ST_TO_ADDR
42950: GO 42903
42952: POP
42953: POP
// end ;
42954: LD_VAR 0 3
42958: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
42959: LD_INT 0
42961: PPUSH
// if not mc_bases or not base or not areas then
42962: LD_EXP 50
42966: NOT
42967: PUSH
42968: LD_VAR 0 1
42972: NOT
42973: OR
42974: PUSH
42975: LD_VAR 0 2
42979: NOT
42980: OR
42981: IFFALSE 42985
// exit ;
42983: GO 43010
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
42985: LD_ADDR_EXP 68
42989: PUSH
42990: LD_EXP 68
42994: PPUSH
42995: LD_VAR 0 1
42999: PPUSH
43000: LD_VAR 0 2
43004: PPUSH
43005: CALL_OW 1
43009: ST_TO_ADDR
// end ;
43010: LD_VAR 0 3
43014: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43015: LD_INT 0
43017: PPUSH
// if not mc_bases or not base or not teleports_exit then
43018: LD_EXP 50
43022: NOT
43023: PUSH
43024: LD_VAR 0 1
43028: NOT
43029: OR
43030: PUSH
43031: LD_VAR 0 2
43035: NOT
43036: OR
43037: IFFALSE 43041
// exit ;
43039: GO 43066
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43041: LD_ADDR_EXP 85
43045: PUSH
43046: LD_EXP 85
43050: PPUSH
43051: LD_VAR 0 1
43055: PPUSH
43056: LD_VAR 0 2
43060: PPUSH
43061: CALL_OW 1
43065: ST_TO_ADDR
// end ;
43066: LD_VAR 0 3
43070: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43071: LD_INT 0
43073: PPUSH
43074: PPUSH
43075: PPUSH
// if not mc_bases or not base or not ext_list then
43076: LD_EXP 50
43080: NOT
43081: PUSH
43082: LD_VAR 0 1
43086: NOT
43087: OR
43088: PUSH
43089: LD_VAR 0 5
43093: NOT
43094: OR
43095: IFFALSE 43099
// exit ;
43097: GO 43272
// tmp := GetFacExtXYD ( x , y , d ) ;
43099: LD_ADDR_VAR 0 8
43103: PUSH
43104: LD_VAR 0 2
43108: PPUSH
43109: LD_VAR 0 3
43113: PPUSH
43114: LD_VAR 0 4
43118: PPUSH
43119: CALL 82898 0 3
43123: ST_TO_ADDR
// if not tmp then
43124: LD_VAR 0 8
43128: NOT
43129: IFFALSE 43133
// exit ;
43131: GO 43272
// for i in tmp do
43133: LD_ADDR_VAR 0 7
43137: PUSH
43138: LD_VAR 0 8
43142: PUSH
43143: FOR_IN
43144: IFFALSE 43270
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43146: LD_ADDR_EXP 55
43150: PUSH
43151: LD_EXP 55
43155: PPUSH
43156: LD_VAR 0 1
43160: PPUSH
43161: LD_EXP 55
43165: PUSH
43166: LD_VAR 0 1
43170: ARRAY
43171: PPUSH
43172: LD_EXP 55
43176: PUSH
43177: LD_VAR 0 1
43181: ARRAY
43182: PUSH
43183: LD_INT 1
43185: PLUS
43186: PPUSH
43187: LD_VAR 0 5
43191: PUSH
43192: LD_INT 1
43194: ARRAY
43195: PUSH
43196: LD_VAR 0 7
43200: PUSH
43201: LD_INT 1
43203: ARRAY
43204: PUSH
43205: LD_VAR 0 7
43209: PUSH
43210: LD_INT 2
43212: ARRAY
43213: PUSH
43214: LD_VAR 0 7
43218: PUSH
43219: LD_INT 3
43221: ARRAY
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: LIST
43227: LIST
43228: PPUSH
43229: CALL_OW 2
43233: PPUSH
43234: CALL_OW 1
43238: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43239: LD_ADDR_VAR 0 5
43243: PUSH
43244: LD_VAR 0 5
43248: PPUSH
43249: LD_INT 1
43251: PPUSH
43252: CALL_OW 3
43256: ST_TO_ADDR
// if not ext_list then
43257: LD_VAR 0 5
43261: NOT
43262: IFFALSE 43268
// exit ;
43264: POP
43265: POP
43266: GO 43272
// end ;
43268: GO 43143
43270: POP
43271: POP
// end ;
43272: LD_VAR 0 6
43276: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43277: LD_INT 0
43279: PPUSH
// if not mc_bases or not base or not weapon_list then
43280: LD_EXP 50
43284: NOT
43285: PUSH
43286: LD_VAR 0 1
43290: NOT
43291: OR
43292: PUSH
43293: LD_VAR 0 2
43297: NOT
43298: OR
43299: IFFALSE 43303
// exit ;
43301: GO 43328
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43303: LD_ADDR_EXP 89
43307: PUSH
43308: LD_EXP 89
43312: PPUSH
43313: LD_VAR 0 1
43317: PPUSH
43318: LD_VAR 0 2
43322: PPUSH
43323: CALL_OW 1
43327: ST_TO_ADDR
// end ;
43328: LD_VAR 0 3
43332: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43333: LD_INT 0
43335: PPUSH
// if not mc_bases or not base or not tech_list then
43336: LD_EXP 50
43340: NOT
43341: PUSH
43342: LD_VAR 0 1
43346: NOT
43347: OR
43348: PUSH
43349: LD_VAR 0 2
43353: NOT
43354: OR
43355: IFFALSE 43359
// exit ;
43357: GO 43384
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43359: LD_ADDR_EXP 77
43363: PUSH
43364: LD_EXP 77
43368: PPUSH
43369: LD_VAR 0 1
43373: PPUSH
43374: LD_VAR 0 2
43378: PPUSH
43379: CALL_OW 1
43383: ST_TO_ADDR
// end ;
43384: LD_VAR 0 3
43388: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43389: LD_INT 0
43391: PPUSH
// if not mc_bases or not parking_area or not base then
43392: LD_EXP 50
43396: NOT
43397: PUSH
43398: LD_VAR 0 2
43402: NOT
43403: OR
43404: PUSH
43405: LD_VAR 0 1
43409: NOT
43410: OR
43411: IFFALSE 43415
// exit ;
43413: GO 43440
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43415: LD_ADDR_EXP 74
43419: PUSH
43420: LD_EXP 74
43424: PPUSH
43425: LD_VAR 0 1
43429: PPUSH
43430: LD_VAR 0 2
43434: PPUSH
43435: CALL_OW 1
43439: ST_TO_ADDR
// end ;
43440: LD_VAR 0 3
43444: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43445: LD_INT 0
43447: PPUSH
// if not mc_bases or not base or not scan_area then
43448: LD_EXP 50
43452: NOT
43453: PUSH
43454: LD_VAR 0 1
43458: NOT
43459: OR
43460: PUSH
43461: LD_VAR 0 2
43465: NOT
43466: OR
43467: IFFALSE 43471
// exit ;
43469: GO 43496
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43471: LD_ADDR_EXP 75
43475: PUSH
43476: LD_EXP 75
43480: PPUSH
43481: LD_VAR 0 1
43485: PPUSH
43486: LD_VAR 0 2
43490: PPUSH
43491: CALL_OW 1
43495: ST_TO_ADDR
// end ;
43496: LD_VAR 0 3
43500: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43501: LD_INT 0
43503: PPUSH
43504: PPUSH
// if not mc_bases or not base then
43505: LD_EXP 50
43509: NOT
43510: PUSH
43511: LD_VAR 0 1
43515: NOT
43516: OR
43517: IFFALSE 43521
// exit ;
43519: GO 43585
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43521: LD_ADDR_VAR 0 3
43525: PUSH
43526: LD_INT 1
43528: PUSH
43529: LD_INT 2
43531: PUSH
43532: LD_INT 3
43534: PUSH
43535: LD_INT 4
43537: PUSH
43538: LD_INT 11
43540: PUSH
43541: EMPTY
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43548: LD_ADDR_EXP 77
43552: PUSH
43553: LD_EXP 77
43557: PPUSH
43558: LD_VAR 0 1
43562: PPUSH
43563: LD_EXP 77
43567: PUSH
43568: LD_VAR 0 1
43572: ARRAY
43573: PUSH
43574: LD_VAR 0 3
43578: DIFF
43579: PPUSH
43580: CALL_OW 1
43584: ST_TO_ADDR
// end ;
43585: LD_VAR 0 2
43589: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43590: LD_INT 0
43592: PPUSH
// result := mc_vehicles [ base ] ;
43593: LD_ADDR_VAR 0 3
43597: PUSH
43598: LD_EXP 69
43602: PUSH
43603: LD_VAR 0 1
43607: ARRAY
43608: ST_TO_ADDR
// if onlyCombat then
43609: LD_VAR 0 2
43613: IFFALSE 43791
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43615: LD_ADDR_VAR 0 3
43619: PUSH
43620: LD_VAR 0 3
43624: PUSH
43625: LD_VAR 0 3
43629: PPUSH
43630: LD_INT 2
43632: PUSH
43633: LD_INT 34
43635: PUSH
43636: LD_INT 12
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: LD_INT 34
43645: PUSH
43646: LD_INT 51
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 34
43655: PUSH
43656: LD_EXP 95
43660: PUSH
43661: EMPTY
43662: LIST
43663: LIST
43664: PUSH
43665: LD_INT 34
43667: PUSH
43668: LD_INT 32
43670: PUSH
43671: EMPTY
43672: LIST
43673: LIST
43674: PUSH
43675: LD_INT 34
43677: PUSH
43678: LD_INT 13
43680: PUSH
43681: EMPTY
43682: LIST
43683: LIST
43684: PUSH
43685: LD_INT 34
43687: PUSH
43688: LD_INT 52
43690: PUSH
43691: EMPTY
43692: LIST
43693: LIST
43694: PUSH
43695: LD_INT 34
43697: PUSH
43698: LD_EXP 100
43702: PUSH
43703: EMPTY
43704: LIST
43705: LIST
43706: PUSH
43707: LD_INT 34
43709: PUSH
43710: LD_INT 14
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: PUSH
43717: LD_INT 34
43719: PUSH
43720: LD_INT 53
43722: PUSH
43723: EMPTY
43724: LIST
43725: LIST
43726: PUSH
43727: LD_INT 34
43729: PUSH
43730: LD_EXP 94
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: LD_INT 34
43741: PUSH
43742: LD_INT 31
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 34
43751: PUSH
43752: LD_INT 48
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: PUSH
43759: LD_INT 34
43761: PUSH
43762: LD_INT 8
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: EMPTY
43770: LIST
43771: LIST
43772: LIST
43773: LIST
43774: LIST
43775: LIST
43776: LIST
43777: LIST
43778: LIST
43779: LIST
43780: LIST
43781: LIST
43782: LIST
43783: LIST
43784: PPUSH
43785: CALL_OW 72
43789: DIFF
43790: ST_TO_ADDR
// end ; end_of_file
43791: LD_VAR 0 3
43795: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43796: LD_INT 0
43798: PPUSH
43799: PPUSH
43800: PPUSH
// if not mc_bases or not skirmish then
43801: LD_EXP 50
43805: NOT
43806: PUSH
43807: LD_EXP 48
43811: NOT
43812: OR
43813: IFFALSE 43817
// exit ;
43815: GO 43982
// for i = 1 to mc_bases do
43817: LD_ADDR_VAR 0 4
43821: PUSH
43822: DOUBLE
43823: LD_INT 1
43825: DEC
43826: ST_TO_ADDR
43827: LD_EXP 50
43831: PUSH
43832: FOR_TO
43833: IFFALSE 43980
// begin if sci in mc_bases [ i ] then
43835: LD_VAR 0 2
43839: PUSH
43840: LD_EXP 50
43844: PUSH
43845: LD_VAR 0 4
43849: ARRAY
43850: IN
43851: IFFALSE 43978
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43853: LD_ADDR_EXP 79
43857: PUSH
43858: LD_EXP 79
43862: PPUSH
43863: LD_VAR 0 4
43867: PUSH
43868: LD_EXP 79
43872: PUSH
43873: LD_VAR 0 4
43877: ARRAY
43878: PUSH
43879: LD_INT 1
43881: PLUS
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PPUSH
43887: LD_VAR 0 1
43891: PPUSH
43892: CALL 53564 0 3
43896: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43897: LD_ADDR_VAR 0 5
43901: PUSH
43902: LD_EXP 50
43906: PUSH
43907: LD_VAR 0 4
43911: ARRAY
43912: PPUSH
43913: LD_INT 2
43915: PUSH
43916: LD_INT 30
43918: PUSH
43919: LD_INT 0
43921: PUSH
43922: EMPTY
43923: LIST
43924: LIST
43925: PUSH
43926: LD_INT 30
43928: PUSH
43929: LD_INT 1
43931: PUSH
43932: EMPTY
43933: LIST
43934: LIST
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: LIST
43940: PPUSH
43941: CALL_OW 72
43945: PPUSH
43946: LD_VAR 0 1
43950: PPUSH
43951: CALL_OW 74
43955: ST_TO_ADDR
// if tmp then
43956: LD_VAR 0 5
43960: IFFALSE 43976
// ComStandNearbyBuilding ( ape , tmp ) ;
43962: LD_VAR 0 1
43966: PPUSH
43967: LD_VAR 0 5
43971: PPUSH
43972: CALL 50142 0 2
// break ;
43976: GO 43980
// end ; end ;
43978: GO 43832
43980: POP
43981: POP
// end ;
43982: LD_VAR 0 3
43986: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
43987: LD_INT 0
43989: PPUSH
43990: PPUSH
43991: PPUSH
// if not mc_bases or not skirmish then
43992: LD_EXP 50
43996: NOT
43997: PUSH
43998: LD_EXP 48
44002: NOT
44003: OR
44004: IFFALSE 44008
// exit ;
44006: GO 44097
// for i = 1 to mc_bases do
44008: LD_ADDR_VAR 0 4
44012: PUSH
44013: DOUBLE
44014: LD_INT 1
44016: DEC
44017: ST_TO_ADDR
44018: LD_EXP 50
44022: PUSH
44023: FOR_TO
44024: IFFALSE 44095
// begin if building in mc_busy_turret_list [ i ] then
44026: LD_VAR 0 1
44030: PUSH
44031: LD_EXP 60
44035: PUSH
44036: LD_VAR 0 4
44040: ARRAY
44041: IN
44042: IFFALSE 44093
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44044: LD_ADDR_VAR 0 5
44048: PUSH
44049: LD_EXP 60
44053: PUSH
44054: LD_VAR 0 4
44058: ARRAY
44059: PUSH
44060: LD_VAR 0 1
44064: DIFF
44065: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44066: LD_ADDR_EXP 60
44070: PUSH
44071: LD_EXP 60
44075: PPUSH
44076: LD_VAR 0 4
44080: PPUSH
44081: LD_VAR 0 5
44085: PPUSH
44086: CALL_OW 1
44090: ST_TO_ADDR
// break ;
44091: GO 44095
// end ; end ;
44093: GO 44023
44095: POP
44096: POP
// end ;
44097: LD_VAR 0 3
44101: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44102: LD_INT 0
44104: PPUSH
44105: PPUSH
44106: PPUSH
// if not mc_bases or not skirmish then
44107: LD_EXP 50
44111: NOT
44112: PUSH
44113: LD_EXP 48
44117: NOT
44118: OR
44119: IFFALSE 44123
// exit ;
44121: GO 44322
// for i = 1 to mc_bases do
44123: LD_ADDR_VAR 0 5
44127: PUSH
44128: DOUBLE
44129: LD_INT 1
44131: DEC
44132: ST_TO_ADDR
44133: LD_EXP 50
44137: PUSH
44138: FOR_TO
44139: IFFALSE 44320
// if building in mc_bases [ i ] then
44141: LD_VAR 0 1
44145: PUSH
44146: LD_EXP 50
44150: PUSH
44151: LD_VAR 0 5
44155: ARRAY
44156: IN
44157: IFFALSE 44318
// begin tmp := mc_bases [ i ] diff building ;
44159: LD_ADDR_VAR 0 6
44163: PUSH
44164: LD_EXP 50
44168: PUSH
44169: LD_VAR 0 5
44173: ARRAY
44174: PUSH
44175: LD_VAR 0 1
44179: DIFF
44180: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44181: LD_ADDR_EXP 50
44185: PUSH
44186: LD_EXP 50
44190: PPUSH
44191: LD_VAR 0 5
44195: PPUSH
44196: LD_VAR 0 6
44200: PPUSH
44201: CALL_OW 1
44205: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44206: LD_VAR 0 1
44210: PUSH
44211: LD_EXP 58
44215: PUSH
44216: LD_VAR 0 5
44220: ARRAY
44221: IN
44222: IFFALSE 44261
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44224: LD_ADDR_EXP 58
44228: PUSH
44229: LD_EXP 58
44233: PPUSH
44234: LD_VAR 0 5
44238: PPUSH
44239: LD_EXP 58
44243: PUSH
44244: LD_VAR 0 5
44248: ARRAY
44249: PUSH
44250: LD_VAR 0 1
44254: DIFF
44255: PPUSH
44256: CALL_OW 1
44260: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44261: LD_VAR 0 1
44265: PUSH
44266: LD_EXP 59
44270: PUSH
44271: LD_VAR 0 5
44275: ARRAY
44276: IN
44277: IFFALSE 44316
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44279: LD_ADDR_EXP 59
44283: PUSH
44284: LD_EXP 59
44288: PPUSH
44289: LD_VAR 0 5
44293: PPUSH
44294: LD_EXP 59
44298: PUSH
44299: LD_VAR 0 5
44303: ARRAY
44304: PUSH
44305: LD_VAR 0 1
44309: DIFF
44310: PPUSH
44311: CALL_OW 1
44315: ST_TO_ADDR
// break ;
44316: GO 44320
// end ;
44318: GO 44138
44320: POP
44321: POP
// end ;
44322: LD_VAR 0 4
44326: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44327: LD_INT 0
44329: PPUSH
44330: PPUSH
44331: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44332: LD_EXP 50
44336: NOT
44337: PUSH
44338: LD_EXP 48
44342: NOT
44343: OR
44344: PUSH
44345: LD_VAR 0 3
44349: PUSH
44350: LD_EXP 76
44354: IN
44355: NOT
44356: OR
44357: IFFALSE 44361
// exit ;
44359: GO 44484
// for i = 1 to mc_vehicles do
44361: LD_ADDR_VAR 0 6
44365: PUSH
44366: DOUBLE
44367: LD_INT 1
44369: DEC
44370: ST_TO_ADDR
44371: LD_EXP 69
44375: PUSH
44376: FOR_TO
44377: IFFALSE 44482
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44379: LD_VAR 0 2
44383: PUSH
44384: LD_EXP 69
44388: PUSH
44389: LD_VAR 0 6
44393: ARRAY
44394: IN
44395: PUSH
44396: LD_VAR 0 1
44400: PUSH
44401: LD_EXP 69
44405: PUSH
44406: LD_VAR 0 6
44410: ARRAY
44411: IN
44412: OR
44413: IFFALSE 44480
// begin tmp := mc_vehicles [ i ] diff old ;
44415: LD_ADDR_VAR 0 7
44419: PUSH
44420: LD_EXP 69
44424: PUSH
44425: LD_VAR 0 6
44429: ARRAY
44430: PUSH
44431: LD_VAR 0 2
44435: DIFF
44436: ST_TO_ADDR
// tmp := tmp diff new ;
44437: LD_ADDR_VAR 0 7
44441: PUSH
44442: LD_VAR 0 7
44446: PUSH
44447: LD_VAR 0 1
44451: DIFF
44452: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44453: LD_ADDR_EXP 69
44457: PUSH
44458: LD_EXP 69
44462: PPUSH
44463: LD_VAR 0 6
44467: PPUSH
44468: LD_VAR 0 7
44472: PPUSH
44473: CALL_OW 1
44477: ST_TO_ADDR
// break ;
44478: GO 44482
// end ;
44480: GO 44376
44482: POP
44483: POP
// end ;
44484: LD_VAR 0 5
44488: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44489: LD_INT 0
44491: PPUSH
44492: PPUSH
44493: PPUSH
44494: PPUSH
// if not mc_bases or not skirmish then
44495: LD_EXP 50
44499: NOT
44500: PUSH
44501: LD_EXP 48
44505: NOT
44506: OR
44507: IFFALSE 44511
// exit ;
44509: GO 44903
// side := GetSide ( vehicle ) ;
44511: LD_ADDR_VAR 0 5
44515: PUSH
44516: LD_VAR 0 1
44520: PPUSH
44521: CALL_OW 255
44525: ST_TO_ADDR
// for i = 1 to mc_bases do
44526: LD_ADDR_VAR 0 4
44530: PUSH
44531: DOUBLE
44532: LD_INT 1
44534: DEC
44535: ST_TO_ADDR
44536: LD_EXP 50
44540: PUSH
44541: FOR_TO
44542: IFFALSE 44901
// begin if factory in mc_bases [ i ] then
44544: LD_VAR 0 2
44548: PUSH
44549: LD_EXP 50
44553: PUSH
44554: LD_VAR 0 4
44558: ARRAY
44559: IN
44560: IFFALSE 44899
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44562: LD_EXP 72
44566: PUSH
44567: LD_VAR 0 4
44571: ARRAY
44572: PUSH
44573: LD_EXP 61
44577: PUSH
44578: LD_VAR 0 4
44582: ARRAY
44583: LESS
44584: PUSH
44585: LD_VAR 0 1
44589: PPUSH
44590: CALL_OW 264
44594: PUSH
44595: LD_INT 31
44597: PUSH
44598: LD_INT 32
44600: PUSH
44601: LD_INT 51
44603: PUSH
44604: LD_EXP 95
44608: PUSH
44609: LD_INT 12
44611: PUSH
44612: LD_INT 30
44614: PUSH
44615: LD_EXP 94
44619: PUSH
44620: LD_INT 11
44622: PUSH
44623: LD_INT 53
44625: PUSH
44626: LD_INT 14
44628: PUSH
44629: LD_EXP 98
44633: PUSH
44634: LD_INT 29
44636: PUSH
44637: LD_EXP 96
44641: PUSH
44642: LD_INT 13
44644: PUSH
44645: LD_INT 52
44647: PUSH
44648: LD_EXP 100
44652: PUSH
44653: LD_INT 48
44655: PUSH
44656: LD_INT 8
44658: PUSH
44659: EMPTY
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: LIST
44669: LIST
44670: LIST
44671: LIST
44672: LIST
44673: LIST
44674: LIST
44675: LIST
44676: LIST
44677: LIST
44678: IN
44679: NOT
44680: AND
44681: IFFALSE 44729
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44683: LD_ADDR_EXP 72
44687: PUSH
44688: LD_EXP 72
44692: PPUSH
44693: LD_VAR 0 4
44697: PUSH
44698: LD_EXP 72
44702: PUSH
44703: LD_VAR 0 4
44707: ARRAY
44708: PUSH
44709: LD_INT 1
44711: PLUS
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PPUSH
44717: LD_VAR 0 1
44721: PPUSH
44722: CALL 53564 0 3
44726: ST_TO_ADDR
44727: GO 44773
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44729: LD_ADDR_EXP 69
44733: PUSH
44734: LD_EXP 69
44738: PPUSH
44739: LD_VAR 0 4
44743: PUSH
44744: LD_EXP 69
44748: PUSH
44749: LD_VAR 0 4
44753: ARRAY
44754: PUSH
44755: LD_INT 1
44757: PLUS
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PPUSH
44763: LD_VAR 0 1
44767: PPUSH
44768: CALL 53564 0 3
44772: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44773: LD_VAR 0 1
44777: PPUSH
44778: CALL_OW 263
44782: PUSH
44783: LD_INT 2
44785: EQUAL
44786: IFFALSE 44815
// begin repeat wait ( 0 0$3 ) ;
44788: LD_INT 105
44790: PPUSH
44791: CALL_OW 67
// Connect ( vehicle ) ;
44795: LD_VAR 0 1
44799: PPUSH
44800: CALL 56535 0 1
// until IsControledBy ( vehicle ) ;
44804: LD_VAR 0 1
44808: PPUSH
44809: CALL_OW 312
44813: IFFALSE 44788
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44815: LD_VAR 0 1
44819: PPUSH
44820: LD_EXP 74
44824: PUSH
44825: LD_VAR 0 4
44829: ARRAY
44830: PPUSH
44831: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44835: LD_VAR 0 1
44839: PPUSH
44840: CALL_OW 263
44844: PUSH
44845: LD_INT 1
44847: NONEQUAL
44848: IFFALSE 44852
// break ;
44850: GO 44901
// repeat wait ( 0 0$1 ) ;
44852: LD_INT 35
44854: PPUSH
44855: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44859: LD_VAR 0 1
44863: PPUSH
44864: LD_EXP 74
44868: PUSH
44869: LD_VAR 0 4
44873: ARRAY
44874: PPUSH
44875: CALL_OW 308
44879: IFFALSE 44852
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44881: LD_VAR 0 1
44885: PPUSH
44886: CALL_OW 311
44890: PPUSH
44891: CALL_OW 121
// exit ;
44895: POP
44896: POP
44897: GO 44903
// end ; end ;
44899: GO 44541
44901: POP
44902: POP
// end ;
44903: LD_VAR 0 3
44907: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44908: LD_INT 0
44910: PPUSH
44911: PPUSH
44912: PPUSH
44913: PPUSH
// if not mc_bases or not skirmish then
44914: LD_EXP 50
44918: NOT
44919: PUSH
44920: LD_EXP 48
44924: NOT
44925: OR
44926: IFFALSE 44930
// exit ;
44928: GO 45283
// repeat wait ( 0 0$1 ) ;
44930: LD_INT 35
44932: PPUSH
44933: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
44937: LD_VAR 0 2
44941: PPUSH
44942: LD_VAR 0 3
44946: PPUSH
44947: CALL_OW 284
44951: IFFALSE 44930
// if GetResourceTypeXY ( x , y ) = mat_artefact then
44953: LD_VAR 0 2
44957: PPUSH
44958: LD_VAR 0 3
44962: PPUSH
44963: CALL_OW 283
44967: PUSH
44968: LD_INT 4
44970: EQUAL
44971: IFFALSE 44975
// exit ;
44973: GO 45283
// for i = 1 to mc_bases do
44975: LD_ADDR_VAR 0 7
44979: PUSH
44980: DOUBLE
44981: LD_INT 1
44983: DEC
44984: ST_TO_ADDR
44985: LD_EXP 50
44989: PUSH
44990: FOR_TO
44991: IFFALSE 45281
// begin if mc_crates_area [ i ] then
44993: LD_EXP 68
44997: PUSH
44998: LD_VAR 0 7
45002: ARRAY
45003: IFFALSE 45114
// for j in mc_crates_area [ i ] do
45005: LD_ADDR_VAR 0 8
45009: PUSH
45010: LD_EXP 68
45014: PUSH
45015: LD_VAR 0 7
45019: ARRAY
45020: PUSH
45021: FOR_IN
45022: IFFALSE 45112
// if InArea ( x , y , j ) then
45024: LD_VAR 0 2
45028: PPUSH
45029: LD_VAR 0 3
45033: PPUSH
45034: LD_VAR 0 8
45038: PPUSH
45039: CALL_OW 309
45043: IFFALSE 45110
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45045: LD_ADDR_EXP 66
45049: PUSH
45050: LD_EXP 66
45054: PPUSH
45055: LD_VAR 0 7
45059: PUSH
45060: LD_EXP 66
45064: PUSH
45065: LD_VAR 0 7
45069: ARRAY
45070: PUSH
45071: LD_INT 1
45073: PLUS
45074: PUSH
45075: EMPTY
45076: LIST
45077: LIST
45078: PPUSH
45079: LD_VAR 0 4
45083: PUSH
45084: LD_VAR 0 2
45088: PUSH
45089: LD_VAR 0 3
45093: PUSH
45094: EMPTY
45095: LIST
45096: LIST
45097: LIST
45098: PPUSH
45099: CALL 53564 0 3
45103: ST_TO_ADDR
// exit ;
45104: POP
45105: POP
45106: POP
45107: POP
45108: GO 45283
// end ;
45110: GO 45021
45112: POP
45113: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45114: LD_ADDR_VAR 0 9
45118: PUSH
45119: LD_EXP 50
45123: PUSH
45124: LD_VAR 0 7
45128: ARRAY
45129: PPUSH
45130: LD_INT 2
45132: PUSH
45133: LD_INT 30
45135: PUSH
45136: LD_INT 0
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 30
45145: PUSH
45146: LD_INT 1
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: LIST
45157: PPUSH
45158: CALL_OW 72
45162: ST_TO_ADDR
// if not depot then
45163: LD_VAR 0 9
45167: NOT
45168: IFFALSE 45172
// continue ;
45170: GO 44990
// for j in depot do
45172: LD_ADDR_VAR 0 8
45176: PUSH
45177: LD_VAR 0 9
45181: PUSH
45182: FOR_IN
45183: IFFALSE 45277
// if GetDistUnitXY ( j , x , y ) < 30 then
45185: LD_VAR 0 8
45189: PPUSH
45190: LD_VAR 0 2
45194: PPUSH
45195: LD_VAR 0 3
45199: PPUSH
45200: CALL_OW 297
45204: PUSH
45205: LD_INT 30
45207: LESS
45208: IFFALSE 45275
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45210: LD_ADDR_EXP 66
45214: PUSH
45215: LD_EXP 66
45219: PPUSH
45220: LD_VAR 0 7
45224: PUSH
45225: LD_EXP 66
45229: PUSH
45230: LD_VAR 0 7
45234: ARRAY
45235: PUSH
45236: LD_INT 1
45238: PLUS
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: PPUSH
45244: LD_VAR 0 4
45248: PUSH
45249: LD_VAR 0 2
45253: PUSH
45254: LD_VAR 0 3
45258: PUSH
45259: EMPTY
45260: LIST
45261: LIST
45262: LIST
45263: PPUSH
45264: CALL 53564 0 3
45268: ST_TO_ADDR
// exit ;
45269: POP
45270: POP
45271: POP
45272: POP
45273: GO 45283
// end ;
45275: GO 45182
45277: POP
45278: POP
// end ;
45279: GO 44990
45281: POP
45282: POP
// end ;
45283: LD_VAR 0 6
45287: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45288: LD_INT 0
45290: PPUSH
45291: PPUSH
45292: PPUSH
45293: PPUSH
// if not mc_bases or not skirmish then
45294: LD_EXP 50
45298: NOT
45299: PUSH
45300: LD_EXP 48
45304: NOT
45305: OR
45306: IFFALSE 45310
// exit ;
45308: GO 45587
// side := GetSide ( lab ) ;
45310: LD_ADDR_VAR 0 4
45314: PUSH
45315: LD_VAR 0 2
45319: PPUSH
45320: CALL_OW 255
45324: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45325: LD_VAR 0 4
45329: PUSH
45330: LD_EXP 76
45334: IN
45335: NOT
45336: PUSH
45337: LD_EXP 77
45341: NOT
45342: OR
45343: PUSH
45344: LD_EXP 50
45348: NOT
45349: OR
45350: IFFALSE 45354
// exit ;
45352: GO 45587
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45354: LD_ADDR_EXP 77
45358: PUSH
45359: LD_EXP 77
45363: PPUSH
45364: LD_VAR 0 4
45368: PPUSH
45369: LD_EXP 77
45373: PUSH
45374: LD_VAR 0 4
45378: ARRAY
45379: PUSH
45380: LD_VAR 0 1
45384: DIFF
45385: PPUSH
45386: CALL_OW 1
45390: ST_TO_ADDR
// for i = 1 to mc_bases do
45391: LD_ADDR_VAR 0 5
45395: PUSH
45396: DOUBLE
45397: LD_INT 1
45399: DEC
45400: ST_TO_ADDR
45401: LD_EXP 50
45405: PUSH
45406: FOR_TO
45407: IFFALSE 45585
// begin if lab in mc_bases [ i ] then
45409: LD_VAR 0 2
45413: PUSH
45414: LD_EXP 50
45418: PUSH
45419: LD_VAR 0 5
45423: ARRAY
45424: IN
45425: IFFALSE 45583
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45427: LD_VAR 0 1
45431: PUSH
45432: LD_INT 11
45434: PUSH
45435: LD_INT 4
45437: PUSH
45438: LD_INT 3
45440: PUSH
45441: LD_INT 2
45443: PUSH
45444: EMPTY
45445: LIST
45446: LIST
45447: LIST
45448: LIST
45449: IN
45450: PUSH
45451: LD_EXP 80
45455: PUSH
45456: LD_VAR 0 5
45460: ARRAY
45461: AND
45462: IFFALSE 45583
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45464: LD_ADDR_VAR 0 6
45468: PUSH
45469: LD_EXP 80
45473: PUSH
45474: LD_VAR 0 5
45478: ARRAY
45479: PUSH
45480: LD_INT 1
45482: ARRAY
45483: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45484: LD_ADDR_EXP 80
45488: PUSH
45489: LD_EXP 80
45493: PPUSH
45494: LD_VAR 0 5
45498: PPUSH
45499: EMPTY
45500: PPUSH
45501: CALL_OW 1
45505: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45506: LD_VAR 0 6
45510: PPUSH
45511: LD_INT 0
45513: PPUSH
45514: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45518: LD_VAR 0 6
45522: PPUSH
45523: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45527: LD_ADDR_EXP 79
45531: PUSH
45532: LD_EXP 79
45536: PPUSH
45537: LD_VAR 0 5
45541: PPUSH
45542: LD_EXP 79
45546: PUSH
45547: LD_VAR 0 5
45551: ARRAY
45552: PPUSH
45553: LD_INT 1
45555: PPUSH
45556: LD_VAR 0 6
45560: PPUSH
45561: CALL_OW 2
45565: PPUSH
45566: CALL_OW 1
45570: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45571: LD_VAR 0 5
45575: PPUSH
45576: LD_INT 112
45578: PPUSH
45579: CALL 22106 0 2
// end ; end ; end ;
45583: GO 45406
45585: POP
45586: POP
// end ;
45587: LD_VAR 0 3
45591: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45592: LD_INT 0
45594: PPUSH
45595: PPUSH
45596: PPUSH
45597: PPUSH
45598: PPUSH
45599: PPUSH
45600: PPUSH
45601: PPUSH
// if not mc_bases or not skirmish then
45602: LD_EXP 50
45606: NOT
45607: PUSH
45608: LD_EXP 48
45612: NOT
45613: OR
45614: IFFALSE 45618
// exit ;
45616: GO 46989
// for i = 1 to mc_bases do
45618: LD_ADDR_VAR 0 3
45622: PUSH
45623: DOUBLE
45624: LD_INT 1
45626: DEC
45627: ST_TO_ADDR
45628: LD_EXP 50
45632: PUSH
45633: FOR_TO
45634: IFFALSE 46987
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45636: LD_VAR 0 1
45640: PUSH
45641: LD_EXP 50
45645: PUSH
45646: LD_VAR 0 3
45650: ARRAY
45651: IN
45652: PUSH
45653: LD_VAR 0 1
45657: PUSH
45658: LD_EXP 57
45662: PUSH
45663: LD_VAR 0 3
45667: ARRAY
45668: IN
45669: OR
45670: PUSH
45671: LD_VAR 0 1
45675: PUSH
45676: LD_EXP 72
45680: PUSH
45681: LD_VAR 0 3
45685: ARRAY
45686: IN
45687: OR
45688: PUSH
45689: LD_VAR 0 1
45693: PUSH
45694: LD_EXP 69
45698: PUSH
45699: LD_VAR 0 3
45703: ARRAY
45704: IN
45705: OR
45706: PUSH
45707: LD_VAR 0 1
45711: PUSH
45712: LD_EXP 79
45716: PUSH
45717: LD_VAR 0 3
45721: ARRAY
45722: IN
45723: OR
45724: PUSH
45725: LD_VAR 0 1
45729: PUSH
45730: LD_EXP 80
45734: PUSH
45735: LD_VAR 0 3
45739: ARRAY
45740: IN
45741: OR
45742: IFFALSE 46985
// begin if un in mc_ape [ i ] then
45744: LD_VAR 0 1
45748: PUSH
45749: LD_EXP 79
45753: PUSH
45754: LD_VAR 0 3
45758: ARRAY
45759: IN
45760: IFFALSE 45799
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45762: LD_ADDR_EXP 79
45766: PUSH
45767: LD_EXP 79
45771: PPUSH
45772: LD_VAR 0 3
45776: PPUSH
45777: LD_EXP 79
45781: PUSH
45782: LD_VAR 0 3
45786: ARRAY
45787: PUSH
45788: LD_VAR 0 1
45792: DIFF
45793: PPUSH
45794: CALL_OW 1
45798: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45799: LD_VAR 0 1
45803: PUSH
45804: LD_EXP 80
45808: PUSH
45809: LD_VAR 0 3
45813: ARRAY
45814: IN
45815: IFFALSE 45839
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45817: LD_ADDR_EXP 80
45821: PUSH
45822: LD_EXP 80
45826: PPUSH
45827: LD_VAR 0 3
45831: PPUSH
45832: EMPTY
45833: PPUSH
45834: CALL_OW 1
45838: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45839: LD_VAR 0 1
45843: PPUSH
45844: CALL_OW 247
45848: PUSH
45849: LD_INT 2
45851: EQUAL
45852: PUSH
45853: LD_VAR 0 1
45857: PPUSH
45858: CALL_OW 110
45862: PUSH
45863: LD_INT 20
45865: EQUAL
45866: PUSH
45867: LD_VAR 0 1
45871: PUSH
45872: LD_EXP 72
45876: PUSH
45877: LD_VAR 0 3
45881: ARRAY
45882: IN
45883: OR
45884: PUSH
45885: LD_VAR 0 1
45889: PPUSH
45890: CALL_OW 264
45894: PUSH
45895: LD_INT 12
45897: PUSH
45898: LD_INT 51
45900: PUSH
45901: LD_EXP 95
45905: PUSH
45906: LD_INT 32
45908: PUSH
45909: LD_INT 13
45911: PUSH
45912: LD_INT 52
45914: PUSH
45915: LD_INT 31
45917: PUSH
45918: EMPTY
45919: LIST
45920: LIST
45921: LIST
45922: LIST
45923: LIST
45924: LIST
45925: LIST
45926: IN
45927: OR
45928: AND
45929: IFFALSE 46237
// begin if un in mc_defender [ i ] then
45931: LD_VAR 0 1
45935: PUSH
45936: LD_EXP 72
45940: PUSH
45941: LD_VAR 0 3
45945: ARRAY
45946: IN
45947: IFFALSE 45986
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45949: LD_ADDR_EXP 72
45953: PUSH
45954: LD_EXP 72
45958: PPUSH
45959: LD_VAR 0 3
45963: PPUSH
45964: LD_EXP 72
45968: PUSH
45969: LD_VAR 0 3
45973: ARRAY
45974: PUSH
45975: LD_VAR 0 1
45979: DIFF
45980: PPUSH
45981: CALL_OW 1
45985: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
45986: LD_ADDR_VAR 0 8
45990: PUSH
45991: LD_VAR 0 3
45995: PPUSH
45996: LD_INT 3
45998: PPUSH
45999: CALL 42627 0 2
46003: ST_TO_ADDR
// if fac then
46004: LD_VAR 0 8
46008: IFFALSE 46237
// begin for j in fac do
46010: LD_ADDR_VAR 0 4
46014: PUSH
46015: LD_VAR 0 8
46019: PUSH
46020: FOR_IN
46021: IFFALSE 46235
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46023: LD_ADDR_VAR 0 9
46027: PUSH
46028: LD_VAR 0 8
46032: PPUSH
46033: LD_VAR 0 1
46037: PPUSH
46038: CALL_OW 265
46042: PPUSH
46043: LD_VAR 0 1
46047: PPUSH
46048: CALL_OW 262
46052: PPUSH
46053: LD_VAR 0 1
46057: PPUSH
46058: CALL_OW 263
46062: PPUSH
46063: LD_VAR 0 1
46067: PPUSH
46068: CALL_OW 264
46072: PPUSH
46073: CALL 51060 0 5
46077: ST_TO_ADDR
// if components then
46078: LD_VAR 0 9
46082: IFFALSE 46233
// begin if GetWeapon ( un ) = ar_control_tower then
46084: LD_VAR 0 1
46088: PPUSH
46089: CALL_OW 264
46093: PUSH
46094: LD_INT 31
46096: EQUAL
46097: IFFALSE 46214
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46099: LD_VAR 0 1
46103: PPUSH
46104: CALL_OW 311
46108: PPUSH
46109: LD_INT 0
46111: PPUSH
46112: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46116: LD_ADDR_EXP 90
46120: PUSH
46121: LD_EXP 90
46125: PPUSH
46126: LD_VAR 0 3
46130: PPUSH
46131: LD_EXP 90
46135: PUSH
46136: LD_VAR 0 3
46140: ARRAY
46141: PUSH
46142: LD_VAR 0 1
46146: PPUSH
46147: CALL_OW 311
46151: DIFF
46152: PPUSH
46153: CALL_OW 1
46157: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46158: LD_ADDR_VAR 0 7
46162: PUSH
46163: LD_EXP 71
46167: PUSH
46168: LD_VAR 0 3
46172: ARRAY
46173: PPUSH
46174: LD_INT 1
46176: PPUSH
46177: LD_VAR 0 9
46181: PPUSH
46182: CALL_OW 2
46186: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46187: LD_ADDR_EXP 71
46191: PUSH
46192: LD_EXP 71
46196: PPUSH
46197: LD_VAR 0 3
46201: PPUSH
46202: LD_VAR 0 7
46206: PPUSH
46207: CALL_OW 1
46211: ST_TO_ADDR
// end else
46212: GO 46231
// MC_InsertProduceList ( i , [ components ] ) ;
46214: LD_VAR 0 3
46218: PPUSH
46219: LD_VAR 0 9
46223: PUSH
46224: EMPTY
46225: LIST
46226: PPUSH
46227: CALL 42172 0 2
// break ;
46231: GO 46235
// end ; end ;
46233: GO 46020
46235: POP
46236: POP
// end ; end ; if GetType ( un ) = unit_building then
46237: LD_VAR 0 1
46241: PPUSH
46242: CALL_OW 247
46246: PUSH
46247: LD_INT 3
46249: EQUAL
46250: IFFALSE 46653
// begin btype := GetBType ( un ) ;
46252: LD_ADDR_VAR 0 5
46256: PUSH
46257: LD_VAR 0 1
46261: PPUSH
46262: CALL_OW 266
46266: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46267: LD_VAR 0 5
46271: PUSH
46272: LD_INT 29
46274: PUSH
46275: LD_INT 30
46277: PUSH
46278: EMPTY
46279: LIST
46280: LIST
46281: IN
46282: IFFALSE 46355
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46284: LD_VAR 0 1
46288: PPUSH
46289: CALL_OW 250
46293: PPUSH
46294: LD_VAR 0 1
46298: PPUSH
46299: CALL_OW 251
46303: PPUSH
46304: LD_VAR 0 1
46308: PPUSH
46309: CALL_OW 255
46313: PPUSH
46314: CALL_OW 440
46318: NOT
46319: IFFALSE 46355
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46321: LD_VAR 0 1
46325: PPUSH
46326: CALL_OW 250
46330: PPUSH
46331: LD_VAR 0 1
46335: PPUSH
46336: CALL_OW 251
46340: PPUSH
46341: LD_VAR 0 1
46345: PPUSH
46346: CALL_OW 255
46350: PPUSH
46351: CALL_OW 441
// end ; if btype = b_warehouse then
46355: LD_VAR 0 5
46359: PUSH
46360: LD_INT 1
46362: EQUAL
46363: IFFALSE 46381
// begin btype := b_depot ;
46365: LD_ADDR_VAR 0 5
46369: PUSH
46370: LD_INT 0
46372: ST_TO_ADDR
// pos := 1 ;
46373: LD_ADDR_VAR 0 6
46377: PUSH
46378: LD_INT 1
46380: ST_TO_ADDR
// end ; if btype = b_factory then
46381: LD_VAR 0 5
46385: PUSH
46386: LD_INT 3
46388: EQUAL
46389: IFFALSE 46407
// begin btype := b_workshop ;
46391: LD_ADDR_VAR 0 5
46395: PUSH
46396: LD_INT 2
46398: ST_TO_ADDR
// pos := 1 ;
46399: LD_ADDR_VAR 0 6
46403: PUSH
46404: LD_INT 1
46406: ST_TO_ADDR
// end ; if btype = b_barracks then
46407: LD_VAR 0 5
46411: PUSH
46412: LD_INT 5
46414: EQUAL
46415: IFFALSE 46425
// btype := b_armoury ;
46417: LD_ADDR_VAR 0 5
46421: PUSH
46422: LD_INT 4
46424: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46425: LD_VAR 0 5
46429: PUSH
46430: LD_INT 7
46432: PUSH
46433: LD_INT 8
46435: PUSH
46436: EMPTY
46437: LIST
46438: LIST
46439: IN
46440: IFFALSE 46450
// btype := b_lab ;
46442: LD_ADDR_VAR 0 5
46446: PUSH
46447: LD_INT 6
46449: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46450: LD_ADDR_EXP 55
46454: PUSH
46455: LD_EXP 55
46459: PPUSH
46460: LD_VAR 0 3
46464: PUSH
46465: LD_EXP 55
46469: PUSH
46470: LD_VAR 0 3
46474: ARRAY
46475: PUSH
46476: LD_INT 1
46478: PLUS
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: PPUSH
46484: LD_VAR 0 5
46488: PUSH
46489: LD_VAR 0 1
46493: PPUSH
46494: CALL_OW 250
46498: PUSH
46499: LD_VAR 0 1
46503: PPUSH
46504: CALL_OW 251
46508: PUSH
46509: LD_VAR 0 1
46513: PPUSH
46514: CALL_OW 254
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: LIST
46523: LIST
46524: PPUSH
46525: CALL 53564 0 3
46529: ST_TO_ADDR
// if pos = 1 then
46530: LD_VAR 0 6
46534: PUSH
46535: LD_INT 1
46537: EQUAL
46538: IFFALSE 46653
// begin tmp := mc_build_list [ i ] ;
46540: LD_ADDR_VAR 0 7
46544: PUSH
46545: LD_EXP 55
46549: PUSH
46550: LD_VAR 0 3
46554: ARRAY
46555: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46556: LD_VAR 0 7
46560: PPUSH
46561: LD_INT 2
46563: PUSH
46564: LD_INT 30
46566: PUSH
46567: LD_INT 0
46569: PUSH
46570: EMPTY
46571: LIST
46572: LIST
46573: PUSH
46574: LD_INT 30
46576: PUSH
46577: LD_INT 1
46579: PUSH
46580: EMPTY
46581: LIST
46582: LIST
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: LIST
46588: PPUSH
46589: CALL_OW 72
46593: IFFALSE 46603
// pos := 2 ;
46595: LD_ADDR_VAR 0 6
46599: PUSH
46600: LD_INT 2
46602: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46603: LD_ADDR_VAR 0 7
46607: PUSH
46608: LD_VAR 0 7
46612: PPUSH
46613: LD_VAR 0 6
46617: PPUSH
46618: LD_VAR 0 7
46622: PPUSH
46623: CALL 53890 0 3
46627: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46628: LD_ADDR_EXP 55
46632: PUSH
46633: LD_EXP 55
46637: PPUSH
46638: LD_VAR 0 3
46642: PPUSH
46643: LD_VAR 0 7
46647: PPUSH
46648: CALL_OW 1
46652: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46653: LD_VAR 0 1
46657: PUSH
46658: LD_EXP 50
46662: PUSH
46663: LD_VAR 0 3
46667: ARRAY
46668: IN
46669: IFFALSE 46708
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46671: LD_ADDR_EXP 50
46675: PUSH
46676: LD_EXP 50
46680: PPUSH
46681: LD_VAR 0 3
46685: PPUSH
46686: LD_EXP 50
46690: PUSH
46691: LD_VAR 0 3
46695: ARRAY
46696: PUSH
46697: LD_VAR 0 1
46701: DIFF
46702: PPUSH
46703: CALL_OW 1
46707: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46708: LD_VAR 0 1
46712: PUSH
46713: LD_EXP 57
46717: PUSH
46718: LD_VAR 0 3
46722: ARRAY
46723: IN
46724: IFFALSE 46763
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46726: LD_ADDR_EXP 57
46730: PUSH
46731: LD_EXP 57
46735: PPUSH
46736: LD_VAR 0 3
46740: PPUSH
46741: LD_EXP 57
46745: PUSH
46746: LD_VAR 0 3
46750: ARRAY
46751: PUSH
46752: LD_VAR 0 1
46756: DIFF
46757: PPUSH
46758: CALL_OW 1
46762: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46763: LD_VAR 0 1
46767: PUSH
46768: LD_EXP 69
46772: PUSH
46773: LD_VAR 0 3
46777: ARRAY
46778: IN
46779: IFFALSE 46818
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46781: LD_ADDR_EXP 69
46785: PUSH
46786: LD_EXP 69
46790: PPUSH
46791: LD_VAR 0 3
46795: PPUSH
46796: LD_EXP 69
46800: PUSH
46801: LD_VAR 0 3
46805: ARRAY
46806: PUSH
46807: LD_VAR 0 1
46811: DIFF
46812: PPUSH
46813: CALL_OW 1
46817: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46818: LD_VAR 0 1
46822: PUSH
46823: LD_EXP 72
46827: PUSH
46828: LD_VAR 0 3
46832: ARRAY
46833: IN
46834: IFFALSE 46873
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46836: LD_ADDR_EXP 72
46840: PUSH
46841: LD_EXP 72
46845: PPUSH
46846: LD_VAR 0 3
46850: PPUSH
46851: LD_EXP 72
46855: PUSH
46856: LD_VAR 0 3
46860: ARRAY
46861: PUSH
46862: LD_VAR 0 1
46866: DIFF
46867: PPUSH
46868: CALL_OW 1
46872: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46873: LD_VAR 0 1
46877: PUSH
46878: LD_EXP 59
46882: PUSH
46883: LD_VAR 0 3
46887: ARRAY
46888: IN
46889: IFFALSE 46928
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46891: LD_ADDR_EXP 59
46895: PUSH
46896: LD_EXP 59
46900: PPUSH
46901: LD_VAR 0 3
46905: PPUSH
46906: LD_EXP 59
46910: PUSH
46911: LD_VAR 0 3
46915: ARRAY
46916: PUSH
46917: LD_VAR 0 1
46921: DIFF
46922: PPUSH
46923: CALL_OW 1
46927: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46928: LD_VAR 0 1
46932: PUSH
46933: LD_EXP 58
46937: PUSH
46938: LD_VAR 0 3
46942: ARRAY
46943: IN
46944: IFFALSE 46983
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
46946: LD_ADDR_EXP 58
46950: PUSH
46951: LD_EXP 58
46955: PPUSH
46956: LD_VAR 0 3
46960: PPUSH
46961: LD_EXP 58
46965: PUSH
46966: LD_VAR 0 3
46970: ARRAY
46971: PUSH
46972: LD_VAR 0 1
46976: DIFF
46977: PPUSH
46978: CALL_OW 1
46982: ST_TO_ADDR
// end ; break ;
46983: GO 46987
// end ;
46985: GO 45633
46987: POP
46988: POP
// end ;
46989: LD_VAR 0 2
46993: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
46994: LD_INT 0
46996: PPUSH
46997: PPUSH
46998: PPUSH
// if not mc_bases or not skirmish then
46999: LD_EXP 50
47003: NOT
47004: PUSH
47005: LD_EXP 48
47009: NOT
47010: OR
47011: IFFALSE 47015
// exit ;
47013: GO 47230
// for i = 1 to mc_bases do
47015: LD_ADDR_VAR 0 3
47019: PUSH
47020: DOUBLE
47021: LD_INT 1
47023: DEC
47024: ST_TO_ADDR
47025: LD_EXP 50
47029: PUSH
47030: FOR_TO
47031: IFFALSE 47228
// begin if building in mc_construct_list [ i ] then
47033: LD_VAR 0 1
47037: PUSH
47038: LD_EXP 57
47042: PUSH
47043: LD_VAR 0 3
47047: ARRAY
47048: IN
47049: IFFALSE 47226
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47051: LD_ADDR_EXP 57
47055: PUSH
47056: LD_EXP 57
47060: PPUSH
47061: LD_VAR 0 3
47065: PPUSH
47066: LD_EXP 57
47070: PUSH
47071: LD_VAR 0 3
47075: ARRAY
47076: PUSH
47077: LD_VAR 0 1
47081: DIFF
47082: PPUSH
47083: CALL_OW 1
47087: ST_TO_ADDR
// if building in mc_lab [ i ] then
47088: LD_VAR 0 1
47092: PUSH
47093: LD_EXP 83
47097: PUSH
47098: LD_VAR 0 3
47102: ARRAY
47103: IN
47104: IFFALSE 47159
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47106: LD_ADDR_EXP 84
47110: PUSH
47111: LD_EXP 84
47115: PPUSH
47116: LD_VAR 0 3
47120: PPUSH
47121: LD_EXP 84
47125: PUSH
47126: LD_VAR 0 3
47130: ARRAY
47131: PPUSH
47132: LD_INT 1
47134: PPUSH
47135: LD_EXP 84
47139: PUSH
47140: LD_VAR 0 3
47144: ARRAY
47145: PPUSH
47146: LD_INT 0
47148: PPUSH
47149: CALL 52982 0 4
47153: PPUSH
47154: CALL_OW 1
47158: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47159: LD_VAR 0 1
47163: PUSH
47164: LD_EXP 50
47168: PUSH
47169: LD_VAR 0 3
47173: ARRAY
47174: IN
47175: NOT
47176: IFFALSE 47222
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47178: LD_ADDR_EXP 50
47182: PUSH
47183: LD_EXP 50
47187: PPUSH
47188: LD_VAR 0 3
47192: PUSH
47193: LD_EXP 50
47197: PUSH
47198: LD_VAR 0 3
47202: ARRAY
47203: PUSH
47204: LD_INT 1
47206: PLUS
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: PPUSH
47212: LD_VAR 0 1
47216: PPUSH
47217: CALL 53564 0 3
47221: ST_TO_ADDR
// exit ;
47222: POP
47223: POP
47224: GO 47230
// end ; end ;
47226: GO 47030
47228: POP
47229: POP
// end ;
47230: LD_VAR 0 2
47234: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47235: LD_INT 0
47237: PPUSH
47238: PPUSH
47239: PPUSH
47240: PPUSH
47241: PPUSH
47242: PPUSH
47243: PPUSH
// if not mc_bases or not skirmish then
47244: LD_EXP 50
47248: NOT
47249: PUSH
47250: LD_EXP 48
47254: NOT
47255: OR
47256: IFFALSE 47260
// exit ;
47258: GO 47921
// for i = 1 to mc_bases do
47260: LD_ADDR_VAR 0 3
47264: PUSH
47265: DOUBLE
47266: LD_INT 1
47268: DEC
47269: ST_TO_ADDR
47270: LD_EXP 50
47274: PUSH
47275: FOR_TO
47276: IFFALSE 47919
// begin if building in mc_construct_list [ i ] then
47278: LD_VAR 0 1
47282: PUSH
47283: LD_EXP 57
47287: PUSH
47288: LD_VAR 0 3
47292: ARRAY
47293: IN
47294: IFFALSE 47917
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47296: LD_ADDR_EXP 57
47300: PUSH
47301: LD_EXP 57
47305: PPUSH
47306: LD_VAR 0 3
47310: PPUSH
47311: LD_EXP 57
47315: PUSH
47316: LD_VAR 0 3
47320: ARRAY
47321: PUSH
47322: LD_VAR 0 1
47326: DIFF
47327: PPUSH
47328: CALL_OW 1
47332: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47333: LD_ADDR_EXP 50
47337: PUSH
47338: LD_EXP 50
47342: PPUSH
47343: LD_VAR 0 3
47347: PUSH
47348: LD_EXP 50
47352: PUSH
47353: LD_VAR 0 3
47357: ARRAY
47358: PUSH
47359: LD_INT 1
47361: PLUS
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PPUSH
47367: LD_VAR 0 1
47371: PPUSH
47372: CALL 53564 0 3
47376: ST_TO_ADDR
// btype := GetBType ( building ) ;
47377: LD_ADDR_VAR 0 5
47381: PUSH
47382: LD_VAR 0 1
47386: PPUSH
47387: CALL_OW 266
47391: ST_TO_ADDR
// side := GetSide ( building ) ;
47392: LD_ADDR_VAR 0 8
47396: PUSH
47397: LD_VAR 0 1
47401: PPUSH
47402: CALL_OW 255
47406: ST_TO_ADDR
// if btype = b_lab then
47407: LD_VAR 0 5
47411: PUSH
47412: LD_INT 6
47414: EQUAL
47415: IFFALSE 47465
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47417: LD_ADDR_EXP 83
47421: PUSH
47422: LD_EXP 83
47426: PPUSH
47427: LD_VAR 0 3
47431: PUSH
47432: LD_EXP 83
47436: PUSH
47437: LD_VAR 0 3
47441: ARRAY
47442: PUSH
47443: LD_INT 1
47445: PLUS
47446: PUSH
47447: EMPTY
47448: LIST
47449: LIST
47450: PPUSH
47451: LD_VAR 0 1
47455: PPUSH
47456: CALL 53564 0 3
47460: ST_TO_ADDR
// exit ;
47461: POP
47462: POP
47463: GO 47921
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47465: LD_VAR 0 5
47469: PUSH
47470: LD_INT 0
47472: PUSH
47473: LD_INT 2
47475: PUSH
47476: LD_INT 4
47478: PUSH
47479: EMPTY
47480: LIST
47481: LIST
47482: LIST
47483: IN
47484: IFFALSE 47608
// begin if btype = b_armoury then
47486: LD_VAR 0 5
47490: PUSH
47491: LD_INT 4
47493: EQUAL
47494: IFFALSE 47504
// btype := b_barracks ;
47496: LD_ADDR_VAR 0 5
47500: PUSH
47501: LD_INT 5
47503: ST_TO_ADDR
// if btype = b_depot then
47504: LD_VAR 0 5
47508: PUSH
47509: LD_INT 0
47511: EQUAL
47512: IFFALSE 47522
// btype := b_warehouse ;
47514: LD_ADDR_VAR 0 5
47518: PUSH
47519: LD_INT 1
47521: ST_TO_ADDR
// if btype = b_workshop then
47522: LD_VAR 0 5
47526: PUSH
47527: LD_INT 2
47529: EQUAL
47530: IFFALSE 47540
// btype := b_factory ;
47532: LD_ADDR_VAR 0 5
47536: PUSH
47537: LD_INT 3
47539: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47540: LD_VAR 0 5
47544: PPUSH
47545: LD_VAR 0 8
47549: PPUSH
47550: CALL_OW 323
47554: PUSH
47555: LD_INT 1
47557: EQUAL
47558: IFFALSE 47604
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47560: LD_ADDR_EXP 82
47564: PUSH
47565: LD_EXP 82
47569: PPUSH
47570: LD_VAR 0 3
47574: PUSH
47575: LD_EXP 82
47579: PUSH
47580: LD_VAR 0 3
47584: ARRAY
47585: PUSH
47586: LD_INT 1
47588: PLUS
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: PPUSH
47594: LD_VAR 0 1
47598: PPUSH
47599: CALL 53564 0 3
47603: ST_TO_ADDR
// exit ;
47604: POP
47605: POP
47606: GO 47921
// end ; if btype in [ b_bunker , b_turret ] then
47608: LD_VAR 0 5
47612: PUSH
47613: LD_INT 32
47615: PUSH
47616: LD_INT 33
47618: PUSH
47619: EMPTY
47620: LIST
47621: LIST
47622: IN
47623: IFFALSE 47913
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47625: LD_ADDR_EXP 58
47629: PUSH
47630: LD_EXP 58
47634: PPUSH
47635: LD_VAR 0 3
47639: PUSH
47640: LD_EXP 58
47644: PUSH
47645: LD_VAR 0 3
47649: ARRAY
47650: PUSH
47651: LD_INT 1
47653: PLUS
47654: PUSH
47655: EMPTY
47656: LIST
47657: LIST
47658: PPUSH
47659: LD_VAR 0 1
47663: PPUSH
47664: CALL 53564 0 3
47668: ST_TO_ADDR
// if btype = b_bunker then
47669: LD_VAR 0 5
47673: PUSH
47674: LD_INT 32
47676: EQUAL
47677: IFFALSE 47913
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47679: LD_ADDR_EXP 59
47683: PUSH
47684: LD_EXP 59
47688: PPUSH
47689: LD_VAR 0 3
47693: PUSH
47694: LD_EXP 59
47698: PUSH
47699: LD_VAR 0 3
47703: ARRAY
47704: PUSH
47705: LD_INT 1
47707: PLUS
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PPUSH
47713: LD_VAR 0 1
47717: PPUSH
47718: CALL 53564 0 3
47722: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47723: LD_ADDR_VAR 0 6
47727: PUSH
47728: LD_EXP 50
47732: PUSH
47733: LD_VAR 0 3
47737: ARRAY
47738: PPUSH
47739: LD_INT 25
47741: PUSH
47742: LD_INT 1
47744: PUSH
47745: EMPTY
47746: LIST
47747: LIST
47748: PUSH
47749: LD_INT 3
47751: PUSH
47752: LD_INT 54
47754: PUSH
47755: EMPTY
47756: LIST
47757: PUSH
47758: EMPTY
47759: LIST
47760: LIST
47761: PUSH
47762: EMPTY
47763: LIST
47764: LIST
47765: PPUSH
47766: CALL_OW 72
47770: ST_TO_ADDR
// if tmp then
47771: LD_VAR 0 6
47775: IFFALSE 47781
// exit ;
47777: POP
47778: POP
47779: GO 47921
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47781: LD_ADDR_VAR 0 6
47785: PUSH
47786: LD_EXP 50
47790: PUSH
47791: LD_VAR 0 3
47795: ARRAY
47796: PPUSH
47797: LD_INT 2
47799: PUSH
47800: LD_INT 30
47802: PUSH
47803: LD_INT 4
47805: PUSH
47806: EMPTY
47807: LIST
47808: LIST
47809: PUSH
47810: LD_INT 30
47812: PUSH
47813: LD_INT 5
47815: PUSH
47816: EMPTY
47817: LIST
47818: LIST
47819: PUSH
47820: EMPTY
47821: LIST
47822: LIST
47823: LIST
47824: PPUSH
47825: CALL_OW 72
47829: ST_TO_ADDR
// if not tmp then
47830: LD_VAR 0 6
47834: NOT
47835: IFFALSE 47841
// exit ;
47837: POP
47838: POP
47839: GO 47921
// for j in tmp do
47841: LD_ADDR_VAR 0 4
47845: PUSH
47846: LD_VAR 0 6
47850: PUSH
47851: FOR_IN
47852: IFFALSE 47911
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47854: LD_ADDR_VAR 0 7
47858: PUSH
47859: LD_VAR 0 4
47863: PPUSH
47864: CALL_OW 313
47868: PPUSH
47869: LD_INT 25
47871: PUSH
47872: LD_INT 1
47874: PUSH
47875: EMPTY
47876: LIST
47877: LIST
47878: PPUSH
47879: CALL_OW 72
47883: ST_TO_ADDR
// if units then
47884: LD_VAR 0 7
47888: IFFALSE 47909
// begin ComExitBuilding ( units [ 1 ] ) ;
47890: LD_VAR 0 7
47894: PUSH
47895: LD_INT 1
47897: ARRAY
47898: PPUSH
47899: CALL_OW 122
// exit ;
47903: POP
47904: POP
47905: POP
47906: POP
47907: GO 47921
// end ; end ;
47909: GO 47851
47911: POP
47912: POP
// end ; end ; exit ;
47913: POP
47914: POP
47915: GO 47921
// end ; end ;
47917: GO 47275
47919: POP
47920: POP
// end ;
47921: LD_VAR 0 2
47925: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47926: LD_INT 0
47928: PPUSH
47929: PPUSH
47930: PPUSH
47931: PPUSH
47932: PPUSH
47933: PPUSH
47934: PPUSH
// if not mc_bases or not skirmish then
47935: LD_EXP 50
47939: NOT
47940: PUSH
47941: LD_EXP 48
47945: NOT
47946: OR
47947: IFFALSE 47951
// exit ;
47949: GO 48216
// btype := GetBType ( building ) ;
47951: LD_ADDR_VAR 0 6
47955: PUSH
47956: LD_VAR 0 1
47960: PPUSH
47961: CALL_OW 266
47965: ST_TO_ADDR
// x := GetX ( building ) ;
47966: LD_ADDR_VAR 0 7
47970: PUSH
47971: LD_VAR 0 1
47975: PPUSH
47976: CALL_OW 250
47980: ST_TO_ADDR
// y := GetY ( building ) ;
47981: LD_ADDR_VAR 0 8
47985: PUSH
47986: LD_VAR 0 1
47990: PPUSH
47991: CALL_OW 251
47995: ST_TO_ADDR
// d := GetDir ( building ) ;
47996: LD_ADDR_VAR 0 9
48000: PUSH
48001: LD_VAR 0 1
48005: PPUSH
48006: CALL_OW 254
48010: ST_TO_ADDR
// for i = 1 to mc_bases do
48011: LD_ADDR_VAR 0 4
48015: PUSH
48016: DOUBLE
48017: LD_INT 1
48019: DEC
48020: ST_TO_ADDR
48021: LD_EXP 50
48025: PUSH
48026: FOR_TO
48027: IFFALSE 48214
// begin if not mc_build_list [ i ] then
48029: LD_EXP 55
48033: PUSH
48034: LD_VAR 0 4
48038: ARRAY
48039: NOT
48040: IFFALSE 48044
// continue ;
48042: GO 48026
// for j := 1 to mc_build_list [ i ] do
48044: LD_ADDR_VAR 0 5
48048: PUSH
48049: DOUBLE
48050: LD_INT 1
48052: DEC
48053: ST_TO_ADDR
48054: LD_EXP 55
48058: PUSH
48059: LD_VAR 0 4
48063: ARRAY
48064: PUSH
48065: FOR_TO
48066: IFFALSE 48210
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48068: LD_VAR 0 6
48072: PUSH
48073: LD_VAR 0 7
48077: PUSH
48078: LD_VAR 0 8
48082: PUSH
48083: LD_VAR 0 9
48087: PUSH
48088: EMPTY
48089: LIST
48090: LIST
48091: LIST
48092: LIST
48093: PPUSH
48094: LD_EXP 55
48098: PUSH
48099: LD_VAR 0 4
48103: ARRAY
48104: PUSH
48105: LD_VAR 0 5
48109: ARRAY
48110: PPUSH
48111: CALL 59746 0 2
48115: IFFALSE 48208
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48117: LD_ADDR_EXP 55
48121: PUSH
48122: LD_EXP 55
48126: PPUSH
48127: LD_VAR 0 4
48131: PPUSH
48132: LD_EXP 55
48136: PUSH
48137: LD_VAR 0 4
48141: ARRAY
48142: PPUSH
48143: LD_VAR 0 5
48147: PPUSH
48148: CALL_OW 3
48152: PPUSH
48153: CALL_OW 1
48157: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48158: LD_ADDR_EXP 57
48162: PUSH
48163: LD_EXP 57
48167: PPUSH
48168: LD_VAR 0 4
48172: PUSH
48173: LD_EXP 57
48177: PUSH
48178: LD_VAR 0 4
48182: ARRAY
48183: PUSH
48184: LD_INT 1
48186: PLUS
48187: PUSH
48188: EMPTY
48189: LIST
48190: LIST
48191: PPUSH
48192: LD_VAR 0 1
48196: PPUSH
48197: CALL 53564 0 3
48201: ST_TO_ADDR
// exit ;
48202: POP
48203: POP
48204: POP
48205: POP
48206: GO 48216
// end ;
48208: GO 48065
48210: POP
48211: POP
// end ;
48212: GO 48026
48214: POP
48215: POP
// end ;
48216: LD_VAR 0 3
48220: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48221: LD_INT 0
48223: PPUSH
48224: PPUSH
48225: PPUSH
// if not mc_bases or not skirmish then
48226: LD_EXP 50
48230: NOT
48231: PUSH
48232: LD_EXP 48
48236: NOT
48237: OR
48238: IFFALSE 48242
// exit ;
48240: GO 48432
// for i = 1 to mc_bases do
48242: LD_ADDR_VAR 0 4
48246: PUSH
48247: DOUBLE
48248: LD_INT 1
48250: DEC
48251: ST_TO_ADDR
48252: LD_EXP 50
48256: PUSH
48257: FOR_TO
48258: IFFALSE 48345
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48260: LD_VAR 0 1
48264: PUSH
48265: LD_EXP 58
48269: PUSH
48270: LD_VAR 0 4
48274: ARRAY
48275: IN
48276: PUSH
48277: LD_VAR 0 1
48281: PUSH
48282: LD_EXP 59
48286: PUSH
48287: LD_VAR 0 4
48291: ARRAY
48292: IN
48293: NOT
48294: AND
48295: IFFALSE 48343
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48297: LD_ADDR_EXP 59
48301: PUSH
48302: LD_EXP 59
48306: PPUSH
48307: LD_VAR 0 4
48311: PUSH
48312: LD_EXP 59
48316: PUSH
48317: LD_VAR 0 4
48321: ARRAY
48322: PUSH
48323: LD_INT 1
48325: PLUS
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PPUSH
48331: LD_VAR 0 1
48335: PPUSH
48336: CALL 53564 0 3
48340: ST_TO_ADDR
// break ;
48341: GO 48345
// end ; end ;
48343: GO 48257
48345: POP
48346: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48347: LD_VAR 0 1
48351: PPUSH
48352: CALL_OW 257
48356: PUSH
48357: LD_EXP 76
48361: IN
48362: PUSH
48363: LD_VAR 0 1
48367: PPUSH
48368: CALL_OW 266
48372: PUSH
48373: LD_INT 5
48375: EQUAL
48376: AND
48377: PUSH
48378: LD_VAR 0 2
48382: PPUSH
48383: CALL_OW 110
48387: PUSH
48388: LD_INT 18
48390: NONEQUAL
48391: AND
48392: IFFALSE 48432
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48394: LD_VAR 0 2
48398: PPUSH
48399: CALL_OW 257
48403: PUSH
48404: LD_INT 5
48406: PUSH
48407: LD_INT 8
48409: PUSH
48410: LD_INT 9
48412: PUSH
48413: EMPTY
48414: LIST
48415: LIST
48416: LIST
48417: IN
48418: IFFALSE 48432
// SetClass ( unit , 1 ) ;
48420: LD_VAR 0 2
48424: PPUSH
48425: LD_INT 1
48427: PPUSH
48428: CALL_OW 336
// end ;
48432: LD_VAR 0 3
48436: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48437: LD_INT 0
48439: PPUSH
48440: PPUSH
// if not mc_bases or not skirmish then
48441: LD_EXP 50
48445: NOT
48446: PUSH
48447: LD_EXP 48
48451: NOT
48452: OR
48453: IFFALSE 48457
// exit ;
48455: GO 48573
// if GetLives ( abandoned_vehicle ) > 250 then
48457: LD_VAR 0 2
48461: PPUSH
48462: CALL_OW 256
48466: PUSH
48467: LD_INT 250
48469: GREATER
48470: IFFALSE 48474
// exit ;
48472: GO 48573
// for i = 1 to mc_bases do
48474: LD_ADDR_VAR 0 6
48478: PUSH
48479: DOUBLE
48480: LD_INT 1
48482: DEC
48483: ST_TO_ADDR
48484: LD_EXP 50
48488: PUSH
48489: FOR_TO
48490: IFFALSE 48571
// begin if driver in mc_bases [ i ] then
48492: LD_VAR 0 1
48496: PUSH
48497: LD_EXP 50
48501: PUSH
48502: LD_VAR 0 6
48506: ARRAY
48507: IN
48508: IFFALSE 48569
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48510: LD_VAR 0 1
48514: PPUSH
48515: LD_EXP 50
48519: PUSH
48520: LD_VAR 0 6
48524: ARRAY
48525: PPUSH
48526: LD_INT 2
48528: PUSH
48529: LD_INT 30
48531: PUSH
48532: LD_INT 0
48534: PUSH
48535: EMPTY
48536: LIST
48537: LIST
48538: PUSH
48539: LD_INT 30
48541: PUSH
48542: LD_INT 1
48544: PUSH
48545: EMPTY
48546: LIST
48547: LIST
48548: PUSH
48549: EMPTY
48550: LIST
48551: LIST
48552: LIST
48553: PPUSH
48554: CALL_OW 72
48558: PUSH
48559: LD_INT 1
48561: ARRAY
48562: PPUSH
48563: CALL 86126 0 2
// break ;
48567: GO 48571
// end ; end ;
48569: GO 48489
48571: POP
48572: POP
// end ; end_of_file
48573: LD_VAR 0 5
48577: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48578: LD_INT 0
48580: PPUSH
48581: PPUSH
// if exist_mode then
48582: LD_VAR 0 2
48586: IFFALSE 48611
// unit := CreateCharacter ( prefix & ident ) else
48588: LD_ADDR_VAR 0 5
48592: PUSH
48593: LD_VAR 0 3
48597: PUSH
48598: LD_VAR 0 1
48602: STR
48603: PPUSH
48604: CALL_OW 34
48608: ST_TO_ADDR
48609: GO 48626
// unit := NewCharacter ( ident ) ;
48611: LD_ADDR_VAR 0 5
48615: PUSH
48616: LD_VAR 0 1
48620: PPUSH
48621: CALL_OW 25
48625: ST_TO_ADDR
// result := unit ;
48626: LD_ADDR_VAR 0 4
48630: PUSH
48631: LD_VAR 0 5
48635: ST_TO_ADDR
// end ;
48636: LD_VAR 0 4
48640: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48641: LD_INT 0
48643: PPUSH
48644: PPUSH
// if not side or not nation then
48645: LD_VAR 0 1
48649: NOT
48650: PUSH
48651: LD_VAR 0 2
48655: NOT
48656: OR
48657: IFFALSE 48661
// exit ;
48659: GO 49429
// case nation of nation_american :
48661: LD_VAR 0 2
48665: PUSH
48666: LD_INT 1
48668: DOUBLE
48669: EQUAL
48670: IFTRUE 48674
48672: GO 48888
48674: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48675: LD_ADDR_VAR 0 4
48679: PUSH
48680: LD_INT 35
48682: PUSH
48683: LD_INT 45
48685: PUSH
48686: LD_INT 46
48688: PUSH
48689: LD_INT 47
48691: PUSH
48692: LD_INT 82
48694: PUSH
48695: LD_INT 83
48697: PUSH
48698: LD_INT 84
48700: PUSH
48701: LD_INT 85
48703: PUSH
48704: LD_INT 86
48706: PUSH
48707: LD_INT 1
48709: PUSH
48710: LD_INT 2
48712: PUSH
48713: LD_INT 6
48715: PUSH
48716: LD_INT 15
48718: PUSH
48719: LD_INT 16
48721: PUSH
48722: LD_INT 7
48724: PUSH
48725: LD_INT 12
48727: PUSH
48728: LD_INT 13
48730: PUSH
48731: LD_INT 10
48733: PUSH
48734: LD_INT 14
48736: PUSH
48737: LD_INT 20
48739: PUSH
48740: LD_INT 21
48742: PUSH
48743: LD_INT 22
48745: PUSH
48746: LD_INT 25
48748: PUSH
48749: LD_INT 32
48751: PUSH
48752: LD_INT 27
48754: PUSH
48755: LD_INT 36
48757: PUSH
48758: LD_INT 69
48760: PUSH
48761: LD_INT 39
48763: PUSH
48764: LD_INT 34
48766: PUSH
48767: LD_INT 40
48769: PUSH
48770: LD_INT 48
48772: PUSH
48773: LD_INT 49
48775: PUSH
48776: LD_INT 50
48778: PUSH
48779: LD_INT 51
48781: PUSH
48782: LD_INT 52
48784: PUSH
48785: LD_INT 53
48787: PUSH
48788: LD_INT 54
48790: PUSH
48791: LD_INT 55
48793: PUSH
48794: LD_INT 56
48796: PUSH
48797: LD_INT 57
48799: PUSH
48800: LD_INT 58
48802: PUSH
48803: LD_INT 59
48805: PUSH
48806: LD_INT 60
48808: PUSH
48809: LD_INT 61
48811: PUSH
48812: LD_INT 62
48814: PUSH
48815: LD_INT 80
48817: PUSH
48818: LD_INT 82
48820: PUSH
48821: LD_INT 83
48823: PUSH
48824: LD_INT 84
48826: PUSH
48827: LD_INT 85
48829: PUSH
48830: LD_INT 86
48832: PUSH
48833: EMPTY
48834: LIST
48835: LIST
48836: LIST
48837: LIST
48838: LIST
48839: LIST
48840: LIST
48841: LIST
48842: LIST
48843: LIST
48844: LIST
48845: LIST
48846: LIST
48847: LIST
48848: LIST
48849: LIST
48850: LIST
48851: LIST
48852: LIST
48853: LIST
48854: LIST
48855: LIST
48856: LIST
48857: LIST
48858: LIST
48859: LIST
48860: LIST
48861: LIST
48862: LIST
48863: LIST
48864: LIST
48865: LIST
48866: LIST
48867: LIST
48868: LIST
48869: LIST
48870: LIST
48871: LIST
48872: LIST
48873: LIST
48874: LIST
48875: LIST
48876: LIST
48877: LIST
48878: LIST
48879: LIST
48880: LIST
48881: LIST
48882: LIST
48883: LIST
48884: LIST
48885: ST_TO_ADDR
48886: GO 49353
48888: LD_INT 2
48890: DOUBLE
48891: EQUAL
48892: IFTRUE 48896
48894: GO 49122
48896: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
48897: LD_ADDR_VAR 0 4
48901: PUSH
48902: LD_INT 35
48904: PUSH
48905: LD_INT 45
48907: PUSH
48908: LD_INT 46
48910: PUSH
48911: LD_INT 47
48913: PUSH
48914: LD_INT 82
48916: PUSH
48917: LD_INT 83
48919: PUSH
48920: LD_INT 84
48922: PUSH
48923: LD_INT 85
48925: PUSH
48926: LD_INT 87
48928: PUSH
48929: LD_INT 70
48931: PUSH
48932: LD_INT 1
48934: PUSH
48935: LD_INT 11
48937: PUSH
48938: LD_INT 3
48940: PUSH
48941: LD_INT 4
48943: PUSH
48944: LD_INT 5
48946: PUSH
48947: LD_INT 6
48949: PUSH
48950: LD_INT 15
48952: PUSH
48953: LD_INT 18
48955: PUSH
48956: LD_INT 7
48958: PUSH
48959: LD_INT 17
48961: PUSH
48962: LD_INT 8
48964: PUSH
48965: LD_INT 20
48967: PUSH
48968: LD_INT 21
48970: PUSH
48971: LD_INT 22
48973: PUSH
48974: LD_INT 72
48976: PUSH
48977: LD_INT 26
48979: PUSH
48980: LD_INT 69
48982: PUSH
48983: LD_INT 39
48985: PUSH
48986: LD_INT 40
48988: PUSH
48989: LD_INT 41
48991: PUSH
48992: LD_INT 42
48994: PUSH
48995: LD_INT 43
48997: PUSH
48998: LD_INT 48
49000: PUSH
49001: LD_INT 49
49003: PUSH
49004: LD_INT 50
49006: PUSH
49007: LD_INT 51
49009: PUSH
49010: LD_INT 52
49012: PUSH
49013: LD_INT 53
49015: PUSH
49016: LD_INT 54
49018: PUSH
49019: LD_INT 55
49021: PUSH
49022: LD_INT 56
49024: PUSH
49025: LD_INT 60
49027: PUSH
49028: LD_INT 61
49030: PUSH
49031: LD_INT 62
49033: PUSH
49034: LD_INT 66
49036: PUSH
49037: LD_INT 67
49039: PUSH
49040: LD_INT 68
49042: PUSH
49043: LD_INT 81
49045: PUSH
49046: LD_INT 82
49048: PUSH
49049: LD_INT 83
49051: PUSH
49052: LD_INT 84
49054: PUSH
49055: LD_INT 85
49057: PUSH
49058: LD_INT 87
49060: PUSH
49061: LD_INT 88
49063: PUSH
49064: EMPTY
49065: LIST
49066: LIST
49067: LIST
49068: LIST
49069: LIST
49070: LIST
49071: LIST
49072: LIST
49073: LIST
49074: LIST
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: LIST
49100: LIST
49101: LIST
49102: LIST
49103: LIST
49104: LIST
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: LIST
49110: LIST
49111: LIST
49112: LIST
49113: LIST
49114: LIST
49115: LIST
49116: LIST
49117: LIST
49118: LIST
49119: ST_TO_ADDR
49120: GO 49353
49122: LD_INT 3
49124: DOUBLE
49125: EQUAL
49126: IFTRUE 49130
49128: GO 49352
49130: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49131: LD_ADDR_VAR 0 4
49135: PUSH
49136: LD_INT 46
49138: PUSH
49139: LD_INT 47
49141: PUSH
49142: LD_INT 1
49144: PUSH
49145: LD_INT 2
49147: PUSH
49148: LD_INT 82
49150: PUSH
49151: LD_INT 83
49153: PUSH
49154: LD_INT 84
49156: PUSH
49157: LD_INT 85
49159: PUSH
49160: LD_INT 86
49162: PUSH
49163: LD_INT 11
49165: PUSH
49166: LD_INT 9
49168: PUSH
49169: LD_INT 20
49171: PUSH
49172: LD_INT 19
49174: PUSH
49175: LD_INT 21
49177: PUSH
49178: LD_INT 24
49180: PUSH
49181: LD_INT 22
49183: PUSH
49184: LD_INT 25
49186: PUSH
49187: LD_INT 28
49189: PUSH
49190: LD_INT 29
49192: PUSH
49193: LD_INT 30
49195: PUSH
49196: LD_INT 31
49198: PUSH
49199: LD_INT 37
49201: PUSH
49202: LD_INT 38
49204: PUSH
49205: LD_INT 32
49207: PUSH
49208: LD_INT 27
49210: PUSH
49211: LD_INT 33
49213: PUSH
49214: LD_INT 69
49216: PUSH
49217: LD_INT 39
49219: PUSH
49220: LD_INT 34
49222: PUSH
49223: LD_INT 40
49225: PUSH
49226: LD_INT 71
49228: PUSH
49229: LD_INT 23
49231: PUSH
49232: LD_INT 44
49234: PUSH
49235: LD_INT 48
49237: PUSH
49238: LD_INT 49
49240: PUSH
49241: LD_INT 50
49243: PUSH
49244: LD_INT 51
49246: PUSH
49247: LD_INT 52
49249: PUSH
49250: LD_INT 53
49252: PUSH
49253: LD_INT 54
49255: PUSH
49256: LD_INT 55
49258: PUSH
49259: LD_INT 56
49261: PUSH
49262: LD_INT 57
49264: PUSH
49265: LD_INT 58
49267: PUSH
49268: LD_INT 59
49270: PUSH
49271: LD_INT 63
49273: PUSH
49274: LD_INT 64
49276: PUSH
49277: LD_INT 65
49279: PUSH
49280: LD_INT 82
49282: PUSH
49283: LD_INT 83
49285: PUSH
49286: LD_INT 84
49288: PUSH
49289: LD_INT 85
49291: PUSH
49292: LD_INT 86
49294: PUSH
49295: EMPTY
49296: LIST
49297: LIST
49298: LIST
49299: LIST
49300: LIST
49301: LIST
49302: LIST
49303: LIST
49304: LIST
49305: LIST
49306: LIST
49307: LIST
49308: LIST
49309: LIST
49310: LIST
49311: LIST
49312: LIST
49313: LIST
49314: LIST
49315: LIST
49316: LIST
49317: LIST
49318: LIST
49319: LIST
49320: LIST
49321: LIST
49322: LIST
49323: LIST
49324: LIST
49325: LIST
49326: LIST
49327: LIST
49328: LIST
49329: LIST
49330: LIST
49331: LIST
49332: LIST
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: LIST
49344: LIST
49345: LIST
49346: LIST
49347: LIST
49348: LIST
49349: ST_TO_ADDR
49350: GO 49353
49352: POP
// if state > - 1 and state < 3 then
49353: LD_VAR 0 3
49357: PUSH
49358: LD_INT 1
49360: NEG
49361: GREATER
49362: PUSH
49363: LD_VAR 0 3
49367: PUSH
49368: LD_INT 3
49370: LESS
49371: AND
49372: IFFALSE 49429
// for i in result do
49374: LD_ADDR_VAR 0 5
49378: PUSH
49379: LD_VAR 0 4
49383: PUSH
49384: FOR_IN
49385: IFFALSE 49427
// if GetTech ( i , side ) <> state then
49387: LD_VAR 0 5
49391: PPUSH
49392: LD_VAR 0 1
49396: PPUSH
49397: CALL_OW 321
49401: PUSH
49402: LD_VAR 0 3
49406: NONEQUAL
49407: IFFALSE 49425
// result := result diff i ;
49409: LD_ADDR_VAR 0 4
49413: PUSH
49414: LD_VAR 0 4
49418: PUSH
49419: LD_VAR 0 5
49423: DIFF
49424: ST_TO_ADDR
49425: GO 49384
49427: POP
49428: POP
// end ;
49429: LD_VAR 0 4
49433: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49434: LD_INT 0
49436: PPUSH
49437: PPUSH
49438: PPUSH
// result := true ;
49439: LD_ADDR_VAR 0 3
49443: PUSH
49444: LD_INT 1
49446: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49447: LD_ADDR_VAR 0 5
49451: PUSH
49452: LD_VAR 0 2
49456: PPUSH
49457: CALL_OW 480
49461: ST_TO_ADDR
// if not tmp then
49462: LD_VAR 0 5
49466: NOT
49467: IFFALSE 49471
// exit ;
49469: GO 49520
// for i in tmp do
49471: LD_ADDR_VAR 0 4
49475: PUSH
49476: LD_VAR 0 5
49480: PUSH
49481: FOR_IN
49482: IFFALSE 49518
// if GetTech ( i , side ) <> state_researched then
49484: LD_VAR 0 4
49488: PPUSH
49489: LD_VAR 0 1
49493: PPUSH
49494: CALL_OW 321
49498: PUSH
49499: LD_INT 2
49501: NONEQUAL
49502: IFFALSE 49516
// begin result := false ;
49504: LD_ADDR_VAR 0 3
49508: PUSH
49509: LD_INT 0
49511: ST_TO_ADDR
// exit ;
49512: POP
49513: POP
49514: GO 49520
// end ;
49516: GO 49481
49518: POP
49519: POP
// end ;
49520: LD_VAR 0 3
49524: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49525: LD_INT 0
49527: PPUSH
49528: PPUSH
49529: PPUSH
49530: PPUSH
49531: PPUSH
49532: PPUSH
49533: PPUSH
49534: PPUSH
49535: PPUSH
49536: PPUSH
49537: PPUSH
49538: PPUSH
49539: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49540: LD_VAR 0 1
49544: NOT
49545: PUSH
49546: LD_VAR 0 1
49550: PPUSH
49551: CALL_OW 257
49555: PUSH
49556: LD_INT 9
49558: NONEQUAL
49559: OR
49560: IFFALSE 49564
// exit ;
49562: GO 50137
// side := GetSide ( unit ) ;
49564: LD_ADDR_VAR 0 9
49568: PUSH
49569: LD_VAR 0 1
49573: PPUSH
49574: CALL_OW 255
49578: ST_TO_ADDR
// tech_space := tech_spacanom ;
49579: LD_ADDR_VAR 0 12
49583: PUSH
49584: LD_INT 29
49586: ST_TO_ADDR
// tech_time := tech_taurad ;
49587: LD_ADDR_VAR 0 13
49591: PUSH
49592: LD_INT 28
49594: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49595: LD_ADDR_VAR 0 11
49599: PUSH
49600: LD_VAR 0 1
49604: PPUSH
49605: CALL_OW 310
49609: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49610: LD_VAR 0 11
49614: PPUSH
49615: CALL_OW 247
49619: PUSH
49620: LD_INT 2
49622: EQUAL
49623: IFFALSE 49627
// exit ;
49625: GO 50137
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49627: LD_ADDR_VAR 0 8
49631: PUSH
49632: LD_INT 81
49634: PUSH
49635: LD_VAR 0 9
49639: PUSH
49640: EMPTY
49641: LIST
49642: LIST
49643: PUSH
49644: LD_INT 3
49646: PUSH
49647: LD_INT 21
49649: PUSH
49650: LD_INT 3
49652: PUSH
49653: EMPTY
49654: LIST
49655: LIST
49656: PUSH
49657: EMPTY
49658: LIST
49659: LIST
49660: PUSH
49661: EMPTY
49662: LIST
49663: LIST
49664: PPUSH
49665: CALL_OW 69
49669: ST_TO_ADDR
// if not tmp then
49670: LD_VAR 0 8
49674: NOT
49675: IFFALSE 49679
// exit ;
49677: GO 50137
// if in_unit then
49679: LD_VAR 0 11
49683: IFFALSE 49707
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49685: LD_ADDR_VAR 0 10
49689: PUSH
49690: LD_VAR 0 8
49694: PPUSH
49695: LD_VAR 0 11
49699: PPUSH
49700: CALL_OW 74
49704: ST_TO_ADDR
49705: GO 49727
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49707: LD_ADDR_VAR 0 10
49711: PUSH
49712: LD_VAR 0 8
49716: PPUSH
49717: LD_VAR 0 1
49721: PPUSH
49722: CALL_OW 74
49726: ST_TO_ADDR
// if not enemy then
49727: LD_VAR 0 10
49731: NOT
49732: IFFALSE 49736
// exit ;
49734: GO 50137
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49736: LD_VAR 0 11
49740: PUSH
49741: LD_VAR 0 11
49745: PPUSH
49746: LD_VAR 0 10
49750: PPUSH
49751: CALL_OW 296
49755: PUSH
49756: LD_INT 13
49758: GREATER
49759: AND
49760: PUSH
49761: LD_VAR 0 1
49765: PPUSH
49766: LD_VAR 0 10
49770: PPUSH
49771: CALL_OW 296
49775: PUSH
49776: LD_INT 12
49778: GREATER
49779: OR
49780: IFFALSE 49784
// exit ;
49782: GO 50137
// missile := [ 1 ] ;
49784: LD_ADDR_VAR 0 14
49788: PUSH
49789: LD_INT 1
49791: PUSH
49792: EMPTY
49793: LIST
49794: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49795: LD_VAR 0 9
49799: PPUSH
49800: LD_VAR 0 12
49804: PPUSH
49805: CALL_OW 325
49809: IFFALSE 49838
// missile := Replace ( missile , missile + 1 , 2 ) ;
49811: LD_ADDR_VAR 0 14
49815: PUSH
49816: LD_VAR 0 14
49820: PPUSH
49821: LD_VAR 0 14
49825: PUSH
49826: LD_INT 1
49828: PLUS
49829: PPUSH
49830: LD_INT 2
49832: PPUSH
49833: CALL_OW 1
49837: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49838: LD_VAR 0 9
49842: PPUSH
49843: LD_VAR 0 13
49847: PPUSH
49848: CALL_OW 325
49852: PUSH
49853: LD_VAR 0 10
49857: PPUSH
49858: CALL_OW 255
49862: PPUSH
49863: LD_VAR 0 13
49867: PPUSH
49868: CALL_OW 325
49872: NOT
49873: AND
49874: IFFALSE 49903
// missile := Replace ( missile , missile + 1 , 3 ) ;
49876: LD_ADDR_VAR 0 14
49880: PUSH
49881: LD_VAR 0 14
49885: PPUSH
49886: LD_VAR 0 14
49890: PUSH
49891: LD_INT 1
49893: PLUS
49894: PPUSH
49895: LD_INT 3
49897: PPUSH
49898: CALL_OW 1
49902: ST_TO_ADDR
// if missile < 2 then
49903: LD_VAR 0 14
49907: PUSH
49908: LD_INT 2
49910: LESS
49911: IFFALSE 49915
// exit ;
49913: GO 50137
// x := GetX ( enemy ) ;
49915: LD_ADDR_VAR 0 4
49919: PUSH
49920: LD_VAR 0 10
49924: PPUSH
49925: CALL_OW 250
49929: ST_TO_ADDR
// y := GetY ( enemy ) ;
49930: LD_ADDR_VAR 0 5
49934: PUSH
49935: LD_VAR 0 10
49939: PPUSH
49940: CALL_OW 251
49944: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
49945: LD_ADDR_VAR 0 6
49949: PUSH
49950: LD_VAR 0 4
49954: PUSH
49955: LD_INT 1
49957: NEG
49958: PPUSH
49959: LD_INT 1
49961: PPUSH
49962: CALL_OW 12
49966: PLUS
49967: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
49968: LD_ADDR_VAR 0 7
49972: PUSH
49973: LD_VAR 0 5
49977: PUSH
49978: LD_INT 1
49980: NEG
49981: PPUSH
49982: LD_INT 1
49984: PPUSH
49985: CALL_OW 12
49989: PLUS
49990: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49991: LD_VAR 0 6
49995: PPUSH
49996: LD_VAR 0 7
50000: PPUSH
50001: CALL_OW 488
50005: NOT
50006: IFFALSE 50028
// begin _x := x ;
50008: LD_ADDR_VAR 0 6
50012: PUSH
50013: LD_VAR 0 4
50017: ST_TO_ADDR
// _y := y ;
50018: LD_ADDR_VAR 0 7
50022: PUSH
50023: LD_VAR 0 5
50027: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50028: LD_ADDR_VAR 0 3
50032: PUSH
50033: LD_INT 1
50035: PPUSH
50036: LD_VAR 0 14
50040: PPUSH
50041: CALL_OW 12
50045: ST_TO_ADDR
// case i of 1 :
50046: LD_VAR 0 3
50050: PUSH
50051: LD_INT 1
50053: DOUBLE
50054: EQUAL
50055: IFTRUE 50059
50057: GO 50076
50059: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50060: LD_VAR 0 1
50064: PPUSH
50065: LD_VAR 0 10
50069: PPUSH
50070: CALL_OW 115
50074: GO 50137
50076: LD_INT 2
50078: DOUBLE
50079: EQUAL
50080: IFTRUE 50084
50082: GO 50106
50084: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50085: LD_VAR 0 1
50089: PPUSH
50090: LD_VAR 0 6
50094: PPUSH
50095: LD_VAR 0 7
50099: PPUSH
50100: CALL_OW 153
50104: GO 50137
50106: LD_INT 3
50108: DOUBLE
50109: EQUAL
50110: IFTRUE 50114
50112: GO 50136
50114: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50115: LD_VAR 0 1
50119: PPUSH
50120: LD_VAR 0 6
50124: PPUSH
50125: LD_VAR 0 7
50129: PPUSH
50130: CALL_OW 154
50134: GO 50137
50136: POP
// end ;
50137: LD_VAR 0 2
50141: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50142: LD_INT 0
50144: PPUSH
50145: PPUSH
50146: PPUSH
50147: PPUSH
50148: PPUSH
50149: PPUSH
// if not unit or not building then
50150: LD_VAR 0 1
50154: NOT
50155: PUSH
50156: LD_VAR 0 2
50160: NOT
50161: OR
50162: IFFALSE 50166
// exit ;
50164: GO 50324
// x := GetX ( building ) ;
50166: LD_ADDR_VAR 0 5
50170: PUSH
50171: LD_VAR 0 2
50175: PPUSH
50176: CALL_OW 250
50180: ST_TO_ADDR
// y := GetY ( building ) ;
50181: LD_ADDR_VAR 0 6
50185: PUSH
50186: LD_VAR 0 2
50190: PPUSH
50191: CALL_OW 251
50195: ST_TO_ADDR
// for i = 0 to 5 do
50196: LD_ADDR_VAR 0 4
50200: PUSH
50201: DOUBLE
50202: LD_INT 0
50204: DEC
50205: ST_TO_ADDR
50206: LD_INT 5
50208: PUSH
50209: FOR_TO
50210: IFFALSE 50322
// begin _x := ShiftX ( x , i , 3 ) ;
50212: LD_ADDR_VAR 0 7
50216: PUSH
50217: LD_VAR 0 5
50221: PPUSH
50222: LD_VAR 0 4
50226: PPUSH
50227: LD_INT 3
50229: PPUSH
50230: CALL_OW 272
50234: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50235: LD_ADDR_VAR 0 8
50239: PUSH
50240: LD_VAR 0 6
50244: PPUSH
50245: LD_VAR 0 4
50249: PPUSH
50250: LD_INT 3
50252: PPUSH
50253: CALL_OW 273
50257: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50258: LD_VAR 0 7
50262: PPUSH
50263: LD_VAR 0 8
50267: PPUSH
50268: CALL_OW 488
50272: NOT
50273: IFFALSE 50277
// continue ;
50275: GO 50209
// if HexInfo ( _x , _y ) = 0 then
50277: LD_VAR 0 7
50281: PPUSH
50282: LD_VAR 0 8
50286: PPUSH
50287: CALL_OW 428
50291: PUSH
50292: LD_INT 0
50294: EQUAL
50295: IFFALSE 50320
// begin ComMoveXY ( unit , _x , _y ) ;
50297: LD_VAR 0 1
50301: PPUSH
50302: LD_VAR 0 7
50306: PPUSH
50307: LD_VAR 0 8
50311: PPUSH
50312: CALL_OW 111
// exit ;
50316: POP
50317: POP
50318: GO 50324
// end ; end ;
50320: GO 50209
50322: POP
50323: POP
// end ;
50324: LD_VAR 0 3
50328: RET
// export function ScanBase ( side , base_area ) ; begin
50329: LD_INT 0
50331: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50332: LD_ADDR_VAR 0 3
50336: PUSH
50337: LD_VAR 0 2
50341: PPUSH
50342: LD_INT 81
50344: PUSH
50345: LD_VAR 0 1
50349: PUSH
50350: EMPTY
50351: LIST
50352: LIST
50353: PPUSH
50354: CALL_OW 70
50358: ST_TO_ADDR
// end ;
50359: LD_VAR 0 3
50363: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50364: LD_INT 0
50366: PPUSH
50367: PPUSH
50368: PPUSH
50369: PPUSH
// result := false ;
50370: LD_ADDR_VAR 0 2
50374: PUSH
50375: LD_INT 0
50377: ST_TO_ADDR
// side := GetSide ( unit ) ;
50378: LD_ADDR_VAR 0 3
50382: PUSH
50383: LD_VAR 0 1
50387: PPUSH
50388: CALL_OW 255
50392: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50393: LD_ADDR_VAR 0 4
50397: PUSH
50398: LD_VAR 0 1
50402: PPUSH
50403: CALL_OW 248
50407: ST_TO_ADDR
// case nat of 1 :
50408: LD_VAR 0 4
50412: PUSH
50413: LD_INT 1
50415: DOUBLE
50416: EQUAL
50417: IFTRUE 50421
50419: GO 50432
50421: POP
// tech := tech_lassight ; 2 :
50422: LD_ADDR_VAR 0 5
50426: PUSH
50427: LD_INT 12
50429: ST_TO_ADDR
50430: GO 50471
50432: LD_INT 2
50434: DOUBLE
50435: EQUAL
50436: IFTRUE 50440
50438: GO 50451
50440: POP
// tech := tech_mortar ; 3 :
50441: LD_ADDR_VAR 0 5
50445: PUSH
50446: LD_INT 41
50448: ST_TO_ADDR
50449: GO 50471
50451: LD_INT 3
50453: DOUBLE
50454: EQUAL
50455: IFTRUE 50459
50457: GO 50470
50459: POP
// tech := tech_bazooka ; end ;
50460: LD_ADDR_VAR 0 5
50464: PUSH
50465: LD_INT 44
50467: ST_TO_ADDR
50468: GO 50471
50470: POP
// if Researched ( side , tech ) then
50471: LD_VAR 0 3
50475: PPUSH
50476: LD_VAR 0 5
50480: PPUSH
50481: CALL_OW 325
50485: IFFALSE 50512
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50487: LD_ADDR_VAR 0 2
50491: PUSH
50492: LD_INT 5
50494: PUSH
50495: LD_INT 8
50497: PUSH
50498: LD_INT 9
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: LIST
50505: PUSH
50506: LD_VAR 0 4
50510: ARRAY
50511: ST_TO_ADDR
// end ;
50512: LD_VAR 0 2
50516: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50517: LD_INT 0
50519: PPUSH
50520: PPUSH
50521: PPUSH
// if not mines then
50522: LD_VAR 0 2
50526: NOT
50527: IFFALSE 50531
// exit ;
50529: GO 50675
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50531: LD_ADDR_VAR 0 5
50535: PUSH
50536: LD_INT 81
50538: PUSH
50539: LD_VAR 0 1
50543: PUSH
50544: EMPTY
50545: LIST
50546: LIST
50547: PUSH
50548: LD_INT 3
50550: PUSH
50551: LD_INT 21
50553: PUSH
50554: LD_INT 3
50556: PUSH
50557: EMPTY
50558: LIST
50559: LIST
50560: PUSH
50561: EMPTY
50562: LIST
50563: LIST
50564: PUSH
50565: EMPTY
50566: LIST
50567: LIST
50568: PPUSH
50569: CALL_OW 69
50573: ST_TO_ADDR
// for i in mines do
50574: LD_ADDR_VAR 0 4
50578: PUSH
50579: LD_VAR 0 2
50583: PUSH
50584: FOR_IN
50585: IFFALSE 50673
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50587: LD_VAR 0 4
50591: PUSH
50592: LD_INT 1
50594: ARRAY
50595: PPUSH
50596: LD_VAR 0 4
50600: PUSH
50601: LD_INT 2
50603: ARRAY
50604: PPUSH
50605: CALL_OW 458
50609: NOT
50610: IFFALSE 50614
// continue ;
50612: GO 50584
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50614: LD_VAR 0 4
50618: PUSH
50619: LD_INT 1
50621: ARRAY
50622: PPUSH
50623: LD_VAR 0 4
50627: PUSH
50628: LD_INT 2
50630: ARRAY
50631: PPUSH
50632: CALL_OW 428
50636: PUSH
50637: LD_VAR 0 5
50641: IN
50642: IFFALSE 50671
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50644: LD_VAR 0 4
50648: PUSH
50649: LD_INT 1
50651: ARRAY
50652: PPUSH
50653: LD_VAR 0 4
50657: PUSH
50658: LD_INT 2
50660: ARRAY
50661: PPUSH
50662: LD_VAR 0 1
50666: PPUSH
50667: CALL_OW 456
// end ;
50671: GO 50584
50673: POP
50674: POP
// end ;
50675: LD_VAR 0 3
50679: RET
// export function Count ( array ) ; var i ; begin
50680: LD_INT 0
50682: PPUSH
50683: PPUSH
// result := 0 ;
50684: LD_ADDR_VAR 0 2
50688: PUSH
50689: LD_INT 0
50691: ST_TO_ADDR
// for i in array do
50692: LD_ADDR_VAR 0 3
50696: PUSH
50697: LD_VAR 0 1
50701: PUSH
50702: FOR_IN
50703: IFFALSE 50727
// if i then
50705: LD_VAR 0 3
50709: IFFALSE 50725
// result := result + 1 ;
50711: LD_ADDR_VAR 0 2
50715: PUSH
50716: LD_VAR 0 2
50720: PUSH
50721: LD_INT 1
50723: PLUS
50724: ST_TO_ADDR
50725: GO 50702
50727: POP
50728: POP
// end ;
50729: LD_VAR 0 2
50733: RET
// export function IsEmpty ( building ) ; begin
50734: LD_INT 0
50736: PPUSH
// if not building then
50737: LD_VAR 0 1
50741: NOT
50742: IFFALSE 50746
// exit ;
50744: GO 50789
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50746: LD_ADDR_VAR 0 2
50750: PUSH
50751: LD_VAR 0 1
50755: PUSH
50756: LD_INT 22
50758: PUSH
50759: LD_VAR 0 1
50763: PPUSH
50764: CALL_OW 255
50768: PUSH
50769: EMPTY
50770: LIST
50771: LIST
50772: PUSH
50773: LD_INT 58
50775: PUSH
50776: EMPTY
50777: LIST
50778: PUSH
50779: EMPTY
50780: LIST
50781: LIST
50782: PPUSH
50783: CALL_OW 69
50787: IN
50788: ST_TO_ADDR
// end ;
50789: LD_VAR 0 2
50793: RET
// export function IsNotFull ( building ) ; begin
50794: LD_INT 0
50796: PPUSH
// if not building then
50797: LD_VAR 0 1
50801: NOT
50802: IFFALSE 50806
// exit ;
50804: GO 50825
// result := UnitsInside ( building ) < 6 ;
50806: LD_ADDR_VAR 0 2
50810: PUSH
50811: LD_VAR 0 1
50815: PPUSH
50816: CALL_OW 313
50820: PUSH
50821: LD_INT 6
50823: LESS
50824: ST_TO_ADDR
// end ;
50825: LD_VAR 0 2
50829: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
50830: LD_INT 0
50832: PPUSH
50833: PPUSH
50834: PPUSH
50835: PPUSH
// tmp := [ ] ;
50836: LD_ADDR_VAR 0 3
50840: PUSH
50841: EMPTY
50842: ST_TO_ADDR
// list := [ ] ;
50843: LD_ADDR_VAR 0 5
50847: PUSH
50848: EMPTY
50849: ST_TO_ADDR
// for i = 16 to 25 do
50850: LD_ADDR_VAR 0 4
50854: PUSH
50855: DOUBLE
50856: LD_INT 16
50858: DEC
50859: ST_TO_ADDR
50860: LD_INT 25
50862: PUSH
50863: FOR_TO
50864: IFFALSE 50937
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
50866: LD_ADDR_VAR 0 3
50870: PUSH
50871: LD_VAR 0 3
50875: PUSH
50876: LD_INT 22
50878: PUSH
50879: LD_VAR 0 1
50883: PPUSH
50884: CALL_OW 255
50888: PUSH
50889: EMPTY
50890: LIST
50891: LIST
50892: PUSH
50893: LD_INT 91
50895: PUSH
50896: LD_VAR 0 1
50900: PUSH
50901: LD_INT 6
50903: PUSH
50904: EMPTY
50905: LIST
50906: LIST
50907: LIST
50908: PUSH
50909: LD_INT 30
50911: PUSH
50912: LD_VAR 0 4
50916: PUSH
50917: EMPTY
50918: LIST
50919: LIST
50920: PUSH
50921: EMPTY
50922: LIST
50923: LIST
50924: LIST
50925: PUSH
50926: EMPTY
50927: LIST
50928: PPUSH
50929: CALL_OW 69
50933: ADD
50934: ST_TO_ADDR
50935: GO 50863
50937: POP
50938: POP
// for i = 1 to tmp do
50939: LD_ADDR_VAR 0 4
50943: PUSH
50944: DOUBLE
50945: LD_INT 1
50947: DEC
50948: ST_TO_ADDR
50949: LD_VAR 0 3
50953: PUSH
50954: FOR_TO
50955: IFFALSE 51043
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
50957: LD_ADDR_VAR 0 5
50961: PUSH
50962: LD_VAR 0 5
50966: PUSH
50967: LD_VAR 0 3
50971: PUSH
50972: LD_VAR 0 4
50976: ARRAY
50977: PPUSH
50978: CALL_OW 266
50982: PUSH
50983: LD_VAR 0 3
50987: PUSH
50988: LD_VAR 0 4
50992: ARRAY
50993: PPUSH
50994: CALL_OW 250
50998: PUSH
50999: LD_VAR 0 3
51003: PUSH
51004: LD_VAR 0 4
51008: ARRAY
51009: PPUSH
51010: CALL_OW 251
51014: PUSH
51015: LD_VAR 0 3
51019: PUSH
51020: LD_VAR 0 4
51024: ARRAY
51025: PPUSH
51026: CALL_OW 254
51030: PUSH
51031: EMPTY
51032: LIST
51033: LIST
51034: LIST
51035: LIST
51036: PUSH
51037: EMPTY
51038: LIST
51039: ADD
51040: ST_TO_ADDR
51041: GO 50954
51043: POP
51044: POP
// result := list ;
51045: LD_ADDR_VAR 0 2
51049: PUSH
51050: LD_VAR 0 5
51054: ST_TO_ADDR
// end ;
51055: LD_VAR 0 2
51059: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51060: LD_INT 0
51062: PPUSH
51063: PPUSH
51064: PPUSH
51065: PPUSH
51066: PPUSH
51067: PPUSH
51068: PPUSH
// if not factory then
51069: LD_VAR 0 1
51073: NOT
51074: IFFALSE 51078
// exit ;
51076: GO 51671
// if control = control_apeman then
51078: LD_VAR 0 4
51082: PUSH
51083: LD_INT 5
51085: EQUAL
51086: IFFALSE 51195
// begin tmp := UnitsInside ( factory ) ;
51088: LD_ADDR_VAR 0 8
51092: PUSH
51093: LD_VAR 0 1
51097: PPUSH
51098: CALL_OW 313
51102: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51103: LD_VAR 0 8
51107: PPUSH
51108: LD_INT 25
51110: PUSH
51111: LD_INT 12
51113: PUSH
51114: EMPTY
51115: LIST
51116: LIST
51117: PPUSH
51118: CALL_OW 72
51122: NOT
51123: IFFALSE 51133
// control := control_manual ;
51125: LD_ADDR_VAR 0 4
51129: PUSH
51130: LD_INT 1
51132: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51133: LD_ADDR_VAR 0 8
51137: PUSH
51138: LD_VAR 0 1
51142: PPUSH
51143: CALL 50830 0 1
51147: ST_TO_ADDR
// if tmp then
51148: LD_VAR 0 8
51152: IFFALSE 51195
// begin for i in tmp do
51154: LD_ADDR_VAR 0 7
51158: PUSH
51159: LD_VAR 0 8
51163: PUSH
51164: FOR_IN
51165: IFFALSE 51193
// if i [ 1 ] = b_ext_radio then
51167: LD_VAR 0 7
51171: PUSH
51172: LD_INT 1
51174: ARRAY
51175: PUSH
51176: LD_INT 22
51178: EQUAL
51179: IFFALSE 51191
// begin control := control_remote ;
51181: LD_ADDR_VAR 0 4
51185: PUSH
51186: LD_INT 2
51188: ST_TO_ADDR
// break ;
51189: GO 51193
// end ;
51191: GO 51164
51193: POP
51194: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51195: LD_VAR 0 1
51199: PPUSH
51200: LD_VAR 0 2
51204: PPUSH
51205: LD_VAR 0 3
51209: PPUSH
51210: LD_VAR 0 4
51214: PPUSH
51215: LD_VAR 0 5
51219: PPUSH
51220: CALL_OW 448
51224: IFFALSE 51259
// begin result := [ chassis , engine , control , weapon ] ;
51226: LD_ADDR_VAR 0 6
51230: PUSH
51231: LD_VAR 0 2
51235: PUSH
51236: LD_VAR 0 3
51240: PUSH
51241: LD_VAR 0 4
51245: PUSH
51246: LD_VAR 0 5
51250: PUSH
51251: EMPTY
51252: LIST
51253: LIST
51254: LIST
51255: LIST
51256: ST_TO_ADDR
// exit ;
51257: GO 51671
// end ; _chassis := AvailableChassisList ( factory ) ;
51259: LD_ADDR_VAR 0 9
51263: PUSH
51264: LD_VAR 0 1
51268: PPUSH
51269: CALL_OW 475
51273: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51274: LD_ADDR_VAR 0 11
51278: PUSH
51279: LD_VAR 0 1
51283: PPUSH
51284: CALL_OW 476
51288: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51289: LD_ADDR_VAR 0 12
51293: PUSH
51294: LD_VAR 0 1
51298: PPUSH
51299: CALL_OW 477
51303: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51304: LD_ADDR_VAR 0 10
51308: PUSH
51309: LD_VAR 0 1
51313: PPUSH
51314: CALL_OW 478
51318: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51319: LD_VAR 0 9
51323: NOT
51324: PUSH
51325: LD_VAR 0 11
51329: NOT
51330: OR
51331: PUSH
51332: LD_VAR 0 12
51336: NOT
51337: OR
51338: PUSH
51339: LD_VAR 0 10
51343: NOT
51344: OR
51345: IFFALSE 51380
// begin result := [ chassis , engine , control , weapon ] ;
51347: LD_ADDR_VAR 0 6
51351: PUSH
51352: LD_VAR 0 2
51356: PUSH
51357: LD_VAR 0 3
51361: PUSH
51362: LD_VAR 0 4
51366: PUSH
51367: LD_VAR 0 5
51371: PUSH
51372: EMPTY
51373: LIST
51374: LIST
51375: LIST
51376: LIST
51377: ST_TO_ADDR
// exit ;
51378: GO 51671
// end ; if not chassis in _chassis then
51380: LD_VAR 0 2
51384: PUSH
51385: LD_VAR 0 9
51389: IN
51390: NOT
51391: IFFALSE 51417
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51393: LD_ADDR_VAR 0 2
51397: PUSH
51398: LD_VAR 0 9
51402: PUSH
51403: LD_INT 1
51405: PPUSH
51406: LD_VAR 0 9
51410: PPUSH
51411: CALL_OW 12
51415: ARRAY
51416: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51417: LD_VAR 0 2
51421: PPUSH
51422: LD_VAR 0 3
51426: PPUSH
51427: CALL 51676 0 2
51431: NOT
51432: IFFALSE 51491
// repeat engine := _engine [ 1 ] ;
51434: LD_ADDR_VAR 0 3
51438: PUSH
51439: LD_VAR 0 11
51443: PUSH
51444: LD_INT 1
51446: ARRAY
51447: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51448: LD_ADDR_VAR 0 11
51452: PUSH
51453: LD_VAR 0 11
51457: PPUSH
51458: LD_INT 1
51460: PPUSH
51461: CALL_OW 3
51465: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51466: LD_VAR 0 2
51470: PPUSH
51471: LD_VAR 0 3
51475: PPUSH
51476: CALL 51676 0 2
51480: PUSH
51481: LD_VAR 0 11
51485: PUSH
51486: EMPTY
51487: EQUAL
51488: OR
51489: IFFALSE 51434
// if not control in _control then
51491: LD_VAR 0 4
51495: PUSH
51496: LD_VAR 0 12
51500: IN
51501: NOT
51502: IFFALSE 51528
// control := _control [ rand ( 1 , _control ) ] ;
51504: LD_ADDR_VAR 0 4
51508: PUSH
51509: LD_VAR 0 12
51513: PUSH
51514: LD_INT 1
51516: PPUSH
51517: LD_VAR 0 12
51521: PPUSH
51522: CALL_OW 12
51526: ARRAY
51527: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51528: LD_VAR 0 2
51532: PPUSH
51533: LD_VAR 0 5
51537: PPUSH
51538: CALL 51896 0 2
51542: NOT
51543: IFFALSE 51602
// repeat weapon := _weapon [ 1 ] ;
51545: LD_ADDR_VAR 0 5
51549: PUSH
51550: LD_VAR 0 10
51554: PUSH
51555: LD_INT 1
51557: ARRAY
51558: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51559: LD_ADDR_VAR 0 10
51563: PUSH
51564: LD_VAR 0 10
51568: PPUSH
51569: LD_INT 1
51571: PPUSH
51572: CALL_OW 3
51576: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51577: LD_VAR 0 2
51581: PPUSH
51582: LD_VAR 0 5
51586: PPUSH
51587: CALL 51896 0 2
51591: PUSH
51592: LD_VAR 0 10
51596: PUSH
51597: EMPTY
51598: EQUAL
51599: OR
51600: IFFALSE 51545
// result := [ ] ;
51602: LD_ADDR_VAR 0 6
51606: PUSH
51607: EMPTY
51608: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51609: LD_VAR 0 1
51613: PPUSH
51614: LD_VAR 0 2
51618: PPUSH
51619: LD_VAR 0 3
51623: PPUSH
51624: LD_VAR 0 4
51628: PPUSH
51629: LD_VAR 0 5
51633: PPUSH
51634: CALL_OW 448
51638: IFFALSE 51671
// result := [ chassis , engine , control , weapon ] ;
51640: LD_ADDR_VAR 0 6
51644: PUSH
51645: LD_VAR 0 2
51649: PUSH
51650: LD_VAR 0 3
51654: PUSH
51655: LD_VAR 0 4
51659: PUSH
51660: LD_VAR 0 5
51664: PUSH
51665: EMPTY
51666: LIST
51667: LIST
51668: LIST
51669: LIST
51670: ST_TO_ADDR
// end ;
51671: LD_VAR 0 6
51675: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51676: LD_INT 0
51678: PPUSH
// if not chassis or not engine then
51679: LD_VAR 0 1
51683: NOT
51684: PUSH
51685: LD_VAR 0 2
51689: NOT
51690: OR
51691: IFFALSE 51695
// exit ;
51693: GO 51891
// case engine of engine_solar :
51695: LD_VAR 0 2
51699: PUSH
51700: LD_INT 2
51702: DOUBLE
51703: EQUAL
51704: IFTRUE 51708
51706: GO 51746
51708: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51709: LD_ADDR_VAR 0 3
51713: PUSH
51714: LD_INT 11
51716: PUSH
51717: LD_INT 12
51719: PUSH
51720: LD_INT 13
51722: PUSH
51723: LD_INT 14
51725: PUSH
51726: LD_INT 1
51728: PUSH
51729: LD_INT 2
51731: PUSH
51732: LD_INT 3
51734: PUSH
51735: EMPTY
51736: LIST
51737: LIST
51738: LIST
51739: LIST
51740: LIST
51741: LIST
51742: LIST
51743: ST_TO_ADDR
51744: GO 51875
51746: LD_INT 1
51748: DOUBLE
51749: EQUAL
51750: IFTRUE 51754
51752: GO 51816
51754: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51755: LD_ADDR_VAR 0 3
51759: PUSH
51760: LD_INT 11
51762: PUSH
51763: LD_INT 12
51765: PUSH
51766: LD_INT 13
51768: PUSH
51769: LD_INT 14
51771: PUSH
51772: LD_INT 1
51774: PUSH
51775: LD_INT 2
51777: PUSH
51778: LD_INT 3
51780: PUSH
51781: LD_INT 4
51783: PUSH
51784: LD_INT 5
51786: PUSH
51787: LD_INT 21
51789: PUSH
51790: LD_INT 23
51792: PUSH
51793: LD_INT 22
51795: PUSH
51796: LD_INT 24
51798: PUSH
51799: EMPTY
51800: LIST
51801: LIST
51802: LIST
51803: LIST
51804: LIST
51805: LIST
51806: LIST
51807: LIST
51808: LIST
51809: LIST
51810: LIST
51811: LIST
51812: LIST
51813: ST_TO_ADDR
51814: GO 51875
51816: LD_INT 3
51818: DOUBLE
51819: EQUAL
51820: IFTRUE 51824
51822: GO 51874
51824: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51825: LD_ADDR_VAR 0 3
51829: PUSH
51830: LD_INT 13
51832: PUSH
51833: LD_INT 14
51835: PUSH
51836: LD_INT 2
51838: PUSH
51839: LD_INT 3
51841: PUSH
51842: LD_INT 4
51844: PUSH
51845: LD_INT 5
51847: PUSH
51848: LD_INT 21
51850: PUSH
51851: LD_INT 22
51853: PUSH
51854: LD_INT 23
51856: PUSH
51857: LD_INT 24
51859: PUSH
51860: EMPTY
51861: LIST
51862: LIST
51863: LIST
51864: LIST
51865: LIST
51866: LIST
51867: LIST
51868: LIST
51869: LIST
51870: LIST
51871: ST_TO_ADDR
51872: GO 51875
51874: POP
// result := ( chassis in result ) ;
51875: LD_ADDR_VAR 0 3
51879: PUSH
51880: LD_VAR 0 1
51884: PUSH
51885: LD_VAR 0 3
51889: IN
51890: ST_TO_ADDR
// end ;
51891: LD_VAR 0 3
51895: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
51896: LD_INT 0
51898: PPUSH
// if not chassis or not weapon then
51899: LD_VAR 0 1
51903: NOT
51904: PUSH
51905: LD_VAR 0 2
51909: NOT
51910: OR
51911: IFFALSE 51915
// exit ;
51913: GO 52977
// case weapon of us_machine_gun :
51915: LD_VAR 0 2
51919: PUSH
51920: LD_INT 2
51922: DOUBLE
51923: EQUAL
51924: IFTRUE 51928
51926: GO 51958
51928: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
51929: LD_ADDR_VAR 0 3
51933: PUSH
51934: LD_INT 1
51936: PUSH
51937: LD_INT 2
51939: PUSH
51940: LD_INT 3
51942: PUSH
51943: LD_INT 4
51945: PUSH
51946: LD_INT 5
51948: PUSH
51949: EMPTY
51950: LIST
51951: LIST
51952: LIST
51953: LIST
51954: LIST
51955: ST_TO_ADDR
51956: GO 52961
51958: LD_INT 3
51960: DOUBLE
51961: EQUAL
51962: IFTRUE 51966
51964: GO 51996
51966: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
51967: LD_ADDR_VAR 0 3
51971: PUSH
51972: LD_INT 1
51974: PUSH
51975: LD_INT 2
51977: PUSH
51978: LD_INT 3
51980: PUSH
51981: LD_INT 4
51983: PUSH
51984: LD_INT 5
51986: PUSH
51987: EMPTY
51988: LIST
51989: LIST
51990: LIST
51991: LIST
51992: LIST
51993: ST_TO_ADDR
51994: GO 52961
51996: LD_INT 11
51998: DOUBLE
51999: EQUAL
52000: IFTRUE 52004
52002: GO 52034
52004: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52005: LD_ADDR_VAR 0 3
52009: PUSH
52010: LD_INT 1
52012: PUSH
52013: LD_INT 2
52015: PUSH
52016: LD_INT 3
52018: PUSH
52019: LD_INT 4
52021: PUSH
52022: LD_INT 5
52024: PUSH
52025: EMPTY
52026: LIST
52027: LIST
52028: LIST
52029: LIST
52030: LIST
52031: ST_TO_ADDR
52032: GO 52961
52034: LD_INT 4
52036: DOUBLE
52037: EQUAL
52038: IFTRUE 52042
52040: GO 52068
52042: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52043: LD_ADDR_VAR 0 3
52047: PUSH
52048: LD_INT 2
52050: PUSH
52051: LD_INT 3
52053: PUSH
52054: LD_INT 4
52056: PUSH
52057: LD_INT 5
52059: PUSH
52060: EMPTY
52061: LIST
52062: LIST
52063: LIST
52064: LIST
52065: ST_TO_ADDR
52066: GO 52961
52068: LD_INT 5
52070: DOUBLE
52071: EQUAL
52072: IFTRUE 52076
52074: GO 52102
52076: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52077: LD_ADDR_VAR 0 3
52081: PUSH
52082: LD_INT 2
52084: PUSH
52085: LD_INT 3
52087: PUSH
52088: LD_INT 4
52090: PUSH
52091: LD_INT 5
52093: PUSH
52094: EMPTY
52095: LIST
52096: LIST
52097: LIST
52098: LIST
52099: ST_TO_ADDR
52100: GO 52961
52102: LD_INT 9
52104: DOUBLE
52105: EQUAL
52106: IFTRUE 52110
52108: GO 52136
52110: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52111: LD_ADDR_VAR 0 3
52115: PUSH
52116: LD_INT 2
52118: PUSH
52119: LD_INT 3
52121: PUSH
52122: LD_INT 4
52124: PUSH
52125: LD_INT 5
52127: PUSH
52128: EMPTY
52129: LIST
52130: LIST
52131: LIST
52132: LIST
52133: ST_TO_ADDR
52134: GO 52961
52136: LD_INT 7
52138: DOUBLE
52139: EQUAL
52140: IFTRUE 52144
52142: GO 52170
52144: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52145: LD_ADDR_VAR 0 3
52149: PUSH
52150: LD_INT 2
52152: PUSH
52153: LD_INT 3
52155: PUSH
52156: LD_INT 4
52158: PUSH
52159: LD_INT 5
52161: PUSH
52162: EMPTY
52163: LIST
52164: LIST
52165: LIST
52166: LIST
52167: ST_TO_ADDR
52168: GO 52961
52170: LD_INT 12
52172: DOUBLE
52173: EQUAL
52174: IFTRUE 52178
52176: GO 52204
52178: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52179: LD_ADDR_VAR 0 3
52183: PUSH
52184: LD_INT 2
52186: PUSH
52187: LD_INT 3
52189: PUSH
52190: LD_INT 4
52192: PUSH
52193: LD_INT 5
52195: PUSH
52196: EMPTY
52197: LIST
52198: LIST
52199: LIST
52200: LIST
52201: ST_TO_ADDR
52202: GO 52961
52204: LD_INT 13
52206: DOUBLE
52207: EQUAL
52208: IFTRUE 52212
52210: GO 52238
52212: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52213: LD_ADDR_VAR 0 3
52217: PUSH
52218: LD_INT 2
52220: PUSH
52221: LD_INT 3
52223: PUSH
52224: LD_INT 4
52226: PUSH
52227: LD_INT 5
52229: PUSH
52230: EMPTY
52231: LIST
52232: LIST
52233: LIST
52234: LIST
52235: ST_TO_ADDR
52236: GO 52961
52238: LD_INT 14
52240: DOUBLE
52241: EQUAL
52242: IFTRUE 52246
52244: GO 52264
52246: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52247: LD_ADDR_VAR 0 3
52251: PUSH
52252: LD_INT 4
52254: PUSH
52255: LD_INT 5
52257: PUSH
52258: EMPTY
52259: LIST
52260: LIST
52261: ST_TO_ADDR
52262: GO 52961
52264: LD_INT 6
52266: DOUBLE
52267: EQUAL
52268: IFTRUE 52272
52270: GO 52290
52272: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52273: LD_ADDR_VAR 0 3
52277: PUSH
52278: LD_INT 4
52280: PUSH
52281: LD_INT 5
52283: PUSH
52284: EMPTY
52285: LIST
52286: LIST
52287: ST_TO_ADDR
52288: GO 52961
52290: LD_INT 10
52292: DOUBLE
52293: EQUAL
52294: IFTRUE 52298
52296: GO 52316
52298: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52299: LD_ADDR_VAR 0 3
52303: PUSH
52304: LD_INT 4
52306: PUSH
52307: LD_INT 5
52309: PUSH
52310: EMPTY
52311: LIST
52312: LIST
52313: ST_TO_ADDR
52314: GO 52961
52316: LD_INT 22
52318: DOUBLE
52319: EQUAL
52320: IFTRUE 52324
52322: GO 52350
52324: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52325: LD_ADDR_VAR 0 3
52329: PUSH
52330: LD_INT 11
52332: PUSH
52333: LD_INT 12
52335: PUSH
52336: LD_INT 13
52338: PUSH
52339: LD_INT 14
52341: PUSH
52342: EMPTY
52343: LIST
52344: LIST
52345: LIST
52346: LIST
52347: ST_TO_ADDR
52348: GO 52961
52350: LD_INT 23
52352: DOUBLE
52353: EQUAL
52354: IFTRUE 52358
52356: GO 52384
52358: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52359: LD_ADDR_VAR 0 3
52363: PUSH
52364: LD_INT 11
52366: PUSH
52367: LD_INT 12
52369: PUSH
52370: LD_INT 13
52372: PUSH
52373: LD_INT 14
52375: PUSH
52376: EMPTY
52377: LIST
52378: LIST
52379: LIST
52380: LIST
52381: ST_TO_ADDR
52382: GO 52961
52384: LD_INT 24
52386: DOUBLE
52387: EQUAL
52388: IFTRUE 52392
52390: GO 52418
52392: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52393: LD_ADDR_VAR 0 3
52397: PUSH
52398: LD_INT 11
52400: PUSH
52401: LD_INT 12
52403: PUSH
52404: LD_INT 13
52406: PUSH
52407: LD_INT 14
52409: PUSH
52410: EMPTY
52411: LIST
52412: LIST
52413: LIST
52414: LIST
52415: ST_TO_ADDR
52416: GO 52961
52418: LD_INT 30
52420: DOUBLE
52421: EQUAL
52422: IFTRUE 52426
52424: GO 52452
52426: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52427: LD_ADDR_VAR 0 3
52431: PUSH
52432: LD_INT 11
52434: PUSH
52435: LD_INT 12
52437: PUSH
52438: LD_INT 13
52440: PUSH
52441: LD_INT 14
52443: PUSH
52444: EMPTY
52445: LIST
52446: LIST
52447: LIST
52448: LIST
52449: ST_TO_ADDR
52450: GO 52961
52452: LD_INT 25
52454: DOUBLE
52455: EQUAL
52456: IFTRUE 52460
52458: GO 52478
52460: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52461: LD_ADDR_VAR 0 3
52465: PUSH
52466: LD_INT 13
52468: PUSH
52469: LD_INT 14
52471: PUSH
52472: EMPTY
52473: LIST
52474: LIST
52475: ST_TO_ADDR
52476: GO 52961
52478: LD_INT 27
52480: DOUBLE
52481: EQUAL
52482: IFTRUE 52486
52484: GO 52504
52486: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52487: LD_ADDR_VAR 0 3
52491: PUSH
52492: LD_INT 13
52494: PUSH
52495: LD_INT 14
52497: PUSH
52498: EMPTY
52499: LIST
52500: LIST
52501: ST_TO_ADDR
52502: GO 52961
52504: LD_EXP 99
52508: DOUBLE
52509: EQUAL
52510: IFTRUE 52514
52512: GO 52540
52514: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52515: LD_ADDR_VAR 0 3
52519: PUSH
52520: LD_INT 11
52522: PUSH
52523: LD_INT 12
52525: PUSH
52526: LD_INT 13
52528: PUSH
52529: LD_INT 14
52531: PUSH
52532: EMPTY
52533: LIST
52534: LIST
52535: LIST
52536: LIST
52537: ST_TO_ADDR
52538: GO 52961
52540: LD_INT 28
52542: DOUBLE
52543: EQUAL
52544: IFTRUE 52548
52546: GO 52566
52548: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52549: LD_ADDR_VAR 0 3
52553: PUSH
52554: LD_INT 13
52556: PUSH
52557: LD_INT 14
52559: PUSH
52560: EMPTY
52561: LIST
52562: LIST
52563: ST_TO_ADDR
52564: GO 52961
52566: LD_INT 29
52568: DOUBLE
52569: EQUAL
52570: IFTRUE 52574
52572: GO 52592
52574: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52575: LD_ADDR_VAR 0 3
52579: PUSH
52580: LD_INT 13
52582: PUSH
52583: LD_INT 14
52585: PUSH
52586: EMPTY
52587: LIST
52588: LIST
52589: ST_TO_ADDR
52590: GO 52961
52592: LD_INT 31
52594: DOUBLE
52595: EQUAL
52596: IFTRUE 52600
52598: GO 52618
52600: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52601: LD_ADDR_VAR 0 3
52605: PUSH
52606: LD_INT 13
52608: PUSH
52609: LD_INT 14
52611: PUSH
52612: EMPTY
52613: LIST
52614: LIST
52615: ST_TO_ADDR
52616: GO 52961
52618: LD_INT 26
52620: DOUBLE
52621: EQUAL
52622: IFTRUE 52626
52624: GO 52644
52626: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52627: LD_ADDR_VAR 0 3
52631: PUSH
52632: LD_INT 13
52634: PUSH
52635: LD_INT 14
52637: PUSH
52638: EMPTY
52639: LIST
52640: LIST
52641: ST_TO_ADDR
52642: GO 52961
52644: LD_INT 42
52646: DOUBLE
52647: EQUAL
52648: IFTRUE 52652
52650: GO 52678
52652: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52653: LD_ADDR_VAR 0 3
52657: PUSH
52658: LD_INT 21
52660: PUSH
52661: LD_INT 22
52663: PUSH
52664: LD_INT 23
52666: PUSH
52667: LD_INT 24
52669: PUSH
52670: EMPTY
52671: LIST
52672: LIST
52673: LIST
52674: LIST
52675: ST_TO_ADDR
52676: GO 52961
52678: LD_INT 43
52680: DOUBLE
52681: EQUAL
52682: IFTRUE 52686
52684: GO 52712
52686: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52687: LD_ADDR_VAR 0 3
52691: PUSH
52692: LD_INT 21
52694: PUSH
52695: LD_INT 22
52697: PUSH
52698: LD_INT 23
52700: PUSH
52701: LD_INT 24
52703: PUSH
52704: EMPTY
52705: LIST
52706: LIST
52707: LIST
52708: LIST
52709: ST_TO_ADDR
52710: GO 52961
52712: LD_INT 44
52714: DOUBLE
52715: EQUAL
52716: IFTRUE 52720
52718: GO 52746
52720: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52721: LD_ADDR_VAR 0 3
52725: PUSH
52726: LD_INT 21
52728: PUSH
52729: LD_INT 22
52731: PUSH
52732: LD_INT 23
52734: PUSH
52735: LD_INT 24
52737: PUSH
52738: EMPTY
52739: LIST
52740: LIST
52741: LIST
52742: LIST
52743: ST_TO_ADDR
52744: GO 52961
52746: LD_INT 45
52748: DOUBLE
52749: EQUAL
52750: IFTRUE 52754
52752: GO 52780
52754: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52755: LD_ADDR_VAR 0 3
52759: PUSH
52760: LD_INT 21
52762: PUSH
52763: LD_INT 22
52765: PUSH
52766: LD_INT 23
52768: PUSH
52769: LD_INT 24
52771: PUSH
52772: EMPTY
52773: LIST
52774: LIST
52775: LIST
52776: LIST
52777: ST_TO_ADDR
52778: GO 52961
52780: LD_INT 49
52782: DOUBLE
52783: EQUAL
52784: IFTRUE 52788
52786: GO 52814
52788: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52789: LD_ADDR_VAR 0 3
52793: PUSH
52794: LD_INT 21
52796: PUSH
52797: LD_INT 22
52799: PUSH
52800: LD_INT 23
52802: PUSH
52803: LD_INT 24
52805: PUSH
52806: EMPTY
52807: LIST
52808: LIST
52809: LIST
52810: LIST
52811: ST_TO_ADDR
52812: GO 52961
52814: LD_INT 51
52816: DOUBLE
52817: EQUAL
52818: IFTRUE 52822
52820: GO 52848
52822: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52823: LD_ADDR_VAR 0 3
52827: PUSH
52828: LD_INT 21
52830: PUSH
52831: LD_INT 22
52833: PUSH
52834: LD_INT 23
52836: PUSH
52837: LD_INT 24
52839: PUSH
52840: EMPTY
52841: LIST
52842: LIST
52843: LIST
52844: LIST
52845: ST_TO_ADDR
52846: GO 52961
52848: LD_INT 52
52850: DOUBLE
52851: EQUAL
52852: IFTRUE 52856
52854: GO 52882
52856: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
52857: LD_ADDR_VAR 0 3
52861: PUSH
52862: LD_INT 21
52864: PUSH
52865: LD_INT 22
52867: PUSH
52868: LD_INT 23
52870: PUSH
52871: LD_INT 24
52873: PUSH
52874: EMPTY
52875: LIST
52876: LIST
52877: LIST
52878: LIST
52879: ST_TO_ADDR
52880: GO 52961
52882: LD_INT 53
52884: DOUBLE
52885: EQUAL
52886: IFTRUE 52890
52888: GO 52908
52890: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
52891: LD_ADDR_VAR 0 3
52895: PUSH
52896: LD_INT 23
52898: PUSH
52899: LD_INT 24
52901: PUSH
52902: EMPTY
52903: LIST
52904: LIST
52905: ST_TO_ADDR
52906: GO 52961
52908: LD_INT 46
52910: DOUBLE
52911: EQUAL
52912: IFTRUE 52916
52914: GO 52934
52916: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
52917: LD_ADDR_VAR 0 3
52921: PUSH
52922: LD_INT 23
52924: PUSH
52925: LD_INT 24
52927: PUSH
52928: EMPTY
52929: LIST
52930: LIST
52931: ST_TO_ADDR
52932: GO 52961
52934: LD_INT 47
52936: DOUBLE
52937: EQUAL
52938: IFTRUE 52942
52940: GO 52960
52942: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52943: LD_ADDR_VAR 0 3
52947: PUSH
52948: LD_INT 23
52950: PUSH
52951: LD_INT 24
52953: PUSH
52954: EMPTY
52955: LIST
52956: LIST
52957: ST_TO_ADDR
52958: GO 52961
52960: POP
// result := ( chassis in result ) ;
52961: LD_ADDR_VAR 0 3
52965: PUSH
52966: LD_VAR 0 1
52970: PUSH
52971: LD_VAR 0 3
52975: IN
52976: ST_TO_ADDR
// end ;
52977: LD_VAR 0 3
52981: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
52982: LD_INT 0
52984: PPUSH
52985: PPUSH
52986: PPUSH
52987: PPUSH
52988: PPUSH
52989: PPUSH
52990: PPUSH
// result := array ;
52991: LD_ADDR_VAR 0 5
52995: PUSH
52996: LD_VAR 0 1
53000: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53001: LD_VAR 0 1
53005: NOT
53006: PUSH
53007: LD_VAR 0 2
53011: NOT
53012: OR
53013: PUSH
53014: LD_VAR 0 3
53018: NOT
53019: OR
53020: PUSH
53021: LD_VAR 0 2
53025: PUSH
53026: LD_VAR 0 1
53030: GREATER
53031: OR
53032: PUSH
53033: LD_VAR 0 3
53037: PUSH
53038: LD_VAR 0 1
53042: GREATER
53043: OR
53044: IFFALSE 53048
// exit ;
53046: GO 53344
// if direction then
53048: LD_VAR 0 4
53052: IFFALSE 53116
// begin d := 1 ;
53054: LD_ADDR_VAR 0 9
53058: PUSH
53059: LD_INT 1
53061: ST_TO_ADDR
// if i_from > i_to then
53062: LD_VAR 0 2
53066: PUSH
53067: LD_VAR 0 3
53071: GREATER
53072: IFFALSE 53098
// length := ( array - i_from ) + i_to else
53074: LD_ADDR_VAR 0 11
53078: PUSH
53079: LD_VAR 0 1
53083: PUSH
53084: LD_VAR 0 2
53088: MINUS
53089: PUSH
53090: LD_VAR 0 3
53094: PLUS
53095: ST_TO_ADDR
53096: GO 53114
// length := i_to - i_from ;
53098: LD_ADDR_VAR 0 11
53102: PUSH
53103: LD_VAR 0 3
53107: PUSH
53108: LD_VAR 0 2
53112: MINUS
53113: ST_TO_ADDR
// end else
53114: GO 53177
// begin d := - 1 ;
53116: LD_ADDR_VAR 0 9
53120: PUSH
53121: LD_INT 1
53123: NEG
53124: ST_TO_ADDR
// if i_from > i_to then
53125: LD_VAR 0 2
53129: PUSH
53130: LD_VAR 0 3
53134: GREATER
53135: IFFALSE 53155
// length := i_from - i_to else
53137: LD_ADDR_VAR 0 11
53141: PUSH
53142: LD_VAR 0 2
53146: PUSH
53147: LD_VAR 0 3
53151: MINUS
53152: ST_TO_ADDR
53153: GO 53177
// length := ( array - i_to ) + i_from ;
53155: LD_ADDR_VAR 0 11
53159: PUSH
53160: LD_VAR 0 1
53164: PUSH
53165: LD_VAR 0 3
53169: MINUS
53170: PUSH
53171: LD_VAR 0 2
53175: PLUS
53176: ST_TO_ADDR
// end ; if not length then
53177: LD_VAR 0 11
53181: NOT
53182: IFFALSE 53186
// exit ;
53184: GO 53344
// tmp := array ;
53186: LD_ADDR_VAR 0 10
53190: PUSH
53191: LD_VAR 0 1
53195: ST_TO_ADDR
// for i = 1 to length do
53196: LD_ADDR_VAR 0 6
53200: PUSH
53201: DOUBLE
53202: LD_INT 1
53204: DEC
53205: ST_TO_ADDR
53206: LD_VAR 0 11
53210: PUSH
53211: FOR_TO
53212: IFFALSE 53332
// begin for j = 1 to array do
53214: LD_ADDR_VAR 0 7
53218: PUSH
53219: DOUBLE
53220: LD_INT 1
53222: DEC
53223: ST_TO_ADDR
53224: LD_VAR 0 1
53228: PUSH
53229: FOR_TO
53230: IFFALSE 53318
// begin k := j + d ;
53232: LD_ADDR_VAR 0 8
53236: PUSH
53237: LD_VAR 0 7
53241: PUSH
53242: LD_VAR 0 9
53246: PLUS
53247: ST_TO_ADDR
// if k > array then
53248: LD_VAR 0 8
53252: PUSH
53253: LD_VAR 0 1
53257: GREATER
53258: IFFALSE 53268
// k := 1 ;
53260: LD_ADDR_VAR 0 8
53264: PUSH
53265: LD_INT 1
53267: ST_TO_ADDR
// if not k then
53268: LD_VAR 0 8
53272: NOT
53273: IFFALSE 53285
// k := array ;
53275: LD_ADDR_VAR 0 8
53279: PUSH
53280: LD_VAR 0 1
53284: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53285: LD_ADDR_VAR 0 10
53289: PUSH
53290: LD_VAR 0 10
53294: PPUSH
53295: LD_VAR 0 8
53299: PPUSH
53300: LD_VAR 0 1
53304: PUSH
53305: LD_VAR 0 7
53309: ARRAY
53310: PPUSH
53311: CALL_OW 1
53315: ST_TO_ADDR
// end ;
53316: GO 53229
53318: POP
53319: POP
// array := tmp ;
53320: LD_ADDR_VAR 0 1
53324: PUSH
53325: LD_VAR 0 10
53329: ST_TO_ADDR
// end ;
53330: GO 53211
53332: POP
53333: POP
// result := array ;
53334: LD_ADDR_VAR 0 5
53338: PUSH
53339: LD_VAR 0 1
53343: ST_TO_ADDR
// end ;
53344: LD_VAR 0 5
53348: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53349: LD_INT 0
53351: PPUSH
53352: PPUSH
// result := 0 ;
53353: LD_ADDR_VAR 0 3
53357: PUSH
53358: LD_INT 0
53360: ST_TO_ADDR
// if not array or not value in array then
53361: LD_VAR 0 1
53365: NOT
53366: PUSH
53367: LD_VAR 0 2
53371: PUSH
53372: LD_VAR 0 1
53376: IN
53377: NOT
53378: OR
53379: IFFALSE 53383
// exit ;
53381: GO 53437
// for i = 1 to array do
53383: LD_ADDR_VAR 0 4
53387: PUSH
53388: DOUBLE
53389: LD_INT 1
53391: DEC
53392: ST_TO_ADDR
53393: LD_VAR 0 1
53397: PUSH
53398: FOR_TO
53399: IFFALSE 53435
// if value = array [ i ] then
53401: LD_VAR 0 2
53405: PUSH
53406: LD_VAR 0 1
53410: PUSH
53411: LD_VAR 0 4
53415: ARRAY
53416: EQUAL
53417: IFFALSE 53433
// begin result := i ;
53419: LD_ADDR_VAR 0 3
53423: PUSH
53424: LD_VAR 0 4
53428: ST_TO_ADDR
// exit ;
53429: POP
53430: POP
53431: GO 53437
// end ;
53433: GO 53398
53435: POP
53436: POP
// end ;
53437: LD_VAR 0 3
53441: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53442: LD_INT 0
53444: PPUSH
// vc_chassis := chassis ;
53445: LD_ADDR_OWVAR 37
53449: PUSH
53450: LD_VAR 0 1
53454: ST_TO_ADDR
// vc_engine := engine ;
53455: LD_ADDR_OWVAR 39
53459: PUSH
53460: LD_VAR 0 2
53464: ST_TO_ADDR
// vc_control := control ;
53465: LD_ADDR_OWVAR 38
53469: PUSH
53470: LD_VAR 0 3
53474: ST_TO_ADDR
// vc_weapon := weapon ;
53475: LD_ADDR_OWVAR 40
53479: PUSH
53480: LD_VAR 0 4
53484: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53485: LD_ADDR_OWVAR 41
53489: PUSH
53490: LD_VAR 0 5
53494: ST_TO_ADDR
// end ;
53495: LD_VAR 0 6
53499: RET
// export function WantPlant ( unit ) ; var task ; begin
53500: LD_INT 0
53502: PPUSH
53503: PPUSH
// result := false ;
53504: LD_ADDR_VAR 0 2
53508: PUSH
53509: LD_INT 0
53511: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53512: LD_ADDR_VAR 0 3
53516: PUSH
53517: LD_VAR 0 1
53521: PPUSH
53522: CALL_OW 437
53526: ST_TO_ADDR
// if task then
53527: LD_VAR 0 3
53531: IFFALSE 53559
// if task [ 1 ] [ 1 ] = p then
53533: LD_VAR 0 3
53537: PUSH
53538: LD_INT 1
53540: ARRAY
53541: PUSH
53542: LD_INT 1
53544: ARRAY
53545: PUSH
53546: LD_STRING p
53548: EQUAL
53549: IFFALSE 53559
// result := true ;
53551: LD_ADDR_VAR 0 2
53555: PUSH
53556: LD_INT 1
53558: ST_TO_ADDR
// end ;
53559: LD_VAR 0 2
53563: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53564: LD_INT 0
53566: PPUSH
53567: PPUSH
53568: PPUSH
53569: PPUSH
// if pos < 1 then
53570: LD_VAR 0 2
53574: PUSH
53575: LD_INT 1
53577: LESS
53578: IFFALSE 53582
// exit ;
53580: GO 53885
// if pos = 1 then
53582: LD_VAR 0 2
53586: PUSH
53587: LD_INT 1
53589: EQUAL
53590: IFFALSE 53623
// result := Replace ( arr , pos [ 1 ] , value ) else
53592: LD_ADDR_VAR 0 4
53596: PUSH
53597: LD_VAR 0 1
53601: PPUSH
53602: LD_VAR 0 2
53606: PUSH
53607: LD_INT 1
53609: ARRAY
53610: PPUSH
53611: LD_VAR 0 3
53615: PPUSH
53616: CALL_OW 1
53620: ST_TO_ADDR
53621: GO 53885
// begin tmp := arr ;
53623: LD_ADDR_VAR 0 6
53627: PUSH
53628: LD_VAR 0 1
53632: ST_TO_ADDR
// s_arr := [ tmp ] ;
53633: LD_ADDR_VAR 0 7
53637: PUSH
53638: LD_VAR 0 6
53642: PUSH
53643: EMPTY
53644: LIST
53645: ST_TO_ADDR
// for i = 1 to pos - 1 do
53646: LD_ADDR_VAR 0 5
53650: PUSH
53651: DOUBLE
53652: LD_INT 1
53654: DEC
53655: ST_TO_ADDR
53656: LD_VAR 0 2
53660: PUSH
53661: LD_INT 1
53663: MINUS
53664: PUSH
53665: FOR_TO
53666: IFFALSE 53711
// begin tmp := tmp [ pos [ i ] ] ;
53668: LD_ADDR_VAR 0 6
53672: PUSH
53673: LD_VAR 0 6
53677: PUSH
53678: LD_VAR 0 2
53682: PUSH
53683: LD_VAR 0 5
53687: ARRAY
53688: ARRAY
53689: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53690: LD_ADDR_VAR 0 7
53694: PUSH
53695: LD_VAR 0 7
53699: PUSH
53700: LD_VAR 0 6
53704: PUSH
53705: EMPTY
53706: LIST
53707: ADD
53708: ST_TO_ADDR
// end ;
53709: GO 53665
53711: POP
53712: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53713: LD_ADDR_VAR 0 6
53717: PUSH
53718: LD_VAR 0 6
53722: PPUSH
53723: LD_VAR 0 2
53727: PUSH
53728: LD_VAR 0 2
53732: ARRAY
53733: PPUSH
53734: LD_VAR 0 3
53738: PPUSH
53739: CALL_OW 1
53743: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53744: LD_ADDR_VAR 0 7
53748: PUSH
53749: LD_VAR 0 7
53753: PPUSH
53754: LD_VAR 0 7
53758: PPUSH
53759: LD_VAR 0 6
53763: PPUSH
53764: CALL_OW 1
53768: ST_TO_ADDR
// for i = s_arr downto 2 do
53769: LD_ADDR_VAR 0 5
53773: PUSH
53774: DOUBLE
53775: LD_VAR 0 7
53779: INC
53780: ST_TO_ADDR
53781: LD_INT 2
53783: PUSH
53784: FOR_DOWNTO
53785: IFFALSE 53869
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53787: LD_ADDR_VAR 0 6
53791: PUSH
53792: LD_VAR 0 7
53796: PUSH
53797: LD_VAR 0 5
53801: PUSH
53802: LD_INT 1
53804: MINUS
53805: ARRAY
53806: PPUSH
53807: LD_VAR 0 2
53811: PUSH
53812: LD_VAR 0 5
53816: PUSH
53817: LD_INT 1
53819: MINUS
53820: ARRAY
53821: PPUSH
53822: LD_VAR 0 7
53826: PUSH
53827: LD_VAR 0 5
53831: ARRAY
53832: PPUSH
53833: CALL_OW 1
53837: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53838: LD_ADDR_VAR 0 7
53842: PUSH
53843: LD_VAR 0 7
53847: PPUSH
53848: LD_VAR 0 5
53852: PUSH
53853: LD_INT 1
53855: MINUS
53856: PPUSH
53857: LD_VAR 0 6
53861: PPUSH
53862: CALL_OW 1
53866: ST_TO_ADDR
// end ;
53867: GO 53784
53869: POP
53870: POP
// result := s_arr [ 1 ] ;
53871: LD_ADDR_VAR 0 4
53875: PUSH
53876: LD_VAR 0 7
53880: PUSH
53881: LD_INT 1
53883: ARRAY
53884: ST_TO_ADDR
// end ; end ;
53885: LD_VAR 0 4
53889: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
53890: LD_INT 0
53892: PPUSH
53893: PPUSH
// if not list then
53894: LD_VAR 0 1
53898: NOT
53899: IFFALSE 53903
// exit ;
53901: GO 53994
// i := list [ pos1 ] ;
53903: LD_ADDR_VAR 0 5
53907: PUSH
53908: LD_VAR 0 1
53912: PUSH
53913: LD_VAR 0 2
53917: ARRAY
53918: ST_TO_ADDR
// if not i then
53919: LD_VAR 0 5
53923: NOT
53924: IFFALSE 53928
// exit ;
53926: GO 53994
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
53928: LD_ADDR_VAR 0 1
53932: PUSH
53933: LD_VAR 0 1
53937: PPUSH
53938: LD_VAR 0 2
53942: PPUSH
53943: LD_VAR 0 1
53947: PUSH
53948: LD_VAR 0 3
53952: ARRAY
53953: PPUSH
53954: CALL_OW 1
53958: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
53959: LD_ADDR_VAR 0 1
53963: PUSH
53964: LD_VAR 0 1
53968: PPUSH
53969: LD_VAR 0 3
53973: PPUSH
53974: LD_VAR 0 5
53978: PPUSH
53979: CALL_OW 1
53983: ST_TO_ADDR
// result := list ;
53984: LD_ADDR_VAR 0 4
53988: PUSH
53989: LD_VAR 0 1
53993: ST_TO_ADDR
// end ;
53994: LD_VAR 0 4
53998: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
53999: LD_INT 0
54001: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54002: LD_ADDR_VAR 0 5
54006: PUSH
54007: LD_VAR 0 1
54011: PPUSH
54012: CALL_OW 250
54016: PPUSH
54017: LD_VAR 0 1
54021: PPUSH
54022: CALL_OW 251
54026: PPUSH
54027: LD_VAR 0 2
54031: PPUSH
54032: LD_VAR 0 3
54036: PPUSH
54037: LD_VAR 0 4
54041: PPUSH
54042: CALL 54052 0 5
54046: ST_TO_ADDR
// end ;
54047: LD_VAR 0 5
54051: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54052: LD_INT 0
54054: PPUSH
54055: PPUSH
54056: PPUSH
54057: PPUSH
// if not list then
54058: LD_VAR 0 3
54062: NOT
54063: IFFALSE 54067
// exit ;
54065: GO 54455
// result := [ ] ;
54067: LD_ADDR_VAR 0 6
54071: PUSH
54072: EMPTY
54073: ST_TO_ADDR
// for i in list do
54074: LD_ADDR_VAR 0 7
54078: PUSH
54079: LD_VAR 0 3
54083: PUSH
54084: FOR_IN
54085: IFFALSE 54287
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54087: LD_ADDR_VAR 0 9
54091: PUSH
54092: LD_VAR 0 7
54096: PPUSH
54097: LD_VAR 0 1
54101: PPUSH
54102: LD_VAR 0 2
54106: PPUSH
54107: CALL_OW 297
54111: ST_TO_ADDR
// if not result then
54112: LD_VAR 0 6
54116: NOT
54117: IFFALSE 54143
// result := [ [ i , tmp ] ] else
54119: LD_ADDR_VAR 0 6
54123: PUSH
54124: LD_VAR 0 7
54128: PUSH
54129: LD_VAR 0 9
54133: PUSH
54134: EMPTY
54135: LIST
54136: LIST
54137: PUSH
54138: EMPTY
54139: LIST
54140: ST_TO_ADDR
54141: GO 54285
// begin if result [ result ] [ 2 ] < tmp then
54143: LD_VAR 0 6
54147: PUSH
54148: LD_VAR 0 6
54152: ARRAY
54153: PUSH
54154: LD_INT 2
54156: ARRAY
54157: PUSH
54158: LD_VAR 0 9
54162: LESS
54163: IFFALSE 54205
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54165: LD_ADDR_VAR 0 6
54169: PUSH
54170: LD_VAR 0 6
54174: PPUSH
54175: LD_VAR 0 6
54179: PUSH
54180: LD_INT 1
54182: PLUS
54183: PPUSH
54184: LD_VAR 0 7
54188: PUSH
54189: LD_VAR 0 9
54193: PUSH
54194: EMPTY
54195: LIST
54196: LIST
54197: PPUSH
54198: CALL_OW 2
54202: ST_TO_ADDR
54203: GO 54285
// for j = 1 to result do
54205: LD_ADDR_VAR 0 8
54209: PUSH
54210: DOUBLE
54211: LD_INT 1
54213: DEC
54214: ST_TO_ADDR
54215: LD_VAR 0 6
54219: PUSH
54220: FOR_TO
54221: IFFALSE 54283
// begin if tmp < result [ j ] [ 2 ] then
54223: LD_VAR 0 9
54227: PUSH
54228: LD_VAR 0 6
54232: PUSH
54233: LD_VAR 0 8
54237: ARRAY
54238: PUSH
54239: LD_INT 2
54241: ARRAY
54242: LESS
54243: IFFALSE 54281
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54245: LD_ADDR_VAR 0 6
54249: PUSH
54250: LD_VAR 0 6
54254: PPUSH
54255: LD_VAR 0 8
54259: PPUSH
54260: LD_VAR 0 7
54264: PUSH
54265: LD_VAR 0 9
54269: PUSH
54270: EMPTY
54271: LIST
54272: LIST
54273: PPUSH
54274: CALL_OW 2
54278: ST_TO_ADDR
// break ;
54279: GO 54283
// end ; end ;
54281: GO 54220
54283: POP
54284: POP
// end ; end ;
54285: GO 54084
54287: POP
54288: POP
// if result and not asc then
54289: LD_VAR 0 6
54293: PUSH
54294: LD_VAR 0 4
54298: NOT
54299: AND
54300: IFFALSE 54375
// begin tmp := result ;
54302: LD_ADDR_VAR 0 9
54306: PUSH
54307: LD_VAR 0 6
54311: ST_TO_ADDR
// for i = tmp downto 1 do
54312: LD_ADDR_VAR 0 7
54316: PUSH
54317: DOUBLE
54318: LD_VAR 0 9
54322: INC
54323: ST_TO_ADDR
54324: LD_INT 1
54326: PUSH
54327: FOR_DOWNTO
54328: IFFALSE 54373
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54330: LD_ADDR_VAR 0 6
54334: PUSH
54335: LD_VAR 0 6
54339: PPUSH
54340: LD_VAR 0 9
54344: PUSH
54345: LD_VAR 0 7
54349: MINUS
54350: PUSH
54351: LD_INT 1
54353: PLUS
54354: PPUSH
54355: LD_VAR 0 9
54359: PUSH
54360: LD_VAR 0 7
54364: ARRAY
54365: PPUSH
54366: CALL_OW 1
54370: ST_TO_ADDR
54371: GO 54327
54373: POP
54374: POP
// end ; tmp := [ ] ;
54375: LD_ADDR_VAR 0 9
54379: PUSH
54380: EMPTY
54381: ST_TO_ADDR
// if mode then
54382: LD_VAR 0 5
54386: IFFALSE 54455
// begin for i = 1 to result do
54388: LD_ADDR_VAR 0 7
54392: PUSH
54393: DOUBLE
54394: LD_INT 1
54396: DEC
54397: ST_TO_ADDR
54398: LD_VAR 0 6
54402: PUSH
54403: FOR_TO
54404: IFFALSE 54443
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54406: LD_ADDR_VAR 0 9
54410: PUSH
54411: LD_VAR 0 9
54415: PPUSH
54416: LD_VAR 0 7
54420: PPUSH
54421: LD_VAR 0 6
54425: PUSH
54426: LD_VAR 0 7
54430: ARRAY
54431: PUSH
54432: LD_INT 1
54434: ARRAY
54435: PPUSH
54436: CALL_OW 1
54440: ST_TO_ADDR
54441: GO 54403
54443: POP
54444: POP
// result := tmp ;
54445: LD_ADDR_VAR 0 6
54449: PUSH
54450: LD_VAR 0 9
54454: ST_TO_ADDR
// end ; end ;
54455: LD_VAR 0 6
54459: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54460: LD_INT 0
54462: PPUSH
54463: PPUSH
54464: PPUSH
54465: PPUSH
54466: PPUSH
54467: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54468: LD_ADDR_VAR 0 5
54472: PUSH
54473: LD_INT 0
54475: PUSH
54476: LD_INT 0
54478: PUSH
54479: LD_INT 0
54481: PUSH
54482: EMPTY
54483: PUSH
54484: EMPTY
54485: LIST
54486: LIST
54487: LIST
54488: LIST
54489: ST_TO_ADDR
// if not x or not y then
54490: LD_VAR 0 2
54494: NOT
54495: PUSH
54496: LD_VAR 0 3
54500: NOT
54501: OR
54502: IFFALSE 54506
// exit ;
54504: GO 56158
// if not range then
54506: LD_VAR 0 4
54510: NOT
54511: IFFALSE 54521
// range := 10 ;
54513: LD_ADDR_VAR 0 4
54517: PUSH
54518: LD_INT 10
54520: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54521: LD_ADDR_VAR 0 8
54525: PUSH
54526: LD_INT 81
54528: PUSH
54529: LD_VAR 0 1
54533: PUSH
54534: EMPTY
54535: LIST
54536: LIST
54537: PUSH
54538: LD_INT 92
54540: PUSH
54541: LD_VAR 0 2
54545: PUSH
54546: LD_VAR 0 3
54550: PUSH
54551: LD_VAR 0 4
54555: PUSH
54556: EMPTY
54557: LIST
54558: LIST
54559: LIST
54560: LIST
54561: PUSH
54562: LD_INT 3
54564: PUSH
54565: LD_INT 21
54567: PUSH
54568: LD_INT 3
54570: PUSH
54571: EMPTY
54572: LIST
54573: LIST
54574: PUSH
54575: EMPTY
54576: LIST
54577: LIST
54578: PUSH
54579: EMPTY
54580: LIST
54581: LIST
54582: LIST
54583: PPUSH
54584: CALL_OW 69
54588: ST_TO_ADDR
// if not tmp then
54589: LD_VAR 0 8
54593: NOT
54594: IFFALSE 54598
// exit ;
54596: GO 56158
// for i in tmp do
54598: LD_ADDR_VAR 0 6
54602: PUSH
54603: LD_VAR 0 8
54607: PUSH
54608: FOR_IN
54609: IFFALSE 56133
// begin points := [ 0 , 0 , 0 ] ;
54611: LD_ADDR_VAR 0 9
54615: PUSH
54616: LD_INT 0
54618: PUSH
54619: LD_INT 0
54621: PUSH
54622: LD_INT 0
54624: PUSH
54625: EMPTY
54626: LIST
54627: LIST
54628: LIST
54629: ST_TO_ADDR
// bpoints := 1 ;
54630: LD_ADDR_VAR 0 10
54634: PUSH
54635: LD_INT 1
54637: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54638: LD_VAR 0 6
54642: PPUSH
54643: CALL_OW 247
54647: PUSH
54648: LD_INT 1
54650: DOUBLE
54651: EQUAL
54652: IFTRUE 54656
54654: GO 55234
54656: POP
// begin if GetClass ( i ) = 1 then
54657: LD_VAR 0 6
54661: PPUSH
54662: CALL_OW 257
54666: PUSH
54667: LD_INT 1
54669: EQUAL
54670: IFFALSE 54691
// points := [ 10 , 5 , 3 ] ;
54672: LD_ADDR_VAR 0 9
54676: PUSH
54677: LD_INT 10
54679: PUSH
54680: LD_INT 5
54682: PUSH
54683: LD_INT 3
54685: PUSH
54686: EMPTY
54687: LIST
54688: LIST
54689: LIST
54690: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54691: LD_VAR 0 6
54695: PPUSH
54696: CALL_OW 257
54700: PUSH
54701: LD_INT 2
54703: PUSH
54704: LD_INT 3
54706: PUSH
54707: LD_INT 4
54709: PUSH
54710: EMPTY
54711: LIST
54712: LIST
54713: LIST
54714: IN
54715: IFFALSE 54736
// points := [ 3 , 2 , 1 ] ;
54717: LD_ADDR_VAR 0 9
54721: PUSH
54722: LD_INT 3
54724: PUSH
54725: LD_INT 2
54727: PUSH
54728: LD_INT 1
54730: PUSH
54731: EMPTY
54732: LIST
54733: LIST
54734: LIST
54735: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54736: LD_VAR 0 6
54740: PPUSH
54741: CALL_OW 257
54745: PUSH
54746: LD_INT 5
54748: EQUAL
54749: IFFALSE 54770
// points := [ 130 , 5 , 2 ] ;
54751: LD_ADDR_VAR 0 9
54755: PUSH
54756: LD_INT 130
54758: PUSH
54759: LD_INT 5
54761: PUSH
54762: LD_INT 2
54764: PUSH
54765: EMPTY
54766: LIST
54767: LIST
54768: LIST
54769: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54770: LD_VAR 0 6
54774: PPUSH
54775: CALL_OW 257
54779: PUSH
54780: LD_INT 8
54782: EQUAL
54783: IFFALSE 54804
// points := [ 35 , 35 , 30 ] ;
54785: LD_ADDR_VAR 0 9
54789: PUSH
54790: LD_INT 35
54792: PUSH
54793: LD_INT 35
54795: PUSH
54796: LD_INT 30
54798: PUSH
54799: EMPTY
54800: LIST
54801: LIST
54802: LIST
54803: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54804: LD_VAR 0 6
54808: PPUSH
54809: CALL_OW 257
54813: PUSH
54814: LD_INT 9
54816: EQUAL
54817: IFFALSE 54838
// points := [ 20 , 55 , 40 ] ;
54819: LD_ADDR_VAR 0 9
54823: PUSH
54824: LD_INT 20
54826: PUSH
54827: LD_INT 55
54829: PUSH
54830: LD_INT 40
54832: PUSH
54833: EMPTY
54834: LIST
54835: LIST
54836: LIST
54837: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54838: LD_VAR 0 6
54842: PPUSH
54843: CALL_OW 257
54847: PUSH
54848: LD_INT 12
54850: PUSH
54851: LD_INT 16
54853: PUSH
54854: EMPTY
54855: LIST
54856: LIST
54857: IN
54858: IFFALSE 54879
// points := [ 5 , 3 , 2 ] ;
54860: LD_ADDR_VAR 0 9
54864: PUSH
54865: LD_INT 5
54867: PUSH
54868: LD_INT 3
54870: PUSH
54871: LD_INT 2
54873: PUSH
54874: EMPTY
54875: LIST
54876: LIST
54877: LIST
54878: ST_TO_ADDR
// if GetClass ( i ) = 17 then
54879: LD_VAR 0 6
54883: PPUSH
54884: CALL_OW 257
54888: PUSH
54889: LD_INT 17
54891: EQUAL
54892: IFFALSE 54913
// points := [ 100 , 50 , 75 ] ;
54894: LD_ADDR_VAR 0 9
54898: PUSH
54899: LD_INT 100
54901: PUSH
54902: LD_INT 50
54904: PUSH
54905: LD_INT 75
54907: PUSH
54908: EMPTY
54909: LIST
54910: LIST
54911: LIST
54912: ST_TO_ADDR
// if GetClass ( i ) = 15 then
54913: LD_VAR 0 6
54917: PPUSH
54918: CALL_OW 257
54922: PUSH
54923: LD_INT 15
54925: EQUAL
54926: IFFALSE 54947
// points := [ 10 , 5 , 3 ] ;
54928: LD_ADDR_VAR 0 9
54932: PUSH
54933: LD_INT 10
54935: PUSH
54936: LD_INT 5
54938: PUSH
54939: LD_INT 3
54941: PUSH
54942: EMPTY
54943: LIST
54944: LIST
54945: LIST
54946: ST_TO_ADDR
// if GetClass ( i ) = 14 then
54947: LD_VAR 0 6
54951: PPUSH
54952: CALL_OW 257
54956: PUSH
54957: LD_INT 14
54959: EQUAL
54960: IFFALSE 54981
// points := [ 10 , 0 , 0 ] ;
54962: LD_ADDR_VAR 0 9
54966: PUSH
54967: LD_INT 10
54969: PUSH
54970: LD_INT 0
54972: PUSH
54973: LD_INT 0
54975: PUSH
54976: EMPTY
54977: LIST
54978: LIST
54979: LIST
54980: ST_TO_ADDR
// if GetClass ( i ) = 11 then
54981: LD_VAR 0 6
54985: PPUSH
54986: CALL_OW 257
54990: PUSH
54991: LD_INT 11
54993: EQUAL
54994: IFFALSE 55015
// points := [ 30 , 10 , 5 ] ;
54996: LD_ADDR_VAR 0 9
55000: PUSH
55001: LD_INT 30
55003: PUSH
55004: LD_INT 10
55006: PUSH
55007: LD_INT 5
55009: PUSH
55010: EMPTY
55011: LIST
55012: LIST
55013: LIST
55014: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55015: LD_VAR 0 1
55019: PPUSH
55020: LD_INT 5
55022: PPUSH
55023: CALL_OW 321
55027: PUSH
55028: LD_INT 2
55030: EQUAL
55031: IFFALSE 55048
// bpoints := bpoints * 1.8 ;
55033: LD_ADDR_VAR 0 10
55037: PUSH
55038: LD_VAR 0 10
55042: PUSH
55043: LD_REAL  1.80000000000000E+0000
55046: MUL
55047: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55048: LD_VAR 0 6
55052: PPUSH
55053: CALL_OW 257
55057: PUSH
55058: LD_INT 1
55060: PUSH
55061: LD_INT 2
55063: PUSH
55064: LD_INT 3
55066: PUSH
55067: LD_INT 4
55069: PUSH
55070: EMPTY
55071: LIST
55072: LIST
55073: LIST
55074: LIST
55075: IN
55076: PUSH
55077: LD_VAR 0 1
55081: PPUSH
55082: LD_INT 51
55084: PPUSH
55085: CALL_OW 321
55089: PUSH
55090: LD_INT 2
55092: EQUAL
55093: AND
55094: IFFALSE 55111
// bpoints := bpoints * 1.2 ;
55096: LD_ADDR_VAR 0 10
55100: PUSH
55101: LD_VAR 0 10
55105: PUSH
55106: LD_REAL  1.20000000000000E+0000
55109: MUL
55110: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55111: LD_VAR 0 6
55115: PPUSH
55116: CALL_OW 257
55120: PUSH
55121: LD_INT 5
55123: PUSH
55124: LD_INT 7
55126: PUSH
55127: LD_INT 9
55129: PUSH
55130: EMPTY
55131: LIST
55132: LIST
55133: LIST
55134: IN
55135: PUSH
55136: LD_VAR 0 1
55140: PPUSH
55141: LD_INT 52
55143: PPUSH
55144: CALL_OW 321
55148: PUSH
55149: LD_INT 2
55151: EQUAL
55152: AND
55153: IFFALSE 55170
// bpoints := bpoints * 1.5 ;
55155: LD_ADDR_VAR 0 10
55159: PUSH
55160: LD_VAR 0 10
55164: PUSH
55165: LD_REAL  1.50000000000000E+0000
55168: MUL
55169: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55170: LD_VAR 0 1
55174: PPUSH
55175: LD_INT 66
55177: PPUSH
55178: CALL_OW 321
55182: PUSH
55183: LD_INT 2
55185: EQUAL
55186: IFFALSE 55203
// bpoints := bpoints * 1.1 ;
55188: LD_ADDR_VAR 0 10
55192: PUSH
55193: LD_VAR 0 10
55197: PUSH
55198: LD_REAL  1.10000000000000E+0000
55201: MUL
55202: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55203: LD_ADDR_VAR 0 10
55207: PUSH
55208: LD_VAR 0 10
55212: PUSH
55213: LD_VAR 0 6
55217: PPUSH
55218: LD_INT 1
55220: PPUSH
55221: CALL_OW 259
55225: PUSH
55226: LD_REAL  1.15000000000000E+0000
55229: MUL
55230: MUL
55231: ST_TO_ADDR
// end ; unit_vehicle :
55232: GO 56062
55234: LD_INT 2
55236: DOUBLE
55237: EQUAL
55238: IFTRUE 55242
55240: GO 56050
55242: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55243: LD_VAR 0 6
55247: PPUSH
55248: CALL_OW 264
55252: PUSH
55253: LD_INT 2
55255: PUSH
55256: LD_INT 42
55258: PUSH
55259: LD_INT 24
55261: PUSH
55262: EMPTY
55263: LIST
55264: LIST
55265: LIST
55266: IN
55267: IFFALSE 55288
// points := [ 25 , 5 , 3 ] ;
55269: LD_ADDR_VAR 0 9
55273: PUSH
55274: LD_INT 25
55276: PUSH
55277: LD_INT 5
55279: PUSH
55280: LD_INT 3
55282: PUSH
55283: EMPTY
55284: LIST
55285: LIST
55286: LIST
55287: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55288: LD_VAR 0 6
55292: PPUSH
55293: CALL_OW 264
55297: PUSH
55298: LD_INT 4
55300: PUSH
55301: LD_INT 43
55303: PUSH
55304: LD_INT 25
55306: PUSH
55307: EMPTY
55308: LIST
55309: LIST
55310: LIST
55311: IN
55312: IFFALSE 55333
// points := [ 40 , 15 , 5 ] ;
55314: LD_ADDR_VAR 0 9
55318: PUSH
55319: LD_INT 40
55321: PUSH
55322: LD_INT 15
55324: PUSH
55325: LD_INT 5
55327: PUSH
55328: EMPTY
55329: LIST
55330: LIST
55331: LIST
55332: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55333: LD_VAR 0 6
55337: PPUSH
55338: CALL_OW 264
55342: PUSH
55343: LD_INT 3
55345: PUSH
55346: LD_INT 23
55348: PUSH
55349: EMPTY
55350: LIST
55351: LIST
55352: IN
55353: IFFALSE 55374
// points := [ 7 , 25 , 8 ] ;
55355: LD_ADDR_VAR 0 9
55359: PUSH
55360: LD_INT 7
55362: PUSH
55363: LD_INT 25
55365: PUSH
55366: LD_INT 8
55368: PUSH
55369: EMPTY
55370: LIST
55371: LIST
55372: LIST
55373: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55374: LD_VAR 0 6
55378: PPUSH
55379: CALL_OW 264
55383: PUSH
55384: LD_INT 5
55386: PUSH
55387: LD_INT 27
55389: PUSH
55390: LD_INT 44
55392: PUSH
55393: EMPTY
55394: LIST
55395: LIST
55396: LIST
55397: IN
55398: IFFALSE 55419
// points := [ 14 , 50 , 16 ] ;
55400: LD_ADDR_VAR 0 9
55404: PUSH
55405: LD_INT 14
55407: PUSH
55408: LD_INT 50
55410: PUSH
55411: LD_INT 16
55413: PUSH
55414: EMPTY
55415: LIST
55416: LIST
55417: LIST
55418: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55419: LD_VAR 0 6
55423: PPUSH
55424: CALL_OW 264
55428: PUSH
55429: LD_INT 6
55431: PUSH
55432: LD_INT 46
55434: PUSH
55435: EMPTY
55436: LIST
55437: LIST
55438: IN
55439: IFFALSE 55460
// points := [ 32 , 120 , 70 ] ;
55441: LD_ADDR_VAR 0 9
55445: PUSH
55446: LD_INT 32
55448: PUSH
55449: LD_INT 120
55451: PUSH
55452: LD_INT 70
55454: PUSH
55455: EMPTY
55456: LIST
55457: LIST
55458: LIST
55459: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55460: LD_VAR 0 6
55464: PPUSH
55465: CALL_OW 264
55469: PUSH
55470: LD_INT 7
55472: PUSH
55473: LD_INT 28
55475: PUSH
55476: LD_INT 45
55478: PUSH
55479: LD_EXP 99
55483: PUSH
55484: EMPTY
55485: LIST
55486: LIST
55487: LIST
55488: LIST
55489: IN
55490: IFFALSE 55511
// points := [ 35 , 20 , 45 ] ;
55492: LD_ADDR_VAR 0 9
55496: PUSH
55497: LD_INT 35
55499: PUSH
55500: LD_INT 20
55502: PUSH
55503: LD_INT 45
55505: PUSH
55506: EMPTY
55507: LIST
55508: LIST
55509: LIST
55510: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55511: LD_VAR 0 6
55515: PPUSH
55516: CALL_OW 264
55520: PUSH
55521: LD_INT 47
55523: PUSH
55524: EMPTY
55525: LIST
55526: IN
55527: IFFALSE 55548
// points := [ 67 , 45 , 75 ] ;
55529: LD_ADDR_VAR 0 9
55533: PUSH
55534: LD_INT 67
55536: PUSH
55537: LD_INT 45
55539: PUSH
55540: LD_INT 75
55542: PUSH
55543: EMPTY
55544: LIST
55545: LIST
55546: LIST
55547: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55548: LD_VAR 0 6
55552: PPUSH
55553: CALL_OW 264
55557: PUSH
55558: LD_INT 26
55560: PUSH
55561: EMPTY
55562: LIST
55563: IN
55564: IFFALSE 55585
// points := [ 120 , 30 , 80 ] ;
55566: LD_ADDR_VAR 0 9
55570: PUSH
55571: LD_INT 120
55573: PUSH
55574: LD_INT 30
55576: PUSH
55577: LD_INT 80
55579: PUSH
55580: EMPTY
55581: LIST
55582: LIST
55583: LIST
55584: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55585: LD_VAR 0 6
55589: PPUSH
55590: CALL_OW 264
55594: PUSH
55595: LD_INT 22
55597: PUSH
55598: EMPTY
55599: LIST
55600: IN
55601: IFFALSE 55622
// points := [ 40 , 1 , 1 ] ;
55603: LD_ADDR_VAR 0 9
55607: PUSH
55608: LD_INT 40
55610: PUSH
55611: LD_INT 1
55613: PUSH
55614: LD_INT 1
55616: PUSH
55617: EMPTY
55618: LIST
55619: LIST
55620: LIST
55621: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55622: LD_VAR 0 6
55626: PPUSH
55627: CALL_OW 264
55631: PUSH
55632: LD_INT 29
55634: PUSH
55635: EMPTY
55636: LIST
55637: IN
55638: IFFALSE 55659
// points := [ 70 , 200 , 400 ] ;
55640: LD_ADDR_VAR 0 9
55644: PUSH
55645: LD_INT 70
55647: PUSH
55648: LD_INT 200
55650: PUSH
55651: LD_INT 400
55653: PUSH
55654: EMPTY
55655: LIST
55656: LIST
55657: LIST
55658: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55659: LD_VAR 0 6
55663: PPUSH
55664: CALL_OW 264
55668: PUSH
55669: LD_INT 14
55671: PUSH
55672: LD_INT 53
55674: PUSH
55675: EMPTY
55676: LIST
55677: LIST
55678: IN
55679: IFFALSE 55700
// points := [ 40 , 10 , 20 ] ;
55681: LD_ADDR_VAR 0 9
55685: PUSH
55686: LD_INT 40
55688: PUSH
55689: LD_INT 10
55691: PUSH
55692: LD_INT 20
55694: PUSH
55695: EMPTY
55696: LIST
55697: LIST
55698: LIST
55699: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55700: LD_VAR 0 6
55704: PPUSH
55705: CALL_OW 264
55709: PUSH
55710: LD_INT 9
55712: PUSH
55713: EMPTY
55714: LIST
55715: IN
55716: IFFALSE 55737
// points := [ 5 , 70 , 20 ] ;
55718: LD_ADDR_VAR 0 9
55722: PUSH
55723: LD_INT 5
55725: PUSH
55726: LD_INT 70
55728: PUSH
55729: LD_INT 20
55731: PUSH
55732: EMPTY
55733: LIST
55734: LIST
55735: LIST
55736: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55737: LD_VAR 0 6
55741: PPUSH
55742: CALL_OW 264
55746: PUSH
55747: LD_INT 10
55749: PUSH
55750: EMPTY
55751: LIST
55752: IN
55753: IFFALSE 55774
// points := [ 35 , 110 , 70 ] ;
55755: LD_ADDR_VAR 0 9
55759: PUSH
55760: LD_INT 35
55762: PUSH
55763: LD_INT 110
55765: PUSH
55766: LD_INT 70
55768: PUSH
55769: EMPTY
55770: LIST
55771: LIST
55772: LIST
55773: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55774: LD_VAR 0 6
55778: PPUSH
55779: CALL_OW 265
55783: PUSH
55784: LD_INT 25
55786: EQUAL
55787: IFFALSE 55808
// points := [ 80 , 65 , 100 ] ;
55789: LD_ADDR_VAR 0 9
55793: PUSH
55794: LD_INT 80
55796: PUSH
55797: LD_INT 65
55799: PUSH
55800: LD_INT 100
55802: PUSH
55803: EMPTY
55804: LIST
55805: LIST
55806: LIST
55807: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55808: LD_VAR 0 6
55812: PPUSH
55813: CALL_OW 263
55817: PUSH
55818: LD_INT 1
55820: EQUAL
55821: IFFALSE 55856
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55823: LD_ADDR_VAR 0 10
55827: PUSH
55828: LD_VAR 0 10
55832: PUSH
55833: LD_VAR 0 6
55837: PPUSH
55838: CALL_OW 311
55842: PPUSH
55843: LD_INT 3
55845: PPUSH
55846: CALL_OW 259
55850: PUSH
55851: LD_INT 4
55853: MUL
55854: MUL
55855: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
55856: LD_VAR 0 6
55860: PPUSH
55861: CALL_OW 263
55865: PUSH
55866: LD_INT 2
55868: EQUAL
55869: IFFALSE 55920
// begin j := IsControledBy ( i ) ;
55871: LD_ADDR_VAR 0 7
55875: PUSH
55876: LD_VAR 0 6
55880: PPUSH
55881: CALL_OW 312
55885: ST_TO_ADDR
// if j then
55886: LD_VAR 0 7
55890: IFFALSE 55920
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
55892: LD_ADDR_VAR 0 10
55896: PUSH
55897: LD_VAR 0 10
55901: PUSH
55902: LD_VAR 0 7
55906: PPUSH
55907: LD_INT 3
55909: PPUSH
55910: CALL_OW 259
55914: PUSH
55915: LD_INT 3
55917: MUL
55918: MUL
55919: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
55920: LD_VAR 0 6
55924: PPUSH
55925: CALL_OW 264
55929: PUSH
55930: LD_INT 5
55932: PUSH
55933: LD_INT 6
55935: PUSH
55936: LD_INT 46
55938: PUSH
55939: LD_INT 44
55941: PUSH
55942: LD_INT 47
55944: PUSH
55945: LD_INT 45
55947: PUSH
55948: LD_INT 28
55950: PUSH
55951: LD_INT 7
55953: PUSH
55954: LD_INT 27
55956: PUSH
55957: LD_INT 29
55959: PUSH
55960: EMPTY
55961: LIST
55962: LIST
55963: LIST
55964: LIST
55965: LIST
55966: LIST
55967: LIST
55968: LIST
55969: LIST
55970: LIST
55971: IN
55972: PUSH
55973: LD_VAR 0 1
55977: PPUSH
55978: LD_INT 52
55980: PPUSH
55981: CALL_OW 321
55985: PUSH
55986: LD_INT 2
55988: EQUAL
55989: AND
55990: IFFALSE 56007
// bpoints := bpoints * 1.2 ;
55992: LD_ADDR_VAR 0 10
55996: PUSH
55997: LD_VAR 0 10
56001: PUSH
56002: LD_REAL  1.20000000000000E+0000
56005: MUL
56006: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56007: LD_VAR 0 6
56011: PPUSH
56012: CALL_OW 264
56016: PUSH
56017: LD_INT 6
56019: PUSH
56020: LD_INT 46
56022: PUSH
56023: LD_INT 47
56025: PUSH
56026: EMPTY
56027: LIST
56028: LIST
56029: LIST
56030: IN
56031: IFFALSE 56048
// bpoints := bpoints * 1.2 ;
56033: LD_ADDR_VAR 0 10
56037: PUSH
56038: LD_VAR 0 10
56042: PUSH
56043: LD_REAL  1.20000000000000E+0000
56046: MUL
56047: ST_TO_ADDR
// end ; unit_building :
56048: GO 56062
56050: LD_INT 3
56052: DOUBLE
56053: EQUAL
56054: IFTRUE 56058
56056: GO 56061
56058: POP
// ; end ;
56059: GO 56062
56061: POP
// for j = 1 to 3 do
56062: LD_ADDR_VAR 0 7
56066: PUSH
56067: DOUBLE
56068: LD_INT 1
56070: DEC
56071: ST_TO_ADDR
56072: LD_INT 3
56074: PUSH
56075: FOR_TO
56076: IFFALSE 56129
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56078: LD_ADDR_VAR 0 5
56082: PUSH
56083: LD_VAR 0 5
56087: PPUSH
56088: LD_VAR 0 7
56092: PPUSH
56093: LD_VAR 0 5
56097: PUSH
56098: LD_VAR 0 7
56102: ARRAY
56103: PUSH
56104: LD_VAR 0 9
56108: PUSH
56109: LD_VAR 0 7
56113: ARRAY
56114: PUSH
56115: LD_VAR 0 10
56119: MUL
56120: PLUS
56121: PPUSH
56122: CALL_OW 1
56126: ST_TO_ADDR
56127: GO 56075
56129: POP
56130: POP
// end ;
56131: GO 54608
56133: POP
56134: POP
// result := Replace ( result , 4 , tmp ) ;
56135: LD_ADDR_VAR 0 5
56139: PUSH
56140: LD_VAR 0 5
56144: PPUSH
56145: LD_INT 4
56147: PPUSH
56148: LD_VAR 0 8
56152: PPUSH
56153: CALL_OW 1
56157: ST_TO_ADDR
// end ;
56158: LD_VAR 0 5
56162: RET
// export function DangerAtRange ( unit , range ) ; begin
56163: LD_INT 0
56165: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56166: LD_ADDR_VAR 0 3
56170: PUSH
56171: LD_VAR 0 1
56175: PPUSH
56176: CALL_OW 255
56180: PPUSH
56181: LD_VAR 0 1
56185: PPUSH
56186: CALL_OW 250
56190: PPUSH
56191: LD_VAR 0 1
56195: PPUSH
56196: CALL_OW 251
56200: PPUSH
56201: LD_VAR 0 2
56205: PPUSH
56206: CALL 54460 0 4
56210: ST_TO_ADDR
// end ;
56211: LD_VAR 0 3
56215: RET
// export function DangerInArea ( side , area ) ; begin
56216: LD_INT 0
56218: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56219: LD_ADDR_VAR 0 3
56223: PUSH
56224: LD_VAR 0 2
56228: PPUSH
56229: LD_INT 81
56231: PUSH
56232: LD_VAR 0 1
56236: PUSH
56237: EMPTY
56238: LIST
56239: LIST
56240: PPUSH
56241: CALL_OW 70
56245: ST_TO_ADDR
// end ;
56246: LD_VAR 0 3
56250: RET
// export function IsExtension ( b ) ; begin
56251: LD_INT 0
56253: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56254: LD_ADDR_VAR 0 2
56258: PUSH
56259: LD_VAR 0 1
56263: PUSH
56264: LD_INT 23
56266: PUSH
56267: LD_INT 20
56269: PUSH
56270: LD_INT 22
56272: PUSH
56273: LD_INT 17
56275: PUSH
56276: LD_INT 24
56278: PUSH
56279: LD_INT 21
56281: PUSH
56282: LD_INT 19
56284: PUSH
56285: LD_INT 16
56287: PUSH
56288: LD_INT 25
56290: PUSH
56291: LD_INT 18
56293: PUSH
56294: EMPTY
56295: LIST
56296: LIST
56297: LIST
56298: LIST
56299: LIST
56300: LIST
56301: LIST
56302: LIST
56303: LIST
56304: LIST
56305: IN
56306: ST_TO_ADDR
// end ;
56307: LD_VAR 0 2
56311: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56312: LD_INT 0
56314: PPUSH
56315: PPUSH
56316: PPUSH
// result := [ ] ;
56317: LD_ADDR_VAR 0 4
56321: PUSH
56322: EMPTY
56323: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56324: LD_ADDR_VAR 0 5
56328: PUSH
56329: LD_VAR 0 2
56333: PPUSH
56334: LD_INT 21
56336: PUSH
56337: LD_INT 3
56339: PUSH
56340: EMPTY
56341: LIST
56342: LIST
56343: PPUSH
56344: CALL_OW 70
56348: ST_TO_ADDR
// if not tmp then
56349: LD_VAR 0 5
56353: NOT
56354: IFFALSE 56358
// exit ;
56356: GO 56422
// if checkLink then
56358: LD_VAR 0 3
56362: IFFALSE 56412
// begin for i in tmp do
56364: LD_ADDR_VAR 0 6
56368: PUSH
56369: LD_VAR 0 5
56373: PUSH
56374: FOR_IN
56375: IFFALSE 56410
// if GetBase ( i ) <> base then
56377: LD_VAR 0 6
56381: PPUSH
56382: CALL_OW 274
56386: PUSH
56387: LD_VAR 0 1
56391: NONEQUAL
56392: IFFALSE 56408
// ComLinkToBase ( base , i ) ;
56394: LD_VAR 0 1
56398: PPUSH
56399: LD_VAR 0 6
56403: PPUSH
56404: CALL_OW 169
56408: GO 56374
56410: POP
56411: POP
// end ; result := tmp ;
56412: LD_ADDR_VAR 0 4
56416: PUSH
56417: LD_VAR 0 5
56421: ST_TO_ADDR
// end ;
56422: LD_VAR 0 4
56426: RET
// export function ComComplete ( units , b ) ; var i ; begin
56427: LD_INT 0
56429: PPUSH
56430: PPUSH
// if not units then
56431: LD_VAR 0 1
56435: NOT
56436: IFFALSE 56440
// exit ;
56438: GO 56530
// for i in units do
56440: LD_ADDR_VAR 0 4
56444: PUSH
56445: LD_VAR 0 1
56449: PUSH
56450: FOR_IN
56451: IFFALSE 56528
// if BuildingStatus ( b ) = bs_build then
56453: LD_VAR 0 2
56457: PPUSH
56458: CALL_OW 461
56462: PUSH
56463: LD_INT 1
56465: EQUAL
56466: IFFALSE 56526
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56468: LD_VAR 0 4
56472: PPUSH
56473: LD_STRING h
56475: PUSH
56476: LD_VAR 0 2
56480: PPUSH
56481: CALL_OW 250
56485: PUSH
56486: LD_VAR 0 2
56490: PPUSH
56491: CALL_OW 251
56495: PUSH
56496: LD_VAR 0 2
56500: PUSH
56501: LD_INT 0
56503: PUSH
56504: LD_INT 0
56506: PUSH
56507: LD_INT 0
56509: PUSH
56510: EMPTY
56511: LIST
56512: LIST
56513: LIST
56514: LIST
56515: LIST
56516: LIST
56517: LIST
56518: PUSH
56519: EMPTY
56520: LIST
56521: PPUSH
56522: CALL_OW 446
56526: GO 56450
56528: POP
56529: POP
// end ;
56530: LD_VAR 0 3
56534: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56535: LD_INT 0
56537: PPUSH
56538: PPUSH
56539: PPUSH
56540: PPUSH
56541: PPUSH
56542: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
56543: LD_VAR 0 1
56547: NOT
56548: PUSH
56549: LD_VAR 0 1
56553: PPUSH
56554: CALL_OW 263
56558: PUSH
56559: LD_INT 2
56561: NONEQUAL
56562: OR
56563: IFFALSE 56567
// exit ;
56565: GO 56883
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56567: LD_ADDR_VAR 0 6
56571: PUSH
56572: LD_INT 22
56574: PUSH
56575: LD_VAR 0 1
56579: PPUSH
56580: CALL_OW 255
56584: PUSH
56585: EMPTY
56586: LIST
56587: LIST
56588: PUSH
56589: LD_INT 2
56591: PUSH
56592: LD_INT 30
56594: PUSH
56595: LD_INT 36
56597: PUSH
56598: EMPTY
56599: LIST
56600: LIST
56601: PUSH
56602: LD_INT 34
56604: PUSH
56605: LD_INT 31
56607: PUSH
56608: EMPTY
56609: LIST
56610: LIST
56611: PUSH
56612: EMPTY
56613: LIST
56614: LIST
56615: LIST
56616: PUSH
56617: EMPTY
56618: LIST
56619: LIST
56620: PPUSH
56621: CALL_OW 69
56625: ST_TO_ADDR
// if not tmp then
56626: LD_VAR 0 6
56630: NOT
56631: IFFALSE 56635
// exit ;
56633: GO 56883
// result := [ ] ;
56635: LD_ADDR_VAR 0 2
56639: PUSH
56640: EMPTY
56641: ST_TO_ADDR
// for i in tmp do
56642: LD_ADDR_VAR 0 3
56646: PUSH
56647: LD_VAR 0 6
56651: PUSH
56652: FOR_IN
56653: IFFALSE 56724
// begin t := UnitsInside ( i ) ;
56655: LD_ADDR_VAR 0 4
56659: PUSH
56660: LD_VAR 0 3
56664: PPUSH
56665: CALL_OW 313
56669: ST_TO_ADDR
// if t then
56670: LD_VAR 0 4
56674: IFFALSE 56722
// for j in t do
56676: LD_ADDR_VAR 0 7
56680: PUSH
56681: LD_VAR 0 4
56685: PUSH
56686: FOR_IN
56687: IFFALSE 56720
// result := Replace ( result , result + 1 , j ) ;
56689: LD_ADDR_VAR 0 2
56693: PUSH
56694: LD_VAR 0 2
56698: PPUSH
56699: LD_VAR 0 2
56703: PUSH
56704: LD_INT 1
56706: PLUS
56707: PPUSH
56708: LD_VAR 0 7
56712: PPUSH
56713: CALL_OW 1
56717: ST_TO_ADDR
56718: GO 56686
56720: POP
56721: POP
// end ;
56722: GO 56652
56724: POP
56725: POP
// if not result then
56726: LD_VAR 0 2
56730: NOT
56731: IFFALSE 56735
// exit ;
56733: GO 56883
// mech := result [ 1 ] ;
56735: LD_ADDR_VAR 0 5
56739: PUSH
56740: LD_VAR 0 2
56744: PUSH
56745: LD_INT 1
56747: ARRAY
56748: ST_TO_ADDR
// if result > 1 then
56749: LD_VAR 0 2
56753: PUSH
56754: LD_INT 1
56756: GREATER
56757: IFFALSE 56869
// begin for i = 2 to result do
56759: LD_ADDR_VAR 0 3
56763: PUSH
56764: DOUBLE
56765: LD_INT 2
56767: DEC
56768: ST_TO_ADDR
56769: LD_VAR 0 2
56773: PUSH
56774: FOR_TO
56775: IFFALSE 56867
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56777: LD_ADDR_VAR 0 4
56781: PUSH
56782: LD_VAR 0 2
56786: PUSH
56787: LD_VAR 0 3
56791: ARRAY
56792: PPUSH
56793: LD_INT 3
56795: PPUSH
56796: CALL_OW 259
56800: PUSH
56801: LD_VAR 0 2
56805: PUSH
56806: LD_VAR 0 3
56810: ARRAY
56811: PPUSH
56812: CALL_OW 432
56816: MINUS
56817: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56818: LD_VAR 0 4
56822: PUSH
56823: LD_VAR 0 5
56827: PPUSH
56828: LD_INT 3
56830: PPUSH
56831: CALL_OW 259
56835: PUSH
56836: LD_VAR 0 5
56840: PPUSH
56841: CALL_OW 432
56845: MINUS
56846: GREATEREQUAL
56847: IFFALSE 56865
// mech := result [ i ] ;
56849: LD_ADDR_VAR 0 5
56853: PUSH
56854: LD_VAR 0 2
56858: PUSH
56859: LD_VAR 0 3
56863: ARRAY
56864: ST_TO_ADDR
// end ;
56865: GO 56774
56867: POP
56868: POP
// end ; ComLinkTo ( vehicle , mech ) ;
56869: LD_VAR 0 1
56873: PPUSH
56874: LD_VAR 0 5
56878: PPUSH
56879: CALL_OW 135
// end ;
56883: LD_VAR 0 2
56887: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
56888: LD_INT 0
56890: PPUSH
56891: PPUSH
56892: PPUSH
56893: PPUSH
56894: PPUSH
56895: PPUSH
56896: PPUSH
56897: PPUSH
56898: PPUSH
56899: PPUSH
56900: PPUSH
56901: PPUSH
56902: PPUSH
// result := [ ] ;
56903: LD_ADDR_VAR 0 7
56907: PUSH
56908: EMPTY
56909: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
56910: LD_VAR 0 1
56914: PPUSH
56915: CALL_OW 266
56919: PUSH
56920: LD_INT 0
56922: PUSH
56923: LD_INT 1
56925: PUSH
56926: EMPTY
56927: LIST
56928: LIST
56929: IN
56930: NOT
56931: IFFALSE 56935
// exit ;
56933: GO 58569
// if name then
56935: LD_VAR 0 3
56939: IFFALSE 56955
// SetBName ( base_dep , name ) ;
56941: LD_VAR 0 1
56945: PPUSH
56946: LD_VAR 0 3
56950: PPUSH
56951: CALL_OW 500
// base := GetBase ( base_dep ) ;
56955: LD_ADDR_VAR 0 15
56959: PUSH
56960: LD_VAR 0 1
56964: PPUSH
56965: CALL_OW 274
56969: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
56970: LD_ADDR_VAR 0 16
56974: PUSH
56975: LD_VAR 0 1
56979: PPUSH
56980: CALL_OW 255
56984: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
56985: LD_ADDR_VAR 0 17
56989: PUSH
56990: LD_VAR 0 1
56994: PPUSH
56995: CALL_OW 248
56999: ST_TO_ADDR
// if sources then
57000: LD_VAR 0 5
57004: IFFALSE 57051
// for i = 1 to 3 do
57006: LD_ADDR_VAR 0 8
57010: PUSH
57011: DOUBLE
57012: LD_INT 1
57014: DEC
57015: ST_TO_ADDR
57016: LD_INT 3
57018: PUSH
57019: FOR_TO
57020: IFFALSE 57049
// AddResourceType ( base , i , sources [ i ] ) ;
57022: LD_VAR 0 15
57026: PPUSH
57027: LD_VAR 0 8
57031: PPUSH
57032: LD_VAR 0 5
57036: PUSH
57037: LD_VAR 0 8
57041: ARRAY
57042: PPUSH
57043: CALL_OW 276
57047: GO 57019
57049: POP
57050: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57051: LD_ADDR_VAR 0 18
57055: PUSH
57056: LD_VAR 0 15
57060: PPUSH
57061: LD_VAR 0 2
57065: PPUSH
57066: LD_INT 1
57068: PPUSH
57069: CALL 56312 0 3
57073: ST_TO_ADDR
// InitHc ;
57074: CALL_OW 19
// InitUc ;
57078: CALL_OW 18
// uc_side := side ;
57082: LD_ADDR_OWVAR 20
57086: PUSH
57087: LD_VAR 0 16
57091: ST_TO_ADDR
// uc_nation := nation ;
57092: LD_ADDR_OWVAR 21
57096: PUSH
57097: LD_VAR 0 17
57101: ST_TO_ADDR
// if buildings then
57102: LD_VAR 0 18
57106: IFFALSE 58428
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57108: LD_ADDR_VAR 0 19
57112: PUSH
57113: LD_VAR 0 18
57117: PPUSH
57118: LD_INT 2
57120: PUSH
57121: LD_INT 30
57123: PUSH
57124: LD_INT 29
57126: PUSH
57127: EMPTY
57128: LIST
57129: LIST
57130: PUSH
57131: LD_INT 30
57133: PUSH
57134: LD_INT 30
57136: PUSH
57137: EMPTY
57138: LIST
57139: LIST
57140: PUSH
57141: EMPTY
57142: LIST
57143: LIST
57144: LIST
57145: PPUSH
57146: CALL_OW 72
57150: ST_TO_ADDR
// if tmp then
57151: LD_VAR 0 19
57155: IFFALSE 57203
// for i in tmp do
57157: LD_ADDR_VAR 0 8
57161: PUSH
57162: LD_VAR 0 19
57166: PUSH
57167: FOR_IN
57168: IFFALSE 57201
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57170: LD_VAR 0 8
57174: PPUSH
57175: CALL_OW 250
57179: PPUSH
57180: LD_VAR 0 8
57184: PPUSH
57185: CALL_OW 251
57189: PPUSH
57190: LD_VAR 0 16
57194: PPUSH
57195: CALL_OW 441
57199: GO 57167
57201: POP
57202: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57203: LD_VAR 0 18
57207: PPUSH
57208: LD_INT 2
57210: PUSH
57211: LD_INT 30
57213: PUSH
57214: LD_INT 32
57216: PUSH
57217: EMPTY
57218: LIST
57219: LIST
57220: PUSH
57221: LD_INT 30
57223: PUSH
57224: LD_INT 33
57226: PUSH
57227: EMPTY
57228: LIST
57229: LIST
57230: PUSH
57231: EMPTY
57232: LIST
57233: LIST
57234: LIST
57235: PPUSH
57236: CALL_OW 72
57240: IFFALSE 57328
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57242: LD_ADDR_VAR 0 8
57246: PUSH
57247: LD_VAR 0 18
57251: PPUSH
57252: LD_INT 2
57254: PUSH
57255: LD_INT 30
57257: PUSH
57258: LD_INT 32
57260: PUSH
57261: EMPTY
57262: LIST
57263: LIST
57264: PUSH
57265: LD_INT 30
57267: PUSH
57268: LD_INT 33
57270: PUSH
57271: EMPTY
57272: LIST
57273: LIST
57274: PUSH
57275: EMPTY
57276: LIST
57277: LIST
57278: LIST
57279: PPUSH
57280: CALL_OW 72
57284: PUSH
57285: FOR_IN
57286: IFFALSE 57326
// begin if not GetBWeapon ( i ) then
57288: LD_VAR 0 8
57292: PPUSH
57293: CALL_OW 269
57297: NOT
57298: IFFALSE 57324
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57300: LD_VAR 0 8
57304: PPUSH
57305: LD_VAR 0 8
57309: PPUSH
57310: LD_VAR 0 2
57314: PPUSH
57315: CALL 58574 0 2
57319: PPUSH
57320: CALL_OW 431
// end ;
57324: GO 57285
57326: POP
57327: POP
// end ; for i = 1 to personel do
57328: LD_ADDR_VAR 0 8
57332: PUSH
57333: DOUBLE
57334: LD_INT 1
57336: DEC
57337: ST_TO_ADDR
57338: LD_VAR 0 6
57342: PUSH
57343: FOR_TO
57344: IFFALSE 58408
// begin if i > 4 then
57346: LD_VAR 0 8
57350: PUSH
57351: LD_INT 4
57353: GREATER
57354: IFFALSE 57358
// break ;
57356: GO 58408
// case i of 1 :
57358: LD_VAR 0 8
57362: PUSH
57363: LD_INT 1
57365: DOUBLE
57366: EQUAL
57367: IFTRUE 57371
57369: GO 57451
57371: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57372: LD_ADDR_VAR 0 12
57376: PUSH
57377: LD_VAR 0 18
57381: PPUSH
57382: LD_INT 22
57384: PUSH
57385: LD_VAR 0 16
57389: PUSH
57390: EMPTY
57391: LIST
57392: LIST
57393: PUSH
57394: LD_INT 58
57396: PUSH
57397: EMPTY
57398: LIST
57399: PUSH
57400: LD_INT 2
57402: PUSH
57403: LD_INT 30
57405: PUSH
57406: LD_INT 32
57408: PUSH
57409: EMPTY
57410: LIST
57411: LIST
57412: PUSH
57413: LD_INT 30
57415: PUSH
57416: LD_INT 4
57418: PUSH
57419: EMPTY
57420: LIST
57421: LIST
57422: PUSH
57423: LD_INT 30
57425: PUSH
57426: LD_INT 5
57428: PUSH
57429: EMPTY
57430: LIST
57431: LIST
57432: PUSH
57433: EMPTY
57434: LIST
57435: LIST
57436: LIST
57437: LIST
57438: PUSH
57439: EMPTY
57440: LIST
57441: LIST
57442: LIST
57443: PPUSH
57444: CALL_OW 72
57448: ST_TO_ADDR
57449: GO 57673
57451: LD_INT 2
57453: DOUBLE
57454: EQUAL
57455: IFTRUE 57459
57457: GO 57521
57459: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57460: LD_ADDR_VAR 0 12
57464: PUSH
57465: LD_VAR 0 18
57469: PPUSH
57470: LD_INT 22
57472: PUSH
57473: LD_VAR 0 16
57477: PUSH
57478: EMPTY
57479: LIST
57480: LIST
57481: PUSH
57482: LD_INT 2
57484: PUSH
57485: LD_INT 30
57487: PUSH
57488: LD_INT 0
57490: PUSH
57491: EMPTY
57492: LIST
57493: LIST
57494: PUSH
57495: LD_INT 30
57497: PUSH
57498: LD_INT 1
57500: PUSH
57501: EMPTY
57502: LIST
57503: LIST
57504: PUSH
57505: EMPTY
57506: LIST
57507: LIST
57508: LIST
57509: PUSH
57510: EMPTY
57511: LIST
57512: LIST
57513: PPUSH
57514: CALL_OW 72
57518: ST_TO_ADDR
57519: GO 57673
57521: LD_INT 3
57523: DOUBLE
57524: EQUAL
57525: IFTRUE 57529
57527: GO 57591
57529: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57530: LD_ADDR_VAR 0 12
57534: PUSH
57535: LD_VAR 0 18
57539: PPUSH
57540: LD_INT 22
57542: PUSH
57543: LD_VAR 0 16
57547: PUSH
57548: EMPTY
57549: LIST
57550: LIST
57551: PUSH
57552: LD_INT 2
57554: PUSH
57555: LD_INT 30
57557: PUSH
57558: LD_INT 2
57560: PUSH
57561: EMPTY
57562: LIST
57563: LIST
57564: PUSH
57565: LD_INT 30
57567: PUSH
57568: LD_INT 3
57570: PUSH
57571: EMPTY
57572: LIST
57573: LIST
57574: PUSH
57575: EMPTY
57576: LIST
57577: LIST
57578: LIST
57579: PUSH
57580: EMPTY
57581: LIST
57582: LIST
57583: PPUSH
57584: CALL_OW 72
57588: ST_TO_ADDR
57589: GO 57673
57591: LD_INT 4
57593: DOUBLE
57594: EQUAL
57595: IFTRUE 57599
57597: GO 57672
57599: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57600: LD_ADDR_VAR 0 12
57604: PUSH
57605: LD_VAR 0 18
57609: PPUSH
57610: LD_INT 22
57612: PUSH
57613: LD_VAR 0 16
57617: PUSH
57618: EMPTY
57619: LIST
57620: LIST
57621: PUSH
57622: LD_INT 2
57624: PUSH
57625: LD_INT 30
57627: PUSH
57628: LD_INT 6
57630: PUSH
57631: EMPTY
57632: LIST
57633: LIST
57634: PUSH
57635: LD_INT 30
57637: PUSH
57638: LD_INT 7
57640: PUSH
57641: EMPTY
57642: LIST
57643: LIST
57644: PUSH
57645: LD_INT 30
57647: PUSH
57648: LD_INT 8
57650: PUSH
57651: EMPTY
57652: LIST
57653: LIST
57654: PUSH
57655: EMPTY
57656: LIST
57657: LIST
57658: LIST
57659: LIST
57660: PUSH
57661: EMPTY
57662: LIST
57663: LIST
57664: PPUSH
57665: CALL_OW 72
57669: ST_TO_ADDR
57670: GO 57673
57672: POP
// if i = 1 then
57673: LD_VAR 0 8
57677: PUSH
57678: LD_INT 1
57680: EQUAL
57681: IFFALSE 57792
// begin tmp := [ ] ;
57683: LD_ADDR_VAR 0 19
57687: PUSH
57688: EMPTY
57689: ST_TO_ADDR
// for j in f do
57690: LD_ADDR_VAR 0 9
57694: PUSH
57695: LD_VAR 0 12
57699: PUSH
57700: FOR_IN
57701: IFFALSE 57774
// if GetBType ( j ) = b_bunker then
57703: LD_VAR 0 9
57707: PPUSH
57708: CALL_OW 266
57712: PUSH
57713: LD_INT 32
57715: EQUAL
57716: IFFALSE 57743
// tmp := Insert ( tmp , 1 , j ) else
57718: LD_ADDR_VAR 0 19
57722: PUSH
57723: LD_VAR 0 19
57727: PPUSH
57728: LD_INT 1
57730: PPUSH
57731: LD_VAR 0 9
57735: PPUSH
57736: CALL_OW 2
57740: ST_TO_ADDR
57741: GO 57772
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57743: LD_ADDR_VAR 0 19
57747: PUSH
57748: LD_VAR 0 19
57752: PPUSH
57753: LD_VAR 0 19
57757: PUSH
57758: LD_INT 1
57760: PLUS
57761: PPUSH
57762: LD_VAR 0 9
57766: PPUSH
57767: CALL_OW 2
57771: ST_TO_ADDR
57772: GO 57700
57774: POP
57775: POP
// if tmp then
57776: LD_VAR 0 19
57780: IFFALSE 57792
// f := tmp ;
57782: LD_ADDR_VAR 0 12
57786: PUSH
57787: LD_VAR 0 19
57791: ST_TO_ADDR
// end ; x := personel [ i ] ;
57792: LD_ADDR_VAR 0 13
57796: PUSH
57797: LD_VAR 0 6
57801: PUSH
57802: LD_VAR 0 8
57806: ARRAY
57807: ST_TO_ADDR
// if x = - 1 then
57808: LD_VAR 0 13
57812: PUSH
57813: LD_INT 1
57815: NEG
57816: EQUAL
57817: IFFALSE 58026
// begin for j in f do
57819: LD_ADDR_VAR 0 9
57823: PUSH
57824: LD_VAR 0 12
57828: PUSH
57829: FOR_IN
57830: IFFALSE 58022
// repeat InitHc ;
57832: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57836: LD_VAR 0 9
57840: PPUSH
57841: CALL_OW 266
57845: PUSH
57846: LD_INT 5
57848: EQUAL
57849: IFFALSE 57919
// begin if UnitsInside ( j ) < 3 then
57851: LD_VAR 0 9
57855: PPUSH
57856: CALL_OW 313
57860: PUSH
57861: LD_INT 3
57863: LESS
57864: IFFALSE 57900
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57866: LD_INT 0
57868: PPUSH
57869: LD_INT 5
57871: PUSH
57872: LD_INT 8
57874: PUSH
57875: LD_INT 9
57877: PUSH
57878: EMPTY
57879: LIST
57880: LIST
57881: LIST
57882: PUSH
57883: LD_VAR 0 17
57887: ARRAY
57888: PPUSH
57889: LD_VAR 0 4
57893: PPUSH
57894: CALL_OW 380
57898: GO 57917
// PrepareHuman ( false , i , skill ) ;
57900: LD_INT 0
57902: PPUSH
57903: LD_VAR 0 8
57907: PPUSH
57908: LD_VAR 0 4
57912: PPUSH
57913: CALL_OW 380
// end else
57917: GO 57936
// PrepareHuman ( false , i , skill ) ;
57919: LD_INT 0
57921: PPUSH
57922: LD_VAR 0 8
57926: PPUSH
57927: LD_VAR 0 4
57931: PPUSH
57932: CALL_OW 380
// un := CreateHuman ;
57936: LD_ADDR_VAR 0 14
57940: PUSH
57941: CALL_OW 44
57945: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57946: LD_ADDR_VAR 0 7
57950: PUSH
57951: LD_VAR 0 7
57955: PPUSH
57956: LD_INT 1
57958: PPUSH
57959: LD_VAR 0 14
57963: PPUSH
57964: CALL_OW 2
57968: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
57969: LD_VAR 0 14
57973: PPUSH
57974: LD_VAR 0 9
57978: PPUSH
57979: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
57983: LD_VAR 0 9
57987: PPUSH
57988: CALL_OW 313
57992: PUSH
57993: LD_INT 6
57995: EQUAL
57996: PUSH
57997: LD_VAR 0 9
58001: PPUSH
58002: CALL_OW 266
58006: PUSH
58007: LD_INT 32
58009: PUSH
58010: LD_INT 31
58012: PUSH
58013: EMPTY
58014: LIST
58015: LIST
58016: IN
58017: OR
58018: IFFALSE 57832
58020: GO 57829
58022: POP
58023: POP
// end else
58024: GO 58406
// for j = 1 to x do
58026: LD_ADDR_VAR 0 9
58030: PUSH
58031: DOUBLE
58032: LD_INT 1
58034: DEC
58035: ST_TO_ADDR
58036: LD_VAR 0 13
58040: PUSH
58041: FOR_TO
58042: IFFALSE 58404
// begin InitHc ;
58044: CALL_OW 19
// if not f then
58048: LD_VAR 0 12
58052: NOT
58053: IFFALSE 58142
// begin PrepareHuman ( false , i , skill ) ;
58055: LD_INT 0
58057: PPUSH
58058: LD_VAR 0 8
58062: PPUSH
58063: LD_VAR 0 4
58067: PPUSH
58068: CALL_OW 380
// un := CreateHuman ;
58072: LD_ADDR_VAR 0 14
58076: PUSH
58077: CALL_OW 44
58081: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58082: LD_ADDR_VAR 0 7
58086: PUSH
58087: LD_VAR 0 7
58091: PPUSH
58092: LD_INT 1
58094: PPUSH
58095: LD_VAR 0 14
58099: PPUSH
58100: CALL_OW 2
58104: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58105: LD_VAR 0 14
58109: PPUSH
58110: LD_VAR 0 1
58114: PPUSH
58115: CALL_OW 250
58119: PPUSH
58120: LD_VAR 0 1
58124: PPUSH
58125: CALL_OW 251
58129: PPUSH
58130: LD_INT 10
58132: PPUSH
58133: LD_INT 0
58135: PPUSH
58136: CALL_OW 50
// continue ;
58140: GO 58041
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58142: LD_VAR 0 12
58146: PUSH
58147: LD_INT 1
58149: ARRAY
58150: PPUSH
58151: CALL_OW 313
58155: PUSH
58156: LD_VAR 0 12
58160: PUSH
58161: LD_INT 1
58163: ARRAY
58164: PPUSH
58165: CALL_OW 266
58169: PUSH
58170: LD_INT 32
58172: PUSH
58173: LD_INT 31
58175: PUSH
58176: EMPTY
58177: LIST
58178: LIST
58179: IN
58180: AND
58181: PUSH
58182: LD_VAR 0 12
58186: PUSH
58187: LD_INT 1
58189: ARRAY
58190: PPUSH
58191: CALL_OW 313
58195: PUSH
58196: LD_INT 6
58198: EQUAL
58199: OR
58200: IFFALSE 58220
// f := Delete ( f , 1 ) ;
58202: LD_ADDR_VAR 0 12
58206: PUSH
58207: LD_VAR 0 12
58211: PPUSH
58212: LD_INT 1
58214: PPUSH
58215: CALL_OW 3
58219: ST_TO_ADDR
// if not f then
58220: LD_VAR 0 12
58224: NOT
58225: IFFALSE 58243
// begin x := x + 2 ;
58227: LD_ADDR_VAR 0 13
58231: PUSH
58232: LD_VAR 0 13
58236: PUSH
58237: LD_INT 2
58239: PLUS
58240: ST_TO_ADDR
// continue ;
58241: GO 58041
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58243: LD_VAR 0 12
58247: PUSH
58248: LD_INT 1
58250: ARRAY
58251: PPUSH
58252: CALL_OW 266
58256: PUSH
58257: LD_INT 5
58259: EQUAL
58260: IFFALSE 58334
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58262: LD_VAR 0 12
58266: PUSH
58267: LD_INT 1
58269: ARRAY
58270: PPUSH
58271: CALL_OW 313
58275: PUSH
58276: LD_INT 3
58278: LESS
58279: IFFALSE 58315
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58281: LD_INT 0
58283: PPUSH
58284: LD_INT 5
58286: PUSH
58287: LD_INT 8
58289: PUSH
58290: LD_INT 9
58292: PUSH
58293: EMPTY
58294: LIST
58295: LIST
58296: LIST
58297: PUSH
58298: LD_VAR 0 17
58302: ARRAY
58303: PPUSH
58304: LD_VAR 0 4
58308: PPUSH
58309: CALL_OW 380
58313: GO 58332
// PrepareHuman ( false , i , skill ) ;
58315: LD_INT 0
58317: PPUSH
58318: LD_VAR 0 8
58322: PPUSH
58323: LD_VAR 0 4
58327: PPUSH
58328: CALL_OW 380
// end else
58332: GO 58351
// PrepareHuman ( false , i , skill ) ;
58334: LD_INT 0
58336: PPUSH
58337: LD_VAR 0 8
58341: PPUSH
58342: LD_VAR 0 4
58346: PPUSH
58347: CALL_OW 380
// un := CreateHuman ;
58351: LD_ADDR_VAR 0 14
58355: PUSH
58356: CALL_OW 44
58360: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58361: LD_ADDR_VAR 0 7
58365: PUSH
58366: LD_VAR 0 7
58370: PPUSH
58371: LD_INT 1
58373: PPUSH
58374: LD_VAR 0 14
58378: PPUSH
58379: CALL_OW 2
58383: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58384: LD_VAR 0 14
58388: PPUSH
58389: LD_VAR 0 12
58393: PUSH
58394: LD_INT 1
58396: ARRAY
58397: PPUSH
58398: CALL_OW 52
// end ;
58402: GO 58041
58404: POP
58405: POP
// end ;
58406: GO 57343
58408: POP
58409: POP
// result := result ^ buildings ;
58410: LD_ADDR_VAR 0 7
58414: PUSH
58415: LD_VAR 0 7
58419: PUSH
58420: LD_VAR 0 18
58424: ADD
58425: ST_TO_ADDR
// end else
58426: GO 58569
// begin for i = 1 to personel do
58428: LD_ADDR_VAR 0 8
58432: PUSH
58433: DOUBLE
58434: LD_INT 1
58436: DEC
58437: ST_TO_ADDR
58438: LD_VAR 0 6
58442: PUSH
58443: FOR_TO
58444: IFFALSE 58567
// begin if i > 4 then
58446: LD_VAR 0 8
58450: PUSH
58451: LD_INT 4
58453: GREATER
58454: IFFALSE 58458
// break ;
58456: GO 58567
// x := personel [ i ] ;
58458: LD_ADDR_VAR 0 13
58462: PUSH
58463: LD_VAR 0 6
58467: PUSH
58468: LD_VAR 0 8
58472: ARRAY
58473: ST_TO_ADDR
// if x = - 1 then
58474: LD_VAR 0 13
58478: PUSH
58479: LD_INT 1
58481: NEG
58482: EQUAL
58483: IFFALSE 58487
// continue ;
58485: GO 58443
// PrepareHuman ( false , i , skill ) ;
58487: LD_INT 0
58489: PPUSH
58490: LD_VAR 0 8
58494: PPUSH
58495: LD_VAR 0 4
58499: PPUSH
58500: CALL_OW 380
// un := CreateHuman ;
58504: LD_ADDR_VAR 0 14
58508: PUSH
58509: CALL_OW 44
58513: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58514: LD_VAR 0 14
58518: PPUSH
58519: LD_VAR 0 1
58523: PPUSH
58524: CALL_OW 250
58528: PPUSH
58529: LD_VAR 0 1
58533: PPUSH
58534: CALL_OW 251
58538: PPUSH
58539: LD_INT 10
58541: PPUSH
58542: LD_INT 0
58544: PPUSH
58545: CALL_OW 50
// result := result ^ un ;
58549: LD_ADDR_VAR 0 7
58553: PUSH
58554: LD_VAR 0 7
58558: PUSH
58559: LD_VAR 0 14
58563: ADD
58564: ST_TO_ADDR
// end ;
58565: GO 58443
58567: POP
58568: POP
// end ; end ;
58569: LD_VAR 0 7
58573: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58574: LD_INT 0
58576: PPUSH
58577: PPUSH
58578: PPUSH
58579: PPUSH
58580: PPUSH
58581: PPUSH
58582: PPUSH
58583: PPUSH
58584: PPUSH
58585: PPUSH
58586: PPUSH
58587: PPUSH
58588: PPUSH
58589: PPUSH
58590: PPUSH
58591: PPUSH
// result := false ;
58592: LD_ADDR_VAR 0 3
58596: PUSH
58597: LD_INT 0
58599: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58600: LD_VAR 0 1
58604: NOT
58605: PUSH
58606: LD_VAR 0 1
58610: PPUSH
58611: CALL_OW 266
58615: PUSH
58616: LD_INT 32
58618: PUSH
58619: LD_INT 33
58621: PUSH
58622: EMPTY
58623: LIST
58624: LIST
58625: IN
58626: NOT
58627: OR
58628: IFFALSE 58632
// exit ;
58630: GO 59741
// nat := GetNation ( tower ) ;
58632: LD_ADDR_VAR 0 12
58636: PUSH
58637: LD_VAR 0 1
58641: PPUSH
58642: CALL_OW 248
58646: ST_TO_ADDR
// side := GetSide ( tower ) ;
58647: LD_ADDR_VAR 0 16
58651: PUSH
58652: LD_VAR 0 1
58656: PPUSH
58657: CALL_OW 255
58661: ST_TO_ADDR
// x := GetX ( tower ) ;
58662: LD_ADDR_VAR 0 10
58666: PUSH
58667: LD_VAR 0 1
58671: PPUSH
58672: CALL_OW 250
58676: ST_TO_ADDR
// y := GetY ( tower ) ;
58677: LD_ADDR_VAR 0 11
58681: PUSH
58682: LD_VAR 0 1
58686: PPUSH
58687: CALL_OW 251
58691: ST_TO_ADDR
// if not x or not y then
58692: LD_VAR 0 10
58696: NOT
58697: PUSH
58698: LD_VAR 0 11
58702: NOT
58703: OR
58704: IFFALSE 58708
// exit ;
58706: GO 59741
// weapon := 0 ;
58708: LD_ADDR_VAR 0 18
58712: PUSH
58713: LD_INT 0
58715: ST_TO_ADDR
// fac_list := [ ] ;
58716: LD_ADDR_VAR 0 17
58720: PUSH
58721: EMPTY
58722: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58723: LD_ADDR_VAR 0 6
58727: PUSH
58728: LD_VAR 0 1
58732: PPUSH
58733: CALL_OW 274
58737: PPUSH
58738: LD_VAR 0 2
58742: PPUSH
58743: LD_INT 0
58745: PPUSH
58746: CALL 56312 0 3
58750: PPUSH
58751: LD_INT 30
58753: PUSH
58754: LD_INT 3
58756: PUSH
58757: EMPTY
58758: LIST
58759: LIST
58760: PPUSH
58761: CALL_OW 72
58765: ST_TO_ADDR
// if not factories then
58766: LD_VAR 0 6
58770: NOT
58771: IFFALSE 58775
// exit ;
58773: GO 59741
// for i in factories do
58775: LD_ADDR_VAR 0 8
58779: PUSH
58780: LD_VAR 0 6
58784: PUSH
58785: FOR_IN
58786: IFFALSE 58811
// fac_list := fac_list union AvailableWeaponList ( i ) ;
58788: LD_ADDR_VAR 0 17
58792: PUSH
58793: LD_VAR 0 17
58797: PUSH
58798: LD_VAR 0 8
58802: PPUSH
58803: CALL_OW 478
58807: UNION
58808: ST_TO_ADDR
58809: GO 58785
58811: POP
58812: POP
// if not fac_list then
58813: LD_VAR 0 17
58817: NOT
58818: IFFALSE 58822
// exit ;
58820: GO 59741
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58822: LD_ADDR_VAR 0 5
58826: PUSH
58827: LD_INT 4
58829: PUSH
58830: LD_INT 5
58832: PUSH
58833: LD_INT 9
58835: PUSH
58836: LD_INT 10
58838: PUSH
58839: LD_INT 6
58841: PUSH
58842: LD_INT 7
58844: PUSH
58845: LD_INT 11
58847: PUSH
58848: EMPTY
58849: LIST
58850: LIST
58851: LIST
58852: LIST
58853: LIST
58854: LIST
58855: LIST
58856: PUSH
58857: LD_INT 27
58859: PUSH
58860: LD_INT 28
58862: PUSH
58863: LD_INT 26
58865: PUSH
58866: LD_INT 30
58868: PUSH
58869: EMPTY
58870: LIST
58871: LIST
58872: LIST
58873: LIST
58874: PUSH
58875: LD_INT 43
58877: PUSH
58878: LD_INT 44
58880: PUSH
58881: LD_INT 46
58883: PUSH
58884: LD_INT 45
58886: PUSH
58887: LD_INT 47
58889: PUSH
58890: LD_INT 49
58892: PUSH
58893: EMPTY
58894: LIST
58895: LIST
58896: LIST
58897: LIST
58898: LIST
58899: LIST
58900: PUSH
58901: EMPTY
58902: LIST
58903: LIST
58904: LIST
58905: PUSH
58906: LD_VAR 0 12
58910: ARRAY
58911: ST_TO_ADDR
// list := list isect fac_list ;
58912: LD_ADDR_VAR 0 5
58916: PUSH
58917: LD_VAR 0 5
58921: PUSH
58922: LD_VAR 0 17
58926: ISECT
58927: ST_TO_ADDR
// if not list then
58928: LD_VAR 0 5
58932: NOT
58933: IFFALSE 58937
// exit ;
58935: GO 59741
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
58937: LD_VAR 0 12
58941: PUSH
58942: LD_INT 3
58944: EQUAL
58945: PUSH
58946: LD_INT 49
58948: PUSH
58949: LD_VAR 0 5
58953: IN
58954: AND
58955: PUSH
58956: LD_INT 31
58958: PPUSH
58959: LD_VAR 0 16
58963: PPUSH
58964: CALL_OW 321
58968: PUSH
58969: LD_INT 2
58971: EQUAL
58972: AND
58973: IFFALSE 59033
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
58975: LD_INT 22
58977: PUSH
58978: LD_VAR 0 16
58982: PUSH
58983: EMPTY
58984: LIST
58985: LIST
58986: PUSH
58987: LD_INT 35
58989: PUSH
58990: LD_INT 49
58992: PUSH
58993: EMPTY
58994: LIST
58995: LIST
58996: PUSH
58997: LD_INT 91
58999: PUSH
59000: LD_VAR 0 1
59004: PUSH
59005: LD_INT 10
59007: PUSH
59008: EMPTY
59009: LIST
59010: LIST
59011: LIST
59012: PUSH
59013: EMPTY
59014: LIST
59015: LIST
59016: LIST
59017: PPUSH
59018: CALL_OW 69
59022: NOT
59023: IFFALSE 59033
// weapon := ru_time_lapser ;
59025: LD_ADDR_VAR 0 18
59029: PUSH
59030: LD_INT 49
59032: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59033: LD_VAR 0 12
59037: PUSH
59038: LD_INT 1
59040: PUSH
59041: LD_INT 2
59043: PUSH
59044: EMPTY
59045: LIST
59046: LIST
59047: IN
59048: PUSH
59049: LD_INT 11
59051: PUSH
59052: LD_VAR 0 5
59056: IN
59057: PUSH
59058: LD_INT 30
59060: PUSH
59061: LD_VAR 0 5
59065: IN
59066: OR
59067: AND
59068: PUSH
59069: LD_INT 6
59071: PPUSH
59072: LD_VAR 0 16
59076: PPUSH
59077: CALL_OW 321
59081: PUSH
59082: LD_INT 2
59084: EQUAL
59085: AND
59086: IFFALSE 59251
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59088: LD_INT 22
59090: PUSH
59091: LD_VAR 0 16
59095: PUSH
59096: EMPTY
59097: LIST
59098: LIST
59099: PUSH
59100: LD_INT 2
59102: PUSH
59103: LD_INT 35
59105: PUSH
59106: LD_INT 11
59108: PUSH
59109: EMPTY
59110: LIST
59111: LIST
59112: PUSH
59113: LD_INT 35
59115: PUSH
59116: LD_INT 30
59118: PUSH
59119: EMPTY
59120: LIST
59121: LIST
59122: PUSH
59123: EMPTY
59124: LIST
59125: LIST
59126: LIST
59127: PUSH
59128: LD_INT 91
59130: PUSH
59131: LD_VAR 0 1
59135: PUSH
59136: LD_INT 18
59138: PUSH
59139: EMPTY
59140: LIST
59141: LIST
59142: LIST
59143: PUSH
59144: EMPTY
59145: LIST
59146: LIST
59147: LIST
59148: PPUSH
59149: CALL_OW 69
59153: NOT
59154: PUSH
59155: LD_INT 22
59157: PUSH
59158: LD_VAR 0 16
59162: PUSH
59163: EMPTY
59164: LIST
59165: LIST
59166: PUSH
59167: LD_INT 2
59169: PUSH
59170: LD_INT 30
59172: PUSH
59173: LD_INT 32
59175: PUSH
59176: EMPTY
59177: LIST
59178: LIST
59179: PUSH
59180: LD_INT 30
59182: PUSH
59183: LD_INT 33
59185: PUSH
59186: EMPTY
59187: LIST
59188: LIST
59189: PUSH
59190: EMPTY
59191: LIST
59192: LIST
59193: LIST
59194: PUSH
59195: LD_INT 91
59197: PUSH
59198: LD_VAR 0 1
59202: PUSH
59203: LD_INT 12
59205: PUSH
59206: EMPTY
59207: LIST
59208: LIST
59209: LIST
59210: PUSH
59211: EMPTY
59212: LIST
59213: LIST
59214: LIST
59215: PUSH
59216: EMPTY
59217: LIST
59218: PPUSH
59219: CALL_OW 69
59223: PUSH
59224: LD_INT 2
59226: GREATER
59227: AND
59228: IFFALSE 59251
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59230: LD_ADDR_VAR 0 18
59234: PUSH
59235: LD_INT 11
59237: PUSH
59238: LD_INT 30
59240: PUSH
59241: EMPTY
59242: LIST
59243: LIST
59244: PUSH
59245: LD_VAR 0 12
59249: ARRAY
59250: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59251: LD_VAR 0 18
59255: NOT
59256: PUSH
59257: LD_INT 40
59259: PPUSH
59260: LD_VAR 0 16
59264: PPUSH
59265: CALL_OW 321
59269: PUSH
59270: LD_INT 2
59272: EQUAL
59273: AND
59274: PUSH
59275: LD_INT 7
59277: PUSH
59278: LD_VAR 0 5
59282: IN
59283: PUSH
59284: LD_INT 28
59286: PUSH
59287: LD_VAR 0 5
59291: IN
59292: OR
59293: PUSH
59294: LD_INT 45
59296: PUSH
59297: LD_VAR 0 5
59301: IN
59302: OR
59303: AND
59304: IFFALSE 59558
// begin hex := GetHexInfo ( x , y ) ;
59306: LD_ADDR_VAR 0 4
59310: PUSH
59311: LD_VAR 0 10
59315: PPUSH
59316: LD_VAR 0 11
59320: PPUSH
59321: CALL_OW 546
59325: ST_TO_ADDR
// if hex [ 1 ] then
59326: LD_VAR 0 4
59330: PUSH
59331: LD_INT 1
59333: ARRAY
59334: IFFALSE 59338
// exit ;
59336: GO 59741
// height := hex [ 2 ] ;
59338: LD_ADDR_VAR 0 15
59342: PUSH
59343: LD_VAR 0 4
59347: PUSH
59348: LD_INT 2
59350: ARRAY
59351: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59352: LD_ADDR_VAR 0 14
59356: PUSH
59357: LD_INT 0
59359: PUSH
59360: LD_INT 2
59362: PUSH
59363: LD_INT 3
59365: PUSH
59366: LD_INT 5
59368: PUSH
59369: EMPTY
59370: LIST
59371: LIST
59372: LIST
59373: LIST
59374: ST_TO_ADDR
// for i in tmp do
59375: LD_ADDR_VAR 0 8
59379: PUSH
59380: LD_VAR 0 14
59384: PUSH
59385: FOR_IN
59386: IFFALSE 59556
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59388: LD_ADDR_VAR 0 9
59392: PUSH
59393: LD_VAR 0 10
59397: PPUSH
59398: LD_VAR 0 8
59402: PPUSH
59403: LD_INT 5
59405: PPUSH
59406: CALL_OW 272
59410: PUSH
59411: LD_VAR 0 11
59415: PPUSH
59416: LD_VAR 0 8
59420: PPUSH
59421: LD_INT 5
59423: PPUSH
59424: CALL_OW 273
59428: PUSH
59429: EMPTY
59430: LIST
59431: LIST
59432: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59433: LD_VAR 0 9
59437: PUSH
59438: LD_INT 1
59440: ARRAY
59441: PPUSH
59442: LD_VAR 0 9
59446: PUSH
59447: LD_INT 2
59449: ARRAY
59450: PPUSH
59451: CALL_OW 488
59455: IFFALSE 59554
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59457: LD_ADDR_VAR 0 4
59461: PUSH
59462: LD_VAR 0 9
59466: PUSH
59467: LD_INT 1
59469: ARRAY
59470: PPUSH
59471: LD_VAR 0 9
59475: PUSH
59476: LD_INT 2
59478: ARRAY
59479: PPUSH
59480: CALL_OW 546
59484: ST_TO_ADDR
// if hex [ 1 ] then
59485: LD_VAR 0 4
59489: PUSH
59490: LD_INT 1
59492: ARRAY
59493: IFFALSE 59497
// continue ;
59495: GO 59385
// h := hex [ 2 ] ;
59497: LD_ADDR_VAR 0 13
59501: PUSH
59502: LD_VAR 0 4
59506: PUSH
59507: LD_INT 2
59509: ARRAY
59510: ST_TO_ADDR
// if h + 7 < height then
59511: LD_VAR 0 13
59515: PUSH
59516: LD_INT 7
59518: PLUS
59519: PUSH
59520: LD_VAR 0 15
59524: LESS
59525: IFFALSE 59554
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59527: LD_ADDR_VAR 0 18
59531: PUSH
59532: LD_INT 7
59534: PUSH
59535: LD_INT 28
59537: PUSH
59538: LD_INT 45
59540: PUSH
59541: EMPTY
59542: LIST
59543: LIST
59544: LIST
59545: PUSH
59546: LD_VAR 0 12
59550: ARRAY
59551: ST_TO_ADDR
// break ;
59552: GO 59556
// end ; end ; end ;
59554: GO 59385
59556: POP
59557: POP
// end ; if not weapon then
59558: LD_VAR 0 18
59562: NOT
59563: IFFALSE 59623
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59565: LD_ADDR_VAR 0 5
59569: PUSH
59570: LD_VAR 0 5
59574: PUSH
59575: LD_INT 11
59577: PUSH
59578: LD_INT 30
59580: PUSH
59581: LD_INT 49
59583: PUSH
59584: EMPTY
59585: LIST
59586: LIST
59587: LIST
59588: DIFF
59589: ST_TO_ADDR
// if not list then
59590: LD_VAR 0 5
59594: NOT
59595: IFFALSE 59599
// exit ;
59597: GO 59741
// weapon := list [ rand ( 1 , list ) ] ;
59599: LD_ADDR_VAR 0 18
59603: PUSH
59604: LD_VAR 0 5
59608: PUSH
59609: LD_INT 1
59611: PPUSH
59612: LD_VAR 0 5
59616: PPUSH
59617: CALL_OW 12
59621: ARRAY
59622: ST_TO_ADDR
// end ; if weapon then
59623: LD_VAR 0 18
59627: IFFALSE 59741
// begin tmp := CostOfWeapon ( weapon ) ;
59629: LD_ADDR_VAR 0 14
59633: PUSH
59634: LD_VAR 0 18
59638: PPUSH
59639: CALL_OW 451
59643: ST_TO_ADDR
// j := GetBase ( tower ) ;
59644: LD_ADDR_VAR 0 9
59648: PUSH
59649: LD_VAR 0 1
59653: PPUSH
59654: CALL_OW 274
59658: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59659: LD_VAR 0 9
59663: PPUSH
59664: LD_INT 1
59666: PPUSH
59667: CALL_OW 275
59671: PUSH
59672: LD_VAR 0 14
59676: PUSH
59677: LD_INT 1
59679: ARRAY
59680: GREATEREQUAL
59681: PUSH
59682: LD_VAR 0 9
59686: PPUSH
59687: LD_INT 2
59689: PPUSH
59690: CALL_OW 275
59694: PUSH
59695: LD_VAR 0 14
59699: PUSH
59700: LD_INT 2
59702: ARRAY
59703: GREATEREQUAL
59704: AND
59705: PUSH
59706: LD_VAR 0 9
59710: PPUSH
59711: LD_INT 3
59713: PPUSH
59714: CALL_OW 275
59718: PUSH
59719: LD_VAR 0 14
59723: PUSH
59724: LD_INT 3
59726: ARRAY
59727: GREATEREQUAL
59728: AND
59729: IFFALSE 59741
// result := weapon ;
59731: LD_ADDR_VAR 0 3
59735: PUSH
59736: LD_VAR 0 18
59740: ST_TO_ADDR
// end ; end ;
59741: LD_VAR 0 3
59745: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59746: LD_INT 0
59748: PPUSH
59749: PPUSH
// result := true ;
59750: LD_ADDR_VAR 0 3
59754: PUSH
59755: LD_INT 1
59757: ST_TO_ADDR
// if array1 = array2 then
59758: LD_VAR 0 1
59762: PUSH
59763: LD_VAR 0 2
59767: EQUAL
59768: IFFALSE 59828
// begin for i = 1 to array1 do
59770: LD_ADDR_VAR 0 4
59774: PUSH
59775: DOUBLE
59776: LD_INT 1
59778: DEC
59779: ST_TO_ADDR
59780: LD_VAR 0 1
59784: PUSH
59785: FOR_TO
59786: IFFALSE 59824
// if array1 [ i ] <> array2 [ i ] then
59788: LD_VAR 0 1
59792: PUSH
59793: LD_VAR 0 4
59797: ARRAY
59798: PUSH
59799: LD_VAR 0 2
59803: PUSH
59804: LD_VAR 0 4
59808: ARRAY
59809: NONEQUAL
59810: IFFALSE 59822
// begin result := false ;
59812: LD_ADDR_VAR 0 3
59816: PUSH
59817: LD_INT 0
59819: ST_TO_ADDR
// break ;
59820: GO 59824
// end ;
59822: GO 59785
59824: POP
59825: POP
// end else
59826: GO 59836
// result := false ;
59828: LD_ADDR_VAR 0 3
59832: PUSH
59833: LD_INT 0
59835: ST_TO_ADDR
// end ;
59836: LD_VAR 0 3
59840: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
59841: LD_INT 0
59843: PPUSH
59844: PPUSH
// if not array1 or not array2 then
59845: LD_VAR 0 1
59849: NOT
59850: PUSH
59851: LD_VAR 0 2
59855: NOT
59856: OR
59857: IFFALSE 59861
// exit ;
59859: GO 59925
// result := true ;
59861: LD_ADDR_VAR 0 3
59865: PUSH
59866: LD_INT 1
59868: ST_TO_ADDR
// for i = 1 to array1 do
59869: LD_ADDR_VAR 0 4
59873: PUSH
59874: DOUBLE
59875: LD_INT 1
59877: DEC
59878: ST_TO_ADDR
59879: LD_VAR 0 1
59883: PUSH
59884: FOR_TO
59885: IFFALSE 59923
// if array1 [ i ] <> array2 [ i ] then
59887: LD_VAR 0 1
59891: PUSH
59892: LD_VAR 0 4
59896: ARRAY
59897: PUSH
59898: LD_VAR 0 2
59902: PUSH
59903: LD_VAR 0 4
59907: ARRAY
59908: NONEQUAL
59909: IFFALSE 59921
// begin result := false ;
59911: LD_ADDR_VAR 0 3
59915: PUSH
59916: LD_INT 0
59918: ST_TO_ADDR
// break ;
59919: GO 59923
// end ;
59921: GO 59884
59923: POP
59924: POP
// end ;
59925: LD_VAR 0 3
59929: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
59930: LD_INT 0
59932: PPUSH
59933: PPUSH
59934: PPUSH
// pom := GetBase ( fac ) ;
59935: LD_ADDR_VAR 0 5
59939: PUSH
59940: LD_VAR 0 1
59944: PPUSH
59945: CALL_OW 274
59949: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
59950: LD_ADDR_VAR 0 4
59954: PUSH
59955: LD_VAR 0 2
59959: PUSH
59960: LD_INT 1
59962: ARRAY
59963: PPUSH
59964: LD_VAR 0 2
59968: PUSH
59969: LD_INT 2
59971: ARRAY
59972: PPUSH
59973: LD_VAR 0 2
59977: PUSH
59978: LD_INT 3
59980: ARRAY
59981: PPUSH
59982: LD_VAR 0 2
59986: PUSH
59987: LD_INT 4
59989: ARRAY
59990: PPUSH
59991: CALL_OW 449
59995: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59996: LD_ADDR_VAR 0 3
60000: PUSH
60001: LD_VAR 0 5
60005: PPUSH
60006: LD_INT 1
60008: PPUSH
60009: CALL_OW 275
60013: PUSH
60014: LD_VAR 0 4
60018: PUSH
60019: LD_INT 1
60021: ARRAY
60022: GREATEREQUAL
60023: PUSH
60024: LD_VAR 0 5
60028: PPUSH
60029: LD_INT 2
60031: PPUSH
60032: CALL_OW 275
60036: PUSH
60037: LD_VAR 0 4
60041: PUSH
60042: LD_INT 2
60044: ARRAY
60045: GREATEREQUAL
60046: AND
60047: PUSH
60048: LD_VAR 0 5
60052: PPUSH
60053: LD_INT 3
60055: PPUSH
60056: CALL_OW 275
60060: PUSH
60061: LD_VAR 0 4
60065: PUSH
60066: LD_INT 3
60068: ARRAY
60069: GREATEREQUAL
60070: AND
60071: ST_TO_ADDR
// end ;
60072: LD_VAR 0 3
60076: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60077: LD_INT 0
60079: PPUSH
60080: PPUSH
60081: PPUSH
60082: PPUSH
// pom := GetBase ( building ) ;
60083: LD_ADDR_VAR 0 3
60087: PUSH
60088: LD_VAR 0 1
60092: PPUSH
60093: CALL_OW 274
60097: ST_TO_ADDR
// if not pom then
60098: LD_VAR 0 3
60102: NOT
60103: IFFALSE 60107
// exit ;
60105: GO 60277
// btype := GetBType ( building ) ;
60107: LD_ADDR_VAR 0 5
60111: PUSH
60112: LD_VAR 0 1
60116: PPUSH
60117: CALL_OW 266
60121: ST_TO_ADDR
// if btype = b_armoury then
60122: LD_VAR 0 5
60126: PUSH
60127: LD_INT 4
60129: EQUAL
60130: IFFALSE 60140
// btype := b_barracks ;
60132: LD_ADDR_VAR 0 5
60136: PUSH
60137: LD_INT 5
60139: ST_TO_ADDR
// if btype = b_depot then
60140: LD_VAR 0 5
60144: PUSH
60145: LD_INT 0
60147: EQUAL
60148: IFFALSE 60158
// btype := b_warehouse ;
60150: LD_ADDR_VAR 0 5
60154: PUSH
60155: LD_INT 1
60157: ST_TO_ADDR
// if btype = b_workshop then
60158: LD_VAR 0 5
60162: PUSH
60163: LD_INT 2
60165: EQUAL
60166: IFFALSE 60176
// btype := b_factory ;
60168: LD_ADDR_VAR 0 5
60172: PUSH
60173: LD_INT 3
60175: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60176: LD_ADDR_VAR 0 4
60180: PUSH
60181: LD_VAR 0 5
60185: PPUSH
60186: LD_VAR 0 1
60190: PPUSH
60191: CALL_OW 248
60195: PPUSH
60196: CALL_OW 450
60200: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60201: LD_ADDR_VAR 0 2
60205: PUSH
60206: LD_VAR 0 3
60210: PPUSH
60211: LD_INT 1
60213: PPUSH
60214: CALL_OW 275
60218: PUSH
60219: LD_VAR 0 4
60223: PUSH
60224: LD_INT 1
60226: ARRAY
60227: GREATEREQUAL
60228: PUSH
60229: LD_VAR 0 3
60233: PPUSH
60234: LD_INT 2
60236: PPUSH
60237: CALL_OW 275
60241: PUSH
60242: LD_VAR 0 4
60246: PUSH
60247: LD_INT 2
60249: ARRAY
60250: GREATEREQUAL
60251: AND
60252: PUSH
60253: LD_VAR 0 3
60257: PPUSH
60258: LD_INT 3
60260: PPUSH
60261: CALL_OW 275
60265: PUSH
60266: LD_VAR 0 4
60270: PUSH
60271: LD_INT 3
60273: ARRAY
60274: GREATEREQUAL
60275: AND
60276: ST_TO_ADDR
// end ;
60277: LD_VAR 0 2
60281: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60282: LD_INT 0
60284: PPUSH
60285: PPUSH
60286: PPUSH
// pom := GetBase ( building ) ;
60287: LD_ADDR_VAR 0 4
60291: PUSH
60292: LD_VAR 0 1
60296: PPUSH
60297: CALL_OW 274
60301: ST_TO_ADDR
// if not pom then
60302: LD_VAR 0 4
60306: NOT
60307: IFFALSE 60311
// exit ;
60309: GO 60412
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60311: LD_ADDR_VAR 0 5
60315: PUSH
60316: LD_VAR 0 2
60320: PPUSH
60321: LD_VAR 0 1
60325: PPUSH
60326: CALL_OW 248
60330: PPUSH
60331: CALL_OW 450
60335: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60336: LD_ADDR_VAR 0 3
60340: PUSH
60341: LD_VAR 0 4
60345: PPUSH
60346: LD_INT 1
60348: PPUSH
60349: CALL_OW 275
60353: PUSH
60354: LD_VAR 0 5
60358: PUSH
60359: LD_INT 1
60361: ARRAY
60362: GREATEREQUAL
60363: PUSH
60364: LD_VAR 0 4
60368: PPUSH
60369: LD_INT 2
60371: PPUSH
60372: CALL_OW 275
60376: PUSH
60377: LD_VAR 0 5
60381: PUSH
60382: LD_INT 2
60384: ARRAY
60385: GREATEREQUAL
60386: AND
60387: PUSH
60388: LD_VAR 0 4
60392: PPUSH
60393: LD_INT 3
60395: PPUSH
60396: CALL_OW 275
60400: PUSH
60401: LD_VAR 0 5
60405: PUSH
60406: LD_INT 3
60408: ARRAY
60409: GREATEREQUAL
60410: AND
60411: ST_TO_ADDR
// end ;
60412: LD_VAR 0 3
60416: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60417: LD_INT 0
60419: PPUSH
60420: PPUSH
60421: PPUSH
60422: PPUSH
60423: PPUSH
60424: PPUSH
60425: PPUSH
60426: PPUSH
60427: PPUSH
60428: PPUSH
60429: PPUSH
// result := false ;
60430: LD_ADDR_VAR 0 8
60434: PUSH
60435: LD_INT 0
60437: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60438: LD_VAR 0 5
60442: NOT
60443: PUSH
60444: LD_VAR 0 1
60448: NOT
60449: OR
60450: PUSH
60451: LD_VAR 0 2
60455: NOT
60456: OR
60457: PUSH
60458: LD_VAR 0 3
60462: NOT
60463: OR
60464: IFFALSE 60468
// exit ;
60466: GO 61282
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60468: LD_ADDR_VAR 0 14
60472: PUSH
60473: LD_VAR 0 1
60477: PPUSH
60478: LD_VAR 0 2
60482: PPUSH
60483: LD_VAR 0 3
60487: PPUSH
60488: LD_VAR 0 4
60492: PPUSH
60493: LD_VAR 0 5
60497: PUSH
60498: LD_INT 1
60500: ARRAY
60501: PPUSH
60502: CALL_OW 248
60506: PPUSH
60507: LD_INT 0
60509: PPUSH
60510: CALL 62519 0 6
60514: ST_TO_ADDR
// if not hexes then
60515: LD_VAR 0 14
60519: NOT
60520: IFFALSE 60524
// exit ;
60522: GO 61282
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60524: LD_ADDR_VAR 0 17
60528: PUSH
60529: LD_VAR 0 5
60533: PPUSH
60534: LD_INT 22
60536: PUSH
60537: LD_VAR 0 13
60541: PPUSH
60542: CALL_OW 255
60546: PUSH
60547: EMPTY
60548: LIST
60549: LIST
60550: PUSH
60551: LD_INT 2
60553: PUSH
60554: LD_INT 30
60556: PUSH
60557: LD_INT 0
60559: PUSH
60560: EMPTY
60561: LIST
60562: LIST
60563: PUSH
60564: LD_INT 30
60566: PUSH
60567: LD_INT 1
60569: PUSH
60570: EMPTY
60571: LIST
60572: LIST
60573: PUSH
60574: EMPTY
60575: LIST
60576: LIST
60577: LIST
60578: PUSH
60579: EMPTY
60580: LIST
60581: LIST
60582: PPUSH
60583: CALL_OW 72
60587: ST_TO_ADDR
// for i = 1 to hexes do
60588: LD_ADDR_VAR 0 9
60592: PUSH
60593: DOUBLE
60594: LD_INT 1
60596: DEC
60597: ST_TO_ADDR
60598: LD_VAR 0 14
60602: PUSH
60603: FOR_TO
60604: IFFALSE 61280
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60606: LD_ADDR_VAR 0 13
60610: PUSH
60611: LD_VAR 0 14
60615: PUSH
60616: LD_VAR 0 9
60620: ARRAY
60621: PUSH
60622: LD_INT 1
60624: ARRAY
60625: PPUSH
60626: LD_VAR 0 14
60630: PUSH
60631: LD_VAR 0 9
60635: ARRAY
60636: PUSH
60637: LD_INT 2
60639: ARRAY
60640: PPUSH
60641: CALL_OW 428
60645: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60646: LD_VAR 0 14
60650: PUSH
60651: LD_VAR 0 9
60655: ARRAY
60656: PUSH
60657: LD_INT 1
60659: ARRAY
60660: PPUSH
60661: LD_VAR 0 14
60665: PUSH
60666: LD_VAR 0 9
60670: ARRAY
60671: PUSH
60672: LD_INT 2
60674: ARRAY
60675: PPUSH
60676: CALL_OW 351
60680: PUSH
60681: LD_VAR 0 14
60685: PUSH
60686: LD_VAR 0 9
60690: ARRAY
60691: PUSH
60692: LD_INT 1
60694: ARRAY
60695: PPUSH
60696: LD_VAR 0 14
60700: PUSH
60701: LD_VAR 0 9
60705: ARRAY
60706: PUSH
60707: LD_INT 2
60709: ARRAY
60710: PPUSH
60711: CALL_OW 488
60715: NOT
60716: OR
60717: PUSH
60718: LD_VAR 0 13
60722: PPUSH
60723: CALL_OW 247
60727: PUSH
60728: LD_INT 3
60730: EQUAL
60731: OR
60732: IFFALSE 60738
// exit ;
60734: POP
60735: POP
60736: GO 61282
// if not tmp then
60738: LD_VAR 0 13
60742: NOT
60743: IFFALSE 60747
// continue ;
60745: GO 60603
// result := true ;
60747: LD_ADDR_VAR 0 8
60751: PUSH
60752: LD_INT 1
60754: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60755: LD_VAR 0 6
60759: PUSH
60760: LD_VAR 0 13
60764: PPUSH
60765: CALL_OW 247
60769: PUSH
60770: LD_INT 2
60772: EQUAL
60773: AND
60774: PUSH
60775: LD_VAR 0 13
60779: PPUSH
60780: CALL_OW 263
60784: PUSH
60785: LD_INT 1
60787: EQUAL
60788: AND
60789: IFFALSE 60953
// begin if IsDrivenBy ( tmp ) then
60791: LD_VAR 0 13
60795: PPUSH
60796: CALL_OW 311
60800: IFFALSE 60804
// continue ;
60802: GO 60603
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
60804: LD_VAR 0 6
60808: PPUSH
60809: LD_INT 3
60811: PUSH
60812: LD_INT 60
60814: PUSH
60815: EMPTY
60816: LIST
60817: PUSH
60818: EMPTY
60819: LIST
60820: LIST
60821: PUSH
60822: LD_INT 3
60824: PUSH
60825: LD_INT 55
60827: PUSH
60828: EMPTY
60829: LIST
60830: PUSH
60831: EMPTY
60832: LIST
60833: LIST
60834: PUSH
60835: EMPTY
60836: LIST
60837: LIST
60838: PPUSH
60839: CALL_OW 72
60843: IFFALSE 60951
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
60845: LD_ADDR_VAR 0 18
60849: PUSH
60850: LD_VAR 0 6
60854: PPUSH
60855: LD_INT 3
60857: PUSH
60858: LD_INT 60
60860: PUSH
60861: EMPTY
60862: LIST
60863: PUSH
60864: EMPTY
60865: LIST
60866: LIST
60867: PUSH
60868: LD_INT 3
60870: PUSH
60871: LD_INT 55
60873: PUSH
60874: EMPTY
60875: LIST
60876: PUSH
60877: EMPTY
60878: LIST
60879: LIST
60880: PUSH
60881: EMPTY
60882: LIST
60883: LIST
60884: PPUSH
60885: CALL_OW 72
60889: PUSH
60890: LD_INT 1
60892: ARRAY
60893: ST_TO_ADDR
// if IsInUnit ( driver ) then
60894: LD_VAR 0 18
60898: PPUSH
60899: CALL_OW 310
60903: IFFALSE 60914
// ComExit ( driver ) ;
60905: LD_VAR 0 18
60909: PPUSH
60910: CALL 85647 0 1
// AddComEnterUnit ( driver , tmp ) ;
60914: LD_VAR 0 18
60918: PPUSH
60919: LD_VAR 0 13
60923: PPUSH
60924: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
60928: LD_VAR 0 18
60932: PPUSH
60933: LD_VAR 0 7
60937: PPUSH
60938: CALL_OW 173
// AddComExitVehicle ( driver ) ;
60942: LD_VAR 0 18
60946: PPUSH
60947: CALL_OW 181
// end ; continue ;
60951: GO 60603
// end ; if not cleaners or not tmp in cleaners then
60953: LD_VAR 0 6
60957: NOT
60958: PUSH
60959: LD_VAR 0 13
60963: PUSH
60964: LD_VAR 0 6
60968: IN
60969: NOT
60970: OR
60971: IFFALSE 61278
// begin if dep then
60973: LD_VAR 0 17
60977: IFFALSE 61113
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
60979: LD_ADDR_VAR 0 16
60983: PUSH
60984: LD_VAR 0 17
60988: PUSH
60989: LD_INT 1
60991: ARRAY
60992: PPUSH
60993: CALL_OW 250
60997: PPUSH
60998: LD_VAR 0 17
61002: PUSH
61003: LD_INT 1
61005: ARRAY
61006: PPUSH
61007: CALL_OW 254
61011: PPUSH
61012: LD_INT 5
61014: PPUSH
61015: CALL_OW 272
61019: PUSH
61020: LD_VAR 0 17
61024: PUSH
61025: LD_INT 1
61027: ARRAY
61028: PPUSH
61029: CALL_OW 251
61033: PPUSH
61034: LD_VAR 0 17
61038: PUSH
61039: LD_INT 1
61041: ARRAY
61042: PPUSH
61043: CALL_OW 254
61047: PPUSH
61048: LD_INT 5
61050: PPUSH
61051: CALL_OW 273
61055: PUSH
61056: EMPTY
61057: LIST
61058: LIST
61059: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61060: LD_VAR 0 16
61064: PUSH
61065: LD_INT 1
61067: ARRAY
61068: PPUSH
61069: LD_VAR 0 16
61073: PUSH
61074: LD_INT 2
61076: ARRAY
61077: PPUSH
61078: CALL_OW 488
61082: IFFALSE 61113
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61084: LD_VAR 0 13
61088: PPUSH
61089: LD_VAR 0 16
61093: PUSH
61094: LD_INT 1
61096: ARRAY
61097: PPUSH
61098: LD_VAR 0 16
61102: PUSH
61103: LD_INT 2
61105: ARRAY
61106: PPUSH
61107: CALL_OW 111
// continue ;
61111: GO 60603
// end ; end ; r := GetDir ( tmp ) ;
61113: LD_ADDR_VAR 0 15
61117: PUSH
61118: LD_VAR 0 13
61122: PPUSH
61123: CALL_OW 254
61127: ST_TO_ADDR
// if r = 5 then
61128: LD_VAR 0 15
61132: PUSH
61133: LD_INT 5
61135: EQUAL
61136: IFFALSE 61146
// r := 0 ;
61138: LD_ADDR_VAR 0 15
61142: PUSH
61143: LD_INT 0
61145: ST_TO_ADDR
// for j = r to 5 do
61146: LD_ADDR_VAR 0 10
61150: PUSH
61151: DOUBLE
61152: LD_VAR 0 15
61156: DEC
61157: ST_TO_ADDR
61158: LD_INT 5
61160: PUSH
61161: FOR_TO
61162: IFFALSE 61276
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61164: LD_ADDR_VAR 0 11
61168: PUSH
61169: LD_VAR 0 13
61173: PPUSH
61174: CALL_OW 250
61178: PPUSH
61179: LD_VAR 0 10
61183: PPUSH
61184: LD_INT 2
61186: PPUSH
61187: CALL_OW 272
61191: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61192: LD_ADDR_VAR 0 12
61196: PUSH
61197: LD_VAR 0 13
61201: PPUSH
61202: CALL_OW 251
61206: PPUSH
61207: LD_VAR 0 10
61211: PPUSH
61212: LD_INT 2
61214: PPUSH
61215: CALL_OW 273
61219: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61220: LD_VAR 0 11
61224: PPUSH
61225: LD_VAR 0 12
61229: PPUSH
61230: CALL_OW 488
61234: PUSH
61235: LD_VAR 0 11
61239: PPUSH
61240: LD_VAR 0 12
61244: PPUSH
61245: CALL_OW 428
61249: NOT
61250: AND
61251: IFFALSE 61274
// begin ComMoveXY ( tmp , _x , _y ) ;
61253: LD_VAR 0 13
61257: PPUSH
61258: LD_VAR 0 11
61262: PPUSH
61263: LD_VAR 0 12
61267: PPUSH
61268: CALL_OW 111
// break ;
61272: GO 61276
// end ; end ;
61274: GO 61161
61276: POP
61277: POP
// end ; end ;
61278: GO 60603
61280: POP
61281: POP
// end ;
61282: LD_VAR 0 8
61286: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61287: LD_INT 0
61289: PPUSH
// result := true ;
61290: LD_ADDR_VAR 0 3
61294: PUSH
61295: LD_INT 1
61297: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61298: LD_VAR 0 2
61302: PUSH
61303: LD_INT 24
61305: DOUBLE
61306: EQUAL
61307: IFTRUE 61317
61309: LD_INT 33
61311: DOUBLE
61312: EQUAL
61313: IFTRUE 61317
61315: GO 61342
61317: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61318: LD_ADDR_VAR 0 3
61322: PUSH
61323: LD_INT 32
61325: PPUSH
61326: LD_VAR 0 1
61330: PPUSH
61331: CALL_OW 321
61335: PUSH
61336: LD_INT 2
61338: EQUAL
61339: ST_TO_ADDR
61340: GO 61662
61342: LD_INT 20
61344: DOUBLE
61345: EQUAL
61346: IFTRUE 61350
61348: GO 61375
61350: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61351: LD_ADDR_VAR 0 3
61355: PUSH
61356: LD_INT 6
61358: PPUSH
61359: LD_VAR 0 1
61363: PPUSH
61364: CALL_OW 321
61368: PUSH
61369: LD_INT 2
61371: EQUAL
61372: ST_TO_ADDR
61373: GO 61662
61375: LD_INT 22
61377: DOUBLE
61378: EQUAL
61379: IFTRUE 61389
61381: LD_INT 36
61383: DOUBLE
61384: EQUAL
61385: IFTRUE 61389
61387: GO 61414
61389: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61390: LD_ADDR_VAR 0 3
61394: PUSH
61395: LD_INT 15
61397: PPUSH
61398: LD_VAR 0 1
61402: PPUSH
61403: CALL_OW 321
61407: PUSH
61408: LD_INT 2
61410: EQUAL
61411: ST_TO_ADDR
61412: GO 61662
61414: LD_INT 30
61416: DOUBLE
61417: EQUAL
61418: IFTRUE 61422
61420: GO 61447
61422: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61423: LD_ADDR_VAR 0 3
61427: PUSH
61428: LD_INT 20
61430: PPUSH
61431: LD_VAR 0 1
61435: PPUSH
61436: CALL_OW 321
61440: PUSH
61441: LD_INT 2
61443: EQUAL
61444: ST_TO_ADDR
61445: GO 61662
61447: LD_INT 28
61449: DOUBLE
61450: EQUAL
61451: IFTRUE 61461
61453: LD_INT 21
61455: DOUBLE
61456: EQUAL
61457: IFTRUE 61461
61459: GO 61486
61461: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61462: LD_ADDR_VAR 0 3
61466: PUSH
61467: LD_INT 21
61469: PPUSH
61470: LD_VAR 0 1
61474: PPUSH
61475: CALL_OW 321
61479: PUSH
61480: LD_INT 2
61482: EQUAL
61483: ST_TO_ADDR
61484: GO 61662
61486: LD_INT 16
61488: DOUBLE
61489: EQUAL
61490: IFTRUE 61494
61492: GO 61521
61494: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61495: LD_ADDR_VAR 0 3
61499: PUSH
61500: LD_EXP 106
61504: PPUSH
61505: LD_VAR 0 1
61509: PPUSH
61510: CALL_OW 321
61514: PUSH
61515: LD_INT 2
61517: EQUAL
61518: ST_TO_ADDR
61519: GO 61662
61521: LD_INT 19
61523: DOUBLE
61524: EQUAL
61525: IFTRUE 61535
61527: LD_INT 23
61529: DOUBLE
61530: EQUAL
61531: IFTRUE 61535
61533: GO 61562
61535: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61536: LD_ADDR_VAR 0 3
61540: PUSH
61541: LD_EXP 105
61545: PPUSH
61546: LD_VAR 0 1
61550: PPUSH
61551: CALL_OW 321
61555: PUSH
61556: LD_INT 2
61558: EQUAL
61559: ST_TO_ADDR
61560: GO 61662
61562: LD_INT 17
61564: DOUBLE
61565: EQUAL
61566: IFTRUE 61570
61568: GO 61595
61570: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61571: LD_ADDR_VAR 0 3
61575: PUSH
61576: LD_INT 39
61578: PPUSH
61579: LD_VAR 0 1
61583: PPUSH
61584: CALL_OW 321
61588: PUSH
61589: LD_INT 2
61591: EQUAL
61592: ST_TO_ADDR
61593: GO 61662
61595: LD_INT 18
61597: DOUBLE
61598: EQUAL
61599: IFTRUE 61603
61601: GO 61628
61603: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61604: LD_ADDR_VAR 0 3
61608: PUSH
61609: LD_INT 40
61611: PPUSH
61612: LD_VAR 0 1
61616: PPUSH
61617: CALL_OW 321
61621: PUSH
61622: LD_INT 2
61624: EQUAL
61625: ST_TO_ADDR
61626: GO 61662
61628: LD_INT 27
61630: DOUBLE
61631: EQUAL
61632: IFTRUE 61636
61634: GO 61661
61636: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61637: LD_ADDR_VAR 0 3
61641: PUSH
61642: LD_INT 35
61644: PPUSH
61645: LD_VAR 0 1
61649: PPUSH
61650: CALL_OW 321
61654: PUSH
61655: LD_INT 2
61657: EQUAL
61658: ST_TO_ADDR
61659: GO 61662
61661: POP
// end ;
61662: LD_VAR 0 3
61666: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61667: LD_INT 0
61669: PPUSH
61670: PPUSH
61671: PPUSH
61672: PPUSH
61673: PPUSH
61674: PPUSH
61675: PPUSH
61676: PPUSH
61677: PPUSH
61678: PPUSH
61679: PPUSH
// result := false ;
61680: LD_ADDR_VAR 0 6
61684: PUSH
61685: LD_INT 0
61687: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61688: LD_VAR 0 1
61692: NOT
61693: PUSH
61694: LD_VAR 0 1
61698: PPUSH
61699: CALL_OW 266
61703: PUSH
61704: LD_INT 0
61706: PUSH
61707: LD_INT 1
61709: PUSH
61710: EMPTY
61711: LIST
61712: LIST
61713: IN
61714: NOT
61715: OR
61716: PUSH
61717: LD_VAR 0 2
61721: NOT
61722: OR
61723: PUSH
61724: LD_VAR 0 5
61728: PUSH
61729: LD_INT 0
61731: PUSH
61732: LD_INT 1
61734: PUSH
61735: LD_INT 2
61737: PUSH
61738: LD_INT 3
61740: PUSH
61741: LD_INT 4
61743: PUSH
61744: LD_INT 5
61746: PUSH
61747: EMPTY
61748: LIST
61749: LIST
61750: LIST
61751: LIST
61752: LIST
61753: LIST
61754: IN
61755: NOT
61756: OR
61757: PUSH
61758: LD_VAR 0 3
61762: PPUSH
61763: LD_VAR 0 4
61767: PPUSH
61768: CALL_OW 488
61772: NOT
61773: OR
61774: IFFALSE 61778
// exit ;
61776: GO 62514
// side := GetSide ( depot ) ;
61778: LD_ADDR_VAR 0 9
61782: PUSH
61783: LD_VAR 0 1
61787: PPUSH
61788: CALL_OW 255
61792: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
61793: LD_VAR 0 9
61797: PPUSH
61798: LD_VAR 0 2
61802: PPUSH
61803: CALL 61287 0 2
61807: NOT
61808: IFFALSE 61812
// exit ;
61810: GO 62514
// pom := GetBase ( depot ) ;
61812: LD_ADDR_VAR 0 10
61816: PUSH
61817: LD_VAR 0 1
61821: PPUSH
61822: CALL_OW 274
61826: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
61827: LD_ADDR_VAR 0 11
61831: PUSH
61832: LD_VAR 0 2
61836: PPUSH
61837: LD_VAR 0 1
61841: PPUSH
61842: CALL_OW 248
61846: PPUSH
61847: CALL_OW 450
61851: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
61852: LD_VAR 0 10
61856: PPUSH
61857: LD_INT 1
61859: PPUSH
61860: CALL_OW 275
61864: PUSH
61865: LD_VAR 0 11
61869: PUSH
61870: LD_INT 1
61872: ARRAY
61873: GREATEREQUAL
61874: PUSH
61875: LD_VAR 0 10
61879: PPUSH
61880: LD_INT 2
61882: PPUSH
61883: CALL_OW 275
61887: PUSH
61888: LD_VAR 0 11
61892: PUSH
61893: LD_INT 2
61895: ARRAY
61896: GREATEREQUAL
61897: AND
61898: PUSH
61899: LD_VAR 0 10
61903: PPUSH
61904: LD_INT 3
61906: PPUSH
61907: CALL_OW 275
61911: PUSH
61912: LD_VAR 0 11
61916: PUSH
61917: LD_INT 3
61919: ARRAY
61920: GREATEREQUAL
61921: AND
61922: NOT
61923: IFFALSE 61927
// exit ;
61925: GO 62514
// if GetBType ( depot ) = b_depot then
61927: LD_VAR 0 1
61931: PPUSH
61932: CALL_OW 266
61936: PUSH
61937: LD_INT 0
61939: EQUAL
61940: IFFALSE 61952
// dist := 28 else
61942: LD_ADDR_VAR 0 14
61946: PUSH
61947: LD_INT 28
61949: ST_TO_ADDR
61950: GO 61960
// dist := 36 ;
61952: LD_ADDR_VAR 0 14
61956: PUSH
61957: LD_INT 36
61959: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
61960: LD_VAR 0 1
61964: PPUSH
61965: LD_VAR 0 3
61969: PPUSH
61970: LD_VAR 0 4
61974: PPUSH
61975: CALL_OW 297
61979: PUSH
61980: LD_VAR 0 14
61984: GREATER
61985: IFFALSE 61989
// exit ;
61987: GO 62514
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
61989: LD_ADDR_VAR 0 12
61993: PUSH
61994: LD_VAR 0 2
61998: PPUSH
61999: LD_VAR 0 3
62003: PPUSH
62004: LD_VAR 0 4
62008: PPUSH
62009: LD_VAR 0 5
62013: PPUSH
62014: LD_VAR 0 1
62018: PPUSH
62019: CALL_OW 248
62023: PPUSH
62024: LD_INT 0
62026: PPUSH
62027: CALL 62519 0 6
62031: ST_TO_ADDR
// if not hexes then
62032: LD_VAR 0 12
62036: NOT
62037: IFFALSE 62041
// exit ;
62039: GO 62514
// hex := GetHexInfo ( x , y ) ;
62041: LD_ADDR_VAR 0 15
62045: PUSH
62046: LD_VAR 0 3
62050: PPUSH
62051: LD_VAR 0 4
62055: PPUSH
62056: CALL_OW 546
62060: ST_TO_ADDR
// if hex [ 1 ] then
62061: LD_VAR 0 15
62065: PUSH
62066: LD_INT 1
62068: ARRAY
62069: IFFALSE 62073
// exit ;
62071: GO 62514
// height := hex [ 2 ] ;
62073: LD_ADDR_VAR 0 13
62077: PUSH
62078: LD_VAR 0 15
62082: PUSH
62083: LD_INT 2
62085: ARRAY
62086: ST_TO_ADDR
// for i = 1 to hexes do
62087: LD_ADDR_VAR 0 7
62091: PUSH
62092: DOUBLE
62093: LD_INT 1
62095: DEC
62096: ST_TO_ADDR
62097: LD_VAR 0 12
62101: PUSH
62102: FOR_TO
62103: IFFALSE 62433
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62105: LD_VAR 0 12
62109: PUSH
62110: LD_VAR 0 7
62114: ARRAY
62115: PUSH
62116: LD_INT 1
62118: ARRAY
62119: PPUSH
62120: LD_VAR 0 12
62124: PUSH
62125: LD_VAR 0 7
62129: ARRAY
62130: PUSH
62131: LD_INT 2
62133: ARRAY
62134: PPUSH
62135: CALL_OW 488
62139: NOT
62140: PUSH
62141: LD_VAR 0 12
62145: PUSH
62146: LD_VAR 0 7
62150: ARRAY
62151: PUSH
62152: LD_INT 1
62154: ARRAY
62155: PPUSH
62156: LD_VAR 0 12
62160: PUSH
62161: LD_VAR 0 7
62165: ARRAY
62166: PUSH
62167: LD_INT 2
62169: ARRAY
62170: PPUSH
62171: CALL_OW 428
62175: PUSH
62176: LD_INT 0
62178: GREATER
62179: OR
62180: PUSH
62181: LD_VAR 0 12
62185: PUSH
62186: LD_VAR 0 7
62190: ARRAY
62191: PUSH
62192: LD_INT 1
62194: ARRAY
62195: PPUSH
62196: LD_VAR 0 12
62200: PUSH
62201: LD_VAR 0 7
62205: ARRAY
62206: PUSH
62207: LD_INT 2
62209: ARRAY
62210: PPUSH
62211: CALL_OW 351
62215: OR
62216: IFFALSE 62222
// exit ;
62218: POP
62219: POP
62220: GO 62514
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62222: LD_ADDR_VAR 0 8
62226: PUSH
62227: LD_VAR 0 12
62231: PUSH
62232: LD_VAR 0 7
62236: ARRAY
62237: PUSH
62238: LD_INT 1
62240: ARRAY
62241: PPUSH
62242: LD_VAR 0 12
62246: PUSH
62247: LD_VAR 0 7
62251: ARRAY
62252: PUSH
62253: LD_INT 2
62255: ARRAY
62256: PPUSH
62257: CALL_OW 546
62261: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62262: LD_VAR 0 8
62266: PUSH
62267: LD_INT 1
62269: ARRAY
62270: PUSH
62271: LD_VAR 0 8
62275: PUSH
62276: LD_INT 2
62278: ARRAY
62279: PUSH
62280: LD_VAR 0 13
62284: PUSH
62285: LD_INT 2
62287: PLUS
62288: GREATER
62289: OR
62290: PUSH
62291: LD_VAR 0 8
62295: PUSH
62296: LD_INT 2
62298: ARRAY
62299: PUSH
62300: LD_VAR 0 13
62304: PUSH
62305: LD_INT 2
62307: MINUS
62308: LESS
62309: OR
62310: PUSH
62311: LD_VAR 0 8
62315: PUSH
62316: LD_INT 3
62318: ARRAY
62319: PUSH
62320: LD_INT 0
62322: PUSH
62323: LD_INT 8
62325: PUSH
62326: LD_INT 9
62328: PUSH
62329: LD_INT 10
62331: PUSH
62332: LD_INT 11
62334: PUSH
62335: LD_INT 12
62337: PUSH
62338: LD_INT 13
62340: PUSH
62341: LD_INT 16
62343: PUSH
62344: LD_INT 17
62346: PUSH
62347: LD_INT 18
62349: PUSH
62350: LD_INT 19
62352: PUSH
62353: LD_INT 20
62355: PUSH
62356: LD_INT 21
62358: PUSH
62359: EMPTY
62360: LIST
62361: LIST
62362: LIST
62363: LIST
62364: LIST
62365: LIST
62366: LIST
62367: LIST
62368: LIST
62369: LIST
62370: LIST
62371: LIST
62372: LIST
62373: IN
62374: NOT
62375: OR
62376: PUSH
62377: LD_VAR 0 8
62381: PUSH
62382: LD_INT 5
62384: ARRAY
62385: NOT
62386: OR
62387: PUSH
62388: LD_VAR 0 8
62392: PUSH
62393: LD_INT 6
62395: ARRAY
62396: PUSH
62397: LD_INT 1
62399: PUSH
62400: LD_INT 2
62402: PUSH
62403: LD_INT 7
62405: PUSH
62406: LD_INT 9
62408: PUSH
62409: LD_INT 10
62411: PUSH
62412: LD_INT 11
62414: PUSH
62415: EMPTY
62416: LIST
62417: LIST
62418: LIST
62419: LIST
62420: LIST
62421: LIST
62422: IN
62423: NOT
62424: OR
62425: IFFALSE 62431
// exit ;
62427: POP
62428: POP
62429: GO 62514
// end ;
62431: GO 62102
62433: POP
62434: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62435: LD_VAR 0 9
62439: PPUSH
62440: LD_VAR 0 3
62444: PPUSH
62445: LD_VAR 0 4
62449: PPUSH
62450: LD_INT 20
62452: PPUSH
62453: CALL 54460 0 4
62457: PUSH
62458: LD_INT 4
62460: ARRAY
62461: IFFALSE 62465
// exit ;
62463: GO 62514
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62465: LD_VAR 0 2
62469: PUSH
62470: LD_INT 29
62472: PUSH
62473: LD_INT 30
62475: PUSH
62476: EMPTY
62477: LIST
62478: LIST
62479: IN
62480: PUSH
62481: LD_VAR 0 3
62485: PPUSH
62486: LD_VAR 0 4
62490: PPUSH
62491: LD_VAR 0 9
62495: PPUSH
62496: CALL_OW 440
62500: NOT
62501: AND
62502: IFFALSE 62506
// exit ;
62504: GO 62514
// result := true ;
62506: LD_ADDR_VAR 0 6
62510: PUSH
62511: LD_INT 1
62513: ST_TO_ADDR
// end ;
62514: LD_VAR 0 6
62518: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62519: LD_INT 0
62521: PPUSH
62522: PPUSH
62523: PPUSH
62524: PPUSH
62525: PPUSH
62526: PPUSH
62527: PPUSH
62528: PPUSH
62529: PPUSH
62530: PPUSH
62531: PPUSH
62532: PPUSH
62533: PPUSH
62534: PPUSH
62535: PPUSH
62536: PPUSH
62537: PPUSH
62538: PPUSH
62539: PPUSH
62540: PPUSH
62541: PPUSH
62542: PPUSH
62543: PPUSH
62544: PPUSH
62545: PPUSH
62546: PPUSH
62547: PPUSH
62548: PPUSH
62549: PPUSH
62550: PPUSH
62551: PPUSH
62552: PPUSH
62553: PPUSH
62554: PPUSH
62555: PPUSH
62556: PPUSH
62557: PPUSH
62558: PPUSH
62559: PPUSH
62560: PPUSH
62561: PPUSH
62562: PPUSH
62563: PPUSH
62564: PPUSH
62565: PPUSH
62566: PPUSH
62567: PPUSH
62568: PPUSH
62569: PPUSH
62570: PPUSH
62571: PPUSH
62572: PPUSH
62573: PPUSH
62574: PPUSH
62575: PPUSH
62576: PPUSH
62577: PPUSH
62578: PPUSH
// result = [ ] ;
62579: LD_ADDR_VAR 0 7
62583: PUSH
62584: EMPTY
62585: ST_TO_ADDR
// temp_list = [ ] ;
62586: LD_ADDR_VAR 0 9
62590: PUSH
62591: EMPTY
62592: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62593: LD_VAR 0 4
62597: PUSH
62598: LD_INT 0
62600: PUSH
62601: LD_INT 1
62603: PUSH
62604: LD_INT 2
62606: PUSH
62607: LD_INT 3
62609: PUSH
62610: LD_INT 4
62612: PUSH
62613: LD_INT 5
62615: PUSH
62616: EMPTY
62617: LIST
62618: LIST
62619: LIST
62620: LIST
62621: LIST
62622: LIST
62623: IN
62624: NOT
62625: PUSH
62626: LD_VAR 0 1
62630: PUSH
62631: LD_INT 0
62633: PUSH
62634: LD_INT 1
62636: PUSH
62637: EMPTY
62638: LIST
62639: LIST
62640: IN
62641: PUSH
62642: LD_VAR 0 5
62646: PUSH
62647: LD_INT 1
62649: PUSH
62650: LD_INT 2
62652: PUSH
62653: LD_INT 3
62655: PUSH
62656: EMPTY
62657: LIST
62658: LIST
62659: LIST
62660: IN
62661: NOT
62662: AND
62663: OR
62664: IFFALSE 62668
// exit ;
62666: GO 81059
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62668: LD_VAR 0 1
62672: PUSH
62673: LD_INT 6
62675: PUSH
62676: LD_INT 7
62678: PUSH
62679: LD_INT 8
62681: PUSH
62682: LD_INT 13
62684: PUSH
62685: LD_INT 12
62687: PUSH
62688: LD_INT 15
62690: PUSH
62691: LD_INT 11
62693: PUSH
62694: LD_INT 14
62696: PUSH
62697: LD_INT 10
62699: PUSH
62700: EMPTY
62701: LIST
62702: LIST
62703: LIST
62704: LIST
62705: LIST
62706: LIST
62707: LIST
62708: LIST
62709: LIST
62710: IN
62711: IFFALSE 62721
// btype = b_lab ;
62713: LD_ADDR_VAR 0 1
62717: PUSH
62718: LD_INT 6
62720: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62721: LD_VAR 0 6
62725: PUSH
62726: LD_INT 0
62728: PUSH
62729: LD_INT 1
62731: PUSH
62732: LD_INT 2
62734: PUSH
62735: EMPTY
62736: LIST
62737: LIST
62738: LIST
62739: IN
62740: NOT
62741: PUSH
62742: LD_VAR 0 1
62746: PUSH
62747: LD_INT 0
62749: PUSH
62750: LD_INT 1
62752: PUSH
62753: LD_INT 2
62755: PUSH
62756: LD_INT 3
62758: PUSH
62759: LD_INT 6
62761: PUSH
62762: LD_INT 36
62764: PUSH
62765: LD_INT 4
62767: PUSH
62768: LD_INT 5
62770: PUSH
62771: LD_INT 31
62773: PUSH
62774: LD_INT 32
62776: PUSH
62777: LD_INT 33
62779: PUSH
62780: EMPTY
62781: LIST
62782: LIST
62783: LIST
62784: LIST
62785: LIST
62786: LIST
62787: LIST
62788: LIST
62789: LIST
62790: LIST
62791: LIST
62792: IN
62793: NOT
62794: PUSH
62795: LD_VAR 0 6
62799: PUSH
62800: LD_INT 1
62802: EQUAL
62803: AND
62804: OR
62805: PUSH
62806: LD_VAR 0 1
62810: PUSH
62811: LD_INT 2
62813: PUSH
62814: LD_INT 3
62816: PUSH
62817: EMPTY
62818: LIST
62819: LIST
62820: IN
62821: NOT
62822: PUSH
62823: LD_VAR 0 6
62827: PUSH
62828: LD_INT 2
62830: EQUAL
62831: AND
62832: OR
62833: IFFALSE 62843
// mode = 0 ;
62835: LD_ADDR_VAR 0 6
62839: PUSH
62840: LD_INT 0
62842: ST_TO_ADDR
// case mode of 0 :
62843: LD_VAR 0 6
62847: PUSH
62848: LD_INT 0
62850: DOUBLE
62851: EQUAL
62852: IFTRUE 62856
62854: GO 74309
62856: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
62857: LD_ADDR_VAR 0 11
62861: PUSH
62862: LD_INT 0
62864: PUSH
62865: LD_INT 0
62867: PUSH
62868: EMPTY
62869: LIST
62870: LIST
62871: PUSH
62872: LD_INT 0
62874: PUSH
62875: LD_INT 1
62877: NEG
62878: PUSH
62879: EMPTY
62880: LIST
62881: LIST
62882: PUSH
62883: LD_INT 1
62885: PUSH
62886: LD_INT 0
62888: PUSH
62889: EMPTY
62890: LIST
62891: LIST
62892: PUSH
62893: LD_INT 1
62895: PUSH
62896: LD_INT 1
62898: PUSH
62899: EMPTY
62900: LIST
62901: LIST
62902: PUSH
62903: LD_INT 0
62905: PUSH
62906: LD_INT 1
62908: PUSH
62909: EMPTY
62910: LIST
62911: LIST
62912: PUSH
62913: LD_INT 1
62915: NEG
62916: PUSH
62917: LD_INT 0
62919: PUSH
62920: EMPTY
62921: LIST
62922: LIST
62923: PUSH
62924: LD_INT 1
62926: NEG
62927: PUSH
62928: LD_INT 1
62930: NEG
62931: PUSH
62932: EMPTY
62933: LIST
62934: LIST
62935: PUSH
62936: LD_INT 1
62938: NEG
62939: PUSH
62940: LD_INT 2
62942: NEG
62943: PUSH
62944: EMPTY
62945: LIST
62946: LIST
62947: PUSH
62948: LD_INT 0
62950: PUSH
62951: LD_INT 2
62953: NEG
62954: PUSH
62955: EMPTY
62956: LIST
62957: LIST
62958: PUSH
62959: LD_INT 1
62961: PUSH
62962: LD_INT 1
62964: NEG
62965: PUSH
62966: EMPTY
62967: LIST
62968: LIST
62969: PUSH
62970: LD_INT 1
62972: PUSH
62973: LD_INT 2
62975: PUSH
62976: EMPTY
62977: LIST
62978: LIST
62979: PUSH
62980: LD_INT 0
62982: PUSH
62983: LD_INT 2
62985: PUSH
62986: EMPTY
62987: LIST
62988: LIST
62989: PUSH
62990: LD_INT 1
62992: NEG
62993: PUSH
62994: LD_INT 1
62996: PUSH
62997: EMPTY
62998: LIST
62999: LIST
63000: PUSH
63001: LD_INT 1
63003: PUSH
63004: LD_INT 3
63006: PUSH
63007: EMPTY
63008: LIST
63009: LIST
63010: PUSH
63011: LD_INT 0
63013: PUSH
63014: LD_INT 3
63016: PUSH
63017: EMPTY
63018: LIST
63019: LIST
63020: PUSH
63021: LD_INT 1
63023: NEG
63024: PUSH
63025: LD_INT 2
63027: PUSH
63028: EMPTY
63029: LIST
63030: LIST
63031: PUSH
63032: EMPTY
63033: LIST
63034: LIST
63035: LIST
63036: LIST
63037: LIST
63038: LIST
63039: LIST
63040: LIST
63041: LIST
63042: LIST
63043: LIST
63044: LIST
63045: LIST
63046: LIST
63047: LIST
63048: LIST
63049: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63050: LD_ADDR_VAR 0 12
63054: PUSH
63055: LD_INT 0
63057: PUSH
63058: LD_INT 0
63060: PUSH
63061: EMPTY
63062: LIST
63063: LIST
63064: PUSH
63065: LD_INT 0
63067: PUSH
63068: LD_INT 1
63070: NEG
63071: PUSH
63072: EMPTY
63073: LIST
63074: LIST
63075: PUSH
63076: LD_INT 1
63078: PUSH
63079: LD_INT 0
63081: PUSH
63082: EMPTY
63083: LIST
63084: LIST
63085: PUSH
63086: LD_INT 1
63088: PUSH
63089: LD_INT 1
63091: PUSH
63092: EMPTY
63093: LIST
63094: LIST
63095: PUSH
63096: LD_INT 0
63098: PUSH
63099: LD_INT 1
63101: PUSH
63102: EMPTY
63103: LIST
63104: LIST
63105: PUSH
63106: LD_INT 1
63108: NEG
63109: PUSH
63110: LD_INT 0
63112: PUSH
63113: EMPTY
63114: LIST
63115: LIST
63116: PUSH
63117: LD_INT 1
63119: NEG
63120: PUSH
63121: LD_INT 1
63123: NEG
63124: PUSH
63125: EMPTY
63126: LIST
63127: LIST
63128: PUSH
63129: LD_INT 1
63131: PUSH
63132: LD_INT 1
63134: NEG
63135: PUSH
63136: EMPTY
63137: LIST
63138: LIST
63139: PUSH
63140: LD_INT 2
63142: PUSH
63143: LD_INT 0
63145: PUSH
63146: EMPTY
63147: LIST
63148: LIST
63149: PUSH
63150: LD_INT 2
63152: PUSH
63153: LD_INT 1
63155: PUSH
63156: EMPTY
63157: LIST
63158: LIST
63159: PUSH
63160: LD_INT 1
63162: NEG
63163: PUSH
63164: LD_INT 1
63166: PUSH
63167: EMPTY
63168: LIST
63169: LIST
63170: PUSH
63171: LD_INT 2
63173: NEG
63174: PUSH
63175: LD_INT 0
63177: PUSH
63178: EMPTY
63179: LIST
63180: LIST
63181: PUSH
63182: LD_INT 2
63184: NEG
63185: PUSH
63186: LD_INT 1
63188: NEG
63189: PUSH
63190: EMPTY
63191: LIST
63192: LIST
63193: PUSH
63194: LD_INT 2
63196: NEG
63197: PUSH
63198: LD_INT 1
63200: PUSH
63201: EMPTY
63202: LIST
63203: LIST
63204: PUSH
63205: LD_INT 3
63207: NEG
63208: PUSH
63209: LD_INT 0
63211: PUSH
63212: EMPTY
63213: LIST
63214: LIST
63215: PUSH
63216: LD_INT 3
63218: NEG
63219: PUSH
63220: LD_INT 1
63222: NEG
63223: PUSH
63224: EMPTY
63225: LIST
63226: LIST
63227: PUSH
63228: EMPTY
63229: LIST
63230: LIST
63231: LIST
63232: LIST
63233: LIST
63234: LIST
63235: LIST
63236: LIST
63237: LIST
63238: LIST
63239: LIST
63240: LIST
63241: LIST
63242: LIST
63243: LIST
63244: LIST
63245: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63246: LD_ADDR_VAR 0 13
63250: PUSH
63251: LD_INT 0
63253: PUSH
63254: LD_INT 0
63256: PUSH
63257: EMPTY
63258: LIST
63259: LIST
63260: PUSH
63261: LD_INT 0
63263: PUSH
63264: LD_INT 1
63266: NEG
63267: PUSH
63268: EMPTY
63269: LIST
63270: LIST
63271: PUSH
63272: LD_INT 1
63274: PUSH
63275: LD_INT 0
63277: PUSH
63278: EMPTY
63279: LIST
63280: LIST
63281: PUSH
63282: LD_INT 1
63284: PUSH
63285: LD_INT 1
63287: PUSH
63288: EMPTY
63289: LIST
63290: LIST
63291: PUSH
63292: LD_INT 0
63294: PUSH
63295: LD_INT 1
63297: PUSH
63298: EMPTY
63299: LIST
63300: LIST
63301: PUSH
63302: LD_INT 1
63304: NEG
63305: PUSH
63306: LD_INT 0
63308: PUSH
63309: EMPTY
63310: LIST
63311: LIST
63312: PUSH
63313: LD_INT 1
63315: NEG
63316: PUSH
63317: LD_INT 1
63319: NEG
63320: PUSH
63321: EMPTY
63322: LIST
63323: LIST
63324: PUSH
63325: LD_INT 1
63327: NEG
63328: PUSH
63329: LD_INT 2
63331: NEG
63332: PUSH
63333: EMPTY
63334: LIST
63335: LIST
63336: PUSH
63337: LD_INT 2
63339: PUSH
63340: LD_INT 1
63342: PUSH
63343: EMPTY
63344: LIST
63345: LIST
63346: PUSH
63347: LD_INT 2
63349: PUSH
63350: LD_INT 2
63352: PUSH
63353: EMPTY
63354: LIST
63355: LIST
63356: PUSH
63357: LD_INT 1
63359: PUSH
63360: LD_INT 2
63362: PUSH
63363: EMPTY
63364: LIST
63365: LIST
63366: PUSH
63367: LD_INT 2
63369: NEG
63370: PUSH
63371: LD_INT 1
63373: NEG
63374: PUSH
63375: EMPTY
63376: LIST
63377: LIST
63378: PUSH
63379: LD_INT 2
63381: NEG
63382: PUSH
63383: LD_INT 2
63385: NEG
63386: PUSH
63387: EMPTY
63388: LIST
63389: LIST
63390: PUSH
63391: LD_INT 2
63393: NEG
63394: PUSH
63395: LD_INT 3
63397: NEG
63398: PUSH
63399: EMPTY
63400: LIST
63401: LIST
63402: PUSH
63403: LD_INT 3
63405: NEG
63406: PUSH
63407: LD_INT 2
63409: NEG
63410: PUSH
63411: EMPTY
63412: LIST
63413: LIST
63414: PUSH
63415: LD_INT 3
63417: NEG
63418: PUSH
63419: LD_INT 3
63421: NEG
63422: PUSH
63423: EMPTY
63424: LIST
63425: LIST
63426: PUSH
63427: EMPTY
63428: LIST
63429: LIST
63430: LIST
63431: LIST
63432: LIST
63433: LIST
63434: LIST
63435: LIST
63436: LIST
63437: LIST
63438: LIST
63439: LIST
63440: LIST
63441: LIST
63442: LIST
63443: LIST
63444: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63445: LD_ADDR_VAR 0 14
63449: PUSH
63450: LD_INT 0
63452: PUSH
63453: LD_INT 0
63455: PUSH
63456: EMPTY
63457: LIST
63458: LIST
63459: PUSH
63460: LD_INT 0
63462: PUSH
63463: LD_INT 1
63465: NEG
63466: PUSH
63467: EMPTY
63468: LIST
63469: LIST
63470: PUSH
63471: LD_INT 1
63473: PUSH
63474: LD_INT 0
63476: PUSH
63477: EMPTY
63478: LIST
63479: LIST
63480: PUSH
63481: LD_INT 1
63483: PUSH
63484: LD_INT 1
63486: PUSH
63487: EMPTY
63488: LIST
63489: LIST
63490: PUSH
63491: LD_INT 0
63493: PUSH
63494: LD_INT 1
63496: PUSH
63497: EMPTY
63498: LIST
63499: LIST
63500: PUSH
63501: LD_INT 1
63503: NEG
63504: PUSH
63505: LD_INT 0
63507: PUSH
63508: EMPTY
63509: LIST
63510: LIST
63511: PUSH
63512: LD_INT 1
63514: NEG
63515: PUSH
63516: LD_INT 1
63518: NEG
63519: PUSH
63520: EMPTY
63521: LIST
63522: LIST
63523: PUSH
63524: LD_INT 1
63526: NEG
63527: PUSH
63528: LD_INT 2
63530: NEG
63531: PUSH
63532: EMPTY
63533: LIST
63534: LIST
63535: PUSH
63536: LD_INT 0
63538: PUSH
63539: LD_INT 2
63541: NEG
63542: PUSH
63543: EMPTY
63544: LIST
63545: LIST
63546: PUSH
63547: LD_INT 1
63549: PUSH
63550: LD_INT 1
63552: NEG
63553: PUSH
63554: EMPTY
63555: LIST
63556: LIST
63557: PUSH
63558: LD_INT 1
63560: PUSH
63561: LD_INT 2
63563: PUSH
63564: EMPTY
63565: LIST
63566: LIST
63567: PUSH
63568: LD_INT 0
63570: PUSH
63571: LD_INT 2
63573: PUSH
63574: EMPTY
63575: LIST
63576: LIST
63577: PUSH
63578: LD_INT 1
63580: NEG
63581: PUSH
63582: LD_INT 1
63584: PUSH
63585: EMPTY
63586: LIST
63587: LIST
63588: PUSH
63589: LD_INT 1
63591: NEG
63592: PUSH
63593: LD_INT 3
63595: NEG
63596: PUSH
63597: EMPTY
63598: LIST
63599: LIST
63600: PUSH
63601: LD_INT 0
63603: PUSH
63604: LD_INT 3
63606: NEG
63607: PUSH
63608: EMPTY
63609: LIST
63610: LIST
63611: PUSH
63612: LD_INT 1
63614: PUSH
63615: LD_INT 2
63617: NEG
63618: PUSH
63619: EMPTY
63620: LIST
63621: LIST
63622: PUSH
63623: EMPTY
63624: LIST
63625: LIST
63626: LIST
63627: LIST
63628: LIST
63629: LIST
63630: LIST
63631: LIST
63632: LIST
63633: LIST
63634: LIST
63635: LIST
63636: LIST
63637: LIST
63638: LIST
63639: LIST
63640: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63641: LD_ADDR_VAR 0 15
63645: PUSH
63646: LD_INT 0
63648: PUSH
63649: LD_INT 0
63651: PUSH
63652: EMPTY
63653: LIST
63654: LIST
63655: PUSH
63656: LD_INT 0
63658: PUSH
63659: LD_INT 1
63661: NEG
63662: PUSH
63663: EMPTY
63664: LIST
63665: LIST
63666: PUSH
63667: LD_INT 1
63669: PUSH
63670: LD_INT 0
63672: PUSH
63673: EMPTY
63674: LIST
63675: LIST
63676: PUSH
63677: LD_INT 1
63679: PUSH
63680: LD_INT 1
63682: PUSH
63683: EMPTY
63684: LIST
63685: LIST
63686: PUSH
63687: LD_INT 0
63689: PUSH
63690: LD_INT 1
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PUSH
63697: LD_INT 1
63699: NEG
63700: PUSH
63701: LD_INT 0
63703: PUSH
63704: EMPTY
63705: LIST
63706: LIST
63707: PUSH
63708: LD_INT 1
63710: NEG
63711: PUSH
63712: LD_INT 1
63714: NEG
63715: PUSH
63716: EMPTY
63717: LIST
63718: LIST
63719: PUSH
63720: LD_INT 1
63722: PUSH
63723: LD_INT 1
63725: NEG
63726: PUSH
63727: EMPTY
63728: LIST
63729: LIST
63730: PUSH
63731: LD_INT 2
63733: PUSH
63734: LD_INT 0
63736: PUSH
63737: EMPTY
63738: LIST
63739: LIST
63740: PUSH
63741: LD_INT 2
63743: PUSH
63744: LD_INT 1
63746: PUSH
63747: EMPTY
63748: LIST
63749: LIST
63750: PUSH
63751: LD_INT 1
63753: NEG
63754: PUSH
63755: LD_INT 1
63757: PUSH
63758: EMPTY
63759: LIST
63760: LIST
63761: PUSH
63762: LD_INT 2
63764: NEG
63765: PUSH
63766: LD_INT 0
63768: PUSH
63769: EMPTY
63770: LIST
63771: LIST
63772: PUSH
63773: LD_INT 2
63775: NEG
63776: PUSH
63777: LD_INT 1
63779: NEG
63780: PUSH
63781: EMPTY
63782: LIST
63783: LIST
63784: PUSH
63785: LD_INT 2
63787: PUSH
63788: LD_INT 1
63790: NEG
63791: PUSH
63792: EMPTY
63793: LIST
63794: LIST
63795: PUSH
63796: LD_INT 3
63798: PUSH
63799: LD_INT 0
63801: PUSH
63802: EMPTY
63803: LIST
63804: LIST
63805: PUSH
63806: LD_INT 3
63808: PUSH
63809: LD_INT 1
63811: PUSH
63812: EMPTY
63813: LIST
63814: LIST
63815: PUSH
63816: EMPTY
63817: LIST
63818: LIST
63819: LIST
63820: LIST
63821: LIST
63822: LIST
63823: LIST
63824: LIST
63825: LIST
63826: LIST
63827: LIST
63828: LIST
63829: LIST
63830: LIST
63831: LIST
63832: LIST
63833: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
63834: LD_ADDR_VAR 0 16
63838: PUSH
63839: LD_INT 0
63841: PUSH
63842: LD_INT 0
63844: PUSH
63845: EMPTY
63846: LIST
63847: LIST
63848: PUSH
63849: LD_INT 0
63851: PUSH
63852: LD_INT 1
63854: NEG
63855: PUSH
63856: EMPTY
63857: LIST
63858: LIST
63859: PUSH
63860: LD_INT 1
63862: PUSH
63863: LD_INT 0
63865: PUSH
63866: EMPTY
63867: LIST
63868: LIST
63869: PUSH
63870: LD_INT 1
63872: PUSH
63873: LD_INT 1
63875: PUSH
63876: EMPTY
63877: LIST
63878: LIST
63879: PUSH
63880: LD_INT 0
63882: PUSH
63883: LD_INT 1
63885: PUSH
63886: EMPTY
63887: LIST
63888: LIST
63889: PUSH
63890: LD_INT 1
63892: NEG
63893: PUSH
63894: LD_INT 0
63896: PUSH
63897: EMPTY
63898: LIST
63899: LIST
63900: PUSH
63901: LD_INT 1
63903: NEG
63904: PUSH
63905: LD_INT 1
63907: NEG
63908: PUSH
63909: EMPTY
63910: LIST
63911: LIST
63912: PUSH
63913: LD_INT 1
63915: NEG
63916: PUSH
63917: LD_INT 2
63919: NEG
63920: PUSH
63921: EMPTY
63922: LIST
63923: LIST
63924: PUSH
63925: LD_INT 2
63927: PUSH
63928: LD_INT 1
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: PUSH
63935: LD_INT 2
63937: PUSH
63938: LD_INT 2
63940: PUSH
63941: EMPTY
63942: LIST
63943: LIST
63944: PUSH
63945: LD_INT 1
63947: PUSH
63948: LD_INT 2
63950: PUSH
63951: EMPTY
63952: LIST
63953: LIST
63954: PUSH
63955: LD_INT 2
63957: NEG
63958: PUSH
63959: LD_INT 1
63961: NEG
63962: PUSH
63963: EMPTY
63964: LIST
63965: LIST
63966: PUSH
63967: LD_INT 2
63969: NEG
63970: PUSH
63971: LD_INT 2
63973: NEG
63974: PUSH
63975: EMPTY
63976: LIST
63977: LIST
63978: PUSH
63979: LD_INT 3
63981: PUSH
63982: LD_INT 2
63984: PUSH
63985: EMPTY
63986: LIST
63987: LIST
63988: PUSH
63989: LD_INT 3
63991: PUSH
63992: LD_INT 3
63994: PUSH
63995: EMPTY
63996: LIST
63997: LIST
63998: PUSH
63999: LD_INT 2
64001: PUSH
64002: LD_INT 3
64004: PUSH
64005: EMPTY
64006: LIST
64007: LIST
64008: PUSH
64009: EMPTY
64010: LIST
64011: LIST
64012: LIST
64013: LIST
64014: LIST
64015: LIST
64016: LIST
64017: LIST
64018: LIST
64019: LIST
64020: LIST
64021: LIST
64022: LIST
64023: LIST
64024: LIST
64025: LIST
64026: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64027: LD_ADDR_VAR 0 17
64031: PUSH
64032: LD_INT 0
64034: PUSH
64035: LD_INT 0
64037: PUSH
64038: EMPTY
64039: LIST
64040: LIST
64041: PUSH
64042: LD_INT 0
64044: PUSH
64045: LD_INT 1
64047: NEG
64048: PUSH
64049: EMPTY
64050: LIST
64051: LIST
64052: PUSH
64053: LD_INT 1
64055: PUSH
64056: LD_INT 0
64058: PUSH
64059: EMPTY
64060: LIST
64061: LIST
64062: PUSH
64063: LD_INT 1
64065: PUSH
64066: LD_INT 1
64068: PUSH
64069: EMPTY
64070: LIST
64071: LIST
64072: PUSH
64073: LD_INT 0
64075: PUSH
64076: LD_INT 1
64078: PUSH
64079: EMPTY
64080: LIST
64081: LIST
64082: PUSH
64083: LD_INT 1
64085: NEG
64086: PUSH
64087: LD_INT 0
64089: PUSH
64090: EMPTY
64091: LIST
64092: LIST
64093: PUSH
64094: LD_INT 1
64096: NEG
64097: PUSH
64098: LD_INT 1
64100: NEG
64101: PUSH
64102: EMPTY
64103: LIST
64104: LIST
64105: PUSH
64106: LD_INT 1
64108: NEG
64109: PUSH
64110: LD_INT 2
64112: NEG
64113: PUSH
64114: EMPTY
64115: LIST
64116: LIST
64117: PUSH
64118: LD_INT 0
64120: PUSH
64121: LD_INT 2
64123: NEG
64124: PUSH
64125: EMPTY
64126: LIST
64127: LIST
64128: PUSH
64129: LD_INT 1
64131: PUSH
64132: LD_INT 1
64134: NEG
64135: PUSH
64136: EMPTY
64137: LIST
64138: LIST
64139: PUSH
64140: LD_INT 2
64142: PUSH
64143: LD_INT 0
64145: PUSH
64146: EMPTY
64147: LIST
64148: LIST
64149: PUSH
64150: LD_INT 2
64152: PUSH
64153: LD_INT 1
64155: PUSH
64156: EMPTY
64157: LIST
64158: LIST
64159: PUSH
64160: LD_INT 2
64162: PUSH
64163: LD_INT 2
64165: PUSH
64166: EMPTY
64167: LIST
64168: LIST
64169: PUSH
64170: LD_INT 1
64172: PUSH
64173: LD_INT 2
64175: PUSH
64176: EMPTY
64177: LIST
64178: LIST
64179: PUSH
64180: LD_INT 0
64182: PUSH
64183: LD_INT 2
64185: PUSH
64186: EMPTY
64187: LIST
64188: LIST
64189: PUSH
64190: LD_INT 1
64192: NEG
64193: PUSH
64194: LD_INT 1
64196: PUSH
64197: EMPTY
64198: LIST
64199: LIST
64200: PUSH
64201: LD_INT 2
64203: NEG
64204: PUSH
64205: LD_INT 0
64207: PUSH
64208: EMPTY
64209: LIST
64210: LIST
64211: PUSH
64212: LD_INT 2
64214: NEG
64215: PUSH
64216: LD_INT 1
64218: NEG
64219: PUSH
64220: EMPTY
64221: LIST
64222: LIST
64223: PUSH
64224: LD_INT 2
64226: NEG
64227: PUSH
64228: LD_INT 2
64230: NEG
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: PUSH
64236: EMPTY
64237: LIST
64238: LIST
64239: LIST
64240: LIST
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: LIST
64249: LIST
64250: LIST
64251: LIST
64252: LIST
64253: LIST
64254: LIST
64255: LIST
64256: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64257: LD_ADDR_VAR 0 18
64261: PUSH
64262: LD_INT 0
64264: PUSH
64265: LD_INT 0
64267: PUSH
64268: EMPTY
64269: LIST
64270: LIST
64271: PUSH
64272: LD_INT 0
64274: PUSH
64275: LD_INT 1
64277: NEG
64278: PUSH
64279: EMPTY
64280: LIST
64281: LIST
64282: PUSH
64283: LD_INT 1
64285: PUSH
64286: LD_INT 0
64288: PUSH
64289: EMPTY
64290: LIST
64291: LIST
64292: PUSH
64293: LD_INT 1
64295: PUSH
64296: LD_INT 1
64298: PUSH
64299: EMPTY
64300: LIST
64301: LIST
64302: PUSH
64303: LD_INT 0
64305: PUSH
64306: LD_INT 1
64308: PUSH
64309: EMPTY
64310: LIST
64311: LIST
64312: PUSH
64313: LD_INT 1
64315: NEG
64316: PUSH
64317: LD_INT 0
64319: PUSH
64320: EMPTY
64321: LIST
64322: LIST
64323: PUSH
64324: LD_INT 1
64326: NEG
64327: PUSH
64328: LD_INT 1
64330: NEG
64331: PUSH
64332: EMPTY
64333: LIST
64334: LIST
64335: PUSH
64336: LD_INT 1
64338: NEG
64339: PUSH
64340: LD_INT 2
64342: NEG
64343: PUSH
64344: EMPTY
64345: LIST
64346: LIST
64347: PUSH
64348: LD_INT 0
64350: PUSH
64351: LD_INT 2
64353: NEG
64354: PUSH
64355: EMPTY
64356: LIST
64357: LIST
64358: PUSH
64359: LD_INT 1
64361: PUSH
64362: LD_INT 1
64364: NEG
64365: PUSH
64366: EMPTY
64367: LIST
64368: LIST
64369: PUSH
64370: LD_INT 2
64372: PUSH
64373: LD_INT 0
64375: PUSH
64376: EMPTY
64377: LIST
64378: LIST
64379: PUSH
64380: LD_INT 2
64382: PUSH
64383: LD_INT 1
64385: PUSH
64386: EMPTY
64387: LIST
64388: LIST
64389: PUSH
64390: LD_INT 2
64392: PUSH
64393: LD_INT 2
64395: PUSH
64396: EMPTY
64397: LIST
64398: LIST
64399: PUSH
64400: LD_INT 1
64402: PUSH
64403: LD_INT 2
64405: PUSH
64406: EMPTY
64407: LIST
64408: LIST
64409: PUSH
64410: LD_INT 0
64412: PUSH
64413: LD_INT 2
64415: PUSH
64416: EMPTY
64417: LIST
64418: LIST
64419: PUSH
64420: LD_INT 1
64422: NEG
64423: PUSH
64424: LD_INT 1
64426: PUSH
64427: EMPTY
64428: LIST
64429: LIST
64430: PUSH
64431: LD_INT 2
64433: NEG
64434: PUSH
64435: LD_INT 0
64437: PUSH
64438: EMPTY
64439: LIST
64440: LIST
64441: PUSH
64442: LD_INT 2
64444: NEG
64445: PUSH
64446: LD_INT 1
64448: NEG
64449: PUSH
64450: EMPTY
64451: LIST
64452: LIST
64453: PUSH
64454: LD_INT 2
64456: NEG
64457: PUSH
64458: LD_INT 2
64460: NEG
64461: PUSH
64462: EMPTY
64463: LIST
64464: LIST
64465: PUSH
64466: EMPTY
64467: LIST
64468: LIST
64469: LIST
64470: LIST
64471: LIST
64472: LIST
64473: LIST
64474: LIST
64475: LIST
64476: LIST
64477: LIST
64478: LIST
64479: LIST
64480: LIST
64481: LIST
64482: LIST
64483: LIST
64484: LIST
64485: LIST
64486: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64487: LD_ADDR_VAR 0 19
64491: PUSH
64492: LD_INT 0
64494: PUSH
64495: LD_INT 0
64497: PUSH
64498: EMPTY
64499: LIST
64500: LIST
64501: PUSH
64502: LD_INT 0
64504: PUSH
64505: LD_INT 1
64507: NEG
64508: PUSH
64509: EMPTY
64510: LIST
64511: LIST
64512: PUSH
64513: LD_INT 1
64515: PUSH
64516: LD_INT 0
64518: PUSH
64519: EMPTY
64520: LIST
64521: LIST
64522: PUSH
64523: LD_INT 1
64525: PUSH
64526: LD_INT 1
64528: PUSH
64529: EMPTY
64530: LIST
64531: LIST
64532: PUSH
64533: LD_INT 0
64535: PUSH
64536: LD_INT 1
64538: PUSH
64539: EMPTY
64540: LIST
64541: LIST
64542: PUSH
64543: LD_INT 1
64545: NEG
64546: PUSH
64547: LD_INT 0
64549: PUSH
64550: EMPTY
64551: LIST
64552: LIST
64553: PUSH
64554: LD_INT 1
64556: NEG
64557: PUSH
64558: LD_INT 1
64560: NEG
64561: PUSH
64562: EMPTY
64563: LIST
64564: LIST
64565: PUSH
64566: LD_INT 1
64568: NEG
64569: PUSH
64570: LD_INT 2
64572: NEG
64573: PUSH
64574: EMPTY
64575: LIST
64576: LIST
64577: PUSH
64578: LD_INT 0
64580: PUSH
64581: LD_INT 2
64583: NEG
64584: PUSH
64585: EMPTY
64586: LIST
64587: LIST
64588: PUSH
64589: LD_INT 1
64591: PUSH
64592: LD_INT 1
64594: NEG
64595: PUSH
64596: EMPTY
64597: LIST
64598: LIST
64599: PUSH
64600: LD_INT 2
64602: PUSH
64603: LD_INT 0
64605: PUSH
64606: EMPTY
64607: LIST
64608: LIST
64609: PUSH
64610: LD_INT 2
64612: PUSH
64613: LD_INT 1
64615: PUSH
64616: EMPTY
64617: LIST
64618: LIST
64619: PUSH
64620: LD_INT 2
64622: PUSH
64623: LD_INT 2
64625: PUSH
64626: EMPTY
64627: LIST
64628: LIST
64629: PUSH
64630: LD_INT 1
64632: PUSH
64633: LD_INT 2
64635: PUSH
64636: EMPTY
64637: LIST
64638: LIST
64639: PUSH
64640: LD_INT 0
64642: PUSH
64643: LD_INT 2
64645: PUSH
64646: EMPTY
64647: LIST
64648: LIST
64649: PUSH
64650: LD_INT 1
64652: NEG
64653: PUSH
64654: LD_INT 1
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: PUSH
64661: LD_INT 2
64663: NEG
64664: PUSH
64665: LD_INT 0
64667: PUSH
64668: EMPTY
64669: LIST
64670: LIST
64671: PUSH
64672: LD_INT 2
64674: NEG
64675: PUSH
64676: LD_INT 1
64678: NEG
64679: PUSH
64680: EMPTY
64681: LIST
64682: LIST
64683: PUSH
64684: LD_INT 2
64686: NEG
64687: PUSH
64688: LD_INT 2
64690: NEG
64691: PUSH
64692: EMPTY
64693: LIST
64694: LIST
64695: PUSH
64696: EMPTY
64697: LIST
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64717: LD_ADDR_VAR 0 20
64721: PUSH
64722: LD_INT 0
64724: PUSH
64725: LD_INT 0
64727: PUSH
64728: EMPTY
64729: LIST
64730: LIST
64731: PUSH
64732: LD_INT 0
64734: PUSH
64735: LD_INT 1
64737: NEG
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: PUSH
64743: LD_INT 1
64745: PUSH
64746: LD_INT 0
64748: PUSH
64749: EMPTY
64750: LIST
64751: LIST
64752: PUSH
64753: LD_INT 1
64755: PUSH
64756: LD_INT 1
64758: PUSH
64759: EMPTY
64760: LIST
64761: LIST
64762: PUSH
64763: LD_INT 0
64765: PUSH
64766: LD_INT 1
64768: PUSH
64769: EMPTY
64770: LIST
64771: LIST
64772: PUSH
64773: LD_INT 1
64775: NEG
64776: PUSH
64777: LD_INT 0
64779: PUSH
64780: EMPTY
64781: LIST
64782: LIST
64783: PUSH
64784: LD_INT 1
64786: NEG
64787: PUSH
64788: LD_INT 1
64790: NEG
64791: PUSH
64792: EMPTY
64793: LIST
64794: LIST
64795: PUSH
64796: LD_INT 1
64798: NEG
64799: PUSH
64800: LD_INT 2
64802: NEG
64803: PUSH
64804: EMPTY
64805: LIST
64806: LIST
64807: PUSH
64808: LD_INT 0
64810: PUSH
64811: LD_INT 2
64813: NEG
64814: PUSH
64815: EMPTY
64816: LIST
64817: LIST
64818: PUSH
64819: LD_INT 1
64821: PUSH
64822: LD_INT 1
64824: NEG
64825: PUSH
64826: EMPTY
64827: LIST
64828: LIST
64829: PUSH
64830: LD_INT 2
64832: PUSH
64833: LD_INT 0
64835: PUSH
64836: EMPTY
64837: LIST
64838: LIST
64839: PUSH
64840: LD_INT 2
64842: PUSH
64843: LD_INT 1
64845: PUSH
64846: EMPTY
64847: LIST
64848: LIST
64849: PUSH
64850: LD_INT 2
64852: PUSH
64853: LD_INT 2
64855: PUSH
64856: EMPTY
64857: LIST
64858: LIST
64859: PUSH
64860: LD_INT 1
64862: PUSH
64863: LD_INT 2
64865: PUSH
64866: EMPTY
64867: LIST
64868: LIST
64869: PUSH
64870: LD_INT 0
64872: PUSH
64873: LD_INT 2
64875: PUSH
64876: EMPTY
64877: LIST
64878: LIST
64879: PUSH
64880: LD_INT 1
64882: NEG
64883: PUSH
64884: LD_INT 1
64886: PUSH
64887: EMPTY
64888: LIST
64889: LIST
64890: PUSH
64891: LD_INT 2
64893: NEG
64894: PUSH
64895: LD_INT 0
64897: PUSH
64898: EMPTY
64899: LIST
64900: LIST
64901: PUSH
64902: LD_INT 2
64904: NEG
64905: PUSH
64906: LD_INT 1
64908: NEG
64909: PUSH
64910: EMPTY
64911: LIST
64912: LIST
64913: PUSH
64914: LD_INT 2
64916: NEG
64917: PUSH
64918: LD_INT 2
64920: NEG
64921: PUSH
64922: EMPTY
64923: LIST
64924: LIST
64925: PUSH
64926: EMPTY
64927: LIST
64928: LIST
64929: LIST
64930: LIST
64931: LIST
64932: LIST
64933: LIST
64934: LIST
64935: LIST
64936: LIST
64937: LIST
64938: LIST
64939: LIST
64940: LIST
64941: LIST
64942: LIST
64943: LIST
64944: LIST
64945: LIST
64946: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64947: LD_ADDR_VAR 0 21
64951: PUSH
64952: LD_INT 0
64954: PUSH
64955: LD_INT 0
64957: PUSH
64958: EMPTY
64959: LIST
64960: LIST
64961: PUSH
64962: LD_INT 0
64964: PUSH
64965: LD_INT 1
64967: NEG
64968: PUSH
64969: EMPTY
64970: LIST
64971: LIST
64972: PUSH
64973: LD_INT 1
64975: PUSH
64976: LD_INT 0
64978: PUSH
64979: EMPTY
64980: LIST
64981: LIST
64982: PUSH
64983: LD_INT 1
64985: PUSH
64986: LD_INT 1
64988: PUSH
64989: EMPTY
64990: LIST
64991: LIST
64992: PUSH
64993: LD_INT 0
64995: PUSH
64996: LD_INT 1
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: PUSH
65003: LD_INT 1
65005: NEG
65006: PUSH
65007: LD_INT 0
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: PUSH
65014: LD_INT 1
65016: NEG
65017: PUSH
65018: LD_INT 1
65020: NEG
65021: PUSH
65022: EMPTY
65023: LIST
65024: LIST
65025: PUSH
65026: LD_INT 1
65028: NEG
65029: PUSH
65030: LD_INT 2
65032: NEG
65033: PUSH
65034: EMPTY
65035: LIST
65036: LIST
65037: PUSH
65038: LD_INT 0
65040: PUSH
65041: LD_INT 2
65043: NEG
65044: PUSH
65045: EMPTY
65046: LIST
65047: LIST
65048: PUSH
65049: LD_INT 1
65051: PUSH
65052: LD_INT 1
65054: NEG
65055: PUSH
65056: EMPTY
65057: LIST
65058: LIST
65059: PUSH
65060: LD_INT 2
65062: PUSH
65063: LD_INT 0
65065: PUSH
65066: EMPTY
65067: LIST
65068: LIST
65069: PUSH
65070: LD_INT 2
65072: PUSH
65073: LD_INT 1
65075: PUSH
65076: EMPTY
65077: LIST
65078: LIST
65079: PUSH
65080: LD_INT 2
65082: PUSH
65083: LD_INT 2
65085: PUSH
65086: EMPTY
65087: LIST
65088: LIST
65089: PUSH
65090: LD_INT 1
65092: PUSH
65093: LD_INT 2
65095: PUSH
65096: EMPTY
65097: LIST
65098: LIST
65099: PUSH
65100: LD_INT 0
65102: PUSH
65103: LD_INT 2
65105: PUSH
65106: EMPTY
65107: LIST
65108: LIST
65109: PUSH
65110: LD_INT 1
65112: NEG
65113: PUSH
65114: LD_INT 1
65116: PUSH
65117: EMPTY
65118: LIST
65119: LIST
65120: PUSH
65121: LD_INT 2
65123: NEG
65124: PUSH
65125: LD_INT 0
65127: PUSH
65128: EMPTY
65129: LIST
65130: LIST
65131: PUSH
65132: LD_INT 2
65134: NEG
65135: PUSH
65136: LD_INT 1
65138: NEG
65139: PUSH
65140: EMPTY
65141: LIST
65142: LIST
65143: PUSH
65144: LD_INT 2
65146: NEG
65147: PUSH
65148: LD_INT 2
65150: NEG
65151: PUSH
65152: EMPTY
65153: LIST
65154: LIST
65155: PUSH
65156: EMPTY
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: LIST
65170: LIST
65171: LIST
65172: LIST
65173: LIST
65174: LIST
65175: LIST
65176: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65177: LD_ADDR_VAR 0 22
65181: PUSH
65182: LD_INT 0
65184: PUSH
65185: LD_INT 0
65187: PUSH
65188: EMPTY
65189: LIST
65190: LIST
65191: PUSH
65192: LD_INT 0
65194: PUSH
65195: LD_INT 1
65197: NEG
65198: PUSH
65199: EMPTY
65200: LIST
65201: LIST
65202: PUSH
65203: LD_INT 1
65205: PUSH
65206: LD_INT 0
65208: PUSH
65209: EMPTY
65210: LIST
65211: LIST
65212: PUSH
65213: LD_INT 1
65215: PUSH
65216: LD_INT 1
65218: PUSH
65219: EMPTY
65220: LIST
65221: LIST
65222: PUSH
65223: LD_INT 0
65225: PUSH
65226: LD_INT 1
65228: PUSH
65229: EMPTY
65230: LIST
65231: LIST
65232: PUSH
65233: LD_INT 1
65235: NEG
65236: PUSH
65237: LD_INT 0
65239: PUSH
65240: EMPTY
65241: LIST
65242: LIST
65243: PUSH
65244: LD_INT 1
65246: NEG
65247: PUSH
65248: LD_INT 1
65250: NEG
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: PUSH
65256: LD_INT 1
65258: NEG
65259: PUSH
65260: LD_INT 2
65262: NEG
65263: PUSH
65264: EMPTY
65265: LIST
65266: LIST
65267: PUSH
65268: LD_INT 0
65270: PUSH
65271: LD_INT 2
65273: NEG
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: PUSH
65279: LD_INT 1
65281: PUSH
65282: LD_INT 1
65284: NEG
65285: PUSH
65286: EMPTY
65287: LIST
65288: LIST
65289: PUSH
65290: LD_INT 2
65292: PUSH
65293: LD_INT 0
65295: PUSH
65296: EMPTY
65297: LIST
65298: LIST
65299: PUSH
65300: LD_INT 2
65302: PUSH
65303: LD_INT 1
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: PUSH
65310: LD_INT 2
65312: PUSH
65313: LD_INT 2
65315: PUSH
65316: EMPTY
65317: LIST
65318: LIST
65319: PUSH
65320: LD_INT 1
65322: PUSH
65323: LD_INT 2
65325: PUSH
65326: EMPTY
65327: LIST
65328: LIST
65329: PUSH
65330: LD_INT 0
65332: PUSH
65333: LD_INT 2
65335: PUSH
65336: EMPTY
65337: LIST
65338: LIST
65339: PUSH
65340: LD_INT 1
65342: NEG
65343: PUSH
65344: LD_INT 1
65346: PUSH
65347: EMPTY
65348: LIST
65349: LIST
65350: PUSH
65351: LD_INT 2
65353: NEG
65354: PUSH
65355: LD_INT 0
65357: PUSH
65358: EMPTY
65359: LIST
65360: LIST
65361: PUSH
65362: LD_INT 2
65364: NEG
65365: PUSH
65366: LD_INT 1
65368: NEG
65369: PUSH
65370: EMPTY
65371: LIST
65372: LIST
65373: PUSH
65374: LD_INT 2
65376: NEG
65377: PUSH
65378: LD_INT 2
65380: NEG
65381: PUSH
65382: EMPTY
65383: LIST
65384: LIST
65385: PUSH
65386: EMPTY
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: LIST
65404: LIST
65405: LIST
65406: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65407: LD_ADDR_VAR 0 23
65411: PUSH
65412: LD_INT 0
65414: PUSH
65415: LD_INT 0
65417: PUSH
65418: EMPTY
65419: LIST
65420: LIST
65421: PUSH
65422: LD_INT 0
65424: PUSH
65425: LD_INT 1
65427: NEG
65428: PUSH
65429: EMPTY
65430: LIST
65431: LIST
65432: PUSH
65433: LD_INT 1
65435: PUSH
65436: LD_INT 0
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: LD_INT 1
65445: PUSH
65446: LD_INT 1
65448: PUSH
65449: EMPTY
65450: LIST
65451: LIST
65452: PUSH
65453: LD_INT 0
65455: PUSH
65456: LD_INT 1
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: PUSH
65463: LD_INT 1
65465: NEG
65466: PUSH
65467: LD_INT 0
65469: PUSH
65470: EMPTY
65471: LIST
65472: LIST
65473: PUSH
65474: LD_INT 1
65476: NEG
65477: PUSH
65478: LD_INT 1
65480: NEG
65481: PUSH
65482: EMPTY
65483: LIST
65484: LIST
65485: PUSH
65486: LD_INT 1
65488: NEG
65489: PUSH
65490: LD_INT 2
65492: NEG
65493: PUSH
65494: EMPTY
65495: LIST
65496: LIST
65497: PUSH
65498: LD_INT 0
65500: PUSH
65501: LD_INT 2
65503: NEG
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: PUSH
65509: LD_INT 1
65511: PUSH
65512: LD_INT 1
65514: NEG
65515: PUSH
65516: EMPTY
65517: LIST
65518: LIST
65519: PUSH
65520: LD_INT 2
65522: PUSH
65523: LD_INT 0
65525: PUSH
65526: EMPTY
65527: LIST
65528: LIST
65529: PUSH
65530: LD_INT 2
65532: PUSH
65533: LD_INT 1
65535: PUSH
65536: EMPTY
65537: LIST
65538: LIST
65539: PUSH
65540: LD_INT 2
65542: PUSH
65543: LD_INT 2
65545: PUSH
65546: EMPTY
65547: LIST
65548: LIST
65549: PUSH
65550: LD_INT 1
65552: PUSH
65553: LD_INT 2
65555: PUSH
65556: EMPTY
65557: LIST
65558: LIST
65559: PUSH
65560: LD_INT 0
65562: PUSH
65563: LD_INT 2
65565: PUSH
65566: EMPTY
65567: LIST
65568: LIST
65569: PUSH
65570: LD_INT 1
65572: NEG
65573: PUSH
65574: LD_INT 1
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: PUSH
65581: LD_INT 2
65583: NEG
65584: PUSH
65585: LD_INT 0
65587: PUSH
65588: EMPTY
65589: LIST
65590: LIST
65591: PUSH
65592: LD_INT 2
65594: NEG
65595: PUSH
65596: LD_INT 1
65598: NEG
65599: PUSH
65600: EMPTY
65601: LIST
65602: LIST
65603: PUSH
65604: LD_INT 2
65606: NEG
65607: PUSH
65608: LD_INT 2
65610: NEG
65611: PUSH
65612: EMPTY
65613: LIST
65614: LIST
65615: PUSH
65616: LD_INT 2
65618: NEG
65619: PUSH
65620: LD_INT 3
65622: NEG
65623: PUSH
65624: EMPTY
65625: LIST
65626: LIST
65627: PUSH
65628: LD_INT 1
65630: NEG
65631: PUSH
65632: LD_INT 3
65634: NEG
65635: PUSH
65636: EMPTY
65637: LIST
65638: LIST
65639: PUSH
65640: LD_INT 1
65642: PUSH
65643: LD_INT 2
65645: NEG
65646: PUSH
65647: EMPTY
65648: LIST
65649: LIST
65650: PUSH
65651: LD_INT 2
65653: PUSH
65654: LD_INT 1
65656: NEG
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: EMPTY
65663: LIST
65664: LIST
65665: LIST
65666: LIST
65667: LIST
65668: LIST
65669: LIST
65670: LIST
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: LIST
65678: LIST
65679: LIST
65680: LIST
65681: LIST
65682: LIST
65683: LIST
65684: LIST
65685: LIST
65686: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65687: LD_ADDR_VAR 0 24
65691: PUSH
65692: LD_INT 0
65694: PUSH
65695: LD_INT 0
65697: PUSH
65698: EMPTY
65699: LIST
65700: LIST
65701: PUSH
65702: LD_INT 0
65704: PUSH
65705: LD_INT 1
65707: NEG
65708: PUSH
65709: EMPTY
65710: LIST
65711: LIST
65712: PUSH
65713: LD_INT 1
65715: PUSH
65716: LD_INT 0
65718: PUSH
65719: EMPTY
65720: LIST
65721: LIST
65722: PUSH
65723: LD_INT 1
65725: PUSH
65726: LD_INT 1
65728: PUSH
65729: EMPTY
65730: LIST
65731: LIST
65732: PUSH
65733: LD_INT 0
65735: PUSH
65736: LD_INT 1
65738: PUSH
65739: EMPTY
65740: LIST
65741: LIST
65742: PUSH
65743: LD_INT 1
65745: NEG
65746: PUSH
65747: LD_INT 0
65749: PUSH
65750: EMPTY
65751: LIST
65752: LIST
65753: PUSH
65754: LD_INT 1
65756: NEG
65757: PUSH
65758: LD_INT 1
65760: NEG
65761: PUSH
65762: EMPTY
65763: LIST
65764: LIST
65765: PUSH
65766: LD_INT 1
65768: NEG
65769: PUSH
65770: LD_INT 2
65772: NEG
65773: PUSH
65774: EMPTY
65775: LIST
65776: LIST
65777: PUSH
65778: LD_INT 0
65780: PUSH
65781: LD_INT 2
65783: NEG
65784: PUSH
65785: EMPTY
65786: LIST
65787: LIST
65788: PUSH
65789: LD_INT 1
65791: PUSH
65792: LD_INT 1
65794: NEG
65795: PUSH
65796: EMPTY
65797: LIST
65798: LIST
65799: PUSH
65800: LD_INT 2
65802: PUSH
65803: LD_INT 0
65805: PUSH
65806: EMPTY
65807: LIST
65808: LIST
65809: PUSH
65810: LD_INT 2
65812: PUSH
65813: LD_INT 1
65815: PUSH
65816: EMPTY
65817: LIST
65818: LIST
65819: PUSH
65820: LD_INT 2
65822: PUSH
65823: LD_INT 2
65825: PUSH
65826: EMPTY
65827: LIST
65828: LIST
65829: PUSH
65830: LD_INT 1
65832: PUSH
65833: LD_INT 2
65835: PUSH
65836: EMPTY
65837: LIST
65838: LIST
65839: PUSH
65840: LD_INT 0
65842: PUSH
65843: LD_INT 2
65845: PUSH
65846: EMPTY
65847: LIST
65848: LIST
65849: PUSH
65850: LD_INT 1
65852: NEG
65853: PUSH
65854: LD_INT 1
65856: PUSH
65857: EMPTY
65858: LIST
65859: LIST
65860: PUSH
65861: LD_INT 2
65863: NEG
65864: PUSH
65865: LD_INT 0
65867: PUSH
65868: EMPTY
65869: LIST
65870: LIST
65871: PUSH
65872: LD_INT 2
65874: NEG
65875: PUSH
65876: LD_INT 1
65878: NEG
65879: PUSH
65880: EMPTY
65881: LIST
65882: LIST
65883: PUSH
65884: LD_INT 2
65886: NEG
65887: PUSH
65888: LD_INT 2
65890: NEG
65891: PUSH
65892: EMPTY
65893: LIST
65894: LIST
65895: PUSH
65896: LD_INT 1
65898: PUSH
65899: LD_INT 2
65901: NEG
65902: PUSH
65903: EMPTY
65904: LIST
65905: LIST
65906: PUSH
65907: LD_INT 2
65909: PUSH
65910: LD_INT 1
65912: NEG
65913: PUSH
65914: EMPTY
65915: LIST
65916: LIST
65917: PUSH
65918: LD_INT 3
65920: PUSH
65921: LD_INT 1
65923: PUSH
65924: EMPTY
65925: LIST
65926: LIST
65927: PUSH
65928: LD_INT 3
65930: PUSH
65931: LD_INT 2
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: LIST
65942: LIST
65943: LIST
65944: LIST
65945: LIST
65946: LIST
65947: LIST
65948: LIST
65949: LIST
65950: LIST
65951: LIST
65952: LIST
65953: LIST
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: LIST
65959: LIST
65960: LIST
65961: LIST
65962: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
65963: LD_ADDR_VAR 0 25
65967: PUSH
65968: LD_INT 0
65970: PUSH
65971: LD_INT 0
65973: PUSH
65974: EMPTY
65975: LIST
65976: LIST
65977: PUSH
65978: LD_INT 0
65980: PUSH
65981: LD_INT 1
65983: NEG
65984: PUSH
65985: EMPTY
65986: LIST
65987: LIST
65988: PUSH
65989: LD_INT 1
65991: PUSH
65992: LD_INT 0
65994: PUSH
65995: EMPTY
65996: LIST
65997: LIST
65998: PUSH
65999: LD_INT 1
66001: PUSH
66002: LD_INT 1
66004: PUSH
66005: EMPTY
66006: LIST
66007: LIST
66008: PUSH
66009: LD_INT 0
66011: PUSH
66012: LD_INT 1
66014: PUSH
66015: EMPTY
66016: LIST
66017: LIST
66018: PUSH
66019: LD_INT 1
66021: NEG
66022: PUSH
66023: LD_INT 0
66025: PUSH
66026: EMPTY
66027: LIST
66028: LIST
66029: PUSH
66030: LD_INT 1
66032: NEG
66033: PUSH
66034: LD_INT 1
66036: NEG
66037: PUSH
66038: EMPTY
66039: LIST
66040: LIST
66041: PUSH
66042: LD_INT 1
66044: NEG
66045: PUSH
66046: LD_INT 2
66048: NEG
66049: PUSH
66050: EMPTY
66051: LIST
66052: LIST
66053: PUSH
66054: LD_INT 0
66056: PUSH
66057: LD_INT 2
66059: NEG
66060: PUSH
66061: EMPTY
66062: LIST
66063: LIST
66064: PUSH
66065: LD_INT 1
66067: PUSH
66068: LD_INT 1
66070: NEG
66071: PUSH
66072: EMPTY
66073: LIST
66074: LIST
66075: PUSH
66076: LD_INT 2
66078: PUSH
66079: LD_INT 0
66081: PUSH
66082: EMPTY
66083: LIST
66084: LIST
66085: PUSH
66086: LD_INT 2
66088: PUSH
66089: LD_INT 1
66091: PUSH
66092: EMPTY
66093: LIST
66094: LIST
66095: PUSH
66096: LD_INT 2
66098: PUSH
66099: LD_INT 2
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: PUSH
66106: LD_INT 1
66108: PUSH
66109: LD_INT 2
66111: PUSH
66112: EMPTY
66113: LIST
66114: LIST
66115: PUSH
66116: LD_INT 0
66118: PUSH
66119: LD_INT 2
66121: PUSH
66122: EMPTY
66123: LIST
66124: LIST
66125: PUSH
66126: LD_INT 1
66128: NEG
66129: PUSH
66130: LD_INT 1
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PUSH
66137: LD_INT 2
66139: NEG
66140: PUSH
66141: LD_INT 0
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: PUSH
66148: LD_INT 2
66150: NEG
66151: PUSH
66152: LD_INT 1
66154: NEG
66155: PUSH
66156: EMPTY
66157: LIST
66158: LIST
66159: PUSH
66160: LD_INT 2
66162: NEG
66163: PUSH
66164: LD_INT 2
66166: NEG
66167: PUSH
66168: EMPTY
66169: LIST
66170: LIST
66171: PUSH
66172: LD_INT 3
66174: PUSH
66175: LD_INT 1
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: LD_INT 3
66184: PUSH
66185: LD_INT 2
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: LD_INT 2
66194: PUSH
66195: LD_INT 3
66197: PUSH
66198: EMPTY
66199: LIST
66200: LIST
66201: PUSH
66202: LD_INT 1
66204: PUSH
66205: LD_INT 3
66207: PUSH
66208: EMPTY
66209: LIST
66210: LIST
66211: PUSH
66212: EMPTY
66213: LIST
66214: LIST
66215: LIST
66216: LIST
66217: LIST
66218: LIST
66219: LIST
66220: LIST
66221: LIST
66222: LIST
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: LIST
66235: LIST
66236: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66237: LD_ADDR_VAR 0 26
66241: PUSH
66242: LD_INT 0
66244: PUSH
66245: LD_INT 0
66247: PUSH
66248: EMPTY
66249: LIST
66250: LIST
66251: PUSH
66252: LD_INT 0
66254: PUSH
66255: LD_INT 1
66257: NEG
66258: PUSH
66259: EMPTY
66260: LIST
66261: LIST
66262: PUSH
66263: LD_INT 1
66265: PUSH
66266: LD_INT 0
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PUSH
66273: LD_INT 1
66275: PUSH
66276: LD_INT 1
66278: PUSH
66279: EMPTY
66280: LIST
66281: LIST
66282: PUSH
66283: LD_INT 0
66285: PUSH
66286: LD_INT 1
66288: PUSH
66289: EMPTY
66290: LIST
66291: LIST
66292: PUSH
66293: LD_INT 1
66295: NEG
66296: PUSH
66297: LD_INT 0
66299: PUSH
66300: EMPTY
66301: LIST
66302: LIST
66303: PUSH
66304: LD_INT 1
66306: NEG
66307: PUSH
66308: LD_INT 1
66310: NEG
66311: PUSH
66312: EMPTY
66313: LIST
66314: LIST
66315: PUSH
66316: LD_INT 1
66318: NEG
66319: PUSH
66320: LD_INT 2
66322: NEG
66323: PUSH
66324: EMPTY
66325: LIST
66326: LIST
66327: PUSH
66328: LD_INT 0
66330: PUSH
66331: LD_INT 2
66333: NEG
66334: PUSH
66335: EMPTY
66336: LIST
66337: LIST
66338: PUSH
66339: LD_INT 1
66341: PUSH
66342: LD_INT 1
66344: NEG
66345: PUSH
66346: EMPTY
66347: LIST
66348: LIST
66349: PUSH
66350: LD_INT 2
66352: PUSH
66353: LD_INT 0
66355: PUSH
66356: EMPTY
66357: LIST
66358: LIST
66359: PUSH
66360: LD_INT 2
66362: PUSH
66363: LD_INT 1
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: PUSH
66370: LD_INT 2
66372: PUSH
66373: LD_INT 2
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: PUSH
66380: LD_INT 1
66382: PUSH
66383: LD_INT 2
66385: PUSH
66386: EMPTY
66387: LIST
66388: LIST
66389: PUSH
66390: LD_INT 0
66392: PUSH
66393: LD_INT 2
66395: PUSH
66396: EMPTY
66397: LIST
66398: LIST
66399: PUSH
66400: LD_INT 1
66402: NEG
66403: PUSH
66404: LD_INT 1
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 2
66413: NEG
66414: PUSH
66415: LD_INT 0
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: LD_INT 2
66424: NEG
66425: PUSH
66426: LD_INT 1
66428: NEG
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: LD_INT 2
66436: NEG
66437: PUSH
66438: LD_INT 2
66440: NEG
66441: PUSH
66442: EMPTY
66443: LIST
66444: LIST
66445: PUSH
66446: LD_INT 2
66448: PUSH
66449: LD_INT 3
66451: PUSH
66452: EMPTY
66453: LIST
66454: LIST
66455: PUSH
66456: LD_INT 1
66458: PUSH
66459: LD_INT 3
66461: PUSH
66462: EMPTY
66463: LIST
66464: LIST
66465: PUSH
66466: LD_INT 1
66468: NEG
66469: PUSH
66470: LD_INT 2
66472: PUSH
66473: EMPTY
66474: LIST
66475: LIST
66476: PUSH
66477: LD_INT 2
66479: NEG
66480: PUSH
66481: LD_INT 1
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: EMPTY
66489: LIST
66490: LIST
66491: LIST
66492: LIST
66493: LIST
66494: LIST
66495: LIST
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: LIST
66501: LIST
66502: LIST
66503: LIST
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66513: LD_ADDR_VAR 0 27
66517: PUSH
66518: LD_INT 0
66520: PUSH
66521: LD_INT 0
66523: PUSH
66524: EMPTY
66525: LIST
66526: LIST
66527: PUSH
66528: LD_INT 0
66530: PUSH
66531: LD_INT 1
66533: NEG
66534: PUSH
66535: EMPTY
66536: LIST
66537: LIST
66538: PUSH
66539: LD_INT 1
66541: PUSH
66542: LD_INT 0
66544: PUSH
66545: EMPTY
66546: LIST
66547: LIST
66548: PUSH
66549: LD_INT 1
66551: PUSH
66552: LD_INT 1
66554: PUSH
66555: EMPTY
66556: LIST
66557: LIST
66558: PUSH
66559: LD_INT 0
66561: PUSH
66562: LD_INT 1
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: PUSH
66569: LD_INT 1
66571: NEG
66572: PUSH
66573: LD_INT 0
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 1
66582: NEG
66583: PUSH
66584: LD_INT 1
66586: NEG
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 1
66594: NEG
66595: PUSH
66596: LD_INT 2
66598: NEG
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: LD_INT 0
66606: PUSH
66607: LD_INT 2
66609: NEG
66610: PUSH
66611: EMPTY
66612: LIST
66613: LIST
66614: PUSH
66615: LD_INT 1
66617: PUSH
66618: LD_INT 1
66620: NEG
66621: PUSH
66622: EMPTY
66623: LIST
66624: LIST
66625: PUSH
66626: LD_INT 2
66628: PUSH
66629: LD_INT 0
66631: PUSH
66632: EMPTY
66633: LIST
66634: LIST
66635: PUSH
66636: LD_INT 2
66638: PUSH
66639: LD_INT 1
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: PUSH
66646: LD_INT 2
66648: PUSH
66649: LD_INT 2
66651: PUSH
66652: EMPTY
66653: LIST
66654: LIST
66655: PUSH
66656: LD_INT 1
66658: PUSH
66659: LD_INT 2
66661: PUSH
66662: EMPTY
66663: LIST
66664: LIST
66665: PUSH
66666: LD_INT 0
66668: PUSH
66669: LD_INT 2
66671: PUSH
66672: EMPTY
66673: LIST
66674: LIST
66675: PUSH
66676: LD_INT 1
66678: NEG
66679: PUSH
66680: LD_INT 1
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: PUSH
66687: LD_INT 2
66689: NEG
66690: PUSH
66691: LD_INT 0
66693: PUSH
66694: EMPTY
66695: LIST
66696: LIST
66697: PUSH
66698: LD_INT 2
66700: NEG
66701: PUSH
66702: LD_INT 1
66704: NEG
66705: PUSH
66706: EMPTY
66707: LIST
66708: LIST
66709: PUSH
66710: LD_INT 2
66712: NEG
66713: PUSH
66714: LD_INT 2
66716: NEG
66717: PUSH
66718: EMPTY
66719: LIST
66720: LIST
66721: PUSH
66722: LD_INT 1
66724: NEG
66725: PUSH
66726: LD_INT 2
66728: PUSH
66729: EMPTY
66730: LIST
66731: LIST
66732: PUSH
66733: LD_INT 2
66735: NEG
66736: PUSH
66737: LD_INT 1
66739: PUSH
66740: EMPTY
66741: LIST
66742: LIST
66743: PUSH
66744: LD_INT 3
66746: NEG
66747: PUSH
66748: LD_INT 1
66750: NEG
66751: PUSH
66752: EMPTY
66753: LIST
66754: LIST
66755: PUSH
66756: LD_INT 3
66758: NEG
66759: PUSH
66760: LD_INT 2
66762: NEG
66763: PUSH
66764: EMPTY
66765: LIST
66766: LIST
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: LIST
66772: LIST
66773: LIST
66774: LIST
66775: LIST
66776: LIST
66777: LIST
66778: LIST
66779: LIST
66780: LIST
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66793: LD_ADDR_VAR 0 28
66797: PUSH
66798: LD_INT 0
66800: PUSH
66801: LD_INT 0
66803: PUSH
66804: EMPTY
66805: LIST
66806: LIST
66807: PUSH
66808: LD_INT 0
66810: PUSH
66811: LD_INT 1
66813: NEG
66814: PUSH
66815: EMPTY
66816: LIST
66817: LIST
66818: PUSH
66819: LD_INT 1
66821: PUSH
66822: LD_INT 0
66824: PUSH
66825: EMPTY
66826: LIST
66827: LIST
66828: PUSH
66829: LD_INT 1
66831: PUSH
66832: LD_INT 1
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: LD_INT 0
66841: PUSH
66842: LD_INT 1
66844: PUSH
66845: EMPTY
66846: LIST
66847: LIST
66848: PUSH
66849: LD_INT 1
66851: NEG
66852: PUSH
66853: LD_INT 0
66855: PUSH
66856: EMPTY
66857: LIST
66858: LIST
66859: PUSH
66860: LD_INT 1
66862: NEG
66863: PUSH
66864: LD_INT 1
66866: NEG
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: LD_INT 1
66874: NEG
66875: PUSH
66876: LD_INT 2
66878: NEG
66879: PUSH
66880: EMPTY
66881: LIST
66882: LIST
66883: PUSH
66884: LD_INT 0
66886: PUSH
66887: LD_INT 2
66889: NEG
66890: PUSH
66891: EMPTY
66892: LIST
66893: LIST
66894: PUSH
66895: LD_INT 1
66897: PUSH
66898: LD_INT 1
66900: NEG
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: PUSH
66906: LD_INT 2
66908: PUSH
66909: LD_INT 0
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PUSH
66916: LD_INT 2
66918: PUSH
66919: LD_INT 1
66921: PUSH
66922: EMPTY
66923: LIST
66924: LIST
66925: PUSH
66926: LD_INT 2
66928: PUSH
66929: LD_INT 2
66931: PUSH
66932: EMPTY
66933: LIST
66934: LIST
66935: PUSH
66936: LD_INT 1
66938: PUSH
66939: LD_INT 2
66941: PUSH
66942: EMPTY
66943: LIST
66944: LIST
66945: PUSH
66946: LD_INT 0
66948: PUSH
66949: LD_INT 2
66951: PUSH
66952: EMPTY
66953: LIST
66954: LIST
66955: PUSH
66956: LD_INT 1
66958: NEG
66959: PUSH
66960: LD_INT 1
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PUSH
66967: LD_INT 2
66969: NEG
66970: PUSH
66971: LD_INT 0
66973: PUSH
66974: EMPTY
66975: LIST
66976: LIST
66977: PUSH
66978: LD_INT 2
66980: NEG
66981: PUSH
66982: LD_INT 1
66984: NEG
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: LD_INT 2
66992: NEG
66993: PUSH
66994: LD_INT 2
66996: NEG
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: PUSH
67002: LD_INT 2
67004: NEG
67005: PUSH
67006: LD_INT 3
67008: NEG
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: LD_INT 1
67016: NEG
67017: PUSH
67018: LD_INT 3
67020: NEG
67021: PUSH
67022: EMPTY
67023: LIST
67024: LIST
67025: PUSH
67026: LD_INT 3
67028: NEG
67029: PUSH
67030: LD_INT 1
67032: NEG
67033: PUSH
67034: EMPTY
67035: LIST
67036: LIST
67037: PUSH
67038: LD_INT 3
67040: NEG
67041: PUSH
67042: LD_INT 2
67044: NEG
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: LIST
67054: LIST
67055: LIST
67056: LIST
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: LIST
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: LIST
67073: LIST
67074: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67075: LD_ADDR_VAR 0 29
67079: PUSH
67080: LD_INT 0
67082: PUSH
67083: LD_INT 0
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PUSH
67090: LD_INT 0
67092: PUSH
67093: LD_INT 1
67095: NEG
67096: PUSH
67097: EMPTY
67098: LIST
67099: LIST
67100: PUSH
67101: LD_INT 1
67103: PUSH
67104: LD_INT 0
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: LD_INT 1
67113: PUSH
67114: LD_INT 1
67116: PUSH
67117: EMPTY
67118: LIST
67119: LIST
67120: PUSH
67121: LD_INT 0
67123: PUSH
67124: LD_INT 1
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: PUSH
67131: LD_INT 1
67133: NEG
67134: PUSH
67135: LD_INT 0
67137: PUSH
67138: EMPTY
67139: LIST
67140: LIST
67141: PUSH
67142: LD_INT 1
67144: NEG
67145: PUSH
67146: LD_INT 1
67148: NEG
67149: PUSH
67150: EMPTY
67151: LIST
67152: LIST
67153: PUSH
67154: LD_INT 1
67156: NEG
67157: PUSH
67158: LD_INT 2
67160: NEG
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: LD_INT 0
67168: PUSH
67169: LD_INT 2
67171: NEG
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 1
67179: PUSH
67180: LD_INT 1
67182: NEG
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: PUSH
67188: LD_INT 2
67190: PUSH
67191: LD_INT 0
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: LD_INT 2
67200: PUSH
67201: LD_INT 1
67203: PUSH
67204: EMPTY
67205: LIST
67206: LIST
67207: PUSH
67208: LD_INT 1
67210: PUSH
67211: LD_INT 2
67213: PUSH
67214: EMPTY
67215: LIST
67216: LIST
67217: PUSH
67218: LD_INT 0
67220: PUSH
67221: LD_INT 2
67223: PUSH
67224: EMPTY
67225: LIST
67226: LIST
67227: PUSH
67228: LD_INT 1
67230: NEG
67231: PUSH
67232: LD_INT 1
67234: PUSH
67235: EMPTY
67236: LIST
67237: LIST
67238: PUSH
67239: LD_INT 2
67241: NEG
67242: PUSH
67243: LD_INT 1
67245: NEG
67246: PUSH
67247: EMPTY
67248: LIST
67249: LIST
67250: PUSH
67251: LD_INT 2
67253: NEG
67254: PUSH
67255: LD_INT 2
67257: NEG
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PUSH
67263: LD_INT 2
67265: NEG
67266: PUSH
67267: LD_INT 3
67269: NEG
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: PUSH
67275: LD_INT 2
67277: PUSH
67278: LD_INT 1
67280: NEG
67281: PUSH
67282: EMPTY
67283: LIST
67284: LIST
67285: PUSH
67286: LD_INT 3
67288: PUSH
67289: LD_INT 1
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 1
67298: PUSH
67299: LD_INT 3
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: LD_INT 1
67308: NEG
67309: PUSH
67310: LD_INT 2
67312: PUSH
67313: EMPTY
67314: LIST
67315: LIST
67316: PUSH
67317: LD_INT 3
67319: NEG
67320: PUSH
67321: LD_INT 2
67323: NEG
67324: PUSH
67325: EMPTY
67326: LIST
67327: LIST
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: LIST
67333: LIST
67334: LIST
67335: LIST
67336: LIST
67337: LIST
67338: LIST
67339: LIST
67340: LIST
67341: LIST
67342: LIST
67343: LIST
67344: LIST
67345: LIST
67346: LIST
67347: LIST
67348: LIST
67349: LIST
67350: LIST
67351: LIST
67352: LIST
67353: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67354: LD_ADDR_VAR 0 30
67358: PUSH
67359: LD_INT 0
67361: PUSH
67362: LD_INT 0
67364: PUSH
67365: EMPTY
67366: LIST
67367: LIST
67368: PUSH
67369: LD_INT 0
67371: PUSH
67372: LD_INT 1
67374: NEG
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: PUSH
67380: LD_INT 1
67382: PUSH
67383: LD_INT 0
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: PUSH
67390: LD_INT 1
67392: PUSH
67393: LD_INT 1
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 0
67402: PUSH
67403: LD_INT 1
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 1
67412: NEG
67413: PUSH
67414: LD_INT 0
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: PUSH
67421: LD_INT 1
67423: NEG
67424: PUSH
67425: LD_INT 1
67427: NEG
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: PUSH
67433: LD_INT 1
67435: NEG
67436: PUSH
67437: LD_INT 2
67439: NEG
67440: PUSH
67441: EMPTY
67442: LIST
67443: LIST
67444: PUSH
67445: LD_INT 0
67447: PUSH
67448: LD_INT 2
67450: NEG
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: PUSH
67456: LD_INT 1
67458: PUSH
67459: LD_INT 1
67461: NEG
67462: PUSH
67463: EMPTY
67464: LIST
67465: LIST
67466: PUSH
67467: LD_INT 2
67469: PUSH
67470: LD_INT 0
67472: PUSH
67473: EMPTY
67474: LIST
67475: LIST
67476: PUSH
67477: LD_INT 2
67479: PUSH
67480: LD_INT 1
67482: PUSH
67483: EMPTY
67484: LIST
67485: LIST
67486: PUSH
67487: LD_INT 2
67489: PUSH
67490: LD_INT 2
67492: PUSH
67493: EMPTY
67494: LIST
67495: LIST
67496: PUSH
67497: LD_INT 1
67499: PUSH
67500: LD_INT 2
67502: PUSH
67503: EMPTY
67504: LIST
67505: LIST
67506: PUSH
67507: LD_INT 1
67509: NEG
67510: PUSH
67511: LD_INT 1
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: PUSH
67518: LD_INT 2
67520: NEG
67521: PUSH
67522: LD_INT 0
67524: PUSH
67525: EMPTY
67526: LIST
67527: LIST
67528: PUSH
67529: LD_INT 2
67531: NEG
67532: PUSH
67533: LD_INT 1
67535: NEG
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: LD_INT 1
67543: NEG
67544: PUSH
67545: LD_INT 3
67547: NEG
67548: PUSH
67549: EMPTY
67550: LIST
67551: LIST
67552: PUSH
67553: LD_INT 1
67555: PUSH
67556: LD_INT 2
67558: NEG
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 3
67566: PUSH
67567: LD_INT 2
67569: PUSH
67570: EMPTY
67571: LIST
67572: LIST
67573: PUSH
67574: LD_INT 2
67576: PUSH
67577: LD_INT 3
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: LD_INT 2
67586: NEG
67587: PUSH
67588: LD_INT 1
67590: PUSH
67591: EMPTY
67592: LIST
67593: LIST
67594: PUSH
67595: LD_INT 3
67597: NEG
67598: PUSH
67599: LD_INT 1
67601: NEG
67602: PUSH
67603: EMPTY
67604: LIST
67605: LIST
67606: PUSH
67607: EMPTY
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: LIST
67631: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67632: LD_ADDR_VAR 0 31
67636: PUSH
67637: LD_INT 0
67639: PUSH
67640: LD_INT 0
67642: PUSH
67643: EMPTY
67644: LIST
67645: LIST
67646: PUSH
67647: LD_INT 0
67649: PUSH
67650: LD_INT 1
67652: NEG
67653: PUSH
67654: EMPTY
67655: LIST
67656: LIST
67657: PUSH
67658: LD_INT 1
67660: PUSH
67661: LD_INT 0
67663: PUSH
67664: EMPTY
67665: LIST
67666: LIST
67667: PUSH
67668: LD_INT 1
67670: PUSH
67671: LD_INT 1
67673: PUSH
67674: EMPTY
67675: LIST
67676: LIST
67677: PUSH
67678: LD_INT 0
67680: PUSH
67681: LD_INT 1
67683: PUSH
67684: EMPTY
67685: LIST
67686: LIST
67687: PUSH
67688: LD_INT 1
67690: NEG
67691: PUSH
67692: LD_INT 0
67694: PUSH
67695: EMPTY
67696: LIST
67697: LIST
67698: PUSH
67699: LD_INT 1
67701: NEG
67702: PUSH
67703: LD_INT 1
67705: NEG
67706: PUSH
67707: EMPTY
67708: LIST
67709: LIST
67710: PUSH
67711: LD_INT 1
67713: NEG
67714: PUSH
67715: LD_INT 2
67717: NEG
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: PUSH
67723: LD_INT 1
67725: PUSH
67726: LD_INT 1
67728: NEG
67729: PUSH
67730: EMPTY
67731: LIST
67732: LIST
67733: PUSH
67734: LD_INT 2
67736: PUSH
67737: LD_INT 0
67739: PUSH
67740: EMPTY
67741: LIST
67742: LIST
67743: PUSH
67744: LD_INT 2
67746: PUSH
67747: LD_INT 1
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: LD_INT 2
67756: PUSH
67757: LD_INT 2
67759: PUSH
67760: EMPTY
67761: LIST
67762: LIST
67763: PUSH
67764: LD_INT 1
67766: PUSH
67767: LD_INT 2
67769: PUSH
67770: EMPTY
67771: LIST
67772: LIST
67773: PUSH
67774: LD_INT 0
67776: PUSH
67777: LD_INT 2
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: LD_INT 1
67786: NEG
67787: PUSH
67788: LD_INT 1
67790: PUSH
67791: EMPTY
67792: LIST
67793: LIST
67794: PUSH
67795: LD_INT 2
67797: NEG
67798: PUSH
67799: LD_INT 1
67801: NEG
67802: PUSH
67803: EMPTY
67804: LIST
67805: LIST
67806: PUSH
67807: LD_INT 2
67809: NEG
67810: PUSH
67811: LD_INT 2
67813: NEG
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PUSH
67819: LD_INT 2
67821: NEG
67822: PUSH
67823: LD_INT 3
67825: NEG
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: PUSH
67831: LD_INT 2
67833: PUSH
67834: LD_INT 1
67836: NEG
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: PUSH
67842: LD_INT 3
67844: PUSH
67845: LD_INT 1
67847: PUSH
67848: EMPTY
67849: LIST
67850: LIST
67851: PUSH
67852: LD_INT 1
67854: PUSH
67855: LD_INT 3
67857: PUSH
67858: EMPTY
67859: LIST
67860: LIST
67861: PUSH
67862: LD_INT 1
67864: NEG
67865: PUSH
67866: LD_INT 2
67868: PUSH
67869: EMPTY
67870: LIST
67871: LIST
67872: PUSH
67873: LD_INT 3
67875: NEG
67876: PUSH
67877: LD_INT 2
67879: NEG
67880: PUSH
67881: EMPTY
67882: LIST
67883: LIST
67884: PUSH
67885: EMPTY
67886: LIST
67887: LIST
67888: LIST
67889: LIST
67890: LIST
67891: LIST
67892: LIST
67893: LIST
67894: LIST
67895: LIST
67896: LIST
67897: LIST
67898: LIST
67899: LIST
67900: LIST
67901: LIST
67902: LIST
67903: LIST
67904: LIST
67905: LIST
67906: LIST
67907: LIST
67908: LIST
67909: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67910: LD_ADDR_VAR 0 32
67914: PUSH
67915: LD_INT 0
67917: PUSH
67918: LD_INT 0
67920: PUSH
67921: EMPTY
67922: LIST
67923: LIST
67924: PUSH
67925: LD_INT 0
67927: PUSH
67928: LD_INT 1
67930: NEG
67931: PUSH
67932: EMPTY
67933: LIST
67934: LIST
67935: PUSH
67936: LD_INT 1
67938: PUSH
67939: LD_INT 0
67941: PUSH
67942: EMPTY
67943: LIST
67944: LIST
67945: PUSH
67946: LD_INT 1
67948: PUSH
67949: LD_INT 1
67951: PUSH
67952: EMPTY
67953: LIST
67954: LIST
67955: PUSH
67956: LD_INT 0
67958: PUSH
67959: LD_INT 1
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 1
67968: NEG
67969: PUSH
67970: LD_INT 0
67972: PUSH
67973: EMPTY
67974: LIST
67975: LIST
67976: PUSH
67977: LD_INT 1
67979: NEG
67980: PUSH
67981: LD_INT 1
67983: NEG
67984: PUSH
67985: EMPTY
67986: LIST
67987: LIST
67988: PUSH
67989: LD_INT 1
67991: NEG
67992: PUSH
67993: LD_INT 2
67995: NEG
67996: PUSH
67997: EMPTY
67998: LIST
67999: LIST
68000: PUSH
68001: LD_INT 0
68003: PUSH
68004: LD_INT 2
68006: NEG
68007: PUSH
68008: EMPTY
68009: LIST
68010: LIST
68011: PUSH
68012: LD_INT 1
68014: PUSH
68015: LD_INT 1
68017: NEG
68018: PUSH
68019: EMPTY
68020: LIST
68021: LIST
68022: PUSH
68023: LD_INT 2
68025: PUSH
68026: LD_INT 1
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 2
68035: PUSH
68036: LD_INT 2
68038: PUSH
68039: EMPTY
68040: LIST
68041: LIST
68042: PUSH
68043: LD_INT 1
68045: PUSH
68046: LD_INT 2
68048: PUSH
68049: EMPTY
68050: LIST
68051: LIST
68052: PUSH
68053: LD_INT 0
68055: PUSH
68056: LD_INT 2
68058: PUSH
68059: EMPTY
68060: LIST
68061: LIST
68062: PUSH
68063: LD_INT 1
68065: NEG
68066: PUSH
68067: LD_INT 1
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PUSH
68074: LD_INT 2
68076: NEG
68077: PUSH
68078: LD_INT 0
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 2
68087: NEG
68088: PUSH
68089: LD_INT 1
68091: NEG
68092: PUSH
68093: EMPTY
68094: LIST
68095: LIST
68096: PUSH
68097: LD_INT 1
68099: NEG
68100: PUSH
68101: LD_INT 3
68103: NEG
68104: PUSH
68105: EMPTY
68106: LIST
68107: LIST
68108: PUSH
68109: LD_INT 1
68111: PUSH
68112: LD_INT 2
68114: NEG
68115: PUSH
68116: EMPTY
68117: LIST
68118: LIST
68119: PUSH
68120: LD_INT 3
68122: PUSH
68123: LD_INT 2
68125: PUSH
68126: EMPTY
68127: LIST
68128: LIST
68129: PUSH
68130: LD_INT 2
68132: PUSH
68133: LD_INT 3
68135: PUSH
68136: EMPTY
68137: LIST
68138: LIST
68139: PUSH
68140: LD_INT 2
68142: NEG
68143: PUSH
68144: LD_INT 1
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: PUSH
68151: LD_INT 3
68153: NEG
68154: PUSH
68155: LD_INT 1
68157: NEG
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: PUSH
68163: EMPTY
68164: LIST
68165: LIST
68166: LIST
68167: LIST
68168: LIST
68169: LIST
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: LIST
68180: LIST
68181: LIST
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68188: LD_ADDR_VAR 0 33
68192: PUSH
68193: LD_INT 0
68195: PUSH
68196: LD_INT 0
68198: PUSH
68199: EMPTY
68200: LIST
68201: LIST
68202: PUSH
68203: LD_INT 0
68205: PUSH
68206: LD_INT 1
68208: NEG
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: PUSH
68214: LD_INT 1
68216: PUSH
68217: LD_INT 0
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: PUSH
68224: LD_INT 1
68226: PUSH
68227: LD_INT 1
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: LD_INT 0
68236: PUSH
68237: LD_INT 1
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: LD_INT 1
68246: NEG
68247: PUSH
68248: LD_INT 0
68250: PUSH
68251: EMPTY
68252: LIST
68253: LIST
68254: PUSH
68255: LD_INT 1
68257: NEG
68258: PUSH
68259: LD_INT 1
68261: NEG
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: PUSH
68267: LD_INT 1
68269: NEG
68270: PUSH
68271: LD_INT 2
68273: NEG
68274: PUSH
68275: EMPTY
68276: LIST
68277: LIST
68278: PUSH
68279: LD_INT 1
68281: PUSH
68282: LD_INT 1
68284: NEG
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: LD_INT 2
68292: PUSH
68293: LD_INT 0
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: LD_INT 2
68302: PUSH
68303: LD_INT 1
68305: PUSH
68306: EMPTY
68307: LIST
68308: LIST
68309: PUSH
68310: LD_INT 1
68312: PUSH
68313: LD_INT 2
68315: PUSH
68316: EMPTY
68317: LIST
68318: LIST
68319: PUSH
68320: LD_INT 0
68322: PUSH
68323: LD_INT 2
68325: PUSH
68326: EMPTY
68327: LIST
68328: LIST
68329: PUSH
68330: LD_INT 1
68332: NEG
68333: PUSH
68334: LD_INT 1
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: LD_INT 2
68343: NEG
68344: PUSH
68345: LD_INT 0
68347: PUSH
68348: EMPTY
68349: LIST
68350: LIST
68351: PUSH
68352: LD_INT 2
68354: NEG
68355: PUSH
68356: LD_INT 1
68358: NEG
68359: PUSH
68360: EMPTY
68361: LIST
68362: LIST
68363: PUSH
68364: LD_INT 2
68366: NEG
68367: PUSH
68368: LD_INT 2
68370: NEG
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: PUSH
68376: LD_INT 2
68378: NEG
68379: PUSH
68380: LD_INT 3
68382: NEG
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 2
68390: PUSH
68391: LD_INT 1
68393: NEG
68394: PUSH
68395: EMPTY
68396: LIST
68397: LIST
68398: PUSH
68399: LD_INT 3
68401: PUSH
68402: LD_INT 1
68404: PUSH
68405: EMPTY
68406: LIST
68407: LIST
68408: PUSH
68409: LD_INT 1
68411: PUSH
68412: LD_INT 3
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PUSH
68419: LD_INT 1
68421: NEG
68422: PUSH
68423: LD_INT 2
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 3
68432: NEG
68433: PUSH
68434: LD_INT 2
68436: NEG
68437: PUSH
68438: EMPTY
68439: LIST
68440: LIST
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: LIST
68446: LIST
68447: LIST
68448: LIST
68449: LIST
68450: LIST
68451: LIST
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: LIST
68457: LIST
68458: LIST
68459: LIST
68460: LIST
68461: LIST
68462: LIST
68463: LIST
68464: LIST
68465: LIST
68466: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68467: LD_ADDR_VAR 0 34
68471: PUSH
68472: LD_INT 0
68474: PUSH
68475: LD_INT 0
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 0
68484: PUSH
68485: LD_INT 1
68487: NEG
68488: PUSH
68489: EMPTY
68490: LIST
68491: LIST
68492: PUSH
68493: LD_INT 1
68495: PUSH
68496: LD_INT 0
68498: PUSH
68499: EMPTY
68500: LIST
68501: LIST
68502: PUSH
68503: LD_INT 1
68505: PUSH
68506: LD_INT 1
68508: PUSH
68509: EMPTY
68510: LIST
68511: LIST
68512: PUSH
68513: LD_INT 0
68515: PUSH
68516: LD_INT 1
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: PUSH
68523: LD_INT 1
68525: NEG
68526: PUSH
68527: LD_INT 0
68529: PUSH
68530: EMPTY
68531: LIST
68532: LIST
68533: PUSH
68534: LD_INT 1
68536: NEG
68537: PUSH
68538: LD_INT 1
68540: NEG
68541: PUSH
68542: EMPTY
68543: LIST
68544: LIST
68545: PUSH
68546: LD_INT 1
68548: NEG
68549: PUSH
68550: LD_INT 2
68552: NEG
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: PUSH
68558: LD_INT 0
68560: PUSH
68561: LD_INT 2
68563: NEG
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: PUSH
68569: LD_INT 1
68571: PUSH
68572: LD_INT 1
68574: NEG
68575: PUSH
68576: EMPTY
68577: LIST
68578: LIST
68579: PUSH
68580: LD_INT 2
68582: PUSH
68583: LD_INT 1
68585: PUSH
68586: EMPTY
68587: LIST
68588: LIST
68589: PUSH
68590: LD_INT 2
68592: PUSH
68593: LD_INT 2
68595: PUSH
68596: EMPTY
68597: LIST
68598: LIST
68599: PUSH
68600: LD_INT 1
68602: PUSH
68603: LD_INT 2
68605: PUSH
68606: EMPTY
68607: LIST
68608: LIST
68609: PUSH
68610: LD_INT 1
68612: NEG
68613: PUSH
68614: LD_INT 1
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: LD_INT 2
68623: NEG
68624: PUSH
68625: LD_INT 0
68627: PUSH
68628: EMPTY
68629: LIST
68630: LIST
68631: PUSH
68632: LD_INT 2
68634: NEG
68635: PUSH
68636: LD_INT 1
68638: NEG
68639: PUSH
68640: EMPTY
68641: LIST
68642: LIST
68643: PUSH
68644: LD_INT 2
68646: NEG
68647: PUSH
68648: LD_INT 2
68650: NEG
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: PUSH
68656: LD_INT 1
68658: NEG
68659: PUSH
68660: LD_INT 3
68662: NEG
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: PUSH
68668: LD_INT 1
68670: PUSH
68671: LD_INT 2
68673: NEG
68674: PUSH
68675: EMPTY
68676: LIST
68677: LIST
68678: PUSH
68679: LD_INT 3
68681: PUSH
68682: LD_INT 2
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: LD_INT 2
68691: PUSH
68692: LD_INT 3
68694: PUSH
68695: EMPTY
68696: LIST
68697: LIST
68698: PUSH
68699: LD_INT 2
68701: NEG
68702: PUSH
68703: LD_INT 1
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: PUSH
68710: LD_INT 3
68712: NEG
68713: PUSH
68714: LD_INT 1
68716: NEG
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: EMPTY
68723: LIST
68724: LIST
68725: LIST
68726: LIST
68727: LIST
68728: LIST
68729: LIST
68730: LIST
68731: LIST
68732: LIST
68733: LIST
68734: LIST
68735: LIST
68736: LIST
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: LIST
68742: LIST
68743: LIST
68744: LIST
68745: LIST
68746: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68747: LD_ADDR_VAR 0 35
68751: PUSH
68752: LD_INT 0
68754: PUSH
68755: LD_INT 0
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: PUSH
68762: LD_INT 0
68764: PUSH
68765: LD_INT 1
68767: NEG
68768: PUSH
68769: EMPTY
68770: LIST
68771: LIST
68772: PUSH
68773: LD_INT 1
68775: PUSH
68776: LD_INT 0
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PUSH
68783: LD_INT 1
68785: PUSH
68786: LD_INT 1
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 0
68795: PUSH
68796: LD_INT 1
68798: PUSH
68799: EMPTY
68800: LIST
68801: LIST
68802: PUSH
68803: LD_INT 1
68805: NEG
68806: PUSH
68807: LD_INT 0
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: LD_INT 1
68816: NEG
68817: PUSH
68818: LD_INT 1
68820: NEG
68821: PUSH
68822: EMPTY
68823: LIST
68824: LIST
68825: PUSH
68826: LD_INT 2
68828: PUSH
68829: LD_INT 1
68831: PUSH
68832: EMPTY
68833: LIST
68834: LIST
68835: PUSH
68836: LD_INT 2
68838: NEG
68839: PUSH
68840: LD_INT 1
68842: NEG
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68859: LD_ADDR_VAR 0 36
68863: PUSH
68864: LD_INT 0
68866: PUSH
68867: LD_INT 0
68869: PUSH
68870: EMPTY
68871: LIST
68872: LIST
68873: PUSH
68874: LD_INT 0
68876: PUSH
68877: LD_INT 1
68879: NEG
68880: PUSH
68881: EMPTY
68882: LIST
68883: LIST
68884: PUSH
68885: LD_INT 1
68887: PUSH
68888: LD_INT 0
68890: PUSH
68891: EMPTY
68892: LIST
68893: LIST
68894: PUSH
68895: LD_INT 1
68897: PUSH
68898: LD_INT 1
68900: PUSH
68901: EMPTY
68902: LIST
68903: LIST
68904: PUSH
68905: LD_INT 0
68907: PUSH
68908: LD_INT 1
68910: PUSH
68911: EMPTY
68912: LIST
68913: LIST
68914: PUSH
68915: LD_INT 1
68917: NEG
68918: PUSH
68919: LD_INT 0
68921: PUSH
68922: EMPTY
68923: LIST
68924: LIST
68925: PUSH
68926: LD_INT 1
68928: NEG
68929: PUSH
68930: LD_INT 1
68932: NEG
68933: PUSH
68934: EMPTY
68935: LIST
68936: LIST
68937: PUSH
68938: LD_INT 1
68940: NEG
68941: PUSH
68942: LD_INT 2
68944: NEG
68945: PUSH
68946: EMPTY
68947: LIST
68948: LIST
68949: PUSH
68950: LD_INT 1
68952: PUSH
68953: LD_INT 2
68955: PUSH
68956: EMPTY
68957: LIST
68958: LIST
68959: PUSH
68960: EMPTY
68961: LIST
68962: LIST
68963: LIST
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: LIST
68970: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68971: LD_ADDR_VAR 0 37
68975: PUSH
68976: LD_INT 0
68978: PUSH
68979: LD_INT 0
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 0
68988: PUSH
68989: LD_INT 1
68991: NEG
68992: PUSH
68993: EMPTY
68994: LIST
68995: LIST
68996: PUSH
68997: LD_INT 1
68999: PUSH
69000: LD_INT 0
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PUSH
69007: LD_INT 1
69009: PUSH
69010: LD_INT 1
69012: PUSH
69013: EMPTY
69014: LIST
69015: LIST
69016: PUSH
69017: LD_INT 0
69019: PUSH
69020: LD_INT 1
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: PUSH
69027: LD_INT 1
69029: NEG
69030: PUSH
69031: LD_INT 0
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 1
69040: NEG
69041: PUSH
69042: LD_INT 1
69044: NEG
69045: PUSH
69046: EMPTY
69047: LIST
69048: LIST
69049: PUSH
69050: LD_INT 1
69052: PUSH
69053: LD_INT 1
69055: NEG
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PUSH
69061: LD_INT 1
69063: NEG
69064: PUSH
69065: LD_INT 1
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: LIST
69082: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69083: LD_ADDR_VAR 0 38
69087: PUSH
69088: LD_INT 0
69090: PUSH
69091: LD_INT 0
69093: PUSH
69094: EMPTY
69095: LIST
69096: LIST
69097: PUSH
69098: LD_INT 0
69100: PUSH
69101: LD_INT 1
69103: NEG
69104: PUSH
69105: EMPTY
69106: LIST
69107: LIST
69108: PUSH
69109: LD_INT 1
69111: PUSH
69112: LD_INT 0
69114: PUSH
69115: EMPTY
69116: LIST
69117: LIST
69118: PUSH
69119: LD_INT 1
69121: PUSH
69122: LD_INT 1
69124: PUSH
69125: EMPTY
69126: LIST
69127: LIST
69128: PUSH
69129: LD_INT 0
69131: PUSH
69132: LD_INT 1
69134: PUSH
69135: EMPTY
69136: LIST
69137: LIST
69138: PUSH
69139: LD_INT 1
69141: NEG
69142: PUSH
69143: LD_INT 0
69145: PUSH
69146: EMPTY
69147: LIST
69148: LIST
69149: PUSH
69150: LD_INT 1
69152: NEG
69153: PUSH
69154: LD_INT 1
69156: NEG
69157: PUSH
69158: EMPTY
69159: LIST
69160: LIST
69161: PUSH
69162: LD_INT 2
69164: PUSH
69165: LD_INT 1
69167: PUSH
69168: EMPTY
69169: LIST
69170: LIST
69171: PUSH
69172: LD_INT 2
69174: NEG
69175: PUSH
69176: LD_INT 1
69178: NEG
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PUSH
69184: EMPTY
69185: LIST
69186: LIST
69187: LIST
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: LIST
69194: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69195: LD_ADDR_VAR 0 39
69199: PUSH
69200: LD_INT 0
69202: PUSH
69203: LD_INT 0
69205: PUSH
69206: EMPTY
69207: LIST
69208: LIST
69209: PUSH
69210: LD_INT 0
69212: PUSH
69213: LD_INT 1
69215: NEG
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: PUSH
69221: LD_INT 1
69223: PUSH
69224: LD_INT 0
69226: PUSH
69227: EMPTY
69228: LIST
69229: LIST
69230: PUSH
69231: LD_INT 1
69233: PUSH
69234: LD_INT 1
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PUSH
69241: LD_INT 0
69243: PUSH
69244: LD_INT 1
69246: PUSH
69247: EMPTY
69248: LIST
69249: LIST
69250: PUSH
69251: LD_INT 1
69253: NEG
69254: PUSH
69255: LD_INT 0
69257: PUSH
69258: EMPTY
69259: LIST
69260: LIST
69261: PUSH
69262: LD_INT 1
69264: NEG
69265: PUSH
69266: LD_INT 1
69268: NEG
69269: PUSH
69270: EMPTY
69271: LIST
69272: LIST
69273: PUSH
69274: LD_INT 1
69276: NEG
69277: PUSH
69278: LD_INT 2
69280: NEG
69281: PUSH
69282: EMPTY
69283: LIST
69284: LIST
69285: PUSH
69286: LD_INT 1
69288: PUSH
69289: LD_INT 2
69291: PUSH
69292: EMPTY
69293: LIST
69294: LIST
69295: PUSH
69296: EMPTY
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: LIST
69305: LIST
69306: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69307: LD_ADDR_VAR 0 40
69311: PUSH
69312: LD_INT 0
69314: PUSH
69315: LD_INT 0
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: PUSH
69322: LD_INT 0
69324: PUSH
69325: LD_INT 1
69327: NEG
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: PUSH
69333: LD_INT 1
69335: PUSH
69336: LD_INT 0
69338: PUSH
69339: EMPTY
69340: LIST
69341: LIST
69342: PUSH
69343: LD_INT 1
69345: PUSH
69346: LD_INT 1
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: PUSH
69353: LD_INT 0
69355: PUSH
69356: LD_INT 1
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: PUSH
69363: LD_INT 1
69365: NEG
69366: PUSH
69367: LD_INT 0
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PUSH
69374: LD_INT 1
69376: NEG
69377: PUSH
69378: LD_INT 1
69380: NEG
69381: PUSH
69382: EMPTY
69383: LIST
69384: LIST
69385: PUSH
69386: LD_INT 1
69388: PUSH
69389: LD_INT 1
69391: NEG
69392: PUSH
69393: EMPTY
69394: LIST
69395: LIST
69396: PUSH
69397: LD_INT 1
69399: NEG
69400: PUSH
69401: LD_INT 1
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: PUSH
69408: EMPTY
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: LIST
69415: LIST
69416: LIST
69417: LIST
69418: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69419: LD_ADDR_VAR 0 41
69423: PUSH
69424: LD_INT 0
69426: PUSH
69427: LD_INT 0
69429: PUSH
69430: EMPTY
69431: LIST
69432: LIST
69433: PUSH
69434: LD_INT 0
69436: PUSH
69437: LD_INT 1
69439: NEG
69440: PUSH
69441: EMPTY
69442: LIST
69443: LIST
69444: PUSH
69445: LD_INT 1
69447: PUSH
69448: LD_INT 0
69450: PUSH
69451: EMPTY
69452: LIST
69453: LIST
69454: PUSH
69455: LD_INT 1
69457: PUSH
69458: LD_INT 1
69460: PUSH
69461: EMPTY
69462: LIST
69463: LIST
69464: PUSH
69465: LD_INT 0
69467: PUSH
69468: LD_INT 1
69470: PUSH
69471: EMPTY
69472: LIST
69473: LIST
69474: PUSH
69475: LD_INT 1
69477: NEG
69478: PUSH
69479: LD_INT 0
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: PUSH
69486: LD_INT 1
69488: NEG
69489: PUSH
69490: LD_INT 1
69492: NEG
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: LD_INT 1
69500: NEG
69501: PUSH
69502: LD_INT 2
69504: NEG
69505: PUSH
69506: EMPTY
69507: LIST
69508: LIST
69509: PUSH
69510: LD_INT 1
69512: PUSH
69513: LD_INT 1
69515: NEG
69516: PUSH
69517: EMPTY
69518: LIST
69519: LIST
69520: PUSH
69521: LD_INT 2
69523: PUSH
69524: LD_INT 0
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: PUSH
69531: LD_INT 2
69533: PUSH
69534: LD_INT 1
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: LD_INT 2
69543: PUSH
69544: LD_INT 2
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: PUSH
69551: LD_INT 1
69553: PUSH
69554: LD_INT 2
69556: PUSH
69557: EMPTY
69558: LIST
69559: LIST
69560: PUSH
69561: LD_INT 1
69563: NEG
69564: PUSH
69565: LD_INT 1
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: PUSH
69572: LD_INT 2
69574: NEG
69575: PUSH
69576: LD_INT 0
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: PUSH
69583: LD_INT 2
69585: NEG
69586: PUSH
69587: LD_INT 1
69589: NEG
69590: PUSH
69591: EMPTY
69592: LIST
69593: LIST
69594: PUSH
69595: LD_INT 2
69597: NEG
69598: PUSH
69599: LD_INT 2
69601: NEG
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: PUSH
69607: LD_INT 2
69609: NEG
69610: PUSH
69611: LD_INT 3
69613: NEG
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: PUSH
69619: LD_INT 2
69621: PUSH
69622: LD_INT 1
69624: NEG
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: LD_INT 3
69632: PUSH
69633: LD_INT 0
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: PUSH
69640: LD_INT 3
69642: PUSH
69643: LD_INT 1
69645: PUSH
69646: EMPTY
69647: LIST
69648: LIST
69649: PUSH
69650: LD_INT 3
69652: PUSH
69653: LD_INT 2
69655: PUSH
69656: EMPTY
69657: LIST
69658: LIST
69659: PUSH
69660: LD_INT 3
69662: PUSH
69663: LD_INT 3
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 2
69672: PUSH
69673: LD_INT 3
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 2
69682: NEG
69683: PUSH
69684: LD_INT 1
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: LD_INT 3
69693: NEG
69694: PUSH
69695: LD_INT 0
69697: PUSH
69698: EMPTY
69699: LIST
69700: LIST
69701: PUSH
69702: LD_INT 3
69704: NEG
69705: PUSH
69706: LD_INT 1
69708: NEG
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: PUSH
69714: LD_INT 3
69716: NEG
69717: PUSH
69718: LD_INT 2
69720: NEG
69721: PUSH
69722: EMPTY
69723: LIST
69724: LIST
69725: PUSH
69726: LD_INT 3
69728: NEG
69729: PUSH
69730: LD_INT 3
69732: NEG
69733: PUSH
69734: EMPTY
69735: LIST
69736: LIST
69737: PUSH
69738: EMPTY
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: LIST
69755: LIST
69756: LIST
69757: LIST
69758: LIST
69759: LIST
69760: LIST
69761: LIST
69762: LIST
69763: LIST
69764: LIST
69765: LIST
69766: LIST
69767: LIST
69768: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69769: LD_ADDR_VAR 0 42
69773: PUSH
69774: LD_INT 0
69776: PUSH
69777: LD_INT 0
69779: PUSH
69780: EMPTY
69781: LIST
69782: LIST
69783: PUSH
69784: LD_INT 0
69786: PUSH
69787: LD_INT 1
69789: NEG
69790: PUSH
69791: EMPTY
69792: LIST
69793: LIST
69794: PUSH
69795: LD_INT 1
69797: PUSH
69798: LD_INT 0
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: PUSH
69805: LD_INT 1
69807: PUSH
69808: LD_INT 1
69810: PUSH
69811: EMPTY
69812: LIST
69813: LIST
69814: PUSH
69815: LD_INT 0
69817: PUSH
69818: LD_INT 1
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: PUSH
69825: LD_INT 1
69827: NEG
69828: PUSH
69829: LD_INT 0
69831: PUSH
69832: EMPTY
69833: LIST
69834: LIST
69835: PUSH
69836: LD_INT 1
69838: NEG
69839: PUSH
69840: LD_INT 1
69842: NEG
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 1
69850: NEG
69851: PUSH
69852: LD_INT 2
69854: NEG
69855: PUSH
69856: EMPTY
69857: LIST
69858: LIST
69859: PUSH
69860: LD_INT 0
69862: PUSH
69863: LD_INT 2
69865: NEG
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: LD_INT 1
69873: PUSH
69874: LD_INT 1
69876: NEG
69877: PUSH
69878: EMPTY
69879: LIST
69880: LIST
69881: PUSH
69882: LD_INT 2
69884: PUSH
69885: LD_INT 1
69887: PUSH
69888: EMPTY
69889: LIST
69890: LIST
69891: PUSH
69892: LD_INT 2
69894: PUSH
69895: LD_INT 2
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: PUSH
69902: LD_INT 1
69904: PUSH
69905: LD_INT 2
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: PUSH
69912: LD_INT 0
69914: PUSH
69915: LD_INT 2
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PUSH
69922: LD_INT 1
69924: NEG
69925: PUSH
69926: LD_INT 1
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 2
69935: NEG
69936: PUSH
69937: LD_INT 1
69939: NEG
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 2
69947: NEG
69948: PUSH
69949: LD_INT 2
69951: NEG
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: LD_INT 2
69959: NEG
69960: PUSH
69961: LD_INT 3
69963: NEG
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: PUSH
69969: LD_INT 1
69971: NEG
69972: PUSH
69973: LD_INT 3
69975: NEG
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: LD_INT 0
69983: PUSH
69984: LD_INT 3
69986: NEG
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: PUSH
69992: LD_INT 1
69994: PUSH
69995: LD_INT 2
69997: NEG
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: LD_INT 3
70005: PUSH
70006: LD_INT 2
70008: PUSH
70009: EMPTY
70010: LIST
70011: LIST
70012: PUSH
70013: LD_INT 3
70015: PUSH
70016: LD_INT 3
70018: PUSH
70019: EMPTY
70020: LIST
70021: LIST
70022: PUSH
70023: LD_INT 2
70025: PUSH
70026: LD_INT 3
70028: PUSH
70029: EMPTY
70030: LIST
70031: LIST
70032: PUSH
70033: LD_INT 1
70035: PUSH
70036: LD_INT 3
70038: PUSH
70039: EMPTY
70040: LIST
70041: LIST
70042: PUSH
70043: LD_INT 0
70045: PUSH
70046: LD_INT 3
70048: PUSH
70049: EMPTY
70050: LIST
70051: LIST
70052: PUSH
70053: LD_INT 1
70055: NEG
70056: PUSH
70057: LD_INT 2
70059: PUSH
70060: EMPTY
70061: LIST
70062: LIST
70063: PUSH
70064: LD_INT 3
70066: NEG
70067: PUSH
70068: LD_INT 2
70070: NEG
70071: PUSH
70072: EMPTY
70073: LIST
70074: LIST
70075: PUSH
70076: LD_INT 3
70078: NEG
70079: PUSH
70080: LD_INT 3
70082: NEG
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PUSH
70088: EMPTY
70089: LIST
70090: LIST
70091: LIST
70092: LIST
70093: LIST
70094: LIST
70095: LIST
70096: LIST
70097: LIST
70098: LIST
70099: LIST
70100: LIST
70101: LIST
70102: LIST
70103: LIST
70104: LIST
70105: LIST
70106: LIST
70107: LIST
70108: LIST
70109: LIST
70110: LIST
70111: LIST
70112: LIST
70113: LIST
70114: LIST
70115: LIST
70116: LIST
70117: LIST
70118: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70119: LD_ADDR_VAR 0 43
70123: PUSH
70124: LD_INT 0
70126: PUSH
70127: LD_INT 0
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: PUSH
70134: LD_INT 0
70136: PUSH
70137: LD_INT 1
70139: NEG
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: PUSH
70145: LD_INT 1
70147: PUSH
70148: LD_INT 0
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: PUSH
70155: LD_INT 1
70157: PUSH
70158: LD_INT 1
70160: PUSH
70161: EMPTY
70162: LIST
70163: LIST
70164: PUSH
70165: LD_INT 0
70167: PUSH
70168: LD_INT 1
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: PUSH
70175: LD_INT 1
70177: NEG
70178: PUSH
70179: LD_INT 0
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: LD_INT 1
70188: NEG
70189: PUSH
70190: LD_INT 1
70192: NEG
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: LD_INT 1
70200: NEG
70201: PUSH
70202: LD_INT 2
70204: NEG
70205: PUSH
70206: EMPTY
70207: LIST
70208: LIST
70209: PUSH
70210: LD_INT 0
70212: PUSH
70213: LD_INT 2
70215: NEG
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 1
70223: PUSH
70224: LD_INT 1
70226: NEG
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 2
70234: PUSH
70235: LD_INT 0
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: LD_INT 2
70244: PUSH
70245: LD_INT 1
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 1
70254: PUSH
70255: LD_INT 2
70257: PUSH
70258: EMPTY
70259: LIST
70260: LIST
70261: PUSH
70262: LD_INT 0
70264: PUSH
70265: LD_INT 2
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: PUSH
70272: LD_INT 1
70274: NEG
70275: PUSH
70276: LD_INT 1
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: PUSH
70283: LD_INT 2
70285: NEG
70286: PUSH
70287: LD_INT 0
70289: PUSH
70290: EMPTY
70291: LIST
70292: LIST
70293: PUSH
70294: LD_INT 2
70296: NEG
70297: PUSH
70298: LD_INT 1
70300: NEG
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: PUSH
70306: LD_INT 1
70308: NEG
70309: PUSH
70310: LD_INT 3
70312: NEG
70313: PUSH
70314: EMPTY
70315: LIST
70316: LIST
70317: PUSH
70318: LD_INT 0
70320: PUSH
70321: LD_INT 3
70323: NEG
70324: PUSH
70325: EMPTY
70326: LIST
70327: LIST
70328: PUSH
70329: LD_INT 1
70331: PUSH
70332: LD_INT 2
70334: NEG
70335: PUSH
70336: EMPTY
70337: LIST
70338: LIST
70339: PUSH
70340: LD_INT 2
70342: PUSH
70343: LD_INT 1
70345: NEG
70346: PUSH
70347: EMPTY
70348: LIST
70349: LIST
70350: PUSH
70351: LD_INT 3
70353: PUSH
70354: LD_INT 0
70356: PUSH
70357: EMPTY
70358: LIST
70359: LIST
70360: PUSH
70361: LD_INT 3
70363: PUSH
70364: LD_INT 1
70366: PUSH
70367: EMPTY
70368: LIST
70369: LIST
70370: PUSH
70371: LD_INT 1
70373: PUSH
70374: LD_INT 3
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: LD_INT 0
70383: PUSH
70384: LD_INT 3
70386: PUSH
70387: EMPTY
70388: LIST
70389: LIST
70390: PUSH
70391: LD_INT 1
70393: NEG
70394: PUSH
70395: LD_INT 2
70397: PUSH
70398: EMPTY
70399: LIST
70400: LIST
70401: PUSH
70402: LD_INT 2
70404: NEG
70405: PUSH
70406: LD_INT 1
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: PUSH
70413: LD_INT 3
70415: NEG
70416: PUSH
70417: LD_INT 0
70419: PUSH
70420: EMPTY
70421: LIST
70422: LIST
70423: PUSH
70424: LD_INT 3
70426: NEG
70427: PUSH
70428: LD_INT 1
70430: NEG
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: LIST
70440: LIST
70441: LIST
70442: LIST
70443: LIST
70444: LIST
70445: LIST
70446: LIST
70447: LIST
70448: LIST
70449: LIST
70450: LIST
70451: LIST
70452: LIST
70453: LIST
70454: LIST
70455: LIST
70456: LIST
70457: LIST
70458: LIST
70459: LIST
70460: LIST
70461: LIST
70462: LIST
70463: LIST
70464: LIST
70465: LIST
70466: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70467: LD_ADDR_VAR 0 44
70471: PUSH
70472: LD_INT 0
70474: PUSH
70475: LD_INT 0
70477: PUSH
70478: EMPTY
70479: LIST
70480: LIST
70481: PUSH
70482: LD_INT 0
70484: PUSH
70485: LD_INT 1
70487: NEG
70488: PUSH
70489: EMPTY
70490: LIST
70491: LIST
70492: PUSH
70493: LD_INT 1
70495: PUSH
70496: LD_INT 0
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 1
70505: PUSH
70506: LD_INT 1
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 0
70515: PUSH
70516: LD_INT 1
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: LD_INT 1
70525: NEG
70526: PUSH
70527: LD_INT 0
70529: PUSH
70530: EMPTY
70531: LIST
70532: LIST
70533: PUSH
70534: LD_INT 1
70536: NEG
70537: PUSH
70538: LD_INT 1
70540: NEG
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: PUSH
70546: LD_INT 1
70548: NEG
70549: PUSH
70550: LD_INT 2
70552: NEG
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PUSH
70558: LD_INT 1
70560: PUSH
70561: LD_INT 1
70563: NEG
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 2
70571: PUSH
70572: LD_INT 0
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 2
70581: PUSH
70582: LD_INT 1
70584: PUSH
70585: EMPTY
70586: LIST
70587: LIST
70588: PUSH
70589: LD_INT 2
70591: PUSH
70592: LD_INT 2
70594: PUSH
70595: EMPTY
70596: LIST
70597: LIST
70598: PUSH
70599: LD_INT 1
70601: PUSH
70602: LD_INT 2
70604: PUSH
70605: EMPTY
70606: LIST
70607: LIST
70608: PUSH
70609: LD_INT 1
70611: NEG
70612: PUSH
70613: LD_INT 1
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: PUSH
70620: LD_INT 2
70622: NEG
70623: PUSH
70624: LD_INT 0
70626: PUSH
70627: EMPTY
70628: LIST
70629: LIST
70630: PUSH
70631: LD_INT 2
70633: NEG
70634: PUSH
70635: LD_INT 1
70637: NEG
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 2
70645: NEG
70646: PUSH
70647: LD_INT 2
70649: NEG
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: LD_INT 2
70657: NEG
70658: PUSH
70659: LD_INT 3
70661: NEG
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: PUSH
70667: LD_INT 2
70669: PUSH
70670: LD_INT 1
70672: NEG
70673: PUSH
70674: EMPTY
70675: LIST
70676: LIST
70677: PUSH
70678: LD_INT 3
70680: PUSH
70681: LD_INT 0
70683: PUSH
70684: EMPTY
70685: LIST
70686: LIST
70687: PUSH
70688: LD_INT 3
70690: PUSH
70691: LD_INT 1
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: PUSH
70698: LD_INT 3
70700: PUSH
70701: LD_INT 2
70703: PUSH
70704: EMPTY
70705: LIST
70706: LIST
70707: PUSH
70708: LD_INT 3
70710: PUSH
70711: LD_INT 3
70713: PUSH
70714: EMPTY
70715: LIST
70716: LIST
70717: PUSH
70718: LD_INT 2
70720: PUSH
70721: LD_INT 3
70723: PUSH
70724: EMPTY
70725: LIST
70726: LIST
70727: PUSH
70728: LD_INT 2
70730: NEG
70731: PUSH
70732: LD_INT 1
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: LD_INT 3
70741: NEG
70742: PUSH
70743: LD_INT 0
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 3
70752: NEG
70753: PUSH
70754: LD_INT 1
70756: NEG
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: PUSH
70762: LD_INT 3
70764: NEG
70765: PUSH
70766: LD_INT 2
70768: NEG
70769: PUSH
70770: EMPTY
70771: LIST
70772: LIST
70773: PUSH
70774: LD_INT 3
70776: NEG
70777: PUSH
70778: LD_INT 3
70780: NEG
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70817: LD_ADDR_VAR 0 45
70821: PUSH
70822: LD_INT 0
70824: PUSH
70825: LD_INT 0
70827: PUSH
70828: EMPTY
70829: LIST
70830: LIST
70831: PUSH
70832: LD_INT 0
70834: PUSH
70835: LD_INT 1
70837: NEG
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PUSH
70843: LD_INT 1
70845: PUSH
70846: LD_INT 0
70848: PUSH
70849: EMPTY
70850: LIST
70851: LIST
70852: PUSH
70853: LD_INT 1
70855: PUSH
70856: LD_INT 1
70858: PUSH
70859: EMPTY
70860: LIST
70861: LIST
70862: PUSH
70863: LD_INT 0
70865: PUSH
70866: LD_INT 1
70868: PUSH
70869: EMPTY
70870: LIST
70871: LIST
70872: PUSH
70873: LD_INT 1
70875: NEG
70876: PUSH
70877: LD_INT 0
70879: PUSH
70880: EMPTY
70881: LIST
70882: LIST
70883: PUSH
70884: LD_INT 1
70886: NEG
70887: PUSH
70888: LD_INT 1
70890: NEG
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 1
70898: NEG
70899: PUSH
70900: LD_INT 2
70902: NEG
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: PUSH
70908: LD_INT 0
70910: PUSH
70911: LD_INT 2
70913: NEG
70914: PUSH
70915: EMPTY
70916: LIST
70917: LIST
70918: PUSH
70919: LD_INT 1
70921: PUSH
70922: LD_INT 1
70924: NEG
70925: PUSH
70926: EMPTY
70927: LIST
70928: LIST
70929: PUSH
70930: LD_INT 2
70932: PUSH
70933: LD_INT 1
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PUSH
70940: LD_INT 2
70942: PUSH
70943: LD_INT 2
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 1
70952: PUSH
70953: LD_INT 2
70955: PUSH
70956: EMPTY
70957: LIST
70958: LIST
70959: PUSH
70960: LD_INT 0
70962: PUSH
70963: LD_INT 2
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 1
70972: NEG
70973: PUSH
70974: LD_INT 1
70976: PUSH
70977: EMPTY
70978: LIST
70979: LIST
70980: PUSH
70981: LD_INT 2
70983: NEG
70984: PUSH
70985: LD_INT 1
70987: NEG
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 2
70995: NEG
70996: PUSH
70997: LD_INT 2
70999: NEG
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: LD_INT 2
71007: NEG
71008: PUSH
71009: LD_INT 3
71011: NEG
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 1
71019: NEG
71020: PUSH
71021: LD_INT 3
71023: NEG
71024: PUSH
71025: EMPTY
71026: LIST
71027: LIST
71028: PUSH
71029: LD_INT 0
71031: PUSH
71032: LD_INT 3
71034: NEG
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 1
71042: PUSH
71043: LD_INT 2
71045: NEG
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 3
71053: PUSH
71054: LD_INT 2
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: LD_INT 3
71063: PUSH
71064: LD_INT 3
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PUSH
71071: LD_INT 2
71073: PUSH
71074: LD_INT 3
71076: PUSH
71077: EMPTY
71078: LIST
71079: LIST
71080: PUSH
71081: LD_INT 1
71083: PUSH
71084: LD_INT 3
71086: PUSH
71087: EMPTY
71088: LIST
71089: LIST
71090: PUSH
71091: LD_INT 0
71093: PUSH
71094: LD_INT 3
71096: PUSH
71097: EMPTY
71098: LIST
71099: LIST
71100: PUSH
71101: LD_INT 1
71103: NEG
71104: PUSH
71105: LD_INT 2
71107: PUSH
71108: EMPTY
71109: LIST
71110: LIST
71111: PUSH
71112: LD_INT 3
71114: NEG
71115: PUSH
71116: LD_INT 2
71118: NEG
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: PUSH
71124: LD_INT 3
71126: NEG
71127: PUSH
71128: LD_INT 3
71130: NEG
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: LIST
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: LIST
71151: LIST
71152: LIST
71153: LIST
71154: LIST
71155: LIST
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: LIST
71161: LIST
71162: LIST
71163: LIST
71164: LIST
71165: LIST
71166: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71167: LD_ADDR_VAR 0 46
71171: PUSH
71172: LD_INT 0
71174: PUSH
71175: LD_INT 0
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 0
71184: PUSH
71185: LD_INT 1
71187: NEG
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: PUSH
71193: LD_INT 1
71195: PUSH
71196: LD_INT 0
71198: PUSH
71199: EMPTY
71200: LIST
71201: LIST
71202: PUSH
71203: LD_INT 1
71205: PUSH
71206: LD_INT 1
71208: PUSH
71209: EMPTY
71210: LIST
71211: LIST
71212: PUSH
71213: LD_INT 0
71215: PUSH
71216: LD_INT 1
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: PUSH
71223: LD_INT 1
71225: NEG
71226: PUSH
71227: LD_INT 0
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 1
71236: NEG
71237: PUSH
71238: LD_INT 1
71240: NEG
71241: PUSH
71242: EMPTY
71243: LIST
71244: LIST
71245: PUSH
71246: LD_INT 1
71248: NEG
71249: PUSH
71250: LD_INT 2
71252: NEG
71253: PUSH
71254: EMPTY
71255: LIST
71256: LIST
71257: PUSH
71258: LD_INT 0
71260: PUSH
71261: LD_INT 2
71263: NEG
71264: PUSH
71265: EMPTY
71266: LIST
71267: LIST
71268: PUSH
71269: LD_INT 1
71271: PUSH
71272: LD_INT 1
71274: NEG
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: LD_INT 2
71282: PUSH
71283: LD_INT 0
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 2
71292: PUSH
71293: LD_INT 1
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 1
71302: PUSH
71303: LD_INT 2
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: LD_INT 0
71312: PUSH
71313: LD_INT 2
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: PUSH
71320: LD_INT 1
71322: NEG
71323: PUSH
71324: LD_INT 1
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 2
71333: NEG
71334: PUSH
71335: LD_INT 0
71337: PUSH
71338: EMPTY
71339: LIST
71340: LIST
71341: PUSH
71342: LD_INT 2
71344: NEG
71345: PUSH
71346: LD_INT 1
71348: NEG
71349: PUSH
71350: EMPTY
71351: LIST
71352: LIST
71353: PUSH
71354: LD_INT 1
71356: NEG
71357: PUSH
71358: LD_INT 3
71360: NEG
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: PUSH
71366: LD_INT 0
71368: PUSH
71369: LD_INT 3
71371: NEG
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: LD_INT 1
71379: PUSH
71380: LD_INT 2
71382: NEG
71383: PUSH
71384: EMPTY
71385: LIST
71386: LIST
71387: PUSH
71388: LD_INT 2
71390: PUSH
71391: LD_INT 1
71393: NEG
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: PUSH
71399: LD_INT 3
71401: PUSH
71402: LD_INT 0
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: PUSH
71409: LD_INT 3
71411: PUSH
71412: LD_INT 1
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: LD_INT 1
71421: PUSH
71422: LD_INT 3
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PUSH
71429: LD_INT 0
71431: PUSH
71432: LD_INT 3
71434: PUSH
71435: EMPTY
71436: LIST
71437: LIST
71438: PUSH
71439: LD_INT 1
71441: NEG
71442: PUSH
71443: LD_INT 2
71445: PUSH
71446: EMPTY
71447: LIST
71448: LIST
71449: PUSH
71450: LD_INT 2
71452: NEG
71453: PUSH
71454: LD_INT 1
71456: PUSH
71457: EMPTY
71458: LIST
71459: LIST
71460: PUSH
71461: LD_INT 3
71463: NEG
71464: PUSH
71465: LD_INT 0
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: PUSH
71472: LD_INT 3
71474: NEG
71475: PUSH
71476: LD_INT 1
71478: NEG
71479: PUSH
71480: EMPTY
71481: LIST
71482: LIST
71483: PUSH
71484: EMPTY
71485: LIST
71486: LIST
71487: LIST
71488: LIST
71489: LIST
71490: LIST
71491: LIST
71492: LIST
71493: LIST
71494: LIST
71495: LIST
71496: LIST
71497: LIST
71498: LIST
71499: LIST
71500: LIST
71501: LIST
71502: LIST
71503: LIST
71504: LIST
71505: LIST
71506: LIST
71507: LIST
71508: LIST
71509: LIST
71510: LIST
71511: LIST
71512: LIST
71513: LIST
71514: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71515: LD_ADDR_VAR 0 47
71519: PUSH
71520: LD_INT 0
71522: PUSH
71523: LD_INT 0
71525: PUSH
71526: EMPTY
71527: LIST
71528: LIST
71529: PUSH
71530: LD_INT 0
71532: PUSH
71533: LD_INT 1
71535: NEG
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 1
71543: PUSH
71544: LD_INT 0
71546: PUSH
71547: EMPTY
71548: LIST
71549: LIST
71550: PUSH
71551: LD_INT 1
71553: PUSH
71554: LD_INT 1
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 0
71563: PUSH
71564: LD_INT 1
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PUSH
71571: LD_INT 1
71573: NEG
71574: PUSH
71575: LD_INT 0
71577: PUSH
71578: EMPTY
71579: LIST
71580: LIST
71581: PUSH
71582: LD_INT 1
71584: NEG
71585: PUSH
71586: LD_INT 1
71588: NEG
71589: PUSH
71590: EMPTY
71591: LIST
71592: LIST
71593: PUSH
71594: LD_INT 1
71596: NEG
71597: PUSH
71598: LD_INT 2
71600: NEG
71601: PUSH
71602: EMPTY
71603: LIST
71604: LIST
71605: PUSH
71606: LD_INT 0
71608: PUSH
71609: LD_INT 2
71611: NEG
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: PUSH
71617: LD_INT 1
71619: PUSH
71620: LD_INT 1
71622: NEG
71623: PUSH
71624: EMPTY
71625: LIST
71626: LIST
71627: PUSH
71628: LD_INT 2
71630: NEG
71631: PUSH
71632: LD_INT 1
71634: NEG
71635: PUSH
71636: EMPTY
71637: LIST
71638: LIST
71639: PUSH
71640: LD_INT 2
71642: NEG
71643: PUSH
71644: LD_INT 2
71646: NEG
71647: PUSH
71648: EMPTY
71649: LIST
71650: LIST
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: LIST
71656: LIST
71657: LIST
71658: LIST
71659: LIST
71660: LIST
71661: LIST
71662: LIST
71663: LIST
71664: LIST
71665: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71666: LD_ADDR_VAR 0 48
71670: PUSH
71671: LD_INT 0
71673: PUSH
71674: LD_INT 0
71676: PUSH
71677: EMPTY
71678: LIST
71679: LIST
71680: PUSH
71681: LD_INT 0
71683: PUSH
71684: LD_INT 1
71686: NEG
71687: PUSH
71688: EMPTY
71689: LIST
71690: LIST
71691: PUSH
71692: LD_INT 1
71694: PUSH
71695: LD_INT 0
71697: PUSH
71698: EMPTY
71699: LIST
71700: LIST
71701: PUSH
71702: LD_INT 1
71704: PUSH
71705: LD_INT 1
71707: PUSH
71708: EMPTY
71709: LIST
71710: LIST
71711: PUSH
71712: LD_INT 0
71714: PUSH
71715: LD_INT 1
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 1
71724: NEG
71725: PUSH
71726: LD_INT 0
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: LD_INT 1
71735: NEG
71736: PUSH
71737: LD_INT 1
71739: NEG
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: LD_INT 1
71747: NEG
71748: PUSH
71749: LD_INT 2
71751: NEG
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 0
71759: PUSH
71760: LD_INT 2
71762: NEG
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: PUSH
71768: LD_INT 1
71770: PUSH
71771: LD_INT 1
71773: NEG
71774: PUSH
71775: EMPTY
71776: LIST
71777: LIST
71778: PUSH
71779: LD_INT 2
71781: PUSH
71782: LD_INT 0
71784: PUSH
71785: EMPTY
71786: LIST
71787: LIST
71788: PUSH
71789: LD_INT 2
71791: PUSH
71792: LD_INT 1
71794: PUSH
71795: EMPTY
71796: LIST
71797: LIST
71798: PUSH
71799: EMPTY
71800: LIST
71801: LIST
71802: LIST
71803: LIST
71804: LIST
71805: LIST
71806: LIST
71807: LIST
71808: LIST
71809: LIST
71810: LIST
71811: LIST
71812: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
71813: LD_ADDR_VAR 0 49
71817: PUSH
71818: LD_INT 0
71820: PUSH
71821: LD_INT 0
71823: PUSH
71824: EMPTY
71825: LIST
71826: LIST
71827: PUSH
71828: LD_INT 0
71830: PUSH
71831: LD_INT 1
71833: NEG
71834: PUSH
71835: EMPTY
71836: LIST
71837: LIST
71838: PUSH
71839: LD_INT 1
71841: PUSH
71842: LD_INT 0
71844: PUSH
71845: EMPTY
71846: LIST
71847: LIST
71848: PUSH
71849: LD_INT 1
71851: PUSH
71852: LD_INT 1
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: PUSH
71859: LD_INT 0
71861: PUSH
71862: LD_INT 1
71864: PUSH
71865: EMPTY
71866: LIST
71867: LIST
71868: PUSH
71869: LD_INT 1
71871: NEG
71872: PUSH
71873: LD_INT 0
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: PUSH
71880: LD_INT 1
71882: NEG
71883: PUSH
71884: LD_INT 1
71886: NEG
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 1
71894: PUSH
71895: LD_INT 1
71897: NEG
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 2
71905: PUSH
71906: LD_INT 0
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: LD_INT 2
71915: PUSH
71916: LD_INT 1
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 2
71925: PUSH
71926: LD_INT 2
71928: PUSH
71929: EMPTY
71930: LIST
71931: LIST
71932: PUSH
71933: LD_INT 1
71935: PUSH
71936: LD_INT 2
71938: PUSH
71939: EMPTY
71940: LIST
71941: LIST
71942: PUSH
71943: EMPTY
71944: LIST
71945: LIST
71946: LIST
71947: LIST
71948: LIST
71949: LIST
71950: LIST
71951: LIST
71952: LIST
71953: LIST
71954: LIST
71955: LIST
71956: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
71957: LD_ADDR_VAR 0 50
71961: PUSH
71962: LD_INT 0
71964: PUSH
71965: LD_INT 0
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: PUSH
71972: LD_INT 0
71974: PUSH
71975: LD_INT 1
71977: NEG
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: PUSH
71983: LD_INT 1
71985: PUSH
71986: LD_INT 0
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 1
71995: PUSH
71996: LD_INT 1
71998: PUSH
71999: EMPTY
72000: LIST
72001: LIST
72002: PUSH
72003: LD_INT 0
72005: PUSH
72006: LD_INT 1
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: PUSH
72013: LD_INT 1
72015: NEG
72016: PUSH
72017: LD_INT 0
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PUSH
72024: LD_INT 1
72026: NEG
72027: PUSH
72028: LD_INT 1
72030: NEG
72031: PUSH
72032: EMPTY
72033: LIST
72034: LIST
72035: PUSH
72036: LD_INT 2
72038: PUSH
72039: LD_INT 1
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PUSH
72046: LD_INT 2
72048: PUSH
72049: LD_INT 2
72051: PUSH
72052: EMPTY
72053: LIST
72054: LIST
72055: PUSH
72056: LD_INT 1
72058: PUSH
72059: LD_INT 2
72061: PUSH
72062: EMPTY
72063: LIST
72064: LIST
72065: PUSH
72066: LD_INT 0
72068: PUSH
72069: LD_INT 2
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 1
72078: NEG
72079: PUSH
72080: LD_INT 1
72082: PUSH
72083: EMPTY
72084: LIST
72085: LIST
72086: PUSH
72087: EMPTY
72088: LIST
72089: LIST
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: LIST
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72101: LD_ADDR_VAR 0 51
72105: PUSH
72106: LD_INT 0
72108: PUSH
72109: LD_INT 0
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PUSH
72116: LD_INT 0
72118: PUSH
72119: LD_INT 1
72121: NEG
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: PUSH
72127: LD_INT 1
72129: PUSH
72130: LD_INT 0
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: LD_INT 1
72139: PUSH
72140: LD_INT 1
72142: PUSH
72143: EMPTY
72144: LIST
72145: LIST
72146: PUSH
72147: LD_INT 0
72149: PUSH
72150: LD_INT 1
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: PUSH
72157: LD_INT 1
72159: NEG
72160: PUSH
72161: LD_INT 0
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: PUSH
72168: LD_INT 1
72170: NEG
72171: PUSH
72172: LD_INT 1
72174: NEG
72175: PUSH
72176: EMPTY
72177: LIST
72178: LIST
72179: PUSH
72180: LD_INT 1
72182: PUSH
72183: LD_INT 2
72185: PUSH
72186: EMPTY
72187: LIST
72188: LIST
72189: PUSH
72190: LD_INT 0
72192: PUSH
72193: LD_INT 2
72195: PUSH
72196: EMPTY
72197: LIST
72198: LIST
72199: PUSH
72200: LD_INT 1
72202: NEG
72203: PUSH
72204: LD_INT 1
72206: PUSH
72207: EMPTY
72208: LIST
72209: LIST
72210: PUSH
72211: LD_INT 2
72213: NEG
72214: PUSH
72215: LD_INT 0
72217: PUSH
72218: EMPTY
72219: LIST
72220: LIST
72221: PUSH
72222: LD_INT 2
72224: NEG
72225: PUSH
72226: LD_INT 1
72228: NEG
72229: PUSH
72230: EMPTY
72231: LIST
72232: LIST
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: LIST
72238: LIST
72239: LIST
72240: LIST
72241: LIST
72242: LIST
72243: LIST
72244: LIST
72245: LIST
72246: LIST
72247: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72248: LD_ADDR_VAR 0 52
72252: PUSH
72253: LD_INT 0
72255: PUSH
72256: LD_INT 0
72258: PUSH
72259: EMPTY
72260: LIST
72261: LIST
72262: PUSH
72263: LD_INT 0
72265: PUSH
72266: LD_INT 1
72268: NEG
72269: PUSH
72270: EMPTY
72271: LIST
72272: LIST
72273: PUSH
72274: LD_INT 1
72276: PUSH
72277: LD_INT 0
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 1
72286: PUSH
72287: LD_INT 1
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PUSH
72294: LD_INT 0
72296: PUSH
72297: LD_INT 1
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PUSH
72304: LD_INT 1
72306: NEG
72307: PUSH
72308: LD_INT 0
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: PUSH
72315: LD_INT 1
72317: NEG
72318: PUSH
72319: LD_INT 1
72321: NEG
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: LD_INT 1
72329: NEG
72330: PUSH
72331: LD_INT 2
72333: NEG
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: LD_INT 1
72341: NEG
72342: PUSH
72343: LD_INT 1
72345: PUSH
72346: EMPTY
72347: LIST
72348: LIST
72349: PUSH
72350: LD_INT 2
72352: NEG
72353: PUSH
72354: LD_INT 0
72356: PUSH
72357: EMPTY
72358: LIST
72359: LIST
72360: PUSH
72361: LD_INT 2
72363: NEG
72364: PUSH
72365: LD_INT 1
72367: NEG
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: PUSH
72373: LD_INT 2
72375: NEG
72376: PUSH
72377: LD_INT 2
72379: NEG
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: LIST
72389: LIST
72390: LIST
72391: LIST
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72399: LD_ADDR_VAR 0 53
72403: PUSH
72404: LD_INT 0
72406: PUSH
72407: LD_INT 0
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: PUSH
72414: LD_INT 0
72416: PUSH
72417: LD_INT 1
72419: NEG
72420: PUSH
72421: EMPTY
72422: LIST
72423: LIST
72424: PUSH
72425: LD_INT 1
72427: PUSH
72428: LD_INT 0
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: PUSH
72435: LD_INT 1
72437: PUSH
72438: LD_INT 1
72440: PUSH
72441: EMPTY
72442: LIST
72443: LIST
72444: PUSH
72445: LD_INT 0
72447: PUSH
72448: LD_INT 1
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: LD_INT 1
72457: NEG
72458: PUSH
72459: LD_INT 0
72461: PUSH
72462: EMPTY
72463: LIST
72464: LIST
72465: PUSH
72466: LD_INT 1
72468: NEG
72469: PUSH
72470: LD_INT 1
72472: NEG
72473: PUSH
72474: EMPTY
72475: LIST
72476: LIST
72477: PUSH
72478: LD_INT 1
72480: NEG
72481: PUSH
72482: LD_INT 2
72484: NEG
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: PUSH
72490: LD_INT 0
72492: PUSH
72493: LD_INT 2
72495: NEG
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 1
72503: PUSH
72504: LD_INT 1
72506: NEG
72507: PUSH
72508: EMPTY
72509: LIST
72510: LIST
72511: PUSH
72512: LD_INT 2
72514: PUSH
72515: LD_INT 0
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: PUSH
72522: LD_INT 2
72524: PUSH
72525: LD_INT 1
72527: PUSH
72528: EMPTY
72529: LIST
72530: LIST
72531: PUSH
72532: LD_INT 2
72534: PUSH
72535: LD_INT 2
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: PUSH
72542: LD_INT 1
72544: PUSH
72545: LD_INT 2
72547: PUSH
72548: EMPTY
72549: LIST
72550: LIST
72551: PUSH
72552: LD_INT 0
72554: PUSH
72555: LD_INT 2
72557: PUSH
72558: EMPTY
72559: LIST
72560: LIST
72561: PUSH
72562: LD_INT 1
72564: NEG
72565: PUSH
72566: LD_INT 1
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: PUSH
72573: LD_INT 2
72575: NEG
72576: PUSH
72577: LD_INT 0
72579: PUSH
72580: EMPTY
72581: LIST
72582: LIST
72583: PUSH
72584: LD_INT 2
72586: NEG
72587: PUSH
72588: LD_INT 1
72590: NEG
72591: PUSH
72592: EMPTY
72593: LIST
72594: LIST
72595: PUSH
72596: LD_INT 2
72598: NEG
72599: PUSH
72600: LD_INT 2
72602: NEG
72603: PUSH
72604: EMPTY
72605: LIST
72606: LIST
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: LIST
72612: LIST
72613: LIST
72614: LIST
72615: LIST
72616: LIST
72617: LIST
72618: LIST
72619: LIST
72620: LIST
72621: LIST
72622: LIST
72623: LIST
72624: LIST
72625: LIST
72626: LIST
72627: LIST
72628: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72629: LD_ADDR_VAR 0 54
72633: PUSH
72634: LD_INT 0
72636: PUSH
72637: LD_INT 0
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 0
72646: PUSH
72647: LD_INT 1
72649: NEG
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PUSH
72655: LD_INT 1
72657: PUSH
72658: LD_INT 0
72660: PUSH
72661: EMPTY
72662: LIST
72663: LIST
72664: PUSH
72665: LD_INT 1
72667: PUSH
72668: LD_INT 1
72670: PUSH
72671: EMPTY
72672: LIST
72673: LIST
72674: PUSH
72675: LD_INT 0
72677: PUSH
72678: LD_INT 1
72680: PUSH
72681: EMPTY
72682: LIST
72683: LIST
72684: PUSH
72685: LD_INT 1
72687: NEG
72688: PUSH
72689: LD_INT 0
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: PUSH
72696: LD_INT 1
72698: NEG
72699: PUSH
72700: LD_INT 1
72702: NEG
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PUSH
72708: LD_INT 1
72710: NEG
72711: PUSH
72712: LD_INT 2
72714: NEG
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PUSH
72720: LD_INT 0
72722: PUSH
72723: LD_INT 2
72725: NEG
72726: PUSH
72727: EMPTY
72728: LIST
72729: LIST
72730: PUSH
72731: LD_INT 1
72733: PUSH
72734: LD_INT 1
72736: NEG
72737: PUSH
72738: EMPTY
72739: LIST
72740: LIST
72741: PUSH
72742: LD_INT 2
72744: PUSH
72745: LD_INT 0
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: PUSH
72752: LD_INT 2
72754: PUSH
72755: LD_INT 1
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PUSH
72762: LD_INT 2
72764: PUSH
72765: LD_INT 2
72767: PUSH
72768: EMPTY
72769: LIST
72770: LIST
72771: PUSH
72772: LD_INT 1
72774: PUSH
72775: LD_INT 2
72777: PUSH
72778: EMPTY
72779: LIST
72780: LIST
72781: PUSH
72782: LD_INT 0
72784: PUSH
72785: LD_INT 2
72787: PUSH
72788: EMPTY
72789: LIST
72790: LIST
72791: PUSH
72792: LD_INT 1
72794: NEG
72795: PUSH
72796: LD_INT 1
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: PUSH
72803: LD_INT 2
72805: NEG
72806: PUSH
72807: LD_INT 0
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: LD_INT 2
72816: NEG
72817: PUSH
72818: LD_INT 1
72820: NEG
72821: PUSH
72822: EMPTY
72823: LIST
72824: LIST
72825: PUSH
72826: LD_INT 2
72828: NEG
72829: PUSH
72830: LD_INT 2
72832: NEG
72833: PUSH
72834: EMPTY
72835: LIST
72836: LIST
72837: PUSH
72838: EMPTY
72839: LIST
72840: LIST
72841: LIST
72842: LIST
72843: LIST
72844: LIST
72845: LIST
72846: LIST
72847: LIST
72848: LIST
72849: LIST
72850: LIST
72851: LIST
72852: LIST
72853: LIST
72854: LIST
72855: LIST
72856: LIST
72857: LIST
72858: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72859: LD_ADDR_VAR 0 55
72863: PUSH
72864: LD_INT 0
72866: PUSH
72867: LD_INT 0
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 0
72876: PUSH
72877: LD_INT 1
72879: NEG
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: PUSH
72885: LD_INT 1
72887: PUSH
72888: LD_INT 0
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: PUSH
72895: LD_INT 1
72897: PUSH
72898: LD_INT 1
72900: PUSH
72901: EMPTY
72902: LIST
72903: LIST
72904: PUSH
72905: LD_INT 0
72907: PUSH
72908: LD_INT 1
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 1
72917: NEG
72918: PUSH
72919: LD_INT 0
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: LD_INT 1
72928: NEG
72929: PUSH
72930: LD_INT 1
72932: NEG
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: PUSH
72938: LD_INT 1
72940: NEG
72941: PUSH
72942: LD_INT 2
72944: NEG
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: PUSH
72950: LD_INT 0
72952: PUSH
72953: LD_INT 2
72955: NEG
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 1
72963: PUSH
72964: LD_INT 1
72966: NEG
72967: PUSH
72968: EMPTY
72969: LIST
72970: LIST
72971: PUSH
72972: LD_INT 2
72974: PUSH
72975: LD_INT 0
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: PUSH
72982: LD_INT 2
72984: PUSH
72985: LD_INT 1
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 2
72994: PUSH
72995: LD_INT 2
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: PUSH
73002: LD_INT 1
73004: PUSH
73005: LD_INT 2
73007: PUSH
73008: EMPTY
73009: LIST
73010: LIST
73011: PUSH
73012: LD_INT 0
73014: PUSH
73015: LD_INT 2
73017: PUSH
73018: EMPTY
73019: LIST
73020: LIST
73021: PUSH
73022: LD_INT 1
73024: NEG
73025: PUSH
73026: LD_INT 1
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: PUSH
73033: LD_INT 2
73035: NEG
73036: PUSH
73037: LD_INT 0
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: PUSH
73044: LD_INT 2
73046: NEG
73047: PUSH
73048: LD_INT 1
73050: NEG
73051: PUSH
73052: EMPTY
73053: LIST
73054: LIST
73055: PUSH
73056: LD_INT 2
73058: NEG
73059: PUSH
73060: LD_INT 2
73062: NEG
73063: PUSH
73064: EMPTY
73065: LIST
73066: LIST
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: LIST
73072: LIST
73073: LIST
73074: LIST
73075: LIST
73076: LIST
73077: LIST
73078: LIST
73079: LIST
73080: LIST
73081: LIST
73082: LIST
73083: LIST
73084: LIST
73085: LIST
73086: LIST
73087: LIST
73088: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73089: LD_ADDR_VAR 0 56
73093: PUSH
73094: LD_INT 0
73096: PUSH
73097: LD_INT 0
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: LD_INT 0
73106: PUSH
73107: LD_INT 1
73109: NEG
73110: PUSH
73111: EMPTY
73112: LIST
73113: LIST
73114: PUSH
73115: LD_INT 1
73117: PUSH
73118: LD_INT 0
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: PUSH
73125: LD_INT 1
73127: PUSH
73128: LD_INT 1
73130: PUSH
73131: EMPTY
73132: LIST
73133: LIST
73134: PUSH
73135: LD_INT 0
73137: PUSH
73138: LD_INT 1
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: PUSH
73145: LD_INT 1
73147: NEG
73148: PUSH
73149: LD_INT 0
73151: PUSH
73152: EMPTY
73153: LIST
73154: LIST
73155: PUSH
73156: LD_INT 1
73158: NEG
73159: PUSH
73160: LD_INT 1
73162: NEG
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 1
73170: NEG
73171: PUSH
73172: LD_INT 2
73174: NEG
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: PUSH
73180: LD_INT 0
73182: PUSH
73183: LD_INT 2
73185: NEG
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: LD_INT 1
73193: PUSH
73194: LD_INT 1
73196: NEG
73197: PUSH
73198: EMPTY
73199: LIST
73200: LIST
73201: PUSH
73202: LD_INT 2
73204: PUSH
73205: LD_INT 0
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 2
73214: PUSH
73215: LD_INT 1
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: PUSH
73222: LD_INT 2
73224: PUSH
73225: LD_INT 2
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 1
73234: PUSH
73235: LD_INT 2
73237: PUSH
73238: EMPTY
73239: LIST
73240: LIST
73241: PUSH
73242: LD_INT 0
73244: PUSH
73245: LD_INT 2
73247: PUSH
73248: EMPTY
73249: LIST
73250: LIST
73251: PUSH
73252: LD_INT 1
73254: NEG
73255: PUSH
73256: LD_INT 1
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: PUSH
73263: LD_INT 2
73265: NEG
73266: PUSH
73267: LD_INT 0
73269: PUSH
73270: EMPTY
73271: LIST
73272: LIST
73273: PUSH
73274: LD_INT 2
73276: NEG
73277: PUSH
73278: LD_INT 1
73280: NEG
73281: PUSH
73282: EMPTY
73283: LIST
73284: LIST
73285: PUSH
73286: LD_INT 2
73288: NEG
73289: PUSH
73290: LD_INT 2
73292: NEG
73293: PUSH
73294: EMPTY
73295: LIST
73296: LIST
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: LIST
73302: LIST
73303: LIST
73304: LIST
73305: LIST
73306: LIST
73307: LIST
73308: LIST
73309: LIST
73310: LIST
73311: LIST
73312: LIST
73313: LIST
73314: LIST
73315: LIST
73316: LIST
73317: LIST
73318: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73319: LD_ADDR_VAR 0 57
73323: PUSH
73324: LD_INT 0
73326: PUSH
73327: LD_INT 0
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 0
73336: PUSH
73337: LD_INT 1
73339: NEG
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: LD_INT 1
73347: PUSH
73348: LD_INT 0
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PUSH
73355: LD_INT 1
73357: PUSH
73358: LD_INT 1
73360: PUSH
73361: EMPTY
73362: LIST
73363: LIST
73364: PUSH
73365: LD_INT 0
73367: PUSH
73368: LD_INT 1
73370: PUSH
73371: EMPTY
73372: LIST
73373: LIST
73374: PUSH
73375: LD_INT 1
73377: NEG
73378: PUSH
73379: LD_INT 0
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: PUSH
73386: LD_INT 1
73388: NEG
73389: PUSH
73390: LD_INT 1
73392: NEG
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 1
73400: NEG
73401: PUSH
73402: LD_INT 2
73404: NEG
73405: PUSH
73406: EMPTY
73407: LIST
73408: LIST
73409: PUSH
73410: LD_INT 0
73412: PUSH
73413: LD_INT 2
73415: NEG
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: PUSH
73421: LD_INT 1
73423: PUSH
73424: LD_INT 1
73426: NEG
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: PUSH
73432: LD_INT 2
73434: PUSH
73435: LD_INT 0
73437: PUSH
73438: EMPTY
73439: LIST
73440: LIST
73441: PUSH
73442: LD_INT 2
73444: PUSH
73445: LD_INT 1
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: LD_INT 2
73454: PUSH
73455: LD_INT 2
73457: PUSH
73458: EMPTY
73459: LIST
73460: LIST
73461: PUSH
73462: LD_INT 1
73464: PUSH
73465: LD_INT 2
73467: PUSH
73468: EMPTY
73469: LIST
73470: LIST
73471: PUSH
73472: LD_INT 0
73474: PUSH
73475: LD_INT 2
73477: PUSH
73478: EMPTY
73479: LIST
73480: LIST
73481: PUSH
73482: LD_INT 1
73484: NEG
73485: PUSH
73486: LD_INT 1
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: PUSH
73493: LD_INT 2
73495: NEG
73496: PUSH
73497: LD_INT 0
73499: PUSH
73500: EMPTY
73501: LIST
73502: LIST
73503: PUSH
73504: LD_INT 2
73506: NEG
73507: PUSH
73508: LD_INT 1
73510: NEG
73511: PUSH
73512: EMPTY
73513: LIST
73514: LIST
73515: PUSH
73516: LD_INT 2
73518: NEG
73519: PUSH
73520: LD_INT 2
73522: NEG
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: LIST
73536: LIST
73537: LIST
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: LIST
73543: LIST
73544: LIST
73545: LIST
73546: LIST
73547: LIST
73548: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73549: LD_ADDR_VAR 0 58
73553: PUSH
73554: LD_INT 0
73556: PUSH
73557: LD_INT 0
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: PUSH
73564: LD_INT 0
73566: PUSH
73567: LD_INT 1
73569: NEG
73570: PUSH
73571: EMPTY
73572: LIST
73573: LIST
73574: PUSH
73575: LD_INT 1
73577: PUSH
73578: LD_INT 0
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: PUSH
73585: LD_INT 1
73587: PUSH
73588: LD_INT 1
73590: PUSH
73591: EMPTY
73592: LIST
73593: LIST
73594: PUSH
73595: LD_INT 0
73597: PUSH
73598: LD_INT 1
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: PUSH
73605: LD_INT 1
73607: NEG
73608: PUSH
73609: LD_INT 0
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 1
73618: NEG
73619: PUSH
73620: LD_INT 1
73622: NEG
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 1
73630: NEG
73631: PUSH
73632: LD_INT 2
73634: NEG
73635: PUSH
73636: EMPTY
73637: LIST
73638: LIST
73639: PUSH
73640: LD_INT 0
73642: PUSH
73643: LD_INT 2
73645: NEG
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: LD_INT 1
73653: PUSH
73654: LD_INT 1
73656: NEG
73657: PUSH
73658: EMPTY
73659: LIST
73660: LIST
73661: PUSH
73662: LD_INT 2
73664: PUSH
73665: LD_INT 0
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PUSH
73672: LD_INT 2
73674: PUSH
73675: LD_INT 1
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 2
73684: PUSH
73685: LD_INT 2
73687: PUSH
73688: EMPTY
73689: LIST
73690: LIST
73691: PUSH
73692: LD_INT 1
73694: PUSH
73695: LD_INT 2
73697: PUSH
73698: EMPTY
73699: LIST
73700: LIST
73701: PUSH
73702: LD_INT 0
73704: PUSH
73705: LD_INT 2
73707: PUSH
73708: EMPTY
73709: LIST
73710: LIST
73711: PUSH
73712: LD_INT 1
73714: NEG
73715: PUSH
73716: LD_INT 1
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 2
73725: NEG
73726: PUSH
73727: LD_INT 0
73729: PUSH
73730: EMPTY
73731: LIST
73732: LIST
73733: PUSH
73734: LD_INT 2
73736: NEG
73737: PUSH
73738: LD_INT 1
73740: NEG
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: PUSH
73746: LD_INT 2
73748: NEG
73749: PUSH
73750: LD_INT 2
73752: NEG
73753: PUSH
73754: EMPTY
73755: LIST
73756: LIST
73757: PUSH
73758: EMPTY
73759: LIST
73760: LIST
73761: LIST
73762: LIST
73763: LIST
73764: LIST
73765: LIST
73766: LIST
73767: LIST
73768: LIST
73769: LIST
73770: LIST
73771: LIST
73772: LIST
73773: LIST
73774: LIST
73775: LIST
73776: LIST
73777: LIST
73778: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73779: LD_ADDR_VAR 0 59
73783: PUSH
73784: LD_INT 0
73786: PUSH
73787: LD_INT 0
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 0
73796: PUSH
73797: LD_INT 1
73799: NEG
73800: PUSH
73801: EMPTY
73802: LIST
73803: LIST
73804: PUSH
73805: LD_INT 1
73807: PUSH
73808: LD_INT 0
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: PUSH
73815: LD_INT 1
73817: PUSH
73818: LD_INT 1
73820: PUSH
73821: EMPTY
73822: LIST
73823: LIST
73824: PUSH
73825: LD_INT 0
73827: PUSH
73828: LD_INT 1
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: LD_INT 1
73837: NEG
73838: PUSH
73839: LD_INT 0
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 1
73848: NEG
73849: PUSH
73850: LD_INT 1
73852: NEG
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: PUSH
73858: EMPTY
73859: LIST
73860: LIST
73861: LIST
73862: LIST
73863: LIST
73864: LIST
73865: LIST
73866: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73867: LD_ADDR_VAR 0 60
73871: PUSH
73872: LD_INT 0
73874: PUSH
73875: LD_INT 0
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 0
73884: PUSH
73885: LD_INT 1
73887: NEG
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: PUSH
73893: LD_INT 1
73895: PUSH
73896: LD_INT 0
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 1
73905: PUSH
73906: LD_INT 1
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: PUSH
73913: LD_INT 0
73915: PUSH
73916: LD_INT 1
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 1
73925: NEG
73926: PUSH
73927: LD_INT 0
73929: PUSH
73930: EMPTY
73931: LIST
73932: LIST
73933: PUSH
73934: LD_INT 1
73936: NEG
73937: PUSH
73938: LD_INT 1
73940: NEG
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: LIST
73950: LIST
73951: LIST
73952: LIST
73953: LIST
73954: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73955: LD_ADDR_VAR 0 61
73959: PUSH
73960: LD_INT 0
73962: PUSH
73963: LD_INT 0
73965: PUSH
73966: EMPTY
73967: LIST
73968: LIST
73969: PUSH
73970: LD_INT 0
73972: PUSH
73973: LD_INT 1
73975: NEG
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: PUSH
73981: LD_INT 1
73983: PUSH
73984: LD_INT 0
73986: PUSH
73987: EMPTY
73988: LIST
73989: LIST
73990: PUSH
73991: LD_INT 1
73993: PUSH
73994: LD_INT 1
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: LD_INT 0
74003: PUSH
74004: LD_INT 1
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: PUSH
74011: LD_INT 1
74013: NEG
74014: PUSH
74015: LD_INT 0
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: PUSH
74022: LD_INT 1
74024: NEG
74025: PUSH
74026: LD_INT 1
74028: NEG
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: EMPTY
74035: LIST
74036: LIST
74037: LIST
74038: LIST
74039: LIST
74040: LIST
74041: LIST
74042: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74043: LD_ADDR_VAR 0 62
74047: PUSH
74048: LD_INT 0
74050: PUSH
74051: LD_INT 0
74053: PUSH
74054: EMPTY
74055: LIST
74056: LIST
74057: PUSH
74058: LD_INT 0
74060: PUSH
74061: LD_INT 1
74063: NEG
74064: PUSH
74065: EMPTY
74066: LIST
74067: LIST
74068: PUSH
74069: LD_INT 1
74071: PUSH
74072: LD_INT 0
74074: PUSH
74075: EMPTY
74076: LIST
74077: LIST
74078: PUSH
74079: LD_INT 1
74081: PUSH
74082: LD_INT 1
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: PUSH
74089: LD_INT 0
74091: PUSH
74092: LD_INT 1
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: PUSH
74099: LD_INT 1
74101: NEG
74102: PUSH
74103: LD_INT 0
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: PUSH
74110: LD_INT 1
74112: NEG
74113: PUSH
74114: LD_INT 1
74116: NEG
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: LIST
74126: LIST
74127: LIST
74128: LIST
74129: LIST
74130: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74131: LD_ADDR_VAR 0 63
74135: PUSH
74136: LD_INT 0
74138: PUSH
74139: LD_INT 0
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: PUSH
74146: LD_INT 0
74148: PUSH
74149: LD_INT 1
74151: NEG
74152: PUSH
74153: EMPTY
74154: LIST
74155: LIST
74156: PUSH
74157: LD_INT 1
74159: PUSH
74160: LD_INT 0
74162: PUSH
74163: EMPTY
74164: LIST
74165: LIST
74166: PUSH
74167: LD_INT 1
74169: PUSH
74170: LD_INT 1
74172: PUSH
74173: EMPTY
74174: LIST
74175: LIST
74176: PUSH
74177: LD_INT 0
74179: PUSH
74180: LD_INT 1
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 1
74189: NEG
74190: PUSH
74191: LD_INT 0
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: PUSH
74198: LD_INT 1
74200: NEG
74201: PUSH
74202: LD_INT 1
74204: NEG
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: EMPTY
74211: LIST
74212: LIST
74213: LIST
74214: LIST
74215: LIST
74216: LIST
74217: LIST
74218: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74219: LD_ADDR_VAR 0 64
74223: PUSH
74224: LD_INT 0
74226: PUSH
74227: LD_INT 0
74229: PUSH
74230: EMPTY
74231: LIST
74232: LIST
74233: PUSH
74234: LD_INT 0
74236: PUSH
74237: LD_INT 1
74239: NEG
74240: PUSH
74241: EMPTY
74242: LIST
74243: LIST
74244: PUSH
74245: LD_INT 1
74247: PUSH
74248: LD_INT 0
74250: PUSH
74251: EMPTY
74252: LIST
74253: LIST
74254: PUSH
74255: LD_INT 1
74257: PUSH
74258: LD_INT 1
74260: PUSH
74261: EMPTY
74262: LIST
74263: LIST
74264: PUSH
74265: LD_INT 0
74267: PUSH
74268: LD_INT 1
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: LD_INT 1
74277: NEG
74278: PUSH
74279: LD_INT 0
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: PUSH
74286: LD_INT 1
74288: NEG
74289: PUSH
74290: LD_INT 1
74292: NEG
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: PUSH
74298: EMPTY
74299: LIST
74300: LIST
74301: LIST
74302: LIST
74303: LIST
74304: LIST
74305: LIST
74306: ST_TO_ADDR
// end ; 1 :
74307: GO 80204
74309: LD_INT 1
74311: DOUBLE
74312: EQUAL
74313: IFTRUE 74317
74315: GO 76940
74317: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74318: LD_ADDR_VAR 0 11
74322: PUSH
74323: LD_INT 1
74325: NEG
74326: PUSH
74327: LD_INT 3
74329: NEG
74330: PUSH
74331: EMPTY
74332: LIST
74333: LIST
74334: PUSH
74335: LD_INT 0
74337: PUSH
74338: LD_INT 3
74340: NEG
74341: PUSH
74342: EMPTY
74343: LIST
74344: LIST
74345: PUSH
74346: LD_INT 1
74348: PUSH
74349: LD_INT 2
74351: NEG
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: PUSH
74357: EMPTY
74358: LIST
74359: LIST
74360: LIST
74361: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74362: LD_ADDR_VAR 0 12
74366: PUSH
74367: LD_INT 2
74369: PUSH
74370: LD_INT 1
74372: NEG
74373: PUSH
74374: EMPTY
74375: LIST
74376: LIST
74377: PUSH
74378: LD_INT 3
74380: PUSH
74381: LD_INT 0
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: PUSH
74388: LD_INT 3
74390: PUSH
74391: LD_INT 1
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: LIST
74402: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74403: LD_ADDR_VAR 0 13
74407: PUSH
74408: LD_INT 3
74410: PUSH
74411: LD_INT 2
74413: PUSH
74414: EMPTY
74415: LIST
74416: LIST
74417: PUSH
74418: LD_INT 3
74420: PUSH
74421: LD_INT 3
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: PUSH
74428: LD_INT 2
74430: PUSH
74431: LD_INT 3
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: EMPTY
74439: LIST
74440: LIST
74441: LIST
74442: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74443: LD_ADDR_VAR 0 14
74447: PUSH
74448: LD_INT 1
74450: PUSH
74451: LD_INT 3
74453: PUSH
74454: EMPTY
74455: LIST
74456: LIST
74457: PUSH
74458: LD_INT 0
74460: PUSH
74461: LD_INT 3
74463: PUSH
74464: EMPTY
74465: LIST
74466: LIST
74467: PUSH
74468: LD_INT 1
74470: NEG
74471: PUSH
74472: LD_INT 2
74474: PUSH
74475: EMPTY
74476: LIST
74477: LIST
74478: PUSH
74479: EMPTY
74480: LIST
74481: LIST
74482: LIST
74483: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74484: LD_ADDR_VAR 0 15
74488: PUSH
74489: LD_INT 2
74491: NEG
74492: PUSH
74493: LD_INT 1
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: LD_INT 3
74502: NEG
74503: PUSH
74504: LD_INT 0
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PUSH
74511: LD_INT 3
74513: NEG
74514: PUSH
74515: LD_INT 1
74517: NEG
74518: PUSH
74519: EMPTY
74520: LIST
74521: LIST
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: LIST
74527: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74528: LD_ADDR_VAR 0 16
74532: PUSH
74533: LD_INT 2
74535: NEG
74536: PUSH
74537: LD_INT 3
74539: NEG
74540: PUSH
74541: EMPTY
74542: LIST
74543: LIST
74544: PUSH
74545: LD_INT 3
74547: NEG
74548: PUSH
74549: LD_INT 2
74551: NEG
74552: PUSH
74553: EMPTY
74554: LIST
74555: LIST
74556: PUSH
74557: LD_INT 3
74559: NEG
74560: PUSH
74561: LD_INT 3
74563: NEG
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: LIST
74573: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74574: LD_ADDR_VAR 0 17
74578: PUSH
74579: LD_INT 1
74581: NEG
74582: PUSH
74583: LD_INT 3
74585: NEG
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: PUSH
74591: LD_INT 0
74593: PUSH
74594: LD_INT 3
74596: NEG
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: PUSH
74602: LD_INT 1
74604: PUSH
74605: LD_INT 2
74607: NEG
74608: PUSH
74609: EMPTY
74610: LIST
74611: LIST
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: LIST
74617: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74618: LD_ADDR_VAR 0 18
74622: PUSH
74623: LD_INT 2
74625: PUSH
74626: LD_INT 1
74628: NEG
74629: PUSH
74630: EMPTY
74631: LIST
74632: LIST
74633: PUSH
74634: LD_INT 3
74636: PUSH
74637: LD_INT 0
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: PUSH
74644: LD_INT 3
74646: PUSH
74647: LD_INT 1
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: EMPTY
74655: LIST
74656: LIST
74657: LIST
74658: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74659: LD_ADDR_VAR 0 19
74663: PUSH
74664: LD_INT 3
74666: PUSH
74667: LD_INT 2
74669: PUSH
74670: EMPTY
74671: LIST
74672: LIST
74673: PUSH
74674: LD_INT 3
74676: PUSH
74677: LD_INT 3
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 2
74686: PUSH
74687: LD_INT 3
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: EMPTY
74695: LIST
74696: LIST
74697: LIST
74698: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74699: LD_ADDR_VAR 0 20
74703: PUSH
74704: LD_INT 1
74706: PUSH
74707: LD_INT 3
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: PUSH
74714: LD_INT 0
74716: PUSH
74717: LD_INT 3
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: PUSH
74724: LD_INT 1
74726: NEG
74727: PUSH
74728: LD_INT 2
74730: PUSH
74731: EMPTY
74732: LIST
74733: LIST
74734: PUSH
74735: EMPTY
74736: LIST
74737: LIST
74738: LIST
74739: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74740: LD_ADDR_VAR 0 21
74744: PUSH
74745: LD_INT 2
74747: NEG
74748: PUSH
74749: LD_INT 1
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: LD_INT 3
74758: NEG
74759: PUSH
74760: LD_INT 0
74762: PUSH
74763: EMPTY
74764: LIST
74765: LIST
74766: PUSH
74767: LD_INT 3
74769: NEG
74770: PUSH
74771: LD_INT 1
74773: NEG
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: PUSH
74779: EMPTY
74780: LIST
74781: LIST
74782: LIST
74783: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74784: LD_ADDR_VAR 0 22
74788: PUSH
74789: LD_INT 2
74791: NEG
74792: PUSH
74793: LD_INT 3
74795: NEG
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PUSH
74801: LD_INT 3
74803: NEG
74804: PUSH
74805: LD_INT 2
74807: NEG
74808: PUSH
74809: EMPTY
74810: LIST
74811: LIST
74812: PUSH
74813: LD_INT 3
74815: NEG
74816: PUSH
74817: LD_INT 3
74819: NEG
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: PUSH
74825: EMPTY
74826: LIST
74827: LIST
74828: LIST
74829: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
74830: LD_ADDR_VAR 0 23
74834: PUSH
74835: LD_INT 0
74837: PUSH
74838: LD_INT 3
74840: NEG
74841: PUSH
74842: EMPTY
74843: LIST
74844: LIST
74845: PUSH
74846: LD_INT 1
74848: NEG
74849: PUSH
74850: LD_INT 4
74852: NEG
74853: PUSH
74854: EMPTY
74855: LIST
74856: LIST
74857: PUSH
74858: LD_INT 1
74860: PUSH
74861: LD_INT 3
74863: NEG
74864: PUSH
74865: EMPTY
74866: LIST
74867: LIST
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: LIST
74873: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
74874: LD_ADDR_VAR 0 24
74878: PUSH
74879: LD_INT 3
74881: PUSH
74882: LD_INT 0
74884: PUSH
74885: EMPTY
74886: LIST
74887: LIST
74888: PUSH
74889: LD_INT 3
74891: PUSH
74892: LD_INT 1
74894: NEG
74895: PUSH
74896: EMPTY
74897: LIST
74898: LIST
74899: PUSH
74900: LD_INT 4
74902: PUSH
74903: LD_INT 1
74905: PUSH
74906: EMPTY
74907: LIST
74908: LIST
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: LIST
74914: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
74915: LD_ADDR_VAR 0 25
74919: PUSH
74920: LD_INT 3
74922: PUSH
74923: LD_INT 3
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: PUSH
74930: LD_INT 4
74932: PUSH
74933: LD_INT 3
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PUSH
74940: LD_INT 3
74942: PUSH
74943: LD_INT 4
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: LIST
74954: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
74955: LD_ADDR_VAR 0 26
74959: PUSH
74960: LD_INT 0
74962: PUSH
74963: LD_INT 3
74965: PUSH
74966: EMPTY
74967: LIST
74968: LIST
74969: PUSH
74970: LD_INT 1
74972: PUSH
74973: LD_INT 4
74975: PUSH
74976: EMPTY
74977: LIST
74978: LIST
74979: PUSH
74980: LD_INT 1
74982: NEG
74983: PUSH
74984: LD_INT 3
74986: PUSH
74987: EMPTY
74988: LIST
74989: LIST
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: LIST
74995: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
74996: LD_ADDR_VAR 0 27
75000: PUSH
75001: LD_INT 3
75003: NEG
75004: PUSH
75005: LD_INT 0
75007: PUSH
75008: EMPTY
75009: LIST
75010: LIST
75011: PUSH
75012: LD_INT 3
75014: NEG
75015: PUSH
75016: LD_INT 1
75018: PUSH
75019: EMPTY
75020: LIST
75021: LIST
75022: PUSH
75023: LD_INT 4
75025: NEG
75026: PUSH
75027: LD_INT 1
75029: NEG
75030: PUSH
75031: EMPTY
75032: LIST
75033: LIST
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: LIST
75039: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75040: LD_ADDR_VAR 0 28
75044: PUSH
75045: LD_INT 3
75047: NEG
75048: PUSH
75049: LD_INT 3
75051: NEG
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 3
75059: NEG
75060: PUSH
75061: LD_INT 4
75063: NEG
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: PUSH
75069: LD_INT 4
75071: NEG
75072: PUSH
75073: LD_INT 3
75075: NEG
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: LIST
75085: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75086: LD_ADDR_VAR 0 29
75090: PUSH
75091: LD_INT 1
75093: NEG
75094: PUSH
75095: LD_INT 3
75097: NEG
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: LD_INT 0
75105: PUSH
75106: LD_INT 3
75108: NEG
75109: PUSH
75110: EMPTY
75111: LIST
75112: LIST
75113: PUSH
75114: LD_INT 1
75116: PUSH
75117: LD_INT 2
75119: NEG
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PUSH
75125: LD_INT 1
75127: NEG
75128: PUSH
75129: LD_INT 4
75131: NEG
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: PUSH
75137: LD_INT 0
75139: PUSH
75140: LD_INT 4
75142: NEG
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: LD_INT 1
75150: PUSH
75151: LD_INT 3
75153: NEG
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 1
75161: NEG
75162: PUSH
75163: LD_INT 5
75165: NEG
75166: PUSH
75167: EMPTY
75168: LIST
75169: LIST
75170: PUSH
75171: LD_INT 0
75173: PUSH
75174: LD_INT 5
75176: NEG
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 1
75184: PUSH
75185: LD_INT 4
75187: NEG
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 1
75195: NEG
75196: PUSH
75197: LD_INT 6
75199: NEG
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PUSH
75205: LD_INT 0
75207: PUSH
75208: LD_INT 6
75210: NEG
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: PUSH
75216: LD_INT 1
75218: PUSH
75219: LD_INT 5
75221: NEG
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: LIST
75231: LIST
75232: LIST
75233: LIST
75234: LIST
75235: LIST
75236: LIST
75237: LIST
75238: LIST
75239: LIST
75240: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75241: LD_ADDR_VAR 0 30
75245: PUSH
75246: LD_INT 2
75248: PUSH
75249: LD_INT 1
75251: NEG
75252: PUSH
75253: EMPTY
75254: LIST
75255: LIST
75256: PUSH
75257: LD_INT 3
75259: PUSH
75260: LD_INT 0
75262: PUSH
75263: EMPTY
75264: LIST
75265: LIST
75266: PUSH
75267: LD_INT 3
75269: PUSH
75270: LD_INT 1
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: PUSH
75277: LD_INT 3
75279: PUSH
75280: LD_INT 1
75282: NEG
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 4
75290: PUSH
75291: LD_INT 0
75293: PUSH
75294: EMPTY
75295: LIST
75296: LIST
75297: PUSH
75298: LD_INT 4
75300: PUSH
75301: LD_INT 1
75303: PUSH
75304: EMPTY
75305: LIST
75306: LIST
75307: PUSH
75308: LD_INT 4
75310: PUSH
75311: LD_INT 1
75313: NEG
75314: PUSH
75315: EMPTY
75316: LIST
75317: LIST
75318: PUSH
75319: LD_INT 5
75321: PUSH
75322: LD_INT 0
75324: PUSH
75325: EMPTY
75326: LIST
75327: LIST
75328: PUSH
75329: LD_INT 5
75331: PUSH
75332: LD_INT 1
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: PUSH
75339: LD_INT 5
75341: PUSH
75342: LD_INT 1
75344: NEG
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: PUSH
75350: LD_INT 6
75352: PUSH
75353: LD_INT 0
75355: PUSH
75356: EMPTY
75357: LIST
75358: LIST
75359: PUSH
75360: LD_INT 6
75362: PUSH
75363: LD_INT 1
75365: PUSH
75366: EMPTY
75367: LIST
75368: LIST
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: LIST
75374: LIST
75375: LIST
75376: LIST
75377: LIST
75378: LIST
75379: LIST
75380: LIST
75381: LIST
75382: LIST
75383: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75384: LD_ADDR_VAR 0 31
75388: PUSH
75389: LD_INT 3
75391: PUSH
75392: LD_INT 2
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PUSH
75399: LD_INT 3
75401: PUSH
75402: LD_INT 3
75404: PUSH
75405: EMPTY
75406: LIST
75407: LIST
75408: PUSH
75409: LD_INT 2
75411: PUSH
75412: LD_INT 3
75414: PUSH
75415: EMPTY
75416: LIST
75417: LIST
75418: PUSH
75419: LD_INT 4
75421: PUSH
75422: LD_INT 3
75424: PUSH
75425: EMPTY
75426: LIST
75427: LIST
75428: PUSH
75429: LD_INT 4
75431: PUSH
75432: LD_INT 4
75434: PUSH
75435: EMPTY
75436: LIST
75437: LIST
75438: PUSH
75439: LD_INT 3
75441: PUSH
75442: LD_INT 4
75444: PUSH
75445: EMPTY
75446: LIST
75447: LIST
75448: PUSH
75449: LD_INT 5
75451: PUSH
75452: LD_INT 4
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: PUSH
75459: LD_INT 5
75461: PUSH
75462: LD_INT 5
75464: PUSH
75465: EMPTY
75466: LIST
75467: LIST
75468: PUSH
75469: LD_INT 4
75471: PUSH
75472: LD_INT 5
75474: PUSH
75475: EMPTY
75476: LIST
75477: LIST
75478: PUSH
75479: LD_INT 6
75481: PUSH
75482: LD_INT 5
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: PUSH
75489: LD_INT 6
75491: PUSH
75492: LD_INT 6
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 5
75501: PUSH
75502: LD_INT 6
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: EMPTY
75510: LIST
75511: LIST
75512: LIST
75513: LIST
75514: LIST
75515: LIST
75516: LIST
75517: LIST
75518: LIST
75519: LIST
75520: LIST
75521: LIST
75522: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75523: LD_ADDR_VAR 0 32
75527: PUSH
75528: LD_INT 1
75530: PUSH
75531: LD_INT 3
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 0
75540: PUSH
75541: LD_INT 3
75543: PUSH
75544: EMPTY
75545: LIST
75546: LIST
75547: PUSH
75548: LD_INT 1
75550: NEG
75551: PUSH
75552: LD_INT 2
75554: PUSH
75555: EMPTY
75556: LIST
75557: LIST
75558: PUSH
75559: LD_INT 1
75561: PUSH
75562: LD_INT 4
75564: PUSH
75565: EMPTY
75566: LIST
75567: LIST
75568: PUSH
75569: LD_INT 0
75571: PUSH
75572: LD_INT 4
75574: PUSH
75575: EMPTY
75576: LIST
75577: LIST
75578: PUSH
75579: LD_INT 1
75581: NEG
75582: PUSH
75583: LD_INT 3
75585: PUSH
75586: EMPTY
75587: LIST
75588: LIST
75589: PUSH
75590: LD_INT 1
75592: PUSH
75593: LD_INT 5
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: LD_INT 0
75602: PUSH
75603: LD_INT 5
75605: PUSH
75606: EMPTY
75607: LIST
75608: LIST
75609: PUSH
75610: LD_INT 1
75612: NEG
75613: PUSH
75614: LD_INT 4
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 1
75623: PUSH
75624: LD_INT 6
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: LD_INT 0
75633: PUSH
75634: LD_INT 6
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 1
75643: NEG
75644: PUSH
75645: LD_INT 5
75647: PUSH
75648: EMPTY
75649: LIST
75650: LIST
75651: PUSH
75652: EMPTY
75653: LIST
75654: LIST
75655: LIST
75656: LIST
75657: LIST
75658: LIST
75659: LIST
75660: LIST
75661: LIST
75662: LIST
75663: LIST
75664: LIST
75665: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75666: LD_ADDR_VAR 0 33
75670: PUSH
75671: LD_INT 2
75673: NEG
75674: PUSH
75675: LD_INT 1
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 3
75684: NEG
75685: PUSH
75686: LD_INT 0
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 3
75695: NEG
75696: PUSH
75697: LD_INT 1
75699: NEG
75700: PUSH
75701: EMPTY
75702: LIST
75703: LIST
75704: PUSH
75705: LD_INT 3
75707: NEG
75708: PUSH
75709: LD_INT 1
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PUSH
75716: LD_INT 4
75718: NEG
75719: PUSH
75720: LD_INT 0
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PUSH
75727: LD_INT 4
75729: NEG
75730: PUSH
75731: LD_INT 1
75733: NEG
75734: PUSH
75735: EMPTY
75736: LIST
75737: LIST
75738: PUSH
75739: LD_INT 4
75741: NEG
75742: PUSH
75743: LD_INT 1
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PUSH
75750: LD_INT 5
75752: NEG
75753: PUSH
75754: LD_INT 0
75756: PUSH
75757: EMPTY
75758: LIST
75759: LIST
75760: PUSH
75761: LD_INT 5
75763: NEG
75764: PUSH
75765: LD_INT 1
75767: NEG
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: PUSH
75773: LD_INT 5
75775: NEG
75776: PUSH
75777: LD_INT 1
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PUSH
75784: LD_INT 6
75786: NEG
75787: PUSH
75788: LD_INT 0
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 6
75797: NEG
75798: PUSH
75799: LD_INT 1
75801: NEG
75802: PUSH
75803: EMPTY
75804: LIST
75805: LIST
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: LIST
75811: LIST
75812: LIST
75813: LIST
75814: LIST
75815: LIST
75816: LIST
75817: LIST
75818: LIST
75819: LIST
75820: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
75821: LD_ADDR_VAR 0 34
75825: PUSH
75826: LD_INT 2
75828: NEG
75829: PUSH
75830: LD_INT 3
75832: NEG
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: PUSH
75838: LD_INT 3
75840: NEG
75841: PUSH
75842: LD_INT 2
75844: NEG
75845: PUSH
75846: EMPTY
75847: LIST
75848: LIST
75849: PUSH
75850: LD_INT 3
75852: NEG
75853: PUSH
75854: LD_INT 3
75856: NEG
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: LD_INT 3
75864: NEG
75865: PUSH
75866: LD_INT 4
75868: NEG
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: LD_INT 4
75876: NEG
75877: PUSH
75878: LD_INT 3
75880: NEG
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: PUSH
75886: LD_INT 4
75888: NEG
75889: PUSH
75890: LD_INT 4
75892: NEG
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: PUSH
75898: LD_INT 4
75900: NEG
75901: PUSH
75902: LD_INT 5
75904: NEG
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: PUSH
75910: LD_INT 5
75912: NEG
75913: PUSH
75914: LD_INT 4
75916: NEG
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: PUSH
75922: LD_INT 5
75924: NEG
75925: PUSH
75926: LD_INT 5
75928: NEG
75929: PUSH
75930: EMPTY
75931: LIST
75932: LIST
75933: PUSH
75934: LD_INT 5
75936: NEG
75937: PUSH
75938: LD_INT 6
75940: NEG
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: PUSH
75946: LD_INT 6
75948: NEG
75949: PUSH
75950: LD_INT 5
75952: NEG
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PUSH
75958: LD_INT 6
75960: NEG
75961: PUSH
75962: LD_INT 6
75964: NEG
75965: PUSH
75966: EMPTY
75967: LIST
75968: LIST
75969: PUSH
75970: EMPTY
75971: LIST
75972: LIST
75973: LIST
75974: LIST
75975: LIST
75976: LIST
75977: LIST
75978: LIST
75979: LIST
75980: LIST
75981: LIST
75982: LIST
75983: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
75984: LD_ADDR_VAR 0 41
75988: PUSH
75989: LD_INT 0
75991: PUSH
75992: LD_INT 2
75994: NEG
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: LD_INT 1
76002: NEG
76003: PUSH
76004: LD_INT 3
76006: NEG
76007: PUSH
76008: EMPTY
76009: LIST
76010: LIST
76011: PUSH
76012: LD_INT 1
76014: PUSH
76015: LD_INT 2
76017: NEG
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: PUSH
76023: EMPTY
76024: LIST
76025: LIST
76026: LIST
76027: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76028: LD_ADDR_VAR 0 42
76032: PUSH
76033: LD_INT 2
76035: PUSH
76036: LD_INT 0
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 2
76045: PUSH
76046: LD_INT 1
76048: NEG
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: PUSH
76054: LD_INT 3
76056: PUSH
76057: LD_INT 1
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PUSH
76064: EMPTY
76065: LIST
76066: LIST
76067: LIST
76068: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76069: LD_ADDR_VAR 0 43
76073: PUSH
76074: LD_INT 2
76076: PUSH
76077: LD_INT 2
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: PUSH
76084: LD_INT 3
76086: PUSH
76087: LD_INT 2
76089: PUSH
76090: EMPTY
76091: LIST
76092: LIST
76093: PUSH
76094: LD_INT 2
76096: PUSH
76097: LD_INT 3
76099: PUSH
76100: EMPTY
76101: LIST
76102: LIST
76103: PUSH
76104: EMPTY
76105: LIST
76106: LIST
76107: LIST
76108: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76109: LD_ADDR_VAR 0 44
76113: PUSH
76114: LD_INT 0
76116: PUSH
76117: LD_INT 2
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: LD_INT 1
76126: PUSH
76127: LD_INT 3
76129: PUSH
76130: EMPTY
76131: LIST
76132: LIST
76133: PUSH
76134: LD_INT 1
76136: NEG
76137: PUSH
76138: LD_INT 2
76140: PUSH
76141: EMPTY
76142: LIST
76143: LIST
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: LIST
76149: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76150: LD_ADDR_VAR 0 45
76154: PUSH
76155: LD_INT 2
76157: NEG
76158: PUSH
76159: LD_INT 0
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PUSH
76166: LD_INT 2
76168: NEG
76169: PUSH
76170: LD_INT 1
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: LD_INT 3
76179: NEG
76180: PUSH
76181: LD_INT 1
76183: NEG
76184: PUSH
76185: EMPTY
76186: LIST
76187: LIST
76188: PUSH
76189: EMPTY
76190: LIST
76191: LIST
76192: LIST
76193: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76194: LD_ADDR_VAR 0 46
76198: PUSH
76199: LD_INT 2
76201: NEG
76202: PUSH
76203: LD_INT 2
76205: NEG
76206: PUSH
76207: EMPTY
76208: LIST
76209: LIST
76210: PUSH
76211: LD_INT 2
76213: NEG
76214: PUSH
76215: LD_INT 3
76217: NEG
76218: PUSH
76219: EMPTY
76220: LIST
76221: LIST
76222: PUSH
76223: LD_INT 3
76225: NEG
76226: PUSH
76227: LD_INT 2
76229: NEG
76230: PUSH
76231: EMPTY
76232: LIST
76233: LIST
76234: PUSH
76235: EMPTY
76236: LIST
76237: LIST
76238: LIST
76239: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76240: LD_ADDR_VAR 0 47
76244: PUSH
76245: LD_INT 2
76247: NEG
76248: PUSH
76249: LD_INT 3
76251: NEG
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: PUSH
76257: LD_INT 1
76259: NEG
76260: PUSH
76261: LD_INT 3
76263: NEG
76264: PUSH
76265: EMPTY
76266: LIST
76267: LIST
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76273: LD_ADDR_VAR 0 48
76277: PUSH
76278: LD_INT 1
76280: PUSH
76281: LD_INT 2
76283: NEG
76284: PUSH
76285: EMPTY
76286: LIST
76287: LIST
76288: PUSH
76289: LD_INT 2
76291: PUSH
76292: LD_INT 1
76294: NEG
76295: PUSH
76296: EMPTY
76297: LIST
76298: LIST
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76304: LD_ADDR_VAR 0 49
76308: PUSH
76309: LD_INT 3
76311: PUSH
76312: LD_INT 1
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PUSH
76319: LD_INT 3
76321: PUSH
76322: LD_INT 2
76324: PUSH
76325: EMPTY
76326: LIST
76327: LIST
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76333: LD_ADDR_VAR 0 50
76337: PUSH
76338: LD_INT 2
76340: PUSH
76341: LD_INT 3
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: PUSH
76348: LD_INT 1
76350: PUSH
76351: LD_INT 3
76353: PUSH
76354: EMPTY
76355: LIST
76356: LIST
76357: PUSH
76358: EMPTY
76359: LIST
76360: LIST
76361: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76362: LD_ADDR_VAR 0 51
76366: PUSH
76367: LD_INT 1
76369: NEG
76370: PUSH
76371: LD_INT 2
76373: PUSH
76374: EMPTY
76375: LIST
76376: LIST
76377: PUSH
76378: LD_INT 2
76380: NEG
76381: PUSH
76382: LD_INT 1
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76393: LD_ADDR_VAR 0 52
76397: PUSH
76398: LD_INT 3
76400: NEG
76401: PUSH
76402: LD_INT 1
76404: NEG
76405: PUSH
76406: EMPTY
76407: LIST
76408: LIST
76409: PUSH
76410: LD_INT 3
76412: NEG
76413: PUSH
76414: LD_INT 2
76416: NEG
76417: PUSH
76418: EMPTY
76419: LIST
76420: LIST
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76426: LD_ADDR_VAR 0 53
76430: PUSH
76431: LD_INT 1
76433: NEG
76434: PUSH
76435: LD_INT 3
76437: NEG
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: PUSH
76443: LD_INT 0
76445: PUSH
76446: LD_INT 3
76448: NEG
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: LD_INT 1
76456: PUSH
76457: LD_INT 2
76459: NEG
76460: PUSH
76461: EMPTY
76462: LIST
76463: LIST
76464: PUSH
76465: EMPTY
76466: LIST
76467: LIST
76468: LIST
76469: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76470: LD_ADDR_VAR 0 54
76474: PUSH
76475: LD_INT 2
76477: PUSH
76478: LD_INT 1
76480: NEG
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: PUSH
76486: LD_INT 3
76488: PUSH
76489: LD_INT 0
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: PUSH
76496: LD_INT 3
76498: PUSH
76499: LD_INT 1
76501: PUSH
76502: EMPTY
76503: LIST
76504: LIST
76505: PUSH
76506: EMPTY
76507: LIST
76508: LIST
76509: LIST
76510: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76511: LD_ADDR_VAR 0 55
76515: PUSH
76516: LD_INT 3
76518: PUSH
76519: LD_INT 2
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: PUSH
76526: LD_INT 3
76528: PUSH
76529: LD_INT 3
76531: PUSH
76532: EMPTY
76533: LIST
76534: LIST
76535: PUSH
76536: LD_INT 2
76538: PUSH
76539: LD_INT 3
76541: PUSH
76542: EMPTY
76543: LIST
76544: LIST
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: LIST
76550: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76551: LD_ADDR_VAR 0 56
76555: PUSH
76556: LD_INT 1
76558: PUSH
76559: LD_INT 3
76561: PUSH
76562: EMPTY
76563: LIST
76564: LIST
76565: PUSH
76566: LD_INT 0
76568: PUSH
76569: LD_INT 3
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: PUSH
76576: LD_INT 1
76578: NEG
76579: PUSH
76580: LD_INT 2
76582: PUSH
76583: EMPTY
76584: LIST
76585: LIST
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: LIST
76591: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76592: LD_ADDR_VAR 0 57
76596: PUSH
76597: LD_INT 2
76599: NEG
76600: PUSH
76601: LD_INT 1
76603: PUSH
76604: EMPTY
76605: LIST
76606: LIST
76607: PUSH
76608: LD_INT 3
76610: NEG
76611: PUSH
76612: LD_INT 0
76614: PUSH
76615: EMPTY
76616: LIST
76617: LIST
76618: PUSH
76619: LD_INT 3
76621: NEG
76622: PUSH
76623: LD_INT 1
76625: NEG
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: LIST
76635: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76636: LD_ADDR_VAR 0 58
76640: PUSH
76641: LD_INT 2
76643: NEG
76644: PUSH
76645: LD_INT 3
76647: NEG
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: PUSH
76653: LD_INT 3
76655: NEG
76656: PUSH
76657: LD_INT 2
76659: NEG
76660: PUSH
76661: EMPTY
76662: LIST
76663: LIST
76664: PUSH
76665: LD_INT 3
76667: NEG
76668: PUSH
76669: LD_INT 3
76671: NEG
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: LIST
76681: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76682: LD_ADDR_VAR 0 59
76686: PUSH
76687: LD_INT 1
76689: NEG
76690: PUSH
76691: LD_INT 2
76693: NEG
76694: PUSH
76695: EMPTY
76696: LIST
76697: LIST
76698: PUSH
76699: LD_INT 0
76701: PUSH
76702: LD_INT 2
76704: NEG
76705: PUSH
76706: EMPTY
76707: LIST
76708: LIST
76709: PUSH
76710: LD_INT 1
76712: PUSH
76713: LD_INT 1
76715: NEG
76716: PUSH
76717: EMPTY
76718: LIST
76719: LIST
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: LIST
76725: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76726: LD_ADDR_VAR 0 60
76730: PUSH
76731: LD_INT 1
76733: PUSH
76734: LD_INT 1
76736: NEG
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: PUSH
76742: LD_INT 2
76744: PUSH
76745: LD_INT 0
76747: PUSH
76748: EMPTY
76749: LIST
76750: LIST
76751: PUSH
76752: LD_INT 2
76754: PUSH
76755: LD_INT 1
76757: PUSH
76758: EMPTY
76759: LIST
76760: LIST
76761: PUSH
76762: EMPTY
76763: LIST
76764: LIST
76765: LIST
76766: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76767: LD_ADDR_VAR 0 61
76771: PUSH
76772: LD_INT 2
76774: PUSH
76775: LD_INT 1
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: PUSH
76782: LD_INT 2
76784: PUSH
76785: LD_INT 2
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: LD_INT 1
76794: PUSH
76795: LD_INT 2
76797: PUSH
76798: EMPTY
76799: LIST
76800: LIST
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: LIST
76806: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76807: LD_ADDR_VAR 0 62
76811: PUSH
76812: LD_INT 1
76814: PUSH
76815: LD_INT 2
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: PUSH
76822: LD_INT 0
76824: PUSH
76825: LD_INT 2
76827: PUSH
76828: EMPTY
76829: LIST
76830: LIST
76831: PUSH
76832: LD_INT 1
76834: NEG
76835: PUSH
76836: LD_INT 1
76838: PUSH
76839: EMPTY
76840: LIST
76841: LIST
76842: PUSH
76843: EMPTY
76844: LIST
76845: LIST
76846: LIST
76847: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76848: LD_ADDR_VAR 0 63
76852: PUSH
76853: LD_INT 1
76855: NEG
76856: PUSH
76857: LD_INT 1
76859: PUSH
76860: EMPTY
76861: LIST
76862: LIST
76863: PUSH
76864: LD_INT 2
76866: NEG
76867: PUSH
76868: LD_INT 0
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: PUSH
76875: LD_INT 2
76877: NEG
76878: PUSH
76879: LD_INT 1
76881: NEG
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: LIST
76891: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76892: LD_ADDR_VAR 0 64
76896: PUSH
76897: LD_INT 1
76899: NEG
76900: PUSH
76901: LD_INT 2
76903: NEG
76904: PUSH
76905: EMPTY
76906: LIST
76907: LIST
76908: PUSH
76909: LD_INT 2
76911: NEG
76912: PUSH
76913: LD_INT 1
76915: NEG
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: PUSH
76921: LD_INT 2
76923: NEG
76924: PUSH
76925: LD_INT 2
76927: NEG
76928: PUSH
76929: EMPTY
76930: LIST
76931: LIST
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: LIST
76937: ST_TO_ADDR
// end ; 2 :
76938: GO 80204
76940: LD_INT 2
76942: DOUBLE
76943: EQUAL
76944: IFTRUE 76948
76946: GO 80203
76948: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
76949: LD_ADDR_VAR 0 29
76953: PUSH
76954: LD_INT 4
76956: PUSH
76957: LD_INT 0
76959: PUSH
76960: EMPTY
76961: LIST
76962: LIST
76963: PUSH
76964: LD_INT 4
76966: PUSH
76967: LD_INT 1
76969: NEG
76970: PUSH
76971: EMPTY
76972: LIST
76973: LIST
76974: PUSH
76975: LD_INT 5
76977: PUSH
76978: LD_INT 0
76980: PUSH
76981: EMPTY
76982: LIST
76983: LIST
76984: PUSH
76985: LD_INT 5
76987: PUSH
76988: LD_INT 1
76990: PUSH
76991: EMPTY
76992: LIST
76993: LIST
76994: PUSH
76995: LD_INT 4
76997: PUSH
76998: LD_INT 1
77000: PUSH
77001: EMPTY
77002: LIST
77003: LIST
77004: PUSH
77005: LD_INT 3
77007: PUSH
77008: LD_INT 0
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: PUSH
77015: LD_INT 3
77017: PUSH
77018: LD_INT 1
77020: NEG
77021: PUSH
77022: EMPTY
77023: LIST
77024: LIST
77025: PUSH
77026: LD_INT 3
77028: PUSH
77029: LD_INT 2
77031: NEG
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: PUSH
77037: LD_INT 5
77039: PUSH
77040: LD_INT 2
77042: PUSH
77043: EMPTY
77044: LIST
77045: LIST
77046: PUSH
77047: LD_INT 3
77049: PUSH
77050: LD_INT 3
77052: PUSH
77053: EMPTY
77054: LIST
77055: LIST
77056: PUSH
77057: LD_INT 3
77059: PUSH
77060: LD_INT 2
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: PUSH
77067: LD_INT 4
77069: PUSH
77070: LD_INT 3
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: PUSH
77077: LD_INT 4
77079: PUSH
77080: LD_INT 4
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: PUSH
77087: LD_INT 3
77089: PUSH
77090: LD_INT 4
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: PUSH
77097: LD_INT 2
77099: PUSH
77100: LD_INT 3
77102: PUSH
77103: EMPTY
77104: LIST
77105: LIST
77106: PUSH
77107: LD_INT 2
77109: PUSH
77110: LD_INT 2
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 4
77119: PUSH
77120: LD_INT 2
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: PUSH
77127: LD_INT 2
77129: PUSH
77130: LD_INT 4
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: LD_INT 0
77139: PUSH
77140: LD_INT 4
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: PUSH
77147: LD_INT 0
77149: PUSH
77150: LD_INT 3
77152: PUSH
77153: EMPTY
77154: LIST
77155: LIST
77156: PUSH
77157: LD_INT 1
77159: PUSH
77160: LD_INT 4
77162: PUSH
77163: EMPTY
77164: LIST
77165: LIST
77166: PUSH
77167: LD_INT 1
77169: PUSH
77170: LD_INT 5
77172: PUSH
77173: EMPTY
77174: LIST
77175: LIST
77176: PUSH
77177: LD_INT 0
77179: PUSH
77180: LD_INT 5
77182: PUSH
77183: EMPTY
77184: LIST
77185: LIST
77186: PUSH
77187: LD_INT 1
77189: NEG
77190: PUSH
77191: LD_INT 4
77193: PUSH
77194: EMPTY
77195: LIST
77196: LIST
77197: PUSH
77198: LD_INT 1
77200: NEG
77201: PUSH
77202: LD_INT 3
77204: PUSH
77205: EMPTY
77206: LIST
77207: LIST
77208: PUSH
77209: LD_INT 2
77211: PUSH
77212: LD_INT 5
77214: PUSH
77215: EMPTY
77216: LIST
77217: LIST
77218: PUSH
77219: LD_INT 2
77221: NEG
77222: PUSH
77223: LD_INT 3
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: PUSH
77230: LD_INT 3
77232: NEG
77233: PUSH
77234: LD_INT 0
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: PUSH
77241: LD_INT 3
77243: NEG
77244: PUSH
77245: LD_INT 1
77247: NEG
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: PUSH
77253: LD_INT 2
77255: NEG
77256: PUSH
77257: LD_INT 0
77259: PUSH
77260: EMPTY
77261: LIST
77262: LIST
77263: PUSH
77264: LD_INT 2
77266: NEG
77267: PUSH
77268: LD_INT 1
77270: PUSH
77271: EMPTY
77272: LIST
77273: LIST
77274: PUSH
77275: LD_INT 3
77277: NEG
77278: PUSH
77279: LD_INT 1
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 4
77288: NEG
77289: PUSH
77290: LD_INT 0
77292: PUSH
77293: EMPTY
77294: LIST
77295: LIST
77296: PUSH
77297: LD_INT 4
77299: NEG
77300: PUSH
77301: LD_INT 1
77303: NEG
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: PUSH
77309: LD_INT 4
77311: NEG
77312: PUSH
77313: LD_INT 2
77315: NEG
77316: PUSH
77317: EMPTY
77318: LIST
77319: LIST
77320: PUSH
77321: LD_INT 2
77323: NEG
77324: PUSH
77325: LD_INT 2
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: PUSH
77332: LD_INT 4
77334: NEG
77335: PUSH
77336: LD_INT 4
77338: NEG
77339: PUSH
77340: EMPTY
77341: LIST
77342: LIST
77343: PUSH
77344: LD_INT 4
77346: NEG
77347: PUSH
77348: LD_INT 5
77350: NEG
77351: PUSH
77352: EMPTY
77353: LIST
77354: LIST
77355: PUSH
77356: LD_INT 3
77358: NEG
77359: PUSH
77360: LD_INT 4
77362: NEG
77363: PUSH
77364: EMPTY
77365: LIST
77366: LIST
77367: PUSH
77368: LD_INT 3
77370: NEG
77371: PUSH
77372: LD_INT 3
77374: NEG
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: PUSH
77380: LD_INT 4
77382: NEG
77383: PUSH
77384: LD_INT 3
77386: NEG
77387: PUSH
77388: EMPTY
77389: LIST
77390: LIST
77391: PUSH
77392: LD_INT 5
77394: NEG
77395: PUSH
77396: LD_INT 4
77398: NEG
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: PUSH
77404: LD_INT 5
77406: NEG
77407: PUSH
77408: LD_INT 5
77410: NEG
77411: PUSH
77412: EMPTY
77413: LIST
77414: LIST
77415: PUSH
77416: LD_INT 3
77418: NEG
77419: PUSH
77420: LD_INT 5
77422: NEG
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: PUSH
77428: LD_INT 5
77430: NEG
77431: PUSH
77432: LD_INT 3
77434: NEG
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: LIST
77444: LIST
77445: LIST
77446: LIST
77447: LIST
77448: LIST
77449: LIST
77450: LIST
77451: LIST
77452: LIST
77453: LIST
77454: LIST
77455: LIST
77456: LIST
77457: LIST
77458: LIST
77459: LIST
77460: LIST
77461: LIST
77462: LIST
77463: LIST
77464: LIST
77465: LIST
77466: LIST
77467: LIST
77468: LIST
77469: LIST
77470: LIST
77471: LIST
77472: LIST
77473: LIST
77474: LIST
77475: LIST
77476: LIST
77477: LIST
77478: LIST
77479: LIST
77480: LIST
77481: LIST
77482: LIST
77483: LIST
77484: LIST
77485: LIST
77486: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77487: LD_ADDR_VAR 0 30
77491: PUSH
77492: LD_INT 4
77494: PUSH
77495: LD_INT 4
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 4
77504: PUSH
77505: LD_INT 3
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: PUSH
77512: LD_INT 5
77514: PUSH
77515: LD_INT 4
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: LD_INT 5
77524: PUSH
77525: LD_INT 5
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: PUSH
77532: LD_INT 4
77534: PUSH
77535: LD_INT 5
77537: PUSH
77538: EMPTY
77539: LIST
77540: LIST
77541: PUSH
77542: LD_INT 3
77544: PUSH
77545: LD_INT 4
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: PUSH
77552: LD_INT 3
77554: PUSH
77555: LD_INT 3
77557: PUSH
77558: EMPTY
77559: LIST
77560: LIST
77561: PUSH
77562: LD_INT 5
77564: PUSH
77565: LD_INT 3
77567: PUSH
77568: EMPTY
77569: LIST
77570: LIST
77571: PUSH
77572: LD_INT 3
77574: PUSH
77575: LD_INT 5
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: LD_INT 0
77584: PUSH
77585: LD_INT 3
77587: PUSH
77588: EMPTY
77589: LIST
77590: LIST
77591: PUSH
77592: LD_INT 0
77594: PUSH
77595: LD_INT 2
77597: PUSH
77598: EMPTY
77599: LIST
77600: LIST
77601: PUSH
77602: LD_INT 1
77604: PUSH
77605: LD_INT 3
77607: PUSH
77608: EMPTY
77609: LIST
77610: LIST
77611: PUSH
77612: LD_INT 1
77614: PUSH
77615: LD_INT 4
77617: PUSH
77618: EMPTY
77619: LIST
77620: LIST
77621: PUSH
77622: LD_INT 0
77624: PUSH
77625: LD_INT 4
77627: PUSH
77628: EMPTY
77629: LIST
77630: LIST
77631: PUSH
77632: LD_INT 1
77634: NEG
77635: PUSH
77636: LD_INT 3
77638: PUSH
77639: EMPTY
77640: LIST
77641: LIST
77642: PUSH
77643: LD_INT 1
77645: NEG
77646: PUSH
77647: LD_INT 2
77649: PUSH
77650: EMPTY
77651: LIST
77652: LIST
77653: PUSH
77654: LD_INT 2
77656: PUSH
77657: LD_INT 4
77659: PUSH
77660: EMPTY
77661: LIST
77662: LIST
77663: PUSH
77664: LD_INT 2
77666: NEG
77667: PUSH
77668: LD_INT 2
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: PUSH
77675: LD_INT 4
77677: NEG
77678: PUSH
77679: LD_INT 0
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: LD_INT 4
77688: NEG
77689: PUSH
77690: LD_INT 1
77692: NEG
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: PUSH
77698: LD_INT 3
77700: NEG
77701: PUSH
77702: LD_INT 0
77704: PUSH
77705: EMPTY
77706: LIST
77707: LIST
77708: PUSH
77709: LD_INT 3
77711: NEG
77712: PUSH
77713: LD_INT 1
77715: PUSH
77716: EMPTY
77717: LIST
77718: LIST
77719: PUSH
77720: LD_INT 4
77722: NEG
77723: PUSH
77724: LD_INT 1
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: PUSH
77731: LD_INT 5
77733: NEG
77734: PUSH
77735: LD_INT 0
77737: PUSH
77738: EMPTY
77739: LIST
77740: LIST
77741: PUSH
77742: LD_INT 5
77744: NEG
77745: PUSH
77746: LD_INT 1
77748: NEG
77749: PUSH
77750: EMPTY
77751: LIST
77752: LIST
77753: PUSH
77754: LD_INT 5
77756: NEG
77757: PUSH
77758: LD_INT 2
77760: NEG
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: LD_INT 3
77768: NEG
77769: PUSH
77770: LD_INT 2
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: PUSH
77777: LD_INT 3
77779: NEG
77780: PUSH
77781: LD_INT 3
77783: NEG
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: PUSH
77789: LD_INT 3
77791: NEG
77792: PUSH
77793: LD_INT 4
77795: NEG
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: LD_INT 2
77803: NEG
77804: PUSH
77805: LD_INT 3
77807: NEG
77808: PUSH
77809: EMPTY
77810: LIST
77811: LIST
77812: PUSH
77813: LD_INT 2
77815: NEG
77816: PUSH
77817: LD_INT 2
77819: NEG
77820: PUSH
77821: EMPTY
77822: LIST
77823: LIST
77824: PUSH
77825: LD_INT 3
77827: NEG
77828: PUSH
77829: LD_INT 2
77831: NEG
77832: PUSH
77833: EMPTY
77834: LIST
77835: LIST
77836: PUSH
77837: LD_INT 4
77839: NEG
77840: PUSH
77841: LD_INT 3
77843: NEG
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: PUSH
77849: LD_INT 4
77851: NEG
77852: PUSH
77853: LD_INT 4
77855: NEG
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PUSH
77861: LD_INT 2
77863: NEG
77864: PUSH
77865: LD_INT 4
77867: NEG
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: LD_INT 4
77875: NEG
77876: PUSH
77877: LD_INT 2
77879: NEG
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PUSH
77885: LD_INT 0
77887: PUSH
77888: LD_INT 4
77890: NEG
77891: PUSH
77892: EMPTY
77893: LIST
77894: LIST
77895: PUSH
77896: LD_INT 0
77898: PUSH
77899: LD_INT 5
77901: NEG
77902: PUSH
77903: EMPTY
77904: LIST
77905: LIST
77906: PUSH
77907: LD_INT 1
77909: PUSH
77910: LD_INT 4
77912: NEG
77913: PUSH
77914: EMPTY
77915: LIST
77916: LIST
77917: PUSH
77918: LD_INT 1
77920: PUSH
77921: LD_INT 3
77923: NEG
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 0
77931: PUSH
77932: LD_INT 3
77934: NEG
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 1
77942: NEG
77943: PUSH
77944: LD_INT 4
77946: NEG
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: LD_INT 1
77954: NEG
77955: PUSH
77956: LD_INT 5
77958: NEG
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: LD_INT 2
77966: PUSH
77967: LD_INT 3
77969: NEG
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: PUSH
77975: LD_INT 2
77977: NEG
77978: PUSH
77979: LD_INT 5
77981: NEG
77982: PUSH
77983: EMPTY
77984: LIST
77985: LIST
77986: PUSH
77987: EMPTY
77988: LIST
77989: LIST
77990: LIST
77991: LIST
77992: LIST
77993: LIST
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: LIST
78011: LIST
78012: LIST
78013: LIST
78014: LIST
78015: LIST
78016: LIST
78017: LIST
78018: LIST
78019: LIST
78020: LIST
78021: LIST
78022: LIST
78023: LIST
78024: LIST
78025: LIST
78026: LIST
78027: LIST
78028: LIST
78029: LIST
78030: LIST
78031: LIST
78032: LIST
78033: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78034: LD_ADDR_VAR 0 31
78038: PUSH
78039: LD_INT 0
78041: PUSH
78042: LD_INT 4
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: PUSH
78049: LD_INT 0
78051: PUSH
78052: LD_INT 3
78054: PUSH
78055: EMPTY
78056: LIST
78057: LIST
78058: PUSH
78059: LD_INT 1
78061: PUSH
78062: LD_INT 4
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: LD_INT 1
78071: PUSH
78072: LD_INT 5
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PUSH
78079: LD_INT 0
78081: PUSH
78082: LD_INT 5
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: PUSH
78089: LD_INT 1
78091: NEG
78092: PUSH
78093: LD_INT 4
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: PUSH
78100: LD_INT 1
78102: NEG
78103: PUSH
78104: LD_INT 3
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: PUSH
78111: LD_INT 2
78113: PUSH
78114: LD_INT 5
78116: PUSH
78117: EMPTY
78118: LIST
78119: LIST
78120: PUSH
78121: LD_INT 2
78123: NEG
78124: PUSH
78125: LD_INT 3
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 3
78134: NEG
78135: PUSH
78136: LD_INT 0
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: PUSH
78143: LD_INT 3
78145: NEG
78146: PUSH
78147: LD_INT 1
78149: NEG
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PUSH
78155: LD_INT 2
78157: NEG
78158: PUSH
78159: LD_INT 0
78161: PUSH
78162: EMPTY
78163: LIST
78164: LIST
78165: PUSH
78166: LD_INT 2
78168: NEG
78169: PUSH
78170: LD_INT 1
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 3
78179: NEG
78180: PUSH
78181: LD_INT 1
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PUSH
78188: LD_INT 4
78190: NEG
78191: PUSH
78192: LD_INT 0
78194: PUSH
78195: EMPTY
78196: LIST
78197: LIST
78198: PUSH
78199: LD_INT 4
78201: NEG
78202: PUSH
78203: LD_INT 1
78205: NEG
78206: PUSH
78207: EMPTY
78208: LIST
78209: LIST
78210: PUSH
78211: LD_INT 4
78213: NEG
78214: PUSH
78215: LD_INT 2
78217: NEG
78218: PUSH
78219: EMPTY
78220: LIST
78221: LIST
78222: PUSH
78223: LD_INT 2
78225: NEG
78226: PUSH
78227: LD_INT 2
78229: PUSH
78230: EMPTY
78231: LIST
78232: LIST
78233: PUSH
78234: LD_INT 4
78236: NEG
78237: PUSH
78238: LD_INT 4
78240: NEG
78241: PUSH
78242: EMPTY
78243: LIST
78244: LIST
78245: PUSH
78246: LD_INT 4
78248: NEG
78249: PUSH
78250: LD_INT 5
78252: NEG
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: PUSH
78258: LD_INT 3
78260: NEG
78261: PUSH
78262: LD_INT 4
78264: NEG
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: PUSH
78270: LD_INT 3
78272: NEG
78273: PUSH
78274: LD_INT 3
78276: NEG
78277: PUSH
78278: EMPTY
78279: LIST
78280: LIST
78281: PUSH
78282: LD_INT 4
78284: NEG
78285: PUSH
78286: LD_INT 3
78288: NEG
78289: PUSH
78290: EMPTY
78291: LIST
78292: LIST
78293: PUSH
78294: LD_INT 5
78296: NEG
78297: PUSH
78298: LD_INT 4
78300: NEG
78301: PUSH
78302: EMPTY
78303: LIST
78304: LIST
78305: PUSH
78306: LD_INT 5
78308: NEG
78309: PUSH
78310: LD_INT 5
78312: NEG
78313: PUSH
78314: EMPTY
78315: LIST
78316: LIST
78317: PUSH
78318: LD_INT 3
78320: NEG
78321: PUSH
78322: LD_INT 5
78324: NEG
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: PUSH
78330: LD_INT 5
78332: NEG
78333: PUSH
78334: LD_INT 3
78336: NEG
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 0
78344: PUSH
78345: LD_INT 3
78347: NEG
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 0
78355: PUSH
78356: LD_INT 4
78358: NEG
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: PUSH
78364: LD_INT 1
78366: PUSH
78367: LD_INT 3
78369: NEG
78370: PUSH
78371: EMPTY
78372: LIST
78373: LIST
78374: PUSH
78375: LD_INT 1
78377: PUSH
78378: LD_INT 2
78380: NEG
78381: PUSH
78382: EMPTY
78383: LIST
78384: LIST
78385: PUSH
78386: LD_INT 0
78388: PUSH
78389: LD_INT 2
78391: NEG
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PUSH
78397: LD_INT 1
78399: NEG
78400: PUSH
78401: LD_INT 3
78403: NEG
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: LD_INT 1
78411: NEG
78412: PUSH
78413: LD_INT 4
78415: NEG
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: PUSH
78421: LD_INT 2
78423: PUSH
78424: LD_INT 2
78426: NEG
78427: PUSH
78428: EMPTY
78429: LIST
78430: LIST
78431: PUSH
78432: LD_INT 2
78434: NEG
78435: PUSH
78436: LD_INT 4
78438: NEG
78439: PUSH
78440: EMPTY
78441: LIST
78442: LIST
78443: PUSH
78444: LD_INT 4
78446: PUSH
78447: LD_INT 0
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: PUSH
78454: LD_INT 4
78456: PUSH
78457: LD_INT 1
78459: NEG
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 5
78467: PUSH
78468: LD_INT 0
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: PUSH
78475: LD_INT 5
78477: PUSH
78478: LD_INT 1
78480: PUSH
78481: EMPTY
78482: LIST
78483: LIST
78484: PUSH
78485: LD_INT 4
78487: PUSH
78488: LD_INT 1
78490: PUSH
78491: EMPTY
78492: LIST
78493: LIST
78494: PUSH
78495: LD_INT 3
78497: PUSH
78498: LD_INT 0
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 3
78507: PUSH
78508: LD_INT 1
78510: NEG
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 3
78518: PUSH
78519: LD_INT 2
78521: NEG
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PUSH
78527: LD_INT 5
78529: PUSH
78530: LD_INT 2
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: EMPTY
78538: LIST
78539: LIST
78540: LIST
78541: LIST
78542: LIST
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: LIST
78552: LIST
78553: LIST
78554: LIST
78555: LIST
78556: LIST
78557: LIST
78558: LIST
78559: LIST
78560: LIST
78561: LIST
78562: LIST
78563: LIST
78564: LIST
78565: LIST
78566: LIST
78567: LIST
78568: LIST
78569: LIST
78570: LIST
78571: LIST
78572: LIST
78573: LIST
78574: LIST
78575: LIST
78576: LIST
78577: LIST
78578: LIST
78579: LIST
78580: LIST
78581: LIST
78582: LIST
78583: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78584: LD_ADDR_VAR 0 32
78588: PUSH
78589: LD_INT 4
78591: NEG
78592: PUSH
78593: LD_INT 0
78595: PUSH
78596: EMPTY
78597: LIST
78598: LIST
78599: PUSH
78600: LD_INT 4
78602: NEG
78603: PUSH
78604: LD_INT 1
78606: NEG
78607: PUSH
78608: EMPTY
78609: LIST
78610: LIST
78611: PUSH
78612: LD_INT 3
78614: NEG
78615: PUSH
78616: LD_INT 0
78618: PUSH
78619: EMPTY
78620: LIST
78621: LIST
78622: PUSH
78623: LD_INT 3
78625: NEG
78626: PUSH
78627: LD_INT 1
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: PUSH
78634: LD_INT 4
78636: NEG
78637: PUSH
78638: LD_INT 1
78640: PUSH
78641: EMPTY
78642: LIST
78643: LIST
78644: PUSH
78645: LD_INT 5
78647: NEG
78648: PUSH
78649: LD_INT 0
78651: PUSH
78652: EMPTY
78653: LIST
78654: LIST
78655: PUSH
78656: LD_INT 5
78658: NEG
78659: PUSH
78660: LD_INT 1
78662: NEG
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: PUSH
78668: LD_INT 5
78670: NEG
78671: PUSH
78672: LD_INT 2
78674: NEG
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: PUSH
78680: LD_INT 3
78682: NEG
78683: PUSH
78684: LD_INT 2
78686: PUSH
78687: EMPTY
78688: LIST
78689: LIST
78690: PUSH
78691: LD_INT 3
78693: NEG
78694: PUSH
78695: LD_INT 3
78697: NEG
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: PUSH
78703: LD_INT 3
78705: NEG
78706: PUSH
78707: LD_INT 4
78709: NEG
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 2
78717: NEG
78718: PUSH
78719: LD_INT 3
78721: NEG
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: PUSH
78727: LD_INT 2
78729: NEG
78730: PUSH
78731: LD_INT 2
78733: NEG
78734: PUSH
78735: EMPTY
78736: LIST
78737: LIST
78738: PUSH
78739: LD_INT 3
78741: NEG
78742: PUSH
78743: LD_INT 2
78745: NEG
78746: PUSH
78747: EMPTY
78748: LIST
78749: LIST
78750: PUSH
78751: LD_INT 4
78753: NEG
78754: PUSH
78755: LD_INT 3
78757: NEG
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: PUSH
78763: LD_INT 4
78765: NEG
78766: PUSH
78767: LD_INT 4
78769: NEG
78770: PUSH
78771: EMPTY
78772: LIST
78773: LIST
78774: PUSH
78775: LD_INT 2
78777: NEG
78778: PUSH
78779: LD_INT 4
78781: NEG
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 4
78789: NEG
78790: PUSH
78791: LD_INT 2
78793: NEG
78794: PUSH
78795: EMPTY
78796: LIST
78797: LIST
78798: PUSH
78799: LD_INT 0
78801: PUSH
78802: LD_INT 4
78804: NEG
78805: PUSH
78806: EMPTY
78807: LIST
78808: LIST
78809: PUSH
78810: LD_INT 0
78812: PUSH
78813: LD_INT 5
78815: NEG
78816: PUSH
78817: EMPTY
78818: LIST
78819: LIST
78820: PUSH
78821: LD_INT 1
78823: PUSH
78824: LD_INT 4
78826: NEG
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PUSH
78832: LD_INT 1
78834: PUSH
78835: LD_INT 3
78837: NEG
78838: PUSH
78839: EMPTY
78840: LIST
78841: LIST
78842: PUSH
78843: LD_INT 0
78845: PUSH
78846: LD_INT 3
78848: NEG
78849: PUSH
78850: EMPTY
78851: LIST
78852: LIST
78853: PUSH
78854: LD_INT 1
78856: NEG
78857: PUSH
78858: LD_INT 4
78860: NEG
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: PUSH
78866: LD_INT 1
78868: NEG
78869: PUSH
78870: LD_INT 5
78872: NEG
78873: PUSH
78874: EMPTY
78875: LIST
78876: LIST
78877: PUSH
78878: LD_INT 2
78880: PUSH
78881: LD_INT 3
78883: NEG
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 2
78891: NEG
78892: PUSH
78893: LD_INT 5
78895: NEG
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PUSH
78901: LD_INT 3
78903: PUSH
78904: LD_INT 0
78906: PUSH
78907: EMPTY
78908: LIST
78909: LIST
78910: PUSH
78911: LD_INT 3
78913: PUSH
78914: LD_INT 1
78916: NEG
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 4
78924: PUSH
78925: LD_INT 0
78927: PUSH
78928: EMPTY
78929: LIST
78930: LIST
78931: PUSH
78932: LD_INT 4
78934: PUSH
78935: LD_INT 1
78937: PUSH
78938: EMPTY
78939: LIST
78940: LIST
78941: PUSH
78942: LD_INT 3
78944: PUSH
78945: LD_INT 1
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: PUSH
78952: LD_INT 2
78954: PUSH
78955: LD_INT 0
78957: PUSH
78958: EMPTY
78959: LIST
78960: LIST
78961: PUSH
78962: LD_INT 2
78964: PUSH
78965: LD_INT 1
78967: NEG
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: LD_INT 2
78975: PUSH
78976: LD_INT 2
78978: NEG
78979: PUSH
78980: EMPTY
78981: LIST
78982: LIST
78983: PUSH
78984: LD_INT 4
78986: PUSH
78987: LD_INT 2
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 4
78996: PUSH
78997: LD_INT 4
78999: PUSH
79000: EMPTY
79001: LIST
79002: LIST
79003: PUSH
79004: LD_INT 4
79006: PUSH
79007: LD_INT 3
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: LD_INT 5
79016: PUSH
79017: LD_INT 4
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: PUSH
79024: LD_INT 5
79026: PUSH
79027: LD_INT 5
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: PUSH
79034: LD_INT 4
79036: PUSH
79037: LD_INT 5
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 3
79046: PUSH
79047: LD_INT 4
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 3
79056: PUSH
79057: LD_INT 3
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 5
79066: PUSH
79067: LD_INT 3
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 3
79076: PUSH
79077: LD_INT 5
79079: PUSH
79080: EMPTY
79081: LIST
79082: LIST
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: LIST
79092: LIST
79093: LIST
79094: LIST
79095: LIST
79096: LIST
79097: LIST
79098: LIST
79099: LIST
79100: LIST
79101: LIST
79102: LIST
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: LIST
79108: LIST
79109: LIST
79110: LIST
79111: LIST
79112: LIST
79113: LIST
79114: LIST
79115: LIST
79116: LIST
79117: LIST
79118: LIST
79119: LIST
79120: LIST
79121: LIST
79122: LIST
79123: LIST
79124: LIST
79125: LIST
79126: LIST
79127: LIST
79128: LIST
79129: LIST
79130: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79131: LD_ADDR_VAR 0 33
79135: PUSH
79136: LD_INT 4
79138: NEG
79139: PUSH
79140: LD_INT 4
79142: NEG
79143: PUSH
79144: EMPTY
79145: LIST
79146: LIST
79147: PUSH
79148: LD_INT 4
79150: NEG
79151: PUSH
79152: LD_INT 5
79154: NEG
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 3
79162: NEG
79163: PUSH
79164: LD_INT 4
79166: NEG
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: PUSH
79172: LD_INT 3
79174: NEG
79175: PUSH
79176: LD_INT 3
79178: NEG
79179: PUSH
79180: EMPTY
79181: LIST
79182: LIST
79183: PUSH
79184: LD_INT 4
79186: NEG
79187: PUSH
79188: LD_INT 3
79190: NEG
79191: PUSH
79192: EMPTY
79193: LIST
79194: LIST
79195: PUSH
79196: LD_INT 5
79198: NEG
79199: PUSH
79200: LD_INT 4
79202: NEG
79203: PUSH
79204: EMPTY
79205: LIST
79206: LIST
79207: PUSH
79208: LD_INT 5
79210: NEG
79211: PUSH
79212: LD_INT 5
79214: NEG
79215: PUSH
79216: EMPTY
79217: LIST
79218: LIST
79219: PUSH
79220: LD_INT 3
79222: NEG
79223: PUSH
79224: LD_INT 5
79226: NEG
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 5
79234: NEG
79235: PUSH
79236: LD_INT 3
79238: NEG
79239: PUSH
79240: EMPTY
79241: LIST
79242: LIST
79243: PUSH
79244: LD_INT 0
79246: PUSH
79247: LD_INT 3
79249: NEG
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: LD_INT 0
79257: PUSH
79258: LD_INT 4
79260: NEG
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 1
79268: PUSH
79269: LD_INT 3
79271: NEG
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: LD_INT 1
79279: PUSH
79280: LD_INT 2
79282: NEG
79283: PUSH
79284: EMPTY
79285: LIST
79286: LIST
79287: PUSH
79288: LD_INT 0
79290: PUSH
79291: LD_INT 2
79293: NEG
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: LD_INT 1
79301: NEG
79302: PUSH
79303: LD_INT 3
79305: NEG
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PUSH
79311: LD_INT 1
79313: NEG
79314: PUSH
79315: LD_INT 4
79317: NEG
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: PUSH
79323: LD_INT 2
79325: PUSH
79326: LD_INT 2
79328: NEG
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 2
79336: NEG
79337: PUSH
79338: LD_INT 4
79340: NEG
79341: PUSH
79342: EMPTY
79343: LIST
79344: LIST
79345: PUSH
79346: LD_INT 4
79348: PUSH
79349: LD_INT 0
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 4
79358: PUSH
79359: LD_INT 1
79361: NEG
79362: PUSH
79363: EMPTY
79364: LIST
79365: LIST
79366: PUSH
79367: LD_INT 5
79369: PUSH
79370: LD_INT 0
79372: PUSH
79373: EMPTY
79374: LIST
79375: LIST
79376: PUSH
79377: LD_INT 5
79379: PUSH
79380: LD_INT 1
79382: PUSH
79383: EMPTY
79384: LIST
79385: LIST
79386: PUSH
79387: LD_INT 4
79389: PUSH
79390: LD_INT 1
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: PUSH
79397: LD_INT 3
79399: PUSH
79400: LD_INT 0
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: PUSH
79407: LD_INT 3
79409: PUSH
79410: LD_INT 1
79412: NEG
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: LD_INT 3
79420: PUSH
79421: LD_INT 2
79423: NEG
79424: PUSH
79425: EMPTY
79426: LIST
79427: LIST
79428: PUSH
79429: LD_INT 5
79431: PUSH
79432: LD_INT 2
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PUSH
79439: LD_INT 3
79441: PUSH
79442: LD_INT 3
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: PUSH
79449: LD_INT 3
79451: PUSH
79452: LD_INT 2
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 4
79461: PUSH
79462: LD_INT 3
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: PUSH
79469: LD_INT 4
79471: PUSH
79472: LD_INT 4
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 3
79481: PUSH
79482: LD_INT 4
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: PUSH
79489: LD_INT 2
79491: PUSH
79492: LD_INT 3
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 2
79501: PUSH
79502: LD_INT 2
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: PUSH
79509: LD_INT 4
79511: PUSH
79512: LD_INT 2
79514: PUSH
79515: EMPTY
79516: LIST
79517: LIST
79518: PUSH
79519: LD_INT 2
79521: PUSH
79522: LD_INT 4
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: LD_INT 0
79531: PUSH
79532: LD_INT 4
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: LD_INT 0
79541: PUSH
79542: LD_INT 3
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 1
79551: PUSH
79552: LD_INT 4
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: PUSH
79559: LD_INT 1
79561: PUSH
79562: LD_INT 5
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 0
79571: PUSH
79572: LD_INT 5
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: PUSH
79579: LD_INT 1
79581: NEG
79582: PUSH
79583: LD_INT 4
79585: PUSH
79586: EMPTY
79587: LIST
79588: LIST
79589: PUSH
79590: LD_INT 1
79592: NEG
79593: PUSH
79594: LD_INT 3
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: PUSH
79601: LD_INT 2
79603: PUSH
79604: LD_INT 5
79606: PUSH
79607: EMPTY
79608: LIST
79609: LIST
79610: PUSH
79611: LD_INT 2
79613: NEG
79614: PUSH
79615: LD_INT 3
79617: PUSH
79618: EMPTY
79619: LIST
79620: LIST
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: LIST
79626: LIST
79627: LIST
79628: LIST
79629: LIST
79630: LIST
79631: LIST
79632: LIST
79633: LIST
79634: LIST
79635: LIST
79636: LIST
79637: LIST
79638: LIST
79639: LIST
79640: LIST
79641: LIST
79642: LIST
79643: LIST
79644: LIST
79645: LIST
79646: LIST
79647: LIST
79648: LIST
79649: LIST
79650: LIST
79651: LIST
79652: LIST
79653: LIST
79654: LIST
79655: LIST
79656: LIST
79657: LIST
79658: LIST
79659: LIST
79660: LIST
79661: LIST
79662: LIST
79663: LIST
79664: LIST
79665: LIST
79666: LIST
79667: LIST
79668: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79669: LD_ADDR_VAR 0 34
79673: PUSH
79674: LD_INT 0
79676: PUSH
79677: LD_INT 4
79679: NEG
79680: PUSH
79681: EMPTY
79682: LIST
79683: LIST
79684: PUSH
79685: LD_INT 0
79687: PUSH
79688: LD_INT 5
79690: NEG
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: LD_INT 1
79698: PUSH
79699: LD_INT 4
79701: NEG
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: PUSH
79707: LD_INT 1
79709: PUSH
79710: LD_INT 3
79712: NEG
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 0
79720: PUSH
79721: LD_INT 3
79723: NEG
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 1
79731: NEG
79732: PUSH
79733: LD_INT 4
79735: NEG
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PUSH
79741: LD_INT 1
79743: NEG
79744: PUSH
79745: LD_INT 5
79747: NEG
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: LD_INT 2
79755: PUSH
79756: LD_INT 3
79758: NEG
79759: PUSH
79760: EMPTY
79761: LIST
79762: LIST
79763: PUSH
79764: LD_INT 2
79766: NEG
79767: PUSH
79768: LD_INT 5
79770: NEG
79771: PUSH
79772: EMPTY
79773: LIST
79774: LIST
79775: PUSH
79776: LD_INT 3
79778: PUSH
79779: LD_INT 0
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PUSH
79786: LD_INT 3
79788: PUSH
79789: LD_INT 1
79791: NEG
79792: PUSH
79793: EMPTY
79794: LIST
79795: LIST
79796: PUSH
79797: LD_INT 4
79799: PUSH
79800: LD_INT 0
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: PUSH
79807: LD_INT 4
79809: PUSH
79810: LD_INT 1
79812: PUSH
79813: EMPTY
79814: LIST
79815: LIST
79816: PUSH
79817: LD_INT 3
79819: PUSH
79820: LD_INT 1
79822: PUSH
79823: EMPTY
79824: LIST
79825: LIST
79826: PUSH
79827: LD_INT 2
79829: PUSH
79830: LD_INT 0
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: LD_INT 2
79839: PUSH
79840: LD_INT 1
79842: NEG
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: PUSH
79848: LD_INT 2
79850: PUSH
79851: LD_INT 2
79853: NEG
79854: PUSH
79855: EMPTY
79856: LIST
79857: LIST
79858: PUSH
79859: LD_INT 4
79861: PUSH
79862: LD_INT 2
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 4
79871: PUSH
79872: LD_INT 4
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 4
79881: PUSH
79882: LD_INT 3
79884: PUSH
79885: EMPTY
79886: LIST
79887: LIST
79888: PUSH
79889: LD_INT 5
79891: PUSH
79892: LD_INT 4
79894: PUSH
79895: EMPTY
79896: LIST
79897: LIST
79898: PUSH
79899: LD_INT 5
79901: PUSH
79902: LD_INT 5
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: PUSH
79909: LD_INT 4
79911: PUSH
79912: LD_INT 5
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: PUSH
79919: LD_INT 3
79921: PUSH
79922: LD_INT 4
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: LD_INT 3
79931: PUSH
79932: LD_INT 3
79934: PUSH
79935: EMPTY
79936: LIST
79937: LIST
79938: PUSH
79939: LD_INT 5
79941: PUSH
79942: LD_INT 3
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 3
79951: PUSH
79952: LD_INT 5
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: LD_INT 0
79961: PUSH
79962: LD_INT 3
79964: PUSH
79965: EMPTY
79966: LIST
79967: LIST
79968: PUSH
79969: LD_INT 0
79971: PUSH
79972: LD_INT 2
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 1
79981: PUSH
79982: LD_INT 3
79984: PUSH
79985: EMPTY
79986: LIST
79987: LIST
79988: PUSH
79989: LD_INT 1
79991: PUSH
79992: LD_INT 4
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: PUSH
79999: LD_INT 0
80001: PUSH
80002: LD_INT 4
80004: PUSH
80005: EMPTY
80006: LIST
80007: LIST
80008: PUSH
80009: LD_INT 1
80011: NEG
80012: PUSH
80013: LD_INT 3
80015: PUSH
80016: EMPTY
80017: LIST
80018: LIST
80019: PUSH
80020: LD_INT 1
80022: NEG
80023: PUSH
80024: LD_INT 2
80026: PUSH
80027: EMPTY
80028: LIST
80029: LIST
80030: PUSH
80031: LD_INT 2
80033: PUSH
80034: LD_INT 4
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: PUSH
80041: LD_INT 2
80043: NEG
80044: PUSH
80045: LD_INT 2
80047: PUSH
80048: EMPTY
80049: LIST
80050: LIST
80051: PUSH
80052: LD_INT 4
80054: NEG
80055: PUSH
80056: LD_INT 0
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 4
80065: NEG
80066: PUSH
80067: LD_INT 1
80069: NEG
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: LD_INT 3
80077: NEG
80078: PUSH
80079: LD_INT 0
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: PUSH
80086: LD_INT 3
80088: NEG
80089: PUSH
80090: LD_INT 1
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 4
80099: NEG
80100: PUSH
80101: LD_INT 1
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 5
80110: NEG
80111: PUSH
80112: LD_INT 0
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: LD_INT 5
80121: NEG
80122: PUSH
80123: LD_INT 1
80125: NEG
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 5
80133: NEG
80134: PUSH
80135: LD_INT 2
80137: NEG
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: LD_INT 3
80145: NEG
80146: PUSH
80147: LD_INT 2
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: LIST
80158: LIST
80159: LIST
80160: LIST
80161: LIST
80162: LIST
80163: LIST
80164: LIST
80165: LIST
80166: LIST
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: LIST
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: LIST
80183: LIST
80184: LIST
80185: LIST
80186: LIST
80187: LIST
80188: LIST
80189: LIST
80190: LIST
80191: LIST
80192: LIST
80193: LIST
80194: LIST
80195: LIST
80196: LIST
80197: LIST
80198: LIST
80199: LIST
80200: ST_TO_ADDR
// end ; end ;
80201: GO 80204
80203: POP
// case btype of b_depot , b_warehouse :
80204: LD_VAR 0 1
80208: PUSH
80209: LD_INT 0
80211: DOUBLE
80212: EQUAL
80213: IFTRUE 80223
80215: LD_INT 1
80217: DOUBLE
80218: EQUAL
80219: IFTRUE 80223
80221: GO 80424
80223: POP
// case nation of nation_american :
80224: LD_VAR 0 5
80228: PUSH
80229: LD_INT 1
80231: DOUBLE
80232: EQUAL
80233: IFTRUE 80237
80235: GO 80293
80237: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80238: LD_ADDR_VAR 0 9
80242: PUSH
80243: LD_VAR 0 11
80247: PUSH
80248: LD_VAR 0 12
80252: PUSH
80253: LD_VAR 0 13
80257: PUSH
80258: LD_VAR 0 14
80262: PUSH
80263: LD_VAR 0 15
80267: PUSH
80268: LD_VAR 0 16
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: LIST
80277: LIST
80278: LIST
80279: LIST
80280: PUSH
80281: LD_VAR 0 4
80285: PUSH
80286: LD_INT 1
80288: PLUS
80289: ARRAY
80290: ST_TO_ADDR
80291: GO 80422
80293: LD_INT 2
80295: DOUBLE
80296: EQUAL
80297: IFTRUE 80301
80299: GO 80357
80301: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80302: LD_ADDR_VAR 0 9
80306: PUSH
80307: LD_VAR 0 17
80311: PUSH
80312: LD_VAR 0 18
80316: PUSH
80317: LD_VAR 0 19
80321: PUSH
80322: LD_VAR 0 20
80326: PUSH
80327: LD_VAR 0 21
80331: PUSH
80332: LD_VAR 0 22
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: LIST
80341: LIST
80342: LIST
80343: LIST
80344: PUSH
80345: LD_VAR 0 4
80349: PUSH
80350: LD_INT 1
80352: PLUS
80353: ARRAY
80354: ST_TO_ADDR
80355: GO 80422
80357: LD_INT 3
80359: DOUBLE
80360: EQUAL
80361: IFTRUE 80365
80363: GO 80421
80365: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80366: LD_ADDR_VAR 0 9
80370: PUSH
80371: LD_VAR 0 23
80375: PUSH
80376: LD_VAR 0 24
80380: PUSH
80381: LD_VAR 0 25
80385: PUSH
80386: LD_VAR 0 26
80390: PUSH
80391: LD_VAR 0 27
80395: PUSH
80396: LD_VAR 0 28
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: LIST
80405: LIST
80406: LIST
80407: LIST
80408: PUSH
80409: LD_VAR 0 4
80413: PUSH
80414: LD_INT 1
80416: PLUS
80417: ARRAY
80418: ST_TO_ADDR
80419: GO 80422
80421: POP
80422: GO 80977
80424: LD_INT 2
80426: DOUBLE
80427: EQUAL
80428: IFTRUE 80438
80430: LD_INT 3
80432: DOUBLE
80433: EQUAL
80434: IFTRUE 80438
80436: GO 80494
80438: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80439: LD_ADDR_VAR 0 9
80443: PUSH
80444: LD_VAR 0 29
80448: PUSH
80449: LD_VAR 0 30
80453: PUSH
80454: LD_VAR 0 31
80458: PUSH
80459: LD_VAR 0 32
80463: PUSH
80464: LD_VAR 0 33
80468: PUSH
80469: LD_VAR 0 34
80473: PUSH
80474: EMPTY
80475: LIST
80476: LIST
80477: LIST
80478: LIST
80479: LIST
80480: LIST
80481: PUSH
80482: LD_VAR 0 4
80486: PUSH
80487: LD_INT 1
80489: PLUS
80490: ARRAY
80491: ST_TO_ADDR
80492: GO 80977
80494: LD_INT 16
80496: DOUBLE
80497: EQUAL
80498: IFTRUE 80556
80500: LD_INT 17
80502: DOUBLE
80503: EQUAL
80504: IFTRUE 80556
80506: LD_INT 18
80508: DOUBLE
80509: EQUAL
80510: IFTRUE 80556
80512: LD_INT 19
80514: DOUBLE
80515: EQUAL
80516: IFTRUE 80556
80518: LD_INT 22
80520: DOUBLE
80521: EQUAL
80522: IFTRUE 80556
80524: LD_INT 20
80526: DOUBLE
80527: EQUAL
80528: IFTRUE 80556
80530: LD_INT 21
80532: DOUBLE
80533: EQUAL
80534: IFTRUE 80556
80536: LD_INT 23
80538: DOUBLE
80539: EQUAL
80540: IFTRUE 80556
80542: LD_INT 24
80544: DOUBLE
80545: EQUAL
80546: IFTRUE 80556
80548: LD_INT 25
80550: DOUBLE
80551: EQUAL
80552: IFTRUE 80556
80554: GO 80612
80556: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80557: LD_ADDR_VAR 0 9
80561: PUSH
80562: LD_VAR 0 35
80566: PUSH
80567: LD_VAR 0 36
80571: PUSH
80572: LD_VAR 0 37
80576: PUSH
80577: LD_VAR 0 38
80581: PUSH
80582: LD_VAR 0 39
80586: PUSH
80587: LD_VAR 0 40
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: PUSH
80600: LD_VAR 0 4
80604: PUSH
80605: LD_INT 1
80607: PLUS
80608: ARRAY
80609: ST_TO_ADDR
80610: GO 80977
80612: LD_INT 6
80614: DOUBLE
80615: EQUAL
80616: IFTRUE 80668
80618: LD_INT 7
80620: DOUBLE
80621: EQUAL
80622: IFTRUE 80668
80624: LD_INT 8
80626: DOUBLE
80627: EQUAL
80628: IFTRUE 80668
80630: LD_INT 13
80632: DOUBLE
80633: EQUAL
80634: IFTRUE 80668
80636: LD_INT 12
80638: DOUBLE
80639: EQUAL
80640: IFTRUE 80668
80642: LD_INT 15
80644: DOUBLE
80645: EQUAL
80646: IFTRUE 80668
80648: LD_INT 11
80650: DOUBLE
80651: EQUAL
80652: IFTRUE 80668
80654: LD_INT 14
80656: DOUBLE
80657: EQUAL
80658: IFTRUE 80668
80660: LD_INT 10
80662: DOUBLE
80663: EQUAL
80664: IFTRUE 80668
80666: GO 80724
80668: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80669: LD_ADDR_VAR 0 9
80673: PUSH
80674: LD_VAR 0 41
80678: PUSH
80679: LD_VAR 0 42
80683: PUSH
80684: LD_VAR 0 43
80688: PUSH
80689: LD_VAR 0 44
80693: PUSH
80694: LD_VAR 0 45
80698: PUSH
80699: LD_VAR 0 46
80703: PUSH
80704: EMPTY
80705: LIST
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: PUSH
80712: LD_VAR 0 4
80716: PUSH
80717: LD_INT 1
80719: PLUS
80720: ARRAY
80721: ST_TO_ADDR
80722: GO 80977
80724: LD_INT 36
80726: DOUBLE
80727: EQUAL
80728: IFTRUE 80732
80730: GO 80788
80732: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80733: LD_ADDR_VAR 0 9
80737: PUSH
80738: LD_VAR 0 47
80742: PUSH
80743: LD_VAR 0 48
80747: PUSH
80748: LD_VAR 0 49
80752: PUSH
80753: LD_VAR 0 50
80757: PUSH
80758: LD_VAR 0 51
80762: PUSH
80763: LD_VAR 0 52
80767: PUSH
80768: EMPTY
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: LIST
80775: PUSH
80776: LD_VAR 0 4
80780: PUSH
80781: LD_INT 1
80783: PLUS
80784: ARRAY
80785: ST_TO_ADDR
80786: GO 80977
80788: LD_INT 4
80790: DOUBLE
80791: EQUAL
80792: IFTRUE 80814
80794: LD_INT 5
80796: DOUBLE
80797: EQUAL
80798: IFTRUE 80814
80800: LD_INT 34
80802: DOUBLE
80803: EQUAL
80804: IFTRUE 80814
80806: LD_INT 37
80808: DOUBLE
80809: EQUAL
80810: IFTRUE 80814
80812: GO 80870
80814: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
80815: LD_ADDR_VAR 0 9
80819: PUSH
80820: LD_VAR 0 53
80824: PUSH
80825: LD_VAR 0 54
80829: PUSH
80830: LD_VAR 0 55
80834: PUSH
80835: LD_VAR 0 56
80839: PUSH
80840: LD_VAR 0 57
80844: PUSH
80845: LD_VAR 0 58
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: LIST
80854: LIST
80855: LIST
80856: LIST
80857: PUSH
80858: LD_VAR 0 4
80862: PUSH
80863: LD_INT 1
80865: PLUS
80866: ARRAY
80867: ST_TO_ADDR
80868: GO 80977
80870: LD_INT 31
80872: DOUBLE
80873: EQUAL
80874: IFTRUE 80920
80876: LD_INT 32
80878: DOUBLE
80879: EQUAL
80880: IFTRUE 80920
80882: LD_INT 33
80884: DOUBLE
80885: EQUAL
80886: IFTRUE 80920
80888: LD_INT 27
80890: DOUBLE
80891: EQUAL
80892: IFTRUE 80920
80894: LD_INT 26
80896: DOUBLE
80897: EQUAL
80898: IFTRUE 80920
80900: LD_INT 28
80902: DOUBLE
80903: EQUAL
80904: IFTRUE 80920
80906: LD_INT 29
80908: DOUBLE
80909: EQUAL
80910: IFTRUE 80920
80912: LD_INT 30
80914: DOUBLE
80915: EQUAL
80916: IFTRUE 80920
80918: GO 80976
80920: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
80921: LD_ADDR_VAR 0 9
80925: PUSH
80926: LD_VAR 0 59
80930: PUSH
80931: LD_VAR 0 60
80935: PUSH
80936: LD_VAR 0 61
80940: PUSH
80941: LD_VAR 0 62
80945: PUSH
80946: LD_VAR 0 63
80950: PUSH
80951: LD_VAR 0 64
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: LIST
80960: LIST
80961: LIST
80962: LIST
80963: PUSH
80964: LD_VAR 0 4
80968: PUSH
80969: LD_INT 1
80971: PLUS
80972: ARRAY
80973: ST_TO_ADDR
80974: GO 80977
80976: POP
// temp_list2 = [ ] ;
80977: LD_ADDR_VAR 0 10
80981: PUSH
80982: EMPTY
80983: ST_TO_ADDR
// for i in temp_list do
80984: LD_ADDR_VAR 0 8
80988: PUSH
80989: LD_VAR 0 9
80993: PUSH
80994: FOR_IN
80995: IFFALSE 81047
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
80997: LD_ADDR_VAR 0 10
81001: PUSH
81002: LD_VAR 0 10
81006: PUSH
81007: LD_VAR 0 8
81011: PUSH
81012: LD_INT 1
81014: ARRAY
81015: PUSH
81016: LD_VAR 0 2
81020: PLUS
81021: PUSH
81022: LD_VAR 0 8
81026: PUSH
81027: LD_INT 2
81029: ARRAY
81030: PUSH
81031: LD_VAR 0 3
81035: PLUS
81036: PUSH
81037: EMPTY
81038: LIST
81039: LIST
81040: PUSH
81041: EMPTY
81042: LIST
81043: ADD
81044: ST_TO_ADDR
81045: GO 80994
81047: POP
81048: POP
// result = temp_list2 ;
81049: LD_ADDR_VAR 0 7
81053: PUSH
81054: LD_VAR 0 10
81058: ST_TO_ADDR
// end ;
81059: LD_VAR 0 7
81063: RET
// export function EnemyInRange ( unit , dist ) ; begin
81064: LD_INT 0
81066: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81067: LD_ADDR_VAR 0 3
81071: PUSH
81072: LD_VAR 0 1
81076: PPUSH
81077: CALL_OW 255
81081: PPUSH
81082: LD_VAR 0 1
81086: PPUSH
81087: CALL_OW 250
81091: PPUSH
81092: LD_VAR 0 1
81096: PPUSH
81097: CALL_OW 251
81101: PPUSH
81102: LD_VAR 0 2
81106: PPUSH
81107: CALL 54460 0 4
81111: PUSH
81112: LD_INT 4
81114: ARRAY
81115: ST_TO_ADDR
// end ;
81116: LD_VAR 0 3
81120: RET
// export function PlayerSeeMe ( unit ) ; begin
81121: LD_INT 0
81123: PPUSH
// result := See ( your_side , unit ) ;
81124: LD_ADDR_VAR 0 2
81128: PUSH
81129: LD_OWVAR 2
81133: PPUSH
81134: LD_VAR 0 1
81138: PPUSH
81139: CALL_OW 292
81143: ST_TO_ADDR
// end ;
81144: LD_VAR 0 2
81148: RET
// export function ReverseDir ( unit ) ; begin
81149: LD_INT 0
81151: PPUSH
// if not unit then
81152: LD_VAR 0 1
81156: NOT
81157: IFFALSE 81161
// exit ;
81159: GO 81184
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81161: LD_ADDR_VAR 0 2
81165: PUSH
81166: LD_VAR 0 1
81170: PPUSH
81171: CALL_OW 254
81175: PUSH
81176: LD_INT 3
81178: PLUS
81179: PUSH
81180: LD_INT 6
81182: MOD
81183: ST_TO_ADDR
// end ;
81184: LD_VAR 0 2
81188: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
81189: LD_INT 0
81191: PPUSH
81192: PPUSH
81193: PPUSH
81194: PPUSH
81195: PPUSH
// if not hexes then
81196: LD_VAR 0 2
81200: NOT
81201: IFFALSE 81205
// exit ;
81203: GO 81353
// dist := 9999 ;
81205: LD_ADDR_VAR 0 5
81209: PUSH
81210: LD_INT 9999
81212: ST_TO_ADDR
// for i = 1 to hexes do
81213: LD_ADDR_VAR 0 4
81217: PUSH
81218: DOUBLE
81219: LD_INT 1
81221: DEC
81222: ST_TO_ADDR
81223: LD_VAR 0 2
81227: PUSH
81228: FOR_TO
81229: IFFALSE 81341
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
81231: LD_VAR 0 1
81235: PPUSH
81236: LD_VAR 0 2
81240: PUSH
81241: LD_VAR 0 4
81245: ARRAY
81246: PUSH
81247: LD_INT 1
81249: ARRAY
81250: PPUSH
81251: LD_VAR 0 2
81255: PUSH
81256: LD_VAR 0 4
81260: ARRAY
81261: PUSH
81262: LD_INT 2
81264: ARRAY
81265: PPUSH
81266: CALL_OW 297
81270: PUSH
81271: LD_VAR 0 5
81275: LESS
81276: IFFALSE 81339
// begin hex := hexes [ i ] ;
81278: LD_ADDR_VAR 0 7
81282: PUSH
81283: LD_VAR 0 2
81287: PUSH
81288: LD_VAR 0 4
81292: ARRAY
81293: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81294: LD_ADDR_VAR 0 5
81298: PUSH
81299: LD_VAR 0 1
81303: PPUSH
81304: LD_VAR 0 2
81308: PUSH
81309: LD_VAR 0 4
81313: ARRAY
81314: PUSH
81315: LD_INT 1
81317: ARRAY
81318: PPUSH
81319: LD_VAR 0 2
81323: PUSH
81324: LD_VAR 0 4
81328: ARRAY
81329: PUSH
81330: LD_INT 2
81332: ARRAY
81333: PPUSH
81334: CALL_OW 297
81338: ST_TO_ADDR
// end ; end ;
81339: GO 81228
81341: POP
81342: POP
// result := hex ;
81343: LD_ADDR_VAR 0 3
81347: PUSH
81348: LD_VAR 0 7
81352: ST_TO_ADDR
// end ;
81353: LD_VAR 0 3
81357: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81358: LD_INT 0
81360: PPUSH
81361: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81362: LD_VAR 0 1
81366: NOT
81367: PUSH
81368: LD_VAR 0 1
81372: PUSH
81373: LD_INT 21
81375: PUSH
81376: LD_INT 2
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: LD_INT 23
81385: PUSH
81386: LD_INT 2
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PPUSH
81397: CALL_OW 69
81401: IN
81402: NOT
81403: OR
81404: IFFALSE 81408
// exit ;
81406: GO 81455
// for i = 1 to 3 do
81408: LD_ADDR_VAR 0 3
81412: PUSH
81413: DOUBLE
81414: LD_INT 1
81416: DEC
81417: ST_TO_ADDR
81418: LD_INT 3
81420: PUSH
81421: FOR_TO
81422: IFFALSE 81453
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81424: LD_VAR 0 1
81428: PPUSH
81429: CALL_OW 250
81433: PPUSH
81434: LD_VAR 0 1
81438: PPUSH
81439: CALL_OW 251
81443: PPUSH
81444: LD_INT 1
81446: PPUSH
81447: CALL_OW 453
81451: GO 81421
81453: POP
81454: POP
// end ;
81455: LD_VAR 0 2
81459: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81460: LD_INT 0
81462: PPUSH
81463: PPUSH
81464: PPUSH
81465: PPUSH
81466: PPUSH
81467: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81468: LD_VAR 0 1
81472: NOT
81473: PUSH
81474: LD_VAR 0 2
81478: NOT
81479: OR
81480: PUSH
81481: LD_VAR 0 1
81485: PPUSH
81486: CALL_OW 314
81490: OR
81491: IFFALSE 81495
// exit ;
81493: GO 81936
// x := GetX ( enemy_unit ) ;
81495: LD_ADDR_VAR 0 7
81499: PUSH
81500: LD_VAR 0 2
81504: PPUSH
81505: CALL_OW 250
81509: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81510: LD_ADDR_VAR 0 8
81514: PUSH
81515: LD_VAR 0 2
81519: PPUSH
81520: CALL_OW 251
81524: ST_TO_ADDR
// if not x or not y then
81525: LD_VAR 0 7
81529: NOT
81530: PUSH
81531: LD_VAR 0 8
81535: NOT
81536: OR
81537: IFFALSE 81541
// exit ;
81539: GO 81936
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81541: LD_ADDR_VAR 0 6
81545: PUSH
81546: LD_VAR 0 7
81550: PPUSH
81551: LD_INT 0
81553: PPUSH
81554: LD_INT 4
81556: PPUSH
81557: CALL_OW 272
81561: PUSH
81562: LD_VAR 0 8
81566: PPUSH
81567: LD_INT 0
81569: PPUSH
81570: LD_INT 4
81572: PPUSH
81573: CALL_OW 273
81577: PUSH
81578: EMPTY
81579: LIST
81580: LIST
81581: PUSH
81582: LD_VAR 0 7
81586: PPUSH
81587: LD_INT 1
81589: PPUSH
81590: LD_INT 4
81592: PPUSH
81593: CALL_OW 272
81597: PUSH
81598: LD_VAR 0 8
81602: PPUSH
81603: LD_INT 1
81605: PPUSH
81606: LD_INT 4
81608: PPUSH
81609: CALL_OW 273
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: LD_VAR 0 7
81622: PPUSH
81623: LD_INT 2
81625: PPUSH
81626: LD_INT 4
81628: PPUSH
81629: CALL_OW 272
81633: PUSH
81634: LD_VAR 0 8
81638: PPUSH
81639: LD_INT 2
81641: PPUSH
81642: LD_INT 4
81644: PPUSH
81645: CALL_OW 273
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: PUSH
81654: LD_VAR 0 7
81658: PPUSH
81659: LD_INT 3
81661: PPUSH
81662: LD_INT 4
81664: PPUSH
81665: CALL_OW 272
81669: PUSH
81670: LD_VAR 0 8
81674: PPUSH
81675: LD_INT 3
81677: PPUSH
81678: LD_INT 4
81680: PPUSH
81681: CALL_OW 273
81685: PUSH
81686: EMPTY
81687: LIST
81688: LIST
81689: PUSH
81690: LD_VAR 0 7
81694: PPUSH
81695: LD_INT 4
81697: PPUSH
81698: LD_INT 4
81700: PPUSH
81701: CALL_OW 272
81705: PUSH
81706: LD_VAR 0 8
81710: PPUSH
81711: LD_INT 4
81713: PPUSH
81714: LD_INT 4
81716: PPUSH
81717: CALL_OW 273
81721: PUSH
81722: EMPTY
81723: LIST
81724: LIST
81725: PUSH
81726: LD_VAR 0 7
81730: PPUSH
81731: LD_INT 5
81733: PPUSH
81734: LD_INT 4
81736: PPUSH
81737: CALL_OW 272
81741: PUSH
81742: LD_VAR 0 8
81746: PPUSH
81747: LD_INT 5
81749: PPUSH
81750: LD_INT 4
81752: PPUSH
81753: CALL_OW 273
81757: PUSH
81758: EMPTY
81759: LIST
81760: LIST
81761: PUSH
81762: EMPTY
81763: LIST
81764: LIST
81765: LIST
81766: LIST
81767: LIST
81768: LIST
81769: ST_TO_ADDR
// for i = tmp downto 1 do
81770: LD_ADDR_VAR 0 4
81774: PUSH
81775: DOUBLE
81776: LD_VAR 0 6
81780: INC
81781: ST_TO_ADDR
81782: LD_INT 1
81784: PUSH
81785: FOR_DOWNTO
81786: IFFALSE 81887
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
81788: LD_VAR 0 6
81792: PUSH
81793: LD_VAR 0 4
81797: ARRAY
81798: PUSH
81799: LD_INT 1
81801: ARRAY
81802: PPUSH
81803: LD_VAR 0 6
81807: PUSH
81808: LD_VAR 0 4
81812: ARRAY
81813: PUSH
81814: LD_INT 2
81816: ARRAY
81817: PPUSH
81818: CALL_OW 488
81822: NOT
81823: PUSH
81824: LD_VAR 0 6
81828: PUSH
81829: LD_VAR 0 4
81833: ARRAY
81834: PUSH
81835: LD_INT 1
81837: ARRAY
81838: PPUSH
81839: LD_VAR 0 6
81843: PUSH
81844: LD_VAR 0 4
81848: ARRAY
81849: PUSH
81850: LD_INT 2
81852: ARRAY
81853: PPUSH
81854: CALL_OW 428
81858: PUSH
81859: LD_INT 0
81861: NONEQUAL
81862: OR
81863: IFFALSE 81885
// tmp := Delete ( tmp , i ) ;
81865: LD_ADDR_VAR 0 6
81869: PUSH
81870: LD_VAR 0 6
81874: PPUSH
81875: LD_VAR 0 4
81879: PPUSH
81880: CALL_OW 3
81884: ST_TO_ADDR
81885: GO 81785
81887: POP
81888: POP
// j := GetClosestHex ( unit , tmp ) ;
81889: LD_ADDR_VAR 0 5
81893: PUSH
81894: LD_VAR 0 1
81898: PPUSH
81899: LD_VAR 0 6
81903: PPUSH
81904: CALL 81189 0 2
81908: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
81909: LD_VAR 0 1
81913: PPUSH
81914: LD_VAR 0 5
81918: PUSH
81919: LD_INT 1
81921: ARRAY
81922: PPUSH
81923: LD_VAR 0 5
81927: PUSH
81928: LD_INT 2
81930: ARRAY
81931: PPUSH
81932: CALL_OW 111
// end ;
81936: LD_VAR 0 3
81940: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
81941: LD_INT 0
81943: PPUSH
81944: PPUSH
81945: PPUSH
// uc_side = 0 ;
81946: LD_ADDR_OWVAR 20
81950: PUSH
81951: LD_INT 0
81953: ST_TO_ADDR
// uc_nation = 0 ;
81954: LD_ADDR_OWVAR 21
81958: PUSH
81959: LD_INT 0
81961: ST_TO_ADDR
// InitHc_All ( ) ;
81962: CALL_OW 584
// InitVc ;
81966: CALL_OW 20
// if mastodonts then
81970: LD_VAR 0 6
81974: IFFALSE 82041
// for i = 1 to mastodonts do
81976: LD_ADDR_VAR 0 11
81980: PUSH
81981: DOUBLE
81982: LD_INT 1
81984: DEC
81985: ST_TO_ADDR
81986: LD_VAR 0 6
81990: PUSH
81991: FOR_TO
81992: IFFALSE 82039
// begin vc_chassis := 31 ;
81994: LD_ADDR_OWVAR 37
81998: PUSH
81999: LD_INT 31
82001: ST_TO_ADDR
// vc_control := control_rider ;
82002: LD_ADDR_OWVAR 38
82006: PUSH
82007: LD_INT 4
82009: ST_TO_ADDR
// animal := CreateVehicle ;
82010: LD_ADDR_VAR 0 12
82014: PUSH
82015: CALL_OW 45
82019: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82020: LD_VAR 0 12
82024: PPUSH
82025: LD_VAR 0 8
82029: PPUSH
82030: LD_INT 0
82032: PPUSH
82033: CALL 84176 0 3
// end ;
82037: GO 81991
82039: POP
82040: POP
// if horses then
82041: LD_VAR 0 5
82045: IFFALSE 82112
// for i = 1 to horses do
82047: LD_ADDR_VAR 0 11
82051: PUSH
82052: DOUBLE
82053: LD_INT 1
82055: DEC
82056: ST_TO_ADDR
82057: LD_VAR 0 5
82061: PUSH
82062: FOR_TO
82063: IFFALSE 82110
// begin hc_class := 21 ;
82065: LD_ADDR_OWVAR 28
82069: PUSH
82070: LD_INT 21
82072: ST_TO_ADDR
// hc_gallery :=  ;
82073: LD_ADDR_OWVAR 33
82077: PUSH
82078: LD_STRING 
82080: ST_TO_ADDR
// animal := CreateHuman ;
82081: LD_ADDR_VAR 0 12
82085: PUSH
82086: CALL_OW 44
82090: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82091: LD_VAR 0 12
82095: PPUSH
82096: LD_VAR 0 8
82100: PPUSH
82101: LD_INT 0
82103: PPUSH
82104: CALL 84176 0 3
// end ;
82108: GO 82062
82110: POP
82111: POP
// if birds then
82112: LD_VAR 0 1
82116: IFFALSE 82183
// for i = 1 to birds do
82118: LD_ADDR_VAR 0 11
82122: PUSH
82123: DOUBLE
82124: LD_INT 1
82126: DEC
82127: ST_TO_ADDR
82128: LD_VAR 0 1
82132: PUSH
82133: FOR_TO
82134: IFFALSE 82181
// begin hc_class = 18 ;
82136: LD_ADDR_OWVAR 28
82140: PUSH
82141: LD_INT 18
82143: ST_TO_ADDR
// hc_gallery =  ;
82144: LD_ADDR_OWVAR 33
82148: PUSH
82149: LD_STRING 
82151: ST_TO_ADDR
// animal := CreateHuman ;
82152: LD_ADDR_VAR 0 12
82156: PUSH
82157: CALL_OW 44
82161: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82162: LD_VAR 0 12
82166: PPUSH
82167: LD_VAR 0 8
82171: PPUSH
82172: LD_INT 0
82174: PPUSH
82175: CALL 84176 0 3
// end ;
82179: GO 82133
82181: POP
82182: POP
// if tigers then
82183: LD_VAR 0 2
82187: IFFALSE 82271
// for i = 1 to tigers do
82189: LD_ADDR_VAR 0 11
82193: PUSH
82194: DOUBLE
82195: LD_INT 1
82197: DEC
82198: ST_TO_ADDR
82199: LD_VAR 0 2
82203: PUSH
82204: FOR_TO
82205: IFFALSE 82269
// begin hc_class = class_tiger ;
82207: LD_ADDR_OWVAR 28
82211: PUSH
82212: LD_INT 14
82214: ST_TO_ADDR
// hc_gallery =  ;
82215: LD_ADDR_OWVAR 33
82219: PUSH
82220: LD_STRING 
82222: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
82223: LD_ADDR_OWVAR 35
82227: PUSH
82228: LD_INT 7
82230: NEG
82231: PPUSH
82232: LD_INT 7
82234: PPUSH
82235: CALL_OW 12
82239: ST_TO_ADDR
// animal := CreateHuman ;
82240: LD_ADDR_VAR 0 12
82244: PUSH
82245: CALL_OW 44
82249: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82250: LD_VAR 0 12
82254: PPUSH
82255: LD_VAR 0 8
82259: PPUSH
82260: LD_INT 0
82262: PPUSH
82263: CALL 84176 0 3
// end ;
82267: GO 82204
82269: POP
82270: POP
// if apemans then
82271: LD_VAR 0 3
82275: IFFALSE 82398
// for i = 1 to apemans do
82277: LD_ADDR_VAR 0 11
82281: PUSH
82282: DOUBLE
82283: LD_INT 1
82285: DEC
82286: ST_TO_ADDR
82287: LD_VAR 0 3
82291: PUSH
82292: FOR_TO
82293: IFFALSE 82396
// begin hc_class = class_apeman ;
82295: LD_ADDR_OWVAR 28
82299: PUSH
82300: LD_INT 12
82302: ST_TO_ADDR
// hc_gallery =  ;
82303: LD_ADDR_OWVAR 33
82307: PUSH
82308: LD_STRING 
82310: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
82311: LD_ADDR_OWVAR 35
82315: PUSH
82316: LD_INT 2
82318: NEG
82319: PPUSH
82320: LD_INT 2
82322: PPUSH
82323: CALL_OW 12
82327: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
82328: LD_ADDR_OWVAR 31
82332: PUSH
82333: LD_INT 1
82335: PPUSH
82336: LD_INT 3
82338: PPUSH
82339: CALL_OW 12
82343: PUSH
82344: LD_INT 1
82346: PPUSH
82347: LD_INT 3
82349: PPUSH
82350: CALL_OW 12
82354: PUSH
82355: LD_INT 0
82357: PUSH
82358: LD_INT 0
82360: PUSH
82361: EMPTY
82362: LIST
82363: LIST
82364: LIST
82365: LIST
82366: ST_TO_ADDR
// animal := CreateHuman ;
82367: LD_ADDR_VAR 0 12
82371: PUSH
82372: CALL_OW 44
82376: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82377: LD_VAR 0 12
82381: PPUSH
82382: LD_VAR 0 8
82386: PPUSH
82387: LD_INT 0
82389: PPUSH
82390: CALL 84176 0 3
// end ;
82394: GO 82292
82396: POP
82397: POP
// if enchidnas then
82398: LD_VAR 0 4
82402: IFFALSE 82469
// for i = 1 to enchidnas do
82404: LD_ADDR_VAR 0 11
82408: PUSH
82409: DOUBLE
82410: LD_INT 1
82412: DEC
82413: ST_TO_ADDR
82414: LD_VAR 0 4
82418: PUSH
82419: FOR_TO
82420: IFFALSE 82467
// begin hc_class = 13 ;
82422: LD_ADDR_OWVAR 28
82426: PUSH
82427: LD_INT 13
82429: ST_TO_ADDR
// hc_gallery =  ;
82430: LD_ADDR_OWVAR 33
82434: PUSH
82435: LD_STRING 
82437: ST_TO_ADDR
// animal := CreateHuman ;
82438: LD_ADDR_VAR 0 12
82442: PUSH
82443: CALL_OW 44
82447: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82448: LD_VAR 0 12
82452: PPUSH
82453: LD_VAR 0 8
82457: PPUSH
82458: LD_INT 0
82460: PPUSH
82461: CALL 84176 0 3
// end ;
82465: GO 82419
82467: POP
82468: POP
// if fishes then
82469: LD_VAR 0 7
82473: IFFALSE 82540
// for i = 1 to fishes do
82475: LD_ADDR_VAR 0 11
82479: PUSH
82480: DOUBLE
82481: LD_INT 1
82483: DEC
82484: ST_TO_ADDR
82485: LD_VAR 0 7
82489: PUSH
82490: FOR_TO
82491: IFFALSE 82538
// begin hc_class = 20 ;
82493: LD_ADDR_OWVAR 28
82497: PUSH
82498: LD_INT 20
82500: ST_TO_ADDR
// hc_gallery =  ;
82501: LD_ADDR_OWVAR 33
82505: PUSH
82506: LD_STRING 
82508: ST_TO_ADDR
// animal := CreateHuman ;
82509: LD_ADDR_VAR 0 12
82513: PUSH
82514: CALL_OW 44
82518: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
82519: LD_VAR 0 12
82523: PPUSH
82524: LD_VAR 0 9
82528: PPUSH
82529: LD_INT 0
82531: PPUSH
82532: CALL 84176 0 3
// end ;
82536: GO 82490
82538: POP
82539: POP
// end ;
82540: LD_VAR 0 10
82544: RET
// export function WantHeal ( sci , unit ) ; begin
82545: LD_INT 0
82547: PPUSH
// if GetTaskList ( sci ) > 0 then
82548: LD_VAR 0 1
82552: PPUSH
82553: CALL_OW 437
82557: PUSH
82558: LD_INT 0
82560: GREATER
82561: IFFALSE 82631
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82563: LD_VAR 0 1
82567: PPUSH
82568: CALL_OW 437
82572: PUSH
82573: LD_INT 1
82575: ARRAY
82576: PUSH
82577: LD_INT 1
82579: ARRAY
82580: PUSH
82581: LD_STRING l
82583: EQUAL
82584: PUSH
82585: LD_VAR 0 1
82589: PPUSH
82590: CALL_OW 437
82594: PUSH
82595: LD_INT 1
82597: ARRAY
82598: PUSH
82599: LD_INT 4
82601: ARRAY
82602: PUSH
82603: LD_VAR 0 2
82607: EQUAL
82608: AND
82609: IFFALSE 82621
// result := true else
82611: LD_ADDR_VAR 0 3
82615: PUSH
82616: LD_INT 1
82618: ST_TO_ADDR
82619: GO 82629
// result := false ;
82621: LD_ADDR_VAR 0 3
82625: PUSH
82626: LD_INT 0
82628: ST_TO_ADDR
// end else
82629: GO 82639
// result := false ;
82631: LD_ADDR_VAR 0 3
82635: PUSH
82636: LD_INT 0
82638: ST_TO_ADDR
// end ;
82639: LD_VAR 0 3
82643: RET
// export function HealTarget ( sci ) ; begin
82644: LD_INT 0
82646: PPUSH
// if not sci then
82647: LD_VAR 0 1
82651: NOT
82652: IFFALSE 82656
// exit ;
82654: GO 82721
// result := 0 ;
82656: LD_ADDR_VAR 0 2
82660: PUSH
82661: LD_INT 0
82663: ST_TO_ADDR
// if GetTaskList ( sci ) then
82664: LD_VAR 0 1
82668: PPUSH
82669: CALL_OW 437
82673: IFFALSE 82721
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82675: LD_VAR 0 1
82679: PPUSH
82680: CALL_OW 437
82684: PUSH
82685: LD_INT 1
82687: ARRAY
82688: PUSH
82689: LD_INT 1
82691: ARRAY
82692: PUSH
82693: LD_STRING l
82695: EQUAL
82696: IFFALSE 82721
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
82698: LD_ADDR_VAR 0 2
82702: PUSH
82703: LD_VAR 0 1
82707: PPUSH
82708: CALL_OW 437
82712: PUSH
82713: LD_INT 1
82715: ARRAY
82716: PUSH
82717: LD_INT 4
82719: ARRAY
82720: ST_TO_ADDR
// end ;
82721: LD_VAR 0 2
82725: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
82726: LD_INT 0
82728: PPUSH
82729: PPUSH
82730: PPUSH
82731: PPUSH
// if not base_units then
82732: LD_VAR 0 1
82736: NOT
82737: IFFALSE 82741
// exit ;
82739: GO 82828
// result := false ;
82741: LD_ADDR_VAR 0 2
82745: PUSH
82746: LD_INT 0
82748: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
82749: LD_ADDR_VAR 0 5
82753: PUSH
82754: LD_VAR 0 1
82758: PPUSH
82759: LD_INT 21
82761: PUSH
82762: LD_INT 3
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PPUSH
82769: CALL_OW 72
82773: ST_TO_ADDR
// if not tmp then
82774: LD_VAR 0 5
82778: NOT
82779: IFFALSE 82783
// exit ;
82781: GO 82828
// for i in tmp do
82783: LD_ADDR_VAR 0 3
82787: PUSH
82788: LD_VAR 0 5
82792: PUSH
82793: FOR_IN
82794: IFFALSE 82826
// begin result := EnemyInRange ( i , 22 ) ;
82796: LD_ADDR_VAR 0 2
82800: PUSH
82801: LD_VAR 0 3
82805: PPUSH
82806: LD_INT 22
82808: PPUSH
82809: CALL 81064 0 2
82813: ST_TO_ADDR
// if result then
82814: LD_VAR 0 2
82818: IFFALSE 82824
// exit ;
82820: POP
82821: POP
82822: GO 82828
// end ;
82824: GO 82793
82826: POP
82827: POP
// end ;
82828: LD_VAR 0 2
82832: RET
// export function FilterByTag ( units , tag ) ; begin
82833: LD_INT 0
82835: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
82836: LD_ADDR_VAR 0 3
82840: PUSH
82841: LD_VAR 0 1
82845: PPUSH
82846: LD_INT 120
82848: PUSH
82849: LD_VAR 0 2
82853: PUSH
82854: EMPTY
82855: LIST
82856: LIST
82857: PPUSH
82858: CALL_OW 72
82862: ST_TO_ADDR
// end ;
82863: LD_VAR 0 3
82867: RET
// export function IsDriver ( un ) ; begin
82868: LD_INT 0
82870: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
82871: LD_ADDR_VAR 0 2
82875: PUSH
82876: LD_VAR 0 1
82880: PUSH
82881: LD_INT 55
82883: PUSH
82884: EMPTY
82885: LIST
82886: PPUSH
82887: CALL_OW 69
82891: IN
82892: ST_TO_ADDR
// end ;
82893: LD_VAR 0 2
82897: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
82898: LD_INT 0
82900: PPUSH
82901: PPUSH
// list := [ ] ;
82902: LD_ADDR_VAR 0 5
82906: PUSH
82907: EMPTY
82908: ST_TO_ADDR
// case d of 0 :
82909: LD_VAR 0 3
82913: PUSH
82914: LD_INT 0
82916: DOUBLE
82917: EQUAL
82918: IFTRUE 82922
82920: GO 83055
82922: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
82923: LD_ADDR_VAR 0 5
82927: PUSH
82928: LD_VAR 0 1
82932: PUSH
82933: LD_INT 4
82935: MINUS
82936: PUSH
82937: LD_VAR 0 2
82941: PUSH
82942: LD_INT 4
82944: MINUS
82945: PUSH
82946: LD_INT 2
82948: PUSH
82949: EMPTY
82950: LIST
82951: LIST
82952: LIST
82953: PUSH
82954: LD_VAR 0 1
82958: PUSH
82959: LD_INT 3
82961: MINUS
82962: PUSH
82963: LD_VAR 0 2
82967: PUSH
82968: LD_INT 1
82970: PUSH
82971: EMPTY
82972: LIST
82973: LIST
82974: LIST
82975: PUSH
82976: LD_VAR 0 1
82980: PUSH
82981: LD_INT 4
82983: PLUS
82984: PUSH
82985: LD_VAR 0 2
82989: PUSH
82990: LD_INT 4
82992: PUSH
82993: EMPTY
82994: LIST
82995: LIST
82996: LIST
82997: PUSH
82998: LD_VAR 0 1
83002: PUSH
83003: LD_INT 3
83005: PLUS
83006: PUSH
83007: LD_VAR 0 2
83011: PUSH
83012: LD_INT 3
83014: PLUS
83015: PUSH
83016: LD_INT 5
83018: PUSH
83019: EMPTY
83020: LIST
83021: LIST
83022: LIST
83023: PUSH
83024: LD_VAR 0 1
83028: PUSH
83029: LD_VAR 0 2
83033: PUSH
83034: LD_INT 4
83036: PLUS
83037: PUSH
83038: LD_INT 0
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: LIST
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: LIST
83050: LIST
83051: LIST
83052: ST_TO_ADDR
// end ; 1 :
83053: GO 83753
83055: LD_INT 1
83057: DOUBLE
83058: EQUAL
83059: IFTRUE 83063
83061: GO 83196
83063: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
83064: LD_ADDR_VAR 0 5
83068: PUSH
83069: LD_VAR 0 1
83073: PUSH
83074: LD_VAR 0 2
83078: PUSH
83079: LD_INT 4
83081: MINUS
83082: PUSH
83083: LD_INT 3
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: LIST
83090: PUSH
83091: LD_VAR 0 1
83095: PUSH
83096: LD_INT 3
83098: MINUS
83099: PUSH
83100: LD_VAR 0 2
83104: PUSH
83105: LD_INT 3
83107: MINUS
83108: PUSH
83109: LD_INT 2
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: LIST
83116: PUSH
83117: LD_VAR 0 1
83121: PUSH
83122: LD_INT 4
83124: MINUS
83125: PUSH
83126: LD_VAR 0 2
83130: PUSH
83131: LD_INT 1
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: LIST
83138: PUSH
83139: LD_VAR 0 1
83143: PUSH
83144: LD_VAR 0 2
83148: PUSH
83149: LD_INT 3
83151: PLUS
83152: PUSH
83153: LD_INT 0
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: LIST
83160: PUSH
83161: LD_VAR 0 1
83165: PUSH
83166: LD_INT 4
83168: PLUS
83169: PUSH
83170: LD_VAR 0 2
83174: PUSH
83175: LD_INT 4
83177: PLUS
83178: PUSH
83179: LD_INT 5
83181: PUSH
83182: EMPTY
83183: LIST
83184: LIST
83185: LIST
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: LIST
83191: LIST
83192: LIST
83193: ST_TO_ADDR
// end ; 2 :
83194: GO 83753
83196: LD_INT 2
83198: DOUBLE
83199: EQUAL
83200: IFTRUE 83204
83202: GO 83333
83204: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
83205: LD_ADDR_VAR 0 5
83209: PUSH
83210: LD_VAR 0 1
83214: PUSH
83215: LD_VAR 0 2
83219: PUSH
83220: LD_INT 3
83222: MINUS
83223: PUSH
83224: LD_INT 3
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: LIST
83231: PUSH
83232: LD_VAR 0 1
83236: PUSH
83237: LD_INT 4
83239: PLUS
83240: PUSH
83241: LD_VAR 0 2
83245: PUSH
83246: LD_INT 4
83248: PUSH
83249: EMPTY
83250: LIST
83251: LIST
83252: LIST
83253: PUSH
83254: LD_VAR 0 1
83258: PUSH
83259: LD_VAR 0 2
83263: PUSH
83264: LD_INT 4
83266: PLUS
83267: PUSH
83268: LD_INT 0
83270: PUSH
83271: EMPTY
83272: LIST
83273: LIST
83274: LIST
83275: PUSH
83276: LD_VAR 0 1
83280: PUSH
83281: LD_INT 3
83283: MINUS
83284: PUSH
83285: LD_VAR 0 2
83289: PUSH
83290: LD_INT 1
83292: PUSH
83293: EMPTY
83294: LIST
83295: LIST
83296: LIST
83297: PUSH
83298: LD_VAR 0 1
83302: PUSH
83303: LD_INT 4
83305: MINUS
83306: PUSH
83307: LD_VAR 0 2
83311: PUSH
83312: LD_INT 4
83314: MINUS
83315: PUSH
83316: LD_INT 2
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: LIST
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: LIST
83328: LIST
83329: LIST
83330: ST_TO_ADDR
// end ; 3 :
83331: GO 83753
83333: LD_INT 3
83335: DOUBLE
83336: EQUAL
83337: IFTRUE 83341
83339: GO 83474
83341: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
83342: LD_ADDR_VAR 0 5
83346: PUSH
83347: LD_VAR 0 1
83351: PUSH
83352: LD_INT 3
83354: PLUS
83355: PUSH
83356: LD_VAR 0 2
83360: PUSH
83361: LD_INT 4
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: LIST
83368: PUSH
83369: LD_VAR 0 1
83373: PUSH
83374: LD_INT 4
83376: PLUS
83377: PUSH
83378: LD_VAR 0 2
83382: PUSH
83383: LD_INT 4
83385: PLUS
83386: PUSH
83387: LD_INT 5
83389: PUSH
83390: EMPTY
83391: LIST
83392: LIST
83393: LIST
83394: PUSH
83395: LD_VAR 0 1
83399: PUSH
83400: LD_INT 4
83402: MINUS
83403: PUSH
83404: LD_VAR 0 2
83408: PUSH
83409: LD_INT 1
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: LIST
83416: PUSH
83417: LD_VAR 0 1
83421: PUSH
83422: LD_VAR 0 2
83426: PUSH
83427: LD_INT 4
83429: MINUS
83430: PUSH
83431: LD_INT 3
83433: PUSH
83434: EMPTY
83435: LIST
83436: LIST
83437: LIST
83438: PUSH
83439: LD_VAR 0 1
83443: PUSH
83444: LD_INT 3
83446: MINUS
83447: PUSH
83448: LD_VAR 0 2
83452: PUSH
83453: LD_INT 3
83455: MINUS
83456: PUSH
83457: LD_INT 2
83459: PUSH
83460: EMPTY
83461: LIST
83462: LIST
83463: LIST
83464: PUSH
83465: EMPTY
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: LIST
83471: ST_TO_ADDR
// end ; 4 :
83472: GO 83753
83474: LD_INT 4
83476: DOUBLE
83477: EQUAL
83478: IFTRUE 83482
83480: GO 83615
83482: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
83483: LD_ADDR_VAR 0 5
83487: PUSH
83488: LD_VAR 0 1
83492: PUSH
83493: LD_VAR 0 2
83497: PUSH
83498: LD_INT 4
83500: PLUS
83501: PUSH
83502: LD_INT 0
83504: PUSH
83505: EMPTY
83506: LIST
83507: LIST
83508: LIST
83509: PUSH
83510: LD_VAR 0 1
83514: PUSH
83515: LD_INT 3
83517: PLUS
83518: PUSH
83519: LD_VAR 0 2
83523: PUSH
83524: LD_INT 3
83526: PLUS
83527: PUSH
83528: LD_INT 5
83530: PUSH
83531: EMPTY
83532: LIST
83533: LIST
83534: LIST
83535: PUSH
83536: LD_VAR 0 1
83540: PUSH
83541: LD_INT 4
83543: PLUS
83544: PUSH
83545: LD_VAR 0 2
83549: PUSH
83550: LD_INT 4
83552: PUSH
83553: EMPTY
83554: LIST
83555: LIST
83556: LIST
83557: PUSH
83558: LD_VAR 0 1
83562: PUSH
83563: LD_VAR 0 2
83567: PUSH
83568: LD_INT 3
83570: MINUS
83571: PUSH
83572: LD_INT 3
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: LIST
83579: PUSH
83580: LD_VAR 0 1
83584: PUSH
83585: LD_INT 4
83587: MINUS
83588: PUSH
83589: LD_VAR 0 2
83593: PUSH
83594: LD_INT 4
83596: MINUS
83597: PUSH
83598: LD_INT 2
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: LIST
83605: PUSH
83606: EMPTY
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: ST_TO_ADDR
// end ; 5 :
83613: GO 83753
83615: LD_INT 5
83617: DOUBLE
83618: EQUAL
83619: IFTRUE 83623
83621: GO 83752
83623: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
83624: LD_ADDR_VAR 0 5
83628: PUSH
83629: LD_VAR 0 1
83633: PUSH
83634: LD_INT 4
83636: MINUS
83637: PUSH
83638: LD_VAR 0 2
83642: PUSH
83643: LD_INT 1
83645: PUSH
83646: EMPTY
83647: LIST
83648: LIST
83649: LIST
83650: PUSH
83651: LD_VAR 0 1
83655: PUSH
83656: LD_VAR 0 2
83660: PUSH
83661: LD_INT 4
83663: MINUS
83664: PUSH
83665: LD_INT 3
83667: PUSH
83668: EMPTY
83669: LIST
83670: LIST
83671: LIST
83672: PUSH
83673: LD_VAR 0 1
83677: PUSH
83678: LD_INT 4
83680: PLUS
83681: PUSH
83682: LD_VAR 0 2
83686: PUSH
83687: LD_INT 4
83689: PLUS
83690: PUSH
83691: LD_INT 5
83693: PUSH
83694: EMPTY
83695: LIST
83696: LIST
83697: LIST
83698: PUSH
83699: LD_VAR 0 1
83703: PUSH
83704: LD_INT 3
83706: PLUS
83707: PUSH
83708: LD_VAR 0 2
83712: PUSH
83713: LD_INT 4
83715: PUSH
83716: EMPTY
83717: LIST
83718: LIST
83719: LIST
83720: PUSH
83721: LD_VAR 0 1
83725: PUSH
83726: LD_VAR 0 2
83730: PUSH
83731: LD_INT 3
83733: PLUS
83734: PUSH
83735: LD_INT 0
83737: PUSH
83738: EMPTY
83739: LIST
83740: LIST
83741: LIST
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: ST_TO_ADDR
// end ; end ;
83750: GO 83753
83752: POP
// result := list ;
83753: LD_ADDR_VAR 0 4
83757: PUSH
83758: LD_VAR 0 5
83762: ST_TO_ADDR
// end ;
83763: LD_VAR 0 4
83767: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
83768: LD_INT 0
83770: PPUSH
83771: PPUSH
83772: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
83773: LD_VAR 0 1
83777: NOT
83778: PUSH
83779: LD_VAR 0 2
83783: PUSH
83784: LD_INT 1
83786: PUSH
83787: LD_INT 2
83789: PUSH
83790: LD_INT 3
83792: PUSH
83793: LD_INT 4
83795: PUSH
83796: EMPTY
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: IN
83802: NOT
83803: OR
83804: IFFALSE 83808
// exit ;
83806: GO 83900
// tmp := [ ] ;
83808: LD_ADDR_VAR 0 5
83812: PUSH
83813: EMPTY
83814: ST_TO_ADDR
// for i in units do
83815: LD_ADDR_VAR 0 4
83819: PUSH
83820: LD_VAR 0 1
83824: PUSH
83825: FOR_IN
83826: IFFALSE 83869
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
83828: LD_ADDR_VAR 0 5
83832: PUSH
83833: LD_VAR 0 5
83837: PPUSH
83838: LD_VAR 0 5
83842: PUSH
83843: LD_INT 1
83845: PLUS
83846: PPUSH
83847: LD_VAR 0 4
83851: PPUSH
83852: LD_VAR 0 2
83856: PPUSH
83857: CALL_OW 259
83861: PPUSH
83862: CALL_OW 2
83866: ST_TO_ADDR
83867: GO 83825
83869: POP
83870: POP
// if not tmp then
83871: LD_VAR 0 5
83875: NOT
83876: IFFALSE 83880
// exit ;
83878: GO 83900
// result := SortListByListDesc ( units , tmp ) ;
83880: LD_ADDR_VAR 0 3
83884: PUSH
83885: LD_VAR 0 1
83889: PPUSH
83890: LD_VAR 0 5
83894: PPUSH
83895: CALL_OW 77
83899: ST_TO_ADDR
// end ;
83900: LD_VAR 0 3
83904: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
83905: LD_INT 0
83907: PPUSH
83908: PPUSH
83909: PPUSH
// result := false ;
83910: LD_ADDR_VAR 0 3
83914: PUSH
83915: LD_INT 0
83917: ST_TO_ADDR
// x := GetX ( building ) ;
83918: LD_ADDR_VAR 0 4
83922: PUSH
83923: LD_VAR 0 2
83927: PPUSH
83928: CALL_OW 250
83932: ST_TO_ADDR
// y := GetY ( building ) ;
83933: LD_ADDR_VAR 0 5
83937: PUSH
83938: LD_VAR 0 2
83942: PPUSH
83943: CALL_OW 251
83947: ST_TO_ADDR
// if not building or not x or not y then
83948: LD_VAR 0 2
83952: NOT
83953: PUSH
83954: LD_VAR 0 4
83958: NOT
83959: OR
83960: PUSH
83961: LD_VAR 0 5
83965: NOT
83966: OR
83967: IFFALSE 83971
// exit ;
83969: GO 84063
// if GetTaskList ( unit ) then
83971: LD_VAR 0 1
83975: PPUSH
83976: CALL_OW 437
83980: IFFALSE 84063
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
83982: LD_STRING e
83984: PUSH
83985: LD_VAR 0 1
83989: PPUSH
83990: CALL_OW 437
83994: PUSH
83995: LD_INT 1
83997: ARRAY
83998: PUSH
83999: LD_INT 1
84001: ARRAY
84002: EQUAL
84003: PUSH
84004: LD_VAR 0 4
84008: PUSH
84009: LD_VAR 0 1
84013: PPUSH
84014: CALL_OW 437
84018: PUSH
84019: LD_INT 1
84021: ARRAY
84022: PUSH
84023: LD_INT 2
84025: ARRAY
84026: EQUAL
84027: AND
84028: PUSH
84029: LD_VAR 0 5
84033: PUSH
84034: LD_VAR 0 1
84038: PPUSH
84039: CALL_OW 437
84043: PUSH
84044: LD_INT 1
84046: ARRAY
84047: PUSH
84048: LD_INT 3
84050: ARRAY
84051: EQUAL
84052: AND
84053: IFFALSE 84063
// result := true end ;
84055: LD_ADDR_VAR 0 3
84059: PUSH
84060: LD_INT 1
84062: ST_TO_ADDR
// end ;
84063: LD_VAR 0 3
84067: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
84068: LD_INT 0
84070: PPUSH
// result := false ;
84071: LD_ADDR_VAR 0 4
84075: PUSH
84076: LD_INT 0
84078: ST_TO_ADDR
// if GetTaskList ( unit ) then
84079: LD_VAR 0 1
84083: PPUSH
84084: CALL_OW 437
84088: IFFALSE 84171
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84090: LD_STRING M
84092: PUSH
84093: LD_VAR 0 1
84097: PPUSH
84098: CALL_OW 437
84102: PUSH
84103: LD_INT 1
84105: ARRAY
84106: PUSH
84107: LD_INT 1
84109: ARRAY
84110: EQUAL
84111: PUSH
84112: LD_VAR 0 2
84116: PUSH
84117: LD_VAR 0 1
84121: PPUSH
84122: CALL_OW 437
84126: PUSH
84127: LD_INT 1
84129: ARRAY
84130: PUSH
84131: LD_INT 2
84133: ARRAY
84134: EQUAL
84135: AND
84136: PUSH
84137: LD_VAR 0 3
84141: PUSH
84142: LD_VAR 0 1
84146: PPUSH
84147: CALL_OW 437
84151: PUSH
84152: LD_INT 1
84154: ARRAY
84155: PUSH
84156: LD_INT 3
84158: ARRAY
84159: EQUAL
84160: AND
84161: IFFALSE 84171
// result := true ;
84163: LD_ADDR_VAR 0 4
84167: PUSH
84168: LD_INT 1
84170: ST_TO_ADDR
// end ; end ;
84171: LD_VAR 0 4
84175: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
84176: LD_INT 0
84178: PPUSH
84179: PPUSH
84180: PPUSH
84181: PPUSH
// if not unit or not area then
84182: LD_VAR 0 1
84186: NOT
84187: PUSH
84188: LD_VAR 0 2
84192: NOT
84193: OR
84194: IFFALSE 84198
// exit ;
84196: GO 84362
// tmp := AreaToList ( area , i ) ;
84198: LD_ADDR_VAR 0 6
84202: PUSH
84203: LD_VAR 0 2
84207: PPUSH
84208: LD_VAR 0 5
84212: PPUSH
84213: CALL_OW 517
84217: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
84218: LD_ADDR_VAR 0 5
84222: PUSH
84223: DOUBLE
84224: LD_INT 1
84226: DEC
84227: ST_TO_ADDR
84228: LD_VAR 0 6
84232: PUSH
84233: LD_INT 1
84235: ARRAY
84236: PUSH
84237: FOR_TO
84238: IFFALSE 84360
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
84240: LD_ADDR_VAR 0 7
84244: PUSH
84245: LD_VAR 0 6
84249: PUSH
84250: LD_INT 1
84252: ARRAY
84253: PUSH
84254: LD_VAR 0 5
84258: ARRAY
84259: PUSH
84260: LD_VAR 0 6
84264: PUSH
84265: LD_INT 2
84267: ARRAY
84268: PUSH
84269: LD_VAR 0 5
84273: ARRAY
84274: PUSH
84275: EMPTY
84276: LIST
84277: LIST
84278: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
84279: LD_VAR 0 7
84283: PUSH
84284: LD_INT 1
84286: ARRAY
84287: PPUSH
84288: LD_VAR 0 7
84292: PUSH
84293: LD_INT 2
84295: ARRAY
84296: PPUSH
84297: CALL_OW 428
84301: PUSH
84302: LD_INT 0
84304: EQUAL
84305: IFFALSE 84358
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
84307: LD_VAR 0 1
84311: PPUSH
84312: LD_VAR 0 7
84316: PUSH
84317: LD_INT 1
84319: ARRAY
84320: PPUSH
84321: LD_VAR 0 7
84325: PUSH
84326: LD_INT 2
84328: ARRAY
84329: PPUSH
84330: LD_VAR 0 3
84334: PPUSH
84335: CALL_OW 48
// result := IsPlaced ( unit ) ;
84339: LD_ADDR_VAR 0 4
84343: PUSH
84344: LD_VAR 0 1
84348: PPUSH
84349: CALL_OW 305
84353: ST_TO_ADDR
// exit ;
84354: POP
84355: POP
84356: GO 84362
// end ; end ;
84358: GO 84237
84360: POP
84361: POP
// end ;
84362: LD_VAR 0 4
84366: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
84367: LD_INT 0
84369: PPUSH
84370: PPUSH
84371: PPUSH
// if not side or side > 8 then
84372: LD_VAR 0 1
84376: NOT
84377: PUSH
84378: LD_VAR 0 1
84382: PUSH
84383: LD_INT 8
84385: GREATER
84386: OR
84387: IFFALSE 84391
// exit ;
84389: GO 84578
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
84391: LD_ADDR_VAR 0 4
84395: PUSH
84396: LD_INT 22
84398: PUSH
84399: LD_VAR 0 1
84403: PUSH
84404: EMPTY
84405: LIST
84406: LIST
84407: PUSH
84408: LD_INT 21
84410: PUSH
84411: LD_INT 3
84413: PUSH
84414: EMPTY
84415: LIST
84416: LIST
84417: PUSH
84418: EMPTY
84419: LIST
84420: LIST
84421: PPUSH
84422: CALL_OW 69
84426: ST_TO_ADDR
// if not tmp then
84427: LD_VAR 0 4
84431: NOT
84432: IFFALSE 84436
// exit ;
84434: GO 84578
// enable_addtolog := true ;
84436: LD_ADDR_OWVAR 81
84440: PUSH
84441: LD_INT 1
84443: ST_TO_ADDR
// AddToLog ( [ ) ;
84444: LD_STRING [
84446: PPUSH
84447: CALL_OW 561
// for i in tmp do
84451: LD_ADDR_VAR 0 3
84455: PUSH
84456: LD_VAR 0 4
84460: PUSH
84461: FOR_IN
84462: IFFALSE 84569
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
84464: LD_STRING [
84466: PUSH
84467: LD_VAR 0 3
84471: PPUSH
84472: CALL_OW 266
84476: STR
84477: PUSH
84478: LD_STRING , 
84480: STR
84481: PUSH
84482: LD_VAR 0 3
84486: PPUSH
84487: CALL_OW 250
84491: STR
84492: PUSH
84493: LD_STRING , 
84495: STR
84496: PUSH
84497: LD_VAR 0 3
84501: PPUSH
84502: CALL_OW 251
84506: STR
84507: PUSH
84508: LD_STRING , 
84510: STR
84511: PUSH
84512: LD_VAR 0 3
84516: PPUSH
84517: CALL_OW 254
84521: STR
84522: PUSH
84523: LD_STRING , 
84525: STR
84526: PUSH
84527: LD_VAR 0 3
84531: PPUSH
84532: LD_INT 1
84534: PPUSH
84535: CALL_OW 268
84539: STR
84540: PUSH
84541: LD_STRING , 
84543: STR
84544: PUSH
84545: LD_VAR 0 3
84549: PPUSH
84550: LD_INT 2
84552: PPUSH
84553: CALL_OW 268
84557: STR
84558: PUSH
84559: LD_STRING ],
84561: STR
84562: PPUSH
84563: CALL_OW 561
// end ;
84567: GO 84461
84569: POP
84570: POP
// AddToLog ( ]; ) ;
84571: LD_STRING ];
84573: PPUSH
84574: CALL_OW 561
// end ;
84578: LD_VAR 0 2
84582: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
84583: LD_INT 0
84585: PPUSH
84586: PPUSH
84587: PPUSH
84588: PPUSH
84589: PPUSH
// if not area or not rate or not max then
84590: LD_VAR 0 1
84594: NOT
84595: PUSH
84596: LD_VAR 0 2
84600: NOT
84601: OR
84602: PUSH
84603: LD_VAR 0 4
84607: NOT
84608: OR
84609: IFFALSE 84613
// exit ;
84611: GO 84802
// while 1 do
84613: LD_INT 1
84615: IFFALSE 84802
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
84617: LD_ADDR_VAR 0 9
84621: PUSH
84622: LD_VAR 0 1
84626: PPUSH
84627: LD_INT 1
84629: PPUSH
84630: CALL_OW 287
84634: PUSH
84635: LD_INT 10
84637: MUL
84638: ST_TO_ADDR
// r := rate / 10 ;
84639: LD_ADDR_VAR 0 7
84643: PUSH
84644: LD_VAR 0 2
84648: PUSH
84649: LD_INT 10
84651: DIVREAL
84652: ST_TO_ADDR
// time := 1 1$00 ;
84653: LD_ADDR_VAR 0 8
84657: PUSH
84658: LD_INT 2100
84660: ST_TO_ADDR
// if amount < min then
84661: LD_VAR 0 9
84665: PUSH
84666: LD_VAR 0 3
84670: LESS
84671: IFFALSE 84689
// r := r * 2 else
84673: LD_ADDR_VAR 0 7
84677: PUSH
84678: LD_VAR 0 7
84682: PUSH
84683: LD_INT 2
84685: MUL
84686: ST_TO_ADDR
84687: GO 84715
// if amount > max then
84689: LD_VAR 0 9
84693: PUSH
84694: LD_VAR 0 4
84698: GREATER
84699: IFFALSE 84715
// r := r / 2 ;
84701: LD_ADDR_VAR 0 7
84705: PUSH
84706: LD_VAR 0 7
84710: PUSH
84711: LD_INT 2
84713: DIVREAL
84714: ST_TO_ADDR
// time := time / r ;
84715: LD_ADDR_VAR 0 8
84719: PUSH
84720: LD_VAR 0 8
84724: PUSH
84725: LD_VAR 0 7
84729: DIVREAL
84730: ST_TO_ADDR
// if time < 0 then
84731: LD_VAR 0 8
84735: PUSH
84736: LD_INT 0
84738: LESS
84739: IFFALSE 84756
// time := time * - 1 ;
84741: LD_ADDR_VAR 0 8
84745: PUSH
84746: LD_VAR 0 8
84750: PUSH
84751: LD_INT 1
84753: NEG
84754: MUL
84755: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
84756: LD_VAR 0 8
84760: PUSH
84761: LD_INT 35
84763: PPUSH
84764: LD_INT 875
84766: PPUSH
84767: CALL_OW 12
84771: PLUS
84772: PPUSH
84773: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
84777: LD_INT 1
84779: PPUSH
84780: LD_INT 5
84782: PPUSH
84783: CALL_OW 12
84787: PPUSH
84788: LD_VAR 0 1
84792: PPUSH
84793: LD_INT 1
84795: PPUSH
84796: CALL_OW 55
// end ;
84800: GO 84613
// end ;
84802: LD_VAR 0 5
84806: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
84807: LD_INT 0
84809: PPUSH
84810: PPUSH
84811: PPUSH
84812: PPUSH
84813: PPUSH
84814: PPUSH
84815: PPUSH
84816: PPUSH
// if not turrets or not factories then
84817: LD_VAR 0 1
84821: NOT
84822: PUSH
84823: LD_VAR 0 2
84827: NOT
84828: OR
84829: IFFALSE 84833
// exit ;
84831: GO 85140
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
84833: LD_ADDR_VAR 0 10
84837: PUSH
84838: LD_INT 5
84840: PUSH
84841: LD_INT 6
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: PUSH
84848: LD_INT 2
84850: PUSH
84851: LD_INT 4
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: LD_INT 3
84860: PUSH
84861: LD_INT 5
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: PUSH
84868: EMPTY
84869: LIST
84870: LIST
84871: LIST
84872: PUSH
84873: LD_INT 24
84875: PUSH
84876: LD_INT 25
84878: PUSH
84879: EMPTY
84880: LIST
84881: LIST
84882: PUSH
84883: LD_INT 23
84885: PUSH
84886: LD_INT 27
84888: PUSH
84889: EMPTY
84890: LIST
84891: LIST
84892: PUSH
84893: EMPTY
84894: LIST
84895: LIST
84896: PUSH
84897: LD_INT 42
84899: PUSH
84900: LD_INT 43
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: PUSH
84907: LD_INT 44
84909: PUSH
84910: LD_INT 46
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: PUSH
84917: LD_INT 45
84919: PUSH
84920: LD_INT 47
84922: PUSH
84923: EMPTY
84924: LIST
84925: LIST
84926: PUSH
84927: EMPTY
84928: LIST
84929: LIST
84930: LIST
84931: PUSH
84932: EMPTY
84933: LIST
84934: LIST
84935: LIST
84936: ST_TO_ADDR
// result := [ ] ;
84937: LD_ADDR_VAR 0 3
84941: PUSH
84942: EMPTY
84943: ST_TO_ADDR
// for i in turrets do
84944: LD_ADDR_VAR 0 4
84948: PUSH
84949: LD_VAR 0 1
84953: PUSH
84954: FOR_IN
84955: IFFALSE 85138
// begin nat := GetNation ( i ) ;
84957: LD_ADDR_VAR 0 7
84961: PUSH
84962: LD_VAR 0 4
84966: PPUSH
84967: CALL_OW 248
84971: ST_TO_ADDR
// weapon := 0 ;
84972: LD_ADDR_VAR 0 8
84976: PUSH
84977: LD_INT 0
84979: ST_TO_ADDR
// if not nat then
84980: LD_VAR 0 7
84984: NOT
84985: IFFALSE 84989
// continue ;
84987: GO 84954
// for j in list [ nat ] do
84989: LD_ADDR_VAR 0 5
84993: PUSH
84994: LD_VAR 0 10
84998: PUSH
84999: LD_VAR 0 7
85003: ARRAY
85004: PUSH
85005: FOR_IN
85006: IFFALSE 85047
// if GetBWeapon ( i ) = j [ 1 ] then
85008: LD_VAR 0 4
85012: PPUSH
85013: CALL_OW 269
85017: PUSH
85018: LD_VAR 0 5
85022: PUSH
85023: LD_INT 1
85025: ARRAY
85026: EQUAL
85027: IFFALSE 85045
// begin weapon := j [ 2 ] ;
85029: LD_ADDR_VAR 0 8
85033: PUSH
85034: LD_VAR 0 5
85038: PUSH
85039: LD_INT 2
85041: ARRAY
85042: ST_TO_ADDR
// break ;
85043: GO 85047
// end ;
85045: GO 85005
85047: POP
85048: POP
// if not weapon then
85049: LD_VAR 0 8
85053: NOT
85054: IFFALSE 85058
// continue ;
85056: GO 84954
// for k in factories do
85058: LD_ADDR_VAR 0 6
85062: PUSH
85063: LD_VAR 0 2
85067: PUSH
85068: FOR_IN
85069: IFFALSE 85134
// begin weapons := AvailableWeaponList ( k ) ;
85071: LD_ADDR_VAR 0 9
85075: PUSH
85076: LD_VAR 0 6
85080: PPUSH
85081: CALL_OW 478
85085: ST_TO_ADDR
// if not weapons then
85086: LD_VAR 0 9
85090: NOT
85091: IFFALSE 85095
// continue ;
85093: GO 85068
// if weapon in weapons then
85095: LD_VAR 0 8
85099: PUSH
85100: LD_VAR 0 9
85104: IN
85105: IFFALSE 85132
// begin result := [ i , weapon ] ;
85107: LD_ADDR_VAR 0 3
85111: PUSH
85112: LD_VAR 0 4
85116: PUSH
85117: LD_VAR 0 8
85121: PUSH
85122: EMPTY
85123: LIST
85124: LIST
85125: ST_TO_ADDR
// exit ;
85126: POP
85127: POP
85128: POP
85129: POP
85130: GO 85140
// end ; end ;
85132: GO 85068
85134: POP
85135: POP
// end ;
85136: GO 84954
85138: POP
85139: POP
// end ;
85140: LD_VAR 0 3
85144: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
85145: LD_INT 0
85147: PPUSH
// if not side or side > 8 then
85148: LD_VAR 0 3
85152: NOT
85153: PUSH
85154: LD_VAR 0 3
85158: PUSH
85159: LD_INT 8
85161: GREATER
85162: OR
85163: IFFALSE 85167
// exit ;
85165: GO 85226
// if not range then
85167: LD_VAR 0 4
85171: NOT
85172: IFFALSE 85183
// range := - 12 ;
85174: LD_ADDR_VAR 0 4
85178: PUSH
85179: LD_INT 12
85181: NEG
85182: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
85183: LD_VAR 0 1
85187: PPUSH
85188: LD_VAR 0 2
85192: PPUSH
85193: LD_VAR 0 3
85197: PPUSH
85198: LD_VAR 0 4
85202: PPUSH
85203: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
85207: LD_VAR 0 1
85211: PPUSH
85212: LD_VAR 0 2
85216: PPUSH
85217: LD_VAR 0 3
85221: PPUSH
85222: CALL_OW 331
// end ;
85226: LD_VAR 0 5
85230: RET
// export function Video ( mode ) ; begin
85231: LD_INT 0
85233: PPUSH
// ingame_video = mode ;
85234: LD_ADDR_OWVAR 52
85238: PUSH
85239: LD_VAR 0 1
85243: ST_TO_ADDR
// interface_hidden = mode ;
85244: LD_ADDR_OWVAR 54
85248: PUSH
85249: LD_VAR 0 1
85253: ST_TO_ADDR
// end ;
85254: LD_VAR 0 2
85258: RET
// export function Join ( array , element ) ; begin
85259: LD_INT 0
85261: PPUSH
// result := Replace ( array , array + 1 , element ) ;
85262: LD_ADDR_VAR 0 3
85266: PUSH
85267: LD_VAR 0 1
85271: PPUSH
85272: LD_VAR 0 1
85276: PUSH
85277: LD_INT 1
85279: PLUS
85280: PPUSH
85281: LD_VAR 0 2
85285: PPUSH
85286: CALL_OW 1
85290: ST_TO_ADDR
// end ;
85291: LD_VAR 0 3
85295: RET
// export function JoinUnion ( array , element ) ; begin
85296: LD_INT 0
85298: PPUSH
// result := array union element ;
85299: LD_ADDR_VAR 0 3
85303: PUSH
85304: LD_VAR 0 1
85308: PUSH
85309: LD_VAR 0 2
85313: UNION
85314: ST_TO_ADDR
// end ;
85315: LD_VAR 0 3
85319: RET
// export function GetBehemoths ( side ) ; begin
85320: LD_INT 0
85322: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
85323: LD_ADDR_VAR 0 2
85327: PUSH
85328: LD_INT 22
85330: PUSH
85331: LD_VAR 0 1
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PUSH
85340: LD_INT 31
85342: PUSH
85343: LD_INT 25
85345: PUSH
85346: EMPTY
85347: LIST
85348: LIST
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: PPUSH
85354: CALL_OW 69
85358: ST_TO_ADDR
// end ;
85359: LD_VAR 0 2
85363: RET
// export function Shuffle ( array ) ; var i , index ; begin
85364: LD_INT 0
85366: PPUSH
85367: PPUSH
85368: PPUSH
// result := [ ] ;
85369: LD_ADDR_VAR 0 2
85373: PUSH
85374: EMPTY
85375: ST_TO_ADDR
// if not array then
85376: LD_VAR 0 1
85380: NOT
85381: IFFALSE 85385
// exit ;
85383: GO 85484
// Randomize ;
85385: CALL_OW 10
// for i = array downto 1 do
85389: LD_ADDR_VAR 0 3
85393: PUSH
85394: DOUBLE
85395: LD_VAR 0 1
85399: INC
85400: ST_TO_ADDR
85401: LD_INT 1
85403: PUSH
85404: FOR_DOWNTO
85405: IFFALSE 85482
// begin index := rand ( 1 , array ) ;
85407: LD_ADDR_VAR 0 4
85411: PUSH
85412: LD_INT 1
85414: PPUSH
85415: LD_VAR 0 1
85419: PPUSH
85420: CALL_OW 12
85424: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
85425: LD_ADDR_VAR 0 2
85429: PUSH
85430: LD_VAR 0 2
85434: PPUSH
85435: LD_VAR 0 2
85439: PUSH
85440: LD_INT 1
85442: PLUS
85443: PPUSH
85444: LD_VAR 0 1
85448: PUSH
85449: LD_VAR 0 4
85453: ARRAY
85454: PPUSH
85455: CALL_OW 2
85459: ST_TO_ADDR
// array := Delete ( array , index ) ;
85460: LD_ADDR_VAR 0 1
85464: PUSH
85465: LD_VAR 0 1
85469: PPUSH
85470: LD_VAR 0 4
85474: PPUSH
85475: CALL_OW 3
85479: ST_TO_ADDR
// end ;
85480: GO 85404
85482: POP
85483: POP
// end ;
85484: LD_VAR 0 2
85488: RET
// export function GetBaseMaterials ( base ) ; begin
85489: LD_INT 0
85491: PPUSH
// result := [ 0 , 0 , 0 ] ;
85492: LD_ADDR_VAR 0 2
85496: PUSH
85497: LD_INT 0
85499: PUSH
85500: LD_INT 0
85502: PUSH
85503: LD_INT 0
85505: PUSH
85506: EMPTY
85507: LIST
85508: LIST
85509: LIST
85510: ST_TO_ADDR
// if not base then
85511: LD_VAR 0 1
85515: NOT
85516: IFFALSE 85520
// exit ;
85518: GO 85569
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
85520: LD_ADDR_VAR 0 2
85524: PUSH
85525: LD_VAR 0 1
85529: PPUSH
85530: LD_INT 1
85532: PPUSH
85533: CALL_OW 275
85537: PUSH
85538: LD_VAR 0 1
85542: PPUSH
85543: LD_INT 2
85545: PPUSH
85546: CALL_OW 275
85550: PUSH
85551: LD_VAR 0 1
85555: PPUSH
85556: LD_INT 3
85558: PPUSH
85559: CALL_OW 275
85563: PUSH
85564: EMPTY
85565: LIST
85566: LIST
85567: LIST
85568: ST_TO_ADDR
// end ;
85569: LD_VAR 0 2
85573: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
85574: LD_INT 0
85576: PPUSH
85577: PPUSH
// result := array ;
85578: LD_ADDR_VAR 0 3
85582: PUSH
85583: LD_VAR 0 1
85587: ST_TO_ADDR
// if size > 0 then
85588: LD_VAR 0 2
85592: PUSH
85593: LD_INT 0
85595: GREATER
85596: IFFALSE 85642
// for i := array downto size do
85598: LD_ADDR_VAR 0 4
85602: PUSH
85603: DOUBLE
85604: LD_VAR 0 1
85608: INC
85609: ST_TO_ADDR
85610: LD_VAR 0 2
85614: PUSH
85615: FOR_DOWNTO
85616: IFFALSE 85640
// result := Delete ( result , result ) ;
85618: LD_ADDR_VAR 0 3
85622: PUSH
85623: LD_VAR 0 3
85627: PPUSH
85628: LD_VAR 0 3
85632: PPUSH
85633: CALL_OW 3
85637: ST_TO_ADDR
85638: GO 85615
85640: POP
85641: POP
// end ;
85642: LD_VAR 0 3
85646: RET
// export function ComExit ( unit ) ; var tmp ; begin
85647: LD_INT 0
85649: PPUSH
85650: PPUSH
// if not IsInUnit ( unit ) then
85651: LD_VAR 0 1
85655: PPUSH
85656: CALL_OW 310
85660: NOT
85661: IFFALSE 85665
// exit ;
85663: GO 85725
// tmp := IsInUnit ( unit ) ;
85665: LD_ADDR_VAR 0 3
85669: PUSH
85670: LD_VAR 0 1
85674: PPUSH
85675: CALL_OW 310
85679: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
85680: LD_VAR 0 3
85684: PPUSH
85685: CALL_OW 247
85689: PUSH
85690: LD_INT 2
85692: EQUAL
85693: IFFALSE 85706
// ComExitVehicle ( unit ) else
85695: LD_VAR 0 1
85699: PPUSH
85700: CALL_OW 121
85704: GO 85715
// ComExitBuilding ( unit ) ;
85706: LD_VAR 0 1
85710: PPUSH
85711: CALL_OW 122
// result := tmp ;
85715: LD_ADDR_VAR 0 2
85719: PUSH
85720: LD_VAR 0 3
85724: ST_TO_ADDR
// end ;
85725: LD_VAR 0 2
85729: RET
// export function ComExitAll ( units ) ; var i ; begin
85730: LD_INT 0
85732: PPUSH
85733: PPUSH
// if not units then
85734: LD_VAR 0 1
85738: NOT
85739: IFFALSE 85743
// exit ;
85741: GO 85769
// for i in units do
85743: LD_ADDR_VAR 0 3
85747: PUSH
85748: LD_VAR 0 1
85752: PUSH
85753: FOR_IN
85754: IFFALSE 85767
// ComExit ( i ) ;
85756: LD_VAR 0 3
85760: PPUSH
85761: CALL 85647 0 1
85765: GO 85753
85767: POP
85768: POP
// end ;
85769: LD_VAR 0 2
85773: RET
// export function ResetHc ; begin
85774: LD_INT 0
85776: PPUSH
// InitHc ;
85777: CALL_OW 19
// hc_importance := 0 ;
85781: LD_ADDR_OWVAR 32
85785: PUSH
85786: LD_INT 0
85788: ST_TO_ADDR
// end ;
85789: LD_VAR 0 1
85793: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
85794: LD_INT 0
85796: PPUSH
85797: PPUSH
85798: PPUSH
// _x := ( x1 + x2 ) div 2 ;
85799: LD_ADDR_VAR 0 6
85803: PUSH
85804: LD_VAR 0 1
85808: PUSH
85809: LD_VAR 0 3
85813: PLUS
85814: PUSH
85815: LD_INT 2
85817: DIV
85818: ST_TO_ADDR
// if _x < 0 then
85819: LD_VAR 0 6
85823: PUSH
85824: LD_INT 0
85826: LESS
85827: IFFALSE 85844
// _x := _x * - 1 ;
85829: LD_ADDR_VAR 0 6
85833: PUSH
85834: LD_VAR 0 6
85838: PUSH
85839: LD_INT 1
85841: NEG
85842: MUL
85843: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
85844: LD_ADDR_VAR 0 7
85848: PUSH
85849: LD_VAR 0 2
85853: PUSH
85854: LD_VAR 0 4
85858: PLUS
85859: PUSH
85860: LD_INT 2
85862: DIV
85863: ST_TO_ADDR
// if _y < 0 then
85864: LD_VAR 0 7
85868: PUSH
85869: LD_INT 0
85871: LESS
85872: IFFALSE 85889
// _y := _y * - 1 ;
85874: LD_ADDR_VAR 0 7
85878: PUSH
85879: LD_VAR 0 7
85883: PUSH
85884: LD_INT 1
85886: NEG
85887: MUL
85888: ST_TO_ADDR
// result := [ _x , _y ] ;
85889: LD_ADDR_VAR 0 5
85893: PUSH
85894: LD_VAR 0 6
85898: PUSH
85899: LD_VAR 0 7
85903: PUSH
85904: EMPTY
85905: LIST
85906: LIST
85907: ST_TO_ADDR
// end ;
85908: LD_VAR 0 5
85912: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
85913: LD_INT 0
85915: PPUSH
85916: PPUSH
85917: PPUSH
85918: PPUSH
// task := GetTaskList ( unit ) ;
85919: LD_ADDR_VAR 0 7
85923: PUSH
85924: LD_VAR 0 1
85928: PPUSH
85929: CALL_OW 437
85933: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
85934: LD_VAR 0 7
85938: NOT
85939: PUSH
85940: LD_VAR 0 1
85944: PPUSH
85945: LD_VAR 0 2
85949: PPUSH
85950: CALL_OW 308
85954: NOT
85955: AND
85956: IFFALSE 85960
// exit ;
85958: GO 86078
// if IsInArea ( unit , area ) then
85960: LD_VAR 0 1
85964: PPUSH
85965: LD_VAR 0 2
85969: PPUSH
85970: CALL_OW 308
85974: IFFALSE 85992
// begin ComMoveToArea ( unit , goAway ) ;
85976: LD_VAR 0 1
85980: PPUSH
85981: LD_VAR 0 3
85985: PPUSH
85986: CALL_OW 113
// exit ;
85990: GO 86078
// end ; if task [ 1 ] [ 1 ] <> M then
85992: LD_VAR 0 7
85996: PUSH
85997: LD_INT 1
85999: ARRAY
86000: PUSH
86001: LD_INT 1
86003: ARRAY
86004: PUSH
86005: LD_STRING M
86007: NONEQUAL
86008: IFFALSE 86012
// exit ;
86010: GO 86078
// x := task [ 1 ] [ 2 ] ;
86012: LD_ADDR_VAR 0 5
86016: PUSH
86017: LD_VAR 0 7
86021: PUSH
86022: LD_INT 1
86024: ARRAY
86025: PUSH
86026: LD_INT 2
86028: ARRAY
86029: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
86030: LD_ADDR_VAR 0 6
86034: PUSH
86035: LD_VAR 0 7
86039: PUSH
86040: LD_INT 1
86042: ARRAY
86043: PUSH
86044: LD_INT 3
86046: ARRAY
86047: ST_TO_ADDR
// if InArea ( x , y , area ) then
86048: LD_VAR 0 5
86052: PPUSH
86053: LD_VAR 0 6
86057: PPUSH
86058: LD_VAR 0 2
86062: PPUSH
86063: CALL_OW 309
86067: IFFALSE 86078
// ComStop ( unit ) ;
86069: LD_VAR 0 1
86073: PPUSH
86074: CALL_OW 141
// end ;
86078: LD_VAR 0 4
86082: RET
// export function Abs ( value ) ; begin
86083: LD_INT 0
86085: PPUSH
// result := value ;
86086: LD_ADDR_VAR 0 2
86090: PUSH
86091: LD_VAR 0 1
86095: ST_TO_ADDR
// if value < 0 then
86096: LD_VAR 0 1
86100: PUSH
86101: LD_INT 0
86103: LESS
86104: IFFALSE 86121
// result := value * - 1 ;
86106: LD_ADDR_VAR 0 2
86110: PUSH
86111: LD_VAR 0 1
86115: PUSH
86116: LD_INT 1
86118: NEG
86119: MUL
86120: ST_TO_ADDR
// end ;
86121: LD_VAR 0 2
86125: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
86126: LD_INT 0
86128: PPUSH
86129: PPUSH
86130: PPUSH
86131: PPUSH
86132: PPUSH
86133: PPUSH
86134: PPUSH
86135: PPUSH
// if not unit or not building then
86136: LD_VAR 0 1
86140: NOT
86141: PUSH
86142: LD_VAR 0 2
86146: NOT
86147: OR
86148: IFFALSE 86152
// exit ;
86150: GO 86378
// x := GetX ( building ) ;
86152: LD_ADDR_VAR 0 4
86156: PUSH
86157: LD_VAR 0 2
86161: PPUSH
86162: CALL_OW 250
86166: ST_TO_ADDR
// y := GetY ( building ) ;
86167: LD_ADDR_VAR 0 6
86171: PUSH
86172: LD_VAR 0 2
86176: PPUSH
86177: CALL_OW 251
86181: ST_TO_ADDR
// d := GetDir ( building ) ;
86182: LD_ADDR_VAR 0 8
86186: PUSH
86187: LD_VAR 0 2
86191: PPUSH
86192: CALL_OW 254
86196: ST_TO_ADDR
// r := 4 ;
86197: LD_ADDR_VAR 0 9
86201: PUSH
86202: LD_INT 4
86204: ST_TO_ADDR
// for i := 1 to 5 do
86205: LD_ADDR_VAR 0 10
86209: PUSH
86210: DOUBLE
86211: LD_INT 1
86213: DEC
86214: ST_TO_ADDR
86215: LD_INT 5
86217: PUSH
86218: FOR_TO
86219: IFFALSE 86376
// begin _x := ShiftX ( x , d , r + i ) ;
86221: LD_ADDR_VAR 0 5
86225: PUSH
86226: LD_VAR 0 4
86230: PPUSH
86231: LD_VAR 0 8
86235: PPUSH
86236: LD_VAR 0 9
86240: PUSH
86241: LD_VAR 0 10
86245: PLUS
86246: PPUSH
86247: CALL_OW 272
86251: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
86252: LD_ADDR_VAR 0 7
86256: PUSH
86257: LD_VAR 0 6
86261: PPUSH
86262: LD_VAR 0 8
86266: PPUSH
86267: LD_VAR 0 9
86271: PUSH
86272: LD_VAR 0 10
86276: PLUS
86277: PPUSH
86278: CALL_OW 273
86282: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
86283: LD_VAR 0 5
86287: PPUSH
86288: LD_VAR 0 7
86292: PPUSH
86293: CALL_OW 488
86297: PUSH
86298: LD_VAR 0 5
86302: PPUSH
86303: LD_VAR 0 7
86307: PPUSH
86308: CALL_OW 428
86312: PPUSH
86313: CALL_OW 247
86317: PUSH
86318: LD_INT 3
86320: PUSH
86321: LD_INT 2
86323: PUSH
86324: EMPTY
86325: LIST
86326: LIST
86327: IN
86328: NOT
86329: AND
86330: IFFALSE 86374
// begin ComMoveXY ( unit , _x , _y ) ;
86332: LD_VAR 0 1
86336: PPUSH
86337: LD_VAR 0 5
86341: PPUSH
86342: LD_VAR 0 7
86346: PPUSH
86347: CALL_OW 111
// result := [ _x , _y ] ;
86351: LD_ADDR_VAR 0 3
86355: PUSH
86356: LD_VAR 0 5
86360: PUSH
86361: LD_VAR 0 7
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: ST_TO_ADDR
// exit ;
86370: POP
86371: POP
86372: GO 86378
// end ; end ;
86374: GO 86218
86376: POP
86377: POP
// end ;
86378: LD_VAR 0 3
86382: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
86383: LD_INT 0
86385: PPUSH
86386: PPUSH
86387: PPUSH
// result := 0 ;
86388: LD_ADDR_VAR 0 3
86392: PUSH
86393: LD_INT 0
86395: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
86396: LD_VAR 0 1
86400: PUSH
86401: LD_INT 0
86403: LESS
86404: PUSH
86405: LD_VAR 0 1
86409: PUSH
86410: LD_INT 8
86412: GREATER
86413: OR
86414: PUSH
86415: LD_VAR 0 2
86419: PUSH
86420: LD_INT 0
86422: LESS
86423: OR
86424: PUSH
86425: LD_VAR 0 2
86429: PUSH
86430: LD_INT 8
86432: GREATER
86433: OR
86434: IFFALSE 86438
// exit ;
86436: GO 86513
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
86438: LD_ADDR_VAR 0 4
86442: PUSH
86443: LD_INT 22
86445: PUSH
86446: LD_VAR 0 2
86450: PUSH
86451: EMPTY
86452: LIST
86453: LIST
86454: PPUSH
86455: CALL_OW 69
86459: PUSH
86460: FOR_IN
86461: IFFALSE 86511
// begin un := UnitShoot ( i ) ;
86463: LD_ADDR_VAR 0 5
86467: PUSH
86468: LD_VAR 0 4
86472: PPUSH
86473: CALL_OW 504
86477: ST_TO_ADDR
// if GetSide ( un ) = side1 then
86478: LD_VAR 0 5
86482: PPUSH
86483: CALL_OW 255
86487: PUSH
86488: LD_VAR 0 1
86492: EQUAL
86493: IFFALSE 86509
// begin result := un ;
86495: LD_ADDR_VAR 0 3
86499: PUSH
86500: LD_VAR 0 5
86504: ST_TO_ADDR
// exit ;
86505: POP
86506: POP
86507: GO 86513
// end ; end ;
86509: GO 86460
86511: POP
86512: POP
// end ;
86513: LD_VAR 0 3
86517: RET
// export function GetCargoBay ( units ) ; begin
86518: LD_INT 0
86520: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
86521: LD_ADDR_VAR 0 2
86525: PUSH
86526: LD_VAR 0 1
86530: PPUSH
86531: LD_INT 2
86533: PUSH
86534: LD_INT 34
86536: PUSH
86537: LD_INT 12
86539: PUSH
86540: EMPTY
86541: LIST
86542: LIST
86543: PUSH
86544: LD_INT 34
86546: PUSH
86547: LD_INT 51
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: LD_INT 34
86556: PUSH
86557: LD_INT 32
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: LD_INT 34
86566: PUSH
86567: LD_EXP 95
86571: PUSH
86572: EMPTY
86573: LIST
86574: LIST
86575: PUSH
86576: EMPTY
86577: LIST
86578: LIST
86579: LIST
86580: LIST
86581: LIST
86582: PPUSH
86583: CALL_OW 72
86587: ST_TO_ADDR
// end ;
86588: LD_VAR 0 2
86592: RET
// export function Negate ( value ) ; begin
86593: LD_INT 0
86595: PPUSH
// result := not value ;
86596: LD_ADDR_VAR 0 2
86600: PUSH
86601: LD_VAR 0 1
86605: NOT
86606: ST_TO_ADDR
// end ;
86607: LD_VAR 0 2
86611: RET
// export function Inc ( value ) ; begin
86612: LD_INT 0
86614: PPUSH
// result := value + 1 ;
86615: LD_ADDR_VAR 0 2
86619: PUSH
86620: LD_VAR 0 1
86624: PUSH
86625: LD_INT 1
86627: PLUS
86628: ST_TO_ADDR
// end ;
86629: LD_VAR 0 2
86633: RET
// export function Dec ( value ) ; begin
86634: LD_INT 0
86636: PPUSH
// result := value - 1 ;
86637: LD_ADDR_VAR 0 2
86641: PUSH
86642: LD_VAR 0 1
86646: PUSH
86647: LD_INT 1
86649: MINUS
86650: ST_TO_ADDR
// end ;
86651: LD_VAR 0 2
86655: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
86656: LD_INT 0
86658: PPUSH
86659: PPUSH
86660: PPUSH
86661: PPUSH
86662: PPUSH
86663: PPUSH
86664: PPUSH
86665: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
86666: LD_VAR 0 1
86670: PPUSH
86671: LD_VAR 0 2
86675: PPUSH
86676: CALL_OW 488
86680: NOT
86681: PUSH
86682: LD_VAR 0 3
86686: PPUSH
86687: LD_VAR 0 4
86691: PPUSH
86692: CALL_OW 488
86696: NOT
86697: OR
86698: IFFALSE 86711
// begin result := - 1 ;
86700: LD_ADDR_VAR 0 5
86704: PUSH
86705: LD_INT 1
86707: NEG
86708: ST_TO_ADDR
// exit ;
86709: GO 86946
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
86711: LD_ADDR_VAR 0 12
86715: PUSH
86716: LD_VAR 0 1
86720: PPUSH
86721: LD_VAR 0 2
86725: PPUSH
86726: LD_VAR 0 3
86730: PPUSH
86731: LD_VAR 0 4
86735: PPUSH
86736: CALL 85794 0 4
86740: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
86741: LD_ADDR_VAR 0 11
86745: PUSH
86746: LD_VAR 0 1
86750: PPUSH
86751: LD_VAR 0 2
86755: PPUSH
86756: LD_VAR 0 12
86760: PUSH
86761: LD_INT 1
86763: ARRAY
86764: PPUSH
86765: LD_VAR 0 12
86769: PUSH
86770: LD_INT 2
86772: ARRAY
86773: PPUSH
86774: CALL_OW 298
86778: ST_TO_ADDR
// distance := 9999 ;
86779: LD_ADDR_VAR 0 10
86783: PUSH
86784: LD_INT 9999
86786: ST_TO_ADDR
// for i := 0 to 5 do
86787: LD_ADDR_VAR 0 6
86791: PUSH
86792: DOUBLE
86793: LD_INT 0
86795: DEC
86796: ST_TO_ADDR
86797: LD_INT 5
86799: PUSH
86800: FOR_TO
86801: IFFALSE 86944
// begin _x := ShiftX ( x1 , i , centerDist ) ;
86803: LD_ADDR_VAR 0 7
86807: PUSH
86808: LD_VAR 0 1
86812: PPUSH
86813: LD_VAR 0 6
86817: PPUSH
86818: LD_VAR 0 11
86822: PPUSH
86823: CALL_OW 272
86827: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
86828: LD_ADDR_VAR 0 8
86832: PUSH
86833: LD_VAR 0 2
86837: PPUSH
86838: LD_VAR 0 6
86842: PPUSH
86843: LD_VAR 0 11
86847: PPUSH
86848: CALL_OW 273
86852: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
86853: LD_VAR 0 7
86857: PPUSH
86858: LD_VAR 0 8
86862: PPUSH
86863: CALL_OW 488
86867: NOT
86868: IFFALSE 86872
// continue ;
86870: GO 86800
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
86872: LD_ADDR_VAR 0 9
86876: PUSH
86877: LD_VAR 0 12
86881: PUSH
86882: LD_INT 1
86884: ARRAY
86885: PPUSH
86886: LD_VAR 0 12
86890: PUSH
86891: LD_INT 2
86893: ARRAY
86894: PPUSH
86895: LD_VAR 0 7
86899: PPUSH
86900: LD_VAR 0 8
86904: PPUSH
86905: CALL_OW 298
86909: ST_TO_ADDR
// if tmp < distance then
86910: LD_VAR 0 9
86914: PUSH
86915: LD_VAR 0 10
86919: LESS
86920: IFFALSE 86942
// begin result := i ;
86922: LD_ADDR_VAR 0 5
86926: PUSH
86927: LD_VAR 0 6
86931: ST_TO_ADDR
// distance := tmp ;
86932: LD_ADDR_VAR 0 10
86936: PUSH
86937: LD_VAR 0 9
86941: ST_TO_ADDR
// end ; end ;
86942: GO 86800
86944: POP
86945: POP
// end ;
86946: LD_VAR 0 5
86950: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
86951: LD_INT 0
86953: PPUSH
86954: PPUSH
// if not driver or not IsInUnit ( driver ) then
86955: LD_VAR 0 1
86959: NOT
86960: PUSH
86961: LD_VAR 0 1
86965: PPUSH
86966: CALL_OW 310
86970: NOT
86971: OR
86972: IFFALSE 86976
// exit ;
86974: GO 87066
// vehicle := IsInUnit ( driver ) ;
86976: LD_ADDR_VAR 0 3
86980: PUSH
86981: LD_VAR 0 1
86985: PPUSH
86986: CALL_OW 310
86990: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
86991: LD_VAR 0 1
86995: PPUSH
86996: LD_STRING \
86998: PUSH
86999: LD_INT 0
87001: PUSH
87002: LD_INT 0
87004: PUSH
87005: LD_INT 0
87007: PUSH
87008: LD_INT 0
87010: PUSH
87011: LD_INT 0
87013: PUSH
87014: LD_INT 0
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: LIST
87024: LIST
87025: PUSH
87026: LD_STRING E
87028: PUSH
87029: LD_INT 0
87031: PUSH
87032: LD_INT 0
87034: PUSH
87035: LD_VAR 0 3
87039: PUSH
87040: LD_INT 0
87042: PUSH
87043: LD_INT 0
87045: PUSH
87046: LD_INT 0
87048: PUSH
87049: EMPTY
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: PUSH
87058: EMPTY
87059: LIST
87060: LIST
87061: PPUSH
87062: CALL_OW 446
// end ;
87066: LD_VAR 0 2
87070: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87071: LD_INT 0
87073: PPUSH
87074: PPUSH
// if not driver or not IsInUnit ( driver ) then
87075: LD_VAR 0 1
87079: NOT
87080: PUSH
87081: LD_VAR 0 1
87085: PPUSH
87086: CALL_OW 310
87090: NOT
87091: OR
87092: IFFALSE 87096
// exit ;
87094: GO 87186
// vehicle := IsInUnit ( driver ) ;
87096: LD_ADDR_VAR 0 3
87100: PUSH
87101: LD_VAR 0 1
87105: PPUSH
87106: CALL_OW 310
87110: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87111: LD_VAR 0 1
87115: PPUSH
87116: LD_STRING \
87118: PUSH
87119: LD_INT 0
87121: PUSH
87122: LD_INT 0
87124: PUSH
87125: LD_INT 0
87127: PUSH
87128: LD_INT 0
87130: PUSH
87131: LD_INT 0
87133: PUSH
87134: LD_INT 0
87136: PUSH
87137: EMPTY
87138: LIST
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: LIST
87144: LIST
87145: PUSH
87146: LD_STRING E
87148: PUSH
87149: LD_INT 0
87151: PUSH
87152: LD_INT 0
87154: PUSH
87155: LD_VAR 0 3
87159: PUSH
87160: LD_INT 0
87162: PUSH
87163: LD_INT 0
87165: PUSH
87166: LD_INT 0
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: LIST
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: PUSH
87178: EMPTY
87179: LIST
87180: LIST
87181: PPUSH
87182: CALL_OW 447
// end ;
87186: LD_VAR 0 2
87190: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
87191: LD_INT 0
87193: PPUSH
87194: PPUSH
87195: PPUSH
// tmp := [ ] ;
87196: LD_ADDR_VAR 0 5
87200: PUSH
87201: EMPTY
87202: ST_TO_ADDR
// for i in units do
87203: LD_ADDR_VAR 0 4
87207: PUSH
87208: LD_VAR 0 1
87212: PUSH
87213: FOR_IN
87214: IFFALSE 87252
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
87216: LD_ADDR_VAR 0 5
87220: PUSH
87221: LD_VAR 0 5
87225: PPUSH
87226: LD_VAR 0 5
87230: PUSH
87231: LD_INT 1
87233: PLUS
87234: PPUSH
87235: LD_VAR 0 4
87239: PPUSH
87240: CALL_OW 256
87244: PPUSH
87245: CALL_OW 2
87249: ST_TO_ADDR
87250: GO 87213
87252: POP
87253: POP
// if not tmp then
87254: LD_VAR 0 5
87258: NOT
87259: IFFALSE 87263
// exit ;
87261: GO 87311
// if asc then
87263: LD_VAR 0 2
87267: IFFALSE 87291
// result := SortListByListAsc ( units , tmp ) else
87269: LD_ADDR_VAR 0 3
87273: PUSH
87274: LD_VAR 0 1
87278: PPUSH
87279: LD_VAR 0 5
87283: PPUSH
87284: CALL_OW 76
87288: ST_TO_ADDR
87289: GO 87311
// result := SortListByListDesc ( units , tmp ) ;
87291: LD_ADDR_VAR 0 3
87295: PUSH
87296: LD_VAR 0 1
87300: PPUSH
87301: LD_VAR 0 5
87305: PPUSH
87306: CALL_OW 77
87310: ST_TO_ADDR
// end ;
87311: LD_VAR 0 3
87315: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
87316: LD_INT 0
87318: PPUSH
87319: PPUSH
// task := GetTaskList ( mech ) ;
87320: LD_ADDR_VAR 0 4
87324: PUSH
87325: LD_VAR 0 1
87329: PPUSH
87330: CALL_OW 437
87334: ST_TO_ADDR
// if not task then
87335: LD_VAR 0 4
87339: NOT
87340: IFFALSE 87344
// exit ;
87342: GO 87386
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
87344: LD_ADDR_VAR 0 3
87348: PUSH
87349: LD_VAR 0 4
87353: PUSH
87354: LD_INT 1
87356: ARRAY
87357: PUSH
87358: LD_INT 1
87360: ARRAY
87361: PUSH
87362: LD_STRING r
87364: EQUAL
87365: PUSH
87366: LD_VAR 0 4
87370: PUSH
87371: LD_INT 1
87373: ARRAY
87374: PUSH
87375: LD_INT 4
87377: ARRAY
87378: PUSH
87379: LD_VAR 0 2
87383: EQUAL
87384: AND
87385: ST_TO_ADDR
// end ;
87386: LD_VAR 0 3
87390: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
87391: LD_INT 0
87393: PPUSH
// SetDir ( unit , d ) ;
87394: LD_VAR 0 1
87398: PPUSH
87399: LD_VAR 0 4
87403: PPUSH
87404: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
87408: LD_VAR 0 1
87412: PPUSH
87413: LD_VAR 0 2
87417: PPUSH
87418: LD_VAR 0 3
87422: PPUSH
87423: LD_VAR 0 5
87427: PPUSH
87428: CALL_OW 48
// end ;
87432: LD_VAR 0 6
87436: RET
// export function ToNaturalNumber ( number ) ; begin
87437: LD_INT 0
87439: PPUSH
// result := number div 1 ;
87440: LD_ADDR_VAR 0 2
87444: PUSH
87445: LD_VAR 0 1
87449: PUSH
87450: LD_INT 1
87452: DIV
87453: ST_TO_ADDR
// if number < 0 then
87454: LD_VAR 0 1
87458: PUSH
87459: LD_INT 0
87461: LESS
87462: IFFALSE 87472
// result := 0 ;
87464: LD_ADDR_VAR 0 2
87468: PUSH
87469: LD_INT 0
87471: ST_TO_ADDR
// end ;
87472: LD_VAR 0 2
87476: RET
// export function SortByClass ( units , class ) ; var un ; begin
87477: LD_INT 0
87479: PPUSH
87480: PPUSH
// if not units or not class then
87481: LD_VAR 0 1
87485: NOT
87486: PUSH
87487: LD_VAR 0 2
87491: NOT
87492: OR
87493: IFFALSE 87497
// exit ;
87495: GO 87592
// result := [ ] ;
87497: LD_ADDR_VAR 0 3
87501: PUSH
87502: EMPTY
87503: ST_TO_ADDR
// for un in units do
87504: LD_ADDR_VAR 0 4
87508: PUSH
87509: LD_VAR 0 1
87513: PUSH
87514: FOR_IN
87515: IFFALSE 87590
// if GetClass ( un ) = class then
87517: LD_VAR 0 4
87521: PPUSH
87522: CALL_OW 257
87526: PUSH
87527: LD_VAR 0 2
87531: EQUAL
87532: IFFALSE 87559
// result := Insert ( result , 1 , un ) else
87534: LD_ADDR_VAR 0 3
87538: PUSH
87539: LD_VAR 0 3
87543: PPUSH
87544: LD_INT 1
87546: PPUSH
87547: LD_VAR 0 4
87551: PPUSH
87552: CALL_OW 2
87556: ST_TO_ADDR
87557: GO 87588
// result := Replace ( result , result + 1 , un ) ;
87559: LD_ADDR_VAR 0 3
87563: PUSH
87564: LD_VAR 0 3
87568: PPUSH
87569: LD_VAR 0 3
87573: PUSH
87574: LD_INT 1
87576: PLUS
87577: PPUSH
87578: LD_VAR 0 4
87582: PPUSH
87583: CALL_OW 1
87587: ST_TO_ADDR
87588: GO 87514
87590: POP
87591: POP
// end ;
87592: LD_VAR 0 3
87596: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
87597: LD_INT 0
87599: PPUSH
87600: PPUSH
87601: PPUSH
87602: PPUSH
87603: PPUSH
87604: PPUSH
87605: PPUSH
// result := [ ] ;
87606: LD_ADDR_VAR 0 4
87610: PUSH
87611: EMPTY
87612: ST_TO_ADDR
// if x - r < 0 then
87613: LD_VAR 0 1
87617: PUSH
87618: LD_VAR 0 3
87622: MINUS
87623: PUSH
87624: LD_INT 0
87626: LESS
87627: IFFALSE 87639
// min_x := 0 else
87629: LD_ADDR_VAR 0 8
87633: PUSH
87634: LD_INT 0
87636: ST_TO_ADDR
87637: GO 87655
// min_x := x - r ;
87639: LD_ADDR_VAR 0 8
87643: PUSH
87644: LD_VAR 0 1
87648: PUSH
87649: LD_VAR 0 3
87653: MINUS
87654: ST_TO_ADDR
// if y - r < 0 then
87655: LD_VAR 0 2
87659: PUSH
87660: LD_VAR 0 3
87664: MINUS
87665: PUSH
87666: LD_INT 0
87668: LESS
87669: IFFALSE 87681
// min_y := 0 else
87671: LD_ADDR_VAR 0 7
87675: PUSH
87676: LD_INT 0
87678: ST_TO_ADDR
87679: GO 87697
// min_y := y - r ;
87681: LD_ADDR_VAR 0 7
87685: PUSH
87686: LD_VAR 0 2
87690: PUSH
87691: LD_VAR 0 3
87695: MINUS
87696: ST_TO_ADDR
// max_x := x + r ;
87697: LD_ADDR_VAR 0 9
87701: PUSH
87702: LD_VAR 0 1
87706: PUSH
87707: LD_VAR 0 3
87711: PLUS
87712: ST_TO_ADDR
// max_y := y + r ;
87713: LD_ADDR_VAR 0 10
87717: PUSH
87718: LD_VAR 0 2
87722: PUSH
87723: LD_VAR 0 3
87727: PLUS
87728: ST_TO_ADDR
// for _x = min_x to max_x do
87729: LD_ADDR_VAR 0 5
87733: PUSH
87734: DOUBLE
87735: LD_VAR 0 8
87739: DEC
87740: ST_TO_ADDR
87741: LD_VAR 0 9
87745: PUSH
87746: FOR_TO
87747: IFFALSE 87848
// for _y = min_y to max_y do
87749: LD_ADDR_VAR 0 6
87753: PUSH
87754: DOUBLE
87755: LD_VAR 0 7
87759: DEC
87760: ST_TO_ADDR
87761: LD_VAR 0 10
87765: PUSH
87766: FOR_TO
87767: IFFALSE 87844
// begin if not ValidHex ( _x , _y ) then
87769: LD_VAR 0 5
87773: PPUSH
87774: LD_VAR 0 6
87778: PPUSH
87779: CALL_OW 488
87783: NOT
87784: IFFALSE 87788
// continue ;
87786: GO 87766
// if GetResourceTypeXY ( _x , _y ) then
87788: LD_VAR 0 5
87792: PPUSH
87793: LD_VAR 0 6
87797: PPUSH
87798: CALL_OW 283
87802: IFFALSE 87842
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
87804: LD_ADDR_VAR 0 4
87808: PUSH
87809: LD_VAR 0 4
87813: PPUSH
87814: LD_VAR 0 4
87818: PUSH
87819: LD_INT 1
87821: PLUS
87822: PPUSH
87823: LD_VAR 0 5
87827: PUSH
87828: LD_VAR 0 6
87832: PUSH
87833: EMPTY
87834: LIST
87835: LIST
87836: PPUSH
87837: CALL_OW 1
87841: ST_TO_ADDR
// end ;
87842: GO 87766
87844: POP
87845: POP
87846: GO 87746
87848: POP
87849: POP
// end ;
87850: LD_VAR 0 4
87854: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
87855: LD_INT 0
87857: PPUSH
87858: PPUSH
87859: PPUSH
87860: PPUSH
87861: PPUSH
87862: PPUSH
87863: PPUSH
87864: PPUSH
// if not units then
87865: LD_VAR 0 1
87869: NOT
87870: IFFALSE 87874
// exit ;
87872: GO 88299
// result := UnitFilter ( units , [ f_ok ] ) ;
87874: LD_ADDR_VAR 0 3
87878: PUSH
87879: LD_VAR 0 1
87883: PPUSH
87884: LD_INT 50
87886: PUSH
87887: EMPTY
87888: LIST
87889: PPUSH
87890: CALL_OW 72
87894: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
87895: LD_ADDR_VAR 0 8
87899: PUSH
87900: LD_VAR 0 1
87904: PUSH
87905: LD_INT 1
87907: ARRAY
87908: PPUSH
87909: CALL_OW 255
87913: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
87914: LD_ADDR_VAR 0 10
87918: PUSH
87919: LD_INT 29
87921: PUSH
87922: LD_EXP 98
87926: PUSH
87927: EMPTY
87928: LIST
87929: LIST
87930: ST_TO_ADDR
// if not result then
87931: LD_VAR 0 3
87935: NOT
87936: IFFALSE 87940
// exit ;
87938: GO 88299
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
87940: LD_ADDR_VAR 0 5
87944: PUSH
87945: LD_INT 81
87947: PUSH
87948: LD_VAR 0 8
87952: PUSH
87953: EMPTY
87954: LIST
87955: LIST
87956: PPUSH
87957: CALL_OW 69
87961: ST_TO_ADDR
// for i in result do
87962: LD_ADDR_VAR 0 4
87966: PUSH
87967: LD_VAR 0 3
87971: PUSH
87972: FOR_IN
87973: IFFALSE 88297
// begin tag := GetTag ( i ) + 1 ;
87975: LD_ADDR_VAR 0 9
87979: PUSH
87980: LD_VAR 0 4
87984: PPUSH
87985: CALL_OW 110
87989: PUSH
87990: LD_INT 1
87992: PLUS
87993: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
87994: LD_ADDR_VAR 0 7
87998: PUSH
87999: LD_VAR 0 4
88003: PPUSH
88004: CALL_OW 250
88008: PPUSH
88009: LD_VAR 0 4
88013: PPUSH
88014: CALL_OW 251
88018: PPUSH
88019: LD_INT 6
88021: PPUSH
88022: CALL 87597 0 3
88026: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
88027: LD_VAR 0 7
88031: PUSH
88032: LD_VAR 0 4
88036: PPUSH
88037: CALL_OW 264
88041: PUSH
88042: LD_VAR 0 10
88046: IN
88047: NOT
88048: AND
88049: IFFALSE 88088
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
88051: LD_VAR 0 4
88055: PPUSH
88056: LD_VAR 0 7
88060: PUSH
88061: LD_INT 1
88063: ARRAY
88064: PUSH
88065: LD_INT 1
88067: ARRAY
88068: PPUSH
88069: LD_VAR 0 7
88073: PUSH
88074: LD_INT 1
88076: ARRAY
88077: PUSH
88078: LD_INT 2
88080: ARRAY
88081: PPUSH
88082: CALL_OW 116
88086: GO 88295
// if path > tag then
88088: LD_VAR 0 2
88092: PUSH
88093: LD_VAR 0 9
88097: GREATER
88098: IFFALSE 88265
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
88100: LD_ADDR_VAR 0 6
88104: PUSH
88105: LD_VAR 0 5
88109: PPUSH
88110: LD_INT 91
88112: PUSH
88113: LD_VAR 0 4
88117: PUSH
88118: LD_INT 12
88120: PUSH
88121: EMPTY
88122: LIST
88123: LIST
88124: LIST
88125: PPUSH
88126: CALL_OW 72
88130: ST_TO_ADDR
// if nearEnemy then
88131: LD_VAR 0 6
88135: IFFALSE 88163
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
88137: LD_VAR 0 4
88141: PPUSH
88142: LD_VAR 0 6
88146: PPUSH
88147: LD_VAR 0 4
88151: PPUSH
88152: CALL_OW 74
88156: PPUSH
88157: CALL_OW 115
88161: GO 88263
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
88163: LD_VAR 0 4
88167: PPUSH
88168: LD_VAR 0 2
88172: PUSH
88173: LD_VAR 0 9
88177: ARRAY
88178: PUSH
88179: LD_INT 1
88181: ARRAY
88182: PPUSH
88183: LD_VAR 0 2
88187: PUSH
88188: LD_VAR 0 9
88192: ARRAY
88193: PUSH
88194: LD_INT 2
88196: ARRAY
88197: PPUSH
88198: CALL_OW 297
88202: PUSH
88203: LD_INT 6
88205: GREATER
88206: IFFALSE 88249
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
88208: LD_VAR 0 4
88212: PPUSH
88213: LD_VAR 0 2
88217: PUSH
88218: LD_VAR 0 9
88222: ARRAY
88223: PUSH
88224: LD_INT 1
88226: ARRAY
88227: PPUSH
88228: LD_VAR 0 2
88232: PUSH
88233: LD_VAR 0 9
88237: ARRAY
88238: PUSH
88239: LD_INT 2
88241: ARRAY
88242: PPUSH
88243: CALL_OW 114
88247: GO 88263
// SetTag ( i , tag ) ;
88249: LD_VAR 0 4
88253: PPUSH
88254: LD_VAR 0 9
88258: PPUSH
88259: CALL_OW 109
// end else
88263: GO 88295
// if enemy then
88265: LD_VAR 0 5
88269: IFFALSE 88295
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
88271: LD_VAR 0 4
88275: PPUSH
88276: LD_VAR 0 5
88280: PPUSH
88281: LD_VAR 0 4
88285: PPUSH
88286: CALL_OW 74
88290: PPUSH
88291: CALL_OW 115
// end ;
88295: GO 87972
88297: POP
88298: POP
// end ;
88299: LD_VAR 0 3
88303: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
88304: LD_INT 0
88306: PPUSH
88307: PPUSH
88308: PPUSH
// if not unit or IsInUnit ( unit ) then
88309: LD_VAR 0 1
88313: NOT
88314: PUSH
88315: LD_VAR 0 1
88319: PPUSH
88320: CALL_OW 310
88324: OR
88325: IFFALSE 88329
// exit ;
88327: GO 88420
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
88329: LD_ADDR_VAR 0 4
88333: PUSH
88334: LD_VAR 0 1
88338: PPUSH
88339: CALL_OW 250
88343: PPUSH
88344: LD_VAR 0 2
88348: PPUSH
88349: LD_INT 1
88351: PPUSH
88352: CALL_OW 272
88356: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
88357: LD_ADDR_VAR 0 5
88361: PUSH
88362: LD_VAR 0 1
88366: PPUSH
88367: CALL_OW 251
88371: PPUSH
88372: LD_VAR 0 2
88376: PPUSH
88377: LD_INT 1
88379: PPUSH
88380: CALL_OW 273
88384: ST_TO_ADDR
// if ValidHex ( x , y ) then
88385: LD_VAR 0 4
88389: PPUSH
88390: LD_VAR 0 5
88394: PPUSH
88395: CALL_OW 488
88399: IFFALSE 88420
// ComTurnXY ( unit , x , y ) ;
88401: LD_VAR 0 1
88405: PPUSH
88406: LD_VAR 0 4
88410: PPUSH
88411: LD_VAR 0 5
88415: PPUSH
88416: CALL_OW 118
// end ;
88420: LD_VAR 0 3
88424: RET
// export function SeeUnits ( side , units ) ; var i ; begin
88425: LD_INT 0
88427: PPUSH
88428: PPUSH
// result := false ;
88429: LD_ADDR_VAR 0 3
88433: PUSH
88434: LD_INT 0
88436: ST_TO_ADDR
// if not units then
88437: LD_VAR 0 2
88441: NOT
88442: IFFALSE 88446
// exit ;
88444: GO 88491
// for i in units do
88446: LD_ADDR_VAR 0 4
88450: PUSH
88451: LD_VAR 0 2
88455: PUSH
88456: FOR_IN
88457: IFFALSE 88489
// if See ( side , i ) then
88459: LD_VAR 0 1
88463: PPUSH
88464: LD_VAR 0 4
88468: PPUSH
88469: CALL_OW 292
88473: IFFALSE 88487
// begin result := true ;
88475: LD_ADDR_VAR 0 3
88479: PUSH
88480: LD_INT 1
88482: ST_TO_ADDR
// exit ;
88483: POP
88484: POP
88485: GO 88491
// end ;
88487: GO 88456
88489: POP
88490: POP
// end ;
88491: LD_VAR 0 3
88495: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
88496: LD_INT 0
88498: PPUSH
88499: PPUSH
88500: PPUSH
88501: PPUSH
// if not unit or not points then
88502: LD_VAR 0 1
88506: NOT
88507: PUSH
88508: LD_VAR 0 2
88512: NOT
88513: OR
88514: IFFALSE 88518
// exit ;
88516: GO 88608
// dist := 99999 ;
88518: LD_ADDR_VAR 0 5
88522: PUSH
88523: LD_INT 99999
88525: ST_TO_ADDR
// for i in points do
88526: LD_ADDR_VAR 0 4
88530: PUSH
88531: LD_VAR 0 2
88535: PUSH
88536: FOR_IN
88537: IFFALSE 88606
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
88539: LD_ADDR_VAR 0 6
88543: PUSH
88544: LD_VAR 0 1
88548: PPUSH
88549: LD_VAR 0 4
88553: PUSH
88554: LD_INT 1
88556: ARRAY
88557: PPUSH
88558: LD_VAR 0 4
88562: PUSH
88563: LD_INT 2
88565: ARRAY
88566: PPUSH
88567: CALL_OW 297
88571: ST_TO_ADDR
// if tmpDist < dist then
88572: LD_VAR 0 6
88576: PUSH
88577: LD_VAR 0 5
88581: LESS
88582: IFFALSE 88604
// begin result := i ;
88584: LD_ADDR_VAR 0 3
88588: PUSH
88589: LD_VAR 0 4
88593: ST_TO_ADDR
// dist := tmpDist ;
88594: LD_ADDR_VAR 0 5
88598: PUSH
88599: LD_VAR 0 6
88603: ST_TO_ADDR
// end ; end ;
88604: GO 88536
88606: POP
88607: POP
// end ; end_of_file
88608: LD_VAR 0 3
88612: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
88613: LD_INT 0
88615: PPUSH
// ar_miner := 81 ;
88616: LD_ADDR_EXP 101
88620: PUSH
88621: LD_INT 81
88623: ST_TO_ADDR
// ar_crane := 88 ;
88624: LD_ADDR_EXP 100
88628: PUSH
88629: LD_INT 88
88631: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
88632: LD_ADDR_EXP 95
88636: PUSH
88637: LD_INT 89
88639: ST_TO_ADDR
// us_hack := 99 ;
88640: LD_ADDR_EXP 96
88644: PUSH
88645: LD_INT 99
88647: ST_TO_ADDR
// us_artillery := 97 ;
88648: LD_ADDR_EXP 97
88652: PUSH
88653: LD_INT 97
88655: ST_TO_ADDR
// ar_bio_bomb := 91 ;
88656: LD_ADDR_EXP 98
88660: PUSH
88661: LD_INT 91
88663: ST_TO_ADDR
// ar_mortar := 92 ;
88664: LD_ADDR_EXP 99
88668: PUSH
88669: LD_INT 92
88671: ST_TO_ADDR
// ru_radar := 98 ;
88672: LD_ADDR_EXP 94
88676: PUSH
88677: LD_INT 98
88679: ST_TO_ADDR
// tech_Artillery := 80 ;
88680: LD_ADDR_EXP 102
88684: PUSH
88685: LD_INT 80
88687: ST_TO_ADDR
// tech_RadMat := 81 ;
88688: LD_ADDR_EXP 103
88692: PUSH
88693: LD_INT 81
88695: ST_TO_ADDR
// tech_BasicTools := 82 ;
88696: LD_ADDR_EXP 104
88700: PUSH
88701: LD_INT 82
88703: ST_TO_ADDR
// tech_Cargo := 83 ;
88704: LD_ADDR_EXP 105
88708: PUSH
88709: LD_INT 83
88711: ST_TO_ADDR
// tech_Track := 84 ;
88712: LD_ADDR_EXP 106
88716: PUSH
88717: LD_INT 84
88719: ST_TO_ADDR
// tech_Crane := 85 ;
88720: LD_ADDR_EXP 107
88724: PUSH
88725: LD_INT 85
88727: ST_TO_ADDR
// tech_Bulldozer := 86 ;
88728: LD_ADDR_EXP 108
88732: PUSH
88733: LD_INT 86
88735: ST_TO_ADDR
// tech_Hovercraft := 87 ;
88736: LD_ADDR_EXP 109
88740: PUSH
88741: LD_INT 87
88743: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
88744: LD_ADDR_EXP 110
88748: PUSH
88749: LD_INT 88
88751: ST_TO_ADDR
// class_mastodont := 31 ;
88752: LD_ADDR_EXP 111
88756: PUSH
88757: LD_INT 31
88759: ST_TO_ADDR
// class_horse := 21 ;
88760: LD_ADDR_EXP 112
88764: PUSH
88765: LD_INT 21
88767: ST_TO_ADDR
// end ;
88768: LD_VAR 0 1
88772: RET
// every 1 do
88773: GO 88775
88775: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
88776: CALL 88613 0 0
88780: END
// every 0 0$1 do
88781: GO 88783
88783: DISABLE
// begin enable ;
88784: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
88785: LD_STRING updateTimer(
88787: PUSH
88788: LD_OWVAR 1
88792: STR
88793: PUSH
88794: LD_STRING );
88796: STR
88797: PPUSH
88798: CALL_OW 559
// end ;
88802: END
// export function SOS_MapStart ( ) ; begin
88803: LD_INT 0
88805: PPUSH
// if streamModeActive then
88806: LD_EXP 113
88810: IFFALSE 88819
// DefineStreamItems ( true ) ;
88812: LD_INT 1
88814: PPUSH
88815: CALL 90469 0 1
// UpdateFactoryWaypoints ( ) ;
88819: CALL 104053 0 0
// end ;
88823: LD_VAR 0 1
88827: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
88828: LD_INT 0
88830: PPUSH
// if p2 = 100 then
88831: LD_VAR 0 2
88835: PUSH
88836: LD_INT 100
88838: EQUAL
88839: IFFALSE 89842
// begin if not StreamModeActive then
88841: LD_EXP 113
88845: NOT
88846: IFFALSE 88856
// StreamModeActive := true ;
88848: LD_ADDR_EXP 113
88852: PUSH
88853: LD_INT 1
88855: ST_TO_ADDR
// if p3 = 0 then
88856: LD_VAR 0 3
88860: PUSH
88861: LD_INT 0
88863: EQUAL
88864: IFFALSE 88870
// InitStreamMode ;
88866: CALL 90005 0 0
// if p3 = 1 then
88870: LD_VAR 0 3
88874: PUSH
88875: LD_INT 1
88877: EQUAL
88878: IFFALSE 88888
// sRocket := true ;
88880: LD_ADDR_EXP 118
88884: PUSH
88885: LD_INT 1
88887: ST_TO_ADDR
// if p3 = 2 then
88888: LD_VAR 0 3
88892: PUSH
88893: LD_INT 2
88895: EQUAL
88896: IFFALSE 88906
// sSpeed := true ;
88898: LD_ADDR_EXP 117
88902: PUSH
88903: LD_INT 1
88905: ST_TO_ADDR
// if p3 = 3 then
88906: LD_VAR 0 3
88910: PUSH
88911: LD_INT 3
88913: EQUAL
88914: IFFALSE 88924
// sEngine := true ;
88916: LD_ADDR_EXP 119
88920: PUSH
88921: LD_INT 1
88923: ST_TO_ADDR
// if p3 = 4 then
88924: LD_VAR 0 3
88928: PUSH
88929: LD_INT 4
88931: EQUAL
88932: IFFALSE 88942
// sSpec := true ;
88934: LD_ADDR_EXP 116
88938: PUSH
88939: LD_INT 1
88941: ST_TO_ADDR
// if p3 = 5 then
88942: LD_VAR 0 3
88946: PUSH
88947: LD_INT 5
88949: EQUAL
88950: IFFALSE 88960
// sLevel := true ;
88952: LD_ADDR_EXP 120
88956: PUSH
88957: LD_INT 1
88959: ST_TO_ADDR
// if p3 = 6 then
88960: LD_VAR 0 3
88964: PUSH
88965: LD_INT 6
88967: EQUAL
88968: IFFALSE 88978
// sArmoury := true ;
88970: LD_ADDR_EXP 121
88974: PUSH
88975: LD_INT 1
88977: ST_TO_ADDR
// if p3 = 7 then
88978: LD_VAR 0 3
88982: PUSH
88983: LD_INT 7
88985: EQUAL
88986: IFFALSE 88996
// sRadar := true ;
88988: LD_ADDR_EXP 122
88992: PUSH
88993: LD_INT 1
88995: ST_TO_ADDR
// if p3 = 8 then
88996: LD_VAR 0 3
89000: PUSH
89001: LD_INT 8
89003: EQUAL
89004: IFFALSE 89014
// sBunker := true ;
89006: LD_ADDR_EXP 123
89010: PUSH
89011: LD_INT 1
89013: ST_TO_ADDR
// if p3 = 9 then
89014: LD_VAR 0 3
89018: PUSH
89019: LD_INT 9
89021: EQUAL
89022: IFFALSE 89032
// sHack := true ;
89024: LD_ADDR_EXP 124
89028: PUSH
89029: LD_INT 1
89031: ST_TO_ADDR
// if p3 = 10 then
89032: LD_VAR 0 3
89036: PUSH
89037: LD_INT 10
89039: EQUAL
89040: IFFALSE 89050
// sFire := true ;
89042: LD_ADDR_EXP 125
89046: PUSH
89047: LD_INT 1
89049: ST_TO_ADDR
// if p3 = 11 then
89050: LD_VAR 0 3
89054: PUSH
89055: LD_INT 11
89057: EQUAL
89058: IFFALSE 89068
// sRefresh := true ;
89060: LD_ADDR_EXP 126
89064: PUSH
89065: LD_INT 1
89067: ST_TO_ADDR
// if p3 = 12 then
89068: LD_VAR 0 3
89072: PUSH
89073: LD_INT 12
89075: EQUAL
89076: IFFALSE 89086
// sExp := true ;
89078: LD_ADDR_EXP 127
89082: PUSH
89083: LD_INT 1
89085: ST_TO_ADDR
// if p3 = 13 then
89086: LD_VAR 0 3
89090: PUSH
89091: LD_INT 13
89093: EQUAL
89094: IFFALSE 89104
// sDepot := true ;
89096: LD_ADDR_EXP 128
89100: PUSH
89101: LD_INT 1
89103: ST_TO_ADDR
// if p3 = 14 then
89104: LD_VAR 0 3
89108: PUSH
89109: LD_INT 14
89111: EQUAL
89112: IFFALSE 89122
// sFlag := true ;
89114: LD_ADDR_EXP 129
89118: PUSH
89119: LD_INT 1
89121: ST_TO_ADDR
// if p3 = 15 then
89122: LD_VAR 0 3
89126: PUSH
89127: LD_INT 15
89129: EQUAL
89130: IFFALSE 89140
// sKamikadze := true ;
89132: LD_ADDR_EXP 137
89136: PUSH
89137: LD_INT 1
89139: ST_TO_ADDR
// if p3 = 16 then
89140: LD_VAR 0 3
89144: PUSH
89145: LD_INT 16
89147: EQUAL
89148: IFFALSE 89158
// sTroll := true ;
89150: LD_ADDR_EXP 138
89154: PUSH
89155: LD_INT 1
89157: ST_TO_ADDR
// if p3 = 17 then
89158: LD_VAR 0 3
89162: PUSH
89163: LD_INT 17
89165: EQUAL
89166: IFFALSE 89176
// sSlow := true ;
89168: LD_ADDR_EXP 139
89172: PUSH
89173: LD_INT 1
89175: ST_TO_ADDR
// if p3 = 18 then
89176: LD_VAR 0 3
89180: PUSH
89181: LD_INT 18
89183: EQUAL
89184: IFFALSE 89194
// sLack := true ;
89186: LD_ADDR_EXP 140
89190: PUSH
89191: LD_INT 1
89193: ST_TO_ADDR
// if p3 = 19 then
89194: LD_VAR 0 3
89198: PUSH
89199: LD_INT 19
89201: EQUAL
89202: IFFALSE 89212
// sTank := true ;
89204: LD_ADDR_EXP 142
89208: PUSH
89209: LD_INT 1
89211: ST_TO_ADDR
// if p3 = 20 then
89212: LD_VAR 0 3
89216: PUSH
89217: LD_INT 20
89219: EQUAL
89220: IFFALSE 89230
// sRemote := true ;
89222: LD_ADDR_EXP 143
89226: PUSH
89227: LD_INT 1
89229: ST_TO_ADDR
// if p3 = 21 then
89230: LD_VAR 0 3
89234: PUSH
89235: LD_INT 21
89237: EQUAL
89238: IFFALSE 89248
// sPowell := true ;
89240: LD_ADDR_EXP 144
89244: PUSH
89245: LD_INT 1
89247: ST_TO_ADDR
// if p3 = 22 then
89248: LD_VAR 0 3
89252: PUSH
89253: LD_INT 22
89255: EQUAL
89256: IFFALSE 89266
// sTeleport := true ;
89258: LD_ADDR_EXP 147
89262: PUSH
89263: LD_INT 1
89265: ST_TO_ADDR
// if p3 = 23 then
89266: LD_VAR 0 3
89270: PUSH
89271: LD_INT 23
89273: EQUAL
89274: IFFALSE 89284
// sOilTower := true ;
89276: LD_ADDR_EXP 149
89280: PUSH
89281: LD_INT 1
89283: ST_TO_ADDR
// if p3 = 24 then
89284: LD_VAR 0 3
89288: PUSH
89289: LD_INT 24
89291: EQUAL
89292: IFFALSE 89302
// sShovel := true ;
89294: LD_ADDR_EXP 150
89298: PUSH
89299: LD_INT 1
89301: ST_TO_ADDR
// if p3 = 25 then
89302: LD_VAR 0 3
89306: PUSH
89307: LD_INT 25
89309: EQUAL
89310: IFFALSE 89320
// sSheik := true ;
89312: LD_ADDR_EXP 151
89316: PUSH
89317: LD_INT 1
89319: ST_TO_ADDR
// if p3 = 26 then
89320: LD_VAR 0 3
89324: PUSH
89325: LD_INT 26
89327: EQUAL
89328: IFFALSE 89338
// sEarthquake := true ;
89330: LD_ADDR_EXP 153
89334: PUSH
89335: LD_INT 1
89337: ST_TO_ADDR
// if p3 = 27 then
89338: LD_VAR 0 3
89342: PUSH
89343: LD_INT 27
89345: EQUAL
89346: IFFALSE 89356
// sAI := true ;
89348: LD_ADDR_EXP 154
89352: PUSH
89353: LD_INT 1
89355: ST_TO_ADDR
// if p3 = 28 then
89356: LD_VAR 0 3
89360: PUSH
89361: LD_INT 28
89363: EQUAL
89364: IFFALSE 89374
// sCargo := true ;
89366: LD_ADDR_EXP 157
89370: PUSH
89371: LD_INT 1
89373: ST_TO_ADDR
// if p3 = 29 then
89374: LD_VAR 0 3
89378: PUSH
89379: LD_INT 29
89381: EQUAL
89382: IFFALSE 89392
// sDLaser := true ;
89384: LD_ADDR_EXP 158
89388: PUSH
89389: LD_INT 1
89391: ST_TO_ADDR
// if p3 = 30 then
89392: LD_VAR 0 3
89396: PUSH
89397: LD_INT 30
89399: EQUAL
89400: IFFALSE 89410
// sExchange := true ;
89402: LD_ADDR_EXP 159
89406: PUSH
89407: LD_INT 1
89409: ST_TO_ADDR
// if p3 = 31 then
89410: LD_VAR 0 3
89414: PUSH
89415: LD_INT 31
89417: EQUAL
89418: IFFALSE 89428
// sFac := true ;
89420: LD_ADDR_EXP 160
89424: PUSH
89425: LD_INT 1
89427: ST_TO_ADDR
// if p3 = 32 then
89428: LD_VAR 0 3
89432: PUSH
89433: LD_INT 32
89435: EQUAL
89436: IFFALSE 89446
// sPower := true ;
89438: LD_ADDR_EXP 161
89442: PUSH
89443: LD_INT 1
89445: ST_TO_ADDR
// if p3 = 33 then
89446: LD_VAR 0 3
89450: PUSH
89451: LD_INT 33
89453: EQUAL
89454: IFFALSE 89464
// sRandom := true ;
89456: LD_ADDR_EXP 162
89460: PUSH
89461: LD_INT 1
89463: ST_TO_ADDR
// if p3 = 34 then
89464: LD_VAR 0 3
89468: PUSH
89469: LD_INT 34
89471: EQUAL
89472: IFFALSE 89482
// sShield := true ;
89474: LD_ADDR_EXP 163
89478: PUSH
89479: LD_INT 1
89481: ST_TO_ADDR
// if p3 = 35 then
89482: LD_VAR 0 3
89486: PUSH
89487: LD_INT 35
89489: EQUAL
89490: IFFALSE 89500
// sTime := true ;
89492: LD_ADDR_EXP 164
89496: PUSH
89497: LD_INT 1
89499: ST_TO_ADDR
// if p3 = 36 then
89500: LD_VAR 0 3
89504: PUSH
89505: LD_INT 36
89507: EQUAL
89508: IFFALSE 89518
// sTools := true ;
89510: LD_ADDR_EXP 165
89514: PUSH
89515: LD_INT 1
89517: ST_TO_ADDR
// if p3 = 101 then
89518: LD_VAR 0 3
89522: PUSH
89523: LD_INT 101
89525: EQUAL
89526: IFFALSE 89536
// sSold := true ;
89528: LD_ADDR_EXP 130
89532: PUSH
89533: LD_INT 1
89535: ST_TO_ADDR
// if p3 = 102 then
89536: LD_VAR 0 3
89540: PUSH
89541: LD_INT 102
89543: EQUAL
89544: IFFALSE 89554
// sDiff := true ;
89546: LD_ADDR_EXP 131
89550: PUSH
89551: LD_INT 1
89553: ST_TO_ADDR
// if p3 = 103 then
89554: LD_VAR 0 3
89558: PUSH
89559: LD_INT 103
89561: EQUAL
89562: IFFALSE 89572
// sFog := true ;
89564: LD_ADDR_EXP 134
89568: PUSH
89569: LD_INT 1
89571: ST_TO_ADDR
// if p3 = 104 then
89572: LD_VAR 0 3
89576: PUSH
89577: LD_INT 104
89579: EQUAL
89580: IFFALSE 89590
// sReset := true ;
89582: LD_ADDR_EXP 135
89586: PUSH
89587: LD_INT 1
89589: ST_TO_ADDR
// if p3 = 105 then
89590: LD_VAR 0 3
89594: PUSH
89595: LD_INT 105
89597: EQUAL
89598: IFFALSE 89608
// sSun := true ;
89600: LD_ADDR_EXP 136
89604: PUSH
89605: LD_INT 1
89607: ST_TO_ADDR
// if p3 = 106 then
89608: LD_VAR 0 3
89612: PUSH
89613: LD_INT 106
89615: EQUAL
89616: IFFALSE 89626
// sTiger := true ;
89618: LD_ADDR_EXP 132
89622: PUSH
89623: LD_INT 1
89625: ST_TO_ADDR
// if p3 = 107 then
89626: LD_VAR 0 3
89630: PUSH
89631: LD_INT 107
89633: EQUAL
89634: IFFALSE 89644
// sBomb := true ;
89636: LD_ADDR_EXP 133
89640: PUSH
89641: LD_INT 1
89643: ST_TO_ADDR
// if p3 = 108 then
89644: LD_VAR 0 3
89648: PUSH
89649: LD_INT 108
89651: EQUAL
89652: IFFALSE 89662
// sWound := true ;
89654: LD_ADDR_EXP 141
89658: PUSH
89659: LD_INT 1
89661: ST_TO_ADDR
// if p3 = 109 then
89662: LD_VAR 0 3
89666: PUSH
89667: LD_INT 109
89669: EQUAL
89670: IFFALSE 89680
// sBetray := true ;
89672: LD_ADDR_EXP 145
89676: PUSH
89677: LD_INT 1
89679: ST_TO_ADDR
// if p3 = 110 then
89680: LD_VAR 0 3
89684: PUSH
89685: LD_INT 110
89687: EQUAL
89688: IFFALSE 89698
// sContamin := true ;
89690: LD_ADDR_EXP 146
89694: PUSH
89695: LD_INT 1
89697: ST_TO_ADDR
// if p3 = 111 then
89698: LD_VAR 0 3
89702: PUSH
89703: LD_INT 111
89705: EQUAL
89706: IFFALSE 89716
// sOil := true ;
89708: LD_ADDR_EXP 148
89712: PUSH
89713: LD_INT 1
89715: ST_TO_ADDR
// if p3 = 112 then
89716: LD_VAR 0 3
89720: PUSH
89721: LD_INT 112
89723: EQUAL
89724: IFFALSE 89734
// sStu := true ;
89726: LD_ADDR_EXP 152
89730: PUSH
89731: LD_INT 1
89733: ST_TO_ADDR
// if p3 = 113 then
89734: LD_VAR 0 3
89738: PUSH
89739: LD_INT 113
89741: EQUAL
89742: IFFALSE 89752
// sBazooka := true ;
89744: LD_ADDR_EXP 155
89748: PUSH
89749: LD_INT 1
89751: ST_TO_ADDR
// if p3 = 114 then
89752: LD_VAR 0 3
89756: PUSH
89757: LD_INT 114
89759: EQUAL
89760: IFFALSE 89770
// sMortar := true ;
89762: LD_ADDR_EXP 156
89766: PUSH
89767: LD_INT 1
89769: ST_TO_ADDR
// if p3 = 115 then
89770: LD_VAR 0 3
89774: PUSH
89775: LD_INT 115
89777: EQUAL
89778: IFFALSE 89788
// sRanger := true ;
89780: LD_ADDR_EXP 166
89784: PUSH
89785: LD_INT 1
89787: ST_TO_ADDR
// if p3 = 116 then
89788: LD_VAR 0 3
89792: PUSH
89793: LD_INT 116
89795: EQUAL
89796: IFFALSE 89806
// sComputer := true ;
89798: LD_ADDR_EXP 167
89802: PUSH
89803: LD_INT 1
89805: ST_TO_ADDR
// if p3 = 117 then
89806: LD_VAR 0 3
89810: PUSH
89811: LD_INT 117
89813: EQUAL
89814: IFFALSE 89824
// s30 := true ;
89816: LD_ADDR_EXP 168
89820: PUSH
89821: LD_INT 1
89823: ST_TO_ADDR
// if p3 = 118 then
89824: LD_VAR 0 3
89828: PUSH
89829: LD_INT 118
89831: EQUAL
89832: IFFALSE 89842
// s60 := true ;
89834: LD_ADDR_EXP 169
89838: PUSH
89839: LD_INT 1
89841: ST_TO_ADDR
// end ; if p2 = 101 then
89842: LD_VAR 0 2
89846: PUSH
89847: LD_INT 101
89849: EQUAL
89850: IFFALSE 89978
// begin case p3 of 1 :
89852: LD_VAR 0 3
89856: PUSH
89857: LD_INT 1
89859: DOUBLE
89860: EQUAL
89861: IFTRUE 89865
89863: GO 89872
89865: POP
// hHackUnlimitedResources ; 2 :
89866: CALL 102076 0 0
89870: GO 89978
89872: LD_INT 2
89874: DOUBLE
89875: EQUAL
89876: IFTRUE 89880
89878: GO 89887
89880: POP
// hHackSetLevel10 ; 3 :
89881: CALL 102209 0 0
89885: GO 89978
89887: LD_INT 3
89889: DOUBLE
89890: EQUAL
89891: IFTRUE 89895
89893: GO 89902
89895: POP
// hHackSetLevel10YourUnits ; 4 :
89896: CALL 102294 0 0
89900: GO 89978
89902: LD_INT 4
89904: DOUBLE
89905: EQUAL
89906: IFTRUE 89910
89908: GO 89917
89910: POP
// hHackInvincible ; 5 :
89911: CALL 102742 0 0
89915: GO 89978
89917: LD_INT 5
89919: DOUBLE
89920: EQUAL
89921: IFTRUE 89925
89923: GO 89932
89925: POP
// hHackInvisible ; 6 :
89926: CALL 102853 0 0
89930: GO 89978
89932: LD_INT 6
89934: DOUBLE
89935: EQUAL
89936: IFTRUE 89940
89938: GO 89947
89940: POP
// hHackChangeYourSide ; 7 :
89941: CALL 102910 0 0
89945: GO 89978
89947: LD_INT 7
89949: DOUBLE
89950: EQUAL
89951: IFTRUE 89955
89953: GO 89962
89955: POP
// hHackChangeUnitSide ; 8 :
89956: CALL 102952 0 0
89960: GO 89978
89962: LD_INT 8
89964: DOUBLE
89965: EQUAL
89966: IFTRUE 89970
89968: GO 89977
89970: POP
// hHackFog ; end ;
89971: CALL 103053 0 0
89975: GO 89978
89977: POP
// end ; end ;
89978: LD_VAR 0 7
89982: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
89983: GO 89985
89985: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
89986: LD_STRING initStreamRollete();
89988: PPUSH
89989: CALL_OW 559
// InitStreamMode ;
89993: CALL 90005 0 0
// DefineStreamItems ( false ) ;
89997: LD_INT 0
89999: PPUSH
90000: CALL 90469 0 1
// end ;
90004: END
// function InitStreamMode ; begin
90005: LD_INT 0
90007: PPUSH
// streamModeActive := false ;
90008: LD_ADDR_EXP 113
90012: PUSH
90013: LD_INT 0
90015: ST_TO_ADDR
// normalCounter := 36 ;
90016: LD_ADDR_EXP 114
90020: PUSH
90021: LD_INT 36
90023: ST_TO_ADDR
// hardcoreCounter := 18 ;
90024: LD_ADDR_EXP 115
90028: PUSH
90029: LD_INT 18
90031: ST_TO_ADDR
// sRocket := false ;
90032: LD_ADDR_EXP 118
90036: PUSH
90037: LD_INT 0
90039: ST_TO_ADDR
// sSpeed := false ;
90040: LD_ADDR_EXP 117
90044: PUSH
90045: LD_INT 0
90047: ST_TO_ADDR
// sEngine := false ;
90048: LD_ADDR_EXP 119
90052: PUSH
90053: LD_INT 0
90055: ST_TO_ADDR
// sSpec := false ;
90056: LD_ADDR_EXP 116
90060: PUSH
90061: LD_INT 0
90063: ST_TO_ADDR
// sLevel := false ;
90064: LD_ADDR_EXP 120
90068: PUSH
90069: LD_INT 0
90071: ST_TO_ADDR
// sArmoury := false ;
90072: LD_ADDR_EXP 121
90076: PUSH
90077: LD_INT 0
90079: ST_TO_ADDR
// sRadar := false ;
90080: LD_ADDR_EXP 122
90084: PUSH
90085: LD_INT 0
90087: ST_TO_ADDR
// sBunker := false ;
90088: LD_ADDR_EXP 123
90092: PUSH
90093: LD_INT 0
90095: ST_TO_ADDR
// sHack := false ;
90096: LD_ADDR_EXP 124
90100: PUSH
90101: LD_INT 0
90103: ST_TO_ADDR
// sFire := false ;
90104: LD_ADDR_EXP 125
90108: PUSH
90109: LD_INT 0
90111: ST_TO_ADDR
// sRefresh := false ;
90112: LD_ADDR_EXP 126
90116: PUSH
90117: LD_INT 0
90119: ST_TO_ADDR
// sExp := false ;
90120: LD_ADDR_EXP 127
90124: PUSH
90125: LD_INT 0
90127: ST_TO_ADDR
// sDepot := false ;
90128: LD_ADDR_EXP 128
90132: PUSH
90133: LD_INT 0
90135: ST_TO_ADDR
// sFlag := false ;
90136: LD_ADDR_EXP 129
90140: PUSH
90141: LD_INT 0
90143: ST_TO_ADDR
// sKamikadze := false ;
90144: LD_ADDR_EXP 137
90148: PUSH
90149: LD_INT 0
90151: ST_TO_ADDR
// sTroll := false ;
90152: LD_ADDR_EXP 138
90156: PUSH
90157: LD_INT 0
90159: ST_TO_ADDR
// sSlow := false ;
90160: LD_ADDR_EXP 139
90164: PUSH
90165: LD_INT 0
90167: ST_TO_ADDR
// sLack := false ;
90168: LD_ADDR_EXP 140
90172: PUSH
90173: LD_INT 0
90175: ST_TO_ADDR
// sTank := false ;
90176: LD_ADDR_EXP 142
90180: PUSH
90181: LD_INT 0
90183: ST_TO_ADDR
// sRemote := false ;
90184: LD_ADDR_EXP 143
90188: PUSH
90189: LD_INT 0
90191: ST_TO_ADDR
// sPowell := false ;
90192: LD_ADDR_EXP 144
90196: PUSH
90197: LD_INT 0
90199: ST_TO_ADDR
// sTeleport := false ;
90200: LD_ADDR_EXP 147
90204: PUSH
90205: LD_INT 0
90207: ST_TO_ADDR
// sOilTower := false ;
90208: LD_ADDR_EXP 149
90212: PUSH
90213: LD_INT 0
90215: ST_TO_ADDR
// sShovel := false ;
90216: LD_ADDR_EXP 150
90220: PUSH
90221: LD_INT 0
90223: ST_TO_ADDR
// sSheik := false ;
90224: LD_ADDR_EXP 151
90228: PUSH
90229: LD_INT 0
90231: ST_TO_ADDR
// sEarthquake := false ;
90232: LD_ADDR_EXP 153
90236: PUSH
90237: LD_INT 0
90239: ST_TO_ADDR
// sAI := false ;
90240: LD_ADDR_EXP 154
90244: PUSH
90245: LD_INT 0
90247: ST_TO_ADDR
// sCargo := false ;
90248: LD_ADDR_EXP 157
90252: PUSH
90253: LD_INT 0
90255: ST_TO_ADDR
// sDLaser := false ;
90256: LD_ADDR_EXP 158
90260: PUSH
90261: LD_INT 0
90263: ST_TO_ADDR
// sExchange := false ;
90264: LD_ADDR_EXP 159
90268: PUSH
90269: LD_INT 0
90271: ST_TO_ADDR
// sFac := false ;
90272: LD_ADDR_EXP 160
90276: PUSH
90277: LD_INT 0
90279: ST_TO_ADDR
// sPower := false ;
90280: LD_ADDR_EXP 161
90284: PUSH
90285: LD_INT 0
90287: ST_TO_ADDR
// sRandom := false ;
90288: LD_ADDR_EXP 162
90292: PUSH
90293: LD_INT 0
90295: ST_TO_ADDR
// sShield := false ;
90296: LD_ADDR_EXP 163
90300: PUSH
90301: LD_INT 0
90303: ST_TO_ADDR
// sTime := false ;
90304: LD_ADDR_EXP 164
90308: PUSH
90309: LD_INT 0
90311: ST_TO_ADDR
// sTools := false ;
90312: LD_ADDR_EXP 165
90316: PUSH
90317: LD_INT 0
90319: ST_TO_ADDR
// sSold := false ;
90320: LD_ADDR_EXP 130
90324: PUSH
90325: LD_INT 0
90327: ST_TO_ADDR
// sDiff := false ;
90328: LD_ADDR_EXP 131
90332: PUSH
90333: LD_INT 0
90335: ST_TO_ADDR
// sFog := false ;
90336: LD_ADDR_EXP 134
90340: PUSH
90341: LD_INT 0
90343: ST_TO_ADDR
// sReset := false ;
90344: LD_ADDR_EXP 135
90348: PUSH
90349: LD_INT 0
90351: ST_TO_ADDR
// sSun := false ;
90352: LD_ADDR_EXP 136
90356: PUSH
90357: LD_INT 0
90359: ST_TO_ADDR
// sTiger := false ;
90360: LD_ADDR_EXP 132
90364: PUSH
90365: LD_INT 0
90367: ST_TO_ADDR
// sBomb := false ;
90368: LD_ADDR_EXP 133
90372: PUSH
90373: LD_INT 0
90375: ST_TO_ADDR
// sWound := false ;
90376: LD_ADDR_EXP 141
90380: PUSH
90381: LD_INT 0
90383: ST_TO_ADDR
// sBetray := false ;
90384: LD_ADDR_EXP 145
90388: PUSH
90389: LD_INT 0
90391: ST_TO_ADDR
// sContamin := false ;
90392: LD_ADDR_EXP 146
90396: PUSH
90397: LD_INT 0
90399: ST_TO_ADDR
// sOil := false ;
90400: LD_ADDR_EXP 148
90404: PUSH
90405: LD_INT 0
90407: ST_TO_ADDR
// sStu := false ;
90408: LD_ADDR_EXP 152
90412: PUSH
90413: LD_INT 0
90415: ST_TO_ADDR
// sBazooka := false ;
90416: LD_ADDR_EXP 155
90420: PUSH
90421: LD_INT 0
90423: ST_TO_ADDR
// sMortar := false ;
90424: LD_ADDR_EXP 156
90428: PUSH
90429: LD_INT 0
90431: ST_TO_ADDR
// sRanger := false ;
90432: LD_ADDR_EXP 166
90436: PUSH
90437: LD_INT 0
90439: ST_TO_ADDR
// sComputer := false ;
90440: LD_ADDR_EXP 167
90444: PUSH
90445: LD_INT 0
90447: ST_TO_ADDR
// s30 := false ;
90448: LD_ADDR_EXP 168
90452: PUSH
90453: LD_INT 0
90455: ST_TO_ADDR
// s60 := false ;
90456: LD_ADDR_EXP 169
90460: PUSH
90461: LD_INT 0
90463: ST_TO_ADDR
// end ;
90464: LD_VAR 0 1
90468: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
90469: LD_INT 0
90471: PPUSH
90472: PPUSH
90473: PPUSH
90474: PPUSH
90475: PPUSH
90476: PPUSH
90477: PPUSH
// result := [ ] ;
90478: LD_ADDR_VAR 0 2
90482: PUSH
90483: EMPTY
90484: ST_TO_ADDR
// if campaign_id = 1 then
90485: LD_OWVAR 69
90489: PUSH
90490: LD_INT 1
90492: EQUAL
90493: IFFALSE 93659
// begin case mission_number of 1 :
90495: LD_OWVAR 70
90499: PUSH
90500: LD_INT 1
90502: DOUBLE
90503: EQUAL
90504: IFTRUE 90508
90506: GO 90584
90508: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
90509: LD_ADDR_VAR 0 2
90513: PUSH
90514: LD_INT 2
90516: PUSH
90517: LD_INT 4
90519: PUSH
90520: LD_INT 11
90522: PUSH
90523: LD_INT 12
90525: PUSH
90526: LD_INT 15
90528: PUSH
90529: LD_INT 16
90531: PUSH
90532: LD_INT 22
90534: PUSH
90535: LD_INT 23
90537: PUSH
90538: LD_INT 26
90540: PUSH
90541: EMPTY
90542: LIST
90543: LIST
90544: LIST
90545: LIST
90546: LIST
90547: LIST
90548: LIST
90549: LIST
90550: LIST
90551: PUSH
90552: LD_INT 101
90554: PUSH
90555: LD_INT 102
90557: PUSH
90558: LD_INT 106
90560: PUSH
90561: LD_INT 116
90563: PUSH
90564: LD_INT 117
90566: PUSH
90567: LD_INT 118
90569: PUSH
90570: EMPTY
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: PUSH
90578: EMPTY
90579: LIST
90580: LIST
90581: ST_TO_ADDR
90582: GO 93657
90584: LD_INT 2
90586: DOUBLE
90587: EQUAL
90588: IFTRUE 90592
90590: GO 90676
90592: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
90593: LD_ADDR_VAR 0 2
90597: PUSH
90598: LD_INT 2
90600: PUSH
90601: LD_INT 4
90603: PUSH
90604: LD_INT 11
90606: PUSH
90607: LD_INT 12
90609: PUSH
90610: LD_INT 15
90612: PUSH
90613: LD_INT 16
90615: PUSH
90616: LD_INT 22
90618: PUSH
90619: LD_INT 23
90621: PUSH
90622: LD_INT 26
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: PUSH
90636: LD_INT 101
90638: PUSH
90639: LD_INT 102
90641: PUSH
90642: LD_INT 105
90644: PUSH
90645: LD_INT 106
90647: PUSH
90648: LD_INT 108
90650: PUSH
90651: LD_INT 116
90653: PUSH
90654: LD_INT 117
90656: PUSH
90657: LD_INT 118
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: LIST
90667: LIST
90668: LIST
90669: PUSH
90670: EMPTY
90671: LIST
90672: LIST
90673: ST_TO_ADDR
90674: GO 93657
90676: LD_INT 3
90678: DOUBLE
90679: EQUAL
90680: IFTRUE 90684
90682: GO 90772
90684: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
90685: LD_ADDR_VAR 0 2
90689: PUSH
90690: LD_INT 2
90692: PUSH
90693: LD_INT 4
90695: PUSH
90696: LD_INT 5
90698: PUSH
90699: LD_INT 11
90701: PUSH
90702: LD_INT 12
90704: PUSH
90705: LD_INT 15
90707: PUSH
90708: LD_INT 16
90710: PUSH
90711: LD_INT 22
90713: PUSH
90714: LD_INT 26
90716: PUSH
90717: LD_INT 36
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: LIST
90724: LIST
90725: LIST
90726: LIST
90727: LIST
90728: LIST
90729: LIST
90730: LIST
90731: PUSH
90732: LD_INT 101
90734: PUSH
90735: LD_INT 102
90737: PUSH
90738: LD_INT 105
90740: PUSH
90741: LD_INT 106
90743: PUSH
90744: LD_INT 108
90746: PUSH
90747: LD_INT 116
90749: PUSH
90750: LD_INT 117
90752: PUSH
90753: LD_INT 118
90755: PUSH
90756: EMPTY
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: PUSH
90766: EMPTY
90767: LIST
90768: LIST
90769: ST_TO_ADDR
90770: GO 93657
90772: LD_INT 4
90774: DOUBLE
90775: EQUAL
90776: IFTRUE 90780
90778: GO 90876
90780: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
90781: LD_ADDR_VAR 0 2
90785: PUSH
90786: LD_INT 2
90788: PUSH
90789: LD_INT 4
90791: PUSH
90792: LD_INT 5
90794: PUSH
90795: LD_INT 8
90797: PUSH
90798: LD_INT 11
90800: PUSH
90801: LD_INT 12
90803: PUSH
90804: LD_INT 15
90806: PUSH
90807: LD_INT 16
90809: PUSH
90810: LD_INT 22
90812: PUSH
90813: LD_INT 23
90815: PUSH
90816: LD_INT 26
90818: PUSH
90819: LD_INT 36
90821: PUSH
90822: EMPTY
90823: LIST
90824: LIST
90825: LIST
90826: LIST
90827: LIST
90828: LIST
90829: LIST
90830: LIST
90831: LIST
90832: LIST
90833: LIST
90834: LIST
90835: PUSH
90836: LD_INT 101
90838: PUSH
90839: LD_INT 102
90841: PUSH
90842: LD_INT 105
90844: PUSH
90845: LD_INT 106
90847: PUSH
90848: LD_INT 108
90850: PUSH
90851: LD_INT 116
90853: PUSH
90854: LD_INT 117
90856: PUSH
90857: LD_INT 118
90859: PUSH
90860: EMPTY
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: PUSH
90870: EMPTY
90871: LIST
90872: LIST
90873: ST_TO_ADDR
90874: GO 93657
90876: LD_INT 5
90878: DOUBLE
90879: EQUAL
90880: IFTRUE 90884
90882: GO 90996
90884: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
90885: LD_ADDR_VAR 0 2
90889: PUSH
90890: LD_INT 2
90892: PUSH
90893: LD_INT 4
90895: PUSH
90896: LD_INT 5
90898: PUSH
90899: LD_INT 6
90901: PUSH
90902: LD_INT 8
90904: PUSH
90905: LD_INT 11
90907: PUSH
90908: LD_INT 12
90910: PUSH
90911: LD_INT 15
90913: PUSH
90914: LD_INT 16
90916: PUSH
90917: LD_INT 22
90919: PUSH
90920: LD_INT 23
90922: PUSH
90923: LD_INT 25
90925: PUSH
90926: LD_INT 26
90928: PUSH
90929: LD_INT 36
90931: PUSH
90932: EMPTY
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: LIST
90944: LIST
90945: LIST
90946: LIST
90947: PUSH
90948: LD_INT 101
90950: PUSH
90951: LD_INT 102
90953: PUSH
90954: LD_INT 105
90956: PUSH
90957: LD_INT 106
90959: PUSH
90960: LD_INT 108
90962: PUSH
90963: LD_INT 109
90965: PUSH
90966: LD_INT 112
90968: PUSH
90969: LD_INT 116
90971: PUSH
90972: LD_INT 117
90974: PUSH
90975: LD_INT 118
90977: PUSH
90978: EMPTY
90979: LIST
90980: LIST
90981: LIST
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: ST_TO_ADDR
90994: GO 93657
90996: LD_INT 6
90998: DOUBLE
90999: EQUAL
91000: IFTRUE 91004
91002: GO 91136
91004: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
91005: LD_ADDR_VAR 0 2
91009: PUSH
91010: LD_INT 2
91012: PUSH
91013: LD_INT 4
91015: PUSH
91016: LD_INT 5
91018: PUSH
91019: LD_INT 6
91021: PUSH
91022: LD_INT 8
91024: PUSH
91025: LD_INT 11
91027: PUSH
91028: LD_INT 12
91030: PUSH
91031: LD_INT 15
91033: PUSH
91034: LD_INT 16
91036: PUSH
91037: LD_INT 20
91039: PUSH
91040: LD_INT 21
91042: PUSH
91043: LD_INT 22
91045: PUSH
91046: LD_INT 23
91048: PUSH
91049: LD_INT 25
91051: PUSH
91052: LD_INT 26
91054: PUSH
91055: LD_INT 30
91057: PUSH
91058: LD_INT 31
91060: PUSH
91061: LD_INT 32
91063: PUSH
91064: LD_INT 36
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: LIST
91071: LIST
91072: LIST
91073: LIST
91074: LIST
91075: LIST
91076: LIST
91077: LIST
91078: LIST
91079: LIST
91080: LIST
91081: LIST
91082: LIST
91083: LIST
91084: LIST
91085: LIST
91086: LIST
91087: PUSH
91088: LD_INT 101
91090: PUSH
91091: LD_INT 102
91093: PUSH
91094: LD_INT 105
91096: PUSH
91097: LD_INT 106
91099: PUSH
91100: LD_INT 108
91102: PUSH
91103: LD_INT 109
91105: PUSH
91106: LD_INT 112
91108: PUSH
91109: LD_INT 116
91111: PUSH
91112: LD_INT 117
91114: PUSH
91115: LD_INT 118
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: LIST
91122: LIST
91123: LIST
91124: LIST
91125: LIST
91126: LIST
91127: LIST
91128: LIST
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: ST_TO_ADDR
91134: GO 93657
91136: LD_INT 7
91138: DOUBLE
91139: EQUAL
91140: IFTRUE 91144
91142: GO 91256
91144: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
91145: LD_ADDR_VAR 0 2
91149: PUSH
91150: LD_INT 2
91152: PUSH
91153: LD_INT 4
91155: PUSH
91156: LD_INT 5
91158: PUSH
91159: LD_INT 7
91161: PUSH
91162: LD_INT 11
91164: PUSH
91165: LD_INT 12
91167: PUSH
91168: LD_INT 15
91170: PUSH
91171: LD_INT 16
91173: PUSH
91174: LD_INT 20
91176: PUSH
91177: LD_INT 21
91179: PUSH
91180: LD_INT 22
91182: PUSH
91183: LD_INT 23
91185: PUSH
91186: LD_INT 25
91188: PUSH
91189: LD_INT 26
91191: PUSH
91192: EMPTY
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: PUSH
91208: LD_INT 101
91210: PUSH
91211: LD_INT 102
91213: PUSH
91214: LD_INT 103
91216: PUSH
91217: LD_INT 105
91219: PUSH
91220: LD_INT 106
91222: PUSH
91223: LD_INT 108
91225: PUSH
91226: LD_INT 112
91228: PUSH
91229: LD_INT 116
91231: PUSH
91232: LD_INT 117
91234: PUSH
91235: LD_INT 118
91237: PUSH
91238: EMPTY
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: PUSH
91250: EMPTY
91251: LIST
91252: LIST
91253: ST_TO_ADDR
91254: GO 93657
91256: LD_INT 8
91258: DOUBLE
91259: EQUAL
91260: IFTRUE 91264
91262: GO 91404
91264: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
91265: LD_ADDR_VAR 0 2
91269: PUSH
91270: LD_INT 2
91272: PUSH
91273: LD_INT 4
91275: PUSH
91276: LD_INT 5
91278: PUSH
91279: LD_INT 6
91281: PUSH
91282: LD_INT 7
91284: PUSH
91285: LD_INT 8
91287: PUSH
91288: LD_INT 11
91290: PUSH
91291: LD_INT 12
91293: PUSH
91294: LD_INT 15
91296: PUSH
91297: LD_INT 16
91299: PUSH
91300: LD_INT 20
91302: PUSH
91303: LD_INT 21
91305: PUSH
91306: LD_INT 22
91308: PUSH
91309: LD_INT 23
91311: PUSH
91312: LD_INT 25
91314: PUSH
91315: LD_INT 26
91317: PUSH
91318: LD_INT 30
91320: PUSH
91321: LD_INT 31
91323: PUSH
91324: LD_INT 32
91326: PUSH
91327: LD_INT 36
91329: PUSH
91330: EMPTY
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: LIST
91350: LIST
91351: PUSH
91352: LD_INT 101
91354: PUSH
91355: LD_INT 102
91357: PUSH
91358: LD_INT 103
91360: PUSH
91361: LD_INT 105
91363: PUSH
91364: LD_INT 106
91366: PUSH
91367: LD_INT 108
91369: PUSH
91370: LD_INT 109
91372: PUSH
91373: LD_INT 112
91375: PUSH
91376: LD_INT 116
91378: PUSH
91379: LD_INT 117
91381: PUSH
91382: LD_INT 118
91384: PUSH
91385: EMPTY
91386: LIST
91387: LIST
91388: LIST
91389: LIST
91390: LIST
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: PUSH
91398: EMPTY
91399: LIST
91400: LIST
91401: ST_TO_ADDR
91402: GO 93657
91404: LD_INT 9
91406: DOUBLE
91407: EQUAL
91408: IFTRUE 91412
91410: GO 91560
91412: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
91413: LD_ADDR_VAR 0 2
91417: PUSH
91418: LD_INT 2
91420: PUSH
91421: LD_INT 4
91423: PUSH
91424: LD_INT 5
91426: PUSH
91427: LD_INT 6
91429: PUSH
91430: LD_INT 7
91432: PUSH
91433: LD_INT 8
91435: PUSH
91436: LD_INT 11
91438: PUSH
91439: LD_INT 12
91441: PUSH
91442: LD_INT 15
91444: PUSH
91445: LD_INT 16
91447: PUSH
91448: LD_INT 20
91450: PUSH
91451: LD_INT 21
91453: PUSH
91454: LD_INT 22
91456: PUSH
91457: LD_INT 23
91459: PUSH
91460: LD_INT 25
91462: PUSH
91463: LD_INT 26
91465: PUSH
91466: LD_INT 28
91468: PUSH
91469: LD_INT 30
91471: PUSH
91472: LD_INT 31
91474: PUSH
91475: LD_INT 32
91477: PUSH
91478: LD_INT 36
91480: PUSH
91481: EMPTY
91482: LIST
91483: LIST
91484: LIST
91485: LIST
91486: LIST
91487: LIST
91488: LIST
91489: LIST
91490: LIST
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: LIST
91496: LIST
91497: LIST
91498: LIST
91499: LIST
91500: LIST
91501: LIST
91502: LIST
91503: PUSH
91504: LD_INT 101
91506: PUSH
91507: LD_INT 102
91509: PUSH
91510: LD_INT 103
91512: PUSH
91513: LD_INT 105
91515: PUSH
91516: LD_INT 106
91518: PUSH
91519: LD_INT 108
91521: PUSH
91522: LD_INT 109
91524: PUSH
91525: LD_INT 112
91527: PUSH
91528: LD_INT 114
91530: PUSH
91531: LD_INT 116
91533: PUSH
91534: LD_INT 117
91536: PUSH
91537: LD_INT 118
91539: PUSH
91540: EMPTY
91541: LIST
91542: LIST
91543: LIST
91544: LIST
91545: LIST
91546: LIST
91547: LIST
91548: LIST
91549: LIST
91550: LIST
91551: LIST
91552: LIST
91553: PUSH
91554: EMPTY
91555: LIST
91556: LIST
91557: ST_TO_ADDR
91558: GO 93657
91560: LD_INT 10
91562: DOUBLE
91563: EQUAL
91564: IFTRUE 91568
91566: GO 91764
91568: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
91569: LD_ADDR_VAR 0 2
91573: PUSH
91574: LD_INT 2
91576: PUSH
91577: LD_INT 4
91579: PUSH
91580: LD_INT 5
91582: PUSH
91583: LD_INT 6
91585: PUSH
91586: LD_INT 7
91588: PUSH
91589: LD_INT 8
91591: PUSH
91592: LD_INT 9
91594: PUSH
91595: LD_INT 10
91597: PUSH
91598: LD_INT 11
91600: PUSH
91601: LD_INT 12
91603: PUSH
91604: LD_INT 13
91606: PUSH
91607: LD_INT 14
91609: PUSH
91610: LD_INT 15
91612: PUSH
91613: LD_INT 16
91615: PUSH
91616: LD_INT 17
91618: PUSH
91619: LD_INT 18
91621: PUSH
91622: LD_INT 19
91624: PUSH
91625: LD_INT 20
91627: PUSH
91628: LD_INT 21
91630: PUSH
91631: LD_INT 22
91633: PUSH
91634: LD_INT 23
91636: PUSH
91637: LD_INT 24
91639: PUSH
91640: LD_INT 25
91642: PUSH
91643: LD_INT 26
91645: PUSH
91646: LD_INT 28
91648: PUSH
91649: LD_INT 30
91651: PUSH
91652: LD_INT 31
91654: PUSH
91655: LD_INT 32
91657: PUSH
91658: LD_INT 36
91660: PUSH
91661: EMPTY
91662: LIST
91663: LIST
91664: LIST
91665: LIST
91666: LIST
91667: LIST
91668: LIST
91669: LIST
91670: LIST
91671: LIST
91672: LIST
91673: LIST
91674: LIST
91675: LIST
91676: LIST
91677: LIST
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: PUSH
91692: LD_INT 101
91694: PUSH
91695: LD_INT 102
91697: PUSH
91698: LD_INT 103
91700: PUSH
91701: LD_INT 104
91703: PUSH
91704: LD_INT 105
91706: PUSH
91707: LD_INT 106
91709: PUSH
91710: LD_INT 107
91712: PUSH
91713: LD_INT 108
91715: PUSH
91716: LD_INT 109
91718: PUSH
91719: LD_INT 110
91721: PUSH
91722: LD_INT 111
91724: PUSH
91725: LD_INT 112
91727: PUSH
91728: LD_INT 114
91730: PUSH
91731: LD_INT 116
91733: PUSH
91734: LD_INT 117
91736: PUSH
91737: LD_INT 118
91739: PUSH
91740: EMPTY
91741: LIST
91742: LIST
91743: LIST
91744: LIST
91745: LIST
91746: LIST
91747: LIST
91748: LIST
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: ST_TO_ADDR
91762: GO 93657
91764: LD_INT 11
91766: DOUBLE
91767: EQUAL
91768: IFTRUE 91772
91770: GO 91976
91772: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
91773: LD_ADDR_VAR 0 2
91777: PUSH
91778: LD_INT 2
91780: PUSH
91781: LD_INT 3
91783: PUSH
91784: LD_INT 4
91786: PUSH
91787: LD_INT 5
91789: PUSH
91790: LD_INT 6
91792: PUSH
91793: LD_INT 7
91795: PUSH
91796: LD_INT 8
91798: PUSH
91799: LD_INT 9
91801: PUSH
91802: LD_INT 10
91804: PUSH
91805: LD_INT 11
91807: PUSH
91808: LD_INT 12
91810: PUSH
91811: LD_INT 13
91813: PUSH
91814: LD_INT 14
91816: PUSH
91817: LD_INT 15
91819: PUSH
91820: LD_INT 16
91822: PUSH
91823: LD_INT 17
91825: PUSH
91826: LD_INT 18
91828: PUSH
91829: LD_INT 19
91831: PUSH
91832: LD_INT 20
91834: PUSH
91835: LD_INT 21
91837: PUSH
91838: LD_INT 22
91840: PUSH
91841: LD_INT 23
91843: PUSH
91844: LD_INT 24
91846: PUSH
91847: LD_INT 25
91849: PUSH
91850: LD_INT 26
91852: PUSH
91853: LD_INT 28
91855: PUSH
91856: LD_INT 30
91858: PUSH
91859: LD_INT 31
91861: PUSH
91862: LD_INT 32
91864: PUSH
91865: LD_INT 34
91867: PUSH
91868: LD_INT 36
91870: PUSH
91871: EMPTY
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: LIST
91879: LIST
91880: LIST
91881: LIST
91882: LIST
91883: LIST
91884: LIST
91885: LIST
91886: LIST
91887: LIST
91888: LIST
91889: LIST
91890: LIST
91891: LIST
91892: LIST
91893: LIST
91894: LIST
91895: LIST
91896: LIST
91897: LIST
91898: LIST
91899: LIST
91900: LIST
91901: LIST
91902: LIST
91903: PUSH
91904: LD_INT 101
91906: PUSH
91907: LD_INT 102
91909: PUSH
91910: LD_INT 103
91912: PUSH
91913: LD_INT 104
91915: PUSH
91916: LD_INT 105
91918: PUSH
91919: LD_INT 106
91921: PUSH
91922: LD_INT 107
91924: PUSH
91925: LD_INT 108
91927: PUSH
91928: LD_INT 109
91930: PUSH
91931: LD_INT 110
91933: PUSH
91934: LD_INT 111
91936: PUSH
91937: LD_INT 112
91939: PUSH
91940: LD_INT 114
91942: PUSH
91943: LD_INT 116
91945: PUSH
91946: LD_INT 117
91948: PUSH
91949: LD_INT 118
91951: PUSH
91952: EMPTY
91953: LIST
91954: LIST
91955: LIST
91956: LIST
91957: LIST
91958: LIST
91959: LIST
91960: LIST
91961: LIST
91962: LIST
91963: LIST
91964: LIST
91965: LIST
91966: LIST
91967: LIST
91968: LIST
91969: PUSH
91970: EMPTY
91971: LIST
91972: LIST
91973: ST_TO_ADDR
91974: GO 93657
91976: LD_INT 12
91978: DOUBLE
91979: EQUAL
91980: IFTRUE 91984
91982: GO 92204
91984: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
91985: LD_ADDR_VAR 0 2
91989: PUSH
91990: LD_INT 1
91992: PUSH
91993: LD_INT 2
91995: PUSH
91996: LD_INT 3
91998: PUSH
91999: LD_INT 4
92001: PUSH
92002: LD_INT 5
92004: PUSH
92005: LD_INT 6
92007: PUSH
92008: LD_INT 7
92010: PUSH
92011: LD_INT 8
92013: PUSH
92014: LD_INT 9
92016: PUSH
92017: LD_INT 10
92019: PUSH
92020: LD_INT 11
92022: PUSH
92023: LD_INT 12
92025: PUSH
92026: LD_INT 13
92028: PUSH
92029: LD_INT 14
92031: PUSH
92032: LD_INT 15
92034: PUSH
92035: LD_INT 16
92037: PUSH
92038: LD_INT 17
92040: PUSH
92041: LD_INT 18
92043: PUSH
92044: LD_INT 19
92046: PUSH
92047: LD_INT 20
92049: PUSH
92050: LD_INT 21
92052: PUSH
92053: LD_INT 22
92055: PUSH
92056: LD_INT 23
92058: PUSH
92059: LD_INT 24
92061: PUSH
92062: LD_INT 25
92064: PUSH
92065: LD_INT 26
92067: PUSH
92068: LD_INT 27
92070: PUSH
92071: LD_INT 28
92073: PUSH
92074: LD_INT 30
92076: PUSH
92077: LD_INT 31
92079: PUSH
92080: LD_INT 32
92082: PUSH
92083: LD_INT 33
92085: PUSH
92086: LD_INT 34
92088: PUSH
92089: LD_INT 36
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: LIST
92096: LIST
92097: LIST
92098: LIST
92099: LIST
92100: LIST
92101: LIST
92102: LIST
92103: LIST
92104: LIST
92105: LIST
92106: LIST
92107: LIST
92108: LIST
92109: LIST
92110: LIST
92111: LIST
92112: LIST
92113: LIST
92114: LIST
92115: LIST
92116: LIST
92117: LIST
92118: LIST
92119: LIST
92120: LIST
92121: LIST
92122: LIST
92123: LIST
92124: LIST
92125: LIST
92126: LIST
92127: PUSH
92128: LD_INT 101
92130: PUSH
92131: LD_INT 102
92133: PUSH
92134: LD_INT 103
92136: PUSH
92137: LD_INT 104
92139: PUSH
92140: LD_INT 105
92142: PUSH
92143: LD_INT 106
92145: PUSH
92146: LD_INT 107
92148: PUSH
92149: LD_INT 108
92151: PUSH
92152: LD_INT 109
92154: PUSH
92155: LD_INT 110
92157: PUSH
92158: LD_INT 111
92160: PUSH
92161: LD_INT 112
92163: PUSH
92164: LD_INT 113
92166: PUSH
92167: LD_INT 114
92169: PUSH
92170: LD_INT 116
92172: PUSH
92173: LD_INT 117
92175: PUSH
92176: LD_INT 118
92178: PUSH
92179: EMPTY
92180: LIST
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: LIST
92191: LIST
92192: LIST
92193: LIST
92194: LIST
92195: LIST
92196: LIST
92197: PUSH
92198: EMPTY
92199: LIST
92200: LIST
92201: ST_TO_ADDR
92202: GO 93657
92204: LD_INT 13
92206: DOUBLE
92207: EQUAL
92208: IFTRUE 92212
92210: GO 92420
92212: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
92213: LD_ADDR_VAR 0 2
92217: PUSH
92218: LD_INT 1
92220: PUSH
92221: LD_INT 2
92223: PUSH
92224: LD_INT 3
92226: PUSH
92227: LD_INT 4
92229: PUSH
92230: LD_INT 5
92232: PUSH
92233: LD_INT 8
92235: PUSH
92236: LD_INT 9
92238: PUSH
92239: LD_INT 10
92241: PUSH
92242: LD_INT 11
92244: PUSH
92245: LD_INT 12
92247: PUSH
92248: LD_INT 14
92250: PUSH
92251: LD_INT 15
92253: PUSH
92254: LD_INT 16
92256: PUSH
92257: LD_INT 17
92259: PUSH
92260: LD_INT 18
92262: PUSH
92263: LD_INT 19
92265: PUSH
92266: LD_INT 20
92268: PUSH
92269: LD_INT 21
92271: PUSH
92272: LD_INT 22
92274: PUSH
92275: LD_INT 23
92277: PUSH
92278: LD_INT 24
92280: PUSH
92281: LD_INT 25
92283: PUSH
92284: LD_INT 26
92286: PUSH
92287: LD_INT 27
92289: PUSH
92290: LD_INT 28
92292: PUSH
92293: LD_INT 30
92295: PUSH
92296: LD_INT 31
92298: PUSH
92299: LD_INT 32
92301: PUSH
92302: LD_INT 33
92304: PUSH
92305: LD_INT 34
92307: PUSH
92308: LD_INT 36
92310: PUSH
92311: EMPTY
92312: LIST
92313: LIST
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: LIST
92319: LIST
92320: LIST
92321: LIST
92322: LIST
92323: LIST
92324: LIST
92325: LIST
92326: LIST
92327: LIST
92328: LIST
92329: LIST
92330: LIST
92331: LIST
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: LIST
92337: LIST
92338: LIST
92339: LIST
92340: LIST
92341: LIST
92342: LIST
92343: PUSH
92344: LD_INT 101
92346: PUSH
92347: LD_INT 102
92349: PUSH
92350: LD_INT 103
92352: PUSH
92353: LD_INT 104
92355: PUSH
92356: LD_INT 105
92358: PUSH
92359: LD_INT 106
92361: PUSH
92362: LD_INT 107
92364: PUSH
92365: LD_INT 108
92367: PUSH
92368: LD_INT 109
92370: PUSH
92371: LD_INT 110
92373: PUSH
92374: LD_INT 111
92376: PUSH
92377: LD_INT 112
92379: PUSH
92380: LD_INT 113
92382: PUSH
92383: LD_INT 114
92385: PUSH
92386: LD_INT 116
92388: PUSH
92389: LD_INT 117
92391: PUSH
92392: LD_INT 118
92394: PUSH
92395: EMPTY
92396: LIST
92397: LIST
92398: LIST
92399: LIST
92400: LIST
92401: LIST
92402: LIST
92403: LIST
92404: LIST
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: PUSH
92414: EMPTY
92415: LIST
92416: LIST
92417: ST_TO_ADDR
92418: GO 93657
92420: LD_INT 14
92422: DOUBLE
92423: EQUAL
92424: IFTRUE 92428
92426: GO 92652
92428: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
92429: LD_ADDR_VAR 0 2
92433: PUSH
92434: LD_INT 1
92436: PUSH
92437: LD_INT 2
92439: PUSH
92440: LD_INT 3
92442: PUSH
92443: LD_INT 4
92445: PUSH
92446: LD_INT 5
92448: PUSH
92449: LD_INT 6
92451: PUSH
92452: LD_INT 7
92454: PUSH
92455: LD_INT 8
92457: PUSH
92458: LD_INT 9
92460: PUSH
92461: LD_INT 10
92463: PUSH
92464: LD_INT 11
92466: PUSH
92467: LD_INT 12
92469: PUSH
92470: LD_INT 13
92472: PUSH
92473: LD_INT 14
92475: PUSH
92476: LD_INT 15
92478: PUSH
92479: LD_INT 16
92481: PUSH
92482: LD_INT 17
92484: PUSH
92485: LD_INT 18
92487: PUSH
92488: LD_INT 19
92490: PUSH
92491: LD_INT 20
92493: PUSH
92494: LD_INT 21
92496: PUSH
92497: LD_INT 22
92499: PUSH
92500: LD_INT 23
92502: PUSH
92503: LD_INT 24
92505: PUSH
92506: LD_INT 25
92508: PUSH
92509: LD_INT 26
92511: PUSH
92512: LD_INT 27
92514: PUSH
92515: LD_INT 28
92517: PUSH
92518: LD_INT 29
92520: PUSH
92521: LD_INT 30
92523: PUSH
92524: LD_INT 31
92526: PUSH
92527: LD_INT 32
92529: PUSH
92530: LD_INT 33
92532: PUSH
92533: LD_INT 34
92535: PUSH
92536: LD_INT 36
92538: PUSH
92539: EMPTY
92540: LIST
92541: LIST
92542: LIST
92543: LIST
92544: LIST
92545: LIST
92546: LIST
92547: LIST
92548: LIST
92549: LIST
92550: LIST
92551: LIST
92552: LIST
92553: LIST
92554: LIST
92555: LIST
92556: LIST
92557: LIST
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: LIST
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: PUSH
92576: LD_INT 101
92578: PUSH
92579: LD_INT 102
92581: PUSH
92582: LD_INT 103
92584: PUSH
92585: LD_INT 104
92587: PUSH
92588: LD_INT 105
92590: PUSH
92591: LD_INT 106
92593: PUSH
92594: LD_INT 107
92596: PUSH
92597: LD_INT 108
92599: PUSH
92600: LD_INT 109
92602: PUSH
92603: LD_INT 110
92605: PUSH
92606: LD_INT 111
92608: PUSH
92609: LD_INT 112
92611: PUSH
92612: LD_INT 113
92614: PUSH
92615: LD_INT 114
92617: PUSH
92618: LD_INT 116
92620: PUSH
92621: LD_INT 117
92623: PUSH
92624: LD_INT 118
92626: PUSH
92627: EMPTY
92628: LIST
92629: LIST
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: PUSH
92646: EMPTY
92647: LIST
92648: LIST
92649: ST_TO_ADDR
92650: GO 93657
92652: LD_INT 15
92654: DOUBLE
92655: EQUAL
92656: IFTRUE 92660
92658: GO 92884
92660: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
92661: LD_ADDR_VAR 0 2
92665: PUSH
92666: LD_INT 1
92668: PUSH
92669: LD_INT 2
92671: PUSH
92672: LD_INT 3
92674: PUSH
92675: LD_INT 4
92677: PUSH
92678: LD_INT 5
92680: PUSH
92681: LD_INT 6
92683: PUSH
92684: LD_INT 7
92686: PUSH
92687: LD_INT 8
92689: PUSH
92690: LD_INT 9
92692: PUSH
92693: LD_INT 10
92695: PUSH
92696: LD_INT 11
92698: PUSH
92699: LD_INT 12
92701: PUSH
92702: LD_INT 13
92704: PUSH
92705: LD_INT 14
92707: PUSH
92708: LD_INT 15
92710: PUSH
92711: LD_INT 16
92713: PUSH
92714: LD_INT 17
92716: PUSH
92717: LD_INT 18
92719: PUSH
92720: LD_INT 19
92722: PUSH
92723: LD_INT 20
92725: PUSH
92726: LD_INT 21
92728: PUSH
92729: LD_INT 22
92731: PUSH
92732: LD_INT 23
92734: PUSH
92735: LD_INT 24
92737: PUSH
92738: LD_INT 25
92740: PUSH
92741: LD_INT 26
92743: PUSH
92744: LD_INT 27
92746: PUSH
92747: LD_INT 28
92749: PUSH
92750: LD_INT 29
92752: PUSH
92753: LD_INT 30
92755: PUSH
92756: LD_INT 31
92758: PUSH
92759: LD_INT 32
92761: PUSH
92762: LD_INT 33
92764: PUSH
92765: LD_INT 34
92767: PUSH
92768: LD_INT 36
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: LIST
92807: PUSH
92808: LD_INT 101
92810: PUSH
92811: LD_INT 102
92813: PUSH
92814: LD_INT 103
92816: PUSH
92817: LD_INT 104
92819: PUSH
92820: LD_INT 105
92822: PUSH
92823: LD_INT 106
92825: PUSH
92826: LD_INT 107
92828: PUSH
92829: LD_INT 108
92831: PUSH
92832: LD_INT 109
92834: PUSH
92835: LD_INT 110
92837: PUSH
92838: LD_INT 111
92840: PUSH
92841: LD_INT 112
92843: PUSH
92844: LD_INT 113
92846: PUSH
92847: LD_INT 114
92849: PUSH
92850: LD_INT 116
92852: PUSH
92853: LD_INT 117
92855: PUSH
92856: LD_INT 118
92858: PUSH
92859: EMPTY
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: PUSH
92878: EMPTY
92879: LIST
92880: LIST
92881: ST_TO_ADDR
92882: GO 93657
92884: LD_INT 16
92886: DOUBLE
92887: EQUAL
92888: IFTRUE 92892
92890: GO 93028
92892: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
92893: LD_ADDR_VAR 0 2
92897: PUSH
92898: LD_INT 2
92900: PUSH
92901: LD_INT 4
92903: PUSH
92904: LD_INT 5
92906: PUSH
92907: LD_INT 7
92909: PUSH
92910: LD_INT 11
92912: PUSH
92913: LD_INT 12
92915: PUSH
92916: LD_INT 15
92918: PUSH
92919: LD_INT 16
92921: PUSH
92922: LD_INT 20
92924: PUSH
92925: LD_INT 21
92927: PUSH
92928: LD_INT 22
92930: PUSH
92931: LD_INT 23
92933: PUSH
92934: LD_INT 25
92936: PUSH
92937: LD_INT 26
92939: PUSH
92940: LD_INT 30
92942: PUSH
92943: LD_INT 31
92945: PUSH
92946: LD_INT 32
92948: PUSH
92949: LD_INT 33
92951: PUSH
92952: LD_INT 34
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: LIST
92959: LIST
92960: LIST
92961: LIST
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: PUSH
92976: LD_INT 101
92978: PUSH
92979: LD_INT 102
92981: PUSH
92982: LD_INT 103
92984: PUSH
92985: LD_INT 106
92987: PUSH
92988: LD_INT 108
92990: PUSH
92991: LD_INT 112
92993: PUSH
92994: LD_INT 113
92996: PUSH
92997: LD_INT 114
92999: PUSH
93000: LD_INT 116
93002: PUSH
93003: LD_INT 117
93005: PUSH
93006: LD_INT 118
93008: PUSH
93009: EMPTY
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: LIST
93018: LIST
93019: LIST
93020: LIST
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: ST_TO_ADDR
93026: GO 93657
93028: LD_INT 17
93030: DOUBLE
93031: EQUAL
93032: IFTRUE 93036
93034: GO 93260
93036: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
93037: LD_ADDR_VAR 0 2
93041: PUSH
93042: LD_INT 1
93044: PUSH
93045: LD_INT 2
93047: PUSH
93048: LD_INT 3
93050: PUSH
93051: LD_INT 4
93053: PUSH
93054: LD_INT 5
93056: PUSH
93057: LD_INT 6
93059: PUSH
93060: LD_INT 7
93062: PUSH
93063: LD_INT 8
93065: PUSH
93066: LD_INT 9
93068: PUSH
93069: LD_INT 10
93071: PUSH
93072: LD_INT 11
93074: PUSH
93075: LD_INT 12
93077: PUSH
93078: LD_INT 13
93080: PUSH
93081: LD_INT 14
93083: PUSH
93084: LD_INT 15
93086: PUSH
93087: LD_INT 16
93089: PUSH
93090: LD_INT 17
93092: PUSH
93093: LD_INT 18
93095: PUSH
93096: LD_INT 19
93098: PUSH
93099: LD_INT 20
93101: PUSH
93102: LD_INT 21
93104: PUSH
93105: LD_INT 22
93107: PUSH
93108: LD_INT 23
93110: PUSH
93111: LD_INT 24
93113: PUSH
93114: LD_INT 25
93116: PUSH
93117: LD_INT 26
93119: PUSH
93120: LD_INT 27
93122: PUSH
93123: LD_INT 28
93125: PUSH
93126: LD_INT 29
93128: PUSH
93129: LD_INT 30
93131: PUSH
93132: LD_INT 31
93134: PUSH
93135: LD_INT 32
93137: PUSH
93138: LD_INT 33
93140: PUSH
93141: LD_INT 34
93143: PUSH
93144: LD_INT 36
93146: PUSH
93147: EMPTY
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: LIST
93158: LIST
93159: LIST
93160: LIST
93161: LIST
93162: LIST
93163: LIST
93164: LIST
93165: LIST
93166: LIST
93167: LIST
93168: LIST
93169: LIST
93170: LIST
93171: LIST
93172: LIST
93173: LIST
93174: LIST
93175: LIST
93176: LIST
93177: LIST
93178: LIST
93179: LIST
93180: LIST
93181: LIST
93182: LIST
93183: PUSH
93184: LD_INT 101
93186: PUSH
93187: LD_INT 102
93189: PUSH
93190: LD_INT 103
93192: PUSH
93193: LD_INT 104
93195: PUSH
93196: LD_INT 105
93198: PUSH
93199: LD_INT 106
93201: PUSH
93202: LD_INT 107
93204: PUSH
93205: LD_INT 108
93207: PUSH
93208: LD_INT 109
93210: PUSH
93211: LD_INT 110
93213: PUSH
93214: LD_INT 111
93216: PUSH
93217: LD_INT 112
93219: PUSH
93220: LD_INT 113
93222: PUSH
93223: LD_INT 114
93225: PUSH
93226: LD_INT 116
93228: PUSH
93229: LD_INT 117
93231: PUSH
93232: LD_INT 118
93234: PUSH
93235: EMPTY
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: LIST
93249: LIST
93250: LIST
93251: LIST
93252: LIST
93253: PUSH
93254: EMPTY
93255: LIST
93256: LIST
93257: ST_TO_ADDR
93258: GO 93657
93260: LD_INT 18
93262: DOUBLE
93263: EQUAL
93264: IFTRUE 93268
93266: GO 93416
93268: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
93269: LD_ADDR_VAR 0 2
93273: PUSH
93274: LD_INT 2
93276: PUSH
93277: LD_INT 4
93279: PUSH
93280: LD_INT 5
93282: PUSH
93283: LD_INT 7
93285: PUSH
93286: LD_INT 11
93288: PUSH
93289: LD_INT 12
93291: PUSH
93292: LD_INT 15
93294: PUSH
93295: LD_INT 16
93297: PUSH
93298: LD_INT 20
93300: PUSH
93301: LD_INT 21
93303: PUSH
93304: LD_INT 22
93306: PUSH
93307: LD_INT 23
93309: PUSH
93310: LD_INT 25
93312: PUSH
93313: LD_INT 26
93315: PUSH
93316: LD_INT 30
93318: PUSH
93319: LD_INT 31
93321: PUSH
93322: LD_INT 32
93324: PUSH
93325: LD_INT 33
93327: PUSH
93328: LD_INT 34
93330: PUSH
93331: LD_INT 35
93333: PUSH
93334: LD_INT 36
93336: PUSH
93337: EMPTY
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: PUSH
93360: LD_INT 101
93362: PUSH
93363: LD_INT 102
93365: PUSH
93366: LD_INT 103
93368: PUSH
93369: LD_INT 106
93371: PUSH
93372: LD_INT 108
93374: PUSH
93375: LD_INT 112
93377: PUSH
93378: LD_INT 113
93380: PUSH
93381: LD_INT 114
93383: PUSH
93384: LD_INT 115
93386: PUSH
93387: LD_INT 116
93389: PUSH
93390: LD_INT 117
93392: PUSH
93393: LD_INT 118
93395: PUSH
93396: EMPTY
93397: LIST
93398: LIST
93399: LIST
93400: LIST
93401: LIST
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: LIST
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: ST_TO_ADDR
93414: GO 93657
93416: LD_INT 19
93418: DOUBLE
93419: EQUAL
93420: IFTRUE 93424
93422: GO 93656
93424: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
93425: LD_ADDR_VAR 0 2
93429: PUSH
93430: LD_INT 1
93432: PUSH
93433: LD_INT 2
93435: PUSH
93436: LD_INT 3
93438: PUSH
93439: LD_INT 4
93441: PUSH
93442: LD_INT 5
93444: PUSH
93445: LD_INT 6
93447: PUSH
93448: LD_INT 7
93450: PUSH
93451: LD_INT 8
93453: PUSH
93454: LD_INT 9
93456: PUSH
93457: LD_INT 10
93459: PUSH
93460: LD_INT 11
93462: PUSH
93463: LD_INT 12
93465: PUSH
93466: LD_INT 13
93468: PUSH
93469: LD_INT 14
93471: PUSH
93472: LD_INT 15
93474: PUSH
93475: LD_INT 16
93477: PUSH
93478: LD_INT 17
93480: PUSH
93481: LD_INT 18
93483: PUSH
93484: LD_INT 19
93486: PUSH
93487: LD_INT 20
93489: PUSH
93490: LD_INT 21
93492: PUSH
93493: LD_INT 22
93495: PUSH
93496: LD_INT 23
93498: PUSH
93499: LD_INT 24
93501: PUSH
93502: LD_INT 25
93504: PUSH
93505: LD_INT 26
93507: PUSH
93508: LD_INT 27
93510: PUSH
93511: LD_INT 28
93513: PUSH
93514: LD_INT 29
93516: PUSH
93517: LD_INT 30
93519: PUSH
93520: LD_INT 31
93522: PUSH
93523: LD_INT 32
93525: PUSH
93526: LD_INT 33
93528: PUSH
93529: LD_INT 34
93531: PUSH
93532: LD_INT 35
93534: PUSH
93535: LD_INT 36
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: LIST
93542: LIST
93543: LIST
93544: LIST
93545: LIST
93546: LIST
93547: LIST
93548: LIST
93549: LIST
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: LIST
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: PUSH
93576: LD_INT 101
93578: PUSH
93579: LD_INT 102
93581: PUSH
93582: LD_INT 103
93584: PUSH
93585: LD_INT 104
93587: PUSH
93588: LD_INT 105
93590: PUSH
93591: LD_INT 106
93593: PUSH
93594: LD_INT 107
93596: PUSH
93597: LD_INT 108
93599: PUSH
93600: LD_INT 109
93602: PUSH
93603: LD_INT 110
93605: PUSH
93606: LD_INT 111
93608: PUSH
93609: LD_INT 112
93611: PUSH
93612: LD_INT 113
93614: PUSH
93615: LD_INT 114
93617: PUSH
93618: LD_INT 115
93620: PUSH
93621: LD_INT 116
93623: PUSH
93624: LD_INT 117
93626: PUSH
93627: LD_INT 118
93629: PUSH
93630: EMPTY
93631: LIST
93632: LIST
93633: LIST
93634: LIST
93635: LIST
93636: LIST
93637: LIST
93638: LIST
93639: LIST
93640: LIST
93641: LIST
93642: LIST
93643: LIST
93644: LIST
93645: LIST
93646: LIST
93647: LIST
93648: LIST
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: ST_TO_ADDR
93654: GO 93657
93656: POP
// end else
93657: GO 93888
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
93659: LD_ADDR_VAR 0 2
93663: PUSH
93664: LD_INT 1
93666: PUSH
93667: LD_INT 2
93669: PUSH
93670: LD_INT 3
93672: PUSH
93673: LD_INT 4
93675: PUSH
93676: LD_INT 5
93678: PUSH
93679: LD_INT 6
93681: PUSH
93682: LD_INT 7
93684: PUSH
93685: LD_INT 8
93687: PUSH
93688: LD_INT 9
93690: PUSH
93691: LD_INT 10
93693: PUSH
93694: LD_INT 11
93696: PUSH
93697: LD_INT 12
93699: PUSH
93700: LD_INT 13
93702: PUSH
93703: LD_INT 14
93705: PUSH
93706: LD_INT 15
93708: PUSH
93709: LD_INT 16
93711: PUSH
93712: LD_INT 17
93714: PUSH
93715: LD_INT 18
93717: PUSH
93718: LD_INT 19
93720: PUSH
93721: LD_INT 20
93723: PUSH
93724: LD_INT 21
93726: PUSH
93727: LD_INT 22
93729: PUSH
93730: LD_INT 23
93732: PUSH
93733: LD_INT 24
93735: PUSH
93736: LD_INT 25
93738: PUSH
93739: LD_INT 26
93741: PUSH
93742: LD_INT 27
93744: PUSH
93745: LD_INT 28
93747: PUSH
93748: LD_INT 29
93750: PUSH
93751: LD_INT 30
93753: PUSH
93754: LD_INT 31
93756: PUSH
93757: LD_INT 32
93759: PUSH
93760: LD_INT 33
93762: PUSH
93763: LD_INT 34
93765: PUSH
93766: LD_INT 35
93768: PUSH
93769: LD_INT 36
93771: PUSH
93772: EMPTY
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: LIST
93783: LIST
93784: LIST
93785: LIST
93786: LIST
93787: LIST
93788: LIST
93789: LIST
93790: LIST
93791: LIST
93792: LIST
93793: LIST
93794: LIST
93795: LIST
93796: LIST
93797: LIST
93798: LIST
93799: LIST
93800: LIST
93801: LIST
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: LIST
93807: LIST
93808: LIST
93809: PUSH
93810: LD_INT 101
93812: PUSH
93813: LD_INT 102
93815: PUSH
93816: LD_INT 103
93818: PUSH
93819: LD_INT 104
93821: PUSH
93822: LD_INT 105
93824: PUSH
93825: LD_INT 106
93827: PUSH
93828: LD_INT 107
93830: PUSH
93831: LD_INT 108
93833: PUSH
93834: LD_INT 109
93836: PUSH
93837: LD_INT 110
93839: PUSH
93840: LD_INT 111
93842: PUSH
93843: LD_INT 112
93845: PUSH
93846: LD_INT 113
93848: PUSH
93849: LD_INT 114
93851: PUSH
93852: LD_INT 115
93854: PUSH
93855: LD_INT 116
93857: PUSH
93858: LD_INT 117
93860: PUSH
93861: LD_INT 118
93863: PUSH
93864: EMPTY
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: ST_TO_ADDR
// if result then
93888: LD_VAR 0 2
93892: IFFALSE 94678
// begin normal :=  ;
93894: LD_ADDR_VAR 0 5
93898: PUSH
93899: LD_STRING 
93901: ST_TO_ADDR
// hardcore :=  ;
93902: LD_ADDR_VAR 0 6
93906: PUSH
93907: LD_STRING 
93909: ST_TO_ADDR
// active :=  ;
93910: LD_ADDR_VAR 0 7
93914: PUSH
93915: LD_STRING 
93917: ST_TO_ADDR
// for i = 1 to normalCounter do
93918: LD_ADDR_VAR 0 8
93922: PUSH
93923: DOUBLE
93924: LD_INT 1
93926: DEC
93927: ST_TO_ADDR
93928: LD_EXP 114
93932: PUSH
93933: FOR_TO
93934: IFFALSE 94035
// begin tmp := 0 ;
93936: LD_ADDR_VAR 0 3
93940: PUSH
93941: LD_STRING 0
93943: ST_TO_ADDR
// if result [ 1 ] then
93944: LD_VAR 0 2
93948: PUSH
93949: LD_INT 1
93951: ARRAY
93952: IFFALSE 94017
// if result [ 1 ] [ 1 ] = i then
93954: LD_VAR 0 2
93958: PUSH
93959: LD_INT 1
93961: ARRAY
93962: PUSH
93963: LD_INT 1
93965: ARRAY
93966: PUSH
93967: LD_VAR 0 8
93971: EQUAL
93972: IFFALSE 94017
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
93974: LD_ADDR_VAR 0 2
93978: PUSH
93979: LD_VAR 0 2
93983: PPUSH
93984: LD_INT 1
93986: PPUSH
93987: LD_VAR 0 2
93991: PUSH
93992: LD_INT 1
93994: ARRAY
93995: PPUSH
93996: LD_INT 1
93998: PPUSH
93999: CALL_OW 3
94003: PPUSH
94004: CALL_OW 1
94008: ST_TO_ADDR
// tmp := 1 ;
94009: LD_ADDR_VAR 0 3
94013: PUSH
94014: LD_STRING 1
94016: ST_TO_ADDR
// end ; normal := normal & tmp ;
94017: LD_ADDR_VAR 0 5
94021: PUSH
94022: LD_VAR 0 5
94026: PUSH
94027: LD_VAR 0 3
94031: STR
94032: ST_TO_ADDR
// end ;
94033: GO 93933
94035: POP
94036: POP
// for i = 1 to hardcoreCounter do
94037: LD_ADDR_VAR 0 8
94041: PUSH
94042: DOUBLE
94043: LD_INT 1
94045: DEC
94046: ST_TO_ADDR
94047: LD_EXP 115
94051: PUSH
94052: FOR_TO
94053: IFFALSE 94158
// begin tmp := 0 ;
94055: LD_ADDR_VAR 0 3
94059: PUSH
94060: LD_STRING 0
94062: ST_TO_ADDR
// if result [ 2 ] then
94063: LD_VAR 0 2
94067: PUSH
94068: LD_INT 2
94070: ARRAY
94071: IFFALSE 94140
// if result [ 2 ] [ 1 ] = 100 + i then
94073: LD_VAR 0 2
94077: PUSH
94078: LD_INT 2
94080: ARRAY
94081: PUSH
94082: LD_INT 1
94084: ARRAY
94085: PUSH
94086: LD_INT 100
94088: PUSH
94089: LD_VAR 0 8
94093: PLUS
94094: EQUAL
94095: IFFALSE 94140
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
94097: LD_ADDR_VAR 0 2
94101: PUSH
94102: LD_VAR 0 2
94106: PPUSH
94107: LD_INT 2
94109: PPUSH
94110: LD_VAR 0 2
94114: PUSH
94115: LD_INT 2
94117: ARRAY
94118: PPUSH
94119: LD_INT 1
94121: PPUSH
94122: CALL_OW 3
94126: PPUSH
94127: CALL_OW 1
94131: ST_TO_ADDR
// tmp := 1 ;
94132: LD_ADDR_VAR 0 3
94136: PUSH
94137: LD_STRING 1
94139: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
94140: LD_ADDR_VAR 0 6
94144: PUSH
94145: LD_VAR 0 6
94149: PUSH
94150: LD_VAR 0 3
94154: STR
94155: ST_TO_ADDR
// end ;
94156: GO 94052
94158: POP
94159: POP
// if isGameLoad then
94160: LD_VAR 0 1
94164: IFFALSE 94639
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
94166: LD_ADDR_VAR 0 4
94170: PUSH
94171: LD_EXP 118
94175: PUSH
94176: LD_EXP 117
94180: PUSH
94181: LD_EXP 119
94185: PUSH
94186: LD_EXP 116
94190: PUSH
94191: LD_EXP 120
94195: PUSH
94196: LD_EXP 121
94200: PUSH
94201: LD_EXP 122
94205: PUSH
94206: LD_EXP 123
94210: PUSH
94211: LD_EXP 124
94215: PUSH
94216: LD_EXP 125
94220: PUSH
94221: LD_EXP 126
94225: PUSH
94226: LD_EXP 127
94230: PUSH
94231: LD_EXP 128
94235: PUSH
94236: LD_EXP 129
94240: PUSH
94241: LD_EXP 137
94245: PUSH
94246: LD_EXP 138
94250: PUSH
94251: LD_EXP 139
94255: PUSH
94256: LD_EXP 140
94260: PUSH
94261: LD_EXP 142
94265: PUSH
94266: LD_EXP 143
94270: PUSH
94271: LD_EXP 144
94275: PUSH
94276: LD_EXP 147
94280: PUSH
94281: LD_EXP 149
94285: PUSH
94286: LD_EXP 150
94290: PUSH
94291: LD_EXP 151
94295: PUSH
94296: LD_EXP 153
94300: PUSH
94301: LD_EXP 154
94305: PUSH
94306: LD_EXP 157
94310: PUSH
94311: LD_EXP 158
94315: PUSH
94316: LD_EXP 159
94320: PUSH
94321: LD_EXP 160
94325: PUSH
94326: LD_EXP 161
94330: PUSH
94331: LD_EXP 162
94335: PUSH
94336: LD_EXP 163
94340: PUSH
94341: LD_EXP 164
94345: PUSH
94346: LD_EXP 165
94350: PUSH
94351: LD_EXP 130
94355: PUSH
94356: LD_EXP 131
94360: PUSH
94361: LD_EXP 134
94365: PUSH
94366: LD_EXP 135
94370: PUSH
94371: LD_EXP 136
94375: PUSH
94376: LD_EXP 132
94380: PUSH
94381: LD_EXP 133
94385: PUSH
94386: LD_EXP 141
94390: PUSH
94391: LD_EXP 145
94395: PUSH
94396: LD_EXP 146
94400: PUSH
94401: LD_EXP 148
94405: PUSH
94406: LD_EXP 152
94410: PUSH
94411: LD_EXP 155
94415: PUSH
94416: LD_EXP 156
94420: PUSH
94421: LD_EXP 166
94425: PUSH
94426: LD_EXP 167
94430: PUSH
94431: LD_EXP 168
94435: PUSH
94436: LD_EXP 169
94440: PUSH
94441: EMPTY
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: ST_TO_ADDR
// tmp :=  ;
94497: LD_ADDR_VAR 0 3
94501: PUSH
94502: LD_STRING 
94504: ST_TO_ADDR
// for i = 1 to normalCounter do
94505: LD_ADDR_VAR 0 8
94509: PUSH
94510: DOUBLE
94511: LD_INT 1
94513: DEC
94514: ST_TO_ADDR
94515: LD_EXP 114
94519: PUSH
94520: FOR_TO
94521: IFFALSE 94557
// begin if flags [ i ] then
94523: LD_VAR 0 4
94527: PUSH
94528: LD_VAR 0 8
94532: ARRAY
94533: IFFALSE 94555
// tmp := tmp & i & ; ;
94535: LD_ADDR_VAR 0 3
94539: PUSH
94540: LD_VAR 0 3
94544: PUSH
94545: LD_VAR 0 8
94549: STR
94550: PUSH
94551: LD_STRING ;
94553: STR
94554: ST_TO_ADDR
// end ;
94555: GO 94520
94557: POP
94558: POP
// for i = 1 to hardcoreCounter do
94559: LD_ADDR_VAR 0 8
94563: PUSH
94564: DOUBLE
94565: LD_INT 1
94567: DEC
94568: ST_TO_ADDR
94569: LD_EXP 115
94573: PUSH
94574: FOR_TO
94575: IFFALSE 94621
// begin if flags [ normalCounter + i ] then
94577: LD_VAR 0 4
94581: PUSH
94582: LD_EXP 114
94586: PUSH
94587: LD_VAR 0 8
94591: PLUS
94592: ARRAY
94593: IFFALSE 94619
// tmp := tmp & ( 100 + i ) & ; ;
94595: LD_ADDR_VAR 0 3
94599: PUSH
94600: LD_VAR 0 3
94604: PUSH
94605: LD_INT 100
94607: PUSH
94608: LD_VAR 0 8
94612: PLUS
94613: STR
94614: PUSH
94615: LD_STRING ;
94617: STR
94618: ST_TO_ADDR
// end ;
94619: GO 94574
94621: POP
94622: POP
// if tmp then
94623: LD_VAR 0 3
94627: IFFALSE 94639
// active := tmp ;
94629: LD_ADDR_VAR 0 7
94633: PUSH
94634: LD_VAR 0 3
94638: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
94639: LD_STRING getStreamItemsFromMission("
94641: PUSH
94642: LD_VAR 0 5
94646: STR
94647: PUSH
94648: LD_STRING ","
94650: STR
94651: PUSH
94652: LD_VAR 0 6
94656: STR
94657: PUSH
94658: LD_STRING ","
94660: STR
94661: PUSH
94662: LD_VAR 0 7
94666: STR
94667: PUSH
94668: LD_STRING ")
94670: STR
94671: PPUSH
94672: CALL_OW 559
// end else
94676: GO 94685
// ToLua ( getStreamItemsFromMission("","","") ) ;
94678: LD_STRING getStreamItemsFromMission("","","")
94680: PPUSH
94681: CALL_OW 559
// end ;
94685: LD_VAR 0 2
94689: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
94690: LD_EXP 113
94694: PUSH
94695: LD_EXP 118
94699: AND
94700: IFFALSE 94824
94702: GO 94704
94704: DISABLE
94705: LD_INT 0
94707: PPUSH
94708: PPUSH
// begin enable ;
94709: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
94710: LD_ADDR_VAR 0 2
94714: PUSH
94715: LD_INT 22
94717: PUSH
94718: LD_OWVAR 2
94722: PUSH
94723: EMPTY
94724: LIST
94725: LIST
94726: PUSH
94727: LD_INT 2
94729: PUSH
94730: LD_INT 34
94732: PUSH
94733: LD_INT 7
94735: PUSH
94736: EMPTY
94737: LIST
94738: LIST
94739: PUSH
94740: LD_INT 34
94742: PUSH
94743: LD_INT 45
94745: PUSH
94746: EMPTY
94747: LIST
94748: LIST
94749: PUSH
94750: LD_INT 34
94752: PUSH
94753: LD_INT 28
94755: PUSH
94756: EMPTY
94757: LIST
94758: LIST
94759: PUSH
94760: LD_INT 34
94762: PUSH
94763: LD_INT 47
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PUSH
94770: EMPTY
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: PUSH
94777: EMPTY
94778: LIST
94779: LIST
94780: PPUSH
94781: CALL_OW 69
94785: ST_TO_ADDR
// if not tmp then
94786: LD_VAR 0 2
94790: NOT
94791: IFFALSE 94795
// exit ;
94793: GO 94824
// for i in tmp do
94795: LD_ADDR_VAR 0 1
94799: PUSH
94800: LD_VAR 0 2
94804: PUSH
94805: FOR_IN
94806: IFFALSE 94822
// begin SetLives ( i , 0 ) ;
94808: LD_VAR 0 1
94812: PPUSH
94813: LD_INT 0
94815: PPUSH
94816: CALL_OW 234
// end ;
94820: GO 94805
94822: POP
94823: POP
// end ;
94824: PPOPN 2
94826: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
94827: LD_EXP 113
94831: PUSH
94832: LD_EXP 119
94836: AND
94837: IFFALSE 94921
94839: GO 94841
94841: DISABLE
94842: LD_INT 0
94844: PPUSH
94845: PPUSH
// begin enable ;
94846: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
94847: LD_ADDR_VAR 0 2
94851: PUSH
94852: LD_INT 22
94854: PUSH
94855: LD_OWVAR 2
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: LD_INT 32
94866: PUSH
94867: LD_INT 3
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: PUSH
94874: EMPTY
94875: LIST
94876: LIST
94877: PPUSH
94878: CALL_OW 69
94882: ST_TO_ADDR
// if not tmp then
94883: LD_VAR 0 2
94887: NOT
94888: IFFALSE 94892
// exit ;
94890: GO 94921
// for i in tmp do
94892: LD_ADDR_VAR 0 1
94896: PUSH
94897: LD_VAR 0 2
94901: PUSH
94902: FOR_IN
94903: IFFALSE 94919
// begin SetLives ( i , 0 ) ;
94905: LD_VAR 0 1
94909: PPUSH
94910: LD_INT 0
94912: PPUSH
94913: CALL_OW 234
// end ;
94917: GO 94902
94919: POP
94920: POP
// end ;
94921: PPOPN 2
94923: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
94924: LD_EXP 113
94928: PUSH
94929: LD_EXP 116
94933: AND
94934: IFFALSE 95027
94936: GO 94938
94938: DISABLE
94939: LD_INT 0
94941: PPUSH
// begin enable ;
94942: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
94943: LD_ADDR_VAR 0 1
94947: PUSH
94948: LD_INT 22
94950: PUSH
94951: LD_OWVAR 2
94955: PUSH
94956: EMPTY
94957: LIST
94958: LIST
94959: PUSH
94960: LD_INT 2
94962: PUSH
94963: LD_INT 25
94965: PUSH
94966: LD_INT 5
94968: PUSH
94969: EMPTY
94970: LIST
94971: LIST
94972: PUSH
94973: LD_INT 25
94975: PUSH
94976: LD_INT 9
94978: PUSH
94979: EMPTY
94980: LIST
94981: LIST
94982: PUSH
94983: LD_INT 25
94985: PUSH
94986: LD_INT 8
94988: PUSH
94989: EMPTY
94990: LIST
94991: LIST
94992: PUSH
94993: EMPTY
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: PUSH
94999: EMPTY
95000: LIST
95001: LIST
95002: PPUSH
95003: CALL_OW 69
95007: PUSH
95008: FOR_IN
95009: IFFALSE 95025
// begin SetClass ( i , 1 ) ;
95011: LD_VAR 0 1
95015: PPUSH
95016: LD_INT 1
95018: PPUSH
95019: CALL_OW 336
// end ;
95023: GO 95008
95025: POP
95026: POP
// end ;
95027: PPOPN 1
95029: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
95030: LD_EXP 113
95034: PUSH
95035: LD_EXP 117
95039: AND
95040: PUSH
95041: LD_OWVAR 65
95045: PUSH
95046: LD_INT 7
95048: LESS
95049: AND
95050: IFFALSE 95064
95052: GO 95054
95054: DISABLE
// begin enable ;
95055: ENABLE
// game_speed := 7 ;
95056: LD_ADDR_OWVAR 65
95060: PUSH
95061: LD_INT 7
95063: ST_TO_ADDR
// end ;
95064: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
95065: LD_EXP 113
95069: PUSH
95070: LD_EXP 120
95074: AND
95075: IFFALSE 95277
95077: GO 95079
95079: DISABLE
95080: LD_INT 0
95082: PPUSH
95083: PPUSH
95084: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
95085: LD_ADDR_VAR 0 3
95089: PUSH
95090: LD_INT 81
95092: PUSH
95093: LD_OWVAR 2
95097: PUSH
95098: EMPTY
95099: LIST
95100: LIST
95101: PUSH
95102: LD_INT 21
95104: PUSH
95105: LD_INT 1
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: EMPTY
95113: LIST
95114: LIST
95115: PPUSH
95116: CALL_OW 69
95120: ST_TO_ADDR
// if not tmp then
95121: LD_VAR 0 3
95125: NOT
95126: IFFALSE 95130
// exit ;
95128: GO 95277
// if tmp > 5 then
95130: LD_VAR 0 3
95134: PUSH
95135: LD_INT 5
95137: GREATER
95138: IFFALSE 95150
// k := 5 else
95140: LD_ADDR_VAR 0 2
95144: PUSH
95145: LD_INT 5
95147: ST_TO_ADDR
95148: GO 95160
// k := tmp ;
95150: LD_ADDR_VAR 0 2
95154: PUSH
95155: LD_VAR 0 3
95159: ST_TO_ADDR
// for i := 1 to k do
95160: LD_ADDR_VAR 0 1
95164: PUSH
95165: DOUBLE
95166: LD_INT 1
95168: DEC
95169: ST_TO_ADDR
95170: LD_VAR 0 2
95174: PUSH
95175: FOR_TO
95176: IFFALSE 95275
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
95178: LD_VAR 0 3
95182: PUSH
95183: LD_VAR 0 1
95187: ARRAY
95188: PPUSH
95189: LD_VAR 0 1
95193: PUSH
95194: LD_INT 4
95196: MOD
95197: PUSH
95198: LD_INT 1
95200: PLUS
95201: PPUSH
95202: CALL_OW 259
95206: PUSH
95207: LD_INT 10
95209: LESS
95210: IFFALSE 95273
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
95212: LD_VAR 0 3
95216: PUSH
95217: LD_VAR 0 1
95221: ARRAY
95222: PPUSH
95223: LD_VAR 0 1
95227: PUSH
95228: LD_INT 4
95230: MOD
95231: PUSH
95232: LD_INT 1
95234: PLUS
95235: PPUSH
95236: LD_VAR 0 3
95240: PUSH
95241: LD_VAR 0 1
95245: ARRAY
95246: PPUSH
95247: LD_VAR 0 1
95251: PUSH
95252: LD_INT 4
95254: MOD
95255: PUSH
95256: LD_INT 1
95258: PLUS
95259: PPUSH
95260: CALL_OW 259
95264: PUSH
95265: LD_INT 1
95267: PLUS
95268: PPUSH
95269: CALL_OW 237
95273: GO 95175
95275: POP
95276: POP
// end ;
95277: PPOPN 3
95279: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
95280: LD_EXP 113
95284: PUSH
95285: LD_EXP 121
95289: AND
95290: IFFALSE 95310
95292: GO 95294
95294: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
95295: LD_INT 4
95297: PPUSH
95298: LD_OWVAR 2
95302: PPUSH
95303: LD_INT 0
95305: PPUSH
95306: CALL_OW 324
95310: END
// every 0 0$1 trigger StreamModeActive and sShovel do
95311: LD_EXP 113
95315: PUSH
95316: LD_EXP 150
95320: AND
95321: IFFALSE 95341
95323: GO 95325
95325: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
95326: LD_INT 19
95328: PPUSH
95329: LD_OWVAR 2
95333: PPUSH
95334: LD_INT 0
95336: PPUSH
95337: CALL_OW 324
95341: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
95342: LD_EXP 113
95346: PUSH
95347: LD_EXP 122
95351: AND
95352: IFFALSE 95454
95354: GO 95356
95356: DISABLE
95357: LD_INT 0
95359: PPUSH
95360: PPUSH
// begin enable ;
95361: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
95362: LD_ADDR_VAR 0 2
95366: PUSH
95367: LD_INT 22
95369: PUSH
95370: LD_OWVAR 2
95374: PUSH
95375: EMPTY
95376: LIST
95377: LIST
95378: PUSH
95379: LD_INT 2
95381: PUSH
95382: LD_INT 34
95384: PUSH
95385: LD_INT 11
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: PUSH
95392: LD_INT 34
95394: PUSH
95395: LD_INT 30
95397: PUSH
95398: EMPTY
95399: LIST
95400: LIST
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: LIST
95406: PUSH
95407: EMPTY
95408: LIST
95409: LIST
95410: PPUSH
95411: CALL_OW 69
95415: ST_TO_ADDR
// if not tmp then
95416: LD_VAR 0 2
95420: NOT
95421: IFFALSE 95425
// exit ;
95423: GO 95454
// for i in tmp do
95425: LD_ADDR_VAR 0 1
95429: PUSH
95430: LD_VAR 0 2
95434: PUSH
95435: FOR_IN
95436: IFFALSE 95452
// begin SetLives ( i , 0 ) ;
95438: LD_VAR 0 1
95442: PPUSH
95443: LD_INT 0
95445: PPUSH
95446: CALL_OW 234
// end ;
95450: GO 95435
95452: POP
95453: POP
// end ;
95454: PPOPN 2
95456: END
// every 0 0$1 trigger StreamModeActive and sBunker do
95457: LD_EXP 113
95461: PUSH
95462: LD_EXP 123
95466: AND
95467: IFFALSE 95487
95469: GO 95471
95471: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
95472: LD_INT 32
95474: PPUSH
95475: LD_OWVAR 2
95479: PPUSH
95480: LD_INT 0
95482: PPUSH
95483: CALL_OW 324
95487: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
95488: LD_EXP 113
95492: PUSH
95493: LD_EXP 124
95497: AND
95498: IFFALSE 95679
95500: GO 95502
95502: DISABLE
95503: LD_INT 0
95505: PPUSH
95506: PPUSH
95507: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
95508: LD_ADDR_VAR 0 2
95512: PUSH
95513: LD_INT 22
95515: PUSH
95516: LD_OWVAR 2
95520: PUSH
95521: EMPTY
95522: LIST
95523: LIST
95524: PUSH
95525: LD_INT 33
95527: PUSH
95528: LD_INT 3
95530: PUSH
95531: EMPTY
95532: LIST
95533: LIST
95534: PUSH
95535: EMPTY
95536: LIST
95537: LIST
95538: PPUSH
95539: CALL_OW 69
95543: ST_TO_ADDR
// if not tmp then
95544: LD_VAR 0 2
95548: NOT
95549: IFFALSE 95553
// exit ;
95551: GO 95679
// side := 0 ;
95553: LD_ADDR_VAR 0 3
95557: PUSH
95558: LD_INT 0
95560: ST_TO_ADDR
// for i := 1 to 8 do
95561: LD_ADDR_VAR 0 1
95565: PUSH
95566: DOUBLE
95567: LD_INT 1
95569: DEC
95570: ST_TO_ADDR
95571: LD_INT 8
95573: PUSH
95574: FOR_TO
95575: IFFALSE 95623
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
95577: LD_OWVAR 2
95581: PUSH
95582: LD_VAR 0 1
95586: NONEQUAL
95587: PUSH
95588: LD_OWVAR 2
95592: PPUSH
95593: LD_VAR 0 1
95597: PPUSH
95598: CALL_OW 81
95602: PUSH
95603: LD_INT 2
95605: EQUAL
95606: AND
95607: IFFALSE 95621
// begin side := i ;
95609: LD_ADDR_VAR 0 3
95613: PUSH
95614: LD_VAR 0 1
95618: ST_TO_ADDR
// break ;
95619: GO 95623
// end ;
95621: GO 95574
95623: POP
95624: POP
// if not side then
95625: LD_VAR 0 3
95629: NOT
95630: IFFALSE 95634
// exit ;
95632: GO 95679
// for i := 1 to tmp do
95634: LD_ADDR_VAR 0 1
95638: PUSH
95639: DOUBLE
95640: LD_INT 1
95642: DEC
95643: ST_TO_ADDR
95644: LD_VAR 0 2
95648: PUSH
95649: FOR_TO
95650: IFFALSE 95677
// if Prob ( 60 ) then
95652: LD_INT 60
95654: PPUSH
95655: CALL_OW 13
95659: IFFALSE 95675
// SetSide ( i , side ) ;
95661: LD_VAR 0 1
95665: PPUSH
95666: LD_VAR 0 3
95670: PPUSH
95671: CALL_OW 235
95675: GO 95649
95677: POP
95678: POP
// end ;
95679: PPOPN 3
95681: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
95682: LD_EXP 113
95686: PUSH
95687: LD_EXP 126
95691: AND
95692: IFFALSE 95811
95694: GO 95696
95696: DISABLE
95697: LD_INT 0
95699: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
95700: LD_ADDR_VAR 0 1
95704: PUSH
95705: LD_INT 22
95707: PUSH
95708: LD_OWVAR 2
95712: PUSH
95713: EMPTY
95714: LIST
95715: LIST
95716: PUSH
95717: LD_INT 21
95719: PUSH
95720: LD_INT 1
95722: PUSH
95723: EMPTY
95724: LIST
95725: LIST
95726: PUSH
95727: LD_INT 3
95729: PUSH
95730: LD_INT 23
95732: PUSH
95733: LD_INT 0
95735: PUSH
95736: EMPTY
95737: LIST
95738: LIST
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: PUSH
95744: EMPTY
95745: LIST
95746: LIST
95747: LIST
95748: PPUSH
95749: CALL_OW 69
95753: PUSH
95754: FOR_IN
95755: IFFALSE 95809
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
95757: LD_VAR 0 1
95761: PPUSH
95762: CALL_OW 257
95766: PUSH
95767: LD_INT 1
95769: PUSH
95770: LD_INT 2
95772: PUSH
95773: LD_INT 3
95775: PUSH
95776: LD_INT 4
95778: PUSH
95779: EMPTY
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: IN
95785: IFFALSE 95807
// SetClass ( un , rand ( 1 , 4 ) ) ;
95787: LD_VAR 0 1
95791: PPUSH
95792: LD_INT 1
95794: PPUSH
95795: LD_INT 4
95797: PPUSH
95798: CALL_OW 12
95802: PPUSH
95803: CALL_OW 336
95807: GO 95754
95809: POP
95810: POP
// end ;
95811: PPOPN 1
95813: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
95814: LD_EXP 113
95818: PUSH
95819: LD_EXP 125
95823: AND
95824: IFFALSE 95903
95826: GO 95828
95828: DISABLE
95829: LD_INT 0
95831: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95832: LD_ADDR_VAR 0 1
95836: PUSH
95837: LD_INT 22
95839: PUSH
95840: LD_OWVAR 2
95844: PUSH
95845: EMPTY
95846: LIST
95847: LIST
95848: PUSH
95849: LD_INT 21
95851: PUSH
95852: LD_INT 3
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: EMPTY
95860: LIST
95861: LIST
95862: PPUSH
95863: CALL_OW 69
95867: ST_TO_ADDR
// if not tmp then
95868: LD_VAR 0 1
95872: NOT
95873: IFFALSE 95877
// exit ;
95875: GO 95903
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
95877: LD_VAR 0 1
95881: PUSH
95882: LD_INT 1
95884: PPUSH
95885: LD_VAR 0 1
95889: PPUSH
95890: CALL_OW 12
95894: ARRAY
95895: PPUSH
95896: LD_INT 100
95898: PPUSH
95899: CALL_OW 234
// end ;
95903: PPOPN 1
95905: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
95906: LD_EXP 113
95910: PUSH
95911: LD_EXP 127
95915: AND
95916: IFFALSE 96014
95918: GO 95920
95920: DISABLE
95921: LD_INT 0
95923: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95924: LD_ADDR_VAR 0 1
95928: PUSH
95929: LD_INT 22
95931: PUSH
95932: LD_OWVAR 2
95936: PUSH
95937: EMPTY
95938: LIST
95939: LIST
95940: PUSH
95941: LD_INT 21
95943: PUSH
95944: LD_INT 1
95946: PUSH
95947: EMPTY
95948: LIST
95949: LIST
95950: PUSH
95951: EMPTY
95952: LIST
95953: LIST
95954: PPUSH
95955: CALL_OW 69
95959: ST_TO_ADDR
// if not tmp then
95960: LD_VAR 0 1
95964: NOT
95965: IFFALSE 95969
// exit ;
95967: GO 96014
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
95969: LD_VAR 0 1
95973: PUSH
95974: LD_INT 1
95976: PPUSH
95977: LD_VAR 0 1
95981: PPUSH
95982: CALL_OW 12
95986: ARRAY
95987: PPUSH
95988: LD_INT 1
95990: PPUSH
95991: LD_INT 4
95993: PPUSH
95994: CALL_OW 12
95998: PPUSH
95999: LD_INT 3000
96001: PPUSH
96002: LD_INT 9000
96004: PPUSH
96005: CALL_OW 12
96009: PPUSH
96010: CALL_OW 492
// end ;
96014: PPOPN 1
96016: END
// every 0 0$1 trigger StreamModeActive and sDepot do
96017: LD_EXP 113
96021: PUSH
96022: LD_EXP 128
96026: AND
96027: IFFALSE 96047
96029: GO 96031
96031: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
96032: LD_INT 1
96034: PPUSH
96035: LD_OWVAR 2
96039: PPUSH
96040: LD_INT 0
96042: PPUSH
96043: CALL_OW 324
96047: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
96048: LD_EXP 113
96052: PUSH
96053: LD_EXP 129
96057: AND
96058: IFFALSE 96141
96060: GO 96062
96062: DISABLE
96063: LD_INT 0
96065: PPUSH
96066: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96067: LD_ADDR_VAR 0 2
96071: PUSH
96072: LD_INT 22
96074: PUSH
96075: LD_OWVAR 2
96079: PUSH
96080: EMPTY
96081: LIST
96082: LIST
96083: PUSH
96084: LD_INT 21
96086: PUSH
96087: LD_INT 3
96089: PUSH
96090: EMPTY
96091: LIST
96092: LIST
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: PPUSH
96098: CALL_OW 69
96102: ST_TO_ADDR
// if not tmp then
96103: LD_VAR 0 2
96107: NOT
96108: IFFALSE 96112
// exit ;
96110: GO 96141
// for i in tmp do
96112: LD_ADDR_VAR 0 1
96116: PUSH
96117: LD_VAR 0 2
96121: PUSH
96122: FOR_IN
96123: IFFALSE 96139
// SetBLevel ( i , 10 ) ;
96125: LD_VAR 0 1
96129: PPUSH
96130: LD_INT 10
96132: PPUSH
96133: CALL_OW 241
96137: GO 96122
96139: POP
96140: POP
// end ;
96141: PPOPN 2
96143: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
96144: LD_EXP 113
96148: PUSH
96149: LD_EXP 130
96153: AND
96154: IFFALSE 96265
96156: GO 96158
96158: DISABLE
96159: LD_INT 0
96161: PPUSH
96162: PPUSH
96163: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96164: LD_ADDR_VAR 0 3
96168: PUSH
96169: LD_INT 22
96171: PUSH
96172: LD_OWVAR 2
96176: PUSH
96177: EMPTY
96178: LIST
96179: LIST
96180: PUSH
96181: LD_INT 25
96183: PUSH
96184: LD_INT 1
96186: PUSH
96187: EMPTY
96188: LIST
96189: LIST
96190: PUSH
96191: EMPTY
96192: LIST
96193: LIST
96194: PPUSH
96195: CALL_OW 69
96199: ST_TO_ADDR
// if not tmp then
96200: LD_VAR 0 3
96204: NOT
96205: IFFALSE 96209
// exit ;
96207: GO 96265
// un := tmp [ rand ( 1 , tmp ) ] ;
96209: LD_ADDR_VAR 0 2
96213: PUSH
96214: LD_VAR 0 3
96218: PUSH
96219: LD_INT 1
96221: PPUSH
96222: LD_VAR 0 3
96226: PPUSH
96227: CALL_OW 12
96231: ARRAY
96232: ST_TO_ADDR
// if Crawls ( un ) then
96233: LD_VAR 0 2
96237: PPUSH
96238: CALL_OW 318
96242: IFFALSE 96253
// ComWalk ( un ) ;
96244: LD_VAR 0 2
96248: PPUSH
96249: CALL_OW 138
// SetClass ( un , class_sniper ) ;
96253: LD_VAR 0 2
96257: PPUSH
96258: LD_INT 5
96260: PPUSH
96261: CALL_OW 336
// end ;
96265: PPOPN 3
96267: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
96268: LD_EXP 113
96272: PUSH
96273: LD_EXP 131
96277: AND
96278: PUSH
96279: LD_OWVAR 67
96283: PUSH
96284: LD_INT 4
96286: LESS
96287: AND
96288: IFFALSE 96307
96290: GO 96292
96292: DISABLE
// begin Difficulty := Difficulty + 1 ;
96293: LD_ADDR_OWVAR 67
96297: PUSH
96298: LD_OWVAR 67
96302: PUSH
96303: LD_INT 1
96305: PLUS
96306: ST_TO_ADDR
// end ;
96307: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
96308: LD_EXP 113
96312: PUSH
96313: LD_EXP 132
96317: AND
96318: IFFALSE 96421
96320: GO 96322
96322: DISABLE
96323: LD_INT 0
96325: PPUSH
// begin for i := 1 to 5 do
96326: LD_ADDR_VAR 0 1
96330: PUSH
96331: DOUBLE
96332: LD_INT 1
96334: DEC
96335: ST_TO_ADDR
96336: LD_INT 5
96338: PUSH
96339: FOR_TO
96340: IFFALSE 96419
// begin uc_nation := nation_nature ;
96342: LD_ADDR_OWVAR 21
96346: PUSH
96347: LD_INT 0
96349: ST_TO_ADDR
// uc_side := 0 ;
96350: LD_ADDR_OWVAR 20
96354: PUSH
96355: LD_INT 0
96357: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96358: LD_ADDR_OWVAR 29
96362: PUSH
96363: LD_INT 12
96365: PUSH
96366: LD_INT 12
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: ST_TO_ADDR
// hc_agressivity := 20 ;
96373: LD_ADDR_OWVAR 35
96377: PUSH
96378: LD_INT 20
96380: ST_TO_ADDR
// hc_class := class_tiger ;
96381: LD_ADDR_OWVAR 28
96385: PUSH
96386: LD_INT 14
96388: ST_TO_ADDR
// hc_gallery :=  ;
96389: LD_ADDR_OWVAR 33
96393: PUSH
96394: LD_STRING 
96396: ST_TO_ADDR
// hc_name :=  ;
96397: LD_ADDR_OWVAR 26
96401: PUSH
96402: LD_STRING 
96404: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
96405: CALL_OW 44
96409: PPUSH
96410: LD_INT 0
96412: PPUSH
96413: CALL_OW 51
// end ;
96417: GO 96339
96419: POP
96420: POP
// end ;
96421: PPOPN 1
96423: END
// every 0 0$1 trigger StreamModeActive and sBomb do
96424: LD_EXP 113
96428: PUSH
96429: LD_EXP 133
96433: AND
96434: IFFALSE 96443
96436: GO 96438
96438: DISABLE
// StreamSibBomb ;
96439: CALL 96444 0 0
96443: END
// export function StreamSibBomb ; var i , x , y ; begin
96444: LD_INT 0
96446: PPUSH
96447: PPUSH
96448: PPUSH
96449: PPUSH
// result := false ;
96450: LD_ADDR_VAR 0 1
96454: PUSH
96455: LD_INT 0
96457: ST_TO_ADDR
// for i := 1 to 16 do
96458: LD_ADDR_VAR 0 2
96462: PUSH
96463: DOUBLE
96464: LD_INT 1
96466: DEC
96467: ST_TO_ADDR
96468: LD_INT 16
96470: PUSH
96471: FOR_TO
96472: IFFALSE 96671
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96474: LD_ADDR_VAR 0 3
96478: PUSH
96479: LD_INT 10
96481: PUSH
96482: LD_INT 20
96484: PUSH
96485: LD_INT 30
96487: PUSH
96488: LD_INT 40
96490: PUSH
96491: LD_INT 50
96493: PUSH
96494: LD_INT 60
96496: PUSH
96497: LD_INT 70
96499: PUSH
96500: LD_INT 80
96502: PUSH
96503: LD_INT 90
96505: PUSH
96506: LD_INT 100
96508: PUSH
96509: LD_INT 110
96511: PUSH
96512: LD_INT 120
96514: PUSH
96515: LD_INT 130
96517: PUSH
96518: LD_INT 140
96520: PUSH
96521: LD_INT 150
96523: PUSH
96524: EMPTY
96525: LIST
96526: LIST
96527: LIST
96528: LIST
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: PUSH
96541: LD_INT 1
96543: PPUSH
96544: LD_INT 15
96546: PPUSH
96547: CALL_OW 12
96551: ARRAY
96552: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96553: LD_ADDR_VAR 0 4
96557: PUSH
96558: LD_INT 10
96560: PUSH
96561: LD_INT 20
96563: PUSH
96564: LD_INT 30
96566: PUSH
96567: LD_INT 40
96569: PUSH
96570: LD_INT 50
96572: PUSH
96573: LD_INT 60
96575: PUSH
96576: LD_INT 70
96578: PUSH
96579: LD_INT 80
96581: PUSH
96582: LD_INT 90
96584: PUSH
96585: LD_INT 100
96587: PUSH
96588: LD_INT 110
96590: PUSH
96591: LD_INT 120
96593: PUSH
96594: LD_INT 130
96596: PUSH
96597: LD_INT 140
96599: PUSH
96600: LD_INT 150
96602: PUSH
96603: EMPTY
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: LIST
96618: LIST
96619: PUSH
96620: LD_INT 1
96622: PPUSH
96623: LD_INT 15
96625: PPUSH
96626: CALL_OW 12
96630: ARRAY
96631: ST_TO_ADDR
// if ValidHex ( x , y ) then
96632: LD_VAR 0 3
96636: PPUSH
96637: LD_VAR 0 4
96641: PPUSH
96642: CALL_OW 488
96646: IFFALSE 96669
// begin result := [ x , y ] ;
96648: LD_ADDR_VAR 0 1
96652: PUSH
96653: LD_VAR 0 3
96657: PUSH
96658: LD_VAR 0 4
96662: PUSH
96663: EMPTY
96664: LIST
96665: LIST
96666: ST_TO_ADDR
// break ;
96667: GO 96671
// end ; end ;
96669: GO 96471
96671: POP
96672: POP
// if result then
96673: LD_VAR 0 1
96677: IFFALSE 96737
// begin ToLua ( playSibBomb() ) ;
96679: LD_STRING playSibBomb()
96681: PPUSH
96682: CALL_OW 559
// wait ( 0 0$14 ) ;
96686: LD_INT 490
96688: PPUSH
96689: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
96693: LD_VAR 0 1
96697: PUSH
96698: LD_INT 1
96700: ARRAY
96701: PPUSH
96702: LD_VAR 0 1
96706: PUSH
96707: LD_INT 2
96709: ARRAY
96710: PPUSH
96711: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
96715: LD_VAR 0 1
96719: PUSH
96720: LD_INT 1
96722: ARRAY
96723: PPUSH
96724: LD_VAR 0 1
96728: PUSH
96729: LD_INT 2
96731: ARRAY
96732: PPUSH
96733: CALL_OW 429
// end ; end ;
96737: LD_VAR 0 1
96741: RET
// every 0 0$1 trigger StreamModeActive and sReset do
96742: LD_EXP 113
96746: PUSH
96747: LD_EXP 135
96751: AND
96752: IFFALSE 96764
96754: GO 96756
96756: DISABLE
// YouLost (  ) ;
96757: LD_STRING 
96759: PPUSH
96760: CALL_OW 104
96764: END
// every 0 0$1 trigger StreamModeActive and sFog do
96765: LD_EXP 113
96769: PUSH
96770: LD_EXP 134
96774: AND
96775: IFFALSE 96789
96777: GO 96779
96779: DISABLE
// FogOff ( your_side ) ;
96780: LD_OWVAR 2
96784: PPUSH
96785: CALL_OW 344
96789: END
// every 0 0$1 trigger StreamModeActive and sSun do
96790: LD_EXP 113
96794: PUSH
96795: LD_EXP 136
96799: AND
96800: IFFALSE 96828
96802: GO 96804
96804: DISABLE
// begin solar_recharge_percent := 0 ;
96805: LD_ADDR_OWVAR 79
96809: PUSH
96810: LD_INT 0
96812: ST_TO_ADDR
// wait ( 5 5$00 ) ;
96813: LD_INT 10500
96815: PPUSH
96816: CALL_OW 67
// solar_recharge_percent := 100 ;
96820: LD_ADDR_OWVAR 79
96824: PUSH
96825: LD_INT 100
96827: ST_TO_ADDR
// end ;
96828: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
96829: LD_EXP 113
96833: PUSH
96834: LD_EXP 137
96838: AND
96839: IFFALSE 97078
96841: GO 96843
96843: DISABLE
96844: LD_INT 0
96846: PPUSH
96847: PPUSH
96848: PPUSH
// begin tmp := [ ] ;
96849: LD_ADDR_VAR 0 3
96853: PUSH
96854: EMPTY
96855: ST_TO_ADDR
// for i := 1 to 6 do
96856: LD_ADDR_VAR 0 1
96860: PUSH
96861: DOUBLE
96862: LD_INT 1
96864: DEC
96865: ST_TO_ADDR
96866: LD_INT 6
96868: PUSH
96869: FOR_TO
96870: IFFALSE 96975
// begin uc_nation := nation_nature ;
96872: LD_ADDR_OWVAR 21
96876: PUSH
96877: LD_INT 0
96879: ST_TO_ADDR
// uc_side := 0 ;
96880: LD_ADDR_OWVAR 20
96884: PUSH
96885: LD_INT 0
96887: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96888: LD_ADDR_OWVAR 29
96892: PUSH
96893: LD_INT 12
96895: PUSH
96896: LD_INT 12
96898: PUSH
96899: EMPTY
96900: LIST
96901: LIST
96902: ST_TO_ADDR
// hc_agressivity := 20 ;
96903: LD_ADDR_OWVAR 35
96907: PUSH
96908: LD_INT 20
96910: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
96911: LD_ADDR_OWVAR 28
96915: PUSH
96916: LD_INT 17
96918: ST_TO_ADDR
// hc_gallery :=  ;
96919: LD_ADDR_OWVAR 33
96923: PUSH
96924: LD_STRING 
96926: ST_TO_ADDR
// hc_name :=  ;
96927: LD_ADDR_OWVAR 26
96931: PUSH
96932: LD_STRING 
96934: ST_TO_ADDR
// un := CreateHuman ;
96935: LD_ADDR_VAR 0 2
96939: PUSH
96940: CALL_OW 44
96944: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
96945: LD_VAR 0 2
96949: PPUSH
96950: LD_INT 1
96952: PPUSH
96953: CALL_OW 51
// tmp := tmp ^ un ;
96957: LD_ADDR_VAR 0 3
96961: PUSH
96962: LD_VAR 0 3
96966: PUSH
96967: LD_VAR 0 2
96971: ADD
96972: ST_TO_ADDR
// end ;
96973: GO 96869
96975: POP
96976: POP
// repeat wait ( 0 0$1 ) ;
96977: LD_INT 35
96979: PPUSH
96980: CALL_OW 67
// for un in tmp do
96984: LD_ADDR_VAR 0 2
96988: PUSH
96989: LD_VAR 0 3
96993: PUSH
96994: FOR_IN
96995: IFFALSE 97069
// begin if IsDead ( un ) then
96997: LD_VAR 0 2
97001: PPUSH
97002: CALL_OW 301
97006: IFFALSE 97026
// begin tmp := tmp diff un ;
97008: LD_ADDR_VAR 0 3
97012: PUSH
97013: LD_VAR 0 3
97017: PUSH
97018: LD_VAR 0 2
97022: DIFF
97023: ST_TO_ADDR
// continue ;
97024: GO 96994
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
97026: LD_VAR 0 2
97030: PPUSH
97031: LD_INT 3
97033: PUSH
97034: LD_INT 22
97036: PUSH
97037: LD_INT 0
97039: PUSH
97040: EMPTY
97041: LIST
97042: LIST
97043: PUSH
97044: EMPTY
97045: LIST
97046: LIST
97047: PPUSH
97048: CALL_OW 69
97052: PPUSH
97053: LD_VAR 0 2
97057: PPUSH
97058: CALL_OW 74
97062: PPUSH
97063: CALL_OW 115
// end ;
97067: GO 96994
97069: POP
97070: POP
// until not tmp ;
97071: LD_VAR 0 3
97075: NOT
97076: IFFALSE 96977
// end ;
97078: PPOPN 3
97080: END
// every 0 0$1 trigger StreamModeActive and sTroll do
97081: LD_EXP 113
97085: PUSH
97086: LD_EXP 138
97090: AND
97091: IFFALSE 97145
97093: GO 97095
97095: DISABLE
// begin ToLua ( displayTroll(); ) ;
97096: LD_STRING displayTroll();
97098: PPUSH
97099: CALL_OW 559
// wait ( 3 3$00 ) ;
97103: LD_INT 6300
97105: PPUSH
97106: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97110: LD_STRING hideTroll();
97112: PPUSH
97113: CALL_OW 559
// wait ( 1 1$00 ) ;
97117: LD_INT 2100
97119: PPUSH
97120: CALL_OW 67
// ToLua ( displayTroll(); ) ;
97124: LD_STRING displayTroll();
97126: PPUSH
97127: CALL_OW 559
// wait ( 1 1$00 ) ;
97131: LD_INT 2100
97133: PPUSH
97134: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97138: LD_STRING hideTroll();
97140: PPUSH
97141: CALL_OW 559
// end ;
97145: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
97146: LD_EXP 113
97150: PUSH
97151: LD_EXP 139
97155: AND
97156: IFFALSE 97219
97158: GO 97160
97160: DISABLE
97161: LD_INT 0
97163: PPUSH
// begin p := 0 ;
97164: LD_ADDR_VAR 0 1
97168: PUSH
97169: LD_INT 0
97171: ST_TO_ADDR
// repeat game_speed := 1 ;
97172: LD_ADDR_OWVAR 65
97176: PUSH
97177: LD_INT 1
97179: ST_TO_ADDR
// wait ( 0 0$1 ) ;
97180: LD_INT 35
97182: PPUSH
97183: CALL_OW 67
// p := p + 1 ;
97187: LD_ADDR_VAR 0 1
97191: PUSH
97192: LD_VAR 0 1
97196: PUSH
97197: LD_INT 1
97199: PLUS
97200: ST_TO_ADDR
// until p >= 60 ;
97201: LD_VAR 0 1
97205: PUSH
97206: LD_INT 60
97208: GREATEREQUAL
97209: IFFALSE 97172
// game_speed := 4 ;
97211: LD_ADDR_OWVAR 65
97215: PUSH
97216: LD_INT 4
97218: ST_TO_ADDR
// end ;
97219: PPOPN 1
97221: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
97222: LD_EXP 113
97226: PUSH
97227: LD_EXP 140
97231: AND
97232: IFFALSE 97378
97234: GO 97236
97236: DISABLE
97237: LD_INT 0
97239: PPUSH
97240: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97241: LD_ADDR_VAR 0 1
97245: PUSH
97246: LD_INT 22
97248: PUSH
97249: LD_OWVAR 2
97253: PUSH
97254: EMPTY
97255: LIST
97256: LIST
97257: PUSH
97258: LD_INT 2
97260: PUSH
97261: LD_INT 30
97263: PUSH
97264: LD_INT 0
97266: PUSH
97267: EMPTY
97268: LIST
97269: LIST
97270: PUSH
97271: LD_INT 30
97273: PUSH
97274: LD_INT 1
97276: PUSH
97277: EMPTY
97278: LIST
97279: LIST
97280: PUSH
97281: EMPTY
97282: LIST
97283: LIST
97284: LIST
97285: PUSH
97286: EMPTY
97287: LIST
97288: LIST
97289: PPUSH
97290: CALL_OW 69
97294: ST_TO_ADDR
// if not depot then
97295: LD_VAR 0 1
97299: NOT
97300: IFFALSE 97304
// exit ;
97302: GO 97378
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
97304: LD_ADDR_VAR 0 2
97308: PUSH
97309: LD_VAR 0 1
97313: PUSH
97314: LD_INT 1
97316: PPUSH
97317: LD_VAR 0 1
97321: PPUSH
97322: CALL_OW 12
97326: ARRAY
97327: PPUSH
97328: CALL_OW 274
97332: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
97333: LD_VAR 0 2
97337: PPUSH
97338: LD_INT 1
97340: PPUSH
97341: LD_INT 0
97343: PPUSH
97344: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
97348: LD_VAR 0 2
97352: PPUSH
97353: LD_INT 2
97355: PPUSH
97356: LD_INT 0
97358: PPUSH
97359: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
97363: LD_VAR 0 2
97367: PPUSH
97368: LD_INT 3
97370: PPUSH
97371: LD_INT 0
97373: PPUSH
97374: CALL_OW 277
// end ;
97378: PPOPN 2
97380: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
97381: LD_EXP 113
97385: PUSH
97386: LD_EXP 141
97390: AND
97391: IFFALSE 97488
97393: GO 97395
97395: DISABLE
97396: LD_INT 0
97398: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97399: LD_ADDR_VAR 0 1
97403: PUSH
97404: LD_INT 22
97406: PUSH
97407: LD_OWVAR 2
97411: PUSH
97412: EMPTY
97413: LIST
97414: LIST
97415: PUSH
97416: LD_INT 21
97418: PUSH
97419: LD_INT 1
97421: PUSH
97422: EMPTY
97423: LIST
97424: LIST
97425: PUSH
97426: LD_INT 3
97428: PUSH
97429: LD_INT 23
97431: PUSH
97432: LD_INT 0
97434: PUSH
97435: EMPTY
97436: LIST
97437: LIST
97438: PUSH
97439: EMPTY
97440: LIST
97441: LIST
97442: PUSH
97443: EMPTY
97444: LIST
97445: LIST
97446: LIST
97447: PPUSH
97448: CALL_OW 69
97452: ST_TO_ADDR
// if not tmp then
97453: LD_VAR 0 1
97457: NOT
97458: IFFALSE 97462
// exit ;
97460: GO 97488
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
97462: LD_VAR 0 1
97466: PUSH
97467: LD_INT 1
97469: PPUSH
97470: LD_VAR 0 1
97474: PPUSH
97475: CALL_OW 12
97479: ARRAY
97480: PPUSH
97481: LD_INT 200
97483: PPUSH
97484: CALL_OW 234
// end ;
97488: PPOPN 1
97490: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
97491: LD_EXP 113
97495: PUSH
97496: LD_EXP 142
97500: AND
97501: IFFALSE 97580
97503: GO 97505
97505: DISABLE
97506: LD_INT 0
97508: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
97509: LD_ADDR_VAR 0 1
97513: PUSH
97514: LD_INT 22
97516: PUSH
97517: LD_OWVAR 2
97521: PUSH
97522: EMPTY
97523: LIST
97524: LIST
97525: PUSH
97526: LD_INT 21
97528: PUSH
97529: LD_INT 2
97531: PUSH
97532: EMPTY
97533: LIST
97534: LIST
97535: PUSH
97536: EMPTY
97537: LIST
97538: LIST
97539: PPUSH
97540: CALL_OW 69
97544: ST_TO_ADDR
// if not tmp then
97545: LD_VAR 0 1
97549: NOT
97550: IFFALSE 97554
// exit ;
97552: GO 97580
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
97554: LD_VAR 0 1
97558: PUSH
97559: LD_INT 1
97561: PPUSH
97562: LD_VAR 0 1
97566: PPUSH
97567: CALL_OW 12
97571: ARRAY
97572: PPUSH
97573: LD_INT 60
97575: PPUSH
97576: CALL_OW 234
// end ;
97580: PPOPN 1
97582: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
97583: LD_EXP 113
97587: PUSH
97588: LD_EXP 143
97592: AND
97593: IFFALSE 97692
97595: GO 97597
97597: DISABLE
97598: LD_INT 0
97600: PPUSH
97601: PPUSH
// begin enable ;
97602: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
97603: LD_ADDR_VAR 0 1
97607: PUSH
97608: LD_INT 22
97610: PUSH
97611: LD_OWVAR 2
97615: PUSH
97616: EMPTY
97617: LIST
97618: LIST
97619: PUSH
97620: LD_INT 61
97622: PUSH
97623: EMPTY
97624: LIST
97625: PUSH
97626: LD_INT 33
97628: PUSH
97629: LD_INT 2
97631: PUSH
97632: EMPTY
97633: LIST
97634: LIST
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: LIST
97640: PPUSH
97641: CALL_OW 69
97645: ST_TO_ADDR
// if not tmp then
97646: LD_VAR 0 1
97650: NOT
97651: IFFALSE 97655
// exit ;
97653: GO 97692
// for i in tmp do
97655: LD_ADDR_VAR 0 2
97659: PUSH
97660: LD_VAR 0 1
97664: PUSH
97665: FOR_IN
97666: IFFALSE 97690
// if IsControledBy ( i ) then
97668: LD_VAR 0 2
97672: PPUSH
97673: CALL_OW 312
97677: IFFALSE 97688
// ComUnlink ( i ) ;
97679: LD_VAR 0 2
97683: PPUSH
97684: CALL_OW 136
97688: GO 97665
97690: POP
97691: POP
// end ;
97692: PPOPN 2
97694: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
97695: LD_EXP 113
97699: PUSH
97700: LD_EXP 144
97704: AND
97705: IFFALSE 97845
97707: GO 97709
97709: DISABLE
97710: LD_INT 0
97712: PPUSH
97713: PPUSH
// begin ToLua ( displayPowell(); ) ;
97714: LD_STRING displayPowell();
97716: PPUSH
97717: CALL_OW 559
// uc_side := 0 ;
97721: LD_ADDR_OWVAR 20
97725: PUSH
97726: LD_INT 0
97728: ST_TO_ADDR
// uc_nation := 2 ;
97729: LD_ADDR_OWVAR 21
97733: PUSH
97734: LD_INT 2
97736: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
97737: LD_ADDR_OWVAR 37
97741: PUSH
97742: LD_INT 14
97744: ST_TO_ADDR
// vc_engine := engine_siberite ;
97745: LD_ADDR_OWVAR 39
97749: PUSH
97750: LD_INT 3
97752: ST_TO_ADDR
// vc_control := control_apeman ;
97753: LD_ADDR_OWVAR 38
97757: PUSH
97758: LD_INT 5
97760: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
97761: LD_ADDR_OWVAR 40
97765: PUSH
97766: LD_INT 29
97768: ST_TO_ADDR
// un := CreateVehicle ;
97769: LD_ADDR_VAR 0 2
97773: PUSH
97774: CALL_OW 45
97778: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97779: LD_VAR 0 2
97783: PPUSH
97784: LD_INT 1
97786: PPUSH
97787: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97791: LD_INT 35
97793: PPUSH
97794: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97798: LD_VAR 0 2
97802: PPUSH
97803: LD_INT 22
97805: PUSH
97806: LD_OWVAR 2
97810: PUSH
97811: EMPTY
97812: LIST
97813: LIST
97814: PPUSH
97815: CALL_OW 69
97819: PPUSH
97820: LD_VAR 0 2
97824: PPUSH
97825: CALL_OW 74
97829: PPUSH
97830: CALL_OW 115
// until IsDead ( un ) ;
97834: LD_VAR 0 2
97838: PPUSH
97839: CALL_OW 301
97843: IFFALSE 97791
// end ;
97845: PPOPN 2
97847: END
// every 0 0$1 trigger StreamModeActive and sStu do
97848: LD_EXP 113
97852: PUSH
97853: LD_EXP 152
97857: AND
97858: IFFALSE 97874
97860: GO 97862
97862: DISABLE
// begin ToLua ( displayStucuk(); ) ;
97863: LD_STRING displayStucuk();
97865: PPUSH
97866: CALL_OW 559
// ResetFog ;
97870: CALL_OW 335
// end ;
97874: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
97875: LD_EXP 113
97879: PUSH
97880: LD_EXP 145
97884: AND
97885: IFFALSE 98026
97887: GO 97889
97889: DISABLE
97890: LD_INT 0
97892: PPUSH
97893: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97894: LD_ADDR_VAR 0 2
97898: PUSH
97899: LD_INT 22
97901: PUSH
97902: LD_OWVAR 2
97906: PUSH
97907: EMPTY
97908: LIST
97909: LIST
97910: PUSH
97911: LD_INT 21
97913: PUSH
97914: LD_INT 1
97916: PUSH
97917: EMPTY
97918: LIST
97919: LIST
97920: PUSH
97921: EMPTY
97922: LIST
97923: LIST
97924: PPUSH
97925: CALL_OW 69
97929: ST_TO_ADDR
// if not tmp then
97930: LD_VAR 0 2
97934: NOT
97935: IFFALSE 97939
// exit ;
97937: GO 98026
// un := tmp [ rand ( 1 , tmp ) ] ;
97939: LD_ADDR_VAR 0 1
97943: PUSH
97944: LD_VAR 0 2
97948: PUSH
97949: LD_INT 1
97951: PPUSH
97952: LD_VAR 0 2
97956: PPUSH
97957: CALL_OW 12
97961: ARRAY
97962: ST_TO_ADDR
// SetSide ( un , 0 ) ;
97963: LD_VAR 0 1
97967: PPUSH
97968: LD_INT 0
97970: PPUSH
97971: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
97975: LD_VAR 0 1
97979: PPUSH
97980: LD_OWVAR 3
97984: PUSH
97985: LD_VAR 0 1
97989: DIFF
97990: PPUSH
97991: LD_VAR 0 1
97995: PPUSH
97996: CALL_OW 74
98000: PPUSH
98001: CALL_OW 115
// wait ( 0 0$20 ) ;
98005: LD_INT 700
98007: PPUSH
98008: CALL_OW 67
// SetSide ( un , your_side ) ;
98012: LD_VAR 0 1
98016: PPUSH
98017: LD_OWVAR 2
98021: PPUSH
98022: CALL_OW 235
// end ;
98026: PPOPN 2
98028: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
98029: LD_EXP 113
98033: PUSH
98034: LD_EXP 146
98038: AND
98039: IFFALSE 98145
98041: GO 98043
98043: DISABLE
98044: LD_INT 0
98046: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98047: LD_ADDR_VAR 0 1
98051: PUSH
98052: LD_INT 22
98054: PUSH
98055: LD_OWVAR 2
98059: PUSH
98060: EMPTY
98061: LIST
98062: LIST
98063: PUSH
98064: LD_INT 2
98066: PUSH
98067: LD_INT 30
98069: PUSH
98070: LD_INT 0
98072: PUSH
98073: EMPTY
98074: LIST
98075: LIST
98076: PUSH
98077: LD_INT 30
98079: PUSH
98080: LD_INT 1
98082: PUSH
98083: EMPTY
98084: LIST
98085: LIST
98086: PUSH
98087: EMPTY
98088: LIST
98089: LIST
98090: LIST
98091: PUSH
98092: EMPTY
98093: LIST
98094: LIST
98095: PPUSH
98096: CALL_OW 69
98100: ST_TO_ADDR
// if not depot then
98101: LD_VAR 0 1
98105: NOT
98106: IFFALSE 98110
// exit ;
98108: GO 98145
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
98110: LD_VAR 0 1
98114: PUSH
98115: LD_INT 1
98117: ARRAY
98118: PPUSH
98119: CALL_OW 250
98123: PPUSH
98124: LD_VAR 0 1
98128: PUSH
98129: LD_INT 1
98131: ARRAY
98132: PPUSH
98133: CALL_OW 251
98137: PPUSH
98138: LD_INT 70
98140: PPUSH
98141: CALL_OW 495
// end ;
98145: PPOPN 1
98147: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
98148: LD_EXP 113
98152: PUSH
98153: LD_EXP 147
98157: AND
98158: IFFALSE 98369
98160: GO 98162
98162: DISABLE
98163: LD_INT 0
98165: PPUSH
98166: PPUSH
98167: PPUSH
98168: PPUSH
98169: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98170: LD_ADDR_VAR 0 5
98174: PUSH
98175: LD_INT 22
98177: PUSH
98178: LD_OWVAR 2
98182: PUSH
98183: EMPTY
98184: LIST
98185: LIST
98186: PUSH
98187: LD_INT 21
98189: PUSH
98190: LD_INT 1
98192: PUSH
98193: EMPTY
98194: LIST
98195: LIST
98196: PUSH
98197: EMPTY
98198: LIST
98199: LIST
98200: PPUSH
98201: CALL_OW 69
98205: ST_TO_ADDR
// if not tmp then
98206: LD_VAR 0 5
98210: NOT
98211: IFFALSE 98215
// exit ;
98213: GO 98369
// for i in tmp do
98215: LD_ADDR_VAR 0 1
98219: PUSH
98220: LD_VAR 0 5
98224: PUSH
98225: FOR_IN
98226: IFFALSE 98367
// begin d := rand ( 0 , 5 ) ;
98228: LD_ADDR_VAR 0 4
98232: PUSH
98233: LD_INT 0
98235: PPUSH
98236: LD_INT 5
98238: PPUSH
98239: CALL_OW 12
98243: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
98244: LD_ADDR_VAR 0 2
98248: PUSH
98249: LD_VAR 0 1
98253: PPUSH
98254: CALL_OW 250
98258: PPUSH
98259: LD_VAR 0 4
98263: PPUSH
98264: LD_INT 3
98266: PPUSH
98267: LD_INT 12
98269: PPUSH
98270: CALL_OW 12
98274: PPUSH
98275: CALL_OW 272
98279: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
98280: LD_ADDR_VAR 0 3
98284: PUSH
98285: LD_VAR 0 1
98289: PPUSH
98290: CALL_OW 251
98294: PPUSH
98295: LD_VAR 0 4
98299: PPUSH
98300: LD_INT 3
98302: PPUSH
98303: LD_INT 12
98305: PPUSH
98306: CALL_OW 12
98310: PPUSH
98311: CALL_OW 273
98315: ST_TO_ADDR
// if ValidHex ( x , y ) then
98316: LD_VAR 0 2
98320: PPUSH
98321: LD_VAR 0 3
98325: PPUSH
98326: CALL_OW 488
98330: IFFALSE 98365
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
98332: LD_VAR 0 1
98336: PPUSH
98337: LD_VAR 0 2
98341: PPUSH
98342: LD_VAR 0 3
98346: PPUSH
98347: LD_INT 3
98349: PPUSH
98350: LD_INT 6
98352: PPUSH
98353: CALL_OW 12
98357: PPUSH
98358: LD_INT 1
98360: PPUSH
98361: CALL_OW 483
// end ;
98365: GO 98225
98367: POP
98368: POP
// end ;
98369: PPOPN 5
98371: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
98372: LD_EXP 113
98376: PUSH
98377: LD_EXP 148
98381: AND
98382: IFFALSE 98476
98384: GO 98386
98386: DISABLE
98387: LD_INT 0
98389: PPUSH
98390: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
98391: LD_ADDR_VAR 0 2
98395: PUSH
98396: LD_INT 22
98398: PUSH
98399: LD_OWVAR 2
98403: PUSH
98404: EMPTY
98405: LIST
98406: LIST
98407: PUSH
98408: LD_INT 32
98410: PUSH
98411: LD_INT 1
98413: PUSH
98414: EMPTY
98415: LIST
98416: LIST
98417: PUSH
98418: LD_INT 21
98420: PUSH
98421: LD_INT 2
98423: PUSH
98424: EMPTY
98425: LIST
98426: LIST
98427: PUSH
98428: EMPTY
98429: LIST
98430: LIST
98431: LIST
98432: PPUSH
98433: CALL_OW 69
98437: ST_TO_ADDR
// if not tmp then
98438: LD_VAR 0 2
98442: NOT
98443: IFFALSE 98447
// exit ;
98445: GO 98476
// for i in tmp do
98447: LD_ADDR_VAR 0 1
98451: PUSH
98452: LD_VAR 0 2
98456: PUSH
98457: FOR_IN
98458: IFFALSE 98474
// SetFuel ( i , 0 ) ;
98460: LD_VAR 0 1
98464: PPUSH
98465: LD_INT 0
98467: PPUSH
98468: CALL_OW 240
98472: GO 98457
98474: POP
98475: POP
// end ;
98476: PPOPN 2
98478: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
98479: LD_EXP 113
98483: PUSH
98484: LD_EXP 149
98488: AND
98489: IFFALSE 98555
98491: GO 98493
98493: DISABLE
98494: LD_INT 0
98496: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98497: LD_ADDR_VAR 0 1
98501: PUSH
98502: LD_INT 22
98504: PUSH
98505: LD_OWVAR 2
98509: PUSH
98510: EMPTY
98511: LIST
98512: LIST
98513: PUSH
98514: LD_INT 30
98516: PUSH
98517: LD_INT 29
98519: PUSH
98520: EMPTY
98521: LIST
98522: LIST
98523: PUSH
98524: EMPTY
98525: LIST
98526: LIST
98527: PPUSH
98528: CALL_OW 69
98532: ST_TO_ADDR
// if not tmp then
98533: LD_VAR 0 1
98537: NOT
98538: IFFALSE 98542
// exit ;
98540: GO 98555
// DestroyUnit ( tmp [ 1 ] ) ;
98542: LD_VAR 0 1
98546: PUSH
98547: LD_INT 1
98549: ARRAY
98550: PPUSH
98551: CALL_OW 65
// end ;
98555: PPOPN 1
98557: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
98558: LD_EXP 113
98562: PUSH
98563: LD_EXP 151
98567: AND
98568: IFFALSE 98697
98570: GO 98572
98572: DISABLE
98573: LD_INT 0
98575: PPUSH
// begin uc_side := 0 ;
98576: LD_ADDR_OWVAR 20
98580: PUSH
98581: LD_INT 0
98583: ST_TO_ADDR
// uc_nation := nation_arabian ;
98584: LD_ADDR_OWVAR 21
98588: PUSH
98589: LD_INT 2
98591: ST_TO_ADDR
// hc_gallery :=  ;
98592: LD_ADDR_OWVAR 33
98596: PUSH
98597: LD_STRING 
98599: ST_TO_ADDR
// hc_name :=  ;
98600: LD_ADDR_OWVAR 26
98604: PUSH
98605: LD_STRING 
98607: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
98608: LD_INT 1
98610: PPUSH
98611: LD_INT 11
98613: PPUSH
98614: LD_INT 10
98616: PPUSH
98617: CALL_OW 380
// un := CreateHuman ;
98621: LD_ADDR_VAR 0 1
98625: PUSH
98626: CALL_OW 44
98630: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98631: LD_VAR 0 1
98635: PPUSH
98636: LD_INT 1
98638: PPUSH
98639: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98643: LD_INT 35
98645: PPUSH
98646: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98650: LD_VAR 0 1
98654: PPUSH
98655: LD_INT 22
98657: PUSH
98658: LD_OWVAR 2
98662: PUSH
98663: EMPTY
98664: LIST
98665: LIST
98666: PPUSH
98667: CALL_OW 69
98671: PPUSH
98672: LD_VAR 0 1
98676: PPUSH
98677: CALL_OW 74
98681: PPUSH
98682: CALL_OW 115
// until IsDead ( un ) ;
98686: LD_VAR 0 1
98690: PPUSH
98691: CALL_OW 301
98695: IFFALSE 98643
// end ;
98697: PPOPN 1
98699: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
98700: LD_EXP 113
98704: PUSH
98705: LD_EXP 153
98709: AND
98710: IFFALSE 98722
98712: GO 98714
98714: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
98715: LD_STRING earthquake(getX(game), 0, 32)
98717: PPUSH
98718: CALL_OW 559
98722: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
98723: LD_EXP 113
98727: PUSH
98728: LD_EXP 154
98732: AND
98733: IFFALSE 98824
98735: GO 98737
98737: DISABLE
98738: LD_INT 0
98740: PPUSH
// begin enable ;
98741: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
98742: LD_ADDR_VAR 0 1
98746: PUSH
98747: LD_INT 22
98749: PUSH
98750: LD_OWVAR 2
98754: PUSH
98755: EMPTY
98756: LIST
98757: LIST
98758: PUSH
98759: LD_INT 21
98761: PUSH
98762: LD_INT 2
98764: PUSH
98765: EMPTY
98766: LIST
98767: LIST
98768: PUSH
98769: LD_INT 33
98771: PUSH
98772: LD_INT 3
98774: PUSH
98775: EMPTY
98776: LIST
98777: LIST
98778: PUSH
98779: EMPTY
98780: LIST
98781: LIST
98782: LIST
98783: PPUSH
98784: CALL_OW 69
98788: ST_TO_ADDR
// if not tmp then
98789: LD_VAR 0 1
98793: NOT
98794: IFFALSE 98798
// exit ;
98796: GO 98824
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98798: LD_VAR 0 1
98802: PUSH
98803: LD_INT 1
98805: PPUSH
98806: LD_VAR 0 1
98810: PPUSH
98811: CALL_OW 12
98815: ARRAY
98816: PPUSH
98817: LD_INT 1
98819: PPUSH
98820: CALL_OW 234
// end ;
98824: PPOPN 1
98826: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
98827: LD_EXP 113
98831: PUSH
98832: LD_EXP 155
98836: AND
98837: IFFALSE 98978
98839: GO 98841
98841: DISABLE
98842: LD_INT 0
98844: PPUSH
98845: PPUSH
98846: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98847: LD_ADDR_VAR 0 3
98851: PUSH
98852: LD_INT 22
98854: PUSH
98855: LD_OWVAR 2
98859: PUSH
98860: EMPTY
98861: LIST
98862: LIST
98863: PUSH
98864: LD_INT 25
98866: PUSH
98867: LD_INT 1
98869: PUSH
98870: EMPTY
98871: LIST
98872: LIST
98873: PUSH
98874: EMPTY
98875: LIST
98876: LIST
98877: PPUSH
98878: CALL_OW 69
98882: ST_TO_ADDR
// if not tmp then
98883: LD_VAR 0 3
98887: NOT
98888: IFFALSE 98892
// exit ;
98890: GO 98978
// un := tmp [ rand ( 1 , tmp ) ] ;
98892: LD_ADDR_VAR 0 2
98896: PUSH
98897: LD_VAR 0 3
98901: PUSH
98902: LD_INT 1
98904: PPUSH
98905: LD_VAR 0 3
98909: PPUSH
98910: CALL_OW 12
98914: ARRAY
98915: ST_TO_ADDR
// if Crawls ( un ) then
98916: LD_VAR 0 2
98920: PPUSH
98921: CALL_OW 318
98925: IFFALSE 98936
// ComWalk ( un ) ;
98927: LD_VAR 0 2
98931: PPUSH
98932: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
98936: LD_VAR 0 2
98940: PPUSH
98941: LD_INT 9
98943: PPUSH
98944: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
98948: LD_INT 28
98950: PPUSH
98951: LD_OWVAR 2
98955: PPUSH
98956: LD_INT 2
98958: PPUSH
98959: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
98963: LD_INT 29
98965: PPUSH
98966: LD_OWVAR 2
98970: PPUSH
98971: LD_INT 2
98973: PPUSH
98974: CALL_OW 322
// end ;
98978: PPOPN 3
98980: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
98981: LD_EXP 113
98985: PUSH
98986: LD_EXP 156
98990: AND
98991: IFFALSE 99102
98993: GO 98995
98995: DISABLE
98996: LD_INT 0
98998: PPUSH
98999: PPUSH
99000: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99001: LD_ADDR_VAR 0 3
99005: PUSH
99006: LD_INT 22
99008: PUSH
99009: LD_OWVAR 2
99013: PUSH
99014: EMPTY
99015: LIST
99016: LIST
99017: PUSH
99018: LD_INT 25
99020: PUSH
99021: LD_INT 1
99023: PUSH
99024: EMPTY
99025: LIST
99026: LIST
99027: PUSH
99028: EMPTY
99029: LIST
99030: LIST
99031: PPUSH
99032: CALL_OW 69
99036: ST_TO_ADDR
// if not tmp then
99037: LD_VAR 0 3
99041: NOT
99042: IFFALSE 99046
// exit ;
99044: GO 99102
// un := tmp [ rand ( 1 , tmp ) ] ;
99046: LD_ADDR_VAR 0 2
99050: PUSH
99051: LD_VAR 0 3
99055: PUSH
99056: LD_INT 1
99058: PPUSH
99059: LD_VAR 0 3
99063: PPUSH
99064: CALL_OW 12
99068: ARRAY
99069: ST_TO_ADDR
// if Crawls ( un ) then
99070: LD_VAR 0 2
99074: PPUSH
99075: CALL_OW 318
99079: IFFALSE 99090
// ComWalk ( un ) ;
99081: LD_VAR 0 2
99085: PPUSH
99086: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99090: LD_VAR 0 2
99094: PPUSH
99095: LD_INT 8
99097: PPUSH
99098: CALL_OW 336
// end ;
99102: PPOPN 3
99104: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
99105: LD_EXP 113
99109: PUSH
99110: LD_EXP 157
99114: AND
99115: IFFALSE 99259
99117: GO 99119
99119: DISABLE
99120: LD_INT 0
99122: PPUSH
99123: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
99124: LD_ADDR_VAR 0 2
99128: PUSH
99129: LD_INT 22
99131: PUSH
99132: LD_OWVAR 2
99136: PUSH
99137: EMPTY
99138: LIST
99139: LIST
99140: PUSH
99141: LD_INT 21
99143: PUSH
99144: LD_INT 2
99146: PUSH
99147: EMPTY
99148: LIST
99149: LIST
99150: PUSH
99151: LD_INT 2
99153: PUSH
99154: LD_INT 34
99156: PUSH
99157: LD_INT 12
99159: PUSH
99160: EMPTY
99161: LIST
99162: LIST
99163: PUSH
99164: LD_INT 34
99166: PUSH
99167: LD_INT 51
99169: PUSH
99170: EMPTY
99171: LIST
99172: LIST
99173: PUSH
99174: LD_INT 34
99176: PUSH
99177: LD_INT 32
99179: PUSH
99180: EMPTY
99181: LIST
99182: LIST
99183: PUSH
99184: EMPTY
99185: LIST
99186: LIST
99187: LIST
99188: LIST
99189: PUSH
99190: EMPTY
99191: LIST
99192: LIST
99193: LIST
99194: PPUSH
99195: CALL_OW 69
99199: ST_TO_ADDR
// if not tmp then
99200: LD_VAR 0 2
99204: NOT
99205: IFFALSE 99209
// exit ;
99207: GO 99259
// for i in tmp do
99209: LD_ADDR_VAR 0 1
99213: PUSH
99214: LD_VAR 0 2
99218: PUSH
99219: FOR_IN
99220: IFFALSE 99257
// if GetCargo ( i , mat_artifact ) = 0 then
99222: LD_VAR 0 1
99226: PPUSH
99227: LD_INT 4
99229: PPUSH
99230: CALL_OW 289
99234: PUSH
99235: LD_INT 0
99237: EQUAL
99238: IFFALSE 99255
// SetCargo ( i , mat_siberit , 100 ) ;
99240: LD_VAR 0 1
99244: PPUSH
99245: LD_INT 3
99247: PPUSH
99248: LD_INT 100
99250: PPUSH
99251: CALL_OW 290
99255: GO 99219
99257: POP
99258: POP
// end ;
99259: PPOPN 2
99261: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
99262: LD_EXP 113
99266: PUSH
99267: LD_EXP 158
99271: AND
99272: IFFALSE 99455
99274: GO 99276
99276: DISABLE
99277: LD_INT 0
99279: PPUSH
99280: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99281: LD_ADDR_VAR 0 2
99285: PUSH
99286: LD_INT 22
99288: PUSH
99289: LD_OWVAR 2
99293: PUSH
99294: EMPTY
99295: LIST
99296: LIST
99297: PPUSH
99298: CALL_OW 69
99302: ST_TO_ADDR
// if not tmp then
99303: LD_VAR 0 2
99307: NOT
99308: IFFALSE 99312
// exit ;
99310: GO 99455
// for i := 1 to 2 do
99312: LD_ADDR_VAR 0 1
99316: PUSH
99317: DOUBLE
99318: LD_INT 1
99320: DEC
99321: ST_TO_ADDR
99322: LD_INT 2
99324: PUSH
99325: FOR_TO
99326: IFFALSE 99453
// begin uc_side := your_side ;
99328: LD_ADDR_OWVAR 20
99332: PUSH
99333: LD_OWVAR 2
99337: ST_TO_ADDR
// uc_nation := nation_american ;
99338: LD_ADDR_OWVAR 21
99342: PUSH
99343: LD_INT 1
99345: ST_TO_ADDR
// vc_chassis := us_morphling ;
99346: LD_ADDR_OWVAR 37
99350: PUSH
99351: LD_INT 5
99353: ST_TO_ADDR
// vc_engine := engine_siberite ;
99354: LD_ADDR_OWVAR 39
99358: PUSH
99359: LD_INT 3
99361: ST_TO_ADDR
// vc_control := control_computer ;
99362: LD_ADDR_OWVAR 38
99366: PUSH
99367: LD_INT 3
99369: ST_TO_ADDR
// vc_weapon := us_double_laser ;
99370: LD_ADDR_OWVAR 40
99374: PUSH
99375: LD_INT 10
99377: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
99378: LD_VAR 0 2
99382: PUSH
99383: LD_INT 1
99385: ARRAY
99386: PPUSH
99387: CALL_OW 310
99391: NOT
99392: IFFALSE 99439
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
99394: CALL_OW 45
99398: PPUSH
99399: LD_VAR 0 2
99403: PUSH
99404: LD_INT 1
99406: ARRAY
99407: PPUSH
99408: CALL_OW 250
99412: PPUSH
99413: LD_VAR 0 2
99417: PUSH
99418: LD_INT 1
99420: ARRAY
99421: PPUSH
99422: CALL_OW 251
99426: PPUSH
99427: LD_INT 12
99429: PPUSH
99430: LD_INT 1
99432: PPUSH
99433: CALL_OW 50
99437: GO 99451
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
99439: CALL_OW 45
99443: PPUSH
99444: LD_INT 1
99446: PPUSH
99447: CALL_OW 51
// end ;
99451: GO 99325
99453: POP
99454: POP
// end ;
99455: PPOPN 2
99457: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
99458: LD_EXP 113
99462: PUSH
99463: LD_EXP 159
99467: AND
99468: IFFALSE 99690
99470: GO 99472
99472: DISABLE
99473: LD_INT 0
99475: PPUSH
99476: PPUSH
99477: PPUSH
99478: PPUSH
99479: PPUSH
99480: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99481: LD_ADDR_VAR 0 6
99485: PUSH
99486: LD_INT 22
99488: PUSH
99489: LD_OWVAR 2
99493: PUSH
99494: EMPTY
99495: LIST
99496: LIST
99497: PUSH
99498: LD_INT 21
99500: PUSH
99501: LD_INT 1
99503: PUSH
99504: EMPTY
99505: LIST
99506: LIST
99507: PUSH
99508: LD_INT 3
99510: PUSH
99511: LD_INT 23
99513: PUSH
99514: LD_INT 0
99516: PUSH
99517: EMPTY
99518: LIST
99519: LIST
99520: PUSH
99521: EMPTY
99522: LIST
99523: LIST
99524: PUSH
99525: EMPTY
99526: LIST
99527: LIST
99528: LIST
99529: PPUSH
99530: CALL_OW 69
99534: ST_TO_ADDR
// if not tmp then
99535: LD_VAR 0 6
99539: NOT
99540: IFFALSE 99544
// exit ;
99542: GO 99690
// s1 := rand ( 1 , 4 ) ;
99544: LD_ADDR_VAR 0 2
99548: PUSH
99549: LD_INT 1
99551: PPUSH
99552: LD_INT 4
99554: PPUSH
99555: CALL_OW 12
99559: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
99560: LD_ADDR_VAR 0 4
99564: PUSH
99565: LD_VAR 0 6
99569: PUSH
99570: LD_INT 1
99572: ARRAY
99573: PPUSH
99574: LD_VAR 0 2
99578: PPUSH
99579: CALL_OW 259
99583: ST_TO_ADDR
// if s1 = 1 then
99584: LD_VAR 0 2
99588: PUSH
99589: LD_INT 1
99591: EQUAL
99592: IFFALSE 99612
// s2 := rand ( 2 , 4 ) else
99594: LD_ADDR_VAR 0 3
99598: PUSH
99599: LD_INT 2
99601: PPUSH
99602: LD_INT 4
99604: PPUSH
99605: CALL_OW 12
99609: ST_TO_ADDR
99610: GO 99620
// s2 := 1 ;
99612: LD_ADDR_VAR 0 3
99616: PUSH
99617: LD_INT 1
99619: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
99620: LD_ADDR_VAR 0 5
99624: PUSH
99625: LD_VAR 0 6
99629: PUSH
99630: LD_INT 1
99632: ARRAY
99633: PPUSH
99634: LD_VAR 0 3
99638: PPUSH
99639: CALL_OW 259
99643: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
99644: LD_VAR 0 6
99648: PUSH
99649: LD_INT 1
99651: ARRAY
99652: PPUSH
99653: LD_VAR 0 2
99657: PPUSH
99658: LD_VAR 0 5
99662: PPUSH
99663: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
99667: LD_VAR 0 6
99671: PUSH
99672: LD_INT 1
99674: ARRAY
99675: PPUSH
99676: LD_VAR 0 3
99680: PPUSH
99681: LD_VAR 0 4
99685: PPUSH
99686: CALL_OW 237
// end ;
99690: PPOPN 6
99692: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
99693: LD_EXP 113
99697: PUSH
99698: LD_EXP 160
99702: AND
99703: IFFALSE 99782
99705: GO 99707
99707: DISABLE
99708: LD_INT 0
99710: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
99711: LD_ADDR_VAR 0 1
99715: PUSH
99716: LD_INT 22
99718: PUSH
99719: LD_OWVAR 2
99723: PUSH
99724: EMPTY
99725: LIST
99726: LIST
99727: PUSH
99728: LD_INT 30
99730: PUSH
99731: LD_INT 3
99733: PUSH
99734: EMPTY
99735: LIST
99736: LIST
99737: PUSH
99738: EMPTY
99739: LIST
99740: LIST
99741: PPUSH
99742: CALL_OW 69
99746: ST_TO_ADDR
// if not tmp then
99747: LD_VAR 0 1
99751: NOT
99752: IFFALSE 99756
// exit ;
99754: GO 99782
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99756: LD_VAR 0 1
99760: PUSH
99761: LD_INT 1
99763: PPUSH
99764: LD_VAR 0 1
99768: PPUSH
99769: CALL_OW 12
99773: ARRAY
99774: PPUSH
99775: LD_INT 1
99777: PPUSH
99778: CALL_OW 234
// end ;
99782: PPOPN 1
99784: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
99785: LD_EXP 113
99789: PUSH
99790: LD_EXP 161
99794: AND
99795: IFFALSE 99907
99797: GO 99799
99799: DISABLE
99800: LD_INT 0
99802: PPUSH
99803: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
99804: LD_ADDR_VAR 0 2
99808: PUSH
99809: LD_INT 22
99811: PUSH
99812: LD_OWVAR 2
99816: PUSH
99817: EMPTY
99818: LIST
99819: LIST
99820: PUSH
99821: LD_INT 2
99823: PUSH
99824: LD_INT 30
99826: PUSH
99827: LD_INT 27
99829: PUSH
99830: EMPTY
99831: LIST
99832: LIST
99833: PUSH
99834: LD_INT 30
99836: PUSH
99837: LD_INT 26
99839: PUSH
99840: EMPTY
99841: LIST
99842: LIST
99843: PUSH
99844: LD_INT 30
99846: PUSH
99847: LD_INT 28
99849: PUSH
99850: EMPTY
99851: LIST
99852: LIST
99853: PUSH
99854: EMPTY
99855: LIST
99856: LIST
99857: LIST
99858: LIST
99859: PUSH
99860: EMPTY
99861: LIST
99862: LIST
99863: PPUSH
99864: CALL_OW 69
99868: ST_TO_ADDR
// if not tmp then
99869: LD_VAR 0 2
99873: NOT
99874: IFFALSE 99878
// exit ;
99876: GO 99907
// for i in tmp do
99878: LD_ADDR_VAR 0 1
99882: PUSH
99883: LD_VAR 0 2
99887: PUSH
99888: FOR_IN
99889: IFFALSE 99905
// SetLives ( i , 1 ) ;
99891: LD_VAR 0 1
99895: PPUSH
99896: LD_INT 1
99898: PPUSH
99899: CALL_OW 234
99903: GO 99888
99905: POP
99906: POP
// end ;
99907: PPOPN 2
99909: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
99910: LD_EXP 113
99914: PUSH
99915: LD_EXP 162
99919: AND
99920: IFFALSE 100207
99922: GO 99924
99924: DISABLE
99925: LD_INT 0
99927: PPUSH
99928: PPUSH
99929: PPUSH
// begin i := rand ( 1 , 7 ) ;
99930: LD_ADDR_VAR 0 1
99934: PUSH
99935: LD_INT 1
99937: PPUSH
99938: LD_INT 7
99940: PPUSH
99941: CALL_OW 12
99945: ST_TO_ADDR
// case i of 1 :
99946: LD_VAR 0 1
99950: PUSH
99951: LD_INT 1
99953: DOUBLE
99954: EQUAL
99955: IFTRUE 99959
99957: GO 99969
99959: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
99960: LD_STRING earthquake(getX(game), 0, 32)
99962: PPUSH
99963: CALL_OW 559
99967: GO 100207
99969: LD_INT 2
99971: DOUBLE
99972: EQUAL
99973: IFTRUE 99977
99975: GO 99991
99977: POP
// begin ToLua ( displayStucuk(); ) ;
99978: LD_STRING displayStucuk();
99980: PPUSH
99981: CALL_OW 559
// ResetFog ;
99985: CALL_OW 335
// end ; 3 :
99989: GO 100207
99991: LD_INT 3
99993: DOUBLE
99994: EQUAL
99995: IFTRUE 99999
99997: GO 100103
99999: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100000: LD_ADDR_VAR 0 2
100004: PUSH
100005: LD_INT 22
100007: PUSH
100008: LD_OWVAR 2
100012: PUSH
100013: EMPTY
100014: LIST
100015: LIST
100016: PUSH
100017: LD_INT 25
100019: PUSH
100020: LD_INT 1
100022: PUSH
100023: EMPTY
100024: LIST
100025: LIST
100026: PUSH
100027: EMPTY
100028: LIST
100029: LIST
100030: PPUSH
100031: CALL_OW 69
100035: ST_TO_ADDR
// if not tmp then
100036: LD_VAR 0 2
100040: NOT
100041: IFFALSE 100045
// exit ;
100043: GO 100207
// un := tmp [ rand ( 1 , tmp ) ] ;
100045: LD_ADDR_VAR 0 3
100049: PUSH
100050: LD_VAR 0 2
100054: PUSH
100055: LD_INT 1
100057: PPUSH
100058: LD_VAR 0 2
100062: PPUSH
100063: CALL_OW 12
100067: ARRAY
100068: ST_TO_ADDR
// if Crawls ( un ) then
100069: LD_VAR 0 3
100073: PPUSH
100074: CALL_OW 318
100078: IFFALSE 100089
// ComWalk ( un ) ;
100080: LD_VAR 0 3
100084: PPUSH
100085: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100089: LD_VAR 0 3
100093: PPUSH
100094: LD_INT 8
100096: PPUSH
100097: CALL_OW 336
// end ; 4 :
100101: GO 100207
100103: LD_INT 4
100105: DOUBLE
100106: EQUAL
100107: IFTRUE 100111
100109: GO 100185
100111: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100112: LD_ADDR_VAR 0 2
100116: PUSH
100117: LD_INT 22
100119: PUSH
100120: LD_OWVAR 2
100124: PUSH
100125: EMPTY
100126: LIST
100127: LIST
100128: PUSH
100129: LD_INT 30
100131: PUSH
100132: LD_INT 29
100134: PUSH
100135: EMPTY
100136: LIST
100137: LIST
100138: PUSH
100139: EMPTY
100140: LIST
100141: LIST
100142: PPUSH
100143: CALL_OW 69
100147: ST_TO_ADDR
// if not tmp then
100148: LD_VAR 0 2
100152: NOT
100153: IFFALSE 100157
// exit ;
100155: GO 100207
// CenterNowOnUnits ( tmp [ 1 ] ) ;
100157: LD_VAR 0 2
100161: PUSH
100162: LD_INT 1
100164: ARRAY
100165: PPUSH
100166: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
100170: LD_VAR 0 2
100174: PUSH
100175: LD_INT 1
100177: ARRAY
100178: PPUSH
100179: CALL_OW 65
// end ; 5 .. 7 :
100183: GO 100207
100185: LD_INT 5
100187: DOUBLE
100188: GREATEREQUAL
100189: IFFALSE 100197
100191: LD_INT 7
100193: DOUBLE
100194: LESSEQUAL
100195: IFTRUE 100199
100197: GO 100206
100199: POP
// StreamSibBomb ; end ;
100200: CALL 96444 0 0
100204: GO 100207
100206: POP
// end ;
100207: PPOPN 3
100209: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
100210: LD_EXP 113
100214: PUSH
100215: LD_EXP 163
100219: AND
100220: IFFALSE 100376
100222: GO 100224
100224: DISABLE
100225: LD_INT 0
100227: PPUSH
100228: PPUSH
100229: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
100230: LD_ADDR_VAR 0 2
100234: PUSH
100235: LD_INT 81
100237: PUSH
100238: LD_OWVAR 2
100242: PUSH
100243: EMPTY
100244: LIST
100245: LIST
100246: PUSH
100247: LD_INT 2
100249: PUSH
100250: LD_INT 21
100252: PUSH
100253: LD_INT 1
100255: PUSH
100256: EMPTY
100257: LIST
100258: LIST
100259: PUSH
100260: LD_INT 21
100262: PUSH
100263: LD_INT 2
100265: PUSH
100266: EMPTY
100267: LIST
100268: LIST
100269: PUSH
100270: EMPTY
100271: LIST
100272: LIST
100273: LIST
100274: PUSH
100275: EMPTY
100276: LIST
100277: LIST
100278: PPUSH
100279: CALL_OW 69
100283: ST_TO_ADDR
// if not tmp then
100284: LD_VAR 0 2
100288: NOT
100289: IFFALSE 100293
// exit ;
100291: GO 100376
// p := 0 ;
100293: LD_ADDR_VAR 0 3
100297: PUSH
100298: LD_INT 0
100300: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100301: LD_INT 35
100303: PPUSH
100304: CALL_OW 67
// p := p + 1 ;
100308: LD_ADDR_VAR 0 3
100312: PUSH
100313: LD_VAR 0 3
100317: PUSH
100318: LD_INT 1
100320: PLUS
100321: ST_TO_ADDR
// for i in tmp do
100322: LD_ADDR_VAR 0 1
100326: PUSH
100327: LD_VAR 0 2
100331: PUSH
100332: FOR_IN
100333: IFFALSE 100364
// if GetLives ( i ) < 1000 then
100335: LD_VAR 0 1
100339: PPUSH
100340: CALL_OW 256
100344: PUSH
100345: LD_INT 1000
100347: LESS
100348: IFFALSE 100362
// SetLives ( i , 1000 ) ;
100350: LD_VAR 0 1
100354: PPUSH
100355: LD_INT 1000
100357: PPUSH
100358: CALL_OW 234
100362: GO 100332
100364: POP
100365: POP
// until p > 20 ;
100366: LD_VAR 0 3
100370: PUSH
100371: LD_INT 20
100373: GREATER
100374: IFFALSE 100301
// end ;
100376: PPOPN 3
100378: END
// every 0 0$1 trigger StreamModeActive and sTime do
100379: LD_EXP 113
100383: PUSH
100384: LD_EXP 164
100388: AND
100389: IFFALSE 100424
100391: GO 100393
100393: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
100394: LD_INT 28
100396: PPUSH
100397: LD_OWVAR 2
100401: PPUSH
100402: LD_INT 2
100404: PPUSH
100405: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
100409: LD_INT 30
100411: PPUSH
100412: LD_OWVAR 2
100416: PPUSH
100417: LD_INT 2
100419: PPUSH
100420: CALL_OW 322
// end ;
100424: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
100425: LD_EXP 113
100429: PUSH
100430: LD_EXP 165
100434: AND
100435: IFFALSE 100556
100437: GO 100439
100439: DISABLE
100440: LD_INT 0
100442: PPUSH
100443: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100444: LD_ADDR_VAR 0 2
100448: PUSH
100449: LD_INT 22
100451: PUSH
100452: LD_OWVAR 2
100456: PUSH
100457: EMPTY
100458: LIST
100459: LIST
100460: PUSH
100461: LD_INT 21
100463: PUSH
100464: LD_INT 1
100466: PUSH
100467: EMPTY
100468: LIST
100469: LIST
100470: PUSH
100471: LD_INT 3
100473: PUSH
100474: LD_INT 23
100476: PUSH
100477: LD_INT 0
100479: PUSH
100480: EMPTY
100481: LIST
100482: LIST
100483: PUSH
100484: EMPTY
100485: LIST
100486: LIST
100487: PUSH
100488: EMPTY
100489: LIST
100490: LIST
100491: LIST
100492: PPUSH
100493: CALL_OW 69
100497: ST_TO_ADDR
// if not tmp then
100498: LD_VAR 0 2
100502: NOT
100503: IFFALSE 100507
// exit ;
100505: GO 100556
// for i in tmp do
100507: LD_ADDR_VAR 0 1
100511: PUSH
100512: LD_VAR 0 2
100516: PUSH
100517: FOR_IN
100518: IFFALSE 100554
// begin if Crawls ( i ) then
100520: LD_VAR 0 1
100524: PPUSH
100525: CALL_OW 318
100529: IFFALSE 100540
// ComWalk ( i ) ;
100531: LD_VAR 0 1
100535: PPUSH
100536: CALL_OW 138
// SetClass ( i , 2 ) ;
100540: LD_VAR 0 1
100544: PPUSH
100545: LD_INT 2
100547: PPUSH
100548: CALL_OW 336
// end ;
100552: GO 100517
100554: POP
100555: POP
// end ;
100556: PPOPN 2
100558: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
100559: LD_EXP 113
100563: PUSH
100564: LD_EXP 166
100568: AND
100569: IFFALSE 100857
100571: GO 100573
100573: DISABLE
100574: LD_INT 0
100576: PPUSH
100577: PPUSH
100578: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
100579: LD_OWVAR 2
100583: PPUSH
100584: LD_INT 9
100586: PPUSH
100587: LD_INT 1
100589: PPUSH
100590: LD_INT 1
100592: PPUSH
100593: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
100597: LD_INT 9
100599: PPUSH
100600: LD_OWVAR 2
100604: PPUSH
100605: CALL_OW 343
// uc_side := 9 ;
100609: LD_ADDR_OWVAR 20
100613: PUSH
100614: LD_INT 9
100616: ST_TO_ADDR
// uc_nation := 2 ;
100617: LD_ADDR_OWVAR 21
100621: PUSH
100622: LD_INT 2
100624: ST_TO_ADDR
// hc_name := Dark Warrior ;
100625: LD_ADDR_OWVAR 26
100629: PUSH
100630: LD_STRING Dark Warrior
100632: ST_TO_ADDR
// hc_gallery :=  ;
100633: LD_ADDR_OWVAR 33
100637: PUSH
100638: LD_STRING 
100640: ST_TO_ADDR
// hc_noskilllimit := true ;
100641: LD_ADDR_OWVAR 76
100645: PUSH
100646: LD_INT 1
100648: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
100649: LD_ADDR_OWVAR 31
100653: PUSH
100654: LD_INT 30
100656: PUSH
100657: LD_INT 30
100659: PUSH
100660: LD_INT 30
100662: PUSH
100663: LD_INT 30
100665: PUSH
100666: EMPTY
100667: LIST
100668: LIST
100669: LIST
100670: LIST
100671: ST_TO_ADDR
// un := CreateHuman ;
100672: LD_ADDR_VAR 0 3
100676: PUSH
100677: CALL_OW 44
100681: ST_TO_ADDR
// hc_noskilllimit := false ;
100682: LD_ADDR_OWVAR 76
100686: PUSH
100687: LD_INT 0
100689: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100690: LD_VAR 0 3
100694: PPUSH
100695: LD_INT 1
100697: PPUSH
100698: CALL_OW 51
// ToLua ( playRanger() ) ;
100702: LD_STRING playRanger()
100704: PPUSH
100705: CALL_OW 559
// p := 0 ;
100709: LD_ADDR_VAR 0 2
100713: PUSH
100714: LD_INT 0
100716: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100717: LD_INT 35
100719: PPUSH
100720: CALL_OW 67
// p := p + 1 ;
100724: LD_ADDR_VAR 0 2
100728: PUSH
100729: LD_VAR 0 2
100733: PUSH
100734: LD_INT 1
100736: PLUS
100737: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
100738: LD_VAR 0 3
100742: PPUSH
100743: CALL_OW 256
100747: PUSH
100748: LD_INT 1000
100750: LESS
100751: IFFALSE 100765
// SetLives ( un , 1000 ) ;
100753: LD_VAR 0 3
100757: PPUSH
100758: LD_INT 1000
100760: PPUSH
100761: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
100765: LD_VAR 0 3
100769: PPUSH
100770: LD_INT 81
100772: PUSH
100773: LD_OWVAR 2
100777: PUSH
100778: EMPTY
100779: LIST
100780: LIST
100781: PUSH
100782: LD_INT 91
100784: PUSH
100785: LD_VAR 0 3
100789: PUSH
100790: LD_INT 30
100792: PUSH
100793: EMPTY
100794: LIST
100795: LIST
100796: LIST
100797: PUSH
100798: EMPTY
100799: LIST
100800: LIST
100801: PPUSH
100802: CALL_OW 69
100806: PPUSH
100807: LD_VAR 0 3
100811: PPUSH
100812: CALL_OW 74
100816: PPUSH
100817: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
100821: LD_VAR 0 2
100825: PUSH
100826: LD_INT 80
100828: GREATER
100829: PUSH
100830: LD_VAR 0 3
100834: PPUSH
100835: CALL_OW 301
100839: OR
100840: IFFALSE 100717
// if un then
100842: LD_VAR 0 3
100846: IFFALSE 100857
// RemoveUnit ( un ) ;
100848: LD_VAR 0 3
100852: PPUSH
100853: CALL_OW 64
// end ;
100857: PPOPN 3
100859: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
100860: LD_EXP 167
100864: IFFALSE 100980
100866: GO 100868
100868: DISABLE
100869: LD_INT 0
100871: PPUSH
100872: PPUSH
100873: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100874: LD_ADDR_VAR 0 2
100878: PUSH
100879: LD_INT 81
100881: PUSH
100882: LD_OWVAR 2
100886: PUSH
100887: EMPTY
100888: LIST
100889: LIST
100890: PUSH
100891: LD_INT 21
100893: PUSH
100894: LD_INT 1
100896: PUSH
100897: EMPTY
100898: LIST
100899: LIST
100900: PUSH
100901: EMPTY
100902: LIST
100903: LIST
100904: PPUSH
100905: CALL_OW 69
100909: ST_TO_ADDR
// ToLua ( playComputer() ) ;
100910: LD_STRING playComputer()
100912: PPUSH
100913: CALL_OW 559
// if not tmp then
100917: LD_VAR 0 2
100921: NOT
100922: IFFALSE 100926
// exit ;
100924: GO 100980
// for i in tmp do
100926: LD_ADDR_VAR 0 1
100930: PUSH
100931: LD_VAR 0 2
100935: PUSH
100936: FOR_IN
100937: IFFALSE 100978
// for j := 1 to 4 do
100939: LD_ADDR_VAR 0 3
100943: PUSH
100944: DOUBLE
100945: LD_INT 1
100947: DEC
100948: ST_TO_ADDR
100949: LD_INT 4
100951: PUSH
100952: FOR_TO
100953: IFFALSE 100974
// SetSkill ( i , j , 10 ) ;
100955: LD_VAR 0 1
100959: PPUSH
100960: LD_VAR 0 3
100964: PPUSH
100965: LD_INT 10
100967: PPUSH
100968: CALL_OW 237
100972: GO 100952
100974: POP
100975: POP
100976: GO 100936
100978: POP
100979: POP
// end ;
100980: PPOPN 3
100982: END
// every 0 0$1 trigger s30 do var i , tmp ;
100983: LD_EXP 168
100987: IFFALSE 101056
100989: GO 100991
100991: DISABLE
100992: LD_INT 0
100994: PPUSH
100995: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100996: LD_ADDR_VAR 0 2
101000: PUSH
101001: LD_INT 22
101003: PUSH
101004: LD_OWVAR 2
101008: PUSH
101009: EMPTY
101010: LIST
101011: LIST
101012: PPUSH
101013: CALL_OW 69
101017: ST_TO_ADDR
// if not tmp then
101018: LD_VAR 0 2
101022: NOT
101023: IFFALSE 101027
// exit ;
101025: GO 101056
// for i in tmp do
101027: LD_ADDR_VAR 0 1
101031: PUSH
101032: LD_VAR 0 2
101036: PUSH
101037: FOR_IN
101038: IFFALSE 101054
// SetLives ( i , 300 ) ;
101040: LD_VAR 0 1
101044: PPUSH
101045: LD_INT 300
101047: PPUSH
101048: CALL_OW 234
101052: GO 101037
101054: POP
101055: POP
// end ;
101056: PPOPN 2
101058: END
// every 0 0$1 trigger s60 do var i , tmp ;
101059: LD_EXP 169
101063: IFFALSE 101132
101065: GO 101067
101067: DISABLE
101068: LD_INT 0
101070: PPUSH
101071: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101072: LD_ADDR_VAR 0 2
101076: PUSH
101077: LD_INT 22
101079: PUSH
101080: LD_OWVAR 2
101084: PUSH
101085: EMPTY
101086: LIST
101087: LIST
101088: PPUSH
101089: CALL_OW 69
101093: ST_TO_ADDR
// if not tmp then
101094: LD_VAR 0 2
101098: NOT
101099: IFFALSE 101103
// exit ;
101101: GO 101132
// for i in tmp do
101103: LD_ADDR_VAR 0 1
101107: PUSH
101108: LD_VAR 0 2
101112: PUSH
101113: FOR_IN
101114: IFFALSE 101130
// SetLives ( i , 600 ) ;
101116: LD_VAR 0 1
101120: PPUSH
101121: LD_INT 600
101123: PPUSH
101124: CALL_OW 234
101128: GO 101113
101130: POP
101131: POP
// end ;
101132: PPOPN 2
101134: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
101135: LD_INT 0
101137: PPUSH
// case cmd of 301 :
101138: LD_VAR 0 1
101142: PUSH
101143: LD_INT 301
101145: DOUBLE
101146: EQUAL
101147: IFTRUE 101151
101149: GO 101183
101151: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
101152: LD_VAR 0 6
101156: PPUSH
101157: LD_VAR 0 7
101161: PPUSH
101162: LD_VAR 0 8
101166: PPUSH
101167: LD_VAR 0 4
101171: PPUSH
101172: LD_VAR 0 5
101176: PPUSH
101177: CALL 102384 0 5
101181: GO 101304
101183: LD_INT 302
101185: DOUBLE
101186: EQUAL
101187: IFTRUE 101191
101189: GO 101228
101191: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
101192: LD_VAR 0 6
101196: PPUSH
101197: LD_VAR 0 7
101201: PPUSH
101202: LD_VAR 0 8
101206: PPUSH
101207: LD_VAR 0 9
101211: PPUSH
101212: LD_VAR 0 4
101216: PPUSH
101217: LD_VAR 0 5
101221: PPUSH
101222: CALL 102475 0 6
101226: GO 101304
101228: LD_INT 303
101230: DOUBLE
101231: EQUAL
101232: IFTRUE 101236
101234: GO 101273
101236: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
101237: LD_VAR 0 6
101241: PPUSH
101242: LD_VAR 0 7
101246: PPUSH
101247: LD_VAR 0 8
101251: PPUSH
101252: LD_VAR 0 9
101256: PPUSH
101257: LD_VAR 0 4
101261: PPUSH
101262: LD_VAR 0 5
101266: PPUSH
101267: CALL 101309 0 6
101271: GO 101304
101273: LD_INT 304
101275: DOUBLE
101276: EQUAL
101277: IFTRUE 101281
101279: GO 101303
101281: POP
// hHackTeleport ( unit , x , y ) ; end ;
101282: LD_VAR 0 2
101286: PPUSH
101287: LD_VAR 0 4
101291: PPUSH
101292: LD_VAR 0 5
101296: PPUSH
101297: CALL 103068 0 3
101301: GO 101304
101303: POP
// end ;
101304: LD_VAR 0 12
101308: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
101309: LD_INT 0
101311: PPUSH
101312: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
101313: LD_VAR 0 1
101317: PUSH
101318: LD_INT 1
101320: LESS
101321: PUSH
101322: LD_VAR 0 1
101326: PUSH
101327: LD_INT 3
101329: GREATER
101330: OR
101331: PUSH
101332: LD_VAR 0 5
101336: PPUSH
101337: LD_VAR 0 6
101341: PPUSH
101342: CALL_OW 428
101346: OR
101347: IFFALSE 101351
// exit ;
101349: GO 102071
// uc_side := your_side ;
101351: LD_ADDR_OWVAR 20
101355: PUSH
101356: LD_OWVAR 2
101360: ST_TO_ADDR
// uc_nation := nation ;
101361: LD_ADDR_OWVAR 21
101365: PUSH
101366: LD_VAR 0 1
101370: ST_TO_ADDR
// bc_level = 1 ;
101371: LD_ADDR_OWVAR 43
101375: PUSH
101376: LD_INT 1
101378: ST_TO_ADDR
// case btype of 1 :
101379: LD_VAR 0 2
101383: PUSH
101384: LD_INT 1
101386: DOUBLE
101387: EQUAL
101388: IFTRUE 101392
101390: GO 101403
101392: POP
// bc_type := b_depot ; 2 :
101393: LD_ADDR_OWVAR 42
101397: PUSH
101398: LD_INT 0
101400: ST_TO_ADDR
101401: GO 102015
101403: LD_INT 2
101405: DOUBLE
101406: EQUAL
101407: IFTRUE 101411
101409: GO 101422
101411: POP
// bc_type := b_warehouse ; 3 :
101412: LD_ADDR_OWVAR 42
101416: PUSH
101417: LD_INT 1
101419: ST_TO_ADDR
101420: GO 102015
101422: LD_INT 3
101424: DOUBLE
101425: EQUAL
101426: IFTRUE 101430
101428: GO 101441
101430: POP
// bc_type := b_lab ; 4 .. 9 :
101431: LD_ADDR_OWVAR 42
101435: PUSH
101436: LD_INT 6
101438: ST_TO_ADDR
101439: GO 102015
101441: LD_INT 4
101443: DOUBLE
101444: GREATEREQUAL
101445: IFFALSE 101453
101447: LD_INT 9
101449: DOUBLE
101450: LESSEQUAL
101451: IFTRUE 101455
101453: GO 101507
101455: POP
// begin bc_type := b_lab_half ;
101456: LD_ADDR_OWVAR 42
101460: PUSH
101461: LD_INT 7
101463: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
101464: LD_ADDR_OWVAR 44
101468: PUSH
101469: LD_INT 10
101471: PUSH
101472: LD_INT 11
101474: PUSH
101475: LD_INT 12
101477: PUSH
101478: LD_INT 15
101480: PUSH
101481: LD_INT 14
101483: PUSH
101484: LD_INT 13
101486: PUSH
101487: EMPTY
101488: LIST
101489: LIST
101490: LIST
101491: LIST
101492: LIST
101493: LIST
101494: PUSH
101495: LD_VAR 0 2
101499: PUSH
101500: LD_INT 3
101502: MINUS
101503: ARRAY
101504: ST_TO_ADDR
// end ; 10 .. 13 :
101505: GO 102015
101507: LD_INT 10
101509: DOUBLE
101510: GREATEREQUAL
101511: IFFALSE 101519
101513: LD_INT 13
101515: DOUBLE
101516: LESSEQUAL
101517: IFTRUE 101521
101519: GO 101598
101521: POP
// begin bc_type := b_lab_full ;
101522: LD_ADDR_OWVAR 42
101526: PUSH
101527: LD_INT 8
101529: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
101530: LD_ADDR_OWVAR 44
101534: PUSH
101535: LD_INT 10
101537: PUSH
101538: LD_INT 12
101540: PUSH
101541: LD_INT 14
101543: PUSH
101544: LD_INT 13
101546: PUSH
101547: EMPTY
101548: LIST
101549: LIST
101550: LIST
101551: LIST
101552: PUSH
101553: LD_VAR 0 2
101557: PUSH
101558: LD_INT 9
101560: MINUS
101561: ARRAY
101562: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
101563: LD_ADDR_OWVAR 45
101567: PUSH
101568: LD_INT 11
101570: PUSH
101571: LD_INT 15
101573: PUSH
101574: LD_INT 12
101576: PUSH
101577: LD_INT 15
101579: PUSH
101580: EMPTY
101581: LIST
101582: LIST
101583: LIST
101584: LIST
101585: PUSH
101586: LD_VAR 0 2
101590: PUSH
101591: LD_INT 9
101593: MINUS
101594: ARRAY
101595: ST_TO_ADDR
// end ; 14 :
101596: GO 102015
101598: LD_INT 14
101600: DOUBLE
101601: EQUAL
101602: IFTRUE 101606
101604: GO 101617
101606: POP
// bc_type := b_workshop ; 15 :
101607: LD_ADDR_OWVAR 42
101611: PUSH
101612: LD_INT 2
101614: ST_TO_ADDR
101615: GO 102015
101617: LD_INT 15
101619: DOUBLE
101620: EQUAL
101621: IFTRUE 101625
101623: GO 101636
101625: POP
// bc_type := b_factory ; 16 :
101626: LD_ADDR_OWVAR 42
101630: PUSH
101631: LD_INT 3
101633: ST_TO_ADDR
101634: GO 102015
101636: LD_INT 16
101638: DOUBLE
101639: EQUAL
101640: IFTRUE 101644
101642: GO 101655
101644: POP
// bc_type := b_ext_gun ; 17 :
101645: LD_ADDR_OWVAR 42
101649: PUSH
101650: LD_INT 17
101652: ST_TO_ADDR
101653: GO 102015
101655: LD_INT 17
101657: DOUBLE
101658: EQUAL
101659: IFTRUE 101663
101661: GO 101691
101663: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
101664: LD_ADDR_OWVAR 42
101668: PUSH
101669: LD_INT 19
101671: PUSH
101672: LD_INT 23
101674: PUSH
101675: LD_INT 19
101677: PUSH
101678: EMPTY
101679: LIST
101680: LIST
101681: LIST
101682: PUSH
101683: LD_VAR 0 1
101687: ARRAY
101688: ST_TO_ADDR
101689: GO 102015
101691: LD_INT 18
101693: DOUBLE
101694: EQUAL
101695: IFTRUE 101699
101697: GO 101710
101699: POP
// bc_type := b_ext_radar ; 19 :
101700: LD_ADDR_OWVAR 42
101704: PUSH
101705: LD_INT 20
101707: ST_TO_ADDR
101708: GO 102015
101710: LD_INT 19
101712: DOUBLE
101713: EQUAL
101714: IFTRUE 101718
101716: GO 101729
101718: POP
// bc_type := b_ext_radio ; 20 :
101719: LD_ADDR_OWVAR 42
101723: PUSH
101724: LD_INT 22
101726: ST_TO_ADDR
101727: GO 102015
101729: LD_INT 20
101731: DOUBLE
101732: EQUAL
101733: IFTRUE 101737
101735: GO 101748
101737: POP
// bc_type := b_ext_siberium ; 21 :
101738: LD_ADDR_OWVAR 42
101742: PUSH
101743: LD_INT 21
101745: ST_TO_ADDR
101746: GO 102015
101748: LD_INT 21
101750: DOUBLE
101751: EQUAL
101752: IFTRUE 101756
101754: GO 101767
101756: POP
// bc_type := b_ext_computer ; 22 :
101757: LD_ADDR_OWVAR 42
101761: PUSH
101762: LD_INT 24
101764: ST_TO_ADDR
101765: GO 102015
101767: LD_INT 22
101769: DOUBLE
101770: EQUAL
101771: IFTRUE 101775
101773: GO 101786
101775: POP
// bc_type := b_ext_track ; 23 :
101776: LD_ADDR_OWVAR 42
101780: PUSH
101781: LD_INT 16
101783: ST_TO_ADDR
101784: GO 102015
101786: LD_INT 23
101788: DOUBLE
101789: EQUAL
101790: IFTRUE 101794
101792: GO 101805
101794: POP
// bc_type := b_ext_laser ; 24 :
101795: LD_ADDR_OWVAR 42
101799: PUSH
101800: LD_INT 25
101802: ST_TO_ADDR
101803: GO 102015
101805: LD_INT 24
101807: DOUBLE
101808: EQUAL
101809: IFTRUE 101813
101811: GO 101824
101813: POP
// bc_type := b_control_tower ; 25 :
101814: LD_ADDR_OWVAR 42
101818: PUSH
101819: LD_INT 36
101821: ST_TO_ADDR
101822: GO 102015
101824: LD_INT 25
101826: DOUBLE
101827: EQUAL
101828: IFTRUE 101832
101830: GO 101843
101832: POP
// bc_type := b_breastwork ; 26 :
101833: LD_ADDR_OWVAR 42
101837: PUSH
101838: LD_INT 31
101840: ST_TO_ADDR
101841: GO 102015
101843: LD_INT 26
101845: DOUBLE
101846: EQUAL
101847: IFTRUE 101851
101849: GO 101862
101851: POP
// bc_type := b_bunker ; 27 :
101852: LD_ADDR_OWVAR 42
101856: PUSH
101857: LD_INT 32
101859: ST_TO_ADDR
101860: GO 102015
101862: LD_INT 27
101864: DOUBLE
101865: EQUAL
101866: IFTRUE 101870
101868: GO 101881
101870: POP
// bc_type := b_turret ; 28 :
101871: LD_ADDR_OWVAR 42
101875: PUSH
101876: LD_INT 33
101878: ST_TO_ADDR
101879: GO 102015
101881: LD_INT 28
101883: DOUBLE
101884: EQUAL
101885: IFTRUE 101889
101887: GO 101900
101889: POP
// bc_type := b_armoury ; 29 :
101890: LD_ADDR_OWVAR 42
101894: PUSH
101895: LD_INT 4
101897: ST_TO_ADDR
101898: GO 102015
101900: LD_INT 29
101902: DOUBLE
101903: EQUAL
101904: IFTRUE 101908
101906: GO 101919
101908: POP
// bc_type := b_barracks ; 30 :
101909: LD_ADDR_OWVAR 42
101913: PUSH
101914: LD_INT 5
101916: ST_TO_ADDR
101917: GO 102015
101919: LD_INT 30
101921: DOUBLE
101922: EQUAL
101923: IFTRUE 101927
101925: GO 101938
101927: POP
// bc_type := b_solar_power ; 31 :
101928: LD_ADDR_OWVAR 42
101932: PUSH
101933: LD_INT 27
101935: ST_TO_ADDR
101936: GO 102015
101938: LD_INT 31
101940: DOUBLE
101941: EQUAL
101942: IFTRUE 101946
101944: GO 101957
101946: POP
// bc_type := b_oil_power ; 32 :
101947: LD_ADDR_OWVAR 42
101951: PUSH
101952: LD_INT 26
101954: ST_TO_ADDR
101955: GO 102015
101957: LD_INT 32
101959: DOUBLE
101960: EQUAL
101961: IFTRUE 101965
101963: GO 101976
101965: POP
// bc_type := b_siberite_power ; 33 :
101966: LD_ADDR_OWVAR 42
101970: PUSH
101971: LD_INT 28
101973: ST_TO_ADDR
101974: GO 102015
101976: LD_INT 33
101978: DOUBLE
101979: EQUAL
101980: IFTRUE 101984
101982: GO 101995
101984: POP
// bc_type := b_oil_mine ; 34 :
101985: LD_ADDR_OWVAR 42
101989: PUSH
101990: LD_INT 29
101992: ST_TO_ADDR
101993: GO 102015
101995: LD_INT 34
101997: DOUBLE
101998: EQUAL
101999: IFTRUE 102003
102001: GO 102014
102003: POP
// bc_type := b_siberite_mine ; end ;
102004: LD_ADDR_OWVAR 42
102008: PUSH
102009: LD_INT 30
102011: ST_TO_ADDR
102012: GO 102015
102014: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
102015: LD_ADDR_VAR 0 8
102019: PUSH
102020: LD_VAR 0 5
102024: PPUSH
102025: LD_VAR 0 6
102029: PPUSH
102030: LD_VAR 0 3
102034: PPUSH
102035: CALL_OW 47
102039: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
102040: LD_OWVAR 42
102044: PUSH
102045: LD_INT 32
102047: PUSH
102048: LD_INT 33
102050: PUSH
102051: EMPTY
102052: LIST
102053: LIST
102054: IN
102055: IFFALSE 102071
// PlaceWeaponTurret ( b , weapon ) ;
102057: LD_VAR 0 8
102061: PPUSH
102062: LD_VAR 0 4
102066: PPUSH
102067: CALL_OW 431
// end ;
102071: LD_VAR 0 7
102075: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
102076: LD_INT 0
102078: PPUSH
102079: PPUSH
102080: PPUSH
102081: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102082: LD_ADDR_VAR 0 4
102086: PUSH
102087: LD_INT 22
102089: PUSH
102090: LD_OWVAR 2
102094: PUSH
102095: EMPTY
102096: LIST
102097: LIST
102098: PUSH
102099: LD_INT 2
102101: PUSH
102102: LD_INT 30
102104: PUSH
102105: LD_INT 0
102107: PUSH
102108: EMPTY
102109: LIST
102110: LIST
102111: PUSH
102112: LD_INT 30
102114: PUSH
102115: LD_INT 1
102117: PUSH
102118: EMPTY
102119: LIST
102120: LIST
102121: PUSH
102122: EMPTY
102123: LIST
102124: LIST
102125: LIST
102126: PUSH
102127: EMPTY
102128: LIST
102129: LIST
102130: PPUSH
102131: CALL_OW 69
102135: ST_TO_ADDR
// if not tmp then
102136: LD_VAR 0 4
102140: NOT
102141: IFFALSE 102145
// exit ;
102143: GO 102204
// for i in tmp do
102145: LD_ADDR_VAR 0 2
102149: PUSH
102150: LD_VAR 0 4
102154: PUSH
102155: FOR_IN
102156: IFFALSE 102202
// for j = 1 to 3 do
102158: LD_ADDR_VAR 0 3
102162: PUSH
102163: DOUBLE
102164: LD_INT 1
102166: DEC
102167: ST_TO_ADDR
102168: LD_INT 3
102170: PUSH
102171: FOR_TO
102172: IFFALSE 102198
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
102174: LD_VAR 0 2
102178: PPUSH
102179: CALL_OW 274
102183: PPUSH
102184: LD_VAR 0 3
102188: PPUSH
102189: LD_INT 99999
102191: PPUSH
102192: CALL_OW 277
102196: GO 102171
102198: POP
102199: POP
102200: GO 102155
102202: POP
102203: POP
// end ;
102204: LD_VAR 0 1
102208: RET
// export function hHackSetLevel10 ; var i , j ; begin
102209: LD_INT 0
102211: PPUSH
102212: PPUSH
102213: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102214: LD_ADDR_VAR 0 2
102218: PUSH
102219: LD_INT 21
102221: PUSH
102222: LD_INT 1
102224: PUSH
102225: EMPTY
102226: LIST
102227: LIST
102228: PPUSH
102229: CALL_OW 69
102233: PUSH
102234: FOR_IN
102235: IFFALSE 102287
// if IsSelected ( i ) then
102237: LD_VAR 0 2
102241: PPUSH
102242: CALL_OW 306
102246: IFFALSE 102285
// begin for j := 1 to 4 do
102248: LD_ADDR_VAR 0 3
102252: PUSH
102253: DOUBLE
102254: LD_INT 1
102256: DEC
102257: ST_TO_ADDR
102258: LD_INT 4
102260: PUSH
102261: FOR_TO
102262: IFFALSE 102283
// SetSkill ( i , j , 10 ) ;
102264: LD_VAR 0 2
102268: PPUSH
102269: LD_VAR 0 3
102273: PPUSH
102274: LD_INT 10
102276: PPUSH
102277: CALL_OW 237
102281: GO 102261
102283: POP
102284: POP
// end ;
102285: GO 102234
102287: POP
102288: POP
// end ;
102289: LD_VAR 0 1
102293: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
102294: LD_INT 0
102296: PPUSH
102297: PPUSH
102298: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
102299: LD_ADDR_VAR 0 2
102303: PUSH
102304: LD_INT 22
102306: PUSH
102307: LD_OWVAR 2
102311: PUSH
102312: EMPTY
102313: LIST
102314: LIST
102315: PUSH
102316: LD_INT 21
102318: PUSH
102319: LD_INT 1
102321: PUSH
102322: EMPTY
102323: LIST
102324: LIST
102325: PUSH
102326: EMPTY
102327: LIST
102328: LIST
102329: PPUSH
102330: CALL_OW 69
102334: PUSH
102335: FOR_IN
102336: IFFALSE 102377
// begin for j := 1 to 4 do
102338: LD_ADDR_VAR 0 3
102342: PUSH
102343: DOUBLE
102344: LD_INT 1
102346: DEC
102347: ST_TO_ADDR
102348: LD_INT 4
102350: PUSH
102351: FOR_TO
102352: IFFALSE 102373
// SetSkill ( i , j , 10 ) ;
102354: LD_VAR 0 2
102358: PPUSH
102359: LD_VAR 0 3
102363: PPUSH
102364: LD_INT 10
102366: PPUSH
102367: CALL_OW 237
102371: GO 102351
102373: POP
102374: POP
// end ;
102375: GO 102335
102377: POP
102378: POP
// end ;
102379: LD_VAR 0 1
102383: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
102384: LD_INT 0
102386: PPUSH
// uc_side := your_side ;
102387: LD_ADDR_OWVAR 20
102391: PUSH
102392: LD_OWVAR 2
102396: ST_TO_ADDR
// uc_nation := nation ;
102397: LD_ADDR_OWVAR 21
102401: PUSH
102402: LD_VAR 0 1
102406: ST_TO_ADDR
// InitHc ;
102407: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
102411: LD_INT 0
102413: PPUSH
102414: LD_VAR 0 2
102418: PPUSH
102419: LD_VAR 0 3
102423: PPUSH
102424: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
102428: LD_VAR 0 4
102432: PPUSH
102433: LD_VAR 0 5
102437: PPUSH
102438: CALL_OW 428
102442: PUSH
102443: LD_INT 0
102445: EQUAL
102446: IFFALSE 102470
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
102448: CALL_OW 44
102452: PPUSH
102453: LD_VAR 0 4
102457: PPUSH
102458: LD_VAR 0 5
102462: PPUSH
102463: LD_INT 1
102465: PPUSH
102466: CALL_OW 48
// end ;
102470: LD_VAR 0 6
102474: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
102475: LD_INT 0
102477: PPUSH
102478: PPUSH
// uc_side := your_side ;
102479: LD_ADDR_OWVAR 20
102483: PUSH
102484: LD_OWVAR 2
102488: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
102489: LD_VAR 0 1
102493: PUSH
102494: LD_INT 1
102496: PUSH
102497: LD_INT 2
102499: PUSH
102500: LD_INT 3
102502: PUSH
102503: LD_INT 4
102505: PUSH
102506: LD_INT 5
102508: PUSH
102509: EMPTY
102510: LIST
102511: LIST
102512: LIST
102513: LIST
102514: LIST
102515: IN
102516: IFFALSE 102528
// uc_nation := nation_american else
102518: LD_ADDR_OWVAR 21
102522: PUSH
102523: LD_INT 1
102525: ST_TO_ADDR
102526: GO 102571
// if chassis in [ 11 , 12 , 13 , 14 ] then
102528: LD_VAR 0 1
102532: PUSH
102533: LD_INT 11
102535: PUSH
102536: LD_INT 12
102538: PUSH
102539: LD_INT 13
102541: PUSH
102542: LD_INT 14
102544: PUSH
102545: EMPTY
102546: LIST
102547: LIST
102548: LIST
102549: LIST
102550: IN
102551: IFFALSE 102563
// uc_nation := nation_arabian else
102553: LD_ADDR_OWVAR 21
102557: PUSH
102558: LD_INT 2
102560: ST_TO_ADDR
102561: GO 102571
// uc_nation := nation_russian ;
102563: LD_ADDR_OWVAR 21
102567: PUSH
102568: LD_INT 3
102570: ST_TO_ADDR
// vc_chassis := chassis ;
102571: LD_ADDR_OWVAR 37
102575: PUSH
102576: LD_VAR 0 1
102580: ST_TO_ADDR
// vc_engine := engine ;
102581: LD_ADDR_OWVAR 39
102585: PUSH
102586: LD_VAR 0 2
102590: ST_TO_ADDR
// vc_control := control ;
102591: LD_ADDR_OWVAR 38
102595: PUSH
102596: LD_VAR 0 3
102600: ST_TO_ADDR
// vc_weapon := weapon ;
102601: LD_ADDR_OWVAR 40
102605: PUSH
102606: LD_VAR 0 4
102610: ST_TO_ADDR
// un := CreateVehicle ;
102611: LD_ADDR_VAR 0 8
102615: PUSH
102616: CALL_OW 45
102620: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
102621: LD_VAR 0 8
102625: PPUSH
102626: LD_INT 0
102628: PPUSH
102629: LD_INT 5
102631: PPUSH
102632: CALL_OW 12
102636: PPUSH
102637: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
102641: LD_VAR 0 8
102645: PPUSH
102646: LD_VAR 0 5
102650: PPUSH
102651: LD_VAR 0 6
102655: PPUSH
102656: LD_INT 1
102658: PPUSH
102659: CALL_OW 48
// end ;
102663: LD_VAR 0 7
102667: RET
// export hInvincible ; every 1 do
102668: GO 102670
102670: DISABLE
// hInvincible := [ ] ;
102671: LD_ADDR_EXP 170
102675: PUSH
102676: EMPTY
102677: ST_TO_ADDR
102678: END
// every 10 do var i ;
102679: GO 102681
102681: DISABLE
102682: LD_INT 0
102684: PPUSH
// begin enable ;
102685: ENABLE
// if not hInvincible then
102686: LD_EXP 170
102690: NOT
102691: IFFALSE 102695
// exit ;
102693: GO 102739
// for i in hInvincible do
102695: LD_ADDR_VAR 0 1
102699: PUSH
102700: LD_EXP 170
102704: PUSH
102705: FOR_IN
102706: IFFALSE 102737
// if GetLives ( i ) < 1000 then
102708: LD_VAR 0 1
102712: PPUSH
102713: CALL_OW 256
102717: PUSH
102718: LD_INT 1000
102720: LESS
102721: IFFALSE 102735
// SetLives ( i , 1000 ) ;
102723: LD_VAR 0 1
102727: PPUSH
102728: LD_INT 1000
102730: PPUSH
102731: CALL_OW 234
102735: GO 102705
102737: POP
102738: POP
// end ;
102739: PPOPN 1
102741: END
// export function hHackInvincible ; var i ; begin
102742: LD_INT 0
102744: PPUSH
102745: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
102746: LD_ADDR_VAR 0 2
102750: PUSH
102751: LD_INT 2
102753: PUSH
102754: LD_INT 21
102756: PUSH
102757: LD_INT 1
102759: PUSH
102760: EMPTY
102761: LIST
102762: LIST
102763: PUSH
102764: LD_INT 21
102766: PUSH
102767: LD_INT 2
102769: PUSH
102770: EMPTY
102771: LIST
102772: LIST
102773: PUSH
102774: EMPTY
102775: LIST
102776: LIST
102777: LIST
102778: PPUSH
102779: CALL_OW 69
102783: PUSH
102784: FOR_IN
102785: IFFALSE 102846
// if IsSelected ( i ) then
102787: LD_VAR 0 2
102791: PPUSH
102792: CALL_OW 306
102796: IFFALSE 102844
// begin if i in hInvincible then
102798: LD_VAR 0 2
102802: PUSH
102803: LD_EXP 170
102807: IN
102808: IFFALSE 102828
// hInvincible := hInvincible diff i else
102810: LD_ADDR_EXP 170
102814: PUSH
102815: LD_EXP 170
102819: PUSH
102820: LD_VAR 0 2
102824: DIFF
102825: ST_TO_ADDR
102826: GO 102844
// hInvincible := hInvincible union i ;
102828: LD_ADDR_EXP 170
102832: PUSH
102833: LD_EXP 170
102837: PUSH
102838: LD_VAR 0 2
102842: UNION
102843: ST_TO_ADDR
// end ;
102844: GO 102784
102846: POP
102847: POP
// end ;
102848: LD_VAR 0 1
102852: RET
// export function hHackInvisible ; var i , j ; begin
102853: LD_INT 0
102855: PPUSH
102856: PPUSH
102857: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102858: LD_ADDR_VAR 0 2
102862: PUSH
102863: LD_INT 21
102865: PUSH
102866: LD_INT 1
102868: PUSH
102869: EMPTY
102870: LIST
102871: LIST
102872: PPUSH
102873: CALL_OW 69
102877: PUSH
102878: FOR_IN
102879: IFFALSE 102903
// if IsSelected ( i ) then
102881: LD_VAR 0 2
102885: PPUSH
102886: CALL_OW 306
102890: IFFALSE 102901
// ComForceInvisible ( i ) ;
102892: LD_VAR 0 2
102896: PPUSH
102897: CALL_OW 496
102901: GO 102878
102903: POP
102904: POP
// end ;
102905: LD_VAR 0 1
102909: RET
// export function hHackChangeYourSide ; begin
102910: LD_INT 0
102912: PPUSH
// if your_side = 8 then
102913: LD_OWVAR 2
102917: PUSH
102918: LD_INT 8
102920: EQUAL
102921: IFFALSE 102933
// your_side := 0 else
102923: LD_ADDR_OWVAR 2
102927: PUSH
102928: LD_INT 0
102930: ST_TO_ADDR
102931: GO 102947
// your_side := your_side + 1 ;
102933: LD_ADDR_OWVAR 2
102937: PUSH
102938: LD_OWVAR 2
102942: PUSH
102943: LD_INT 1
102945: PLUS
102946: ST_TO_ADDR
// end ;
102947: LD_VAR 0 1
102951: RET
// export function hHackChangeUnitSide ; var i , j ; begin
102952: LD_INT 0
102954: PPUSH
102955: PPUSH
102956: PPUSH
// for i in all_units do
102957: LD_ADDR_VAR 0 2
102961: PUSH
102962: LD_OWVAR 3
102966: PUSH
102967: FOR_IN
102968: IFFALSE 103046
// if IsSelected ( i ) then
102970: LD_VAR 0 2
102974: PPUSH
102975: CALL_OW 306
102979: IFFALSE 103044
// begin j := GetSide ( i ) ;
102981: LD_ADDR_VAR 0 3
102985: PUSH
102986: LD_VAR 0 2
102990: PPUSH
102991: CALL_OW 255
102995: ST_TO_ADDR
// if j = 8 then
102996: LD_VAR 0 3
103000: PUSH
103001: LD_INT 8
103003: EQUAL
103004: IFFALSE 103016
// j := 0 else
103006: LD_ADDR_VAR 0 3
103010: PUSH
103011: LD_INT 0
103013: ST_TO_ADDR
103014: GO 103030
// j := j + 1 ;
103016: LD_ADDR_VAR 0 3
103020: PUSH
103021: LD_VAR 0 3
103025: PUSH
103026: LD_INT 1
103028: PLUS
103029: ST_TO_ADDR
// SetSide ( i , j ) ;
103030: LD_VAR 0 2
103034: PPUSH
103035: LD_VAR 0 3
103039: PPUSH
103040: CALL_OW 235
// end ;
103044: GO 102967
103046: POP
103047: POP
// end ;
103048: LD_VAR 0 1
103052: RET
// export function hHackFog ; begin
103053: LD_INT 0
103055: PPUSH
// FogOff ( true ) ;
103056: LD_INT 1
103058: PPUSH
103059: CALL_OW 344
// end ;
103063: LD_VAR 0 1
103067: RET
// export function hHackTeleport ( unit , x , y ) ; begin
103068: LD_INT 0
103070: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
103071: LD_VAR 0 1
103075: PPUSH
103076: LD_VAR 0 2
103080: PPUSH
103081: LD_VAR 0 3
103085: PPUSH
103086: LD_INT 1
103088: PPUSH
103089: LD_INT 1
103091: PPUSH
103092: CALL_OW 483
// CenterOnXY ( x , y ) ;
103096: LD_VAR 0 2
103100: PPUSH
103101: LD_VAR 0 3
103105: PPUSH
103106: CALL_OW 84
// end ; end_of_file
103110: LD_VAR 0 4
103114: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
103115: LD_INT 0
103117: PPUSH
103118: PPUSH
103119: PPUSH
103120: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
103121: LD_VAR 0 1
103125: PPUSH
103126: CALL_OW 264
103130: PUSH
103131: LD_EXP 98
103135: EQUAL
103136: IFFALSE 103208
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
103138: LD_INT 68
103140: PPUSH
103141: LD_VAR 0 1
103145: PPUSH
103146: CALL_OW 255
103150: PPUSH
103151: CALL_OW 321
103155: PUSH
103156: LD_INT 2
103158: EQUAL
103159: IFFALSE 103171
// eff := 70 else
103161: LD_ADDR_VAR 0 4
103165: PUSH
103166: LD_INT 70
103168: ST_TO_ADDR
103169: GO 103179
// eff := 30 ;
103171: LD_ADDR_VAR 0 4
103175: PUSH
103176: LD_INT 30
103178: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
103179: LD_VAR 0 1
103183: PPUSH
103184: CALL_OW 250
103188: PPUSH
103189: LD_VAR 0 1
103193: PPUSH
103194: CALL_OW 251
103198: PPUSH
103199: LD_VAR 0 4
103203: PPUSH
103204: CALL_OW 495
// end ; end ;
103208: LD_VAR 0 2
103212: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
103213: LD_INT 0
103215: PPUSH
// end ;
103216: LD_VAR 0 4
103220: RET
// export function SOS_Command ( cmd ) ; begin
103221: LD_INT 0
103223: PPUSH
// end ;
103224: LD_VAR 0 2
103228: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
103229: LD_INT 0
103231: PPUSH
// end ;
103232: LD_VAR 0 6
103236: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
103237: LD_INT 0
103239: PPUSH
103240: PPUSH
// if not vehicle or not factory then
103241: LD_VAR 0 1
103245: NOT
103246: PUSH
103247: LD_VAR 0 2
103251: NOT
103252: OR
103253: IFFALSE 103257
// exit ;
103255: GO 103488
// if factoryWaypoints >= factory then
103257: LD_EXP 171
103261: PUSH
103262: LD_VAR 0 2
103266: GREATEREQUAL
103267: IFFALSE 103488
// if factoryWaypoints [ factory ] then
103269: LD_EXP 171
103273: PUSH
103274: LD_VAR 0 2
103278: ARRAY
103279: IFFALSE 103488
// begin if GetControl ( vehicle ) = control_manual then
103281: LD_VAR 0 1
103285: PPUSH
103286: CALL_OW 263
103290: PUSH
103291: LD_INT 1
103293: EQUAL
103294: IFFALSE 103375
// begin driver := IsDrivenBy ( vehicle ) ;
103296: LD_ADDR_VAR 0 4
103300: PUSH
103301: LD_VAR 0 1
103305: PPUSH
103306: CALL_OW 311
103310: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103311: LD_VAR 0 4
103315: PPUSH
103316: LD_EXP 171
103320: PUSH
103321: LD_VAR 0 2
103325: ARRAY
103326: PUSH
103327: LD_INT 3
103329: ARRAY
103330: PPUSH
103331: LD_EXP 171
103335: PUSH
103336: LD_VAR 0 2
103340: ARRAY
103341: PUSH
103342: LD_INT 4
103344: ARRAY
103345: PPUSH
103346: CALL_OW 171
// AddComExitVehicle ( driver ) ;
103350: LD_VAR 0 4
103354: PPUSH
103355: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
103359: LD_VAR 0 4
103363: PPUSH
103364: LD_VAR 0 2
103368: PPUSH
103369: CALL_OW 180
// end else
103373: GO 103488
// if GetControl ( vehicle ) = control_remote then
103375: LD_VAR 0 1
103379: PPUSH
103380: CALL_OW 263
103384: PUSH
103385: LD_INT 2
103387: EQUAL
103388: IFFALSE 103449
// begin wait ( 0 0$2 ) ;
103390: LD_INT 70
103392: PPUSH
103393: CALL_OW 67
// if Connect ( vehicle ) then
103397: LD_VAR 0 1
103401: PPUSH
103402: CALL 56535 0 1
103406: IFFALSE 103447
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103408: LD_VAR 0 1
103412: PPUSH
103413: LD_EXP 171
103417: PUSH
103418: LD_VAR 0 2
103422: ARRAY
103423: PUSH
103424: LD_INT 3
103426: ARRAY
103427: PPUSH
103428: LD_EXP 171
103432: PUSH
103433: LD_VAR 0 2
103437: ARRAY
103438: PUSH
103439: LD_INT 4
103441: ARRAY
103442: PPUSH
103443: CALL_OW 171
// end else
103447: GO 103488
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103449: LD_VAR 0 1
103453: PPUSH
103454: LD_EXP 171
103458: PUSH
103459: LD_VAR 0 2
103463: ARRAY
103464: PUSH
103465: LD_INT 3
103467: ARRAY
103468: PPUSH
103469: LD_EXP 171
103473: PUSH
103474: LD_VAR 0 2
103478: ARRAY
103479: PUSH
103480: LD_INT 4
103482: ARRAY
103483: PPUSH
103484: CALL_OW 171
// end ; end ;
103488: LD_VAR 0 3
103492: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
103493: LD_INT 0
103495: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
103496: LD_VAR 0 1
103500: PUSH
103501: LD_INT 250
103503: EQUAL
103504: PUSH
103505: LD_VAR 0 2
103509: PPUSH
103510: CALL_OW 264
103514: PUSH
103515: LD_EXP 101
103519: EQUAL
103520: AND
103521: IFFALSE 103542
// MinerPlaceMine ( unit , x , y ) ;
103523: LD_VAR 0 2
103527: PPUSH
103528: LD_VAR 0 4
103532: PPUSH
103533: LD_VAR 0 5
103537: PPUSH
103538: CALL 106270 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
103542: LD_VAR 0 1
103546: PUSH
103547: LD_INT 251
103549: EQUAL
103550: PUSH
103551: LD_VAR 0 2
103555: PPUSH
103556: CALL_OW 264
103560: PUSH
103561: LD_EXP 101
103565: EQUAL
103566: AND
103567: IFFALSE 103588
// MinerDetonateMine ( unit , x , y ) ;
103569: LD_VAR 0 2
103573: PPUSH
103574: LD_VAR 0 4
103578: PPUSH
103579: LD_VAR 0 5
103583: PPUSH
103584: CALL 106547 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
103588: LD_VAR 0 1
103592: PUSH
103593: LD_INT 252
103595: EQUAL
103596: PUSH
103597: LD_VAR 0 2
103601: PPUSH
103602: CALL_OW 264
103606: PUSH
103607: LD_EXP 101
103611: EQUAL
103612: AND
103613: IFFALSE 103634
// MinerCreateMinefield ( unit , x , y ) ;
103615: LD_VAR 0 2
103619: PPUSH
103620: LD_VAR 0 4
103624: PPUSH
103625: LD_VAR 0 5
103629: PPUSH
103630: CALL 106964 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
103634: LD_VAR 0 1
103638: PUSH
103639: LD_INT 253
103641: EQUAL
103642: PUSH
103643: LD_VAR 0 2
103647: PPUSH
103648: CALL_OW 257
103652: PUSH
103653: LD_INT 5
103655: EQUAL
103656: AND
103657: IFFALSE 103678
// ComBinocular ( unit , x , y ) ;
103659: LD_VAR 0 2
103663: PPUSH
103664: LD_VAR 0 4
103668: PPUSH
103669: LD_VAR 0 5
103673: PPUSH
103674: CALL 107335 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
103678: LD_VAR 0 1
103682: PUSH
103683: LD_INT 254
103685: EQUAL
103686: PUSH
103687: LD_VAR 0 2
103691: PPUSH
103692: CALL_OW 264
103696: PUSH
103697: LD_EXP 96
103701: EQUAL
103702: AND
103703: PUSH
103704: LD_VAR 0 3
103708: PPUSH
103709: CALL_OW 263
103713: PUSH
103714: LD_INT 3
103716: EQUAL
103717: AND
103718: IFFALSE 103734
// HackDestroyVehicle ( unit , selectedUnit ) ;
103720: LD_VAR 0 2
103724: PPUSH
103725: LD_VAR 0 3
103729: PPUSH
103730: CALL 105630 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
103734: LD_VAR 0 1
103738: PUSH
103739: LD_INT 255
103741: EQUAL
103742: PUSH
103743: LD_VAR 0 2
103747: PPUSH
103748: CALL_OW 264
103752: PUSH
103753: LD_INT 14
103755: PUSH
103756: LD_INT 53
103758: PUSH
103759: EMPTY
103760: LIST
103761: LIST
103762: IN
103763: AND
103764: PUSH
103765: LD_VAR 0 4
103769: PPUSH
103770: LD_VAR 0 5
103774: PPUSH
103775: CALL_OW 488
103779: AND
103780: IFFALSE 103804
// CutTreeXYR ( unit , x , y , 12 ) ;
103782: LD_VAR 0 2
103786: PPUSH
103787: LD_VAR 0 4
103791: PPUSH
103792: LD_VAR 0 5
103796: PPUSH
103797: LD_INT 12
103799: PPUSH
103800: CALL 104196 0 4
// if cmd = 256 then
103804: LD_VAR 0 1
103808: PUSH
103809: LD_INT 256
103811: EQUAL
103812: IFFALSE 103833
// SetFactoryWaypoint ( unit , x , y ) ;
103814: LD_VAR 0 2
103818: PPUSH
103819: LD_VAR 0 4
103823: PPUSH
103824: LD_VAR 0 5
103828: PPUSH
103829: CALL 103838 0 3
// end ;
103833: LD_VAR 0 6
103837: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
103838: LD_INT 0
103840: PPUSH
103841: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
103842: LD_VAR 0 1
103846: NOT
103847: PUSH
103848: LD_VAR 0 2
103852: PPUSH
103853: LD_VAR 0 3
103857: PPUSH
103858: CALL_OW 488
103862: NOT
103863: OR
103864: PUSH
103865: LD_VAR 0 1
103869: PPUSH
103870: CALL_OW 266
103874: PUSH
103875: LD_INT 3
103877: NONEQUAL
103878: PUSH
103879: LD_VAR 0 1
103883: PPUSH
103884: CALL_OW 247
103888: PUSH
103889: LD_INT 1
103891: EQUAL
103892: NOT
103893: AND
103894: OR
103895: IFFALSE 103899
// exit ;
103897: GO 104048
// if GetType ( factory ) = unit_human then
103899: LD_VAR 0 1
103903: PPUSH
103904: CALL_OW 247
103908: PUSH
103909: LD_INT 1
103911: EQUAL
103912: IFFALSE 103929
// factory := IsInUnit ( factory ) ;
103914: LD_ADDR_VAR 0 1
103918: PUSH
103919: LD_VAR 0 1
103923: PPUSH
103924: CALL_OW 310
103928: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
103929: LD_VAR 0 1
103933: PPUSH
103934: CALL_OW 266
103938: PUSH
103939: LD_INT 3
103941: NONEQUAL
103942: IFFALSE 103946
// exit ;
103944: GO 104048
// if HexInfo ( x , y ) = factory then
103946: LD_VAR 0 2
103950: PPUSH
103951: LD_VAR 0 3
103955: PPUSH
103956: CALL_OW 428
103960: PUSH
103961: LD_VAR 0 1
103965: EQUAL
103966: IFFALSE 103993
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
103968: LD_ADDR_EXP 171
103972: PUSH
103973: LD_EXP 171
103977: PPUSH
103978: LD_VAR 0 1
103982: PPUSH
103983: LD_INT 0
103985: PPUSH
103986: CALL_OW 1
103990: ST_TO_ADDR
103991: GO 104044
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
103993: LD_ADDR_EXP 171
103997: PUSH
103998: LD_EXP 171
104002: PPUSH
104003: LD_VAR 0 1
104007: PPUSH
104008: LD_VAR 0 1
104012: PPUSH
104013: CALL_OW 255
104017: PUSH
104018: LD_VAR 0 1
104022: PUSH
104023: LD_VAR 0 2
104027: PUSH
104028: LD_VAR 0 3
104032: PUSH
104033: EMPTY
104034: LIST
104035: LIST
104036: LIST
104037: LIST
104038: PPUSH
104039: CALL_OW 1
104043: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104044: CALL 104053 0 0
// end ;
104048: LD_VAR 0 4
104052: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
104053: LD_INT 0
104055: PPUSH
104056: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104057: LD_STRING resetFactoryWaypoint();
104059: PPUSH
104060: CALL_OW 559
// if factoryWaypoints then
104064: LD_EXP 171
104068: IFFALSE 104191
// begin for i := 1 to factoryWaypoints do
104070: LD_ADDR_VAR 0 2
104074: PUSH
104075: DOUBLE
104076: LD_INT 1
104078: DEC
104079: ST_TO_ADDR
104080: LD_EXP 171
104084: PUSH
104085: FOR_TO
104086: IFFALSE 104189
// if factoryWaypoints [ i ] then
104088: LD_EXP 171
104092: PUSH
104093: LD_VAR 0 2
104097: ARRAY
104098: IFFALSE 104187
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
104100: LD_STRING setFactoryWaypointXY(
104102: PUSH
104103: LD_EXP 171
104107: PUSH
104108: LD_VAR 0 2
104112: ARRAY
104113: PUSH
104114: LD_INT 1
104116: ARRAY
104117: STR
104118: PUSH
104119: LD_STRING ,
104121: STR
104122: PUSH
104123: LD_EXP 171
104127: PUSH
104128: LD_VAR 0 2
104132: ARRAY
104133: PUSH
104134: LD_INT 2
104136: ARRAY
104137: STR
104138: PUSH
104139: LD_STRING ,
104141: STR
104142: PUSH
104143: LD_EXP 171
104147: PUSH
104148: LD_VAR 0 2
104152: ARRAY
104153: PUSH
104154: LD_INT 3
104156: ARRAY
104157: STR
104158: PUSH
104159: LD_STRING ,
104161: STR
104162: PUSH
104163: LD_EXP 171
104167: PUSH
104168: LD_VAR 0 2
104172: ARRAY
104173: PUSH
104174: LD_INT 4
104176: ARRAY
104177: STR
104178: PUSH
104179: LD_STRING )
104181: STR
104182: PPUSH
104183: CALL_OW 559
104187: GO 104085
104189: POP
104190: POP
// end ; end ;
104191: LD_VAR 0 1
104195: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
104196: LD_INT 0
104198: PPUSH
104199: PPUSH
104200: PPUSH
104201: PPUSH
104202: PPUSH
104203: PPUSH
104204: PPUSH
104205: PPUSH
104206: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
104207: LD_VAR 0 1
104211: NOT
104212: PUSH
104213: LD_VAR 0 2
104217: PPUSH
104218: LD_VAR 0 3
104222: PPUSH
104223: CALL_OW 488
104227: NOT
104228: OR
104229: PUSH
104230: LD_VAR 0 4
104234: NOT
104235: OR
104236: IFFALSE 104240
// exit ;
104238: GO 104580
// list := [ ] ;
104240: LD_ADDR_VAR 0 13
104244: PUSH
104245: EMPTY
104246: ST_TO_ADDR
// if x - r < 0 then
104247: LD_VAR 0 2
104251: PUSH
104252: LD_VAR 0 4
104256: MINUS
104257: PUSH
104258: LD_INT 0
104260: LESS
104261: IFFALSE 104273
// min_x := 0 else
104263: LD_ADDR_VAR 0 7
104267: PUSH
104268: LD_INT 0
104270: ST_TO_ADDR
104271: GO 104289
// min_x := x - r ;
104273: LD_ADDR_VAR 0 7
104277: PUSH
104278: LD_VAR 0 2
104282: PUSH
104283: LD_VAR 0 4
104287: MINUS
104288: ST_TO_ADDR
// if y - r < 0 then
104289: LD_VAR 0 3
104293: PUSH
104294: LD_VAR 0 4
104298: MINUS
104299: PUSH
104300: LD_INT 0
104302: LESS
104303: IFFALSE 104315
// min_y := 0 else
104305: LD_ADDR_VAR 0 8
104309: PUSH
104310: LD_INT 0
104312: ST_TO_ADDR
104313: GO 104331
// min_y := y - r ;
104315: LD_ADDR_VAR 0 8
104319: PUSH
104320: LD_VAR 0 3
104324: PUSH
104325: LD_VAR 0 4
104329: MINUS
104330: ST_TO_ADDR
// max_x := x + r ;
104331: LD_ADDR_VAR 0 9
104335: PUSH
104336: LD_VAR 0 2
104340: PUSH
104341: LD_VAR 0 4
104345: PLUS
104346: ST_TO_ADDR
// max_y := y + r ;
104347: LD_ADDR_VAR 0 10
104351: PUSH
104352: LD_VAR 0 3
104356: PUSH
104357: LD_VAR 0 4
104361: PLUS
104362: ST_TO_ADDR
// for _x = min_x to max_x do
104363: LD_ADDR_VAR 0 11
104367: PUSH
104368: DOUBLE
104369: LD_VAR 0 7
104373: DEC
104374: ST_TO_ADDR
104375: LD_VAR 0 9
104379: PUSH
104380: FOR_TO
104381: IFFALSE 104498
// for _y = min_y to max_y do
104383: LD_ADDR_VAR 0 12
104387: PUSH
104388: DOUBLE
104389: LD_VAR 0 8
104393: DEC
104394: ST_TO_ADDR
104395: LD_VAR 0 10
104399: PUSH
104400: FOR_TO
104401: IFFALSE 104494
// begin if not ValidHex ( _x , _y ) then
104403: LD_VAR 0 11
104407: PPUSH
104408: LD_VAR 0 12
104412: PPUSH
104413: CALL_OW 488
104417: NOT
104418: IFFALSE 104422
// continue ;
104420: GO 104400
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
104422: LD_VAR 0 11
104426: PPUSH
104427: LD_VAR 0 12
104431: PPUSH
104432: CALL_OW 351
104436: PUSH
104437: LD_VAR 0 11
104441: PPUSH
104442: LD_VAR 0 12
104446: PPUSH
104447: CALL_OW 554
104451: AND
104452: IFFALSE 104492
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
104454: LD_ADDR_VAR 0 13
104458: PUSH
104459: LD_VAR 0 13
104463: PPUSH
104464: LD_VAR 0 13
104468: PUSH
104469: LD_INT 1
104471: PLUS
104472: PPUSH
104473: LD_VAR 0 11
104477: PUSH
104478: LD_VAR 0 12
104482: PUSH
104483: EMPTY
104484: LIST
104485: LIST
104486: PPUSH
104487: CALL_OW 2
104491: ST_TO_ADDR
// end ;
104492: GO 104400
104494: POP
104495: POP
104496: GO 104380
104498: POP
104499: POP
// if not list then
104500: LD_VAR 0 13
104504: NOT
104505: IFFALSE 104509
// exit ;
104507: GO 104580
// for i in list do
104509: LD_ADDR_VAR 0 6
104513: PUSH
104514: LD_VAR 0 13
104518: PUSH
104519: FOR_IN
104520: IFFALSE 104578
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
104522: LD_VAR 0 1
104526: PPUSH
104527: LD_STRING M
104529: PUSH
104530: LD_VAR 0 6
104534: PUSH
104535: LD_INT 1
104537: ARRAY
104538: PUSH
104539: LD_VAR 0 6
104543: PUSH
104544: LD_INT 2
104546: ARRAY
104547: PUSH
104548: LD_INT 0
104550: PUSH
104551: LD_INT 0
104553: PUSH
104554: LD_INT 0
104556: PUSH
104557: LD_INT 0
104559: PUSH
104560: EMPTY
104561: LIST
104562: LIST
104563: LIST
104564: LIST
104565: LIST
104566: LIST
104567: LIST
104568: PUSH
104569: EMPTY
104570: LIST
104571: PPUSH
104572: CALL_OW 447
104576: GO 104519
104578: POP
104579: POP
// end ;
104580: LD_VAR 0 5
104584: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
104585: LD_EXP 172
104589: NOT
104590: IFFALSE 104640
104592: GO 104594
104594: DISABLE
// begin initHack := true ;
104595: LD_ADDR_EXP 172
104599: PUSH
104600: LD_INT 1
104602: ST_TO_ADDR
// hackTanks := [ ] ;
104603: LD_ADDR_EXP 173
104607: PUSH
104608: EMPTY
104609: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
104610: LD_ADDR_EXP 174
104614: PUSH
104615: EMPTY
104616: ST_TO_ADDR
// hackLimit := 3 ;
104617: LD_ADDR_EXP 175
104621: PUSH
104622: LD_INT 3
104624: ST_TO_ADDR
// hackDist := 12 ;
104625: LD_ADDR_EXP 176
104629: PUSH
104630: LD_INT 12
104632: ST_TO_ADDR
// hackCounter := [ ] ;
104633: LD_ADDR_EXP 177
104637: PUSH
104638: EMPTY
104639: ST_TO_ADDR
// end ;
104640: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
104641: LD_EXP 172
104645: PUSH
104646: LD_INT 34
104648: PUSH
104649: LD_EXP 96
104653: PUSH
104654: EMPTY
104655: LIST
104656: LIST
104657: PPUSH
104658: CALL_OW 69
104662: AND
104663: IFFALSE 104918
104665: GO 104667
104667: DISABLE
104668: LD_INT 0
104670: PPUSH
104671: PPUSH
// begin enable ;
104672: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
104673: LD_ADDR_VAR 0 1
104677: PUSH
104678: LD_INT 34
104680: PUSH
104681: LD_EXP 96
104685: PUSH
104686: EMPTY
104687: LIST
104688: LIST
104689: PPUSH
104690: CALL_OW 69
104694: PUSH
104695: FOR_IN
104696: IFFALSE 104916
// begin if not i in hackTanks then
104698: LD_VAR 0 1
104702: PUSH
104703: LD_EXP 173
104707: IN
104708: NOT
104709: IFFALSE 104792
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
104711: LD_ADDR_EXP 173
104715: PUSH
104716: LD_EXP 173
104720: PPUSH
104721: LD_EXP 173
104725: PUSH
104726: LD_INT 1
104728: PLUS
104729: PPUSH
104730: LD_VAR 0 1
104734: PPUSH
104735: CALL_OW 1
104739: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
104740: LD_ADDR_EXP 174
104744: PUSH
104745: LD_EXP 174
104749: PPUSH
104750: LD_EXP 174
104754: PUSH
104755: LD_INT 1
104757: PLUS
104758: PPUSH
104759: EMPTY
104760: PPUSH
104761: CALL_OW 1
104765: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
104766: LD_ADDR_EXP 177
104770: PUSH
104771: LD_EXP 177
104775: PPUSH
104776: LD_EXP 177
104780: PUSH
104781: LD_INT 1
104783: PLUS
104784: PPUSH
104785: EMPTY
104786: PPUSH
104787: CALL_OW 1
104791: ST_TO_ADDR
// end ; if not IsOk ( i ) then
104792: LD_VAR 0 1
104796: PPUSH
104797: CALL_OW 302
104801: NOT
104802: IFFALSE 104815
// begin HackUnlinkAll ( i ) ;
104804: LD_VAR 0 1
104808: PPUSH
104809: CALL 104921 0 1
// continue ;
104813: GO 104695
// end ; HackCheckCapturedStatus ( i ) ;
104815: LD_VAR 0 1
104819: PPUSH
104820: CALL 105364 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
104824: LD_ADDR_VAR 0 2
104828: PUSH
104829: LD_INT 81
104831: PUSH
104832: LD_VAR 0 1
104836: PPUSH
104837: CALL_OW 255
104841: PUSH
104842: EMPTY
104843: LIST
104844: LIST
104845: PUSH
104846: LD_INT 33
104848: PUSH
104849: LD_INT 3
104851: PUSH
104852: EMPTY
104853: LIST
104854: LIST
104855: PUSH
104856: LD_INT 91
104858: PUSH
104859: LD_VAR 0 1
104863: PUSH
104864: LD_EXP 176
104868: PUSH
104869: EMPTY
104870: LIST
104871: LIST
104872: LIST
104873: PUSH
104874: LD_INT 50
104876: PUSH
104877: EMPTY
104878: LIST
104879: PUSH
104880: EMPTY
104881: LIST
104882: LIST
104883: LIST
104884: LIST
104885: PPUSH
104886: CALL_OW 69
104890: ST_TO_ADDR
// if not tmp then
104891: LD_VAR 0 2
104895: NOT
104896: IFFALSE 104900
// continue ;
104898: GO 104695
// HackLink ( i , tmp ) ;
104900: LD_VAR 0 1
104904: PPUSH
104905: LD_VAR 0 2
104909: PPUSH
104910: CALL 105057 0 2
// end ;
104914: GO 104695
104916: POP
104917: POP
// end ;
104918: PPOPN 2
104920: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
104921: LD_INT 0
104923: PPUSH
104924: PPUSH
104925: PPUSH
// if not hack in hackTanks then
104926: LD_VAR 0 1
104930: PUSH
104931: LD_EXP 173
104935: IN
104936: NOT
104937: IFFALSE 104941
// exit ;
104939: GO 105052
// index := GetElementIndex ( hackTanks , hack ) ;
104941: LD_ADDR_VAR 0 4
104945: PUSH
104946: LD_EXP 173
104950: PPUSH
104951: LD_VAR 0 1
104955: PPUSH
104956: CALL 53349 0 2
104960: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
104961: LD_EXP 174
104965: PUSH
104966: LD_VAR 0 4
104970: ARRAY
104971: IFFALSE 105052
// begin for i in hackTanksCaptured [ index ] do
104973: LD_ADDR_VAR 0 3
104977: PUSH
104978: LD_EXP 174
104982: PUSH
104983: LD_VAR 0 4
104987: ARRAY
104988: PUSH
104989: FOR_IN
104990: IFFALSE 105016
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
104992: LD_VAR 0 3
104996: PUSH
104997: LD_INT 1
104999: ARRAY
105000: PPUSH
105001: LD_VAR 0 3
105005: PUSH
105006: LD_INT 2
105008: ARRAY
105009: PPUSH
105010: CALL_OW 235
105014: GO 104989
105016: POP
105017: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
105018: LD_ADDR_EXP 174
105022: PUSH
105023: LD_EXP 174
105027: PPUSH
105028: LD_VAR 0 4
105032: PPUSH
105033: EMPTY
105034: PPUSH
105035: CALL_OW 1
105039: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
105040: LD_VAR 0 1
105044: PPUSH
105045: LD_INT 0
105047: PPUSH
105048: CALL_OW 505
// end ; end ;
105052: LD_VAR 0 2
105056: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
105057: LD_INT 0
105059: PPUSH
105060: PPUSH
105061: PPUSH
// if not hack in hackTanks or not vehicles then
105062: LD_VAR 0 1
105066: PUSH
105067: LD_EXP 173
105071: IN
105072: NOT
105073: PUSH
105074: LD_VAR 0 2
105078: NOT
105079: OR
105080: IFFALSE 105084
// exit ;
105082: GO 105359
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
105084: LD_ADDR_VAR 0 2
105088: PUSH
105089: LD_VAR 0 1
105093: PPUSH
105094: LD_VAR 0 2
105098: PPUSH
105099: LD_INT 1
105101: PPUSH
105102: LD_INT 1
105104: PPUSH
105105: CALL 53999 0 4
105109: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
105110: LD_ADDR_VAR 0 5
105114: PUSH
105115: LD_EXP 173
105119: PPUSH
105120: LD_VAR 0 1
105124: PPUSH
105125: CALL 53349 0 2
105129: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
105130: LD_EXP 174
105134: PUSH
105135: LD_VAR 0 5
105139: ARRAY
105140: PUSH
105141: LD_EXP 175
105145: LESS
105146: IFFALSE 105335
// begin for i := 1 to vehicles do
105148: LD_ADDR_VAR 0 4
105152: PUSH
105153: DOUBLE
105154: LD_INT 1
105156: DEC
105157: ST_TO_ADDR
105158: LD_VAR 0 2
105162: PUSH
105163: FOR_TO
105164: IFFALSE 105333
// begin if hackTanksCaptured [ index ] = hackLimit then
105166: LD_EXP 174
105170: PUSH
105171: LD_VAR 0 5
105175: ARRAY
105176: PUSH
105177: LD_EXP 175
105181: EQUAL
105182: IFFALSE 105186
// break ;
105184: GO 105333
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
105186: LD_ADDR_EXP 177
105190: PUSH
105191: LD_EXP 177
105195: PPUSH
105196: LD_VAR 0 5
105200: PPUSH
105201: LD_EXP 177
105205: PUSH
105206: LD_VAR 0 5
105210: ARRAY
105211: PUSH
105212: LD_INT 1
105214: PLUS
105215: PPUSH
105216: CALL_OW 1
105220: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
105221: LD_ADDR_EXP 174
105225: PUSH
105226: LD_EXP 174
105230: PPUSH
105231: LD_VAR 0 5
105235: PUSH
105236: LD_EXP 174
105240: PUSH
105241: LD_VAR 0 5
105245: ARRAY
105246: PUSH
105247: LD_INT 1
105249: PLUS
105250: PUSH
105251: EMPTY
105252: LIST
105253: LIST
105254: PPUSH
105255: LD_VAR 0 2
105259: PUSH
105260: LD_VAR 0 4
105264: ARRAY
105265: PUSH
105266: LD_VAR 0 2
105270: PUSH
105271: LD_VAR 0 4
105275: ARRAY
105276: PPUSH
105277: CALL_OW 255
105281: PUSH
105282: EMPTY
105283: LIST
105284: LIST
105285: PPUSH
105286: CALL 53564 0 3
105290: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
105291: LD_VAR 0 2
105295: PUSH
105296: LD_VAR 0 4
105300: ARRAY
105301: PPUSH
105302: LD_VAR 0 1
105306: PPUSH
105307: CALL_OW 255
105311: PPUSH
105312: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
105316: LD_VAR 0 2
105320: PUSH
105321: LD_VAR 0 4
105325: ARRAY
105326: PPUSH
105327: CALL_OW 141
// end ;
105331: GO 105163
105333: POP
105334: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105335: LD_VAR 0 1
105339: PPUSH
105340: LD_EXP 174
105344: PUSH
105345: LD_VAR 0 5
105349: ARRAY
105350: PUSH
105351: LD_INT 0
105353: PLUS
105354: PPUSH
105355: CALL_OW 505
// end ;
105359: LD_VAR 0 3
105363: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
105364: LD_INT 0
105366: PPUSH
105367: PPUSH
105368: PPUSH
105369: PPUSH
// if not hack in hackTanks then
105370: LD_VAR 0 1
105374: PUSH
105375: LD_EXP 173
105379: IN
105380: NOT
105381: IFFALSE 105385
// exit ;
105383: GO 105625
// index := GetElementIndex ( hackTanks , hack ) ;
105385: LD_ADDR_VAR 0 4
105389: PUSH
105390: LD_EXP 173
105394: PPUSH
105395: LD_VAR 0 1
105399: PPUSH
105400: CALL 53349 0 2
105404: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
105405: LD_ADDR_VAR 0 3
105409: PUSH
105410: DOUBLE
105411: LD_EXP 174
105415: PUSH
105416: LD_VAR 0 4
105420: ARRAY
105421: INC
105422: ST_TO_ADDR
105423: LD_INT 1
105425: PUSH
105426: FOR_DOWNTO
105427: IFFALSE 105599
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
105429: LD_ADDR_VAR 0 5
105433: PUSH
105434: LD_EXP 174
105438: PUSH
105439: LD_VAR 0 4
105443: ARRAY
105444: PUSH
105445: LD_VAR 0 3
105449: ARRAY
105450: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
105451: LD_VAR 0 5
105455: PUSH
105456: LD_INT 1
105458: ARRAY
105459: PPUSH
105460: CALL_OW 302
105464: NOT
105465: PUSH
105466: LD_VAR 0 5
105470: PUSH
105471: LD_INT 1
105473: ARRAY
105474: PPUSH
105475: CALL_OW 255
105479: PUSH
105480: LD_VAR 0 1
105484: PPUSH
105485: CALL_OW 255
105489: NONEQUAL
105490: OR
105491: IFFALSE 105597
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
105493: LD_VAR 0 5
105497: PUSH
105498: LD_INT 1
105500: ARRAY
105501: PPUSH
105502: CALL_OW 305
105506: PUSH
105507: LD_VAR 0 5
105511: PUSH
105512: LD_INT 1
105514: ARRAY
105515: PPUSH
105516: CALL_OW 255
105520: PUSH
105521: LD_VAR 0 1
105525: PPUSH
105526: CALL_OW 255
105530: EQUAL
105531: AND
105532: IFFALSE 105556
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
105534: LD_VAR 0 5
105538: PUSH
105539: LD_INT 1
105541: ARRAY
105542: PPUSH
105543: LD_VAR 0 5
105547: PUSH
105548: LD_INT 2
105550: ARRAY
105551: PPUSH
105552: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
105556: LD_ADDR_EXP 174
105560: PUSH
105561: LD_EXP 174
105565: PPUSH
105566: LD_VAR 0 4
105570: PPUSH
105571: LD_EXP 174
105575: PUSH
105576: LD_VAR 0 4
105580: ARRAY
105581: PPUSH
105582: LD_VAR 0 3
105586: PPUSH
105587: CALL_OW 3
105591: PPUSH
105592: CALL_OW 1
105596: ST_TO_ADDR
// end ; end ;
105597: GO 105426
105599: POP
105600: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105601: LD_VAR 0 1
105605: PPUSH
105606: LD_EXP 174
105610: PUSH
105611: LD_VAR 0 4
105615: ARRAY
105616: PUSH
105617: LD_INT 0
105619: PLUS
105620: PPUSH
105621: CALL_OW 505
// end ;
105625: LD_VAR 0 2
105629: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
105630: LD_INT 0
105632: PPUSH
105633: PPUSH
105634: PPUSH
105635: PPUSH
// if not hack in hackTanks then
105636: LD_VAR 0 1
105640: PUSH
105641: LD_EXP 173
105645: IN
105646: NOT
105647: IFFALSE 105651
// exit ;
105649: GO 105736
// index := GetElementIndex ( hackTanks , hack ) ;
105651: LD_ADDR_VAR 0 5
105655: PUSH
105656: LD_EXP 173
105660: PPUSH
105661: LD_VAR 0 1
105665: PPUSH
105666: CALL 53349 0 2
105670: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
105671: LD_ADDR_VAR 0 4
105675: PUSH
105676: DOUBLE
105677: LD_INT 1
105679: DEC
105680: ST_TO_ADDR
105681: LD_EXP 174
105685: PUSH
105686: LD_VAR 0 5
105690: ARRAY
105691: PUSH
105692: FOR_TO
105693: IFFALSE 105734
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
105695: LD_EXP 174
105699: PUSH
105700: LD_VAR 0 5
105704: ARRAY
105705: PUSH
105706: LD_VAR 0 4
105710: ARRAY
105711: PUSH
105712: LD_INT 1
105714: ARRAY
105715: PUSH
105716: LD_VAR 0 2
105720: EQUAL
105721: IFFALSE 105732
// KillUnit ( vehicle ) ;
105723: LD_VAR 0 2
105727: PPUSH
105728: CALL_OW 66
105732: GO 105692
105734: POP
105735: POP
// end ;
105736: LD_VAR 0 3
105740: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
105741: LD_EXP 178
105745: NOT
105746: IFFALSE 105781
105748: GO 105750
105750: DISABLE
// begin initMiner := true ;
105751: LD_ADDR_EXP 178
105755: PUSH
105756: LD_INT 1
105758: ST_TO_ADDR
// minersList := [ ] ;
105759: LD_ADDR_EXP 179
105763: PUSH
105764: EMPTY
105765: ST_TO_ADDR
// minerMinesList := [ ] ;
105766: LD_ADDR_EXP 180
105770: PUSH
105771: EMPTY
105772: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
105773: LD_ADDR_EXP 181
105777: PUSH
105778: LD_INT 5
105780: ST_TO_ADDR
// end ;
105781: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
105782: LD_EXP 178
105786: PUSH
105787: LD_INT 34
105789: PUSH
105790: LD_EXP 101
105794: PUSH
105795: EMPTY
105796: LIST
105797: LIST
105798: PPUSH
105799: CALL_OW 69
105803: AND
105804: IFFALSE 106267
105806: GO 105808
105808: DISABLE
105809: LD_INT 0
105811: PPUSH
105812: PPUSH
105813: PPUSH
105814: PPUSH
// begin enable ;
105815: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
105816: LD_ADDR_VAR 0 1
105820: PUSH
105821: LD_INT 34
105823: PUSH
105824: LD_EXP 101
105828: PUSH
105829: EMPTY
105830: LIST
105831: LIST
105832: PPUSH
105833: CALL_OW 69
105837: PUSH
105838: FOR_IN
105839: IFFALSE 105911
// begin if not i in minersList then
105841: LD_VAR 0 1
105845: PUSH
105846: LD_EXP 179
105850: IN
105851: NOT
105852: IFFALSE 105909
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
105854: LD_ADDR_EXP 179
105858: PUSH
105859: LD_EXP 179
105863: PPUSH
105864: LD_EXP 179
105868: PUSH
105869: LD_INT 1
105871: PLUS
105872: PPUSH
105873: LD_VAR 0 1
105877: PPUSH
105878: CALL_OW 1
105882: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
105883: LD_ADDR_EXP 180
105887: PUSH
105888: LD_EXP 180
105892: PPUSH
105893: LD_EXP 180
105897: PUSH
105898: LD_INT 1
105900: PLUS
105901: PPUSH
105902: EMPTY
105903: PPUSH
105904: CALL_OW 1
105908: ST_TO_ADDR
// end end ;
105909: GO 105838
105911: POP
105912: POP
// for i := minerMinesList downto 1 do
105913: LD_ADDR_VAR 0 1
105917: PUSH
105918: DOUBLE
105919: LD_EXP 180
105923: INC
105924: ST_TO_ADDR
105925: LD_INT 1
105927: PUSH
105928: FOR_DOWNTO
105929: IFFALSE 106265
// begin if IsLive ( minersList [ i ] ) then
105931: LD_EXP 179
105935: PUSH
105936: LD_VAR 0 1
105940: ARRAY
105941: PPUSH
105942: CALL_OW 300
105946: IFFALSE 105974
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
105948: LD_EXP 179
105952: PUSH
105953: LD_VAR 0 1
105957: ARRAY
105958: PPUSH
105959: LD_EXP 180
105963: PUSH
105964: LD_VAR 0 1
105968: ARRAY
105969: PPUSH
105970: CALL_OW 505
// if not minerMinesList [ i ] then
105974: LD_EXP 180
105978: PUSH
105979: LD_VAR 0 1
105983: ARRAY
105984: NOT
105985: IFFALSE 105989
// continue ;
105987: GO 105928
// for j := minerMinesList [ i ] downto 1 do
105989: LD_ADDR_VAR 0 2
105993: PUSH
105994: DOUBLE
105995: LD_EXP 180
105999: PUSH
106000: LD_VAR 0 1
106004: ARRAY
106005: INC
106006: ST_TO_ADDR
106007: LD_INT 1
106009: PUSH
106010: FOR_DOWNTO
106011: IFFALSE 106261
// begin side := GetSide ( minersList [ i ] ) ;
106013: LD_ADDR_VAR 0 3
106017: PUSH
106018: LD_EXP 179
106022: PUSH
106023: LD_VAR 0 1
106027: ARRAY
106028: PPUSH
106029: CALL_OW 255
106033: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
106034: LD_ADDR_VAR 0 4
106038: PUSH
106039: LD_EXP 180
106043: PUSH
106044: LD_VAR 0 1
106048: ARRAY
106049: PUSH
106050: LD_VAR 0 2
106054: ARRAY
106055: PUSH
106056: LD_INT 1
106058: ARRAY
106059: PPUSH
106060: LD_EXP 180
106064: PUSH
106065: LD_VAR 0 1
106069: ARRAY
106070: PUSH
106071: LD_VAR 0 2
106075: ARRAY
106076: PUSH
106077: LD_INT 2
106079: ARRAY
106080: PPUSH
106081: CALL_OW 428
106085: ST_TO_ADDR
// if not tmp then
106086: LD_VAR 0 4
106090: NOT
106091: IFFALSE 106095
// continue ;
106093: GO 106010
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
106095: LD_VAR 0 4
106099: PUSH
106100: LD_INT 81
106102: PUSH
106103: LD_VAR 0 3
106107: PUSH
106108: EMPTY
106109: LIST
106110: LIST
106111: PPUSH
106112: CALL_OW 69
106116: IN
106117: PUSH
106118: LD_EXP 180
106122: PUSH
106123: LD_VAR 0 1
106127: ARRAY
106128: PUSH
106129: LD_VAR 0 2
106133: ARRAY
106134: PUSH
106135: LD_INT 1
106137: ARRAY
106138: PPUSH
106139: LD_EXP 180
106143: PUSH
106144: LD_VAR 0 1
106148: ARRAY
106149: PUSH
106150: LD_VAR 0 2
106154: ARRAY
106155: PUSH
106156: LD_INT 2
106158: ARRAY
106159: PPUSH
106160: CALL_OW 458
106164: AND
106165: IFFALSE 106259
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
106167: LD_EXP 180
106171: PUSH
106172: LD_VAR 0 1
106176: ARRAY
106177: PUSH
106178: LD_VAR 0 2
106182: ARRAY
106183: PUSH
106184: LD_INT 1
106186: ARRAY
106187: PPUSH
106188: LD_EXP 180
106192: PUSH
106193: LD_VAR 0 1
106197: ARRAY
106198: PUSH
106199: LD_VAR 0 2
106203: ARRAY
106204: PUSH
106205: LD_INT 2
106207: ARRAY
106208: PPUSH
106209: LD_VAR 0 3
106213: PPUSH
106214: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
106218: LD_ADDR_EXP 180
106222: PUSH
106223: LD_EXP 180
106227: PPUSH
106228: LD_VAR 0 1
106232: PPUSH
106233: LD_EXP 180
106237: PUSH
106238: LD_VAR 0 1
106242: ARRAY
106243: PPUSH
106244: LD_VAR 0 2
106248: PPUSH
106249: CALL_OW 3
106253: PPUSH
106254: CALL_OW 1
106258: ST_TO_ADDR
// end ; end ;
106259: GO 106010
106261: POP
106262: POP
// end ;
106263: GO 105928
106265: POP
106266: POP
// end ;
106267: PPOPN 4
106269: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
106270: LD_INT 0
106272: PPUSH
106273: PPUSH
// result := false ;
106274: LD_ADDR_VAR 0 4
106278: PUSH
106279: LD_INT 0
106281: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
106282: LD_VAR 0 1
106286: PPUSH
106287: CALL_OW 264
106291: PUSH
106292: LD_EXP 101
106296: EQUAL
106297: NOT
106298: IFFALSE 106302
// exit ;
106300: GO 106542
// index := GetElementIndex ( minersList , unit ) ;
106302: LD_ADDR_VAR 0 5
106306: PUSH
106307: LD_EXP 179
106311: PPUSH
106312: LD_VAR 0 1
106316: PPUSH
106317: CALL 53349 0 2
106321: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
106322: LD_EXP 180
106326: PUSH
106327: LD_VAR 0 5
106331: ARRAY
106332: PUSH
106333: LD_EXP 181
106337: GREATEREQUAL
106338: IFFALSE 106342
// exit ;
106340: GO 106542
// ComMoveXY ( unit , x , y ) ;
106342: LD_VAR 0 1
106346: PPUSH
106347: LD_VAR 0 2
106351: PPUSH
106352: LD_VAR 0 3
106356: PPUSH
106357: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106361: LD_INT 35
106363: PPUSH
106364: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
106368: LD_VAR 0 1
106372: PPUSH
106373: LD_VAR 0 2
106377: PPUSH
106378: LD_VAR 0 3
106382: PPUSH
106383: CALL 84068 0 3
106387: NOT
106388: PUSH
106389: LD_VAR 0 1
106393: PPUSH
106394: CALL_OW 314
106398: AND
106399: IFFALSE 106403
// exit ;
106401: GO 106542
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
106403: LD_VAR 0 2
106407: PPUSH
106408: LD_VAR 0 3
106412: PPUSH
106413: CALL_OW 428
106417: PUSH
106418: LD_VAR 0 1
106422: EQUAL
106423: PUSH
106424: LD_VAR 0 1
106428: PPUSH
106429: CALL_OW 314
106433: NOT
106434: AND
106435: IFFALSE 106361
// PlaySoundXY ( x , y , PlantMine ) ;
106437: LD_VAR 0 2
106441: PPUSH
106442: LD_VAR 0 3
106446: PPUSH
106447: LD_STRING PlantMine
106449: PPUSH
106450: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
106454: LD_VAR 0 2
106458: PPUSH
106459: LD_VAR 0 3
106463: PPUSH
106464: LD_VAR 0 1
106468: PPUSH
106469: CALL_OW 255
106473: PPUSH
106474: LD_INT 0
106476: PPUSH
106477: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
106481: LD_ADDR_EXP 180
106485: PUSH
106486: LD_EXP 180
106490: PPUSH
106491: LD_VAR 0 5
106495: PUSH
106496: LD_EXP 180
106500: PUSH
106501: LD_VAR 0 5
106505: ARRAY
106506: PUSH
106507: LD_INT 1
106509: PLUS
106510: PUSH
106511: EMPTY
106512: LIST
106513: LIST
106514: PPUSH
106515: LD_VAR 0 2
106519: PUSH
106520: LD_VAR 0 3
106524: PUSH
106525: EMPTY
106526: LIST
106527: LIST
106528: PPUSH
106529: CALL 53564 0 3
106533: ST_TO_ADDR
// result := true ;
106534: LD_ADDR_VAR 0 4
106538: PUSH
106539: LD_INT 1
106541: ST_TO_ADDR
// end ;
106542: LD_VAR 0 4
106546: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
106547: LD_INT 0
106549: PPUSH
106550: PPUSH
106551: PPUSH
// if not unit in minersList then
106552: LD_VAR 0 1
106556: PUSH
106557: LD_EXP 179
106561: IN
106562: NOT
106563: IFFALSE 106567
// exit ;
106565: GO 106959
// index := GetElementIndex ( minersList , unit ) ;
106567: LD_ADDR_VAR 0 6
106571: PUSH
106572: LD_EXP 179
106576: PPUSH
106577: LD_VAR 0 1
106581: PPUSH
106582: CALL 53349 0 2
106586: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
106587: LD_ADDR_VAR 0 5
106591: PUSH
106592: DOUBLE
106593: LD_EXP 180
106597: PUSH
106598: LD_VAR 0 6
106602: ARRAY
106603: INC
106604: ST_TO_ADDR
106605: LD_INT 1
106607: PUSH
106608: FOR_DOWNTO
106609: IFFALSE 106770
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
106611: LD_EXP 180
106615: PUSH
106616: LD_VAR 0 6
106620: ARRAY
106621: PUSH
106622: LD_VAR 0 5
106626: ARRAY
106627: PUSH
106628: LD_INT 1
106630: ARRAY
106631: PUSH
106632: LD_VAR 0 2
106636: EQUAL
106637: PUSH
106638: LD_EXP 180
106642: PUSH
106643: LD_VAR 0 6
106647: ARRAY
106648: PUSH
106649: LD_VAR 0 5
106653: ARRAY
106654: PUSH
106655: LD_INT 2
106657: ARRAY
106658: PUSH
106659: LD_VAR 0 3
106663: EQUAL
106664: AND
106665: IFFALSE 106768
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106667: LD_EXP 180
106671: PUSH
106672: LD_VAR 0 6
106676: ARRAY
106677: PUSH
106678: LD_VAR 0 5
106682: ARRAY
106683: PUSH
106684: LD_INT 1
106686: ARRAY
106687: PPUSH
106688: LD_EXP 180
106692: PUSH
106693: LD_VAR 0 6
106697: ARRAY
106698: PUSH
106699: LD_VAR 0 5
106703: ARRAY
106704: PUSH
106705: LD_INT 2
106707: ARRAY
106708: PPUSH
106709: LD_VAR 0 1
106713: PPUSH
106714: CALL_OW 255
106718: PPUSH
106719: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106723: LD_ADDR_EXP 180
106727: PUSH
106728: LD_EXP 180
106732: PPUSH
106733: LD_VAR 0 6
106737: PPUSH
106738: LD_EXP 180
106742: PUSH
106743: LD_VAR 0 6
106747: ARRAY
106748: PPUSH
106749: LD_VAR 0 5
106753: PPUSH
106754: CALL_OW 3
106758: PPUSH
106759: CALL_OW 1
106763: ST_TO_ADDR
// exit ;
106764: POP
106765: POP
106766: GO 106959
// end ; end ;
106768: GO 106608
106770: POP
106771: POP
// for i := minerMinesList [ index ] downto 1 do
106772: LD_ADDR_VAR 0 5
106776: PUSH
106777: DOUBLE
106778: LD_EXP 180
106782: PUSH
106783: LD_VAR 0 6
106787: ARRAY
106788: INC
106789: ST_TO_ADDR
106790: LD_INT 1
106792: PUSH
106793: FOR_DOWNTO
106794: IFFALSE 106957
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
106796: LD_EXP 180
106800: PUSH
106801: LD_VAR 0 6
106805: ARRAY
106806: PUSH
106807: LD_VAR 0 5
106811: ARRAY
106812: PUSH
106813: LD_INT 1
106815: ARRAY
106816: PPUSH
106817: LD_EXP 180
106821: PUSH
106822: LD_VAR 0 6
106826: ARRAY
106827: PUSH
106828: LD_VAR 0 5
106832: ARRAY
106833: PUSH
106834: LD_INT 2
106836: ARRAY
106837: PPUSH
106838: LD_VAR 0 2
106842: PPUSH
106843: LD_VAR 0 3
106847: PPUSH
106848: CALL_OW 298
106852: PUSH
106853: LD_INT 6
106855: LESS
106856: IFFALSE 106955
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106858: LD_EXP 180
106862: PUSH
106863: LD_VAR 0 6
106867: ARRAY
106868: PUSH
106869: LD_VAR 0 5
106873: ARRAY
106874: PUSH
106875: LD_INT 1
106877: ARRAY
106878: PPUSH
106879: LD_EXP 180
106883: PUSH
106884: LD_VAR 0 6
106888: ARRAY
106889: PUSH
106890: LD_VAR 0 5
106894: ARRAY
106895: PUSH
106896: LD_INT 2
106898: ARRAY
106899: PPUSH
106900: LD_VAR 0 1
106904: PPUSH
106905: CALL_OW 255
106909: PPUSH
106910: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106914: LD_ADDR_EXP 180
106918: PUSH
106919: LD_EXP 180
106923: PPUSH
106924: LD_VAR 0 6
106928: PPUSH
106929: LD_EXP 180
106933: PUSH
106934: LD_VAR 0 6
106938: ARRAY
106939: PPUSH
106940: LD_VAR 0 5
106944: PPUSH
106945: CALL_OW 3
106949: PPUSH
106950: CALL_OW 1
106954: ST_TO_ADDR
// end ; end ;
106955: GO 106793
106957: POP
106958: POP
// end ;
106959: LD_VAR 0 4
106963: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
106964: LD_INT 0
106966: PPUSH
106967: PPUSH
106968: PPUSH
106969: PPUSH
106970: PPUSH
106971: PPUSH
106972: PPUSH
106973: PPUSH
106974: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
106975: LD_VAR 0 1
106979: PPUSH
106980: CALL_OW 264
106984: PUSH
106985: LD_EXP 101
106989: EQUAL
106990: NOT
106991: PUSH
106992: LD_VAR 0 1
106996: PUSH
106997: LD_EXP 179
107001: IN
107002: NOT
107003: OR
107004: IFFALSE 107008
// exit ;
107006: GO 107330
// index := GetElementIndex ( minersList , unit ) ;
107008: LD_ADDR_VAR 0 6
107012: PUSH
107013: LD_EXP 179
107017: PPUSH
107018: LD_VAR 0 1
107022: PPUSH
107023: CALL 53349 0 2
107027: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
107028: LD_ADDR_VAR 0 8
107032: PUSH
107033: LD_EXP 181
107037: PUSH
107038: LD_EXP 180
107042: PUSH
107043: LD_VAR 0 6
107047: ARRAY
107048: MINUS
107049: ST_TO_ADDR
// if not minesFreeAmount then
107050: LD_VAR 0 8
107054: NOT
107055: IFFALSE 107059
// exit ;
107057: GO 107330
// tmp := [ ] ;
107059: LD_ADDR_VAR 0 7
107063: PUSH
107064: EMPTY
107065: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
107066: LD_ADDR_VAR 0 5
107070: PUSH
107071: DOUBLE
107072: LD_INT 1
107074: DEC
107075: ST_TO_ADDR
107076: LD_VAR 0 8
107080: PUSH
107081: FOR_TO
107082: IFFALSE 107277
// begin _d := rand ( 0 , 5 ) ;
107084: LD_ADDR_VAR 0 11
107088: PUSH
107089: LD_INT 0
107091: PPUSH
107092: LD_INT 5
107094: PPUSH
107095: CALL_OW 12
107099: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
107100: LD_ADDR_VAR 0 12
107104: PUSH
107105: LD_INT 2
107107: PPUSH
107108: LD_INT 6
107110: PPUSH
107111: CALL_OW 12
107115: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
107116: LD_ADDR_VAR 0 9
107120: PUSH
107121: LD_VAR 0 2
107125: PPUSH
107126: LD_VAR 0 11
107130: PPUSH
107131: LD_VAR 0 12
107135: PPUSH
107136: CALL_OW 272
107140: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
107141: LD_ADDR_VAR 0 10
107145: PUSH
107146: LD_VAR 0 3
107150: PPUSH
107151: LD_VAR 0 11
107155: PPUSH
107156: LD_VAR 0 12
107160: PPUSH
107161: CALL_OW 273
107165: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
107166: LD_VAR 0 9
107170: PPUSH
107171: LD_VAR 0 10
107175: PPUSH
107176: CALL_OW 488
107180: PUSH
107181: LD_VAR 0 9
107185: PUSH
107186: LD_VAR 0 10
107190: PUSH
107191: EMPTY
107192: LIST
107193: LIST
107194: PUSH
107195: LD_VAR 0 7
107199: IN
107200: NOT
107201: AND
107202: PUSH
107203: LD_VAR 0 9
107207: PPUSH
107208: LD_VAR 0 10
107212: PPUSH
107213: CALL_OW 458
107217: NOT
107218: AND
107219: IFFALSE 107261
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
107221: LD_ADDR_VAR 0 7
107225: PUSH
107226: LD_VAR 0 7
107230: PPUSH
107231: LD_VAR 0 7
107235: PUSH
107236: LD_INT 1
107238: PLUS
107239: PPUSH
107240: LD_VAR 0 9
107244: PUSH
107245: LD_VAR 0 10
107249: PUSH
107250: EMPTY
107251: LIST
107252: LIST
107253: PPUSH
107254: CALL_OW 1
107258: ST_TO_ADDR
107259: GO 107275
// i := i - 1 ;
107261: LD_ADDR_VAR 0 5
107265: PUSH
107266: LD_VAR 0 5
107270: PUSH
107271: LD_INT 1
107273: MINUS
107274: ST_TO_ADDR
// end ;
107275: GO 107081
107277: POP
107278: POP
// for i in tmp do
107279: LD_ADDR_VAR 0 5
107283: PUSH
107284: LD_VAR 0 7
107288: PUSH
107289: FOR_IN
107290: IFFALSE 107328
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
107292: LD_VAR 0 1
107296: PPUSH
107297: LD_VAR 0 5
107301: PUSH
107302: LD_INT 1
107304: ARRAY
107305: PPUSH
107306: LD_VAR 0 5
107310: PUSH
107311: LD_INT 2
107313: ARRAY
107314: PPUSH
107315: CALL 106270 0 3
107319: NOT
107320: IFFALSE 107326
// exit ;
107322: POP
107323: POP
107324: GO 107330
107326: GO 107289
107328: POP
107329: POP
// end ;
107330: LD_VAR 0 4
107334: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
107335: LD_INT 0
107337: PPUSH
107338: PPUSH
107339: PPUSH
107340: PPUSH
107341: PPUSH
107342: PPUSH
107343: PPUSH
// if not GetClass ( unit ) = class_sniper then
107344: LD_VAR 0 1
107348: PPUSH
107349: CALL_OW 257
107353: PUSH
107354: LD_INT 5
107356: EQUAL
107357: NOT
107358: IFFALSE 107362
// exit ;
107360: GO 107750
// dist := 8 ;
107362: LD_ADDR_VAR 0 5
107366: PUSH
107367: LD_INT 8
107369: ST_TO_ADDR
// viewRange := 12 ;
107370: LD_ADDR_VAR 0 7
107374: PUSH
107375: LD_INT 12
107377: ST_TO_ADDR
// side := GetSide ( unit ) ;
107378: LD_ADDR_VAR 0 6
107382: PUSH
107383: LD_VAR 0 1
107387: PPUSH
107388: CALL_OW 255
107392: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
107393: LD_INT 61
107395: PPUSH
107396: LD_VAR 0 6
107400: PPUSH
107401: CALL_OW 321
107405: PUSH
107406: LD_INT 2
107408: EQUAL
107409: IFFALSE 107419
// viewRange := 16 ;
107411: LD_ADDR_VAR 0 7
107415: PUSH
107416: LD_INT 16
107418: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
107419: LD_VAR 0 1
107423: PPUSH
107424: LD_VAR 0 2
107428: PPUSH
107429: LD_VAR 0 3
107433: PPUSH
107434: CALL_OW 297
107438: PUSH
107439: LD_VAR 0 5
107443: GREATER
107444: IFFALSE 107523
// begin ComMoveXY ( unit , x , y ) ;
107446: LD_VAR 0 1
107450: PPUSH
107451: LD_VAR 0 2
107455: PPUSH
107456: LD_VAR 0 3
107460: PPUSH
107461: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
107465: LD_INT 35
107467: PPUSH
107468: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
107472: LD_VAR 0 1
107476: PPUSH
107477: LD_VAR 0 2
107481: PPUSH
107482: LD_VAR 0 3
107486: PPUSH
107487: CALL 84068 0 3
107491: NOT
107492: IFFALSE 107496
// exit ;
107494: GO 107750
// until GetDistUnitXY ( unit , x , y ) < dist ;
107496: LD_VAR 0 1
107500: PPUSH
107501: LD_VAR 0 2
107505: PPUSH
107506: LD_VAR 0 3
107510: PPUSH
107511: CALL_OW 297
107515: PUSH
107516: LD_VAR 0 5
107520: LESS
107521: IFFALSE 107465
// end ; ComTurnXY ( unit , x , y ) ;
107523: LD_VAR 0 1
107527: PPUSH
107528: LD_VAR 0 2
107532: PPUSH
107533: LD_VAR 0 3
107537: PPUSH
107538: CALL_OW 118
// wait ( 5 ) ;
107542: LD_INT 5
107544: PPUSH
107545: CALL_OW 67
// _d := GetDir ( unit ) ;
107549: LD_ADDR_VAR 0 10
107553: PUSH
107554: LD_VAR 0 1
107558: PPUSH
107559: CALL_OW 254
107563: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
107564: LD_ADDR_VAR 0 8
107568: PUSH
107569: LD_VAR 0 1
107573: PPUSH
107574: CALL_OW 250
107578: PPUSH
107579: LD_VAR 0 10
107583: PPUSH
107584: LD_VAR 0 5
107588: PPUSH
107589: CALL_OW 272
107593: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
107594: LD_ADDR_VAR 0 9
107598: PUSH
107599: LD_VAR 0 1
107603: PPUSH
107604: CALL_OW 251
107608: PPUSH
107609: LD_VAR 0 10
107613: PPUSH
107614: LD_VAR 0 5
107618: PPUSH
107619: CALL_OW 273
107623: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
107624: LD_VAR 0 8
107628: PPUSH
107629: LD_VAR 0 9
107633: PPUSH
107634: CALL_OW 488
107638: NOT
107639: IFFALSE 107643
// exit ;
107641: GO 107750
// ComAnimCustom ( unit , 1 ) ;
107643: LD_VAR 0 1
107647: PPUSH
107648: LD_INT 1
107650: PPUSH
107651: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
107655: LD_VAR 0 8
107659: PPUSH
107660: LD_VAR 0 9
107664: PPUSH
107665: LD_VAR 0 6
107669: PPUSH
107670: LD_VAR 0 7
107674: PPUSH
107675: CALL_OW 330
// repeat wait ( 1 ) ;
107679: LD_INT 1
107681: PPUSH
107682: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
107686: LD_VAR 0 1
107690: PPUSH
107691: CALL_OW 316
107695: PUSH
107696: LD_VAR 0 1
107700: PPUSH
107701: CALL_OW 314
107705: OR
107706: PUSH
107707: LD_VAR 0 1
107711: PPUSH
107712: CALL_OW 302
107716: NOT
107717: OR
107718: PUSH
107719: LD_VAR 0 1
107723: PPUSH
107724: CALL_OW 301
107728: OR
107729: IFFALSE 107679
// RemoveSeeing ( _x , _y , side ) ;
107731: LD_VAR 0 8
107735: PPUSH
107736: LD_VAR 0 9
107740: PPUSH
107741: LD_VAR 0 6
107745: PPUSH
107746: CALL_OW 331
// end ; end_of_file
107750: LD_VAR 0 4
107754: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
107755: LD_INT 0
107757: PPUSH
107758: PPUSH
107759: PPUSH
107760: PPUSH
107761: PPUSH
107762: PPUSH
107763: PPUSH
107764: PPUSH
107765: PPUSH
107766: PPUSH
107767: PPUSH
107768: PPUSH
107769: PPUSH
107770: PPUSH
107771: PPUSH
107772: PPUSH
107773: PPUSH
107774: PPUSH
107775: PPUSH
107776: PPUSH
107777: PPUSH
107778: PPUSH
107779: PPUSH
107780: PPUSH
107781: PPUSH
107782: PPUSH
107783: PPUSH
107784: PPUSH
107785: PPUSH
107786: PPUSH
107787: PPUSH
107788: PPUSH
107789: PPUSH
107790: PPUSH
// if not list then
107791: LD_VAR 0 1
107795: NOT
107796: IFFALSE 107800
// exit ;
107798: GO 112459
// base := list [ 1 ] ;
107800: LD_ADDR_VAR 0 3
107804: PUSH
107805: LD_VAR 0 1
107809: PUSH
107810: LD_INT 1
107812: ARRAY
107813: ST_TO_ADDR
// group := list [ 2 ] ;
107814: LD_ADDR_VAR 0 4
107818: PUSH
107819: LD_VAR 0 1
107823: PUSH
107824: LD_INT 2
107826: ARRAY
107827: ST_TO_ADDR
// path := list [ 3 ] ;
107828: LD_ADDR_VAR 0 5
107832: PUSH
107833: LD_VAR 0 1
107837: PUSH
107838: LD_INT 3
107840: ARRAY
107841: ST_TO_ADDR
// flags := list [ 4 ] ;
107842: LD_ADDR_VAR 0 6
107846: PUSH
107847: LD_VAR 0 1
107851: PUSH
107852: LD_INT 4
107854: ARRAY
107855: ST_TO_ADDR
// mined := [ ] ;
107856: LD_ADDR_VAR 0 27
107860: PUSH
107861: EMPTY
107862: ST_TO_ADDR
// bombed := [ ] ;
107863: LD_ADDR_VAR 0 28
107867: PUSH
107868: EMPTY
107869: ST_TO_ADDR
// healers := [ ] ;
107870: LD_ADDR_VAR 0 31
107874: PUSH
107875: EMPTY
107876: ST_TO_ADDR
// to_heal := [ ] ;
107877: LD_ADDR_VAR 0 30
107881: PUSH
107882: EMPTY
107883: ST_TO_ADDR
// repairs := [ ] ;
107884: LD_ADDR_VAR 0 33
107888: PUSH
107889: EMPTY
107890: ST_TO_ADDR
// to_repair := [ ] ;
107891: LD_ADDR_VAR 0 32
107895: PUSH
107896: EMPTY
107897: ST_TO_ADDR
// if not group or not path then
107898: LD_VAR 0 4
107902: NOT
107903: PUSH
107904: LD_VAR 0 5
107908: NOT
107909: OR
107910: IFFALSE 107914
// exit ;
107912: GO 112459
// side := GetSide ( group [ 1 ] ) ;
107914: LD_ADDR_VAR 0 35
107918: PUSH
107919: LD_VAR 0 4
107923: PUSH
107924: LD_INT 1
107926: ARRAY
107927: PPUSH
107928: CALL_OW 255
107932: ST_TO_ADDR
// if flags then
107933: LD_VAR 0 6
107937: IFFALSE 108081
// begin f_ignore_area := flags [ 1 ] ;
107939: LD_ADDR_VAR 0 17
107943: PUSH
107944: LD_VAR 0 6
107948: PUSH
107949: LD_INT 1
107951: ARRAY
107952: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
107953: LD_ADDR_VAR 0 18
107957: PUSH
107958: LD_VAR 0 6
107962: PUSH
107963: LD_INT 2
107965: ARRAY
107966: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
107967: LD_ADDR_VAR 0 19
107971: PUSH
107972: LD_VAR 0 6
107976: PUSH
107977: LD_INT 3
107979: ARRAY
107980: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
107981: LD_ADDR_VAR 0 20
107985: PUSH
107986: LD_VAR 0 6
107990: PUSH
107991: LD_INT 4
107993: ARRAY
107994: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
107995: LD_ADDR_VAR 0 21
107999: PUSH
108000: LD_VAR 0 6
108004: PUSH
108005: LD_INT 5
108007: ARRAY
108008: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
108009: LD_ADDR_VAR 0 22
108013: PUSH
108014: LD_VAR 0 6
108018: PUSH
108019: LD_INT 6
108021: ARRAY
108022: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
108023: LD_ADDR_VAR 0 23
108027: PUSH
108028: LD_VAR 0 6
108032: PUSH
108033: LD_INT 7
108035: ARRAY
108036: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
108037: LD_ADDR_VAR 0 24
108041: PUSH
108042: LD_VAR 0 6
108046: PUSH
108047: LD_INT 8
108049: ARRAY
108050: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
108051: LD_ADDR_VAR 0 25
108055: PUSH
108056: LD_VAR 0 6
108060: PUSH
108061: LD_INT 9
108063: ARRAY
108064: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
108065: LD_ADDR_VAR 0 26
108069: PUSH
108070: LD_VAR 0 6
108074: PUSH
108075: LD_INT 10
108077: ARRAY
108078: ST_TO_ADDR
// end else
108079: GO 108161
// begin f_ignore_area := false ;
108081: LD_ADDR_VAR 0 17
108085: PUSH
108086: LD_INT 0
108088: ST_TO_ADDR
// f_capture := false ;
108089: LD_ADDR_VAR 0 18
108093: PUSH
108094: LD_INT 0
108096: ST_TO_ADDR
// f_ignore_civ := false ;
108097: LD_ADDR_VAR 0 19
108101: PUSH
108102: LD_INT 0
108104: ST_TO_ADDR
// f_murder := false ;
108105: LD_ADDR_VAR 0 20
108109: PUSH
108110: LD_INT 0
108112: ST_TO_ADDR
// f_mines := false ;
108113: LD_ADDR_VAR 0 21
108117: PUSH
108118: LD_INT 0
108120: ST_TO_ADDR
// f_repair := false ;
108121: LD_ADDR_VAR 0 22
108125: PUSH
108126: LD_INT 0
108128: ST_TO_ADDR
// f_heal := false ;
108129: LD_ADDR_VAR 0 23
108133: PUSH
108134: LD_INT 0
108136: ST_TO_ADDR
// f_spacetime := false ;
108137: LD_ADDR_VAR 0 24
108141: PUSH
108142: LD_INT 0
108144: ST_TO_ADDR
// f_attack_depot := false ;
108145: LD_ADDR_VAR 0 25
108149: PUSH
108150: LD_INT 0
108152: ST_TO_ADDR
// f_crawl := false ;
108153: LD_ADDR_VAR 0 26
108157: PUSH
108158: LD_INT 0
108160: ST_TO_ADDR
// end ; if f_heal then
108161: LD_VAR 0 23
108165: IFFALSE 108192
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
108167: LD_ADDR_VAR 0 31
108171: PUSH
108172: LD_VAR 0 4
108176: PPUSH
108177: LD_INT 25
108179: PUSH
108180: LD_INT 4
108182: PUSH
108183: EMPTY
108184: LIST
108185: LIST
108186: PPUSH
108187: CALL_OW 72
108191: ST_TO_ADDR
// if f_repair then
108192: LD_VAR 0 22
108196: IFFALSE 108223
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
108198: LD_ADDR_VAR 0 33
108202: PUSH
108203: LD_VAR 0 4
108207: PPUSH
108208: LD_INT 25
108210: PUSH
108211: LD_INT 3
108213: PUSH
108214: EMPTY
108215: LIST
108216: LIST
108217: PPUSH
108218: CALL_OW 72
108222: ST_TO_ADDR
// units_path := [ ] ;
108223: LD_ADDR_VAR 0 16
108227: PUSH
108228: EMPTY
108229: ST_TO_ADDR
// for i = 1 to group do
108230: LD_ADDR_VAR 0 7
108234: PUSH
108235: DOUBLE
108236: LD_INT 1
108238: DEC
108239: ST_TO_ADDR
108240: LD_VAR 0 4
108244: PUSH
108245: FOR_TO
108246: IFFALSE 108275
// units_path := Replace ( units_path , i , path ) ;
108248: LD_ADDR_VAR 0 16
108252: PUSH
108253: LD_VAR 0 16
108257: PPUSH
108258: LD_VAR 0 7
108262: PPUSH
108263: LD_VAR 0 5
108267: PPUSH
108268: CALL_OW 1
108272: ST_TO_ADDR
108273: GO 108245
108275: POP
108276: POP
// repeat for i = group downto 1 do
108277: LD_ADDR_VAR 0 7
108281: PUSH
108282: DOUBLE
108283: LD_VAR 0 4
108287: INC
108288: ST_TO_ADDR
108289: LD_INT 1
108291: PUSH
108292: FOR_DOWNTO
108293: IFFALSE 112415
// begin wait ( 5 ) ;
108295: LD_INT 5
108297: PPUSH
108298: CALL_OW 67
// tmp := [ ] ;
108302: LD_ADDR_VAR 0 14
108306: PUSH
108307: EMPTY
108308: ST_TO_ADDR
// attacking := false ;
108309: LD_ADDR_VAR 0 29
108313: PUSH
108314: LD_INT 0
108316: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
108317: LD_VAR 0 4
108321: PUSH
108322: LD_VAR 0 7
108326: ARRAY
108327: PPUSH
108328: CALL_OW 301
108332: PUSH
108333: LD_VAR 0 4
108337: PUSH
108338: LD_VAR 0 7
108342: ARRAY
108343: NOT
108344: OR
108345: IFFALSE 108454
// begin if GetType ( group [ i ] ) = unit_human then
108347: LD_VAR 0 4
108351: PUSH
108352: LD_VAR 0 7
108356: ARRAY
108357: PPUSH
108358: CALL_OW 247
108362: PUSH
108363: LD_INT 1
108365: EQUAL
108366: IFFALSE 108412
// begin to_heal := to_heal diff group [ i ] ;
108368: LD_ADDR_VAR 0 30
108372: PUSH
108373: LD_VAR 0 30
108377: PUSH
108378: LD_VAR 0 4
108382: PUSH
108383: LD_VAR 0 7
108387: ARRAY
108388: DIFF
108389: ST_TO_ADDR
// healers := healers diff group [ i ] ;
108390: LD_ADDR_VAR 0 31
108394: PUSH
108395: LD_VAR 0 31
108399: PUSH
108400: LD_VAR 0 4
108404: PUSH
108405: LD_VAR 0 7
108409: ARRAY
108410: DIFF
108411: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
108412: LD_ADDR_VAR 0 4
108416: PUSH
108417: LD_VAR 0 4
108421: PPUSH
108422: LD_VAR 0 7
108426: PPUSH
108427: CALL_OW 3
108431: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
108432: LD_ADDR_VAR 0 16
108436: PUSH
108437: LD_VAR 0 16
108441: PPUSH
108442: LD_VAR 0 7
108446: PPUSH
108447: CALL_OW 3
108451: ST_TO_ADDR
// continue ;
108452: GO 108292
// end ; if f_repair then
108454: LD_VAR 0 22
108458: IFFALSE 108947
// begin if GetType ( group [ i ] ) = unit_vehicle then
108460: LD_VAR 0 4
108464: PUSH
108465: LD_VAR 0 7
108469: ARRAY
108470: PPUSH
108471: CALL_OW 247
108475: PUSH
108476: LD_INT 2
108478: EQUAL
108479: IFFALSE 108669
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
108481: LD_VAR 0 4
108485: PUSH
108486: LD_VAR 0 7
108490: ARRAY
108491: PPUSH
108492: CALL_OW 256
108496: PUSH
108497: LD_INT 700
108499: LESS
108500: PUSH
108501: LD_VAR 0 4
108505: PUSH
108506: LD_VAR 0 7
108510: ARRAY
108511: PUSH
108512: LD_VAR 0 32
108516: IN
108517: NOT
108518: AND
108519: IFFALSE 108543
// to_repair := to_repair union group [ i ] ;
108521: LD_ADDR_VAR 0 32
108525: PUSH
108526: LD_VAR 0 32
108530: PUSH
108531: LD_VAR 0 4
108535: PUSH
108536: LD_VAR 0 7
108540: ARRAY
108541: UNION
108542: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
108543: LD_VAR 0 4
108547: PUSH
108548: LD_VAR 0 7
108552: ARRAY
108553: PPUSH
108554: CALL_OW 256
108558: PUSH
108559: LD_INT 1000
108561: EQUAL
108562: PUSH
108563: LD_VAR 0 4
108567: PUSH
108568: LD_VAR 0 7
108572: ARRAY
108573: PUSH
108574: LD_VAR 0 32
108578: IN
108579: AND
108580: IFFALSE 108604
// to_repair := to_repair diff group [ i ] ;
108582: LD_ADDR_VAR 0 32
108586: PUSH
108587: LD_VAR 0 32
108591: PUSH
108592: LD_VAR 0 4
108596: PUSH
108597: LD_VAR 0 7
108601: ARRAY
108602: DIFF
108603: ST_TO_ADDR
// if group [ i ] in to_repair then
108604: LD_VAR 0 4
108608: PUSH
108609: LD_VAR 0 7
108613: ARRAY
108614: PUSH
108615: LD_VAR 0 32
108619: IN
108620: IFFALSE 108667
// begin if not IsInArea ( group [ i ] , f_repair ) then
108622: LD_VAR 0 4
108626: PUSH
108627: LD_VAR 0 7
108631: ARRAY
108632: PPUSH
108633: LD_VAR 0 22
108637: PPUSH
108638: CALL_OW 308
108642: NOT
108643: IFFALSE 108665
// ComMoveToArea ( group [ i ] , f_repair ) ;
108645: LD_VAR 0 4
108649: PUSH
108650: LD_VAR 0 7
108654: ARRAY
108655: PPUSH
108656: LD_VAR 0 22
108660: PPUSH
108661: CALL_OW 113
// continue ;
108665: GO 108292
// end ; end else
108667: GO 108947
// if group [ i ] in repairs then
108669: LD_VAR 0 4
108673: PUSH
108674: LD_VAR 0 7
108678: ARRAY
108679: PUSH
108680: LD_VAR 0 33
108684: IN
108685: IFFALSE 108947
// begin if IsInUnit ( group [ i ] ) then
108687: LD_VAR 0 4
108691: PUSH
108692: LD_VAR 0 7
108696: ARRAY
108697: PPUSH
108698: CALL_OW 310
108702: IFFALSE 108770
// begin z := IsInUnit ( group [ i ] ) ;
108704: LD_ADDR_VAR 0 13
108708: PUSH
108709: LD_VAR 0 4
108713: PUSH
108714: LD_VAR 0 7
108718: ARRAY
108719: PPUSH
108720: CALL_OW 310
108724: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
108725: LD_VAR 0 13
108729: PUSH
108730: LD_VAR 0 32
108734: IN
108735: PUSH
108736: LD_VAR 0 13
108740: PPUSH
108741: LD_VAR 0 22
108745: PPUSH
108746: CALL_OW 308
108750: AND
108751: IFFALSE 108768
// ComExitVehicle ( group [ i ] ) ;
108753: LD_VAR 0 4
108757: PUSH
108758: LD_VAR 0 7
108762: ARRAY
108763: PPUSH
108764: CALL_OW 121
// end else
108768: GO 108947
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
108770: LD_ADDR_VAR 0 13
108774: PUSH
108775: LD_VAR 0 4
108779: PPUSH
108780: LD_INT 95
108782: PUSH
108783: LD_VAR 0 22
108787: PUSH
108788: EMPTY
108789: LIST
108790: LIST
108791: PUSH
108792: LD_INT 58
108794: PUSH
108795: EMPTY
108796: LIST
108797: PUSH
108798: EMPTY
108799: LIST
108800: LIST
108801: PPUSH
108802: CALL_OW 72
108806: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
108807: LD_VAR 0 4
108811: PUSH
108812: LD_VAR 0 7
108816: ARRAY
108817: PPUSH
108818: CALL_OW 314
108822: NOT
108823: IFFALSE 108945
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
108825: LD_ADDR_VAR 0 10
108829: PUSH
108830: LD_VAR 0 13
108834: PPUSH
108835: LD_VAR 0 4
108839: PUSH
108840: LD_VAR 0 7
108844: ARRAY
108845: PPUSH
108846: CALL_OW 74
108850: ST_TO_ADDR
// if not x then
108851: LD_VAR 0 10
108855: NOT
108856: IFFALSE 108860
// continue ;
108858: GO 108292
// if GetLives ( x ) < 1000 then
108860: LD_VAR 0 10
108864: PPUSH
108865: CALL_OW 256
108869: PUSH
108870: LD_INT 1000
108872: LESS
108873: IFFALSE 108897
// ComRepairVehicle ( group [ i ] , x ) else
108875: LD_VAR 0 4
108879: PUSH
108880: LD_VAR 0 7
108884: ARRAY
108885: PPUSH
108886: LD_VAR 0 10
108890: PPUSH
108891: CALL_OW 129
108895: GO 108945
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
108897: LD_VAR 0 23
108901: PUSH
108902: LD_VAR 0 4
108906: PUSH
108907: LD_VAR 0 7
108911: ARRAY
108912: PPUSH
108913: CALL_OW 256
108917: PUSH
108918: LD_INT 1000
108920: LESS
108921: AND
108922: NOT
108923: IFFALSE 108945
// ComEnterUnit ( group [ i ] , x ) ;
108925: LD_VAR 0 4
108929: PUSH
108930: LD_VAR 0 7
108934: ARRAY
108935: PPUSH
108936: LD_VAR 0 10
108940: PPUSH
108941: CALL_OW 120
// end ; continue ;
108945: GO 108292
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
108947: LD_VAR 0 23
108951: PUSH
108952: LD_VAR 0 4
108956: PUSH
108957: LD_VAR 0 7
108961: ARRAY
108962: PPUSH
108963: CALL_OW 247
108967: PUSH
108968: LD_INT 1
108970: EQUAL
108971: AND
108972: IFFALSE 109450
// begin if group [ i ] in healers then
108974: LD_VAR 0 4
108978: PUSH
108979: LD_VAR 0 7
108983: ARRAY
108984: PUSH
108985: LD_VAR 0 31
108989: IN
108990: IFFALSE 109263
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
108992: LD_VAR 0 4
108996: PUSH
108997: LD_VAR 0 7
109001: ARRAY
109002: PPUSH
109003: LD_VAR 0 23
109007: PPUSH
109008: CALL_OW 308
109012: NOT
109013: PUSH
109014: LD_VAR 0 4
109018: PUSH
109019: LD_VAR 0 7
109023: ARRAY
109024: PPUSH
109025: CALL_OW 314
109029: NOT
109030: AND
109031: IFFALSE 109055
// ComMoveToArea ( group [ i ] , f_heal ) else
109033: LD_VAR 0 4
109037: PUSH
109038: LD_VAR 0 7
109042: ARRAY
109043: PPUSH
109044: LD_VAR 0 23
109048: PPUSH
109049: CALL_OW 113
109053: GO 109261
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
109055: LD_VAR 0 4
109059: PUSH
109060: LD_VAR 0 7
109064: ARRAY
109065: PPUSH
109066: CALL 82644 0 1
109070: PPUSH
109071: CALL_OW 256
109075: PUSH
109076: LD_INT 1000
109078: EQUAL
109079: IFFALSE 109098
// ComStop ( group [ i ] ) else
109081: LD_VAR 0 4
109085: PUSH
109086: LD_VAR 0 7
109090: ARRAY
109091: PPUSH
109092: CALL_OW 141
109096: GO 109261
// if not HasTask ( group [ i ] ) and to_heal then
109098: LD_VAR 0 4
109102: PUSH
109103: LD_VAR 0 7
109107: ARRAY
109108: PPUSH
109109: CALL_OW 314
109113: NOT
109114: PUSH
109115: LD_VAR 0 30
109119: AND
109120: IFFALSE 109261
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
109122: LD_ADDR_VAR 0 13
109126: PUSH
109127: LD_VAR 0 30
109131: PPUSH
109132: LD_INT 3
109134: PUSH
109135: LD_INT 54
109137: PUSH
109138: EMPTY
109139: LIST
109140: PUSH
109141: EMPTY
109142: LIST
109143: LIST
109144: PPUSH
109145: CALL_OW 72
109149: PPUSH
109150: LD_VAR 0 4
109154: PUSH
109155: LD_VAR 0 7
109159: ARRAY
109160: PPUSH
109161: CALL_OW 74
109165: ST_TO_ADDR
// if z then
109166: LD_VAR 0 13
109170: IFFALSE 109261
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
109172: LD_INT 91
109174: PUSH
109175: LD_VAR 0 13
109179: PUSH
109180: LD_INT 10
109182: PUSH
109183: EMPTY
109184: LIST
109185: LIST
109186: LIST
109187: PUSH
109188: LD_INT 81
109190: PUSH
109191: LD_VAR 0 13
109195: PPUSH
109196: CALL_OW 255
109200: PUSH
109201: EMPTY
109202: LIST
109203: LIST
109204: PUSH
109205: EMPTY
109206: LIST
109207: LIST
109208: PPUSH
109209: CALL_OW 69
109213: PUSH
109214: LD_INT 0
109216: EQUAL
109217: IFFALSE 109241
// ComHeal ( group [ i ] , z ) else
109219: LD_VAR 0 4
109223: PUSH
109224: LD_VAR 0 7
109228: ARRAY
109229: PPUSH
109230: LD_VAR 0 13
109234: PPUSH
109235: CALL_OW 128
109239: GO 109261
// ComMoveToArea ( group [ i ] , f_heal ) ;
109241: LD_VAR 0 4
109245: PUSH
109246: LD_VAR 0 7
109250: ARRAY
109251: PPUSH
109252: LD_VAR 0 23
109256: PPUSH
109257: CALL_OW 113
// end ; continue ;
109261: GO 108292
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
109263: LD_VAR 0 4
109267: PUSH
109268: LD_VAR 0 7
109272: ARRAY
109273: PPUSH
109274: CALL_OW 256
109278: PUSH
109279: LD_INT 700
109281: LESS
109282: PUSH
109283: LD_VAR 0 4
109287: PUSH
109288: LD_VAR 0 7
109292: ARRAY
109293: PUSH
109294: LD_VAR 0 30
109298: IN
109299: NOT
109300: AND
109301: IFFALSE 109325
// to_heal := to_heal union group [ i ] ;
109303: LD_ADDR_VAR 0 30
109307: PUSH
109308: LD_VAR 0 30
109312: PUSH
109313: LD_VAR 0 4
109317: PUSH
109318: LD_VAR 0 7
109322: ARRAY
109323: UNION
109324: ST_TO_ADDR
// if group [ i ] in to_heal then
109325: LD_VAR 0 4
109329: PUSH
109330: LD_VAR 0 7
109334: ARRAY
109335: PUSH
109336: LD_VAR 0 30
109340: IN
109341: IFFALSE 109450
// begin if GetLives ( group [ i ] ) = 1000 then
109343: LD_VAR 0 4
109347: PUSH
109348: LD_VAR 0 7
109352: ARRAY
109353: PPUSH
109354: CALL_OW 256
109358: PUSH
109359: LD_INT 1000
109361: EQUAL
109362: IFFALSE 109388
// to_heal := to_heal diff group [ i ] else
109364: LD_ADDR_VAR 0 30
109368: PUSH
109369: LD_VAR 0 30
109373: PUSH
109374: LD_VAR 0 4
109378: PUSH
109379: LD_VAR 0 7
109383: ARRAY
109384: DIFF
109385: ST_TO_ADDR
109386: GO 109450
// begin if not IsInArea ( group [ i ] , to_heal ) then
109388: LD_VAR 0 4
109392: PUSH
109393: LD_VAR 0 7
109397: ARRAY
109398: PPUSH
109399: LD_VAR 0 30
109403: PPUSH
109404: CALL_OW 308
109408: NOT
109409: IFFALSE 109433
// ComMoveToArea ( group [ i ] , f_heal ) else
109411: LD_VAR 0 4
109415: PUSH
109416: LD_VAR 0 7
109420: ARRAY
109421: PPUSH
109422: LD_VAR 0 23
109426: PPUSH
109427: CALL_OW 113
109431: GO 109448
// ComHold ( group [ i ] ) ;
109433: LD_VAR 0 4
109437: PUSH
109438: LD_VAR 0 7
109442: ARRAY
109443: PPUSH
109444: CALL_OW 140
// continue ;
109448: GO 108292
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
109450: LD_VAR 0 4
109454: PUSH
109455: LD_VAR 0 7
109459: ARRAY
109460: PPUSH
109461: LD_INT 10
109463: PPUSH
109464: CALL 81064 0 2
109468: NOT
109469: PUSH
109470: LD_VAR 0 16
109474: PUSH
109475: LD_VAR 0 7
109479: ARRAY
109480: PUSH
109481: EMPTY
109482: EQUAL
109483: NOT
109484: AND
109485: IFFALSE 109751
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
109487: LD_VAR 0 4
109491: PUSH
109492: LD_VAR 0 7
109496: ARRAY
109497: PPUSH
109498: CALL_OW 262
109502: PUSH
109503: LD_INT 1
109505: PUSH
109506: LD_INT 2
109508: PUSH
109509: EMPTY
109510: LIST
109511: LIST
109512: IN
109513: IFFALSE 109554
// if GetFuel ( group [ i ] ) < 10 then
109515: LD_VAR 0 4
109519: PUSH
109520: LD_VAR 0 7
109524: ARRAY
109525: PPUSH
109526: CALL_OW 261
109530: PUSH
109531: LD_INT 10
109533: LESS
109534: IFFALSE 109554
// SetFuel ( group [ i ] , 12 ) ;
109536: LD_VAR 0 4
109540: PUSH
109541: LD_VAR 0 7
109545: ARRAY
109546: PPUSH
109547: LD_INT 12
109549: PPUSH
109550: CALL_OW 240
// if units_path [ i ] then
109554: LD_VAR 0 16
109558: PUSH
109559: LD_VAR 0 7
109563: ARRAY
109564: IFFALSE 109749
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
109566: LD_VAR 0 4
109570: PUSH
109571: LD_VAR 0 7
109575: ARRAY
109576: PPUSH
109577: LD_VAR 0 16
109581: PUSH
109582: LD_VAR 0 7
109586: ARRAY
109587: PUSH
109588: LD_INT 1
109590: ARRAY
109591: PUSH
109592: LD_INT 1
109594: ARRAY
109595: PPUSH
109596: LD_VAR 0 16
109600: PUSH
109601: LD_VAR 0 7
109605: ARRAY
109606: PUSH
109607: LD_INT 1
109609: ARRAY
109610: PUSH
109611: LD_INT 2
109613: ARRAY
109614: PPUSH
109615: CALL_OW 297
109619: PUSH
109620: LD_INT 6
109622: GREATER
109623: IFFALSE 109698
// begin if not HasTask ( group [ i ] ) then
109625: LD_VAR 0 4
109629: PUSH
109630: LD_VAR 0 7
109634: ARRAY
109635: PPUSH
109636: CALL_OW 314
109640: NOT
109641: IFFALSE 109696
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
109643: LD_VAR 0 4
109647: PUSH
109648: LD_VAR 0 7
109652: ARRAY
109653: PPUSH
109654: LD_VAR 0 16
109658: PUSH
109659: LD_VAR 0 7
109663: ARRAY
109664: PUSH
109665: LD_INT 1
109667: ARRAY
109668: PUSH
109669: LD_INT 1
109671: ARRAY
109672: PPUSH
109673: LD_VAR 0 16
109677: PUSH
109678: LD_VAR 0 7
109682: ARRAY
109683: PUSH
109684: LD_INT 1
109686: ARRAY
109687: PUSH
109688: LD_INT 2
109690: ARRAY
109691: PPUSH
109692: CALL_OW 114
// end else
109696: GO 109749
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
109698: LD_ADDR_VAR 0 15
109702: PUSH
109703: LD_VAR 0 16
109707: PUSH
109708: LD_VAR 0 7
109712: ARRAY
109713: PPUSH
109714: LD_INT 1
109716: PPUSH
109717: CALL_OW 3
109721: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
109722: LD_ADDR_VAR 0 16
109726: PUSH
109727: LD_VAR 0 16
109731: PPUSH
109732: LD_VAR 0 7
109736: PPUSH
109737: LD_VAR 0 15
109741: PPUSH
109742: CALL_OW 1
109746: ST_TO_ADDR
// continue ;
109747: GO 108292
// end ; end ; end else
109749: GO 112413
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
109751: LD_ADDR_VAR 0 14
109755: PUSH
109756: LD_INT 81
109758: PUSH
109759: LD_VAR 0 4
109763: PUSH
109764: LD_VAR 0 7
109768: ARRAY
109769: PPUSH
109770: CALL_OW 255
109774: PUSH
109775: EMPTY
109776: LIST
109777: LIST
109778: PPUSH
109779: CALL_OW 69
109783: ST_TO_ADDR
// if not tmp then
109784: LD_VAR 0 14
109788: NOT
109789: IFFALSE 109793
// continue ;
109791: GO 108292
// if f_ignore_area then
109793: LD_VAR 0 17
109797: IFFALSE 109885
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
109799: LD_ADDR_VAR 0 15
109803: PUSH
109804: LD_VAR 0 14
109808: PPUSH
109809: LD_INT 3
109811: PUSH
109812: LD_INT 92
109814: PUSH
109815: LD_VAR 0 17
109819: PUSH
109820: LD_INT 1
109822: ARRAY
109823: PUSH
109824: LD_VAR 0 17
109828: PUSH
109829: LD_INT 2
109831: ARRAY
109832: PUSH
109833: LD_VAR 0 17
109837: PUSH
109838: LD_INT 3
109840: ARRAY
109841: PUSH
109842: EMPTY
109843: LIST
109844: LIST
109845: LIST
109846: LIST
109847: PUSH
109848: EMPTY
109849: LIST
109850: LIST
109851: PPUSH
109852: CALL_OW 72
109856: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109857: LD_VAR 0 14
109861: PUSH
109862: LD_VAR 0 15
109866: DIFF
109867: IFFALSE 109885
// tmp := tmp diff tmp2 ;
109869: LD_ADDR_VAR 0 14
109873: PUSH
109874: LD_VAR 0 14
109878: PUSH
109879: LD_VAR 0 15
109883: DIFF
109884: ST_TO_ADDR
// end ; if not f_murder then
109885: LD_VAR 0 20
109889: NOT
109890: IFFALSE 109948
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
109892: LD_ADDR_VAR 0 15
109896: PUSH
109897: LD_VAR 0 14
109901: PPUSH
109902: LD_INT 3
109904: PUSH
109905: LD_INT 50
109907: PUSH
109908: EMPTY
109909: LIST
109910: PUSH
109911: EMPTY
109912: LIST
109913: LIST
109914: PPUSH
109915: CALL_OW 72
109919: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109920: LD_VAR 0 14
109924: PUSH
109925: LD_VAR 0 15
109929: DIFF
109930: IFFALSE 109948
// tmp := tmp diff tmp2 ;
109932: LD_ADDR_VAR 0 14
109936: PUSH
109937: LD_VAR 0 14
109941: PUSH
109942: LD_VAR 0 15
109946: DIFF
109947: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
109948: LD_ADDR_VAR 0 14
109952: PUSH
109953: LD_VAR 0 4
109957: PUSH
109958: LD_VAR 0 7
109962: ARRAY
109963: PPUSH
109964: LD_VAR 0 14
109968: PPUSH
109969: LD_INT 1
109971: PPUSH
109972: LD_INT 1
109974: PPUSH
109975: CALL 53999 0 4
109979: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
109980: LD_VAR 0 4
109984: PUSH
109985: LD_VAR 0 7
109989: ARRAY
109990: PPUSH
109991: CALL_OW 257
109995: PUSH
109996: LD_INT 1
109998: EQUAL
109999: IFFALSE 110447
// begin if WantPlant ( group [ i ] ) then
110001: LD_VAR 0 4
110005: PUSH
110006: LD_VAR 0 7
110010: ARRAY
110011: PPUSH
110012: CALL 53500 0 1
110016: IFFALSE 110020
// continue ;
110018: GO 108292
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
110020: LD_VAR 0 18
110024: PUSH
110025: LD_VAR 0 4
110029: PUSH
110030: LD_VAR 0 7
110034: ARRAY
110035: PPUSH
110036: CALL_OW 310
110040: NOT
110041: AND
110042: PUSH
110043: LD_VAR 0 14
110047: PUSH
110048: LD_INT 1
110050: ARRAY
110051: PUSH
110052: LD_VAR 0 14
110056: PPUSH
110057: LD_INT 21
110059: PUSH
110060: LD_INT 2
110062: PUSH
110063: EMPTY
110064: LIST
110065: LIST
110066: PUSH
110067: LD_INT 58
110069: PUSH
110070: EMPTY
110071: LIST
110072: PUSH
110073: EMPTY
110074: LIST
110075: LIST
110076: PPUSH
110077: CALL_OW 72
110081: IN
110082: AND
110083: IFFALSE 110119
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
110085: LD_VAR 0 4
110089: PUSH
110090: LD_VAR 0 7
110094: ARRAY
110095: PPUSH
110096: LD_VAR 0 14
110100: PUSH
110101: LD_INT 1
110103: ARRAY
110104: PPUSH
110105: CALL_OW 120
// attacking := true ;
110109: LD_ADDR_VAR 0 29
110113: PUSH
110114: LD_INT 1
110116: ST_TO_ADDR
// continue ;
110117: GO 108292
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
110119: LD_VAR 0 26
110123: PUSH
110124: LD_VAR 0 4
110128: PUSH
110129: LD_VAR 0 7
110133: ARRAY
110134: PPUSH
110135: CALL_OW 257
110139: PUSH
110140: LD_INT 1
110142: EQUAL
110143: AND
110144: PUSH
110145: LD_VAR 0 4
110149: PUSH
110150: LD_VAR 0 7
110154: ARRAY
110155: PPUSH
110156: CALL_OW 256
110160: PUSH
110161: LD_INT 800
110163: LESS
110164: AND
110165: PUSH
110166: LD_VAR 0 4
110170: PUSH
110171: LD_VAR 0 7
110175: ARRAY
110176: PPUSH
110177: CALL_OW 318
110181: NOT
110182: AND
110183: IFFALSE 110200
// ComCrawl ( group [ i ] ) ;
110185: LD_VAR 0 4
110189: PUSH
110190: LD_VAR 0 7
110194: ARRAY
110195: PPUSH
110196: CALL_OW 137
// if f_mines then
110200: LD_VAR 0 21
110204: IFFALSE 110447
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
110206: LD_VAR 0 14
110210: PUSH
110211: LD_INT 1
110213: ARRAY
110214: PPUSH
110215: CALL_OW 247
110219: PUSH
110220: LD_INT 3
110222: EQUAL
110223: PUSH
110224: LD_VAR 0 14
110228: PUSH
110229: LD_INT 1
110231: ARRAY
110232: PUSH
110233: LD_VAR 0 27
110237: IN
110238: NOT
110239: AND
110240: IFFALSE 110447
// begin x := GetX ( tmp [ 1 ] ) ;
110242: LD_ADDR_VAR 0 10
110246: PUSH
110247: LD_VAR 0 14
110251: PUSH
110252: LD_INT 1
110254: ARRAY
110255: PPUSH
110256: CALL_OW 250
110260: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
110261: LD_ADDR_VAR 0 11
110265: PUSH
110266: LD_VAR 0 14
110270: PUSH
110271: LD_INT 1
110273: ARRAY
110274: PPUSH
110275: CALL_OW 251
110279: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
110280: LD_ADDR_VAR 0 12
110284: PUSH
110285: LD_VAR 0 4
110289: PUSH
110290: LD_VAR 0 7
110294: ARRAY
110295: PPUSH
110296: CALL 81149 0 1
110300: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
110301: LD_VAR 0 4
110305: PUSH
110306: LD_VAR 0 7
110310: ARRAY
110311: PPUSH
110312: LD_VAR 0 10
110316: PPUSH
110317: LD_VAR 0 11
110321: PPUSH
110322: LD_VAR 0 14
110326: PUSH
110327: LD_INT 1
110329: ARRAY
110330: PPUSH
110331: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
110335: LD_VAR 0 4
110339: PUSH
110340: LD_VAR 0 7
110344: ARRAY
110345: PPUSH
110346: LD_VAR 0 10
110350: PPUSH
110351: LD_VAR 0 12
110355: PPUSH
110356: LD_INT 7
110358: PPUSH
110359: CALL_OW 272
110363: PPUSH
110364: LD_VAR 0 11
110368: PPUSH
110369: LD_VAR 0 12
110373: PPUSH
110374: LD_INT 7
110376: PPUSH
110377: CALL_OW 273
110381: PPUSH
110382: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
110386: LD_VAR 0 4
110390: PUSH
110391: LD_VAR 0 7
110395: ARRAY
110396: PPUSH
110397: LD_INT 71
110399: PPUSH
110400: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
110404: LD_ADDR_VAR 0 27
110408: PUSH
110409: LD_VAR 0 27
110413: PPUSH
110414: LD_VAR 0 27
110418: PUSH
110419: LD_INT 1
110421: PLUS
110422: PPUSH
110423: LD_VAR 0 14
110427: PUSH
110428: LD_INT 1
110430: ARRAY
110431: PPUSH
110432: CALL_OW 1
110436: ST_TO_ADDR
// attacking := true ;
110437: LD_ADDR_VAR 0 29
110441: PUSH
110442: LD_INT 1
110444: ST_TO_ADDR
// continue ;
110445: GO 108292
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
110447: LD_VAR 0 4
110451: PUSH
110452: LD_VAR 0 7
110456: ARRAY
110457: PPUSH
110458: CALL_OW 257
110462: PUSH
110463: LD_INT 17
110465: EQUAL
110466: PUSH
110467: LD_VAR 0 4
110471: PUSH
110472: LD_VAR 0 7
110476: ARRAY
110477: PPUSH
110478: CALL_OW 110
110482: PUSH
110483: LD_INT 71
110485: EQUAL
110486: NOT
110487: AND
110488: IFFALSE 110634
// begin attacking := false ;
110490: LD_ADDR_VAR 0 29
110494: PUSH
110495: LD_INT 0
110497: ST_TO_ADDR
// k := 5 ;
110498: LD_ADDR_VAR 0 9
110502: PUSH
110503: LD_INT 5
110505: ST_TO_ADDR
// if tmp < k then
110506: LD_VAR 0 14
110510: PUSH
110511: LD_VAR 0 9
110515: LESS
110516: IFFALSE 110528
// k := tmp ;
110518: LD_ADDR_VAR 0 9
110522: PUSH
110523: LD_VAR 0 14
110527: ST_TO_ADDR
// for j = 1 to k do
110528: LD_ADDR_VAR 0 8
110532: PUSH
110533: DOUBLE
110534: LD_INT 1
110536: DEC
110537: ST_TO_ADDR
110538: LD_VAR 0 9
110542: PUSH
110543: FOR_TO
110544: IFFALSE 110632
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
110546: LD_VAR 0 14
110550: PUSH
110551: LD_VAR 0 8
110555: ARRAY
110556: PUSH
110557: LD_VAR 0 14
110561: PPUSH
110562: LD_INT 58
110564: PUSH
110565: EMPTY
110566: LIST
110567: PPUSH
110568: CALL_OW 72
110572: IN
110573: NOT
110574: IFFALSE 110630
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110576: LD_VAR 0 4
110580: PUSH
110581: LD_VAR 0 7
110585: ARRAY
110586: PPUSH
110587: LD_VAR 0 14
110591: PUSH
110592: LD_VAR 0 8
110596: ARRAY
110597: PPUSH
110598: CALL_OW 115
// attacking := true ;
110602: LD_ADDR_VAR 0 29
110606: PUSH
110607: LD_INT 1
110609: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
110610: LD_VAR 0 4
110614: PUSH
110615: LD_VAR 0 7
110619: ARRAY
110620: PPUSH
110621: LD_INT 71
110623: PPUSH
110624: CALL_OW 109
// continue ;
110628: GO 110543
// end ; end ;
110630: GO 110543
110632: POP
110633: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
110634: LD_VAR 0 4
110638: PUSH
110639: LD_VAR 0 7
110643: ARRAY
110644: PPUSH
110645: CALL_OW 257
110649: PUSH
110650: LD_INT 8
110652: EQUAL
110653: PUSH
110654: LD_VAR 0 4
110658: PUSH
110659: LD_VAR 0 7
110663: ARRAY
110664: PPUSH
110665: CALL_OW 264
110669: PUSH
110670: LD_INT 28
110672: PUSH
110673: LD_INT 45
110675: PUSH
110676: LD_INT 7
110678: PUSH
110679: LD_INT 47
110681: PUSH
110682: EMPTY
110683: LIST
110684: LIST
110685: LIST
110686: LIST
110687: IN
110688: OR
110689: IFFALSE 110945
// begin attacking := false ;
110691: LD_ADDR_VAR 0 29
110695: PUSH
110696: LD_INT 0
110698: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
110699: LD_VAR 0 14
110703: PUSH
110704: LD_INT 1
110706: ARRAY
110707: PPUSH
110708: CALL_OW 266
110712: PUSH
110713: LD_INT 32
110715: PUSH
110716: LD_INT 31
110718: PUSH
110719: LD_INT 33
110721: PUSH
110722: LD_INT 4
110724: PUSH
110725: LD_INT 5
110727: PUSH
110728: EMPTY
110729: LIST
110730: LIST
110731: LIST
110732: LIST
110733: LIST
110734: IN
110735: IFFALSE 110921
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
110737: LD_ADDR_VAR 0 9
110741: PUSH
110742: LD_VAR 0 14
110746: PUSH
110747: LD_INT 1
110749: ARRAY
110750: PPUSH
110751: CALL_OW 266
110755: PPUSH
110756: LD_VAR 0 14
110760: PUSH
110761: LD_INT 1
110763: ARRAY
110764: PPUSH
110765: CALL_OW 250
110769: PPUSH
110770: LD_VAR 0 14
110774: PUSH
110775: LD_INT 1
110777: ARRAY
110778: PPUSH
110779: CALL_OW 251
110783: PPUSH
110784: LD_VAR 0 14
110788: PUSH
110789: LD_INT 1
110791: ARRAY
110792: PPUSH
110793: CALL_OW 254
110797: PPUSH
110798: LD_VAR 0 14
110802: PUSH
110803: LD_INT 1
110805: ARRAY
110806: PPUSH
110807: CALL_OW 248
110811: PPUSH
110812: LD_INT 0
110814: PPUSH
110815: CALL 62519 0 6
110819: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
110820: LD_ADDR_VAR 0 8
110824: PUSH
110825: LD_VAR 0 4
110829: PUSH
110830: LD_VAR 0 7
110834: ARRAY
110835: PPUSH
110836: LD_VAR 0 9
110840: PPUSH
110841: CALL 81189 0 2
110845: ST_TO_ADDR
// if j then
110846: LD_VAR 0 8
110850: IFFALSE 110919
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
110852: LD_VAR 0 8
110856: PUSH
110857: LD_INT 1
110859: ARRAY
110860: PPUSH
110861: LD_VAR 0 8
110865: PUSH
110866: LD_INT 2
110868: ARRAY
110869: PPUSH
110870: CALL_OW 488
110874: IFFALSE 110919
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
110876: LD_VAR 0 4
110880: PUSH
110881: LD_VAR 0 7
110885: ARRAY
110886: PPUSH
110887: LD_VAR 0 8
110891: PUSH
110892: LD_INT 1
110894: ARRAY
110895: PPUSH
110896: LD_VAR 0 8
110900: PUSH
110901: LD_INT 2
110903: ARRAY
110904: PPUSH
110905: CALL_OW 116
// attacking := true ;
110909: LD_ADDR_VAR 0 29
110913: PUSH
110914: LD_INT 1
110916: ST_TO_ADDR
// continue ;
110917: GO 108292
// end ; end else
110919: GO 110945
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110921: LD_VAR 0 4
110925: PUSH
110926: LD_VAR 0 7
110930: ARRAY
110931: PPUSH
110932: LD_VAR 0 14
110936: PUSH
110937: LD_INT 1
110939: ARRAY
110940: PPUSH
110941: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
110945: LD_VAR 0 4
110949: PUSH
110950: LD_VAR 0 7
110954: ARRAY
110955: PPUSH
110956: CALL_OW 265
110960: PUSH
110961: LD_INT 11
110963: EQUAL
110964: IFFALSE 111242
// begin k := 10 ;
110966: LD_ADDR_VAR 0 9
110970: PUSH
110971: LD_INT 10
110973: ST_TO_ADDR
// x := 0 ;
110974: LD_ADDR_VAR 0 10
110978: PUSH
110979: LD_INT 0
110981: ST_TO_ADDR
// if tmp < k then
110982: LD_VAR 0 14
110986: PUSH
110987: LD_VAR 0 9
110991: LESS
110992: IFFALSE 111004
// k := tmp ;
110994: LD_ADDR_VAR 0 9
110998: PUSH
110999: LD_VAR 0 14
111003: ST_TO_ADDR
// for j = k downto 1 do
111004: LD_ADDR_VAR 0 8
111008: PUSH
111009: DOUBLE
111010: LD_VAR 0 9
111014: INC
111015: ST_TO_ADDR
111016: LD_INT 1
111018: PUSH
111019: FOR_DOWNTO
111020: IFFALSE 111095
// begin if GetType ( tmp [ j ] ) = unit_human then
111022: LD_VAR 0 14
111026: PUSH
111027: LD_VAR 0 8
111031: ARRAY
111032: PPUSH
111033: CALL_OW 247
111037: PUSH
111038: LD_INT 1
111040: EQUAL
111041: IFFALSE 111093
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
111043: LD_VAR 0 4
111047: PUSH
111048: LD_VAR 0 7
111052: ARRAY
111053: PPUSH
111054: LD_VAR 0 14
111058: PUSH
111059: LD_VAR 0 8
111063: ARRAY
111064: PPUSH
111065: CALL 81460 0 2
// x := tmp [ j ] ;
111069: LD_ADDR_VAR 0 10
111073: PUSH
111074: LD_VAR 0 14
111078: PUSH
111079: LD_VAR 0 8
111083: ARRAY
111084: ST_TO_ADDR
// attacking := true ;
111085: LD_ADDR_VAR 0 29
111089: PUSH
111090: LD_INT 1
111092: ST_TO_ADDR
// end ; end ;
111093: GO 111019
111095: POP
111096: POP
// if not x then
111097: LD_VAR 0 10
111101: NOT
111102: IFFALSE 111242
// begin attacking := true ;
111104: LD_ADDR_VAR 0 29
111108: PUSH
111109: LD_INT 1
111111: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
111112: LD_VAR 0 4
111116: PUSH
111117: LD_VAR 0 7
111121: ARRAY
111122: PPUSH
111123: CALL_OW 250
111127: PPUSH
111128: LD_VAR 0 4
111132: PUSH
111133: LD_VAR 0 7
111137: ARRAY
111138: PPUSH
111139: CALL_OW 251
111143: PPUSH
111144: CALL_OW 546
111148: PUSH
111149: LD_INT 2
111151: ARRAY
111152: PUSH
111153: LD_VAR 0 14
111157: PUSH
111158: LD_INT 1
111160: ARRAY
111161: PPUSH
111162: CALL_OW 250
111166: PPUSH
111167: LD_VAR 0 14
111171: PUSH
111172: LD_INT 1
111174: ARRAY
111175: PPUSH
111176: CALL_OW 251
111180: PPUSH
111181: CALL_OW 546
111185: PUSH
111186: LD_INT 2
111188: ARRAY
111189: EQUAL
111190: IFFALSE 111218
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
111192: LD_VAR 0 4
111196: PUSH
111197: LD_VAR 0 7
111201: ARRAY
111202: PPUSH
111203: LD_VAR 0 14
111207: PUSH
111208: LD_INT 1
111210: ARRAY
111211: PPUSH
111212: CALL 81460 0 2
111216: GO 111242
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111218: LD_VAR 0 4
111222: PUSH
111223: LD_VAR 0 7
111227: ARRAY
111228: PPUSH
111229: LD_VAR 0 14
111233: PUSH
111234: LD_INT 1
111236: ARRAY
111237: PPUSH
111238: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
111242: LD_VAR 0 4
111246: PUSH
111247: LD_VAR 0 7
111251: ARRAY
111252: PPUSH
111253: CALL_OW 264
111257: PUSH
111258: LD_INT 29
111260: EQUAL
111261: IFFALSE 111627
// begin if WantsToAttack ( group [ i ] ) in bombed then
111263: LD_VAR 0 4
111267: PUSH
111268: LD_VAR 0 7
111272: ARRAY
111273: PPUSH
111274: CALL_OW 319
111278: PUSH
111279: LD_VAR 0 28
111283: IN
111284: IFFALSE 111288
// continue ;
111286: GO 108292
// k := 8 ;
111288: LD_ADDR_VAR 0 9
111292: PUSH
111293: LD_INT 8
111295: ST_TO_ADDR
// x := 0 ;
111296: LD_ADDR_VAR 0 10
111300: PUSH
111301: LD_INT 0
111303: ST_TO_ADDR
// if tmp < k then
111304: LD_VAR 0 14
111308: PUSH
111309: LD_VAR 0 9
111313: LESS
111314: IFFALSE 111326
// k := tmp ;
111316: LD_ADDR_VAR 0 9
111320: PUSH
111321: LD_VAR 0 14
111325: ST_TO_ADDR
// for j = 1 to k do
111326: LD_ADDR_VAR 0 8
111330: PUSH
111331: DOUBLE
111332: LD_INT 1
111334: DEC
111335: ST_TO_ADDR
111336: LD_VAR 0 9
111340: PUSH
111341: FOR_TO
111342: IFFALSE 111474
// begin if GetType ( tmp [ j ] ) = unit_building then
111344: LD_VAR 0 14
111348: PUSH
111349: LD_VAR 0 8
111353: ARRAY
111354: PPUSH
111355: CALL_OW 247
111359: PUSH
111360: LD_INT 3
111362: EQUAL
111363: IFFALSE 111472
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
111365: LD_VAR 0 14
111369: PUSH
111370: LD_VAR 0 8
111374: ARRAY
111375: PUSH
111376: LD_VAR 0 28
111380: IN
111381: NOT
111382: PUSH
111383: LD_VAR 0 14
111387: PUSH
111388: LD_VAR 0 8
111392: ARRAY
111393: PPUSH
111394: CALL_OW 313
111398: AND
111399: IFFALSE 111472
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111401: LD_VAR 0 4
111405: PUSH
111406: LD_VAR 0 7
111410: ARRAY
111411: PPUSH
111412: LD_VAR 0 14
111416: PUSH
111417: LD_VAR 0 8
111421: ARRAY
111422: PPUSH
111423: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
111427: LD_ADDR_VAR 0 28
111431: PUSH
111432: LD_VAR 0 28
111436: PPUSH
111437: LD_VAR 0 28
111441: PUSH
111442: LD_INT 1
111444: PLUS
111445: PPUSH
111446: LD_VAR 0 14
111450: PUSH
111451: LD_VAR 0 8
111455: ARRAY
111456: PPUSH
111457: CALL_OW 1
111461: ST_TO_ADDR
// attacking := true ;
111462: LD_ADDR_VAR 0 29
111466: PUSH
111467: LD_INT 1
111469: ST_TO_ADDR
// break ;
111470: GO 111474
// end ; end ;
111472: GO 111341
111474: POP
111475: POP
// if not attacking and f_attack_depot then
111476: LD_VAR 0 29
111480: NOT
111481: PUSH
111482: LD_VAR 0 25
111486: AND
111487: IFFALSE 111582
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111489: LD_ADDR_VAR 0 13
111493: PUSH
111494: LD_VAR 0 14
111498: PPUSH
111499: LD_INT 2
111501: PUSH
111502: LD_INT 30
111504: PUSH
111505: LD_INT 0
111507: PUSH
111508: EMPTY
111509: LIST
111510: LIST
111511: PUSH
111512: LD_INT 30
111514: PUSH
111515: LD_INT 1
111517: PUSH
111518: EMPTY
111519: LIST
111520: LIST
111521: PUSH
111522: EMPTY
111523: LIST
111524: LIST
111525: LIST
111526: PPUSH
111527: CALL_OW 72
111531: ST_TO_ADDR
// if z then
111532: LD_VAR 0 13
111536: IFFALSE 111582
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
111538: LD_VAR 0 4
111542: PUSH
111543: LD_VAR 0 7
111547: ARRAY
111548: PPUSH
111549: LD_VAR 0 13
111553: PPUSH
111554: LD_VAR 0 4
111558: PUSH
111559: LD_VAR 0 7
111563: ARRAY
111564: PPUSH
111565: CALL_OW 74
111569: PPUSH
111570: CALL_OW 115
// attacking := true ;
111574: LD_ADDR_VAR 0 29
111578: PUSH
111579: LD_INT 1
111581: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
111582: LD_VAR 0 4
111586: PUSH
111587: LD_VAR 0 7
111591: ARRAY
111592: PPUSH
111593: CALL_OW 256
111597: PUSH
111598: LD_INT 500
111600: LESS
111601: IFFALSE 111627
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111603: LD_VAR 0 4
111607: PUSH
111608: LD_VAR 0 7
111612: ARRAY
111613: PPUSH
111614: LD_VAR 0 14
111618: PUSH
111619: LD_INT 1
111621: ARRAY
111622: PPUSH
111623: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
111627: LD_VAR 0 4
111631: PUSH
111632: LD_VAR 0 7
111636: ARRAY
111637: PPUSH
111638: CALL_OW 264
111642: PUSH
111643: LD_INT 49
111645: EQUAL
111646: IFFALSE 111767
// begin if not HasTask ( group [ i ] ) then
111648: LD_VAR 0 4
111652: PUSH
111653: LD_VAR 0 7
111657: ARRAY
111658: PPUSH
111659: CALL_OW 314
111663: NOT
111664: IFFALSE 111767
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
111666: LD_ADDR_VAR 0 9
111670: PUSH
111671: LD_INT 81
111673: PUSH
111674: LD_VAR 0 4
111678: PUSH
111679: LD_VAR 0 7
111683: ARRAY
111684: PPUSH
111685: CALL_OW 255
111689: PUSH
111690: EMPTY
111691: LIST
111692: LIST
111693: PPUSH
111694: CALL_OW 69
111698: PPUSH
111699: LD_VAR 0 4
111703: PUSH
111704: LD_VAR 0 7
111708: ARRAY
111709: PPUSH
111710: CALL_OW 74
111714: ST_TO_ADDR
// if k then
111715: LD_VAR 0 9
111719: IFFALSE 111767
// if GetDistUnits ( group [ i ] , k ) > 10 then
111721: LD_VAR 0 4
111725: PUSH
111726: LD_VAR 0 7
111730: ARRAY
111731: PPUSH
111732: LD_VAR 0 9
111736: PPUSH
111737: CALL_OW 296
111741: PUSH
111742: LD_INT 10
111744: GREATER
111745: IFFALSE 111767
// ComMoveUnit ( group [ i ] , k ) ;
111747: LD_VAR 0 4
111751: PUSH
111752: LD_VAR 0 7
111756: ARRAY
111757: PPUSH
111758: LD_VAR 0 9
111762: PPUSH
111763: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
111767: LD_VAR 0 4
111771: PUSH
111772: LD_VAR 0 7
111776: ARRAY
111777: PPUSH
111778: CALL_OW 256
111782: PUSH
111783: LD_INT 250
111785: LESS
111786: PUSH
111787: LD_VAR 0 4
111791: PUSH
111792: LD_VAR 0 7
111796: ARRAY
111797: PUSH
111798: LD_INT 21
111800: PUSH
111801: LD_INT 2
111803: PUSH
111804: EMPTY
111805: LIST
111806: LIST
111807: PUSH
111808: LD_INT 23
111810: PUSH
111811: LD_INT 2
111813: PUSH
111814: EMPTY
111815: LIST
111816: LIST
111817: PUSH
111818: EMPTY
111819: LIST
111820: LIST
111821: PPUSH
111822: CALL_OW 69
111826: IN
111827: AND
111828: IFFALSE 111953
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
111830: LD_ADDR_VAR 0 9
111834: PUSH
111835: LD_OWVAR 3
111839: PUSH
111840: LD_VAR 0 4
111844: PUSH
111845: LD_VAR 0 7
111849: ARRAY
111850: DIFF
111851: PPUSH
111852: LD_VAR 0 4
111856: PUSH
111857: LD_VAR 0 7
111861: ARRAY
111862: PPUSH
111863: CALL_OW 74
111867: ST_TO_ADDR
// if not k then
111868: LD_VAR 0 9
111872: NOT
111873: IFFALSE 111877
// continue ;
111875: GO 108292
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
111877: LD_VAR 0 9
111881: PUSH
111882: LD_INT 81
111884: PUSH
111885: LD_VAR 0 4
111889: PUSH
111890: LD_VAR 0 7
111894: ARRAY
111895: PPUSH
111896: CALL_OW 255
111900: PUSH
111901: EMPTY
111902: LIST
111903: LIST
111904: PPUSH
111905: CALL_OW 69
111909: IN
111910: PUSH
111911: LD_VAR 0 9
111915: PPUSH
111916: LD_VAR 0 4
111920: PUSH
111921: LD_VAR 0 7
111925: ARRAY
111926: PPUSH
111927: CALL_OW 296
111931: PUSH
111932: LD_INT 5
111934: LESS
111935: AND
111936: IFFALSE 111953
// ComAutodestruct ( group [ i ] ) ;
111938: LD_VAR 0 4
111942: PUSH
111943: LD_VAR 0 7
111947: ARRAY
111948: PPUSH
111949: CALL 81358 0 1
// end ; if f_attack_depot then
111953: LD_VAR 0 25
111957: IFFALSE 112069
// begin k := 6 ;
111959: LD_ADDR_VAR 0 9
111963: PUSH
111964: LD_INT 6
111966: ST_TO_ADDR
// if tmp < k then
111967: LD_VAR 0 14
111971: PUSH
111972: LD_VAR 0 9
111976: LESS
111977: IFFALSE 111989
// k := tmp ;
111979: LD_ADDR_VAR 0 9
111983: PUSH
111984: LD_VAR 0 14
111988: ST_TO_ADDR
// for j = 1 to k do
111989: LD_ADDR_VAR 0 8
111993: PUSH
111994: DOUBLE
111995: LD_INT 1
111997: DEC
111998: ST_TO_ADDR
111999: LD_VAR 0 9
112003: PUSH
112004: FOR_TO
112005: IFFALSE 112067
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
112007: LD_VAR 0 8
112011: PPUSH
112012: CALL_OW 266
112016: PUSH
112017: LD_INT 0
112019: PUSH
112020: LD_INT 1
112022: PUSH
112023: EMPTY
112024: LIST
112025: LIST
112026: IN
112027: IFFALSE 112065
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112029: LD_VAR 0 4
112033: PUSH
112034: LD_VAR 0 7
112038: ARRAY
112039: PPUSH
112040: LD_VAR 0 14
112044: PUSH
112045: LD_VAR 0 8
112049: ARRAY
112050: PPUSH
112051: CALL_OW 115
// attacking := true ;
112055: LD_ADDR_VAR 0 29
112059: PUSH
112060: LD_INT 1
112062: ST_TO_ADDR
// break ;
112063: GO 112067
// end ;
112065: GO 112004
112067: POP
112068: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
112069: LD_VAR 0 4
112073: PUSH
112074: LD_VAR 0 7
112078: ARRAY
112079: PPUSH
112080: CALL_OW 302
112084: PUSH
112085: LD_VAR 0 29
112089: NOT
112090: AND
112091: IFFALSE 112413
// begin if GetTag ( group [ i ] ) = 71 then
112093: LD_VAR 0 4
112097: PUSH
112098: LD_VAR 0 7
112102: ARRAY
112103: PPUSH
112104: CALL_OW 110
112108: PUSH
112109: LD_INT 71
112111: EQUAL
112112: IFFALSE 112153
// begin if HasTask ( group [ i ] ) then
112114: LD_VAR 0 4
112118: PUSH
112119: LD_VAR 0 7
112123: ARRAY
112124: PPUSH
112125: CALL_OW 314
112129: IFFALSE 112135
// continue else
112131: GO 108292
112133: GO 112153
// SetTag ( group [ i ] , 0 ) ;
112135: LD_VAR 0 4
112139: PUSH
112140: LD_VAR 0 7
112144: ARRAY
112145: PPUSH
112146: LD_INT 0
112148: PPUSH
112149: CALL_OW 109
// end ; k := 8 ;
112153: LD_ADDR_VAR 0 9
112157: PUSH
112158: LD_INT 8
112160: ST_TO_ADDR
// x := 0 ;
112161: LD_ADDR_VAR 0 10
112165: PUSH
112166: LD_INT 0
112168: ST_TO_ADDR
// if tmp < k then
112169: LD_VAR 0 14
112173: PUSH
112174: LD_VAR 0 9
112178: LESS
112179: IFFALSE 112191
// k := tmp ;
112181: LD_ADDR_VAR 0 9
112185: PUSH
112186: LD_VAR 0 14
112190: ST_TO_ADDR
// for j = 1 to k do
112191: LD_ADDR_VAR 0 8
112195: PUSH
112196: DOUBLE
112197: LD_INT 1
112199: DEC
112200: ST_TO_ADDR
112201: LD_VAR 0 9
112205: PUSH
112206: FOR_TO
112207: IFFALSE 112305
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
112209: LD_VAR 0 14
112213: PUSH
112214: LD_VAR 0 8
112218: ARRAY
112219: PPUSH
112220: CALL_OW 247
112224: PUSH
112225: LD_INT 1
112227: EQUAL
112228: PUSH
112229: LD_VAR 0 14
112233: PUSH
112234: LD_VAR 0 8
112238: ARRAY
112239: PPUSH
112240: CALL_OW 256
112244: PUSH
112245: LD_INT 250
112247: LESS
112248: PUSH
112249: LD_VAR 0 20
112253: AND
112254: PUSH
112255: LD_VAR 0 20
112259: NOT
112260: PUSH
112261: LD_VAR 0 14
112265: PUSH
112266: LD_VAR 0 8
112270: ARRAY
112271: PPUSH
112272: CALL_OW 256
112276: PUSH
112277: LD_INT 250
112279: GREATEREQUAL
112280: AND
112281: OR
112282: AND
112283: IFFALSE 112303
// begin x := tmp [ j ] ;
112285: LD_ADDR_VAR 0 10
112289: PUSH
112290: LD_VAR 0 14
112294: PUSH
112295: LD_VAR 0 8
112299: ARRAY
112300: ST_TO_ADDR
// break ;
112301: GO 112305
// end ;
112303: GO 112206
112305: POP
112306: POP
// if x then
112307: LD_VAR 0 10
112311: IFFALSE 112335
// ComAttackUnit ( group [ i ] , x ) else
112313: LD_VAR 0 4
112317: PUSH
112318: LD_VAR 0 7
112322: ARRAY
112323: PPUSH
112324: LD_VAR 0 10
112328: PPUSH
112329: CALL_OW 115
112333: GO 112359
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112335: LD_VAR 0 4
112339: PUSH
112340: LD_VAR 0 7
112344: ARRAY
112345: PPUSH
112346: LD_VAR 0 14
112350: PUSH
112351: LD_INT 1
112353: ARRAY
112354: PPUSH
112355: CALL_OW 115
// if not HasTask ( group [ i ] ) then
112359: LD_VAR 0 4
112363: PUSH
112364: LD_VAR 0 7
112368: ARRAY
112369: PPUSH
112370: CALL_OW 314
112374: NOT
112375: IFFALSE 112413
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
112377: LD_VAR 0 4
112381: PUSH
112382: LD_VAR 0 7
112386: ARRAY
112387: PPUSH
112388: LD_VAR 0 14
112392: PPUSH
112393: LD_VAR 0 4
112397: PUSH
112398: LD_VAR 0 7
112402: ARRAY
112403: PPUSH
112404: CALL_OW 74
112408: PPUSH
112409: CALL_OW 115
// end ; end ; end ;
112413: GO 108292
112415: POP
112416: POP
// wait ( 0 0$2 ) ;
112417: LD_INT 70
112419: PPUSH
112420: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
112424: LD_VAR 0 4
112428: NOT
112429: PUSH
112430: LD_VAR 0 4
112434: PUSH
112435: EMPTY
112436: EQUAL
112437: OR
112438: PUSH
112439: LD_INT 81
112441: PUSH
112442: LD_VAR 0 35
112446: PUSH
112447: EMPTY
112448: LIST
112449: LIST
112450: PPUSH
112451: CALL_OW 69
112455: NOT
112456: OR
112457: IFFALSE 108277
// end ;
112459: LD_VAR 0 2
112463: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
112464: LD_INT 0
112466: PPUSH
112467: PPUSH
112468: PPUSH
112469: PPUSH
112470: PPUSH
112471: PPUSH
// if not base or not mc_bases [ base ] or not solds then
112472: LD_VAR 0 1
112476: NOT
112477: PUSH
112478: LD_EXP 50
112482: PUSH
112483: LD_VAR 0 1
112487: ARRAY
112488: NOT
112489: OR
112490: PUSH
112491: LD_VAR 0 2
112495: NOT
112496: OR
112497: IFFALSE 112501
// exit ;
112499: GO 113055
// side := mc_sides [ base ] ;
112501: LD_ADDR_VAR 0 6
112505: PUSH
112506: LD_EXP 76
112510: PUSH
112511: LD_VAR 0 1
112515: ARRAY
112516: ST_TO_ADDR
// if not side then
112517: LD_VAR 0 6
112521: NOT
112522: IFFALSE 112526
// exit ;
112524: GO 113055
// for i in solds do
112526: LD_ADDR_VAR 0 7
112530: PUSH
112531: LD_VAR 0 2
112535: PUSH
112536: FOR_IN
112537: IFFALSE 112598
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
112539: LD_VAR 0 7
112543: PPUSH
112544: CALL_OW 310
112548: PPUSH
112549: CALL_OW 266
112553: PUSH
112554: LD_INT 32
112556: PUSH
112557: LD_INT 31
112559: PUSH
112560: EMPTY
112561: LIST
112562: LIST
112563: IN
112564: IFFALSE 112584
// solds := solds diff i else
112566: LD_ADDR_VAR 0 2
112570: PUSH
112571: LD_VAR 0 2
112575: PUSH
112576: LD_VAR 0 7
112580: DIFF
112581: ST_TO_ADDR
112582: GO 112596
// SetTag ( i , 18 ) ;
112584: LD_VAR 0 7
112588: PPUSH
112589: LD_INT 18
112591: PPUSH
112592: CALL_OW 109
112596: GO 112536
112598: POP
112599: POP
// if not solds then
112600: LD_VAR 0 2
112604: NOT
112605: IFFALSE 112609
// exit ;
112607: GO 113055
// repeat wait ( 0 0$2 ) ;
112609: LD_INT 70
112611: PPUSH
112612: CALL_OW 67
// enemy := mc_scan [ base ] ;
112616: LD_ADDR_VAR 0 4
112620: PUSH
112621: LD_EXP 73
112625: PUSH
112626: LD_VAR 0 1
112630: ARRAY
112631: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112632: LD_EXP 50
112636: PUSH
112637: LD_VAR 0 1
112641: ARRAY
112642: NOT
112643: PUSH
112644: LD_EXP 50
112648: PUSH
112649: LD_VAR 0 1
112653: ARRAY
112654: PUSH
112655: EMPTY
112656: EQUAL
112657: OR
112658: IFFALSE 112695
// begin for i in solds do
112660: LD_ADDR_VAR 0 7
112664: PUSH
112665: LD_VAR 0 2
112669: PUSH
112670: FOR_IN
112671: IFFALSE 112684
// ComStop ( i ) ;
112673: LD_VAR 0 7
112677: PPUSH
112678: CALL_OW 141
112682: GO 112670
112684: POP
112685: POP
// solds := [ ] ;
112686: LD_ADDR_VAR 0 2
112690: PUSH
112691: EMPTY
112692: ST_TO_ADDR
// exit ;
112693: GO 113055
// end ; for i in solds do
112695: LD_ADDR_VAR 0 7
112699: PUSH
112700: LD_VAR 0 2
112704: PUSH
112705: FOR_IN
112706: IFFALSE 113027
// begin if IsInUnit ( i ) then
112708: LD_VAR 0 7
112712: PPUSH
112713: CALL_OW 310
112717: IFFALSE 112728
// ComExitBuilding ( i ) ;
112719: LD_VAR 0 7
112723: PPUSH
112724: CALL_OW 122
// if GetLives ( i ) > 500 then
112728: LD_VAR 0 7
112732: PPUSH
112733: CALL_OW 256
112737: PUSH
112738: LD_INT 500
112740: GREATER
112741: IFFALSE 112794
// begin e := NearestUnitToUnit ( enemy , i ) ;
112743: LD_ADDR_VAR 0 5
112747: PUSH
112748: LD_VAR 0 4
112752: PPUSH
112753: LD_VAR 0 7
112757: PPUSH
112758: CALL_OW 74
112762: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
112763: LD_VAR 0 7
112767: PPUSH
112768: LD_VAR 0 5
112772: PPUSH
112773: CALL_OW 250
112777: PPUSH
112778: LD_VAR 0 5
112782: PPUSH
112783: CALL_OW 251
112787: PPUSH
112788: CALL_OW 114
// end else
112792: GO 113025
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
112794: LD_VAR 0 7
112798: PPUSH
112799: LD_EXP 50
112803: PUSH
112804: LD_VAR 0 1
112808: ARRAY
112809: PPUSH
112810: LD_INT 2
112812: PUSH
112813: LD_INT 30
112815: PUSH
112816: LD_INT 0
112818: PUSH
112819: EMPTY
112820: LIST
112821: LIST
112822: PUSH
112823: LD_INT 30
112825: PUSH
112826: LD_INT 1
112828: PUSH
112829: EMPTY
112830: LIST
112831: LIST
112832: PUSH
112833: LD_INT 30
112835: PUSH
112836: LD_INT 6
112838: PUSH
112839: EMPTY
112840: LIST
112841: LIST
112842: PUSH
112843: EMPTY
112844: LIST
112845: LIST
112846: LIST
112847: LIST
112848: PPUSH
112849: CALL_OW 72
112853: PPUSH
112854: LD_VAR 0 7
112858: PPUSH
112859: CALL_OW 74
112863: PPUSH
112864: CALL_OW 296
112868: PUSH
112869: LD_INT 10
112871: GREATER
112872: IFFALSE 113025
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
112874: LD_ADDR_VAR 0 8
112878: PUSH
112879: LD_EXP 50
112883: PUSH
112884: LD_VAR 0 1
112888: ARRAY
112889: PPUSH
112890: LD_INT 2
112892: PUSH
112893: LD_INT 30
112895: PUSH
112896: LD_INT 0
112898: PUSH
112899: EMPTY
112900: LIST
112901: LIST
112902: PUSH
112903: LD_INT 30
112905: PUSH
112906: LD_INT 1
112908: PUSH
112909: EMPTY
112910: LIST
112911: LIST
112912: PUSH
112913: LD_INT 30
112915: PUSH
112916: LD_INT 6
112918: PUSH
112919: EMPTY
112920: LIST
112921: LIST
112922: PUSH
112923: EMPTY
112924: LIST
112925: LIST
112926: LIST
112927: LIST
112928: PPUSH
112929: CALL_OW 72
112933: PPUSH
112934: LD_VAR 0 7
112938: PPUSH
112939: CALL_OW 74
112943: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
112944: LD_VAR 0 7
112948: PPUSH
112949: LD_VAR 0 8
112953: PPUSH
112954: CALL_OW 250
112958: PPUSH
112959: LD_INT 3
112961: PPUSH
112962: LD_INT 5
112964: PPUSH
112965: CALL_OW 272
112969: PPUSH
112970: LD_VAR 0 8
112974: PPUSH
112975: CALL_OW 251
112979: PPUSH
112980: LD_INT 3
112982: PPUSH
112983: LD_INT 5
112985: PPUSH
112986: CALL_OW 273
112990: PPUSH
112991: CALL_OW 111
// SetTag ( i , 0 ) ;
112995: LD_VAR 0 7
112999: PPUSH
113000: LD_INT 0
113002: PPUSH
113003: CALL_OW 109
// solds := solds diff i ;
113007: LD_ADDR_VAR 0 2
113011: PUSH
113012: LD_VAR 0 2
113016: PUSH
113017: LD_VAR 0 7
113021: DIFF
113022: ST_TO_ADDR
// continue ;
113023: GO 112705
// end ; end ;
113025: GO 112705
113027: POP
113028: POP
// until not solds or not enemy ;
113029: LD_VAR 0 2
113033: NOT
113034: PUSH
113035: LD_VAR 0 4
113039: NOT
113040: OR
113041: IFFALSE 112609
// MC_Reset ( base , 18 ) ;
113043: LD_VAR 0 1
113047: PPUSH
113048: LD_INT 18
113050: PPUSH
113051: CALL 22106 0 2
// end ;
113055: LD_VAR 0 3
113059: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
113060: LD_INT 0
113062: PPUSH
113063: PPUSH
113064: PPUSH
113065: PPUSH
113066: PPUSH
113067: PPUSH
113068: PPUSH
113069: PPUSH
113070: PPUSH
113071: PPUSH
113072: PPUSH
113073: PPUSH
113074: PPUSH
113075: PPUSH
113076: PPUSH
113077: PPUSH
113078: PPUSH
113079: PPUSH
113080: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
113081: LD_ADDR_VAR 0 12
113085: PUSH
113086: LD_EXP 50
113090: PUSH
113091: LD_VAR 0 1
113095: ARRAY
113096: PPUSH
113097: LD_INT 25
113099: PUSH
113100: LD_INT 3
113102: PUSH
113103: EMPTY
113104: LIST
113105: LIST
113106: PPUSH
113107: CALL_OW 72
113111: ST_TO_ADDR
// if mc_remote_driver [ base ] then
113112: LD_EXP 90
113116: PUSH
113117: LD_VAR 0 1
113121: ARRAY
113122: IFFALSE 113146
// mechs := mechs diff mc_remote_driver [ base ] ;
113124: LD_ADDR_VAR 0 12
113128: PUSH
113129: LD_VAR 0 12
113133: PUSH
113134: LD_EXP 90
113138: PUSH
113139: LD_VAR 0 1
113143: ARRAY
113144: DIFF
113145: ST_TO_ADDR
// for i in mechs do
113146: LD_ADDR_VAR 0 4
113150: PUSH
113151: LD_VAR 0 12
113155: PUSH
113156: FOR_IN
113157: IFFALSE 113192
// if GetTag ( i ) > 0 then
113159: LD_VAR 0 4
113163: PPUSH
113164: CALL_OW 110
113168: PUSH
113169: LD_INT 0
113171: GREATER
113172: IFFALSE 113190
// mechs := mechs diff i ;
113174: LD_ADDR_VAR 0 12
113178: PUSH
113179: LD_VAR 0 12
113183: PUSH
113184: LD_VAR 0 4
113188: DIFF
113189: ST_TO_ADDR
113190: GO 113156
113192: POP
113193: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113194: LD_ADDR_VAR 0 8
113198: PUSH
113199: LD_EXP 50
113203: PUSH
113204: LD_VAR 0 1
113208: ARRAY
113209: PPUSH
113210: LD_INT 2
113212: PUSH
113213: LD_INT 25
113215: PUSH
113216: LD_INT 1
113218: PUSH
113219: EMPTY
113220: LIST
113221: LIST
113222: PUSH
113223: LD_INT 25
113225: PUSH
113226: LD_INT 5
113228: PUSH
113229: EMPTY
113230: LIST
113231: LIST
113232: PUSH
113233: LD_INT 25
113235: PUSH
113236: LD_INT 8
113238: PUSH
113239: EMPTY
113240: LIST
113241: LIST
113242: PUSH
113243: LD_INT 25
113245: PUSH
113246: LD_INT 9
113248: PUSH
113249: EMPTY
113250: LIST
113251: LIST
113252: PUSH
113253: EMPTY
113254: LIST
113255: LIST
113256: LIST
113257: LIST
113258: LIST
113259: PPUSH
113260: CALL_OW 72
113264: ST_TO_ADDR
// if not defenders and not solds then
113265: LD_VAR 0 2
113269: NOT
113270: PUSH
113271: LD_VAR 0 8
113275: NOT
113276: AND
113277: IFFALSE 113281
// exit ;
113279: GO 115051
// depot_under_attack := false ;
113281: LD_ADDR_VAR 0 16
113285: PUSH
113286: LD_INT 0
113288: ST_TO_ADDR
// sold_defenders := [ ] ;
113289: LD_ADDR_VAR 0 17
113293: PUSH
113294: EMPTY
113295: ST_TO_ADDR
// if mechs then
113296: LD_VAR 0 12
113300: IFFALSE 113453
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
113302: LD_ADDR_VAR 0 4
113306: PUSH
113307: LD_VAR 0 2
113311: PPUSH
113312: LD_INT 21
113314: PUSH
113315: LD_INT 2
113317: PUSH
113318: EMPTY
113319: LIST
113320: LIST
113321: PPUSH
113322: CALL_OW 72
113326: PUSH
113327: FOR_IN
113328: IFFALSE 113451
// begin if GetTag ( i ) <> 20 then
113330: LD_VAR 0 4
113334: PPUSH
113335: CALL_OW 110
113339: PUSH
113340: LD_INT 20
113342: NONEQUAL
113343: IFFALSE 113357
// SetTag ( i , 20 ) ;
113345: LD_VAR 0 4
113349: PPUSH
113350: LD_INT 20
113352: PPUSH
113353: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
113357: LD_VAR 0 4
113361: PPUSH
113362: CALL_OW 263
113366: PUSH
113367: LD_INT 1
113369: EQUAL
113370: PUSH
113371: LD_VAR 0 4
113375: PPUSH
113376: CALL_OW 311
113380: NOT
113381: AND
113382: IFFALSE 113449
// begin un := mechs [ 1 ] ;
113384: LD_ADDR_VAR 0 10
113388: PUSH
113389: LD_VAR 0 12
113393: PUSH
113394: LD_INT 1
113396: ARRAY
113397: ST_TO_ADDR
// ComExit ( un ) ;
113398: LD_VAR 0 10
113402: PPUSH
113403: CALL 85647 0 1
// AddComEnterUnit ( un , i ) ;
113407: LD_VAR 0 10
113411: PPUSH
113412: LD_VAR 0 4
113416: PPUSH
113417: CALL_OW 180
// SetTag ( un , 19 ) ;
113421: LD_VAR 0 10
113425: PPUSH
113426: LD_INT 19
113428: PPUSH
113429: CALL_OW 109
// mechs := mechs diff un ;
113433: LD_ADDR_VAR 0 12
113437: PUSH
113438: LD_VAR 0 12
113442: PUSH
113443: LD_VAR 0 10
113447: DIFF
113448: ST_TO_ADDR
// end ; end ;
113449: GO 113327
113451: POP
113452: POP
// if solds then
113453: LD_VAR 0 8
113457: IFFALSE 113516
// for i in solds do
113459: LD_ADDR_VAR 0 4
113463: PUSH
113464: LD_VAR 0 8
113468: PUSH
113469: FOR_IN
113470: IFFALSE 113514
// if not GetTag ( i ) then
113472: LD_VAR 0 4
113476: PPUSH
113477: CALL_OW 110
113481: NOT
113482: IFFALSE 113512
// begin defenders := defenders union i ;
113484: LD_ADDR_VAR 0 2
113488: PUSH
113489: LD_VAR 0 2
113493: PUSH
113494: LD_VAR 0 4
113498: UNION
113499: ST_TO_ADDR
// SetTag ( i , 18 ) ;
113500: LD_VAR 0 4
113504: PPUSH
113505: LD_INT 18
113507: PPUSH
113508: CALL_OW 109
// end ;
113512: GO 113469
113514: POP
113515: POP
// repeat wait ( 0 0$2 ) ;
113516: LD_INT 70
113518: PPUSH
113519: CALL_OW 67
// enemy := mc_scan [ base ] ;
113523: LD_ADDR_VAR 0 21
113527: PUSH
113528: LD_EXP 73
113532: PUSH
113533: LD_VAR 0 1
113537: ARRAY
113538: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113539: LD_EXP 50
113543: PUSH
113544: LD_VAR 0 1
113548: ARRAY
113549: NOT
113550: PUSH
113551: LD_EXP 50
113555: PUSH
113556: LD_VAR 0 1
113560: ARRAY
113561: PUSH
113562: EMPTY
113563: EQUAL
113564: OR
113565: IFFALSE 113602
// begin for i in defenders do
113567: LD_ADDR_VAR 0 4
113571: PUSH
113572: LD_VAR 0 2
113576: PUSH
113577: FOR_IN
113578: IFFALSE 113591
// ComStop ( i ) ;
113580: LD_VAR 0 4
113584: PPUSH
113585: CALL_OW 141
113589: GO 113577
113591: POP
113592: POP
// defenders := [ ] ;
113593: LD_ADDR_VAR 0 2
113597: PUSH
113598: EMPTY
113599: ST_TO_ADDR
// exit ;
113600: GO 115051
// end ; for i in defenders do
113602: LD_ADDR_VAR 0 4
113606: PUSH
113607: LD_VAR 0 2
113611: PUSH
113612: FOR_IN
113613: IFFALSE 114511
// begin e := NearestUnitToUnit ( enemy , i ) ;
113615: LD_ADDR_VAR 0 13
113619: PUSH
113620: LD_VAR 0 21
113624: PPUSH
113625: LD_VAR 0 4
113629: PPUSH
113630: CALL_OW 74
113634: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113635: LD_ADDR_VAR 0 7
113639: PUSH
113640: LD_EXP 50
113644: PUSH
113645: LD_VAR 0 1
113649: ARRAY
113650: PPUSH
113651: LD_INT 2
113653: PUSH
113654: LD_INT 30
113656: PUSH
113657: LD_INT 0
113659: PUSH
113660: EMPTY
113661: LIST
113662: LIST
113663: PUSH
113664: LD_INT 30
113666: PUSH
113667: LD_INT 1
113669: PUSH
113670: EMPTY
113671: LIST
113672: LIST
113673: PUSH
113674: EMPTY
113675: LIST
113676: LIST
113677: LIST
113678: PPUSH
113679: CALL_OW 72
113683: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
113684: LD_ADDR_VAR 0 16
113688: PUSH
113689: LD_VAR 0 7
113693: NOT
113694: PUSH
113695: LD_VAR 0 7
113699: PPUSH
113700: LD_INT 3
113702: PUSH
113703: LD_INT 24
113705: PUSH
113706: LD_INT 600
113708: PUSH
113709: EMPTY
113710: LIST
113711: LIST
113712: PUSH
113713: EMPTY
113714: LIST
113715: LIST
113716: PPUSH
113717: CALL_OW 72
113721: OR
113722: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
113723: LD_VAR 0 4
113727: PPUSH
113728: CALL_OW 247
113732: PUSH
113733: LD_INT 2
113735: DOUBLE
113736: EQUAL
113737: IFTRUE 113741
113739: GO 114137
113741: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
113742: LD_VAR 0 4
113746: PPUSH
113747: CALL_OW 256
113751: PUSH
113752: LD_INT 1000
113754: EQUAL
113755: PUSH
113756: LD_VAR 0 4
113760: PPUSH
113761: LD_VAR 0 13
113765: PPUSH
113766: CALL_OW 296
113770: PUSH
113771: LD_INT 40
113773: LESS
113774: PUSH
113775: LD_VAR 0 13
113779: PPUSH
113780: LD_EXP 75
113784: PUSH
113785: LD_VAR 0 1
113789: ARRAY
113790: PPUSH
113791: CALL_OW 308
113795: OR
113796: AND
113797: IFFALSE 113919
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
113799: LD_VAR 0 4
113803: PPUSH
113804: CALL_OW 262
113808: PUSH
113809: LD_INT 1
113811: EQUAL
113812: PUSH
113813: LD_VAR 0 4
113817: PPUSH
113818: CALL_OW 261
113822: PUSH
113823: LD_INT 30
113825: LESS
113826: AND
113827: PUSH
113828: LD_VAR 0 7
113832: AND
113833: IFFALSE 113903
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
113835: LD_VAR 0 4
113839: PPUSH
113840: LD_VAR 0 7
113844: PPUSH
113845: LD_VAR 0 4
113849: PPUSH
113850: CALL_OW 74
113854: PPUSH
113855: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
113859: LD_VAR 0 4
113863: PPUSH
113864: LD_VAR 0 7
113868: PPUSH
113869: LD_VAR 0 4
113873: PPUSH
113874: CALL_OW 74
113878: PPUSH
113879: CALL_OW 296
113883: PUSH
113884: LD_INT 6
113886: LESS
113887: IFFALSE 113901
// SetFuel ( i , 100 ) ;
113889: LD_VAR 0 4
113893: PPUSH
113894: LD_INT 100
113896: PPUSH
113897: CALL_OW 240
// end else
113901: GO 113917
// ComAttackUnit ( i , e ) ;
113903: LD_VAR 0 4
113907: PPUSH
113908: LD_VAR 0 13
113912: PPUSH
113913: CALL_OW 115
// end else
113917: GO 114020
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
113919: LD_VAR 0 13
113923: PPUSH
113924: LD_EXP 75
113928: PUSH
113929: LD_VAR 0 1
113933: ARRAY
113934: PPUSH
113935: CALL_OW 308
113939: NOT
113940: PUSH
113941: LD_VAR 0 4
113945: PPUSH
113946: LD_VAR 0 13
113950: PPUSH
113951: CALL_OW 296
113955: PUSH
113956: LD_INT 40
113958: GREATEREQUAL
113959: AND
113960: PUSH
113961: LD_VAR 0 4
113965: PPUSH
113966: CALL_OW 256
113970: PUSH
113971: LD_INT 650
113973: LESSEQUAL
113974: OR
113975: PUSH
113976: LD_VAR 0 4
113980: PPUSH
113981: LD_EXP 74
113985: PUSH
113986: LD_VAR 0 1
113990: ARRAY
113991: PPUSH
113992: CALL_OW 308
113996: NOT
113997: AND
113998: IFFALSE 114020
// ComMoveToArea ( i , mc_parking [ base ] ) ;
114000: LD_VAR 0 4
114004: PPUSH
114005: LD_EXP 74
114009: PUSH
114010: LD_VAR 0 1
114014: ARRAY
114015: PPUSH
114016: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
114020: LD_VAR 0 4
114024: PPUSH
114025: CALL_OW 256
114029: PUSH
114030: LD_INT 1000
114032: LESS
114033: PUSH
114034: LD_VAR 0 4
114038: PPUSH
114039: CALL_OW 263
114043: PUSH
114044: LD_INT 1
114046: EQUAL
114047: AND
114048: PUSH
114049: LD_VAR 0 4
114053: PPUSH
114054: CALL_OW 311
114058: AND
114059: PUSH
114060: LD_VAR 0 4
114064: PPUSH
114065: LD_EXP 74
114069: PUSH
114070: LD_VAR 0 1
114074: ARRAY
114075: PPUSH
114076: CALL_OW 308
114080: AND
114081: IFFALSE 114135
// begin mech := IsDrivenBy ( i ) ;
114083: LD_ADDR_VAR 0 9
114087: PUSH
114088: LD_VAR 0 4
114092: PPUSH
114093: CALL_OW 311
114097: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
114098: LD_VAR 0 9
114102: PPUSH
114103: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
114107: LD_VAR 0 9
114111: PPUSH
114112: LD_VAR 0 4
114116: PPUSH
114117: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
114121: LD_VAR 0 9
114125: PPUSH
114126: LD_VAR 0 4
114130: PPUSH
114131: CALL_OW 180
// end ; end ; unit_human :
114135: GO 114482
114137: LD_INT 1
114139: DOUBLE
114140: EQUAL
114141: IFTRUE 114145
114143: GO 114481
114145: POP
// begin b := IsInUnit ( i ) ;
114146: LD_ADDR_VAR 0 18
114150: PUSH
114151: LD_VAR 0 4
114155: PPUSH
114156: CALL_OW 310
114160: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
114161: LD_ADDR_VAR 0 19
114165: PUSH
114166: LD_VAR 0 18
114170: NOT
114171: PUSH
114172: LD_VAR 0 18
114176: PPUSH
114177: CALL_OW 266
114181: PUSH
114182: LD_INT 32
114184: PUSH
114185: LD_INT 31
114187: PUSH
114188: EMPTY
114189: LIST
114190: LIST
114191: IN
114192: OR
114193: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
114194: LD_VAR 0 18
114198: PPUSH
114199: CALL_OW 266
114203: PUSH
114204: LD_INT 5
114206: EQUAL
114207: PUSH
114208: LD_VAR 0 4
114212: PPUSH
114213: CALL_OW 257
114217: PUSH
114218: LD_INT 1
114220: PUSH
114221: LD_INT 2
114223: PUSH
114224: LD_INT 3
114226: PUSH
114227: LD_INT 4
114229: PUSH
114230: EMPTY
114231: LIST
114232: LIST
114233: LIST
114234: LIST
114235: IN
114236: AND
114237: IFFALSE 114274
// begin class := AllowSpecClass ( i ) ;
114239: LD_ADDR_VAR 0 20
114243: PUSH
114244: LD_VAR 0 4
114248: PPUSH
114249: CALL 50364 0 1
114253: ST_TO_ADDR
// if class then
114254: LD_VAR 0 20
114258: IFFALSE 114274
// ComChangeProfession ( i , class ) ;
114260: LD_VAR 0 4
114264: PPUSH
114265: LD_VAR 0 20
114269: PPUSH
114270: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
114274: LD_VAR 0 16
114278: PUSH
114279: LD_VAR 0 2
114283: PPUSH
114284: LD_INT 21
114286: PUSH
114287: LD_INT 2
114289: PUSH
114290: EMPTY
114291: LIST
114292: LIST
114293: PPUSH
114294: CALL_OW 72
114298: PUSH
114299: LD_INT 1
114301: LESSEQUAL
114302: OR
114303: PUSH
114304: LD_VAR 0 19
114308: AND
114309: PUSH
114310: LD_VAR 0 4
114314: PUSH
114315: LD_VAR 0 17
114319: IN
114320: NOT
114321: AND
114322: IFFALSE 114415
// begin if b then
114324: LD_VAR 0 18
114328: IFFALSE 114377
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
114330: LD_VAR 0 18
114334: PPUSH
114335: LD_VAR 0 21
114339: PPUSH
114340: LD_VAR 0 18
114344: PPUSH
114345: CALL_OW 74
114349: PPUSH
114350: CALL_OW 296
114354: PUSH
114355: LD_INT 10
114357: LESS
114358: PUSH
114359: LD_VAR 0 18
114363: PPUSH
114364: CALL_OW 461
114368: PUSH
114369: LD_INT 7
114371: NONEQUAL
114372: AND
114373: IFFALSE 114377
// continue ;
114375: GO 113612
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
114377: LD_ADDR_VAR 0 17
114381: PUSH
114382: LD_VAR 0 17
114386: PPUSH
114387: LD_VAR 0 17
114391: PUSH
114392: LD_INT 1
114394: PLUS
114395: PPUSH
114396: LD_VAR 0 4
114400: PPUSH
114401: CALL_OW 1
114405: ST_TO_ADDR
// ComExitBuilding ( i ) ;
114406: LD_VAR 0 4
114410: PPUSH
114411: CALL_OW 122
// end ; if sold_defenders then
114415: LD_VAR 0 17
114419: IFFALSE 114479
// if i in sold_defenders then
114421: LD_VAR 0 4
114425: PUSH
114426: LD_VAR 0 17
114430: IN
114431: IFFALSE 114479
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
114433: LD_VAR 0 4
114437: PPUSH
114438: CALL_OW 314
114442: NOT
114443: PUSH
114444: LD_VAR 0 4
114448: PPUSH
114449: LD_VAR 0 13
114453: PPUSH
114454: CALL_OW 296
114458: PUSH
114459: LD_INT 30
114461: LESS
114462: AND
114463: IFFALSE 114479
// ComAttackUnit ( i , e ) ;
114465: LD_VAR 0 4
114469: PPUSH
114470: LD_VAR 0 13
114474: PPUSH
114475: CALL_OW 115
// end ; end ; end ;
114479: GO 114482
114481: POP
// if IsDead ( i ) then
114482: LD_VAR 0 4
114486: PPUSH
114487: CALL_OW 301
114491: IFFALSE 114509
// defenders := defenders diff i ;
114493: LD_ADDR_VAR 0 2
114497: PUSH
114498: LD_VAR 0 2
114502: PUSH
114503: LD_VAR 0 4
114507: DIFF
114508: ST_TO_ADDR
// end ;
114509: GO 113612
114511: POP
114512: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
114513: LD_VAR 0 21
114517: NOT
114518: PUSH
114519: LD_VAR 0 2
114523: NOT
114524: OR
114525: PUSH
114526: LD_EXP 50
114530: PUSH
114531: LD_VAR 0 1
114535: ARRAY
114536: NOT
114537: OR
114538: IFFALSE 113516
// MC_Reset ( base , 18 ) ;
114540: LD_VAR 0 1
114544: PPUSH
114545: LD_INT 18
114547: PPUSH
114548: CALL 22106 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
114552: LD_ADDR_VAR 0 2
114556: PUSH
114557: LD_VAR 0 2
114561: PUSH
114562: LD_VAR 0 2
114566: PPUSH
114567: LD_INT 2
114569: PUSH
114570: LD_INT 25
114572: PUSH
114573: LD_INT 1
114575: PUSH
114576: EMPTY
114577: LIST
114578: LIST
114579: PUSH
114580: LD_INT 25
114582: PUSH
114583: LD_INT 5
114585: PUSH
114586: EMPTY
114587: LIST
114588: LIST
114589: PUSH
114590: LD_INT 25
114592: PUSH
114593: LD_INT 8
114595: PUSH
114596: EMPTY
114597: LIST
114598: LIST
114599: PUSH
114600: LD_INT 25
114602: PUSH
114603: LD_INT 9
114605: PUSH
114606: EMPTY
114607: LIST
114608: LIST
114609: PUSH
114610: EMPTY
114611: LIST
114612: LIST
114613: LIST
114614: LIST
114615: LIST
114616: PPUSH
114617: CALL_OW 72
114621: DIFF
114622: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
114623: LD_VAR 0 21
114627: NOT
114628: PUSH
114629: LD_VAR 0 2
114633: PPUSH
114634: LD_INT 21
114636: PUSH
114637: LD_INT 2
114639: PUSH
114640: EMPTY
114641: LIST
114642: LIST
114643: PPUSH
114644: CALL_OW 72
114648: AND
114649: IFFALSE 114987
// begin tmp := FilterByTag ( defenders , 19 ) ;
114651: LD_ADDR_VAR 0 11
114655: PUSH
114656: LD_VAR 0 2
114660: PPUSH
114661: LD_INT 19
114663: PPUSH
114664: CALL 82833 0 2
114668: ST_TO_ADDR
// if tmp then
114669: LD_VAR 0 11
114673: IFFALSE 114743
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
114675: LD_ADDR_VAR 0 11
114679: PUSH
114680: LD_VAR 0 11
114684: PPUSH
114685: LD_INT 25
114687: PUSH
114688: LD_INT 3
114690: PUSH
114691: EMPTY
114692: LIST
114693: LIST
114694: PPUSH
114695: CALL_OW 72
114699: ST_TO_ADDR
// if tmp then
114700: LD_VAR 0 11
114704: IFFALSE 114743
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
114706: LD_ADDR_EXP 62
114710: PUSH
114711: LD_EXP 62
114715: PPUSH
114716: LD_VAR 0 1
114720: PPUSH
114721: LD_EXP 62
114725: PUSH
114726: LD_VAR 0 1
114730: ARRAY
114731: PUSH
114732: LD_VAR 0 11
114736: UNION
114737: PPUSH
114738: CALL_OW 1
114742: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
114743: LD_VAR 0 1
114747: PPUSH
114748: LD_INT 19
114750: PPUSH
114751: CALL 22106 0 2
// repeat wait ( 0 0$1 ) ;
114755: LD_INT 35
114757: PPUSH
114758: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114762: LD_EXP 50
114766: PUSH
114767: LD_VAR 0 1
114771: ARRAY
114772: NOT
114773: PUSH
114774: LD_EXP 50
114778: PUSH
114779: LD_VAR 0 1
114783: ARRAY
114784: PUSH
114785: EMPTY
114786: EQUAL
114787: OR
114788: IFFALSE 114825
// begin for i in defenders do
114790: LD_ADDR_VAR 0 4
114794: PUSH
114795: LD_VAR 0 2
114799: PUSH
114800: FOR_IN
114801: IFFALSE 114814
// ComStop ( i ) ;
114803: LD_VAR 0 4
114807: PPUSH
114808: CALL_OW 141
114812: GO 114800
114814: POP
114815: POP
// defenders := [ ] ;
114816: LD_ADDR_VAR 0 2
114820: PUSH
114821: EMPTY
114822: ST_TO_ADDR
// exit ;
114823: GO 115051
// end ; for i in defenders do
114825: LD_ADDR_VAR 0 4
114829: PUSH
114830: LD_VAR 0 2
114834: PUSH
114835: FOR_IN
114836: IFFALSE 114925
// begin if not IsInArea ( i , mc_parking [ base ] ) then
114838: LD_VAR 0 4
114842: PPUSH
114843: LD_EXP 74
114847: PUSH
114848: LD_VAR 0 1
114852: ARRAY
114853: PPUSH
114854: CALL_OW 308
114858: NOT
114859: IFFALSE 114883
// ComMoveToArea ( i , mc_parking [ base ] ) else
114861: LD_VAR 0 4
114865: PPUSH
114866: LD_EXP 74
114870: PUSH
114871: LD_VAR 0 1
114875: ARRAY
114876: PPUSH
114877: CALL_OW 113
114881: GO 114923
// if GetControl ( i ) = control_manual then
114883: LD_VAR 0 4
114887: PPUSH
114888: CALL_OW 263
114892: PUSH
114893: LD_INT 1
114895: EQUAL
114896: IFFALSE 114923
// if IsDrivenBy ( i ) then
114898: LD_VAR 0 4
114902: PPUSH
114903: CALL_OW 311
114907: IFFALSE 114923
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
114909: LD_VAR 0 4
114913: PPUSH
114914: CALL_OW 311
114918: PPUSH
114919: CALL_OW 121
// end ;
114923: GO 114835
114925: POP
114926: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
114927: LD_VAR 0 2
114931: PPUSH
114932: LD_INT 95
114934: PUSH
114935: LD_EXP 74
114939: PUSH
114940: LD_VAR 0 1
114944: ARRAY
114945: PUSH
114946: EMPTY
114947: LIST
114948: LIST
114949: PPUSH
114950: CALL_OW 72
114954: PUSH
114955: LD_VAR 0 2
114959: EQUAL
114960: PUSH
114961: LD_EXP 73
114965: PUSH
114966: LD_VAR 0 1
114970: ARRAY
114971: OR
114972: PUSH
114973: LD_EXP 50
114977: PUSH
114978: LD_VAR 0 1
114982: ARRAY
114983: NOT
114984: OR
114985: IFFALSE 114755
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
114987: LD_ADDR_EXP 72
114991: PUSH
114992: LD_EXP 72
114996: PPUSH
114997: LD_VAR 0 1
115001: PPUSH
115002: LD_VAR 0 2
115006: PPUSH
115007: LD_INT 21
115009: PUSH
115010: LD_INT 2
115012: PUSH
115013: EMPTY
115014: LIST
115015: LIST
115016: PPUSH
115017: CALL_OW 72
115021: PPUSH
115022: CALL_OW 1
115026: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
115027: LD_VAR 0 1
115031: PPUSH
115032: LD_INT 19
115034: PPUSH
115035: CALL 22106 0 2
// MC_Reset ( base , 20 ) ;
115039: LD_VAR 0 1
115043: PPUSH
115044: LD_INT 20
115046: PPUSH
115047: CALL 22106 0 2
// end ; end_of_file
115051: LD_VAR 0 3
115055: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
115056: LD_VAR 0 1
115060: PUSH
115061: LD_INT 200
115063: DOUBLE
115064: GREATEREQUAL
115065: IFFALSE 115073
115067: LD_INT 299
115069: DOUBLE
115070: LESSEQUAL
115071: IFTRUE 115075
115073: GO 115107
115075: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
115076: LD_VAR 0 1
115080: PPUSH
115081: LD_VAR 0 2
115085: PPUSH
115086: LD_VAR 0 3
115090: PPUSH
115091: LD_VAR 0 4
115095: PPUSH
115096: LD_VAR 0 5
115100: PPUSH
115101: CALL 103493 0 5
115105: GO 115184
115107: LD_INT 300
115109: DOUBLE
115110: GREATEREQUAL
115111: IFFALSE 115119
115113: LD_INT 399
115115: DOUBLE
115116: LESSEQUAL
115117: IFTRUE 115121
115119: GO 115183
115121: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
115122: LD_VAR 0 1
115126: PPUSH
115127: LD_VAR 0 2
115131: PPUSH
115132: LD_VAR 0 3
115136: PPUSH
115137: LD_VAR 0 4
115141: PPUSH
115142: LD_VAR 0 5
115146: PPUSH
115147: LD_VAR 0 6
115151: PPUSH
115152: LD_VAR 0 7
115156: PPUSH
115157: LD_VAR 0 8
115161: PPUSH
115162: LD_VAR 0 9
115166: PPUSH
115167: LD_VAR 0 10
115171: PPUSH
115172: LD_VAR 0 11
115176: PPUSH
115177: CALL 101135 0 11
115181: GO 115184
115183: POP
// end ;
115184: PPOPN 11
115186: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
115187: LD_VAR 0 1
115191: PPUSH
115192: LD_VAR 0 2
115196: PPUSH
115197: LD_VAR 0 3
115201: PPUSH
115202: LD_VAR 0 4
115206: PPUSH
115207: LD_VAR 0 5
115211: PPUSH
115212: CALL 103229 0 5
// end ; end_of_file
115216: PPOPN 5
115218: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
115219: LD_VAR 0 1
115223: PPUSH
115224: LD_VAR 0 2
115228: PPUSH
115229: LD_VAR 0 3
115233: PPUSH
115234: LD_VAR 0 4
115238: PPUSH
115239: LD_VAR 0 5
115243: PPUSH
115244: LD_VAR 0 6
115248: PPUSH
115249: CALL 88828 0 6
// end ;
115253: PPOPN 6
115255: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
115256: CALL 88803 0 0
// end ;
115260: PPOPN 1
115262: END
