// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17984 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 82805 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2605 0 0
// MC_Start ( ) ;
  85: CALL 20156 0 0
// Action ;
  89: CALL 8540 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 41894 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 41894 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 41894 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42320 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42212 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42212 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 48648 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 48648 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 48648 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 48648 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 48648 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 48648 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 48648 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 48648 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 48648 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 48648 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 48648 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 48648 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 48648 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 48648 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 48648 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_lock
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10c_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1540: LD_STRING 10_lock
1542: PPUSH
1543: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1547: LD_STRING 10c_lock
1549: PPUSH
1550: CALL_OW 40
// for i in tmp do
1554: LD_ADDR_VAR 0 2
1558: PUSH
1559: LD_VAR 0 5
1563: PUSH
1564: FOR_IN
1565: IFFALSE 1603
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1567: LD_VAR 0 2
1571: PPUSH
1572: CALL_OW 257
1576: PUSH
1577: LD_INT 8
1579: PUSH
1580: LD_INT 2
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: IN
1587: IFFALSE 1601
// SetClass ( i , class_soldier ) ;
1589: LD_VAR 0 2
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: CALL_OW 336
1601: GO 1564
1603: POP
1604: POP
// if tmp < 12 then
1605: LD_VAR 0 5
1609: PUSH
1610: LD_INT 12
1612: LESS
1613: IFFALSE 1707
// begin k := 16 - tmp ;
1615: LD_ADDR_VAR 0 3
1619: PUSH
1620: LD_INT 16
1622: PUSH
1623: LD_VAR 0 5
1627: MINUS
1628: ST_TO_ADDR
// for i = 1 to k do
1629: LD_ADDR_VAR 0 2
1633: PUSH
1634: DOUBLE
1635: LD_INT 1
1637: DEC
1638: ST_TO_ADDR
1639: LD_VAR 0 3
1643: PUSH
1644: FOR_TO
1645: IFFALSE 1705
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1647: LD_INT 0
1649: PPUSH
1650: LD_INT 1
1652: PUSH
1653: LD_INT 1
1655: PUSH
1656: LD_INT 3
1658: PUSH
1659: LD_INT 4
1661: PUSH
1662: EMPTY
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: PUSH
1668: LD_INT 1
1670: PPUSH
1671: LD_INT 4
1673: PPUSH
1674: CALL_OW 12
1678: ARRAY
1679: PPUSH
1680: LD_INT 6
1682: PPUSH
1683: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1687: LD_ADDR_VAR 0 5
1691: PUSH
1692: LD_VAR 0 5
1696: PUSH
1697: CALL_OW 44
1701: ADD
1702: ST_TO_ADDR
// end ;
1703: GO 1644
1705: POP
1706: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1707: LD_ADDR_EXP 19
1711: PUSH
1712: LD_STRING 1
1714: PPUSH
1715: LD_INT 12
1717: PPUSH
1718: LD_INT 12
1720: PPUSH
1721: LD_INT -5
1723: PUSH
1724: LD_EXP 21
1728: PUSH
1729: LD_INT -2
1731: PUSH
1732: LD_INT -3
1734: PUSH
1735: LD_INT -5
1737: PUSH
1738: EMPTY
1739: LIST
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: PUSH
1745: LD_VAR 0 5
1749: ADD
1750: PUSH
1751: LD_INT -6
1753: PUSH
1754: LD_INT -4
1756: PUSH
1757: LD_EXP 30
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: LIST
1766: ADD
1767: PPUSH
1768: LD_INT 1
1770: PUSH
1771: LD_INT 4
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: PUSH
1778: LD_INT 3
1780: PUSH
1781: LD_INT 0
1783: PUSH
1784: LD_INT 5
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: LIST
1791: PUSH
1792: LD_INT 4
1794: PUSH
1795: LD_INT 0
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: PUSH
1806: LD_INT 5
1808: PUSH
1809: LD_INT 0
1811: PUSH
1812: LD_INT 2
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 42
1830: ST_TO_ADDR
// others := tmp diff selected ;
1831: LD_ADDR_VAR 0 8
1835: PUSH
1836: LD_VAR 0 5
1840: PUSH
1841: LD_EXP 19
1845: DIFF
1846: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1847: LD_ADDR_VAR 0 8
1851: PUSH
1852: LD_VAR 0 8
1856: PUSH
1857: LD_EXP 22
1861: PUSH
1862: LD_EXP 23
1866: PUSH
1867: LD_EXP 24
1871: PUSH
1872: LD_EXP 25
1876: PUSH
1877: LD_EXP 26
1881: PUSH
1882: LD_EXP 27
1886: PUSH
1887: LD_EXP 28
1891: PUSH
1892: LD_EXP 29
1896: PUSH
1897: LD_EXP 31
1901: PUSH
1902: LD_EXP 32
1906: PUSH
1907: LD_EXP 33
1911: PUSH
1912: LD_EXP 34
1916: PUSH
1917: EMPTY
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: DIFF
1931: ST_TO_ADDR
// if others then
1932: LD_VAR 0 8
1936: IFFALSE 1950
// SaveCharacters ( others , 11_others ) ;
1938: LD_VAR 0 8
1942: PPUSH
1943: LD_STRING 11_others
1945: PPUSH
1946: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1950: LD_ADDR_VAR 0 6
1954: PUSH
1955: LD_INT 3
1957: PUSH
1958: LD_INT 1
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 4
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: LIST
1971: LIST
1972: PUSH
1973: LD_INT 2
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 1
1981: PUSH
1982: LD_INT 5
1984: PUSH
1985: EMPTY
1986: LIST
1987: LIST
1988: LIST
1989: LIST
1990: PUSH
1991: LD_INT 4
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 1
1999: PUSH
2000: LD_INT 5
2002: PUSH
2003: EMPTY
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 2
2011: PUSH
2012: LD_INT 1
2014: PUSH
2015: LD_INT 1
2017: PUSH
2018: LD_INT 7
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: LIST
2025: LIST
2026: PUSH
2027: LD_INT 3
2029: PUSH
2030: LD_INT 2
2032: PUSH
2033: LD_INT 1
2035: PUSH
2036: LD_INT 7
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: PUSH
2045: EMPTY
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: ST_TO_ADDR
// for i in JMM ^ selected do
2052: LD_ADDR_VAR 0 2
2056: PUSH
2057: LD_EXP 21
2061: PUSH
2062: LD_EXP 19
2066: ADD
2067: PUSH
2068: FOR_IN
2069: IFFALSE 2259
// begin if GetClass ( i ) = 3 then
2071: LD_VAR 0 2
2075: PPUSH
2076: CALL_OW 257
2080: PUSH
2081: LD_INT 3
2083: EQUAL
2084: IFFALSE 2242
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2086: LD_ADDR_OWVAR 37
2090: PUSH
2091: LD_VAR 0 6
2095: PUSH
2096: LD_INT 1
2098: ARRAY
2099: PUSH
2100: LD_INT 1
2102: ARRAY
2103: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2104: LD_ADDR_OWVAR 39
2108: PUSH
2109: LD_VAR 0 6
2113: PUSH
2114: LD_INT 1
2116: ARRAY
2117: PUSH
2118: LD_INT 2
2120: ARRAY
2121: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2122: LD_ADDR_OWVAR 38
2126: PUSH
2127: LD_VAR 0 6
2131: PUSH
2132: LD_INT 1
2134: ARRAY
2135: PUSH
2136: LD_INT 3
2138: ARRAY
2139: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2140: LD_ADDR_OWVAR 40
2144: PUSH
2145: LD_VAR 0 6
2149: PUSH
2150: LD_INT 1
2152: ARRAY
2153: PUSH
2154: LD_INT 4
2156: ARRAY
2157: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2158: LD_ADDR_VAR 0 6
2162: PUSH
2163: LD_VAR 0 6
2167: PPUSH
2168: LD_INT 1
2170: PPUSH
2171: CALL_OW 3
2175: ST_TO_ADDR
// veh := CreateVehicle ;
2176: LD_ADDR_VAR 0 7
2180: PUSH
2181: CALL_OW 45
2185: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2186: LD_VAR 0 7
2190: PPUSH
2191: LD_INT 8
2193: PPUSH
2194: LD_INT 0
2196: PPUSH
2197: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2201: LD_VAR 0 2
2205: PPUSH
2206: LD_VAR 0 7
2210: PPUSH
2211: CALL_OW 52
// if i = JMM then
2215: LD_VAR 0 2
2219: PUSH
2220: LD_EXP 21
2224: EQUAL
2225: IFFALSE 2240
// SetMark ( veh , - 1 ) ;
2227: LD_VAR 0 7
2231: PPUSH
2232: LD_INT 1
2234: NEG
2235: PPUSH
2236: CALL_OW 242
// end else
2240: GO 2257
// PlaceUnitArea ( i , am_hum_start , false ) ;
2242: LD_VAR 0 2
2246: PPUSH
2247: LD_INT 9
2249: PPUSH
2250: LD_INT 0
2252: PPUSH
2253: CALL_OW 49
// end ;
2257: GO 2068
2259: POP
2260: POP
// vc_chassis := us_medium_tracked ;
2261: LD_ADDR_OWVAR 37
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// vc_engine := engine_solar ;
2269: LD_ADDR_OWVAR 39
2273: PUSH
2274: LD_INT 2
2276: ST_TO_ADDR
// vc_control := control_computer ;
2277: LD_ADDR_OWVAR 38
2281: PUSH
2282: LD_INT 3
2284: ST_TO_ADDR
// vc_weapon := us_radar ;
2285: LD_ADDR_OWVAR 40
2289: PUSH
2290: LD_INT 11
2292: ST_TO_ADDR
// veh := CreateVehicle ;
2293: LD_ADDR_VAR 0 7
2297: PUSH
2298: CALL_OW 45
2302: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2303: LD_VAR 0 7
2307: PPUSH
2308: LD_INT 87
2310: PPUSH
2311: LD_INT 142
2313: PPUSH
2314: LD_INT 0
2316: PPUSH
2317: CALL_OW 48
// end ;
2321: LD_VAR 0 1
2325: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2326: LD_INT 0
2328: PPUSH
2329: PPUSH
2330: PPUSH
2331: PPUSH
// uc_side := 1 ;
2332: LD_ADDR_OWVAR 20
2336: PUSH
2337: LD_INT 1
2339: ST_TO_ADDR
// uc_nation := 1 ;
2340: LD_ADDR_OWVAR 21
2344: PUSH
2345: LD_INT 1
2347: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2348: LD_ADDR_VAR 0 3
2352: PUSH
2353: LD_INT 3
2355: PUSH
2356: LD_INT 1
2358: PUSH
2359: LD_INT 3
2361: PUSH
2362: LD_INT 5
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 3
2373: PUSH
2374: LD_INT 1
2376: PUSH
2377: LD_INT 3
2379: PUSH
2380: LD_INT 7
2382: PUSH
2383: EMPTY
2384: LIST
2385: LIST
2386: LIST
2387: LIST
2388: PUSH
2389: LD_INT 3
2391: PUSH
2392: LD_INT 1
2394: PUSH
2395: LD_INT 3
2397: PUSH
2398: LD_INT 7
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: LIST
2405: LIST
2406: PUSH
2407: LD_INT 3
2409: PUSH
2410: LD_INT 1
2412: PUSH
2413: LD_INT 3
2415: PUSH
2416: LD_INT 11
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: LIST
2423: LIST
2424: PUSH
2425: LD_INT 4
2427: PUSH
2428: LD_INT 1
2430: PUSH
2431: LD_INT 3
2433: PUSH
2434: LD_INT 6
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: LIST
2441: LIST
2442: PUSH
2443: LD_INT 4
2445: PUSH
2446: LD_INT 1
2448: PUSH
2449: LD_INT 3
2451: PUSH
2452: LD_INT 5
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: LIST
2467: LIST
2468: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2469: LD_ADDR_VAR 0 2
2473: PUSH
2474: DOUBLE
2475: LD_INT 1
2477: DEC
2478: ST_TO_ADDR
2479: LD_INT 7
2481: PUSH
2482: LD_OWVAR 67
2486: MINUS
2487: PUSH
2488: FOR_TO
2489: IFFALSE 2598
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2491: LD_ADDR_OWVAR 37
2495: PUSH
2496: LD_VAR 0 3
2500: PUSH
2501: LD_VAR 0 2
2505: ARRAY
2506: PUSH
2507: LD_INT 1
2509: ARRAY
2510: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2511: LD_ADDR_OWVAR 39
2515: PUSH
2516: LD_VAR 0 3
2520: PUSH
2521: LD_VAR 0 2
2525: ARRAY
2526: PUSH
2527: LD_INT 2
2529: ARRAY
2530: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2531: LD_ADDR_OWVAR 38
2535: PUSH
2536: LD_VAR 0 3
2540: PUSH
2541: LD_VAR 0 2
2545: ARRAY
2546: PUSH
2547: LD_INT 3
2549: ARRAY
2550: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2551: LD_ADDR_OWVAR 40
2555: PUSH
2556: LD_VAR 0 3
2560: PUSH
2561: LD_VAR 0 2
2565: ARRAY
2566: PUSH
2567: LD_INT 4
2569: ARRAY
2570: ST_TO_ADDR
// veh := CreateVehicle ;
2571: LD_ADDR_VAR 0 4
2575: PUSH
2576: CALL_OW 45
2580: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2581: LD_VAR 0 4
2585: PPUSH
2586: LD_INT 8
2588: PPUSH
2589: LD_INT 0
2591: PPUSH
2592: CALL_OW 49
// end ;
2596: GO 2488
2598: POP
2599: POP
// end ; end_of_file
2600: LD_VAR 0 1
2604: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2605: LD_INT 0
2607: PPUSH
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
2612: PPUSH
// if Difficulty = 1 then
2613: LD_OWVAR 67
2617: PUSH
2618: LD_INT 1
2620: EQUAL
2621: IFFALSE 2718
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2623: LD_ADDR_VAR 0 6
2627: PUSH
2628: LD_INT 129
2630: PUSH
2631: LD_INT 45
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: LD_INT 143
2640: PUSH
2641: LD_INT 58
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: LD_INT 184
2650: PUSH
2651: LD_INT 113
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 163
2660: PUSH
2661: LD_INT 107
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: LIST
2672: LIST
2673: ST_TO_ADDR
// for i in tmp do
2674: LD_ADDR_VAR 0 2
2678: PUSH
2679: LD_VAR 0 6
2683: PUSH
2684: FOR_IN
2685: IFFALSE 2716
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2687: LD_VAR 0 2
2691: PUSH
2692: LD_INT 1
2694: ARRAY
2695: PPUSH
2696: LD_VAR 0 2
2700: PUSH
2701: LD_INT 2
2703: ARRAY
2704: PPUSH
2705: CALL_OW 428
2709: PPUSH
2710: CALL_OW 64
2714: GO 2684
2716: POP
2717: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2718: LD_ADDR_VAR 0 2
2722: PUSH
2723: LD_INT 21
2725: PUSH
2726: LD_INT 3
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL_OW 69
2737: PUSH
2738: FOR_IN
2739: IFFALSE 2776
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2741: LD_VAR 0 2
2745: PPUSH
2746: LD_INT 5
2748: PUSH
2749: LD_INT 6
2751: PUSH
2752: LD_INT 7
2754: PUSH
2755: LD_INT 8
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_OWVAR 67
2768: ARRAY
2769: PPUSH
2770: CALL_OW 241
2774: GO 2738
2776: POP
2777: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2778: LD_ADDR_VAR 0 5
2782: PUSH
2783: LD_INT 5
2785: PUSH
2786: LD_INT 6
2788: PUSH
2789: LD_INT 7
2791: PUSH
2792: LD_INT 8
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: PUSH
2801: LD_OWVAR 67
2805: ARRAY
2806: ST_TO_ADDR
// uc_side := 2 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 2
2814: ST_TO_ADDR
// uc_nation := 2 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 2
2822: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2823: LD_ADDR_OWVAR 37
2827: PUSH
2828: LD_INT 14
2830: ST_TO_ADDR
// vc_engine := engine_siberite ;
2831: LD_ADDR_OWVAR 39
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// vc_control := control_manual ;
2839: LD_ADDR_OWVAR 38
2843: PUSH
2844: LD_INT 1
2846: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2847: LD_ADDR_OWVAR 40
2851: PUSH
2852: LD_INT 31
2854: ST_TO_ADDR
// for i = 1 to 3 do
2855: LD_ADDR_VAR 0 2
2859: PUSH
2860: DOUBLE
2861: LD_INT 1
2863: DEC
2864: ST_TO_ADDR
2865: LD_INT 3
2867: PUSH
2868: FOR_TO
2869: IFFALSE 2953
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2871: LD_INT 0
2873: PPUSH
2874: LD_INT 3
2876: PPUSH
2877: LD_VAR 0 5
2881: PPUSH
2882: CALL_OW 380
// un := CreateVehicle ;
2886: LD_ADDR_VAR 0 4
2890: PUSH
2891: CALL_OW 45
2895: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2896: LD_VAR 0 4
2900: PPUSH
2901: LD_INT 0
2903: PPUSH
2904: LD_INT 5
2906: PPUSH
2907: CALL_OW 12
2911: PPUSH
2912: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2916: LD_VAR 0 4
2920: PPUSH
2921: LD_INT 156
2923: PPUSH
2924: LD_INT 15
2926: PPUSH
2927: LD_INT 6
2929: PPUSH
2930: LD_INT 0
2932: PPUSH
2933: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2937: CALL_OW 44
2941: PPUSH
2942: LD_VAR 0 4
2946: PPUSH
2947: CALL_OW 52
// end ;
2951: GO 2868
2953: POP
2954: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2955: LD_ADDR_EXP 37
2959: PUSH
2960: LD_INT 94
2962: PPUSH
2963: LD_INT 28
2965: PPUSH
2966: LD_STRING dammam
2968: PPUSH
2969: LD_VAR 0 5
2973: PPUSH
2974: LD_INT 10000
2976: PUSH
2977: LD_INT 1000
2979: PUSH
2980: LD_INT 300
2982: PUSH
2983: EMPTY
2984: LIST
2985: LIST
2986: LIST
2987: PPUSH
2988: LD_INT 12
2990: PUSH
2991: LD_INT 2
2993: PUSH
2994: LD_INT 3
2996: PUSH
2997: LD_INT 4
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PUSH
3009: LD_OWVAR 67
3013: ARRAY
3014: PUSH
3015: LD_INT 1
3017: NEG
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL 57107 0 6
3032: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3033: LD_ADDR_EXP 37
3037: PUSH
3038: LD_EXP 37
3042: PUSH
3043: LD_INT 122
3045: PPUSH
3046: LD_INT 25
3048: PPUSH
3049: LD_STRING 
3051: PPUSH
3052: LD_VAR 0 5
3056: PPUSH
3057: LD_INT 500
3059: PUSH
3060: LD_INT 60
3062: PUSH
3063: LD_INT 0
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: LIST
3070: PPUSH
3071: LD_INT 8
3073: PUSH
3074: LD_INT 2
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: LD_INT 4
3082: PUSH
3083: LD_INT 5
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: LD_OWVAR 67
3096: ARRAY
3097: PUSH
3098: LD_INT 2
3100: PUSH
3101: LD_INT 0
3103: PUSH
3104: EMPTY
3105: LIST
3106: LIST
3107: LIST
3108: LIST
3109: PPUSH
3110: CALL 57107 0 6
3114: UNION
3115: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3116: LD_ADDR_EXP 35
3120: PUSH
3121: LD_INT 45
3123: PPUSH
3124: LD_INT 24
3126: PPUSH
3127: LD_STRING jeddah
3129: PPUSH
3130: LD_VAR 0 5
3134: PPUSH
3135: LD_INT 700
3137: PUSH
3138: LD_INT 300
3140: PUSH
3141: LD_INT 10
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PPUSH
3149: LD_INT 9
3151: PUSH
3152: LD_INT 4
3154: PUSH
3155: LD_INT 3
3157: PUSH
3158: LD_INT 2
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: PPUSH
3167: CALL 57107 0 6
3171: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3172: LD_ADDR_EXP 36
3176: PUSH
3177: LD_INT 7
3179: PPUSH
3180: LD_INT 27
3182: PPUSH
3183: LD_STRING riyadh
3185: PPUSH
3186: LD_VAR 0 5
3190: PPUSH
3191: LD_INT 500
3193: PUSH
3194: LD_INT 60
3196: PUSH
3197: LD_INT 0
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: PPUSH
3205: LD_INT 4
3207: PUSH
3208: LD_INT 2
3210: PUSH
3211: LD_INT 3
3213: PUSH
3214: LD_INT 1
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: PPUSH
3223: CALL 57107 0 6
3227: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3228: LD_ADDR_EXP 39
3232: PUSH
3233: LD_INT 204
3235: PPUSH
3236: LD_INT 26
3238: PPUSH
3239: LD_STRING 
3241: PPUSH
3242: LD_VAR 0 5
3246: PPUSH
3247: LD_INT 500
3249: PUSH
3250: LD_INT 50
3252: PUSH
3253: LD_INT 0
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: PPUSH
3261: LD_INT 9
3263: PUSH
3264: LD_INT 2
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 1
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PPUSH
3279: CALL 57107 0 6
3283: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3284: LD_ADDR_EXP 50
3288: PUSH
3289: LD_EXP 37
3293: PUSH
3294: LD_EXP 35
3298: PUSH
3299: LD_EXP 39
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: LIST
3308: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3309: LD_ADDR_VAR 0 2
3313: PUSH
3314: LD_INT 22
3316: PUSH
3317: LD_INT 2
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: PUSH
3324: LD_INT 30
3326: PUSH
3327: LD_INT 31
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 58
3336: PUSH
3337: EMPTY
3338: LIST
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: LIST
3344: PPUSH
3345: CALL_OW 69
3349: PUSH
3350: FOR_IN
3351: IFFALSE 3476
// begin if GetBase ( i ) then
3353: LD_VAR 0 2
3357: PPUSH
3358: CALL_OW 274
3362: IFFALSE 3366
// continue ;
3364: GO 3350
// d := GetDir ( i ) ;
3366: LD_ADDR_VAR 0 3
3370: PUSH
3371: LD_VAR 0 2
3375: PPUSH
3376: CALL_OW 254
3380: ST_TO_ADDR
// if d < 3 then
3381: LD_VAR 0 3
3385: PUSH
3386: LD_INT 3
3388: LESS
3389: IFFALSE 3407
// d := d + 3 else
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: LD_VAR 0 3
3400: PUSH
3401: LD_INT 3
3403: PLUS
3404: ST_TO_ADDR
3405: GO 3421
// d := d - 3 ;
3407: LD_ADDR_VAR 0 3
3411: PUSH
3412: LD_VAR 0 3
3416: PUSH
3417: LD_INT 3
3419: MINUS
3420: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3421: LD_INT 0
3423: PPUSH
3424: LD_INT 8
3426: PPUSH
3427: LD_VAR 0 5
3431: PPUSH
3432: CALL_OW 380
// un := CreateHuman ;
3436: LD_ADDR_VAR 0 4
3440: PUSH
3441: CALL_OW 44
3445: ST_TO_ADDR
// SetDir ( un , d ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_VAR 0 3
3455: PPUSH
3456: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3460: LD_VAR 0 4
3464: PPUSH
3465: LD_VAR 0 2
3469: PPUSH
3470: CALL_OW 52
// end ;
3474: GO 3350
3476: POP
3477: POP
// if Difficulty > 1 then
3478: LD_OWVAR 67
3482: PUSH
3483: LD_INT 1
3485: GREATER
3486: IFFALSE 3857
// begin ar_kamikadze := [ ] ;
3488: LD_ADDR_EXP 42
3492: PUSH
3493: EMPTY
3494: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3495: LD_INT 0
3497: PPUSH
3498: LD_INT 1
3500: PPUSH
3501: LD_VAR 0 5
3505: PPUSH
3506: CALL_OW 380
// un := CreateHuman ;
3510: LD_ADDR_VAR 0 4
3514: PUSH
3515: CALL_OW 44
3519: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3520: LD_VAR 0 4
3524: PPUSH
3525: LD_INT 3
3527: PPUSH
3528: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3532: LD_VAR 0 4
3536: PPUSH
3537: LD_INT 23
3539: PPUSH
3540: LD_INT 44
3542: PPUSH
3543: LD_INT 0
3545: PPUSH
3546: CALL_OW 48
// ComCrawl ( un ) ;
3550: LD_VAR 0 4
3554: PPUSH
3555: CALL_OW 137
// un := CreateHuman ;
3559: LD_ADDR_VAR 0 4
3563: PUSH
3564: CALL_OW 44
3568: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: LD_INT 3
3576: PPUSH
3577: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3581: LD_VAR 0 4
3585: PPUSH
3586: LD_INT 30
3588: PPUSH
3589: LD_INT 39
3591: PPUSH
3592: LD_INT 0
3594: PPUSH
3595: CALL_OW 48
// ComCrawl ( un ) ;
3599: LD_VAR 0 4
3603: PPUSH
3604: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3608: LD_INT 0
3610: PPUSH
3611: LD_INT 17
3613: PPUSH
3614: LD_VAR 0 5
3618: PPUSH
3619: CALL_OW 380
// un := CreateHuman ;
3623: LD_ADDR_VAR 0 4
3627: PUSH
3628: CALL_OW 44
3632: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3633: LD_VAR 0 4
3637: PPUSH
3638: LD_INT 3
3640: PPUSH
3641: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3645: LD_VAR 0 4
3649: PPUSH
3650: LD_INT 45
3652: PPUSH
3653: LD_INT 86
3655: PPUSH
3656: LD_INT 0
3658: PPUSH
3659: CALL_OW 48
// ComHold ( un ) ;
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3672: LD_ADDR_EXP 42
3676: PUSH
3677: LD_EXP 42
3681: PPUSH
3682: LD_EXP 42
3686: PUSH
3687: LD_INT 1
3689: PLUS
3690: PPUSH
3691: LD_VAR 0 4
3695: PPUSH
3696: CALL_OW 1
3700: ST_TO_ADDR
// un := CreateHuman ;
3701: LD_ADDR_VAR 0 4
3705: PUSH
3706: CALL_OW 44
3710: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3711: LD_VAR 0 4
3715: PPUSH
3716: LD_INT 3
3718: PPUSH
3719: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3723: LD_VAR 0 4
3727: PPUSH
3728: LD_INT 60
3730: PPUSH
3731: LD_INT 85
3733: PPUSH
3734: LD_INT 0
3736: PPUSH
3737: CALL_OW 48
// ComHold ( un ) ;
3741: LD_VAR 0 4
3745: PPUSH
3746: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3750: LD_ADDR_EXP 42
3754: PUSH
3755: LD_EXP 42
3759: PPUSH
3760: LD_EXP 42
3764: PUSH
3765: LD_INT 1
3767: PLUS
3768: PPUSH
3769: LD_VAR 0 4
3773: PPUSH
3774: CALL_OW 1
3778: ST_TO_ADDR
// un := CreateHuman ;
3779: LD_ADDR_VAR 0 4
3783: PUSH
3784: CALL_OW 44
3788: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3789: LD_VAR 0 4
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3801: LD_VAR 0 4
3805: PPUSH
3806: LD_INT 222
3808: PPUSH
3809: LD_INT 166
3811: PPUSH
3812: LD_INT 0
3814: PPUSH
3815: CALL_OW 48
// ComHold ( un ) ;
3819: LD_VAR 0 4
3823: PPUSH
3824: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3828: LD_ADDR_EXP 42
3832: PUSH
3833: LD_EXP 42
3837: PPUSH
3838: LD_EXP 42
3842: PUSH
3843: LD_INT 1
3845: PLUS
3846: PPUSH
3847: LD_VAR 0 4
3851: PPUSH
3852: CALL_OW 1
3856: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3857: LD_ADDR_EXP 40
3861: PUSH
3862: EMPTY
3863: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3864: LD_INT 1
3866: PPUSH
3867: LD_INT 1
3869: PPUSH
3870: LD_VAR 0 5
3874: PPUSH
3875: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3879: LD_ADDR_OWVAR 26
3883: PUSH
3884: LD_STRING Pavel Grigorovic
3886: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3887: LD_ADDR_OWVAR 33
3891: PUSH
3892: LD_STRING SecondCharsGal
3894: ST_TO_ADDR
// hc_face_number := 4 ;
3895: LD_ADDR_OWVAR 34
3899: PUSH
3900: LD_INT 4
3902: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3903: LD_ADDR_EXP 40
3907: PUSH
3908: LD_EXP 40
3912: PPUSH
3913: LD_INT 1
3915: PPUSH
3916: CALL_OW 44
3920: PPUSH
3921: CALL_OW 1
3925: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3926: LD_INT 2
3928: PPUSH
3929: LD_INT 4
3931: PPUSH
3932: LD_INT 2
3934: PPUSH
3935: CALL_OW 380
// hc_name := Lucy Sebel ;
3939: LD_ADDR_OWVAR 26
3943: PUSH
3944: LD_STRING Lucy Sebel
3946: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3947: LD_ADDR_OWVAR 33
3951: PUSH
3952: LD_STRING SecondCharsGal
3954: ST_TO_ADDR
// hc_face_number := 15 ;
3955: LD_ADDR_OWVAR 34
3959: PUSH
3960: LD_INT 15
3962: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3963: LD_ADDR_EXP 40
3967: PUSH
3968: LD_EXP 40
3972: PPUSH
3973: LD_INT 2
3975: PPUSH
3976: CALL_OW 44
3980: PPUSH
3981: CALL_OW 1
3985: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3986: LD_INT 2
3988: PPUSH
3989: LD_INT 4
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 380
// hc_gallery :=  ;
3999: LD_ADDR_OWVAR 33
4003: PUSH
4004: LD_STRING 
4006: ST_TO_ADDR
// hc_name :=  ;
4007: LD_ADDR_OWVAR 26
4011: PUSH
4012: LD_STRING 
4014: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4015: LD_ADDR_EXP 40
4019: PUSH
4020: LD_EXP 40
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: CALL_OW 44
4032: PPUSH
4033: CALL_OW 1
4037: ST_TO_ADDR
// hc_sex := sex_male ;
4038: LD_ADDR_OWVAR 27
4042: PUSH
4043: LD_INT 1
4045: ST_TO_ADDR
// hc_class = 11 ;
4046: LD_ADDR_OWVAR 28
4050: PUSH
4051: LD_INT 11
4053: ST_TO_ADDR
// hc_gallery = sandar ;
4054: LD_ADDR_OWVAR 33
4058: PUSH
4059: LD_STRING sandar
4061: ST_TO_ADDR
// hc_face_number = 33 ;
4062: LD_ADDR_OWVAR 34
4066: PUSH
4067: LD_INT 33
4069: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4070: LD_ADDR_OWVAR 26
4074: PUSH
4075: LD_STRING Thabit Muhair Saliba
4077: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4078: LD_ADDR_OWVAR 31
4082: PUSH
4083: LD_INT 0
4085: PUSH
4086: LD_INT 0
4088: PUSH
4089: LD_INT 0
4091: PUSH
4092: LD_INT 0
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: ST_TO_ADDR
// Saliba = CreateHuman ;
4101: LD_ADDR_EXP 44
4105: PUSH
4106: CALL_OW 44
4110: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4111: LD_EXP 44
4115: PPUSH
4116: LD_INT 7
4118: PPUSH
4119: CALL_OW 52
// if gensher_active then
4123: LD_EXP 18
4127: IFFALSE 4154
// begin Gensher = NewCharacter ( Dietrich ) ;
4129: LD_ADDR_EXP 45
4133: PUSH
4134: LD_STRING Dietrich
4136: PPUSH
4137: CALL_OW 25
4141: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4142: LD_EXP 45
4146: PPUSH
4147: LD_INT 94
4149: PPUSH
4150: CALL_OW 52
// end ; InitHc ;
4154: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4158: LD_ADDR_EXP 41
4162: PUSH
4163: EMPTY
4164: ST_TO_ADDR
// for i = 1 to 5 do
4165: LD_ADDR_VAR 0 2
4169: PUSH
4170: DOUBLE
4171: LD_INT 1
4173: DEC
4174: ST_TO_ADDR
4175: LD_INT 5
4177: PUSH
4178: FOR_TO
4179: IFFALSE 4351
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4181: LD_INT 13
4183: PUSH
4184: LD_INT 14
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PUSH
4191: LD_INT 1
4193: PPUSH
4194: LD_INT 2
4196: PPUSH
4197: CALL_OW 12
4201: ARRAY
4202: PPUSH
4203: LD_INT 1
4205: PUSH
4206: LD_INT 2
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_INT 2
4218: PPUSH
4219: CALL_OW 12
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PPUSH
4228: LD_INT 25
4230: PUSH
4231: LD_INT 27
4233: PUSH
4234: LD_INT 26
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 1
4244: PPUSH
4245: LD_INT 3
4247: PPUSH
4248: CALL_OW 12
4252: ARRAY
4253: PPUSH
4254: LD_INT 60
4256: PPUSH
4257: LD_INT 100
4259: PPUSH
4260: CALL_OW 12
4264: PPUSH
4265: CALL 53663 0 5
// un := CreateVehicle ;
4269: LD_ADDR_VAR 0 4
4273: PUSH
4274: CALL_OW 45
4278: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4279: LD_ADDR_EXP 41
4283: PUSH
4284: LD_EXP 41
4288: PPUSH
4289: LD_EXP 41
4293: PUSH
4294: LD_INT 1
4296: PLUS
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 1
4307: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4308: LD_VAR 0 4
4312: PPUSH
4313: LD_INT 0
4315: PPUSH
4316: LD_INT 5
4318: PPUSH
4319: CALL_OW 12
4323: PPUSH
4324: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4328: LD_VAR 0 4
4332: PPUSH
4333: LD_INT 124
4335: PPUSH
4336: LD_INT 141
4338: PPUSH
4339: LD_INT 8
4341: PPUSH
4342: LD_INT 0
4344: PPUSH
4345: CALL_OW 50
// end ;
4349: GO 4178
4351: POP
4352: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4353: LD_ADDR_EXP 43
4357: PUSH
4358: EMPTY
4359: PUSH
4360: EMPTY
4361: PUSH
4362: EMPTY
4363: PUSH
4364: EMPTY
4365: LIST
4366: LIST
4367: LIST
4368: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4369: LD_ADDR_VAR 0 3
4373: PUSH
4374: DOUBLE
4375: LD_INT 1
4377: DEC
4378: ST_TO_ADDR
4379: LD_INT 3
4381: PUSH
4382: LD_INT 3
4384: PUSH
4385: LD_INT 4
4387: PUSH
4388: LD_INT 4
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_OWVAR 67
4401: ARRAY
4402: PUSH
4403: FOR_TO
4404: IFFALSE 4618
// for i = 1 to 3 do
4406: LD_ADDR_VAR 0 2
4410: PUSH
4411: DOUBLE
4412: LD_INT 1
4414: DEC
4415: ST_TO_ADDR
4416: LD_INT 3
4418: PUSH
4419: FOR_TO
4420: IFFALSE 4614
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4422: LD_INT 14
4424: PPUSH
4425: LD_INT 3
4427: PUSH
4428: LD_INT 2
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: LD_INT 1
4437: PPUSH
4438: LD_INT 2
4440: PPUSH
4441: CALL_OW 12
4445: ARRAY
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 5
4452: PUSH
4453: EMPTY
4454: LIST
4455: LIST
4456: PUSH
4457: LD_INT 1
4459: PPUSH
4460: LD_INT 2
4462: PPUSH
4463: CALL_OW 12
4467: ARRAY
4468: PPUSH
4469: LD_INT 25
4471: PUSH
4472: LD_INT 27
4474: PUSH
4475: LD_INT 26
4477: PUSH
4478: LD_INT 28
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: LIST
4486: PUSH
4487: LD_INT 1
4489: PPUSH
4490: LD_INT 4
4492: PPUSH
4493: CALL_OW 12
4497: ARRAY
4498: PPUSH
4499: LD_INT 100
4501: PPUSH
4502: CALL 53663 0 5
// un := CreateVehicle ;
4506: LD_ADDR_VAR 0 4
4510: PUSH
4511: CALL_OW 45
4515: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4516: LD_ADDR_EXP 43
4520: PUSH
4521: LD_EXP 43
4525: PPUSH
4526: LD_VAR 0 2
4530: PUSH
4531: LD_EXP 43
4535: PUSH
4536: LD_VAR 0 2
4540: ARRAY
4541: PUSH
4542: LD_INT 1
4544: PLUS
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: LD_VAR 0 4
4554: PPUSH
4555: CALL 53785 0 3
4559: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4560: LD_VAR 0 4
4564: PPUSH
4565: LD_INT 0
4567: PPUSH
4568: LD_INT 5
4570: PPUSH
4571: CALL_OW 12
4575: PPUSH
4576: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4580: LD_VAR 0 4
4584: PPUSH
4585: LD_INT 20
4587: PUSH
4588: LD_INT 21
4590: PUSH
4591: LD_INT 22
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: LIST
4598: PUSH
4599: LD_VAR 0 2
4603: ARRAY
4604: PPUSH
4605: LD_INT 0
4607: PPUSH
4608: CALL_OW 49
// end ;
4612: GO 4419
4614: POP
4615: POP
4616: GO 4403
4618: POP
4619: POP
// InitHc ;
4620: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4624: LD_INT 4
4626: PPUSH
4627: LD_INT 5
4629: PPUSH
4630: LD_INT 10
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_INT 0
4638: PPUSH
4639: CALL_OW 58
// end ;
4643: LD_VAR 0 1
4647: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4648: LD_EXP 42
4652: IFFALSE 4726
4654: GO 4656
4656: DISABLE
4657: LD_INT 0
4659: PPUSH
// begin enable ;
4660: ENABLE
// for i in ar_kamikadze do
4661: LD_ADDR_VAR 0 1
4665: PUSH
4666: LD_EXP 42
4670: PUSH
4671: FOR_IN
4672: IFFALSE 4724
// if See ( 1 , i ) then
4674: LD_INT 1
4676: PPUSH
4677: LD_VAR 0 1
4681: PPUSH
4682: CALL_OW 292
4686: IFFALSE 4722
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4688: LD_VAR 0 1
4692: PPUSH
4693: LD_INT 81
4695: PUSH
4696: LD_INT 2
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PPUSH
4703: CALL_OW 69
4707: PPUSH
4708: LD_VAR 0 1
4712: PPUSH
4713: CALL_OW 74
4717: PPUSH
4718: CALL_OW 115
4722: GO 4671
4724: POP
4725: POP
// end ;
4726: PPOPN 1
4728: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4729: LD_EXP 13
4733: IFFALSE 5050
4735: GO 4737
4737: DISABLE
4738: LD_INT 0
4740: PPUSH
4741: PPUSH
4742: PPUSH
4743: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4744: LD_INT 35
4746: PPUSH
4747: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4751: LD_INT 1
4753: PPUSH
4754: CALL 42608 0 1
4758: PUSH
4759: LD_INT 0
4761: EQUAL
4762: IFFALSE 4744
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4764: LD_INT 1
4766: PPUSH
4767: LD_INT 14
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 2
4775: PUSH
4776: LD_INT 32
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: PUSH
4785: EMPTY
4786: LIST
4787: PPUSH
4788: CALL 42212 0 2
// repeat wait ( 0 0$1 ) ;
4792: LD_INT 35
4794: PPUSH
4795: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4799: LD_EXP 69
4803: PUSH
4804: LD_INT 1
4806: ARRAY
4807: PPUSH
4808: LD_INT 33
4810: PUSH
4811: LD_INT 2
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 34
4820: PUSH
4821: LD_INT 32
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 72
4836: IFFALSE 4792
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4838: LD_ADDR_VAR 0 2
4842: PUSH
4843: LD_EXP 69
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 33
4854: PUSH
4855: LD_INT 2
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 34
4864: PUSH
4865: LD_INT 32
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PPUSH
4876: CALL_OW 72
4880: PUSH
4881: LD_INT 1
4883: ARRAY
4884: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4885: LD_ADDR_VAR 0 4
4889: PUSH
4890: LD_INT 5
4892: PPUSH
4893: CALL_OW 469
4897: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4898: LD_INT 35
4900: PPUSH
4901: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4905: LD_ADDR_VAR 0 4
4909: PUSH
4910: LD_INT 5
4912: PPUSH
4913: CALL_OW 469
4917: ST_TO_ADDR
// tmp := 100 ;
4918: LD_ADDR_VAR 0 3
4922: PUSH
4923: LD_INT 100
4925: ST_TO_ADDR
// if pos then
4926: LD_VAR 0 4
4930: IFFALSE 4970
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4932: LD_ADDR_VAR 0 3
4936: PUSH
4937: LD_INT 2
4939: PPUSH
4940: LD_VAR 0 4
4944: PUSH
4945: LD_INT 1
4947: ARRAY
4948: PPUSH
4949: LD_VAR 0 4
4953: PUSH
4954: LD_INT 2
4956: ARRAY
4957: PPUSH
4958: LD_INT 20
4960: PPUSH
4961: CALL 54681 0 4
4965: PUSH
4966: LD_INT 4
4968: ARRAY
4969: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4970: LD_VAR 0 4
4974: PUSH
4975: LD_EXP 14
4979: NOT
4980: AND
4981: PUSH
4982: LD_VAR 0 3
4986: PUSH
4987: LD_INT 10
4989: LESS
4990: AND
4991: IFFALSE 4898
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_VAR 0 4
5002: PUSH
5003: LD_INT 1
5005: ARRAY
5006: PPUSH
5007: LD_VAR 0 4
5011: PUSH
5012: LD_INT 2
5014: ARRAY
5015: PPUSH
5016: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5020: LD_VAR 0 2
5024: PPUSH
5025: LD_INT 198
5027: PPUSH
5028: LD_INT 113
5030: PPUSH
5031: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5035: LD_VAR 0 2
5039: PPUSH
5040: LD_INT 124
5042: PPUSH
5043: LD_INT 7
5045: PPUSH
5046: CALL_OW 171
// end ;
5050: PPOPN 4
5052: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
5053: LD_EXP 6
5057: IFFALSE 7020
5059: GO 5061
5061: DISABLE
5062: LD_INT 0
5064: PPUSH
5065: PPUSH
5066: PPUSH
5067: PPUSH
5068: PPUSH
5069: PPUSH
5070: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5071: LD_ADDR_VAR 0 4
5075: PUSH
5076: LD_INT 5
5078: PUSH
5079: LD_INT 6
5081: PUSH
5082: LD_INT 7
5084: PUSH
5085: LD_INT 8
5087: PUSH
5088: EMPTY
5089: LIST
5090: LIST
5091: LIST
5092: LIST
5093: PUSH
5094: LD_OWVAR 67
5098: ARRAY
5099: ST_TO_ADDR
// coords := [ ] ;
5100: LD_ADDR_VAR 0 5
5104: PUSH
5105: EMPTY
5106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5107: LD_ADDR_VAR 0 6
5111: PUSH
5112: LD_INT 0
5114: PUSH
5115: LD_INT 0
5117: PUSH
5118: LD_INT 0
5120: PUSH
5121: LD_INT 0
5123: PUSH
5124: LD_INT 1
5126: PUSH
5127: LD_INT 0
5129: PUSH
5130: LD_INT 0
5132: PUSH
5133: LD_INT 0
5135: PUSH
5136: LD_INT 1
5138: PUSH
5139: LD_INT 0
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: LIST
5148: LIST
5149: LIST
5150: LIST
5151: LIST
5152: LIST
5153: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5154: LD_INT 1
5156: PPUSH
5157: LD_INT 14
5159: PUSH
5160: LD_INT 1
5162: PUSH
5163: LD_INT 2
5165: PUSH
5166: LD_INT 28
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: LIST
5173: LIST
5174: PUSH
5175: LD_INT 14
5177: PUSH
5178: LD_INT 1
5180: PUSH
5181: LD_INT 2
5183: PUSH
5184: LD_INT 25
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: PUSH
5193: LD_INT 14
5195: PUSH
5196: LD_INT 1
5198: PUSH
5199: LD_INT 2
5201: PUSH
5202: LD_INT 28
5204: PUSH
5205: EMPTY
5206: LIST
5207: LIST
5208: LIST
5209: LIST
5210: PUSH
5211: LD_INT 14
5213: PUSH
5214: LD_INT 1
5216: PUSH
5217: LD_INT 2
5219: PUSH
5220: LD_INT 29
5222: PUSH
5223: EMPTY
5224: LIST
5225: LIST
5226: LIST
5227: LIST
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: LIST
5233: LIST
5234: PPUSH
5235: CALL 42212 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5239: LD_INT 21000
5241: PUSH
5242: LD_INT 19950
5244: PUSH
5245: LD_INT 18900
5247: PUSH
5248: LD_INT 18200
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: LIST
5255: LIST
5256: PUSH
5257: LD_OWVAR 67
5261: ARRAY
5262: PPUSH
5263: CALL_OW 67
// InitHc ;
5267: CALL_OW 19
// InitUc ;
5271: CALL_OW 18
// uc_side := 2 ;
5275: LD_ADDR_OWVAR 20
5279: PUSH
5280: LD_INT 2
5282: ST_TO_ADDR
// uc_nation := 2 ;
5283: LD_ADDR_OWVAR 21
5287: PUSH
5288: LD_INT 2
5290: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5291: LD_ADDR_VAR 0 3
5295: PUSH
5296: EMPTY
5297: PUSH
5298: EMPTY
5299: PUSH
5300: EMPTY
5301: PUSH
5302: EMPTY
5303: PUSH
5304: EMPTY
5305: PUSH
5306: EMPTY
5307: LIST
5308: LIST
5309: LIST
5310: LIST
5311: LIST
5312: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5313: LD_ADDR_VAR 0 3
5317: PUSH
5318: LD_VAR 0 3
5322: PPUSH
5323: LD_INT 1
5325: PPUSH
5326: LD_EXP 69
5330: PUSH
5331: LD_INT 1
5333: ARRAY
5334: PUSH
5335: LD_INT 2
5337: PUSH
5338: LD_INT 34
5340: PUSH
5341: LD_INT 88
5343: PUSH
5344: EMPTY
5345: LIST
5346: LIST
5347: PUSH
5348: LD_INT 34
5350: PUSH
5351: LD_INT 32
5353: PUSH
5354: EMPTY
5355: LIST
5356: LIST
5357: PUSH
5358: EMPTY
5359: LIST
5360: LIST
5361: LIST
5362: PPUSH
5363: CALL_OW 69
5367: DIFF
5368: PPUSH
5369: CALL_OW 1
5373: ST_TO_ADDR
// for i = 1 to Difficulty do
5374: LD_ADDR_VAR 0 1
5378: PUSH
5379: DOUBLE
5380: LD_INT 1
5382: DEC
5383: ST_TO_ADDR
5384: LD_OWVAR 67
5388: PUSH
5389: FOR_TO
5390: IFFALSE 5528
// begin uc_side := 2 ;
5392: LD_ADDR_OWVAR 20
5396: PUSH
5397: LD_INT 2
5399: ST_TO_ADDR
// uc_nation := 2 ;
5400: LD_ADDR_OWVAR 21
5404: PUSH
5405: LD_INT 2
5407: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5408: LD_INT 13
5410: PPUSH
5411: LD_INT 3
5413: PPUSH
5414: LD_INT 5
5416: PPUSH
5417: LD_INT 29
5419: PPUSH
5420: LD_INT 100
5422: PPUSH
5423: CALL 53663 0 5
// un := CreateVehicle ;
5427: LD_ADDR_VAR 0 2
5431: PUSH
5432: CALL_OW 45
5436: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5437: LD_ADDR_VAR 0 3
5441: PUSH
5442: LD_VAR 0 3
5446: PPUSH
5447: LD_INT 1
5449: PUSH
5450: LD_VAR 0 3
5454: PUSH
5455: LD_INT 1
5457: ARRAY
5458: PUSH
5459: LD_INT 1
5461: PLUS
5462: PUSH
5463: EMPTY
5464: LIST
5465: LIST
5466: PPUSH
5467: LD_VAR 0 2
5471: PPUSH
5472: CALL 53785 0 3
5476: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5477: LD_VAR 0 2
5481: PPUSH
5482: LD_INT 3
5484: PPUSH
5485: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5489: LD_VAR 0 2
5493: PPUSH
5494: LD_INT 16
5496: PPUSH
5497: LD_INT 0
5499: PPUSH
5500: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5504: LD_VAR 0 2
5508: PPUSH
5509: LD_INT 51
5511: PPUSH
5512: LD_INT 10
5514: PPUSH
5515: CALL_OW 111
// wait ( 0 0$2 ) ;
5519: LD_INT 70
5521: PPUSH
5522: CALL_OW 67
// end ;
5526: GO 5389
5528: POP
5529: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5530: LD_ADDR_VAR 0 5
5534: PUSH
5535: LD_INT 51
5537: PUSH
5538: LD_INT 24
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: PUSH
5545: LD_INT 75
5547: PUSH
5548: LD_INT 90
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5559: LD_INT 1
5561: PPUSH
5562: LD_VAR 0 3
5566: PUSH
5567: LD_INT 1
5569: ARRAY
5570: PPUSH
5571: LD_VAR 0 5
5575: PPUSH
5576: LD_VAR 0 6
5580: PPUSH
5581: CALL 42445 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5585: LD_ADDR_VAR 0 1
5589: PUSH
5590: DOUBLE
5591: LD_INT 1
5593: DEC
5594: ST_TO_ADDR
5595: LD_INT 1
5597: PUSH
5598: LD_INT 3
5600: PUSH
5601: LD_INT 4
5603: PUSH
5604: LD_INT 5
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: PUSH
5613: LD_OWVAR 67
5617: ARRAY
5618: PUSH
5619: FOR_TO
5620: IFFALSE 5720
// begin uc_side := 2 ;
5622: LD_ADDR_OWVAR 20
5626: PUSH
5627: LD_INT 2
5629: ST_TO_ADDR
// uc_nation := 2 ;
5630: LD_ADDR_OWVAR 21
5634: PUSH
5635: LD_INT 2
5637: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5638: LD_INT 0
5640: PPUSH
5641: LD_INT 17
5643: PPUSH
5644: LD_VAR 0 4
5648: PPUSH
5649: CALL_OW 380
// un := CreateHuman ;
5653: LD_ADDR_VAR 0 2
5657: PUSH
5658: CALL_OW 44
5662: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5663: LD_ADDR_VAR 0 3
5667: PUSH
5668: LD_VAR 0 3
5672: PPUSH
5673: LD_INT 2
5675: PUSH
5676: LD_VAR 0 3
5680: PUSH
5681: LD_INT 2
5683: ARRAY
5684: PUSH
5685: LD_INT 1
5687: PLUS
5688: PUSH
5689: EMPTY
5690: LIST
5691: LIST
5692: PPUSH
5693: LD_VAR 0 2
5697: PPUSH
5698: CALL 53785 0 3
5702: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5703: LD_VAR 0 2
5707: PPUSH
5708: LD_INT 13
5710: PPUSH
5711: LD_INT 0
5713: PPUSH
5714: CALL_OW 49
// end ;
5718: GO 5619
5720: POP
5721: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5722: LD_ADDR_VAR 0 1
5726: PUSH
5727: DOUBLE
5728: LD_INT 1
5730: DEC
5731: ST_TO_ADDR
5732: LD_INT 3
5734: PUSH
5735: LD_INT 4
5737: PUSH
5738: LD_INT 5
5740: PUSH
5741: LD_INT 6
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: PUSH
5750: LD_OWVAR 67
5754: ARRAY
5755: PUSH
5756: FOR_TO
5757: IFFALSE 5878
// begin uc_side := 2 ;
5759: LD_ADDR_OWVAR 20
5763: PUSH
5764: LD_INT 2
5766: ST_TO_ADDR
// uc_nation := 2 ;
5767: LD_ADDR_OWVAR 21
5771: PUSH
5772: LD_INT 2
5774: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5775: LD_INT 0
5777: PPUSH
5778: LD_INT 1
5780: PUSH
5781: LD_INT 8
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: PUSH
5788: LD_VAR 0 1
5792: PUSH
5793: LD_INT 2
5795: MOD
5796: PUSH
5797: LD_INT 1
5799: PLUS
5800: ARRAY
5801: PPUSH
5802: LD_VAR 0 4
5806: PPUSH
5807: CALL_OW 380
// un := CreateHuman ;
5811: LD_ADDR_VAR 0 2
5815: PUSH
5816: CALL_OW 44
5820: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5821: LD_ADDR_VAR 0 3
5825: PUSH
5826: LD_VAR 0 3
5830: PPUSH
5831: LD_INT 2
5833: PUSH
5834: LD_VAR 0 3
5838: PUSH
5839: LD_INT 2
5841: ARRAY
5842: PUSH
5843: LD_INT 1
5845: PLUS
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: PPUSH
5851: LD_VAR 0 2
5855: PPUSH
5856: CALL 53785 0 3
5860: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5861: LD_VAR 0 2
5865: PPUSH
5866: LD_INT 13
5868: PPUSH
5869: LD_INT 0
5871: PPUSH
5872: CALL_OW 49
// end ;
5876: GO 5756
5878: POP
5879: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5880: LD_ADDR_VAR 0 5
5884: PUSH
5885: LD_INT 67
5887: PUSH
5888: LD_INT 112
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: LD_INT 85
5897: PUSH
5898: LD_INT 130
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5909: LD_INT 2
5911: PPUSH
5912: LD_VAR 0 3
5916: PUSH
5917: LD_INT 2
5919: ARRAY
5920: PPUSH
5921: LD_VAR 0 5
5925: PPUSH
5926: LD_VAR 0 6
5930: PPUSH
5931: CALL 42445 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5935: LD_ADDR_VAR 0 1
5939: PUSH
5940: DOUBLE
5941: LD_INT 1
5943: DEC
5944: ST_TO_ADDR
5945: LD_INT 1
5947: PUSH
5948: LD_INT 2
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: EMPTY
5958: LIST
5959: LIST
5960: LIST
5961: LIST
5962: PUSH
5963: LD_OWVAR 67
5967: ARRAY
5968: PUSH
5969: FOR_TO
5970: IFFALSE 6070
// begin uc_side := 2 ;
5972: LD_ADDR_OWVAR 20
5976: PUSH
5977: LD_INT 2
5979: ST_TO_ADDR
// uc_nation := 2 ;
5980: LD_ADDR_OWVAR 21
5984: PUSH
5985: LD_INT 2
5987: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5988: LD_INT 0
5990: PPUSH
5991: LD_INT 17
5993: PPUSH
5994: LD_VAR 0 4
5998: PPUSH
5999: CALL_OW 380
// un := CreateHuman ;
6003: LD_ADDR_VAR 0 2
6007: PUSH
6008: CALL_OW 44
6012: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6013: LD_ADDR_VAR 0 3
6017: PUSH
6018: LD_VAR 0 3
6022: PPUSH
6023: LD_INT 3
6025: PUSH
6026: LD_VAR 0 3
6030: PUSH
6031: LD_INT 3
6033: ARRAY
6034: PUSH
6035: LD_INT 1
6037: PLUS
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PPUSH
6043: LD_VAR 0 2
6047: PPUSH
6048: CALL 53785 0 3
6052: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6053: LD_VAR 0 2
6057: PPUSH
6058: LD_INT 14
6060: PPUSH
6061: LD_INT 0
6063: PPUSH
6064: CALL_OW 49
// end ;
6068: GO 5969
6070: POP
6071: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6072: LD_ADDR_VAR 0 5
6076: PUSH
6077: LD_INT 148
6079: PUSH
6080: LD_INT 158
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PUSH
6087: LD_INT 148
6089: PUSH
6090: LD_INT 158
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6101: LD_INT 3
6103: PPUSH
6104: LD_VAR 0 3
6108: PUSH
6109: LD_INT 3
6111: ARRAY
6112: PPUSH
6113: LD_VAR 0 5
6117: PPUSH
6118: LD_VAR 0 6
6122: PPUSH
6123: CALL 42445 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: DOUBLE
6133: LD_INT 1
6135: DEC
6136: ST_TO_ADDR
6137: LD_INT 2
6139: PUSH
6140: LD_INT 3
6142: PUSH
6143: LD_INT 4
6145: PUSH
6146: LD_INT 5
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: LIST
6153: LIST
6154: PUSH
6155: LD_OWVAR 67
6159: ARRAY
6160: PUSH
6161: FOR_TO
6162: IFFALSE 6386
// begin uc_side := 2 ;
6164: LD_ADDR_OWVAR 20
6168: PUSH
6169: LD_INT 2
6171: ST_TO_ADDR
// uc_nation := 2 ;
6172: LD_ADDR_OWVAR 21
6176: PUSH
6177: LD_INT 2
6179: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6180: LD_INT 14
6182: PPUSH
6183: LD_INT 3
6185: PPUSH
6186: LD_INT 1
6188: PUSH
6189: LD_INT 5
6191: PUSH
6192: EMPTY
6193: LIST
6194: LIST
6195: PUSH
6196: LD_INT 1
6198: PPUSH
6199: LD_INT 2
6201: PPUSH
6202: CALL_OW 12
6206: ARRAY
6207: PPUSH
6208: LD_INT 27
6210: PUSH
6211: LD_INT 26
6213: PUSH
6214: LD_INT 28
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: LIST
6221: PUSH
6222: LD_INT 1
6224: PPUSH
6225: LD_INT 3
6227: PPUSH
6228: CALL_OW 12
6232: ARRAY
6233: PPUSH
6234: LD_INT 100
6236: PPUSH
6237: CALL 53663 0 5
// un := CreateVehicle ;
6241: LD_ADDR_VAR 0 2
6245: PUSH
6246: CALL_OW 45
6250: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6251: LD_ADDR_VAR 0 3
6255: PUSH
6256: LD_VAR 0 3
6260: PPUSH
6261: LD_INT 4
6263: PUSH
6264: LD_VAR 0 3
6268: PUSH
6269: LD_INT 4
6271: ARRAY
6272: PUSH
6273: LD_INT 1
6275: PLUS
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: PPUSH
6281: LD_VAR 0 2
6285: PPUSH
6286: CALL 53785 0 3
6290: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6291: LD_VAR 0 2
6295: PPUSH
6296: LD_INT 5
6298: PPUSH
6299: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6303: LD_VAR 0 2
6307: PPUSH
6308: LD_INT 15
6310: PPUSH
6311: LD_INT 0
6313: PPUSH
6314: CALL_OW 49
// if GetControl ( un ) = control_manual then
6318: LD_VAR 0 2
6322: PPUSH
6323: CALL_OW 263
6327: PUSH
6328: LD_INT 1
6330: EQUAL
6331: IFFALSE 6362
// begin PrepareHuman ( false , 3 , skill ) ;
6333: LD_INT 0
6335: PPUSH
6336: LD_INT 3
6338: PPUSH
6339: LD_VAR 0 4
6343: PPUSH
6344: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6348: CALL_OW 44
6352: PPUSH
6353: LD_VAR 0 2
6357: PPUSH
6358: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6362: LD_VAR 0 2
6366: PPUSH
6367: LD_INT 179
6369: PPUSH
6370: LD_INT 135
6372: PPUSH
6373: CALL_OW 111
// wait ( 0 0$2 ) ;
6377: LD_INT 70
6379: PPUSH
6380: CALL_OW 67
// end ;
6384: GO 6161
6386: POP
6387: POP
// vc_chassis := 15 ;
6388: LD_ADDR_OWVAR 37
6392: PUSH
6393: LD_INT 15
6395: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6396: LD_ADDR_VAR 0 3
6400: PUSH
6401: LD_VAR 0 3
6405: PPUSH
6406: LD_INT 4
6408: PUSH
6409: LD_VAR 0 3
6413: PUSH
6414: LD_INT 4
6416: ARRAY
6417: PUSH
6418: LD_INT 1
6420: PLUS
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: PPUSH
6426: CALL_OW 45
6430: PPUSH
6431: CALL 53785 0 3
6435: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6436: LD_VAR 0 3
6440: PUSH
6441: LD_INT 4
6443: ARRAY
6444: PUSH
6445: LD_VAR 0 3
6449: PUSH
6450: LD_INT 4
6452: ARRAY
6453: ARRAY
6454: PPUSH
6455: LD_INT 15
6457: PPUSH
6458: LD_INT 0
6460: PPUSH
6461: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6465: LD_INT 0
6467: PPUSH
6468: LD_INT 11
6470: PPUSH
6471: LD_VAR 0 4
6475: PPUSH
6476: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6480: LD_ADDR_VAR 0 3
6484: PUSH
6485: LD_VAR 0 3
6489: PPUSH
6490: LD_INT 4
6492: PUSH
6493: LD_VAR 0 3
6497: PUSH
6498: LD_INT 4
6500: ARRAY
6501: PUSH
6502: LD_INT 1
6504: PLUS
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PPUSH
6510: CALL_OW 44
6514: PPUSH
6515: CALL 53785 0 3
6519: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6520: LD_VAR 0 3
6524: PUSH
6525: LD_INT 4
6527: ARRAY
6528: PUSH
6529: LD_VAR 0 3
6533: PUSH
6534: LD_INT 4
6536: ARRAY
6537: ARRAY
6538: PPUSH
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_INT 4
6555: ARRAY
6556: PUSH
6557: LD_INT 1
6559: MINUS
6560: ARRAY
6561: PPUSH
6562: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6566: LD_ADDR_VAR 0 5
6570: PUSH
6571: LD_INT 148
6573: PUSH
6574: LD_INT 140
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: EMPTY
6582: LIST
6583: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6584: LD_INT 1
6586: PPUSH
6587: LD_VAR 0 3
6591: PUSH
6592: LD_INT 4
6594: ARRAY
6595: PPUSH
6596: LD_VAR 0 5
6600: PPUSH
6601: LD_VAR 0 6
6605: PPUSH
6606: CALL 42445 0 4
// if gensher_active then
6610: LD_EXP 18
6614: IFFALSE 7020
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6616: LD_EXP 45
6620: PPUSH
6621: LD_STRING D10-Diet-1
6623: PPUSH
6624: CALL_OW 94
// for i = 1 to 2 do
6628: LD_ADDR_VAR 0 1
6632: PUSH
6633: DOUBLE
6634: LD_INT 1
6636: DEC
6637: ST_TO_ADDR
6638: LD_INT 2
6640: PUSH
6641: FOR_TO
6642: IFFALSE 6780
// begin uc_side := 2 ;
6644: LD_ADDR_OWVAR 20
6648: PUSH
6649: LD_INT 2
6651: ST_TO_ADDR
// uc_nation := 2 ;
6652: LD_ADDR_OWVAR 21
6656: PUSH
6657: LD_INT 2
6659: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6660: LD_INT 13
6662: PPUSH
6663: LD_INT 3
6665: PPUSH
6666: LD_INT 5
6668: PPUSH
6669: LD_INT 29
6671: PPUSH
6672: LD_INT 100
6674: PPUSH
6675: CALL 53663 0 5
// un := CreateVehicle ;
6679: LD_ADDR_VAR 0 2
6683: PUSH
6684: CALL_OW 45
6688: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6689: LD_ADDR_VAR 0 3
6693: PUSH
6694: LD_VAR 0 3
6698: PPUSH
6699: LD_INT 5
6701: PUSH
6702: LD_VAR 0 3
6706: PUSH
6707: LD_INT 5
6709: ARRAY
6710: PUSH
6711: LD_INT 1
6713: PLUS
6714: PUSH
6715: EMPTY
6716: LIST
6717: LIST
6718: PPUSH
6719: LD_VAR 0 2
6723: PPUSH
6724: CALL 53785 0 3
6728: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6729: LD_VAR 0 2
6733: PPUSH
6734: LD_INT 0
6736: PPUSH
6737: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6741: LD_VAR 0 2
6745: PPUSH
6746: LD_INT 23
6748: PPUSH
6749: LD_INT 0
6751: PPUSH
6752: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6756: LD_VAR 0 2
6760: PPUSH
6761: LD_INT 85
6763: PPUSH
6764: LD_INT 152
6766: PPUSH
6767: CALL_OW 111
// wait ( 0 0$2 ) ;
6771: LD_INT 70
6773: PPUSH
6774: CALL_OW 67
// end ;
6778: GO 6641
6780: POP
6781: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: DOUBLE
6788: LD_INT 1
6790: DEC
6791: ST_TO_ADDR
6792: LD_INT 2
6794: PUSH
6795: LD_INT 3
6797: PUSH
6798: LD_INT 3
6800: PUSH
6801: LD_INT 4
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: LIST
6808: LIST
6809: PUSH
6810: LD_OWVAR 67
6814: ARRAY
6815: PUSH
6816: FOR_TO
6817: IFFALSE 6974
// begin uc_side := 2 ;
6819: LD_ADDR_OWVAR 20
6823: PUSH
6824: LD_INT 2
6826: ST_TO_ADDR
// uc_nation := 2 ;
6827: LD_ADDR_OWVAR 21
6831: PUSH
6832: LD_INT 2
6834: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6835: LD_INT 14
6837: PPUSH
6838: LD_INT 3
6840: PPUSH
6841: LD_INT 5
6843: PPUSH
6844: LD_INT 27
6846: PUSH
6847: LD_INT 28
6849: PUSH
6850: EMPTY
6851: LIST
6852: LIST
6853: PUSH
6854: LD_INT 1
6856: PPUSH
6857: LD_INT 2
6859: PPUSH
6860: CALL_OW 12
6864: ARRAY
6865: PPUSH
6866: LD_INT 100
6868: PPUSH
6869: CALL 53663 0 5
// un := CreateVehicle ;
6873: LD_ADDR_VAR 0 2
6877: PUSH
6878: CALL_OW 45
6882: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6883: LD_ADDR_VAR 0 3
6887: PUSH
6888: LD_VAR 0 3
6892: PPUSH
6893: LD_INT 5
6895: PUSH
6896: LD_VAR 0 3
6900: PUSH
6901: LD_INT 5
6903: ARRAY
6904: PUSH
6905: LD_INT 1
6907: PLUS
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: PPUSH
6913: LD_VAR 0 2
6917: PPUSH
6918: CALL 53785 0 3
6922: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6923: LD_VAR 0 2
6927: PPUSH
6928: LD_INT 0
6930: PPUSH
6931: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6935: LD_VAR 0 2
6939: PPUSH
6940: LD_INT 23
6942: PPUSH
6943: LD_INT 0
6945: PPUSH
6946: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_INT 85
6957: PPUSH
6958: LD_INT 152
6960: PPUSH
6961: CALL_OW 111
// wait ( 0 0$2 ) ;
6965: LD_INT 70
6967: PPUSH
6968: CALL_OW 67
// end ;
6972: GO 6816
6974: POP
6975: POP
// coords := [ [ 97 , 143 ] ] ;
6976: LD_ADDR_VAR 0 5
6980: PUSH
6981: LD_INT 97
6983: PUSH
6984: LD_INT 143
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: PUSH
6991: EMPTY
6992: LIST
6993: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6994: LD_INT 1
6996: PPUSH
6997: LD_VAR 0 3
7001: PUSH
7002: LD_INT 5
7004: ARRAY
7005: PPUSH
7006: LD_VAR 0 5
7010: PPUSH
7011: LD_VAR 0 6
7015: PPUSH
7016: CALL 42445 0 4
// end ; end ;
7020: PPOPN 7
7022: END
// every 10 10$0 + 20 20$0 do var i , tmp , tmp2 , coords , w , list ;
7023: GO 7025
7025: DISABLE
7026: LD_INT 0
7028: PPUSH
7029: PPUSH
7030: PPUSH
7031: PPUSH
7032: PPUSH
7033: PPUSH
// begin enable ;
7034: ENABLE
// tmp := [ ] ;
7035: LD_ADDR_VAR 0 2
7039: PUSH
7040: EMPTY
7041: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
7042: LD_ADDR_VAR 0 5
7046: PUSH
7047: LD_INT 1
7049: PPUSH
7050: LD_INT 3
7052: PPUSH
7053: CALL_OW 12
7057: ST_TO_ADDR
// if w = 3 then
7058: LD_VAR 0 5
7062: PUSH
7063: LD_INT 3
7065: EQUAL
7066: IFFALSE 7153
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7068: LD_ADDR_VAR 0 6
7072: PUSH
7073: LD_INT 11
7075: PUSH
7076: LD_INT 1
7078: PUSH
7079: LD_INT 2
7081: PUSH
7082: LD_INT 24
7084: PUSH
7085: EMPTY
7086: LIST
7087: LIST
7088: LIST
7089: LIST
7090: PUSH
7091: LD_INT 11
7093: PUSH
7094: LD_INT 1
7096: PUSH
7097: LD_INT 2
7099: PUSH
7100: LD_INT 24
7102: PUSH
7103: EMPTY
7104: LIST
7105: LIST
7106: LIST
7107: LIST
7108: PUSH
7109: LD_INT 11
7111: PUSH
7112: LD_INT 1
7114: PUSH
7115: LD_INT 2
7117: PUSH
7118: LD_INT 24
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: LIST
7125: LIST
7126: PUSH
7127: LD_INT 11
7129: PUSH
7130: LD_INT 1
7132: PUSH
7133: LD_INT 2
7135: PUSH
7136: LD_INT 24
7138: PUSH
7139: EMPTY
7140: LIST
7141: LIST
7142: LIST
7143: LIST
7144: PUSH
7145: EMPTY
7146: LIST
7147: LIST
7148: LIST
7149: LIST
7150: ST_TO_ADDR
7151: GO 7236
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7153: LD_ADDR_VAR 0 6
7157: PUSH
7158: LD_INT 14
7160: PUSH
7161: LD_INT 1
7163: PUSH
7164: LD_INT 2
7166: PUSH
7167: LD_INT 28
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: PUSH
7176: LD_INT 14
7178: PUSH
7179: LD_INT 1
7181: PUSH
7182: LD_INT 2
7184: PUSH
7185: LD_INT 25
7187: PUSH
7188: EMPTY
7189: LIST
7190: LIST
7191: LIST
7192: LIST
7193: PUSH
7194: LD_INT 14
7196: PUSH
7197: LD_INT 1
7199: PUSH
7200: LD_INT 2
7202: PUSH
7203: LD_INT 28
7205: PUSH
7206: EMPTY
7207: LIST
7208: LIST
7209: LIST
7210: LIST
7211: PUSH
7212: LD_INT 14
7214: PUSH
7215: LD_INT 1
7217: PUSH
7218: LD_INT 2
7220: PUSH
7221: LD_INT 29
7223: PUSH
7224: EMPTY
7225: LIST
7226: LIST
7227: LIST
7228: LIST
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: LIST
7234: LIST
7235: ST_TO_ADDR
// if w < 3 then
7236: LD_VAR 0 5
7240: PUSH
7241: LD_INT 3
7243: LESS
7244: IFFALSE 7320
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7246: LD_ADDR_VAR 0 6
7250: PUSH
7251: LD_VAR 0 6
7255: PPUSH
7256: LD_INT 1
7258: PUSH
7259: LD_VAR 0 6
7263: PUSH
7264: LD_VAR 0 1
7268: ARRAY
7269: PUSH
7270: LD_INT 1
7272: PLUS
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: PPUSH
7278: LD_INT 14
7280: PUSH
7281: LD_INT 1
7283: PUSH
7284: LD_INT 2
7286: PUSH
7287: LD_INT 25
7289: PUSH
7290: LD_INT 28
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PUSH
7297: LD_INT 1
7299: PPUSH
7300: LD_INT 2
7302: PPUSH
7303: CALL_OW 12
7307: ARRAY
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: LIST
7313: LIST
7314: PPUSH
7315: CALL 53785 0 3
7319: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7320: LD_INT 1
7322: PPUSH
7323: LD_VAR 0 6
7327: PPUSH
7328: CALL 42212 0 2
// if GetSide ( ar_dep_w ) = 2 then
7332: LD_INT 45
7334: PPUSH
7335: CALL_OW 255
7339: PUSH
7340: LD_INT 2
7342: EQUAL
7343: IFFALSE 7428
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7345: LD_ADDR_VAR 0 6
7349: PUSH
7350: LD_INT 14
7352: PUSH
7353: LD_INT 1
7355: PUSH
7356: LD_INT 2
7358: PUSH
7359: LD_INT 28
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: LIST
7366: LIST
7367: PUSH
7368: LD_INT 14
7370: PUSH
7371: LD_INT 1
7373: PUSH
7374: LD_INT 2
7376: PUSH
7377: LD_INT 27
7379: PUSH
7380: EMPTY
7381: LIST
7382: LIST
7383: LIST
7384: LIST
7385: PUSH
7386: LD_INT 14
7388: PUSH
7389: LD_INT 1
7391: PUSH
7392: LD_INT 2
7394: PUSH
7395: LD_INT 27
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: LIST
7402: LIST
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: LIST
7408: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7409: LD_INT 2
7411: PPUSH
7412: LD_VAR 0 6
7416: PPUSH
7417: CALL 42212 0 2
// wait ( 0 0$20 ) ;
7421: LD_INT 700
7423: PPUSH
7424: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7428: LD_INT 35
7430: PPUSH
7431: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7435: LD_EXP 69
7439: PUSH
7440: LD_INT 1
7442: ARRAY
7443: PPUSH
7444: LD_INT 3
7446: PUSH
7447: LD_INT 2
7449: PUSH
7450: LD_INT 34
7452: PUSH
7453: LD_INT 32
7455: PUSH
7456: EMPTY
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 34
7462: PUSH
7463: LD_INT 88
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: LIST
7474: PUSH
7475: EMPTY
7476: LIST
7477: LIST
7478: PPUSH
7479: CALL_OW 72
7483: PUSH
7484: LD_INT 4
7486: GREATEREQUAL
7487: IFFALSE 7428
// wait ( 0 0$10 ) ;
7489: LD_INT 350
7491: PPUSH
7492: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7496: LD_ADDR_VAR 0 2
7500: PUSH
7501: LD_EXP 69
7505: PUSH
7506: LD_INT 1
7508: ARRAY
7509: PPUSH
7510: LD_INT 3
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 34
7518: PUSH
7519: LD_INT 32
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: LD_INT 34
7528: PUSH
7529: LD_INT 88
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PPUSH
7545: CALL_OW 72
7549: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7550: LD_ADDR_VAR 0 3
7554: PUSH
7555: LD_EXP 69
7559: PUSH
7560: LD_INT 2
7562: ARRAY
7563: PPUSH
7564: LD_INT 3
7566: PUSH
7567: LD_INT 2
7569: PUSH
7570: LD_INT 34
7572: PUSH
7573: LD_INT 32
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PUSH
7580: LD_INT 34
7582: PUSH
7583: LD_INT 88
7585: PUSH
7586: EMPTY
7587: LIST
7588: LIST
7589: PUSH
7590: EMPTY
7591: LIST
7592: LIST
7593: LIST
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PPUSH
7599: CALL_OW 72
7603: ST_TO_ADDR
// if tmp2 then
7604: LD_VAR 0 3
7608: IFFALSE 7626
// tmp := tmp union tmp2 ;
7610: LD_ADDR_VAR 0 2
7614: PUSH
7615: LD_VAR 0 2
7619: PUSH
7620: LD_VAR 0 3
7624: UNION
7625: ST_TO_ADDR
// if Count ( tmp2 ) or Prob ( 50 ) then
7626: LD_VAR 0 3
7630: PPUSH
7631: CALL 50750 0 1
7635: PUSH
7636: LD_INT 50
7638: PPUSH
7639: CALL_OW 13
7643: OR
7644: IFFALSE 7677
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7646: LD_ADDR_VAR 0 4
7650: PUSH
7651: LD_INT 48
7653: PUSH
7654: LD_INT 33
7656: PUSH
7657: EMPTY
7658: LIST
7659: LIST
7660: PUSH
7661: LD_INT 71
7663: PUSH
7664: LD_INT 88
7666: PUSH
7667: EMPTY
7668: LIST
7669: LIST
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: ST_TO_ADDR
7675: GO 7706
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7677: LD_ADDR_VAR 0 4
7681: PUSH
7682: LD_INT 128
7684: PUSH
7685: LD_INT 94
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: PUSH
7692: LD_INT 180
7694: PUSH
7695: LD_INT 135
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: ST_TO_ADDR
// if w = 3 then
7706: LD_VAR 0 5
7710: PUSH
7711: LD_INT 3
7713: EQUAL
7714: IFFALSE 7745
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7716: LD_ADDR_VAR 0 4
7720: PUSH
7721: LD_INT 91
7723: PUSH
7724: LD_INT 58
7726: PUSH
7727: EMPTY
7728: LIST
7729: LIST
7730: PUSH
7731: LD_INT 117
7733: PUSH
7734: LD_INT 107
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7745: LD_VAR 0 2
7749: PPUSH
7750: LD_VAR 0 4
7754: PUSH
7755: LD_INT 1
7757: ARRAY
7758: PPUSH
7759: LD_VAR 0 4
7763: PUSH
7764: LD_INT 2
7766: ARRAY
7767: PPUSH
7768: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7772: LD_INT 35
7774: PPUSH
7775: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7779: LD_VAR 0 2
7783: PPUSH
7784: LD_INT 60
7786: PUSH
7787: EMPTY
7788: LIST
7789: PPUSH
7790: CALL_OW 72
7794: PUSH
7795: LD_INT 0
7797: EQUAL
7798: IFFALSE 7772
// repeat wait ( 0 0$2 ) ;
7800: LD_INT 70
7802: PPUSH
7803: CALL_OW 67
// for i in tmp do
7807: LD_ADDR_VAR 0 1
7811: PUSH
7812: LD_VAR 0 2
7816: PUSH
7817: FOR_IN
7818: IFFALSE 7907
// if GetChassis ( i ) = ar_hovercraft then
7820: LD_VAR 0 1
7824: PPUSH
7825: CALL_OW 265
7829: PUSH
7830: LD_INT 11
7832: EQUAL
7833: IFFALSE 7871
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7835: LD_VAR 0 1
7839: PPUSH
7840: LD_INT 22
7842: PUSH
7843: LD_INT 1
7845: PUSH
7846: EMPTY
7847: LIST
7848: LIST
7849: PPUSH
7850: CALL_OW 69
7854: PPUSH
7855: LD_VAR 0 1
7859: PPUSH
7860: CALL_OW 74
7864: PPUSH
7865: CALL 81731 0 2
7869: GO 7905
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7871: LD_VAR 0 1
7875: PPUSH
7876: LD_INT 22
7878: PUSH
7879: LD_INT 1
7881: PUSH
7882: EMPTY
7883: LIST
7884: LIST
7885: PPUSH
7886: CALL_OW 69
7890: PPUSH
7891: LD_VAR 0 1
7895: PPUSH
7896: CALL_OW 74
7900: PPUSH
7901: CALL_OW 115
7905: GO 7817
7907: POP
7908: POP
// until not tmp ;
7909: LD_VAR 0 2
7913: NOT
7914: IFFALSE 7800
// end ;
7916: PPOPN 6
7918: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7919: LD_INT 204
7921: IFFALSE 8387
7923: GO 7925
7925: DISABLE
7926: LD_INT 0
7928: PPUSH
7929: PPUSH
7930: PPUSH
7931: PPUSH
// begin enable ;
7932: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7933: LD_INT 35
7935: PPUSH
7936: LD_INT 1190
7938: PPUSH
7939: CALL_OW 12
7943: PPUSH
7944: CALL_OW 67
// tmp := [ ] ;
7948: LD_ADDR_VAR 0 2
7952: PUSH
7953: EMPTY
7954: ST_TO_ADDR
// uc_side := 8 ;
7955: LD_ADDR_OWVAR 20
7959: PUSH
7960: LD_INT 8
7962: ST_TO_ADDR
// uc_nation := 2 ;
7963: LD_ADDR_OWVAR 21
7967: PUSH
7968: LD_INT 2
7970: ST_TO_ADDR
// InitHc ;
7971: CALL_OW 19
// for i = 1 to 3 do
7975: LD_ADDR_VAR 0 1
7979: PUSH
7980: DOUBLE
7981: LD_INT 1
7983: DEC
7984: ST_TO_ADDR
7985: LD_INT 3
7987: PUSH
7988: FOR_TO
7989: IFFALSE 8116
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7991: LD_INT 13
7993: PUSH
7994: LD_INT 14
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 1
8003: PPUSH
8004: LD_INT 2
8006: PPUSH
8007: CALL_OW 12
8011: ARRAY
8012: PPUSH
8013: LD_INT 3
8015: PPUSH
8016: LD_INT 5
8018: PPUSH
8019: LD_INT 27
8021: PUSH
8022: LD_INT 28
8024: PUSH
8025: EMPTY
8026: LIST
8027: LIST
8028: PUSH
8029: LD_INT 1
8031: PPUSH
8032: LD_INT 2
8034: PPUSH
8035: CALL_OW 12
8039: ARRAY
8040: PPUSH
8041: LD_INT 100
8043: PPUSH
8044: CALL 53663 0 5
// un := CreateVehicle ;
8048: LD_ADDR_VAR 0 3
8052: PUSH
8053: CALL_OW 45
8057: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8058: LD_VAR 0 3
8062: PPUSH
8063: LD_INT 4
8065: PPUSH
8066: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8070: LD_VAR 0 3
8074: PPUSH
8075: LD_INT 15
8077: PPUSH
8078: LD_INT 0
8080: PPUSH
8081: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8085: LD_ADDR_VAR 0 2
8089: PUSH
8090: LD_VAR 0 2
8094: PPUSH
8095: LD_VAR 0 2
8099: PUSH
8100: LD_INT 1
8102: PLUS
8103: PPUSH
8104: LD_VAR 0 3
8108: PPUSH
8109: CALL_OW 1
8113: ST_TO_ADDR
// end ;
8114: GO 7988
8116: POP
8117: POP
// for i = 1 to 4 do
8118: LD_ADDR_VAR 0 1
8122: PUSH
8123: DOUBLE
8124: LD_INT 1
8126: DEC
8127: ST_TO_ADDR
8128: LD_INT 4
8130: PUSH
8131: FOR_TO
8132: IFFALSE 8203
// begin PrepareHuman ( false , 1 , 6 ) ;
8134: LD_INT 0
8136: PPUSH
8137: LD_INT 1
8139: PPUSH
8140: LD_INT 6
8142: PPUSH
8143: CALL_OW 380
// un := CreateHuman ;
8147: LD_ADDR_VAR 0 3
8151: PUSH
8152: CALL_OW 44
8156: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8157: LD_VAR 0 3
8161: PPUSH
8162: LD_INT 15
8164: PPUSH
8165: LD_INT 0
8167: PPUSH
8168: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8172: LD_ADDR_VAR 0 2
8176: PUSH
8177: LD_VAR 0 2
8181: PPUSH
8182: LD_VAR 0 2
8186: PUSH
8187: LD_INT 1
8189: PLUS
8190: PPUSH
8191: LD_VAR 0 3
8195: PPUSH
8196: CALL_OW 1
8200: ST_TO_ADDR
// end ;
8201: GO 8131
8203: POP
8204: POP
// wait ( 0 0$3 ) ;
8205: LD_INT 105
8207: PPUSH
8208: CALL_OW 67
// for i in tmp do
8212: LD_ADDR_VAR 0 1
8216: PUSH
8217: LD_VAR 0 2
8221: PUSH
8222: FOR_IN
8223: IFFALSE 8291
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8225: LD_VAR 0 1
8229: PPUSH
8230: CALL_OW 257
8234: PUSH
8235: LD_INT 1
8237: EQUAL
8238: PUSH
8239: LD_VAR 0 1
8243: PPUSH
8244: CALL_OW 247
8248: PUSH
8249: LD_INT 2
8251: EQUAL
8252: OR
8253: IFFALSE 8289
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8255: LD_VAR 0 1
8259: PPUSH
8260: LD_INT 81
8262: PUSH
8263: LD_INT 8
8265: PUSH
8266: EMPTY
8267: LIST
8268: LIST
8269: PPUSH
8270: CALL_OW 69
8274: PPUSH
8275: LD_VAR 0 1
8279: PPUSH
8280: CALL_OW 74
8284: PPUSH
8285: CALL_OW 115
8289: GO 8222
8291: POP
8292: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8293: LD_VAR 0 2
8297: PPUSH
8298: LD_INT 210
8300: PPUSH
8301: LD_INT 178
8303: PPUSH
8304: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8308: LD_ADDR_VAR 0 4
8312: PUSH
8313: LD_INT 10
8315: PPUSH
8316: LD_INT 22
8318: PUSH
8319: LD_INT 8
8321: PUSH
8322: EMPTY
8323: LIST
8324: LIST
8325: PPUSH
8326: CALL_OW 70
8330: ST_TO_ADDR
// if x then
8331: LD_VAR 0 4
8335: IFFALSE 8363
// for i in x do
8337: LD_ADDR_VAR 0 1
8341: PUSH
8342: LD_VAR 0 4
8346: PUSH
8347: FOR_IN
8348: IFFALSE 8361
// RemoveUnit ( i ) ;
8350: LD_VAR 0 1
8354: PPUSH
8355: CALL_OW 64
8359: GO 8347
8361: POP
8362: POP
// wait ( 0 0$1 ) ;
8363: LD_INT 35
8365: PPUSH
8366: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8370: LD_INT 22
8372: PUSH
8373: LD_INT 8
8375: PUSH
8376: EMPTY
8377: LIST
8378: LIST
8379: PPUSH
8380: CALL_OW 69
8384: NOT
8385: IFFALSE 8293
// end ;
8387: PPOPN 4
8389: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8390: LD_INT 22
8392: PUSH
8393: LD_INT 2
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: LD_INT 34
8402: PUSH
8403: LD_INT 31
8405: PUSH
8406: EMPTY
8407: LIST
8408: LIST
8409: PUSH
8410: LD_INT 3
8412: PUSH
8413: LD_INT 24
8415: PUSH
8416: LD_INT 1000
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: PUSH
8427: EMPTY
8428: LIST
8429: LIST
8430: LIST
8431: PPUSH
8432: CALL_OW 69
8436: IFFALSE 8539
8438: GO 8440
8440: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8441: LD_INT 45
8443: PPUSH
8444: CALL_OW 302
8448: PUSH
8449: LD_INT 45
8451: PPUSH
8452: CALL_OW 255
8456: AND
8457: IFFALSE 8500
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8459: LD_INT 22
8461: PUSH
8462: LD_INT 2
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: PUSH
8469: LD_INT 34
8471: PUSH
8472: LD_INT 31
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: PUSH
8479: EMPTY
8480: LIST
8481: LIST
8482: PPUSH
8483: CALL_OW 69
8487: PPUSH
8488: LD_INT 18
8490: PPUSH
8491: LD_INT 8
8493: PPUSH
8494: CALL_OW 111
8498: GO 8539
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8500: LD_INT 22
8502: PUSH
8503: LD_INT 2
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: PUSH
8510: LD_INT 34
8512: PUSH
8513: LD_INT 31
8515: PUSH
8516: EMPTY
8517: LIST
8518: LIST
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: PPUSH
8524: CALL_OW 69
8528: PPUSH
8529: LD_INT 106
8531: PPUSH
8532: LD_INT 14
8534: PPUSH
8535: CALL_OW 111
// end ; end_of_file
8539: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8540: LD_INT 0
8542: PPUSH
8543: PPUSH
8544: PPUSH
8545: PPUSH
8546: PPUSH
8547: PPUSH
// InGameOn ;
8548: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8552: LD_EXP 21
8556: PPUSH
8557: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8561: LD_INT 2
8563: PPUSH
8564: LD_INT 1
8566: PPUSH
8567: LD_INT 1
8569: PPUSH
8570: LD_INT 1
8572: PPUSH
8573: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8577: LD_ADDR_VAR 0 2
8581: PUSH
8582: LD_INT 22
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: PUSH
8592: LD_INT 25
8594: PUSH
8595: LD_INT 1
8597: PUSH
8598: EMPTY
8599: LIST
8600: LIST
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PPUSH
8606: CALL_OW 69
8610: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8611: LD_ADDR_VAR 0 4
8615: PUSH
8616: LD_INT 22
8618: PUSH
8619: LD_INT 1
8621: PUSH
8622: EMPTY
8623: LIST
8624: LIST
8625: PUSH
8626: LD_INT 34
8628: PUSH
8629: LD_INT 11
8631: PUSH
8632: EMPTY
8633: LIST
8634: LIST
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: PPUSH
8640: CALL_OW 69
8644: PUSH
8645: LD_INT 1
8647: ARRAY
8648: ST_TO_ADDR
// for i = 1 to tmp do
8649: LD_ADDR_VAR 0 6
8653: PUSH
8654: DOUBLE
8655: LD_INT 1
8657: DEC
8658: ST_TO_ADDR
8659: LD_VAR 0 2
8663: PUSH
8664: FOR_TO
8665: IFFALSE 8712
// begin if i = 5 then
8667: LD_VAR 0 6
8671: PUSH
8672: LD_INT 5
8674: EQUAL
8675: IFFALSE 8679
// break ;
8677: GO 8712
// sols := Replace ( sols , i , tmp [ i ] ) ;
8679: LD_ADDR_VAR 0 5
8683: PUSH
8684: LD_VAR 0 5
8688: PPUSH
8689: LD_VAR 0 6
8693: PPUSH
8694: LD_VAR 0 2
8698: PUSH
8699: LD_VAR 0 6
8703: ARRAY
8704: PPUSH
8705: CALL_OW 1
8709: ST_TO_ADDR
// end ;
8710: GO 8664
8712: POP
8713: POP
// tmp := ar_force_tmp ;
8714: LD_ADDR_VAR 0 2
8718: PUSH
8719: LD_EXP 40
8723: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8724: LD_VAR 0 2
8728: PUSH
8729: LD_INT 1
8731: ARRAY
8732: PPUSH
8733: LD_INT 108
8735: PPUSH
8736: LD_INT 139
8738: PPUSH
8739: LD_INT 0
8741: PPUSH
8742: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8746: LD_VAR 0 2
8750: PUSH
8751: LD_INT 1
8753: ARRAY
8754: PPUSH
8755: LD_EXP 21
8759: PPUSH
8760: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8764: LD_VAR 0 2
8768: PUSH
8769: LD_INT 2
8771: ARRAY
8772: PPUSH
8773: LD_INT 114
8775: PPUSH
8776: LD_INT 132
8778: PPUSH
8779: LD_INT 0
8781: PPUSH
8782: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8786: LD_VAR 0 2
8790: PUSH
8791: LD_INT 3
8793: ARRAY
8794: PPUSH
8795: LD_INT 115
8797: PPUSH
8798: LD_INT 132
8800: PPUSH
8801: LD_INT 0
8803: PPUSH
8804: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8808: LD_VAR 0 2
8812: PUSH
8813: LD_INT 2
8815: ARRAY
8816: PUSH
8817: LD_VAR 0 2
8821: PUSH
8822: LD_INT 3
8824: ARRAY
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: PPUSH
8830: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8834: LD_VAR 0 4
8838: PPUSH
8839: LD_INT 83
8841: PPUSH
8842: LD_INT 123
8844: PPUSH
8845: CALL_OW 111
// Wait ( 0 0$01 ) ;
8849: LD_INT 35
8851: PPUSH
8852: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8856: LD_INT 90
8858: PPUSH
8859: LD_INT 144
8861: PPUSH
8862: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8866: LD_VAR 0 5
8870: PPUSH
8871: LD_INT 88
8873: PPUSH
8874: LD_INT 129
8876: PPUSH
8877: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8881: LD_ADDR_VAR 0 3
8885: PUSH
8886: LD_INT 92
8888: PUSH
8889: LD_INT 131
8891: PUSH
8892: EMPTY
8893: LIST
8894: LIST
8895: PUSH
8896: LD_INT 88
8898: PUSH
8899: LD_INT 127
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PUSH
8906: LD_INT 91
8908: PUSH
8909: LD_INT 132
8911: PUSH
8912: EMPTY
8913: LIST
8914: LIST
8915: PUSH
8916: LD_INT 92
8918: PUSH
8919: LD_INT 134
8921: PUSH
8922: EMPTY
8923: LIST
8924: LIST
8925: PUSH
8926: EMPTY
8927: LIST
8928: LIST
8929: LIST
8930: LIST
8931: ST_TO_ADDR
// for i = 1 to sols do
8932: LD_ADDR_VAR 0 6
8936: PUSH
8937: DOUBLE
8938: LD_INT 1
8940: DEC
8941: ST_TO_ADDR
8942: LD_VAR 0 5
8946: PUSH
8947: FOR_TO
8948: IFFALSE 9021
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8950: LD_VAR 0 5
8954: PUSH
8955: LD_VAR 0 6
8959: ARRAY
8960: PPUSH
8961: LD_VAR 0 3
8965: PUSH
8966: LD_VAR 0 6
8970: ARRAY
8971: PUSH
8972: LD_INT 1
8974: ARRAY
8975: PPUSH
8976: LD_VAR 0 3
8980: PUSH
8981: LD_VAR 0 6
8985: ARRAY
8986: PUSH
8987: LD_INT 2
8989: ARRAY
8990: PPUSH
8991: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8995: LD_VAR 0 5
8999: PUSH
9000: LD_VAR 0 6
9004: ARRAY
9005: PPUSH
9006: CALL_OW 197
// AddComHold ( sols ) ;
9010: LD_VAR 0 5
9014: PPUSH
9015: CALL_OW 200
// end ;
9019: GO 8947
9021: POP
9022: POP
// repeat wait ( 0 0$1 ) ;
9023: LD_INT 35
9025: PPUSH
9026: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9030: LD_VAR 0 5
9034: PUSH
9035: LD_INT 1
9037: ARRAY
9038: PPUSH
9039: LD_INT 92
9041: PPUSH
9042: LD_INT 131
9044: PPUSH
9045: CALL_OW 297
9049: PUSH
9050: LD_INT 4
9052: LESS
9053: IFFALSE 9023
// CenterOnXY ( 96 , 139 ) ;
9055: LD_INT 96
9057: PPUSH
9058: LD_INT 139
9060: PPUSH
9061: CALL_OW 84
// wait ( 0 0$3 ) ;
9065: LD_INT 105
9067: PPUSH
9068: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9072: LD_INT 111
9074: PPUSH
9075: LD_INT 135
9077: PPUSH
9078: LD_INT 1
9080: PPUSH
9081: LD_INT 25
9083: NEG
9084: PPUSH
9085: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9089: LD_VAR 0 2
9093: PUSH
9094: LD_INT 2
9096: ARRAY
9097: PPUSH
9098: LD_VAR 0 2
9102: PUSH
9103: LD_INT 1
9105: ARRAY
9106: PPUSH
9107: CALL_OW 250
9111: PUSH
9112: LD_INT 3
9114: PLUS
9115: PPUSH
9116: LD_VAR 0 2
9120: PUSH
9121: LD_INT 1
9123: ARRAY
9124: PPUSH
9125: CALL_OW 251
9129: PPUSH
9130: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9134: LD_VAR 0 2
9138: PUSH
9139: LD_INT 3
9141: ARRAY
9142: PPUSH
9143: LD_INT 7
9145: PPUSH
9146: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9150: LD_VAR 0 2
9154: PUSH
9155: LD_INT 2
9157: ARRAY
9158: PPUSH
9159: LD_VAR 0 2
9163: PUSH
9164: LD_INT 1
9166: ARRAY
9167: PPUSH
9168: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9172: LD_INT 35
9174: PPUSH
9175: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9179: LD_VAR 0 2
9183: PUSH
9184: LD_INT 1
9186: ARRAY
9187: PPUSH
9188: LD_VAR 0 2
9192: PUSH
9193: LD_INT 2
9195: ARRAY
9196: PPUSH
9197: CALL_OW 296
9201: PUSH
9202: LD_INT 5
9204: LESS
9205: IFFALSE 9172
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9207: LD_VAR 0 2
9211: PUSH
9212: LD_INT 1
9214: ARRAY
9215: PPUSH
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 2
9223: ARRAY
9224: PPUSH
9225: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9229: LD_VAR 0 2
9233: PUSH
9234: LD_INT 1
9236: ARRAY
9237: PPUSH
9238: LD_STRING D1a-Merc1-1
9240: PPUSH
9241: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9245: LD_VAR 0 2
9249: PUSH
9250: LD_INT 2
9252: ARRAY
9253: PPUSH
9254: LD_STRING D1a-FMerc2-1
9256: PPUSH
9257: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9261: LD_VAR 0 2
9265: PUSH
9266: LD_INT 2
9268: ARRAY
9269: PPUSH
9270: LD_VAR 0 2
9274: PUSH
9275: LD_INT 1
9277: ARRAY
9278: PPUSH
9279: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9283: LD_VAR 0 2
9287: PUSH
9288: LD_INT 1
9290: ARRAY
9291: PPUSH
9292: LD_INT 500
9294: PPUSH
9295: CALL_OW 234
// wait ( 0 0$2 ) ;
9299: LD_INT 70
9301: PPUSH
9302: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9306: LD_VAR 0 2
9310: PUSH
9311: LD_INT 1
9313: ARRAY
9314: PPUSH
9315: LD_INT 2
9317: PPUSH
9318: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9322: LD_INT 10
9324: PPUSH
9325: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9329: LD_VAR 0 2
9333: PUSH
9334: LD_INT 1
9336: ARRAY
9337: PPUSH
9338: LD_STRING D1a-Merc1-2
9340: PPUSH
9341: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9345: LD_INT 7
9347: PPUSH
9348: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9352: LD_VAR 0 2
9356: PUSH
9357: LD_INT 1
9359: ARRAY
9360: PPUSH
9361: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9365: LD_VAR 0 2
9369: PUSH
9370: LD_INT 2
9372: ARRAY
9373: PPUSH
9374: LD_INT 10
9376: PPUSH
9377: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9381: LD_VAR 0 2
9385: PUSH
9386: LD_INT 2
9388: ARRAY
9389: PPUSH
9390: LD_STRING D1a-FMerc2-2
9392: PPUSH
9393: CALL_OW 88
// wait ( 0 0$1 ) ;
9397: LD_INT 35
9399: PPUSH
9400: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9404: LD_INT 7
9406: PPUSH
9407: CALL_OW 85
// wait ( 0 0$2 ) ;
9411: LD_INT 70
9413: PPUSH
9414: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9418: LD_EXP 44
9422: PPUSH
9423: LD_STRING D1a-Saliba-1
9425: PPUSH
9426: CALL_OW 91
// KillUnit ( Saliba ) ;
9430: LD_EXP 44
9434: PPUSH
9435: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9439: LD_VAR 0 2
9443: PUSH
9444: LD_INT 3
9446: ARRAY
9447: PPUSH
9448: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9452: LD_EXP 21
9456: PPUSH
9457: CALL_OW 85
// wait ( 0 0$1 ) ;
9461: LD_INT 35
9463: PPUSH
9464: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9468: LD_VAR 0 5
9472: PPUSH
9473: LD_INT 88
9475: PPUSH
9476: LD_INT 141
9478: PPUSH
9479: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9483: LD_VAR 0 5
9487: PPUSH
9488: LD_INT 70
9490: PPUSH
9491: CALL_OW 202
// wait ( 0 0$2 ) ;
9495: LD_INT 70
9497: PPUSH
9498: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9502: LD_INT 2
9504: PPUSH
9505: LD_INT 1
9507: PPUSH
9508: LD_INT 2
9510: PPUSH
9511: LD_INT 1
9513: PPUSH
9514: CALL_OW 80
// InGameOff ;
9518: CALL_OW 9
// ComWalk ( sols ) ;
9522: LD_VAR 0 5
9526: PPUSH
9527: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9531: LD_STRING M1
9533: PPUSH
9534: CALL_OW 337
// game_speed := 4 ;
9538: LD_ADDR_OWVAR 65
9542: PUSH
9543: LD_INT 4
9545: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9546: LD_INT 111
9548: PPUSH
9549: LD_INT 135
9551: PPUSH
9552: LD_INT 1
9554: PPUSH
9555: CALL_OW 331
// SaveForQuickRestart ;
9559: CALL_OW 22
// ar_run := true ;
9563: LD_ADDR_EXP 5
9567: PUSH
9568: LD_INT 1
9570: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9571: LD_INT 35
9573: PPUSH
9574: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9578: LD_INT 22
9580: PUSH
9581: LD_INT 1
9583: PUSH
9584: EMPTY
9585: LIST
9586: LIST
9587: PUSH
9588: LD_INT 91
9590: PUSH
9591: LD_INT 7
9593: PUSH
9594: LD_INT 10
9596: PUSH
9597: EMPTY
9598: LIST
9599: LIST
9600: LIST
9601: PUSH
9602: EMPTY
9603: LIST
9604: LIST
9605: PPUSH
9606: CALL_OW 69
9610: PUSH
9611: LD_INT 7
9613: PPUSH
9614: CALL_OW 256
9618: PUSH
9619: LD_INT 999
9621: LESS
9622: OR
9623: IFFALSE 9571
// if GetSide ( ar_dep_s ) = 2 then
9625: LD_INT 7
9627: PPUSH
9628: CALL_OW 255
9632: PUSH
9633: LD_INT 2
9635: EQUAL
9636: IFFALSE 9648
// SetSide ( ar_dep_s , 1 ) ;
9638: LD_INT 7
9640: PPUSH
9641: LD_INT 1
9643: PPUSH
9644: CALL_OW 235
// end ;
9648: LD_VAR 0 1
9652: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9653: LD_EXP 5
9657: IFFALSE 10017
9659: GO 9661
9661: DISABLE
9662: LD_INT 0
9664: PPUSH
9665: PPUSH
9666: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9667: LD_ADDR_VAR 0 2
9671: PUSH
9672: LD_EXP 40
9676: PUSH
9677: LD_EXP 36
9681: PPUSH
9682: LD_INT 2
9684: PUSH
9685: LD_INT 21
9687: PUSH
9688: LD_INT 2
9690: PUSH
9691: EMPTY
9692: LIST
9693: LIST
9694: PUSH
9695: LD_INT 21
9697: PUSH
9698: LD_INT 1
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: LIST
9709: PPUSH
9710: CALL_OW 72
9714: ADD
9715: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9716: LD_VAR 0 2
9720: PPUSH
9721: LD_INT 5
9723: PPUSH
9724: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9728: LD_INT 5
9730: PPUSH
9731: LD_INT 1
9733: PPUSH
9734: CALL_OW 343
// k := 1 ;
9738: LD_ADDR_VAR 0 3
9742: PUSH
9743: LD_INT 1
9745: ST_TO_ADDR
// for i in tmp do
9746: LD_ADDR_VAR 0 1
9750: PUSH
9751: LD_VAR 0 2
9755: PUSH
9756: FOR_IN
9757: IFFALSE 9842
// begin if IsInUnit ( i ) then
9759: LD_VAR 0 1
9763: PPUSH
9764: CALL_OW 310
9768: IFFALSE 9779
// ComExitBuilding ( i ) ;
9770: LD_VAR 0 1
9774: PPUSH
9775: CALL_OW 122
// if GetClass ( i ) = 3 then
9779: LD_VAR 0 1
9783: PPUSH
9784: CALL_OW 257
9788: PUSH
9789: LD_INT 3
9791: EQUAL
9792: IFFALSE 9828
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9794: LD_VAR 0 1
9798: PPUSH
9799: LD_EXP 41
9803: PUSH
9804: LD_VAR 0 3
9808: ARRAY
9809: PPUSH
9810: CALL_OW 180
// k := k + 1 ;
9814: LD_ADDR_VAR 0 3
9818: PUSH
9819: LD_VAR 0 3
9823: PUSH
9824: LD_INT 1
9826: PLUS
9827: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9828: LD_VAR 0 1
9832: PPUSH
9833: LD_INT 10
9835: PPUSH
9836: CALL_OW 173
// end ;
9840: GO 9756
9842: POP
9843: POP
// ar_patrol := true ;
9844: LD_ADDR_EXP 7
9848: PUSH
9849: LD_INT 1
9851: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9852: LD_INT 10
9854: PPUSH
9855: CALL_OW 67
// for i in tmp do
9859: LD_ADDR_VAR 0 1
9863: PUSH
9864: LD_VAR 0 2
9868: PUSH
9869: FOR_IN
9870: IFFALSE 9898
// if not HasTask ( i ) then
9872: LD_VAR 0 1
9876: PPUSH
9877: CALL_OW 314
9881: NOT
9882: IFFALSE 9896
// ComMoveToArea ( i , escape_area ) ;
9884: LD_VAR 0 1
9888: PPUSH
9889: LD_INT 10
9891: PPUSH
9892: CALL_OW 113
9896: GO 9869
9898: POP
9899: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9900: LD_ADDR_VAR 0 3
9904: PUSH
9905: LD_VAR 0 2
9909: PPUSH
9910: LD_INT 95
9912: PUSH
9913: LD_INT 10
9915: PUSH
9916: EMPTY
9917: LIST
9918: LIST
9919: PPUSH
9920: CALL_OW 72
9924: ST_TO_ADDR
// if k then
9925: LD_VAR 0 3
9929: IFFALSE 9998
// for i in k do
9931: LD_ADDR_VAR 0 1
9935: PUSH
9936: LD_VAR 0 3
9940: PUSH
9941: FOR_IN
9942: IFFALSE 9996
// begin if IsInUnit ( i ) then
9944: LD_VAR 0 1
9948: PPUSH
9949: CALL_OW 310
9953: IFFALSE 9969
// RemoveUnit ( IsInUnit ( i ) ) ;
9955: LD_VAR 0 1
9959: PPUSH
9960: CALL_OW 310
9964: PPUSH
9965: CALL_OW 64
// RemoveUnit ( i ) ;
9969: LD_VAR 0 1
9973: PPUSH
9974: CALL_OW 64
// tmp := tmp diff i ;
9978: LD_ADDR_VAR 0 2
9982: PUSH
9983: LD_VAR 0 2
9987: PUSH
9988: LD_VAR 0 1
9992: DIFF
9993: ST_TO_ADDR
// end ;
9994: GO 9941
9996: POP
9997: POP
// until tmp = [ ] ;
9998: LD_VAR 0 2
10002: PUSH
10003: EMPTY
10004: EQUAL
10005: IFFALSE 9852
// ChangeSideFog ( 5 , 5 ) ;
10007: LD_INT 5
10009: PPUSH
10010: LD_INT 5
10012: PPUSH
10013: CALL_OW 343
// end ;
10017: PPOPN 3
10019: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10020: LD_EXP 7
10024: IFFALSE 10314
10026: GO 10028
10028: DISABLE
10029: LD_INT 0
10031: PPUSH
10032: PPUSH
10033: PPUSH
// begin uc_side := 2 ;
10034: LD_ADDR_OWVAR 20
10038: PUSH
10039: LD_INT 2
10041: ST_TO_ADDR
// uc_nation := 2 ;
10042: LD_ADDR_OWVAR 21
10046: PUSH
10047: LD_INT 2
10049: ST_TO_ADDR
// InitHc ;
10050: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10054: LD_INT 1
10056: PPUSH
10057: LD_INT 1
10059: PPUSH
10060: LD_INT 6
10062: PPUSH
10063: CALL_OW 380
// un := CreateHuman ;
10067: LD_ADDR_VAR 0 2
10071: PUSH
10072: CALL_OW 44
10076: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10077: LD_INT 14
10079: PPUSH
10080: LD_INT 1
10082: PPUSH
10083: LD_INT 1
10085: PPUSH
10086: LD_INT 27
10088: PPUSH
10089: LD_INT 98
10091: PPUSH
10092: CALL 53663 0 5
// veh := CreateVehicle ;
10096: LD_ADDR_VAR 0 3
10100: PUSH
10101: CALL_OW 45
10105: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10106: LD_VAR 0 3
10110: PPUSH
10111: LD_INT 4
10113: PPUSH
10114: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10118: LD_VAR 0 3
10122: PPUSH
10123: LD_INT 179
10125: PPUSH
10126: LD_INT 135
10128: PPUSH
10129: LD_INT 0
10131: PPUSH
10132: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10136: LD_VAR 0 2
10140: PPUSH
10141: LD_VAR 0 3
10145: PPUSH
10146: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10150: LD_VAR 0 2
10154: PPUSH
10155: LD_INT 126
10157: PPUSH
10158: LD_INT 133
10160: PPUSH
10161: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10165: LD_INT 10
10167: PPUSH
10168: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10172: LD_INT 1
10174: PPUSH
10175: LD_VAR 0 3
10179: PPUSH
10180: CALL_OW 292
10184: PUSH
10185: LD_VAR 0 3
10189: PPUSH
10190: LD_INT 7
10192: PPUSH
10193: CALL_OW 296
10197: PUSH
10198: LD_INT 9
10200: LESS
10201: OR
10202: IFFALSE 10165
// ComHold ( veh ) ;
10204: LD_VAR 0 3
10208: PPUSH
10209: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10213: LD_VAR 0 2
10217: PPUSH
10218: LD_STRING D2aa-Ar1-1
10220: PPUSH
10221: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10225: LD_VAR 0 2
10229: PPUSH
10230: LD_INT 177
10232: PPUSH
10233: LD_INT 96
10235: PPUSH
10236: CALL_OW 111
// AddComExitVehicle ( un ) ;
10240: LD_VAR 0 2
10244: PPUSH
10245: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10249: LD_INT 35
10251: PPUSH
10252: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10256: LD_VAR 0 2
10260: PPUSH
10261: LD_INT 204
10263: PPUSH
10264: CALL_OW 296
10268: PUSH
10269: LD_INT 15
10271: LESS
10272: IFFALSE 10249
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10274: LD_ADDR_EXP 50
10278: PUSH
10279: LD_EXP 50
10283: PPUSH
10284: LD_INT 3
10286: PUSH
10287: LD_EXP 50
10291: PUSH
10292: LD_INT 3
10294: ARRAY
10295: PUSH
10296: LD_INT 1
10298: PLUS
10299: PUSH
10300: EMPTY
10301: LIST
10302: LIST
10303: PPUSH
10304: LD_VAR 0 2
10308: PPUSH
10309: CALL 53785 0 3
10313: ST_TO_ADDR
// end ;
10314: PPOPN 3
10316: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10317: LD_INT 7
10319: PPUSH
10320: CALL_OW 255
10324: PUSH
10325: LD_INT 1
10327: EQUAL
10328: PUSH
10329: LD_INT 7
10331: PPUSH
10332: CALL_OW 301
10336: OR
10337: IFFALSE 12742
10339: GO 10341
10341: DISABLE
10342: LD_INT 0
10344: PPUSH
10345: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10346: LD_ADDR_VAR 0 1
10350: PUSH
10351: LD_EXP 36
10355: PPUSH
10356: LD_INT 21
10358: PUSH
10359: LD_INT 3
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: PPUSH
10366: CALL_OW 72
10370: PUSH
10371: FOR_IN
10372: IFFALSE 10388
// SetSide ( i , 1 ) ;
10374: LD_VAR 0 1
10378: PPUSH
10379: LD_INT 1
10381: PPUSH
10382: CALL_OW 235
10386: GO 10371
10388: POP
10389: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10390: LD_ADDR_VAR 0 2
10394: PUSH
10395: LD_INT 46
10397: PUSH
10398: LD_INT 41
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PUSH
10405: LD_INT 50
10407: PUSH
10408: LD_INT 25
10410: PUSH
10411: EMPTY
10412: LIST
10413: LIST
10414: PUSH
10415: LD_INT 57
10417: PUSH
10418: LD_INT 75
10420: PUSH
10421: EMPTY
10422: LIST
10423: LIST
10424: PUSH
10425: LD_INT 75
10427: PUSH
10428: LD_INT 89
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: PUSH
10435: LD_INT 51
10437: PUSH
10438: LD_INT 45
10440: PUSH
10441: EMPTY
10442: LIST
10443: LIST
10444: PUSH
10445: LD_INT 95
10447: PUSH
10448: LD_INT 95
10450: PUSH
10451: EMPTY
10452: LIST
10453: LIST
10454: PUSH
10455: LD_INT 84
10457: PUSH
10458: LD_INT 77
10460: PUSH
10461: EMPTY
10462: LIST
10463: LIST
10464: PUSH
10465: LD_INT 101
10467: PUSH
10468: LD_INT 76
10470: PUSH
10471: EMPTY
10472: LIST
10473: LIST
10474: PUSH
10475: LD_INT 118
10477: PUSH
10478: LD_INT 81
10480: PUSH
10481: EMPTY
10482: LIST
10483: LIST
10484: PUSH
10485: LD_INT 139
10487: PUSH
10488: LD_INT 97
10490: PUSH
10491: EMPTY
10492: LIST
10493: LIST
10494: PUSH
10495: LD_INT 129
10497: PUSH
10498: LD_INT 114
10500: PUSH
10501: EMPTY
10502: LIST
10503: LIST
10504: PUSH
10505: LD_INT 154
10507: PUSH
10508: LD_INT 111
10510: PUSH
10511: EMPTY
10512: LIST
10513: LIST
10514: PUSH
10515: EMPTY
10516: LIST
10517: LIST
10518: LIST
10519: LIST
10520: LIST
10521: LIST
10522: LIST
10523: LIST
10524: LIST
10525: LIST
10526: LIST
10527: LIST
10528: ST_TO_ADDR
// base_captured := true ;
10529: LD_ADDR_EXP 6
10533: PUSH
10534: LD_INT 1
10536: ST_TO_ADDR
// DialogueOn ;
10537: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10541: LD_EXP 21
10545: PPUSH
10546: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10550: LD_EXP 21
10554: PPUSH
10555: LD_STRING D2-JMM-1
10557: PPUSH
10558: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10562: LD_EXP 30
10566: PPUSH
10567: LD_STRING D2-Pow-1
10569: PPUSH
10570: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10574: LD_EXP 21
10578: PPUSH
10579: LD_STRING D2-JMM-2
10581: PPUSH
10582: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10586: LD_EXP 30
10590: PPUSH
10591: LD_STRING D2-Pow-2
10593: PPUSH
10594: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10598: LD_EXP 21
10602: PPUSH
10603: LD_STRING D2-JMM-3
10605: PPUSH
10606: CALL_OW 88
// DialogueOff ;
10610: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10614: LD_STRING M2
10616: PPUSH
10617: CALL_OW 337
// Wait ( 0 0$2 ) ;
10621: LD_INT 70
10623: PPUSH
10624: CALL_OW 67
// if IsOk ( Gary ) then
10628: LD_EXP 32
10632: PPUSH
10633: CALL_OW 302
10637: IFFALSE 10651
// Say ( Gary , D2a-Gary-1 ) ;
10639: LD_EXP 32
10643: PPUSH
10644: LD_STRING D2a-Gary-1
10646: PPUSH
10647: CALL_OW 88
// if IsOk ( Bobby ) then
10651: LD_EXP 24
10655: PPUSH
10656: CALL_OW 302
10660: IFFALSE 10674
// Say ( Bobby , D2a-Bobby-1 ) ;
10662: LD_EXP 24
10666: PPUSH
10667: LD_STRING D2a-Bobby-1
10669: PPUSH
10670: CALL_OW 88
// if IsOk ( Cyrus ) then
10674: LD_EXP 25
10678: PPUSH
10679: CALL_OW 302
10683: IFFALSE 10697
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10685: LD_EXP 25
10689: PPUSH
10690: LD_STRING D2a-Cyrus-1
10692: PPUSH
10693: CALL_OW 88
// if IsOk ( Lisa ) then
10697: LD_EXP 22
10701: PPUSH
10702: CALL_OW 302
10706: IFFALSE 10720
// Say ( Lisa , D2a-Lisa-1 ) ;
10708: LD_EXP 22
10712: PPUSH
10713: LD_STRING D2a-Lisa-1
10715: PPUSH
10716: CALL_OW 88
// if IsOk ( Frank ) then
10720: LD_EXP 33
10724: PPUSH
10725: CALL_OW 302
10729: IFFALSE 10743
// Say ( Frank , D2a-Frank-1 ) ;
10731: LD_EXP 33
10735: PPUSH
10736: LD_STRING D2a-Frank-1
10738: PPUSH
10739: CALL_OW 88
// if IsOk ( Cornel ) then
10743: LD_EXP 31
10747: PPUSH
10748: CALL_OW 302
10752: IFFALSE 10766
// Say ( Cornel , D2a-Corn-1 ) ;
10754: LD_EXP 31
10758: PPUSH
10759: LD_STRING D2a-Corn-1
10761: PPUSH
10762: CALL_OW 88
// if IsOk ( Donaldson ) then
10766: LD_EXP 23
10770: PPUSH
10771: CALL_OW 302
10775: IFFALSE 10789
// Say ( Donaldson , D2a-Don-1 ) ;
10777: LD_EXP 23
10781: PPUSH
10782: LD_STRING D2a-Don-1
10784: PPUSH
10785: CALL_OW 88
// if IsOk ( Brown ) then
10789: LD_EXP 27
10793: PPUSH
10794: CALL_OW 302
10798: IFFALSE 10812
// Say ( Brown , D2a-Brown-1 ) ;
10800: LD_EXP 27
10804: PPUSH
10805: LD_STRING D2a-Brown-1
10807: PPUSH
10808: CALL_OW 88
// Wait ( 0 0$30 ) ;
10812: LD_INT 1050
10814: PPUSH
10815: CALL_OW 67
// if IsOk ( Frank ) then
10819: LD_EXP 33
10823: PPUSH
10824: CALL_OW 302
10828: IFFALSE 11808
// begin DialogueOn ;
10830: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10834: LD_EXP 21
10838: PUSH
10839: LD_EXP 33
10843: PUSH
10844: EMPTY
10845: LIST
10846: LIST
10847: PPUSH
10848: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10852: LD_EXP 33
10856: PPUSH
10857: LD_STRING D3F-Frank-1
10859: PPUSH
10860: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10864: LD_EXP 21
10868: PPUSH
10869: LD_STRING D3F-JMM-1
10871: PPUSH
10872: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10876: LD_EXP 33
10880: PPUSH
10881: LD_STRING D3F-Frank-2
10883: PPUSH
10884: CALL_OW 88
// case Query ( QFrank ) of 1 :
10888: LD_STRING QFrank
10890: PPUSH
10891: CALL_OW 97
10895: PUSH
10896: LD_INT 1
10898: DOUBLE
10899: EQUAL
10900: IFTRUE 10904
10902: GO 10927
10904: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10905: LD_EXP 21
10909: PPUSH
10910: LD_STRING D3Fa-JMM-1
10912: PPUSH
10913: CALL_OW 88
// us_scout := 1 ;
10917: LD_ADDR_EXP 8
10921: PUSH
10922: LD_INT 1
10924: ST_TO_ADDR
// end ; 2 :
10925: GO 11090
10927: LD_INT 2
10929: DOUBLE
10930: EQUAL
10931: IFTRUE 10935
10933: GO 11057
10935: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10936: LD_EXP 21
10940: PPUSH
10941: LD_STRING D3Fb-JMM-1
10943: PPUSH
10944: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10948: LD_EXP 33
10952: PPUSH
10953: LD_STRING D3Fb-Frank-1
10955: PPUSH
10956: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10960: LD_STRING QFrank2
10962: PPUSH
10963: CALL_OW 97
10967: PUSH
10968: LD_INT 1
10970: DOUBLE
10971: EQUAL
10972: IFTRUE 10976
10974: GO 11023
10976: POP
// begin us_scout := 2 ;
10977: LD_ADDR_EXP 8
10981: PUSH
10982: LD_INT 2
10984: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10985: LD_EXP 21
10989: PPUSH
10990: LD_STRING D3Fba-JMM-1
10992: PPUSH
10993: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10997: LD_EXP 33
11001: PPUSH
11002: LD_STRING D3Fba-Frank-1
11004: PPUSH
11005: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11009: LD_EXP 21
11013: PPUSH
11014: LD_STRING D3Fba-JMM-2
11016: PPUSH
11017: CALL_OW 88
// end ; 2 :
11021: GO 11055
11023: LD_INT 2
11025: DOUBLE
11026: EQUAL
11027: IFTRUE 11031
11029: GO 11054
11031: POP
// begin us_scout := 0 ;
11032: LD_ADDR_EXP 8
11036: PUSH
11037: LD_INT 0
11039: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11040: LD_EXP 21
11044: PPUSH
11045: LD_STRING D3Fbb-JMM-1
11047: PPUSH
11048: CALL_OW 88
// end ; end ;
11052: GO 11055
11054: POP
// end ; 3 :
11055: GO 11090
11057: LD_INT 3
11059: DOUBLE
11060: EQUAL
11061: IFTRUE 11065
11063: GO 11089
11065: POP
// begin us_scout := - 1 ;
11066: LD_ADDR_EXP 8
11070: PUSH
11071: LD_INT 1
11073: NEG
11074: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11075: LD_EXP 21
11079: PPUSH
11080: LD_STRING D3Fc-JMM-1
11082: PPUSH
11083: CALL_OW 88
// end ; end ;
11087: GO 11090
11089: POP
// DialogueOff ;
11090: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11094: LD_EXP 8
11098: PUSH
11099: LD_INT 1
11101: NEG
11102: PUSH
11103: LD_INT 0
11105: PUSH
11106: EMPTY
11107: LIST
11108: LIST
11109: IN
11110: IFFALSE 11114
// exit ;
11112: GO 12742
// if us_scout in [ 1 , 2 ] then
11114: LD_EXP 8
11118: PUSH
11119: LD_INT 1
11121: PUSH
11122: LD_INT 2
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: IN
11129: IFFALSE 11808
// begin if IsInUnit ( Frank ) then
11131: LD_EXP 33
11135: PPUSH
11136: CALL_OW 310
11140: IFFALSE 11151
// ComExit ( Frank ) ;
11142: LD_EXP 33
11146: PPUSH
11147: CALL 86514 0 1
// SetSide ( Frank , 4 ) ;
11151: LD_EXP 33
11155: PPUSH
11156: LD_INT 4
11158: PPUSH
11159: CALL_OW 235
// wait ( 0 0$1 ) ;
11163: LD_INT 35
11165: PPUSH
11166: CALL_OW 67
// if us_scout = 2 then
11170: LD_EXP 8
11174: PUSH
11175: LD_INT 2
11177: EQUAL
11178: IFFALSE 11546
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11180: LD_EXP 33
11184: PPUSH
11185: LD_INT 75
11187: PPUSH
11188: LD_INT 63
11190: PPUSH
11191: CALL_OW 111
// AddComHold ( Frank ) ;
11195: LD_EXP 33
11199: PPUSH
11200: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11204: LD_EXP 33
11208: PPUSH
11209: LD_INT 770
11211: PPUSH
11212: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11216: LD_EXP 33
11220: PPUSH
11221: LD_INT 100
11223: PPUSH
11224: LD_INT 75
11226: PPUSH
11227: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11231: LD_EXP 33
11235: PPUSH
11236: LD_INT 123
11238: PPUSH
11239: LD_INT 103
11241: PPUSH
11242: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11246: LD_EXP 33
11250: PPUSH
11251: LD_INT 138
11253: PPUSH
11254: LD_INT 108
11256: PPUSH
11257: CALL_OW 171
// AddComHold ( Frank ) ;
11261: LD_EXP 33
11265: PPUSH
11266: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11270: LD_INT 35
11272: PPUSH
11273: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11277: LD_EXP 33
11281: PPUSH
11282: LD_INT 138
11284: PPUSH
11285: LD_INT 108
11287: PPUSH
11288: CALL_OW 307
11292: IFFALSE 11270
// AddComMoveXY ( Frank , 125 , 132 ) ;
11294: LD_EXP 33
11298: PPUSH
11299: LD_INT 125
11301: PPUSH
11302: LD_INT 132
11304: PPUSH
11305: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11309: LD_INT 35
11311: PPUSH
11312: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11316: LD_INT 1
11318: PPUSH
11319: LD_EXP 33
11323: PPUSH
11324: CALL_OW 292
11328: PUSH
11329: LD_EXP 33
11333: PPUSH
11334: LD_INT 7
11336: PPUSH
11337: CALL_OW 296
11341: PUSH
11342: LD_INT 7
11344: LESS
11345: OR
11346: IFFALSE 11309
// DialogueOn ;
11348: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11352: LD_EXP 33
11356: PPUSH
11357: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11361: LD_INT 10
11363: PPUSH
11364: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11368: LD_EXP 21
11372: PPUSH
11373: LD_STRING D4Fa-JMM-1
11375: PPUSH
11376: CALL_OW 88
// for i in points do
11380: LD_ADDR_VAR 0 1
11384: PUSH
11385: LD_VAR 0 2
11389: PUSH
11390: FOR_IN
11391: IFFALSE 11449
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11393: LD_VAR 0 1
11397: PUSH
11398: LD_INT 1
11400: ARRAY
11401: PPUSH
11402: LD_VAR 0 1
11406: PUSH
11407: LD_INT 2
11409: ARRAY
11410: PPUSH
11411: LD_INT 1
11413: PPUSH
11414: LD_INT 20
11416: NEG
11417: PPUSH
11418: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11422: LD_VAR 0 1
11426: PUSH
11427: LD_INT 1
11429: ARRAY
11430: PPUSH
11431: LD_VAR 0 1
11435: PUSH
11436: LD_INT 2
11438: ARRAY
11439: PPUSH
11440: LD_INT 1
11442: PPUSH
11443: CALL_OW 331
// end ;
11447: GO 11390
11449: POP
11450: POP
// dwait ( 0 0$0.5 ) ;
11451: LD_INT 18
11453: PPUSH
11454: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11458: LD_INT 42
11460: PPUSH
11461: LD_INT 27
11463: PPUSH
11464: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11468: LD_EXP 33
11472: PPUSH
11473: LD_STRING D4Fa-Frank-1
11475: PPUSH
11476: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11480: LD_INT 18
11482: PPUSH
11483: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11487: LD_EXP 21
11491: PPUSH
11492: LD_STRING D4Fa-JMM-2
11494: PPUSH
11495: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11499: LD_INT 118
11501: PPUSH
11502: LD_INT 80
11504: PPUSH
11505: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11509: LD_EXP 33
11513: PPUSH
11514: LD_STRING D4Fa-Frank-2
11516: PPUSH
11517: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11521: LD_INT 10
11523: PPUSH
11524: CALL_OW 68
// DialogueOff ;
11528: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11532: LD_EXP 33
11536: PPUSH
11537: LD_INT 1
11539: PPUSH
11540: CALL_OW 235
// end else
11544: GO 11808
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11546: LD_INT 2
11548: PPUSH
11549: LD_INT 4
11551: PPUSH
11552: LD_INT 2
11554: PPUSH
11555: LD_INT 1
11557: PPUSH
11558: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11562: LD_EXP 33
11566: PPUSH
11567: LD_INT 75
11569: PPUSH
11570: LD_INT 63
11572: PPUSH
11573: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11577: LD_EXP 33
11581: PPUSH
11582: LD_INT 175
11584: PPUSH
11585: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11589: LD_EXP 33
11593: PPUSH
11594: LD_INT 102
11596: PPUSH
11597: LD_INT 76
11599: PPUSH
11600: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11604: LD_EXP 33
11608: PPUSH
11609: LD_INT 108
11611: PPUSH
11612: LD_INT 70
11614: PPUSH
11615: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11619: LD_INT 35
11621: PPUSH
11622: CALL_OW 67
// until See ( 2 , Frank ) ;
11626: LD_INT 2
11628: PPUSH
11629: LD_EXP 33
11633: PPUSH
11634: CALL_OW 292
11638: IFFALSE 11619
// ComMoveXY ( Frank , 112 , 118 ) ;
11640: LD_EXP 33
11644: PPUSH
11645: LD_INT 112
11647: PPUSH
11648: LD_INT 118
11650: PPUSH
11651: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11655: LD_EXP 33
11659: PPUSH
11660: CALL_OW 256
11664: PUSH
11665: LD_INT 750
11667: GREATEREQUAL
11668: IFFALSE 11682
// SetLives ( Frank , 700 ) ;
11670: LD_EXP 33
11674: PPUSH
11675: LD_INT 700
11677: PPUSH
11678: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11682: LD_INT 35
11684: PPUSH
11685: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11689: LD_INT 1
11691: PPUSH
11692: LD_EXP 33
11696: PPUSH
11697: CALL_OW 292
11701: PUSH
11702: LD_EXP 33
11706: PPUSH
11707: LD_INT 7
11709: PPUSH
11710: CALL_OW 296
11714: PUSH
11715: LD_INT 17
11717: LESS
11718: OR
11719: IFFALSE 11682
// DialogueOn ;
11721: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11725: LD_EXP 33
11729: PPUSH
11730: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11734: LD_EXP 33
11738: PPUSH
11739: LD_STRING D4Fb-Frank-1
11741: PPUSH
11742: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11746: LD_EXP 21
11750: PPUSH
11751: LD_STRING D4Fb-JMM-1
11753: PPUSH
11754: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11758: LD_INT 2
11760: PPUSH
11761: LD_STRING D4Fb-FSci1-1
11763: PPUSH
11764: CALL 16719 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11768: LD_EXP 33
11772: PPUSH
11773: LD_STRING D4Fb-Frank-2
11775: PPUSH
11776: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11780: LD_EXP 21
11784: PPUSH
11785: LD_STRING D4Fb-JMM-2
11787: PPUSH
11788: CALL_OW 88
// DialogueOff ;
11792: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11796: LD_EXP 33
11800: PPUSH
11801: LD_INT 1
11803: PPUSH
11804: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
11808: LD_EXP 34
11812: PPUSH
11813: CALL_OW 302
11817: PUSH
11818: LD_EXP 33
11822: PPUSH
11823: CALL_OW 302
11827: NOT
11828: AND
11829: IFFALSE 12742
// begin DialogueOn ;
11831: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11835: LD_EXP 21
11839: PUSH
11840: LD_EXP 34
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PPUSH
11849: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11853: LD_EXP 34
11857: PPUSH
11858: LD_STRING D3Y-Yam-1
11860: PPUSH
11861: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11865: LD_EXP 21
11869: PPUSH
11870: LD_STRING D3Y-JMM-1
11872: PPUSH
11873: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11877: LD_EXP 34
11881: PPUSH
11882: LD_STRING D3Y-Yam-2
11884: PPUSH
11885: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11889: LD_STRING QYamoko
11891: PPUSH
11892: CALL_OW 97
11896: PUSH
11897: LD_INT 1
11899: DOUBLE
11900: EQUAL
11901: IFTRUE 11905
11903: GO 11940
11905: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11906: LD_EXP 21
11910: PPUSH
11911: LD_STRING D3Ya-JMM-1
11913: PPUSH
11914: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11918: LD_EXP 34
11922: PPUSH
11923: LD_STRING D3Ya-Yam-1
11925: PPUSH
11926: CALL_OW 88
// us_scout := 1 ;
11930: LD_ADDR_EXP 8
11934: PUSH
11935: LD_INT 1
11937: ST_TO_ADDR
// end ; 2 :
11938: GO 11973
11940: LD_INT 2
11942: DOUBLE
11943: EQUAL
11944: IFTRUE 11948
11946: GO 11972
11948: POP
// begin us_scout := - 1 ;
11949: LD_ADDR_EXP 8
11953: PUSH
11954: LD_INT 1
11956: NEG
11957: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11958: LD_EXP 21
11962: PPUSH
11963: LD_STRING D3Yb-JMM-1
11965: PPUSH
11966: CALL_OW 88
// end ; end ;
11970: GO 11973
11972: POP
// DialogueOff ;
11973: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11977: LD_EXP 8
11981: PUSH
11982: LD_INT 1
11984: NEG
11985: PUSH
11986: LD_INT 0
11988: PUSH
11989: EMPTY
11990: LIST
11991: LIST
11992: IN
11993: IFFALSE 11997
// exit ;
11995: GO 12742
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
11997: LD_ADDR_EXP 8
12001: PUSH
12002: LD_INT 2
12004: PUSH
12005: LD_INT 2
12007: PUSH
12008: LD_INT 1
12010: PUSH
12011: LD_INT 1
12013: PUSH
12014: EMPTY
12015: LIST
12016: LIST
12017: LIST
12018: LIST
12019: PUSH
12020: LD_OWVAR 67
12024: ARRAY
12025: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12026: LD_EXP 8
12030: PUSH
12031: LD_INT 1
12033: PUSH
12034: LD_INT 2
12036: PUSH
12037: EMPTY
12038: LIST
12039: LIST
12040: IN
12041: IFFALSE 12742
// begin if IsInUnit ( Kikuchi ) then
12043: LD_EXP 34
12047: PPUSH
12048: CALL_OW 310
12052: IFFALSE 12063
// ComExitBuilding ( Kikuchi ) ;
12054: LD_EXP 34
12058: PPUSH
12059: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12063: LD_EXP 34
12067: PPUSH
12068: CALL_OW 311
12072: IFFALSE 12083
// ComExitVehicle ( Kikuchi ) ;
12074: LD_EXP 34
12078: PPUSH
12079: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12083: LD_EXP 34
12087: PPUSH
12088: LD_INT 4
12090: PPUSH
12091: CALL_OW 235
// wait ( 0 0$1 ) ;
12095: LD_INT 35
12097: PPUSH
12098: CALL_OW 67
// if us_scout = 2 then
12102: LD_EXP 8
12106: PUSH
12107: LD_INT 2
12109: EQUAL
12110: IFFALSE 12490
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12112: LD_EXP 34
12116: PPUSH
12117: LD_INT 75
12119: PPUSH
12120: LD_INT 63
12122: PPUSH
12123: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12127: LD_EXP 34
12131: PPUSH
12132: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12136: LD_EXP 34
12140: PPUSH
12141: LD_INT 770
12143: PPUSH
12144: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12148: LD_EXP 34
12152: PPUSH
12153: LD_INT 100
12155: PPUSH
12156: LD_INT 75
12158: PPUSH
12159: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12163: LD_EXP 34
12167: PPUSH
12168: LD_INT 123
12170: PPUSH
12171: LD_INT 103
12173: PPUSH
12174: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12178: LD_EXP 34
12182: PPUSH
12183: LD_INT 138
12185: PPUSH
12186: LD_INT 108
12188: PPUSH
12189: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12193: LD_EXP 34
12197: PPUSH
12198: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12202: LD_INT 35
12204: PPUSH
12205: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12209: LD_EXP 34
12213: PPUSH
12214: LD_INT 138
12216: PPUSH
12217: LD_INT 108
12219: PPUSH
12220: CALL_OW 307
12224: IFFALSE 12202
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12226: LD_EXP 34
12230: PPUSH
12231: LD_INT 125
12233: PPUSH
12234: LD_INT 132
12236: PPUSH
12237: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12241: LD_INT 35
12243: PPUSH
12244: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12248: LD_INT 1
12250: PPUSH
12251: LD_EXP 34
12255: PPUSH
12256: CALL_OW 292
12260: PUSH
12261: LD_EXP 34
12265: PPUSH
12266: LD_INT 7
12268: PPUSH
12269: CALL_OW 296
12273: PUSH
12274: LD_INT 7
12276: LESS
12277: OR
12278: IFFALSE 12241
// DialogueOn ;
12280: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12284: LD_EXP 34
12288: PPUSH
12289: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12293: LD_INT 10
12295: PPUSH
12296: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12300: LD_EXP 34
12304: PPUSH
12305: LD_STRING D4Ya-Yam-1
12307: PPUSH
12308: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12312: LD_EXP 21
12316: PPUSH
12317: LD_STRING D4Ya-JMM-1
12319: PPUSH
12320: CALL_OW 88
// for i in points do
12324: LD_ADDR_VAR 0 1
12328: PUSH
12329: LD_VAR 0 2
12333: PUSH
12334: FOR_IN
12335: IFFALSE 12393
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12337: LD_VAR 0 1
12341: PUSH
12342: LD_INT 1
12344: ARRAY
12345: PPUSH
12346: LD_VAR 0 1
12350: PUSH
12351: LD_INT 2
12353: ARRAY
12354: PPUSH
12355: LD_INT 1
12357: PPUSH
12358: LD_INT 20
12360: NEG
12361: PPUSH
12362: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12366: LD_VAR 0 1
12370: PUSH
12371: LD_INT 1
12373: ARRAY
12374: PPUSH
12375: LD_VAR 0 1
12379: PUSH
12380: LD_INT 2
12382: ARRAY
12383: PPUSH
12384: LD_INT 1
12386: PPUSH
12387: CALL_OW 331
// end ;
12391: GO 12334
12393: POP
12394: POP
// dwait ( 0 0$0.5 ) ;
12395: LD_INT 18
12397: PPUSH
12398: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12402: LD_INT 42
12404: PPUSH
12405: LD_INT 27
12407: PPUSH
12408: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12412: LD_EXP 34
12416: PPUSH
12417: LD_STRING D4Ya-Yam-2
12419: PPUSH
12420: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12424: LD_INT 18
12426: PPUSH
12427: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12431: LD_INT 118
12433: PPUSH
12434: LD_INT 80
12436: PPUSH
12437: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12441: LD_EXP 21
12445: PPUSH
12446: LD_STRING D4Ya-JMM-2
12448: PPUSH
12449: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12453: LD_EXP 34
12457: PPUSH
12458: LD_STRING D4Ya-Yam-3
12460: PPUSH
12461: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12465: LD_INT 10
12467: PPUSH
12468: CALL_OW 68
// DialogueOff ;
12472: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12476: LD_EXP 34
12480: PPUSH
12481: LD_INT 1
12483: PPUSH
12484: CALL_OW 235
// end else
12488: GO 12742
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12490: LD_INT 2
12492: PPUSH
12493: LD_INT 4
12495: PPUSH
12496: LD_INT 2
12498: PPUSH
12499: LD_INT 1
12501: PPUSH
12502: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12506: LD_EXP 34
12510: PPUSH
12511: LD_INT 75
12513: PPUSH
12514: LD_INT 63
12516: PPUSH
12517: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12521: LD_EXP 34
12525: PPUSH
12526: LD_INT 175
12528: PPUSH
12529: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12533: LD_EXP 34
12537: PPUSH
12538: LD_INT 102
12540: PPUSH
12541: LD_INT 76
12543: PPUSH
12544: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12548: LD_EXP 34
12552: PPUSH
12553: LD_INT 108
12555: PPUSH
12556: LD_INT 70
12558: PPUSH
12559: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12563: LD_INT 35
12565: PPUSH
12566: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12570: LD_INT 2
12572: PPUSH
12573: LD_EXP 34
12577: PPUSH
12578: CALL_OW 292
12582: IFFALSE 12563
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12584: LD_EXP 34
12588: PPUSH
12589: LD_INT 112
12591: PPUSH
12592: LD_INT 118
12594: PPUSH
12595: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12599: LD_EXP 34
12603: PPUSH
12604: CALL_OW 256
12608: PUSH
12609: LD_INT 750
12611: GREATEREQUAL
12612: IFFALSE 12626
// SetLives ( Kikuchi , 700 ) ;
12614: LD_EXP 34
12618: PPUSH
12619: LD_INT 700
12621: PPUSH
12622: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12626: LD_INT 35
12628: PPUSH
12629: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12633: LD_INT 1
12635: PPUSH
12636: LD_EXP 34
12640: PPUSH
12641: CALL_OW 292
12645: PUSH
12646: LD_EXP 34
12650: PPUSH
12651: LD_INT 7
12653: PPUSH
12654: CALL_OW 296
12658: PUSH
12659: LD_INT 17
12661: LESS
12662: OR
12663: IFFALSE 12626
// DialogueOn ;
12665: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12669: LD_EXP 34
12673: PPUSH
12674: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12678: LD_EXP 34
12682: PPUSH
12683: LD_STRING D4Yb-Yam-1
12685: PPUSH
12686: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12690: LD_EXP 21
12694: PPUSH
12695: LD_STRING D4Yb-JMM-1
12697: PPUSH
12698: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12702: LD_EXP 34
12706: PPUSH
12707: LD_STRING D4Yb-Yam-2
12709: PPUSH
12710: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12714: LD_EXP 21
12718: PPUSH
12719: LD_STRING D4Yb-JMM-2
12721: PPUSH
12722: CALL_OW 88
// DialogueOff ;
12726: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12730: LD_EXP 34
12734: PPUSH
12735: LD_INT 1
12737: PPUSH
12738: CALL_OW 235
// end ; end ; end ; end ;
12742: PPOPN 2
12744: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12745: LD_EXP 6
12749: IFFALSE 13782
12751: GO 12753
12753: DISABLE
12754: LD_INT 0
12756: PPUSH
12757: PPUSH
12758: PPUSH
12759: PPUSH
// begin enable ;
12760: ENABLE
// if not seen [ 1 ] then
12761: LD_EXP 9
12765: PUSH
12766: LD_INT 1
12768: ARRAY
12769: NOT
12770: IFFALSE 12950
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12772: LD_ADDR_VAR 0 2
12776: PUSH
12777: LD_INT 22
12779: PUSH
12780: LD_INT 2
12782: PUSH
12783: EMPTY
12784: LIST
12785: LIST
12786: PUSH
12787: LD_INT 2
12789: PUSH
12790: LD_INT 25
12792: PUSH
12793: LD_INT 11
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 33
12802: PUSH
12803: LD_INT 4
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: LIST
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: PPUSH
12819: CALL_OW 69
12823: ST_TO_ADDR
// if tmp then
12824: LD_VAR 0 2
12828: IFFALSE 12950
// for i in tmp do
12830: LD_ADDR_VAR 0 1
12834: PUSH
12835: LD_VAR 0 2
12839: PUSH
12840: FOR_IN
12841: IFFALSE 12948
// if See ( 1 , i ) then
12843: LD_INT 1
12845: PPUSH
12846: LD_VAR 0 1
12850: PPUSH
12851: CALL_OW 292
12855: IFFALSE 12946
// begin seen := Replace ( seen , 1 , true ) ;
12857: LD_ADDR_EXP 9
12861: PUSH
12862: LD_EXP 9
12866: PPUSH
12867: LD_INT 1
12869: PPUSH
12870: LD_INT 1
12872: PPUSH
12873: CALL_OW 1
12877: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12878: LD_INT 1
12880: PPUSH
12881: CALL 16541 0 1
12885: IFFALSE 12946
// begin DialogueOn ;
12887: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12891: LD_VAR 0 1
12895: PPUSH
12896: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12900: LD_INT 10
12902: PPUSH
12903: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12907: LD_ADDR_VAR 0 3
12911: PUSH
12912: LD_INT 1
12914: PPUSH
12915: LD_STRING D5a-Sol2-1
12917: PPUSH
12918: CALL 16719 0 2
12922: ST_TO_ADDR
// if not un then
12923: LD_VAR 0 3
12927: NOT
12928: IFFALSE 12940
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12930: LD_INT 2
12932: PPUSH
12933: LD_STRING D5a-FSol2-1
12935: PPUSH
12936: CALL 16719 0 2
// DialogueOff ;
12940: CALL_OW 7
// break ;
12944: GO 12948
// end ; end ;
12946: GO 12840
12948: POP
12949: POP
// end ; if not seen [ 2 ] then
12950: LD_EXP 9
12954: PUSH
12955: LD_INT 2
12957: ARRAY
12958: NOT
12959: IFFALSE 13184
// begin can_kamikazed := true ;
12961: LD_ADDR_EXP 10
12965: PUSH
12966: LD_INT 1
12968: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12969: LD_ADDR_VAR 0 2
12973: PUSH
12974: LD_INT 22
12976: PUSH
12977: LD_INT 2
12979: PUSH
12980: EMPTY
12981: LIST
12982: LIST
12983: PUSH
12984: LD_INT 25
12986: PUSH
12987: LD_INT 17
12989: PUSH
12990: EMPTY
12991: LIST
12992: LIST
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: PPUSH
12998: CALL_OW 69
13002: ST_TO_ADDR
// if tmp then
13003: LD_VAR 0 2
13007: IFFALSE 13184
// for i in tmp do
13009: LD_ADDR_VAR 0 1
13013: PUSH
13014: LD_VAR 0 2
13018: PUSH
13019: FOR_IN
13020: IFFALSE 13182
// if See ( 1 , i ) then
13022: LD_INT 1
13024: PPUSH
13025: LD_VAR 0 1
13029: PPUSH
13030: CALL_OW 292
13034: IFFALSE 13180
// begin seen := Replace ( seen , 2 , true ) ;
13036: LD_ADDR_EXP 9
13040: PUSH
13041: LD_EXP 9
13045: PPUSH
13046: LD_INT 2
13048: PPUSH
13049: LD_INT 1
13051: PPUSH
13052: CALL_OW 1
13056: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13057: LD_INT 1
13059: PPUSH
13060: CALL 16541 0 1
13064: IFFALSE 13180
// begin DialogueOn ;
13066: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13070: LD_VAR 0 1
13074: PPUSH
13075: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13079: LD_INT 10
13081: PPUSH
13082: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13086: LD_ADDR_VAR 0 3
13090: PUSH
13091: LD_INT 1
13093: PPUSH
13094: LD_STRING D5b-Sol1-1
13096: PPUSH
13097: CALL 16719 0 2
13101: ST_TO_ADDR
// if not un then
13102: LD_VAR 0 3
13106: NOT
13107: IFFALSE 13125
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13109: LD_ADDR_VAR 0 3
13113: PUSH
13114: LD_INT 2
13116: PPUSH
13117: LD_STRING D5b-FSol1-1
13119: PPUSH
13120: CALL 16719 0 2
13124: ST_TO_ADDR
// if un then
13125: LD_VAR 0 3
13129: IFFALSE 13174
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13131: LD_ADDR_VAR 0 4
13135: PUSH
13136: LD_INT 1
13138: PPUSH
13139: LD_STRING D5b-Sol2-1
13141: PPUSH
13142: LD_VAR 0 3
13146: PPUSH
13147: CALL 16945 0 3
13151: ST_TO_ADDR
// if not un2 then
13152: LD_VAR 0 4
13156: NOT
13157: IFFALSE 13174
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13159: LD_INT 2
13161: PPUSH
13162: LD_STRING D5b-FSol2-1
13164: PPUSH
13165: LD_VAR 0 3
13169: PPUSH
13170: CALL 16945 0 3
// end ; DialogueOff ;
13174: CALL_OW 7
// break ;
13178: GO 13182
// end ; end ;
13180: GO 13019
13182: POP
13183: POP
// end ; if not seen [ 3 ] then
13184: LD_EXP 9
13188: PUSH
13189: LD_INT 3
13191: ARRAY
13192: NOT
13193: IFFALSE 13367
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13195: LD_ADDR_VAR 0 2
13199: PUSH
13200: LD_INT 22
13202: PUSH
13203: LD_INT 2
13205: PUSH
13206: EMPTY
13207: LIST
13208: LIST
13209: PUSH
13210: LD_INT 33
13212: PUSH
13213: LD_INT 2
13215: PUSH
13216: EMPTY
13217: LIST
13218: LIST
13219: PUSH
13220: EMPTY
13221: LIST
13222: LIST
13223: PPUSH
13224: CALL_OW 69
13228: ST_TO_ADDR
// if tmp then
13229: LD_VAR 0 2
13233: IFFALSE 13367
// for i in tmp do
13235: LD_ADDR_VAR 0 1
13239: PUSH
13240: LD_VAR 0 2
13244: PUSH
13245: FOR_IN
13246: IFFALSE 13365
// if See ( 1 , i ) then
13248: LD_INT 1
13250: PPUSH
13251: LD_VAR 0 1
13255: PPUSH
13256: CALL_OW 292
13260: IFFALSE 13363
// begin seen := Replace ( seen , 3 , true ) ;
13262: LD_ADDR_EXP 9
13266: PUSH
13267: LD_EXP 9
13271: PPUSH
13272: LD_INT 3
13274: PPUSH
13275: LD_INT 1
13277: PPUSH
13278: CALL_OW 1
13282: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13283: LD_INT 1
13285: PPUSH
13286: CALL 16541 0 1
13290: IFFALSE 13363
// begin DialogueOn ;
13292: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13296: LD_VAR 0 1
13300: PPUSH
13301: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13305: LD_INT 10
13307: PPUSH
13308: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13312: LD_ADDR_VAR 0 3
13316: PUSH
13317: LD_INT 1
13319: PPUSH
13320: LD_STRING D8-Sol1-1
13322: PPUSH
13323: CALL 16719 0 2
13327: ST_TO_ADDR
// if not un then
13328: LD_VAR 0 3
13332: NOT
13333: IFFALSE 13345
// SayRand ( sex_female , D8-FSol1-1 ) ;
13335: LD_INT 2
13337: PPUSH
13338: LD_STRING D8-FSol1-1
13340: PPUSH
13341: CALL 16719 0 2
// Say ( JMM , D8-JMM-1 ) ;
13345: LD_EXP 21
13349: PPUSH
13350: LD_STRING D8-JMM-1
13352: PPUSH
13353: CALL_OW 88
// DialogueOff ;
13357: CALL_OW 7
// break ;
13361: GO 13365
// end ; end ;
13363: GO 13245
13365: POP
13366: POP
// end ; if not seen [ 4 ] then
13367: LD_EXP 9
13371: PUSH
13372: LD_INT 4
13374: ARRAY
13375: NOT
13376: IFFALSE 13538
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13378: LD_ADDR_VAR 0 2
13382: PUSH
13383: LD_INT 22
13385: PUSH
13386: LD_INT 2
13388: PUSH
13389: EMPTY
13390: LIST
13391: LIST
13392: PUSH
13393: LD_INT 33
13395: PUSH
13396: LD_INT 5
13398: PUSH
13399: EMPTY
13400: LIST
13401: LIST
13402: PUSH
13403: EMPTY
13404: LIST
13405: LIST
13406: PPUSH
13407: CALL_OW 69
13411: ST_TO_ADDR
// if tmp then
13412: LD_VAR 0 2
13416: IFFALSE 13538
// for i in tmp do
13418: LD_ADDR_VAR 0 1
13422: PUSH
13423: LD_VAR 0 2
13427: PUSH
13428: FOR_IN
13429: IFFALSE 13536
// if See ( 1 , i ) then
13431: LD_INT 1
13433: PPUSH
13434: LD_VAR 0 1
13438: PPUSH
13439: CALL_OW 292
13443: IFFALSE 13534
// begin seen := Replace ( seen , 4 , true ) ;
13445: LD_ADDR_EXP 9
13449: PUSH
13450: LD_EXP 9
13454: PPUSH
13455: LD_INT 4
13457: PPUSH
13458: LD_INT 1
13460: PPUSH
13461: CALL_OW 1
13465: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13466: LD_INT 1
13468: PPUSH
13469: CALL 16541 0 1
13473: IFFALSE 13534
// begin DialogueOn ;
13475: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13479: LD_VAR 0 1
13483: PPUSH
13484: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13488: LD_INT 10
13490: PPUSH
13491: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13495: LD_ADDR_VAR 0 3
13499: PUSH
13500: LD_INT 1
13502: PPUSH
13503: LD_STRING D5a-Sol1-1
13505: PPUSH
13506: CALL 16719 0 2
13510: ST_TO_ADDR
// if not un then
13511: LD_VAR 0 3
13515: NOT
13516: IFFALSE 13528
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13518: LD_INT 2
13520: PPUSH
13521: LD_STRING D5a-FSol1-1
13523: PPUSH
13524: CALL 16719 0 2
// DialogueOff ;
13528: CALL_OW 7
// break ;
13532: GO 13536
// end ; end ;
13534: GO 13428
13536: POP
13537: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13538: LD_EXP 9
13542: PUSH
13543: LD_INT 5
13545: ARRAY
13546: NOT
13547: PUSH
13548: LD_EXP 9
13552: PUSH
13553: LD_INT 3
13555: ARRAY
13556: AND
13557: IFFALSE 13731
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13559: LD_ADDR_VAR 0 2
13563: PUSH
13564: LD_INT 22
13566: PUSH
13567: LD_INT 2
13569: PUSH
13570: EMPTY
13571: LIST
13572: LIST
13573: PUSH
13574: LD_INT 34
13576: PUSH
13577: LD_INT 31
13579: PUSH
13580: EMPTY
13581: LIST
13582: LIST
13583: PUSH
13584: EMPTY
13585: LIST
13586: LIST
13587: PPUSH
13588: CALL_OW 69
13592: ST_TO_ADDR
// if tmp then
13593: LD_VAR 0 2
13597: IFFALSE 13731
// for i in tmp do
13599: LD_ADDR_VAR 0 1
13603: PUSH
13604: LD_VAR 0 2
13608: PUSH
13609: FOR_IN
13610: IFFALSE 13729
// if See ( 1 , i ) then
13612: LD_INT 1
13614: PPUSH
13615: LD_VAR 0 1
13619: PPUSH
13620: CALL_OW 292
13624: IFFALSE 13727
// begin seen := Replace ( seen , 5 , true ) ;
13626: LD_ADDR_EXP 9
13630: PUSH
13631: LD_EXP 9
13635: PPUSH
13636: LD_INT 5
13638: PPUSH
13639: LD_INT 1
13641: PPUSH
13642: CALL_OW 1
13646: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13647: LD_INT 1
13649: PPUSH
13650: CALL 16541 0 1
13654: IFFALSE 13727
// begin DialogueOn ;
13656: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13660: LD_VAR 0 1
13664: PPUSH
13665: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13669: LD_INT 10
13671: PPUSH
13672: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13676: LD_ADDR_VAR 0 3
13680: PUSH
13681: LD_INT 1
13683: PPUSH
13684: LD_STRING D8a-Sol2-1
13686: PPUSH
13687: CALL 16719 0 2
13691: ST_TO_ADDR
// if not un then
13692: LD_VAR 0 3
13696: NOT
13697: IFFALSE 13709
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13699: LD_INT 2
13701: PPUSH
13702: LD_STRING D8a-FSol2-1
13704: PPUSH
13705: CALL 16719 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13709: LD_EXP 21
13713: PPUSH
13714: LD_STRING D8a-JMM-1
13716: PPUSH
13717: CALL_OW 88
// DialogueOff ;
13721: CALL_OW 7
// break ;
13725: GO 13729
// end ; end ;
13727: GO 13609
13729: POP
13730: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13731: LD_EXP 9
13735: PUSH
13736: LD_INT 1
13738: ARRAY
13739: PUSH
13740: LD_EXP 9
13744: PUSH
13745: LD_INT 2
13747: ARRAY
13748: AND
13749: PUSH
13750: LD_EXP 9
13754: PUSH
13755: LD_INT 3
13757: ARRAY
13758: AND
13759: PUSH
13760: LD_EXP 9
13764: PUSH
13765: LD_INT 4
13767: ARRAY
13768: AND
13769: PUSH
13770: LD_EXP 9
13774: PUSH
13775: LD_INT 5
13777: ARRAY
13778: AND
13779: IFFALSE 13782
// disable ;
13781: DISABLE
// end ;
13782: PPOPN 4
13784: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13785: LD_EXP 10
13789: PUSH
13790: LD_EXP 11
13794: AND
13795: IFFALSE 13993
13797: GO 13799
13799: DISABLE
13800: LD_INT 0
13802: PPUSH
// begin DialogueOn ;
13803: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13807: LD_EXP 11
13811: PPUSH
13812: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13816: LD_ADDR_VAR 0 1
13820: PUSH
13821: LD_INT 1
13823: PPUSH
13824: LD_STRING D5c-Sol1-1
13826: PPUSH
13827: CALL 16719 0 2
13831: ST_TO_ADDR
// if not un then
13832: LD_VAR 0 1
13836: NOT
13837: IFFALSE 13855
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13839: LD_ADDR_VAR 0 1
13843: PUSH
13844: LD_INT 2
13846: PPUSH
13847: LD_STRING D5c-FSol1-1
13849: PPUSH
13850: CALL 16719 0 2
13854: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13855: LD_EXP 21
13859: PPUSH
13860: LD_STRING D5c-JMM-1
13862: PPUSH
13863: CALL_OW 88
// if IsOk ( Lisa ) then
13867: LD_EXP 22
13871: PPUSH
13872: CALL_OW 302
13876: IFFALSE 13892
// Say ( Lisa , D5d-Lisa-1 ) else
13878: LD_EXP 22
13882: PPUSH
13883: LD_STRING D5d-Lisa-1
13885: PPUSH
13886: CALL_OW 88
13890: GO 13977
// if IsOk ( Cyrus ) then
13892: LD_EXP 25
13896: PPUSH
13897: CALL_OW 302
13901: IFFALSE 13917
// Say ( Cyrus , D5d-Cyrus-1 ) else
13903: LD_EXP 25
13907: PPUSH
13908: LD_STRING D5d-Cyrus-1
13910: PPUSH
13911: CALL_OW 88
13915: GO 13977
// if IsOk ( Gary ) then
13917: LD_EXP 32
13921: PPUSH
13922: CALL_OW 302
13926: IFFALSE 13942
// Say ( Gary , D5d-Gary-1 ) else
13928: LD_EXP 32
13932: PPUSH
13933: LD_STRING D5d-Gary-1
13935: PPUSH
13936: CALL_OW 88
13940: GO 13977
// if GetSex ( un ) = sex_male then
13942: LD_VAR 0 1
13946: PPUSH
13947: CALL_OW 258
13951: PUSH
13952: LD_INT 1
13954: EQUAL
13955: IFFALSE 13971
// Say ( un , D5d-Sol1-1 ) else
13957: LD_VAR 0 1
13961: PPUSH
13962: LD_STRING D5d-Sol1-1
13964: PPUSH
13965: CALL_OW 88
13969: GO 13977
// begin DialogueOff ;
13971: CALL_OW 7
// exit ;
13975: GO 13993
// end ; Say ( JMM , D5d-JMM-1 ) ;
13977: LD_EXP 21
13981: PPUSH
13982: LD_STRING D5d-JMM-1
13984: PPUSH
13985: CALL_OW 88
// DialogueOff ;
13989: CALL_OW 7
// end ;
13993: PPOPN 1
13995: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13996: LD_INT 1
13998: PPUSH
13999: LD_INT 17
14001: PPUSH
14002: CALL_OW 294
14006: PUSH
14007: LD_INT 2
14009: GREATEREQUAL
14010: IFFALSE 14142
14012: GO 14014
14014: DISABLE
14015: LD_INT 0
14017: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14018: LD_INT 10
14020: PPUSH
14021: LD_INT 5
14023: PPUSH
14024: LD_INT 1
14026: PPUSH
14027: LD_INT 10
14029: NEG
14030: PPUSH
14031: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14035: LD_INT 10
14037: PPUSH
14038: LD_INT 5
14040: PPUSH
14041: LD_INT 1
14043: PPUSH
14044: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14048: LD_INT 10
14050: PPUSH
14051: LD_INT 5
14053: PPUSH
14054: CALL_OW 86
// DialogueOn ;
14058: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14062: LD_ADDR_VAR 0 1
14066: PUSH
14067: LD_INT 1
14069: PPUSH
14070: LD_STRING D6-Sci1-1
14072: PPUSH
14073: CALL 16719 0 2
14077: ST_TO_ADDR
// if un then
14078: LD_VAR 0 1
14082: IFFALSE 14120
// begin Say ( JMM , D6-JMM-1 ) ;
14084: LD_EXP 21
14088: PPUSH
14089: LD_STRING D6-JMM-1
14091: PPUSH
14092: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14096: LD_VAR 0 1
14100: PPUSH
14101: LD_STRING D6-Sci1-2
14103: PPUSH
14104: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14108: LD_EXP 21
14112: PPUSH
14113: LD_STRING D6-JMM-2
14115: PPUSH
14116: CALL_OW 88
// end ; DialogueOff ;
14120: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14124: LD_STRING M3
14126: PPUSH
14127: CALL_OW 337
// wait ( 0 0$30 ) ;
14131: LD_INT 1050
14133: PPUSH
14134: CALL_OW 67
// AmericanReinforcements ;
14138: CALL 2326 0 0
// end ;
14142: PPOPN 1
14144: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14145: LD_OWVAR 1
14149: PUSH
14150: LD_INT 42000
14152: GREATEREQUAL
14153: PUSH
14154: LD_INT 2
14156: PPUSH
14157: LD_INT 169
14159: PPUSH
14160: LD_INT 90
14162: PPUSH
14163: LD_INT 10
14165: PPUSH
14166: CALL 54681 0 4
14170: PUSH
14171: LD_INT 4
14173: ARRAY
14174: PUSH
14175: LD_INT 0
14177: EQUAL
14178: PUSH
14179: LD_INT 45
14181: PPUSH
14182: CALL_OW 301
14186: OR
14187: PUSH
14188: LD_INT 45
14190: PPUSH
14191: CALL_OW 255
14195: PUSH
14196: LD_INT 1
14198: EQUAL
14199: OR
14200: AND
14201: PUSH
14202: LD_INT 94
14204: PPUSH
14205: CALL_OW 301
14209: NOT
14210: AND
14211: IFFALSE 15416
14213: GO 14215
14215: DISABLE
14216: LD_INT 0
14218: PPUSH
14219: PPUSH
14220: PPUSH
14221: PPUSH
14222: PPUSH
// begin uc_side := 5 ;
14223: LD_ADDR_OWVAR 20
14227: PUSH
14228: LD_INT 5
14230: ST_TO_ADDR
// uc_nation := 2 ;
14231: LD_ADDR_OWVAR 21
14235: PUSH
14236: LD_INT 2
14238: ST_TO_ADDR
// InitHc ;
14239: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14243: LD_INT 1
14245: PPUSH
14246: LD_INT 3
14248: PPUSH
14249: LD_INT 8
14251: PPUSH
14252: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14256: LD_ADDR_OWVAR 29
14260: PUSH
14261: LD_INT 12
14263: PUSH
14264: LD_INT 12
14266: PUSH
14267: EMPTY
14268: LIST
14269: LIST
14270: ST_TO_ADDR
// hc_name := Hans Fliege ;
14271: LD_ADDR_OWVAR 26
14275: PUSH
14276: LD_STRING Hans Fliege
14278: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14279: LD_ADDR_OWVAR 33
14283: PUSH
14284: LD_STRING SecondCharsGal
14286: ST_TO_ADDR
// hc_face_number := 7 ;
14287: LD_ADDR_OWVAR 34
14291: PUSH
14292: LD_INT 7
14294: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14295: LD_ADDR_EXP 46
14299: PUSH
14300: CALL_OW 44
14304: ST_TO_ADDR
// InitHc ;
14305: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14309: LD_INT 1
14311: PPUSH
14312: LD_INT 16
14314: PPUSH
14315: LD_INT 2
14317: PPUSH
14318: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14322: LD_ADDR_OWVAR 29
14326: PUSH
14327: LD_INT 12
14329: PUSH
14330: LD_INT 12
14332: PUSH
14333: EMPTY
14334: LIST
14335: LIST
14336: ST_TO_ADDR
// hc_name :=  ;
14337: LD_ADDR_OWVAR 26
14341: PUSH
14342: LD_STRING 
14344: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14345: LD_ADDR_EXP 47
14349: PUSH
14350: CALL_OW 44
14354: ST_TO_ADDR
// InitHc ;
14355: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14359: LD_INT 35
14361: PPUSH
14362: CALL_OW 67
// until not InBattle ( 1 ) ;
14366: LD_INT 1
14368: PPUSH
14369: CALL_OW 463
14373: NOT
14374: IFFALSE 14359
// wait ( 0 0$5 ) ;
14376: LD_INT 175
14378: PPUSH
14379: CALL_OW 67
// DialogueOn ;
14383: CALL_OW 6
// InGameOn ;
14387: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14391: LD_ADDR_VAR 0 1
14395: PUSH
14396: LD_INT 22
14398: PUSH
14399: LD_INT 1
14401: PUSH
14402: EMPTY
14403: LIST
14404: LIST
14405: PUSH
14406: LD_INT 2
14408: PUSH
14409: LD_INT 25
14411: PUSH
14412: LD_INT 1
14414: PUSH
14415: EMPTY
14416: LIST
14417: LIST
14418: PUSH
14419: LD_INT 25
14421: PUSH
14422: LD_INT 2
14424: PUSH
14425: EMPTY
14426: LIST
14427: LIST
14428: PUSH
14429: LD_INT 25
14431: PUSH
14432: LD_INT 3
14434: PUSH
14435: EMPTY
14436: LIST
14437: LIST
14438: PUSH
14439: LD_INT 25
14441: PUSH
14442: LD_INT 4
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: PUSH
14449: LD_INT 25
14451: PUSH
14452: LD_INT 5
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: PUSH
14459: LD_INT 25
14461: PUSH
14462: LD_INT 8
14464: PUSH
14465: EMPTY
14466: LIST
14467: LIST
14468: PUSH
14469: EMPTY
14470: LIST
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: LIST
14476: LIST
14477: PUSH
14478: EMPTY
14479: LIST
14480: LIST
14481: PPUSH
14482: CALL_OW 69
14486: PUSH
14487: LD_EXP 21
14491: PUSH
14492: LD_EXP 22
14496: PUSH
14497: LD_EXP 23
14501: PUSH
14502: LD_EXP 24
14506: PUSH
14507: LD_EXP 25
14511: PUSH
14512: LD_EXP 26
14516: PUSH
14517: LD_EXP 27
14521: PUSH
14522: LD_EXP 28
14526: PUSH
14527: LD_EXP 29
14531: PUSH
14532: LD_EXP 31
14536: PUSH
14537: LD_EXP 32
14541: PUSH
14542: LD_EXP 33
14546: PUSH
14547: LD_EXP 34
14551: PUSH
14552: EMPTY
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: DIFF
14567: PPUSH
14568: LD_INT 26
14570: PUSH
14571: LD_INT 1
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: PPUSH
14578: CALL_OW 72
14582: PUSH
14583: LD_INT 1
14585: ARRAY
14586: ST_TO_ADDR
// if Brown then
14587: LD_EXP 27
14591: IFFALSE 14603
// un := Brown ;
14593: LD_ADDR_VAR 0 1
14597: PUSH
14598: LD_EXP 27
14602: ST_TO_ADDR
// if un then
14603: LD_VAR 0 1
14607: IFFALSE 14633
// begin Say ( un , D7-Sol1-1 ) ;
14609: LD_VAR 0 1
14613: PPUSH
14614: LD_STRING D7-Sol1-1
14616: PPUSH
14617: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14621: LD_EXP 21
14625: PPUSH
14626: LD_STRING D7-JMM-1
14628: PPUSH
14629: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14633: LD_EXP 46
14637: PPUSH
14638: LD_STRING D7-Ar1-1
14640: PPUSH
14641: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14645: LD_EXP 21
14649: PPUSH
14650: LD_STRING D7-JMM-2
14652: PPUSH
14653: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14657: LD_EXP 46
14661: PPUSH
14662: LD_STRING D7-Ar1-2
14664: PPUSH
14665: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14669: LD_EXP 21
14673: PPUSH
14674: LD_STRING D7-JMM-3
14676: PPUSH
14677: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14681: LD_EXP 46
14685: PPUSH
14686: LD_STRING D7-Ar1-3
14688: PPUSH
14689: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14693: LD_EXP 21
14697: PPUSH
14698: LD_STRING D7-JMM-4
14700: PPUSH
14701: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14705: LD_EXP 46
14709: PPUSH
14710: LD_STRING D7-Ar1-4
14712: PPUSH
14713: CALL_OW 94
// InGameOff ;
14717: CALL_OW 9
// DialogueOff ;
14721: CALL_OW 7
// case Query ( QCameras ) of 1 :
14725: LD_STRING QCameras
14727: PPUSH
14728: CALL_OW 97
14732: PUSH
14733: LD_INT 1
14735: DOUBLE
14736: EQUAL
14737: IFTRUE 14741
14739: GO 14744
14741: POP
// ; 2 :
14742: GO 14758
14744: LD_INT 2
14746: DOUBLE
14747: EQUAL
14748: IFTRUE 14752
14750: GO 14757
14752: POP
// exit ; end ;
14753: GO 15416
14755: GO 14758
14757: POP
// ChangeMissionObjectives ( MCar ) ;
14758: LD_STRING MCar
14760: PPUSH
14761: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14765: LD_INT 124
14767: PPUSH
14768: LD_INT 90
14770: PPUSH
14771: LD_INT 1
14773: PPUSH
14774: LD_INT 6
14776: NEG
14777: PPUSH
14778: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14782: LD_INT 124
14784: PPUSH
14785: LD_INT 90
14787: PPUSH
14788: LD_INT 1
14790: PPUSH
14791: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14795: LD_INT 12
14797: PPUSH
14798: LD_INT 1
14800: PPUSH
14801: CALL_OW 424
// wait ( 3 ) ;
14805: LD_INT 3
14807: PPUSH
14808: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14812: LD_INT 124
14814: PPUSH
14815: LD_INT 90
14817: PPUSH
14818: CALL_OW 86
// cargo := false ;
14822: LD_ADDR_VAR 0 3
14826: PUSH
14827: LD_INT 0
14829: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14830: LD_INT 35
14832: PPUSH
14833: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14837: LD_ADDR_VAR 0 3
14841: PUSH
14842: LD_INT 12
14844: PPUSH
14845: LD_INT 32
14847: PUSH
14848: LD_INT 3
14850: PUSH
14851: EMPTY
14852: LIST
14853: LIST
14854: PUSH
14855: LD_INT 34
14857: PUSH
14858: LD_INT 32
14860: PUSH
14861: EMPTY
14862: LIST
14863: LIST
14864: PUSH
14865: LD_INT 58
14867: PUSH
14868: EMPTY
14869: LIST
14870: PUSH
14871: EMPTY
14872: LIST
14873: LIST
14874: LIST
14875: PPUSH
14876: CALL_OW 70
14880: ST_TO_ADDR
// until cargo ;
14881: LD_VAR 0 3
14885: IFFALSE 14830
// cargo := cargo [ 1 ] ;
14887: LD_ADDR_VAR 0 3
14891: PUSH
14892: LD_VAR 0 3
14896: PUSH
14897: LD_INT 1
14899: ARRAY
14900: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14901: LD_VAR 0 3
14905: PPUSH
14906: LD_INT 5
14908: PPUSH
14909: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14913: LD_INT 12
14915: PPUSH
14916: LD_INT 0
14918: PPUSH
14919: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14923: LD_EXP 46
14927: PPUSH
14928: LD_INT 11
14930: PPUSH
14931: LD_INT 0
14933: PPUSH
14934: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14938: LD_EXP 47
14942: PPUSH
14943: LD_INT 11
14945: PPUSH
14946: LD_INT 0
14948: PPUSH
14949: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14953: LD_EXP 46
14957: PUSH
14958: LD_EXP 47
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: PPUSH
14967: LD_INT 12
14969: PPUSH
14970: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14974: LD_EXP 46
14978: PPUSH
14979: LD_VAR 0 3
14983: PPUSH
14984: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14988: LD_EXP 46
14992: PUSH
14993: LD_EXP 47
14997: PUSH
14998: EMPTY
14999: LIST
15000: LIST
15001: PPUSH
15002: LD_INT 209
15004: PPUSH
15005: LD_INT 178
15007: PPUSH
15008: CALL_OW 171
// escaped := 0 ;
15012: LD_ADDR_VAR 0 5
15016: PUSH
15017: LD_INT 0
15019: ST_TO_ADDR
// while ( true ) do
15020: LD_INT 1
15022: IFFALSE 15238
// begin wait ( 0 0$1 ) ;
15024: LD_INT 35
15026: PPUSH
15027: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15031: LD_EXP 46
15035: PPUSH
15036: CALL_OW 314
15040: NOT
15041: PUSH
15042: LD_EXP 47
15046: PPUSH
15047: CALL_OW 314
15051: NOT
15052: OR
15053: IFFALSE 15079
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15055: LD_EXP 46
15059: PUSH
15060: LD_EXP 47
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: PPUSH
15069: LD_INT 209
15071: PPUSH
15072: LD_INT 178
15074: PPUSH
15075: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15079: LD_EXP 46
15083: PPUSH
15084: LD_INT 10
15086: PPUSH
15087: CALL_OW 308
15091: IFFALSE 15116
// begin RemoveUnit ( ar_mechanic ) ;
15093: LD_EXP 46
15097: PPUSH
15098: CALL_OW 64
// escaped := escaped + 1 ;
15102: LD_ADDR_VAR 0 5
15106: PUSH
15107: LD_VAR 0 5
15111: PUSH
15112: LD_INT 1
15114: PLUS
15115: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15116: LD_EXP 47
15120: PPUSH
15121: LD_INT 10
15123: PPUSH
15124: CALL_OW 308
15128: IFFALSE 15153
// begin RemoveUnit ( ar_mechanic_friend ) ;
15130: LD_EXP 47
15134: PPUSH
15135: CALL_OW 64
// escaped := escaped + 1 ;
15139: LD_ADDR_VAR 0 5
15143: PUSH
15144: LD_VAR 0 5
15148: PUSH
15149: LD_INT 1
15151: PLUS
15152: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15153: LD_VAR 0 3
15157: PPUSH
15158: LD_INT 10
15160: PPUSH
15161: CALL_OW 308
15165: IFFALSE 15176
// RemoveUnit ( cargo ) ;
15167: LD_VAR 0 3
15171: PPUSH
15172: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15176: LD_EXP 46
15180: PPUSH
15181: CALL_OW 305
15185: NOT
15186: PUSH
15187: LD_VAR 0 5
15191: PUSH
15192: LD_INT 2
15194: GREATEREQUAL
15195: AND
15196: IFFALSE 15200
// break ;
15198: GO 15238
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15200: LD_EXP 46
15204: PPUSH
15205: CALL_OW 305
15209: NOT
15210: PUSH
15211: LD_EXP 47
15215: PPUSH
15216: CALL_OW 305
15220: NOT
15221: AND
15222: PUSH
15223: LD_VAR 0 5
15227: PUSH
15228: LD_INT 2
15230: LESS
15231: AND
15232: IFFALSE 15236
// exit ;
15234: GO 15416
// end ;
15236: GO 15020
// wait ( 0 0$2 ) ;
15238: LD_INT 70
15240: PPUSH
15241: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15245: LD_EXP 46
15249: PPUSH
15250: LD_STRING D7a-Ar1-1
15252: PPUSH
15253: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15257: LD_ADDR_VAR 0 4
15261: PUSH
15262: LD_INT 129
15264: PUSH
15265: LD_INT 10
15267: PUSH
15268: EMPTY
15269: LIST
15270: LIST
15271: PUSH
15272: LD_INT 103
15274: PUSH
15275: LD_INT 6
15277: PUSH
15278: EMPTY
15279: LIST
15280: LIST
15281: PUSH
15282: LD_INT 148
15284: PUSH
15285: LD_INT 47
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PUSH
15292: LD_INT 155
15294: PUSH
15295: LD_INT 16
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: LIST
15306: LIST
15307: ST_TO_ADDR
// if Difficulty = 1 then
15308: LD_OWVAR 67
15312: PUSH
15313: LD_INT 1
15315: EQUAL
15316: IFFALSE 15353
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15318: LD_ADDR_VAR 0 4
15322: PUSH
15323: LD_VAR 0 4
15327: PUSH
15328: LD_INT 78
15330: PUSH
15331: LD_INT 7
15333: PUSH
15334: EMPTY
15335: LIST
15336: LIST
15337: PUSH
15338: LD_INT 104
15340: PUSH
15341: LD_INT 43
15343: PUSH
15344: EMPTY
15345: LIST
15346: LIST
15347: PUSH
15348: EMPTY
15349: LIST
15350: LIST
15351: ADD
15352: ST_TO_ADDR
// for i in tmp do
15353: LD_ADDR_VAR 0 2
15357: PUSH
15358: LD_VAR 0 4
15362: PUSH
15363: FOR_IN
15364: IFFALSE 15397
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15366: LD_VAR 0 2
15370: PUSH
15371: LD_INT 1
15373: ARRAY
15374: PPUSH
15375: LD_VAR 0 2
15379: PUSH
15380: LD_INT 2
15382: ARRAY
15383: PPUSH
15384: LD_INT 1
15386: PPUSH
15387: LD_INT 9
15389: NEG
15390: PPUSH
15391: CALL_OW 330
15395: GO 15363
15397: POP
15398: POP
// SetAchievement ( ACH_FRIEND ) ;
15399: LD_STRING ACH_FRIEND
15401: PPUSH
15402: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15406: LD_INT 129
15408: PPUSH
15409: LD_INT 10
15411: PPUSH
15412: CALL_OW 84
// end ;
15416: PPOPN 5
15418: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15419: LD_EXP 15
15423: PUSH
15424: LD_INT 21000
15426: MINUS
15427: PUSH
15428: LD_OWVAR 1
15432: LESSEQUAL
15433: IFFALSE 15473
15435: GO 15437
15437: DISABLE
// begin powell_warn := true ;
15438: LD_ADDR_EXP 16
15442: PUSH
15443: LD_INT 1
15445: ST_TO_ADDR
// DialogueOn ;
15446: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15450: LD_EXP 30
15454: PPUSH
15455: LD_STRING D9-Pow-1
15457: PPUSH
15458: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15462: LD_INT 10
15464: PPUSH
15465: CALL_OW 68
// DialogueOff ;
15469: CALL_OW 7
// end ;
15473: END
// every 0 0$1 trigger game_time <= tick do
15474: LD_EXP 15
15478: PUSH
15479: LD_OWVAR 1
15483: LESSEQUAL
15484: IFFALSE 15523
15486: GO 15488
15488: DISABLE
// begin DialogueOn ;
15489: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15493: LD_EXP 30
15497: PPUSH
15498: LD_STRING D9a-Pow-1
15500: PPUSH
15501: CALL_OW 94
// dwait ( 0 0$2 ) ;
15505: LD_INT 70
15507: PPUSH
15508: CALL_OW 68
// DialogueOff ;
15512: CALL_OW 7
// YouLost ( Command ) ;
15516: LD_STRING Command
15518: PPUSH
15519: CALL_OW 104
// end ;
15523: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15524: LD_INT 22
15526: PUSH
15527: LD_INT 2
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: PUSH
15534: LD_INT 30
15536: PUSH
15537: LD_INT 1
15539: PUSH
15540: EMPTY
15541: LIST
15542: LIST
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: PPUSH
15548: CALL_OW 69
15552: PUSH
15553: LD_INT 0
15555: EQUAL
15556: PUSH
15557: LD_EXP 21
15561: PPUSH
15562: CALL_OW 302
15566: AND
15567: IFFALSE 15615
15569: GO 15571
15571: DISABLE
// begin case Query ( QEndMission ) of 1 :
15572: LD_STRING QEndMission
15574: PPUSH
15575: CALL_OW 97
15579: PUSH
15580: LD_INT 1
15582: DOUBLE
15583: EQUAL
15584: IFTRUE 15588
15586: GO 15599
15588: POP
// end_the_mission_allowed := true ; 2 :
15589: LD_ADDR_OWVAR 57
15593: PUSH
15594: LD_INT 1
15596: ST_TO_ADDR
15597: GO 15615
15599: LD_INT 2
15601: DOUBLE
15602: EQUAL
15603: IFTRUE 15607
15605: GO 15614
15607: POP
// EndMission ; end ;
15608: CALL 15623 0 0
15612: GO 15615
15614: POP
// end ;
15615: END
// on EndTheMissionRaised ( p ) do begin EndMission ;
15616: CALL 15623 0 0
// end ;
15620: PPOPN 1
15622: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15623: LD_INT 0
15625: PPUSH
15626: PPUSH
15627: PPUSH
15628: PPUSH
15629: PPUSH
// m1 := false ;
15630: LD_ADDR_VAR 0 3
15634: PUSH
15635: LD_INT 0
15637: ST_TO_ADDR
// m2 := false ;
15638: LD_ADDR_VAR 0 4
15642: PUSH
15643: LD_INT 0
15645: ST_TO_ADDR
// m3 := false ;
15646: LD_ADDR_VAR 0 5
15650: PUSH
15651: LD_INT 0
15653: ST_TO_ADDR
// if not am_veh_consturcted then
15654: LD_EXP 20
15658: NOT
15659: IFFALSE 15668
// SetAchievement ( ACH_ARABTECH ) ;
15661: LD_STRING ACH_ARABTECH
15663: PPUSH
15664: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15668: LD_OWVAR 1
15672: PUSH
15673: LD_INT 252000
15675: PUSH
15676: LD_INT 210000
15678: PUSH
15679: LD_INT 199500
15681: PUSH
15682: LD_INT 193200
15684: PUSH
15685: EMPTY
15686: LIST
15687: LIST
15688: LIST
15689: LIST
15690: PUSH
15691: LD_OWVAR 67
15695: ARRAY
15696: LESS
15697: IFFALSE 15719
// begin m3 := true ;
15699: LD_ADDR_VAR 0 5
15703: PUSH
15704: LD_INT 1
15706: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15707: LD_STRING Time1
15709: PPUSH
15710: LD_INT 1
15712: PPUSH
15713: CALL_OW 101
// end else
15717: GO 15750
// if not powell_warn then
15719: LD_EXP 16
15723: NOT
15724: IFFALSE 15739
// AddMedal ( Time1 , - 1 ) else
15726: LD_STRING Time1
15728: PPUSH
15729: LD_INT 1
15731: NEG
15732: PPUSH
15733: CALL_OW 101
15737: GO 15750
// AddMedal ( Time1 , - 2 ) ;
15739: LD_STRING Time1
15741: PPUSH
15742: LD_INT 2
15744: NEG
15745: PPUSH
15746: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15750: LD_EXP 17
15754: PUSH
15755: LD_INT 5
15757: PUSH
15758: LD_INT 4
15760: PUSH
15761: LD_INT 3
15763: PUSH
15764: LD_INT 3
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: LIST
15771: LIST
15772: PUSH
15773: LD_OWVAR 67
15777: ARRAY
15778: GREATEREQUAL
15779: IFFALSE 15794
// AddMedal ( Destroy , - 2 ) else
15781: LD_STRING Destroy
15783: PPUSH
15784: LD_INT 2
15786: NEG
15787: PPUSH
15788: CALL_OW 101
15792: GO 15927
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15794: LD_INT 22
15796: PUSH
15797: LD_INT 2
15799: PUSH
15800: EMPTY
15801: LIST
15802: LIST
15803: PUSH
15804: LD_INT 21
15806: PUSH
15807: LD_INT 3
15809: PUSH
15810: EMPTY
15811: LIST
15812: LIST
15813: PUSH
15814: LD_INT 50
15816: PUSH
15817: EMPTY
15818: LIST
15819: PUSH
15820: EMPTY
15821: LIST
15822: LIST
15823: LIST
15824: PPUSH
15825: CALL_OW 69
15829: PUSH
15830: LD_INT 25
15832: GREATEREQUAL
15833: IFFALSE 15848
// AddMedal ( Destroy , - 1 ) else
15835: LD_STRING Destroy
15837: PPUSH
15838: LD_INT 1
15840: NEG
15841: PPUSH
15842: CALL_OW 101
15846: GO 15927
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15848: LD_INT 22
15850: PUSH
15851: LD_INT 2
15853: PUSH
15854: EMPTY
15855: LIST
15856: LIST
15857: PUSH
15858: LD_INT 21
15860: PUSH
15861: LD_INT 3
15863: PUSH
15864: EMPTY
15865: LIST
15866: LIST
15867: PUSH
15868: LD_INT 50
15870: PUSH
15871: EMPTY
15872: LIST
15873: PUSH
15874: EMPTY
15875: LIST
15876: LIST
15877: LIST
15878: PPUSH
15879: CALL_OW 69
15883: PUSH
15884: LD_INT 15
15886: GREATEREQUAL
15887: IFFALSE 15909
// begin m1 := true ;
15889: LD_ADDR_VAR 0 3
15893: PUSH
15894: LD_INT 1
15896: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15897: LD_STRING Destroy
15899: PPUSH
15900: LD_INT 1
15902: PPUSH
15903: CALL_OW 101
// end else
15907: GO 15927
// begin m1 := true ;
15909: LD_ADDR_VAR 0 3
15913: PUSH
15914: LD_INT 1
15916: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15917: LD_STRING Destroy
15919: PPUSH
15920: LD_INT 2
15922: PPUSH
15923: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15927: LD_EXP 13
15931: PPUSH
15932: LD_STRING 11_artifact_captured
15934: PPUSH
15935: CALL_OW 39
// if artifact_get then
15939: LD_EXP 13
15943: IFFALSE 15965
// begin m2 := true ;
15945: LD_ADDR_VAR 0 4
15949: PUSH
15950: LD_INT 1
15952: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15953: LD_STRING Artefact
15955: PPUSH
15956: LD_INT 1
15958: PPUSH
15959: CALL_OW 101
// end else
15963: GO 15976
// AddMedal ( Artefact , - 1 ) ;
15965: LD_STRING Artefact
15967: PPUSH
15968: LD_INT 1
15970: NEG
15971: PPUSH
15972: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
15976: LD_VAR 0 3
15980: PUSH
15981: LD_VAR 0 4
15985: AND
15986: PUSH
15987: LD_VAR 0 5
15991: AND
15992: PUSH
15993: LD_OWVAR 67
15997: PUSH
15998: LD_INT 3
16000: GREATEREQUAL
16001: AND
16002: IFFALSE 16014
// SetAchievementEX ( ACH_AMER , 11 ) ;
16004: LD_STRING ACH_AMER
16006: PPUSH
16007: LD_INT 11
16009: PPUSH
16010: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16014: LD_VAR 0 3
16018: PUSH
16019: LD_VAR 0 4
16023: AND
16024: PUSH
16025: LD_VAR 0 5
16029: AND
16030: PUSH
16031: LD_EXP 17
16035: PUSH
16036: LD_INT 0
16038: EQUAL
16039: AND
16040: IFFALSE 16056
// begin wait ( 3 ) ;
16042: LD_INT 3
16044: PPUSH
16045: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16049: LD_STRING ACH_GENERAL
16051: PPUSH
16052: CALL_OW 543
// end ; if tick <= 100 100$00 then
16056: LD_OWVAR 1
16060: PUSH
16061: LD_INT 210000
16063: LESSEQUAL
16064: IFFALSE 16080
// begin wait ( 3 ) ;
16066: LD_INT 3
16068: PPUSH
16069: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16073: LD_STRING ACH_ASPEED_11
16075: PPUSH
16076: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16080: LD_STRING MAIN
16082: PPUSH
16083: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16087: LD_ADDR_EXP 19
16091: PUSH
16092: LD_EXP 19
16096: PPUSH
16097: LD_INT 51
16099: PUSH
16100: EMPTY
16101: LIST
16102: PPUSH
16103: CALL_OW 72
16107: ST_TO_ADDR
// tmp := JMM ^ selected ;
16108: LD_ADDR_VAR 0 2
16112: PUSH
16113: LD_EXP 21
16117: PUSH
16118: LD_EXP 19
16122: ADD
16123: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16124: LD_VAR 0 2
16128: PPUSH
16129: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16133: LD_VAR 0 2
16137: PUSH
16138: LD_EXP 21
16142: PUSH
16143: LD_EXP 22
16147: PUSH
16148: LD_EXP 23
16152: PUSH
16153: LD_EXP 24
16157: PUSH
16158: LD_EXP 25
16162: PUSH
16163: LD_EXP 26
16167: PUSH
16168: LD_EXP 27
16172: PUSH
16173: LD_EXP 28
16177: PUSH
16178: LD_EXP 29
16182: PUSH
16183: LD_EXP 31
16187: PUSH
16188: LD_EXP 32
16192: PUSH
16193: LD_EXP 33
16197: PUSH
16198: LD_EXP 34
16202: PUSH
16203: EMPTY
16204: LIST
16205: LIST
16206: LIST
16207: LIST
16208: LIST
16209: LIST
16210: LIST
16211: LIST
16212: LIST
16213: LIST
16214: LIST
16215: LIST
16216: LIST
16217: DIFF
16218: PPUSH
16219: LD_STRING 11c_others
16221: PPUSH
16222: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16226: LD_EXP 21
16230: PPUSH
16231: LD_EXP 3
16235: PUSH
16236: LD_STRING JMM
16238: STR
16239: PPUSH
16240: CALL_OW 38
// if Lisa then
16244: LD_EXP 22
16248: IFFALSE 16268
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16250: LD_EXP 22
16254: PPUSH
16255: LD_EXP 3
16259: PUSH
16260: LD_STRING Lisa
16262: STR
16263: PPUSH
16264: CALL_OW 38
// if Donaldson then
16268: LD_EXP 23
16272: IFFALSE 16292
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16274: LD_EXP 23
16278: PPUSH
16279: LD_EXP 3
16283: PUSH
16284: LD_STRING Donaldson
16286: STR
16287: PPUSH
16288: CALL_OW 38
// if Bobby then
16292: LD_EXP 24
16296: IFFALSE 16316
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16298: LD_EXP 24
16302: PPUSH
16303: LD_EXP 3
16307: PUSH
16308: LD_STRING Bobby
16310: STR
16311: PPUSH
16312: CALL_OW 38
// if Cyrus then
16316: LD_EXP 25
16320: IFFALSE 16340
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16322: LD_EXP 25
16326: PPUSH
16327: LD_EXP 3
16331: PUSH
16332: LD_STRING Cyrus
16334: STR
16335: PPUSH
16336: CALL_OW 38
// if Denis then
16340: LD_EXP 26
16344: IFFALSE 16364
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16346: LD_EXP 26
16350: PPUSH
16351: LD_EXP 3
16355: PUSH
16356: LD_STRING Denis
16358: STR
16359: PPUSH
16360: CALL_OW 38
// if Brown then
16364: LD_EXP 27
16368: IFFALSE 16388
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16370: LD_EXP 27
16374: PPUSH
16375: LD_EXP 3
16379: PUSH
16380: LD_STRING Brown
16382: STR
16383: PPUSH
16384: CALL_OW 38
// if Gladstone then
16388: LD_EXP 28
16392: IFFALSE 16412
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16394: LD_EXP 28
16398: PPUSH
16399: LD_EXP 3
16403: PUSH
16404: LD_STRING Gladstone
16406: STR
16407: PPUSH
16408: CALL_OW 38
// if Houten then
16412: LD_EXP 29
16416: IFFALSE 16436
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16418: LD_EXP 29
16422: PPUSH
16423: LD_EXP 3
16427: PUSH
16428: LD_STRING Houten
16430: STR
16431: PPUSH
16432: CALL_OW 38
// if Cornel then
16436: LD_EXP 31
16440: IFFALSE 16460
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16442: LD_EXP 31
16446: PPUSH
16447: LD_EXP 3
16451: PUSH
16452: LD_STRING Cornell
16454: STR
16455: PPUSH
16456: CALL_OW 38
// if Gary then
16460: LD_EXP 32
16464: IFFALSE 16484
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16466: LD_EXP 32
16470: PPUSH
16471: LD_EXP 3
16475: PUSH
16476: LD_STRING Gary
16478: STR
16479: PPUSH
16480: CALL_OW 38
// if Frank then
16484: LD_EXP 33
16488: IFFALSE 16508
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16490: LD_EXP 33
16494: PPUSH
16495: LD_EXP 3
16499: PUSH
16500: LD_STRING Frank
16502: STR
16503: PPUSH
16504: CALL_OW 38
// if Kikuchi then
16508: LD_EXP 34
16512: IFFALSE 16532
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16514: LD_EXP 34
16518: PPUSH
16519: LD_EXP 3
16523: PUSH
16524: LD_STRING Kikuchi
16526: STR
16527: PPUSH
16528: CALL_OW 38
// YouWin ;
16532: CALL_OW 103
// end ;
16536: LD_VAR 0 1
16540: RET
// export function CanSayRand ( side ) ; begin
16541: LD_INT 0
16543: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16544: LD_ADDR_VAR 0 2
16548: PUSH
16549: LD_INT 52
16551: PUSH
16552: EMPTY
16553: LIST
16554: PUSH
16555: LD_INT 22
16557: PUSH
16558: LD_VAR 0 1
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: PUSH
16567: LD_INT 2
16569: PUSH
16570: LD_INT 25
16572: PUSH
16573: LD_INT 1
16575: PUSH
16576: EMPTY
16577: LIST
16578: LIST
16579: PUSH
16580: LD_INT 25
16582: PUSH
16583: LD_INT 2
16585: PUSH
16586: EMPTY
16587: LIST
16588: LIST
16589: PUSH
16590: LD_INT 25
16592: PUSH
16593: LD_INT 3
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PUSH
16600: LD_INT 25
16602: PUSH
16603: LD_INT 4
16605: PUSH
16606: EMPTY
16607: LIST
16608: LIST
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: LIST
16614: LIST
16615: LIST
16616: PUSH
16617: EMPTY
16618: LIST
16619: LIST
16620: LIST
16621: PPUSH
16622: CALL_OW 69
16626: PUSH
16627: LD_EXP 21
16631: PUSH
16632: LD_EXP 33
16636: PUSH
16637: LD_EXP 22
16641: PUSH
16642: LD_EXP 23
16646: PUSH
16647: LD_EXP 24
16651: PUSH
16652: LD_EXP 25
16656: PUSH
16657: LD_EXP 26
16661: PUSH
16662: LD_EXP 27
16666: PUSH
16667: LD_EXP 28
16671: PUSH
16672: LD_EXP 29
16676: PUSH
16677: LD_EXP 30
16681: PUSH
16682: LD_EXP 31
16686: PUSH
16687: LD_EXP 32
16691: PUSH
16692: LD_EXP 34
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: LIST
16701: LIST
16702: LIST
16703: LIST
16704: LIST
16705: LIST
16706: LIST
16707: LIST
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: DIFF
16713: ST_TO_ADDR
// end ;
16714: LD_VAR 0 2
16718: RET
// export function SayRand ( sex , dial ) ; begin
16719: LD_INT 0
16721: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16722: LD_ADDR_VAR 0 3
16726: PUSH
16727: LD_INT 52
16729: PUSH
16730: EMPTY
16731: LIST
16732: PUSH
16733: LD_INT 22
16735: PUSH
16736: LD_INT 1
16738: PUSH
16739: EMPTY
16740: LIST
16741: LIST
16742: PUSH
16743: LD_INT 26
16745: PUSH
16746: LD_VAR 0 1
16750: PUSH
16751: EMPTY
16752: LIST
16753: LIST
16754: PUSH
16755: LD_INT 2
16757: PUSH
16758: LD_INT 25
16760: PUSH
16761: LD_INT 1
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: PUSH
16768: LD_INT 25
16770: PUSH
16771: LD_INT 2
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: PUSH
16778: LD_INT 25
16780: PUSH
16781: LD_INT 3
16783: PUSH
16784: EMPTY
16785: LIST
16786: LIST
16787: PUSH
16788: LD_INT 25
16790: PUSH
16791: LD_INT 4
16793: PUSH
16794: EMPTY
16795: LIST
16796: LIST
16797: PUSH
16798: EMPTY
16799: LIST
16800: LIST
16801: LIST
16802: LIST
16803: LIST
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: LIST
16809: LIST
16810: PPUSH
16811: CALL_OW 69
16815: PUSH
16816: LD_EXP 21
16820: PUSH
16821: LD_EXP 33
16825: PUSH
16826: LD_EXP 22
16830: PUSH
16831: LD_EXP 23
16835: PUSH
16836: LD_EXP 24
16840: PUSH
16841: LD_EXP 25
16845: PUSH
16846: LD_EXP 26
16850: PUSH
16851: LD_EXP 27
16855: PUSH
16856: LD_EXP 28
16860: PUSH
16861: LD_EXP 29
16865: PUSH
16866: LD_EXP 30
16870: PUSH
16871: LD_EXP 31
16875: PUSH
16876: LD_EXP 32
16880: PUSH
16881: LD_EXP 34
16885: PUSH
16886: EMPTY
16887: LIST
16888: LIST
16889: LIST
16890: LIST
16891: LIST
16892: LIST
16893: LIST
16894: LIST
16895: LIST
16896: LIST
16897: LIST
16898: LIST
16899: LIST
16900: LIST
16901: DIFF
16902: ST_TO_ADDR
// if not result then
16903: LD_VAR 0 3
16907: NOT
16908: IFFALSE 16912
// exit ;
16910: GO 16940
// result := result [ 1 ] ;
16912: LD_ADDR_VAR 0 3
16916: PUSH
16917: LD_VAR 0 3
16921: PUSH
16922: LD_INT 1
16924: ARRAY
16925: ST_TO_ADDR
// Say ( result , dial ) ;
16926: LD_VAR 0 3
16930: PPUSH
16931: LD_VAR 0 2
16935: PPUSH
16936: CALL_OW 88
// end ;
16940: LD_VAR 0 3
16944: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16945: LD_INT 0
16947: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16948: LD_ADDR_VAR 0 4
16952: PUSH
16953: LD_INT 22
16955: PUSH
16956: LD_INT 1
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: PUSH
16963: LD_INT 26
16965: PUSH
16966: LD_VAR 0 1
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: LD_INT 2
16977: PUSH
16978: LD_INT 25
16980: PUSH
16981: LD_INT 1
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PUSH
16988: LD_INT 25
16990: PUSH
16991: LD_INT 2
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: PUSH
16998: LD_INT 25
17000: PUSH
17001: LD_INT 3
17003: PUSH
17004: EMPTY
17005: LIST
17006: LIST
17007: PUSH
17008: LD_INT 25
17010: PUSH
17011: LD_INT 4
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: PUSH
17018: EMPTY
17019: LIST
17020: LIST
17021: LIST
17022: LIST
17023: LIST
17024: PUSH
17025: EMPTY
17026: LIST
17027: LIST
17028: LIST
17029: PPUSH
17030: CALL_OW 69
17034: PUSH
17035: LD_EXP 21
17039: PUSH
17040: LD_EXP 33
17044: PUSH
17045: LD_EXP 22
17049: PUSH
17050: LD_EXP 23
17054: PUSH
17055: LD_EXP 24
17059: PUSH
17060: LD_EXP 25
17064: PUSH
17065: LD_EXP 26
17069: PUSH
17070: LD_EXP 27
17074: PUSH
17075: LD_EXP 28
17079: PUSH
17080: LD_EXP 29
17084: PUSH
17085: LD_EXP 30
17089: PUSH
17090: LD_EXP 31
17094: PUSH
17095: LD_EXP 32
17099: PUSH
17100: LD_EXP 34
17104: PUSH
17105: EMPTY
17106: LIST
17107: LIST
17108: LIST
17109: LIST
17110: LIST
17111: LIST
17112: LIST
17113: LIST
17114: LIST
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: LIST
17120: PUSH
17121: LD_VAR 0 3
17125: ADD
17126: DIFF
17127: ST_TO_ADDR
// if not result then
17128: LD_VAR 0 4
17132: NOT
17133: IFFALSE 17137
// exit ;
17135: GO 17165
// result := result [ 1 ] ;
17137: LD_ADDR_VAR 0 4
17141: PUSH
17142: LD_VAR 0 4
17146: PUSH
17147: LD_INT 1
17149: ARRAY
17150: ST_TO_ADDR
// Say ( result , dial ) ;
17151: LD_VAR 0 4
17155: PPUSH
17156: LD_VAR 0 2
17160: PPUSH
17161: CALL_OW 88
// end ; end_of_file
17165: LD_VAR 0 4
17169: RET
// export function CustomEvent ( event ) ; begin
17170: LD_INT 0
17172: PPUSH
// end ;
17173: LD_VAR 0 2
17177: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17178: LD_VAR 0 1
17182: PPUSH
17183: CALL_OW 255
17187: PUSH
17188: LD_INT 1
17190: EQUAL
17191: IFFALSE 17201
// artifact_get := true ;
17193: LD_ADDR_EXP 13
17197: PUSH
17198: LD_INT 1
17200: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17201: LD_VAR 0 1
17205: PPUSH
17206: CALL_OW 255
17210: PUSH
17211: LD_INT 2
17213: EQUAL
17214: IFFALSE 17232
// begin artifact_get := false ;
17216: LD_ADDR_EXP 13
17220: PUSH
17221: LD_INT 0
17223: ST_TO_ADDR
// artifact_stolen := true ;
17224: LD_ADDR_EXP 12
17228: PUSH
17229: LD_INT 1
17231: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17232: LD_ADDR_EXP 14
17236: PUSH
17237: LD_INT 1
17239: ST_TO_ADDR
// end ;
17240: PPOPN 2
17242: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17243: LD_ADDR_EXP 14
17247: PUSH
17248: LD_INT 0
17250: ST_TO_ADDR
// end ;
17251: PPOPN 2
17253: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17254: LD_VAR 0 1
17258: PPUSH
17259: CALL 105868 0 1
// if un = JMM then
17263: LD_VAR 0 1
17267: PUSH
17268: LD_EXP 21
17272: EQUAL
17273: IFFALSE 17284
// begin YouLost ( JMM ) ;
17275: LD_STRING JMM
17277: PPUSH
17278: CALL_OW 104
// exit ;
17282: GO 17416
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17284: LD_VAR 0 1
17288: PUSH
17289: LD_INT 22
17291: PUSH
17292: LD_INT 1
17294: PUSH
17295: EMPTY
17296: LIST
17297: LIST
17298: PUSH
17299: LD_INT 21
17301: PUSH
17302: LD_INT 1
17304: PUSH
17305: EMPTY
17306: LIST
17307: LIST
17308: PUSH
17309: LD_INT 2
17311: PUSH
17312: LD_INT 25
17314: PUSH
17315: LD_INT 1
17317: PUSH
17318: EMPTY
17319: LIST
17320: LIST
17321: PUSH
17322: LD_INT 25
17324: PUSH
17325: LD_INT 2
17327: PUSH
17328: EMPTY
17329: LIST
17330: LIST
17331: PUSH
17332: LD_INT 25
17334: PUSH
17335: LD_INT 3
17337: PUSH
17338: EMPTY
17339: LIST
17340: LIST
17341: PUSH
17342: LD_INT 25
17344: PUSH
17345: LD_INT 4
17347: PUSH
17348: EMPTY
17349: LIST
17350: LIST
17351: PUSH
17352: LD_INT 25
17354: PUSH
17355: LD_INT 5
17357: PUSH
17358: EMPTY
17359: LIST
17360: LIST
17361: PUSH
17362: LD_INT 25
17364: PUSH
17365: LD_INT 8
17367: PUSH
17368: EMPTY
17369: LIST
17370: LIST
17371: PUSH
17372: EMPTY
17373: LIST
17374: LIST
17375: LIST
17376: LIST
17377: LIST
17378: LIST
17379: LIST
17380: PUSH
17381: EMPTY
17382: LIST
17383: LIST
17384: LIST
17385: PPUSH
17386: CALL_OW 69
17390: IN
17391: IFFALSE 17407
// loses_counter := loses_counter + 1 ;
17393: LD_ADDR_EXP 17
17397: PUSH
17398: LD_EXP 17
17402: PUSH
17403: LD_INT 1
17405: PLUS
17406: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17407: LD_VAR 0 1
17411: PPUSH
17412: CALL 45664 0 1
// end ;
17416: PPOPN 1
17418: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17419: LD_VAR 0 1
17423: PPUSH
17424: LD_VAR 0 2
17428: PPUSH
17429: CALL 47996 0 2
// end ;
17433: PPOPN 2
17435: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17436: LD_VAR 0 1
17440: PPUSH
17441: CALL 47305 0 1
// end ;
17445: PPOPN 1
17447: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17448: LD_VAR 0 1
17452: PPUSH
17453: LD_VAR 0 2
17457: PPUSH
17458: LD_VAR 0 3
17462: PPUSH
17463: LD_VAR 0 4
17467: PPUSH
17468: LD_VAR 0 5
17472: PPUSH
17473: CALL 44980 0 5
// end ;
17477: PPOPN 5
17479: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17480: LD_VAR 0 1
17484: PPUSH
17485: LD_VAR 0 2
17489: PPUSH
17490: CALL 105988 0 2
// if GetNation ( vehicle ) = nation_american then
17494: LD_VAR 0 1
17498: PPUSH
17499: CALL_OW 248
17503: PUSH
17504: LD_INT 1
17506: EQUAL
17507: IFFALSE 17517
// am_veh_consturcted := true ;
17509: LD_ADDR_EXP 20
17513: PUSH
17514: LD_INT 1
17516: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17517: LD_VAR 0 1
17521: PPUSH
17522: LD_VAR 0 2
17526: PPUSH
17527: CALL 44571 0 2
// end ;
17531: PPOPN 2
17533: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17534: LD_VAR 0 1
17538: PPUSH
17539: CALL_OW 247
17543: PUSH
17544: LD_INT 2
17546: EQUAL
17547: IFFALSE 17551
// exit ;
17549: GO 17568
// if not kamikazed then
17551: LD_EXP 11
17555: NOT
17556: IFFALSE 17568
// kamikazed := unit ;
17558: LD_ADDR_EXP 11
17562: PUSH
17563: LD_VAR 0 1
17567: ST_TO_ADDR
// end ;
17568: PPOPN 1
17570: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17571: LD_INT 0
17573: PPUSH
17574: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17575: LD_VAR 0 1
17579: PPUSH
17580: LD_VAR 0 2
17584: PPUSH
17585: LD_VAR 0 3
17589: PPUSH
17590: LD_VAR 0 4
17594: PPUSH
17595: CALL 44409 0 4
// end ;
17599: PPOPN 6
17601: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17602: LD_VAR 0 1
17606: PPUSH
17607: LD_VAR 0 2
17611: PPUSH
17612: LD_VAR 0 3
17616: PPUSH
17617: CALL 44184 0 3
// end ;
17621: PPOPN 3
17623: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17624: LD_VAR 0 1
17628: PPUSH
17629: LD_VAR 0 2
17633: PPUSH
17634: CALL 45360 0 2
// end ;
17638: PPOPN 2
17640: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17641: LD_VAR 0 1
17645: PPUSH
17646: LD_VAR 0 2
17650: PPUSH
17651: CALL 43878 0 2
// end ;
17655: PPOPN 2
17657: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17658: LD_VAR 0 1
17662: PPUSH
17663: LD_VAR 0 2
17667: PPUSH
17668: CALL 44069 0 2
// end ;
17672: PPOPN 2
17674: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17675: LD_VAR 0 1
17679: PPUSH
17680: CALL 47064 0 1
// end ;
17684: PPOPN 1
17686: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17687: LD_VAR 0 1
17691: PPUSH
17692: LD_VAR 0 2
17696: PPUSH
17697: CALL 48291 0 2
// end ;
17701: PPOPN 2
17703: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17704: LD_VAR 0 1
17708: PPUSH
17709: LD_VAR 0 2
17713: PPUSH
17714: LD_VAR 0 3
17718: PPUSH
17719: LD_VAR 0 4
17723: PPUSH
17724: CALL 48507 0 4
// end ;
17728: PPOPN 4
17730: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17731: LD_VAR 0 1
17735: PPUSH
17736: CALL 105972 0 1
// end ; end_of_file
17740: PPOPN 1
17742: END
// every 0 0$1 trigger game do
17743: LD_EXP 2
17747: IFFALSE 17777
17749: GO 17751
17751: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17752: LD_INT 7
17754: PUSH
17755: LD_INT 6
17757: PUSH
17758: LD_INT 4
17760: PUSH
17761: LD_INT 6
17763: PUSH
17764: EMPTY
17765: LIST
17766: LIST
17767: LIST
17768: LIST
17769: PPUSH
17770: LD_INT 1750
17772: PPUSH
17773: CALL 17778 0 2
17777: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17778: LD_INT 0
17780: PPUSH
17781: PPUSH
17782: PPUSH
// if not areas then
17783: LD_VAR 0 1
17787: NOT
17788: IFFALSE 17792
// exit ;
17790: GO 17922
// repeat wait ( time ) ;
17792: LD_VAR 0 2
17796: PPUSH
17797: CALL_OW 67
// for i in areas do
17801: LD_ADDR_VAR 0 4
17805: PUSH
17806: LD_VAR 0 1
17810: PUSH
17811: FOR_IN
17812: IFFALSE 17881
// begin p := rand ( 1 , 90 ) ;
17814: LD_ADDR_VAR 0 5
17818: PUSH
17819: LD_INT 1
17821: PPUSH
17822: LD_INT 90
17824: PPUSH
17825: CALL_OW 12
17829: ST_TO_ADDR
// if Prob ( p ) then
17830: LD_VAR 0 5
17834: PPUSH
17835: CALL_OW 13
17839: IFFALSE 17879
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17841: LD_INT 2
17843: PPUSH
17844: LD_INT 5
17846: PPUSH
17847: CALL_OW 12
17851: PPUSH
17852: LD_VAR 0 4
17856: PPUSH
17857: LD_INT 1
17859: PPUSH
17860: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17864: LD_INT 735
17866: PPUSH
17867: LD_INT 1295
17869: PPUSH
17870: CALL_OW 12
17874: PPUSH
17875: CALL_OW 67
// end ; end ;
17879: GO 17811
17881: POP
17882: POP
// time := time + 0 0$3 ;
17883: LD_ADDR_VAR 0 2
17887: PUSH
17888: LD_VAR 0 2
17892: PUSH
17893: LD_INT 105
17895: PLUS
17896: ST_TO_ADDR
// if time > 6 6$00 then
17897: LD_VAR 0 2
17901: PUSH
17902: LD_INT 12600
17904: GREATER
17905: IFFALSE 17915
// time := 0 0$40 ;
17907: LD_ADDR_VAR 0 2
17911: PUSH
17912: LD_INT 1400
17914: ST_TO_ADDR
// until not game ;
17915: LD_EXP 2
17919: NOT
17920: IFFALSE 17792
// end ;
17922: LD_VAR 0 3
17926: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
17927: LD_OWVAR 1
17931: PUSH
17932: LD_INT 84000
17934: PUSH
17935: LD_INT 73500
17937: PUSH
17938: LD_INT 63000
17940: PUSH
17941: LD_INT 52500
17943: PUSH
17944: EMPTY
17945: LIST
17946: LIST
17947: LIST
17948: LIST
17949: PUSH
17950: LD_OWVAR 67
17954: ARRAY
17955: LESS
17956: IFFALSE 17983
17958: GO 17960
17960: DISABLE
// begin enable ;
17961: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17962: LD_INT 1
17964: PPUSH
17965: LD_INT 5
17967: PPUSH
17968: CALL_OW 12
17972: PPUSH
17973: LD_INT 7
17975: PPUSH
17976: LD_INT 1
17978: PPUSH
17979: CALL_OW 55
// end ; end_of_file
17983: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17984: LD_INT 0
17986: PPUSH
17987: PPUSH
// skirmish := false ;
17988: LD_ADDR_EXP 48
17992: PUSH
17993: LD_INT 0
17995: ST_TO_ADDR
// debug_mc := false ;
17996: LD_ADDR_EXP 49
18000: PUSH
18001: LD_INT 0
18003: ST_TO_ADDR
// mc_bases := [ ] ;
18004: LD_ADDR_EXP 50
18008: PUSH
18009: EMPTY
18010: ST_TO_ADDR
// mc_sides := [ ] ;
18011: LD_ADDR_EXP 76
18015: PUSH
18016: EMPTY
18017: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18018: LD_ADDR_EXP 51
18022: PUSH
18023: EMPTY
18024: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18025: LD_ADDR_EXP 52
18029: PUSH
18030: EMPTY
18031: ST_TO_ADDR
// mc_need_heal := [ ] ;
18032: LD_ADDR_EXP 53
18036: PUSH
18037: EMPTY
18038: ST_TO_ADDR
// mc_healers := [ ] ;
18039: LD_ADDR_EXP 54
18043: PUSH
18044: EMPTY
18045: ST_TO_ADDR
// mc_build_list := [ ] ;
18046: LD_ADDR_EXP 55
18050: PUSH
18051: EMPTY
18052: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18053: LD_ADDR_EXP 82
18057: PUSH
18058: EMPTY
18059: ST_TO_ADDR
// mc_builders := [ ] ;
18060: LD_ADDR_EXP 56
18064: PUSH
18065: EMPTY
18066: ST_TO_ADDR
// mc_construct_list := [ ] ;
18067: LD_ADDR_EXP 57
18071: PUSH
18072: EMPTY
18073: ST_TO_ADDR
// mc_turret_list := [ ] ;
18074: LD_ADDR_EXP 58
18078: PUSH
18079: EMPTY
18080: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18081: LD_ADDR_EXP 59
18085: PUSH
18086: EMPTY
18087: ST_TO_ADDR
// mc_miners := [ ] ;
18088: LD_ADDR_EXP 64
18092: PUSH
18093: EMPTY
18094: ST_TO_ADDR
// mc_mines := [ ] ;
18095: LD_ADDR_EXP 63
18099: PUSH
18100: EMPTY
18101: ST_TO_ADDR
// mc_minefields := [ ] ;
18102: LD_ADDR_EXP 65
18106: PUSH
18107: EMPTY
18108: ST_TO_ADDR
// mc_crates := [ ] ;
18109: LD_ADDR_EXP 66
18113: PUSH
18114: EMPTY
18115: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18116: LD_ADDR_EXP 67
18120: PUSH
18121: EMPTY
18122: ST_TO_ADDR
// mc_crates_area := [ ] ;
18123: LD_ADDR_EXP 68
18127: PUSH
18128: EMPTY
18129: ST_TO_ADDR
// mc_vehicles := [ ] ;
18130: LD_ADDR_EXP 69
18134: PUSH
18135: EMPTY
18136: ST_TO_ADDR
// mc_attack := [ ] ;
18137: LD_ADDR_EXP 70
18141: PUSH
18142: EMPTY
18143: ST_TO_ADDR
// mc_produce := [ ] ;
18144: LD_ADDR_EXP 71
18148: PUSH
18149: EMPTY
18150: ST_TO_ADDR
// mc_defender := [ ] ;
18151: LD_ADDR_EXP 72
18155: PUSH
18156: EMPTY
18157: ST_TO_ADDR
// mc_parking := [ ] ;
18158: LD_ADDR_EXP 74
18162: PUSH
18163: EMPTY
18164: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18165: LD_ADDR_EXP 60
18169: PUSH
18170: EMPTY
18171: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18172: LD_ADDR_EXP 62
18176: PUSH
18177: EMPTY
18178: ST_TO_ADDR
// mc_scan := [ ] ;
18179: LD_ADDR_EXP 73
18183: PUSH
18184: EMPTY
18185: ST_TO_ADDR
// mc_scan_area := [ ] ;
18186: LD_ADDR_EXP 75
18190: PUSH
18191: EMPTY
18192: ST_TO_ADDR
// mc_tech := [ ] ;
18193: LD_ADDR_EXP 77
18197: PUSH
18198: EMPTY
18199: ST_TO_ADDR
// mc_class := [ ] ;
18200: LD_ADDR_EXP 91
18204: PUSH
18205: EMPTY
18206: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18207: LD_ADDR_EXP 92
18211: PUSH
18212: EMPTY
18213: ST_TO_ADDR
// mc_is_defending := [ ] ;
18214: LD_ADDR_EXP 93
18218: PUSH
18219: EMPTY
18220: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18221: LD_ADDR_EXP 84
18225: PUSH
18226: EMPTY
18227: ST_TO_ADDR
// end ;
18228: LD_VAR 0 1
18232: RET
// export function MC_Kill ( base ) ; begin
18233: LD_INT 0
18235: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18236: LD_ADDR_EXP 50
18240: PUSH
18241: LD_EXP 50
18245: PPUSH
18246: LD_VAR 0 1
18250: PPUSH
18251: EMPTY
18252: PPUSH
18253: CALL_OW 1
18257: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18258: LD_ADDR_EXP 51
18262: PUSH
18263: LD_EXP 51
18267: PPUSH
18268: LD_VAR 0 1
18272: PPUSH
18273: EMPTY
18274: PPUSH
18275: CALL_OW 1
18279: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18280: LD_ADDR_EXP 52
18284: PUSH
18285: LD_EXP 52
18289: PPUSH
18290: LD_VAR 0 1
18294: PPUSH
18295: EMPTY
18296: PPUSH
18297: CALL_OW 1
18301: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18302: LD_ADDR_EXP 53
18306: PUSH
18307: LD_EXP 53
18311: PPUSH
18312: LD_VAR 0 1
18316: PPUSH
18317: EMPTY
18318: PPUSH
18319: CALL_OW 1
18323: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18324: LD_ADDR_EXP 54
18328: PUSH
18329: LD_EXP 54
18333: PPUSH
18334: LD_VAR 0 1
18338: PPUSH
18339: EMPTY
18340: PPUSH
18341: CALL_OW 1
18345: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18346: LD_ADDR_EXP 55
18350: PUSH
18351: LD_EXP 55
18355: PPUSH
18356: LD_VAR 0 1
18360: PPUSH
18361: EMPTY
18362: PPUSH
18363: CALL_OW 1
18367: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18368: LD_ADDR_EXP 56
18372: PUSH
18373: LD_EXP 56
18377: PPUSH
18378: LD_VAR 0 1
18382: PPUSH
18383: EMPTY
18384: PPUSH
18385: CALL_OW 1
18389: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18390: LD_ADDR_EXP 57
18394: PUSH
18395: LD_EXP 57
18399: PPUSH
18400: LD_VAR 0 1
18404: PPUSH
18405: EMPTY
18406: PPUSH
18407: CALL_OW 1
18411: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18412: LD_ADDR_EXP 58
18416: PUSH
18417: LD_EXP 58
18421: PPUSH
18422: LD_VAR 0 1
18426: PPUSH
18427: EMPTY
18428: PPUSH
18429: CALL_OW 1
18433: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18434: LD_ADDR_EXP 59
18438: PUSH
18439: LD_EXP 59
18443: PPUSH
18444: LD_VAR 0 1
18448: PPUSH
18449: EMPTY
18450: PPUSH
18451: CALL_OW 1
18455: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18456: LD_ADDR_EXP 60
18460: PUSH
18461: LD_EXP 60
18465: PPUSH
18466: LD_VAR 0 1
18470: PPUSH
18471: EMPTY
18472: PPUSH
18473: CALL_OW 1
18477: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18478: LD_ADDR_EXP 61
18482: PUSH
18483: LD_EXP 61
18487: PPUSH
18488: LD_VAR 0 1
18492: PPUSH
18493: LD_INT 0
18495: PPUSH
18496: CALL_OW 1
18500: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18501: LD_ADDR_EXP 62
18505: PUSH
18506: LD_EXP 62
18510: PPUSH
18511: LD_VAR 0 1
18515: PPUSH
18516: EMPTY
18517: PPUSH
18518: CALL_OW 1
18522: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18523: LD_ADDR_EXP 63
18527: PUSH
18528: LD_EXP 63
18532: PPUSH
18533: LD_VAR 0 1
18537: PPUSH
18538: EMPTY
18539: PPUSH
18540: CALL_OW 1
18544: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18545: LD_ADDR_EXP 64
18549: PUSH
18550: LD_EXP 64
18554: PPUSH
18555: LD_VAR 0 1
18559: PPUSH
18560: EMPTY
18561: PPUSH
18562: CALL_OW 1
18566: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18567: LD_ADDR_EXP 65
18571: PUSH
18572: LD_EXP 65
18576: PPUSH
18577: LD_VAR 0 1
18581: PPUSH
18582: EMPTY
18583: PPUSH
18584: CALL_OW 1
18588: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18589: LD_ADDR_EXP 66
18593: PUSH
18594: LD_EXP 66
18598: PPUSH
18599: LD_VAR 0 1
18603: PPUSH
18604: EMPTY
18605: PPUSH
18606: CALL_OW 1
18610: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18611: LD_ADDR_EXP 67
18615: PUSH
18616: LD_EXP 67
18620: PPUSH
18621: LD_VAR 0 1
18625: PPUSH
18626: EMPTY
18627: PPUSH
18628: CALL_OW 1
18632: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18633: LD_ADDR_EXP 68
18637: PUSH
18638: LD_EXP 68
18642: PPUSH
18643: LD_VAR 0 1
18647: PPUSH
18648: EMPTY
18649: PPUSH
18650: CALL_OW 1
18654: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18655: LD_ADDR_EXP 69
18659: PUSH
18660: LD_EXP 69
18664: PPUSH
18665: LD_VAR 0 1
18669: PPUSH
18670: EMPTY
18671: PPUSH
18672: CALL_OW 1
18676: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18677: LD_ADDR_EXP 70
18681: PUSH
18682: LD_EXP 70
18686: PPUSH
18687: LD_VAR 0 1
18691: PPUSH
18692: EMPTY
18693: PPUSH
18694: CALL_OW 1
18698: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18699: LD_ADDR_EXP 71
18703: PUSH
18704: LD_EXP 71
18708: PPUSH
18709: LD_VAR 0 1
18713: PPUSH
18714: EMPTY
18715: PPUSH
18716: CALL_OW 1
18720: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18721: LD_ADDR_EXP 72
18725: PUSH
18726: LD_EXP 72
18730: PPUSH
18731: LD_VAR 0 1
18735: PPUSH
18736: EMPTY
18737: PPUSH
18738: CALL_OW 1
18742: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18743: LD_ADDR_EXP 73
18747: PUSH
18748: LD_EXP 73
18752: PPUSH
18753: LD_VAR 0 1
18757: PPUSH
18758: EMPTY
18759: PPUSH
18760: CALL_OW 1
18764: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18765: LD_ADDR_EXP 74
18769: PUSH
18770: LD_EXP 74
18774: PPUSH
18775: LD_VAR 0 1
18779: PPUSH
18780: EMPTY
18781: PPUSH
18782: CALL_OW 1
18786: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18787: LD_ADDR_EXP 75
18791: PUSH
18792: LD_EXP 75
18796: PPUSH
18797: LD_VAR 0 1
18801: PPUSH
18802: EMPTY
18803: PPUSH
18804: CALL_OW 1
18808: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18809: LD_ADDR_EXP 77
18813: PUSH
18814: LD_EXP 77
18818: PPUSH
18819: LD_VAR 0 1
18823: PPUSH
18824: EMPTY
18825: PPUSH
18826: CALL_OW 1
18830: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18831: LD_ADDR_EXP 79
18835: PUSH
18836: LD_EXP 79
18840: PPUSH
18841: LD_VAR 0 1
18845: PPUSH
18846: EMPTY
18847: PPUSH
18848: CALL_OW 1
18852: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18853: LD_ADDR_EXP 80
18857: PUSH
18858: LD_EXP 80
18862: PPUSH
18863: LD_VAR 0 1
18867: PPUSH
18868: EMPTY
18869: PPUSH
18870: CALL_OW 1
18874: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18875: LD_ADDR_EXP 81
18879: PUSH
18880: LD_EXP 81
18884: PPUSH
18885: LD_VAR 0 1
18889: PPUSH
18890: EMPTY
18891: PPUSH
18892: CALL_OW 1
18896: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18897: LD_ADDR_EXP 82
18901: PUSH
18902: LD_EXP 82
18906: PPUSH
18907: LD_VAR 0 1
18911: PPUSH
18912: EMPTY
18913: PPUSH
18914: CALL_OW 1
18918: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18919: LD_ADDR_EXP 83
18923: PUSH
18924: LD_EXP 83
18928: PPUSH
18929: LD_VAR 0 1
18933: PPUSH
18934: EMPTY
18935: PPUSH
18936: CALL_OW 1
18940: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18941: LD_ADDR_EXP 84
18945: PUSH
18946: LD_EXP 84
18950: PPUSH
18951: LD_VAR 0 1
18955: PPUSH
18956: EMPTY
18957: PPUSH
18958: CALL_OW 1
18962: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18963: LD_ADDR_EXP 85
18967: PUSH
18968: LD_EXP 85
18972: PPUSH
18973: LD_VAR 0 1
18977: PPUSH
18978: EMPTY
18979: PPUSH
18980: CALL_OW 1
18984: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18985: LD_ADDR_EXP 86
18989: PUSH
18990: LD_EXP 86
18994: PPUSH
18995: LD_VAR 0 1
18999: PPUSH
19000: EMPTY
19001: PPUSH
19002: CALL_OW 1
19006: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19007: LD_ADDR_EXP 87
19011: PUSH
19012: LD_EXP 87
19016: PPUSH
19017: LD_VAR 0 1
19021: PPUSH
19022: EMPTY
19023: PPUSH
19024: CALL_OW 1
19028: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19029: LD_ADDR_EXP 88
19033: PUSH
19034: LD_EXP 88
19038: PPUSH
19039: LD_VAR 0 1
19043: PPUSH
19044: EMPTY
19045: PPUSH
19046: CALL_OW 1
19050: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19051: LD_ADDR_EXP 89
19055: PUSH
19056: LD_EXP 89
19060: PPUSH
19061: LD_VAR 0 1
19065: PPUSH
19066: EMPTY
19067: PPUSH
19068: CALL_OW 1
19072: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19073: LD_ADDR_EXP 90
19077: PUSH
19078: LD_EXP 90
19082: PPUSH
19083: LD_VAR 0 1
19087: PPUSH
19088: EMPTY
19089: PPUSH
19090: CALL_OW 1
19094: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19095: LD_ADDR_EXP 91
19099: PUSH
19100: LD_EXP 91
19104: PPUSH
19105: LD_VAR 0 1
19109: PPUSH
19110: EMPTY
19111: PPUSH
19112: CALL_OW 1
19116: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19117: LD_ADDR_EXP 92
19121: PUSH
19122: LD_EXP 92
19126: PPUSH
19127: LD_VAR 0 1
19131: PPUSH
19132: LD_INT 0
19134: PPUSH
19135: CALL_OW 1
19139: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19140: LD_ADDR_EXP 93
19144: PUSH
19145: LD_EXP 93
19149: PPUSH
19150: LD_VAR 0 1
19154: PPUSH
19155: LD_INT 0
19157: PPUSH
19158: CALL_OW 1
19162: ST_TO_ADDR
// end ;
19163: LD_VAR 0 2
19167: RET
// export function MC_Add ( side , units ) ; var base ; begin
19168: LD_INT 0
19170: PPUSH
19171: PPUSH
// base := mc_bases + 1 ;
19172: LD_ADDR_VAR 0 4
19176: PUSH
19177: LD_EXP 50
19181: PUSH
19182: LD_INT 1
19184: PLUS
19185: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19186: LD_ADDR_EXP 76
19190: PUSH
19191: LD_EXP 76
19195: PPUSH
19196: LD_VAR 0 4
19200: PPUSH
19201: LD_VAR 0 1
19205: PPUSH
19206: CALL_OW 1
19210: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19211: LD_ADDR_EXP 50
19215: PUSH
19216: LD_EXP 50
19220: PPUSH
19221: LD_VAR 0 4
19225: PPUSH
19226: LD_VAR 0 2
19230: PPUSH
19231: CALL_OW 1
19235: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19236: LD_ADDR_EXP 51
19240: PUSH
19241: LD_EXP 51
19245: PPUSH
19246: LD_VAR 0 4
19250: PPUSH
19251: EMPTY
19252: PPUSH
19253: CALL_OW 1
19257: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19258: LD_ADDR_EXP 52
19262: PUSH
19263: LD_EXP 52
19267: PPUSH
19268: LD_VAR 0 4
19272: PPUSH
19273: EMPTY
19274: PPUSH
19275: CALL_OW 1
19279: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19280: LD_ADDR_EXP 53
19284: PUSH
19285: LD_EXP 53
19289: PPUSH
19290: LD_VAR 0 4
19294: PPUSH
19295: EMPTY
19296: PPUSH
19297: CALL_OW 1
19301: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19302: LD_ADDR_EXP 54
19306: PUSH
19307: LD_EXP 54
19311: PPUSH
19312: LD_VAR 0 4
19316: PPUSH
19317: EMPTY
19318: PPUSH
19319: CALL_OW 1
19323: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19324: LD_ADDR_EXP 55
19328: PUSH
19329: LD_EXP 55
19333: PPUSH
19334: LD_VAR 0 4
19338: PPUSH
19339: EMPTY
19340: PPUSH
19341: CALL_OW 1
19345: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19346: LD_ADDR_EXP 56
19350: PUSH
19351: LD_EXP 56
19355: PPUSH
19356: LD_VAR 0 4
19360: PPUSH
19361: EMPTY
19362: PPUSH
19363: CALL_OW 1
19367: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19368: LD_ADDR_EXP 57
19372: PUSH
19373: LD_EXP 57
19377: PPUSH
19378: LD_VAR 0 4
19382: PPUSH
19383: EMPTY
19384: PPUSH
19385: CALL_OW 1
19389: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19390: LD_ADDR_EXP 58
19394: PUSH
19395: LD_EXP 58
19399: PPUSH
19400: LD_VAR 0 4
19404: PPUSH
19405: EMPTY
19406: PPUSH
19407: CALL_OW 1
19411: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19412: LD_ADDR_EXP 59
19416: PUSH
19417: LD_EXP 59
19421: PPUSH
19422: LD_VAR 0 4
19426: PPUSH
19427: EMPTY
19428: PPUSH
19429: CALL_OW 1
19433: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19434: LD_ADDR_EXP 60
19438: PUSH
19439: LD_EXP 60
19443: PPUSH
19444: LD_VAR 0 4
19448: PPUSH
19449: EMPTY
19450: PPUSH
19451: CALL_OW 1
19455: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19456: LD_ADDR_EXP 61
19460: PUSH
19461: LD_EXP 61
19465: PPUSH
19466: LD_VAR 0 4
19470: PPUSH
19471: LD_INT 0
19473: PPUSH
19474: CALL_OW 1
19478: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19479: LD_ADDR_EXP 62
19483: PUSH
19484: LD_EXP 62
19488: PPUSH
19489: LD_VAR 0 4
19493: PPUSH
19494: EMPTY
19495: PPUSH
19496: CALL_OW 1
19500: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19501: LD_ADDR_EXP 63
19505: PUSH
19506: LD_EXP 63
19510: PPUSH
19511: LD_VAR 0 4
19515: PPUSH
19516: EMPTY
19517: PPUSH
19518: CALL_OW 1
19522: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19523: LD_ADDR_EXP 64
19527: PUSH
19528: LD_EXP 64
19532: PPUSH
19533: LD_VAR 0 4
19537: PPUSH
19538: EMPTY
19539: PPUSH
19540: CALL_OW 1
19544: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19545: LD_ADDR_EXP 65
19549: PUSH
19550: LD_EXP 65
19554: PPUSH
19555: LD_VAR 0 4
19559: PPUSH
19560: EMPTY
19561: PPUSH
19562: CALL_OW 1
19566: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19567: LD_ADDR_EXP 66
19571: PUSH
19572: LD_EXP 66
19576: PPUSH
19577: LD_VAR 0 4
19581: PPUSH
19582: EMPTY
19583: PPUSH
19584: CALL_OW 1
19588: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19589: LD_ADDR_EXP 67
19593: PUSH
19594: LD_EXP 67
19598: PPUSH
19599: LD_VAR 0 4
19603: PPUSH
19604: EMPTY
19605: PPUSH
19606: CALL_OW 1
19610: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19611: LD_ADDR_EXP 68
19615: PUSH
19616: LD_EXP 68
19620: PPUSH
19621: LD_VAR 0 4
19625: PPUSH
19626: EMPTY
19627: PPUSH
19628: CALL_OW 1
19632: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19633: LD_ADDR_EXP 69
19637: PUSH
19638: LD_EXP 69
19642: PPUSH
19643: LD_VAR 0 4
19647: PPUSH
19648: EMPTY
19649: PPUSH
19650: CALL_OW 1
19654: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19655: LD_ADDR_EXP 70
19659: PUSH
19660: LD_EXP 70
19664: PPUSH
19665: LD_VAR 0 4
19669: PPUSH
19670: EMPTY
19671: PPUSH
19672: CALL_OW 1
19676: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19677: LD_ADDR_EXP 71
19681: PUSH
19682: LD_EXP 71
19686: PPUSH
19687: LD_VAR 0 4
19691: PPUSH
19692: EMPTY
19693: PPUSH
19694: CALL_OW 1
19698: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19699: LD_ADDR_EXP 72
19703: PUSH
19704: LD_EXP 72
19708: PPUSH
19709: LD_VAR 0 4
19713: PPUSH
19714: EMPTY
19715: PPUSH
19716: CALL_OW 1
19720: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19721: LD_ADDR_EXP 73
19725: PUSH
19726: LD_EXP 73
19730: PPUSH
19731: LD_VAR 0 4
19735: PPUSH
19736: EMPTY
19737: PPUSH
19738: CALL_OW 1
19742: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19743: LD_ADDR_EXP 74
19747: PUSH
19748: LD_EXP 74
19752: PPUSH
19753: LD_VAR 0 4
19757: PPUSH
19758: EMPTY
19759: PPUSH
19760: CALL_OW 1
19764: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19765: LD_ADDR_EXP 75
19769: PUSH
19770: LD_EXP 75
19774: PPUSH
19775: LD_VAR 0 4
19779: PPUSH
19780: EMPTY
19781: PPUSH
19782: CALL_OW 1
19786: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19787: LD_ADDR_EXP 77
19791: PUSH
19792: LD_EXP 77
19796: PPUSH
19797: LD_VAR 0 4
19801: PPUSH
19802: EMPTY
19803: PPUSH
19804: CALL_OW 1
19808: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19809: LD_ADDR_EXP 79
19813: PUSH
19814: LD_EXP 79
19818: PPUSH
19819: LD_VAR 0 4
19823: PPUSH
19824: EMPTY
19825: PPUSH
19826: CALL_OW 1
19830: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19831: LD_ADDR_EXP 80
19835: PUSH
19836: LD_EXP 80
19840: PPUSH
19841: LD_VAR 0 4
19845: PPUSH
19846: EMPTY
19847: PPUSH
19848: CALL_OW 1
19852: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19853: LD_ADDR_EXP 81
19857: PUSH
19858: LD_EXP 81
19862: PPUSH
19863: LD_VAR 0 4
19867: PPUSH
19868: EMPTY
19869: PPUSH
19870: CALL_OW 1
19874: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19875: LD_ADDR_EXP 82
19879: PUSH
19880: LD_EXP 82
19884: PPUSH
19885: LD_VAR 0 4
19889: PPUSH
19890: EMPTY
19891: PPUSH
19892: CALL_OW 1
19896: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19897: LD_ADDR_EXP 83
19901: PUSH
19902: LD_EXP 83
19906: PPUSH
19907: LD_VAR 0 4
19911: PPUSH
19912: EMPTY
19913: PPUSH
19914: CALL_OW 1
19918: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19919: LD_ADDR_EXP 84
19923: PUSH
19924: LD_EXP 84
19928: PPUSH
19929: LD_VAR 0 4
19933: PPUSH
19934: EMPTY
19935: PPUSH
19936: CALL_OW 1
19940: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19941: LD_ADDR_EXP 85
19945: PUSH
19946: LD_EXP 85
19950: PPUSH
19951: LD_VAR 0 4
19955: PPUSH
19956: EMPTY
19957: PPUSH
19958: CALL_OW 1
19962: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19963: LD_ADDR_EXP 86
19967: PUSH
19968: LD_EXP 86
19972: PPUSH
19973: LD_VAR 0 4
19977: PPUSH
19978: EMPTY
19979: PPUSH
19980: CALL_OW 1
19984: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19985: LD_ADDR_EXP 87
19989: PUSH
19990: LD_EXP 87
19994: PPUSH
19995: LD_VAR 0 4
19999: PPUSH
20000: EMPTY
20001: PPUSH
20002: CALL_OW 1
20006: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20007: LD_ADDR_EXP 88
20011: PUSH
20012: LD_EXP 88
20016: PPUSH
20017: LD_VAR 0 4
20021: PPUSH
20022: EMPTY
20023: PPUSH
20024: CALL_OW 1
20028: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20029: LD_ADDR_EXP 89
20033: PUSH
20034: LD_EXP 89
20038: PPUSH
20039: LD_VAR 0 4
20043: PPUSH
20044: EMPTY
20045: PPUSH
20046: CALL_OW 1
20050: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20051: LD_ADDR_EXP 90
20055: PUSH
20056: LD_EXP 90
20060: PPUSH
20061: LD_VAR 0 4
20065: PPUSH
20066: EMPTY
20067: PPUSH
20068: CALL_OW 1
20072: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20073: LD_ADDR_EXP 91
20077: PUSH
20078: LD_EXP 91
20082: PPUSH
20083: LD_VAR 0 4
20087: PPUSH
20088: EMPTY
20089: PPUSH
20090: CALL_OW 1
20094: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20095: LD_ADDR_EXP 92
20099: PUSH
20100: LD_EXP 92
20104: PPUSH
20105: LD_VAR 0 4
20109: PPUSH
20110: LD_INT 0
20112: PPUSH
20113: CALL_OW 1
20117: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20118: LD_ADDR_EXP 93
20122: PUSH
20123: LD_EXP 93
20127: PPUSH
20128: LD_VAR 0 4
20132: PPUSH
20133: LD_INT 0
20135: PPUSH
20136: CALL_OW 1
20140: ST_TO_ADDR
// result := base ;
20141: LD_ADDR_VAR 0 3
20145: PUSH
20146: LD_VAR 0 4
20150: ST_TO_ADDR
// end ;
20151: LD_VAR 0 3
20155: RET
// export function MC_Start ( ) ; var i ; begin
20156: LD_INT 0
20158: PPUSH
20159: PPUSH
// for i = 1 to mc_bases do
20160: LD_ADDR_VAR 0 2
20164: PUSH
20165: DOUBLE
20166: LD_INT 1
20168: DEC
20169: ST_TO_ADDR
20170: LD_EXP 50
20174: PUSH
20175: FOR_TO
20176: IFFALSE 21276
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20178: LD_ADDR_EXP 50
20182: PUSH
20183: LD_EXP 50
20187: PPUSH
20188: LD_VAR 0 2
20192: PPUSH
20193: LD_EXP 50
20197: PUSH
20198: LD_VAR 0 2
20202: ARRAY
20203: PUSH
20204: LD_INT 0
20206: DIFF
20207: PPUSH
20208: CALL_OW 1
20212: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20213: LD_ADDR_EXP 51
20217: PUSH
20218: LD_EXP 51
20222: PPUSH
20223: LD_VAR 0 2
20227: PPUSH
20228: EMPTY
20229: PPUSH
20230: CALL_OW 1
20234: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20235: LD_ADDR_EXP 52
20239: PUSH
20240: LD_EXP 52
20244: PPUSH
20245: LD_VAR 0 2
20249: PPUSH
20250: EMPTY
20251: PPUSH
20252: CALL_OW 1
20256: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20257: LD_ADDR_EXP 53
20261: PUSH
20262: LD_EXP 53
20266: PPUSH
20267: LD_VAR 0 2
20271: PPUSH
20272: EMPTY
20273: PPUSH
20274: CALL_OW 1
20278: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20279: LD_ADDR_EXP 54
20283: PUSH
20284: LD_EXP 54
20288: PPUSH
20289: LD_VAR 0 2
20293: PPUSH
20294: EMPTY
20295: PUSH
20296: EMPTY
20297: PUSH
20298: EMPTY
20299: LIST
20300: LIST
20301: PPUSH
20302: CALL_OW 1
20306: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20307: LD_ADDR_EXP 55
20311: PUSH
20312: LD_EXP 55
20316: PPUSH
20317: LD_VAR 0 2
20321: PPUSH
20322: EMPTY
20323: PPUSH
20324: CALL_OW 1
20328: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20329: LD_ADDR_EXP 82
20333: PUSH
20334: LD_EXP 82
20338: PPUSH
20339: LD_VAR 0 2
20343: PPUSH
20344: EMPTY
20345: PPUSH
20346: CALL_OW 1
20350: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20351: LD_ADDR_EXP 56
20355: PUSH
20356: LD_EXP 56
20360: PPUSH
20361: LD_VAR 0 2
20365: PPUSH
20366: EMPTY
20367: PPUSH
20368: CALL_OW 1
20372: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20373: LD_ADDR_EXP 57
20377: PUSH
20378: LD_EXP 57
20382: PPUSH
20383: LD_VAR 0 2
20387: PPUSH
20388: EMPTY
20389: PPUSH
20390: CALL_OW 1
20394: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20395: LD_ADDR_EXP 58
20399: PUSH
20400: LD_EXP 58
20404: PPUSH
20405: LD_VAR 0 2
20409: PPUSH
20410: LD_EXP 50
20414: PUSH
20415: LD_VAR 0 2
20419: ARRAY
20420: PPUSH
20421: LD_INT 2
20423: PUSH
20424: LD_INT 30
20426: PUSH
20427: LD_INT 32
20429: PUSH
20430: EMPTY
20431: LIST
20432: LIST
20433: PUSH
20434: LD_INT 30
20436: PUSH
20437: LD_INT 33
20439: PUSH
20440: EMPTY
20441: LIST
20442: LIST
20443: PUSH
20444: EMPTY
20445: LIST
20446: LIST
20447: LIST
20448: PPUSH
20449: CALL_OW 72
20453: PPUSH
20454: CALL_OW 1
20458: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20459: LD_ADDR_EXP 59
20463: PUSH
20464: LD_EXP 59
20468: PPUSH
20469: LD_VAR 0 2
20473: PPUSH
20474: LD_EXP 50
20478: PUSH
20479: LD_VAR 0 2
20483: ARRAY
20484: PPUSH
20485: LD_INT 2
20487: PUSH
20488: LD_INT 30
20490: PUSH
20491: LD_INT 32
20493: PUSH
20494: EMPTY
20495: LIST
20496: LIST
20497: PUSH
20498: LD_INT 30
20500: PUSH
20501: LD_INT 31
20503: PUSH
20504: EMPTY
20505: LIST
20506: LIST
20507: PUSH
20508: EMPTY
20509: LIST
20510: LIST
20511: LIST
20512: PUSH
20513: LD_INT 58
20515: PUSH
20516: EMPTY
20517: LIST
20518: PUSH
20519: EMPTY
20520: LIST
20521: LIST
20522: PPUSH
20523: CALL_OW 72
20527: PPUSH
20528: CALL_OW 1
20532: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20533: LD_ADDR_EXP 60
20537: PUSH
20538: LD_EXP 60
20542: PPUSH
20543: LD_VAR 0 2
20547: PPUSH
20548: EMPTY
20549: PPUSH
20550: CALL_OW 1
20554: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20555: LD_ADDR_EXP 64
20559: PUSH
20560: LD_EXP 64
20564: PPUSH
20565: LD_VAR 0 2
20569: PPUSH
20570: EMPTY
20571: PPUSH
20572: CALL_OW 1
20576: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20577: LD_ADDR_EXP 63
20581: PUSH
20582: LD_EXP 63
20586: PPUSH
20587: LD_VAR 0 2
20591: PPUSH
20592: EMPTY
20593: PPUSH
20594: CALL_OW 1
20598: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20599: LD_ADDR_EXP 65
20603: PUSH
20604: LD_EXP 65
20608: PPUSH
20609: LD_VAR 0 2
20613: PPUSH
20614: EMPTY
20615: PPUSH
20616: CALL_OW 1
20620: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20621: LD_ADDR_EXP 66
20625: PUSH
20626: LD_EXP 66
20630: PPUSH
20631: LD_VAR 0 2
20635: PPUSH
20636: EMPTY
20637: PPUSH
20638: CALL_OW 1
20642: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20643: LD_ADDR_EXP 67
20647: PUSH
20648: LD_EXP 67
20652: PPUSH
20653: LD_VAR 0 2
20657: PPUSH
20658: EMPTY
20659: PPUSH
20660: CALL_OW 1
20664: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20665: LD_ADDR_EXP 68
20669: PUSH
20670: LD_EXP 68
20674: PPUSH
20675: LD_VAR 0 2
20679: PPUSH
20680: EMPTY
20681: PPUSH
20682: CALL_OW 1
20686: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20687: LD_ADDR_EXP 69
20691: PUSH
20692: LD_EXP 69
20696: PPUSH
20697: LD_VAR 0 2
20701: PPUSH
20702: EMPTY
20703: PPUSH
20704: CALL_OW 1
20708: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20709: LD_ADDR_EXP 70
20713: PUSH
20714: LD_EXP 70
20718: PPUSH
20719: LD_VAR 0 2
20723: PPUSH
20724: EMPTY
20725: PPUSH
20726: CALL_OW 1
20730: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20731: LD_ADDR_EXP 71
20735: PUSH
20736: LD_EXP 71
20740: PPUSH
20741: LD_VAR 0 2
20745: PPUSH
20746: EMPTY
20747: PPUSH
20748: CALL_OW 1
20752: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20753: LD_ADDR_EXP 72
20757: PUSH
20758: LD_EXP 72
20762: PPUSH
20763: LD_VAR 0 2
20767: PPUSH
20768: EMPTY
20769: PPUSH
20770: CALL_OW 1
20774: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20775: LD_ADDR_EXP 61
20779: PUSH
20780: LD_EXP 61
20784: PPUSH
20785: LD_VAR 0 2
20789: PPUSH
20790: LD_INT 0
20792: PPUSH
20793: CALL_OW 1
20797: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20798: LD_ADDR_EXP 74
20802: PUSH
20803: LD_EXP 74
20807: PPUSH
20808: LD_VAR 0 2
20812: PPUSH
20813: LD_INT 0
20815: PPUSH
20816: CALL_OW 1
20820: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20821: LD_ADDR_EXP 62
20825: PUSH
20826: LD_EXP 62
20830: PPUSH
20831: LD_VAR 0 2
20835: PPUSH
20836: EMPTY
20837: PPUSH
20838: CALL_OW 1
20842: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20843: LD_ADDR_EXP 73
20847: PUSH
20848: LD_EXP 73
20852: PPUSH
20853: LD_VAR 0 2
20857: PPUSH
20858: LD_INT 0
20860: PPUSH
20861: CALL_OW 1
20865: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20866: LD_ADDR_EXP 75
20870: PUSH
20871: LD_EXP 75
20875: PPUSH
20876: LD_VAR 0 2
20880: PPUSH
20881: EMPTY
20882: PPUSH
20883: CALL_OW 1
20887: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20888: LD_ADDR_EXP 78
20892: PUSH
20893: LD_EXP 78
20897: PPUSH
20898: LD_VAR 0 2
20902: PPUSH
20903: LD_INT 0
20905: PPUSH
20906: CALL_OW 1
20910: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20911: LD_ADDR_EXP 79
20915: PUSH
20916: LD_EXP 79
20920: PPUSH
20921: LD_VAR 0 2
20925: PPUSH
20926: EMPTY
20927: PPUSH
20928: CALL_OW 1
20932: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20933: LD_ADDR_EXP 80
20937: PUSH
20938: LD_EXP 80
20942: PPUSH
20943: LD_VAR 0 2
20947: PPUSH
20948: EMPTY
20949: PPUSH
20950: CALL_OW 1
20954: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20955: LD_ADDR_EXP 81
20959: PUSH
20960: LD_EXP 81
20964: PPUSH
20965: LD_VAR 0 2
20969: PPUSH
20970: EMPTY
20971: PPUSH
20972: CALL_OW 1
20976: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20977: LD_ADDR_EXP 83
20981: PUSH
20982: LD_EXP 83
20986: PPUSH
20987: LD_VAR 0 2
20991: PPUSH
20992: LD_EXP 50
20996: PUSH
20997: LD_VAR 0 2
21001: ARRAY
21002: PPUSH
21003: LD_INT 2
21005: PUSH
21006: LD_INT 30
21008: PUSH
21009: LD_INT 6
21011: PUSH
21012: EMPTY
21013: LIST
21014: LIST
21015: PUSH
21016: LD_INT 30
21018: PUSH
21019: LD_INT 7
21021: PUSH
21022: EMPTY
21023: LIST
21024: LIST
21025: PUSH
21026: LD_INT 30
21028: PUSH
21029: LD_INT 8
21031: PUSH
21032: EMPTY
21033: LIST
21034: LIST
21035: PUSH
21036: EMPTY
21037: LIST
21038: LIST
21039: LIST
21040: LIST
21041: PPUSH
21042: CALL_OW 72
21046: PPUSH
21047: CALL_OW 1
21051: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21052: LD_ADDR_EXP 84
21056: PUSH
21057: LD_EXP 84
21061: PPUSH
21062: LD_VAR 0 2
21066: PPUSH
21067: EMPTY
21068: PPUSH
21069: CALL_OW 1
21073: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21074: LD_ADDR_EXP 85
21078: PUSH
21079: LD_EXP 85
21083: PPUSH
21084: LD_VAR 0 2
21088: PPUSH
21089: EMPTY
21090: PPUSH
21091: CALL_OW 1
21095: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21096: LD_ADDR_EXP 86
21100: PUSH
21101: LD_EXP 86
21105: PPUSH
21106: LD_VAR 0 2
21110: PPUSH
21111: EMPTY
21112: PPUSH
21113: CALL_OW 1
21117: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21118: LD_ADDR_EXP 87
21122: PUSH
21123: LD_EXP 87
21127: PPUSH
21128: LD_VAR 0 2
21132: PPUSH
21133: EMPTY
21134: PPUSH
21135: CALL_OW 1
21139: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21140: LD_ADDR_EXP 88
21144: PUSH
21145: LD_EXP 88
21149: PPUSH
21150: LD_VAR 0 2
21154: PPUSH
21155: EMPTY
21156: PPUSH
21157: CALL_OW 1
21161: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21162: LD_ADDR_EXP 89
21166: PUSH
21167: LD_EXP 89
21171: PPUSH
21172: LD_VAR 0 2
21176: PPUSH
21177: EMPTY
21178: PPUSH
21179: CALL_OW 1
21183: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21184: LD_ADDR_EXP 90
21188: PUSH
21189: LD_EXP 90
21193: PPUSH
21194: LD_VAR 0 2
21198: PPUSH
21199: EMPTY
21200: PPUSH
21201: CALL_OW 1
21205: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21206: LD_ADDR_EXP 91
21210: PUSH
21211: LD_EXP 91
21215: PPUSH
21216: LD_VAR 0 2
21220: PPUSH
21221: EMPTY
21222: PPUSH
21223: CALL_OW 1
21227: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21228: LD_ADDR_EXP 92
21232: PUSH
21233: LD_EXP 92
21237: PPUSH
21238: LD_VAR 0 2
21242: PPUSH
21243: LD_INT 0
21245: PPUSH
21246: CALL_OW 1
21250: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21251: LD_ADDR_EXP 93
21255: PUSH
21256: LD_EXP 93
21260: PPUSH
21261: LD_VAR 0 2
21265: PPUSH
21266: LD_INT 0
21268: PPUSH
21269: CALL_OW 1
21273: ST_TO_ADDR
// end ;
21274: GO 20175
21276: POP
21277: POP
// MC_InitSides ( ) ;
21278: CALL 21564 0 0
// MC_InitResearch ( ) ;
21282: CALL 21303 0 0
// CustomInitMacro ( ) ;
21286: CALL 304 0 0
// skirmish := true ;
21290: LD_ADDR_EXP 48
21294: PUSH
21295: LD_INT 1
21297: ST_TO_ADDR
// end ;
21298: LD_VAR 0 1
21302: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21303: LD_INT 0
21305: PPUSH
21306: PPUSH
21307: PPUSH
21308: PPUSH
21309: PPUSH
21310: PPUSH
// if not mc_bases then
21311: LD_EXP 50
21315: NOT
21316: IFFALSE 21320
// exit ;
21318: GO 21559
// for i = 1 to 8 do
21320: LD_ADDR_VAR 0 2
21324: PUSH
21325: DOUBLE
21326: LD_INT 1
21328: DEC
21329: ST_TO_ADDR
21330: LD_INT 8
21332: PUSH
21333: FOR_TO
21334: IFFALSE 21360
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21336: LD_ADDR_EXP 77
21340: PUSH
21341: LD_EXP 77
21345: PPUSH
21346: LD_VAR 0 2
21350: PPUSH
21351: EMPTY
21352: PPUSH
21353: CALL_OW 1
21357: ST_TO_ADDR
21358: GO 21333
21360: POP
21361: POP
// tmp := [ ] ;
21362: LD_ADDR_VAR 0 5
21366: PUSH
21367: EMPTY
21368: ST_TO_ADDR
// for i = 1 to mc_sides do
21369: LD_ADDR_VAR 0 2
21373: PUSH
21374: DOUBLE
21375: LD_INT 1
21377: DEC
21378: ST_TO_ADDR
21379: LD_EXP 76
21383: PUSH
21384: FOR_TO
21385: IFFALSE 21443
// if not mc_sides [ i ] in tmp then
21387: LD_EXP 76
21391: PUSH
21392: LD_VAR 0 2
21396: ARRAY
21397: PUSH
21398: LD_VAR 0 5
21402: IN
21403: NOT
21404: IFFALSE 21441
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21406: LD_ADDR_VAR 0 5
21410: PUSH
21411: LD_VAR 0 5
21415: PPUSH
21416: LD_VAR 0 5
21420: PUSH
21421: LD_INT 1
21423: PLUS
21424: PPUSH
21425: LD_EXP 76
21429: PUSH
21430: LD_VAR 0 2
21434: ARRAY
21435: PPUSH
21436: CALL_OW 2
21440: ST_TO_ADDR
21441: GO 21384
21443: POP
21444: POP
// if not tmp then
21445: LD_VAR 0 5
21449: NOT
21450: IFFALSE 21454
// exit ;
21452: GO 21559
// for j in tmp do
21454: LD_ADDR_VAR 0 3
21458: PUSH
21459: LD_VAR 0 5
21463: PUSH
21464: FOR_IN
21465: IFFALSE 21557
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21467: LD_ADDR_VAR 0 6
21471: PUSH
21472: LD_INT 22
21474: PUSH
21475: LD_VAR 0 3
21479: PUSH
21480: EMPTY
21481: LIST
21482: LIST
21483: PPUSH
21484: CALL_OW 69
21488: ST_TO_ADDR
// if not un then
21489: LD_VAR 0 6
21493: NOT
21494: IFFALSE 21498
// continue ;
21496: GO 21464
// nation := GetNation ( un [ 1 ] ) ;
21498: LD_ADDR_VAR 0 4
21502: PUSH
21503: LD_VAR 0 6
21507: PUSH
21508: LD_INT 1
21510: ARRAY
21511: PPUSH
21512: CALL_OW 248
21516: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21517: LD_ADDR_EXP 77
21521: PUSH
21522: LD_EXP 77
21526: PPUSH
21527: LD_VAR 0 3
21531: PPUSH
21532: LD_VAR 0 3
21536: PPUSH
21537: LD_VAR 0 4
21541: PPUSH
21542: LD_INT 1
21544: PPUSH
21545: CALL 48711 0 3
21549: PPUSH
21550: CALL_OW 1
21554: ST_TO_ADDR
// end ;
21555: GO 21464
21557: POP
21558: POP
// end ;
21559: LD_VAR 0 1
21563: RET
// export function MC_InitSides ( ) ; var i ; begin
21564: LD_INT 0
21566: PPUSH
21567: PPUSH
// if not mc_bases then
21568: LD_EXP 50
21572: NOT
21573: IFFALSE 21577
// exit ;
21575: GO 21651
// for i = 1 to mc_bases do
21577: LD_ADDR_VAR 0 2
21581: PUSH
21582: DOUBLE
21583: LD_INT 1
21585: DEC
21586: ST_TO_ADDR
21587: LD_EXP 50
21591: PUSH
21592: FOR_TO
21593: IFFALSE 21649
// if mc_bases [ i ] then
21595: LD_EXP 50
21599: PUSH
21600: LD_VAR 0 2
21604: ARRAY
21605: IFFALSE 21647
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21607: LD_ADDR_EXP 76
21611: PUSH
21612: LD_EXP 76
21616: PPUSH
21617: LD_VAR 0 2
21621: PPUSH
21622: LD_EXP 50
21626: PUSH
21627: LD_VAR 0 2
21631: ARRAY
21632: PUSH
21633: LD_INT 1
21635: ARRAY
21636: PPUSH
21637: CALL_OW 255
21641: PPUSH
21642: CALL_OW 1
21646: ST_TO_ADDR
21647: GO 21592
21649: POP
21650: POP
// end ;
21651: LD_VAR 0 1
21655: RET
// every 0 0$03 trigger skirmish do
21656: LD_EXP 48
21660: IFFALSE 21814
21662: GO 21664
21664: DISABLE
// begin enable ;
21665: ENABLE
// MC_CheckBuildings ( ) ;
21666: CALL 26312 0 0
// MC_CheckPeopleLife ( ) ;
21670: CALL 26473 0 0
// RaiseSailEvent ( 100 ) ;
21674: LD_INT 100
21676: PPUSH
21677: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21681: LD_INT 103
21683: PPUSH
21684: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21688: LD_INT 104
21690: PPUSH
21691: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21695: LD_INT 105
21697: PPUSH
21698: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21702: LD_INT 106
21704: PPUSH
21705: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21709: LD_INT 107
21711: PPUSH
21712: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21716: LD_INT 108
21718: PPUSH
21719: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21723: LD_INT 109
21725: PPUSH
21726: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21730: LD_INT 110
21732: PPUSH
21733: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21737: LD_INT 111
21739: PPUSH
21740: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21744: LD_INT 112
21746: PPUSH
21747: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21751: LD_INT 113
21753: PPUSH
21754: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21758: LD_INT 120
21760: PPUSH
21761: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21765: LD_INT 121
21767: PPUSH
21768: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21772: LD_INT 122
21774: PPUSH
21775: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21779: LD_INT 123
21781: PPUSH
21782: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21786: LD_INT 124
21788: PPUSH
21789: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21793: LD_INT 125
21795: PPUSH
21796: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21800: LD_INT 126
21802: PPUSH
21803: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21807: LD_INT 200
21809: PPUSH
21810: CALL_OW 427
// end ;
21814: END
// on SailEvent ( event ) do begin if event < 100 then
21815: LD_VAR 0 1
21819: PUSH
21820: LD_INT 100
21822: LESS
21823: IFFALSE 21834
// CustomEvent ( event ) ;
21825: LD_VAR 0 1
21829: PPUSH
21830: CALL 17170 0 1
// if event = 100 then
21834: LD_VAR 0 1
21838: PUSH
21839: LD_INT 100
21841: EQUAL
21842: IFFALSE 21848
// MC_ClassManager ( ) ;
21844: CALL 22240 0 0
// if event = 101 then
21848: LD_VAR 0 1
21852: PUSH
21853: LD_INT 101
21855: EQUAL
21856: IFFALSE 21862
// MC_RepairBuildings ( ) ;
21858: CALL 27058 0 0
// if event = 102 then
21862: LD_VAR 0 1
21866: PUSH
21867: LD_INT 102
21869: EQUAL
21870: IFFALSE 21876
// MC_Heal ( ) ;
21872: CALL 27993 0 0
// if event = 103 then
21876: LD_VAR 0 1
21880: PUSH
21881: LD_INT 103
21883: EQUAL
21884: IFFALSE 21890
// MC_Build ( ) ;
21886: CALL 28415 0 0
// if event = 104 then
21890: LD_VAR 0 1
21894: PUSH
21895: LD_INT 104
21897: EQUAL
21898: IFFALSE 21904
// MC_TurretWeapon ( ) ;
21900: CALL 30049 0 0
// if event = 105 then
21904: LD_VAR 0 1
21908: PUSH
21909: LD_INT 105
21911: EQUAL
21912: IFFALSE 21918
// MC_BuildUpgrade ( ) ;
21914: CALL 29600 0 0
// if event = 106 then
21918: LD_VAR 0 1
21922: PUSH
21923: LD_INT 106
21925: EQUAL
21926: IFFALSE 21932
// MC_PlantMines ( ) ;
21928: CALL 30479 0 0
// if event = 107 then
21932: LD_VAR 0 1
21936: PUSH
21937: LD_INT 107
21939: EQUAL
21940: IFFALSE 21946
// MC_CollectCrates ( ) ;
21942: CALL 31270 0 0
// if event = 108 then
21946: LD_VAR 0 1
21950: PUSH
21951: LD_INT 108
21953: EQUAL
21954: IFFALSE 21960
// MC_LinkRemoteControl ( ) ;
21956: CALL 33120 0 0
// if event = 109 then
21960: LD_VAR 0 1
21964: PUSH
21965: LD_INT 109
21967: EQUAL
21968: IFFALSE 21974
// MC_ProduceVehicle ( ) ;
21970: CALL 33301 0 0
// if event = 110 then
21974: LD_VAR 0 1
21978: PUSH
21979: LD_INT 110
21981: EQUAL
21982: IFFALSE 21988
// MC_SendAttack ( ) ;
21984: CALL 33767 0 0
// if event = 111 then
21988: LD_VAR 0 1
21992: PUSH
21993: LD_INT 111
21995: EQUAL
21996: IFFALSE 22002
// MC_Defend ( ) ;
21998: CALL 33875 0 0
// if event = 112 then
22002: LD_VAR 0 1
22006: PUSH
22007: LD_INT 112
22009: EQUAL
22010: IFFALSE 22016
// MC_Research ( ) ;
22012: CALL 34755 0 0
// if event = 113 then
22016: LD_VAR 0 1
22020: PUSH
22021: LD_INT 113
22023: EQUAL
22024: IFFALSE 22030
// MC_MinesTrigger ( ) ;
22026: CALL 35869 0 0
// if event = 120 then
22030: LD_VAR 0 1
22034: PUSH
22035: LD_INT 120
22037: EQUAL
22038: IFFALSE 22044
// MC_RepairVehicle ( ) ;
22040: CALL 35968 0 0
// if event = 121 then
22044: LD_VAR 0 1
22048: PUSH
22049: LD_INT 121
22051: EQUAL
22052: IFFALSE 22058
// MC_TameApe ( ) ;
22054: CALL 36737 0 0
// if event = 122 then
22058: LD_VAR 0 1
22062: PUSH
22063: LD_INT 122
22065: EQUAL
22066: IFFALSE 22072
// MC_ChangeApeClass ( ) ;
22068: CALL 37566 0 0
// if event = 123 then
22072: LD_VAR 0 1
22076: PUSH
22077: LD_INT 123
22079: EQUAL
22080: IFFALSE 22086
// MC_Bazooka ( ) ;
22082: CALL 38216 0 0
// if event = 124 then
22086: LD_VAR 0 1
22090: PUSH
22091: LD_INT 124
22093: EQUAL
22094: IFFALSE 22100
// MC_TeleportExit ( ) ;
22096: CALL 38414 0 0
// if event = 125 then
22100: LD_VAR 0 1
22104: PUSH
22105: LD_INT 125
22107: EQUAL
22108: IFFALSE 22114
// MC_Deposits ( ) ;
22110: CALL 39061 0 0
// if event = 126 then
22114: LD_VAR 0 1
22118: PUSH
22119: LD_INT 126
22121: EQUAL
22122: IFFALSE 22128
// MC_RemoteDriver ( ) ;
22124: CALL 39686 0 0
// if event = 200 then
22128: LD_VAR 0 1
22132: PUSH
22133: LD_INT 200
22135: EQUAL
22136: IFFALSE 22142
// MC_Idle ( ) ;
22138: CALL 41635 0 0
// end ;
22142: PPOPN 1
22144: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22145: LD_INT 0
22147: PPUSH
22148: PPUSH
// if not mc_bases [ base ] or not tag then
22149: LD_EXP 50
22153: PUSH
22154: LD_VAR 0 1
22158: ARRAY
22159: NOT
22160: PUSH
22161: LD_VAR 0 2
22165: NOT
22166: OR
22167: IFFALSE 22171
// exit ;
22169: GO 22235
// for i in mc_bases [ base ] union mc_ape [ base ] do
22171: LD_ADDR_VAR 0 4
22175: PUSH
22176: LD_EXP 50
22180: PUSH
22181: LD_VAR 0 1
22185: ARRAY
22186: PUSH
22187: LD_EXP 79
22191: PUSH
22192: LD_VAR 0 1
22196: ARRAY
22197: UNION
22198: PUSH
22199: FOR_IN
22200: IFFALSE 22233
// if GetTag ( i ) = tag then
22202: LD_VAR 0 4
22206: PPUSH
22207: CALL_OW 110
22211: PUSH
22212: LD_VAR 0 2
22216: EQUAL
22217: IFFALSE 22231
// SetTag ( i , 0 ) ;
22219: LD_VAR 0 4
22223: PPUSH
22224: LD_INT 0
22226: PPUSH
22227: CALL_OW 109
22231: GO 22199
22233: POP
22234: POP
// end ;
22235: LD_VAR 0 3
22239: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22240: LD_INT 0
22242: PPUSH
22243: PPUSH
22244: PPUSH
22245: PPUSH
22246: PPUSH
22247: PPUSH
22248: PPUSH
22249: PPUSH
// if not mc_bases then
22250: LD_EXP 50
22254: NOT
22255: IFFALSE 22259
// exit ;
22257: GO 22717
// for i = 1 to mc_bases do
22259: LD_ADDR_VAR 0 2
22263: PUSH
22264: DOUBLE
22265: LD_INT 1
22267: DEC
22268: ST_TO_ADDR
22269: LD_EXP 50
22273: PUSH
22274: FOR_TO
22275: IFFALSE 22715
// begin tmp := MC_ClassCheckReq ( i ) ;
22277: LD_ADDR_VAR 0 4
22281: PUSH
22282: LD_VAR 0 2
22286: PPUSH
22287: CALL 22722 0 1
22291: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22292: LD_ADDR_EXP 91
22296: PUSH
22297: LD_EXP 91
22301: PPUSH
22302: LD_VAR 0 2
22306: PPUSH
22307: LD_VAR 0 4
22311: PPUSH
22312: CALL_OW 1
22316: ST_TO_ADDR
// if not tmp then
22317: LD_VAR 0 4
22321: NOT
22322: IFFALSE 22326
// continue ;
22324: GO 22274
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22326: LD_ADDR_VAR 0 6
22330: PUSH
22331: LD_EXP 50
22335: PUSH
22336: LD_VAR 0 2
22340: ARRAY
22341: PPUSH
22342: LD_INT 2
22344: PUSH
22345: LD_INT 30
22347: PUSH
22348: LD_INT 4
22350: PUSH
22351: EMPTY
22352: LIST
22353: LIST
22354: PUSH
22355: LD_INT 30
22357: PUSH
22358: LD_INT 5
22360: PUSH
22361: EMPTY
22362: LIST
22363: LIST
22364: PUSH
22365: EMPTY
22366: LIST
22367: LIST
22368: LIST
22369: PPUSH
22370: CALL_OW 72
22374: PUSH
22375: LD_EXP 50
22379: PUSH
22380: LD_VAR 0 2
22384: ARRAY
22385: PPUSH
22386: LD_INT 2
22388: PUSH
22389: LD_INT 30
22391: PUSH
22392: LD_INT 0
22394: PUSH
22395: EMPTY
22396: LIST
22397: LIST
22398: PUSH
22399: LD_INT 30
22401: PUSH
22402: LD_INT 1
22404: PUSH
22405: EMPTY
22406: LIST
22407: LIST
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: LIST
22413: PPUSH
22414: CALL_OW 72
22418: PUSH
22419: LD_EXP 50
22423: PUSH
22424: LD_VAR 0 2
22428: ARRAY
22429: PPUSH
22430: LD_INT 30
22432: PUSH
22433: LD_INT 3
22435: PUSH
22436: EMPTY
22437: LIST
22438: LIST
22439: PPUSH
22440: CALL_OW 72
22444: PUSH
22445: LD_EXP 50
22449: PUSH
22450: LD_VAR 0 2
22454: ARRAY
22455: PPUSH
22456: LD_INT 2
22458: PUSH
22459: LD_INT 30
22461: PUSH
22462: LD_INT 6
22464: PUSH
22465: EMPTY
22466: LIST
22467: LIST
22468: PUSH
22469: LD_INT 30
22471: PUSH
22472: LD_INT 7
22474: PUSH
22475: EMPTY
22476: LIST
22477: LIST
22478: PUSH
22479: LD_INT 30
22481: PUSH
22482: LD_INT 8
22484: PUSH
22485: EMPTY
22486: LIST
22487: LIST
22488: PUSH
22489: EMPTY
22490: LIST
22491: LIST
22492: LIST
22493: LIST
22494: PPUSH
22495: CALL_OW 72
22499: PUSH
22500: EMPTY
22501: LIST
22502: LIST
22503: LIST
22504: LIST
22505: ST_TO_ADDR
// for j = 1 to 4 do
22506: LD_ADDR_VAR 0 3
22510: PUSH
22511: DOUBLE
22512: LD_INT 1
22514: DEC
22515: ST_TO_ADDR
22516: LD_INT 4
22518: PUSH
22519: FOR_TO
22520: IFFALSE 22711
// begin if not tmp [ j ] then
22522: LD_VAR 0 4
22526: PUSH
22527: LD_VAR 0 3
22531: ARRAY
22532: NOT
22533: IFFALSE 22537
// continue ;
22535: GO 22519
// for p in tmp [ j ] do
22537: LD_ADDR_VAR 0 5
22541: PUSH
22542: LD_VAR 0 4
22546: PUSH
22547: LD_VAR 0 3
22551: ARRAY
22552: PUSH
22553: FOR_IN
22554: IFFALSE 22707
// begin if not b [ j ] then
22556: LD_VAR 0 6
22560: PUSH
22561: LD_VAR 0 3
22565: ARRAY
22566: NOT
22567: IFFALSE 22571
// break ;
22569: GO 22707
// e := 0 ;
22571: LD_ADDR_VAR 0 7
22575: PUSH
22576: LD_INT 0
22578: ST_TO_ADDR
// for k in b [ j ] do
22579: LD_ADDR_VAR 0 8
22583: PUSH
22584: LD_VAR 0 6
22588: PUSH
22589: LD_VAR 0 3
22593: ARRAY
22594: PUSH
22595: FOR_IN
22596: IFFALSE 22623
// if IsNotFull ( k ) then
22598: LD_VAR 0 8
22602: PPUSH
22603: CALL 50864 0 1
22607: IFFALSE 22621
// begin e := k ;
22609: LD_ADDR_VAR 0 7
22613: PUSH
22614: LD_VAR 0 8
22618: ST_TO_ADDR
// break ;
22619: GO 22623
// end ;
22621: GO 22595
22623: POP
22624: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22625: LD_VAR 0 7
22629: PUSH
22630: LD_VAR 0 5
22634: PPUSH
22635: LD_VAR 0 7
22639: PPUSH
22640: CALL 84760 0 2
22644: NOT
22645: AND
22646: IFFALSE 22705
// begin if IsInUnit ( p ) then
22648: LD_VAR 0 5
22652: PPUSH
22653: CALL_OW 310
22657: IFFALSE 22668
// ComExitBuilding ( p ) ;
22659: LD_VAR 0 5
22663: PPUSH
22664: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22668: LD_VAR 0 5
22672: PPUSH
22673: LD_VAR 0 7
22677: PPUSH
22678: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22682: LD_VAR 0 5
22686: PPUSH
22687: LD_VAR 0 3
22691: PPUSH
22692: CALL_OW 183
// AddComExitBuilding ( p ) ;
22696: LD_VAR 0 5
22700: PPUSH
22701: CALL_OW 182
// end ; end ;
22705: GO 22553
22707: POP
22708: POP
// end ;
22709: GO 22519
22711: POP
22712: POP
// end ;
22713: GO 22274
22715: POP
22716: POP
// end ;
22717: LD_VAR 0 1
22721: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22722: LD_INT 0
22724: PPUSH
22725: PPUSH
22726: PPUSH
22727: PPUSH
22728: PPUSH
22729: PPUSH
22730: PPUSH
22731: PPUSH
22732: PPUSH
22733: PPUSH
22734: PPUSH
22735: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22736: LD_VAR 0 1
22740: NOT
22741: PUSH
22742: LD_EXP 50
22746: PUSH
22747: LD_VAR 0 1
22751: ARRAY
22752: NOT
22753: OR
22754: PUSH
22755: LD_EXP 50
22759: PUSH
22760: LD_VAR 0 1
22764: ARRAY
22765: PPUSH
22766: LD_INT 2
22768: PUSH
22769: LD_INT 30
22771: PUSH
22772: LD_INT 0
22774: PUSH
22775: EMPTY
22776: LIST
22777: LIST
22778: PUSH
22779: LD_INT 30
22781: PUSH
22782: LD_INT 1
22784: PUSH
22785: EMPTY
22786: LIST
22787: LIST
22788: PUSH
22789: EMPTY
22790: LIST
22791: LIST
22792: LIST
22793: PPUSH
22794: CALL_OW 72
22798: NOT
22799: OR
22800: IFFALSE 22804
// exit ;
22802: GO 26307
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22804: LD_ADDR_VAR 0 4
22808: PUSH
22809: LD_EXP 50
22813: PUSH
22814: LD_VAR 0 1
22818: ARRAY
22819: PPUSH
22820: LD_INT 2
22822: PUSH
22823: LD_INT 25
22825: PUSH
22826: LD_INT 1
22828: PUSH
22829: EMPTY
22830: LIST
22831: LIST
22832: PUSH
22833: LD_INT 25
22835: PUSH
22836: LD_INT 2
22838: PUSH
22839: EMPTY
22840: LIST
22841: LIST
22842: PUSH
22843: LD_INT 25
22845: PUSH
22846: LD_INT 3
22848: PUSH
22849: EMPTY
22850: LIST
22851: LIST
22852: PUSH
22853: LD_INT 25
22855: PUSH
22856: LD_INT 4
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: PUSH
22863: LD_INT 25
22865: PUSH
22866: LD_INT 5
22868: PUSH
22869: EMPTY
22870: LIST
22871: LIST
22872: PUSH
22873: LD_INT 25
22875: PUSH
22876: LD_INT 8
22878: PUSH
22879: EMPTY
22880: LIST
22881: LIST
22882: PUSH
22883: LD_INT 25
22885: PUSH
22886: LD_INT 9
22888: PUSH
22889: EMPTY
22890: LIST
22891: LIST
22892: PUSH
22893: EMPTY
22894: LIST
22895: LIST
22896: LIST
22897: LIST
22898: LIST
22899: LIST
22900: LIST
22901: LIST
22902: PPUSH
22903: CALL_OW 72
22907: ST_TO_ADDR
// if not tmp then
22908: LD_VAR 0 4
22912: NOT
22913: IFFALSE 22917
// exit ;
22915: GO 26307
// for i in tmp do
22917: LD_ADDR_VAR 0 3
22921: PUSH
22922: LD_VAR 0 4
22926: PUSH
22927: FOR_IN
22928: IFFALSE 22959
// if GetTag ( i ) then
22930: LD_VAR 0 3
22934: PPUSH
22935: CALL_OW 110
22939: IFFALSE 22957
// tmp := tmp diff i ;
22941: LD_ADDR_VAR 0 4
22945: PUSH
22946: LD_VAR 0 4
22950: PUSH
22951: LD_VAR 0 3
22955: DIFF
22956: ST_TO_ADDR
22957: GO 22927
22959: POP
22960: POP
// if not tmp then
22961: LD_VAR 0 4
22965: NOT
22966: IFFALSE 22970
// exit ;
22968: GO 26307
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22970: LD_ADDR_VAR 0 5
22974: PUSH
22975: LD_EXP 50
22979: PUSH
22980: LD_VAR 0 1
22984: ARRAY
22985: PPUSH
22986: LD_INT 2
22988: PUSH
22989: LD_INT 25
22991: PUSH
22992: LD_INT 1
22994: PUSH
22995: EMPTY
22996: LIST
22997: LIST
22998: PUSH
22999: LD_INT 25
23001: PUSH
23002: LD_INT 5
23004: PUSH
23005: EMPTY
23006: LIST
23007: LIST
23008: PUSH
23009: LD_INT 25
23011: PUSH
23012: LD_INT 8
23014: PUSH
23015: EMPTY
23016: LIST
23017: LIST
23018: PUSH
23019: LD_INT 25
23021: PUSH
23022: LD_INT 9
23024: PUSH
23025: EMPTY
23026: LIST
23027: LIST
23028: PUSH
23029: EMPTY
23030: LIST
23031: LIST
23032: LIST
23033: LIST
23034: LIST
23035: PPUSH
23036: CALL_OW 72
23040: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23041: LD_ADDR_VAR 0 6
23045: PUSH
23046: LD_EXP 50
23050: PUSH
23051: LD_VAR 0 1
23055: ARRAY
23056: PPUSH
23057: LD_INT 25
23059: PUSH
23060: LD_INT 2
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: PPUSH
23067: CALL_OW 72
23071: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23072: LD_ADDR_VAR 0 7
23076: PUSH
23077: LD_EXP 50
23081: PUSH
23082: LD_VAR 0 1
23086: ARRAY
23087: PPUSH
23088: LD_INT 25
23090: PUSH
23091: LD_INT 3
23093: PUSH
23094: EMPTY
23095: LIST
23096: LIST
23097: PPUSH
23098: CALL_OW 72
23102: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23103: LD_ADDR_VAR 0 8
23107: PUSH
23108: LD_EXP 50
23112: PUSH
23113: LD_VAR 0 1
23117: ARRAY
23118: PPUSH
23119: LD_INT 25
23121: PUSH
23122: LD_INT 4
23124: PUSH
23125: EMPTY
23126: LIST
23127: LIST
23128: PUSH
23129: LD_INT 24
23131: PUSH
23132: LD_INT 251
23134: PUSH
23135: EMPTY
23136: LIST
23137: LIST
23138: PUSH
23139: EMPTY
23140: LIST
23141: LIST
23142: PPUSH
23143: CALL_OW 72
23147: ST_TO_ADDR
// if mc_is_defending [ base ] then
23148: LD_EXP 93
23152: PUSH
23153: LD_VAR 0 1
23157: ARRAY
23158: IFFALSE 23619
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23160: LD_ADDR_EXP 92
23164: PUSH
23165: LD_EXP 92
23169: PPUSH
23170: LD_VAR 0 1
23174: PPUSH
23175: LD_INT 4
23177: PPUSH
23178: CALL_OW 1
23182: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23183: LD_ADDR_VAR 0 12
23187: PUSH
23188: LD_EXP 50
23192: PUSH
23193: LD_VAR 0 1
23197: ARRAY
23198: PPUSH
23199: LD_INT 2
23201: PUSH
23202: LD_INT 30
23204: PUSH
23205: LD_INT 4
23207: PUSH
23208: EMPTY
23209: LIST
23210: LIST
23211: PUSH
23212: LD_INT 30
23214: PUSH
23215: LD_INT 5
23217: PUSH
23218: EMPTY
23219: LIST
23220: LIST
23221: PUSH
23222: EMPTY
23223: LIST
23224: LIST
23225: LIST
23226: PPUSH
23227: CALL_OW 72
23231: ST_TO_ADDR
// if not b then
23232: LD_VAR 0 12
23236: NOT
23237: IFFALSE 23241
// exit ;
23239: GO 26307
// p := [ ] ;
23241: LD_ADDR_VAR 0 11
23245: PUSH
23246: EMPTY
23247: ST_TO_ADDR
// if sci >= 2 then
23248: LD_VAR 0 8
23252: PUSH
23253: LD_INT 2
23255: GREATEREQUAL
23256: IFFALSE 23287
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23258: LD_ADDR_VAR 0 8
23262: PUSH
23263: LD_VAR 0 8
23267: PUSH
23268: LD_INT 1
23270: ARRAY
23271: PUSH
23272: LD_VAR 0 8
23276: PUSH
23277: LD_INT 2
23279: ARRAY
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: ST_TO_ADDR
23285: GO 23348
// if sci = 1 then
23287: LD_VAR 0 8
23291: PUSH
23292: LD_INT 1
23294: EQUAL
23295: IFFALSE 23316
// sci := [ sci [ 1 ] ] else
23297: LD_ADDR_VAR 0 8
23301: PUSH
23302: LD_VAR 0 8
23306: PUSH
23307: LD_INT 1
23309: ARRAY
23310: PUSH
23311: EMPTY
23312: LIST
23313: ST_TO_ADDR
23314: GO 23348
// if sci = 0 then
23316: LD_VAR 0 8
23320: PUSH
23321: LD_INT 0
23323: EQUAL
23324: IFFALSE 23348
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23326: LD_ADDR_VAR 0 11
23330: PUSH
23331: LD_VAR 0 4
23335: PPUSH
23336: LD_INT 4
23338: PPUSH
23339: CALL 84632 0 2
23343: PUSH
23344: LD_INT 1
23346: ARRAY
23347: ST_TO_ADDR
// if eng > 4 then
23348: LD_VAR 0 6
23352: PUSH
23353: LD_INT 4
23355: GREATER
23356: IFFALSE 23402
// for i = eng downto 4 do
23358: LD_ADDR_VAR 0 3
23362: PUSH
23363: DOUBLE
23364: LD_VAR 0 6
23368: INC
23369: ST_TO_ADDR
23370: LD_INT 4
23372: PUSH
23373: FOR_DOWNTO
23374: IFFALSE 23400
// eng := eng diff eng [ i ] ;
23376: LD_ADDR_VAR 0 6
23380: PUSH
23381: LD_VAR 0 6
23385: PUSH
23386: LD_VAR 0 6
23390: PUSH
23391: LD_VAR 0 3
23395: ARRAY
23396: DIFF
23397: ST_TO_ADDR
23398: GO 23373
23400: POP
23401: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23402: LD_ADDR_VAR 0 4
23406: PUSH
23407: LD_VAR 0 4
23411: PUSH
23412: LD_VAR 0 5
23416: PUSH
23417: LD_VAR 0 6
23421: UNION
23422: PUSH
23423: LD_VAR 0 7
23427: UNION
23428: PUSH
23429: LD_VAR 0 8
23433: UNION
23434: DIFF
23435: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23436: LD_ADDR_VAR 0 13
23440: PUSH
23441: LD_EXP 50
23445: PUSH
23446: LD_VAR 0 1
23450: ARRAY
23451: PPUSH
23452: LD_INT 2
23454: PUSH
23455: LD_INT 30
23457: PUSH
23458: LD_INT 32
23460: PUSH
23461: EMPTY
23462: LIST
23463: LIST
23464: PUSH
23465: LD_INT 30
23467: PUSH
23468: LD_INT 31
23470: PUSH
23471: EMPTY
23472: LIST
23473: LIST
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: LIST
23479: PPUSH
23480: CALL_OW 72
23484: PUSH
23485: LD_EXP 50
23489: PUSH
23490: LD_VAR 0 1
23494: ARRAY
23495: PPUSH
23496: LD_INT 2
23498: PUSH
23499: LD_INT 30
23501: PUSH
23502: LD_INT 4
23504: PUSH
23505: EMPTY
23506: LIST
23507: LIST
23508: PUSH
23509: LD_INT 30
23511: PUSH
23512: LD_INT 5
23514: PUSH
23515: EMPTY
23516: LIST
23517: LIST
23518: PUSH
23519: EMPTY
23520: LIST
23521: LIST
23522: LIST
23523: PPUSH
23524: CALL_OW 72
23528: PUSH
23529: LD_INT 6
23531: MUL
23532: PLUS
23533: ST_TO_ADDR
// if bcount < tmp then
23534: LD_VAR 0 13
23538: PUSH
23539: LD_VAR 0 4
23543: LESS
23544: IFFALSE 23590
// for i = tmp downto bcount do
23546: LD_ADDR_VAR 0 3
23550: PUSH
23551: DOUBLE
23552: LD_VAR 0 4
23556: INC
23557: ST_TO_ADDR
23558: LD_VAR 0 13
23562: PUSH
23563: FOR_DOWNTO
23564: IFFALSE 23588
// tmp := Delete ( tmp , tmp ) ;
23566: LD_ADDR_VAR 0 4
23570: PUSH
23571: LD_VAR 0 4
23575: PPUSH
23576: LD_VAR 0 4
23580: PPUSH
23581: CALL_OW 3
23585: ST_TO_ADDR
23586: GO 23563
23588: POP
23589: POP
// result := [ tmp , 0 , 0 , p ] ;
23590: LD_ADDR_VAR 0 2
23594: PUSH
23595: LD_VAR 0 4
23599: PUSH
23600: LD_INT 0
23602: PUSH
23603: LD_INT 0
23605: PUSH
23606: LD_VAR 0 11
23610: PUSH
23611: EMPTY
23612: LIST
23613: LIST
23614: LIST
23615: LIST
23616: ST_TO_ADDR
// exit ;
23617: GO 26307
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23619: LD_EXP 50
23623: PUSH
23624: LD_VAR 0 1
23628: ARRAY
23629: PPUSH
23630: LD_INT 2
23632: PUSH
23633: LD_INT 30
23635: PUSH
23636: LD_INT 6
23638: PUSH
23639: EMPTY
23640: LIST
23641: LIST
23642: PUSH
23643: LD_INT 30
23645: PUSH
23646: LD_INT 7
23648: PUSH
23649: EMPTY
23650: LIST
23651: LIST
23652: PUSH
23653: LD_INT 30
23655: PUSH
23656: LD_INT 8
23658: PUSH
23659: EMPTY
23660: LIST
23661: LIST
23662: PUSH
23663: EMPTY
23664: LIST
23665: LIST
23666: LIST
23667: LIST
23668: PPUSH
23669: CALL_OW 72
23673: NOT
23674: PUSH
23675: LD_EXP 50
23679: PUSH
23680: LD_VAR 0 1
23684: ARRAY
23685: PPUSH
23686: LD_INT 30
23688: PUSH
23689: LD_INT 3
23691: PUSH
23692: EMPTY
23693: LIST
23694: LIST
23695: PPUSH
23696: CALL_OW 72
23700: NOT
23701: AND
23702: IFFALSE 23774
// begin if eng = tmp then
23704: LD_VAR 0 6
23708: PUSH
23709: LD_VAR 0 4
23713: EQUAL
23714: IFFALSE 23718
// exit ;
23716: GO 26307
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23718: LD_ADDR_EXP 92
23722: PUSH
23723: LD_EXP 92
23727: PPUSH
23728: LD_VAR 0 1
23732: PPUSH
23733: LD_INT 1
23735: PPUSH
23736: CALL_OW 1
23740: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23741: LD_ADDR_VAR 0 2
23745: PUSH
23746: LD_INT 0
23748: PUSH
23749: LD_VAR 0 4
23753: PUSH
23754: LD_VAR 0 6
23758: DIFF
23759: PUSH
23760: LD_INT 0
23762: PUSH
23763: LD_INT 0
23765: PUSH
23766: EMPTY
23767: LIST
23768: LIST
23769: LIST
23770: LIST
23771: ST_TO_ADDR
// exit ;
23772: GO 26307
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23774: LD_EXP 77
23778: PUSH
23779: LD_EXP 76
23783: PUSH
23784: LD_VAR 0 1
23788: ARRAY
23789: ARRAY
23790: PUSH
23791: LD_EXP 50
23795: PUSH
23796: LD_VAR 0 1
23800: ARRAY
23801: PPUSH
23802: LD_INT 2
23804: PUSH
23805: LD_INT 30
23807: PUSH
23808: LD_INT 6
23810: PUSH
23811: EMPTY
23812: LIST
23813: LIST
23814: PUSH
23815: LD_INT 30
23817: PUSH
23818: LD_INT 7
23820: PUSH
23821: EMPTY
23822: LIST
23823: LIST
23824: PUSH
23825: LD_INT 30
23827: PUSH
23828: LD_INT 8
23830: PUSH
23831: EMPTY
23832: LIST
23833: LIST
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: LIST
23839: LIST
23840: PPUSH
23841: CALL_OW 72
23845: AND
23846: PUSH
23847: LD_EXP 50
23851: PUSH
23852: LD_VAR 0 1
23856: ARRAY
23857: PPUSH
23858: LD_INT 30
23860: PUSH
23861: LD_INT 3
23863: PUSH
23864: EMPTY
23865: LIST
23866: LIST
23867: PPUSH
23868: CALL_OW 72
23872: NOT
23873: AND
23874: IFFALSE 24088
// begin if sci >= 6 then
23876: LD_VAR 0 8
23880: PUSH
23881: LD_INT 6
23883: GREATEREQUAL
23884: IFFALSE 23888
// exit ;
23886: GO 26307
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23888: LD_ADDR_EXP 92
23892: PUSH
23893: LD_EXP 92
23897: PPUSH
23898: LD_VAR 0 1
23902: PPUSH
23903: LD_INT 2
23905: PPUSH
23906: CALL_OW 1
23910: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23911: LD_ADDR_VAR 0 9
23915: PUSH
23916: LD_VAR 0 4
23920: PUSH
23921: LD_VAR 0 8
23925: DIFF
23926: PPUSH
23927: LD_INT 4
23929: PPUSH
23930: CALL 84632 0 2
23934: ST_TO_ADDR
// p := [ ] ;
23935: LD_ADDR_VAR 0 11
23939: PUSH
23940: EMPTY
23941: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23942: LD_VAR 0 8
23946: PUSH
23947: LD_INT 6
23949: LESS
23950: PUSH
23951: LD_VAR 0 9
23955: PUSH
23956: LD_INT 6
23958: GREATER
23959: AND
23960: IFFALSE 24041
// begin for i = 1 to 6 - sci do
23962: LD_ADDR_VAR 0 3
23966: PUSH
23967: DOUBLE
23968: LD_INT 1
23970: DEC
23971: ST_TO_ADDR
23972: LD_INT 6
23974: PUSH
23975: LD_VAR 0 8
23979: MINUS
23980: PUSH
23981: FOR_TO
23982: IFFALSE 24037
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23984: LD_ADDR_VAR 0 11
23988: PUSH
23989: LD_VAR 0 11
23993: PPUSH
23994: LD_VAR 0 11
23998: PUSH
23999: LD_INT 1
24001: PLUS
24002: PPUSH
24003: LD_VAR 0 9
24007: PUSH
24008: LD_INT 1
24010: ARRAY
24011: PPUSH
24012: CALL_OW 2
24016: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24017: LD_ADDR_VAR 0 9
24021: PUSH
24022: LD_VAR 0 9
24026: PPUSH
24027: LD_INT 1
24029: PPUSH
24030: CALL_OW 3
24034: ST_TO_ADDR
// end ;
24035: GO 23981
24037: POP
24038: POP
// end else
24039: GO 24061
// if sort then
24041: LD_VAR 0 9
24045: IFFALSE 24061
// p := sort [ 1 ] ;
24047: LD_ADDR_VAR 0 11
24051: PUSH
24052: LD_VAR 0 9
24056: PUSH
24057: LD_INT 1
24059: ARRAY
24060: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24061: LD_ADDR_VAR 0 2
24065: PUSH
24066: LD_INT 0
24068: PUSH
24069: LD_INT 0
24071: PUSH
24072: LD_INT 0
24074: PUSH
24075: LD_VAR 0 11
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: LIST
24084: LIST
24085: ST_TO_ADDR
// exit ;
24086: GO 26307
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24088: LD_EXP 77
24092: PUSH
24093: LD_EXP 76
24097: PUSH
24098: LD_VAR 0 1
24102: ARRAY
24103: ARRAY
24104: PUSH
24105: LD_EXP 50
24109: PUSH
24110: LD_VAR 0 1
24114: ARRAY
24115: PPUSH
24116: LD_INT 2
24118: PUSH
24119: LD_INT 30
24121: PUSH
24122: LD_INT 6
24124: PUSH
24125: EMPTY
24126: LIST
24127: LIST
24128: PUSH
24129: LD_INT 30
24131: PUSH
24132: LD_INT 7
24134: PUSH
24135: EMPTY
24136: LIST
24137: LIST
24138: PUSH
24139: LD_INT 30
24141: PUSH
24142: LD_INT 8
24144: PUSH
24145: EMPTY
24146: LIST
24147: LIST
24148: PUSH
24149: EMPTY
24150: LIST
24151: LIST
24152: LIST
24153: LIST
24154: PPUSH
24155: CALL_OW 72
24159: AND
24160: PUSH
24161: LD_EXP 50
24165: PUSH
24166: LD_VAR 0 1
24170: ARRAY
24171: PPUSH
24172: LD_INT 30
24174: PUSH
24175: LD_INT 3
24177: PUSH
24178: EMPTY
24179: LIST
24180: LIST
24181: PPUSH
24182: CALL_OW 72
24186: AND
24187: IFFALSE 24921
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24189: LD_ADDR_EXP 92
24193: PUSH
24194: LD_EXP 92
24198: PPUSH
24199: LD_VAR 0 1
24203: PPUSH
24204: LD_INT 3
24206: PPUSH
24207: CALL_OW 1
24211: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24212: LD_ADDR_VAR 0 2
24216: PUSH
24217: LD_INT 0
24219: PUSH
24220: LD_INT 0
24222: PUSH
24223: LD_INT 0
24225: PUSH
24226: LD_INT 0
24228: PUSH
24229: EMPTY
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: ST_TO_ADDR
// if not eng then
24235: LD_VAR 0 6
24239: NOT
24240: IFFALSE 24303
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24242: LD_ADDR_VAR 0 11
24246: PUSH
24247: LD_VAR 0 4
24251: PPUSH
24252: LD_INT 2
24254: PPUSH
24255: CALL 84632 0 2
24259: PUSH
24260: LD_INT 1
24262: ARRAY
24263: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24264: LD_ADDR_VAR 0 2
24268: PUSH
24269: LD_VAR 0 2
24273: PPUSH
24274: LD_INT 2
24276: PPUSH
24277: LD_VAR 0 11
24281: PPUSH
24282: CALL_OW 1
24286: ST_TO_ADDR
// tmp := tmp diff p ;
24287: LD_ADDR_VAR 0 4
24291: PUSH
24292: LD_VAR 0 4
24296: PUSH
24297: LD_VAR 0 11
24301: DIFF
24302: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24303: LD_VAR 0 4
24307: PUSH
24308: LD_VAR 0 8
24312: PUSH
24313: LD_INT 6
24315: LESS
24316: AND
24317: IFFALSE 24505
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24319: LD_ADDR_VAR 0 9
24323: PUSH
24324: LD_VAR 0 4
24328: PUSH
24329: LD_VAR 0 8
24333: PUSH
24334: LD_VAR 0 7
24338: UNION
24339: DIFF
24340: PPUSH
24341: LD_INT 4
24343: PPUSH
24344: CALL 84632 0 2
24348: ST_TO_ADDR
// p := [ ] ;
24349: LD_ADDR_VAR 0 11
24353: PUSH
24354: EMPTY
24355: ST_TO_ADDR
// if sort then
24356: LD_VAR 0 9
24360: IFFALSE 24476
// for i = 1 to 6 - sci do
24362: LD_ADDR_VAR 0 3
24366: PUSH
24367: DOUBLE
24368: LD_INT 1
24370: DEC
24371: ST_TO_ADDR
24372: LD_INT 6
24374: PUSH
24375: LD_VAR 0 8
24379: MINUS
24380: PUSH
24381: FOR_TO
24382: IFFALSE 24474
// begin if i = sort then
24384: LD_VAR 0 3
24388: PUSH
24389: LD_VAR 0 9
24393: EQUAL
24394: IFFALSE 24398
// break ;
24396: GO 24474
// if GetClass ( i ) = 4 then
24398: LD_VAR 0 3
24402: PPUSH
24403: CALL_OW 257
24407: PUSH
24408: LD_INT 4
24410: EQUAL
24411: IFFALSE 24415
// continue ;
24413: GO 24381
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24415: LD_ADDR_VAR 0 11
24419: PUSH
24420: LD_VAR 0 11
24424: PPUSH
24425: LD_VAR 0 11
24429: PUSH
24430: LD_INT 1
24432: PLUS
24433: PPUSH
24434: LD_VAR 0 9
24438: PUSH
24439: LD_VAR 0 3
24443: ARRAY
24444: PPUSH
24445: CALL_OW 2
24449: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24450: LD_ADDR_VAR 0 4
24454: PUSH
24455: LD_VAR 0 4
24459: PUSH
24460: LD_VAR 0 9
24464: PUSH
24465: LD_VAR 0 3
24469: ARRAY
24470: DIFF
24471: ST_TO_ADDR
// end ;
24472: GO 24381
24474: POP
24475: POP
// if p then
24476: LD_VAR 0 11
24480: IFFALSE 24505
// result := Replace ( result , 4 , p ) ;
24482: LD_ADDR_VAR 0 2
24486: PUSH
24487: LD_VAR 0 2
24491: PPUSH
24492: LD_INT 4
24494: PPUSH
24495: LD_VAR 0 11
24499: PPUSH
24500: CALL_OW 1
24504: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24505: LD_VAR 0 4
24509: PUSH
24510: LD_VAR 0 7
24514: PUSH
24515: LD_INT 6
24517: LESS
24518: AND
24519: IFFALSE 24707
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24521: LD_ADDR_VAR 0 9
24525: PUSH
24526: LD_VAR 0 4
24530: PUSH
24531: LD_VAR 0 8
24535: PUSH
24536: LD_VAR 0 7
24540: UNION
24541: DIFF
24542: PPUSH
24543: LD_INT 3
24545: PPUSH
24546: CALL 84632 0 2
24550: ST_TO_ADDR
// p := [ ] ;
24551: LD_ADDR_VAR 0 11
24555: PUSH
24556: EMPTY
24557: ST_TO_ADDR
// if sort then
24558: LD_VAR 0 9
24562: IFFALSE 24678
// for i = 1 to 6 - mech do
24564: LD_ADDR_VAR 0 3
24568: PUSH
24569: DOUBLE
24570: LD_INT 1
24572: DEC
24573: ST_TO_ADDR
24574: LD_INT 6
24576: PUSH
24577: LD_VAR 0 7
24581: MINUS
24582: PUSH
24583: FOR_TO
24584: IFFALSE 24676
// begin if i = sort then
24586: LD_VAR 0 3
24590: PUSH
24591: LD_VAR 0 9
24595: EQUAL
24596: IFFALSE 24600
// break ;
24598: GO 24676
// if GetClass ( i ) = 3 then
24600: LD_VAR 0 3
24604: PPUSH
24605: CALL_OW 257
24609: PUSH
24610: LD_INT 3
24612: EQUAL
24613: IFFALSE 24617
// continue ;
24615: GO 24583
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24617: LD_ADDR_VAR 0 11
24621: PUSH
24622: LD_VAR 0 11
24626: PPUSH
24627: LD_VAR 0 11
24631: PUSH
24632: LD_INT 1
24634: PLUS
24635: PPUSH
24636: LD_VAR 0 9
24640: PUSH
24641: LD_VAR 0 3
24645: ARRAY
24646: PPUSH
24647: CALL_OW 2
24651: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24652: LD_ADDR_VAR 0 4
24656: PUSH
24657: LD_VAR 0 4
24661: PUSH
24662: LD_VAR 0 9
24666: PUSH
24667: LD_VAR 0 3
24671: ARRAY
24672: DIFF
24673: ST_TO_ADDR
// end ;
24674: GO 24583
24676: POP
24677: POP
// if p then
24678: LD_VAR 0 11
24682: IFFALSE 24707
// result := Replace ( result , 3 , p ) ;
24684: LD_ADDR_VAR 0 2
24688: PUSH
24689: LD_VAR 0 2
24693: PPUSH
24694: LD_INT 3
24696: PPUSH
24697: LD_VAR 0 11
24701: PPUSH
24702: CALL_OW 1
24706: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24707: LD_VAR 0 4
24711: PUSH
24712: LD_INT 6
24714: GREATER
24715: PUSH
24716: LD_VAR 0 6
24720: PUSH
24721: LD_INT 6
24723: LESS
24724: AND
24725: IFFALSE 24919
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24727: LD_ADDR_VAR 0 9
24731: PUSH
24732: LD_VAR 0 4
24736: PUSH
24737: LD_VAR 0 8
24741: PUSH
24742: LD_VAR 0 7
24746: UNION
24747: PUSH
24748: LD_VAR 0 6
24752: UNION
24753: DIFF
24754: PPUSH
24755: LD_INT 2
24757: PPUSH
24758: CALL 84632 0 2
24762: ST_TO_ADDR
// p := [ ] ;
24763: LD_ADDR_VAR 0 11
24767: PUSH
24768: EMPTY
24769: ST_TO_ADDR
// if sort then
24770: LD_VAR 0 9
24774: IFFALSE 24890
// for i = 1 to 6 - eng do
24776: LD_ADDR_VAR 0 3
24780: PUSH
24781: DOUBLE
24782: LD_INT 1
24784: DEC
24785: ST_TO_ADDR
24786: LD_INT 6
24788: PUSH
24789: LD_VAR 0 6
24793: MINUS
24794: PUSH
24795: FOR_TO
24796: IFFALSE 24888
// begin if i = sort then
24798: LD_VAR 0 3
24802: PUSH
24803: LD_VAR 0 9
24807: EQUAL
24808: IFFALSE 24812
// break ;
24810: GO 24888
// if GetClass ( i ) = 2 then
24812: LD_VAR 0 3
24816: PPUSH
24817: CALL_OW 257
24821: PUSH
24822: LD_INT 2
24824: EQUAL
24825: IFFALSE 24829
// continue ;
24827: GO 24795
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24829: LD_ADDR_VAR 0 11
24833: PUSH
24834: LD_VAR 0 11
24838: PPUSH
24839: LD_VAR 0 11
24843: PUSH
24844: LD_INT 1
24846: PLUS
24847: PPUSH
24848: LD_VAR 0 9
24852: PUSH
24853: LD_VAR 0 3
24857: ARRAY
24858: PPUSH
24859: CALL_OW 2
24863: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24864: LD_ADDR_VAR 0 4
24868: PUSH
24869: LD_VAR 0 4
24873: PUSH
24874: LD_VAR 0 9
24878: PUSH
24879: LD_VAR 0 3
24883: ARRAY
24884: DIFF
24885: ST_TO_ADDR
// end ;
24886: GO 24795
24888: POP
24889: POP
// if p then
24890: LD_VAR 0 11
24894: IFFALSE 24919
// result := Replace ( result , 2 , p ) ;
24896: LD_ADDR_VAR 0 2
24900: PUSH
24901: LD_VAR 0 2
24905: PPUSH
24906: LD_INT 2
24908: PPUSH
24909: LD_VAR 0 11
24913: PPUSH
24914: CALL_OW 1
24918: ST_TO_ADDR
// end ; exit ;
24919: GO 26307
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24921: LD_EXP 77
24925: PUSH
24926: LD_EXP 76
24930: PUSH
24931: LD_VAR 0 1
24935: ARRAY
24936: ARRAY
24937: NOT
24938: PUSH
24939: LD_EXP 50
24943: PUSH
24944: LD_VAR 0 1
24948: ARRAY
24949: PPUSH
24950: LD_INT 30
24952: PUSH
24953: LD_INT 3
24955: PUSH
24956: EMPTY
24957: LIST
24958: LIST
24959: PPUSH
24960: CALL_OW 72
24964: AND
24965: PUSH
24966: LD_EXP 55
24970: PUSH
24971: LD_VAR 0 1
24975: ARRAY
24976: AND
24977: IFFALSE 25585
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24979: LD_ADDR_EXP 92
24983: PUSH
24984: LD_EXP 92
24988: PPUSH
24989: LD_VAR 0 1
24993: PPUSH
24994: LD_INT 5
24996: PPUSH
24997: CALL_OW 1
25001: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25002: LD_ADDR_VAR 0 2
25006: PUSH
25007: LD_INT 0
25009: PUSH
25010: LD_INT 0
25012: PUSH
25013: LD_INT 0
25015: PUSH
25016: LD_INT 0
25018: PUSH
25019: EMPTY
25020: LIST
25021: LIST
25022: LIST
25023: LIST
25024: ST_TO_ADDR
// if sci > 1 then
25025: LD_VAR 0 8
25029: PUSH
25030: LD_INT 1
25032: GREATER
25033: IFFALSE 25061
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25035: LD_ADDR_VAR 0 4
25039: PUSH
25040: LD_VAR 0 4
25044: PUSH
25045: LD_VAR 0 8
25049: PUSH
25050: LD_VAR 0 8
25054: PUSH
25055: LD_INT 1
25057: ARRAY
25058: DIFF
25059: DIFF
25060: ST_TO_ADDR
// if tmp and not sci then
25061: LD_VAR 0 4
25065: PUSH
25066: LD_VAR 0 8
25070: NOT
25071: AND
25072: IFFALSE 25141
// begin sort := SortBySkill ( tmp , 4 ) ;
25074: LD_ADDR_VAR 0 9
25078: PUSH
25079: LD_VAR 0 4
25083: PPUSH
25084: LD_INT 4
25086: PPUSH
25087: CALL 84632 0 2
25091: ST_TO_ADDR
// if sort then
25092: LD_VAR 0 9
25096: IFFALSE 25112
// p := sort [ 1 ] ;
25098: LD_ADDR_VAR 0 11
25102: PUSH
25103: LD_VAR 0 9
25107: PUSH
25108: LD_INT 1
25110: ARRAY
25111: ST_TO_ADDR
// if p then
25112: LD_VAR 0 11
25116: IFFALSE 25141
// result := Replace ( result , 4 , p ) ;
25118: LD_ADDR_VAR 0 2
25122: PUSH
25123: LD_VAR 0 2
25127: PPUSH
25128: LD_INT 4
25130: PPUSH
25131: LD_VAR 0 11
25135: PPUSH
25136: CALL_OW 1
25140: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25141: LD_ADDR_VAR 0 4
25145: PUSH
25146: LD_VAR 0 4
25150: PUSH
25151: LD_VAR 0 7
25155: DIFF
25156: ST_TO_ADDR
// if tmp and mech < 6 then
25157: LD_VAR 0 4
25161: PUSH
25162: LD_VAR 0 7
25166: PUSH
25167: LD_INT 6
25169: LESS
25170: AND
25171: IFFALSE 25359
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25173: LD_ADDR_VAR 0 9
25177: PUSH
25178: LD_VAR 0 4
25182: PUSH
25183: LD_VAR 0 8
25187: PUSH
25188: LD_VAR 0 7
25192: UNION
25193: DIFF
25194: PPUSH
25195: LD_INT 3
25197: PPUSH
25198: CALL 84632 0 2
25202: ST_TO_ADDR
// p := [ ] ;
25203: LD_ADDR_VAR 0 11
25207: PUSH
25208: EMPTY
25209: ST_TO_ADDR
// if sort then
25210: LD_VAR 0 9
25214: IFFALSE 25330
// for i = 1 to 6 - mech do
25216: LD_ADDR_VAR 0 3
25220: PUSH
25221: DOUBLE
25222: LD_INT 1
25224: DEC
25225: ST_TO_ADDR
25226: LD_INT 6
25228: PUSH
25229: LD_VAR 0 7
25233: MINUS
25234: PUSH
25235: FOR_TO
25236: IFFALSE 25328
// begin if i = sort then
25238: LD_VAR 0 3
25242: PUSH
25243: LD_VAR 0 9
25247: EQUAL
25248: IFFALSE 25252
// break ;
25250: GO 25328
// if GetClass ( i ) = 3 then
25252: LD_VAR 0 3
25256: PPUSH
25257: CALL_OW 257
25261: PUSH
25262: LD_INT 3
25264: EQUAL
25265: IFFALSE 25269
// continue ;
25267: GO 25235
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25269: LD_ADDR_VAR 0 11
25273: PUSH
25274: LD_VAR 0 11
25278: PPUSH
25279: LD_VAR 0 11
25283: PUSH
25284: LD_INT 1
25286: PLUS
25287: PPUSH
25288: LD_VAR 0 9
25292: PUSH
25293: LD_VAR 0 3
25297: ARRAY
25298: PPUSH
25299: CALL_OW 2
25303: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25304: LD_ADDR_VAR 0 4
25308: PUSH
25309: LD_VAR 0 4
25313: PUSH
25314: LD_VAR 0 9
25318: PUSH
25319: LD_VAR 0 3
25323: ARRAY
25324: DIFF
25325: ST_TO_ADDR
// end ;
25326: GO 25235
25328: POP
25329: POP
// if p then
25330: LD_VAR 0 11
25334: IFFALSE 25359
// result := Replace ( result , 3 , p ) ;
25336: LD_ADDR_VAR 0 2
25340: PUSH
25341: LD_VAR 0 2
25345: PPUSH
25346: LD_INT 3
25348: PPUSH
25349: LD_VAR 0 11
25353: PPUSH
25354: CALL_OW 1
25358: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25359: LD_ADDR_VAR 0 4
25363: PUSH
25364: LD_VAR 0 4
25368: PUSH
25369: LD_VAR 0 6
25373: DIFF
25374: ST_TO_ADDR
// if tmp and eng < 6 then
25375: LD_VAR 0 4
25379: PUSH
25380: LD_VAR 0 6
25384: PUSH
25385: LD_INT 6
25387: LESS
25388: AND
25389: IFFALSE 25583
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25391: LD_ADDR_VAR 0 9
25395: PUSH
25396: LD_VAR 0 4
25400: PUSH
25401: LD_VAR 0 8
25405: PUSH
25406: LD_VAR 0 7
25410: UNION
25411: PUSH
25412: LD_VAR 0 6
25416: UNION
25417: DIFF
25418: PPUSH
25419: LD_INT 2
25421: PPUSH
25422: CALL 84632 0 2
25426: ST_TO_ADDR
// p := [ ] ;
25427: LD_ADDR_VAR 0 11
25431: PUSH
25432: EMPTY
25433: ST_TO_ADDR
// if sort then
25434: LD_VAR 0 9
25438: IFFALSE 25554
// for i = 1 to 6 - eng do
25440: LD_ADDR_VAR 0 3
25444: PUSH
25445: DOUBLE
25446: LD_INT 1
25448: DEC
25449: ST_TO_ADDR
25450: LD_INT 6
25452: PUSH
25453: LD_VAR 0 6
25457: MINUS
25458: PUSH
25459: FOR_TO
25460: IFFALSE 25552
// begin if i = sort then
25462: LD_VAR 0 3
25466: PUSH
25467: LD_VAR 0 9
25471: EQUAL
25472: IFFALSE 25476
// break ;
25474: GO 25552
// if GetClass ( i ) = 2 then
25476: LD_VAR 0 3
25480: PPUSH
25481: CALL_OW 257
25485: PUSH
25486: LD_INT 2
25488: EQUAL
25489: IFFALSE 25493
// continue ;
25491: GO 25459
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25493: LD_ADDR_VAR 0 11
25497: PUSH
25498: LD_VAR 0 11
25502: PPUSH
25503: LD_VAR 0 11
25507: PUSH
25508: LD_INT 1
25510: PLUS
25511: PPUSH
25512: LD_VAR 0 9
25516: PUSH
25517: LD_VAR 0 3
25521: ARRAY
25522: PPUSH
25523: CALL_OW 2
25527: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25528: LD_ADDR_VAR 0 4
25532: PUSH
25533: LD_VAR 0 4
25537: PUSH
25538: LD_VAR 0 9
25542: PUSH
25543: LD_VAR 0 3
25547: ARRAY
25548: DIFF
25549: ST_TO_ADDR
// end ;
25550: GO 25459
25552: POP
25553: POP
// if p then
25554: LD_VAR 0 11
25558: IFFALSE 25583
// result := Replace ( result , 2 , p ) ;
25560: LD_ADDR_VAR 0 2
25564: PUSH
25565: LD_VAR 0 2
25569: PPUSH
25570: LD_INT 2
25572: PPUSH
25573: LD_VAR 0 11
25577: PPUSH
25578: CALL_OW 1
25582: ST_TO_ADDR
// end ; exit ;
25583: GO 26307
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25585: LD_EXP 77
25589: PUSH
25590: LD_EXP 76
25594: PUSH
25595: LD_VAR 0 1
25599: ARRAY
25600: ARRAY
25601: NOT
25602: PUSH
25603: LD_EXP 50
25607: PUSH
25608: LD_VAR 0 1
25612: ARRAY
25613: PPUSH
25614: LD_INT 30
25616: PUSH
25617: LD_INT 3
25619: PUSH
25620: EMPTY
25621: LIST
25622: LIST
25623: PPUSH
25624: CALL_OW 72
25628: AND
25629: PUSH
25630: LD_EXP 55
25634: PUSH
25635: LD_VAR 0 1
25639: ARRAY
25640: NOT
25641: AND
25642: IFFALSE 26307
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25644: LD_ADDR_EXP 92
25648: PUSH
25649: LD_EXP 92
25653: PPUSH
25654: LD_VAR 0 1
25658: PPUSH
25659: LD_INT 6
25661: PPUSH
25662: CALL_OW 1
25666: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25667: LD_ADDR_VAR 0 2
25671: PUSH
25672: LD_INT 0
25674: PUSH
25675: LD_INT 0
25677: PUSH
25678: LD_INT 0
25680: PUSH
25681: LD_INT 0
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: LIST
25688: LIST
25689: ST_TO_ADDR
// if sci >= 1 then
25690: LD_VAR 0 8
25694: PUSH
25695: LD_INT 1
25697: GREATEREQUAL
25698: IFFALSE 25720
// tmp := tmp diff sci [ 1 ] ;
25700: LD_ADDR_VAR 0 4
25704: PUSH
25705: LD_VAR 0 4
25709: PUSH
25710: LD_VAR 0 8
25714: PUSH
25715: LD_INT 1
25717: ARRAY
25718: DIFF
25719: ST_TO_ADDR
// if tmp and not sci then
25720: LD_VAR 0 4
25724: PUSH
25725: LD_VAR 0 8
25729: NOT
25730: AND
25731: IFFALSE 25800
// begin sort := SortBySkill ( tmp , 4 ) ;
25733: LD_ADDR_VAR 0 9
25737: PUSH
25738: LD_VAR 0 4
25742: PPUSH
25743: LD_INT 4
25745: PPUSH
25746: CALL 84632 0 2
25750: ST_TO_ADDR
// if sort then
25751: LD_VAR 0 9
25755: IFFALSE 25771
// p := sort [ 1 ] ;
25757: LD_ADDR_VAR 0 11
25761: PUSH
25762: LD_VAR 0 9
25766: PUSH
25767: LD_INT 1
25769: ARRAY
25770: ST_TO_ADDR
// if p then
25771: LD_VAR 0 11
25775: IFFALSE 25800
// result := Replace ( result , 4 , p ) ;
25777: LD_ADDR_VAR 0 2
25781: PUSH
25782: LD_VAR 0 2
25786: PPUSH
25787: LD_INT 4
25789: PPUSH
25790: LD_VAR 0 11
25794: PPUSH
25795: CALL_OW 1
25799: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25800: LD_ADDR_VAR 0 4
25804: PUSH
25805: LD_VAR 0 4
25809: PUSH
25810: LD_VAR 0 7
25814: DIFF
25815: ST_TO_ADDR
// if tmp and mech < 6 then
25816: LD_VAR 0 4
25820: PUSH
25821: LD_VAR 0 7
25825: PUSH
25826: LD_INT 6
25828: LESS
25829: AND
25830: IFFALSE 26012
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25832: LD_ADDR_VAR 0 9
25836: PUSH
25837: LD_VAR 0 4
25841: PUSH
25842: LD_VAR 0 7
25846: DIFF
25847: PPUSH
25848: LD_INT 3
25850: PPUSH
25851: CALL 84632 0 2
25855: ST_TO_ADDR
// p := [ ] ;
25856: LD_ADDR_VAR 0 11
25860: PUSH
25861: EMPTY
25862: ST_TO_ADDR
// if sort then
25863: LD_VAR 0 9
25867: IFFALSE 25983
// for i = 1 to 6 - mech do
25869: LD_ADDR_VAR 0 3
25873: PUSH
25874: DOUBLE
25875: LD_INT 1
25877: DEC
25878: ST_TO_ADDR
25879: LD_INT 6
25881: PUSH
25882: LD_VAR 0 7
25886: MINUS
25887: PUSH
25888: FOR_TO
25889: IFFALSE 25981
// begin if i = sort then
25891: LD_VAR 0 3
25895: PUSH
25896: LD_VAR 0 9
25900: EQUAL
25901: IFFALSE 25905
// break ;
25903: GO 25981
// if GetClass ( i ) = 3 then
25905: LD_VAR 0 3
25909: PPUSH
25910: CALL_OW 257
25914: PUSH
25915: LD_INT 3
25917: EQUAL
25918: IFFALSE 25922
// continue ;
25920: GO 25888
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25922: LD_ADDR_VAR 0 11
25926: PUSH
25927: LD_VAR 0 11
25931: PPUSH
25932: LD_VAR 0 11
25936: PUSH
25937: LD_INT 1
25939: PLUS
25940: PPUSH
25941: LD_VAR 0 9
25945: PUSH
25946: LD_VAR 0 3
25950: ARRAY
25951: PPUSH
25952: CALL_OW 2
25956: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25957: LD_ADDR_VAR 0 4
25961: PUSH
25962: LD_VAR 0 4
25966: PUSH
25967: LD_VAR 0 9
25971: PUSH
25972: LD_VAR 0 3
25976: ARRAY
25977: DIFF
25978: ST_TO_ADDR
// end ;
25979: GO 25888
25981: POP
25982: POP
// if p then
25983: LD_VAR 0 11
25987: IFFALSE 26012
// result := Replace ( result , 3 , p ) ;
25989: LD_ADDR_VAR 0 2
25993: PUSH
25994: LD_VAR 0 2
25998: PPUSH
25999: LD_INT 3
26001: PPUSH
26002: LD_VAR 0 11
26006: PPUSH
26007: CALL_OW 1
26011: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26012: LD_ADDR_VAR 0 4
26016: PUSH
26017: LD_VAR 0 4
26021: PUSH
26022: LD_VAR 0 6
26026: DIFF
26027: ST_TO_ADDR
// if tmp and eng < 4 then
26028: LD_VAR 0 4
26032: PUSH
26033: LD_VAR 0 6
26037: PUSH
26038: LD_INT 4
26040: LESS
26041: AND
26042: IFFALSE 26232
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26044: LD_ADDR_VAR 0 9
26048: PUSH
26049: LD_VAR 0 4
26053: PUSH
26054: LD_VAR 0 7
26058: PUSH
26059: LD_VAR 0 6
26063: UNION
26064: DIFF
26065: PPUSH
26066: LD_INT 2
26068: PPUSH
26069: CALL 84632 0 2
26073: ST_TO_ADDR
// p := [ ] ;
26074: LD_ADDR_VAR 0 11
26078: PUSH
26079: EMPTY
26080: ST_TO_ADDR
// if sort then
26081: LD_VAR 0 9
26085: IFFALSE 26201
// for i = 1 to 4 - eng do
26087: LD_ADDR_VAR 0 3
26091: PUSH
26092: DOUBLE
26093: LD_INT 1
26095: DEC
26096: ST_TO_ADDR
26097: LD_INT 4
26099: PUSH
26100: LD_VAR 0 6
26104: MINUS
26105: PUSH
26106: FOR_TO
26107: IFFALSE 26199
// begin if i = sort then
26109: LD_VAR 0 3
26113: PUSH
26114: LD_VAR 0 9
26118: EQUAL
26119: IFFALSE 26123
// break ;
26121: GO 26199
// if GetClass ( i ) = 2 then
26123: LD_VAR 0 3
26127: PPUSH
26128: CALL_OW 257
26132: PUSH
26133: LD_INT 2
26135: EQUAL
26136: IFFALSE 26140
// continue ;
26138: GO 26106
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26140: LD_ADDR_VAR 0 11
26144: PUSH
26145: LD_VAR 0 11
26149: PPUSH
26150: LD_VAR 0 11
26154: PUSH
26155: LD_INT 1
26157: PLUS
26158: PPUSH
26159: LD_VAR 0 9
26163: PUSH
26164: LD_VAR 0 3
26168: ARRAY
26169: PPUSH
26170: CALL_OW 2
26174: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26175: LD_ADDR_VAR 0 4
26179: PUSH
26180: LD_VAR 0 4
26184: PUSH
26185: LD_VAR 0 9
26189: PUSH
26190: LD_VAR 0 3
26194: ARRAY
26195: DIFF
26196: ST_TO_ADDR
// end ;
26197: GO 26106
26199: POP
26200: POP
// if p then
26201: LD_VAR 0 11
26205: IFFALSE 26230
// result := Replace ( result , 2 , p ) ;
26207: LD_ADDR_VAR 0 2
26211: PUSH
26212: LD_VAR 0 2
26216: PPUSH
26217: LD_INT 2
26219: PPUSH
26220: LD_VAR 0 11
26224: PPUSH
26225: CALL_OW 1
26229: ST_TO_ADDR
// end else
26230: GO 26276
// for i = eng downto 5 do
26232: LD_ADDR_VAR 0 3
26236: PUSH
26237: DOUBLE
26238: LD_VAR 0 6
26242: INC
26243: ST_TO_ADDR
26244: LD_INT 5
26246: PUSH
26247: FOR_DOWNTO
26248: IFFALSE 26274
// tmp := tmp union eng [ i ] ;
26250: LD_ADDR_VAR 0 4
26254: PUSH
26255: LD_VAR 0 4
26259: PUSH
26260: LD_VAR 0 6
26264: PUSH
26265: LD_VAR 0 3
26269: ARRAY
26270: UNION
26271: ST_TO_ADDR
26272: GO 26247
26274: POP
26275: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26276: LD_ADDR_VAR 0 2
26280: PUSH
26281: LD_VAR 0 2
26285: PPUSH
26286: LD_INT 1
26288: PPUSH
26289: LD_VAR 0 4
26293: PUSH
26294: LD_VAR 0 5
26298: DIFF
26299: PPUSH
26300: CALL_OW 1
26304: ST_TO_ADDR
// exit ;
26305: GO 26307
// end ; end ;
26307: LD_VAR 0 2
26311: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26312: LD_INT 0
26314: PPUSH
26315: PPUSH
26316: PPUSH
// if not mc_bases then
26317: LD_EXP 50
26321: NOT
26322: IFFALSE 26326
// exit ;
26324: GO 26468
// for i = 1 to mc_bases do
26326: LD_ADDR_VAR 0 2
26330: PUSH
26331: DOUBLE
26332: LD_INT 1
26334: DEC
26335: ST_TO_ADDR
26336: LD_EXP 50
26340: PUSH
26341: FOR_TO
26342: IFFALSE 26459
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26344: LD_ADDR_VAR 0 3
26348: PUSH
26349: LD_EXP 50
26353: PUSH
26354: LD_VAR 0 2
26358: ARRAY
26359: PPUSH
26360: LD_INT 21
26362: PUSH
26363: LD_INT 3
26365: PUSH
26366: EMPTY
26367: LIST
26368: LIST
26369: PUSH
26370: LD_INT 3
26372: PUSH
26373: LD_INT 2
26375: PUSH
26376: LD_INT 30
26378: PUSH
26379: LD_INT 29
26381: PUSH
26382: EMPTY
26383: LIST
26384: LIST
26385: PUSH
26386: LD_INT 30
26388: PUSH
26389: LD_INT 30
26391: PUSH
26392: EMPTY
26393: LIST
26394: LIST
26395: PUSH
26396: EMPTY
26397: LIST
26398: LIST
26399: LIST
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 3
26407: PUSH
26408: LD_INT 24
26410: PUSH
26411: LD_INT 1000
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: PUSH
26418: EMPTY
26419: LIST
26420: LIST
26421: PUSH
26422: EMPTY
26423: LIST
26424: LIST
26425: LIST
26426: PPUSH
26427: CALL_OW 72
26431: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26432: LD_ADDR_EXP 51
26436: PUSH
26437: LD_EXP 51
26441: PPUSH
26442: LD_VAR 0 2
26446: PPUSH
26447: LD_VAR 0 3
26451: PPUSH
26452: CALL_OW 1
26456: ST_TO_ADDR
// end ;
26457: GO 26341
26459: POP
26460: POP
// RaiseSailEvent ( 101 ) ;
26461: LD_INT 101
26463: PPUSH
26464: CALL_OW 427
// end ;
26468: LD_VAR 0 1
26472: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26473: LD_INT 0
26475: PPUSH
26476: PPUSH
26477: PPUSH
26478: PPUSH
26479: PPUSH
26480: PPUSH
26481: PPUSH
// if not mc_bases then
26482: LD_EXP 50
26486: NOT
26487: IFFALSE 26491
// exit ;
26489: GO 27053
// for i = 1 to mc_bases do
26491: LD_ADDR_VAR 0 2
26495: PUSH
26496: DOUBLE
26497: LD_INT 1
26499: DEC
26500: ST_TO_ADDR
26501: LD_EXP 50
26505: PUSH
26506: FOR_TO
26507: IFFALSE 27044
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26509: LD_ADDR_VAR 0 5
26513: PUSH
26514: LD_EXP 50
26518: PUSH
26519: LD_VAR 0 2
26523: ARRAY
26524: PUSH
26525: LD_EXP 79
26529: PUSH
26530: LD_VAR 0 2
26534: ARRAY
26535: UNION
26536: PPUSH
26537: LD_INT 21
26539: PUSH
26540: LD_INT 1
26542: PUSH
26543: EMPTY
26544: LIST
26545: LIST
26546: PUSH
26547: LD_INT 1
26549: PUSH
26550: LD_INT 3
26552: PUSH
26553: LD_INT 54
26555: PUSH
26556: EMPTY
26557: LIST
26558: PUSH
26559: EMPTY
26560: LIST
26561: LIST
26562: PUSH
26563: LD_INT 3
26565: PUSH
26566: LD_INT 24
26568: PUSH
26569: LD_INT 1000
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: LIST
26584: PUSH
26585: EMPTY
26586: LIST
26587: LIST
26588: PPUSH
26589: CALL_OW 72
26593: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26594: LD_ADDR_VAR 0 6
26598: PUSH
26599: LD_EXP 50
26603: PUSH
26604: LD_VAR 0 2
26608: ARRAY
26609: PPUSH
26610: LD_INT 21
26612: PUSH
26613: LD_INT 1
26615: PUSH
26616: EMPTY
26617: LIST
26618: LIST
26619: PUSH
26620: LD_INT 1
26622: PUSH
26623: LD_INT 3
26625: PUSH
26626: LD_INT 54
26628: PUSH
26629: EMPTY
26630: LIST
26631: PUSH
26632: EMPTY
26633: LIST
26634: LIST
26635: PUSH
26636: LD_INT 3
26638: PUSH
26639: LD_INT 24
26641: PUSH
26642: LD_INT 250
26644: PUSH
26645: EMPTY
26646: LIST
26647: LIST
26648: PUSH
26649: EMPTY
26650: LIST
26651: LIST
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: LIST
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: PPUSH
26662: CALL_OW 72
26666: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26667: LD_ADDR_VAR 0 7
26671: PUSH
26672: LD_VAR 0 5
26676: PUSH
26677: LD_VAR 0 6
26681: DIFF
26682: ST_TO_ADDR
// if not need_heal_1 then
26683: LD_VAR 0 6
26687: NOT
26688: IFFALSE 26721
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26690: LD_ADDR_EXP 53
26694: PUSH
26695: LD_EXP 53
26699: PPUSH
26700: LD_VAR 0 2
26704: PUSH
26705: LD_INT 1
26707: PUSH
26708: EMPTY
26709: LIST
26710: LIST
26711: PPUSH
26712: EMPTY
26713: PPUSH
26714: CALL 53785 0 3
26718: ST_TO_ADDR
26719: GO 26791
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26721: LD_ADDR_EXP 53
26725: PUSH
26726: LD_EXP 53
26730: PPUSH
26731: LD_VAR 0 2
26735: PUSH
26736: LD_INT 1
26738: PUSH
26739: EMPTY
26740: LIST
26741: LIST
26742: PPUSH
26743: LD_EXP 53
26747: PUSH
26748: LD_VAR 0 2
26752: ARRAY
26753: PUSH
26754: LD_INT 1
26756: ARRAY
26757: PPUSH
26758: LD_INT 3
26760: PUSH
26761: LD_INT 24
26763: PUSH
26764: LD_INT 1000
26766: PUSH
26767: EMPTY
26768: LIST
26769: LIST
26770: PUSH
26771: EMPTY
26772: LIST
26773: LIST
26774: PPUSH
26775: CALL_OW 72
26779: PUSH
26780: LD_VAR 0 6
26784: UNION
26785: PPUSH
26786: CALL 53785 0 3
26790: ST_TO_ADDR
// if not need_heal_2 then
26791: LD_VAR 0 7
26795: NOT
26796: IFFALSE 26829
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26798: LD_ADDR_EXP 53
26802: PUSH
26803: LD_EXP 53
26807: PPUSH
26808: LD_VAR 0 2
26812: PUSH
26813: LD_INT 2
26815: PUSH
26816: EMPTY
26817: LIST
26818: LIST
26819: PPUSH
26820: EMPTY
26821: PPUSH
26822: CALL 53785 0 3
26826: ST_TO_ADDR
26827: GO 26861
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26829: LD_ADDR_EXP 53
26833: PUSH
26834: LD_EXP 53
26838: PPUSH
26839: LD_VAR 0 2
26843: PUSH
26844: LD_INT 2
26846: PUSH
26847: EMPTY
26848: LIST
26849: LIST
26850: PPUSH
26851: LD_VAR 0 7
26855: PPUSH
26856: CALL 53785 0 3
26860: ST_TO_ADDR
// if need_heal_2 then
26861: LD_VAR 0 7
26865: IFFALSE 27026
// for j in need_heal_2 do
26867: LD_ADDR_VAR 0 3
26871: PUSH
26872: LD_VAR 0 7
26876: PUSH
26877: FOR_IN
26878: IFFALSE 27024
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26880: LD_ADDR_VAR 0 5
26884: PUSH
26885: LD_EXP 50
26889: PUSH
26890: LD_VAR 0 2
26894: ARRAY
26895: PPUSH
26896: LD_INT 2
26898: PUSH
26899: LD_INT 30
26901: PUSH
26902: LD_INT 6
26904: PUSH
26905: EMPTY
26906: LIST
26907: LIST
26908: PUSH
26909: LD_INT 30
26911: PUSH
26912: LD_INT 7
26914: PUSH
26915: EMPTY
26916: LIST
26917: LIST
26918: PUSH
26919: LD_INT 30
26921: PUSH
26922: LD_INT 8
26924: PUSH
26925: EMPTY
26926: LIST
26927: LIST
26928: PUSH
26929: LD_INT 30
26931: PUSH
26932: LD_INT 0
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: PUSH
26939: LD_INT 30
26941: PUSH
26942: LD_INT 1
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: PUSH
26949: EMPTY
26950: LIST
26951: LIST
26952: LIST
26953: LIST
26954: LIST
26955: LIST
26956: PPUSH
26957: CALL_OW 72
26961: ST_TO_ADDR
// if tmp then
26962: LD_VAR 0 5
26966: IFFALSE 27022
// begin k := NearestUnitToUnit ( tmp , j ) ;
26968: LD_ADDR_VAR 0 4
26972: PUSH
26973: LD_VAR 0 5
26977: PPUSH
26978: LD_VAR 0 3
26982: PPUSH
26983: CALL_OW 74
26987: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26988: LD_VAR 0 3
26992: PPUSH
26993: LD_VAR 0 4
26997: PPUSH
26998: CALL_OW 296
27002: PUSH
27003: LD_INT 5
27005: GREATER
27006: IFFALSE 27022
// ComMoveToNearbyEntrance ( j , k ) ;
27008: LD_VAR 0 3
27012: PPUSH
27013: LD_VAR 0 4
27017: PPUSH
27018: CALL 86993 0 2
// end ; end ;
27022: GO 26877
27024: POP
27025: POP
// if not need_heal_1 and not need_heal_2 then
27026: LD_VAR 0 6
27030: NOT
27031: PUSH
27032: LD_VAR 0 7
27036: NOT
27037: AND
27038: IFFALSE 27042
// continue ;
27040: GO 26506
// end ;
27042: GO 26506
27044: POP
27045: POP
// RaiseSailEvent ( 102 ) ;
27046: LD_INT 102
27048: PPUSH
27049: CALL_OW 427
// end ;
27053: LD_VAR 0 1
27057: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27058: LD_INT 0
27060: PPUSH
27061: PPUSH
27062: PPUSH
27063: PPUSH
27064: PPUSH
27065: PPUSH
27066: PPUSH
27067: PPUSH
// if not mc_bases then
27068: LD_EXP 50
27072: NOT
27073: IFFALSE 27077
// exit ;
27075: GO 27988
// for i = 1 to mc_bases do
27077: LD_ADDR_VAR 0 2
27081: PUSH
27082: DOUBLE
27083: LD_INT 1
27085: DEC
27086: ST_TO_ADDR
27087: LD_EXP 50
27091: PUSH
27092: FOR_TO
27093: IFFALSE 27986
// begin if not mc_building_need_repair [ i ] then
27095: LD_EXP 51
27099: PUSH
27100: LD_VAR 0 2
27104: ARRAY
27105: NOT
27106: IFFALSE 27291
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27108: LD_ADDR_VAR 0 6
27112: PUSH
27113: LD_EXP 69
27117: PUSH
27118: LD_VAR 0 2
27122: ARRAY
27123: PPUSH
27124: LD_INT 3
27126: PUSH
27127: LD_INT 24
27129: PUSH
27130: LD_INT 1000
27132: PUSH
27133: EMPTY
27134: LIST
27135: LIST
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: LD_INT 2
27143: PUSH
27144: LD_INT 34
27146: PUSH
27147: LD_INT 13
27149: PUSH
27150: EMPTY
27151: LIST
27152: LIST
27153: PUSH
27154: LD_INT 34
27156: PUSH
27157: LD_INT 52
27159: PUSH
27160: EMPTY
27161: LIST
27162: LIST
27163: PUSH
27164: LD_INT 34
27166: PUSH
27167: LD_INT 88
27169: PUSH
27170: EMPTY
27171: LIST
27172: LIST
27173: PUSH
27174: EMPTY
27175: LIST
27176: LIST
27177: LIST
27178: LIST
27179: PUSH
27180: EMPTY
27181: LIST
27182: LIST
27183: PPUSH
27184: CALL_OW 72
27188: ST_TO_ADDR
// if cranes then
27189: LD_VAR 0 6
27193: IFFALSE 27255
// for j in cranes do
27195: LD_ADDR_VAR 0 3
27199: PUSH
27200: LD_VAR 0 6
27204: PUSH
27205: FOR_IN
27206: IFFALSE 27253
// if not IsInArea ( j , mc_parking [ i ] ) then
27208: LD_VAR 0 3
27212: PPUSH
27213: LD_EXP 74
27217: PUSH
27218: LD_VAR 0 2
27222: ARRAY
27223: PPUSH
27224: CALL_OW 308
27228: NOT
27229: IFFALSE 27251
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27231: LD_VAR 0 3
27235: PPUSH
27236: LD_EXP 74
27240: PUSH
27241: LD_VAR 0 2
27245: ARRAY
27246: PPUSH
27247: CALL_OW 113
27251: GO 27205
27253: POP
27254: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27255: LD_ADDR_EXP 52
27259: PUSH
27260: LD_EXP 52
27264: PPUSH
27265: LD_VAR 0 2
27269: PPUSH
27270: EMPTY
27271: PPUSH
27272: CALL_OW 1
27276: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27277: LD_VAR 0 2
27281: PPUSH
27282: LD_INT 101
27284: PPUSH
27285: CALL 22145 0 2
// continue ;
27289: GO 27092
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27291: LD_ADDR_EXP 56
27295: PUSH
27296: LD_EXP 56
27300: PPUSH
27301: LD_VAR 0 2
27305: PPUSH
27306: EMPTY
27307: PPUSH
27308: CALL_OW 1
27312: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27313: LD_VAR 0 2
27317: PPUSH
27318: LD_INT 103
27320: PPUSH
27321: CALL 22145 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27325: LD_ADDR_VAR 0 5
27329: PUSH
27330: LD_EXP 50
27334: PUSH
27335: LD_VAR 0 2
27339: ARRAY
27340: PUSH
27341: LD_EXP 79
27345: PUSH
27346: LD_VAR 0 2
27350: ARRAY
27351: UNION
27352: PPUSH
27353: LD_INT 2
27355: PUSH
27356: LD_INT 25
27358: PUSH
27359: LD_INT 2
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PUSH
27366: LD_INT 25
27368: PUSH
27369: LD_INT 16
27371: PUSH
27372: EMPTY
27373: LIST
27374: LIST
27375: PUSH
27376: EMPTY
27377: LIST
27378: LIST
27379: LIST
27380: PUSH
27381: EMPTY
27382: LIST
27383: PPUSH
27384: CALL_OW 72
27388: ST_TO_ADDR
// if mc_need_heal [ i ] then
27389: LD_EXP 53
27393: PUSH
27394: LD_VAR 0 2
27398: ARRAY
27399: IFFALSE 27443
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27401: LD_ADDR_VAR 0 5
27405: PUSH
27406: LD_VAR 0 5
27410: PUSH
27411: LD_EXP 53
27415: PUSH
27416: LD_VAR 0 2
27420: ARRAY
27421: PUSH
27422: LD_INT 1
27424: ARRAY
27425: PUSH
27426: LD_EXP 53
27430: PUSH
27431: LD_VAR 0 2
27435: ARRAY
27436: PUSH
27437: LD_INT 2
27439: ARRAY
27440: UNION
27441: DIFF
27442: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27443: LD_ADDR_VAR 0 6
27447: PUSH
27448: LD_EXP 69
27452: PUSH
27453: LD_VAR 0 2
27457: ARRAY
27458: PPUSH
27459: LD_INT 2
27461: PUSH
27462: LD_INT 34
27464: PUSH
27465: LD_INT 13
27467: PUSH
27468: EMPTY
27469: LIST
27470: LIST
27471: PUSH
27472: LD_INT 34
27474: PUSH
27475: LD_INT 52
27477: PUSH
27478: EMPTY
27479: LIST
27480: LIST
27481: PUSH
27482: LD_INT 34
27484: PUSH
27485: LD_INT 88
27487: PUSH
27488: EMPTY
27489: LIST
27490: LIST
27491: PUSH
27492: EMPTY
27493: LIST
27494: LIST
27495: LIST
27496: LIST
27497: PPUSH
27498: CALL_OW 72
27502: ST_TO_ADDR
// if cranes then
27503: LD_VAR 0 6
27507: IFFALSE 27675
// begin for j in cranes do
27509: LD_ADDR_VAR 0 3
27513: PUSH
27514: LD_VAR 0 6
27518: PUSH
27519: FOR_IN
27520: IFFALSE 27673
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27522: LD_VAR 0 3
27526: PPUSH
27527: CALL_OW 256
27531: PUSH
27532: LD_INT 1000
27534: EQUAL
27535: PUSH
27536: LD_VAR 0 3
27540: PPUSH
27541: CALL_OW 314
27545: NOT
27546: AND
27547: IFFALSE 27613
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
27549: LD_ADDR_VAR 0 8
27553: PUSH
27554: LD_EXP 51
27558: PUSH
27559: LD_VAR 0 2
27563: ARRAY
27564: PPUSH
27565: LD_VAR 0 3
27569: PPUSH
27570: CALL_OW 74
27574: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27575: LD_VAR 0 8
27579: PPUSH
27580: LD_INT 16
27582: PPUSH
27583: CALL 56382 0 2
27587: PUSH
27588: LD_INT 4
27590: ARRAY
27591: PUSH
27592: LD_INT 10
27594: LESS
27595: IFFALSE 27611
// ComRepairBuilding ( j , to_repair ) ;
27597: LD_VAR 0 3
27601: PPUSH
27602: LD_VAR 0 8
27606: PPUSH
27607: CALL_OW 130
// end else
27611: GO 27671
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27613: LD_VAR 0 3
27617: PPUSH
27618: CALL_OW 256
27622: PUSH
27623: LD_INT 500
27625: LESS
27626: PUSH
27627: LD_VAR 0 3
27631: PPUSH
27632: LD_EXP 74
27636: PUSH
27637: LD_VAR 0 2
27641: ARRAY
27642: PPUSH
27643: CALL_OW 308
27647: NOT
27648: AND
27649: IFFALSE 27671
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27651: LD_VAR 0 3
27655: PPUSH
27656: LD_EXP 74
27660: PUSH
27661: LD_VAR 0 2
27665: ARRAY
27666: PPUSH
27667: CALL_OW 113
// end ;
27671: GO 27519
27673: POP
27674: POP
// end ; if tmp > 3 then
27675: LD_VAR 0 5
27679: PUSH
27680: LD_INT 3
27682: GREATER
27683: IFFALSE 27703
// tmp := ShrinkArray ( tmp , 4 ) ;
27685: LD_ADDR_VAR 0 5
27689: PUSH
27690: LD_VAR 0 5
27694: PPUSH
27695: LD_INT 4
27697: PPUSH
27698: CALL 86431 0 2
27702: ST_TO_ADDR
// if not tmp then
27703: LD_VAR 0 5
27707: NOT
27708: IFFALSE 27712
// continue ;
27710: GO 27092
// for j in tmp do
27712: LD_ADDR_VAR 0 3
27716: PUSH
27717: LD_VAR 0 5
27721: PUSH
27722: FOR_IN
27723: IFFALSE 27982
// begin if IsInUnit ( j ) then
27725: LD_VAR 0 3
27729: PPUSH
27730: CALL_OW 310
27734: IFFALSE 27745
// ComExitBuilding ( j ) ;
27736: LD_VAR 0 3
27740: PPUSH
27741: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27745: LD_VAR 0 3
27749: PUSH
27750: LD_EXP 52
27754: PUSH
27755: LD_VAR 0 2
27759: ARRAY
27760: IN
27761: NOT
27762: IFFALSE 27820
// begin SetTag ( j , 101 ) ;
27764: LD_VAR 0 3
27768: PPUSH
27769: LD_INT 101
27771: PPUSH
27772: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27776: LD_ADDR_EXP 52
27780: PUSH
27781: LD_EXP 52
27785: PPUSH
27786: LD_VAR 0 2
27790: PUSH
27791: LD_EXP 52
27795: PUSH
27796: LD_VAR 0 2
27800: ARRAY
27801: PUSH
27802: LD_INT 1
27804: PLUS
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: PPUSH
27810: LD_VAR 0 3
27814: PPUSH
27815: CALL 53785 0 3
27819: ST_TO_ADDR
// end ; wait ( 1 ) ;
27820: LD_INT 1
27822: PPUSH
27823: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27827: LD_ADDR_VAR 0 7
27831: PUSH
27832: LD_EXP 51
27836: PUSH
27837: LD_VAR 0 2
27841: ARRAY
27842: ST_TO_ADDR
// if mc_scan [ i ] then
27843: LD_EXP 73
27847: PUSH
27848: LD_VAR 0 2
27852: ARRAY
27853: IFFALSE 27915
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27855: LD_ADDR_VAR 0 7
27859: PUSH
27860: LD_EXP 51
27864: PUSH
27865: LD_VAR 0 2
27869: ARRAY
27870: PPUSH
27871: LD_INT 3
27873: PUSH
27874: LD_INT 30
27876: PUSH
27877: LD_INT 32
27879: PUSH
27880: EMPTY
27881: LIST
27882: LIST
27883: PUSH
27884: LD_INT 30
27886: PUSH
27887: LD_INT 33
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: PUSH
27894: LD_INT 30
27896: PUSH
27897: LD_INT 31
27899: PUSH
27900: EMPTY
27901: LIST
27902: LIST
27903: PUSH
27904: EMPTY
27905: LIST
27906: LIST
27907: LIST
27908: LIST
27909: PPUSH
27910: CALL_OW 72
27914: ST_TO_ADDR
// if not to_repair_tmp then
27915: LD_VAR 0 7
27919: NOT
27920: IFFALSE 27924
// continue ;
27922: GO 27722
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27924: LD_ADDR_VAR 0 8
27928: PUSH
27929: LD_VAR 0 7
27933: PPUSH
27934: LD_VAR 0 3
27938: PPUSH
27939: CALL_OW 74
27943: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
27944: LD_VAR 0 8
27948: PPUSH
27949: LD_INT 16
27951: PPUSH
27952: CALL 56382 0 2
27956: PUSH
27957: LD_INT 4
27959: ARRAY
27960: PUSH
27961: LD_INT 14
27963: LESS
27964: IFFALSE 27980
// ComRepairBuilding ( j , to_repair ) ;
27966: LD_VAR 0 3
27970: PPUSH
27971: LD_VAR 0 8
27975: PPUSH
27976: CALL_OW 130
// end ;
27980: GO 27722
27982: POP
27983: POP
// end ;
27984: GO 27092
27986: POP
27987: POP
// end ;
27988: LD_VAR 0 1
27992: RET
// export function MC_Heal ; var i , j , tmp ; begin
27993: LD_INT 0
27995: PPUSH
27996: PPUSH
27997: PPUSH
27998: PPUSH
// if not mc_bases then
27999: LD_EXP 50
28003: NOT
28004: IFFALSE 28008
// exit ;
28006: GO 28410
// for i = 1 to mc_bases do
28008: LD_ADDR_VAR 0 2
28012: PUSH
28013: DOUBLE
28014: LD_INT 1
28016: DEC
28017: ST_TO_ADDR
28018: LD_EXP 50
28022: PUSH
28023: FOR_TO
28024: IFFALSE 28408
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28026: LD_EXP 53
28030: PUSH
28031: LD_VAR 0 2
28035: ARRAY
28036: PUSH
28037: LD_INT 1
28039: ARRAY
28040: NOT
28041: PUSH
28042: LD_EXP 53
28046: PUSH
28047: LD_VAR 0 2
28051: ARRAY
28052: PUSH
28053: LD_INT 2
28055: ARRAY
28056: NOT
28057: AND
28058: IFFALSE 28096
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28060: LD_ADDR_EXP 54
28064: PUSH
28065: LD_EXP 54
28069: PPUSH
28070: LD_VAR 0 2
28074: PPUSH
28075: EMPTY
28076: PPUSH
28077: CALL_OW 1
28081: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28082: LD_VAR 0 2
28086: PPUSH
28087: LD_INT 102
28089: PPUSH
28090: CALL 22145 0 2
// continue ;
28094: GO 28023
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28096: LD_ADDR_VAR 0 4
28100: PUSH
28101: LD_EXP 50
28105: PUSH
28106: LD_VAR 0 2
28110: ARRAY
28111: PPUSH
28112: LD_INT 25
28114: PUSH
28115: LD_INT 4
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PPUSH
28122: CALL_OW 72
28126: ST_TO_ADDR
// if not tmp then
28127: LD_VAR 0 4
28131: NOT
28132: IFFALSE 28136
// continue ;
28134: GO 28023
// if mc_taming [ i ] then
28136: LD_EXP 81
28140: PUSH
28141: LD_VAR 0 2
28145: ARRAY
28146: IFFALSE 28170
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28148: LD_ADDR_EXP 81
28152: PUSH
28153: LD_EXP 81
28157: PPUSH
28158: LD_VAR 0 2
28162: PPUSH
28163: EMPTY
28164: PPUSH
28165: CALL_OW 1
28169: ST_TO_ADDR
// for j in tmp do
28170: LD_ADDR_VAR 0 3
28174: PUSH
28175: LD_VAR 0 4
28179: PUSH
28180: FOR_IN
28181: IFFALSE 28404
// begin if IsInUnit ( j ) then
28183: LD_VAR 0 3
28187: PPUSH
28188: CALL_OW 310
28192: IFFALSE 28203
// ComExitBuilding ( j ) ;
28194: LD_VAR 0 3
28198: PPUSH
28199: CALL_OW 122
// if not j in mc_healers [ i ] then
28203: LD_VAR 0 3
28207: PUSH
28208: LD_EXP 54
28212: PUSH
28213: LD_VAR 0 2
28217: ARRAY
28218: IN
28219: NOT
28220: IFFALSE 28266
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28222: LD_ADDR_EXP 54
28226: PUSH
28227: LD_EXP 54
28231: PPUSH
28232: LD_VAR 0 2
28236: PUSH
28237: LD_EXP 54
28241: PUSH
28242: LD_VAR 0 2
28246: ARRAY
28247: PUSH
28248: LD_INT 1
28250: PLUS
28251: PUSH
28252: EMPTY
28253: LIST
28254: LIST
28255: PPUSH
28256: LD_VAR 0 3
28260: PPUSH
28261: CALL 53785 0 3
28265: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28266: LD_VAR 0 3
28270: PPUSH
28271: CALL_OW 110
28275: PUSH
28276: LD_INT 102
28278: NONEQUAL
28279: IFFALSE 28293
// SetTag ( j , 102 ) ;
28281: LD_VAR 0 3
28285: PPUSH
28286: LD_INT 102
28288: PPUSH
28289: CALL_OW 109
// Wait ( 3 ) ;
28293: LD_INT 3
28295: PPUSH
28296: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28300: LD_EXP 53
28304: PUSH
28305: LD_VAR 0 2
28309: ARRAY
28310: PUSH
28311: LD_INT 1
28313: ARRAY
28314: IFFALSE 28346
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28316: LD_VAR 0 3
28320: PPUSH
28321: LD_EXP 53
28325: PUSH
28326: LD_VAR 0 2
28330: ARRAY
28331: PUSH
28332: LD_INT 1
28334: ARRAY
28335: PUSH
28336: LD_INT 1
28338: ARRAY
28339: PPUSH
28340: CALL_OW 128
28344: GO 28402
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28346: LD_VAR 0 3
28350: PPUSH
28351: CALL_OW 314
28355: NOT
28356: PUSH
28357: LD_EXP 53
28361: PUSH
28362: LD_VAR 0 2
28366: ARRAY
28367: PUSH
28368: LD_INT 2
28370: ARRAY
28371: AND
28372: IFFALSE 28402
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28374: LD_VAR 0 3
28378: PPUSH
28379: LD_EXP 53
28383: PUSH
28384: LD_VAR 0 2
28388: ARRAY
28389: PUSH
28390: LD_INT 2
28392: ARRAY
28393: PUSH
28394: LD_INT 1
28396: ARRAY
28397: PPUSH
28398: CALL_OW 128
// end ;
28402: GO 28180
28404: POP
28405: POP
// end ;
28406: GO 28023
28408: POP
28409: POP
// end ;
28410: LD_VAR 0 1
28414: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28415: LD_INT 0
28417: PPUSH
28418: PPUSH
28419: PPUSH
28420: PPUSH
28421: PPUSH
28422: PPUSH
// if not mc_bases then
28423: LD_EXP 50
28427: NOT
28428: IFFALSE 28432
// exit ;
28430: GO 29595
// for i = 1 to mc_bases do
28432: LD_ADDR_VAR 0 2
28436: PUSH
28437: DOUBLE
28438: LD_INT 1
28440: DEC
28441: ST_TO_ADDR
28442: LD_EXP 50
28446: PUSH
28447: FOR_TO
28448: IFFALSE 29593
// begin if mc_scan [ i ] then
28450: LD_EXP 73
28454: PUSH
28455: LD_VAR 0 2
28459: ARRAY
28460: IFFALSE 28464
// continue ;
28462: GO 28447
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28464: LD_EXP 55
28468: PUSH
28469: LD_VAR 0 2
28473: ARRAY
28474: NOT
28475: PUSH
28476: LD_EXP 57
28480: PUSH
28481: LD_VAR 0 2
28485: ARRAY
28486: NOT
28487: AND
28488: PUSH
28489: LD_EXP 56
28493: PUSH
28494: LD_VAR 0 2
28498: ARRAY
28499: AND
28500: IFFALSE 28538
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28502: LD_ADDR_EXP 56
28506: PUSH
28507: LD_EXP 56
28511: PPUSH
28512: LD_VAR 0 2
28516: PPUSH
28517: EMPTY
28518: PPUSH
28519: CALL_OW 1
28523: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28524: LD_VAR 0 2
28528: PPUSH
28529: LD_INT 103
28531: PPUSH
28532: CALL 22145 0 2
// continue ;
28536: GO 28447
// end ; if mc_construct_list [ i ] then
28538: LD_EXP 57
28542: PUSH
28543: LD_VAR 0 2
28547: ARRAY
28548: IFFALSE 28768
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28550: LD_ADDR_VAR 0 5
28554: PUSH
28555: LD_EXP 50
28559: PUSH
28560: LD_VAR 0 2
28564: ARRAY
28565: PPUSH
28566: LD_INT 25
28568: PUSH
28569: LD_INT 2
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PPUSH
28576: CALL_OW 72
28580: PUSH
28581: LD_EXP 52
28585: PUSH
28586: LD_VAR 0 2
28590: ARRAY
28591: DIFF
28592: ST_TO_ADDR
// if not tmp then
28593: LD_VAR 0 5
28597: NOT
28598: IFFALSE 28602
// continue ;
28600: GO 28447
// for j in tmp do
28602: LD_ADDR_VAR 0 3
28606: PUSH
28607: LD_VAR 0 5
28611: PUSH
28612: FOR_IN
28613: IFFALSE 28764
// begin if not mc_builders [ i ] then
28615: LD_EXP 56
28619: PUSH
28620: LD_VAR 0 2
28624: ARRAY
28625: NOT
28626: IFFALSE 28684
// begin SetTag ( j , 103 ) ;
28628: LD_VAR 0 3
28632: PPUSH
28633: LD_INT 103
28635: PPUSH
28636: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28640: LD_ADDR_EXP 56
28644: PUSH
28645: LD_EXP 56
28649: PPUSH
28650: LD_VAR 0 2
28654: PUSH
28655: LD_EXP 56
28659: PUSH
28660: LD_VAR 0 2
28664: ARRAY
28665: PUSH
28666: LD_INT 1
28668: PLUS
28669: PUSH
28670: EMPTY
28671: LIST
28672: LIST
28673: PPUSH
28674: LD_VAR 0 3
28678: PPUSH
28679: CALL 53785 0 3
28683: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28684: LD_VAR 0 3
28688: PPUSH
28689: CALL_OW 310
28693: IFFALSE 28704
// ComExitBuilding ( j ) ;
28695: LD_VAR 0 3
28699: PPUSH
28700: CALL_OW 122
// wait ( 3 ) ;
28704: LD_INT 3
28706: PPUSH
28707: CALL_OW 67
// if not mc_construct_list [ i ] then
28711: LD_EXP 57
28715: PUSH
28716: LD_VAR 0 2
28720: ARRAY
28721: NOT
28722: IFFALSE 28726
// break ;
28724: GO 28764
// if not HasTask ( j ) then
28726: LD_VAR 0 3
28730: PPUSH
28731: CALL_OW 314
28735: NOT
28736: IFFALSE 28762
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28738: LD_VAR 0 3
28742: PPUSH
28743: LD_EXP 57
28747: PUSH
28748: LD_VAR 0 2
28752: ARRAY
28753: PUSH
28754: LD_INT 1
28756: ARRAY
28757: PPUSH
28758: CALL 56646 0 2
// end ;
28762: GO 28612
28764: POP
28765: POP
// end else
28766: GO 29591
// if mc_build_list [ i ] then
28768: LD_EXP 55
28772: PUSH
28773: LD_VAR 0 2
28777: ARRAY
28778: IFFALSE 29591
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28780: LD_EXP 55
28784: PUSH
28785: LD_VAR 0 2
28789: ARRAY
28790: PUSH
28791: LD_INT 1
28793: ARRAY
28794: PUSH
28795: LD_INT 1
28797: ARRAY
28798: PPUSH
28799: CALL 56470 0 1
28803: PUSH
28804: LD_EXP 50
28808: PUSH
28809: LD_VAR 0 2
28813: ARRAY
28814: PPUSH
28815: LD_INT 2
28817: PUSH
28818: LD_INT 30
28820: PUSH
28821: LD_INT 2
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: PUSH
28828: LD_INT 30
28830: PUSH
28831: LD_INT 3
28833: PUSH
28834: EMPTY
28835: LIST
28836: LIST
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: LIST
28842: PPUSH
28843: CALL_OW 72
28847: NOT
28848: AND
28849: IFFALSE 28954
// begin for j = 1 to mc_build_list [ i ] do
28851: LD_ADDR_VAR 0 3
28855: PUSH
28856: DOUBLE
28857: LD_INT 1
28859: DEC
28860: ST_TO_ADDR
28861: LD_EXP 55
28865: PUSH
28866: LD_VAR 0 2
28870: ARRAY
28871: PUSH
28872: FOR_TO
28873: IFFALSE 28952
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28875: LD_EXP 55
28879: PUSH
28880: LD_VAR 0 2
28884: ARRAY
28885: PUSH
28886: LD_VAR 0 3
28890: ARRAY
28891: PUSH
28892: LD_INT 1
28894: ARRAY
28895: PUSH
28896: LD_INT 2
28898: EQUAL
28899: IFFALSE 28950
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28901: LD_ADDR_EXP 55
28905: PUSH
28906: LD_EXP 55
28910: PPUSH
28911: LD_VAR 0 2
28915: PPUSH
28916: LD_EXP 55
28920: PUSH
28921: LD_VAR 0 2
28925: ARRAY
28926: PPUSH
28927: LD_VAR 0 3
28931: PPUSH
28932: LD_INT 1
28934: PPUSH
28935: LD_INT 0
28937: PPUSH
28938: CALL 53203 0 4
28942: PPUSH
28943: CALL_OW 1
28947: ST_TO_ADDR
// break ;
28948: GO 28952
// end ;
28950: GO 28872
28952: POP
28953: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28954: LD_ADDR_VAR 0 6
28958: PUSH
28959: LD_EXP 50
28963: PUSH
28964: LD_VAR 0 2
28968: ARRAY
28969: PPUSH
28970: LD_INT 2
28972: PUSH
28973: LD_INT 30
28975: PUSH
28976: LD_INT 0
28978: PUSH
28979: EMPTY
28980: LIST
28981: LIST
28982: PUSH
28983: LD_INT 30
28985: PUSH
28986: LD_INT 1
28988: PUSH
28989: EMPTY
28990: LIST
28991: LIST
28992: PUSH
28993: EMPTY
28994: LIST
28995: LIST
28996: LIST
28997: PPUSH
28998: CALL_OW 72
29002: ST_TO_ADDR
// for k := 1 to depot do
29003: LD_ADDR_VAR 0 4
29007: PUSH
29008: DOUBLE
29009: LD_INT 1
29011: DEC
29012: ST_TO_ADDR
29013: LD_VAR 0 6
29017: PUSH
29018: FOR_TO
29019: IFFALSE 29589
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29021: LD_EXP 55
29025: PUSH
29026: LD_VAR 0 2
29030: ARRAY
29031: PUSH
29032: LD_INT 1
29034: ARRAY
29035: PUSH
29036: LD_INT 1
29038: ARRAY
29039: PUSH
29040: LD_INT 0
29042: EQUAL
29043: PUSH
29044: LD_VAR 0 6
29048: PUSH
29049: LD_VAR 0 4
29053: ARRAY
29054: PPUSH
29055: LD_EXP 55
29059: PUSH
29060: LD_VAR 0 2
29064: ARRAY
29065: PUSH
29066: LD_INT 1
29068: ARRAY
29069: PUSH
29070: LD_INT 1
29072: ARRAY
29073: PPUSH
29074: LD_EXP 55
29078: PUSH
29079: LD_VAR 0 2
29083: ARRAY
29084: PUSH
29085: LD_INT 1
29087: ARRAY
29088: PUSH
29089: LD_INT 2
29091: ARRAY
29092: PPUSH
29093: LD_EXP 55
29097: PUSH
29098: LD_VAR 0 2
29102: ARRAY
29103: PUSH
29104: LD_INT 1
29106: ARRAY
29107: PUSH
29108: LD_INT 3
29110: ARRAY
29111: PPUSH
29112: LD_EXP 55
29116: PUSH
29117: LD_VAR 0 2
29121: ARRAY
29122: PUSH
29123: LD_INT 1
29125: ARRAY
29126: PUSH
29127: LD_INT 4
29129: ARRAY
29130: PPUSH
29131: CALL 61882 0 5
29135: OR
29136: IFFALSE 29417
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29138: LD_ADDR_VAR 0 5
29142: PUSH
29143: LD_EXP 50
29147: PUSH
29148: LD_VAR 0 2
29152: ARRAY
29153: PPUSH
29154: LD_INT 25
29156: PUSH
29157: LD_INT 2
29159: PUSH
29160: EMPTY
29161: LIST
29162: LIST
29163: PPUSH
29164: CALL_OW 72
29168: PUSH
29169: LD_EXP 52
29173: PUSH
29174: LD_VAR 0 2
29178: ARRAY
29179: DIFF
29180: ST_TO_ADDR
// if not tmp then
29181: LD_VAR 0 5
29185: NOT
29186: IFFALSE 29190
// continue ;
29188: GO 29018
// for j in tmp do
29190: LD_ADDR_VAR 0 3
29194: PUSH
29195: LD_VAR 0 5
29199: PUSH
29200: FOR_IN
29201: IFFALSE 29413
// begin if not mc_builders [ i ] then
29203: LD_EXP 56
29207: PUSH
29208: LD_VAR 0 2
29212: ARRAY
29213: NOT
29214: IFFALSE 29272
// begin SetTag ( j , 103 ) ;
29216: LD_VAR 0 3
29220: PPUSH
29221: LD_INT 103
29223: PPUSH
29224: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29228: LD_ADDR_EXP 56
29232: PUSH
29233: LD_EXP 56
29237: PPUSH
29238: LD_VAR 0 2
29242: PUSH
29243: LD_EXP 56
29247: PUSH
29248: LD_VAR 0 2
29252: ARRAY
29253: PUSH
29254: LD_INT 1
29256: PLUS
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PPUSH
29262: LD_VAR 0 3
29266: PPUSH
29267: CALL 53785 0 3
29271: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29272: LD_VAR 0 3
29276: PPUSH
29277: CALL_OW 310
29281: IFFALSE 29292
// ComExitBuilding ( j ) ;
29283: LD_VAR 0 3
29287: PPUSH
29288: CALL_OW 122
// wait ( 3 ) ;
29292: LD_INT 3
29294: PPUSH
29295: CALL_OW 67
// if not mc_build_list [ i ] then
29299: LD_EXP 55
29303: PUSH
29304: LD_VAR 0 2
29308: ARRAY
29309: NOT
29310: IFFALSE 29314
// break ;
29312: GO 29413
// if not HasTask ( j ) then
29314: LD_VAR 0 3
29318: PPUSH
29319: CALL_OW 314
29323: NOT
29324: IFFALSE 29411
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29326: LD_VAR 0 3
29330: PPUSH
29331: LD_EXP 55
29335: PUSH
29336: LD_VAR 0 2
29340: ARRAY
29341: PUSH
29342: LD_INT 1
29344: ARRAY
29345: PUSH
29346: LD_INT 1
29348: ARRAY
29349: PPUSH
29350: LD_EXP 55
29354: PUSH
29355: LD_VAR 0 2
29359: ARRAY
29360: PUSH
29361: LD_INT 1
29363: ARRAY
29364: PUSH
29365: LD_INT 2
29367: ARRAY
29368: PPUSH
29369: LD_EXP 55
29373: PUSH
29374: LD_VAR 0 2
29378: ARRAY
29379: PUSH
29380: LD_INT 1
29382: ARRAY
29383: PUSH
29384: LD_INT 3
29386: ARRAY
29387: PPUSH
29388: LD_EXP 55
29392: PUSH
29393: LD_VAR 0 2
29397: ARRAY
29398: PUSH
29399: LD_INT 1
29401: ARRAY
29402: PUSH
29403: LD_INT 4
29405: ARRAY
29406: PPUSH
29407: CALL_OW 145
// end ;
29411: GO 29200
29413: POP
29414: POP
// end else
29415: GO 29587
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29417: LD_EXP 50
29421: PUSH
29422: LD_VAR 0 2
29426: ARRAY
29427: PPUSH
29428: LD_EXP 55
29432: PUSH
29433: LD_VAR 0 2
29437: ARRAY
29438: PUSH
29439: LD_INT 1
29441: ARRAY
29442: PUSH
29443: LD_INT 1
29445: ARRAY
29446: PPUSH
29447: LD_EXP 55
29451: PUSH
29452: LD_VAR 0 2
29456: ARRAY
29457: PUSH
29458: LD_INT 1
29460: ARRAY
29461: PUSH
29462: LD_INT 2
29464: ARRAY
29465: PPUSH
29466: LD_EXP 55
29470: PUSH
29471: LD_VAR 0 2
29475: ARRAY
29476: PUSH
29477: LD_INT 1
29479: ARRAY
29480: PUSH
29481: LD_INT 3
29483: ARRAY
29484: PPUSH
29485: LD_EXP 55
29489: PUSH
29490: LD_VAR 0 2
29494: ARRAY
29495: PUSH
29496: LD_INT 1
29498: ARRAY
29499: PUSH
29500: LD_INT 4
29502: ARRAY
29503: PPUSH
29504: LD_EXP 50
29508: PUSH
29509: LD_VAR 0 2
29513: ARRAY
29514: PPUSH
29515: LD_INT 21
29517: PUSH
29518: LD_INT 3
29520: PUSH
29521: EMPTY
29522: LIST
29523: LIST
29524: PPUSH
29525: CALL_OW 72
29529: PPUSH
29530: EMPTY
29531: PPUSH
29532: CALL 60636 0 7
29536: NOT
29537: IFFALSE 29587
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29539: LD_ADDR_EXP 55
29543: PUSH
29544: LD_EXP 55
29548: PPUSH
29549: LD_VAR 0 2
29553: PPUSH
29554: LD_EXP 55
29558: PUSH
29559: LD_VAR 0 2
29563: ARRAY
29564: PPUSH
29565: LD_INT 1
29567: PPUSH
29568: LD_INT 1
29570: NEG
29571: PPUSH
29572: LD_INT 0
29574: PPUSH
29575: CALL 53203 0 4
29579: PPUSH
29580: CALL_OW 1
29584: ST_TO_ADDR
// continue ;
29585: GO 29018
// end ; end ;
29587: GO 29018
29589: POP
29590: POP
// end ; end ;
29591: GO 28447
29593: POP
29594: POP
// end ;
29595: LD_VAR 0 1
29599: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29600: LD_INT 0
29602: PPUSH
29603: PPUSH
29604: PPUSH
29605: PPUSH
29606: PPUSH
29607: PPUSH
// if not mc_bases then
29608: LD_EXP 50
29612: NOT
29613: IFFALSE 29617
// exit ;
29615: GO 30044
// for i = 1 to mc_bases do
29617: LD_ADDR_VAR 0 2
29621: PUSH
29622: DOUBLE
29623: LD_INT 1
29625: DEC
29626: ST_TO_ADDR
29627: LD_EXP 50
29631: PUSH
29632: FOR_TO
29633: IFFALSE 30042
// begin tmp := mc_build_upgrade [ i ] ;
29635: LD_ADDR_VAR 0 4
29639: PUSH
29640: LD_EXP 82
29644: PUSH
29645: LD_VAR 0 2
29649: ARRAY
29650: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29651: LD_ADDR_VAR 0 6
29655: PUSH
29656: LD_EXP 83
29660: PUSH
29661: LD_VAR 0 2
29665: ARRAY
29666: PPUSH
29667: LD_INT 2
29669: PUSH
29670: LD_INT 30
29672: PUSH
29673: LD_INT 6
29675: PUSH
29676: EMPTY
29677: LIST
29678: LIST
29679: PUSH
29680: LD_INT 30
29682: PUSH
29683: LD_INT 7
29685: PUSH
29686: EMPTY
29687: LIST
29688: LIST
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: LIST
29694: PPUSH
29695: CALL_OW 72
29699: ST_TO_ADDR
// if not tmp and not lab then
29700: LD_VAR 0 4
29704: NOT
29705: PUSH
29706: LD_VAR 0 6
29710: NOT
29711: AND
29712: IFFALSE 29716
// continue ;
29714: GO 29632
// if tmp then
29716: LD_VAR 0 4
29720: IFFALSE 29840
// for j in tmp do
29722: LD_ADDR_VAR 0 3
29726: PUSH
29727: LD_VAR 0 4
29731: PUSH
29732: FOR_IN
29733: IFFALSE 29838
// begin if UpgradeCost ( j ) then
29735: LD_VAR 0 3
29739: PPUSH
29740: CALL 60296 0 1
29744: IFFALSE 29836
// begin ComUpgrade ( j ) ;
29746: LD_VAR 0 3
29750: PPUSH
29751: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29755: LD_ADDR_EXP 82
29759: PUSH
29760: LD_EXP 82
29764: PPUSH
29765: LD_VAR 0 2
29769: PPUSH
29770: LD_EXP 82
29774: PUSH
29775: LD_VAR 0 2
29779: ARRAY
29780: PUSH
29781: LD_VAR 0 3
29785: DIFF
29786: PPUSH
29787: CALL_OW 1
29791: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29792: LD_ADDR_EXP 57
29796: PUSH
29797: LD_EXP 57
29801: PPUSH
29802: LD_VAR 0 2
29806: PUSH
29807: LD_EXP 57
29811: PUSH
29812: LD_VAR 0 2
29816: ARRAY
29817: PUSH
29818: LD_INT 1
29820: PLUS
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PPUSH
29826: LD_VAR 0 3
29830: PPUSH
29831: CALL 53785 0 3
29835: ST_TO_ADDR
// end ; end ;
29836: GO 29732
29838: POP
29839: POP
// if not lab or not mc_lab_upgrade [ i ] then
29840: LD_VAR 0 6
29844: NOT
29845: PUSH
29846: LD_EXP 84
29850: PUSH
29851: LD_VAR 0 2
29855: ARRAY
29856: NOT
29857: OR
29858: IFFALSE 29862
// continue ;
29860: GO 29632
// for j in lab do
29862: LD_ADDR_VAR 0 3
29866: PUSH
29867: LD_VAR 0 6
29871: PUSH
29872: FOR_IN
29873: IFFALSE 30038
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29875: LD_VAR 0 3
29879: PPUSH
29880: CALL_OW 266
29884: PUSH
29885: LD_INT 6
29887: PUSH
29888: LD_INT 7
29890: PUSH
29891: EMPTY
29892: LIST
29893: LIST
29894: IN
29895: PUSH
29896: LD_VAR 0 3
29900: PPUSH
29901: CALL_OW 461
29905: PUSH
29906: LD_INT 1
29908: NONEQUAL
29909: AND
29910: IFFALSE 30036
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29912: LD_VAR 0 3
29916: PPUSH
29917: LD_EXP 84
29921: PUSH
29922: LD_VAR 0 2
29926: ARRAY
29927: PUSH
29928: LD_INT 1
29930: ARRAY
29931: PPUSH
29932: CALL 60501 0 2
29936: IFFALSE 30036
// begin ComCancel ( j ) ;
29938: LD_VAR 0 3
29942: PPUSH
29943: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29947: LD_VAR 0 3
29951: PPUSH
29952: LD_EXP 84
29956: PUSH
29957: LD_VAR 0 2
29961: ARRAY
29962: PUSH
29963: LD_INT 1
29965: ARRAY
29966: PPUSH
29967: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29971: LD_VAR 0 3
29975: PUSH
29976: LD_EXP 57
29980: PUSH
29981: LD_VAR 0 2
29985: ARRAY
29986: IN
29987: NOT
29988: IFFALSE 30034
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29990: LD_ADDR_EXP 57
29994: PUSH
29995: LD_EXP 57
29999: PPUSH
30000: LD_VAR 0 2
30004: PUSH
30005: LD_EXP 57
30009: PUSH
30010: LD_VAR 0 2
30014: ARRAY
30015: PUSH
30016: LD_INT 1
30018: PLUS
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PPUSH
30024: LD_VAR 0 3
30028: PPUSH
30029: CALL 53785 0 3
30033: ST_TO_ADDR
// break ;
30034: GO 30038
// end ; end ; end ;
30036: GO 29872
30038: POP
30039: POP
// end ;
30040: GO 29632
30042: POP
30043: POP
// end ;
30044: LD_VAR 0 1
30048: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30049: LD_INT 0
30051: PPUSH
30052: PPUSH
30053: PPUSH
30054: PPUSH
30055: PPUSH
30056: PPUSH
30057: PPUSH
30058: PPUSH
30059: PPUSH
// if not mc_bases then
30060: LD_EXP 50
30064: NOT
30065: IFFALSE 30069
// exit ;
30067: GO 30474
// for i = 1 to mc_bases do
30069: LD_ADDR_VAR 0 2
30073: PUSH
30074: DOUBLE
30075: LD_INT 1
30077: DEC
30078: ST_TO_ADDR
30079: LD_EXP 50
30083: PUSH
30084: FOR_TO
30085: IFFALSE 30472
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30087: LD_EXP 58
30091: PUSH
30092: LD_VAR 0 2
30096: ARRAY
30097: NOT
30098: PUSH
30099: LD_EXP 50
30103: PUSH
30104: LD_VAR 0 2
30108: ARRAY
30109: PPUSH
30110: LD_INT 30
30112: PUSH
30113: LD_INT 3
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PPUSH
30120: CALL_OW 72
30124: NOT
30125: OR
30126: IFFALSE 30130
// continue ;
30128: GO 30084
// busy := false ;
30130: LD_ADDR_VAR 0 8
30134: PUSH
30135: LD_INT 0
30137: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30138: LD_ADDR_VAR 0 4
30142: PUSH
30143: LD_EXP 50
30147: PUSH
30148: LD_VAR 0 2
30152: ARRAY
30153: PPUSH
30154: LD_INT 30
30156: PUSH
30157: LD_INT 3
30159: PUSH
30160: EMPTY
30161: LIST
30162: LIST
30163: PPUSH
30164: CALL_OW 72
30168: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30169: LD_ADDR_VAR 0 6
30173: PUSH
30174: LD_EXP 58
30178: PUSH
30179: LD_VAR 0 2
30183: ARRAY
30184: PPUSH
30185: LD_INT 2
30187: PUSH
30188: LD_INT 30
30190: PUSH
30191: LD_INT 32
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: PUSH
30198: LD_INT 30
30200: PUSH
30201: LD_INT 33
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: LIST
30212: PPUSH
30213: CALL_OW 72
30217: ST_TO_ADDR
// if not t then
30218: LD_VAR 0 6
30222: NOT
30223: IFFALSE 30227
// continue ;
30225: GO 30084
// for j in tmp do
30227: LD_ADDR_VAR 0 3
30231: PUSH
30232: LD_VAR 0 4
30236: PUSH
30237: FOR_IN
30238: IFFALSE 30268
// if not BuildingStatus ( j ) = bs_idle then
30240: LD_VAR 0 3
30244: PPUSH
30245: CALL_OW 461
30249: PUSH
30250: LD_INT 2
30252: EQUAL
30253: NOT
30254: IFFALSE 30266
// begin busy := true ;
30256: LD_ADDR_VAR 0 8
30260: PUSH
30261: LD_INT 1
30263: ST_TO_ADDR
// break ;
30264: GO 30268
// end ;
30266: GO 30237
30268: POP
30269: POP
// if busy then
30270: LD_VAR 0 8
30274: IFFALSE 30278
// continue ;
30276: GO 30084
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30278: LD_ADDR_VAR 0 7
30282: PUSH
30283: LD_VAR 0 6
30287: PPUSH
30288: LD_INT 35
30290: PUSH
30291: LD_INT 0
30293: PUSH
30294: EMPTY
30295: LIST
30296: LIST
30297: PPUSH
30298: CALL_OW 72
30302: ST_TO_ADDR
// if tw then
30303: LD_VAR 0 7
30307: IFFALSE 30384
// begin tw := tw [ 1 ] ;
30309: LD_ADDR_VAR 0 7
30313: PUSH
30314: LD_VAR 0 7
30318: PUSH
30319: LD_INT 1
30321: ARRAY
30322: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30323: LD_ADDR_VAR 0 9
30327: PUSH
30328: LD_VAR 0 7
30332: PPUSH
30333: LD_EXP 75
30337: PUSH
30338: LD_VAR 0 2
30342: ARRAY
30343: PPUSH
30344: CALL 58793 0 2
30348: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30349: LD_EXP 89
30353: PUSH
30354: LD_VAR 0 2
30358: ARRAY
30359: IFFALSE 30382
// if not weapon in mc_allowed_tower_weapons [ i ] then
30361: LD_VAR 0 9
30365: PUSH
30366: LD_EXP 89
30370: PUSH
30371: LD_VAR 0 2
30375: ARRAY
30376: IN
30377: NOT
30378: IFFALSE 30382
// continue ;
30380: GO 30084
// end else
30382: GO 30447
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30384: LD_ADDR_VAR 0 5
30388: PUSH
30389: LD_EXP 58
30393: PUSH
30394: LD_VAR 0 2
30398: ARRAY
30399: PPUSH
30400: LD_VAR 0 4
30404: PPUSH
30405: CALL 85664 0 2
30409: ST_TO_ADDR
// if not tmp2 then
30410: LD_VAR 0 5
30414: NOT
30415: IFFALSE 30419
// continue ;
30417: GO 30084
// tw := tmp2 [ 1 ] ;
30419: LD_ADDR_VAR 0 7
30423: PUSH
30424: LD_VAR 0 5
30428: PUSH
30429: LD_INT 1
30431: ARRAY
30432: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30433: LD_ADDR_VAR 0 9
30437: PUSH
30438: LD_VAR 0 5
30442: PUSH
30443: LD_INT 2
30445: ARRAY
30446: ST_TO_ADDR
// end ; if not weapon then
30447: LD_VAR 0 9
30451: NOT
30452: IFFALSE 30456
// continue ;
30454: GO 30084
// ComPlaceWeapon ( tw , weapon ) ;
30456: LD_VAR 0 7
30460: PPUSH
30461: LD_VAR 0 9
30465: PPUSH
30466: CALL_OW 148
// end ;
30470: GO 30084
30472: POP
30473: POP
// end ;
30474: LD_VAR 0 1
30478: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30479: LD_INT 0
30481: PPUSH
30482: PPUSH
30483: PPUSH
30484: PPUSH
30485: PPUSH
30486: PPUSH
30487: PPUSH
// if not mc_bases then
30488: LD_EXP 50
30492: NOT
30493: IFFALSE 30497
// exit ;
30495: GO 31265
// for i = 1 to mc_bases do
30497: LD_ADDR_VAR 0 2
30501: PUSH
30502: DOUBLE
30503: LD_INT 1
30505: DEC
30506: ST_TO_ADDR
30507: LD_EXP 50
30511: PUSH
30512: FOR_TO
30513: IFFALSE 31263
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30515: LD_EXP 63
30519: PUSH
30520: LD_VAR 0 2
30524: ARRAY
30525: NOT
30526: PUSH
30527: LD_EXP 63
30531: PUSH
30532: LD_VAR 0 2
30536: ARRAY
30537: PUSH
30538: LD_EXP 64
30542: PUSH
30543: LD_VAR 0 2
30547: ARRAY
30548: EQUAL
30549: OR
30550: PUSH
30551: LD_EXP 73
30555: PUSH
30556: LD_VAR 0 2
30560: ARRAY
30561: OR
30562: IFFALSE 30566
// continue ;
30564: GO 30512
// if mc_miners [ i ] then
30566: LD_EXP 64
30570: PUSH
30571: LD_VAR 0 2
30575: ARRAY
30576: IFFALSE 30950
// begin for j = mc_miners [ i ] downto 1 do
30578: LD_ADDR_VAR 0 3
30582: PUSH
30583: DOUBLE
30584: LD_EXP 64
30588: PUSH
30589: LD_VAR 0 2
30593: ARRAY
30594: INC
30595: ST_TO_ADDR
30596: LD_INT 1
30598: PUSH
30599: FOR_DOWNTO
30600: IFFALSE 30948
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30602: LD_EXP 64
30606: PUSH
30607: LD_VAR 0 2
30611: ARRAY
30612: PUSH
30613: LD_VAR 0 3
30617: ARRAY
30618: PPUSH
30619: CALL_OW 301
30623: PUSH
30624: LD_EXP 64
30628: PUSH
30629: LD_VAR 0 2
30633: ARRAY
30634: PUSH
30635: LD_VAR 0 3
30639: ARRAY
30640: PPUSH
30641: CALL_OW 257
30645: PUSH
30646: LD_INT 1
30648: NONEQUAL
30649: OR
30650: IFFALSE 30713
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30652: LD_ADDR_VAR 0 5
30656: PUSH
30657: LD_EXP 64
30661: PUSH
30662: LD_VAR 0 2
30666: ARRAY
30667: PUSH
30668: LD_EXP 64
30672: PUSH
30673: LD_VAR 0 2
30677: ARRAY
30678: PUSH
30679: LD_VAR 0 3
30683: ARRAY
30684: DIFF
30685: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30686: LD_ADDR_EXP 64
30690: PUSH
30691: LD_EXP 64
30695: PPUSH
30696: LD_VAR 0 2
30700: PPUSH
30701: LD_VAR 0 5
30705: PPUSH
30706: CALL_OW 1
30710: ST_TO_ADDR
// continue ;
30711: GO 30599
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30713: LD_EXP 64
30717: PUSH
30718: LD_VAR 0 2
30722: ARRAY
30723: PUSH
30724: LD_VAR 0 3
30728: ARRAY
30729: PPUSH
30730: CALL_OW 257
30734: PUSH
30735: LD_INT 1
30737: EQUAL
30738: PUSH
30739: LD_EXP 64
30743: PUSH
30744: LD_VAR 0 2
30748: ARRAY
30749: PUSH
30750: LD_VAR 0 3
30754: ARRAY
30755: PPUSH
30756: CALL_OW 459
30760: NOT
30761: AND
30762: PUSH
30763: LD_EXP 64
30767: PUSH
30768: LD_VAR 0 2
30772: ARRAY
30773: PUSH
30774: LD_VAR 0 3
30778: ARRAY
30779: PPUSH
30780: CALL_OW 314
30784: NOT
30785: AND
30786: IFFALSE 30946
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30788: LD_EXP 64
30792: PUSH
30793: LD_VAR 0 2
30797: ARRAY
30798: PUSH
30799: LD_VAR 0 3
30803: ARRAY
30804: PPUSH
30805: CALL_OW 310
30809: IFFALSE 30832
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30811: LD_EXP 64
30815: PUSH
30816: LD_VAR 0 2
30820: ARRAY
30821: PUSH
30822: LD_VAR 0 3
30826: ARRAY
30827: PPUSH
30828: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30832: LD_EXP 64
30836: PUSH
30837: LD_VAR 0 2
30841: ARRAY
30842: PUSH
30843: LD_VAR 0 3
30847: ARRAY
30848: PPUSH
30849: CALL_OW 314
30853: NOT
30854: IFFALSE 30946
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30856: LD_ADDR_VAR 0 7
30860: PUSH
30861: LD_INT 1
30863: PPUSH
30864: LD_EXP 63
30868: PUSH
30869: LD_VAR 0 2
30873: ARRAY
30874: PPUSH
30875: CALL_OW 12
30879: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30880: LD_EXP 64
30884: PUSH
30885: LD_VAR 0 2
30889: ARRAY
30890: PUSH
30891: LD_VAR 0 3
30895: ARRAY
30896: PPUSH
30897: LD_EXP 63
30901: PUSH
30902: LD_VAR 0 2
30906: ARRAY
30907: PUSH
30908: LD_VAR 0 7
30912: ARRAY
30913: PUSH
30914: LD_INT 1
30916: ARRAY
30917: PPUSH
30918: LD_EXP 63
30922: PUSH
30923: LD_VAR 0 2
30927: ARRAY
30928: PUSH
30929: LD_VAR 0 7
30933: ARRAY
30934: PUSH
30935: LD_INT 2
30937: ARRAY
30938: PPUSH
30939: LD_INT 0
30941: PPUSH
30942: CALL_OW 193
// end ; end ; end ;
30946: GO 30599
30948: POP
30949: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30950: LD_ADDR_VAR 0 5
30954: PUSH
30955: LD_EXP 50
30959: PUSH
30960: LD_VAR 0 2
30964: ARRAY
30965: PPUSH
30966: LD_INT 2
30968: PUSH
30969: LD_INT 30
30971: PUSH
30972: LD_INT 4
30974: PUSH
30975: EMPTY
30976: LIST
30977: LIST
30978: PUSH
30979: LD_INT 30
30981: PUSH
30982: LD_INT 5
30984: PUSH
30985: EMPTY
30986: LIST
30987: LIST
30988: PUSH
30989: LD_INT 30
30991: PUSH
30992: LD_INT 32
30994: PUSH
30995: EMPTY
30996: LIST
30997: LIST
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: LIST
31003: LIST
31004: PPUSH
31005: CALL_OW 72
31009: ST_TO_ADDR
// if not tmp then
31010: LD_VAR 0 5
31014: NOT
31015: IFFALSE 31019
// continue ;
31017: GO 30512
// list := [ ] ;
31019: LD_ADDR_VAR 0 6
31023: PUSH
31024: EMPTY
31025: ST_TO_ADDR
// for j in tmp do
31026: LD_ADDR_VAR 0 3
31030: PUSH
31031: LD_VAR 0 5
31035: PUSH
31036: FOR_IN
31037: IFFALSE 31106
// begin for k in UnitsInside ( j ) do
31039: LD_ADDR_VAR 0 4
31043: PUSH
31044: LD_VAR 0 3
31048: PPUSH
31049: CALL_OW 313
31053: PUSH
31054: FOR_IN
31055: IFFALSE 31102
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31057: LD_VAR 0 4
31061: PPUSH
31062: CALL_OW 257
31066: PUSH
31067: LD_INT 1
31069: EQUAL
31070: PUSH
31071: LD_VAR 0 4
31075: PPUSH
31076: CALL_OW 459
31080: NOT
31081: AND
31082: IFFALSE 31100
// list := list ^ k ;
31084: LD_ADDR_VAR 0 6
31088: PUSH
31089: LD_VAR 0 6
31093: PUSH
31094: LD_VAR 0 4
31098: ADD
31099: ST_TO_ADDR
31100: GO 31054
31102: POP
31103: POP
// end ;
31104: GO 31036
31106: POP
31107: POP
// list := list diff mc_miners [ i ] ;
31108: LD_ADDR_VAR 0 6
31112: PUSH
31113: LD_VAR 0 6
31117: PUSH
31118: LD_EXP 64
31122: PUSH
31123: LD_VAR 0 2
31127: ARRAY
31128: DIFF
31129: ST_TO_ADDR
// if not list then
31130: LD_VAR 0 6
31134: NOT
31135: IFFALSE 31139
// continue ;
31137: GO 30512
// k := mc_mines [ i ] - mc_miners [ i ] ;
31139: LD_ADDR_VAR 0 4
31143: PUSH
31144: LD_EXP 63
31148: PUSH
31149: LD_VAR 0 2
31153: ARRAY
31154: PUSH
31155: LD_EXP 64
31159: PUSH
31160: LD_VAR 0 2
31164: ARRAY
31165: MINUS
31166: ST_TO_ADDR
// if k > list then
31167: LD_VAR 0 4
31171: PUSH
31172: LD_VAR 0 6
31176: GREATER
31177: IFFALSE 31189
// k := list ;
31179: LD_ADDR_VAR 0 4
31183: PUSH
31184: LD_VAR 0 6
31188: ST_TO_ADDR
// for j = 1 to k do
31189: LD_ADDR_VAR 0 3
31193: PUSH
31194: DOUBLE
31195: LD_INT 1
31197: DEC
31198: ST_TO_ADDR
31199: LD_VAR 0 4
31203: PUSH
31204: FOR_TO
31205: IFFALSE 31259
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31207: LD_ADDR_EXP 64
31211: PUSH
31212: LD_EXP 64
31216: PPUSH
31217: LD_VAR 0 2
31221: PUSH
31222: LD_EXP 64
31226: PUSH
31227: LD_VAR 0 2
31231: ARRAY
31232: PUSH
31233: LD_INT 1
31235: PLUS
31236: PUSH
31237: EMPTY
31238: LIST
31239: LIST
31240: PPUSH
31241: LD_VAR 0 6
31245: PUSH
31246: LD_VAR 0 3
31250: ARRAY
31251: PPUSH
31252: CALL 53785 0 3
31256: ST_TO_ADDR
31257: GO 31204
31259: POP
31260: POP
// end ;
31261: GO 30512
31263: POP
31264: POP
// end ;
31265: LD_VAR 0 1
31269: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31270: LD_INT 0
31272: PPUSH
31273: PPUSH
31274: PPUSH
31275: PPUSH
31276: PPUSH
31277: PPUSH
31278: PPUSH
31279: PPUSH
31280: PPUSH
31281: PPUSH
31282: PPUSH
// if not mc_bases then
31283: LD_EXP 50
31287: NOT
31288: IFFALSE 31292
// exit ;
31290: GO 33115
// for i = 1 to mc_bases do
31292: LD_ADDR_VAR 0 2
31296: PUSH
31297: DOUBLE
31298: LD_INT 1
31300: DEC
31301: ST_TO_ADDR
31302: LD_EXP 50
31306: PUSH
31307: FOR_TO
31308: IFFALSE 33113
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31310: LD_EXP 50
31314: PUSH
31315: LD_VAR 0 2
31319: ARRAY
31320: NOT
31321: PUSH
31322: LD_EXP 57
31326: PUSH
31327: LD_VAR 0 2
31331: ARRAY
31332: OR
31333: IFFALSE 31337
// continue ;
31335: GO 31307
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31337: LD_EXP 66
31341: PUSH
31342: LD_VAR 0 2
31346: ARRAY
31347: NOT
31348: PUSH
31349: LD_EXP 67
31353: PUSH
31354: LD_VAR 0 2
31358: ARRAY
31359: AND
31360: IFFALSE 31398
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31362: LD_ADDR_EXP 67
31366: PUSH
31367: LD_EXP 67
31371: PPUSH
31372: LD_VAR 0 2
31376: PPUSH
31377: EMPTY
31378: PPUSH
31379: CALL_OW 1
31383: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31384: LD_VAR 0 2
31388: PPUSH
31389: LD_INT 107
31391: PPUSH
31392: CALL 22145 0 2
// continue ;
31396: GO 31307
// end ; target := [ ] ;
31398: LD_ADDR_VAR 0 7
31402: PUSH
31403: EMPTY
31404: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31405: LD_ADDR_VAR 0 6
31409: PUSH
31410: LD_EXP 50
31414: PUSH
31415: LD_VAR 0 2
31419: ARRAY
31420: PUSH
31421: LD_INT 1
31423: ARRAY
31424: PPUSH
31425: CALL_OW 255
31429: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31430: LD_ADDR_VAR 0 9
31434: PUSH
31435: LD_EXP 50
31439: PUSH
31440: LD_VAR 0 2
31444: ARRAY
31445: PPUSH
31446: LD_INT 2
31448: PUSH
31449: LD_INT 30
31451: PUSH
31452: LD_INT 0
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 30
31461: PUSH
31462: LD_INT 1
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: LIST
31473: PPUSH
31474: CALL_OW 72
31478: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31479: LD_ADDR_VAR 0 3
31483: PUSH
31484: DOUBLE
31485: LD_EXP 66
31489: PUSH
31490: LD_VAR 0 2
31494: ARRAY
31495: INC
31496: ST_TO_ADDR
31497: LD_INT 1
31499: PUSH
31500: FOR_DOWNTO
31501: IFFALSE 31746
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31503: LD_EXP 66
31507: PUSH
31508: LD_VAR 0 2
31512: ARRAY
31513: PUSH
31514: LD_VAR 0 3
31518: ARRAY
31519: PUSH
31520: LD_INT 2
31522: ARRAY
31523: PPUSH
31524: LD_EXP 66
31528: PUSH
31529: LD_VAR 0 2
31533: ARRAY
31534: PUSH
31535: LD_VAR 0 3
31539: ARRAY
31540: PUSH
31541: LD_INT 3
31543: ARRAY
31544: PPUSH
31545: CALL_OW 488
31549: PUSH
31550: LD_EXP 66
31554: PUSH
31555: LD_VAR 0 2
31559: ARRAY
31560: PUSH
31561: LD_VAR 0 3
31565: ARRAY
31566: PUSH
31567: LD_INT 2
31569: ARRAY
31570: PPUSH
31571: LD_EXP 66
31575: PUSH
31576: LD_VAR 0 2
31580: ARRAY
31581: PUSH
31582: LD_VAR 0 3
31586: ARRAY
31587: PUSH
31588: LD_INT 3
31590: ARRAY
31591: PPUSH
31592: CALL_OW 284
31596: PUSH
31597: LD_INT 0
31599: EQUAL
31600: AND
31601: IFFALSE 31656
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31603: LD_ADDR_VAR 0 5
31607: PUSH
31608: LD_EXP 66
31612: PUSH
31613: LD_VAR 0 2
31617: ARRAY
31618: PPUSH
31619: LD_VAR 0 3
31623: PPUSH
31624: CALL_OW 3
31628: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31629: LD_ADDR_EXP 66
31633: PUSH
31634: LD_EXP 66
31638: PPUSH
31639: LD_VAR 0 2
31643: PPUSH
31644: LD_VAR 0 5
31648: PPUSH
31649: CALL_OW 1
31653: ST_TO_ADDR
// continue ;
31654: GO 31500
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31656: LD_VAR 0 6
31660: PPUSH
31661: LD_EXP 66
31665: PUSH
31666: LD_VAR 0 2
31670: ARRAY
31671: PUSH
31672: LD_VAR 0 3
31676: ARRAY
31677: PUSH
31678: LD_INT 2
31680: ARRAY
31681: PPUSH
31682: LD_EXP 66
31686: PUSH
31687: LD_VAR 0 2
31691: ARRAY
31692: PUSH
31693: LD_VAR 0 3
31697: ARRAY
31698: PUSH
31699: LD_INT 3
31701: ARRAY
31702: PPUSH
31703: LD_INT 30
31705: PPUSH
31706: CALL 54681 0 4
31710: PUSH
31711: LD_INT 4
31713: ARRAY
31714: PUSH
31715: LD_INT 0
31717: EQUAL
31718: IFFALSE 31744
// begin target := mc_crates [ i ] [ j ] ;
31720: LD_ADDR_VAR 0 7
31724: PUSH
31725: LD_EXP 66
31729: PUSH
31730: LD_VAR 0 2
31734: ARRAY
31735: PUSH
31736: LD_VAR 0 3
31740: ARRAY
31741: ST_TO_ADDR
// break ;
31742: GO 31746
// end ; end ;
31744: GO 31500
31746: POP
31747: POP
// if not target then
31748: LD_VAR 0 7
31752: NOT
31753: IFFALSE 31757
// continue ;
31755: GO 31307
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31757: LD_ADDR_VAR 0 8
31761: PUSH
31762: LD_EXP 69
31766: PUSH
31767: LD_VAR 0 2
31771: ARRAY
31772: PPUSH
31773: LD_INT 2
31775: PUSH
31776: LD_INT 3
31778: PUSH
31779: LD_INT 58
31781: PUSH
31782: EMPTY
31783: LIST
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: PUSH
31789: LD_INT 61
31791: PUSH
31792: EMPTY
31793: LIST
31794: PUSH
31795: LD_INT 33
31797: PUSH
31798: LD_INT 5
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PUSH
31805: LD_INT 33
31807: PUSH
31808: LD_INT 3
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: LIST
31819: LIST
31820: LIST
31821: PUSH
31822: LD_INT 2
31824: PUSH
31825: LD_INT 34
31827: PUSH
31828: LD_INT 32
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PUSH
31835: LD_INT 34
31837: PUSH
31838: LD_INT 51
31840: PUSH
31841: EMPTY
31842: LIST
31843: LIST
31844: PUSH
31845: LD_INT 34
31847: PUSH
31848: LD_INT 12
31850: PUSH
31851: EMPTY
31852: LIST
31853: LIST
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: LIST
31859: LIST
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PPUSH
31865: CALL_OW 72
31869: ST_TO_ADDR
// if not cargo then
31870: LD_VAR 0 8
31874: NOT
31875: IFFALSE 32581
// begin if mc_crates_collector [ i ] < 5 then
31877: LD_EXP 67
31881: PUSH
31882: LD_VAR 0 2
31886: ARRAY
31887: PUSH
31888: LD_INT 5
31890: LESS
31891: IFFALSE 32257
// begin if mc_ape [ i ] then
31893: LD_EXP 79
31897: PUSH
31898: LD_VAR 0 2
31902: ARRAY
31903: IFFALSE 31950
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31905: LD_ADDR_VAR 0 5
31909: PUSH
31910: LD_EXP 79
31914: PUSH
31915: LD_VAR 0 2
31919: ARRAY
31920: PPUSH
31921: LD_INT 25
31923: PUSH
31924: LD_INT 16
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 24
31933: PUSH
31934: LD_INT 750
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PPUSH
31945: CALL_OW 72
31949: ST_TO_ADDR
// if not tmp then
31950: LD_VAR 0 5
31954: NOT
31955: IFFALSE 32002
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31957: LD_ADDR_VAR 0 5
31961: PUSH
31962: LD_EXP 50
31966: PUSH
31967: LD_VAR 0 2
31971: ARRAY
31972: PPUSH
31973: LD_INT 25
31975: PUSH
31976: LD_INT 2
31978: PUSH
31979: EMPTY
31980: LIST
31981: LIST
31982: PUSH
31983: LD_INT 24
31985: PUSH
31986: LD_INT 750
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PPUSH
31997: CALL_OW 72
32001: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32002: LD_EXP 79
32006: PUSH
32007: LD_VAR 0 2
32011: ARRAY
32012: PUSH
32013: LD_EXP 50
32017: PUSH
32018: LD_VAR 0 2
32022: ARRAY
32023: PPUSH
32024: LD_INT 25
32026: PUSH
32027: LD_INT 2
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: LD_INT 24
32036: PUSH
32037: LD_INT 750
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: PUSH
32044: EMPTY
32045: LIST
32046: LIST
32047: PPUSH
32048: CALL_OW 72
32052: AND
32053: PUSH
32054: LD_VAR 0 5
32058: PUSH
32059: LD_INT 5
32061: LESS
32062: AND
32063: IFFALSE 32145
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32065: LD_ADDR_VAR 0 3
32069: PUSH
32070: LD_EXP 50
32074: PUSH
32075: LD_VAR 0 2
32079: ARRAY
32080: PPUSH
32081: LD_INT 25
32083: PUSH
32084: LD_INT 2
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PUSH
32091: LD_INT 24
32093: PUSH
32094: LD_INT 750
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: PPUSH
32105: CALL_OW 72
32109: PUSH
32110: FOR_IN
32111: IFFALSE 32143
// begin tmp := tmp union j ;
32113: LD_ADDR_VAR 0 5
32117: PUSH
32118: LD_VAR 0 5
32122: PUSH
32123: LD_VAR 0 3
32127: UNION
32128: ST_TO_ADDR
// if tmp >= 5 then
32129: LD_VAR 0 5
32133: PUSH
32134: LD_INT 5
32136: GREATEREQUAL
32137: IFFALSE 32141
// break ;
32139: GO 32143
// end ;
32141: GO 32110
32143: POP
32144: POP
// end ; if not tmp then
32145: LD_VAR 0 5
32149: NOT
32150: IFFALSE 32154
// continue ;
32152: GO 31307
// for j in tmp do
32154: LD_ADDR_VAR 0 3
32158: PUSH
32159: LD_VAR 0 5
32163: PUSH
32164: FOR_IN
32165: IFFALSE 32255
// if not GetTag ( j ) then
32167: LD_VAR 0 3
32171: PPUSH
32172: CALL_OW 110
32176: NOT
32177: IFFALSE 32253
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32179: LD_ADDR_EXP 67
32183: PUSH
32184: LD_EXP 67
32188: PPUSH
32189: LD_VAR 0 2
32193: PUSH
32194: LD_EXP 67
32198: PUSH
32199: LD_VAR 0 2
32203: ARRAY
32204: PUSH
32205: LD_INT 1
32207: PLUS
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PPUSH
32213: LD_VAR 0 3
32217: PPUSH
32218: CALL 53785 0 3
32222: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32223: LD_VAR 0 3
32227: PPUSH
32228: LD_INT 107
32230: PPUSH
32231: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32235: LD_EXP 67
32239: PUSH
32240: LD_VAR 0 2
32244: ARRAY
32245: PUSH
32246: LD_INT 5
32248: GREATEREQUAL
32249: IFFALSE 32253
// break ;
32251: GO 32255
// end ;
32253: GO 32164
32255: POP
32256: POP
// end ; if mc_crates_collector [ i ] and target then
32257: LD_EXP 67
32261: PUSH
32262: LD_VAR 0 2
32266: ARRAY
32267: PUSH
32268: LD_VAR 0 7
32272: AND
32273: IFFALSE 32579
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32275: LD_EXP 67
32279: PUSH
32280: LD_VAR 0 2
32284: ARRAY
32285: PUSH
32286: LD_VAR 0 7
32290: PUSH
32291: LD_INT 1
32293: ARRAY
32294: LESS
32295: IFFALSE 32315
// tmp := mc_crates_collector [ i ] else
32297: LD_ADDR_VAR 0 5
32301: PUSH
32302: LD_EXP 67
32306: PUSH
32307: LD_VAR 0 2
32311: ARRAY
32312: ST_TO_ADDR
32313: GO 32329
// tmp := target [ 1 ] ;
32315: LD_ADDR_VAR 0 5
32319: PUSH
32320: LD_VAR 0 7
32324: PUSH
32325: LD_INT 1
32327: ARRAY
32328: ST_TO_ADDR
// k := 0 ;
32329: LD_ADDR_VAR 0 4
32333: PUSH
32334: LD_INT 0
32336: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32337: LD_ADDR_VAR 0 3
32341: PUSH
32342: LD_EXP 67
32346: PUSH
32347: LD_VAR 0 2
32351: ARRAY
32352: PUSH
32353: FOR_IN
32354: IFFALSE 32577
// begin k := k + 1 ;
32356: LD_ADDR_VAR 0 4
32360: PUSH
32361: LD_VAR 0 4
32365: PUSH
32366: LD_INT 1
32368: PLUS
32369: ST_TO_ADDR
// if k > tmp then
32370: LD_VAR 0 4
32374: PUSH
32375: LD_VAR 0 5
32379: GREATER
32380: IFFALSE 32384
// break ;
32382: GO 32577
// if not GetClass ( j ) in [ 2 , 16 ] then
32384: LD_VAR 0 3
32388: PPUSH
32389: CALL_OW 257
32393: PUSH
32394: LD_INT 2
32396: PUSH
32397: LD_INT 16
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: IN
32404: NOT
32405: IFFALSE 32458
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32407: LD_ADDR_EXP 67
32411: PUSH
32412: LD_EXP 67
32416: PPUSH
32417: LD_VAR 0 2
32421: PPUSH
32422: LD_EXP 67
32426: PUSH
32427: LD_VAR 0 2
32431: ARRAY
32432: PUSH
32433: LD_VAR 0 3
32437: DIFF
32438: PPUSH
32439: CALL_OW 1
32443: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32444: LD_VAR 0 3
32448: PPUSH
32449: LD_INT 0
32451: PPUSH
32452: CALL_OW 109
// continue ;
32456: GO 32353
// end ; if IsInUnit ( j ) then
32458: LD_VAR 0 3
32462: PPUSH
32463: CALL_OW 310
32467: IFFALSE 32478
// ComExitBuilding ( j ) ;
32469: LD_VAR 0 3
32473: PPUSH
32474: CALL_OW 122
// wait ( 3 ) ;
32478: LD_INT 3
32480: PPUSH
32481: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32485: LD_VAR 0 3
32489: PPUSH
32490: CALL_OW 314
32494: PUSH
32495: LD_VAR 0 6
32499: PPUSH
32500: LD_VAR 0 7
32504: PUSH
32505: LD_INT 2
32507: ARRAY
32508: PPUSH
32509: LD_VAR 0 7
32513: PUSH
32514: LD_INT 3
32516: ARRAY
32517: PPUSH
32518: LD_INT 30
32520: PPUSH
32521: CALL 54681 0 4
32525: PUSH
32526: LD_INT 4
32528: ARRAY
32529: AND
32530: IFFALSE 32548
// ComStandNearbyBuilding ( j , depot ) else
32532: LD_VAR 0 3
32536: PPUSH
32537: LD_VAR 0 9
32541: PPUSH
32542: CALL 50212 0 2
32546: GO 32575
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32548: LD_VAR 0 3
32552: PPUSH
32553: LD_VAR 0 7
32557: PUSH
32558: LD_INT 2
32560: ARRAY
32561: PPUSH
32562: LD_VAR 0 7
32566: PUSH
32567: LD_INT 3
32569: ARRAY
32570: PPUSH
32571: CALL_OW 117
// end ;
32575: GO 32353
32577: POP
32578: POP
// end ; end else
32579: GO 33111
// begin for j in cargo do
32581: LD_ADDR_VAR 0 3
32585: PUSH
32586: LD_VAR 0 8
32590: PUSH
32591: FOR_IN
32592: IFFALSE 33109
// begin if GetTag ( j ) <> 0 then
32594: LD_VAR 0 3
32598: PPUSH
32599: CALL_OW 110
32603: PUSH
32604: LD_INT 0
32606: NONEQUAL
32607: IFFALSE 32611
// continue ;
32609: GO 32591
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32611: LD_VAR 0 3
32615: PPUSH
32616: CALL_OW 256
32620: PUSH
32621: LD_INT 1000
32623: LESS
32624: PUSH
32625: LD_VAR 0 3
32629: PPUSH
32630: LD_EXP 74
32634: PUSH
32635: LD_VAR 0 2
32639: ARRAY
32640: PPUSH
32641: CALL_OW 308
32645: NOT
32646: AND
32647: IFFALSE 32669
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32649: LD_VAR 0 3
32653: PPUSH
32654: LD_EXP 74
32658: PUSH
32659: LD_VAR 0 2
32663: ARRAY
32664: PPUSH
32665: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32669: LD_VAR 0 3
32673: PPUSH
32674: CALL_OW 256
32678: PUSH
32679: LD_INT 1000
32681: LESS
32682: PUSH
32683: LD_VAR 0 3
32687: PPUSH
32688: LD_EXP 74
32692: PUSH
32693: LD_VAR 0 2
32697: ARRAY
32698: PPUSH
32699: CALL_OW 308
32703: AND
32704: IFFALSE 32708
// continue ;
32706: GO 32591
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32708: LD_VAR 0 3
32712: PPUSH
32713: CALL_OW 262
32717: PUSH
32718: LD_INT 2
32720: EQUAL
32721: PUSH
32722: LD_VAR 0 3
32726: PPUSH
32727: CALL_OW 261
32731: PUSH
32732: LD_INT 15
32734: LESS
32735: AND
32736: IFFALSE 32740
// continue ;
32738: GO 32591
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32740: LD_VAR 0 3
32744: PPUSH
32745: CALL_OW 262
32749: PUSH
32750: LD_INT 1
32752: EQUAL
32753: PUSH
32754: LD_VAR 0 3
32758: PPUSH
32759: CALL_OW 261
32763: PUSH
32764: LD_INT 10
32766: LESS
32767: AND
32768: IFFALSE 33048
// begin if not depot then
32770: LD_VAR 0 9
32774: NOT
32775: IFFALSE 32779
// continue ;
32777: GO 32591
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32779: LD_VAR 0 3
32783: PPUSH
32784: LD_VAR 0 9
32788: PPUSH
32789: LD_VAR 0 3
32793: PPUSH
32794: CALL_OW 74
32798: PPUSH
32799: CALL_OW 296
32803: PUSH
32804: LD_INT 6
32806: LESS
32807: IFFALSE 32823
// SetFuel ( j , 100 ) else
32809: LD_VAR 0 3
32813: PPUSH
32814: LD_INT 100
32816: PPUSH
32817: CALL_OW 240
32821: GO 33048
// if GetFuel ( j ) = 0 then
32823: LD_VAR 0 3
32827: PPUSH
32828: CALL_OW 261
32832: PUSH
32833: LD_INT 0
32835: EQUAL
32836: IFFALSE 33048
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32838: LD_ADDR_EXP 69
32842: PUSH
32843: LD_EXP 69
32847: PPUSH
32848: LD_VAR 0 2
32852: PPUSH
32853: LD_EXP 69
32857: PUSH
32858: LD_VAR 0 2
32862: ARRAY
32863: PUSH
32864: LD_VAR 0 3
32868: DIFF
32869: PPUSH
32870: CALL_OW 1
32874: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32875: LD_VAR 0 3
32879: PPUSH
32880: CALL_OW 263
32884: PUSH
32885: LD_INT 1
32887: EQUAL
32888: IFFALSE 32904
// ComExitVehicle ( IsInUnit ( j ) ) ;
32890: LD_VAR 0 3
32894: PPUSH
32895: CALL_OW 310
32899: PPUSH
32900: CALL_OW 121
// if GetControl ( j ) = control_remote then
32904: LD_VAR 0 3
32908: PPUSH
32909: CALL_OW 263
32913: PUSH
32914: LD_INT 2
32916: EQUAL
32917: IFFALSE 32928
// ComUnlink ( j ) ;
32919: LD_VAR 0 3
32923: PPUSH
32924: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32928: LD_ADDR_VAR 0 10
32932: PUSH
32933: LD_VAR 0 2
32937: PPUSH
32938: LD_INT 3
32940: PPUSH
32941: CALL 42715 0 2
32945: ST_TO_ADDR
// if fac then
32946: LD_VAR 0 10
32950: IFFALSE 33046
// begin for k in fac do
32952: LD_ADDR_VAR 0 4
32956: PUSH
32957: LD_VAR 0 10
32961: PUSH
32962: FOR_IN
32963: IFFALSE 33044
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32965: LD_ADDR_VAR 0 11
32969: PUSH
32970: LD_VAR 0 10
32974: PPUSH
32975: LD_VAR 0 3
32979: PPUSH
32980: CALL_OW 265
32984: PPUSH
32985: LD_VAR 0 3
32989: PPUSH
32990: CALL_OW 262
32994: PPUSH
32995: LD_VAR 0 3
32999: PPUSH
33000: CALL_OW 263
33004: PPUSH
33005: LD_VAR 0 3
33009: PPUSH
33010: CALL_OW 264
33014: PPUSH
33015: CALL 51283 0 5
33019: ST_TO_ADDR
// if components then
33020: LD_VAR 0 11
33024: IFFALSE 33042
// begin MC_InsertProduceList ( i , components ) ;
33026: LD_VAR 0 2
33030: PPUSH
33031: LD_VAR 0 11
33035: PPUSH
33036: CALL 42260 0 2
// break ;
33040: GO 33044
// end ; end ;
33042: GO 32962
33044: POP
33045: POP
// end ; continue ;
33046: GO 32591
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33048: LD_VAR 0 3
33052: PPUSH
33053: LD_INT 1
33055: PPUSH
33056: CALL_OW 289
33060: PUSH
33061: LD_INT 100
33063: LESS
33064: PUSH
33065: LD_VAR 0 3
33069: PPUSH
33070: CALL_OW 314
33074: NOT
33075: AND
33076: IFFALSE 33105
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33078: LD_VAR 0 3
33082: PPUSH
33083: LD_VAR 0 7
33087: PUSH
33088: LD_INT 2
33090: ARRAY
33091: PPUSH
33092: LD_VAR 0 7
33096: PUSH
33097: LD_INT 3
33099: ARRAY
33100: PPUSH
33101: CALL_OW 117
// break ;
33105: GO 33109
// end ;
33107: GO 32591
33109: POP
33110: POP
// end ; end ;
33111: GO 31307
33113: POP
33114: POP
// end ;
33115: LD_VAR 0 1
33119: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33120: LD_INT 0
33122: PPUSH
33123: PPUSH
33124: PPUSH
33125: PPUSH
// if not mc_bases then
33126: LD_EXP 50
33130: NOT
33131: IFFALSE 33135
// exit ;
33133: GO 33296
// for i = 1 to mc_bases do
33135: LD_ADDR_VAR 0 2
33139: PUSH
33140: DOUBLE
33141: LD_INT 1
33143: DEC
33144: ST_TO_ADDR
33145: LD_EXP 50
33149: PUSH
33150: FOR_TO
33151: IFFALSE 33294
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33153: LD_ADDR_VAR 0 4
33157: PUSH
33158: LD_EXP 69
33162: PUSH
33163: LD_VAR 0 2
33167: ARRAY
33168: PUSH
33169: LD_EXP 72
33173: PUSH
33174: LD_VAR 0 2
33178: ARRAY
33179: UNION
33180: PPUSH
33181: LD_INT 33
33183: PUSH
33184: LD_INT 2
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PPUSH
33191: CALL_OW 72
33195: ST_TO_ADDR
// if tmp then
33196: LD_VAR 0 4
33200: IFFALSE 33292
// for j in tmp do
33202: LD_ADDR_VAR 0 3
33206: PUSH
33207: LD_VAR 0 4
33211: PUSH
33212: FOR_IN
33213: IFFALSE 33290
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33215: LD_VAR 0 3
33219: PPUSH
33220: CALL_OW 312
33224: NOT
33225: PUSH
33226: LD_VAR 0 3
33230: PPUSH
33231: CALL_OW 256
33235: PUSH
33236: LD_INT 250
33238: GREATEREQUAL
33239: AND
33240: IFFALSE 33253
// Connect ( j ) else
33242: LD_VAR 0 3
33246: PPUSH
33247: CALL 56754 0 1
33251: GO 33288
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33253: LD_VAR 0 3
33257: PPUSH
33258: CALL_OW 256
33262: PUSH
33263: LD_INT 250
33265: LESS
33266: PUSH
33267: LD_VAR 0 3
33271: PPUSH
33272: CALL_OW 312
33276: AND
33277: IFFALSE 33288
// ComUnlink ( j ) ;
33279: LD_VAR 0 3
33283: PPUSH
33284: CALL_OW 136
33288: GO 33212
33290: POP
33291: POP
// end ;
33292: GO 33150
33294: POP
33295: POP
// end ;
33296: LD_VAR 0 1
33300: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33301: LD_INT 0
33303: PPUSH
33304: PPUSH
33305: PPUSH
33306: PPUSH
33307: PPUSH
// if not mc_bases then
33308: LD_EXP 50
33312: NOT
33313: IFFALSE 33317
// exit ;
33315: GO 33762
// for i = 1 to mc_bases do
33317: LD_ADDR_VAR 0 2
33321: PUSH
33322: DOUBLE
33323: LD_INT 1
33325: DEC
33326: ST_TO_ADDR
33327: LD_EXP 50
33331: PUSH
33332: FOR_TO
33333: IFFALSE 33760
// begin if not mc_produce [ i ] then
33335: LD_EXP 71
33339: PUSH
33340: LD_VAR 0 2
33344: ARRAY
33345: NOT
33346: IFFALSE 33350
// continue ;
33348: GO 33332
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33350: LD_ADDR_VAR 0 5
33354: PUSH
33355: LD_EXP 50
33359: PUSH
33360: LD_VAR 0 2
33364: ARRAY
33365: PPUSH
33366: LD_INT 30
33368: PUSH
33369: LD_INT 3
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: PPUSH
33376: CALL_OW 72
33380: ST_TO_ADDR
// if not fac then
33381: LD_VAR 0 5
33385: NOT
33386: IFFALSE 33390
// continue ;
33388: GO 33332
// for j in fac do
33390: LD_ADDR_VAR 0 3
33394: PUSH
33395: LD_VAR 0 5
33399: PUSH
33400: FOR_IN
33401: IFFALSE 33756
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33403: LD_VAR 0 3
33407: PPUSH
33408: CALL_OW 461
33412: PUSH
33413: LD_INT 2
33415: NONEQUAL
33416: PUSH
33417: LD_VAR 0 3
33421: PPUSH
33422: LD_INT 15
33424: PPUSH
33425: CALL 56382 0 2
33429: PUSH
33430: LD_INT 4
33432: ARRAY
33433: OR
33434: IFFALSE 33438
// continue ;
33436: GO 33400
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33438: LD_VAR 0 3
33442: PPUSH
33443: LD_EXP 71
33447: PUSH
33448: LD_VAR 0 2
33452: ARRAY
33453: PUSH
33454: LD_INT 1
33456: ARRAY
33457: PUSH
33458: LD_INT 1
33460: ARRAY
33461: PPUSH
33462: LD_EXP 71
33466: PUSH
33467: LD_VAR 0 2
33471: ARRAY
33472: PUSH
33473: LD_INT 1
33475: ARRAY
33476: PUSH
33477: LD_INT 2
33479: ARRAY
33480: PPUSH
33481: LD_EXP 71
33485: PUSH
33486: LD_VAR 0 2
33490: ARRAY
33491: PUSH
33492: LD_INT 1
33494: ARRAY
33495: PUSH
33496: LD_INT 3
33498: ARRAY
33499: PPUSH
33500: LD_EXP 71
33504: PUSH
33505: LD_VAR 0 2
33509: ARRAY
33510: PUSH
33511: LD_INT 1
33513: ARRAY
33514: PUSH
33515: LD_INT 4
33517: ARRAY
33518: PPUSH
33519: CALL_OW 448
33523: PUSH
33524: LD_VAR 0 3
33528: PPUSH
33529: LD_EXP 71
33533: PUSH
33534: LD_VAR 0 2
33538: ARRAY
33539: PUSH
33540: LD_INT 1
33542: ARRAY
33543: PUSH
33544: LD_INT 1
33546: ARRAY
33547: PUSH
33548: LD_EXP 71
33552: PUSH
33553: LD_VAR 0 2
33557: ARRAY
33558: PUSH
33559: LD_INT 1
33561: ARRAY
33562: PUSH
33563: LD_INT 2
33565: ARRAY
33566: PUSH
33567: LD_EXP 71
33571: PUSH
33572: LD_VAR 0 2
33576: ARRAY
33577: PUSH
33578: LD_INT 1
33580: ARRAY
33581: PUSH
33582: LD_INT 3
33584: ARRAY
33585: PUSH
33586: LD_EXP 71
33590: PUSH
33591: LD_VAR 0 2
33595: ARRAY
33596: PUSH
33597: LD_INT 1
33599: ARRAY
33600: PUSH
33601: LD_INT 4
33603: ARRAY
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: PPUSH
33611: CALL 60149 0 2
33615: AND
33616: IFFALSE 33754
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33618: LD_VAR 0 3
33622: PPUSH
33623: LD_EXP 71
33627: PUSH
33628: LD_VAR 0 2
33632: ARRAY
33633: PUSH
33634: LD_INT 1
33636: ARRAY
33637: PUSH
33638: LD_INT 1
33640: ARRAY
33641: PPUSH
33642: LD_EXP 71
33646: PUSH
33647: LD_VAR 0 2
33651: ARRAY
33652: PUSH
33653: LD_INT 1
33655: ARRAY
33656: PUSH
33657: LD_INT 2
33659: ARRAY
33660: PPUSH
33661: LD_EXP 71
33665: PUSH
33666: LD_VAR 0 2
33670: ARRAY
33671: PUSH
33672: LD_INT 1
33674: ARRAY
33675: PUSH
33676: LD_INT 3
33678: ARRAY
33679: PPUSH
33680: LD_EXP 71
33684: PUSH
33685: LD_VAR 0 2
33689: ARRAY
33690: PUSH
33691: LD_INT 1
33693: ARRAY
33694: PUSH
33695: LD_INT 4
33697: ARRAY
33698: PPUSH
33699: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33703: LD_ADDR_VAR 0 4
33707: PUSH
33708: LD_EXP 71
33712: PUSH
33713: LD_VAR 0 2
33717: ARRAY
33718: PPUSH
33719: LD_INT 1
33721: PPUSH
33722: CALL_OW 3
33726: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33727: LD_ADDR_EXP 71
33731: PUSH
33732: LD_EXP 71
33736: PPUSH
33737: LD_VAR 0 2
33741: PPUSH
33742: LD_VAR 0 4
33746: PPUSH
33747: CALL_OW 1
33751: ST_TO_ADDR
// break ;
33752: GO 33756
// end ; end ;
33754: GO 33400
33756: POP
33757: POP
// end ;
33758: GO 33332
33760: POP
33761: POP
// end ;
33762: LD_VAR 0 1
33766: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33767: LD_INT 0
33769: PPUSH
33770: PPUSH
33771: PPUSH
// if not mc_bases then
33772: LD_EXP 50
33776: NOT
33777: IFFALSE 33781
// exit ;
33779: GO 33870
// for i = 1 to mc_bases do
33781: LD_ADDR_VAR 0 2
33785: PUSH
33786: DOUBLE
33787: LD_INT 1
33789: DEC
33790: ST_TO_ADDR
33791: LD_EXP 50
33795: PUSH
33796: FOR_TO
33797: IFFALSE 33868
// begin if mc_attack [ i ] then
33799: LD_EXP 70
33803: PUSH
33804: LD_VAR 0 2
33808: ARRAY
33809: IFFALSE 33866
// begin tmp := mc_attack [ i ] [ 1 ] ;
33811: LD_ADDR_VAR 0 3
33815: PUSH
33816: LD_EXP 70
33820: PUSH
33821: LD_VAR 0 2
33825: ARRAY
33826: PUSH
33827: LD_INT 1
33829: ARRAY
33830: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33831: LD_ADDR_EXP 70
33835: PUSH
33836: LD_EXP 70
33840: PPUSH
33841: LD_VAR 0 2
33845: PPUSH
33846: EMPTY
33847: PPUSH
33848: CALL_OW 1
33852: ST_TO_ADDR
// Attack ( tmp ) ;
33853: LD_VAR 0 3
33857: PPUSH
33858: CALL 110157 0 1
// exit ;
33862: POP
33863: POP
33864: GO 33870
// end ; end ;
33866: GO 33796
33868: POP
33869: POP
// end ;
33870: LD_VAR 0 1
33874: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33875: LD_INT 0
33877: PPUSH
33878: PPUSH
33879: PPUSH
33880: PPUSH
33881: PPUSH
33882: PPUSH
33883: PPUSH
// if not mc_bases then
33884: LD_EXP 50
33888: NOT
33889: IFFALSE 33893
// exit ;
33891: GO 34750
// for i = 1 to mc_bases do
33893: LD_ADDR_VAR 0 2
33897: PUSH
33898: DOUBLE
33899: LD_INT 1
33901: DEC
33902: ST_TO_ADDR
33903: LD_EXP 50
33907: PUSH
33908: FOR_TO
33909: IFFALSE 34748
// begin if not mc_bases [ i ] then
33911: LD_EXP 50
33915: PUSH
33916: LD_VAR 0 2
33920: ARRAY
33921: NOT
33922: IFFALSE 33926
// continue ;
33924: GO 33908
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33926: LD_ADDR_VAR 0 7
33930: PUSH
33931: LD_EXP 50
33935: PUSH
33936: LD_VAR 0 2
33940: ARRAY
33941: PUSH
33942: LD_INT 1
33944: ARRAY
33945: PPUSH
33946: CALL 50434 0 1
33950: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33951: LD_ADDR_EXP 73
33955: PUSH
33956: LD_EXP 73
33960: PPUSH
33961: LD_VAR 0 2
33965: PPUSH
33966: LD_EXP 50
33970: PUSH
33971: LD_VAR 0 2
33975: ARRAY
33976: PUSH
33977: LD_INT 1
33979: ARRAY
33980: PPUSH
33981: CALL_OW 255
33985: PPUSH
33986: LD_EXP 75
33990: PUSH
33991: LD_VAR 0 2
33995: ARRAY
33996: PPUSH
33997: CALL 50399 0 2
34001: PPUSH
34002: CALL_OW 1
34006: ST_TO_ADDR
// if not mc_scan [ i ] then
34007: LD_EXP 73
34011: PUSH
34012: LD_VAR 0 2
34016: ARRAY
34017: NOT
34018: IFFALSE 34196
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34020: LD_ADDR_EXP 93
34024: PUSH
34025: LD_EXP 93
34029: PPUSH
34030: LD_VAR 0 2
34034: PPUSH
34035: LD_INT 0
34037: PPUSH
34038: CALL_OW 1
34042: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34043: LD_ADDR_VAR 0 4
34047: PUSH
34048: LD_EXP 50
34052: PUSH
34053: LD_VAR 0 2
34057: ARRAY
34058: PPUSH
34059: LD_INT 2
34061: PUSH
34062: LD_INT 25
34064: PUSH
34065: LD_INT 5
34067: PUSH
34068: EMPTY
34069: LIST
34070: LIST
34071: PUSH
34072: LD_INT 25
34074: PUSH
34075: LD_INT 8
34077: PUSH
34078: EMPTY
34079: LIST
34080: LIST
34081: PUSH
34082: LD_INT 25
34084: PUSH
34085: LD_INT 9
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: LIST
34096: LIST
34097: PPUSH
34098: CALL_OW 72
34102: ST_TO_ADDR
// if not tmp then
34103: LD_VAR 0 4
34107: NOT
34108: IFFALSE 34112
// continue ;
34110: GO 33908
// for j in tmp do
34112: LD_ADDR_VAR 0 3
34116: PUSH
34117: LD_VAR 0 4
34121: PUSH
34122: FOR_IN
34123: IFFALSE 34194
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34125: LD_VAR 0 3
34129: PPUSH
34130: CALL_OW 310
34134: PPUSH
34135: CALL_OW 266
34139: PUSH
34140: LD_INT 5
34142: EQUAL
34143: PUSH
34144: LD_VAR 0 3
34148: PPUSH
34149: CALL_OW 257
34153: PUSH
34154: LD_INT 1
34156: EQUAL
34157: AND
34158: PUSH
34159: LD_VAR 0 3
34163: PPUSH
34164: CALL_OW 459
34168: NOT
34169: AND
34170: PUSH
34171: LD_VAR 0 7
34175: AND
34176: IFFALSE 34192
// ComChangeProfession ( j , class ) ;
34178: LD_VAR 0 3
34182: PPUSH
34183: LD_VAR 0 7
34187: PPUSH
34188: CALL_OW 123
34192: GO 34122
34194: POP
34195: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34196: LD_EXP 73
34200: PUSH
34201: LD_VAR 0 2
34205: ARRAY
34206: PUSH
34207: LD_EXP 93
34211: PUSH
34212: LD_VAR 0 2
34216: ARRAY
34217: NOT
34218: AND
34219: PUSH
34220: LD_EXP 72
34224: PUSH
34225: LD_VAR 0 2
34229: ARRAY
34230: NOT
34231: AND
34232: PUSH
34233: LD_EXP 50
34237: PUSH
34238: LD_VAR 0 2
34242: ARRAY
34243: PPUSH
34244: LD_INT 50
34246: PUSH
34247: EMPTY
34248: LIST
34249: PUSH
34250: LD_INT 2
34252: PUSH
34253: LD_INT 30
34255: PUSH
34256: LD_INT 32
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 30
34265: PUSH
34266: LD_INT 33
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: PUSH
34273: LD_INT 30
34275: PUSH
34276: LD_INT 4
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 30
34285: PUSH
34286: LD_INT 5
34288: PUSH
34289: EMPTY
34290: LIST
34291: LIST
34292: PUSH
34293: EMPTY
34294: LIST
34295: LIST
34296: LIST
34297: LIST
34298: LIST
34299: PUSH
34300: EMPTY
34301: LIST
34302: LIST
34303: PPUSH
34304: CALL_OW 72
34308: PUSH
34309: LD_INT 4
34311: LESS
34312: PUSH
34313: LD_EXP 50
34317: PUSH
34318: LD_VAR 0 2
34322: ARRAY
34323: PPUSH
34324: LD_INT 3
34326: PUSH
34327: LD_INT 24
34329: PUSH
34330: LD_INT 1000
34332: PUSH
34333: EMPTY
34334: LIST
34335: LIST
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: LD_INT 2
34343: PUSH
34344: LD_INT 30
34346: PUSH
34347: LD_INT 0
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 30
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: LIST
34368: PUSH
34369: EMPTY
34370: LIST
34371: LIST
34372: PPUSH
34373: CALL_OW 72
34377: OR
34378: AND
34379: IFFALSE 34630
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34381: LD_ADDR_EXP 93
34385: PUSH
34386: LD_EXP 93
34390: PPUSH
34391: LD_VAR 0 2
34395: PPUSH
34396: LD_INT 1
34398: PPUSH
34399: CALL_OW 1
34403: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34404: LD_ADDR_VAR 0 4
34408: PUSH
34409: LD_EXP 50
34413: PUSH
34414: LD_VAR 0 2
34418: ARRAY
34419: PPUSH
34420: LD_INT 2
34422: PUSH
34423: LD_INT 25
34425: PUSH
34426: LD_INT 1
34428: PUSH
34429: EMPTY
34430: LIST
34431: LIST
34432: PUSH
34433: LD_INT 25
34435: PUSH
34436: LD_INT 5
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: PUSH
34443: LD_INT 25
34445: PUSH
34446: LD_INT 8
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 25
34455: PUSH
34456: LD_INT 9
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: LIST
34467: LIST
34468: LIST
34469: PPUSH
34470: CALL_OW 72
34474: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34475: LD_ADDR_VAR 0 4
34479: PUSH
34480: LD_VAR 0 4
34484: PUSH
34485: LD_VAR 0 4
34489: PPUSH
34490: LD_INT 18
34492: PPUSH
34493: CALL 83697 0 2
34497: DIFF
34498: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34499: LD_VAR 0 4
34503: NOT
34504: PUSH
34505: LD_EXP 50
34509: PUSH
34510: LD_VAR 0 2
34514: ARRAY
34515: PPUSH
34516: LD_INT 2
34518: PUSH
34519: LD_INT 30
34521: PUSH
34522: LD_INT 4
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: PUSH
34529: LD_INT 30
34531: PUSH
34532: LD_INT 5
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: LIST
34543: PPUSH
34544: CALL_OW 72
34548: NOT
34549: AND
34550: IFFALSE 34612
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34552: LD_ADDR_VAR 0 4
34556: PUSH
34557: LD_EXP 50
34561: PUSH
34562: LD_VAR 0 2
34566: ARRAY
34567: PPUSH
34568: LD_INT 2
34570: PUSH
34571: LD_INT 25
34573: PUSH
34574: LD_INT 2
34576: PUSH
34577: EMPTY
34578: LIST
34579: LIST
34580: PUSH
34581: LD_INT 25
34583: PUSH
34584: LD_INT 3
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 25
34593: PUSH
34594: LD_INT 4
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: LIST
34605: LIST
34606: PPUSH
34607: CALL_OW 72
34611: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34612: LD_VAR 0 2
34616: PPUSH
34617: LD_VAR 0 4
34621: PPUSH
34622: CALL 114866 0 2
// exit ;
34626: POP
34627: POP
34628: GO 34750
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34630: LD_EXP 73
34634: PUSH
34635: LD_VAR 0 2
34639: ARRAY
34640: PUSH
34641: LD_EXP 93
34645: PUSH
34646: LD_VAR 0 2
34650: ARRAY
34651: NOT
34652: AND
34653: PUSH
34654: LD_EXP 72
34658: PUSH
34659: LD_VAR 0 2
34663: ARRAY
34664: AND
34665: IFFALSE 34746
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34667: LD_ADDR_EXP 93
34671: PUSH
34672: LD_EXP 93
34676: PPUSH
34677: LD_VAR 0 2
34681: PPUSH
34682: LD_INT 1
34684: PPUSH
34685: CALL_OW 1
34689: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34690: LD_ADDR_VAR 0 4
34694: PUSH
34695: LD_EXP 72
34699: PUSH
34700: LD_VAR 0 2
34704: ARRAY
34705: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34706: LD_ADDR_EXP 72
34710: PUSH
34711: LD_EXP 72
34715: PPUSH
34716: LD_VAR 0 2
34720: PPUSH
34721: EMPTY
34722: PPUSH
34723: CALL_OW 1
34727: ST_TO_ADDR
// Defend ( i , tmp ) ;
34728: LD_VAR 0 2
34732: PPUSH
34733: LD_VAR 0 4
34737: PPUSH
34738: CALL 115462 0 2
// exit ;
34742: POP
34743: POP
34744: GO 34750
// end ; end ;
34746: GO 33908
34748: POP
34749: POP
// end ;
34750: LD_VAR 0 1
34754: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34755: LD_INT 0
34757: PPUSH
34758: PPUSH
34759: PPUSH
34760: PPUSH
34761: PPUSH
34762: PPUSH
34763: PPUSH
34764: PPUSH
34765: PPUSH
34766: PPUSH
34767: PPUSH
// if not mc_bases then
34768: LD_EXP 50
34772: NOT
34773: IFFALSE 34777
// exit ;
34775: GO 35864
// for i = 1 to mc_bases do
34777: LD_ADDR_VAR 0 2
34781: PUSH
34782: DOUBLE
34783: LD_INT 1
34785: DEC
34786: ST_TO_ADDR
34787: LD_EXP 50
34791: PUSH
34792: FOR_TO
34793: IFFALSE 35862
// begin tmp := mc_lab [ i ] ;
34795: LD_ADDR_VAR 0 6
34799: PUSH
34800: LD_EXP 83
34804: PUSH
34805: LD_VAR 0 2
34809: ARRAY
34810: ST_TO_ADDR
// if not tmp then
34811: LD_VAR 0 6
34815: NOT
34816: IFFALSE 34820
// continue ;
34818: GO 34792
// idle_lab := 0 ;
34820: LD_ADDR_VAR 0 11
34824: PUSH
34825: LD_INT 0
34827: ST_TO_ADDR
// for j in tmp do
34828: LD_ADDR_VAR 0 3
34832: PUSH
34833: LD_VAR 0 6
34837: PUSH
34838: FOR_IN
34839: IFFALSE 35858
// begin researching := false ;
34841: LD_ADDR_VAR 0 10
34845: PUSH
34846: LD_INT 0
34848: ST_TO_ADDR
// side := GetSide ( j ) ;
34849: LD_ADDR_VAR 0 4
34853: PUSH
34854: LD_VAR 0 3
34858: PPUSH
34859: CALL_OW 255
34863: ST_TO_ADDR
// if not mc_tech [ side ] then
34864: LD_EXP 77
34868: PUSH
34869: LD_VAR 0 4
34873: ARRAY
34874: NOT
34875: IFFALSE 34879
// continue ;
34877: GO 34838
// if BuildingStatus ( j ) = bs_idle then
34879: LD_VAR 0 3
34883: PPUSH
34884: CALL_OW 461
34888: PUSH
34889: LD_INT 2
34891: EQUAL
34892: IFFALSE 35080
// begin if idle_lab and UnitsInside ( j ) < 6 then
34894: LD_VAR 0 11
34898: PUSH
34899: LD_VAR 0 3
34903: PPUSH
34904: CALL_OW 313
34908: PUSH
34909: LD_INT 6
34911: LESS
34912: AND
34913: IFFALSE 34984
// begin tmp2 := UnitsInside ( idle_lab ) ;
34915: LD_ADDR_VAR 0 9
34919: PUSH
34920: LD_VAR 0 11
34924: PPUSH
34925: CALL_OW 313
34929: ST_TO_ADDR
// if tmp2 then
34930: LD_VAR 0 9
34934: IFFALSE 34976
// for x in tmp2 do
34936: LD_ADDR_VAR 0 7
34940: PUSH
34941: LD_VAR 0 9
34945: PUSH
34946: FOR_IN
34947: IFFALSE 34974
// begin ComExitBuilding ( x ) ;
34949: LD_VAR 0 7
34953: PPUSH
34954: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34958: LD_VAR 0 7
34962: PPUSH
34963: LD_VAR 0 3
34967: PPUSH
34968: CALL_OW 180
// end ;
34972: GO 34946
34974: POP
34975: POP
// idle_lab := 0 ;
34976: LD_ADDR_VAR 0 11
34980: PUSH
34981: LD_INT 0
34983: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34984: LD_ADDR_VAR 0 5
34988: PUSH
34989: LD_EXP 77
34993: PUSH
34994: LD_VAR 0 4
34998: ARRAY
34999: PUSH
35000: FOR_IN
35001: IFFALSE 35061
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35003: LD_VAR 0 3
35007: PPUSH
35008: LD_VAR 0 5
35012: PPUSH
35013: CALL_OW 430
35017: PUSH
35018: LD_VAR 0 4
35022: PPUSH
35023: LD_VAR 0 5
35027: PPUSH
35028: CALL 49504 0 2
35032: AND
35033: IFFALSE 35059
// begin researching := true ;
35035: LD_ADDR_VAR 0 10
35039: PUSH
35040: LD_INT 1
35042: ST_TO_ADDR
// ComResearch ( j , t ) ;
35043: LD_VAR 0 3
35047: PPUSH
35048: LD_VAR 0 5
35052: PPUSH
35053: CALL_OW 124
// break ;
35057: GO 35061
// end ;
35059: GO 35000
35061: POP
35062: POP
// if not researching then
35063: LD_VAR 0 10
35067: NOT
35068: IFFALSE 35080
// idle_lab := j ;
35070: LD_ADDR_VAR 0 11
35074: PUSH
35075: LD_VAR 0 3
35079: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35080: LD_VAR 0 3
35084: PPUSH
35085: CALL_OW 461
35089: PUSH
35090: LD_INT 10
35092: EQUAL
35093: IFFALSE 35681
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35095: LD_EXP 79
35099: PUSH
35100: LD_VAR 0 2
35104: ARRAY
35105: NOT
35106: PUSH
35107: LD_EXP 80
35111: PUSH
35112: LD_VAR 0 2
35116: ARRAY
35117: NOT
35118: AND
35119: PUSH
35120: LD_EXP 77
35124: PUSH
35125: LD_VAR 0 4
35129: ARRAY
35130: PUSH
35131: LD_INT 1
35133: GREATER
35134: AND
35135: IFFALSE 35266
// begin ComCancel ( j ) ;
35137: LD_VAR 0 3
35141: PPUSH
35142: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35146: LD_ADDR_EXP 77
35150: PUSH
35151: LD_EXP 77
35155: PPUSH
35156: LD_VAR 0 4
35160: PPUSH
35161: LD_EXP 77
35165: PUSH
35166: LD_VAR 0 4
35170: ARRAY
35171: PPUSH
35172: LD_EXP 77
35176: PUSH
35177: LD_VAR 0 4
35181: ARRAY
35182: PUSH
35183: LD_INT 1
35185: MINUS
35186: PPUSH
35187: LD_EXP 77
35191: PUSH
35192: LD_VAR 0 4
35196: ARRAY
35197: PPUSH
35198: LD_INT 0
35200: PPUSH
35201: CALL 53203 0 4
35205: PPUSH
35206: CALL_OW 1
35210: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35211: LD_ADDR_EXP 77
35215: PUSH
35216: LD_EXP 77
35220: PPUSH
35221: LD_VAR 0 4
35225: PPUSH
35226: LD_EXP 77
35230: PUSH
35231: LD_VAR 0 4
35235: ARRAY
35236: PPUSH
35237: LD_EXP 77
35241: PUSH
35242: LD_VAR 0 4
35246: ARRAY
35247: PPUSH
35248: LD_INT 1
35250: PPUSH
35251: LD_INT 0
35253: PPUSH
35254: CALL 53203 0 4
35258: PPUSH
35259: CALL_OW 1
35263: ST_TO_ADDR
// continue ;
35264: GO 34838
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35266: LD_EXP 79
35270: PUSH
35271: LD_VAR 0 2
35275: ARRAY
35276: PUSH
35277: LD_EXP 80
35281: PUSH
35282: LD_VAR 0 2
35286: ARRAY
35287: NOT
35288: AND
35289: IFFALSE 35416
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35291: LD_ADDR_EXP 80
35295: PUSH
35296: LD_EXP 80
35300: PPUSH
35301: LD_VAR 0 2
35305: PUSH
35306: LD_EXP 80
35310: PUSH
35311: LD_VAR 0 2
35315: ARRAY
35316: PUSH
35317: LD_INT 1
35319: PLUS
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PPUSH
35325: LD_EXP 79
35329: PUSH
35330: LD_VAR 0 2
35334: ARRAY
35335: PUSH
35336: LD_INT 1
35338: ARRAY
35339: PPUSH
35340: CALL 53785 0 3
35344: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35345: LD_EXP 79
35349: PUSH
35350: LD_VAR 0 2
35354: ARRAY
35355: PUSH
35356: LD_INT 1
35358: ARRAY
35359: PPUSH
35360: LD_INT 112
35362: PPUSH
35363: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35367: LD_ADDR_VAR 0 9
35371: PUSH
35372: LD_EXP 79
35376: PUSH
35377: LD_VAR 0 2
35381: ARRAY
35382: PPUSH
35383: LD_INT 1
35385: PPUSH
35386: CALL_OW 3
35390: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35391: LD_ADDR_EXP 79
35395: PUSH
35396: LD_EXP 79
35400: PPUSH
35401: LD_VAR 0 2
35405: PPUSH
35406: LD_VAR 0 9
35410: PPUSH
35411: CALL_OW 1
35415: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35416: LD_EXP 79
35420: PUSH
35421: LD_VAR 0 2
35425: ARRAY
35426: PUSH
35427: LD_EXP 80
35431: PUSH
35432: LD_VAR 0 2
35436: ARRAY
35437: AND
35438: PUSH
35439: LD_EXP 80
35443: PUSH
35444: LD_VAR 0 2
35448: ARRAY
35449: PUSH
35450: LD_INT 1
35452: ARRAY
35453: PPUSH
35454: CALL_OW 310
35458: NOT
35459: AND
35460: PUSH
35461: LD_VAR 0 3
35465: PPUSH
35466: CALL_OW 313
35470: PUSH
35471: LD_INT 6
35473: EQUAL
35474: AND
35475: IFFALSE 35531
// begin tmp2 := UnitsInside ( j ) ;
35477: LD_ADDR_VAR 0 9
35481: PUSH
35482: LD_VAR 0 3
35486: PPUSH
35487: CALL_OW 313
35491: ST_TO_ADDR
// if tmp2 = 6 then
35492: LD_VAR 0 9
35496: PUSH
35497: LD_INT 6
35499: EQUAL
35500: IFFALSE 35531
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35502: LD_VAR 0 9
35506: PUSH
35507: LD_INT 1
35509: ARRAY
35510: PPUSH
35511: LD_INT 112
35513: PPUSH
35514: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35518: LD_VAR 0 9
35522: PUSH
35523: LD_INT 1
35525: ARRAY
35526: PPUSH
35527: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35531: LD_EXP 80
35535: PUSH
35536: LD_VAR 0 2
35540: ARRAY
35541: PUSH
35542: LD_EXP 80
35546: PUSH
35547: LD_VAR 0 2
35551: ARRAY
35552: PUSH
35553: LD_INT 1
35555: ARRAY
35556: PPUSH
35557: CALL_OW 314
35561: NOT
35562: AND
35563: PUSH
35564: LD_EXP 80
35568: PUSH
35569: LD_VAR 0 2
35573: ARRAY
35574: PUSH
35575: LD_INT 1
35577: ARRAY
35578: PPUSH
35579: CALL_OW 310
35583: NOT
35584: AND
35585: IFFALSE 35611
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35587: LD_EXP 80
35591: PUSH
35592: LD_VAR 0 2
35596: ARRAY
35597: PUSH
35598: LD_INT 1
35600: ARRAY
35601: PPUSH
35602: LD_VAR 0 3
35606: PPUSH
35607: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35611: LD_EXP 80
35615: PUSH
35616: LD_VAR 0 2
35620: ARRAY
35621: PUSH
35622: LD_INT 1
35624: ARRAY
35625: PPUSH
35626: CALL_OW 310
35630: PUSH
35631: LD_EXP 80
35635: PUSH
35636: LD_VAR 0 2
35640: ARRAY
35641: PUSH
35642: LD_INT 1
35644: ARRAY
35645: PPUSH
35646: CALL_OW 310
35650: PPUSH
35651: CALL_OW 461
35655: PUSH
35656: LD_INT 3
35658: NONEQUAL
35659: AND
35660: IFFALSE 35681
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35662: LD_EXP 80
35666: PUSH
35667: LD_VAR 0 2
35671: ARRAY
35672: PUSH
35673: LD_INT 1
35675: ARRAY
35676: PPUSH
35677: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35681: LD_VAR 0 3
35685: PPUSH
35686: CALL_OW 461
35690: PUSH
35691: LD_INT 6
35693: EQUAL
35694: PUSH
35695: LD_VAR 0 6
35699: PUSH
35700: LD_INT 1
35702: GREATER
35703: AND
35704: IFFALSE 35856
// begin sci := [ ] ;
35706: LD_ADDR_VAR 0 8
35710: PUSH
35711: EMPTY
35712: ST_TO_ADDR
// for x in ( tmp diff j ) do
35713: LD_ADDR_VAR 0 7
35717: PUSH
35718: LD_VAR 0 6
35722: PUSH
35723: LD_VAR 0 3
35727: DIFF
35728: PUSH
35729: FOR_IN
35730: IFFALSE 35782
// begin if sci = 6 then
35732: LD_VAR 0 8
35736: PUSH
35737: LD_INT 6
35739: EQUAL
35740: IFFALSE 35744
// break ;
35742: GO 35782
// if BuildingStatus ( x ) = bs_idle then
35744: LD_VAR 0 7
35748: PPUSH
35749: CALL_OW 461
35753: PUSH
35754: LD_INT 2
35756: EQUAL
35757: IFFALSE 35780
// sci := sci ^ UnitsInside ( x ) ;
35759: LD_ADDR_VAR 0 8
35763: PUSH
35764: LD_VAR 0 8
35768: PUSH
35769: LD_VAR 0 7
35773: PPUSH
35774: CALL_OW 313
35778: ADD
35779: ST_TO_ADDR
// end ;
35780: GO 35729
35782: POP
35783: POP
// if not sci then
35784: LD_VAR 0 8
35788: NOT
35789: IFFALSE 35793
// continue ;
35791: GO 34838
// for x in sci do
35793: LD_ADDR_VAR 0 7
35797: PUSH
35798: LD_VAR 0 8
35802: PUSH
35803: FOR_IN
35804: IFFALSE 35854
// if IsInUnit ( x ) and not HasTask ( x ) then
35806: LD_VAR 0 7
35810: PPUSH
35811: CALL_OW 310
35815: PUSH
35816: LD_VAR 0 7
35820: PPUSH
35821: CALL_OW 314
35825: NOT
35826: AND
35827: IFFALSE 35852
// begin ComExitBuilding ( x ) ;
35829: LD_VAR 0 7
35833: PPUSH
35834: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35838: LD_VAR 0 7
35842: PPUSH
35843: LD_VAR 0 3
35847: PPUSH
35848: CALL_OW 180
// end ;
35852: GO 35803
35854: POP
35855: POP
// end ; end ;
35856: GO 34838
35858: POP
35859: POP
// end ;
35860: GO 34792
35862: POP
35863: POP
// end ;
35864: LD_VAR 0 1
35868: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35869: LD_INT 0
35871: PPUSH
35872: PPUSH
// if not mc_bases then
35873: LD_EXP 50
35877: NOT
35878: IFFALSE 35882
// exit ;
35880: GO 35963
// for i = 1 to mc_bases do
35882: LD_ADDR_VAR 0 2
35886: PUSH
35887: DOUBLE
35888: LD_INT 1
35890: DEC
35891: ST_TO_ADDR
35892: LD_EXP 50
35896: PUSH
35897: FOR_TO
35898: IFFALSE 35961
// if mc_mines [ i ] and mc_miners [ i ] then
35900: LD_EXP 63
35904: PUSH
35905: LD_VAR 0 2
35909: ARRAY
35910: PUSH
35911: LD_EXP 64
35915: PUSH
35916: LD_VAR 0 2
35920: ARRAY
35921: AND
35922: IFFALSE 35959
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35924: LD_EXP 64
35928: PUSH
35929: LD_VAR 0 2
35933: ARRAY
35934: PUSH
35935: LD_INT 1
35937: ARRAY
35938: PPUSH
35939: CALL_OW 255
35943: PPUSH
35944: LD_EXP 63
35948: PUSH
35949: LD_VAR 0 2
35953: ARRAY
35954: PPUSH
35955: CALL 50587 0 2
35959: GO 35897
35961: POP
35962: POP
// end ;
35963: LD_VAR 0 1
35967: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35968: LD_INT 0
35970: PPUSH
35971: PPUSH
35972: PPUSH
35973: PPUSH
35974: PPUSH
35975: PPUSH
35976: PPUSH
35977: PPUSH
// if not mc_bases or not mc_parking then
35978: LD_EXP 50
35982: NOT
35983: PUSH
35984: LD_EXP 74
35988: NOT
35989: OR
35990: IFFALSE 35994
// exit ;
35992: GO 36732
// for i = 1 to mc_bases do
35994: LD_ADDR_VAR 0 2
35998: PUSH
35999: DOUBLE
36000: LD_INT 1
36002: DEC
36003: ST_TO_ADDR
36004: LD_EXP 50
36008: PUSH
36009: FOR_TO
36010: IFFALSE 36730
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36012: LD_EXP 50
36016: PUSH
36017: LD_VAR 0 2
36021: ARRAY
36022: NOT
36023: PUSH
36024: LD_EXP 74
36028: PUSH
36029: LD_VAR 0 2
36033: ARRAY
36034: NOT
36035: OR
36036: IFFALSE 36040
// continue ;
36038: GO 36009
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36040: LD_ADDR_VAR 0 5
36044: PUSH
36045: LD_EXP 50
36049: PUSH
36050: LD_VAR 0 2
36054: ARRAY
36055: PUSH
36056: LD_INT 1
36058: ARRAY
36059: PPUSH
36060: CALL_OW 255
36064: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36065: LD_ADDR_VAR 0 6
36069: PUSH
36070: LD_EXP 50
36074: PUSH
36075: LD_VAR 0 2
36079: ARRAY
36080: PPUSH
36081: LD_INT 30
36083: PUSH
36084: LD_INT 3
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PPUSH
36091: CALL_OW 72
36095: ST_TO_ADDR
// if not fac then
36096: LD_VAR 0 6
36100: NOT
36101: IFFALSE 36152
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36103: LD_ADDR_VAR 0 6
36107: PUSH
36108: LD_EXP 50
36112: PUSH
36113: LD_VAR 0 2
36117: ARRAY
36118: PPUSH
36119: LD_INT 2
36121: PUSH
36122: LD_INT 30
36124: PUSH
36125: LD_INT 0
36127: PUSH
36128: EMPTY
36129: LIST
36130: LIST
36131: PUSH
36132: LD_INT 30
36134: PUSH
36135: LD_INT 1
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: LIST
36146: PPUSH
36147: CALL_OW 72
36151: ST_TO_ADDR
// if not fac then
36152: LD_VAR 0 6
36156: NOT
36157: IFFALSE 36161
// continue ;
36159: GO 36009
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36161: LD_ADDR_VAR 0 7
36165: PUSH
36166: LD_EXP 74
36170: PUSH
36171: LD_VAR 0 2
36175: ARRAY
36176: PPUSH
36177: LD_INT 22
36179: PUSH
36180: LD_VAR 0 5
36184: PUSH
36185: EMPTY
36186: LIST
36187: LIST
36188: PUSH
36189: LD_INT 21
36191: PUSH
36192: LD_INT 2
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 3
36201: PUSH
36202: LD_INT 60
36204: PUSH
36205: EMPTY
36206: LIST
36207: PUSH
36208: EMPTY
36209: LIST
36210: LIST
36211: PUSH
36212: LD_INT 3
36214: PUSH
36215: LD_INT 24
36217: PUSH
36218: LD_INT 1000
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: LIST
36233: LIST
36234: PPUSH
36235: CALL_OW 70
36239: ST_TO_ADDR
// for j in fac do
36240: LD_ADDR_VAR 0 3
36244: PUSH
36245: LD_VAR 0 6
36249: PUSH
36250: FOR_IN
36251: IFFALSE 36346
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36253: LD_ADDR_VAR 0 7
36257: PUSH
36258: LD_VAR 0 7
36262: PUSH
36263: LD_INT 22
36265: PUSH
36266: LD_VAR 0 5
36270: PUSH
36271: EMPTY
36272: LIST
36273: LIST
36274: PUSH
36275: LD_INT 91
36277: PUSH
36278: LD_VAR 0 3
36282: PUSH
36283: LD_INT 15
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 21
36293: PUSH
36294: LD_INT 2
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 3
36303: PUSH
36304: LD_INT 60
36306: PUSH
36307: EMPTY
36308: LIST
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 3
36316: PUSH
36317: LD_INT 24
36319: PUSH
36320: LD_INT 1000
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: EMPTY
36332: LIST
36333: LIST
36334: LIST
36335: LIST
36336: LIST
36337: PPUSH
36338: CALL_OW 69
36342: UNION
36343: ST_TO_ADDR
36344: GO 36250
36346: POP
36347: POP
// if not vehs then
36348: LD_VAR 0 7
36352: NOT
36353: IFFALSE 36379
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36355: LD_ADDR_EXP 62
36359: PUSH
36360: LD_EXP 62
36364: PPUSH
36365: LD_VAR 0 2
36369: PPUSH
36370: EMPTY
36371: PPUSH
36372: CALL_OW 1
36376: ST_TO_ADDR
// continue ;
36377: GO 36009
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36379: LD_ADDR_VAR 0 8
36383: PUSH
36384: LD_EXP 50
36388: PUSH
36389: LD_VAR 0 2
36393: ARRAY
36394: PPUSH
36395: LD_INT 30
36397: PUSH
36398: LD_INT 3
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PPUSH
36405: CALL_OW 72
36409: ST_TO_ADDR
// if tmp then
36410: LD_VAR 0 8
36414: IFFALSE 36517
// begin for j in tmp do
36416: LD_ADDR_VAR 0 3
36420: PUSH
36421: LD_VAR 0 8
36425: PUSH
36426: FOR_IN
36427: IFFALSE 36515
// for k in UnitsInside ( j ) do
36429: LD_ADDR_VAR 0 4
36433: PUSH
36434: LD_VAR 0 3
36438: PPUSH
36439: CALL_OW 313
36443: PUSH
36444: FOR_IN
36445: IFFALSE 36511
// if k then
36447: LD_VAR 0 4
36451: IFFALSE 36509
// if not k in mc_repair_vehicle [ i ] then
36453: LD_VAR 0 4
36457: PUSH
36458: LD_EXP 62
36462: PUSH
36463: LD_VAR 0 2
36467: ARRAY
36468: IN
36469: NOT
36470: IFFALSE 36509
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36472: LD_ADDR_EXP 62
36476: PUSH
36477: LD_EXP 62
36481: PPUSH
36482: LD_VAR 0 2
36486: PPUSH
36487: LD_EXP 62
36491: PUSH
36492: LD_VAR 0 2
36496: ARRAY
36497: PUSH
36498: LD_VAR 0 4
36502: UNION
36503: PPUSH
36504: CALL_OW 1
36508: ST_TO_ADDR
36509: GO 36444
36511: POP
36512: POP
36513: GO 36426
36515: POP
36516: POP
// end ; if not mc_repair_vehicle [ i ] then
36517: LD_EXP 62
36521: PUSH
36522: LD_VAR 0 2
36526: ARRAY
36527: NOT
36528: IFFALSE 36532
// continue ;
36530: GO 36009
// for j in mc_repair_vehicle [ i ] do
36532: LD_ADDR_VAR 0 3
36536: PUSH
36537: LD_EXP 62
36541: PUSH
36542: LD_VAR 0 2
36546: ARRAY
36547: PUSH
36548: FOR_IN
36549: IFFALSE 36726
// begin if GetClass ( j ) <> 3 then
36551: LD_VAR 0 3
36555: PPUSH
36556: CALL_OW 257
36560: PUSH
36561: LD_INT 3
36563: NONEQUAL
36564: IFFALSE 36605
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36566: LD_ADDR_EXP 62
36570: PUSH
36571: LD_EXP 62
36575: PPUSH
36576: LD_VAR 0 2
36580: PPUSH
36581: LD_EXP 62
36585: PUSH
36586: LD_VAR 0 2
36590: ARRAY
36591: PUSH
36592: LD_VAR 0 3
36596: DIFF
36597: PPUSH
36598: CALL_OW 1
36602: ST_TO_ADDR
// continue ;
36603: GO 36548
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36605: LD_VAR 0 3
36609: PPUSH
36610: CALL_OW 311
36614: NOT
36615: PUSH
36616: LD_VAR 0 3
36620: PUSH
36621: LD_EXP 53
36625: PUSH
36626: LD_VAR 0 2
36630: ARRAY
36631: PUSH
36632: LD_INT 1
36634: ARRAY
36635: IN
36636: NOT
36637: AND
36638: PUSH
36639: LD_VAR 0 3
36643: PUSH
36644: LD_EXP 53
36648: PUSH
36649: LD_VAR 0 2
36653: ARRAY
36654: PUSH
36655: LD_INT 2
36657: ARRAY
36658: IN
36659: NOT
36660: AND
36661: IFFALSE 36724
// begin if IsInUnit ( j ) then
36663: LD_VAR 0 3
36667: PPUSH
36668: CALL_OW 310
36672: IFFALSE 36685
// ComExitBuilding ( j ) else
36674: LD_VAR 0 3
36678: PPUSH
36679: CALL_OW 122
36683: GO 36724
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36685: LD_VAR 0 3
36689: PPUSH
36690: LD_VAR 0 7
36694: PUSH
36695: LD_INT 1
36697: ARRAY
36698: PPUSH
36699: CALL 88181 0 2
36703: NOT
36704: IFFALSE 36724
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
36706: LD_VAR 0 3
36710: PPUSH
36711: LD_VAR 0 7
36715: PUSH
36716: LD_INT 1
36718: ARRAY
36719: PPUSH
36720: CALL_OW 129
// end ; end ;
36724: GO 36548
36726: POP
36727: POP
// end ;
36728: GO 36009
36730: POP
36731: POP
// end ;
36732: LD_VAR 0 1
36736: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36737: LD_INT 0
36739: PPUSH
36740: PPUSH
36741: PPUSH
36742: PPUSH
36743: PPUSH
36744: PPUSH
36745: PPUSH
36746: PPUSH
36747: PPUSH
36748: PPUSH
36749: PPUSH
// if not mc_bases then
36750: LD_EXP 50
36754: NOT
36755: IFFALSE 36759
// exit ;
36757: GO 37561
// for i = 1 to mc_bases do
36759: LD_ADDR_VAR 0 2
36763: PUSH
36764: DOUBLE
36765: LD_INT 1
36767: DEC
36768: ST_TO_ADDR
36769: LD_EXP 50
36773: PUSH
36774: FOR_TO
36775: IFFALSE 37559
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36777: LD_EXP 78
36781: PUSH
36782: LD_VAR 0 2
36786: ARRAY
36787: NOT
36788: PUSH
36789: LD_EXP 53
36793: PUSH
36794: LD_VAR 0 2
36798: ARRAY
36799: PUSH
36800: LD_INT 1
36802: ARRAY
36803: OR
36804: PUSH
36805: LD_EXP 53
36809: PUSH
36810: LD_VAR 0 2
36814: ARRAY
36815: PUSH
36816: LD_INT 2
36818: ARRAY
36819: OR
36820: PUSH
36821: LD_EXP 76
36825: PUSH
36826: LD_VAR 0 2
36830: ARRAY
36831: PPUSH
36832: LD_INT 1
36834: PPUSH
36835: CALL_OW 325
36839: NOT
36840: OR
36841: PUSH
36842: LD_EXP 73
36846: PUSH
36847: LD_VAR 0 2
36851: ARRAY
36852: OR
36853: IFFALSE 36857
// continue ;
36855: GO 36774
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36857: LD_ADDR_VAR 0 8
36861: PUSH
36862: LD_EXP 50
36866: PUSH
36867: LD_VAR 0 2
36871: ARRAY
36872: PPUSH
36873: LD_INT 25
36875: PUSH
36876: LD_INT 4
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 50
36885: PUSH
36886: EMPTY
36887: LIST
36888: PUSH
36889: LD_INT 3
36891: PUSH
36892: LD_INT 60
36894: PUSH
36895: EMPTY
36896: LIST
36897: PUSH
36898: EMPTY
36899: LIST
36900: LIST
36901: PUSH
36902: EMPTY
36903: LIST
36904: LIST
36905: LIST
36906: PPUSH
36907: CALL_OW 72
36911: PUSH
36912: LD_EXP 54
36916: PUSH
36917: LD_VAR 0 2
36921: ARRAY
36922: DIFF
36923: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36924: LD_ADDR_VAR 0 9
36928: PUSH
36929: LD_EXP 50
36933: PUSH
36934: LD_VAR 0 2
36938: ARRAY
36939: PPUSH
36940: LD_INT 2
36942: PUSH
36943: LD_INT 30
36945: PUSH
36946: LD_INT 0
36948: PUSH
36949: EMPTY
36950: LIST
36951: LIST
36952: PUSH
36953: LD_INT 30
36955: PUSH
36956: LD_INT 1
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: LIST
36967: PPUSH
36968: CALL_OW 72
36972: ST_TO_ADDR
// if not tmp or not dep then
36973: LD_VAR 0 8
36977: NOT
36978: PUSH
36979: LD_VAR 0 9
36983: NOT
36984: OR
36985: IFFALSE 36989
// continue ;
36987: GO 36774
// side := GetSide ( tmp [ 1 ] ) ;
36989: LD_ADDR_VAR 0 11
36993: PUSH
36994: LD_VAR 0 8
36998: PUSH
36999: LD_INT 1
37001: ARRAY
37002: PPUSH
37003: CALL_OW 255
37007: ST_TO_ADDR
// dep := dep [ 1 ] ;
37008: LD_ADDR_VAR 0 9
37012: PUSH
37013: LD_VAR 0 9
37017: PUSH
37018: LD_INT 1
37020: ARRAY
37021: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37022: LD_ADDR_VAR 0 7
37026: PUSH
37027: LD_EXP 78
37031: PUSH
37032: LD_VAR 0 2
37036: ARRAY
37037: PPUSH
37038: LD_INT 22
37040: PUSH
37041: LD_INT 0
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 25
37050: PUSH
37051: LD_INT 12
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PPUSH
37062: CALL_OW 70
37066: PUSH
37067: LD_INT 22
37069: PUSH
37070: LD_INT 0
37072: PUSH
37073: EMPTY
37074: LIST
37075: LIST
37076: PUSH
37077: LD_INT 25
37079: PUSH
37080: LD_INT 12
37082: PUSH
37083: EMPTY
37084: LIST
37085: LIST
37086: PUSH
37087: LD_INT 91
37089: PUSH
37090: LD_VAR 0 9
37094: PUSH
37095: LD_INT 20
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: LIST
37102: PUSH
37103: EMPTY
37104: LIST
37105: LIST
37106: LIST
37107: PPUSH
37108: CALL_OW 69
37112: UNION
37113: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37114: LD_ADDR_VAR 0 10
37118: PUSH
37119: LD_EXP 78
37123: PUSH
37124: LD_VAR 0 2
37128: ARRAY
37129: PPUSH
37130: LD_INT 81
37132: PUSH
37133: LD_VAR 0 11
37137: PUSH
37138: EMPTY
37139: LIST
37140: LIST
37141: PPUSH
37142: CALL_OW 70
37146: ST_TO_ADDR
// if not apes or danger_at_area then
37147: LD_VAR 0 7
37151: NOT
37152: PUSH
37153: LD_VAR 0 10
37157: OR
37158: IFFALSE 37208
// begin if mc_taming [ i ] then
37160: LD_EXP 81
37164: PUSH
37165: LD_VAR 0 2
37169: ARRAY
37170: IFFALSE 37206
// begin MC_Reset ( i , 121 ) ;
37172: LD_VAR 0 2
37176: PPUSH
37177: LD_INT 121
37179: PPUSH
37180: CALL 22145 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37184: LD_ADDR_EXP 81
37188: PUSH
37189: LD_EXP 81
37193: PPUSH
37194: LD_VAR 0 2
37198: PPUSH
37199: EMPTY
37200: PPUSH
37201: CALL_OW 1
37205: ST_TO_ADDR
// end ; continue ;
37206: GO 36774
// end ; for j in tmp do
37208: LD_ADDR_VAR 0 3
37212: PUSH
37213: LD_VAR 0 8
37217: PUSH
37218: FOR_IN
37219: IFFALSE 37555
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37221: LD_VAR 0 3
37225: PUSH
37226: LD_EXP 81
37230: PUSH
37231: LD_VAR 0 2
37235: ARRAY
37236: IN
37237: NOT
37238: PUSH
37239: LD_EXP 81
37243: PUSH
37244: LD_VAR 0 2
37248: ARRAY
37249: PUSH
37250: LD_INT 3
37252: LESS
37253: AND
37254: IFFALSE 37312
// begin SetTag ( j , 121 ) ;
37256: LD_VAR 0 3
37260: PPUSH
37261: LD_INT 121
37263: PPUSH
37264: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37268: LD_ADDR_EXP 81
37272: PUSH
37273: LD_EXP 81
37277: PPUSH
37278: LD_VAR 0 2
37282: PUSH
37283: LD_EXP 81
37287: PUSH
37288: LD_VAR 0 2
37292: ARRAY
37293: PUSH
37294: LD_INT 1
37296: PLUS
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PPUSH
37302: LD_VAR 0 3
37306: PPUSH
37307: CALL 53785 0 3
37311: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37312: LD_VAR 0 3
37316: PUSH
37317: LD_EXP 81
37321: PUSH
37322: LD_VAR 0 2
37326: ARRAY
37327: IN
37328: IFFALSE 37553
// begin if GetClass ( j ) <> 4 then
37330: LD_VAR 0 3
37334: PPUSH
37335: CALL_OW 257
37339: PUSH
37340: LD_INT 4
37342: NONEQUAL
37343: IFFALSE 37396
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37345: LD_ADDR_EXP 81
37349: PUSH
37350: LD_EXP 81
37354: PPUSH
37355: LD_VAR 0 2
37359: PPUSH
37360: LD_EXP 81
37364: PUSH
37365: LD_VAR 0 2
37369: ARRAY
37370: PUSH
37371: LD_VAR 0 3
37375: DIFF
37376: PPUSH
37377: CALL_OW 1
37381: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37382: LD_VAR 0 3
37386: PPUSH
37387: LD_INT 0
37389: PPUSH
37390: CALL_OW 109
// continue ;
37394: GO 37218
// end ; if IsInUnit ( j ) then
37396: LD_VAR 0 3
37400: PPUSH
37401: CALL_OW 310
37405: IFFALSE 37416
// ComExitBuilding ( j ) ;
37407: LD_VAR 0 3
37411: PPUSH
37412: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37416: LD_ADDR_VAR 0 6
37420: PUSH
37421: LD_VAR 0 7
37425: PPUSH
37426: LD_VAR 0 3
37430: PPUSH
37431: CALL_OW 74
37435: ST_TO_ADDR
// if not ape then
37436: LD_VAR 0 6
37440: NOT
37441: IFFALSE 37445
// break ;
37443: GO 37555
// x := GetX ( ape ) ;
37445: LD_ADDR_VAR 0 4
37449: PUSH
37450: LD_VAR 0 6
37454: PPUSH
37455: CALL_OW 250
37459: ST_TO_ADDR
// y := GetY ( ape ) ;
37460: LD_ADDR_VAR 0 5
37464: PUSH
37465: LD_VAR 0 6
37469: PPUSH
37470: CALL_OW 251
37474: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37475: LD_VAR 0 4
37479: PPUSH
37480: LD_VAR 0 5
37484: PPUSH
37485: CALL_OW 488
37489: NOT
37490: PUSH
37491: LD_VAR 0 11
37495: PPUSH
37496: LD_VAR 0 4
37500: PPUSH
37501: LD_VAR 0 5
37505: PPUSH
37506: LD_INT 20
37508: PPUSH
37509: CALL 54681 0 4
37513: PUSH
37514: LD_INT 4
37516: ARRAY
37517: OR
37518: IFFALSE 37522
// break ;
37520: GO 37555
// if not HasTask ( j ) then
37522: LD_VAR 0 3
37526: PPUSH
37527: CALL_OW 314
37531: NOT
37532: IFFALSE 37553
// ComTameXY ( j , x , y ) ;
37534: LD_VAR 0 3
37538: PPUSH
37539: LD_VAR 0 4
37543: PPUSH
37544: LD_VAR 0 5
37548: PPUSH
37549: CALL_OW 131
// end ; end ;
37553: GO 37218
37555: POP
37556: POP
// end ;
37557: GO 36774
37559: POP
37560: POP
// end ;
37561: LD_VAR 0 1
37565: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37566: LD_INT 0
37568: PPUSH
37569: PPUSH
37570: PPUSH
37571: PPUSH
37572: PPUSH
37573: PPUSH
37574: PPUSH
37575: PPUSH
// if not mc_bases then
37576: LD_EXP 50
37580: NOT
37581: IFFALSE 37585
// exit ;
37583: GO 38211
// for i = 1 to mc_bases do
37585: LD_ADDR_VAR 0 2
37589: PUSH
37590: DOUBLE
37591: LD_INT 1
37593: DEC
37594: ST_TO_ADDR
37595: LD_EXP 50
37599: PUSH
37600: FOR_TO
37601: IFFALSE 38209
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37603: LD_EXP 79
37607: PUSH
37608: LD_VAR 0 2
37612: ARRAY
37613: NOT
37614: PUSH
37615: LD_EXP 79
37619: PUSH
37620: LD_VAR 0 2
37624: ARRAY
37625: PPUSH
37626: LD_INT 25
37628: PUSH
37629: LD_INT 12
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PPUSH
37636: CALL_OW 72
37640: NOT
37641: OR
37642: IFFALSE 37646
// continue ;
37644: GO 37600
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37646: LD_ADDR_VAR 0 5
37650: PUSH
37651: LD_EXP 79
37655: PUSH
37656: LD_VAR 0 2
37660: ARRAY
37661: PUSH
37662: LD_INT 1
37664: ARRAY
37665: PPUSH
37666: CALL_OW 255
37670: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37671: LD_VAR 0 5
37675: PPUSH
37676: LD_INT 2
37678: PPUSH
37679: CALL_OW 325
37683: IFFALSE 37936
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37685: LD_ADDR_VAR 0 4
37689: PUSH
37690: LD_EXP 79
37694: PUSH
37695: LD_VAR 0 2
37699: ARRAY
37700: PPUSH
37701: LD_INT 25
37703: PUSH
37704: LD_INT 16
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: PPUSH
37711: CALL_OW 72
37715: ST_TO_ADDR
// if tmp < 6 then
37716: LD_VAR 0 4
37720: PUSH
37721: LD_INT 6
37723: LESS
37724: IFFALSE 37936
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37726: LD_ADDR_VAR 0 6
37730: PUSH
37731: LD_EXP 50
37735: PUSH
37736: LD_VAR 0 2
37740: ARRAY
37741: PPUSH
37742: LD_INT 2
37744: PUSH
37745: LD_INT 30
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 30
37757: PUSH
37758: LD_INT 1
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: LIST
37769: PPUSH
37770: CALL_OW 72
37774: ST_TO_ADDR
// if depot then
37775: LD_VAR 0 6
37779: IFFALSE 37936
// begin selected := 0 ;
37781: LD_ADDR_VAR 0 7
37785: PUSH
37786: LD_INT 0
37788: ST_TO_ADDR
// for j in depot do
37789: LD_ADDR_VAR 0 3
37793: PUSH
37794: LD_VAR 0 6
37798: PUSH
37799: FOR_IN
37800: IFFALSE 37831
// begin if UnitsInside ( j ) < 6 then
37802: LD_VAR 0 3
37806: PPUSH
37807: CALL_OW 313
37811: PUSH
37812: LD_INT 6
37814: LESS
37815: IFFALSE 37829
// begin selected := j ;
37817: LD_ADDR_VAR 0 7
37821: PUSH
37822: LD_VAR 0 3
37826: ST_TO_ADDR
// break ;
37827: GO 37831
// end ; end ;
37829: GO 37799
37831: POP
37832: POP
// if selected then
37833: LD_VAR 0 7
37837: IFFALSE 37936
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37839: LD_ADDR_VAR 0 3
37843: PUSH
37844: LD_EXP 79
37848: PUSH
37849: LD_VAR 0 2
37853: ARRAY
37854: PPUSH
37855: LD_INT 25
37857: PUSH
37858: LD_INT 12
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PPUSH
37865: CALL_OW 72
37869: PUSH
37870: FOR_IN
37871: IFFALSE 37934
// if not HasTask ( j ) then
37873: LD_VAR 0 3
37877: PPUSH
37878: CALL_OW 314
37882: NOT
37883: IFFALSE 37932
// begin if not IsInUnit ( j ) then
37885: LD_VAR 0 3
37889: PPUSH
37890: CALL_OW 310
37894: NOT
37895: IFFALSE 37911
// ComEnterUnit ( j , selected ) ;
37897: LD_VAR 0 3
37901: PPUSH
37902: LD_VAR 0 7
37906: PPUSH
37907: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37911: LD_VAR 0 3
37915: PPUSH
37916: LD_INT 16
37918: PPUSH
37919: CALL_OW 183
// AddComExitBuilding ( j ) ;
37923: LD_VAR 0 3
37927: PPUSH
37928: CALL_OW 182
// end ;
37932: GO 37870
37934: POP
37935: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37936: LD_VAR 0 5
37940: PPUSH
37941: LD_INT 11
37943: PPUSH
37944: CALL_OW 325
37948: IFFALSE 38207
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37950: LD_ADDR_VAR 0 4
37954: PUSH
37955: LD_EXP 79
37959: PUSH
37960: LD_VAR 0 2
37964: ARRAY
37965: PPUSH
37966: LD_INT 25
37968: PUSH
37969: LD_INT 16
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: PPUSH
37976: CALL_OW 72
37980: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37981: LD_VAR 0 4
37985: PUSH
37986: LD_INT 6
37988: GREATEREQUAL
37989: PUSH
37990: LD_VAR 0 5
37994: PPUSH
37995: LD_INT 2
37997: PPUSH
37998: CALL_OW 325
38002: NOT
38003: OR
38004: IFFALSE 38207
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38006: LD_ADDR_VAR 0 8
38010: PUSH
38011: LD_EXP 50
38015: PUSH
38016: LD_VAR 0 2
38020: ARRAY
38021: PPUSH
38022: LD_INT 2
38024: PUSH
38025: LD_INT 30
38027: PUSH
38028: LD_INT 4
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 30
38037: PUSH
38038: LD_INT 5
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: LIST
38049: PPUSH
38050: CALL_OW 72
38054: ST_TO_ADDR
// if barracks then
38055: LD_VAR 0 8
38059: IFFALSE 38207
// begin selected := 0 ;
38061: LD_ADDR_VAR 0 7
38065: PUSH
38066: LD_INT 0
38068: ST_TO_ADDR
// for j in barracks do
38069: LD_ADDR_VAR 0 3
38073: PUSH
38074: LD_VAR 0 8
38078: PUSH
38079: FOR_IN
38080: IFFALSE 38111
// begin if UnitsInside ( j ) < 6 then
38082: LD_VAR 0 3
38086: PPUSH
38087: CALL_OW 313
38091: PUSH
38092: LD_INT 6
38094: LESS
38095: IFFALSE 38109
// begin selected := j ;
38097: LD_ADDR_VAR 0 7
38101: PUSH
38102: LD_VAR 0 3
38106: ST_TO_ADDR
// break ;
38107: GO 38111
// end ; end ;
38109: GO 38079
38111: POP
38112: POP
// if selected then
38113: LD_VAR 0 7
38117: IFFALSE 38207
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38119: LD_ADDR_VAR 0 3
38123: PUSH
38124: LD_EXP 79
38128: PUSH
38129: LD_VAR 0 2
38133: ARRAY
38134: PPUSH
38135: LD_INT 25
38137: PUSH
38138: LD_INT 12
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: PPUSH
38145: CALL_OW 72
38149: PUSH
38150: FOR_IN
38151: IFFALSE 38205
// if not IsInUnit ( j ) and not HasTask ( j ) then
38153: LD_VAR 0 3
38157: PPUSH
38158: CALL_OW 310
38162: NOT
38163: PUSH
38164: LD_VAR 0 3
38168: PPUSH
38169: CALL_OW 314
38173: NOT
38174: AND
38175: IFFALSE 38203
// begin ComEnterUnit ( j , selected ) ;
38177: LD_VAR 0 3
38181: PPUSH
38182: LD_VAR 0 7
38186: PPUSH
38187: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38191: LD_VAR 0 3
38195: PPUSH
38196: LD_INT 15
38198: PPUSH
38199: CALL_OW 183
// end ;
38203: GO 38150
38205: POP
38206: POP
// end ; end ; end ; end ; end ;
38207: GO 37600
38209: POP
38210: POP
// end ;
38211: LD_VAR 0 1
38215: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38216: LD_INT 0
38218: PPUSH
38219: PPUSH
38220: PPUSH
38221: PPUSH
// if not mc_bases then
38222: LD_EXP 50
38226: NOT
38227: IFFALSE 38231
// exit ;
38229: GO 38409
// for i = 1 to mc_bases do
38231: LD_ADDR_VAR 0 2
38235: PUSH
38236: DOUBLE
38237: LD_INT 1
38239: DEC
38240: ST_TO_ADDR
38241: LD_EXP 50
38245: PUSH
38246: FOR_TO
38247: IFFALSE 38407
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38249: LD_ADDR_VAR 0 4
38253: PUSH
38254: LD_EXP 50
38258: PUSH
38259: LD_VAR 0 2
38263: ARRAY
38264: PPUSH
38265: LD_INT 25
38267: PUSH
38268: LD_INT 9
38270: PUSH
38271: EMPTY
38272: LIST
38273: LIST
38274: PPUSH
38275: CALL_OW 72
38279: ST_TO_ADDR
// if not tmp then
38280: LD_VAR 0 4
38284: NOT
38285: IFFALSE 38289
// continue ;
38287: GO 38246
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38289: LD_EXP 76
38293: PUSH
38294: LD_VAR 0 2
38298: ARRAY
38299: PPUSH
38300: LD_INT 29
38302: PPUSH
38303: CALL_OW 325
38307: NOT
38308: PUSH
38309: LD_EXP 76
38313: PUSH
38314: LD_VAR 0 2
38318: ARRAY
38319: PPUSH
38320: LD_INT 28
38322: PPUSH
38323: CALL_OW 325
38327: NOT
38328: AND
38329: IFFALSE 38333
// continue ;
38331: GO 38246
// for j in tmp do
38333: LD_ADDR_VAR 0 3
38337: PUSH
38338: LD_VAR 0 4
38342: PUSH
38343: FOR_IN
38344: IFFALSE 38403
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38346: LD_VAR 0 3
38350: PUSH
38351: LD_EXP 53
38355: PUSH
38356: LD_VAR 0 2
38360: ARRAY
38361: PUSH
38362: LD_INT 1
38364: ARRAY
38365: IN
38366: NOT
38367: PUSH
38368: LD_VAR 0 3
38372: PUSH
38373: LD_EXP 53
38377: PUSH
38378: LD_VAR 0 2
38382: ARRAY
38383: PUSH
38384: LD_INT 2
38386: ARRAY
38387: IN
38388: NOT
38389: AND
38390: IFFALSE 38401
// ComSpaceTimeShoot ( j ) ;
38392: LD_VAR 0 3
38396: PPUSH
38397: CALL 49595 0 1
38401: GO 38343
38403: POP
38404: POP
// end ;
38405: GO 38246
38407: POP
38408: POP
// end ;
38409: LD_VAR 0 1
38413: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38414: LD_INT 0
38416: PPUSH
38417: PPUSH
38418: PPUSH
38419: PPUSH
38420: PPUSH
38421: PPUSH
38422: PPUSH
38423: PPUSH
38424: PPUSH
// if not mc_bases then
38425: LD_EXP 50
38429: NOT
38430: IFFALSE 38434
// exit ;
38432: GO 39056
// for i = 1 to mc_bases do
38434: LD_ADDR_VAR 0 2
38438: PUSH
38439: DOUBLE
38440: LD_INT 1
38442: DEC
38443: ST_TO_ADDR
38444: LD_EXP 50
38448: PUSH
38449: FOR_TO
38450: IFFALSE 39054
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38452: LD_EXP 85
38456: PUSH
38457: LD_VAR 0 2
38461: ARRAY
38462: NOT
38463: PUSH
38464: LD_INT 38
38466: PPUSH
38467: LD_EXP 76
38471: PUSH
38472: LD_VAR 0 2
38476: ARRAY
38477: PPUSH
38478: CALL_OW 321
38482: PUSH
38483: LD_INT 2
38485: NONEQUAL
38486: OR
38487: IFFALSE 38491
// continue ;
38489: GO 38449
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38491: LD_ADDR_VAR 0 8
38495: PUSH
38496: LD_EXP 50
38500: PUSH
38501: LD_VAR 0 2
38505: ARRAY
38506: PPUSH
38507: LD_INT 30
38509: PUSH
38510: LD_INT 34
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: PPUSH
38517: CALL_OW 72
38521: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38522: LD_ADDR_VAR 0 9
38526: PUSH
38527: LD_EXP 50
38531: PUSH
38532: LD_VAR 0 2
38536: ARRAY
38537: PPUSH
38538: LD_INT 25
38540: PUSH
38541: LD_INT 4
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PPUSH
38548: CALL_OW 72
38552: PPUSH
38553: LD_INT 0
38555: PPUSH
38556: CALL 83697 0 2
38560: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38561: LD_VAR 0 9
38565: NOT
38566: PUSH
38567: LD_VAR 0 8
38571: NOT
38572: OR
38573: PUSH
38574: LD_EXP 50
38578: PUSH
38579: LD_VAR 0 2
38583: ARRAY
38584: PPUSH
38585: LD_INT 124
38587: PPUSH
38588: CALL 83697 0 2
38592: OR
38593: IFFALSE 38597
// continue ;
38595: GO 38449
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38597: LD_EXP 86
38601: PUSH
38602: LD_VAR 0 2
38606: ARRAY
38607: PUSH
38608: LD_EXP 85
38612: PUSH
38613: LD_VAR 0 2
38617: ARRAY
38618: LESS
38619: PUSH
38620: LD_EXP 86
38624: PUSH
38625: LD_VAR 0 2
38629: ARRAY
38630: PUSH
38631: LD_VAR 0 8
38635: LESS
38636: AND
38637: IFFALSE 39052
// begin tmp := sci [ 1 ] ;
38639: LD_ADDR_VAR 0 7
38643: PUSH
38644: LD_VAR 0 9
38648: PUSH
38649: LD_INT 1
38651: ARRAY
38652: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38653: LD_VAR 0 7
38657: PPUSH
38658: LD_INT 124
38660: PPUSH
38661: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38665: LD_ADDR_VAR 0 3
38669: PUSH
38670: DOUBLE
38671: LD_EXP 85
38675: PUSH
38676: LD_VAR 0 2
38680: ARRAY
38681: INC
38682: ST_TO_ADDR
38683: LD_EXP 85
38687: PUSH
38688: LD_VAR 0 2
38692: ARRAY
38693: PUSH
38694: FOR_DOWNTO
38695: IFFALSE 39038
// begin if IsInUnit ( tmp ) then
38697: LD_VAR 0 7
38701: PPUSH
38702: CALL_OW 310
38706: IFFALSE 38717
// ComExitBuilding ( tmp ) ;
38708: LD_VAR 0 7
38712: PPUSH
38713: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38717: LD_INT 35
38719: PPUSH
38720: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38724: LD_VAR 0 7
38728: PPUSH
38729: CALL_OW 310
38733: NOT
38734: PUSH
38735: LD_VAR 0 7
38739: PPUSH
38740: CALL_OW 314
38744: NOT
38745: AND
38746: IFFALSE 38717
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38748: LD_ADDR_VAR 0 6
38752: PUSH
38753: LD_VAR 0 7
38757: PPUSH
38758: CALL_OW 250
38762: PUSH
38763: LD_VAR 0 7
38767: PPUSH
38768: CALL_OW 251
38772: PUSH
38773: EMPTY
38774: LIST
38775: LIST
38776: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38777: LD_INT 35
38779: PPUSH
38780: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38784: LD_ADDR_VAR 0 4
38788: PUSH
38789: LD_EXP 85
38793: PUSH
38794: LD_VAR 0 2
38798: ARRAY
38799: PUSH
38800: LD_VAR 0 3
38804: ARRAY
38805: PUSH
38806: LD_INT 1
38808: ARRAY
38809: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38810: LD_ADDR_VAR 0 5
38814: PUSH
38815: LD_EXP 85
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: PUSH
38826: LD_VAR 0 3
38830: ARRAY
38831: PUSH
38832: LD_INT 2
38834: ARRAY
38835: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38836: LD_VAR 0 7
38840: PPUSH
38841: LD_INT 10
38843: PPUSH
38844: CALL 56382 0 2
38848: PUSH
38849: LD_INT 4
38851: ARRAY
38852: IFFALSE 38890
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38854: LD_VAR 0 7
38858: PPUSH
38859: LD_VAR 0 6
38863: PUSH
38864: LD_INT 1
38866: ARRAY
38867: PPUSH
38868: LD_VAR 0 6
38872: PUSH
38873: LD_INT 2
38875: ARRAY
38876: PPUSH
38877: CALL_OW 111
// wait ( 0 0$10 ) ;
38881: LD_INT 350
38883: PPUSH
38884: CALL_OW 67
// end else
38888: GO 38916
// begin ComMoveXY ( tmp , x , y ) ;
38890: LD_VAR 0 7
38894: PPUSH
38895: LD_VAR 0 4
38899: PPUSH
38900: LD_VAR 0 5
38904: PPUSH
38905: CALL_OW 111
// wait ( 0 0$3 ) ;
38909: LD_INT 105
38911: PPUSH
38912: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38916: LD_VAR 0 7
38920: PPUSH
38921: LD_VAR 0 4
38925: PPUSH
38926: LD_VAR 0 5
38930: PPUSH
38931: CALL_OW 307
38935: IFFALSE 38777
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38937: LD_VAR 0 7
38941: PPUSH
38942: LD_VAR 0 4
38946: PPUSH
38947: LD_VAR 0 5
38951: PPUSH
38952: LD_VAR 0 8
38956: PUSH
38957: LD_VAR 0 3
38961: ARRAY
38962: PPUSH
38963: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38967: LD_INT 35
38969: PPUSH
38970: CALL_OW 67
// until not HasTask ( tmp ) ;
38974: LD_VAR 0 7
38978: PPUSH
38979: CALL_OW 314
38983: NOT
38984: IFFALSE 38967
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38986: LD_ADDR_EXP 86
38990: PUSH
38991: LD_EXP 86
38995: PPUSH
38996: LD_VAR 0 2
39000: PUSH
39001: LD_EXP 86
39005: PUSH
39006: LD_VAR 0 2
39010: ARRAY
39011: PUSH
39012: LD_INT 1
39014: PLUS
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: PPUSH
39020: LD_VAR 0 8
39024: PUSH
39025: LD_VAR 0 3
39029: ARRAY
39030: PPUSH
39031: CALL 53785 0 3
39035: ST_TO_ADDR
// end ;
39036: GO 38694
39038: POP
39039: POP
// MC_Reset ( i , 124 ) ;
39040: LD_VAR 0 2
39044: PPUSH
39045: LD_INT 124
39047: PPUSH
39048: CALL 22145 0 2
// end ; end ;
39052: GO 38449
39054: POP
39055: POP
// end ;
39056: LD_VAR 0 1
39060: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39061: LD_INT 0
39063: PPUSH
39064: PPUSH
39065: PPUSH
// if not mc_bases then
39066: LD_EXP 50
39070: NOT
39071: IFFALSE 39075
// exit ;
39073: GO 39681
// for i = 1 to mc_bases do
39075: LD_ADDR_VAR 0 2
39079: PUSH
39080: DOUBLE
39081: LD_INT 1
39083: DEC
39084: ST_TO_ADDR
39085: LD_EXP 50
39089: PUSH
39090: FOR_TO
39091: IFFALSE 39679
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39093: LD_ADDR_VAR 0 3
39097: PUSH
39098: LD_EXP 50
39102: PUSH
39103: LD_VAR 0 2
39107: ARRAY
39108: PPUSH
39109: LD_INT 25
39111: PUSH
39112: LD_INT 4
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: PPUSH
39119: CALL_OW 72
39123: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39124: LD_VAR 0 3
39128: NOT
39129: PUSH
39130: LD_EXP 87
39134: PUSH
39135: LD_VAR 0 2
39139: ARRAY
39140: NOT
39141: OR
39142: PUSH
39143: LD_EXP 50
39147: PUSH
39148: LD_VAR 0 2
39152: ARRAY
39153: PPUSH
39154: LD_INT 2
39156: PUSH
39157: LD_INT 30
39159: PUSH
39160: LD_INT 0
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: LD_INT 30
39169: PUSH
39170: LD_INT 1
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: LIST
39181: PPUSH
39182: CALL_OW 72
39186: NOT
39187: OR
39188: IFFALSE 39238
// begin if mc_deposits_finder [ i ] then
39190: LD_EXP 88
39194: PUSH
39195: LD_VAR 0 2
39199: ARRAY
39200: IFFALSE 39236
// begin MC_Reset ( i , 125 ) ;
39202: LD_VAR 0 2
39206: PPUSH
39207: LD_INT 125
39209: PPUSH
39210: CALL 22145 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39214: LD_ADDR_EXP 88
39218: PUSH
39219: LD_EXP 88
39223: PPUSH
39224: LD_VAR 0 2
39228: PPUSH
39229: EMPTY
39230: PPUSH
39231: CALL_OW 1
39235: ST_TO_ADDR
// end ; continue ;
39236: GO 39090
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39238: LD_EXP 87
39242: PUSH
39243: LD_VAR 0 2
39247: ARRAY
39248: PUSH
39249: LD_INT 1
39251: ARRAY
39252: PUSH
39253: LD_INT 3
39255: ARRAY
39256: PUSH
39257: LD_INT 1
39259: EQUAL
39260: PUSH
39261: LD_INT 20
39263: PPUSH
39264: LD_EXP 76
39268: PUSH
39269: LD_VAR 0 2
39273: ARRAY
39274: PPUSH
39275: CALL_OW 321
39279: PUSH
39280: LD_INT 2
39282: NONEQUAL
39283: AND
39284: IFFALSE 39334
// begin if mc_deposits_finder [ i ] then
39286: LD_EXP 88
39290: PUSH
39291: LD_VAR 0 2
39295: ARRAY
39296: IFFALSE 39332
// begin MC_Reset ( i , 125 ) ;
39298: LD_VAR 0 2
39302: PPUSH
39303: LD_INT 125
39305: PPUSH
39306: CALL 22145 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39310: LD_ADDR_EXP 88
39314: PUSH
39315: LD_EXP 88
39319: PPUSH
39320: LD_VAR 0 2
39324: PPUSH
39325: EMPTY
39326: PPUSH
39327: CALL_OW 1
39331: ST_TO_ADDR
// end ; continue ;
39332: GO 39090
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39334: LD_EXP 87
39338: PUSH
39339: LD_VAR 0 2
39343: ARRAY
39344: PUSH
39345: LD_INT 1
39347: ARRAY
39348: PUSH
39349: LD_INT 1
39351: ARRAY
39352: PPUSH
39353: LD_EXP 87
39357: PUSH
39358: LD_VAR 0 2
39362: ARRAY
39363: PUSH
39364: LD_INT 1
39366: ARRAY
39367: PUSH
39368: LD_INT 2
39370: ARRAY
39371: PPUSH
39372: LD_EXP 76
39376: PUSH
39377: LD_VAR 0 2
39381: ARRAY
39382: PPUSH
39383: CALL_OW 440
39387: IFFALSE 39430
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39389: LD_ADDR_EXP 87
39393: PUSH
39394: LD_EXP 87
39398: PPUSH
39399: LD_VAR 0 2
39403: PPUSH
39404: LD_EXP 87
39408: PUSH
39409: LD_VAR 0 2
39413: ARRAY
39414: PPUSH
39415: LD_INT 1
39417: PPUSH
39418: CALL_OW 3
39422: PPUSH
39423: CALL_OW 1
39427: ST_TO_ADDR
39428: GO 39677
// begin if not mc_deposits_finder [ i ] then
39430: LD_EXP 88
39434: PUSH
39435: LD_VAR 0 2
39439: ARRAY
39440: NOT
39441: IFFALSE 39493
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39443: LD_ADDR_EXP 88
39447: PUSH
39448: LD_EXP 88
39452: PPUSH
39453: LD_VAR 0 2
39457: PPUSH
39458: LD_VAR 0 3
39462: PUSH
39463: LD_INT 1
39465: ARRAY
39466: PUSH
39467: EMPTY
39468: LIST
39469: PPUSH
39470: CALL_OW 1
39474: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39475: LD_VAR 0 3
39479: PUSH
39480: LD_INT 1
39482: ARRAY
39483: PPUSH
39484: LD_INT 125
39486: PPUSH
39487: CALL_OW 109
// end else
39491: GO 39677
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39493: LD_EXP 88
39497: PUSH
39498: LD_VAR 0 2
39502: ARRAY
39503: PUSH
39504: LD_INT 1
39506: ARRAY
39507: PPUSH
39508: CALL_OW 310
39512: IFFALSE 39535
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39514: LD_EXP 88
39518: PUSH
39519: LD_VAR 0 2
39523: ARRAY
39524: PUSH
39525: LD_INT 1
39527: ARRAY
39528: PPUSH
39529: CALL_OW 122
39533: GO 39677
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39535: LD_EXP 88
39539: PUSH
39540: LD_VAR 0 2
39544: ARRAY
39545: PUSH
39546: LD_INT 1
39548: ARRAY
39549: PPUSH
39550: CALL_OW 314
39554: NOT
39555: PUSH
39556: LD_EXP 88
39560: PUSH
39561: LD_VAR 0 2
39565: ARRAY
39566: PUSH
39567: LD_INT 1
39569: ARRAY
39570: PPUSH
39571: LD_EXP 87
39575: PUSH
39576: LD_VAR 0 2
39580: ARRAY
39581: PUSH
39582: LD_INT 1
39584: ARRAY
39585: PUSH
39586: LD_INT 1
39588: ARRAY
39589: PPUSH
39590: LD_EXP 87
39594: PUSH
39595: LD_VAR 0 2
39599: ARRAY
39600: PUSH
39601: LD_INT 1
39603: ARRAY
39604: PUSH
39605: LD_INT 2
39607: ARRAY
39608: PPUSH
39609: CALL_OW 297
39613: PUSH
39614: LD_INT 6
39616: GREATER
39617: AND
39618: IFFALSE 39677
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39620: LD_EXP 88
39624: PUSH
39625: LD_VAR 0 2
39629: ARRAY
39630: PUSH
39631: LD_INT 1
39633: ARRAY
39634: PPUSH
39635: LD_EXP 87
39639: PUSH
39640: LD_VAR 0 2
39644: ARRAY
39645: PUSH
39646: LD_INT 1
39648: ARRAY
39649: PUSH
39650: LD_INT 1
39652: ARRAY
39653: PPUSH
39654: LD_EXP 87
39658: PUSH
39659: LD_VAR 0 2
39663: ARRAY
39664: PUSH
39665: LD_INT 1
39667: ARRAY
39668: PUSH
39669: LD_INT 2
39671: ARRAY
39672: PPUSH
39673: CALL_OW 111
// end ; end ; end ;
39677: GO 39090
39679: POP
39680: POP
// end ;
39681: LD_VAR 0 1
39685: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39686: LD_INT 0
39688: PPUSH
39689: PPUSH
39690: PPUSH
39691: PPUSH
39692: PPUSH
39693: PPUSH
39694: PPUSH
39695: PPUSH
39696: PPUSH
39697: PPUSH
39698: PPUSH
// if not mc_bases then
39699: LD_EXP 50
39703: NOT
39704: IFFALSE 39708
// exit ;
39706: GO 40648
// for i = 1 to mc_bases do
39708: LD_ADDR_VAR 0 2
39712: PUSH
39713: DOUBLE
39714: LD_INT 1
39716: DEC
39717: ST_TO_ADDR
39718: LD_EXP 50
39722: PUSH
39723: FOR_TO
39724: IFFALSE 40646
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39726: LD_EXP 50
39730: PUSH
39731: LD_VAR 0 2
39735: ARRAY
39736: NOT
39737: PUSH
39738: LD_EXP 73
39742: PUSH
39743: LD_VAR 0 2
39747: ARRAY
39748: OR
39749: IFFALSE 39753
// continue ;
39751: GO 39723
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39753: LD_ADDR_VAR 0 7
39757: PUSH
39758: LD_EXP 50
39762: PUSH
39763: LD_VAR 0 2
39767: ARRAY
39768: PUSH
39769: LD_INT 1
39771: ARRAY
39772: PPUSH
39773: CALL_OW 248
39777: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39778: LD_VAR 0 7
39782: PUSH
39783: LD_INT 3
39785: EQUAL
39786: PUSH
39787: LD_EXP 69
39791: PUSH
39792: LD_VAR 0 2
39796: ARRAY
39797: PUSH
39798: LD_EXP 72
39802: PUSH
39803: LD_VAR 0 2
39807: ARRAY
39808: UNION
39809: PPUSH
39810: LD_INT 33
39812: PUSH
39813: LD_INT 2
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PPUSH
39820: CALL_OW 72
39824: NOT
39825: OR
39826: IFFALSE 39830
// continue ;
39828: GO 39723
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39830: LD_ADDR_VAR 0 9
39834: PUSH
39835: LD_EXP 50
39839: PUSH
39840: LD_VAR 0 2
39844: ARRAY
39845: PPUSH
39846: LD_INT 30
39848: PUSH
39849: LD_INT 36
39851: PUSH
39852: EMPTY
39853: LIST
39854: LIST
39855: PPUSH
39856: CALL_OW 72
39860: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39861: LD_ADDR_VAR 0 10
39865: PUSH
39866: LD_EXP 69
39870: PUSH
39871: LD_VAR 0 2
39875: ARRAY
39876: PPUSH
39877: LD_INT 34
39879: PUSH
39880: LD_INT 31
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PPUSH
39887: CALL_OW 72
39891: ST_TO_ADDR
// if not cts and not mcts then
39892: LD_VAR 0 9
39896: NOT
39897: PUSH
39898: LD_VAR 0 10
39902: NOT
39903: AND
39904: IFFALSE 39908
// continue ;
39906: GO 39723
// x := cts ;
39908: LD_ADDR_VAR 0 11
39912: PUSH
39913: LD_VAR 0 9
39917: ST_TO_ADDR
// if not x then
39918: LD_VAR 0 11
39922: NOT
39923: IFFALSE 39935
// x := mcts ;
39925: LD_ADDR_VAR 0 11
39929: PUSH
39930: LD_VAR 0 10
39934: ST_TO_ADDR
// if not x then
39935: LD_VAR 0 11
39939: NOT
39940: IFFALSE 39944
// continue ;
39942: GO 39723
// if mc_remote_driver [ i ] then
39944: LD_EXP 90
39948: PUSH
39949: LD_VAR 0 2
39953: ARRAY
39954: IFFALSE 40341
// for j in mc_remote_driver [ i ] do
39956: LD_ADDR_VAR 0 3
39960: PUSH
39961: LD_EXP 90
39965: PUSH
39966: LD_VAR 0 2
39970: ARRAY
39971: PUSH
39972: FOR_IN
39973: IFFALSE 40339
// begin if GetClass ( j ) <> 3 then
39975: LD_VAR 0 3
39979: PPUSH
39980: CALL_OW 257
39984: PUSH
39985: LD_INT 3
39987: NONEQUAL
39988: IFFALSE 40041
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39990: LD_ADDR_EXP 90
39994: PUSH
39995: LD_EXP 90
39999: PPUSH
40000: LD_VAR 0 2
40004: PPUSH
40005: LD_EXP 90
40009: PUSH
40010: LD_VAR 0 2
40014: ARRAY
40015: PUSH
40016: LD_VAR 0 3
40020: DIFF
40021: PPUSH
40022: CALL_OW 1
40026: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40027: LD_VAR 0 3
40031: PPUSH
40032: LD_INT 0
40034: PPUSH
40035: CALL_OW 109
// continue ;
40039: GO 39972
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40041: LD_EXP 69
40045: PUSH
40046: LD_VAR 0 2
40050: ARRAY
40051: PPUSH
40052: LD_INT 34
40054: PUSH
40055: LD_INT 31
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: LD_INT 58
40064: PUSH
40065: EMPTY
40066: LIST
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PPUSH
40072: CALL_OW 72
40076: PUSH
40077: LD_VAR 0 3
40081: PPUSH
40082: CALL 83732 0 1
40086: NOT
40087: AND
40088: IFFALSE 40159
// begin if IsInUnit ( j ) then
40090: LD_VAR 0 3
40094: PPUSH
40095: CALL_OW 310
40099: IFFALSE 40110
// ComExitBuilding ( j ) ;
40101: LD_VAR 0 3
40105: PPUSH
40106: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40110: LD_VAR 0 3
40114: PPUSH
40115: LD_EXP 69
40119: PUSH
40120: LD_VAR 0 2
40124: ARRAY
40125: PPUSH
40126: LD_INT 34
40128: PUSH
40129: LD_INT 31
40131: PUSH
40132: EMPTY
40133: LIST
40134: LIST
40135: PUSH
40136: LD_INT 58
40138: PUSH
40139: EMPTY
40140: LIST
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PPUSH
40146: CALL_OW 72
40150: PUSH
40151: LD_INT 1
40153: ARRAY
40154: PPUSH
40155: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40159: LD_VAR 0 3
40163: PPUSH
40164: CALL_OW 310
40168: NOT
40169: PUSH
40170: LD_VAR 0 3
40174: PPUSH
40175: CALL_OW 310
40179: PPUSH
40180: CALL_OW 266
40184: PUSH
40185: LD_INT 36
40187: NONEQUAL
40188: PUSH
40189: LD_VAR 0 3
40193: PPUSH
40194: CALL 83732 0 1
40198: NOT
40199: AND
40200: OR
40201: IFFALSE 40337
// begin if IsInUnit ( j ) then
40203: LD_VAR 0 3
40207: PPUSH
40208: CALL_OW 310
40212: IFFALSE 40223
// ComExitBuilding ( j ) ;
40214: LD_VAR 0 3
40218: PPUSH
40219: CALL_OW 122
// ct := 0 ;
40223: LD_ADDR_VAR 0 8
40227: PUSH
40228: LD_INT 0
40230: ST_TO_ADDR
// for k in x do
40231: LD_ADDR_VAR 0 4
40235: PUSH
40236: LD_VAR 0 11
40240: PUSH
40241: FOR_IN
40242: IFFALSE 40315
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40244: LD_VAR 0 4
40248: PPUSH
40249: CALL_OW 264
40253: PUSH
40254: LD_INT 31
40256: EQUAL
40257: PUSH
40258: LD_VAR 0 4
40262: PPUSH
40263: CALL_OW 311
40267: NOT
40268: AND
40269: PUSH
40270: LD_VAR 0 4
40274: PPUSH
40275: CALL_OW 266
40279: PUSH
40280: LD_INT 36
40282: EQUAL
40283: PUSH
40284: LD_VAR 0 4
40288: PPUSH
40289: CALL_OW 313
40293: PUSH
40294: LD_INT 3
40296: LESS
40297: AND
40298: OR
40299: IFFALSE 40313
// begin ct := k ;
40301: LD_ADDR_VAR 0 8
40305: PUSH
40306: LD_VAR 0 4
40310: ST_TO_ADDR
// break ;
40311: GO 40315
// end ;
40313: GO 40241
40315: POP
40316: POP
// if ct then
40317: LD_VAR 0 8
40321: IFFALSE 40337
// ComEnterUnit ( j , ct ) ;
40323: LD_VAR 0 3
40327: PPUSH
40328: LD_VAR 0 8
40332: PPUSH
40333: CALL_OW 120
// end ; end ;
40337: GO 39972
40339: POP
40340: POP
// places := 0 ;
40341: LD_ADDR_VAR 0 5
40345: PUSH
40346: LD_INT 0
40348: ST_TO_ADDR
// for j = 1 to x do
40349: LD_ADDR_VAR 0 3
40353: PUSH
40354: DOUBLE
40355: LD_INT 1
40357: DEC
40358: ST_TO_ADDR
40359: LD_VAR 0 11
40363: PUSH
40364: FOR_TO
40365: IFFALSE 40441
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40367: LD_VAR 0 11
40371: PUSH
40372: LD_VAR 0 3
40376: ARRAY
40377: PPUSH
40378: CALL_OW 264
40382: PUSH
40383: LD_INT 31
40385: EQUAL
40386: IFFALSE 40404
// places := places + 1 else
40388: LD_ADDR_VAR 0 5
40392: PUSH
40393: LD_VAR 0 5
40397: PUSH
40398: LD_INT 1
40400: PLUS
40401: ST_TO_ADDR
40402: GO 40439
// if GetBType ( x [ j ] ) = b_control_tower then
40404: LD_VAR 0 11
40408: PUSH
40409: LD_VAR 0 3
40413: ARRAY
40414: PPUSH
40415: CALL_OW 266
40419: PUSH
40420: LD_INT 36
40422: EQUAL
40423: IFFALSE 40439
// places := places + 3 ;
40425: LD_ADDR_VAR 0 5
40429: PUSH
40430: LD_VAR 0 5
40434: PUSH
40435: LD_INT 3
40437: PLUS
40438: ST_TO_ADDR
40439: GO 40364
40441: POP
40442: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40443: LD_VAR 0 5
40447: PUSH
40448: LD_INT 0
40450: EQUAL
40451: PUSH
40452: LD_VAR 0 5
40456: PUSH
40457: LD_EXP 90
40461: PUSH
40462: LD_VAR 0 2
40466: ARRAY
40467: LESSEQUAL
40468: OR
40469: IFFALSE 40473
// continue ;
40471: GO 39723
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40473: LD_ADDR_VAR 0 6
40477: PUSH
40478: LD_EXP 50
40482: PUSH
40483: LD_VAR 0 2
40487: ARRAY
40488: PPUSH
40489: LD_INT 25
40491: PUSH
40492: LD_INT 3
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PPUSH
40499: CALL_OW 72
40503: PUSH
40504: LD_EXP 90
40508: PUSH
40509: LD_VAR 0 2
40513: ARRAY
40514: DIFF
40515: PPUSH
40516: LD_INT 3
40518: PPUSH
40519: CALL 84632 0 2
40523: ST_TO_ADDR
// for j in tmp do
40524: LD_ADDR_VAR 0 3
40528: PUSH
40529: LD_VAR 0 6
40533: PUSH
40534: FOR_IN
40535: IFFALSE 40570
// if GetTag ( j ) > 0 then
40537: LD_VAR 0 3
40541: PPUSH
40542: CALL_OW 110
40546: PUSH
40547: LD_INT 0
40549: GREATER
40550: IFFALSE 40568
// tmp := tmp diff j ;
40552: LD_ADDR_VAR 0 6
40556: PUSH
40557: LD_VAR 0 6
40561: PUSH
40562: LD_VAR 0 3
40566: DIFF
40567: ST_TO_ADDR
40568: GO 40534
40570: POP
40571: POP
// if not tmp then
40572: LD_VAR 0 6
40576: NOT
40577: IFFALSE 40581
// continue ;
40579: GO 39723
// if places then
40581: LD_VAR 0 5
40585: IFFALSE 40644
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40587: LD_ADDR_EXP 90
40591: PUSH
40592: LD_EXP 90
40596: PPUSH
40597: LD_VAR 0 2
40601: PPUSH
40602: LD_EXP 90
40606: PUSH
40607: LD_VAR 0 2
40611: ARRAY
40612: PUSH
40613: LD_VAR 0 6
40617: PUSH
40618: LD_INT 1
40620: ARRAY
40621: UNION
40622: PPUSH
40623: CALL_OW 1
40627: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40628: LD_VAR 0 6
40632: PUSH
40633: LD_INT 1
40635: ARRAY
40636: PPUSH
40637: LD_INT 126
40639: PPUSH
40640: CALL_OW 109
// end ; end ;
40644: GO 39723
40646: POP
40647: POP
// end ;
40648: LD_VAR 0 1
40652: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40653: LD_INT 0
40655: PPUSH
40656: PPUSH
40657: PPUSH
40658: PPUSH
40659: PPUSH
40660: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40661: LD_VAR 0 1
40665: NOT
40666: PUSH
40667: LD_VAR 0 2
40671: NOT
40672: OR
40673: PUSH
40674: LD_VAR 0 3
40678: NOT
40679: OR
40680: PUSH
40681: LD_VAR 0 4
40685: PUSH
40686: LD_INT 1
40688: PUSH
40689: LD_INT 2
40691: PUSH
40692: LD_INT 3
40694: PUSH
40695: LD_INT 4
40697: PUSH
40698: LD_INT 5
40700: PUSH
40701: LD_INT 8
40703: PUSH
40704: LD_INT 9
40706: PUSH
40707: LD_INT 15
40709: PUSH
40710: LD_INT 16
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: LIST
40717: LIST
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: LIST
40723: IN
40724: NOT
40725: OR
40726: IFFALSE 40730
// exit ;
40728: GO 41630
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40730: LD_ADDR_VAR 0 2
40734: PUSH
40735: LD_VAR 0 2
40739: PPUSH
40740: LD_INT 21
40742: PUSH
40743: LD_INT 3
40745: PUSH
40746: EMPTY
40747: LIST
40748: LIST
40749: PUSH
40750: LD_INT 24
40752: PUSH
40753: LD_INT 250
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PPUSH
40764: CALL_OW 72
40768: ST_TO_ADDR
// case class of 1 , 15 :
40769: LD_VAR 0 4
40773: PUSH
40774: LD_INT 1
40776: DOUBLE
40777: EQUAL
40778: IFTRUE 40788
40780: LD_INT 15
40782: DOUBLE
40783: EQUAL
40784: IFTRUE 40788
40786: GO 40873
40788: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40789: LD_ADDR_VAR 0 8
40793: PUSH
40794: LD_VAR 0 2
40798: PPUSH
40799: LD_INT 2
40801: PUSH
40802: LD_INT 30
40804: PUSH
40805: LD_INT 32
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 30
40814: PUSH
40815: LD_INT 31
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: LIST
40826: PPUSH
40827: CALL_OW 72
40831: PUSH
40832: LD_VAR 0 2
40836: PPUSH
40837: LD_INT 2
40839: PUSH
40840: LD_INT 30
40842: PUSH
40843: LD_INT 4
40845: PUSH
40846: EMPTY
40847: LIST
40848: LIST
40849: PUSH
40850: LD_INT 30
40852: PUSH
40853: LD_INT 5
40855: PUSH
40856: EMPTY
40857: LIST
40858: LIST
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: LIST
40864: PPUSH
40865: CALL_OW 72
40869: ADD
40870: ST_TO_ADDR
40871: GO 41119
40873: LD_INT 2
40875: DOUBLE
40876: EQUAL
40877: IFTRUE 40887
40879: LD_INT 16
40881: DOUBLE
40882: EQUAL
40883: IFTRUE 40887
40885: GO 40933
40887: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40888: LD_ADDR_VAR 0 8
40892: PUSH
40893: LD_VAR 0 2
40897: PPUSH
40898: LD_INT 2
40900: PUSH
40901: LD_INT 30
40903: PUSH
40904: LD_INT 0
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: LD_INT 30
40913: PUSH
40914: LD_INT 1
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: LIST
40925: PPUSH
40926: CALL_OW 72
40930: ST_TO_ADDR
40931: GO 41119
40933: LD_INT 3
40935: DOUBLE
40936: EQUAL
40937: IFTRUE 40941
40939: GO 40987
40941: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40942: LD_ADDR_VAR 0 8
40946: PUSH
40947: LD_VAR 0 2
40951: PPUSH
40952: LD_INT 2
40954: PUSH
40955: LD_INT 30
40957: PUSH
40958: LD_INT 2
40960: PUSH
40961: EMPTY
40962: LIST
40963: LIST
40964: PUSH
40965: LD_INT 30
40967: PUSH
40968: LD_INT 3
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: EMPTY
40976: LIST
40977: LIST
40978: LIST
40979: PPUSH
40980: CALL_OW 72
40984: ST_TO_ADDR
40985: GO 41119
40987: LD_INT 4
40989: DOUBLE
40990: EQUAL
40991: IFTRUE 40995
40993: GO 41052
40995: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40996: LD_ADDR_VAR 0 8
41000: PUSH
41001: LD_VAR 0 2
41005: PPUSH
41006: LD_INT 2
41008: PUSH
41009: LD_INT 30
41011: PUSH
41012: LD_INT 6
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 30
41021: PUSH
41022: LD_INT 7
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: PUSH
41029: LD_INT 30
41031: PUSH
41032: LD_INT 8
41034: PUSH
41035: EMPTY
41036: LIST
41037: LIST
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: LIST
41043: LIST
41044: PPUSH
41045: CALL_OW 72
41049: ST_TO_ADDR
41050: GO 41119
41052: LD_INT 5
41054: DOUBLE
41055: EQUAL
41056: IFTRUE 41072
41058: LD_INT 8
41060: DOUBLE
41061: EQUAL
41062: IFTRUE 41072
41064: LD_INT 9
41066: DOUBLE
41067: EQUAL
41068: IFTRUE 41072
41070: GO 41118
41072: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41073: LD_ADDR_VAR 0 8
41077: PUSH
41078: LD_VAR 0 2
41082: PPUSH
41083: LD_INT 2
41085: PUSH
41086: LD_INT 30
41088: PUSH
41089: LD_INT 4
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: PUSH
41096: LD_INT 30
41098: PUSH
41099: LD_INT 5
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: LIST
41110: PPUSH
41111: CALL_OW 72
41115: ST_TO_ADDR
41116: GO 41119
41118: POP
// if not tmp then
41119: LD_VAR 0 8
41123: NOT
41124: IFFALSE 41128
// exit ;
41126: GO 41630
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41128: LD_VAR 0 4
41132: PUSH
41133: LD_INT 1
41135: PUSH
41136: LD_INT 15
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: IN
41143: PUSH
41144: LD_EXP 59
41148: PUSH
41149: LD_VAR 0 1
41153: ARRAY
41154: AND
41155: IFFALSE 41311
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41157: LD_ADDR_VAR 0 9
41161: PUSH
41162: LD_EXP 59
41166: PUSH
41167: LD_VAR 0 1
41171: ARRAY
41172: PUSH
41173: LD_INT 1
41175: ARRAY
41176: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41177: LD_VAR 0 9
41181: PUSH
41182: LD_EXP 60
41186: PUSH
41187: LD_VAR 0 1
41191: ARRAY
41192: IN
41193: NOT
41194: IFFALSE 41309
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41196: LD_ADDR_EXP 60
41200: PUSH
41201: LD_EXP 60
41205: PPUSH
41206: LD_VAR 0 1
41210: PUSH
41211: LD_EXP 60
41215: PUSH
41216: LD_VAR 0 1
41220: ARRAY
41221: PUSH
41222: LD_INT 1
41224: PLUS
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: PPUSH
41230: LD_VAR 0 9
41234: PPUSH
41235: CALL 53785 0 3
41239: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41240: LD_ADDR_EXP 59
41244: PUSH
41245: LD_EXP 59
41249: PPUSH
41250: LD_VAR 0 1
41254: PPUSH
41255: LD_EXP 59
41259: PUSH
41260: LD_VAR 0 1
41264: ARRAY
41265: PUSH
41266: LD_VAR 0 9
41270: DIFF
41271: PPUSH
41272: CALL_OW 1
41276: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41277: LD_VAR 0 3
41281: PPUSH
41282: LD_EXP 60
41286: PUSH
41287: LD_VAR 0 1
41291: ARRAY
41292: PUSH
41293: LD_EXP 60
41297: PUSH
41298: LD_VAR 0 1
41302: ARRAY
41303: ARRAY
41304: PPUSH
41305: CALL_OW 120
// end ; exit ;
41309: GO 41630
// end ; if tmp > 1 then
41311: LD_VAR 0 8
41315: PUSH
41316: LD_INT 1
41318: GREATER
41319: IFFALSE 41423
// for i = 2 to tmp do
41321: LD_ADDR_VAR 0 6
41325: PUSH
41326: DOUBLE
41327: LD_INT 2
41329: DEC
41330: ST_TO_ADDR
41331: LD_VAR 0 8
41335: PUSH
41336: FOR_TO
41337: IFFALSE 41421
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41339: LD_VAR 0 8
41343: PUSH
41344: LD_VAR 0 6
41348: ARRAY
41349: PPUSH
41350: CALL_OW 461
41354: PUSH
41355: LD_INT 6
41357: EQUAL
41358: IFFALSE 41419
// begin x := tmp [ i ] ;
41360: LD_ADDR_VAR 0 9
41364: PUSH
41365: LD_VAR 0 8
41369: PUSH
41370: LD_VAR 0 6
41374: ARRAY
41375: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41376: LD_ADDR_VAR 0 8
41380: PUSH
41381: LD_VAR 0 8
41385: PPUSH
41386: LD_VAR 0 6
41390: PPUSH
41391: CALL_OW 3
41395: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41396: LD_ADDR_VAR 0 8
41400: PUSH
41401: LD_VAR 0 8
41405: PPUSH
41406: LD_INT 1
41408: PPUSH
41409: LD_VAR 0 9
41413: PPUSH
41414: CALL_OW 2
41418: ST_TO_ADDR
// end ;
41419: GO 41336
41421: POP
41422: POP
// for i in tmp do
41423: LD_ADDR_VAR 0 6
41427: PUSH
41428: LD_VAR 0 8
41432: PUSH
41433: FOR_IN
41434: IFFALSE 41503
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41436: LD_VAR 0 6
41440: PPUSH
41441: CALL_OW 313
41445: PUSH
41446: LD_INT 6
41448: LESS
41449: PUSH
41450: LD_VAR 0 6
41454: PPUSH
41455: CALL_OW 266
41459: PUSH
41460: LD_INT 31
41462: PUSH
41463: LD_INT 32
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: IN
41470: NOT
41471: AND
41472: PUSH
41473: LD_VAR 0 6
41477: PPUSH
41478: CALL_OW 313
41482: PUSH
41483: LD_INT 0
41485: EQUAL
41486: OR
41487: IFFALSE 41501
// begin j := i ;
41489: LD_ADDR_VAR 0 7
41493: PUSH
41494: LD_VAR 0 6
41498: ST_TO_ADDR
// break ;
41499: GO 41503
// end ; end ;
41501: GO 41433
41503: POP
41504: POP
// if j then
41505: LD_VAR 0 7
41509: IFFALSE 41527
// ComEnterUnit ( unit , j ) else
41511: LD_VAR 0 3
41515: PPUSH
41516: LD_VAR 0 7
41520: PPUSH
41521: CALL_OW 120
41525: GO 41630
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41527: LD_ADDR_VAR 0 10
41531: PUSH
41532: LD_VAR 0 2
41536: PPUSH
41537: LD_INT 2
41539: PUSH
41540: LD_INT 30
41542: PUSH
41543: LD_INT 0
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: PUSH
41550: LD_INT 30
41552: PUSH
41553: LD_INT 1
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: LIST
41564: PPUSH
41565: CALL_OW 72
41569: ST_TO_ADDR
// if depot then
41570: LD_VAR 0 10
41574: IFFALSE 41630
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41576: LD_ADDR_VAR 0 10
41580: PUSH
41581: LD_VAR 0 10
41585: PPUSH
41586: LD_VAR 0 3
41590: PPUSH
41591: CALL_OW 74
41595: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41596: LD_VAR 0 3
41600: PPUSH
41601: LD_VAR 0 10
41605: PPUSH
41606: CALL_OW 296
41610: PUSH
41611: LD_INT 10
41613: GREATER
41614: IFFALSE 41630
// ComStandNearbyBuilding ( unit , depot ) ;
41616: LD_VAR 0 3
41620: PPUSH
41621: LD_VAR 0 10
41625: PPUSH
41626: CALL 50212 0 2
// end ; end ; end ;
41630: LD_VAR 0 5
41634: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41635: LD_INT 0
41637: PPUSH
41638: PPUSH
41639: PPUSH
41640: PPUSH
// if not mc_bases then
41641: LD_EXP 50
41645: NOT
41646: IFFALSE 41650
// exit ;
41648: GO 41889
// for i = 1 to mc_bases do
41650: LD_ADDR_VAR 0 2
41654: PUSH
41655: DOUBLE
41656: LD_INT 1
41658: DEC
41659: ST_TO_ADDR
41660: LD_EXP 50
41664: PUSH
41665: FOR_TO
41666: IFFALSE 41887
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41668: LD_ADDR_VAR 0 4
41672: PUSH
41673: LD_EXP 50
41677: PUSH
41678: LD_VAR 0 2
41682: ARRAY
41683: PPUSH
41684: LD_INT 21
41686: PUSH
41687: LD_INT 1
41689: PUSH
41690: EMPTY
41691: LIST
41692: LIST
41693: PPUSH
41694: CALL_OW 72
41698: PUSH
41699: LD_EXP 79
41703: PUSH
41704: LD_VAR 0 2
41708: ARRAY
41709: UNION
41710: ST_TO_ADDR
// if not tmp then
41711: LD_VAR 0 4
41715: NOT
41716: IFFALSE 41720
// continue ;
41718: GO 41665
// for j in tmp do
41720: LD_ADDR_VAR 0 3
41724: PUSH
41725: LD_VAR 0 4
41729: PUSH
41730: FOR_IN
41731: IFFALSE 41883
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41733: LD_VAR 0 3
41737: PPUSH
41738: CALL_OW 110
41742: NOT
41743: PUSH
41744: LD_VAR 0 3
41748: PPUSH
41749: CALL_OW 314
41753: NOT
41754: AND
41755: PUSH
41756: LD_VAR 0 3
41760: PPUSH
41761: CALL_OW 311
41765: NOT
41766: AND
41767: PUSH
41768: LD_VAR 0 3
41772: PPUSH
41773: CALL_OW 310
41777: NOT
41778: AND
41779: PUSH
41780: LD_VAR 0 3
41784: PUSH
41785: LD_EXP 53
41789: PUSH
41790: LD_VAR 0 2
41794: ARRAY
41795: PUSH
41796: LD_INT 1
41798: ARRAY
41799: IN
41800: NOT
41801: AND
41802: PUSH
41803: LD_VAR 0 3
41807: PUSH
41808: LD_EXP 53
41812: PUSH
41813: LD_VAR 0 2
41817: ARRAY
41818: PUSH
41819: LD_INT 2
41821: ARRAY
41822: IN
41823: NOT
41824: AND
41825: PUSH
41826: LD_VAR 0 3
41830: PUSH
41831: LD_EXP 62
41835: PUSH
41836: LD_VAR 0 2
41840: ARRAY
41841: IN
41842: NOT
41843: AND
41844: IFFALSE 41881
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41846: LD_VAR 0 2
41850: PPUSH
41851: LD_EXP 50
41855: PUSH
41856: LD_VAR 0 2
41860: ARRAY
41861: PPUSH
41862: LD_VAR 0 3
41866: PPUSH
41867: LD_VAR 0 3
41871: PPUSH
41872: CALL_OW 257
41876: PPUSH
41877: CALL 40653 0 4
// end ;
41881: GO 41730
41883: POP
41884: POP
// end ;
41885: GO 41665
41887: POP
41888: POP
// end ;
41889: LD_VAR 0 1
41893: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41894: LD_INT 0
41896: PPUSH
41897: PPUSH
41898: PPUSH
41899: PPUSH
41900: PPUSH
41901: PPUSH
// if not mc_bases [ base ] then
41902: LD_EXP 50
41906: PUSH
41907: LD_VAR 0 1
41911: ARRAY
41912: NOT
41913: IFFALSE 41917
// exit ;
41915: GO 42099
// tmp := [ ] ;
41917: LD_ADDR_VAR 0 6
41921: PUSH
41922: EMPTY
41923: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41924: LD_ADDR_VAR 0 7
41928: PUSH
41929: LD_VAR 0 3
41933: PPUSH
41934: LD_INT 0
41936: PPUSH
41937: CALL_OW 517
41941: ST_TO_ADDR
// if not list then
41942: LD_VAR 0 7
41946: NOT
41947: IFFALSE 41951
// exit ;
41949: GO 42099
// for i = 1 to amount do
41951: LD_ADDR_VAR 0 5
41955: PUSH
41956: DOUBLE
41957: LD_INT 1
41959: DEC
41960: ST_TO_ADDR
41961: LD_VAR 0 2
41965: PUSH
41966: FOR_TO
41967: IFFALSE 42047
// begin x := rand ( 1 , list [ 1 ] ) ;
41969: LD_ADDR_VAR 0 8
41973: PUSH
41974: LD_INT 1
41976: PPUSH
41977: LD_VAR 0 7
41981: PUSH
41982: LD_INT 1
41984: ARRAY
41985: PPUSH
41986: CALL_OW 12
41990: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41991: LD_ADDR_VAR 0 6
41995: PUSH
41996: LD_VAR 0 6
42000: PPUSH
42001: LD_VAR 0 5
42005: PPUSH
42006: LD_VAR 0 7
42010: PUSH
42011: LD_INT 1
42013: ARRAY
42014: PUSH
42015: LD_VAR 0 8
42019: ARRAY
42020: PUSH
42021: LD_VAR 0 7
42025: PUSH
42026: LD_INT 2
42028: ARRAY
42029: PUSH
42030: LD_VAR 0 8
42034: ARRAY
42035: PUSH
42036: EMPTY
42037: LIST
42038: LIST
42039: PPUSH
42040: CALL_OW 1
42044: ST_TO_ADDR
// end ;
42045: GO 41966
42047: POP
42048: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42049: LD_ADDR_EXP 63
42053: PUSH
42054: LD_EXP 63
42058: PPUSH
42059: LD_VAR 0 1
42063: PPUSH
42064: LD_VAR 0 6
42068: PPUSH
42069: CALL_OW 1
42073: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42074: LD_ADDR_EXP 65
42078: PUSH
42079: LD_EXP 65
42083: PPUSH
42084: LD_VAR 0 1
42088: PPUSH
42089: LD_VAR 0 3
42093: PPUSH
42094: CALL_OW 1
42098: ST_TO_ADDR
// end ;
42099: LD_VAR 0 4
42103: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42104: LD_INT 0
42106: PPUSH
// if not mc_bases [ base ] then
42107: LD_EXP 50
42111: PUSH
42112: LD_VAR 0 1
42116: ARRAY
42117: NOT
42118: IFFALSE 42122
// exit ;
42120: GO 42147
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42122: LD_ADDR_EXP 55
42126: PUSH
42127: LD_EXP 55
42131: PPUSH
42132: LD_VAR 0 1
42136: PPUSH
42137: LD_VAR 0 2
42141: PPUSH
42142: CALL_OW 1
42146: ST_TO_ADDR
// end ;
42147: LD_VAR 0 3
42151: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42152: LD_INT 0
42154: PPUSH
// if not mc_bases [ base ] then
42155: LD_EXP 50
42159: PUSH
42160: LD_VAR 0 1
42164: ARRAY
42165: NOT
42166: IFFALSE 42170
// exit ;
42168: GO 42207
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42170: LD_ADDR_EXP 55
42174: PUSH
42175: LD_EXP 55
42179: PPUSH
42180: LD_VAR 0 1
42184: PPUSH
42185: LD_EXP 55
42189: PUSH
42190: LD_VAR 0 1
42194: ARRAY
42195: PUSH
42196: LD_VAR 0 2
42200: UNION
42201: PPUSH
42202: CALL_OW 1
42206: ST_TO_ADDR
// end ;
42207: LD_VAR 0 3
42211: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42212: LD_INT 0
42214: PPUSH
// if not mc_bases [ base ] then
42215: LD_EXP 50
42219: PUSH
42220: LD_VAR 0 1
42224: ARRAY
42225: NOT
42226: IFFALSE 42230
// exit ;
42228: GO 42255
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42230: LD_ADDR_EXP 71
42234: PUSH
42235: LD_EXP 71
42239: PPUSH
42240: LD_VAR 0 1
42244: PPUSH
42245: LD_VAR 0 2
42249: PPUSH
42250: CALL_OW 1
42254: ST_TO_ADDR
// end ;
42255: LD_VAR 0 3
42259: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42260: LD_INT 0
42262: PPUSH
// if not mc_bases [ base ] then
42263: LD_EXP 50
42267: PUSH
42268: LD_VAR 0 1
42272: ARRAY
42273: NOT
42274: IFFALSE 42278
// exit ;
42276: GO 42315
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42278: LD_ADDR_EXP 71
42282: PUSH
42283: LD_EXP 71
42287: PPUSH
42288: LD_VAR 0 1
42292: PPUSH
42293: LD_EXP 71
42297: PUSH
42298: LD_VAR 0 1
42302: ARRAY
42303: PUSH
42304: LD_VAR 0 2
42308: ADD
42309: PPUSH
42310: CALL_OW 1
42314: ST_TO_ADDR
// end ;
42315: LD_VAR 0 3
42319: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42320: LD_INT 0
42322: PPUSH
// if not mc_bases [ base ] then
42323: LD_EXP 50
42327: PUSH
42328: LD_VAR 0 1
42332: ARRAY
42333: NOT
42334: IFFALSE 42338
// exit ;
42336: GO 42392
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42338: LD_ADDR_EXP 72
42342: PUSH
42343: LD_EXP 72
42347: PPUSH
42348: LD_VAR 0 1
42352: PPUSH
42353: LD_VAR 0 2
42357: PPUSH
42358: CALL_OW 1
42362: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42363: LD_ADDR_EXP 61
42367: PUSH
42368: LD_EXP 61
42372: PPUSH
42373: LD_VAR 0 1
42377: PPUSH
42378: LD_VAR 0 2
42382: PUSH
42383: LD_INT 0
42385: PLUS
42386: PPUSH
42387: CALL_OW 1
42391: ST_TO_ADDR
// end ;
42392: LD_VAR 0 3
42396: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42397: LD_INT 0
42399: PPUSH
// if not mc_bases [ base ] then
42400: LD_EXP 50
42404: PUSH
42405: LD_VAR 0 1
42409: ARRAY
42410: NOT
42411: IFFALSE 42415
// exit ;
42413: GO 42440
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42415: LD_ADDR_EXP 61
42419: PUSH
42420: LD_EXP 61
42424: PPUSH
42425: LD_VAR 0 1
42429: PPUSH
42430: LD_VAR 0 2
42434: PPUSH
42435: CALL_OW 1
42439: ST_TO_ADDR
// end ;
42440: LD_VAR 0 3
42444: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42445: LD_INT 0
42447: PPUSH
42448: PPUSH
42449: PPUSH
42450: PPUSH
// if not mc_bases [ base ] then
42451: LD_EXP 50
42455: PUSH
42456: LD_VAR 0 1
42460: ARRAY
42461: NOT
42462: IFFALSE 42466
// exit ;
42464: GO 42531
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42466: LD_ADDR_EXP 70
42470: PUSH
42471: LD_EXP 70
42475: PPUSH
42476: LD_VAR 0 1
42480: PUSH
42481: LD_EXP 70
42485: PUSH
42486: LD_VAR 0 1
42490: ARRAY
42491: PUSH
42492: LD_INT 1
42494: PLUS
42495: PUSH
42496: EMPTY
42497: LIST
42498: LIST
42499: PPUSH
42500: LD_VAR 0 1
42504: PUSH
42505: LD_VAR 0 2
42509: PUSH
42510: LD_VAR 0 3
42514: PUSH
42515: LD_VAR 0 4
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: LIST
42524: LIST
42525: PPUSH
42526: CALL 53785 0 3
42530: ST_TO_ADDR
// end ;
42531: LD_VAR 0 5
42535: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42536: LD_INT 0
42538: PPUSH
// if not mc_bases [ base ] then
42539: LD_EXP 50
42543: PUSH
42544: LD_VAR 0 1
42548: ARRAY
42549: NOT
42550: IFFALSE 42554
// exit ;
42552: GO 42579
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42554: LD_ADDR_EXP 87
42558: PUSH
42559: LD_EXP 87
42563: PPUSH
42564: LD_VAR 0 1
42568: PPUSH
42569: LD_VAR 0 2
42573: PPUSH
42574: CALL_OW 1
42578: ST_TO_ADDR
// end ;
42579: LD_VAR 0 3
42583: RET
// export function MC_GetMinesField ( base ) ; begin
42584: LD_INT 0
42586: PPUSH
// result := mc_mines [ base ] ;
42587: LD_ADDR_VAR 0 2
42591: PUSH
42592: LD_EXP 63
42596: PUSH
42597: LD_VAR 0 1
42601: ARRAY
42602: ST_TO_ADDR
// end ;
42603: LD_VAR 0 2
42607: RET
// export function MC_GetProduceList ( base ) ; begin
42608: LD_INT 0
42610: PPUSH
// result := mc_produce [ base ] ;
42611: LD_ADDR_VAR 0 2
42615: PUSH
42616: LD_EXP 71
42620: PUSH
42621: LD_VAR 0 1
42625: ARRAY
42626: ST_TO_ADDR
// end ;
42627: LD_VAR 0 2
42631: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42632: LD_INT 0
42634: PPUSH
42635: PPUSH
// if not mc_bases then
42636: LD_EXP 50
42640: NOT
42641: IFFALSE 42645
// exit ;
42643: GO 42710
// if mc_bases [ base ] then
42645: LD_EXP 50
42649: PUSH
42650: LD_VAR 0 1
42654: ARRAY
42655: IFFALSE 42710
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42657: LD_ADDR_VAR 0 3
42661: PUSH
42662: LD_EXP 50
42666: PUSH
42667: LD_VAR 0 1
42671: ARRAY
42672: PPUSH
42673: LD_INT 30
42675: PUSH
42676: LD_VAR 0 2
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PPUSH
42685: CALL_OW 72
42689: ST_TO_ADDR
// if result then
42690: LD_VAR 0 3
42694: IFFALSE 42710
// result := result [ 1 ] ;
42696: LD_ADDR_VAR 0 3
42700: PUSH
42701: LD_VAR 0 3
42705: PUSH
42706: LD_INT 1
42708: ARRAY
42709: ST_TO_ADDR
// end ; end ;
42710: LD_VAR 0 3
42714: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42715: LD_INT 0
42717: PPUSH
42718: PPUSH
// if not mc_bases then
42719: LD_EXP 50
42723: NOT
42724: IFFALSE 42728
// exit ;
42726: GO 42773
// if mc_bases [ base ] then
42728: LD_EXP 50
42732: PUSH
42733: LD_VAR 0 1
42737: ARRAY
42738: IFFALSE 42773
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42740: LD_ADDR_VAR 0 3
42744: PUSH
42745: LD_EXP 50
42749: PUSH
42750: LD_VAR 0 1
42754: ARRAY
42755: PPUSH
42756: LD_INT 30
42758: PUSH
42759: LD_VAR 0 2
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PPUSH
42768: CALL_OW 72
42772: ST_TO_ADDR
// end ;
42773: LD_VAR 0 3
42777: RET
// export function MC_SetTame ( base , area ) ; begin
42778: LD_INT 0
42780: PPUSH
// if not mc_bases or not base then
42781: LD_EXP 50
42785: NOT
42786: PUSH
42787: LD_VAR 0 1
42791: NOT
42792: OR
42793: IFFALSE 42797
// exit ;
42795: GO 42822
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42797: LD_ADDR_EXP 78
42801: PUSH
42802: LD_EXP 78
42806: PPUSH
42807: LD_VAR 0 1
42811: PPUSH
42812: LD_VAR 0 2
42816: PPUSH
42817: CALL_OW 1
42821: ST_TO_ADDR
// end ;
42822: LD_VAR 0 3
42826: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42827: LD_INT 0
42829: PPUSH
42830: PPUSH
// if not mc_bases or not base then
42831: LD_EXP 50
42835: NOT
42836: PUSH
42837: LD_VAR 0 1
42841: NOT
42842: OR
42843: IFFALSE 42847
// exit ;
42845: GO 42949
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42847: LD_ADDR_VAR 0 4
42851: PUSH
42852: LD_EXP 50
42856: PUSH
42857: LD_VAR 0 1
42861: ARRAY
42862: PPUSH
42863: LD_INT 30
42865: PUSH
42866: LD_VAR 0 2
42870: PUSH
42871: EMPTY
42872: LIST
42873: LIST
42874: PPUSH
42875: CALL_OW 72
42879: ST_TO_ADDR
// if not tmp then
42880: LD_VAR 0 4
42884: NOT
42885: IFFALSE 42889
// exit ;
42887: GO 42949
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42889: LD_ADDR_EXP 82
42893: PUSH
42894: LD_EXP 82
42898: PPUSH
42899: LD_VAR 0 1
42903: PPUSH
42904: LD_EXP 82
42908: PUSH
42909: LD_VAR 0 1
42913: ARRAY
42914: PPUSH
42915: LD_EXP 82
42919: PUSH
42920: LD_VAR 0 1
42924: ARRAY
42925: PUSH
42926: LD_INT 1
42928: PLUS
42929: PPUSH
42930: LD_VAR 0 4
42934: PUSH
42935: LD_INT 1
42937: ARRAY
42938: PPUSH
42939: CALL_OW 2
42943: PPUSH
42944: CALL_OW 1
42948: ST_TO_ADDR
// end ;
42949: LD_VAR 0 3
42953: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42954: LD_INT 0
42956: PPUSH
42957: PPUSH
// if not mc_bases or not base or not kinds then
42958: LD_EXP 50
42962: NOT
42963: PUSH
42964: LD_VAR 0 1
42968: NOT
42969: OR
42970: PUSH
42971: LD_VAR 0 2
42975: NOT
42976: OR
42977: IFFALSE 42981
// exit ;
42979: GO 43042
// for i in kinds do
42981: LD_ADDR_VAR 0 4
42985: PUSH
42986: LD_VAR 0 2
42990: PUSH
42991: FOR_IN
42992: IFFALSE 43040
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42994: LD_ADDR_EXP 84
42998: PUSH
42999: LD_EXP 84
43003: PPUSH
43004: LD_VAR 0 1
43008: PUSH
43009: LD_EXP 84
43013: PUSH
43014: LD_VAR 0 1
43018: ARRAY
43019: PUSH
43020: LD_INT 1
43022: PLUS
43023: PUSH
43024: EMPTY
43025: LIST
43026: LIST
43027: PPUSH
43028: LD_VAR 0 4
43032: PPUSH
43033: CALL 53785 0 3
43037: ST_TO_ADDR
43038: GO 42991
43040: POP
43041: POP
// end ;
43042: LD_VAR 0 3
43046: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43047: LD_INT 0
43049: PPUSH
// if not mc_bases or not base or not areas then
43050: LD_EXP 50
43054: NOT
43055: PUSH
43056: LD_VAR 0 1
43060: NOT
43061: OR
43062: PUSH
43063: LD_VAR 0 2
43067: NOT
43068: OR
43069: IFFALSE 43073
// exit ;
43071: GO 43098
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43073: LD_ADDR_EXP 68
43077: PUSH
43078: LD_EXP 68
43082: PPUSH
43083: LD_VAR 0 1
43087: PPUSH
43088: LD_VAR 0 2
43092: PPUSH
43093: CALL_OW 1
43097: ST_TO_ADDR
// end ;
43098: LD_VAR 0 3
43102: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43103: LD_INT 0
43105: PPUSH
// if not mc_bases or not base or not teleports_exit then
43106: LD_EXP 50
43110: NOT
43111: PUSH
43112: LD_VAR 0 1
43116: NOT
43117: OR
43118: PUSH
43119: LD_VAR 0 2
43123: NOT
43124: OR
43125: IFFALSE 43129
// exit ;
43127: GO 43154
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43129: LD_ADDR_EXP 85
43133: PUSH
43134: LD_EXP 85
43138: PPUSH
43139: LD_VAR 0 1
43143: PPUSH
43144: LD_VAR 0 2
43148: PPUSH
43149: CALL_OW 1
43153: ST_TO_ADDR
// end ;
43154: LD_VAR 0 3
43158: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43159: LD_INT 0
43161: PPUSH
43162: PPUSH
43163: PPUSH
// if not mc_bases or not base or not ext_list then
43164: LD_EXP 50
43168: NOT
43169: PUSH
43170: LD_VAR 0 1
43174: NOT
43175: OR
43176: PUSH
43177: LD_VAR 0 5
43181: NOT
43182: OR
43183: IFFALSE 43187
// exit ;
43185: GO 43360
// tmp := GetFacExtXYD ( x , y , d ) ;
43187: LD_ADDR_VAR 0 8
43191: PUSH
43192: LD_VAR 0 2
43196: PPUSH
43197: LD_VAR 0 3
43201: PPUSH
43202: LD_VAR 0 4
43206: PPUSH
43207: CALL 83762 0 3
43211: ST_TO_ADDR
// if not tmp then
43212: LD_VAR 0 8
43216: NOT
43217: IFFALSE 43221
// exit ;
43219: GO 43360
// for i in tmp do
43221: LD_ADDR_VAR 0 7
43225: PUSH
43226: LD_VAR 0 8
43230: PUSH
43231: FOR_IN
43232: IFFALSE 43358
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43234: LD_ADDR_EXP 55
43238: PUSH
43239: LD_EXP 55
43243: PPUSH
43244: LD_VAR 0 1
43248: PPUSH
43249: LD_EXP 55
43253: PUSH
43254: LD_VAR 0 1
43258: ARRAY
43259: PPUSH
43260: LD_EXP 55
43264: PUSH
43265: LD_VAR 0 1
43269: ARRAY
43270: PUSH
43271: LD_INT 1
43273: PLUS
43274: PPUSH
43275: LD_VAR 0 5
43279: PUSH
43280: LD_INT 1
43282: ARRAY
43283: PUSH
43284: LD_VAR 0 7
43288: PUSH
43289: LD_INT 1
43291: ARRAY
43292: PUSH
43293: LD_VAR 0 7
43297: PUSH
43298: LD_INT 2
43300: ARRAY
43301: PUSH
43302: LD_VAR 0 7
43306: PUSH
43307: LD_INT 3
43309: ARRAY
43310: PUSH
43311: EMPTY
43312: LIST
43313: LIST
43314: LIST
43315: LIST
43316: PPUSH
43317: CALL_OW 2
43321: PPUSH
43322: CALL_OW 1
43326: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43327: LD_ADDR_VAR 0 5
43331: PUSH
43332: LD_VAR 0 5
43336: PPUSH
43337: LD_INT 1
43339: PPUSH
43340: CALL_OW 3
43344: ST_TO_ADDR
// if not ext_list then
43345: LD_VAR 0 5
43349: NOT
43350: IFFALSE 43356
// exit ;
43352: POP
43353: POP
43354: GO 43360
// end ;
43356: GO 43231
43358: POP
43359: POP
// end ;
43360: LD_VAR 0 6
43364: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43365: LD_INT 0
43367: PPUSH
// if not mc_bases or not base or not weapon_list then
43368: LD_EXP 50
43372: NOT
43373: PUSH
43374: LD_VAR 0 1
43378: NOT
43379: OR
43380: PUSH
43381: LD_VAR 0 2
43385: NOT
43386: OR
43387: IFFALSE 43391
// exit ;
43389: GO 43416
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43391: LD_ADDR_EXP 89
43395: PUSH
43396: LD_EXP 89
43400: PPUSH
43401: LD_VAR 0 1
43405: PPUSH
43406: LD_VAR 0 2
43410: PPUSH
43411: CALL_OW 1
43415: ST_TO_ADDR
// end ;
43416: LD_VAR 0 3
43420: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43421: LD_INT 0
43423: PPUSH
// if not mc_bases or not base or not tech_list then
43424: LD_EXP 50
43428: NOT
43429: PUSH
43430: LD_VAR 0 1
43434: NOT
43435: OR
43436: PUSH
43437: LD_VAR 0 2
43441: NOT
43442: OR
43443: IFFALSE 43447
// exit ;
43445: GO 43472
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43447: LD_ADDR_EXP 77
43451: PUSH
43452: LD_EXP 77
43456: PPUSH
43457: LD_VAR 0 1
43461: PPUSH
43462: LD_VAR 0 2
43466: PPUSH
43467: CALL_OW 1
43471: ST_TO_ADDR
// end ;
43472: LD_VAR 0 3
43476: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43477: LD_INT 0
43479: PPUSH
// if not mc_bases or not parking_area or not base then
43480: LD_EXP 50
43484: NOT
43485: PUSH
43486: LD_VAR 0 2
43490: NOT
43491: OR
43492: PUSH
43493: LD_VAR 0 1
43497: NOT
43498: OR
43499: IFFALSE 43503
// exit ;
43501: GO 43528
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43503: LD_ADDR_EXP 74
43507: PUSH
43508: LD_EXP 74
43512: PPUSH
43513: LD_VAR 0 1
43517: PPUSH
43518: LD_VAR 0 2
43522: PPUSH
43523: CALL_OW 1
43527: ST_TO_ADDR
// end ;
43528: LD_VAR 0 3
43532: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43533: LD_INT 0
43535: PPUSH
// if not mc_bases or not base or not scan_area then
43536: LD_EXP 50
43540: NOT
43541: PUSH
43542: LD_VAR 0 1
43546: NOT
43547: OR
43548: PUSH
43549: LD_VAR 0 2
43553: NOT
43554: OR
43555: IFFALSE 43559
// exit ;
43557: GO 43584
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43559: LD_ADDR_EXP 75
43563: PUSH
43564: LD_EXP 75
43568: PPUSH
43569: LD_VAR 0 1
43573: PPUSH
43574: LD_VAR 0 2
43578: PPUSH
43579: CALL_OW 1
43583: ST_TO_ADDR
// end ;
43584: LD_VAR 0 3
43588: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43589: LD_INT 0
43591: PPUSH
43592: PPUSH
// if not mc_bases or not base then
43593: LD_EXP 50
43597: NOT
43598: PUSH
43599: LD_VAR 0 1
43603: NOT
43604: OR
43605: IFFALSE 43609
// exit ;
43607: GO 43673
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43609: LD_ADDR_VAR 0 3
43613: PUSH
43614: LD_INT 1
43616: PUSH
43617: LD_INT 2
43619: PUSH
43620: LD_INT 3
43622: PUSH
43623: LD_INT 4
43625: PUSH
43626: LD_INT 11
43628: PUSH
43629: EMPTY
43630: LIST
43631: LIST
43632: LIST
43633: LIST
43634: LIST
43635: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43636: LD_ADDR_EXP 77
43640: PUSH
43641: LD_EXP 77
43645: PPUSH
43646: LD_VAR 0 1
43650: PPUSH
43651: LD_EXP 77
43655: PUSH
43656: LD_VAR 0 1
43660: ARRAY
43661: PUSH
43662: LD_VAR 0 3
43666: DIFF
43667: PPUSH
43668: CALL_OW 1
43672: ST_TO_ADDR
// end ;
43673: LD_VAR 0 2
43677: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43678: LD_INT 0
43680: PPUSH
// result := mc_vehicles [ base ] ;
43681: LD_ADDR_VAR 0 3
43685: PUSH
43686: LD_EXP 69
43690: PUSH
43691: LD_VAR 0 1
43695: ARRAY
43696: ST_TO_ADDR
// if onlyCombat then
43697: LD_VAR 0 2
43701: IFFALSE 43873
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43703: LD_ADDR_VAR 0 3
43707: PUSH
43708: LD_VAR 0 3
43712: PUSH
43713: LD_VAR 0 3
43717: PPUSH
43718: LD_INT 2
43720: PUSH
43721: LD_INT 34
43723: PUSH
43724: LD_INT 12
43726: PUSH
43727: EMPTY
43728: LIST
43729: LIST
43730: PUSH
43731: LD_INT 34
43733: PUSH
43734: LD_INT 51
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: LD_INT 34
43743: PUSH
43744: LD_INT 89
43746: PUSH
43747: EMPTY
43748: LIST
43749: LIST
43750: PUSH
43751: LD_INT 34
43753: PUSH
43754: LD_INT 32
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: PUSH
43761: LD_INT 34
43763: PUSH
43764: LD_INT 13
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 34
43773: PUSH
43774: LD_INT 52
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 34
43783: PUSH
43784: LD_INT 88
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 34
43793: PUSH
43794: LD_INT 14
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 34
43803: PUSH
43804: LD_INT 53
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: PUSH
43811: LD_INT 34
43813: PUSH
43814: LD_INT 98
43816: PUSH
43817: EMPTY
43818: LIST
43819: LIST
43820: PUSH
43821: LD_INT 34
43823: PUSH
43824: LD_INT 31
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PUSH
43831: LD_INT 34
43833: PUSH
43834: LD_INT 48
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PUSH
43841: LD_INT 34
43843: PUSH
43844: LD_INT 8
43846: PUSH
43847: EMPTY
43848: LIST
43849: LIST
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: LIST
43855: LIST
43856: LIST
43857: LIST
43858: LIST
43859: LIST
43860: LIST
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: PPUSH
43867: CALL_OW 72
43871: DIFF
43872: ST_TO_ADDR
// end ; end_of_file
43873: LD_VAR 0 3
43877: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43878: LD_INT 0
43880: PPUSH
43881: PPUSH
43882: PPUSH
// if not mc_bases or not skirmish then
43883: LD_EXP 50
43887: NOT
43888: PUSH
43889: LD_EXP 48
43893: NOT
43894: OR
43895: IFFALSE 43899
// exit ;
43897: GO 44064
// for i = 1 to mc_bases do
43899: LD_ADDR_VAR 0 4
43903: PUSH
43904: DOUBLE
43905: LD_INT 1
43907: DEC
43908: ST_TO_ADDR
43909: LD_EXP 50
43913: PUSH
43914: FOR_TO
43915: IFFALSE 44062
// begin if sci in mc_bases [ i ] then
43917: LD_VAR 0 2
43921: PUSH
43922: LD_EXP 50
43926: PUSH
43927: LD_VAR 0 4
43931: ARRAY
43932: IN
43933: IFFALSE 44060
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43935: LD_ADDR_EXP 79
43939: PUSH
43940: LD_EXP 79
43944: PPUSH
43945: LD_VAR 0 4
43949: PUSH
43950: LD_EXP 79
43954: PUSH
43955: LD_VAR 0 4
43959: ARRAY
43960: PUSH
43961: LD_INT 1
43963: PLUS
43964: PUSH
43965: EMPTY
43966: LIST
43967: LIST
43968: PPUSH
43969: LD_VAR 0 1
43973: PPUSH
43974: CALL 53785 0 3
43978: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43979: LD_ADDR_VAR 0 5
43983: PUSH
43984: LD_EXP 50
43988: PUSH
43989: LD_VAR 0 4
43993: ARRAY
43994: PPUSH
43995: LD_INT 2
43997: PUSH
43998: LD_INT 30
44000: PUSH
44001: LD_INT 0
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_INT 30
44010: PUSH
44011: LD_INT 1
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: EMPTY
44019: LIST
44020: LIST
44021: LIST
44022: PPUSH
44023: CALL_OW 72
44027: PPUSH
44028: LD_VAR 0 1
44032: PPUSH
44033: CALL_OW 74
44037: ST_TO_ADDR
// if tmp then
44038: LD_VAR 0 5
44042: IFFALSE 44058
// ComStandNearbyBuilding ( ape , tmp ) ;
44044: LD_VAR 0 1
44048: PPUSH
44049: LD_VAR 0 5
44053: PPUSH
44054: CALL 50212 0 2
// break ;
44058: GO 44062
// end ; end ;
44060: GO 43914
44062: POP
44063: POP
// end ;
44064: LD_VAR 0 3
44068: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44069: LD_INT 0
44071: PPUSH
44072: PPUSH
44073: PPUSH
// if not mc_bases or not skirmish then
44074: LD_EXP 50
44078: NOT
44079: PUSH
44080: LD_EXP 48
44084: NOT
44085: OR
44086: IFFALSE 44090
// exit ;
44088: GO 44179
// for i = 1 to mc_bases do
44090: LD_ADDR_VAR 0 4
44094: PUSH
44095: DOUBLE
44096: LD_INT 1
44098: DEC
44099: ST_TO_ADDR
44100: LD_EXP 50
44104: PUSH
44105: FOR_TO
44106: IFFALSE 44177
// begin if building in mc_busy_turret_list [ i ] then
44108: LD_VAR 0 1
44112: PUSH
44113: LD_EXP 60
44117: PUSH
44118: LD_VAR 0 4
44122: ARRAY
44123: IN
44124: IFFALSE 44175
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44126: LD_ADDR_VAR 0 5
44130: PUSH
44131: LD_EXP 60
44135: PUSH
44136: LD_VAR 0 4
44140: ARRAY
44141: PUSH
44142: LD_VAR 0 1
44146: DIFF
44147: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44148: LD_ADDR_EXP 60
44152: PUSH
44153: LD_EXP 60
44157: PPUSH
44158: LD_VAR 0 4
44162: PPUSH
44163: LD_VAR 0 5
44167: PPUSH
44168: CALL_OW 1
44172: ST_TO_ADDR
// break ;
44173: GO 44177
// end ; end ;
44175: GO 44105
44177: POP
44178: POP
// end ;
44179: LD_VAR 0 3
44183: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44184: LD_INT 0
44186: PPUSH
44187: PPUSH
44188: PPUSH
// if not mc_bases or not skirmish then
44189: LD_EXP 50
44193: NOT
44194: PUSH
44195: LD_EXP 48
44199: NOT
44200: OR
44201: IFFALSE 44205
// exit ;
44203: GO 44404
// for i = 1 to mc_bases do
44205: LD_ADDR_VAR 0 5
44209: PUSH
44210: DOUBLE
44211: LD_INT 1
44213: DEC
44214: ST_TO_ADDR
44215: LD_EXP 50
44219: PUSH
44220: FOR_TO
44221: IFFALSE 44402
// if building in mc_bases [ i ] then
44223: LD_VAR 0 1
44227: PUSH
44228: LD_EXP 50
44232: PUSH
44233: LD_VAR 0 5
44237: ARRAY
44238: IN
44239: IFFALSE 44400
// begin tmp := mc_bases [ i ] diff building ;
44241: LD_ADDR_VAR 0 6
44245: PUSH
44246: LD_EXP 50
44250: PUSH
44251: LD_VAR 0 5
44255: ARRAY
44256: PUSH
44257: LD_VAR 0 1
44261: DIFF
44262: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44263: LD_ADDR_EXP 50
44267: PUSH
44268: LD_EXP 50
44272: PPUSH
44273: LD_VAR 0 5
44277: PPUSH
44278: LD_VAR 0 6
44282: PPUSH
44283: CALL_OW 1
44287: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44288: LD_VAR 0 1
44292: PUSH
44293: LD_EXP 58
44297: PUSH
44298: LD_VAR 0 5
44302: ARRAY
44303: IN
44304: IFFALSE 44343
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44306: LD_ADDR_EXP 58
44310: PUSH
44311: LD_EXP 58
44315: PPUSH
44316: LD_VAR 0 5
44320: PPUSH
44321: LD_EXP 58
44325: PUSH
44326: LD_VAR 0 5
44330: ARRAY
44331: PUSH
44332: LD_VAR 0 1
44336: DIFF
44337: PPUSH
44338: CALL_OW 1
44342: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44343: LD_VAR 0 1
44347: PUSH
44348: LD_EXP 59
44352: PUSH
44353: LD_VAR 0 5
44357: ARRAY
44358: IN
44359: IFFALSE 44398
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44361: LD_ADDR_EXP 59
44365: PUSH
44366: LD_EXP 59
44370: PPUSH
44371: LD_VAR 0 5
44375: PPUSH
44376: LD_EXP 59
44380: PUSH
44381: LD_VAR 0 5
44385: ARRAY
44386: PUSH
44387: LD_VAR 0 1
44391: DIFF
44392: PPUSH
44393: CALL_OW 1
44397: ST_TO_ADDR
// break ;
44398: GO 44402
// end ;
44400: GO 44220
44402: POP
44403: POP
// end ;
44404: LD_VAR 0 4
44408: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44409: LD_INT 0
44411: PPUSH
44412: PPUSH
44413: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44414: LD_EXP 50
44418: NOT
44419: PUSH
44420: LD_EXP 48
44424: NOT
44425: OR
44426: PUSH
44427: LD_VAR 0 3
44431: PUSH
44432: LD_EXP 76
44436: IN
44437: NOT
44438: OR
44439: IFFALSE 44443
// exit ;
44441: GO 44566
// for i = 1 to mc_vehicles do
44443: LD_ADDR_VAR 0 6
44447: PUSH
44448: DOUBLE
44449: LD_INT 1
44451: DEC
44452: ST_TO_ADDR
44453: LD_EXP 69
44457: PUSH
44458: FOR_TO
44459: IFFALSE 44564
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44461: LD_VAR 0 2
44465: PUSH
44466: LD_EXP 69
44470: PUSH
44471: LD_VAR 0 6
44475: ARRAY
44476: IN
44477: PUSH
44478: LD_VAR 0 1
44482: PUSH
44483: LD_EXP 69
44487: PUSH
44488: LD_VAR 0 6
44492: ARRAY
44493: IN
44494: OR
44495: IFFALSE 44562
// begin tmp := mc_vehicles [ i ] diff old ;
44497: LD_ADDR_VAR 0 7
44501: PUSH
44502: LD_EXP 69
44506: PUSH
44507: LD_VAR 0 6
44511: ARRAY
44512: PUSH
44513: LD_VAR 0 2
44517: DIFF
44518: ST_TO_ADDR
// tmp := tmp diff new ;
44519: LD_ADDR_VAR 0 7
44523: PUSH
44524: LD_VAR 0 7
44528: PUSH
44529: LD_VAR 0 1
44533: DIFF
44534: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44535: LD_ADDR_EXP 69
44539: PUSH
44540: LD_EXP 69
44544: PPUSH
44545: LD_VAR 0 6
44549: PPUSH
44550: LD_VAR 0 7
44554: PPUSH
44555: CALL_OW 1
44559: ST_TO_ADDR
// break ;
44560: GO 44564
// end ;
44562: GO 44458
44564: POP
44565: POP
// end ;
44566: LD_VAR 0 5
44570: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44571: LD_INT 0
44573: PPUSH
44574: PPUSH
44575: PPUSH
44576: PPUSH
// if not mc_bases or not skirmish then
44577: LD_EXP 50
44581: NOT
44582: PUSH
44583: LD_EXP 48
44587: NOT
44588: OR
44589: IFFALSE 44593
// exit ;
44591: GO 44975
// side := GetSide ( vehicle ) ;
44593: LD_ADDR_VAR 0 5
44597: PUSH
44598: LD_VAR 0 1
44602: PPUSH
44603: CALL_OW 255
44607: ST_TO_ADDR
// for i = 1 to mc_bases do
44608: LD_ADDR_VAR 0 4
44612: PUSH
44613: DOUBLE
44614: LD_INT 1
44616: DEC
44617: ST_TO_ADDR
44618: LD_EXP 50
44622: PUSH
44623: FOR_TO
44624: IFFALSE 44973
// begin if factory in mc_bases [ i ] then
44626: LD_VAR 0 2
44630: PUSH
44631: LD_EXP 50
44635: PUSH
44636: LD_VAR 0 4
44640: ARRAY
44641: IN
44642: IFFALSE 44971
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44644: LD_EXP 72
44648: PUSH
44649: LD_VAR 0 4
44653: ARRAY
44654: PUSH
44655: LD_EXP 61
44659: PUSH
44660: LD_VAR 0 4
44664: ARRAY
44665: LESS
44666: PUSH
44667: LD_VAR 0 1
44671: PPUSH
44672: CALL_OW 264
44676: PUSH
44677: LD_INT 31
44679: PUSH
44680: LD_INT 32
44682: PUSH
44683: LD_INT 51
44685: PUSH
44686: LD_INT 89
44688: PUSH
44689: LD_INT 12
44691: PUSH
44692: LD_INT 30
44694: PUSH
44695: LD_INT 98
44697: PUSH
44698: LD_INT 11
44700: PUSH
44701: LD_INT 53
44703: PUSH
44704: LD_INT 14
44706: PUSH
44707: LD_INT 91
44709: PUSH
44710: LD_INT 29
44712: PUSH
44713: LD_INT 99
44715: PUSH
44716: LD_INT 13
44718: PUSH
44719: LD_INT 52
44721: PUSH
44722: LD_INT 88
44724: PUSH
44725: LD_INT 48
44727: PUSH
44728: LD_INT 8
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: LIST
44735: LIST
44736: LIST
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: LIST
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: IN
44751: NOT
44752: AND
44753: IFFALSE 44801
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44755: LD_ADDR_EXP 72
44759: PUSH
44760: LD_EXP 72
44764: PPUSH
44765: LD_VAR 0 4
44769: PUSH
44770: LD_EXP 72
44774: PUSH
44775: LD_VAR 0 4
44779: ARRAY
44780: PUSH
44781: LD_INT 1
44783: PLUS
44784: PUSH
44785: EMPTY
44786: LIST
44787: LIST
44788: PPUSH
44789: LD_VAR 0 1
44793: PPUSH
44794: CALL 53785 0 3
44798: ST_TO_ADDR
44799: GO 44845
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44801: LD_ADDR_EXP 69
44805: PUSH
44806: LD_EXP 69
44810: PPUSH
44811: LD_VAR 0 4
44815: PUSH
44816: LD_EXP 69
44820: PUSH
44821: LD_VAR 0 4
44825: ARRAY
44826: PUSH
44827: LD_INT 1
44829: PLUS
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PPUSH
44835: LD_VAR 0 1
44839: PPUSH
44840: CALL 53785 0 3
44844: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44845: LD_VAR 0 1
44849: PPUSH
44850: CALL_OW 263
44854: PUSH
44855: LD_INT 2
44857: EQUAL
44858: IFFALSE 44887
// begin repeat wait ( 0 0$3 ) ;
44860: LD_INT 105
44862: PPUSH
44863: CALL_OW 67
// Connect ( vehicle ) ;
44867: LD_VAR 0 1
44871: PPUSH
44872: CALL 56754 0 1
// until IsControledBy ( vehicle ) ;
44876: LD_VAR 0 1
44880: PPUSH
44881: CALL_OW 312
44885: IFFALSE 44860
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44887: LD_VAR 0 1
44891: PPUSH
44892: LD_EXP 74
44896: PUSH
44897: LD_VAR 0 4
44901: ARRAY
44902: PPUSH
44903: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44907: LD_VAR 0 1
44911: PPUSH
44912: CALL_OW 263
44916: PUSH
44917: LD_INT 1
44919: NONEQUAL
44920: IFFALSE 44924
// break ;
44922: GO 44973
// repeat wait ( 0 0$1 ) ;
44924: LD_INT 35
44926: PPUSH
44927: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44931: LD_VAR 0 1
44935: PPUSH
44936: LD_EXP 74
44940: PUSH
44941: LD_VAR 0 4
44945: ARRAY
44946: PPUSH
44947: CALL_OW 308
44951: IFFALSE 44924
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44953: LD_VAR 0 1
44957: PPUSH
44958: CALL_OW 311
44962: PPUSH
44963: CALL_OW 121
// exit ;
44967: POP
44968: POP
44969: GO 44975
// end ; end ;
44971: GO 44623
44973: POP
44974: POP
// end ;
44975: LD_VAR 0 3
44979: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44980: LD_INT 0
44982: PPUSH
44983: PPUSH
44984: PPUSH
44985: PPUSH
// if not mc_bases or not skirmish then
44986: LD_EXP 50
44990: NOT
44991: PUSH
44992: LD_EXP 48
44996: NOT
44997: OR
44998: IFFALSE 45002
// exit ;
45000: GO 45355
// repeat wait ( 0 0$1 ) ;
45002: LD_INT 35
45004: PPUSH
45005: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45009: LD_VAR 0 2
45013: PPUSH
45014: LD_VAR 0 3
45018: PPUSH
45019: CALL_OW 284
45023: IFFALSE 45002
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45025: LD_VAR 0 2
45029: PPUSH
45030: LD_VAR 0 3
45034: PPUSH
45035: CALL_OW 283
45039: PUSH
45040: LD_INT 4
45042: EQUAL
45043: IFFALSE 45047
// exit ;
45045: GO 45355
// for i = 1 to mc_bases do
45047: LD_ADDR_VAR 0 7
45051: PUSH
45052: DOUBLE
45053: LD_INT 1
45055: DEC
45056: ST_TO_ADDR
45057: LD_EXP 50
45061: PUSH
45062: FOR_TO
45063: IFFALSE 45353
// begin if mc_crates_area [ i ] then
45065: LD_EXP 68
45069: PUSH
45070: LD_VAR 0 7
45074: ARRAY
45075: IFFALSE 45186
// for j in mc_crates_area [ i ] do
45077: LD_ADDR_VAR 0 8
45081: PUSH
45082: LD_EXP 68
45086: PUSH
45087: LD_VAR 0 7
45091: ARRAY
45092: PUSH
45093: FOR_IN
45094: IFFALSE 45184
// if InArea ( x , y , j ) then
45096: LD_VAR 0 2
45100: PPUSH
45101: LD_VAR 0 3
45105: PPUSH
45106: LD_VAR 0 8
45110: PPUSH
45111: CALL_OW 309
45115: IFFALSE 45182
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45117: LD_ADDR_EXP 66
45121: PUSH
45122: LD_EXP 66
45126: PPUSH
45127: LD_VAR 0 7
45131: PUSH
45132: LD_EXP 66
45136: PUSH
45137: LD_VAR 0 7
45141: ARRAY
45142: PUSH
45143: LD_INT 1
45145: PLUS
45146: PUSH
45147: EMPTY
45148: LIST
45149: LIST
45150: PPUSH
45151: LD_VAR 0 4
45155: PUSH
45156: LD_VAR 0 2
45160: PUSH
45161: LD_VAR 0 3
45165: PUSH
45166: EMPTY
45167: LIST
45168: LIST
45169: LIST
45170: PPUSH
45171: CALL 53785 0 3
45175: ST_TO_ADDR
// exit ;
45176: POP
45177: POP
45178: POP
45179: POP
45180: GO 45355
// end ;
45182: GO 45093
45184: POP
45185: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45186: LD_ADDR_VAR 0 9
45190: PUSH
45191: LD_EXP 50
45195: PUSH
45196: LD_VAR 0 7
45200: ARRAY
45201: PPUSH
45202: LD_INT 2
45204: PUSH
45205: LD_INT 30
45207: PUSH
45208: LD_INT 0
45210: PUSH
45211: EMPTY
45212: LIST
45213: LIST
45214: PUSH
45215: LD_INT 30
45217: PUSH
45218: LD_INT 1
45220: PUSH
45221: EMPTY
45222: LIST
45223: LIST
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: LIST
45229: PPUSH
45230: CALL_OW 72
45234: ST_TO_ADDR
// if not depot then
45235: LD_VAR 0 9
45239: NOT
45240: IFFALSE 45244
// continue ;
45242: GO 45062
// for j in depot do
45244: LD_ADDR_VAR 0 8
45248: PUSH
45249: LD_VAR 0 9
45253: PUSH
45254: FOR_IN
45255: IFFALSE 45349
// if GetDistUnitXY ( j , x , y ) < 30 then
45257: LD_VAR 0 8
45261: PPUSH
45262: LD_VAR 0 2
45266: PPUSH
45267: LD_VAR 0 3
45271: PPUSH
45272: CALL_OW 297
45276: PUSH
45277: LD_INT 30
45279: LESS
45280: IFFALSE 45347
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45282: LD_ADDR_EXP 66
45286: PUSH
45287: LD_EXP 66
45291: PPUSH
45292: LD_VAR 0 7
45296: PUSH
45297: LD_EXP 66
45301: PUSH
45302: LD_VAR 0 7
45306: ARRAY
45307: PUSH
45308: LD_INT 1
45310: PLUS
45311: PUSH
45312: EMPTY
45313: LIST
45314: LIST
45315: PPUSH
45316: LD_VAR 0 4
45320: PUSH
45321: LD_VAR 0 2
45325: PUSH
45326: LD_VAR 0 3
45330: PUSH
45331: EMPTY
45332: LIST
45333: LIST
45334: LIST
45335: PPUSH
45336: CALL 53785 0 3
45340: ST_TO_ADDR
// exit ;
45341: POP
45342: POP
45343: POP
45344: POP
45345: GO 45355
// end ;
45347: GO 45254
45349: POP
45350: POP
// end ;
45351: GO 45062
45353: POP
45354: POP
// end ;
45355: LD_VAR 0 6
45359: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45360: LD_INT 0
45362: PPUSH
45363: PPUSH
45364: PPUSH
45365: PPUSH
// if not mc_bases or not skirmish then
45366: LD_EXP 50
45370: NOT
45371: PUSH
45372: LD_EXP 48
45376: NOT
45377: OR
45378: IFFALSE 45382
// exit ;
45380: GO 45659
// side := GetSide ( lab ) ;
45382: LD_ADDR_VAR 0 4
45386: PUSH
45387: LD_VAR 0 2
45391: PPUSH
45392: CALL_OW 255
45396: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45397: LD_VAR 0 4
45401: PUSH
45402: LD_EXP 76
45406: IN
45407: NOT
45408: PUSH
45409: LD_EXP 77
45413: NOT
45414: OR
45415: PUSH
45416: LD_EXP 50
45420: NOT
45421: OR
45422: IFFALSE 45426
// exit ;
45424: GO 45659
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45426: LD_ADDR_EXP 77
45430: PUSH
45431: LD_EXP 77
45435: PPUSH
45436: LD_VAR 0 4
45440: PPUSH
45441: LD_EXP 77
45445: PUSH
45446: LD_VAR 0 4
45450: ARRAY
45451: PUSH
45452: LD_VAR 0 1
45456: DIFF
45457: PPUSH
45458: CALL_OW 1
45462: ST_TO_ADDR
// for i = 1 to mc_bases do
45463: LD_ADDR_VAR 0 5
45467: PUSH
45468: DOUBLE
45469: LD_INT 1
45471: DEC
45472: ST_TO_ADDR
45473: LD_EXP 50
45477: PUSH
45478: FOR_TO
45479: IFFALSE 45657
// begin if lab in mc_bases [ i ] then
45481: LD_VAR 0 2
45485: PUSH
45486: LD_EXP 50
45490: PUSH
45491: LD_VAR 0 5
45495: ARRAY
45496: IN
45497: IFFALSE 45655
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45499: LD_VAR 0 1
45503: PUSH
45504: LD_INT 11
45506: PUSH
45507: LD_INT 4
45509: PUSH
45510: LD_INT 3
45512: PUSH
45513: LD_INT 2
45515: PUSH
45516: EMPTY
45517: LIST
45518: LIST
45519: LIST
45520: LIST
45521: IN
45522: PUSH
45523: LD_EXP 80
45527: PUSH
45528: LD_VAR 0 5
45532: ARRAY
45533: AND
45534: IFFALSE 45655
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45536: LD_ADDR_VAR 0 6
45540: PUSH
45541: LD_EXP 80
45545: PUSH
45546: LD_VAR 0 5
45550: ARRAY
45551: PUSH
45552: LD_INT 1
45554: ARRAY
45555: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45556: LD_ADDR_EXP 80
45560: PUSH
45561: LD_EXP 80
45565: PPUSH
45566: LD_VAR 0 5
45570: PPUSH
45571: EMPTY
45572: PPUSH
45573: CALL_OW 1
45577: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45578: LD_VAR 0 6
45582: PPUSH
45583: LD_INT 0
45585: PPUSH
45586: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45590: LD_VAR 0 6
45594: PPUSH
45595: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45599: LD_ADDR_EXP 79
45603: PUSH
45604: LD_EXP 79
45608: PPUSH
45609: LD_VAR 0 5
45613: PPUSH
45614: LD_EXP 79
45618: PUSH
45619: LD_VAR 0 5
45623: ARRAY
45624: PPUSH
45625: LD_INT 1
45627: PPUSH
45628: LD_VAR 0 6
45632: PPUSH
45633: CALL_OW 2
45637: PPUSH
45638: CALL_OW 1
45642: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45643: LD_VAR 0 5
45647: PPUSH
45648: LD_INT 112
45650: PPUSH
45651: CALL 22145 0 2
// end ; end ; end ;
45655: GO 45478
45657: POP
45658: POP
// end ;
45659: LD_VAR 0 3
45663: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45664: LD_INT 0
45666: PPUSH
45667: PPUSH
45668: PPUSH
45669: PPUSH
45670: PPUSH
45671: PPUSH
45672: PPUSH
45673: PPUSH
// if not mc_bases or not skirmish then
45674: LD_EXP 50
45678: NOT
45679: PUSH
45680: LD_EXP 48
45684: NOT
45685: OR
45686: IFFALSE 45690
// exit ;
45688: GO 47059
// for i = 1 to mc_bases do
45690: LD_ADDR_VAR 0 3
45694: PUSH
45695: DOUBLE
45696: LD_INT 1
45698: DEC
45699: ST_TO_ADDR
45700: LD_EXP 50
45704: PUSH
45705: FOR_TO
45706: IFFALSE 47057
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45708: LD_VAR 0 1
45712: PUSH
45713: LD_EXP 50
45717: PUSH
45718: LD_VAR 0 3
45722: ARRAY
45723: IN
45724: PUSH
45725: LD_VAR 0 1
45729: PUSH
45730: LD_EXP 57
45734: PUSH
45735: LD_VAR 0 3
45739: ARRAY
45740: IN
45741: OR
45742: PUSH
45743: LD_VAR 0 1
45747: PUSH
45748: LD_EXP 72
45752: PUSH
45753: LD_VAR 0 3
45757: ARRAY
45758: IN
45759: OR
45760: PUSH
45761: LD_VAR 0 1
45765: PUSH
45766: LD_EXP 69
45770: PUSH
45771: LD_VAR 0 3
45775: ARRAY
45776: IN
45777: OR
45778: PUSH
45779: LD_VAR 0 1
45783: PUSH
45784: LD_EXP 79
45788: PUSH
45789: LD_VAR 0 3
45793: ARRAY
45794: IN
45795: OR
45796: PUSH
45797: LD_VAR 0 1
45801: PUSH
45802: LD_EXP 80
45806: PUSH
45807: LD_VAR 0 3
45811: ARRAY
45812: IN
45813: OR
45814: IFFALSE 47055
// begin if un in mc_ape [ i ] then
45816: LD_VAR 0 1
45820: PUSH
45821: LD_EXP 79
45825: PUSH
45826: LD_VAR 0 3
45830: ARRAY
45831: IN
45832: IFFALSE 45871
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45834: LD_ADDR_EXP 79
45838: PUSH
45839: LD_EXP 79
45843: PPUSH
45844: LD_VAR 0 3
45848: PPUSH
45849: LD_EXP 79
45853: PUSH
45854: LD_VAR 0 3
45858: ARRAY
45859: PUSH
45860: LD_VAR 0 1
45864: DIFF
45865: PPUSH
45866: CALL_OW 1
45870: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45871: LD_VAR 0 1
45875: PUSH
45876: LD_EXP 80
45880: PUSH
45881: LD_VAR 0 3
45885: ARRAY
45886: IN
45887: IFFALSE 45911
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45889: LD_ADDR_EXP 80
45893: PUSH
45894: LD_EXP 80
45898: PPUSH
45899: LD_VAR 0 3
45903: PPUSH
45904: EMPTY
45905: PPUSH
45906: CALL_OW 1
45910: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45911: LD_VAR 0 1
45915: PPUSH
45916: CALL_OW 247
45920: PUSH
45921: LD_INT 2
45923: EQUAL
45924: PUSH
45925: LD_VAR 0 1
45929: PPUSH
45930: CALL_OW 110
45934: PUSH
45935: LD_INT 20
45937: EQUAL
45938: PUSH
45939: LD_VAR 0 1
45943: PUSH
45944: LD_EXP 72
45948: PUSH
45949: LD_VAR 0 3
45953: ARRAY
45954: IN
45955: OR
45956: PUSH
45957: LD_VAR 0 1
45961: PPUSH
45962: CALL_OW 264
45966: PUSH
45967: LD_INT 12
45969: PUSH
45970: LD_INT 51
45972: PUSH
45973: LD_INT 89
45975: PUSH
45976: LD_INT 32
45978: PUSH
45979: LD_INT 13
45981: PUSH
45982: LD_INT 52
45984: PUSH
45985: LD_INT 31
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: IN
45997: OR
45998: AND
45999: IFFALSE 46307
// begin if un in mc_defender [ i ] then
46001: LD_VAR 0 1
46005: PUSH
46006: LD_EXP 72
46010: PUSH
46011: LD_VAR 0 3
46015: ARRAY
46016: IN
46017: IFFALSE 46056
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46019: LD_ADDR_EXP 72
46023: PUSH
46024: LD_EXP 72
46028: PPUSH
46029: LD_VAR 0 3
46033: PPUSH
46034: LD_EXP 72
46038: PUSH
46039: LD_VAR 0 3
46043: ARRAY
46044: PUSH
46045: LD_VAR 0 1
46049: DIFF
46050: PPUSH
46051: CALL_OW 1
46055: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46056: LD_ADDR_VAR 0 8
46060: PUSH
46061: LD_VAR 0 3
46065: PPUSH
46066: LD_INT 3
46068: PPUSH
46069: CALL 42715 0 2
46073: ST_TO_ADDR
// if fac then
46074: LD_VAR 0 8
46078: IFFALSE 46307
// begin for j in fac do
46080: LD_ADDR_VAR 0 4
46084: PUSH
46085: LD_VAR 0 8
46089: PUSH
46090: FOR_IN
46091: IFFALSE 46305
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46093: LD_ADDR_VAR 0 9
46097: PUSH
46098: LD_VAR 0 8
46102: PPUSH
46103: LD_VAR 0 1
46107: PPUSH
46108: CALL_OW 265
46112: PPUSH
46113: LD_VAR 0 1
46117: PPUSH
46118: CALL_OW 262
46122: PPUSH
46123: LD_VAR 0 1
46127: PPUSH
46128: CALL_OW 263
46132: PPUSH
46133: LD_VAR 0 1
46137: PPUSH
46138: CALL_OW 264
46142: PPUSH
46143: CALL 51283 0 5
46147: ST_TO_ADDR
// if components then
46148: LD_VAR 0 9
46152: IFFALSE 46303
// begin if GetWeapon ( un ) = ar_control_tower then
46154: LD_VAR 0 1
46158: PPUSH
46159: CALL_OW 264
46163: PUSH
46164: LD_INT 31
46166: EQUAL
46167: IFFALSE 46284
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46169: LD_VAR 0 1
46173: PPUSH
46174: CALL_OW 311
46178: PPUSH
46179: LD_INT 0
46181: PPUSH
46182: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46186: LD_ADDR_EXP 90
46190: PUSH
46191: LD_EXP 90
46195: PPUSH
46196: LD_VAR 0 3
46200: PPUSH
46201: LD_EXP 90
46205: PUSH
46206: LD_VAR 0 3
46210: ARRAY
46211: PUSH
46212: LD_VAR 0 1
46216: PPUSH
46217: CALL_OW 311
46221: DIFF
46222: PPUSH
46223: CALL_OW 1
46227: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46228: LD_ADDR_VAR 0 7
46232: PUSH
46233: LD_EXP 71
46237: PUSH
46238: LD_VAR 0 3
46242: ARRAY
46243: PPUSH
46244: LD_INT 1
46246: PPUSH
46247: LD_VAR 0 9
46251: PPUSH
46252: CALL_OW 2
46256: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46257: LD_ADDR_EXP 71
46261: PUSH
46262: LD_EXP 71
46266: PPUSH
46267: LD_VAR 0 3
46271: PPUSH
46272: LD_VAR 0 7
46276: PPUSH
46277: CALL_OW 1
46281: ST_TO_ADDR
// end else
46282: GO 46301
// MC_InsertProduceList ( i , [ components ] ) ;
46284: LD_VAR 0 3
46288: PPUSH
46289: LD_VAR 0 9
46293: PUSH
46294: EMPTY
46295: LIST
46296: PPUSH
46297: CALL 42260 0 2
// break ;
46301: GO 46305
// end ; end ;
46303: GO 46090
46305: POP
46306: POP
// end ; end ; if GetType ( un ) = unit_building then
46307: LD_VAR 0 1
46311: PPUSH
46312: CALL_OW 247
46316: PUSH
46317: LD_INT 3
46319: EQUAL
46320: IFFALSE 46723
// begin btype := GetBType ( un ) ;
46322: LD_ADDR_VAR 0 5
46326: PUSH
46327: LD_VAR 0 1
46331: PPUSH
46332: CALL_OW 266
46336: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46337: LD_VAR 0 5
46341: PUSH
46342: LD_INT 29
46344: PUSH
46345: LD_INT 30
46347: PUSH
46348: EMPTY
46349: LIST
46350: LIST
46351: IN
46352: IFFALSE 46425
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46354: LD_VAR 0 1
46358: PPUSH
46359: CALL_OW 250
46363: PPUSH
46364: LD_VAR 0 1
46368: PPUSH
46369: CALL_OW 251
46373: PPUSH
46374: LD_VAR 0 1
46378: PPUSH
46379: CALL_OW 255
46383: PPUSH
46384: CALL_OW 440
46388: NOT
46389: IFFALSE 46425
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46391: LD_VAR 0 1
46395: PPUSH
46396: CALL_OW 250
46400: PPUSH
46401: LD_VAR 0 1
46405: PPUSH
46406: CALL_OW 251
46410: PPUSH
46411: LD_VAR 0 1
46415: PPUSH
46416: CALL_OW 255
46420: PPUSH
46421: CALL_OW 441
// end ; if btype = b_warehouse then
46425: LD_VAR 0 5
46429: PUSH
46430: LD_INT 1
46432: EQUAL
46433: IFFALSE 46451
// begin btype := b_depot ;
46435: LD_ADDR_VAR 0 5
46439: PUSH
46440: LD_INT 0
46442: ST_TO_ADDR
// pos := 1 ;
46443: LD_ADDR_VAR 0 6
46447: PUSH
46448: LD_INT 1
46450: ST_TO_ADDR
// end ; if btype = b_factory then
46451: LD_VAR 0 5
46455: PUSH
46456: LD_INT 3
46458: EQUAL
46459: IFFALSE 46477
// begin btype := b_workshop ;
46461: LD_ADDR_VAR 0 5
46465: PUSH
46466: LD_INT 2
46468: ST_TO_ADDR
// pos := 1 ;
46469: LD_ADDR_VAR 0 6
46473: PUSH
46474: LD_INT 1
46476: ST_TO_ADDR
// end ; if btype = b_barracks then
46477: LD_VAR 0 5
46481: PUSH
46482: LD_INT 5
46484: EQUAL
46485: IFFALSE 46495
// btype := b_armoury ;
46487: LD_ADDR_VAR 0 5
46491: PUSH
46492: LD_INT 4
46494: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46495: LD_VAR 0 5
46499: PUSH
46500: LD_INT 7
46502: PUSH
46503: LD_INT 8
46505: PUSH
46506: EMPTY
46507: LIST
46508: LIST
46509: IN
46510: IFFALSE 46520
// btype := b_lab ;
46512: LD_ADDR_VAR 0 5
46516: PUSH
46517: LD_INT 6
46519: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46520: LD_ADDR_EXP 55
46524: PUSH
46525: LD_EXP 55
46529: PPUSH
46530: LD_VAR 0 3
46534: PUSH
46535: LD_EXP 55
46539: PUSH
46540: LD_VAR 0 3
46544: ARRAY
46545: PUSH
46546: LD_INT 1
46548: PLUS
46549: PUSH
46550: EMPTY
46551: LIST
46552: LIST
46553: PPUSH
46554: LD_VAR 0 5
46558: PUSH
46559: LD_VAR 0 1
46563: PPUSH
46564: CALL_OW 250
46568: PUSH
46569: LD_VAR 0 1
46573: PPUSH
46574: CALL_OW 251
46578: PUSH
46579: LD_VAR 0 1
46583: PPUSH
46584: CALL_OW 254
46588: PUSH
46589: EMPTY
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: PPUSH
46595: CALL 53785 0 3
46599: ST_TO_ADDR
// if pos = 1 then
46600: LD_VAR 0 6
46604: PUSH
46605: LD_INT 1
46607: EQUAL
46608: IFFALSE 46723
// begin tmp := mc_build_list [ i ] ;
46610: LD_ADDR_VAR 0 7
46614: PUSH
46615: LD_EXP 55
46619: PUSH
46620: LD_VAR 0 3
46624: ARRAY
46625: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46626: LD_VAR 0 7
46630: PPUSH
46631: LD_INT 2
46633: PUSH
46634: LD_INT 30
46636: PUSH
46637: LD_INT 0
46639: PUSH
46640: EMPTY
46641: LIST
46642: LIST
46643: PUSH
46644: LD_INT 30
46646: PUSH
46647: LD_INT 1
46649: PUSH
46650: EMPTY
46651: LIST
46652: LIST
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: LIST
46658: PPUSH
46659: CALL_OW 72
46663: IFFALSE 46673
// pos := 2 ;
46665: LD_ADDR_VAR 0 6
46669: PUSH
46670: LD_INT 2
46672: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46673: LD_ADDR_VAR 0 7
46677: PUSH
46678: LD_VAR 0 7
46682: PPUSH
46683: LD_VAR 0 6
46687: PPUSH
46688: LD_VAR 0 7
46692: PPUSH
46693: CALL 54111 0 3
46697: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46698: LD_ADDR_EXP 55
46702: PUSH
46703: LD_EXP 55
46707: PPUSH
46708: LD_VAR 0 3
46712: PPUSH
46713: LD_VAR 0 7
46717: PPUSH
46718: CALL_OW 1
46722: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46723: LD_VAR 0 1
46727: PUSH
46728: LD_EXP 50
46732: PUSH
46733: LD_VAR 0 3
46737: ARRAY
46738: IN
46739: IFFALSE 46778
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46741: LD_ADDR_EXP 50
46745: PUSH
46746: LD_EXP 50
46750: PPUSH
46751: LD_VAR 0 3
46755: PPUSH
46756: LD_EXP 50
46760: PUSH
46761: LD_VAR 0 3
46765: ARRAY
46766: PUSH
46767: LD_VAR 0 1
46771: DIFF
46772: PPUSH
46773: CALL_OW 1
46777: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46778: LD_VAR 0 1
46782: PUSH
46783: LD_EXP 57
46787: PUSH
46788: LD_VAR 0 3
46792: ARRAY
46793: IN
46794: IFFALSE 46833
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46796: LD_ADDR_EXP 57
46800: PUSH
46801: LD_EXP 57
46805: PPUSH
46806: LD_VAR 0 3
46810: PPUSH
46811: LD_EXP 57
46815: PUSH
46816: LD_VAR 0 3
46820: ARRAY
46821: PUSH
46822: LD_VAR 0 1
46826: DIFF
46827: PPUSH
46828: CALL_OW 1
46832: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46833: LD_VAR 0 1
46837: PUSH
46838: LD_EXP 69
46842: PUSH
46843: LD_VAR 0 3
46847: ARRAY
46848: IN
46849: IFFALSE 46888
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46851: LD_ADDR_EXP 69
46855: PUSH
46856: LD_EXP 69
46860: PPUSH
46861: LD_VAR 0 3
46865: PPUSH
46866: LD_EXP 69
46870: PUSH
46871: LD_VAR 0 3
46875: ARRAY
46876: PUSH
46877: LD_VAR 0 1
46881: DIFF
46882: PPUSH
46883: CALL_OW 1
46887: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46888: LD_VAR 0 1
46892: PUSH
46893: LD_EXP 72
46897: PUSH
46898: LD_VAR 0 3
46902: ARRAY
46903: IN
46904: IFFALSE 46943
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46906: LD_ADDR_EXP 72
46910: PUSH
46911: LD_EXP 72
46915: PPUSH
46916: LD_VAR 0 3
46920: PPUSH
46921: LD_EXP 72
46925: PUSH
46926: LD_VAR 0 3
46930: ARRAY
46931: PUSH
46932: LD_VAR 0 1
46936: DIFF
46937: PPUSH
46938: CALL_OW 1
46942: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46943: LD_VAR 0 1
46947: PUSH
46948: LD_EXP 59
46952: PUSH
46953: LD_VAR 0 3
46957: ARRAY
46958: IN
46959: IFFALSE 46998
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46961: LD_ADDR_EXP 59
46965: PUSH
46966: LD_EXP 59
46970: PPUSH
46971: LD_VAR 0 3
46975: PPUSH
46976: LD_EXP 59
46980: PUSH
46981: LD_VAR 0 3
46985: ARRAY
46986: PUSH
46987: LD_VAR 0 1
46991: DIFF
46992: PPUSH
46993: CALL_OW 1
46997: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46998: LD_VAR 0 1
47002: PUSH
47003: LD_EXP 58
47007: PUSH
47008: LD_VAR 0 3
47012: ARRAY
47013: IN
47014: IFFALSE 47053
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47016: LD_ADDR_EXP 58
47020: PUSH
47021: LD_EXP 58
47025: PPUSH
47026: LD_VAR 0 3
47030: PPUSH
47031: LD_EXP 58
47035: PUSH
47036: LD_VAR 0 3
47040: ARRAY
47041: PUSH
47042: LD_VAR 0 1
47046: DIFF
47047: PPUSH
47048: CALL_OW 1
47052: ST_TO_ADDR
// end ; break ;
47053: GO 47057
// end ;
47055: GO 45705
47057: POP
47058: POP
// end ;
47059: LD_VAR 0 2
47063: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47064: LD_INT 0
47066: PPUSH
47067: PPUSH
47068: PPUSH
// if not mc_bases or not skirmish then
47069: LD_EXP 50
47073: NOT
47074: PUSH
47075: LD_EXP 48
47079: NOT
47080: OR
47081: IFFALSE 47085
// exit ;
47083: GO 47300
// for i = 1 to mc_bases do
47085: LD_ADDR_VAR 0 3
47089: PUSH
47090: DOUBLE
47091: LD_INT 1
47093: DEC
47094: ST_TO_ADDR
47095: LD_EXP 50
47099: PUSH
47100: FOR_TO
47101: IFFALSE 47298
// begin if building in mc_construct_list [ i ] then
47103: LD_VAR 0 1
47107: PUSH
47108: LD_EXP 57
47112: PUSH
47113: LD_VAR 0 3
47117: ARRAY
47118: IN
47119: IFFALSE 47296
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47121: LD_ADDR_EXP 57
47125: PUSH
47126: LD_EXP 57
47130: PPUSH
47131: LD_VAR 0 3
47135: PPUSH
47136: LD_EXP 57
47140: PUSH
47141: LD_VAR 0 3
47145: ARRAY
47146: PUSH
47147: LD_VAR 0 1
47151: DIFF
47152: PPUSH
47153: CALL_OW 1
47157: ST_TO_ADDR
// if building in mc_lab [ i ] then
47158: LD_VAR 0 1
47162: PUSH
47163: LD_EXP 83
47167: PUSH
47168: LD_VAR 0 3
47172: ARRAY
47173: IN
47174: IFFALSE 47229
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47176: LD_ADDR_EXP 84
47180: PUSH
47181: LD_EXP 84
47185: PPUSH
47186: LD_VAR 0 3
47190: PPUSH
47191: LD_EXP 84
47195: PUSH
47196: LD_VAR 0 3
47200: ARRAY
47201: PPUSH
47202: LD_INT 1
47204: PPUSH
47205: LD_EXP 84
47209: PUSH
47210: LD_VAR 0 3
47214: ARRAY
47215: PPUSH
47216: LD_INT 0
47218: PPUSH
47219: CALL 53203 0 4
47223: PPUSH
47224: CALL_OW 1
47228: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47229: LD_VAR 0 1
47233: PUSH
47234: LD_EXP 50
47238: PUSH
47239: LD_VAR 0 3
47243: ARRAY
47244: IN
47245: NOT
47246: IFFALSE 47292
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47248: LD_ADDR_EXP 50
47252: PUSH
47253: LD_EXP 50
47257: PPUSH
47258: LD_VAR 0 3
47262: PUSH
47263: LD_EXP 50
47267: PUSH
47268: LD_VAR 0 3
47272: ARRAY
47273: PUSH
47274: LD_INT 1
47276: PLUS
47277: PUSH
47278: EMPTY
47279: LIST
47280: LIST
47281: PPUSH
47282: LD_VAR 0 1
47286: PPUSH
47287: CALL 53785 0 3
47291: ST_TO_ADDR
// exit ;
47292: POP
47293: POP
47294: GO 47300
// end ; end ;
47296: GO 47100
47298: POP
47299: POP
// end ;
47300: LD_VAR 0 2
47304: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47305: LD_INT 0
47307: PPUSH
47308: PPUSH
47309: PPUSH
47310: PPUSH
47311: PPUSH
47312: PPUSH
47313: PPUSH
// if not mc_bases or not skirmish then
47314: LD_EXP 50
47318: NOT
47319: PUSH
47320: LD_EXP 48
47324: NOT
47325: OR
47326: IFFALSE 47330
// exit ;
47328: GO 47991
// for i = 1 to mc_bases do
47330: LD_ADDR_VAR 0 3
47334: PUSH
47335: DOUBLE
47336: LD_INT 1
47338: DEC
47339: ST_TO_ADDR
47340: LD_EXP 50
47344: PUSH
47345: FOR_TO
47346: IFFALSE 47989
// begin if building in mc_construct_list [ i ] then
47348: LD_VAR 0 1
47352: PUSH
47353: LD_EXP 57
47357: PUSH
47358: LD_VAR 0 3
47362: ARRAY
47363: IN
47364: IFFALSE 47987
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47366: LD_ADDR_EXP 57
47370: PUSH
47371: LD_EXP 57
47375: PPUSH
47376: LD_VAR 0 3
47380: PPUSH
47381: LD_EXP 57
47385: PUSH
47386: LD_VAR 0 3
47390: ARRAY
47391: PUSH
47392: LD_VAR 0 1
47396: DIFF
47397: PPUSH
47398: CALL_OW 1
47402: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47403: LD_ADDR_EXP 50
47407: PUSH
47408: LD_EXP 50
47412: PPUSH
47413: LD_VAR 0 3
47417: PUSH
47418: LD_EXP 50
47422: PUSH
47423: LD_VAR 0 3
47427: ARRAY
47428: PUSH
47429: LD_INT 1
47431: PLUS
47432: PUSH
47433: EMPTY
47434: LIST
47435: LIST
47436: PPUSH
47437: LD_VAR 0 1
47441: PPUSH
47442: CALL 53785 0 3
47446: ST_TO_ADDR
// btype := GetBType ( building ) ;
47447: LD_ADDR_VAR 0 5
47451: PUSH
47452: LD_VAR 0 1
47456: PPUSH
47457: CALL_OW 266
47461: ST_TO_ADDR
// side := GetSide ( building ) ;
47462: LD_ADDR_VAR 0 8
47466: PUSH
47467: LD_VAR 0 1
47471: PPUSH
47472: CALL_OW 255
47476: ST_TO_ADDR
// if btype = b_lab then
47477: LD_VAR 0 5
47481: PUSH
47482: LD_INT 6
47484: EQUAL
47485: IFFALSE 47535
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47487: LD_ADDR_EXP 83
47491: PUSH
47492: LD_EXP 83
47496: PPUSH
47497: LD_VAR 0 3
47501: PUSH
47502: LD_EXP 83
47506: PUSH
47507: LD_VAR 0 3
47511: ARRAY
47512: PUSH
47513: LD_INT 1
47515: PLUS
47516: PUSH
47517: EMPTY
47518: LIST
47519: LIST
47520: PPUSH
47521: LD_VAR 0 1
47525: PPUSH
47526: CALL 53785 0 3
47530: ST_TO_ADDR
// exit ;
47531: POP
47532: POP
47533: GO 47991
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47535: LD_VAR 0 5
47539: PUSH
47540: LD_INT 0
47542: PUSH
47543: LD_INT 2
47545: PUSH
47546: LD_INT 4
47548: PUSH
47549: EMPTY
47550: LIST
47551: LIST
47552: LIST
47553: IN
47554: IFFALSE 47678
// begin if btype = b_armoury then
47556: LD_VAR 0 5
47560: PUSH
47561: LD_INT 4
47563: EQUAL
47564: IFFALSE 47574
// btype := b_barracks ;
47566: LD_ADDR_VAR 0 5
47570: PUSH
47571: LD_INT 5
47573: ST_TO_ADDR
// if btype = b_depot then
47574: LD_VAR 0 5
47578: PUSH
47579: LD_INT 0
47581: EQUAL
47582: IFFALSE 47592
// btype := b_warehouse ;
47584: LD_ADDR_VAR 0 5
47588: PUSH
47589: LD_INT 1
47591: ST_TO_ADDR
// if btype = b_workshop then
47592: LD_VAR 0 5
47596: PUSH
47597: LD_INT 2
47599: EQUAL
47600: IFFALSE 47610
// btype := b_factory ;
47602: LD_ADDR_VAR 0 5
47606: PUSH
47607: LD_INT 3
47609: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47610: LD_VAR 0 5
47614: PPUSH
47615: LD_VAR 0 8
47619: PPUSH
47620: CALL_OW 323
47624: PUSH
47625: LD_INT 1
47627: EQUAL
47628: IFFALSE 47674
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47630: LD_ADDR_EXP 82
47634: PUSH
47635: LD_EXP 82
47639: PPUSH
47640: LD_VAR 0 3
47644: PUSH
47645: LD_EXP 82
47649: PUSH
47650: LD_VAR 0 3
47654: ARRAY
47655: PUSH
47656: LD_INT 1
47658: PLUS
47659: PUSH
47660: EMPTY
47661: LIST
47662: LIST
47663: PPUSH
47664: LD_VAR 0 1
47668: PPUSH
47669: CALL 53785 0 3
47673: ST_TO_ADDR
// exit ;
47674: POP
47675: POP
47676: GO 47991
// end ; if btype in [ b_bunker , b_turret ] then
47678: LD_VAR 0 5
47682: PUSH
47683: LD_INT 32
47685: PUSH
47686: LD_INT 33
47688: PUSH
47689: EMPTY
47690: LIST
47691: LIST
47692: IN
47693: IFFALSE 47983
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47695: LD_ADDR_EXP 58
47699: PUSH
47700: LD_EXP 58
47704: PPUSH
47705: LD_VAR 0 3
47709: PUSH
47710: LD_EXP 58
47714: PUSH
47715: LD_VAR 0 3
47719: ARRAY
47720: PUSH
47721: LD_INT 1
47723: PLUS
47724: PUSH
47725: EMPTY
47726: LIST
47727: LIST
47728: PPUSH
47729: LD_VAR 0 1
47733: PPUSH
47734: CALL 53785 0 3
47738: ST_TO_ADDR
// if btype = b_bunker then
47739: LD_VAR 0 5
47743: PUSH
47744: LD_INT 32
47746: EQUAL
47747: IFFALSE 47983
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47749: LD_ADDR_EXP 59
47753: PUSH
47754: LD_EXP 59
47758: PPUSH
47759: LD_VAR 0 3
47763: PUSH
47764: LD_EXP 59
47768: PUSH
47769: LD_VAR 0 3
47773: ARRAY
47774: PUSH
47775: LD_INT 1
47777: PLUS
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: PPUSH
47783: LD_VAR 0 1
47787: PPUSH
47788: CALL 53785 0 3
47792: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47793: LD_ADDR_VAR 0 6
47797: PUSH
47798: LD_EXP 50
47802: PUSH
47803: LD_VAR 0 3
47807: ARRAY
47808: PPUSH
47809: LD_INT 25
47811: PUSH
47812: LD_INT 1
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PUSH
47819: LD_INT 3
47821: PUSH
47822: LD_INT 54
47824: PUSH
47825: EMPTY
47826: LIST
47827: PUSH
47828: EMPTY
47829: LIST
47830: LIST
47831: PUSH
47832: EMPTY
47833: LIST
47834: LIST
47835: PPUSH
47836: CALL_OW 72
47840: ST_TO_ADDR
// if tmp then
47841: LD_VAR 0 6
47845: IFFALSE 47851
// exit ;
47847: POP
47848: POP
47849: GO 47991
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47851: LD_ADDR_VAR 0 6
47855: PUSH
47856: LD_EXP 50
47860: PUSH
47861: LD_VAR 0 3
47865: ARRAY
47866: PPUSH
47867: LD_INT 2
47869: PUSH
47870: LD_INT 30
47872: PUSH
47873: LD_INT 4
47875: PUSH
47876: EMPTY
47877: LIST
47878: LIST
47879: PUSH
47880: LD_INT 30
47882: PUSH
47883: LD_INT 5
47885: PUSH
47886: EMPTY
47887: LIST
47888: LIST
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: LIST
47894: PPUSH
47895: CALL_OW 72
47899: ST_TO_ADDR
// if not tmp then
47900: LD_VAR 0 6
47904: NOT
47905: IFFALSE 47911
// exit ;
47907: POP
47908: POP
47909: GO 47991
// for j in tmp do
47911: LD_ADDR_VAR 0 4
47915: PUSH
47916: LD_VAR 0 6
47920: PUSH
47921: FOR_IN
47922: IFFALSE 47981
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47924: LD_ADDR_VAR 0 7
47928: PUSH
47929: LD_VAR 0 4
47933: PPUSH
47934: CALL_OW 313
47938: PPUSH
47939: LD_INT 25
47941: PUSH
47942: LD_INT 1
47944: PUSH
47945: EMPTY
47946: LIST
47947: LIST
47948: PPUSH
47949: CALL_OW 72
47953: ST_TO_ADDR
// if units then
47954: LD_VAR 0 7
47958: IFFALSE 47979
// begin ComExitBuilding ( units [ 1 ] ) ;
47960: LD_VAR 0 7
47964: PUSH
47965: LD_INT 1
47967: ARRAY
47968: PPUSH
47969: CALL_OW 122
// exit ;
47973: POP
47974: POP
47975: POP
47976: POP
47977: GO 47991
// end ; end ;
47979: GO 47921
47981: POP
47982: POP
// end ; end ; exit ;
47983: POP
47984: POP
47985: GO 47991
// end ; end ;
47987: GO 47345
47989: POP
47990: POP
// end ;
47991: LD_VAR 0 2
47995: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47996: LD_INT 0
47998: PPUSH
47999: PPUSH
48000: PPUSH
48001: PPUSH
48002: PPUSH
48003: PPUSH
48004: PPUSH
// if not mc_bases or not skirmish then
48005: LD_EXP 50
48009: NOT
48010: PUSH
48011: LD_EXP 48
48015: NOT
48016: OR
48017: IFFALSE 48021
// exit ;
48019: GO 48286
// btype := GetBType ( building ) ;
48021: LD_ADDR_VAR 0 6
48025: PUSH
48026: LD_VAR 0 1
48030: PPUSH
48031: CALL_OW 266
48035: ST_TO_ADDR
// x := GetX ( building ) ;
48036: LD_ADDR_VAR 0 7
48040: PUSH
48041: LD_VAR 0 1
48045: PPUSH
48046: CALL_OW 250
48050: ST_TO_ADDR
// y := GetY ( building ) ;
48051: LD_ADDR_VAR 0 8
48055: PUSH
48056: LD_VAR 0 1
48060: PPUSH
48061: CALL_OW 251
48065: ST_TO_ADDR
// d := GetDir ( building ) ;
48066: LD_ADDR_VAR 0 9
48070: PUSH
48071: LD_VAR 0 1
48075: PPUSH
48076: CALL_OW 254
48080: ST_TO_ADDR
// for i = 1 to mc_bases do
48081: LD_ADDR_VAR 0 4
48085: PUSH
48086: DOUBLE
48087: LD_INT 1
48089: DEC
48090: ST_TO_ADDR
48091: LD_EXP 50
48095: PUSH
48096: FOR_TO
48097: IFFALSE 48284
// begin if not mc_build_list [ i ] then
48099: LD_EXP 55
48103: PUSH
48104: LD_VAR 0 4
48108: ARRAY
48109: NOT
48110: IFFALSE 48114
// continue ;
48112: GO 48096
// for j := 1 to mc_build_list [ i ] do
48114: LD_ADDR_VAR 0 5
48118: PUSH
48119: DOUBLE
48120: LD_INT 1
48122: DEC
48123: ST_TO_ADDR
48124: LD_EXP 55
48128: PUSH
48129: LD_VAR 0 4
48133: ARRAY
48134: PUSH
48135: FOR_TO
48136: IFFALSE 48280
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48138: LD_VAR 0 6
48142: PUSH
48143: LD_VAR 0 7
48147: PUSH
48148: LD_VAR 0 8
48152: PUSH
48153: LD_VAR 0 9
48157: PUSH
48158: EMPTY
48159: LIST
48160: LIST
48161: LIST
48162: LIST
48163: PPUSH
48164: LD_EXP 55
48168: PUSH
48169: LD_VAR 0 4
48173: ARRAY
48174: PUSH
48175: LD_VAR 0 5
48179: ARRAY
48180: PPUSH
48181: CALL 59965 0 2
48185: IFFALSE 48278
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48187: LD_ADDR_EXP 55
48191: PUSH
48192: LD_EXP 55
48196: PPUSH
48197: LD_VAR 0 4
48201: PPUSH
48202: LD_EXP 55
48206: PUSH
48207: LD_VAR 0 4
48211: ARRAY
48212: PPUSH
48213: LD_VAR 0 5
48217: PPUSH
48218: CALL_OW 3
48222: PPUSH
48223: CALL_OW 1
48227: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48228: LD_ADDR_EXP 57
48232: PUSH
48233: LD_EXP 57
48237: PPUSH
48238: LD_VAR 0 4
48242: PUSH
48243: LD_EXP 57
48247: PUSH
48248: LD_VAR 0 4
48252: ARRAY
48253: PUSH
48254: LD_INT 1
48256: PLUS
48257: PUSH
48258: EMPTY
48259: LIST
48260: LIST
48261: PPUSH
48262: LD_VAR 0 1
48266: PPUSH
48267: CALL 53785 0 3
48271: ST_TO_ADDR
// exit ;
48272: POP
48273: POP
48274: POP
48275: POP
48276: GO 48286
// end ;
48278: GO 48135
48280: POP
48281: POP
// end ;
48282: GO 48096
48284: POP
48285: POP
// end ;
48286: LD_VAR 0 3
48290: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48291: LD_INT 0
48293: PPUSH
48294: PPUSH
48295: PPUSH
// if not mc_bases or not skirmish then
48296: LD_EXP 50
48300: NOT
48301: PUSH
48302: LD_EXP 48
48306: NOT
48307: OR
48308: IFFALSE 48312
// exit ;
48310: GO 48502
// for i = 1 to mc_bases do
48312: LD_ADDR_VAR 0 4
48316: PUSH
48317: DOUBLE
48318: LD_INT 1
48320: DEC
48321: ST_TO_ADDR
48322: LD_EXP 50
48326: PUSH
48327: FOR_TO
48328: IFFALSE 48415
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48330: LD_VAR 0 1
48334: PUSH
48335: LD_EXP 58
48339: PUSH
48340: LD_VAR 0 4
48344: ARRAY
48345: IN
48346: PUSH
48347: LD_VAR 0 1
48351: PUSH
48352: LD_EXP 59
48356: PUSH
48357: LD_VAR 0 4
48361: ARRAY
48362: IN
48363: NOT
48364: AND
48365: IFFALSE 48413
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48367: LD_ADDR_EXP 59
48371: PUSH
48372: LD_EXP 59
48376: PPUSH
48377: LD_VAR 0 4
48381: PUSH
48382: LD_EXP 59
48386: PUSH
48387: LD_VAR 0 4
48391: ARRAY
48392: PUSH
48393: LD_INT 1
48395: PLUS
48396: PUSH
48397: EMPTY
48398: LIST
48399: LIST
48400: PPUSH
48401: LD_VAR 0 1
48405: PPUSH
48406: CALL 53785 0 3
48410: ST_TO_ADDR
// break ;
48411: GO 48415
// end ; end ;
48413: GO 48327
48415: POP
48416: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48417: LD_VAR 0 1
48421: PPUSH
48422: CALL_OW 257
48426: PUSH
48427: LD_EXP 76
48431: IN
48432: PUSH
48433: LD_VAR 0 1
48437: PPUSH
48438: CALL_OW 266
48442: PUSH
48443: LD_INT 5
48445: EQUAL
48446: AND
48447: PUSH
48448: LD_VAR 0 2
48452: PPUSH
48453: CALL_OW 110
48457: PUSH
48458: LD_INT 18
48460: NONEQUAL
48461: AND
48462: IFFALSE 48502
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48464: LD_VAR 0 2
48468: PPUSH
48469: CALL_OW 257
48473: PUSH
48474: LD_INT 5
48476: PUSH
48477: LD_INT 8
48479: PUSH
48480: LD_INT 9
48482: PUSH
48483: EMPTY
48484: LIST
48485: LIST
48486: LIST
48487: IN
48488: IFFALSE 48502
// SetClass ( unit , 1 ) ;
48490: LD_VAR 0 2
48494: PPUSH
48495: LD_INT 1
48497: PPUSH
48498: CALL_OW 336
// end ;
48502: LD_VAR 0 3
48506: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48507: LD_INT 0
48509: PPUSH
48510: PPUSH
// if not mc_bases or not skirmish then
48511: LD_EXP 50
48515: NOT
48516: PUSH
48517: LD_EXP 48
48521: NOT
48522: OR
48523: IFFALSE 48527
// exit ;
48525: GO 48643
// if GetLives ( abandoned_vehicle ) > 250 then
48527: LD_VAR 0 2
48531: PPUSH
48532: CALL_OW 256
48536: PUSH
48537: LD_INT 250
48539: GREATER
48540: IFFALSE 48544
// exit ;
48542: GO 48643
// for i = 1 to mc_bases do
48544: LD_ADDR_VAR 0 6
48548: PUSH
48549: DOUBLE
48550: LD_INT 1
48552: DEC
48553: ST_TO_ADDR
48554: LD_EXP 50
48558: PUSH
48559: FOR_TO
48560: IFFALSE 48641
// begin if driver in mc_bases [ i ] then
48562: LD_VAR 0 1
48566: PUSH
48567: LD_EXP 50
48571: PUSH
48572: LD_VAR 0 6
48576: ARRAY
48577: IN
48578: IFFALSE 48639
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48580: LD_VAR 0 1
48584: PPUSH
48585: LD_EXP 50
48589: PUSH
48590: LD_VAR 0 6
48594: ARRAY
48595: PPUSH
48596: LD_INT 2
48598: PUSH
48599: LD_INT 30
48601: PUSH
48602: LD_INT 0
48604: PUSH
48605: EMPTY
48606: LIST
48607: LIST
48608: PUSH
48609: LD_INT 30
48611: PUSH
48612: LD_INT 1
48614: PUSH
48615: EMPTY
48616: LIST
48617: LIST
48618: PUSH
48619: EMPTY
48620: LIST
48621: LIST
48622: LIST
48623: PPUSH
48624: CALL_OW 72
48628: PUSH
48629: LD_INT 1
48631: ARRAY
48632: PPUSH
48633: CALL 86993 0 2
// break ;
48637: GO 48641
// end ; end ;
48639: GO 48559
48641: POP
48642: POP
// end ; end_of_file
48643: LD_VAR 0 5
48647: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48648: LD_INT 0
48650: PPUSH
48651: PPUSH
// if exist_mode then
48652: LD_VAR 0 2
48656: IFFALSE 48681
// unit := CreateCharacter ( prefix & ident ) else
48658: LD_ADDR_VAR 0 5
48662: PUSH
48663: LD_VAR 0 3
48667: PUSH
48668: LD_VAR 0 1
48672: STR
48673: PPUSH
48674: CALL_OW 34
48678: ST_TO_ADDR
48679: GO 48696
// unit := NewCharacter ( ident ) ;
48681: LD_ADDR_VAR 0 5
48685: PUSH
48686: LD_VAR 0 1
48690: PPUSH
48691: CALL_OW 25
48695: ST_TO_ADDR
// result := unit ;
48696: LD_ADDR_VAR 0 4
48700: PUSH
48701: LD_VAR 0 5
48705: ST_TO_ADDR
// end ;
48706: LD_VAR 0 4
48710: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48711: LD_INT 0
48713: PPUSH
48714: PPUSH
// if not side or not nation then
48715: LD_VAR 0 1
48719: NOT
48720: PUSH
48721: LD_VAR 0 2
48725: NOT
48726: OR
48727: IFFALSE 48731
// exit ;
48729: GO 49499
// case nation of nation_american :
48731: LD_VAR 0 2
48735: PUSH
48736: LD_INT 1
48738: DOUBLE
48739: EQUAL
48740: IFTRUE 48744
48742: GO 48958
48744: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48745: LD_ADDR_VAR 0 4
48749: PUSH
48750: LD_INT 35
48752: PUSH
48753: LD_INT 45
48755: PUSH
48756: LD_INT 46
48758: PUSH
48759: LD_INT 47
48761: PUSH
48762: LD_INT 82
48764: PUSH
48765: LD_INT 83
48767: PUSH
48768: LD_INT 84
48770: PUSH
48771: LD_INT 85
48773: PUSH
48774: LD_INT 86
48776: PUSH
48777: LD_INT 1
48779: PUSH
48780: LD_INT 2
48782: PUSH
48783: LD_INT 6
48785: PUSH
48786: LD_INT 15
48788: PUSH
48789: LD_INT 16
48791: PUSH
48792: LD_INT 7
48794: PUSH
48795: LD_INT 12
48797: PUSH
48798: LD_INT 13
48800: PUSH
48801: LD_INT 10
48803: PUSH
48804: LD_INT 14
48806: PUSH
48807: LD_INT 20
48809: PUSH
48810: LD_INT 21
48812: PUSH
48813: LD_INT 22
48815: PUSH
48816: LD_INT 25
48818: PUSH
48819: LD_INT 32
48821: PUSH
48822: LD_INT 27
48824: PUSH
48825: LD_INT 36
48827: PUSH
48828: LD_INT 69
48830: PUSH
48831: LD_INT 39
48833: PUSH
48834: LD_INT 34
48836: PUSH
48837: LD_INT 40
48839: PUSH
48840: LD_INT 48
48842: PUSH
48843: LD_INT 49
48845: PUSH
48846: LD_INT 50
48848: PUSH
48849: LD_INT 51
48851: PUSH
48852: LD_INT 52
48854: PUSH
48855: LD_INT 53
48857: PUSH
48858: LD_INT 54
48860: PUSH
48861: LD_INT 55
48863: PUSH
48864: LD_INT 56
48866: PUSH
48867: LD_INT 57
48869: PUSH
48870: LD_INT 58
48872: PUSH
48873: LD_INT 59
48875: PUSH
48876: LD_INT 60
48878: PUSH
48879: LD_INT 61
48881: PUSH
48882: LD_INT 62
48884: PUSH
48885: LD_INT 80
48887: PUSH
48888: LD_INT 82
48890: PUSH
48891: LD_INT 83
48893: PUSH
48894: LD_INT 84
48896: PUSH
48897: LD_INT 85
48899: PUSH
48900: LD_INT 86
48902: PUSH
48903: EMPTY
48904: LIST
48905: LIST
48906: LIST
48907: LIST
48908: LIST
48909: LIST
48910: LIST
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: LIST
48938: LIST
48939: LIST
48940: LIST
48941: LIST
48942: LIST
48943: LIST
48944: LIST
48945: LIST
48946: LIST
48947: LIST
48948: LIST
48949: LIST
48950: LIST
48951: LIST
48952: LIST
48953: LIST
48954: LIST
48955: ST_TO_ADDR
48956: GO 49423
48958: LD_INT 2
48960: DOUBLE
48961: EQUAL
48962: IFTRUE 48966
48964: GO 49192
48966: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
48967: LD_ADDR_VAR 0 4
48971: PUSH
48972: LD_INT 35
48974: PUSH
48975: LD_INT 45
48977: PUSH
48978: LD_INT 46
48980: PUSH
48981: LD_INT 47
48983: PUSH
48984: LD_INT 82
48986: PUSH
48987: LD_INT 83
48989: PUSH
48990: LD_INT 84
48992: PUSH
48993: LD_INT 85
48995: PUSH
48996: LD_INT 87
48998: PUSH
48999: LD_INT 70
49001: PUSH
49002: LD_INT 1
49004: PUSH
49005: LD_INT 11
49007: PUSH
49008: LD_INT 3
49010: PUSH
49011: LD_INT 4
49013: PUSH
49014: LD_INT 5
49016: PUSH
49017: LD_INT 6
49019: PUSH
49020: LD_INT 15
49022: PUSH
49023: LD_INT 18
49025: PUSH
49026: LD_INT 7
49028: PUSH
49029: LD_INT 17
49031: PUSH
49032: LD_INT 8
49034: PUSH
49035: LD_INT 20
49037: PUSH
49038: LD_INT 21
49040: PUSH
49041: LD_INT 22
49043: PUSH
49044: LD_INT 72
49046: PUSH
49047: LD_INT 26
49049: PUSH
49050: LD_INT 69
49052: PUSH
49053: LD_INT 39
49055: PUSH
49056: LD_INT 40
49058: PUSH
49059: LD_INT 41
49061: PUSH
49062: LD_INT 42
49064: PUSH
49065: LD_INT 43
49067: PUSH
49068: LD_INT 48
49070: PUSH
49071: LD_INT 49
49073: PUSH
49074: LD_INT 50
49076: PUSH
49077: LD_INT 51
49079: PUSH
49080: LD_INT 52
49082: PUSH
49083: LD_INT 53
49085: PUSH
49086: LD_INT 54
49088: PUSH
49089: LD_INT 55
49091: PUSH
49092: LD_INT 56
49094: PUSH
49095: LD_INT 60
49097: PUSH
49098: LD_INT 61
49100: PUSH
49101: LD_INT 62
49103: PUSH
49104: LD_INT 66
49106: PUSH
49107: LD_INT 67
49109: PUSH
49110: LD_INT 68
49112: PUSH
49113: LD_INT 81
49115: PUSH
49116: LD_INT 82
49118: PUSH
49119: LD_INT 83
49121: PUSH
49122: LD_INT 84
49124: PUSH
49125: LD_INT 85
49127: PUSH
49128: LD_INT 87
49130: PUSH
49131: LD_INT 88
49133: PUSH
49134: EMPTY
49135: LIST
49136: LIST
49137: LIST
49138: LIST
49139: LIST
49140: LIST
49141: LIST
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: LIST
49147: LIST
49148: LIST
49149: LIST
49150: LIST
49151: LIST
49152: LIST
49153: LIST
49154: LIST
49155: LIST
49156: LIST
49157: LIST
49158: LIST
49159: LIST
49160: LIST
49161: LIST
49162: LIST
49163: LIST
49164: LIST
49165: LIST
49166: LIST
49167: LIST
49168: LIST
49169: LIST
49170: LIST
49171: LIST
49172: LIST
49173: LIST
49174: LIST
49175: LIST
49176: LIST
49177: LIST
49178: LIST
49179: LIST
49180: LIST
49181: LIST
49182: LIST
49183: LIST
49184: LIST
49185: LIST
49186: LIST
49187: LIST
49188: LIST
49189: ST_TO_ADDR
49190: GO 49423
49192: LD_INT 3
49194: DOUBLE
49195: EQUAL
49196: IFTRUE 49200
49198: GO 49422
49200: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49201: LD_ADDR_VAR 0 4
49205: PUSH
49206: LD_INT 46
49208: PUSH
49209: LD_INT 47
49211: PUSH
49212: LD_INT 1
49214: PUSH
49215: LD_INT 2
49217: PUSH
49218: LD_INT 82
49220: PUSH
49221: LD_INT 83
49223: PUSH
49224: LD_INT 84
49226: PUSH
49227: LD_INT 85
49229: PUSH
49230: LD_INT 86
49232: PUSH
49233: LD_INT 11
49235: PUSH
49236: LD_INT 9
49238: PUSH
49239: LD_INT 20
49241: PUSH
49242: LD_INT 19
49244: PUSH
49245: LD_INT 21
49247: PUSH
49248: LD_INT 24
49250: PUSH
49251: LD_INT 22
49253: PUSH
49254: LD_INT 25
49256: PUSH
49257: LD_INT 28
49259: PUSH
49260: LD_INT 29
49262: PUSH
49263: LD_INT 30
49265: PUSH
49266: LD_INT 31
49268: PUSH
49269: LD_INT 37
49271: PUSH
49272: LD_INT 38
49274: PUSH
49275: LD_INT 32
49277: PUSH
49278: LD_INT 27
49280: PUSH
49281: LD_INT 33
49283: PUSH
49284: LD_INT 69
49286: PUSH
49287: LD_INT 39
49289: PUSH
49290: LD_INT 34
49292: PUSH
49293: LD_INT 40
49295: PUSH
49296: LD_INT 71
49298: PUSH
49299: LD_INT 23
49301: PUSH
49302: LD_INT 44
49304: PUSH
49305: LD_INT 48
49307: PUSH
49308: LD_INT 49
49310: PUSH
49311: LD_INT 50
49313: PUSH
49314: LD_INT 51
49316: PUSH
49317: LD_INT 52
49319: PUSH
49320: LD_INT 53
49322: PUSH
49323: LD_INT 54
49325: PUSH
49326: LD_INT 55
49328: PUSH
49329: LD_INT 56
49331: PUSH
49332: LD_INT 57
49334: PUSH
49335: LD_INT 58
49337: PUSH
49338: LD_INT 59
49340: PUSH
49341: LD_INT 63
49343: PUSH
49344: LD_INT 64
49346: PUSH
49347: LD_INT 65
49349: PUSH
49350: LD_INT 82
49352: PUSH
49353: LD_INT 83
49355: PUSH
49356: LD_INT 84
49358: PUSH
49359: LD_INT 85
49361: PUSH
49362: LD_INT 86
49364: PUSH
49365: EMPTY
49366: LIST
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: LIST
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: LIST
49380: LIST
49381: LIST
49382: LIST
49383: LIST
49384: LIST
49385: LIST
49386: LIST
49387: LIST
49388: LIST
49389: LIST
49390: LIST
49391: LIST
49392: LIST
49393: LIST
49394: LIST
49395: LIST
49396: LIST
49397: LIST
49398: LIST
49399: LIST
49400: LIST
49401: LIST
49402: LIST
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: LIST
49410: LIST
49411: LIST
49412: LIST
49413: LIST
49414: LIST
49415: LIST
49416: LIST
49417: LIST
49418: LIST
49419: ST_TO_ADDR
49420: GO 49423
49422: POP
// if state > - 1 and state < 3 then
49423: LD_VAR 0 3
49427: PUSH
49428: LD_INT 1
49430: NEG
49431: GREATER
49432: PUSH
49433: LD_VAR 0 3
49437: PUSH
49438: LD_INT 3
49440: LESS
49441: AND
49442: IFFALSE 49499
// for i in result do
49444: LD_ADDR_VAR 0 5
49448: PUSH
49449: LD_VAR 0 4
49453: PUSH
49454: FOR_IN
49455: IFFALSE 49497
// if GetTech ( i , side ) <> state then
49457: LD_VAR 0 5
49461: PPUSH
49462: LD_VAR 0 1
49466: PPUSH
49467: CALL_OW 321
49471: PUSH
49472: LD_VAR 0 3
49476: NONEQUAL
49477: IFFALSE 49495
// result := result diff i ;
49479: LD_ADDR_VAR 0 4
49483: PUSH
49484: LD_VAR 0 4
49488: PUSH
49489: LD_VAR 0 5
49493: DIFF
49494: ST_TO_ADDR
49495: GO 49454
49497: POP
49498: POP
// end ;
49499: LD_VAR 0 4
49503: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49504: LD_INT 0
49506: PPUSH
49507: PPUSH
49508: PPUSH
// result := true ;
49509: LD_ADDR_VAR 0 3
49513: PUSH
49514: LD_INT 1
49516: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49517: LD_ADDR_VAR 0 5
49521: PUSH
49522: LD_VAR 0 2
49526: PPUSH
49527: CALL_OW 480
49531: ST_TO_ADDR
// if not tmp then
49532: LD_VAR 0 5
49536: NOT
49537: IFFALSE 49541
// exit ;
49539: GO 49590
// for i in tmp do
49541: LD_ADDR_VAR 0 4
49545: PUSH
49546: LD_VAR 0 5
49550: PUSH
49551: FOR_IN
49552: IFFALSE 49588
// if GetTech ( i , side ) <> state_researched then
49554: LD_VAR 0 4
49558: PPUSH
49559: LD_VAR 0 1
49563: PPUSH
49564: CALL_OW 321
49568: PUSH
49569: LD_INT 2
49571: NONEQUAL
49572: IFFALSE 49586
// begin result := false ;
49574: LD_ADDR_VAR 0 3
49578: PUSH
49579: LD_INT 0
49581: ST_TO_ADDR
// exit ;
49582: POP
49583: POP
49584: GO 49590
// end ;
49586: GO 49551
49588: POP
49589: POP
// end ;
49590: LD_VAR 0 3
49594: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49595: LD_INT 0
49597: PPUSH
49598: PPUSH
49599: PPUSH
49600: PPUSH
49601: PPUSH
49602: PPUSH
49603: PPUSH
49604: PPUSH
49605: PPUSH
49606: PPUSH
49607: PPUSH
49608: PPUSH
49609: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49610: LD_VAR 0 1
49614: NOT
49615: PUSH
49616: LD_VAR 0 1
49620: PPUSH
49621: CALL_OW 257
49625: PUSH
49626: LD_INT 9
49628: NONEQUAL
49629: OR
49630: IFFALSE 49634
// exit ;
49632: GO 50207
// side := GetSide ( unit ) ;
49634: LD_ADDR_VAR 0 9
49638: PUSH
49639: LD_VAR 0 1
49643: PPUSH
49644: CALL_OW 255
49648: ST_TO_ADDR
// tech_space := tech_spacanom ;
49649: LD_ADDR_VAR 0 12
49653: PUSH
49654: LD_INT 29
49656: ST_TO_ADDR
// tech_time := tech_taurad ;
49657: LD_ADDR_VAR 0 13
49661: PUSH
49662: LD_INT 28
49664: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49665: LD_ADDR_VAR 0 11
49669: PUSH
49670: LD_VAR 0 1
49674: PPUSH
49675: CALL_OW 310
49679: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49680: LD_VAR 0 11
49684: PPUSH
49685: CALL_OW 247
49689: PUSH
49690: LD_INT 2
49692: EQUAL
49693: IFFALSE 49697
// exit ;
49695: GO 50207
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49697: LD_ADDR_VAR 0 8
49701: PUSH
49702: LD_INT 81
49704: PUSH
49705: LD_VAR 0 9
49709: PUSH
49710: EMPTY
49711: LIST
49712: LIST
49713: PUSH
49714: LD_INT 3
49716: PUSH
49717: LD_INT 21
49719: PUSH
49720: LD_INT 3
49722: PUSH
49723: EMPTY
49724: LIST
49725: LIST
49726: PUSH
49727: EMPTY
49728: LIST
49729: LIST
49730: PUSH
49731: EMPTY
49732: LIST
49733: LIST
49734: PPUSH
49735: CALL_OW 69
49739: ST_TO_ADDR
// if not tmp then
49740: LD_VAR 0 8
49744: NOT
49745: IFFALSE 49749
// exit ;
49747: GO 50207
// if in_unit then
49749: LD_VAR 0 11
49753: IFFALSE 49777
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49755: LD_ADDR_VAR 0 10
49759: PUSH
49760: LD_VAR 0 8
49764: PPUSH
49765: LD_VAR 0 11
49769: PPUSH
49770: CALL_OW 74
49774: ST_TO_ADDR
49775: GO 49797
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49777: LD_ADDR_VAR 0 10
49781: PUSH
49782: LD_VAR 0 8
49786: PPUSH
49787: LD_VAR 0 1
49791: PPUSH
49792: CALL_OW 74
49796: ST_TO_ADDR
// if not enemy then
49797: LD_VAR 0 10
49801: NOT
49802: IFFALSE 49806
// exit ;
49804: GO 50207
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49806: LD_VAR 0 11
49810: PUSH
49811: LD_VAR 0 11
49815: PPUSH
49816: LD_VAR 0 10
49820: PPUSH
49821: CALL_OW 296
49825: PUSH
49826: LD_INT 13
49828: GREATER
49829: AND
49830: PUSH
49831: LD_VAR 0 1
49835: PPUSH
49836: LD_VAR 0 10
49840: PPUSH
49841: CALL_OW 296
49845: PUSH
49846: LD_INT 12
49848: GREATER
49849: OR
49850: IFFALSE 49854
// exit ;
49852: GO 50207
// missile := [ 1 ] ;
49854: LD_ADDR_VAR 0 14
49858: PUSH
49859: LD_INT 1
49861: PUSH
49862: EMPTY
49863: LIST
49864: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49865: LD_VAR 0 9
49869: PPUSH
49870: LD_VAR 0 12
49874: PPUSH
49875: CALL_OW 325
49879: IFFALSE 49908
// missile := Replace ( missile , missile + 1 , 2 ) ;
49881: LD_ADDR_VAR 0 14
49885: PUSH
49886: LD_VAR 0 14
49890: PPUSH
49891: LD_VAR 0 14
49895: PUSH
49896: LD_INT 1
49898: PLUS
49899: PPUSH
49900: LD_INT 2
49902: PPUSH
49903: CALL_OW 1
49907: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49908: LD_VAR 0 9
49912: PPUSH
49913: LD_VAR 0 13
49917: PPUSH
49918: CALL_OW 325
49922: PUSH
49923: LD_VAR 0 10
49927: PPUSH
49928: CALL_OW 255
49932: PPUSH
49933: LD_VAR 0 13
49937: PPUSH
49938: CALL_OW 325
49942: NOT
49943: AND
49944: IFFALSE 49973
// missile := Replace ( missile , missile + 1 , 3 ) ;
49946: LD_ADDR_VAR 0 14
49950: PUSH
49951: LD_VAR 0 14
49955: PPUSH
49956: LD_VAR 0 14
49960: PUSH
49961: LD_INT 1
49963: PLUS
49964: PPUSH
49965: LD_INT 3
49967: PPUSH
49968: CALL_OW 1
49972: ST_TO_ADDR
// if missile < 2 then
49973: LD_VAR 0 14
49977: PUSH
49978: LD_INT 2
49980: LESS
49981: IFFALSE 49985
// exit ;
49983: GO 50207
// x := GetX ( enemy ) ;
49985: LD_ADDR_VAR 0 4
49989: PUSH
49990: LD_VAR 0 10
49994: PPUSH
49995: CALL_OW 250
49999: ST_TO_ADDR
// y := GetY ( enemy ) ;
50000: LD_ADDR_VAR 0 5
50004: PUSH
50005: LD_VAR 0 10
50009: PPUSH
50010: CALL_OW 251
50014: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50015: LD_ADDR_VAR 0 6
50019: PUSH
50020: LD_VAR 0 4
50024: PUSH
50025: LD_INT 1
50027: NEG
50028: PPUSH
50029: LD_INT 1
50031: PPUSH
50032: CALL_OW 12
50036: PLUS
50037: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50038: LD_ADDR_VAR 0 7
50042: PUSH
50043: LD_VAR 0 5
50047: PUSH
50048: LD_INT 1
50050: NEG
50051: PPUSH
50052: LD_INT 1
50054: PPUSH
50055: CALL_OW 12
50059: PLUS
50060: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50061: LD_VAR 0 6
50065: PPUSH
50066: LD_VAR 0 7
50070: PPUSH
50071: CALL_OW 488
50075: NOT
50076: IFFALSE 50098
// begin _x := x ;
50078: LD_ADDR_VAR 0 6
50082: PUSH
50083: LD_VAR 0 4
50087: ST_TO_ADDR
// _y := y ;
50088: LD_ADDR_VAR 0 7
50092: PUSH
50093: LD_VAR 0 5
50097: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50098: LD_ADDR_VAR 0 3
50102: PUSH
50103: LD_INT 1
50105: PPUSH
50106: LD_VAR 0 14
50110: PPUSH
50111: CALL_OW 12
50115: ST_TO_ADDR
// case i of 1 :
50116: LD_VAR 0 3
50120: PUSH
50121: LD_INT 1
50123: DOUBLE
50124: EQUAL
50125: IFTRUE 50129
50127: GO 50146
50129: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50130: LD_VAR 0 1
50134: PPUSH
50135: LD_VAR 0 10
50139: PPUSH
50140: CALL_OW 115
50144: GO 50207
50146: LD_INT 2
50148: DOUBLE
50149: EQUAL
50150: IFTRUE 50154
50152: GO 50176
50154: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50155: LD_VAR 0 1
50159: PPUSH
50160: LD_VAR 0 6
50164: PPUSH
50165: LD_VAR 0 7
50169: PPUSH
50170: CALL_OW 153
50174: GO 50207
50176: LD_INT 3
50178: DOUBLE
50179: EQUAL
50180: IFTRUE 50184
50182: GO 50206
50184: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50185: LD_VAR 0 1
50189: PPUSH
50190: LD_VAR 0 6
50194: PPUSH
50195: LD_VAR 0 7
50199: PPUSH
50200: CALL_OW 154
50204: GO 50207
50206: POP
// end ;
50207: LD_VAR 0 2
50211: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50212: LD_INT 0
50214: PPUSH
50215: PPUSH
50216: PPUSH
50217: PPUSH
50218: PPUSH
50219: PPUSH
// if not unit or not building then
50220: LD_VAR 0 1
50224: NOT
50225: PUSH
50226: LD_VAR 0 2
50230: NOT
50231: OR
50232: IFFALSE 50236
// exit ;
50234: GO 50394
// x := GetX ( building ) ;
50236: LD_ADDR_VAR 0 5
50240: PUSH
50241: LD_VAR 0 2
50245: PPUSH
50246: CALL_OW 250
50250: ST_TO_ADDR
// y := GetY ( building ) ;
50251: LD_ADDR_VAR 0 6
50255: PUSH
50256: LD_VAR 0 2
50260: PPUSH
50261: CALL_OW 251
50265: ST_TO_ADDR
// for i = 0 to 5 do
50266: LD_ADDR_VAR 0 4
50270: PUSH
50271: DOUBLE
50272: LD_INT 0
50274: DEC
50275: ST_TO_ADDR
50276: LD_INT 5
50278: PUSH
50279: FOR_TO
50280: IFFALSE 50392
// begin _x := ShiftX ( x , i , 3 ) ;
50282: LD_ADDR_VAR 0 7
50286: PUSH
50287: LD_VAR 0 5
50291: PPUSH
50292: LD_VAR 0 4
50296: PPUSH
50297: LD_INT 3
50299: PPUSH
50300: CALL_OW 272
50304: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50305: LD_ADDR_VAR 0 8
50309: PUSH
50310: LD_VAR 0 6
50314: PPUSH
50315: LD_VAR 0 4
50319: PPUSH
50320: LD_INT 3
50322: PPUSH
50323: CALL_OW 273
50327: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50328: LD_VAR 0 7
50332: PPUSH
50333: LD_VAR 0 8
50337: PPUSH
50338: CALL_OW 488
50342: NOT
50343: IFFALSE 50347
// continue ;
50345: GO 50279
// if HexInfo ( _x , _y ) = 0 then
50347: LD_VAR 0 7
50351: PPUSH
50352: LD_VAR 0 8
50356: PPUSH
50357: CALL_OW 428
50361: PUSH
50362: LD_INT 0
50364: EQUAL
50365: IFFALSE 50390
// begin ComMoveXY ( unit , _x , _y ) ;
50367: LD_VAR 0 1
50371: PPUSH
50372: LD_VAR 0 7
50376: PPUSH
50377: LD_VAR 0 8
50381: PPUSH
50382: CALL_OW 111
// exit ;
50386: POP
50387: POP
50388: GO 50394
// end ; end ;
50390: GO 50279
50392: POP
50393: POP
// end ;
50394: LD_VAR 0 3
50398: RET
// export function ScanBase ( side , base_area ) ; begin
50399: LD_INT 0
50401: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50402: LD_ADDR_VAR 0 3
50406: PUSH
50407: LD_VAR 0 2
50411: PPUSH
50412: LD_INT 81
50414: PUSH
50415: LD_VAR 0 1
50419: PUSH
50420: EMPTY
50421: LIST
50422: LIST
50423: PPUSH
50424: CALL_OW 70
50428: ST_TO_ADDR
// end ;
50429: LD_VAR 0 3
50433: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50434: LD_INT 0
50436: PPUSH
50437: PPUSH
50438: PPUSH
50439: PPUSH
// result := false ;
50440: LD_ADDR_VAR 0 2
50444: PUSH
50445: LD_INT 0
50447: ST_TO_ADDR
// side := GetSide ( unit ) ;
50448: LD_ADDR_VAR 0 3
50452: PUSH
50453: LD_VAR 0 1
50457: PPUSH
50458: CALL_OW 255
50462: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50463: LD_ADDR_VAR 0 4
50467: PUSH
50468: LD_VAR 0 1
50472: PPUSH
50473: CALL_OW 248
50477: ST_TO_ADDR
// case nat of 1 :
50478: LD_VAR 0 4
50482: PUSH
50483: LD_INT 1
50485: DOUBLE
50486: EQUAL
50487: IFTRUE 50491
50489: GO 50502
50491: POP
// tech := tech_lassight ; 2 :
50492: LD_ADDR_VAR 0 5
50496: PUSH
50497: LD_INT 12
50499: ST_TO_ADDR
50500: GO 50541
50502: LD_INT 2
50504: DOUBLE
50505: EQUAL
50506: IFTRUE 50510
50508: GO 50521
50510: POP
// tech := tech_mortar ; 3 :
50511: LD_ADDR_VAR 0 5
50515: PUSH
50516: LD_INT 41
50518: ST_TO_ADDR
50519: GO 50541
50521: LD_INT 3
50523: DOUBLE
50524: EQUAL
50525: IFTRUE 50529
50527: GO 50540
50529: POP
// tech := tech_bazooka ; end ;
50530: LD_ADDR_VAR 0 5
50534: PUSH
50535: LD_INT 44
50537: ST_TO_ADDR
50538: GO 50541
50540: POP
// if Researched ( side , tech ) then
50541: LD_VAR 0 3
50545: PPUSH
50546: LD_VAR 0 5
50550: PPUSH
50551: CALL_OW 325
50555: IFFALSE 50582
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50557: LD_ADDR_VAR 0 2
50561: PUSH
50562: LD_INT 5
50564: PUSH
50565: LD_INT 8
50567: PUSH
50568: LD_INT 9
50570: PUSH
50571: EMPTY
50572: LIST
50573: LIST
50574: LIST
50575: PUSH
50576: LD_VAR 0 4
50580: ARRAY
50581: ST_TO_ADDR
// end ;
50582: LD_VAR 0 2
50586: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50587: LD_INT 0
50589: PPUSH
50590: PPUSH
50591: PPUSH
// if not mines then
50592: LD_VAR 0 2
50596: NOT
50597: IFFALSE 50601
// exit ;
50599: GO 50745
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50601: LD_ADDR_VAR 0 5
50605: PUSH
50606: LD_INT 81
50608: PUSH
50609: LD_VAR 0 1
50613: PUSH
50614: EMPTY
50615: LIST
50616: LIST
50617: PUSH
50618: LD_INT 3
50620: PUSH
50621: LD_INT 21
50623: PUSH
50624: LD_INT 3
50626: PUSH
50627: EMPTY
50628: LIST
50629: LIST
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: EMPTY
50636: LIST
50637: LIST
50638: PPUSH
50639: CALL_OW 69
50643: ST_TO_ADDR
// for i in mines do
50644: LD_ADDR_VAR 0 4
50648: PUSH
50649: LD_VAR 0 2
50653: PUSH
50654: FOR_IN
50655: IFFALSE 50743
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50657: LD_VAR 0 4
50661: PUSH
50662: LD_INT 1
50664: ARRAY
50665: PPUSH
50666: LD_VAR 0 4
50670: PUSH
50671: LD_INT 2
50673: ARRAY
50674: PPUSH
50675: CALL_OW 458
50679: NOT
50680: IFFALSE 50684
// continue ;
50682: GO 50654
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50684: LD_VAR 0 4
50688: PUSH
50689: LD_INT 1
50691: ARRAY
50692: PPUSH
50693: LD_VAR 0 4
50697: PUSH
50698: LD_INT 2
50700: ARRAY
50701: PPUSH
50702: CALL_OW 428
50706: PUSH
50707: LD_VAR 0 5
50711: IN
50712: IFFALSE 50741
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50714: LD_VAR 0 4
50718: PUSH
50719: LD_INT 1
50721: ARRAY
50722: PPUSH
50723: LD_VAR 0 4
50727: PUSH
50728: LD_INT 2
50730: ARRAY
50731: PPUSH
50732: LD_VAR 0 1
50736: PPUSH
50737: CALL_OW 456
// end ;
50741: GO 50654
50743: POP
50744: POP
// end ;
50745: LD_VAR 0 3
50749: RET
// export function Count ( array ) ; var i ; begin
50750: LD_INT 0
50752: PPUSH
50753: PPUSH
// result := 0 ;
50754: LD_ADDR_VAR 0 2
50758: PUSH
50759: LD_INT 0
50761: ST_TO_ADDR
// for i in array do
50762: LD_ADDR_VAR 0 3
50766: PUSH
50767: LD_VAR 0 1
50771: PUSH
50772: FOR_IN
50773: IFFALSE 50797
// if i then
50775: LD_VAR 0 3
50779: IFFALSE 50795
// result := result + 1 ;
50781: LD_ADDR_VAR 0 2
50785: PUSH
50786: LD_VAR 0 2
50790: PUSH
50791: LD_INT 1
50793: PLUS
50794: ST_TO_ADDR
50795: GO 50772
50797: POP
50798: POP
// end ;
50799: LD_VAR 0 2
50803: RET
// export function IsEmpty ( building ) ; begin
50804: LD_INT 0
50806: PPUSH
// if not building then
50807: LD_VAR 0 1
50811: NOT
50812: IFFALSE 50816
// exit ;
50814: GO 50859
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50816: LD_ADDR_VAR 0 2
50820: PUSH
50821: LD_VAR 0 1
50825: PUSH
50826: LD_INT 22
50828: PUSH
50829: LD_VAR 0 1
50833: PPUSH
50834: CALL_OW 255
50838: PUSH
50839: EMPTY
50840: LIST
50841: LIST
50842: PUSH
50843: LD_INT 58
50845: PUSH
50846: EMPTY
50847: LIST
50848: PUSH
50849: EMPTY
50850: LIST
50851: LIST
50852: PPUSH
50853: CALL_OW 69
50857: IN
50858: ST_TO_ADDR
// end ;
50859: LD_VAR 0 2
50863: RET
// export function IsNotFull ( building ) ; var places ; begin
50864: LD_INT 0
50866: PPUSH
50867: PPUSH
// if not building then
50868: LD_VAR 0 1
50872: NOT
50873: IFFALSE 50877
// exit ;
50875: GO 51048
// result := false ;
50877: LD_ADDR_VAR 0 2
50881: PUSH
50882: LD_INT 0
50884: ST_TO_ADDR
// places := 0 ;
50885: LD_ADDR_VAR 0 3
50889: PUSH
50890: LD_INT 0
50892: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
50893: LD_VAR 0 1
50897: PPUSH
50898: CALL_OW 266
50902: PUSH
50903: LD_INT 0
50905: DOUBLE
50906: EQUAL
50907: IFTRUE 50965
50909: LD_INT 1
50911: DOUBLE
50912: EQUAL
50913: IFTRUE 50965
50915: LD_INT 6
50917: DOUBLE
50918: EQUAL
50919: IFTRUE 50965
50921: LD_INT 7
50923: DOUBLE
50924: EQUAL
50925: IFTRUE 50965
50927: LD_INT 8
50929: DOUBLE
50930: EQUAL
50931: IFTRUE 50965
50933: LD_INT 4
50935: DOUBLE
50936: EQUAL
50937: IFTRUE 50965
50939: LD_INT 5
50941: DOUBLE
50942: EQUAL
50943: IFTRUE 50965
50945: LD_INT 2
50947: DOUBLE
50948: EQUAL
50949: IFTRUE 50965
50951: LD_INT 3
50953: DOUBLE
50954: EQUAL
50955: IFTRUE 50965
50957: LD_INT 35
50959: DOUBLE
50960: EQUAL
50961: IFTRUE 50965
50963: GO 50976
50965: POP
// places := 6 ; b_bunker , b_breastwork :
50966: LD_ADDR_VAR 0 3
50970: PUSH
50971: LD_INT 6
50973: ST_TO_ADDR
50974: GO 51021
50976: LD_INT 32
50978: DOUBLE
50979: EQUAL
50980: IFTRUE 50990
50982: LD_INT 31
50984: DOUBLE
50985: EQUAL
50986: IFTRUE 50990
50988: GO 51001
50990: POP
// places := 1 ; b_control_tower :
50991: LD_ADDR_VAR 0 3
50995: PUSH
50996: LD_INT 1
50998: ST_TO_ADDR
50999: GO 51021
51001: LD_INT 36
51003: DOUBLE
51004: EQUAL
51005: IFTRUE 51009
51007: GO 51020
51009: POP
// places := 3 ; end ;
51010: LD_ADDR_VAR 0 3
51014: PUSH
51015: LD_INT 3
51017: ST_TO_ADDR
51018: GO 51021
51020: POP
// if places then
51021: LD_VAR 0 3
51025: IFFALSE 51048
// result := UnitsInside ( building ) < places ;
51027: LD_ADDR_VAR 0 2
51031: PUSH
51032: LD_VAR 0 1
51036: PPUSH
51037: CALL_OW 313
51041: PUSH
51042: LD_VAR 0 3
51046: LESS
51047: ST_TO_ADDR
// end ;
51048: LD_VAR 0 2
51052: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51053: LD_INT 0
51055: PPUSH
51056: PPUSH
51057: PPUSH
51058: PPUSH
// tmp := [ ] ;
51059: LD_ADDR_VAR 0 3
51063: PUSH
51064: EMPTY
51065: ST_TO_ADDR
// list := [ ] ;
51066: LD_ADDR_VAR 0 5
51070: PUSH
51071: EMPTY
51072: ST_TO_ADDR
// for i = 16 to 25 do
51073: LD_ADDR_VAR 0 4
51077: PUSH
51078: DOUBLE
51079: LD_INT 16
51081: DEC
51082: ST_TO_ADDR
51083: LD_INT 25
51085: PUSH
51086: FOR_TO
51087: IFFALSE 51160
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51089: LD_ADDR_VAR 0 3
51093: PUSH
51094: LD_VAR 0 3
51098: PUSH
51099: LD_INT 22
51101: PUSH
51102: LD_VAR 0 1
51106: PPUSH
51107: CALL_OW 255
51111: PUSH
51112: EMPTY
51113: LIST
51114: LIST
51115: PUSH
51116: LD_INT 91
51118: PUSH
51119: LD_VAR 0 1
51123: PUSH
51124: LD_INT 6
51126: PUSH
51127: EMPTY
51128: LIST
51129: LIST
51130: LIST
51131: PUSH
51132: LD_INT 30
51134: PUSH
51135: LD_VAR 0 4
51139: PUSH
51140: EMPTY
51141: LIST
51142: LIST
51143: PUSH
51144: EMPTY
51145: LIST
51146: LIST
51147: LIST
51148: PUSH
51149: EMPTY
51150: LIST
51151: PPUSH
51152: CALL_OW 69
51156: ADD
51157: ST_TO_ADDR
51158: GO 51086
51160: POP
51161: POP
// for i = 1 to tmp do
51162: LD_ADDR_VAR 0 4
51166: PUSH
51167: DOUBLE
51168: LD_INT 1
51170: DEC
51171: ST_TO_ADDR
51172: LD_VAR 0 3
51176: PUSH
51177: FOR_TO
51178: IFFALSE 51266
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51180: LD_ADDR_VAR 0 5
51184: PUSH
51185: LD_VAR 0 5
51189: PUSH
51190: LD_VAR 0 3
51194: PUSH
51195: LD_VAR 0 4
51199: ARRAY
51200: PPUSH
51201: CALL_OW 266
51205: PUSH
51206: LD_VAR 0 3
51210: PUSH
51211: LD_VAR 0 4
51215: ARRAY
51216: PPUSH
51217: CALL_OW 250
51221: PUSH
51222: LD_VAR 0 3
51226: PUSH
51227: LD_VAR 0 4
51231: ARRAY
51232: PPUSH
51233: CALL_OW 251
51237: PUSH
51238: LD_VAR 0 3
51242: PUSH
51243: LD_VAR 0 4
51247: ARRAY
51248: PPUSH
51249: CALL_OW 254
51253: PUSH
51254: EMPTY
51255: LIST
51256: LIST
51257: LIST
51258: LIST
51259: PUSH
51260: EMPTY
51261: LIST
51262: ADD
51263: ST_TO_ADDR
51264: GO 51177
51266: POP
51267: POP
// result := list ;
51268: LD_ADDR_VAR 0 2
51272: PUSH
51273: LD_VAR 0 5
51277: ST_TO_ADDR
// end ;
51278: LD_VAR 0 2
51282: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51283: LD_INT 0
51285: PPUSH
51286: PPUSH
51287: PPUSH
51288: PPUSH
51289: PPUSH
51290: PPUSH
51291: PPUSH
// if not factory then
51292: LD_VAR 0 1
51296: NOT
51297: IFFALSE 51301
// exit ;
51299: GO 51894
// if control = control_apeman then
51301: LD_VAR 0 4
51305: PUSH
51306: LD_INT 5
51308: EQUAL
51309: IFFALSE 51418
// begin tmp := UnitsInside ( factory ) ;
51311: LD_ADDR_VAR 0 8
51315: PUSH
51316: LD_VAR 0 1
51320: PPUSH
51321: CALL_OW 313
51325: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51326: LD_VAR 0 8
51330: PPUSH
51331: LD_INT 25
51333: PUSH
51334: LD_INT 12
51336: PUSH
51337: EMPTY
51338: LIST
51339: LIST
51340: PPUSH
51341: CALL_OW 72
51345: NOT
51346: IFFALSE 51356
// control := control_manual ;
51348: LD_ADDR_VAR 0 4
51352: PUSH
51353: LD_INT 1
51355: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51356: LD_ADDR_VAR 0 8
51360: PUSH
51361: LD_VAR 0 1
51365: PPUSH
51366: CALL 51053 0 1
51370: ST_TO_ADDR
// if tmp then
51371: LD_VAR 0 8
51375: IFFALSE 51418
// begin for i in tmp do
51377: LD_ADDR_VAR 0 7
51381: PUSH
51382: LD_VAR 0 8
51386: PUSH
51387: FOR_IN
51388: IFFALSE 51416
// if i [ 1 ] = b_ext_radio then
51390: LD_VAR 0 7
51394: PUSH
51395: LD_INT 1
51397: ARRAY
51398: PUSH
51399: LD_INT 22
51401: EQUAL
51402: IFFALSE 51414
// begin control := control_remote ;
51404: LD_ADDR_VAR 0 4
51408: PUSH
51409: LD_INT 2
51411: ST_TO_ADDR
// break ;
51412: GO 51416
// end ;
51414: GO 51387
51416: POP
51417: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51418: LD_VAR 0 1
51422: PPUSH
51423: LD_VAR 0 2
51427: PPUSH
51428: LD_VAR 0 3
51432: PPUSH
51433: LD_VAR 0 4
51437: PPUSH
51438: LD_VAR 0 5
51442: PPUSH
51443: CALL_OW 448
51447: IFFALSE 51482
// begin result := [ chassis , engine , control , weapon ] ;
51449: LD_ADDR_VAR 0 6
51453: PUSH
51454: LD_VAR 0 2
51458: PUSH
51459: LD_VAR 0 3
51463: PUSH
51464: LD_VAR 0 4
51468: PUSH
51469: LD_VAR 0 5
51473: PUSH
51474: EMPTY
51475: LIST
51476: LIST
51477: LIST
51478: LIST
51479: ST_TO_ADDR
// exit ;
51480: GO 51894
// end ; _chassis := AvailableChassisList ( factory ) ;
51482: LD_ADDR_VAR 0 9
51486: PUSH
51487: LD_VAR 0 1
51491: PPUSH
51492: CALL_OW 475
51496: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51497: LD_ADDR_VAR 0 11
51501: PUSH
51502: LD_VAR 0 1
51506: PPUSH
51507: CALL_OW 476
51511: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51512: LD_ADDR_VAR 0 12
51516: PUSH
51517: LD_VAR 0 1
51521: PPUSH
51522: CALL_OW 477
51526: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51527: LD_ADDR_VAR 0 10
51531: PUSH
51532: LD_VAR 0 1
51536: PPUSH
51537: CALL_OW 478
51541: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51542: LD_VAR 0 9
51546: NOT
51547: PUSH
51548: LD_VAR 0 11
51552: NOT
51553: OR
51554: PUSH
51555: LD_VAR 0 12
51559: NOT
51560: OR
51561: PUSH
51562: LD_VAR 0 10
51566: NOT
51567: OR
51568: IFFALSE 51603
// begin result := [ chassis , engine , control , weapon ] ;
51570: LD_ADDR_VAR 0 6
51574: PUSH
51575: LD_VAR 0 2
51579: PUSH
51580: LD_VAR 0 3
51584: PUSH
51585: LD_VAR 0 4
51589: PUSH
51590: LD_VAR 0 5
51594: PUSH
51595: EMPTY
51596: LIST
51597: LIST
51598: LIST
51599: LIST
51600: ST_TO_ADDR
// exit ;
51601: GO 51894
// end ; if not chassis in _chassis then
51603: LD_VAR 0 2
51607: PUSH
51608: LD_VAR 0 9
51612: IN
51613: NOT
51614: IFFALSE 51640
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51616: LD_ADDR_VAR 0 2
51620: PUSH
51621: LD_VAR 0 9
51625: PUSH
51626: LD_INT 1
51628: PPUSH
51629: LD_VAR 0 9
51633: PPUSH
51634: CALL_OW 12
51638: ARRAY
51639: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51640: LD_VAR 0 2
51644: PPUSH
51645: LD_VAR 0 3
51649: PPUSH
51650: CALL 51899 0 2
51654: NOT
51655: IFFALSE 51714
// repeat engine := _engine [ 1 ] ;
51657: LD_ADDR_VAR 0 3
51661: PUSH
51662: LD_VAR 0 11
51666: PUSH
51667: LD_INT 1
51669: ARRAY
51670: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51671: LD_ADDR_VAR 0 11
51675: PUSH
51676: LD_VAR 0 11
51680: PPUSH
51681: LD_INT 1
51683: PPUSH
51684: CALL_OW 3
51688: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51689: LD_VAR 0 2
51693: PPUSH
51694: LD_VAR 0 3
51698: PPUSH
51699: CALL 51899 0 2
51703: PUSH
51704: LD_VAR 0 11
51708: PUSH
51709: EMPTY
51710: EQUAL
51711: OR
51712: IFFALSE 51657
// if not control in _control then
51714: LD_VAR 0 4
51718: PUSH
51719: LD_VAR 0 12
51723: IN
51724: NOT
51725: IFFALSE 51751
// control := _control [ rand ( 1 , _control ) ] ;
51727: LD_ADDR_VAR 0 4
51731: PUSH
51732: LD_VAR 0 12
51736: PUSH
51737: LD_INT 1
51739: PPUSH
51740: LD_VAR 0 12
51744: PPUSH
51745: CALL_OW 12
51749: ARRAY
51750: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51751: LD_VAR 0 2
51755: PPUSH
51756: LD_VAR 0 5
51760: PPUSH
51761: CALL 52119 0 2
51765: NOT
51766: IFFALSE 51825
// repeat weapon := _weapon [ 1 ] ;
51768: LD_ADDR_VAR 0 5
51772: PUSH
51773: LD_VAR 0 10
51777: PUSH
51778: LD_INT 1
51780: ARRAY
51781: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51782: LD_ADDR_VAR 0 10
51786: PUSH
51787: LD_VAR 0 10
51791: PPUSH
51792: LD_INT 1
51794: PPUSH
51795: CALL_OW 3
51799: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51800: LD_VAR 0 2
51804: PPUSH
51805: LD_VAR 0 5
51809: PPUSH
51810: CALL 52119 0 2
51814: PUSH
51815: LD_VAR 0 10
51819: PUSH
51820: EMPTY
51821: EQUAL
51822: OR
51823: IFFALSE 51768
// result := [ ] ;
51825: LD_ADDR_VAR 0 6
51829: PUSH
51830: EMPTY
51831: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51832: LD_VAR 0 1
51836: PPUSH
51837: LD_VAR 0 2
51841: PPUSH
51842: LD_VAR 0 3
51846: PPUSH
51847: LD_VAR 0 4
51851: PPUSH
51852: LD_VAR 0 5
51856: PPUSH
51857: CALL_OW 448
51861: IFFALSE 51894
// result := [ chassis , engine , control , weapon ] ;
51863: LD_ADDR_VAR 0 6
51867: PUSH
51868: LD_VAR 0 2
51872: PUSH
51873: LD_VAR 0 3
51877: PUSH
51878: LD_VAR 0 4
51882: PUSH
51883: LD_VAR 0 5
51887: PUSH
51888: EMPTY
51889: LIST
51890: LIST
51891: LIST
51892: LIST
51893: ST_TO_ADDR
// end ;
51894: LD_VAR 0 6
51898: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51899: LD_INT 0
51901: PPUSH
// if not chassis or not engine then
51902: LD_VAR 0 1
51906: NOT
51907: PUSH
51908: LD_VAR 0 2
51912: NOT
51913: OR
51914: IFFALSE 51918
// exit ;
51916: GO 52114
// case engine of engine_solar :
51918: LD_VAR 0 2
51922: PUSH
51923: LD_INT 2
51925: DOUBLE
51926: EQUAL
51927: IFTRUE 51931
51929: GO 51969
51931: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51932: LD_ADDR_VAR 0 3
51936: PUSH
51937: LD_INT 11
51939: PUSH
51940: LD_INT 12
51942: PUSH
51943: LD_INT 13
51945: PUSH
51946: LD_INT 14
51948: PUSH
51949: LD_INT 1
51951: PUSH
51952: LD_INT 2
51954: PUSH
51955: LD_INT 3
51957: PUSH
51958: EMPTY
51959: LIST
51960: LIST
51961: LIST
51962: LIST
51963: LIST
51964: LIST
51965: LIST
51966: ST_TO_ADDR
51967: GO 52098
51969: LD_INT 1
51971: DOUBLE
51972: EQUAL
51973: IFTRUE 51977
51975: GO 52039
51977: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51978: LD_ADDR_VAR 0 3
51982: PUSH
51983: LD_INT 11
51985: PUSH
51986: LD_INT 12
51988: PUSH
51989: LD_INT 13
51991: PUSH
51992: LD_INT 14
51994: PUSH
51995: LD_INT 1
51997: PUSH
51998: LD_INT 2
52000: PUSH
52001: LD_INT 3
52003: PUSH
52004: LD_INT 4
52006: PUSH
52007: LD_INT 5
52009: PUSH
52010: LD_INT 21
52012: PUSH
52013: LD_INT 23
52015: PUSH
52016: LD_INT 22
52018: PUSH
52019: LD_INT 24
52021: PUSH
52022: EMPTY
52023: LIST
52024: LIST
52025: LIST
52026: LIST
52027: LIST
52028: LIST
52029: LIST
52030: LIST
52031: LIST
52032: LIST
52033: LIST
52034: LIST
52035: LIST
52036: ST_TO_ADDR
52037: GO 52098
52039: LD_INT 3
52041: DOUBLE
52042: EQUAL
52043: IFTRUE 52047
52045: GO 52097
52047: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52048: LD_ADDR_VAR 0 3
52052: PUSH
52053: LD_INT 13
52055: PUSH
52056: LD_INT 14
52058: PUSH
52059: LD_INT 2
52061: PUSH
52062: LD_INT 3
52064: PUSH
52065: LD_INT 4
52067: PUSH
52068: LD_INT 5
52070: PUSH
52071: LD_INT 21
52073: PUSH
52074: LD_INT 22
52076: PUSH
52077: LD_INT 23
52079: PUSH
52080: LD_INT 24
52082: PUSH
52083: EMPTY
52084: LIST
52085: LIST
52086: LIST
52087: LIST
52088: LIST
52089: LIST
52090: LIST
52091: LIST
52092: LIST
52093: LIST
52094: ST_TO_ADDR
52095: GO 52098
52097: POP
// result := ( chassis in result ) ;
52098: LD_ADDR_VAR 0 3
52102: PUSH
52103: LD_VAR 0 1
52107: PUSH
52108: LD_VAR 0 3
52112: IN
52113: ST_TO_ADDR
// end ;
52114: LD_VAR 0 3
52118: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52119: LD_INT 0
52121: PPUSH
// if not chassis or not weapon then
52122: LD_VAR 0 1
52126: NOT
52127: PUSH
52128: LD_VAR 0 2
52132: NOT
52133: OR
52134: IFFALSE 52138
// exit ;
52136: GO 53198
// case weapon of us_machine_gun :
52138: LD_VAR 0 2
52142: PUSH
52143: LD_INT 2
52145: DOUBLE
52146: EQUAL
52147: IFTRUE 52151
52149: GO 52181
52151: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52152: LD_ADDR_VAR 0 3
52156: PUSH
52157: LD_INT 1
52159: PUSH
52160: LD_INT 2
52162: PUSH
52163: LD_INT 3
52165: PUSH
52166: LD_INT 4
52168: PUSH
52169: LD_INT 5
52171: PUSH
52172: EMPTY
52173: LIST
52174: LIST
52175: LIST
52176: LIST
52177: LIST
52178: ST_TO_ADDR
52179: GO 53182
52181: LD_INT 3
52183: DOUBLE
52184: EQUAL
52185: IFTRUE 52189
52187: GO 52219
52189: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52190: LD_ADDR_VAR 0 3
52194: PUSH
52195: LD_INT 1
52197: PUSH
52198: LD_INT 2
52200: PUSH
52201: LD_INT 3
52203: PUSH
52204: LD_INT 4
52206: PUSH
52207: LD_INT 5
52209: PUSH
52210: EMPTY
52211: LIST
52212: LIST
52213: LIST
52214: LIST
52215: LIST
52216: ST_TO_ADDR
52217: GO 53182
52219: LD_INT 11
52221: DOUBLE
52222: EQUAL
52223: IFTRUE 52227
52225: GO 52257
52227: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52228: LD_ADDR_VAR 0 3
52232: PUSH
52233: LD_INT 1
52235: PUSH
52236: LD_INT 2
52238: PUSH
52239: LD_INT 3
52241: PUSH
52242: LD_INT 4
52244: PUSH
52245: LD_INT 5
52247: PUSH
52248: EMPTY
52249: LIST
52250: LIST
52251: LIST
52252: LIST
52253: LIST
52254: ST_TO_ADDR
52255: GO 53182
52257: LD_INT 4
52259: DOUBLE
52260: EQUAL
52261: IFTRUE 52265
52263: GO 52291
52265: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52266: LD_ADDR_VAR 0 3
52270: PUSH
52271: LD_INT 2
52273: PUSH
52274: LD_INT 3
52276: PUSH
52277: LD_INT 4
52279: PUSH
52280: LD_INT 5
52282: PUSH
52283: EMPTY
52284: LIST
52285: LIST
52286: LIST
52287: LIST
52288: ST_TO_ADDR
52289: GO 53182
52291: LD_INT 5
52293: DOUBLE
52294: EQUAL
52295: IFTRUE 52299
52297: GO 52325
52299: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52300: LD_ADDR_VAR 0 3
52304: PUSH
52305: LD_INT 2
52307: PUSH
52308: LD_INT 3
52310: PUSH
52311: LD_INT 4
52313: PUSH
52314: LD_INT 5
52316: PUSH
52317: EMPTY
52318: LIST
52319: LIST
52320: LIST
52321: LIST
52322: ST_TO_ADDR
52323: GO 53182
52325: LD_INT 9
52327: DOUBLE
52328: EQUAL
52329: IFTRUE 52333
52331: GO 52359
52333: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52334: LD_ADDR_VAR 0 3
52338: PUSH
52339: LD_INT 2
52341: PUSH
52342: LD_INT 3
52344: PUSH
52345: LD_INT 4
52347: PUSH
52348: LD_INT 5
52350: PUSH
52351: EMPTY
52352: LIST
52353: LIST
52354: LIST
52355: LIST
52356: ST_TO_ADDR
52357: GO 53182
52359: LD_INT 7
52361: DOUBLE
52362: EQUAL
52363: IFTRUE 52367
52365: GO 52393
52367: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52368: LD_ADDR_VAR 0 3
52372: PUSH
52373: LD_INT 2
52375: PUSH
52376: LD_INT 3
52378: PUSH
52379: LD_INT 4
52381: PUSH
52382: LD_INT 5
52384: PUSH
52385: EMPTY
52386: LIST
52387: LIST
52388: LIST
52389: LIST
52390: ST_TO_ADDR
52391: GO 53182
52393: LD_INT 12
52395: DOUBLE
52396: EQUAL
52397: IFTRUE 52401
52399: GO 52427
52401: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52402: LD_ADDR_VAR 0 3
52406: PUSH
52407: LD_INT 2
52409: PUSH
52410: LD_INT 3
52412: PUSH
52413: LD_INT 4
52415: PUSH
52416: LD_INT 5
52418: PUSH
52419: EMPTY
52420: LIST
52421: LIST
52422: LIST
52423: LIST
52424: ST_TO_ADDR
52425: GO 53182
52427: LD_INT 13
52429: DOUBLE
52430: EQUAL
52431: IFTRUE 52435
52433: GO 52461
52435: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52436: LD_ADDR_VAR 0 3
52440: PUSH
52441: LD_INT 2
52443: PUSH
52444: LD_INT 3
52446: PUSH
52447: LD_INT 4
52449: PUSH
52450: LD_INT 5
52452: PUSH
52453: EMPTY
52454: LIST
52455: LIST
52456: LIST
52457: LIST
52458: ST_TO_ADDR
52459: GO 53182
52461: LD_INT 14
52463: DOUBLE
52464: EQUAL
52465: IFTRUE 52469
52467: GO 52487
52469: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52470: LD_ADDR_VAR 0 3
52474: PUSH
52475: LD_INT 4
52477: PUSH
52478: LD_INT 5
52480: PUSH
52481: EMPTY
52482: LIST
52483: LIST
52484: ST_TO_ADDR
52485: GO 53182
52487: LD_INT 6
52489: DOUBLE
52490: EQUAL
52491: IFTRUE 52495
52493: GO 52513
52495: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52496: LD_ADDR_VAR 0 3
52500: PUSH
52501: LD_INT 4
52503: PUSH
52504: LD_INT 5
52506: PUSH
52507: EMPTY
52508: LIST
52509: LIST
52510: ST_TO_ADDR
52511: GO 53182
52513: LD_INT 10
52515: DOUBLE
52516: EQUAL
52517: IFTRUE 52521
52519: GO 52539
52521: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52522: LD_ADDR_VAR 0 3
52526: PUSH
52527: LD_INT 4
52529: PUSH
52530: LD_INT 5
52532: PUSH
52533: EMPTY
52534: LIST
52535: LIST
52536: ST_TO_ADDR
52537: GO 53182
52539: LD_INT 22
52541: DOUBLE
52542: EQUAL
52543: IFTRUE 52547
52545: GO 52573
52547: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52548: LD_ADDR_VAR 0 3
52552: PUSH
52553: LD_INT 11
52555: PUSH
52556: LD_INT 12
52558: PUSH
52559: LD_INT 13
52561: PUSH
52562: LD_INT 14
52564: PUSH
52565: EMPTY
52566: LIST
52567: LIST
52568: LIST
52569: LIST
52570: ST_TO_ADDR
52571: GO 53182
52573: LD_INT 23
52575: DOUBLE
52576: EQUAL
52577: IFTRUE 52581
52579: GO 52607
52581: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52582: LD_ADDR_VAR 0 3
52586: PUSH
52587: LD_INT 11
52589: PUSH
52590: LD_INT 12
52592: PUSH
52593: LD_INT 13
52595: PUSH
52596: LD_INT 14
52598: PUSH
52599: EMPTY
52600: LIST
52601: LIST
52602: LIST
52603: LIST
52604: ST_TO_ADDR
52605: GO 53182
52607: LD_INT 24
52609: DOUBLE
52610: EQUAL
52611: IFTRUE 52615
52613: GO 52641
52615: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52616: LD_ADDR_VAR 0 3
52620: PUSH
52621: LD_INT 11
52623: PUSH
52624: LD_INT 12
52626: PUSH
52627: LD_INT 13
52629: PUSH
52630: LD_INT 14
52632: PUSH
52633: EMPTY
52634: LIST
52635: LIST
52636: LIST
52637: LIST
52638: ST_TO_ADDR
52639: GO 53182
52641: LD_INT 30
52643: DOUBLE
52644: EQUAL
52645: IFTRUE 52649
52647: GO 52675
52649: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52650: LD_ADDR_VAR 0 3
52654: PUSH
52655: LD_INT 11
52657: PUSH
52658: LD_INT 12
52660: PUSH
52661: LD_INT 13
52663: PUSH
52664: LD_INT 14
52666: PUSH
52667: EMPTY
52668: LIST
52669: LIST
52670: LIST
52671: LIST
52672: ST_TO_ADDR
52673: GO 53182
52675: LD_INT 25
52677: DOUBLE
52678: EQUAL
52679: IFTRUE 52683
52681: GO 52701
52683: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52684: LD_ADDR_VAR 0 3
52688: PUSH
52689: LD_INT 13
52691: PUSH
52692: LD_INT 14
52694: PUSH
52695: EMPTY
52696: LIST
52697: LIST
52698: ST_TO_ADDR
52699: GO 53182
52701: LD_INT 27
52703: DOUBLE
52704: EQUAL
52705: IFTRUE 52709
52707: GO 52727
52709: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52710: LD_ADDR_VAR 0 3
52714: PUSH
52715: LD_INT 13
52717: PUSH
52718: LD_INT 14
52720: PUSH
52721: EMPTY
52722: LIST
52723: LIST
52724: ST_TO_ADDR
52725: GO 53182
52727: LD_INT 92
52729: DOUBLE
52730: EQUAL
52731: IFTRUE 52735
52733: GO 52761
52735: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52736: LD_ADDR_VAR 0 3
52740: PUSH
52741: LD_INT 11
52743: PUSH
52744: LD_INT 12
52746: PUSH
52747: LD_INT 13
52749: PUSH
52750: LD_INT 14
52752: PUSH
52753: EMPTY
52754: LIST
52755: LIST
52756: LIST
52757: LIST
52758: ST_TO_ADDR
52759: GO 53182
52761: LD_INT 28
52763: DOUBLE
52764: EQUAL
52765: IFTRUE 52769
52767: GO 52787
52769: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52770: LD_ADDR_VAR 0 3
52774: PUSH
52775: LD_INT 13
52777: PUSH
52778: LD_INT 14
52780: PUSH
52781: EMPTY
52782: LIST
52783: LIST
52784: ST_TO_ADDR
52785: GO 53182
52787: LD_INT 29
52789: DOUBLE
52790: EQUAL
52791: IFTRUE 52795
52793: GO 52813
52795: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52796: LD_ADDR_VAR 0 3
52800: PUSH
52801: LD_INT 13
52803: PUSH
52804: LD_INT 14
52806: PUSH
52807: EMPTY
52808: LIST
52809: LIST
52810: ST_TO_ADDR
52811: GO 53182
52813: LD_INT 31
52815: DOUBLE
52816: EQUAL
52817: IFTRUE 52821
52819: GO 52839
52821: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52822: LD_ADDR_VAR 0 3
52826: PUSH
52827: LD_INT 13
52829: PUSH
52830: LD_INT 14
52832: PUSH
52833: EMPTY
52834: LIST
52835: LIST
52836: ST_TO_ADDR
52837: GO 53182
52839: LD_INT 26
52841: DOUBLE
52842: EQUAL
52843: IFTRUE 52847
52845: GO 52865
52847: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52848: LD_ADDR_VAR 0 3
52852: PUSH
52853: LD_INT 13
52855: PUSH
52856: LD_INT 14
52858: PUSH
52859: EMPTY
52860: LIST
52861: LIST
52862: ST_TO_ADDR
52863: GO 53182
52865: LD_INT 42
52867: DOUBLE
52868: EQUAL
52869: IFTRUE 52873
52871: GO 52899
52873: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52874: LD_ADDR_VAR 0 3
52878: PUSH
52879: LD_INT 21
52881: PUSH
52882: LD_INT 22
52884: PUSH
52885: LD_INT 23
52887: PUSH
52888: LD_INT 24
52890: PUSH
52891: EMPTY
52892: LIST
52893: LIST
52894: LIST
52895: LIST
52896: ST_TO_ADDR
52897: GO 53182
52899: LD_INT 43
52901: DOUBLE
52902: EQUAL
52903: IFTRUE 52907
52905: GO 52933
52907: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52908: LD_ADDR_VAR 0 3
52912: PUSH
52913: LD_INT 21
52915: PUSH
52916: LD_INT 22
52918: PUSH
52919: LD_INT 23
52921: PUSH
52922: LD_INT 24
52924: PUSH
52925: EMPTY
52926: LIST
52927: LIST
52928: LIST
52929: LIST
52930: ST_TO_ADDR
52931: GO 53182
52933: LD_INT 44
52935: DOUBLE
52936: EQUAL
52937: IFTRUE 52941
52939: GO 52967
52941: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52942: LD_ADDR_VAR 0 3
52946: PUSH
52947: LD_INT 21
52949: PUSH
52950: LD_INT 22
52952: PUSH
52953: LD_INT 23
52955: PUSH
52956: LD_INT 24
52958: PUSH
52959: EMPTY
52960: LIST
52961: LIST
52962: LIST
52963: LIST
52964: ST_TO_ADDR
52965: GO 53182
52967: LD_INT 45
52969: DOUBLE
52970: EQUAL
52971: IFTRUE 52975
52973: GO 53001
52975: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52976: LD_ADDR_VAR 0 3
52980: PUSH
52981: LD_INT 21
52983: PUSH
52984: LD_INT 22
52986: PUSH
52987: LD_INT 23
52989: PUSH
52990: LD_INT 24
52992: PUSH
52993: EMPTY
52994: LIST
52995: LIST
52996: LIST
52997: LIST
52998: ST_TO_ADDR
52999: GO 53182
53001: LD_INT 49
53003: DOUBLE
53004: EQUAL
53005: IFTRUE 53009
53007: GO 53035
53009: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53010: LD_ADDR_VAR 0 3
53014: PUSH
53015: LD_INT 21
53017: PUSH
53018: LD_INT 22
53020: PUSH
53021: LD_INT 23
53023: PUSH
53024: LD_INT 24
53026: PUSH
53027: EMPTY
53028: LIST
53029: LIST
53030: LIST
53031: LIST
53032: ST_TO_ADDR
53033: GO 53182
53035: LD_INT 51
53037: DOUBLE
53038: EQUAL
53039: IFTRUE 53043
53041: GO 53069
53043: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53044: LD_ADDR_VAR 0 3
53048: PUSH
53049: LD_INT 21
53051: PUSH
53052: LD_INT 22
53054: PUSH
53055: LD_INT 23
53057: PUSH
53058: LD_INT 24
53060: PUSH
53061: EMPTY
53062: LIST
53063: LIST
53064: LIST
53065: LIST
53066: ST_TO_ADDR
53067: GO 53182
53069: LD_INT 52
53071: DOUBLE
53072: EQUAL
53073: IFTRUE 53077
53075: GO 53103
53077: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53078: LD_ADDR_VAR 0 3
53082: PUSH
53083: LD_INT 21
53085: PUSH
53086: LD_INT 22
53088: PUSH
53089: LD_INT 23
53091: PUSH
53092: LD_INT 24
53094: PUSH
53095: EMPTY
53096: LIST
53097: LIST
53098: LIST
53099: LIST
53100: ST_TO_ADDR
53101: GO 53182
53103: LD_INT 53
53105: DOUBLE
53106: EQUAL
53107: IFTRUE 53111
53109: GO 53129
53111: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53112: LD_ADDR_VAR 0 3
53116: PUSH
53117: LD_INT 23
53119: PUSH
53120: LD_INT 24
53122: PUSH
53123: EMPTY
53124: LIST
53125: LIST
53126: ST_TO_ADDR
53127: GO 53182
53129: LD_INT 46
53131: DOUBLE
53132: EQUAL
53133: IFTRUE 53137
53135: GO 53155
53137: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53138: LD_ADDR_VAR 0 3
53142: PUSH
53143: LD_INT 23
53145: PUSH
53146: LD_INT 24
53148: PUSH
53149: EMPTY
53150: LIST
53151: LIST
53152: ST_TO_ADDR
53153: GO 53182
53155: LD_INT 47
53157: DOUBLE
53158: EQUAL
53159: IFTRUE 53163
53161: GO 53181
53163: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53164: LD_ADDR_VAR 0 3
53168: PUSH
53169: LD_INT 23
53171: PUSH
53172: LD_INT 24
53174: PUSH
53175: EMPTY
53176: LIST
53177: LIST
53178: ST_TO_ADDR
53179: GO 53182
53181: POP
// result := ( chassis in result ) ;
53182: LD_ADDR_VAR 0 3
53186: PUSH
53187: LD_VAR 0 1
53191: PUSH
53192: LD_VAR 0 3
53196: IN
53197: ST_TO_ADDR
// end ;
53198: LD_VAR 0 3
53202: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53203: LD_INT 0
53205: PPUSH
53206: PPUSH
53207: PPUSH
53208: PPUSH
53209: PPUSH
53210: PPUSH
53211: PPUSH
// result := array ;
53212: LD_ADDR_VAR 0 5
53216: PUSH
53217: LD_VAR 0 1
53221: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53222: LD_VAR 0 1
53226: NOT
53227: PUSH
53228: LD_VAR 0 2
53232: NOT
53233: OR
53234: PUSH
53235: LD_VAR 0 3
53239: NOT
53240: OR
53241: PUSH
53242: LD_VAR 0 2
53246: PUSH
53247: LD_VAR 0 1
53251: GREATER
53252: OR
53253: PUSH
53254: LD_VAR 0 3
53258: PUSH
53259: LD_VAR 0 1
53263: GREATER
53264: OR
53265: IFFALSE 53269
// exit ;
53267: GO 53565
// if direction then
53269: LD_VAR 0 4
53273: IFFALSE 53337
// begin d := 1 ;
53275: LD_ADDR_VAR 0 9
53279: PUSH
53280: LD_INT 1
53282: ST_TO_ADDR
// if i_from > i_to then
53283: LD_VAR 0 2
53287: PUSH
53288: LD_VAR 0 3
53292: GREATER
53293: IFFALSE 53319
// length := ( array - i_from ) + i_to else
53295: LD_ADDR_VAR 0 11
53299: PUSH
53300: LD_VAR 0 1
53304: PUSH
53305: LD_VAR 0 2
53309: MINUS
53310: PUSH
53311: LD_VAR 0 3
53315: PLUS
53316: ST_TO_ADDR
53317: GO 53335
// length := i_to - i_from ;
53319: LD_ADDR_VAR 0 11
53323: PUSH
53324: LD_VAR 0 3
53328: PUSH
53329: LD_VAR 0 2
53333: MINUS
53334: ST_TO_ADDR
// end else
53335: GO 53398
// begin d := - 1 ;
53337: LD_ADDR_VAR 0 9
53341: PUSH
53342: LD_INT 1
53344: NEG
53345: ST_TO_ADDR
// if i_from > i_to then
53346: LD_VAR 0 2
53350: PUSH
53351: LD_VAR 0 3
53355: GREATER
53356: IFFALSE 53376
// length := i_from - i_to else
53358: LD_ADDR_VAR 0 11
53362: PUSH
53363: LD_VAR 0 2
53367: PUSH
53368: LD_VAR 0 3
53372: MINUS
53373: ST_TO_ADDR
53374: GO 53398
// length := ( array - i_to ) + i_from ;
53376: LD_ADDR_VAR 0 11
53380: PUSH
53381: LD_VAR 0 1
53385: PUSH
53386: LD_VAR 0 3
53390: MINUS
53391: PUSH
53392: LD_VAR 0 2
53396: PLUS
53397: ST_TO_ADDR
// end ; if not length then
53398: LD_VAR 0 11
53402: NOT
53403: IFFALSE 53407
// exit ;
53405: GO 53565
// tmp := array ;
53407: LD_ADDR_VAR 0 10
53411: PUSH
53412: LD_VAR 0 1
53416: ST_TO_ADDR
// for i = 1 to length do
53417: LD_ADDR_VAR 0 6
53421: PUSH
53422: DOUBLE
53423: LD_INT 1
53425: DEC
53426: ST_TO_ADDR
53427: LD_VAR 0 11
53431: PUSH
53432: FOR_TO
53433: IFFALSE 53553
// begin for j = 1 to array do
53435: LD_ADDR_VAR 0 7
53439: PUSH
53440: DOUBLE
53441: LD_INT 1
53443: DEC
53444: ST_TO_ADDR
53445: LD_VAR 0 1
53449: PUSH
53450: FOR_TO
53451: IFFALSE 53539
// begin k := j + d ;
53453: LD_ADDR_VAR 0 8
53457: PUSH
53458: LD_VAR 0 7
53462: PUSH
53463: LD_VAR 0 9
53467: PLUS
53468: ST_TO_ADDR
// if k > array then
53469: LD_VAR 0 8
53473: PUSH
53474: LD_VAR 0 1
53478: GREATER
53479: IFFALSE 53489
// k := 1 ;
53481: LD_ADDR_VAR 0 8
53485: PUSH
53486: LD_INT 1
53488: ST_TO_ADDR
// if not k then
53489: LD_VAR 0 8
53493: NOT
53494: IFFALSE 53506
// k := array ;
53496: LD_ADDR_VAR 0 8
53500: PUSH
53501: LD_VAR 0 1
53505: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53506: LD_ADDR_VAR 0 10
53510: PUSH
53511: LD_VAR 0 10
53515: PPUSH
53516: LD_VAR 0 8
53520: PPUSH
53521: LD_VAR 0 1
53525: PUSH
53526: LD_VAR 0 7
53530: ARRAY
53531: PPUSH
53532: CALL_OW 1
53536: ST_TO_ADDR
// end ;
53537: GO 53450
53539: POP
53540: POP
// array := tmp ;
53541: LD_ADDR_VAR 0 1
53545: PUSH
53546: LD_VAR 0 10
53550: ST_TO_ADDR
// end ;
53551: GO 53432
53553: POP
53554: POP
// result := array ;
53555: LD_ADDR_VAR 0 5
53559: PUSH
53560: LD_VAR 0 1
53564: ST_TO_ADDR
// end ;
53565: LD_VAR 0 5
53569: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53570: LD_INT 0
53572: PPUSH
53573: PPUSH
// result := 0 ;
53574: LD_ADDR_VAR 0 3
53578: PUSH
53579: LD_INT 0
53581: ST_TO_ADDR
// if not array or not value in array then
53582: LD_VAR 0 1
53586: NOT
53587: PUSH
53588: LD_VAR 0 2
53592: PUSH
53593: LD_VAR 0 1
53597: IN
53598: NOT
53599: OR
53600: IFFALSE 53604
// exit ;
53602: GO 53658
// for i = 1 to array do
53604: LD_ADDR_VAR 0 4
53608: PUSH
53609: DOUBLE
53610: LD_INT 1
53612: DEC
53613: ST_TO_ADDR
53614: LD_VAR 0 1
53618: PUSH
53619: FOR_TO
53620: IFFALSE 53656
// if value = array [ i ] then
53622: LD_VAR 0 2
53626: PUSH
53627: LD_VAR 0 1
53631: PUSH
53632: LD_VAR 0 4
53636: ARRAY
53637: EQUAL
53638: IFFALSE 53654
// begin result := i ;
53640: LD_ADDR_VAR 0 3
53644: PUSH
53645: LD_VAR 0 4
53649: ST_TO_ADDR
// exit ;
53650: POP
53651: POP
53652: GO 53658
// end ;
53654: GO 53619
53656: POP
53657: POP
// end ;
53658: LD_VAR 0 3
53662: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53663: LD_INT 0
53665: PPUSH
// vc_chassis := chassis ;
53666: LD_ADDR_OWVAR 37
53670: PUSH
53671: LD_VAR 0 1
53675: ST_TO_ADDR
// vc_engine := engine ;
53676: LD_ADDR_OWVAR 39
53680: PUSH
53681: LD_VAR 0 2
53685: ST_TO_ADDR
// vc_control := control ;
53686: LD_ADDR_OWVAR 38
53690: PUSH
53691: LD_VAR 0 3
53695: ST_TO_ADDR
// vc_weapon := weapon ;
53696: LD_ADDR_OWVAR 40
53700: PUSH
53701: LD_VAR 0 4
53705: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53706: LD_ADDR_OWVAR 41
53710: PUSH
53711: LD_VAR 0 5
53715: ST_TO_ADDR
// end ;
53716: LD_VAR 0 6
53720: RET
// export function WantPlant ( unit ) ; var task ; begin
53721: LD_INT 0
53723: PPUSH
53724: PPUSH
// result := false ;
53725: LD_ADDR_VAR 0 2
53729: PUSH
53730: LD_INT 0
53732: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53733: LD_ADDR_VAR 0 3
53737: PUSH
53738: LD_VAR 0 1
53742: PPUSH
53743: CALL_OW 437
53747: ST_TO_ADDR
// if task then
53748: LD_VAR 0 3
53752: IFFALSE 53780
// if task [ 1 ] [ 1 ] = p then
53754: LD_VAR 0 3
53758: PUSH
53759: LD_INT 1
53761: ARRAY
53762: PUSH
53763: LD_INT 1
53765: ARRAY
53766: PUSH
53767: LD_STRING p
53769: EQUAL
53770: IFFALSE 53780
// result := true ;
53772: LD_ADDR_VAR 0 2
53776: PUSH
53777: LD_INT 1
53779: ST_TO_ADDR
// end ;
53780: LD_VAR 0 2
53784: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53785: LD_INT 0
53787: PPUSH
53788: PPUSH
53789: PPUSH
53790: PPUSH
// if pos < 1 then
53791: LD_VAR 0 2
53795: PUSH
53796: LD_INT 1
53798: LESS
53799: IFFALSE 53803
// exit ;
53801: GO 54106
// if pos = 1 then
53803: LD_VAR 0 2
53807: PUSH
53808: LD_INT 1
53810: EQUAL
53811: IFFALSE 53844
// result := Replace ( arr , pos [ 1 ] , value ) else
53813: LD_ADDR_VAR 0 4
53817: PUSH
53818: LD_VAR 0 1
53822: PPUSH
53823: LD_VAR 0 2
53827: PUSH
53828: LD_INT 1
53830: ARRAY
53831: PPUSH
53832: LD_VAR 0 3
53836: PPUSH
53837: CALL_OW 1
53841: ST_TO_ADDR
53842: GO 54106
// begin tmp := arr ;
53844: LD_ADDR_VAR 0 6
53848: PUSH
53849: LD_VAR 0 1
53853: ST_TO_ADDR
// s_arr := [ tmp ] ;
53854: LD_ADDR_VAR 0 7
53858: PUSH
53859: LD_VAR 0 6
53863: PUSH
53864: EMPTY
53865: LIST
53866: ST_TO_ADDR
// for i = 1 to pos - 1 do
53867: LD_ADDR_VAR 0 5
53871: PUSH
53872: DOUBLE
53873: LD_INT 1
53875: DEC
53876: ST_TO_ADDR
53877: LD_VAR 0 2
53881: PUSH
53882: LD_INT 1
53884: MINUS
53885: PUSH
53886: FOR_TO
53887: IFFALSE 53932
// begin tmp := tmp [ pos [ i ] ] ;
53889: LD_ADDR_VAR 0 6
53893: PUSH
53894: LD_VAR 0 6
53898: PUSH
53899: LD_VAR 0 2
53903: PUSH
53904: LD_VAR 0 5
53908: ARRAY
53909: ARRAY
53910: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53911: LD_ADDR_VAR 0 7
53915: PUSH
53916: LD_VAR 0 7
53920: PUSH
53921: LD_VAR 0 6
53925: PUSH
53926: EMPTY
53927: LIST
53928: ADD
53929: ST_TO_ADDR
// end ;
53930: GO 53886
53932: POP
53933: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53934: LD_ADDR_VAR 0 6
53938: PUSH
53939: LD_VAR 0 6
53943: PPUSH
53944: LD_VAR 0 2
53948: PUSH
53949: LD_VAR 0 2
53953: ARRAY
53954: PPUSH
53955: LD_VAR 0 3
53959: PPUSH
53960: CALL_OW 1
53964: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53965: LD_ADDR_VAR 0 7
53969: PUSH
53970: LD_VAR 0 7
53974: PPUSH
53975: LD_VAR 0 7
53979: PPUSH
53980: LD_VAR 0 6
53984: PPUSH
53985: CALL_OW 1
53989: ST_TO_ADDR
// for i = s_arr downto 2 do
53990: LD_ADDR_VAR 0 5
53994: PUSH
53995: DOUBLE
53996: LD_VAR 0 7
54000: INC
54001: ST_TO_ADDR
54002: LD_INT 2
54004: PUSH
54005: FOR_DOWNTO
54006: IFFALSE 54090
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54008: LD_ADDR_VAR 0 6
54012: PUSH
54013: LD_VAR 0 7
54017: PUSH
54018: LD_VAR 0 5
54022: PUSH
54023: LD_INT 1
54025: MINUS
54026: ARRAY
54027: PPUSH
54028: LD_VAR 0 2
54032: PUSH
54033: LD_VAR 0 5
54037: PUSH
54038: LD_INT 1
54040: MINUS
54041: ARRAY
54042: PPUSH
54043: LD_VAR 0 7
54047: PUSH
54048: LD_VAR 0 5
54052: ARRAY
54053: PPUSH
54054: CALL_OW 1
54058: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54059: LD_ADDR_VAR 0 7
54063: PUSH
54064: LD_VAR 0 7
54068: PPUSH
54069: LD_VAR 0 5
54073: PUSH
54074: LD_INT 1
54076: MINUS
54077: PPUSH
54078: LD_VAR 0 6
54082: PPUSH
54083: CALL_OW 1
54087: ST_TO_ADDR
// end ;
54088: GO 54005
54090: POP
54091: POP
// result := s_arr [ 1 ] ;
54092: LD_ADDR_VAR 0 4
54096: PUSH
54097: LD_VAR 0 7
54101: PUSH
54102: LD_INT 1
54104: ARRAY
54105: ST_TO_ADDR
// end ; end ;
54106: LD_VAR 0 4
54110: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54111: LD_INT 0
54113: PPUSH
54114: PPUSH
// if not list then
54115: LD_VAR 0 1
54119: NOT
54120: IFFALSE 54124
// exit ;
54122: GO 54215
// i := list [ pos1 ] ;
54124: LD_ADDR_VAR 0 5
54128: PUSH
54129: LD_VAR 0 1
54133: PUSH
54134: LD_VAR 0 2
54138: ARRAY
54139: ST_TO_ADDR
// if not i then
54140: LD_VAR 0 5
54144: NOT
54145: IFFALSE 54149
// exit ;
54147: GO 54215
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54149: LD_ADDR_VAR 0 1
54153: PUSH
54154: LD_VAR 0 1
54158: PPUSH
54159: LD_VAR 0 2
54163: PPUSH
54164: LD_VAR 0 1
54168: PUSH
54169: LD_VAR 0 3
54173: ARRAY
54174: PPUSH
54175: CALL_OW 1
54179: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54180: LD_ADDR_VAR 0 1
54184: PUSH
54185: LD_VAR 0 1
54189: PPUSH
54190: LD_VAR 0 3
54194: PPUSH
54195: LD_VAR 0 5
54199: PPUSH
54200: CALL_OW 1
54204: ST_TO_ADDR
// result := list ;
54205: LD_ADDR_VAR 0 4
54209: PUSH
54210: LD_VAR 0 1
54214: ST_TO_ADDR
// end ;
54215: LD_VAR 0 4
54219: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54220: LD_INT 0
54222: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54223: LD_ADDR_VAR 0 5
54227: PUSH
54228: LD_VAR 0 1
54232: PPUSH
54233: CALL_OW 250
54237: PPUSH
54238: LD_VAR 0 1
54242: PPUSH
54243: CALL_OW 251
54247: PPUSH
54248: LD_VAR 0 2
54252: PPUSH
54253: LD_VAR 0 3
54257: PPUSH
54258: LD_VAR 0 4
54262: PPUSH
54263: CALL 54273 0 5
54267: ST_TO_ADDR
// end ;
54268: LD_VAR 0 5
54272: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54273: LD_INT 0
54275: PPUSH
54276: PPUSH
54277: PPUSH
54278: PPUSH
// if not list then
54279: LD_VAR 0 3
54283: NOT
54284: IFFALSE 54288
// exit ;
54286: GO 54676
// result := [ ] ;
54288: LD_ADDR_VAR 0 6
54292: PUSH
54293: EMPTY
54294: ST_TO_ADDR
// for i in list do
54295: LD_ADDR_VAR 0 7
54299: PUSH
54300: LD_VAR 0 3
54304: PUSH
54305: FOR_IN
54306: IFFALSE 54508
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54308: LD_ADDR_VAR 0 9
54312: PUSH
54313: LD_VAR 0 7
54317: PPUSH
54318: LD_VAR 0 1
54322: PPUSH
54323: LD_VAR 0 2
54327: PPUSH
54328: CALL_OW 297
54332: ST_TO_ADDR
// if not result then
54333: LD_VAR 0 6
54337: NOT
54338: IFFALSE 54364
// result := [ [ i , tmp ] ] else
54340: LD_ADDR_VAR 0 6
54344: PUSH
54345: LD_VAR 0 7
54349: PUSH
54350: LD_VAR 0 9
54354: PUSH
54355: EMPTY
54356: LIST
54357: LIST
54358: PUSH
54359: EMPTY
54360: LIST
54361: ST_TO_ADDR
54362: GO 54506
// begin if result [ result ] [ 2 ] < tmp then
54364: LD_VAR 0 6
54368: PUSH
54369: LD_VAR 0 6
54373: ARRAY
54374: PUSH
54375: LD_INT 2
54377: ARRAY
54378: PUSH
54379: LD_VAR 0 9
54383: LESS
54384: IFFALSE 54426
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54386: LD_ADDR_VAR 0 6
54390: PUSH
54391: LD_VAR 0 6
54395: PPUSH
54396: LD_VAR 0 6
54400: PUSH
54401: LD_INT 1
54403: PLUS
54404: PPUSH
54405: LD_VAR 0 7
54409: PUSH
54410: LD_VAR 0 9
54414: PUSH
54415: EMPTY
54416: LIST
54417: LIST
54418: PPUSH
54419: CALL_OW 2
54423: ST_TO_ADDR
54424: GO 54506
// for j = 1 to result do
54426: LD_ADDR_VAR 0 8
54430: PUSH
54431: DOUBLE
54432: LD_INT 1
54434: DEC
54435: ST_TO_ADDR
54436: LD_VAR 0 6
54440: PUSH
54441: FOR_TO
54442: IFFALSE 54504
// begin if tmp < result [ j ] [ 2 ] then
54444: LD_VAR 0 9
54448: PUSH
54449: LD_VAR 0 6
54453: PUSH
54454: LD_VAR 0 8
54458: ARRAY
54459: PUSH
54460: LD_INT 2
54462: ARRAY
54463: LESS
54464: IFFALSE 54502
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54466: LD_ADDR_VAR 0 6
54470: PUSH
54471: LD_VAR 0 6
54475: PPUSH
54476: LD_VAR 0 8
54480: PPUSH
54481: LD_VAR 0 7
54485: PUSH
54486: LD_VAR 0 9
54490: PUSH
54491: EMPTY
54492: LIST
54493: LIST
54494: PPUSH
54495: CALL_OW 2
54499: ST_TO_ADDR
// break ;
54500: GO 54504
// end ; end ;
54502: GO 54441
54504: POP
54505: POP
// end ; end ;
54506: GO 54305
54508: POP
54509: POP
// if result and not asc then
54510: LD_VAR 0 6
54514: PUSH
54515: LD_VAR 0 4
54519: NOT
54520: AND
54521: IFFALSE 54596
// begin tmp := result ;
54523: LD_ADDR_VAR 0 9
54527: PUSH
54528: LD_VAR 0 6
54532: ST_TO_ADDR
// for i = tmp downto 1 do
54533: LD_ADDR_VAR 0 7
54537: PUSH
54538: DOUBLE
54539: LD_VAR 0 9
54543: INC
54544: ST_TO_ADDR
54545: LD_INT 1
54547: PUSH
54548: FOR_DOWNTO
54549: IFFALSE 54594
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54551: LD_ADDR_VAR 0 6
54555: PUSH
54556: LD_VAR 0 6
54560: PPUSH
54561: LD_VAR 0 9
54565: PUSH
54566: LD_VAR 0 7
54570: MINUS
54571: PUSH
54572: LD_INT 1
54574: PLUS
54575: PPUSH
54576: LD_VAR 0 9
54580: PUSH
54581: LD_VAR 0 7
54585: ARRAY
54586: PPUSH
54587: CALL_OW 1
54591: ST_TO_ADDR
54592: GO 54548
54594: POP
54595: POP
// end ; tmp := [ ] ;
54596: LD_ADDR_VAR 0 9
54600: PUSH
54601: EMPTY
54602: ST_TO_ADDR
// if mode then
54603: LD_VAR 0 5
54607: IFFALSE 54676
// begin for i = 1 to result do
54609: LD_ADDR_VAR 0 7
54613: PUSH
54614: DOUBLE
54615: LD_INT 1
54617: DEC
54618: ST_TO_ADDR
54619: LD_VAR 0 6
54623: PUSH
54624: FOR_TO
54625: IFFALSE 54664
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54627: LD_ADDR_VAR 0 9
54631: PUSH
54632: LD_VAR 0 9
54636: PPUSH
54637: LD_VAR 0 7
54641: PPUSH
54642: LD_VAR 0 6
54646: PUSH
54647: LD_VAR 0 7
54651: ARRAY
54652: PUSH
54653: LD_INT 1
54655: ARRAY
54656: PPUSH
54657: CALL_OW 1
54661: ST_TO_ADDR
54662: GO 54624
54664: POP
54665: POP
// result := tmp ;
54666: LD_ADDR_VAR 0 6
54670: PUSH
54671: LD_VAR 0 9
54675: ST_TO_ADDR
// end ; end ;
54676: LD_VAR 0 6
54680: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54681: LD_INT 0
54683: PPUSH
54684: PPUSH
54685: PPUSH
54686: PPUSH
54687: PPUSH
54688: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54689: LD_ADDR_VAR 0 5
54693: PUSH
54694: LD_INT 0
54696: PUSH
54697: LD_INT 0
54699: PUSH
54700: LD_INT 0
54702: PUSH
54703: EMPTY
54704: PUSH
54705: EMPTY
54706: LIST
54707: LIST
54708: LIST
54709: LIST
54710: ST_TO_ADDR
// if not x or not y then
54711: LD_VAR 0 2
54715: NOT
54716: PUSH
54717: LD_VAR 0 3
54721: NOT
54722: OR
54723: IFFALSE 54727
// exit ;
54725: GO 56377
// if not range then
54727: LD_VAR 0 4
54731: NOT
54732: IFFALSE 54742
// range := 10 ;
54734: LD_ADDR_VAR 0 4
54738: PUSH
54739: LD_INT 10
54741: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54742: LD_ADDR_VAR 0 8
54746: PUSH
54747: LD_INT 81
54749: PUSH
54750: LD_VAR 0 1
54754: PUSH
54755: EMPTY
54756: LIST
54757: LIST
54758: PUSH
54759: LD_INT 92
54761: PUSH
54762: LD_VAR 0 2
54766: PUSH
54767: LD_VAR 0 3
54771: PUSH
54772: LD_VAR 0 4
54776: PUSH
54777: EMPTY
54778: LIST
54779: LIST
54780: LIST
54781: LIST
54782: PUSH
54783: LD_INT 3
54785: PUSH
54786: LD_INT 21
54788: PUSH
54789: LD_INT 3
54791: PUSH
54792: EMPTY
54793: LIST
54794: LIST
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: PUSH
54800: EMPTY
54801: LIST
54802: LIST
54803: LIST
54804: PPUSH
54805: CALL_OW 69
54809: ST_TO_ADDR
// if not tmp then
54810: LD_VAR 0 8
54814: NOT
54815: IFFALSE 54819
// exit ;
54817: GO 56377
// for i in tmp do
54819: LD_ADDR_VAR 0 6
54823: PUSH
54824: LD_VAR 0 8
54828: PUSH
54829: FOR_IN
54830: IFFALSE 56352
// begin points := [ 0 , 0 , 0 ] ;
54832: LD_ADDR_VAR 0 9
54836: PUSH
54837: LD_INT 0
54839: PUSH
54840: LD_INT 0
54842: PUSH
54843: LD_INT 0
54845: PUSH
54846: EMPTY
54847: LIST
54848: LIST
54849: LIST
54850: ST_TO_ADDR
// bpoints := 1 ;
54851: LD_ADDR_VAR 0 10
54855: PUSH
54856: LD_INT 1
54858: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54859: LD_VAR 0 6
54863: PPUSH
54864: CALL_OW 247
54868: PUSH
54869: LD_INT 1
54871: DOUBLE
54872: EQUAL
54873: IFTRUE 54877
54875: GO 55455
54877: POP
// begin if GetClass ( i ) = 1 then
54878: LD_VAR 0 6
54882: PPUSH
54883: CALL_OW 257
54887: PUSH
54888: LD_INT 1
54890: EQUAL
54891: IFFALSE 54912
// points := [ 10 , 5 , 3 ] ;
54893: LD_ADDR_VAR 0 9
54897: PUSH
54898: LD_INT 10
54900: PUSH
54901: LD_INT 5
54903: PUSH
54904: LD_INT 3
54906: PUSH
54907: EMPTY
54908: LIST
54909: LIST
54910: LIST
54911: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54912: LD_VAR 0 6
54916: PPUSH
54917: CALL_OW 257
54921: PUSH
54922: LD_INT 2
54924: PUSH
54925: LD_INT 3
54927: PUSH
54928: LD_INT 4
54930: PUSH
54931: EMPTY
54932: LIST
54933: LIST
54934: LIST
54935: IN
54936: IFFALSE 54957
// points := [ 3 , 2 , 1 ] ;
54938: LD_ADDR_VAR 0 9
54942: PUSH
54943: LD_INT 3
54945: PUSH
54946: LD_INT 2
54948: PUSH
54949: LD_INT 1
54951: PUSH
54952: EMPTY
54953: LIST
54954: LIST
54955: LIST
54956: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54957: LD_VAR 0 6
54961: PPUSH
54962: CALL_OW 257
54966: PUSH
54967: LD_INT 5
54969: EQUAL
54970: IFFALSE 54991
// points := [ 130 , 5 , 2 ] ;
54972: LD_ADDR_VAR 0 9
54976: PUSH
54977: LD_INT 130
54979: PUSH
54980: LD_INT 5
54982: PUSH
54983: LD_INT 2
54985: PUSH
54986: EMPTY
54987: LIST
54988: LIST
54989: LIST
54990: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54991: LD_VAR 0 6
54995: PPUSH
54996: CALL_OW 257
55000: PUSH
55001: LD_INT 8
55003: EQUAL
55004: IFFALSE 55025
// points := [ 35 , 35 , 30 ] ;
55006: LD_ADDR_VAR 0 9
55010: PUSH
55011: LD_INT 35
55013: PUSH
55014: LD_INT 35
55016: PUSH
55017: LD_INT 30
55019: PUSH
55020: EMPTY
55021: LIST
55022: LIST
55023: LIST
55024: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55025: LD_VAR 0 6
55029: PPUSH
55030: CALL_OW 257
55034: PUSH
55035: LD_INT 9
55037: EQUAL
55038: IFFALSE 55059
// points := [ 20 , 55 , 40 ] ;
55040: LD_ADDR_VAR 0 9
55044: PUSH
55045: LD_INT 20
55047: PUSH
55048: LD_INT 55
55050: PUSH
55051: LD_INT 40
55053: PUSH
55054: EMPTY
55055: LIST
55056: LIST
55057: LIST
55058: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55059: LD_VAR 0 6
55063: PPUSH
55064: CALL_OW 257
55068: PUSH
55069: LD_INT 12
55071: PUSH
55072: LD_INT 16
55074: PUSH
55075: EMPTY
55076: LIST
55077: LIST
55078: IN
55079: IFFALSE 55100
// points := [ 5 , 3 , 2 ] ;
55081: LD_ADDR_VAR 0 9
55085: PUSH
55086: LD_INT 5
55088: PUSH
55089: LD_INT 3
55091: PUSH
55092: LD_INT 2
55094: PUSH
55095: EMPTY
55096: LIST
55097: LIST
55098: LIST
55099: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55100: LD_VAR 0 6
55104: PPUSH
55105: CALL_OW 257
55109: PUSH
55110: LD_INT 17
55112: EQUAL
55113: IFFALSE 55134
// points := [ 100 , 50 , 75 ] ;
55115: LD_ADDR_VAR 0 9
55119: PUSH
55120: LD_INT 100
55122: PUSH
55123: LD_INT 50
55125: PUSH
55126: LD_INT 75
55128: PUSH
55129: EMPTY
55130: LIST
55131: LIST
55132: LIST
55133: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55134: LD_VAR 0 6
55138: PPUSH
55139: CALL_OW 257
55143: PUSH
55144: LD_INT 15
55146: EQUAL
55147: IFFALSE 55168
// points := [ 10 , 5 , 3 ] ;
55149: LD_ADDR_VAR 0 9
55153: PUSH
55154: LD_INT 10
55156: PUSH
55157: LD_INT 5
55159: PUSH
55160: LD_INT 3
55162: PUSH
55163: EMPTY
55164: LIST
55165: LIST
55166: LIST
55167: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55168: LD_VAR 0 6
55172: PPUSH
55173: CALL_OW 257
55177: PUSH
55178: LD_INT 14
55180: EQUAL
55181: IFFALSE 55202
// points := [ 10 , 0 , 0 ] ;
55183: LD_ADDR_VAR 0 9
55187: PUSH
55188: LD_INT 10
55190: PUSH
55191: LD_INT 0
55193: PUSH
55194: LD_INT 0
55196: PUSH
55197: EMPTY
55198: LIST
55199: LIST
55200: LIST
55201: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55202: LD_VAR 0 6
55206: PPUSH
55207: CALL_OW 257
55211: PUSH
55212: LD_INT 11
55214: EQUAL
55215: IFFALSE 55236
// points := [ 30 , 10 , 5 ] ;
55217: LD_ADDR_VAR 0 9
55221: PUSH
55222: LD_INT 30
55224: PUSH
55225: LD_INT 10
55227: PUSH
55228: LD_INT 5
55230: PUSH
55231: EMPTY
55232: LIST
55233: LIST
55234: LIST
55235: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55236: LD_VAR 0 1
55240: PPUSH
55241: LD_INT 5
55243: PPUSH
55244: CALL_OW 321
55248: PUSH
55249: LD_INT 2
55251: EQUAL
55252: IFFALSE 55269
// bpoints := bpoints * 1.8 ;
55254: LD_ADDR_VAR 0 10
55258: PUSH
55259: LD_VAR 0 10
55263: PUSH
55264: LD_REAL  1.80000000000000E+0000
55267: MUL
55268: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55269: LD_VAR 0 6
55273: PPUSH
55274: CALL_OW 257
55278: PUSH
55279: LD_INT 1
55281: PUSH
55282: LD_INT 2
55284: PUSH
55285: LD_INT 3
55287: PUSH
55288: LD_INT 4
55290: PUSH
55291: EMPTY
55292: LIST
55293: LIST
55294: LIST
55295: LIST
55296: IN
55297: PUSH
55298: LD_VAR 0 1
55302: PPUSH
55303: LD_INT 51
55305: PPUSH
55306: CALL_OW 321
55310: PUSH
55311: LD_INT 2
55313: EQUAL
55314: AND
55315: IFFALSE 55332
// bpoints := bpoints * 1.2 ;
55317: LD_ADDR_VAR 0 10
55321: PUSH
55322: LD_VAR 0 10
55326: PUSH
55327: LD_REAL  1.20000000000000E+0000
55330: MUL
55331: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55332: LD_VAR 0 6
55336: PPUSH
55337: CALL_OW 257
55341: PUSH
55342: LD_INT 5
55344: PUSH
55345: LD_INT 7
55347: PUSH
55348: LD_INT 9
55350: PUSH
55351: EMPTY
55352: LIST
55353: LIST
55354: LIST
55355: IN
55356: PUSH
55357: LD_VAR 0 1
55361: PPUSH
55362: LD_INT 52
55364: PPUSH
55365: CALL_OW 321
55369: PUSH
55370: LD_INT 2
55372: EQUAL
55373: AND
55374: IFFALSE 55391
// bpoints := bpoints * 1.5 ;
55376: LD_ADDR_VAR 0 10
55380: PUSH
55381: LD_VAR 0 10
55385: PUSH
55386: LD_REAL  1.50000000000000E+0000
55389: MUL
55390: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55391: LD_VAR 0 1
55395: PPUSH
55396: LD_INT 66
55398: PPUSH
55399: CALL_OW 321
55403: PUSH
55404: LD_INT 2
55406: EQUAL
55407: IFFALSE 55424
// bpoints := bpoints * 1.1 ;
55409: LD_ADDR_VAR 0 10
55413: PUSH
55414: LD_VAR 0 10
55418: PUSH
55419: LD_REAL  1.10000000000000E+0000
55422: MUL
55423: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55424: LD_ADDR_VAR 0 10
55428: PUSH
55429: LD_VAR 0 10
55433: PUSH
55434: LD_VAR 0 6
55438: PPUSH
55439: LD_INT 1
55441: PPUSH
55442: CALL_OW 259
55446: PUSH
55447: LD_REAL  1.15000000000000E+0000
55450: MUL
55451: MUL
55452: ST_TO_ADDR
// end ; unit_vehicle :
55453: GO 56281
55455: LD_INT 2
55457: DOUBLE
55458: EQUAL
55459: IFTRUE 55463
55461: GO 56269
55463: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55464: LD_VAR 0 6
55468: PPUSH
55469: CALL_OW 264
55473: PUSH
55474: LD_INT 2
55476: PUSH
55477: LD_INT 42
55479: PUSH
55480: LD_INT 24
55482: PUSH
55483: EMPTY
55484: LIST
55485: LIST
55486: LIST
55487: IN
55488: IFFALSE 55509
// points := [ 25 , 5 , 3 ] ;
55490: LD_ADDR_VAR 0 9
55494: PUSH
55495: LD_INT 25
55497: PUSH
55498: LD_INT 5
55500: PUSH
55501: LD_INT 3
55503: PUSH
55504: EMPTY
55505: LIST
55506: LIST
55507: LIST
55508: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55509: LD_VAR 0 6
55513: PPUSH
55514: CALL_OW 264
55518: PUSH
55519: LD_INT 4
55521: PUSH
55522: LD_INT 43
55524: PUSH
55525: LD_INT 25
55527: PUSH
55528: EMPTY
55529: LIST
55530: LIST
55531: LIST
55532: IN
55533: IFFALSE 55554
// points := [ 40 , 15 , 5 ] ;
55535: LD_ADDR_VAR 0 9
55539: PUSH
55540: LD_INT 40
55542: PUSH
55543: LD_INT 15
55545: PUSH
55546: LD_INT 5
55548: PUSH
55549: EMPTY
55550: LIST
55551: LIST
55552: LIST
55553: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55554: LD_VAR 0 6
55558: PPUSH
55559: CALL_OW 264
55563: PUSH
55564: LD_INT 3
55566: PUSH
55567: LD_INT 23
55569: PUSH
55570: EMPTY
55571: LIST
55572: LIST
55573: IN
55574: IFFALSE 55595
// points := [ 7 , 25 , 8 ] ;
55576: LD_ADDR_VAR 0 9
55580: PUSH
55581: LD_INT 7
55583: PUSH
55584: LD_INT 25
55586: PUSH
55587: LD_INT 8
55589: PUSH
55590: EMPTY
55591: LIST
55592: LIST
55593: LIST
55594: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55595: LD_VAR 0 6
55599: PPUSH
55600: CALL_OW 264
55604: PUSH
55605: LD_INT 5
55607: PUSH
55608: LD_INT 27
55610: PUSH
55611: LD_INT 44
55613: PUSH
55614: EMPTY
55615: LIST
55616: LIST
55617: LIST
55618: IN
55619: IFFALSE 55640
// points := [ 14 , 50 , 16 ] ;
55621: LD_ADDR_VAR 0 9
55625: PUSH
55626: LD_INT 14
55628: PUSH
55629: LD_INT 50
55631: PUSH
55632: LD_INT 16
55634: PUSH
55635: EMPTY
55636: LIST
55637: LIST
55638: LIST
55639: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55640: LD_VAR 0 6
55644: PPUSH
55645: CALL_OW 264
55649: PUSH
55650: LD_INT 6
55652: PUSH
55653: LD_INT 46
55655: PUSH
55656: EMPTY
55657: LIST
55658: LIST
55659: IN
55660: IFFALSE 55681
// points := [ 32 , 120 , 70 ] ;
55662: LD_ADDR_VAR 0 9
55666: PUSH
55667: LD_INT 32
55669: PUSH
55670: LD_INT 120
55672: PUSH
55673: LD_INT 70
55675: PUSH
55676: EMPTY
55677: LIST
55678: LIST
55679: LIST
55680: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55681: LD_VAR 0 6
55685: PPUSH
55686: CALL_OW 264
55690: PUSH
55691: LD_INT 7
55693: PUSH
55694: LD_INT 28
55696: PUSH
55697: LD_INT 45
55699: PUSH
55700: LD_INT 92
55702: PUSH
55703: EMPTY
55704: LIST
55705: LIST
55706: LIST
55707: LIST
55708: IN
55709: IFFALSE 55730
// points := [ 35 , 20 , 45 ] ;
55711: LD_ADDR_VAR 0 9
55715: PUSH
55716: LD_INT 35
55718: PUSH
55719: LD_INT 20
55721: PUSH
55722: LD_INT 45
55724: PUSH
55725: EMPTY
55726: LIST
55727: LIST
55728: LIST
55729: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55730: LD_VAR 0 6
55734: PPUSH
55735: CALL_OW 264
55739: PUSH
55740: LD_INT 47
55742: PUSH
55743: EMPTY
55744: LIST
55745: IN
55746: IFFALSE 55767
// points := [ 67 , 45 , 75 ] ;
55748: LD_ADDR_VAR 0 9
55752: PUSH
55753: LD_INT 67
55755: PUSH
55756: LD_INT 45
55758: PUSH
55759: LD_INT 75
55761: PUSH
55762: EMPTY
55763: LIST
55764: LIST
55765: LIST
55766: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55767: LD_VAR 0 6
55771: PPUSH
55772: CALL_OW 264
55776: PUSH
55777: LD_INT 26
55779: PUSH
55780: EMPTY
55781: LIST
55782: IN
55783: IFFALSE 55804
// points := [ 120 , 30 , 80 ] ;
55785: LD_ADDR_VAR 0 9
55789: PUSH
55790: LD_INT 120
55792: PUSH
55793: LD_INT 30
55795: PUSH
55796: LD_INT 80
55798: PUSH
55799: EMPTY
55800: LIST
55801: LIST
55802: LIST
55803: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55804: LD_VAR 0 6
55808: PPUSH
55809: CALL_OW 264
55813: PUSH
55814: LD_INT 22
55816: PUSH
55817: EMPTY
55818: LIST
55819: IN
55820: IFFALSE 55841
// points := [ 40 , 1 , 1 ] ;
55822: LD_ADDR_VAR 0 9
55826: PUSH
55827: LD_INT 40
55829: PUSH
55830: LD_INT 1
55832: PUSH
55833: LD_INT 1
55835: PUSH
55836: EMPTY
55837: LIST
55838: LIST
55839: LIST
55840: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55841: LD_VAR 0 6
55845: PPUSH
55846: CALL_OW 264
55850: PUSH
55851: LD_INT 29
55853: PUSH
55854: EMPTY
55855: LIST
55856: IN
55857: IFFALSE 55878
// points := [ 70 , 200 , 400 ] ;
55859: LD_ADDR_VAR 0 9
55863: PUSH
55864: LD_INT 70
55866: PUSH
55867: LD_INT 200
55869: PUSH
55870: LD_INT 400
55872: PUSH
55873: EMPTY
55874: LIST
55875: LIST
55876: LIST
55877: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55878: LD_VAR 0 6
55882: PPUSH
55883: CALL_OW 264
55887: PUSH
55888: LD_INT 14
55890: PUSH
55891: LD_INT 53
55893: PUSH
55894: EMPTY
55895: LIST
55896: LIST
55897: IN
55898: IFFALSE 55919
// points := [ 40 , 10 , 20 ] ;
55900: LD_ADDR_VAR 0 9
55904: PUSH
55905: LD_INT 40
55907: PUSH
55908: LD_INT 10
55910: PUSH
55911: LD_INT 20
55913: PUSH
55914: EMPTY
55915: LIST
55916: LIST
55917: LIST
55918: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55919: LD_VAR 0 6
55923: PPUSH
55924: CALL_OW 264
55928: PUSH
55929: LD_INT 9
55931: PUSH
55932: EMPTY
55933: LIST
55934: IN
55935: IFFALSE 55956
// points := [ 5 , 70 , 20 ] ;
55937: LD_ADDR_VAR 0 9
55941: PUSH
55942: LD_INT 5
55944: PUSH
55945: LD_INT 70
55947: PUSH
55948: LD_INT 20
55950: PUSH
55951: EMPTY
55952: LIST
55953: LIST
55954: LIST
55955: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55956: LD_VAR 0 6
55960: PPUSH
55961: CALL_OW 264
55965: PUSH
55966: LD_INT 10
55968: PUSH
55969: EMPTY
55970: LIST
55971: IN
55972: IFFALSE 55993
// points := [ 35 , 110 , 70 ] ;
55974: LD_ADDR_VAR 0 9
55978: PUSH
55979: LD_INT 35
55981: PUSH
55982: LD_INT 110
55984: PUSH
55985: LD_INT 70
55987: PUSH
55988: EMPTY
55989: LIST
55990: LIST
55991: LIST
55992: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55993: LD_VAR 0 6
55997: PPUSH
55998: CALL_OW 265
56002: PUSH
56003: LD_INT 25
56005: EQUAL
56006: IFFALSE 56027
// points := [ 80 , 65 , 100 ] ;
56008: LD_ADDR_VAR 0 9
56012: PUSH
56013: LD_INT 80
56015: PUSH
56016: LD_INT 65
56018: PUSH
56019: LD_INT 100
56021: PUSH
56022: EMPTY
56023: LIST
56024: LIST
56025: LIST
56026: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56027: LD_VAR 0 6
56031: PPUSH
56032: CALL_OW 263
56036: PUSH
56037: LD_INT 1
56039: EQUAL
56040: IFFALSE 56075
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56042: LD_ADDR_VAR 0 10
56046: PUSH
56047: LD_VAR 0 10
56051: PUSH
56052: LD_VAR 0 6
56056: PPUSH
56057: CALL_OW 311
56061: PPUSH
56062: LD_INT 3
56064: PPUSH
56065: CALL_OW 259
56069: PUSH
56070: LD_INT 4
56072: MUL
56073: MUL
56074: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56075: LD_VAR 0 6
56079: PPUSH
56080: CALL_OW 263
56084: PUSH
56085: LD_INT 2
56087: EQUAL
56088: IFFALSE 56139
// begin j := IsControledBy ( i ) ;
56090: LD_ADDR_VAR 0 7
56094: PUSH
56095: LD_VAR 0 6
56099: PPUSH
56100: CALL_OW 312
56104: ST_TO_ADDR
// if j then
56105: LD_VAR 0 7
56109: IFFALSE 56139
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56111: LD_ADDR_VAR 0 10
56115: PUSH
56116: LD_VAR 0 10
56120: PUSH
56121: LD_VAR 0 7
56125: PPUSH
56126: LD_INT 3
56128: PPUSH
56129: CALL_OW 259
56133: PUSH
56134: LD_INT 3
56136: MUL
56137: MUL
56138: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56139: LD_VAR 0 6
56143: PPUSH
56144: CALL_OW 264
56148: PUSH
56149: LD_INT 5
56151: PUSH
56152: LD_INT 6
56154: PUSH
56155: LD_INT 46
56157: PUSH
56158: LD_INT 44
56160: PUSH
56161: LD_INT 47
56163: PUSH
56164: LD_INT 45
56166: PUSH
56167: LD_INT 28
56169: PUSH
56170: LD_INT 7
56172: PUSH
56173: LD_INT 27
56175: PUSH
56176: LD_INT 29
56178: PUSH
56179: EMPTY
56180: LIST
56181: LIST
56182: LIST
56183: LIST
56184: LIST
56185: LIST
56186: LIST
56187: LIST
56188: LIST
56189: LIST
56190: IN
56191: PUSH
56192: LD_VAR 0 1
56196: PPUSH
56197: LD_INT 52
56199: PPUSH
56200: CALL_OW 321
56204: PUSH
56205: LD_INT 2
56207: EQUAL
56208: AND
56209: IFFALSE 56226
// bpoints := bpoints * 1.2 ;
56211: LD_ADDR_VAR 0 10
56215: PUSH
56216: LD_VAR 0 10
56220: PUSH
56221: LD_REAL  1.20000000000000E+0000
56224: MUL
56225: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56226: LD_VAR 0 6
56230: PPUSH
56231: CALL_OW 264
56235: PUSH
56236: LD_INT 6
56238: PUSH
56239: LD_INT 46
56241: PUSH
56242: LD_INT 47
56244: PUSH
56245: EMPTY
56246: LIST
56247: LIST
56248: LIST
56249: IN
56250: IFFALSE 56267
// bpoints := bpoints * 1.2 ;
56252: LD_ADDR_VAR 0 10
56256: PUSH
56257: LD_VAR 0 10
56261: PUSH
56262: LD_REAL  1.20000000000000E+0000
56265: MUL
56266: ST_TO_ADDR
// end ; unit_building :
56267: GO 56281
56269: LD_INT 3
56271: DOUBLE
56272: EQUAL
56273: IFTRUE 56277
56275: GO 56280
56277: POP
// ; end ;
56278: GO 56281
56280: POP
// for j = 1 to 3 do
56281: LD_ADDR_VAR 0 7
56285: PUSH
56286: DOUBLE
56287: LD_INT 1
56289: DEC
56290: ST_TO_ADDR
56291: LD_INT 3
56293: PUSH
56294: FOR_TO
56295: IFFALSE 56348
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56297: LD_ADDR_VAR 0 5
56301: PUSH
56302: LD_VAR 0 5
56306: PPUSH
56307: LD_VAR 0 7
56311: PPUSH
56312: LD_VAR 0 5
56316: PUSH
56317: LD_VAR 0 7
56321: ARRAY
56322: PUSH
56323: LD_VAR 0 9
56327: PUSH
56328: LD_VAR 0 7
56332: ARRAY
56333: PUSH
56334: LD_VAR 0 10
56338: MUL
56339: PLUS
56340: PPUSH
56341: CALL_OW 1
56345: ST_TO_ADDR
56346: GO 56294
56348: POP
56349: POP
// end ;
56350: GO 54829
56352: POP
56353: POP
// result := Replace ( result , 4 , tmp ) ;
56354: LD_ADDR_VAR 0 5
56358: PUSH
56359: LD_VAR 0 5
56363: PPUSH
56364: LD_INT 4
56366: PPUSH
56367: LD_VAR 0 8
56371: PPUSH
56372: CALL_OW 1
56376: ST_TO_ADDR
// end ;
56377: LD_VAR 0 5
56381: RET
// export function DangerAtRange ( unit , range ) ; begin
56382: LD_INT 0
56384: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56385: LD_ADDR_VAR 0 3
56389: PUSH
56390: LD_VAR 0 1
56394: PPUSH
56395: CALL_OW 255
56399: PPUSH
56400: LD_VAR 0 1
56404: PPUSH
56405: CALL_OW 250
56409: PPUSH
56410: LD_VAR 0 1
56414: PPUSH
56415: CALL_OW 251
56419: PPUSH
56420: LD_VAR 0 2
56424: PPUSH
56425: CALL 54681 0 4
56429: ST_TO_ADDR
// end ;
56430: LD_VAR 0 3
56434: RET
// export function DangerInArea ( side , area ) ; begin
56435: LD_INT 0
56437: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56438: LD_ADDR_VAR 0 3
56442: PUSH
56443: LD_VAR 0 2
56447: PPUSH
56448: LD_INT 81
56450: PUSH
56451: LD_VAR 0 1
56455: PUSH
56456: EMPTY
56457: LIST
56458: LIST
56459: PPUSH
56460: CALL_OW 70
56464: ST_TO_ADDR
// end ;
56465: LD_VAR 0 3
56469: RET
// export function IsExtension ( b ) ; begin
56470: LD_INT 0
56472: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56473: LD_ADDR_VAR 0 2
56477: PUSH
56478: LD_VAR 0 1
56482: PUSH
56483: LD_INT 23
56485: PUSH
56486: LD_INT 20
56488: PUSH
56489: LD_INT 22
56491: PUSH
56492: LD_INT 17
56494: PUSH
56495: LD_INT 24
56497: PUSH
56498: LD_INT 21
56500: PUSH
56501: LD_INT 19
56503: PUSH
56504: LD_INT 16
56506: PUSH
56507: LD_INT 25
56509: PUSH
56510: LD_INT 18
56512: PUSH
56513: EMPTY
56514: LIST
56515: LIST
56516: LIST
56517: LIST
56518: LIST
56519: LIST
56520: LIST
56521: LIST
56522: LIST
56523: LIST
56524: IN
56525: ST_TO_ADDR
// end ;
56526: LD_VAR 0 2
56530: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56531: LD_INT 0
56533: PPUSH
56534: PPUSH
56535: PPUSH
// result := [ ] ;
56536: LD_ADDR_VAR 0 4
56540: PUSH
56541: EMPTY
56542: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56543: LD_ADDR_VAR 0 5
56547: PUSH
56548: LD_VAR 0 2
56552: PPUSH
56553: LD_INT 21
56555: PUSH
56556: LD_INT 3
56558: PUSH
56559: EMPTY
56560: LIST
56561: LIST
56562: PPUSH
56563: CALL_OW 70
56567: ST_TO_ADDR
// if not tmp then
56568: LD_VAR 0 5
56572: NOT
56573: IFFALSE 56577
// exit ;
56575: GO 56641
// if checkLink then
56577: LD_VAR 0 3
56581: IFFALSE 56631
// begin for i in tmp do
56583: LD_ADDR_VAR 0 6
56587: PUSH
56588: LD_VAR 0 5
56592: PUSH
56593: FOR_IN
56594: IFFALSE 56629
// if GetBase ( i ) <> base then
56596: LD_VAR 0 6
56600: PPUSH
56601: CALL_OW 274
56605: PUSH
56606: LD_VAR 0 1
56610: NONEQUAL
56611: IFFALSE 56627
// ComLinkToBase ( base , i ) ;
56613: LD_VAR 0 1
56617: PPUSH
56618: LD_VAR 0 6
56622: PPUSH
56623: CALL_OW 169
56627: GO 56593
56629: POP
56630: POP
// end ; result := tmp ;
56631: LD_ADDR_VAR 0 4
56635: PUSH
56636: LD_VAR 0 5
56640: ST_TO_ADDR
// end ;
56641: LD_VAR 0 4
56645: RET
// export function ComComplete ( units , b ) ; var i ; begin
56646: LD_INT 0
56648: PPUSH
56649: PPUSH
// if not units then
56650: LD_VAR 0 1
56654: NOT
56655: IFFALSE 56659
// exit ;
56657: GO 56749
// for i in units do
56659: LD_ADDR_VAR 0 4
56663: PUSH
56664: LD_VAR 0 1
56668: PUSH
56669: FOR_IN
56670: IFFALSE 56747
// if BuildingStatus ( b ) = bs_build then
56672: LD_VAR 0 2
56676: PPUSH
56677: CALL_OW 461
56681: PUSH
56682: LD_INT 1
56684: EQUAL
56685: IFFALSE 56745
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56687: LD_VAR 0 4
56691: PPUSH
56692: LD_STRING h
56694: PUSH
56695: LD_VAR 0 2
56699: PPUSH
56700: CALL_OW 250
56704: PUSH
56705: LD_VAR 0 2
56709: PPUSH
56710: CALL_OW 251
56714: PUSH
56715: LD_VAR 0 2
56719: PUSH
56720: LD_INT 0
56722: PUSH
56723: LD_INT 0
56725: PUSH
56726: LD_INT 0
56728: PUSH
56729: EMPTY
56730: LIST
56731: LIST
56732: LIST
56733: LIST
56734: LIST
56735: LIST
56736: LIST
56737: PUSH
56738: EMPTY
56739: LIST
56740: PPUSH
56741: CALL_OW 446
56745: GO 56669
56747: POP
56748: POP
// end ;
56749: LD_VAR 0 3
56753: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56754: LD_INT 0
56756: PPUSH
56757: PPUSH
56758: PPUSH
56759: PPUSH
56760: PPUSH
56761: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
56762: LD_VAR 0 1
56766: NOT
56767: PUSH
56768: LD_VAR 0 1
56772: PPUSH
56773: CALL_OW 263
56777: PUSH
56778: LD_INT 2
56780: NONEQUAL
56781: OR
56782: IFFALSE 56786
// exit ;
56784: GO 57102
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56786: LD_ADDR_VAR 0 6
56790: PUSH
56791: LD_INT 22
56793: PUSH
56794: LD_VAR 0 1
56798: PPUSH
56799: CALL_OW 255
56803: PUSH
56804: EMPTY
56805: LIST
56806: LIST
56807: PUSH
56808: LD_INT 2
56810: PUSH
56811: LD_INT 30
56813: PUSH
56814: LD_INT 36
56816: PUSH
56817: EMPTY
56818: LIST
56819: LIST
56820: PUSH
56821: LD_INT 34
56823: PUSH
56824: LD_INT 31
56826: PUSH
56827: EMPTY
56828: LIST
56829: LIST
56830: PUSH
56831: EMPTY
56832: LIST
56833: LIST
56834: LIST
56835: PUSH
56836: EMPTY
56837: LIST
56838: LIST
56839: PPUSH
56840: CALL_OW 69
56844: ST_TO_ADDR
// if not tmp then
56845: LD_VAR 0 6
56849: NOT
56850: IFFALSE 56854
// exit ;
56852: GO 57102
// result := [ ] ;
56854: LD_ADDR_VAR 0 2
56858: PUSH
56859: EMPTY
56860: ST_TO_ADDR
// for i in tmp do
56861: LD_ADDR_VAR 0 3
56865: PUSH
56866: LD_VAR 0 6
56870: PUSH
56871: FOR_IN
56872: IFFALSE 56943
// begin t := UnitsInside ( i ) ;
56874: LD_ADDR_VAR 0 4
56878: PUSH
56879: LD_VAR 0 3
56883: PPUSH
56884: CALL_OW 313
56888: ST_TO_ADDR
// if t then
56889: LD_VAR 0 4
56893: IFFALSE 56941
// for j in t do
56895: LD_ADDR_VAR 0 7
56899: PUSH
56900: LD_VAR 0 4
56904: PUSH
56905: FOR_IN
56906: IFFALSE 56939
// result := Replace ( result , result + 1 , j ) ;
56908: LD_ADDR_VAR 0 2
56912: PUSH
56913: LD_VAR 0 2
56917: PPUSH
56918: LD_VAR 0 2
56922: PUSH
56923: LD_INT 1
56925: PLUS
56926: PPUSH
56927: LD_VAR 0 7
56931: PPUSH
56932: CALL_OW 1
56936: ST_TO_ADDR
56937: GO 56905
56939: POP
56940: POP
// end ;
56941: GO 56871
56943: POP
56944: POP
// if not result then
56945: LD_VAR 0 2
56949: NOT
56950: IFFALSE 56954
// exit ;
56952: GO 57102
// mech := result [ 1 ] ;
56954: LD_ADDR_VAR 0 5
56958: PUSH
56959: LD_VAR 0 2
56963: PUSH
56964: LD_INT 1
56966: ARRAY
56967: ST_TO_ADDR
// if result > 1 then
56968: LD_VAR 0 2
56972: PUSH
56973: LD_INT 1
56975: GREATER
56976: IFFALSE 57088
// begin for i = 2 to result do
56978: LD_ADDR_VAR 0 3
56982: PUSH
56983: DOUBLE
56984: LD_INT 2
56986: DEC
56987: ST_TO_ADDR
56988: LD_VAR 0 2
56992: PUSH
56993: FOR_TO
56994: IFFALSE 57086
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56996: LD_ADDR_VAR 0 4
57000: PUSH
57001: LD_VAR 0 2
57005: PUSH
57006: LD_VAR 0 3
57010: ARRAY
57011: PPUSH
57012: LD_INT 3
57014: PPUSH
57015: CALL_OW 259
57019: PUSH
57020: LD_VAR 0 2
57024: PUSH
57025: LD_VAR 0 3
57029: ARRAY
57030: PPUSH
57031: CALL_OW 432
57035: MINUS
57036: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57037: LD_VAR 0 4
57041: PUSH
57042: LD_VAR 0 5
57046: PPUSH
57047: LD_INT 3
57049: PPUSH
57050: CALL_OW 259
57054: PUSH
57055: LD_VAR 0 5
57059: PPUSH
57060: CALL_OW 432
57064: MINUS
57065: GREATEREQUAL
57066: IFFALSE 57084
// mech := result [ i ] ;
57068: LD_ADDR_VAR 0 5
57072: PUSH
57073: LD_VAR 0 2
57077: PUSH
57078: LD_VAR 0 3
57082: ARRAY
57083: ST_TO_ADDR
// end ;
57084: GO 56993
57086: POP
57087: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57088: LD_VAR 0 1
57092: PPUSH
57093: LD_VAR 0 5
57097: PPUSH
57098: CALL_OW 135
// end ;
57102: LD_VAR 0 2
57106: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57107: LD_INT 0
57109: PPUSH
57110: PPUSH
57111: PPUSH
57112: PPUSH
57113: PPUSH
57114: PPUSH
57115: PPUSH
57116: PPUSH
57117: PPUSH
57118: PPUSH
57119: PPUSH
57120: PPUSH
57121: PPUSH
// result := [ ] ;
57122: LD_ADDR_VAR 0 7
57126: PUSH
57127: EMPTY
57128: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57129: LD_VAR 0 1
57133: PPUSH
57134: CALL_OW 266
57138: PUSH
57139: LD_INT 0
57141: PUSH
57142: LD_INT 1
57144: PUSH
57145: EMPTY
57146: LIST
57147: LIST
57148: IN
57149: NOT
57150: IFFALSE 57154
// exit ;
57152: GO 58788
// if name then
57154: LD_VAR 0 3
57158: IFFALSE 57174
// SetBName ( base_dep , name ) ;
57160: LD_VAR 0 1
57164: PPUSH
57165: LD_VAR 0 3
57169: PPUSH
57170: CALL_OW 500
// base := GetBase ( base_dep ) ;
57174: LD_ADDR_VAR 0 15
57178: PUSH
57179: LD_VAR 0 1
57183: PPUSH
57184: CALL_OW 274
57188: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57189: LD_ADDR_VAR 0 16
57193: PUSH
57194: LD_VAR 0 1
57198: PPUSH
57199: CALL_OW 255
57203: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57204: LD_ADDR_VAR 0 17
57208: PUSH
57209: LD_VAR 0 1
57213: PPUSH
57214: CALL_OW 248
57218: ST_TO_ADDR
// if sources then
57219: LD_VAR 0 5
57223: IFFALSE 57270
// for i = 1 to 3 do
57225: LD_ADDR_VAR 0 8
57229: PUSH
57230: DOUBLE
57231: LD_INT 1
57233: DEC
57234: ST_TO_ADDR
57235: LD_INT 3
57237: PUSH
57238: FOR_TO
57239: IFFALSE 57268
// AddResourceType ( base , i , sources [ i ] ) ;
57241: LD_VAR 0 15
57245: PPUSH
57246: LD_VAR 0 8
57250: PPUSH
57251: LD_VAR 0 5
57255: PUSH
57256: LD_VAR 0 8
57260: ARRAY
57261: PPUSH
57262: CALL_OW 276
57266: GO 57238
57268: POP
57269: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57270: LD_ADDR_VAR 0 18
57274: PUSH
57275: LD_VAR 0 15
57279: PPUSH
57280: LD_VAR 0 2
57284: PPUSH
57285: LD_INT 1
57287: PPUSH
57288: CALL 56531 0 3
57292: ST_TO_ADDR
// InitHc ;
57293: CALL_OW 19
// InitUc ;
57297: CALL_OW 18
// uc_side := side ;
57301: LD_ADDR_OWVAR 20
57305: PUSH
57306: LD_VAR 0 16
57310: ST_TO_ADDR
// uc_nation := nation ;
57311: LD_ADDR_OWVAR 21
57315: PUSH
57316: LD_VAR 0 17
57320: ST_TO_ADDR
// if buildings then
57321: LD_VAR 0 18
57325: IFFALSE 58647
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57327: LD_ADDR_VAR 0 19
57331: PUSH
57332: LD_VAR 0 18
57336: PPUSH
57337: LD_INT 2
57339: PUSH
57340: LD_INT 30
57342: PUSH
57343: LD_INT 29
57345: PUSH
57346: EMPTY
57347: LIST
57348: LIST
57349: PUSH
57350: LD_INT 30
57352: PUSH
57353: LD_INT 30
57355: PUSH
57356: EMPTY
57357: LIST
57358: LIST
57359: PUSH
57360: EMPTY
57361: LIST
57362: LIST
57363: LIST
57364: PPUSH
57365: CALL_OW 72
57369: ST_TO_ADDR
// if tmp then
57370: LD_VAR 0 19
57374: IFFALSE 57422
// for i in tmp do
57376: LD_ADDR_VAR 0 8
57380: PUSH
57381: LD_VAR 0 19
57385: PUSH
57386: FOR_IN
57387: IFFALSE 57420
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57389: LD_VAR 0 8
57393: PPUSH
57394: CALL_OW 250
57398: PPUSH
57399: LD_VAR 0 8
57403: PPUSH
57404: CALL_OW 251
57408: PPUSH
57409: LD_VAR 0 16
57413: PPUSH
57414: CALL_OW 441
57418: GO 57386
57420: POP
57421: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57422: LD_VAR 0 18
57426: PPUSH
57427: LD_INT 2
57429: PUSH
57430: LD_INT 30
57432: PUSH
57433: LD_INT 32
57435: PUSH
57436: EMPTY
57437: LIST
57438: LIST
57439: PUSH
57440: LD_INT 30
57442: PUSH
57443: LD_INT 33
57445: PUSH
57446: EMPTY
57447: LIST
57448: LIST
57449: PUSH
57450: EMPTY
57451: LIST
57452: LIST
57453: LIST
57454: PPUSH
57455: CALL_OW 72
57459: IFFALSE 57547
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57461: LD_ADDR_VAR 0 8
57465: PUSH
57466: LD_VAR 0 18
57470: PPUSH
57471: LD_INT 2
57473: PUSH
57474: LD_INT 30
57476: PUSH
57477: LD_INT 32
57479: PUSH
57480: EMPTY
57481: LIST
57482: LIST
57483: PUSH
57484: LD_INT 30
57486: PUSH
57487: LD_INT 33
57489: PUSH
57490: EMPTY
57491: LIST
57492: LIST
57493: PUSH
57494: EMPTY
57495: LIST
57496: LIST
57497: LIST
57498: PPUSH
57499: CALL_OW 72
57503: PUSH
57504: FOR_IN
57505: IFFALSE 57545
// begin if not GetBWeapon ( i ) then
57507: LD_VAR 0 8
57511: PPUSH
57512: CALL_OW 269
57516: NOT
57517: IFFALSE 57543
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57519: LD_VAR 0 8
57523: PPUSH
57524: LD_VAR 0 8
57528: PPUSH
57529: LD_VAR 0 2
57533: PPUSH
57534: CALL 58793 0 2
57538: PPUSH
57539: CALL_OW 431
// end ;
57543: GO 57504
57545: POP
57546: POP
// end ; for i = 1 to personel do
57547: LD_ADDR_VAR 0 8
57551: PUSH
57552: DOUBLE
57553: LD_INT 1
57555: DEC
57556: ST_TO_ADDR
57557: LD_VAR 0 6
57561: PUSH
57562: FOR_TO
57563: IFFALSE 58627
// begin if i > 4 then
57565: LD_VAR 0 8
57569: PUSH
57570: LD_INT 4
57572: GREATER
57573: IFFALSE 57577
// break ;
57575: GO 58627
// case i of 1 :
57577: LD_VAR 0 8
57581: PUSH
57582: LD_INT 1
57584: DOUBLE
57585: EQUAL
57586: IFTRUE 57590
57588: GO 57670
57590: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57591: LD_ADDR_VAR 0 12
57595: PUSH
57596: LD_VAR 0 18
57600: PPUSH
57601: LD_INT 22
57603: PUSH
57604: LD_VAR 0 16
57608: PUSH
57609: EMPTY
57610: LIST
57611: LIST
57612: PUSH
57613: LD_INT 58
57615: PUSH
57616: EMPTY
57617: LIST
57618: PUSH
57619: LD_INT 2
57621: PUSH
57622: LD_INT 30
57624: PUSH
57625: LD_INT 32
57627: PUSH
57628: EMPTY
57629: LIST
57630: LIST
57631: PUSH
57632: LD_INT 30
57634: PUSH
57635: LD_INT 4
57637: PUSH
57638: EMPTY
57639: LIST
57640: LIST
57641: PUSH
57642: LD_INT 30
57644: PUSH
57645: LD_INT 5
57647: PUSH
57648: EMPTY
57649: LIST
57650: LIST
57651: PUSH
57652: EMPTY
57653: LIST
57654: LIST
57655: LIST
57656: LIST
57657: PUSH
57658: EMPTY
57659: LIST
57660: LIST
57661: LIST
57662: PPUSH
57663: CALL_OW 72
57667: ST_TO_ADDR
57668: GO 57892
57670: LD_INT 2
57672: DOUBLE
57673: EQUAL
57674: IFTRUE 57678
57676: GO 57740
57678: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57679: LD_ADDR_VAR 0 12
57683: PUSH
57684: LD_VAR 0 18
57688: PPUSH
57689: LD_INT 22
57691: PUSH
57692: LD_VAR 0 16
57696: PUSH
57697: EMPTY
57698: LIST
57699: LIST
57700: PUSH
57701: LD_INT 2
57703: PUSH
57704: LD_INT 30
57706: PUSH
57707: LD_INT 0
57709: PUSH
57710: EMPTY
57711: LIST
57712: LIST
57713: PUSH
57714: LD_INT 30
57716: PUSH
57717: LD_INT 1
57719: PUSH
57720: EMPTY
57721: LIST
57722: LIST
57723: PUSH
57724: EMPTY
57725: LIST
57726: LIST
57727: LIST
57728: PUSH
57729: EMPTY
57730: LIST
57731: LIST
57732: PPUSH
57733: CALL_OW 72
57737: ST_TO_ADDR
57738: GO 57892
57740: LD_INT 3
57742: DOUBLE
57743: EQUAL
57744: IFTRUE 57748
57746: GO 57810
57748: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57749: LD_ADDR_VAR 0 12
57753: PUSH
57754: LD_VAR 0 18
57758: PPUSH
57759: LD_INT 22
57761: PUSH
57762: LD_VAR 0 16
57766: PUSH
57767: EMPTY
57768: LIST
57769: LIST
57770: PUSH
57771: LD_INT 2
57773: PUSH
57774: LD_INT 30
57776: PUSH
57777: LD_INT 2
57779: PUSH
57780: EMPTY
57781: LIST
57782: LIST
57783: PUSH
57784: LD_INT 30
57786: PUSH
57787: LD_INT 3
57789: PUSH
57790: EMPTY
57791: LIST
57792: LIST
57793: PUSH
57794: EMPTY
57795: LIST
57796: LIST
57797: LIST
57798: PUSH
57799: EMPTY
57800: LIST
57801: LIST
57802: PPUSH
57803: CALL_OW 72
57807: ST_TO_ADDR
57808: GO 57892
57810: LD_INT 4
57812: DOUBLE
57813: EQUAL
57814: IFTRUE 57818
57816: GO 57891
57818: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57819: LD_ADDR_VAR 0 12
57823: PUSH
57824: LD_VAR 0 18
57828: PPUSH
57829: LD_INT 22
57831: PUSH
57832: LD_VAR 0 16
57836: PUSH
57837: EMPTY
57838: LIST
57839: LIST
57840: PUSH
57841: LD_INT 2
57843: PUSH
57844: LD_INT 30
57846: PUSH
57847: LD_INT 6
57849: PUSH
57850: EMPTY
57851: LIST
57852: LIST
57853: PUSH
57854: LD_INT 30
57856: PUSH
57857: LD_INT 7
57859: PUSH
57860: EMPTY
57861: LIST
57862: LIST
57863: PUSH
57864: LD_INT 30
57866: PUSH
57867: LD_INT 8
57869: PUSH
57870: EMPTY
57871: LIST
57872: LIST
57873: PUSH
57874: EMPTY
57875: LIST
57876: LIST
57877: LIST
57878: LIST
57879: PUSH
57880: EMPTY
57881: LIST
57882: LIST
57883: PPUSH
57884: CALL_OW 72
57888: ST_TO_ADDR
57889: GO 57892
57891: POP
// if i = 1 then
57892: LD_VAR 0 8
57896: PUSH
57897: LD_INT 1
57899: EQUAL
57900: IFFALSE 58011
// begin tmp := [ ] ;
57902: LD_ADDR_VAR 0 19
57906: PUSH
57907: EMPTY
57908: ST_TO_ADDR
// for j in f do
57909: LD_ADDR_VAR 0 9
57913: PUSH
57914: LD_VAR 0 12
57918: PUSH
57919: FOR_IN
57920: IFFALSE 57993
// if GetBType ( j ) = b_bunker then
57922: LD_VAR 0 9
57926: PPUSH
57927: CALL_OW 266
57931: PUSH
57932: LD_INT 32
57934: EQUAL
57935: IFFALSE 57962
// tmp := Insert ( tmp , 1 , j ) else
57937: LD_ADDR_VAR 0 19
57941: PUSH
57942: LD_VAR 0 19
57946: PPUSH
57947: LD_INT 1
57949: PPUSH
57950: LD_VAR 0 9
57954: PPUSH
57955: CALL_OW 2
57959: ST_TO_ADDR
57960: GO 57991
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57962: LD_ADDR_VAR 0 19
57966: PUSH
57967: LD_VAR 0 19
57971: PPUSH
57972: LD_VAR 0 19
57976: PUSH
57977: LD_INT 1
57979: PLUS
57980: PPUSH
57981: LD_VAR 0 9
57985: PPUSH
57986: CALL_OW 2
57990: ST_TO_ADDR
57991: GO 57919
57993: POP
57994: POP
// if tmp then
57995: LD_VAR 0 19
57999: IFFALSE 58011
// f := tmp ;
58001: LD_ADDR_VAR 0 12
58005: PUSH
58006: LD_VAR 0 19
58010: ST_TO_ADDR
// end ; x := personel [ i ] ;
58011: LD_ADDR_VAR 0 13
58015: PUSH
58016: LD_VAR 0 6
58020: PUSH
58021: LD_VAR 0 8
58025: ARRAY
58026: ST_TO_ADDR
// if x = - 1 then
58027: LD_VAR 0 13
58031: PUSH
58032: LD_INT 1
58034: NEG
58035: EQUAL
58036: IFFALSE 58245
// begin for j in f do
58038: LD_ADDR_VAR 0 9
58042: PUSH
58043: LD_VAR 0 12
58047: PUSH
58048: FOR_IN
58049: IFFALSE 58241
// repeat InitHc ;
58051: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58055: LD_VAR 0 9
58059: PPUSH
58060: CALL_OW 266
58064: PUSH
58065: LD_INT 5
58067: EQUAL
58068: IFFALSE 58138
// begin if UnitsInside ( j ) < 3 then
58070: LD_VAR 0 9
58074: PPUSH
58075: CALL_OW 313
58079: PUSH
58080: LD_INT 3
58082: LESS
58083: IFFALSE 58119
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58085: LD_INT 0
58087: PPUSH
58088: LD_INT 5
58090: PUSH
58091: LD_INT 8
58093: PUSH
58094: LD_INT 9
58096: PUSH
58097: EMPTY
58098: LIST
58099: LIST
58100: LIST
58101: PUSH
58102: LD_VAR 0 17
58106: ARRAY
58107: PPUSH
58108: LD_VAR 0 4
58112: PPUSH
58113: CALL_OW 380
58117: GO 58136
// PrepareHuman ( false , i , skill ) ;
58119: LD_INT 0
58121: PPUSH
58122: LD_VAR 0 8
58126: PPUSH
58127: LD_VAR 0 4
58131: PPUSH
58132: CALL_OW 380
// end else
58136: GO 58155
// PrepareHuman ( false , i , skill ) ;
58138: LD_INT 0
58140: PPUSH
58141: LD_VAR 0 8
58145: PPUSH
58146: LD_VAR 0 4
58150: PPUSH
58151: CALL_OW 380
// un := CreateHuman ;
58155: LD_ADDR_VAR 0 14
58159: PUSH
58160: CALL_OW 44
58164: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58165: LD_ADDR_VAR 0 7
58169: PUSH
58170: LD_VAR 0 7
58174: PPUSH
58175: LD_INT 1
58177: PPUSH
58178: LD_VAR 0 14
58182: PPUSH
58183: CALL_OW 2
58187: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58188: LD_VAR 0 14
58192: PPUSH
58193: LD_VAR 0 9
58197: PPUSH
58198: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58202: LD_VAR 0 9
58206: PPUSH
58207: CALL_OW 313
58211: PUSH
58212: LD_INT 6
58214: EQUAL
58215: PUSH
58216: LD_VAR 0 9
58220: PPUSH
58221: CALL_OW 266
58225: PUSH
58226: LD_INT 32
58228: PUSH
58229: LD_INT 31
58231: PUSH
58232: EMPTY
58233: LIST
58234: LIST
58235: IN
58236: OR
58237: IFFALSE 58051
58239: GO 58048
58241: POP
58242: POP
// end else
58243: GO 58625
// for j = 1 to x do
58245: LD_ADDR_VAR 0 9
58249: PUSH
58250: DOUBLE
58251: LD_INT 1
58253: DEC
58254: ST_TO_ADDR
58255: LD_VAR 0 13
58259: PUSH
58260: FOR_TO
58261: IFFALSE 58623
// begin InitHc ;
58263: CALL_OW 19
// if not f then
58267: LD_VAR 0 12
58271: NOT
58272: IFFALSE 58361
// begin PrepareHuman ( false , i , skill ) ;
58274: LD_INT 0
58276: PPUSH
58277: LD_VAR 0 8
58281: PPUSH
58282: LD_VAR 0 4
58286: PPUSH
58287: CALL_OW 380
// un := CreateHuman ;
58291: LD_ADDR_VAR 0 14
58295: PUSH
58296: CALL_OW 44
58300: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58301: LD_ADDR_VAR 0 7
58305: PUSH
58306: LD_VAR 0 7
58310: PPUSH
58311: LD_INT 1
58313: PPUSH
58314: LD_VAR 0 14
58318: PPUSH
58319: CALL_OW 2
58323: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58324: LD_VAR 0 14
58328: PPUSH
58329: LD_VAR 0 1
58333: PPUSH
58334: CALL_OW 250
58338: PPUSH
58339: LD_VAR 0 1
58343: PPUSH
58344: CALL_OW 251
58348: PPUSH
58349: LD_INT 10
58351: PPUSH
58352: LD_INT 0
58354: PPUSH
58355: CALL_OW 50
// continue ;
58359: GO 58260
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58361: LD_VAR 0 12
58365: PUSH
58366: LD_INT 1
58368: ARRAY
58369: PPUSH
58370: CALL_OW 313
58374: PUSH
58375: LD_VAR 0 12
58379: PUSH
58380: LD_INT 1
58382: ARRAY
58383: PPUSH
58384: CALL_OW 266
58388: PUSH
58389: LD_INT 32
58391: PUSH
58392: LD_INT 31
58394: PUSH
58395: EMPTY
58396: LIST
58397: LIST
58398: IN
58399: AND
58400: PUSH
58401: LD_VAR 0 12
58405: PUSH
58406: LD_INT 1
58408: ARRAY
58409: PPUSH
58410: CALL_OW 313
58414: PUSH
58415: LD_INT 6
58417: EQUAL
58418: OR
58419: IFFALSE 58439
// f := Delete ( f , 1 ) ;
58421: LD_ADDR_VAR 0 12
58425: PUSH
58426: LD_VAR 0 12
58430: PPUSH
58431: LD_INT 1
58433: PPUSH
58434: CALL_OW 3
58438: ST_TO_ADDR
// if not f then
58439: LD_VAR 0 12
58443: NOT
58444: IFFALSE 58462
// begin x := x + 2 ;
58446: LD_ADDR_VAR 0 13
58450: PUSH
58451: LD_VAR 0 13
58455: PUSH
58456: LD_INT 2
58458: PLUS
58459: ST_TO_ADDR
// continue ;
58460: GO 58260
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58462: LD_VAR 0 12
58466: PUSH
58467: LD_INT 1
58469: ARRAY
58470: PPUSH
58471: CALL_OW 266
58475: PUSH
58476: LD_INT 5
58478: EQUAL
58479: IFFALSE 58553
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58481: LD_VAR 0 12
58485: PUSH
58486: LD_INT 1
58488: ARRAY
58489: PPUSH
58490: CALL_OW 313
58494: PUSH
58495: LD_INT 3
58497: LESS
58498: IFFALSE 58534
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58500: LD_INT 0
58502: PPUSH
58503: LD_INT 5
58505: PUSH
58506: LD_INT 8
58508: PUSH
58509: LD_INT 9
58511: PUSH
58512: EMPTY
58513: LIST
58514: LIST
58515: LIST
58516: PUSH
58517: LD_VAR 0 17
58521: ARRAY
58522: PPUSH
58523: LD_VAR 0 4
58527: PPUSH
58528: CALL_OW 380
58532: GO 58551
// PrepareHuman ( false , i , skill ) ;
58534: LD_INT 0
58536: PPUSH
58537: LD_VAR 0 8
58541: PPUSH
58542: LD_VAR 0 4
58546: PPUSH
58547: CALL_OW 380
// end else
58551: GO 58570
// PrepareHuman ( false , i , skill ) ;
58553: LD_INT 0
58555: PPUSH
58556: LD_VAR 0 8
58560: PPUSH
58561: LD_VAR 0 4
58565: PPUSH
58566: CALL_OW 380
// un := CreateHuman ;
58570: LD_ADDR_VAR 0 14
58574: PUSH
58575: CALL_OW 44
58579: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58580: LD_ADDR_VAR 0 7
58584: PUSH
58585: LD_VAR 0 7
58589: PPUSH
58590: LD_INT 1
58592: PPUSH
58593: LD_VAR 0 14
58597: PPUSH
58598: CALL_OW 2
58602: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58603: LD_VAR 0 14
58607: PPUSH
58608: LD_VAR 0 12
58612: PUSH
58613: LD_INT 1
58615: ARRAY
58616: PPUSH
58617: CALL_OW 52
// end ;
58621: GO 58260
58623: POP
58624: POP
// end ;
58625: GO 57562
58627: POP
58628: POP
// result := result ^ buildings ;
58629: LD_ADDR_VAR 0 7
58633: PUSH
58634: LD_VAR 0 7
58638: PUSH
58639: LD_VAR 0 18
58643: ADD
58644: ST_TO_ADDR
// end else
58645: GO 58788
// begin for i = 1 to personel do
58647: LD_ADDR_VAR 0 8
58651: PUSH
58652: DOUBLE
58653: LD_INT 1
58655: DEC
58656: ST_TO_ADDR
58657: LD_VAR 0 6
58661: PUSH
58662: FOR_TO
58663: IFFALSE 58786
// begin if i > 4 then
58665: LD_VAR 0 8
58669: PUSH
58670: LD_INT 4
58672: GREATER
58673: IFFALSE 58677
// break ;
58675: GO 58786
// x := personel [ i ] ;
58677: LD_ADDR_VAR 0 13
58681: PUSH
58682: LD_VAR 0 6
58686: PUSH
58687: LD_VAR 0 8
58691: ARRAY
58692: ST_TO_ADDR
// if x = - 1 then
58693: LD_VAR 0 13
58697: PUSH
58698: LD_INT 1
58700: NEG
58701: EQUAL
58702: IFFALSE 58706
// continue ;
58704: GO 58662
// PrepareHuman ( false , i , skill ) ;
58706: LD_INT 0
58708: PPUSH
58709: LD_VAR 0 8
58713: PPUSH
58714: LD_VAR 0 4
58718: PPUSH
58719: CALL_OW 380
// un := CreateHuman ;
58723: LD_ADDR_VAR 0 14
58727: PUSH
58728: CALL_OW 44
58732: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58733: LD_VAR 0 14
58737: PPUSH
58738: LD_VAR 0 1
58742: PPUSH
58743: CALL_OW 250
58747: PPUSH
58748: LD_VAR 0 1
58752: PPUSH
58753: CALL_OW 251
58757: PPUSH
58758: LD_INT 10
58760: PPUSH
58761: LD_INT 0
58763: PPUSH
58764: CALL_OW 50
// result := result ^ un ;
58768: LD_ADDR_VAR 0 7
58772: PUSH
58773: LD_VAR 0 7
58777: PUSH
58778: LD_VAR 0 14
58782: ADD
58783: ST_TO_ADDR
// end ;
58784: GO 58662
58786: POP
58787: POP
// end ; end ;
58788: LD_VAR 0 7
58792: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58793: LD_INT 0
58795: PPUSH
58796: PPUSH
58797: PPUSH
58798: PPUSH
58799: PPUSH
58800: PPUSH
58801: PPUSH
58802: PPUSH
58803: PPUSH
58804: PPUSH
58805: PPUSH
58806: PPUSH
58807: PPUSH
58808: PPUSH
58809: PPUSH
58810: PPUSH
// result := false ;
58811: LD_ADDR_VAR 0 3
58815: PUSH
58816: LD_INT 0
58818: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58819: LD_VAR 0 1
58823: NOT
58824: PUSH
58825: LD_VAR 0 1
58829: PPUSH
58830: CALL_OW 266
58834: PUSH
58835: LD_INT 32
58837: PUSH
58838: LD_INT 33
58840: PUSH
58841: EMPTY
58842: LIST
58843: LIST
58844: IN
58845: NOT
58846: OR
58847: IFFALSE 58851
// exit ;
58849: GO 59960
// nat := GetNation ( tower ) ;
58851: LD_ADDR_VAR 0 12
58855: PUSH
58856: LD_VAR 0 1
58860: PPUSH
58861: CALL_OW 248
58865: ST_TO_ADDR
// side := GetSide ( tower ) ;
58866: LD_ADDR_VAR 0 16
58870: PUSH
58871: LD_VAR 0 1
58875: PPUSH
58876: CALL_OW 255
58880: ST_TO_ADDR
// x := GetX ( tower ) ;
58881: LD_ADDR_VAR 0 10
58885: PUSH
58886: LD_VAR 0 1
58890: PPUSH
58891: CALL_OW 250
58895: ST_TO_ADDR
// y := GetY ( tower ) ;
58896: LD_ADDR_VAR 0 11
58900: PUSH
58901: LD_VAR 0 1
58905: PPUSH
58906: CALL_OW 251
58910: ST_TO_ADDR
// if not x or not y then
58911: LD_VAR 0 10
58915: NOT
58916: PUSH
58917: LD_VAR 0 11
58921: NOT
58922: OR
58923: IFFALSE 58927
// exit ;
58925: GO 59960
// weapon := 0 ;
58927: LD_ADDR_VAR 0 18
58931: PUSH
58932: LD_INT 0
58934: ST_TO_ADDR
// fac_list := [ ] ;
58935: LD_ADDR_VAR 0 17
58939: PUSH
58940: EMPTY
58941: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58942: LD_ADDR_VAR 0 6
58946: PUSH
58947: LD_VAR 0 1
58951: PPUSH
58952: CALL_OW 274
58956: PPUSH
58957: LD_VAR 0 2
58961: PPUSH
58962: LD_INT 0
58964: PPUSH
58965: CALL 56531 0 3
58969: PPUSH
58970: LD_INT 30
58972: PUSH
58973: LD_INT 3
58975: PUSH
58976: EMPTY
58977: LIST
58978: LIST
58979: PPUSH
58980: CALL_OW 72
58984: ST_TO_ADDR
// if not factories then
58985: LD_VAR 0 6
58989: NOT
58990: IFFALSE 58994
// exit ;
58992: GO 59960
// for i in factories do
58994: LD_ADDR_VAR 0 8
58998: PUSH
58999: LD_VAR 0 6
59003: PUSH
59004: FOR_IN
59005: IFFALSE 59030
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59007: LD_ADDR_VAR 0 17
59011: PUSH
59012: LD_VAR 0 17
59016: PUSH
59017: LD_VAR 0 8
59021: PPUSH
59022: CALL_OW 478
59026: UNION
59027: ST_TO_ADDR
59028: GO 59004
59030: POP
59031: POP
// if not fac_list then
59032: LD_VAR 0 17
59036: NOT
59037: IFFALSE 59041
// exit ;
59039: GO 59960
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59041: LD_ADDR_VAR 0 5
59045: PUSH
59046: LD_INT 4
59048: PUSH
59049: LD_INT 5
59051: PUSH
59052: LD_INT 9
59054: PUSH
59055: LD_INT 10
59057: PUSH
59058: LD_INT 6
59060: PUSH
59061: LD_INT 7
59063: PUSH
59064: LD_INT 11
59066: PUSH
59067: EMPTY
59068: LIST
59069: LIST
59070: LIST
59071: LIST
59072: LIST
59073: LIST
59074: LIST
59075: PUSH
59076: LD_INT 27
59078: PUSH
59079: LD_INT 28
59081: PUSH
59082: LD_INT 26
59084: PUSH
59085: LD_INT 30
59087: PUSH
59088: EMPTY
59089: LIST
59090: LIST
59091: LIST
59092: LIST
59093: PUSH
59094: LD_INT 43
59096: PUSH
59097: LD_INT 44
59099: PUSH
59100: LD_INT 46
59102: PUSH
59103: LD_INT 45
59105: PUSH
59106: LD_INT 47
59108: PUSH
59109: LD_INT 49
59111: PUSH
59112: EMPTY
59113: LIST
59114: LIST
59115: LIST
59116: LIST
59117: LIST
59118: LIST
59119: PUSH
59120: EMPTY
59121: LIST
59122: LIST
59123: LIST
59124: PUSH
59125: LD_VAR 0 12
59129: ARRAY
59130: ST_TO_ADDR
// list := list isect fac_list ;
59131: LD_ADDR_VAR 0 5
59135: PUSH
59136: LD_VAR 0 5
59140: PUSH
59141: LD_VAR 0 17
59145: ISECT
59146: ST_TO_ADDR
// if not list then
59147: LD_VAR 0 5
59151: NOT
59152: IFFALSE 59156
// exit ;
59154: GO 59960
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59156: LD_VAR 0 12
59160: PUSH
59161: LD_INT 3
59163: EQUAL
59164: PUSH
59165: LD_INT 49
59167: PUSH
59168: LD_VAR 0 5
59172: IN
59173: AND
59174: PUSH
59175: LD_INT 31
59177: PPUSH
59178: LD_VAR 0 16
59182: PPUSH
59183: CALL_OW 321
59187: PUSH
59188: LD_INT 2
59190: EQUAL
59191: AND
59192: IFFALSE 59252
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59194: LD_INT 22
59196: PUSH
59197: LD_VAR 0 16
59201: PUSH
59202: EMPTY
59203: LIST
59204: LIST
59205: PUSH
59206: LD_INT 35
59208: PUSH
59209: LD_INT 49
59211: PUSH
59212: EMPTY
59213: LIST
59214: LIST
59215: PUSH
59216: LD_INT 91
59218: PUSH
59219: LD_VAR 0 1
59223: PUSH
59224: LD_INT 10
59226: PUSH
59227: EMPTY
59228: LIST
59229: LIST
59230: LIST
59231: PUSH
59232: EMPTY
59233: LIST
59234: LIST
59235: LIST
59236: PPUSH
59237: CALL_OW 69
59241: NOT
59242: IFFALSE 59252
// weapon := ru_time_lapser ;
59244: LD_ADDR_VAR 0 18
59248: PUSH
59249: LD_INT 49
59251: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59252: LD_VAR 0 12
59256: PUSH
59257: LD_INT 1
59259: PUSH
59260: LD_INT 2
59262: PUSH
59263: EMPTY
59264: LIST
59265: LIST
59266: IN
59267: PUSH
59268: LD_INT 11
59270: PUSH
59271: LD_VAR 0 5
59275: IN
59276: PUSH
59277: LD_INT 30
59279: PUSH
59280: LD_VAR 0 5
59284: IN
59285: OR
59286: AND
59287: PUSH
59288: LD_INT 6
59290: PPUSH
59291: LD_VAR 0 16
59295: PPUSH
59296: CALL_OW 321
59300: PUSH
59301: LD_INT 2
59303: EQUAL
59304: AND
59305: IFFALSE 59470
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59307: LD_INT 22
59309: PUSH
59310: LD_VAR 0 16
59314: PUSH
59315: EMPTY
59316: LIST
59317: LIST
59318: PUSH
59319: LD_INT 2
59321: PUSH
59322: LD_INT 35
59324: PUSH
59325: LD_INT 11
59327: PUSH
59328: EMPTY
59329: LIST
59330: LIST
59331: PUSH
59332: LD_INT 35
59334: PUSH
59335: LD_INT 30
59337: PUSH
59338: EMPTY
59339: LIST
59340: LIST
59341: PUSH
59342: EMPTY
59343: LIST
59344: LIST
59345: LIST
59346: PUSH
59347: LD_INT 91
59349: PUSH
59350: LD_VAR 0 1
59354: PUSH
59355: LD_INT 18
59357: PUSH
59358: EMPTY
59359: LIST
59360: LIST
59361: LIST
59362: PUSH
59363: EMPTY
59364: LIST
59365: LIST
59366: LIST
59367: PPUSH
59368: CALL_OW 69
59372: NOT
59373: PUSH
59374: LD_INT 22
59376: PUSH
59377: LD_VAR 0 16
59381: PUSH
59382: EMPTY
59383: LIST
59384: LIST
59385: PUSH
59386: LD_INT 2
59388: PUSH
59389: LD_INT 30
59391: PUSH
59392: LD_INT 32
59394: PUSH
59395: EMPTY
59396: LIST
59397: LIST
59398: PUSH
59399: LD_INT 30
59401: PUSH
59402: LD_INT 33
59404: PUSH
59405: EMPTY
59406: LIST
59407: LIST
59408: PUSH
59409: EMPTY
59410: LIST
59411: LIST
59412: LIST
59413: PUSH
59414: LD_INT 91
59416: PUSH
59417: LD_VAR 0 1
59421: PUSH
59422: LD_INT 12
59424: PUSH
59425: EMPTY
59426: LIST
59427: LIST
59428: LIST
59429: PUSH
59430: EMPTY
59431: LIST
59432: LIST
59433: LIST
59434: PUSH
59435: EMPTY
59436: LIST
59437: PPUSH
59438: CALL_OW 69
59442: PUSH
59443: LD_INT 2
59445: GREATER
59446: AND
59447: IFFALSE 59470
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59449: LD_ADDR_VAR 0 18
59453: PUSH
59454: LD_INT 11
59456: PUSH
59457: LD_INT 30
59459: PUSH
59460: EMPTY
59461: LIST
59462: LIST
59463: PUSH
59464: LD_VAR 0 12
59468: ARRAY
59469: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59470: LD_VAR 0 18
59474: NOT
59475: PUSH
59476: LD_INT 40
59478: PPUSH
59479: LD_VAR 0 16
59483: PPUSH
59484: CALL_OW 321
59488: PUSH
59489: LD_INT 2
59491: EQUAL
59492: AND
59493: PUSH
59494: LD_INT 7
59496: PUSH
59497: LD_VAR 0 5
59501: IN
59502: PUSH
59503: LD_INT 28
59505: PUSH
59506: LD_VAR 0 5
59510: IN
59511: OR
59512: PUSH
59513: LD_INT 45
59515: PUSH
59516: LD_VAR 0 5
59520: IN
59521: OR
59522: AND
59523: IFFALSE 59777
// begin hex := GetHexInfo ( x , y ) ;
59525: LD_ADDR_VAR 0 4
59529: PUSH
59530: LD_VAR 0 10
59534: PPUSH
59535: LD_VAR 0 11
59539: PPUSH
59540: CALL_OW 546
59544: ST_TO_ADDR
// if hex [ 1 ] then
59545: LD_VAR 0 4
59549: PUSH
59550: LD_INT 1
59552: ARRAY
59553: IFFALSE 59557
// exit ;
59555: GO 59960
// height := hex [ 2 ] ;
59557: LD_ADDR_VAR 0 15
59561: PUSH
59562: LD_VAR 0 4
59566: PUSH
59567: LD_INT 2
59569: ARRAY
59570: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59571: LD_ADDR_VAR 0 14
59575: PUSH
59576: LD_INT 0
59578: PUSH
59579: LD_INT 2
59581: PUSH
59582: LD_INT 3
59584: PUSH
59585: LD_INT 5
59587: PUSH
59588: EMPTY
59589: LIST
59590: LIST
59591: LIST
59592: LIST
59593: ST_TO_ADDR
// for i in tmp do
59594: LD_ADDR_VAR 0 8
59598: PUSH
59599: LD_VAR 0 14
59603: PUSH
59604: FOR_IN
59605: IFFALSE 59775
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59607: LD_ADDR_VAR 0 9
59611: PUSH
59612: LD_VAR 0 10
59616: PPUSH
59617: LD_VAR 0 8
59621: PPUSH
59622: LD_INT 5
59624: PPUSH
59625: CALL_OW 272
59629: PUSH
59630: LD_VAR 0 11
59634: PPUSH
59635: LD_VAR 0 8
59639: PPUSH
59640: LD_INT 5
59642: PPUSH
59643: CALL_OW 273
59647: PUSH
59648: EMPTY
59649: LIST
59650: LIST
59651: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59652: LD_VAR 0 9
59656: PUSH
59657: LD_INT 1
59659: ARRAY
59660: PPUSH
59661: LD_VAR 0 9
59665: PUSH
59666: LD_INT 2
59668: ARRAY
59669: PPUSH
59670: CALL_OW 488
59674: IFFALSE 59773
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59676: LD_ADDR_VAR 0 4
59680: PUSH
59681: LD_VAR 0 9
59685: PUSH
59686: LD_INT 1
59688: ARRAY
59689: PPUSH
59690: LD_VAR 0 9
59694: PUSH
59695: LD_INT 2
59697: ARRAY
59698: PPUSH
59699: CALL_OW 546
59703: ST_TO_ADDR
// if hex [ 1 ] then
59704: LD_VAR 0 4
59708: PUSH
59709: LD_INT 1
59711: ARRAY
59712: IFFALSE 59716
// continue ;
59714: GO 59604
// h := hex [ 2 ] ;
59716: LD_ADDR_VAR 0 13
59720: PUSH
59721: LD_VAR 0 4
59725: PUSH
59726: LD_INT 2
59728: ARRAY
59729: ST_TO_ADDR
// if h + 7 < height then
59730: LD_VAR 0 13
59734: PUSH
59735: LD_INT 7
59737: PLUS
59738: PUSH
59739: LD_VAR 0 15
59743: LESS
59744: IFFALSE 59773
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59746: LD_ADDR_VAR 0 18
59750: PUSH
59751: LD_INT 7
59753: PUSH
59754: LD_INT 28
59756: PUSH
59757: LD_INT 45
59759: PUSH
59760: EMPTY
59761: LIST
59762: LIST
59763: LIST
59764: PUSH
59765: LD_VAR 0 12
59769: ARRAY
59770: ST_TO_ADDR
// break ;
59771: GO 59775
// end ; end ; end ;
59773: GO 59604
59775: POP
59776: POP
// end ; if not weapon then
59777: LD_VAR 0 18
59781: NOT
59782: IFFALSE 59842
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59784: LD_ADDR_VAR 0 5
59788: PUSH
59789: LD_VAR 0 5
59793: PUSH
59794: LD_INT 11
59796: PUSH
59797: LD_INT 30
59799: PUSH
59800: LD_INT 49
59802: PUSH
59803: EMPTY
59804: LIST
59805: LIST
59806: LIST
59807: DIFF
59808: ST_TO_ADDR
// if not list then
59809: LD_VAR 0 5
59813: NOT
59814: IFFALSE 59818
// exit ;
59816: GO 59960
// weapon := list [ rand ( 1 , list ) ] ;
59818: LD_ADDR_VAR 0 18
59822: PUSH
59823: LD_VAR 0 5
59827: PUSH
59828: LD_INT 1
59830: PPUSH
59831: LD_VAR 0 5
59835: PPUSH
59836: CALL_OW 12
59840: ARRAY
59841: ST_TO_ADDR
// end ; if weapon then
59842: LD_VAR 0 18
59846: IFFALSE 59960
// begin tmp := CostOfWeapon ( weapon ) ;
59848: LD_ADDR_VAR 0 14
59852: PUSH
59853: LD_VAR 0 18
59857: PPUSH
59858: CALL_OW 451
59862: ST_TO_ADDR
// j := GetBase ( tower ) ;
59863: LD_ADDR_VAR 0 9
59867: PUSH
59868: LD_VAR 0 1
59872: PPUSH
59873: CALL_OW 274
59877: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59878: LD_VAR 0 9
59882: PPUSH
59883: LD_INT 1
59885: PPUSH
59886: CALL_OW 275
59890: PUSH
59891: LD_VAR 0 14
59895: PUSH
59896: LD_INT 1
59898: ARRAY
59899: GREATEREQUAL
59900: PUSH
59901: LD_VAR 0 9
59905: PPUSH
59906: LD_INT 2
59908: PPUSH
59909: CALL_OW 275
59913: PUSH
59914: LD_VAR 0 14
59918: PUSH
59919: LD_INT 2
59921: ARRAY
59922: GREATEREQUAL
59923: AND
59924: PUSH
59925: LD_VAR 0 9
59929: PPUSH
59930: LD_INT 3
59932: PPUSH
59933: CALL_OW 275
59937: PUSH
59938: LD_VAR 0 14
59942: PUSH
59943: LD_INT 3
59945: ARRAY
59946: GREATEREQUAL
59947: AND
59948: IFFALSE 59960
// result := weapon ;
59950: LD_ADDR_VAR 0 3
59954: PUSH
59955: LD_VAR 0 18
59959: ST_TO_ADDR
// end ; end ;
59960: LD_VAR 0 3
59964: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59965: LD_INT 0
59967: PPUSH
59968: PPUSH
// result := true ;
59969: LD_ADDR_VAR 0 3
59973: PUSH
59974: LD_INT 1
59976: ST_TO_ADDR
// if array1 = array2 then
59977: LD_VAR 0 1
59981: PUSH
59982: LD_VAR 0 2
59986: EQUAL
59987: IFFALSE 60047
// begin for i = 1 to array1 do
59989: LD_ADDR_VAR 0 4
59993: PUSH
59994: DOUBLE
59995: LD_INT 1
59997: DEC
59998: ST_TO_ADDR
59999: LD_VAR 0 1
60003: PUSH
60004: FOR_TO
60005: IFFALSE 60043
// if array1 [ i ] <> array2 [ i ] then
60007: LD_VAR 0 1
60011: PUSH
60012: LD_VAR 0 4
60016: ARRAY
60017: PUSH
60018: LD_VAR 0 2
60022: PUSH
60023: LD_VAR 0 4
60027: ARRAY
60028: NONEQUAL
60029: IFFALSE 60041
// begin result := false ;
60031: LD_ADDR_VAR 0 3
60035: PUSH
60036: LD_INT 0
60038: ST_TO_ADDR
// break ;
60039: GO 60043
// end ;
60041: GO 60004
60043: POP
60044: POP
// end else
60045: GO 60055
// result := false ;
60047: LD_ADDR_VAR 0 3
60051: PUSH
60052: LD_INT 0
60054: ST_TO_ADDR
// end ;
60055: LD_VAR 0 3
60059: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60060: LD_INT 0
60062: PPUSH
60063: PPUSH
// if not array1 or not array2 then
60064: LD_VAR 0 1
60068: NOT
60069: PUSH
60070: LD_VAR 0 2
60074: NOT
60075: OR
60076: IFFALSE 60080
// exit ;
60078: GO 60144
// result := true ;
60080: LD_ADDR_VAR 0 3
60084: PUSH
60085: LD_INT 1
60087: ST_TO_ADDR
// for i = 1 to array1 do
60088: LD_ADDR_VAR 0 4
60092: PUSH
60093: DOUBLE
60094: LD_INT 1
60096: DEC
60097: ST_TO_ADDR
60098: LD_VAR 0 1
60102: PUSH
60103: FOR_TO
60104: IFFALSE 60142
// if array1 [ i ] <> array2 [ i ] then
60106: LD_VAR 0 1
60110: PUSH
60111: LD_VAR 0 4
60115: ARRAY
60116: PUSH
60117: LD_VAR 0 2
60121: PUSH
60122: LD_VAR 0 4
60126: ARRAY
60127: NONEQUAL
60128: IFFALSE 60140
// begin result := false ;
60130: LD_ADDR_VAR 0 3
60134: PUSH
60135: LD_INT 0
60137: ST_TO_ADDR
// break ;
60138: GO 60142
// end ;
60140: GO 60103
60142: POP
60143: POP
// end ;
60144: LD_VAR 0 3
60148: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60149: LD_INT 0
60151: PPUSH
60152: PPUSH
60153: PPUSH
// pom := GetBase ( fac ) ;
60154: LD_ADDR_VAR 0 5
60158: PUSH
60159: LD_VAR 0 1
60163: PPUSH
60164: CALL_OW 274
60168: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60169: LD_ADDR_VAR 0 4
60173: PUSH
60174: LD_VAR 0 2
60178: PUSH
60179: LD_INT 1
60181: ARRAY
60182: PPUSH
60183: LD_VAR 0 2
60187: PUSH
60188: LD_INT 2
60190: ARRAY
60191: PPUSH
60192: LD_VAR 0 2
60196: PUSH
60197: LD_INT 3
60199: ARRAY
60200: PPUSH
60201: LD_VAR 0 2
60205: PUSH
60206: LD_INT 4
60208: ARRAY
60209: PPUSH
60210: CALL_OW 449
60214: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60215: LD_ADDR_VAR 0 3
60219: PUSH
60220: LD_VAR 0 5
60224: PPUSH
60225: LD_INT 1
60227: PPUSH
60228: CALL_OW 275
60232: PUSH
60233: LD_VAR 0 4
60237: PUSH
60238: LD_INT 1
60240: ARRAY
60241: GREATEREQUAL
60242: PUSH
60243: LD_VAR 0 5
60247: PPUSH
60248: LD_INT 2
60250: PPUSH
60251: CALL_OW 275
60255: PUSH
60256: LD_VAR 0 4
60260: PUSH
60261: LD_INT 2
60263: ARRAY
60264: GREATEREQUAL
60265: AND
60266: PUSH
60267: LD_VAR 0 5
60271: PPUSH
60272: LD_INT 3
60274: PPUSH
60275: CALL_OW 275
60279: PUSH
60280: LD_VAR 0 4
60284: PUSH
60285: LD_INT 3
60287: ARRAY
60288: GREATEREQUAL
60289: AND
60290: ST_TO_ADDR
// end ;
60291: LD_VAR 0 3
60295: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60296: LD_INT 0
60298: PPUSH
60299: PPUSH
60300: PPUSH
60301: PPUSH
// pom := GetBase ( building ) ;
60302: LD_ADDR_VAR 0 3
60306: PUSH
60307: LD_VAR 0 1
60311: PPUSH
60312: CALL_OW 274
60316: ST_TO_ADDR
// if not pom then
60317: LD_VAR 0 3
60321: NOT
60322: IFFALSE 60326
// exit ;
60324: GO 60496
// btype := GetBType ( building ) ;
60326: LD_ADDR_VAR 0 5
60330: PUSH
60331: LD_VAR 0 1
60335: PPUSH
60336: CALL_OW 266
60340: ST_TO_ADDR
// if btype = b_armoury then
60341: LD_VAR 0 5
60345: PUSH
60346: LD_INT 4
60348: EQUAL
60349: IFFALSE 60359
// btype := b_barracks ;
60351: LD_ADDR_VAR 0 5
60355: PUSH
60356: LD_INT 5
60358: ST_TO_ADDR
// if btype = b_depot then
60359: LD_VAR 0 5
60363: PUSH
60364: LD_INT 0
60366: EQUAL
60367: IFFALSE 60377
// btype := b_warehouse ;
60369: LD_ADDR_VAR 0 5
60373: PUSH
60374: LD_INT 1
60376: ST_TO_ADDR
// if btype = b_workshop then
60377: LD_VAR 0 5
60381: PUSH
60382: LD_INT 2
60384: EQUAL
60385: IFFALSE 60395
// btype := b_factory ;
60387: LD_ADDR_VAR 0 5
60391: PUSH
60392: LD_INT 3
60394: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60395: LD_ADDR_VAR 0 4
60399: PUSH
60400: LD_VAR 0 5
60404: PPUSH
60405: LD_VAR 0 1
60409: PPUSH
60410: CALL_OW 248
60414: PPUSH
60415: CALL_OW 450
60419: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60420: LD_ADDR_VAR 0 2
60424: PUSH
60425: LD_VAR 0 3
60429: PPUSH
60430: LD_INT 1
60432: PPUSH
60433: CALL_OW 275
60437: PUSH
60438: LD_VAR 0 4
60442: PUSH
60443: LD_INT 1
60445: ARRAY
60446: GREATEREQUAL
60447: PUSH
60448: LD_VAR 0 3
60452: PPUSH
60453: LD_INT 2
60455: PPUSH
60456: CALL_OW 275
60460: PUSH
60461: LD_VAR 0 4
60465: PUSH
60466: LD_INT 2
60468: ARRAY
60469: GREATEREQUAL
60470: AND
60471: PUSH
60472: LD_VAR 0 3
60476: PPUSH
60477: LD_INT 3
60479: PPUSH
60480: CALL_OW 275
60484: PUSH
60485: LD_VAR 0 4
60489: PUSH
60490: LD_INT 3
60492: ARRAY
60493: GREATEREQUAL
60494: AND
60495: ST_TO_ADDR
// end ;
60496: LD_VAR 0 2
60500: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60501: LD_INT 0
60503: PPUSH
60504: PPUSH
60505: PPUSH
// pom := GetBase ( building ) ;
60506: LD_ADDR_VAR 0 4
60510: PUSH
60511: LD_VAR 0 1
60515: PPUSH
60516: CALL_OW 274
60520: ST_TO_ADDR
// if not pom then
60521: LD_VAR 0 4
60525: NOT
60526: IFFALSE 60530
// exit ;
60528: GO 60631
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60530: LD_ADDR_VAR 0 5
60534: PUSH
60535: LD_VAR 0 2
60539: PPUSH
60540: LD_VAR 0 1
60544: PPUSH
60545: CALL_OW 248
60549: PPUSH
60550: CALL_OW 450
60554: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60555: LD_ADDR_VAR 0 3
60559: PUSH
60560: LD_VAR 0 4
60564: PPUSH
60565: LD_INT 1
60567: PPUSH
60568: CALL_OW 275
60572: PUSH
60573: LD_VAR 0 5
60577: PUSH
60578: LD_INT 1
60580: ARRAY
60581: GREATEREQUAL
60582: PUSH
60583: LD_VAR 0 4
60587: PPUSH
60588: LD_INT 2
60590: PPUSH
60591: CALL_OW 275
60595: PUSH
60596: LD_VAR 0 5
60600: PUSH
60601: LD_INT 2
60603: ARRAY
60604: GREATEREQUAL
60605: AND
60606: PUSH
60607: LD_VAR 0 4
60611: PPUSH
60612: LD_INT 3
60614: PPUSH
60615: CALL_OW 275
60619: PUSH
60620: LD_VAR 0 5
60624: PUSH
60625: LD_INT 3
60627: ARRAY
60628: GREATEREQUAL
60629: AND
60630: ST_TO_ADDR
// end ;
60631: LD_VAR 0 3
60635: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60636: LD_INT 0
60638: PPUSH
60639: PPUSH
60640: PPUSH
60641: PPUSH
60642: PPUSH
60643: PPUSH
60644: PPUSH
60645: PPUSH
60646: PPUSH
60647: PPUSH
60648: PPUSH
// result := false ;
60649: LD_ADDR_VAR 0 8
60653: PUSH
60654: LD_INT 0
60656: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60657: LD_VAR 0 5
60661: NOT
60662: PUSH
60663: LD_VAR 0 1
60667: NOT
60668: OR
60669: PUSH
60670: LD_VAR 0 2
60674: NOT
60675: OR
60676: PUSH
60677: LD_VAR 0 3
60681: NOT
60682: OR
60683: IFFALSE 60687
// exit ;
60685: GO 61501
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60687: LD_ADDR_VAR 0 14
60691: PUSH
60692: LD_VAR 0 1
60696: PPUSH
60697: LD_VAR 0 2
60701: PPUSH
60702: LD_VAR 0 3
60706: PPUSH
60707: LD_VAR 0 4
60711: PPUSH
60712: LD_VAR 0 5
60716: PUSH
60717: LD_INT 1
60719: ARRAY
60720: PPUSH
60721: CALL_OW 248
60725: PPUSH
60726: LD_INT 0
60728: PPUSH
60729: CALL 62734 0 6
60733: ST_TO_ADDR
// if not hexes then
60734: LD_VAR 0 14
60738: NOT
60739: IFFALSE 60743
// exit ;
60741: GO 61501
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60743: LD_ADDR_VAR 0 17
60747: PUSH
60748: LD_VAR 0 5
60752: PPUSH
60753: LD_INT 22
60755: PUSH
60756: LD_VAR 0 13
60760: PPUSH
60761: CALL_OW 255
60765: PUSH
60766: EMPTY
60767: LIST
60768: LIST
60769: PUSH
60770: LD_INT 2
60772: PUSH
60773: LD_INT 30
60775: PUSH
60776: LD_INT 0
60778: PUSH
60779: EMPTY
60780: LIST
60781: LIST
60782: PUSH
60783: LD_INT 30
60785: PUSH
60786: LD_INT 1
60788: PUSH
60789: EMPTY
60790: LIST
60791: LIST
60792: PUSH
60793: EMPTY
60794: LIST
60795: LIST
60796: LIST
60797: PUSH
60798: EMPTY
60799: LIST
60800: LIST
60801: PPUSH
60802: CALL_OW 72
60806: ST_TO_ADDR
// for i = 1 to hexes do
60807: LD_ADDR_VAR 0 9
60811: PUSH
60812: DOUBLE
60813: LD_INT 1
60815: DEC
60816: ST_TO_ADDR
60817: LD_VAR 0 14
60821: PUSH
60822: FOR_TO
60823: IFFALSE 61499
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60825: LD_ADDR_VAR 0 13
60829: PUSH
60830: LD_VAR 0 14
60834: PUSH
60835: LD_VAR 0 9
60839: ARRAY
60840: PUSH
60841: LD_INT 1
60843: ARRAY
60844: PPUSH
60845: LD_VAR 0 14
60849: PUSH
60850: LD_VAR 0 9
60854: ARRAY
60855: PUSH
60856: LD_INT 2
60858: ARRAY
60859: PPUSH
60860: CALL_OW 428
60864: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60865: LD_VAR 0 14
60869: PUSH
60870: LD_VAR 0 9
60874: ARRAY
60875: PUSH
60876: LD_INT 1
60878: ARRAY
60879: PPUSH
60880: LD_VAR 0 14
60884: PUSH
60885: LD_VAR 0 9
60889: ARRAY
60890: PUSH
60891: LD_INT 2
60893: ARRAY
60894: PPUSH
60895: CALL_OW 351
60899: PUSH
60900: LD_VAR 0 14
60904: PUSH
60905: LD_VAR 0 9
60909: ARRAY
60910: PUSH
60911: LD_INT 1
60913: ARRAY
60914: PPUSH
60915: LD_VAR 0 14
60919: PUSH
60920: LD_VAR 0 9
60924: ARRAY
60925: PUSH
60926: LD_INT 2
60928: ARRAY
60929: PPUSH
60930: CALL_OW 488
60934: NOT
60935: OR
60936: PUSH
60937: LD_VAR 0 13
60941: PPUSH
60942: CALL_OW 247
60946: PUSH
60947: LD_INT 3
60949: EQUAL
60950: OR
60951: IFFALSE 60957
// exit ;
60953: POP
60954: POP
60955: GO 61501
// if not tmp then
60957: LD_VAR 0 13
60961: NOT
60962: IFFALSE 60966
// continue ;
60964: GO 60822
// result := true ;
60966: LD_ADDR_VAR 0 8
60970: PUSH
60971: LD_INT 1
60973: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60974: LD_VAR 0 6
60978: PUSH
60979: LD_VAR 0 13
60983: PPUSH
60984: CALL_OW 247
60988: PUSH
60989: LD_INT 2
60991: EQUAL
60992: AND
60993: PUSH
60994: LD_VAR 0 13
60998: PPUSH
60999: CALL_OW 263
61003: PUSH
61004: LD_INT 1
61006: EQUAL
61007: AND
61008: IFFALSE 61172
// begin if IsDrivenBy ( tmp ) then
61010: LD_VAR 0 13
61014: PPUSH
61015: CALL_OW 311
61019: IFFALSE 61023
// continue ;
61021: GO 60822
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61023: LD_VAR 0 6
61027: PPUSH
61028: LD_INT 3
61030: PUSH
61031: LD_INT 60
61033: PUSH
61034: EMPTY
61035: LIST
61036: PUSH
61037: EMPTY
61038: LIST
61039: LIST
61040: PUSH
61041: LD_INT 3
61043: PUSH
61044: LD_INT 55
61046: PUSH
61047: EMPTY
61048: LIST
61049: PUSH
61050: EMPTY
61051: LIST
61052: LIST
61053: PUSH
61054: EMPTY
61055: LIST
61056: LIST
61057: PPUSH
61058: CALL_OW 72
61062: IFFALSE 61170
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61064: LD_ADDR_VAR 0 18
61068: PUSH
61069: LD_VAR 0 6
61073: PPUSH
61074: LD_INT 3
61076: PUSH
61077: LD_INT 60
61079: PUSH
61080: EMPTY
61081: LIST
61082: PUSH
61083: EMPTY
61084: LIST
61085: LIST
61086: PUSH
61087: LD_INT 3
61089: PUSH
61090: LD_INT 55
61092: PUSH
61093: EMPTY
61094: LIST
61095: PUSH
61096: EMPTY
61097: LIST
61098: LIST
61099: PUSH
61100: EMPTY
61101: LIST
61102: LIST
61103: PPUSH
61104: CALL_OW 72
61108: PUSH
61109: LD_INT 1
61111: ARRAY
61112: ST_TO_ADDR
// if IsInUnit ( driver ) then
61113: LD_VAR 0 18
61117: PPUSH
61118: CALL_OW 310
61122: IFFALSE 61133
// ComExit ( driver ) ;
61124: LD_VAR 0 18
61128: PPUSH
61129: CALL 86514 0 1
// AddComEnterUnit ( driver , tmp ) ;
61133: LD_VAR 0 18
61137: PPUSH
61138: LD_VAR 0 13
61142: PPUSH
61143: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61147: LD_VAR 0 18
61151: PPUSH
61152: LD_VAR 0 7
61156: PPUSH
61157: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61161: LD_VAR 0 18
61165: PPUSH
61166: CALL_OW 181
// end ; continue ;
61170: GO 60822
// end ; if not cleaners or not tmp in cleaners then
61172: LD_VAR 0 6
61176: NOT
61177: PUSH
61178: LD_VAR 0 13
61182: PUSH
61183: LD_VAR 0 6
61187: IN
61188: NOT
61189: OR
61190: IFFALSE 61497
// begin if dep then
61192: LD_VAR 0 17
61196: IFFALSE 61332
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61198: LD_ADDR_VAR 0 16
61202: PUSH
61203: LD_VAR 0 17
61207: PUSH
61208: LD_INT 1
61210: ARRAY
61211: PPUSH
61212: CALL_OW 250
61216: PPUSH
61217: LD_VAR 0 17
61221: PUSH
61222: LD_INT 1
61224: ARRAY
61225: PPUSH
61226: CALL_OW 254
61230: PPUSH
61231: LD_INT 5
61233: PPUSH
61234: CALL_OW 272
61238: PUSH
61239: LD_VAR 0 17
61243: PUSH
61244: LD_INT 1
61246: ARRAY
61247: PPUSH
61248: CALL_OW 251
61252: PPUSH
61253: LD_VAR 0 17
61257: PUSH
61258: LD_INT 1
61260: ARRAY
61261: PPUSH
61262: CALL_OW 254
61266: PPUSH
61267: LD_INT 5
61269: PPUSH
61270: CALL_OW 273
61274: PUSH
61275: EMPTY
61276: LIST
61277: LIST
61278: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61279: LD_VAR 0 16
61283: PUSH
61284: LD_INT 1
61286: ARRAY
61287: PPUSH
61288: LD_VAR 0 16
61292: PUSH
61293: LD_INT 2
61295: ARRAY
61296: PPUSH
61297: CALL_OW 488
61301: IFFALSE 61332
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61303: LD_VAR 0 13
61307: PPUSH
61308: LD_VAR 0 16
61312: PUSH
61313: LD_INT 1
61315: ARRAY
61316: PPUSH
61317: LD_VAR 0 16
61321: PUSH
61322: LD_INT 2
61324: ARRAY
61325: PPUSH
61326: CALL_OW 111
// continue ;
61330: GO 60822
// end ; end ; r := GetDir ( tmp ) ;
61332: LD_ADDR_VAR 0 15
61336: PUSH
61337: LD_VAR 0 13
61341: PPUSH
61342: CALL_OW 254
61346: ST_TO_ADDR
// if r = 5 then
61347: LD_VAR 0 15
61351: PUSH
61352: LD_INT 5
61354: EQUAL
61355: IFFALSE 61365
// r := 0 ;
61357: LD_ADDR_VAR 0 15
61361: PUSH
61362: LD_INT 0
61364: ST_TO_ADDR
// for j = r to 5 do
61365: LD_ADDR_VAR 0 10
61369: PUSH
61370: DOUBLE
61371: LD_VAR 0 15
61375: DEC
61376: ST_TO_ADDR
61377: LD_INT 5
61379: PUSH
61380: FOR_TO
61381: IFFALSE 61495
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61383: LD_ADDR_VAR 0 11
61387: PUSH
61388: LD_VAR 0 13
61392: PPUSH
61393: CALL_OW 250
61397: PPUSH
61398: LD_VAR 0 10
61402: PPUSH
61403: LD_INT 2
61405: PPUSH
61406: CALL_OW 272
61410: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61411: LD_ADDR_VAR 0 12
61415: PUSH
61416: LD_VAR 0 13
61420: PPUSH
61421: CALL_OW 251
61425: PPUSH
61426: LD_VAR 0 10
61430: PPUSH
61431: LD_INT 2
61433: PPUSH
61434: CALL_OW 273
61438: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61439: LD_VAR 0 11
61443: PPUSH
61444: LD_VAR 0 12
61448: PPUSH
61449: CALL_OW 488
61453: PUSH
61454: LD_VAR 0 11
61458: PPUSH
61459: LD_VAR 0 12
61463: PPUSH
61464: CALL_OW 428
61468: NOT
61469: AND
61470: IFFALSE 61493
// begin ComMoveXY ( tmp , _x , _y ) ;
61472: LD_VAR 0 13
61476: PPUSH
61477: LD_VAR 0 11
61481: PPUSH
61482: LD_VAR 0 12
61486: PPUSH
61487: CALL_OW 111
// break ;
61491: GO 61495
// end ; end ;
61493: GO 61380
61495: POP
61496: POP
// end ; end ;
61497: GO 60822
61499: POP
61500: POP
// end ;
61501: LD_VAR 0 8
61505: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61506: LD_INT 0
61508: PPUSH
// result := true ;
61509: LD_ADDR_VAR 0 3
61513: PUSH
61514: LD_INT 1
61516: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61517: LD_VAR 0 2
61521: PUSH
61522: LD_INT 24
61524: DOUBLE
61525: EQUAL
61526: IFTRUE 61536
61528: LD_INT 33
61530: DOUBLE
61531: EQUAL
61532: IFTRUE 61536
61534: GO 61561
61536: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61537: LD_ADDR_VAR 0 3
61541: PUSH
61542: LD_INT 32
61544: PPUSH
61545: LD_VAR 0 1
61549: PPUSH
61550: CALL_OW 321
61554: PUSH
61555: LD_INT 2
61557: EQUAL
61558: ST_TO_ADDR
61559: GO 61877
61561: LD_INT 20
61563: DOUBLE
61564: EQUAL
61565: IFTRUE 61569
61567: GO 61594
61569: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61570: LD_ADDR_VAR 0 3
61574: PUSH
61575: LD_INT 6
61577: PPUSH
61578: LD_VAR 0 1
61582: PPUSH
61583: CALL_OW 321
61587: PUSH
61588: LD_INT 2
61590: EQUAL
61591: ST_TO_ADDR
61592: GO 61877
61594: LD_INT 22
61596: DOUBLE
61597: EQUAL
61598: IFTRUE 61608
61600: LD_INT 36
61602: DOUBLE
61603: EQUAL
61604: IFTRUE 61608
61606: GO 61633
61608: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61609: LD_ADDR_VAR 0 3
61613: PUSH
61614: LD_INT 15
61616: PPUSH
61617: LD_VAR 0 1
61621: PPUSH
61622: CALL_OW 321
61626: PUSH
61627: LD_INT 2
61629: EQUAL
61630: ST_TO_ADDR
61631: GO 61877
61633: LD_INT 30
61635: DOUBLE
61636: EQUAL
61637: IFTRUE 61641
61639: GO 61666
61641: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61642: LD_ADDR_VAR 0 3
61646: PUSH
61647: LD_INT 20
61649: PPUSH
61650: LD_VAR 0 1
61654: PPUSH
61655: CALL_OW 321
61659: PUSH
61660: LD_INT 2
61662: EQUAL
61663: ST_TO_ADDR
61664: GO 61877
61666: LD_INT 28
61668: DOUBLE
61669: EQUAL
61670: IFTRUE 61680
61672: LD_INT 21
61674: DOUBLE
61675: EQUAL
61676: IFTRUE 61680
61678: GO 61705
61680: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61681: LD_ADDR_VAR 0 3
61685: PUSH
61686: LD_INT 21
61688: PPUSH
61689: LD_VAR 0 1
61693: PPUSH
61694: CALL_OW 321
61698: PUSH
61699: LD_INT 2
61701: EQUAL
61702: ST_TO_ADDR
61703: GO 61877
61705: LD_INT 16
61707: DOUBLE
61708: EQUAL
61709: IFTRUE 61713
61711: GO 61738
61713: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61714: LD_ADDR_VAR 0 3
61718: PUSH
61719: LD_INT 84
61721: PPUSH
61722: LD_VAR 0 1
61726: PPUSH
61727: CALL_OW 321
61731: PUSH
61732: LD_INT 2
61734: EQUAL
61735: ST_TO_ADDR
61736: GO 61877
61738: LD_INT 19
61740: DOUBLE
61741: EQUAL
61742: IFTRUE 61752
61744: LD_INT 23
61746: DOUBLE
61747: EQUAL
61748: IFTRUE 61752
61750: GO 61777
61752: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61753: LD_ADDR_VAR 0 3
61757: PUSH
61758: LD_INT 83
61760: PPUSH
61761: LD_VAR 0 1
61765: PPUSH
61766: CALL_OW 321
61770: PUSH
61771: LD_INT 2
61773: EQUAL
61774: ST_TO_ADDR
61775: GO 61877
61777: LD_INT 17
61779: DOUBLE
61780: EQUAL
61781: IFTRUE 61785
61783: GO 61810
61785: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61786: LD_ADDR_VAR 0 3
61790: PUSH
61791: LD_INT 39
61793: PPUSH
61794: LD_VAR 0 1
61798: PPUSH
61799: CALL_OW 321
61803: PUSH
61804: LD_INT 2
61806: EQUAL
61807: ST_TO_ADDR
61808: GO 61877
61810: LD_INT 18
61812: DOUBLE
61813: EQUAL
61814: IFTRUE 61818
61816: GO 61843
61818: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61819: LD_ADDR_VAR 0 3
61823: PUSH
61824: LD_INT 40
61826: PPUSH
61827: LD_VAR 0 1
61831: PPUSH
61832: CALL_OW 321
61836: PUSH
61837: LD_INT 2
61839: EQUAL
61840: ST_TO_ADDR
61841: GO 61877
61843: LD_INT 27
61845: DOUBLE
61846: EQUAL
61847: IFTRUE 61851
61849: GO 61876
61851: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61852: LD_ADDR_VAR 0 3
61856: PUSH
61857: LD_INT 35
61859: PPUSH
61860: LD_VAR 0 1
61864: PPUSH
61865: CALL_OW 321
61869: PUSH
61870: LD_INT 2
61872: EQUAL
61873: ST_TO_ADDR
61874: GO 61877
61876: POP
// end ;
61877: LD_VAR 0 3
61881: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61882: LD_INT 0
61884: PPUSH
61885: PPUSH
61886: PPUSH
61887: PPUSH
61888: PPUSH
61889: PPUSH
61890: PPUSH
61891: PPUSH
61892: PPUSH
61893: PPUSH
61894: PPUSH
// result := false ;
61895: LD_ADDR_VAR 0 6
61899: PUSH
61900: LD_INT 0
61902: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61903: LD_VAR 0 1
61907: NOT
61908: PUSH
61909: LD_VAR 0 1
61913: PPUSH
61914: CALL_OW 266
61918: PUSH
61919: LD_INT 0
61921: PUSH
61922: LD_INT 1
61924: PUSH
61925: EMPTY
61926: LIST
61927: LIST
61928: IN
61929: NOT
61930: OR
61931: PUSH
61932: LD_VAR 0 2
61936: NOT
61937: OR
61938: PUSH
61939: LD_VAR 0 5
61943: PUSH
61944: LD_INT 0
61946: PUSH
61947: LD_INT 1
61949: PUSH
61950: LD_INT 2
61952: PUSH
61953: LD_INT 3
61955: PUSH
61956: LD_INT 4
61958: PUSH
61959: LD_INT 5
61961: PUSH
61962: EMPTY
61963: LIST
61964: LIST
61965: LIST
61966: LIST
61967: LIST
61968: LIST
61969: IN
61970: NOT
61971: OR
61972: PUSH
61973: LD_VAR 0 3
61977: PPUSH
61978: LD_VAR 0 4
61982: PPUSH
61983: CALL_OW 488
61987: NOT
61988: OR
61989: IFFALSE 61993
// exit ;
61991: GO 62729
// side := GetSide ( depot ) ;
61993: LD_ADDR_VAR 0 9
61997: PUSH
61998: LD_VAR 0 1
62002: PPUSH
62003: CALL_OW 255
62007: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62008: LD_VAR 0 9
62012: PPUSH
62013: LD_VAR 0 2
62017: PPUSH
62018: CALL 61506 0 2
62022: NOT
62023: IFFALSE 62027
// exit ;
62025: GO 62729
// pom := GetBase ( depot ) ;
62027: LD_ADDR_VAR 0 10
62031: PUSH
62032: LD_VAR 0 1
62036: PPUSH
62037: CALL_OW 274
62041: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62042: LD_ADDR_VAR 0 11
62046: PUSH
62047: LD_VAR 0 2
62051: PPUSH
62052: LD_VAR 0 1
62056: PPUSH
62057: CALL_OW 248
62061: PPUSH
62062: CALL_OW 450
62066: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62067: LD_VAR 0 10
62071: PPUSH
62072: LD_INT 1
62074: PPUSH
62075: CALL_OW 275
62079: PUSH
62080: LD_VAR 0 11
62084: PUSH
62085: LD_INT 1
62087: ARRAY
62088: GREATEREQUAL
62089: PUSH
62090: LD_VAR 0 10
62094: PPUSH
62095: LD_INT 2
62097: PPUSH
62098: CALL_OW 275
62102: PUSH
62103: LD_VAR 0 11
62107: PUSH
62108: LD_INT 2
62110: ARRAY
62111: GREATEREQUAL
62112: AND
62113: PUSH
62114: LD_VAR 0 10
62118: PPUSH
62119: LD_INT 3
62121: PPUSH
62122: CALL_OW 275
62126: PUSH
62127: LD_VAR 0 11
62131: PUSH
62132: LD_INT 3
62134: ARRAY
62135: GREATEREQUAL
62136: AND
62137: NOT
62138: IFFALSE 62142
// exit ;
62140: GO 62729
// if GetBType ( depot ) = b_depot then
62142: LD_VAR 0 1
62146: PPUSH
62147: CALL_OW 266
62151: PUSH
62152: LD_INT 0
62154: EQUAL
62155: IFFALSE 62167
// dist := 28 else
62157: LD_ADDR_VAR 0 14
62161: PUSH
62162: LD_INT 28
62164: ST_TO_ADDR
62165: GO 62175
// dist := 36 ;
62167: LD_ADDR_VAR 0 14
62171: PUSH
62172: LD_INT 36
62174: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62175: LD_VAR 0 1
62179: PPUSH
62180: LD_VAR 0 3
62184: PPUSH
62185: LD_VAR 0 4
62189: PPUSH
62190: CALL_OW 297
62194: PUSH
62195: LD_VAR 0 14
62199: GREATER
62200: IFFALSE 62204
// exit ;
62202: GO 62729
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62204: LD_ADDR_VAR 0 12
62208: PUSH
62209: LD_VAR 0 2
62213: PPUSH
62214: LD_VAR 0 3
62218: PPUSH
62219: LD_VAR 0 4
62223: PPUSH
62224: LD_VAR 0 5
62228: PPUSH
62229: LD_VAR 0 1
62233: PPUSH
62234: CALL_OW 248
62238: PPUSH
62239: LD_INT 0
62241: PPUSH
62242: CALL 62734 0 6
62246: ST_TO_ADDR
// if not hexes then
62247: LD_VAR 0 12
62251: NOT
62252: IFFALSE 62256
// exit ;
62254: GO 62729
// hex := GetHexInfo ( x , y ) ;
62256: LD_ADDR_VAR 0 15
62260: PUSH
62261: LD_VAR 0 3
62265: PPUSH
62266: LD_VAR 0 4
62270: PPUSH
62271: CALL_OW 546
62275: ST_TO_ADDR
// if hex [ 1 ] then
62276: LD_VAR 0 15
62280: PUSH
62281: LD_INT 1
62283: ARRAY
62284: IFFALSE 62288
// exit ;
62286: GO 62729
// height := hex [ 2 ] ;
62288: LD_ADDR_VAR 0 13
62292: PUSH
62293: LD_VAR 0 15
62297: PUSH
62298: LD_INT 2
62300: ARRAY
62301: ST_TO_ADDR
// for i = 1 to hexes do
62302: LD_ADDR_VAR 0 7
62306: PUSH
62307: DOUBLE
62308: LD_INT 1
62310: DEC
62311: ST_TO_ADDR
62312: LD_VAR 0 12
62316: PUSH
62317: FOR_TO
62318: IFFALSE 62648
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62320: LD_VAR 0 12
62324: PUSH
62325: LD_VAR 0 7
62329: ARRAY
62330: PUSH
62331: LD_INT 1
62333: ARRAY
62334: PPUSH
62335: LD_VAR 0 12
62339: PUSH
62340: LD_VAR 0 7
62344: ARRAY
62345: PUSH
62346: LD_INT 2
62348: ARRAY
62349: PPUSH
62350: CALL_OW 488
62354: NOT
62355: PUSH
62356: LD_VAR 0 12
62360: PUSH
62361: LD_VAR 0 7
62365: ARRAY
62366: PUSH
62367: LD_INT 1
62369: ARRAY
62370: PPUSH
62371: LD_VAR 0 12
62375: PUSH
62376: LD_VAR 0 7
62380: ARRAY
62381: PUSH
62382: LD_INT 2
62384: ARRAY
62385: PPUSH
62386: CALL_OW 428
62390: PUSH
62391: LD_INT 0
62393: GREATER
62394: OR
62395: PUSH
62396: LD_VAR 0 12
62400: PUSH
62401: LD_VAR 0 7
62405: ARRAY
62406: PUSH
62407: LD_INT 1
62409: ARRAY
62410: PPUSH
62411: LD_VAR 0 12
62415: PUSH
62416: LD_VAR 0 7
62420: ARRAY
62421: PUSH
62422: LD_INT 2
62424: ARRAY
62425: PPUSH
62426: CALL_OW 351
62430: OR
62431: IFFALSE 62437
// exit ;
62433: POP
62434: POP
62435: GO 62729
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62437: LD_ADDR_VAR 0 8
62441: PUSH
62442: LD_VAR 0 12
62446: PUSH
62447: LD_VAR 0 7
62451: ARRAY
62452: PUSH
62453: LD_INT 1
62455: ARRAY
62456: PPUSH
62457: LD_VAR 0 12
62461: PUSH
62462: LD_VAR 0 7
62466: ARRAY
62467: PUSH
62468: LD_INT 2
62470: ARRAY
62471: PPUSH
62472: CALL_OW 546
62476: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62477: LD_VAR 0 8
62481: PUSH
62482: LD_INT 1
62484: ARRAY
62485: PUSH
62486: LD_VAR 0 8
62490: PUSH
62491: LD_INT 2
62493: ARRAY
62494: PUSH
62495: LD_VAR 0 13
62499: PUSH
62500: LD_INT 2
62502: PLUS
62503: GREATER
62504: OR
62505: PUSH
62506: LD_VAR 0 8
62510: PUSH
62511: LD_INT 2
62513: ARRAY
62514: PUSH
62515: LD_VAR 0 13
62519: PUSH
62520: LD_INT 2
62522: MINUS
62523: LESS
62524: OR
62525: PUSH
62526: LD_VAR 0 8
62530: PUSH
62531: LD_INT 3
62533: ARRAY
62534: PUSH
62535: LD_INT 0
62537: PUSH
62538: LD_INT 8
62540: PUSH
62541: LD_INT 9
62543: PUSH
62544: LD_INT 10
62546: PUSH
62547: LD_INT 11
62549: PUSH
62550: LD_INT 12
62552: PUSH
62553: LD_INT 13
62555: PUSH
62556: LD_INT 16
62558: PUSH
62559: LD_INT 17
62561: PUSH
62562: LD_INT 18
62564: PUSH
62565: LD_INT 19
62567: PUSH
62568: LD_INT 20
62570: PUSH
62571: LD_INT 21
62573: PUSH
62574: EMPTY
62575: LIST
62576: LIST
62577: LIST
62578: LIST
62579: LIST
62580: LIST
62581: LIST
62582: LIST
62583: LIST
62584: LIST
62585: LIST
62586: LIST
62587: LIST
62588: IN
62589: NOT
62590: OR
62591: PUSH
62592: LD_VAR 0 8
62596: PUSH
62597: LD_INT 5
62599: ARRAY
62600: NOT
62601: OR
62602: PUSH
62603: LD_VAR 0 8
62607: PUSH
62608: LD_INT 6
62610: ARRAY
62611: PUSH
62612: LD_INT 1
62614: PUSH
62615: LD_INT 2
62617: PUSH
62618: LD_INT 7
62620: PUSH
62621: LD_INT 9
62623: PUSH
62624: LD_INT 10
62626: PUSH
62627: LD_INT 11
62629: PUSH
62630: EMPTY
62631: LIST
62632: LIST
62633: LIST
62634: LIST
62635: LIST
62636: LIST
62637: IN
62638: NOT
62639: OR
62640: IFFALSE 62646
// exit ;
62642: POP
62643: POP
62644: GO 62729
// end ;
62646: GO 62317
62648: POP
62649: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62650: LD_VAR 0 9
62654: PPUSH
62655: LD_VAR 0 3
62659: PPUSH
62660: LD_VAR 0 4
62664: PPUSH
62665: LD_INT 20
62667: PPUSH
62668: CALL 54681 0 4
62672: PUSH
62673: LD_INT 4
62675: ARRAY
62676: IFFALSE 62680
// exit ;
62678: GO 62729
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62680: LD_VAR 0 2
62684: PUSH
62685: LD_INT 29
62687: PUSH
62688: LD_INT 30
62690: PUSH
62691: EMPTY
62692: LIST
62693: LIST
62694: IN
62695: PUSH
62696: LD_VAR 0 3
62700: PPUSH
62701: LD_VAR 0 4
62705: PPUSH
62706: LD_VAR 0 9
62710: PPUSH
62711: CALL_OW 440
62715: NOT
62716: AND
62717: IFFALSE 62721
// exit ;
62719: GO 62729
// result := true ;
62721: LD_ADDR_VAR 0 6
62725: PUSH
62726: LD_INT 1
62728: ST_TO_ADDR
// end ;
62729: LD_VAR 0 6
62733: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62734: LD_INT 0
62736: PPUSH
62737: PPUSH
62738: PPUSH
62739: PPUSH
62740: PPUSH
62741: PPUSH
62742: PPUSH
62743: PPUSH
62744: PPUSH
62745: PPUSH
62746: PPUSH
62747: PPUSH
62748: PPUSH
62749: PPUSH
62750: PPUSH
62751: PPUSH
62752: PPUSH
62753: PPUSH
62754: PPUSH
62755: PPUSH
62756: PPUSH
62757: PPUSH
62758: PPUSH
62759: PPUSH
62760: PPUSH
62761: PPUSH
62762: PPUSH
62763: PPUSH
62764: PPUSH
62765: PPUSH
62766: PPUSH
62767: PPUSH
62768: PPUSH
62769: PPUSH
62770: PPUSH
62771: PPUSH
62772: PPUSH
62773: PPUSH
62774: PPUSH
62775: PPUSH
62776: PPUSH
62777: PPUSH
62778: PPUSH
62779: PPUSH
62780: PPUSH
62781: PPUSH
62782: PPUSH
62783: PPUSH
62784: PPUSH
62785: PPUSH
62786: PPUSH
62787: PPUSH
62788: PPUSH
62789: PPUSH
62790: PPUSH
62791: PPUSH
62792: PPUSH
62793: PPUSH
// result = [ ] ;
62794: LD_ADDR_VAR 0 7
62798: PUSH
62799: EMPTY
62800: ST_TO_ADDR
// temp_list = [ ] ;
62801: LD_ADDR_VAR 0 9
62805: PUSH
62806: EMPTY
62807: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62808: LD_VAR 0 4
62812: PUSH
62813: LD_INT 0
62815: PUSH
62816: LD_INT 1
62818: PUSH
62819: LD_INT 2
62821: PUSH
62822: LD_INT 3
62824: PUSH
62825: LD_INT 4
62827: PUSH
62828: LD_INT 5
62830: PUSH
62831: EMPTY
62832: LIST
62833: LIST
62834: LIST
62835: LIST
62836: LIST
62837: LIST
62838: IN
62839: NOT
62840: PUSH
62841: LD_VAR 0 1
62845: PUSH
62846: LD_INT 0
62848: PUSH
62849: LD_INT 1
62851: PUSH
62852: EMPTY
62853: LIST
62854: LIST
62855: IN
62856: PUSH
62857: LD_VAR 0 5
62861: PUSH
62862: LD_INT 1
62864: PUSH
62865: LD_INT 2
62867: PUSH
62868: LD_INT 3
62870: PUSH
62871: EMPTY
62872: LIST
62873: LIST
62874: LIST
62875: IN
62876: NOT
62877: AND
62878: OR
62879: IFFALSE 62883
// exit ;
62881: GO 81274
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62883: LD_VAR 0 1
62887: PUSH
62888: LD_INT 6
62890: PUSH
62891: LD_INT 7
62893: PUSH
62894: LD_INT 8
62896: PUSH
62897: LD_INT 13
62899: PUSH
62900: LD_INT 12
62902: PUSH
62903: LD_INT 15
62905: PUSH
62906: LD_INT 11
62908: PUSH
62909: LD_INT 14
62911: PUSH
62912: LD_INT 10
62914: PUSH
62915: EMPTY
62916: LIST
62917: LIST
62918: LIST
62919: LIST
62920: LIST
62921: LIST
62922: LIST
62923: LIST
62924: LIST
62925: IN
62926: IFFALSE 62936
// btype = b_lab ;
62928: LD_ADDR_VAR 0 1
62932: PUSH
62933: LD_INT 6
62935: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62936: LD_VAR 0 6
62940: PUSH
62941: LD_INT 0
62943: PUSH
62944: LD_INT 1
62946: PUSH
62947: LD_INT 2
62949: PUSH
62950: EMPTY
62951: LIST
62952: LIST
62953: LIST
62954: IN
62955: NOT
62956: PUSH
62957: LD_VAR 0 1
62961: PUSH
62962: LD_INT 0
62964: PUSH
62965: LD_INT 1
62967: PUSH
62968: LD_INT 2
62970: PUSH
62971: LD_INT 3
62973: PUSH
62974: LD_INT 6
62976: PUSH
62977: LD_INT 36
62979: PUSH
62980: LD_INT 4
62982: PUSH
62983: LD_INT 5
62985: PUSH
62986: LD_INT 31
62988: PUSH
62989: LD_INT 32
62991: PUSH
62992: LD_INT 33
62994: PUSH
62995: EMPTY
62996: LIST
62997: LIST
62998: LIST
62999: LIST
63000: LIST
63001: LIST
63002: LIST
63003: LIST
63004: LIST
63005: LIST
63006: LIST
63007: IN
63008: NOT
63009: PUSH
63010: LD_VAR 0 6
63014: PUSH
63015: LD_INT 1
63017: EQUAL
63018: AND
63019: OR
63020: PUSH
63021: LD_VAR 0 1
63025: PUSH
63026: LD_INT 2
63028: PUSH
63029: LD_INT 3
63031: PUSH
63032: EMPTY
63033: LIST
63034: LIST
63035: IN
63036: NOT
63037: PUSH
63038: LD_VAR 0 6
63042: PUSH
63043: LD_INT 2
63045: EQUAL
63046: AND
63047: OR
63048: IFFALSE 63058
// mode = 0 ;
63050: LD_ADDR_VAR 0 6
63054: PUSH
63055: LD_INT 0
63057: ST_TO_ADDR
// case mode of 0 :
63058: LD_VAR 0 6
63062: PUSH
63063: LD_INT 0
63065: DOUBLE
63066: EQUAL
63067: IFTRUE 63071
63069: GO 74524
63071: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63072: LD_ADDR_VAR 0 11
63076: PUSH
63077: LD_INT 0
63079: PUSH
63080: LD_INT 0
63082: PUSH
63083: EMPTY
63084: LIST
63085: LIST
63086: PUSH
63087: LD_INT 0
63089: PUSH
63090: LD_INT 1
63092: NEG
63093: PUSH
63094: EMPTY
63095: LIST
63096: LIST
63097: PUSH
63098: LD_INT 1
63100: PUSH
63101: LD_INT 0
63103: PUSH
63104: EMPTY
63105: LIST
63106: LIST
63107: PUSH
63108: LD_INT 1
63110: PUSH
63111: LD_INT 1
63113: PUSH
63114: EMPTY
63115: LIST
63116: LIST
63117: PUSH
63118: LD_INT 0
63120: PUSH
63121: LD_INT 1
63123: PUSH
63124: EMPTY
63125: LIST
63126: LIST
63127: PUSH
63128: LD_INT 1
63130: NEG
63131: PUSH
63132: LD_INT 0
63134: PUSH
63135: EMPTY
63136: LIST
63137: LIST
63138: PUSH
63139: LD_INT 1
63141: NEG
63142: PUSH
63143: LD_INT 1
63145: NEG
63146: PUSH
63147: EMPTY
63148: LIST
63149: LIST
63150: PUSH
63151: LD_INT 1
63153: NEG
63154: PUSH
63155: LD_INT 2
63157: NEG
63158: PUSH
63159: EMPTY
63160: LIST
63161: LIST
63162: PUSH
63163: LD_INT 0
63165: PUSH
63166: LD_INT 2
63168: NEG
63169: PUSH
63170: EMPTY
63171: LIST
63172: LIST
63173: PUSH
63174: LD_INT 1
63176: PUSH
63177: LD_INT 1
63179: NEG
63180: PUSH
63181: EMPTY
63182: LIST
63183: LIST
63184: PUSH
63185: LD_INT 1
63187: PUSH
63188: LD_INT 2
63190: PUSH
63191: EMPTY
63192: LIST
63193: LIST
63194: PUSH
63195: LD_INT 0
63197: PUSH
63198: LD_INT 2
63200: PUSH
63201: EMPTY
63202: LIST
63203: LIST
63204: PUSH
63205: LD_INT 1
63207: NEG
63208: PUSH
63209: LD_INT 1
63211: PUSH
63212: EMPTY
63213: LIST
63214: LIST
63215: PUSH
63216: LD_INT 1
63218: PUSH
63219: LD_INT 3
63221: PUSH
63222: EMPTY
63223: LIST
63224: LIST
63225: PUSH
63226: LD_INT 0
63228: PUSH
63229: LD_INT 3
63231: PUSH
63232: EMPTY
63233: LIST
63234: LIST
63235: PUSH
63236: LD_INT 1
63238: NEG
63239: PUSH
63240: LD_INT 2
63242: PUSH
63243: EMPTY
63244: LIST
63245: LIST
63246: PUSH
63247: EMPTY
63248: LIST
63249: LIST
63250: LIST
63251: LIST
63252: LIST
63253: LIST
63254: LIST
63255: LIST
63256: LIST
63257: LIST
63258: LIST
63259: LIST
63260: LIST
63261: LIST
63262: LIST
63263: LIST
63264: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63265: LD_ADDR_VAR 0 12
63269: PUSH
63270: LD_INT 0
63272: PUSH
63273: LD_INT 0
63275: PUSH
63276: EMPTY
63277: LIST
63278: LIST
63279: PUSH
63280: LD_INT 0
63282: PUSH
63283: LD_INT 1
63285: NEG
63286: PUSH
63287: EMPTY
63288: LIST
63289: LIST
63290: PUSH
63291: LD_INT 1
63293: PUSH
63294: LD_INT 0
63296: PUSH
63297: EMPTY
63298: LIST
63299: LIST
63300: PUSH
63301: LD_INT 1
63303: PUSH
63304: LD_INT 1
63306: PUSH
63307: EMPTY
63308: LIST
63309: LIST
63310: PUSH
63311: LD_INT 0
63313: PUSH
63314: LD_INT 1
63316: PUSH
63317: EMPTY
63318: LIST
63319: LIST
63320: PUSH
63321: LD_INT 1
63323: NEG
63324: PUSH
63325: LD_INT 0
63327: PUSH
63328: EMPTY
63329: LIST
63330: LIST
63331: PUSH
63332: LD_INT 1
63334: NEG
63335: PUSH
63336: LD_INT 1
63338: NEG
63339: PUSH
63340: EMPTY
63341: LIST
63342: LIST
63343: PUSH
63344: LD_INT 1
63346: PUSH
63347: LD_INT 1
63349: NEG
63350: PUSH
63351: EMPTY
63352: LIST
63353: LIST
63354: PUSH
63355: LD_INT 2
63357: PUSH
63358: LD_INT 0
63360: PUSH
63361: EMPTY
63362: LIST
63363: LIST
63364: PUSH
63365: LD_INT 2
63367: PUSH
63368: LD_INT 1
63370: PUSH
63371: EMPTY
63372: LIST
63373: LIST
63374: PUSH
63375: LD_INT 1
63377: NEG
63378: PUSH
63379: LD_INT 1
63381: PUSH
63382: EMPTY
63383: LIST
63384: LIST
63385: PUSH
63386: LD_INT 2
63388: NEG
63389: PUSH
63390: LD_INT 0
63392: PUSH
63393: EMPTY
63394: LIST
63395: LIST
63396: PUSH
63397: LD_INT 2
63399: NEG
63400: PUSH
63401: LD_INT 1
63403: NEG
63404: PUSH
63405: EMPTY
63406: LIST
63407: LIST
63408: PUSH
63409: LD_INT 2
63411: NEG
63412: PUSH
63413: LD_INT 1
63415: PUSH
63416: EMPTY
63417: LIST
63418: LIST
63419: PUSH
63420: LD_INT 3
63422: NEG
63423: PUSH
63424: LD_INT 0
63426: PUSH
63427: EMPTY
63428: LIST
63429: LIST
63430: PUSH
63431: LD_INT 3
63433: NEG
63434: PUSH
63435: LD_INT 1
63437: NEG
63438: PUSH
63439: EMPTY
63440: LIST
63441: LIST
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: LIST
63447: LIST
63448: LIST
63449: LIST
63450: LIST
63451: LIST
63452: LIST
63453: LIST
63454: LIST
63455: LIST
63456: LIST
63457: LIST
63458: LIST
63459: LIST
63460: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63461: LD_ADDR_VAR 0 13
63465: PUSH
63466: LD_INT 0
63468: PUSH
63469: LD_INT 0
63471: PUSH
63472: EMPTY
63473: LIST
63474: LIST
63475: PUSH
63476: LD_INT 0
63478: PUSH
63479: LD_INT 1
63481: NEG
63482: PUSH
63483: EMPTY
63484: LIST
63485: LIST
63486: PUSH
63487: LD_INT 1
63489: PUSH
63490: LD_INT 0
63492: PUSH
63493: EMPTY
63494: LIST
63495: LIST
63496: PUSH
63497: LD_INT 1
63499: PUSH
63500: LD_INT 1
63502: PUSH
63503: EMPTY
63504: LIST
63505: LIST
63506: PUSH
63507: LD_INT 0
63509: PUSH
63510: LD_INT 1
63512: PUSH
63513: EMPTY
63514: LIST
63515: LIST
63516: PUSH
63517: LD_INT 1
63519: NEG
63520: PUSH
63521: LD_INT 0
63523: PUSH
63524: EMPTY
63525: LIST
63526: LIST
63527: PUSH
63528: LD_INT 1
63530: NEG
63531: PUSH
63532: LD_INT 1
63534: NEG
63535: PUSH
63536: EMPTY
63537: LIST
63538: LIST
63539: PUSH
63540: LD_INT 1
63542: NEG
63543: PUSH
63544: LD_INT 2
63546: NEG
63547: PUSH
63548: EMPTY
63549: LIST
63550: LIST
63551: PUSH
63552: LD_INT 2
63554: PUSH
63555: LD_INT 1
63557: PUSH
63558: EMPTY
63559: LIST
63560: LIST
63561: PUSH
63562: LD_INT 2
63564: PUSH
63565: LD_INT 2
63567: PUSH
63568: EMPTY
63569: LIST
63570: LIST
63571: PUSH
63572: LD_INT 1
63574: PUSH
63575: LD_INT 2
63577: PUSH
63578: EMPTY
63579: LIST
63580: LIST
63581: PUSH
63582: LD_INT 2
63584: NEG
63585: PUSH
63586: LD_INT 1
63588: NEG
63589: PUSH
63590: EMPTY
63591: LIST
63592: LIST
63593: PUSH
63594: LD_INT 2
63596: NEG
63597: PUSH
63598: LD_INT 2
63600: NEG
63601: PUSH
63602: EMPTY
63603: LIST
63604: LIST
63605: PUSH
63606: LD_INT 2
63608: NEG
63609: PUSH
63610: LD_INT 3
63612: NEG
63613: PUSH
63614: EMPTY
63615: LIST
63616: LIST
63617: PUSH
63618: LD_INT 3
63620: NEG
63621: PUSH
63622: LD_INT 2
63624: NEG
63625: PUSH
63626: EMPTY
63627: LIST
63628: LIST
63629: PUSH
63630: LD_INT 3
63632: NEG
63633: PUSH
63634: LD_INT 3
63636: NEG
63637: PUSH
63638: EMPTY
63639: LIST
63640: LIST
63641: PUSH
63642: EMPTY
63643: LIST
63644: LIST
63645: LIST
63646: LIST
63647: LIST
63648: LIST
63649: LIST
63650: LIST
63651: LIST
63652: LIST
63653: LIST
63654: LIST
63655: LIST
63656: LIST
63657: LIST
63658: LIST
63659: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63660: LD_ADDR_VAR 0 14
63664: PUSH
63665: LD_INT 0
63667: PUSH
63668: LD_INT 0
63670: PUSH
63671: EMPTY
63672: LIST
63673: LIST
63674: PUSH
63675: LD_INT 0
63677: PUSH
63678: LD_INT 1
63680: NEG
63681: PUSH
63682: EMPTY
63683: LIST
63684: LIST
63685: PUSH
63686: LD_INT 1
63688: PUSH
63689: LD_INT 0
63691: PUSH
63692: EMPTY
63693: LIST
63694: LIST
63695: PUSH
63696: LD_INT 1
63698: PUSH
63699: LD_INT 1
63701: PUSH
63702: EMPTY
63703: LIST
63704: LIST
63705: PUSH
63706: LD_INT 0
63708: PUSH
63709: LD_INT 1
63711: PUSH
63712: EMPTY
63713: LIST
63714: LIST
63715: PUSH
63716: LD_INT 1
63718: NEG
63719: PUSH
63720: LD_INT 0
63722: PUSH
63723: EMPTY
63724: LIST
63725: LIST
63726: PUSH
63727: LD_INT 1
63729: NEG
63730: PUSH
63731: LD_INT 1
63733: NEG
63734: PUSH
63735: EMPTY
63736: LIST
63737: LIST
63738: PUSH
63739: LD_INT 1
63741: NEG
63742: PUSH
63743: LD_INT 2
63745: NEG
63746: PUSH
63747: EMPTY
63748: LIST
63749: LIST
63750: PUSH
63751: LD_INT 0
63753: PUSH
63754: LD_INT 2
63756: NEG
63757: PUSH
63758: EMPTY
63759: LIST
63760: LIST
63761: PUSH
63762: LD_INT 1
63764: PUSH
63765: LD_INT 1
63767: NEG
63768: PUSH
63769: EMPTY
63770: LIST
63771: LIST
63772: PUSH
63773: LD_INT 1
63775: PUSH
63776: LD_INT 2
63778: PUSH
63779: EMPTY
63780: LIST
63781: LIST
63782: PUSH
63783: LD_INT 0
63785: PUSH
63786: LD_INT 2
63788: PUSH
63789: EMPTY
63790: LIST
63791: LIST
63792: PUSH
63793: LD_INT 1
63795: NEG
63796: PUSH
63797: LD_INT 1
63799: PUSH
63800: EMPTY
63801: LIST
63802: LIST
63803: PUSH
63804: LD_INT 1
63806: NEG
63807: PUSH
63808: LD_INT 3
63810: NEG
63811: PUSH
63812: EMPTY
63813: LIST
63814: LIST
63815: PUSH
63816: LD_INT 0
63818: PUSH
63819: LD_INT 3
63821: NEG
63822: PUSH
63823: EMPTY
63824: LIST
63825: LIST
63826: PUSH
63827: LD_INT 1
63829: PUSH
63830: LD_INT 2
63832: NEG
63833: PUSH
63834: EMPTY
63835: LIST
63836: LIST
63837: PUSH
63838: EMPTY
63839: LIST
63840: LIST
63841: LIST
63842: LIST
63843: LIST
63844: LIST
63845: LIST
63846: LIST
63847: LIST
63848: LIST
63849: LIST
63850: LIST
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63856: LD_ADDR_VAR 0 15
63860: PUSH
63861: LD_INT 0
63863: PUSH
63864: LD_INT 0
63866: PUSH
63867: EMPTY
63868: LIST
63869: LIST
63870: PUSH
63871: LD_INT 0
63873: PUSH
63874: LD_INT 1
63876: NEG
63877: PUSH
63878: EMPTY
63879: LIST
63880: LIST
63881: PUSH
63882: LD_INT 1
63884: PUSH
63885: LD_INT 0
63887: PUSH
63888: EMPTY
63889: LIST
63890: LIST
63891: PUSH
63892: LD_INT 1
63894: PUSH
63895: LD_INT 1
63897: PUSH
63898: EMPTY
63899: LIST
63900: LIST
63901: PUSH
63902: LD_INT 0
63904: PUSH
63905: LD_INT 1
63907: PUSH
63908: EMPTY
63909: LIST
63910: LIST
63911: PUSH
63912: LD_INT 1
63914: NEG
63915: PUSH
63916: LD_INT 0
63918: PUSH
63919: EMPTY
63920: LIST
63921: LIST
63922: PUSH
63923: LD_INT 1
63925: NEG
63926: PUSH
63927: LD_INT 1
63929: NEG
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: PUSH
63935: LD_INT 1
63937: PUSH
63938: LD_INT 1
63940: NEG
63941: PUSH
63942: EMPTY
63943: LIST
63944: LIST
63945: PUSH
63946: LD_INT 2
63948: PUSH
63949: LD_INT 0
63951: PUSH
63952: EMPTY
63953: LIST
63954: LIST
63955: PUSH
63956: LD_INT 2
63958: PUSH
63959: LD_INT 1
63961: PUSH
63962: EMPTY
63963: LIST
63964: LIST
63965: PUSH
63966: LD_INT 1
63968: NEG
63969: PUSH
63970: LD_INT 1
63972: PUSH
63973: EMPTY
63974: LIST
63975: LIST
63976: PUSH
63977: LD_INT 2
63979: NEG
63980: PUSH
63981: LD_INT 0
63983: PUSH
63984: EMPTY
63985: LIST
63986: LIST
63987: PUSH
63988: LD_INT 2
63990: NEG
63991: PUSH
63992: LD_INT 1
63994: NEG
63995: PUSH
63996: EMPTY
63997: LIST
63998: LIST
63999: PUSH
64000: LD_INT 2
64002: PUSH
64003: LD_INT 1
64005: NEG
64006: PUSH
64007: EMPTY
64008: LIST
64009: LIST
64010: PUSH
64011: LD_INT 3
64013: PUSH
64014: LD_INT 0
64016: PUSH
64017: EMPTY
64018: LIST
64019: LIST
64020: PUSH
64021: LD_INT 3
64023: PUSH
64024: LD_INT 1
64026: PUSH
64027: EMPTY
64028: LIST
64029: LIST
64030: PUSH
64031: EMPTY
64032: LIST
64033: LIST
64034: LIST
64035: LIST
64036: LIST
64037: LIST
64038: LIST
64039: LIST
64040: LIST
64041: LIST
64042: LIST
64043: LIST
64044: LIST
64045: LIST
64046: LIST
64047: LIST
64048: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64049: LD_ADDR_VAR 0 16
64053: PUSH
64054: LD_INT 0
64056: PUSH
64057: LD_INT 0
64059: PUSH
64060: EMPTY
64061: LIST
64062: LIST
64063: PUSH
64064: LD_INT 0
64066: PUSH
64067: LD_INT 1
64069: NEG
64070: PUSH
64071: EMPTY
64072: LIST
64073: LIST
64074: PUSH
64075: LD_INT 1
64077: PUSH
64078: LD_INT 0
64080: PUSH
64081: EMPTY
64082: LIST
64083: LIST
64084: PUSH
64085: LD_INT 1
64087: PUSH
64088: LD_INT 1
64090: PUSH
64091: EMPTY
64092: LIST
64093: LIST
64094: PUSH
64095: LD_INT 0
64097: PUSH
64098: LD_INT 1
64100: PUSH
64101: EMPTY
64102: LIST
64103: LIST
64104: PUSH
64105: LD_INT 1
64107: NEG
64108: PUSH
64109: LD_INT 0
64111: PUSH
64112: EMPTY
64113: LIST
64114: LIST
64115: PUSH
64116: LD_INT 1
64118: NEG
64119: PUSH
64120: LD_INT 1
64122: NEG
64123: PUSH
64124: EMPTY
64125: LIST
64126: LIST
64127: PUSH
64128: LD_INT 1
64130: NEG
64131: PUSH
64132: LD_INT 2
64134: NEG
64135: PUSH
64136: EMPTY
64137: LIST
64138: LIST
64139: PUSH
64140: LD_INT 2
64142: PUSH
64143: LD_INT 1
64145: PUSH
64146: EMPTY
64147: LIST
64148: LIST
64149: PUSH
64150: LD_INT 2
64152: PUSH
64153: LD_INT 2
64155: PUSH
64156: EMPTY
64157: LIST
64158: LIST
64159: PUSH
64160: LD_INT 1
64162: PUSH
64163: LD_INT 2
64165: PUSH
64166: EMPTY
64167: LIST
64168: LIST
64169: PUSH
64170: LD_INT 2
64172: NEG
64173: PUSH
64174: LD_INT 1
64176: NEG
64177: PUSH
64178: EMPTY
64179: LIST
64180: LIST
64181: PUSH
64182: LD_INT 2
64184: NEG
64185: PUSH
64186: LD_INT 2
64188: NEG
64189: PUSH
64190: EMPTY
64191: LIST
64192: LIST
64193: PUSH
64194: LD_INT 3
64196: PUSH
64197: LD_INT 2
64199: PUSH
64200: EMPTY
64201: LIST
64202: LIST
64203: PUSH
64204: LD_INT 3
64206: PUSH
64207: LD_INT 3
64209: PUSH
64210: EMPTY
64211: LIST
64212: LIST
64213: PUSH
64214: LD_INT 2
64216: PUSH
64217: LD_INT 3
64219: PUSH
64220: EMPTY
64221: LIST
64222: LIST
64223: PUSH
64224: EMPTY
64225: LIST
64226: LIST
64227: LIST
64228: LIST
64229: LIST
64230: LIST
64231: LIST
64232: LIST
64233: LIST
64234: LIST
64235: LIST
64236: LIST
64237: LIST
64238: LIST
64239: LIST
64240: LIST
64241: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64242: LD_ADDR_VAR 0 17
64246: PUSH
64247: LD_INT 0
64249: PUSH
64250: LD_INT 0
64252: PUSH
64253: EMPTY
64254: LIST
64255: LIST
64256: PUSH
64257: LD_INT 0
64259: PUSH
64260: LD_INT 1
64262: NEG
64263: PUSH
64264: EMPTY
64265: LIST
64266: LIST
64267: PUSH
64268: LD_INT 1
64270: PUSH
64271: LD_INT 0
64273: PUSH
64274: EMPTY
64275: LIST
64276: LIST
64277: PUSH
64278: LD_INT 1
64280: PUSH
64281: LD_INT 1
64283: PUSH
64284: EMPTY
64285: LIST
64286: LIST
64287: PUSH
64288: LD_INT 0
64290: PUSH
64291: LD_INT 1
64293: PUSH
64294: EMPTY
64295: LIST
64296: LIST
64297: PUSH
64298: LD_INT 1
64300: NEG
64301: PUSH
64302: LD_INT 0
64304: PUSH
64305: EMPTY
64306: LIST
64307: LIST
64308: PUSH
64309: LD_INT 1
64311: NEG
64312: PUSH
64313: LD_INT 1
64315: NEG
64316: PUSH
64317: EMPTY
64318: LIST
64319: LIST
64320: PUSH
64321: LD_INT 1
64323: NEG
64324: PUSH
64325: LD_INT 2
64327: NEG
64328: PUSH
64329: EMPTY
64330: LIST
64331: LIST
64332: PUSH
64333: LD_INT 0
64335: PUSH
64336: LD_INT 2
64338: NEG
64339: PUSH
64340: EMPTY
64341: LIST
64342: LIST
64343: PUSH
64344: LD_INT 1
64346: PUSH
64347: LD_INT 1
64349: NEG
64350: PUSH
64351: EMPTY
64352: LIST
64353: LIST
64354: PUSH
64355: LD_INT 2
64357: PUSH
64358: LD_INT 0
64360: PUSH
64361: EMPTY
64362: LIST
64363: LIST
64364: PUSH
64365: LD_INT 2
64367: PUSH
64368: LD_INT 1
64370: PUSH
64371: EMPTY
64372: LIST
64373: LIST
64374: PUSH
64375: LD_INT 2
64377: PUSH
64378: LD_INT 2
64380: PUSH
64381: EMPTY
64382: LIST
64383: LIST
64384: PUSH
64385: LD_INT 1
64387: PUSH
64388: LD_INT 2
64390: PUSH
64391: EMPTY
64392: LIST
64393: LIST
64394: PUSH
64395: LD_INT 0
64397: PUSH
64398: LD_INT 2
64400: PUSH
64401: EMPTY
64402: LIST
64403: LIST
64404: PUSH
64405: LD_INT 1
64407: NEG
64408: PUSH
64409: LD_INT 1
64411: PUSH
64412: EMPTY
64413: LIST
64414: LIST
64415: PUSH
64416: LD_INT 2
64418: NEG
64419: PUSH
64420: LD_INT 0
64422: PUSH
64423: EMPTY
64424: LIST
64425: LIST
64426: PUSH
64427: LD_INT 2
64429: NEG
64430: PUSH
64431: LD_INT 1
64433: NEG
64434: PUSH
64435: EMPTY
64436: LIST
64437: LIST
64438: PUSH
64439: LD_INT 2
64441: NEG
64442: PUSH
64443: LD_INT 2
64445: NEG
64446: PUSH
64447: EMPTY
64448: LIST
64449: LIST
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: LIST
64455: LIST
64456: LIST
64457: LIST
64458: LIST
64459: LIST
64460: LIST
64461: LIST
64462: LIST
64463: LIST
64464: LIST
64465: LIST
64466: LIST
64467: LIST
64468: LIST
64469: LIST
64470: LIST
64471: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64472: LD_ADDR_VAR 0 18
64476: PUSH
64477: LD_INT 0
64479: PUSH
64480: LD_INT 0
64482: PUSH
64483: EMPTY
64484: LIST
64485: LIST
64486: PUSH
64487: LD_INT 0
64489: PUSH
64490: LD_INT 1
64492: NEG
64493: PUSH
64494: EMPTY
64495: LIST
64496: LIST
64497: PUSH
64498: LD_INT 1
64500: PUSH
64501: LD_INT 0
64503: PUSH
64504: EMPTY
64505: LIST
64506: LIST
64507: PUSH
64508: LD_INT 1
64510: PUSH
64511: LD_INT 1
64513: PUSH
64514: EMPTY
64515: LIST
64516: LIST
64517: PUSH
64518: LD_INT 0
64520: PUSH
64521: LD_INT 1
64523: PUSH
64524: EMPTY
64525: LIST
64526: LIST
64527: PUSH
64528: LD_INT 1
64530: NEG
64531: PUSH
64532: LD_INT 0
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: PUSH
64539: LD_INT 1
64541: NEG
64542: PUSH
64543: LD_INT 1
64545: NEG
64546: PUSH
64547: EMPTY
64548: LIST
64549: LIST
64550: PUSH
64551: LD_INT 1
64553: NEG
64554: PUSH
64555: LD_INT 2
64557: NEG
64558: PUSH
64559: EMPTY
64560: LIST
64561: LIST
64562: PUSH
64563: LD_INT 0
64565: PUSH
64566: LD_INT 2
64568: NEG
64569: PUSH
64570: EMPTY
64571: LIST
64572: LIST
64573: PUSH
64574: LD_INT 1
64576: PUSH
64577: LD_INT 1
64579: NEG
64580: PUSH
64581: EMPTY
64582: LIST
64583: LIST
64584: PUSH
64585: LD_INT 2
64587: PUSH
64588: LD_INT 0
64590: PUSH
64591: EMPTY
64592: LIST
64593: LIST
64594: PUSH
64595: LD_INT 2
64597: PUSH
64598: LD_INT 1
64600: PUSH
64601: EMPTY
64602: LIST
64603: LIST
64604: PUSH
64605: LD_INT 2
64607: PUSH
64608: LD_INT 2
64610: PUSH
64611: EMPTY
64612: LIST
64613: LIST
64614: PUSH
64615: LD_INT 1
64617: PUSH
64618: LD_INT 2
64620: PUSH
64621: EMPTY
64622: LIST
64623: LIST
64624: PUSH
64625: LD_INT 0
64627: PUSH
64628: LD_INT 2
64630: PUSH
64631: EMPTY
64632: LIST
64633: LIST
64634: PUSH
64635: LD_INT 1
64637: NEG
64638: PUSH
64639: LD_INT 1
64641: PUSH
64642: EMPTY
64643: LIST
64644: LIST
64645: PUSH
64646: LD_INT 2
64648: NEG
64649: PUSH
64650: LD_INT 0
64652: PUSH
64653: EMPTY
64654: LIST
64655: LIST
64656: PUSH
64657: LD_INT 2
64659: NEG
64660: PUSH
64661: LD_INT 1
64663: NEG
64664: PUSH
64665: EMPTY
64666: LIST
64667: LIST
64668: PUSH
64669: LD_INT 2
64671: NEG
64672: PUSH
64673: LD_INT 2
64675: NEG
64676: PUSH
64677: EMPTY
64678: LIST
64679: LIST
64680: PUSH
64681: EMPTY
64682: LIST
64683: LIST
64684: LIST
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: LIST
64701: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64702: LD_ADDR_VAR 0 19
64706: PUSH
64707: LD_INT 0
64709: PUSH
64710: LD_INT 0
64712: PUSH
64713: EMPTY
64714: LIST
64715: LIST
64716: PUSH
64717: LD_INT 0
64719: PUSH
64720: LD_INT 1
64722: NEG
64723: PUSH
64724: EMPTY
64725: LIST
64726: LIST
64727: PUSH
64728: LD_INT 1
64730: PUSH
64731: LD_INT 0
64733: PUSH
64734: EMPTY
64735: LIST
64736: LIST
64737: PUSH
64738: LD_INT 1
64740: PUSH
64741: LD_INT 1
64743: PUSH
64744: EMPTY
64745: LIST
64746: LIST
64747: PUSH
64748: LD_INT 0
64750: PUSH
64751: LD_INT 1
64753: PUSH
64754: EMPTY
64755: LIST
64756: LIST
64757: PUSH
64758: LD_INT 1
64760: NEG
64761: PUSH
64762: LD_INT 0
64764: PUSH
64765: EMPTY
64766: LIST
64767: LIST
64768: PUSH
64769: LD_INT 1
64771: NEG
64772: PUSH
64773: LD_INT 1
64775: NEG
64776: PUSH
64777: EMPTY
64778: LIST
64779: LIST
64780: PUSH
64781: LD_INT 1
64783: NEG
64784: PUSH
64785: LD_INT 2
64787: NEG
64788: PUSH
64789: EMPTY
64790: LIST
64791: LIST
64792: PUSH
64793: LD_INT 0
64795: PUSH
64796: LD_INT 2
64798: NEG
64799: PUSH
64800: EMPTY
64801: LIST
64802: LIST
64803: PUSH
64804: LD_INT 1
64806: PUSH
64807: LD_INT 1
64809: NEG
64810: PUSH
64811: EMPTY
64812: LIST
64813: LIST
64814: PUSH
64815: LD_INT 2
64817: PUSH
64818: LD_INT 0
64820: PUSH
64821: EMPTY
64822: LIST
64823: LIST
64824: PUSH
64825: LD_INT 2
64827: PUSH
64828: LD_INT 1
64830: PUSH
64831: EMPTY
64832: LIST
64833: LIST
64834: PUSH
64835: LD_INT 2
64837: PUSH
64838: LD_INT 2
64840: PUSH
64841: EMPTY
64842: LIST
64843: LIST
64844: PUSH
64845: LD_INT 1
64847: PUSH
64848: LD_INT 2
64850: PUSH
64851: EMPTY
64852: LIST
64853: LIST
64854: PUSH
64855: LD_INT 0
64857: PUSH
64858: LD_INT 2
64860: PUSH
64861: EMPTY
64862: LIST
64863: LIST
64864: PUSH
64865: LD_INT 1
64867: NEG
64868: PUSH
64869: LD_INT 1
64871: PUSH
64872: EMPTY
64873: LIST
64874: LIST
64875: PUSH
64876: LD_INT 2
64878: NEG
64879: PUSH
64880: LD_INT 0
64882: PUSH
64883: EMPTY
64884: LIST
64885: LIST
64886: PUSH
64887: LD_INT 2
64889: NEG
64890: PUSH
64891: LD_INT 1
64893: NEG
64894: PUSH
64895: EMPTY
64896: LIST
64897: LIST
64898: PUSH
64899: LD_INT 2
64901: NEG
64902: PUSH
64903: LD_INT 2
64905: NEG
64906: PUSH
64907: EMPTY
64908: LIST
64909: LIST
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: LIST
64915: LIST
64916: LIST
64917: LIST
64918: LIST
64919: LIST
64920: LIST
64921: LIST
64922: LIST
64923: LIST
64924: LIST
64925: LIST
64926: LIST
64927: LIST
64928: LIST
64929: LIST
64930: LIST
64931: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64932: LD_ADDR_VAR 0 20
64936: PUSH
64937: LD_INT 0
64939: PUSH
64940: LD_INT 0
64942: PUSH
64943: EMPTY
64944: LIST
64945: LIST
64946: PUSH
64947: LD_INT 0
64949: PUSH
64950: LD_INT 1
64952: NEG
64953: PUSH
64954: EMPTY
64955: LIST
64956: LIST
64957: PUSH
64958: LD_INT 1
64960: PUSH
64961: LD_INT 0
64963: PUSH
64964: EMPTY
64965: LIST
64966: LIST
64967: PUSH
64968: LD_INT 1
64970: PUSH
64971: LD_INT 1
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: PUSH
64978: LD_INT 0
64980: PUSH
64981: LD_INT 1
64983: PUSH
64984: EMPTY
64985: LIST
64986: LIST
64987: PUSH
64988: LD_INT 1
64990: NEG
64991: PUSH
64992: LD_INT 0
64994: PUSH
64995: EMPTY
64996: LIST
64997: LIST
64998: PUSH
64999: LD_INT 1
65001: NEG
65002: PUSH
65003: LD_INT 1
65005: NEG
65006: PUSH
65007: EMPTY
65008: LIST
65009: LIST
65010: PUSH
65011: LD_INT 1
65013: NEG
65014: PUSH
65015: LD_INT 2
65017: NEG
65018: PUSH
65019: EMPTY
65020: LIST
65021: LIST
65022: PUSH
65023: LD_INT 0
65025: PUSH
65026: LD_INT 2
65028: NEG
65029: PUSH
65030: EMPTY
65031: LIST
65032: LIST
65033: PUSH
65034: LD_INT 1
65036: PUSH
65037: LD_INT 1
65039: NEG
65040: PUSH
65041: EMPTY
65042: LIST
65043: LIST
65044: PUSH
65045: LD_INT 2
65047: PUSH
65048: LD_INT 0
65050: PUSH
65051: EMPTY
65052: LIST
65053: LIST
65054: PUSH
65055: LD_INT 2
65057: PUSH
65058: LD_INT 1
65060: PUSH
65061: EMPTY
65062: LIST
65063: LIST
65064: PUSH
65065: LD_INT 2
65067: PUSH
65068: LD_INT 2
65070: PUSH
65071: EMPTY
65072: LIST
65073: LIST
65074: PUSH
65075: LD_INT 1
65077: PUSH
65078: LD_INT 2
65080: PUSH
65081: EMPTY
65082: LIST
65083: LIST
65084: PUSH
65085: LD_INT 0
65087: PUSH
65088: LD_INT 2
65090: PUSH
65091: EMPTY
65092: LIST
65093: LIST
65094: PUSH
65095: LD_INT 1
65097: NEG
65098: PUSH
65099: LD_INT 1
65101: PUSH
65102: EMPTY
65103: LIST
65104: LIST
65105: PUSH
65106: LD_INT 2
65108: NEG
65109: PUSH
65110: LD_INT 0
65112: PUSH
65113: EMPTY
65114: LIST
65115: LIST
65116: PUSH
65117: LD_INT 2
65119: NEG
65120: PUSH
65121: LD_INT 1
65123: NEG
65124: PUSH
65125: EMPTY
65126: LIST
65127: LIST
65128: PUSH
65129: LD_INT 2
65131: NEG
65132: PUSH
65133: LD_INT 2
65135: NEG
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: LIST
65154: LIST
65155: LIST
65156: LIST
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65162: LD_ADDR_VAR 0 21
65166: PUSH
65167: LD_INT 0
65169: PUSH
65170: LD_INT 0
65172: PUSH
65173: EMPTY
65174: LIST
65175: LIST
65176: PUSH
65177: LD_INT 0
65179: PUSH
65180: LD_INT 1
65182: NEG
65183: PUSH
65184: EMPTY
65185: LIST
65186: LIST
65187: PUSH
65188: LD_INT 1
65190: PUSH
65191: LD_INT 0
65193: PUSH
65194: EMPTY
65195: LIST
65196: LIST
65197: PUSH
65198: LD_INT 1
65200: PUSH
65201: LD_INT 1
65203: PUSH
65204: EMPTY
65205: LIST
65206: LIST
65207: PUSH
65208: LD_INT 0
65210: PUSH
65211: LD_INT 1
65213: PUSH
65214: EMPTY
65215: LIST
65216: LIST
65217: PUSH
65218: LD_INT 1
65220: NEG
65221: PUSH
65222: LD_INT 0
65224: PUSH
65225: EMPTY
65226: LIST
65227: LIST
65228: PUSH
65229: LD_INT 1
65231: NEG
65232: PUSH
65233: LD_INT 1
65235: NEG
65236: PUSH
65237: EMPTY
65238: LIST
65239: LIST
65240: PUSH
65241: LD_INT 1
65243: NEG
65244: PUSH
65245: LD_INT 2
65247: NEG
65248: PUSH
65249: EMPTY
65250: LIST
65251: LIST
65252: PUSH
65253: LD_INT 0
65255: PUSH
65256: LD_INT 2
65258: NEG
65259: PUSH
65260: EMPTY
65261: LIST
65262: LIST
65263: PUSH
65264: LD_INT 1
65266: PUSH
65267: LD_INT 1
65269: NEG
65270: PUSH
65271: EMPTY
65272: LIST
65273: LIST
65274: PUSH
65275: LD_INT 2
65277: PUSH
65278: LD_INT 0
65280: PUSH
65281: EMPTY
65282: LIST
65283: LIST
65284: PUSH
65285: LD_INT 2
65287: PUSH
65288: LD_INT 1
65290: PUSH
65291: EMPTY
65292: LIST
65293: LIST
65294: PUSH
65295: LD_INT 2
65297: PUSH
65298: LD_INT 2
65300: PUSH
65301: EMPTY
65302: LIST
65303: LIST
65304: PUSH
65305: LD_INT 1
65307: PUSH
65308: LD_INT 2
65310: PUSH
65311: EMPTY
65312: LIST
65313: LIST
65314: PUSH
65315: LD_INT 0
65317: PUSH
65318: LD_INT 2
65320: PUSH
65321: EMPTY
65322: LIST
65323: LIST
65324: PUSH
65325: LD_INT 1
65327: NEG
65328: PUSH
65329: LD_INT 1
65331: PUSH
65332: EMPTY
65333: LIST
65334: LIST
65335: PUSH
65336: LD_INT 2
65338: NEG
65339: PUSH
65340: LD_INT 0
65342: PUSH
65343: EMPTY
65344: LIST
65345: LIST
65346: PUSH
65347: LD_INT 2
65349: NEG
65350: PUSH
65351: LD_INT 1
65353: NEG
65354: PUSH
65355: EMPTY
65356: LIST
65357: LIST
65358: PUSH
65359: LD_INT 2
65361: NEG
65362: PUSH
65363: LD_INT 2
65365: NEG
65366: PUSH
65367: EMPTY
65368: LIST
65369: LIST
65370: PUSH
65371: EMPTY
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65392: LD_ADDR_VAR 0 22
65396: PUSH
65397: LD_INT 0
65399: PUSH
65400: LD_INT 0
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: PUSH
65407: LD_INT 0
65409: PUSH
65410: LD_INT 1
65412: NEG
65413: PUSH
65414: EMPTY
65415: LIST
65416: LIST
65417: PUSH
65418: LD_INT 1
65420: PUSH
65421: LD_INT 0
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PUSH
65428: LD_INT 1
65430: PUSH
65431: LD_INT 1
65433: PUSH
65434: EMPTY
65435: LIST
65436: LIST
65437: PUSH
65438: LD_INT 0
65440: PUSH
65441: LD_INT 1
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PUSH
65448: LD_INT 1
65450: NEG
65451: PUSH
65452: LD_INT 0
65454: PUSH
65455: EMPTY
65456: LIST
65457: LIST
65458: PUSH
65459: LD_INT 1
65461: NEG
65462: PUSH
65463: LD_INT 1
65465: NEG
65466: PUSH
65467: EMPTY
65468: LIST
65469: LIST
65470: PUSH
65471: LD_INT 1
65473: NEG
65474: PUSH
65475: LD_INT 2
65477: NEG
65478: PUSH
65479: EMPTY
65480: LIST
65481: LIST
65482: PUSH
65483: LD_INT 0
65485: PUSH
65486: LD_INT 2
65488: NEG
65489: PUSH
65490: EMPTY
65491: LIST
65492: LIST
65493: PUSH
65494: LD_INT 1
65496: PUSH
65497: LD_INT 1
65499: NEG
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: PUSH
65505: LD_INT 2
65507: PUSH
65508: LD_INT 0
65510: PUSH
65511: EMPTY
65512: LIST
65513: LIST
65514: PUSH
65515: LD_INT 2
65517: PUSH
65518: LD_INT 1
65520: PUSH
65521: EMPTY
65522: LIST
65523: LIST
65524: PUSH
65525: LD_INT 2
65527: PUSH
65528: LD_INT 2
65530: PUSH
65531: EMPTY
65532: LIST
65533: LIST
65534: PUSH
65535: LD_INT 1
65537: PUSH
65538: LD_INT 2
65540: PUSH
65541: EMPTY
65542: LIST
65543: LIST
65544: PUSH
65545: LD_INT 0
65547: PUSH
65548: LD_INT 2
65550: PUSH
65551: EMPTY
65552: LIST
65553: LIST
65554: PUSH
65555: LD_INT 1
65557: NEG
65558: PUSH
65559: LD_INT 1
65561: PUSH
65562: EMPTY
65563: LIST
65564: LIST
65565: PUSH
65566: LD_INT 2
65568: NEG
65569: PUSH
65570: LD_INT 0
65572: PUSH
65573: EMPTY
65574: LIST
65575: LIST
65576: PUSH
65577: LD_INT 2
65579: NEG
65580: PUSH
65581: LD_INT 1
65583: NEG
65584: PUSH
65585: EMPTY
65586: LIST
65587: LIST
65588: PUSH
65589: LD_INT 2
65591: NEG
65592: PUSH
65593: LD_INT 2
65595: NEG
65596: PUSH
65597: EMPTY
65598: LIST
65599: LIST
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: LIST
65605: LIST
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: LIST
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65622: LD_ADDR_VAR 0 23
65626: PUSH
65627: LD_INT 0
65629: PUSH
65630: LD_INT 0
65632: PUSH
65633: EMPTY
65634: LIST
65635: LIST
65636: PUSH
65637: LD_INT 0
65639: PUSH
65640: LD_INT 1
65642: NEG
65643: PUSH
65644: EMPTY
65645: LIST
65646: LIST
65647: PUSH
65648: LD_INT 1
65650: PUSH
65651: LD_INT 0
65653: PUSH
65654: EMPTY
65655: LIST
65656: LIST
65657: PUSH
65658: LD_INT 1
65660: PUSH
65661: LD_INT 1
65663: PUSH
65664: EMPTY
65665: LIST
65666: LIST
65667: PUSH
65668: LD_INT 0
65670: PUSH
65671: LD_INT 1
65673: PUSH
65674: EMPTY
65675: LIST
65676: LIST
65677: PUSH
65678: LD_INT 1
65680: NEG
65681: PUSH
65682: LD_INT 0
65684: PUSH
65685: EMPTY
65686: LIST
65687: LIST
65688: PUSH
65689: LD_INT 1
65691: NEG
65692: PUSH
65693: LD_INT 1
65695: NEG
65696: PUSH
65697: EMPTY
65698: LIST
65699: LIST
65700: PUSH
65701: LD_INT 1
65703: NEG
65704: PUSH
65705: LD_INT 2
65707: NEG
65708: PUSH
65709: EMPTY
65710: LIST
65711: LIST
65712: PUSH
65713: LD_INT 0
65715: PUSH
65716: LD_INT 2
65718: NEG
65719: PUSH
65720: EMPTY
65721: LIST
65722: LIST
65723: PUSH
65724: LD_INT 1
65726: PUSH
65727: LD_INT 1
65729: NEG
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: PUSH
65735: LD_INT 2
65737: PUSH
65738: LD_INT 0
65740: PUSH
65741: EMPTY
65742: LIST
65743: LIST
65744: PUSH
65745: LD_INT 2
65747: PUSH
65748: LD_INT 1
65750: PUSH
65751: EMPTY
65752: LIST
65753: LIST
65754: PUSH
65755: LD_INT 2
65757: PUSH
65758: LD_INT 2
65760: PUSH
65761: EMPTY
65762: LIST
65763: LIST
65764: PUSH
65765: LD_INT 1
65767: PUSH
65768: LD_INT 2
65770: PUSH
65771: EMPTY
65772: LIST
65773: LIST
65774: PUSH
65775: LD_INT 0
65777: PUSH
65778: LD_INT 2
65780: PUSH
65781: EMPTY
65782: LIST
65783: LIST
65784: PUSH
65785: LD_INT 1
65787: NEG
65788: PUSH
65789: LD_INT 1
65791: PUSH
65792: EMPTY
65793: LIST
65794: LIST
65795: PUSH
65796: LD_INT 2
65798: NEG
65799: PUSH
65800: LD_INT 0
65802: PUSH
65803: EMPTY
65804: LIST
65805: LIST
65806: PUSH
65807: LD_INT 2
65809: NEG
65810: PUSH
65811: LD_INT 1
65813: NEG
65814: PUSH
65815: EMPTY
65816: LIST
65817: LIST
65818: PUSH
65819: LD_INT 2
65821: NEG
65822: PUSH
65823: LD_INT 2
65825: NEG
65826: PUSH
65827: EMPTY
65828: LIST
65829: LIST
65830: PUSH
65831: LD_INT 2
65833: NEG
65834: PUSH
65835: LD_INT 3
65837: NEG
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PUSH
65843: LD_INT 1
65845: NEG
65846: PUSH
65847: LD_INT 3
65849: NEG
65850: PUSH
65851: EMPTY
65852: LIST
65853: LIST
65854: PUSH
65855: LD_INT 1
65857: PUSH
65858: LD_INT 2
65860: NEG
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: PUSH
65866: LD_INT 2
65868: PUSH
65869: LD_INT 1
65871: NEG
65872: PUSH
65873: EMPTY
65874: LIST
65875: LIST
65876: PUSH
65877: EMPTY
65878: LIST
65879: LIST
65880: LIST
65881: LIST
65882: LIST
65883: LIST
65884: LIST
65885: LIST
65886: LIST
65887: LIST
65888: LIST
65889: LIST
65890: LIST
65891: LIST
65892: LIST
65893: LIST
65894: LIST
65895: LIST
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65902: LD_ADDR_VAR 0 24
65906: PUSH
65907: LD_INT 0
65909: PUSH
65910: LD_INT 0
65912: PUSH
65913: EMPTY
65914: LIST
65915: LIST
65916: PUSH
65917: LD_INT 0
65919: PUSH
65920: LD_INT 1
65922: NEG
65923: PUSH
65924: EMPTY
65925: LIST
65926: LIST
65927: PUSH
65928: LD_INT 1
65930: PUSH
65931: LD_INT 0
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PUSH
65938: LD_INT 1
65940: PUSH
65941: LD_INT 1
65943: PUSH
65944: EMPTY
65945: LIST
65946: LIST
65947: PUSH
65948: LD_INT 0
65950: PUSH
65951: LD_INT 1
65953: PUSH
65954: EMPTY
65955: LIST
65956: LIST
65957: PUSH
65958: LD_INT 1
65960: NEG
65961: PUSH
65962: LD_INT 0
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: PUSH
65969: LD_INT 1
65971: NEG
65972: PUSH
65973: LD_INT 1
65975: NEG
65976: PUSH
65977: EMPTY
65978: LIST
65979: LIST
65980: PUSH
65981: LD_INT 1
65983: NEG
65984: PUSH
65985: LD_INT 2
65987: NEG
65988: PUSH
65989: EMPTY
65990: LIST
65991: LIST
65992: PUSH
65993: LD_INT 0
65995: PUSH
65996: LD_INT 2
65998: NEG
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: LD_INT 1
66006: PUSH
66007: LD_INT 1
66009: NEG
66010: PUSH
66011: EMPTY
66012: LIST
66013: LIST
66014: PUSH
66015: LD_INT 2
66017: PUSH
66018: LD_INT 0
66020: PUSH
66021: EMPTY
66022: LIST
66023: LIST
66024: PUSH
66025: LD_INT 2
66027: PUSH
66028: LD_INT 1
66030: PUSH
66031: EMPTY
66032: LIST
66033: LIST
66034: PUSH
66035: LD_INT 2
66037: PUSH
66038: LD_INT 2
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: PUSH
66045: LD_INT 1
66047: PUSH
66048: LD_INT 2
66050: PUSH
66051: EMPTY
66052: LIST
66053: LIST
66054: PUSH
66055: LD_INT 0
66057: PUSH
66058: LD_INT 2
66060: PUSH
66061: EMPTY
66062: LIST
66063: LIST
66064: PUSH
66065: LD_INT 1
66067: NEG
66068: PUSH
66069: LD_INT 1
66071: PUSH
66072: EMPTY
66073: LIST
66074: LIST
66075: PUSH
66076: LD_INT 2
66078: NEG
66079: PUSH
66080: LD_INT 0
66082: PUSH
66083: EMPTY
66084: LIST
66085: LIST
66086: PUSH
66087: LD_INT 2
66089: NEG
66090: PUSH
66091: LD_INT 1
66093: NEG
66094: PUSH
66095: EMPTY
66096: LIST
66097: LIST
66098: PUSH
66099: LD_INT 2
66101: NEG
66102: PUSH
66103: LD_INT 2
66105: NEG
66106: PUSH
66107: EMPTY
66108: LIST
66109: LIST
66110: PUSH
66111: LD_INT 1
66113: PUSH
66114: LD_INT 2
66116: NEG
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: PUSH
66122: LD_INT 2
66124: PUSH
66125: LD_INT 1
66127: NEG
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PUSH
66133: LD_INT 3
66135: PUSH
66136: LD_INT 1
66138: PUSH
66139: EMPTY
66140: LIST
66141: LIST
66142: PUSH
66143: LD_INT 3
66145: PUSH
66146: LD_INT 2
66148: PUSH
66149: EMPTY
66150: LIST
66151: LIST
66152: PUSH
66153: EMPTY
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66178: LD_ADDR_VAR 0 25
66182: PUSH
66183: LD_INT 0
66185: PUSH
66186: LD_INT 0
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: PUSH
66193: LD_INT 0
66195: PUSH
66196: LD_INT 1
66198: NEG
66199: PUSH
66200: EMPTY
66201: LIST
66202: LIST
66203: PUSH
66204: LD_INT 1
66206: PUSH
66207: LD_INT 0
66209: PUSH
66210: EMPTY
66211: LIST
66212: LIST
66213: PUSH
66214: LD_INT 1
66216: PUSH
66217: LD_INT 1
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: PUSH
66224: LD_INT 0
66226: PUSH
66227: LD_INT 1
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: LD_INT 1
66236: NEG
66237: PUSH
66238: LD_INT 0
66240: PUSH
66241: EMPTY
66242: LIST
66243: LIST
66244: PUSH
66245: LD_INT 1
66247: NEG
66248: PUSH
66249: LD_INT 1
66251: NEG
66252: PUSH
66253: EMPTY
66254: LIST
66255: LIST
66256: PUSH
66257: LD_INT 1
66259: NEG
66260: PUSH
66261: LD_INT 2
66263: NEG
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: PUSH
66269: LD_INT 0
66271: PUSH
66272: LD_INT 2
66274: NEG
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: LD_INT 1
66282: PUSH
66283: LD_INT 1
66285: NEG
66286: PUSH
66287: EMPTY
66288: LIST
66289: LIST
66290: PUSH
66291: LD_INT 2
66293: PUSH
66294: LD_INT 0
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: PUSH
66301: LD_INT 2
66303: PUSH
66304: LD_INT 1
66306: PUSH
66307: EMPTY
66308: LIST
66309: LIST
66310: PUSH
66311: LD_INT 2
66313: PUSH
66314: LD_INT 2
66316: PUSH
66317: EMPTY
66318: LIST
66319: LIST
66320: PUSH
66321: LD_INT 1
66323: PUSH
66324: LD_INT 2
66326: PUSH
66327: EMPTY
66328: LIST
66329: LIST
66330: PUSH
66331: LD_INT 0
66333: PUSH
66334: LD_INT 2
66336: PUSH
66337: EMPTY
66338: LIST
66339: LIST
66340: PUSH
66341: LD_INT 1
66343: NEG
66344: PUSH
66345: LD_INT 1
66347: PUSH
66348: EMPTY
66349: LIST
66350: LIST
66351: PUSH
66352: LD_INT 2
66354: NEG
66355: PUSH
66356: LD_INT 0
66358: PUSH
66359: EMPTY
66360: LIST
66361: LIST
66362: PUSH
66363: LD_INT 2
66365: NEG
66366: PUSH
66367: LD_INT 1
66369: NEG
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: PUSH
66375: LD_INT 2
66377: NEG
66378: PUSH
66379: LD_INT 2
66381: NEG
66382: PUSH
66383: EMPTY
66384: LIST
66385: LIST
66386: PUSH
66387: LD_INT 3
66389: PUSH
66390: LD_INT 1
66392: PUSH
66393: EMPTY
66394: LIST
66395: LIST
66396: PUSH
66397: LD_INT 3
66399: PUSH
66400: LD_INT 2
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PUSH
66407: LD_INT 2
66409: PUSH
66410: LD_INT 3
66412: PUSH
66413: EMPTY
66414: LIST
66415: LIST
66416: PUSH
66417: LD_INT 1
66419: PUSH
66420: LD_INT 3
66422: PUSH
66423: EMPTY
66424: LIST
66425: LIST
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: LIST
66431: LIST
66432: LIST
66433: LIST
66434: LIST
66435: LIST
66436: LIST
66437: LIST
66438: LIST
66439: LIST
66440: LIST
66441: LIST
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66452: LD_ADDR_VAR 0 26
66456: PUSH
66457: LD_INT 0
66459: PUSH
66460: LD_INT 0
66462: PUSH
66463: EMPTY
66464: LIST
66465: LIST
66466: PUSH
66467: LD_INT 0
66469: PUSH
66470: LD_INT 1
66472: NEG
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 1
66480: PUSH
66481: LD_INT 0
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: LD_INT 1
66490: PUSH
66491: LD_INT 1
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: PUSH
66498: LD_INT 0
66500: PUSH
66501: LD_INT 1
66503: PUSH
66504: EMPTY
66505: LIST
66506: LIST
66507: PUSH
66508: LD_INT 1
66510: NEG
66511: PUSH
66512: LD_INT 0
66514: PUSH
66515: EMPTY
66516: LIST
66517: LIST
66518: PUSH
66519: LD_INT 1
66521: NEG
66522: PUSH
66523: LD_INT 1
66525: NEG
66526: PUSH
66527: EMPTY
66528: LIST
66529: LIST
66530: PUSH
66531: LD_INT 1
66533: NEG
66534: PUSH
66535: LD_INT 2
66537: NEG
66538: PUSH
66539: EMPTY
66540: LIST
66541: LIST
66542: PUSH
66543: LD_INT 0
66545: PUSH
66546: LD_INT 2
66548: NEG
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PUSH
66554: LD_INT 1
66556: PUSH
66557: LD_INT 1
66559: NEG
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 2
66567: PUSH
66568: LD_INT 0
66570: PUSH
66571: EMPTY
66572: LIST
66573: LIST
66574: PUSH
66575: LD_INT 2
66577: PUSH
66578: LD_INT 1
66580: PUSH
66581: EMPTY
66582: LIST
66583: LIST
66584: PUSH
66585: LD_INT 2
66587: PUSH
66588: LD_INT 2
66590: PUSH
66591: EMPTY
66592: LIST
66593: LIST
66594: PUSH
66595: LD_INT 1
66597: PUSH
66598: LD_INT 2
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: PUSH
66605: LD_INT 0
66607: PUSH
66608: LD_INT 2
66610: PUSH
66611: EMPTY
66612: LIST
66613: LIST
66614: PUSH
66615: LD_INT 1
66617: NEG
66618: PUSH
66619: LD_INT 1
66621: PUSH
66622: EMPTY
66623: LIST
66624: LIST
66625: PUSH
66626: LD_INT 2
66628: NEG
66629: PUSH
66630: LD_INT 0
66632: PUSH
66633: EMPTY
66634: LIST
66635: LIST
66636: PUSH
66637: LD_INT 2
66639: NEG
66640: PUSH
66641: LD_INT 1
66643: NEG
66644: PUSH
66645: EMPTY
66646: LIST
66647: LIST
66648: PUSH
66649: LD_INT 2
66651: NEG
66652: PUSH
66653: LD_INT 2
66655: NEG
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: PUSH
66661: LD_INT 2
66663: PUSH
66664: LD_INT 3
66666: PUSH
66667: EMPTY
66668: LIST
66669: LIST
66670: PUSH
66671: LD_INT 1
66673: PUSH
66674: LD_INT 3
66676: PUSH
66677: EMPTY
66678: LIST
66679: LIST
66680: PUSH
66681: LD_INT 1
66683: NEG
66684: PUSH
66685: LD_INT 2
66687: PUSH
66688: EMPTY
66689: LIST
66690: LIST
66691: PUSH
66692: LD_INT 2
66694: NEG
66695: PUSH
66696: LD_INT 1
66698: PUSH
66699: EMPTY
66700: LIST
66701: LIST
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: LIST
66707: LIST
66708: LIST
66709: LIST
66710: LIST
66711: LIST
66712: LIST
66713: LIST
66714: LIST
66715: LIST
66716: LIST
66717: LIST
66718: LIST
66719: LIST
66720: LIST
66721: LIST
66722: LIST
66723: LIST
66724: LIST
66725: LIST
66726: LIST
66727: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66728: LD_ADDR_VAR 0 27
66732: PUSH
66733: LD_INT 0
66735: PUSH
66736: LD_INT 0
66738: PUSH
66739: EMPTY
66740: LIST
66741: LIST
66742: PUSH
66743: LD_INT 0
66745: PUSH
66746: LD_INT 1
66748: NEG
66749: PUSH
66750: EMPTY
66751: LIST
66752: LIST
66753: PUSH
66754: LD_INT 1
66756: PUSH
66757: LD_INT 0
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: PUSH
66764: LD_INT 1
66766: PUSH
66767: LD_INT 1
66769: PUSH
66770: EMPTY
66771: LIST
66772: LIST
66773: PUSH
66774: LD_INT 0
66776: PUSH
66777: LD_INT 1
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PUSH
66784: LD_INT 1
66786: NEG
66787: PUSH
66788: LD_INT 0
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: PUSH
66795: LD_INT 1
66797: NEG
66798: PUSH
66799: LD_INT 1
66801: NEG
66802: PUSH
66803: EMPTY
66804: LIST
66805: LIST
66806: PUSH
66807: LD_INT 1
66809: NEG
66810: PUSH
66811: LD_INT 2
66813: NEG
66814: PUSH
66815: EMPTY
66816: LIST
66817: LIST
66818: PUSH
66819: LD_INT 0
66821: PUSH
66822: LD_INT 2
66824: NEG
66825: PUSH
66826: EMPTY
66827: LIST
66828: LIST
66829: PUSH
66830: LD_INT 1
66832: PUSH
66833: LD_INT 1
66835: NEG
66836: PUSH
66837: EMPTY
66838: LIST
66839: LIST
66840: PUSH
66841: LD_INT 2
66843: PUSH
66844: LD_INT 0
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PUSH
66851: LD_INT 2
66853: PUSH
66854: LD_INT 1
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: PUSH
66861: LD_INT 2
66863: PUSH
66864: LD_INT 2
66866: PUSH
66867: EMPTY
66868: LIST
66869: LIST
66870: PUSH
66871: LD_INT 1
66873: PUSH
66874: LD_INT 2
66876: PUSH
66877: EMPTY
66878: LIST
66879: LIST
66880: PUSH
66881: LD_INT 0
66883: PUSH
66884: LD_INT 2
66886: PUSH
66887: EMPTY
66888: LIST
66889: LIST
66890: PUSH
66891: LD_INT 1
66893: NEG
66894: PUSH
66895: LD_INT 1
66897: PUSH
66898: EMPTY
66899: LIST
66900: LIST
66901: PUSH
66902: LD_INT 2
66904: NEG
66905: PUSH
66906: LD_INT 0
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PUSH
66913: LD_INT 2
66915: NEG
66916: PUSH
66917: LD_INT 1
66919: NEG
66920: PUSH
66921: EMPTY
66922: LIST
66923: LIST
66924: PUSH
66925: LD_INT 2
66927: NEG
66928: PUSH
66929: LD_INT 2
66931: NEG
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PUSH
66937: LD_INT 1
66939: NEG
66940: PUSH
66941: LD_INT 2
66943: PUSH
66944: EMPTY
66945: LIST
66946: LIST
66947: PUSH
66948: LD_INT 2
66950: NEG
66951: PUSH
66952: LD_INT 1
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: PUSH
66959: LD_INT 3
66961: NEG
66962: PUSH
66963: LD_INT 1
66965: NEG
66966: PUSH
66967: EMPTY
66968: LIST
66969: LIST
66970: PUSH
66971: LD_INT 3
66973: NEG
66974: PUSH
66975: LD_INT 2
66977: NEG
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: EMPTY
66984: LIST
66985: LIST
66986: LIST
66987: LIST
66988: LIST
66989: LIST
66990: LIST
66991: LIST
66992: LIST
66993: LIST
66994: LIST
66995: LIST
66996: LIST
66997: LIST
66998: LIST
66999: LIST
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67008: LD_ADDR_VAR 0 28
67012: PUSH
67013: LD_INT 0
67015: PUSH
67016: LD_INT 0
67018: PUSH
67019: EMPTY
67020: LIST
67021: LIST
67022: PUSH
67023: LD_INT 0
67025: PUSH
67026: LD_INT 1
67028: NEG
67029: PUSH
67030: EMPTY
67031: LIST
67032: LIST
67033: PUSH
67034: LD_INT 1
67036: PUSH
67037: LD_INT 0
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: PUSH
67044: LD_INT 1
67046: PUSH
67047: LD_INT 1
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: PUSH
67054: LD_INT 0
67056: PUSH
67057: LD_INT 1
67059: PUSH
67060: EMPTY
67061: LIST
67062: LIST
67063: PUSH
67064: LD_INT 1
67066: NEG
67067: PUSH
67068: LD_INT 0
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: PUSH
67075: LD_INT 1
67077: NEG
67078: PUSH
67079: LD_INT 1
67081: NEG
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: LD_INT 1
67089: NEG
67090: PUSH
67091: LD_INT 2
67093: NEG
67094: PUSH
67095: EMPTY
67096: LIST
67097: LIST
67098: PUSH
67099: LD_INT 0
67101: PUSH
67102: LD_INT 2
67104: NEG
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 1
67112: PUSH
67113: LD_INT 1
67115: NEG
67116: PUSH
67117: EMPTY
67118: LIST
67119: LIST
67120: PUSH
67121: LD_INT 2
67123: PUSH
67124: LD_INT 0
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: PUSH
67131: LD_INT 2
67133: PUSH
67134: LD_INT 1
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: LD_INT 2
67143: PUSH
67144: LD_INT 2
67146: PUSH
67147: EMPTY
67148: LIST
67149: LIST
67150: PUSH
67151: LD_INT 1
67153: PUSH
67154: LD_INT 2
67156: PUSH
67157: EMPTY
67158: LIST
67159: LIST
67160: PUSH
67161: LD_INT 0
67163: PUSH
67164: LD_INT 2
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: PUSH
67171: LD_INT 1
67173: NEG
67174: PUSH
67175: LD_INT 1
67177: PUSH
67178: EMPTY
67179: LIST
67180: LIST
67181: PUSH
67182: LD_INT 2
67184: NEG
67185: PUSH
67186: LD_INT 0
67188: PUSH
67189: EMPTY
67190: LIST
67191: LIST
67192: PUSH
67193: LD_INT 2
67195: NEG
67196: PUSH
67197: LD_INT 1
67199: NEG
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 2
67207: NEG
67208: PUSH
67209: LD_INT 2
67211: NEG
67212: PUSH
67213: EMPTY
67214: LIST
67215: LIST
67216: PUSH
67217: LD_INT 2
67219: NEG
67220: PUSH
67221: LD_INT 3
67223: NEG
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: PUSH
67229: LD_INT 1
67231: NEG
67232: PUSH
67233: LD_INT 3
67235: NEG
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: PUSH
67241: LD_INT 3
67243: NEG
67244: PUSH
67245: LD_INT 1
67247: NEG
67248: PUSH
67249: EMPTY
67250: LIST
67251: LIST
67252: PUSH
67253: LD_INT 3
67255: NEG
67256: PUSH
67257: LD_INT 2
67259: NEG
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: LIST
67269: LIST
67270: LIST
67271: LIST
67272: LIST
67273: LIST
67274: LIST
67275: LIST
67276: LIST
67277: LIST
67278: LIST
67279: LIST
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67290: LD_ADDR_VAR 0 29
67294: PUSH
67295: LD_INT 0
67297: PUSH
67298: LD_INT 0
67300: PUSH
67301: EMPTY
67302: LIST
67303: LIST
67304: PUSH
67305: LD_INT 0
67307: PUSH
67308: LD_INT 1
67310: NEG
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 1
67318: PUSH
67319: LD_INT 0
67321: PUSH
67322: EMPTY
67323: LIST
67324: LIST
67325: PUSH
67326: LD_INT 1
67328: PUSH
67329: LD_INT 1
67331: PUSH
67332: EMPTY
67333: LIST
67334: LIST
67335: PUSH
67336: LD_INT 0
67338: PUSH
67339: LD_INT 1
67341: PUSH
67342: EMPTY
67343: LIST
67344: LIST
67345: PUSH
67346: LD_INT 1
67348: NEG
67349: PUSH
67350: LD_INT 0
67352: PUSH
67353: EMPTY
67354: LIST
67355: LIST
67356: PUSH
67357: LD_INT 1
67359: NEG
67360: PUSH
67361: LD_INT 1
67363: NEG
67364: PUSH
67365: EMPTY
67366: LIST
67367: LIST
67368: PUSH
67369: LD_INT 1
67371: NEG
67372: PUSH
67373: LD_INT 2
67375: NEG
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: PUSH
67381: LD_INT 0
67383: PUSH
67384: LD_INT 2
67386: NEG
67387: PUSH
67388: EMPTY
67389: LIST
67390: LIST
67391: PUSH
67392: LD_INT 1
67394: PUSH
67395: LD_INT 1
67397: NEG
67398: PUSH
67399: EMPTY
67400: LIST
67401: LIST
67402: PUSH
67403: LD_INT 2
67405: PUSH
67406: LD_INT 0
67408: PUSH
67409: EMPTY
67410: LIST
67411: LIST
67412: PUSH
67413: LD_INT 2
67415: PUSH
67416: LD_INT 1
67418: PUSH
67419: EMPTY
67420: LIST
67421: LIST
67422: PUSH
67423: LD_INT 1
67425: PUSH
67426: LD_INT 2
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: PUSH
67433: LD_INT 0
67435: PUSH
67436: LD_INT 2
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PUSH
67443: LD_INT 1
67445: NEG
67446: PUSH
67447: LD_INT 1
67449: PUSH
67450: EMPTY
67451: LIST
67452: LIST
67453: PUSH
67454: LD_INT 2
67456: NEG
67457: PUSH
67458: LD_INT 1
67460: NEG
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: PUSH
67466: LD_INT 2
67468: NEG
67469: PUSH
67470: LD_INT 2
67472: NEG
67473: PUSH
67474: EMPTY
67475: LIST
67476: LIST
67477: PUSH
67478: LD_INT 2
67480: NEG
67481: PUSH
67482: LD_INT 3
67484: NEG
67485: PUSH
67486: EMPTY
67487: LIST
67488: LIST
67489: PUSH
67490: LD_INT 2
67492: PUSH
67493: LD_INT 1
67495: NEG
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: PUSH
67501: LD_INT 3
67503: PUSH
67504: LD_INT 1
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: LD_INT 1
67513: PUSH
67514: LD_INT 3
67516: PUSH
67517: EMPTY
67518: LIST
67519: LIST
67520: PUSH
67521: LD_INT 1
67523: NEG
67524: PUSH
67525: LD_INT 2
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: PUSH
67532: LD_INT 3
67534: NEG
67535: PUSH
67536: LD_INT 2
67538: NEG
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: LIST
67548: LIST
67549: LIST
67550: LIST
67551: LIST
67552: LIST
67553: LIST
67554: LIST
67555: LIST
67556: LIST
67557: LIST
67558: LIST
67559: LIST
67560: LIST
67561: LIST
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: LIST
67567: LIST
67568: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67569: LD_ADDR_VAR 0 30
67573: PUSH
67574: LD_INT 0
67576: PUSH
67577: LD_INT 0
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: LD_INT 0
67586: PUSH
67587: LD_INT 1
67589: NEG
67590: PUSH
67591: EMPTY
67592: LIST
67593: LIST
67594: PUSH
67595: LD_INT 1
67597: PUSH
67598: LD_INT 0
67600: PUSH
67601: EMPTY
67602: LIST
67603: LIST
67604: PUSH
67605: LD_INT 1
67607: PUSH
67608: LD_INT 1
67610: PUSH
67611: EMPTY
67612: LIST
67613: LIST
67614: PUSH
67615: LD_INT 0
67617: PUSH
67618: LD_INT 1
67620: PUSH
67621: EMPTY
67622: LIST
67623: LIST
67624: PUSH
67625: LD_INT 1
67627: NEG
67628: PUSH
67629: LD_INT 0
67631: PUSH
67632: EMPTY
67633: LIST
67634: LIST
67635: PUSH
67636: LD_INT 1
67638: NEG
67639: PUSH
67640: LD_INT 1
67642: NEG
67643: PUSH
67644: EMPTY
67645: LIST
67646: LIST
67647: PUSH
67648: LD_INT 1
67650: NEG
67651: PUSH
67652: LD_INT 2
67654: NEG
67655: PUSH
67656: EMPTY
67657: LIST
67658: LIST
67659: PUSH
67660: LD_INT 0
67662: PUSH
67663: LD_INT 2
67665: NEG
67666: PUSH
67667: EMPTY
67668: LIST
67669: LIST
67670: PUSH
67671: LD_INT 1
67673: PUSH
67674: LD_INT 1
67676: NEG
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 2
67684: PUSH
67685: LD_INT 0
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: LD_INT 2
67694: PUSH
67695: LD_INT 1
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: PUSH
67702: LD_INT 2
67704: PUSH
67705: LD_INT 2
67707: PUSH
67708: EMPTY
67709: LIST
67710: LIST
67711: PUSH
67712: LD_INT 1
67714: PUSH
67715: LD_INT 2
67717: PUSH
67718: EMPTY
67719: LIST
67720: LIST
67721: PUSH
67722: LD_INT 1
67724: NEG
67725: PUSH
67726: LD_INT 1
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: PUSH
67733: LD_INT 2
67735: NEG
67736: PUSH
67737: LD_INT 0
67739: PUSH
67740: EMPTY
67741: LIST
67742: LIST
67743: PUSH
67744: LD_INT 2
67746: NEG
67747: PUSH
67748: LD_INT 1
67750: NEG
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: PUSH
67756: LD_INT 1
67758: NEG
67759: PUSH
67760: LD_INT 3
67762: NEG
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: PUSH
67768: LD_INT 1
67770: PUSH
67771: LD_INT 2
67773: NEG
67774: PUSH
67775: EMPTY
67776: LIST
67777: LIST
67778: PUSH
67779: LD_INT 3
67781: PUSH
67782: LD_INT 2
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: PUSH
67789: LD_INT 2
67791: PUSH
67792: LD_INT 3
67794: PUSH
67795: EMPTY
67796: LIST
67797: LIST
67798: PUSH
67799: LD_INT 2
67801: NEG
67802: PUSH
67803: LD_INT 1
67805: PUSH
67806: EMPTY
67807: LIST
67808: LIST
67809: PUSH
67810: LD_INT 3
67812: NEG
67813: PUSH
67814: LD_INT 1
67816: NEG
67817: PUSH
67818: EMPTY
67819: LIST
67820: LIST
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: LIST
67826: LIST
67827: LIST
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67847: LD_ADDR_VAR 0 31
67851: PUSH
67852: LD_INT 0
67854: PUSH
67855: LD_INT 0
67857: PUSH
67858: EMPTY
67859: LIST
67860: LIST
67861: PUSH
67862: LD_INT 0
67864: PUSH
67865: LD_INT 1
67867: NEG
67868: PUSH
67869: EMPTY
67870: LIST
67871: LIST
67872: PUSH
67873: LD_INT 1
67875: PUSH
67876: LD_INT 0
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: PUSH
67883: LD_INT 1
67885: PUSH
67886: LD_INT 1
67888: PUSH
67889: EMPTY
67890: LIST
67891: LIST
67892: PUSH
67893: LD_INT 0
67895: PUSH
67896: LD_INT 1
67898: PUSH
67899: EMPTY
67900: LIST
67901: LIST
67902: PUSH
67903: LD_INT 1
67905: NEG
67906: PUSH
67907: LD_INT 0
67909: PUSH
67910: EMPTY
67911: LIST
67912: LIST
67913: PUSH
67914: LD_INT 1
67916: NEG
67917: PUSH
67918: LD_INT 1
67920: NEG
67921: PUSH
67922: EMPTY
67923: LIST
67924: LIST
67925: PUSH
67926: LD_INT 1
67928: NEG
67929: PUSH
67930: LD_INT 2
67932: NEG
67933: PUSH
67934: EMPTY
67935: LIST
67936: LIST
67937: PUSH
67938: LD_INT 1
67940: PUSH
67941: LD_INT 1
67943: NEG
67944: PUSH
67945: EMPTY
67946: LIST
67947: LIST
67948: PUSH
67949: LD_INT 2
67951: PUSH
67952: LD_INT 0
67954: PUSH
67955: EMPTY
67956: LIST
67957: LIST
67958: PUSH
67959: LD_INT 2
67961: PUSH
67962: LD_INT 1
67964: PUSH
67965: EMPTY
67966: LIST
67967: LIST
67968: PUSH
67969: LD_INT 2
67971: PUSH
67972: LD_INT 2
67974: PUSH
67975: EMPTY
67976: LIST
67977: LIST
67978: PUSH
67979: LD_INT 1
67981: PUSH
67982: LD_INT 2
67984: PUSH
67985: EMPTY
67986: LIST
67987: LIST
67988: PUSH
67989: LD_INT 0
67991: PUSH
67992: LD_INT 2
67994: PUSH
67995: EMPTY
67996: LIST
67997: LIST
67998: PUSH
67999: LD_INT 1
68001: NEG
68002: PUSH
68003: LD_INT 1
68005: PUSH
68006: EMPTY
68007: LIST
68008: LIST
68009: PUSH
68010: LD_INT 2
68012: NEG
68013: PUSH
68014: LD_INT 1
68016: NEG
68017: PUSH
68018: EMPTY
68019: LIST
68020: LIST
68021: PUSH
68022: LD_INT 2
68024: NEG
68025: PUSH
68026: LD_INT 2
68028: NEG
68029: PUSH
68030: EMPTY
68031: LIST
68032: LIST
68033: PUSH
68034: LD_INT 2
68036: NEG
68037: PUSH
68038: LD_INT 3
68040: NEG
68041: PUSH
68042: EMPTY
68043: LIST
68044: LIST
68045: PUSH
68046: LD_INT 2
68048: PUSH
68049: LD_INT 1
68051: NEG
68052: PUSH
68053: EMPTY
68054: LIST
68055: LIST
68056: PUSH
68057: LD_INT 3
68059: PUSH
68060: LD_INT 1
68062: PUSH
68063: EMPTY
68064: LIST
68065: LIST
68066: PUSH
68067: LD_INT 1
68069: PUSH
68070: LD_INT 3
68072: PUSH
68073: EMPTY
68074: LIST
68075: LIST
68076: PUSH
68077: LD_INT 1
68079: NEG
68080: PUSH
68081: LD_INT 2
68083: PUSH
68084: EMPTY
68085: LIST
68086: LIST
68087: PUSH
68088: LD_INT 3
68090: NEG
68091: PUSH
68092: LD_INT 2
68094: NEG
68095: PUSH
68096: EMPTY
68097: LIST
68098: LIST
68099: PUSH
68100: EMPTY
68101: LIST
68102: LIST
68103: LIST
68104: LIST
68105: LIST
68106: LIST
68107: LIST
68108: LIST
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: LIST
68115: LIST
68116: LIST
68117: LIST
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68125: LD_ADDR_VAR 0 32
68129: PUSH
68130: LD_INT 0
68132: PUSH
68133: LD_INT 0
68135: PUSH
68136: EMPTY
68137: LIST
68138: LIST
68139: PUSH
68140: LD_INT 0
68142: PUSH
68143: LD_INT 1
68145: NEG
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: PUSH
68151: LD_INT 1
68153: PUSH
68154: LD_INT 0
68156: PUSH
68157: EMPTY
68158: LIST
68159: LIST
68160: PUSH
68161: LD_INT 1
68163: PUSH
68164: LD_INT 1
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: PUSH
68171: LD_INT 0
68173: PUSH
68174: LD_INT 1
68176: PUSH
68177: EMPTY
68178: LIST
68179: LIST
68180: PUSH
68181: LD_INT 1
68183: NEG
68184: PUSH
68185: LD_INT 0
68187: PUSH
68188: EMPTY
68189: LIST
68190: LIST
68191: PUSH
68192: LD_INT 1
68194: NEG
68195: PUSH
68196: LD_INT 1
68198: NEG
68199: PUSH
68200: EMPTY
68201: LIST
68202: LIST
68203: PUSH
68204: LD_INT 1
68206: NEG
68207: PUSH
68208: LD_INT 2
68210: NEG
68211: PUSH
68212: EMPTY
68213: LIST
68214: LIST
68215: PUSH
68216: LD_INT 0
68218: PUSH
68219: LD_INT 2
68221: NEG
68222: PUSH
68223: EMPTY
68224: LIST
68225: LIST
68226: PUSH
68227: LD_INT 1
68229: PUSH
68230: LD_INT 1
68232: NEG
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: PUSH
68238: LD_INT 2
68240: PUSH
68241: LD_INT 1
68243: PUSH
68244: EMPTY
68245: LIST
68246: LIST
68247: PUSH
68248: LD_INT 2
68250: PUSH
68251: LD_INT 2
68253: PUSH
68254: EMPTY
68255: LIST
68256: LIST
68257: PUSH
68258: LD_INT 1
68260: PUSH
68261: LD_INT 2
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PUSH
68268: LD_INT 0
68270: PUSH
68271: LD_INT 2
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: LD_INT 1
68280: NEG
68281: PUSH
68282: LD_INT 1
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: PUSH
68289: LD_INT 2
68291: NEG
68292: PUSH
68293: LD_INT 0
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: LD_INT 2
68302: NEG
68303: PUSH
68304: LD_INT 1
68306: NEG
68307: PUSH
68308: EMPTY
68309: LIST
68310: LIST
68311: PUSH
68312: LD_INT 1
68314: NEG
68315: PUSH
68316: LD_INT 3
68318: NEG
68319: PUSH
68320: EMPTY
68321: LIST
68322: LIST
68323: PUSH
68324: LD_INT 1
68326: PUSH
68327: LD_INT 2
68329: NEG
68330: PUSH
68331: EMPTY
68332: LIST
68333: LIST
68334: PUSH
68335: LD_INT 3
68337: PUSH
68338: LD_INT 2
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: PUSH
68345: LD_INT 2
68347: PUSH
68348: LD_INT 3
68350: PUSH
68351: EMPTY
68352: LIST
68353: LIST
68354: PUSH
68355: LD_INT 2
68357: NEG
68358: PUSH
68359: LD_INT 1
68361: PUSH
68362: EMPTY
68363: LIST
68364: LIST
68365: PUSH
68366: LD_INT 3
68368: NEG
68369: PUSH
68370: LD_INT 1
68372: NEG
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: LIST
68382: LIST
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: LIST
68394: LIST
68395: LIST
68396: LIST
68397: LIST
68398: LIST
68399: LIST
68400: LIST
68401: LIST
68402: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68403: LD_ADDR_VAR 0 33
68407: PUSH
68408: LD_INT 0
68410: PUSH
68411: LD_INT 0
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: PUSH
68418: LD_INT 0
68420: PUSH
68421: LD_INT 1
68423: NEG
68424: PUSH
68425: EMPTY
68426: LIST
68427: LIST
68428: PUSH
68429: LD_INT 1
68431: PUSH
68432: LD_INT 0
68434: PUSH
68435: EMPTY
68436: LIST
68437: LIST
68438: PUSH
68439: LD_INT 1
68441: PUSH
68442: LD_INT 1
68444: PUSH
68445: EMPTY
68446: LIST
68447: LIST
68448: PUSH
68449: LD_INT 0
68451: PUSH
68452: LD_INT 1
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PUSH
68459: LD_INT 1
68461: NEG
68462: PUSH
68463: LD_INT 0
68465: PUSH
68466: EMPTY
68467: LIST
68468: LIST
68469: PUSH
68470: LD_INT 1
68472: NEG
68473: PUSH
68474: LD_INT 1
68476: NEG
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 1
68484: NEG
68485: PUSH
68486: LD_INT 2
68488: NEG
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: PUSH
68494: LD_INT 1
68496: PUSH
68497: LD_INT 1
68499: NEG
68500: PUSH
68501: EMPTY
68502: LIST
68503: LIST
68504: PUSH
68505: LD_INT 2
68507: PUSH
68508: LD_INT 0
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PUSH
68515: LD_INT 2
68517: PUSH
68518: LD_INT 1
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PUSH
68525: LD_INT 1
68527: PUSH
68528: LD_INT 2
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: LD_INT 0
68537: PUSH
68538: LD_INT 2
68540: PUSH
68541: EMPTY
68542: LIST
68543: LIST
68544: PUSH
68545: LD_INT 1
68547: NEG
68548: PUSH
68549: LD_INT 1
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: PUSH
68556: LD_INT 2
68558: NEG
68559: PUSH
68560: LD_INT 0
68562: PUSH
68563: EMPTY
68564: LIST
68565: LIST
68566: PUSH
68567: LD_INT 2
68569: NEG
68570: PUSH
68571: LD_INT 1
68573: NEG
68574: PUSH
68575: EMPTY
68576: LIST
68577: LIST
68578: PUSH
68579: LD_INT 2
68581: NEG
68582: PUSH
68583: LD_INT 2
68585: NEG
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: PUSH
68591: LD_INT 2
68593: NEG
68594: PUSH
68595: LD_INT 3
68597: NEG
68598: PUSH
68599: EMPTY
68600: LIST
68601: LIST
68602: PUSH
68603: LD_INT 2
68605: PUSH
68606: LD_INT 1
68608: NEG
68609: PUSH
68610: EMPTY
68611: LIST
68612: LIST
68613: PUSH
68614: LD_INT 3
68616: PUSH
68617: LD_INT 1
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: PUSH
68624: LD_INT 1
68626: PUSH
68627: LD_INT 3
68629: PUSH
68630: EMPTY
68631: LIST
68632: LIST
68633: PUSH
68634: LD_INT 1
68636: NEG
68637: PUSH
68638: LD_INT 2
68640: PUSH
68641: EMPTY
68642: LIST
68643: LIST
68644: PUSH
68645: LD_INT 3
68647: NEG
68648: PUSH
68649: LD_INT 2
68651: NEG
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: PUSH
68657: EMPTY
68658: LIST
68659: LIST
68660: LIST
68661: LIST
68662: LIST
68663: LIST
68664: LIST
68665: LIST
68666: LIST
68667: LIST
68668: LIST
68669: LIST
68670: LIST
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68682: LD_ADDR_VAR 0 34
68686: PUSH
68687: LD_INT 0
68689: PUSH
68690: LD_INT 0
68692: PUSH
68693: EMPTY
68694: LIST
68695: LIST
68696: PUSH
68697: LD_INT 0
68699: PUSH
68700: LD_INT 1
68702: NEG
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: PUSH
68708: LD_INT 1
68710: PUSH
68711: LD_INT 0
68713: PUSH
68714: EMPTY
68715: LIST
68716: LIST
68717: PUSH
68718: LD_INT 1
68720: PUSH
68721: LD_INT 1
68723: PUSH
68724: EMPTY
68725: LIST
68726: LIST
68727: PUSH
68728: LD_INT 0
68730: PUSH
68731: LD_INT 1
68733: PUSH
68734: EMPTY
68735: LIST
68736: LIST
68737: PUSH
68738: LD_INT 1
68740: NEG
68741: PUSH
68742: LD_INT 0
68744: PUSH
68745: EMPTY
68746: LIST
68747: LIST
68748: PUSH
68749: LD_INT 1
68751: NEG
68752: PUSH
68753: LD_INT 1
68755: NEG
68756: PUSH
68757: EMPTY
68758: LIST
68759: LIST
68760: PUSH
68761: LD_INT 1
68763: NEG
68764: PUSH
68765: LD_INT 2
68767: NEG
68768: PUSH
68769: EMPTY
68770: LIST
68771: LIST
68772: PUSH
68773: LD_INT 0
68775: PUSH
68776: LD_INT 2
68778: NEG
68779: PUSH
68780: EMPTY
68781: LIST
68782: LIST
68783: PUSH
68784: LD_INT 1
68786: PUSH
68787: LD_INT 1
68789: NEG
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: PUSH
68795: LD_INT 2
68797: PUSH
68798: LD_INT 1
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 2
68807: PUSH
68808: LD_INT 2
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: PUSH
68815: LD_INT 1
68817: PUSH
68818: LD_INT 2
68820: PUSH
68821: EMPTY
68822: LIST
68823: LIST
68824: PUSH
68825: LD_INT 1
68827: NEG
68828: PUSH
68829: LD_INT 1
68831: PUSH
68832: EMPTY
68833: LIST
68834: LIST
68835: PUSH
68836: LD_INT 2
68838: NEG
68839: PUSH
68840: LD_INT 0
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: LD_INT 2
68849: NEG
68850: PUSH
68851: LD_INT 1
68853: NEG
68854: PUSH
68855: EMPTY
68856: LIST
68857: LIST
68858: PUSH
68859: LD_INT 2
68861: NEG
68862: PUSH
68863: LD_INT 2
68865: NEG
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: LD_INT 1
68873: NEG
68874: PUSH
68875: LD_INT 3
68877: NEG
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 1
68885: PUSH
68886: LD_INT 2
68888: NEG
68889: PUSH
68890: EMPTY
68891: LIST
68892: LIST
68893: PUSH
68894: LD_INT 3
68896: PUSH
68897: LD_INT 2
68899: PUSH
68900: EMPTY
68901: LIST
68902: LIST
68903: PUSH
68904: LD_INT 2
68906: PUSH
68907: LD_INT 3
68909: PUSH
68910: EMPTY
68911: LIST
68912: LIST
68913: PUSH
68914: LD_INT 2
68916: NEG
68917: PUSH
68918: LD_INT 1
68920: PUSH
68921: EMPTY
68922: LIST
68923: LIST
68924: PUSH
68925: LD_INT 3
68927: NEG
68928: PUSH
68929: LD_INT 1
68931: NEG
68932: PUSH
68933: EMPTY
68934: LIST
68935: LIST
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: LIST
68948: LIST
68949: LIST
68950: LIST
68951: LIST
68952: LIST
68953: LIST
68954: LIST
68955: LIST
68956: LIST
68957: LIST
68958: LIST
68959: LIST
68960: LIST
68961: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68962: LD_ADDR_VAR 0 35
68966: PUSH
68967: LD_INT 0
68969: PUSH
68970: LD_INT 0
68972: PUSH
68973: EMPTY
68974: LIST
68975: LIST
68976: PUSH
68977: LD_INT 0
68979: PUSH
68980: LD_INT 1
68982: NEG
68983: PUSH
68984: EMPTY
68985: LIST
68986: LIST
68987: PUSH
68988: LD_INT 1
68990: PUSH
68991: LD_INT 0
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 1
69000: PUSH
69001: LD_INT 1
69003: PUSH
69004: EMPTY
69005: LIST
69006: LIST
69007: PUSH
69008: LD_INT 0
69010: PUSH
69011: LD_INT 1
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: PUSH
69018: LD_INT 1
69020: NEG
69021: PUSH
69022: LD_INT 0
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: PUSH
69029: LD_INT 1
69031: NEG
69032: PUSH
69033: LD_INT 1
69035: NEG
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PUSH
69041: LD_INT 2
69043: PUSH
69044: LD_INT 1
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: PUSH
69051: LD_INT 2
69053: NEG
69054: PUSH
69055: LD_INT 1
69057: NEG
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: LIST
69067: LIST
69068: LIST
69069: LIST
69070: LIST
69071: LIST
69072: LIST
69073: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69074: LD_ADDR_VAR 0 36
69078: PUSH
69079: LD_INT 0
69081: PUSH
69082: LD_INT 0
69084: PUSH
69085: EMPTY
69086: LIST
69087: LIST
69088: PUSH
69089: LD_INT 0
69091: PUSH
69092: LD_INT 1
69094: NEG
69095: PUSH
69096: EMPTY
69097: LIST
69098: LIST
69099: PUSH
69100: LD_INT 1
69102: PUSH
69103: LD_INT 0
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: LD_INT 1
69112: PUSH
69113: LD_INT 1
69115: PUSH
69116: EMPTY
69117: LIST
69118: LIST
69119: PUSH
69120: LD_INT 0
69122: PUSH
69123: LD_INT 1
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: LD_INT 1
69132: NEG
69133: PUSH
69134: LD_INT 0
69136: PUSH
69137: EMPTY
69138: LIST
69139: LIST
69140: PUSH
69141: LD_INT 1
69143: NEG
69144: PUSH
69145: LD_INT 1
69147: NEG
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 1
69155: NEG
69156: PUSH
69157: LD_INT 2
69159: NEG
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: PUSH
69165: LD_INT 1
69167: PUSH
69168: LD_INT 2
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: LIST
69179: LIST
69180: LIST
69181: LIST
69182: LIST
69183: LIST
69184: LIST
69185: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69186: LD_ADDR_VAR 0 37
69190: PUSH
69191: LD_INT 0
69193: PUSH
69194: LD_INT 0
69196: PUSH
69197: EMPTY
69198: LIST
69199: LIST
69200: PUSH
69201: LD_INT 0
69203: PUSH
69204: LD_INT 1
69206: NEG
69207: PUSH
69208: EMPTY
69209: LIST
69210: LIST
69211: PUSH
69212: LD_INT 1
69214: PUSH
69215: LD_INT 0
69217: PUSH
69218: EMPTY
69219: LIST
69220: LIST
69221: PUSH
69222: LD_INT 1
69224: PUSH
69225: LD_INT 1
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: PUSH
69232: LD_INT 0
69234: PUSH
69235: LD_INT 1
69237: PUSH
69238: EMPTY
69239: LIST
69240: LIST
69241: PUSH
69242: LD_INT 1
69244: NEG
69245: PUSH
69246: LD_INT 0
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PUSH
69253: LD_INT 1
69255: NEG
69256: PUSH
69257: LD_INT 1
69259: NEG
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: PUSH
69265: LD_INT 1
69267: PUSH
69268: LD_INT 1
69270: NEG
69271: PUSH
69272: EMPTY
69273: LIST
69274: LIST
69275: PUSH
69276: LD_INT 1
69278: NEG
69279: PUSH
69280: LD_INT 1
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: LIST
69291: LIST
69292: LIST
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69298: LD_ADDR_VAR 0 38
69302: PUSH
69303: LD_INT 0
69305: PUSH
69306: LD_INT 0
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: PUSH
69313: LD_INT 0
69315: PUSH
69316: LD_INT 1
69318: NEG
69319: PUSH
69320: EMPTY
69321: LIST
69322: LIST
69323: PUSH
69324: LD_INT 1
69326: PUSH
69327: LD_INT 0
69329: PUSH
69330: EMPTY
69331: LIST
69332: LIST
69333: PUSH
69334: LD_INT 1
69336: PUSH
69337: LD_INT 1
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PUSH
69344: LD_INT 0
69346: PUSH
69347: LD_INT 1
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: PUSH
69354: LD_INT 1
69356: NEG
69357: PUSH
69358: LD_INT 0
69360: PUSH
69361: EMPTY
69362: LIST
69363: LIST
69364: PUSH
69365: LD_INT 1
69367: NEG
69368: PUSH
69369: LD_INT 1
69371: NEG
69372: PUSH
69373: EMPTY
69374: LIST
69375: LIST
69376: PUSH
69377: LD_INT 2
69379: PUSH
69380: LD_INT 1
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: LD_INT 2
69389: NEG
69390: PUSH
69391: LD_INT 1
69393: NEG
69394: PUSH
69395: EMPTY
69396: LIST
69397: LIST
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69410: LD_ADDR_VAR 0 39
69414: PUSH
69415: LD_INT 0
69417: PUSH
69418: LD_INT 0
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: PUSH
69425: LD_INT 0
69427: PUSH
69428: LD_INT 1
69430: NEG
69431: PUSH
69432: EMPTY
69433: LIST
69434: LIST
69435: PUSH
69436: LD_INT 1
69438: PUSH
69439: LD_INT 0
69441: PUSH
69442: EMPTY
69443: LIST
69444: LIST
69445: PUSH
69446: LD_INT 1
69448: PUSH
69449: LD_INT 1
69451: PUSH
69452: EMPTY
69453: LIST
69454: LIST
69455: PUSH
69456: LD_INT 0
69458: PUSH
69459: LD_INT 1
69461: PUSH
69462: EMPTY
69463: LIST
69464: LIST
69465: PUSH
69466: LD_INT 1
69468: NEG
69469: PUSH
69470: LD_INT 0
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: PUSH
69477: LD_INT 1
69479: NEG
69480: PUSH
69481: LD_INT 1
69483: NEG
69484: PUSH
69485: EMPTY
69486: LIST
69487: LIST
69488: PUSH
69489: LD_INT 1
69491: NEG
69492: PUSH
69493: LD_INT 2
69495: NEG
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 1
69503: PUSH
69504: LD_INT 2
69506: PUSH
69507: EMPTY
69508: LIST
69509: LIST
69510: PUSH
69511: EMPTY
69512: LIST
69513: LIST
69514: LIST
69515: LIST
69516: LIST
69517: LIST
69518: LIST
69519: LIST
69520: LIST
69521: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69522: LD_ADDR_VAR 0 40
69526: PUSH
69527: LD_INT 0
69529: PUSH
69530: LD_INT 0
69532: PUSH
69533: EMPTY
69534: LIST
69535: LIST
69536: PUSH
69537: LD_INT 0
69539: PUSH
69540: LD_INT 1
69542: NEG
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: PUSH
69548: LD_INT 1
69550: PUSH
69551: LD_INT 0
69553: PUSH
69554: EMPTY
69555: LIST
69556: LIST
69557: PUSH
69558: LD_INT 1
69560: PUSH
69561: LD_INT 1
69563: PUSH
69564: EMPTY
69565: LIST
69566: LIST
69567: PUSH
69568: LD_INT 0
69570: PUSH
69571: LD_INT 1
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: PUSH
69578: LD_INT 1
69580: NEG
69581: PUSH
69582: LD_INT 0
69584: PUSH
69585: EMPTY
69586: LIST
69587: LIST
69588: PUSH
69589: LD_INT 1
69591: NEG
69592: PUSH
69593: LD_INT 1
69595: NEG
69596: PUSH
69597: EMPTY
69598: LIST
69599: LIST
69600: PUSH
69601: LD_INT 1
69603: PUSH
69604: LD_INT 1
69606: NEG
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: PUSH
69612: LD_INT 1
69614: NEG
69615: PUSH
69616: LD_INT 1
69618: PUSH
69619: EMPTY
69620: LIST
69621: LIST
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69634: LD_ADDR_VAR 0 41
69638: PUSH
69639: LD_INT 0
69641: PUSH
69642: LD_INT 0
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: PUSH
69649: LD_INT 0
69651: PUSH
69652: LD_INT 1
69654: NEG
69655: PUSH
69656: EMPTY
69657: LIST
69658: LIST
69659: PUSH
69660: LD_INT 1
69662: PUSH
69663: LD_INT 0
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 1
69672: PUSH
69673: LD_INT 1
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 0
69682: PUSH
69683: LD_INT 1
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: PUSH
69690: LD_INT 1
69692: NEG
69693: PUSH
69694: LD_INT 0
69696: PUSH
69697: EMPTY
69698: LIST
69699: LIST
69700: PUSH
69701: LD_INT 1
69703: NEG
69704: PUSH
69705: LD_INT 1
69707: NEG
69708: PUSH
69709: EMPTY
69710: LIST
69711: LIST
69712: PUSH
69713: LD_INT 1
69715: NEG
69716: PUSH
69717: LD_INT 2
69719: NEG
69720: PUSH
69721: EMPTY
69722: LIST
69723: LIST
69724: PUSH
69725: LD_INT 1
69727: PUSH
69728: LD_INT 1
69730: NEG
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: LD_INT 2
69738: PUSH
69739: LD_INT 0
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: LD_INT 2
69748: PUSH
69749: LD_INT 1
69751: PUSH
69752: EMPTY
69753: LIST
69754: LIST
69755: PUSH
69756: LD_INT 2
69758: PUSH
69759: LD_INT 2
69761: PUSH
69762: EMPTY
69763: LIST
69764: LIST
69765: PUSH
69766: LD_INT 1
69768: PUSH
69769: LD_INT 2
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: PUSH
69776: LD_INT 1
69778: NEG
69779: PUSH
69780: LD_INT 1
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: LD_INT 2
69789: NEG
69790: PUSH
69791: LD_INT 0
69793: PUSH
69794: EMPTY
69795: LIST
69796: LIST
69797: PUSH
69798: LD_INT 2
69800: NEG
69801: PUSH
69802: LD_INT 1
69804: NEG
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: PUSH
69810: LD_INT 2
69812: NEG
69813: PUSH
69814: LD_INT 2
69816: NEG
69817: PUSH
69818: EMPTY
69819: LIST
69820: LIST
69821: PUSH
69822: LD_INT 2
69824: NEG
69825: PUSH
69826: LD_INT 3
69828: NEG
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PUSH
69834: LD_INT 2
69836: PUSH
69837: LD_INT 1
69839: NEG
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: PUSH
69845: LD_INT 3
69847: PUSH
69848: LD_INT 0
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: PUSH
69855: LD_INT 3
69857: PUSH
69858: LD_INT 1
69860: PUSH
69861: EMPTY
69862: LIST
69863: LIST
69864: PUSH
69865: LD_INT 3
69867: PUSH
69868: LD_INT 2
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: PUSH
69875: LD_INT 3
69877: PUSH
69878: LD_INT 3
69880: PUSH
69881: EMPTY
69882: LIST
69883: LIST
69884: PUSH
69885: LD_INT 2
69887: PUSH
69888: LD_INT 3
69890: PUSH
69891: EMPTY
69892: LIST
69893: LIST
69894: PUSH
69895: LD_INT 2
69897: NEG
69898: PUSH
69899: LD_INT 1
69901: PUSH
69902: EMPTY
69903: LIST
69904: LIST
69905: PUSH
69906: LD_INT 3
69908: NEG
69909: PUSH
69910: LD_INT 0
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: LD_INT 3
69919: NEG
69920: PUSH
69921: LD_INT 1
69923: NEG
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PUSH
69929: LD_INT 3
69931: NEG
69932: PUSH
69933: LD_INT 2
69935: NEG
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 3
69943: NEG
69944: PUSH
69945: LD_INT 3
69947: NEG
69948: PUSH
69949: EMPTY
69950: LIST
69951: LIST
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: LIST
69957: LIST
69958: LIST
69959: LIST
69960: LIST
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69984: LD_ADDR_VAR 0 42
69988: PUSH
69989: LD_INT 0
69991: PUSH
69992: LD_INT 0
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: LD_INT 0
70001: PUSH
70002: LD_INT 1
70004: NEG
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PUSH
70010: LD_INT 1
70012: PUSH
70013: LD_INT 0
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: PUSH
70020: LD_INT 1
70022: PUSH
70023: LD_INT 1
70025: PUSH
70026: EMPTY
70027: LIST
70028: LIST
70029: PUSH
70030: LD_INT 0
70032: PUSH
70033: LD_INT 1
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 1
70042: NEG
70043: PUSH
70044: LD_INT 0
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: PUSH
70051: LD_INT 1
70053: NEG
70054: PUSH
70055: LD_INT 1
70057: NEG
70058: PUSH
70059: EMPTY
70060: LIST
70061: LIST
70062: PUSH
70063: LD_INT 1
70065: NEG
70066: PUSH
70067: LD_INT 2
70069: NEG
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: PUSH
70075: LD_INT 0
70077: PUSH
70078: LD_INT 2
70080: NEG
70081: PUSH
70082: EMPTY
70083: LIST
70084: LIST
70085: PUSH
70086: LD_INT 1
70088: PUSH
70089: LD_INT 1
70091: NEG
70092: PUSH
70093: EMPTY
70094: LIST
70095: LIST
70096: PUSH
70097: LD_INT 2
70099: PUSH
70100: LD_INT 1
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: PUSH
70107: LD_INT 2
70109: PUSH
70110: LD_INT 2
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: PUSH
70117: LD_INT 1
70119: PUSH
70120: LD_INT 2
70122: PUSH
70123: EMPTY
70124: LIST
70125: LIST
70126: PUSH
70127: LD_INT 0
70129: PUSH
70130: LD_INT 2
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: PUSH
70137: LD_INT 1
70139: NEG
70140: PUSH
70141: LD_INT 1
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: PUSH
70148: LD_INT 2
70150: NEG
70151: PUSH
70152: LD_INT 1
70154: NEG
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: PUSH
70160: LD_INT 2
70162: NEG
70163: PUSH
70164: LD_INT 2
70166: NEG
70167: PUSH
70168: EMPTY
70169: LIST
70170: LIST
70171: PUSH
70172: LD_INT 2
70174: NEG
70175: PUSH
70176: LD_INT 3
70178: NEG
70179: PUSH
70180: EMPTY
70181: LIST
70182: LIST
70183: PUSH
70184: LD_INT 1
70186: NEG
70187: PUSH
70188: LD_INT 3
70190: NEG
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 0
70198: PUSH
70199: LD_INT 3
70201: NEG
70202: PUSH
70203: EMPTY
70204: LIST
70205: LIST
70206: PUSH
70207: LD_INT 1
70209: PUSH
70210: LD_INT 2
70212: NEG
70213: PUSH
70214: EMPTY
70215: LIST
70216: LIST
70217: PUSH
70218: LD_INT 3
70220: PUSH
70221: LD_INT 2
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PUSH
70228: LD_INT 3
70230: PUSH
70231: LD_INT 3
70233: PUSH
70234: EMPTY
70235: LIST
70236: LIST
70237: PUSH
70238: LD_INT 2
70240: PUSH
70241: LD_INT 3
70243: PUSH
70244: EMPTY
70245: LIST
70246: LIST
70247: PUSH
70248: LD_INT 1
70250: PUSH
70251: LD_INT 3
70253: PUSH
70254: EMPTY
70255: LIST
70256: LIST
70257: PUSH
70258: LD_INT 0
70260: PUSH
70261: LD_INT 3
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: PUSH
70268: LD_INT 1
70270: NEG
70271: PUSH
70272: LD_INT 2
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PUSH
70279: LD_INT 3
70281: NEG
70282: PUSH
70283: LD_INT 2
70285: NEG
70286: PUSH
70287: EMPTY
70288: LIST
70289: LIST
70290: PUSH
70291: LD_INT 3
70293: NEG
70294: PUSH
70295: LD_INT 3
70297: NEG
70298: PUSH
70299: EMPTY
70300: LIST
70301: LIST
70302: PUSH
70303: EMPTY
70304: LIST
70305: LIST
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: LIST
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70334: LD_ADDR_VAR 0 43
70338: PUSH
70339: LD_INT 0
70341: PUSH
70342: LD_INT 0
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: LD_INT 0
70351: PUSH
70352: LD_INT 1
70354: NEG
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 1
70362: PUSH
70363: LD_INT 0
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: LD_INT 1
70372: PUSH
70373: LD_INT 1
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: LD_INT 0
70382: PUSH
70383: LD_INT 1
70385: PUSH
70386: EMPTY
70387: LIST
70388: LIST
70389: PUSH
70390: LD_INT 1
70392: NEG
70393: PUSH
70394: LD_INT 0
70396: PUSH
70397: EMPTY
70398: LIST
70399: LIST
70400: PUSH
70401: LD_INT 1
70403: NEG
70404: PUSH
70405: LD_INT 1
70407: NEG
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: PUSH
70413: LD_INT 1
70415: NEG
70416: PUSH
70417: LD_INT 2
70419: NEG
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 0
70427: PUSH
70428: LD_INT 2
70430: NEG
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: LD_INT 1
70438: PUSH
70439: LD_INT 1
70441: NEG
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: LD_INT 2
70449: PUSH
70450: LD_INT 0
70452: PUSH
70453: EMPTY
70454: LIST
70455: LIST
70456: PUSH
70457: LD_INT 2
70459: PUSH
70460: LD_INT 1
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PUSH
70467: LD_INT 1
70469: PUSH
70470: LD_INT 2
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 0
70479: PUSH
70480: LD_INT 2
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 1
70489: NEG
70490: PUSH
70491: LD_INT 1
70493: PUSH
70494: EMPTY
70495: LIST
70496: LIST
70497: PUSH
70498: LD_INT 2
70500: NEG
70501: PUSH
70502: LD_INT 0
70504: PUSH
70505: EMPTY
70506: LIST
70507: LIST
70508: PUSH
70509: LD_INT 2
70511: NEG
70512: PUSH
70513: LD_INT 1
70515: NEG
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: LD_INT 1
70523: NEG
70524: PUSH
70525: LD_INT 3
70527: NEG
70528: PUSH
70529: EMPTY
70530: LIST
70531: LIST
70532: PUSH
70533: LD_INT 0
70535: PUSH
70536: LD_INT 3
70538: NEG
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: LD_INT 1
70546: PUSH
70547: LD_INT 2
70549: NEG
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 2
70557: PUSH
70558: LD_INT 1
70560: NEG
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: PUSH
70566: LD_INT 3
70568: PUSH
70569: LD_INT 0
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 3
70578: PUSH
70579: LD_INT 1
70581: PUSH
70582: EMPTY
70583: LIST
70584: LIST
70585: PUSH
70586: LD_INT 1
70588: PUSH
70589: LD_INT 3
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: LD_INT 0
70598: PUSH
70599: LD_INT 3
70601: PUSH
70602: EMPTY
70603: LIST
70604: LIST
70605: PUSH
70606: LD_INT 1
70608: NEG
70609: PUSH
70610: LD_INT 2
70612: PUSH
70613: EMPTY
70614: LIST
70615: LIST
70616: PUSH
70617: LD_INT 2
70619: NEG
70620: PUSH
70621: LD_INT 1
70623: PUSH
70624: EMPTY
70625: LIST
70626: LIST
70627: PUSH
70628: LD_INT 3
70630: NEG
70631: PUSH
70632: LD_INT 0
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 3
70641: NEG
70642: PUSH
70643: LD_INT 1
70645: NEG
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: LIST
70655: LIST
70656: LIST
70657: LIST
70658: LIST
70659: LIST
70660: LIST
70661: LIST
70662: LIST
70663: LIST
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: LIST
70679: LIST
70680: LIST
70681: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70682: LD_ADDR_VAR 0 44
70686: PUSH
70687: LD_INT 0
70689: PUSH
70690: LD_INT 0
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: PUSH
70697: LD_INT 0
70699: PUSH
70700: LD_INT 1
70702: NEG
70703: PUSH
70704: EMPTY
70705: LIST
70706: LIST
70707: PUSH
70708: LD_INT 1
70710: PUSH
70711: LD_INT 0
70713: PUSH
70714: EMPTY
70715: LIST
70716: LIST
70717: PUSH
70718: LD_INT 1
70720: PUSH
70721: LD_INT 1
70723: PUSH
70724: EMPTY
70725: LIST
70726: LIST
70727: PUSH
70728: LD_INT 0
70730: PUSH
70731: LD_INT 1
70733: PUSH
70734: EMPTY
70735: LIST
70736: LIST
70737: PUSH
70738: LD_INT 1
70740: NEG
70741: PUSH
70742: LD_INT 0
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: PUSH
70749: LD_INT 1
70751: NEG
70752: PUSH
70753: LD_INT 1
70755: NEG
70756: PUSH
70757: EMPTY
70758: LIST
70759: LIST
70760: PUSH
70761: LD_INT 1
70763: NEG
70764: PUSH
70765: LD_INT 2
70767: NEG
70768: PUSH
70769: EMPTY
70770: LIST
70771: LIST
70772: PUSH
70773: LD_INT 1
70775: PUSH
70776: LD_INT 1
70778: NEG
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PUSH
70784: LD_INT 2
70786: PUSH
70787: LD_INT 0
70789: PUSH
70790: EMPTY
70791: LIST
70792: LIST
70793: PUSH
70794: LD_INT 2
70796: PUSH
70797: LD_INT 1
70799: PUSH
70800: EMPTY
70801: LIST
70802: LIST
70803: PUSH
70804: LD_INT 2
70806: PUSH
70807: LD_INT 2
70809: PUSH
70810: EMPTY
70811: LIST
70812: LIST
70813: PUSH
70814: LD_INT 1
70816: PUSH
70817: LD_INT 2
70819: PUSH
70820: EMPTY
70821: LIST
70822: LIST
70823: PUSH
70824: LD_INT 1
70826: NEG
70827: PUSH
70828: LD_INT 1
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PUSH
70835: LD_INT 2
70837: NEG
70838: PUSH
70839: LD_INT 0
70841: PUSH
70842: EMPTY
70843: LIST
70844: LIST
70845: PUSH
70846: LD_INT 2
70848: NEG
70849: PUSH
70850: LD_INT 1
70852: NEG
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 2
70860: NEG
70861: PUSH
70862: LD_INT 2
70864: NEG
70865: PUSH
70866: EMPTY
70867: LIST
70868: LIST
70869: PUSH
70870: LD_INT 2
70872: NEG
70873: PUSH
70874: LD_INT 3
70876: NEG
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 2
70884: PUSH
70885: LD_INT 1
70887: NEG
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PUSH
70893: LD_INT 3
70895: PUSH
70896: LD_INT 0
70898: PUSH
70899: EMPTY
70900: LIST
70901: LIST
70902: PUSH
70903: LD_INT 3
70905: PUSH
70906: LD_INT 1
70908: PUSH
70909: EMPTY
70910: LIST
70911: LIST
70912: PUSH
70913: LD_INT 3
70915: PUSH
70916: LD_INT 2
70918: PUSH
70919: EMPTY
70920: LIST
70921: LIST
70922: PUSH
70923: LD_INT 3
70925: PUSH
70926: LD_INT 3
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: PUSH
70933: LD_INT 2
70935: PUSH
70936: LD_INT 3
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: PUSH
70943: LD_INT 2
70945: NEG
70946: PUSH
70947: LD_INT 1
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: PUSH
70954: LD_INT 3
70956: NEG
70957: PUSH
70958: LD_INT 0
70960: PUSH
70961: EMPTY
70962: LIST
70963: LIST
70964: PUSH
70965: LD_INT 3
70967: NEG
70968: PUSH
70969: LD_INT 1
70971: NEG
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: PUSH
70977: LD_INT 3
70979: NEG
70980: PUSH
70981: LD_INT 2
70983: NEG
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: PUSH
70989: LD_INT 3
70991: NEG
70992: PUSH
70993: LD_INT 3
70995: NEG
70996: PUSH
70997: EMPTY
70998: LIST
70999: LIST
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: LIST
71005: LIST
71006: LIST
71007: LIST
71008: LIST
71009: LIST
71010: LIST
71011: LIST
71012: LIST
71013: LIST
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71032: LD_ADDR_VAR 0 45
71036: PUSH
71037: LD_INT 0
71039: PUSH
71040: LD_INT 0
71042: PUSH
71043: EMPTY
71044: LIST
71045: LIST
71046: PUSH
71047: LD_INT 0
71049: PUSH
71050: LD_INT 1
71052: NEG
71053: PUSH
71054: EMPTY
71055: LIST
71056: LIST
71057: PUSH
71058: LD_INT 1
71060: PUSH
71061: LD_INT 0
71063: PUSH
71064: EMPTY
71065: LIST
71066: LIST
71067: PUSH
71068: LD_INT 1
71070: PUSH
71071: LD_INT 1
71073: PUSH
71074: EMPTY
71075: LIST
71076: LIST
71077: PUSH
71078: LD_INT 0
71080: PUSH
71081: LD_INT 1
71083: PUSH
71084: EMPTY
71085: LIST
71086: LIST
71087: PUSH
71088: LD_INT 1
71090: NEG
71091: PUSH
71092: LD_INT 0
71094: PUSH
71095: EMPTY
71096: LIST
71097: LIST
71098: PUSH
71099: LD_INT 1
71101: NEG
71102: PUSH
71103: LD_INT 1
71105: NEG
71106: PUSH
71107: EMPTY
71108: LIST
71109: LIST
71110: PUSH
71111: LD_INT 1
71113: NEG
71114: PUSH
71115: LD_INT 2
71117: NEG
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: LD_INT 0
71125: PUSH
71126: LD_INT 2
71128: NEG
71129: PUSH
71130: EMPTY
71131: LIST
71132: LIST
71133: PUSH
71134: LD_INT 1
71136: PUSH
71137: LD_INT 1
71139: NEG
71140: PUSH
71141: EMPTY
71142: LIST
71143: LIST
71144: PUSH
71145: LD_INT 2
71147: PUSH
71148: LD_INT 1
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PUSH
71155: LD_INT 2
71157: PUSH
71158: LD_INT 2
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: PUSH
71165: LD_INT 1
71167: PUSH
71168: LD_INT 2
71170: PUSH
71171: EMPTY
71172: LIST
71173: LIST
71174: PUSH
71175: LD_INT 0
71177: PUSH
71178: LD_INT 2
71180: PUSH
71181: EMPTY
71182: LIST
71183: LIST
71184: PUSH
71185: LD_INT 1
71187: NEG
71188: PUSH
71189: LD_INT 1
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: PUSH
71196: LD_INT 2
71198: NEG
71199: PUSH
71200: LD_INT 1
71202: NEG
71203: PUSH
71204: EMPTY
71205: LIST
71206: LIST
71207: PUSH
71208: LD_INT 2
71210: NEG
71211: PUSH
71212: LD_INT 2
71214: NEG
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: LD_INT 2
71222: NEG
71223: PUSH
71224: LD_INT 3
71226: NEG
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PUSH
71232: LD_INT 1
71234: NEG
71235: PUSH
71236: LD_INT 3
71238: NEG
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: LD_INT 0
71246: PUSH
71247: LD_INT 3
71249: NEG
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 1
71257: PUSH
71258: LD_INT 2
71260: NEG
71261: PUSH
71262: EMPTY
71263: LIST
71264: LIST
71265: PUSH
71266: LD_INT 3
71268: PUSH
71269: LD_INT 2
71271: PUSH
71272: EMPTY
71273: LIST
71274: LIST
71275: PUSH
71276: LD_INT 3
71278: PUSH
71279: LD_INT 3
71281: PUSH
71282: EMPTY
71283: LIST
71284: LIST
71285: PUSH
71286: LD_INT 2
71288: PUSH
71289: LD_INT 3
71291: PUSH
71292: EMPTY
71293: LIST
71294: LIST
71295: PUSH
71296: LD_INT 1
71298: PUSH
71299: LD_INT 3
71301: PUSH
71302: EMPTY
71303: LIST
71304: LIST
71305: PUSH
71306: LD_INT 0
71308: PUSH
71309: LD_INT 3
71311: PUSH
71312: EMPTY
71313: LIST
71314: LIST
71315: PUSH
71316: LD_INT 1
71318: NEG
71319: PUSH
71320: LD_INT 2
71322: PUSH
71323: EMPTY
71324: LIST
71325: LIST
71326: PUSH
71327: LD_INT 3
71329: NEG
71330: PUSH
71331: LD_INT 2
71333: NEG
71334: PUSH
71335: EMPTY
71336: LIST
71337: LIST
71338: PUSH
71339: LD_INT 3
71341: NEG
71342: PUSH
71343: LD_INT 3
71345: NEG
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: LIST
71355: LIST
71356: LIST
71357: LIST
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: LIST
71364: LIST
71365: LIST
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: LIST
71377: LIST
71378: LIST
71379: LIST
71380: LIST
71381: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71382: LD_ADDR_VAR 0 46
71386: PUSH
71387: LD_INT 0
71389: PUSH
71390: LD_INT 0
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PUSH
71397: LD_INT 0
71399: PUSH
71400: LD_INT 1
71402: NEG
71403: PUSH
71404: EMPTY
71405: LIST
71406: LIST
71407: PUSH
71408: LD_INT 1
71410: PUSH
71411: LD_INT 0
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PUSH
71418: LD_INT 1
71420: PUSH
71421: LD_INT 1
71423: PUSH
71424: EMPTY
71425: LIST
71426: LIST
71427: PUSH
71428: LD_INT 0
71430: PUSH
71431: LD_INT 1
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PUSH
71438: LD_INT 1
71440: NEG
71441: PUSH
71442: LD_INT 0
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 1
71451: NEG
71452: PUSH
71453: LD_INT 1
71455: NEG
71456: PUSH
71457: EMPTY
71458: LIST
71459: LIST
71460: PUSH
71461: LD_INT 1
71463: NEG
71464: PUSH
71465: LD_INT 2
71467: NEG
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: PUSH
71473: LD_INT 0
71475: PUSH
71476: LD_INT 2
71478: NEG
71479: PUSH
71480: EMPTY
71481: LIST
71482: LIST
71483: PUSH
71484: LD_INT 1
71486: PUSH
71487: LD_INT 1
71489: NEG
71490: PUSH
71491: EMPTY
71492: LIST
71493: LIST
71494: PUSH
71495: LD_INT 2
71497: PUSH
71498: LD_INT 0
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: PUSH
71505: LD_INT 2
71507: PUSH
71508: LD_INT 1
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: PUSH
71515: LD_INT 1
71517: PUSH
71518: LD_INT 2
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: PUSH
71525: LD_INT 0
71527: PUSH
71528: LD_INT 2
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: LD_INT 1
71537: NEG
71538: PUSH
71539: LD_INT 1
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PUSH
71546: LD_INT 2
71548: NEG
71549: PUSH
71550: LD_INT 0
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PUSH
71557: LD_INT 2
71559: NEG
71560: PUSH
71561: LD_INT 1
71563: NEG
71564: PUSH
71565: EMPTY
71566: LIST
71567: LIST
71568: PUSH
71569: LD_INT 1
71571: NEG
71572: PUSH
71573: LD_INT 3
71575: NEG
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PUSH
71581: LD_INT 0
71583: PUSH
71584: LD_INT 3
71586: NEG
71587: PUSH
71588: EMPTY
71589: LIST
71590: LIST
71591: PUSH
71592: LD_INT 1
71594: PUSH
71595: LD_INT 2
71597: NEG
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: PUSH
71603: LD_INT 2
71605: PUSH
71606: LD_INT 1
71608: NEG
71609: PUSH
71610: EMPTY
71611: LIST
71612: LIST
71613: PUSH
71614: LD_INT 3
71616: PUSH
71617: LD_INT 0
71619: PUSH
71620: EMPTY
71621: LIST
71622: LIST
71623: PUSH
71624: LD_INT 3
71626: PUSH
71627: LD_INT 1
71629: PUSH
71630: EMPTY
71631: LIST
71632: LIST
71633: PUSH
71634: LD_INT 1
71636: PUSH
71637: LD_INT 3
71639: PUSH
71640: EMPTY
71641: LIST
71642: LIST
71643: PUSH
71644: LD_INT 0
71646: PUSH
71647: LD_INT 3
71649: PUSH
71650: EMPTY
71651: LIST
71652: LIST
71653: PUSH
71654: LD_INT 1
71656: NEG
71657: PUSH
71658: LD_INT 2
71660: PUSH
71661: EMPTY
71662: LIST
71663: LIST
71664: PUSH
71665: LD_INT 2
71667: NEG
71668: PUSH
71669: LD_INT 1
71671: PUSH
71672: EMPTY
71673: LIST
71674: LIST
71675: PUSH
71676: LD_INT 3
71678: NEG
71679: PUSH
71680: LD_INT 0
71682: PUSH
71683: EMPTY
71684: LIST
71685: LIST
71686: PUSH
71687: LD_INT 3
71689: NEG
71690: PUSH
71691: LD_INT 1
71693: NEG
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: LIST
71703: LIST
71704: LIST
71705: LIST
71706: LIST
71707: LIST
71708: LIST
71709: LIST
71710: LIST
71711: LIST
71712: LIST
71713: LIST
71714: LIST
71715: LIST
71716: LIST
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: LIST
71722: LIST
71723: LIST
71724: LIST
71725: LIST
71726: LIST
71727: LIST
71728: LIST
71729: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71730: LD_ADDR_VAR 0 47
71734: PUSH
71735: LD_INT 0
71737: PUSH
71738: LD_INT 0
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: LD_INT 0
71747: PUSH
71748: LD_INT 1
71750: NEG
71751: PUSH
71752: EMPTY
71753: LIST
71754: LIST
71755: PUSH
71756: LD_INT 1
71758: PUSH
71759: LD_INT 0
71761: PUSH
71762: EMPTY
71763: LIST
71764: LIST
71765: PUSH
71766: LD_INT 1
71768: PUSH
71769: LD_INT 1
71771: PUSH
71772: EMPTY
71773: LIST
71774: LIST
71775: PUSH
71776: LD_INT 0
71778: PUSH
71779: LD_INT 1
71781: PUSH
71782: EMPTY
71783: LIST
71784: LIST
71785: PUSH
71786: LD_INT 1
71788: NEG
71789: PUSH
71790: LD_INT 0
71792: PUSH
71793: EMPTY
71794: LIST
71795: LIST
71796: PUSH
71797: LD_INT 1
71799: NEG
71800: PUSH
71801: LD_INT 1
71803: NEG
71804: PUSH
71805: EMPTY
71806: LIST
71807: LIST
71808: PUSH
71809: LD_INT 1
71811: NEG
71812: PUSH
71813: LD_INT 2
71815: NEG
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: PUSH
71821: LD_INT 0
71823: PUSH
71824: LD_INT 2
71826: NEG
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: PUSH
71832: LD_INT 1
71834: PUSH
71835: LD_INT 1
71837: NEG
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PUSH
71843: LD_INT 2
71845: NEG
71846: PUSH
71847: LD_INT 1
71849: NEG
71850: PUSH
71851: EMPTY
71852: LIST
71853: LIST
71854: PUSH
71855: LD_INT 2
71857: NEG
71858: PUSH
71859: LD_INT 2
71861: NEG
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: LIST
71877: LIST
71878: LIST
71879: LIST
71880: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71881: LD_ADDR_VAR 0 48
71885: PUSH
71886: LD_INT 0
71888: PUSH
71889: LD_INT 0
71891: PUSH
71892: EMPTY
71893: LIST
71894: LIST
71895: PUSH
71896: LD_INT 0
71898: PUSH
71899: LD_INT 1
71901: NEG
71902: PUSH
71903: EMPTY
71904: LIST
71905: LIST
71906: PUSH
71907: LD_INT 1
71909: PUSH
71910: LD_INT 0
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: PUSH
71917: LD_INT 1
71919: PUSH
71920: LD_INT 1
71922: PUSH
71923: EMPTY
71924: LIST
71925: LIST
71926: PUSH
71927: LD_INT 0
71929: PUSH
71930: LD_INT 1
71932: PUSH
71933: EMPTY
71934: LIST
71935: LIST
71936: PUSH
71937: LD_INT 1
71939: NEG
71940: PUSH
71941: LD_INT 0
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: PUSH
71948: LD_INT 1
71950: NEG
71951: PUSH
71952: LD_INT 1
71954: NEG
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: PUSH
71960: LD_INT 1
71962: NEG
71963: PUSH
71964: LD_INT 2
71966: NEG
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: PUSH
71972: LD_INT 0
71974: PUSH
71975: LD_INT 2
71977: NEG
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: PUSH
71983: LD_INT 1
71985: PUSH
71986: LD_INT 1
71988: NEG
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: PUSH
71994: LD_INT 2
71996: PUSH
71997: LD_INT 0
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: PUSH
72004: LD_INT 2
72006: PUSH
72007: LD_INT 1
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: LIST
72018: LIST
72019: LIST
72020: LIST
72021: LIST
72022: LIST
72023: LIST
72024: LIST
72025: LIST
72026: LIST
72027: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72028: LD_ADDR_VAR 0 49
72032: PUSH
72033: LD_INT 0
72035: PUSH
72036: LD_INT 0
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: LD_INT 0
72045: PUSH
72046: LD_INT 1
72048: NEG
72049: PUSH
72050: EMPTY
72051: LIST
72052: LIST
72053: PUSH
72054: LD_INT 1
72056: PUSH
72057: LD_INT 0
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: LD_INT 1
72066: PUSH
72067: LD_INT 1
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: PUSH
72074: LD_INT 0
72076: PUSH
72077: LD_INT 1
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: PUSH
72084: LD_INT 1
72086: NEG
72087: PUSH
72088: LD_INT 0
72090: PUSH
72091: EMPTY
72092: LIST
72093: LIST
72094: PUSH
72095: LD_INT 1
72097: NEG
72098: PUSH
72099: LD_INT 1
72101: NEG
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 1
72109: PUSH
72110: LD_INT 1
72112: NEG
72113: PUSH
72114: EMPTY
72115: LIST
72116: LIST
72117: PUSH
72118: LD_INT 2
72120: PUSH
72121: LD_INT 0
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 2
72130: PUSH
72131: LD_INT 1
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 2
72140: PUSH
72141: LD_INT 2
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 1
72150: PUSH
72151: LD_INT 2
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: EMPTY
72159: LIST
72160: LIST
72161: LIST
72162: LIST
72163: LIST
72164: LIST
72165: LIST
72166: LIST
72167: LIST
72168: LIST
72169: LIST
72170: LIST
72171: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72172: LD_ADDR_VAR 0 50
72176: PUSH
72177: LD_INT 0
72179: PUSH
72180: LD_INT 0
72182: PUSH
72183: EMPTY
72184: LIST
72185: LIST
72186: PUSH
72187: LD_INT 0
72189: PUSH
72190: LD_INT 1
72192: NEG
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 1
72200: PUSH
72201: LD_INT 0
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 1
72210: PUSH
72211: LD_INT 1
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 0
72220: PUSH
72221: LD_INT 1
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: PUSH
72228: LD_INT 1
72230: NEG
72231: PUSH
72232: LD_INT 0
72234: PUSH
72235: EMPTY
72236: LIST
72237: LIST
72238: PUSH
72239: LD_INT 1
72241: NEG
72242: PUSH
72243: LD_INT 1
72245: NEG
72246: PUSH
72247: EMPTY
72248: LIST
72249: LIST
72250: PUSH
72251: LD_INT 2
72253: PUSH
72254: LD_INT 1
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: PUSH
72261: LD_INT 2
72263: PUSH
72264: LD_INT 2
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: PUSH
72271: LD_INT 1
72273: PUSH
72274: LD_INT 2
72276: PUSH
72277: EMPTY
72278: LIST
72279: LIST
72280: PUSH
72281: LD_INT 0
72283: PUSH
72284: LD_INT 2
72286: PUSH
72287: EMPTY
72288: LIST
72289: LIST
72290: PUSH
72291: LD_INT 1
72293: NEG
72294: PUSH
72295: LD_INT 1
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: PUSH
72302: EMPTY
72303: LIST
72304: LIST
72305: LIST
72306: LIST
72307: LIST
72308: LIST
72309: LIST
72310: LIST
72311: LIST
72312: LIST
72313: LIST
72314: LIST
72315: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72316: LD_ADDR_VAR 0 51
72320: PUSH
72321: LD_INT 0
72323: PUSH
72324: LD_INT 0
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: PUSH
72331: LD_INT 0
72333: PUSH
72334: LD_INT 1
72336: NEG
72337: PUSH
72338: EMPTY
72339: LIST
72340: LIST
72341: PUSH
72342: LD_INT 1
72344: PUSH
72345: LD_INT 0
72347: PUSH
72348: EMPTY
72349: LIST
72350: LIST
72351: PUSH
72352: LD_INT 1
72354: PUSH
72355: LD_INT 1
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: PUSH
72362: LD_INT 0
72364: PUSH
72365: LD_INT 1
72367: PUSH
72368: EMPTY
72369: LIST
72370: LIST
72371: PUSH
72372: LD_INT 1
72374: NEG
72375: PUSH
72376: LD_INT 0
72378: PUSH
72379: EMPTY
72380: LIST
72381: LIST
72382: PUSH
72383: LD_INT 1
72385: NEG
72386: PUSH
72387: LD_INT 1
72389: NEG
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PUSH
72395: LD_INT 1
72397: PUSH
72398: LD_INT 2
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PUSH
72405: LD_INT 0
72407: PUSH
72408: LD_INT 2
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: PUSH
72415: LD_INT 1
72417: NEG
72418: PUSH
72419: LD_INT 1
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: PUSH
72426: LD_INT 2
72428: NEG
72429: PUSH
72430: LD_INT 0
72432: PUSH
72433: EMPTY
72434: LIST
72435: LIST
72436: PUSH
72437: LD_INT 2
72439: NEG
72440: PUSH
72441: LD_INT 1
72443: NEG
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: EMPTY
72450: LIST
72451: LIST
72452: LIST
72453: LIST
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: LIST
72462: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72463: LD_ADDR_VAR 0 52
72467: PUSH
72468: LD_INT 0
72470: PUSH
72471: LD_INT 0
72473: PUSH
72474: EMPTY
72475: LIST
72476: LIST
72477: PUSH
72478: LD_INT 0
72480: PUSH
72481: LD_INT 1
72483: NEG
72484: PUSH
72485: EMPTY
72486: LIST
72487: LIST
72488: PUSH
72489: LD_INT 1
72491: PUSH
72492: LD_INT 0
72494: PUSH
72495: EMPTY
72496: LIST
72497: LIST
72498: PUSH
72499: LD_INT 1
72501: PUSH
72502: LD_INT 1
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: LD_INT 0
72511: PUSH
72512: LD_INT 1
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PUSH
72519: LD_INT 1
72521: NEG
72522: PUSH
72523: LD_INT 0
72525: PUSH
72526: EMPTY
72527: LIST
72528: LIST
72529: PUSH
72530: LD_INT 1
72532: NEG
72533: PUSH
72534: LD_INT 1
72536: NEG
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: PUSH
72542: LD_INT 1
72544: NEG
72545: PUSH
72546: LD_INT 2
72548: NEG
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: PUSH
72554: LD_INT 1
72556: NEG
72557: PUSH
72558: LD_INT 1
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: PUSH
72565: LD_INT 2
72567: NEG
72568: PUSH
72569: LD_INT 0
72571: PUSH
72572: EMPTY
72573: LIST
72574: LIST
72575: PUSH
72576: LD_INT 2
72578: NEG
72579: PUSH
72580: LD_INT 1
72582: NEG
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: PUSH
72588: LD_INT 2
72590: NEG
72591: PUSH
72592: LD_INT 2
72594: NEG
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: EMPTY
72601: LIST
72602: LIST
72603: LIST
72604: LIST
72605: LIST
72606: LIST
72607: LIST
72608: LIST
72609: LIST
72610: LIST
72611: LIST
72612: LIST
72613: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72614: LD_ADDR_VAR 0 53
72618: PUSH
72619: LD_INT 0
72621: PUSH
72622: LD_INT 0
72624: PUSH
72625: EMPTY
72626: LIST
72627: LIST
72628: PUSH
72629: LD_INT 0
72631: PUSH
72632: LD_INT 1
72634: NEG
72635: PUSH
72636: EMPTY
72637: LIST
72638: LIST
72639: PUSH
72640: LD_INT 1
72642: PUSH
72643: LD_INT 0
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PUSH
72650: LD_INT 1
72652: PUSH
72653: LD_INT 1
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: PUSH
72660: LD_INT 0
72662: PUSH
72663: LD_INT 1
72665: PUSH
72666: EMPTY
72667: LIST
72668: LIST
72669: PUSH
72670: LD_INT 1
72672: NEG
72673: PUSH
72674: LD_INT 0
72676: PUSH
72677: EMPTY
72678: LIST
72679: LIST
72680: PUSH
72681: LD_INT 1
72683: NEG
72684: PUSH
72685: LD_INT 1
72687: NEG
72688: PUSH
72689: EMPTY
72690: LIST
72691: LIST
72692: PUSH
72693: LD_INT 1
72695: NEG
72696: PUSH
72697: LD_INT 2
72699: NEG
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: LD_INT 0
72707: PUSH
72708: LD_INT 2
72710: NEG
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: LD_INT 1
72718: PUSH
72719: LD_INT 1
72721: NEG
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 2
72729: PUSH
72730: LD_INT 0
72732: PUSH
72733: EMPTY
72734: LIST
72735: LIST
72736: PUSH
72737: LD_INT 2
72739: PUSH
72740: LD_INT 1
72742: PUSH
72743: EMPTY
72744: LIST
72745: LIST
72746: PUSH
72747: LD_INT 2
72749: PUSH
72750: LD_INT 2
72752: PUSH
72753: EMPTY
72754: LIST
72755: LIST
72756: PUSH
72757: LD_INT 1
72759: PUSH
72760: LD_INT 2
72762: PUSH
72763: EMPTY
72764: LIST
72765: LIST
72766: PUSH
72767: LD_INT 0
72769: PUSH
72770: LD_INT 2
72772: PUSH
72773: EMPTY
72774: LIST
72775: LIST
72776: PUSH
72777: LD_INT 1
72779: NEG
72780: PUSH
72781: LD_INT 1
72783: PUSH
72784: EMPTY
72785: LIST
72786: LIST
72787: PUSH
72788: LD_INT 2
72790: NEG
72791: PUSH
72792: LD_INT 0
72794: PUSH
72795: EMPTY
72796: LIST
72797: LIST
72798: PUSH
72799: LD_INT 2
72801: NEG
72802: PUSH
72803: LD_INT 1
72805: NEG
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: PUSH
72811: LD_INT 2
72813: NEG
72814: PUSH
72815: LD_INT 2
72817: NEG
72818: PUSH
72819: EMPTY
72820: LIST
72821: LIST
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: LIST
72827: LIST
72828: LIST
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: LIST
72838: LIST
72839: LIST
72840: LIST
72841: LIST
72842: LIST
72843: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72844: LD_ADDR_VAR 0 54
72848: PUSH
72849: LD_INT 0
72851: PUSH
72852: LD_INT 0
72854: PUSH
72855: EMPTY
72856: LIST
72857: LIST
72858: PUSH
72859: LD_INT 0
72861: PUSH
72862: LD_INT 1
72864: NEG
72865: PUSH
72866: EMPTY
72867: LIST
72868: LIST
72869: PUSH
72870: LD_INT 1
72872: PUSH
72873: LD_INT 0
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: PUSH
72880: LD_INT 1
72882: PUSH
72883: LD_INT 1
72885: PUSH
72886: EMPTY
72887: LIST
72888: LIST
72889: PUSH
72890: LD_INT 0
72892: PUSH
72893: LD_INT 1
72895: PUSH
72896: EMPTY
72897: LIST
72898: LIST
72899: PUSH
72900: LD_INT 1
72902: NEG
72903: PUSH
72904: LD_INT 0
72906: PUSH
72907: EMPTY
72908: LIST
72909: LIST
72910: PUSH
72911: LD_INT 1
72913: NEG
72914: PUSH
72915: LD_INT 1
72917: NEG
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PUSH
72923: LD_INT 1
72925: NEG
72926: PUSH
72927: LD_INT 2
72929: NEG
72930: PUSH
72931: EMPTY
72932: LIST
72933: LIST
72934: PUSH
72935: LD_INT 0
72937: PUSH
72938: LD_INT 2
72940: NEG
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: LD_INT 1
72948: PUSH
72949: LD_INT 1
72951: NEG
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: PUSH
72957: LD_INT 2
72959: PUSH
72960: LD_INT 0
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: LD_INT 2
72969: PUSH
72970: LD_INT 1
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: PUSH
72977: LD_INT 2
72979: PUSH
72980: LD_INT 2
72982: PUSH
72983: EMPTY
72984: LIST
72985: LIST
72986: PUSH
72987: LD_INT 1
72989: PUSH
72990: LD_INT 2
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: PUSH
72997: LD_INT 0
72999: PUSH
73000: LD_INT 2
73002: PUSH
73003: EMPTY
73004: LIST
73005: LIST
73006: PUSH
73007: LD_INT 1
73009: NEG
73010: PUSH
73011: LD_INT 1
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PUSH
73018: LD_INT 2
73020: NEG
73021: PUSH
73022: LD_INT 0
73024: PUSH
73025: EMPTY
73026: LIST
73027: LIST
73028: PUSH
73029: LD_INT 2
73031: NEG
73032: PUSH
73033: LD_INT 1
73035: NEG
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: PUSH
73041: LD_INT 2
73043: NEG
73044: PUSH
73045: LD_INT 2
73047: NEG
73048: PUSH
73049: EMPTY
73050: LIST
73051: LIST
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: LIST
73057: LIST
73058: LIST
73059: LIST
73060: LIST
73061: LIST
73062: LIST
73063: LIST
73064: LIST
73065: LIST
73066: LIST
73067: LIST
73068: LIST
73069: LIST
73070: LIST
73071: LIST
73072: LIST
73073: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73074: LD_ADDR_VAR 0 55
73078: PUSH
73079: LD_INT 0
73081: PUSH
73082: LD_INT 0
73084: PUSH
73085: EMPTY
73086: LIST
73087: LIST
73088: PUSH
73089: LD_INT 0
73091: PUSH
73092: LD_INT 1
73094: NEG
73095: PUSH
73096: EMPTY
73097: LIST
73098: LIST
73099: PUSH
73100: LD_INT 1
73102: PUSH
73103: LD_INT 0
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: PUSH
73110: LD_INT 1
73112: PUSH
73113: LD_INT 1
73115: PUSH
73116: EMPTY
73117: LIST
73118: LIST
73119: PUSH
73120: LD_INT 0
73122: PUSH
73123: LD_INT 1
73125: PUSH
73126: EMPTY
73127: LIST
73128: LIST
73129: PUSH
73130: LD_INT 1
73132: NEG
73133: PUSH
73134: LD_INT 0
73136: PUSH
73137: EMPTY
73138: LIST
73139: LIST
73140: PUSH
73141: LD_INT 1
73143: NEG
73144: PUSH
73145: LD_INT 1
73147: NEG
73148: PUSH
73149: EMPTY
73150: LIST
73151: LIST
73152: PUSH
73153: LD_INT 1
73155: NEG
73156: PUSH
73157: LD_INT 2
73159: NEG
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: LD_INT 0
73167: PUSH
73168: LD_INT 2
73170: NEG
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PUSH
73176: LD_INT 1
73178: PUSH
73179: LD_INT 1
73181: NEG
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: PUSH
73187: LD_INT 2
73189: PUSH
73190: LD_INT 0
73192: PUSH
73193: EMPTY
73194: LIST
73195: LIST
73196: PUSH
73197: LD_INT 2
73199: PUSH
73200: LD_INT 1
73202: PUSH
73203: EMPTY
73204: LIST
73205: LIST
73206: PUSH
73207: LD_INT 2
73209: PUSH
73210: LD_INT 2
73212: PUSH
73213: EMPTY
73214: LIST
73215: LIST
73216: PUSH
73217: LD_INT 1
73219: PUSH
73220: LD_INT 2
73222: PUSH
73223: EMPTY
73224: LIST
73225: LIST
73226: PUSH
73227: LD_INT 0
73229: PUSH
73230: LD_INT 2
73232: PUSH
73233: EMPTY
73234: LIST
73235: LIST
73236: PUSH
73237: LD_INT 1
73239: NEG
73240: PUSH
73241: LD_INT 1
73243: PUSH
73244: EMPTY
73245: LIST
73246: LIST
73247: PUSH
73248: LD_INT 2
73250: NEG
73251: PUSH
73252: LD_INT 0
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: PUSH
73259: LD_INT 2
73261: NEG
73262: PUSH
73263: LD_INT 1
73265: NEG
73266: PUSH
73267: EMPTY
73268: LIST
73269: LIST
73270: PUSH
73271: LD_INT 2
73273: NEG
73274: PUSH
73275: LD_INT 2
73277: NEG
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: PUSH
73283: EMPTY
73284: LIST
73285: LIST
73286: LIST
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: LIST
73294: LIST
73295: LIST
73296: LIST
73297: LIST
73298: LIST
73299: LIST
73300: LIST
73301: LIST
73302: LIST
73303: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73304: LD_ADDR_VAR 0 56
73308: PUSH
73309: LD_INT 0
73311: PUSH
73312: LD_INT 0
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PUSH
73319: LD_INT 0
73321: PUSH
73322: LD_INT 1
73324: NEG
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PUSH
73330: LD_INT 1
73332: PUSH
73333: LD_INT 0
73335: PUSH
73336: EMPTY
73337: LIST
73338: LIST
73339: PUSH
73340: LD_INT 1
73342: PUSH
73343: LD_INT 1
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: PUSH
73350: LD_INT 0
73352: PUSH
73353: LD_INT 1
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PUSH
73360: LD_INT 1
73362: NEG
73363: PUSH
73364: LD_INT 0
73366: PUSH
73367: EMPTY
73368: LIST
73369: LIST
73370: PUSH
73371: LD_INT 1
73373: NEG
73374: PUSH
73375: LD_INT 1
73377: NEG
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: PUSH
73383: LD_INT 1
73385: NEG
73386: PUSH
73387: LD_INT 2
73389: NEG
73390: PUSH
73391: EMPTY
73392: LIST
73393: LIST
73394: PUSH
73395: LD_INT 0
73397: PUSH
73398: LD_INT 2
73400: NEG
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: PUSH
73406: LD_INT 1
73408: PUSH
73409: LD_INT 1
73411: NEG
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: PUSH
73417: LD_INT 2
73419: PUSH
73420: LD_INT 0
73422: PUSH
73423: EMPTY
73424: LIST
73425: LIST
73426: PUSH
73427: LD_INT 2
73429: PUSH
73430: LD_INT 1
73432: PUSH
73433: EMPTY
73434: LIST
73435: LIST
73436: PUSH
73437: LD_INT 2
73439: PUSH
73440: LD_INT 2
73442: PUSH
73443: EMPTY
73444: LIST
73445: LIST
73446: PUSH
73447: LD_INT 1
73449: PUSH
73450: LD_INT 2
73452: PUSH
73453: EMPTY
73454: LIST
73455: LIST
73456: PUSH
73457: LD_INT 0
73459: PUSH
73460: LD_INT 2
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: PUSH
73467: LD_INT 1
73469: NEG
73470: PUSH
73471: LD_INT 1
73473: PUSH
73474: EMPTY
73475: LIST
73476: LIST
73477: PUSH
73478: LD_INT 2
73480: NEG
73481: PUSH
73482: LD_INT 0
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: PUSH
73489: LD_INT 2
73491: NEG
73492: PUSH
73493: LD_INT 1
73495: NEG
73496: PUSH
73497: EMPTY
73498: LIST
73499: LIST
73500: PUSH
73501: LD_INT 2
73503: NEG
73504: PUSH
73505: LD_INT 2
73507: NEG
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: LIST
73527: LIST
73528: LIST
73529: LIST
73530: LIST
73531: LIST
73532: LIST
73533: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73534: LD_ADDR_VAR 0 57
73538: PUSH
73539: LD_INT 0
73541: PUSH
73542: LD_INT 0
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: PUSH
73549: LD_INT 0
73551: PUSH
73552: LD_INT 1
73554: NEG
73555: PUSH
73556: EMPTY
73557: LIST
73558: LIST
73559: PUSH
73560: LD_INT 1
73562: PUSH
73563: LD_INT 0
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PUSH
73570: LD_INT 1
73572: PUSH
73573: LD_INT 1
73575: PUSH
73576: EMPTY
73577: LIST
73578: LIST
73579: PUSH
73580: LD_INT 0
73582: PUSH
73583: LD_INT 1
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: PUSH
73590: LD_INT 1
73592: NEG
73593: PUSH
73594: LD_INT 0
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: PUSH
73601: LD_INT 1
73603: NEG
73604: PUSH
73605: LD_INT 1
73607: NEG
73608: PUSH
73609: EMPTY
73610: LIST
73611: LIST
73612: PUSH
73613: LD_INT 1
73615: NEG
73616: PUSH
73617: LD_INT 2
73619: NEG
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: PUSH
73625: LD_INT 0
73627: PUSH
73628: LD_INT 2
73630: NEG
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 1
73638: PUSH
73639: LD_INT 1
73641: NEG
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 2
73649: PUSH
73650: LD_INT 0
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: PUSH
73657: LD_INT 2
73659: PUSH
73660: LD_INT 1
73662: PUSH
73663: EMPTY
73664: LIST
73665: LIST
73666: PUSH
73667: LD_INT 2
73669: PUSH
73670: LD_INT 2
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: LD_INT 1
73679: PUSH
73680: LD_INT 2
73682: PUSH
73683: EMPTY
73684: LIST
73685: LIST
73686: PUSH
73687: LD_INT 0
73689: PUSH
73690: LD_INT 2
73692: PUSH
73693: EMPTY
73694: LIST
73695: LIST
73696: PUSH
73697: LD_INT 1
73699: NEG
73700: PUSH
73701: LD_INT 1
73703: PUSH
73704: EMPTY
73705: LIST
73706: LIST
73707: PUSH
73708: LD_INT 2
73710: NEG
73711: PUSH
73712: LD_INT 0
73714: PUSH
73715: EMPTY
73716: LIST
73717: LIST
73718: PUSH
73719: LD_INT 2
73721: NEG
73722: PUSH
73723: LD_INT 1
73725: NEG
73726: PUSH
73727: EMPTY
73728: LIST
73729: LIST
73730: PUSH
73731: LD_INT 2
73733: NEG
73734: PUSH
73735: LD_INT 2
73737: NEG
73738: PUSH
73739: EMPTY
73740: LIST
73741: LIST
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: LIST
73747: LIST
73748: LIST
73749: LIST
73750: LIST
73751: LIST
73752: LIST
73753: LIST
73754: LIST
73755: LIST
73756: LIST
73757: LIST
73758: LIST
73759: LIST
73760: LIST
73761: LIST
73762: LIST
73763: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73764: LD_ADDR_VAR 0 58
73768: PUSH
73769: LD_INT 0
73771: PUSH
73772: LD_INT 0
73774: PUSH
73775: EMPTY
73776: LIST
73777: LIST
73778: PUSH
73779: LD_INT 0
73781: PUSH
73782: LD_INT 1
73784: NEG
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: PUSH
73790: LD_INT 1
73792: PUSH
73793: LD_INT 0
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PUSH
73800: LD_INT 1
73802: PUSH
73803: LD_INT 1
73805: PUSH
73806: EMPTY
73807: LIST
73808: LIST
73809: PUSH
73810: LD_INT 0
73812: PUSH
73813: LD_INT 1
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: PUSH
73820: LD_INT 1
73822: NEG
73823: PUSH
73824: LD_INT 0
73826: PUSH
73827: EMPTY
73828: LIST
73829: LIST
73830: PUSH
73831: LD_INT 1
73833: NEG
73834: PUSH
73835: LD_INT 1
73837: NEG
73838: PUSH
73839: EMPTY
73840: LIST
73841: LIST
73842: PUSH
73843: LD_INT 1
73845: NEG
73846: PUSH
73847: LD_INT 2
73849: NEG
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: PUSH
73855: LD_INT 0
73857: PUSH
73858: LD_INT 2
73860: NEG
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: LD_INT 1
73868: PUSH
73869: LD_INT 1
73871: NEG
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: PUSH
73877: LD_INT 2
73879: PUSH
73880: LD_INT 0
73882: PUSH
73883: EMPTY
73884: LIST
73885: LIST
73886: PUSH
73887: LD_INT 2
73889: PUSH
73890: LD_INT 1
73892: PUSH
73893: EMPTY
73894: LIST
73895: LIST
73896: PUSH
73897: LD_INT 2
73899: PUSH
73900: LD_INT 2
73902: PUSH
73903: EMPTY
73904: LIST
73905: LIST
73906: PUSH
73907: LD_INT 1
73909: PUSH
73910: LD_INT 2
73912: PUSH
73913: EMPTY
73914: LIST
73915: LIST
73916: PUSH
73917: LD_INT 0
73919: PUSH
73920: LD_INT 2
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 1
73929: NEG
73930: PUSH
73931: LD_INT 1
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: PUSH
73938: LD_INT 2
73940: NEG
73941: PUSH
73942: LD_INT 0
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: PUSH
73949: LD_INT 2
73951: NEG
73952: PUSH
73953: LD_INT 1
73955: NEG
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 2
73963: NEG
73964: PUSH
73965: LD_INT 2
73967: NEG
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: LIST
73977: LIST
73978: LIST
73979: LIST
73980: LIST
73981: LIST
73982: LIST
73983: LIST
73984: LIST
73985: LIST
73986: LIST
73987: LIST
73988: LIST
73989: LIST
73990: LIST
73991: LIST
73992: LIST
73993: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73994: LD_ADDR_VAR 0 59
73998: PUSH
73999: LD_INT 0
74001: PUSH
74002: LD_INT 0
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: LD_INT 0
74011: PUSH
74012: LD_INT 1
74014: NEG
74015: PUSH
74016: EMPTY
74017: LIST
74018: LIST
74019: PUSH
74020: LD_INT 1
74022: PUSH
74023: LD_INT 0
74025: PUSH
74026: EMPTY
74027: LIST
74028: LIST
74029: PUSH
74030: LD_INT 1
74032: PUSH
74033: LD_INT 1
74035: PUSH
74036: EMPTY
74037: LIST
74038: LIST
74039: PUSH
74040: LD_INT 0
74042: PUSH
74043: LD_INT 1
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: PUSH
74050: LD_INT 1
74052: NEG
74053: PUSH
74054: LD_INT 0
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: PUSH
74061: LD_INT 1
74063: NEG
74064: PUSH
74065: LD_INT 1
74067: NEG
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: PUSH
74073: EMPTY
74074: LIST
74075: LIST
74076: LIST
74077: LIST
74078: LIST
74079: LIST
74080: LIST
74081: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74082: LD_ADDR_VAR 0 60
74086: PUSH
74087: LD_INT 0
74089: PUSH
74090: LD_INT 0
74092: PUSH
74093: EMPTY
74094: LIST
74095: LIST
74096: PUSH
74097: LD_INT 0
74099: PUSH
74100: LD_INT 1
74102: NEG
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PUSH
74108: LD_INT 1
74110: PUSH
74111: LD_INT 0
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: PUSH
74118: LD_INT 1
74120: PUSH
74121: LD_INT 1
74123: PUSH
74124: EMPTY
74125: LIST
74126: LIST
74127: PUSH
74128: LD_INT 0
74130: PUSH
74131: LD_INT 1
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 1
74140: NEG
74141: PUSH
74142: LD_INT 0
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 1
74151: NEG
74152: PUSH
74153: LD_INT 1
74155: NEG
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: LIST
74165: LIST
74166: LIST
74167: LIST
74168: LIST
74169: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74170: LD_ADDR_VAR 0 61
74174: PUSH
74175: LD_INT 0
74177: PUSH
74178: LD_INT 0
74180: PUSH
74181: EMPTY
74182: LIST
74183: LIST
74184: PUSH
74185: LD_INT 0
74187: PUSH
74188: LD_INT 1
74190: NEG
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: LD_INT 1
74198: PUSH
74199: LD_INT 0
74201: PUSH
74202: EMPTY
74203: LIST
74204: LIST
74205: PUSH
74206: LD_INT 1
74208: PUSH
74209: LD_INT 1
74211: PUSH
74212: EMPTY
74213: LIST
74214: LIST
74215: PUSH
74216: LD_INT 0
74218: PUSH
74219: LD_INT 1
74221: PUSH
74222: EMPTY
74223: LIST
74224: LIST
74225: PUSH
74226: LD_INT 1
74228: NEG
74229: PUSH
74230: LD_INT 0
74232: PUSH
74233: EMPTY
74234: LIST
74235: LIST
74236: PUSH
74237: LD_INT 1
74239: NEG
74240: PUSH
74241: LD_INT 1
74243: NEG
74244: PUSH
74245: EMPTY
74246: LIST
74247: LIST
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: LIST
74253: LIST
74254: LIST
74255: LIST
74256: LIST
74257: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74258: LD_ADDR_VAR 0 62
74262: PUSH
74263: LD_INT 0
74265: PUSH
74266: LD_INT 0
74268: PUSH
74269: EMPTY
74270: LIST
74271: LIST
74272: PUSH
74273: LD_INT 0
74275: PUSH
74276: LD_INT 1
74278: NEG
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: LD_INT 1
74286: PUSH
74287: LD_INT 0
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PUSH
74294: LD_INT 1
74296: PUSH
74297: LD_INT 1
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: LD_INT 0
74306: PUSH
74307: LD_INT 1
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: PUSH
74314: LD_INT 1
74316: NEG
74317: PUSH
74318: LD_INT 0
74320: PUSH
74321: EMPTY
74322: LIST
74323: LIST
74324: PUSH
74325: LD_INT 1
74327: NEG
74328: PUSH
74329: LD_INT 1
74331: NEG
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: LIST
74341: LIST
74342: LIST
74343: LIST
74344: LIST
74345: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74346: LD_ADDR_VAR 0 63
74350: PUSH
74351: LD_INT 0
74353: PUSH
74354: LD_INT 0
74356: PUSH
74357: EMPTY
74358: LIST
74359: LIST
74360: PUSH
74361: LD_INT 0
74363: PUSH
74364: LD_INT 1
74366: NEG
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: PUSH
74372: LD_INT 1
74374: PUSH
74375: LD_INT 0
74377: PUSH
74378: EMPTY
74379: LIST
74380: LIST
74381: PUSH
74382: LD_INT 1
74384: PUSH
74385: LD_INT 1
74387: PUSH
74388: EMPTY
74389: LIST
74390: LIST
74391: PUSH
74392: LD_INT 0
74394: PUSH
74395: LD_INT 1
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: PUSH
74402: LD_INT 1
74404: NEG
74405: PUSH
74406: LD_INT 0
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: LD_INT 1
74415: NEG
74416: PUSH
74417: LD_INT 1
74419: NEG
74420: PUSH
74421: EMPTY
74422: LIST
74423: LIST
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: LIST
74429: LIST
74430: LIST
74431: LIST
74432: LIST
74433: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74434: LD_ADDR_VAR 0 64
74438: PUSH
74439: LD_INT 0
74441: PUSH
74442: LD_INT 0
74444: PUSH
74445: EMPTY
74446: LIST
74447: LIST
74448: PUSH
74449: LD_INT 0
74451: PUSH
74452: LD_INT 1
74454: NEG
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PUSH
74460: LD_INT 1
74462: PUSH
74463: LD_INT 0
74465: PUSH
74466: EMPTY
74467: LIST
74468: LIST
74469: PUSH
74470: LD_INT 1
74472: PUSH
74473: LD_INT 1
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: PUSH
74480: LD_INT 0
74482: PUSH
74483: LD_INT 1
74485: PUSH
74486: EMPTY
74487: LIST
74488: LIST
74489: PUSH
74490: LD_INT 1
74492: NEG
74493: PUSH
74494: LD_INT 0
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: PUSH
74501: LD_INT 1
74503: NEG
74504: PUSH
74505: LD_INT 1
74507: NEG
74508: PUSH
74509: EMPTY
74510: LIST
74511: LIST
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: LIST
74517: LIST
74518: LIST
74519: LIST
74520: LIST
74521: ST_TO_ADDR
// end ; 1 :
74522: GO 80419
74524: LD_INT 1
74526: DOUBLE
74527: EQUAL
74528: IFTRUE 74532
74530: GO 77155
74532: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74533: LD_ADDR_VAR 0 11
74537: PUSH
74538: LD_INT 1
74540: NEG
74541: PUSH
74542: LD_INT 3
74544: NEG
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 0
74552: PUSH
74553: LD_INT 3
74555: NEG
74556: PUSH
74557: EMPTY
74558: LIST
74559: LIST
74560: PUSH
74561: LD_INT 1
74563: PUSH
74564: LD_INT 2
74566: NEG
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: LIST
74576: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74577: LD_ADDR_VAR 0 12
74581: PUSH
74582: LD_INT 2
74584: PUSH
74585: LD_INT 1
74587: NEG
74588: PUSH
74589: EMPTY
74590: LIST
74591: LIST
74592: PUSH
74593: LD_INT 3
74595: PUSH
74596: LD_INT 0
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: PUSH
74603: LD_INT 3
74605: PUSH
74606: LD_INT 1
74608: PUSH
74609: EMPTY
74610: LIST
74611: LIST
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: LIST
74617: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74618: LD_ADDR_VAR 0 13
74622: PUSH
74623: LD_INT 3
74625: PUSH
74626: LD_INT 2
74628: PUSH
74629: EMPTY
74630: LIST
74631: LIST
74632: PUSH
74633: LD_INT 3
74635: PUSH
74636: LD_INT 3
74638: PUSH
74639: EMPTY
74640: LIST
74641: LIST
74642: PUSH
74643: LD_INT 2
74645: PUSH
74646: LD_INT 3
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: LIST
74657: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74658: LD_ADDR_VAR 0 14
74662: PUSH
74663: LD_INT 1
74665: PUSH
74666: LD_INT 3
74668: PUSH
74669: EMPTY
74670: LIST
74671: LIST
74672: PUSH
74673: LD_INT 0
74675: PUSH
74676: LD_INT 3
74678: PUSH
74679: EMPTY
74680: LIST
74681: LIST
74682: PUSH
74683: LD_INT 1
74685: NEG
74686: PUSH
74687: LD_INT 2
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: EMPTY
74695: LIST
74696: LIST
74697: LIST
74698: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74699: LD_ADDR_VAR 0 15
74703: PUSH
74704: LD_INT 2
74706: NEG
74707: PUSH
74708: LD_INT 1
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: PUSH
74715: LD_INT 3
74717: NEG
74718: PUSH
74719: LD_INT 0
74721: PUSH
74722: EMPTY
74723: LIST
74724: LIST
74725: PUSH
74726: LD_INT 3
74728: NEG
74729: PUSH
74730: LD_INT 1
74732: NEG
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: EMPTY
74739: LIST
74740: LIST
74741: LIST
74742: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74743: LD_ADDR_VAR 0 16
74747: PUSH
74748: LD_INT 2
74750: NEG
74751: PUSH
74752: LD_INT 3
74754: NEG
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: PUSH
74760: LD_INT 3
74762: NEG
74763: PUSH
74764: LD_INT 2
74766: NEG
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: PUSH
74772: LD_INT 3
74774: NEG
74775: PUSH
74776: LD_INT 3
74778: NEG
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: PUSH
74784: EMPTY
74785: LIST
74786: LIST
74787: LIST
74788: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74789: LD_ADDR_VAR 0 17
74793: PUSH
74794: LD_INT 1
74796: NEG
74797: PUSH
74798: LD_INT 3
74800: NEG
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: PUSH
74806: LD_INT 0
74808: PUSH
74809: LD_INT 3
74811: NEG
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: PUSH
74817: LD_INT 1
74819: PUSH
74820: LD_INT 2
74822: NEG
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: LIST
74832: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74833: LD_ADDR_VAR 0 18
74837: PUSH
74838: LD_INT 2
74840: PUSH
74841: LD_INT 1
74843: NEG
74844: PUSH
74845: EMPTY
74846: LIST
74847: LIST
74848: PUSH
74849: LD_INT 3
74851: PUSH
74852: LD_INT 0
74854: PUSH
74855: EMPTY
74856: LIST
74857: LIST
74858: PUSH
74859: LD_INT 3
74861: PUSH
74862: LD_INT 1
74864: PUSH
74865: EMPTY
74866: LIST
74867: LIST
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: LIST
74873: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74874: LD_ADDR_VAR 0 19
74878: PUSH
74879: LD_INT 3
74881: PUSH
74882: LD_INT 2
74884: PUSH
74885: EMPTY
74886: LIST
74887: LIST
74888: PUSH
74889: LD_INT 3
74891: PUSH
74892: LD_INT 3
74894: PUSH
74895: EMPTY
74896: LIST
74897: LIST
74898: PUSH
74899: LD_INT 2
74901: PUSH
74902: LD_INT 3
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: LIST
74913: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74914: LD_ADDR_VAR 0 20
74918: PUSH
74919: LD_INT 1
74921: PUSH
74922: LD_INT 3
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: LD_INT 0
74931: PUSH
74932: LD_INT 3
74934: PUSH
74935: EMPTY
74936: LIST
74937: LIST
74938: PUSH
74939: LD_INT 1
74941: NEG
74942: PUSH
74943: LD_INT 2
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: LIST
74954: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74955: LD_ADDR_VAR 0 21
74959: PUSH
74960: LD_INT 2
74962: NEG
74963: PUSH
74964: LD_INT 1
74966: PUSH
74967: EMPTY
74968: LIST
74969: LIST
74970: PUSH
74971: LD_INT 3
74973: NEG
74974: PUSH
74975: LD_INT 0
74977: PUSH
74978: EMPTY
74979: LIST
74980: LIST
74981: PUSH
74982: LD_INT 3
74984: NEG
74985: PUSH
74986: LD_INT 1
74988: NEG
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: LIST
74998: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74999: LD_ADDR_VAR 0 22
75003: PUSH
75004: LD_INT 2
75006: NEG
75007: PUSH
75008: LD_INT 3
75010: NEG
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PUSH
75016: LD_INT 3
75018: NEG
75019: PUSH
75020: LD_INT 2
75022: NEG
75023: PUSH
75024: EMPTY
75025: LIST
75026: LIST
75027: PUSH
75028: LD_INT 3
75030: NEG
75031: PUSH
75032: LD_INT 3
75034: NEG
75035: PUSH
75036: EMPTY
75037: LIST
75038: LIST
75039: PUSH
75040: EMPTY
75041: LIST
75042: LIST
75043: LIST
75044: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75045: LD_ADDR_VAR 0 23
75049: PUSH
75050: LD_INT 0
75052: PUSH
75053: LD_INT 3
75055: NEG
75056: PUSH
75057: EMPTY
75058: LIST
75059: LIST
75060: PUSH
75061: LD_INT 1
75063: NEG
75064: PUSH
75065: LD_INT 4
75067: NEG
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: PUSH
75073: LD_INT 1
75075: PUSH
75076: LD_INT 3
75078: NEG
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: LIST
75088: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75089: LD_ADDR_VAR 0 24
75093: PUSH
75094: LD_INT 3
75096: PUSH
75097: LD_INT 0
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: PUSH
75104: LD_INT 3
75106: PUSH
75107: LD_INT 1
75109: NEG
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PUSH
75115: LD_INT 4
75117: PUSH
75118: LD_INT 1
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: LIST
75129: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75130: LD_ADDR_VAR 0 25
75134: PUSH
75135: LD_INT 3
75137: PUSH
75138: LD_INT 3
75140: PUSH
75141: EMPTY
75142: LIST
75143: LIST
75144: PUSH
75145: LD_INT 4
75147: PUSH
75148: LD_INT 3
75150: PUSH
75151: EMPTY
75152: LIST
75153: LIST
75154: PUSH
75155: LD_INT 3
75157: PUSH
75158: LD_INT 4
75160: PUSH
75161: EMPTY
75162: LIST
75163: LIST
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: LIST
75169: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75170: LD_ADDR_VAR 0 26
75174: PUSH
75175: LD_INT 0
75177: PUSH
75178: LD_INT 3
75180: PUSH
75181: EMPTY
75182: LIST
75183: LIST
75184: PUSH
75185: LD_INT 1
75187: PUSH
75188: LD_INT 4
75190: PUSH
75191: EMPTY
75192: LIST
75193: LIST
75194: PUSH
75195: LD_INT 1
75197: NEG
75198: PUSH
75199: LD_INT 3
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: LIST
75210: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75211: LD_ADDR_VAR 0 27
75215: PUSH
75216: LD_INT 3
75218: NEG
75219: PUSH
75220: LD_INT 0
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: LD_INT 3
75229: NEG
75230: PUSH
75231: LD_INT 1
75233: PUSH
75234: EMPTY
75235: LIST
75236: LIST
75237: PUSH
75238: LD_INT 4
75240: NEG
75241: PUSH
75242: LD_INT 1
75244: NEG
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: LIST
75254: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75255: LD_ADDR_VAR 0 28
75259: PUSH
75260: LD_INT 3
75262: NEG
75263: PUSH
75264: LD_INT 3
75266: NEG
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PUSH
75272: LD_INT 3
75274: NEG
75275: PUSH
75276: LD_INT 4
75278: NEG
75279: PUSH
75280: EMPTY
75281: LIST
75282: LIST
75283: PUSH
75284: LD_INT 4
75286: NEG
75287: PUSH
75288: LD_INT 3
75290: NEG
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: LIST
75300: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75301: LD_ADDR_VAR 0 29
75305: PUSH
75306: LD_INT 1
75308: NEG
75309: PUSH
75310: LD_INT 3
75312: NEG
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PUSH
75318: LD_INT 0
75320: PUSH
75321: LD_INT 3
75323: NEG
75324: PUSH
75325: EMPTY
75326: LIST
75327: LIST
75328: PUSH
75329: LD_INT 1
75331: PUSH
75332: LD_INT 2
75334: NEG
75335: PUSH
75336: EMPTY
75337: LIST
75338: LIST
75339: PUSH
75340: LD_INT 1
75342: NEG
75343: PUSH
75344: LD_INT 4
75346: NEG
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: LD_INT 0
75354: PUSH
75355: LD_INT 4
75357: NEG
75358: PUSH
75359: EMPTY
75360: LIST
75361: LIST
75362: PUSH
75363: LD_INT 1
75365: PUSH
75366: LD_INT 3
75368: NEG
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: PUSH
75374: LD_INT 1
75376: NEG
75377: PUSH
75378: LD_INT 5
75380: NEG
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 0
75388: PUSH
75389: LD_INT 5
75391: NEG
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PUSH
75397: LD_INT 1
75399: PUSH
75400: LD_INT 4
75402: NEG
75403: PUSH
75404: EMPTY
75405: LIST
75406: LIST
75407: PUSH
75408: LD_INT 1
75410: NEG
75411: PUSH
75412: LD_INT 6
75414: NEG
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 0
75422: PUSH
75423: LD_INT 6
75425: NEG
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: LD_INT 1
75433: PUSH
75434: LD_INT 5
75436: NEG
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: EMPTY
75443: LIST
75444: LIST
75445: LIST
75446: LIST
75447: LIST
75448: LIST
75449: LIST
75450: LIST
75451: LIST
75452: LIST
75453: LIST
75454: LIST
75455: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75456: LD_ADDR_VAR 0 30
75460: PUSH
75461: LD_INT 2
75463: PUSH
75464: LD_INT 1
75466: NEG
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: PUSH
75472: LD_INT 3
75474: PUSH
75475: LD_INT 0
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: PUSH
75482: LD_INT 3
75484: PUSH
75485: LD_INT 1
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: PUSH
75492: LD_INT 3
75494: PUSH
75495: LD_INT 1
75497: NEG
75498: PUSH
75499: EMPTY
75500: LIST
75501: LIST
75502: PUSH
75503: LD_INT 4
75505: PUSH
75506: LD_INT 0
75508: PUSH
75509: EMPTY
75510: LIST
75511: LIST
75512: PUSH
75513: LD_INT 4
75515: PUSH
75516: LD_INT 1
75518: PUSH
75519: EMPTY
75520: LIST
75521: LIST
75522: PUSH
75523: LD_INT 4
75525: PUSH
75526: LD_INT 1
75528: NEG
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: PUSH
75534: LD_INT 5
75536: PUSH
75537: LD_INT 0
75539: PUSH
75540: EMPTY
75541: LIST
75542: LIST
75543: PUSH
75544: LD_INT 5
75546: PUSH
75547: LD_INT 1
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PUSH
75554: LD_INT 5
75556: PUSH
75557: LD_INT 1
75559: NEG
75560: PUSH
75561: EMPTY
75562: LIST
75563: LIST
75564: PUSH
75565: LD_INT 6
75567: PUSH
75568: LD_INT 0
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: PUSH
75575: LD_INT 6
75577: PUSH
75578: LD_INT 1
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PUSH
75585: EMPTY
75586: LIST
75587: LIST
75588: LIST
75589: LIST
75590: LIST
75591: LIST
75592: LIST
75593: LIST
75594: LIST
75595: LIST
75596: LIST
75597: LIST
75598: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75599: LD_ADDR_VAR 0 31
75603: PUSH
75604: LD_INT 3
75606: PUSH
75607: LD_INT 2
75609: PUSH
75610: EMPTY
75611: LIST
75612: LIST
75613: PUSH
75614: LD_INT 3
75616: PUSH
75617: LD_INT 3
75619: PUSH
75620: EMPTY
75621: LIST
75622: LIST
75623: PUSH
75624: LD_INT 2
75626: PUSH
75627: LD_INT 3
75629: PUSH
75630: EMPTY
75631: LIST
75632: LIST
75633: PUSH
75634: LD_INT 4
75636: PUSH
75637: LD_INT 3
75639: PUSH
75640: EMPTY
75641: LIST
75642: LIST
75643: PUSH
75644: LD_INT 4
75646: PUSH
75647: LD_INT 4
75649: PUSH
75650: EMPTY
75651: LIST
75652: LIST
75653: PUSH
75654: LD_INT 3
75656: PUSH
75657: LD_INT 4
75659: PUSH
75660: EMPTY
75661: LIST
75662: LIST
75663: PUSH
75664: LD_INT 5
75666: PUSH
75667: LD_INT 4
75669: PUSH
75670: EMPTY
75671: LIST
75672: LIST
75673: PUSH
75674: LD_INT 5
75676: PUSH
75677: LD_INT 5
75679: PUSH
75680: EMPTY
75681: LIST
75682: LIST
75683: PUSH
75684: LD_INT 4
75686: PUSH
75687: LD_INT 5
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: PUSH
75694: LD_INT 6
75696: PUSH
75697: LD_INT 5
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: PUSH
75704: LD_INT 6
75706: PUSH
75707: LD_INT 6
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PUSH
75714: LD_INT 5
75716: PUSH
75717: LD_INT 6
75719: PUSH
75720: EMPTY
75721: LIST
75722: LIST
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: LIST
75728: LIST
75729: LIST
75730: LIST
75731: LIST
75732: LIST
75733: LIST
75734: LIST
75735: LIST
75736: LIST
75737: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75738: LD_ADDR_VAR 0 32
75742: PUSH
75743: LD_INT 1
75745: PUSH
75746: LD_INT 3
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: PUSH
75753: LD_INT 0
75755: PUSH
75756: LD_INT 3
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: LD_INT 1
75765: NEG
75766: PUSH
75767: LD_INT 2
75769: PUSH
75770: EMPTY
75771: LIST
75772: LIST
75773: PUSH
75774: LD_INT 1
75776: PUSH
75777: LD_INT 4
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PUSH
75784: LD_INT 0
75786: PUSH
75787: LD_INT 4
75789: PUSH
75790: EMPTY
75791: LIST
75792: LIST
75793: PUSH
75794: LD_INT 1
75796: NEG
75797: PUSH
75798: LD_INT 3
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: PUSH
75805: LD_INT 1
75807: PUSH
75808: LD_INT 5
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: LD_INT 0
75817: PUSH
75818: LD_INT 5
75820: PUSH
75821: EMPTY
75822: LIST
75823: LIST
75824: PUSH
75825: LD_INT 1
75827: NEG
75828: PUSH
75829: LD_INT 4
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 1
75838: PUSH
75839: LD_INT 6
75841: PUSH
75842: EMPTY
75843: LIST
75844: LIST
75845: PUSH
75846: LD_INT 0
75848: PUSH
75849: LD_INT 6
75851: PUSH
75852: EMPTY
75853: LIST
75854: LIST
75855: PUSH
75856: LD_INT 1
75858: NEG
75859: PUSH
75860: LD_INT 5
75862: PUSH
75863: EMPTY
75864: LIST
75865: LIST
75866: PUSH
75867: EMPTY
75868: LIST
75869: LIST
75870: LIST
75871: LIST
75872: LIST
75873: LIST
75874: LIST
75875: LIST
75876: LIST
75877: LIST
75878: LIST
75879: LIST
75880: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75881: LD_ADDR_VAR 0 33
75885: PUSH
75886: LD_INT 2
75888: NEG
75889: PUSH
75890: LD_INT 1
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: LD_INT 3
75899: NEG
75900: PUSH
75901: LD_INT 0
75903: PUSH
75904: EMPTY
75905: LIST
75906: LIST
75907: PUSH
75908: LD_INT 3
75910: NEG
75911: PUSH
75912: LD_INT 1
75914: NEG
75915: PUSH
75916: EMPTY
75917: LIST
75918: LIST
75919: PUSH
75920: LD_INT 3
75922: NEG
75923: PUSH
75924: LD_INT 1
75926: PUSH
75927: EMPTY
75928: LIST
75929: LIST
75930: PUSH
75931: LD_INT 4
75933: NEG
75934: PUSH
75935: LD_INT 0
75937: PUSH
75938: EMPTY
75939: LIST
75940: LIST
75941: PUSH
75942: LD_INT 4
75944: NEG
75945: PUSH
75946: LD_INT 1
75948: NEG
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: LD_INT 4
75956: NEG
75957: PUSH
75958: LD_INT 1
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 5
75967: NEG
75968: PUSH
75969: LD_INT 0
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: PUSH
75976: LD_INT 5
75978: NEG
75979: PUSH
75980: LD_INT 1
75982: NEG
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PUSH
75988: LD_INT 5
75990: NEG
75991: PUSH
75992: LD_INT 1
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: PUSH
75999: LD_INT 6
76001: NEG
76002: PUSH
76003: LD_INT 0
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: LD_INT 6
76012: NEG
76013: PUSH
76014: LD_INT 1
76016: NEG
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: EMPTY
76023: LIST
76024: LIST
76025: LIST
76026: LIST
76027: LIST
76028: LIST
76029: LIST
76030: LIST
76031: LIST
76032: LIST
76033: LIST
76034: LIST
76035: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76036: LD_ADDR_VAR 0 34
76040: PUSH
76041: LD_INT 2
76043: NEG
76044: PUSH
76045: LD_INT 3
76047: NEG
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: LD_INT 3
76055: NEG
76056: PUSH
76057: LD_INT 2
76059: NEG
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: LD_INT 3
76067: NEG
76068: PUSH
76069: LD_INT 3
76071: NEG
76072: PUSH
76073: EMPTY
76074: LIST
76075: LIST
76076: PUSH
76077: LD_INT 3
76079: NEG
76080: PUSH
76081: LD_INT 4
76083: NEG
76084: PUSH
76085: EMPTY
76086: LIST
76087: LIST
76088: PUSH
76089: LD_INT 4
76091: NEG
76092: PUSH
76093: LD_INT 3
76095: NEG
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PUSH
76101: LD_INT 4
76103: NEG
76104: PUSH
76105: LD_INT 4
76107: NEG
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 4
76115: NEG
76116: PUSH
76117: LD_INT 5
76119: NEG
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: PUSH
76125: LD_INT 5
76127: NEG
76128: PUSH
76129: LD_INT 4
76131: NEG
76132: PUSH
76133: EMPTY
76134: LIST
76135: LIST
76136: PUSH
76137: LD_INT 5
76139: NEG
76140: PUSH
76141: LD_INT 5
76143: NEG
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: PUSH
76149: LD_INT 5
76151: NEG
76152: PUSH
76153: LD_INT 6
76155: NEG
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: LD_INT 6
76163: NEG
76164: PUSH
76165: LD_INT 5
76167: NEG
76168: PUSH
76169: EMPTY
76170: LIST
76171: LIST
76172: PUSH
76173: LD_INT 6
76175: NEG
76176: PUSH
76177: LD_INT 6
76179: NEG
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: PUSH
76185: EMPTY
76186: LIST
76187: LIST
76188: LIST
76189: LIST
76190: LIST
76191: LIST
76192: LIST
76193: LIST
76194: LIST
76195: LIST
76196: LIST
76197: LIST
76198: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76199: LD_ADDR_VAR 0 41
76203: PUSH
76204: LD_INT 0
76206: PUSH
76207: LD_INT 2
76209: NEG
76210: PUSH
76211: EMPTY
76212: LIST
76213: LIST
76214: PUSH
76215: LD_INT 1
76217: NEG
76218: PUSH
76219: LD_INT 3
76221: NEG
76222: PUSH
76223: EMPTY
76224: LIST
76225: LIST
76226: PUSH
76227: LD_INT 1
76229: PUSH
76230: LD_INT 2
76232: NEG
76233: PUSH
76234: EMPTY
76235: LIST
76236: LIST
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: LIST
76242: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76243: LD_ADDR_VAR 0 42
76247: PUSH
76248: LD_INT 2
76250: PUSH
76251: LD_INT 0
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: PUSH
76258: LD_INT 2
76260: PUSH
76261: LD_INT 1
76263: NEG
76264: PUSH
76265: EMPTY
76266: LIST
76267: LIST
76268: PUSH
76269: LD_INT 3
76271: PUSH
76272: LD_INT 1
76274: PUSH
76275: EMPTY
76276: LIST
76277: LIST
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: LIST
76283: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76284: LD_ADDR_VAR 0 43
76288: PUSH
76289: LD_INT 2
76291: PUSH
76292: LD_INT 2
76294: PUSH
76295: EMPTY
76296: LIST
76297: LIST
76298: PUSH
76299: LD_INT 3
76301: PUSH
76302: LD_INT 2
76304: PUSH
76305: EMPTY
76306: LIST
76307: LIST
76308: PUSH
76309: LD_INT 2
76311: PUSH
76312: LD_INT 3
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PUSH
76319: EMPTY
76320: LIST
76321: LIST
76322: LIST
76323: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76324: LD_ADDR_VAR 0 44
76328: PUSH
76329: LD_INT 0
76331: PUSH
76332: LD_INT 2
76334: PUSH
76335: EMPTY
76336: LIST
76337: LIST
76338: PUSH
76339: LD_INT 1
76341: PUSH
76342: LD_INT 3
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: PUSH
76349: LD_INT 1
76351: NEG
76352: PUSH
76353: LD_INT 2
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: PUSH
76360: EMPTY
76361: LIST
76362: LIST
76363: LIST
76364: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76365: LD_ADDR_VAR 0 45
76369: PUSH
76370: LD_INT 2
76372: NEG
76373: PUSH
76374: LD_INT 0
76376: PUSH
76377: EMPTY
76378: LIST
76379: LIST
76380: PUSH
76381: LD_INT 2
76383: NEG
76384: PUSH
76385: LD_INT 1
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: PUSH
76392: LD_INT 3
76394: NEG
76395: PUSH
76396: LD_INT 1
76398: NEG
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: EMPTY
76405: LIST
76406: LIST
76407: LIST
76408: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76409: LD_ADDR_VAR 0 46
76413: PUSH
76414: LD_INT 2
76416: NEG
76417: PUSH
76418: LD_INT 2
76420: NEG
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: PUSH
76426: LD_INT 2
76428: NEG
76429: PUSH
76430: LD_INT 3
76432: NEG
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: LD_INT 3
76440: NEG
76441: PUSH
76442: LD_INT 2
76444: NEG
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: LIST
76454: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76455: LD_ADDR_VAR 0 47
76459: PUSH
76460: LD_INT 2
76462: NEG
76463: PUSH
76464: LD_INT 3
76466: NEG
76467: PUSH
76468: EMPTY
76469: LIST
76470: LIST
76471: PUSH
76472: LD_INT 1
76474: NEG
76475: PUSH
76476: LD_INT 3
76478: NEG
76479: PUSH
76480: EMPTY
76481: LIST
76482: LIST
76483: PUSH
76484: EMPTY
76485: LIST
76486: LIST
76487: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76488: LD_ADDR_VAR 0 48
76492: PUSH
76493: LD_INT 1
76495: PUSH
76496: LD_INT 2
76498: NEG
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: LD_INT 2
76506: PUSH
76507: LD_INT 1
76509: NEG
76510: PUSH
76511: EMPTY
76512: LIST
76513: LIST
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76519: LD_ADDR_VAR 0 49
76523: PUSH
76524: LD_INT 3
76526: PUSH
76527: LD_INT 1
76529: PUSH
76530: EMPTY
76531: LIST
76532: LIST
76533: PUSH
76534: LD_INT 3
76536: PUSH
76537: LD_INT 2
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: PUSH
76544: EMPTY
76545: LIST
76546: LIST
76547: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76548: LD_ADDR_VAR 0 50
76552: PUSH
76553: LD_INT 2
76555: PUSH
76556: LD_INT 3
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 1
76565: PUSH
76566: LD_INT 3
76568: PUSH
76569: EMPTY
76570: LIST
76571: LIST
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76577: LD_ADDR_VAR 0 51
76581: PUSH
76582: LD_INT 1
76584: NEG
76585: PUSH
76586: LD_INT 2
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: PUSH
76593: LD_INT 2
76595: NEG
76596: PUSH
76597: LD_INT 1
76599: PUSH
76600: EMPTY
76601: LIST
76602: LIST
76603: PUSH
76604: EMPTY
76605: LIST
76606: LIST
76607: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76608: LD_ADDR_VAR 0 52
76612: PUSH
76613: LD_INT 3
76615: NEG
76616: PUSH
76617: LD_INT 1
76619: NEG
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: LD_INT 3
76627: NEG
76628: PUSH
76629: LD_INT 2
76631: NEG
76632: PUSH
76633: EMPTY
76634: LIST
76635: LIST
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76641: LD_ADDR_VAR 0 53
76645: PUSH
76646: LD_INT 1
76648: NEG
76649: PUSH
76650: LD_INT 3
76652: NEG
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: PUSH
76658: LD_INT 0
76660: PUSH
76661: LD_INT 3
76663: NEG
76664: PUSH
76665: EMPTY
76666: LIST
76667: LIST
76668: PUSH
76669: LD_INT 1
76671: PUSH
76672: LD_INT 2
76674: NEG
76675: PUSH
76676: EMPTY
76677: LIST
76678: LIST
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: LIST
76684: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76685: LD_ADDR_VAR 0 54
76689: PUSH
76690: LD_INT 2
76692: PUSH
76693: LD_INT 1
76695: NEG
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PUSH
76701: LD_INT 3
76703: PUSH
76704: LD_INT 0
76706: PUSH
76707: EMPTY
76708: LIST
76709: LIST
76710: PUSH
76711: LD_INT 3
76713: PUSH
76714: LD_INT 1
76716: PUSH
76717: EMPTY
76718: LIST
76719: LIST
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: LIST
76725: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76726: LD_ADDR_VAR 0 55
76730: PUSH
76731: LD_INT 3
76733: PUSH
76734: LD_INT 2
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: PUSH
76741: LD_INT 3
76743: PUSH
76744: LD_INT 3
76746: PUSH
76747: EMPTY
76748: LIST
76749: LIST
76750: PUSH
76751: LD_INT 2
76753: PUSH
76754: LD_INT 3
76756: PUSH
76757: EMPTY
76758: LIST
76759: LIST
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: LIST
76765: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76766: LD_ADDR_VAR 0 56
76770: PUSH
76771: LD_INT 1
76773: PUSH
76774: LD_INT 3
76776: PUSH
76777: EMPTY
76778: LIST
76779: LIST
76780: PUSH
76781: LD_INT 0
76783: PUSH
76784: LD_INT 3
76786: PUSH
76787: EMPTY
76788: LIST
76789: LIST
76790: PUSH
76791: LD_INT 1
76793: NEG
76794: PUSH
76795: LD_INT 2
76797: PUSH
76798: EMPTY
76799: LIST
76800: LIST
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: LIST
76806: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76807: LD_ADDR_VAR 0 57
76811: PUSH
76812: LD_INT 2
76814: NEG
76815: PUSH
76816: LD_INT 1
76818: PUSH
76819: EMPTY
76820: LIST
76821: LIST
76822: PUSH
76823: LD_INT 3
76825: NEG
76826: PUSH
76827: LD_INT 0
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: PUSH
76834: LD_INT 3
76836: NEG
76837: PUSH
76838: LD_INT 1
76840: NEG
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: LIST
76850: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76851: LD_ADDR_VAR 0 58
76855: PUSH
76856: LD_INT 2
76858: NEG
76859: PUSH
76860: LD_INT 3
76862: NEG
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: PUSH
76868: LD_INT 3
76870: NEG
76871: PUSH
76872: LD_INT 2
76874: NEG
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 3
76882: NEG
76883: PUSH
76884: LD_INT 3
76886: NEG
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: LIST
76896: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76897: LD_ADDR_VAR 0 59
76901: PUSH
76902: LD_INT 1
76904: NEG
76905: PUSH
76906: LD_INT 2
76908: NEG
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: LD_INT 0
76916: PUSH
76917: LD_INT 2
76919: NEG
76920: PUSH
76921: EMPTY
76922: LIST
76923: LIST
76924: PUSH
76925: LD_INT 1
76927: PUSH
76928: LD_INT 1
76930: NEG
76931: PUSH
76932: EMPTY
76933: LIST
76934: LIST
76935: PUSH
76936: EMPTY
76937: LIST
76938: LIST
76939: LIST
76940: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76941: LD_ADDR_VAR 0 60
76945: PUSH
76946: LD_INT 1
76948: PUSH
76949: LD_INT 1
76951: NEG
76952: PUSH
76953: EMPTY
76954: LIST
76955: LIST
76956: PUSH
76957: LD_INT 2
76959: PUSH
76960: LD_INT 0
76962: PUSH
76963: EMPTY
76964: LIST
76965: LIST
76966: PUSH
76967: LD_INT 2
76969: PUSH
76970: LD_INT 1
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: LIST
76981: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76982: LD_ADDR_VAR 0 61
76986: PUSH
76987: LD_INT 2
76989: PUSH
76990: LD_INT 1
76992: PUSH
76993: EMPTY
76994: LIST
76995: LIST
76996: PUSH
76997: LD_INT 2
76999: PUSH
77000: LD_INT 2
77002: PUSH
77003: EMPTY
77004: LIST
77005: LIST
77006: PUSH
77007: LD_INT 1
77009: PUSH
77010: LD_INT 2
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: PUSH
77017: EMPTY
77018: LIST
77019: LIST
77020: LIST
77021: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77022: LD_ADDR_VAR 0 62
77026: PUSH
77027: LD_INT 1
77029: PUSH
77030: LD_INT 2
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: PUSH
77037: LD_INT 0
77039: PUSH
77040: LD_INT 2
77042: PUSH
77043: EMPTY
77044: LIST
77045: LIST
77046: PUSH
77047: LD_INT 1
77049: NEG
77050: PUSH
77051: LD_INT 1
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: PUSH
77058: EMPTY
77059: LIST
77060: LIST
77061: LIST
77062: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77063: LD_ADDR_VAR 0 63
77067: PUSH
77068: LD_INT 1
77070: NEG
77071: PUSH
77072: LD_INT 1
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PUSH
77079: LD_INT 2
77081: NEG
77082: PUSH
77083: LD_INT 0
77085: PUSH
77086: EMPTY
77087: LIST
77088: LIST
77089: PUSH
77090: LD_INT 2
77092: NEG
77093: PUSH
77094: LD_INT 1
77096: NEG
77097: PUSH
77098: EMPTY
77099: LIST
77100: LIST
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: LIST
77106: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77107: LD_ADDR_VAR 0 64
77111: PUSH
77112: LD_INT 1
77114: NEG
77115: PUSH
77116: LD_INT 2
77118: NEG
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: PUSH
77124: LD_INT 2
77126: NEG
77127: PUSH
77128: LD_INT 1
77130: NEG
77131: PUSH
77132: EMPTY
77133: LIST
77134: LIST
77135: PUSH
77136: LD_INT 2
77138: NEG
77139: PUSH
77140: LD_INT 2
77142: NEG
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: PUSH
77148: EMPTY
77149: LIST
77150: LIST
77151: LIST
77152: ST_TO_ADDR
// end ; 2 :
77153: GO 80419
77155: LD_INT 2
77157: DOUBLE
77158: EQUAL
77159: IFTRUE 77163
77161: GO 80418
77163: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77164: LD_ADDR_VAR 0 29
77168: PUSH
77169: LD_INT 4
77171: PUSH
77172: LD_INT 0
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: LD_INT 4
77181: PUSH
77182: LD_INT 1
77184: NEG
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: PUSH
77190: LD_INT 5
77192: PUSH
77193: LD_INT 0
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: PUSH
77200: LD_INT 5
77202: PUSH
77203: LD_INT 1
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: PUSH
77210: LD_INT 4
77212: PUSH
77213: LD_INT 1
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: PUSH
77220: LD_INT 3
77222: PUSH
77223: LD_INT 0
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: PUSH
77230: LD_INT 3
77232: PUSH
77233: LD_INT 1
77235: NEG
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: PUSH
77241: LD_INT 3
77243: PUSH
77244: LD_INT 2
77246: NEG
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 5
77254: PUSH
77255: LD_INT 2
77257: PUSH
77258: EMPTY
77259: LIST
77260: LIST
77261: PUSH
77262: LD_INT 3
77264: PUSH
77265: LD_INT 3
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: PUSH
77272: LD_INT 3
77274: PUSH
77275: LD_INT 2
77277: PUSH
77278: EMPTY
77279: LIST
77280: LIST
77281: PUSH
77282: LD_INT 4
77284: PUSH
77285: LD_INT 3
77287: PUSH
77288: EMPTY
77289: LIST
77290: LIST
77291: PUSH
77292: LD_INT 4
77294: PUSH
77295: LD_INT 4
77297: PUSH
77298: EMPTY
77299: LIST
77300: LIST
77301: PUSH
77302: LD_INT 3
77304: PUSH
77305: LD_INT 4
77307: PUSH
77308: EMPTY
77309: LIST
77310: LIST
77311: PUSH
77312: LD_INT 2
77314: PUSH
77315: LD_INT 3
77317: PUSH
77318: EMPTY
77319: LIST
77320: LIST
77321: PUSH
77322: LD_INT 2
77324: PUSH
77325: LD_INT 2
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: PUSH
77332: LD_INT 4
77334: PUSH
77335: LD_INT 2
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: PUSH
77342: LD_INT 2
77344: PUSH
77345: LD_INT 4
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: PUSH
77352: LD_INT 0
77354: PUSH
77355: LD_INT 4
77357: PUSH
77358: EMPTY
77359: LIST
77360: LIST
77361: PUSH
77362: LD_INT 0
77364: PUSH
77365: LD_INT 3
77367: PUSH
77368: EMPTY
77369: LIST
77370: LIST
77371: PUSH
77372: LD_INT 1
77374: PUSH
77375: LD_INT 4
77377: PUSH
77378: EMPTY
77379: LIST
77380: LIST
77381: PUSH
77382: LD_INT 1
77384: PUSH
77385: LD_INT 5
77387: PUSH
77388: EMPTY
77389: LIST
77390: LIST
77391: PUSH
77392: LD_INT 0
77394: PUSH
77395: LD_INT 5
77397: PUSH
77398: EMPTY
77399: LIST
77400: LIST
77401: PUSH
77402: LD_INT 1
77404: NEG
77405: PUSH
77406: LD_INT 4
77408: PUSH
77409: EMPTY
77410: LIST
77411: LIST
77412: PUSH
77413: LD_INT 1
77415: NEG
77416: PUSH
77417: LD_INT 3
77419: PUSH
77420: EMPTY
77421: LIST
77422: LIST
77423: PUSH
77424: LD_INT 2
77426: PUSH
77427: LD_INT 5
77429: PUSH
77430: EMPTY
77431: LIST
77432: LIST
77433: PUSH
77434: LD_INT 2
77436: NEG
77437: PUSH
77438: LD_INT 3
77440: PUSH
77441: EMPTY
77442: LIST
77443: LIST
77444: PUSH
77445: LD_INT 3
77447: NEG
77448: PUSH
77449: LD_INT 0
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PUSH
77456: LD_INT 3
77458: NEG
77459: PUSH
77460: LD_INT 1
77462: NEG
77463: PUSH
77464: EMPTY
77465: LIST
77466: LIST
77467: PUSH
77468: LD_INT 2
77470: NEG
77471: PUSH
77472: LD_INT 0
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: LD_INT 2
77481: NEG
77482: PUSH
77483: LD_INT 1
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: LD_INT 3
77492: NEG
77493: PUSH
77494: LD_INT 1
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: LD_INT 4
77503: NEG
77504: PUSH
77505: LD_INT 0
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: PUSH
77512: LD_INT 4
77514: NEG
77515: PUSH
77516: LD_INT 1
77518: NEG
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PUSH
77524: LD_INT 4
77526: NEG
77527: PUSH
77528: LD_INT 2
77530: NEG
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: LD_INT 2
77538: NEG
77539: PUSH
77540: LD_INT 2
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: LD_INT 4
77549: NEG
77550: PUSH
77551: LD_INT 4
77553: NEG
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 4
77561: NEG
77562: PUSH
77563: LD_INT 5
77565: NEG
77566: PUSH
77567: EMPTY
77568: LIST
77569: LIST
77570: PUSH
77571: LD_INT 3
77573: NEG
77574: PUSH
77575: LD_INT 4
77577: NEG
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: PUSH
77583: LD_INT 3
77585: NEG
77586: PUSH
77587: LD_INT 3
77589: NEG
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: LD_INT 4
77597: NEG
77598: PUSH
77599: LD_INT 3
77601: NEG
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: PUSH
77607: LD_INT 5
77609: NEG
77610: PUSH
77611: LD_INT 4
77613: NEG
77614: PUSH
77615: EMPTY
77616: LIST
77617: LIST
77618: PUSH
77619: LD_INT 5
77621: NEG
77622: PUSH
77623: LD_INT 5
77625: NEG
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: LD_INT 3
77633: NEG
77634: PUSH
77635: LD_INT 5
77637: NEG
77638: PUSH
77639: EMPTY
77640: LIST
77641: LIST
77642: PUSH
77643: LD_INT 5
77645: NEG
77646: PUSH
77647: LD_INT 3
77649: NEG
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: PUSH
77655: EMPTY
77656: LIST
77657: LIST
77658: LIST
77659: LIST
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: LIST
77671: LIST
77672: LIST
77673: LIST
77674: LIST
77675: LIST
77676: LIST
77677: LIST
77678: LIST
77679: LIST
77680: LIST
77681: LIST
77682: LIST
77683: LIST
77684: LIST
77685: LIST
77686: LIST
77687: LIST
77688: LIST
77689: LIST
77690: LIST
77691: LIST
77692: LIST
77693: LIST
77694: LIST
77695: LIST
77696: LIST
77697: LIST
77698: LIST
77699: LIST
77700: LIST
77701: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77702: LD_ADDR_VAR 0 30
77706: PUSH
77707: LD_INT 4
77709: PUSH
77710: LD_INT 4
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: LD_INT 4
77719: PUSH
77720: LD_INT 3
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PUSH
77727: LD_INT 5
77729: PUSH
77730: LD_INT 4
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: LD_INT 5
77739: PUSH
77740: LD_INT 5
77742: PUSH
77743: EMPTY
77744: LIST
77745: LIST
77746: PUSH
77747: LD_INT 4
77749: PUSH
77750: LD_INT 5
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: PUSH
77757: LD_INT 3
77759: PUSH
77760: LD_INT 4
77762: PUSH
77763: EMPTY
77764: LIST
77765: LIST
77766: PUSH
77767: LD_INT 3
77769: PUSH
77770: LD_INT 3
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: PUSH
77777: LD_INT 5
77779: PUSH
77780: LD_INT 3
77782: PUSH
77783: EMPTY
77784: LIST
77785: LIST
77786: PUSH
77787: LD_INT 3
77789: PUSH
77790: LD_INT 5
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: LD_INT 0
77799: PUSH
77800: LD_INT 3
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PUSH
77807: LD_INT 0
77809: PUSH
77810: LD_INT 2
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 1
77819: PUSH
77820: LD_INT 3
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: PUSH
77827: LD_INT 1
77829: PUSH
77830: LD_INT 4
77832: PUSH
77833: EMPTY
77834: LIST
77835: LIST
77836: PUSH
77837: LD_INT 0
77839: PUSH
77840: LD_INT 4
77842: PUSH
77843: EMPTY
77844: LIST
77845: LIST
77846: PUSH
77847: LD_INT 1
77849: NEG
77850: PUSH
77851: LD_INT 3
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 1
77860: NEG
77861: PUSH
77862: LD_INT 2
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: LD_INT 2
77871: PUSH
77872: LD_INT 4
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: LD_INT 2
77881: NEG
77882: PUSH
77883: LD_INT 2
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PUSH
77890: LD_INT 4
77892: NEG
77893: PUSH
77894: LD_INT 0
77896: PUSH
77897: EMPTY
77898: LIST
77899: LIST
77900: PUSH
77901: LD_INT 4
77903: NEG
77904: PUSH
77905: LD_INT 1
77907: NEG
77908: PUSH
77909: EMPTY
77910: LIST
77911: LIST
77912: PUSH
77913: LD_INT 3
77915: NEG
77916: PUSH
77917: LD_INT 0
77919: PUSH
77920: EMPTY
77921: LIST
77922: LIST
77923: PUSH
77924: LD_INT 3
77926: NEG
77927: PUSH
77928: LD_INT 1
77930: PUSH
77931: EMPTY
77932: LIST
77933: LIST
77934: PUSH
77935: LD_INT 4
77937: NEG
77938: PUSH
77939: LD_INT 1
77941: PUSH
77942: EMPTY
77943: LIST
77944: LIST
77945: PUSH
77946: LD_INT 5
77948: NEG
77949: PUSH
77950: LD_INT 0
77952: PUSH
77953: EMPTY
77954: LIST
77955: LIST
77956: PUSH
77957: LD_INT 5
77959: NEG
77960: PUSH
77961: LD_INT 1
77963: NEG
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: PUSH
77969: LD_INT 5
77971: NEG
77972: PUSH
77973: LD_INT 2
77975: NEG
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: PUSH
77981: LD_INT 3
77983: NEG
77984: PUSH
77985: LD_INT 2
77987: PUSH
77988: EMPTY
77989: LIST
77990: LIST
77991: PUSH
77992: LD_INT 3
77994: NEG
77995: PUSH
77996: LD_INT 3
77998: NEG
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: PUSH
78004: LD_INT 3
78006: NEG
78007: PUSH
78008: LD_INT 4
78010: NEG
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: PUSH
78016: LD_INT 2
78018: NEG
78019: PUSH
78020: LD_INT 3
78022: NEG
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 2
78030: NEG
78031: PUSH
78032: LD_INT 2
78034: NEG
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: PUSH
78040: LD_INT 3
78042: NEG
78043: PUSH
78044: LD_INT 2
78046: NEG
78047: PUSH
78048: EMPTY
78049: LIST
78050: LIST
78051: PUSH
78052: LD_INT 4
78054: NEG
78055: PUSH
78056: LD_INT 3
78058: NEG
78059: PUSH
78060: EMPTY
78061: LIST
78062: LIST
78063: PUSH
78064: LD_INT 4
78066: NEG
78067: PUSH
78068: LD_INT 4
78070: NEG
78071: PUSH
78072: EMPTY
78073: LIST
78074: LIST
78075: PUSH
78076: LD_INT 2
78078: NEG
78079: PUSH
78080: LD_INT 4
78082: NEG
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: LD_INT 4
78090: NEG
78091: PUSH
78092: LD_INT 2
78094: NEG
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: PUSH
78100: LD_INT 0
78102: PUSH
78103: LD_INT 4
78105: NEG
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: PUSH
78111: LD_INT 0
78113: PUSH
78114: LD_INT 5
78116: NEG
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PUSH
78122: LD_INT 1
78124: PUSH
78125: LD_INT 4
78127: NEG
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: PUSH
78133: LD_INT 1
78135: PUSH
78136: LD_INT 3
78138: NEG
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 0
78146: PUSH
78147: LD_INT 3
78149: NEG
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PUSH
78155: LD_INT 1
78157: NEG
78158: PUSH
78159: LD_INT 4
78161: NEG
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 1
78169: NEG
78170: PUSH
78171: LD_INT 5
78173: NEG
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: PUSH
78179: LD_INT 2
78181: PUSH
78182: LD_INT 3
78184: NEG
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: LD_INT 2
78192: NEG
78193: PUSH
78194: LD_INT 5
78196: NEG
78197: PUSH
78198: EMPTY
78199: LIST
78200: LIST
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: LIST
78206: LIST
78207: LIST
78208: LIST
78209: LIST
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: LIST
78246: LIST
78247: LIST
78248: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78249: LD_ADDR_VAR 0 31
78253: PUSH
78254: LD_INT 0
78256: PUSH
78257: LD_INT 4
78259: PUSH
78260: EMPTY
78261: LIST
78262: LIST
78263: PUSH
78264: LD_INT 0
78266: PUSH
78267: LD_INT 3
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: LD_INT 1
78276: PUSH
78277: LD_INT 4
78279: PUSH
78280: EMPTY
78281: LIST
78282: LIST
78283: PUSH
78284: LD_INT 1
78286: PUSH
78287: LD_INT 5
78289: PUSH
78290: EMPTY
78291: LIST
78292: LIST
78293: PUSH
78294: LD_INT 0
78296: PUSH
78297: LD_INT 5
78299: PUSH
78300: EMPTY
78301: LIST
78302: LIST
78303: PUSH
78304: LD_INT 1
78306: NEG
78307: PUSH
78308: LD_INT 4
78310: PUSH
78311: EMPTY
78312: LIST
78313: LIST
78314: PUSH
78315: LD_INT 1
78317: NEG
78318: PUSH
78319: LD_INT 3
78321: PUSH
78322: EMPTY
78323: LIST
78324: LIST
78325: PUSH
78326: LD_INT 2
78328: PUSH
78329: LD_INT 5
78331: PUSH
78332: EMPTY
78333: LIST
78334: LIST
78335: PUSH
78336: LD_INT 2
78338: NEG
78339: PUSH
78340: LD_INT 3
78342: PUSH
78343: EMPTY
78344: LIST
78345: LIST
78346: PUSH
78347: LD_INT 3
78349: NEG
78350: PUSH
78351: LD_INT 0
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: LD_INT 3
78360: NEG
78361: PUSH
78362: LD_INT 1
78364: NEG
78365: PUSH
78366: EMPTY
78367: LIST
78368: LIST
78369: PUSH
78370: LD_INT 2
78372: NEG
78373: PUSH
78374: LD_INT 0
78376: PUSH
78377: EMPTY
78378: LIST
78379: LIST
78380: PUSH
78381: LD_INT 2
78383: NEG
78384: PUSH
78385: LD_INT 1
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: LD_INT 3
78394: NEG
78395: PUSH
78396: LD_INT 1
78398: PUSH
78399: EMPTY
78400: LIST
78401: LIST
78402: PUSH
78403: LD_INT 4
78405: NEG
78406: PUSH
78407: LD_INT 0
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: LD_INT 4
78416: NEG
78417: PUSH
78418: LD_INT 1
78420: NEG
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 4
78428: NEG
78429: PUSH
78430: LD_INT 2
78432: NEG
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 2
78440: NEG
78441: PUSH
78442: LD_INT 2
78444: PUSH
78445: EMPTY
78446: LIST
78447: LIST
78448: PUSH
78449: LD_INT 4
78451: NEG
78452: PUSH
78453: LD_INT 4
78455: NEG
78456: PUSH
78457: EMPTY
78458: LIST
78459: LIST
78460: PUSH
78461: LD_INT 4
78463: NEG
78464: PUSH
78465: LD_INT 5
78467: NEG
78468: PUSH
78469: EMPTY
78470: LIST
78471: LIST
78472: PUSH
78473: LD_INT 3
78475: NEG
78476: PUSH
78477: LD_INT 4
78479: NEG
78480: PUSH
78481: EMPTY
78482: LIST
78483: LIST
78484: PUSH
78485: LD_INT 3
78487: NEG
78488: PUSH
78489: LD_INT 3
78491: NEG
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 4
78499: NEG
78500: PUSH
78501: LD_INT 3
78503: NEG
78504: PUSH
78505: EMPTY
78506: LIST
78507: LIST
78508: PUSH
78509: LD_INT 5
78511: NEG
78512: PUSH
78513: LD_INT 4
78515: NEG
78516: PUSH
78517: EMPTY
78518: LIST
78519: LIST
78520: PUSH
78521: LD_INT 5
78523: NEG
78524: PUSH
78525: LD_INT 5
78527: NEG
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: LD_INT 3
78535: NEG
78536: PUSH
78537: LD_INT 5
78539: NEG
78540: PUSH
78541: EMPTY
78542: LIST
78543: LIST
78544: PUSH
78545: LD_INT 5
78547: NEG
78548: PUSH
78549: LD_INT 3
78551: NEG
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 0
78559: PUSH
78560: LD_INT 3
78562: NEG
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: PUSH
78568: LD_INT 0
78570: PUSH
78571: LD_INT 4
78573: NEG
78574: PUSH
78575: EMPTY
78576: LIST
78577: LIST
78578: PUSH
78579: LD_INT 1
78581: PUSH
78582: LD_INT 3
78584: NEG
78585: PUSH
78586: EMPTY
78587: LIST
78588: LIST
78589: PUSH
78590: LD_INT 1
78592: PUSH
78593: LD_INT 2
78595: NEG
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: PUSH
78601: LD_INT 0
78603: PUSH
78604: LD_INT 2
78606: NEG
78607: PUSH
78608: EMPTY
78609: LIST
78610: LIST
78611: PUSH
78612: LD_INT 1
78614: NEG
78615: PUSH
78616: LD_INT 3
78618: NEG
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: PUSH
78624: LD_INT 1
78626: NEG
78627: PUSH
78628: LD_INT 4
78630: NEG
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 2
78638: PUSH
78639: LD_INT 2
78641: NEG
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 2
78649: NEG
78650: PUSH
78651: LD_INT 4
78653: NEG
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 4
78661: PUSH
78662: LD_INT 0
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 4
78671: PUSH
78672: LD_INT 1
78674: NEG
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: PUSH
78680: LD_INT 5
78682: PUSH
78683: LD_INT 0
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: PUSH
78690: LD_INT 5
78692: PUSH
78693: LD_INT 1
78695: PUSH
78696: EMPTY
78697: LIST
78698: LIST
78699: PUSH
78700: LD_INT 4
78702: PUSH
78703: LD_INT 1
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: LD_INT 3
78712: PUSH
78713: LD_INT 0
78715: PUSH
78716: EMPTY
78717: LIST
78718: LIST
78719: PUSH
78720: LD_INT 3
78722: PUSH
78723: LD_INT 1
78725: NEG
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: LD_INT 3
78733: PUSH
78734: LD_INT 2
78736: NEG
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: PUSH
78742: LD_INT 5
78744: PUSH
78745: LD_INT 2
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: LIST
78756: LIST
78757: LIST
78758: LIST
78759: LIST
78760: LIST
78761: LIST
78762: LIST
78763: LIST
78764: LIST
78765: LIST
78766: LIST
78767: LIST
78768: LIST
78769: LIST
78770: LIST
78771: LIST
78772: LIST
78773: LIST
78774: LIST
78775: LIST
78776: LIST
78777: LIST
78778: LIST
78779: LIST
78780: LIST
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78799: LD_ADDR_VAR 0 32
78803: PUSH
78804: LD_INT 4
78806: NEG
78807: PUSH
78808: LD_INT 0
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 4
78817: NEG
78818: PUSH
78819: LD_INT 1
78821: NEG
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: PUSH
78827: LD_INT 3
78829: NEG
78830: PUSH
78831: LD_INT 0
78833: PUSH
78834: EMPTY
78835: LIST
78836: LIST
78837: PUSH
78838: LD_INT 3
78840: NEG
78841: PUSH
78842: LD_INT 1
78844: PUSH
78845: EMPTY
78846: LIST
78847: LIST
78848: PUSH
78849: LD_INT 4
78851: NEG
78852: PUSH
78853: LD_INT 1
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: PUSH
78860: LD_INT 5
78862: NEG
78863: PUSH
78864: LD_INT 0
78866: PUSH
78867: EMPTY
78868: LIST
78869: LIST
78870: PUSH
78871: LD_INT 5
78873: NEG
78874: PUSH
78875: LD_INT 1
78877: NEG
78878: PUSH
78879: EMPTY
78880: LIST
78881: LIST
78882: PUSH
78883: LD_INT 5
78885: NEG
78886: PUSH
78887: LD_INT 2
78889: NEG
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 3
78897: NEG
78898: PUSH
78899: LD_INT 2
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PUSH
78906: LD_INT 3
78908: NEG
78909: PUSH
78910: LD_INT 3
78912: NEG
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PUSH
78918: LD_INT 3
78920: NEG
78921: PUSH
78922: LD_INT 4
78924: NEG
78925: PUSH
78926: EMPTY
78927: LIST
78928: LIST
78929: PUSH
78930: LD_INT 2
78932: NEG
78933: PUSH
78934: LD_INT 3
78936: NEG
78937: PUSH
78938: EMPTY
78939: LIST
78940: LIST
78941: PUSH
78942: LD_INT 2
78944: NEG
78945: PUSH
78946: LD_INT 2
78948: NEG
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 3
78956: NEG
78957: PUSH
78958: LD_INT 2
78960: NEG
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: PUSH
78966: LD_INT 4
78968: NEG
78969: PUSH
78970: LD_INT 3
78972: NEG
78973: PUSH
78974: EMPTY
78975: LIST
78976: LIST
78977: PUSH
78978: LD_INT 4
78980: NEG
78981: PUSH
78982: LD_INT 4
78984: NEG
78985: PUSH
78986: EMPTY
78987: LIST
78988: LIST
78989: PUSH
78990: LD_INT 2
78992: NEG
78993: PUSH
78994: LD_INT 4
78996: NEG
78997: PUSH
78998: EMPTY
78999: LIST
79000: LIST
79001: PUSH
79002: LD_INT 4
79004: NEG
79005: PUSH
79006: LD_INT 2
79008: NEG
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: LD_INT 0
79016: PUSH
79017: LD_INT 4
79019: NEG
79020: PUSH
79021: EMPTY
79022: LIST
79023: LIST
79024: PUSH
79025: LD_INT 0
79027: PUSH
79028: LD_INT 5
79030: NEG
79031: PUSH
79032: EMPTY
79033: LIST
79034: LIST
79035: PUSH
79036: LD_INT 1
79038: PUSH
79039: LD_INT 4
79041: NEG
79042: PUSH
79043: EMPTY
79044: LIST
79045: LIST
79046: PUSH
79047: LD_INT 1
79049: PUSH
79050: LD_INT 3
79052: NEG
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 0
79060: PUSH
79061: LD_INT 3
79063: NEG
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 1
79071: NEG
79072: PUSH
79073: LD_INT 4
79075: NEG
79076: PUSH
79077: EMPTY
79078: LIST
79079: LIST
79080: PUSH
79081: LD_INT 1
79083: NEG
79084: PUSH
79085: LD_INT 5
79087: NEG
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 2
79095: PUSH
79096: LD_INT 3
79098: NEG
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 2
79106: NEG
79107: PUSH
79108: LD_INT 5
79110: NEG
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: PUSH
79116: LD_INT 3
79118: PUSH
79119: LD_INT 0
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 3
79128: PUSH
79129: LD_INT 1
79131: NEG
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 4
79139: PUSH
79140: LD_INT 0
79142: PUSH
79143: EMPTY
79144: LIST
79145: LIST
79146: PUSH
79147: LD_INT 4
79149: PUSH
79150: LD_INT 1
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 3
79159: PUSH
79160: LD_INT 1
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 2
79169: PUSH
79170: LD_INT 0
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: PUSH
79177: LD_INT 2
79179: PUSH
79180: LD_INT 1
79182: NEG
79183: PUSH
79184: EMPTY
79185: LIST
79186: LIST
79187: PUSH
79188: LD_INT 2
79190: PUSH
79191: LD_INT 2
79193: NEG
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: PUSH
79199: LD_INT 4
79201: PUSH
79202: LD_INT 2
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: PUSH
79209: LD_INT 4
79211: PUSH
79212: LD_INT 4
79214: PUSH
79215: EMPTY
79216: LIST
79217: LIST
79218: PUSH
79219: LD_INT 4
79221: PUSH
79222: LD_INT 3
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 5
79231: PUSH
79232: LD_INT 4
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 5
79241: PUSH
79242: LD_INT 5
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PUSH
79249: LD_INT 4
79251: PUSH
79252: LD_INT 5
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: PUSH
79259: LD_INT 3
79261: PUSH
79262: LD_INT 4
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 3
79271: PUSH
79272: LD_INT 3
79274: PUSH
79275: EMPTY
79276: LIST
79277: LIST
79278: PUSH
79279: LD_INT 5
79281: PUSH
79282: LD_INT 3
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 3
79291: PUSH
79292: LD_INT 5
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: LIST
79303: LIST
79304: LIST
79305: LIST
79306: LIST
79307: LIST
79308: LIST
79309: LIST
79310: LIST
79311: LIST
79312: LIST
79313: LIST
79314: LIST
79315: LIST
79316: LIST
79317: LIST
79318: LIST
79319: LIST
79320: LIST
79321: LIST
79322: LIST
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79346: LD_ADDR_VAR 0 33
79350: PUSH
79351: LD_INT 4
79353: NEG
79354: PUSH
79355: LD_INT 4
79357: NEG
79358: PUSH
79359: EMPTY
79360: LIST
79361: LIST
79362: PUSH
79363: LD_INT 4
79365: NEG
79366: PUSH
79367: LD_INT 5
79369: NEG
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: LD_INT 3
79377: NEG
79378: PUSH
79379: LD_INT 4
79381: NEG
79382: PUSH
79383: EMPTY
79384: LIST
79385: LIST
79386: PUSH
79387: LD_INT 3
79389: NEG
79390: PUSH
79391: LD_INT 3
79393: NEG
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: PUSH
79399: LD_INT 4
79401: NEG
79402: PUSH
79403: LD_INT 3
79405: NEG
79406: PUSH
79407: EMPTY
79408: LIST
79409: LIST
79410: PUSH
79411: LD_INT 5
79413: NEG
79414: PUSH
79415: LD_INT 4
79417: NEG
79418: PUSH
79419: EMPTY
79420: LIST
79421: LIST
79422: PUSH
79423: LD_INT 5
79425: NEG
79426: PUSH
79427: LD_INT 5
79429: NEG
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 3
79437: NEG
79438: PUSH
79439: LD_INT 5
79441: NEG
79442: PUSH
79443: EMPTY
79444: LIST
79445: LIST
79446: PUSH
79447: LD_INT 5
79449: NEG
79450: PUSH
79451: LD_INT 3
79453: NEG
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 0
79461: PUSH
79462: LD_INT 3
79464: NEG
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: PUSH
79470: LD_INT 0
79472: PUSH
79473: LD_INT 4
79475: NEG
79476: PUSH
79477: EMPTY
79478: LIST
79479: LIST
79480: PUSH
79481: LD_INT 1
79483: PUSH
79484: LD_INT 3
79486: NEG
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: PUSH
79492: LD_INT 1
79494: PUSH
79495: LD_INT 2
79497: NEG
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 0
79505: PUSH
79506: LD_INT 2
79508: NEG
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: LD_INT 1
79516: NEG
79517: PUSH
79518: LD_INT 3
79520: NEG
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: PUSH
79526: LD_INT 1
79528: NEG
79529: PUSH
79530: LD_INT 4
79532: NEG
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 2
79540: PUSH
79541: LD_INT 2
79543: NEG
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 2
79551: NEG
79552: PUSH
79553: LD_INT 4
79555: NEG
79556: PUSH
79557: EMPTY
79558: LIST
79559: LIST
79560: PUSH
79561: LD_INT 4
79563: PUSH
79564: LD_INT 0
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 4
79573: PUSH
79574: LD_INT 1
79576: NEG
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 5
79584: PUSH
79585: LD_INT 0
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: PUSH
79592: LD_INT 5
79594: PUSH
79595: LD_INT 1
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: PUSH
79602: LD_INT 4
79604: PUSH
79605: LD_INT 1
79607: PUSH
79608: EMPTY
79609: LIST
79610: LIST
79611: PUSH
79612: LD_INT 3
79614: PUSH
79615: LD_INT 0
79617: PUSH
79618: EMPTY
79619: LIST
79620: LIST
79621: PUSH
79622: LD_INT 3
79624: PUSH
79625: LD_INT 1
79627: NEG
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: PUSH
79633: LD_INT 3
79635: PUSH
79636: LD_INT 2
79638: NEG
79639: PUSH
79640: EMPTY
79641: LIST
79642: LIST
79643: PUSH
79644: LD_INT 5
79646: PUSH
79647: LD_INT 2
79649: PUSH
79650: EMPTY
79651: LIST
79652: LIST
79653: PUSH
79654: LD_INT 3
79656: PUSH
79657: LD_INT 3
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PUSH
79664: LD_INT 3
79666: PUSH
79667: LD_INT 2
79669: PUSH
79670: EMPTY
79671: LIST
79672: LIST
79673: PUSH
79674: LD_INT 4
79676: PUSH
79677: LD_INT 3
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 4
79686: PUSH
79687: LD_INT 4
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: PUSH
79694: LD_INT 3
79696: PUSH
79697: LD_INT 4
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: PUSH
79704: LD_INT 2
79706: PUSH
79707: LD_INT 3
79709: PUSH
79710: EMPTY
79711: LIST
79712: LIST
79713: PUSH
79714: LD_INT 2
79716: PUSH
79717: LD_INT 2
79719: PUSH
79720: EMPTY
79721: LIST
79722: LIST
79723: PUSH
79724: LD_INT 4
79726: PUSH
79727: LD_INT 2
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: LD_INT 2
79736: PUSH
79737: LD_INT 4
79739: PUSH
79740: EMPTY
79741: LIST
79742: LIST
79743: PUSH
79744: LD_INT 0
79746: PUSH
79747: LD_INT 4
79749: PUSH
79750: EMPTY
79751: LIST
79752: LIST
79753: PUSH
79754: LD_INT 0
79756: PUSH
79757: LD_INT 3
79759: PUSH
79760: EMPTY
79761: LIST
79762: LIST
79763: PUSH
79764: LD_INT 1
79766: PUSH
79767: LD_INT 4
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: LD_INT 1
79776: PUSH
79777: LD_INT 5
79779: PUSH
79780: EMPTY
79781: LIST
79782: LIST
79783: PUSH
79784: LD_INT 0
79786: PUSH
79787: LD_INT 5
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: PUSH
79794: LD_INT 1
79796: NEG
79797: PUSH
79798: LD_INT 4
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: PUSH
79805: LD_INT 1
79807: NEG
79808: PUSH
79809: LD_INT 3
79811: PUSH
79812: EMPTY
79813: LIST
79814: LIST
79815: PUSH
79816: LD_INT 2
79818: PUSH
79819: LD_INT 5
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 2
79828: NEG
79829: PUSH
79830: LD_INT 3
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: LIST
79841: LIST
79842: LIST
79843: LIST
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: LIST
79849: LIST
79850: LIST
79851: LIST
79852: LIST
79853: LIST
79854: LIST
79855: LIST
79856: LIST
79857: LIST
79858: LIST
79859: LIST
79860: LIST
79861: LIST
79862: LIST
79863: LIST
79864: LIST
79865: LIST
79866: LIST
79867: LIST
79868: LIST
79869: LIST
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: LIST
79875: LIST
79876: LIST
79877: LIST
79878: LIST
79879: LIST
79880: LIST
79881: LIST
79882: LIST
79883: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79884: LD_ADDR_VAR 0 34
79888: PUSH
79889: LD_INT 0
79891: PUSH
79892: LD_INT 4
79894: NEG
79895: PUSH
79896: EMPTY
79897: LIST
79898: LIST
79899: PUSH
79900: LD_INT 0
79902: PUSH
79903: LD_INT 5
79905: NEG
79906: PUSH
79907: EMPTY
79908: LIST
79909: LIST
79910: PUSH
79911: LD_INT 1
79913: PUSH
79914: LD_INT 4
79916: NEG
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: PUSH
79922: LD_INT 1
79924: PUSH
79925: LD_INT 3
79927: NEG
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: LD_INT 0
79935: PUSH
79936: LD_INT 3
79938: NEG
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: LD_INT 1
79946: NEG
79947: PUSH
79948: LD_INT 4
79950: NEG
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 1
79958: NEG
79959: PUSH
79960: LD_INT 5
79962: NEG
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 2
79970: PUSH
79971: LD_INT 3
79973: NEG
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 2
79981: NEG
79982: PUSH
79983: LD_INT 5
79985: NEG
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: LD_INT 3
79993: PUSH
79994: LD_INT 0
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: PUSH
80001: LD_INT 3
80003: PUSH
80004: LD_INT 1
80006: NEG
80007: PUSH
80008: EMPTY
80009: LIST
80010: LIST
80011: PUSH
80012: LD_INT 4
80014: PUSH
80015: LD_INT 0
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: PUSH
80022: LD_INT 4
80024: PUSH
80025: LD_INT 1
80027: PUSH
80028: EMPTY
80029: LIST
80030: LIST
80031: PUSH
80032: LD_INT 3
80034: PUSH
80035: LD_INT 1
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PUSH
80042: LD_INT 2
80044: PUSH
80045: LD_INT 0
80047: PUSH
80048: EMPTY
80049: LIST
80050: LIST
80051: PUSH
80052: LD_INT 2
80054: PUSH
80055: LD_INT 1
80057: NEG
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 2
80065: PUSH
80066: LD_INT 2
80068: NEG
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 4
80076: PUSH
80077: LD_INT 2
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: PUSH
80084: LD_INT 4
80086: PUSH
80087: LD_INT 4
80089: PUSH
80090: EMPTY
80091: LIST
80092: LIST
80093: PUSH
80094: LD_INT 4
80096: PUSH
80097: LD_INT 3
80099: PUSH
80100: EMPTY
80101: LIST
80102: LIST
80103: PUSH
80104: LD_INT 5
80106: PUSH
80107: LD_INT 4
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PUSH
80114: LD_INT 5
80116: PUSH
80117: LD_INT 5
80119: PUSH
80120: EMPTY
80121: LIST
80122: LIST
80123: PUSH
80124: LD_INT 4
80126: PUSH
80127: LD_INT 5
80129: PUSH
80130: EMPTY
80131: LIST
80132: LIST
80133: PUSH
80134: LD_INT 3
80136: PUSH
80137: LD_INT 4
80139: PUSH
80140: EMPTY
80141: LIST
80142: LIST
80143: PUSH
80144: LD_INT 3
80146: PUSH
80147: LD_INT 3
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: PUSH
80154: LD_INT 5
80156: PUSH
80157: LD_INT 3
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: PUSH
80164: LD_INT 3
80166: PUSH
80167: LD_INT 5
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: LD_INT 0
80176: PUSH
80177: LD_INT 3
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 0
80186: PUSH
80187: LD_INT 2
80189: PUSH
80190: EMPTY
80191: LIST
80192: LIST
80193: PUSH
80194: LD_INT 1
80196: PUSH
80197: LD_INT 3
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 1
80206: PUSH
80207: LD_INT 4
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: LD_INT 0
80216: PUSH
80217: LD_INT 4
80219: PUSH
80220: EMPTY
80221: LIST
80222: LIST
80223: PUSH
80224: LD_INT 1
80226: NEG
80227: PUSH
80228: LD_INT 3
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: LD_INT 1
80237: NEG
80238: PUSH
80239: LD_INT 2
80241: PUSH
80242: EMPTY
80243: LIST
80244: LIST
80245: PUSH
80246: LD_INT 2
80248: PUSH
80249: LD_INT 4
80251: PUSH
80252: EMPTY
80253: LIST
80254: LIST
80255: PUSH
80256: LD_INT 2
80258: NEG
80259: PUSH
80260: LD_INT 2
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 4
80269: NEG
80270: PUSH
80271: LD_INT 0
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 4
80280: NEG
80281: PUSH
80282: LD_INT 1
80284: NEG
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 3
80292: NEG
80293: PUSH
80294: LD_INT 0
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: PUSH
80301: LD_INT 3
80303: NEG
80304: PUSH
80305: LD_INT 1
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 4
80314: NEG
80315: PUSH
80316: LD_INT 1
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 5
80325: NEG
80326: PUSH
80327: LD_INT 0
80329: PUSH
80330: EMPTY
80331: LIST
80332: LIST
80333: PUSH
80334: LD_INT 5
80336: NEG
80337: PUSH
80338: LD_INT 1
80340: NEG
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: PUSH
80346: LD_INT 5
80348: NEG
80349: PUSH
80350: LD_INT 2
80352: NEG
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: PUSH
80358: LD_INT 3
80360: NEG
80361: PUSH
80362: LD_INT 2
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: LIST
80396: LIST
80397: LIST
80398: LIST
80399: LIST
80400: LIST
80401: LIST
80402: LIST
80403: LIST
80404: LIST
80405: LIST
80406: LIST
80407: LIST
80408: LIST
80409: LIST
80410: LIST
80411: LIST
80412: LIST
80413: LIST
80414: LIST
80415: ST_TO_ADDR
// end ; end ;
80416: GO 80419
80418: POP
// case btype of b_depot , b_warehouse :
80419: LD_VAR 0 1
80423: PUSH
80424: LD_INT 0
80426: DOUBLE
80427: EQUAL
80428: IFTRUE 80438
80430: LD_INT 1
80432: DOUBLE
80433: EQUAL
80434: IFTRUE 80438
80436: GO 80639
80438: POP
// case nation of nation_american :
80439: LD_VAR 0 5
80443: PUSH
80444: LD_INT 1
80446: DOUBLE
80447: EQUAL
80448: IFTRUE 80452
80450: GO 80508
80452: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80453: LD_ADDR_VAR 0 9
80457: PUSH
80458: LD_VAR 0 11
80462: PUSH
80463: LD_VAR 0 12
80467: PUSH
80468: LD_VAR 0 13
80472: PUSH
80473: LD_VAR 0 14
80477: PUSH
80478: LD_VAR 0 15
80482: PUSH
80483: LD_VAR 0 16
80487: PUSH
80488: EMPTY
80489: LIST
80490: LIST
80491: LIST
80492: LIST
80493: LIST
80494: LIST
80495: PUSH
80496: LD_VAR 0 4
80500: PUSH
80501: LD_INT 1
80503: PLUS
80504: ARRAY
80505: ST_TO_ADDR
80506: GO 80637
80508: LD_INT 2
80510: DOUBLE
80511: EQUAL
80512: IFTRUE 80516
80514: GO 80572
80516: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80517: LD_ADDR_VAR 0 9
80521: PUSH
80522: LD_VAR 0 17
80526: PUSH
80527: LD_VAR 0 18
80531: PUSH
80532: LD_VAR 0 19
80536: PUSH
80537: LD_VAR 0 20
80541: PUSH
80542: LD_VAR 0 21
80546: PUSH
80547: LD_VAR 0 22
80551: PUSH
80552: EMPTY
80553: LIST
80554: LIST
80555: LIST
80556: LIST
80557: LIST
80558: LIST
80559: PUSH
80560: LD_VAR 0 4
80564: PUSH
80565: LD_INT 1
80567: PLUS
80568: ARRAY
80569: ST_TO_ADDR
80570: GO 80637
80572: LD_INT 3
80574: DOUBLE
80575: EQUAL
80576: IFTRUE 80580
80578: GO 80636
80580: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80581: LD_ADDR_VAR 0 9
80585: PUSH
80586: LD_VAR 0 23
80590: PUSH
80591: LD_VAR 0 24
80595: PUSH
80596: LD_VAR 0 25
80600: PUSH
80601: LD_VAR 0 26
80605: PUSH
80606: LD_VAR 0 27
80610: PUSH
80611: LD_VAR 0 28
80615: PUSH
80616: EMPTY
80617: LIST
80618: LIST
80619: LIST
80620: LIST
80621: LIST
80622: LIST
80623: PUSH
80624: LD_VAR 0 4
80628: PUSH
80629: LD_INT 1
80631: PLUS
80632: ARRAY
80633: ST_TO_ADDR
80634: GO 80637
80636: POP
80637: GO 81192
80639: LD_INT 2
80641: DOUBLE
80642: EQUAL
80643: IFTRUE 80653
80645: LD_INT 3
80647: DOUBLE
80648: EQUAL
80649: IFTRUE 80653
80651: GO 80709
80653: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80654: LD_ADDR_VAR 0 9
80658: PUSH
80659: LD_VAR 0 29
80663: PUSH
80664: LD_VAR 0 30
80668: PUSH
80669: LD_VAR 0 31
80673: PUSH
80674: LD_VAR 0 32
80678: PUSH
80679: LD_VAR 0 33
80683: PUSH
80684: LD_VAR 0 34
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: LIST
80693: LIST
80694: LIST
80695: LIST
80696: PUSH
80697: LD_VAR 0 4
80701: PUSH
80702: LD_INT 1
80704: PLUS
80705: ARRAY
80706: ST_TO_ADDR
80707: GO 81192
80709: LD_INT 16
80711: DOUBLE
80712: EQUAL
80713: IFTRUE 80771
80715: LD_INT 17
80717: DOUBLE
80718: EQUAL
80719: IFTRUE 80771
80721: LD_INT 18
80723: DOUBLE
80724: EQUAL
80725: IFTRUE 80771
80727: LD_INT 19
80729: DOUBLE
80730: EQUAL
80731: IFTRUE 80771
80733: LD_INT 22
80735: DOUBLE
80736: EQUAL
80737: IFTRUE 80771
80739: LD_INT 20
80741: DOUBLE
80742: EQUAL
80743: IFTRUE 80771
80745: LD_INT 21
80747: DOUBLE
80748: EQUAL
80749: IFTRUE 80771
80751: LD_INT 23
80753: DOUBLE
80754: EQUAL
80755: IFTRUE 80771
80757: LD_INT 24
80759: DOUBLE
80760: EQUAL
80761: IFTRUE 80771
80763: LD_INT 25
80765: DOUBLE
80766: EQUAL
80767: IFTRUE 80771
80769: GO 80827
80771: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80772: LD_ADDR_VAR 0 9
80776: PUSH
80777: LD_VAR 0 35
80781: PUSH
80782: LD_VAR 0 36
80786: PUSH
80787: LD_VAR 0 37
80791: PUSH
80792: LD_VAR 0 38
80796: PUSH
80797: LD_VAR 0 39
80801: PUSH
80802: LD_VAR 0 40
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: LIST
80811: LIST
80812: LIST
80813: LIST
80814: PUSH
80815: LD_VAR 0 4
80819: PUSH
80820: LD_INT 1
80822: PLUS
80823: ARRAY
80824: ST_TO_ADDR
80825: GO 81192
80827: LD_INT 6
80829: DOUBLE
80830: EQUAL
80831: IFTRUE 80883
80833: LD_INT 7
80835: DOUBLE
80836: EQUAL
80837: IFTRUE 80883
80839: LD_INT 8
80841: DOUBLE
80842: EQUAL
80843: IFTRUE 80883
80845: LD_INT 13
80847: DOUBLE
80848: EQUAL
80849: IFTRUE 80883
80851: LD_INT 12
80853: DOUBLE
80854: EQUAL
80855: IFTRUE 80883
80857: LD_INT 15
80859: DOUBLE
80860: EQUAL
80861: IFTRUE 80883
80863: LD_INT 11
80865: DOUBLE
80866: EQUAL
80867: IFTRUE 80883
80869: LD_INT 14
80871: DOUBLE
80872: EQUAL
80873: IFTRUE 80883
80875: LD_INT 10
80877: DOUBLE
80878: EQUAL
80879: IFTRUE 80883
80881: GO 80939
80883: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80884: LD_ADDR_VAR 0 9
80888: PUSH
80889: LD_VAR 0 41
80893: PUSH
80894: LD_VAR 0 42
80898: PUSH
80899: LD_VAR 0 43
80903: PUSH
80904: LD_VAR 0 44
80908: PUSH
80909: LD_VAR 0 45
80913: PUSH
80914: LD_VAR 0 46
80918: PUSH
80919: EMPTY
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: PUSH
80927: LD_VAR 0 4
80931: PUSH
80932: LD_INT 1
80934: PLUS
80935: ARRAY
80936: ST_TO_ADDR
80937: GO 81192
80939: LD_INT 36
80941: DOUBLE
80942: EQUAL
80943: IFTRUE 80947
80945: GO 81003
80947: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80948: LD_ADDR_VAR 0 9
80952: PUSH
80953: LD_VAR 0 47
80957: PUSH
80958: LD_VAR 0 48
80962: PUSH
80963: LD_VAR 0 49
80967: PUSH
80968: LD_VAR 0 50
80972: PUSH
80973: LD_VAR 0 51
80977: PUSH
80978: LD_VAR 0 52
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: LIST
80987: LIST
80988: LIST
80989: LIST
80990: PUSH
80991: LD_VAR 0 4
80995: PUSH
80996: LD_INT 1
80998: PLUS
80999: ARRAY
81000: ST_TO_ADDR
81001: GO 81192
81003: LD_INT 4
81005: DOUBLE
81006: EQUAL
81007: IFTRUE 81029
81009: LD_INT 5
81011: DOUBLE
81012: EQUAL
81013: IFTRUE 81029
81015: LD_INT 34
81017: DOUBLE
81018: EQUAL
81019: IFTRUE 81029
81021: LD_INT 37
81023: DOUBLE
81024: EQUAL
81025: IFTRUE 81029
81027: GO 81085
81029: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81030: LD_ADDR_VAR 0 9
81034: PUSH
81035: LD_VAR 0 53
81039: PUSH
81040: LD_VAR 0 54
81044: PUSH
81045: LD_VAR 0 55
81049: PUSH
81050: LD_VAR 0 56
81054: PUSH
81055: LD_VAR 0 57
81059: PUSH
81060: LD_VAR 0 58
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: LIST
81072: PUSH
81073: LD_VAR 0 4
81077: PUSH
81078: LD_INT 1
81080: PLUS
81081: ARRAY
81082: ST_TO_ADDR
81083: GO 81192
81085: LD_INT 31
81087: DOUBLE
81088: EQUAL
81089: IFTRUE 81135
81091: LD_INT 32
81093: DOUBLE
81094: EQUAL
81095: IFTRUE 81135
81097: LD_INT 33
81099: DOUBLE
81100: EQUAL
81101: IFTRUE 81135
81103: LD_INT 27
81105: DOUBLE
81106: EQUAL
81107: IFTRUE 81135
81109: LD_INT 26
81111: DOUBLE
81112: EQUAL
81113: IFTRUE 81135
81115: LD_INT 28
81117: DOUBLE
81118: EQUAL
81119: IFTRUE 81135
81121: LD_INT 29
81123: DOUBLE
81124: EQUAL
81125: IFTRUE 81135
81127: LD_INT 30
81129: DOUBLE
81130: EQUAL
81131: IFTRUE 81135
81133: GO 81191
81135: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81136: LD_ADDR_VAR 0 9
81140: PUSH
81141: LD_VAR 0 59
81145: PUSH
81146: LD_VAR 0 60
81150: PUSH
81151: LD_VAR 0 61
81155: PUSH
81156: LD_VAR 0 62
81160: PUSH
81161: LD_VAR 0 63
81165: PUSH
81166: LD_VAR 0 64
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: PUSH
81179: LD_VAR 0 4
81183: PUSH
81184: LD_INT 1
81186: PLUS
81187: ARRAY
81188: ST_TO_ADDR
81189: GO 81192
81191: POP
// temp_list2 = [ ] ;
81192: LD_ADDR_VAR 0 10
81196: PUSH
81197: EMPTY
81198: ST_TO_ADDR
// for i in temp_list do
81199: LD_ADDR_VAR 0 8
81203: PUSH
81204: LD_VAR 0 9
81208: PUSH
81209: FOR_IN
81210: IFFALSE 81262
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81212: LD_ADDR_VAR 0 10
81216: PUSH
81217: LD_VAR 0 10
81221: PUSH
81222: LD_VAR 0 8
81226: PUSH
81227: LD_INT 1
81229: ARRAY
81230: PUSH
81231: LD_VAR 0 2
81235: PLUS
81236: PUSH
81237: LD_VAR 0 8
81241: PUSH
81242: LD_INT 2
81244: ARRAY
81245: PUSH
81246: LD_VAR 0 3
81250: PLUS
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: EMPTY
81257: LIST
81258: ADD
81259: ST_TO_ADDR
81260: GO 81209
81262: POP
81263: POP
// result = temp_list2 ;
81264: LD_ADDR_VAR 0 7
81268: PUSH
81269: LD_VAR 0 10
81273: ST_TO_ADDR
// end ;
81274: LD_VAR 0 7
81278: RET
// export function EnemyInRange ( unit , dist ) ; begin
81279: LD_INT 0
81281: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81282: LD_ADDR_VAR 0 3
81286: PUSH
81287: LD_VAR 0 1
81291: PPUSH
81292: CALL_OW 255
81296: PPUSH
81297: LD_VAR 0 1
81301: PPUSH
81302: CALL_OW 250
81306: PPUSH
81307: LD_VAR 0 1
81311: PPUSH
81312: CALL_OW 251
81316: PPUSH
81317: LD_VAR 0 2
81321: PPUSH
81322: CALL 54681 0 4
81326: PUSH
81327: LD_INT 4
81329: ARRAY
81330: ST_TO_ADDR
// end ;
81331: LD_VAR 0 3
81335: RET
// export function PlayerSeeMe ( unit ) ; begin
81336: LD_INT 0
81338: PPUSH
// result := See ( your_side , unit ) ;
81339: LD_ADDR_VAR 0 2
81343: PUSH
81344: LD_OWVAR 2
81348: PPUSH
81349: LD_VAR 0 1
81353: PPUSH
81354: CALL_OW 292
81358: ST_TO_ADDR
// end ;
81359: LD_VAR 0 2
81363: RET
// export function ReverseDir ( unit ) ; begin
81364: LD_INT 0
81366: PPUSH
// if not unit then
81367: LD_VAR 0 1
81371: NOT
81372: IFFALSE 81376
// exit ;
81374: GO 81399
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81376: LD_ADDR_VAR 0 2
81380: PUSH
81381: LD_VAR 0 1
81385: PPUSH
81386: CALL_OW 254
81390: PUSH
81391: LD_INT 3
81393: PLUS
81394: PUSH
81395: LD_INT 6
81397: MOD
81398: ST_TO_ADDR
// end ;
81399: LD_VAR 0 2
81403: RET
// export function ReverseArray ( array ) ; var i ; begin
81404: LD_INT 0
81406: PPUSH
81407: PPUSH
// if not array then
81408: LD_VAR 0 1
81412: NOT
81413: IFFALSE 81417
// exit ;
81415: GO 81472
// result := [ ] ;
81417: LD_ADDR_VAR 0 2
81421: PUSH
81422: EMPTY
81423: ST_TO_ADDR
// for i := array downto 1 do
81424: LD_ADDR_VAR 0 3
81428: PUSH
81429: DOUBLE
81430: LD_VAR 0 1
81434: INC
81435: ST_TO_ADDR
81436: LD_INT 1
81438: PUSH
81439: FOR_DOWNTO
81440: IFFALSE 81470
// result := Join ( result , array [ i ] ) ;
81442: LD_ADDR_VAR 0 2
81446: PUSH
81447: LD_VAR 0 2
81451: PPUSH
81452: LD_VAR 0 1
81456: PUSH
81457: LD_VAR 0 3
81461: ARRAY
81462: PPUSH
81463: CALL 86116 0 2
81467: ST_TO_ADDR
81468: GO 81439
81470: POP
81471: POP
// end ;
81472: LD_VAR 0 2
81476: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
81477: LD_INT 0
81479: PPUSH
81480: PPUSH
81481: PPUSH
81482: PPUSH
81483: PPUSH
81484: PPUSH
// if not unit or not hexes then
81485: LD_VAR 0 1
81489: NOT
81490: PUSH
81491: LD_VAR 0 2
81495: NOT
81496: OR
81497: IFFALSE 81501
// exit ;
81499: GO 81624
// dist := 9999 ;
81501: LD_ADDR_VAR 0 5
81505: PUSH
81506: LD_INT 9999
81508: ST_TO_ADDR
// for i = 1 to hexes do
81509: LD_ADDR_VAR 0 4
81513: PUSH
81514: DOUBLE
81515: LD_INT 1
81517: DEC
81518: ST_TO_ADDR
81519: LD_VAR 0 2
81523: PUSH
81524: FOR_TO
81525: IFFALSE 81612
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81527: LD_ADDR_VAR 0 6
81531: PUSH
81532: LD_VAR 0 1
81536: PPUSH
81537: LD_VAR 0 2
81541: PUSH
81542: LD_VAR 0 4
81546: ARRAY
81547: PUSH
81548: LD_INT 1
81550: ARRAY
81551: PPUSH
81552: LD_VAR 0 2
81556: PUSH
81557: LD_VAR 0 4
81561: ARRAY
81562: PUSH
81563: LD_INT 2
81565: ARRAY
81566: PPUSH
81567: CALL_OW 297
81571: ST_TO_ADDR
// if tdist < dist then
81572: LD_VAR 0 6
81576: PUSH
81577: LD_VAR 0 5
81581: LESS
81582: IFFALSE 81610
// begin hex := hexes [ i ] ;
81584: LD_ADDR_VAR 0 8
81588: PUSH
81589: LD_VAR 0 2
81593: PUSH
81594: LD_VAR 0 4
81598: ARRAY
81599: ST_TO_ADDR
// dist := tdist ;
81600: LD_ADDR_VAR 0 5
81604: PUSH
81605: LD_VAR 0 6
81609: ST_TO_ADDR
// end ; end ;
81610: GO 81524
81612: POP
81613: POP
// result := hex ;
81614: LD_ADDR_VAR 0 3
81618: PUSH
81619: LD_VAR 0 8
81623: ST_TO_ADDR
// end ;
81624: LD_VAR 0 3
81628: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81629: LD_INT 0
81631: PPUSH
81632: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81633: LD_VAR 0 1
81637: NOT
81638: PUSH
81639: LD_VAR 0 1
81643: PUSH
81644: LD_INT 21
81646: PUSH
81647: LD_INT 2
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: PUSH
81654: LD_INT 23
81656: PUSH
81657: LD_INT 2
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PPUSH
81668: CALL_OW 69
81672: IN
81673: NOT
81674: OR
81675: IFFALSE 81679
// exit ;
81677: GO 81726
// for i = 1 to 3 do
81679: LD_ADDR_VAR 0 3
81683: PUSH
81684: DOUBLE
81685: LD_INT 1
81687: DEC
81688: ST_TO_ADDR
81689: LD_INT 3
81691: PUSH
81692: FOR_TO
81693: IFFALSE 81724
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81695: LD_VAR 0 1
81699: PPUSH
81700: CALL_OW 250
81704: PPUSH
81705: LD_VAR 0 1
81709: PPUSH
81710: CALL_OW 251
81714: PPUSH
81715: LD_INT 1
81717: PPUSH
81718: CALL_OW 453
81722: GO 81692
81724: POP
81725: POP
// end ;
81726: LD_VAR 0 2
81730: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81731: LD_INT 0
81733: PPUSH
81734: PPUSH
81735: PPUSH
81736: PPUSH
81737: PPUSH
81738: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81739: LD_VAR 0 1
81743: NOT
81744: PUSH
81745: LD_VAR 0 2
81749: NOT
81750: OR
81751: PUSH
81752: LD_VAR 0 1
81756: PPUSH
81757: CALL_OW 314
81761: OR
81762: IFFALSE 81766
// exit ;
81764: GO 82233
// if GetLives ( i ) < 250 then
81766: LD_VAR 0 4
81770: PPUSH
81771: CALL_OW 256
81775: PUSH
81776: LD_INT 250
81778: LESS
81779: IFFALSE 81792
// begin ComAutodestruct ( i ) ;
81781: LD_VAR 0 4
81785: PPUSH
81786: CALL 81629 0 1
// exit ;
81790: GO 82233
// end ; x := GetX ( enemy_unit ) ;
81792: LD_ADDR_VAR 0 7
81796: PUSH
81797: LD_VAR 0 2
81801: PPUSH
81802: CALL_OW 250
81806: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81807: LD_ADDR_VAR 0 8
81811: PUSH
81812: LD_VAR 0 2
81816: PPUSH
81817: CALL_OW 251
81821: ST_TO_ADDR
// if not x or not y then
81822: LD_VAR 0 7
81826: NOT
81827: PUSH
81828: LD_VAR 0 8
81832: NOT
81833: OR
81834: IFFALSE 81838
// exit ;
81836: GO 82233
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81838: LD_ADDR_VAR 0 6
81842: PUSH
81843: LD_VAR 0 7
81847: PPUSH
81848: LD_INT 0
81850: PPUSH
81851: LD_INT 4
81853: PPUSH
81854: CALL_OW 272
81858: PUSH
81859: LD_VAR 0 8
81863: PPUSH
81864: LD_INT 0
81866: PPUSH
81867: LD_INT 4
81869: PPUSH
81870: CALL_OW 273
81874: PUSH
81875: EMPTY
81876: LIST
81877: LIST
81878: PUSH
81879: LD_VAR 0 7
81883: PPUSH
81884: LD_INT 1
81886: PPUSH
81887: LD_INT 4
81889: PPUSH
81890: CALL_OW 272
81894: PUSH
81895: LD_VAR 0 8
81899: PPUSH
81900: LD_INT 1
81902: PPUSH
81903: LD_INT 4
81905: PPUSH
81906: CALL_OW 273
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_VAR 0 7
81919: PPUSH
81920: LD_INT 2
81922: PPUSH
81923: LD_INT 4
81925: PPUSH
81926: CALL_OW 272
81930: PUSH
81931: LD_VAR 0 8
81935: PPUSH
81936: LD_INT 2
81938: PPUSH
81939: LD_INT 4
81941: PPUSH
81942: CALL_OW 273
81946: PUSH
81947: EMPTY
81948: LIST
81949: LIST
81950: PUSH
81951: LD_VAR 0 7
81955: PPUSH
81956: LD_INT 3
81958: PPUSH
81959: LD_INT 4
81961: PPUSH
81962: CALL_OW 272
81966: PUSH
81967: LD_VAR 0 8
81971: PPUSH
81972: LD_INT 3
81974: PPUSH
81975: LD_INT 4
81977: PPUSH
81978: CALL_OW 273
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: PUSH
81987: LD_VAR 0 7
81991: PPUSH
81992: LD_INT 4
81994: PPUSH
81995: LD_INT 4
81997: PPUSH
81998: CALL_OW 272
82002: PUSH
82003: LD_VAR 0 8
82007: PPUSH
82008: LD_INT 4
82010: PPUSH
82011: LD_INT 4
82013: PPUSH
82014: CALL_OW 273
82018: PUSH
82019: EMPTY
82020: LIST
82021: LIST
82022: PUSH
82023: LD_VAR 0 7
82027: PPUSH
82028: LD_INT 5
82030: PPUSH
82031: LD_INT 4
82033: PPUSH
82034: CALL_OW 272
82038: PUSH
82039: LD_VAR 0 8
82043: PPUSH
82044: LD_INT 5
82046: PPUSH
82047: LD_INT 4
82049: PPUSH
82050: CALL_OW 273
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: EMPTY
82060: LIST
82061: LIST
82062: LIST
82063: LIST
82064: LIST
82065: LIST
82066: ST_TO_ADDR
// for i = tmp downto 1 do
82067: LD_ADDR_VAR 0 4
82071: PUSH
82072: DOUBLE
82073: LD_VAR 0 6
82077: INC
82078: ST_TO_ADDR
82079: LD_INT 1
82081: PUSH
82082: FOR_DOWNTO
82083: IFFALSE 82184
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82085: LD_VAR 0 6
82089: PUSH
82090: LD_VAR 0 4
82094: ARRAY
82095: PUSH
82096: LD_INT 1
82098: ARRAY
82099: PPUSH
82100: LD_VAR 0 6
82104: PUSH
82105: LD_VAR 0 4
82109: ARRAY
82110: PUSH
82111: LD_INT 2
82113: ARRAY
82114: PPUSH
82115: CALL_OW 488
82119: NOT
82120: PUSH
82121: LD_VAR 0 6
82125: PUSH
82126: LD_VAR 0 4
82130: ARRAY
82131: PUSH
82132: LD_INT 1
82134: ARRAY
82135: PPUSH
82136: LD_VAR 0 6
82140: PUSH
82141: LD_VAR 0 4
82145: ARRAY
82146: PUSH
82147: LD_INT 2
82149: ARRAY
82150: PPUSH
82151: CALL_OW 428
82155: PUSH
82156: LD_INT 0
82158: NONEQUAL
82159: OR
82160: IFFALSE 82182
// tmp := Delete ( tmp , i ) ;
82162: LD_ADDR_VAR 0 6
82166: PUSH
82167: LD_VAR 0 6
82171: PPUSH
82172: LD_VAR 0 4
82176: PPUSH
82177: CALL_OW 3
82181: ST_TO_ADDR
82182: GO 82082
82184: POP
82185: POP
// j := GetClosestHex ( unit , tmp ) ;
82186: LD_ADDR_VAR 0 5
82190: PUSH
82191: LD_VAR 0 1
82195: PPUSH
82196: LD_VAR 0 6
82200: PPUSH
82201: CALL 81477 0 2
82205: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82206: LD_VAR 0 1
82210: PPUSH
82211: LD_VAR 0 5
82215: PUSH
82216: LD_INT 1
82218: ARRAY
82219: PPUSH
82220: LD_VAR 0 5
82224: PUSH
82225: LD_INT 2
82227: ARRAY
82228: PPUSH
82229: CALL_OW 111
// end ;
82233: LD_VAR 0 3
82237: RET
// export function PrepareApemanSoldier ( ) ; begin
82238: LD_INT 0
82240: PPUSH
// uc_nation := 0 ;
82241: LD_ADDR_OWVAR 21
82245: PUSH
82246: LD_INT 0
82248: ST_TO_ADDR
// hc_sex := sex_male ;
82249: LD_ADDR_OWVAR 27
82253: PUSH
82254: LD_INT 1
82256: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82257: LD_ADDR_OWVAR 28
82261: PUSH
82262: LD_INT 15
82264: ST_TO_ADDR
// hc_gallery :=  ;
82265: LD_ADDR_OWVAR 33
82269: PUSH
82270: LD_STRING 
82272: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82273: LD_ADDR_OWVAR 31
82277: PUSH
82278: LD_INT 0
82280: PPUSH
82281: LD_INT 3
82283: PPUSH
82284: CALL_OW 12
82288: PUSH
82289: LD_INT 0
82291: PPUSH
82292: LD_INT 3
82294: PPUSH
82295: CALL_OW 12
82299: PUSH
82300: LD_INT 0
82302: PUSH
82303: LD_INT 0
82305: PUSH
82306: EMPTY
82307: LIST
82308: LIST
82309: LIST
82310: LIST
82311: ST_TO_ADDR
// end ;
82312: LD_VAR 0 1
82316: RET
// export function PrepareApemanEngineer ( ) ; begin
82317: LD_INT 0
82319: PPUSH
// uc_nation := 0 ;
82320: LD_ADDR_OWVAR 21
82324: PUSH
82325: LD_INT 0
82327: ST_TO_ADDR
// hc_sex := sex_male ;
82328: LD_ADDR_OWVAR 27
82332: PUSH
82333: LD_INT 1
82335: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
82336: LD_ADDR_OWVAR 28
82340: PUSH
82341: LD_INT 16
82343: ST_TO_ADDR
// hc_gallery :=  ;
82344: LD_ADDR_OWVAR 33
82348: PUSH
82349: LD_STRING 
82351: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82352: LD_ADDR_OWVAR 31
82356: PUSH
82357: LD_INT 0
82359: PPUSH
82360: LD_INT 3
82362: PPUSH
82363: CALL_OW 12
82367: PUSH
82368: LD_INT 0
82370: PPUSH
82371: LD_INT 3
82373: PPUSH
82374: CALL_OW 12
82378: PUSH
82379: LD_INT 0
82381: PUSH
82382: LD_INT 0
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: ST_TO_ADDR
// end ;
82391: LD_VAR 0 1
82395: RET
// export function PrepareApeman ( agressivity ) ; begin
82396: LD_INT 0
82398: PPUSH
// uc_side := 0 ;
82399: LD_ADDR_OWVAR 20
82403: PUSH
82404: LD_INT 0
82406: ST_TO_ADDR
// uc_nation := 0 ;
82407: LD_ADDR_OWVAR 21
82411: PUSH
82412: LD_INT 0
82414: ST_TO_ADDR
// hc_sex := sex_male ;
82415: LD_ADDR_OWVAR 27
82419: PUSH
82420: LD_INT 1
82422: ST_TO_ADDR
// hc_class := class_apeman ;
82423: LD_ADDR_OWVAR 28
82427: PUSH
82428: LD_INT 12
82430: ST_TO_ADDR
// hc_gallery :=  ;
82431: LD_ADDR_OWVAR 33
82435: PUSH
82436: LD_STRING 
82438: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82439: LD_ADDR_OWVAR 35
82443: PUSH
82444: LD_VAR 0 1
82448: NEG
82449: PPUSH
82450: LD_VAR 0 1
82454: PPUSH
82455: CALL_OW 12
82459: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82460: LD_ADDR_OWVAR 31
82464: PUSH
82465: LD_INT 0
82467: PPUSH
82468: LD_INT 3
82470: PPUSH
82471: CALL_OW 12
82475: PUSH
82476: LD_INT 0
82478: PPUSH
82479: LD_INT 3
82481: PPUSH
82482: CALL_OW 12
82486: PUSH
82487: LD_INT 0
82489: PUSH
82490: LD_INT 0
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: LIST
82497: LIST
82498: ST_TO_ADDR
// end ;
82499: LD_VAR 0 2
82503: RET
// export function PrepareTiger ( agressivity ) ; begin
82504: LD_INT 0
82506: PPUSH
// uc_side := 0 ;
82507: LD_ADDR_OWVAR 20
82511: PUSH
82512: LD_INT 0
82514: ST_TO_ADDR
// uc_nation := 0 ;
82515: LD_ADDR_OWVAR 21
82519: PUSH
82520: LD_INT 0
82522: ST_TO_ADDR
// hc_class := class_tiger ;
82523: LD_ADDR_OWVAR 28
82527: PUSH
82528: LD_INT 14
82530: ST_TO_ADDR
// hc_gallery :=  ;
82531: LD_ADDR_OWVAR 33
82535: PUSH
82536: LD_STRING 
82538: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82539: LD_ADDR_OWVAR 35
82543: PUSH
82544: LD_VAR 0 1
82548: NEG
82549: PPUSH
82550: LD_VAR 0 1
82554: PPUSH
82555: CALL_OW 12
82559: ST_TO_ADDR
// end ;
82560: LD_VAR 0 2
82564: RET
// export function PrepareEnchidna ( ) ; begin
82565: LD_INT 0
82567: PPUSH
// uc_side := 0 ;
82568: LD_ADDR_OWVAR 20
82572: PUSH
82573: LD_INT 0
82575: ST_TO_ADDR
// uc_nation := 0 ;
82576: LD_ADDR_OWVAR 21
82580: PUSH
82581: LD_INT 0
82583: ST_TO_ADDR
// hc_class := class_baggie ;
82584: LD_ADDR_OWVAR 28
82588: PUSH
82589: LD_INT 13
82591: ST_TO_ADDR
// hc_gallery :=  ;
82592: LD_ADDR_OWVAR 33
82596: PUSH
82597: LD_STRING 
82599: ST_TO_ADDR
// end ;
82600: LD_VAR 0 1
82604: RET
// export function PrepareFrog ( ) ; begin
82605: LD_INT 0
82607: PPUSH
// uc_side := 0 ;
82608: LD_ADDR_OWVAR 20
82612: PUSH
82613: LD_INT 0
82615: ST_TO_ADDR
// uc_nation := 0 ;
82616: LD_ADDR_OWVAR 21
82620: PUSH
82621: LD_INT 0
82623: ST_TO_ADDR
// hc_class := class_frog ;
82624: LD_ADDR_OWVAR 28
82628: PUSH
82629: LD_INT 19
82631: ST_TO_ADDR
// hc_gallery :=  ;
82632: LD_ADDR_OWVAR 33
82636: PUSH
82637: LD_STRING 
82639: ST_TO_ADDR
// end ;
82640: LD_VAR 0 1
82644: RET
// export function PrepareFish ( ) ; begin
82645: LD_INT 0
82647: PPUSH
// uc_side := 0 ;
82648: LD_ADDR_OWVAR 20
82652: PUSH
82653: LD_INT 0
82655: ST_TO_ADDR
// uc_nation := 0 ;
82656: LD_ADDR_OWVAR 21
82660: PUSH
82661: LD_INT 0
82663: ST_TO_ADDR
// hc_class := class_fish ;
82664: LD_ADDR_OWVAR 28
82668: PUSH
82669: LD_INT 20
82671: ST_TO_ADDR
// hc_gallery :=  ;
82672: LD_ADDR_OWVAR 33
82676: PUSH
82677: LD_STRING 
82679: ST_TO_ADDR
// end ;
82680: LD_VAR 0 1
82684: RET
// export function PrepareBird ( ) ; begin
82685: LD_INT 0
82687: PPUSH
// uc_side := 0 ;
82688: LD_ADDR_OWVAR 20
82692: PUSH
82693: LD_INT 0
82695: ST_TO_ADDR
// uc_nation := 0 ;
82696: LD_ADDR_OWVAR 21
82700: PUSH
82701: LD_INT 0
82703: ST_TO_ADDR
// hc_class := class_phororhacos ;
82704: LD_ADDR_OWVAR 28
82708: PUSH
82709: LD_INT 18
82711: ST_TO_ADDR
// hc_gallery :=  ;
82712: LD_ADDR_OWVAR 33
82716: PUSH
82717: LD_STRING 
82719: ST_TO_ADDR
// end ;
82720: LD_VAR 0 1
82724: RET
// export function PrepareHorse ( ) ; begin
82725: LD_INT 0
82727: PPUSH
// uc_side := 0 ;
82728: LD_ADDR_OWVAR 20
82732: PUSH
82733: LD_INT 0
82735: ST_TO_ADDR
// uc_nation := 0 ;
82736: LD_ADDR_OWVAR 21
82740: PUSH
82741: LD_INT 0
82743: ST_TO_ADDR
// hc_class := class_horse ;
82744: LD_ADDR_OWVAR 28
82748: PUSH
82749: LD_INT 21
82751: ST_TO_ADDR
// hc_gallery :=  ;
82752: LD_ADDR_OWVAR 33
82756: PUSH
82757: LD_STRING 
82759: ST_TO_ADDR
// end ;
82760: LD_VAR 0 1
82764: RET
// export function PrepareMastodont ( ) ; begin
82765: LD_INT 0
82767: PPUSH
// uc_side := 0 ;
82768: LD_ADDR_OWVAR 20
82772: PUSH
82773: LD_INT 0
82775: ST_TO_ADDR
// uc_nation := 0 ;
82776: LD_ADDR_OWVAR 21
82780: PUSH
82781: LD_INT 0
82783: ST_TO_ADDR
// vc_chassis := class_mastodont ;
82784: LD_ADDR_OWVAR 37
82788: PUSH
82789: LD_INT 31
82791: ST_TO_ADDR
// vc_control := control_rider ;
82792: LD_ADDR_OWVAR 38
82796: PUSH
82797: LD_INT 4
82799: ST_TO_ADDR
// end ;
82800: LD_VAR 0 1
82804: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
82805: LD_INT 0
82807: PPUSH
82808: PPUSH
82809: PPUSH
// uc_side = 0 ;
82810: LD_ADDR_OWVAR 20
82814: PUSH
82815: LD_INT 0
82817: ST_TO_ADDR
// uc_nation = 0 ;
82818: LD_ADDR_OWVAR 21
82822: PUSH
82823: LD_INT 0
82825: ST_TO_ADDR
// InitHc_All ( ) ;
82826: CALL_OW 584
// InitVc ;
82830: CALL_OW 20
// if mastodonts then
82834: LD_VAR 0 6
82838: IFFALSE 82905
// for i = 1 to mastodonts do
82840: LD_ADDR_VAR 0 11
82844: PUSH
82845: DOUBLE
82846: LD_INT 1
82848: DEC
82849: ST_TO_ADDR
82850: LD_VAR 0 6
82854: PUSH
82855: FOR_TO
82856: IFFALSE 82903
// begin vc_chassis := 31 ;
82858: LD_ADDR_OWVAR 37
82862: PUSH
82863: LD_INT 31
82865: ST_TO_ADDR
// vc_control := control_rider ;
82866: LD_ADDR_OWVAR 38
82870: PUSH
82871: LD_INT 4
82873: ST_TO_ADDR
// animal := CreateVehicle ;
82874: LD_ADDR_VAR 0 12
82878: PUSH
82879: CALL_OW 45
82883: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82884: LD_VAR 0 12
82888: PPUSH
82889: LD_VAR 0 8
82893: PPUSH
82894: LD_INT 0
82896: PPUSH
82897: CALL 85033 0 3
// end ;
82901: GO 82855
82903: POP
82904: POP
// if horses then
82905: LD_VAR 0 5
82909: IFFALSE 82976
// for i = 1 to horses do
82911: LD_ADDR_VAR 0 11
82915: PUSH
82916: DOUBLE
82917: LD_INT 1
82919: DEC
82920: ST_TO_ADDR
82921: LD_VAR 0 5
82925: PUSH
82926: FOR_TO
82927: IFFALSE 82974
// begin hc_class := 21 ;
82929: LD_ADDR_OWVAR 28
82933: PUSH
82934: LD_INT 21
82936: ST_TO_ADDR
// hc_gallery :=  ;
82937: LD_ADDR_OWVAR 33
82941: PUSH
82942: LD_STRING 
82944: ST_TO_ADDR
// animal := CreateHuman ;
82945: LD_ADDR_VAR 0 12
82949: PUSH
82950: CALL_OW 44
82954: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82955: LD_VAR 0 12
82959: PPUSH
82960: LD_VAR 0 8
82964: PPUSH
82965: LD_INT 0
82967: PPUSH
82968: CALL 85033 0 3
// end ;
82972: GO 82926
82974: POP
82975: POP
// if birds then
82976: LD_VAR 0 1
82980: IFFALSE 83047
// for i = 1 to birds do
82982: LD_ADDR_VAR 0 11
82986: PUSH
82987: DOUBLE
82988: LD_INT 1
82990: DEC
82991: ST_TO_ADDR
82992: LD_VAR 0 1
82996: PUSH
82997: FOR_TO
82998: IFFALSE 83045
// begin hc_class = 18 ;
83000: LD_ADDR_OWVAR 28
83004: PUSH
83005: LD_INT 18
83007: ST_TO_ADDR
// hc_gallery =  ;
83008: LD_ADDR_OWVAR 33
83012: PUSH
83013: LD_STRING 
83015: ST_TO_ADDR
// animal := CreateHuman ;
83016: LD_ADDR_VAR 0 12
83020: PUSH
83021: CALL_OW 44
83025: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83026: LD_VAR 0 12
83030: PPUSH
83031: LD_VAR 0 8
83035: PPUSH
83036: LD_INT 0
83038: PPUSH
83039: CALL 85033 0 3
// end ;
83043: GO 82997
83045: POP
83046: POP
// if tigers then
83047: LD_VAR 0 2
83051: IFFALSE 83135
// for i = 1 to tigers do
83053: LD_ADDR_VAR 0 11
83057: PUSH
83058: DOUBLE
83059: LD_INT 1
83061: DEC
83062: ST_TO_ADDR
83063: LD_VAR 0 2
83067: PUSH
83068: FOR_TO
83069: IFFALSE 83133
// begin hc_class = class_tiger ;
83071: LD_ADDR_OWVAR 28
83075: PUSH
83076: LD_INT 14
83078: ST_TO_ADDR
// hc_gallery =  ;
83079: LD_ADDR_OWVAR 33
83083: PUSH
83084: LD_STRING 
83086: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83087: LD_ADDR_OWVAR 35
83091: PUSH
83092: LD_INT 7
83094: NEG
83095: PPUSH
83096: LD_INT 7
83098: PPUSH
83099: CALL_OW 12
83103: ST_TO_ADDR
// animal := CreateHuman ;
83104: LD_ADDR_VAR 0 12
83108: PUSH
83109: CALL_OW 44
83113: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83114: LD_VAR 0 12
83118: PPUSH
83119: LD_VAR 0 8
83123: PPUSH
83124: LD_INT 0
83126: PPUSH
83127: CALL 85033 0 3
// end ;
83131: GO 83068
83133: POP
83134: POP
// if apemans then
83135: LD_VAR 0 3
83139: IFFALSE 83262
// for i = 1 to apemans do
83141: LD_ADDR_VAR 0 11
83145: PUSH
83146: DOUBLE
83147: LD_INT 1
83149: DEC
83150: ST_TO_ADDR
83151: LD_VAR 0 3
83155: PUSH
83156: FOR_TO
83157: IFFALSE 83260
// begin hc_class = class_apeman ;
83159: LD_ADDR_OWVAR 28
83163: PUSH
83164: LD_INT 12
83166: ST_TO_ADDR
// hc_gallery =  ;
83167: LD_ADDR_OWVAR 33
83171: PUSH
83172: LD_STRING 
83174: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83175: LD_ADDR_OWVAR 35
83179: PUSH
83180: LD_INT 2
83182: NEG
83183: PPUSH
83184: LD_INT 2
83186: PPUSH
83187: CALL_OW 12
83191: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83192: LD_ADDR_OWVAR 31
83196: PUSH
83197: LD_INT 1
83199: PPUSH
83200: LD_INT 3
83202: PPUSH
83203: CALL_OW 12
83207: PUSH
83208: LD_INT 1
83210: PPUSH
83211: LD_INT 3
83213: PPUSH
83214: CALL_OW 12
83218: PUSH
83219: LD_INT 0
83221: PUSH
83222: LD_INT 0
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: LIST
83229: LIST
83230: ST_TO_ADDR
// animal := CreateHuman ;
83231: LD_ADDR_VAR 0 12
83235: PUSH
83236: CALL_OW 44
83240: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83241: LD_VAR 0 12
83245: PPUSH
83246: LD_VAR 0 8
83250: PPUSH
83251: LD_INT 0
83253: PPUSH
83254: CALL 85033 0 3
// end ;
83258: GO 83156
83260: POP
83261: POP
// if enchidnas then
83262: LD_VAR 0 4
83266: IFFALSE 83333
// for i = 1 to enchidnas do
83268: LD_ADDR_VAR 0 11
83272: PUSH
83273: DOUBLE
83274: LD_INT 1
83276: DEC
83277: ST_TO_ADDR
83278: LD_VAR 0 4
83282: PUSH
83283: FOR_TO
83284: IFFALSE 83331
// begin hc_class = 13 ;
83286: LD_ADDR_OWVAR 28
83290: PUSH
83291: LD_INT 13
83293: ST_TO_ADDR
// hc_gallery =  ;
83294: LD_ADDR_OWVAR 33
83298: PUSH
83299: LD_STRING 
83301: ST_TO_ADDR
// animal := CreateHuman ;
83302: LD_ADDR_VAR 0 12
83306: PUSH
83307: CALL_OW 44
83311: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83312: LD_VAR 0 12
83316: PPUSH
83317: LD_VAR 0 8
83321: PPUSH
83322: LD_INT 0
83324: PPUSH
83325: CALL 85033 0 3
// end ;
83329: GO 83283
83331: POP
83332: POP
// if fishes then
83333: LD_VAR 0 7
83337: IFFALSE 83404
// for i = 1 to fishes do
83339: LD_ADDR_VAR 0 11
83343: PUSH
83344: DOUBLE
83345: LD_INT 1
83347: DEC
83348: ST_TO_ADDR
83349: LD_VAR 0 7
83353: PUSH
83354: FOR_TO
83355: IFFALSE 83402
// begin hc_class = 20 ;
83357: LD_ADDR_OWVAR 28
83361: PUSH
83362: LD_INT 20
83364: ST_TO_ADDR
// hc_gallery =  ;
83365: LD_ADDR_OWVAR 33
83369: PUSH
83370: LD_STRING 
83372: ST_TO_ADDR
// animal := CreateHuman ;
83373: LD_ADDR_VAR 0 12
83377: PUSH
83378: CALL_OW 44
83382: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83383: LD_VAR 0 12
83387: PPUSH
83388: LD_VAR 0 9
83392: PPUSH
83393: LD_INT 0
83395: PPUSH
83396: CALL 85033 0 3
// end ;
83400: GO 83354
83402: POP
83403: POP
// end ;
83404: LD_VAR 0 10
83408: RET
// export function WantHeal ( sci , unit ) ; begin
83409: LD_INT 0
83411: PPUSH
// if GetTaskList ( sci ) > 0 then
83412: LD_VAR 0 1
83416: PPUSH
83417: CALL_OW 437
83421: PUSH
83422: LD_INT 0
83424: GREATER
83425: IFFALSE 83495
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83427: LD_VAR 0 1
83431: PPUSH
83432: CALL_OW 437
83436: PUSH
83437: LD_INT 1
83439: ARRAY
83440: PUSH
83441: LD_INT 1
83443: ARRAY
83444: PUSH
83445: LD_STRING l
83447: EQUAL
83448: PUSH
83449: LD_VAR 0 1
83453: PPUSH
83454: CALL_OW 437
83458: PUSH
83459: LD_INT 1
83461: ARRAY
83462: PUSH
83463: LD_INT 4
83465: ARRAY
83466: PUSH
83467: LD_VAR 0 2
83471: EQUAL
83472: AND
83473: IFFALSE 83485
// result := true else
83475: LD_ADDR_VAR 0 3
83479: PUSH
83480: LD_INT 1
83482: ST_TO_ADDR
83483: GO 83493
// result := false ;
83485: LD_ADDR_VAR 0 3
83489: PUSH
83490: LD_INT 0
83492: ST_TO_ADDR
// end else
83493: GO 83503
// result := false ;
83495: LD_ADDR_VAR 0 3
83499: PUSH
83500: LD_INT 0
83502: ST_TO_ADDR
// end ;
83503: LD_VAR 0 3
83507: RET
// export function HealTarget ( sci ) ; begin
83508: LD_INT 0
83510: PPUSH
// if not sci then
83511: LD_VAR 0 1
83515: NOT
83516: IFFALSE 83520
// exit ;
83518: GO 83585
// result := 0 ;
83520: LD_ADDR_VAR 0 2
83524: PUSH
83525: LD_INT 0
83527: ST_TO_ADDR
// if GetTaskList ( sci ) then
83528: LD_VAR 0 1
83532: PPUSH
83533: CALL_OW 437
83537: IFFALSE 83585
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
83539: LD_VAR 0 1
83543: PPUSH
83544: CALL_OW 437
83548: PUSH
83549: LD_INT 1
83551: ARRAY
83552: PUSH
83553: LD_INT 1
83555: ARRAY
83556: PUSH
83557: LD_STRING l
83559: EQUAL
83560: IFFALSE 83585
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
83562: LD_ADDR_VAR 0 2
83566: PUSH
83567: LD_VAR 0 1
83571: PPUSH
83572: CALL_OW 437
83576: PUSH
83577: LD_INT 1
83579: ARRAY
83580: PUSH
83581: LD_INT 4
83583: ARRAY
83584: ST_TO_ADDR
// end ;
83585: LD_VAR 0 2
83589: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
83590: LD_INT 0
83592: PPUSH
83593: PPUSH
83594: PPUSH
83595: PPUSH
// if not base_units then
83596: LD_VAR 0 1
83600: NOT
83601: IFFALSE 83605
// exit ;
83603: GO 83692
// result := false ;
83605: LD_ADDR_VAR 0 2
83609: PUSH
83610: LD_INT 0
83612: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
83613: LD_ADDR_VAR 0 5
83617: PUSH
83618: LD_VAR 0 1
83622: PPUSH
83623: LD_INT 21
83625: PUSH
83626: LD_INT 3
83628: PUSH
83629: EMPTY
83630: LIST
83631: LIST
83632: PPUSH
83633: CALL_OW 72
83637: ST_TO_ADDR
// if not tmp then
83638: LD_VAR 0 5
83642: NOT
83643: IFFALSE 83647
// exit ;
83645: GO 83692
// for i in tmp do
83647: LD_ADDR_VAR 0 3
83651: PUSH
83652: LD_VAR 0 5
83656: PUSH
83657: FOR_IN
83658: IFFALSE 83690
// begin result := EnemyInRange ( i , 22 ) ;
83660: LD_ADDR_VAR 0 2
83664: PUSH
83665: LD_VAR 0 3
83669: PPUSH
83670: LD_INT 22
83672: PPUSH
83673: CALL 81279 0 2
83677: ST_TO_ADDR
// if result then
83678: LD_VAR 0 2
83682: IFFALSE 83688
// exit ;
83684: POP
83685: POP
83686: GO 83692
// end ;
83688: GO 83657
83690: POP
83691: POP
// end ;
83692: LD_VAR 0 2
83696: RET
// export function FilterByTag ( units , tag ) ; begin
83697: LD_INT 0
83699: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
83700: LD_ADDR_VAR 0 3
83704: PUSH
83705: LD_VAR 0 1
83709: PPUSH
83710: LD_INT 120
83712: PUSH
83713: LD_VAR 0 2
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: PPUSH
83722: CALL_OW 72
83726: ST_TO_ADDR
// end ;
83727: LD_VAR 0 3
83731: RET
// export function IsDriver ( un ) ; begin
83732: LD_INT 0
83734: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
83735: LD_ADDR_VAR 0 2
83739: PUSH
83740: LD_VAR 0 1
83744: PUSH
83745: LD_INT 55
83747: PUSH
83748: EMPTY
83749: LIST
83750: PPUSH
83751: CALL_OW 69
83755: IN
83756: ST_TO_ADDR
// end ;
83757: LD_VAR 0 2
83761: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
83762: LD_INT 0
83764: PPUSH
83765: PPUSH
// list := [ ] ;
83766: LD_ADDR_VAR 0 5
83770: PUSH
83771: EMPTY
83772: ST_TO_ADDR
// case d of 0 :
83773: LD_VAR 0 3
83777: PUSH
83778: LD_INT 0
83780: DOUBLE
83781: EQUAL
83782: IFTRUE 83786
83784: GO 83919
83786: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
83787: LD_ADDR_VAR 0 5
83791: PUSH
83792: LD_VAR 0 1
83796: PUSH
83797: LD_INT 4
83799: MINUS
83800: PUSH
83801: LD_VAR 0 2
83805: PUSH
83806: LD_INT 4
83808: MINUS
83809: PUSH
83810: LD_INT 2
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: LIST
83817: PUSH
83818: LD_VAR 0 1
83822: PUSH
83823: LD_INT 3
83825: MINUS
83826: PUSH
83827: LD_VAR 0 2
83831: PUSH
83832: LD_INT 1
83834: PUSH
83835: EMPTY
83836: LIST
83837: LIST
83838: LIST
83839: PUSH
83840: LD_VAR 0 1
83844: PUSH
83845: LD_INT 4
83847: PLUS
83848: PUSH
83849: LD_VAR 0 2
83853: PUSH
83854: LD_INT 4
83856: PUSH
83857: EMPTY
83858: LIST
83859: LIST
83860: LIST
83861: PUSH
83862: LD_VAR 0 1
83866: PUSH
83867: LD_INT 3
83869: PLUS
83870: PUSH
83871: LD_VAR 0 2
83875: PUSH
83876: LD_INT 3
83878: PLUS
83879: PUSH
83880: LD_INT 5
83882: PUSH
83883: EMPTY
83884: LIST
83885: LIST
83886: LIST
83887: PUSH
83888: LD_VAR 0 1
83892: PUSH
83893: LD_VAR 0 2
83897: PUSH
83898: LD_INT 4
83900: PLUS
83901: PUSH
83902: LD_INT 0
83904: PUSH
83905: EMPTY
83906: LIST
83907: LIST
83908: LIST
83909: PUSH
83910: EMPTY
83911: LIST
83912: LIST
83913: LIST
83914: LIST
83915: LIST
83916: ST_TO_ADDR
// end ; 1 :
83917: GO 84617
83919: LD_INT 1
83921: DOUBLE
83922: EQUAL
83923: IFTRUE 83927
83925: GO 84060
83927: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
83928: LD_ADDR_VAR 0 5
83932: PUSH
83933: LD_VAR 0 1
83937: PUSH
83938: LD_VAR 0 2
83942: PUSH
83943: LD_INT 4
83945: MINUS
83946: PUSH
83947: LD_INT 3
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: LIST
83954: PUSH
83955: LD_VAR 0 1
83959: PUSH
83960: LD_INT 3
83962: MINUS
83963: PUSH
83964: LD_VAR 0 2
83968: PUSH
83969: LD_INT 3
83971: MINUS
83972: PUSH
83973: LD_INT 2
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: LIST
83980: PUSH
83981: LD_VAR 0 1
83985: PUSH
83986: LD_INT 4
83988: MINUS
83989: PUSH
83990: LD_VAR 0 2
83994: PUSH
83995: LD_INT 1
83997: PUSH
83998: EMPTY
83999: LIST
84000: LIST
84001: LIST
84002: PUSH
84003: LD_VAR 0 1
84007: PUSH
84008: LD_VAR 0 2
84012: PUSH
84013: LD_INT 3
84015: PLUS
84016: PUSH
84017: LD_INT 0
84019: PUSH
84020: EMPTY
84021: LIST
84022: LIST
84023: LIST
84024: PUSH
84025: LD_VAR 0 1
84029: PUSH
84030: LD_INT 4
84032: PLUS
84033: PUSH
84034: LD_VAR 0 2
84038: PUSH
84039: LD_INT 4
84041: PLUS
84042: PUSH
84043: LD_INT 5
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: LIST
84050: PUSH
84051: EMPTY
84052: LIST
84053: LIST
84054: LIST
84055: LIST
84056: LIST
84057: ST_TO_ADDR
// end ; 2 :
84058: GO 84617
84060: LD_INT 2
84062: DOUBLE
84063: EQUAL
84064: IFTRUE 84068
84066: GO 84197
84068: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84069: LD_ADDR_VAR 0 5
84073: PUSH
84074: LD_VAR 0 1
84078: PUSH
84079: LD_VAR 0 2
84083: PUSH
84084: LD_INT 3
84086: MINUS
84087: PUSH
84088: LD_INT 3
84090: PUSH
84091: EMPTY
84092: LIST
84093: LIST
84094: LIST
84095: PUSH
84096: LD_VAR 0 1
84100: PUSH
84101: LD_INT 4
84103: PLUS
84104: PUSH
84105: LD_VAR 0 2
84109: PUSH
84110: LD_INT 4
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: LIST
84117: PUSH
84118: LD_VAR 0 1
84122: PUSH
84123: LD_VAR 0 2
84127: PUSH
84128: LD_INT 4
84130: PLUS
84131: PUSH
84132: LD_INT 0
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: LIST
84139: PUSH
84140: LD_VAR 0 1
84144: PUSH
84145: LD_INT 3
84147: MINUS
84148: PUSH
84149: LD_VAR 0 2
84153: PUSH
84154: LD_INT 1
84156: PUSH
84157: EMPTY
84158: LIST
84159: LIST
84160: LIST
84161: PUSH
84162: LD_VAR 0 1
84166: PUSH
84167: LD_INT 4
84169: MINUS
84170: PUSH
84171: LD_VAR 0 2
84175: PUSH
84176: LD_INT 4
84178: MINUS
84179: PUSH
84180: LD_INT 2
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: LIST
84187: PUSH
84188: EMPTY
84189: LIST
84190: LIST
84191: LIST
84192: LIST
84193: LIST
84194: ST_TO_ADDR
// end ; 3 :
84195: GO 84617
84197: LD_INT 3
84199: DOUBLE
84200: EQUAL
84201: IFTRUE 84205
84203: GO 84338
84205: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84206: LD_ADDR_VAR 0 5
84210: PUSH
84211: LD_VAR 0 1
84215: PUSH
84216: LD_INT 3
84218: PLUS
84219: PUSH
84220: LD_VAR 0 2
84224: PUSH
84225: LD_INT 4
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: LIST
84232: PUSH
84233: LD_VAR 0 1
84237: PUSH
84238: LD_INT 4
84240: PLUS
84241: PUSH
84242: LD_VAR 0 2
84246: PUSH
84247: LD_INT 4
84249: PLUS
84250: PUSH
84251: LD_INT 5
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: LIST
84258: PUSH
84259: LD_VAR 0 1
84263: PUSH
84264: LD_INT 4
84266: MINUS
84267: PUSH
84268: LD_VAR 0 2
84272: PUSH
84273: LD_INT 1
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: LIST
84280: PUSH
84281: LD_VAR 0 1
84285: PUSH
84286: LD_VAR 0 2
84290: PUSH
84291: LD_INT 4
84293: MINUS
84294: PUSH
84295: LD_INT 3
84297: PUSH
84298: EMPTY
84299: LIST
84300: LIST
84301: LIST
84302: PUSH
84303: LD_VAR 0 1
84307: PUSH
84308: LD_INT 3
84310: MINUS
84311: PUSH
84312: LD_VAR 0 2
84316: PUSH
84317: LD_INT 3
84319: MINUS
84320: PUSH
84321: LD_INT 2
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: LIST
84328: PUSH
84329: EMPTY
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: ST_TO_ADDR
// end ; 4 :
84336: GO 84617
84338: LD_INT 4
84340: DOUBLE
84341: EQUAL
84342: IFTRUE 84346
84344: GO 84479
84346: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84347: LD_ADDR_VAR 0 5
84351: PUSH
84352: LD_VAR 0 1
84356: PUSH
84357: LD_VAR 0 2
84361: PUSH
84362: LD_INT 4
84364: PLUS
84365: PUSH
84366: LD_INT 0
84368: PUSH
84369: EMPTY
84370: LIST
84371: LIST
84372: LIST
84373: PUSH
84374: LD_VAR 0 1
84378: PUSH
84379: LD_INT 3
84381: PLUS
84382: PUSH
84383: LD_VAR 0 2
84387: PUSH
84388: LD_INT 3
84390: PLUS
84391: PUSH
84392: LD_INT 5
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: LIST
84399: PUSH
84400: LD_VAR 0 1
84404: PUSH
84405: LD_INT 4
84407: PLUS
84408: PUSH
84409: LD_VAR 0 2
84413: PUSH
84414: LD_INT 4
84416: PUSH
84417: EMPTY
84418: LIST
84419: LIST
84420: LIST
84421: PUSH
84422: LD_VAR 0 1
84426: PUSH
84427: LD_VAR 0 2
84431: PUSH
84432: LD_INT 3
84434: MINUS
84435: PUSH
84436: LD_INT 3
84438: PUSH
84439: EMPTY
84440: LIST
84441: LIST
84442: LIST
84443: PUSH
84444: LD_VAR 0 1
84448: PUSH
84449: LD_INT 4
84451: MINUS
84452: PUSH
84453: LD_VAR 0 2
84457: PUSH
84458: LD_INT 4
84460: MINUS
84461: PUSH
84462: LD_INT 2
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: LIST
84469: PUSH
84470: EMPTY
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: ST_TO_ADDR
// end ; 5 :
84477: GO 84617
84479: LD_INT 5
84481: DOUBLE
84482: EQUAL
84483: IFTRUE 84487
84485: GO 84616
84487: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84488: LD_ADDR_VAR 0 5
84492: PUSH
84493: LD_VAR 0 1
84497: PUSH
84498: LD_INT 4
84500: MINUS
84501: PUSH
84502: LD_VAR 0 2
84506: PUSH
84507: LD_INT 1
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: LIST
84514: PUSH
84515: LD_VAR 0 1
84519: PUSH
84520: LD_VAR 0 2
84524: PUSH
84525: LD_INT 4
84527: MINUS
84528: PUSH
84529: LD_INT 3
84531: PUSH
84532: EMPTY
84533: LIST
84534: LIST
84535: LIST
84536: PUSH
84537: LD_VAR 0 1
84541: PUSH
84542: LD_INT 4
84544: PLUS
84545: PUSH
84546: LD_VAR 0 2
84550: PUSH
84551: LD_INT 4
84553: PLUS
84554: PUSH
84555: LD_INT 5
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: LIST
84562: PUSH
84563: LD_VAR 0 1
84567: PUSH
84568: LD_INT 3
84570: PLUS
84571: PUSH
84572: LD_VAR 0 2
84576: PUSH
84577: LD_INT 4
84579: PUSH
84580: EMPTY
84581: LIST
84582: LIST
84583: LIST
84584: PUSH
84585: LD_VAR 0 1
84589: PUSH
84590: LD_VAR 0 2
84594: PUSH
84595: LD_INT 3
84597: PLUS
84598: PUSH
84599: LD_INT 0
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: LIST
84606: PUSH
84607: EMPTY
84608: LIST
84609: LIST
84610: LIST
84611: LIST
84612: LIST
84613: ST_TO_ADDR
// end ; end ;
84614: GO 84617
84616: POP
// result := list ;
84617: LD_ADDR_VAR 0 4
84621: PUSH
84622: LD_VAR 0 5
84626: ST_TO_ADDR
// end ;
84627: LD_VAR 0 4
84631: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
84632: LD_INT 0
84634: PPUSH
84635: PPUSH
84636: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
84637: LD_VAR 0 1
84641: NOT
84642: PUSH
84643: LD_VAR 0 2
84647: PUSH
84648: LD_INT 1
84650: PUSH
84651: LD_INT 2
84653: PUSH
84654: LD_INT 3
84656: PUSH
84657: LD_INT 4
84659: PUSH
84660: EMPTY
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: IN
84666: NOT
84667: OR
84668: IFFALSE 84672
// exit ;
84670: GO 84755
// tmp := [ ] ;
84672: LD_ADDR_VAR 0 5
84676: PUSH
84677: EMPTY
84678: ST_TO_ADDR
// for i in units do
84679: LD_ADDR_VAR 0 4
84683: PUSH
84684: LD_VAR 0 1
84688: PUSH
84689: FOR_IN
84690: IFFALSE 84724
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
84692: LD_ADDR_VAR 0 5
84696: PUSH
84697: LD_VAR 0 5
84701: PPUSH
84702: LD_VAR 0 4
84706: PPUSH
84707: LD_VAR 0 2
84711: PPUSH
84712: CALL_OW 259
84716: PPUSH
84717: CALL 86116 0 2
84721: ST_TO_ADDR
84722: GO 84689
84724: POP
84725: POP
// if not tmp then
84726: LD_VAR 0 5
84730: NOT
84731: IFFALSE 84735
// exit ;
84733: GO 84755
// result := SortListByListDesc ( units , tmp ) ;
84735: LD_ADDR_VAR 0 3
84739: PUSH
84740: LD_VAR 0 1
84744: PPUSH
84745: LD_VAR 0 5
84749: PPUSH
84750: CALL_OW 77
84754: ST_TO_ADDR
// end ;
84755: LD_VAR 0 3
84759: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
84760: LD_INT 0
84762: PPUSH
84763: PPUSH
84764: PPUSH
// result := false ;
84765: LD_ADDR_VAR 0 3
84769: PUSH
84770: LD_INT 0
84772: ST_TO_ADDR
// if not building then
84773: LD_VAR 0 2
84777: NOT
84778: IFFALSE 84782
// exit ;
84780: GO 84920
// x := GetX ( building ) ;
84782: LD_ADDR_VAR 0 4
84786: PUSH
84787: LD_VAR 0 2
84791: PPUSH
84792: CALL_OW 250
84796: ST_TO_ADDR
// y := GetY ( building ) ;
84797: LD_ADDR_VAR 0 5
84801: PUSH
84802: LD_VAR 0 2
84806: PPUSH
84807: CALL_OW 251
84811: ST_TO_ADDR
// if not x or not y then
84812: LD_VAR 0 4
84816: NOT
84817: PUSH
84818: LD_VAR 0 5
84822: NOT
84823: OR
84824: IFFALSE 84828
// exit ;
84826: GO 84920
// if GetTaskList ( unit ) then
84828: LD_VAR 0 1
84832: PPUSH
84833: CALL_OW 437
84837: IFFALSE 84920
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84839: LD_STRING e
84841: PUSH
84842: LD_VAR 0 1
84846: PPUSH
84847: CALL_OW 437
84851: PUSH
84852: LD_INT 1
84854: ARRAY
84855: PUSH
84856: LD_INT 1
84858: ARRAY
84859: EQUAL
84860: PUSH
84861: LD_VAR 0 4
84865: PUSH
84866: LD_VAR 0 1
84870: PPUSH
84871: CALL_OW 437
84875: PUSH
84876: LD_INT 1
84878: ARRAY
84879: PUSH
84880: LD_INT 2
84882: ARRAY
84883: EQUAL
84884: AND
84885: PUSH
84886: LD_VAR 0 5
84890: PUSH
84891: LD_VAR 0 1
84895: PPUSH
84896: CALL_OW 437
84900: PUSH
84901: LD_INT 1
84903: ARRAY
84904: PUSH
84905: LD_INT 3
84907: ARRAY
84908: EQUAL
84909: AND
84910: IFFALSE 84920
// result := true end ;
84912: LD_ADDR_VAR 0 3
84916: PUSH
84917: LD_INT 1
84919: ST_TO_ADDR
// end ;
84920: LD_VAR 0 3
84924: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
84925: LD_INT 0
84927: PPUSH
// result := false ;
84928: LD_ADDR_VAR 0 4
84932: PUSH
84933: LD_INT 0
84935: ST_TO_ADDR
// if GetTaskList ( unit ) then
84936: LD_VAR 0 1
84940: PPUSH
84941: CALL_OW 437
84945: IFFALSE 85028
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84947: LD_STRING M
84949: PUSH
84950: LD_VAR 0 1
84954: PPUSH
84955: CALL_OW 437
84959: PUSH
84960: LD_INT 1
84962: ARRAY
84963: PUSH
84964: LD_INT 1
84966: ARRAY
84967: EQUAL
84968: PUSH
84969: LD_VAR 0 2
84973: PUSH
84974: LD_VAR 0 1
84978: PPUSH
84979: CALL_OW 437
84983: PUSH
84984: LD_INT 1
84986: ARRAY
84987: PUSH
84988: LD_INT 2
84990: ARRAY
84991: EQUAL
84992: AND
84993: PUSH
84994: LD_VAR 0 3
84998: PUSH
84999: LD_VAR 0 1
85003: PPUSH
85004: CALL_OW 437
85008: PUSH
85009: LD_INT 1
85011: ARRAY
85012: PUSH
85013: LD_INT 3
85015: ARRAY
85016: EQUAL
85017: AND
85018: IFFALSE 85028
// result := true ;
85020: LD_ADDR_VAR 0 4
85024: PUSH
85025: LD_INT 1
85027: ST_TO_ADDR
// end ; end ;
85028: LD_VAR 0 4
85032: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85033: LD_INT 0
85035: PPUSH
85036: PPUSH
85037: PPUSH
85038: PPUSH
// if not unit or not area then
85039: LD_VAR 0 1
85043: NOT
85044: PUSH
85045: LD_VAR 0 2
85049: NOT
85050: OR
85051: IFFALSE 85055
// exit ;
85053: GO 85219
// tmp := AreaToList ( area , i ) ;
85055: LD_ADDR_VAR 0 6
85059: PUSH
85060: LD_VAR 0 2
85064: PPUSH
85065: LD_VAR 0 5
85069: PPUSH
85070: CALL_OW 517
85074: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85075: LD_ADDR_VAR 0 5
85079: PUSH
85080: DOUBLE
85081: LD_INT 1
85083: DEC
85084: ST_TO_ADDR
85085: LD_VAR 0 6
85089: PUSH
85090: LD_INT 1
85092: ARRAY
85093: PUSH
85094: FOR_TO
85095: IFFALSE 85217
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85097: LD_ADDR_VAR 0 7
85101: PUSH
85102: LD_VAR 0 6
85106: PUSH
85107: LD_INT 1
85109: ARRAY
85110: PUSH
85111: LD_VAR 0 5
85115: ARRAY
85116: PUSH
85117: LD_VAR 0 6
85121: PUSH
85122: LD_INT 2
85124: ARRAY
85125: PUSH
85126: LD_VAR 0 5
85130: ARRAY
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85136: LD_VAR 0 7
85140: PUSH
85141: LD_INT 1
85143: ARRAY
85144: PPUSH
85145: LD_VAR 0 7
85149: PUSH
85150: LD_INT 2
85152: ARRAY
85153: PPUSH
85154: CALL_OW 428
85158: PUSH
85159: LD_INT 0
85161: EQUAL
85162: IFFALSE 85215
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85164: LD_VAR 0 1
85168: PPUSH
85169: LD_VAR 0 7
85173: PUSH
85174: LD_INT 1
85176: ARRAY
85177: PPUSH
85178: LD_VAR 0 7
85182: PUSH
85183: LD_INT 2
85185: ARRAY
85186: PPUSH
85187: LD_VAR 0 3
85191: PPUSH
85192: CALL_OW 48
// result := IsPlaced ( unit ) ;
85196: LD_ADDR_VAR 0 4
85200: PUSH
85201: LD_VAR 0 1
85205: PPUSH
85206: CALL_OW 305
85210: ST_TO_ADDR
// exit ;
85211: POP
85212: POP
85213: GO 85219
// end ; end ;
85215: GO 85094
85217: POP
85218: POP
// end ;
85219: LD_VAR 0 4
85223: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85224: LD_INT 0
85226: PPUSH
85227: PPUSH
85228: PPUSH
// if not side or side > 8 then
85229: LD_VAR 0 1
85233: NOT
85234: PUSH
85235: LD_VAR 0 1
85239: PUSH
85240: LD_INT 8
85242: GREATER
85243: OR
85244: IFFALSE 85248
// exit ;
85246: GO 85435
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85248: LD_ADDR_VAR 0 4
85252: PUSH
85253: LD_INT 22
85255: PUSH
85256: LD_VAR 0 1
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 21
85267: PUSH
85268: LD_INT 3
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: PPUSH
85279: CALL_OW 69
85283: ST_TO_ADDR
// if not tmp then
85284: LD_VAR 0 4
85288: NOT
85289: IFFALSE 85293
// exit ;
85291: GO 85435
// enable_addtolog := true ;
85293: LD_ADDR_OWVAR 81
85297: PUSH
85298: LD_INT 1
85300: ST_TO_ADDR
// AddToLog ( [ ) ;
85301: LD_STRING [
85303: PPUSH
85304: CALL_OW 561
// for i in tmp do
85308: LD_ADDR_VAR 0 3
85312: PUSH
85313: LD_VAR 0 4
85317: PUSH
85318: FOR_IN
85319: IFFALSE 85426
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85321: LD_STRING [
85323: PUSH
85324: LD_VAR 0 3
85328: PPUSH
85329: CALL_OW 266
85333: STR
85334: PUSH
85335: LD_STRING , 
85337: STR
85338: PUSH
85339: LD_VAR 0 3
85343: PPUSH
85344: CALL_OW 250
85348: STR
85349: PUSH
85350: LD_STRING , 
85352: STR
85353: PUSH
85354: LD_VAR 0 3
85358: PPUSH
85359: CALL_OW 251
85363: STR
85364: PUSH
85365: LD_STRING , 
85367: STR
85368: PUSH
85369: LD_VAR 0 3
85373: PPUSH
85374: CALL_OW 254
85378: STR
85379: PUSH
85380: LD_STRING , 
85382: STR
85383: PUSH
85384: LD_VAR 0 3
85388: PPUSH
85389: LD_INT 1
85391: PPUSH
85392: CALL_OW 268
85396: STR
85397: PUSH
85398: LD_STRING , 
85400: STR
85401: PUSH
85402: LD_VAR 0 3
85406: PPUSH
85407: LD_INT 2
85409: PPUSH
85410: CALL_OW 268
85414: STR
85415: PUSH
85416: LD_STRING ],
85418: STR
85419: PPUSH
85420: CALL_OW 561
// end ;
85424: GO 85318
85426: POP
85427: POP
// AddToLog ( ]; ) ;
85428: LD_STRING ];
85430: PPUSH
85431: CALL_OW 561
// end ;
85435: LD_VAR 0 2
85439: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85440: LD_INT 0
85442: PPUSH
85443: PPUSH
85444: PPUSH
85445: PPUSH
85446: PPUSH
// if not area or not rate or not max then
85447: LD_VAR 0 1
85451: NOT
85452: PUSH
85453: LD_VAR 0 2
85457: NOT
85458: OR
85459: PUSH
85460: LD_VAR 0 4
85464: NOT
85465: OR
85466: IFFALSE 85470
// exit ;
85468: GO 85659
// while 1 do
85470: LD_INT 1
85472: IFFALSE 85659
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85474: LD_ADDR_VAR 0 9
85478: PUSH
85479: LD_VAR 0 1
85483: PPUSH
85484: LD_INT 1
85486: PPUSH
85487: CALL_OW 287
85491: PUSH
85492: LD_INT 10
85494: MUL
85495: ST_TO_ADDR
// r := rate / 10 ;
85496: LD_ADDR_VAR 0 7
85500: PUSH
85501: LD_VAR 0 2
85505: PUSH
85506: LD_INT 10
85508: DIVREAL
85509: ST_TO_ADDR
// time := 1 1$00 ;
85510: LD_ADDR_VAR 0 8
85514: PUSH
85515: LD_INT 2100
85517: ST_TO_ADDR
// if amount < min then
85518: LD_VAR 0 9
85522: PUSH
85523: LD_VAR 0 3
85527: LESS
85528: IFFALSE 85546
// r := r * 2 else
85530: LD_ADDR_VAR 0 7
85534: PUSH
85535: LD_VAR 0 7
85539: PUSH
85540: LD_INT 2
85542: MUL
85543: ST_TO_ADDR
85544: GO 85572
// if amount > max then
85546: LD_VAR 0 9
85550: PUSH
85551: LD_VAR 0 4
85555: GREATER
85556: IFFALSE 85572
// r := r / 2 ;
85558: LD_ADDR_VAR 0 7
85562: PUSH
85563: LD_VAR 0 7
85567: PUSH
85568: LD_INT 2
85570: DIVREAL
85571: ST_TO_ADDR
// time := time / r ;
85572: LD_ADDR_VAR 0 8
85576: PUSH
85577: LD_VAR 0 8
85581: PUSH
85582: LD_VAR 0 7
85586: DIVREAL
85587: ST_TO_ADDR
// if time < 0 then
85588: LD_VAR 0 8
85592: PUSH
85593: LD_INT 0
85595: LESS
85596: IFFALSE 85613
// time := time * - 1 ;
85598: LD_ADDR_VAR 0 8
85602: PUSH
85603: LD_VAR 0 8
85607: PUSH
85608: LD_INT 1
85610: NEG
85611: MUL
85612: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
85613: LD_VAR 0 8
85617: PUSH
85618: LD_INT 35
85620: PPUSH
85621: LD_INT 875
85623: PPUSH
85624: CALL_OW 12
85628: PLUS
85629: PPUSH
85630: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
85634: LD_INT 1
85636: PPUSH
85637: LD_INT 5
85639: PPUSH
85640: CALL_OW 12
85644: PPUSH
85645: LD_VAR 0 1
85649: PPUSH
85650: LD_INT 1
85652: PPUSH
85653: CALL_OW 55
// end ;
85657: GO 85470
// end ;
85659: LD_VAR 0 5
85663: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
85664: LD_INT 0
85666: PPUSH
85667: PPUSH
85668: PPUSH
85669: PPUSH
85670: PPUSH
85671: PPUSH
85672: PPUSH
85673: PPUSH
// if not turrets or not factories then
85674: LD_VAR 0 1
85678: NOT
85679: PUSH
85680: LD_VAR 0 2
85684: NOT
85685: OR
85686: IFFALSE 85690
// exit ;
85688: GO 85997
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
85690: LD_ADDR_VAR 0 10
85694: PUSH
85695: LD_INT 5
85697: PUSH
85698: LD_INT 6
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: LD_INT 2
85707: PUSH
85708: LD_INT 4
85710: PUSH
85711: EMPTY
85712: LIST
85713: LIST
85714: PUSH
85715: LD_INT 3
85717: PUSH
85718: LD_INT 5
85720: PUSH
85721: EMPTY
85722: LIST
85723: LIST
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: LIST
85729: PUSH
85730: LD_INT 24
85732: PUSH
85733: LD_INT 25
85735: PUSH
85736: EMPTY
85737: LIST
85738: LIST
85739: PUSH
85740: LD_INT 23
85742: PUSH
85743: LD_INT 27
85745: PUSH
85746: EMPTY
85747: LIST
85748: LIST
85749: PUSH
85750: EMPTY
85751: LIST
85752: LIST
85753: PUSH
85754: LD_INT 42
85756: PUSH
85757: LD_INT 43
85759: PUSH
85760: EMPTY
85761: LIST
85762: LIST
85763: PUSH
85764: LD_INT 44
85766: PUSH
85767: LD_INT 46
85769: PUSH
85770: EMPTY
85771: LIST
85772: LIST
85773: PUSH
85774: LD_INT 45
85776: PUSH
85777: LD_INT 47
85779: PUSH
85780: EMPTY
85781: LIST
85782: LIST
85783: PUSH
85784: EMPTY
85785: LIST
85786: LIST
85787: LIST
85788: PUSH
85789: EMPTY
85790: LIST
85791: LIST
85792: LIST
85793: ST_TO_ADDR
// result := [ ] ;
85794: LD_ADDR_VAR 0 3
85798: PUSH
85799: EMPTY
85800: ST_TO_ADDR
// for i in turrets do
85801: LD_ADDR_VAR 0 4
85805: PUSH
85806: LD_VAR 0 1
85810: PUSH
85811: FOR_IN
85812: IFFALSE 85995
// begin nat := GetNation ( i ) ;
85814: LD_ADDR_VAR 0 7
85818: PUSH
85819: LD_VAR 0 4
85823: PPUSH
85824: CALL_OW 248
85828: ST_TO_ADDR
// weapon := 0 ;
85829: LD_ADDR_VAR 0 8
85833: PUSH
85834: LD_INT 0
85836: ST_TO_ADDR
// if not nat then
85837: LD_VAR 0 7
85841: NOT
85842: IFFALSE 85846
// continue ;
85844: GO 85811
// for j in list [ nat ] do
85846: LD_ADDR_VAR 0 5
85850: PUSH
85851: LD_VAR 0 10
85855: PUSH
85856: LD_VAR 0 7
85860: ARRAY
85861: PUSH
85862: FOR_IN
85863: IFFALSE 85904
// if GetBWeapon ( i ) = j [ 1 ] then
85865: LD_VAR 0 4
85869: PPUSH
85870: CALL_OW 269
85874: PUSH
85875: LD_VAR 0 5
85879: PUSH
85880: LD_INT 1
85882: ARRAY
85883: EQUAL
85884: IFFALSE 85902
// begin weapon := j [ 2 ] ;
85886: LD_ADDR_VAR 0 8
85890: PUSH
85891: LD_VAR 0 5
85895: PUSH
85896: LD_INT 2
85898: ARRAY
85899: ST_TO_ADDR
// break ;
85900: GO 85904
// end ;
85902: GO 85862
85904: POP
85905: POP
// if not weapon then
85906: LD_VAR 0 8
85910: NOT
85911: IFFALSE 85915
// continue ;
85913: GO 85811
// for k in factories do
85915: LD_ADDR_VAR 0 6
85919: PUSH
85920: LD_VAR 0 2
85924: PUSH
85925: FOR_IN
85926: IFFALSE 85991
// begin weapons := AvailableWeaponList ( k ) ;
85928: LD_ADDR_VAR 0 9
85932: PUSH
85933: LD_VAR 0 6
85937: PPUSH
85938: CALL_OW 478
85942: ST_TO_ADDR
// if not weapons then
85943: LD_VAR 0 9
85947: NOT
85948: IFFALSE 85952
// continue ;
85950: GO 85925
// if weapon in weapons then
85952: LD_VAR 0 8
85956: PUSH
85957: LD_VAR 0 9
85961: IN
85962: IFFALSE 85989
// begin result := [ i , weapon ] ;
85964: LD_ADDR_VAR 0 3
85968: PUSH
85969: LD_VAR 0 4
85973: PUSH
85974: LD_VAR 0 8
85978: PUSH
85979: EMPTY
85980: LIST
85981: LIST
85982: ST_TO_ADDR
// exit ;
85983: POP
85984: POP
85985: POP
85986: POP
85987: GO 85997
// end ; end ;
85989: GO 85925
85991: POP
85992: POP
// end ;
85993: GO 85811
85995: POP
85996: POP
// end ;
85997: LD_VAR 0 3
86001: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86002: LD_INT 0
86004: PPUSH
// if not side or side > 8 then
86005: LD_VAR 0 3
86009: NOT
86010: PUSH
86011: LD_VAR 0 3
86015: PUSH
86016: LD_INT 8
86018: GREATER
86019: OR
86020: IFFALSE 86024
// exit ;
86022: GO 86083
// if not range then
86024: LD_VAR 0 4
86028: NOT
86029: IFFALSE 86040
// range := - 12 ;
86031: LD_ADDR_VAR 0 4
86035: PUSH
86036: LD_INT 12
86038: NEG
86039: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86040: LD_VAR 0 1
86044: PPUSH
86045: LD_VAR 0 2
86049: PPUSH
86050: LD_VAR 0 3
86054: PPUSH
86055: LD_VAR 0 4
86059: PPUSH
86060: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86064: LD_VAR 0 1
86068: PPUSH
86069: LD_VAR 0 2
86073: PPUSH
86074: LD_VAR 0 3
86078: PPUSH
86079: CALL_OW 331
// end ;
86083: LD_VAR 0 5
86087: RET
// export function Video ( mode ) ; begin
86088: LD_INT 0
86090: PPUSH
// ingame_video = mode ;
86091: LD_ADDR_OWVAR 52
86095: PUSH
86096: LD_VAR 0 1
86100: ST_TO_ADDR
// interface_hidden = mode ;
86101: LD_ADDR_OWVAR 54
86105: PUSH
86106: LD_VAR 0 1
86110: ST_TO_ADDR
// end ;
86111: LD_VAR 0 2
86115: RET
// export function Join ( array , element ) ; begin
86116: LD_INT 0
86118: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86119: LD_ADDR_VAR 0 3
86123: PUSH
86124: LD_VAR 0 1
86128: PPUSH
86129: LD_VAR 0 1
86133: PUSH
86134: LD_INT 1
86136: PLUS
86137: PPUSH
86138: LD_VAR 0 2
86142: PPUSH
86143: CALL_OW 1
86147: ST_TO_ADDR
// end ;
86148: LD_VAR 0 3
86152: RET
// export function JoinUnion ( array , element ) ; begin
86153: LD_INT 0
86155: PPUSH
// result := array union element ;
86156: LD_ADDR_VAR 0 3
86160: PUSH
86161: LD_VAR 0 1
86165: PUSH
86166: LD_VAR 0 2
86170: UNION
86171: ST_TO_ADDR
// end ;
86172: LD_VAR 0 3
86176: RET
// export function GetBehemoths ( side ) ; begin
86177: LD_INT 0
86179: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86180: LD_ADDR_VAR 0 2
86184: PUSH
86185: LD_INT 22
86187: PUSH
86188: LD_VAR 0 1
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: PUSH
86197: LD_INT 31
86199: PUSH
86200: LD_INT 25
86202: PUSH
86203: EMPTY
86204: LIST
86205: LIST
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PPUSH
86211: CALL_OW 69
86215: ST_TO_ADDR
// end ;
86216: LD_VAR 0 2
86220: RET
// export function Shuffle ( array ) ; var i , index ; begin
86221: LD_INT 0
86223: PPUSH
86224: PPUSH
86225: PPUSH
// result := [ ] ;
86226: LD_ADDR_VAR 0 2
86230: PUSH
86231: EMPTY
86232: ST_TO_ADDR
// if not array then
86233: LD_VAR 0 1
86237: NOT
86238: IFFALSE 86242
// exit ;
86240: GO 86341
// Randomize ;
86242: CALL_OW 10
// for i = array downto 1 do
86246: LD_ADDR_VAR 0 3
86250: PUSH
86251: DOUBLE
86252: LD_VAR 0 1
86256: INC
86257: ST_TO_ADDR
86258: LD_INT 1
86260: PUSH
86261: FOR_DOWNTO
86262: IFFALSE 86339
// begin index := rand ( 1 , array ) ;
86264: LD_ADDR_VAR 0 4
86268: PUSH
86269: LD_INT 1
86271: PPUSH
86272: LD_VAR 0 1
86276: PPUSH
86277: CALL_OW 12
86281: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86282: LD_ADDR_VAR 0 2
86286: PUSH
86287: LD_VAR 0 2
86291: PPUSH
86292: LD_VAR 0 2
86296: PUSH
86297: LD_INT 1
86299: PLUS
86300: PPUSH
86301: LD_VAR 0 1
86305: PUSH
86306: LD_VAR 0 4
86310: ARRAY
86311: PPUSH
86312: CALL_OW 2
86316: ST_TO_ADDR
// array := Delete ( array , index ) ;
86317: LD_ADDR_VAR 0 1
86321: PUSH
86322: LD_VAR 0 1
86326: PPUSH
86327: LD_VAR 0 4
86331: PPUSH
86332: CALL_OW 3
86336: ST_TO_ADDR
// end ;
86337: GO 86261
86339: POP
86340: POP
// end ;
86341: LD_VAR 0 2
86345: RET
// export function GetBaseMaterials ( base ) ; begin
86346: LD_INT 0
86348: PPUSH
// result := [ 0 , 0 , 0 ] ;
86349: LD_ADDR_VAR 0 2
86353: PUSH
86354: LD_INT 0
86356: PUSH
86357: LD_INT 0
86359: PUSH
86360: LD_INT 0
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: LIST
86367: ST_TO_ADDR
// if not base then
86368: LD_VAR 0 1
86372: NOT
86373: IFFALSE 86377
// exit ;
86375: GO 86426
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86377: LD_ADDR_VAR 0 2
86381: PUSH
86382: LD_VAR 0 1
86386: PPUSH
86387: LD_INT 1
86389: PPUSH
86390: CALL_OW 275
86394: PUSH
86395: LD_VAR 0 1
86399: PPUSH
86400: LD_INT 2
86402: PPUSH
86403: CALL_OW 275
86407: PUSH
86408: LD_VAR 0 1
86412: PPUSH
86413: LD_INT 3
86415: PPUSH
86416: CALL_OW 275
86420: PUSH
86421: EMPTY
86422: LIST
86423: LIST
86424: LIST
86425: ST_TO_ADDR
// end ;
86426: LD_VAR 0 2
86430: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86431: LD_INT 0
86433: PPUSH
86434: PPUSH
// result := array ;
86435: LD_ADDR_VAR 0 3
86439: PUSH
86440: LD_VAR 0 1
86444: ST_TO_ADDR
// if size >= result then
86445: LD_VAR 0 2
86449: PUSH
86450: LD_VAR 0 3
86454: GREATEREQUAL
86455: IFFALSE 86459
// exit ;
86457: GO 86509
// if size then
86459: LD_VAR 0 2
86463: IFFALSE 86509
// for i := array downto size do
86465: LD_ADDR_VAR 0 4
86469: PUSH
86470: DOUBLE
86471: LD_VAR 0 1
86475: INC
86476: ST_TO_ADDR
86477: LD_VAR 0 2
86481: PUSH
86482: FOR_DOWNTO
86483: IFFALSE 86507
// result := Delete ( result , result ) ;
86485: LD_ADDR_VAR 0 3
86489: PUSH
86490: LD_VAR 0 3
86494: PPUSH
86495: LD_VAR 0 3
86499: PPUSH
86500: CALL_OW 3
86504: ST_TO_ADDR
86505: GO 86482
86507: POP
86508: POP
// end ;
86509: LD_VAR 0 3
86513: RET
// export function ComExit ( unit ) ; var tmp ; begin
86514: LD_INT 0
86516: PPUSH
86517: PPUSH
// if not IsInUnit ( unit ) then
86518: LD_VAR 0 1
86522: PPUSH
86523: CALL_OW 310
86527: NOT
86528: IFFALSE 86532
// exit ;
86530: GO 86592
// tmp := IsInUnit ( unit ) ;
86532: LD_ADDR_VAR 0 3
86536: PUSH
86537: LD_VAR 0 1
86541: PPUSH
86542: CALL_OW 310
86546: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
86547: LD_VAR 0 3
86551: PPUSH
86552: CALL_OW 247
86556: PUSH
86557: LD_INT 2
86559: EQUAL
86560: IFFALSE 86573
// ComExitVehicle ( unit ) else
86562: LD_VAR 0 1
86566: PPUSH
86567: CALL_OW 121
86571: GO 86582
// ComExitBuilding ( unit ) ;
86573: LD_VAR 0 1
86577: PPUSH
86578: CALL_OW 122
// result := tmp ;
86582: LD_ADDR_VAR 0 2
86586: PUSH
86587: LD_VAR 0 3
86591: ST_TO_ADDR
// end ;
86592: LD_VAR 0 2
86596: RET
// export function ComExitAll ( units ) ; var i ; begin
86597: LD_INT 0
86599: PPUSH
86600: PPUSH
// if not units then
86601: LD_VAR 0 1
86605: NOT
86606: IFFALSE 86610
// exit ;
86608: GO 86636
// for i in units do
86610: LD_ADDR_VAR 0 3
86614: PUSH
86615: LD_VAR 0 1
86619: PUSH
86620: FOR_IN
86621: IFFALSE 86634
// ComExit ( i ) ;
86623: LD_VAR 0 3
86627: PPUSH
86628: CALL 86514 0 1
86632: GO 86620
86634: POP
86635: POP
// end ;
86636: LD_VAR 0 2
86640: RET
// export function ResetHc ; begin
86641: LD_INT 0
86643: PPUSH
// InitHc ;
86644: CALL_OW 19
// hc_importance := 0 ;
86648: LD_ADDR_OWVAR 32
86652: PUSH
86653: LD_INT 0
86655: ST_TO_ADDR
// end ;
86656: LD_VAR 0 1
86660: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
86661: LD_INT 0
86663: PPUSH
86664: PPUSH
86665: PPUSH
// _x := ( x1 + x2 ) div 2 ;
86666: LD_ADDR_VAR 0 6
86670: PUSH
86671: LD_VAR 0 1
86675: PUSH
86676: LD_VAR 0 3
86680: PLUS
86681: PUSH
86682: LD_INT 2
86684: DIV
86685: ST_TO_ADDR
// if _x < 0 then
86686: LD_VAR 0 6
86690: PUSH
86691: LD_INT 0
86693: LESS
86694: IFFALSE 86711
// _x := _x * - 1 ;
86696: LD_ADDR_VAR 0 6
86700: PUSH
86701: LD_VAR 0 6
86705: PUSH
86706: LD_INT 1
86708: NEG
86709: MUL
86710: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
86711: LD_ADDR_VAR 0 7
86715: PUSH
86716: LD_VAR 0 2
86720: PUSH
86721: LD_VAR 0 4
86725: PLUS
86726: PUSH
86727: LD_INT 2
86729: DIV
86730: ST_TO_ADDR
// if _y < 0 then
86731: LD_VAR 0 7
86735: PUSH
86736: LD_INT 0
86738: LESS
86739: IFFALSE 86756
// _y := _y * - 1 ;
86741: LD_ADDR_VAR 0 7
86745: PUSH
86746: LD_VAR 0 7
86750: PUSH
86751: LD_INT 1
86753: NEG
86754: MUL
86755: ST_TO_ADDR
// result := [ _x , _y ] ;
86756: LD_ADDR_VAR 0 5
86760: PUSH
86761: LD_VAR 0 6
86765: PUSH
86766: LD_VAR 0 7
86770: PUSH
86771: EMPTY
86772: LIST
86773: LIST
86774: ST_TO_ADDR
// end ;
86775: LD_VAR 0 5
86779: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
86780: LD_INT 0
86782: PPUSH
86783: PPUSH
86784: PPUSH
86785: PPUSH
// task := GetTaskList ( unit ) ;
86786: LD_ADDR_VAR 0 7
86790: PUSH
86791: LD_VAR 0 1
86795: PPUSH
86796: CALL_OW 437
86800: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
86801: LD_VAR 0 7
86805: NOT
86806: PUSH
86807: LD_VAR 0 1
86811: PPUSH
86812: LD_VAR 0 2
86816: PPUSH
86817: CALL_OW 308
86821: NOT
86822: AND
86823: IFFALSE 86827
// exit ;
86825: GO 86945
// if IsInArea ( unit , area ) then
86827: LD_VAR 0 1
86831: PPUSH
86832: LD_VAR 0 2
86836: PPUSH
86837: CALL_OW 308
86841: IFFALSE 86859
// begin ComMoveToArea ( unit , goAway ) ;
86843: LD_VAR 0 1
86847: PPUSH
86848: LD_VAR 0 3
86852: PPUSH
86853: CALL_OW 113
// exit ;
86857: GO 86945
// end ; if task [ 1 ] [ 1 ] <> M then
86859: LD_VAR 0 7
86863: PUSH
86864: LD_INT 1
86866: ARRAY
86867: PUSH
86868: LD_INT 1
86870: ARRAY
86871: PUSH
86872: LD_STRING M
86874: NONEQUAL
86875: IFFALSE 86879
// exit ;
86877: GO 86945
// x := task [ 1 ] [ 2 ] ;
86879: LD_ADDR_VAR 0 5
86883: PUSH
86884: LD_VAR 0 7
86888: PUSH
86889: LD_INT 1
86891: ARRAY
86892: PUSH
86893: LD_INT 2
86895: ARRAY
86896: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
86897: LD_ADDR_VAR 0 6
86901: PUSH
86902: LD_VAR 0 7
86906: PUSH
86907: LD_INT 1
86909: ARRAY
86910: PUSH
86911: LD_INT 3
86913: ARRAY
86914: ST_TO_ADDR
// if InArea ( x , y , area ) then
86915: LD_VAR 0 5
86919: PPUSH
86920: LD_VAR 0 6
86924: PPUSH
86925: LD_VAR 0 2
86929: PPUSH
86930: CALL_OW 309
86934: IFFALSE 86945
// ComStop ( unit ) ;
86936: LD_VAR 0 1
86940: PPUSH
86941: CALL_OW 141
// end ;
86945: LD_VAR 0 4
86949: RET
// export function Abs ( value ) ; begin
86950: LD_INT 0
86952: PPUSH
// result := value ;
86953: LD_ADDR_VAR 0 2
86957: PUSH
86958: LD_VAR 0 1
86962: ST_TO_ADDR
// if value < 0 then
86963: LD_VAR 0 1
86967: PUSH
86968: LD_INT 0
86970: LESS
86971: IFFALSE 86988
// result := value * - 1 ;
86973: LD_ADDR_VAR 0 2
86977: PUSH
86978: LD_VAR 0 1
86982: PUSH
86983: LD_INT 1
86985: NEG
86986: MUL
86987: ST_TO_ADDR
// end ;
86988: LD_VAR 0 2
86992: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
86993: LD_INT 0
86995: PPUSH
86996: PPUSH
86997: PPUSH
86998: PPUSH
86999: PPUSH
87000: PPUSH
87001: PPUSH
87002: PPUSH
// if not unit or not building then
87003: LD_VAR 0 1
87007: NOT
87008: PUSH
87009: LD_VAR 0 2
87013: NOT
87014: OR
87015: IFFALSE 87019
// exit ;
87017: GO 87245
// x := GetX ( building ) ;
87019: LD_ADDR_VAR 0 4
87023: PUSH
87024: LD_VAR 0 2
87028: PPUSH
87029: CALL_OW 250
87033: ST_TO_ADDR
// y := GetY ( building ) ;
87034: LD_ADDR_VAR 0 6
87038: PUSH
87039: LD_VAR 0 2
87043: PPUSH
87044: CALL_OW 251
87048: ST_TO_ADDR
// d := GetDir ( building ) ;
87049: LD_ADDR_VAR 0 8
87053: PUSH
87054: LD_VAR 0 2
87058: PPUSH
87059: CALL_OW 254
87063: ST_TO_ADDR
// r := 4 ;
87064: LD_ADDR_VAR 0 9
87068: PUSH
87069: LD_INT 4
87071: ST_TO_ADDR
// for i := 1 to 5 do
87072: LD_ADDR_VAR 0 10
87076: PUSH
87077: DOUBLE
87078: LD_INT 1
87080: DEC
87081: ST_TO_ADDR
87082: LD_INT 5
87084: PUSH
87085: FOR_TO
87086: IFFALSE 87243
// begin _x := ShiftX ( x , d , r + i ) ;
87088: LD_ADDR_VAR 0 5
87092: PUSH
87093: LD_VAR 0 4
87097: PPUSH
87098: LD_VAR 0 8
87102: PPUSH
87103: LD_VAR 0 9
87107: PUSH
87108: LD_VAR 0 10
87112: PLUS
87113: PPUSH
87114: CALL_OW 272
87118: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87119: LD_ADDR_VAR 0 7
87123: PUSH
87124: LD_VAR 0 6
87128: PPUSH
87129: LD_VAR 0 8
87133: PPUSH
87134: LD_VAR 0 9
87138: PUSH
87139: LD_VAR 0 10
87143: PLUS
87144: PPUSH
87145: CALL_OW 273
87149: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87150: LD_VAR 0 5
87154: PPUSH
87155: LD_VAR 0 7
87159: PPUSH
87160: CALL_OW 488
87164: PUSH
87165: LD_VAR 0 5
87169: PPUSH
87170: LD_VAR 0 7
87174: PPUSH
87175: CALL_OW 428
87179: PPUSH
87180: CALL_OW 247
87184: PUSH
87185: LD_INT 3
87187: PUSH
87188: LD_INT 2
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: IN
87195: NOT
87196: AND
87197: IFFALSE 87241
// begin ComMoveXY ( unit , _x , _y ) ;
87199: LD_VAR 0 1
87203: PPUSH
87204: LD_VAR 0 5
87208: PPUSH
87209: LD_VAR 0 7
87213: PPUSH
87214: CALL_OW 111
// result := [ _x , _y ] ;
87218: LD_ADDR_VAR 0 3
87222: PUSH
87223: LD_VAR 0 5
87227: PUSH
87228: LD_VAR 0 7
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: ST_TO_ADDR
// exit ;
87237: POP
87238: POP
87239: GO 87245
// end ; end ;
87241: GO 87085
87243: POP
87244: POP
// end ;
87245: LD_VAR 0 3
87249: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87250: LD_INT 0
87252: PPUSH
87253: PPUSH
87254: PPUSH
// result := 0 ;
87255: LD_ADDR_VAR 0 3
87259: PUSH
87260: LD_INT 0
87262: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87263: LD_VAR 0 1
87267: PUSH
87268: LD_INT 0
87270: LESS
87271: PUSH
87272: LD_VAR 0 1
87276: PUSH
87277: LD_INT 8
87279: GREATER
87280: OR
87281: PUSH
87282: LD_VAR 0 2
87286: PUSH
87287: LD_INT 0
87289: LESS
87290: OR
87291: PUSH
87292: LD_VAR 0 2
87296: PUSH
87297: LD_INT 8
87299: GREATER
87300: OR
87301: IFFALSE 87305
// exit ;
87303: GO 87380
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87305: LD_ADDR_VAR 0 4
87309: PUSH
87310: LD_INT 22
87312: PUSH
87313: LD_VAR 0 2
87317: PUSH
87318: EMPTY
87319: LIST
87320: LIST
87321: PPUSH
87322: CALL_OW 69
87326: PUSH
87327: FOR_IN
87328: IFFALSE 87378
// begin un := UnitShoot ( i ) ;
87330: LD_ADDR_VAR 0 5
87334: PUSH
87335: LD_VAR 0 4
87339: PPUSH
87340: CALL_OW 504
87344: ST_TO_ADDR
// if GetSide ( un ) = side1 then
87345: LD_VAR 0 5
87349: PPUSH
87350: CALL_OW 255
87354: PUSH
87355: LD_VAR 0 1
87359: EQUAL
87360: IFFALSE 87376
// begin result := un ;
87362: LD_ADDR_VAR 0 3
87366: PUSH
87367: LD_VAR 0 5
87371: ST_TO_ADDR
// exit ;
87372: POP
87373: POP
87374: GO 87380
// end ; end ;
87376: GO 87327
87378: POP
87379: POP
// end ;
87380: LD_VAR 0 3
87384: RET
// export function GetCargoBay ( units ) ; begin
87385: LD_INT 0
87387: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
87388: LD_ADDR_VAR 0 2
87392: PUSH
87393: LD_VAR 0 1
87397: PPUSH
87398: LD_INT 2
87400: PUSH
87401: LD_INT 34
87403: PUSH
87404: LD_INT 12
87406: PUSH
87407: EMPTY
87408: LIST
87409: LIST
87410: PUSH
87411: LD_INT 34
87413: PUSH
87414: LD_INT 51
87416: PUSH
87417: EMPTY
87418: LIST
87419: LIST
87420: PUSH
87421: LD_INT 34
87423: PUSH
87424: LD_INT 32
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: LD_INT 34
87433: PUSH
87434: LD_INT 89
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: EMPTY
87442: LIST
87443: LIST
87444: LIST
87445: LIST
87446: LIST
87447: PPUSH
87448: CALL_OW 72
87452: ST_TO_ADDR
// end ;
87453: LD_VAR 0 2
87457: RET
// export function Negate ( value ) ; begin
87458: LD_INT 0
87460: PPUSH
// result := not value ;
87461: LD_ADDR_VAR 0 2
87465: PUSH
87466: LD_VAR 0 1
87470: NOT
87471: ST_TO_ADDR
// end ;
87472: LD_VAR 0 2
87476: RET
// export function Inc ( value ) ; begin
87477: LD_INT 0
87479: PPUSH
// result := value + 1 ;
87480: LD_ADDR_VAR 0 2
87484: PUSH
87485: LD_VAR 0 1
87489: PUSH
87490: LD_INT 1
87492: PLUS
87493: ST_TO_ADDR
// end ;
87494: LD_VAR 0 2
87498: RET
// export function Dec ( value ) ; begin
87499: LD_INT 0
87501: PPUSH
// result := value - 1 ;
87502: LD_ADDR_VAR 0 2
87506: PUSH
87507: LD_VAR 0 1
87511: PUSH
87512: LD_INT 1
87514: MINUS
87515: ST_TO_ADDR
// end ;
87516: LD_VAR 0 2
87520: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
87521: LD_INT 0
87523: PPUSH
87524: PPUSH
87525: PPUSH
87526: PPUSH
87527: PPUSH
87528: PPUSH
87529: PPUSH
87530: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
87531: LD_VAR 0 1
87535: PPUSH
87536: LD_VAR 0 2
87540: PPUSH
87541: CALL_OW 488
87545: NOT
87546: PUSH
87547: LD_VAR 0 3
87551: PPUSH
87552: LD_VAR 0 4
87556: PPUSH
87557: CALL_OW 488
87561: NOT
87562: OR
87563: IFFALSE 87576
// begin result := - 1 ;
87565: LD_ADDR_VAR 0 5
87569: PUSH
87570: LD_INT 1
87572: NEG
87573: ST_TO_ADDR
// exit ;
87574: GO 87811
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
87576: LD_ADDR_VAR 0 12
87580: PUSH
87581: LD_VAR 0 1
87585: PPUSH
87586: LD_VAR 0 2
87590: PPUSH
87591: LD_VAR 0 3
87595: PPUSH
87596: LD_VAR 0 4
87600: PPUSH
87601: CALL 86661 0 4
87605: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
87606: LD_ADDR_VAR 0 11
87610: PUSH
87611: LD_VAR 0 1
87615: PPUSH
87616: LD_VAR 0 2
87620: PPUSH
87621: LD_VAR 0 12
87625: PUSH
87626: LD_INT 1
87628: ARRAY
87629: PPUSH
87630: LD_VAR 0 12
87634: PUSH
87635: LD_INT 2
87637: ARRAY
87638: PPUSH
87639: CALL_OW 298
87643: ST_TO_ADDR
// distance := 9999 ;
87644: LD_ADDR_VAR 0 10
87648: PUSH
87649: LD_INT 9999
87651: ST_TO_ADDR
// for i := 0 to 5 do
87652: LD_ADDR_VAR 0 6
87656: PUSH
87657: DOUBLE
87658: LD_INT 0
87660: DEC
87661: ST_TO_ADDR
87662: LD_INT 5
87664: PUSH
87665: FOR_TO
87666: IFFALSE 87809
// begin _x := ShiftX ( x1 , i , centerDist ) ;
87668: LD_ADDR_VAR 0 7
87672: PUSH
87673: LD_VAR 0 1
87677: PPUSH
87678: LD_VAR 0 6
87682: PPUSH
87683: LD_VAR 0 11
87687: PPUSH
87688: CALL_OW 272
87692: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
87693: LD_ADDR_VAR 0 8
87697: PUSH
87698: LD_VAR 0 2
87702: PPUSH
87703: LD_VAR 0 6
87707: PPUSH
87708: LD_VAR 0 11
87712: PPUSH
87713: CALL_OW 273
87717: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
87718: LD_VAR 0 7
87722: PPUSH
87723: LD_VAR 0 8
87727: PPUSH
87728: CALL_OW 488
87732: NOT
87733: IFFALSE 87737
// continue ;
87735: GO 87665
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
87737: LD_ADDR_VAR 0 9
87741: PUSH
87742: LD_VAR 0 12
87746: PUSH
87747: LD_INT 1
87749: ARRAY
87750: PPUSH
87751: LD_VAR 0 12
87755: PUSH
87756: LD_INT 2
87758: ARRAY
87759: PPUSH
87760: LD_VAR 0 7
87764: PPUSH
87765: LD_VAR 0 8
87769: PPUSH
87770: CALL_OW 298
87774: ST_TO_ADDR
// if tmp < distance then
87775: LD_VAR 0 9
87779: PUSH
87780: LD_VAR 0 10
87784: LESS
87785: IFFALSE 87807
// begin result := i ;
87787: LD_ADDR_VAR 0 5
87791: PUSH
87792: LD_VAR 0 6
87796: ST_TO_ADDR
// distance := tmp ;
87797: LD_ADDR_VAR 0 10
87801: PUSH
87802: LD_VAR 0 9
87806: ST_TO_ADDR
// end ; end ;
87807: GO 87665
87809: POP
87810: POP
// end ;
87811: LD_VAR 0 5
87815: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87816: LD_INT 0
87818: PPUSH
87819: PPUSH
// if not driver or not IsInUnit ( driver ) then
87820: LD_VAR 0 1
87824: NOT
87825: PUSH
87826: LD_VAR 0 1
87830: PPUSH
87831: CALL_OW 310
87835: NOT
87836: OR
87837: IFFALSE 87841
// exit ;
87839: GO 87931
// vehicle := IsInUnit ( driver ) ;
87841: LD_ADDR_VAR 0 3
87845: PUSH
87846: LD_VAR 0 1
87850: PPUSH
87851: CALL_OW 310
87855: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87856: LD_VAR 0 1
87860: PPUSH
87861: LD_STRING \
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: LD_INT 0
87869: PUSH
87870: LD_INT 0
87872: PUSH
87873: LD_INT 0
87875: PUSH
87876: LD_INT 0
87878: PUSH
87879: LD_INT 0
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: LIST
87886: LIST
87887: LIST
87888: LIST
87889: LIST
87890: PUSH
87891: LD_STRING E
87893: PUSH
87894: LD_INT 0
87896: PUSH
87897: LD_INT 0
87899: PUSH
87900: LD_VAR 0 3
87904: PUSH
87905: LD_INT 0
87907: PUSH
87908: LD_INT 0
87910: PUSH
87911: LD_INT 0
87913: PUSH
87914: EMPTY
87915: LIST
87916: LIST
87917: LIST
87918: LIST
87919: LIST
87920: LIST
87921: LIST
87922: PUSH
87923: EMPTY
87924: LIST
87925: LIST
87926: PPUSH
87927: CALL_OW 446
// end ;
87931: LD_VAR 0 2
87935: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87936: LD_INT 0
87938: PPUSH
87939: PPUSH
// if not driver or not IsInUnit ( driver ) then
87940: LD_VAR 0 1
87944: NOT
87945: PUSH
87946: LD_VAR 0 1
87950: PPUSH
87951: CALL_OW 310
87955: NOT
87956: OR
87957: IFFALSE 87961
// exit ;
87959: GO 88051
// vehicle := IsInUnit ( driver ) ;
87961: LD_ADDR_VAR 0 3
87965: PUSH
87966: LD_VAR 0 1
87970: PPUSH
87971: CALL_OW 310
87975: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87976: LD_VAR 0 1
87980: PPUSH
87981: LD_STRING \
87983: PUSH
87984: LD_INT 0
87986: PUSH
87987: LD_INT 0
87989: PUSH
87990: LD_INT 0
87992: PUSH
87993: LD_INT 0
87995: PUSH
87996: LD_INT 0
87998: PUSH
87999: LD_INT 0
88001: PUSH
88002: EMPTY
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: PUSH
88011: LD_STRING E
88013: PUSH
88014: LD_INT 0
88016: PUSH
88017: LD_INT 0
88019: PUSH
88020: LD_VAR 0 3
88024: PUSH
88025: LD_INT 0
88027: PUSH
88028: LD_INT 0
88030: PUSH
88031: LD_INT 0
88033: PUSH
88034: EMPTY
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: PUSH
88043: EMPTY
88044: LIST
88045: LIST
88046: PPUSH
88047: CALL_OW 447
// end ;
88051: LD_VAR 0 2
88055: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88056: LD_INT 0
88058: PPUSH
88059: PPUSH
88060: PPUSH
// tmp := [ ] ;
88061: LD_ADDR_VAR 0 5
88065: PUSH
88066: EMPTY
88067: ST_TO_ADDR
// for i in units do
88068: LD_ADDR_VAR 0 4
88072: PUSH
88073: LD_VAR 0 1
88077: PUSH
88078: FOR_IN
88079: IFFALSE 88117
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88081: LD_ADDR_VAR 0 5
88085: PUSH
88086: LD_VAR 0 5
88090: PPUSH
88091: LD_VAR 0 5
88095: PUSH
88096: LD_INT 1
88098: PLUS
88099: PPUSH
88100: LD_VAR 0 4
88104: PPUSH
88105: CALL_OW 256
88109: PPUSH
88110: CALL_OW 2
88114: ST_TO_ADDR
88115: GO 88078
88117: POP
88118: POP
// if not tmp then
88119: LD_VAR 0 5
88123: NOT
88124: IFFALSE 88128
// exit ;
88126: GO 88176
// if asc then
88128: LD_VAR 0 2
88132: IFFALSE 88156
// result := SortListByListAsc ( units , tmp ) else
88134: LD_ADDR_VAR 0 3
88138: PUSH
88139: LD_VAR 0 1
88143: PPUSH
88144: LD_VAR 0 5
88148: PPUSH
88149: CALL_OW 76
88153: ST_TO_ADDR
88154: GO 88176
// result := SortListByListDesc ( units , tmp ) ;
88156: LD_ADDR_VAR 0 3
88160: PUSH
88161: LD_VAR 0 1
88165: PPUSH
88166: LD_VAR 0 5
88170: PPUSH
88171: CALL_OW 77
88175: ST_TO_ADDR
// end ;
88176: LD_VAR 0 3
88180: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88181: LD_INT 0
88183: PPUSH
88184: PPUSH
// task := GetTaskList ( mech ) ;
88185: LD_ADDR_VAR 0 4
88189: PUSH
88190: LD_VAR 0 1
88194: PPUSH
88195: CALL_OW 437
88199: ST_TO_ADDR
// if not task then
88200: LD_VAR 0 4
88204: NOT
88205: IFFALSE 88209
// exit ;
88207: GO 88251
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88209: LD_ADDR_VAR 0 3
88213: PUSH
88214: LD_VAR 0 4
88218: PUSH
88219: LD_INT 1
88221: ARRAY
88222: PUSH
88223: LD_INT 1
88225: ARRAY
88226: PUSH
88227: LD_STRING r
88229: EQUAL
88230: PUSH
88231: LD_VAR 0 4
88235: PUSH
88236: LD_INT 1
88238: ARRAY
88239: PUSH
88240: LD_INT 4
88242: ARRAY
88243: PUSH
88244: LD_VAR 0 2
88248: EQUAL
88249: AND
88250: ST_TO_ADDR
// end ;
88251: LD_VAR 0 3
88255: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88256: LD_INT 0
88258: PPUSH
// SetDir ( unit , d ) ;
88259: LD_VAR 0 1
88263: PPUSH
88264: LD_VAR 0 4
88268: PPUSH
88269: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88273: LD_VAR 0 1
88277: PPUSH
88278: LD_VAR 0 2
88282: PPUSH
88283: LD_VAR 0 3
88287: PPUSH
88288: LD_VAR 0 5
88292: PPUSH
88293: CALL_OW 48
// end ;
88297: LD_VAR 0 6
88301: RET
// export function ToNaturalNumber ( number ) ; begin
88302: LD_INT 0
88304: PPUSH
// result := number div 1 ;
88305: LD_ADDR_VAR 0 2
88309: PUSH
88310: LD_VAR 0 1
88314: PUSH
88315: LD_INT 1
88317: DIV
88318: ST_TO_ADDR
// if number < 0 then
88319: LD_VAR 0 1
88323: PUSH
88324: LD_INT 0
88326: LESS
88327: IFFALSE 88337
// result := 0 ;
88329: LD_ADDR_VAR 0 2
88333: PUSH
88334: LD_INT 0
88336: ST_TO_ADDR
// end ;
88337: LD_VAR 0 2
88341: RET
// export function SortByClass ( units , class ) ; var un ; begin
88342: LD_INT 0
88344: PPUSH
88345: PPUSH
// if not units or not class then
88346: LD_VAR 0 1
88350: NOT
88351: PUSH
88352: LD_VAR 0 2
88356: NOT
88357: OR
88358: IFFALSE 88362
// exit ;
88360: GO 88457
// result := [ ] ;
88362: LD_ADDR_VAR 0 3
88366: PUSH
88367: EMPTY
88368: ST_TO_ADDR
// for un in units do
88369: LD_ADDR_VAR 0 4
88373: PUSH
88374: LD_VAR 0 1
88378: PUSH
88379: FOR_IN
88380: IFFALSE 88455
// if GetClass ( un ) = class then
88382: LD_VAR 0 4
88386: PPUSH
88387: CALL_OW 257
88391: PUSH
88392: LD_VAR 0 2
88396: EQUAL
88397: IFFALSE 88424
// result := Insert ( result , 1 , un ) else
88399: LD_ADDR_VAR 0 3
88403: PUSH
88404: LD_VAR 0 3
88408: PPUSH
88409: LD_INT 1
88411: PPUSH
88412: LD_VAR 0 4
88416: PPUSH
88417: CALL_OW 2
88421: ST_TO_ADDR
88422: GO 88453
// result := Replace ( result , result + 1 , un ) ;
88424: LD_ADDR_VAR 0 3
88428: PUSH
88429: LD_VAR 0 3
88433: PPUSH
88434: LD_VAR 0 3
88438: PUSH
88439: LD_INT 1
88441: PLUS
88442: PPUSH
88443: LD_VAR 0 4
88447: PPUSH
88448: CALL_OW 1
88452: ST_TO_ADDR
88453: GO 88379
88455: POP
88456: POP
// end ;
88457: LD_VAR 0 3
88461: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
88462: LD_INT 0
88464: PPUSH
88465: PPUSH
88466: PPUSH
88467: PPUSH
88468: PPUSH
88469: PPUSH
88470: PPUSH
// result := [ ] ;
88471: LD_ADDR_VAR 0 4
88475: PUSH
88476: EMPTY
88477: ST_TO_ADDR
// if x - r < 0 then
88478: LD_VAR 0 1
88482: PUSH
88483: LD_VAR 0 3
88487: MINUS
88488: PUSH
88489: LD_INT 0
88491: LESS
88492: IFFALSE 88504
// min_x := 0 else
88494: LD_ADDR_VAR 0 8
88498: PUSH
88499: LD_INT 0
88501: ST_TO_ADDR
88502: GO 88520
// min_x := x - r ;
88504: LD_ADDR_VAR 0 8
88508: PUSH
88509: LD_VAR 0 1
88513: PUSH
88514: LD_VAR 0 3
88518: MINUS
88519: ST_TO_ADDR
// if y - r < 0 then
88520: LD_VAR 0 2
88524: PUSH
88525: LD_VAR 0 3
88529: MINUS
88530: PUSH
88531: LD_INT 0
88533: LESS
88534: IFFALSE 88546
// min_y := 0 else
88536: LD_ADDR_VAR 0 7
88540: PUSH
88541: LD_INT 0
88543: ST_TO_ADDR
88544: GO 88562
// min_y := y - r ;
88546: LD_ADDR_VAR 0 7
88550: PUSH
88551: LD_VAR 0 2
88555: PUSH
88556: LD_VAR 0 3
88560: MINUS
88561: ST_TO_ADDR
// max_x := x + r ;
88562: LD_ADDR_VAR 0 9
88566: PUSH
88567: LD_VAR 0 1
88571: PUSH
88572: LD_VAR 0 3
88576: PLUS
88577: ST_TO_ADDR
// max_y := y + r ;
88578: LD_ADDR_VAR 0 10
88582: PUSH
88583: LD_VAR 0 2
88587: PUSH
88588: LD_VAR 0 3
88592: PLUS
88593: ST_TO_ADDR
// for _x = min_x to max_x do
88594: LD_ADDR_VAR 0 5
88598: PUSH
88599: DOUBLE
88600: LD_VAR 0 8
88604: DEC
88605: ST_TO_ADDR
88606: LD_VAR 0 9
88610: PUSH
88611: FOR_TO
88612: IFFALSE 88713
// for _y = min_y to max_y do
88614: LD_ADDR_VAR 0 6
88618: PUSH
88619: DOUBLE
88620: LD_VAR 0 7
88624: DEC
88625: ST_TO_ADDR
88626: LD_VAR 0 10
88630: PUSH
88631: FOR_TO
88632: IFFALSE 88709
// begin if not ValidHex ( _x , _y ) then
88634: LD_VAR 0 5
88638: PPUSH
88639: LD_VAR 0 6
88643: PPUSH
88644: CALL_OW 488
88648: NOT
88649: IFFALSE 88653
// continue ;
88651: GO 88631
// if GetResourceTypeXY ( _x , _y ) then
88653: LD_VAR 0 5
88657: PPUSH
88658: LD_VAR 0 6
88662: PPUSH
88663: CALL_OW 283
88667: IFFALSE 88707
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
88669: LD_ADDR_VAR 0 4
88673: PUSH
88674: LD_VAR 0 4
88678: PPUSH
88679: LD_VAR 0 4
88683: PUSH
88684: LD_INT 1
88686: PLUS
88687: PPUSH
88688: LD_VAR 0 5
88692: PUSH
88693: LD_VAR 0 6
88697: PUSH
88698: EMPTY
88699: LIST
88700: LIST
88701: PPUSH
88702: CALL_OW 1
88706: ST_TO_ADDR
// end ;
88707: GO 88631
88709: POP
88710: POP
88711: GO 88611
88713: POP
88714: POP
// end ;
88715: LD_VAR 0 4
88719: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
88720: LD_INT 0
88722: PPUSH
88723: PPUSH
88724: PPUSH
88725: PPUSH
88726: PPUSH
88727: PPUSH
88728: PPUSH
88729: PPUSH
// if not units then
88730: LD_VAR 0 1
88734: NOT
88735: IFFALSE 88739
// exit ;
88737: GO 89263
// result := UnitFilter ( units , [ f_ok ] ) ;
88739: LD_ADDR_VAR 0 3
88743: PUSH
88744: LD_VAR 0 1
88748: PPUSH
88749: LD_INT 50
88751: PUSH
88752: EMPTY
88753: LIST
88754: PPUSH
88755: CALL_OW 72
88759: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
88760: LD_ADDR_VAR 0 8
88764: PUSH
88765: LD_VAR 0 1
88769: PUSH
88770: LD_INT 1
88772: ARRAY
88773: PPUSH
88774: CALL_OW 255
88778: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
88779: LD_ADDR_VAR 0 10
88783: PUSH
88784: LD_INT 29
88786: PUSH
88787: LD_INT 91
88789: PUSH
88790: LD_INT 49
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: LIST
88797: ST_TO_ADDR
// if not result then
88798: LD_VAR 0 3
88802: NOT
88803: IFFALSE 88807
// exit ;
88805: GO 89263
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
88807: LD_ADDR_VAR 0 5
88811: PUSH
88812: LD_INT 81
88814: PUSH
88815: LD_VAR 0 8
88819: PUSH
88820: EMPTY
88821: LIST
88822: LIST
88823: PPUSH
88824: CALL_OW 69
88828: ST_TO_ADDR
// for i in result do
88829: LD_ADDR_VAR 0 4
88833: PUSH
88834: LD_VAR 0 3
88838: PUSH
88839: FOR_IN
88840: IFFALSE 89261
// begin tag := GetTag ( i ) + 1 ;
88842: LD_ADDR_VAR 0 9
88846: PUSH
88847: LD_VAR 0 4
88851: PPUSH
88852: CALL_OW 110
88856: PUSH
88857: LD_INT 1
88859: PLUS
88860: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
88861: LD_ADDR_VAR 0 7
88865: PUSH
88866: LD_VAR 0 4
88870: PPUSH
88871: CALL_OW 250
88875: PPUSH
88876: LD_VAR 0 4
88880: PPUSH
88881: CALL_OW 251
88885: PPUSH
88886: LD_INT 6
88888: PPUSH
88889: CALL 88462 0 3
88893: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
88894: LD_VAR 0 4
88898: PPUSH
88899: CALL_OW 247
88903: PUSH
88904: LD_INT 2
88906: EQUAL
88907: PUSH
88908: LD_VAR 0 7
88912: AND
88913: PUSH
88914: LD_VAR 0 4
88918: PPUSH
88919: CALL_OW 264
88923: PUSH
88924: LD_VAR 0 10
88928: IN
88929: NOT
88930: AND
88931: IFFALSE 88970
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
88933: LD_VAR 0 4
88937: PPUSH
88938: LD_VAR 0 7
88942: PUSH
88943: LD_INT 1
88945: ARRAY
88946: PUSH
88947: LD_INT 1
88949: ARRAY
88950: PPUSH
88951: LD_VAR 0 7
88955: PUSH
88956: LD_INT 1
88958: ARRAY
88959: PUSH
88960: LD_INT 2
88962: ARRAY
88963: PPUSH
88964: CALL_OW 116
88968: GO 89259
// if path > tag then
88970: LD_VAR 0 2
88974: PUSH
88975: LD_VAR 0 9
88979: GREATER
88980: IFFALSE 89188
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
88982: LD_ADDR_VAR 0 6
88986: PUSH
88987: LD_VAR 0 5
88991: PPUSH
88992: LD_INT 91
88994: PUSH
88995: LD_VAR 0 4
88999: PUSH
89000: LD_INT 8
89002: PUSH
89003: EMPTY
89004: LIST
89005: LIST
89006: LIST
89007: PPUSH
89008: CALL_OW 72
89012: ST_TO_ADDR
// if nearEnemy then
89013: LD_VAR 0 6
89017: IFFALSE 89086
// begin if GetWeapon ( i ) = ru_time_lapser then
89019: LD_VAR 0 4
89023: PPUSH
89024: CALL_OW 264
89028: PUSH
89029: LD_INT 49
89031: EQUAL
89032: IFFALSE 89060
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89034: LD_VAR 0 4
89038: PPUSH
89039: LD_VAR 0 6
89043: PPUSH
89044: LD_VAR 0 4
89048: PPUSH
89049: CALL_OW 74
89053: PPUSH
89054: CALL_OW 112
89058: GO 89084
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89060: LD_VAR 0 4
89064: PPUSH
89065: LD_VAR 0 6
89069: PPUSH
89070: LD_VAR 0 4
89074: PPUSH
89075: CALL_OW 74
89079: PPUSH
89080: CALL_OW 115
// end else
89084: GO 89186
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89086: LD_VAR 0 4
89090: PPUSH
89091: LD_VAR 0 2
89095: PUSH
89096: LD_VAR 0 9
89100: ARRAY
89101: PUSH
89102: LD_INT 1
89104: ARRAY
89105: PPUSH
89106: LD_VAR 0 2
89110: PUSH
89111: LD_VAR 0 9
89115: ARRAY
89116: PUSH
89117: LD_INT 2
89119: ARRAY
89120: PPUSH
89121: CALL_OW 297
89125: PUSH
89126: LD_INT 6
89128: GREATER
89129: IFFALSE 89172
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89131: LD_VAR 0 4
89135: PPUSH
89136: LD_VAR 0 2
89140: PUSH
89141: LD_VAR 0 9
89145: ARRAY
89146: PUSH
89147: LD_INT 1
89149: ARRAY
89150: PPUSH
89151: LD_VAR 0 2
89155: PUSH
89156: LD_VAR 0 9
89160: ARRAY
89161: PUSH
89162: LD_INT 2
89164: ARRAY
89165: PPUSH
89166: CALL_OW 114
89170: GO 89186
// SetTag ( i , tag ) ;
89172: LD_VAR 0 4
89176: PPUSH
89177: LD_VAR 0 9
89181: PPUSH
89182: CALL_OW 109
// end else
89186: GO 89259
// if enemy then
89188: LD_VAR 0 5
89192: IFFALSE 89259
// begin if GetWeapon ( i ) = ru_time_lapser then
89194: LD_VAR 0 4
89198: PPUSH
89199: CALL_OW 264
89203: PUSH
89204: LD_INT 49
89206: EQUAL
89207: IFFALSE 89235
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89209: LD_VAR 0 4
89213: PPUSH
89214: LD_VAR 0 5
89218: PPUSH
89219: LD_VAR 0 4
89223: PPUSH
89224: CALL_OW 74
89228: PPUSH
89229: CALL_OW 112
89233: GO 89259
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89235: LD_VAR 0 4
89239: PPUSH
89240: LD_VAR 0 5
89244: PPUSH
89245: LD_VAR 0 4
89249: PPUSH
89250: CALL_OW 74
89254: PPUSH
89255: CALL_OW 115
// end ; end ;
89259: GO 88839
89261: POP
89262: POP
// end ;
89263: LD_VAR 0 3
89267: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89268: LD_INT 0
89270: PPUSH
89271: PPUSH
89272: PPUSH
// if not unit or IsInUnit ( unit ) then
89273: LD_VAR 0 1
89277: NOT
89278: PUSH
89279: LD_VAR 0 1
89283: PPUSH
89284: CALL_OW 310
89288: OR
89289: IFFALSE 89293
// exit ;
89291: GO 89384
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89293: LD_ADDR_VAR 0 4
89297: PUSH
89298: LD_VAR 0 1
89302: PPUSH
89303: CALL_OW 250
89307: PPUSH
89308: LD_VAR 0 2
89312: PPUSH
89313: LD_INT 1
89315: PPUSH
89316: CALL_OW 272
89320: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
89321: LD_ADDR_VAR 0 5
89325: PUSH
89326: LD_VAR 0 1
89330: PPUSH
89331: CALL_OW 251
89335: PPUSH
89336: LD_VAR 0 2
89340: PPUSH
89341: LD_INT 1
89343: PPUSH
89344: CALL_OW 273
89348: ST_TO_ADDR
// if ValidHex ( x , y ) then
89349: LD_VAR 0 4
89353: PPUSH
89354: LD_VAR 0 5
89358: PPUSH
89359: CALL_OW 488
89363: IFFALSE 89384
// ComTurnXY ( unit , x , y ) ;
89365: LD_VAR 0 1
89369: PPUSH
89370: LD_VAR 0 4
89374: PPUSH
89375: LD_VAR 0 5
89379: PPUSH
89380: CALL_OW 118
// end ;
89384: LD_VAR 0 3
89388: RET
// export function SeeUnits ( side , units ) ; var i ; begin
89389: LD_INT 0
89391: PPUSH
89392: PPUSH
// result := false ;
89393: LD_ADDR_VAR 0 3
89397: PUSH
89398: LD_INT 0
89400: ST_TO_ADDR
// if not units then
89401: LD_VAR 0 2
89405: NOT
89406: IFFALSE 89410
// exit ;
89408: GO 89455
// for i in units do
89410: LD_ADDR_VAR 0 4
89414: PUSH
89415: LD_VAR 0 2
89419: PUSH
89420: FOR_IN
89421: IFFALSE 89453
// if See ( side , i ) then
89423: LD_VAR 0 1
89427: PPUSH
89428: LD_VAR 0 4
89432: PPUSH
89433: CALL_OW 292
89437: IFFALSE 89451
// begin result := true ;
89439: LD_ADDR_VAR 0 3
89443: PUSH
89444: LD_INT 1
89446: ST_TO_ADDR
// exit ;
89447: POP
89448: POP
89449: GO 89455
// end ;
89451: GO 89420
89453: POP
89454: POP
// end ;
89455: LD_VAR 0 3
89459: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
89460: LD_INT 0
89462: PPUSH
89463: PPUSH
89464: PPUSH
89465: PPUSH
// if not unit or not points then
89466: LD_VAR 0 1
89470: NOT
89471: PUSH
89472: LD_VAR 0 2
89476: NOT
89477: OR
89478: IFFALSE 89482
// exit ;
89480: GO 89572
// dist := 99999 ;
89482: LD_ADDR_VAR 0 5
89486: PUSH
89487: LD_INT 99999
89489: ST_TO_ADDR
// for i in points do
89490: LD_ADDR_VAR 0 4
89494: PUSH
89495: LD_VAR 0 2
89499: PUSH
89500: FOR_IN
89501: IFFALSE 89570
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
89503: LD_ADDR_VAR 0 6
89507: PUSH
89508: LD_VAR 0 1
89512: PPUSH
89513: LD_VAR 0 4
89517: PUSH
89518: LD_INT 1
89520: ARRAY
89521: PPUSH
89522: LD_VAR 0 4
89526: PUSH
89527: LD_INT 2
89529: ARRAY
89530: PPUSH
89531: CALL_OW 297
89535: ST_TO_ADDR
// if tmpDist < dist then
89536: LD_VAR 0 6
89540: PUSH
89541: LD_VAR 0 5
89545: LESS
89546: IFFALSE 89568
// begin result := i ;
89548: LD_ADDR_VAR 0 3
89552: PUSH
89553: LD_VAR 0 4
89557: ST_TO_ADDR
// dist := tmpDist ;
89558: LD_ADDR_VAR 0 5
89562: PUSH
89563: LD_VAR 0 6
89567: ST_TO_ADDR
// end ; end ;
89568: GO 89500
89570: POP
89571: POP
// end ;
89572: LD_VAR 0 3
89576: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
89577: LD_INT 0
89579: PPUSH
// uc_side := side ;
89580: LD_ADDR_OWVAR 20
89584: PUSH
89585: LD_VAR 0 1
89589: ST_TO_ADDR
// uc_nation := 3 ;
89590: LD_ADDR_OWVAR 21
89594: PUSH
89595: LD_INT 3
89597: ST_TO_ADDR
// vc_chassis := 25 ;
89598: LD_ADDR_OWVAR 37
89602: PUSH
89603: LD_INT 25
89605: ST_TO_ADDR
// vc_engine := engine_siberite ;
89606: LD_ADDR_OWVAR 39
89610: PUSH
89611: LD_INT 3
89613: ST_TO_ADDR
// vc_control := control_computer ;
89614: LD_ADDR_OWVAR 38
89618: PUSH
89619: LD_INT 3
89621: ST_TO_ADDR
// vc_weapon := 59 ;
89622: LD_ADDR_OWVAR 40
89626: PUSH
89627: LD_INT 59
89629: ST_TO_ADDR
// result := CreateVehicle ;
89630: LD_ADDR_VAR 0 5
89634: PUSH
89635: CALL_OW 45
89639: ST_TO_ADDR
// SetDir ( result , d ) ;
89640: LD_VAR 0 5
89644: PPUSH
89645: LD_VAR 0 4
89649: PPUSH
89650: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
89654: LD_VAR 0 5
89658: PPUSH
89659: LD_VAR 0 2
89663: PPUSH
89664: LD_VAR 0 3
89668: PPUSH
89669: LD_INT 0
89671: PPUSH
89672: CALL_OW 48
// end ;
89676: LD_VAR 0 5
89680: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
89681: LD_INT 0
89683: PPUSH
89684: PPUSH
89685: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
89686: LD_ADDR_VAR 0 2
89690: PUSH
89691: LD_INT 0
89693: PUSH
89694: LD_INT 0
89696: PUSH
89697: LD_INT 0
89699: PUSH
89700: LD_INT 0
89702: PUSH
89703: EMPTY
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
89709: LD_VAR 0 1
89713: NOT
89714: PUSH
89715: LD_VAR 0 1
89719: PPUSH
89720: CALL_OW 264
89724: PUSH
89725: LD_INT 12
89727: PUSH
89728: LD_INT 51
89730: PUSH
89731: LD_INT 32
89733: PUSH
89734: LD_INT 89
89736: PUSH
89737: EMPTY
89738: LIST
89739: LIST
89740: LIST
89741: LIST
89742: IN
89743: NOT
89744: OR
89745: IFFALSE 89749
// exit ;
89747: GO 89847
// for i := 1 to 3 do
89749: LD_ADDR_VAR 0 3
89753: PUSH
89754: DOUBLE
89755: LD_INT 1
89757: DEC
89758: ST_TO_ADDR
89759: LD_INT 3
89761: PUSH
89762: FOR_TO
89763: IFFALSE 89845
// begin tmp := GetCargo ( cargo , i ) ;
89765: LD_ADDR_VAR 0 4
89769: PUSH
89770: LD_VAR 0 1
89774: PPUSH
89775: LD_VAR 0 3
89779: PPUSH
89780: CALL_OW 289
89784: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
89785: LD_ADDR_VAR 0 2
89789: PUSH
89790: LD_VAR 0 2
89794: PPUSH
89795: LD_VAR 0 3
89799: PPUSH
89800: LD_VAR 0 4
89804: PPUSH
89805: CALL_OW 1
89809: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
89810: LD_ADDR_VAR 0 2
89814: PUSH
89815: LD_VAR 0 2
89819: PPUSH
89820: LD_INT 4
89822: PPUSH
89823: LD_VAR 0 2
89827: PUSH
89828: LD_INT 4
89830: ARRAY
89831: PUSH
89832: LD_VAR 0 4
89836: PLUS
89837: PPUSH
89838: CALL_OW 1
89842: ST_TO_ADDR
// end ;
89843: GO 89762
89845: POP
89846: POP
// end ;
89847: LD_VAR 0 2
89851: RET
// export function Length ( array ) ; begin
89852: LD_INT 0
89854: PPUSH
// result := array + 0 ;
89855: LD_ADDR_VAR 0 2
89859: PUSH
89860: LD_VAR 0 1
89864: PUSH
89865: LD_INT 0
89867: PLUS
89868: ST_TO_ADDR
// end ;
89869: LD_VAR 0 2
89873: RET
// export function PrepareArray ( array ) ; begin
89874: LD_INT 0
89876: PPUSH
// result := array diff 0 ;
89877: LD_ADDR_VAR 0 2
89881: PUSH
89882: LD_VAR 0 1
89886: PUSH
89887: LD_INT 0
89889: DIFF
89890: ST_TO_ADDR
// if not result [ 1 ] then
89891: LD_VAR 0 2
89895: PUSH
89896: LD_INT 1
89898: ARRAY
89899: NOT
89900: IFFALSE 89920
// result := Delete ( result , 1 ) ;
89902: LD_ADDR_VAR 0 2
89906: PUSH
89907: LD_VAR 0 2
89911: PPUSH
89912: LD_INT 1
89914: PPUSH
89915: CALL_OW 3
89919: ST_TO_ADDR
// end ;
89920: LD_VAR 0 2
89924: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
89925: LD_INT 0
89927: PPUSH
89928: PPUSH
89929: PPUSH
89930: PPUSH
// sibRocketRange := 25 ;
89931: LD_ADDR_VAR 0 6
89935: PUSH
89936: LD_INT 25
89938: ST_TO_ADDR
// result := false ;
89939: LD_ADDR_VAR 0 4
89943: PUSH
89944: LD_INT 0
89946: ST_TO_ADDR
// for i := 0 to 5 do
89947: LD_ADDR_VAR 0 5
89951: PUSH
89952: DOUBLE
89953: LD_INT 0
89955: DEC
89956: ST_TO_ADDR
89957: LD_INT 5
89959: PUSH
89960: FOR_TO
89961: IFFALSE 90028
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
89963: LD_VAR 0 1
89967: PPUSH
89968: LD_VAR 0 5
89972: PPUSH
89973: LD_VAR 0 6
89977: PPUSH
89978: CALL_OW 272
89982: PPUSH
89983: LD_VAR 0 2
89987: PPUSH
89988: LD_VAR 0 5
89992: PPUSH
89993: LD_VAR 0 6
89997: PPUSH
89998: CALL_OW 273
90002: PPUSH
90003: LD_VAR 0 3
90007: PPUSH
90008: CALL_OW 309
90012: IFFALSE 90026
// begin result := true ;
90014: LD_ADDR_VAR 0 4
90018: PUSH
90019: LD_INT 1
90021: ST_TO_ADDR
// exit ;
90022: POP
90023: POP
90024: GO 90030
// end ;
90026: GO 89960
90028: POP
90029: POP
// end ;
90030: LD_VAR 0 4
90034: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90035: LD_INT 0
90037: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90038: LD_VAR 0 1
90042: PPUSH
90043: LD_VAR 0 2
90047: PPUSH
90048: LD_INT 0
90050: PPUSH
90051: LD_INT 0
90053: PPUSH
90054: LD_INT 1
90056: PPUSH
90057: LD_INT 0
90059: PPUSH
90060: CALL_OW 587
// end ; end_of_file end_of_file
90064: LD_VAR 0 3
90068: RET
// every 0 0$1 do
90069: GO 90071
90071: DISABLE
// begin enable ;
90072: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
90073: LD_STRING updateTimer(
90075: PUSH
90076: LD_OWVAR 1
90080: STR
90081: PUSH
90082: LD_STRING );
90084: STR
90085: PPUSH
90086: CALL_OW 559
// end ;
90090: END
// export function SOS_MapStart ( ) ; begin
90091: LD_INT 0
90093: PPUSH
// if streamModeActive then
90094: LD_EXP 95
90098: IFFALSE 90107
// DefineStreamItems ( true ) ;
90100: LD_INT 1
90102: PPUSH
90103: CALL 91911 0 1
// UpdateLuaVariables ( ) ;
90107: CALL 90124 0 0
// UpdateFactoryWaypoints ( ) ;
90111: CALL 104772 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90115: CALL 105029 0 0
// end ;
90119: LD_VAR 0 1
90123: RET
// export globalGameSaveCounter ; function UpdateLuaVariables ( ) ; begin
90124: LD_INT 0
90126: PPUSH
// if not globalGameSaveCounter then
90127: LD_EXP 94
90131: NOT
90132: IFFALSE 90143
// ToLua ( setGameSaveCounter(0) ) else
90134: LD_STRING setGameSaveCounter(0)
90136: PPUSH
90137: CALL_OW 559
90141: GO 90175
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
90143: LD_ADDR_EXP 94
90147: PUSH
90148: LD_EXP 94
90152: PPUSH
90153: CALL 87477 0 1
90157: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90158: LD_STRING setGameSaveCounter(
90160: PUSH
90161: LD_EXP 94
90165: STR
90166: PUSH
90167: LD_STRING )
90169: STR
90170: PPUSH
90171: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
90175: LD_STRING setGameDifficulty(
90177: PUSH
90178: LD_OWVAR 67
90182: STR
90183: PUSH
90184: LD_STRING )
90186: STR
90187: PPUSH
90188: CALL_OW 559
// end ;
90192: LD_VAR 0 1
90196: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90197: LD_INT 0
90199: PPUSH
// if p2 = stream_mode then
90200: LD_VAR 0 2
90204: PUSH
90205: LD_INT 100
90207: EQUAL
90208: IFFALSE 91211
// begin if not StreamModeActive then
90210: LD_EXP 95
90214: NOT
90215: IFFALSE 90225
// StreamModeActive := true ;
90217: LD_ADDR_EXP 95
90221: PUSH
90222: LD_INT 1
90224: ST_TO_ADDR
// if p3 = 0 then
90225: LD_VAR 0 3
90229: PUSH
90230: LD_INT 0
90232: EQUAL
90233: IFFALSE 90239
// InitStreamMode ;
90235: CALL 91447 0 0
// if p3 = 1 then
90239: LD_VAR 0 3
90243: PUSH
90244: LD_INT 1
90246: EQUAL
90247: IFFALSE 90257
// sRocket := true ;
90249: LD_ADDR_EXP 100
90253: PUSH
90254: LD_INT 1
90256: ST_TO_ADDR
// if p3 = 2 then
90257: LD_VAR 0 3
90261: PUSH
90262: LD_INT 2
90264: EQUAL
90265: IFFALSE 90275
// sSpeed := true ;
90267: LD_ADDR_EXP 99
90271: PUSH
90272: LD_INT 1
90274: ST_TO_ADDR
// if p3 = 3 then
90275: LD_VAR 0 3
90279: PUSH
90280: LD_INT 3
90282: EQUAL
90283: IFFALSE 90293
// sEngine := true ;
90285: LD_ADDR_EXP 101
90289: PUSH
90290: LD_INT 1
90292: ST_TO_ADDR
// if p3 = 4 then
90293: LD_VAR 0 3
90297: PUSH
90298: LD_INT 4
90300: EQUAL
90301: IFFALSE 90311
// sSpec := true ;
90303: LD_ADDR_EXP 98
90307: PUSH
90308: LD_INT 1
90310: ST_TO_ADDR
// if p3 = 5 then
90311: LD_VAR 0 3
90315: PUSH
90316: LD_INT 5
90318: EQUAL
90319: IFFALSE 90329
// sLevel := true ;
90321: LD_ADDR_EXP 102
90325: PUSH
90326: LD_INT 1
90328: ST_TO_ADDR
// if p3 = 6 then
90329: LD_VAR 0 3
90333: PUSH
90334: LD_INT 6
90336: EQUAL
90337: IFFALSE 90347
// sArmoury := true ;
90339: LD_ADDR_EXP 103
90343: PUSH
90344: LD_INT 1
90346: ST_TO_ADDR
// if p3 = 7 then
90347: LD_VAR 0 3
90351: PUSH
90352: LD_INT 7
90354: EQUAL
90355: IFFALSE 90365
// sRadar := true ;
90357: LD_ADDR_EXP 104
90361: PUSH
90362: LD_INT 1
90364: ST_TO_ADDR
// if p3 = 8 then
90365: LD_VAR 0 3
90369: PUSH
90370: LD_INT 8
90372: EQUAL
90373: IFFALSE 90383
// sBunker := true ;
90375: LD_ADDR_EXP 105
90379: PUSH
90380: LD_INT 1
90382: ST_TO_ADDR
// if p3 = 9 then
90383: LD_VAR 0 3
90387: PUSH
90388: LD_INT 9
90390: EQUAL
90391: IFFALSE 90401
// sHack := true ;
90393: LD_ADDR_EXP 106
90397: PUSH
90398: LD_INT 1
90400: ST_TO_ADDR
// if p3 = 10 then
90401: LD_VAR 0 3
90405: PUSH
90406: LD_INT 10
90408: EQUAL
90409: IFFALSE 90419
// sFire := true ;
90411: LD_ADDR_EXP 107
90415: PUSH
90416: LD_INT 1
90418: ST_TO_ADDR
// if p3 = 11 then
90419: LD_VAR 0 3
90423: PUSH
90424: LD_INT 11
90426: EQUAL
90427: IFFALSE 90437
// sRefresh := true ;
90429: LD_ADDR_EXP 108
90433: PUSH
90434: LD_INT 1
90436: ST_TO_ADDR
// if p3 = 12 then
90437: LD_VAR 0 3
90441: PUSH
90442: LD_INT 12
90444: EQUAL
90445: IFFALSE 90455
// sExp := true ;
90447: LD_ADDR_EXP 109
90451: PUSH
90452: LD_INT 1
90454: ST_TO_ADDR
// if p3 = 13 then
90455: LD_VAR 0 3
90459: PUSH
90460: LD_INT 13
90462: EQUAL
90463: IFFALSE 90473
// sDepot := true ;
90465: LD_ADDR_EXP 110
90469: PUSH
90470: LD_INT 1
90472: ST_TO_ADDR
// if p3 = 14 then
90473: LD_VAR 0 3
90477: PUSH
90478: LD_INT 14
90480: EQUAL
90481: IFFALSE 90491
// sFlag := true ;
90483: LD_ADDR_EXP 111
90487: PUSH
90488: LD_INT 1
90490: ST_TO_ADDR
// if p3 = 15 then
90491: LD_VAR 0 3
90495: PUSH
90496: LD_INT 15
90498: EQUAL
90499: IFFALSE 90509
// sKamikadze := true ;
90501: LD_ADDR_EXP 119
90505: PUSH
90506: LD_INT 1
90508: ST_TO_ADDR
// if p3 = 16 then
90509: LD_VAR 0 3
90513: PUSH
90514: LD_INT 16
90516: EQUAL
90517: IFFALSE 90527
// sTroll := true ;
90519: LD_ADDR_EXP 120
90523: PUSH
90524: LD_INT 1
90526: ST_TO_ADDR
// if p3 = 17 then
90527: LD_VAR 0 3
90531: PUSH
90532: LD_INT 17
90534: EQUAL
90535: IFFALSE 90545
// sSlow := true ;
90537: LD_ADDR_EXP 121
90541: PUSH
90542: LD_INT 1
90544: ST_TO_ADDR
// if p3 = 18 then
90545: LD_VAR 0 3
90549: PUSH
90550: LD_INT 18
90552: EQUAL
90553: IFFALSE 90563
// sLack := true ;
90555: LD_ADDR_EXP 122
90559: PUSH
90560: LD_INT 1
90562: ST_TO_ADDR
// if p3 = 19 then
90563: LD_VAR 0 3
90567: PUSH
90568: LD_INT 19
90570: EQUAL
90571: IFFALSE 90581
// sTank := true ;
90573: LD_ADDR_EXP 124
90577: PUSH
90578: LD_INT 1
90580: ST_TO_ADDR
// if p3 = 20 then
90581: LD_VAR 0 3
90585: PUSH
90586: LD_INT 20
90588: EQUAL
90589: IFFALSE 90599
// sRemote := true ;
90591: LD_ADDR_EXP 125
90595: PUSH
90596: LD_INT 1
90598: ST_TO_ADDR
// if p3 = 21 then
90599: LD_VAR 0 3
90603: PUSH
90604: LD_INT 21
90606: EQUAL
90607: IFFALSE 90617
// sPowell := true ;
90609: LD_ADDR_EXP 126
90613: PUSH
90614: LD_INT 1
90616: ST_TO_ADDR
// if p3 = 22 then
90617: LD_VAR 0 3
90621: PUSH
90622: LD_INT 22
90624: EQUAL
90625: IFFALSE 90635
// sTeleport := true ;
90627: LD_ADDR_EXP 129
90631: PUSH
90632: LD_INT 1
90634: ST_TO_ADDR
// if p3 = 23 then
90635: LD_VAR 0 3
90639: PUSH
90640: LD_INT 23
90642: EQUAL
90643: IFFALSE 90653
// sOilTower := true ;
90645: LD_ADDR_EXP 131
90649: PUSH
90650: LD_INT 1
90652: ST_TO_ADDR
// if p3 = 24 then
90653: LD_VAR 0 3
90657: PUSH
90658: LD_INT 24
90660: EQUAL
90661: IFFALSE 90671
// sShovel := true ;
90663: LD_ADDR_EXP 132
90667: PUSH
90668: LD_INT 1
90670: ST_TO_ADDR
// if p3 = 25 then
90671: LD_VAR 0 3
90675: PUSH
90676: LD_INT 25
90678: EQUAL
90679: IFFALSE 90689
// sSheik := true ;
90681: LD_ADDR_EXP 133
90685: PUSH
90686: LD_INT 1
90688: ST_TO_ADDR
// if p3 = 26 then
90689: LD_VAR 0 3
90693: PUSH
90694: LD_INT 26
90696: EQUAL
90697: IFFALSE 90707
// sEarthquake := true ;
90699: LD_ADDR_EXP 135
90703: PUSH
90704: LD_INT 1
90706: ST_TO_ADDR
// if p3 = 27 then
90707: LD_VAR 0 3
90711: PUSH
90712: LD_INT 27
90714: EQUAL
90715: IFFALSE 90725
// sAI := true ;
90717: LD_ADDR_EXP 136
90721: PUSH
90722: LD_INT 1
90724: ST_TO_ADDR
// if p3 = 28 then
90725: LD_VAR 0 3
90729: PUSH
90730: LD_INT 28
90732: EQUAL
90733: IFFALSE 90743
// sCargo := true ;
90735: LD_ADDR_EXP 139
90739: PUSH
90740: LD_INT 1
90742: ST_TO_ADDR
// if p3 = 29 then
90743: LD_VAR 0 3
90747: PUSH
90748: LD_INT 29
90750: EQUAL
90751: IFFALSE 90761
// sDLaser := true ;
90753: LD_ADDR_EXP 140
90757: PUSH
90758: LD_INT 1
90760: ST_TO_ADDR
// if p3 = 30 then
90761: LD_VAR 0 3
90765: PUSH
90766: LD_INT 30
90768: EQUAL
90769: IFFALSE 90779
// sExchange := true ;
90771: LD_ADDR_EXP 141
90775: PUSH
90776: LD_INT 1
90778: ST_TO_ADDR
// if p3 = 31 then
90779: LD_VAR 0 3
90783: PUSH
90784: LD_INT 31
90786: EQUAL
90787: IFFALSE 90797
// sFac := true ;
90789: LD_ADDR_EXP 142
90793: PUSH
90794: LD_INT 1
90796: ST_TO_ADDR
// if p3 = 32 then
90797: LD_VAR 0 3
90801: PUSH
90802: LD_INT 32
90804: EQUAL
90805: IFFALSE 90815
// sPower := true ;
90807: LD_ADDR_EXP 143
90811: PUSH
90812: LD_INT 1
90814: ST_TO_ADDR
// if p3 = 33 then
90815: LD_VAR 0 3
90819: PUSH
90820: LD_INT 33
90822: EQUAL
90823: IFFALSE 90833
// sRandom := true ;
90825: LD_ADDR_EXP 144
90829: PUSH
90830: LD_INT 1
90832: ST_TO_ADDR
// if p3 = 34 then
90833: LD_VAR 0 3
90837: PUSH
90838: LD_INT 34
90840: EQUAL
90841: IFFALSE 90851
// sShield := true ;
90843: LD_ADDR_EXP 145
90847: PUSH
90848: LD_INT 1
90850: ST_TO_ADDR
// if p3 = 35 then
90851: LD_VAR 0 3
90855: PUSH
90856: LD_INT 35
90858: EQUAL
90859: IFFALSE 90869
// sTime := true ;
90861: LD_ADDR_EXP 146
90865: PUSH
90866: LD_INT 1
90868: ST_TO_ADDR
// if p3 = 36 then
90869: LD_VAR 0 3
90873: PUSH
90874: LD_INT 36
90876: EQUAL
90877: IFFALSE 90887
// sTools := true ;
90879: LD_ADDR_EXP 147
90883: PUSH
90884: LD_INT 1
90886: ST_TO_ADDR
// if p3 = 101 then
90887: LD_VAR 0 3
90891: PUSH
90892: LD_INT 101
90894: EQUAL
90895: IFFALSE 90905
// sSold := true ;
90897: LD_ADDR_EXP 112
90901: PUSH
90902: LD_INT 1
90904: ST_TO_ADDR
// if p3 = 102 then
90905: LD_VAR 0 3
90909: PUSH
90910: LD_INT 102
90912: EQUAL
90913: IFFALSE 90923
// sDiff := true ;
90915: LD_ADDR_EXP 113
90919: PUSH
90920: LD_INT 1
90922: ST_TO_ADDR
// if p3 = 103 then
90923: LD_VAR 0 3
90927: PUSH
90928: LD_INT 103
90930: EQUAL
90931: IFFALSE 90941
// sFog := true ;
90933: LD_ADDR_EXP 116
90937: PUSH
90938: LD_INT 1
90940: ST_TO_ADDR
// if p3 = 104 then
90941: LD_VAR 0 3
90945: PUSH
90946: LD_INT 104
90948: EQUAL
90949: IFFALSE 90959
// sReset := true ;
90951: LD_ADDR_EXP 117
90955: PUSH
90956: LD_INT 1
90958: ST_TO_ADDR
// if p3 = 105 then
90959: LD_VAR 0 3
90963: PUSH
90964: LD_INT 105
90966: EQUAL
90967: IFFALSE 90977
// sSun := true ;
90969: LD_ADDR_EXP 118
90973: PUSH
90974: LD_INT 1
90976: ST_TO_ADDR
// if p3 = 106 then
90977: LD_VAR 0 3
90981: PUSH
90982: LD_INT 106
90984: EQUAL
90985: IFFALSE 90995
// sTiger := true ;
90987: LD_ADDR_EXP 114
90991: PUSH
90992: LD_INT 1
90994: ST_TO_ADDR
// if p3 = 107 then
90995: LD_VAR 0 3
90999: PUSH
91000: LD_INT 107
91002: EQUAL
91003: IFFALSE 91013
// sBomb := true ;
91005: LD_ADDR_EXP 115
91009: PUSH
91010: LD_INT 1
91012: ST_TO_ADDR
// if p3 = 108 then
91013: LD_VAR 0 3
91017: PUSH
91018: LD_INT 108
91020: EQUAL
91021: IFFALSE 91031
// sWound := true ;
91023: LD_ADDR_EXP 123
91027: PUSH
91028: LD_INT 1
91030: ST_TO_ADDR
// if p3 = 109 then
91031: LD_VAR 0 3
91035: PUSH
91036: LD_INT 109
91038: EQUAL
91039: IFFALSE 91049
// sBetray := true ;
91041: LD_ADDR_EXP 127
91045: PUSH
91046: LD_INT 1
91048: ST_TO_ADDR
// if p3 = 110 then
91049: LD_VAR 0 3
91053: PUSH
91054: LD_INT 110
91056: EQUAL
91057: IFFALSE 91067
// sContamin := true ;
91059: LD_ADDR_EXP 128
91063: PUSH
91064: LD_INT 1
91066: ST_TO_ADDR
// if p3 = 111 then
91067: LD_VAR 0 3
91071: PUSH
91072: LD_INT 111
91074: EQUAL
91075: IFFALSE 91085
// sOil := true ;
91077: LD_ADDR_EXP 130
91081: PUSH
91082: LD_INT 1
91084: ST_TO_ADDR
// if p3 = 112 then
91085: LD_VAR 0 3
91089: PUSH
91090: LD_INT 112
91092: EQUAL
91093: IFFALSE 91103
// sStu := true ;
91095: LD_ADDR_EXP 134
91099: PUSH
91100: LD_INT 1
91102: ST_TO_ADDR
// if p3 = 113 then
91103: LD_VAR 0 3
91107: PUSH
91108: LD_INT 113
91110: EQUAL
91111: IFFALSE 91121
// sBazooka := true ;
91113: LD_ADDR_EXP 137
91117: PUSH
91118: LD_INT 1
91120: ST_TO_ADDR
// if p3 = 114 then
91121: LD_VAR 0 3
91125: PUSH
91126: LD_INT 114
91128: EQUAL
91129: IFFALSE 91139
// sMortar := true ;
91131: LD_ADDR_EXP 138
91135: PUSH
91136: LD_INT 1
91138: ST_TO_ADDR
// if p3 = 115 then
91139: LD_VAR 0 3
91143: PUSH
91144: LD_INT 115
91146: EQUAL
91147: IFFALSE 91157
// sRanger := true ;
91149: LD_ADDR_EXP 148
91153: PUSH
91154: LD_INT 1
91156: ST_TO_ADDR
// if p3 = 116 then
91157: LD_VAR 0 3
91161: PUSH
91162: LD_INT 116
91164: EQUAL
91165: IFFALSE 91175
// sComputer := true ;
91167: LD_ADDR_EXP 149
91171: PUSH
91172: LD_INT 1
91174: ST_TO_ADDR
// if p3 = 117 then
91175: LD_VAR 0 3
91179: PUSH
91180: LD_INT 117
91182: EQUAL
91183: IFFALSE 91193
// s30 := true ;
91185: LD_ADDR_EXP 150
91189: PUSH
91190: LD_INT 1
91192: ST_TO_ADDR
// if p3 = 118 then
91193: LD_VAR 0 3
91197: PUSH
91198: LD_INT 118
91200: EQUAL
91201: IFFALSE 91211
// s60 := true ;
91203: LD_ADDR_EXP 151
91207: PUSH
91208: LD_INT 1
91210: ST_TO_ADDR
// end ; if p2 = hack_mode then
91211: LD_VAR 0 2
91215: PUSH
91216: LD_INT 101
91218: EQUAL
91219: IFFALSE 91347
// begin case p3 of 1 :
91221: LD_VAR 0 3
91225: PUSH
91226: LD_INT 1
91228: DOUBLE
91229: EQUAL
91230: IFTRUE 91234
91232: GO 91241
91234: POP
// hHackUnlimitedResources ; 2 :
91235: CALL 103518 0 0
91239: GO 91347
91241: LD_INT 2
91243: DOUBLE
91244: EQUAL
91245: IFTRUE 91249
91247: GO 91256
91249: POP
// hHackSetLevel10 ; 3 :
91250: CALL 103651 0 0
91254: GO 91347
91256: LD_INT 3
91258: DOUBLE
91259: EQUAL
91260: IFTRUE 91264
91262: GO 91271
91264: POP
// hHackSetLevel10YourUnits ; 4 :
91265: CALL 103736 0 0
91269: GO 91347
91271: LD_INT 4
91273: DOUBLE
91274: EQUAL
91275: IFTRUE 91279
91277: GO 91286
91279: POP
// hHackInvincible ; 5 :
91280: CALL 104184 0 0
91284: GO 91347
91286: LD_INT 5
91288: DOUBLE
91289: EQUAL
91290: IFTRUE 91294
91292: GO 91301
91294: POP
// hHackInvisible ; 6 :
91295: CALL 104295 0 0
91299: GO 91347
91301: LD_INT 6
91303: DOUBLE
91304: EQUAL
91305: IFTRUE 91309
91307: GO 91316
91309: POP
// hHackChangeYourSide ; 7 :
91310: CALL 104352 0 0
91314: GO 91347
91316: LD_INT 7
91318: DOUBLE
91319: EQUAL
91320: IFTRUE 91324
91322: GO 91331
91324: POP
// hHackChangeUnitSide ; 8 :
91325: CALL 104394 0 0
91329: GO 91347
91331: LD_INT 8
91333: DOUBLE
91334: EQUAL
91335: IFTRUE 91339
91337: GO 91346
91339: POP
// hHackFog ; end ;
91340: CALL 104495 0 0
91344: GO 91347
91346: POP
// end ; if p2 = game_save_mode then
91347: LD_VAR 0 2
91351: PUSH
91352: LD_INT 102
91354: EQUAL
91355: IFFALSE 91420
// begin if p3 = 1 then
91357: LD_VAR 0 3
91361: PUSH
91362: LD_INT 1
91364: EQUAL
91365: IFFALSE 91377
// globalGameSaveCounter := p4 ;
91367: LD_ADDR_EXP 94
91371: PUSH
91372: LD_VAR 0 4
91376: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
91377: LD_VAR 0 3
91381: PUSH
91382: LD_INT 2
91384: EQUAL
91385: PUSH
91386: LD_EXP 94
91390: AND
91391: IFFALSE 91410
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91393: LD_STRING setGameSaveCounter(
91395: PUSH
91396: LD_EXP 94
91400: STR
91401: PUSH
91402: LD_STRING )
91404: STR
91405: PPUSH
91406: CALL_OW 559
// display_strings := globalGameSaveCounter ;
91410: LD_ADDR_OWVAR 47
91414: PUSH
91415: LD_EXP 94
91419: ST_TO_ADDR
// end ; end ;
91420: LD_VAR 0 7
91424: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
91425: GO 91427
91427: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
91428: LD_STRING initStreamRollete();
91430: PPUSH
91431: CALL_OW 559
// InitStreamMode ;
91435: CALL 91447 0 0
// DefineStreamItems ( false ) ;
91439: LD_INT 0
91441: PPUSH
91442: CALL 91911 0 1
// end ;
91446: END
// function InitStreamMode ; begin
91447: LD_INT 0
91449: PPUSH
// streamModeActive := false ;
91450: LD_ADDR_EXP 95
91454: PUSH
91455: LD_INT 0
91457: ST_TO_ADDR
// normalCounter := 36 ;
91458: LD_ADDR_EXP 96
91462: PUSH
91463: LD_INT 36
91465: ST_TO_ADDR
// hardcoreCounter := 18 ;
91466: LD_ADDR_EXP 97
91470: PUSH
91471: LD_INT 18
91473: ST_TO_ADDR
// sRocket := false ;
91474: LD_ADDR_EXP 100
91478: PUSH
91479: LD_INT 0
91481: ST_TO_ADDR
// sSpeed := false ;
91482: LD_ADDR_EXP 99
91486: PUSH
91487: LD_INT 0
91489: ST_TO_ADDR
// sEngine := false ;
91490: LD_ADDR_EXP 101
91494: PUSH
91495: LD_INT 0
91497: ST_TO_ADDR
// sSpec := false ;
91498: LD_ADDR_EXP 98
91502: PUSH
91503: LD_INT 0
91505: ST_TO_ADDR
// sLevel := false ;
91506: LD_ADDR_EXP 102
91510: PUSH
91511: LD_INT 0
91513: ST_TO_ADDR
// sArmoury := false ;
91514: LD_ADDR_EXP 103
91518: PUSH
91519: LD_INT 0
91521: ST_TO_ADDR
// sRadar := false ;
91522: LD_ADDR_EXP 104
91526: PUSH
91527: LD_INT 0
91529: ST_TO_ADDR
// sBunker := false ;
91530: LD_ADDR_EXP 105
91534: PUSH
91535: LD_INT 0
91537: ST_TO_ADDR
// sHack := false ;
91538: LD_ADDR_EXP 106
91542: PUSH
91543: LD_INT 0
91545: ST_TO_ADDR
// sFire := false ;
91546: LD_ADDR_EXP 107
91550: PUSH
91551: LD_INT 0
91553: ST_TO_ADDR
// sRefresh := false ;
91554: LD_ADDR_EXP 108
91558: PUSH
91559: LD_INT 0
91561: ST_TO_ADDR
// sExp := false ;
91562: LD_ADDR_EXP 109
91566: PUSH
91567: LD_INT 0
91569: ST_TO_ADDR
// sDepot := false ;
91570: LD_ADDR_EXP 110
91574: PUSH
91575: LD_INT 0
91577: ST_TO_ADDR
// sFlag := false ;
91578: LD_ADDR_EXP 111
91582: PUSH
91583: LD_INT 0
91585: ST_TO_ADDR
// sKamikadze := false ;
91586: LD_ADDR_EXP 119
91590: PUSH
91591: LD_INT 0
91593: ST_TO_ADDR
// sTroll := false ;
91594: LD_ADDR_EXP 120
91598: PUSH
91599: LD_INT 0
91601: ST_TO_ADDR
// sSlow := false ;
91602: LD_ADDR_EXP 121
91606: PUSH
91607: LD_INT 0
91609: ST_TO_ADDR
// sLack := false ;
91610: LD_ADDR_EXP 122
91614: PUSH
91615: LD_INT 0
91617: ST_TO_ADDR
// sTank := false ;
91618: LD_ADDR_EXP 124
91622: PUSH
91623: LD_INT 0
91625: ST_TO_ADDR
// sRemote := false ;
91626: LD_ADDR_EXP 125
91630: PUSH
91631: LD_INT 0
91633: ST_TO_ADDR
// sPowell := false ;
91634: LD_ADDR_EXP 126
91638: PUSH
91639: LD_INT 0
91641: ST_TO_ADDR
// sTeleport := false ;
91642: LD_ADDR_EXP 129
91646: PUSH
91647: LD_INT 0
91649: ST_TO_ADDR
// sOilTower := false ;
91650: LD_ADDR_EXP 131
91654: PUSH
91655: LD_INT 0
91657: ST_TO_ADDR
// sShovel := false ;
91658: LD_ADDR_EXP 132
91662: PUSH
91663: LD_INT 0
91665: ST_TO_ADDR
// sSheik := false ;
91666: LD_ADDR_EXP 133
91670: PUSH
91671: LD_INT 0
91673: ST_TO_ADDR
// sEarthquake := false ;
91674: LD_ADDR_EXP 135
91678: PUSH
91679: LD_INT 0
91681: ST_TO_ADDR
// sAI := false ;
91682: LD_ADDR_EXP 136
91686: PUSH
91687: LD_INT 0
91689: ST_TO_ADDR
// sCargo := false ;
91690: LD_ADDR_EXP 139
91694: PUSH
91695: LD_INT 0
91697: ST_TO_ADDR
// sDLaser := false ;
91698: LD_ADDR_EXP 140
91702: PUSH
91703: LD_INT 0
91705: ST_TO_ADDR
// sExchange := false ;
91706: LD_ADDR_EXP 141
91710: PUSH
91711: LD_INT 0
91713: ST_TO_ADDR
// sFac := false ;
91714: LD_ADDR_EXP 142
91718: PUSH
91719: LD_INT 0
91721: ST_TO_ADDR
// sPower := false ;
91722: LD_ADDR_EXP 143
91726: PUSH
91727: LD_INT 0
91729: ST_TO_ADDR
// sRandom := false ;
91730: LD_ADDR_EXP 144
91734: PUSH
91735: LD_INT 0
91737: ST_TO_ADDR
// sShield := false ;
91738: LD_ADDR_EXP 145
91742: PUSH
91743: LD_INT 0
91745: ST_TO_ADDR
// sTime := false ;
91746: LD_ADDR_EXP 146
91750: PUSH
91751: LD_INT 0
91753: ST_TO_ADDR
// sTools := false ;
91754: LD_ADDR_EXP 147
91758: PUSH
91759: LD_INT 0
91761: ST_TO_ADDR
// sSold := false ;
91762: LD_ADDR_EXP 112
91766: PUSH
91767: LD_INT 0
91769: ST_TO_ADDR
// sDiff := false ;
91770: LD_ADDR_EXP 113
91774: PUSH
91775: LD_INT 0
91777: ST_TO_ADDR
// sFog := false ;
91778: LD_ADDR_EXP 116
91782: PUSH
91783: LD_INT 0
91785: ST_TO_ADDR
// sReset := false ;
91786: LD_ADDR_EXP 117
91790: PUSH
91791: LD_INT 0
91793: ST_TO_ADDR
// sSun := false ;
91794: LD_ADDR_EXP 118
91798: PUSH
91799: LD_INT 0
91801: ST_TO_ADDR
// sTiger := false ;
91802: LD_ADDR_EXP 114
91806: PUSH
91807: LD_INT 0
91809: ST_TO_ADDR
// sBomb := false ;
91810: LD_ADDR_EXP 115
91814: PUSH
91815: LD_INT 0
91817: ST_TO_ADDR
// sWound := false ;
91818: LD_ADDR_EXP 123
91822: PUSH
91823: LD_INT 0
91825: ST_TO_ADDR
// sBetray := false ;
91826: LD_ADDR_EXP 127
91830: PUSH
91831: LD_INT 0
91833: ST_TO_ADDR
// sContamin := false ;
91834: LD_ADDR_EXP 128
91838: PUSH
91839: LD_INT 0
91841: ST_TO_ADDR
// sOil := false ;
91842: LD_ADDR_EXP 130
91846: PUSH
91847: LD_INT 0
91849: ST_TO_ADDR
// sStu := false ;
91850: LD_ADDR_EXP 134
91854: PUSH
91855: LD_INT 0
91857: ST_TO_ADDR
// sBazooka := false ;
91858: LD_ADDR_EXP 137
91862: PUSH
91863: LD_INT 0
91865: ST_TO_ADDR
// sMortar := false ;
91866: LD_ADDR_EXP 138
91870: PUSH
91871: LD_INT 0
91873: ST_TO_ADDR
// sRanger := false ;
91874: LD_ADDR_EXP 148
91878: PUSH
91879: LD_INT 0
91881: ST_TO_ADDR
// sComputer := false ;
91882: LD_ADDR_EXP 149
91886: PUSH
91887: LD_INT 0
91889: ST_TO_ADDR
// s30 := false ;
91890: LD_ADDR_EXP 150
91894: PUSH
91895: LD_INT 0
91897: ST_TO_ADDR
// s60 := false ;
91898: LD_ADDR_EXP 151
91902: PUSH
91903: LD_INT 0
91905: ST_TO_ADDR
// end ;
91906: LD_VAR 0 1
91910: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
91911: LD_INT 0
91913: PPUSH
91914: PPUSH
91915: PPUSH
91916: PPUSH
91917: PPUSH
91918: PPUSH
91919: PPUSH
// result := [ ] ;
91920: LD_ADDR_VAR 0 2
91924: PUSH
91925: EMPTY
91926: ST_TO_ADDR
// if campaign_id = 1 then
91927: LD_OWVAR 69
91931: PUSH
91932: LD_INT 1
91934: EQUAL
91935: IFFALSE 95101
// begin case mission_number of 1 :
91937: LD_OWVAR 70
91941: PUSH
91942: LD_INT 1
91944: DOUBLE
91945: EQUAL
91946: IFTRUE 91950
91948: GO 92026
91950: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
91951: LD_ADDR_VAR 0 2
91955: PUSH
91956: LD_INT 2
91958: PUSH
91959: LD_INT 4
91961: PUSH
91962: LD_INT 11
91964: PUSH
91965: LD_INT 12
91967: PUSH
91968: LD_INT 15
91970: PUSH
91971: LD_INT 16
91973: PUSH
91974: LD_INT 22
91976: PUSH
91977: LD_INT 23
91979: PUSH
91980: LD_INT 26
91982: PUSH
91983: EMPTY
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: PUSH
91994: LD_INT 101
91996: PUSH
91997: LD_INT 102
91999: PUSH
92000: LD_INT 106
92002: PUSH
92003: LD_INT 116
92005: PUSH
92006: LD_INT 117
92008: PUSH
92009: LD_INT 118
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: LIST
92018: LIST
92019: PUSH
92020: EMPTY
92021: LIST
92022: LIST
92023: ST_TO_ADDR
92024: GO 95099
92026: LD_INT 2
92028: DOUBLE
92029: EQUAL
92030: IFTRUE 92034
92032: GO 92118
92034: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
92035: LD_ADDR_VAR 0 2
92039: PUSH
92040: LD_INT 2
92042: PUSH
92043: LD_INT 4
92045: PUSH
92046: LD_INT 11
92048: PUSH
92049: LD_INT 12
92051: PUSH
92052: LD_INT 15
92054: PUSH
92055: LD_INT 16
92057: PUSH
92058: LD_INT 22
92060: PUSH
92061: LD_INT 23
92063: PUSH
92064: LD_INT 26
92066: PUSH
92067: EMPTY
92068: LIST
92069: LIST
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: PUSH
92078: LD_INT 101
92080: PUSH
92081: LD_INT 102
92083: PUSH
92084: LD_INT 105
92086: PUSH
92087: LD_INT 106
92089: PUSH
92090: LD_INT 108
92092: PUSH
92093: LD_INT 116
92095: PUSH
92096: LD_INT 117
92098: PUSH
92099: LD_INT 118
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: LIST
92106: LIST
92107: LIST
92108: LIST
92109: LIST
92110: LIST
92111: PUSH
92112: EMPTY
92113: LIST
92114: LIST
92115: ST_TO_ADDR
92116: GO 95099
92118: LD_INT 3
92120: DOUBLE
92121: EQUAL
92122: IFTRUE 92126
92124: GO 92214
92126: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
92127: LD_ADDR_VAR 0 2
92131: PUSH
92132: LD_INT 2
92134: PUSH
92135: LD_INT 4
92137: PUSH
92138: LD_INT 5
92140: PUSH
92141: LD_INT 11
92143: PUSH
92144: LD_INT 12
92146: PUSH
92147: LD_INT 15
92149: PUSH
92150: LD_INT 16
92152: PUSH
92153: LD_INT 22
92155: PUSH
92156: LD_INT 26
92158: PUSH
92159: LD_INT 36
92161: PUSH
92162: EMPTY
92163: LIST
92164: LIST
92165: LIST
92166: LIST
92167: LIST
92168: LIST
92169: LIST
92170: LIST
92171: LIST
92172: LIST
92173: PUSH
92174: LD_INT 101
92176: PUSH
92177: LD_INT 102
92179: PUSH
92180: LD_INT 105
92182: PUSH
92183: LD_INT 106
92185: PUSH
92186: LD_INT 108
92188: PUSH
92189: LD_INT 116
92191: PUSH
92192: LD_INT 117
92194: PUSH
92195: LD_INT 118
92197: PUSH
92198: EMPTY
92199: LIST
92200: LIST
92201: LIST
92202: LIST
92203: LIST
92204: LIST
92205: LIST
92206: LIST
92207: PUSH
92208: EMPTY
92209: LIST
92210: LIST
92211: ST_TO_ADDR
92212: GO 95099
92214: LD_INT 4
92216: DOUBLE
92217: EQUAL
92218: IFTRUE 92222
92220: GO 92318
92222: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92223: LD_ADDR_VAR 0 2
92227: PUSH
92228: LD_INT 2
92230: PUSH
92231: LD_INT 4
92233: PUSH
92234: LD_INT 5
92236: PUSH
92237: LD_INT 8
92239: PUSH
92240: LD_INT 11
92242: PUSH
92243: LD_INT 12
92245: PUSH
92246: LD_INT 15
92248: PUSH
92249: LD_INT 16
92251: PUSH
92252: LD_INT 22
92254: PUSH
92255: LD_INT 23
92257: PUSH
92258: LD_INT 26
92260: PUSH
92261: LD_INT 36
92263: PUSH
92264: EMPTY
92265: LIST
92266: LIST
92267: LIST
92268: LIST
92269: LIST
92270: LIST
92271: LIST
92272: LIST
92273: LIST
92274: LIST
92275: LIST
92276: LIST
92277: PUSH
92278: LD_INT 101
92280: PUSH
92281: LD_INT 102
92283: PUSH
92284: LD_INT 105
92286: PUSH
92287: LD_INT 106
92289: PUSH
92290: LD_INT 108
92292: PUSH
92293: LD_INT 116
92295: PUSH
92296: LD_INT 117
92298: PUSH
92299: LD_INT 118
92301: PUSH
92302: EMPTY
92303: LIST
92304: LIST
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: LIST
92311: PUSH
92312: EMPTY
92313: LIST
92314: LIST
92315: ST_TO_ADDR
92316: GO 95099
92318: LD_INT 5
92320: DOUBLE
92321: EQUAL
92322: IFTRUE 92326
92324: GO 92438
92326: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92327: LD_ADDR_VAR 0 2
92331: PUSH
92332: LD_INT 2
92334: PUSH
92335: LD_INT 4
92337: PUSH
92338: LD_INT 5
92340: PUSH
92341: LD_INT 6
92343: PUSH
92344: LD_INT 8
92346: PUSH
92347: LD_INT 11
92349: PUSH
92350: LD_INT 12
92352: PUSH
92353: LD_INT 15
92355: PUSH
92356: LD_INT 16
92358: PUSH
92359: LD_INT 22
92361: PUSH
92362: LD_INT 23
92364: PUSH
92365: LD_INT 25
92367: PUSH
92368: LD_INT 26
92370: PUSH
92371: LD_INT 36
92373: PUSH
92374: EMPTY
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: PUSH
92390: LD_INT 101
92392: PUSH
92393: LD_INT 102
92395: PUSH
92396: LD_INT 105
92398: PUSH
92399: LD_INT 106
92401: PUSH
92402: LD_INT 108
92404: PUSH
92405: LD_INT 109
92407: PUSH
92408: LD_INT 112
92410: PUSH
92411: LD_INT 116
92413: PUSH
92414: LD_INT 117
92416: PUSH
92417: LD_INT 118
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: LIST
92424: LIST
92425: LIST
92426: LIST
92427: LIST
92428: LIST
92429: LIST
92430: LIST
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: ST_TO_ADDR
92436: GO 95099
92438: LD_INT 6
92440: DOUBLE
92441: EQUAL
92442: IFTRUE 92446
92444: GO 92578
92446: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
92447: LD_ADDR_VAR 0 2
92451: PUSH
92452: LD_INT 2
92454: PUSH
92455: LD_INT 4
92457: PUSH
92458: LD_INT 5
92460: PUSH
92461: LD_INT 6
92463: PUSH
92464: LD_INT 8
92466: PUSH
92467: LD_INT 11
92469: PUSH
92470: LD_INT 12
92472: PUSH
92473: LD_INT 15
92475: PUSH
92476: LD_INT 16
92478: PUSH
92479: LD_INT 20
92481: PUSH
92482: LD_INT 21
92484: PUSH
92485: LD_INT 22
92487: PUSH
92488: LD_INT 23
92490: PUSH
92491: LD_INT 25
92493: PUSH
92494: LD_INT 26
92496: PUSH
92497: LD_INT 30
92499: PUSH
92500: LD_INT 31
92502: PUSH
92503: LD_INT 32
92505: PUSH
92506: LD_INT 36
92508: PUSH
92509: EMPTY
92510: LIST
92511: LIST
92512: LIST
92513: LIST
92514: LIST
92515: LIST
92516: LIST
92517: LIST
92518: LIST
92519: LIST
92520: LIST
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: PUSH
92530: LD_INT 101
92532: PUSH
92533: LD_INT 102
92535: PUSH
92536: LD_INT 105
92538: PUSH
92539: LD_INT 106
92541: PUSH
92542: LD_INT 108
92544: PUSH
92545: LD_INT 109
92547: PUSH
92548: LD_INT 112
92550: PUSH
92551: LD_INT 116
92553: PUSH
92554: LD_INT 117
92556: PUSH
92557: LD_INT 118
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: LIST
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: ST_TO_ADDR
92576: GO 95099
92578: LD_INT 7
92580: DOUBLE
92581: EQUAL
92582: IFTRUE 92586
92584: GO 92698
92586: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
92587: LD_ADDR_VAR 0 2
92591: PUSH
92592: LD_INT 2
92594: PUSH
92595: LD_INT 4
92597: PUSH
92598: LD_INT 5
92600: PUSH
92601: LD_INT 7
92603: PUSH
92604: LD_INT 11
92606: PUSH
92607: LD_INT 12
92609: PUSH
92610: LD_INT 15
92612: PUSH
92613: LD_INT 16
92615: PUSH
92616: LD_INT 20
92618: PUSH
92619: LD_INT 21
92621: PUSH
92622: LD_INT 22
92624: PUSH
92625: LD_INT 23
92627: PUSH
92628: LD_INT 25
92630: PUSH
92631: LD_INT 26
92633: PUSH
92634: EMPTY
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: LIST
92649: PUSH
92650: LD_INT 101
92652: PUSH
92653: LD_INT 102
92655: PUSH
92656: LD_INT 103
92658: PUSH
92659: LD_INT 105
92661: PUSH
92662: LD_INT 106
92664: PUSH
92665: LD_INT 108
92667: PUSH
92668: LD_INT 112
92670: PUSH
92671: LD_INT 116
92673: PUSH
92674: LD_INT 117
92676: PUSH
92677: LD_INT 118
92679: PUSH
92680: EMPTY
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: LIST
92691: PUSH
92692: EMPTY
92693: LIST
92694: LIST
92695: ST_TO_ADDR
92696: GO 95099
92698: LD_INT 8
92700: DOUBLE
92701: EQUAL
92702: IFTRUE 92706
92704: GO 92846
92706: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
92707: LD_ADDR_VAR 0 2
92711: PUSH
92712: LD_INT 2
92714: PUSH
92715: LD_INT 4
92717: PUSH
92718: LD_INT 5
92720: PUSH
92721: LD_INT 6
92723: PUSH
92724: LD_INT 7
92726: PUSH
92727: LD_INT 8
92729: PUSH
92730: LD_INT 11
92732: PUSH
92733: LD_INT 12
92735: PUSH
92736: LD_INT 15
92738: PUSH
92739: LD_INT 16
92741: PUSH
92742: LD_INT 20
92744: PUSH
92745: LD_INT 21
92747: PUSH
92748: LD_INT 22
92750: PUSH
92751: LD_INT 23
92753: PUSH
92754: LD_INT 25
92756: PUSH
92757: LD_INT 26
92759: PUSH
92760: LD_INT 30
92762: PUSH
92763: LD_INT 31
92765: PUSH
92766: LD_INT 32
92768: PUSH
92769: LD_INT 36
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: PUSH
92794: LD_INT 101
92796: PUSH
92797: LD_INT 102
92799: PUSH
92800: LD_INT 103
92802: PUSH
92803: LD_INT 105
92805: PUSH
92806: LD_INT 106
92808: PUSH
92809: LD_INT 108
92811: PUSH
92812: LD_INT 109
92814: PUSH
92815: LD_INT 112
92817: PUSH
92818: LD_INT 116
92820: PUSH
92821: LD_INT 117
92823: PUSH
92824: LD_INT 118
92826: PUSH
92827: EMPTY
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: PUSH
92840: EMPTY
92841: LIST
92842: LIST
92843: ST_TO_ADDR
92844: GO 95099
92846: LD_INT 9
92848: DOUBLE
92849: EQUAL
92850: IFTRUE 92854
92852: GO 93002
92854: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
92855: LD_ADDR_VAR 0 2
92859: PUSH
92860: LD_INT 2
92862: PUSH
92863: LD_INT 4
92865: PUSH
92866: LD_INT 5
92868: PUSH
92869: LD_INT 6
92871: PUSH
92872: LD_INT 7
92874: PUSH
92875: LD_INT 8
92877: PUSH
92878: LD_INT 11
92880: PUSH
92881: LD_INT 12
92883: PUSH
92884: LD_INT 15
92886: PUSH
92887: LD_INT 16
92889: PUSH
92890: LD_INT 20
92892: PUSH
92893: LD_INT 21
92895: PUSH
92896: LD_INT 22
92898: PUSH
92899: LD_INT 23
92901: PUSH
92902: LD_INT 25
92904: PUSH
92905: LD_INT 26
92907: PUSH
92908: LD_INT 28
92910: PUSH
92911: LD_INT 30
92913: PUSH
92914: LD_INT 31
92916: PUSH
92917: LD_INT 32
92919: PUSH
92920: LD_INT 36
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: PUSH
92946: LD_INT 101
92948: PUSH
92949: LD_INT 102
92951: PUSH
92952: LD_INT 103
92954: PUSH
92955: LD_INT 105
92957: PUSH
92958: LD_INT 106
92960: PUSH
92961: LD_INT 108
92963: PUSH
92964: LD_INT 109
92966: PUSH
92967: LD_INT 112
92969: PUSH
92970: LD_INT 114
92972: PUSH
92973: LD_INT 116
92975: PUSH
92976: LD_INT 117
92978: PUSH
92979: LD_INT 118
92981: PUSH
92982: EMPTY
92983: LIST
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: LIST
92989: LIST
92990: LIST
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: PUSH
92996: EMPTY
92997: LIST
92998: LIST
92999: ST_TO_ADDR
93000: GO 95099
93002: LD_INT 10
93004: DOUBLE
93005: EQUAL
93006: IFTRUE 93010
93008: GO 93206
93010: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
93011: LD_ADDR_VAR 0 2
93015: PUSH
93016: LD_INT 2
93018: PUSH
93019: LD_INT 4
93021: PUSH
93022: LD_INT 5
93024: PUSH
93025: LD_INT 6
93027: PUSH
93028: LD_INT 7
93030: PUSH
93031: LD_INT 8
93033: PUSH
93034: LD_INT 9
93036: PUSH
93037: LD_INT 10
93039: PUSH
93040: LD_INT 11
93042: PUSH
93043: LD_INT 12
93045: PUSH
93046: LD_INT 13
93048: PUSH
93049: LD_INT 14
93051: PUSH
93052: LD_INT 15
93054: PUSH
93055: LD_INT 16
93057: PUSH
93058: LD_INT 17
93060: PUSH
93061: LD_INT 18
93063: PUSH
93064: LD_INT 19
93066: PUSH
93067: LD_INT 20
93069: PUSH
93070: LD_INT 21
93072: PUSH
93073: LD_INT 22
93075: PUSH
93076: LD_INT 23
93078: PUSH
93079: LD_INT 24
93081: PUSH
93082: LD_INT 25
93084: PUSH
93085: LD_INT 26
93087: PUSH
93088: LD_INT 28
93090: PUSH
93091: LD_INT 30
93093: PUSH
93094: LD_INT 31
93096: PUSH
93097: LD_INT 32
93099: PUSH
93100: LD_INT 36
93102: PUSH
93103: EMPTY
93104: LIST
93105: LIST
93106: LIST
93107: LIST
93108: LIST
93109: LIST
93110: LIST
93111: LIST
93112: LIST
93113: LIST
93114: LIST
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: PUSH
93134: LD_INT 101
93136: PUSH
93137: LD_INT 102
93139: PUSH
93140: LD_INT 103
93142: PUSH
93143: LD_INT 104
93145: PUSH
93146: LD_INT 105
93148: PUSH
93149: LD_INT 106
93151: PUSH
93152: LD_INT 107
93154: PUSH
93155: LD_INT 108
93157: PUSH
93158: LD_INT 109
93160: PUSH
93161: LD_INT 110
93163: PUSH
93164: LD_INT 111
93166: PUSH
93167: LD_INT 112
93169: PUSH
93170: LD_INT 114
93172: PUSH
93173: LD_INT 116
93175: PUSH
93176: LD_INT 117
93178: PUSH
93179: LD_INT 118
93181: PUSH
93182: EMPTY
93183: LIST
93184: LIST
93185: LIST
93186: LIST
93187: LIST
93188: LIST
93189: LIST
93190: LIST
93191: LIST
93192: LIST
93193: LIST
93194: LIST
93195: LIST
93196: LIST
93197: LIST
93198: LIST
93199: PUSH
93200: EMPTY
93201: LIST
93202: LIST
93203: ST_TO_ADDR
93204: GO 95099
93206: LD_INT 11
93208: DOUBLE
93209: EQUAL
93210: IFTRUE 93214
93212: GO 93418
93214: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93215: LD_ADDR_VAR 0 2
93219: PUSH
93220: LD_INT 2
93222: PUSH
93223: LD_INT 3
93225: PUSH
93226: LD_INT 4
93228: PUSH
93229: LD_INT 5
93231: PUSH
93232: LD_INT 6
93234: PUSH
93235: LD_INT 7
93237: PUSH
93238: LD_INT 8
93240: PUSH
93241: LD_INT 9
93243: PUSH
93244: LD_INT 10
93246: PUSH
93247: LD_INT 11
93249: PUSH
93250: LD_INT 12
93252: PUSH
93253: LD_INT 13
93255: PUSH
93256: LD_INT 14
93258: PUSH
93259: LD_INT 15
93261: PUSH
93262: LD_INT 16
93264: PUSH
93265: LD_INT 17
93267: PUSH
93268: LD_INT 18
93270: PUSH
93271: LD_INT 19
93273: PUSH
93274: LD_INT 20
93276: PUSH
93277: LD_INT 21
93279: PUSH
93280: LD_INT 22
93282: PUSH
93283: LD_INT 23
93285: PUSH
93286: LD_INT 24
93288: PUSH
93289: LD_INT 25
93291: PUSH
93292: LD_INT 26
93294: PUSH
93295: LD_INT 28
93297: PUSH
93298: LD_INT 30
93300: PUSH
93301: LD_INT 31
93303: PUSH
93304: LD_INT 32
93306: PUSH
93307: LD_INT 34
93309: PUSH
93310: LD_INT 36
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: PUSH
93346: LD_INT 101
93348: PUSH
93349: LD_INT 102
93351: PUSH
93352: LD_INT 103
93354: PUSH
93355: LD_INT 104
93357: PUSH
93358: LD_INT 105
93360: PUSH
93361: LD_INT 106
93363: PUSH
93364: LD_INT 107
93366: PUSH
93367: LD_INT 108
93369: PUSH
93370: LD_INT 109
93372: PUSH
93373: LD_INT 110
93375: PUSH
93376: LD_INT 111
93378: PUSH
93379: LD_INT 112
93381: PUSH
93382: LD_INT 114
93384: PUSH
93385: LD_INT 116
93387: PUSH
93388: LD_INT 117
93390: PUSH
93391: LD_INT 118
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: LIST
93398: LIST
93399: LIST
93400: LIST
93401: LIST
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: LIST
93409: LIST
93410: LIST
93411: PUSH
93412: EMPTY
93413: LIST
93414: LIST
93415: ST_TO_ADDR
93416: GO 95099
93418: LD_INT 12
93420: DOUBLE
93421: EQUAL
93422: IFTRUE 93426
93424: GO 93646
93426: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93427: LD_ADDR_VAR 0 2
93431: PUSH
93432: LD_INT 1
93434: PUSH
93435: LD_INT 2
93437: PUSH
93438: LD_INT 3
93440: PUSH
93441: LD_INT 4
93443: PUSH
93444: LD_INT 5
93446: PUSH
93447: LD_INT 6
93449: PUSH
93450: LD_INT 7
93452: PUSH
93453: LD_INT 8
93455: PUSH
93456: LD_INT 9
93458: PUSH
93459: LD_INT 10
93461: PUSH
93462: LD_INT 11
93464: PUSH
93465: LD_INT 12
93467: PUSH
93468: LD_INT 13
93470: PUSH
93471: LD_INT 14
93473: PUSH
93474: LD_INT 15
93476: PUSH
93477: LD_INT 16
93479: PUSH
93480: LD_INT 17
93482: PUSH
93483: LD_INT 18
93485: PUSH
93486: LD_INT 19
93488: PUSH
93489: LD_INT 20
93491: PUSH
93492: LD_INT 21
93494: PUSH
93495: LD_INT 22
93497: PUSH
93498: LD_INT 23
93500: PUSH
93501: LD_INT 24
93503: PUSH
93504: LD_INT 25
93506: PUSH
93507: LD_INT 26
93509: PUSH
93510: LD_INT 27
93512: PUSH
93513: LD_INT 28
93515: PUSH
93516: LD_INT 30
93518: PUSH
93519: LD_INT 31
93521: PUSH
93522: LD_INT 32
93524: PUSH
93525: LD_INT 33
93527: PUSH
93528: LD_INT 34
93530: PUSH
93531: LD_INT 36
93533: PUSH
93534: EMPTY
93535: LIST
93536: LIST
93537: LIST
93538: LIST
93539: LIST
93540: LIST
93541: LIST
93542: LIST
93543: LIST
93544: LIST
93545: LIST
93546: LIST
93547: LIST
93548: LIST
93549: LIST
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: LIST
93568: LIST
93569: PUSH
93570: LD_INT 101
93572: PUSH
93573: LD_INT 102
93575: PUSH
93576: LD_INT 103
93578: PUSH
93579: LD_INT 104
93581: PUSH
93582: LD_INT 105
93584: PUSH
93585: LD_INT 106
93587: PUSH
93588: LD_INT 107
93590: PUSH
93591: LD_INT 108
93593: PUSH
93594: LD_INT 109
93596: PUSH
93597: LD_INT 110
93599: PUSH
93600: LD_INT 111
93602: PUSH
93603: LD_INT 112
93605: PUSH
93606: LD_INT 113
93608: PUSH
93609: LD_INT 114
93611: PUSH
93612: LD_INT 116
93614: PUSH
93615: LD_INT 117
93617: PUSH
93618: LD_INT 118
93620: PUSH
93621: EMPTY
93622: LIST
93623: LIST
93624: LIST
93625: LIST
93626: LIST
93627: LIST
93628: LIST
93629: LIST
93630: LIST
93631: LIST
93632: LIST
93633: LIST
93634: LIST
93635: LIST
93636: LIST
93637: LIST
93638: LIST
93639: PUSH
93640: EMPTY
93641: LIST
93642: LIST
93643: ST_TO_ADDR
93644: GO 95099
93646: LD_INT 13
93648: DOUBLE
93649: EQUAL
93650: IFTRUE 93654
93652: GO 93862
93654: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
93655: LD_ADDR_VAR 0 2
93659: PUSH
93660: LD_INT 1
93662: PUSH
93663: LD_INT 2
93665: PUSH
93666: LD_INT 3
93668: PUSH
93669: LD_INT 4
93671: PUSH
93672: LD_INT 5
93674: PUSH
93675: LD_INT 8
93677: PUSH
93678: LD_INT 9
93680: PUSH
93681: LD_INT 10
93683: PUSH
93684: LD_INT 11
93686: PUSH
93687: LD_INT 12
93689: PUSH
93690: LD_INT 14
93692: PUSH
93693: LD_INT 15
93695: PUSH
93696: LD_INT 16
93698: PUSH
93699: LD_INT 17
93701: PUSH
93702: LD_INT 18
93704: PUSH
93705: LD_INT 19
93707: PUSH
93708: LD_INT 20
93710: PUSH
93711: LD_INT 21
93713: PUSH
93714: LD_INT 22
93716: PUSH
93717: LD_INT 23
93719: PUSH
93720: LD_INT 24
93722: PUSH
93723: LD_INT 25
93725: PUSH
93726: LD_INT 26
93728: PUSH
93729: LD_INT 27
93731: PUSH
93732: LD_INT 28
93734: PUSH
93735: LD_INT 30
93737: PUSH
93738: LD_INT 31
93740: PUSH
93741: LD_INT 32
93743: PUSH
93744: LD_INT 33
93746: PUSH
93747: LD_INT 34
93749: PUSH
93750: LD_INT 36
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: LIST
93783: LIST
93784: LIST
93785: PUSH
93786: LD_INT 101
93788: PUSH
93789: LD_INT 102
93791: PUSH
93792: LD_INT 103
93794: PUSH
93795: LD_INT 104
93797: PUSH
93798: LD_INT 105
93800: PUSH
93801: LD_INT 106
93803: PUSH
93804: LD_INT 107
93806: PUSH
93807: LD_INT 108
93809: PUSH
93810: LD_INT 109
93812: PUSH
93813: LD_INT 110
93815: PUSH
93816: LD_INT 111
93818: PUSH
93819: LD_INT 112
93821: PUSH
93822: LD_INT 113
93824: PUSH
93825: LD_INT 114
93827: PUSH
93828: LD_INT 116
93830: PUSH
93831: LD_INT 117
93833: PUSH
93834: LD_INT 118
93836: PUSH
93837: EMPTY
93838: LIST
93839: LIST
93840: LIST
93841: LIST
93842: LIST
93843: LIST
93844: LIST
93845: LIST
93846: LIST
93847: LIST
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: LIST
93853: LIST
93854: LIST
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: ST_TO_ADDR
93860: GO 95099
93862: LD_INT 14
93864: DOUBLE
93865: EQUAL
93866: IFTRUE 93870
93868: GO 94094
93870: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
93871: LD_ADDR_VAR 0 2
93875: PUSH
93876: LD_INT 1
93878: PUSH
93879: LD_INT 2
93881: PUSH
93882: LD_INT 3
93884: PUSH
93885: LD_INT 4
93887: PUSH
93888: LD_INT 5
93890: PUSH
93891: LD_INT 6
93893: PUSH
93894: LD_INT 7
93896: PUSH
93897: LD_INT 8
93899: PUSH
93900: LD_INT 9
93902: PUSH
93903: LD_INT 10
93905: PUSH
93906: LD_INT 11
93908: PUSH
93909: LD_INT 12
93911: PUSH
93912: LD_INT 13
93914: PUSH
93915: LD_INT 14
93917: PUSH
93918: LD_INT 15
93920: PUSH
93921: LD_INT 16
93923: PUSH
93924: LD_INT 17
93926: PUSH
93927: LD_INT 18
93929: PUSH
93930: LD_INT 19
93932: PUSH
93933: LD_INT 20
93935: PUSH
93936: LD_INT 21
93938: PUSH
93939: LD_INT 22
93941: PUSH
93942: LD_INT 23
93944: PUSH
93945: LD_INT 24
93947: PUSH
93948: LD_INT 25
93950: PUSH
93951: LD_INT 26
93953: PUSH
93954: LD_INT 27
93956: PUSH
93957: LD_INT 28
93959: PUSH
93960: LD_INT 29
93962: PUSH
93963: LD_INT 30
93965: PUSH
93966: LD_INT 31
93968: PUSH
93969: LD_INT 32
93971: PUSH
93972: LD_INT 33
93974: PUSH
93975: LD_INT 34
93977: PUSH
93978: LD_INT 36
93980: PUSH
93981: EMPTY
93982: LIST
93983: LIST
93984: LIST
93985: LIST
93986: LIST
93987: LIST
93988: LIST
93989: LIST
93990: LIST
93991: LIST
93992: LIST
93993: LIST
93994: LIST
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: LIST
94017: PUSH
94018: LD_INT 101
94020: PUSH
94021: LD_INT 102
94023: PUSH
94024: LD_INT 103
94026: PUSH
94027: LD_INT 104
94029: PUSH
94030: LD_INT 105
94032: PUSH
94033: LD_INT 106
94035: PUSH
94036: LD_INT 107
94038: PUSH
94039: LD_INT 108
94041: PUSH
94042: LD_INT 109
94044: PUSH
94045: LD_INT 110
94047: PUSH
94048: LD_INT 111
94050: PUSH
94051: LD_INT 112
94053: PUSH
94054: LD_INT 113
94056: PUSH
94057: LD_INT 114
94059: PUSH
94060: LD_INT 116
94062: PUSH
94063: LD_INT 117
94065: PUSH
94066: LD_INT 118
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: ST_TO_ADDR
94092: GO 95099
94094: LD_INT 15
94096: DOUBLE
94097: EQUAL
94098: IFTRUE 94102
94100: GO 94326
94102: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
94103: LD_ADDR_VAR 0 2
94107: PUSH
94108: LD_INT 1
94110: PUSH
94111: LD_INT 2
94113: PUSH
94114: LD_INT 3
94116: PUSH
94117: LD_INT 4
94119: PUSH
94120: LD_INT 5
94122: PUSH
94123: LD_INT 6
94125: PUSH
94126: LD_INT 7
94128: PUSH
94129: LD_INT 8
94131: PUSH
94132: LD_INT 9
94134: PUSH
94135: LD_INT 10
94137: PUSH
94138: LD_INT 11
94140: PUSH
94141: LD_INT 12
94143: PUSH
94144: LD_INT 13
94146: PUSH
94147: LD_INT 14
94149: PUSH
94150: LD_INT 15
94152: PUSH
94153: LD_INT 16
94155: PUSH
94156: LD_INT 17
94158: PUSH
94159: LD_INT 18
94161: PUSH
94162: LD_INT 19
94164: PUSH
94165: LD_INT 20
94167: PUSH
94168: LD_INT 21
94170: PUSH
94171: LD_INT 22
94173: PUSH
94174: LD_INT 23
94176: PUSH
94177: LD_INT 24
94179: PUSH
94180: LD_INT 25
94182: PUSH
94183: LD_INT 26
94185: PUSH
94186: LD_INT 27
94188: PUSH
94189: LD_INT 28
94191: PUSH
94192: LD_INT 29
94194: PUSH
94195: LD_INT 30
94197: PUSH
94198: LD_INT 31
94200: PUSH
94201: LD_INT 32
94203: PUSH
94204: LD_INT 33
94206: PUSH
94207: LD_INT 34
94209: PUSH
94210: LD_INT 36
94212: PUSH
94213: EMPTY
94214: LIST
94215: LIST
94216: LIST
94217: LIST
94218: LIST
94219: LIST
94220: LIST
94221: LIST
94222: LIST
94223: LIST
94224: LIST
94225: LIST
94226: LIST
94227: LIST
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: LIST
94233: LIST
94234: LIST
94235: LIST
94236: LIST
94237: LIST
94238: LIST
94239: LIST
94240: LIST
94241: LIST
94242: LIST
94243: LIST
94244: LIST
94245: LIST
94246: LIST
94247: LIST
94248: LIST
94249: PUSH
94250: LD_INT 101
94252: PUSH
94253: LD_INT 102
94255: PUSH
94256: LD_INT 103
94258: PUSH
94259: LD_INT 104
94261: PUSH
94262: LD_INT 105
94264: PUSH
94265: LD_INT 106
94267: PUSH
94268: LD_INT 107
94270: PUSH
94271: LD_INT 108
94273: PUSH
94274: LD_INT 109
94276: PUSH
94277: LD_INT 110
94279: PUSH
94280: LD_INT 111
94282: PUSH
94283: LD_INT 112
94285: PUSH
94286: LD_INT 113
94288: PUSH
94289: LD_INT 114
94291: PUSH
94292: LD_INT 116
94294: PUSH
94295: LD_INT 117
94297: PUSH
94298: LD_INT 118
94300: PUSH
94301: EMPTY
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: PUSH
94320: EMPTY
94321: LIST
94322: LIST
94323: ST_TO_ADDR
94324: GO 95099
94326: LD_INT 16
94328: DOUBLE
94329: EQUAL
94330: IFTRUE 94334
94332: GO 94470
94334: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94335: LD_ADDR_VAR 0 2
94339: PUSH
94340: LD_INT 2
94342: PUSH
94343: LD_INT 4
94345: PUSH
94346: LD_INT 5
94348: PUSH
94349: LD_INT 7
94351: PUSH
94352: LD_INT 11
94354: PUSH
94355: LD_INT 12
94357: PUSH
94358: LD_INT 15
94360: PUSH
94361: LD_INT 16
94363: PUSH
94364: LD_INT 20
94366: PUSH
94367: LD_INT 21
94369: PUSH
94370: LD_INT 22
94372: PUSH
94373: LD_INT 23
94375: PUSH
94376: LD_INT 25
94378: PUSH
94379: LD_INT 26
94381: PUSH
94382: LD_INT 30
94384: PUSH
94385: LD_INT 31
94387: PUSH
94388: LD_INT 32
94390: PUSH
94391: LD_INT 33
94393: PUSH
94394: LD_INT 34
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: PUSH
94418: LD_INT 101
94420: PUSH
94421: LD_INT 102
94423: PUSH
94424: LD_INT 103
94426: PUSH
94427: LD_INT 106
94429: PUSH
94430: LD_INT 108
94432: PUSH
94433: LD_INT 112
94435: PUSH
94436: LD_INT 113
94438: PUSH
94439: LD_INT 114
94441: PUSH
94442: LD_INT 116
94444: PUSH
94445: LD_INT 117
94447: PUSH
94448: LD_INT 118
94450: PUSH
94451: EMPTY
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: ST_TO_ADDR
94468: GO 95099
94470: LD_INT 17
94472: DOUBLE
94473: EQUAL
94474: IFTRUE 94478
94476: GO 94702
94478: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
94479: LD_ADDR_VAR 0 2
94483: PUSH
94484: LD_INT 1
94486: PUSH
94487: LD_INT 2
94489: PUSH
94490: LD_INT 3
94492: PUSH
94493: LD_INT 4
94495: PUSH
94496: LD_INT 5
94498: PUSH
94499: LD_INT 6
94501: PUSH
94502: LD_INT 7
94504: PUSH
94505: LD_INT 8
94507: PUSH
94508: LD_INT 9
94510: PUSH
94511: LD_INT 10
94513: PUSH
94514: LD_INT 11
94516: PUSH
94517: LD_INT 12
94519: PUSH
94520: LD_INT 13
94522: PUSH
94523: LD_INT 14
94525: PUSH
94526: LD_INT 15
94528: PUSH
94529: LD_INT 16
94531: PUSH
94532: LD_INT 17
94534: PUSH
94535: LD_INT 18
94537: PUSH
94538: LD_INT 19
94540: PUSH
94541: LD_INT 20
94543: PUSH
94544: LD_INT 21
94546: PUSH
94547: LD_INT 22
94549: PUSH
94550: LD_INT 23
94552: PUSH
94553: LD_INT 24
94555: PUSH
94556: LD_INT 25
94558: PUSH
94559: LD_INT 26
94561: PUSH
94562: LD_INT 27
94564: PUSH
94565: LD_INT 28
94567: PUSH
94568: LD_INT 29
94570: PUSH
94571: LD_INT 30
94573: PUSH
94574: LD_INT 31
94576: PUSH
94577: LD_INT 32
94579: PUSH
94580: LD_INT 33
94582: PUSH
94583: LD_INT 34
94585: PUSH
94586: LD_INT 36
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: PUSH
94626: LD_INT 101
94628: PUSH
94629: LD_INT 102
94631: PUSH
94632: LD_INT 103
94634: PUSH
94635: LD_INT 104
94637: PUSH
94638: LD_INT 105
94640: PUSH
94641: LD_INT 106
94643: PUSH
94644: LD_INT 107
94646: PUSH
94647: LD_INT 108
94649: PUSH
94650: LD_INT 109
94652: PUSH
94653: LD_INT 110
94655: PUSH
94656: LD_INT 111
94658: PUSH
94659: LD_INT 112
94661: PUSH
94662: LD_INT 113
94664: PUSH
94665: LD_INT 114
94667: PUSH
94668: LD_INT 116
94670: PUSH
94671: LD_INT 117
94673: PUSH
94674: LD_INT 118
94676: PUSH
94677: EMPTY
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: LIST
94693: LIST
94694: LIST
94695: PUSH
94696: EMPTY
94697: LIST
94698: LIST
94699: ST_TO_ADDR
94700: GO 95099
94702: LD_INT 18
94704: DOUBLE
94705: EQUAL
94706: IFTRUE 94710
94708: GO 94858
94710: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
94711: LD_ADDR_VAR 0 2
94715: PUSH
94716: LD_INT 2
94718: PUSH
94719: LD_INT 4
94721: PUSH
94722: LD_INT 5
94724: PUSH
94725: LD_INT 7
94727: PUSH
94728: LD_INT 11
94730: PUSH
94731: LD_INT 12
94733: PUSH
94734: LD_INT 15
94736: PUSH
94737: LD_INT 16
94739: PUSH
94740: LD_INT 20
94742: PUSH
94743: LD_INT 21
94745: PUSH
94746: LD_INT 22
94748: PUSH
94749: LD_INT 23
94751: PUSH
94752: LD_INT 25
94754: PUSH
94755: LD_INT 26
94757: PUSH
94758: LD_INT 30
94760: PUSH
94761: LD_INT 31
94763: PUSH
94764: LD_INT 32
94766: PUSH
94767: LD_INT 33
94769: PUSH
94770: LD_INT 34
94772: PUSH
94773: LD_INT 35
94775: PUSH
94776: LD_INT 36
94778: PUSH
94779: EMPTY
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: PUSH
94802: LD_INT 101
94804: PUSH
94805: LD_INT 102
94807: PUSH
94808: LD_INT 103
94810: PUSH
94811: LD_INT 106
94813: PUSH
94814: LD_INT 108
94816: PUSH
94817: LD_INT 112
94819: PUSH
94820: LD_INT 113
94822: PUSH
94823: LD_INT 114
94825: PUSH
94826: LD_INT 115
94828: PUSH
94829: LD_INT 116
94831: PUSH
94832: LD_INT 117
94834: PUSH
94835: LD_INT 118
94837: PUSH
94838: EMPTY
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: LIST
94851: PUSH
94852: EMPTY
94853: LIST
94854: LIST
94855: ST_TO_ADDR
94856: GO 95099
94858: LD_INT 19
94860: DOUBLE
94861: EQUAL
94862: IFTRUE 94866
94864: GO 95098
94866: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
94867: LD_ADDR_VAR 0 2
94871: PUSH
94872: LD_INT 1
94874: PUSH
94875: LD_INT 2
94877: PUSH
94878: LD_INT 3
94880: PUSH
94881: LD_INT 4
94883: PUSH
94884: LD_INT 5
94886: PUSH
94887: LD_INT 6
94889: PUSH
94890: LD_INT 7
94892: PUSH
94893: LD_INT 8
94895: PUSH
94896: LD_INT 9
94898: PUSH
94899: LD_INT 10
94901: PUSH
94902: LD_INT 11
94904: PUSH
94905: LD_INT 12
94907: PUSH
94908: LD_INT 13
94910: PUSH
94911: LD_INT 14
94913: PUSH
94914: LD_INT 15
94916: PUSH
94917: LD_INT 16
94919: PUSH
94920: LD_INT 17
94922: PUSH
94923: LD_INT 18
94925: PUSH
94926: LD_INT 19
94928: PUSH
94929: LD_INT 20
94931: PUSH
94932: LD_INT 21
94934: PUSH
94935: LD_INT 22
94937: PUSH
94938: LD_INT 23
94940: PUSH
94941: LD_INT 24
94943: PUSH
94944: LD_INT 25
94946: PUSH
94947: LD_INT 26
94949: PUSH
94950: LD_INT 27
94952: PUSH
94953: LD_INT 28
94955: PUSH
94956: LD_INT 29
94958: PUSH
94959: LD_INT 30
94961: PUSH
94962: LD_INT 31
94964: PUSH
94965: LD_INT 32
94967: PUSH
94968: LD_INT 33
94970: PUSH
94971: LD_INT 34
94973: PUSH
94974: LD_INT 35
94976: PUSH
94977: LD_INT 36
94979: PUSH
94980: EMPTY
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: PUSH
95018: LD_INT 101
95020: PUSH
95021: LD_INT 102
95023: PUSH
95024: LD_INT 103
95026: PUSH
95027: LD_INT 104
95029: PUSH
95030: LD_INT 105
95032: PUSH
95033: LD_INT 106
95035: PUSH
95036: LD_INT 107
95038: PUSH
95039: LD_INT 108
95041: PUSH
95042: LD_INT 109
95044: PUSH
95045: LD_INT 110
95047: PUSH
95048: LD_INT 111
95050: PUSH
95051: LD_INT 112
95053: PUSH
95054: LD_INT 113
95056: PUSH
95057: LD_INT 114
95059: PUSH
95060: LD_INT 115
95062: PUSH
95063: LD_INT 116
95065: PUSH
95066: LD_INT 117
95068: PUSH
95069: LD_INT 118
95071: PUSH
95072: EMPTY
95073: LIST
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: PUSH
95092: EMPTY
95093: LIST
95094: LIST
95095: ST_TO_ADDR
95096: GO 95099
95098: POP
// end else
95099: GO 95330
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
95101: LD_ADDR_VAR 0 2
95105: PUSH
95106: LD_INT 1
95108: PUSH
95109: LD_INT 2
95111: PUSH
95112: LD_INT 3
95114: PUSH
95115: LD_INT 4
95117: PUSH
95118: LD_INT 5
95120: PUSH
95121: LD_INT 6
95123: PUSH
95124: LD_INT 7
95126: PUSH
95127: LD_INT 8
95129: PUSH
95130: LD_INT 9
95132: PUSH
95133: LD_INT 10
95135: PUSH
95136: LD_INT 11
95138: PUSH
95139: LD_INT 12
95141: PUSH
95142: LD_INT 13
95144: PUSH
95145: LD_INT 14
95147: PUSH
95148: LD_INT 15
95150: PUSH
95151: LD_INT 16
95153: PUSH
95154: LD_INT 17
95156: PUSH
95157: LD_INT 18
95159: PUSH
95160: LD_INT 19
95162: PUSH
95163: LD_INT 20
95165: PUSH
95166: LD_INT 21
95168: PUSH
95169: LD_INT 22
95171: PUSH
95172: LD_INT 23
95174: PUSH
95175: LD_INT 24
95177: PUSH
95178: LD_INT 25
95180: PUSH
95181: LD_INT 26
95183: PUSH
95184: LD_INT 27
95186: PUSH
95187: LD_INT 28
95189: PUSH
95190: LD_INT 29
95192: PUSH
95193: LD_INT 30
95195: PUSH
95196: LD_INT 31
95198: PUSH
95199: LD_INT 32
95201: PUSH
95202: LD_INT 33
95204: PUSH
95205: LD_INT 34
95207: PUSH
95208: LD_INT 35
95210: PUSH
95211: LD_INT 36
95213: PUSH
95214: EMPTY
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: PUSH
95252: LD_INT 101
95254: PUSH
95255: LD_INT 102
95257: PUSH
95258: LD_INT 103
95260: PUSH
95261: LD_INT 104
95263: PUSH
95264: LD_INT 105
95266: PUSH
95267: LD_INT 106
95269: PUSH
95270: LD_INT 107
95272: PUSH
95273: LD_INT 108
95275: PUSH
95276: LD_INT 109
95278: PUSH
95279: LD_INT 110
95281: PUSH
95282: LD_INT 111
95284: PUSH
95285: LD_INT 112
95287: PUSH
95288: LD_INT 113
95290: PUSH
95291: LD_INT 114
95293: PUSH
95294: LD_INT 115
95296: PUSH
95297: LD_INT 116
95299: PUSH
95300: LD_INT 117
95302: PUSH
95303: LD_INT 118
95305: PUSH
95306: EMPTY
95307: LIST
95308: LIST
95309: LIST
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: PUSH
95326: EMPTY
95327: LIST
95328: LIST
95329: ST_TO_ADDR
// if result then
95330: LD_VAR 0 2
95334: IFFALSE 96120
// begin normal :=  ;
95336: LD_ADDR_VAR 0 5
95340: PUSH
95341: LD_STRING 
95343: ST_TO_ADDR
// hardcore :=  ;
95344: LD_ADDR_VAR 0 6
95348: PUSH
95349: LD_STRING 
95351: ST_TO_ADDR
// active :=  ;
95352: LD_ADDR_VAR 0 7
95356: PUSH
95357: LD_STRING 
95359: ST_TO_ADDR
// for i = 1 to normalCounter do
95360: LD_ADDR_VAR 0 8
95364: PUSH
95365: DOUBLE
95366: LD_INT 1
95368: DEC
95369: ST_TO_ADDR
95370: LD_EXP 96
95374: PUSH
95375: FOR_TO
95376: IFFALSE 95477
// begin tmp := 0 ;
95378: LD_ADDR_VAR 0 3
95382: PUSH
95383: LD_STRING 0
95385: ST_TO_ADDR
// if result [ 1 ] then
95386: LD_VAR 0 2
95390: PUSH
95391: LD_INT 1
95393: ARRAY
95394: IFFALSE 95459
// if result [ 1 ] [ 1 ] = i then
95396: LD_VAR 0 2
95400: PUSH
95401: LD_INT 1
95403: ARRAY
95404: PUSH
95405: LD_INT 1
95407: ARRAY
95408: PUSH
95409: LD_VAR 0 8
95413: EQUAL
95414: IFFALSE 95459
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95416: LD_ADDR_VAR 0 2
95420: PUSH
95421: LD_VAR 0 2
95425: PPUSH
95426: LD_INT 1
95428: PPUSH
95429: LD_VAR 0 2
95433: PUSH
95434: LD_INT 1
95436: ARRAY
95437: PPUSH
95438: LD_INT 1
95440: PPUSH
95441: CALL_OW 3
95445: PPUSH
95446: CALL_OW 1
95450: ST_TO_ADDR
// tmp := 1 ;
95451: LD_ADDR_VAR 0 3
95455: PUSH
95456: LD_STRING 1
95458: ST_TO_ADDR
// end ; normal := normal & tmp ;
95459: LD_ADDR_VAR 0 5
95463: PUSH
95464: LD_VAR 0 5
95468: PUSH
95469: LD_VAR 0 3
95473: STR
95474: ST_TO_ADDR
// end ;
95475: GO 95375
95477: POP
95478: POP
// for i = 1 to hardcoreCounter do
95479: LD_ADDR_VAR 0 8
95483: PUSH
95484: DOUBLE
95485: LD_INT 1
95487: DEC
95488: ST_TO_ADDR
95489: LD_EXP 97
95493: PUSH
95494: FOR_TO
95495: IFFALSE 95600
// begin tmp := 0 ;
95497: LD_ADDR_VAR 0 3
95501: PUSH
95502: LD_STRING 0
95504: ST_TO_ADDR
// if result [ 2 ] then
95505: LD_VAR 0 2
95509: PUSH
95510: LD_INT 2
95512: ARRAY
95513: IFFALSE 95582
// if result [ 2 ] [ 1 ] = 100 + i then
95515: LD_VAR 0 2
95519: PUSH
95520: LD_INT 2
95522: ARRAY
95523: PUSH
95524: LD_INT 1
95526: ARRAY
95527: PUSH
95528: LD_INT 100
95530: PUSH
95531: LD_VAR 0 8
95535: PLUS
95536: EQUAL
95537: IFFALSE 95582
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95539: LD_ADDR_VAR 0 2
95543: PUSH
95544: LD_VAR 0 2
95548: PPUSH
95549: LD_INT 2
95551: PPUSH
95552: LD_VAR 0 2
95556: PUSH
95557: LD_INT 2
95559: ARRAY
95560: PPUSH
95561: LD_INT 1
95563: PPUSH
95564: CALL_OW 3
95568: PPUSH
95569: CALL_OW 1
95573: ST_TO_ADDR
// tmp := 1 ;
95574: LD_ADDR_VAR 0 3
95578: PUSH
95579: LD_STRING 1
95581: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95582: LD_ADDR_VAR 0 6
95586: PUSH
95587: LD_VAR 0 6
95591: PUSH
95592: LD_VAR 0 3
95596: STR
95597: ST_TO_ADDR
// end ;
95598: GO 95494
95600: POP
95601: POP
// if isGameLoad then
95602: LD_VAR 0 1
95606: IFFALSE 96081
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
95608: LD_ADDR_VAR 0 4
95612: PUSH
95613: LD_EXP 100
95617: PUSH
95618: LD_EXP 99
95622: PUSH
95623: LD_EXP 101
95627: PUSH
95628: LD_EXP 98
95632: PUSH
95633: LD_EXP 102
95637: PUSH
95638: LD_EXP 103
95642: PUSH
95643: LD_EXP 104
95647: PUSH
95648: LD_EXP 105
95652: PUSH
95653: LD_EXP 106
95657: PUSH
95658: LD_EXP 107
95662: PUSH
95663: LD_EXP 108
95667: PUSH
95668: LD_EXP 109
95672: PUSH
95673: LD_EXP 110
95677: PUSH
95678: LD_EXP 111
95682: PUSH
95683: LD_EXP 119
95687: PUSH
95688: LD_EXP 120
95692: PUSH
95693: LD_EXP 121
95697: PUSH
95698: LD_EXP 122
95702: PUSH
95703: LD_EXP 124
95707: PUSH
95708: LD_EXP 125
95712: PUSH
95713: LD_EXP 126
95717: PUSH
95718: LD_EXP 129
95722: PUSH
95723: LD_EXP 131
95727: PUSH
95728: LD_EXP 132
95732: PUSH
95733: LD_EXP 133
95737: PUSH
95738: LD_EXP 135
95742: PUSH
95743: LD_EXP 136
95747: PUSH
95748: LD_EXP 139
95752: PUSH
95753: LD_EXP 140
95757: PUSH
95758: LD_EXP 141
95762: PUSH
95763: LD_EXP 142
95767: PUSH
95768: LD_EXP 143
95772: PUSH
95773: LD_EXP 144
95777: PUSH
95778: LD_EXP 145
95782: PUSH
95783: LD_EXP 146
95787: PUSH
95788: LD_EXP 147
95792: PUSH
95793: LD_EXP 112
95797: PUSH
95798: LD_EXP 113
95802: PUSH
95803: LD_EXP 116
95807: PUSH
95808: LD_EXP 117
95812: PUSH
95813: LD_EXP 118
95817: PUSH
95818: LD_EXP 114
95822: PUSH
95823: LD_EXP 115
95827: PUSH
95828: LD_EXP 123
95832: PUSH
95833: LD_EXP 127
95837: PUSH
95838: LD_EXP 128
95842: PUSH
95843: LD_EXP 130
95847: PUSH
95848: LD_EXP 134
95852: PUSH
95853: LD_EXP 137
95857: PUSH
95858: LD_EXP 138
95862: PUSH
95863: LD_EXP 148
95867: PUSH
95868: LD_EXP 149
95872: PUSH
95873: LD_EXP 150
95877: PUSH
95878: LD_EXP 151
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: ST_TO_ADDR
// tmp :=  ;
95939: LD_ADDR_VAR 0 3
95943: PUSH
95944: LD_STRING 
95946: ST_TO_ADDR
// for i = 1 to normalCounter do
95947: LD_ADDR_VAR 0 8
95951: PUSH
95952: DOUBLE
95953: LD_INT 1
95955: DEC
95956: ST_TO_ADDR
95957: LD_EXP 96
95961: PUSH
95962: FOR_TO
95963: IFFALSE 95999
// begin if flags [ i ] then
95965: LD_VAR 0 4
95969: PUSH
95970: LD_VAR 0 8
95974: ARRAY
95975: IFFALSE 95997
// tmp := tmp & i & ; ;
95977: LD_ADDR_VAR 0 3
95981: PUSH
95982: LD_VAR 0 3
95986: PUSH
95987: LD_VAR 0 8
95991: STR
95992: PUSH
95993: LD_STRING ;
95995: STR
95996: ST_TO_ADDR
// end ;
95997: GO 95962
95999: POP
96000: POP
// for i = 1 to hardcoreCounter do
96001: LD_ADDR_VAR 0 8
96005: PUSH
96006: DOUBLE
96007: LD_INT 1
96009: DEC
96010: ST_TO_ADDR
96011: LD_EXP 97
96015: PUSH
96016: FOR_TO
96017: IFFALSE 96063
// begin if flags [ normalCounter + i ] then
96019: LD_VAR 0 4
96023: PUSH
96024: LD_EXP 96
96028: PUSH
96029: LD_VAR 0 8
96033: PLUS
96034: ARRAY
96035: IFFALSE 96061
// tmp := tmp & ( 100 + i ) & ; ;
96037: LD_ADDR_VAR 0 3
96041: PUSH
96042: LD_VAR 0 3
96046: PUSH
96047: LD_INT 100
96049: PUSH
96050: LD_VAR 0 8
96054: PLUS
96055: STR
96056: PUSH
96057: LD_STRING ;
96059: STR
96060: ST_TO_ADDR
// end ;
96061: GO 96016
96063: POP
96064: POP
// if tmp then
96065: LD_VAR 0 3
96069: IFFALSE 96081
// active := tmp ;
96071: LD_ADDR_VAR 0 7
96075: PUSH
96076: LD_VAR 0 3
96080: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
96081: LD_STRING getStreamItemsFromMission("
96083: PUSH
96084: LD_VAR 0 5
96088: STR
96089: PUSH
96090: LD_STRING ","
96092: STR
96093: PUSH
96094: LD_VAR 0 6
96098: STR
96099: PUSH
96100: LD_STRING ","
96102: STR
96103: PUSH
96104: LD_VAR 0 7
96108: STR
96109: PUSH
96110: LD_STRING ")
96112: STR
96113: PPUSH
96114: CALL_OW 559
// end else
96118: GO 96127
// ToLua ( getStreamItemsFromMission("","","") ) ;
96120: LD_STRING getStreamItemsFromMission("","","")
96122: PPUSH
96123: CALL_OW 559
// end ;
96127: LD_VAR 0 2
96131: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96132: LD_EXP 95
96136: PUSH
96137: LD_EXP 100
96141: AND
96142: IFFALSE 96266
96144: GO 96146
96146: DISABLE
96147: LD_INT 0
96149: PPUSH
96150: PPUSH
// begin enable ;
96151: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96152: LD_ADDR_VAR 0 2
96156: PUSH
96157: LD_INT 22
96159: PUSH
96160: LD_OWVAR 2
96164: PUSH
96165: EMPTY
96166: LIST
96167: LIST
96168: PUSH
96169: LD_INT 2
96171: PUSH
96172: LD_INT 34
96174: PUSH
96175: LD_INT 7
96177: PUSH
96178: EMPTY
96179: LIST
96180: LIST
96181: PUSH
96182: LD_INT 34
96184: PUSH
96185: LD_INT 45
96187: PUSH
96188: EMPTY
96189: LIST
96190: LIST
96191: PUSH
96192: LD_INT 34
96194: PUSH
96195: LD_INT 28
96197: PUSH
96198: EMPTY
96199: LIST
96200: LIST
96201: PUSH
96202: LD_INT 34
96204: PUSH
96205: LD_INT 47
96207: PUSH
96208: EMPTY
96209: LIST
96210: LIST
96211: PUSH
96212: EMPTY
96213: LIST
96214: LIST
96215: LIST
96216: LIST
96217: LIST
96218: PUSH
96219: EMPTY
96220: LIST
96221: LIST
96222: PPUSH
96223: CALL_OW 69
96227: ST_TO_ADDR
// if not tmp then
96228: LD_VAR 0 2
96232: NOT
96233: IFFALSE 96237
// exit ;
96235: GO 96266
// for i in tmp do
96237: LD_ADDR_VAR 0 1
96241: PUSH
96242: LD_VAR 0 2
96246: PUSH
96247: FOR_IN
96248: IFFALSE 96264
// begin SetLives ( i , 0 ) ;
96250: LD_VAR 0 1
96254: PPUSH
96255: LD_INT 0
96257: PPUSH
96258: CALL_OW 234
// end ;
96262: GO 96247
96264: POP
96265: POP
// end ;
96266: PPOPN 2
96268: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96269: LD_EXP 95
96273: PUSH
96274: LD_EXP 101
96278: AND
96279: IFFALSE 96363
96281: GO 96283
96283: DISABLE
96284: LD_INT 0
96286: PPUSH
96287: PPUSH
// begin enable ;
96288: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96289: LD_ADDR_VAR 0 2
96293: PUSH
96294: LD_INT 22
96296: PUSH
96297: LD_OWVAR 2
96301: PUSH
96302: EMPTY
96303: LIST
96304: LIST
96305: PUSH
96306: LD_INT 32
96308: PUSH
96309: LD_INT 3
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: PUSH
96316: EMPTY
96317: LIST
96318: LIST
96319: PPUSH
96320: CALL_OW 69
96324: ST_TO_ADDR
// if not tmp then
96325: LD_VAR 0 2
96329: NOT
96330: IFFALSE 96334
// exit ;
96332: GO 96363
// for i in tmp do
96334: LD_ADDR_VAR 0 1
96338: PUSH
96339: LD_VAR 0 2
96343: PUSH
96344: FOR_IN
96345: IFFALSE 96361
// begin SetLives ( i , 0 ) ;
96347: LD_VAR 0 1
96351: PPUSH
96352: LD_INT 0
96354: PPUSH
96355: CALL_OW 234
// end ;
96359: GO 96344
96361: POP
96362: POP
// end ;
96363: PPOPN 2
96365: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96366: LD_EXP 95
96370: PUSH
96371: LD_EXP 98
96375: AND
96376: IFFALSE 96469
96378: GO 96380
96380: DISABLE
96381: LD_INT 0
96383: PPUSH
// begin enable ;
96384: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96385: LD_ADDR_VAR 0 1
96389: PUSH
96390: LD_INT 22
96392: PUSH
96393: LD_OWVAR 2
96397: PUSH
96398: EMPTY
96399: LIST
96400: LIST
96401: PUSH
96402: LD_INT 2
96404: PUSH
96405: LD_INT 25
96407: PUSH
96408: LD_INT 5
96410: PUSH
96411: EMPTY
96412: LIST
96413: LIST
96414: PUSH
96415: LD_INT 25
96417: PUSH
96418: LD_INT 9
96420: PUSH
96421: EMPTY
96422: LIST
96423: LIST
96424: PUSH
96425: LD_INT 25
96427: PUSH
96428: LD_INT 8
96430: PUSH
96431: EMPTY
96432: LIST
96433: LIST
96434: PUSH
96435: EMPTY
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: PUSH
96441: EMPTY
96442: LIST
96443: LIST
96444: PPUSH
96445: CALL_OW 69
96449: PUSH
96450: FOR_IN
96451: IFFALSE 96467
// begin SetClass ( i , 1 ) ;
96453: LD_VAR 0 1
96457: PPUSH
96458: LD_INT 1
96460: PPUSH
96461: CALL_OW 336
// end ;
96465: GO 96450
96467: POP
96468: POP
// end ;
96469: PPOPN 1
96471: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96472: LD_EXP 95
96476: PUSH
96477: LD_EXP 99
96481: AND
96482: PUSH
96483: LD_OWVAR 65
96487: PUSH
96488: LD_INT 7
96490: LESS
96491: AND
96492: IFFALSE 96506
96494: GO 96496
96496: DISABLE
// begin enable ;
96497: ENABLE
// game_speed := 7 ;
96498: LD_ADDR_OWVAR 65
96502: PUSH
96503: LD_INT 7
96505: ST_TO_ADDR
// end ;
96506: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96507: LD_EXP 95
96511: PUSH
96512: LD_EXP 102
96516: AND
96517: IFFALSE 96719
96519: GO 96521
96521: DISABLE
96522: LD_INT 0
96524: PPUSH
96525: PPUSH
96526: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96527: LD_ADDR_VAR 0 3
96531: PUSH
96532: LD_INT 81
96534: PUSH
96535: LD_OWVAR 2
96539: PUSH
96540: EMPTY
96541: LIST
96542: LIST
96543: PUSH
96544: LD_INT 21
96546: PUSH
96547: LD_INT 1
96549: PUSH
96550: EMPTY
96551: LIST
96552: LIST
96553: PUSH
96554: EMPTY
96555: LIST
96556: LIST
96557: PPUSH
96558: CALL_OW 69
96562: ST_TO_ADDR
// if not tmp then
96563: LD_VAR 0 3
96567: NOT
96568: IFFALSE 96572
// exit ;
96570: GO 96719
// if tmp > 5 then
96572: LD_VAR 0 3
96576: PUSH
96577: LD_INT 5
96579: GREATER
96580: IFFALSE 96592
// k := 5 else
96582: LD_ADDR_VAR 0 2
96586: PUSH
96587: LD_INT 5
96589: ST_TO_ADDR
96590: GO 96602
// k := tmp ;
96592: LD_ADDR_VAR 0 2
96596: PUSH
96597: LD_VAR 0 3
96601: ST_TO_ADDR
// for i := 1 to k do
96602: LD_ADDR_VAR 0 1
96606: PUSH
96607: DOUBLE
96608: LD_INT 1
96610: DEC
96611: ST_TO_ADDR
96612: LD_VAR 0 2
96616: PUSH
96617: FOR_TO
96618: IFFALSE 96717
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96620: LD_VAR 0 3
96624: PUSH
96625: LD_VAR 0 1
96629: ARRAY
96630: PPUSH
96631: LD_VAR 0 1
96635: PUSH
96636: LD_INT 4
96638: MOD
96639: PUSH
96640: LD_INT 1
96642: PLUS
96643: PPUSH
96644: CALL_OW 259
96648: PUSH
96649: LD_INT 10
96651: LESS
96652: IFFALSE 96715
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96654: LD_VAR 0 3
96658: PUSH
96659: LD_VAR 0 1
96663: ARRAY
96664: PPUSH
96665: LD_VAR 0 1
96669: PUSH
96670: LD_INT 4
96672: MOD
96673: PUSH
96674: LD_INT 1
96676: PLUS
96677: PPUSH
96678: LD_VAR 0 3
96682: PUSH
96683: LD_VAR 0 1
96687: ARRAY
96688: PPUSH
96689: LD_VAR 0 1
96693: PUSH
96694: LD_INT 4
96696: MOD
96697: PUSH
96698: LD_INT 1
96700: PLUS
96701: PPUSH
96702: CALL_OW 259
96706: PUSH
96707: LD_INT 1
96709: PLUS
96710: PPUSH
96711: CALL_OW 237
96715: GO 96617
96717: POP
96718: POP
// end ;
96719: PPOPN 3
96721: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96722: LD_EXP 95
96726: PUSH
96727: LD_EXP 103
96731: AND
96732: IFFALSE 96752
96734: GO 96736
96736: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96737: LD_INT 4
96739: PPUSH
96740: LD_OWVAR 2
96744: PPUSH
96745: LD_INT 0
96747: PPUSH
96748: CALL_OW 324
96752: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96753: LD_EXP 95
96757: PUSH
96758: LD_EXP 132
96762: AND
96763: IFFALSE 96783
96765: GO 96767
96767: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96768: LD_INT 19
96770: PPUSH
96771: LD_OWVAR 2
96775: PPUSH
96776: LD_INT 0
96778: PPUSH
96779: CALL_OW 324
96783: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96784: LD_EXP 95
96788: PUSH
96789: LD_EXP 104
96793: AND
96794: IFFALSE 96896
96796: GO 96798
96798: DISABLE
96799: LD_INT 0
96801: PPUSH
96802: PPUSH
// begin enable ;
96803: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96804: LD_ADDR_VAR 0 2
96808: PUSH
96809: LD_INT 22
96811: PUSH
96812: LD_OWVAR 2
96816: PUSH
96817: EMPTY
96818: LIST
96819: LIST
96820: PUSH
96821: LD_INT 2
96823: PUSH
96824: LD_INT 34
96826: PUSH
96827: LD_INT 11
96829: PUSH
96830: EMPTY
96831: LIST
96832: LIST
96833: PUSH
96834: LD_INT 34
96836: PUSH
96837: LD_INT 30
96839: PUSH
96840: EMPTY
96841: LIST
96842: LIST
96843: PUSH
96844: EMPTY
96845: LIST
96846: LIST
96847: LIST
96848: PUSH
96849: EMPTY
96850: LIST
96851: LIST
96852: PPUSH
96853: CALL_OW 69
96857: ST_TO_ADDR
// if not tmp then
96858: LD_VAR 0 2
96862: NOT
96863: IFFALSE 96867
// exit ;
96865: GO 96896
// for i in tmp do
96867: LD_ADDR_VAR 0 1
96871: PUSH
96872: LD_VAR 0 2
96876: PUSH
96877: FOR_IN
96878: IFFALSE 96894
// begin SetLives ( i , 0 ) ;
96880: LD_VAR 0 1
96884: PPUSH
96885: LD_INT 0
96887: PPUSH
96888: CALL_OW 234
// end ;
96892: GO 96877
96894: POP
96895: POP
// end ;
96896: PPOPN 2
96898: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96899: LD_EXP 95
96903: PUSH
96904: LD_EXP 105
96908: AND
96909: IFFALSE 96929
96911: GO 96913
96913: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96914: LD_INT 32
96916: PPUSH
96917: LD_OWVAR 2
96921: PPUSH
96922: LD_INT 0
96924: PPUSH
96925: CALL_OW 324
96929: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96930: LD_EXP 95
96934: PUSH
96935: LD_EXP 106
96939: AND
96940: IFFALSE 97121
96942: GO 96944
96944: DISABLE
96945: LD_INT 0
96947: PPUSH
96948: PPUSH
96949: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96950: LD_ADDR_VAR 0 2
96954: PUSH
96955: LD_INT 22
96957: PUSH
96958: LD_OWVAR 2
96962: PUSH
96963: EMPTY
96964: LIST
96965: LIST
96966: PUSH
96967: LD_INT 33
96969: PUSH
96970: LD_INT 3
96972: PUSH
96973: EMPTY
96974: LIST
96975: LIST
96976: PUSH
96977: EMPTY
96978: LIST
96979: LIST
96980: PPUSH
96981: CALL_OW 69
96985: ST_TO_ADDR
// if not tmp then
96986: LD_VAR 0 2
96990: NOT
96991: IFFALSE 96995
// exit ;
96993: GO 97121
// side := 0 ;
96995: LD_ADDR_VAR 0 3
96999: PUSH
97000: LD_INT 0
97002: ST_TO_ADDR
// for i := 1 to 8 do
97003: LD_ADDR_VAR 0 1
97007: PUSH
97008: DOUBLE
97009: LD_INT 1
97011: DEC
97012: ST_TO_ADDR
97013: LD_INT 8
97015: PUSH
97016: FOR_TO
97017: IFFALSE 97065
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97019: LD_OWVAR 2
97023: PUSH
97024: LD_VAR 0 1
97028: NONEQUAL
97029: PUSH
97030: LD_OWVAR 2
97034: PPUSH
97035: LD_VAR 0 1
97039: PPUSH
97040: CALL_OW 81
97044: PUSH
97045: LD_INT 2
97047: EQUAL
97048: AND
97049: IFFALSE 97063
// begin side := i ;
97051: LD_ADDR_VAR 0 3
97055: PUSH
97056: LD_VAR 0 1
97060: ST_TO_ADDR
// break ;
97061: GO 97065
// end ;
97063: GO 97016
97065: POP
97066: POP
// if not side then
97067: LD_VAR 0 3
97071: NOT
97072: IFFALSE 97076
// exit ;
97074: GO 97121
// for i := 1 to tmp do
97076: LD_ADDR_VAR 0 1
97080: PUSH
97081: DOUBLE
97082: LD_INT 1
97084: DEC
97085: ST_TO_ADDR
97086: LD_VAR 0 2
97090: PUSH
97091: FOR_TO
97092: IFFALSE 97119
// if Prob ( 60 ) then
97094: LD_INT 60
97096: PPUSH
97097: CALL_OW 13
97101: IFFALSE 97117
// SetSide ( i , side ) ;
97103: LD_VAR 0 1
97107: PPUSH
97108: LD_VAR 0 3
97112: PPUSH
97113: CALL_OW 235
97117: GO 97091
97119: POP
97120: POP
// end ;
97121: PPOPN 3
97123: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97124: LD_EXP 95
97128: PUSH
97129: LD_EXP 108
97133: AND
97134: IFFALSE 97253
97136: GO 97138
97138: DISABLE
97139: LD_INT 0
97141: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97142: LD_ADDR_VAR 0 1
97146: PUSH
97147: LD_INT 22
97149: PUSH
97150: LD_OWVAR 2
97154: PUSH
97155: EMPTY
97156: LIST
97157: LIST
97158: PUSH
97159: LD_INT 21
97161: PUSH
97162: LD_INT 1
97164: PUSH
97165: EMPTY
97166: LIST
97167: LIST
97168: PUSH
97169: LD_INT 3
97171: PUSH
97172: LD_INT 23
97174: PUSH
97175: LD_INT 0
97177: PUSH
97178: EMPTY
97179: LIST
97180: LIST
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: PUSH
97186: EMPTY
97187: LIST
97188: LIST
97189: LIST
97190: PPUSH
97191: CALL_OW 69
97195: PUSH
97196: FOR_IN
97197: IFFALSE 97251
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97199: LD_VAR 0 1
97203: PPUSH
97204: CALL_OW 257
97208: PUSH
97209: LD_INT 1
97211: PUSH
97212: LD_INT 2
97214: PUSH
97215: LD_INT 3
97217: PUSH
97218: LD_INT 4
97220: PUSH
97221: EMPTY
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: IN
97227: IFFALSE 97249
// SetClass ( un , rand ( 1 , 4 ) ) ;
97229: LD_VAR 0 1
97233: PPUSH
97234: LD_INT 1
97236: PPUSH
97237: LD_INT 4
97239: PPUSH
97240: CALL_OW 12
97244: PPUSH
97245: CALL_OW 336
97249: GO 97196
97251: POP
97252: POP
// end ;
97253: PPOPN 1
97255: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97256: LD_EXP 95
97260: PUSH
97261: LD_EXP 107
97265: AND
97266: IFFALSE 97345
97268: GO 97270
97270: DISABLE
97271: LD_INT 0
97273: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97274: LD_ADDR_VAR 0 1
97278: PUSH
97279: LD_INT 22
97281: PUSH
97282: LD_OWVAR 2
97286: PUSH
97287: EMPTY
97288: LIST
97289: LIST
97290: PUSH
97291: LD_INT 21
97293: PUSH
97294: LD_INT 3
97296: PUSH
97297: EMPTY
97298: LIST
97299: LIST
97300: PUSH
97301: EMPTY
97302: LIST
97303: LIST
97304: PPUSH
97305: CALL_OW 69
97309: ST_TO_ADDR
// if not tmp then
97310: LD_VAR 0 1
97314: NOT
97315: IFFALSE 97319
// exit ;
97317: GO 97345
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97319: LD_VAR 0 1
97323: PUSH
97324: LD_INT 1
97326: PPUSH
97327: LD_VAR 0 1
97331: PPUSH
97332: CALL_OW 12
97336: ARRAY
97337: PPUSH
97338: LD_INT 100
97340: PPUSH
97341: CALL_OW 234
// end ;
97345: PPOPN 1
97347: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97348: LD_EXP 95
97352: PUSH
97353: LD_EXP 109
97357: AND
97358: IFFALSE 97456
97360: GO 97362
97362: DISABLE
97363: LD_INT 0
97365: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97366: LD_ADDR_VAR 0 1
97370: PUSH
97371: LD_INT 22
97373: PUSH
97374: LD_OWVAR 2
97378: PUSH
97379: EMPTY
97380: LIST
97381: LIST
97382: PUSH
97383: LD_INT 21
97385: PUSH
97386: LD_INT 1
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: PUSH
97393: EMPTY
97394: LIST
97395: LIST
97396: PPUSH
97397: CALL_OW 69
97401: ST_TO_ADDR
// if not tmp then
97402: LD_VAR 0 1
97406: NOT
97407: IFFALSE 97411
// exit ;
97409: GO 97456
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97411: LD_VAR 0 1
97415: PUSH
97416: LD_INT 1
97418: PPUSH
97419: LD_VAR 0 1
97423: PPUSH
97424: CALL_OW 12
97428: ARRAY
97429: PPUSH
97430: LD_INT 1
97432: PPUSH
97433: LD_INT 4
97435: PPUSH
97436: CALL_OW 12
97440: PPUSH
97441: LD_INT 3000
97443: PPUSH
97444: LD_INT 9000
97446: PPUSH
97447: CALL_OW 12
97451: PPUSH
97452: CALL_OW 492
// end ;
97456: PPOPN 1
97458: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97459: LD_EXP 95
97463: PUSH
97464: LD_EXP 110
97468: AND
97469: IFFALSE 97489
97471: GO 97473
97473: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97474: LD_INT 1
97476: PPUSH
97477: LD_OWVAR 2
97481: PPUSH
97482: LD_INT 0
97484: PPUSH
97485: CALL_OW 324
97489: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97490: LD_EXP 95
97494: PUSH
97495: LD_EXP 111
97499: AND
97500: IFFALSE 97583
97502: GO 97504
97504: DISABLE
97505: LD_INT 0
97507: PPUSH
97508: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97509: LD_ADDR_VAR 0 2
97513: PUSH
97514: LD_INT 22
97516: PUSH
97517: LD_OWVAR 2
97521: PUSH
97522: EMPTY
97523: LIST
97524: LIST
97525: PUSH
97526: LD_INT 21
97528: PUSH
97529: LD_INT 3
97531: PUSH
97532: EMPTY
97533: LIST
97534: LIST
97535: PUSH
97536: EMPTY
97537: LIST
97538: LIST
97539: PPUSH
97540: CALL_OW 69
97544: ST_TO_ADDR
// if not tmp then
97545: LD_VAR 0 2
97549: NOT
97550: IFFALSE 97554
// exit ;
97552: GO 97583
// for i in tmp do
97554: LD_ADDR_VAR 0 1
97558: PUSH
97559: LD_VAR 0 2
97563: PUSH
97564: FOR_IN
97565: IFFALSE 97581
// SetBLevel ( i , 10 ) ;
97567: LD_VAR 0 1
97571: PPUSH
97572: LD_INT 10
97574: PPUSH
97575: CALL_OW 241
97579: GO 97564
97581: POP
97582: POP
// end ;
97583: PPOPN 2
97585: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97586: LD_EXP 95
97590: PUSH
97591: LD_EXP 112
97595: AND
97596: IFFALSE 97707
97598: GO 97600
97600: DISABLE
97601: LD_INT 0
97603: PPUSH
97604: PPUSH
97605: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97606: LD_ADDR_VAR 0 3
97610: PUSH
97611: LD_INT 22
97613: PUSH
97614: LD_OWVAR 2
97618: PUSH
97619: EMPTY
97620: LIST
97621: LIST
97622: PUSH
97623: LD_INT 25
97625: PUSH
97626: LD_INT 1
97628: PUSH
97629: EMPTY
97630: LIST
97631: LIST
97632: PUSH
97633: EMPTY
97634: LIST
97635: LIST
97636: PPUSH
97637: CALL_OW 69
97641: ST_TO_ADDR
// if not tmp then
97642: LD_VAR 0 3
97646: NOT
97647: IFFALSE 97651
// exit ;
97649: GO 97707
// un := tmp [ rand ( 1 , tmp ) ] ;
97651: LD_ADDR_VAR 0 2
97655: PUSH
97656: LD_VAR 0 3
97660: PUSH
97661: LD_INT 1
97663: PPUSH
97664: LD_VAR 0 3
97668: PPUSH
97669: CALL_OW 12
97673: ARRAY
97674: ST_TO_ADDR
// if Crawls ( un ) then
97675: LD_VAR 0 2
97679: PPUSH
97680: CALL_OW 318
97684: IFFALSE 97695
// ComWalk ( un ) ;
97686: LD_VAR 0 2
97690: PPUSH
97691: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97695: LD_VAR 0 2
97699: PPUSH
97700: LD_INT 5
97702: PPUSH
97703: CALL_OW 336
// end ;
97707: PPOPN 3
97709: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97710: LD_EXP 95
97714: PUSH
97715: LD_EXP 113
97719: AND
97720: PUSH
97721: LD_OWVAR 67
97725: PUSH
97726: LD_INT 4
97728: LESS
97729: AND
97730: IFFALSE 97749
97732: GO 97734
97734: DISABLE
// begin Difficulty := Difficulty + 1 ;
97735: LD_ADDR_OWVAR 67
97739: PUSH
97740: LD_OWVAR 67
97744: PUSH
97745: LD_INT 1
97747: PLUS
97748: ST_TO_ADDR
// end ;
97749: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97750: LD_EXP 95
97754: PUSH
97755: LD_EXP 114
97759: AND
97760: IFFALSE 97863
97762: GO 97764
97764: DISABLE
97765: LD_INT 0
97767: PPUSH
// begin for i := 1 to 5 do
97768: LD_ADDR_VAR 0 1
97772: PUSH
97773: DOUBLE
97774: LD_INT 1
97776: DEC
97777: ST_TO_ADDR
97778: LD_INT 5
97780: PUSH
97781: FOR_TO
97782: IFFALSE 97861
// begin uc_nation := nation_nature ;
97784: LD_ADDR_OWVAR 21
97788: PUSH
97789: LD_INT 0
97791: ST_TO_ADDR
// uc_side := 0 ;
97792: LD_ADDR_OWVAR 20
97796: PUSH
97797: LD_INT 0
97799: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97800: LD_ADDR_OWVAR 29
97804: PUSH
97805: LD_INT 12
97807: PUSH
97808: LD_INT 12
97810: PUSH
97811: EMPTY
97812: LIST
97813: LIST
97814: ST_TO_ADDR
// hc_agressivity := 20 ;
97815: LD_ADDR_OWVAR 35
97819: PUSH
97820: LD_INT 20
97822: ST_TO_ADDR
// hc_class := class_tiger ;
97823: LD_ADDR_OWVAR 28
97827: PUSH
97828: LD_INT 14
97830: ST_TO_ADDR
// hc_gallery :=  ;
97831: LD_ADDR_OWVAR 33
97835: PUSH
97836: LD_STRING 
97838: ST_TO_ADDR
// hc_name :=  ;
97839: LD_ADDR_OWVAR 26
97843: PUSH
97844: LD_STRING 
97846: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97847: CALL_OW 44
97851: PPUSH
97852: LD_INT 0
97854: PPUSH
97855: CALL_OW 51
// end ;
97859: GO 97781
97861: POP
97862: POP
// end ;
97863: PPOPN 1
97865: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97866: LD_EXP 95
97870: PUSH
97871: LD_EXP 115
97875: AND
97876: IFFALSE 97885
97878: GO 97880
97880: DISABLE
// StreamSibBomb ;
97881: CALL 97886 0 0
97885: END
// export function StreamSibBomb ; var i , x , y ; begin
97886: LD_INT 0
97888: PPUSH
97889: PPUSH
97890: PPUSH
97891: PPUSH
// result := false ;
97892: LD_ADDR_VAR 0 1
97896: PUSH
97897: LD_INT 0
97899: ST_TO_ADDR
// for i := 1 to 16 do
97900: LD_ADDR_VAR 0 2
97904: PUSH
97905: DOUBLE
97906: LD_INT 1
97908: DEC
97909: ST_TO_ADDR
97910: LD_INT 16
97912: PUSH
97913: FOR_TO
97914: IFFALSE 98113
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97916: LD_ADDR_VAR 0 3
97920: PUSH
97921: LD_INT 10
97923: PUSH
97924: LD_INT 20
97926: PUSH
97927: LD_INT 30
97929: PUSH
97930: LD_INT 40
97932: PUSH
97933: LD_INT 50
97935: PUSH
97936: LD_INT 60
97938: PUSH
97939: LD_INT 70
97941: PUSH
97942: LD_INT 80
97944: PUSH
97945: LD_INT 90
97947: PUSH
97948: LD_INT 100
97950: PUSH
97951: LD_INT 110
97953: PUSH
97954: LD_INT 120
97956: PUSH
97957: LD_INT 130
97959: PUSH
97960: LD_INT 140
97962: PUSH
97963: LD_INT 150
97965: PUSH
97966: EMPTY
97967: LIST
97968: LIST
97969: LIST
97970: LIST
97971: LIST
97972: LIST
97973: LIST
97974: LIST
97975: LIST
97976: LIST
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: LIST
97982: PUSH
97983: LD_INT 1
97985: PPUSH
97986: LD_INT 15
97988: PPUSH
97989: CALL_OW 12
97993: ARRAY
97994: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97995: LD_ADDR_VAR 0 4
97999: PUSH
98000: LD_INT 10
98002: PUSH
98003: LD_INT 20
98005: PUSH
98006: LD_INT 30
98008: PUSH
98009: LD_INT 40
98011: PUSH
98012: LD_INT 50
98014: PUSH
98015: LD_INT 60
98017: PUSH
98018: LD_INT 70
98020: PUSH
98021: LD_INT 80
98023: PUSH
98024: LD_INT 90
98026: PUSH
98027: LD_INT 100
98029: PUSH
98030: LD_INT 110
98032: PUSH
98033: LD_INT 120
98035: PUSH
98036: LD_INT 130
98038: PUSH
98039: LD_INT 140
98041: PUSH
98042: LD_INT 150
98044: PUSH
98045: EMPTY
98046: LIST
98047: LIST
98048: LIST
98049: LIST
98050: LIST
98051: LIST
98052: LIST
98053: LIST
98054: LIST
98055: LIST
98056: LIST
98057: LIST
98058: LIST
98059: LIST
98060: LIST
98061: PUSH
98062: LD_INT 1
98064: PPUSH
98065: LD_INT 15
98067: PPUSH
98068: CALL_OW 12
98072: ARRAY
98073: ST_TO_ADDR
// if ValidHex ( x , y ) then
98074: LD_VAR 0 3
98078: PPUSH
98079: LD_VAR 0 4
98083: PPUSH
98084: CALL_OW 488
98088: IFFALSE 98111
// begin result := [ x , y ] ;
98090: LD_ADDR_VAR 0 1
98094: PUSH
98095: LD_VAR 0 3
98099: PUSH
98100: LD_VAR 0 4
98104: PUSH
98105: EMPTY
98106: LIST
98107: LIST
98108: ST_TO_ADDR
// break ;
98109: GO 98113
// end ; end ;
98111: GO 97913
98113: POP
98114: POP
// if result then
98115: LD_VAR 0 1
98119: IFFALSE 98179
// begin ToLua ( playSibBomb() ) ;
98121: LD_STRING playSibBomb()
98123: PPUSH
98124: CALL_OW 559
// wait ( 0 0$14 ) ;
98128: LD_INT 490
98130: PPUSH
98131: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98135: LD_VAR 0 1
98139: PUSH
98140: LD_INT 1
98142: ARRAY
98143: PPUSH
98144: LD_VAR 0 1
98148: PUSH
98149: LD_INT 2
98151: ARRAY
98152: PPUSH
98153: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98157: LD_VAR 0 1
98161: PUSH
98162: LD_INT 1
98164: ARRAY
98165: PPUSH
98166: LD_VAR 0 1
98170: PUSH
98171: LD_INT 2
98173: ARRAY
98174: PPUSH
98175: CALL_OW 429
// end ; end ;
98179: LD_VAR 0 1
98183: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98184: LD_EXP 95
98188: PUSH
98189: LD_EXP 117
98193: AND
98194: IFFALSE 98206
98196: GO 98198
98198: DISABLE
// YouLost (  ) ;
98199: LD_STRING 
98201: PPUSH
98202: CALL_OW 104
98206: END
// every 0 0$1 trigger StreamModeActive and sFog do
98207: LD_EXP 95
98211: PUSH
98212: LD_EXP 116
98216: AND
98217: IFFALSE 98231
98219: GO 98221
98221: DISABLE
// FogOff ( your_side ) ;
98222: LD_OWVAR 2
98226: PPUSH
98227: CALL_OW 344
98231: END
// every 0 0$1 trigger StreamModeActive and sSun do
98232: LD_EXP 95
98236: PUSH
98237: LD_EXP 118
98241: AND
98242: IFFALSE 98270
98244: GO 98246
98246: DISABLE
// begin solar_recharge_percent := 0 ;
98247: LD_ADDR_OWVAR 79
98251: PUSH
98252: LD_INT 0
98254: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98255: LD_INT 10500
98257: PPUSH
98258: CALL_OW 67
// solar_recharge_percent := 100 ;
98262: LD_ADDR_OWVAR 79
98266: PUSH
98267: LD_INT 100
98269: ST_TO_ADDR
// end ;
98270: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98271: LD_EXP 95
98275: PUSH
98276: LD_EXP 119
98280: AND
98281: IFFALSE 98520
98283: GO 98285
98285: DISABLE
98286: LD_INT 0
98288: PPUSH
98289: PPUSH
98290: PPUSH
// begin tmp := [ ] ;
98291: LD_ADDR_VAR 0 3
98295: PUSH
98296: EMPTY
98297: ST_TO_ADDR
// for i := 1 to 6 do
98298: LD_ADDR_VAR 0 1
98302: PUSH
98303: DOUBLE
98304: LD_INT 1
98306: DEC
98307: ST_TO_ADDR
98308: LD_INT 6
98310: PUSH
98311: FOR_TO
98312: IFFALSE 98417
// begin uc_nation := nation_nature ;
98314: LD_ADDR_OWVAR 21
98318: PUSH
98319: LD_INT 0
98321: ST_TO_ADDR
// uc_side := 0 ;
98322: LD_ADDR_OWVAR 20
98326: PUSH
98327: LD_INT 0
98329: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98330: LD_ADDR_OWVAR 29
98334: PUSH
98335: LD_INT 12
98337: PUSH
98338: LD_INT 12
98340: PUSH
98341: EMPTY
98342: LIST
98343: LIST
98344: ST_TO_ADDR
// hc_agressivity := 20 ;
98345: LD_ADDR_OWVAR 35
98349: PUSH
98350: LD_INT 20
98352: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98353: LD_ADDR_OWVAR 28
98357: PUSH
98358: LD_INT 17
98360: ST_TO_ADDR
// hc_gallery :=  ;
98361: LD_ADDR_OWVAR 33
98365: PUSH
98366: LD_STRING 
98368: ST_TO_ADDR
// hc_name :=  ;
98369: LD_ADDR_OWVAR 26
98373: PUSH
98374: LD_STRING 
98376: ST_TO_ADDR
// un := CreateHuman ;
98377: LD_ADDR_VAR 0 2
98381: PUSH
98382: CALL_OW 44
98386: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98387: LD_VAR 0 2
98391: PPUSH
98392: LD_INT 1
98394: PPUSH
98395: CALL_OW 51
// tmp := tmp ^ un ;
98399: LD_ADDR_VAR 0 3
98403: PUSH
98404: LD_VAR 0 3
98408: PUSH
98409: LD_VAR 0 2
98413: ADD
98414: ST_TO_ADDR
// end ;
98415: GO 98311
98417: POP
98418: POP
// repeat wait ( 0 0$1 ) ;
98419: LD_INT 35
98421: PPUSH
98422: CALL_OW 67
// for un in tmp do
98426: LD_ADDR_VAR 0 2
98430: PUSH
98431: LD_VAR 0 3
98435: PUSH
98436: FOR_IN
98437: IFFALSE 98511
// begin if IsDead ( un ) then
98439: LD_VAR 0 2
98443: PPUSH
98444: CALL_OW 301
98448: IFFALSE 98468
// begin tmp := tmp diff un ;
98450: LD_ADDR_VAR 0 3
98454: PUSH
98455: LD_VAR 0 3
98459: PUSH
98460: LD_VAR 0 2
98464: DIFF
98465: ST_TO_ADDR
// continue ;
98466: GO 98436
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98468: LD_VAR 0 2
98472: PPUSH
98473: LD_INT 3
98475: PUSH
98476: LD_INT 22
98478: PUSH
98479: LD_INT 0
98481: PUSH
98482: EMPTY
98483: LIST
98484: LIST
98485: PUSH
98486: EMPTY
98487: LIST
98488: LIST
98489: PPUSH
98490: CALL_OW 69
98494: PPUSH
98495: LD_VAR 0 2
98499: PPUSH
98500: CALL_OW 74
98504: PPUSH
98505: CALL_OW 115
// end ;
98509: GO 98436
98511: POP
98512: POP
// until not tmp ;
98513: LD_VAR 0 3
98517: NOT
98518: IFFALSE 98419
// end ;
98520: PPOPN 3
98522: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98523: LD_EXP 95
98527: PUSH
98528: LD_EXP 120
98532: AND
98533: IFFALSE 98587
98535: GO 98537
98537: DISABLE
// begin ToLua ( displayTroll(); ) ;
98538: LD_STRING displayTroll();
98540: PPUSH
98541: CALL_OW 559
// wait ( 3 3$00 ) ;
98545: LD_INT 6300
98547: PPUSH
98548: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98552: LD_STRING hideTroll();
98554: PPUSH
98555: CALL_OW 559
// wait ( 1 1$00 ) ;
98559: LD_INT 2100
98561: PPUSH
98562: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98566: LD_STRING displayTroll();
98568: PPUSH
98569: CALL_OW 559
// wait ( 1 1$00 ) ;
98573: LD_INT 2100
98575: PPUSH
98576: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98580: LD_STRING hideTroll();
98582: PPUSH
98583: CALL_OW 559
// end ;
98587: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98588: LD_EXP 95
98592: PUSH
98593: LD_EXP 121
98597: AND
98598: IFFALSE 98661
98600: GO 98602
98602: DISABLE
98603: LD_INT 0
98605: PPUSH
// begin p := 0 ;
98606: LD_ADDR_VAR 0 1
98610: PUSH
98611: LD_INT 0
98613: ST_TO_ADDR
// repeat game_speed := 1 ;
98614: LD_ADDR_OWVAR 65
98618: PUSH
98619: LD_INT 1
98621: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98622: LD_INT 35
98624: PPUSH
98625: CALL_OW 67
// p := p + 1 ;
98629: LD_ADDR_VAR 0 1
98633: PUSH
98634: LD_VAR 0 1
98638: PUSH
98639: LD_INT 1
98641: PLUS
98642: ST_TO_ADDR
// until p >= 60 ;
98643: LD_VAR 0 1
98647: PUSH
98648: LD_INT 60
98650: GREATEREQUAL
98651: IFFALSE 98614
// game_speed := 4 ;
98653: LD_ADDR_OWVAR 65
98657: PUSH
98658: LD_INT 4
98660: ST_TO_ADDR
// end ;
98661: PPOPN 1
98663: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98664: LD_EXP 95
98668: PUSH
98669: LD_EXP 122
98673: AND
98674: IFFALSE 98820
98676: GO 98678
98678: DISABLE
98679: LD_INT 0
98681: PPUSH
98682: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98683: LD_ADDR_VAR 0 1
98687: PUSH
98688: LD_INT 22
98690: PUSH
98691: LD_OWVAR 2
98695: PUSH
98696: EMPTY
98697: LIST
98698: LIST
98699: PUSH
98700: LD_INT 2
98702: PUSH
98703: LD_INT 30
98705: PUSH
98706: LD_INT 0
98708: PUSH
98709: EMPTY
98710: LIST
98711: LIST
98712: PUSH
98713: LD_INT 30
98715: PUSH
98716: LD_INT 1
98718: PUSH
98719: EMPTY
98720: LIST
98721: LIST
98722: PUSH
98723: EMPTY
98724: LIST
98725: LIST
98726: LIST
98727: PUSH
98728: EMPTY
98729: LIST
98730: LIST
98731: PPUSH
98732: CALL_OW 69
98736: ST_TO_ADDR
// if not depot then
98737: LD_VAR 0 1
98741: NOT
98742: IFFALSE 98746
// exit ;
98744: GO 98820
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98746: LD_ADDR_VAR 0 2
98750: PUSH
98751: LD_VAR 0 1
98755: PUSH
98756: LD_INT 1
98758: PPUSH
98759: LD_VAR 0 1
98763: PPUSH
98764: CALL_OW 12
98768: ARRAY
98769: PPUSH
98770: CALL_OW 274
98774: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98775: LD_VAR 0 2
98779: PPUSH
98780: LD_INT 1
98782: PPUSH
98783: LD_INT 0
98785: PPUSH
98786: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98790: LD_VAR 0 2
98794: PPUSH
98795: LD_INT 2
98797: PPUSH
98798: LD_INT 0
98800: PPUSH
98801: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98805: LD_VAR 0 2
98809: PPUSH
98810: LD_INT 3
98812: PPUSH
98813: LD_INT 0
98815: PPUSH
98816: CALL_OW 277
// end ;
98820: PPOPN 2
98822: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98823: LD_EXP 95
98827: PUSH
98828: LD_EXP 123
98832: AND
98833: IFFALSE 98930
98835: GO 98837
98837: DISABLE
98838: LD_INT 0
98840: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98841: LD_ADDR_VAR 0 1
98845: PUSH
98846: LD_INT 22
98848: PUSH
98849: LD_OWVAR 2
98853: PUSH
98854: EMPTY
98855: LIST
98856: LIST
98857: PUSH
98858: LD_INT 21
98860: PUSH
98861: LD_INT 1
98863: PUSH
98864: EMPTY
98865: LIST
98866: LIST
98867: PUSH
98868: LD_INT 3
98870: PUSH
98871: LD_INT 23
98873: PUSH
98874: LD_INT 0
98876: PUSH
98877: EMPTY
98878: LIST
98879: LIST
98880: PUSH
98881: EMPTY
98882: LIST
98883: LIST
98884: PUSH
98885: EMPTY
98886: LIST
98887: LIST
98888: LIST
98889: PPUSH
98890: CALL_OW 69
98894: ST_TO_ADDR
// if not tmp then
98895: LD_VAR 0 1
98899: NOT
98900: IFFALSE 98904
// exit ;
98902: GO 98930
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98904: LD_VAR 0 1
98908: PUSH
98909: LD_INT 1
98911: PPUSH
98912: LD_VAR 0 1
98916: PPUSH
98917: CALL_OW 12
98921: ARRAY
98922: PPUSH
98923: LD_INT 200
98925: PPUSH
98926: CALL_OW 234
// end ;
98930: PPOPN 1
98932: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98933: LD_EXP 95
98937: PUSH
98938: LD_EXP 124
98942: AND
98943: IFFALSE 99022
98945: GO 98947
98947: DISABLE
98948: LD_INT 0
98950: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98951: LD_ADDR_VAR 0 1
98955: PUSH
98956: LD_INT 22
98958: PUSH
98959: LD_OWVAR 2
98963: PUSH
98964: EMPTY
98965: LIST
98966: LIST
98967: PUSH
98968: LD_INT 21
98970: PUSH
98971: LD_INT 2
98973: PUSH
98974: EMPTY
98975: LIST
98976: LIST
98977: PUSH
98978: EMPTY
98979: LIST
98980: LIST
98981: PPUSH
98982: CALL_OW 69
98986: ST_TO_ADDR
// if not tmp then
98987: LD_VAR 0 1
98991: NOT
98992: IFFALSE 98996
// exit ;
98994: GO 99022
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98996: LD_VAR 0 1
99000: PUSH
99001: LD_INT 1
99003: PPUSH
99004: LD_VAR 0 1
99008: PPUSH
99009: CALL_OW 12
99013: ARRAY
99014: PPUSH
99015: LD_INT 60
99017: PPUSH
99018: CALL_OW 234
// end ;
99022: PPOPN 1
99024: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99025: LD_EXP 95
99029: PUSH
99030: LD_EXP 125
99034: AND
99035: IFFALSE 99134
99037: GO 99039
99039: DISABLE
99040: LD_INT 0
99042: PPUSH
99043: PPUSH
// begin enable ;
99044: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99045: LD_ADDR_VAR 0 1
99049: PUSH
99050: LD_INT 22
99052: PUSH
99053: LD_OWVAR 2
99057: PUSH
99058: EMPTY
99059: LIST
99060: LIST
99061: PUSH
99062: LD_INT 61
99064: PUSH
99065: EMPTY
99066: LIST
99067: PUSH
99068: LD_INT 33
99070: PUSH
99071: LD_INT 2
99073: PUSH
99074: EMPTY
99075: LIST
99076: LIST
99077: PUSH
99078: EMPTY
99079: LIST
99080: LIST
99081: LIST
99082: PPUSH
99083: CALL_OW 69
99087: ST_TO_ADDR
// if not tmp then
99088: LD_VAR 0 1
99092: NOT
99093: IFFALSE 99097
// exit ;
99095: GO 99134
// for i in tmp do
99097: LD_ADDR_VAR 0 2
99101: PUSH
99102: LD_VAR 0 1
99106: PUSH
99107: FOR_IN
99108: IFFALSE 99132
// if IsControledBy ( i ) then
99110: LD_VAR 0 2
99114: PPUSH
99115: CALL_OW 312
99119: IFFALSE 99130
// ComUnlink ( i ) ;
99121: LD_VAR 0 2
99125: PPUSH
99126: CALL_OW 136
99130: GO 99107
99132: POP
99133: POP
// end ;
99134: PPOPN 2
99136: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99137: LD_EXP 95
99141: PUSH
99142: LD_EXP 126
99146: AND
99147: IFFALSE 99287
99149: GO 99151
99151: DISABLE
99152: LD_INT 0
99154: PPUSH
99155: PPUSH
// begin ToLua ( displayPowell(); ) ;
99156: LD_STRING displayPowell();
99158: PPUSH
99159: CALL_OW 559
// uc_side := 0 ;
99163: LD_ADDR_OWVAR 20
99167: PUSH
99168: LD_INT 0
99170: ST_TO_ADDR
// uc_nation := 2 ;
99171: LD_ADDR_OWVAR 21
99175: PUSH
99176: LD_INT 2
99178: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99179: LD_ADDR_OWVAR 37
99183: PUSH
99184: LD_INT 14
99186: ST_TO_ADDR
// vc_engine := engine_siberite ;
99187: LD_ADDR_OWVAR 39
99191: PUSH
99192: LD_INT 3
99194: ST_TO_ADDR
// vc_control := control_apeman ;
99195: LD_ADDR_OWVAR 38
99199: PUSH
99200: LD_INT 5
99202: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99203: LD_ADDR_OWVAR 40
99207: PUSH
99208: LD_INT 29
99210: ST_TO_ADDR
// un := CreateVehicle ;
99211: LD_ADDR_VAR 0 2
99215: PUSH
99216: CALL_OW 45
99220: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99221: LD_VAR 0 2
99225: PPUSH
99226: LD_INT 1
99228: PPUSH
99229: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99233: LD_INT 35
99235: PPUSH
99236: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99240: LD_VAR 0 2
99244: PPUSH
99245: LD_INT 22
99247: PUSH
99248: LD_OWVAR 2
99252: PUSH
99253: EMPTY
99254: LIST
99255: LIST
99256: PPUSH
99257: CALL_OW 69
99261: PPUSH
99262: LD_VAR 0 2
99266: PPUSH
99267: CALL_OW 74
99271: PPUSH
99272: CALL_OW 115
// until IsDead ( un ) ;
99276: LD_VAR 0 2
99280: PPUSH
99281: CALL_OW 301
99285: IFFALSE 99233
// end ;
99287: PPOPN 2
99289: END
// every 0 0$1 trigger StreamModeActive and sStu do
99290: LD_EXP 95
99294: PUSH
99295: LD_EXP 134
99299: AND
99300: IFFALSE 99316
99302: GO 99304
99304: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99305: LD_STRING displayStucuk();
99307: PPUSH
99308: CALL_OW 559
// ResetFog ;
99312: CALL_OW 335
// end ;
99316: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99317: LD_EXP 95
99321: PUSH
99322: LD_EXP 127
99326: AND
99327: IFFALSE 99468
99329: GO 99331
99331: DISABLE
99332: LD_INT 0
99334: PPUSH
99335: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99336: LD_ADDR_VAR 0 2
99340: PUSH
99341: LD_INT 22
99343: PUSH
99344: LD_OWVAR 2
99348: PUSH
99349: EMPTY
99350: LIST
99351: LIST
99352: PUSH
99353: LD_INT 21
99355: PUSH
99356: LD_INT 1
99358: PUSH
99359: EMPTY
99360: LIST
99361: LIST
99362: PUSH
99363: EMPTY
99364: LIST
99365: LIST
99366: PPUSH
99367: CALL_OW 69
99371: ST_TO_ADDR
// if not tmp then
99372: LD_VAR 0 2
99376: NOT
99377: IFFALSE 99381
// exit ;
99379: GO 99468
// un := tmp [ rand ( 1 , tmp ) ] ;
99381: LD_ADDR_VAR 0 1
99385: PUSH
99386: LD_VAR 0 2
99390: PUSH
99391: LD_INT 1
99393: PPUSH
99394: LD_VAR 0 2
99398: PPUSH
99399: CALL_OW 12
99403: ARRAY
99404: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99405: LD_VAR 0 1
99409: PPUSH
99410: LD_INT 0
99412: PPUSH
99413: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99417: LD_VAR 0 1
99421: PPUSH
99422: LD_OWVAR 3
99426: PUSH
99427: LD_VAR 0 1
99431: DIFF
99432: PPUSH
99433: LD_VAR 0 1
99437: PPUSH
99438: CALL_OW 74
99442: PPUSH
99443: CALL_OW 115
// wait ( 0 0$20 ) ;
99447: LD_INT 700
99449: PPUSH
99450: CALL_OW 67
// SetSide ( un , your_side ) ;
99454: LD_VAR 0 1
99458: PPUSH
99459: LD_OWVAR 2
99463: PPUSH
99464: CALL_OW 235
// end ;
99468: PPOPN 2
99470: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99471: LD_EXP 95
99475: PUSH
99476: LD_EXP 128
99480: AND
99481: IFFALSE 99587
99483: GO 99485
99485: DISABLE
99486: LD_INT 0
99488: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99489: LD_ADDR_VAR 0 1
99493: PUSH
99494: LD_INT 22
99496: PUSH
99497: LD_OWVAR 2
99501: PUSH
99502: EMPTY
99503: LIST
99504: LIST
99505: PUSH
99506: LD_INT 2
99508: PUSH
99509: LD_INT 30
99511: PUSH
99512: LD_INT 0
99514: PUSH
99515: EMPTY
99516: LIST
99517: LIST
99518: PUSH
99519: LD_INT 30
99521: PUSH
99522: LD_INT 1
99524: PUSH
99525: EMPTY
99526: LIST
99527: LIST
99528: PUSH
99529: EMPTY
99530: LIST
99531: LIST
99532: LIST
99533: PUSH
99534: EMPTY
99535: LIST
99536: LIST
99537: PPUSH
99538: CALL_OW 69
99542: ST_TO_ADDR
// if not depot then
99543: LD_VAR 0 1
99547: NOT
99548: IFFALSE 99552
// exit ;
99550: GO 99587
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99552: LD_VAR 0 1
99556: PUSH
99557: LD_INT 1
99559: ARRAY
99560: PPUSH
99561: CALL_OW 250
99565: PPUSH
99566: LD_VAR 0 1
99570: PUSH
99571: LD_INT 1
99573: ARRAY
99574: PPUSH
99575: CALL_OW 251
99579: PPUSH
99580: LD_INT 70
99582: PPUSH
99583: CALL_OW 495
// end ;
99587: PPOPN 1
99589: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99590: LD_EXP 95
99594: PUSH
99595: LD_EXP 129
99599: AND
99600: IFFALSE 99811
99602: GO 99604
99604: DISABLE
99605: LD_INT 0
99607: PPUSH
99608: PPUSH
99609: PPUSH
99610: PPUSH
99611: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99612: LD_ADDR_VAR 0 5
99616: PUSH
99617: LD_INT 22
99619: PUSH
99620: LD_OWVAR 2
99624: PUSH
99625: EMPTY
99626: LIST
99627: LIST
99628: PUSH
99629: LD_INT 21
99631: PUSH
99632: LD_INT 1
99634: PUSH
99635: EMPTY
99636: LIST
99637: LIST
99638: PUSH
99639: EMPTY
99640: LIST
99641: LIST
99642: PPUSH
99643: CALL_OW 69
99647: ST_TO_ADDR
// if not tmp then
99648: LD_VAR 0 5
99652: NOT
99653: IFFALSE 99657
// exit ;
99655: GO 99811
// for i in tmp do
99657: LD_ADDR_VAR 0 1
99661: PUSH
99662: LD_VAR 0 5
99666: PUSH
99667: FOR_IN
99668: IFFALSE 99809
// begin d := rand ( 0 , 5 ) ;
99670: LD_ADDR_VAR 0 4
99674: PUSH
99675: LD_INT 0
99677: PPUSH
99678: LD_INT 5
99680: PPUSH
99681: CALL_OW 12
99685: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99686: LD_ADDR_VAR 0 2
99690: PUSH
99691: LD_VAR 0 1
99695: PPUSH
99696: CALL_OW 250
99700: PPUSH
99701: LD_VAR 0 4
99705: PPUSH
99706: LD_INT 3
99708: PPUSH
99709: LD_INT 12
99711: PPUSH
99712: CALL_OW 12
99716: PPUSH
99717: CALL_OW 272
99721: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99722: LD_ADDR_VAR 0 3
99726: PUSH
99727: LD_VAR 0 1
99731: PPUSH
99732: CALL_OW 251
99736: PPUSH
99737: LD_VAR 0 4
99741: PPUSH
99742: LD_INT 3
99744: PPUSH
99745: LD_INT 12
99747: PPUSH
99748: CALL_OW 12
99752: PPUSH
99753: CALL_OW 273
99757: ST_TO_ADDR
// if ValidHex ( x , y ) then
99758: LD_VAR 0 2
99762: PPUSH
99763: LD_VAR 0 3
99767: PPUSH
99768: CALL_OW 488
99772: IFFALSE 99807
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99774: LD_VAR 0 1
99778: PPUSH
99779: LD_VAR 0 2
99783: PPUSH
99784: LD_VAR 0 3
99788: PPUSH
99789: LD_INT 3
99791: PPUSH
99792: LD_INT 6
99794: PPUSH
99795: CALL_OW 12
99799: PPUSH
99800: LD_INT 1
99802: PPUSH
99803: CALL_OW 483
// end ;
99807: GO 99667
99809: POP
99810: POP
// end ;
99811: PPOPN 5
99813: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99814: LD_EXP 95
99818: PUSH
99819: LD_EXP 130
99823: AND
99824: IFFALSE 99918
99826: GO 99828
99828: DISABLE
99829: LD_INT 0
99831: PPUSH
99832: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99833: LD_ADDR_VAR 0 2
99837: PUSH
99838: LD_INT 22
99840: PUSH
99841: LD_OWVAR 2
99845: PUSH
99846: EMPTY
99847: LIST
99848: LIST
99849: PUSH
99850: LD_INT 32
99852: PUSH
99853: LD_INT 1
99855: PUSH
99856: EMPTY
99857: LIST
99858: LIST
99859: PUSH
99860: LD_INT 21
99862: PUSH
99863: LD_INT 2
99865: PUSH
99866: EMPTY
99867: LIST
99868: LIST
99869: PUSH
99870: EMPTY
99871: LIST
99872: LIST
99873: LIST
99874: PPUSH
99875: CALL_OW 69
99879: ST_TO_ADDR
// if not tmp then
99880: LD_VAR 0 2
99884: NOT
99885: IFFALSE 99889
// exit ;
99887: GO 99918
// for i in tmp do
99889: LD_ADDR_VAR 0 1
99893: PUSH
99894: LD_VAR 0 2
99898: PUSH
99899: FOR_IN
99900: IFFALSE 99916
// SetFuel ( i , 0 ) ;
99902: LD_VAR 0 1
99906: PPUSH
99907: LD_INT 0
99909: PPUSH
99910: CALL_OW 240
99914: GO 99899
99916: POP
99917: POP
// end ;
99918: PPOPN 2
99920: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99921: LD_EXP 95
99925: PUSH
99926: LD_EXP 131
99930: AND
99931: IFFALSE 99997
99933: GO 99935
99935: DISABLE
99936: LD_INT 0
99938: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99939: LD_ADDR_VAR 0 1
99943: PUSH
99944: LD_INT 22
99946: PUSH
99947: LD_OWVAR 2
99951: PUSH
99952: EMPTY
99953: LIST
99954: LIST
99955: PUSH
99956: LD_INT 30
99958: PUSH
99959: LD_INT 29
99961: PUSH
99962: EMPTY
99963: LIST
99964: LIST
99965: PUSH
99966: EMPTY
99967: LIST
99968: LIST
99969: PPUSH
99970: CALL_OW 69
99974: ST_TO_ADDR
// if not tmp then
99975: LD_VAR 0 1
99979: NOT
99980: IFFALSE 99984
// exit ;
99982: GO 99997
// DestroyUnit ( tmp [ 1 ] ) ;
99984: LD_VAR 0 1
99988: PUSH
99989: LD_INT 1
99991: ARRAY
99992: PPUSH
99993: CALL_OW 65
// end ;
99997: PPOPN 1
99999: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100000: LD_EXP 95
100004: PUSH
100005: LD_EXP 133
100009: AND
100010: IFFALSE 100139
100012: GO 100014
100014: DISABLE
100015: LD_INT 0
100017: PPUSH
// begin uc_side := 0 ;
100018: LD_ADDR_OWVAR 20
100022: PUSH
100023: LD_INT 0
100025: ST_TO_ADDR
// uc_nation := nation_arabian ;
100026: LD_ADDR_OWVAR 21
100030: PUSH
100031: LD_INT 2
100033: ST_TO_ADDR
// hc_gallery :=  ;
100034: LD_ADDR_OWVAR 33
100038: PUSH
100039: LD_STRING 
100041: ST_TO_ADDR
// hc_name :=  ;
100042: LD_ADDR_OWVAR 26
100046: PUSH
100047: LD_STRING 
100049: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100050: LD_INT 1
100052: PPUSH
100053: LD_INT 11
100055: PPUSH
100056: LD_INT 10
100058: PPUSH
100059: CALL_OW 380
// un := CreateHuman ;
100063: LD_ADDR_VAR 0 1
100067: PUSH
100068: CALL_OW 44
100072: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100073: LD_VAR 0 1
100077: PPUSH
100078: LD_INT 1
100080: PPUSH
100081: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100085: LD_INT 35
100087: PPUSH
100088: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100092: LD_VAR 0 1
100096: PPUSH
100097: LD_INT 22
100099: PUSH
100100: LD_OWVAR 2
100104: PUSH
100105: EMPTY
100106: LIST
100107: LIST
100108: PPUSH
100109: CALL_OW 69
100113: PPUSH
100114: LD_VAR 0 1
100118: PPUSH
100119: CALL_OW 74
100123: PPUSH
100124: CALL_OW 115
// until IsDead ( un ) ;
100128: LD_VAR 0 1
100132: PPUSH
100133: CALL_OW 301
100137: IFFALSE 100085
// end ;
100139: PPOPN 1
100141: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100142: LD_EXP 95
100146: PUSH
100147: LD_EXP 135
100151: AND
100152: IFFALSE 100164
100154: GO 100156
100156: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100157: LD_STRING earthquake(getX(game), 0, 32)
100159: PPUSH
100160: CALL_OW 559
100164: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100165: LD_EXP 95
100169: PUSH
100170: LD_EXP 136
100174: AND
100175: IFFALSE 100266
100177: GO 100179
100179: DISABLE
100180: LD_INT 0
100182: PPUSH
// begin enable ;
100183: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100184: LD_ADDR_VAR 0 1
100188: PUSH
100189: LD_INT 22
100191: PUSH
100192: LD_OWVAR 2
100196: PUSH
100197: EMPTY
100198: LIST
100199: LIST
100200: PUSH
100201: LD_INT 21
100203: PUSH
100204: LD_INT 2
100206: PUSH
100207: EMPTY
100208: LIST
100209: LIST
100210: PUSH
100211: LD_INT 33
100213: PUSH
100214: LD_INT 3
100216: PUSH
100217: EMPTY
100218: LIST
100219: LIST
100220: PUSH
100221: EMPTY
100222: LIST
100223: LIST
100224: LIST
100225: PPUSH
100226: CALL_OW 69
100230: ST_TO_ADDR
// if not tmp then
100231: LD_VAR 0 1
100235: NOT
100236: IFFALSE 100240
// exit ;
100238: GO 100266
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100240: LD_VAR 0 1
100244: PUSH
100245: LD_INT 1
100247: PPUSH
100248: LD_VAR 0 1
100252: PPUSH
100253: CALL_OW 12
100257: ARRAY
100258: PPUSH
100259: LD_INT 1
100261: PPUSH
100262: CALL_OW 234
// end ;
100266: PPOPN 1
100268: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100269: LD_EXP 95
100273: PUSH
100274: LD_EXP 137
100278: AND
100279: IFFALSE 100420
100281: GO 100283
100283: DISABLE
100284: LD_INT 0
100286: PPUSH
100287: PPUSH
100288: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100289: LD_ADDR_VAR 0 3
100293: PUSH
100294: LD_INT 22
100296: PUSH
100297: LD_OWVAR 2
100301: PUSH
100302: EMPTY
100303: LIST
100304: LIST
100305: PUSH
100306: LD_INT 25
100308: PUSH
100309: LD_INT 1
100311: PUSH
100312: EMPTY
100313: LIST
100314: LIST
100315: PUSH
100316: EMPTY
100317: LIST
100318: LIST
100319: PPUSH
100320: CALL_OW 69
100324: ST_TO_ADDR
// if not tmp then
100325: LD_VAR 0 3
100329: NOT
100330: IFFALSE 100334
// exit ;
100332: GO 100420
// un := tmp [ rand ( 1 , tmp ) ] ;
100334: LD_ADDR_VAR 0 2
100338: PUSH
100339: LD_VAR 0 3
100343: PUSH
100344: LD_INT 1
100346: PPUSH
100347: LD_VAR 0 3
100351: PPUSH
100352: CALL_OW 12
100356: ARRAY
100357: ST_TO_ADDR
// if Crawls ( un ) then
100358: LD_VAR 0 2
100362: PPUSH
100363: CALL_OW 318
100367: IFFALSE 100378
// ComWalk ( un ) ;
100369: LD_VAR 0 2
100373: PPUSH
100374: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100378: LD_VAR 0 2
100382: PPUSH
100383: LD_INT 9
100385: PPUSH
100386: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100390: LD_INT 28
100392: PPUSH
100393: LD_OWVAR 2
100397: PPUSH
100398: LD_INT 2
100400: PPUSH
100401: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100405: LD_INT 29
100407: PPUSH
100408: LD_OWVAR 2
100412: PPUSH
100413: LD_INT 2
100415: PPUSH
100416: CALL_OW 322
// end ;
100420: PPOPN 3
100422: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100423: LD_EXP 95
100427: PUSH
100428: LD_EXP 138
100432: AND
100433: IFFALSE 100544
100435: GO 100437
100437: DISABLE
100438: LD_INT 0
100440: PPUSH
100441: PPUSH
100442: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100443: LD_ADDR_VAR 0 3
100447: PUSH
100448: LD_INT 22
100450: PUSH
100451: LD_OWVAR 2
100455: PUSH
100456: EMPTY
100457: LIST
100458: LIST
100459: PUSH
100460: LD_INT 25
100462: PUSH
100463: LD_INT 1
100465: PUSH
100466: EMPTY
100467: LIST
100468: LIST
100469: PUSH
100470: EMPTY
100471: LIST
100472: LIST
100473: PPUSH
100474: CALL_OW 69
100478: ST_TO_ADDR
// if not tmp then
100479: LD_VAR 0 3
100483: NOT
100484: IFFALSE 100488
// exit ;
100486: GO 100544
// un := tmp [ rand ( 1 , tmp ) ] ;
100488: LD_ADDR_VAR 0 2
100492: PUSH
100493: LD_VAR 0 3
100497: PUSH
100498: LD_INT 1
100500: PPUSH
100501: LD_VAR 0 3
100505: PPUSH
100506: CALL_OW 12
100510: ARRAY
100511: ST_TO_ADDR
// if Crawls ( un ) then
100512: LD_VAR 0 2
100516: PPUSH
100517: CALL_OW 318
100521: IFFALSE 100532
// ComWalk ( un ) ;
100523: LD_VAR 0 2
100527: PPUSH
100528: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100532: LD_VAR 0 2
100536: PPUSH
100537: LD_INT 8
100539: PPUSH
100540: CALL_OW 336
// end ;
100544: PPOPN 3
100546: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100547: LD_EXP 95
100551: PUSH
100552: LD_EXP 139
100556: AND
100557: IFFALSE 100701
100559: GO 100561
100561: DISABLE
100562: LD_INT 0
100564: PPUSH
100565: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100566: LD_ADDR_VAR 0 2
100570: PUSH
100571: LD_INT 22
100573: PUSH
100574: LD_OWVAR 2
100578: PUSH
100579: EMPTY
100580: LIST
100581: LIST
100582: PUSH
100583: LD_INT 21
100585: PUSH
100586: LD_INT 2
100588: PUSH
100589: EMPTY
100590: LIST
100591: LIST
100592: PUSH
100593: LD_INT 2
100595: PUSH
100596: LD_INT 34
100598: PUSH
100599: LD_INT 12
100601: PUSH
100602: EMPTY
100603: LIST
100604: LIST
100605: PUSH
100606: LD_INT 34
100608: PUSH
100609: LD_INT 51
100611: PUSH
100612: EMPTY
100613: LIST
100614: LIST
100615: PUSH
100616: LD_INT 34
100618: PUSH
100619: LD_INT 32
100621: PUSH
100622: EMPTY
100623: LIST
100624: LIST
100625: PUSH
100626: EMPTY
100627: LIST
100628: LIST
100629: LIST
100630: LIST
100631: PUSH
100632: EMPTY
100633: LIST
100634: LIST
100635: LIST
100636: PPUSH
100637: CALL_OW 69
100641: ST_TO_ADDR
// if not tmp then
100642: LD_VAR 0 2
100646: NOT
100647: IFFALSE 100651
// exit ;
100649: GO 100701
// for i in tmp do
100651: LD_ADDR_VAR 0 1
100655: PUSH
100656: LD_VAR 0 2
100660: PUSH
100661: FOR_IN
100662: IFFALSE 100699
// if GetCargo ( i , mat_artifact ) = 0 then
100664: LD_VAR 0 1
100668: PPUSH
100669: LD_INT 4
100671: PPUSH
100672: CALL_OW 289
100676: PUSH
100677: LD_INT 0
100679: EQUAL
100680: IFFALSE 100697
// SetCargo ( i , mat_siberit , 100 ) ;
100682: LD_VAR 0 1
100686: PPUSH
100687: LD_INT 3
100689: PPUSH
100690: LD_INT 100
100692: PPUSH
100693: CALL_OW 290
100697: GO 100661
100699: POP
100700: POP
// end ;
100701: PPOPN 2
100703: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100704: LD_EXP 95
100708: PUSH
100709: LD_EXP 140
100713: AND
100714: IFFALSE 100897
100716: GO 100718
100718: DISABLE
100719: LD_INT 0
100721: PPUSH
100722: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100723: LD_ADDR_VAR 0 2
100727: PUSH
100728: LD_INT 22
100730: PUSH
100731: LD_OWVAR 2
100735: PUSH
100736: EMPTY
100737: LIST
100738: LIST
100739: PPUSH
100740: CALL_OW 69
100744: ST_TO_ADDR
// if not tmp then
100745: LD_VAR 0 2
100749: NOT
100750: IFFALSE 100754
// exit ;
100752: GO 100897
// for i := 1 to 2 do
100754: LD_ADDR_VAR 0 1
100758: PUSH
100759: DOUBLE
100760: LD_INT 1
100762: DEC
100763: ST_TO_ADDR
100764: LD_INT 2
100766: PUSH
100767: FOR_TO
100768: IFFALSE 100895
// begin uc_side := your_side ;
100770: LD_ADDR_OWVAR 20
100774: PUSH
100775: LD_OWVAR 2
100779: ST_TO_ADDR
// uc_nation := nation_american ;
100780: LD_ADDR_OWVAR 21
100784: PUSH
100785: LD_INT 1
100787: ST_TO_ADDR
// vc_chassis := us_morphling ;
100788: LD_ADDR_OWVAR 37
100792: PUSH
100793: LD_INT 5
100795: ST_TO_ADDR
// vc_engine := engine_siberite ;
100796: LD_ADDR_OWVAR 39
100800: PUSH
100801: LD_INT 3
100803: ST_TO_ADDR
// vc_control := control_computer ;
100804: LD_ADDR_OWVAR 38
100808: PUSH
100809: LD_INT 3
100811: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100812: LD_ADDR_OWVAR 40
100816: PUSH
100817: LD_INT 10
100819: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100820: LD_VAR 0 2
100824: PUSH
100825: LD_INT 1
100827: ARRAY
100828: PPUSH
100829: CALL_OW 310
100833: NOT
100834: IFFALSE 100881
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100836: CALL_OW 45
100840: PPUSH
100841: LD_VAR 0 2
100845: PUSH
100846: LD_INT 1
100848: ARRAY
100849: PPUSH
100850: CALL_OW 250
100854: PPUSH
100855: LD_VAR 0 2
100859: PUSH
100860: LD_INT 1
100862: ARRAY
100863: PPUSH
100864: CALL_OW 251
100868: PPUSH
100869: LD_INT 12
100871: PPUSH
100872: LD_INT 1
100874: PPUSH
100875: CALL_OW 50
100879: GO 100893
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100881: CALL_OW 45
100885: PPUSH
100886: LD_INT 1
100888: PPUSH
100889: CALL_OW 51
// end ;
100893: GO 100767
100895: POP
100896: POP
// end ;
100897: PPOPN 2
100899: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100900: LD_EXP 95
100904: PUSH
100905: LD_EXP 141
100909: AND
100910: IFFALSE 101132
100912: GO 100914
100914: DISABLE
100915: LD_INT 0
100917: PPUSH
100918: PPUSH
100919: PPUSH
100920: PPUSH
100921: PPUSH
100922: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100923: LD_ADDR_VAR 0 6
100927: PUSH
100928: LD_INT 22
100930: PUSH
100931: LD_OWVAR 2
100935: PUSH
100936: EMPTY
100937: LIST
100938: LIST
100939: PUSH
100940: LD_INT 21
100942: PUSH
100943: LD_INT 1
100945: PUSH
100946: EMPTY
100947: LIST
100948: LIST
100949: PUSH
100950: LD_INT 3
100952: PUSH
100953: LD_INT 23
100955: PUSH
100956: LD_INT 0
100958: PUSH
100959: EMPTY
100960: LIST
100961: LIST
100962: PUSH
100963: EMPTY
100964: LIST
100965: LIST
100966: PUSH
100967: EMPTY
100968: LIST
100969: LIST
100970: LIST
100971: PPUSH
100972: CALL_OW 69
100976: ST_TO_ADDR
// if not tmp then
100977: LD_VAR 0 6
100981: NOT
100982: IFFALSE 100986
// exit ;
100984: GO 101132
// s1 := rand ( 1 , 4 ) ;
100986: LD_ADDR_VAR 0 2
100990: PUSH
100991: LD_INT 1
100993: PPUSH
100994: LD_INT 4
100996: PPUSH
100997: CALL_OW 12
101001: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101002: LD_ADDR_VAR 0 4
101006: PUSH
101007: LD_VAR 0 6
101011: PUSH
101012: LD_INT 1
101014: ARRAY
101015: PPUSH
101016: LD_VAR 0 2
101020: PPUSH
101021: CALL_OW 259
101025: ST_TO_ADDR
// if s1 = 1 then
101026: LD_VAR 0 2
101030: PUSH
101031: LD_INT 1
101033: EQUAL
101034: IFFALSE 101054
// s2 := rand ( 2 , 4 ) else
101036: LD_ADDR_VAR 0 3
101040: PUSH
101041: LD_INT 2
101043: PPUSH
101044: LD_INT 4
101046: PPUSH
101047: CALL_OW 12
101051: ST_TO_ADDR
101052: GO 101062
// s2 := 1 ;
101054: LD_ADDR_VAR 0 3
101058: PUSH
101059: LD_INT 1
101061: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101062: LD_ADDR_VAR 0 5
101066: PUSH
101067: LD_VAR 0 6
101071: PUSH
101072: LD_INT 1
101074: ARRAY
101075: PPUSH
101076: LD_VAR 0 3
101080: PPUSH
101081: CALL_OW 259
101085: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101086: LD_VAR 0 6
101090: PUSH
101091: LD_INT 1
101093: ARRAY
101094: PPUSH
101095: LD_VAR 0 2
101099: PPUSH
101100: LD_VAR 0 5
101104: PPUSH
101105: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101109: LD_VAR 0 6
101113: PUSH
101114: LD_INT 1
101116: ARRAY
101117: PPUSH
101118: LD_VAR 0 3
101122: PPUSH
101123: LD_VAR 0 4
101127: PPUSH
101128: CALL_OW 237
// end ;
101132: PPOPN 6
101134: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101135: LD_EXP 95
101139: PUSH
101140: LD_EXP 142
101144: AND
101145: IFFALSE 101224
101147: GO 101149
101149: DISABLE
101150: LD_INT 0
101152: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101153: LD_ADDR_VAR 0 1
101157: PUSH
101158: LD_INT 22
101160: PUSH
101161: LD_OWVAR 2
101165: PUSH
101166: EMPTY
101167: LIST
101168: LIST
101169: PUSH
101170: LD_INT 30
101172: PUSH
101173: LD_INT 3
101175: PUSH
101176: EMPTY
101177: LIST
101178: LIST
101179: PUSH
101180: EMPTY
101181: LIST
101182: LIST
101183: PPUSH
101184: CALL_OW 69
101188: ST_TO_ADDR
// if not tmp then
101189: LD_VAR 0 1
101193: NOT
101194: IFFALSE 101198
// exit ;
101196: GO 101224
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101198: LD_VAR 0 1
101202: PUSH
101203: LD_INT 1
101205: PPUSH
101206: LD_VAR 0 1
101210: PPUSH
101211: CALL_OW 12
101215: ARRAY
101216: PPUSH
101217: LD_INT 1
101219: PPUSH
101220: CALL_OW 234
// end ;
101224: PPOPN 1
101226: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101227: LD_EXP 95
101231: PUSH
101232: LD_EXP 143
101236: AND
101237: IFFALSE 101349
101239: GO 101241
101241: DISABLE
101242: LD_INT 0
101244: PPUSH
101245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101246: LD_ADDR_VAR 0 2
101250: PUSH
101251: LD_INT 22
101253: PUSH
101254: LD_OWVAR 2
101258: PUSH
101259: EMPTY
101260: LIST
101261: LIST
101262: PUSH
101263: LD_INT 2
101265: PUSH
101266: LD_INT 30
101268: PUSH
101269: LD_INT 27
101271: PUSH
101272: EMPTY
101273: LIST
101274: LIST
101275: PUSH
101276: LD_INT 30
101278: PUSH
101279: LD_INT 26
101281: PUSH
101282: EMPTY
101283: LIST
101284: LIST
101285: PUSH
101286: LD_INT 30
101288: PUSH
101289: LD_INT 28
101291: PUSH
101292: EMPTY
101293: LIST
101294: LIST
101295: PUSH
101296: EMPTY
101297: LIST
101298: LIST
101299: LIST
101300: LIST
101301: PUSH
101302: EMPTY
101303: LIST
101304: LIST
101305: PPUSH
101306: CALL_OW 69
101310: ST_TO_ADDR
// if not tmp then
101311: LD_VAR 0 2
101315: NOT
101316: IFFALSE 101320
// exit ;
101318: GO 101349
// for i in tmp do
101320: LD_ADDR_VAR 0 1
101324: PUSH
101325: LD_VAR 0 2
101329: PUSH
101330: FOR_IN
101331: IFFALSE 101347
// SetLives ( i , 1 ) ;
101333: LD_VAR 0 1
101337: PPUSH
101338: LD_INT 1
101340: PPUSH
101341: CALL_OW 234
101345: GO 101330
101347: POP
101348: POP
// end ;
101349: PPOPN 2
101351: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101352: LD_EXP 95
101356: PUSH
101357: LD_EXP 144
101361: AND
101362: IFFALSE 101649
101364: GO 101366
101366: DISABLE
101367: LD_INT 0
101369: PPUSH
101370: PPUSH
101371: PPUSH
// begin i := rand ( 1 , 7 ) ;
101372: LD_ADDR_VAR 0 1
101376: PUSH
101377: LD_INT 1
101379: PPUSH
101380: LD_INT 7
101382: PPUSH
101383: CALL_OW 12
101387: ST_TO_ADDR
// case i of 1 :
101388: LD_VAR 0 1
101392: PUSH
101393: LD_INT 1
101395: DOUBLE
101396: EQUAL
101397: IFTRUE 101401
101399: GO 101411
101401: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101402: LD_STRING earthquake(getX(game), 0, 32)
101404: PPUSH
101405: CALL_OW 559
101409: GO 101649
101411: LD_INT 2
101413: DOUBLE
101414: EQUAL
101415: IFTRUE 101419
101417: GO 101433
101419: POP
// begin ToLua ( displayStucuk(); ) ;
101420: LD_STRING displayStucuk();
101422: PPUSH
101423: CALL_OW 559
// ResetFog ;
101427: CALL_OW 335
// end ; 3 :
101431: GO 101649
101433: LD_INT 3
101435: DOUBLE
101436: EQUAL
101437: IFTRUE 101441
101439: GO 101545
101441: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101442: LD_ADDR_VAR 0 2
101446: PUSH
101447: LD_INT 22
101449: PUSH
101450: LD_OWVAR 2
101454: PUSH
101455: EMPTY
101456: LIST
101457: LIST
101458: PUSH
101459: LD_INT 25
101461: PUSH
101462: LD_INT 1
101464: PUSH
101465: EMPTY
101466: LIST
101467: LIST
101468: PUSH
101469: EMPTY
101470: LIST
101471: LIST
101472: PPUSH
101473: CALL_OW 69
101477: ST_TO_ADDR
// if not tmp then
101478: LD_VAR 0 2
101482: NOT
101483: IFFALSE 101487
// exit ;
101485: GO 101649
// un := tmp [ rand ( 1 , tmp ) ] ;
101487: LD_ADDR_VAR 0 3
101491: PUSH
101492: LD_VAR 0 2
101496: PUSH
101497: LD_INT 1
101499: PPUSH
101500: LD_VAR 0 2
101504: PPUSH
101505: CALL_OW 12
101509: ARRAY
101510: ST_TO_ADDR
// if Crawls ( un ) then
101511: LD_VAR 0 3
101515: PPUSH
101516: CALL_OW 318
101520: IFFALSE 101531
// ComWalk ( un ) ;
101522: LD_VAR 0 3
101526: PPUSH
101527: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101531: LD_VAR 0 3
101535: PPUSH
101536: LD_INT 8
101538: PPUSH
101539: CALL_OW 336
// end ; 4 :
101543: GO 101649
101545: LD_INT 4
101547: DOUBLE
101548: EQUAL
101549: IFTRUE 101553
101551: GO 101627
101553: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101554: LD_ADDR_VAR 0 2
101558: PUSH
101559: LD_INT 22
101561: PUSH
101562: LD_OWVAR 2
101566: PUSH
101567: EMPTY
101568: LIST
101569: LIST
101570: PUSH
101571: LD_INT 30
101573: PUSH
101574: LD_INT 29
101576: PUSH
101577: EMPTY
101578: LIST
101579: LIST
101580: PUSH
101581: EMPTY
101582: LIST
101583: LIST
101584: PPUSH
101585: CALL_OW 69
101589: ST_TO_ADDR
// if not tmp then
101590: LD_VAR 0 2
101594: NOT
101595: IFFALSE 101599
// exit ;
101597: GO 101649
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101599: LD_VAR 0 2
101603: PUSH
101604: LD_INT 1
101606: ARRAY
101607: PPUSH
101608: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101612: LD_VAR 0 2
101616: PUSH
101617: LD_INT 1
101619: ARRAY
101620: PPUSH
101621: CALL_OW 65
// end ; 5 .. 7 :
101625: GO 101649
101627: LD_INT 5
101629: DOUBLE
101630: GREATEREQUAL
101631: IFFALSE 101639
101633: LD_INT 7
101635: DOUBLE
101636: LESSEQUAL
101637: IFTRUE 101641
101639: GO 101648
101641: POP
// StreamSibBomb ; end ;
101642: CALL 97886 0 0
101646: GO 101649
101648: POP
// end ;
101649: PPOPN 3
101651: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101652: LD_EXP 95
101656: PUSH
101657: LD_EXP 145
101661: AND
101662: IFFALSE 101818
101664: GO 101666
101666: DISABLE
101667: LD_INT 0
101669: PPUSH
101670: PPUSH
101671: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101672: LD_ADDR_VAR 0 2
101676: PUSH
101677: LD_INT 81
101679: PUSH
101680: LD_OWVAR 2
101684: PUSH
101685: EMPTY
101686: LIST
101687: LIST
101688: PUSH
101689: LD_INT 2
101691: PUSH
101692: LD_INT 21
101694: PUSH
101695: LD_INT 1
101697: PUSH
101698: EMPTY
101699: LIST
101700: LIST
101701: PUSH
101702: LD_INT 21
101704: PUSH
101705: LD_INT 2
101707: PUSH
101708: EMPTY
101709: LIST
101710: LIST
101711: PUSH
101712: EMPTY
101713: LIST
101714: LIST
101715: LIST
101716: PUSH
101717: EMPTY
101718: LIST
101719: LIST
101720: PPUSH
101721: CALL_OW 69
101725: ST_TO_ADDR
// if not tmp then
101726: LD_VAR 0 2
101730: NOT
101731: IFFALSE 101735
// exit ;
101733: GO 101818
// p := 0 ;
101735: LD_ADDR_VAR 0 3
101739: PUSH
101740: LD_INT 0
101742: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101743: LD_INT 35
101745: PPUSH
101746: CALL_OW 67
// p := p + 1 ;
101750: LD_ADDR_VAR 0 3
101754: PUSH
101755: LD_VAR 0 3
101759: PUSH
101760: LD_INT 1
101762: PLUS
101763: ST_TO_ADDR
// for i in tmp do
101764: LD_ADDR_VAR 0 1
101768: PUSH
101769: LD_VAR 0 2
101773: PUSH
101774: FOR_IN
101775: IFFALSE 101806
// if GetLives ( i ) < 1000 then
101777: LD_VAR 0 1
101781: PPUSH
101782: CALL_OW 256
101786: PUSH
101787: LD_INT 1000
101789: LESS
101790: IFFALSE 101804
// SetLives ( i , 1000 ) ;
101792: LD_VAR 0 1
101796: PPUSH
101797: LD_INT 1000
101799: PPUSH
101800: CALL_OW 234
101804: GO 101774
101806: POP
101807: POP
// until p > 20 ;
101808: LD_VAR 0 3
101812: PUSH
101813: LD_INT 20
101815: GREATER
101816: IFFALSE 101743
// end ;
101818: PPOPN 3
101820: END
// every 0 0$1 trigger StreamModeActive and sTime do
101821: LD_EXP 95
101825: PUSH
101826: LD_EXP 146
101830: AND
101831: IFFALSE 101866
101833: GO 101835
101835: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101836: LD_INT 28
101838: PPUSH
101839: LD_OWVAR 2
101843: PPUSH
101844: LD_INT 2
101846: PPUSH
101847: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101851: LD_INT 30
101853: PPUSH
101854: LD_OWVAR 2
101858: PPUSH
101859: LD_INT 2
101861: PPUSH
101862: CALL_OW 322
// end ;
101866: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101867: LD_EXP 95
101871: PUSH
101872: LD_EXP 147
101876: AND
101877: IFFALSE 101998
101879: GO 101881
101881: DISABLE
101882: LD_INT 0
101884: PPUSH
101885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101886: LD_ADDR_VAR 0 2
101890: PUSH
101891: LD_INT 22
101893: PUSH
101894: LD_OWVAR 2
101898: PUSH
101899: EMPTY
101900: LIST
101901: LIST
101902: PUSH
101903: LD_INT 21
101905: PUSH
101906: LD_INT 1
101908: PUSH
101909: EMPTY
101910: LIST
101911: LIST
101912: PUSH
101913: LD_INT 3
101915: PUSH
101916: LD_INT 23
101918: PUSH
101919: LD_INT 0
101921: PUSH
101922: EMPTY
101923: LIST
101924: LIST
101925: PUSH
101926: EMPTY
101927: LIST
101928: LIST
101929: PUSH
101930: EMPTY
101931: LIST
101932: LIST
101933: LIST
101934: PPUSH
101935: CALL_OW 69
101939: ST_TO_ADDR
// if not tmp then
101940: LD_VAR 0 2
101944: NOT
101945: IFFALSE 101949
// exit ;
101947: GO 101998
// for i in tmp do
101949: LD_ADDR_VAR 0 1
101953: PUSH
101954: LD_VAR 0 2
101958: PUSH
101959: FOR_IN
101960: IFFALSE 101996
// begin if Crawls ( i ) then
101962: LD_VAR 0 1
101966: PPUSH
101967: CALL_OW 318
101971: IFFALSE 101982
// ComWalk ( i ) ;
101973: LD_VAR 0 1
101977: PPUSH
101978: CALL_OW 138
// SetClass ( i , 2 ) ;
101982: LD_VAR 0 1
101986: PPUSH
101987: LD_INT 2
101989: PPUSH
101990: CALL_OW 336
// end ;
101994: GO 101959
101996: POP
101997: POP
// end ;
101998: PPOPN 2
102000: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102001: LD_EXP 95
102005: PUSH
102006: LD_EXP 148
102010: AND
102011: IFFALSE 102299
102013: GO 102015
102015: DISABLE
102016: LD_INT 0
102018: PPUSH
102019: PPUSH
102020: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102021: LD_OWVAR 2
102025: PPUSH
102026: LD_INT 9
102028: PPUSH
102029: LD_INT 1
102031: PPUSH
102032: LD_INT 1
102034: PPUSH
102035: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102039: LD_INT 9
102041: PPUSH
102042: LD_OWVAR 2
102046: PPUSH
102047: CALL_OW 343
// uc_side := 9 ;
102051: LD_ADDR_OWVAR 20
102055: PUSH
102056: LD_INT 9
102058: ST_TO_ADDR
// uc_nation := 2 ;
102059: LD_ADDR_OWVAR 21
102063: PUSH
102064: LD_INT 2
102066: ST_TO_ADDR
// hc_name := Dark Warrior ;
102067: LD_ADDR_OWVAR 26
102071: PUSH
102072: LD_STRING Dark Warrior
102074: ST_TO_ADDR
// hc_gallery :=  ;
102075: LD_ADDR_OWVAR 33
102079: PUSH
102080: LD_STRING 
102082: ST_TO_ADDR
// hc_noskilllimit := true ;
102083: LD_ADDR_OWVAR 76
102087: PUSH
102088: LD_INT 1
102090: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102091: LD_ADDR_OWVAR 31
102095: PUSH
102096: LD_INT 30
102098: PUSH
102099: LD_INT 30
102101: PUSH
102102: LD_INT 30
102104: PUSH
102105: LD_INT 30
102107: PUSH
102108: EMPTY
102109: LIST
102110: LIST
102111: LIST
102112: LIST
102113: ST_TO_ADDR
// un := CreateHuman ;
102114: LD_ADDR_VAR 0 3
102118: PUSH
102119: CALL_OW 44
102123: ST_TO_ADDR
// hc_noskilllimit := false ;
102124: LD_ADDR_OWVAR 76
102128: PUSH
102129: LD_INT 0
102131: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102132: LD_VAR 0 3
102136: PPUSH
102137: LD_INT 1
102139: PPUSH
102140: CALL_OW 51
// ToLua ( playRanger() ) ;
102144: LD_STRING playRanger()
102146: PPUSH
102147: CALL_OW 559
// p := 0 ;
102151: LD_ADDR_VAR 0 2
102155: PUSH
102156: LD_INT 0
102158: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102159: LD_INT 35
102161: PPUSH
102162: CALL_OW 67
// p := p + 1 ;
102166: LD_ADDR_VAR 0 2
102170: PUSH
102171: LD_VAR 0 2
102175: PUSH
102176: LD_INT 1
102178: PLUS
102179: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102180: LD_VAR 0 3
102184: PPUSH
102185: CALL_OW 256
102189: PUSH
102190: LD_INT 1000
102192: LESS
102193: IFFALSE 102207
// SetLives ( un , 1000 ) ;
102195: LD_VAR 0 3
102199: PPUSH
102200: LD_INT 1000
102202: PPUSH
102203: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102207: LD_VAR 0 3
102211: PPUSH
102212: LD_INT 81
102214: PUSH
102215: LD_OWVAR 2
102219: PUSH
102220: EMPTY
102221: LIST
102222: LIST
102223: PUSH
102224: LD_INT 91
102226: PUSH
102227: LD_VAR 0 3
102231: PUSH
102232: LD_INT 30
102234: PUSH
102235: EMPTY
102236: LIST
102237: LIST
102238: LIST
102239: PUSH
102240: EMPTY
102241: LIST
102242: LIST
102243: PPUSH
102244: CALL_OW 69
102248: PPUSH
102249: LD_VAR 0 3
102253: PPUSH
102254: CALL_OW 74
102258: PPUSH
102259: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102263: LD_VAR 0 2
102267: PUSH
102268: LD_INT 80
102270: GREATER
102271: PUSH
102272: LD_VAR 0 3
102276: PPUSH
102277: CALL_OW 301
102281: OR
102282: IFFALSE 102159
// if un then
102284: LD_VAR 0 3
102288: IFFALSE 102299
// RemoveUnit ( un ) ;
102290: LD_VAR 0 3
102294: PPUSH
102295: CALL_OW 64
// end ;
102299: PPOPN 3
102301: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102302: LD_EXP 149
102306: IFFALSE 102422
102308: GO 102310
102310: DISABLE
102311: LD_INT 0
102313: PPUSH
102314: PPUSH
102315: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102316: LD_ADDR_VAR 0 2
102320: PUSH
102321: LD_INT 81
102323: PUSH
102324: LD_OWVAR 2
102328: PUSH
102329: EMPTY
102330: LIST
102331: LIST
102332: PUSH
102333: LD_INT 21
102335: PUSH
102336: LD_INT 1
102338: PUSH
102339: EMPTY
102340: LIST
102341: LIST
102342: PUSH
102343: EMPTY
102344: LIST
102345: LIST
102346: PPUSH
102347: CALL_OW 69
102351: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102352: LD_STRING playComputer()
102354: PPUSH
102355: CALL_OW 559
// if not tmp then
102359: LD_VAR 0 2
102363: NOT
102364: IFFALSE 102368
// exit ;
102366: GO 102422
// for i in tmp do
102368: LD_ADDR_VAR 0 1
102372: PUSH
102373: LD_VAR 0 2
102377: PUSH
102378: FOR_IN
102379: IFFALSE 102420
// for j := 1 to 4 do
102381: LD_ADDR_VAR 0 3
102385: PUSH
102386: DOUBLE
102387: LD_INT 1
102389: DEC
102390: ST_TO_ADDR
102391: LD_INT 4
102393: PUSH
102394: FOR_TO
102395: IFFALSE 102416
// SetSkill ( i , j , 10 ) ;
102397: LD_VAR 0 1
102401: PPUSH
102402: LD_VAR 0 3
102406: PPUSH
102407: LD_INT 10
102409: PPUSH
102410: CALL_OW 237
102414: GO 102394
102416: POP
102417: POP
102418: GO 102378
102420: POP
102421: POP
// end ;
102422: PPOPN 3
102424: END
// every 0 0$1 trigger s30 do var i , tmp ;
102425: LD_EXP 150
102429: IFFALSE 102498
102431: GO 102433
102433: DISABLE
102434: LD_INT 0
102436: PPUSH
102437: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102438: LD_ADDR_VAR 0 2
102442: PUSH
102443: LD_INT 22
102445: PUSH
102446: LD_OWVAR 2
102450: PUSH
102451: EMPTY
102452: LIST
102453: LIST
102454: PPUSH
102455: CALL_OW 69
102459: ST_TO_ADDR
// if not tmp then
102460: LD_VAR 0 2
102464: NOT
102465: IFFALSE 102469
// exit ;
102467: GO 102498
// for i in tmp do
102469: LD_ADDR_VAR 0 1
102473: PUSH
102474: LD_VAR 0 2
102478: PUSH
102479: FOR_IN
102480: IFFALSE 102496
// SetLives ( i , 300 ) ;
102482: LD_VAR 0 1
102486: PPUSH
102487: LD_INT 300
102489: PPUSH
102490: CALL_OW 234
102494: GO 102479
102496: POP
102497: POP
// end ;
102498: PPOPN 2
102500: END
// every 0 0$1 trigger s60 do var i , tmp ;
102501: LD_EXP 151
102505: IFFALSE 102574
102507: GO 102509
102509: DISABLE
102510: LD_INT 0
102512: PPUSH
102513: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102514: LD_ADDR_VAR 0 2
102518: PUSH
102519: LD_INT 22
102521: PUSH
102522: LD_OWVAR 2
102526: PUSH
102527: EMPTY
102528: LIST
102529: LIST
102530: PPUSH
102531: CALL_OW 69
102535: ST_TO_ADDR
// if not tmp then
102536: LD_VAR 0 2
102540: NOT
102541: IFFALSE 102545
// exit ;
102543: GO 102574
// for i in tmp do
102545: LD_ADDR_VAR 0 1
102549: PUSH
102550: LD_VAR 0 2
102554: PUSH
102555: FOR_IN
102556: IFFALSE 102572
// SetLives ( i , 600 ) ;
102558: LD_VAR 0 1
102562: PPUSH
102563: LD_INT 600
102565: PPUSH
102566: CALL_OW 234
102570: GO 102555
102572: POP
102573: POP
// end ;
102574: PPOPN 2
102576: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102577: LD_INT 0
102579: PPUSH
// case cmd of 301 :
102580: LD_VAR 0 1
102584: PUSH
102585: LD_INT 301
102587: DOUBLE
102588: EQUAL
102589: IFTRUE 102593
102591: GO 102625
102593: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102594: LD_VAR 0 6
102598: PPUSH
102599: LD_VAR 0 7
102603: PPUSH
102604: LD_VAR 0 8
102608: PPUSH
102609: LD_VAR 0 4
102613: PPUSH
102614: LD_VAR 0 5
102618: PPUSH
102619: CALL 103826 0 5
102623: GO 102746
102625: LD_INT 302
102627: DOUBLE
102628: EQUAL
102629: IFTRUE 102633
102631: GO 102670
102633: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102634: LD_VAR 0 6
102638: PPUSH
102639: LD_VAR 0 7
102643: PPUSH
102644: LD_VAR 0 8
102648: PPUSH
102649: LD_VAR 0 9
102653: PPUSH
102654: LD_VAR 0 4
102658: PPUSH
102659: LD_VAR 0 5
102663: PPUSH
102664: CALL 103917 0 6
102668: GO 102746
102670: LD_INT 303
102672: DOUBLE
102673: EQUAL
102674: IFTRUE 102678
102676: GO 102715
102678: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102679: LD_VAR 0 6
102683: PPUSH
102684: LD_VAR 0 7
102688: PPUSH
102689: LD_VAR 0 8
102693: PPUSH
102694: LD_VAR 0 9
102698: PPUSH
102699: LD_VAR 0 4
102703: PPUSH
102704: LD_VAR 0 5
102708: PPUSH
102709: CALL 102751 0 6
102713: GO 102746
102715: LD_INT 304
102717: DOUBLE
102718: EQUAL
102719: IFTRUE 102723
102721: GO 102745
102723: POP
// hHackTeleport ( unit , x , y ) ; end ;
102724: LD_VAR 0 2
102728: PPUSH
102729: LD_VAR 0 4
102733: PPUSH
102734: LD_VAR 0 5
102738: PPUSH
102739: CALL 104510 0 3
102743: GO 102746
102745: POP
// end ;
102746: LD_VAR 0 12
102750: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102751: LD_INT 0
102753: PPUSH
102754: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102755: LD_VAR 0 1
102759: PUSH
102760: LD_INT 1
102762: LESS
102763: PUSH
102764: LD_VAR 0 1
102768: PUSH
102769: LD_INT 3
102771: GREATER
102772: OR
102773: PUSH
102774: LD_VAR 0 5
102778: PPUSH
102779: LD_VAR 0 6
102783: PPUSH
102784: CALL_OW 428
102788: OR
102789: IFFALSE 102793
// exit ;
102791: GO 103513
// uc_side := your_side ;
102793: LD_ADDR_OWVAR 20
102797: PUSH
102798: LD_OWVAR 2
102802: ST_TO_ADDR
// uc_nation := nation ;
102803: LD_ADDR_OWVAR 21
102807: PUSH
102808: LD_VAR 0 1
102812: ST_TO_ADDR
// bc_level = 1 ;
102813: LD_ADDR_OWVAR 43
102817: PUSH
102818: LD_INT 1
102820: ST_TO_ADDR
// case btype of 1 :
102821: LD_VAR 0 2
102825: PUSH
102826: LD_INT 1
102828: DOUBLE
102829: EQUAL
102830: IFTRUE 102834
102832: GO 102845
102834: POP
// bc_type := b_depot ; 2 :
102835: LD_ADDR_OWVAR 42
102839: PUSH
102840: LD_INT 0
102842: ST_TO_ADDR
102843: GO 103457
102845: LD_INT 2
102847: DOUBLE
102848: EQUAL
102849: IFTRUE 102853
102851: GO 102864
102853: POP
// bc_type := b_warehouse ; 3 :
102854: LD_ADDR_OWVAR 42
102858: PUSH
102859: LD_INT 1
102861: ST_TO_ADDR
102862: GO 103457
102864: LD_INT 3
102866: DOUBLE
102867: EQUAL
102868: IFTRUE 102872
102870: GO 102883
102872: POP
// bc_type := b_lab ; 4 .. 9 :
102873: LD_ADDR_OWVAR 42
102877: PUSH
102878: LD_INT 6
102880: ST_TO_ADDR
102881: GO 103457
102883: LD_INT 4
102885: DOUBLE
102886: GREATEREQUAL
102887: IFFALSE 102895
102889: LD_INT 9
102891: DOUBLE
102892: LESSEQUAL
102893: IFTRUE 102897
102895: GO 102949
102897: POP
// begin bc_type := b_lab_half ;
102898: LD_ADDR_OWVAR 42
102902: PUSH
102903: LD_INT 7
102905: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102906: LD_ADDR_OWVAR 44
102910: PUSH
102911: LD_INT 10
102913: PUSH
102914: LD_INT 11
102916: PUSH
102917: LD_INT 12
102919: PUSH
102920: LD_INT 15
102922: PUSH
102923: LD_INT 14
102925: PUSH
102926: LD_INT 13
102928: PUSH
102929: EMPTY
102930: LIST
102931: LIST
102932: LIST
102933: LIST
102934: LIST
102935: LIST
102936: PUSH
102937: LD_VAR 0 2
102941: PUSH
102942: LD_INT 3
102944: MINUS
102945: ARRAY
102946: ST_TO_ADDR
// end ; 10 .. 13 :
102947: GO 103457
102949: LD_INT 10
102951: DOUBLE
102952: GREATEREQUAL
102953: IFFALSE 102961
102955: LD_INT 13
102957: DOUBLE
102958: LESSEQUAL
102959: IFTRUE 102963
102961: GO 103040
102963: POP
// begin bc_type := b_lab_full ;
102964: LD_ADDR_OWVAR 42
102968: PUSH
102969: LD_INT 8
102971: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102972: LD_ADDR_OWVAR 44
102976: PUSH
102977: LD_INT 10
102979: PUSH
102980: LD_INT 12
102982: PUSH
102983: LD_INT 14
102985: PUSH
102986: LD_INT 13
102988: PUSH
102989: EMPTY
102990: LIST
102991: LIST
102992: LIST
102993: LIST
102994: PUSH
102995: LD_VAR 0 2
102999: PUSH
103000: LD_INT 9
103002: MINUS
103003: ARRAY
103004: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103005: LD_ADDR_OWVAR 45
103009: PUSH
103010: LD_INT 11
103012: PUSH
103013: LD_INT 15
103015: PUSH
103016: LD_INT 12
103018: PUSH
103019: LD_INT 15
103021: PUSH
103022: EMPTY
103023: LIST
103024: LIST
103025: LIST
103026: LIST
103027: PUSH
103028: LD_VAR 0 2
103032: PUSH
103033: LD_INT 9
103035: MINUS
103036: ARRAY
103037: ST_TO_ADDR
// end ; 14 :
103038: GO 103457
103040: LD_INT 14
103042: DOUBLE
103043: EQUAL
103044: IFTRUE 103048
103046: GO 103059
103048: POP
// bc_type := b_workshop ; 15 :
103049: LD_ADDR_OWVAR 42
103053: PUSH
103054: LD_INT 2
103056: ST_TO_ADDR
103057: GO 103457
103059: LD_INT 15
103061: DOUBLE
103062: EQUAL
103063: IFTRUE 103067
103065: GO 103078
103067: POP
// bc_type := b_factory ; 16 :
103068: LD_ADDR_OWVAR 42
103072: PUSH
103073: LD_INT 3
103075: ST_TO_ADDR
103076: GO 103457
103078: LD_INT 16
103080: DOUBLE
103081: EQUAL
103082: IFTRUE 103086
103084: GO 103097
103086: POP
// bc_type := b_ext_gun ; 17 :
103087: LD_ADDR_OWVAR 42
103091: PUSH
103092: LD_INT 17
103094: ST_TO_ADDR
103095: GO 103457
103097: LD_INT 17
103099: DOUBLE
103100: EQUAL
103101: IFTRUE 103105
103103: GO 103133
103105: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103106: LD_ADDR_OWVAR 42
103110: PUSH
103111: LD_INT 19
103113: PUSH
103114: LD_INT 23
103116: PUSH
103117: LD_INT 19
103119: PUSH
103120: EMPTY
103121: LIST
103122: LIST
103123: LIST
103124: PUSH
103125: LD_VAR 0 1
103129: ARRAY
103130: ST_TO_ADDR
103131: GO 103457
103133: LD_INT 18
103135: DOUBLE
103136: EQUAL
103137: IFTRUE 103141
103139: GO 103152
103141: POP
// bc_type := b_ext_radar ; 19 :
103142: LD_ADDR_OWVAR 42
103146: PUSH
103147: LD_INT 20
103149: ST_TO_ADDR
103150: GO 103457
103152: LD_INT 19
103154: DOUBLE
103155: EQUAL
103156: IFTRUE 103160
103158: GO 103171
103160: POP
// bc_type := b_ext_radio ; 20 :
103161: LD_ADDR_OWVAR 42
103165: PUSH
103166: LD_INT 22
103168: ST_TO_ADDR
103169: GO 103457
103171: LD_INT 20
103173: DOUBLE
103174: EQUAL
103175: IFTRUE 103179
103177: GO 103190
103179: POP
// bc_type := b_ext_siberium ; 21 :
103180: LD_ADDR_OWVAR 42
103184: PUSH
103185: LD_INT 21
103187: ST_TO_ADDR
103188: GO 103457
103190: LD_INT 21
103192: DOUBLE
103193: EQUAL
103194: IFTRUE 103198
103196: GO 103209
103198: POP
// bc_type := b_ext_computer ; 22 :
103199: LD_ADDR_OWVAR 42
103203: PUSH
103204: LD_INT 24
103206: ST_TO_ADDR
103207: GO 103457
103209: LD_INT 22
103211: DOUBLE
103212: EQUAL
103213: IFTRUE 103217
103215: GO 103228
103217: POP
// bc_type := b_ext_track ; 23 :
103218: LD_ADDR_OWVAR 42
103222: PUSH
103223: LD_INT 16
103225: ST_TO_ADDR
103226: GO 103457
103228: LD_INT 23
103230: DOUBLE
103231: EQUAL
103232: IFTRUE 103236
103234: GO 103247
103236: POP
// bc_type := b_ext_laser ; 24 :
103237: LD_ADDR_OWVAR 42
103241: PUSH
103242: LD_INT 25
103244: ST_TO_ADDR
103245: GO 103457
103247: LD_INT 24
103249: DOUBLE
103250: EQUAL
103251: IFTRUE 103255
103253: GO 103266
103255: POP
// bc_type := b_control_tower ; 25 :
103256: LD_ADDR_OWVAR 42
103260: PUSH
103261: LD_INT 36
103263: ST_TO_ADDR
103264: GO 103457
103266: LD_INT 25
103268: DOUBLE
103269: EQUAL
103270: IFTRUE 103274
103272: GO 103285
103274: POP
// bc_type := b_breastwork ; 26 :
103275: LD_ADDR_OWVAR 42
103279: PUSH
103280: LD_INT 31
103282: ST_TO_ADDR
103283: GO 103457
103285: LD_INT 26
103287: DOUBLE
103288: EQUAL
103289: IFTRUE 103293
103291: GO 103304
103293: POP
// bc_type := b_bunker ; 27 :
103294: LD_ADDR_OWVAR 42
103298: PUSH
103299: LD_INT 32
103301: ST_TO_ADDR
103302: GO 103457
103304: LD_INT 27
103306: DOUBLE
103307: EQUAL
103308: IFTRUE 103312
103310: GO 103323
103312: POP
// bc_type := b_turret ; 28 :
103313: LD_ADDR_OWVAR 42
103317: PUSH
103318: LD_INT 33
103320: ST_TO_ADDR
103321: GO 103457
103323: LD_INT 28
103325: DOUBLE
103326: EQUAL
103327: IFTRUE 103331
103329: GO 103342
103331: POP
// bc_type := b_armoury ; 29 :
103332: LD_ADDR_OWVAR 42
103336: PUSH
103337: LD_INT 4
103339: ST_TO_ADDR
103340: GO 103457
103342: LD_INT 29
103344: DOUBLE
103345: EQUAL
103346: IFTRUE 103350
103348: GO 103361
103350: POP
// bc_type := b_barracks ; 30 :
103351: LD_ADDR_OWVAR 42
103355: PUSH
103356: LD_INT 5
103358: ST_TO_ADDR
103359: GO 103457
103361: LD_INT 30
103363: DOUBLE
103364: EQUAL
103365: IFTRUE 103369
103367: GO 103380
103369: POP
// bc_type := b_solar_power ; 31 :
103370: LD_ADDR_OWVAR 42
103374: PUSH
103375: LD_INT 27
103377: ST_TO_ADDR
103378: GO 103457
103380: LD_INT 31
103382: DOUBLE
103383: EQUAL
103384: IFTRUE 103388
103386: GO 103399
103388: POP
// bc_type := b_oil_power ; 32 :
103389: LD_ADDR_OWVAR 42
103393: PUSH
103394: LD_INT 26
103396: ST_TO_ADDR
103397: GO 103457
103399: LD_INT 32
103401: DOUBLE
103402: EQUAL
103403: IFTRUE 103407
103405: GO 103418
103407: POP
// bc_type := b_siberite_power ; 33 :
103408: LD_ADDR_OWVAR 42
103412: PUSH
103413: LD_INT 28
103415: ST_TO_ADDR
103416: GO 103457
103418: LD_INT 33
103420: DOUBLE
103421: EQUAL
103422: IFTRUE 103426
103424: GO 103437
103426: POP
// bc_type := b_oil_mine ; 34 :
103427: LD_ADDR_OWVAR 42
103431: PUSH
103432: LD_INT 29
103434: ST_TO_ADDR
103435: GO 103457
103437: LD_INT 34
103439: DOUBLE
103440: EQUAL
103441: IFTRUE 103445
103443: GO 103456
103445: POP
// bc_type := b_siberite_mine ; end ;
103446: LD_ADDR_OWVAR 42
103450: PUSH
103451: LD_INT 30
103453: ST_TO_ADDR
103454: GO 103457
103456: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103457: LD_ADDR_VAR 0 8
103461: PUSH
103462: LD_VAR 0 5
103466: PPUSH
103467: LD_VAR 0 6
103471: PPUSH
103472: LD_VAR 0 3
103476: PPUSH
103477: CALL_OW 47
103481: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103482: LD_OWVAR 42
103486: PUSH
103487: LD_INT 32
103489: PUSH
103490: LD_INT 33
103492: PUSH
103493: EMPTY
103494: LIST
103495: LIST
103496: IN
103497: IFFALSE 103513
// PlaceWeaponTurret ( b , weapon ) ;
103499: LD_VAR 0 8
103503: PPUSH
103504: LD_VAR 0 4
103508: PPUSH
103509: CALL_OW 431
// end ;
103513: LD_VAR 0 7
103517: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103518: LD_INT 0
103520: PPUSH
103521: PPUSH
103522: PPUSH
103523: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103524: LD_ADDR_VAR 0 4
103528: PUSH
103529: LD_INT 22
103531: PUSH
103532: LD_OWVAR 2
103536: PUSH
103537: EMPTY
103538: LIST
103539: LIST
103540: PUSH
103541: LD_INT 2
103543: PUSH
103544: LD_INT 30
103546: PUSH
103547: LD_INT 0
103549: PUSH
103550: EMPTY
103551: LIST
103552: LIST
103553: PUSH
103554: LD_INT 30
103556: PUSH
103557: LD_INT 1
103559: PUSH
103560: EMPTY
103561: LIST
103562: LIST
103563: PUSH
103564: EMPTY
103565: LIST
103566: LIST
103567: LIST
103568: PUSH
103569: EMPTY
103570: LIST
103571: LIST
103572: PPUSH
103573: CALL_OW 69
103577: ST_TO_ADDR
// if not tmp then
103578: LD_VAR 0 4
103582: NOT
103583: IFFALSE 103587
// exit ;
103585: GO 103646
// for i in tmp do
103587: LD_ADDR_VAR 0 2
103591: PUSH
103592: LD_VAR 0 4
103596: PUSH
103597: FOR_IN
103598: IFFALSE 103644
// for j = 1 to 3 do
103600: LD_ADDR_VAR 0 3
103604: PUSH
103605: DOUBLE
103606: LD_INT 1
103608: DEC
103609: ST_TO_ADDR
103610: LD_INT 3
103612: PUSH
103613: FOR_TO
103614: IFFALSE 103640
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103616: LD_VAR 0 2
103620: PPUSH
103621: CALL_OW 274
103625: PPUSH
103626: LD_VAR 0 3
103630: PPUSH
103631: LD_INT 99999
103633: PPUSH
103634: CALL_OW 277
103638: GO 103613
103640: POP
103641: POP
103642: GO 103597
103644: POP
103645: POP
// end ;
103646: LD_VAR 0 1
103650: RET
// export function hHackSetLevel10 ; var i , j ; begin
103651: LD_INT 0
103653: PPUSH
103654: PPUSH
103655: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103656: LD_ADDR_VAR 0 2
103660: PUSH
103661: LD_INT 21
103663: PUSH
103664: LD_INT 1
103666: PUSH
103667: EMPTY
103668: LIST
103669: LIST
103670: PPUSH
103671: CALL_OW 69
103675: PUSH
103676: FOR_IN
103677: IFFALSE 103729
// if IsSelected ( i ) then
103679: LD_VAR 0 2
103683: PPUSH
103684: CALL_OW 306
103688: IFFALSE 103727
// begin for j := 1 to 4 do
103690: LD_ADDR_VAR 0 3
103694: PUSH
103695: DOUBLE
103696: LD_INT 1
103698: DEC
103699: ST_TO_ADDR
103700: LD_INT 4
103702: PUSH
103703: FOR_TO
103704: IFFALSE 103725
// SetSkill ( i , j , 10 ) ;
103706: LD_VAR 0 2
103710: PPUSH
103711: LD_VAR 0 3
103715: PPUSH
103716: LD_INT 10
103718: PPUSH
103719: CALL_OW 237
103723: GO 103703
103725: POP
103726: POP
// end ;
103727: GO 103676
103729: POP
103730: POP
// end ;
103731: LD_VAR 0 1
103735: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103736: LD_INT 0
103738: PPUSH
103739: PPUSH
103740: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103741: LD_ADDR_VAR 0 2
103745: PUSH
103746: LD_INT 22
103748: PUSH
103749: LD_OWVAR 2
103753: PUSH
103754: EMPTY
103755: LIST
103756: LIST
103757: PUSH
103758: LD_INT 21
103760: PUSH
103761: LD_INT 1
103763: PUSH
103764: EMPTY
103765: LIST
103766: LIST
103767: PUSH
103768: EMPTY
103769: LIST
103770: LIST
103771: PPUSH
103772: CALL_OW 69
103776: PUSH
103777: FOR_IN
103778: IFFALSE 103819
// begin for j := 1 to 4 do
103780: LD_ADDR_VAR 0 3
103784: PUSH
103785: DOUBLE
103786: LD_INT 1
103788: DEC
103789: ST_TO_ADDR
103790: LD_INT 4
103792: PUSH
103793: FOR_TO
103794: IFFALSE 103815
// SetSkill ( i , j , 10 ) ;
103796: LD_VAR 0 2
103800: PPUSH
103801: LD_VAR 0 3
103805: PPUSH
103806: LD_INT 10
103808: PPUSH
103809: CALL_OW 237
103813: GO 103793
103815: POP
103816: POP
// end ;
103817: GO 103777
103819: POP
103820: POP
// end ;
103821: LD_VAR 0 1
103825: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103826: LD_INT 0
103828: PPUSH
// uc_side := your_side ;
103829: LD_ADDR_OWVAR 20
103833: PUSH
103834: LD_OWVAR 2
103838: ST_TO_ADDR
// uc_nation := nation ;
103839: LD_ADDR_OWVAR 21
103843: PUSH
103844: LD_VAR 0 1
103848: ST_TO_ADDR
// InitHc ;
103849: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103853: LD_INT 0
103855: PPUSH
103856: LD_VAR 0 2
103860: PPUSH
103861: LD_VAR 0 3
103865: PPUSH
103866: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103870: LD_VAR 0 4
103874: PPUSH
103875: LD_VAR 0 5
103879: PPUSH
103880: CALL_OW 428
103884: PUSH
103885: LD_INT 0
103887: EQUAL
103888: IFFALSE 103912
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103890: CALL_OW 44
103894: PPUSH
103895: LD_VAR 0 4
103899: PPUSH
103900: LD_VAR 0 5
103904: PPUSH
103905: LD_INT 1
103907: PPUSH
103908: CALL_OW 48
// end ;
103912: LD_VAR 0 6
103916: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103917: LD_INT 0
103919: PPUSH
103920: PPUSH
// uc_side := your_side ;
103921: LD_ADDR_OWVAR 20
103925: PUSH
103926: LD_OWVAR 2
103930: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103931: LD_VAR 0 1
103935: PUSH
103936: LD_INT 1
103938: PUSH
103939: LD_INT 2
103941: PUSH
103942: LD_INT 3
103944: PUSH
103945: LD_INT 4
103947: PUSH
103948: LD_INT 5
103950: PUSH
103951: EMPTY
103952: LIST
103953: LIST
103954: LIST
103955: LIST
103956: LIST
103957: IN
103958: IFFALSE 103970
// uc_nation := nation_american else
103960: LD_ADDR_OWVAR 21
103964: PUSH
103965: LD_INT 1
103967: ST_TO_ADDR
103968: GO 104013
// if chassis in [ 11 , 12 , 13 , 14 ] then
103970: LD_VAR 0 1
103974: PUSH
103975: LD_INT 11
103977: PUSH
103978: LD_INT 12
103980: PUSH
103981: LD_INT 13
103983: PUSH
103984: LD_INT 14
103986: PUSH
103987: EMPTY
103988: LIST
103989: LIST
103990: LIST
103991: LIST
103992: IN
103993: IFFALSE 104005
// uc_nation := nation_arabian else
103995: LD_ADDR_OWVAR 21
103999: PUSH
104000: LD_INT 2
104002: ST_TO_ADDR
104003: GO 104013
// uc_nation := nation_russian ;
104005: LD_ADDR_OWVAR 21
104009: PUSH
104010: LD_INT 3
104012: ST_TO_ADDR
// vc_chassis := chassis ;
104013: LD_ADDR_OWVAR 37
104017: PUSH
104018: LD_VAR 0 1
104022: ST_TO_ADDR
// vc_engine := engine ;
104023: LD_ADDR_OWVAR 39
104027: PUSH
104028: LD_VAR 0 2
104032: ST_TO_ADDR
// vc_control := control ;
104033: LD_ADDR_OWVAR 38
104037: PUSH
104038: LD_VAR 0 3
104042: ST_TO_ADDR
// vc_weapon := weapon ;
104043: LD_ADDR_OWVAR 40
104047: PUSH
104048: LD_VAR 0 4
104052: ST_TO_ADDR
// un := CreateVehicle ;
104053: LD_ADDR_VAR 0 8
104057: PUSH
104058: CALL_OW 45
104062: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104063: LD_VAR 0 8
104067: PPUSH
104068: LD_INT 0
104070: PPUSH
104071: LD_INT 5
104073: PPUSH
104074: CALL_OW 12
104078: PPUSH
104079: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104083: LD_VAR 0 8
104087: PPUSH
104088: LD_VAR 0 5
104092: PPUSH
104093: LD_VAR 0 6
104097: PPUSH
104098: LD_INT 1
104100: PPUSH
104101: CALL_OW 48
// end ;
104105: LD_VAR 0 7
104109: RET
// export hInvincible ; every 1 do
104110: GO 104112
104112: DISABLE
// hInvincible := [ ] ;
104113: LD_ADDR_EXP 152
104117: PUSH
104118: EMPTY
104119: ST_TO_ADDR
104120: END
// every 10 do var i ;
104121: GO 104123
104123: DISABLE
104124: LD_INT 0
104126: PPUSH
// begin enable ;
104127: ENABLE
// if not hInvincible then
104128: LD_EXP 152
104132: NOT
104133: IFFALSE 104137
// exit ;
104135: GO 104181
// for i in hInvincible do
104137: LD_ADDR_VAR 0 1
104141: PUSH
104142: LD_EXP 152
104146: PUSH
104147: FOR_IN
104148: IFFALSE 104179
// if GetLives ( i ) < 1000 then
104150: LD_VAR 0 1
104154: PPUSH
104155: CALL_OW 256
104159: PUSH
104160: LD_INT 1000
104162: LESS
104163: IFFALSE 104177
// SetLives ( i , 1000 ) ;
104165: LD_VAR 0 1
104169: PPUSH
104170: LD_INT 1000
104172: PPUSH
104173: CALL_OW 234
104177: GO 104147
104179: POP
104180: POP
// end ;
104181: PPOPN 1
104183: END
// export function hHackInvincible ; var i ; begin
104184: LD_INT 0
104186: PPUSH
104187: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104188: LD_ADDR_VAR 0 2
104192: PUSH
104193: LD_INT 2
104195: PUSH
104196: LD_INT 21
104198: PUSH
104199: LD_INT 1
104201: PUSH
104202: EMPTY
104203: LIST
104204: LIST
104205: PUSH
104206: LD_INT 21
104208: PUSH
104209: LD_INT 2
104211: PUSH
104212: EMPTY
104213: LIST
104214: LIST
104215: PUSH
104216: EMPTY
104217: LIST
104218: LIST
104219: LIST
104220: PPUSH
104221: CALL_OW 69
104225: PUSH
104226: FOR_IN
104227: IFFALSE 104288
// if IsSelected ( i ) then
104229: LD_VAR 0 2
104233: PPUSH
104234: CALL_OW 306
104238: IFFALSE 104286
// begin if i in hInvincible then
104240: LD_VAR 0 2
104244: PUSH
104245: LD_EXP 152
104249: IN
104250: IFFALSE 104270
// hInvincible := hInvincible diff i else
104252: LD_ADDR_EXP 152
104256: PUSH
104257: LD_EXP 152
104261: PUSH
104262: LD_VAR 0 2
104266: DIFF
104267: ST_TO_ADDR
104268: GO 104286
// hInvincible := hInvincible union i ;
104270: LD_ADDR_EXP 152
104274: PUSH
104275: LD_EXP 152
104279: PUSH
104280: LD_VAR 0 2
104284: UNION
104285: ST_TO_ADDR
// end ;
104286: GO 104226
104288: POP
104289: POP
// end ;
104290: LD_VAR 0 1
104294: RET
// export function hHackInvisible ; var i , j ; begin
104295: LD_INT 0
104297: PPUSH
104298: PPUSH
104299: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104300: LD_ADDR_VAR 0 2
104304: PUSH
104305: LD_INT 21
104307: PUSH
104308: LD_INT 1
104310: PUSH
104311: EMPTY
104312: LIST
104313: LIST
104314: PPUSH
104315: CALL_OW 69
104319: PUSH
104320: FOR_IN
104321: IFFALSE 104345
// if IsSelected ( i ) then
104323: LD_VAR 0 2
104327: PPUSH
104328: CALL_OW 306
104332: IFFALSE 104343
// ComForceInvisible ( i ) ;
104334: LD_VAR 0 2
104338: PPUSH
104339: CALL_OW 496
104343: GO 104320
104345: POP
104346: POP
// end ;
104347: LD_VAR 0 1
104351: RET
// export function hHackChangeYourSide ; begin
104352: LD_INT 0
104354: PPUSH
// if your_side = 8 then
104355: LD_OWVAR 2
104359: PUSH
104360: LD_INT 8
104362: EQUAL
104363: IFFALSE 104375
// your_side := 0 else
104365: LD_ADDR_OWVAR 2
104369: PUSH
104370: LD_INT 0
104372: ST_TO_ADDR
104373: GO 104389
// your_side := your_side + 1 ;
104375: LD_ADDR_OWVAR 2
104379: PUSH
104380: LD_OWVAR 2
104384: PUSH
104385: LD_INT 1
104387: PLUS
104388: ST_TO_ADDR
// end ;
104389: LD_VAR 0 1
104393: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104394: LD_INT 0
104396: PPUSH
104397: PPUSH
104398: PPUSH
// for i in all_units do
104399: LD_ADDR_VAR 0 2
104403: PUSH
104404: LD_OWVAR 3
104408: PUSH
104409: FOR_IN
104410: IFFALSE 104488
// if IsSelected ( i ) then
104412: LD_VAR 0 2
104416: PPUSH
104417: CALL_OW 306
104421: IFFALSE 104486
// begin j := GetSide ( i ) ;
104423: LD_ADDR_VAR 0 3
104427: PUSH
104428: LD_VAR 0 2
104432: PPUSH
104433: CALL_OW 255
104437: ST_TO_ADDR
// if j = 8 then
104438: LD_VAR 0 3
104442: PUSH
104443: LD_INT 8
104445: EQUAL
104446: IFFALSE 104458
// j := 0 else
104448: LD_ADDR_VAR 0 3
104452: PUSH
104453: LD_INT 0
104455: ST_TO_ADDR
104456: GO 104472
// j := j + 1 ;
104458: LD_ADDR_VAR 0 3
104462: PUSH
104463: LD_VAR 0 3
104467: PUSH
104468: LD_INT 1
104470: PLUS
104471: ST_TO_ADDR
// SetSide ( i , j ) ;
104472: LD_VAR 0 2
104476: PPUSH
104477: LD_VAR 0 3
104481: PPUSH
104482: CALL_OW 235
// end ;
104486: GO 104409
104488: POP
104489: POP
// end ;
104490: LD_VAR 0 1
104494: RET
// export function hHackFog ; begin
104495: LD_INT 0
104497: PPUSH
// FogOff ( true ) ;
104498: LD_INT 1
104500: PPUSH
104501: CALL_OW 344
// end ;
104505: LD_VAR 0 1
104509: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104510: LD_INT 0
104512: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104513: LD_VAR 0 1
104517: PPUSH
104518: LD_VAR 0 2
104522: PPUSH
104523: LD_VAR 0 3
104527: PPUSH
104528: LD_INT 1
104530: PPUSH
104531: LD_INT 1
104533: PPUSH
104534: CALL_OW 483
// CenterOnXY ( x , y ) ;
104538: LD_VAR 0 2
104542: PPUSH
104543: LD_VAR 0 3
104547: PPUSH
104548: CALL_OW 84
// end ;
104552: LD_VAR 0 4
104556: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104557: LD_INT 0
104559: PPUSH
104560: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104561: LD_VAR 0 1
104565: NOT
104566: PUSH
104567: LD_VAR 0 2
104571: PPUSH
104572: LD_VAR 0 3
104576: PPUSH
104577: CALL_OW 488
104581: NOT
104582: OR
104583: PUSH
104584: LD_VAR 0 1
104588: PPUSH
104589: CALL_OW 266
104593: PUSH
104594: LD_INT 3
104596: NONEQUAL
104597: PUSH
104598: LD_VAR 0 1
104602: PPUSH
104603: CALL_OW 247
104607: PUSH
104608: LD_INT 1
104610: EQUAL
104611: NOT
104612: AND
104613: OR
104614: IFFALSE 104618
// exit ;
104616: GO 104767
// if GetType ( factory ) = unit_human then
104618: LD_VAR 0 1
104622: PPUSH
104623: CALL_OW 247
104627: PUSH
104628: LD_INT 1
104630: EQUAL
104631: IFFALSE 104648
// factory := IsInUnit ( factory ) ;
104633: LD_ADDR_VAR 0 1
104637: PUSH
104638: LD_VAR 0 1
104642: PPUSH
104643: CALL_OW 310
104647: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
104648: LD_VAR 0 1
104652: PPUSH
104653: CALL_OW 266
104657: PUSH
104658: LD_INT 3
104660: NONEQUAL
104661: IFFALSE 104665
// exit ;
104663: GO 104767
// if HexInfo ( x , y ) = factory then
104665: LD_VAR 0 2
104669: PPUSH
104670: LD_VAR 0 3
104674: PPUSH
104675: CALL_OW 428
104679: PUSH
104680: LD_VAR 0 1
104684: EQUAL
104685: IFFALSE 104712
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
104687: LD_ADDR_EXP 153
104691: PUSH
104692: LD_EXP 153
104696: PPUSH
104697: LD_VAR 0 1
104701: PPUSH
104702: LD_INT 0
104704: PPUSH
104705: CALL_OW 1
104709: ST_TO_ADDR
104710: GO 104763
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104712: LD_ADDR_EXP 153
104716: PUSH
104717: LD_EXP 153
104721: PPUSH
104722: LD_VAR 0 1
104726: PPUSH
104727: LD_VAR 0 1
104731: PPUSH
104732: CALL_OW 255
104736: PUSH
104737: LD_VAR 0 1
104741: PUSH
104742: LD_VAR 0 2
104746: PUSH
104747: LD_VAR 0 3
104751: PUSH
104752: EMPTY
104753: LIST
104754: LIST
104755: LIST
104756: LIST
104757: PPUSH
104758: CALL_OW 1
104762: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104763: CALL 104772 0 0
// end ;
104767: LD_VAR 0 4
104771: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
104772: LD_INT 0
104774: PPUSH
104775: PPUSH
104776: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104777: LD_STRING resetFactoryWaypoint();
104779: PPUSH
104780: CALL_OW 559
// if factoryWaypoints then
104784: LD_EXP 153
104788: IFFALSE 104914
// begin list := PrepareArray ( factoryWaypoints ) ;
104790: LD_ADDR_VAR 0 3
104794: PUSH
104795: LD_EXP 153
104799: PPUSH
104800: CALL 89874 0 1
104804: ST_TO_ADDR
// for i := 1 to list do
104805: LD_ADDR_VAR 0 2
104809: PUSH
104810: DOUBLE
104811: LD_INT 1
104813: DEC
104814: ST_TO_ADDR
104815: LD_VAR 0 3
104819: PUSH
104820: FOR_TO
104821: IFFALSE 104912
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104823: LD_STRING setFactoryWaypointXY(
104825: PUSH
104826: LD_VAR 0 3
104830: PUSH
104831: LD_VAR 0 2
104835: ARRAY
104836: PUSH
104837: LD_INT 1
104839: ARRAY
104840: STR
104841: PUSH
104842: LD_STRING ,
104844: STR
104845: PUSH
104846: LD_VAR 0 3
104850: PUSH
104851: LD_VAR 0 2
104855: ARRAY
104856: PUSH
104857: LD_INT 2
104859: ARRAY
104860: STR
104861: PUSH
104862: LD_STRING ,
104864: STR
104865: PUSH
104866: LD_VAR 0 3
104870: PUSH
104871: LD_VAR 0 2
104875: ARRAY
104876: PUSH
104877: LD_INT 3
104879: ARRAY
104880: STR
104881: PUSH
104882: LD_STRING ,
104884: STR
104885: PUSH
104886: LD_VAR 0 3
104890: PUSH
104891: LD_VAR 0 2
104895: ARRAY
104896: PUSH
104897: LD_INT 4
104899: ARRAY
104900: STR
104901: PUSH
104902: LD_STRING )
104904: STR
104905: PPUSH
104906: CALL_OW 559
104910: GO 104820
104912: POP
104913: POP
// end ; end ;
104914: LD_VAR 0 1
104918: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
104919: LD_INT 0
104921: PPUSH
// if HexInfo ( x , y ) = warehouse then
104922: LD_VAR 0 2
104926: PPUSH
104927: LD_VAR 0 3
104931: PPUSH
104932: CALL_OW 428
104936: PUSH
104937: LD_VAR 0 1
104941: EQUAL
104942: IFFALSE 104969
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
104944: LD_ADDR_EXP 154
104948: PUSH
104949: LD_EXP 154
104953: PPUSH
104954: LD_VAR 0 1
104958: PPUSH
104959: LD_INT 0
104961: PPUSH
104962: CALL_OW 1
104966: ST_TO_ADDR
104967: GO 105020
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
104969: LD_ADDR_EXP 154
104973: PUSH
104974: LD_EXP 154
104978: PPUSH
104979: LD_VAR 0 1
104983: PPUSH
104984: LD_VAR 0 1
104988: PPUSH
104989: CALL_OW 255
104993: PUSH
104994: LD_VAR 0 1
104998: PUSH
104999: LD_VAR 0 2
105003: PUSH
105004: LD_VAR 0 3
105008: PUSH
105009: EMPTY
105010: LIST
105011: LIST
105012: LIST
105013: LIST
105014: PPUSH
105015: CALL_OW 1
105019: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
105020: CALL 105029 0 0
// end ;
105024: LD_VAR 0 4
105028: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
105029: LD_INT 0
105031: PPUSH
105032: PPUSH
105033: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
105034: LD_STRING resetWarehouseGatheringPoints();
105036: PPUSH
105037: CALL_OW 559
// if warehouseGatheringPoints then
105041: LD_EXP 154
105045: IFFALSE 105171
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
105047: LD_ADDR_VAR 0 3
105051: PUSH
105052: LD_EXP 154
105056: PPUSH
105057: CALL 89874 0 1
105061: ST_TO_ADDR
// for i := 1 to list do
105062: LD_ADDR_VAR 0 2
105066: PUSH
105067: DOUBLE
105068: LD_INT 1
105070: DEC
105071: ST_TO_ADDR
105072: LD_VAR 0 3
105076: PUSH
105077: FOR_TO
105078: IFFALSE 105169
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105080: LD_STRING setWarehouseGatheringPointXY(
105082: PUSH
105083: LD_VAR 0 3
105087: PUSH
105088: LD_VAR 0 2
105092: ARRAY
105093: PUSH
105094: LD_INT 1
105096: ARRAY
105097: STR
105098: PUSH
105099: LD_STRING ,
105101: STR
105102: PUSH
105103: LD_VAR 0 3
105107: PUSH
105108: LD_VAR 0 2
105112: ARRAY
105113: PUSH
105114: LD_INT 2
105116: ARRAY
105117: STR
105118: PUSH
105119: LD_STRING ,
105121: STR
105122: PUSH
105123: LD_VAR 0 3
105127: PUSH
105128: LD_VAR 0 2
105132: ARRAY
105133: PUSH
105134: LD_INT 3
105136: ARRAY
105137: STR
105138: PUSH
105139: LD_STRING ,
105141: STR
105142: PUSH
105143: LD_VAR 0 3
105147: PUSH
105148: LD_VAR 0 2
105152: ARRAY
105153: PUSH
105154: LD_INT 4
105156: ARRAY
105157: STR
105158: PUSH
105159: LD_STRING )
105161: STR
105162: PPUSH
105163: CALL_OW 559
105167: GO 105077
105169: POP
105170: POP
// end ; end ;
105171: LD_VAR 0 1
105175: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
105176: LD_EXP 154
105180: IFFALSE 105865
105182: GO 105184
105184: DISABLE
105185: LD_INT 0
105187: PPUSH
105188: PPUSH
105189: PPUSH
105190: PPUSH
105191: PPUSH
105192: PPUSH
105193: PPUSH
105194: PPUSH
105195: PPUSH
// begin enable ;
105196: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
105197: LD_ADDR_VAR 0 3
105201: PUSH
105202: LD_EXP 154
105206: PPUSH
105207: CALL 89874 0 1
105211: ST_TO_ADDR
// if not list then
105212: LD_VAR 0 3
105216: NOT
105217: IFFALSE 105221
// exit ;
105219: GO 105865
// for i := 1 to list do
105221: LD_ADDR_VAR 0 1
105225: PUSH
105226: DOUBLE
105227: LD_INT 1
105229: DEC
105230: ST_TO_ADDR
105231: LD_VAR 0 3
105235: PUSH
105236: FOR_TO
105237: IFFALSE 105863
// begin depot := list [ i ] [ 2 ] ;
105239: LD_ADDR_VAR 0 8
105243: PUSH
105244: LD_VAR 0 3
105248: PUSH
105249: LD_VAR 0 1
105253: ARRAY
105254: PUSH
105255: LD_INT 2
105257: ARRAY
105258: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
105259: LD_ADDR_VAR 0 5
105263: PUSH
105264: LD_VAR 0 3
105268: PUSH
105269: LD_VAR 0 1
105273: ARRAY
105274: PUSH
105275: LD_INT 1
105277: ARRAY
105278: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105279: LD_VAR 0 8
105283: PPUSH
105284: CALL_OW 301
105288: PUSH
105289: LD_VAR 0 5
105293: PUSH
105294: LD_VAR 0 8
105298: PPUSH
105299: CALL_OW 255
105303: NONEQUAL
105304: OR
105305: IFFALSE 105334
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105307: LD_ADDR_EXP 154
105311: PUSH
105312: LD_EXP 154
105316: PPUSH
105317: LD_VAR 0 8
105321: PPUSH
105322: LD_INT 0
105324: PPUSH
105325: CALL_OW 1
105329: ST_TO_ADDR
// exit ;
105330: POP
105331: POP
105332: GO 105865
// end ; x := list [ i ] [ 3 ] ;
105334: LD_ADDR_VAR 0 6
105338: PUSH
105339: LD_VAR 0 3
105343: PUSH
105344: LD_VAR 0 1
105348: ARRAY
105349: PUSH
105350: LD_INT 3
105352: ARRAY
105353: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105354: LD_ADDR_VAR 0 7
105358: PUSH
105359: LD_VAR 0 3
105363: PUSH
105364: LD_VAR 0 1
105368: ARRAY
105369: PUSH
105370: LD_INT 4
105372: ARRAY
105373: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105374: LD_ADDR_VAR 0 9
105378: PUSH
105379: LD_VAR 0 6
105383: PPUSH
105384: LD_VAR 0 7
105388: PPUSH
105389: LD_INT 16
105391: PPUSH
105392: CALL 88462 0 3
105396: ST_TO_ADDR
// if not cratesNearbyPoint then
105397: LD_VAR 0 9
105401: NOT
105402: IFFALSE 105408
// exit ;
105404: POP
105405: POP
105406: GO 105865
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105408: LD_ADDR_VAR 0 4
105412: PUSH
105413: LD_INT 22
105415: PUSH
105416: LD_VAR 0 5
105420: PUSH
105421: EMPTY
105422: LIST
105423: LIST
105424: PUSH
105425: LD_INT 3
105427: PUSH
105428: LD_INT 60
105430: PUSH
105431: EMPTY
105432: LIST
105433: PUSH
105434: EMPTY
105435: LIST
105436: LIST
105437: PUSH
105438: LD_INT 91
105440: PUSH
105441: LD_VAR 0 8
105445: PUSH
105446: LD_INT 6
105448: PUSH
105449: EMPTY
105450: LIST
105451: LIST
105452: LIST
105453: PUSH
105454: LD_INT 2
105456: PUSH
105457: LD_INT 25
105459: PUSH
105460: LD_INT 2
105462: PUSH
105463: EMPTY
105464: LIST
105465: LIST
105466: PUSH
105467: LD_INT 25
105469: PUSH
105470: LD_INT 16
105472: PUSH
105473: EMPTY
105474: LIST
105475: LIST
105476: PUSH
105477: EMPTY
105478: LIST
105479: LIST
105480: LIST
105481: PUSH
105482: EMPTY
105483: LIST
105484: LIST
105485: LIST
105486: LIST
105487: PPUSH
105488: CALL_OW 69
105492: PUSH
105493: LD_VAR 0 8
105497: PPUSH
105498: CALL_OW 313
105502: PPUSH
105503: LD_INT 3
105505: PUSH
105506: LD_INT 60
105508: PUSH
105509: EMPTY
105510: LIST
105511: PUSH
105512: EMPTY
105513: LIST
105514: LIST
105515: PUSH
105516: LD_INT 2
105518: PUSH
105519: LD_INT 25
105521: PUSH
105522: LD_INT 2
105524: PUSH
105525: EMPTY
105526: LIST
105527: LIST
105528: PUSH
105529: LD_INT 25
105531: PUSH
105532: LD_INT 16
105534: PUSH
105535: EMPTY
105536: LIST
105537: LIST
105538: PUSH
105539: EMPTY
105540: LIST
105541: LIST
105542: LIST
105543: PUSH
105544: EMPTY
105545: LIST
105546: LIST
105547: PPUSH
105548: CALL_OW 72
105552: UNION
105553: ST_TO_ADDR
// if tmp then
105554: LD_VAR 0 4
105558: IFFALSE 105638
// begin tmp := ShrinkArray ( tmp , 3 ) ;
105560: LD_ADDR_VAR 0 4
105564: PUSH
105565: LD_VAR 0 4
105569: PPUSH
105570: LD_INT 3
105572: PPUSH
105573: CALL 86431 0 2
105577: ST_TO_ADDR
// for j in tmp do
105578: LD_ADDR_VAR 0 2
105582: PUSH
105583: LD_VAR 0 4
105587: PUSH
105588: FOR_IN
105589: IFFALSE 105632
// begin if IsInUnit ( j ) then
105591: LD_VAR 0 2
105595: PPUSH
105596: CALL_OW 310
105600: IFFALSE 105611
// ComExit ( j ) ;
105602: LD_VAR 0 2
105606: PPUSH
105607: CALL 86514 0 1
// AddComCollect ( j , x , y ) ;
105611: LD_VAR 0 2
105615: PPUSH
105616: LD_VAR 0 6
105620: PPUSH
105621: LD_VAR 0 7
105625: PPUSH
105626: CALL_OW 177
// end ;
105630: GO 105588
105632: POP
105633: POP
// exit ;
105634: POP
105635: POP
105636: GO 105865
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
105638: LD_ADDR_VAR 0 4
105642: PUSH
105643: LD_INT 22
105645: PUSH
105646: LD_VAR 0 5
105650: PUSH
105651: EMPTY
105652: LIST
105653: LIST
105654: PUSH
105655: LD_INT 91
105657: PUSH
105658: LD_VAR 0 8
105662: PUSH
105663: LD_INT 8
105665: PUSH
105666: EMPTY
105667: LIST
105668: LIST
105669: LIST
105670: PUSH
105671: LD_INT 2
105673: PUSH
105674: LD_INT 34
105676: PUSH
105677: LD_INT 12
105679: PUSH
105680: EMPTY
105681: LIST
105682: LIST
105683: PUSH
105684: LD_INT 34
105686: PUSH
105687: LD_INT 51
105689: PUSH
105690: EMPTY
105691: LIST
105692: LIST
105693: PUSH
105694: LD_INT 34
105696: PUSH
105697: LD_INT 32
105699: PUSH
105700: EMPTY
105701: LIST
105702: LIST
105703: PUSH
105704: LD_INT 34
105706: PUSH
105707: LD_INT 89
105709: PUSH
105710: EMPTY
105711: LIST
105712: LIST
105713: PUSH
105714: EMPTY
105715: LIST
105716: LIST
105717: LIST
105718: LIST
105719: LIST
105720: PUSH
105721: EMPTY
105722: LIST
105723: LIST
105724: LIST
105725: PPUSH
105726: CALL_OW 69
105730: ST_TO_ADDR
// if tmp then
105731: LD_VAR 0 4
105735: IFFALSE 105861
// begin for j in tmp do
105737: LD_ADDR_VAR 0 2
105741: PUSH
105742: LD_VAR 0 4
105746: PUSH
105747: FOR_IN
105748: IFFALSE 105859
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
105750: LD_VAR 0 2
105754: PPUSH
105755: CALL_OW 262
105759: PUSH
105760: LD_INT 3
105762: EQUAL
105763: PUSH
105764: LD_VAR 0 2
105768: PPUSH
105769: CALL_OW 261
105773: PUSH
105774: LD_INT 20
105776: GREATER
105777: OR
105778: PUSH
105779: LD_VAR 0 2
105783: PPUSH
105784: CALL_OW 314
105788: NOT
105789: AND
105790: PUSH
105791: LD_VAR 0 2
105795: PPUSH
105796: CALL_OW 263
105800: PUSH
105801: LD_INT 1
105803: NONEQUAL
105804: PUSH
105805: LD_VAR 0 2
105809: PPUSH
105810: CALL_OW 311
105814: OR
105815: AND
105816: IFFALSE 105857
// begin ComCollect ( j , x , y ) ;
105818: LD_VAR 0 2
105822: PPUSH
105823: LD_VAR 0 6
105827: PPUSH
105828: LD_VAR 0 7
105832: PPUSH
105833: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
105837: LD_VAR 0 2
105841: PPUSH
105842: LD_VAR 0 8
105846: PPUSH
105847: CALL_OW 172
// exit ;
105851: POP
105852: POP
105853: POP
105854: POP
105855: GO 105865
// end ;
105857: GO 105747
105859: POP
105860: POP
// end ; end ;
105861: GO 105236
105863: POP
105864: POP
// end ; end_of_file
105865: PPOPN 9
105867: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105868: LD_INT 0
105870: PPUSH
105871: PPUSH
105872: PPUSH
105873: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105874: LD_VAR 0 1
105878: PPUSH
105879: CALL_OW 264
105883: PUSH
105884: LD_INT 91
105886: EQUAL
105887: IFFALSE 105959
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105889: LD_INT 68
105891: PPUSH
105892: LD_VAR 0 1
105896: PPUSH
105897: CALL_OW 255
105901: PPUSH
105902: CALL_OW 321
105906: PUSH
105907: LD_INT 2
105909: EQUAL
105910: IFFALSE 105922
// eff := 70 else
105912: LD_ADDR_VAR 0 4
105916: PUSH
105917: LD_INT 70
105919: ST_TO_ADDR
105920: GO 105930
// eff := 30 ;
105922: LD_ADDR_VAR 0 4
105926: PUSH
105927: LD_INT 30
105929: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105930: LD_VAR 0 1
105934: PPUSH
105935: CALL_OW 250
105939: PPUSH
105940: LD_VAR 0 1
105944: PPUSH
105945: CALL_OW 251
105949: PPUSH
105950: LD_VAR 0 4
105954: PPUSH
105955: CALL_OW 495
// end ; end ;
105959: LD_VAR 0 2
105963: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105964: LD_INT 0
105966: PPUSH
// end ;
105967: LD_VAR 0 4
105971: RET
// export function SOS_Command ( cmd ) ; begin
105972: LD_INT 0
105974: PPUSH
// end ;
105975: LD_VAR 0 2
105979: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105980: LD_INT 0
105982: PPUSH
// end ;
105983: LD_VAR 0 6
105987: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
105988: LD_INT 0
105990: PPUSH
105991: PPUSH
// if not vehicle or not factory then
105992: LD_VAR 0 1
105996: NOT
105997: PUSH
105998: LD_VAR 0 2
106002: NOT
106003: OR
106004: IFFALSE 106008
// exit ;
106006: GO 106239
// if factoryWaypoints >= factory then
106008: LD_EXP 153
106012: PUSH
106013: LD_VAR 0 2
106017: GREATEREQUAL
106018: IFFALSE 106239
// if factoryWaypoints [ factory ] then
106020: LD_EXP 153
106024: PUSH
106025: LD_VAR 0 2
106029: ARRAY
106030: IFFALSE 106239
// begin if GetControl ( vehicle ) = control_manual then
106032: LD_VAR 0 1
106036: PPUSH
106037: CALL_OW 263
106041: PUSH
106042: LD_INT 1
106044: EQUAL
106045: IFFALSE 106126
// begin driver := IsDrivenBy ( vehicle ) ;
106047: LD_ADDR_VAR 0 4
106051: PUSH
106052: LD_VAR 0 1
106056: PPUSH
106057: CALL_OW 311
106061: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106062: LD_VAR 0 4
106066: PPUSH
106067: LD_EXP 153
106071: PUSH
106072: LD_VAR 0 2
106076: ARRAY
106077: PUSH
106078: LD_INT 3
106080: ARRAY
106081: PPUSH
106082: LD_EXP 153
106086: PUSH
106087: LD_VAR 0 2
106091: ARRAY
106092: PUSH
106093: LD_INT 4
106095: ARRAY
106096: PPUSH
106097: CALL_OW 171
// AddComExitVehicle ( driver ) ;
106101: LD_VAR 0 4
106105: PPUSH
106106: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
106110: LD_VAR 0 4
106114: PPUSH
106115: LD_VAR 0 2
106119: PPUSH
106120: CALL_OW 180
// end else
106124: GO 106239
// if GetControl ( vehicle ) = control_remote then
106126: LD_VAR 0 1
106130: PPUSH
106131: CALL_OW 263
106135: PUSH
106136: LD_INT 2
106138: EQUAL
106139: IFFALSE 106200
// begin wait ( 0 0$2 ) ;
106141: LD_INT 70
106143: PPUSH
106144: CALL_OW 67
// if Connect ( vehicle ) then
106148: LD_VAR 0 1
106152: PPUSH
106153: CALL 56754 0 1
106157: IFFALSE 106198
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106159: LD_VAR 0 1
106163: PPUSH
106164: LD_EXP 153
106168: PUSH
106169: LD_VAR 0 2
106173: ARRAY
106174: PUSH
106175: LD_INT 3
106177: ARRAY
106178: PPUSH
106179: LD_EXP 153
106183: PUSH
106184: LD_VAR 0 2
106188: ARRAY
106189: PUSH
106190: LD_INT 4
106192: ARRAY
106193: PPUSH
106194: CALL_OW 171
// end else
106198: GO 106239
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106200: LD_VAR 0 1
106204: PPUSH
106205: LD_EXP 153
106209: PUSH
106210: LD_VAR 0 2
106214: ARRAY
106215: PUSH
106216: LD_INT 3
106218: ARRAY
106219: PPUSH
106220: LD_EXP 153
106224: PUSH
106225: LD_VAR 0 2
106229: ARRAY
106230: PUSH
106231: LD_INT 4
106233: ARRAY
106234: PPUSH
106235: CALL_OW 171
// end ; end ;
106239: LD_VAR 0 3
106243: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106244: LD_INT 0
106246: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106247: LD_VAR 0 1
106251: PUSH
106252: LD_INT 250
106254: EQUAL
106255: PUSH
106256: LD_VAR 0 2
106260: PPUSH
106261: CALL_OW 264
106265: PUSH
106266: LD_INT 81
106268: EQUAL
106269: AND
106270: IFFALSE 106291
// MinerPlaceMine ( unit , x , y ) ;
106272: LD_VAR 0 2
106276: PPUSH
106277: LD_VAR 0 4
106281: PPUSH
106282: LD_VAR 0 5
106286: PPUSH
106287: CALL 108676 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106291: LD_VAR 0 1
106295: PUSH
106296: LD_INT 251
106298: EQUAL
106299: PUSH
106300: LD_VAR 0 2
106304: PPUSH
106305: CALL_OW 264
106309: PUSH
106310: LD_INT 81
106312: EQUAL
106313: AND
106314: IFFALSE 106335
// MinerDetonateMine ( unit , x , y ) ;
106316: LD_VAR 0 2
106320: PPUSH
106321: LD_VAR 0 4
106325: PPUSH
106326: LD_VAR 0 5
106330: PPUSH
106331: CALL 108951 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106335: LD_VAR 0 1
106339: PUSH
106340: LD_INT 252
106342: EQUAL
106343: PUSH
106344: LD_VAR 0 2
106348: PPUSH
106349: CALL_OW 264
106353: PUSH
106354: LD_INT 81
106356: EQUAL
106357: AND
106358: IFFALSE 106379
// MinerCreateMinefield ( unit , x , y ) ;
106360: LD_VAR 0 2
106364: PPUSH
106365: LD_VAR 0 4
106369: PPUSH
106370: LD_VAR 0 5
106374: PPUSH
106375: CALL 109368 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106379: LD_VAR 0 1
106383: PUSH
106384: LD_INT 253
106386: EQUAL
106387: PUSH
106388: LD_VAR 0 2
106392: PPUSH
106393: CALL_OW 257
106397: PUSH
106398: LD_INT 5
106400: EQUAL
106401: AND
106402: IFFALSE 106423
// ComBinocular ( unit , x , y ) ;
106404: LD_VAR 0 2
106408: PPUSH
106409: LD_VAR 0 4
106413: PPUSH
106414: LD_VAR 0 5
106418: PPUSH
106419: CALL 109737 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106423: LD_VAR 0 1
106427: PUSH
106428: LD_INT 254
106430: EQUAL
106431: PUSH
106432: LD_VAR 0 2
106436: PPUSH
106437: CALL_OW 264
106441: PUSH
106442: LD_INT 99
106444: EQUAL
106445: AND
106446: PUSH
106447: LD_VAR 0 3
106451: PPUSH
106452: CALL_OW 263
106456: PUSH
106457: LD_INT 3
106459: EQUAL
106460: AND
106461: IFFALSE 106477
// HackDestroyVehicle ( unit , selectedUnit ) ;
106463: LD_VAR 0 2
106467: PPUSH
106468: LD_VAR 0 3
106472: PPUSH
106473: CALL 108040 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
106477: LD_VAR 0 1
106481: PUSH
106482: LD_INT 255
106484: EQUAL
106485: PUSH
106486: LD_VAR 0 2
106490: PPUSH
106491: CALL_OW 264
106495: PUSH
106496: LD_INT 14
106498: PUSH
106499: LD_INT 53
106501: PUSH
106502: EMPTY
106503: LIST
106504: LIST
106505: IN
106506: AND
106507: PUSH
106508: LD_VAR 0 4
106512: PPUSH
106513: LD_VAR 0 5
106517: PPUSH
106518: CALL_OW 488
106522: AND
106523: IFFALSE 106547
// CutTreeXYR ( unit , x , y , 12 ) ;
106525: LD_VAR 0 2
106529: PPUSH
106530: LD_VAR 0 4
106534: PPUSH
106535: LD_VAR 0 5
106539: PPUSH
106540: LD_INT 12
106542: PPUSH
106543: CALL 106610 0 4
// if cmd = 256 then
106547: LD_VAR 0 1
106551: PUSH
106552: LD_INT 256
106554: EQUAL
106555: IFFALSE 106576
// SetFactoryWaypoint ( unit , x , y ) ;
106557: LD_VAR 0 2
106561: PPUSH
106562: LD_VAR 0 4
106566: PPUSH
106567: LD_VAR 0 5
106571: PPUSH
106572: CALL 104557 0 3
// if cmd = 257 then
106576: LD_VAR 0 1
106580: PUSH
106581: LD_INT 257
106583: EQUAL
106584: IFFALSE 106605
// SetWarehouseGatheringPoint ( unit , x , y ) ;
106586: LD_VAR 0 2
106590: PPUSH
106591: LD_VAR 0 4
106595: PPUSH
106596: LD_VAR 0 5
106600: PPUSH
106601: CALL 104919 0 3
// end ;
106605: LD_VAR 0 6
106609: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106610: LD_INT 0
106612: PPUSH
106613: PPUSH
106614: PPUSH
106615: PPUSH
106616: PPUSH
106617: PPUSH
106618: PPUSH
106619: PPUSH
106620: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
106621: LD_VAR 0 1
106625: NOT
106626: PUSH
106627: LD_VAR 0 2
106631: PPUSH
106632: LD_VAR 0 3
106636: PPUSH
106637: CALL_OW 488
106641: NOT
106642: OR
106643: PUSH
106644: LD_VAR 0 4
106648: NOT
106649: OR
106650: IFFALSE 106654
// exit ;
106652: GO 106994
// list := [ ] ;
106654: LD_ADDR_VAR 0 13
106658: PUSH
106659: EMPTY
106660: ST_TO_ADDR
// if x - r < 0 then
106661: LD_VAR 0 2
106665: PUSH
106666: LD_VAR 0 4
106670: MINUS
106671: PUSH
106672: LD_INT 0
106674: LESS
106675: IFFALSE 106687
// min_x := 0 else
106677: LD_ADDR_VAR 0 7
106681: PUSH
106682: LD_INT 0
106684: ST_TO_ADDR
106685: GO 106703
// min_x := x - r ;
106687: LD_ADDR_VAR 0 7
106691: PUSH
106692: LD_VAR 0 2
106696: PUSH
106697: LD_VAR 0 4
106701: MINUS
106702: ST_TO_ADDR
// if y - r < 0 then
106703: LD_VAR 0 3
106707: PUSH
106708: LD_VAR 0 4
106712: MINUS
106713: PUSH
106714: LD_INT 0
106716: LESS
106717: IFFALSE 106729
// min_y := 0 else
106719: LD_ADDR_VAR 0 8
106723: PUSH
106724: LD_INT 0
106726: ST_TO_ADDR
106727: GO 106745
// min_y := y - r ;
106729: LD_ADDR_VAR 0 8
106733: PUSH
106734: LD_VAR 0 3
106738: PUSH
106739: LD_VAR 0 4
106743: MINUS
106744: ST_TO_ADDR
// max_x := x + r ;
106745: LD_ADDR_VAR 0 9
106749: PUSH
106750: LD_VAR 0 2
106754: PUSH
106755: LD_VAR 0 4
106759: PLUS
106760: ST_TO_ADDR
// max_y := y + r ;
106761: LD_ADDR_VAR 0 10
106765: PUSH
106766: LD_VAR 0 3
106770: PUSH
106771: LD_VAR 0 4
106775: PLUS
106776: ST_TO_ADDR
// for _x = min_x to max_x do
106777: LD_ADDR_VAR 0 11
106781: PUSH
106782: DOUBLE
106783: LD_VAR 0 7
106787: DEC
106788: ST_TO_ADDR
106789: LD_VAR 0 9
106793: PUSH
106794: FOR_TO
106795: IFFALSE 106912
// for _y = min_y to max_y do
106797: LD_ADDR_VAR 0 12
106801: PUSH
106802: DOUBLE
106803: LD_VAR 0 8
106807: DEC
106808: ST_TO_ADDR
106809: LD_VAR 0 10
106813: PUSH
106814: FOR_TO
106815: IFFALSE 106908
// begin if not ValidHex ( _x , _y ) then
106817: LD_VAR 0 11
106821: PPUSH
106822: LD_VAR 0 12
106826: PPUSH
106827: CALL_OW 488
106831: NOT
106832: IFFALSE 106836
// continue ;
106834: GO 106814
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106836: LD_VAR 0 11
106840: PPUSH
106841: LD_VAR 0 12
106845: PPUSH
106846: CALL_OW 351
106850: PUSH
106851: LD_VAR 0 11
106855: PPUSH
106856: LD_VAR 0 12
106860: PPUSH
106861: CALL_OW 554
106865: AND
106866: IFFALSE 106906
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106868: LD_ADDR_VAR 0 13
106872: PUSH
106873: LD_VAR 0 13
106877: PPUSH
106878: LD_VAR 0 13
106882: PUSH
106883: LD_INT 1
106885: PLUS
106886: PPUSH
106887: LD_VAR 0 11
106891: PUSH
106892: LD_VAR 0 12
106896: PUSH
106897: EMPTY
106898: LIST
106899: LIST
106900: PPUSH
106901: CALL_OW 2
106905: ST_TO_ADDR
// end ;
106906: GO 106814
106908: POP
106909: POP
106910: GO 106794
106912: POP
106913: POP
// if not list then
106914: LD_VAR 0 13
106918: NOT
106919: IFFALSE 106923
// exit ;
106921: GO 106994
// for i in list do
106923: LD_ADDR_VAR 0 6
106927: PUSH
106928: LD_VAR 0 13
106932: PUSH
106933: FOR_IN
106934: IFFALSE 106992
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106936: LD_VAR 0 1
106940: PPUSH
106941: LD_STRING M
106943: PUSH
106944: LD_VAR 0 6
106948: PUSH
106949: LD_INT 1
106951: ARRAY
106952: PUSH
106953: LD_VAR 0 6
106957: PUSH
106958: LD_INT 2
106960: ARRAY
106961: PUSH
106962: LD_INT 0
106964: PUSH
106965: LD_INT 0
106967: PUSH
106968: LD_INT 0
106970: PUSH
106971: LD_INT 0
106973: PUSH
106974: EMPTY
106975: LIST
106976: LIST
106977: LIST
106978: LIST
106979: LIST
106980: LIST
106981: LIST
106982: PUSH
106983: EMPTY
106984: LIST
106985: PPUSH
106986: CALL_OW 447
106990: GO 106933
106992: POP
106993: POP
// end ;
106994: LD_VAR 0 5
106998: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
106999: LD_EXP 156
107003: NOT
107004: IFFALSE 107054
107006: GO 107008
107008: DISABLE
// begin initHack := true ;
107009: LD_ADDR_EXP 156
107013: PUSH
107014: LD_INT 1
107016: ST_TO_ADDR
// hackTanks := [ ] ;
107017: LD_ADDR_EXP 157
107021: PUSH
107022: EMPTY
107023: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
107024: LD_ADDR_EXP 158
107028: PUSH
107029: EMPTY
107030: ST_TO_ADDR
// hackLimit := 3 ;
107031: LD_ADDR_EXP 159
107035: PUSH
107036: LD_INT 3
107038: ST_TO_ADDR
// hackDist := 12 ;
107039: LD_ADDR_EXP 160
107043: PUSH
107044: LD_INT 12
107046: ST_TO_ADDR
// hackCounter := [ ] ;
107047: LD_ADDR_EXP 161
107051: PUSH
107052: EMPTY
107053: ST_TO_ADDR
// end ;
107054: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
107055: LD_EXP 156
107059: PUSH
107060: LD_INT 34
107062: PUSH
107063: LD_INT 99
107065: PUSH
107066: EMPTY
107067: LIST
107068: LIST
107069: PPUSH
107070: CALL_OW 69
107074: AND
107075: IFFALSE 107328
107077: GO 107079
107079: DISABLE
107080: LD_INT 0
107082: PPUSH
107083: PPUSH
// begin enable ;
107084: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
107085: LD_ADDR_VAR 0 1
107089: PUSH
107090: LD_INT 34
107092: PUSH
107093: LD_INT 99
107095: PUSH
107096: EMPTY
107097: LIST
107098: LIST
107099: PPUSH
107100: CALL_OW 69
107104: PUSH
107105: FOR_IN
107106: IFFALSE 107326
// begin if not i in hackTanks then
107108: LD_VAR 0 1
107112: PUSH
107113: LD_EXP 157
107117: IN
107118: NOT
107119: IFFALSE 107202
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
107121: LD_ADDR_EXP 157
107125: PUSH
107126: LD_EXP 157
107130: PPUSH
107131: LD_EXP 157
107135: PUSH
107136: LD_INT 1
107138: PLUS
107139: PPUSH
107140: LD_VAR 0 1
107144: PPUSH
107145: CALL_OW 1
107149: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
107150: LD_ADDR_EXP 158
107154: PUSH
107155: LD_EXP 158
107159: PPUSH
107160: LD_EXP 158
107164: PUSH
107165: LD_INT 1
107167: PLUS
107168: PPUSH
107169: EMPTY
107170: PPUSH
107171: CALL_OW 1
107175: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
107176: LD_ADDR_EXP 161
107180: PUSH
107181: LD_EXP 161
107185: PPUSH
107186: LD_EXP 161
107190: PUSH
107191: LD_INT 1
107193: PLUS
107194: PPUSH
107195: EMPTY
107196: PPUSH
107197: CALL_OW 1
107201: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107202: LD_VAR 0 1
107206: PPUSH
107207: CALL_OW 302
107211: NOT
107212: IFFALSE 107225
// begin HackUnlinkAll ( i ) ;
107214: LD_VAR 0 1
107218: PPUSH
107219: CALL 107331 0 1
// continue ;
107223: GO 107105
// end ; HackCheckCapturedStatus ( i ) ;
107225: LD_VAR 0 1
107229: PPUSH
107230: CALL 107774 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107234: LD_ADDR_VAR 0 2
107238: PUSH
107239: LD_INT 81
107241: PUSH
107242: LD_VAR 0 1
107246: PPUSH
107247: CALL_OW 255
107251: PUSH
107252: EMPTY
107253: LIST
107254: LIST
107255: PUSH
107256: LD_INT 33
107258: PUSH
107259: LD_INT 3
107261: PUSH
107262: EMPTY
107263: LIST
107264: LIST
107265: PUSH
107266: LD_INT 91
107268: PUSH
107269: LD_VAR 0 1
107273: PUSH
107274: LD_EXP 160
107278: PUSH
107279: EMPTY
107280: LIST
107281: LIST
107282: LIST
107283: PUSH
107284: LD_INT 50
107286: PUSH
107287: EMPTY
107288: LIST
107289: PUSH
107290: EMPTY
107291: LIST
107292: LIST
107293: LIST
107294: LIST
107295: PPUSH
107296: CALL_OW 69
107300: ST_TO_ADDR
// if not tmp then
107301: LD_VAR 0 2
107305: NOT
107306: IFFALSE 107310
// continue ;
107308: GO 107105
// HackLink ( i , tmp ) ;
107310: LD_VAR 0 1
107314: PPUSH
107315: LD_VAR 0 2
107319: PPUSH
107320: CALL 107467 0 2
// end ;
107324: GO 107105
107326: POP
107327: POP
// end ;
107328: PPOPN 2
107330: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107331: LD_INT 0
107333: PPUSH
107334: PPUSH
107335: PPUSH
// if not hack in hackTanks then
107336: LD_VAR 0 1
107340: PUSH
107341: LD_EXP 157
107345: IN
107346: NOT
107347: IFFALSE 107351
// exit ;
107349: GO 107462
// index := GetElementIndex ( hackTanks , hack ) ;
107351: LD_ADDR_VAR 0 4
107355: PUSH
107356: LD_EXP 157
107360: PPUSH
107361: LD_VAR 0 1
107365: PPUSH
107366: CALL 53570 0 2
107370: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107371: LD_EXP 158
107375: PUSH
107376: LD_VAR 0 4
107380: ARRAY
107381: IFFALSE 107462
// begin for i in hackTanksCaptured [ index ] do
107383: LD_ADDR_VAR 0 3
107387: PUSH
107388: LD_EXP 158
107392: PUSH
107393: LD_VAR 0 4
107397: ARRAY
107398: PUSH
107399: FOR_IN
107400: IFFALSE 107426
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107402: LD_VAR 0 3
107406: PUSH
107407: LD_INT 1
107409: ARRAY
107410: PPUSH
107411: LD_VAR 0 3
107415: PUSH
107416: LD_INT 2
107418: ARRAY
107419: PPUSH
107420: CALL_OW 235
107424: GO 107399
107426: POP
107427: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
107428: LD_ADDR_EXP 158
107432: PUSH
107433: LD_EXP 158
107437: PPUSH
107438: LD_VAR 0 4
107442: PPUSH
107443: EMPTY
107444: PPUSH
107445: CALL_OW 1
107449: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
107450: LD_VAR 0 1
107454: PPUSH
107455: LD_INT 0
107457: PPUSH
107458: CALL_OW 505
// end ; end ;
107462: LD_VAR 0 2
107466: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
107467: LD_INT 0
107469: PPUSH
107470: PPUSH
107471: PPUSH
// if not hack in hackTanks or not vehicles then
107472: LD_VAR 0 1
107476: PUSH
107477: LD_EXP 157
107481: IN
107482: NOT
107483: PUSH
107484: LD_VAR 0 2
107488: NOT
107489: OR
107490: IFFALSE 107494
// exit ;
107492: GO 107769
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107494: LD_ADDR_VAR 0 2
107498: PUSH
107499: LD_VAR 0 1
107503: PPUSH
107504: LD_VAR 0 2
107508: PPUSH
107509: LD_INT 1
107511: PPUSH
107512: LD_INT 1
107514: PPUSH
107515: CALL 54220 0 4
107519: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
107520: LD_ADDR_VAR 0 5
107524: PUSH
107525: LD_EXP 157
107529: PPUSH
107530: LD_VAR 0 1
107534: PPUSH
107535: CALL 53570 0 2
107539: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
107540: LD_EXP 158
107544: PUSH
107545: LD_VAR 0 5
107549: ARRAY
107550: PUSH
107551: LD_EXP 159
107555: LESS
107556: IFFALSE 107745
// begin for i := 1 to vehicles do
107558: LD_ADDR_VAR 0 4
107562: PUSH
107563: DOUBLE
107564: LD_INT 1
107566: DEC
107567: ST_TO_ADDR
107568: LD_VAR 0 2
107572: PUSH
107573: FOR_TO
107574: IFFALSE 107743
// begin if hackTanksCaptured [ index ] = hackLimit then
107576: LD_EXP 158
107580: PUSH
107581: LD_VAR 0 5
107585: ARRAY
107586: PUSH
107587: LD_EXP 159
107591: EQUAL
107592: IFFALSE 107596
// break ;
107594: GO 107743
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
107596: LD_ADDR_EXP 161
107600: PUSH
107601: LD_EXP 161
107605: PPUSH
107606: LD_VAR 0 5
107610: PPUSH
107611: LD_EXP 161
107615: PUSH
107616: LD_VAR 0 5
107620: ARRAY
107621: PUSH
107622: LD_INT 1
107624: PLUS
107625: PPUSH
107626: CALL_OW 1
107630: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
107631: LD_ADDR_EXP 158
107635: PUSH
107636: LD_EXP 158
107640: PPUSH
107641: LD_VAR 0 5
107645: PUSH
107646: LD_EXP 158
107650: PUSH
107651: LD_VAR 0 5
107655: ARRAY
107656: PUSH
107657: LD_INT 1
107659: PLUS
107660: PUSH
107661: EMPTY
107662: LIST
107663: LIST
107664: PPUSH
107665: LD_VAR 0 2
107669: PUSH
107670: LD_VAR 0 4
107674: ARRAY
107675: PUSH
107676: LD_VAR 0 2
107680: PUSH
107681: LD_VAR 0 4
107685: ARRAY
107686: PPUSH
107687: CALL_OW 255
107691: PUSH
107692: EMPTY
107693: LIST
107694: LIST
107695: PPUSH
107696: CALL 53785 0 3
107700: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
107701: LD_VAR 0 2
107705: PUSH
107706: LD_VAR 0 4
107710: ARRAY
107711: PPUSH
107712: LD_VAR 0 1
107716: PPUSH
107717: CALL_OW 255
107721: PPUSH
107722: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
107726: LD_VAR 0 2
107730: PUSH
107731: LD_VAR 0 4
107735: ARRAY
107736: PPUSH
107737: CALL_OW 141
// end ;
107741: GO 107573
107743: POP
107744: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107745: LD_VAR 0 1
107749: PPUSH
107750: LD_EXP 158
107754: PUSH
107755: LD_VAR 0 5
107759: ARRAY
107760: PUSH
107761: LD_INT 0
107763: PLUS
107764: PPUSH
107765: CALL_OW 505
// end ;
107769: LD_VAR 0 3
107773: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
107774: LD_INT 0
107776: PPUSH
107777: PPUSH
107778: PPUSH
107779: PPUSH
// if not hack in hackTanks then
107780: LD_VAR 0 1
107784: PUSH
107785: LD_EXP 157
107789: IN
107790: NOT
107791: IFFALSE 107795
// exit ;
107793: GO 108035
// index := GetElementIndex ( hackTanks , hack ) ;
107795: LD_ADDR_VAR 0 4
107799: PUSH
107800: LD_EXP 157
107804: PPUSH
107805: LD_VAR 0 1
107809: PPUSH
107810: CALL 53570 0 2
107814: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
107815: LD_ADDR_VAR 0 3
107819: PUSH
107820: DOUBLE
107821: LD_EXP 158
107825: PUSH
107826: LD_VAR 0 4
107830: ARRAY
107831: INC
107832: ST_TO_ADDR
107833: LD_INT 1
107835: PUSH
107836: FOR_DOWNTO
107837: IFFALSE 108009
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
107839: LD_ADDR_VAR 0 5
107843: PUSH
107844: LD_EXP 158
107848: PUSH
107849: LD_VAR 0 4
107853: ARRAY
107854: PUSH
107855: LD_VAR 0 3
107859: ARRAY
107860: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
107861: LD_VAR 0 5
107865: PUSH
107866: LD_INT 1
107868: ARRAY
107869: PPUSH
107870: CALL_OW 302
107874: NOT
107875: PUSH
107876: LD_VAR 0 5
107880: PUSH
107881: LD_INT 1
107883: ARRAY
107884: PPUSH
107885: CALL_OW 255
107889: PUSH
107890: LD_VAR 0 1
107894: PPUSH
107895: CALL_OW 255
107899: NONEQUAL
107900: OR
107901: IFFALSE 108007
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
107903: LD_VAR 0 5
107907: PUSH
107908: LD_INT 1
107910: ARRAY
107911: PPUSH
107912: CALL_OW 305
107916: PUSH
107917: LD_VAR 0 5
107921: PUSH
107922: LD_INT 1
107924: ARRAY
107925: PPUSH
107926: CALL_OW 255
107930: PUSH
107931: LD_VAR 0 1
107935: PPUSH
107936: CALL_OW 255
107940: EQUAL
107941: AND
107942: IFFALSE 107966
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
107944: LD_VAR 0 5
107948: PUSH
107949: LD_INT 1
107951: ARRAY
107952: PPUSH
107953: LD_VAR 0 5
107957: PUSH
107958: LD_INT 2
107960: ARRAY
107961: PPUSH
107962: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
107966: LD_ADDR_EXP 158
107970: PUSH
107971: LD_EXP 158
107975: PPUSH
107976: LD_VAR 0 4
107980: PPUSH
107981: LD_EXP 158
107985: PUSH
107986: LD_VAR 0 4
107990: ARRAY
107991: PPUSH
107992: LD_VAR 0 3
107996: PPUSH
107997: CALL_OW 3
108001: PPUSH
108002: CALL_OW 1
108006: ST_TO_ADDR
// end ; end ;
108007: GO 107836
108009: POP
108010: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108011: LD_VAR 0 1
108015: PPUSH
108016: LD_EXP 158
108020: PUSH
108021: LD_VAR 0 4
108025: ARRAY
108026: PUSH
108027: LD_INT 0
108029: PLUS
108030: PPUSH
108031: CALL_OW 505
// end ;
108035: LD_VAR 0 2
108039: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
108040: LD_INT 0
108042: PPUSH
108043: PPUSH
108044: PPUSH
108045: PPUSH
// if not hack in hackTanks then
108046: LD_VAR 0 1
108050: PUSH
108051: LD_EXP 157
108055: IN
108056: NOT
108057: IFFALSE 108061
// exit ;
108059: GO 108146
// index := GetElementIndex ( hackTanks , hack ) ;
108061: LD_ADDR_VAR 0 5
108065: PUSH
108066: LD_EXP 157
108070: PPUSH
108071: LD_VAR 0 1
108075: PPUSH
108076: CALL 53570 0 2
108080: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
108081: LD_ADDR_VAR 0 4
108085: PUSH
108086: DOUBLE
108087: LD_INT 1
108089: DEC
108090: ST_TO_ADDR
108091: LD_EXP 158
108095: PUSH
108096: LD_VAR 0 5
108100: ARRAY
108101: PUSH
108102: FOR_TO
108103: IFFALSE 108144
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
108105: LD_EXP 158
108109: PUSH
108110: LD_VAR 0 5
108114: ARRAY
108115: PUSH
108116: LD_VAR 0 4
108120: ARRAY
108121: PUSH
108122: LD_INT 1
108124: ARRAY
108125: PUSH
108126: LD_VAR 0 2
108130: EQUAL
108131: IFFALSE 108142
// KillUnit ( vehicle ) ;
108133: LD_VAR 0 2
108137: PPUSH
108138: CALL_OW 66
108142: GO 108102
108144: POP
108145: POP
// end ;
108146: LD_VAR 0 3
108150: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
108151: LD_EXP 162
108155: NOT
108156: IFFALSE 108191
108158: GO 108160
108160: DISABLE
// begin initMiner := true ;
108161: LD_ADDR_EXP 162
108165: PUSH
108166: LD_INT 1
108168: ST_TO_ADDR
// minersList := [ ] ;
108169: LD_ADDR_EXP 163
108173: PUSH
108174: EMPTY
108175: ST_TO_ADDR
// minerMinesList := [ ] ;
108176: LD_ADDR_EXP 164
108180: PUSH
108181: EMPTY
108182: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
108183: LD_ADDR_EXP 165
108187: PUSH
108188: LD_INT 5
108190: ST_TO_ADDR
// end ;
108191: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
108192: LD_EXP 162
108196: PUSH
108197: LD_INT 34
108199: PUSH
108200: LD_INT 81
108202: PUSH
108203: EMPTY
108204: LIST
108205: LIST
108206: PPUSH
108207: CALL_OW 69
108211: AND
108212: IFFALSE 108673
108214: GO 108216
108216: DISABLE
108217: LD_INT 0
108219: PPUSH
108220: PPUSH
108221: PPUSH
108222: PPUSH
// begin enable ;
108223: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108224: LD_ADDR_VAR 0 1
108228: PUSH
108229: LD_INT 34
108231: PUSH
108232: LD_INT 81
108234: PUSH
108235: EMPTY
108236: LIST
108237: LIST
108238: PPUSH
108239: CALL_OW 69
108243: PUSH
108244: FOR_IN
108245: IFFALSE 108317
// begin if not i in minersList then
108247: LD_VAR 0 1
108251: PUSH
108252: LD_EXP 163
108256: IN
108257: NOT
108258: IFFALSE 108315
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108260: LD_ADDR_EXP 163
108264: PUSH
108265: LD_EXP 163
108269: PPUSH
108270: LD_EXP 163
108274: PUSH
108275: LD_INT 1
108277: PLUS
108278: PPUSH
108279: LD_VAR 0 1
108283: PPUSH
108284: CALL_OW 1
108288: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108289: LD_ADDR_EXP 164
108293: PUSH
108294: LD_EXP 164
108298: PPUSH
108299: LD_EXP 164
108303: PUSH
108304: LD_INT 1
108306: PLUS
108307: PPUSH
108308: EMPTY
108309: PPUSH
108310: CALL_OW 1
108314: ST_TO_ADDR
// end end ;
108315: GO 108244
108317: POP
108318: POP
// for i := minerMinesList downto 1 do
108319: LD_ADDR_VAR 0 1
108323: PUSH
108324: DOUBLE
108325: LD_EXP 164
108329: INC
108330: ST_TO_ADDR
108331: LD_INT 1
108333: PUSH
108334: FOR_DOWNTO
108335: IFFALSE 108671
// begin if IsLive ( minersList [ i ] ) then
108337: LD_EXP 163
108341: PUSH
108342: LD_VAR 0 1
108346: ARRAY
108347: PPUSH
108348: CALL_OW 300
108352: IFFALSE 108380
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108354: LD_EXP 163
108358: PUSH
108359: LD_VAR 0 1
108363: ARRAY
108364: PPUSH
108365: LD_EXP 164
108369: PUSH
108370: LD_VAR 0 1
108374: ARRAY
108375: PPUSH
108376: CALL_OW 505
// if not minerMinesList [ i ] then
108380: LD_EXP 164
108384: PUSH
108385: LD_VAR 0 1
108389: ARRAY
108390: NOT
108391: IFFALSE 108395
// continue ;
108393: GO 108334
// for j := minerMinesList [ i ] downto 1 do
108395: LD_ADDR_VAR 0 2
108399: PUSH
108400: DOUBLE
108401: LD_EXP 164
108405: PUSH
108406: LD_VAR 0 1
108410: ARRAY
108411: INC
108412: ST_TO_ADDR
108413: LD_INT 1
108415: PUSH
108416: FOR_DOWNTO
108417: IFFALSE 108667
// begin side := GetSide ( minersList [ i ] ) ;
108419: LD_ADDR_VAR 0 3
108423: PUSH
108424: LD_EXP 163
108428: PUSH
108429: LD_VAR 0 1
108433: ARRAY
108434: PPUSH
108435: CALL_OW 255
108439: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108440: LD_ADDR_VAR 0 4
108444: PUSH
108445: LD_EXP 164
108449: PUSH
108450: LD_VAR 0 1
108454: ARRAY
108455: PUSH
108456: LD_VAR 0 2
108460: ARRAY
108461: PUSH
108462: LD_INT 1
108464: ARRAY
108465: PPUSH
108466: LD_EXP 164
108470: PUSH
108471: LD_VAR 0 1
108475: ARRAY
108476: PUSH
108477: LD_VAR 0 2
108481: ARRAY
108482: PUSH
108483: LD_INT 2
108485: ARRAY
108486: PPUSH
108487: CALL_OW 428
108491: ST_TO_ADDR
// if not tmp then
108492: LD_VAR 0 4
108496: NOT
108497: IFFALSE 108501
// continue ;
108499: GO 108416
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108501: LD_VAR 0 4
108505: PUSH
108506: LD_INT 81
108508: PUSH
108509: LD_VAR 0 3
108513: PUSH
108514: EMPTY
108515: LIST
108516: LIST
108517: PPUSH
108518: CALL_OW 69
108522: IN
108523: PUSH
108524: LD_EXP 164
108528: PUSH
108529: LD_VAR 0 1
108533: ARRAY
108534: PUSH
108535: LD_VAR 0 2
108539: ARRAY
108540: PUSH
108541: LD_INT 1
108543: ARRAY
108544: PPUSH
108545: LD_EXP 164
108549: PUSH
108550: LD_VAR 0 1
108554: ARRAY
108555: PUSH
108556: LD_VAR 0 2
108560: ARRAY
108561: PUSH
108562: LD_INT 2
108564: ARRAY
108565: PPUSH
108566: CALL_OW 458
108570: AND
108571: IFFALSE 108665
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
108573: LD_EXP 164
108577: PUSH
108578: LD_VAR 0 1
108582: ARRAY
108583: PUSH
108584: LD_VAR 0 2
108588: ARRAY
108589: PUSH
108590: LD_INT 1
108592: ARRAY
108593: PPUSH
108594: LD_EXP 164
108598: PUSH
108599: LD_VAR 0 1
108603: ARRAY
108604: PUSH
108605: LD_VAR 0 2
108609: ARRAY
108610: PUSH
108611: LD_INT 2
108613: ARRAY
108614: PPUSH
108615: LD_VAR 0 3
108619: PPUSH
108620: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
108624: LD_ADDR_EXP 164
108628: PUSH
108629: LD_EXP 164
108633: PPUSH
108634: LD_VAR 0 1
108638: PPUSH
108639: LD_EXP 164
108643: PUSH
108644: LD_VAR 0 1
108648: ARRAY
108649: PPUSH
108650: LD_VAR 0 2
108654: PPUSH
108655: CALL_OW 3
108659: PPUSH
108660: CALL_OW 1
108664: ST_TO_ADDR
// end ; end ;
108665: GO 108416
108667: POP
108668: POP
// end ;
108669: GO 108334
108671: POP
108672: POP
// end ;
108673: PPOPN 4
108675: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
108676: LD_INT 0
108678: PPUSH
108679: PPUSH
// result := false ;
108680: LD_ADDR_VAR 0 4
108684: PUSH
108685: LD_INT 0
108687: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
108688: LD_VAR 0 1
108692: PPUSH
108693: CALL_OW 264
108697: PUSH
108698: LD_INT 81
108700: EQUAL
108701: NOT
108702: IFFALSE 108706
// exit ;
108704: GO 108946
// index := GetElementIndex ( minersList , unit ) ;
108706: LD_ADDR_VAR 0 5
108710: PUSH
108711: LD_EXP 163
108715: PPUSH
108716: LD_VAR 0 1
108720: PPUSH
108721: CALL 53570 0 2
108725: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
108726: LD_EXP 164
108730: PUSH
108731: LD_VAR 0 5
108735: ARRAY
108736: PUSH
108737: LD_EXP 165
108741: GREATEREQUAL
108742: IFFALSE 108746
// exit ;
108744: GO 108946
// ComMoveXY ( unit , x , y ) ;
108746: LD_VAR 0 1
108750: PPUSH
108751: LD_VAR 0 2
108755: PPUSH
108756: LD_VAR 0 3
108760: PPUSH
108761: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
108765: LD_INT 35
108767: PPUSH
108768: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
108772: LD_VAR 0 1
108776: PPUSH
108777: LD_VAR 0 2
108781: PPUSH
108782: LD_VAR 0 3
108786: PPUSH
108787: CALL 84925 0 3
108791: NOT
108792: PUSH
108793: LD_VAR 0 1
108797: PPUSH
108798: CALL_OW 314
108802: AND
108803: IFFALSE 108807
// exit ;
108805: GO 108946
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
108807: LD_VAR 0 2
108811: PPUSH
108812: LD_VAR 0 3
108816: PPUSH
108817: CALL_OW 428
108821: PUSH
108822: LD_VAR 0 1
108826: EQUAL
108827: PUSH
108828: LD_VAR 0 1
108832: PPUSH
108833: CALL_OW 314
108837: NOT
108838: AND
108839: IFFALSE 108765
// PlaySoundXY ( x , y , PlantMine ) ;
108841: LD_VAR 0 2
108845: PPUSH
108846: LD_VAR 0 3
108850: PPUSH
108851: LD_STRING PlantMine
108853: PPUSH
108854: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
108858: LD_VAR 0 2
108862: PPUSH
108863: LD_VAR 0 3
108867: PPUSH
108868: LD_VAR 0 1
108872: PPUSH
108873: CALL_OW 255
108877: PPUSH
108878: LD_INT 0
108880: PPUSH
108881: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
108885: LD_ADDR_EXP 164
108889: PUSH
108890: LD_EXP 164
108894: PPUSH
108895: LD_VAR 0 5
108899: PUSH
108900: LD_EXP 164
108904: PUSH
108905: LD_VAR 0 5
108909: ARRAY
108910: PUSH
108911: LD_INT 1
108913: PLUS
108914: PUSH
108915: EMPTY
108916: LIST
108917: LIST
108918: PPUSH
108919: LD_VAR 0 2
108923: PUSH
108924: LD_VAR 0 3
108928: PUSH
108929: EMPTY
108930: LIST
108931: LIST
108932: PPUSH
108933: CALL 53785 0 3
108937: ST_TO_ADDR
// result := true ;
108938: LD_ADDR_VAR 0 4
108942: PUSH
108943: LD_INT 1
108945: ST_TO_ADDR
// end ;
108946: LD_VAR 0 4
108950: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
108951: LD_INT 0
108953: PPUSH
108954: PPUSH
108955: PPUSH
// if not unit in minersList then
108956: LD_VAR 0 1
108960: PUSH
108961: LD_EXP 163
108965: IN
108966: NOT
108967: IFFALSE 108971
// exit ;
108969: GO 109363
// index := GetElementIndex ( minersList , unit ) ;
108971: LD_ADDR_VAR 0 6
108975: PUSH
108976: LD_EXP 163
108980: PPUSH
108981: LD_VAR 0 1
108985: PPUSH
108986: CALL 53570 0 2
108990: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
108991: LD_ADDR_VAR 0 5
108995: PUSH
108996: DOUBLE
108997: LD_EXP 164
109001: PUSH
109002: LD_VAR 0 6
109006: ARRAY
109007: INC
109008: ST_TO_ADDR
109009: LD_INT 1
109011: PUSH
109012: FOR_DOWNTO
109013: IFFALSE 109174
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
109015: LD_EXP 164
109019: PUSH
109020: LD_VAR 0 6
109024: ARRAY
109025: PUSH
109026: LD_VAR 0 5
109030: ARRAY
109031: PUSH
109032: LD_INT 1
109034: ARRAY
109035: PUSH
109036: LD_VAR 0 2
109040: EQUAL
109041: PUSH
109042: LD_EXP 164
109046: PUSH
109047: LD_VAR 0 6
109051: ARRAY
109052: PUSH
109053: LD_VAR 0 5
109057: ARRAY
109058: PUSH
109059: LD_INT 2
109061: ARRAY
109062: PUSH
109063: LD_VAR 0 3
109067: EQUAL
109068: AND
109069: IFFALSE 109172
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109071: LD_EXP 164
109075: PUSH
109076: LD_VAR 0 6
109080: ARRAY
109081: PUSH
109082: LD_VAR 0 5
109086: ARRAY
109087: PUSH
109088: LD_INT 1
109090: ARRAY
109091: PPUSH
109092: LD_EXP 164
109096: PUSH
109097: LD_VAR 0 6
109101: ARRAY
109102: PUSH
109103: LD_VAR 0 5
109107: ARRAY
109108: PUSH
109109: LD_INT 2
109111: ARRAY
109112: PPUSH
109113: LD_VAR 0 1
109117: PPUSH
109118: CALL_OW 255
109122: PPUSH
109123: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109127: LD_ADDR_EXP 164
109131: PUSH
109132: LD_EXP 164
109136: PPUSH
109137: LD_VAR 0 6
109141: PPUSH
109142: LD_EXP 164
109146: PUSH
109147: LD_VAR 0 6
109151: ARRAY
109152: PPUSH
109153: LD_VAR 0 5
109157: PPUSH
109158: CALL_OW 3
109162: PPUSH
109163: CALL_OW 1
109167: ST_TO_ADDR
// exit ;
109168: POP
109169: POP
109170: GO 109363
// end ; end ;
109172: GO 109012
109174: POP
109175: POP
// for i := minerMinesList [ index ] downto 1 do
109176: LD_ADDR_VAR 0 5
109180: PUSH
109181: DOUBLE
109182: LD_EXP 164
109186: PUSH
109187: LD_VAR 0 6
109191: ARRAY
109192: INC
109193: ST_TO_ADDR
109194: LD_INT 1
109196: PUSH
109197: FOR_DOWNTO
109198: IFFALSE 109361
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109200: LD_EXP 164
109204: PUSH
109205: LD_VAR 0 6
109209: ARRAY
109210: PUSH
109211: LD_VAR 0 5
109215: ARRAY
109216: PUSH
109217: LD_INT 1
109219: ARRAY
109220: PPUSH
109221: LD_EXP 164
109225: PUSH
109226: LD_VAR 0 6
109230: ARRAY
109231: PUSH
109232: LD_VAR 0 5
109236: ARRAY
109237: PUSH
109238: LD_INT 2
109240: ARRAY
109241: PPUSH
109242: LD_VAR 0 2
109246: PPUSH
109247: LD_VAR 0 3
109251: PPUSH
109252: CALL_OW 298
109256: PUSH
109257: LD_INT 6
109259: LESS
109260: IFFALSE 109359
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109262: LD_EXP 164
109266: PUSH
109267: LD_VAR 0 6
109271: ARRAY
109272: PUSH
109273: LD_VAR 0 5
109277: ARRAY
109278: PUSH
109279: LD_INT 1
109281: ARRAY
109282: PPUSH
109283: LD_EXP 164
109287: PUSH
109288: LD_VAR 0 6
109292: ARRAY
109293: PUSH
109294: LD_VAR 0 5
109298: ARRAY
109299: PUSH
109300: LD_INT 2
109302: ARRAY
109303: PPUSH
109304: LD_VAR 0 1
109308: PPUSH
109309: CALL_OW 255
109313: PPUSH
109314: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109318: LD_ADDR_EXP 164
109322: PUSH
109323: LD_EXP 164
109327: PPUSH
109328: LD_VAR 0 6
109332: PPUSH
109333: LD_EXP 164
109337: PUSH
109338: LD_VAR 0 6
109342: ARRAY
109343: PPUSH
109344: LD_VAR 0 5
109348: PPUSH
109349: CALL_OW 3
109353: PPUSH
109354: CALL_OW 1
109358: ST_TO_ADDR
// end ; end ;
109359: GO 109197
109361: POP
109362: POP
// end ;
109363: LD_VAR 0 4
109367: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109368: LD_INT 0
109370: PPUSH
109371: PPUSH
109372: PPUSH
109373: PPUSH
109374: PPUSH
109375: PPUSH
109376: PPUSH
109377: PPUSH
109378: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109379: LD_VAR 0 1
109383: PPUSH
109384: CALL_OW 264
109388: PUSH
109389: LD_INT 81
109391: EQUAL
109392: NOT
109393: PUSH
109394: LD_VAR 0 1
109398: PUSH
109399: LD_EXP 163
109403: IN
109404: NOT
109405: OR
109406: IFFALSE 109410
// exit ;
109408: GO 109732
// index := GetElementIndex ( minersList , unit ) ;
109410: LD_ADDR_VAR 0 6
109414: PUSH
109415: LD_EXP 163
109419: PPUSH
109420: LD_VAR 0 1
109424: PPUSH
109425: CALL 53570 0 2
109429: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
109430: LD_ADDR_VAR 0 8
109434: PUSH
109435: LD_EXP 165
109439: PUSH
109440: LD_EXP 164
109444: PUSH
109445: LD_VAR 0 6
109449: ARRAY
109450: MINUS
109451: ST_TO_ADDR
// if not minesFreeAmount then
109452: LD_VAR 0 8
109456: NOT
109457: IFFALSE 109461
// exit ;
109459: GO 109732
// tmp := [ ] ;
109461: LD_ADDR_VAR 0 7
109465: PUSH
109466: EMPTY
109467: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
109468: LD_ADDR_VAR 0 5
109472: PUSH
109473: DOUBLE
109474: LD_INT 1
109476: DEC
109477: ST_TO_ADDR
109478: LD_VAR 0 8
109482: PUSH
109483: FOR_TO
109484: IFFALSE 109679
// begin _d := rand ( 0 , 5 ) ;
109486: LD_ADDR_VAR 0 11
109490: PUSH
109491: LD_INT 0
109493: PPUSH
109494: LD_INT 5
109496: PPUSH
109497: CALL_OW 12
109501: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109502: LD_ADDR_VAR 0 12
109506: PUSH
109507: LD_INT 2
109509: PPUSH
109510: LD_INT 6
109512: PPUSH
109513: CALL_OW 12
109517: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109518: LD_ADDR_VAR 0 9
109522: PUSH
109523: LD_VAR 0 2
109527: PPUSH
109528: LD_VAR 0 11
109532: PPUSH
109533: LD_VAR 0 12
109537: PPUSH
109538: CALL_OW 272
109542: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
109543: LD_ADDR_VAR 0 10
109547: PUSH
109548: LD_VAR 0 3
109552: PPUSH
109553: LD_VAR 0 11
109557: PPUSH
109558: LD_VAR 0 12
109562: PPUSH
109563: CALL_OW 273
109567: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
109568: LD_VAR 0 9
109572: PPUSH
109573: LD_VAR 0 10
109577: PPUSH
109578: CALL_OW 488
109582: PUSH
109583: LD_VAR 0 9
109587: PUSH
109588: LD_VAR 0 10
109592: PUSH
109593: EMPTY
109594: LIST
109595: LIST
109596: PUSH
109597: LD_VAR 0 7
109601: IN
109602: NOT
109603: AND
109604: PUSH
109605: LD_VAR 0 9
109609: PPUSH
109610: LD_VAR 0 10
109614: PPUSH
109615: CALL_OW 458
109619: NOT
109620: AND
109621: IFFALSE 109663
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
109623: LD_ADDR_VAR 0 7
109627: PUSH
109628: LD_VAR 0 7
109632: PPUSH
109633: LD_VAR 0 7
109637: PUSH
109638: LD_INT 1
109640: PLUS
109641: PPUSH
109642: LD_VAR 0 9
109646: PUSH
109647: LD_VAR 0 10
109651: PUSH
109652: EMPTY
109653: LIST
109654: LIST
109655: PPUSH
109656: CALL_OW 1
109660: ST_TO_ADDR
109661: GO 109677
// i := i - 1 ;
109663: LD_ADDR_VAR 0 5
109667: PUSH
109668: LD_VAR 0 5
109672: PUSH
109673: LD_INT 1
109675: MINUS
109676: ST_TO_ADDR
// end ;
109677: GO 109483
109679: POP
109680: POP
// for i in tmp do
109681: LD_ADDR_VAR 0 5
109685: PUSH
109686: LD_VAR 0 7
109690: PUSH
109691: FOR_IN
109692: IFFALSE 109730
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
109694: LD_VAR 0 1
109698: PPUSH
109699: LD_VAR 0 5
109703: PUSH
109704: LD_INT 1
109706: ARRAY
109707: PPUSH
109708: LD_VAR 0 5
109712: PUSH
109713: LD_INT 2
109715: ARRAY
109716: PPUSH
109717: CALL 108676 0 3
109721: NOT
109722: IFFALSE 109728
// exit ;
109724: POP
109725: POP
109726: GO 109732
109728: GO 109691
109730: POP
109731: POP
// end ;
109732: LD_VAR 0 4
109736: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
109737: LD_INT 0
109739: PPUSH
109740: PPUSH
109741: PPUSH
109742: PPUSH
109743: PPUSH
109744: PPUSH
109745: PPUSH
// if not GetClass ( unit ) = class_sniper then
109746: LD_VAR 0 1
109750: PPUSH
109751: CALL_OW 257
109755: PUSH
109756: LD_INT 5
109758: EQUAL
109759: NOT
109760: IFFALSE 109764
// exit ;
109762: GO 110152
// dist := 8 ;
109764: LD_ADDR_VAR 0 5
109768: PUSH
109769: LD_INT 8
109771: ST_TO_ADDR
// viewRange := 12 ;
109772: LD_ADDR_VAR 0 7
109776: PUSH
109777: LD_INT 12
109779: ST_TO_ADDR
// side := GetSide ( unit ) ;
109780: LD_ADDR_VAR 0 6
109784: PUSH
109785: LD_VAR 0 1
109789: PPUSH
109790: CALL_OW 255
109794: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
109795: LD_INT 61
109797: PPUSH
109798: LD_VAR 0 6
109802: PPUSH
109803: CALL_OW 321
109807: PUSH
109808: LD_INT 2
109810: EQUAL
109811: IFFALSE 109821
// viewRange := 16 ;
109813: LD_ADDR_VAR 0 7
109817: PUSH
109818: LD_INT 16
109820: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
109821: LD_VAR 0 1
109825: PPUSH
109826: LD_VAR 0 2
109830: PPUSH
109831: LD_VAR 0 3
109835: PPUSH
109836: CALL_OW 297
109840: PUSH
109841: LD_VAR 0 5
109845: GREATER
109846: IFFALSE 109925
// begin ComMoveXY ( unit , x , y ) ;
109848: LD_VAR 0 1
109852: PPUSH
109853: LD_VAR 0 2
109857: PPUSH
109858: LD_VAR 0 3
109862: PPUSH
109863: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109867: LD_INT 35
109869: PPUSH
109870: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
109874: LD_VAR 0 1
109878: PPUSH
109879: LD_VAR 0 2
109883: PPUSH
109884: LD_VAR 0 3
109888: PPUSH
109889: CALL 84925 0 3
109893: NOT
109894: IFFALSE 109898
// exit ;
109896: GO 110152
// until GetDistUnitXY ( unit , x , y ) < dist ;
109898: LD_VAR 0 1
109902: PPUSH
109903: LD_VAR 0 2
109907: PPUSH
109908: LD_VAR 0 3
109912: PPUSH
109913: CALL_OW 297
109917: PUSH
109918: LD_VAR 0 5
109922: LESS
109923: IFFALSE 109867
// end ; ComTurnXY ( unit , x , y ) ;
109925: LD_VAR 0 1
109929: PPUSH
109930: LD_VAR 0 2
109934: PPUSH
109935: LD_VAR 0 3
109939: PPUSH
109940: CALL_OW 118
// wait ( 5 ) ;
109944: LD_INT 5
109946: PPUSH
109947: CALL_OW 67
// _d := GetDir ( unit ) ;
109951: LD_ADDR_VAR 0 10
109955: PUSH
109956: LD_VAR 0 1
109960: PPUSH
109961: CALL_OW 254
109965: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
109966: LD_ADDR_VAR 0 8
109970: PUSH
109971: LD_VAR 0 1
109975: PPUSH
109976: CALL_OW 250
109980: PPUSH
109981: LD_VAR 0 10
109985: PPUSH
109986: LD_VAR 0 5
109990: PPUSH
109991: CALL_OW 272
109995: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
109996: LD_ADDR_VAR 0 9
110000: PUSH
110001: LD_VAR 0 1
110005: PPUSH
110006: CALL_OW 251
110010: PPUSH
110011: LD_VAR 0 10
110015: PPUSH
110016: LD_VAR 0 5
110020: PPUSH
110021: CALL_OW 273
110025: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110026: LD_VAR 0 8
110030: PPUSH
110031: LD_VAR 0 9
110035: PPUSH
110036: CALL_OW 488
110040: NOT
110041: IFFALSE 110045
// exit ;
110043: GO 110152
// ComAnimCustom ( unit , 1 ) ;
110045: LD_VAR 0 1
110049: PPUSH
110050: LD_INT 1
110052: PPUSH
110053: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
110057: LD_VAR 0 8
110061: PPUSH
110062: LD_VAR 0 9
110066: PPUSH
110067: LD_VAR 0 6
110071: PPUSH
110072: LD_VAR 0 7
110076: PPUSH
110077: CALL_OW 330
// repeat wait ( 1 ) ;
110081: LD_INT 1
110083: PPUSH
110084: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
110088: LD_VAR 0 1
110092: PPUSH
110093: CALL_OW 316
110097: PUSH
110098: LD_VAR 0 1
110102: PPUSH
110103: CALL_OW 314
110107: OR
110108: PUSH
110109: LD_VAR 0 1
110113: PPUSH
110114: CALL_OW 302
110118: NOT
110119: OR
110120: PUSH
110121: LD_VAR 0 1
110125: PPUSH
110126: CALL_OW 301
110130: OR
110131: IFFALSE 110081
// RemoveSeeing ( _x , _y , side ) ;
110133: LD_VAR 0 8
110137: PPUSH
110138: LD_VAR 0 9
110142: PPUSH
110143: LD_VAR 0 6
110147: PPUSH
110148: CALL_OW 331
// end ; end_of_file
110152: LD_VAR 0 4
110156: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
110157: LD_INT 0
110159: PPUSH
110160: PPUSH
110161: PPUSH
110162: PPUSH
110163: PPUSH
110164: PPUSH
110165: PPUSH
110166: PPUSH
110167: PPUSH
110168: PPUSH
110169: PPUSH
110170: PPUSH
110171: PPUSH
110172: PPUSH
110173: PPUSH
110174: PPUSH
110175: PPUSH
110176: PPUSH
110177: PPUSH
110178: PPUSH
110179: PPUSH
110180: PPUSH
110181: PPUSH
110182: PPUSH
110183: PPUSH
110184: PPUSH
110185: PPUSH
110186: PPUSH
110187: PPUSH
110188: PPUSH
110189: PPUSH
110190: PPUSH
110191: PPUSH
110192: PPUSH
// if not list then
110193: LD_VAR 0 1
110197: NOT
110198: IFFALSE 110202
// exit ;
110200: GO 114861
// base := list [ 1 ] ;
110202: LD_ADDR_VAR 0 3
110206: PUSH
110207: LD_VAR 0 1
110211: PUSH
110212: LD_INT 1
110214: ARRAY
110215: ST_TO_ADDR
// group := list [ 2 ] ;
110216: LD_ADDR_VAR 0 4
110220: PUSH
110221: LD_VAR 0 1
110225: PUSH
110226: LD_INT 2
110228: ARRAY
110229: ST_TO_ADDR
// path := list [ 3 ] ;
110230: LD_ADDR_VAR 0 5
110234: PUSH
110235: LD_VAR 0 1
110239: PUSH
110240: LD_INT 3
110242: ARRAY
110243: ST_TO_ADDR
// flags := list [ 4 ] ;
110244: LD_ADDR_VAR 0 6
110248: PUSH
110249: LD_VAR 0 1
110253: PUSH
110254: LD_INT 4
110256: ARRAY
110257: ST_TO_ADDR
// mined := [ ] ;
110258: LD_ADDR_VAR 0 27
110262: PUSH
110263: EMPTY
110264: ST_TO_ADDR
// bombed := [ ] ;
110265: LD_ADDR_VAR 0 28
110269: PUSH
110270: EMPTY
110271: ST_TO_ADDR
// healers := [ ] ;
110272: LD_ADDR_VAR 0 31
110276: PUSH
110277: EMPTY
110278: ST_TO_ADDR
// to_heal := [ ] ;
110279: LD_ADDR_VAR 0 30
110283: PUSH
110284: EMPTY
110285: ST_TO_ADDR
// repairs := [ ] ;
110286: LD_ADDR_VAR 0 33
110290: PUSH
110291: EMPTY
110292: ST_TO_ADDR
// to_repair := [ ] ;
110293: LD_ADDR_VAR 0 32
110297: PUSH
110298: EMPTY
110299: ST_TO_ADDR
// if not group or not path then
110300: LD_VAR 0 4
110304: NOT
110305: PUSH
110306: LD_VAR 0 5
110310: NOT
110311: OR
110312: IFFALSE 110316
// exit ;
110314: GO 114861
// side := GetSide ( group [ 1 ] ) ;
110316: LD_ADDR_VAR 0 35
110320: PUSH
110321: LD_VAR 0 4
110325: PUSH
110326: LD_INT 1
110328: ARRAY
110329: PPUSH
110330: CALL_OW 255
110334: ST_TO_ADDR
// if flags then
110335: LD_VAR 0 6
110339: IFFALSE 110483
// begin f_ignore_area := flags [ 1 ] ;
110341: LD_ADDR_VAR 0 17
110345: PUSH
110346: LD_VAR 0 6
110350: PUSH
110351: LD_INT 1
110353: ARRAY
110354: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110355: LD_ADDR_VAR 0 18
110359: PUSH
110360: LD_VAR 0 6
110364: PUSH
110365: LD_INT 2
110367: ARRAY
110368: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110369: LD_ADDR_VAR 0 19
110373: PUSH
110374: LD_VAR 0 6
110378: PUSH
110379: LD_INT 3
110381: ARRAY
110382: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110383: LD_ADDR_VAR 0 20
110387: PUSH
110388: LD_VAR 0 6
110392: PUSH
110393: LD_INT 4
110395: ARRAY
110396: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110397: LD_ADDR_VAR 0 21
110401: PUSH
110402: LD_VAR 0 6
110406: PUSH
110407: LD_INT 5
110409: ARRAY
110410: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110411: LD_ADDR_VAR 0 22
110415: PUSH
110416: LD_VAR 0 6
110420: PUSH
110421: LD_INT 6
110423: ARRAY
110424: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
110425: LD_ADDR_VAR 0 23
110429: PUSH
110430: LD_VAR 0 6
110434: PUSH
110435: LD_INT 7
110437: ARRAY
110438: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110439: LD_ADDR_VAR 0 24
110443: PUSH
110444: LD_VAR 0 6
110448: PUSH
110449: LD_INT 8
110451: ARRAY
110452: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
110453: LD_ADDR_VAR 0 25
110457: PUSH
110458: LD_VAR 0 6
110462: PUSH
110463: LD_INT 9
110465: ARRAY
110466: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
110467: LD_ADDR_VAR 0 26
110471: PUSH
110472: LD_VAR 0 6
110476: PUSH
110477: LD_INT 10
110479: ARRAY
110480: ST_TO_ADDR
// end else
110481: GO 110563
// begin f_ignore_area := false ;
110483: LD_ADDR_VAR 0 17
110487: PUSH
110488: LD_INT 0
110490: ST_TO_ADDR
// f_capture := false ;
110491: LD_ADDR_VAR 0 18
110495: PUSH
110496: LD_INT 0
110498: ST_TO_ADDR
// f_ignore_civ := false ;
110499: LD_ADDR_VAR 0 19
110503: PUSH
110504: LD_INT 0
110506: ST_TO_ADDR
// f_murder := false ;
110507: LD_ADDR_VAR 0 20
110511: PUSH
110512: LD_INT 0
110514: ST_TO_ADDR
// f_mines := false ;
110515: LD_ADDR_VAR 0 21
110519: PUSH
110520: LD_INT 0
110522: ST_TO_ADDR
// f_repair := false ;
110523: LD_ADDR_VAR 0 22
110527: PUSH
110528: LD_INT 0
110530: ST_TO_ADDR
// f_heal := false ;
110531: LD_ADDR_VAR 0 23
110535: PUSH
110536: LD_INT 0
110538: ST_TO_ADDR
// f_spacetime := false ;
110539: LD_ADDR_VAR 0 24
110543: PUSH
110544: LD_INT 0
110546: ST_TO_ADDR
// f_attack_depot := false ;
110547: LD_ADDR_VAR 0 25
110551: PUSH
110552: LD_INT 0
110554: ST_TO_ADDR
// f_crawl := false ;
110555: LD_ADDR_VAR 0 26
110559: PUSH
110560: LD_INT 0
110562: ST_TO_ADDR
// end ; if f_heal then
110563: LD_VAR 0 23
110567: IFFALSE 110594
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
110569: LD_ADDR_VAR 0 31
110573: PUSH
110574: LD_VAR 0 4
110578: PPUSH
110579: LD_INT 25
110581: PUSH
110582: LD_INT 4
110584: PUSH
110585: EMPTY
110586: LIST
110587: LIST
110588: PPUSH
110589: CALL_OW 72
110593: ST_TO_ADDR
// if f_repair then
110594: LD_VAR 0 22
110598: IFFALSE 110625
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
110600: LD_ADDR_VAR 0 33
110604: PUSH
110605: LD_VAR 0 4
110609: PPUSH
110610: LD_INT 25
110612: PUSH
110613: LD_INT 3
110615: PUSH
110616: EMPTY
110617: LIST
110618: LIST
110619: PPUSH
110620: CALL_OW 72
110624: ST_TO_ADDR
// units_path := [ ] ;
110625: LD_ADDR_VAR 0 16
110629: PUSH
110630: EMPTY
110631: ST_TO_ADDR
// for i = 1 to group do
110632: LD_ADDR_VAR 0 7
110636: PUSH
110637: DOUBLE
110638: LD_INT 1
110640: DEC
110641: ST_TO_ADDR
110642: LD_VAR 0 4
110646: PUSH
110647: FOR_TO
110648: IFFALSE 110677
// units_path := Replace ( units_path , i , path ) ;
110650: LD_ADDR_VAR 0 16
110654: PUSH
110655: LD_VAR 0 16
110659: PPUSH
110660: LD_VAR 0 7
110664: PPUSH
110665: LD_VAR 0 5
110669: PPUSH
110670: CALL_OW 1
110674: ST_TO_ADDR
110675: GO 110647
110677: POP
110678: POP
// repeat for i = group downto 1 do
110679: LD_ADDR_VAR 0 7
110683: PUSH
110684: DOUBLE
110685: LD_VAR 0 4
110689: INC
110690: ST_TO_ADDR
110691: LD_INT 1
110693: PUSH
110694: FOR_DOWNTO
110695: IFFALSE 114817
// begin wait ( 5 ) ;
110697: LD_INT 5
110699: PPUSH
110700: CALL_OW 67
// tmp := [ ] ;
110704: LD_ADDR_VAR 0 14
110708: PUSH
110709: EMPTY
110710: ST_TO_ADDR
// attacking := false ;
110711: LD_ADDR_VAR 0 29
110715: PUSH
110716: LD_INT 0
110718: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
110719: LD_VAR 0 4
110723: PUSH
110724: LD_VAR 0 7
110728: ARRAY
110729: PPUSH
110730: CALL_OW 301
110734: PUSH
110735: LD_VAR 0 4
110739: PUSH
110740: LD_VAR 0 7
110744: ARRAY
110745: NOT
110746: OR
110747: IFFALSE 110856
// begin if GetType ( group [ i ] ) = unit_human then
110749: LD_VAR 0 4
110753: PUSH
110754: LD_VAR 0 7
110758: ARRAY
110759: PPUSH
110760: CALL_OW 247
110764: PUSH
110765: LD_INT 1
110767: EQUAL
110768: IFFALSE 110814
// begin to_heal := to_heal diff group [ i ] ;
110770: LD_ADDR_VAR 0 30
110774: PUSH
110775: LD_VAR 0 30
110779: PUSH
110780: LD_VAR 0 4
110784: PUSH
110785: LD_VAR 0 7
110789: ARRAY
110790: DIFF
110791: ST_TO_ADDR
// healers := healers diff group [ i ] ;
110792: LD_ADDR_VAR 0 31
110796: PUSH
110797: LD_VAR 0 31
110801: PUSH
110802: LD_VAR 0 4
110806: PUSH
110807: LD_VAR 0 7
110811: ARRAY
110812: DIFF
110813: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
110814: LD_ADDR_VAR 0 4
110818: PUSH
110819: LD_VAR 0 4
110823: PPUSH
110824: LD_VAR 0 7
110828: PPUSH
110829: CALL_OW 3
110833: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
110834: LD_ADDR_VAR 0 16
110838: PUSH
110839: LD_VAR 0 16
110843: PPUSH
110844: LD_VAR 0 7
110848: PPUSH
110849: CALL_OW 3
110853: ST_TO_ADDR
// continue ;
110854: GO 110694
// end ; if f_repair then
110856: LD_VAR 0 22
110860: IFFALSE 111349
// begin if GetType ( group [ i ] ) = unit_vehicle then
110862: LD_VAR 0 4
110866: PUSH
110867: LD_VAR 0 7
110871: ARRAY
110872: PPUSH
110873: CALL_OW 247
110877: PUSH
110878: LD_INT 2
110880: EQUAL
110881: IFFALSE 111071
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
110883: LD_VAR 0 4
110887: PUSH
110888: LD_VAR 0 7
110892: ARRAY
110893: PPUSH
110894: CALL_OW 256
110898: PUSH
110899: LD_INT 700
110901: LESS
110902: PUSH
110903: LD_VAR 0 4
110907: PUSH
110908: LD_VAR 0 7
110912: ARRAY
110913: PUSH
110914: LD_VAR 0 32
110918: IN
110919: NOT
110920: AND
110921: IFFALSE 110945
// to_repair := to_repair union group [ i ] ;
110923: LD_ADDR_VAR 0 32
110927: PUSH
110928: LD_VAR 0 32
110932: PUSH
110933: LD_VAR 0 4
110937: PUSH
110938: LD_VAR 0 7
110942: ARRAY
110943: UNION
110944: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
110945: LD_VAR 0 4
110949: PUSH
110950: LD_VAR 0 7
110954: ARRAY
110955: PPUSH
110956: CALL_OW 256
110960: PUSH
110961: LD_INT 1000
110963: EQUAL
110964: PUSH
110965: LD_VAR 0 4
110969: PUSH
110970: LD_VAR 0 7
110974: ARRAY
110975: PUSH
110976: LD_VAR 0 32
110980: IN
110981: AND
110982: IFFALSE 111006
// to_repair := to_repair diff group [ i ] ;
110984: LD_ADDR_VAR 0 32
110988: PUSH
110989: LD_VAR 0 32
110993: PUSH
110994: LD_VAR 0 4
110998: PUSH
110999: LD_VAR 0 7
111003: ARRAY
111004: DIFF
111005: ST_TO_ADDR
// if group [ i ] in to_repair then
111006: LD_VAR 0 4
111010: PUSH
111011: LD_VAR 0 7
111015: ARRAY
111016: PUSH
111017: LD_VAR 0 32
111021: IN
111022: IFFALSE 111069
// begin if not IsInArea ( group [ i ] , f_repair ) then
111024: LD_VAR 0 4
111028: PUSH
111029: LD_VAR 0 7
111033: ARRAY
111034: PPUSH
111035: LD_VAR 0 22
111039: PPUSH
111040: CALL_OW 308
111044: NOT
111045: IFFALSE 111067
// ComMoveToArea ( group [ i ] , f_repair ) ;
111047: LD_VAR 0 4
111051: PUSH
111052: LD_VAR 0 7
111056: ARRAY
111057: PPUSH
111058: LD_VAR 0 22
111062: PPUSH
111063: CALL_OW 113
// continue ;
111067: GO 110694
// end ; end else
111069: GO 111349
// if group [ i ] in repairs then
111071: LD_VAR 0 4
111075: PUSH
111076: LD_VAR 0 7
111080: ARRAY
111081: PUSH
111082: LD_VAR 0 33
111086: IN
111087: IFFALSE 111349
// begin if IsInUnit ( group [ i ] ) then
111089: LD_VAR 0 4
111093: PUSH
111094: LD_VAR 0 7
111098: ARRAY
111099: PPUSH
111100: CALL_OW 310
111104: IFFALSE 111172
// begin z := IsInUnit ( group [ i ] ) ;
111106: LD_ADDR_VAR 0 13
111110: PUSH
111111: LD_VAR 0 4
111115: PUSH
111116: LD_VAR 0 7
111120: ARRAY
111121: PPUSH
111122: CALL_OW 310
111126: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
111127: LD_VAR 0 13
111131: PUSH
111132: LD_VAR 0 32
111136: IN
111137: PUSH
111138: LD_VAR 0 13
111142: PPUSH
111143: LD_VAR 0 22
111147: PPUSH
111148: CALL_OW 308
111152: AND
111153: IFFALSE 111170
// ComExitVehicle ( group [ i ] ) ;
111155: LD_VAR 0 4
111159: PUSH
111160: LD_VAR 0 7
111164: ARRAY
111165: PPUSH
111166: CALL_OW 121
// end else
111170: GO 111349
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
111172: LD_ADDR_VAR 0 13
111176: PUSH
111177: LD_VAR 0 4
111181: PPUSH
111182: LD_INT 95
111184: PUSH
111185: LD_VAR 0 22
111189: PUSH
111190: EMPTY
111191: LIST
111192: LIST
111193: PUSH
111194: LD_INT 58
111196: PUSH
111197: EMPTY
111198: LIST
111199: PUSH
111200: EMPTY
111201: LIST
111202: LIST
111203: PPUSH
111204: CALL_OW 72
111208: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111209: LD_VAR 0 4
111213: PUSH
111214: LD_VAR 0 7
111218: ARRAY
111219: PPUSH
111220: CALL_OW 314
111224: NOT
111225: IFFALSE 111347
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111227: LD_ADDR_VAR 0 10
111231: PUSH
111232: LD_VAR 0 13
111236: PPUSH
111237: LD_VAR 0 4
111241: PUSH
111242: LD_VAR 0 7
111246: ARRAY
111247: PPUSH
111248: CALL_OW 74
111252: ST_TO_ADDR
// if not x then
111253: LD_VAR 0 10
111257: NOT
111258: IFFALSE 111262
// continue ;
111260: GO 110694
// if GetLives ( x ) < 1000 then
111262: LD_VAR 0 10
111266: PPUSH
111267: CALL_OW 256
111271: PUSH
111272: LD_INT 1000
111274: LESS
111275: IFFALSE 111299
// ComRepairVehicle ( group [ i ] , x ) else
111277: LD_VAR 0 4
111281: PUSH
111282: LD_VAR 0 7
111286: ARRAY
111287: PPUSH
111288: LD_VAR 0 10
111292: PPUSH
111293: CALL_OW 129
111297: GO 111347
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111299: LD_VAR 0 23
111303: PUSH
111304: LD_VAR 0 4
111308: PUSH
111309: LD_VAR 0 7
111313: ARRAY
111314: PPUSH
111315: CALL_OW 256
111319: PUSH
111320: LD_INT 1000
111322: LESS
111323: AND
111324: NOT
111325: IFFALSE 111347
// ComEnterUnit ( group [ i ] , x ) ;
111327: LD_VAR 0 4
111331: PUSH
111332: LD_VAR 0 7
111336: ARRAY
111337: PPUSH
111338: LD_VAR 0 10
111342: PPUSH
111343: CALL_OW 120
// end ; continue ;
111347: GO 110694
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111349: LD_VAR 0 23
111353: PUSH
111354: LD_VAR 0 4
111358: PUSH
111359: LD_VAR 0 7
111363: ARRAY
111364: PPUSH
111365: CALL_OW 247
111369: PUSH
111370: LD_INT 1
111372: EQUAL
111373: AND
111374: IFFALSE 111852
// begin if group [ i ] in healers then
111376: LD_VAR 0 4
111380: PUSH
111381: LD_VAR 0 7
111385: ARRAY
111386: PUSH
111387: LD_VAR 0 31
111391: IN
111392: IFFALSE 111665
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111394: LD_VAR 0 4
111398: PUSH
111399: LD_VAR 0 7
111403: ARRAY
111404: PPUSH
111405: LD_VAR 0 23
111409: PPUSH
111410: CALL_OW 308
111414: NOT
111415: PUSH
111416: LD_VAR 0 4
111420: PUSH
111421: LD_VAR 0 7
111425: ARRAY
111426: PPUSH
111427: CALL_OW 314
111431: NOT
111432: AND
111433: IFFALSE 111457
// ComMoveToArea ( group [ i ] , f_heal ) else
111435: LD_VAR 0 4
111439: PUSH
111440: LD_VAR 0 7
111444: ARRAY
111445: PPUSH
111446: LD_VAR 0 23
111450: PPUSH
111451: CALL_OW 113
111455: GO 111663
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
111457: LD_VAR 0 4
111461: PUSH
111462: LD_VAR 0 7
111466: ARRAY
111467: PPUSH
111468: CALL 83508 0 1
111472: PPUSH
111473: CALL_OW 256
111477: PUSH
111478: LD_INT 1000
111480: EQUAL
111481: IFFALSE 111500
// ComStop ( group [ i ] ) else
111483: LD_VAR 0 4
111487: PUSH
111488: LD_VAR 0 7
111492: ARRAY
111493: PPUSH
111494: CALL_OW 141
111498: GO 111663
// if not HasTask ( group [ i ] ) and to_heal then
111500: LD_VAR 0 4
111504: PUSH
111505: LD_VAR 0 7
111509: ARRAY
111510: PPUSH
111511: CALL_OW 314
111515: NOT
111516: PUSH
111517: LD_VAR 0 30
111521: AND
111522: IFFALSE 111663
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
111524: LD_ADDR_VAR 0 13
111528: PUSH
111529: LD_VAR 0 30
111533: PPUSH
111534: LD_INT 3
111536: PUSH
111537: LD_INT 54
111539: PUSH
111540: EMPTY
111541: LIST
111542: PUSH
111543: EMPTY
111544: LIST
111545: LIST
111546: PPUSH
111547: CALL_OW 72
111551: PPUSH
111552: LD_VAR 0 4
111556: PUSH
111557: LD_VAR 0 7
111561: ARRAY
111562: PPUSH
111563: CALL_OW 74
111567: ST_TO_ADDR
// if z then
111568: LD_VAR 0 13
111572: IFFALSE 111663
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
111574: LD_INT 91
111576: PUSH
111577: LD_VAR 0 13
111581: PUSH
111582: LD_INT 10
111584: PUSH
111585: EMPTY
111586: LIST
111587: LIST
111588: LIST
111589: PUSH
111590: LD_INT 81
111592: PUSH
111593: LD_VAR 0 13
111597: PPUSH
111598: CALL_OW 255
111602: PUSH
111603: EMPTY
111604: LIST
111605: LIST
111606: PUSH
111607: EMPTY
111608: LIST
111609: LIST
111610: PPUSH
111611: CALL_OW 69
111615: PUSH
111616: LD_INT 0
111618: EQUAL
111619: IFFALSE 111643
// ComHeal ( group [ i ] , z ) else
111621: LD_VAR 0 4
111625: PUSH
111626: LD_VAR 0 7
111630: ARRAY
111631: PPUSH
111632: LD_VAR 0 13
111636: PPUSH
111637: CALL_OW 128
111641: GO 111663
// ComMoveToArea ( group [ i ] , f_heal ) ;
111643: LD_VAR 0 4
111647: PUSH
111648: LD_VAR 0 7
111652: ARRAY
111653: PPUSH
111654: LD_VAR 0 23
111658: PPUSH
111659: CALL_OW 113
// end ; continue ;
111663: GO 110694
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
111665: LD_VAR 0 4
111669: PUSH
111670: LD_VAR 0 7
111674: ARRAY
111675: PPUSH
111676: CALL_OW 256
111680: PUSH
111681: LD_INT 700
111683: LESS
111684: PUSH
111685: LD_VAR 0 4
111689: PUSH
111690: LD_VAR 0 7
111694: ARRAY
111695: PUSH
111696: LD_VAR 0 30
111700: IN
111701: NOT
111702: AND
111703: IFFALSE 111727
// to_heal := to_heal union group [ i ] ;
111705: LD_ADDR_VAR 0 30
111709: PUSH
111710: LD_VAR 0 30
111714: PUSH
111715: LD_VAR 0 4
111719: PUSH
111720: LD_VAR 0 7
111724: ARRAY
111725: UNION
111726: ST_TO_ADDR
// if group [ i ] in to_heal then
111727: LD_VAR 0 4
111731: PUSH
111732: LD_VAR 0 7
111736: ARRAY
111737: PUSH
111738: LD_VAR 0 30
111742: IN
111743: IFFALSE 111852
// begin if GetLives ( group [ i ] ) = 1000 then
111745: LD_VAR 0 4
111749: PUSH
111750: LD_VAR 0 7
111754: ARRAY
111755: PPUSH
111756: CALL_OW 256
111760: PUSH
111761: LD_INT 1000
111763: EQUAL
111764: IFFALSE 111790
// to_heal := to_heal diff group [ i ] else
111766: LD_ADDR_VAR 0 30
111770: PUSH
111771: LD_VAR 0 30
111775: PUSH
111776: LD_VAR 0 4
111780: PUSH
111781: LD_VAR 0 7
111785: ARRAY
111786: DIFF
111787: ST_TO_ADDR
111788: GO 111852
// begin if not IsInArea ( group [ i ] , to_heal ) then
111790: LD_VAR 0 4
111794: PUSH
111795: LD_VAR 0 7
111799: ARRAY
111800: PPUSH
111801: LD_VAR 0 30
111805: PPUSH
111806: CALL_OW 308
111810: NOT
111811: IFFALSE 111835
// ComMoveToArea ( group [ i ] , f_heal ) else
111813: LD_VAR 0 4
111817: PUSH
111818: LD_VAR 0 7
111822: ARRAY
111823: PPUSH
111824: LD_VAR 0 23
111828: PPUSH
111829: CALL_OW 113
111833: GO 111850
// ComHold ( group [ i ] ) ;
111835: LD_VAR 0 4
111839: PUSH
111840: LD_VAR 0 7
111844: ARRAY
111845: PPUSH
111846: CALL_OW 140
// continue ;
111850: GO 110694
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
111852: LD_VAR 0 4
111856: PUSH
111857: LD_VAR 0 7
111861: ARRAY
111862: PPUSH
111863: LD_INT 10
111865: PPUSH
111866: CALL 81279 0 2
111870: NOT
111871: PUSH
111872: LD_VAR 0 16
111876: PUSH
111877: LD_VAR 0 7
111881: ARRAY
111882: PUSH
111883: EMPTY
111884: EQUAL
111885: NOT
111886: AND
111887: IFFALSE 112153
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
111889: LD_VAR 0 4
111893: PUSH
111894: LD_VAR 0 7
111898: ARRAY
111899: PPUSH
111900: CALL_OW 262
111904: PUSH
111905: LD_INT 1
111907: PUSH
111908: LD_INT 2
111910: PUSH
111911: EMPTY
111912: LIST
111913: LIST
111914: IN
111915: IFFALSE 111956
// if GetFuel ( group [ i ] ) < 10 then
111917: LD_VAR 0 4
111921: PUSH
111922: LD_VAR 0 7
111926: ARRAY
111927: PPUSH
111928: CALL_OW 261
111932: PUSH
111933: LD_INT 10
111935: LESS
111936: IFFALSE 111956
// SetFuel ( group [ i ] , 12 ) ;
111938: LD_VAR 0 4
111942: PUSH
111943: LD_VAR 0 7
111947: ARRAY
111948: PPUSH
111949: LD_INT 12
111951: PPUSH
111952: CALL_OW 240
// if units_path [ i ] then
111956: LD_VAR 0 16
111960: PUSH
111961: LD_VAR 0 7
111965: ARRAY
111966: IFFALSE 112151
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
111968: LD_VAR 0 4
111972: PUSH
111973: LD_VAR 0 7
111977: ARRAY
111978: PPUSH
111979: LD_VAR 0 16
111983: PUSH
111984: LD_VAR 0 7
111988: ARRAY
111989: PUSH
111990: LD_INT 1
111992: ARRAY
111993: PUSH
111994: LD_INT 1
111996: ARRAY
111997: PPUSH
111998: LD_VAR 0 16
112002: PUSH
112003: LD_VAR 0 7
112007: ARRAY
112008: PUSH
112009: LD_INT 1
112011: ARRAY
112012: PUSH
112013: LD_INT 2
112015: ARRAY
112016: PPUSH
112017: CALL_OW 297
112021: PUSH
112022: LD_INT 6
112024: GREATER
112025: IFFALSE 112100
// begin if not HasTask ( group [ i ] ) then
112027: LD_VAR 0 4
112031: PUSH
112032: LD_VAR 0 7
112036: ARRAY
112037: PPUSH
112038: CALL_OW 314
112042: NOT
112043: IFFALSE 112098
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
112045: LD_VAR 0 4
112049: PUSH
112050: LD_VAR 0 7
112054: ARRAY
112055: PPUSH
112056: LD_VAR 0 16
112060: PUSH
112061: LD_VAR 0 7
112065: ARRAY
112066: PUSH
112067: LD_INT 1
112069: ARRAY
112070: PUSH
112071: LD_INT 1
112073: ARRAY
112074: PPUSH
112075: LD_VAR 0 16
112079: PUSH
112080: LD_VAR 0 7
112084: ARRAY
112085: PUSH
112086: LD_INT 1
112088: ARRAY
112089: PUSH
112090: LD_INT 2
112092: ARRAY
112093: PPUSH
112094: CALL_OW 114
// end else
112098: GO 112151
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
112100: LD_ADDR_VAR 0 15
112104: PUSH
112105: LD_VAR 0 16
112109: PUSH
112110: LD_VAR 0 7
112114: ARRAY
112115: PPUSH
112116: LD_INT 1
112118: PPUSH
112119: CALL_OW 3
112123: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
112124: LD_ADDR_VAR 0 16
112128: PUSH
112129: LD_VAR 0 16
112133: PPUSH
112134: LD_VAR 0 7
112138: PPUSH
112139: LD_VAR 0 15
112143: PPUSH
112144: CALL_OW 1
112148: ST_TO_ADDR
// continue ;
112149: GO 110694
// end ; end ; end else
112151: GO 114815
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
112153: LD_ADDR_VAR 0 14
112157: PUSH
112158: LD_INT 81
112160: PUSH
112161: LD_VAR 0 4
112165: PUSH
112166: LD_VAR 0 7
112170: ARRAY
112171: PPUSH
112172: CALL_OW 255
112176: PUSH
112177: EMPTY
112178: LIST
112179: LIST
112180: PPUSH
112181: CALL_OW 69
112185: ST_TO_ADDR
// if not tmp then
112186: LD_VAR 0 14
112190: NOT
112191: IFFALSE 112195
// continue ;
112193: GO 110694
// if f_ignore_area then
112195: LD_VAR 0 17
112199: IFFALSE 112287
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112201: LD_ADDR_VAR 0 15
112205: PUSH
112206: LD_VAR 0 14
112210: PPUSH
112211: LD_INT 3
112213: PUSH
112214: LD_INT 92
112216: PUSH
112217: LD_VAR 0 17
112221: PUSH
112222: LD_INT 1
112224: ARRAY
112225: PUSH
112226: LD_VAR 0 17
112230: PUSH
112231: LD_INT 2
112233: ARRAY
112234: PUSH
112235: LD_VAR 0 17
112239: PUSH
112240: LD_INT 3
112242: ARRAY
112243: PUSH
112244: EMPTY
112245: LIST
112246: LIST
112247: LIST
112248: LIST
112249: PUSH
112250: EMPTY
112251: LIST
112252: LIST
112253: PPUSH
112254: CALL_OW 72
112258: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112259: LD_VAR 0 14
112263: PUSH
112264: LD_VAR 0 15
112268: DIFF
112269: IFFALSE 112287
// tmp := tmp diff tmp2 ;
112271: LD_ADDR_VAR 0 14
112275: PUSH
112276: LD_VAR 0 14
112280: PUSH
112281: LD_VAR 0 15
112285: DIFF
112286: ST_TO_ADDR
// end ; if not f_murder then
112287: LD_VAR 0 20
112291: NOT
112292: IFFALSE 112350
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112294: LD_ADDR_VAR 0 15
112298: PUSH
112299: LD_VAR 0 14
112303: PPUSH
112304: LD_INT 3
112306: PUSH
112307: LD_INT 50
112309: PUSH
112310: EMPTY
112311: LIST
112312: PUSH
112313: EMPTY
112314: LIST
112315: LIST
112316: PPUSH
112317: CALL_OW 72
112321: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112322: LD_VAR 0 14
112326: PUSH
112327: LD_VAR 0 15
112331: DIFF
112332: IFFALSE 112350
// tmp := tmp diff tmp2 ;
112334: LD_ADDR_VAR 0 14
112338: PUSH
112339: LD_VAR 0 14
112343: PUSH
112344: LD_VAR 0 15
112348: DIFF
112349: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112350: LD_ADDR_VAR 0 14
112354: PUSH
112355: LD_VAR 0 4
112359: PUSH
112360: LD_VAR 0 7
112364: ARRAY
112365: PPUSH
112366: LD_VAR 0 14
112370: PPUSH
112371: LD_INT 1
112373: PPUSH
112374: LD_INT 1
112376: PPUSH
112377: CALL 54220 0 4
112381: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112382: LD_VAR 0 4
112386: PUSH
112387: LD_VAR 0 7
112391: ARRAY
112392: PPUSH
112393: CALL_OW 257
112397: PUSH
112398: LD_INT 1
112400: EQUAL
112401: IFFALSE 112849
// begin if WantPlant ( group [ i ] ) then
112403: LD_VAR 0 4
112407: PUSH
112408: LD_VAR 0 7
112412: ARRAY
112413: PPUSH
112414: CALL 53721 0 1
112418: IFFALSE 112422
// continue ;
112420: GO 110694
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112422: LD_VAR 0 18
112426: PUSH
112427: LD_VAR 0 4
112431: PUSH
112432: LD_VAR 0 7
112436: ARRAY
112437: PPUSH
112438: CALL_OW 310
112442: NOT
112443: AND
112444: PUSH
112445: LD_VAR 0 14
112449: PUSH
112450: LD_INT 1
112452: ARRAY
112453: PUSH
112454: LD_VAR 0 14
112458: PPUSH
112459: LD_INT 21
112461: PUSH
112462: LD_INT 2
112464: PUSH
112465: EMPTY
112466: LIST
112467: LIST
112468: PUSH
112469: LD_INT 58
112471: PUSH
112472: EMPTY
112473: LIST
112474: PUSH
112475: EMPTY
112476: LIST
112477: LIST
112478: PPUSH
112479: CALL_OW 72
112483: IN
112484: AND
112485: IFFALSE 112521
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
112487: LD_VAR 0 4
112491: PUSH
112492: LD_VAR 0 7
112496: ARRAY
112497: PPUSH
112498: LD_VAR 0 14
112502: PUSH
112503: LD_INT 1
112505: ARRAY
112506: PPUSH
112507: CALL_OW 120
// attacking := true ;
112511: LD_ADDR_VAR 0 29
112515: PUSH
112516: LD_INT 1
112518: ST_TO_ADDR
// continue ;
112519: GO 110694
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
112521: LD_VAR 0 26
112525: PUSH
112526: LD_VAR 0 4
112530: PUSH
112531: LD_VAR 0 7
112535: ARRAY
112536: PPUSH
112537: CALL_OW 257
112541: PUSH
112542: LD_INT 1
112544: EQUAL
112545: AND
112546: PUSH
112547: LD_VAR 0 4
112551: PUSH
112552: LD_VAR 0 7
112556: ARRAY
112557: PPUSH
112558: CALL_OW 256
112562: PUSH
112563: LD_INT 800
112565: LESS
112566: AND
112567: PUSH
112568: LD_VAR 0 4
112572: PUSH
112573: LD_VAR 0 7
112577: ARRAY
112578: PPUSH
112579: CALL_OW 318
112583: NOT
112584: AND
112585: IFFALSE 112602
// ComCrawl ( group [ i ] ) ;
112587: LD_VAR 0 4
112591: PUSH
112592: LD_VAR 0 7
112596: ARRAY
112597: PPUSH
112598: CALL_OW 137
// if f_mines then
112602: LD_VAR 0 21
112606: IFFALSE 112849
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
112608: LD_VAR 0 14
112612: PUSH
112613: LD_INT 1
112615: ARRAY
112616: PPUSH
112617: CALL_OW 247
112621: PUSH
112622: LD_INT 3
112624: EQUAL
112625: PUSH
112626: LD_VAR 0 14
112630: PUSH
112631: LD_INT 1
112633: ARRAY
112634: PUSH
112635: LD_VAR 0 27
112639: IN
112640: NOT
112641: AND
112642: IFFALSE 112849
// begin x := GetX ( tmp [ 1 ] ) ;
112644: LD_ADDR_VAR 0 10
112648: PUSH
112649: LD_VAR 0 14
112653: PUSH
112654: LD_INT 1
112656: ARRAY
112657: PPUSH
112658: CALL_OW 250
112662: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
112663: LD_ADDR_VAR 0 11
112667: PUSH
112668: LD_VAR 0 14
112672: PUSH
112673: LD_INT 1
112675: ARRAY
112676: PPUSH
112677: CALL_OW 251
112681: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
112682: LD_ADDR_VAR 0 12
112686: PUSH
112687: LD_VAR 0 4
112691: PUSH
112692: LD_VAR 0 7
112696: ARRAY
112697: PPUSH
112698: CALL 81364 0 1
112702: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
112703: LD_VAR 0 4
112707: PUSH
112708: LD_VAR 0 7
112712: ARRAY
112713: PPUSH
112714: LD_VAR 0 10
112718: PPUSH
112719: LD_VAR 0 11
112723: PPUSH
112724: LD_VAR 0 14
112728: PUSH
112729: LD_INT 1
112731: ARRAY
112732: PPUSH
112733: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
112737: LD_VAR 0 4
112741: PUSH
112742: LD_VAR 0 7
112746: ARRAY
112747: PPUSH
112748: LD_VAR 0 10
112752: PPUSH
112753: LD_VAR 0 12
112757: PPUSH
112758: LD_INT 7
112760: PPUSH
112761: CALL_OW 272
112765: PPUSH
112766: LD_VAR 0 11
112770: PPUSH
112771: LD_VAR 0 12
112775: PPUSH
112776: LD_INT 7
112778: PPUSH
112779: CALL_OW 273
112783: PPUSH
112784: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
112788: LD_VAR 0 4
112792: PUSH
112793: LD_VAR 0 7
112797: ARRAY
112798: PPUSH
112799: LD_INT 71
112801: PPUSH
112802: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
112806: LD_ADDR_VAR 0 27
112810: PUSH
112811: LD_VAR 0 27
112815: PPUSH
112816: LD_VAR 0 27
112820: PUSH
112821: LD_INT 1
112823: PLUS
112824: PPUSH
112825: LD_VAR 0 14
112829: PUSH
112830: LD_INT 1
112832: ARRAY
112833: PPUSH
112834: CALL_OW 1
112838: ST_TO_ADDR
// attacking := true ;
112839: LD_ADDR_VAR 0 29
112843: PUSH
112844: LD_INT 1
112846: ST_TO_ADDR
// continue ;
112847: GO 110694
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
112849: LD_VAR 0 4
112853: PUSH
112854: LD_VAR 0 7
112858: ARRAY
112859: PPUSH
112860: CALL_OW 257
112864: PUSH
112865: LD_INT 17
112867: EQUAL
112868: PUSH
112869: LD_VAR 0 4
112873: PUSH
112874: LD_VAR 0 7
112878: ARRAY
112879: PPUSH
112880: CALL_OW 110
112884: PUSH
112885: LD_INT 71
112887: EQUAL
112888: NOT
112889: AND
112890: IFFALSE 113036
// begin attacking := false ;
112892: LD_ADDR_VAR 0 29
112896: PUSH
112897: LD_INT 0
112899: ST_TO_ADDR
// k := 5 ;
112900: LD_ADDR_VAR 0 9
112904: PUSH
112905: LD_INT 5
112907: ST_TO_ADDR
// if tmp < k then
112908: LD_VAR 0 14
112912: PUSH
112913: LD_VAR 0 9
112917: LESS
112918: IFFALSE 112930
// k := tmp ;
112920: LD_ADDR_VAR 0 9
112924: PUSH
112925: LD_VAR 0 14
112929: ST_TO_ADDR
// for j = 1 to k do
112930: LD_ADDR_VAR 0 8
112934: PUSH
112935: DOUBLE
112936: LD_INT 1
112938: DEC
112939: ST_TO_ADDR
112940: LD_VAR 0 9
112944: PUSH
112945: FOR_TO
112946: IFFALSE 113034
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
112948: LD_VAR 0 14
112952: PUSH
112953: LD_VAR 0 8
112957: ARRAY
112958: PUSH
112959: LD_VAR 0 14
112963: PPUSH
112964: LD_INT 58
112966: PUSH
112967: EMPTY
112968: LIST
112969: PPUSH
112970: CALL_OW 72
112974: IN
112975: NOT
112976: IFFALSE 113032
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112978: LD_VAR 0 4
112982: PUSH
112983: LD_VAR 0 7
112987: ARRAY
112988: PPUSH
112989: LD_VAR 0 14
112993: PUSH
112994: LD_VAR 0 8
112998: ARRAY
112999: PPUSH
113000: CALL_OW 115
// attacking := true ;
113004: LD_ADDR_VAR 0 29
113008: PUSH
113009: LD_INT 1
113011: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
113012: LD_VAR 0 4
113016: PUSH
113017: LD_VAR 0 7
113021: ARRAY
113022: PPUSH
113023: LD_INT 71
113025: PPUSH
113026: CALL_OW 109
// continue ;
113030: GO 112945
// end ; end ;
113032: GO 112945
113034: POP
113035: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
113036: LD_VAR 0 4
113040: PUSH
113041: LD_VAR 0 7
113045: ARRAY
113046: PPUSH
113047: CALL_OW 257
113051: PUSH
113052: LD_INT 8
113054: EQUAL
113055: PUSH
113056: LD_VAR 0 4
113060: PUSH
113061: LD_VAR 0 7
113065: ARRAY
113066: PPUSH
113067: CALL_OW 264
113071: PUSH
113072: LD_INT 28
113074: PUSH
113075: LD_INT 45
113077: PUSH
113078: LD_INT 7
113080: PUSH
113081: LD_INT 47
113083: PUSH
113084: EMPTY
113085: LIST
113086: LIST
113087: LIST
113088: LIST
113089: IN
113090: OR
113091: IFFALSE 113347
// begin attacking := false ;
113093: LD_ADDR_VAR 0 29
113097: PUSH
113098: LD_INT 0
113100: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
113101: LD_VAR 0 14
113105: PUSH
113106: LD_INT 1
113108: ARRAY
113109: PPUSH
113110: CALL_OW 266
113114: PUSH
113115: LD_INT 32
113117: PUSH
113118: LD_INT 31
113120: PUSH
113121: LD_INT 33
113123: PUSH
113124: LD_INT 4
113126: PUSH
113127: LD_INT 5
113129: PUSH
113130: EMPTY
113131: LIST
113132: LIST
113133: LIST
113134: LIST
113135: LIST
113136: IN
113137: IFFALSE 113323
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
113139: LD_ADDR_VAR 0 9
113143: PUSH
113144: LD_VAR 0 14
113148: PUSH
113149: LD_INT 1
113151: ARRAY
113152: PPUSH
113153: CALL_OW 266
113157: PPUSH
113158: LD_VAR 0 14
113162: PUSH
113163: LD_INT 1
113165: ARRAY
113166: PPUSH
113167: CALL_OW 250
113171: PPUSH
113172: LD_VAR 0 14
113176: PUSH
113177: LD_INT 1
113179: ARRAY
113180: PPUSH
113181: CALL_OW 251
113185: PPUSH
113186: LD_VAR 0 14
113190: PUSH
113191: LD_INT 1
113193: ARRAY
113194: PPUSH
113195: CALL_OW 254
113199: PPUSH
113200: LD_VAR 0 14
113204: PUSH
113205: LD_INT 1
113207: ARRAY
113208: PPUSH
113209: CALL_OW 248
113213: PPUSH
113214: LD_INT 0
113216: PPUSH
113217: CALL 62734 0 6
113221: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113222: LD_ADDR_VAR 0 8
113226: PUSH
113227: LD_VAR 0 4
113231: PUSH
113232: LD_VAR 0 7
113236: ARRAY
113237: PPUSH
113238: LD_VAR 0 9
113242: PPUSH
113243: CALL 81477 0 2
113247: ST_TO_ADDR
// if j then
113248: LD_VAR 0 8
113252: IFFALSE 113321
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113254: LD_VAR 0 8
113258: PUSH
113259: LD_INT 1
113261: ARRAY
113262: PPUSH
113263: LD_VAR 0 8
113267: PUSH
113268: LD_INT 2
113270: ARRAY
113271: PPUSH
113272: CALL_OW 488
113276: IFFALSE 113321
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113278: LD_VAR 0 4
113282: PUSH
113283: LD_VAR 0 7
113287: ARRAY
113288: PPUSH
113289: LD_VAR 0 8
113293: PUSH
113294: LD_INT 1
113296: ARRAY
113297: PPUSH
113298: LD_VAR 0 8
113302: PUSH
113303: LD_INT 2
113305: ARRAY
113306: PPUSH
113307: CALL_OW 116
// attacking := true ;
113311: LD_ADDR_VAR 0 29
113315: PUSH
113316: LD_INT 1
113318: ST_TO_ADDR
// continue ;
113319: GO 110694
// end ; end else
113321: GO 113347
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113323: LD_VAR 0 4
113327: PUSH
113328: LD_VAR 0 7
113332: ARRAY
113333: PPUSH
113334: LD_VAR 0 14
113338: PUSH
113339: LD_INT 1
113341: ARRAY
113342: PPUSH
113343: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113347: LD_VAR 0 4
113351: PUSH
113352: LD_VAR 0 7
113356: ARRAY
113357: PPUSH
113358: CALL_OW 265
113362: PUSH
113363: LD_INT 11
113365: EQUAL
113366: IFFALSE 113644
// begin k := 10 ;
113368: LD_ADDR_VAR 0 9
113372: PUSH
113373: LD_INT 10
113375: ST_TO_ADDR
// x := 0 ;
113376: LD_ADDR_VAR 0 10
113380: PUSH
113381: LD_INT 0
113383: ST_TO_ADDR
// if tmp < k then
113384: LD_VAR 0 14
113388: PUSH
113389: LD_VAR 0 9
113393: LESS
113394: IFFALSE 113406
// k := tmp ;
113396: LD_ADDR_VAR 0 9
113400: PUSH
113401: LD_VAR 0 14
113405: ST_TO_ADDR
// for j = k downto 1 do
113406: LD_ADDR_VAR 0 8
113410: PUSH
113411: DOUBLE
113412: LD_VAR 0 9
113416: INC
113417: ST_TO_ADDR
113418: LD_INT 1
113420: PUSH
113421: FOR_DOWNTO
113422: IFFALSE 113497
// begin if GetType ( tmp [ j ] ) = unit_human then
113424: LD_VAR 0 14
113428: PUSH
113429: LD_VAR 0 8
113433: ARRAY
113434: PPUSH
113435: CALL_OW 247
113439: PUSH
113440: LD_INT 1
113442: EQUAL
113443: IFFALSE 113495
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113445: LD_VAR 0 4
113449: PUSH
113450: LD_VAR 0 7
113454: ARRAY
113455: PPUSH
113456: LD_VAR 0 14
113460: PUSH
113461: LD_VAR 0 8
113465: ARRAY
113466: PPUSH
113467: CALL 81731 0 2
// x := tmp [ j ] ;
113471: LD_ADDR_VAR 0 10
113475: PUSH
113476: LD_VAR 0 14
113480: PUSH
113481: LD_VAR 0 8
113485: ARRAY
113486: ST_TO_ADDR
// attacking := true ;
113487: LD_ADDR_VAR 0 29
113491: PUSH
113492: LD_INT 1
113494: ST_TO_ADDR
// end ; end ;
113495: GO 113421
113497: POP
113498: POP
// if not x then
113499: LD_VAR 0 10
113503: NOT
113504: IFFALSE 113644
// begin attacking := true ;
113506: LD_ADDR_VAR 0 29
113510: PUSH
113511: LD_INT 1
113513: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113514: LD_VAR 0 4
113518: PUSH
113519: LD_VAR 0 7
113523: ARRAY
113524: PPUSH
113525: CALL_OW 250
113529: PPUSH
113530: LD_VAR 0 4
113534: PUSH
113535: LD_VAR 0 7
113539: ARRAY
113540: PPUSH
113541: CALL_OW 251
113545: PPUSH
113546: CALL_OW 546
113550: PUSH
113551: LD_INT 2
113553: ARRAY
113554: PUSH
113555: LD_VAR 0 14
113559: PUSH
113560: LD_INT 1
113562: ARRAY
113563: PPUSH
113564: CALL_OW 250
113568: PPUSH
113569: LD_VAR 0 14
113573: PUSH
113574: LD_INT 1
113576: ARRAY
113577: PPUSH
113578: CALL_OW 251
113582: PPUSH
113583: CALL_OW 546
113587: PUSH
113588: LD_INT 2
113590: ARRAY
113591: EQUAL
113592: IFFALSE 113620
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
113594: LD_VAR 0 4
113598: PUSH
113599: LD_VAR 0 7
113603: ARRAY
113604: PPUSH
113605: LD_VAR 0 14
113609: PUSH
113610: LD_INT 1
113612: ARRAY
113613: PPUSH
113614: CALL 81731 0 2
113618: GO 113644
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113620: LD_VAR 0 4
113624: PUSH
113625: LD_VAR 0 7
113629: ARRAY
113630: PPUSH
113631: LD_VAR 0 14
113635: PUSH
113636: LD_INT 1
113638: ARRAY
113639: PPUSH
113640: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
113644: LD_VAR 0 4
113648: PUSH
113649: LD_VAR 0 7
113653: ARRAY
113654: PPUSH
113655: CALL_OW 264
113659: PUSH
113660: LD_INT 29
113662: EQUAL
113663: IFFALSE 114029
// begin if WantsToAttack ( group [ i ] ) in bombed then
113665: LD_VAR 0 4
113669: PUSH
113670: LD_VAR 0 7
113674: ARRAY
113675: PPUSH
113676: CALL_OW 319
113680: PUSH
113681: LD_VAR 0 28
113685: IN
113686: IFFALSE 113690
// continue ;
113688: GO 110694
// k := 8 ;
113690: LD_ADDR_VAR 0 9
113694: PUSH
113695: LD_INT 8
113697: ST_TO_ADDR
// x := 0 ;
113698: LD_ADDR_VAR 0 10
113702: PUSH
113703: LD_INT 0
113705: ST_TO_ADDR
// if tmp < k then
113706: LD_VAR 0 14
113710: PUSH
113711: LD_VAR 0 9
113715: LESS
113716: IFFALSE 113728
// k := tmp ;
113718: LD_ADDR_VAR 0 9
113722: PUSH
113723: LD_VAR 0 14
113727: ST_TO_ADDR
// for j = 1 to k do
113728: LD_ADDR_VAR 0 8
113732: PUSH
113733: DOUBLE
113734: LD_INT 1
113736: DEC
113737: ST_TO_ADDR
113738: LD_VAR 0 9
113742: PUSH
113743: FOR_TO
113744: IFFALSE 113876
// begin if GetType ( tmp [ j ] ) = unit_building then
113746: LD_VAR 0 14
113750: PUSH
113751: LD_VAR 0 8
113755: ARRAY
113756: PPUSH
113757: CALL_OW 247
113761: PUSH
113762: LD_INT 3
113764: EQUAL
113765: IFFALSE 113874
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
113767: LD_VAR 0 14
113771: PUSH
113772: LD_VAR 0 8
113776: ARRAY
113777: PUSH
113778: LD_VAR 0 28
113782: IN
113783: NOT
113784: PUSH
113785: LD_VAR 0 14
113789: PUSH
113790: LD_VAR 0 8
113794: ARRAY
113795: PPUSH
113796: CALL_OW 313
113800: AND
113801: IFFALSE 113874
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113803: LD_VAR 0 4
113807: PUSH
113808: LD_VAR 0 7
113812: ARRAY
113813: PPUSH
113814: LD_VAR 0 14
113818: PUSH
113819: LD_VAR 0 8
113823: ARRAY
113824: PPUSH
113825: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
113829: LD_ADDR_VAR 0 28
113833: PUSH
113834: LD_VAR 0 28
113838: PPUSH
113839: LD_VAR 0 28
113843: PUSH
113844: LD_INT 1
113846: PLUS
113847: PPUSH
113848: LD_VAR 0 14
113852: PUSH
113853: LD_VAR 0 8
113857: ARRAY
113858: PPUSH
113859: CALL_OW 1
113863: ST_TO_ADDR
// attacking := true ;
113864: LD_ADDR_VAR 0 29
113868: PUSH
113869: LD_INT 1
113871: ST_TO_ADDR
// break ;
113872: GO 113876
// end ; end ;
113874: GO 113743
113876: POP
113877: POP
// if not attacking and f_attack_depot then
113878: LD_VAR 0 29
113882: NOT
113883: PUSH
113884: LD_VAR 0 25
113888: AND
113889: IFFALSE 113984
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113891: LD_ADDR_VAR 0 13
113895: PUSH
113896: LD_VAR 0 14
113900: PPUSH
113901: LD_INT 2
113903: PUSH
113904: LD_INT 30
113906: PUSH
113907: LD_INT 0
113909: PUSH
113910: EMPTY
113911: LIST
113912: LIST
113913: PUSH
113914: LD_INT 30
113916: PUSH
113917: LD_INT 1
113919: PUSH
113920: EMPTY
113921: LIST
113922: LIST
113923: PUSH
113924: EMPTY
113925: LIST
113926: LIST
113927: LIST
113928: PPUSH
113929: CALL_OW 72
113933: ST_TO_ADDR
// if z then
113934: LD_VAR 0 13
113938: IFFALSE 113984
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
113940: LD_VAR 0 4
113944: PUSH
113945: LD_VAR 0 7
113949: ARRAY
113950: PPUSH
113951: LD_VAR 0 13
113955: PPUSH
113956: LD_VAR 0 4
113960: PUSH
113961: LD_VAR 0 7
113965: ARRAY
113966: PPUSH
113967: CALL_OW 74
113971: PPUSH
113972: CALL_OW 115
// attacking := true ;
113976: LD_ADDR_VAR 0 29
113980: PUSH
113981: LD_INT 1
113983: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
113984: LD_VAR 0 4
113988: PUSH
113989: LD_VAR 0 7
113993: ARRAY
113994: PPUSH
113995: CALL_OW 256
113999: PUSH
114000: LD_INT 500
114002: LESS
114003: IFFALSE 114029
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114005: LD_VAR 0 4
114009: PUSH
114010: LD_VAR 0 7
114014: ARRAY
114015: PPUSH
114016: LD_VAR 0 14
114020: PUSH
114021: LD_INT 1
114023: ARRAY
114024: PPUSH
114025: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
114029: LD_VAR 0 4
114033: PUSH
114034: LD_VAR 0 7
114038: ARRAY
114039: PPUSH
114040: CALL_OW 264
114044: PUSH
114045: LD_INT 49
114047: EQUAL
114048: IFFALSE 114169
// begin if not HasTask ( group [ i ] ) then
114050: LD_VAR 0 4
114054: PUSH
114055: LD_VAR 0 7
114059: ARRAY
114060: PPUSH
114061: CALL_OW 314
114065: NOT
114066: IFFALSE 114169
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
114068: LD_ADDR_VAR 0 9
114072: PUSH
114073: LD_INT 81
114075: PUSH
114076: LD_VAR 0 4
114080: PUSH
114081: LD_VAR 0 7
114085: ARRAY
114086: PPUSH
114087: CALL_OW 255
114091: PUSH
114092: EMPTY
114093: LIST
114094: LIST
114095: PPUSH
114096: CALL_OW 69
114100: PPUSH
114101: LD_VAR 0 4
114105: PUSH
114106: LD_VAR 0 7
114110: ARRAY
114111: PPUSH
114112: CALL_OW 74
114116: ST_TO_ADDR
// if k then
114117: LD_VAR 0 9
114121: IFFALSE 114169
// if GetDistUnits ( group [ i ] , k ) > 10 then
114123: LD_VAR 0 4
114127: PUSH
114128: LD_VAR 0 7
114132: ARRAY
114133: PPUSH
114134: LD_VAR 0 9
114138: PPUSH
114139: CALL_OW 296
114143: PUSH
114144: LD_INT 10
114146: GREATER
114147: IFFALSE 114169
// ComMoveUnit ( group [ i ] , k ) ;
114149: LD_VAR 0 4
114153: PUSH
114154: LD_VAR 0 7
114158: ARRAY
114159: PPUSH
114160: LD_VAR 0 9
114164: PPUSH
114165: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
114169: LD_VAR 0 4
114173: PUSH
114174: LD_VAR 0 7
114178: ARRAY
114179: PPUSH
114180: CALL_OW 256
114184: PUSH
114185: LD_INT 250
114187: LESS
114188: PUSH
114189: LD_VAR 0 4
114193: PUSH
114194: LD_VAR 0 7
114198: ARRAY
114199: PUSH
114200: LD_INT 21
114202: PUSH
114203: LD_INT 2
114205: PUSH
114206: EMPTY
114207: LIST
114208: LIST
114209: PUSH
114210: LD_INT 23
114212: PUSH
114213: LD_INT 2
114215: PUSH
114216: EMPTY
114217: LIST
114218: LIST
114219: PUSH
114220: EMPTY
114221: LIST
114222: LIST
114223: PPUSH
114224: CALL_OW 69
114228: IN
114229: AND
114230: IFFALSE 114355
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114232: LD_ADDR_VAR 0 9
114236: PUSH
114237: LD_OWVAR 3
114241: PUSH
114242: LD_VAR 0 4
114246: PUSH
114247: LD_VAR 0 7
114251: ARRAY
114252: DIFF
114253: PPUSH
114254: LD_VAR 0 4
114258: PUSH
114259: LD_VAR 0 7
114263: ARRAY
114264: PPUSH
114265: CALL_OW 74
114269: ST_TO_ADDR
// if not k then
114270: LD_VAR 0 9
114274: NOT
114275: IFFALSE 114279
// continue ;
114277: GO 110694
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114279: LD_VAR 0 9
114283: PUSH
114284: LD_INT 81
114286: PUSH
114287: LD_VAR 0 4
114291: PUSH
114292: LD_VAR 0 7
114296: ARRAY
114297: PPUSH
114298: CALL_OW 255
114302: PUSH
114303: EMPTY
114304: LIST
114305: LIST
114306: PPUSH
114307: CALL_OW 69
114311: IN
114312: PUSH
114313: LD_VAR 0 9
114317: PPUSH
114318: LD_VAR 0 4
114322: PUSH
114323: LD_VAR 0 7
114327: ARRAY
114328: PPUSH
114329: CALL_OW 296
114333: PUSH
114334: LD_INT 5
114336: LESS
114337: AND
114338: IFFALSE 114355
// ComAutodestruct ( group [ i ] ) ;
114340: LD_VAR 0 4
114344: PUSH
114345: LD_VAR 0 7
114349: ARRAY
114350: PPUSH
114351: CALL 81629 0 1
// end ; if f_attack_depot then
114355: LD_VAR 0 25
114359: IFFALSE 114471
// begin k := 6 ;
114361: LD_ADDR_VAR 0 9
114365: PUSH
114366: LD_INT 6
114368: ST_TO_ADDR
// if tmp < k then
114369: LD_VAR 0 14
114373: PUSH
114374: LD_VAR 0 9
114378: LESS
114379: IFFALSE 114391
// k := tmp ;
114381: LD_ADDR_VAR 0 9
114385: PUSH
114386: LD_VAR 0 14
114390: ST_TO_ADDR
// for j = 1 to k do
114391: LD_ADDR_VAR 0 8
114395: PUSH
114396: DOUBLE
114397: LD_INT 1
114399: DEC
114400: ST_TO_ADDR
114401: LD_VAR 0 9
114405: PUSH
114406: FOR_TO
114407: IFFALSE 114469
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114409: LD_VAR 0 8
114413: PPUSH
114414: CALL_OW 266
114418: PUSH
114419: LD_INT 0
114421: PUSH
114422: LD_INT 1
114424: PUSH
114425: EMPTY
114426: LIST
114427: LIST
114428: IN
114429: IFFALSE 114467
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114431: LD_VAR 0 4
114435: PUSH
114436: LD_VAR 0 7
114440: ARRAY
114441: PPUSH
114442: LD_VAR 0 14
114446: PUSH
114447: LD_VAR 0 8
114451: ARRAY
114452: PPUSH
114453: CALL_OW 115
// attacking := true ;
114457: LD_ADDR_VAR 0 29
114461: PUSH
114462: LD_INT 1
114464: ST_TO_ADDR
// break ;
114465: GO 114469
// end ;
114467: GO 114406
114469: POP
114470: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
114471: LD_VAR 0 4
114475: PUSH
114476: LD_VAR 0 7
114480: ARRAY
114481: PPUSH
114482: CALL_OW 302
114486: PUSH
114487: LD_VAR 0 29
114491: NOT
114492: AND
114493: IFFALSE 114815
// begin if GetTag ( group [ i ] ) = 71 then
114495: LD_VAR 0 4
114499: PUSH
114500: LD_VAR 0 7
114504: ARRAY
114505: PPUSH
114506: CALL_OW 110
114510: PUSH
114511: LD_INT 71
114513: EQUAL
114514: IFFALSE 114555
// begin if HasTask ( group [ i ] ) then
114516: LD_VAR 0 4
114520: PUSH
114521: LD_VAR 0 7
114525: ARRAY
114526: PPUSH
114527: CALL_OW 314
114531: IFFALSE 114537
// continue else
114533: GO 110694
114535: GO 114555
// SetTag ( group [ i ] , 0 ) ;
114537: LD_VAR 0 4
114541: PUSH
114542: LD_VAR 0 7
114546: ARRAY
114547: PPUSH
114548: LD_INT 0
114550: PPUSH
114551: CALL_OW 109
// end ; k := 8 ;
114555: LD_ADDR_VAR 0 9
114559: PUSH
114560: LD_INT 8
114562: ST_TO_ADDR
// x := 0 ;
114563: LD_ADDR_VAR 0 10
114567: PUSH
114568: LD_INT 0
114570: ST_TO_ADDR
// if tmp < k then
114571: LD_VAR 0 14
114575: PUSH
114576: LD_VAR 0 9
114580: LESS
114581: IFFALSE 114593
// k := tmp ;
114583: LD_ADDR_VAR 0 9
114587: PUSH
114588: LD_VAR 0 14
114592: ST_TO_ADDR
// for j = 1 to k do
114593: LD_ADDR_VAR 0 8
114597: PUSH
114598: DOUBLE
114599: LD_INT 1
114601: DEC
114602: ST_TO_ADDR
114603: LD_VAR 0 9
114607: PUSH
114608: FOR_TO
114609: IFFALSE 114707
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
114611: LD_VAR 0 14
114615: PUSH
114616: LD_VAR 0 8
114620: ARRAY
114621: PPUSH
114622: CALL_OW 247
114626: PUSH
114627: LD_INT 1
114629: EQUAL
114630: PUSH
114631: LD_VAR 0 14
114635: PUSH
114636: LD_VAR 0 8
114640: ARRAY
114641: PPUSH
114642: CALL_OW 256
114646: PUSH
114647: LD_INT 250
114649: LESS
114650: PUSH
114651: LD_VAR 0 20
114655: AND
114656: PUSH
114657: LD_VAR 0 20
114661: NOT
114662: PUSH
114663: LD_VAR 0 14
114667: PUSH
114668: LD_VAR 0 8
114672: ARRAY
114673: PPUSH
114674: CALL_OW 256
114678: PUSH
114679: LD_INT 250
114681: GREATEREQUAL
114682: AND
114683: OR
114684: AND
114685: IFFALSE 114705
// begin x := tmp [ j ] ;
114687: LD_ADDR_VAR 0 10
114691: PUSH
114692: LD_VAR 0 14
114696: PUSH
114697: LD_VAR 0 8
114701: ARRAY
114702: ST_TO_ADDR
// break ;
114703: GO 114707
// end ;
114705: GO 114608
114707: POP
114708: POP
// if x then
114709: LD_VAR 0 10
114713: IFFALSE 114737
// ComAttackUnit ( group [ i ] , x ) else
114715: LD_VAR 0 4
114719: PUSH
114720: LD_VAR 0 7
114724: ARRAY
114725: PPUSH
114726: LD_VAR 0 10
114730: PPUSH
114731: CALL_OW 115
114735: GO 114761
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114737: LD_VAR 0 4
114741: PUSH
114742: LD_VAR 0 7
114746: ARRAY
114747: PPUSH
114748: LD_VAR 0 14
114752: PUSH
114753: LD_INT 1
114755: ARRAY
114756: PPUSH
114757: CALL_OW 115
// if not HasTask ( group [ i ] ) then
114761: LD_VAR 0 4
114765: PUSH
114766: LD_VAR 0 7
114770: ARRAY
114771: PPUSH
114772: CALL_OW 314
114776: NOT
114777: IFFALSE 114815
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
114779: LD_VAR 0 4
114783: PUSH
114784: LD_VAR 0 7
114788: ARRAY
114789: PPUSH
114790: LD_VAR 0 14
114794: PPUSH
114795: LD_VAR 0 4
114799: PUSH
114800: LD_VAR 0 7
114804: ARRAY
114805: PPUSH
114806: CALL_OW 74
114810: PPUSH
114811: CALL_OW 115
// end ; end ; end ;
114815: GO 110694
114817: POP
114818: POP
// wait ( 0 0$2 ) ;
114819: LD_INT 70
114821: PPUSH
114822: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
114826: LD_VAR 0 4
114830: NOT
114831: PUSH
114832: LD_VAR 0 4
114836: PUSH
114837: EMPTY
114838: EQUAL
114839: OR
114840: PUSH
114841: LD_INT 81
114843: PUSH
114844: LD_VAR 0 35
114848: PUSH
114849: EMPTY
114850: LIST
114851: LIST
114852: PPUSH
114853: CALL_OW 69
114857: NOT
114858: OR
114859: IFFALSE 110679
// end ;
114861: LD_VAR 0 2
114865: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
114866: LD_INT 0
114868: PPUSH
114869: PPUSH
114870: PPUSH
114871: PPUSH
114872: PPUSH
114873: PPUSH
// if not base or not mc_bases [ base ] or not solds then
114874: LD_VAR 0 1
114878: NOT
114879: PUSH
114880: LD_EXP 50
114884: PUSH
114885: LD_VAR 0 1
114889: ARRAY
114890: NOT
114891: OR
114892: PUSH
114893: LD_VAR 0 2
114897: NOT
114898: OR
114899: IFFALSE 114903
// exit ;
114901: GO 115457
// side := mc_sides [ base ] ;
114903: LD_ADDR_VAR 0 6
114907: PUSH
114908: LD_EXP 76
114912: PUSH
114913: LD_VAR 0 1
114917: ARRAY
114918: ST_TO_ADDR
// if not side then
114919: LD_VAR 0 6
114923: NOT
114924: IFFALSE 114928
// exit ;
114926: GO 115457
// for i in solds do
114928: LD_ADDR_VAR 0 7
114932: PUSH
114933: LD_VAR 0 2
114937: PUSH
114938: FOR_IN
114939: IFFALSE 115000
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
114941: LD_VAR 0 7
114945: PPUSH
114946: CALL_OW 310
114950: PPUSH
114951: CALL_OW 266
114955: PUSH
114956: LD_INT 32
114958: PUSH
114959: LD_INT 31
114961: PUSH
114962: EMPTY
114963: LIST
114964: LIST
114965: IN
114966: IFFALSE 114986
// solds := solds diff i else
114968: LD_ADDR_VAR 0 2
114972: PUSH
114973: LD_VAR 0 2
114977: PUSH
114978: LD_VAR 0 7
114982: DIFF
114983: ST_TO_ADDR
114984: GO 114998
// SetTag ( i , 18 ) ;
114986: LD_VAR 0 7
114990: PPUSH
114991: LD_INT 18
114993: PPUSH
114994: CALL_OW 109
114998: GO 114938
115000: POP
115001: POP
// if not solds then
115002: LD_VAR 0 2
115006: NOT
115007: IFFALSE 115011
// exit ;
115009: GO 115457
// repeat wait ( 0 0$2 ) ;
115011: LD_INT 70
115013: PPUSH
115014: CALL_OW 67
// enemy := mc_scan [ base ] ;
115018: LD_ADDR_VAR 0 4
115022: PUSH
115023: LD_EXP 73
115027: PUSH
115028: LD_VAR 0 1
115032: ARRAY
115033: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115034: LD_EXP 50
115038: PUSH
115039: LD_VAR 0 1
115043: ARRAY
115044: NOT
115045: PUSH
115046: LD_EXP 50
115050: PUSH
115051: LD_VAR 0 1
115055: ARRAY
115056: PUSH
115057: EMPTY
115058: EQUAL
115059: OR
115060: IFFALSE 115097
// begin for i in solds do
115062: LD_ADDR_VAR 0 7
115066: PUSH
115067: LD_VAR 0 2
115071: PUSH
115072: FOR_IN
115073: IFFALSE 115086
// ComStop ( i ) ;
115075: LD_VAR 0 7
115079: PPUSH
115080: CALL_OW 141
115084: GO 115072
115086: POP
115087: POP
// solds := [ ] ;
115088: LD_ADDR_VAR 0 2
115092: PUSH
115093: EMPTY
115094: ST_TO_ADDR
// exit ;
115095: GO 115457
// end ; for i in solds do
115097: LD_ADDR_VAR 0 7
115101: PUSH
115102: LD_VAR 0 2
115106: PUSH
115107: FOR_IN
115108: IFFALSE 115429
// begin if IsInUnit ( i ) then
115110: LD_VAR 0 7
115114: PPUSH
115115: CALL_OW 310
115119: IFFALSE 115130
// ComExitBuilding ( i ) ;
115121: LD_VAR 0 7
115125: PPUSH
115126: CALL_OW 122
// if GetLives ( i ) > 500 then
115130: LD_VAR 0 7
115134: PPUSH
115135: CALL_OW 256
115139: PUSH
115140: LD_INT 500
115142: GREATER
115143: IFFALSE 115196
// begin e := NearestUnitToUnit ( enemy , i ) ;
115145: LD_ADDR_VAR 0 5
115149: PUSH
115150: LD_VAR 0 4
115154: PPUSH
115155: LD_VAR 0 7
115159: PPUSH
115160: CALL_OW 74
115164: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
115165: LD_VAR 0 7
115169: PPUSH
115170: LD_VAR 0 5
115174: PPUSH
115175: CALL_OW 250
115179: PPUSH
115180: LD_VAR 0 5
115184: PPUSH
115185: CALL_OW 251
115189: PPUSH
115190: CALL_OW 114
// end else
115194: GO 115427
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
115196: LD_VAR 0 7
115200: PPUSH
115201: LD_EXP 50
115205: PUSH
115206: LD_VAR 0 1
115210: ARRAY
115211: PPUSH
115212: LD_INT 2
115214: PUSH
115215: LD_INT 30
115217: PUSH
115218: LD_INT 0
115220: PUSH
115221: EMPTY
115222: LIST
115223: LIST
115224: PUSH
115225: LD_INT 30
115227: PUSH
115228: LD_INT 1
115230: PUSH
115231: EMPTY
115232: LIST
115233: LIST
115234: PUSH
115235: LD_INT 30
115237: PUSH
115238: LD_INT 6
115240: PUSH
115241: EMPTY
115242: LIST
115243: LIST
115244: PUSH
115245: EMPTY
115246: LIST
115247: LIST
115248: LIST
115249: LIST
115250: PPUSH
115251: CALL_OW 72
115255: PPUSH
115256: LD_VAR 0 7
115260: PPUSH
115261: CALL_OW 74
115265: PPUSH
115266: CALL_OW 296
115270: PUSH
115271: LD_INT 10
115273: GREATER
115274: IFFALSE 115427
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115276: LD_ADDR_VAR 0 8
115280: PUSH
115281: LD_EXP 50
115285: PUSH
115286: LD_VAR 0 1
115290: ARRAY
115291: PPUSH
115292: LD_INT 2
115294: PUSH
115295: LD_INT 30
115297: PUSH
115298: LD_INT 0
115300: PUSH
115301: EMPTY
115302: LIST
115303: LIST
115304: PUSH
115305: LD_INT 30
115307: PUSH
115308: LD_INT 1
115310: PUSH
115311: EMPTY
115312: LIST
115313: LIST
115314: PUSH
115315: LD_INT 30
115317: PUSH
115318: LD_INT 6
115320: PUSH
115321: EMPTY
115322: LIST
115323: LIST
115324: PUSH
115325: EMPTY
115326: LIST
115327: LIST
115328: LIST
115329: LIST
115330: PPUSH
115331: CALL_OW 72
115335: PPUSH
115336: LD_VAR 0 7
115340: PPUSH
115341: CALL_OW 74
115345: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115346: LD_VAR 0 7
115350: PPUSH
115351: LD_VAR 0 8
115355: PPUSH
115356: CALL_OW 250
115360: PPUSH
115361: LD_INT 3
115363: PPUSH
115364: LD_INT 5
115366: PPUSH
115367: CALL_OW 272
115371: PPUSH
115372: LD_VAR 0 8
115376: PPUSH
115377: CALL_OW 251
115381: PPUSH
115382: LD_INT 3
115384: PPUSH
115385: LD_INT 5
115387: PPUSH
115388: CALL_OW 273
115392: PPUSH
115393: CALL_OW 111
// SetTag ( i , 0 ) ;
115397: LD_VAR 0 7
115401: PPUSH
115402: LD_INT 0
115404: PPUSH
115405: CALL_OW 109
// solds := solds diff i ;
115409: LD_ADDR_VAR 0 2
115413: PUSH
115414: LD_VAR 0 2
115418: PUSH
115419: LD_VAR 0 7
115423: DIFF
115424: ST_TO_ADDR
// continue ;
115425: GO 115107
// end ; end ;
115427: GO 115107
115429: POP
115430: POP
// until not solds or not enemy ;
115431: LD_VAR 0 2
115435: NOT
115436: PUSH
115437: LD_VAR 0 4
115441: NOT
115442: OR
115443: IFFALSE 115011
// MC_Reset ( base , 18 ) ;
115445: LD_VAR 0 1
115449: PPUSH
115450: LD_INT 18
115452: PPUSH
115453: CALL 22145 0 2
// end ;
115457: LD_VAR 0 3
115461: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
115462: LD_INT 0
115464: PPUSH
115465: PPUSH
115466: PPUSH
115467: PPUSH
115468: PPUSH
115469: PPUSH
115470: PPUSH
115471: PPUSH
115472: PPUSH
115473: PPUSH
115474: PPUSH
115475: PPUSH
115476: PPUSH
115477: PPUSH
115478: PPUSH
115479: PPUSH
115480: PPUSH
115481: PPUSH
115482: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
115483: LD_ADDR_VAR 0 12
115487: PUSH
115488: LD_EXP 50
115492: PUSH
115493: LD_VAR 0 1
115497: ARRAY
115498: PPUSH
115499: LD_INT 25
115501: PUSH
115502: LD_INT 3
115504: PUSH
115505: EMPTY
115506: LIST
115507: LIST
115508: PPUSH
115509: CALL_OW 72
115513: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115514: LD_EXP 90
115518: PUSH
115519: LD_VAR 0 1
115523: ARRAY
115524: IFFALSE 115548
// mechs := mechs diff mc_remote_driver [ base ] ;
115526: LD_ADDR_VAR 0 12
115530: PUSH
115531: LD_VAR 0 12
115535: PUSH
115536: LD_EXP 90
115540: PUSH
115541: LD_VAR 0 1
115545: ARRAY
115546: DIFF
115547: ST_TO_ADDR
// for i in mechs do
115548: LD_ADDR_VAR 0 4
115552: PUSH
115553: LD_VAR 0 12
115557: PUSH
115558: FOR_IN
115559: IFFALSE 115594
// if GetTag ( i ) > 0 then
115561: LD_VAR 0 4
115565: PPUSH
115566: CALL_OW 110
115570: PUSH
115571: LD_INT 0
115573: GREATER
115574: IFFALSE 115592
// mechs := mechs diff i ;
115576: LD_ADDR_VAR 0 12
115580: PUSH
115581: LD_VAR 0 12
115585: PUSH
115586: LD_VAR 0 4
115590: DIFF
115591: ST_TO_ADDR
115592: GO 115558
115594: POP
115595: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115596: LD_ADDR_VAR 0 8
115600: PUSH
115601: LD_EXP 50
115605: PUSH
115606: LD_VAR 0 1
115610: ARRAY
115611: PPUSH
115612: LD_INT 2
115614: PUSH
115615: LD_INT 25
115617: PUSH
115618: LD_INT 1
115620: PUSH
115621: EMPTY
115622: LIST
115623: LIST
115624: PUSH
115625: LD_INT 25
115627: PUSH
115628: LD_INT 5
115630: PUSH
115631: EMPTY
115632: LIST
115633: LIST
115634: PUSH
115635: LD_INT 25
115637: PUSH
115638: LD_INT 8
115640: PUSH
115641: EMPTY
115642: LIST
115643: LIST
115644: PUSH
115645: LD_INT 25
115647: PUSH
115648: LD_INT 9
115650: PUSH
115651: EMPTY
115652: LIST
115653: LIST
115654: PUSH
115655: EMPTY
115656: LIST
115657: LIST
115658: LIST
115659: LIST
115660: LIST
115661: PPUSH
115662: CALL_OW 72
115666: ST_TO_ADDR
// if not defenders and not solds then
115667: LD_VAR 0 2
115671: NOT
115672: PUSH
115673: LD_VAR 0 8
115677: NOT
115678: AND
115679: IFFALSE 115683
// exit ;
115681: GO 117453
// depot_under_attack := false ;
115683: LD_ADDR_VAR 0 16
115687: PUSH
115688: LD_INT 0
115690: ST_TO_ADDR
// sold_defenders := [ ] ;
115691: LD_ADDR_VAR 0 17
115695: PUSH
115696: EMPTY
115697: ST_TO_ADDR
// if mechs then
115698: LD_VAR 0 12
115702: IFFALSE 115855
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
115704: LD_ADDR_VAR 0 4
115708: PUSH
115709: LD_VAR 0 2
115713: PPUSH
115714: LD_INT 21
115716: PUSH
115717: LD_INT 2
115719: PUSH
115720: EMPTY
115721: LIST
115722: LIST
115723: PPUSH
115724: CALL_OW 72
115728: PUSH
115729: FOR_IN
115730: IFFALSE 115853
// begin if GetTag ( i ) <> 20 then
115732: LD_VAR 0 4
115736: PPUSH
115737: CALL_OW 110
115741: PUSH
115742: LD_INT 20
115744: NONEQUAL
115745: IFFALSE 115759
// SetTag ( i , 20 ) ;
115747: LD_VAR 0 4
115751: PPUSH
115752: LD_INT 20
115754: PPUSH
115755: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
115759: LD_VAR 0 4
115763: PPUSH
115764: CALL_OW 263
115768: PUSH
115769: LD_INT 1
115771: EQUAL
115772: PUSH
115773: LD_VAR 0 4
115777: PPUSH
115778: CALL_OW 311
115782: NOT
115783: AND
115784: IFFALSE 115851
// begin un := mechs [ 1 ] ;
115786: LD_ADDR_VAR 0 10
115790: PUSH
115791: LD_VAR 0 12
115795: PUSH
115796: LD_INT 1
115798: ARRAY
115799: ST_TO_ADDR
// ComExit ( un ) ;
115800: LD_VAR 0 10
115804: PPUSH
115805: CALL 86514 0 1
// AddComEnterUnit ( un , i ) ;
115809: LD_VAR 0 10
115813: PPUSH
115814: LD_VAR 0 4
115818: PPUSH
115819: CALL_OW 180
// SetTag ( un , 19 ) ;
115823: LD_VAR 0 10
115827: PPUSH
115828: LD_INT 19
115830: PPUSH
115831: CALL_OW 109
// mechs := mechs diff un ;
115835: LD_ADDR_VAR 0 12
115839: PUSH
115840: LD_VAR 0 12
115844: PUSH
115845: LD_VAR 0 10
115849: DIFF
115850: ST_TO_ADDR
// end ; end ;
115851: GO 115729
115853: POP
115854: POP
// if solds then
115855: LD_VAR 0 8
115859: IFFALSE 115918
// for i in solds do
115861: LD_ADDR_VAR 0 4
115865: PUSH
115866: LD_VAR 0 8
115870: PUSH
115871: FOR_IN
115872: IFFALSE 115916
// if not GetTag ( i ) then
115874: LD_VAR 0 4
115878: PPUSH
115879: CALL_OW 110
115883: NOT
115884: IFFALSE 115914
// begin defenders := defenders union i ;
115886: LD_ADDR_VAR 0 2
115890: PUSH
115891: LD_VAR 0 2
115895: PUSH
115896: LD_VAR 0 4
115900: UNION
115901: ST_TO_ADDR
// SetTag ( i , 18 ) ;
115902: LD_VAR 0 4
115906: PPUSH
115907: LD_INT 18
115909: PPUSH
115910: CALL_OW 109
// end ;
115914: GO 115871
115916: POP
115917: POP
// repeat wait ( 0 0$2 ) ;
115918: LD_INT 70
115920: PPUSH
115921: CALL_OW 67
// enemy := mc_scan [ base ] ;
115925: LD_ADDR_VAR 0 21
115929: PUSH
115930: LD_EXP 73
115934: PUSH
115935: LD_VAR 0 1
115939: ARRAY
115940: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115941: LD_EXP 50
115945: PUSH
115946: LD_VAR 0 1
115950: ARRAY
115951: NOT
115952: PUSH
115953: LD_EXP 50
115957: PUSH
115958: LD_VAR 0 1
115962: ARRAY
115963: PUSH
115964: EMPTY
115965: EQUAL
115966: OR
115967: IFFALSE 116004
// begin for i in defenders do
115969: LD_ADDR_VAR 0 4
115973: PUSH
115974: LD_VAR 0 2
115978: PUSH
115979: FOR_IN
115980: IFFALSE 115993
// ComStop ( i ) ;
115982: LD_VAR 0 4
115986: PPUSH
115987: CALL_OW 141
115991: GO 115979
115993: POP
115994: POP
// defenders := [ ] ;
115995: LD_ADDR_VAR 0 2
115999: PUSH
116000: EMPTY
116001: ST_TO_ADDR
// exit ;
116002: GO 117453
// end ; for i in defenders do
116004: LD_ADDR_VAR 0 4
116008: PUSH
116009: LD_VAR 0 2
116013: PUSH
116014: FOR_IN
116015: IFFALSE 116913
// begin e := NearestUnitToUnit ( enemy , i ) ;
116017: LD_ADDR_VAR 0 13
116021: PUSH
116022: LD_VAR 0 21
116026: PPUSH
116027: LD_VAR 0 4
116031: PPUSH
116032: CALL_OW 74
116036: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116037: LD_ADDR_VAR 0 7
116041: PUSH
116042: LD_EXP 50
116046: PUSH
116047: LD_VAR 0 1
116051: ARRAY
116052: PPUSH
116053: LD_INT 2
116055: PUSH
116056: LD_INT 30
116058: PUSH
116059: LD_INT 0
116061: PUSH
116062: EMPTY
116063: LIST
116064: LIST
116065: PUSH
116066: LD_INT 30
116068: PUSH
116069: LD_INT 1
116071: PUSH
116072: EMPTY
116073: LIST
116074: LIST
116075: PUSH
116076: EMPTY
116077: LIST
116078: LIST
116079: LIST
116080: PPUSH
116081: CALL_OW 72
116085: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
116086: LD_ADDR_VAR 0 16
116090: PUSH
116091: LD_VAR 0 7
116095: NOT
116096: PUSH
116097: LD_VAR 0 7
116101: PPUSH
116102: LD_INT 3
116104: PUSH
116105: LD_INT 24
116107: PUSH
116108: LD_INT 600
116110: PUSH
116111: EMPTY
116112: LIST
116113: LIST
116114: PUSH
116115: EMPTY
116116: LIST
116117: LIST
116118: PPUSH
116119: CALL_OW 72
116123: OR
116124: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
116125: LD_VAR 0 4
116129: PPUSH
116130: CALL_OW 247
116134: PUSH
116135: LD_INT 2
116137: DOUBLE
116138: EQUAL
116139: IFTRUE 116143
116141: GO 116539
116143: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
116144: LD_VAR 0 4
116148: PPUSH
116149: CALL_OW 256
116153: PUSH
116154: LD_INT 1000
116156: EQUAL
116157: PUSH
116158: LD_VAR 0 4
116162: PPUSH
116163: LD_VAR 0 13
116167: PPUSH
116168: CALL_OW 296
116172: PUSH
116173: LD_INT 40
116175: LESS
116176: PUSH
116177: LD_VAR 0 13
116181: PPUSH
116182: LD_EXP 75
116186: PUSH
116187: LD_VAR 0 1
116191: ARRAY
116192: PPUSH
116193: CALL_OW 308
116197: OR
116198: AND
116199: IFFALSE 116321
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116201: LD_VAR 0 4
116205: PPUSH
116206: CALL_OW 262
116210: PUSH
116211: LD_INT 1
116213: EQUAL
116214: PUSH
116215: LD_VAR 0 4
116219: PPUSH
116220: CALL_OW 261
116224: PUSH
116225: LD_INT 30
116227: LESS
116228: AND
116229: PUSH
116230: LD_VAR 0 7
116234: AND
116235: IFFALSE 116305
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116237: LD_VAR 0 4
116241: PPUSH
116242: LD_VAR 0 7
116246: PPUSH
116247: LD_VAR 0 4
116251: PPUSH
116252: CALL_OW 74
116256: PPUSH
116257: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116261: LD_VAR 0 4
116265: PPUSH
116266: LD_VAR 0 7
116270: PPUSH
116271: LD_VAR 0 4
116275: PPUSH
116276: CALL_OW 74
116280: PPUSH
116281: CALL_OW 296
116285: PUSH
116286: LD_INT 6
116288: LESS
116289: IFFALSE 116303
// SetFuel ( i , 100 ) ;
116291: LD_VAR 0 4
116295: PPUSH
116296: LD_INT 100
116298: PPUSH
116299: CALL_OW 240
// end else
116303: GO 116319
// ComAttackUnit ( i , e ) ;
116305: LD_VAR 0 4
116309: PPUSH
116310: LD_VAR 0 13
116314: PPUSH
116315: CALL_OW 115
// end else
116319: GO 116422
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116321: LD_VAR 0 13
116325: PPUSH
116326: LD_EXP 75
116330: PUSH
116331: LD_VAR 0 1
116335: ARRAY
116336: PPUSH
116337: CALL_OW 308
116341: NOT
116342: PUSH
116343: LD_VAR 0 4
116347: PPUSH
116348: LD_VAR 0 13
116352: PPUSH
116353: CALL_OW 296
116357: PUSH
116358: LD_INT 40
116360: GREATEREQUAL
116361: AND
116362: PUSH
116363: LD_VAR 0 4
116367: PPUSH
116368: CALL_OW 256
116372: PUSH
116373: LD_INT 650
116375: LESSEQUAL
116376: OR
116377: PUSH
116378: LD_VAR 0 4
116382: PPUSH
116383: LD_EXP 74
116387: PUSH
116388: LD_VAR 0 1
116392: ARRAY
116393: PPUSH
116394: CALL_OW 308
116398: NOT
116399: AND
116400: IFFALSE 116422
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116402: LD_VAR 0 4
116406: PPUSH
116407: LD_EXP 74
116411: PUSH
116412: LD_VAR 0 1
116416: ARRAY
116417: PPUSH
116418: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116422: LD_VAR 0 4
116426: PPUSH
116427: CALL_OW 256
116431: PUSH
116432: LD_INT 1000
116434: LESS
116435: PUSH
116436: LD_VAR 0 4
116440: PPUSH
116441: CALL_OW 263
116445: PUSH
116446: LD_INT 1
116448: EQUAL
116449: AND
116450: PUSH
116451: LD_VAR 0 4
116455: PPUSH
116456: CALL_OW 311
116460: AND
116461: PUSH
116462: LD_VAR 0 4
116466: PPUSH
116467: LD_EXP 74
116471: PUSH
116472: LD_VAR 0 1
116476: ARRAY
116477: PPUSH
116478: CALL_OW 308
116482: AND
116483: IFFALSE 116537
// begin mech := IsDrivenBy ( i ) ;
116485: LD_ADDR_VAR 0 9
116489: PUSH
116490: LD_VAR 0 4
116494: PPUSH
116495: CALL_OW 311
116499: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116500: LD_VAR 0 9
116504: PPUSH
116505: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116509: LD_VAR 0 9
116513: PPUSH
116514: LD_VAR 0 4
116518: PPUSH
116519: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
116523: LD_VAR 0 9
116527: PPUSH
116528: LD_VAR 0 4
116532: PPUSH
116533: CALL_OW 180
// end ; end ; unit_human :
116537: GO 116884
116539: LD_INT 1
116541: DOUBLE
116542: EQUAL
116543: IFTRUE 116547
116545: GO 116883
116547: POP
// begin b := IsInUnit ( i ) ;
116548: LD_ADDR_VAR 0 18
116552: PUSH
116553: LD_VAR 0 4
116557: PPUSH
116558: CALL_OW 310
116562: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
116563: LD_ADDR_VAR 0 19
116567: PUSH
116568: LD_VAR 0 18
116572: NOT
116573: PUSH
116574: LD_VAR 0 18
116578: PPUSH
116579: CALL_OW 266
116583: PUSH
116584: LD_INT 32
116586: PUSH
116587: LD_INT 31
116589: PUSH
116590: EMPTY
116591: LIST
116592: LIST
116593: IN
116594: OR
116595: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
116596: LD_VAR 0 18
116600: PPUSH
116601: CALL_OW 266
116605: PUSH
116606: LD_INT 5
116608: EQUAL
116609: PUSH
116610: LD_VAR 0 4
116614: PPUSH
116615: CALL_OW 257
116619: PUSH
116620: LD_INT 1
116622: PUSH
116623: LD_INT 2
116625: PUSH
116626: LD_INT 3
116628: PUSH
116629: LD_INT 4
116631: PUSH
116632: EMPTY
116633: LIST
116634: LIST
116635: LIST
116636: LIST
116637: IN
116638: AND
116639: IFFALSE 116676
// begin class := AllowSpecClass ( i ) ;
116641: LD_ADDR_VAR 0 20
116645: PUSH
116646: LD_VAR 0 4
116650: PPUSH
116651: CALL 50434 0 1
116655: ST_TO_ADDR
// if class then
116656: LD_VAR 0 20
116660: IFFALSE 116676
// ComChangeProfession ( i , class ) ;
116662: LD_VAR 0 4
116666: PPUSH
116667: LD_VAR 0 20
116671: PPUSH
116672: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
116676: LD_VAR 0 16
116680: PUSH
116681: LD_VAR 0 2
116685: PPUSH
116686: LD_INT 21
116688: PUSH
116689: LD_INT 2
116691: PUSH
116692: EMPTY
116693: LIST
116694: LIST
116695: PPUSH
116696: CALL_OW 72
116700: PUSH
116701: LD_INT 1
116703: LESSEQUAL
116704: OR
116705: PUSH
116706: LD_VAR 0 19
116710: AND
116711: PUSH
116712: LD_VAR 0 4
116716: PUSH
116717: LD_VAR 0 17
116721: IN
116722: NOT
116723: AND
116724: IFFALSE 116817
// begin if b then
116726: LD_VAR 0 18
116730: IFFALSE 116779
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
116732: LD_VAR 0 18
116736: PPUSH
116737: LD_VAR 0 21
116741: PPUSH
116742: LD_VAR 0 18
116746: PPUSH
116747: CALL_OW 74
116751: PPUSH
116752: CALL_OW 296
116756: PUSH
116757: LD_INT 10
116759: LESS
116760: PUSH
116761: LD_VAR 0 18
116765: PPUSH
116766: CALL_OW 461
116770: PUSH
116771: LD_INT 7
116773: NONEQUAL
116774: AND
116775: IFFALSE 116779
// continue ;
116777: GO 116014
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
116779: LD_ADDR_VAR 0 17
116783: PUSH
116784: LD_VAR 0 17
116788: PPUSH
116789: LD_VAR 0 17
116793: PUSH
116794: LD_INT 1
116796: PLUS
116797: PPUSH
116798: LD_VAR 0 4
116802: PPUSH
116803: CALL_OW 1
116807: ST_TO_ADDR
// ComExitBuilding ( i ) ;
116808: LD_VAR 0 4
116812: PPUSH
116813: CALL_OW 122
// end ; if sold_defenders then
116817: LD_VAR 0 17
116821: IFFALSE 116881
// if i in sold_defenders then
116823: LD_VAR 0 4
116827: PUSH
116828: LD_VAR 0 17
116832: IN
116833: IFFALSE 116881
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
116835: LD_VAR 0 4
116839: PPUSH
116840: CALL_OW 314
116844: NOT
116845: PUSH
116846: LD_VAR 0 4
116850: PPUSH
116851: LD_VAR 0 13
116855: PPUSH
116856: CALL_OW 296
116860: PUSH
116861: LD_INT 30
116863: LESS
116864: AND
116865: IFFALSE 116881
// ComAttackUnit ( i , e ) ;
116867: LD_VAR 0 4
116871: PPUSH
116872: LD_VAR 0 13
116876: PPUSH
116877: CALL_OW 115
// end ; end ; end ;
116881: GO 116884
116883: POP
// if IsDead ( i ) then
116884: LD_VAR 0 4
116888: PPUSH
116889: CALL_OW 301
116893: IFFALSE 116911
// defenders := defenders diff i ;
116895: LD_ADDR_VAR 0 2
116899: PUSH
116900: LD_VAR 0 2
116904: PUSH
116905: LD_VAR 0 4
116909: DIFF
116910: ST_TO_ADDR
// end ;
116911: GO 116014
116913: POP
116914: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
116915: LD_VAR 0 21
116919: NOT
116920: PUSH
116921: LD_VAR 0 2
116925: NOT
116926: OR
116927: PUSH
116928: LD_EXP 50
116932: PUSH
116933: LD_VAR 0 1
116937: ARRAY
116938: NOT
116939: OR
116940: IFFALSE 115918
// MC_Reset ( base , 18 ) ;
116942: LD_VAR 0 1
116946: PPUSH
116947: LD_INT 18
116949: PPUSH
116950: CALL 22145 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116954: LD_ADDR_VAR 0 2
116958: PUSH
116959: LD_VAR 0 2
116963: PUSH
116964: LD_VAR 0 2
116968: PPUSH
116969: LD_INT 2
116971: PUSH
116972: LD_INT 25
116974: PUSH
116975: LD_INT 1
116977: PUSH
116978: EMPTY
116979: LIST
116980: LIST
116981: PUSH
116982: LD_INT 25
116984: PUSH
116985: LD_INT 5
116987: PUSH
116988: EMPTY
116989: LIST
116990: LIST
116991: PUSH
116992: LD_INT 25
116994: PUSH
116995: LD_INT 8
116997: PUSH
116998: EMPTY
116999: LIST
117000: LIST
117001: PUSH
117002: LD_INT 25
117004: PUSH
117005: LD_INT 9
117007: PUSH
117008: EMPTY
117009: LIST
117010: LIST
117011: PUSH
117012: EMPTY
117013: LIST
117014: LIST
117015: LIST
117016: LIST
117017: LIST
117018: PPUSH
117019: CALL_OW 72
117023: DIFF
117024: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
117025: LD_VAR 0 21
117029: NOT
117030: PUSH
117031: LD_VAR 0 2
117035: PPUSH
117036: LD_INT 21
117038: PUSH
117039: LD_INT 2
117041: PUSH
117042: EMPTY
117043: LIST
117044: LIST
117045: PPUSH
117046: CALL_OW 72
117050: AND
117051: IFFALSE 117389
// begin tmp := FilterByTag ( defenders , 19 ) ;
117053: LD_ADDR_VAR 0 11
117057: PUSH
117058: LD_VAR 0 2
117062: PPUSH
117063: LD_INT 19
117065: PPUSH
117066: CALL 83697 0 2
117070: ST_TO_ADDR
// if tmp then
117071: LD_VAR 0 11
117075: IFFALSE 117145
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
117077: LD_ADDR_VAR 0 11
117081: PUSH
117082: LD_VAR 0 11
117086: PPUSH
117087: LD_INT 25
117089: PUSH
117090: LD_INT 3
117092: PUSH
117093: EMPTY
117094: LIST
117095: LIST
117096: PPUSH
117097: CALL_OW 72
117101: ST_TO_ADDR
// if tmp then
117102: LD_VAR 0 11
117106: IFFALSE 117145
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
117108: LD_ADDR_EXP 62
117112: PUSH
117113: LD_EXP 62
117117: PPUSH
117118: LD_VAR 0 1
117122: PPUSH
117123: LD_EXP 62
117127: PUSH
117128: LD_VAR 0 1
117132: ARRAY
117133: PUSH
117134: LD_VAR 0 11
117138: UNION
117139: PPUSH
117140: CALL_OW 1
117144: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
117145: LD_VAR 0 1
117149: PPUSH
117150: LD_INT 19
117152: PPUSH
117153: CALL 22145 0 2
// repeat wait ( 0 0$1 ) ;
117157: LD_INT 35
117159: PPUSH
117160: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117164: LD_EXP 50
117168: PUSH
117169: LD_VAR 0 1
117173: ARRAY
117174: NOT
117175: PUSH
117176: LD_EXP 50
117180: PUSH
117181: LD_VAR 0 1
117185: ARRAY
117186: PUSH
117187: EMPTY
117188: EQUAL
117189: OR
117190: IFFALSE 117227
// begin for i in defenders do
117192: LD_ADDR_VAR 0 4
117196: PUSH
117197: LD_VAR 0 2
117201: PUSH
117202: FOR_IN
117203: IFFALSE 117216
// ComStop ( i ) ;
117205: LD_VAR 0 4
117209: PPUSH
117210: CALL_OW 141
117214: GO 117202
117216: POP
117217: POP
// defenders := [ ] ;
117218: LD_ADDR_VAR 0 2
117222: PUSH
117223: EMPTY
117224: ST_TO_ADDR
// exit ;
117225: GO 117453
// end ; for i in defenders do
117227: LD_ADDR_VAR 0 4
117231: PUSH
117232: LD_VAR 0 2
117236: PUSH
117237: FOR_IN
117238: IFFALSE 117327
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117240: LD_VAR 0 4
117244: PPUSH
117245: LD_EXP 74
117249: PUSH
117250: LD_VAR 0 1
117254: ARRAY
117255: PPUSH
117256: CALL_OW 308
117260: NOT
117261: IFFALSE 117285
// ComMoveToArea ( i , mc_parking [ base ] ) else
117263: LD_VAR 0 4
117267: PPUSH
117268: LD_EXP 74
117272: PUSH
117273: LD_VAR 0 1
117277: ARRAY
117278: PPUSH
117279: CALL_OW 113
117283: GO 117325
// if GetControl ( i ) = control_manual then
117285: LD_VAR 0 4
117289: PPUSH
117290: CALL_OW 263
117294: PUSH
117295: LD_INT 1
117297: EQUAL
117298: IFFALSE 117325
// if IsDrivenBy ( i ) then
117300: LD_VAR 0 4
117304: PPUSH
117305: CALL_OW 311
117309: IFFALSE 117325
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117311: LD_VAR 0 4
117315: PPUSH
117316: CALL_OW 311
117320: PPUSH
117321: CALL_OW 121
// end ;
117325: GO 117237
117327: POP
117328: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117329: LD_VAR 0 2
117333: PPUSH
117334: LD_INT 95
117336: PUSH
117337: LD_EXP 74
117341: PUSH
117342: LD_VAR 0 1
117346: ARRAY
117347: PUSH
117348: EMPTY
117349: LIST
117350: LIST
117351: PPUSH
117352: CALL_OW 72
117356: PUSH
117357: LD_VAR 0 2
117361: EQUAL
117362: PUSH
117363: LD_EXP 73
117367: PUSH
117368: LD_VAR 0 1
117372: ARRAY
117373: OR
117374: PUSH
117375: LD_EXP 50
117379: PUSH
117380: LD_VAR 0 1
117384: ARRAY
117385: NOT
117386: OR
117387: IFFALSE 117157
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117389: LD_ADDR_EXP 72
117393: PUSH
117394: LD_EXP 72
117398: PPUSH
117399: LD_VAR 0 1
117403: PPUSH
117404: LD_VAR 0 2
117408: PPUSH
117409: LD_INT 21
117411: PUSH
117412: LD_INT 2
117414: PUSH
117415: EMPTY
117416: LIST
117417: LIST
117418: PPUSH
117419: CALL_OW 72
117423: PPUSH
117424: CALL_OW 1
117428: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
117429: LD_VAR 0 1
117433: PPUSH
117434: LD_INT 19
117436: PPUSH
117437: CALL 22145 0 2
// MC_Reset ( base , 20 ) ;
117441: LD_VAR 0 1
117445: PPUSH
117446: LD_INT 20
117448: PPUSH
117449: CALL 22145 0 2
// end ; end_of_file
117453: LD_VAR 0 3
117457: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
117458: LD_VAR 0 1
117462: PUSH
117463: LD_INT 200
117465: DOUBLE
117466: GREATEREQUAL
117467: IFFALSE 117475
117469: LD_INT 299
117471: DOUBLE
117472: LESSEQUAL
117473: IFTRUE 117477
117475: GO 117509
117477: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
117478: LD_VAR 0 1
117482: PPUSH
117483: LD_VAR 0 2
117487: PPUSH
117488: LD_VAR 0 3
117492: PPUSH
117493: LD_VAR 0 4
117497: PPUSH
117498: LD_VAR 0 5
117502: PPUSH
117503: CALL 106244 0 5
117507: GO 117586
117509: LD_INT 300
117511: DOUBLE
117512: GREATEREQUAL
117513: IFFALSE 117521
117515: LD_INT 399
117517: DOUBLE
117518: LESSEQUAL
117519: IFTRUE 117523
117521: GO 117585
117523: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
117524: LD_VAR 0 1
117528: PPUSH
117529: LD_VAR 0 2
117533: PPUSH
117534: LD_VAR 0 3
117538: PPUSH
117539: LD_VAR 0 4
117543: PPUSH
117544: LD_VAR 0 5
117548: PPUSH
117549: LD_VAR 0 6
117553: PPUSH
117554: LD_VAR 0 7
117558: PPUSH
117559: LD_VAR 0 8
117563: PPUSH
117564: LD_VAR 0 9
117568: PPUSH
117569: LD_VAR 0 10
117573: PPUSH
117574: LD_VAR 0 11
117578: PPUSH
117579: CALL 102577 0 11
117583: GO 117586
117585: POP
// end ;
117586: PPOPN 11
117588: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
117589: LD_VAR 0 1
117593: PPUSH
117594: LD_VAR 0 2
117598: PPUSH
117599: LD_VAR 0 3
117603: PPUSH
117604: LD_VAR 0 4
117608: PPUSH
117609: LD_VAR 0 5
117613: PPUSH
117614: CALL 105980 0 5
// end ; end_of_file
117618: PPOPN 5
117620: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
117621: LD_VAR 0 1
117625: PPUSH
117626: LD_VAR 0 2
117630: PPUSH
117631: LD_VAR 0 3
117635: PPUSH
117636: LD_VAR 0 4
117640: PPUSH
117641: LD_VAR 0 5
117645: PPUSH
117646: LD_VAR 0 6
117650: PPUSH
117651: CALL 90197 0 6
// end ;
117655: PPOPN 6
117657: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
117658: LD_INT 0
117660: PPUSH
// begin if not units then
117661: LD_VAR 0 1
117665: NOT
117666: IFFALSE 117670
// exit ;
117668: GO 117670
// end ;
117670: PPOPN 7
117672: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
117673: CALL 90091 0 0
// end ;
117677: PPOPN 1
117679: END
