// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 18411 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 83498 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2624 0 0
// MC_Start ( ) ;
  85: CALL 20591 0 0
// Action ;
  89: CALL 8768 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 42308 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 42308 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 42308 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42753 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42645 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42645 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 49119 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 49119 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 49119 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 49119 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 49119 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 49119 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 49119 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 49119 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 49119 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 49119 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 49119 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 49119 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 49119 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 49119 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 49119 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_other_survivors ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_other_survivors
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1540: LD_ADDR_VAR 0 5
1544: PUSH
1545: LD_VAR 0 5
1549: PUSH
1550: LD_STRING 10c_lock
1552: PPUSH
1553: CALL_OW 31
1557: UNION
1558: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1559: LD_STRING 10_lock
1561: PPUSH
1562: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1566: LD_STRING 10c_lock
1568: PPUSH
1569: CALL_OW 40
// for i in tmp do
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 5
1582: PUSH
1583: FOR_IN
1584: IFFALSE 1622
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1586: LD_VAR 0 2
1590: PPUSH
1591: CALL_OW 257
1595: PUSH
1596: LD_INT 8
1598: PUSH
1599: LD_INT 2
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: IN
1606: IFFALSE 1620
// SetClass ( i , class_soldier ) ;
1608: LD_VAR 0 2
1612: PPUSH
1613: LD_INT 1
1615: PPUSH
1616: CALL_OW 336
1620: GO 1583
1622: POP
1623: POP
// if tmp < 12 then
1624: LD_VAR 0 5
1628: PUSH
1629: LD_INT 12
1631: LESS
1632: IFFALSE 1726
// begin k := 16 - tmp ;
1634: LD_ADDR_VAR 0 3
1638: PUSH
1639: LD_INT 16
1641: PUSH
1642: LD_VAR 0 5
1646: MINUS
1647: ST_TO_ADDR
// for i = 1 to k do
1648: LD_ADDR_VAR 0 2
1652: PUSH
1653: DOUBLE
1654: LD_INT 1
1656: DEC
1657: ST_TO_ADDR
1658: LD_VAR 0 3
1662: PUSH
1663: FOR_TO
1664: IFFALSE 1724
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1666: LD_INT 0
1668: PPUSH
1669: LD_INT 1
1671: PUSH
1672: LD_INT 1
1674: PUSH
1675: LD_INT 3
1677: PUSH
1678: LD_INT 4
1680: PUSH
1681: EMPTY
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 1
1689: PPUSH
1690: LD_INT 4
1692: PPUSH
1693: CALL_OW 12
1697: ARRAY
1698: PPUSH
1699: LD_INT 6
1701: PPUSH
1702: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1706: LD_ADDR_VAR 0 5
1710: PUSH
1711: LD_VAR 0 5
1715: PUSH
1716: CALL_OW 44
1720: ADD
1721: ST_TO_ADDR
// end ;
1722: GO 1663
1724: POP
1725: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1726: LD_ADDR_EXP 19
1730: PUSH
1731: LD_STRING 1
1733: PPUSH
1734: LD_INT 12
1736: PPUSH
1737: LD_INT 12
1739: PPUSH
1740: LD_INT -5
1742: PUSH
1743: LD_EXP 21
1747: PUSH
1748: LD_INT -2
1750: PUSH
1751: LD_INT -3
1753: PUSH
1754: LD_INT -5
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: LIST
1761: LIST
1762: LIST
1763: PUSH
1764: LD_VAR 0 5
1768: ADD
1769: PUSH
1770: LD_INT -6
1772: PUSH
1773: LD_INT -4
1775: PUSH
1776: LD_EXP 30
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: ADD
1786: PPUSH
1787: LD_INT 1
1789: PUSH
1790: LD_INT 4
1792: PUSH
1793: EMPTY
1794: LIST
1795: LIST
1796: PUSH
1797: LD_INT 3
1799: PUSH
1800: LD_INT 0
1802: PUSH
1803: LD_INT 5
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: LIST
1810: PUSH
1811: LD_INT 4
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: LD_INT 3
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: PUSH
1825: LD_INT 5
1827: PUSH
1828: LD_INT 0
1830: PUSH
1831: LD_INT 2
1833: PUSH
1834: EMPTY
1835: LIST
1836: LIST
1837: LIST
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: PPUSH
1845: CALL_OW 42
1849: ST_TO_ADDR
// others := tmp diff selected ;
1850: LD_ADDR_VAR 0 8
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 19
1864: DIFF
1865: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1866: LD_ADDR_VAR 0 8
1870: PUSH
1871: LD_VAR 0 8
1875: PUSH
1876: LD_EXP 22
1880: PUSH
1881: LD_EXP 23
1885: PUSH
1886: LD_EXP 24
1890: PUSH
1891: LD_EXP 25
1895: PUSH
1896: LD_EXP 26
1900: PUSH
1901: LD_EXP 27
1905: PUSH
1906: LD_EXP 28
1910: PUSH
1911: LD_EXP 29
1915: PUSH
1916: LD_EXP 31
1920: PUSH
1921: LD_EXP 32
1925: PUSH
1926: LD_EXP 33
1930: PUSH
1931: LD_EXP 34
1935: PUSH
1936: EMPTY
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: LIST
1947: LIST
1948: LIST
1949: DIFF
1950: ST_TO_ADDR
// if others then
1951: LD_VAR 0 8
1955: IFFALSE 1969
// SaveCharacters ( others , 11_others ) ;
1957: LD_VAR 0 8
1961: PPUSH
1962: LD_STRING 11_others
1964: PPUSH
1965: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_siberite , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_manual , us_rocket_launcher ] ] ;
1969: LD_ADDR_VAR 0 6
1973: PUSH
1974: LD_INT 3
1976: PUSH
1977: LD_INT 1
1979: PUSH
1980: LD_INT 1
1982: PUSH
1983: LD_INT 4
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PUSH
1992: LD_INT 2
1994: PUSH
1995: LD_INT 3
1997: PUSH
1998: LD_INT 1
2000: PUSH
2001: LD_INT 5
2003: PUSH
2004: EMPTY
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 4
2012: PUSH
2013: LD_INT 1
2015: PUSH
2016: LD_INT 1
2018: PUSH
2019: LD_INT 5
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PUSH
2028: LD_INT 2
2030: PUSH
2031: LD_INT 1
2033: PUSH
2034: LD_INT 1
2036: PUSH
2037: LD_INT 7
2039: PUSH
2040: EMPTY
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: PUSH
2046: LD_INT 3
2048: PUSH
2049: LD_INT 3
2051: PUSH
2052: LD_INT 1
2054: PUSH
2055: LD_INT 7
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: LIST
2062: LIST
2063: PUSH
2064: EMPTY
2065: LIST
2066: LIST
2067: LIST
2068: LIST
2069: LIST
2070: ST_TO_ADDR
// for i in JMM ^ selected do
2071: LD_ADDR_VAR 0 2
2075: PUSH
2076: LD_EXP 21
2080: PUSH
2081: LD_EXP 19
2085: ADD
2086: PUSH
2087: FOR_IN
2088: IFFALSE 2278
// begin if GetClass ( i ) = 3 then
2090: LD_VAR 0 2
2094: PPUSH
2095: CALL_OW 257
2099: PUSH
2100: LD_INT 3
2102: EQUAL
2103: IFFALSE 2261
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2105: LD_ADDR_OWVAR 37
2109: PUSH
2110: LD_VAR 0 6
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: PUSH
2119: LD_INT 1
2121: ARRAY
2122: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2123: LD_ADDR_OWVAR 39
2127: PUSH
2128: LD_VAR 0 6
2132: PUSH
2133: LD_INT 1
2135: ARRAY
2136: PUSH
2137: LD_INT 2
2139: ARRAY
2140: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2141: LD_ADDR_OWVAR 38
2145: PUSH
2146: LD_VAR 0 6
2150: PUSH
2151: LD_INT 1
2153: ARRAY
2154: PUSH
2155: LD_INT 3
2157: ARRAY
2158: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2159: LD_ADDR_OWVAR 40
2163: PUSH
2164: LD_VAR 0 6
2168: PUSH
2169: LD_INT 1
2171: ARRAY
2172: PUSH
2173: LD_INT 4
2175: ARRAY
2176: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2177: LD_ADDR_VAR 0 6
2181: PUSH
2182: LD_VAR 0 6
2186: PPUSH
2187: LD_INT 1
2189: PPUSH
2190: CALL_OW 3
2194: ST_TO_ADDR
// veh := CreateVehicle ;
2195: LD_ADDR_VAR 0 7
2199: PUSH
2200: CALL_OW 45
2204: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2205: LD_VAR 0 7
2209: PPUSH
2210: LD_INT 8
2212: PPUSH
2213: LD_INT 0
2215: PPUSH
2216: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2220: LD_VAR 0 2
2224: PPUSH
2225: LD_VAR 0 7
2229: PPUSH
2230: CALL_OW 52
// if i = JMM then
2234: LD_VAR 0 2
2238: PUSH
2239: LD_EXP 21
2243: EQUAL
2244: IFFALSE 2259
// SetMark ( veh , - 1 ) ;
2246: LD_VAR 0 7
2250: PPUSH
2251: LD_INT 1
2253: NEG
2254: PPUSH
2255: CALL_OW 242
// end else
2259: GO 2276
// PlaceUnitArea ( i , am_hum_start , false ) ;
2261: LD_VAR 0 2
2265: PPUSH
2266: LD_INT 9
2268: PPUSH
2269: LD_INT 0
2271: PPUSH
2272: CALL_OW 49
// end ;
2276: GO 2087
2278: POP
2279: POP
// vc_chassis := us_medium_tracked ;
2280: LD_ADDR_OWVAR 37
2284: PUSH
2285: LD_INT 3
2287: ST_TO_ADDR
// vc_engine := engine_solar ;
2288: LD_ADDR_OWVAR 39
2292: PUSH
2293: LD_INT 2
2295: ST_TO_ADDR
// vc_control := control_computer ;
2296: LD_ADDR_OWVAR 38
2300: PUSH
2301: LD_INT 3
2303: ST_TO_ADDR
// vc_weapon := us_radar ;
2304: LD_ADDR_OWVAR 40
2308: PUSH
2309: LD_INT 11
2311: ST_TO_ADDR
// veh := CreateVehicle ;
2312: LD_ADDR_VAR 0 7
2316: PUSH
2317: CALL_OW 45
2321: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2322: LD_VAR 0 7
2326: PPUSH
2327: LD_INT 87
2329: PPUSH
2330: LD_INT 142
2332: PPUSH
2333: LD_INT 0
2335: PPUSH
2336: CALL_OW 48
// end ;
2340: LD_VAR 0 1
2344: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2345: LD_INT 0
2347: PPUSH
2348: PPUSH
2349: PPUSH
2350: PPUSH
// uc_side := 1 ;
2351: LD_ADDR_OWVAR 20
2355: PUSH
2356: LD_INT 1
2358: ST_TO_ADDR
// uc_nation := 1 ;
2359: LD_ADDR_OWVAR 21
2363: PUSH
2364: LD_INT 1
2366: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 3
2374: PUSH
2375: LD_INT 1
2377: PUSH
2378: LD_INT 3
2380: PUSH
2381: LD_INT 5
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: LIST
2388: LIST
2389: PUSH
2390: LD_INT 3
2392: PUSH
2393: LD_INT 1
2395: PUSH
2396: LD_INT 3
2398: PUSH
2399: LD_INT 7
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: LIST
2406: LIST
2407: PUSH
2408: LD_INT 3
2410: PUSH
2411: LD_INT 1
2413: PUSH
2414: LD_INT 3
2416: PUSH
2417: LD_INT 7
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: LIST
2424: LIST
2425: PUSH
2426: LD_INT 3
2428: PUSH
2429: LD_INT 1
2431: PUSH
2432: LD_INT 3
2434: PUSH
2435: LD_INT 11
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: LIST
2442: LIST
2443: PUSH
2444: LD_INT 4
2446: PUSH
2447: LD_INT 1
2449: PUSH
2450: LD_INT 3
2452: PUSH
2453: LD_INT 6
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: PUSH
2462: LD_INT 4
2464: PUSH
2465: LD_INT 1
2467: PUSH
2468: LD_INT 3
2470: PUSH
2471: LD_INT 5
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: LIST
2478: LIST
2479: PUSH
2480: EMPTY
2481: LIST
2482: LIST
2483: LIST
2484: LIST
2485: LIST
2486: LIST
2487: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2488: LD_ADDR_VAR 0 2
2492: PUSH
2493: DOUBLE
2494: LD_INT 1
2496: DEC
2497: ST_TO_ADDR
2498: LD_INT 7
2500: PUSH
2501: LD_OWVAR 67
2505: MINUS
2506: PUSH
2507: FOR_TO
2508: IFFALSE 2617
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2510: LD_ADDR_OWVAR 37
2514: PUSH
2515: LD_VAR 0 3
2519: PUSH
2520: LD_VAR 0 2
2524: ARRAY
2525: PUSH
2526: LD_INT 1
2528: ARRAY
2529: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2530: LD_ADDR_OWVAR 39
2534: PUSH
2535: LD_VAR 0 3
2539: PUSH
2540: LD_VAR 0 2
2544: ARRAY
2545: PUSH
2546: LD_INT 2
2548: ARRAY
2549: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2550: LD_ADDR_OWVAR 38
2554: PUSH
2555: LD_VAR 0 3
2559: PUSH
2560: LD_VAR 0 2
2564: ARRAY
2565: PUSH
2566: LD_INT 3
2568: ARRAY
2569: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2570: LD_ADDR_OWVAR 40
2574: PUSH
2575: LD_VAR 0 3
2579: PUSH
2580: LD_VAR 0 2
2584: ARRAY
2585: PUSH
2586: LD_INT 4
2588: ARRAY
2589: ST_TO_ADDR
// veh := CreateVehicle ;
2590: LD_ADDR_VAR 0 4
2594: PUSH
2595: CALL_OW 45
2599: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2600: LD_VAR 0 4
2604: PPUSH
2605: LD_INT 8
2607: PPUSH
2608: LD_INT 0
2610: PPUSH
2611: CALL_OW 49
// end ;
2615: GO 2507
2617: POP
2618: POP
// end ; end_of_file
2619: LD_VAR 0 1
2623: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2624: LD_INT 0
2626: PPUSH
2627: PPUSH
2628: PPUSH
2629: PPUSH
2630: PPUSH
2631: PPUSH
// if Difficulty = 1 then
2632: LD_OWVAR 67
2636: PUSH
2637: LD_INT 1
2639: EQUAL
2640: IFFALSE 2737
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2642: LD_ADDR_VAR 0 6
2646: PUSH
2647: LD_INT 129
2649: PUSH
2650: LD_INT 45
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 143
2659: PUSH
2660: LD_INT 58
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PUSH
2667: LD_INT 184
2669: PUSH
2670: LD_INT 113
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PUSH
2677: LD_INT 163
2679: PUSH
2680: LD_INT 107
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: PUSH
2687: EMPTY
2688: LIST
2689: LIST
2690: LIST
2691: LIST
2692: ST_TO_ADDR
// for i in tmp do
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 6
2702: PUSH
2703: FOR_IN
2704: IFFALSE 2735
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2706: LD_VAR 0 2
2710: PUSH
2711: LD_INT 1
2713: ARRAY
2714: PPUSH
2715: LD_VAR 0 2
2719: PUSH
2720: LD_INT 2
2722: ARRAY
2723: PPUSH
2724: CALL_OW 428
2728: PPUSH
2729: CALL_OW 64
2733: GO 2703
2735: POP
2736: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2737: LD_ADDR_VAR 0 2
2741: PUSH
2742: LD_INT 21
2744: PUSH
2745: LD_INT 3
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: PPUSH
2752: CALL_OW 69
2756: PUSH
2757: FOR_IN
2758: IFFALSE 2795
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2760: LD_VAR 0 2
2764: PPUSH
2765: LD_INT 5
2767: PUSH
2768: LD_INT 6
2770: PUSH
2771: LD_INT 7
2773: PUSH
2774: LD_INT 8
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: PUSH
2783: LD_OWVAR 67
2787: ARRAY
2788: PPUSH
2789: CALL_OW 241
2793: GO 2757
2795: POP
2796: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2797: LD_ADDR_VAR 0 5
2801: PUSH
2802: LD_INT 5
2804: PUSH
2805: LD_INT 6
2807: PUSH
2808: LD_INT 7
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: LIST
2819: PUSH
2820: LD_OWVAR 67
2824: ARRAY
2825: ST_TO_ADDR
// uc_side := 2 ;
2826: LD_ADDR_OWVAR 20
2830: PUSH
2831: LD_INT 2
2833: ST_TO_ADDR
// uc_nation := 2 ;
2834: LD_ADDR_OWVAR 21
2838: PUSH
2839: LD_INT 2
2841: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2842: LD_ADDR_OWVAR 37
2846: PUSH
2847: LD_INT 14
2849: ST_TO_ADDR
// vc_engine := engine_siberite ;
2850: LD_ADDR_OWVAR 39
2854: PUSH
2855: LD_INT 3
2857: ST_TO_ADDR
// vc_control := control_manual ;
2858: LD_ADDR_OWVAR 38
2862: PUSH
2863: LD_INT 1
2865: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2866: LD_ADDR_OWVAR 40
2870: PUSH
2871: LD_INT 31
2873: ST_TO_ADDR
// for i = 1 to 3 do
2874: LD_ADDR_VAR 0 2
2878: PUSH
2879: DOUBLE
2880: LD_INT 1
2882: DEC
2883: ST_TO_ADDR
2884: LD_INT 3
2886: PUSH
2887: FOR_TO
2888: IFFALSE 2972
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2890: LD_INT 0
2892: PPUSH
2893: LD_INT 3
2895: PPUSH
2896: LD_VAR 0 5
2900: PPUSH
2901: CALL_OW 380
// un := CreateVehicle ;
2905: LD_ADDR_VAR 0 4
2909: PUSH
2910: CALL_OW 45
2914: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2915: LD_VAR 0 4
2919: PPUSH
2920: LD_INT 0
2922: PPUSH
2923: LD_INT 5
2925: PPUSH
2926: CALL_OW 12
2930: PPUSH
2931: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2935: LD_VAR 0 4
2939: PPUSH
2940: LD_INT 156
2942: PPUSH
2943: LD_INT 15
2945: PPUSH
2946: LD_INT 6
2948: PPUSH
2949: LD_INT 0
2951: PPUSH
2952: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2956: CALL_OW 44
2960: PPUSH
2961: LD_VAR 0 4
2965: PPUSH
2966: CALL_OW 52
// end ;
2970: GO 2887
2972: POP
2973: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2974: LD_ADDR_EXP 37
2978: PUSH
2979: LD_INT 94
2981: PPUSH
2982: LD_INT 28
2984: PPUSH
2985: LD_STRING dammam
2987: PPUSH
2988: LD_VAR 0 5
2992: PPUSH
2993: LD_INT 10000
2995: PUSH
2996: LD_INT 1000
2998: PUSH
2999: LD_INT 300
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: LIST
3006: PPUSH
3007: LD_INT 12
3009: PUSH
3010: LD_INT 2
3012: PUSH
3013: LD_INT 3
3015: PUSH
3016: LD_INT 4
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PUSH
3028: LD_OWVAR 67
3032: ARRAY
3033: PUSH
3034: LD_INT 1
3036: NEG
3037: PUSH
3038: LD_INT 4
3040: PUSH
3041: EMPTY
3042: LIST
3043: LIST
3044: LIST
3045: LIST
3046: PPUSH
3047: CALL 57780 0 6
3051: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3052: LD_ADDR_EXP 37
3056: PUSH
3057: LD_EXP 37
3061: PUSH
3062: LD_INT 122
3064: PPUSH
3065: LD_INT 25
3067: PPUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_VAR 0 5
3075: PPUSH
3076: LD_INT 500
3078: PUSH
3079: LD_INT 60
3081: PUSH
3082: LD_INT 0
3084: PUSH
3085: EMPTY
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: LD_INT 8
3092: PUSH
3093: LD_INT 2
3095: PUSH
3096: LD_INT 3
3098: PUSH
3099: LD_INT 4
3101: PUSH
3102: LD_INT 5
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: LIST
3109: LIST
3110: PUSH
3111: LD_OWVAR 67
3115: ARRAY
3116: PUSH
3117: LD_INT 2
3119: PUSH
3120: LD_INT 0
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: LIST
3127: LIST
3128: PPUSH
3129: CALL 57780 0 6
3133: UNION
3134: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3135: LD_ADDR_EXP 35
3139: PUSH
3140: LD_INT 45
3142: PPUSH
3143: LD_INT 24
3145: PPUSH
3146: LD_STRING jeddah
3148: PPUSH
3149: LD_VAR 0 5
3153: PPUSH
3154: LD_INT 700
3156: PUSH
3157: LD_INT 300
3159: PUSH
3160: LD_INT 10
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: LIST
3167: PPUSH
3168: LD_INT 9
3170: PUSH
3171: LD_INT 4
3173: PUSH
3174: LD_INT 3
3176: PUSH
3177: LD_INT 2
3179: PUSH
3180: EMPTY
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: PPUSH
3186: CALL 57780 0 6
3190: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3191: LD_ADDR_EXP 36
3195: PUSH
3196: LD_INT 7
3198: PPUSH
3199: LD_INT 27
3201: PPUSH
3202: LD_STRING riyadh
3204: PPUSH
3205: LD_VAR 0 5
3209: PPUSH
3210: LD_INT 500
3212: PUSH
3213: LD_INT 60
3215: PUSH
3216: LD_INT 0
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: PPUSH
3224: LD_INT 4
3226: PUSH
3227: LD_INT 2
3229: PUSH
3230: LD_INT 3
3232: PUSH
3233: LD_INT 1
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL 57780 0 6
3246: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3247: LD_ADDR_EXP 39
3251: PUSH
3252: LD_INT 204
3254: PPUSH
3255: LD_INT 26
3257: PPUSH
3258: LD_STRING 
3260: PPUSH
3261: LD_VAR 0 5
3265: PPUSH
3266: LD_INT 500
3268: PUSH
3269: LD_INT 50
3271: PUSH
3272: LD_INT 0
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: LIST
3279: PPUSH
3280: LD_INT 9
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 1
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: PPUSH
3298: CALL 57780 0 6
3302: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3303: LD_ADDR_EXP 50
3307: PUSH
3308: LD_EXP 37
3312: PUSH
3313: LD_EXP 35
3317: PUSH
3318: LD_EXP 39
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3328: LD_ADDR_VAR 0 2
3332: PUSH
3333: LD_INT 22
3335: PUSH
3336: LD_INT 2
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 30
3345: PUSH
3346: LD_INT 31
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: PUSH
3353: LD_INT 58
3355: PUSH
3356: EMPTY
3357: LIST
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: PPUSH
3364: CALL_OW 69
3368: PUSH
3369: FOR_IN
3370: IFFALSE 3495
// begin if GetBase ( i ) then
3372: LD_VAR 0 2
3376: PPUSH
3377: CALL_OW 274
3381: IFFALSE 3385
// continue ;
3383: GO 3369
// d := GetDir ( i ) ;
3385: LD_ADDR_VAR 0 3
3389: PUSH
3390: LD_VAR 0 2
3394: PPUSH
3395: CALL_OW 254
3399: ST_TO_ADDR
// if d < 3 then
3400: LD_VAR 0 3
3404: PUSH
3405: LD_INT 3
3407: LESS
3408: IFFALSE 3426
// d := d + 3 else
3410: LD_ADDR_VAR 0 3
3414: PUSH
3415: LD_VAR 0 3
3419: PUSH
3420: LD_INT 3
3422: PLUS
3423: ST_TO_ADDR
3424: GO 3440
// d := d - 3 ;
3426: LD_ADDR_VAR 0 3
3430: PUSH
3431: LD_VAR 0 3
3435: PUSH
3436: LD_INT 3
3438: MINUS
3439: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3440: LD_INT 0
3442: PPUSH
3443: LD_INT 8
3445: PPUSH
3446: LD_VAR 0 5
3450: PPUSH
3451: CALL_OW 380
// un := CreateHuman ;
3455: LD_ADDR_VAR 0 4
3459: PUSH
3460: CALL_OW 44
3464: ST_TO_ADDR
// SetDir ( un , d ) ;
3465: LD_VAR 0 4
3469: PPUSH
3470: LD_VAR 0 3
3474: PPUSH
3475: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3479: LD_VAR 0 4
3483: PPUSH
3484: LD_VAR 0 2
3488: PPUSH
3489: CALL_OW 52
// end ;
3493: GO 3369
3495: POP
3496: POP
// if Difficulty > 1 then
3497: LD_OWVAR 67
3501: PUSH
3502: LD_INT 1
3504: GREATER
3505: IFFALSE 3876
// begin ar_kamikadze := [ ] ;
3507: LD_ADDR_EXP 42
3511: PUSH
3512: EMPTY
3513: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3514: LD_INT 0
3516: PPUSH
3517: LD_INT 1
3519: PPUSH
3520: LD_VAR 0 5
3524: PPUSH
3525: CALL_OW 380
// un := CreateHuman ;
3529: LD_ADDR_VAR 0 4
3533: PUSH
3534: CALL_OW 44
3538: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3539: LD_VAR 0 4
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3551: LD_VAR 0 4
3555: PPUSH
3556: LD_INT 23
3558: PPUSH
3559: LD_INT 44
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 48
// ComCrawl ( un ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: CALL_OW 137
// un := CreateHuman ;
3578: LD_ADDR_VAR 0 4
3582: PUSH
3583: CALL_OW 44
3587: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3588: LD_VAR 0 4
3592: PPUSH
3593: LD_INT 3
3595: PPUSH
3596: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3600: LD_VAR 0 4
3604: PPUSH
3605: LD_INT 30
3607: PPUSH
3608: LD_INT 39
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 48
// ComCrawl ( un ) ;
3618: LD_VAR 0 4
3622: PPUSH
3623: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3627: LD_INT 0
3629: PPUSH
3630: LD_INT 17
3632: PPUSH
3633: LD_VAR 0 5
3637: PPUSH
3638: CALL_OW 380
// un := CreateHuman ;
3642: LD_ADDR_VAR 0 4
3646: PUSH
3647: CALL_OW 44
3651: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3652: LD_VAR 0 4
3656: PPUSH
3657: LD_INT 3
3659: PPUSH
3660: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3664: LD_VAR 0 4
3668: PPUSH
3669: LD_INT 45
3671: PPUSH
3672: LD_INT 86
3674: PPUSH
3675: LD_INT 0
3677: PPUSH
3678: CALL_OW 48
// ComHold ( un ) ;
3682: LD_VAR 0 4
3686: PPUSH
3687: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3691: LD_ADDR_EXP 42
3695: PUSH
3696: LD_EXP 42
3700: PPUSH
3701: LD_EXP 42
3705: PUSH
3706: LD_INT 1
3708: PLUS
3709: PPUSH
3710: LD_VAR 0 4
3714: PPUSH
3715: CALL_OW 1
3719: ST_TO_ADDR
// un := CreateHuman ;
3720: LD_ADDR_VAR 0 4
3724: PUSH
3725: CALL_OW 44
3729: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3730: LD_VAR 0 4
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3742: LD_VAR 0 4
3746: PPUSH
3747: LD_INT 60
3749: PPUSH
3750: LD_INT 85
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 48
// ComHold ( un ) ;
3760: LD_VAR 0 4
3764: PPUSH
3765: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3769: LD_ADDR_EXP 42
3773: PUSH
3774: LD_EXP 42
3778: PPUSH
3779: LD_EXP 42
3783: PUSH
3784: LD_INT 1
3786: PLUS
3787: PPUSH
3788: LD_VAR 0 4
3792: PPUSH
3793: CALL_OW 1
3797: ST_TO_ADDR
// un := CreateHuman ;
3798: LD_ADDR_VAR 0 4
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3808: LD_VAR 0 4
3812: PPUSH
3813: LD_INT 3
3815: PPUSH
3816: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3820: LD_VAR 0 4
3824: PPUSH
3825: LD_INT 222
3827: PPUSH
3828: LD_INT 166
3830: PPUSH
3831: LD_INT 0
3833: PPUSH
3834: CALL_OW 48
// ComHold ( un ) ;
3838: LD_VAR 0 4
3842: PPUSH
3843: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3847: LD_ADDR_EXP 42
3851: PUSH
3852: LD_EXP 42
3856: PPUSH
3857: LD_EXP 42
3861: PUSH
3862: LD_INT 1
3864: PLUS
3865: PPUSH
3866: LD_VAR 0 4
3870: PPUSH
3871: CALL_OW 1
3875: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3876: LD_ADDR_EXP 40
3880: PUSH
3881: EMPTY
3882: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3883: LD_INT 1
3885: PPUSH
3886: LD_INT 1
3888: PPUSH
3889: LD_VAR 0 5
3893: PPUSH
3894: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3898: LD_ADDR_OWVAR 26
3902: PUSH
3903: LD_STRING Pavel Grigorovic
3905: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3906: LD_ADDR_OWVAR 33
3910: PUSH
3911: LD_STRING SecondCharsGal
3913: ST_TO_ADDR
// hc_face_number := 4 ;
3914: LD_ADDR_OWVAR 34
3918: PUSH
3919: LD_INT 4
3921: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3922: LD_ADDR_EXP 40
3926: PUSH
3927: LD_EXP 40
3931: PPUSH
3932: LD_INT 1
3934: PPUSH
3935: CALL_OW 44
3939: PPUSH
3940: CALL_OW 1
3944: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3945: LD_INT 2
3947: PPUSH
3948: LD_INT 4
3950: PPUSH
3951: LD_INT 2
3953: PPUSH
3954: CALL_OW 380
// hc_name := Lucy Sebel ;
3958: LD_ADDR_OWVAR 26
3962: PUSH
3963: LD_STRING Lucy Sebel
3965: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3966: LD_ADDR_OWVAR 33
3970: PUSH
3971: LD_STRING SecondCharsGal
3973: ST_TO_ADDR
// hc_face_number := 15 ;
3974: LD_ADDR_OWVAR 34
3978: PUSH
3979: LD_INT 15
3981: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3982: LD_ADDR_EXP 40
3986: PUSH
3987: LD_EXP 40
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 44
3999: PPUSH
4000: CALL_OW 1
4004: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
4005: LD_INT 2
4007: PPUSH
4008: LD_INT 4
4010: PPUSH
4011: LD_INT 2
4013: PPUSH
4014: CALL_OW 380
// hc_gallery :=  ;
4018: LD_ADDR_OWVAR 33
4022: PUSH
4023: LD_STRING 
4025: ST_TO_ADDR
// hc_name :=  ;
4026: LD_ADDR_OWVAR 26
4030: PUSH
4031: LD_STRING 
4033: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4034: LD_ADDR_EXP 40
4038: PUSH
4039: LD_EXP 40
4043: PPUSH
4044: LD_INT 3
4046: PPUSH
4047: CALL_OW 44
4051: PPUSH
4052: CALL_OW 1
4056: ST_TO_ADDR
// hc_sex := sex_male ;
4057: LD_ADDR_OWVAR 27
4061: PUSH
4062: LD_INT 1
4064: ST_TO_ADDR
// hc_class = 11 ;
4065: LD_ADDR_OWVAR 28
4069: PUSH
4070: LD_INT 11
4072: ST_TO_ADDR
// hc_gallery = sandar ;
4073: LD_ADDR_OWVAR 33
4077: PUSH
4078: LD_STRING sandar
4080: ST_TO_ADDR
// hc_face_number = 33 ;
4081: LD_ADDR_OWVAR 34
4085: PUSH
4086: LD_INT 33
4088: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4089: LD_ADDR_OWVAR 26
4093: PUSH
4094: LD_STRING Thabit Muhair Saliba
4096: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4097: LD_ADDR_OWVAR 31
4101: PUSH
4102: LD_INT 0
4104: PUSH
4105: LD_INT 0
4107: PUSH
4108: LD_INT 0
4110: PUSH
4111: LD_INT 0
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: ST_TO_ADDR
// Saliba = CreateHuman ;
4120: LD_ADDR_EXP 44
4124: PUSH
4125: CALL_OW 44
4129: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4130: LD_EXP 44
4134: PPUSH
4135: LD_INT 7
4137: PPUSH
4138: CALL_OW 52
// if gensher_active then
4142: LD_EXP 18
4146: IFFALSE 4173
// begin Gensher = NewCharacter ( Dietrich ) ;
4148: LD_ADDR_EXP 45
4152: PUSH
4153: LD_STRING Dietrich
4155: PPUSH
4156: CALL_OW 25
4160: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4161: LD_EXP 45
4165: PPUSH
4166: LD_INT 94
4168: PPUSH
4169: CALL_OW 52
// end ; InitHc ;
4173: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4177: LD_ADDR_EXP 41
4181: PUSH
4182: EMPTY
4183: ST_TO_ADDR
// for i = 1 to 5 do
4184: LD_ADDR_VAR 0 2
4188: PUSH
4189: DOUBLE
4190: LD_INT 1
4192: DEC
4193: ST_TO_ADDR
4194: LD_INT 5
4196: PUSH
4197: FOR_TO
4198: IFFALSE 4370
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4200: LD_INT 13
4202: PUSH
4203: LD_INT 14
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 1
4212: PPUSH
4213: LD_INT 2
4215: PPUSH
4216: CALL_OW 12
4220: ARRAY
4221: PPUSH
4222: LD_INT 1
4224: PUSH
4225: LD_INT 2
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 1
4234: PPUSH
4235: LD_INT 2
4237: PPUSH
4238: CALL_OW 12
4242: ARRAY
4243: PPUSH
4244: LD_INT 1
4246: PPUSH
4247: LD_INT 25
4249: PUSH
4250: LD_INT 27
4252: PUSH
4253: LD_INT 26
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: PUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 3
4266: PPUSH
4267: CALL_OW 12
4271: ARRAY
4272: PPUSH
4273: LD_INT 60
4275: PPUSH
4276: LD_INT 100
4278: PPUSH
4279: CALL_OW 12
4283: PPUSH
4284: CALL 53959 0 5
// un := CreateVehicle ;
4288: LD_ADDR_VAR 0 4
4292: PUSH
4293: CALL_OW 45
4297: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4298: LD_ADDR_EXP 41
4302: PUSH
4303: LD_EXP 41
4307: PPUSH
4308: LD_EXP 41
4312: PUSH
4313: LD_INT 1
4315: PLUS
4316: PPUSH
4317: LD_VAR 0 4
4321: PPUSH
4322: CALL_OW 1
4326: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4327: LD_VAR 0 4
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: LD_INT 5
4337: PPUSH
4338: CALL_OW 12
4342: PPUSH
4343: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4347: LD_VAR 0 4
4351: PPUSH
4352: LD_INT 124
4354: PPUSH
4355: LD_INT 141
4357: PPUSH
4358: LD_INT 8
4360: PPUSH
4361: LD_INT 0
4363: PPUSH
4364: CALL_OW 50
// end ;
4368: GO 4197
4370: POP
4371: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4372: LD_ADDR_EXP 43
4376: PUSH
4377: EMPTY
4378: PUSH
4379: EMPTY
4380: PUSH
4381: EMPTY
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: LIST
4387: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4388: LD_ADDR_VAR 0 3
4392: PUSH
4393: DOUBLE
4394: LD_INT 1
4396: DEC
4397: ST_TO_ADDR
4398: LD_INT 3
4400: PUSH
4401: LD_INT 3
4403: PUSH
4404: LD_INT 4
4406: PUSH
4407: LD_INT 4
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: PUSH
4416: LD_OWVAR 67
4420: ARRAY
4421: PUSH
4422: FOR_TO
4423: IFFALSE 4637
// for i = 1 to 3 do
4425: LD_ADDR_VAR 0 2
4429: PUSH
4430: DOUBLE
4431: LD_INT 1
4433: DEC
4434: ST_TO_ADDR
4435: LD_INT 3
4437: PUSH
4438: FOR_TO
4439: IFFALSE 4633
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4441: LD_INT 14
4443: PPUSH
4444: LD_INT 3
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: LD_INT 1
4456: PPUSH
4457: LD_INT 2
4459: PPUSH
4460: CALL_OW 12
4464: ARRAY
4465: PPUSH
4466: LD_INT 1
4468: PUSH
4469: LD_INT 5
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: LD_INT 1
4478: PPUSH
4479: LD_INT 2
4481: PPUSH
4482: CALL_OW 12
4486: ARRAY
4487: PPUSH
4488: LD_INT 25
4490: PUSH
4491: LD_INT 27
4493: PUSH
4494: LD_INT 26
4496: PUSH
4497: LD_INT 28
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: PUSH
4506: LD_INT 1
4508: PPUSH
4509: LD_INT 4
4511: PPUSH
4512: CALL_OW 12
4516: ARRAY
4517: PPUSH
4518: LD_INT 100
4520: PPUSH
4521: CALL 53959 0 5
// un := CreateVehicle ;
4525: LD_ADDR_VAR 0 4
4529: PUSH
4530: CALL_OW 45
4534: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4535: LD_ADDR_EXP 43
4539: PUSH
4540: LD_EXP 43
4544: PPUSH
4545: LD_VAR 0 2
4549: PUSH
4550: LD_EXP 43
4554: PUSH
4555: LD_VAR 0 2
4559: ARRAY
4560: PUSH
4561: LD_INT 1
4563: PLUS
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PPUSH
4569: LD_VAR 0 4
4573: PPUSH
4574: CALL 54081 0 3
4578: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4579: LD_VAR 0 4
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: LD_INT 5
4589: PPUSH
4590: CALL_OW 12
4594: PPUSH
4595: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4599: LD_VAR 0 4
4603: PPUSH
4604: LD_INT 20
4606: PUSH
4607: LD_INT 21
4609: PUSH
4610: LD_INT 22
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: LIST
4617: PUSH
4618: LD_VAR 0 2
4622: ARRAY
4623: PPUSH
4624: LD_INT 0
4626: PPUSH
4627: CALL_OW 49
// end ;
4631: GO 4438
4633: POP
4634: POP
4635: GO 4422
4637: POP
4638: POP
// InitHc ;
4639: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4643: LD_INT 4
4645: PPUSH
4646: LD_INT 5
4648: PPUSH
4649: LD_INT 10
4651: PPUSH
4652: LD_INT 5
4654: PPUSH
4655: LD_INT 0
4657: PPUSH
4658: CALL_OW 58
// end ;
4662: LD_VAR 0 1
4666: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4667: LD_EXP 42
4671: IFFALSE 4745
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin enable ;
4679: ENABLE
// for i in ar_kamikadze do
4680: LD_ADDR_VAR 0 1
4684: PUSH
4685: LD_EXP 42
4689: PUSH
4690: FOR_IN
4691: IFFALSE 4743
// if See ( 1 , i ) then
4693: LD_INT 1
4695: PPUSH
4696: LD_VAR 0 1
4700: PPUSH
4701: CALL_OW 292
4705: IFFALSE 4741
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4707: LD_VAR 0 1
4711: PPUSH
4712: LD_INT 81
4714: PUSH
4715: LD_INT 2
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PPUSH
4722: CALL_OW 69
4726: PPUSH
4727: LD_VAR 0 1
4731: PPUSH
4732: CALL_OW 74
4736: PPUSH
4737: CALL_OW 115
4741: GO 4690
4743: POP
4744: POP
// end ;
4745: PPOPN 1
4747: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4748: LD_EXP 13
4752: IFFALSE 5069
4754: GO 4756
4756: DISABLE
4757: LD_INT 0
4759: PPUSH
4760: PPUSH
4761: PPUSH
4762: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4763: LD_INT 35
4765: PPUSH
4766: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4770: LD_INT 1
4772: PPUSH
4773: CALL 43041 0 1
4777: PUSH
4778: LD_INT 0
4780: EQUAL
4781: IFFALSE 4763
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 14
4788: PUSH
4789: LD_INT 3
4791: PUSH
4792: LD_INT 2
4794: PUSH
4795: LD_INT 32
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: PUSH
4804: EMPTY
4805: LIST
4806: PPUSH
4807: CALL 42645 0 2
// repeat wait ( 0 0$1 ) ;
4811: LD_INT 35
4813: PPUSH
4814: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4818: LD_EXP 69
4822: PUSH
4823: LD_INT 1
4825: ARRAY
4826: PPUSH
4827: LD_INT 33
4829: PUSH
4830: LD_INT 2
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: LD_INT 34
4839: PUSH
4840: LD_INT 32
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PPUSH
4851: CALL_OW 72
4855: IFFALSE 4811
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4857: LD_ADDR_VAR 0 2
4861: PUSH
4862: LD_EXP 69
4866: PUSH
4867: LD_INT 1
4869: ARRAY
4870: PPUSH
4871: LD_INT 33
4873: PUSH
4874: LD_INT 2
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: LD_INT 34
4883: PUSH
4884: LD_INT 32
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PPUSH
4895: CALL_OW 72
4899: PUSH
4900: LD_INT 1
4902: ARRAY
4903: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4904: LD_ADDR_VAR 0 4
4908: PUSH
4909: LD_INT 5
4911: PPUSH
4912: CALL_OW 469
4916: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4917: LD_INT 35
4919: PPUSH
4920: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4924: LD_ADDR_VAR 0 4
4928: PUSH
4929: LD_INT 5
4931: PPUSH
4932: CALL_OW 469
4936: ST_TO_ADDR
// tmp := 100 ;
4937: LD_ADDR_VAR 0 3
4941: PUSH
4942: LD_INT 100
4944: ST_TO_ADDR
// if pos then
4945: LD_VAR 0 4
4949: IFFALSE 4989
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4951: LD_ADDR_VAR 0 3
4955: PUSH
4956: LD_INT 2
4958: PPUSH
4959: LD_VAR 0 4
4963: PUSH
4964: LD_INT 1
4966: ARRAY
4967: PPUSH
4968: LD_VAR 0 4
4972: PUSH
4973: LD_INT 2
4975: ARRAY
4976: PPUSH
4977: LD_INT 20
4979: PPUSH
4980: CALL 55345 0 4
4984: PUSH
4985: LD_INT 4
4987: ARRAY
4988: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4989: LD_VAR 0 4
4993: PUSH
4994: LD_EXP 14
4998: NOT
4999: AND
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_INT 10
5008: LESS
5009: AND
5010: IFFALSE 4917
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5012: LD_VAR 0 2
5016: PPUSH
5017: LD_VAR 0 4
5021: PUSH
5022: LD_INT 1
5024: ARRAY
5025: PPUSH
5026: LD_VAR 0 4
5030: PUSH
5031: LD_INT 2
5033: ARRAY
5034: PPUSH
5035: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5039: LD_VAR 0 2
5043: PPUSH
5044: LD_INT 198
5046: PPUSH
5047: LD_INT 113
5049: PPUSH
5050: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5054: LD_VAR 0 2
5058: PPUSH
5059: LD_INT 124
5061: PPUSH
5062: LD_INT 7
5064: PPUSH
5065: CALL_OW 171
// end ;
5069: PPOPN 4
5071: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
5072: LD_EXP 6
5076: IFFALSE 7039
5078: GO 5080
5080: DISABLE
5081: LD_INT 0
5083: PPUSH
5084: PPUSH
5085: PPUSH
5086: PPUSH
5087: PPUSH
5088: PPUSH
5089: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5090: LD_ADDR_VAR 0 4
5094: PUSH
5095: LD_INT 5
5097: PUSH
5098: LD_INT 6
5100: PUSH
5101: LD_INT 7
5103: PUSH
5104: LD_INT 8
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: LIST
5111: LIST
5112: PUSH
5113: LD_OWVAR 67
5117: ARRAY
5118: ST_TO_ADDR
// coords := [ ] ;
5119: LD_ADDR_VAR 0 5
5123: PUSH
5124: EMPTY
5125: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5126: LD_ADDR_VAR 0 6
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 0
5136: PUSH
5137: LD_INT 0
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: LD_INT 1
5145: PUSH
5146: LD_INT 0
5148: PUSH
5149: LD_INT 0
5151: PUSH
5152: LD_INT 0
5154: PUSH
5155: LD_INT 1
5157: PUSH
5158: LD_INT 0
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5173: LD_INT 1
5175: PPUSH
5176: LD_INT 14
5178: PUSH
5179: LD_INT 1
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: LD_INT 28
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 14
5196: PUSH
5197: LD_INT 1
5199: PUSH
5200: LD_INT 2
5202: PUSH
5203: LD_INT 25
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 14
5214: PUSH
5215: LD_INT 1
5217: PUSH
5218: LD_INT 2
5220: PUSH
5221: LD_INT 28
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 14
5232: PUSH
5233: LD_INT 1
5235: PUSH
5236: LD_INT 2
5238: PUSH
5239: LD_INT 29
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL 42645 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5258: LD_INT 21000
5260: PUSH
5261: LD_INT 19950
5263: PUSH
5264: LD_INT 18900
5266: PUSH
5267: LD_INT 18200
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: LIST
5274: LIST
5275: PUSH
5276: LD_OWVAR 67
5280: ARRAY
5281: PPUSH
5282: CALL_OW 67
// InitHc ;
5286: CALL_OW 19
// InitUc ;
5290: CALL_OW 18
// uc_side := 2 ;
5294: LD_ADDR_OWVAR 20
5298: PUSH
5299: LD_INT 2
5301: ST_TO_ADDR
// uc_nation := 2 ;
5302: LD_ADDR_OWVAR 21
5306: PUSH
5307: LD_INT 2
5309: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5310: LD_ADDR_VAR 0 3
5314: PUSH
5315: EMPTY
5316: PUSH
5317: EMPTY
5318: PUSH
5319: EMPTY
5320: PUSH
5321: EMPTY
5322: PUSH
5323: EMPTY
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: LIST
5329: LIST
5330: LIST
5331: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5332: LD_ADDR_VAR 0 3
5336: PUSH
5337: LD_VAR 0 3
5341: PPUSH
5342: LD_INT 1
5344: PPUSH
5345: LD_EXP 69
5349: PUSH
5350: LD_INT 1
5352: ARRAY
5353: PUSH
5354: LD_INT 2
5356: PUSH
5357: LD_INT 34
5359: PUSH
5360: LD_INT 88
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PUSH
5367: LD_INT 34
5369: PUSH
5370: LD_INT 32
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: LIST
5381: PPUSH
5382: CALL_OW 69
5386: DIFF
5387: PPUSH
5388: CALL_OW 1
5392: ST_TO_ADDR
// for i = 1 to Difficulty do
5393: LD_ADDR_VAR 0 1
5397: PUSH
5398: DOUBLE
5399: LD_INT 1
5401: DEC
5402: ST_TO_ADDR
5403: LD_OWVAR 67
5407: PUSH
5408: FOR_TO
5409: IFFALSE 5547
// begin uc_side := 2 ;
5411: LD_ADDR_OWVAR 20
5415: PUSH
5416: LD_INT 2
5418: ST_TO_ADDR
// uc_nation := 2 ;
5419: LD_ADDR_OWVAR 21
5423: PUSH
5424: LD_INT 2
5426: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5427: LD_INT 13
5429: PPUSH
5430: LD_INT 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 29
5438: PPUSH
5439: LD_INT 100
5441: PPUSH
5442: CALL 53959 0 5
// un := CreateVehicle ;
5446: LD_ADDR_VAR 0 2
5450: PUSH
5451: CALL_OW 45
5455: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5456: LD_ADDR_VAR 0 3
5460: PUSH
5461: LD_VAR 0 3
5465: PPUSH
5466: LD_INT 1
5468: PUSH
5469: LD_VAR 0 3
5473: PUSH
5474: LD_INT 1
5476: ARRAY
5477: PUSH
5478: LD_INT 1
5480: PLUS
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PPUSH
5486: LD_VAR 0 2
5490: PPUSH
5491: CALL 54081 0 3
5495: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5496: LD_VAR 0 2
5500: PPUSH
5501: LD_INT 3
5503: PPUSH
5504: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5508: LD_VAR 0 2
5512: PPUSH
5513: LD_INT 16
5515: PPUSH
5516: LD_INT 0
5518: PPUSH
5519: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5523: LD_VAR 0 2
5527: PPUSH
5528: LD_INT 51
5530: PPUSH
5531: LD_INT 10
5533: PPUSH
5534: CALL_OW 111
// wait ( 0 0$2 ) ;
5538: LD_INT 70
5540: PPUSH
5541: CALL_OW 67
// end ;
5545: GO 5408
5547: POP
5548: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5549: LD_ADDR_VAR 0 5
5553: PUSH
5554: LD_INT 51
5556: PUSH
5557: LD_INT 24
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 75
5566: PUSH
5567: LD_INT 90
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5578: LD_INT 1
5580: PPUSH
5581: LD_VAR 0 3
5585: PUSH
5586: LD_INT 1
5588: ARRAY
5589: PPUSH
5590: LD_VAR 0 5
5594: PPUSH
5595: LD_VAR 0 6
5599: PPUSH
5600: CALL 42878 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5604: LD_ADDR_VAR 0 1
5608: PUSH
5609: DOUBLE
5610: LD_INT 1
5612: DEC
5613: ST_TO_ADDR
5614: LD_INT 1
5616: PUSH
5617: LD_INT 3
5619: PUSH
5620: LD_INT 4
5622: PUSH
5623: LD_INT 5
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_OWVAR 67
5636: ARRAY
5637: PUSH
5638: FOR_TO
5639: IFFALSE 5739
// begin uc_side := 2 ;
5641: LD_ADDR_OWVAR 20
5645: PUSH
5646: LD_INT 2
5648: ST_TO_ADDR
// uc_nation := 2 ;
5649: LD_ADDR_OWVAR 21
5653: PUSH
5654: LD_INT 2
5656: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5657: LD_INT 0
5659: PPUSH
5660: LD_INT 17
5662: PPUSH
5663: LD_VAR 0 4
5667: PPUSH
5668: CALL_OW 380
// un := CreateHuman ;
5672: LD_ADDR_VAR 0 2
5676: PUSH
5677: CALL_OW 44
5681: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5682: LD_ADDR_VAR 0 3
5686: PUSH
5687: LD_VAR 0 3
5691: PPUSH
5692: LD_INT 2
5694: PUSH
5695: LD_VAR 0 3
5699: PUSH
5700: LD_INT 2
5702: ARRAY
5703: PUSH
5704: LD_INT 1
5706: PLUS
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: PPUSH
5712: LD_VAR 0 2
5716: PPUSH
5717: CALL 54081 0 3
5721: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5722: LD_VAR 0 2
5726: PPUSH
5727: LD_INT 13
5729: PPUSH
5730: LD_INT 0
5732: PPUSH
5733: CALL_OW 49
// end ;
5737: GO 5638
5739: POP
5740: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5741: LD_ADDR_VAR 0 1
5745: PUSH
5746: DOUBLE
5747: LD_INT 1
5749: DEC
5750: ST_TO_ADDR
5751: LD_INT 3
5753: PUSH
5754: LD_INT 4
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 6
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: LIST
5768: PUSH
5769: LD_OWVAR 67
5773: ARRAY
5774: PUSH
5775: FOR_TO
5776: IFFALSE 5897
// begin uc_side := 2 ;
5778: LD_ADDR_OWVAR 20
5782: PUSH
5783: LD_INT 2
5785: ST_TO_ADDR
// uc_nation := 2 ;
5786: LD_ADDR_OWVAR 21
5790: PUSH
5791: LD_INT 2
5793: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5794: LD_INT 0
5796: PPUSH
5797: LD_INT 1
5799: PUSH
5800: LD_INT 8
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: PUSH
5807: LD_VAR 0 1
5811: PUSH
5812: LD_INT 2
5814: MOD
5815: PUSH
5816: LD_INT 1
5818: PLUS
5819: ARRAY
5820: PPUSH
5821: LD_VAR 0 4
5825: PPUSH
5826: CALL_OW 380
// un := CreateHuman ;
5830: LD_ADDR_VAR 0 2
5834: PUSH
5835: CALL_OW 44
5839: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5840: LD_ADDR_VAR 0 3
5844: PUSH
5845: LD_VAR 0 3
5849: PPUSH
5850: LD_INT 2
5852: PUSH
5853: LD_VAR 0 3
5857: PUSH
5858: LD_INT 2
5860: ARRAY
5861: PUSH
5862: LD_INT 1
5864: PLUS
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PPUSH
5870: LD_VAR 0 2
5874: PPUSH
5875: CALL 54081 0 3
5879: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5880: LD_VAR 0 2
5884: PPUSH
5885: LD_INT 13
5887: PPUSH
5888: LD_INT 0
5890: PPUSH
5891: CALL_OW 49
// end ;
5895: GO 5775
5897: POP
5898: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5899: LD_ADDR_VAR 0 5
5903: PUSH
5904: LD_INT 67
5906: PUSH
5907: LD_INT 112
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 85
5916: PUSH
5917: LD_INT 130
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5928: LD_INT 2
5930: PPUSH
5931: LD_VAR 0 3
5935: PUSH
5936: LD_INT 2
5938: ARRAY
5939: PPUSH
5940: LD_VAR 0 5
5944: PPUSH
5945: LD_VAR 0 6
5949: PPUSH
5950: CALL 42878 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: DOUBLE
5960: LD_INT 1
5962: DEC
5963: ST_TO_ADDR
5964: LD_INT 1
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 3
5972: PUSH
5973: LD_INT 5
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: LIST
5981: PUSH
5982: LD_OWVAR 67
5986: ARRAY
5987: PUSH
5988: FOR_TO
5989: IFFALSE 6089
// begin uc_side := 2 ;
5991: LD_ADDR_OWVAR 20
5995: PUSH
5996: LD_INT 2
5998: ST_TO_ADDR
// uc_nation := 2 ;
5999: LD_ADDR_OWVAR 21
6003: PUSH
6004: LD_INT 2
6006: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6007: LD_INT 0
6009: PPUSH
6010: LD_INT 17
6012: PPUSH
6013: LD_VAR 0 4
6017: PPUSH
6018: CALL_OW 380
// un := CreateHuman ;
6022: LD_ADDR_VAR 0 2
6026: PUSH
6027: CALL_OW 44
6031: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6032: LD_ADDR_VAR 0 3
6036: PUSH
6037: LD_VAR 0 3
6041: PPUSH
6042: LD_INT 3
6044: PUSH
6045: LD_VAR 0 3
6049: PUSH
6050: LD_INT 3
6052: ARRAY
6053: PUSH
6054: LD_INT 1
6056: PLUS
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PPUSH
6062: LD_VAR 0 2
6066: PPUSH
6067: CALL 54081 0 3
6071: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6072: LD_VAR 0 2
6076: PPUSH
6077: LD_INT 14
6079: PPUSH
6080: LD_INT 0
6082: PPUSH
6083: CALL_OW 49
// end ;
6087: GO 5988
6089: POP
6090: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6091: LD_ADDR_VAR 0 5
6095: PUSH
6096: LD_INT 148
6098: PUSH
6099: LD_INT 158
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: LD_INT 148
6108: PUSH
6109: LD_INT 158
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6120: LD_INT 3
6122: PPUSH
6123: LD_VAR 0 3
6127: PUSH
6128: LD_INT 3
6130: ARRAY
6131: PPUSH
6132: LD_VAR 0 5
6136: PPUSH
6137: LD_VAR 0 6
6141: PPUSH
6142: CALL 42878 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6146: LD_ADDR_VAR 0 1
6150: PUSH
6151: DOUBLE
6152: LD_INT 1
6154: DEC
6155: ST_TO_ADDR
6156: LD_INT 2
6158: PUSH
6159: LD_INT 3
6161: PUSH
6162: LD_INT 4
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_OWVAR 67
6178: ARRAY
6179: PUSH
6180: FOR_TO
6181: IFFALSE 6405
// begin uc_side := 2 ;
6183: LD_ADDR_OWVAR 20
6187: PUSH
6188: LD_INT 2
6190: ST_TO_ADDR
// uc_nation := 2 ;
6191: LD_ADDR_OWVAR 21
6195: PUSH
6196: LD_INT 2
6198: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6199: LD_INT 14
6201: PPUSH
6202: LD_INT 3
6204: PPUSH
6205: LD_INT 1
6207: PUSH
6208: LD_INT 5
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 1
6217: PPUSH
6218: LD_INT 2
6220: PPUSH
6221: CALL_OW 12
6225: ARRAY
6226: PPUSH
6227: LD_INT 27
6229: PUSH
6230: LD_INT 26
6232: PUSH
6233: LD_INT 28
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: LIST
6240: PUSH
6241: LD_INT 1
6243: PPUSH
6244: LD_INT 3
6246: PPUSH
6247: CALL_OW 12
6251: ARRAY
6252: PPUSH
6253: LD_INT 100
6255: PPUSH
6256: CALL 53959 0 5
// un := CreateVehicle ;
6260: LD_ADDR_VAR 0 2
6264: PUSH
6265: CALL_OW 45
6269: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6270: LD_ADDR_VAR 0 3
6274: PUSH
6275: LD_VAR 0 3
6279: PPUSH
6280: LD_INT 4
6282: PUSH
6283: LD_VAR 0 3
6287: PUSH
6288: LD_INT 4
6290: ARRAY
6291: PUSH
6292: LD_INT 1
6294: PLUS
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PPUSH
6300: LD_VAR 0 2
6304: PPUSH
6305: CALL 54081 0 3
6309: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6310: LD_VAR 0 2
6314: PPUSH
6315: LD_INT 5
6317: PPUSH
6318: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6322: LD_VAR 0 2
6326: PPUSH
6327: LD_INT 15
6329: PPUSH
6330: LD_INT 0
6332: PPUSH
6333: CALL_OW 49
// if GetControl ( un ) = control_manual then
6337: LD_VAR 0 2
6341: PPUSH
6342: CALL_OW 263
6346: PUSH
6347: LD_INT 1
6349: EQUAL
6350: IFFALSE 6381
// begin PrepareHuman ( false , 3 , skill ) ;
6352: LD_INT 0
6354: PPUSH
6355: LD_INT 3
6357: PPUSH
6358: LD_VAR 0 4
6362: PPUSH
6363: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6367: CALL_OW 44
6371: PPUSH
6372: LD_VAR 0 2
6376: PPUSH
6377: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6381: LD_VAR 0 2
6385: PPUSH
6386: LD_INT 179
6388: PPUSH
6389: LD_INT 135
6391: PPUSH
6392: CALL_OW 111
// wait ( 0 0$2 ) ;
6396: LD_INT 70
6398: PPUSH
6399: CALL_OW 67
// end ;
6403: GO 6180
6405: POP
6406: POP
// vc_chassis := 15 ;
6407: LD_ADDR_OWVAR 37
6411: PUSH
6412: LD_INT 15
6414: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6415: LD_ADDR_VAR 0 3
6419: PUSH
6420: LD_VAR 0 3
6424: PPUSH
6425: LD_INT 4
6427: PUSH
6428: LD_VAR 0 3
6432: PUSH
6433: LD_INT 4
6435: ARRAY
6436: PUSH
6437: LD_INT 1
6439: PLUS
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PPUSH
6445: CALL_OW 45
6449: PPUSH
6450: CALL 54081 0 3
6454: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6455: LD_VAR 0 3
6459: PUSH
6460: LD_INT 4
6462: ARRAY
6463: PUSH
6464: LD_VAR 0 3
6468: PUSH
6469: LD_INT 4
6471: ARRAY
6472: ARRAY
6473: PPUSH
6474: LD_INT 15
6476: PPUSH
6477: LD_INT 0
6479: PPUSH
6480: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6484: LD_INT 0
6486: PPUSH
6487: LD_INT 11
6489: PPUSH
6490: LD_VAR 0 4
6494: PPUSH
6495: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6499: LD_ADDR_VAR 0 3
6503: PUSH
6504: LD_VAR 0 3
6508: PPUSH
6509: LD_INT 4
6511: PUSH
6512: LD_VAR 0 3
6516: PUSH
6517: LD_INT 4
6519: ARRAY
6520: PUSH
6521: LD_INT 1
6523: PLUS
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: PPUSH
6529: CALL_OW 44
6533: PPUSH
6534: CALL 54081 0 3
6538: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_INT 4
6555: ARRAY
6556: ARRAY
6557: PPUSH
6558: LD_VAR 0 3
6562: PUSH
6563: LD_INT 4
6565: ARRAY
6566: PUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 4
6574: ARRAY
6575: PUSH
6576: LD_INT 1
6578: MINUS
6579: ARRAY
6580: PPUSH
6581: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6585: LD_ADDR_VAR 0 5
6589: PUSH
6590: LD_INT 148
6592: PUSH
6593: LD_INT 140
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: PUSH
6600: EMPTY
6601: LIST
6602: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6603: LD_INT 1
6605: PPUSH
6606: LD_VAR 0 3
6610: PUSH
6611: LD_INT 4
6613: ARRAY
6614: PPUSH
6615: LD_VAR 0 5
6619: PPUSH
6620: LD_VAR 0 6
6624: PPUSH
6625: CALL 42878 0 4
// if gensher_active then
6629: LD_EXP 18
6633: IFFALSE 7039
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6635: LD_EXP 45
6639: PPUSH
6640: LD_STRING D10-Diet-1
6642: PPUSH
6643: CALL_OW 94
// for i = 1 to 2 do
6647: LD_ADDR_VAR 0 1
6651: PUSH
6652: DOUBLE
6653: LD_INT 1
6655: DEC
6656: ST_TO_ADDR
6657: LD_INT 2
6659: PUSH
6660: FOR_TO
6661: IFFALSE 6799
// begin uc_side := 2 ;
6663: LD_ADDR_OWVAR 20
6667: PUSH
6668: LD_INT 2
6670: ST_TO_ADDR
// uc_nation := 2 ;
6671: LD_ADDR_OWVAR 21
6675: PUSH
6676: LD_INT 2
6678: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6679: LD_INT 13
6681: PPUSH
6682: LD_INT 3
6684: PPUSH
6685: LD_INT 5
6687: PPUSH
6688: LD_INT 29
6690: PPUSH
6691: LD_INT 100
6693: PPUSH
6694: CALL 53959 0 5
// un := CreateVehicle ;
6698: LD_ADDR_VAR 0 2
6702: PUSH
6703: CALL_OW 45
6707: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6708: LD_ADDR_VAR 0 3
6712: PUSH
6713: LD_VAR 0 3
6717: PPUSH
6718: LD_INT 5
6720: PUSH
6721: LD_VAR 0 3
6725: PUSH
6726: LD_INT 5
6728: ARRAY
6729: PUSH
6730: LD_INT 1
6732: PLUS
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PPUSH
6738: LD_VAR 0 2
6742: PPUSH
6743: CALL 54081 0 3
6747: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6748: LD_VAR 0 2
6752: PPUSH
6753: LD_INT 0
6755: PPUSH
6756: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6760: LD_VAR 0 2
6764: PPUSH
6765: LD_INT 23
6767: PPUSH
6768: LD_INT 0
6770: PPUSH
6771: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6775: LD_VAR 0 2
6779: PPUSH
6780: LD_INT 85
6782: PPUSH
6783: LD_INT 152
6785: PPUSH
6786: CALL_OW 111
// wait ( 0 0$2 ) ;
6790: LD_INT 70
6792: PPUSH
6793: CALL_OW 67
// end ;
6797: GO 6660
6799: POP
6800: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6801: LD_ADDR_VAR 0 1
6805: PUSH
6806: DOUBLE
6807: LD_INT 1
6809: DEC
6810: ST_TO_ADDR
6811: LD_INT 2
6813: PUSH
6814: LD_INT 3
6816: PUSH
6817: LD_INT 3
6819: PUSH
6820: LD_INT 4
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: LIST
6828: PUSH
6829: LD_OWVAR 67
6833: ARRAY
6834: PUSH
6835: FOR_TO
6836: IFFALSE 6993
// begin uc_side := 2 ;
6838: LD_ADDR_OWVAR 20
6842: PUSH
6843: LD_INT 2
6845: ST_TO_ADDR
// uc_nation := 2 ;
6846: LD_ADDR_OWVAR 21
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6854: LD_INT 14
6856: PPUSH
6857: LD_INT 3
6859: PPUSH
6860: LD_INT 5
6862: PPUSH
6863: LD_INT 27
6865: PUSH
6866: LD_INT 28
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 1
6875: PPUSH
6876: LD_INT 2
6878: PPUSH
6879: CALL_OW 12
6883: ARRAY
6884: PPUSH
6885: LD_INT 100
6887: PPUSH
6888: CALL 53959 0 5
// un := CreateVehicle ;
6892: LD_ADDR_VAR 0 2
6896: PUSH
6897: CALL_OW 45
6901: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6902: LD_ADDR_VAR 0 3
6906: PUSH
6907: LD_VAR 0 3
6911: PPUSH
6912: LD_INT 5
6914: PUSH
6915: LD_VAR 0 3
6919: PUSH
6920: LD_INT 5
6922: ARRAY
6923: PUSH
6924: LD_INT 1
6926: PLUS
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: PPUSH
6932: LD_VAR 0 2
6936: PPUSH
6937: CALL 54081 0 3
6941: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6942: LD_VAR 0 2
6946: PPUSH
6947: LD_INT 0
6949: PPUSH
6950: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6954: LD_VAR 0 2
6958: PPUSH
6959: LD_INT 23
6961: PPUSH
6962: LD_INT 0
6964: PPUSH
6965: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6969: LD_VAR 0 2
6973: PPUSH
6974: LD_INT 85
6976: PPUSH
6977: LD_INT 152
6979: PPUSH
6980: CALL_OW 111
// wait ( 0 0$2 ) ;
6984: LD_INT 70
6986: PPUSH
6987: CALL_OW 67
// end ;
6991: GO 6835
6993: POP
6994: POP
// coords := [ [ 97 , 143 ] ] ;
6995: LD_ADDR_VAR 0 5
6999: PUSH
7000: LD_INT 97
7002: PUSH
7003: LD_INT 143
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: EMPTY
7011: LIST
7012: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7013: LD_INT 1
7015: PPUSH
7016: LD_VAR 0 3
7020: PUSH
7021: LD_INT 5
7023: ARRAY
7024: PPUSH
7025: LD_VAR 0 5
7029: PPUSH
7030: LD_VAR 0 6
7034: PPUSH
7035: CALL 42878 0 4
// end ; end ;
7039: PPOPN 7
7041: END
// every 5 5$0 + 15 15$0 do var i , tmp , tmp2 , coords , w , list , p ;
7042: GO 7044
7044: DISABLE
7045: LD_INT 0
7047: PPUSH
7048: PPUSH
7049: PPUSH
7050: PPUSH
7051: PPUSH
7052: PPUSH
7053: PPUSH
// begin enable ;
7054: ENABLE
// tmp := [ ] ;
7055: LD_ADDR_VAR 0 2
7059: PUSH
7060: EMPTY
7061: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
7062: LD_ADDR_VAR 0 5
7066: PUSH
7067: LD_INT 1
7069: PPUSH
7070: LD_INT 3
7072: PPUSH
7073: CALL_OW 12
7077: ST_TO_ADDR
// if w = 3 then
7078: LD_VAR 0 5
7082: PUSH
7083: LD_INT 3
7085: EQUAL
7086: IFFALSE 7173
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7088: LD_ADDR_VAR 0 6
7092: PUSH
7093: LD_INT 11
7095: PUSH
7096: LD_INT 1
7098: PUSH
7099: LD_INT 2
7101: PUSH
7102: LD_INT 24
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 11
7113: PUSH
7114: LD_INT 1
7116: PUSH
7117: LD_INT 2
7119: PUSH
7120: LD_INT 24
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: LIST
7127: LIST
7128: PUSH
7129: LD_INT 11
7131: PUSH
7132: LD_INT 1
7134: PUSH
7135: LD_INT 2
7137: PUSH
7138: LD_INT 24
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: PUSH
7147: LD_INT 11
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: LD_INT 2
7155: PUSH
7156: LD_INT 24
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: LIST
7163: LIST
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: ST_TO_ADDR
7171: GO 7275
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7173: LD_ADDR_VAR 0 6
7177: PUSH
7178: LD_INT 14
7180: PUSH
7181: LD_INT 1
7183: PUSH
7184: LD_INT 2
7186: PUSH
7187: LD_INT 28
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 14
7198: PUSH
7199: LD_INT 1
7201: PUSH
7202: LD_INT 2
7204: PUSH
7205: LD_INT 25
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: LIST
7212: LIST
7213: PUSH
7214: LD_INT 14
7216: PUSH
7217: LD_INT 1
7219: PUSH
7220: LD_INT 2
7222: PUSH
7223: LD_INT 28
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: LIST
7230: LIST
7231: PUSH
7232: LD_INT 14
7234: PUSH
7235: LD_INT 1
7237: PUSH
7238: LD_INT 2
7240: PUSH
7241: LD_INT 29
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: LIST
7248: LIST
7249: PUSH
7250: LD_INT 14
7252: PUSH
7253: LD_INT 1
7255: PUSH
7256: LD_INT 2
7258: PUSH
7259: LD_INT 29
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: LIST
7272: LIST
7273: LIST
7274: ST_TO_ADDR
// if w < 3 then
7275: LD_VAR 0 5
7279: PUSH
7280: LD_INT 3
7282: LESS
7283: IFFALSE 7363
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] ) ;
7285: LD_ADDR_VAR 0 6
7289: PUSH
7290: LD_VAR 0 6
7294: PPUSH
7295: LD_INT 1
7297: PUSH
7298: LD_VAR 0 6
7302: PUSH
7303: LD_VAR 0 1
7307: ARRAY
7308: PUSH
7309: LD_INT 1
7311: PLUS
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PPUSH
7317: LD_INT 14
7319: PUSH
7320: LD_INT 1
7322: PUSH
7323: LD_INT 2
7325: PUSH
7326: LD_INT 25
7328: PUSH
7329: LD_INT 28
7331: PUSH
7332: LD_INT 29
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: LIST
7339: PUSH
7340: LD_INT 1
7342: PPUSH
7343: LD_INT 3
7345: PPUSH
7346: CALL_OW 12
7350: ARRAY
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PPUSH
7358: CALL 54081 0 3
7362: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7363: LD_INT 1
7365: PPUSH
7366: LD_VAR 0 6
7370: PPUSH
7371: CALL 42645 0 2
// if GetSide ( ar_dep_w ) = 2 and IsOk ( ar_dep_w ) and w < 3 then
7375: LD_INT 45
7377: PPUSH
7378: CALL_OW 255
7382: PUSH
7383: LD_INT 2
7385: EQUAL
7386: PUSH
7387: LD_INT 45
7389: PPUSH
7390: CALL_OW 302
7394: AND
7395: PUSH
7396: LD_VAR 0 5
7400: PUSH
7401: LD_INT 3
7403: LESS
7404: AND
7405: IFFALSE 7490
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7407: LD_ADDR_VAR 0 6
7411: PUSH
7412: LD_INT 14
7414: PUSH
7415: LD_INT 1
7417: PUSH
7418: LD_INT 2
7420: PUSH
7421: LD_INT 28
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: PUSH
7430: LD_INT 14
7432: PUSH
7433: LD_INT 1
7435: PUSH
7436: LD_INT 2
7438: PUSH
7439: LD_INT 27
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 14
7450: PUSH
7451: LD_INT 1
7453: PUSH
7454: LD_INT 2
7456: PUSH
7457: LD_INT 27
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7471: LD_INT 2
7473: PPUSH
7474: LD_VAR 0 6
7478: PPUSH
7479: CALL 42645 0 2
// wait ( 0 0$20 ) ;
7483: LD_INT 700
7485: PPUSH
7486: CALL_OW 67
// end ; p := 60 ;
7490: LD_ADDR_VAR 0 7
7494: PUSH
7495: LD_INT 60
7497: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7498: LD_INT 35
7500: PPUSH
7501: CALL_OW 67
// p := Dec ( p ) ;
7505: LD_ADDR_VAR 0 7
7509: PUSH
7510: LD_VAR 0 7
7514: PPUSH
7515: CALL 88204 0 1
7519: ST_TO_ADDR
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) >= 4 or p <= 0 ;
7520: LD_EXP 69
7524: PUSH
7525: LD_INT 1
7527: ARRAY
7528: PPUSH
7529: LD_INT 3
7531: PUSH
7532: LD_INT 34
7534: PUSH
7535: LD_INT 32
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: PUSH
7542: LD_INT 34
7544: PUSH
7545: LD_INT 88
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PPUSH
7557: CALL_OW 72
7561: PUSH
7562: LD_INT 4
7564: GREATEREQUAL
7565: PUSH
7566: LD_VAR 0 7
7570: PUSH
7571: LD_INT 0
7573: LESSEQUAL
7574: OR
7575: IFFALSE 7498
// wait ( 0 0$10 ) ;
7577: LD_INT 350
7579: PPUSH
7580: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7584: LD_ADDR_VAR 0 2
7588: PUSH
7589: LD_EXP 69
7593: PUSH
7594: LD_INT 1
7596: ARRAY
7597: PPUSH
7598: LD_INT 3
7600: PUSH
7601: LD_INT 34
7603: PUSH
7604: LD_INT 32
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: LD_INT 34
7613: PUSH
7614: LD_INT 88
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: LIST
7625: PPUSH
7626: CALL_OW 72
7630: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7631: LD_ADDR_VAR 0 3
7635: PUSH
7636: LD_EXP 69
7640: PUSH
7641: LD_INT 2
7643: ARRAY
7644: PPUSH
7645: LD_INT 3
7647: PUSH
7648: LD_INT 34
7650: PUSH
7651: LD_INT 32
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: PUSH
7658: LD_INT 34
7660: PUSH
7661: LD_INT 88
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: LIST
7672: PPUSH
7673: CALL_OW 72
7677: ST_TO_ADDR
// if tmp2 then
7678: LD_VAR 0 3
7682: IFFALSE 7700
// tmp := tmp union tmp2 ;
7684: LD_ADDR_VAR 0 2
7688: PUSH
7689: LD_VAR 0 2
7693: PUSH
7694: LD_VAR 0 3
7698: UNION
7699: ST_TO_ADDR
// if not tmp then
7700: LD_VAR 0 2
7704: NOT
7705: IFFALSE 7709
// exit ;
7707: GO 8090
// if Count ( tmp2 ) or Prob ( 50 ) then
7709: LD_VAR 0 3
7713: PPUSH
7714: CALL 51221 0 1
7718: PUSH
7719: LD_INT 50
7721: PPUSH
7722: CALL_OW 13
7726: OR
7727: IFFALSE 7760
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7729: LD_ADDR_VAR 0 4
7733: PUSH
7734: LD_INT 48
7736: PUSH
7737: LD_INT 33
7739: PUSH
7740: EMPTY
7741: LIST
7742: LIST
7743: PUSH
7744: LD_INT 71
7746: PUSH
7747: LD_INT 88
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: ST_TO_ADDR
7758: GO 7789
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7760: LD_ADDR_VAR 0 4
7764: PUSH
7765: LD_INT 128
7767: PUSH
7768: LD_INT 94
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PUSH
7775: LD_INT 180
7777: PUSH
7778: LD_INT 135
7780: PUSH
7781: EMPTY
7782: LIST
7783: LIST
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: ST_TO_ADDR
// if w = 3 then
7789: LD_VAR 0 5
7793: PUSH
7794: LD_INT 3
7796: EQUAL
7797: IFFALSE 7828
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7799: LD_ADDR_VAR 0 4
7803: PUSH
7804: LD_INT 91
7806: PUSH
7807: LD_INT 58
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 117
7816: PUSH
7817: LD_INT 107
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: ST_TO_ADDR
// if FilterUnitsInArea ( base_north , [ f_side , 1 ] ) then
7828: LD_INT 28
7830: PPUSH
7831: LD_INT 22
7833: PUSH
7834: LD_INT 1
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PPUSH
7841: CALL_OW 70
7845: IFFALSE 7865
// coords := [ [ 163 , 41 ] ] ;
7847: LD_ADDR_VAR 0 4
7851: PUSH
7852: LD_INT 163
7854: PUSH
7855: LD_INT 41
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PUSH
7862: EMPTY
7863: LIST
7864: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7865: LD_VAR 0 2
7869: PPUSH
7870: LD_VAR 0 4
7874: PUSH
7875: LD_INT 1
7877: ARRAY
7878: PPUSH
7879: LD_VAR 0 4
7883: PUSH
7884: LD_INT 2
7886: ARRAY
7887: PPUSH
7888: CALL_OW 114
// p := 30 ;
7892: LD_ADDR_VAR 0 7
7896: PUSH
7897: LD_INT 30
7899: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7900: LD_INT 35
7902: PPUSH
7903: CALL_OW 67
// p := Dec ( p ) ;
7907: LD_ADDR_VAR 0 7
7911: PUSH
7912: LD_VAR 0 7
7916: PPUSH
7917: CALL 88204 0 1
7921: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 or p <= 0 ;
7922: LD_VAR 0 2
7926: PPUSH
7927: LD_INT 60
7929: PUSH
7930: EMPTY
7931: LIST
7932: PPUSH
7933: CALL_OW 72
7937: PUSH
7938: LD_INT 0
7940: EQUAL
7941: PUSH
7942: LD_VAR 0 7
7946: PUSH
7947: LD_INT 0
7949: LESSEQUAL
7950: OR
7951: IFFALSE 7900
// repeat wait ( 0 0$2 ) ;
7953: LD_INT 70
7955: PPUSH
7956: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
7960: LD_ADDR_VAR 0 2
7964: PUSH
7965: LD_VAR 0 2
7969: PPUSH
7970: LD_INT 50
7972: PUSH
7973: EMPTY
7974: LIST
7975: PPUSH
7976: CALL_OW 72
7980: ST_TO_ADDR
// for i in tmp do
7981: LD_ADDR_VAR 0 1
7985: PUSH
7986: LD_VAR 0 2
7990: PUSH
7991: FOR_IN
7992: IFFALSE 8081
// if GetChassis ( i ) = ar_hovercraft then
7994: LD_VAR 0 1
7998: PPUSH
7999: CALL_OW 265
8003: PUSH
8004: LD_INT 11
8006: EQUAL
8007: IFFALSE 8045
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
8009: LD_VAR 0 1
8013: PPUSH
8014: LD_INT 22
8016: PUSH
8017: LD_INT 1
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: PPUSH
8024: CALL_OW 69
8028: PPUSH
8029: LD_VAR 0 1
8033: PPUSH
8034: CALL_OW 74
8038: PPUSH
8039: CALL 82424 0 2
8043: GO 8079
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
8045: LD_VAR 0 1
8049: PPUSH
8050: LD_INT 22
8052: PUSH
8053: LD_INT 1
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: PPUSH
8060: CALL_OW 69
8064: PPUSH
8065: LD_VAR 0 1
8069: PPUSH
8070: CALL_OW 74
8074: PPUSH
8075: CALL_OW 115
8079: GO 7991
8081: POP
8082: POP
// until not tmp ;
8083: LD_VAR 0 2
8087: NOT
8088: IFFALSE 7953
// end ;
8090: PPOPN 7
8092: END
// every 28 28$00 do var i , tmp , un , x , p ;
8093: GO 8095
8095: DISABLE
8096: LD_INT 0
8098: PPUSH
8099: PPUSH
8100: PPUSH
8101: PPUSH
8102: PPUSH
// begin enable ;
8103: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
8104: LD_INT 35
8106: PPUSH
8107: LD_INT 1190
8109: PPUSH
8110: CALL_OW 12
8114: PPUSH
8115: CALL_OW 67
// tmp := [ ] ;
8119: LD_ADDR_VAR 0 2
8123: PUSH
8124: EMPTY
8125: ST_TO_ADDR
// InitHc ;
8126: CALL_OW 19
// for i = 1 to 3 do
8130: LD_ADDR_VAR 0 1
8134: PUSH
8135: DOUBLE
8136: LD_INT 1
8138: DEC
8139: ST_TO_ADDR
8140: LD_INT 3
8142: PUSH
8143: FOR_TO
8144: IFFALSE 8287
// begin uc_side := 8 ;
8146: LD_ADDR_OWVAR 20
8150: PUSH
8151: LD_INT 8
8153: ST_TO_ADDR
// uc_nation := 2 ;
8154: LD_ADDR_OWVAR 21
8158: PUSH
8159: LD_INT 2
8161: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8162: LD_INT 13
8164: PUSH
8165: LD_INT 14
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_INT 1
8174: PPUSH
8175: LD_INT 2
8177: PPUSH
8178: CALL_OW 12
8182: ARRAY
8183: PPUSH
8184: LD_INT 3
8186: PPUSH
8187: LD_INT 5
8189: PPUSH
8190: LD_INT 27
8192: PUSH
8193: LD_INT 28
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: PUSH
8200: LD_INT 1
8202: PPUSH
8203: LD_INT 2
8205: PPUSH
8206: CALL_OW 12
8210: ARRAY
8211: PPUSH
8212: LD_INT 100
8214: PPUSH
8215: CALL 53959 0 5
// un := CreateVehicle ;
8219: LD_ADDR_VAR 0 3
8223: PUSH
8224: CALL_OW 45
8228: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8229: LD_VAR 0 3
8233: PPUSH
8234: LD_INT 4
8236: PPUSH
8237: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8241: LD_VAR 0 3
8245: PPUSH
8246: LD_INT 15
8248: PPUSH
8249: LD_INT 0
8251: PPUSH
8252: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8256: LD_ADDR_VAR 0 2
8260: PUSH
8261: LD_VAR 0 2
8265: PPUSH
8266: LD_VAR 0 2
8270: PUSH
8271: LD_INT 1
8273: PLUS
8274: PPUSH
8275: LD_VAR 0 3
8279: PPUSH
8280: CALL_OW 1
8284: ST_TO_ADDR
// end ;
8285: GO 8143
8287: POP
8288: POP
// for i = 1 to 3 do
8289: LD_ADDR_VAR 0 1
8293: PUSH
8294: DOUBLE
8295: LD_INT 1
8297: DEC
8298: ST_TO_ADDR
8299: LD_INT 3
8301: PUSH
8302: FOR_TO
8303: IFFALSE 8411
// begin uc_side := 8 ;
8305: LD_ADDR_OWVAR 20
8309: PUSH
8310: LD_INT 8
8312: ST_TO_ADDR
// uc_nation := 2 ;
8313: LD_ADDR_OWVAR 21
8317: PUSH
8318: LD_INT 2
8320: ST_TO_ADDR
// PrepareHuman ( false , 1 , 6 ) ;
8321: LD_INT 0
8323: PPUSH
8324: LD_INT 1
8326: PPUSH
8327: LD_INT 6
8329: PPUSH
8330: CALL_OW 380
// un := CreateHuman ;
8334: LD_ADDR_VAR 0 3
8338: PUSH
8339: CALL_OW 44
8343: ST_TO_ADDR
// if Prob ( 50 ) then
8344: LD_INT 50
8346: PPUSH
8347: CALL_OW 13
8351: IFFALSE 8365
// SetClass ( un , class_mortar ) ;
8353: LD_VAR 0 3
8357: PPUSH
8358: LD_INT 8
8360: PPUSH
8361: CALL_OW 336
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8365: LD_VAR 0 3
8369: PPUSH
8370: LD_INT 15
8372: PPUSH
8373: LD_INT 0
8375: PPUSH
8376: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8380: LD_ADDR_VAR 0 2
8384: PUSH
8385: LD_VAR 0 2
8389: PPUSH
8390: LD_VAR 0 2
8394: PUSH
8395: LD_INT 1
8397: PLUS
8398: PPUSH
8399: LD_VAR 0 3
8403: PPUSH
8404: CALL_OW 1
8408: ST_TO_ADDR
// end ;
8409: GO 8302
8411: POP
8412: POP
// wait ( 0 0$3 ) ;
8413: LD_INT 105
8415: PPUSH
8416: CALL_OW 67
// p := 0 ;
8420: LD_ADDR_VAR 0 5
8424: PUSH
8425: LD_INT 0
8427: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
8428: LD_INT 105
8430: PPUSH
8431: CALL_OW 67
// p := p + 3 ;
8435: LD_ADDR_VAR 0 5
8439: PUSH
8440: LD_VAR 0 5
8444: PUSH
8445: LD_INT 3
8447: PLUS
8448: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_ok ] ) do
8449: LD_ADDR_VAR 0 1
8453: PUSH
8454: LD_VAR 0 2
8458: PPUSH
8459: LD_INT 50
8461: PUSH
8462: EMPTY
8463: LIST
8464: PPUSH
8465: CALL_OW 72
8469: PUSH
8470: FOR_IN
8471: IFFALSE 8509
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8473: LD_VAR 0 1
8477: PPUSH
8478: LD_INT 81
8480: PUSH
8481: LD_INT 8
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PPUSH
8488: CALL_OW 69
8492: PPUSH
8493: LD_VAR 0 1
8497: PPUSH
8498: CALL_OW 74
8502: PPUSH
8503: CALL_OW 115
8507: GO 8470
8509: POP
8510: POP
// until p >= 120 ;
8511: LD_VAR 0 5
8515: PUSH
8516: LD_INT 120
8518: GREATEREQUAL
8519: IFFALSE 8428
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8521: LD_VAR 0 2
8525: PPUSH
8526: LD_INT 210
8528: PPUSH
8529: LD_INT 178
8531: PPUSH
8532: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8536: LD_ADDR_VAR 0 4
8540: PUSH
8541: LD_INT 10
8543: PPUSH
8544: LD_INT 22
8546: PUSH
8547: LD_INT 8
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PPUSH
8554: CALL_OW 70
8558: ST_TO_ADDR
// if x then
8559: LD_VAR 0 4
8563: IFFALSE 8591
// for i in x do
8565: LD_ADDR_VAR 0 1
8569: PUSH
8570: LD_VAR 0 4
8574: PUSH
8575: FOR_IN
8576: IFFALSE 8589
// RemoveUnit ( i ) ;
8578: LD_VAR 0 1
8582: PPUSH
8583: CALL_OW 64
8587: GO 8575
8589: POP
8590: POP
// wait ( 0 0$1 ) ;
8591: LD_INT 35
8593: PPUSH
8594: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8598: LD_INT 22
8600: PUSH
8601: LD_INT 8
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: PPUSH
8608: CALL_OW 69
8612: NOT
8613: IFFALSE 8521
// end ;
8615: PPOPN 5
8617: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8618: LD_INT 22
8620: PUSH
8621: LD_INT 2
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: PUSH
8628: LD_INT 34
8630: PUSH
8631: LD_INT 31
8633: PUSH
8634: EMPTY
8635: LIST
8636: LIST
8637: PUSH
8638: LD_INT 3
8640: PUSH
8641: LD_INT 24
8643: PUSH
8644: LD_INT 1000
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 69
8664: IFFALSE 8767
8666: GO 8668
8668: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8669: LD_INT 45
8671: PPUSH
8672: CALL_OW 302
8676: PUSH
8677: LD_INT 45
8679: PPUSH
8680: CALL_OW 255
8684: AND
8685: IFFALSE 8728
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8687: LD_INT 22
8689: PUSH
8690: LD_INT 2
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 34
8699: PUSH
8700: LD_INT 31
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL_OW 69
8715: PPUSH
8716: LD_INT 18
8718: PPUSH
8719: LD_INT 8
8721: PPUSH
8722: CALL_OW 111
8726: GO 8767
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8728: LD_INT 22
8730: PUSH
8731: LD_INT 2
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PUSH
8738: LD_INT 34
8740: PUSH
8741: LD_INT 31
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: PPUSH
8752: CALL_OW 69
8756: PPUSH
8757: LD_INT 106
8759: PPUSH
8760: LD_INT 14
8762: PPUSH
8763: CALL_OW 111
// end ; end_of_file
8767: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8768: LD_INT 0
8770: PPUSH
8771: PPUSH
8772: PPUSH
8773: PPUSH
8774: PPUSH
8775: PPUSH
// InGameOn ;
8776: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8780: LD_EXP 21
8784: PPUSH
8785: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8789: LD_INT 2
8791: PPUSH
8792: LD_INT 1
8794: PPUSH
8795: LD_INT 1
8797: PPUSH
8798: LD_INT 1
8800: PPUSH
8801: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8805: LD_ADDR_VAR 0 2
8809: PUSH
8810: LD_INT 22
8812: PUSH
8813: LD_INT 1
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: LD_INT 25
8822: PUSH
8823: LD_INT 1
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PPUSH
8834: CALL_OW 69
8838: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8839: LD_ADDR_VAR 0 4
8843: PUSH
8844: LD_INT 22
8846: PUSH
8847: LD_INT 1
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: LD_INT 34
8856: PUSH
8857: LD_INT 11
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PPUSH
8868: CALL_OW 69
8872: PUSH
8873: LD_INT 1
8875: ARRAY
8876: ST_TO_ADDR
// for i = 1 to tmp do
8877: LD_ADDR_VAR 0 6
8881: PUSH
8882: DOUBLE
8883: LD_INT 1
8885: DEC
8886: ST_TO_ADDR
8887: LD_VAR 0 2
8891: PUSH
8892: FOR_TO
8893: IFFALSE 8940
// begin if i = 5 then
8895: LD_VAR 0 6
8899: PUSH
8900: LD_INT 5
8902: EQUAL
8903: IFFALSE 8907
// break ;
8905: GO 8940
// sols := Replace ( sols , i , tmp [ i ] ) ;
8907: LD_ADDR_VAR 0 5
8911: PUSH
8912: LD_VAR 0 5
8916: PPUSH
8917: LD_VAR 0 6
8921: PPUSH
8922: LD_VAR 0 2
8926: PUSH
8927: LD_VAR 0 6
8931: ARRAY
8932: PPUSH
8933: CALL_OW 1
8937: ST_TO_ADDR
// end ;
8938: GO 8892
8940: POP
8941: POP
// tmp := ar_force_tmp ;
8942: LD_ADDR_VAR 0 2
8946: PUSH
8947: LD_EXP 40
8951: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8952: LD_VAR 0 2
8956: PUSH
8957: LD_INT 1
8959: ARRAY
8960: PPUSH
8961: LD_INT 108
8963: PPUSH
8964: LD_INT 139
8966: PPUSH
8967: LD_INT 0
8969: PPUSH
8970: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8974: LD_VAR 0 2
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: LD_EXP 21
8987: PPUSH
8988: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8992: LD_VAR 0 2
8996: PUSH
8997: LD_INT 2
8999: ARRAY
9000: PPUSH
9001: LD_INT 114
9003: PPUSH
9004: LD_INT 132
9006: PPUSH
9007: LD_INT 0
9009: PPUSH
9010: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
9014: LD_VAR 0 2
9018: PUSH
9019: LD_INT 3
9021: ARRAY
9022: PPUSH
9023: LD_INT 115
9025: PPUSH
9026: LD_INT 132
9028: PPUSH
9029: LD_INT 0
9031: PPUSH
9032: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
9036: LD_VAR 0 2
9040: PUSH
9041: LD_INT 2
9043: ARRAY
9044: PUSH
9045: LD_VAR 0 2
9049: PUSH
9050: LD_INT 3
9052: ARRAY
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: PPUSH
9058: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
9062: LD_VAR 0 4
9066: PPUSH
9067: LD_INT 83
9069: PPUSH
9070: LD_INT 123
9072: PPUSH
9073: CALL_OW 111
// Wait ( 0 0$01 ) ;
9077: LD_INT 35
9079: PPUSH
9080: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
9084: LD_INT 90
9086: PPUSH
9087: LD_INT 144
9089: PPUSH
9090: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
9094: LD_VAR 0 5
9098: PPUSH
9099: LD_INT 88
9101: PPUSH
9102: LD_INT 129
9104: PPUSH
9105: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_INT 92
9116: PUSH
9117: LD_INT 131
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 88
9126: PUSH
9127: LD_INT 127
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: LD_INT 91
9136: PUSH
9137: LD_INT 132
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PUSH
9144: LD_INT 92
9146: PUSH
9147: LD_INT 134
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: ST_TO_ADDR
// for i = 1 to sols do
9160: LD_ADDR_VAR 0 6
9164: PUSH
9165: DOUBLE
9166: LD_INT 1
9168: DEC
9169: ST_TO_ADDR
9170: LD_VAR 0 5
9174: PUSH
9175: FOR_TO
9176: IFFALSE 9249
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
9178: LD_VAR 0 5
9182: PUSH
9183: LD_VAR 0 6
9187: ARRAY
9188: PPUSH
9189: LD_VAR 0 3
9193: PUSH
9194: LD_VAR 0 6
9198: ARRAY
9199: PUSH
9200: LD_INT 1
9202: ARRAY
9203: PPUSH
9204: LD_VAR 0 3
9208: PUSH
9209: LD_VAR 0 6
9213: ARRAY
9214: PUSH
9215: LD_INT 2
9217: ARRAY
9218: PPUSH
9219: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9223: LD_VAR 0 5
9227: PUSH
9228: LD_VAR 0 6
9232: ARRAY
9233: PPUSH
9234: CALL_OW 197
// AddComHold ( sols ) ;
9238: LD_VAR 0 5
9242: PPUSH
9243: CALL_OW 200
// end ;
9247: GO 9175
9249: POP
9250: POP
// repeat wait ( 0 0$1 ) ;
9251: LD_INT 35
9253: PPUSH
9254: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9258: LD_VAR 0 5
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: LD_INT 92
9269: PPUSH
9270: LD_INT 131
9272: PPUSH
9273: CALL_OW 297
9277: PUSH
9278: LD_INT 4
9280: LESS
9281: IFFALSE 9251
// CenterOnXY ( 96 , 139 ) ;
9283: LD_INT 96
9285: PPUSH
9286: LD_INT 139
9288: PPUSH
9289: CALL_OW 84
// wait ( 0 0$3 ) ;
9293: LD_INT 105
9295: PPUSH
9296: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9300: LD_INT 111
9302: PPUSH
9303: LD_INT 135
9305: PPUSH
9306: LD_INT 1
9308: PPUSH
9309: LD_INT 25
9311: NEG
9312: PPUSH
9313: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9317: LD_VAR 0 2
9321: PUSH
9322: LD_INT 2
9324: ARRAY
9325: PPUSH
9326: LD_VAR 0 2
9330: PUSH
9331: LD_INT 1
9333: ARRAY
9334: PPUSH
9335: CALL_OW 250
9339: PUSH
9340: LD_INT 3
9342: PLUS
9343: PPUSH
9344: LD_VAR 0 2
9348: PUSH
9349: LD_INT 1
9351: ARRAY
9352: PPUSH
9353: CALL_OW 251
9357: PPUSH
9358: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9362: LD_VAR 0 2
9366: PUSH
9367: LD_INT 3
9369: ARRAY
9370: PPUSH
9371: LD_INT 7
9373: PPUSH
9374: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9378: LD_VAR 0 2
9382: PUSH
9383: LD_INT 2
9385: ARRAY
9386: PPUSH
9387: LD_VAR 0 2
9391: PUSH
9392: LD_INT 1
9394: ARRAY
9395: PPUSH
9396: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9400: LD_INT 35
9402: PPUSH
9403: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9407: LD_VAR 0 2
9411: PUSH
9412: LD_INT 1
9414: ARRAY
9415: PPUSH
9416: LD_VAR 0 2
9420: PUSH
9421: LD_INT 2
9423: ARRAY
9424: PPUSH
9425: CALL_OW 296
9429: PUSH
9430: LD_INT 5
9432: LESS
9433: IFFALSE 9400
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9435: LD_VAR 0 2
9439: PUSH
9440: LD_INT 1
9442: ARRAY
9443: PPUSH
9444: LD_VAR 0 2
9448: PUSH
9449: LD_INT 2
9451: ARRAY
9452: PPUSH
9453: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9457: LD_VAR 0 2
9461: PUSH
9462: LD_INT 1
9464: ARRAY
9465: PPUSH
9466: LD_STRING D1a-Merc1-1
9468: PPUSH
9469: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9473: LD_VAR 0 2
9477: PUSH
9478: LD_INT 2
9480: ARRAY
9481: PPUSH
9482: LD_STRING D1a-FMerc2-1
9484: PPUSH
9485: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9489: LD_VAR 0 2
9493: PUSH
9494: LD_INT 2
9496: ARRAY
9497: PPUSH
9498: LD_VAR 0 2
9502: PUSH
9503: LD_INT 1
9505: ARRAY
9506: PPUSH
9507: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9511: LD_VAR 0 2
9515: PUSH
9516: LD_INT 1
9518: ARRAY
9519: PPUSH
9520: LD_INT 500
9522: PPUSH
9523: CALL_OW 234
// wait ( 0 0$2 ) ;
9527: LD_INT 70
9529: PPUSH
9530: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9534: LD_VAR 0 2
9538: PUSH
9539: LD_INT 1
9541: ARRAY
9542: PPUSH
9543: LD_INT 2
9545: PPUSH
9546: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9550: LD_INT 10
9552: PPUSH
9553: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9557: LD_VAR 0 2
9561: PUSH
9562: LD_INT 1
9564: ARRAY
9565: PPUSH
9566: LD_STRING D1a-Merc1-2
9568: PPUSH
9569: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9573: LD_INT 7
9575: PPUSH
9576: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9580: LD_VAR 0 2
9584: PUSH
9585: LD_INT 1
9587: ARRAY
9588: PPUSH
9589: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9593: LD_VAR 0 2
9597: PUSH
9598: LD_INT 2
9600: ARRAY
9601: PPUSH
9602: LD_INT 10
9604: PPUSH
9605: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9609: LD_VAR 0 2
9613: PUSH
9614: LD_INT 2
9616: ARRAY
9617: PPUSH
9618: LD_STRING D1a-FMerc2-2
9620: PPUSH
9621: CALL_OW 88
// wait ( 0 0$1 ) ;
9625: LD_INT 35
9627: PPUSH
9628: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9632: LD_INT 7
9634: PPUSH
9635: CALL_OW 85
// wait ( 0 0$2 ) ;
9639: LD_INT 70
9641: PPUSH
9642: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9646: LD_EXP 44
9650: PPUSH
9651: LD_STRING D1a-Saliba-1
9653: PPUSH
9654: CALL_OW 91
// KillUnit ( Saliba ) ;
9658: LD_EXP 44
9662: PPUSH
9663: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: ARRAY
9675: PPUSH
9676: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9680: LD_EXP 21
9684: PPUSH
9685: CALL_OW 85
// wait ( 0 0$1 ) ;
9689: LD_INT 35
9691: PPUSH
9692: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9696: LD_VAR 0 5
9700: PPUSH
9701: LD_INT 88
9703: PPUSH
9704: LD_INT 141
9706: PPUSH
9707: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9711: LD_VAR 0 5
9715: PPUSH
9716: LD_INT 70
9718: PPUSH
9719: CALL_OW 202
// wait ( 0 0$2 ) ;
9723: LD_INT 70
9725: PPUSH
9726: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9730: LD_INT 2
9732: PPUSH
9733: LD_INT 1
9735: PPUSH
9736: LD_INT 2
9738: PPUSH
9739: LD_INT 1
9741: PPUSH
9742: CALL_OW 80
// InGameOff ;
9746: CALL_OW 9
// ComWalk ( sols ) ;
9750: LD_VAR 0 5
9754: PPUSH
9755: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9759: LD_STRING M1
9761: PPUSH
9762: CALL_OW 337
// game_speed := 4 ;
9766: LD_ADDR_OWVAR 65
9770: PUSH
9771: LD_INT 4
9773: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9774: LD_INT 111
9776: PPUSH
9777: LD_INT 135
9779: PPUSH
9780: LD_INT 1
9782: PPUSH
9783: CALL_OW 331
// SaveForQuickRestart ;
9787: CALL_OW 22
// ar_run := true ;
9791: LD_ADDR_EXP 5
9795: PUSH
9796: LD_INT 1
9798: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9799: LD_INT 35
9801: PPUSH
9802: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9806: LD_INT 22
9808: PUSH
9809: LD_INT 1
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 91
9818: PUSH
9819: LD_INT 7
9821: PUSH
9822: LD_INT 10
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: PUSH
9839: LD_INT 7
9841: PPUSH
9842: CALL_OW 256
9846: PUSH
9847: LD_INT 999
9849: LESS
9850: OR
9851: IFFALSE 9799
// if GetSide ( ar_dep_s ) = 2 then
9853: LD_INT 7
9855: PPUSH
9856: CALL_OW 255
9860: PUSH
9861: LD_INT 2
9863: EQUAL
9864: IFFALSE 9876
// SetSide ( ar_dep_s , 1 ) ;
9866: LD_INT 7
9868: PPUSH
9869: LD_INT 1
9871: PPUSH
9872: CALL_OW 235
// end ;
9876: LD_VAR 0 1
9880: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9881: LD_EXP 5
9885: IFFALSE 10245
9887: GO 9889
9889: DISABLE
9890: LD_INT 0
9892: PPUSH
9893: PPUSH
9894: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9895: LD_ADDR_VAR 0 2
9899: PUSH
9900: LD_EXP 40
9904: PUSH
9905: LD_EXP 36
9909: PPUSH
9910: LD_INT 2
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 2
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: LD_INT 21
9925: PUSH
9926: LD_INT 1
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: PPUSH
9938: CALL_OW 72
9942: ADD
9943: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9944: LD_VAR 0 2
9948: PPUSH
9949: LD_INT 5
9951: PPUSH
9952: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9956: LD_INT 5
9958: PPUSH
9959: LD_INT 1
9961: PPUSH
9962: CALL_OW 343
// k := 1 ;
9966: LD_ADDR_VAR 0 3
9970: PUSH
9971: LD_INT 1
9973: ST_TO_ADDR
// for i in tmp do
9974: LD_ADDR_VAR 0 1
9978: PUSH
9979: LD_VAR 0 2
9983: PUSH
9984: FOR_IN
9985: IFFALSE 10070
// begin if IsInUnit ( i ) then
9987: LD_VAR 0 1
9991: PPUSH
9992: CALL_OW 310
9996: IFFALSE 10007
// ComExitBuilding ( i ) ;
9998: LD_VAR 0 1
10002: PPUSH
10003: CALL_OW 122
// if GetClass ( i ) = 3 then
10007: LD_VAR 0 1
10011: PPUSH
10012: CALL_OW 257
10016: PUSH
10017: LD_INT 3
10019: EQUAL
10020: IFFALSE 10056
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
10022: LD_VAR 0 1
10026: PPUSH
10027: LD_EXP 41
10031: PUSH
10032: LD_VAR 0 3
10036: ARRAY
10037: PPUSH
10038: CALL_OW 180
// k := k + 1 ;
10042: LD_ADDR_VAR 0 3
10046: PUSH
10047: LD_VAR 0 3
10051: PUSH
10052: LD_INT 1
10054: PLUS
10055: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
10056: LD_VAR 0 1
10060: PPUSH
10061: LD_INT 10
10063: PPUSH
10064: CALL_OW 173
// end ;
10068: GO 9984
10070: POP
10071: POP
// ar_patrol := true ;
10072: LD_ADDR_EXP 7
10076: PUSH
10077: LD_INT 1
10079: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
10080: LD_INT 10
10082: PPUSH
10083: CALL_OW 67
// for i in tmp do
10087: LD_ADDR_VAR 0 1
10091: PUSH
10092: LD_VAR 0 2
10096: PUSH
10097: FOR_IN
10098: IFFALSE 10126
// if not HasTask ( i ) then
10100: LD_VAR 0 1
10104: PPUSH
10105: CALL_OW 314
10109: NOT
10110: IFFALSE 10124
// ComMoveToArea ( i , escape_area ) ;
10112: LD_VAR 0 1
10116: PPUSH
10117: LD_INT 10
10119: PPUSH
10120: CALL_OW 113
10124: GO 10097
10126: POP
10127: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
10128: LD_ADDR_VAR 0 3
10132: PUSH
10133: LD_VAR 0 2
10137: PPUSH
10138: LD_INT 95
10140: PUSH
10141: LD_INT 10
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: PPUSH
10148: CALL_OW 72
10152: ST_TO_ADDR
// if k then
10153: LD_VAR 0 3
10157: IFFALSE 10226
// for i in k do
10159: LD_ADDR_VAR 0 1
10163: PUSH
10164: LD_VAR 0 3
10168: PUSH
10169: FOR_IN
10170: IFFALSE 10224
// begin if IsInUnit ( i ) then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 310
10181: IFFALSE 10197
// RemoveUnit ( IsInUnit ( i ) ) ;
10183: LD_VAR 0 1
10187: PPUSH
10188: CALL_OW 310
10192: PPUSH
10193: CALL_OW 64
// RemoveUnit ( i ) ;
10197: LD_VAR 0 1
10201: PPUSH
10202: CALL_OW 64
// tmp := tmp diff i ;
10206: LD_ADDR_VAR 0 2
10210: PUSH
10211: LD_VAR 0 2
10215: PUSH
10216: LD_VAR 0 1
10220: DIFF
10221: ST_TO_ADDR
// end ;
10222: GO 10169
10224: POP
10225: POP
// until tmp = [ ] ;
10226: LD_VAR 0 2
10230: PUSH
10231: EMPTY
10232: EQUAL
10233: IFFALSE 10080
// ChangeSideFog ( 5 , 5 ) ;
10235: LD_INT 5
10237: PPUSH
10238: LD_INT 5
10240: PPUSH
10241: CALL_OW 343
// end ;
10245: PPOPN 3
10247: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10248: LD_EXP 7
10252: IFFALSE 10542
10254: GO 10256
10256: DISABLE
10257: LD_INT 0
10259: PPUSH
10260: PPUSH
10261: PPUSH
// begin uc_side := 2 ;
10262: LD_ADDR_OWVAR 20
10266: PUSH
10267: LD_INT 2
10269: ST_TO_ADDR
// uc_nation := 2 ;
10270: LD_ADDR_OWVAR 21
10274: PUSH
10275: LD_INT 2
10277: ST_TO_ADDR
// InitHc ;
10278: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10282: LD_INT 1
10284: PPUSH
10285: LD_INT 1
10287: PPUSH
10288: LD_INT 6
10290: PPUSH
10291: CALL_OW 380
// un := CreateHuman ;
10295: LD_ADDR_VAR 0 2
10299: PUSH
10300: CALL_OW 44
10304: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10305: LD_INT 14
10307: PPUSH
10308: LD_INT 1
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: LD_INT 27
10316: PPUSH
10317: LD_INT 98
10319: PPUSH
10320: CALL 53959 0 5
// veh := CreateVehicle ;
10324: LD_ADDR_VAR 0 3
10328: PUSH
10329: CALL_OW 45
10333: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10334: LD_VAR 0 3
10338: PPUSH
10339: LD_INT 4
10341: PPUSH
10342: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10346: LD_VAR 0 3
10350: PPUSH
10351: LD_INT 179
10353: PPUSH
10354: LD_INT 135
10356: PPUSH
10357: LD_INT 0
10359: PPUSH
10360: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10364: LD_VAR 0 2
10368: PPUSH
10369: LD_VAR 0 3
10373: PPUSH
10374: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10378: LD_VAR 0 2
10382: PPUSH
10383: LD_INT 126
10385: PPUSH
10386: LD_INT 133
10388: PPUSH
10389: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10393: LD_INT 10
10395: PPUSH
10396: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10400: LD_INT 1
10402: PPUSH
10403: LD_VAR 0 3
10407: PPUSH
10408: CALL_OW 292
10412: PUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 7
10420: PPUSH
10421: CALL_OW 296
10425: PUSH
10426: LD_INT 9
10428: LESS
10429: OR
10430: IFFALSE 10393
// ComHold ( veh ) ;
10432: LD_VAR 0 3
10436: PPUSH
10437: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10441: LD_VAR 0 2
10445: PPUSH
10446: LD_STRING D2aa-Ar1-1
10448: PPUSH
10449: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10453: LD_VAR 0 2
10457: PPUSH
10458: LD_INT 177
10460: PPUSH
10461: LD_INT 96
10463: PPUSH
10464: CALL_OW 111
// AddComExitVehicle ( un ) ;
10468: LD_VAR 0 2
10472: PPUSH
10473: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10477: LD_INT 35
10479: PPUSH
10480: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10484: LD_VAR 0 2
10488: PPUSH
10489: LD_INT 204
10491: PPUSH
10492: CALL_OW 296
10496: PUSH
10497: LD_INT 15
10499: LESS
10500: IFFALSE 10477
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10502: LD_ADDR_EXP 50
10506: PUSH
10507: LD_EXP 50
10511: PPUSH
10512: LD_INT 3
10514: PUSH
10515: LD_EXP 50
10519: PUSH
10520: LD_INT 3
10522: ARRAY
10523: PUSH
10524: LD_INT 1
10526: PLUS
10527: PUSH
10528: EMPTY
10529: LIST
10530: LIST
10531: PPUSH
10532: LD_VAR 0 2
10536: PPUSH
10537: CALL 54081 0 3
10541: ST_TO_ADDR
// end ;
10542: PPOPN 3
10544: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10545: LD_INT 7
10547: PPUSH
10548: CALL_OW 255
10552: PUSH
10553: LD_INT 1
10555: EQUAL
10556: PUSH
10557: LD_INT 7
10559: PPUSH
10560: CALL_OW 301
10564: OR
10565: IFFALSE 12970
10567: GO 10569
10569: DISABLE
10570: LD_INT 0
10572: PPUSH
10573: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10574: LD_ADDR_VAR 0 1
10578: PUSH
10579: LD_EXP 36
10583: PPUSH
10584: LD_INT 21
10586: PUSH
10587: LD_INT 3
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: PPUSH
10594: CALL_OW 72
10598: PUSH
10599: FOR_IN
10600: IFFALSE 10616
// SetSide ( i , 1 ) ;
10602: LD_VAR 0 1
10606: PPUSH
10607: LD_INT 1
10609: PPUSH
10610: CALL_OW 235
10614: GO 10599
10616: POP
10617: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10618: LD_ADDR_VAR 0 2
10622: PUSH
10623: LD_INT 46
10625: PUSH
10626: LD_INT 41
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 50
10635: PUSH
10636: LD_INT 25
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PUSH
10643: LD_INT 57
10645: PUSH
10646: LD_INT 75
10648: PUSH
10649: EMPTY
10650: LIST
10651: LIST
10652: PUSH
10653: LD_INT 75
10655: PUSH
10656: LD_INT 89
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PUSH
10663: LD_INT 51
10665: PUSH
10666: LD_INT 45
10668: PUSH
10669: EMPTY
10670: LIST
10671: LIST
10672: PUSH
10673: LD_INT 95
10675: PUSH
10676: LD_INT 95
10678: PUSH
10679: EMPTY
10680: LIST
10681: LIST
10682: PUSH
10683: LD_INT 84
10685: PUSH
10686: LD_INT 77
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: PUSH
10693: LD_INT 101
10695: PUSH
10696: LD_INT 76
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: PUSH
10703: LD_INT 118
10705: PUSH
10706: LD_INT 81
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 139
10715: PUSH
10716: LD_INT 97
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: LD_INT 129
10725: PUSH
10726: LD_INT 114
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PUSH
10733: LD_INT 154
10735: PUSH
10736: LD_INT 111
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: LIST
10750: LIST
10751: LIST
10752: LIST
10753: LIST
10754: LIST
10755: LIST
10756: ST_TO_ADDR
// base_captured := true ;
10757: LD_ADDR_EXP 6
10761: PUSH
10762: LD_INT 1
10764: ST_TO_ADDR
// DialogueOn ;
10765: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10769: LD_EXP 21
10773: PPUSH
10774: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10778: LD_EXP 21
10782: PPUSH
10783: LD_STRING D2-JMM-1
10785: PPUSH
10786: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10790: LD_EXP 30
10794: PPUSH
10795: LD_STRING D2-Pow-1
10797: PPUSH
10798: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10802: LD_EXP 21
10806: PPUSH
10807: LD_STRING D2-JMM-2
10809: PPUSH
10810: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10814: LD_EXP 30
10818: PPUSH
10819: LD_STRING D2-Pow-2
10821: PPUSH
10822: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10826: LD_EXP 21
10830: PPUSH
10831: LD_STRING D2-JMM-3
10833: PPUSH
10834: CALL_OW 88
// DialogueOff ;
10838: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10842: LD_STRING M2
10844: PPUSH
10845: CALL_OW 337
// Wait ( 0 0$2 ) ;
10849: LD_INT 70
10851: PPUSH
10852: CALL_OW 67
// if IsOk ( Gary ) then
10856: LD_EXP 32
10860: PPUSH
10861: CALL_OW 302
10865: IFFALSE 10879
// Say ( Gary , D2a-Gary-1 ) ;
10867: LD_EXP 32
10871: PPUSH
10872: LD_STRING D2a-Gary-1
10874: PPUSH
10875: CALL_OW 88
// if IsOk ( Bobby ) then
10879: LD_EXP 24
10883: PPUSH
10884: CALL_OW 302
10888: IFFALSE 10902
// Say ( Bobby , D2a-Bobby-1 ) ;
10890: LD_EXP 24
10894: PPUSH
10895: LD_STRING D2a-Bobby-1
10897: PPUSH
10898: CALL_OW 88
// if IsOk ( Cyrus ) then
10902: LD_EXP 25
10906: PPUSH
10907: CALL_OW 302
10911: IFFALSE 10925
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10913: LD_EXP 25
10917: PPUSH
10918: LD_STRING D2a-Cyrus-1
10920: PPUSH
10921: CALL_OW 88
// if IsOk ( Lisa ) then
10925: LD_EXP 22
10929: PPUSH
10930: CALL_OW 302
10934: IFFALSE 10948
// Say ( Lisa , D2a-Lisa-1 ) ;
10936: LD_EXP 22
10940: PPUSH
10941: LD_STRING D2a-Lisa-1
10943: PPUSH
10944: CALL_OW 88
// if IsOk ( Frank ) then
10948: LD_EXP 33
10952: PPUSH
10953: CALL_OW 302
10957: IFFALSE 10971
// Say ( Frank , D2a-Frank-1 ) ;
10959: LD_EXP 33
10963: PPUSH
10964: LD_STRING D2a-Frank-1
10966: PPUSH
10967: CALL_OW 88
// if IsOk ( Cornel ) then
10971: LD_EXP 31
10975: PPUSH
10976: CALL_OW 302
10980: IFFALSE 10994
// Say ( Cornel , D2a-Corn-1 ) ;
10982: LD_EXP 31
10986: PPUSH
10987: LD_STRING D2a-Corn-1
10989: PPUSH
10990: CALL_OW 88
// if IsOk ( Donaldson ) then
10994: LD_EXP 23
10998: PPUSH
10999: CALL_OW 302
11003: IFFALSE 11017
// Say ( Donaldson , D2a-Don-1 ) ;
11005: LD_EXP 23
11009: PPUSH
11010: LD_STRING D2a-Don-1
11012: PPUSH
11013: CALL_OW 88
// if IsOk ( Brown ) then
11017: LD_EXP 27
11021: PPUSH
11022: CALL_OW 302
11026: IFFALSE 11040
// Say ( Brown , D2a-Brown-1 ) ;
11028: LD_EXP 27
11032: PPUSH
11033: LD_STRING D2a-Brown-1
11035: PPUSH
11036: CALL_OW 88
// Wait ( 0 0$30 ) ;
11040: LD_INT 1050
11042: PPUSH
11043: CALL_OW 67
// if IsOk ( Frank ) then
11047: LD_EXP 33
11051: PPUSH
11052: CALL_OW 302
11056: IFFALSE 12036
// begin DialogueOn ;
11058: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
11062: LD_EXP 21
11066: PUSH
11067: LD_EXP 33
11071: PUSH
11072: EMPTY
11073: LIST
11074: LIST
11075: PPUSH
11076: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
11080: LD_EXP 33
11084: PPUSH
11085: LD_STRING D3F-Frank-1
11087: PPUSH
11088: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
11092: LD_EXP 21
11096: PPUSH
11097: LD_STRING D3F-JMM-1
11099: PPUSH
11100: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
11104: LD_EXP 33
11108: PPUSH
11109: LD_STRING D3F-Frank-2
11111: PPUSH
11112: CALL_OW 88
// case Query ( QFrank ) of 1 :
11116: LD_STRING QFrank
11118: PPUSH
11119: CALL_OW 97
11123: PUSH
11124: LD_INT 1
11126: DOUBLE
11127: EQUAL
11128: IFTRUE 11132
11130: GO 11155
11132: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
11133: LD_EXP 21
11137: PPUSH
11138: LD_STRING D3Fa-JMM-1
11140: PPUSH
11141: CALL_OW 88
// us_scout := 1 ;
11145: LD_ADDR_EXP 8
11149: PUSH
11150: LD_INT 1
11152: ST_TO_ADDR
// end ; 2 :
11153: GO 11318
11155: LD_INT 2
11157: DOUBLE
11158: EQUAL
11159: IFTRUE 11163
11161: GO 11285
11163: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
11164: LD_EXP 21
11168: PPUSH
11169: LD_STRING D3Fb-JMM-1
11171: PPUSH
11172: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
11176: LD_EXP 33
11180: PPUSH
11181: LD_STRING D3Fb-Frank-1
11183: PPUSH
11184: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
11188: LD_STRING QFrank2
11190: PPUSH
11191: CALL_OW 97
11195: PUSH
11196: LD_INT 1
11198: DOUBLE
11199: EQUAL
11200: IFTRUE 11204
11202: GO 11251
11204: POP
// begin us_scout := 2 ;
11205: LD_ADDR_EXP 8
11209: PUSH
11210: LD_INT 2
11212: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11213: LD_EXP 21
11217: PPUSH
11218: LD_STRING D3Fba-JMM-1
11220: PPUSH
11221: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11225: LD_EXP 33
11229: PPUSH
11230: LD_STRING D3Fba-Frank-1
11232: PPUSH
11233: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11237: LD_EXP 21
11241: PPUSH
11242: LD_STRING D3Fba-JMM-2
11244: PPUSH
11245: CALL_OW 88
// end ; 2 :
11249: GO 11283
11251: LD_INT 2
11253: DOUBLE
11254: EQUAL
11255: IFTRUE 11259
11257: GO 11282
11259: POP
// begin us_scout := 0 ;
11260: LD_ADDR_EXP 8
11264: PUSH
11265: LD_INT 0
11267: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11268: LD_EXP 21
11272: PPUSH
11273: LD_STRING D3Fbb-JMM-1
11275: PPUSH
11276: CALL_OW 88
// end ; end ;
11280: GO 11283
11282: POP
// end ; 3 :
11283: GO 11318
11285: LD_INT 3
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11317
11293: POP
// begin us_scout := - 1 ;
11294: LD_ADDR_EXP 8
11298: PUSH
11299: LD_INT 1
11301: NEG
11302: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11303: LD_EXP 21
11307: PPUSH
11308: LD_STRING D3Fc-JMM-1
11310: PPUSH
11311: CALL_OW 88
// end ; end ;
11315: GO 11318
11317: POP
// DialogueOff ;
11318: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11322: LD_EXP 8
11326: PUSH
11327: LD_INT 1
11329: NEG
11330: PUSH
11331: LD_INT 0
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: IN
11338: IFFALSE 11342
// exit ;
11340: GO 12970
// if us_scout in [ 1 , 2 ] then
11342: LD_EXP 8
11346: PUSH
11347: LD_INT 1
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: EMPTY
11354: LIST
11355: LIST
11356: IN
11357: IFFALSE 12036
// begin if IsInUnit ( Frank ) then
11359: LD_EXP 33
11363: PPUSH
11364: CALL_OW 310
11368: IFFALSE 11379
// ComExit ( Frank ) ;
11370: LD_EXP 33
11374: PPUSH
11375: CALL 87219 0 1
// SetSide ( Frank , 4 ) ;
11379: LD_EXP 33
11383: PPUSH
11384: LD_INT 4
11386: PPUSH
11387: CALL_OW 235
// wait ( 0 0$1 ) ;
11391: LD_INT 35
11393: PPUSH
11394: CALL_OW 67
// if us_scout = 2 then
11398: LD_EXP 8
11402: PUSH
11403: LD_INT 2
11405: EQUAL
11406: IFFALSE 11774
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11408: LD_EXP 33
11412: PPUSH
11413: LD_INT 75
11415: PPUSH
11416: LD_INT 63
11418: PPUSH
11419: CALL_OW 111
// AddComHold ( Frank ) ;
11423: LD_EXP 33
11427: PPUSH
11428: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11432: LD_EXP 33
11436: PPUSH
11437: LD_INT 770
11439: PPUSH
11440: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11444: LD_EXP 33
11448: PPUSH
11449: LD_INT 100
11451: PPUSH
11452: LD_INT 75
11454: PPUSH
11455: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11459: LD_EXP 33
11463: PPUSH
11464: LD_INT 123
11466: PPUSH
11467: LD_INT 103
11469: PPUSH
11470: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11474: LD_EXP 33
11478: PPUSH
11479: LD_INT 138
11481: PPUSH
11482: LD_INT 108
11484: PPUSH
11485: CALL_OW 171
// AddComHold ( Frank ) ;
11489: LD_EXP 33
11493: PPUSH
11494: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11498: LD_INT 35
11500: PPUSH
11501: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11505: LD_EXP 33
11509: PPUSH
11510: LD_INT 138
11512: PPUSH
11513: LD_INT 108
11515: PPUSH
11516: CALL_OW 307
11520: IFFALSE 11498
// AddComMoveXY ( Frank , 125 , 132 ) ;
11522: LD_EXP 33
11526: PPUSH
11527: LD_INT 125
11529: PPUSH
11530: LD_INT 132
11532: PPUSH
11533: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11537: LD_INT 35
11539: PPUSH
11540: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11544: LD_INT 1
11546: PPUSH
11547: LD_EXP 33
11551: PPUSH
11552: CALL_OW 292
11556: PUSH
11557: LD_EXP 33
11561: PPUSH
11562: LD_INT 7
11564: PPUSH
11565: CALL_OW 296
11569: PUSH
11570: LD_INT 7
11572: LESS
11573: OR
11574: IFFALSE 11537
// DialogueOn ;
11576: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11580: LD_EXP 33
11584: PPUSH
11585: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11589: LD_INT 10
11591: PPUSH
11592: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11596: LD_EXP 21
11600: PPUSH
11601: LD_STRING D4Fa-JMM-1
11603: PPUSH
11604: CALL_OW 88
// for i in points do
11608: LD_ADDR_VAR 0 1
11612: PUSH
11613: LD_VAR 0 2
11617: PUSH
11618: FOR_IN
11619: IFFALSE 11677
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11621: LD_VAR 0 1
11625: PUSH
11626: LD_INT 1
11628: ARRAY
11629: PPUSH
11630: LD_VAR 0 1
11634: PUSH
11635: LD_INT 2
11637: ARRAY
11638: PPUSH
11639: LD_INT 1
11641: PPUSH
11642: LD_INT 20
11644: NEG
11645: PPUSH
11646: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11650: LD_VAR 0 1
11654: PUSH
11655: LD_INT 1
11657: ARRAY
11658: PPUSH
11659: LD_VAR 0 1
11663: PUSH
11664: LD_INT 2
11666: ARRAY
11667: PPUSH
11668: LD_INT 1
11670: PPUSH
11671: CALL_OW 331
// end ;
11675: GO 11618
11677: POP
11678: POP
// dwait ( 0 0$0.5 ) ;
11679: LD_INT 18
11681: PPUSH
11682: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11686: LD_INT 42
11688: PPUSH
11689: LD_INT 27
11691: PPUSH
11692: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11696: LD_EXP 33
11700: PPUSH
11701: LD_STRING D4Fa-Frank-1
11703: PPUSH
11704: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11708: LD_INT 18
11710: PPUSH
11711: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11715: LD_EXP 21
11719: PPUSH
11720: LD_STRING D4Fa-JMM-2
11722: PPUSH
11723: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11727: LD_INT 118
11729: PPUSH
11730: LD_INT 80
11732: PPUSH
11733: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11737: LD_EXP 33
11741: PPUSH
11742: LD_STRING D4Fa-Frank-2
11744: PPUSH
11745: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11749: LD_INT 10
11751: PPUSH
11752: CALL_OW 68
// DialogueOff ;
11756: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11760: LD_EXP 33
11764: PPUSH
11765: LD_INT 1
11767: PPUSH
11768: CALL_OW 235
// end else
11772: GO 12036
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11774: LD_INT 2
11776: PPUSH
11777: LD_INT 4
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 1
11785: PPUSH
11786: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11790: LD_EXP 33
11794: PPUSH
11795: LD_INT 75
11797: PPUSH
11798: LD_INT 63
11800: PPUSH
11801: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11805: LD_EXP 33
11809: PPUSH
11810: LD_INT 175
11812: PPUSH
11813: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11817: LD_EXP 33
11821: PPUSH
11822: LD_INT 102
11824: PPUSH
11825: LD_INT 76
11827: PPUSH
11828: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11832: LD_EXP 33
11836: PPUSH
11837: LD_INT 108
11839: PPUSH
11840: LD_INT 70
11842: PPUSH
11843: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11847: LD_INT 35
11849: PPUSH
11850: CALL_OW 67
// until See ( 2 , Frank ) ;
11854: LD_INT 2
11856: PPUSH
11857: LD_EXP 33
11861: PPUSH
11862: CALL_OW 292
11866: IFFALSE 11847
// ComMoveXY ( Frank , 112 , 118 ) ;
11868: LD_EXP 33
11872: PPUSH
11873: LD_INT 112
11875: PPUSH
11876: LD_INT 118
11878: PPUSH
11879: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11883: LD_EXP 33
11887: PPUSH
11888: CALL_OW 256
11892: PUSH
11893: LD_INT 750
11895: GREATEREQUAL
11896: IFFALSE 11910
// SetLives ( Frank , 700 ) ;
11898: LD_EXP 33
11902: PPUSH
11903: LD_INT 700
11905: PPUSH
11906: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11910: LD_INT 35
11912: PPUSH
11913: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11917: LD_INT 1
11919: PPUSH
11920: LD_EXP 33
11924: PPUSH
11925: CALL_OW 292
11929: PUSH
11930: LD_EXP 33
11934: PPUSH
11935: LD_INT 7
11937: PPUSH
11938: CALL_OW 296
11942: PUSH
11943: LD_INT 17
11945: LESS
11946: OR
11947: IFFALSE 11910
// DialogueOn ;
11949: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11953: LD_EXP 33
11957: PPUSH
11958: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11962: LD_EXP 33
11966: PPUSH
11967: LD_STRING D4Fb-Frank-1
11969: PPUSH
11970: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11974: LD_EXP 21
11978: PPUSH
11979: LD_STRING D4Fb-JMM-1
11981: PPUSH
11982: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11986: LD_INT 2
11988: PPUSH
11989: LD_STRING D4Fb-FSci1-1
11991: PPUSH
11992: CALL 16961 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11996: LD_EXP 33
12000: PPUSH
12001: LD_STRING D4Fb-Frank-2
12003: PPUSH
12004: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
12008: LD_EXP 21
12012: PPUSH
12013: LD_STRING D4Fb-JMM-2
12015: PPUSH
12016: CALL_OW 88
// DialogueOff ;
12020: CALL_OW 7
// SetSide ( Frank , 1 ) ;
12024: LD_EXP 33
12028: PPUSH
12029: LD_INT 1
12031: PPUSH
12032: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
12036: LD_EXP 34
12040: PPUSH
12041: CALL_OW 302
12045: PUSH
12046: LD_EXP 33
12050: PPUSH
12051: CALL_OW 302
12055: NOT
12056: AND
12057: IFFALSE 12970
// begin DialogueOn ;
12059: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
12063: LD_EXP 21
12067: PUSH
12068: LD_EXP 34
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: PPUSH
12077: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
12081: LD_EXP 34
12085: PPUSH
12086: LD_STRING D3Y-Yam-1
12088: PPUSH
12089: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
12093: LD_EXP 21
12097: PPUSH
12098: LD_STRING D3Y-JMM-1
12100: PPUSH
12101: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
12105: LD_EXP 34
12109: PPUSH
12110: LD_STRING D3Y-Yam-2
12112: PPUSH
12113: CALL_OW 88
// case Query ( QYamoko ) of 1 :
12117: LD_STRING QYamoko
12119: PPUSH
12120: CALL_OW 97
12124: PUSH
12125: LD_INT 1
12127: DOUBLE
12128: EQUAL
12129: IFTRUE 12133
12131: GO 12168
12133: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
12134: LD_EXP 21
12138: PPUSH
12139: LD_STRING D3Ya-JMM-1
12141: PPUSH
12142: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
12146: LD_EXP 34
12150: PPUSH
12151: LD_STRING D3Ya-Yam-1
12153: PPUSH
12154: CALL_OW 88
// us_scout := 1 ;
12158: LD_ADDR_EXP 8
12162: PUSH
12163: LD_INT 1
12165: ST_TO_ADDR
// end ; 2 :
12166: GO 12201
12168: LD_INT 2
12170: DOUBLE
12171: EQUAL
12172: IFTRUE 12176
12174: GO 12200
12176: POP
// begin us_scout := - 1 ;
12177: LD_ADDR_EXP 8
12181: PUSH
12182: LD_INT 1
12184: NEG
12185: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
12186: LD_EXP 21
12190: PPUSH
12191: LD_STRING D3Yb-JMM-1
12193: PPUSH
12194: CALL_OW 88
// end ; end ;
12198: GO 12201
12200: POP
// DialogueOff ;
12201: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
12205: LD_EXP 8
12209: PUSH
12210: LD_INT 1
12212: NEG
12213: PUSH
12214: LD_INT 0
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: IN
12221: IFFALSE 12225
// exit ;
12223: GO 12970
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12225: LD_ADDR_EXP 8
12229: PUSH
12230: LD_INT 2
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 1
12238: PUSH
12239: LD_INT 1
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: PUSH
12248: LD_OWVAR 67
12252: ARRAY
12253: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12254: LD_EXP 8
12258: PUSH
12259: LD_INT 1
12261: PUSH
12262: LD_INT 2
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: IN
12269: IFFALSE 12970
// begin if IsInUnit ( Kikuchi ) then
12271: LD_EXP 34
12275: PPUSH
12276: CALL_OW 310
12280: IFFALSE 12291
// ComExitBuilding ( Kikuchi ) ;
12282: LD_EXP 34
12286: PPUSH
12287: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12291: LD_EXP 34
12295: PPUSH
12296: CALL_OW 311
12300: IFFALSE 12311
// ComExitVehicle ( Kikuchi ) ;
12302: LD_EXP 34
12306: PPUSH
12307: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12311: LD_EXP 34
12315: PPUSH
12316: LD_INT 4
12318: PPUSH
12319: CALL_OW 235
// wait ( 0 0$1 ) ;
12323: LD_INT 35
12325: PPUSH
12326: CALL_OW 67
// if us_scout = 2 then
12330: LD_EXP 8
12334: PUSH
12335: LD_INT 2
12337: EQUAL
12338: IFFALSE 12718
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12340: LD_EXP 34
12344: PPUSH
12345: LD_INT 75
12347: PPUSH
12348: LD_INT 63
12350: PPUSH
12351: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12355: LD_EXP 34
12359: PPUSH
12360: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12364: LD_EXP 34
12368: PPUSH
12369: LD_INT 770
12371: PPUSH
12372: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12376: LD_EXP 34
12380: PPUSH
12381: LD_INT 100
12383: PPUSH
12384: LD_INT 75
12386: PPUSH
12387: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12391: LD_EXP 34
12395: PPUSH
12396: LD_INT 123
12398: PPUSH
12399: LD_INT 103
12401: PPUSH
12402: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12406: LD_EXP 34
12410: PPUSH
12411: LD_INT 138
12413: PPUSH
12414: LD_INT 108
12416: PPUSH
12417: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12421: LD_EXP 34
12425: PPUSH
12426: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12430: LD_INT 35
12432: PPUSH
12433: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12437: LD_EXP 34
12441: PPUSH
12442: LD_INT 138
12444: PPUSH
12445: LD_INT 108
12447: PPUSH
12448: CALL_OW 307
12452: IFFALSE 12430
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12454: LD_EXP 34
12458: PPUSH
12459: LD_INT 125
12461: PPUSH
12462: LD_INT 132
12464: PPUSH
12465: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12469: LD_INT 35
12471: PPUSH
12472: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12476: LD_INT 1
12478: PPUSH
12479: LD_EXP 34
12483: PPUSH
12484: CALL_OW 292
12488: PUSH
12489: LD_EXP 34
12493: PPUSH
12494: LD_INT 7
12496: PPUSH
12497: CALL_OW 296
12501: PUSH
12502: LD_INT 7
12504: LESS
12505: OR
12506: IFFALSE 12469
// DialogueOn ;
12508: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12512: LD_EXP 34
12516: PPUSH
12517: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12521: LD_INT 10
12523: PPUSH
12524: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_STRING D4Ya-Yam-1
12535: PPUSH
12536: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12540: LD_EXP 21
12544: PPUSH
12545: LD_STRING D4Ya-JMM-1
12547: PPUSH
12548: CALL_OW 88
// for i in points do
12552: LD_ADDR_VAR 0 1
12556: PUSH
12557: LD_VAR 0 2
12561: PUSH
12562: FOR_IN
12563: IFFALSE 12621
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12565: LD_VAR 0 1
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 1
12578: PUSH
12579: LD_INT 2
12581: ARRAY
12582: PPUSH
12583: LD_INT 1
12585: PPUSH
12586: LD_INT 20
12588: NEG
12589: PPUSH
12590: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12594: LD_VAR 0 1
12598: PUSH
12599: LD_INT 1
12601: ARRAY
12602: PPUSH
12603: LD_VAR 0 1
12607: PUSH
12608: LD_INT 2
12610: ARRAY
12611: PPUSH
12612: LD_INT 1
12614: PPUSH
12615: CALL_OW 331
// end ;
12619: GO 12562
12621: POP
12622: POP
// dwait ( 0 0$0.5 ) ;
12623: LD_INT 18
12625: PPUSH
12626: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12630: LD_INT 42
12632: PPUSH
12633: LD_INT 27
12635: PPUSH
12636: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12640: LD_EXP 34
12644: PPUSH
12645: LD_STRING D4Ya-Yam-2
12647: PPUSH
12648: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12652: LD_INT 18
12654: PPUSH
12655: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12659: LD_INT 118
12661: PPUSH
12662: LD_INT 80
12664: PPUSH
12665: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12669: LD_EXP 21
12673: PPUSH
12674: LD_STRING D4Ya-JMM-2
12676: PPUSH
12677: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12681: LD_EXP 34
12685: PPUSH
12686: LD_STRING D4Ya-Yam-3
12688: PPUSH
12689: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12693: LD_INT 10
12695: PPUSH
12696: CALL_OW 68
// DialogueOff ;
12700: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12704: LD_EXP 34
12708: PPUSH
12709: LD_INT 1
12711: PPUSH
12712: CALL_OW 235
// end else
12716: GO 12970
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12718: LD_INT 2
12720: PPUSH
12721: LD_INT 4
12723: PPUSH
12724: LD_INT 2
12726: PPUSH
12727: LD_INT 1
12729: PPUSH
12730: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12734: LD_EXP 34
12738: PPUSH
12739: LD_INT 75
12741: PPUSH
12742: LD_INT 63
12744: PPUSH
12745: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12749: LD_EXP 34
12753: PPUSH
12754: LD_INT 175
12756: PPUSH
12757: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12761: LD_EXP 34
12765: PPUSH
12766: LD_INT 102
12768: PPUSH
12769: LD_INT 76
12771: PPUSH
12772: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12776: LD_EXP 34
12780: PPUSH
12781: LD_INT 108
12783: PPUSH
12784: LD_INT 70
12786: PPUSH
12787: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12791: LD_INT 35
12793: PPUSH
12794: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12798: LD_INT 2
12800: PPUSH
12801: LD_EXP 34
12805: PPUSH
12806: CALL_OW 292
12810: IFFALSE 12791
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12812: LD_EXP 34
12816: PPUSH
12817: LD_INT 112
12819: PPUSH
12820: LD_INT 118
12822: PPUSH
12823: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12827: LD_EXP 34
12831: PPUSH
12832: CALL_OW 256
12836: PUSH
12837: LD_INT 750
12839: GREATEREQUAL
12840: IFFALSE 12854
// SetLives ( Kikuchi , 700 ) ;
12842: LD_EXP 34
12846: PPUSH
12847: LD_INT 700
12849: PPUSH
12850: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12854: LD_INT 35
12856: PPUSH
12857: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12861: LD_INT 1
12863: PPUSH
12864: LD_EXP 34
12868: PPUSH
12869: CALL_OW 292
12873: PUSH
12874: LD_EXP 34
12878: PPUSH
12879: LD_INT 7
12881: PPUSH
12882: CALL_OW 296
12886: PUSH
12887: LD_INT 17
12889: LESS
12890: OR
12891: IFFALSE 12854
// DialogueOn ;
12893: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12897: LD_EXP 34
12901: PPUSH
12902: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12906: LD_EXP 34
12910: PPUSH
12911: LD_STRING D4Yb-Yam-1
12913: PPUSH
12914: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12918: LD_EXP 21
12922: PPUSH
12923: LD_STRING D4Yb-JMM-1
12925: PPUSH
12926: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12930: LD_EXP 34
12934: PPUSH
12935: LD_STRING D4Yb-Yam-2
12937: PPUSH
12938: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12942: LD_EXP 21
12946: PPUSH
12947: LD_STRING D4Yb-JMM-2
12949: PPUSH
12950: CALL_OW 88
// DialogueOff ;
12954: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12958: LD_EXP 34
12962: PPUSH
12963: LD_INT 1
12965: PPUSH
12966: CALL_OW 235
// end ; end ; end ; end ;
12970: PPOPN 2
12972: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12973: LD_EXP 6
12977: IFFALSE 14010
12979: GO 12981
12981: DISABLE
12982: LD_INT 0
12984: PPUSH
12985: PPUSH
12986: PPUSH
12987: PPUSH
// begin enable ;
12988: ENABLE
// if not seen [ 1 ] then
12989: LD_EXP 9
12993: PUSH
12994: LD_INT 1
12996: ARRAY
12997: NOT
12998: IFFALSE 13178
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
13000: LD_ADDR_VAR 0 2
13004: PUSH
13005: LD_INT 22
13007: PUSH
13008: LD_INT 2
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: LD_INT 2
13017: PUSH
13018: LD_INT 25
13020: PUSH
13021: LD_INT 11
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 33
13030: PUSH
13031: LD_INT 4
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: PPUSH
13047: CALL_OW 69
13051: ST_TO_ADDR
// if tmp then
13052: LD_VAR 0 2
13056: IFFALSE 13178
// for i in tmp do
13058: LD_ADDR_VAR 0 1
13062: PUSH
13063: LD_VAR 0 2
13067: PUSH
13068: FOR_IN
13069: IFFALSE 13176
// if See ( 1 , i ) then
13071: LD_INT 1
13073: PPUSH
13074: LD_VAR 0 1
13078: PPUSH
13079: CALL_OW 292
13083: IFFALSE 13174
// begin seen := Replace ( seen , 1 , true ) ;
13085: LD_ADDR_EXP 9
13089: PUSH
13090: LD_EXP 9
13094: PPUSH
13095: LD_INT 1
13097: PPUSH
13098: LD_INT 1
13100: PPUSH
13101: CALL_OW 1
13105: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13106: LD_INT 1
13108: PPUSH
13109: CALL 16783 0 1
13113: IFFALSE 13174
// begin DialogueOn ;
13115: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13119: LD_VAR 0 1
13123: PPUSH
13124: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13128: LD_INT 10
13130: PPUSH
13131: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
13135: LD_ADDR_VAR 0 3
13139: PUSH
13140: LD_INT 1
13142: PPUSH
13143: LD_STRING D5a-Sol2-1
13145: PPUSH
13146: CALL 16961 0 2
13150: ST_TO_ADDR
// if not un then
13151: LD_VAR 0 3
13155: NOT
13156: IFFALSE 13168
// SayRand ( sex_female , D5a-FSol2-1 ) ;
13158: LD_INT 2
13160: PPUSH
13161: LD_STRING D5a-FSol2-1
13163: PPUSH
13164: CALL 16961 0 2
// DialogueOff ;
13168: CALL_OW 7
// break ;
13172: GO 13176
// end ; end ;
13174: GO 13068
13176: POP
13177: POP
// end ; if not seen [ 2 ] then
13178: LD_EXP 9
13182: PUSH
13183: LD_INT 2
13185: ARRAY
13186: NOT
13187: IFFALSE 13412
// begin can_kamikazed := true ;
13189: LD_ADDR_EXP 10
13193: PUSH
13194: LD_INT 1
13196: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
13197: LD_ADDR_VAR 0 2
13201: PUSH
13202: LD_INT 22
13204: PUSH
13205: LD_INT 2
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: LD_INT 25
13214: PUSH
13215: LD_INT 17
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: PUSH
13222: EMPTY
13223: LIST
13224: LIST
13225: PPUSH
13226: CALL_OW 69
13230: ST_TO_ADDR
// if tmp then
13231: LD_VAR 0 2
13235: IFFALSE 13412
// for i in tmp do
13237: LD_ADDR_VAR 0 1
13241: PUSH
13242: LD_VAR 0 2
13246: PUSH
13247: FOR_IN
13248: IFFALSE 13410
// if See ( 1 , i ) then
13250: LD_INT 1
13252: PPUSH
13253: LD_VAR 0 1
13257: PPUSH
13258: CALL_OW 292
13262: IFFALSE 13408
// begin seen := Replace ( seen , 2 , true ) ;
13264: LD_ADDR_EXP 9
13268: PUSH
13269: LD_EXP 9
13273: PPUSH
13274: LD_INT 2
13276: PPUSH
13277: LD_INT 1
13279: PPUSH
13280: CALL_OW 1
13284: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13285: LD_INT 1
13287: PPUSH
13288: CALL 16783 0 1
13292: IFFALSE 13408
// begin DialogueOn ;
13294: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13298: LD_VAR 0 1
13302: PPUSH
13303: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13307: LD_INT 10
13309: PPUSH
13310: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13314: LD_ADDR_VAR 0 3
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_STRING D5b-Sol1-1
13324: PPUSH
13325: CALL 16961 0 2
13329: ST_TO_ADDR
// if not un then
13330: LD_VAR 0 3
13334: NOT
13335: IFFALSE 13353
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13337: LD_ADDR_VAR 0 3
13341: PUSH
13342: LD_INT 2
13344: PPUSH
13345: LD_STRING D5b-FSol1-1
13347: PPUSH
13348: CALL 16961 0 2
13352: ST_TO_ADDR
// if un then
13353: LD_VAR 0 3
13357: IFFALSE 13402
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13359: LD_ADDR_VAR 0 4
13363: PUSH
13364: LD_INT 1
13366: PPUSH
13367: LD_STRING D5b-Sol2-1
13369: PPUSH
13370: LD_VAR 0 3
13374: PPUSH
13375: CALL 17187 0 3
13379: ST_TO_ADDR
// if not un2 then
13380: LD_VAR 0 4
13384: NOT
13385: IFFALSE 13402
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13387: LD_INT 2
13389: PPUSH
13390: LD_STRING D5b-FSol2-1
13392: PPUSH
13393: LD_VAR 0 3
13397: PPUSH
13398: CALL 17187 0 3
// end ; DialogueOff ;
13402: CALL_OW 7
// break ;
13406: GO 13410
// end ; end ;
13408: GO 13247
13410: POP
13411: POP
// end ; if not seen [ 3 ] then
13412: LD_EXP 9
13416: PUSH
13417: LD_INT 3
13419: ARRAY
13420: NOT
13421: IFFALSE 13595
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: LD_INT 22
13430: PUSH
13431: LD_INT 2
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: PUSH
13438: LD_INT 33
13440: PUSH
13441: LD_INT 2
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: CALL_OW 69
13456: ST_TO_ADDR
// if tmp then
13457: LD_VAR 0 2
13461: IFFALSE 13595
// for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13593
// if See ( 1 , i ) then
13476: LD_INT 1
13478: PPUSH
13479: LD_VAR 0 1
13483: PPUSH
13484: CALL_OW 292
13488: IFFALSE 13591
// begin seen := Replace ( seen , 3 , true ) ;
13490: LD_ADDR_EXP 9
13494: PUSH
13495: LD_EXP 9
13499: PPUSH
13500: LD_INT 3
13502: PPUSH
13503: LD_INT 1
13505: PPUSH
13506: CALL_OW 1
13510: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13511: LD_INT 1
13513: PPUSH
13514: CALL 16783 0 1
13518: IFFALSE 13591
// begin DialogueOn ;
13520: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13524: LD_VAR 0 1
13528: PPUSH
13529: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13533: LD_INT 10
13535: PPUSH
13536: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13540: LD_ADDR_VAR 0 3
13544: PUSH
13545: LD_INT 1
13547: PPUSH
13548: LD_STRING D8-Sol1-1
13550: PPUSH
13551: CALL 16961 0 2
13555: ST_TO_ADDR
// if not un then
13556: LD_VAR 0 3
13560: NOT
13561: IFFALSE 13573
// SayRand ( sex_female , D8-FSol1-1 ) ;
13563: LD_INT 2
13565: PPUSH
13566: LD_STRING D8-FSol1-1
13568: PPUSH
13569: CALL 16961 0 2
// Say ( JMM , D8-JMM-1 ) ;
13573: LD_EXP 21
13577: PPUSH
13578: LD_STRING D8-JMM-1
13580: PPUSH
13581: CALL_OW 88
// DialogueOff ;
13585: CALL_OW 7
// break ;
13589: GO 13593
// end ; end ;
13591: GO 13473
13593: POP
13594: POP
// end ; if not seen [ 4 ] then
13595: LD_EXP 9
13599: PUSH
13600: LD_INT 4
13602: ARRAY
13603: NOT
13604: IFFALSE 13766
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13606: LD_ADDR_VAR 0 2
13610: PUSH
13611: LD_INT 22
13613: PUSH
13614: LD_INT 2
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 33
13623: PUSH
13624: LD_INT 5
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: EMPTY
13632: LIST
13633: LIST
13634: PPUSH
13635: CALL_OW 69
13639: ST_TO_ADDR
// if tmp then
13640: LD_VAR 0 2
13644: IFFALSE 13766
// for i in tmp do
13646: LD_ADDR_VAR 0 1
13650: PUSH
13651: LD_VAR 0 2
13655: PUSH
13656: FOR_IN
13657: IFFALSE 13764
// if See ( 1 , i ) then
13659: LD_INT 1
13661: PPUSH
13662: LD_VAR 0 1
13666: PPUSH
13667: CALL_OW 292
13671: IFFALSE 13762
// begin seen := Replace ( seen , 4 , true ) ;
13673: LD_ADDR_EXP 9
13677: PUSH
13678: LD_EXP 9
13682: PPUSH
13683: LD_INT 4
13685: PPUSH
13686: LD_INT 1
13688: PPUSH
13689: CALL_OW 1
13693: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13694: LD_INT 1
13696: PPUSH
13697: CALL 16783 0 1
13701: IFFALSE 13762
// begin DialogueOn ;
13703: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13707: LD_VAR 0 1
13711: PPUSH
13712: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13716: LD_INT 10
13718: PPUSH
13719: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13723: LD_ADDR_VAR 0 3
13727: PUSH
13728: LD_INT 1
13730: PPUSH
13731: LD_STRING D5a-Sol1-1
13733: PPUSH
13734: CALL 16961 0 2
13738: ST_TO_ADDR
// if not un then
13739: LD_VAR 0 3
13743: NOT
13744: IFFALSE 13756
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13746: LD_INT 2
13748: PPUSH
13749: LD_STRING D5a-FSol1-1
13751: PPUSH
13752: CALL 16961 0 2
// DialogueOff ;
13756: CALL_OW 7
// break ;
13760: GO 13764
// end ; end ;
13762: GO 13656
13764: POP
13765: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13766: LD_EXP 9
13770: PUSH
13771: LD_INT 5
13773: ARRAY
13774: NOT
13775: PUSH
13776: LD_EXP 9
13780: PUSH
13781: LD_INT 3
13783: ARRAY
13784: AND
13785: IFFALSE 13959
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 22
13794: PUSH
13795: LD_INT 2
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: LD_INT 34
13804: PUSH
13805: LD_INT 31
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: ST_TO_ADDR
// if tmp then
13821: LD_VAR 0 2
13825: IFFALSE 13959
// for i in tmp do
13827: LD_ADDR_VAR 0 1
13831: PUSH
13832: LD_VAR 0 2
13836: PUSH
13837: FOR_IN
13838: IFFALSE 13957
// if See ( 1 , i ) then
13840: LD_INT 1
13842: PPUSH
13843: LD_VAR 0 1
13847: PPUSH
13848: CALL_OW 292
13852: IFFALSE 13955
// begin seen := Replace ( seen , 5 , true ) ;
13854: LD_ADDR_EXP 9
13858: PUSH
13859: LD_EXP 9
13863: PPUSH
13864: LD_INT 5
13866: PPUSH
13867: LD_INT 1
13869: PPUSH
13870: CALL_OW 1
13874: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13875: LD_INT 1
13877: PPUSH
13878: CALL 16783 0 1
13882: IFFALSE 13955
// begin DialogueOn ;
13884: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13888: LD_VAR 0 1
13892: PPUSH
13893: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13897: LD_INT 10
13899: PPUSH
13900: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13904: LD_ADDR_VAR 0 3
13908: PUSH
13909: LD_INT 1
13911: PPUSH
13912: LD_STRING D8a-Sol2-1
13914: PPUSH
13915: CALL 16961 0 2
13919: ST_TO_ADDR
// if not un then
13920: LD_VAR 0 3
13924: NOT
13925: IFFALSE 13937
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13927: LD_INT 2
13929: PPUSH
13930: LD_STRING D8a-FSol2-1
13932: PPUSH
13933: CALL 16961 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13937: LD_EXP 21
13941: PPUSH
13942: LD_STRING D8a-JMM-1
13944: PPUSH
13945: CALL_OW 88
// DialogueOff ;
13949: CALL_OW 7
// break ;
13953: GO 13957
// end ; end ;
13955: GO 13837
13957: POP
13958: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13959: LD_EXP 9
13963: PUSH
13964: LD_INT 1
13966: ARRAY
13967: PUSH
13968: LD_EXP 9
13972: PUSH
13973: LD_INT 2
13975: ARRAY
13976: AND
13977: PUSH
13978: LD_EXP 9
13982: PUSH
13983: LD_INT 3
13985: ARRAY
13986: AND
13987: PUSH
13988: LD_EXP 9
13992: PUSH
13993: LD_INT 4
13995: ARRAY
13996: AND
13997: PUSH
13998: LD_EXP 9
14002: PUSH
14003: LD_INT 5
14005: ARRAY
14006: AND
14007: IFFALSE 14010
// disable ;
14009: DISABLE
// end ;
14010: PPOPN 4
14012: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
14013: LD_EXP 10
14017: PUSH
14018: LD_EXP 11
14022: AND
14023: IFFALSE 14221
14025: GO 14027
14027: DISABLE
14028: LD_INT 0
14030: PPUSH
// begin DialogueOn ;
14031: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
14035: LD_EXP 11
14039: PPUSH
14040: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
14044: LD_ADDR_VAR 0 1
14048: PUSH
14049: LD_INT 1
14051: PPUSH
14052: LD_STRING D5c-Sol1-1
14054: PPUSH
14055: CALL 16961 0 2
14059: ST_TO_ADDR
// if not un then
14060: LD_VAR 0 1
14064: NOT
14065: IFFALSE 14083
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
14067: LD_ADDR_VAR 0 1
14071: PUSH
14072: LD_INT 2
14074: PPUSH
14075: LD_STRING D5c-FSol1-1
14077: PPUSH
14078: CALL 16961 0 2
14082: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
14083: LD_EXP 21
14087: PPUSH
14088: LD_STRING D5c-JMM-1
14090: PPUSH
14091: CALL_OW 88
// if IsOk ( Lisa ) then
14095: LD_EXP 22
14099: PPUSH
14100: CALL_OW 302
14104: IFFALSE 14120
// Say ( Lisa , D5d-Lisa-1 ) else
14106: LD_EXP 22
14110: PPUSH
14111: LD_STRING D5d-Lisa-1
14113: PPUSH
14114: CALL_OW 88
14118: GO 14205
// if IsOk ( Cyrus ) then
14120: LD_EXP 25
14124: PPUSH
14125: CALL_OW 302
14129: IFFALSE 14145
// Say ( Cyrus , D5d-Cyrus-1 ) else
14131: LD_EXP 25
14135: PPUSH
14136: LD_STRING D5d-Cyrus-1
14138: PPUSH
14139: CALL_OW 88
14143: GO 14205
// if IsOk ( Gary ) then
14145: LD_EXP 32
14149: PPUSH
14150: CALL_OW 302
14154: IFFALSE 14170
// Say ( Gary , D5d-Gary-1 ) else
14156: LD_EXP 32
14160: PPUSH
14161: LD_STRING D5d-Gary-1
14163: PPUSH
14164: CALL_OW 88
14168: GO 14205
// if GetSex ( un ) = sex_male then
14170: LD_VAR 0 1
14174: PPUSH
14175: CALL_OW 258
14179: PUSH
14180: LD_INT 1
14182: EQUAL
14183: IFFALSE 14199
// Say ( un , D5d-Sol1-1 ) else
14185: LD_VAR 0 1
14189: PPUSH
14190: LD_STRING D5d-Sol1-1
14192: PPUSH
14193: CALL_OW 88
14197: GO 14205
// begin DialogueOff ;
14199: CALL_OW 7
// exit ;
14203: GO 14221
// end ; Say ( JMM , D5d-JMM-1 ) ;
14205: LD_EXP 21
14209: PPUSH
14210: LD_STRING D5d-JMM-1
14212: PPUSH
14213: CALL_OW 88
// DialogueOff ;
14217: CALL_OW 7
// end ;
14221: PPOPN 1
14223: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14224: LD_INT 1
14226: PPUSH
14227: LD_INT 17
14229: PPUSH
14230: CALL_OW 294
14234: PUSH
14235: LD_INT 2
14237: GREATEREQUAL
14238: IFFALSE 14370
14240: GO 14242
14242: DISABLE
14243: LD_INT 0
14245: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14246: LD_INT 10
14248: PPUSH
14249: LD_INT 5
14251: PPUSH
14252: LD_INT 1
14254: PPUSH
14255: LD_INT 10
14257: NEG
14258: PPUSH
14259: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14263: LD_INT 10
14265: PPUSH
14266: LD_INT 5
14268: PPUSH
14269: LD_INT 1
14271: PPUSH
14272: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14276: LD_INT 10
14278: PPUSH
14279: LD_INT 5
14281: PPUSH
14282: CALL_OW 86
// DialogueOn ;
14286: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14290: LD_ADDR_VAR 0 1
14294: PUSH
14295: LD_INT 1
14297: PPUSH
14298: LD_STRING D6-Sci1-1
14300: PPUSH
14301: CALL 16961 0 2
14305: ST_TO_ADDR
// if un then
14306: LD_VAR 0 1
14310: IFFALSE 14348
// begin Say ( JMM , D6-JMM-1 ) ;
14312: LD_EXP 21
14316: PPUSH
14317: LD_STRING D6-JMM-1
14319: PPUSH
14320: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14324: LD_VAR 0 1
14328: PPUSH
14329: LD_STRING D6-Sci1-2
14331: PPUSH
14332: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14336: LD_EXP 21
14340: PPUSH
14341: LD_STRING D6-JMM-2
14343: PPUSH
14344: CALL_OW 88
// end ; DialogueOff ;
14348: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14352: LD_STRING M3
14354: PPUSH
14355: CALL_OW 337
// wait ( 0 0$30 ) ;
14359: LD_INT 1050
14361: PPUSH
14362: CALL_OW 67
// AmericanReinforcements ;
14366: CALL 2345 0 0
// end ;
14370: PPOPN 1
14372: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14373: LD_OWVAR 1
14377: PUSH
14378: LD_INT 42000
14380: GREATEREQUAL
14381: PUSH
14382: LD_INT 2
14384: PPUSH
14385: LD_INT 169
14387: PPUSH
14388: LD_INT 90
14390: PPUSH
14391: LD_INT 10
14393: PPUSH
14394: CALL 55345 0 4
14398: PUSH
14399: LD_INT 4
14401: ARRAY
14402: PUSH
14403: LD_INT 0
14405: EQUAL
14406: PUSH
14407: LD_INT 45
14409: PPUSH
14410: CALL_OW 301
14414: OR
14415: PUSH
14416: LD_INT 45
14418: PPUSH
14419: CALL_OW 255
14423: PUSH
14424: LD_INT 1
14426: EQUAL
14427: OR
14428: AND
14429: PUSH
14430: LD_INT 94
14432: PPUSH
14433: CALL_OW 301
14437: NOT
14438: AND
14439: IFFALSE 15644
14441: GO 14443
14443: DISABLE
14444: LD_INT 0
14446: PPUSH
14447: PPUSH
14448: PPUSH
14449: PPUSH
14450: PPUSH
// begin uc_side := 5 ;
14451: LD_ADDR_OWVAR 20
14455: PUSH
14456: LD_INT 5
14458: ST_TO_ADDR
// uc_nation := 2 ;
14459: LD_ADDR_OWVAR 21
14463: PUSH
14464: LD_INT 2
14466: ST_TO_ADDR
// InitHc ;
14467: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14471: LD_INT 1
14473: PPUSH
14474: LD_INT 3
14476: PPUSH
14477: LD_INT 8
14479: PPUSH
14480: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14484: LD_ADDR_OWVAR 29
14488: PUSH
14489: LD_INT 12
14491: PUSH
14492: LD_INT 12
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: ST_TO_ADDR
// hc_name := Hans Fliege ;
14499: LD_ADDR_OWVAR 26
14503: PUSH
14504: LD_STRING Hans Fliege
14506: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14507: LD_ADDR_OWVAR 33
14511: PUSH
14512: LD_STRING SecondCharsGal
14514: ST_TO_ADDR
// hc_face_number := 7 ;
14515: LD_ADDR_OWVAR 34
14519: PUSH
14520: LD_INT 7
14522: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14523: LD_ADDR_EXP 46
14527: PUSH
14528: CALL_OW 44
14532: ST_TO_ADDR
// InitHc ;
14533: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14537: LD_INT 1
14539: PPUSH
14540: LD_INT 16
14542: PPUSH
14543: LD_INT 2
14545: PPUSH
14546: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14550: LD_ADDR_OWVAR 29
14554: PUSH
14555: LD_INT 12
14557: PUSH
14558: LD_INT 12
14560: PUSH
14561: EMPTY
14562: LIST
14563: LIST
14564: ST_TO_ADDR
// hc_name :=  ;
14565: LD_ADDR_OWVAR 26
14569: PUSH
14570: LD_STRING 
14572: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14573: LD_ADDR_EXP 47
14577: PUSH
14578: CALL_OW 44
14582: ST_TO_ADDR
// InitHc ;
14583: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14587: LD_INT 35
14589: PPUSH
14590: CALL_OW 67
// until not InBattle ( 1 ) ;
14594: LD_INT 1
14596: PPUSH
14597: CALL_OW 463
14601: NOT
14602: IFFALSE 14587
// wait ( 0 0$5 ) ;
14604: LD_INT 175
14606: PPUSH
14607: CALL_OW 67
// DialogueOn ;
14611: CALL_OW 6
// InGameOn ;
14615: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14619: LD_ADDR_VAR 0 1
14623: PUSH
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 25
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 25
14649: PUSH
14650: LD_INT 2
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: LD_INT 25
14659: PUSH
14660: LD_INT 3
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: PUSH
14667: LD_INT 25
14669: PUSH
14670: LD_INT 4
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 25
14679: PUSH
14680: LD_INT 5
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PUSH
14687: LD_INT 25
14689: PUSH
14690: LD_INT 8
14692: PUSH
14693: EMPTY
14694: LIST
14695: LIST
14696: PUSH
14697: EMPTY
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: PPUSH
14710: CALL_OW 69
14714: PUSH
14715: LD_EXP 21
14719: PUSH
14720: LD_EXP 22
14724: PUSH
14725: LD_EXP 23
14729: PUSH
14730: LD_EXP 24
14734: PUSH
14735: LD_EXP 25
14739: PUSH
14740: LD_EXP 26
14744: PUSH
14745: LD_EXP 27
14749: PUSH
14750: LD_EXP 28
14754: PUSH
14755: LD_EXP 29
14759: PUSH
14760: LD_EXP 31
14764: PUSH
14765: LD_EXP 32
14769: PUSH
14770: LD_EXP 33
14774: PUSH
14775: LD_EXP 34
14779: PUSH
14780: EMPTY
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: DIFF
14795: PPUSH
14796: LD_INT 26
14798: PUSH
14799: LD_INT 1
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: PPUSH
14806: CALL_OW 72
14810: PUSH
14811: LD_INT 1
14813: ARRAY
14814: ST_TO_ADDR
// if Brown then
14815: LD_EXP 27
14819: IFFALSE 14831
// un := Brown ;
14821: LD_ADDR_VAR 0 1
14825: PUSH
14826: LD_EXP 27
14830: ST_TO_ADDR
// if un then
14831: LD_VAR 0 1
14835: IFFALSE 14861
// begin Say ( un , D7-Sol1-1 ) ;
14837: LD_VAR 0 1
14841: PPUSH
14842: LD_STRING D7-Sol1-1
14844: PPUSH
14845: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14849: LD_EXP 21
14853: PPUSH
14854: LD_STRING D7-JMM-1
14856: PPUSH
14857: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14861: LD_EXP 46
14865: PPUSH
14866: LD_STRING D7-Ar1-1
14868: PPUSH
14869: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14873: LD_EXP 21
14877: PPUSH
14878: LD_STRING D7-JMM-2
14880: PPUSH
14881: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14885: LD_EXP 46
14889: PPUSH
14890: LD_STRING D7-Ar1-2
14892: PPUSH
14893: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14897: LD_EXP 21
14901: PPUSH
14902: LD_STRING D7-JMM-3
14904: PPUSH
14905: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14909: LD_EXP 46
14913: PPUSH
14914: LD_STRING D7-Ar1-3
14916: PPUSH
14917: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14921: LD_EXP 21
14925: PPUSH
14926: LD_STRING D7-JMM-4
14928: PPUSH
14929: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14933: LD_EXP 46
14937: PPUSH
14938: LD_STRING D7-Ar1-4
14940: PPUSH
14941: CALL_OW 94
// InGameOff ;
14945: CALL_OW 9
// DialogueOff ;
14949: CALL_OW 7
// case Query ( QCameras ) of 1 :
14953: LD_STRING QCameras
14955: PPUSH
14956: CALL_OW 97
14960: PUSH
14961: LD_INT 1
14963: DOUBLE
14964: EQUAL
14965: IFTRUE 14969
14967: GO 14972
14969: POP
// ; 2 :
14970: GO 14986
14972: LD_INT 2
14974: DOUBLE
14975: EQUAL
14976: IFTRUE 14980
14978: GO 14985
14980: POP
// exit ; end ;
14981: GO 15644
14983: GO 14986
14985: POP
// ChangeMissionObjectives ( MCar ) ;
14986: LD_STRING MCar
14988: PPUSH
14989: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14993: LD_INT 124
14995: PPUSH
14996: LD_INT 90
14998: PPUSH
14999: LD_INT 1
15001: PPUSH
15002: LD_INT 6
15004: NEG
15005: PPUSH
15006: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
15010: LD_INT 124
15012: PPUSH
15013: LD_INT 90
15015: PPUSH
15016: LD_INT 1
15018: PPUSH
15019: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
15023: LD_INT 12
15025: PPUSH
15026: LD_INT 1
15028: PPUSH
15029: CALL_OW 424
// wait ( 3 ) ;
15033: LD_INT 3
15035: PPUSH
15036: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
15040: LD_INT 124
15042: PPUSH
15043: LD_INT 90
15045: PPUSH
15046: CALL_OW 86
// cargo := false ;
15050: LD_ADDR_VAR 0 3
15054: PUSH
15055: LD_INT 0
15057: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15058: LD_INT 35
15060: PPUSH
15061: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
15065: LD_ADDR_VAR 0 3
15069: PUSH
15070: LD_INT 12
15072: PPUSH
15073: LD_INT 32
15075: PUSH
15076: LD_INT 3
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 34
15085: PUSH
15086: LD_INT 32
15088: PUSH
15089: EMPTY
15090: LIST
15091: LIST
15092: PUSH
15093: LD_INT 58
15095: PUSH
15096: EMPTY
15097: LIST
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: LIST
15103: PPUSH
15104: CALL_OW 70
15108: ST_TO_ADDR
// until cargo ;
15109: LD_VAR 0 3
15113: IFFALSE 15058
// cargo := cargo [ 1 ] ;
15115: LD_ADDR_VAR 0 3
15119: PUSH
15120: LD_VAR 0 3
15124: PUSH
15125: LD_INT 1
15127: ARRAY
15128: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
15129: LD_VAR 0 3
15133: PPUSH
15134: LD_INT 5
15136: PPUSH
15137: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
15141: LD_INT 12
15143: PPUSH
15144: LD_INT 0
15146: PPUSH
15147: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
15151: LD_EXP 46
15155: PPUSH
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 0
15161: PPUSH
15162: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
15166: LD_EXP 47
15170: PPUSH
15171: LD_INT 11
15173: PPUSH
15174: LD_INT 0
15176: PPUSH
15177: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
15181: LD_EXP 46
15185: PUSH
15186: LD_EXP 47
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PPUSH
15195: LD_INT 12
15197: PPUSH
15198: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
15202: LD_EXP 46
15206: PPUSH
15207: LD_VAR 0 3
15211: PPUSH
15212: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15216: LD_EXP 46
15220: PUSH
15221: LD_EXP 47
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: PPUSH
15230: LD_INT 209
15232: PPUSH
15233: LD_INT 178
15235: PPUSH
15236: CALL_OW 171
// escaped := 0 ;
15240: LD_ADDR_VAR 0 5
15244: PUSH
15245: LD_INT 0
15247: ST_TO_ADDR
// while ( true ) do
15248: LD_INT 1
15250: IFFALSE 15466
// begin wait ( 0 0$1 ) ;
15252: LD_INT 35
15254: PPUSH
15255: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15259: LD_EXP 46
15263: PPUSH
15264: CALL_OW 314
15268: NOT
15269: PUSH
15270: LD_EXP 47
15274: PPUSH
15275: CALL_OW 314
15279: NOT
15280: OR
15281: IFFALSE 15307
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15283: LD_EXP 46
15287: PUSH
15288: LD_EXP 47
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PPUSH
15297: LD_INT 209
15299: PPUSH
15300: LD_INT 178
15302: PPUSH
15303: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15307: LD_EXP 46
15311: PPUSH
15312: LD_INT 10
15314: PPUSH
15315: CALL_OW 308
15319: IFFALSE 15344
// begin RemoveUnit ( ar_mechanic ) ;
15321: LD_EXP 46
15325: PPUSH
15326: CALL_OW 64
// escaped := escaped + 1 ;
15330: LD_ADDR_VAR 0 5
15334: PUSH
15335: LD_VAR 0 5
15339: PUSH
15340: LD_INT 1
15342: PLUS
15343: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15344: LD_EXP 47
15348: PPUSH
15349: LD_INT 10
15351: PPUSH
15352: CALL_OW 308
15356: IFFALSE 15381
// begin RemoveUnit ( ar_mechanic_friend ) ;
15358: LD_EXP 47
15362: PPUSH
15363: CALL_OW 64
// escaped := escaped + 1 ;
15367: LD_ADDR_VAR 0 5
15371: PUSH
15372: LD_VAR 0 5
15376: PUSH
15377: LD_INT 1
15379: PLUS
15380: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15381: LD_VAR 0 3
15385: PPUSH
15386: LD_INT 10
15388: PPUSH
15389: CALL_OW 308
15393: IFFALSE 15404
// RemoveUnit ( cargo ) ;
15395: LD_VAR 0 3
15399: PPUSH
15400: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15404: LD_EXP 46
15408: PPUSH
15409: CALL_OW 305
15413: NOT
15414: PUSH
15415: LD_VAR 0 5
15419: PUSH
15420: LD_INT 2
15422: GREATEREQUAL
15423: AND
15424: IFFALSE 15428
// break ;
15426: GO 15466
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15428: LD_EXP 46
15432: PPUSH
15433: CALL_OW 305
15437: NOT
15438: PUSH
15439: LD_EXP 47
15443: PPUSH
15444: CALL_OW 305
15448: NOT
15449: AND
15450: PUSH
15451: LD_VAR 0 5
15455: PUSH
15456: LD_INT 2
15458: LESS
15459: AND
15460: IFFALSE 15464
// exit ;
15462: GO 15644
// end ;
15464: GO 15248
// wait ( 0 0$2 ) ;
15466: LD_INT 70
15468: PPUSH
15469: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15473: LD_EXP 46
15477: PPUSH
15478: LD_STRING D7a-Ar1-1
15480: PPUSH
15481: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15485: LD_ADDR_VAR 0 4
15489: PUSH
15490: LD_INT 129
15492: PUSH
15493: LD_INT 10
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: LD_INT 103
15502: PUSH
15503: LD_INT 6
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: LD_INT 148
15512: PUSH
15513: LD_INT 47
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: LD_INT 155
15522: PUSH
15523: LD_INT 16
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: ST_TO_ADDR
// if Difficulty = 1 then
15536: LD_OWVAR 67
15540: PUSH
15541: LD_INT 1
15543: EQUAL
15544: IFFALSE 15581
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15546: LD_ADDR_VAR 0 4
15550: PUSH
15551: LD_VAR 0 4
15555: PUSH
15556: LD_INT 78
15558: PUSH
15559: LD_INT 7
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: LD_INT 104
15568: PUSH
15569: LD_INT 43
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: ADD
15580: ST_TO_ADDR
// for i in tmp do
15581: LD_ADDR_VAR 0 2
15585: PUSH
15586: LD_VAR 0 4
15590: PUSH
15591: FOR_IN
15592: IFFALSE 15625
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15594: LD_VAR 0 2
15598: PUSH
15599: LD_INT 1
15601: ARRAY
15602: PPUSH
15603: LD_VAR 0 2
15607: PUSH
15608: LD_INT 2
15610: ARRAY
15611: PPUSH
15612: LD_INT 1
15614: PPUSH
15615: LD_INT 9
15617: NEG
15618: PPUSH
15619: CALL_OW 330
15623: GO 15591
15625: POP
15626: POP
// SetAchievement ( ACH_FRIEND ) ;
15627: LD_STRING ACH_FRIEND
15629: PPUSH
15630: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15634: LD_INT 129
15636: PPUSH
15637: LD_INT 10
15639: PPUSH
15640: CALL_OW 84
// end ;
15644: PPOPN 5
15646: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15647: LD_EXP 15
15651: PUSH
15652: LD_INT 21000
15654: MINUS
15655: PUSH
15656: LD_OWVAR 1
15660: LESSEQUAL
15661: IFFALSE 15701
15663: GO 15665
15665: DISABLE
// begin powell_warn := true ;
15666: LD_ADDR_EXP 16
15670: PUSH
15671: LD_INT 1
15673: ST_TO_ADDR
// DialogueOn ;
15674: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15678: LD_EXP 30
15682: PPUSH
15683: LD_STRING D9-Pow-1
15685: PPUSH
15686: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15690: LD_INT 10
15692: PPUSH
15693: CALL_OW 68
// DialogueOff ;
15697: CALL_OW 7
// end ;
15701: END
// every 0 0$1 trigger game_time <= tick do
15702: LD_EXP 15
15706: PUSH
15707: LD_OWVAR 1
15711: LESSEQUAL
15712: IFFALSE 15751
15714: GO 15716
15716: DISABLE
// begin DialogueOn ;
15717: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15721: LD_EXP 30
15725: PPUSH
15726: LD_STRING D9a-Pow-1
15728: PPUSH
15729: CALL_OW 94
// dwait ( 0 0$2 ) ;
15733: LD_INT 70
15735: PPUSH
15736: CALL_OW 68
// DialogueOff ;
15740: CALL_OW 7
// YouLost ( Command ) ;
15744: LD_STRING Command
15746: PPUSH
15747: CALL_OW 104
// end ;
15751: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15752: LD_INT 22
15754: PUSH
15755: LD_INT 2
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 30
15764: PUSH
15765: LD_INT 1
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PPUSH
15776: CALL_OW 69
15780: PUSH
15781: LD_INT 0
15783: EQUAL
15784: PUSH
15785: LD_EXP 21
15789: PPUSH
15790: CALL_OW 302
15794: AND
15795: IFFALSE 15843
15797: GO 15799
15799: DISABLE
// begin case Query ( QEndMission ) of 1 :
15800: LD_STRING QEndMission
15802: PPUSH
15803: CALL_OW 97
15807: PUSH
15808: LD_INT 1
15810: DOUBLE
15811: EQUAL
15812: IFTRUE 15816
15814: GO 15827
15816: POP
// end_the_mission_allowed := true ; 2 :
15817: LD_ADDR_OWVAR 57
15821: PUSH
15822: LD_INT 1
15824: ST_TO_ADDR
15825: GO 15843
15827: LD_INT 2
15829: DOUBLE
15830: EQUAL
15831: IFTRUE 15835
15833: GO 15842
15835: POP
// EndMission ; end ;
15836: CALL 15865 0 0
15840: GO 15843
15842: POP
// end ;
15843: END
// on EndTheMissionRaised ( p ) do begin if end_the_mission_allowed then
15844: LD_OWVAR 57
15848: IFFALSE 15862
// begin end_the_mission_allowed := false ;
15850: LD_ADDR_OWVAR 57
15854: PUSH
15855: LD_INT 0
15857: ST_TO_ADDR
// EndMission ;
15858: CALL 15865 0 0
// end ; end ;
15862: PPOPN 1
15864: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15865: LD_INT 0
15867: PPUSH
15868: PPUSH
15869: PPUSH
15870: PPUSH
15871: PPUSH
// m1 := false ;
15872: LD_ADDR_VAR 0 3
15876: PUSH
15877: LD_INT 0
15879: ST_TO_ADDR
// m2 := false ;
15880: LD_ADDR_VAR 0 4
15884: PUSH
15885: LD_INT 0
15887: ST_TO_ADDR
// m3 := false ;
15888: LD_ADDR_VAR 0 5
15892: PUSH
15893: LD_INT 0
15895: ST_TO_ADDR
// if not am_veh_consturcted then
15896: LD_EXP 20
15900: NOT
15901: IFFALSE 15910
// SetAchievement ( ACH_ARABTECH ) ;
15903: LD_STRING ACH_ARABTECH
15905: PPUSH
15906: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15910: LD_OWVAR 1
15914: PUSH
15915: LD_INT 252000
15917: PUSH
15918: LD_INT 210000
15920: PUSH
15921: LD_INT 199500
15923: PUSH
15924: LD_INT 193200
15926: PUSH
15927: EMPTY
15928: LIST
15929: LIST
15930: LIST
15931: LIST
15932: PUSH
15933: LD_OWVAR 67
15937: ARRAY
15938: LESS
15939: IFFALSE 15961
// begin m3 := true ;
15941: LD_ADDR_VAR 0 5
15945: PUSH
15946: LD_INT 1
15948: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15949: LD_STRING Time1
15951: PPUSH
15952: LD_INT 1
15954: PPUSH
15955: CALL_OW 101
// end else
15959: GO 15992
// if not powell_warn then
15961: LD_EXP 16
15965: NOT
15966: IFFALSE 15981
// AddMedal ( Time1 , - 1 ) else
15968: LD_STRING Time1
15970: PPUSH
15971: LD_INT 1
15973: NEG
15974: PPUSH
15975: CALL_OW 101
15979: GO 15992
// AddMedal ( Time1 , - 2 ) ;
15981: LD_STRING Time1
15983: PPUSH
15984: LD_INT 2
15986: NEG
15987: PPUSH
15988: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15992: LD_EXP 17
15996: PUSH
15997: LD_INT 5
15999: PUSH
16000: LD_INT 4
16002: PUSH
16003: LD_INT 3
16005: PUSH
16006: LD_INT 3
16008: PUSH
16009: EMPTY
16010: LIST
16011: LIST
16012: LIST
16013: LIST
16014: PUSH
16015: LD_OWVAR 67
16019: ARRAY
16020: GREATEREQUAL
16021: IFFALSE 16036
// AddMedal ( Destroy , - 2 ) else
16023: LD_STRING Destroy
16025: PPUSH
16026: LD_INT 2
16028: NEG
16029: PPUSH
16030: CALL_OW 101
16034: GO 16169
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
16036: LD_INT 22
16038: PUSH
16039: LD_INT 2
16041: PUSH
16042: EMPTY
16043: LIST
16044: LIST
16045: PUSH
16046: LD_INT 21
16048: PUSH
16049: LD_INT 3
16051: PUSH
16052: EMPTY
16053: LIST
16054: LIST
16055: PUSH
16056: LD_INT 50
16058: PUSH
16059: EMPTY
16060: LIST
16061: PUSH
16062: EMPTY
16063: LIST
16064: LIST
16065: LIST
16066: PPUSH
16067: CALL_OW 69
16071: PUSH
16072: LD_INT 25
16074: GREATEREQUAL
16075: IFFALSE 16090
// AddMedal ( Destroy , - 1 ) else
16077: LD_STRING Destroy
16079: PPUSH
16080: LD_INT 1
16082: NEG
16083: PPUSH
16084: CALL_OW 101
16088: GO 16169
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
16090: LD_INT 22
16092: PUSH
16093: LD_INT 2
16095: PUSH
16096: EMPTY
16097: LIST
16098: LIST
16099: PUSH
16100: LD_INT 21
16102: PUSH
16103: LD_INT 3
16105: PUSH
16106: EMPTY
16107: LIST
16108: LIST
16109: PUSH
16110: LD_INT 50
16112: PUSH
16113: EMPTY
16114: LIST
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: LIST
16120: PPUSH
16121: CALL_OW 69
16125: PUSH
16126: LD_INT 15
16128: GREATEREQUAL
16129: IFFALSE 16151
// begin m1 := true ;
16131: LD_ADDR_VAR 0 3
16135: PUSH
16136: LD_INT 1
16138: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
16139: LD_STRING Destroy
16141: PPUSH
16142: LD_INT 1
16144: PPUSH
16145: CALL_OW 101
// end else
16149: GO 16169
// begin m1 := true ;
16151: LD_ADDR_VAR 0 3
16155: PUSH
16156: LD_INT 1
16158: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
16159: LD_STRING Destroy
16161: PPUSH
16162: LD_INT 2
16164: PPUSH
16165: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
16169: LD_EXP 13
16173: PPUSH
16174: LD_STRING 11_artifact_captured
16176: PPUSH
16177: CALL_OW 39
// if artifact_get then
16181: LD_EXP 13
16185: IFFALSE 16207
// begin m2 := true ;
16187: LD_ADDR_VAR 0 4
16191: PUSH
16192: LD_INT 1
16194: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
16195: LD_STRING Artefact
16197: PPUSH
16198: LD_INT 1
16200: PPUSH
16201: CALL_OW 101
// end else
16205: GO 16218
// AddMedal ( Artefact , - 1 ) ;
16207: LD_STRING Artefact
16209: PPUSH
16210: LD_INT 1
16212: NEG
16213: PPUSH
16214: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
16218: LD_VAR 0 3
16222: PUSH
16223: LD_VAR 0 4
16227: AND
16228: PUSH
16229: LD_VAR 0 5
16233: AND
16234: PUSH
16235: LD_OWVAR 67
16239: PUSH
16240: LD_INT 3
16242: GREATEREQUAL
16243: AND
16244: IFFALSE 16256
// SetAchievementEX ( ACH_AMER , 11 ) ;
16246: LD_STRING ACH_AMER
16248: PPUSH
16249: LD_INT 11
16251: PPUSH
16252: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16256: LD_VAR 0 3
16260: PUSH
16261: LD_VAR 0 4
16265: AND
16266: PUSH
16267: LD_VAR 0 5
16271: AND
16272: PUSH
16273: LD_EXP 17
16277: PUSH
16278: LD_INT 0
16280: EQUAL
16281: AND
16282: IFFALSE 16298
// begin wait ( 3 ) ;
16284: LD_INT 3
16286: PPUSH
16287: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16291: LD_STRING ACH_GENERAL
16293: PPUSH
16294: CALL_OW 543
// end ; if tick <= 100 100$00 then
16298: LD_OWVAR 1
16302: PUSH
16303: LD_INT 210000
16305: LESSEQUAL
16306: IFFALSE 16322
// begin wait ( 3 ) ;
16308: LD_INT 3
16310: PPUSH
16311: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16315: LD_STRING ACH_ASPEED_11
16317: PPUSH
16318: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16322: LD_STRING MAIN
16324: PPUSH
16325: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16329: LD_ADDR_EXP 19
16333: PUSH
16334: LD_EXP 19
16338: PPUSH
16339: LD_INT 51
16341: PUSH
16342: EMPTY
16343: LIST
16344: PPUSH
16345: CALL_OW 72
16349: ST_TO_ADDR
// tmp := JMM ^ selected ;
16350: LD_ADDR_VAR 0 2
16354: PUSH
16355: LD_EXP 21
16359: PUSH
16360: LD_EXP 19
16364: ADD
16365: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16366: LD_VAR 0 2
16370: PPUSH
16371: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16375: LD_VAR 0 2
16379: PUSH
16380: LD_EXP 21
16384: PUSH
16385: LD_EXP 22
16389: PUSH
16390: LD_EXP 23
16394: PUSH
16395: LD_EXP 24
16399: PUSH
16400: LD_EXP 25
16404: PUSH
16405: LD_EXP 26
16409: PUSH
16410: LD_EXP 27
16414: PUSH
16415: LD_EXP 28
16419: PUSH
16420: LD_EXP 29
16424: PUSH
16425: LD_EXP 31
16429: PUSH
16430: LD_EXP 32
16434: PUSH
16435: LD_EXP 33
16439: PUSH
16440: LD_EXP 34
16444: PUSH
16445: EMPTY
16446: LIST
16447: LIST
16448: LIST
16449: LIST
16450: LIST
16451: LIST
16452: LIST
16453: LIST
16454: LIST
16455: LIST
16456: LIST
16457: LIST
16458: LIST
16459: DIFF
16460: PPUSH
16461: LD_STRING 11c_others
16463: PPUSH
16464: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16468: LD_EXP 21
16472: PPUSH
16473: LD_EXP 3
16477: PUSH
16478: LD_STRING JMM
16480: STR
16481: PPUSH
16482: CALL_OW 38
// if Lisa then
16486: LD_EXP 22
16490: IFFALSE 16510
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16492: LD_EXP 22
16496: PPUSH
16497: LD_EXP 3
16501: PUSH
16502: LD_STRING Lisa
16504: STR
16505: PPUSH
16506: CALL_OW 38
// if Donaldson then
16510: LD_EXP 23
16514: IFFALSE 16534
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16516: LD_EXP 23
16520: PPUSH
16521: LD_EXP 3
16525: PUSH
16526: LD_STRING Donaldson
16528: STR
16529: PPUSH
16530: CALL_OW 38
// if Bobby then
16534: LD_EXP 24
16538: IFFALSE 16558
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16540: LD_EXP 24
16544: PPUSH
16545: LD_EXP 3
16549: PUSH
16550: LD_STRING Bobby
16552: STR
16553: PPUSH
16554: CALL_OW 38
// if Cyrus then
16558: LD_EXP 25
16562: IFFALSE 16582
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16564: LD_EXP 25
16568: PPUSH
16569: LD_EXP 3
16573: PUSH
16574: LD_STRING Cyrus
16576: STR
16577: PPUSH
16578: CALL_OW 38
// if Denis then
16582: LD_EXP 26
16586: IFFALSE 16606
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16588: LD_EXP 26
16592: PPUSH
16593: LD_EXP 3
16597: PUSH
16598: LD_STRING Denis
16600: STR
16601: PPUSH
16602: CALL_OW 38
// if Brown then
16606: LD_EXP 27
16610: IFFALSE 16630
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16612: LD_EXP 27
16616: PPUSH
16617: LD_EXP 3
16621: PUSH
16622: LD_STRING Brown
16624: STR
16625: PPUSH
16626: CALL_OW 38
// if Gladstone then
16630: LD_EXP 28
16634: IFFALSE 16654
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16636: LD_EXP 28
16640: PPUSH
16641: LD_EXP 3
16645: PUSH
16646: LD_STRING Gladstone
16648: STR
16649: PPUSH
16650: CALL_OW 38
// if Houten then
16654: LD_EXP 29
16658: IFFALSE 16678
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16660: LD_EXP 29
16664: PPUSH
16665: LD_EXP 3
16669: PUSH
16670: LD_STRING Houten
16672: STR
16673: PPUSH
16674: CALL_OW 38
// if Cornel then
16678: LD_EXP 31
16682: IFFALSE 16702
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16684: LD_EXP 31
16688: PPUSH
16689: LD_EXP 3
16693: PUSH
16694: LD_STRING Cornell
16696: STR
16697: PPUSH
16698: CALL_OW 38
// if Gary then
16702: LD_EXP 32
16706: IFFALSE 16726
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16708: LD_EXP 32
16712: PPUSH
16713: LD_EXP 3
16717: PUSH
16718: LD_STRING Gary
16720: STR
16721: PPUSH
16722: CALL_OW 38
// if Frank then
16726: LD_EXP 33
16730: IFFALSE 16750
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16732: LD_EXP 33
16736: PPUSH
16737: LD_EXP 3
16741: PUSH
16742: LD_STRING Frank
16744: STR
16745: PPUSH
16746: CALL_OW 38
// if Kikuchi then
16750: LD_EXP 34
16754: IFFALSE 16774
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16756: LD_EXP 34
16760: PPUSH
16761: LD_EXP 3
16765: PUSH
16766: LD_STRING Kikuchi
16768: STR
16769: PPUSH
16770: CALL_OW 38
// YouWin ;
16774: CALL_OW 103
// end ;
16778: LD_VAR 0 1
16782: RET
// export function CanSayRand ( side ) ; begin
16783: LD_INT 0
16785: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16786: LD_ADDR_VAR 0 2
16790: PUSH
16791: LD_INT 52
16793: PUSH
16794: EMPTY
16795: LIST
16796: PUSH
16797: LD_INT 22
16799: PUSH
16800: LD_VAR 0 1
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: PUSH
16809: LD_INT 2
16811: PUSH
16812: LD_INT 25
16814: PUSH
16815: LD_INT 1
16817: PUSH
16818: EMPTY
16819: LIST
16820: LIST
16821: PUSH
16822: LD_INT 25
16824: PUSH
16825: LD_INT 2
16827: PUSH
16828: EMPTY
16829: LIST
16830: LIST
16831: PUSH
16832: LD_INT 25
16834: PUSH
16835: LD_INT 3
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: PUSH
16842: LD_INT 25
16844: PUSH
16845: LD_INT 4
16847: PUSH
16848: EMPTY
16849: LIST
16850: LIST
16851: PUSH
16852: EMPTY
16853: LIST
16854: LIST
16855: LIST
16856: LIST
16857: LIST
16858: PUSH
16859: EMPTY
16860: LIST
16861: LIST
16862: LIST
16863: PPUSH
16864: CALL_OW 69
16868: PUSH
16869: LD_EXP 21
16873: PUSH
16874: LD_EXP 33
16878: PUSH
16879: LD_EXP 22
16883: PUSH
16884: LD_EXP 23
16888: PUSH
16889: LD_EXP 24
16893: PUSH
16894: LD_EXP 25
16898: PUSH
16899: LD_EXP 26
16903: PUSH
16904: LD_EXP 27
16908: PUSH
16909: LD_EXP 28
16913: PUSH
16914: LD_EXP 29
16918: PUSH
16919: LD_EXP 30
16923: PUSH
16924: LD_EXP 31
16928: PUSH
16929: LD_EXP 32
16933: PUSH
16934: LD_EXP 34
16938: PUSH
16939: EMPTY
16940: LIST
16941: LIST
16942: LIST
16943: LIST
16944: LIST
16945: LIST
16946: LIST
16947: LIST
16948: LIST
16949: LIST
16950: LIST
16951: LIST
16952: LIST
16953: LIST
16954: DIFF
16955: ST_TO_ADDR
// end ;
16956: LD_VAR 0 2
16960: RET
// export function SayRand ( sex , dial ) ; begin
16961: LD_INT 0
16963: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16964: LD_ADDR_VAR 0 3
16968: PUSH
16969: LD_INT 52
16971: PUSH
16972: EMPTY
16973: LIST
16974: PUSH
16975: LD_INT 22
16977: PUSH
16978: LD_INT 1
16980: PUSH
16981: EMPTY
16982: LIST
16983: LIST
16984: PUSH
16985: LD_INT 26
16987: PUSH
16988: LD_VAR 0 1
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: PUSH
16997: LD_INT 2
16999: PUSH
17000: LD_INT 25
17002: PUSH
17003: LD_INT 1
17005: PUSH
17006: EMPTY
17007: LIST
17008: LIST
17009: PUSH
17010: LD_INT 25
17012: PUSH
17013: LD_INT 2
17015: PUSH
17016: EMPTY
17017: LIST
17018: LIST
17019: PUSH
17020: LD_INT 25
17022: PUSH
17023: LD_INT 3
17025: PUSH
17026: EMPTY
17027: LIST
17028: LIST
17029: PUSH
17030: LD_INT 25
17032: PUSH
17033: LD_INT 4
17035: PUSH
17036: EMPTY
17037: LIST
17038: LIST
17039: PUSH
17040: EMPTY
17041: LIST
17042: LIST
17043: LIST
17044: LIST
17045: LIST
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: LIST
17051: LIST
17052: PPUSH
17053: CALL_OW 69
17057: PUSH
17058: LD_EXP 21
17062: PUSH
17063: LD_EXP 33
17067: PUSH
17068: LD_EXP 22
17072: PUSH
17073: LD_EXP 23
17077: PUSH
17078: LD_EXP 24
17082: PUSH
17083: LD_EXP 25
17087: PUSH
17088: LD_EXP 26
17092: PUSH
17093: LD_EXP 27
17097: PUSH
17098: LD_EXP 28
17102: PUSH
17103: LD_EXP 29
17107: PUSH
17108: LD_EXP 30
17112: PUSH
17113: LD_EXP 31
17117: PUSH
17118: LD_EXP 32
17122: PUSH
17123: LD_EXP 34
17127: PUSH
17128: EMPTY
17129: LIST
17130: LIST
17131: LIST
17132: LIST
17133: LIST
17134: LIST
17135: LIST
17136: LIST
17137: LIST
17138: LIST
17139: LIST
17140: LIST
17141: LIST
17142: LIST
17143: DIFF
17144: ST_TO_ADDR
// if not result then
17145: LD_VAR 0 3
17149: NOT
17150: IFFALSE 17154
// exit ;
17152: GO 17182
// result := result [ 1 ] ;
17154: LD_ADDR_VAR 0 3
17158: PUSH
17159: LD_VAR 0 3
17163: PUSH
17164: LD_INT 1
17166: ARRAY
17167: ST_TO_ADDR
// Say ( result , dial ) ;
17168: LD_VAR 0 3
17172: PPUSH
17173: LD_VAR 0 2
17177: PPUSH
17178: CALL_OW 88
// end ;
17182: LD_VAR 0 3
17186: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
17187: LD_INT 0
17189: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
17190: LD_ADDR_VAR 0 4
17194: PUSH
17195: LD_INT 22
17197: PUSH
17198: LD_INT 1
17200: PUSH
17201: EMPTY
17202: LIST
17203: LIST
17204: PUSH
17205: LD_INT 26
17207: PUSH
17208: LD_VAR 0 1
17212: PUSH
17213: EMPTY
17214: LIST
17215: LIST
17216: PUSH
17217: LD_INT 2
17219: PUSH
17220: LD_INT 25
17222: PUSH
17223: LD_INT 1
17225: PUSH
17226: EMPTY
17227: LIST
17228: LIST
17229: PUSH
17230: LD_INT 25
17232: PUSH
17233: LD_INT 2
17235: PUSH
17236: EMPTY
17237: LIST
17238: LIST
17239: PUSH
17240: LD_INT 25
17242: PUSH
17243: LD_INT 3
17245: PUSH
17246: EMPTY
17247: LIST
17248: LIST
17249: PUSH
17250: LD_INT 25
17252: PUSH
17253: LD_INT 4
17255: PUSH
17256: EMPTY
17257: LIST
17258: LIST
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: LIST
17264: LIST
17265: LIST
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: LIST
17271: PPUSH
17272: CALL_OW 69
17276: PUSH
17277: LD_EXP 21
17281: PUSH
17282: LD_EXP 33
17286: PUSH
17287: LD_EXP 22
17291: PUSH
17292: LD_EXP 23
17296: PUSH
17297: LD_EXP 24
17301: PUSH
17302: LD_EXP 25
17306: PUSH
17307: LD_EXP 26
17311: PUSH
17312: LD_EXP 27
17316: PUSH
17317: LD_EXP 28
17321: PUSH
17322: LD_EXP 29
17326: PUSH
17327: LD_EXP 30
17331: PUSH
17332: LD_EXP 31
17336: PUSH
17337: LD_EXP 32
17341: PUSH
17342: LD_EXP 34
17346: PUSH
17347: EMPTY
17348: LIST
17349: LIST
17350: LIST
17351: LIST
17352: LIST
17353: LIST
17354: LIST
17355: LIST
17356: LIST
17357: LIST
17358: LIST
17359: LIST
17360: LIST
17361: LIST
17362: PUSH
17363: LD_VAR 0 3
17367: ADD
17368: DIFF
17369: ST_TO_ADDR
// if not result then
17370: LD_VAR 0 4
17374: NOT
17375: IFFALSE 17379
// exit ;
17377: GO 17407
// result := result [ 1 ] ;
17379: LD_ADDR_VAR 0 4
17383: PUSH
17384: LD_VAR 0 4
17388: PUSH
17389: LD_INT 1
17391: ARRAY
17392: ST_TO_ADDR
// Say ( result , dial ) ;
17393: LD_VAR 0 4
17397: PPUSH
17398: LD_VAR 0 2
17402: PPUSH
17403: CALL_OW 88
// end ; end_of_file
17407: LD_VAR 0 4
17411: RET
// export function CustomEvent ( event ) ; begin
17412: LD_INT 0
17414: PPUSH
// end ;
17415: LD_VAR 0 2
17419: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17420: LD_VAR 0 1
17424: PPUSH
17425: CALL_OW 255
17429: PUSH
17430: LD_INT 1
17432: EQUAL
17433: IFFALSE 17443
// artifact_get := true ;
17435: LD_ADDR_EXP 13
17439: PUSH
17440: LD_INT 1
17442: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17443: LD_VAR 0 1
17447: PPUSH
17448: CALL_OW 255
17452: PUSH
17453: LD_INT 2
17455: EQUAL
17456: IFFALSE 17474
// begin artifact_get := false ;
17458: LD_ADDR_EXP 13
17462: PUSH
17463: LD_INT 0
17465: ST_TO_ADDR
// artifact_stolen := true ;
17466: LD_ADDR_EXP 12
17470: PUSH
17471: LD_INT 1
17473: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17474: LD_ADDR_EXP 14
17478: PUSH
17479: LD_INT 1
17481: ST_TO_ADDR
// end ;
17482: PPOPN 2
17484: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17485: LD_ADDR_EXP 14
17489: PUSH
17490: LD_INT 0
17492: ST_TO_ADDR
// end ;
17493: PPOPN 2
17495: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17496: LD_VAR 0 1
17500: PPUSH
17501: CALL 107153 0 1
// if un = JMM then
17505: LD_VAR 0 1
17509: PUSH
17510: LD_EXP 21
17514: EQUAL
17515: IFFALSE 17526
// begin YouLost ( JMM ) ;
17517: LD_STRING JMM
17519: PPUSH
17520: CALL_OW 104
// exit ;
17524: GO 17658
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17526: LD_VAR 0 1
17530: PUSH
17531: LD_INT 22
17533: PUSH
17534: LD_INT 1
17536: PUSH
17537: EMPTY
17538: LIST
17539: LIST
17540: PUSH
17541: LD_INT 21
17543: PUSH
17544: LD_INT 1
17546: PUSH
17547: EMPTY
17548: LIST
17549: LIST
17550: PUSH
17551: LD_INT 2
17553: PUSH
17554: LD_INT 25
17556: PUSH
17557: LD_INT 1
17559: PUSH
17560: EMPTY
17561: LIST
17562: LIST
17563: PUSH
17564: LD_INT 25
17566: PUSH
17567: LD_INT 2
17569: PUSH
17570: EMPTY
17571: LIST
17572: LIST
17573: PUSH
17574: LD_INT 25
17576: PUSH
17577: LD_INT 3
17579: PUSH
17580: EMPTY
17581: LIST
17582: LIST
17583: PUSH
17584: LD_INT 25
17586: PUSH
17587: LD_INT 4
17589: PUSH
17590: EMPTY
17591: LIST
17592: LIST
17593: PUSH
17594: LD_INT 25
17596: PUSH
17597: LD_INT 5
17599: PUSH
17600: EMPTY
17601: LIST
17602: LIST
17603: PUSH
17604: LD_INT 25
17606: PUSH
17607: LD_INT 8
17609: PUSH
17610: EMPTY
17611: LIST
17612: LIST
17613: PUSH
17614: EMPTY
17615: LIST
17616: LIST
17617: LIST
17618: LIST
17619: LIST
17620: LIST
17621: LIST
17622: PUSH
17623: EMPTY
17624: LIST
17625: LIST
17626: LIST
17627: PPUSH
17628: CALL_OW 69
17632: IN
17633: IFFALSE 17649
// loses_counter := loses_counter + 1 ;
17635: LD_ADDR_EXP 17
17639: PUSH
17640: LD_EXP 17
17644: PUSH
17645: LD_INT 1
17647: PLUS
17648: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17649: LD_VAR 0 1
17653: PPUSH
17654: CALL 46135 0 1
// end ;
17658: PPOPN 1
17660: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17661: LD_VAR 0 1
17665: PPUSH
17666: LD_VAR 0 2
17670: PPUSH
17671: CALL 48467 0 2
// end ;
17675: PPOPN 2
17677: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17678: LD_VAR 0 1
17682: PPUSH
17683: CALL 47776 0 1
// end ;
17687: PPOPN 1
17689: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17690: LD_VAR 0 1
17694: PPUSH
17695: LD_VAR 0 2
17699: PPUSH
17700: LD_VAR 0 3
17704: PPUSH
17705: LD_VAR 0 4
17709: PPUSH
17710: LD_VAR 0 5
17714: PPUSH
17715: CALL 45451 0 5
// end ;
17719: PPOPN 5
17721: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17722: LD_VAR 0 1
17726: PPUSH
17727: LD_VAR 0 2
17731: PPUSH
17732: CALL 107273 0 2
// if GetNation ( vehicle ) = nation_american then
17736: LD_VAR 0 1
17740: PPUSH
17741: CALL_OW 248
17745: PUSH
17746: LD_INT 1
17748: EQUAL
17749: IFFALSE 17759
// am_veh_consturcted := true ;
17751: LD_ADDR_EXP 20
17755: PUSH
17756: LD_INT 1
17758: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17759: LD_VAR 0 1
17763: PPUSH
17764: LD_VAR 0 2
17768: PPUSH
17769: CALL 45004 0 2
// end ;
17773: PPOPN 2
17775: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17776: LD_VAR 0 1
17780: PPUSH
17781: CALL_OW 247
17785: PUSH
17786: LD_INT 2
17788: EQUAL
17789: IFFALSE 17793
// exit ;
17791: GO 17810
// if not kamikazed then
17793: LD_EXP 11
17797: NOT
17798: IFFALSE 17810
// kamikazed := unit ;
17800: LD_ADDR_EXP 11
17804: PUSH
17805: LD_VAR 0 1
17809: ST_TO_ADDR
// end ;
17810: PPOPN 1
17812: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17813: LD_INT 0
17815: PPUSH
17816: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17817: LD_VAR 0 1
17821: PPUSH
17822: LD_VAR 0 2
17826: PPUSH
17827: LD_VAR 0 3
17831: PPUSH
17832: LD_VAR 0 4
17836: PPUSH
17837: CALL 44842 0 4
// end ;
17841: PPOPN 6
17843: END
// on BuildingCaptured ( building , side , capturning_unit ) do var i ;
17844: LD_INT 0
17846: PPUSH
// begin if building = ar_dep_n then
17847: LD_VAR 0 1
17851: PUSH
17852: LD_INT 94
17854: EQUAL
17855: IFFALSE 17907
// begin for i := 1 to 3 do
17857: LD_ADDR_VAR 0 4
17861: PUSH
17862: DOUBLE
17863: LD_INT 1
17865: DEC
17866: ST_TO_ADDR
17867: LD_INT 3
17869: PUSH
17870: FOR_TO
17871: IFFALSE 17905
// begin MineExplosion ( 115 + ( i * 2 ) , 6 , 1 ) ;
17873: LD_INT 115
17875: PUSH
17876: LD_VAR 0 4
17880: PUSH
17881: LD_INT 2
17883: MUL
17884: PLUS
17885: PPUSH
17886: LD_INT 6
17888: PPUSH
17889: LD_INT 1
17891: PPUSH
17892: CALL_OW 453
// wait ( 0 0$0.3 ) ;
17896: LD_INT 10
17898: PPUSH
17899: CALL_OW 67
// end ;
17903: GO 17870
17905: POP
17906: POP
// end ; MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17907: LD_VAR 0 1
17911: PPUSH
17912: LD_VAR 0 2
17916: PPUSH
17917: LD_VAR 0 3
17921: PPUSH
17922: CALL 44617 0 3
// end ;
17926: PPOPN 4
17928: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17929: LD_VAR 0 1
17933: PPUSH
17934: LD_VAR 0 2
17938: PPUSH
17939: CALL 45831 0 2
// end ;
17943: PPOPN 2
17945: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17946: LD_VAR 0 1
17950: PPUSH
17951: LD_VAR 0 2
17955: PPUSH
17956: CALL 44311 0 2
// end ;
17960: PPOPN 2
17962: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17963: LD_VAR 0 1
17967: PPUSH
17968: LD_VAR 0 2
17972: PPUSH
17973: CALL 44502 0 2
// end ;
17977: PPOPN 2
17979: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17980: LD_VAR 0 1
17984: PPUSH
17985: CALL 47535 0 1
// end ;
17989: PPOPN 1
17991: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17992: LD_VAR 0 1
17996: PPUSH
17997: LD_VAR 0 2
18001: PPUSH
18002: CALL 48762 0 2
// end ;
18006: PPOPN 2
18008: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
18009: LD_VAR 0 1
18013: PPUSH
18014: LD_VAR 0 2
18018: PPUSH
18019: LD_VAR 0 3
18023: PPUSH
18024: LD_VAR 0 4
18028: PPUSH
18029: CALL 48978 0 4
// end ;
18033: PPOPN 4
18035: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18036: LD_VAR 0 1
18040: PPUSH
18041: CALL 107257 0 1
// end ;
18045: PPOPN 1
18047: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do var i ;
18048: LD_INT 22
18050: PUSH
18051: LD_INT 2
18053: PUSH
18054: EMPTY
18055: LIST
18056: LIST
18057: PUSH
18058: LD_INT 50
18060: PUSH
18061: EMPTY
18062: LIST
18063: PUSH
18064: LD_INT 21
18066: PUSH
18067: LD_INT 1
18069: PUSH
18070: EMPTY
18071: LIST
18072: LIST
18073: PUSH
18074: EMPTY
18075: LIST
18076: LIST
18077: LIST
18078: PPUSH
18079: CALL_OW 69
18083: IFFALSE 18167
18085: GO 18087
18087: DISABLE
18088: LD_INT 0
18090: PPUSH
// begin enable ;
18091: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do
18092: LD_ADDR_VAR 0 1
18096: PUSH
18097: LD_INT 22
18099: PUSH
18100: LD_INT 2
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: PUSH
18107: LD_INT 50
18109: PUSH
18110: EMPTY
18111: LIST
18112: PUSH
18113: LD_INT 21
18115: PUSH
18116: LD_INT 1
18118: PUSH
18119: EMPTY
18120: LIST
18121: LIST
18122: PUSH
18123: EMPTY
18124: LIST
18125: LIST
18126: LIST
18127: PPUSH
18128: CALL_OW 69
18132: PUSH
18133: FOR_IN
18134: IFFALSE 18165
// if GetFuel ( i ) < 3 then
18136: LD_VAR 0 1
18140: PPUSH
18141: CALL_OW 261
18145: PUSH
18146: LD_INT 3
18148: LESS
18149: IFFALSE 18163
// SetFuel ( i , 5 ) ;
18151: LD_VAR 0 1
18155: PPUSH
18156: LD_INT 5
18158: PPUSH
18159: CALL_OW 240
18163: GO 18133
18165: POP
18166: POP
// end ; end_of_file
18167: PPOPN 1
18169: END
// every 0 0$1 trigger game do
18170: LD_EXP 2
18174: IFFALSE 18204
18176: GO 18178
18178: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
18179: LD_INT 7
18181: PUSH
18182: LD_INT 6
18184: PUSH
18185: LD_INT 4
18187: PUSH
18188: LD_INT 6
18190: PUSH
18191: EMPTY
18192: LIST
18193: LIST
18194: LIST
18195: LIST
18196: PPUSH
18197: LD_INT 1750
18199: PPUSH
18200: CALL 18205 0 2
18204: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
18205: LD_INT 0
18207: PPUSH
18208: PPUSH
18209: PPUSH
// if not areas then
18210: LD_VAR 0 1
18214: NOT
18215: IFFALSE 18219
// exit ;
18217: GO 18349
// repeat wait ( time ) ;
18219: LD_VAR 0 2
18223: PPUSH
18224: CALL_OW 67
// for i in areas do
18228: LD_ADDR_VAR 0 4
18232: PUSH
18233: LD_VAR 0 1
18237: PUSH
18238: FOR_IN
18239: IFFALSE 18308
// begin p := rand ( 1 , 90 ) ;
18241: LD_ADDR_VAR 0 5
18245: PUSH
18246: LD_INT 1
18248: PPUSH
18249: LD_INT 90
18251: PPUSH
18252: CALL_OW 12
18256: ST_TO_ADDR
// if Prob ( p ) then
18257: LD_VAR 0 5
18261: PPUSH
18262: CALL_OW 13
18266: IFFALSE 18306
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
18268: LD_INT 2
18270: PPUSH
18271: LD_INT 5
18273: PPUSH
18274: CALL_OW 12
18278: PPUSH
18279: LD_VAR 0 4
18283: PPUSH
18284: LD_INT 1
18286: PPUSH
18287: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
18291: LD_INT 735
18293: PPUSH
18294: LD_INT 1295
18296: PPUSH
18297: CALL_OW 12
18301: PPUSH
18302: CALL_OW 67
// end ; end ;
18306: GO 18238
18308: POP
18309: POP
// time := time + 0 0$3 ;
18310: LD_ADDR_VAR 0 2
18314: PUSH
18315: LD_VAR 0 2
18319: PUSH
18320: LD_INT 105
18322: PLUS
18323: ST_TO_ADDR
// if time > 3 3$00 then
18324: LD_VAR 0 2
18328: PUSH
18329: LD_INT 6300
18331: GREATER
18332: IFFALSE 18342
// time := 0 0$40 ;
18334: LD_ADDR_VAR 0 2
18338: PUSH
18339: LD_INT 1400
18341: ST_TO_ADDR
// until not game ;
18342: LD_EXP 2
18346: NOT
18347: IFFALSE 18219
// end ;
18349: LD_VAR 0 3
18353: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
18354: LD_OWVAR 1
18358: PUSH
18359: LD_INT 84000
18361: PUSH
18362: LD_INT 73500
18364: PUSH
18365: LD_INT 63000
18367: PUSH
18368: LD_INT 52500
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: LIST
18375: LIST
18376: PUSH
18377: LD_OWVAR 67
18381: ARRAY
18382: LESS
18383: IFFALSE 18410
18385: GO 18387
18387: DISABLE
// begin enable ;
18388: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
18389: LD_INT 1
18391: PPUSH
18392: LD_INT 5
18394: PPUSH
18395: CALL_OW 12
18399: PPUSH
18400: LD_INT 7
18402: PPUSH
18403: LD_INT 1
18405: PPUSH
18406: CALL_OW 55
// end ; end_of_file
18410: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
18411: LD_INT 0
18413: PPUSH
18414: PPUSH
// skirmish := false ;
18415: LD_ADDR_EXP 48
18419: PUSH
18420: LD_INT 0
18422: ST_TO_ADDR
// debug_mc := false ;
18423: LD_ADDR_EXP 49
18427: PUSH
18428: LD_INT 0
18430: ST_TO_ADDR
// mc_bases := [ ] ;
18431: LD_ADDR_EXP 50
18435: PUSH
18436: EMPTY
18437: ST_TO_ADDR
// mc_sides := [ ] ;
18438: LD_ADDR_EXP 76
18442: PUSH
18443: EMPTY
18444: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18445: LD_ADDR_EXP 51
18449: PUSH
18450: EMPTY
18451: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18452: LD_ADDR_EXP 52
18456: PUSH
18457: EMPTY
18458: ST_TO_ADDR
// mc_need_heal := [ ] ;
18459: LD_ADDR_EXP 53
18463: PUSH
18464: EMPTY
18465: ST_TO_ADDR
// mc_healers := [ ] ;
18466: LD_ADDR_EXP 54
18470: PUSH
18471: EMPTY
18472: ST_TO_ADDR
// mc_build_list := [ ] ;
18473: LD_ADDR_EXP 55
18477: PUSH
18478: EMPTY
18479: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18480: LD_ADDR_EXP 82
18484: PUSH
18485: EMPTY
18486: ST_TO_ADDR
// mc_builders := [ ] ;
18487: LD_ADDR_EXP 56
18491: PUSH
18492: EMPTY
18493: ST_TO_ADDR
// mc_construct_list := [ ] ;
18494: LD_ADDR_EXP 57
18498: PUSH
18499: EMPTY
18500: ST_TO_ADDR
// mc_turret_list := [ ] ;
18501: LD_ADDR_EXP 58
18505: PUSH
18506: EMPTY
18507: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18508: LD_ADDR_EXP 59
18512: PUSH
18513: EMPTY
18514: ST_TO_ADDR
// mc_miners := [ ] ;
18515: LD_ADDR_EXP 64
18519: PUSH
18520: EMPTY
18521: ST_TO_ADDR
// mc_mines := [ ] ;
18522: LD_ADDR_EXP 63
18526: PUSH
18527: EMPTY
18528: ST_TO_ADDR
// mc_minefields := [ ] ;
18529: LD_ADDR_EXP 65
18533: PUSH
18534: EMPTY
18535: ST_TO_ADDR
// mc_crates := [ ] ;
18536: LD_ADDR_EXP 66
18540: PUSH
18541: EMPTY
18542: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18543: LD_ADDR_EXP 67
18547: PUSH
18548: EMPTY
18549: ST_TO_ADDR
// mc_crates_area := [ ] ;
18550: LD_ADDR_EXP 68
18554: PUSH
18555: EMPTY
18556: ST_TO_ADDR
// mc_vehicles := [ ] ;
18557: LD_ADDR_EXP 69
18561: PUSH
18562: EMPTY
18563: ST_TO_ADDR
// mc_attack := [ ] ;
18564: LD_ADDR_EXP 70
18568: PUSH
18569: EMPTY
18570: ST_TO_ADDR
// mc_produce := [ ] ;
18571: LD_ADDR_EXP 71
18575: PUSH
18576: EMPTY
18577: ST_TO_ADDR
// mc_defender := [ ] ;
18578: LD_ADDR_EXP 72
18582: PUSH
18583: EMPTY
18584: ST_TO_ADDR
// mc_parking := [ ] ;
18585: LD_ADDR_EXP 74
18589: PUSH
18590: EMPTY
18591: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18592: LD_ADDR_EXP 60
18596: PUSH
18597: EMPTY
18598: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18599: LD_ADDR_EXP 62
18603: PUSH
18604: EMPTY
18605: ST_TO_ADDR
// mc_scan := [ ] ;
18606: LD_ADDR_EXP 73
18610: PUSH
18611: EMPTY
18612: ST_TO_ADDR
// mc_scan_area := [ ] ;
18613: LD_ADDR_EXP 75
18617: PUSH
18618: EMPTY
18619: ST_TO_ADDR
// mc_tech := [ ] ;
18620: LD_ADDR_EXP 77
18624: PUSH
18625: EMPTY
18626: ST_TO_ADDR
// mc_class := [ ] ;
18627: LD_ADDR_EXP 91
18631: PUSH
18632: EMPTY
18633: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18634: LD_ADDR_EXP 92
18638: PUSH
18639: EMPTY
18640: ST_TO_ADDR
// mc_is_defending := [ ] ;
18641: LD_ADDR_EXP 93
18645: PUSH
18646: EMPTY
18647: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18648: LD_ADDR_EXP 84
18652: PUSH
18653: EMPTY
18654: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
18655: LD_ADDR_EXP 94
18659: PUSH
18660: LD_INT 0
18662: ST_TO_ADDR
// end ;
18663: LD_VAR 0 1
18667: RET
// export function MC_Kill ( base ) ; begin
18668: LD_INT 0
18670: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18671: LD_ADDR_EXP 50
18675: PUSH
18676: LD_EXP 50
18680: PPUSH
18681: LD_VAR 0 1
18685: PPUSH
18686: EMPTY
18687: PPUSH
18688: CALL_OW 1
18692: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18693: LD_ADDR_EXP 51
18697: PUSH
18698: LD_EXP 51
18702: PPUSH
18703: LD_VAR 0 1
18707: PPUSH
18708: EMPTY
18709: PPUSH
18710: CALL_OW 1
18714: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18715: LD_ADDR_EXP 52
18719: PUSH
18720: LD_EXP 52
18724: PPUSH
18725: LD_VAR 0 1
18729: PPUSH
18730: EMPTY
18731: PPUSH
18732: CALL_OW 1
18736: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18737: LD_ADDR_EXP 53
18741: PUSH
18742: LD_EXP 53
18746: PPUSH
18747: LD_VAR 0 1
18751: PPUSH
18752: EMPTY
18753: PPUSH
18754: CALL_OW 1
18758: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18759: LD_ADDR_EXP 54
18763: PUSH
18764: LD_EXP 54
18768: PPUSH
18769: LD_VAR 0 1
18773: PPUSH
18774: EMPTY
18775: PPUSH
18776: CALL_OW 1
18780: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18781: LD_ADDR_EXP 55
18785: PUSH
18786: LD_EXP 55
18790: PPUSH
18791: LD_VAR 0 1
18795: PPUSH
18796: EMPTY
18797: PPUSH
18798: CALL_OW 1
18802: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18803: LD_ADDR_EXP 56
18807: PUSH
18808: LD_EXP 56
18812: PPUSH
18813: LD_VAR 0 1
18817: PPUSH
18818: EMPTY
18819: PPUSH
18820: CALL_OW 1
18824: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18825: LD_ADDR_EXP 57
18829: PUSH
18830: LD_EXP 57
18834: PPUSH
18835: LD_VAR 0 1
18839: PPUSH
18840: EMPTY
18841: PPUSH
18842: CALL_OW 1
18846: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18847: LD_ADDR_EXP 58
18851: PUSH
18852: LD_EXP 58
18856: PPUSH
18857: LD_VAR 0 1
18861: PPUSH
18862: EMPTY
18863: PPUSH
18864: CALL_OW 1
18868: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18869: LD_ADDR_EXP 59
18873: PUSH
18874: LD_EXP 59
18878: PPUSH
18879: LD_VAR 0 1
18883: PPUSH
18884: EMPTY
18885: PPUSH
18886: CALL_OW 1
18890: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18891: LD_ADDR_EXP 60
18895: PUSH
18896: LD_EXP 60
18900: PPUSH
18901: LD_VAR 0 1
18905: PPUSH
18906: EMPTY
18907: PPUSH
18908: CALL_OW 1
18912: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18913: LD_ADDR_EXP 61
18917: PUSH
18918: LD_EXP 61
18922: PPUSH
18923: LD_VAR 0 1
18927: PPUSH
18928: LD_INT 0
18930: PPUSH
18931: CALL_OW 1
18935: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18936: LD_ADDR_EXP 62
18940: PUSH
18941: LD_EXP 62
18945: PPUSH
18946: LD_VAR 0 1
18950: PPUSH
18951: EMPTY
18952: PPUSH
18953: CALL_OW 1
18957: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18958: LD_ADDR_EXP 63
18962: PUSH
18963: LD_EXP 63
18967: PPUSH
18968: LD_VAR 0 1
18972: PPUSH
18973: EMPTY
18974: PPUSH
18975: CALL_OW 1
18979: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18980: LD_ADDR_EXP 64
18984: PUSH
18985: LD_EXP 64
18989: PPUSH
18990: LD_VAR 0 1
18994: PPUSH
18995: EMPTY
18996: PPUSH
18997: CALL_OW 1
19001: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19002: LD_ADDR_EXP 65
19006: PUSH
19007: LD_EXP 65
19011: PPUSH
19012: LD_VAR 0 1
19016: PPUSH
19017: EMPTY
19018: PPUSH
19019: CALL_OW 1
19023: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19024: LD_ADDR_EXP 66
19028: PUSH
19029: LD_EXP 66
19033: PPUSH
19034: LD_VAR 0 1
19038: PPUSH
19039: EMPTY
19040: PPUSH
19041: CALL_OW 1
19045: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19046: LD_ADDR_EXP 67
19050: PUSH
19051: LD_EXP 67
19055: PPUSH
19056: LD_VAR 0 1
19060: PPUSH
19061: EMPTY
19062: PPUSH
19063: CALL_OW 1
19067: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19068: LD_ADDR_EXP 68
19072: PUSH
19073: LD_EXP 68
19077: PPUSH
19078: LD_VAR 0 1
19082: PPUSH
19083: EMPTY
19084: PPUSH
19085: CALL_OW 1
19089: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19090: LD_ADDR_EXP 69
19094: PUSH
19095: LD_EXP 69
19099: PPUSH
19100: LD_VAR 0 1
19104: PPUSH
19105: EMPTY
19106: PPUSH
19107: CALL_OW 1
19111: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19112: LD_ADDR_EXP 70
19116: PUSH
19117: LD_EXP 70
19121: PPUSH
19122: LD_VAR 0 1
19126: PPUSH
19127: EMPTY
19128: PPUSH
19129: CALL_OW 1
19133: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19134: LD_ADDR_EXP 71
19138: PUSH
19139: LD_EXP 71
19143: PPUSH
19144: LD_VAR 0 1
19148: PPUSH
19149: EMPTY
19150: PPUSH
19151: CALL_OW 1
19155: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19156: LD_ADDR_EXP 72
19160: PUSH
19161: LD_EXP 72
19165: PPUSH
19166: LD_VAR 0 1
19170: PPUSH
19171: EMPTY
19172: PPUSH
19173: CALL_OW 1
19177: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19178: LD_ADDR_EXP 73
19182: PUSH
19183: LD_EXP 73
19187: PPUSH
19188: LD_VAR 0 1
19192: PPUSH
19193: EMPTY
19194: PPUSH
19195: CALL_OW 1
19199: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19200: LD_ADDR_EXP 74
19204: PUSH
19205: LD_EXP 74
19209: PPUSH
19210: LD_VAR 0 1
19214: PPUSH
19215: EMPTY
19216: PPUSH
19217: CALL_OW 1
19221: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19222: LD_ADDR_EXP 75
19226: PUSH
19227: LD_EXP 75
19231: PPUSH
19232: LD_VAR 0 1
19236: PPUSH
19237: EMPTY
19238: PPUSH
19239: CALL_OW 1
19243: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19244: LD_ADDR_EXP 77
19248: PUSH
19249: LD_EXP 77
19253: PPUSH
19254: LD_VAR 0 1
19258: PPUSH
19259: EMPTY
19260: PPUSH
19261: CALL_OW 1
19265: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19266: LD_ADDR_EXP 79
19270: PUSH
19271: LD_EXP 79
19275: PPUSH
19276: LD_VAR 0 1
19280: PPUSH
19281: EMPTY
19282: PPUSH
19283: CALL_OW 1
19287: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19288: LD_ADDR_EXP 80
19292: PUSH
19293: LD_EXP 80
19297: PPUSH
19298: LD_VAR 0 1
19302: PPUSH
19303: EMPTY
19304: PPUSH
19305: CALL_OW 1
19309: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19310: LD_ADDR_EXP 81
19314: PUSH
19315: LD_EXP 81
19319: PPUSH
19320: LD_VAR 0 1
19324: PPUSH
19325: EMPTY
19326: PPUSH
19327: CALL_OW 1
19331: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19332: LD_ADDR_EXP 82
19336: PUSH
19337: LD_EXP 82
19341: PPUSH
19342: LD_VAR 0 1
19346: PPUSH
19347: EMPTY
19348: PPUSH
19349: CALL_OW 1
19353: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19354: LD_ADDR_EXP 83
19358: PUSH
19359: LD_EXP 83
19363: PPUSH
19364: LD_VAR 0 1
19368: PPUSH
19369: EMPTY
19370: PPUSH
19371: CALL_OW 1
19375: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19376: LD_ADDR_EXP 84
19380: PUSH
19381: LD_EXP 84
19385: PPUSH
19386: LD_VAR 0 1
19390: PPUSH
19391: EMPTY
19392: PPUSH
19393: CALL_OW 1
19397: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19398: LD_ADDR_EXP 85
19402: PUSH
19403: LD_EXP 85
19407: PPUSH
19408: LD_VAR 0 1
19412: PPUSH
19413: EMPTY
19414: PPUSH
19415: CALL_OW 1
19419: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19420: LD_ADDR_EXP 86
19424: PUSH
19425: LD_EXP 86
19429: PPUSH
19430: LD_VAR 0 1
19434: PPUSH
19435: EMPTY
19436: PPUSH
19437: CALL_OW 1
19441: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19442: LD_ADDR_EXP 87
19446: PUSH
19447: LD_EXP 87
19451: PPUSH
19452: LD_VAR 0 1
19456: PPUSH
19457: EMPTY
19458: PPUSH
19459: CALL_OW 1
19463: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19464: LD_ADDR_EXP 88
19468: PUSH
19469: LD_EXP 88
19473: PPUSH
19474: LD_VAR 0 1
19478: PPUSH
19479: EMPTY
19480: PPUSH
19481: CALL_OW 1
19485: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19486: LD_ADDR_EXP 89
19490: PUSH
19491: LD_EXP 89
19495: PPUSH
19496: LD_VAR 0 1
19500: PPUSH
19501: EMPTY
19502: PPUSH
19503: CALL_OW 1
19507: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19508: LD_ADDR_EXP 90
19512: PUSH
19513: LD_EXP 90
19517: PPUSH
19518: LD_VAR 0 1
19522: PPUSH
19523: EMPTY
19524: PPUSH
19525: CALL_OW 1
19529: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19530: LD_ADDR_EXP 91
19534: PUSH
19535: LD_EXP 91
19539: PPUSH
19540: LD_VAR 0 1
19544: PPUSH
19545: EMPTY
19546: PPUSH
19547: CALL_OW 1
19551: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19552: LD_ADDR_EXP 92
19556: PUSH
19557: LD_EXP 92
19561: PPUSH
19562: LD_VAR 0 1
19566: PPUSH
19567: LD_INT 0
19569: PPUSH
19570: CALL_OW 1
19574: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19575: LD_ADDR_EXP 93
19579: PUSH
19580: LD_EXP 93
19584: PPUSH
19585: LD_VAR 0 1
19589: PPUSH
19590: LD_INT 0
19592: PPUSH
19593: CALL_OW 1
19597: ST_TO_ADDR
// end ;
19598: LD_VAR 0 2
19602: RET
// export function MC_Add ( side , units ) ; var base ; begin
19603: LD_INT 0
19605: PPUSH
19606: PPUSH
// base := mc_bases + 1 ;
19607: LD_ADDR_VAR 0 4
19611: PUSH
19612: LD_EXP 50
19616: PUSH
19617: LD_INT 1
19619: PLUS
19620: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19621: LD_ADDR_EXP 76
19625: PUSH
19626: LD_EXP 76
19630: PPUSH
19631: LD_VAR 0 4
19635: PPUSH
19636: LD_VAR 0 1
19640: PPUSH
19641: CALL_OW 1
19645: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19646: LD_ADDR_EXP 50
19650: PUSH
19651: LD_EXP 50
19655: PPUSH
19656: LD_VAR 0 4
19660: PPUSH
19661: LD_VAR 0 2
19665: PPUSH
19666: CALL_OW 1
19670: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19671: LD_ADDR_EXP 51
19675: PUSH
19676: LD_EXP 51
19680: PPUSH
19681: LD_VAR 0 4
19685: PPUSH
19686: EMPTY
19687: PPUSH
19688: CALL_OW 1
19692: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19693: LD_ADDR_EXP 52
19697: PUSH
19698: LD_EXP 52
19702: PPUSH
19703: LD_VAR 0 4
19707: PPUSH
19708: EMPTY
19709: PPUSH
19710: CALL_OW 1
19714: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19715: LD_ADDR_EXP 53
19719: PUSH
19720: LD_EXP 53
19724: PPUSH
19725: LD_VAR 0 4
19729: PPUSH
19730: EMPTY
19731: PPUSH
19732: CALL_OW 1
19736: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19737: LD_ADDR_EXP 54
19741: PUSH
19742: LD_EXP 54
19746: PPUSH
19747: LD_VAR 0 4
19751: PPUSH
19752: EMPTY
19753: PPUSH
19754: CALL_OW 1
19758: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19759: LD_ADDR_EXP 55
19763: PUSH
19764: LD_EXP 55
19768: PPUSH
19769: LD_VAR 0 4
19773: PPUSH
19774: EMPTY
19775: PPUSH
19776: CALL_OW 1
19780: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19781: LD_ADDR_EXP 56
19785: PUSH
19786: LD_EXP 56
19790: PPUSH
19791: LD_VAR 0 4
19795: PPUSH
19796: EMPTY
19797: PPUSH
19798: CALL_OW 1
19802: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19803: LD_ADDR_EXP 57
19807: PUSH
19808: LD_EXP 57
19812: PPUSH
19813: LD_VAR 0 4
19817: PPUSH
19818: EMPTY
19819: PPUSH
19820: CALL_OW 1
19824: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19825: LD_ADDR_EXP 58
19829: PUSH
19830: LD_EXP 58
19834: PPUSH
19835: LD_VAR 0 4
19839: PPUSH
19840: EMPTY
19841: PPUSH
19842: CALL_OW 1
19846: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19847: LD_ADDR_EXP 59
19851: PUSH
19852: LD_EXP 59
19856: PPUSH
19857: LD_VAR 0 4
19861: PPUSH
19862: EMPTY
19863: PPUSH
19864: CALL_OW 1
19868: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19869: LD_ADDR_EXP 60
19873: PUSH
19874: LD_EXP 60
19878: PPUSH
19879: LD_VAR 0 4
19883: PPUSH
19884: EMPTY
19885: PPUSH
19886: CALL_OW 1
19890: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19891: LD_ADDR_EXP 61
19895: PUSH
19896: LD_EXP 61
19900: PPUSH
19901: LD_VAR 0 4
19905: PPUSH
19906: LD_INT 0
19908: PPUSH
19909: CALL_OW 1
19913: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19914: LD_ADDR_EXP 62
19918: PUSH
19919: LD_EXP 62
19923: PPUSH
19924: LD_VAR 0 4
19928: PPUSH
19929: EMPTY
19930: PPUSH
19931: CALL_OW 1
19935: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19936: LD_ADDR_EXP 63
19940: PUSH
19941: LD_EXP 63
19945: PPUSH
19946: LD_VAR 0 4
19950: PPUSH
19951: EMPTY
19952: PPUSH
19953: CALL_OW 1
19957: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19958: LD_ADDR_EXP 64
19962: PUSH
19963: LD_EXP 64
19967: PPUSH
19968: LD_VAR 0 4
19972: PPUSH
19973: EMPTY
19974: PPUSH
19975: CALL_OW 1
19979: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19980: LD_ADDR_EXP 65
19984: PUSH
19985: LD_EXP 65
19989: PPUSH
19990: LD_VAR 0 4
19994: PPUSH
19995: EMPTY
19996: PPUSH
19997: CALL_OW 1
20001: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20002: LD_ADDR_EXP 66
20006: PUSH
20007: LD_EXP 66
20011: PPUSH
20012: LD_VAR 0 4
20016: PPUSH
20017: EMPTY
20018: PPUSH
20019: CALL_OW 1
20023: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20024: LD_ADDR_EXP 67
20028: PUSH
20029: LD_EXP 67
20033: PPUSH
20034: LD_VAR 0 4
20038: PPUSH
20039: EMPTY
20040: PPUSH
20041: CALL_OW 1
20045: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20046: LD_ADDR_EXP 68
20050: PUSH
20051: LD_EXP 68
20055: PPUSH
20056: LD_VAR 0 4
20060: PPUSH
20061: EMPTY
20062: PPUSH
20063: CALL_OW 1
20067: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20068: LD_ADDR_EXP 69
20072: PUSH
20073: LD_EXP 69
20077: PPUSH
20078: LD_VAR 0 4
20082: PPUSH
20083: EMPTY
20084: PPUSH
20085: CALL_OW 1
20089: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20090: LD_ADDR_EXP 70
20094: PUSH
20095: LD_EXP 70
20099: PPUSH
20100: LD_VAR 0 4
20104: PPUSH
20105: EMPTY
20106: PPUSH
20107: CALL_OW 1
20111: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20112: LD_ADDR_EXP 71
20116: PUSH
20117: LD_EXP 71
20121: PPUSH
20122: LD_VAR 0 4
20126: PPUSH
20127: EMPTY
20128: PPUSH
20129: CALL_OW 1
20133: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20134: LD_ADDR_EXP 72
20138: PUSH
20139: LD_EXP 72
20143: PPUSH
20144: LD_VAR 0 4
20148: PPUSH
20149: EMPTY
20150: PPUSH
20151: CALL_OW 1
20155: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20156: LD_ADDR_EXP 73
20160: PUSH
20161: LD_EXP 73
20165: PPUSH
20166: LD_VAR 0 4
20170: PPUSH
20171: EMPTY
20172: PPUSH
20173: CALL_OW 1
20177: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20178: LD_ADDR_EXP 74
20182: PUSH
20183: LD_EXP 74
20187: PPUSH
20188: LD_VAR 0 4
20192: PPUSH
20193: EMPTY
20194: PPUSH
20195: CALL_OW 1
20199: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20200: LD_ADDR_EXP 75
20204: PUSH
20205: LD_EXP 75
20209: PPUSH
20210: LD_VAR 0 4
20214: PPUSH
20215: EMPTY
20216: PPUSH
20217: CALL_OW 1
20221: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20222: LD_ADDR_EXP 77
20226: PUSH
20227: LD_EXP 77
20231: PPUSH
20232: LD_VAR 0 4
20236: PPUSH
20237: EMPTY
20238: PPUSH
20239: CALL_OW 1
20243: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20244: LD_ADDR_EXP 79
20248: PUSH
20249: LD_EXP 79
20253: PPUSH
20254: LD_VAR 0 4
20258: PPUSH
20259: EMPTY
20260: PPUSH
20261: CALL_OW 1
20265: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20266: LD_ADDR_EXP 80
20270: PUSH
20271: LD_EXP 80
20275: PPUSH
20276: LD_VAR 0 4
20280: PPUSH
20281: EMPTY
20282: PPUSH
20283: CALL_OW 1
20287: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20288: LD_ADDR_EXP 81
20292: PUSH
20293: LD_EXP 81
20297: PPUSH
20298: LD_VAR 0 4
20302: PPUSH
20303: EMPTY
20304: PPUSH
20305: CALL_OW 1
20309: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20310: LD_ADDR_EXP 82
20314: PUSH
20315: LD_EXP 82
20319: PPUSH
20320: LD_VAR 0 4
20324: PPUSH
20325: EMPTY
20326: PPUSH
20327: CALL_OW 1
20331: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20332: LD_ADDR_EXP 83
20336: PUSH
20337: LD_EXP 83
20341: PPUSH
20342: LD_VAR 0 4
20346: PPUSH
20347: EMPTY
20348: PPUSH
20349: CALL_OW 1
20353: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20354: LD_ADDR_EXP 84
20358: PUSH
20359: LD_EXP 84
20363: PPUSH
20364: LD_VAR 0 4
20368: PPUSH
20369: EMPTY
20370: PPUSH
20371: CALL_OW 1
20375: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20376: LD_ADDR_EXP 85
20380: PUSH
20381: LD_EXP 85
20385: PPUSH
20386: LD_VAR 0 4
20390: PPUSH
20391: EMPTY
20392: PPUSH
20393: CALL_OW 1
20397: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20398: LD_ADDR_EXP 86
20402: PUSH
20403: LD_EXP 86
20407: PPUSH
20408: LD_VAR 0 4
20412: PPUSH
20413: EMPTY
20414: PPUSH
20415: CALL_OW 1
20419: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20420: LD_ADDR_EXP 87
20424: PUSH
20425: LD_EXP 87
20429: PPUSH
20430: LD_VAR 0 4
20434: PPUSH
20435: EMPTY
20436: PPUSH
20437: CALL_OW 1
20441: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20442: LD_ADDR_EXP 88
20446: PUSH
20447: LD_EXP 88
20451: PPUSH
20452: LD_VAR 0 4
20456: PPUSH
20457: EMPTY
20458: PPUSH
20459: CALL_OW 1
20463: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20464: LD_ADDR_EXP 89
20468: PUSH
20469: LD_EXP 89
20473: PPUSH
20474: LD_VAR 0 4
20478: PPUSH
20479: EMPTY
20480: PPUSH
20481: CALL_OW 1
20485: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20486: LD_ADDR_EXP 90
20490: PUSH
20491: LD_EXP 90
20495: PPUSH
20496: LD_VAR 0 4
20500: PPUSH
20501: EMPTY
20502: PPUSH
20503: CALL_OW 1
20507: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20508: LD_ADDR_EXP 91
20512: PUSH
20513: LD_EXP 91
20517: PPUSH
20518: LD_VAR 0 4
20522: PPUSH
20523: EMPTY
20524: PPUSH
20525: CALL_OW 1
20529: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20530: LD_ADDR_EXP 92
20534: PUSH
20535: LD_EXP 92
20539: PPUSH
20540: LD_VAR 0 4
20544: PPUSH
20545: LD_INT 0
20547: PPUSH
20548: CALL_OW 1
20552: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20553: LD_ADDR_EXP 93
20557: PUSH
20558: LD_EXP 93
20562: PPUSH
20563: LD_VAR 0 4
20567: PPUSH
20568: LD_INT 0
20570: PPUSH
20571: CALL_OW 1
20575: ST_TO_ADDR
// result := base ;
20576: LD_ADDR_VAR 0 3
20580: PUSH
20581: LD_VAR 0 4
20585: ST_TO_ADDR
// end ;
20586: LD_VAR 0 3
20590: RET
// export function MC_Start ( ) ; var i ; begin
20591: LD_INT 0
20593: PPUSH
20594: PPUSH
// for i = 1 to mc_bases do
20595: LD_ADDR_VAR 0 2
20599: PUSH
20600: DOUBLE
20601: LD_INT 1
20603: DEC
20604: ST_TO_ADDR
20605: LD_EXP 50
20609: PUSH
20610: FOR_TO
20611: IFFALSE 21711
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20613: LD_ADDR_EXP 50
20617: PUSH
20618: LD_EXP 50
20622: PPUSH
20623: LD_VAR 0 2
20627: PPUSH
20628: LD_EXP 50
20632: PUSH
20633: LD_VAR 0 2
20637: ARRAY
20638: PUSH
20639: LD_INT 0
20641: DIFF
20642: PPUSH
20643: CALL_OW 1
20647: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20648: LD_ADDR_EXP 51
20652: PUSH
20653: LD_EXP 51
20657: PPUSH
20658: LD_VAR 0 2
20662: PPUSH
20663: EMPTY
20664: PPUSH
20665: CALL_OW 1
20669: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20670: LD_ADDR_EXP 52
20674: PUSH
20675: LD_EXP 52
20679: PPUSH
20680: LD_VAR 0 2
20684: PPUSH
20685: EMPTY
20686: PPUSH
20687: CALL_OW 1
20691: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20692: LD_ADDR_EXP 53
20696: PUSH
20697: LD_EXP 53
20701: PPUSH
20702: LD_VAR 0 2
20706: PPUSH
20707: EMPTY
20708: PPUSH
20709: CALL_OW 1
20713: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20714: LD_ADDR_EXP 54
20718: PUSH
20719: LD_EXP 54
20723: PPUSH
20724: LD_VAR 0 2
20728: PPUSH
20729: EMPTY
20730: PUSH
20731: EMPTY
20732: PUSH
20733: EMPTY
20734: LIST
20735: LIST
20736: PPUSH
20737: CALL_OW 1
20741: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20742: LD_ADDR_EXP 55
20746: PUSH
20747: LD_EXP 55
20751: PPUSH
20752: LD_VAR 0 2
20756: PPUSH
20757: EMPTY
20758: PPUSH
20759: CALL_OW 1
20763: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20764: LD_ADDR_EXP 82
20768: PUSH
20769: LD_EXP 82
20773: PPUSH
20774: LD_VAR 0 2
20778: PPUSH
20779: EMPTY
20780: PPUSH
20781: CALL_OW 1
20785: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20786: LD_ADDR_EXP 56
20790: PUSH
20791: LD_EXP 56
20795: PPUSH
20796: LD_VAR 0 2
20800: PPUSH
20801: EMPTY
20802: PPUSH
20803: CALL_OW 1
20807: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20808: LD_ADDR_EXP 57
20812: PUSH
20813: LD_EXP 57
20817: PPUSH
20818: LD_VAR 0 2
20822: PPUSH
20823: EMPTY
20824: PPUSH
20825: CALL_OW 1
20829: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20830: LD_ADDR_EXP 58
20834: PUSH
20835: LD_EXP 58
20839: PPUSH
20840: LD_VAR 0 2
20844: PPUSH
20845: LD_EXP 50
20849: PUSH
20850: LD_VAR 0 2
20854: ARRAY
20855: PPUSH
20856: LD_INT 2
20858: PUSH
20859: LD_INT 30
20861: PUSH
20862: LD_INT 32
20864: PUSH
20865: EMPTY
20866: LIST
20867: LIST
20868: PUSH
20869: LD_INT 30
20871: PUSH
20872: LD_INT 33
20874: PUSH
20875: EMPTY
20876: LIST
20877: LIST
20878: PUSH
20879: EMPTY
20880: LIST
20881: LIST
20882: LIST
20883: PPUSH
20884: CALL_OW 72
20888: PPUSH
20889: CALL_OW 1
20893: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20894: LD_ADDR_EXP 59
20898: PUSH
20899: LD_EXP 59
20903: PPUSH
20904: LD_VAR 0 2
20908: PPUSH
20909: LD_EXP 50
20913: PUSH
20914: LD_VAR 0 2
20918: ARRAY
20919: PPUSH
20920: LD_INT 2
20922: PUSH
20923: LD_INT 30
20925: PUSH
20926: LD_INT 32
20928: PUSH
20929: EMPTY
20930: LIST
20931: LIST
20932: PUSH
20933: LD_INT 30
20935: PUSH
20936: LD_INT 31
20938: PUSH
20939: EMPTY
20940: LIST
20941: LIST
20942: PUSH
20943: EMPTY
20944: LIST
20945: LIST
20946: LIST
20947: PUSH
20948: LD_INT 58
20950: PUSH
20951: EMPTY
20952: LIST
20953: PUSH
20954: EMPTY
20955: LIST
20956: LIST
20957: PPUSH
20958: CALL_OW 72
20962: PPUSH
20963: CALL_OW 1
20967: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20968: LD_ADDR_EXP 60
20972: PUSH
20973: LD_EXP 60
20977: PPUSH
20978: LD_VAR 0 2
20982: PPUSH
20983: EMPTY
20984: PPUSH
20985: CALL_OW 1
20989: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20990: LD_ADDR_EXP 64
20994: PUSH
20995: LD_EXP 64
20999: PPUSH
21000: LD_VAR 0 2
21004: PPUSH
21005: EMPTY
21006: PPUSH
21007: CALL_OW 1
21011: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
21012: LD_ADDR_EXP 63
21016: PUSH
21017: LD_EXP 63
21021: PPUSH
21022: LD_VAR 0 2
21026: PPUSH
21027: EMPTY
21028: PPUSH
21029: CALL_OW 1
21033: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
21034: LD_ADDR_EXP 65
21038: PUSH
21039: LD_EXP 65
21043: PPUSH
21044: LD_VAR 0 2
21048: PPUSH
21049: EMPTY
21050: PPUSH
21051: CALL_OW 1
21055: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
21056: LD_ADDR_EXP 66
21060: PUSH
21061: LD_EXP 66
21065: PPUSH
21066: LD_VAR 0 2
21070: PPUSH
21071: EMPTY
21072: PPUSH
21073: CALL_OW 1
21077: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
21078: LD_ADDR_EXP 67
21082: PUSH
21083: LD_EXP 67
21087: PPUSH
21088: LD_VAR 0 2
21092: PPUSH
21093: EMPTY
21094: PPUSH
21095: CALL_OW 1
21099: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
21100: LD_ADDR_EXP 68
21104: PUSH
21105: LD_EXP 68
21109: PPUSH
21110: LD_VAR 0 2
21114: PPUSH
21115: EMPTY
21116: PPUSH
21117: CALL_OW 1
21121: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
21122: LD_ADDR_EXP 69
21126: PUSH
21127: LD_EXP 69
21131: PPUSH
21132: LD_VAR 0 2
21136: PPUSH
21137: EMPTY
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
21144: LD_ADDR_EXP 70
21148: PUSH
21149: LD_EXP 70
21153: PPUSH
21154: LD_VAR 0 2
21158: PPUSH
21159: EMPTY
21160: PPUSH
21161: CALL_OW 1
21165: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
21166: LD_ADDR_EXP 71
21170: PUSH
21171: LD_EXP 71
21175: PPUSH
21176: LD_VAR 0 2
21180: PPUSH
21181: EMPTY
21182: PPUSH
21183: CALL_OW 1
21187: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
21188: LD_ADDR_EXP 72
21192: PUSH
21193: LD_EXP 72
21197: PPUSH
21198: LD_VAR 0 2
21202: PPUSH
21203: EMPTY
21204: PPUSH
21205: CALL_OW 1
21209: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
21210: LD_ADDR_EXP 61
21214: PUSH
21215: LD_EXP 61
21219: PPUSH
21220: LD_VAR 0 2
21224: PPUSH
21225: LD_INT 0
21227: PPUSH
21228: CALL_OW 1
21232: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
21233: LD_ADDR_EXP 74
21237: PUSH
21238: LD_EXP 74
21242: PPUSH
21243: LD_VAR 0 2
21247: PPUSH
21248: LD_INT 0
21250: PPUSH
21251: CALL_OW 1
21255: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
21256: LD_ADDR_EXP 62
21260: PUSH
21261: LD_EXP 62
21265: PPUSH
21266: LD_VAR 0 2
21270: PPUSH
21271: EMPTY
21272: PPUSH
21273: CALL_OW 1
21277: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
21278: LD_ADDR_EXP 73
21282: PUSH
21283: LD_EXP 73
21287: PPUSH
21288: LD_VAR 0 2
21292: PPUSH
21293: LD_INT 0
21295: PPUSH
21296: CALL_OW 1
21300: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
21301: LD_ADDR_EXP 75
21305: PUSH
21306: LD_EXP 75
21310: PPUSH
21311: LD_VAR 0 2
21315: PPUSH
21316: EMPTY
21317: PPUSH
21318: CALL_OW 1
21322: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
21323: LD_ADDR_EXP 78
21327: PUSH
21328: LD_EXP 78
21332: PPUSH
21333: LD_VAR 0 2
21337: PPUSH
21338: LD_INT 0
21340: PPUSH
21341: CALL_OW 1
21345: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
21346: LD_ADDR_EXP 79
21350: PUSH
21351: LD_EXP 79
21355: PPUSH
21356: LD_VAR 0 2
21360: PPUSH
21361: EMPTY
21362: PPUSH
21363: CALL_OW 1
21367: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
21368: LD_ADDR_EXP 80
21372: PUSH
21373: LD_EXP 80
21377: PPUSH
21378: LD_VAR 0 2
21382: PPUSH
21383: EMPTY
21384: PPUSH
21385: CALL_OW 1
21389: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
21390: LD_ADDR_EXP 81
21394: PUSH
21395: LD_EXP 81
21399: PPUSH
21400: LD_VAR 0 2
21404: PPUSH
21405: EMPTY
21406: PPUSH
21407: CALL_OW 1
21411: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
21412: LD_ADDR_EXP 83
21416: PUSH
21417: LD_EXP 83
21421: PPUSH
21422: LD_VAR 0 2
21426: PPUSH
21427: LD_EXP 50
21431: PUSH
21432: LD_VAR 0 2
21436: ARRAY
21437: PPUSH
21438: LD_INT 2
21440: PUSH
21441: LD_INT 30
21443: PUSH
21444: LD_INT 6
21446: PUSH
21447: EMPTY
21448: LIST
21449: LIST
21450: PUSH
21451: LD_INT 30
21453: PUSH
21454: LD_INT 7
21456: PUSH
21457: EMPTY
21458: LIST
21459: LIST
21460: PUSH
21461: LD_INT 30
21463: PUSH
21464: LD_INT 8
21466: PUSH
21467: EMPTY
21468: LIST
21469: LIST
21470: PUSH
21471: EMPTY
21472: LIST
21473: LIST
21474: LIST
21475: LIST
21476: PPUSH
21477: CALL_OW 72
21481: PPUSH
21482: CALL_OW 1
21486: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21487: LD_ADDR_EXP 84
21491: PUSH
21492: LD_EXP 84
21496: PPUSH
21497: LD_VAR 0 2
21501: PPUSH
21502: EMPTY
21503: PPUSH
21504: CALL_OW 1
21508: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21509: LD_ADDR_EXP 85
21513: PUSH
21514: LD_EXP 85
21518: PPUSH
21519: LD_VAR 0 2
21523: PPUSH
21524: EMPTY
21525: PPUSH
21526: CALL_OW 1
21530: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21531: LD_ADDR_EXP 86
21535: PUSH
21536: LD_EXP 86
21540: PPUSH
21541: LD_VAR 0 2
21545: PPUSH
21546: EMPTY
21547: PPUSH
21548: CALL_OW 1
21552: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21553: LD_ADDR_EXP 87
21557: PUSH
21558: LD_EXP 87
21562: PPUSH
21563: LD_VAR 0 2
21567: PPUSH
21568: EMPTY
21569: PPUSH
21570: CALL_OW 1
21574: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21575: LD_ADDR_EXP 88
21579: PUSH
21580: LD_EXP 88
21584: PPUSH
21585: LD_VAR 0 2
21589: PPUSH
21590: EMPTY
21591: PPUSH
21592: CALL_OW 1
21596: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21597: LD_ADDR_EXP 89
21601: PUSH
21602: LD_EXP 89
21606: PPUSH
21607: LD_VAR 0 2
21611: PPUSH
21612: EMPTY
21613: PPUSH
21614: CALL_OW 1
21618: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21619: LD_ADDR_EXP 90
21623: PUSH
21624: LD_EXP 90
21628: PPUSH
21629: LD_VAR 0 2
21633: PPUSH
21634: EMPTY
21635: PPUSH
21636: CALL_OW 1
21640: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21641: LD_ADDR_EXP 91
21645: PUSH
21646: LD_EXP 91
21650: PPUSH
21651: LD_VAR 0 2
21655: PPUSH
21656: EMPTY
21657: PPUSH
21658: CALL_OW 1
21662: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21663: LD_ADDR_EXP 92
21667: PUSH
21668: LD_EXP 92
21672: PPUSH
21673: LD_VAR 0 2
21677: PPUSH
21678: LD_INT 0
21680: PPUSH
21681: CALL_OW 1
21685: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21686: LD_ADDR_EXP 93
21690: PUSH
21691: LD_EXP 93
21695: PPUSH
21696: LD_VAR 0 2
21700: PPUSH
21701: LD_INT 0
21703: PPUSH
21704: CALL_OW 1
21708: ST_TO_ADDR
// end ;
21709: GO 20610
21711: POP
21712: POP
// MC_InitSides ( ) ;
21713: CALL 21999 0 0
// MC_InitResearch ( ) ;
21717: CALL 21738 0 0
// CustomInitMacro ( ) ;
21721: CALL 304 0 0
// skirmish := true ;
21725: LD_ADDR_EXP 48
21729: PUSH
21730: LD_INT 1
21732: ST_TO_ADDR
// end ;
21733: LD_VAR 0 1
21737: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21738: LD_INT 0
21740: PPUSH
21741: PPUSH
21742: PPUSH
21743: PPUSH
21744: PPUSH
21745: PPUSH
// if not mc_bases then
21746: LD_EXP 50
21750: NOT
21751: IFFALSE 21755
// exit ;
21753: GO 21994
// for i = 1 to 8 do
21755: LD_ADDR_VAR 0 2
21759: PUSH
21760: DOUBLE
21761: LD_INT 1
21763: DEC
21764: ST_TO_ADDR
21765: LD_INT 8
21767: PUSH
21768: FOR_TO
21769: IFFALSE 21795
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21771: LD_ADDR_EXP 77
21775: PUSH
21776: LD_EXP 77
21780: PPUSH
21781: LD_VAR 0 2
21785: PPUSH
21786: EMPTY
21787: PPUSH
21788: CALL_OW 1
21792: ST_TO_ADDR
21793: GO 21768
21795: POP
21796: POP
// tmp := [ ] ;
21797: LD_ADDR_VAR 0 5
21801: PUSH
21802: EMPTY
21803: ST_TO_ADDR
// for i = 1 to mc_sides do
21804: LD_ADDR_VAR 0 2
21808: PUSH
21809: DOUBLE
21810: LD_INT 1
21812: DEC
21813: ST_TO_ADDR
21814: LD_EXP 76
21818: PUSH
21819: FOR_TO
21820: IFFALSE 21878
// if not mc_sides [ i ] in tmp then
21822: LD_EXP 76
21826: PUSH
21827: LD_VAR 0 2
21831: ARRAY
21832: PUSH
21833: LD_VAR 0 5
21837: IN
21838: NOT
21839: IFFALSE 21876
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21841: LD_ADDR_VAR 0 5
21845: PUSH
21846: LD_VAR 0 5
21850: PPUSH
21851: LD_VAR 0 5
21855: PUSH
21856: LD_INT 1
21858: PLUS
21859: PPUSH
21860: LD_EXP 76
21864: PUSH
21865: LD_VAR 0 2
21869: ARRAY
21870: PPUSH
21871: CALL_OW 2
21875: ST_TO_ADDR
21876: GO 21819
21878: POP
21879: POP
// if not tmp then
21880: LD_VAR 0 5
21884: NOT
21885: IFFALSE 21889
// exit ;
21887: GO 21994
// for j in tmp do
21889: LD_ADDR_VAR 0 3
21893: PUSH
21894: LD_VAR 0 5
21898: PUSH
21899: FOR_IN
21900: IFFALSE 21992
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21902: LD_ADDR_VAR 0 6
21906: PUSH
21907: LD_INT 22
21909: PUSH
21910: LD_VAR 0 3
21914: PUSH
21915: EMPTY
21916: LIST
21917: LIST
21918: PPUSH
21919: CALL_OW 69
21923: ST_TO_ADDR
// if not un then
21924: LD_VAR 0 6
21928: NOT
21929: IFFALSE 21933
// continue ;
21931: GO 21899
// nation := GetNation ( un [ 1 ] ) ;
21933: LD_ADDR_VAR 0 4
21937: PUSH
21938: LD_VAR 0 6
21942: PUSH
21943: LD_INT 1
21945: ARRAY
21946: PPUSH
21947: CALL_OW 248
21951: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21952: LD_ADDR_EXP 77
21956: PUSH
21957: LD_EXP 77
21961: PPUSH
21962: LD_VAR 0 3
21966: PPUSH
21967: LD_VAR 0 3
21971: PPUSH
21972: LD_VAR 0 4
21976: PPUSH
21977: LD_INT 1
21979: PPUSH
21980: CALL 49182 0 3
21984: PPUSH
21985: CALL_OW 1
21989: ST_TO_ADDR
// end ;
21990: GO 21899
21992: POP
21993: POP
// end ;
21994: LD_VAR 0 1
21998: RET
// export function MC_InitSides ( ) ; var i ; begin
21999: LD_INT 0
22001: PPUSH
22002: PPUSH
// if not mc_bases then
22003: LD_EXP 50
22007: NOT
22008: IFFALSE 22012
// exit ;
22010: GO 22086
// for i = 1 to mc_bases do
22012: LD_ADDR_VAR 0 2
22016: PUSH
22017: DOUBLE
22018: LD_INT 1
22020: DEC
22021: ST_TO_ADDR
22022: LD_EXP 50
22026: PUSH
22027: FOR_TO
22028: IFFALSE 22084
// if mc_bases [ i ] then
22030: LD_EXP 50
22034: PUSH
22035: LD_VAR 0 2
22039: ARRAY
22040: IFFALSE 22082
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
22042: LD_ADDR_EXP 76
22046: PUSH
22047: LD_EXP 76
22051: PPUSH
22052: LD_VAR 0 2
22056: PPUSH
22057: LD_EXP 50
22061: PUSH
22062: LD_VAR 0 2
22066: ARRAY
22067: PUSH
22068: LD_INT 1
22070: ARRAY
22071: PPUSH
22072: CALL_OW 255
22076: PPUSH
22077: CALL_OW 1
22081: ST_TO_ADDR
22082: GO 22027
22084: POP
22085: POP
// end ;
22086: LD_VAR 0 1
22090: RET
// every 0 0$03 trigger skirmish do
22091: LD_EXP 48
22095: IFFALSE 22249
22097: GO 22099
22099: DISABLE
// begin enable ;
22100: ENABLE
// MC_CheckBuildings ( ) ;
22101: CALL 26761 0 0
// MC_CheckPeopleLife ( ) ;
22105: CALL 26922 0 0
// RaiseSailEvent ( 100 ) ;
22109: LD_INT 100
22111: PPUSH
22112: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
22116: LD_INT 103
22118: PPUSH
22119: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
22123: LD_INT 104
22125: PPUSH
22126: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
22130: LD_INT 105
22132: PPUSH
22133: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
22137: LD_INT 106
22139: PPUSH
22140: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
22144: LD_INT 107
22146: PPUSH
22147: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
22151: LD_INT 108
22153: PPUSH
22154: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
22158: LD_INT 109
22160: PPUSH
22161: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
22165: LD_INT 110
22167: PPUSH
22168: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
22172: LD_INT 111
22174: PPUSH
22175: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
22179: LD_INT 112
22181: PPUSH
22182: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
22186: LD_INT 113
22188: PPUSH
22189: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
22193: LD_INT 120
22195: PPUSH
22196: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
22200: LD_INT 121
22202: PPUSH
22203: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
22207: LD_INT 122
22209: PPUSH
22210: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
22214: LD_INT 123
22216: PPUSH
22217: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
22221: LD_INT 124
22223: PPUSH
22224: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
22228: LD_INT 125
22230: PPUSH
22231: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
22235: LD_INT 126
22237: PPUSH
22238: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
22242: LD_INT 200
22244: PPUSH
22245: CALL_OW 427
// end ;
22249: END
// on SailEvent ( event ) do begin if event < 100 then
22250: LD_VAR 0 1
22254: PUSH
22255: LD_INT 100
22257: LESS
22258: IFFALSE 22269
// CustomEvent ( event ) ;
22260: LD_VAR 0 1
22264: PPUSH
22265: CALL 17412 0 1
// if event = 100 then
22269: LD_VAR 0 1
22273: PUSH
22274: LD_INT 100
22276: EQUAL
22277: IFFALSE 22283
// MC_ClassManager ( ) ;
22279: CALL 22675 0 0
// if event = 101 then
22283: LD_VAR 0 1
22287: PUSH
22288: LD_INT 101
22290: EQUAL
22291: IFFALSE 22297
// MC_RepairBuildings ( ) ;
22293: CALL 27507 0 0
// if event = 102 then
22297: LD_VAR 0 1
22301: PUSH
22302: LD_INT 102
22304: EQUAL
22305: IFFALSE 22311
// MC_Heal ( ) ;
22307: CALL 28442 0 0
// if event = 103 then
22311: LD_VAR 0 1
22315: PUSH
22316: LD_INT 103
22318: EQUAL
22319: IFFALSE 22325
// MC_Build ( ) ;
22321: CALL 28864 0 0
// if event = 104 then
22325: LD_VAR 0 1
22329: PUSH
22330: LD_INT 104
22332: EQUAL
22333: IFFALSE 22339
// MC_TurretWeapon ( ) ;
22335: CALL 30498 0 0
// if event = 105 then
22339: LD_VAR 0 1
22343: PUSH
22344: LD_INT 105
22346: EQUAL
22347: IFFALSE 22353
// MC_BuildUpgrade ( ) ;
22349: CALL 30049 0 0
// if event = 106 then
22353: LD_VAR 0 1
22357: PUSH
22358: LD_INT 106
22360: EQUAL
22361: IFFALSE 22367
// MC_PlantMines ( ) ;
22363: CALL 30928 0 0
// if event = 107 then
22367: LD_VAR 0 1
22371: PUSH
22372: LD_INT 107
22374: EQUAL
22375: IFFALSE 22381
// MC_CollectCrates ( ) ;
22377: CALL 31726 0 0
// if event = 108 then
22381: LD_VAR 0 1
22385: PUSH
22386: LD_INT 108
22388: EQUAL
22389: IFFALSE 22395
// MC_LinkRemoteControl ( ) ;
22391: CALL 33576 0 0
// if event = 109 then
22395: LD_VAR 0 1
22399: PUSH
22400: LD_INT 109
22402: EQUAL
22403: IFFALSE 22409
// MC_ProduceVehicle ( ) ;
22405: CALL 33757 0 0
// if event = 110 then
22409: LD_VAR 0 1
22413: PUSH
22414: LD_INT 110
22416: EQUAL
22417: IFFALSE 22423
// MC_SendAttack ( ) ;
22419: CALL 34223 0 0
// if event = 111 then
22423: LD_VAR 0 1
22427: PUSH
22428: LD_INT 111
22430: EQUAL
22431: IFFALSE 22437
// MC_Defend ( ) ;
22433: CALL 34331 0 0
// if event = 112 then
22437: LD_VAR 0 1
22441: PUSH
22442: LD_INT 112
22444: EQUAL
22445: IFFALSE 22451
// MC_Research ( ) ;
22447: CALL 35211 0 0
// if event = 113 then
22451: LD_VAR 0 1
22455: PUSH
22456: LD_INT 113
22458: EQUAL
22459: IFFALSE 22465
// MC_MinesTrigger ( ) ;
22461: CALL 36325 0 0
// if event = 120 then
22465: LD_VAR 0 1
22469: PUSH
22470: LD_INT 120
22472: EQUAL
22473: IFFALSE 22479
// MC_RepairVehicle ( ) ;
22475: CALL 36424 0 0
// if event = 121 then
22479: LD_VAR 0 1
22483: PUSH
22484: LD_INT 121
22486: EQUAL
22487: IFFALSE 22493
// MC_TameApe ( ) ;
22489: CALL 37193 0 0
// if event = 122 then
22493: LD_VAR 0 1
22497: PUSH
22498: LD_INT 122
22500: EQUAL
22501: IFFALSE 22507
// MC_ChangeApeClass ( ) ;
22503: CALL 38022 0 0
// if event = 123 then
22507: LD_VAR 0 1
22511: PUSH
22512: LD_INT 123
22514: EQUAL
22515: IFFALSE 22521
// MC_Bazooka ( ) ;
22517: CALL 38672 0 0
// if event = 124 then
22521: LD_VAR 0 1
22525: PUSH
22526: LD_INT 124
22528: EQUAL
22529: IFFALSE 22535
// MC_TeleportExit ( ) ;
22531: CALL 38870 0 0
// if event = 125 then
22535: LD_VAR 0 1
22539: PUSH
22540: LD_INT 125
22542: EQUAL
22543: IFFALSE 22549
// MC_Deposits ( ) ;
22545: CALL 39517 0 0
// if event = 126 then
22549: LD_VAR 0 1
22553: PUSH
22554: LD_INT 126
22556: EQUAL
22557: IFFALSE 22563
// MC_RemoteDriver ( ) ;
22559: CALL 40142 0 0
// if event = 200 then
22563: LD_VAR 0 1
22567: PUSH
22568: LD_INT 200
22570: EQUAL
22571: IFFALSE 22577
// MC_Idle ( ) ;
22573: CALL 42049 0 0
// end ;
22577: PPOPN 1
22579: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22580: LD_INT 0
22582: PPUSH
22583: PPUSH
// if not mc_bases [ base ] or not tag then
22584: LD_EXP 50
22588: PUSH
22589: LD_VAR 0 1
22593: ARRAY
22594: NOT
22595: PUSH
22596: LD_VAR 0 2
22600: NOT
22601: OR
22602: IFFALSE 22606
// exit ;
22604: GO 22670
// for i in mc_bases [ base ] union mc_ape [ base ] do
22606: LD_ADDR_VAR 0 4
22610: PUSH
22611: LD_EXP 50
22615: PUSH
22616: LD_VAR 0 1
22620: ARRAY
22621: PUSH
22622: LD_EXP 79
22626: PUSH
22627: LD_VAR 0 1
22631: ARRAY
22632: UNION
22633: PUSH
22634: FOR_IN
22635: IFFALSE 22668
// if GetTag ( i ) = tag then
22637: LD_VAR 0 4
22641: PPUSH
22642: CALL_OW 110
22646: PUSH
22647: LD_VAR 0 2
22651: EQUAL
22652: IFFALSE 22666
// SetTag ( i , 0 ) ;
22654: LD_VAR 0 4
22658: PPUSH
22659: LD_INT 0
22661: PPUSH
22662: CALL_OW 109
22666: GO 22634
22668: POP
22669: POP
// end ;
22670: LD_VAR 0 3
22674: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22675: LD_INT 0
22677: PPUSH
22678: PPUSH
22679: PPUSH
22680: PPUSH
22681: PPUSH
22682: PPUSH
22683: PPUSH
22684: PPUSH
// if not mc_bases then
22685: LD_EXP 50
22689: NOT
22690: IFFALSE 22694
// exit ;
22692: GO 23143
// for i = 1 to mc_bases do
22694: LD_ADDR_VAR 0 2
22698: PUSH
22699: DOUBLE
22700: LD_INT 1
22702: DEC
22703: ST_TO_ADDR
22704: LD_EXP 50
22708: PUSH
22709: FOR_TO
22710: IFFALSE 23141
// begin tmp := MC_ClassCheckReq ( i ) ;
22712: LD_ADDR_VAR 0 4
22716: PUSH
22717: LD_VAR 0 2
22721: PPUSH
22722: CALL 23148 0 1
22726: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22727: LD_ADDR_EXP 91
22731: PUSH
22732: LD_EXP 91
22736: PPUSH
22737: LD_VAR 0 2
22741: PPUSH
22742: LD_VAR 0 4
22746: PPUSH
22747: CALL_OW 1
22751: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22752: LD_ADDR_VAR 0 6
22756: PUSH
22757: LD_EXP 50
22761: PUSH
22762: LD_VAR 0 2
22766: ARRAY
22767: PPUSH
22768: LD_INT 2
22770: PUSH
22771: LD_INT 30
22773: PUSH
22774: LD_INT 4
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: PUSH
22781: LD_INT 30
22783: PUSH
22784: LD_INT 5
22786: PUSH
22787: EMPTY
22788: LIST
22789: LIST
22790: PUSH
22791: EMPTY
22792: LIST
22793: LIST
22794: LIST
22795: PPUSH
22796: CALL_OW 72
22800: PUSH
22801: LD_EXP 50
22805: PUSH
22806: LD_VAR 0 2
22810: ARRAY
22811: PPUSH
22812: LD_INT 2
22814: PUSH
22815: LD_INT 30
22817: PUSH
22818: LD_INT 0
22820: PUSH
22821: EMPTY
22822: LIST
22823: LIST
22824: PUSH
22825: LD_INT 30
22827: PUSH
22828: LD_INT 1
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: PUSH
22835: EMPTY
22836: LIST
22837: LIST
22838: LIST
22839: PPUSH
22840: CALL_OW 72
22844: PUSH
22845: LD_EXP 50
22849: PUSH
22850: LD_VAR 0 2
22854: ARRAY
22855: PPUSH
22856: LD_INT 30
22858: PUSH
22859: LD_INT 3
22861: PUSH
22862: EMPTY
22863: LIST
22864: LIST
22865: PPUSH
22866: CALL_OW 72
22870: PUSH
22871: LD_EXP 50
22875: PUSH
22876: LD_VAR 0 2
22880: ARRAY
22881: PPUSH
22882: LD_INT 2
22884: PUSH
22885: LD_INT 30
22887: PUSH
22888: LD_INT 6
22890: PUSH
22891: EMPTY
22892: LIST
22893: LIST
22894: PUSH
22895: LD_INT 30
22897: PUSH
22898: LD_INT 7
22900: PUSH
22901: EMPTY
22902: LIST
22903: LIST
22904: PUSH
22905: LD_INT 30
22907: PUSH
22908: LD_INT 8
22910: PUSH
22911: EMPTY
22912: LIST
22913: LIST
22914: PUSH
22915: EMPTY
22916: LIST
22917: LIST
22918: LIST
22919: LIST
22920: PPUSH
22921: CALL_OW 72
22925: PUSH
22926: EMPTY
22927: LIST
22928: LIST
22929: LIST
22930: LIST
22931: ST_TO_ADDR
// for j := 1 to 4 do
22932: LD_ADDR_VAR 0 3
22936: PUSH
22937: DOUBLE
22938: LD_INT 1
22940: DEC
22941: ST_TO_ADDR
22942: LD_INT 4
22944: PUSH
22945: FOR_TO
22946: IFFALSE 23137
// begin if not tmp [ j ] then
22948: LD_VAR 0 4
22952: PUSH
22953: LD_VAR 0 3
22957: ARRAY
22958: NOT
22959: IFFALSE 22963
// continue ;
22961: GO 22945
// for p in tmp [ j ] do
22963: LD_ADDR_VAR 0 5
22967: PUSH
22968: LD_VAR 0 4
22972: PUSH
22973: LD_VAR 0 3
22977: ARRAY
22978: PUSH
22979: FOR_IN
22980: IFFALSE 23133
// begin if not b [ j ] then
22982: LD_VAR 0 6
22986: PUSH
22987: LD_VAR 0 3
22991: ARRAY
22992: NOT
22993: IFFALSE 22997
// break ;
22995: GO 23133
// e := 0 ;
22997: LD_ADDR_VAR 0 7
23001: PUSH
23002: LD_INT 0
23004: ST_TO_ADDR
// for k in b [ j ] do
23005: LD_ADDR_VAR 0 8
23009: PUSH
23010: LD_VAR 0 6
23014: PUSH
23015: LD_VAR 0 3
23019: ARRAY
23020: PUSH
23021: FOR_IN
23022: IFFALSE 23049
// if IsNotFull ( k ) then
23024: LD_VAR 0 8
23028: PPUSH
23029: CALL 51303 0 1
23033: IFFALSE 23047
// begin e := k ;
23035: LD_ADDR_VAR 0 7
23039: PUSH
23040: LD_VAR 0 8
23044: ST_TO_ADDR
// break ;
23045: GO 23049
// end ;
23047: GO 23021
23049: POP
23050: POP
// if e and not UnitGoingToBuilding ( p , e ) then
23051: LD_VAR 0 7
23055: PUSH
23056: LD_VAR 0 5
23060: PPUSH
23061: LD_VAR 0 7
23065: PPUSH
23066: CALL 85453 0 2
23070: NOT
23071: AND
23072: IFFALSE 23131
// begin if IsInUnit ( p ) then
23074: LD_VAR 0 5
23078: PPUSH
23079: CALL_OW 310
23083: IFFALSE 23094
// ComExitBuilding ( p ) ;
23085: LD_VAR 0 5
23089: PPUSH
23090: CALL_OW 122
// ComEnterUnit ( p , e ) ;
23094: LD_VAR 0 5
23098: PPUSH
23099: LD_VAR 0 7
23103: PPUSH
23104: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
23108: LD_VAR 0 5
23112: PPUSH
23113: LD_VAR 0 3
23117: PPUSH
23118: CALL_OW 183
// AddComExitBuilding ( p ) ;
23122: LD_VAR 0 5
23126: PPUSH
23127: CALL_OW 182
// end ; end ;
23131: GO 22979
23133: POP
23134: POP
// end ;
23135: GO 22945
23137: POP
23138: POP
// end ;
23139: GO 22709
23141: POP
23142: POP
// end ;
23143: LD_VAR 0 1
23147: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
23148: LD_INT 0
23150: PPUSH
23151: PPUSH
23152: PPUSH
23153: PPUSH
23154: PPUSH
23155: PPUSH
23156: PPUSH
23157: PPUSH
23158: PPUSH
23159: PPUSH
23160: PPUSH
23161: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
23162: LD_ADDR_VAR 0 2
23166: PUSH
23167: LD_INT 0
23169: PUSH
23170: LD_INT 0
23172: PUSH
23173: LD_INT 0
23175: PUSH
23176: LD_INT 0
23178: PUSH
23179: EMPTY
23180: LIST
23181: LIST
23182: LIST
23183: LIST
23184: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
23185: LD_VAR 0 1
23189: NOT
23190: PUSH
23191: LD_EXP 50
23195: PUSH
23196: LD_VAR 0 1
23200: ARRAY
23201: NOT
23202: OR
23203: PUSH
23204: LD_EXP 50
23208: PUSH
23209: LD_VAR 0 1
23213: ARRAY
23214: PPUSH
23215: LD_INT 2
23217: PUSH
23218: LD_INT 30
23220: PUSH
23221: LD_INT 0
23223: PUSH
23224: EMPTY
23225: LIST
23226: LIST
23227: PUSH
23228: LD_INT 30
23230: PUSH
23231: LD_INT 1
23233: PUSH
23234: EMPTY
23235: LIST
23236: LIST
23237: PUSH
23238: EMPTY
23239: LIST
23240: LIST
23241: LIST
23242: PPUSH
23243: CALL_OW 72
23247: NOT
23248: OR
23249: IFFALSE 23253
// exit ;
23251: GO 26756
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23253: LD_ADDR_VAR 0 4
23257: PUSH
23258: LD_EXP 50
23262: PUSH
23263: LD_VAR 0 1
23267: ARRAY
23268: PPUSH
23269: LD_INT 2
23271: PUSH
23272: LD_INT 25
23274: PUSH
23275: LD_INT 1
23277: PUSH
23278: EMPTY
23279: LIST
23280: LIST
23281: PUSH
23282: LD_INT 25
23284: PUSH
23285: LD_INT 2
23287: PUSH
23288: EMPTY
23289: LIST
23290: LIST
23291: PUSH
23292: LD_INT 25
23294: PUSH
23295: LD_INT 3
23297: PUSH
23298: EMPTY
23299: LIST
23300: LIST
23301: PUSH
23302: LD_INT 25
23304: PUSH
23305: LD_INT 4
23307: PUSH
23308: EMPTY
23309: LIST
23310: LIST
23311: PUSH
23312: LD_INT 25
23314: PUSH
23315: LD_INT 5
23317: PUSH
23318: EMPTY
23319: LIST
23320: LIST
23321: PUSH
23322: LD_INT 25
23324: PUSH
23325: LD_INT 8
23327: PUSH
23328: EMPTY
23329: LIST
23330: LIST
23331: PUSH
23332: LD_INT 25
23334: PUSH
23335: LD_INT 9
23337: PUSH
23338: EMPTY
23339: LIST
23340: LIST
23341: PUSH
23342: EMPTY
23343: LIST
23344: LIST
23345: LIST
23346: LIST
23347: LIST
23348: LIST
23349: LIST
23350: LIST
23351: PPUSH
23352: CALL_OW 72
23356: ST_TO_ADDR
// if not tmp then
23357: LD_VAR 0 4
23361: NOT
23362: IFFALSE 23366
// exit ;
23364: GO 26756
// for i in tmp do
23366: LD_ADDR_VAR 0 3
23370: PUSH
23371: LD_VAR 0 4
23375: PUSH
23376: FOR_IN
23377: IFFALSE 23408
// if GetTag ( i ) then
23379: LD_VAR 0 3
23383: PPUSH
23384: CALL_OW 110
23388: IFFALSE 23406
// tmp := tmp diff i ;
23390: LD_ADDR_VAR 0 4
23394: PUSH
23395: LD_VAR 0 4
23399: PUSH
23400: LD_VAR 0 3
23404: DIFF
23405: ST_TO_ADDR
23406: GO 23376
23408: POP
23409: POP
// if not tmp then
23410: LD_VAR 0 4
23414: NOT
23415: IFFALSE 23419
// exit ;
23417: GO 26756
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23419: LD_ADDR_VAR 0 5
23423: PUSH
23424: LD_EXP 50
23428: PUSH
23429: LD_VAR 0 1
23433: ARRAY
23434: PPUSH
23435: LD_INT 2
23437: PUSH
23438: LD_INT 25
23440: PUSH
23441: LD_INT 1
23443: PUSH
23444: EMPTY
23445: LIST
23446: LIST
23447: PUSH
23448: LD_INT 25
23450: PUSH
23451: LD_INT 5
23453: PUSH
23454: EMPTY
23455: LIST
23456: LIST
23457: PUSH
23458: LD_INT 25
23460: PUSH
23461: LD_INT 8
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: PUSH
23468: LD_INT 25
23470: PUSH
23471: LD_INT 9
23473: PUSH
23474: EMPTY
23475: LIST
23476: LIST
23477: PUSH
23478: EMPTY
23479: LIST
23480: LIST
23481: LIST
23482: LIST
23483: LIST
23484: PPUSH
23485: CALL_OW 72
23489: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23490: LD_ADDR_VAR 0 6
23494: PUSH
23495: LD_EXP 50
23499: PUSH
23500: LD_VAR 0 1
23504: ARRAY
23505: PPUSH
23506: LD_INT 25
23508: PUSH
23509: LD_INT 2
23511: PUSH
23512: EMPTY
23513: LIST
23514: LIST
23515: PPUSH
23516: CALL_OW 72
23520: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23521: LD_ADDR_VAR 0 7
23525: PUSH
23526: LD_EXP 50
23530: PUSH
23531: LD_VAR 0 1
23535: ARRAY
23536: PPUSH
23537: LD_INT 25
23539: PUSH
23540: LD_INT 3
23542: PUSH
23543: EMPTY
23544: LIST
23545: LIST
23546: PPUSH
23547: CALL_OW 72
23551: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23552: LD_ADDR_VAR 0 8
23556: PUSH
23557: LD_EXP 50
23561: PUSH
23562: LD_VAR 0 1
23566: ARRAY
23567: PPUSH
23568: LD_INT 25
23570: PUSH
23571: LD_INT 4
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: PUSH
23578: LD_INT 24
23580: PUSH
23581: LD_INT 251
23583: PUSH
23584: EMPTY
23585: LIST
23586: LIST
23587: PUSH
23588: EMPTY
23589: LIST
23590: LIST
23591: PPUSH
23592: CALL_OW 72
23596: ST_TO_ADDR
// if mc_is_defending [ base ] then
23597: LD_EXP 93
23601: PUSH
23602: LD_VAR 0 1
23606: ARRAY
23607: IFFALSE 24068
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23609: LD_ADDR_EXP 92
23613: PUSH
23614: LD_EXP 92
23618: PPUSH
23619: LD_VAR 0 1
23623: PPUSH
23624: LD_INT 4
23626: PPUSH
23627: CALL_OW 1
23631: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23632: LD_ADDR_VAR 0 12
23636: PUSH
23637: LD_EXP 50
23641: PUSH
23642: LD_VAR 0 1
23646: ARRAY
23647: PPUSH
23648: LD_INT 2
23650: PUSH
23651: LD_INT 30
23653: PUSH
23654: LD_INT 4
23656: PUSH
23657: EMPTY
23658: LIST
23659: LIST
23660: PUSH
23661: LD_INT 30
23663: PUSH
23664: LD_INT 5
23666: PUSH
23667: EMPTY
23668: LIST
23669: LIST
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: LIST
23675: PPUSH
23676: CALL_OW 72
23680: ST_TO_ADDR
// if not b then
23681: LD_VAR 0 12
23685: NOT
23686: IFFALSE 23690
// exit ;
23688: GO 26756
// p := [ ] ;
23690: LD_ADDR_VAR 0 11
23694: PUSH
23695: EMPTY
23696: ST_TO_ADDR
// if sci >= 2 then
23697: LD_VAR 0 8
23701: PUSH
23702: LD_INT 2
23704: GREATEREQUAL
23705: IFFALSE 23736
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23707: LD_ADDR_VAR 0 8
23711: PUSH
23712: LD_VAR 0 8
23716: PUSH
23717: LD_INT 1
23719: ARRAY
23720: PUSH
23721: LD_VAR 0 8
23725: PUSH
23726: LD_INT 2
23728: ARRAY
23729: PUSH
23730: EMPTY
23731: LIST
23732: LIST
23733: ST_TO_ADDR
23734: GO 23797
// if sci = 1 then
23736: LD_VAR 0 8
23740: PUSH
23741: LD_INT 1
23743: EQUAL
23744: IFFALSE 23765
// sci := [ sci [ 1 ] ] else
23746: LD_ADDR_VAR 0 8
23750: PUSH
23751: LD_VAR 0 8
23755: PUSH
23756: LD_INT 1
23758: ARRAY
23759: PUSH
23760: EMPTY
23761: LIST
23762: ST_TO_ADDR
23763: GO 23797
// if sci = 0 then
23765: LD_VAR 0 8
23769: PUSH
23770: LD_INT 0
23772: EQUAL
23773: IFFALSE 23797
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23775: LD_ADDR_VAR 0 11
23779: PUSH
23780: LD_VAR 0 4
23784: PPUSH
23785: LD_INT 4
23787: PPUSH
23788: CALL 85325 0 2
23792: PUSH
23793: LD_INT 1
23795: ARRAY
23796: ST_TO_ADDR
// if eng > 4 then
23797: LD_VAR 0 6
23801: PUSH
23802: LD_INT 4
23804: GREATER
23805: IFFALSE 23851
// for i = eng downto 4 do
23807: LD_ADDR_VAR 0 3
23811: PUSH
23812: DOUBLE
23813: LD_VAR 0 6
23817: INC
23818: ST_TO_ADDR
23819: LD_INT 4
23821: PUSH
23822: FOR_DOWNTO
23823: IFFALSE 23849
// eng := eng diff eng [ i ] ;
23825: LD_ADDR_VAR 0 6
23829: PUSH
23830: LD_VAR 0 6
23834: PUSH
23835: LD_VAR 0 6
23839: PUSH
23840: LD_VAR 0 3
23844: ARRAY
23845: DIFF
23846: ST_TO_ADDR
23847: GO 23822
23849: POP
23850: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23851: LD_ADDR_VAR 0 4
23855: PUSH
23856: LD_VAR 0 4
23860: PUSH
23861: LD_VAR 0 5
23865: PUSH
23866: LD_VAR 0 6
23870: UNION
23871: PUSH
23872: LD_VAR 0 7
23876: UNION
23877: PUSH
23878: LD_VAR 0 8
23882: UNION
23883: DIFF
23884: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23885: LD_ADDR_VAR 0 13
23889: PUSH
23890: LD_EXP 50
23894: PUSH
23895: LD_VAR 0 1
23899: ARRAY
23900: PPUSH
23901: LD_INT 2
23903: PUSH
23904: LD_INT 30
23906: PUSH
23907: LD_INT 32
23909: PUSH
23910: EMPTY
23911: LIST
23912: LIST
23913: PUSH
23914: LD_INT 30
23916: PUSH
23917: LD_INT 31
23919: PUSH
23920: EMPTY
23921: LIST
23922: LIST
23923: PUSH
23924: EMPTY
23925: LIST
23926: LIST
23927: LIST
23928: PPUSH
23929: CALL_OW 72
23933: PUSH
23934: LD_EXP 50
23938: PUSH
23939: LD_VAR 0 1
23943: ARRAY
23944: PPUSH
23945: LD_INT 2
23947: PUSH
23948: LD_INT 30
23950: PUSH
23951: LD_INT 4
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: PUSH
23958: LD_INT 30
23960: PUSH
23961: LD_INT 5
23963: PUSH
23964: EMPTY
23965: LIST
23966: LIST
23967: PUSH
23968: EMPTY
23969: LIST
23970: LIST
23971: LIST
23972: PPUSH
23973: CALL_OW 72
23977: PUSH
23978: LD_INT 6
23980: MUL
23981: PLUS
23982: ST_TO_ADDR
// if bcount < tmp then
23983: LD_VAR 0 13
23987: PUSH
23988: LD_VAR 0 4
23992: LESS
23993: IFFALSE 24039
// for i = tmp downto bcount do
23995: LD_ADDR_VAR 0 3
23999: PUSH
24000: DOUBLE
24001: LD_VAR 0 4
24005: INC
24006: ST_TO_ADDR
24007: LD_VAR 0 13
24011: PUSH
24012: FOR_DOWNTO
24013: IFFALSE 24037
// tmp := Delete ( tmp , tmp ) ;
24015: LD_ADDR_VAR 0 4
24019: PUSH
24020: LD_VAR 0 4
24024: PPUSH
24025: LD_VAR 0 4
24029: PPUSH
24030: CALL_OW 3
24034: ST_TO_ADDR
24035: GO 24012
24037: POP
24038: POP
// result := [ tmp , 0 , 0 , p ] ;
24039: LD_ADDR_VAR 0 2
24043: PUSH
24044: LD_VAR 0 4
24048: PUSH
24049: LD_INT 0
24051: PUSH
24052: LD_INT 0
24054: PUSH
24055: LD_VAR 0 11
24059: PUSH
24060: EMPTY
24061: LIST
24062: LIST
24063: LIST
24064: LIST
24065: ST_TO_ADDR
// exit ;
24066: GO 26756
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24068: LD_EXP 50
24072: PUSH
24073: LD_VAR 0 1
24077: ARRAY
24078: PPUSH
24079: LD_INT 2
24081: PUSH
24082: LD_INT 30
24084: PUSH
24085: LD_INT 6
24087: PUSH
24088: EMPTY
24089: LIST
24090: LIST
24091: PUSH
24092: LD_INT 30
24094: PUSH
24095: LD_INT 7
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: PUSH
24102: LD_INT 30
24104: PUSH
24105: LD_INT 8
24107: PUSH
24108: EMPTY
24109: LIST
24110: LIST
24111: PUSH
24112: EMPTY
24113: LIST
24114: LIST
24115: LIST
24116: LIST
24117: PPUSH
24118: CALL_OW 72
24122: NOT
24123: PUSH
24124: LD_EXP 50
24128: PUSH
24129: LD_VAR 0 1
24133: ARRAY
24134: PPUSH
24135: LD_INT 30
24137: PUSH
24138: LD_INT 3
24140: PUSH
24141: EMPTY
24142: LIST
24143: LIST
24144: PPUSH
24145: CALL_OW 72
24149: NOT
24150: AND
24151: IFFALSE 24223
// begin if eng = tmp then
24153: LD_VAR 0 6
24157: PUSH
24158: LD_VAR 0 4
24162: EQUAL
24163: IFFALSE 24167
// exit ;
24165: GO 26756
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
24167: LD_ADDR_EXP 92
24171: PUSH
24172: LD_EXP 92
24176: PPUSH
24177: LD_VAR 0 1
24181: PPUSH
24182: LD_INT 1
24184: PPUSH
24185: CALL_OW 1
24189: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
24190: LD_ADDR_VAR 0 2
24194: PUSH
24195: LD_INT 0
24197: PUSH
24198: LD_VAR 0 4
24202: PUSH
24203: LD_VAR 0 6
24207: DIFF
24208: PUSH
24209: LD_INT 0
24211: PUSH
24212: LD_INT 0
24214: PUSH
24215: EMPTY
24216: LIST
24217: LIST
24218: LIST
24219: LIST
24220: ST_TO_ADDR
// exit ;
24221: GO 26756
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24223: LD_EXP 77
24227: PUSH
24228: LD_EXP 76
24232: PUSH
24233: LD_VAR 0 1
24237: ARRAY
24238: ARRAY
24239: PUSH
24240: LD_EXP 50
24244: PUSH
24245: LD_VAR 0 1
24249: ARRAY
24250: PPUSH
24251: LD_INT 2
24253: PUSH
24254: LD_INT 30
24256: PUSH
24257: LD_INT 6
24259: PUSH
24260: EMPTY
24261: LIST
24262: LIST
24263: PUSH
24264: LD_INT 30
24266: PUSH
24267: LD_INT 7
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: PUSH
24274: LD_INT 30
24276: PUSH
24277: LD_INT 8
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: PUSH
24284: EMPTY
24285: LIST
24286: LIST
24287: LIST
24288: LIST
24289: PPUSH
24290: CALL_OW 72
24294: AND
24295: PUSH
24296: LD_EXP 50
24300: PUSH
24301: LD_VAR 0 1
24305: ARRAY
24306: PPUSH
24307: LD_INT 30
24309: PUSH
24310: LD_INT 3
24312: PUSH
24313: EMPTY
24314: LIST
24315: LIST
24316: PPUSH
24317: CALL_OW 72
24321: NOT
24322: AND
24323: IFFALSE 24537
// begin if sci >= 6 then
24325: LD_VAR 0 8
24329: PUSH
24330: LD_INT 6
24332: GREATEREQUAL
24333: IFFALSE 24337
// exit ;
24335: GO 26756
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
24337: LD_ADDR_EXP 92
24341: PUSH
24342: LD_EXP 92
24346: PPUSH
24347: LD_VAR 0 1
24351: PPUSH
24352: LD_INT 2
24354: PPUSH
24355: CALL_OW 1
24359: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
24360: LD_ADDR_VAR 0 9
24364: PUSH
24365: LD_VAR 0 4
24369: PUSH
24370: LD_VAR 0 8
24374: DIFF
24375: PPUSH
24376: LD_INT 4
24378: PPUSH
24379: CALL 85325 0 2
24383: ST_TO_ADDR
// p := [ ] ;
24384: LD_ADDR_VAR 0 11
24388: PUSH
24389: EMPTY
24390: ST_TO_ADDR
// if sci < 6 and sort > 6 then
24391: LD_VAR 0 8
24395: PUSH
24396: LD_INT 6
24398: LESS
24399: PUSH
24400: LD_VAR 0 9
24404: PUSH
24405: LD_INT 6
24407: GREATER
24408: AND
24409: IFFALSE 24490
// begin for i = 1 to 6 - sci do
24411: LD_ADDR_VAR 0 3
24415: PUSH
24416: DOUBLE
24417: LD_INT 1
24419: DEC
24420: ST_TO_ADDR
24421: LD_INT 6
24423: PUSH
24424: LD_VAR 0 8
24428: MINUS
24429: PUSH
24430: FOR_TO
24431: IFFALSE 24486
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
24433: LD_ADDR_VAR 0 11
24437: PUSH
24438: LD_VAR 0 11
24442: PPUSH
24443: LD_VAR 0 11
24447: PUSH
24448: LD_INT 1
24450: PLUS
24451: PPUSH
24452: LD_VAR 0 9
24456: PUSH
24457: LD_INT 1
24459: ARRAY
24460: PPUSH
24461: CALL_OW 2
24465: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24466: LD_ADDR_VAR 0 9
24470: PUSH
24471: LD_VAR 0 9
24475: PPUSH
24476: LD_INT 1
24478: PPUSH
24479: CALL_OW 3
24483: ST_TO_ADDR
// end ;
24484: GO 24430
24486: POP
24487: POP
// end else
24488: GO 24510
// if sort then
24490: LD_VAR 0 9
24494: IFFALSE 24510
// p := sort [ 1 ] ;
24496: LD_ADDR_VAR 0 11
24500: PUSH
24501: LD_VAR 0 9
24505: PUSH
24506: LD_INT 1
24508: ARRAY
24509: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24510: LD_ADDR_VAR 0 2
24514: PUSH
24515: LD_INT 0
24517: PUSH
24518: LD_INT 0
24520: PUSH
24521: LD_INT 0
24523: PUSH
24524: LD_VAR 0 11
24528: PUSH
24529: EMPTY
24530: LIST
24531: LIST
24532: LIST
24533: LIST
24534: ST_TO_ADDR
// exit ;
24535: GO 26756
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24537: LD_EXP 77
24541: PUSH
24542: LD_EXP 76
24546: PUSH
24547: LD_VAR 0 1
24551: ARRAY
24552: ARRAY
24553: PUSH
24554: LD_EXP 50
24558: PUSH
24559: LD_VAR 0 1
24563: ARRAY
24564: PPUSH
24565: LD_INT 2
24567: PUSH
24568: LD_INT 30
24570: PUSH
24571: LD_INT 6
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PUSH
24578: LD_INT 30
24580: PUSH
24581: LD_INT 7
24583: PUSH
24584: EMPTY
24585: LIST
24586: LIST
24587: PUSH
24588: LD_INT 30
24590: PUSH
24591: LD_INT 8
24593: PUSH
24594: EMPTY
24595: LIST
24596: LIST
24597: PUSH
24598: EMPTY
24599: LIST
24600: LIST
24601: LIST
24602: LIST
24603: PPUSH
24604: CALL_OW 72
24608: AND
24609: PUSH
24610: LD_EXP 50
24614: PUSH
24615: LD_VAR 0 1
24619: ARRAY
24620: PPUSH
24621: LD_INT 30
24623: PUSH
24624: LD_INT 3
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PPUSH
24631: CALL_OW 72
24635: AND
24636: IFFALSE 25370
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24638: LD_ADDR_EXP 92
24642: PUSH
24643: LD_EXP 92
24647: PPUSH
24648: LD_VAR 0 1
24652: PPUSH
24653: LD_INT 3
24655: PPUSH
24656: CALL_OW 1
24660: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24661: LD_ADDR_VAR 0 2
24665: PUSH
24666: LD_INT 0
24668: PUSH
24669: LD_INT 0
24671: PUSH
24672: LD_INT 0
24674: PUSH
24675: LD_INT 0
24677: PUSH
24678: EMPTY
24679: LIST
24680: LIST
24681: LIST
24682: LIST
24683: ST_TO_ADDR
// if not eng then
24684: LD_VAR 0 6
24688: NOT
24689: IFFALSE 24752
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24691: LD_ADDR_VAR 0 11
24695: PUSH
24696: LD_VAR 0 4
24700: PPUSH
24701: LD_INT 2
24703: PPUSH
24704: CALL 85325 0 2
24708: PUSH
24709: LD_INT 1
24711: ARRAY
24712: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24713: LD_ADDR_VAR 0 2
24717: PUSH
24718: LD_VAR 0 2
24722: PPUSH
24723: LD_INT 2
24725: PPUSH
24726: LD_VAR 0 11
24730: PPUSH
24731: CALL_OW 1
24735: ST_TO_ADDR
// tmp := tmp diff p ;
24736: LD_ADDR_VAR 0 4
24740: PUSH
24741: LD_VAR 0 4
24745: PUSH
24746: LD_VAR 0 11
24750: DIFF
24751: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24752: LD_VAR 0 4
24756: PUSH
24757: LD_VAR 0 8
24761: PUSH
24762: LD_INT 6
24764: LESS
24765: AND
24766: IFFALSE 24954
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24768: LD_ADDR_VAR 0 9
24772: PUSH
24773: LD_VAR 0 4
24777: PUSH
24778: LD_VAR 0 8
24782: PUSH
24783: LD_VAR 0 7
24787: UNION
24788: DIFF
24789: PPUSH
24790: LD_INT 4
24792: PPUSH
24793: CALL 85325 0 2
24797: ST_TO_ADDR
// p := [ ] ;
24798: LD_ADDR_VAR 0 11
24802: PUSH
24803: EMPTY
24804: ST_TO_ADDR
// if sort then
24805: LD_VAR 0 9
24809: IFFALSE 24925
// for i = 1 to 6 - sci do
24811: LD_ADDR_VAR 0 3
24815: PUSH
24816: DOUBLE
24817: LD_INT 1
24819: DEC
24820: ST_TO_ADDR
24821: LD_INT 6
24823: PUSH
24824: LD_VAR 0 8
24828: MINUS
24829: PUSH
24830: FOR_TO
24831: IFFALSE 24923
// begin if i = sort then
24833: LD_VAR 0 3
24837: PUSH
24838: LD_VAR 0 9
24842: EQUAL
24843: IFFALSE 24847
// break ;
24845: GO 24923
// if GetClass ( i ) = 4 then
24847: LD_VAR 0 3
24851: PPUSH
24852: CALL_OW 257
24856: PUSH
24857: LD_INT 4
24859: EQUAL
24860: IFFALSE 24864
// continue ;
24862: GO 24830
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24864: LD_ADDR_VAR 0 11
24868: PUSH
24869: LD_VAR 0 11
24873: PPUSH
24874: LD_VAR 0 11
24878: PUSH
24879: LD_INT 1
24881: PLUS
24882: PPUSH
24883: LD_VAR 0 9
24887: PUSH
24888: LD_VAR 0 3
24892: ARRAY
24893: PPUSH
24894: CALL_OW 2
24898: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24899: LD_ADDR_VAR 0 4
24903: PUSH
24904: LD_VAR 0 4
24908: PUSH
24909: LD_VAR 0 9
24913: PUSH
24914: LD_VAR 0 3
24918: ARRAY
24919: DIFF
24920: ST_TO_ADDR
// end ;
24921: GO 24830
24923: POP
24924: POP
// if p then
24925: LD_VAR 0 11
24929: IFFALSE 24954
// result := Replace ( result , 4 , p ) ;
24931: LD_ADDR_VAR 0 2
24935: PUSH
24936: LD_VAR 0 2
24940: PPUSH
24941: LD_INT 4
24943: PPUSH
24944: LD_VAR 0 11
24948: PPUSH
24949: CALL_OW 1
24953: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24954: LD_VAR 0 4
24958: PUSH
24959: LD_VAR 0 7
24963: PUSH
24964: LD_INT 6
24966: LESS
24967: AND
24968: IFFALSE 25156
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24970: LD_ADDR_VAR 0 9
24974: PUSH
24975: LD_VAR 0 4
24979: PUSH
24980: LD_VAR 0 8
24984: PUSH
24985: LD_VAR 0 7
24989: UNION
24990: DIFF
24991: PPUSH
24992: LD_INT 3
24994: PPUSH
24995: CALL 85325 0 2
24999: ST_TO_ADDR
// p := [ ] ;
25000: LD_ADDR_VAR 0 11
25004: PUSH
25005: EMPTY
25006: ST_TO_ADDR
// if sort then
25007: LD_VAR 0 9
25011: IFFALSE 25127
// for i = 1 to 6 - mech do
25013: LD_ADDR_VAR 0 3
25017: PUSH
25018: DOUBLE
25019: LD_INT 1
25021: DEC
25022: ST_TO_ADDR
25023: LD_INT 6
25025: PUSH
25026: LD_VAR 0 7
25030: MINUS
25031: PUSH
25032: FOR_TO
25033: IFFALSE 25125
// begin if i = sort then
25035: LD_VAR 0 3
25039: PUSH
25040: LD_VAR 0 9
25044: EQUAL
25045: IFFALSE 25049
// break ;
25047: GO 25125
// if GetClass ( i ) = 3 then
25049: LD_VAR 0 3
25053: PPUSH
25054: CALL_OW 257
25058: PUSH
25059: LD_INT 3
25061: EQUAL
25062: IFFALSE 25066
// continue ;
25064: GO 25032
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25066: LD_ADDR_VAR 0 11
25070: PUSH
25071: LD_VAR 0 11
25075: PPUSH
25076: LD_VAR 0 11
25080: PUSH
25081: LD_INT 1
25083: PLUS
25084: PPUSH
25085: LD_VAR 0 9
25089: PUSH
25090: LD_VAR 0 3
25094: ARRAY
25095: PPUSH
25096: CALL_OW 2
25100: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25101: LD_ADDR_VAR 0 4
25105: PUSH
25106: LD_VAR 0 4
25110: PUSH
25111: LD_VAR 0 9
25115: PUSH
25116: LD_VAR 0 3
25120: ARRAY
25121: DIFF
25122: ST_TO_ADDR
// end ;
25123: GO 25032
25125: POP
25126: POP
// if p then
25127: LD_VAR 0 11
25131: IFFALSE 25156
// result := Replace ( result , 3 , p ) ;
25133: LD_ADDR_VAR 0 2
25137: PUSH
25138: LD_VAR 0 2
25142: PPUSH
25143: LD_INT 3
25145: PPUSH
25146: LD_VAR 0 11
25150: PPUSH
25151: CALL_OW 1
25155: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
25156: LD_VAR 0 4
25160: PUSH
25161: LD_INT 6
25163: GREATER
25164: PUSH
25165: LD_VAR 0 6
25169: PUSH
25170: LD_INT 6
25172: LESS
25173: AND
25174: IFFALSE 25368
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25176: LD_ADDR_VAR 0 9
25180: PUSH
25181: LD_VAR 0 4
25185: PUSH
25186: LD_VAR 0 8
25190: PUSH
25191: LD_VAR 0 7
25195: UNION
25196: PUSH
25197: LD_VAR 0 6
25201: UNION
25202: DIFF
25203: PPUSH
25204: LD_INT 2
25206: PPUSH
25207: CALL 85325 0 2
25211: ST_TO_ADDR
// p := [ ] ;
25212: LD_ADDR_VAR 0 11
25216: PUSH
25217: EMPTY
25218: ST_TO_ADDR
// if sort then
25219: LD_VAR 0 9
25223: IFFALSE 25339
// for i = 1 to 6 - eng do
25225: LD_ADDR_VAR 0 3
25229: PUSH
25230: DOUBLE
25231: LD_INT 1
25233: DEC
25234: ST_TO_ADDR
25235: LD_INT 6
25237: PUSH
25238: LD_VAR 0 6
25242: MINUS
25243: PUSH
25244: FOR_TO
25245: IFFALSE 25337
// begin if i = sort then
25247: LD_VAR 0 3
25251: PUSH
25252: LD_VAR 0 9
25256: EQUAL
25257: IFFALSE 25261
// break ;
25259: GO 25337
// if GetClass ( i ) = 2 then
25261: LD_VAR 0 3
25265: PPUSH
25266: CALL_OW 257
25270: PUSH
25271: LD_INT 2
25273: EQUAL
25274: IFFALSE 25278
// continue ;
25276: GO 25244
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25278: LD_ADDR_VAR 0 11
25282: PUSH
25283: LD_VAR 0 11
25287: PPUSH
25288: LD_VAR 0 11
25292: PUSH
25293: LD_INT 1
25295: PLUS
25296: PPUSH
25297: LD_VAR 0 9
25301: PUSH
25302: LD_VAR 0 3
25306: ARRAY
25307: PPUSH
25308: CALL_OW 2
25312: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25313: LD_ADDR_VAR 0 4
25317: PUSH
25318: LD_VAR 0 4
25322: PUSH
25323: LD_VAR 0 9
25327: PUSH
25328: LD_VAR 0 3
25332: ARRAY
25333: DIFF
25334: ST_TO_ADDR
// end ;
25335: GO 25244
25337: POP
25338: POP
// if p then
25339: LD_VAR 0 11
25343: IFFALSE 25368
// result := Replace ( result , 2 , p ) ;
25345: LD_ADDR_VAR 0 2
25349: PUSH
25350: LD_VAR 0 2
25354: PPUSH
25355: LD_INT 2
25357: PPUSH
25358: LD_VAR 0 11
25362: PPUSH
25363: CALL_OW 1
25367: ST_TO_ADDR
// end ; exit ;
25368: GO 26756
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
25370: LD_EXP 77
25374: PUSH
25375: LD_EXP 76
25379: PUSH
25380: LD_VAR 0 1
25384: ARRAY
25385: ARRAY
25386: NOT
25387: PUSH
25388: LD_EXP 50
25392: PUSH
25393: LD_VAR 0 1
25397: ARRAY
25398: PPUSH
25399: LD_INT 30
25401: PUSH
25402: LD_INT 3
25404: PUSH
25405: EMPTY
25406: LIST
25407: LIST
25408: PPUSH
25409: CALL_OW 72
25413: AND
25414: PUSH
25415: LD_EXP 55
25419: PUSH
25420: LD_VAR 0 1
25424: ARRAY
25425: AND
25426: IFFALSE 26034
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
25428: LD_ADDR_EXP 92
25432: PUSH
25433: LD_EXP 92
25437: PPUSH
25438: LD_VAR 0 1
25442: PPUSH
25443: LD_INT 5
25445: PPUSH
25446: CALL_OW 1
25450: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25451: LD_ADDR_VAR 0 2
25455: PUSH
25456: LD_INT 0
25458: PUSH
25459: LD_INT 0
25461: PUSH
25462: LD_INT 0
25464: PUSH
25465: LD_INT 0
25467: PUSH
25468: EMPTY
25469: LIST
25470: LIST
25471: LIST
25472: LIST
25473: ST_TO_ADDR
// if sci > 1 then
25474: LD_VAR 0 8
25478: PUSH
25479: LD_INT 1
25481: GREATER
25482: IFFALSE 25510
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25484: LD_ADDR_VAR 0 4
25488: PUSH
25489: LD_VAR 0 4
25493: PUSH
25494: LD_VAR 0 8
25498: PUSH
25499: LD_VAR 0 8
25503: PUSH
25504: LD_INT 1
25506: ARRAY
25507: DIFF
25508: DIFF
25509: ST_TO_ADDR
// if tmp and not sci then
25510: LD_VAR 0 4
25514: PUSH
25515: LD_VAR 0 8
25519: NOT
25520: AND
25521: IFFALSE 25590
// begin sort := SortBySkill ( tmp , 4 ) ;
25523: LD_ADDR_VAR 0 9
25527: PUSH
25528: LD_VAR 0 4
25532: PPUSH
25533: LD_INT 4
25535: PPUSH
25536: CALL 85325 0 2
25540: ST_TO_ADDR
// if sort then
25541: LD_VAR 0 9
25545: IFFALSE 25561
// p := sort [ 1 ] ;
25547: LD_ADDR_VAR 0 11
25551: PUSH
25552: LD_VAR 0 9
25556: PUSH
25557: LD_INT 1
25559: ARRAY
25560: ST_TO_ADDR
// if p then
25561: LD_VAR 0 11
25565: IFFALSE 25590
// result := Replace ( result , 4 , p ) ;
25567: LD_ADDR_VAR 0 2
25571: PUSH
25572: LD_VAR 0 2
25576: PPUSH
25577: LD_INT 4
25579: PPUSH
25580: LD_VAR 0 11
25584: PPUSH
25585: CALL_OW 1
25589: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25590: LD_ADDR_VAR 0 4
25594: PUSH
25595: LD_VAR 0 4
25599: PUSH
25600: LD_VAR 0 7
25604: DIFF
25605: ST_TO_ADDR
// if tmp and mech < 6 then
25606: LD_VAR 0 4
25610: PUSH
25611: LD_VAR 0 7
25615: PUSH
25616: LD_INT 6
25618: LESS
25619: AND
25620: IFFALSE 25808
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25622: LD_ADDR_VAR 0 9
25626: PUSH
25627: LD_VAR 0 4
25631: PUSH
25632: LD_VAR 0 8
25636: PUSH
25637: LD_VAR 0 7
25641: UNION
25642: DIFF
25643: PPUSH
25644: LD_INT 3
25646: PPUSH
25647: CALL 85325 0 2
25651: ST_TO_ADDR
// p := [ ] ;
25652: LD_ADDR_VAR 0 11
25656: PUSH
25657: EMPTY
25658: ST_TO_ADDR
// if sort then
25659: LD_VAR 0 9
25663: IFFALSE 25779
// for i = 1 to 6 - mech do
25665: LD_ADDR_VAR 0 3
25669: PUSH
25670: DOUBLE
25671: LD_INT 1
25673: DEC
25674: ST_TO_ADDR
25675: LD_INT 6
25677: PUSH
25678: LD_VAR 0 7
25682: MINUS
25683: PUSH
25684: FOR_TO
25685: IFFALSE 25777
// begin if i = sort then
25687: LD_VAR 0 3
25691: PUSH
25692: LD_VAR 0 9
25696: EQUAL
25697: IFFALSE 25701
// break ;
25699: GO 25777
// if GetClass ( i ) = 3 then
25701: LD_VAR 0 3
25705: PPUSH
25706: CALL_OW 257
25710: PUSH
25711: LD_INT 3
25713: EQUAL
25714: IFFALSE 25718
// continue ;
25716: GO 25684
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25718: LD_ADDR_VAR 0 11
25722: PUSH
25723: LD_VAR 0 11
25727: PPUSH
25728: LD_VAR 0 11
25732: PUSH
25733: LD_INT 1
25735: PLUS
25736: PPUSH
25737: LD_VAR 0 9
25741: PUSH
25742: LD_VAR 0 3
25746: ARRAY
25747: PPUSH
25748: CALL_OW 2
25752: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25753: LD_ADDR_VAR 0 4
25757: PUSH
25758: LD_VAR 0 4
25762: PUSH
25763: LD_VAR 0 9
25767: PUSH
25768: LD_VAR 0 3
25772: ARRAY
25773: DIFF
25774: ST_TO_ADDR
// end ;
25775: GO 25684
25777: POP
25778: POP
// if p then
25779: LD_VAR 0 11
25783: IFFALSE 25808
// result := Replace ( result , 3 , p ) ;
25785: LD_ADDR_VAR 0 2
25789: PUSH
25790: LD_VAR 0 2
25794: PPUSH
25795: LD_INT 3
25797: PPUSH
25798: LD_VAR 0 11
25802: PPUSH
25803: CALL_OW 1
25807: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25808: LD_ADDR_VAR 0 4
25812: PUSH
25813: LD_VAR 0 4
25817: PUSH
25818: LD_VAR 0 6
25822: DIFF
25823: ST_TO_ADDR
// if tmp and eng < 6 then
25824: LD_VAR 0 4
25828: PUSH
25829: LD_VAR 0 6
25833: PUSH
25834: LD_INT 6
25836: LESS
25837: AND
25838: IFFALSE 26032
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25840: LD_ADDR_VAR 0 9
25844: PUSH
25845: LD_VAR 0 4
25849: PUSH
25850: LD_VAR 0 8
25854: PUSH
25855: LD_VAR 0 7
25859: UNION
25860: PUSH
25861: LD_VAR 0 6
25865: UNION
25866: DIFF
25867: PPUSH
25868: LD_INT 2
25870: PPUSH
25871: CALL 85325 0 2
25875: ST_TO_ADDR
// p := [ ] ;
25876: LD_ADDR_VAR 0 11
25880: PUSH
25881: EMPTY
25882: ST_TO_ADDR
// if sort then
25883: LD_VAR 0 9
25887: IFFALSE 26003
// for i = 1 to 6 - eng do
25889: LD_ADDR_VAR 0 3
25893: PUSH
25894: DOUBLE
25895: LD_INT 1
25897: DEC
25898: ST_TO_ADDR
25899: LD_INT 6
25901: PUSH
25902: LD_VAR 0 6
25906: MINUS
25907: PUSH
25908: FOR_TO
25909: IFFALSE 26001
// begin if i = sort then
25911: LD_VAR 0 3
25915: PUSH
25916: LD_VAR 0 9
25920: EQUAL
25921: IFFALSE 25925
// break ;
25923: GO 26001
// if GetClass ( i ) = 2 then
25925: LD_VAR 0 3
25929: PPUSH
25930: CALL_OW 257
25934: PUSH
25935: LD_INT 2
25937: EQUAL
25938: IFFALSE 25942
// continue ;
25940: GO 25908
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25942: LD_ADDR_VAR 0 11
25946: PUSH
25947: LD_VAR 0 11
25951: PPUSH
25952: LD_VAR 0 11
25956: PUSH
25957: LD_INT 1
25959: PLUS
25960: PPUSH
25961: LD_VAR 0 9
25965: PUSH
25966: LD_VAR 0 3
25970: ARRAY
25971: PPUSH
25972: CALL_OW 2
25976: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25977: LD_ADDR_VAR 0 4
25981: PUSH
25982: LD_VAR 0 4
25986: PUSH
25987: LD_VAR 0 9
25991: PUSH
25992: LD_VAR 0 3
25996: ARRAY
25997: DIFF
25998: ST_TO_ADDR
// end ;
25999: GO 25908
26001: POP
26002: POP
// if p then
26003: LD_VAR 0 11
26007: IFFALSE 26032
// result := Replace ( result , 2 , p ) ;
26009: LD_ADDR_VAR 0 2
26013: PUSH
26014: LD_VAR 0 2
26018: PPUSH
26019: LD_INT 2
26021: PPUSH
26022: LD_VAR 0 11
26026: PPUSH
26027: CALL_OW 1
26031: ST_TO_ADDR
// end ; exit ;
26032: GO 26756
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
26034: LD_EXP 77
26038: PUSH
26039: LD_EXP 76
26043: PUSH
26044: LD_VAR 0 1
26048: ARRAY
26049: ARRAY
26050: NOT
26051: PUSH
26052: LD_EXP 50
26056: PUSH
26057: LD_VAR 0 1
26061: ARRAY
26062: PPUSH
26063: LD_INT 30
26065: PUSH
26066: LD_INT 3
26068: PUSH
26069: EMPTY
26070: LIST
26071: LIST
26072: PPUSH
26073: CALL_OW 72
26077: AND
26078: PUSH
26079: LD_EXP 55
26083: PUSH
26084: LD_VAR 0 1
26088: ARRAY
26089: NOT
26090: AND
26091: IFFALSE 26756
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
26093: LD_ADDR_EXP 92
26097: PUSH
26098: LD_EXP 92
26102: PPUSH
26103: LD_VAR 0 1
26107: PPUSH
26108: LD_INT 6
26110: PPUSH
26111: CALL_OW 1
26115: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26116: LD_ADDR_VAR 0 2
26120: PUSH
26121: LD_INT 0
26123: PUSH
26124: LD_INT 0
26126: PUSH
26127: LD_INT 0
26129: PUSH
26130: LD_INT 0
26132: PUSH
26133: EMPTY
26134: LIST
26135: LIST
26136: LIST
26137: LIST
26138: ST_TO_ADDR
// if sci >= 1 then
26139: LD_VAR 0 8
26143: PUSH
26144: LD_INT 1
26146: GREATEREQUAL
26147: IFFALSE 26169
// tmp := tmp diff sci [ 1 ] ;
26149: LD_ADDR_VAR 0 4
26153: PUSH
26154: LD_VAR 0 4
26158: PUSH
26159: LD_VAR 0 8
26163: PUSH
26164: LD_INT 1
26166: ARRAY
26167: DIFF
26168: ST_TO_ADDR
// if tmp and not sci then
26169: LD_VAR 0 4
26173: PUSH
26174: LD_VAR 0 8
26178: NOT
26179: AND
26180: IFFALSE 26249
// begin sort := SortBySkill ( tmp , 4 ) ;
26182: LD_ADDR_VAR 0 9
26186: PUSH
26187: LD_VAR 0 4
26191: PPUSH
26192: LD_INT 4
26194: PPUSH
26195: CALL 85325 0 2
26199: ST_TO_ADDR
// if sort then
26200: LD_VAR 0 9
26204: IFFALSE 26220
// p := sort [ 1 ] ;
26206: LD_ADDR_VAR 0 11
26210: PUSH
26211: LD_VAR 0 9
26215: PUSH
26216: LD_INT 1
26218: ARRAY
26219: ST_TO_ADDR
// if p then
26220: LD_VAR 0 11
26224: IFFALSE 26249
// result := Replace ( result , 4 , p ) ;
26226: LD_ADDR_VAR 0 2
26230: PUSH
26231: LD_VAR 0 2
26235: PPUSH
26236: LD_INT 4
26238: PPUSH
26239: LD_VAR 0 11
26243: PPUSH
26244: CALL_OW 1
26248: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26249: LD_ADDR_VAR 0 4
26253: PUSH
26254: LD_VAR 0 4
26258: PUSH
26259: LD_VAR 0 7
26263: DIFF
26264: ST_TO_ADDR
// if tmp and mech < 6 then
26265: LD_VAR 0 4
26269: PUSH
26270: LD_VAR 0 7
26274: PUSH
26275: LD_INT 6
26277: LESS
26278: AND
26279: IFFALSE 26461
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
26281: LD_ADDR_VAR 0 9
26285: PUSH
26286: LD_VAR 0 4
26290: PUSH
26291: LD_VAR 0 7
26295: DIFF
26296: PPUSH
26297: LD_INT 3
26299: PPUSH
26300: CALL 85325 0 2
26304: ST_TO_ADDR
// p := [ ] ;
26305: LD_ADDR_VAR 0 11
26309: PUSH
26310: EMPTY
26311: ST_TO_ADDR
// if sort then
26312: LD_VAR 0 9
26316: IFFALSE 26432
// for i = 1 to 6 - mech do
26318: LD_ADDR_VAR 0 3
26322: PUSH
26323: DOUBLE
26324: LD_INT 1
26326: DEC
26327: ST_TO_ADDR
26328: LD_INT 6
26330: PUSH
26331: LD_VAR 0 7
26335: MINUS
26336: PUSH
26337: FOR_TO
26338: IFFALSE 26430
// begin if i = sort then
26340: LD_VAR 0 3
26344: PUSH
26345: LD_VAR 0 9
26349: EQUAL
26350: IFFALSE 26354
// break ;
26352: GO 26430
// if GetClass ( i ) = 3 then
26354: LD_VAR 0 3
26358: PPUSH
26359: CALL_OW 257
26363: PUSH
26364: LD_INT 3
26366: EQUAL
26367: IFFALSE 26371
// continue ;
26369: GO 26337
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26371: LD_ADDR_VAR 0 11
26375: PUSH
26376: LD_VAR 0 11
26380: PPUSH
26381: LD_VAR 0 11
26385: PUSH
26386: LD_INT 1
26388: PLUS
26389: PPUSH
26390: LD_VAR 0 9
26394: PUSH
26395: LD_VAR 0 3
26399: ARRAY
26400: PPUSH
26401: CALL_OW 2
26405: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26406: LD_ADDR_VAR 0 4
26410: PUSH
26411: LD_VAR 0 4
26415: PUSH
26416: LD_VAR 0 9
26420: PUSH
26421: LD_VAR 0 3
26425: ARRAY
26426: DIFF
26427: ST_TO_ADDR
// end ;
26428: GO 26337
26430: POP
26431: POP
// if p then
26432: LD_VAR 0 11
26436: IFFALSE 26461
// result := Replace ( result , 3 , p ) ;
26438: LD_ADDR_VAR 0 2
26442: PUSH
26443: LD_VAR 0 2
26447: PPUSH
26448: LD_INT 3
26450: PPUSH
26451: LD_VAR 0 11
26455: PPUSH
26456: CALL_OW 1
26460: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26461: LD_ADDR_VAR 0 4
26465: PUSH
26466: LD_VAR 0 4
26470: PUSH
26471: LD_VAR 0 6
26475: DIFF
26476: ST_TO_ADDR
// if tmp and eng < 4 then
26477: LD_VAR 0 4
26481: PUSH
26482: LD_VAR 0 6
26486: PUSH
26487: LD_INT 4
26489: LESS
26490: AND
26491: IFFALSE 26681
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26493: LD_ADDR_VAR 0 9
26497: PUSH
26498: LD_VAR 0 4
26502: PUSH
26503: LD_VAR 0 7
26507: PUSH
26508: LD_VAR 0 6
26512: UNION
26513: DIFF
26514: PPUSH
26515: LD_INT 2
26517: PPUSH
26518: CALL 85325 0 2
26522: ST_TO_ADDR
// p := [ ] ;
26523: LD_ADDR_VAR 0 11
26527: PUSH
26528: EMPTY
26529: ST_TO_ADDR
// if sort then
26530: LD_VAR 0 9
26534: IFFALSE 26650
// for i = 1 to 4 - eng do
26536: LD_ADDR_VAR 0 3
26540: PUSH
26541: DOUBLE
26542: LD_INT 1
26544: DEC
26545: ST_TO_ADDR
26546: LD_INT 4
26548: PUSH
26549: LD_VAR 0 6
26553: MINUS
26554: PUSH
26555: FOR_TO
26556: IFFALSE 26648
// begin if i = sort then
26558: LD_VAR 0 3
26562: PUSH
26563: LD_VAR 0 9
26567: EQUAL
26568: IFFALSE 26572
// break ;
26570: GO 26648
// if GetClass ( i ) = 2 then
26572: LD_VAR 0 3
26576: PPUSH
26577: CALL_OW 257
26581: PUSH
26582: LD_INT 2
26584: EQUAL
26585: IFFALSE 26589
// continue ;
26587: GO 26555
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26589: LD_ADDR_VAR 0 11
26593: PUSH
26594: LD_VAR 0 11
26598: PPUSH
26599: LD_VAR 0 11
26603: PUSH
26604: LD_INT 1
26606: PLUS
26607: PPUSH
26608: LD_VAR 0 9
26612: PUSH
26613: LD_VAR 0 3
26617: ARRAY
26618: PPUSH
26619: CALL_OW 2
26623: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26624: LD_ADDR_VAR 0 4
26628: PUSH
26629: LD_VAR 0 4
26633: PUSH
26634: LD_VAR 0 9
26638: PUSH
26639: LD_VAR 0 3
26643: ARRAY
26644: DIFF
26645: ST_TO_ADDR
// end ;
26646: GO 26555
26648: POP
26649: POP
// if p then
26650: LD_VAR 0 11
26654: IFFALSE 26679
// result := Replace ( result , 2 , p ) ;
26656: LD_ADDR_VAR 0 2
26660: PUSH
26661: LD_VAR 0 2
26665: PPUSH
26666: LD_INT 2
26668: PPUSH
26669: LD_VAR 0 11
26673: PPUSH
26674: CALL_OW 1
26678: ST_TO_ADDR
// end else
26679: GO 26725
// for i = eng downto 5 do
26681: LD_ADDR_VAR 0 3
26685: PUSH
26686: DOUBLE
26687: LD_VAR 0 6
26691: INC
26692: ST_TO_ADDR
26693: LD_INT 5
26695: PUSH
26696: FOR_DOWNTO
26697: IFFALSE 26723
// tmp := tmp union eng [ i ] ;
26699: LD_ADDR_VAR 0 4
26703: PUSH
26704: LD_VAR 0 4
26708: PUSH
26709: LD_VAR 0 6
26713: PUSH
26714: LD_VAR 0 3
26718: ARRAY
26719: UNION
26720: ST_TO_ADDR
26721: GO 26696
26723: POP
26724: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26725: LD_ADDR_VAR 0 2
26729: PUSH
26730: LD_VAR 0 2
26734: PPUSH
26735: LD_INT 1
26737: PPUSH
26738: LD_VAR 0 4
26742: PUSH
26743: LD_VAR 0 5
26747: DIFF
26748: PPUSH
26749: CALL_OW 1
26753: ST_TO_ADDR
// exit ;
26754: GO 26756
// end ; end ;
26756: LD_VAR 0 2
26760: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26761: LD_INT 0
26763: PPUSH
26764: PPUSH
26765: PPUSH
// if not mc_bases then
26766: LD_EXP 50
26770: NOT
26771: IFFALSE 26775
// exit ;
26773: GO 26917
// for i = 1 to mc_bases do
26775: LD_ADDR_VAR 0 2
26779: PUSH
26780: DOUBLE
26781: LD_INT 1
26783: DEC
26784: ST_TO_ADDR
26785: LD_EXP 50
26789: PUSH
26790: FOR_TO
26791: IFFALSE 26908
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26793: LD_ADDR_VAR 0 3
26797: PUSH
26798: LD_EXP 50
26802: PUSH
26803: LD_VAR 0 2
26807: ARRAY
26808: PPUSH
26809: LD_INT 21
26811: PUSH
26812: LD_INT 3
26814: PUSH
26815: EMPTY
26816: LIST
26817: LIST
26818: PUSH
26819: LD_INT 3
26821: PUSH
26822: LD_INT 2
26824: PUSH
26825: LD_INT 30
26827: PUSH
26828: LD_INT 29
26830: PUSH
26831: EMPTY
26832: LIST
26833: LIST
26834: PUSH
26835: LD_INT 30
26837: PUSH
26838: LD_INT 30
26840: PUSH
26841: EMPTY
26842: LIST
26843: LIST
26844: PUSH
26845: EMPTY
26846: LIST
26847: LIST
26848: LIST
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: PUSH
26854: LD_INT 3
26856: PUSH
26857: LD_INT 24
26859: PUSH
26860: LD_INT 1000
26862: PUSH
26863: EMPTY
26864: LIST
26865: LIST
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: LIST
26875: PPUSH
26876: CALL_OW 72
26880: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26881: LD_ADDR_EXP 51
26885: PUSH
26886: LD_EXP 51
26890: PPUSH
26891: LD_VAR 0 2
26895: PPUSH
26896: LD_VAR 0 3
26900: PPUSH
26901: CALL_OW 1
26905: ST_TO_ADDR
// end ;
26906: GO 26790
26908: POP
26909: POP
// RaiseSailEvent ( 101 ) ;
26910: LD_INT 101
26912: PPUSH
26913: CALL_OW 427
// end ;
26917: LD_VAR 0 1
26921: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26922: LD_INT 0
26924: PPUSH
26925: PPUSH
26926: PPUSH
26927: PPUSH
26928: PPUSH
26929: PPUSH
26930: PPUSH
// if not mc_bases then
26931: LD_EXP 50
26935: NOT
26936: IFFALSE 26940
// exit ;
26938: GO 27502
// for i = 1 to mc_bases do
26940: LD_ADDR_VAR 0 2
26944: PUSH
26945: DOUBLE
26946: LD_INT 1
26948: DEC
26949: ST_TO_ADDR
26950: LD_EXP 50
26954: PUSH
26955: FOR_TO
26956: IFFALSE 27493
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26958: LD_ADDR_VAR 0 5
26962: PUSH
26963: LD_EXP 50
26967: PUSH
26968: LD_VAR 0 2
26972: ARRAY
26973: PUSH
26974: LD_EXP 79
26978: PUSH
26979: LD_VAR 0 2
26983: ARRAY
26984: UNION
26985: PPUSH
26986: LD_INT 21
26988: PUSH
26989: LD_INT 1
26991: PUSH
26992: EMPTY
26993: LIST
26994: LIST
26995: PUSH
26996: LD_INT 1
26998: PUSH
26999: LD_INT 3
27001: PUSH
27002: LD_INT 54
27004: PUSH
27005: EMPTY
27006: LIST
27007: PUSH
27008: EMPTY
27009: LIST
27010: LIST
27011: PUSH
27012: LD_INT 3
27014: PUSH
27015: LD_INT 24
27017: PUSH
27018: LD_INT 1000
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PUSH
27025: EMPTY
27026: LIST
27027: LIST
27028: PUSH
27029: EMPTY
27030: LIST
27031: LIST
27032: LIST
27033: PUSH
27034: EMPTY
27035: LIST
27036: LIST
27037: PPUSH
27038: CALL_OW 72
27042: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
27043: LD_ADDR_VAR 0 6
27047: PUSH
27048: LD_EXP 50
27052: PUSH
27053: LD_VAR 0 2
27057: ARRAY
27058: PPUSH
27059: LD_INT 21
27061: PUSH
27062: LD_INT 1
27064: PUSH
27065: EMPTY
27066: LIST
27067: LIST
27068: PUSH
27069: LD_INT 1
27071: PUSH
27072: LD_INT 3
27074: PUSH
27075: LD_INT 54
27077: PUSH
27078: EMPTY
27079: LIST
27080: PUSH
27081: EMPTY
27082: LIST
27083: LIST
27084: PUSH
27085: LD_INT 3
27087: PUSH
27088: LD_INT 24
27090: PUSH
27091: LD_INT 250
27093: PUSH
27094: EMPTY
27095: LIST
27096: LIST
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PUSH
27102: EMPTY
27103: LIST
27104: LIST
27105: LIST
27106: PUSH
27107: EMPTY
27108: LIST
27109: LIST
27110: PPUSH
27111: CALL_OW 72
27115: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
27116: LD_ADDR_VAR 0 7
27120: PUSH
27121: LD_VAR 0 5
27125: PUSH
27126: LD_VAR 0 6
27130: DIFF
27131: ST_TO_ADDR
// if not need_heal_1 then
27132: LD_VAR 0 6
27136: NOT
27137: IFFALSE 27170
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
27139: LD_ADDR_EXP 53
27143: PUSH
27144: LD_EXP 53
27148: PPUSH
27149: LD_VAR 0 2
27153: PUSH
27154: LD_INT 1
27156: PUSH
27157: EMPTY
27158: LIST
27159: LIST
27160: PPUSH
27161: EMPTY
27162: PPUSH
27163: CALL 54081 0 3
27167: ST_TO_ADDR
27168: GO 27240
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
27170: LD_ADDR_EXP 53
27174: PUSH
27175: LD_EXP 53
27179: PPUSH
27180: LD_VAR 0 2
27184: PUSH
27185: LD_INT 1
27187: PUSH
27188: EMPTY
27189: LIST
27190: LIST
27191: PPUSH
27192: LD_EXP 53
27196: PUSH
27197: LD_VAR 0 2
27201: ARRAY
27202: PUSH
27203: LD_INT 1
27205: ARRAY
27206: PPUSH
27207: LD_INT 3
27209: PUSH
27210: LD_INT 24
27212: PUSH
27213: LD_INT 1000
27215: PUSH
27216: EMPTY
27217: LIST
27218: LIST
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: PPUSH
27224: CALL_OW 72
27228: PUSH
27229: LD_VAR 0 6
27233: UNION
27234: PPUSH
27235: CALL 54081 0 3
27239: ST_TO_ADDR
// if not need_heal_2 then
27240: LD_VAR 0 7
27244: NOT
27245: IFFALSE 27278
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
27247: LD_ADDR_EXP 53
27251: PUSH
27252: LD_EXP 53
27256: PPUSH
27257: LD_VAR 0 2
27261: PUSH
27262: LD_INT 2
27264: PUSH
27265: EMPTY
27266: LIST
27267: LIST
27268: PPUSH
27269: EMPTY
27270: PPUSH
27271: CALL 54081 0 3
27275: ST_TO_ADDR
27276: GO 27310
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
27278: LD_ADDR_EXP 53
27282: PUSH
27283: LD_EXP 53
27287: PPUSH
27288: LD_VAR 0 2
27292: PUSH
27293: LD_INT 2
27295: PUSH
27296: EMPTY
27297: LIST
27298: LIST
27299: PPUSH
27300: LD_VAR 0 7
27304: PPUSH
27305: CALL 54081 0 3
27309: ST_TO_ADDR
// if need_heal_2 then
27310: LD_VAR 0 7
27314: IFFALSE 27475
// for j in need_heal_2 do
27316: LD_ADDR_VAR 0 3
27320: PUSH
27321: LD_VAR 0 7
27325: PUSH
27326: FOR_IN
27327: IFFALSE 27473
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27329: LD_ADDR_VAR 0 5
27333: PUSH
27334: LD_EXP 50
27338: PUSH
27339: LD_VAR 0 2
27343: ARRAY
27344: PPUSH
27345: LD_INT 2
27347: PUSH
27348: LD_INT 30
27350: PUSH
27351: LD_INT 6
27353: PUSH
27354: EMPTY
27355: LIST
27356: LIST
27357: PUSH
27358: LD_INT 30
27360: PUSH
27361: LD_INT 7
27363: PUSH
27364: EMPTY
27365: LIST
27366: LIST
27367: PUSH
27368: LD_INT 30
27370: PUSH
27371: LD_INT 8
27373: PUSH
27374: EMPTY
27375: LIST
27376: LIST
27377: PUSH
27378: LD_INT 30
27380: PUSH
27381: LD_INT 0
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: PUSH
27388: LD_INT 30
27390: PUSH
27391: LD_INT 1
27393: PUSH
27394: EMPTY
27395: LIST
27396: LIST
27397: PUSH
27398: EMPTY
27399: LIST
27400: LIST
27401: LIST
27402: LIST
27403: LIST
27404: LIST
27405: PPUSH
27406: CALL_OW 72
27410: ST_TO_ADDR
// if tmp then
27411: LD_VAR 0 5
27415: IFFALSE 27471
// begin k := NearestUnitToUnit ( tmp , j ) ;
27417: LD_ADDR_VAR 0 4
27421: PUSH
27422: LD_VAR 0 5
27426: PPUSH
27427: LD_VAR 0 3
27431: PPUSH
27432: CALL_OW 74
27436: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
27437: LD_VAR 0 3
27441: PPUSH
27442: LD_VAR 0 4
27446: PPUSH
27447: CALL_OW 296
27451: PUSH
27452: LD_INT 5
27454: GREATER
27455: IFFALSE 27471
// ComMoveToNearbyEntrance ( j , k ) ;
27457: LD_VAR 0 3
27461: PPUSH
27462: LD_VAR 0 4
27466: PPUSH
27467: CALL 87698 0 2
// end ; end ;
27471: GO 27326
27473: POP
27474: POP
// if not need_heal_1 and not need_heal_2 then
27475: LD_VAR 0 6
27479: NOT
27480: PUSH
27481: LD_VAR 0 7
27485: NOT
27486: AND
27487: IFFALSE 27491
// continue ;
27489: GO 26955
// end ;
27491: GO 26955
27493: POP
27494: POP
// RaiseSailEvent ( 102 ) ;
27495: LD_INT 102
27497: PPUSH
27498: CALL_OW 427
// end ;
27502: LD_VAR 0 1
27506: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27507: LD_INT 0
27509: PPUSH
27510: PPUSH
27511: PPUSH
27512: PPUSH
27513: PPUSH
27514: PPUSH
27515: PPUSH
27516: PPUSH
// if not mc_bases then
27517: LD_EXP 50
27521: NOT
27522: IFFALSE 27526
// exit ;
27524: GO 28437
// for i = 1 to mc_bases do
27526: LD_ADDR_VAR 0 2
27530: PUSH
27531: DOUBLE
27532: LD_INT 1
27534: DEC
27535: ST_TO_ADDR
27536: LD_EXP 50
27540: PUSH
27541: FOR_TO
27542: IFFALSE 28435
// begin if not mc_building_need_repair [ i ] then
27544: LD_EXP 51
27548: PUSH
27549: LD_VAR 0 2
27553: ARRAY
27554: NOT
27555: IFFALSE 27740
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27557: LD_ADDR_VAR 0 6
27561: PUSH
27562: LD_EXP 69
27566: PUSH
27567: LD_VAR 0 2
27571: ARRAY
27572: PPUSH
27573: LD_INT 3
27575: PUSH
27576: LD_INT 24
27578: PUSH
27579: LD_INT 1000
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: PUSH
27586: EMPTY
27587: LIST
27588: LIST
27589: PUSH
27590: LD_INT 2
27592: PUSH
27593: LD_INT 34
27595: PUSH
27596: LD_INT 13
27598: PUSH
27599: EMPTY
27600: LIST
27601: LIST
27602: PUSH
27603: LD_INT 34
27605: PUSH
27606: LD_INT 52
27608: PUSH
27609: EMPTY
27610: LIST
27611: LIST
27612: PUSH
27613: LD_INT 34
27615: PUSH
27616: LD_INT 88
27618: PUSH
27619: EMPTY
27620: LIST
27621: LIST
27622: PUSH
27623: EMPTY
27624: LIST
27625: LIST
27626: LIST
27627: LIST
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PPUSH
27633: CALL_OW 72
27637: ST_TO_ADDR
// if cranes then
27638: LD_VAR 0 6
27642: IFFALSE 27704
// for j in cranes do
27644: LD_ADDR_VAR 0 3
27648: PUSH
27649: LD_VAR 0 6
27653: PUSH
27654: FOR_IN
27655: IFFALSE 27702
// if not IsInArea ( j , mc_parking [ i ] ) then
27657: LD_VAR 0 3
27661: PPUSH
27662: LD_EXP 74
27666: PUSH
27667: LD_VAR 0 2
27671: ARRAY
27672: PPUSH
27673: CALL_OW 308
27677: NOT
27678: IFFALSE 27700
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27680: LD_VAR 0 3
27684: PPUSH
27685: LD_EXP 74
27689: PUSH
27690: LD_VAR 0 2
27694: ARRAY
27695: PPUSH
27696: CALL_OW 113
27700: GO 27654
27702: POP
27703: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27704: LD_ADDR_EXP 52
27708: PUSH
27709: LD_EXP 52
27713: PPUSH
27714: LD_VAR 0 2
27718: PPUSH
27719: EMPTY
27720: PPUSH
27721: CALL_OW 1
27725: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27726: LD_VAR 0 2
27730: PPUSH
27731: LD_INT 101
27733: PPUSH
27734: CALL 22580 0 2
// continue ;
27738: GO 27541
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27740: LD_ADDR_EXP 56
27744: PUSH
27745: LD_EXP 56
27749: PPUSH
27750: LD_VAR 0 2
27754: PPUSH
27755: EMPTY
27756: PPUSH
27757: CALL_OW 1
27761: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27762: LD_VAR 0 2
27766: PPUSH
27767: LD_INT 103
27769: PPUSH
27770: CALL 22580 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27774: LD_ADDR_VAR 0 5
27778: PUSH
27779: LD_EXP 50
27783: PUSH
27784: LD_VAR 0 2
27788: ARRAY
27789: PUSH
27790: LD_EXP 79
27794: PUSH
27795: LD_VAR 0 2
27799: ARRAY
27800: UNION
27801: PPUSH
27802: LD_INT 2
27804: PUSH
27805: LD_INT 25
27807: PUSH
27808: LD_INT 2
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: PUSH
27815: LD_INT 25
27817: PUSH
27818: LD_INT 16
27820: PUSH
27821: EMPTY
27822: LIST
27823: LIST
27824: PUSH
27825: EMPTY
27826: LIST
27827: LIST
27828: LIST
27829: PUSH
27830: EMPTY
27831: LIST
27832: PPUSH
27833: CALL_OW 72
27837: ST_TO_ADDR
// if mc_need_heal [ i ] then
27838: LD_EXP 53
27842: PUSH
27843: LD_VAR 0 2
27847: ARRAY
27848: IFFALSE 27892
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27850: LD_ADDR_VAR 0 5
27854: PUSH
27855: LD_VAR 0 5
27859: PUSH
27860: LD_EXP 53
27864: PUSH
27865: LD_VAR 0 2
27869: ARRAY
27870: PUSH
27871: LD_INT 1
27873: ARRAY
27874: PUSH
27875: LD_EXP 53
27879: PUSH
27880: LD_VAR 0 2
27884: ARRAY
27885: PUSH
27886: LD_INT 2
27888: ARRAY
27889: UNION
27890: DIFF
27891: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27892: LD_ADDR_VAR 0 6
27896: PUSH
27897: LD_EXP 69
27901: PUSH
27902: LD_VAR 0 2
27906: ARRAY
27907: PPUSH
27908: LD_INT 2
27910: PUSH
27911: LD_INT 34
27913: PUSH
27914: LD_INT 13
27916: PUSH
27917: EMPTY
27918: LIST
27919: LIST
27920: PUSH
27921: LD_INT 34
27923: PUSH
27924: LD_INT 52
27926: PUSH
27927: EMPTY
27928: LIST
27929: LIST
27930: PUSH
27931: LD_INT 34
27933: PUSH
27934: LD_INT 88
27936: PUSH
27937: EMPTY
27938: LIST
27939: LIST
27940: PUSH
27941: EMPTY
27942: LIST
27943: LIST
27944: LIST
27945: LIST
27946: PPUSH
27947: CALL_OW 72
27951: ST_TO_ADDR
// if cranes then
27952: LD_VAR 0 6
27956: IFFALSE 28124
// begin for j in cranes do
27958: LD_ADDR_VAR 0 3
27962: PUSH
27963: LD_VAR 0 6
27967: PUSH
27968: FOR_IN
27969: IFFALSE 28122
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27971: LD_VAR 0 3
27975: PPUSH
27976: CALL_OW 256
27980: PUSH
27981: LD_INT 1000
27983: EQUAL
27984: PUSH
27985: LD_VAR 0 3
27989: PPUSH
27990: CALL_OW 314
27994: NOT
27995: AND
27996: IFFALSE 28062
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
27998: LD_ADDR_VAR 0 8
28002: PUSH
28003: LD_EXP 51
28007: PUSH
28008: LD_VAR 0 2
28012: ARRAY
28013: PPUSH
28014: LD_VAR 0 3
28018: PPUSH
28019: CALL_OW 74
28023: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
28024: LD_VAR 0 8
28028: PPUSH
28029: LD_INT 16
28031: PPUSH
28032: CALL 57046 0 2
28036: PUSH
28037: LD_INT 4
28039: ARRAY
28040: PUSH
28041: LD_INT 10
28043: LESS
28044: IFFALSE 28060
// ComRepairBuilding ( j , to_repair ) ;
28046: LD_VAR 0 3
28050: PPUSH
28051: LD_VAR 0 8
28055: PPUSH
28056: CALL_OW 130
// end else
28060: GO 28120
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
28062: LD_VAR 0 3
28066: PPUSH
28067: CALL_OW 256
28071: PUSH
28072: LD_INT 500
28074: LESS
28075: PUSH
28076: LD_VAR 0 3
28080: PPUSH
28081: LD_EXP 74
28085: PUSH
28086: LD_VAR 0 2
28090: ARRAY
28091: PPUSH
28092: CALL_OW 308
28096: NOT
28097: AND
28098: IFFALSE 28120
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28100: LD_VAR 0 3
28104: PPUSH
28105: LD_EXP 74
28109: PUSH
28110: LD_VAR 0 2
28114: ARRAY
28115: PPUSH
28116: CALL_OW 113
// end ;
28120: GO 27968
28122: POP
28123: POP
// end ; if tmp > 3 then
28124: LD_VAR 0 5
28128: PUSH
28129: LD_INT 3
28131: GREATER
28132: IFFALSE 28152
// tmp := ShrinkArray ( tmp , 4 ) ;
28134: LD_ADDR_VAR 0 5
28138: PUSH
28139: LD_VAR 0 5
28143: PPUSH
28144: LD_INT 4
28146: PPUSH
28147: CALL 87136 0 2
28151: ST_TO_ADDR
// if not tmp then
28152: LD_VAR 0 5
28156: NOT
28157: IFFALSE 28161
// continue ;
28159: GO 27541
// for j in tmp do
28161: LD_ADDR_VAR 0 3
28165: PUSH
28166: LD_VAR 0 5
28170: PUSH
28171: FOR_IN
28172: IFFALSE 28431
// begin if IsInUnit ( j ) then
28174: LD_VAR 0 3
28178: PPUSH
28179: CALL_OW 310
28183: IFFALSE 28194
// ComExitBuilding ( j ) ;
28185: LD_VAR 0 3
28189: PPUSH
28190: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
28194: LD_VAR 0 3
28198: PUSH
28199: LD_EXP 52
28203: PUSH
28204: LD_VAR 0 2
28208: ARRAY
28209: IN
28210: NOT
28211: IFFALSE 28269
// begin SetTag ( j , 101 ) ;
28213: LD_VAR 0 3
28217: PPUSH
28218: LD_INT 101
28220: PPUSH
28221: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
28225: LD_ADDR_EXP 52
28229: PUSH
28230: LD_EXP 52
28234: PPUSH
28235: LD_VAR 0 2
28239: PUSH
28240: LD_EXP 52
28244: PUSH
28245: LD_VAR 0 2
28249: ARRAY
28250: PUSH
28251: LD_INT 1
28253: PLUS
28254: PUSH
28255: EMPTY
28256: LIST
28257: LIST
28258: PPUSH
28259: LD_VAR 0 3
28263: PPUSH
28264: CALL 54081 0 3
28268: ST_TO_ADDR
// end ; wait ( 1 ) ;
28269: LD_INT 1
28271: PPUSH
28272: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
28276: LD_ADDR_VAR 0 7
28280: PUSH
28281: LD_EXP 51
28285: PUSH
28286: LD_VAR 0 2
28290: ARRAY
28291: ST_TO_ADDR
// if mc_scan [ i ] then
28292: LD_EXP 73
28296: PUSH
28297: LD_VAR 0 2
28301: ARRAY
28302: IFFALSE 28364
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
28304: LD_ADDR_VAR 0 7
28308: PUSH
28309: LD_EXP 51
28313: PUSH
28314: LD_VAR 0 2
28318: ARRAY
28319: PPUSH
28320: LD_INT 3
28322: PUSH
28323: LD_INT 30
28325: PUSH
28326: LD_INT 32
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: PUSH
28333: LD_INT 30
28335: PUSH
28336: LD_INT 33
28338: PUSH
28339: EMPTY
28340: LIST
28341: LIST
28342: PUSH
28343: LD_INT 30
28345: PUSH
28346: LD_INT 31
28348: PUSH
28349: EMPTY
28350: LIST
28351: LIST
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: LIST
28357: LIST
28358: PPUSH
28359: CALL_OW 72
28363: ST_TO_ADDR
// if not to_repair_tmp then
28364: LD_VAR 0 7
28368: NOT
28369: IFFALSE 28373
// continue ;
28371: GO 28171
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
28373: LD_ADDR_VAR 0 8
28377: PUSH
28378: LD_VAR 0 7
28382: PPUSH
28383: LD_VAR 0 3
28387: PPUSH
28388: CALL_OW 74
28392: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
28393: LD_VAR 0 8
28397: PPUSH
28398: LD_INT 16
28400: PPUSH
28401: CALL 57046 0 2
28405: PUSH
28406: LD_INT 4
28408: ARRAY
28409: PUSH
28410: LD_INT 14
28412: LESS
28413: IFFALSE 28429
// ComRepairBuilding ( j , to_repair ) ;
28415: LD_VAR 0 3
28419: PPUSH
28420: LD_VAR 0 8
28424: PPUSH
28425: CALL_OW 130
// end ;
28429: GO 28171
28431: POP
28432: POP
// end ;
28433: GO 27541
28435: POP
28436: POP
// end ;
28437: LD_VAR 0 1
28441: RET
// export function MC_Heal ; var i , j , tmp ; begin
28442: LD_INT 0
28444: PPUSH
28445: PPUSH
28446: PPUSH
28447: PPUSH
// if not mc_bases then
28448: LD_EXP 50
28452: NOT
28453: IFFALSE 28457
// exit ;
28455: GO 28859
// for i = 1 to mc_bases do
28457: LD_ADDR_VAR 0 2
28461: PUSH
28462: DOUBLE
28463: LD_INT 1
28465: DEC
28466: ST_TO_ADDR
28467: LD_EXP 50
28471: PUSH
28472: FOR_TO
28473: IFFALSE 28857
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28475: LD_EXP 53
28479: PUSH
28480: LD_VAR 0 2
28484: ARRAY
28485: PUSH
28486: LD_INT 1
28488: ARRAY
28489: NOT
28490: PUSH
28491: LD_EXP 53
28495: PUSH
28496: LD_VAR 0 2
28500: ARRAY
28501: PUSH
28502: LD_INT 2
28504: ARRAY
28505: NOT
28506: AND
28507: IFFALSE 28545
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28509: LD_ADDR_EXP 54
28513: PUSH
28514: LD_EXP 54
28518: PPUSH
28519: LD_VAR 0 2
28523: PPUSH
28524: EMPTY
28525: PPUSH
28526: CALL_OW 1
28530: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28531: LD_VAR 0 2
28535: PPUSH
28536: LD_INT 102
28538: PPUSH
28539: CALL 22580 0 2
// continue ;
28543: GO 28472
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28545: LD_ADDR_VAR 0 4
28549: PUSH
28550: LD_EXP 50
28554: PUSH
28555: LD_VAR 0 2
28559: ARRAY
28560: PPUSH
28561: LD_INT 25
28563: PUSH
28564: LD_INT 4
28566: PUSH
28567: EMPTY
28568: LIST
28569: LIST
28570: PPUSH
28571: CALL_OW 72
28575: ST_TO_ADDR
// if not tmp then
28576: LD_VAR 0 4
28580: NOT
28581: IFFALSE 28585
// continue ;
28583: GO 28472
// if mc_taming [ i ] then
28585: LD_EXP 81
28589: PUSH
28590: LD_VAR 0 2
28594: ARRAY
28595: IFFALSE 28619
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28597: LD_ADDR_EXP 81
28601: PUSH
28602: LD_EXP 81
28606: PPUSH
28607: LD_VAR 0 2
28611: PPUSH
28612: EMPTY
28613: PPUSH
28614: CALL_OW 1
28618: ST_TO_ADDR
// for j in tmp do
28619: LD_ADDR_VAR 0 3
28623: PUSH
28624: LD_VAR 0 4
28628: PUSH
28629: FOR_IN
28630: IFFALSE 28853
// begin if IsInUnit ( j ) then
28632: LD_VAR 0 3
28636: PPUSH
28637: CALL_OW 310
28641: IFFALSE 28652
// ComExitBuilding ( j ) ;
28643: LD_VAR 0 3
28647: PPUSH
28648: CALL_OW 122
// if not j in mc_healers [ i ] then
28652: LD_VAR 0 3
28656: PUSH
28657: LD_EXP 54
28661: PUSH
28662: LD_VAR 0 2
28666: ARRAY
28667: IN
28668: NOT
28669: IFFALSE 28715
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28671: LD_ADDR_EXP 54
28675: PUSH
28676: LD_EXP 54
28680: PPUSH
28681: LD_VAR 0 2
28685: PUSH
28686: LD_EXP 54
28690: PUSH
28691: LD_VAR 0 2
28695: ARRAY
28696: PUSH
28697: LD_INT 1
28699: PLUS
28700: PUSH
28701: EMPTY
28702: LIST
28703: LIST
28704: PPUSH
28705: LD_VAR 0 3
28709: PPUSH
28710: CALL 54081 0 3
28714: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28715: LD_VAR 0 3
28719: PPUSH
28720: CALL_OW 110
28724: PUSH
28725: LD_INT 102
28727: NONEQUAL
28728: IFFALSE 28742
// SetTag ( j , 102 ) ;
28730: LD_VAR 0 3
28734: PPUSH
28735: LD_INT 102
28737: PPUSH
28738: CALL_OW 109
// Wait ( 3 ) ;
28742: LD_INT 3
28744: PPUSH
28745: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28749: LD_EXP 53
28753: PUSH
28754: LD_VAR 0 2
28758: ARRAY
28759: PUSH
28760: LD_INT 1
28762: ARRAY
28763: IFFALSE 28795
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28765: LD_VAR 0 3
28769: PPUSH
28770: LD_EXP 53
28774: PUSH
28775: LD_VAR 0 2
28779: ARRAY
28780: PUSH
28781: LD_INT 1
28783: ARRAY
28784: PUSH
28785: LD_INT 1
28787: ARRAY
28788: PPUSH
28789: CALL_OW 128
28793: GO 28851
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28795: LD_VAR 0 3
28799: PPUSH
28800: CALL_OW 314
28804: NOT
28805: PUSH
28806: LD_EXP 53
28810: PUSH
28811: LD_VAR 0 2
28815: ARRAY
28816: PUSH
28817: LD_INT 2
28819: ARRAY
28820: AND
28821: IFFALSE 28851
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28823: LD_VAR 0 3
28827: PPUSH
28828: LD_EXP 53
28832: PUSH
28833: LD_VAR 0 2
28837: ARRAY
28838: PUSH
28839: LD_INT 2
28841: ARRAY
28842: PUSH
28843: LD_INT 1
28845: ARRAY
28846: PPUSH
28847: CALL_OW 128
// end ;
28851: GO 28629
28853: POP
28854: POP
// end ;
28855: GO 28472
28857: POP
28858: POP
// end ;
28859: LD_VAR 0 1
28863: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28864: LD_INT 0
28866: PPUSH
28867: PPUSH
28868: PPUSH
28869: PPUSH
28870: PPUSH
28871: PPUSH
// if not mc_bases then
28872: LD_EXP 50
28876: NOT
28877: IFFALSE 28881
// exit ;
28879: GO 30044
// for i = 1 to mc_bases do
28881: LD_ADDR_VAR 0 2
28885: PUSH
28886: DOUBLE
28887: LD_INT 1
28889: DEC
28890: ST_TO_ADDR
28891: LD_EXP 50
28895: PUSH
28896: FOR_TO
28897: IFFALSE 30042
// begin if mc_scan [ i ] then
28899: LD_EXP 73
28903: PUSH
28904: LD_VAR 0 2
28908: ARRAY
28909: IFFALSE 28913
// continue ;
28911: GO 28896
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28913: LD_EXP 55
28917: PUSH
28918: LD_VAR 0 2
28922: ARRAY
28923: NOT
28924: PUSH
28925: LD_EXP 57
28929: PUSH
28930: LD_VAR 0 2
28934: ARRAY
28935: NOT
28936: AND
28937: PUSH
28938: LD_EXP 56
28942: PUSH
28943: LD_VAR 0 2
28947: ARRAY
28948: AND
28949: IFFALSE 28987
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28951: LD_ADDR_EXP 56
28955: PUSH
28956: LD_EXP 56
28960: PPUSH
28961: LD_VAR 0 2
28965: PPUSH
28966: EMPTY
28967: PPUSH
28968: CALL_OW 1
28972: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28973: LD_VAR 0 2
28977: PPUSH
28978: LD_INT 103
28980: PPUSH
28981: CALL 22580 0 2
// continue ;
28985: GO 28896
// end ; if mc_construct_list [ i ] then
28987: LD_EXP 57
28991: PUSH
28992: LD_VAR 0 2
28996: ARRAY
28997: IFFALSE 29217
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28999: LD_ADDR_VAR 0 5
29003: PUSH
29004: LD_EXP 50
29008: PUSH
29009: LD_VAR 0 2
29013: ARRAY
29014: PPUSH
29015: LD_INT 25
29017: PUSH
29018: LD_INT 2
29020: PUSH
29021: EMPTY
29022: LIST
29023: LIST
29024: PPUSH
29025: CALL_OW 72
29029: PUSH
29030: LD_EXP 52
29034: PUSH
29035: LD_VAR 0 2
29039: ARRAY
29040: DIFF
29041: ST_TO_ADDR
// if not tmp then
29042: LD_VAR 0 5
29046: NOT
29047: IFFALSE 29051
// continue ;
29049: GO 28896
// for j in tmp do
29051: LD_ADDR_VAR 0 3
29055: PUSH
29056: LD_VAR 0 5
29060: PUSH
29061: FOR_IN
29062: IFFALSE 29213
// begin if not mc_builders [ i ] then
29064: LD_EXP 56
29068: PUSH
29069: LD_VAR 0 2
29073: ARRAY
29074: NOT
29075: IFFALSE 29133
// begin SetTag ( j , 103 ) ;
29077: LD_VAR 0 3
29081: PPUSH
29082: LD_INT 103
29084: PPUSH
29085: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29089: LD_ADDR_EXP 56
29093: PUSH
29094: LD_EXP 56
29098: PPUSH
29099: LD_VAR 0 2
29103: PUSH
29104: LD_EXP 56
29108: PUSH
29109: LD_VAR 0 2
29113: ARRAY
29114: PUSH
29115: LD_INT 1
29117: PLUS
29118: PUSH
29119: EMPTY
29120: LIST
29121: LIST
29122: PPUSH
29123: LD_VAR 0 3
29127: PPUSH
29128: CALL 54081 0 3
29132: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29133: LD_VAR 0 3
29137: PPUSH
29138: CALL_OW 310
29142: IFFALSE 29153
// ComExitBuilding ( j ) ;
29144: LD_VAR 0 3
29148: PPUSH
29149: CALL_OW 122
// wait ( 3 ) ;
29153: LD_INT 3
29155: PPUSH
29156: CALL_OW 67
// if not mc_construct_list [ i ] then
29160: LD_EXP 57
29164: PUSH
29165: LD_VAR 0 2
29169: ARRAY
29170: NOT
29171: IFFALSE 29175
// break ;
29173: GO 29213
// if not HasTask ( j ) then
29175: LD_VAR 0 3
29179: PPUSH
29180: CALL_OW 314
29184: NOT
29185: IFFALSE 29211
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
29187: LD_VAR 0 3
29191: PPUSH
29192: LD_EXP 57
29196: PUSH
29197: LD_VAR 0 2
29201: ARRAY
29202: PUSH
29203: LD_INT 1
29205: ARRAY
29206: PPUSH
29207: CALL 57319 0 2
// end ;
29211: GO 29061
29213: POP
29214: POP
// end else
29215: GO 30040
// if mc_build_list [ i ] then
29217: LD_EXP 55
29221: PUSH
29222: LD_VAR 0 2
29226: ARRAY
29227: IFFALSE 30040
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
29229: LD_EXP 55
29233: PUSH
29234: LD_VAR 0 2
29238: ARRAY
29239: PUSH
29240: LD_INT 1
29242: ARRAY
29243: PUSH
29244: LD_INT 1
29246: ARRAY
29247: PPUSH
29248: CALL 57143 0 1
29252: PUSH
29253: LD_EXP 50
29257: PUSH
29258: LD_VAR 0 2
29262: ARRAY
29263: PPUSH
29264: LD_INT 2
29266: PUSH
29267: LD_INT 30
29269: PUSH
29270: LD_INT 2
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: PUSH
29277: LD_INT 30
29279: PUSH
29280: LD_INT 3
29282: PUSH
29283: EMPTY
29284: LIST
29285: LIST
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: LIST
29291: PPUSH
29292: CALL_OW 72
29296: NOT
29297: AND
29298: IFFALSE 29403
// begin for j = 1 to mc_build_list [ i ] do
29300: LD_ADDR_VAR 0 3
29304: PUSH
29305: DOUBLE
29306: LD_INT 1
29308: DEC
29309: ST_TO_ADDR
29310: LD_EXP 55
29314: PUSH
29315: LD_VAR 0 2
29319: ARRAY
29320: PUSH
29321: FOR_TO
29322: IFFALSE 29401
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
29324: LD_EXP 55
29328: PUSH
29329: LD_VAR 0 2
29333: ARRAY
29334: PUSH
29335: LD_VAR 0 3
29339: ARRAY
29340: PUSH
29341: LD_INT 1
29343: ARRAY
29344: PUSH
29345: LD_INT 2
29347: EQUAL
29348: IFFALSE 29399
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
29350: LD_ADDR_EXP 55
29354: PUSH
29355: LD_EXP 55
29359: PPUSH
29360: LD_VAR 0 2
29364: PPUSH
29365: LD_EXP 55
29369: PUSH
29370: LD_VAR 0 2
29374: ARRAY
29375: PPUSH
29376: LD_VAR 0 3
29380: PPUSH
29381: LD_INT 1
29383: PPUSH
29384: LD_INT 0
29386: PPUSH
29387: CALL 53499 0 4
29391: PPUSH
29392: CALL_OW 1
29396: ST_TO_ADDR
// break ;
29397: GO 29401
// end ;
29399: GO 29321
29401: POP
29402: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29403: LD_ADDR_VAR 0 6
29407: PUSH
29408: LD_EXP 50
29412: PUSH
29413: LD_VAR 0 2
29417: ARRAY
29418: PPUSH
29419: LD_INT 2
29421: PUSH
29422: LD_INT 30
29424: PUSH
29425: LD_INT 0
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: LD_INT 30
29434: PUSH
29435: LD_INT 1
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: LIST
29446: PPUSH
29447: CALL_OW 72
29451: ST_TO_ADDR
// for k := 1 to depot do
29452: LD_ADDR_VAR 0 4
29456: PUSH
29457: DOUBLE
29458: LD_INT 1
29460: DEC
29461: ST_TO_ADDR
29462: LD_VAR 0 6
29466: PUSH
29467: FOR_TO
29468: IFFALSE 30038
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29470: LD_EXP 55
29474: PUSH
29475: LD_VAR 0 2
29479: ARRAY
29480: PUSH
29481: LD_INT 1
29483: ARRAY
29484: PUSH
29485: LD_INT 1
29487: ARRAY
29488: PUSH
29489: LD_INT 0
29491: EQUAL
29492: PUSH
29493: LD_VAR 0 6
29497: PUSH
29498: LD_VAR 0 4
29502: ARRAY
29503: PPUSH
29504: LD_EXP 55
29508: PUSH
29509: LD_VAR 0 2
29513: ARRAY
29514: PUSH
29515: LD_INT 1
29517: ARRAY
29518: PUSH
29519: LD_INT 1
29521: ARRAY
29522: PPUSH
29523: LD_EXP 55
29527: PUSH
29528: LD_VAR 0 2
29532: ARRAY
29533: PUSH
29534: LD_INT 1
29536: ARRAY
29537: PUSH
29538: LD_INT 2
29540: ARRAY
29541: PPUSH
29542: LD_EXP 55
29546: PUSH
29547: LD_VAR 0 2
29551: ARRAY
29552: PUSH
29553: LD_INT 1
29555: ARRAY
29556: PUSH
29557: LD_INT 3
29559: ARRAY
29560: PPUSH
29561: LD_EXP 55
29565: PUSH
29566: LD_VAR 0 2
29570: ARRAY
29571: PUSH
29572: LD_INT 1
29574: ARRAY
29575: PUSH
29576: LD_INT 4
29578: ARRAY
29579: PPUSH
29580: CALL 62555 0 5
29584: OR
29585: IFFALSE 29866
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29587: LD_ADDR_VAR 0 5
29591: PUSH
29592: LD_EXP 50
29596: PUSH
29597: LD_VAR 0 2
29601: ARRAY
29602: PPUSH
29603: LD_INT 25
29605: PUSH
29606: LD_INT 2
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: PPUSH
29613: CALL_OW 72
29617: PUSH
29618: LD_EXP 52
29622: PUSH
29623: LD_VAR 0 2
29627: ARRAY
29628: DIFF
29629: ST_TO_ADDR
// if not tmp then
29630: LD_VAR 0 5
29634: NOT
29635: IFFALSE 29639
// continue ;
29637: GO 29467
// for j in tmp do
29639: LD_ADDR_VAR 0 3
29643: PUSH
29644: LD_VAR 0 5
29648: PUSH
29649: FOR_IN
29650: IFFALSE 29862
// begin if not mc_builders [ i ] then
29652: LD_EXP 56
29656: PUSH
29657: LD_VAR 0 2
29661: ARRAY
29662: NOT
29663: IFFALSE 29721
// begin SetTag ( j , 103 ) ;
29665: LD_VAR 0 3
29669: PPUSH
29670: LD_INT 103
29672: PPUSH
29673: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29677: LD_ADDR_EXP 56
29681: PUSH
29682: LD_EXP 56
29686: PPUSH
29687: LD_VAR 0 2
29691: PUSH
29692: LD_EXP 56
29696: PUSH
29697: LD_VAR 0 2
29701: ARRAY
29702: PUSH
29703: LD_INT 1
29705: PLUS
29706: PUSH
29707: EMPTY
29708: LIST
29709: LIST
29710: PPUSH
29711: LD_VAR 0 3
29715: PPUSH
29716: CALL 54081 0 3
29720: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29721: LD_VAR 0 3
29725: PPUSH
29726: CALL_OW 310
29730: IFFALSE 29741
// ComExitBuilding ( j ) ;
29732: LD_VAR 0 3
29736: PPUSH
29737: CALL_OW 122
// wait ( 3 ) ;
29741: LD_INT 3
29743: PPUSH
29744: CALL_OW 67
// if not mc_build_list [ i ] then
29748: LD_EXP 55
29752: PUSH
29753: LD_VAR 0 2
29757: ARRAY
29758: NOT
29759: IFFALSE 29763
// break ;
29761: GO 29862
// if not HasTask ( j ) then
29763: LD_VAR 0 3
29767: PPUSH
29768: CALL_OW 314
29772: NOT
29773: IFFALSE 29860
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29775: LD_VAR 0 3
29779: PPUSH
29780: LD_EXP 55
29784: PUSH
29785: LD_VAR 0 2
29789: ARRAY
29790: PUSH
29791: LD_INT 1
29793: ARRAY
29794: PUSH
29795: LD_INT 1
29797: ARRAY
29798: PPUSH
29799: LD_EXP 55
29803: PUSH
29804: LD_VAR 0 2
29808: ARRAY
29809: PUSH
29810: LD_INT 1
29812: ARRAY
29813: PUSH
29814: LD_INT 2
29816: ARRAY
29817: PPUSH
29818: LD_EXP 55
29822: PUSH
29823: LD_VAR 0 2
29827: ARRAY
29828: PUSH
29829: LD_INT 1
29831: ARRAY
29832: PUSH
29833: LD_INT 3
29835: ARRAY
29836: PPUSH
29837: LD_EXP 55
29841: PUSH
29842: LD_VAR 0 2
29846: ARRAY
29847: PUSH
29848: LD_INT 1
29850: ARRAY
29851: PUSH
29852: LD_INT 4
29854: ARRAY
29855: PPUSH
29856: CALL_OW 145
// end ;
29860: GO 29649
29862: POP
29863: POP
// end else
29864: GO 30036
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29866: LD_EXP 50
29870: PUSH
29871: LD_VAR 0 2
29875: ARRAY
29876: PPUSH
29877: LD_EXP 55
29881: PUSH
29882: LD_VAR 0 2
29886: ARRAY
29887: PUSH
29888: LD_INT 1
29890: ARRAY
29891: PUSH
29892: LD_INT 1
29894: ARRAY
29895: PPUSH
29896: LD_EXP 55
29900: PUSH
29901: LD_VAR 0 2
29905: ARRAY
29906: PUSH
29907: LD_INT 1
29909: ARRAY
29910: PUSH
29911: LD_INT 2
29913: ARRAY
29914: PPUSH
29915: LD_EXP 55
29919: PUSH
29920: LD_VAR 0 2
29924: ARRAY
29925: PUSH
29926: LD_INT 1
29928: ARRAY
29929: PUSH
29930: LD_INT 3
29932: ARRAY
29933: PPUSH
29934: LD_EXP 55
29938: PUSH
29939: LD_VAR 0 2
29943: ARRAY
29944: PUSH
29945: LD_INT 1
29947: ARRAY
29948: PUSH
29949: LD_INT 4
29951: ARRAY
29952: PPUSH
29953: LD_EXP 50
29957: PUSH
29958: LD_VAR 0 2
29962: ARRAY
29963: PPUSH
29964: LD_INT 21
29966: PUSH
29967: LD_INT 3
29969: PUSH
29970: EMPTY
29971: LIST
29972: LIST
29973: PPUSH
29974: CALL_OW 72
29978: PPUSH
29979: EMPTY
29980: PPUSH
29981: CALL 61309 0 7
29985: NOT
29986: IFFALSE 30036
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29988: LD_ADDR_EXP 55
29992: PUSH
29993: LD_EXP 55
29997: PPUSH
29998: LD_VAR 0 2
30002: PPUSH
30003: LD_EXP 55
30007: PUSH
30008: LD_VAR 0 2
30012: ARRAY
30013: PPUSH
30014: LD_INT 1
30016: PPUSH
30017: LD_INT 1
30019: NEG
30020: PPUSH
30021: LD_INT 0
30023: PPUSH
30024: CALL 53499 0 4
30028: PPUSH
30029: CALL_OW 1
30033: ST_TO_ADDR
// continue ;
30034: GO 29467
// end ; end ;
30036: GO 29467
30038: POP
30039: POP
// end ; end ;
30040: GO 28896
30042: POP
30043: POP
// end ;
30044: LD_VAR 0 1
30048: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
30049: LD_INT 0
30051: PPUSH
30052: PPUSH
30053: PPUSH
30054: PPUSH
30055: PPUSH
30056: PPUSH
// if not mc_bases then
30057: LD_EXP 50
30061: NOT
30062: IFFALSE 30066
// exit ;
30064: GO 30493
// for i = 1 to mc_bases do
30066: LD_ADDR_VAR 0 2
30070: PUSH
30071: DOUBLE
30072: LD_INT 1
30074: DEC
30075: ST_TO_ADDR
30076: LD_EXP 50
30080: PUSH
30081: FOR_TO
30082: IFFALSE 30491
// begin tmp := mc_build_upgrade [ i ] ;
30084: LD_ADDR_VAR 0 4
30088: PUSH
30089: LD_EXP 82
30093: PUSH
30094: LD_VAR 0 2
30098: ARRAY
30099: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
30100: LD_ADDR_VAR 0 6
30104: PUSH
30105: LD_EXP 83
30109: PUSH
30110: LD_VAR 0 2
30114: ARRAY
30115: PPUSH
30116: LD_INT 2
30118: PUSH
30119: LD_INT 30
30121: PUSH
30122: LD_INT 6
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: PUSH
30129: LD_INT 30
30131: PUSH
30132: LD_INT 7
30134: PUSH
30135: EMPTY
30136: LIST
30137: LIST
30138: PUSH
30139: EMPTY
30140: LIST
30141: LIST
30142: LIST
30143: PPUSH
30144: CALL_OW 72
30148: ST_TO_ADDR
// if not tmp and not lab then
30149: LD_VAR 0 4
30153: NOT
30154: PUSH
30155: LD_VAR 0 6
30159: NOT
30160: AND
30161: IFFALSE 30165
// continue ;
30163: GO 30081
// if tmp then
30165: LD_VAR 0 4
30169: IFFALSE 30289
// for j in tmp do
30171: LD_ADDR_VAR 0 3
30175: PUSH
30176: LD_VAR 0 4
30180: PUSH
30181: FOR_IN
30182: IFFALSE 30287
// begin if UpgradeCost ( j ) then
30184: LD_VAR 0 3
30188: PPUSH
30189: CALL 60969 0 1
30193: IFFALSE 30285
// begin ComUpgrade ( j ) ;
30195: LD_VAR 0 3
30199: PPUSH
30200: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
30204: LD_ADDR_EXP 82
30208: PUSH
30209: LD_EXP 82
30213: PPUSH
30214: LD_VAR 0 2
30218: PPUSH
30219: LD_EXP 82
30223: PUSH
30224: LD_VAR 0 2
30228: ARRAY
30229: PUSH
30230: LD_VAR 0 3
30234: DIFF
30235: PPUSH
30236: CALL_OW 1
30240: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30241: LD_ADDR_EXP 57
30245: PUSH
30246: LD_EXP 57
30250: PPUSH
30251: LD_VAR 0 2
30255: PUSH
30256: LD_EXP 57
30260: PUSH
30261: LD_VAR 0 2
30265: ARRAY
30266: PUSH
30267: LD_INT 1
30269: PLUS
30270: PUSH
30271: EMPTY
30272: LIST
30273: LIST
30274: PPUSH
30275: LD_VAR 0 3
30279: PPUSH
30280: CALL 54081 0 3
30284: ST_TO_ADDR
// end ; end ;
30285: GO 30181
30287: POP
30288: POP
// if not lab or not mc_lab_upgrade [ i ] then
30289: LD_VAR 0 6
30293: NOT
30294: PUSH
30295: LD_EXP 84
30299: PUSH
30300: LD_VAR 0 2
30304: ARRAY
30305: NOT
30306: OR
30307: IFFALSE 30311
// continue ;
30309: GO 30081
// for j in lab do
30311: LD_ADDR_VAR 0 3
30315: PUSH
30316: LD_VAR 0 6
30320: PUSH
30321: FOR_IN
30322: IFFALSE 30487
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
30324: LD_VAR 0 3
30328: PPUSH
30329: CALL_OW 266
30333: PUSH
30334: LD_INT 6
30336: PUSH
30337: LD_INT 7
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: IN
30344: PUSH
30345: LD_VAR 0 3
30349: PPUSH
30350: CALL_OW 461
30354: PUSH
30355: LD_INT 1
30357: NONEQUAL
30358: AND
30359: IFFALSE 30485
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
30361: LD_VAR 0 3
30365: PPUSH
30366: LD_EXP 84
30370: PUSH
30371: LD_VAR 0 2
30375: ARRAY
30376: PUSH
30377: LD_INT 1
30379: ARRAY
30380: PPUSH
30381: CALL 61174 0 2
30385: IFFALSE 30485
// begin ComCancel ( j ) ;
30387: LD_VAR 0 3
30391: PPUSH
30392: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
30396: LD_VAR 0 3
30400: PPUSH
30401: LD_EXP 84
30405: PUSH
30406: LD_VAR 0 2
30410: ARRAY
30411: PUSH
30412: LD_INT 1
30414: ARRAY
30415: PPUSH
30416: CALL_OW 207
// if not j in mc_construct_list [ i ] then
30420: LD_VAR 0 3
30424: PUSH
30425: LD_EXP 57
30429: PUSH
30430: LD_VAR 0 2
30434: ARRAY
30435: IN
30436: NOT
30437: IFFALSE 30483
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30439: LD_ADDR_EXP 57
30443: PUSH
30444: LD_EXP 57
30448: PPUSH
30449: LD_VAR 0 2
30453: PUSH
30454: LD_EXP 57
30458: PUSH
30459: LD_VAR 0 2
30463: ARRAY
30464: PUSH
30465: LD_INT 1
30467: PLUS
30468: PUSH
30469: EMPTY
30470: LIST
30471: LIST
30472: PPUSH
30473: LD_VAR 0 3
30477: PPUSH
30478: CALL 54081 0 3
30482: ST_TO_ADDR
// break ;
30483: GO 30487
// end ; end ; end ;
30485: GO 30321
30487: POP
30488: POP
// end ;
30489: GO 30081
30491: POP
30492: POP
// end ;
30493: LD_VAR 0 1
30497: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30498: LD_INT 0
30500: PPUSH
30501: PPUSH
30502: PPUSH
30503: PPUSH
30504: PPUSH
30505: PPUSH
30506: PPUSH
30507: PPUSH
30508: PPUSH
// if not mc_bases then
30509: LD_EXP 50
30513: NOT
30514: IFFALSE 30518
// exit ;
30516: GO 30923
// for i = 1 to mc_bases do
30518: LD_ADDR_VAR 0 2
30522: PUSH
30523: DOUBLE
30524: LD_INT 1
30526: DEC
30527: ST_TO_ADDR
30528: LD_EXP 50
30532: PUSH
30533: FOR_TO
30534: IFFALSE 30921
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30536: LD_EXP 58
30540: PUSH
30541: LD_VAR 0 2
30545: ARRAY
30546: NOT
30547: PUSH
30548: LD_EXP 50
30552: PUSH
30553: LD_VAR 0 2
30557: ARRAY
30558: PPUSH
30559: LD_INT 30
30561: PUSH
30562: LD_INT 3
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PPUSH
30569: CALL_OW 72
30573: NOT
30574: OR
30575: IFFALSE 30579
// continue ;
30577: GO 30533
// busy := false ;
30579: LD_ADDR_VAR 0 8
30583: PUSH
30584: LD_INT 0
30586: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30587: LD_ADDR_VAR 0 4
30591: PUSH
30592: LD_EXP 50
30596: PUSH
30597: LD_VAR 0 2
30601: ARRAY
30602: PPUSH
30603: LD_INT 30
30605: PUSH
30606: LD_INT 3
30608: PUSH
30609: EMPTY
30610: LIST
30611: LIST
30612: PPUSH
30613: CALL_OW 72
30617: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30618: LD_ADDR_VAR 0 6
30622: PUSH
30623: LD_EXP 58
30627: PUSH
30628: LD_VAR 0 2
30632: ARRAY
30633: PPUSH
30634: LD_INT 2
30636: PUSH
30637: LD_INT 30
30639: PUSH
30640: LD_INT 32
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 30
30649: PUSH
30650: LD_INT 33
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: PUSH
30657: EMPTY
30658: LIST
30659: LIST
30660: LIST
30661: PPUSH
30662: CALL_OW 72
30666: ST_TO_ADDR
// if not t then
30667: LD_VAR 0 6
30671: NOT
30672: IFFALSE 30676
// continue ;
30674: GO 30533
// for j in tmp do
30676: LD_ADDR_VAR 0 3
30680: PUSH
30681: LD_VAR 0 4
30685: PUSH
30686: FOR_IN
30687: IFFALSE 30717
// if not BuildingStatus ( j ) = bs_idle then
30689: LD_VAR 0 3
30693: PPUSH
30694: CALL_OW 461
30698: PUSH
30699: LD_INT 2
30701: EQUAL
30702: NOT
30703: IFFALSE 30715
// begin busy := true ;
30705: LD_ADDR_VAR 0 8
30709: PUSH
30710: LD_INT 1
30712: ST_TO_ADDR
// break ;
30713: GO 30717
// end ;
30715: GO 30686
30717: POP
30718: POP
// if busy then
30719: LD_VAR 0 8
30723: IFFALSE 30727
// continue ;
30725: GO 30533
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30727: LD_ADDR_VAR 0 7
30731: PUSH
30732: LD_VAR 0 6
30736: PPUSH
30737: LD_INT 35
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: EMPTY
30744: LIST
30745: LIST
30746: PPUSH
30747: CALL_OW 72
30751: ST_TO_ADDR
// if tw then
30752: LD_VAR 0 7
30756: IFFALSE 30833
// begin tw := tw [ 1 ] ;
30758: LD_ADDR_VAR 0 7
30762: PUSH
30763: LD_VAR 0 7
30767: PUSH
30768: LD_INT 1
30770: ARRAY
30771: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30772: LD_ADDR_VAR 0 9
30776: PUSH
30777: LD_VAR 0 7
30781: PPUSH
30782: LD_EXP 75
30786: PUSH
30787: LD_VAR 0 2
30791: ARRAY
30792: PPUSH
30793: CALL 59466 0 2
30797: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30798: LD_EXP 89
30802: PUSH
30803: LD_VAR 0 2
30807: ARRAY
30808: IFFALSE 30831
// if not weapon in mc_allowed_tower_weapons [ i ] then
30810: LD_VAR 0 9
30814: PUSH
30815: LD_EXP 89
30819: PUSH
30820: LD_VAR 0 2
30824: ARRAY
30825: IN
30826: NOT
30827: IFFALSE 30831
// continue ;
30829: GO 30533
// end else
30831: GO 30896
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30833: LD_ADDR_VAR 0 5
30837: PUSH
30838: LD_EXP 58
30842: PUSH
30843: LD_VAR 0 2
30847: ARRAY
30848: PPUSH
30849: LD_VAR 0 4
30853: PPUSH
30854: CALL 86369 0 2
30858: ST_TO_ADDR
// if not tmp2 then
30859: LD_VAR 0 5
30863: NOT
30864: IFFALSE 30868
// continue ;
30866: GO 30533
// tw := tmp2 [ 1 ] ;
30868: LD_ADDR_VAR 0 7
30872: PUSH
30873: LD_VAR 0 5
30877: PUSH
30878: LD_INT 1
30880: ARRAY
30881: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30882: LD_ADDR_VAR 0 9
30886: PUSH
30887: LD_VAR 0 5
30891: PUSH
30892: LD_INT 2
30894: ARRAY
30895: ST_TO_ADDR
// end ; if not weapon then
30896: LD_VAR 0 9
30900: NOT
30901: IFFALSE 30905
// continue ;
30903: GO 30533
// ComPlaceWeapon ( tw , weapon ) ;
30905: LD_VAR 0 7
30909: PPUSH
30910: LD_VAR 0 9
30914: PPUSH
30915: CALL_OW 148
// end ;
30919: GO 30533
30921: POP
30922: POP
// end ;
30923: LD_VAR 0 1
30927: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30928: LD_INT 0
30930: PPUSH
30931: PPUSH
30932: PPUSH
30933: PPUSH
30934: PPUSH
30935: PPUSH
30936: PPUSH
// if not mc_bases then
30937: LD_EXP 50
30941: NOT
30942: IFFALSE 30946
// exit ;
30944: GO 31721
// for i = 1 to mc_bases do
30946: LD_ADDR_VAR 0 2
30950: PUSH
30951: DOUBLE
30952: LD_INT 1
30954: DEC
30955: ST_TO_ADDR
30956: LD_EXP 50
30960: PUSH
30961: FOR_TO
30962: IFFALSE 31719
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30964: LD_EXP 63
30968: PUSH
30969: LD_VAR 0 2
30973: ARRAY
30974: NOT
30975: PUSH
30976: LD_EXP 63
30980: PUSH
30981: LD_VAR 0 2
30985: ARRAY
30986: PUSH
30987: LD_EXP 64
30991: PUSH
30992: LD_VAR 0 2
30996: ARRAY
30997: EQUAL
30998: OR
30999: PUSH
31000: LD_EXP 73
31004: PUSH
31005: LD_VAR 0 2
31009: ARRAY
31010: OR
31011: IFFALSE 31015
// continue ;
31013: GO 30961
// if mc_miners [ i ] then
31015: LD_EXP 64
31019: PUSH
31020: LD_VAR 0 2
31024: ARRAY
31025: IFFALSE 31406
// begin for j = mc_miners [ i ] downto 1 do
31027: LD_ADDR_VAR 0 3
31031: PUSH
31032: DOUBLE
31033: LD_EXP 64
31037: PUSH
31038: LD_VAR 0 2
31042: ARRAY
31043: INC
31044: ST_TO_ADDR
31045: LD_INT 1
31047: PUSH
31048: FOR_DOWNTO
31049: IFFALSE 31404
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
31051: LD_EXP 64
31055: PUSH
31056: LD_VAR 0 2
31060: ARRAY
31061: PUSH
31062: LD_VAR 0 3
31066: ARRAY
31067: PPUSH
31068: CALL_OW 301
31072: PUSH
31073: LD_EXP 64
31077: PUSH
31078: LD_VAR 0 2
31082: ARRAY
31083: PUSH
31084: LD_VAR 0 3
31088: ARRAY
31089: PPUSH
31090: CALL_OW 257
31094: PUSH
31095: LD_INT 1
31097: NONEQUAL
31098: OR
31099: IFFALSE 31162
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
31101: LD_ADDR_VAR 0 5
31105: PUSH
31106: LD_EXP 64
31110: PUSH
31111: LD_VAR 0 2
31115: ARRAY
31116: PUSH
31117: LD_EXP 64
31121: PUSH
31122: LD_VAR 0 2
31126: ARRAY
31127: PUSH
31128: LD_VAR 0 3
31132: ARRAY
31133: DIFF
31134: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
31135: LD_ADDR_EXP 64
31139: PUSH
31140: LD_EXP 64
31144: PPUSH
31145: LD_VAR 0 2
31149: PPUSH
31150: LD_VAR 0 5
31154: PPUSH
31155: CALL_OW 1
31159: ST_TO_ADDR
// continue ;
31160: GO 31048
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
31162: LD_EXP 64
31166: PUSH
31167: LD_VAR 0 2
31171: ARRAY
31172: PUSH
31173: LD_VAR 0 3
31177: ARRAY
31178: PPUSH
31179: CALL_OW 257
31183: PUSH
31184: LD_INT 1
31186: EQUAL
31187: PUSH
31188: LD_EXP 64
31192: PUSH
31193: LD_VAR 0 2
31197: ARRAY
31198: PUSH
31199: LD_VAR 0 3
31203: ARRAY
31204: PPUSH
31205: CALL_OW 459
31209: NOT
31210: AND
31211: PUSH
31212: LD_EXP 64
31216: PUSH
31217: LD_VAR 0 2
31221: ARRAY
31222: PUSH
31223: LD_VAR 0 3
31227: ARRAY
31228: PPUSH
31229: CALL_OW 314
31233: NOT
31234: AND
31235: IFFALSE 31402
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
31237: LD_EXP 64
31241: PUSH
31242: LD_VAR 0 2
31246: ARRAY
31247: PUSH
31248: LD_VAR 0 3
31252: ARRAY
31253: PPUSH
31254: CALL_OW 310
31258: IFFALSE 31281
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
31260: LD_EXP 64
31264: PUSH
31265: LD_VAR 0 2
31269: ARRAY
31270: PUSH
31271: LD_VAR 0 3
31275: ARRAY
31276: PPUSH
31277: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
31281: LD_EXP 64
31285: PUSH
31286: LD_VAR 0 2
31290: ARRAY
31291: PUSH
31292: LD_VAR 0 3
31296: ARRAY
31297: PPUSH
31298: CALL_OW 314
31302: NOT
31303: IFFALSE 31402
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
31305: LD_ADDR_VAR 0 7
31309: PUSH
31310: LD_VAR 0 3
31314: PUSH
31315: LD_EXP 63
31319: PUSH
31320: LD_VAR 0 2
31324: ARRAY
31325: PPUSH
31326: CALL 51221 0 1
31330: MOD
31331: PUSH
31332: LD_INT 1
31334: PLUS
31335: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
31336: LD_EXP 64
31340: PUSH
31341: LD_VAR 0 2
31345: ARRAY
31346: PUSH
31347: LD_VAR 0 3
31351: ARRAY
31352: PPUSH
31353: LD_EXP 63
31357: PUSH
31358: LD_VAR 0 2
31362: ARRAY
31363: PUSH
31364: LD_VAR 0 7
31368: ARRAY
31369: PUSH
31370: LD_INT 1
31372: ARRAY
31373: PPUSH
31374: LD_EXP 63
31378: PUSH
31379: LD_VAR 0 2
31383: ARRAY
31384: PUSH
31385: LD_VAR 0 7
31389: ARRAY
31390: PUSH
31391: LD_INT 2
31393: ARRAY
31394: PPUSH
31395: LD_INT 0
31397: PPUSH
31398: CALL_OW 193
// end ; end ; end ;
31402: GO 31048
31404: POP
31405: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
31406: LD_ADDR_VAR 0 5
31410: PUSH
31411: LD_EXP 50
31415: PUSH
31416: LD_VAR 0 2
31420: ARRAY
31421: PPUSH
31422: LD_INT 2
31424: PUSH
31425: LD_INT 30
31427: PUSH
31428: LD_INT 4
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 30
31437: PUSH
31438: LD_INT 5
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: PUSH
31445: LD_INT 30
31447: PUSH
31448: LD_INT 32
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: LIST
31459: LIST
31460: PPUSH
31461: CALL_OW 72
31465: ST_TO_ADDR
// if not tmp then
31466: LD_VAR 0 5
31470: NOT
31471: IFFALSE 31475
// continue ;
31473: GO 30961
// list := [ ] ;
31475: LD_ADDR_VAR 0 6
31479: PUSH
31480: EMPTY
31481: ST_TO_ADDR
// for j in tmp do
31482: LD_ADDR_VAR 0 3
31486: PUSH
31487: LD_VAR 0 5
31491: PUSH
31492: FOR_IN
31493: IFFALSE 31562
// begin for k in UnitsInside ( j ) do
31495: LD_ADDR_VAR 0 4
31499: PUSH
31500: LD_VAR 0 3
31504: PPUSH
31505: CALL_OW 313
31509: PUSH
31510: FOR_IN
31511: IFFALSE 31558
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31513: LD_VAR 0 4
31517: PPUSH
31518: CALL_OW 257
31522: PUSH
31523: LD_INT 1
31525: EQUAL
31526: PUSH
31527: LD_VAR 0 4
31531: PPUSH
31532: CALL_OW 459
31536: NOT
31537: AND
31538: IFFALSE 31556
// list := list ^ k ;
31540: LD_ADDR_VAR 0 6
31544: PUSH
31545: LD_VAR 0 6
31549: PUSH
31550: LD_VAR 0 4
31554: ADD
31555: ST_TO_ADDR
31556: GO 31510
31558: POP
31559: POP
// end ;
31560: GO 31492
31562: POP
31563: POP
// list := list diff mc_miners [ i ] ;
31564: LD_ADDR_VAR 0 6
31568: PUSH
31569: LD_VAR 0 6
31573: PUSH
31574: LD_EXP 64
31578: PUSH
31579: LD_VAR 0 2
31583: ARRAY
31584: DIFF
31585: ST_TO_ADDR
// if not list then
31586: LD_VAR 0 6
31590: NOT
31591: IFFALSE 31595
// continue ;
31593: GO 30961
// k := mc_mines [ i ] - mc_miners [ i ] ;
31595: LD_ADDR_VAR 0 4
31599: PUSH
31600: LD_EXP 63
31604: PUSH
31605: LD_VAR 0 2
31609: ARRAY
31610: PUSH
31611: LD_EXP 64
31615: PUSH
31616: LD_VAR 0 2
31620: ARRAY
31621: MINUS
31622: ST_TO_ADDR
// if k > list then
31623: LD_VAR 0 4
31627: PUSH
31628: LD_VAR 0 6
31632: GREATER
31633: IFFALSE 31645
// k := list ;
31635: LD_ADDR_VAR 0 4
31639: PUSH
31640: LD_VAR 0 6
31644: ST_TO_ADDR
// for j = 1 to k do
31645: LD_ADDR_VAR 0 3
31649: PUSH
31650: DOUBLE
31651: LD_INT 1
31653: DEC
31654: ST_TO_ADDR
31655: LD_VAR 0 4
31659: PUSH
31660: FOR_TO
31661: IFFALSE 31715
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31663: LD_ADDR_EXP 64
31667: PUSH
31668: LD_EXP 64
31672: PPUSH
31673: LD_VAR 0 2
31677: PUSH
31678: LD_EXP 64
31682: PUSH
31683: LD_VAR 0 2
31687: ARRAY
31688: PUSH
31689: LD_INT 1
31691: PLUS
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PPUSH
31697: LD_VAR 0 6
31701: PUSH
31702: LD_VAR 0 3
31706: ARRAY
31707: PPUSH
31708: CALL 54081 0 3
31712: ST_TO_ADDR
31713: GO 31660
31715: POP
31716: POP
// end ;
31717: GO 30961
31719: POP
31720: POP
// end ;
31721: LD_VAR 0 1
31725: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31726: LD_INT 0
31728: PPUSH
31729: PPUSH
31730: PPUSH
31731: PPUSH
31732: PPUSH
31733: PPUSH
31734: PPUSH
31735: PPUSH
31736: PPUSH
31737: PPUSH
31738: PPUSH
// if not mc_bases then
31739: LD_EXP 50
31743: NOT
31744: IFFALSE 31748
// exit ;
31746: GO 33571
// for i = 1 to mc_bases do
31748: LD_ADDR_VAR 0 2
31752: PUSH
31753: DOUBLE
31754: LD_INT 1
31756: DEC
31757: ST_TO_ADDR
31758: LD_EXP 50
31762: PUSH
31763: FOR_TO
31764: IFFALSE 33569
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31766: LD_EXP 50
31770: PUSH
31771: LD_VAR 0 2
31775: ARRAY
31776: NOT
31777: PUSH
31778: LD_EXP 57
31782: PUSH
31783: LD_VAR 0 2
31787: ARRAY
31788: OR
31789: IFFALSE 31793
// continue ;
31791: GO 31763
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31793: LD_EXP 66
31797: PUSH
31798: LD_VAR 0 2
31802: ARRAY
31803: NOT
31804: PUSH
31805: LD_EXP 67
31809: PUSH
31810: LD_VAR 0 2
31814: ARRAY
31815: AND
31816: IFFALSE 31854
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31818: LD_ADDR_EXP 67
31822: PUSH
31823: LD_EXP 67
31827: PPUSH
31828: LD_VAR 0 2
31832: PPUSH
31833: EMPTY
31834: PPUSH
31835: CALL_OW 1
31839: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31840: LD_VAR 0 2
31844: PPUSH
31845: LD_INT 107
31847: PPUSH
31848: CALL 22580 0 2
// continue ;
31852: GO 31763
// end ; target := [ ] ;
31854: LD_ADDR_VAR 0 7
31858: PUSH
31859: EMPTY
31860: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31861: LD_ADDR_VAR 0 6
31865: PUSH
31866: LD_EXP 50
31870: PUSH
31871: LD_VAR 0 2
31875: ARRAY
31876: PUSH
31877: LD_INT 1
31879: ARRAY
31880: PPUSH
31881: CALL_OW 255
31885: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31886: LD_ADDR_VAR 0 9
31890: PUSH
31891: LD_EXP 50
31895: PUSH
31896: LD_VAR 0 2
31900: ARRAY
31901: PPUSH
31902: LD_INT 2
31904: PUSH
31905: LD_INT 30
31907: PUSH
31908: LD_INT 0
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: LD_INT 30
31917: PUSH
31918: LD_INT 1
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: EMPTY
31926: LIST
31927: LIST
31928: LIST
31929: PPUSH
31930: CALL_OW 72
31934: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31935: LD_ADDR_VAR 0 3
31939: PUSH
31940: DOUBLE
31941: LD_EXP 66
31945: PUSH
31946: LD_VAR 0 2
31950: ARRAY
31951: INC
31952: ST_TO_ADDR
31953: LD_INT 1
31955: PUSH
31956: FOR_DOWNTO
31957: IFFALSE 32202
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31959: LD_EXP 66
31963: PUSH
31964: LD_VAR 0 2
31968: ARRAY
31969: PUSH
31970: LD_VAR 0 3
31974: ARRAY
31975: PUSH
31976: LD_INT 2
31978: ARRAY
31979: PPUSH
31980: LD_EXP 66
31984: PUSH
31985: LD_VAR 0 2
31989: ARRAY
31990: PUSH
31991: LD_VAR 0 3
31995: ARRAY
31996: PUSH
31997: LD_INT 3
31999: ARRAY
32000: PPUSH
32001: CALL_OW 488
32005: PUSH
32006: LD_EXP 66
32010: PUSH
32011: LD_VAR 0 2
32015: ARRAY
32016: PUSH
32017: LD_VAR 0 3
32021: ARRAY
32022: PUSH
32023: LD_INT 2
32025: ARRAY
32026: PPUSH
32027: LD_EXP 66
32031: PUSH
32032: LD_VAR 0 2
32036: ARRAY
32037: PUSH
32038: LD_VAR 0 3
32042: ARRAY
32043: PUSH
32044: LD_INT 3
32046: ARRAY
32047: PPUSH
32048: CALL_OW 284
32052: PUSH
32053: LD_INT 0
32055: EQUAL
32056: AND
32057: IFFALSE 32112
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
32059: LD_ADDR_VAR 0 5
32063: PUSH
32064: LD_EXP 66
32068: PUSH
32069: LD_VAR 0 2
32073: ARRAY
32074: PPUSH
32075: LD_VAR 0 3
32079: PPUSH
32080: CALL_OW 3
32084: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
32085: LD_ADDR_EXP 66
32089: PUSH
32090: LD_EXP 66
32094: PPUSH
32095: LD_VAR 0 2
32099: PPUSH
32100: LD_VAR 0 5
32104: PPUSH
32105: CALL_OW 1
32109: ST_TO_ADDR
// continue ;
32110: GO 31956
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
32112: LD_VAR 0 6
32116: PPUSH
32117: LD_EXP 66
32121: PUSH
32122: LD_VAR 0 2
32126: ARRAY
32127: PUSH
32128: LD_VAR 0 3
32132: ARRAY
32133: PUSH
32134: LD_INT 2
32136: ARRAY
32137: PPUSH
32138: LD_EXP 66
32142: PUSH
32143: LD_VAR 0 2
32147: ARRAY
32148: PUSH
32149: LD_VAR 0 3
32153: ARRAY
32154: PUSH
32155: LD_INT 3
32157: ARRAY
32158: PPUSH
32159: LD_INT 30
32161: PPUSH
32162: CALL 55345 0 4
32166: PUSH
32167: LD_INT 4
32169: ARRAY
32170: PUSH
32171: LD_INT 0
32173: EQUAL
32174: IFFALSE 32200
// begin target := mc_crates [ i ] [ j ] ;
32176: LD_ADDR_VAR 0 7
32180: PUSH
32181: LD_EXP 66
32185: PUSH
32186: LD_VAR 0 2
32190: ARRAY
32191: PUSH
32192: LD_VAR 0 3
32196: ARRAY
32197: ST_TO_ADDR
// break ;
32198: GO 32202
// end ; end ;
32200: GO 31956
32202: POP
32203: POP
// if not target then
32204: LD_VAR 0 7
32208: NOT
32209: IFFALSE 32213
// continue ;
32211: GO 31763
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
32213: LD_ADDR_VAR 0 8
32217: PUSH
32218: LD_EXP 69
32222: PUSH
32223: LD_VAR 0 2
32227: ARRAY
32228: PPUSH
32229: LD_INT 2
32231: PUSH
32232: LD_INT 3
32234: PUSH
32235: LD_INT 58
32237: PUSH
32238: EMPTY
32239: LIST
32240: PUSH
32241: EMPTY
32242: LIST
32243: LIST
32244: PUSH
32245: LD_INT 61
32247: PUSH
32248: EMPTY
32249: LIST
32250: PUSH
32251: LD_INT 33
32253: PUSH
32254: LD_INT 5
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: PUSH
32261: LD_INT 33
32263: PUSH
32264: LD_INT 3
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PUSH
32271: EMPTY
32272: LIST
32273: LIST
32274: LIST
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 2
32280: PUSH
32281: LD_INT 34
32283: PUSH
32284: LD_INT 32
32286: PUSH
32287: EMPTY
32288: LIST
32289: LIST
32290: PUSH
32291: LD_INT 34
32293: PUSH
32294: LD_INT 51
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: PUSH
32301: LD_INT 34
32303: PUSH
32304: LD_INT 12
32306: PUSH
32307: EMPTY
32308: LIST
32309: LIST
32310: PUSH
32311: EMPTY
32312: LIST
32313: LIST
32314: LIST
32315: LIST
32316: PUSH
32317: EMPTY
32318: LIST
32319: LIST
32320: PPUSH
32321: CALL_OW 72
32325: ST_TO_ADDR
// if not cargo then
32326: LD_VAR 0 8
32330: NOT
32331: IFFALSE 33037
// begin if mc_crates_collector [ i ] < 5 then
32333: LD_EXP 67
32337: PUSH
32338: LD_VAR 0 2
32342: ARRAY
32343: PUSH
32344: LD_INT 5
32346: LESS
32347: IFFALSE 32713
// begin if mc_ape [ i ] then
32349: LD_EXP 79
32353: PUSH
32354: LD_VAR 0 2
32358: ARRAY
32359: IFFALSE 32406
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
32361: LD_ADDR_VAR 0 5
32365: PUSH
32366: LD_EXP 79
32370: PUSH
32371: LD_VAR 0 2
32375: ARRAY
32376: PPUSH
32377: LD_INT 25
32379: PUSH
32380: LD_INT 16
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 24
32389: PUSH
32390: LD_INT 750
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PPUSH
32401: CALL_OW 72
32405: ST_TO_ADDR
// if not tmp then
32406: LD_VAR 0 5
32410: NOT
32411: IFFALSE 32458
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
32413: LD_ADDR_VAR 0 5
32417: PUSH
32418: LD_EXP 50
32422: PUSH
32423: LD_VAR 0 2
32427: ARRAY
32428: PPUSH
32429: LD_INT 25
32431: PUSH
32432: LD_INT 2
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 24
32441: PUSH
32442: LD_INT 750
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PPUSH
32453: CALL_OW 72
32457: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32458: LD_EXP 79
32462: PUSH
32463: LD_VAR 0 2
32467: ARRAY
32468: PUSH
32469: LD_EXP 50
32473: PUSH
32474: LD_VAR 0 2
32478: ARRAY
32479: PPUSH
32480: LD_INT 25
32482: PUSH
32483: LD_INT 2
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 24
32492: PUSH
32493: LD_INT 750
32495: PUSH
32496: EMPTY
32497: LIST
32498: LIST
32499: PUSH
32500: EMPTY
32501: LIST
32502: LIST
32503: PPUSH
32504: CALL_OW 72
32508: AND
32509: PUSH
32510: LD_VAR 0 5
32514: PUSH
32515: LD_INT 5
32517: LESS
32518: AND
32519: IFFALSE 32601
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32521: LD_ADDR_VAR 0 3
32525: PUSH
32526: LD_EXP 50
32530: PUSH
32531: LD_VAR 0 2
32535: ARRAY
32536: PPUSH
32537: LD_INT 25
32539: PUSH
32540: LD_INT 2
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 24
32549: PUSH
32550: LD_INT 750
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PPUSH
32561: CALL_OW 72
32565: PUSH
32566: FOR_IN
32567: IFFALSE 32599
// begin tmp := tmp union j ;
32569: LD_ADDR_VAR 0 5
32573: PUSH
32574: LD_VAR 0 5
32578: PUSH
32579: LD_VAR 0 3
32583: UNION
32584: ST_TO_ADDR
// if tmp >= 5 then
32585: LD_VAR 0 5
32589: PUSH
32590: LD_INT 5
32592: GREATEREQUAL
32593: IFFALSE 32597
// break ;
32595: GO 32599
// end ;
32597: GO 32566
32599: POP
32600: POP
// end ; if not tmp then
32601: LD_VAR 0 5
32605: NOT
32606: IFFALSE 32610
// continue ;
32608: GO 31763
// for j in tmp do
32610: LD_ADDR_VAR 0 3
32614: PUSH
32615: LD_VAR 0 5
32619: PUSH
32620: FOR_IN
32621: IFFALSE 32711
// if not GetTag ( j ) then
32623: LD_VAR 0 3
32627: PPUSH
32628: CALL_OW 110
32632: NOT
32633: IFFALSE 32709
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32635: LD_ADDR_EXP 67
32639: PUSH
32640: LD_EXP 67
32644: PPUSH
32645: LD_VAR 0 2
32649: PUSH
32650: LD_EXP 67
32654: PUSH
32655: LD_VAR 0 2
32659: ARRAY
32660: PUSH
32661: LD_INT 1
32663: PLUS
32664: PUSH
32665: EMPTY
32666: LIST
32667: LIST
32668: PPUSH
32669: LD_VAR 0 3
32673: PPUSH
32674: CALL 54081 0 3
32678: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32679: LD_VAR 0 3
32683: PPUSH
32684: LD_INT 107
32686: PPUSH
32687: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32691: LD_EXP 67
32695: PUSH
32696: LD_VAR 0 2
32700: ARRAY
32701: PUSH
32702: LD_INT 5
32704: GREATEREQUAL
32705: IFFALSE 32709
// break ;
32707: GO 32711
// end ;
32709: GO 32620
32711: POP
32712: POP
// end ; if mc_crates_collector [ i ] and target then
32713: LD_EXP 67
32717: PUSH
32718: LD_VAR 0 2
32722: ARRAY
32723: PUSH
32724: LD_VAR 0 7
32728: AND
32729: IFFALSE 33035
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32731: LD_EXP 67
32735: PUSH
32736: LD_VAR 0 2
32740: ARRAY
32741: PUSH
32742: LD_VAR 0 7
32746: PUSH
32747: LD_INT 1
32749: ARRAY
32750: LESS
32751: IFFALSE 32771
// tmp := mc_crates_collector [ i ] else
32753: LD_ADDR_VAR 0 5
32757: PUSH
32758: LD_EXP 67
32762: PUSH
32763: LD_VAR 0 2
32767: ARRAY
32768: ST_TO_ADDR
32769: GO 32785
// tmp := target [ 1 ] ;
32771: LD_ADDR_VAR 0 5
32775: PUSH
32776: LD_VAR 0 7
32780: PUSH
32781: LD_INT 1
32783: ARRAY
32784: ST_TO_ADDR
// k := 0 ;
32785: LD_ADDR_VAR 0 4
32789: PUSH
32790: LD_INT 0
32792: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32793: LD_ADDR_VAR 0 3
32797: PUSH
32798: LD_EXP 67
32802: PUSH
32803: LD_VAR 0 2
32807: ARRAY
32808: PUSH
32809: FOR_IN
32810: IFFALSE 33033
// begin k := k + 1 ;
32812: LD_ADDR_VAR 0 4
32816: PUSH
32817: LD_VAR 0 4
32821: PUSH
32822: LD_INT 1
32824: PLUS
32825: ST_TO_ADDR
// if k > tmp then
32826: LD_VAR 0 4
32830: PUSH
32831: LD_VAR 0 5
32835: GREATER
32836: IFFALSE 32840
// break ;
32838: GO 33033
// if not GetClass ( j ) in [ 2 , 16 ] then
32840: LD_VAR 0 3
32844: PPUSH
32845: CALL_OW 257
32849: PUSH
32850: LD_INT 2
32852: PUSH
32853: LD_INT 16
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: IN
32860: NOT
32861: IFFALSE 32914
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32863: LD_ADDR_EXP 67
32867: PUSH
32868: LD_EXP 67
32872: PPUSH
32873: LD_VAR 0 2
32877: PPUSH
32878: LD_EXP 67
32882: PUSH
32883: LD_VAR 0 2
32887: ARRAY
32888: PUSH
32889: LD_VAR 0 3
32893: DIFF
32894: PPUSH
32895: CALL_OW 1
32899: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32900: LD_VAR 0 3
32904: PPUSH
32905: LD_INT 0
32907: PPUSH
32908: CALL_OW 109
// continue ;
32912: GO 32809
// end ; if IsInUnit ( j ) then
32914: LD_VAR 0 3
32918: PPUSH
32919: CALL_OW 310
32923: IFFALSE 32934
// ComExitBuilding ( j ) ;
32925: LD_VAR 0 3
32929: PPUSH
32930: CALL_OW 122
// wait ( 3 ) ;
32934: LD_INT 3
32936: PPUSH
32937: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32941: LD_VAR 0 3
32945: PPUSH
32946: CALL_OW 314
32950: PUSH
32951: LD_VAR 0 6
32955: PPUSH
32956: LD_VAR 0 7
32960: PUSH
32961: LD_INT 2
32963: ARRAY
32964: PPUSH
32965: LD_VAR 0 7
32969: PUSH
32970: LD_INT 3
32972: ARRAY
32973: PPUSH
32974: LD_INT 30
32976: PPUSH
32977: CALL 55345 0 4
32981: PUSH
32982: LD_INT 4
32984: ARRAY
32985: AND
32986: IFFALSE 33004
// ComStandNearbyBuilding ( j , depot ) else
32988: LD_VAR 0 3
32992: PPUSH
32993: LD_VAR 0 9
32997: PPUSH
32998: CALL 50683 0 2
33002: GO 33031
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33004: LD_VAR 0 3
33008: PPUSH
33009: LD_VAR 0 7
33013: PUSH
33014: LD_INT 2
33016: ARRAY
33017: PPUSH
33018: LD_VAR 0 7
33022: PUSH
33023: LD_INT 3
33025: ARRAY
33026: PPUSH
33027: CALL_OW 117
// end ;
33031: GO 32809
33033: POP
33034: POP
// end ; end else
33035: GO 33567
// begin for j in cargo do
33037: LD_ADDR_VAR 0 3
33041: PUSH
33042: LD_VAR 0 8
33046: PUSH
33047: FOR_IN
33048: IFFALSE 33565
// begin if GetTag ( j ) <> 0 then
33050: LD_VAR 0 3
33054: PPUSH
33055: CALL_OW 110
33059: PUSH
33060: LD_INT 0
33062: NONEQUAL
33063: IFFALSE 33067
// continue ;
33065: GO 33047
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
33067: LD_VAR 0 3
33071: PPUSH
33072: CALL_OW 256
33076: PUSH
33077: LD_INT 1000
33079: LESS
33080: PUSH
33081: LD_VAR 0 3
33085: PPUSH
33086: LD_EXP 74
33090: PUSH
33091: LD_VAR 0 2
33095: ARRAY
33096: PPUSH
33097: CALL_OW 308
33101: NOT
33102: AND
33103: IFFALSE 33125
// ComMoveToArea ( j , mc_parking [ i ] ) ;
33105: LD_VAR 0 3
33109: PPUSH
33110: LD_EXP 74
33114: PUSH
33115: LD_VAR 0 2
33119: ARRAY
33120: PPUSH
33121: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
33125: LD_VAR 0 3
33129: PPUSH
33130: CALL_OW 256
33134: PUSH
33135: LD_INT 1000
33137: LESS
33138: PUSH
33139: LD_VAR 0 3
33143: PPUSH
33144: LD_EXP 74
33148: PUSH
33149: LD_VAR 0 2
33153: ARRAY
33154: PPUSH
33155: CALL_OW 308
33159: AND
33160: IFFALSE 33164
// continue ;
33162: GO 33047
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
33164: LD_VAR 0 3
33168: PPUSH
33169: CALL_OW 262
33173: PUSH
33174: LD_INT 2
33176: EQUAL
33177: PUSH
33178: LD_VAR 0 3
33182: PPUSH
33183: CALL_OW 261
33187: PUSH
33188: LD_INT 15
33190: LESS
33191: AND
33192: IFFALSE 33196
// continue ;
33194: GO 33047
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
33196: LD_VAR 0 3
33200: PPUSH
33201: CALL_OW 262
33205: PUSH
33206: LD_INT 1
33208: EQUAL
33209: PUSH
33210: LD_VAR 0 3
33214: PPUSH
33215: CALL_OW 261
33219: PUSH
33220: LD_INT 10
33222: LESS
33223: AND
33224: IFFALSE 33504
// begin if not depot then
33226: LD_VAR 0 9
33230: NOT
33231: IFFALSE 33235
// continue ;
33233: GO 33047
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
33235: LD_VAR 0 3
33239: PPUSH
33240: LD_VAR 0 9
33244: PPUSH
33245: LD_VAR 0 3
33249: PPUSH
33250: CALL_OW 74
33254: PPUSH
33255: CALL_OW 296
33259: PUSH
33260: LD_INT 6
33262: LESS
33263: IFFALSE 33279
// SetFuel ( j , 100 ) else
33265: LD_VAR 0 3
33269: PPUSH
33270: LD_INT 100
33272: PPUSH
33273: CALL_OW 240
33277: GO 33504
// if GetFuel ( j ) = 0 then
33279: LD_VAR 0 3
33283: PPUSH
33284: CALL_OW 261
33288: PUSH
33289: LD_INT 0
33291: EQUAL
33292: IFFALSE 33504
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
33294: LD_ADDR_EXP 69
33298: PUSH
33299: LD_EXP 69
33303: PPUSH
33304: LD_VAR 0 2
33308: PPUSH
33309: LD_EXP 69
33313: PUSH
33314: LD_VAR 0 2
33318: ARRAY
33319: PUSH
33320: LD_VAR 0 3
33324: DIFF
33325: PPUSH
33326: CALL_OW 1
33330: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
33331: LD_VAR 0 3
33335: PPUSH
33336: CALL_OW 263
33340: PUSH
33341: LD_INT 1
33343: EQUAL
33344: IFFALSE 33360
// ComExitVehicle ( IsInUnit ( j ) ) ;
33346: LD_VAR 0 3
33350: PPUSH
33351: CALL_OW 310
33355: PPUSH
33356: CALL_OW 121
// if GetControl ( j ) = control_remote then
33360: LD_VAR 0 3
33364: PPUSH
33365: CALL_OW 263
33369: PUSH
33370: LD_INT 2
33372: EQUAL
33373: IFFALSE 33384
// ComUnlink ( j ) ;
33375: LD_VAR 0 3
33379: PPUSH
33380: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
33384: LD_ADDR_VAR 0 10
33388: PUSH
33389: LD_VAR 0 2
33393: PPUSH
33394: LD_INT 3
33396: PPUSH
33397: CALL 43148 0 2
33401: ST_TO_ADDR
// if fac then
33402: LD_VAR 0 10
33406: IFFALSE 33502
// begin for k in fac do
33408: LD_ADDR_VAR 0 4
33412: PUSH
33413: LD_VAR 0 10
33417: PUSH
33418: FOR_IN
33419: IFFALSE 33500
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
33421: LD_ADDR_VAR 0 11
33425: PUSH
33426: LD_VAR 0 10
33430: PPUSH
33431: LD_VAR 0 3
33435: PPUSH
33436: CALL_OW 265
33440: PPUSH
33441: LD_VAR 0 3
33445: PPUSH
33446: CALL_OW 262
33450: PPUSH
33451: LD_VAR 0 3
33455: PPUSH
33456: CALL_OW 263
33460: PPUSH
33461: LD_VAR 0 3
33465: PPUSH
33466: CALL_OW 264
33470: PPUSH
33471: CALL 51579 0 5
33475: ST_TO_ADDR
// if components then
33476: LD_VAR 0 11
33480: IFFALSE 33498
// begin MC_InsertProduceList ( i , components ) ;
33482: LD_VAR 0 2
33486: PPUSH
33487: LD_VAR 0 11
33491: PPUSH
33492: CALL 42693 0 2
// break ;
33496: GO 33500
// end ; end ;
33498: GO 33418
33500: POP
33501: POP
// end ; continue ;
33502: GO 33047
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33504: LD_VAR 0 3
33508: PPUSH
33509: LD_INT 1
33511: PPUSH
33512: CALL_OW 289
33516: PUSH
33517: LD_INT 100
33519: LESS
33520: PUSH
33521: LD_VAR 0 3
33525: PPUSH
33526: CALL_OW 314
33530: NOT
33531: AND
33532: IFFALSE 33561
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33534: LD_VAR 0 3
33538: PPUSH
33539: LD_VAR 0 7
33543: PUSH
33544: LD_INT 2
33546: ARRAY
33547: PPUSH
33548: LD_VAR 0 7
33552: PUSH
33553: LD_INT 3
33555: ARRAY
33556: PPUSH
33557: CALL_OW 117
// break ;
33561: GO 33565
// end ;
33563: GO 33047
33565: POP
33566: POP
// end ; end ;
33567: GO 31763
33569: POP
33570: POP
// end ;
33571: LD_VAR 0 1
33575: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33576: LD_INT 0
33578: PPUSH
33579: PPUSH
33580: PPUSH
33581: PPUSH
// if not mc_bases then
33582: LD_EXP 50
33586: NOT
33587: IFFALSE 33591
// exit ;
33589: GO 33752
// for i = 1 to mc_bases do
33591: LD_ADDR_VAR 0 2
33595: PUSH
33596: DOUBLE
33597: LD_INT 1
33599: DEC
33600: ST_TO_ADDR
33601: LD_EXP 50
33605: PUSH
33606: FOR_TO
33607: IFFALSE 33750
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33609: LD_ADDR_VAR 0 4
33613: PUSH
33614: LD_EXP 69
33618: PUSH
33619: LD_VAR 0 2
33623: ARRAY
33624: PUSH
33625: LD_EXP 72
33629: PUSH
33630: LD_VAR 0 2
33634: ARRAY
33635: UNION
33636: PPUSH
33637: LD_INT 33
33639: PUSH
33640: LD_INT 2
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PPUSH
33647: CALL_OW 72
33651: ST_TO_ADDR
// if tmp then
33652: LD_VAR 0 4
33656: IFFALSE 33748
// for j in tmp do
33658: LD_ADDR_VAR 0 3
33662: PUSH
33663: LD_VAR 0 4
33667: PUSH
33668: FOR_IN
33669: IFFALSE 33746
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33671: LD_VAR 0 3
33675: PPUSH
33676: CALL_OW 312
33680: NOT
33681: PUSH
33682: LD_VAR 0 3
33686: PPUSH
33687: CALL_OW 256
33691: PUSH
33692: LD_INT 250
33694: GREATEREQUAL
33695: AND
33696: IFFALSE 33709
// Connect ( j ) else
33698: LD_VAR 0 3
33702: PPUSH
33703: CALL 57427 0 1
33707: GO 33744
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33709: LD_VAR 0 3
33713: PPUSH
33714: CALL_OW 256
33718: PUSH
33719: LD_INT 250
33721: LESS
33722: PUSH
33723: LD_VAR 0 3
33727: PPUSH
33728: CALL_OW 312
33732: AND
33733: IFFALSE 33744
// ComUnlink ( j ) ;
33735: LD_VAR 0 3
33739: PPUSH
33740: CALL_OW 136
33744: GO 33668
33746: POP
33747: POP
// end ;
33748: GO 33606
33750: POP
33751: POP
// end ;
33752: LD_VAR 0 1
33756: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33757: LD_INT 0
33759: PPUSH
33760: PPUSH
33761: PPUSH
33762: PPUSH
33763: PPUSH
// if not mc_bases then
33764: LD_EXP 50
33768: NOT
33769: IFFALSE 33773
// exit ;
33771: GO 34218
// for i = 1 to mc_bases do
33773: LD_ADDR_VAR 0 2
33777: PUSH
33778: DOUBLE
33779: LD_INT 1
33781: DEC
33782: ST_TO_ADDR
33783: LD_EXP 50
33787: PUSH
33788: FOR_TO
33789: IFFALSE 34216
// begin if not mc_produce [ i ] then
33791: LD_EXP 71
33795: PUSH
33796: LD_VAR 0 2
33800: ARRAY
33801: NOT
33802: IFFALSE 33806
// continue ;
33804: GO 33788
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33806: LD_ADDR_VAR 0 5
33810: PUSH
33811: LD_EXP 50
33815: PUSH
33816: LD_VAR 0 2
33820: ARRAY
33821: PPUSH
33822: LD_INT 30
33824: PUSH
33825: LD_INT 3
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PPUSH
33832: CALL_OW 72
33836: ST_TO_ADDR
// if not fac then
33837: LD_VAR 0 5
33841: NOT
33842: IFFALSE 33846
// continue ;
33844: GO 33788
// for j in fac do
33846: LD_ADDR_VAR 0 3
33850: PUSH
33851: LD_VAR 0 5
33855: PUSH
33856: FOR_IN
33857: IFFALSE 34212
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33859: LD_VAR 0 3
33863: PPUSH
33864: CALL_OW 461
33868: PUSH
33869: LD_INT 2
33871: NONEQUAL
33872: PUSH
33873: LD_VAR 0 3
33877: PPUSH
33878: LD_INT 15
33880: PPUSH
33881: CALL 57046 0 2
33885: PUSH
33886: LD_INT 4
33888: ARRAY
33889: OR
33890: IFFALSE 33894
// continue ;
33892: GO 33856
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33894: LD_VAR 0 3
33898: PPUSH
33899: LD_EXP 71
33903: PUSH
33904: LD_VAR 0 2
33908: ARRAY
33909: PUSH
33910: LD_INT 1
33912: ARRAY
33913: PUSH
33914: LD_INT 1
33916: ARRAY
33917: PPUSH
33918: LD_EXP 71
33922: PUSH
33923: LD_VAR 0 2
33927: ARRAY
33928: PUSH
33929: LD_INT 1
33931: ARRAY
33932: PUSH
33933: LD_INT 2
33935: ARRAY
33936: PPUSH
33937: LD_EXP 71
33941: PUSH
33942: LD_VAR 0 2
33946: ARRAY
33947: PUSH
33948: LD_INT 1
33950: ARRAY
33951: PUSH
33952: LD_INT 3
33954: ARRAY
33955: PPUSH
33956: LD_EXP 71
33960: PUSH
33961: LD_VAR 0 2
33965: ARRAY
33966: PUSH
33967: LD_INT 1
33969: ARRAY
33970: PUSH
33971: LD_INT 4
33973: ARRAY
33974: PPUSH
33975: CALL_OW 448
33979: PUSH
33980: LD_VAR 0 3
33984: PPUSH
33985: LD_EXP 71
33989: PUSH
33990: LD_VAR 0 2
33994: ARRAY
33995: PUSH
33996: LD_INT 1
33998: ARRAY
33999: PUSH
34000: LD_INT 1
34002: ARRAY
34003: PUSH
34004: LD_EXP 71
34008: PUSH
34009: LD_VAR 0 2
34013: ARRAY
34014: PUSH
34015: LD_INT 1
34017: ARRAY
34018: PUSH
34019: LD_INT 2
34021: ARRAY
34022: PUSH
34023: LD_EXP 71
34027: PUSH
34028: LD_VAR 0 2
34032: ARRAY
34033: PUSH
34034: LD_INT 1
34036: ARRAY
34037: PUSH
34038: LD_INT 3
34040: ARRAY
34041: PUSH
34042: LD_EXP 71
34046: PUSH
34047: LD_VAR 0 2
34051: ARRAY
34052: PUSH
34053: LD_INT 1
34055: ARRAY
34056: PUSH
34057: LD_INT 4
34059: ARRAY
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: PPUSH
34067: CALL 60822 0 2
34071: AND
34072: IFFALSE 34210
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
34074: LD_VAR 0 3
34078: PPUSH
34079: LD_EXP 71
34083: PUSH
34084: LD_VAR 0 2
34088: ARRAY
34089: PUSH
34090: LD_INT 1
34092: ARRAY
34093: PUSH
34094: LD_INT 1
34096: ARRAY
34097: PPUSH
34098: LD_EXP 71
34102: PUSH
34103: LD_VAR 0 2
34107: ARRAY
34108: PUSH
34109: LD_INT 1
34111: ARRAY
34112: PUSH
34113: LD_INT 2
34115: ARRAY
34116: PPUSH
34117: LD_EXP 71
34121: PUSH
34122: LD_VAR 0 2
34126: ARRAY
34127: PUSH
34128: LD_INT 1
34130: ARRAY
34131: PUSH
34132: LD_INT 3
34134: ARRAY
34135: PPUSH
34136: LD_EXP 71
34140: PUSH
34141: LD_VAR 0 2
34145: ARRAY
34146: PUSH
34147: LD_INT 1
34149: ARRAY
34150: PUSH
34151: LD_INT 4
34153: ARRAY
34154: PPUSH
34155: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
34159: LD_ADDR_VAR 0 4
34163: PUSH
34164: LD_EXP 71
34168: PUSH
34169: LD_VAR 0 2
34173: ARRAY
34174: PPUSH
34175: LD_INT 1
34177: PPUSH
34178: CALL_OW 3
34182: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
34183: LD_ADDR_EXP 71
34187: PUSH
34188: LD_EXP 71
34192: PPUSH
34193: LD_VAR 0 2
34197: PPUSH
34198: LD_VAR 0 4
34202: PPUSH
34203: CALL_OW 1
34207: ST_TO_ADDR
// break ;
34208: GO 34212
// end ; end ;
34210: GO 33856
34212: POP
34213: POP
// end ;
34214: GO 33788
34216: POP
34217: POP
// end ;
34218: LD_VAR 0 1
34222: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
34223: LD_INT 0
34225: PPUSH
34226: PPUSH
34227: PPUSH
// if not mc_bases then
34228: LD_EXP 50
34232: NOT
34233: IFFALSE 34237
// exit ;
34235: GO 34326
// for i = 1 to mc_bases do
34237: LD_ADDR_VAR 0 2
34241: PUSH
34242: DOUBLE
34243: LD_INT 1
34245: DEC
34246: ST_TO_ADDR
34247: LD_EXP 50
34251: PUSH
34252: FOR_TO
34253: IFFALSE 34324
// begin if mc_attack [ i ] then
34255: LD_EXP 70
34259: PUSH
34260: LD_VAR 0 2
34264: ARRAY
34265: IFFALSE 34322
// begin tmp := mc_attack [ i ] [ 1 ] ;
34267: LD_ADDR_VAR 0 3
34271: PUSH
34272: LD_EXP 70
34276: PUSH
34277: LD_VAR 0 2
34281: ARRAY
34282: PUSH
34283: LD_INT 1
34285: ARRAY
34286: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
34287: LD_ADDR_EXP 70
34291: PUSH
34292: LD_EXP 70
34296: PPUSH
34297: LD_VAR 0 2
34301: PPUSH
34302: EMPTY
34303: PPUSH
34304: CALL_OW 1
34308: ST_TO_ADDR
// Attack ( tmp ) ;
34309: LD_VAR 0 3
34313: PPUSH
34314: CALL 112047 0 1
// exit ;
34318: POP
34319: POP
34320: GO 34326
// end ; end ;
34322: GO 34252
34324: POP
34325: POP
// end ;
34326: LD_VAR 0 1
34330: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
34331: LD_INT 0
34333: PPUSH
34334: PPUSH
34335: PPUSH
34336: PPUSH
34337: PPUSH
34338: PPUSH
34339: PPUSH
// if not mc_bases then
34340: LD_EXP 50
34344: NOT
34345: IFFALSE 34349
// exit ;
34347: GO 35206
// for i = 1 to mc_bases do
34349: LD_ADDR_VAR 0 2
34353: PUSH
34354: DOUBLE
34355: LD_INT 1
34357: DEC
34358: ST_TO_ADDR
34359: LD_EXP 50
34363: PUSH
34364: FOR_TO
34365: IFFALSE 35204
// begin if not mc_bases [ i ] then
34367: LD_EXP 50
34371: PUSH
34372: LD_VAR 0 2
34376: ARRAY
34377: NOT
34378: IFFALSE 34382
// continue ;
34380: GO 34364
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
34382: LD_ADDR_VAR 0 7
34386: PUSH
34387: LD_EXP 50
34391: PUSH
34392: LD_VAR 0 2
34396: ARRAY
34397: PUSH
34398: LD_INT 1
34400: ARRAY
34401: PPUSH
34402: CALL 50905 0 1
34406: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
34407: LD_ADDR_EXP 73
34411: PUSH
34412: LD_EXP 73
34416: PPUSH
34417: LD_VAR 0 2
34421: PPUSH
34422: LD_EXP 50
34426: PUSH
34427: LD_VAR 0 2
34431: ARRAY
34432: PUSH
34433: LD_INT 1
34435: ARRAY
34436: PPUSH
34437: CALL_OW 255
34441: PPUSH
34442: LD_EXP 75
34446: PUSH
34447: LD_VAR 0 2
34451: ARRAY
34452: PPUSH
34453: CALL 50870 0 2
34457: PPUSH
34458: CALL_OW 1
34462: ST_TO_ADDR
// if not mc_scan [ i ] then
34463: LD_EXP 73
34467: PUSH
34468: LD_VAR 0 2
34472: ARRAY
34473: NOT
34474: IFFALSE 34652
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34476: LD_ADDR_EXP 93
34480: PUSH
34481: LD_EXP 93
34485: PPUSH
34486: LD_VAR 0 2
34490: PPUSH
34491: LD_INT 0
34493: PPUSH
34494: CALL_OW 1
34498: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34499: LD_ADDR_VAR 0 4
34503: PUSH
34504: LD_EXP 50
34508: PUSH
34509: LD_VAR 0 2
34513: ARRAY
34514: PPUSH
34515: LD_INT 2
34517: PUSH
34518: LD_INT 25
34520: PUSH
34521: LD_INT 5
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 25
34530: PUSH
34531: LD_INT 8
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 25
34540: PUSH
34541: LD_INT 9
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: PPUSH
34554: CALL_OW 72
34558: ST_TO_ADDR
// if not tmp then
34559: LD_VAR 0 4
34563: NOT
34564: IFFALSE 34568
// continue ;
34566: GO 34364
// for j in tmp do
34568: LD_ADDR_VAR 0 3
34572: PUSH
34573: LD_VAR 0 4
34577: PUSH
34578: FOR_IN
34579: IFFALSE 34650
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34581: LD_VAR 0 3
34585: PPUSH
34586: CALL_OW 310
34590: PPUSH
34591: CALL_OW 266
34595: PUSH
34596: LD_INT 5
34598: EQUAL
34599: PUSH
34600: LD_VAR 0 3
34604: PPUSH
34605: CALL_OW 257
34609: PUSH
34610: LD_INT 1
34612: EQUAL
34613: AND
34614: PUSH
34615: LD_VAR 0 3
34619: PPUSH
34620: CALL_OW 459
34624: NOT
34625: AND
34626: PUSH
34627: LD_VAR 0 7
34631: AND
34632: IFFALSE 34648
// ComChangeProfession ( j , class ) ;
34634: LD_VAR 0 3
34638: PPUSH
34639: LD_VAR 0 7
34643: PPUSH
34644: CALL_OW 123
34648: GO 34578
34650: POP
34651: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34652: LD_EXP 73
34656: PUSH
34657: LD_VAR 0 2
34661: ARRAY
34662: PUSH
34663: LD_EXP 93
34667: PUSH
34668: LD_VAR 0 2
34672: ARRAY
34673: NOT
34674: AND
34675: PUSH
34676: LD_EXP 72
34680: PUSH
34681: LD_VAR 0 2
34685: ARRAY
34686: NOT
34687: AND
34688: PUSH
34689: LD_EXP 50
34693: PUSH
34694: LD_VAR 0 2
34698: ARRAY
34699: PPUSH
34700: LD_INT 50
34702: PUSH
34703: EMPTY
34704: LIST
34705: PUSH
34706: LD_INT 2
34708: PUSH
34709: LD_INT 30
34711: PUSH
34712: LD_INT 32
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 30
34721: PUSH
34722: LD_INT 33
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: LD_INT 30
34731: PUSH
34732: LD_INT 4
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: PUSH
34739: LD_INT 30
34741: PUSH
34742: LD_INT 5
34744: PUSH
34745: EMPTY
34746: LIST
34747: LIST
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: LIST
34753: LIST
34754: LIST
34755: PUSH
34756: EMPTY
34757: LIST
34758: LIST
34759: PPUSH
34760: CALL_OW 72
34764: PUSH
34765: LD_INT 4
34767: LESS
34768: PUSH
34769: LD_EXP 50
34773: PUSH
34774: LD_VAR 0 2
34778: ARRAY
34779: PPUSH
34780: LD_INT 3
34782: PUSH
34783: LD_INT 24
34785: PUSH
34786: LD_INT 1000
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: PUSH
34797: LD_INT 2
34799: PUSH
34800: LD_INT 30
34802: PUSH
34803: LD_INT 0
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 30
34812: PUSH
34813: LD_INT 1
34815: PUSH
34816: EMPTY
34817: LIST
34818: LIST
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: LIST
34824: PUSH
34825: EMPTY
34826: LIST
34827: LIST
34828: PPUSH
34829: CALL_OW 72
34833: OR
34834: AND
34835: IFFALSE 35086
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34837: LD_ADDR_EXP 93
34841: PUSH
34842: LD_EXP 93
34846: PPUSH
34847: LD_VAR 0 2
34851: PPUSH
34852: LD_INT 1
34854: PPUSH
34855: CALL_OW 1
34859: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34860: LD_ADDR_VAR 0 4
34864: PUSH
34865: LD_EXP 50
34869: PUSH
34870: LD_VAR 0 2
34874: ARRAY
34875: PPUSH
34876: LD_INT 2
34878: PUSH
34879: LD_INT 25
34881: PUSH
34882: LD_INT 1
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: LD_INT 25
34891: PUSH
34892: LD_INT 5
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: PUSH
34899: LD_INT 25
34901: PUSH
34902: LD_INT 8
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 25
34911: PUSH
34912: LD_INT 9
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: LIST
34923: LIST
34924: LIST
34925: PPUSH
34926: CALL_OW 72
34930: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34931: LD_ADDR_VAR 0 4
34935: PUSH
34936: LD_VAR 0 4
34940: PUSH
34941: LD_VAR 0 4
34945: PPUSH
34946: LD_INT 18
34948: PPUSH
34949: CALL 84390 0 2
34953: DIFF
34954: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34955: LD_VAR 0 4
34959: NOT
34960: PUSH
34961: LD_EXP 50
34965: PUSH
34966: LD_VAR 0 2
34970: ARRAY
34971: PPUSH
34972: LD_INT 2
34974: PUSH
34975: LD_INT 30
34977: PUSH
34978: LD_INT 4
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 30
34987: PUSH
34988: LD_INT 5
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: LIST
34999: PPUSH
35000: CALL_OW 72
35004: NOT
35005: AND
35006: IFFALSE 35068
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
35008: LD_ADDR_VAR 0 4
35012: PUSH
35013: LD_EXP 50
35017: PUSH
35018: LD_VAR 0 2
35022: ARRAY
35023: PPUSH
35024: LD_INT 2
35026: PUSH
35027: LD_INT 25
35029: PUSH
35030: LD_INT 2
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 25
35039: PUSH
35040: LD_INT 3
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: LD_INT 25
35049: PUSH
35050: LD_INT 4
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: PPUSH
35063: CALL_OW 72
35067: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
35068: LD_VAR 0 2
35072: PPUSH
35073: LD_VAR 0 4
35077: PPUSH
35078: CALL 116756 0 2
// exit ;
35082: POP
35083: POP
35084: GO 35206
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
35086: LD_EXP 73
35090: PUSH
35091: LD_VAR 0 2
35095: ARRAY
35096: PUSH
35097: LD_EXP 93
35101: PUSH
35102: LD_VAR 0 2
35106: ARRAY
35107: NOT
35108: AND
35109: PUSH
35110: LD_EXP 72
35114: PUSH
35115: LD_VAR 0 2
35119: ARRAY
35120: AND
35121: IFFALSE 35202
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
35123: LD_ADDR_EXP 93
35127: PUSH
35128: LD_EXP 93
35132: PPUSH
35133: LD_VAR 0 2
35137: PPUSH
35138: LD_INT 1
35140: PPUSH
35141: CALL_OW 1
35145: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
35146: LD_ADDR_VAR 0 4
35150: PUSH
35151: LD_EXP 72
35155: PUSH
35156: LD_VAR 0 2
35160: ARRAY
35161: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35162: LD_ADDR_EXP 72
35166: PUSH
35167: LD_EXP 72
35171: PPUSH
35172: LD_VAR 0 2
35176: PPUSH
35177: EMPTY
35178: PPUSH
35179: CALL_OW 1
35183: ST_TO_ADDR
// Defend ( i , tmp ) ;
35184: LD_VAR 0 2
35188: PPUSH
35189: LD_VAR 0 4
35193: PPUSH
35194: CALL 117352 0 2
// exit ;
35198: POP
35199: POP
35200: GO 35206
// end ; end ;
35202: GO 34364
35204: POP
35205: POP
// end ;
35206: LD_VAR 0 1
35210: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35211: LD_INT 0
35213: PPUSH
35214: PPUSH
35215: PPUSH
35216: PPUSH
35217: PPUSH
35218: PPUSH
35219: PPUSH
35220: PPUSH
35221: PPUSH
35222: PPUSH
35223: PPUSH
// if not mc_bases then
35224: LD_EXP 50
35228: NOT
35229: IFFALSE 35233
// exit ;
35231: GO 36320
// for i = 1 to mc_bases do
35233: LD_ADDR_VAR 0 2
35237: PUSH
35238: DOUBLE
35239: LD_INT 1
35241: DEC
35242: ST_TO_ADDR
35243: LD_EXP 50
35247: PUSH
35248: FOR_TO
35249: IFFALSE 36318
// begin tmp := mc_lab [ i ] ;
35251: LD_ADDR_VAR 0 6
35255: PUSH
35256: LD_EXP 83
35260: PUSH
35261: LD_VAR 0 2
35265: ARRAY
35266: ST_TO_ADDR
// if not tmp then
35267: LD_VAR 0 6
35271: NOT
35272: IFFALSE 35276
// continue ;
35274: GO 35248
// idle_lab := 0 ;
35276: LD_ADDR_VAR 0 11
35280: PUSH
35281: LD_INT 0
35283: ST_TO_ADDR
// for j in tmp do
35284: LD_ADDR_VAR 0 3
35288: PUSH
35289: LD_VAR 0 6
35293: PUSH
35294: FOR_IN
35295: IFFALSE 36314
// begin researching := false ;
35297: LD_ADDR_VAR 0 10
35301: PUSH
35302: LD_INT 0
35304: ST_TO_ADDR
// side := GetSide ( j ) ;
35305: LD_ADDR_VAR 0 4
35309: PUSH
35310: LD_VAR 0 3
35314: PPUSH
35315: CALL_OW 255
35319: ST_TO_ADDR
// if not mc_tech [ side ] then
35320: LD_EXP 77
35324: PUSH
35325: LD_VAR 0 4
35329: ARRAY
35330: NOT
35331: IFFALSE 35335
// continue ;
35333: GO 35294
// if BuildingStatus ( j ) = bs_idle then
35335: LD_VAR 0 3
35339: PPUSH
35340: CALL_OW 461
35344: PUSH
35345: LD_INT 2
35347: EQUAL
35348: IFFALSE 35536
// begin if idle_lab and UnitsInside ( j ) < 6 then
35350: LD_VAR 0 11
35354: PUSH
35355: LD_VAR 0 3
35359: PPUSH
35360: CALL_OW 313
35364: PUSH
35365: LD_INT 6
35367: LESS
35368: AND
35369: IFFALSE 35440
// begin tmp2 := UnitsInside ( idle_lab ) ;
35371: LD_ADDR_VAR 0 9
35375: PUSH
35376: LD_VAR 0 11
35380: PPUSH
35381: CALL_OW 313
35385: ST_TO_ADDR
// if tmp2 then
35386: LD_VAR 0 9
35390: IFFALSE 35432
// for x in tmp2 do
35392: LD_ADDR_VAR 0 7
35396: PUSH
35397: LD_VAR 0 9
35401: PUSH
35402: FOR_IN
35403: IFFALSE 35430
// begin ComExitBuilding ( x ) ;
35405: LD_VAR 0 7
35409: PPUSH
35410: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35414: LD_VAR 0 7
35418: PPUSH
35419: LD_VAR 0 3
35423: PPUSH
35424: CALL_OW 180
// end ;
35428: GO 35402
35430: POP
35431: POP
// idle_lab := 0 ;
35432: LD_ADDR_VAR 0 11
35436: PUSH
35437: LD_INT 0
35439: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
35440: LD_ADDR_VAR 0 5
35444: PUSH
35445: LD_EXP 77
35449: PUSH
35450: LD_VAR 0 4
35454: ARRAY
35455: PUSH
35456: FOR_IN
35457: IFFALSE 35517
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35459: LD_VAR 0 3
35463: PPUSH
35464: LD_VAR 0 5
35468: PPUSH
35469: CALL_OW 430
35473: PUSH
35474: LD_VAR 0 4
35478: PPUSH
35479: LD_VAR 0 5
35483: PPUSH
35484: CALL 49975 0 2
35488: AND
35489: IFFALSE 35515
// begin researching := true ;
35491: LD_ADDR_VAR 0 10
35495: PUSH
35496: LD_INT 1
35498: ST_TO_ADDR
// ComResearch ( j , t ) ;
35499: LD_VAR 0 3
35503: PPUSH
35504: LD_VAR 0 5
35508: PPUSH
35509: CALL_OW 124
// break ;
35513: GO 35517
// end ;
35515: GO 35456
35517: POP
35518: POP
// if not researching then
35519: LD_VAR 0 10
35523: NOT
35524: IFFALSE 35536
// idle_lab := j ;
35526: LD_ADDR_VAR 0 11
35530: PUSH
35531: LD_VAR 0 3
35535: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35536: LD_VAR 0 3
35540: PPUSH
35541: CALL_OW 461
35545: PUSH
35546: LD_INT 10
35548: EQUAL
35549: IFFALSE 36137
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35551: LD_EXP 79
35555: PUSH
35556: LD_VAR 0 2
35560: ARRAY
35561: NOT
35562: PUSH
35563: LD_EXP 80
35567: PUSH
35568: LD_VAR 0 2
35572: ARRAY
35573: NOT
35574: AND
35575: PUSH
35576: LD_EXP 77
35580: PUSH
35581: LD_VAR 0 4
35585: ARRAY
35586: PUSH
35587: LD_INT 1
35589: GREATER
35590: AND
35591: IFFALSE 35722
// begin ComCancel ( j ) ;
35593: LD_VAR 0 3
35597: PPUSH
35598: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35602: LD_ADDR_EXP 77
35606: PUSH
35607: LD_EXP 77
35611: PPUSH
35612: LD_VAR 0 4
35616: PPUSH
35617: LD_EXP 77
35621: PUSH
35622: LD_VAR 0 4
35626: ARRAY
35627: PPUSH
35628: LD_EXP 77
35632: PUSH
35633: LD_VAR 0 4
35637: ARRAY
35638: PUSH
35639: LD_INT 1
35641: MINUS
35642: PPUSH
35643: LD_EXP 77
35647: PUSH
35648: LD_VAR 0 4
35652: ARRAY
35653: PPUSH
35654: LD_INT 0
35656: PPUSH
35657: CALL 53499 0 4
35661: PPUSH
35662: CALL_OW 1
35666: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35667: LD_ADDR_EXP 77
35671: PUSH
35672: LD_EXP 77
35676: PPUSH
35677: LD_VAR 0 4
35681: PPUSH
35682: LD_EXP 77
35686: PUSH
35687: LD_VAR 0 4
35691: ARRAY
35692: PPUSH
35693: LD_EXP 77
35697: PUSH
35698: LD_VAR 0 4
35702: ARRAY
35703: PPUSH
35704: LD_INT 1
35706: PPUSH
35707: LD_INT 0
35709: PPUSH
35710: CALL 53499 0 4
35714: PPUSH
35715: CALL_OW 1
35719: ST_TO_ADDR
// continue ;
35720: GO 35294
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35722: LD_EXP 79
35726: PUSH
35727: LD_VAR 0 2
35731: ARRAY
35732: PUSH
35733: LD_EXP 80
35737: PUSH
35738: LD_VAR 0 2
35742: ARRAY
35743: NOT
35744: AND
35745: IFFALSE 35872
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35747: LD_ADDR_EXP 80
35751: PUSH
35752: LD_EXP 80
35756: PPUSH
35757: LD_VAR 0 2
35761: PUSH
35762: LD_EXP 80
35766: PUSH
35767: LD_VAR 0 2
35771: ARRAY
35772: PUSH
35773: LD_INT 1
35775: PLUS
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: PPUSH
35781: LD_EXP 79
35785: PUSH
35786: LD_VAR 0 2
35790: ARRAY
35791: PUSH
35792: LD_INT 1
35794: ARRAY
35795: PPUSH
35796: CALL 54081 0 3
35800: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35801: LD_EXP 79
35805: PUSH
35806: LD_VAR 0 2
35810: ARRAY
35811: PUSH
35812: LD_INT 1
35814: ARRAY
35815: PPUSH
35816: LD_INT 112
35818: PPUSH
35819: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35823: LD_ADDR_VAR 0 9
35827: PUSH
35828: LD_EXP 79
35832: PUSH
35833: LD_VAR 0 2
35837: ARRAY
35838: PPUSH
35839: LD_INT 1
35841: PPUSH
35842: CALL_OW 3
35846: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35847: LD_ADDR_EXP 79
35851: PUSH
35852: LD_EXP 79
35856: PPUSH
35857: LD_VAR 0 2
35861: PPUSH
35862: LD_VAR 0 9
35866: PPUSH
35867: CALL_OW 1
35871: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35872: LD_EXP 79
35876: PUSH
35877: LD_VAR 0 2
35881: ARRAY
35882: PUSH
35883: LD_EXP 80
35887: PUSH
35888: LD_VAR 0 2
35892: ARRAY
35893: AND
35894: PUSH
35895: LD_EXP 80
35899: PUSH
35900: LD_VAR 0 2
35904: ARRAY
35905: PUSH
35906: LD_INT 1
35908: ARRAY
35909: PPUSH
35910: CALL_OW 310
35914: NOT
35915: AND
35916: PUSH
35917: LD_VAR 0 3
35921: PPUSH
35922: CALL_OW 313
35926: PUSH
35927: LD_INT 6
35929: EQUAL
35930: AND
35931: IFFALSE 35987
// begin tmp2 := UnitsInside ( j ) ;
35933: LD_ADDR_VAR 0 9
35937: PUSH
35938: LD_VAR 0 3
35942: PPUSH
35943: CALL_OW 313
35947: ST_TO_ADDR
// if tmp2 = 6 then
35948: LD_VAR 0 9
35952: PUSH
35953: LD_INT 6
35955: EQUAL
35956: IFFALSE 35987
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35958: LD_VAR 0 9
35962: PUSH
35963: LD_INT 1
35965: ARRAY
35966: PPUSH
35967: LD_INT 112
35969: PPUSH
35970: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35974: LD_VAR 0 9
35978: PUSH
35979: LD_INT 1
35981: ARRAY
35982: PPUSH
35983: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35987: LD_EXP 80
35991: PUSH
35992: LD_VAR 0 2
35996: ARRAY
35997: PUSH
35998: LD_EXP 80
36002: PUSH
36003: LD_VAR 0 2
36007: ARRAY
36008: PUSH
36009: LD_INT 1
36011: ARRAY
36012: PPUSH
36013: CALL_OW 314
36017: NOT
36018: AND
36019: PUSH
36020: LD_EXP 80
36024: PUSH
36025: LD_VAR 0 2
36029: ARRAY
36030: PUSH
36031: LD_INT 1
36033: ARRAY
36034: PPUSH
36035: CALL_OW 310
36039: NOT
36040: AND
36041: IFFALSE 36067
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
36043: LD_EXP 80
36047: PUSH
36048: LD_VAR 0 2
36052: ARRAY
36053: PUSH
36054: LD_INT 1
36056: ARRAY
36057: PPUSH
36058: LD_VAR 0 3
36062: PPUSH
36063: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
36067: LD_EXP 80
36071: PUSH
36072: LD_VAR 0 2
36076: ARRAY
36077: PUSH
36078: LD_INT 1
36080: ARRAY
36081: PPUSH
36082: CALL_OW 310
36086: PUSH
36087: LD_EXP 80
36091: PUSH
36092: LD_VAR 0 2
36096: ARRAY
36097: PUSH
36098: LD_INT 1
36100: ARRAY
36101: PPUSH
36102: CALL_OW 310
36106: PPUSH
36107: CALL_OW 461
36111: PUSH
36112: LD_INT 3
36114: NONEQUAL
36115: AND
36116: IFFALSE 36137
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36118: LD_EXP 80
36122: PUSH
36123: LD_VAR 0 2
36127: ARRAY
36128: PUSH
36129: LD_INT 1
36131: ARRAY
36132: PPUSH
36133: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
36137: LD_VAR 0 3
36141: PPUSH
36142: CALL_OW 461
36146: PUSH
36147: LD_INT 6
36149: EQUAL
36150: PUSH
36151: LD_VAR 0 6
36155: PUSH
36156: LD_INT 1
36158: GREATER
36159: AND
36160: IFFALSE 36312
// begin sci := [ ] ;
36162: LD_ADDR_VAR 0 8
36166: PUSH
36167: EMPTY
36168: ST_TO_ADDR
// for x in ( tmp diff j ) do
36169: LD_ADDR_VAR 0 7
36173: PUSH
36174: LD_VAR 0 6
36178: PUSH
36179: LD_VAR 0 3
36183: DIFF
36184: PUSH
36185: FOR_IN
36186: IFFALSE 36238
// begin if sci = 6 then
36188: LD_VAR 0 8
36192: PUSH
36193: LD_INT 6
36195: EQUAL
36196: IFFALSE 36200
// break ;
36198: GO 36238
// if BuildingStatus ( x ) = bs_idle then
36200: LD_VAR 0 7
36204: PPUSH
36205: CALL_OW 461
36209: PUSH
36210: LD_INT 2
36212: EQUAL
36213: IFFALSE 36236
// sci := sci ^ UnitsInside ( x ) ;
36215: LD_ADDR_VAR 0 8
36219: PUSH
36220: LD_VAR 0 8
36224: PUSH
36225: LD_VAR 0 7
36229: PPUSH
36230: CALL_OW 313
36234: ADD
36235: ST_TO_ADDR
// end ;
36236: GO 36185
36238: POP
36239: POP
// if not sci then
36240: LD_VAR 0 8
36244: NOT
36245: IFFALSE 36249
// continue ;
36247: GO 35294
// for x in sci do
36249: LD_ADDR_VAR 0 7
36253: PUSH
36254: LD_VAR 0 8
36258: PUSH
36259: FOR_IN
36260: IFFALSE 36310
// if IsInUnit ( x ) and not HasTask ( x ) then
36262: LD_VAR 0 7
36266: PPUSH
36267: CALL_OW 310
36271: PUSH
36272: LD_VAR 0 7
36276: PPUSH
36277: CALL_OW 314
36281: NOT
36282: AND
36283: IFFALSE 36308
// begin ComExitBuilding ( x ) ;
36285: LD_VAR 0 7
36289: PPUSH
36290: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36294: LD_VAR 0 7
36298: PPUSH
36299: LD_VAR 0 3
36303: PPUSH
36304: CALL_OW 180
// end ;
36308: GO 36259
36310: POP
36311: POP
// end ; end ;
36312: GO 35294
36314: POP
36315: POP
// end ;
36316: GO 35248
36318: POP
36319: POP
// end ;
36320: LD_VAR 0 1
36324: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
36325: LD_INT 0
36327: PPUSH
36328: PPUSH
// if not mc_bases then
36329: LD_EXP 50
36333: NOT
36334: IFFALSE 36338
// exit ;
36336: GO 36419
// for i = 1 to mc_bases do
36338: LD_ADDR_VAR 0 2
36342: PUSH
36343: DOUBLE
36344: LD_INT 1
36346: DEC
36347: ST_TO_ADDR
36348: LD_EXP 50
36352: PUSH
36353: FOR_TO
36354: IFFALSE 36417
// if mc_mines [ i ] and mc_miners [ i ] then
36356: LD_EXP 63
36360: PUSH
36361: LD_VAR 0 2
36365: ARRAY
36366: PUSH
36367: LD_EXP 64
36371: PUSH
36372: LD_VAR 0 2
36376: ARRAY
36377: AND
36378: IFFALSE 36415
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
36380: LD_EXP 64
36384: PUSH
36385: LD_VAR 0 2
36389: ARRAY
36390: PUSH
36391: LD_INT 1
36393: ARRAY
36394: PPUSH
36395: CALL_OW 255
36399: PPUSH
36400: LD_EXP 63
36404: PUSH
36405: LD_VAR 0 2
36409: ARRAY
36410: PPUSH
36411: CALL 51058 0 2
36415: GO 36353
36417: POP
36418: POP
// end ;
36419: LD_VAR 0 1
36423: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
36424: LD_INT 0
36426: PPUSH
36427: PPUSH
36428: PPUSH
36429: PPUSH
36430: PPUSH
36431: PPUSH
36432: PPUSH
36433: PPUSH
// if not mc_bases or not mc_parking then
36434: LD_EXP 50
36438: NOT
36439: PUSH
36440: LD_EXP 74
36444: NOT
36445: OR
36446: IFFALSE 36450
// exit ;
36448: GO 37188
// for i = 1 to mc_bases do
36450: LD_ADDR_VAR 0 2
36454: PUSH
36455: DOUBLE
36456: LD_INT 1
36458: DEC
36459: ST_TO_ADDR
36460: LD_EXP 50
36464: PUSH
36465: FOR_TO
36466: IFFALSE 37186
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36468: LD_EXP 50
36472: PUSH
36473: LD_VAR 0 2
36477: ARRAY
36478: NOT
36479: PUSH
36480: LD_EXP 74
36484: PUSH
36485: LD_VAR 0 2
36489: ARRAY
36490: NOT
36491: OR
36492: IFFALSE 36496
// continue ;
36494: GO 36465
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36496: LD_ADDR_VAR 0 5
36500: PUSH
36501: LD_EXP 50
36505: PUSH
36506: LD_VAR 0 2
36510: ARRAY
36511: PUSH
36512: LD_INT 1
36514: ARRAY
36515: PPUSH
36516: CALL_OW 255
36520: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36521: LD_ADDR_VAR 0 6
36525: PUSH
36526: LD_EXP 50
36530: PUSH
36531: LD_VAR 0 2
36535: ARRAY
36536: PPUSH
36537: LD_INT 30
36539: PUSH
36540: LD_INT 3
36542: PUSH
36543: EMPTY
36544: LIST
36545: LIST
36546: PPUSH
36547: CALL_OW 72
36551: ST_TO_ADDR
// if not fac then
36552: LD_VAR 0 6
36556: NOT
36557: IFFALSE 36608
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36559: LD_ADDR_VAR 0 6
36563: PUSH
36564: LD_EXP 50
36568: PUSH
36569: LD_VAR 0 2
36573: ARRAY
36574: PPUSH
36575: LD_INT 2
36577: PUSH
36578: LD_INT 30
36580: PUSH
36581: LD_INT 0
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: LD_INT 30
36590: PUSH
36591: LD_INT 1
36593: PUSH
36594: EMPTY
36595: LIST
36596: LIST
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: LIST
36602: PPUSH
36603: CALL_OW 72
36607: ST_TO_ADDR
// if not fac then
36608: LD_VAR 0 6
36612: NOT
36613: IFFALSE 36617
// continue ;
36615: GO 36465
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36617: LD_ADDR_VAR 0 7
36621: PUSH
36622: LD_EXP 74
36626: PUSH
36627: LD_VAR 0 2
36631: ARRAY
36632: PPUSH
36633: LD_INT 22
36635: PUSH
36636: LD_VAR 0 5
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 21
36647: PUSH
36648: LD_INT 2
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 3
36657: PUSH
36658: LD_INT 60
36660: PUSH
36661: EMPTY
36662: LIST
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: PUSH
36668: LD_INT 3
36670: PUSH
36671: LD_INT 24
36673: PUSH
36674: LD_INT 1000
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: PUSH
36685: EMPTY
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: PPUSH
36691: CALL_OW 70
36695: ST_TO_ADDR
// for j in fac do
36696: LD_ADDR_VAR 0 3
36700: PUSH
36701: LD_VAR 0 6
36705: PUSH
36706: FOR_IN
36707: IFFALSE 36802
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36709: LD_ADDR_VAR 0 7
36713: PUSH
36714: LD_VAR 0 7
36718: PUSH
36719: LD_INT 22
36721: PUSH
36722: LD_VAR 0 5
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: LD_INT 91
36733: PUSH
36734: LD_VAR 0 3
36738: PUSH
36739: LD_INT 15
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 21
36749: PUSH
36750: LD_INT 2
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PUSH
36757: LD_INT 3
36759: PUSH
36760: LD_INT 60
36762: PUSH
36763: EMPTY
36764: LIST
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 3
36772: PUSH
36773: LD_INT 24
36775: PUSH
36776: LD_INT 1000
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: EMPTY
36784: LIST
36785: LIST
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: PPUSH
36794: CALL_OW 69
36798: UNION
36799: ST_TO_ADDR
36800: GO 36706
36802: POP
36803: POP
// if not vehs then
36804: LD_VAR 0 7
36808: NOT
36809: IFFALSE 36835
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36811: LD_ADDR_EXP 62
36815: PUSH
36816: LD_EXP 62
36820: PPUSH
36821: LD_VAR 0 2
36825: PPUSH
36826: EMPTY
36827: PPUSH
36828: CALL_OW 1
36832: ST_TO_ADDR
// continue ;
36833: GO 36465
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36835: LD_ADDR_VAR 0 8
36839: PUSH
36840: LD_EXP 50
36844: PUSH
36845: LD_VAR 0 2
36849: ARRAY
36850: PPUSH
36851: LD_INT 30
36853: PUSH
36854: LD_INT 3
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: PPUSH
36861: CALL_OW 72
36865: ST_TO_ADDR
// if tmp then
36866: LD_VAR 0 8
36870: IFFALSE 36973
// begin for j in tmp do
36872: LD_ADDR_VAR 0 3
36876: PUSH
36877: LD_VAR 0 8
36881: PUSH
36882: FOR_IN
36883: IFFALSE 36971
// for k in UnitsInside ( j ) do
36885: LD_ADDR_VAR 0 4
36889: PUSH
36890: LD_VAR 0 3
36894: PPUSH
36895: CALL_OW 313
36899: PUSH
36900: FOR_IN
36901: IFFALSE 36967
// if k then
36903: LD_VAR 0 4
36907: IFFALSE 36965
// if not k in mc_repair_vehicle [ i ] then
36909: LD_VAR 0 4
36913: PUSH
36914: LD_EXP 62
36918: PUSH
36919: LD_VAR 0 2
36923: ARRAY
36924: IN
36925: NOT
36926: IFFALSE 36965
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36928: LD_ADDR_EXP 62
36932: PUSH
36933: LD_EXP 62
36937: PPUSH
36938: LD_VAR 0 2
36942: PPUSH
36943: LD_EXP 62
36947: PUSH
36948: LD_VAR 0 2
36952: ARRAY
36953: PUSH
36954: LD_VAR 0 4
36958: UNION
36959: PPUSH
36960: CALL_OW 1
36964: ST_TO_ADDR
36965: GO 36900
36967: POP
36968: POP
36969: GO 36882
36971: POP
36972: POP
// end ; if not mc_repair_vehicle [ i ] then
36973: LD_EXP 62
36977: PUSH
36978: LD_VAR 0 2
36982: ARRAY
36983: NOT
36984: IFFALSE 36988
// continue ;
36986: GO 36465
// for j in mc_repair_vehicle [ i ] do
36988: LD_ADDR_VAR 0 3
36992: PUSH
36993: LD_EXP 62
36997: PUSH
36998: LD_VAR 0 2
37002: ARRAY
37003: PUSH
37004: FOR_IN
37005: IFFALSE 37182
// begin if GetClass ( j ) <> 3 then
37007: LD_VAR 0 3
37011: PPUSH
37012: CALL_OW 257
37016: PUSH
37017: LD_INT 3
37019: NONEQUAL
37020: IFFALSE 37061
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
37022: LD_ADDR_EXP 62
37026: PUSH
37027: LD_EXP 62
37031: PPUSH
37032: LD_VAR 0 2
37036: PPUSH
37037: LD_EXP 62
37041: PUSH
37042: LD_VAR 0 2
37046: ARRAY
37047: PUSH
37048: LD_VAR 0 3
37052: DIFF
37053: PPUSH
37054: CALL_OW 1
37058: ST_TO_ADDR
// continue ;
37059: GO 37004
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37061: LD_VAR 0 3
37065: PPUSH
37066: CALL_OW 311
37070: NOT
37071: PUSH
37072: LD_VAR 0 3
37076: PUSH
37077: LD_EXP 53
37081: PUSH
37082: LD_VAR 0 2
37086: ARRAY
37087: PUSH
37088: LD_INT 1
37090: ARRAY
37091: IN
37092: NOT
37093: AND
37094: PUSH
37095: LD_VAR 0 3
37099: PUSH
37100: LD_EXP 53
37104: PUSH
37105: LD_VAR 0 2
37109: ARRAY
37110: PUSH
37111: LD_INT 2
37113: ARRAY
37114: IN
37115: NOT
37116: AND
37117: IFFALSE 37180
// begin if IsInUnit ( j ) then
37119: LD_VAR 0 3
37123: PPUSH
37124: CALL_OW 310
37128: IFFALSE 37141
// ComExitBuilding ( j ) else
37130: LD_VAR 0 3
37134: PPUSH
37135: CALL_OW 122
37139: GO 37180
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
37141: LD_VAR 0 3
37145: PPUSH
37146: LD_VAR 0 7
37150: PUSH
37151: LD_INT 1
37153: ARRAY
37154: PPUSH
37155: CALL 88886 0 2
37159: NOT
37160: IFFALSE 37180
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
37162: LD_VAR 0 3
37166: PPUSH
37167: LD_VAR 0 7
37171: PUSH
37172: LD_INT 1
37174: ARRAY
37175: PPUSH
37176: CALL_OW 129
// end ; end ;
37180: GO 37004
37182: POP
37183: POP
// end ;
37184: GO 36465
37186: POP
37187: POP
// end ;
37188: LD_VAR 0 1
37192: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37193: LD_INT 0
37195: PPUSH
37196: PPUSH
37197: PPUSH
37198: PPUSH
37199: PPUSH
37200: PPUSH
37201: PPUSH
37202: PPUSH
37203: PPUSH
37204: PPUSH
37205: PPUSH
// if not mc_bases then
37206: LD_EXP 50
37210: NOT
37211: IFFALSE 37215
// exit ;
37213: GO 38017
// for i = 1 to mc_bases do
37215: LD_ADDR_VAR 0 2
37219: PUSH
37220: DOUBLE
37221: LD_INT 1
37223: DEC
37224: ST_TO_ADDR
37225: LD_EXP 50
37229: PUSH
37230: FOR_TO
37231: IFFALSE 38015
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37233: LD_EXP 78
37237: PUSH
37238: LD_VAR 0 2
37242: ARRAY
37243: NOT
37244: PUSH
37245: LD_EXP 53
37249: PUSH
37250: LD_VAR 0 2
37254: ARRAY
37255: PUSH
37256: LD_INT 1
37258: ARRAY
37259: OR
37260: PUSH
37261: LD_EXP 53
37265: PUSH
37266: LD_VAR 0 2
37270: ARRAY
37271: PUSH
37272: LD_INT 2
37274: ARRAY
37275: OR
37276: PUSH
37277: LD_EXP 76
37281: PUSH
37282: LD_VAR 0 2
37286: ARRAY
37287: PPUSH
37288: LD_INT 1
37290: PPUSH
37291: CALL_OW 325
37295: NOT
37296: OR
37297: PUSH
37298: LD_EXP 73
37302: PUSH
37303: LD_VAR 0 2
37307: ARRAY
37308: OR
37309: IFFALSE 37313
// continue ;
37311: GO 37230
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37313: LD_ADDR_VAR 0 8
37317: PUSH
37318: LD_EXP 50
37322: PUSH
37323: LD_VAR 0 2
37327: ARRAY
37328: PPUSH
37329: LD_INT 25
37331: PUSH
37332: LD_INT 4
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: LD_INT 50
37341: PUSH
37342: EMPTY
37343: LIST
37344: PUSH
37345: LD_INT 3
37347: PUSH
37348: LD_INT 60
37350: PUSH
37351: EMPTY
37352: LIST
37353: PUSH
37354: EMPTY
37355: LIST
37356: LIST
37357: PUSH
37358: EMPTY
37359: LIST
37360: LIST
37361: LIST
37362: PPUSH
37363: CALL_OW 72
37367: PUSH
37368: LD_EXP 54
37372: PUSH
37373: LD_VAR 0 2
37377: ARRAY
37378: DIFF
37379: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37380: LD_ADDR_VAR 0 9
37384: PUSH
37385: LD_EXP 50
37389: PUSH
37390: LD_VAR 0 2
37394: ARRAY
37395: PPUSH
37396: LD_INT 2
37398: PUSH
37399: LD_INT 30
37401: PUSH
37402: LD_INT 0
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: LD_INT 30
37411: PUSH
37412: LD_INT 1
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: EMPTY
37420: LIST
37421: LIST
37422: LIST
37423: PPUSH
37424: CALL_OW 72
37428: ST_TO_ADDR
// if not tmp or not dep then
37429: LD_VAR 0 8
37433: NOT
37434: PUSH
37435: LD_VAR 0 9
37439: NOT
37440: OR
37441: IFFALSE 37445
// continue ;
37443: GO 37230
// side := GetSide ( tmp [ 1 ] ) ;
37445: LD_ADDR_VAR 0 11
37449: PUSH
37450: LD_VAR 0 8
37454: PUSH
37455: LD_INT 1
37457: ARRAY
37458: PPUSH
37459: CALL_OW 255
37463: ST_TO_ADDR
// dep := dep [ 1 ] ;
37464: LD_ADDR_VAR 0 9
37468: PUSH
37469: LD_VAR 0 9
37473: PUSH
37474: LD_INT 1
37476: ARRAY
37477: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37478: LD_ADDR_VAR 0 7
37482: PUSH
37483: LD_EXP 78
37487: PUSH
37488: LD_VAR 0 2
37492: ARRAY
37493: PPUSH
37494: LD_INT 22
37496: PUSH
37497: LD_INT 0
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: PUSH
37504: LD_INT 25
37506: PUSH
37507: LD_INT 12
37509: PUSH
37510: EMPTY
37511: LIST
37512: LIST
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PPUSH
37518: CALL_OW 70
37522: PUSH
37523: LD_INT 22
37525: PUSH
37526: LD_INT 0
37528: PUSH
37529: EMPTY
37530: LIST
37531: LIST
37532: PUSH
37533: LD_INT 25
37535: PUSH
37536: LD_INT 12
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PUSH
37543: LD_INT 91
37545: PUSH
37546: LD_VAR 0 9
37550: PUSH
37551: LD_INT 20
37553: PUSH
37554: EMPTY
37555: LIST
37556: LIST
37557: LIST
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: LIST
37563: PPUSH
37564: CALL_OW 69
37568: UNION
37569: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37570: LD_ADDR_VAR 0 10
37574: PUSH
37575: LD_EXP 78
37579: PUSH
37580: LD_VAR 0 2
37584: ARRAY
37585: PPUSH
37586: LD_INT 81
37588: PUSH
37589: LD_VAR 0 11
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PPUSH
37598: CALL_OW 70
37602: ST_TO_ADDR
// if not apes or danger_at_area then
37603: LD_VAR 0 7
37607: NOT
37608: PUSH
37609: LD_VAR 0 10
37613: OR
37614: IFFALSE 37664
// begin if mc_taming [ i ] then
37616: LD_EXP 81
37620: PUSH
37621: LD_VAR 0 2
37625: ARRAY
37626: IFFALSE 37662
// begin MC_Reset ( i , 121 ) ;
37628: LD_VAR 0 2
37632: PPUSH
37633: LD_INT 121
37635: PPUSH
37636: CALL 22580 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37640: LD_ADDR_EXP 81
37644: PUSH
37645: LD_EXP 81
37649: PPUSH
37650: LD_VAR 0 2
37654: PPUSH
37655: EMPTY
37656: PPUSH
37657: CALL_OW 1
37661: ST_TO_ADDR
// end ; continue ;
37662: GO 37230
// end ; for j in tmp do
37664: LD_ADDR_VAR 0 3
37668: PUSH
37669: LD_VAR 0 8
37673: PUSH
37674: FOR_IN
37675: IFFALSE 38011
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37677: LD_VAR 0 3
37681: PUSH
37682: LD_EXP 81
37686: PUSH
37687: LD_VAR 0 2
37691: ARRAY
37692: IN
37693: NOT
37694: PUSH
37695: LD_EXP 81
37699: PUSH
37700: LD_VAR 0 2
37704: ARRAY
37705: PUSH
37706: LD_INT 3
37708: LESS
37709: AND
37710: IFFALSE 37768
// begin SetTag ( j , 121 ) ;
37712: LD_VAR 0 3
37716: PPUSH
37717: LD_INT 121
37719: PPUSH
37720: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37724: LD_ADDR_EXP 81
37728: PUSH
37729: LD_EXP 81
37733: PPUSH
37734: LD_VAR 0 2
37738: PUSH
37739: LD_EXP 81
37743: PUSH
37744: LD_VAR 0 2
37748: ARRAY
37749: PUSH
37750: LD_INT 1
37752: PLUS
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PPUSH
37758: LD_VAR 0 3
37762: PPUSH
37763: CALL 54081 0 3
37767: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37768: LD_VAR 0 3
37772: PUSH
37773: LD_EXP 81
37777: PUSH
37778: LD_VAR 0 2
37782: ARRAY
37783: IN
37784: IFFALSE 38009
// begin if GetClass ( j ) <> 4 then
37786: LD_VAR 0 3
37790: PPUSH
37791: CALL_OW 257
37795: PUSH
37796: LD_INT 4
37798: NONEQUAL
37799: IFFALSE 37852
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37801: LD_ADDR_EXP 81
37805: PUSH
37806: LD_EXP 81
37810: PPUSH
37811: LD_VAR 0 2
37815: PPUSH
37816: LD_EXP 81
37820: PUSH
37821: LD_VAR 0 2
37825: ARRAY
37826: PUSH
37827: LD_VAR 0 3
37831: DIFF
37832: PPUSH
37833: CALL_OW 1
37837: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37838: LD_VAR 0 3
37842: PPUSH
37843: LD_INT 0
37845: PPUSH
37846: CALL_OW 109
// continue ;
37850: GO 37674
// end ; if IsInUnit ( j ) then
37852: LD_VAR 0 3
37856: PPUSH
37857: CALL_OW 310
37861: IFFALSE 37872
// ComExitBuilding ( j ) ;
37863: LD_VAR 0 3
37867: PPUSH
37868: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37872: LD_ADDR_VAR 0 6
37876: PUSH
37877: LD_VAR 0 7
37881: PPUSH
37882: LD_VAR 0 3
37886: PPUSH
37887: CALL_OW 74
37891: ST_TO_ADDR
// if not ape then
37892: LD_VAR 0 6
37896: NOT
37897: IFFALSE 37901
// break ;
37899: GO 38011
// x := GetX ( ape ) ;
37901: LD_ADDR_VAR 0 4
37905: PUSH
37906: LD_VAR 0 6
37910: PPUSH
37911: CALL_OW 250
37915: ST_TO_ADDR
// y := GetY ( ape ) ;
37916: LD_ADDR_VAR 0 5
37920: PUSH
37921: LD_VAR 0 6
37925: PPUSH
37926: CALL_OW 251
37930: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37931: LD_VAR 0 4
37935: PPUSH
37936: LD_VAR 0 5
37940: PPUSH
37941: CALL_OW 488
37945: NOT
37946: PUSH
37947: LD_VAR 0 11
37951: PPUSH
37952: LD_VAR 0 4
37956: PPUSH
37957: LD_VAR 0 5
37961: PPUSH
37962: LD_INT 20
37964: PPUSH
37965: CALL 55345 0 4
37969: PUSH
37970: LD_INT 4
37972: ARRAY
37973: OR
37974: IFFALSE 37978
// break ;
37976: GO 38011
// if not HasTask ( j ) then
37978: LD_VAR 0 3
37982: PPUSH
37983: CALL_OW 314
37987: NOT
37988: IFFALSE 38009
// ComTameXY ( j , x , y ) ;
37990: LD_VAR 0 3
37994: PPUSH
37995: LD_VAR 0 4
37999: PPUSH
38000: LD_VAR 0 5
38004: PPUSH
38005: CALL_OW 131
// end ; end ;
38009: GO 37674
38011: POP
38012: POP
// end ;
38013: GO 37230
38015: POP
38016: POP
// end ;
38017: LD_VAR 0 1
38021: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
38022: LD_INT 0
38024: PPUSH
38025: PPUSH
38026: PPUSH
38027: PPUSH
38028: PPUSH
38029: PPUSH
38030: PPUSH
38031: PPUSH
// if not mc_bases then
38032: LD_EXP 50
38036: NOT
38037: IFFALSE 38041
// exit ;
38039: GO 38667
// for i = 1 to mc_bases do
38041: LD_ADDR_VAR 0 2
38045: PUSH
38046: DOUBLE
38047: LD_INT 1
38049: DEC
38050: ST_TO_ADDR
38051: LD_EXP 50
38055: PUSH
38056: FOR_TO
38057: IFFALSE 38665
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
38059: LD_EXP 79
38063: PUSH
38064: LD_VAR 0 2
38068: ARRAY
38069: NOT
38070: PUSH
38071: LD_EXP 79
38075: PUSH
38076: LD_VAR 0 2
38080: ARRAY
38081: PPUSH
38082: LD_INT 25
38084: PUSH
38085: LD_INT 12
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: PPUSH
38092: CALL_OW 72
38096: NOT
38097: OR
38098: IFFALSE 38102
// continue ;
38100: GO 38056
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
38102: LD_ADDR_VAR 0 5
38106: PUSH
38107: LD_EXP 79
38111: PUSH
38112: LD_VAR 0 2
38116: ARRAY
38117: PUSH
38118: LD_INT 1
38120: ARRAY
38121: PPUSH
38122: CALL_OW 255
38126: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38127: LD_VAR 0 5
38131: PPUSH
38132: LD_INT 2
38134: PPUSH
38135: CALL_OW 325
38139: IFFALSE 38392
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38141: LD_ADDR_VAR 0 4
38145: PUSH
38146: LD_EXP 79
38150: PUSH
38151: LD_VAR 0 2
38155: ARRAY
38156: PPUSH
38157: LD_INT 25
38159: PUSH
38160: LD_INT 16
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: PPUSH
38167: CALL_OW 72
38171: ST_TO_ADDR
// if tmp < 6 then
38172: LD_VAR 0 4
38176: PUSH
38177: LD_INT 6
38179: LESS
38180: IFFALSE 38392
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38182: LD_ADDR_VAR 0 6
38186: PUSH
38187: LD_EXP 50
38191: PUSH
38192: LD_VAR 0 2
38196: ARRAY
38197: PPUSH
38198: LD_INT 2
38200: PUSH
38201: LD_INT 30
38203: PUSH
38204: LD_INT 0
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: PUSH
38211: LD_INT 30
38213: PUSH
38214: LD_INT 1
38216: PUSH
38217: EMPTY
38218: LIST
38219: LIST
38220: PUSH
38221: EMPTY
38222: LIST
38223: LIST
38224: LIST
38225: PPUSH
38226: CALL_OW 72
38230: ST_TO_ADDR
// if depot then
38231: LD_VAR 0 6
38235: IFFALSE 38392
// begin selected := 0 ;
38237: LD_ADDR_VAR 0 7
38241: PUSH
38242: LD_INT 0
38244: ST_TO_ADDR
// for j in depot do
38245: LD_ADDR_VAR 0 3
38249: PUSH
38250: LD_VAR 0 6
38254: PUSH
38255: FOR_IN
38256: IFFALSE 38287
// begin if UnitsInside ( j ) < 6 then
38258: LD_VAR 0 3
38262: PPUSH
38263: CALL_OW 313
38267: PUSH
38268: LD_INT 6
38270: LESS
38271: IFFALSE 38285
// begin selected := j ;
38273: LD_ADDR_VAR 0 7
38277: PUSH
38278: LD_VAR 0 3
38282: ST_TO_ADDR
// break ;
38283: GO 38287
// end ; end ;
38285: GO 38255
38287: POP
38288: POP
// if selected then
38289: LD_VAR 0 7
38293: IFFALSE 38392
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38295: LD_ADDR_VAR 0 3
38299: PUSH
38300: LD_EXP 79
38304: PUSH
38305: LD_VAR 0 2
38309: ARRAY
38310: PPUSH
38311: LD_INT 25
38313: PUSH
38314: LD_INT 12
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PPUSH
38321: CALL_OW 72
38325: PUSH
38326: FOR_IN
38327: IFFALSE 38390
// if not HasTask ( j ) then
38329: LD_VAR 0 3
38333: PPUSH
38334: CALL_OW 314
38338: NOT
38339: IFFALSE 38388
// begin if not IsInUnit ( j ) then
38341: LD_VAR 0 3
38345: PPUSH
38346: CALL_OW 310
38350: NOT
38351: IFFALSE 38367
// ComEnterUnit ( j , selected ) ;
38353: LD_VAR 0 3
38357: PPUSH
38358: LD_VAR 0 7
38362: PPUSH
38363: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
38367: LD_VAR 0 3
38371: PPUSH
38372: LD_INT 16
38374: PPUSH
38375: CALL_OW 183
// AddComExitBuilding ( j ) ;
38379: LD_VAR 0 3
38383: PPUSH
38384: CALL_OW 182
// end ;
38388: GO 38326
38390: POP
38391: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
38392: LD_VAR 0 5
38396: PPUSH
38397: LD_INT 11
38399: PPUSH
38400: CALL_OW 325
38404: IFFALSE 38663
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38406: LD_ADDR_VAR 0 4
38410: PUSH
38411: LD_EXP 79
38415: PUSH
38416: LD_VAR 0 2
38420: ARRAY
38421: PPUSH
38422: LD_INT 25
38424: PUSH
38425: LD_INT 16
38427: PUSH
38428: EMPTY
38429: LIST
38430: LIST
38431: PPUSH
38432: CALL_OW 72
38436: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
38437: LD_VAR 0 4
38441: PUSH
38442: LD_INT 6
38444: GREATEREQUAL
38445: PUSH
38446: LD_VAR 0 5
38450: PPUSH
38451: LD_INT 2
38453: PPUSH
38454: CALL_OW 325
38458: NOT
38459: OR
38460: IFFALSE 38663
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38462: LD_ADDR_VAR 0 8
38466: PUSH
38467: LD_EXP 50
38471: PUSH
38472: LD_VAR 0 2
38476: ARRAY
38477: PPUSH
38478: LD_INT 2
38480: PUSH
38481: LD_INT 30
38483: PUSH
38484: LD_INT 4
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: PUSH
38491: LD_INT 30
38493: PUSH
38494: LD_INT 5
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: LIST
38505: PPUSH
38506: CALL_OW 72
38510: ST_TO_ADDR
// if barracks then
38511: LD_VAR 0 8
38515: IFFALSE 38663
// begin selected := 0 ;
38517: LD_ADDR_VAR 0 7
38521: PUSH
38522: LD_INT 0
38524: ST_TO_ADDR
// for j in barracks do
38525: LD_ADDR_VAR 0 3
38529: PUSH
38530: LD_VAR 0 8
38534: PUSH
38535: FOR_IN
38536: IFFALSE 38567
// begin if UnitsInside ( j ) < 6 then
38538: LD_VAR 0 3
38542: PPUSH
38543: CALL_OW 313
38547: PUSH
38548: LD_INT 6
38550: LESS
38551: IFFALSE 38565
// begin selected := j ;
38553: LD_ADDR_VAR 0 7
38557: PUSH
38558: LD_VAR 0 3
38562: ST_TO_ADDR
// break ;
38563: GO 38567
// end ; end ;
38565: GO 38535
38567: POP
38568: POP
// if selected then
38569: LD_VAR 0 7
38573: IFFALSE 38663
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38575: LD_ADDR_VAR 0 3
38579: PUSH
38580: LD_EXP 79
38584: PUSH
38585: LD_VAR 0 2
38589: ARRAY
38590: PPUSH
38591: LD_INT 25
38593: PUSH
38594: LD_INT 12
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PPUSH
38601: CALL_OW 72
38605: PUSH
38606: FOR_IN
38607: IFFALSE 38661
// if not IsInUnit ( j ) and not HasTask ( j ) then
38609: LD_VAR 0 3
38613: PPUSH
38614: CALL_OW 310
38618: NOT
38619: PUSH
38620: LD_VAR 0 3
38624: PPUSH
38625: CALL_OW 314
38629: NOT
38630: AND
38631: IFFALSE 38659
// begin ComEnterUnit ( j , selected ) ;
38633: LD_VAR 0 3
38637: PPUSH
38638: LD_VAR 0 7
38642: PPUSH
38643: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38647: LD_VAR 0 3
38651: PPUSH
38652: LD_INT 15
38654: PPUSH
38655: CALL_OW 183
// end ;
38659: GO 38606
38661: POP
38662: POP
// end ; end ; end ; end ; end ;
38663: GO 38056
38665: POP
38666: POP
// end ;
38667: LD_VAR 0 1
38671: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38672: LD_INT 0
38674: PPUSH
38675: PPUSH
38676: PPUSH
38677: PPUSH
// if not mc_bases then
38678: LD_EXP 50
38682: NOT
38683: IFFALSE 38687
// exit ;
38685: GO 38865
// for i = 1 to mc_bases do
38687: LD_ADDR_VAR 0 2
38691: PUSH
38692: DOUBLE
38693: LD_INT 1
38695: DEC
38696: ST_TO_ADDR
38697: LD_EXP 50
38701: PUSH
38702: FOR_TO
38703: IFFALSE 38863
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38705: LD_ADDR_VAR 0 4
38709: PUSH
38710: LD_EXP 50
38714: PUSH
38715: LD_VAR 0 2
38719: ARRAY
38720: PPUSH
38721: LD_INT 25
38723: PUSH
38724: LD_INT 9
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PPUSH
38731: CALL_OW 72
38735: ST_TO_ADDR
// if not tmp then
38736: LD_VAR 0 4
38740: NOT
38741: IFFALSE 38745
// continue ;
38743: GO 38702
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38745: LD_EXP 76
38749: PUSH
38750: LD_VAR 0 2
38754: ARRAY
38755: PPUSH
38756: LD_INT 29
38758: PPUSH
38759: CALL_OW 325
38763: NOT
38764: PUSH
38765: LD_EXP 76
38769: PUSH
38770: LD_VAR 0 2
38774: ARRAY
38775: PPUSH
38776: LD_INT 28
38778: PPUSH
38779: CALL_OW 325
38783: NOT
38784: AND
38785: IFFALSE 38789
// continue ;
38787: GO 38702
// for j in tmp do
38789: LD_ADDR_VAR 0 3
38793: PUSH
38794: LD_VAR 0 4
38798: PUSH
38799: FOR_IN
38800: IFFALSE 38859
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38802: LD_VAR 0 3
38806: PUSH
38807: LD_EXP 53
38811: PUSH
38812: LD_VAR 0 2
38816: ARRAY
38817: PUSH
38818: LD_INT 1
38820: ARRAY
38821: IN
38822: NOT
38823: PUSH
38824: LD_VAR 0 3
38828: PUSH
38829: LD_EXP 53
38833: PUSH
38834: LD_VAR 0 2
38838: ARRAY
38839: PUSH
38840: LD_INT 2
38842: ARRAY
38843: IN
38844: NOT
38845: AND
38846: IFFALSE 38857
// ComSpaceTimeShoot ( j ) ;
38848: LD_VAR 0 3
38852: PPUSH
38853: CALL 50066 0 1
38857: GO 38799
38859: POP
38860: POP
// end ;
38861: GO 38702
38863: POP
38864: POP
// end ;
38865: LD_VAR 0 1
38869: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38870: LD_INT 0
38872: PPUSH
38873: PPUSH
38874: PPUSH
38875: PPUSH
38876: PPUSH
38877: PPUSH
38878: PPUSH
38879: PPUSH
38880: PPUSH
// if not mc_bases then
38881: LD_EXP 50
38885: NOT
38886: IFFALSE 38890
// exit ;
38888: GO 39512
// for i = 1 to mc_bases do
38890: LD_ADDR_VAR 0 2
38894: PUSH
38895: DOUBLE
38896: LD_INT 1
38898: DEC
38899: ST_TO_ADDR
38900: LD_EXP 50
38904: PUSH
38905: FOR_TO
38906: IFFALSE 39510
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38908: LD_EXP 85
38912: PUSH
38913: LD_VAR 0 2
38917: ARRAY
38918: NOT
38919: PUSH
38920: LD_INT 38
38922: PPUSH
38923: LD_EXP 76
38927: PUSH
38928: LD_VAR 0 2
38932: ARRAY
38933: PPUSH
38934: CALL_OW 321
38938: PUSH
38939: LD_INT 2
38941: NONEQUAL
38942: OR
38943: IFFALSE 38947
// continue ;
38945: GO 38905
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38947: LD_ADDR_VAR 0 8
38951: PUSH
38952: LD_EXP 50
38956: PUSH
38957: LD_VAR 0 2
38961: ARRAY
38962: PPUSH
38963: LD_INT 30
38965: PUSH
38966: LD_INT 34
38968: PUSH
38969: EMPTY
38970: LIST
38971: LIST
38972: PPUSH
38973: CALL_OW 72
38977: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38978: LD_ADDR_VAR 0 9
38982: PUSH
38983: LD_EXP 50
38987: PUSH
38988: LD_VAR 0 2
38992: ARRAY
38993: PPUSH
38994: LD_INT 25
38996: PUSH
38997: LD_INT 4
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PPUSH
39004: CALL_OW 72
39008: PPUSH
39009: LD_INT 0
39011: PPUSH
39012: CALL 84390 0 2
39016: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
39017: LD_VAR 0 9
39021: NOT
39022: PUSH
39023: LD_VAR 0 8
39027: NOT
39028: OR
39029: PUSH
39030: LD_EXP 50
39034: PUSH
39035: LD_VAR 0 2
39039: ARRAY
39040: PPUSH
39041: LD_INT 124
39043: PPUSH
39044: CALL 84390 0 2
39048: OR
39049: IFFALSE 39053
// continue ;
39051: GO 38905
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
39053: LD_EXP 86
39057: PUSH
39058: LD_VAR 0 2
39062: ARRAY
39063: PUSH
39064: LD_EXP 85
39068: PUSH
39069: LD_VAR 0 2
39073: ARRAY
39074: LESS
39075: PUSH
39076: LD_EXP 86
39080: PUSH
39081: LD_VAR 0 2
39085: ARRAY
39086: PUSH
39087: LD_VAR 0 8
39091: LESS
39092: AND
39093: IFFALSE 39508
// begin tmp := sci [ 1 ] ;
39095: LD_ADDR_VAR 0 7
39099: PUSH
39100: LD_VAR 0 9
39104: PUSH
39105: LD_INT 1
39107: ARRAY
39108: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
39109: LD_VAR 0 7
39113: PPUSH
39114: LD_INT 124
39116: PPUSH
39117: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39121: LD_ADDR_VAR 0 3
39125: PUSH
39126: DOUBLE
39127: LD_EXP 85
39131: PUSH
39132: LD_VAR 0 2
39136: ARRAY
39137: INC
39138: ST_TO_ADDR
39139: LD_EXP 85
39143: PUSH
39144: LD_VAR 0 2
39148: ARRAY
39149: PUSH
39150: FOR_DOWNTO
39151: IFFALSE 39494
// begin if IsInUnit ( tmp ) then
39153: LD_VAR 0 7
39157: PPUSH
39158: CALL_OW 310
39162: IFFALSE 39173
// ComExitBuilding ( tmp ) ;
39164: LD_VAR 0 7
39168: PPUSH
39169: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39173: LD_INT 35
39175: PPUSH
39176: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39180: LD_VAR 0 7
39184: PPUSH
39185: CALL_OW 310
39189: NOT
39190: PUSH
39191: LD_VAR 0 7
39195: PPUSH
39196: CALL_OW 314
39200: NOT
39201: AND
39202: IFFALSE 39173
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39204: LD_ADDR_VAR 0 6
39208: PUSH
39209: LD_VAR 0 7
39213: PPUSH
39214: CALL_OW 250
39218: PUSH
39219: LD_VAR 0 7
39223: PPUSH
39224: CALL_OW 251
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39233: LD_INT 35
39235: PPUSH
39236: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39240: LD_ADDR_VAR 0 4
39244: PUSH
39245: LD_EXP 85
39249: PUSH
39250: LD_VAR 0 2
39254: ARRAY
39255: PUSH
39256: LD_VAR 0 3
39260: ARRAY
39261: PUSH
39262: LD_INT 1
39264: ARRAY
39265: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39266: LD_ADDR_VAR 0 5
39270: PUSH
39271: LD_EXP 85
39275: PUSH
39276: LD_VAR 0 2
39280: ARRAY
39281: PUSH
39282: LD_VAR 0 3
39286: ARRAY
39287: PUSH
39288: LD_INT 2
39290: ARRAY
39291: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39292: LD_VAR 0 7
39296: PPUSH
39297: LD_INT 10
39299: PPUSH
39300: CALL 57046 0 2
39304: PUSH
39305: LD_INT 4
39307: ARRAY
39308: IFFALSE 39346
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39310: LD_VAR 0 7
39314: PPUSH
39315: LD_VAR 0 6
39319: PUSH
39320: LD_INT 1
39322: ARRAY
39323: PPUSH
39324: LD_VAR 0 6
39328: PUSH
39329: LD_INT 2
39331: ARRAY
39332: PPUSH
39333: CALL_OW 111
// wait ( 0 0$10 ) ;
39337: LD_INT 350
39339: PPUSH
39340: CALL_OW 67
// end else
39344: GO 39372
// begin ComMoveXY ( tmp , x , y ) ;
39346: LD_VAR 0 7
39350: PPUSH
39351: LD_VAR 0 4
39355: PPUSH
39356: LD_VAR 0 5
39360: PPUSH
39361: CALL_OW 111
// wait ( 0 0$3 ) ;
39365: LD_INT 105
39367: PPUSH
39368: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
39372: LD_VAR 0 7
39376: PPUSH
39377: LD_VAR 0 4
39381: PPUSH
39382: LD_VAR 0 5
39386: PPUSH
39387: CALL_OW 307
39391: IFFALSE 39233
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
39393: LD_VAR 0 7
39397: PPUSH
39398: LD_VAR 0 4
39402: PPUSH
39403: LD_VAR 0 5
39407: PPUSH
39408: LD_VAR 0 8
39412: PUSH
39413: LD_VAR 0 3
39417: ARRAY
39418: PPUSH
39419: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
39423: LD_INT 35
39425: PPUSH
39426: CALL_OW 67
// until not HasTask ( tmp ) ;
39430: LD_VAR 0 7
39434: PPUSH
39435: CALL_OW 314
39439: NOT
39440: IFFALSE 39423
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
39442: LD_ADDR_EXP 86
39446: PUSH
39447: LD_EXP 86
39451: PPUSH
39452: LD_VAR 0 2
39456: PUSH
39457: LD_EXP 86
39461: PUSH
39462: LD_VAR 0 2
39466: ARRAY
39467: PUSH
39468: LD_INT 1
39470: PLUS
39471: PUSH
39472: EMPTY
39473: LIST
39474: LIST
39475: PPUSH
39476: LD_VAR 0 8
39480: PUSH
39481: LD_VAR 0 3
39485: ARRAY
39486: PPUSH
39487: CALL 54081 0 3
39491: ST_TO_ADDR
// end ;
39492: GO 39150
39494: POP
39495: POP
// MC_Reset ( i , 124 ) ;
39496: LD_VAR 0 2
39500: PPUSH
39501: LD_INT 124
39503: PPUSH
39504: CALL 22580 0 2
// end ; end ;
39508: GO 38905
39510: POP
39511: POP
// end ;
39512: LD_VAR 0 1
39516: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39517: LD_INT 0
39519: PPUSH
39520: PPUSH
39521: PPUSH
// if not mc_bases then
39522: LD_EXP 50
39526: NOT
39527: IFFALSE 39531
// exit ;
39529: GO 40137
// for i = 1 to mc_bases do
39531: LD_ADDR_VAR 0 2
39535: PUSH
39536: DOUBLE
39537: LD_INT 1
39539: DEC
39540: ST_TO_ADDR
39541: LD_EXP 50
39545: PUSH
39546: FOR_TO
39547: IFFALSE 40135
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39549: LD_ADDR_VAR 0 3
39553: PUSH
39554: LD_EXP 50
39558: PUSH
39559: LD_VAR 0 2
39563: ARRAY
39564: PPUSH
39565: LD_INT 25
39567: PUSH
39568: LD_INT 4
39570: PUSH
39571: EMPTY
39572: LIST
39573: LIST
39574: PPUSH
39575: CALL_OW 72
39579: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39580: LD_VAR 0 3
39584: NOT
39585: PUSH
39586: LD_EXP 87
39590: PUSH
39591: LD_VAR 0 2
39595: ARRAY
39596: NOT
39597: OR
39598: PUSH
39599: LD_EXP 50
39603: PUSH
39604: LD_VAR 0 2
39608: ARRAY
39609: PPUSH
39610: LD_INT 2
39612: PUSH
39613: LD_INT 30
39615: PUSH
39616: LD_INT 0
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 30
39625: PUSH
39626: LD_INT 1
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: LIST
39637: PPUSH
39638: CALL_OW 72
39642: NOT
39643: OR
39644: IFFALSE 39694
// begin if mc_deposits_finder [ i ] then
39646: LD_EXP 88
39650: PUSH
39651: LD_VAR 0 2
39655: ARRAY
39656: IFFALSE 39692
// begin MC_Reset ( i , 125 ) ;
39658: LD_VAR 0 2
39662: PPUSH
39663: LD_INT 125
39665: PPUSH
39666: CALL 22580 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39670: LD_ADDR_EXP 88
39674: PUSH
39675: LD_EXP 88
39679: PPUSH
39680: LD_VAR 0 2
39684: PPUSH
39685: EMPTY
39686: PPUSH
39687: CALL_OW 1
39691: ST_TO_ADDR
// end ; continue ;
39692: GO 39546
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39694: LD_EXP 87
39698: PUSH
39699: LD_VAR 0 2
39703: ARRAY
39704: PUSH
39705: LD_INT 1
39707: ARRAY
39708: PUSH
39709: LD_INT 3
39711: ARRAY
39712: PUSH
39713: LD_INT 1
39715: EQUAL
39716: PUSH
39717: LD_INT 20
39719: PPUSH
39720: LD_EXP 76
39724: PUSH
39725: LD_VAR 0 2
39729: ARRAY
39730: PPUSH
39731: CALL_OW 321
39735: PUSH
39736: LD_INT 2
39738: NONEQUAL
39739: AND
39740: IFFALSE 39790
// begin if mc_deposits_finder [ i ] then
39742: LD_EXP 88
39746: PUSH
39747: LD_VAR 0 2
39751: ARRAY
39752: IFFALSE 39788
// begin MC_Reset ( i , 125 ) ;
39754: LD_VAR 0 2
39758: PPUSH
39759: LD_INT 125
39761: PPUSH
39762: CALL 22580 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39766: LD_ADDR_EXP 88
39770: PUSH
39771: LD_EXP 88
39775: PPUSH
39776: LD_VAR 0 2
39780: PPUSH
39781: EMPTY
39782: PPUSH
39783: CALL_OW 1
39787: ST_TO_ADDR
// end ; continue ;
39788: GO 39546
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39790: LD_EXP 87
39794: PUSH
39795: LD_VAR 0 2
39799: ARRAY
39800: PUSH
39801: LD_INT 1
39803: ARRAY
39804: PUSH
39805: LD_INT 1
39807: ARRAY
39808: PPUSH
39809: LD_EXP 87
39813: PUSH
39814: LD_VAR 0 2
39818: ARRAY
39819: PUSH
39820: LD_INT 1
39822: ARRAY
39823: PUSH
39824: LD_INT 2
39826: ARRAY
39827: PPUSH
39828: LD_EXP 76
39832: PUSH
39833: LD_VAR 0 2
39837: ARRAY
39838: PPUSH
39839: CALL_OW 440
39843: IFFALSE 39886
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39845: LD_ADDR_EXP 87
39849: PUSH
39850: LD_EXP 87
39854: PPUSH
39855: LD_VAR 0 2
39859: PPUSH
39860: LD_EXP 87
39864: PUSH
39865: LD_VAR 0 2
39869: ARRAY
39870: PPUSH
39871: LD_INT 1
39873: PPUSH
39874: CALL_OW 3
39878: PPUSH
39879: CALL_OW 1
39883: ST_TO_ADDR
39884: GO 40133
// begin if not mc_deposits_finder [ i ] then
39886: LD_EXP 88
39890: PUSH
39891: LD_VAR 0 2
39895: ARRAY
39896: NOT
39897: IFFALSE 39949
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39899: LD_ADDR_EXP 88
39903: PUSH
39904: LD_EXP 88
39908: PPUSH
39909: LD_VAR 0 2
39913: PPUSH
39914: LD_VAR 0 3
39918: PUSH
39919: LD_INT 1
39921: ARRAY
39922: PUSH
39923: EMPTY
39924: LIST
39925: PPUSH
39926: CALL_OW 1
39930: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39931: LD_VAR 0 3
39935: PUSH
39936: LD_INT 1
39938: ARRAY
39939: PPUSH
39940: LD_INT 125
39942: PPUSH
39943: CALL_OW 109
// end else
39947: GO 40133
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39949: LD_EXP 88
39953: PUSH
39954: LD_VAR 0 2
39958: ARRAY
39959: PUSH
39960: LD_INT 1
39962: ARRAY
39963: PPUSH
39964: CALL_OW 310
39968: IFFALSE 39991
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39970: LD_EXP 88
39974: PUSH
39975: LD_VAR 0 2
39979: ARRAY
39980: PUSH
39981: LD_INT 1
39983: ARRAY
39984: PPUSH
39985: CALL_OW 122
39989: GO 40133
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39991: LD_EXP 88
39995: PUSH
39996: LD_VAR 0 2
40000: ARRAY
40001: PUSH
40002: LD_INT 1
40004: ARRAY
40005: PPUSH
40006: CALL_OW 314
40010: NOT
40011: PUSH
40012: LD_EXP 88
40016: PUSH
40017: LD_VAR 0 2
40021: ARRAY
40022: PUSH
40023: LD_INT 1
40025: ARRAY
40026: PPUSH
40027: LD_EXP 87
40031: PUSH
40032: LD_VAR 0 2
40036: ARRAY
40037: PUSH
40038: LD_INT 1
40040: ARRAY
40041: PUSH
40042: LD_INT 1
40044: ARRAY
40045: PPUSH
40046: LD_EXP 87
40050: PUSH
40051: LD_VAR 0 2
40055: ARRAY
40056: PUSH
40057: LD_INT 1
40059: ARRAY
40060: PUSH
40061: LD_INT 2
40063: ARRAY
40064: PPUSH
40065: CALL_OW 297
40069: PUSH
40070: LD_INT 6
40072: GREATER
40073: AND
40074: IFFALSE 40133
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
40076: LD_EXP 88
40080: PUSH
40081: LD_VAR 0 2
40085: ARRAY
40086: PUSH
40087: LD_INT 1
40089: ARRAY
40090: PPUSH
40091: LD_EXP 87
40095: PUSH
40096: LD_VAR 0 2
40100: ARRAY
40101: PUSH
40102: LD_INT 1
40104: ARRAY
40105: PUSH
40106: LD_INT 1
40108: ARRAY
40109: PPUSH
40110: LD_EXP 87
40114: PUSH
40115: LD_VAR 0 2
40119: ARRAY
40120: PUSH
40121: LD_INT 1
40123: ARRAY
40124: PUSH
40125: LD_INT 2
40127: ARRAY
40128: PPUSH
40129: CALL_OW 111
// end ; end ; end ;
40133: GO 39546
40135: POP
40136: POP
// end ;
40137: LD_VAR 0 1
40141: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40142: LD_INT 0
40144: PPUSH
40145: PPUSH
40146: PPUSH
40147: PPUSH
40148: PPUSH
40149: PPUSH
40150: PPUSH
40151: PPUSH
40152: PPUSH
40153: PPUSH
40154: PPUSH
// if not mc_bases then
40155: LD_EXP 50
40159: NOT
40160: IFFALSE 40164
// exit ;
40162: GO 41104
// for i = 1 to mc_bases do
40164: LD_ADDR_VAR 0 2
40168: PUSH
40169: DOUBLE
40170: LD_INT 1
40172: DEC
40173: ST_TO_ADDR
40174: LD_EXP 50
40178: PUSH
40179: FOR_TO
40180: IFFALSE 41102
// begin if not mc_bases [ i ] or mc_scan [ i ] then
40182: LD_EXP 50
40186: PUSH
40187: LD_VAR 0 2
40191: ARRAY
40192: NOT
40193: PUSH
40194: LD_EXP 73
40198: PUSH
40199: LD_VAR 0 2
40203: ARRAY
40204: OR
40205: IFFALSE 40209
// continue ;
40207: GO 40179
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40209: LD_ADDR_VAR 0 7
40213: PUSH
40214: LD_EXP 50
40218: PUSH
40219: LD_VAR 0 2
40223: ARRAY
40224: PUSH
40225: LD_INT 1
40227: ARRAY
40228: PPUSH
40229: CALL_OW 248
40233: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40234: LD_VAR 0 7
40238: PUSH
40239: LD_INT 3
40241: EQUAL
40242: PUSH
40243: LD_EXP 69
40247: PUSH
40248: LD_VAR 0 2
40252: ARRAY
40253: PUSH
40254: LD_EXP 72
40258: PUSH
40259: LD_VAR 0 2
40263: ARRAY
40264: UNION
40265: PPUSH
40266: LD_INT 33
40268: PUSH
40269: LD_INT 2
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PPUSH
40276: CALL_OW 72
40280: NOT
40281: OR
40282: IFFALSE 40286
// continue ;
40284: GO 40179
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40286: LD_ADDR_VAR 0 9
40290: PUSH
40291: LD_EXP 50
40295: PUSH
40296: LD_VAR 0 2
40300: ARRAY
40301: PPUSH
40302: LD_INT 30
40304: PUSH
40305: LD_INT 36
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PPUSH
40312: CALL_OW 72
40316: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40317: LD_ADDR_VAR 0 10
40321: PUSH
40322: LD_EXP 69
40326: PUSH
40327: LD_VAR 0 2
40331: ARRAY
40332: PPUSH
40333: LD_INT 34
40335: PUSH
40336: LD_INT 31
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: PPUSH
40343: CALL_OW 72
40347: ST_TO_ADDR
// if not cts and not mcts then
40348: LD_VAR 0 9
40352: NOT
40353: PUSH
40354: LD_VAR 0 10
40358: NOT
40359: AND
40360: IFFALSE 40364
// continue ;
40362: GO 40179
// x := cts ;
40364: LD_ADDR_VAR 0 11
40368: PUSH
40369: LD_VAR 0 9
40373: ST_TO_ADDR
// if not x then
40374: LD_VAR 0 11
40378: NOT
40379: IFFALSE 40391
// x := mcts ;
40381: LD_ADDR_VAR 0 11
40385: PUSH
40386: LD_VAR 0 10
40390: ST_TO_ADDR
// if not x then
40391: LD_VAR 0 11
40395: NOT
40396: IFFALSE 40400
// continue ;
40398: GO 40179
// if mc_remote_driver [ i ] then
40400: LD_EXP 90
40404: PUSH
40405: LD_VAR 0 2
40409: ARRAY
40410: IFFALSE 40797
// for j in mc_remote_driver [ i ] do
40412: LD_ADDR_VAR 0 3
40416: PUSH
40417: LD_EXP 90
40421: PUSH
40422: LD_VAR 0 2
40426: ARRAY
40427: PUSH
40428: FOR_IN
40429: IFFALSE 40795
// begin if GetClass ( j ) <> 3 then
40431: LD_VAR 0 3
40435: PPUSH
40436: CALL_OW 257
40440: PUSH
40441: LD_INT 3
40443: NONEQUAL
40444: IFFALSE 40497
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
40446: LD_ADDR_EXP 90
40450: PUSH
40451: LD_EXP 90
40455: PPUSH
40456: LD_VAR 0 2
40460: PPUSH
40461: LD_EXP 90
40465: PUSH
40466: LD_VAR 0 2
40470: ARRAY
40471: PUSH
40472: LD_VAR 0 3
40476: DIFF
40477: PPUSH
40478: CALL_OW 1
40482: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40483: LD_VAR 0 3
40487: PPUSH
40488: LD_INT 0
40490: PPUSH
40491: CALL_OW 109
// continue ;
40495: GO 40428
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40497: LD_EXP 69
40501: PUSH
40502: LD_VAR 0 2
40506: ARRAY
40507: PPUSH
40508: LD_INT 34
40510: PUSH
40511: LD_INT 31
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 58
40520: PUSH
40521: EMPTY
40522: LIST
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PPUSH
40528: CALL_OW 72
40532: PUSH
40533: LD_VAR 0 3
40537: PPUSH
40538: CALL 84425 0 1
40542: NOT
40543: AND
40544: IFFALSE 40615
// begin if IsInUnit ( j ) then
40546: LD_VAR 0 3
40550: PPUSH
40551: CALL_OW 310
40555: IFFALSE 40566
// ComExitBuilding ( j ) ;
40557: LD_VAR 0 3
40561: PPUSH
40562: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40566: LD_VAR 0 3
40570: PPUSH
40571: LD_EXP 69
40575: PUSH
40576: LD_VAR 0 2
40580: ARRAY
40581: PPUSH
40582: LD_INT 34
40584: PUSH
40585: LD_INT 31
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: LD_INT 58
40594: PUSH
40595: EMPTY
40596: LIST
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PPUSH
40602: CALL_OW 72
40606: PUSH
40607: LD_INT 1
40609: ARRAY
40610: PPUSH
40611: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40615: LD_VAR 0 3
40619: PPUSH
40620: CALL_OW 310
40624: NOT
40625: PUSH
40626: LD_VAR 0 3
40630: PPUSH
40631: CALL_OW 310
40635: PPUSH
40636: CALL_OW 266
40640: PUSH
40641: LD_INT 36
40643: NONEQUAL
40644: PUSH
40645: LD_VAR 0 3
40649: PPUSH
40650: CALL 84425 0 1
40654: NOT
40655: AND
40656: OR
40657: IFFALSE 40793
// begin if IsInUnit ( j ) then
40659: LD_VAR 0 3
40663: PPUSH
40664: CALL_OW 310
40668: IFFALSE 40679
// ComExitBuilding ( j ) ;
40670: LD_VAR 0 3
40674: PPUSH
40675: CALL_OW 122
// ct := 0 ;
40679: LD_ADDR_VAR 0 8
40683: PUSH
40684: LD_INT 0
40686: ST_TO_ADDR
// for k in x do
40687: LD_ADDR_VAR 0 4
40691: PUSH
40692: LD_VAR 0 11
40696: PUSH
40697: FOR_IN
40698: IFFALSE 40771
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40700: LD_VAR 0 4
40704: PPUSH
40705: CALL_OW 264
40709: PUSH
40710: LD_INT 31
40712: EQUAL
40713: PUSH
40714: LD_VAR 0 4
40718: PPUSH
40719: CALL_OW 311
40723: NOT
40724: AND
40725: PUSH
40726: LD_VAR 0 4
40730: PPUSH
40731: CALL_OW 266
40735: PUSH
40736: LD_INT 36
40738: EQUAL
40739: PUSH
40740: LD_VAR 0 4
40744: PPUSH
40745: CALL_OW 313
40749: PUSH
40750: LD_INT 3
40752: LESS
40753: AND
40754: OR
40755: IFFALSE 40769
// begin ct := k ;
40757: LD_ADDR_VAR 0 8
40761: PUSH
40762: LD_VAR 0 4
40766: ST_TO_ADDR
// break ;
40767: GO 40771
// end ;
40769: GO 40697
40771: POP
40772: POP
// if ct then
40773: LD_VAR 0 8
40777: IFFALSE 40793
// ComEnterUnit ( j , ct ) ;
40779: LD_VAR 0 3
40783: PPUSH
40784: LD_VAR 0 8
40788: PPUSH
40789: CALL_OW 120
// end ; end ;
40793: GO 40428
40795: POP
40796: POP
// places := 0 ;
40797: LD_ADDR_VAR 0 5
40801: PUSH
40802: LD_INT 0
40804: ST_TO_ADDR
// for j = 1 to x do
40805: LD_ADDR_VAR 0 3
40809: PUSH
40810: DOUBLE
40811: LD_INT 1
40813: DEC
40814: ST_TO_ADDR
40815: LD_VAR 0 11
40819: PUSH
40820: FOR_TO
40821: IFFALSE 40897
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40823: LD_VAR 0 11
40827: PUSH
40828: LD_VAR 0 3
40832: ARRAY
40833: PPUSH
40834: CALL_OW 264
40838: PUSH
40839: LD_INT 31
40841: EQUAL
40842: IFFALSE 40860
// places := places + 1 else
40844: LD_ADDR_VAR 0 5
40848: PUSH
40849: LD_VAR 0 5
40853: PUSH
40854: LD_INT 1
40856: PLUS
40857: ST_TO_ADDR
40858: GO 40895
// if GetBType ( x [ j ] ) = b_control_tower then
40860: LD_VAR 0 11
40864: PUSH
40865: LD_VAR 0 3
40869: ARRAY
40870: PPUSH
40871: CALL_OW 266
40875: PUSH
40876: LD_INT 36
40878: EQUAL
40879: IFFALSE 40895
// places := places + 3 ;
40881: LD_ADDR_VAR 0 5
40885: PUSH
40886: LD_VAR 0 5
40890: PUSH
40891: LD_INT 3
40893: PLUS
40894: ST_TO_ADDR
40895: GO 40820
40897: POP
40898: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40899: LD_VAR 0 5
40903: PUSH
40904: LD_INT 0
40906: EQUAL
40907: PUSH
40908: LD_VAR 0 5
40912: PUSH
40913: LD_EXP 90
40917: PUSH
40918: LD_VAR 0 2
40922: ARRAY
40923: LESSEQUAL
40924: OR
40925: IFFALSE 40929
// continue ;
40927: GO 40179
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40929: LD_ADDR_VAR 0 6
40933: PUSH
40934: LD_EXP 50
40938: PUSH
40939: LD_VAR 0 2
40943: ARRAY
40944: PPUSH
40945: LD_INT 25
40947: PUSH
40948: LD_INT 3
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PPUSH
40955: CALL_OW 72
40959: PUSH
40960: LD_EXP 90
40964: PUSH
40965: LD_VAR 0 2
40969: ARRAY
40970: DIFF
40971: PPUSH
40972: LD_INT 3
40974: PPUSH
40975: CALL 85325 0 2
40979: ST_TO_ADDR
// for j in tmp do
40980: LD_ADDR_VAR 0 3
40984: PUSH
40985: LD_VAR 0 6
40989: PUSH
40990: FOR_IN
40991: IFFALSE 41026
// if GetTag ( j ) > 0 then
40993: LD_VAR 0 3
40997: PPUSH
40998: CALL_OW 110
41002: PUSH
41003: LD_INT 0
41005: GREATER
41006: IFFALSE 41024
// tmp := tmp diff j ;
41008: LD_ADDR_VAR 0 6
41012: PUSH
41013: LD_VAR 0 6
41017: PUSH
41018: LD_VAR 0 3
41022: DIFF
41023: ST_TO_ADDR
41024: GO 40990
41026: POP
41027: POP
// if not tmp then
41028: LD_VAR 0 6
41032: NOT
41033: IFFALSE 41037
// continue ;
41035: GO 40179
// if places then
41037: LD_VAR 0 5
41041: IFFALSE 41100
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
41043: LD_ADDR_EXP 90
41047: PUSH
41048: LD_EXP 90
41052: PPUSH
41053: LD_VAR 0 2
41057: PPUSH
41058: LD_EXP 90
41062: PUSH
41063: LD_VAR 0 2
41067: ARRAY
41068: PUSH
41069: LD_VAR 0 6
41073: PUSH
41074: LD_INT 1
41076: ARRAY
41077: UNION
41078: PPUSH
41079: CALL_OW 1
41083: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
41084: LD_VAR 0 6
41088: PUSH
41089: LD_INT 1
41091: ARRAY
41092: PPUSH
41093: LD_INT 126
41095: PPUSH
41096: CALL_OW 109
// end ; end ;
41100: GO 40179
41102: POP
41103: POP
// end ;
41104: LD_VAR 0 1
41108: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
41109: LD_INT 0
41111: PPUSH
41112: PPUSH
41113: PPUSH
41114: PPUSH
41115: PPUSH
41116: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41117: LD_VAR 0 1
41121: NOT
41122: PUSH
41123: LD_VAR 0 2
41127: NOT
41128: OR
41129: PUSH
41130: LD_VAR 0 3
41134: NOT
41135: OR
41136: PUSH
41137: LD_VAR 0 4
41141: PUSH
41142: LD_INT 1
41144: PUSH
41145: LD_INT 2
41147: PUSH
41148: LD_INT 3
41150: PUSH
41151: LD_INT 4
41153: PUSH
41154: LD_INT 5
41156: PUSH
41157: LD_INT 8
41159: PUSH
41160: LD_INT 9
41162: PUSH
41163: LD_INT 15
41165: PUSH
41166: LD_INT 16
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: LIST
41173: LIST
41174: LIST
41175: LIST
41176: LIST
41177: LIST
41178: LIST
41179: IN
41180: NOT
41181: OR
41182: IFFALSE 41186
// exit ;
41184: GO 42044
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41186: LD_ADDR_VAR 0 2
41190: PUSH
41191: LD_VAR 0 2
41195: PPUSH
41196: LD_INT 21
41198: PUSH
41199: LD_INT 3
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 24
41208: PUSH
41209: LD_INT 250
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: EMPTY
41217: LIST
41218: LIST
41219: PPUSH
41220: CALL_OW 72
41224: ST_TO_ADDR
// case class of 1 , 15 :
41225: LD_VAR 0 4
41229: PUSH
41230: LD_INT 1
41232: DOUBLE
41233: EQUAL
41234: IFTRUE 41244
41236: LD_INT 15
41238: DOUBLE
41239: EQUAL
41240: IFTRUE 41244
41242: GO 41329
41244: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41245: LD_ADDR_VAR 0 8
41249: PUSH
41250: LD_VAR 0 2
41254: PPUSH
41255: LD_INT 2
41257: PUSH
41258: LD_INT 30
41260: PUSH
41261: LD_INT 32
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 30
41270: PUSH
41271: LD_INT 31
41273: PUSH
41274: EMPTY
41275: LIST
41276: LIST
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: LIST
41282: PPUSH
41283: CALL_OW 72
41287: PUSH
41288: LD_VAR 0 2
41292: PPUSH
41293: LD_INT 2
41295: PUSH
41296: LD_INT 30
41298: PUSH
41299: LD_INT 4
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: PUSH
41306: LD_INT 30
41308: PUSH
41309: LD_INT 5
41311: PUSH
41312: EMPTY
41313: LIST
41314: LIST
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: LIST
41320: PPUSH
41321: CALL_OW 72
41325: ADD
41326: ST_TO_ADDR
41327: GO 41575
41329: LD_INT 2
41331: DOUBLE
41332: EQUAL
41333: IFTRUE 41343
41335: LD_INT 16
41337: DOUBLE
41338: EQUAL
41339: IFTRUE 41343
41341: GO 41389
41343: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41344: LD_ADDR_VAR 0 8
41348: PUSH
41349: LD_VAR 0 2
41353: PPUSH
41354: LD_INT 2
41356: PUSH
41357: LD_INT 30
41359: PUSH
41360: LD_INT 0
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: PUSH
41367: LD_INT 30
41369: PUSH
41370: LD_INT 1
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: LIST
41381: PPUSH
41382: CALL_OW 72
41386: ST_TO_ADDR
41387: GO 41575
41389: LD_INT 3
41391: DOUBLE
41392: EQUAL
41393: IFTRUE 41397
41395: GO 41443
41397: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41398: LD_ADDR_VAR 0 8
41402: PUSH
41403: LD_VAR 0 2
41407: PPUSH
41408: LD_INT 2
41410: PUSH
41411: LD_INT 30
41413: PUSH
41414: LD_INT 2
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: PUSH
41421: LD_INT 30
41423: PUSH
41424: LD_INT 3
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: EMPTY
41432: LIST
41433: LIST
41434: LIST
41435: PPUSH
41436: CALL_OW 72
41440: ST_TO_ADDR
41441: GO 41575
41443: LD_INT 4
41445: DOUBLE
41446: EQUAL
41447: IFTRUE 41451
41449: GO 41508
41451: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41452: LD_ADDR_VAR 0 8
41456: PUSH
41457: LD_VAR 0 2
41461: PPUSH
41462: LD_INT 2
41464: PUSH
41465: LD_INT 30
41467: PUSH
41468: LD_INT 6
41470: PUSH
41471: EMPTY
41472: LIST
41473: LIST
41474: PUSH
41475: LD_INT 30
41477: PUSH
41478: LD_INT 7
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: PUSH
41485: LD_INT 30
41487: PUSH
41488: LD_INT 8
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: LIST
41499: LIST
41500: PPUSH
41501: CALL_OW 72
41505: ST_TO_ADDR
41506: GO 41575
41508: LD_INT 5
41510: DOUBLE
41511: EQUAL
41512: IFTRUE 41528
41514: LD_INT 8
41516: DOUBLE
41517: EQUAL
41518: IFTRUE 41528
41520: LD_INT 9
41522: DOUBLE
41523: EQUAL
41524: IFTRUE 41528
41526: GO 41574
41528: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41529: LD_ADDR_VAR 0 8
41533: PUSH
41534: LD_VAR 0 2
41538: PPUSH
41539: LD_INT 2
41541: PUSH
41542: LD_INT 30
41544: PUSH
41545: LD_INT 4
41547: PUSH
41548: EMPTY
41549: LIST
41550: LIST
41551: PUSH
41552: LD_INT 30
41554: PUSH
41555: LD_INT 5
41557: PUSH
41558: EMPTY
41559: LIST
41560: LIST
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: LIST
41566: PPUSH
41567: CALL_OW 72
41571: ST_TO_ADDR
41572: GO 41575
41574: POP
// if not tmp then
41575: LD_VAR 0 8
41579: NOT
41580: IFFALSE 41584
// exit ;
41582: GO 42044
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41584: LD_VAR 0 4
41588: PUSH
41589: LD_INT 1
41591: PUSH
41592: LD_INT 15
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: IN
41599: PUSH
41600: LD_EXP 59
41604: PUSH
41605: LD_VAR 0 1
41609: ARRAY
41610: AND
41611: IFFALSE 41767
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41613: LD_ADDR_VAR 0 9
41617: PUSH
41618: LD_EXP 59
41622: PUSH
41623: LD_VAR 0 1
41627: ARRAY
41628: PUSH
41629: LD_INT 1
41631: ARRAY
41632: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41633: LD_VAR 0 9
41637: PUSH
41638: LD_EXP 60
41642: PUSH
41643: LD_VAR 0 1
41647: ARRAY
41648: IN
41649: NOT
41650: IFFALSE 41765
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41652: LD_ADDR_EXP 60
41656: PUSH
41657: LD_EXP 60
41661: PPUSH
41662: LD_VAR 0 1
41666: PUSH
41667: LD_EXP 60
41671: PUSH
41672: LD_VAR 0 1
41676: ARRAY
41677: PUSH
41678: LD_INT 1
41680: PLUS
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PPUSH
41686: LD_VAR 0 9
41690: PPUSH
41691: CALL 54081 0 3
41695: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41696: LD_ADDR_EXP 59
41700: PUSH
41701: LD_EXP 59
41705: PPUSH
41706: LD_VAR 0 1
41710: PPUSH
41711: LD_EXP 59
41715: PUSH
41716: LD_VAR 0 1
41720: ARRAY
41721: PUSH
41722: LD_VAR 0 9
41726: DIFF
41727: PPUSH
41728: CALL_OW 1
41732: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41733: LD_VAR 0 3
41737: PPUSH
41738: LD_EXP 60
41742: PUSH
41743: LD_VAR 0 1
41747: ARRAY
41748: PUSH
41749: LD_EXP 60
41753: PUSH
41754: LD_VAR 0 1
41758: ARRAY
41759: ARRAY
41760: PPUSH
41761: CALL_OW 120
// end ; exit ;
41765: GO 42044
// end ; if tmp > 1 then
41767: LD_VAR 0 8
41771: PUSH
41772: LD_INT 1
41774: GREATER
41775: IFFALSE 41879
// for i = 2 to tmp do
41777: LD_ADDR_VAR 0 6
41781: PUSH
41782: DOUBLE
41783: LD_INT 2
41785: DEC
41786: ST_TO_ADDR
41787: LD_VAR 0 8
41791: PUSH
41792: FOR_TO
41793: IFFALSE 41877
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41795: LD_VAR 0 8
41799: PUSH
41800: LD_VAR 0 6
41804: ARRAY
41805: PPUSH
41806: CALL_OW 461
41810: PUSH
41811: LD_INT 6
41813: EQUAL
41814: IFFALSE 41875
// begin x := tmp [ i ] ;
41816: LD_ADDR_VAR 0 9
41820: PUSH
41821: LD_VAR 0 8
41825: PUSH
41826: LD_VAR 0 6
41830: ARRAY
41831: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41832: LD_ADDR_VAR 0 8
41836: PUSH
41837: LD_VAR 0 8
41841: PPUSH
41842: LD_VAR 0 6
41846: PPUSH
41847: CALL_OW 3
41851: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41852: LD_ADDR_VAR 0 8
41856: PUSH
41857: LD_VAR 0 8
41861: PPUSH
41862: LD_INT 1
41864: PPUSH
41865: LD_VAR 0 9
41869: PPUSH
41870: CALL_OW 2
41874: ST_TO_ADDR
// end ;
41875: GO 41792
41877: POP
41878: POP
// for i in tmp do
41879: LD_ADDR_VAR 0 6
41883: PUSH
41884: LD_VAR 0 8
41888: PUSH
41889: FOR_IN
41890: IFFALSE 41917
// begin if IsNotFull ( i ) then
41892: LD_VAR 0 6
41896: PPUSH
41897: CALL 51303 0 1
41901: IFFALSE 41915
// begin j := i ;
41903: LD_ADDR_VAR 0 7
41907: PUSH
41908: LD_VAR 0 6
41912: ST_TO_ADDR
// break ;
41913: GO 41917
// end ; end ;
41915: GO 41889
41917: POP
41918: POP
// if j then
41919: LD_VAR 0 7
41923: IFFALSE 41941
// ComEnterUnit ( unit , j ) else
41925: LD_VAR 0 3
41929: PPUSH
41930: LD_VAR 0 7
41934: PPUSH
41935: CALL_OW 120
41939: GO 42044
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41941: LD_ADDR_VAR 0 10
41945: PUSH
41946: LD_VAR 0 2
41950: PPUSH
41951: LD_INT 2
41953: PUSH
41954: LD_INT 30
41956: PUSH
41957: LD_INT 0
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: LD_INT 30
41966: PUSH
41967: LD_INT 1
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: EMPTY
41975: LIST
41976: LIST
41977: LIST
41978: PPUSH
41979: CALL_OW 72
41983: ST_TO_ADDR
// if depot then
41984: LD_VAR 0 10
41988: IFFALSE 42044
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41990: LD_ADDR_VAR 0 10
41994: PUSH
41995: LD_VAR 0 10
41999: PPUSH
42000: LD_VAR 0 3
42004: PPUSH
42005: CALL_OW 74
42009: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
42010: LD_VAR 0 3
42014: PPUSH
42015: LD_VAR 0 10
42019: PPUSH
42020: CALL_OW 296
42024: PUSH
42025: LD_INT 10
42027: GREATER
42028: IFFALSE 42044
// ComStandNearbyBuilding ( unit , depot ) ;
42030: LD_VAR 0 3
42034: PPUSH
42035: LD_VAR 0 10
42039: PPUSH
42040: CALL 50683 0 2
// end ; end ; end ;
42044: LD_VAR 0 5
42048: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
42049: LD_INT 0
42051: PPUSH
42052: PPUSH
42053: PPUSH
42054: PPUSH
// if not mc_bases then
42055: LD_EXP 50
42059: NOT
42060: IFFALSE 42064
// exit ;
42062: GO 42303
// for i = 1 to mc_bases do
42064: LD_ADDR_VAR 0 2
42068: PUSH
42069: DOUBLE
42070: LD_INT 1
42072: DEC
42073: ST_TO_ADDR
42074: LD_EXP 50
42078: PUSH
42079: FOR_TO
42080: IFFALSE 42301
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42082: LD_ADDR_VAR 0 4
42086: PUSH
42087: LD_EXP 50
42091: PUSH
42092: LD_VAR 0 2
42096: ARRAY
42097: PPUSH
42098: LD_INT 21
42100: PUSH
42101: LD_INT 1
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PPUSH
42108: CALL_OW 72
42112: PUSH
42113: LD_EXP 79
42117: PUSH
42118: LD_VAR 0 2
42122: ARRAY
42123: UNION
42124: ST_TO_ADDR
// if not tmp then
42125: LD_VAR 0 4
42129: NOT
42130: IFFALSE 42134
// continue ;
42132: GO 42079
// for j in tmp do
42134: LD_ADDR_VAR 0 3
42138: PUSH
42139: LD_VAR 0 4
42143: PUSH
42144: FOR_IN
42145: IFFALSE 42297
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42147: LD_VAR 0 3
42151: PPUSH
42152: CALL_OW 110
42156: NOT
42157: PUSH
42158: LD_VAR 0 3
42162: PPUSH
42163: CALL_OW 314
42167: NOT
42168: AND
42169: PUSH
42170: LD_VAR 0 3
42174: PPUSH
42175: CALL_OW 311
42179: NOT
42180: AND
42181: PUSH
42182: LD_VAR 0 3
42186: PPUSH
42187: CALL_OW 310
42191: NOT
42192: AND
42193: PUSH
42194: LD_VAR 0 3
42198: PUSH
42199: LD_EXP 53
42203: PUSH
42204: LD_VAR 0 2
42208: ARRAY
42209: PUSH
42210: LD_INT 1
42212: ARRAY
42213: IN
42214: NOT
42215: AND
42216: PUSH
42217: LD_VAR 0 3
42221: PUSH
42222: LD_EXP 53
42226: PUSH
42227: LD_VAR 0 2
42231: ARRAY
42232: PUSH
42233: LD_INT 2
42235: ARRAY
42236: IN
42237: NOT
42238: AND
42239: PUSH
42240: LD_VAR 0 3
42244: PUSH
42245: LD_EXP 62
42249: PUSH
42250: LD_VAR 0 2
42254: ARRAY
42255: IN
42256: NOT
42257: AND
42258: IFFALSE 42295
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42260: LD_VAR 0 2
42264: PPUSH
42265: LD_EXP 50
42269: PUSH
42270: LD_VAR 0 2
42274: ARRAY
42275: PPUSH
42276: LD_VAR 0 3
42280: PPUSH
42281: LD_VAR 0 3
42285: PPUSH
42286: CALL_OW 257
42290: PPUSH
42291: CALL 41109 0 4
// end ;
42295: GO 42144
42297: POP
42298: POP
// end ;
42299: GO 42079
42301: POP
42302: POP
// end ;
42303: LD_VAR 0 1
42307: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
42308: LD_INT 0
42310: PPUSH
42311: PPUSH
42312: PPUSH
42313: PPUSH
42314: PPUSH
42315: PPUSH
// if not mc_bases [ base ] then
42316: LD_EXP 50
42320: PUSH
42321: LD_VAR 0 1
42325: ARRAY
42326: NOT
42327: IFFALSE 42331
// exit ;
42329: GO 42532
// tmp := [ ] ;
42331: LD_ADDR_VAR 0 6
42335: PUSH
42336: EMPTY
42337: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42338: LD_ADDR_VAR 0 7
42342: PUSH
42343: LD_VAR 0 3
42347: PPUSH
42348: LD_INT 0
42350: PPUSH
42351: CALL_OW 517
42355: ST_TO_ADDR
// if not list then
42356: LD_VAR 0 7
42360: NOT
42361: IFFALSE 42365
// exit ;
42363: GO 42532
// c := Count ( list [ 1 ] ) ;
42365: LD_ADDR_VAR 0 9
42369: PUSH
42370: LD_VAR 0 7
42374: PUSH
42375: LD_INT 1
42377: ARRAY
42378: PPUSH
42379: CALL 51221 0 1
42383: ST_TO_ADDR
// if amount > c then
42384: LD_VAR 0 2
42388: PUSH
42389: LD_VAR 0 9
42393: GREATER
42394: IFFALSE 42406
// amount := c ;
42396: LD_ADDR_VAR 0 2
42400: PUSH
42401: LD_VAR 0 9
42405: ST_TO_ADDR
// for i := 1 to amount do
42406: LD_ADDR_VAR 0 5
42410: PUSH
42411: DOUBLE
42412: LD_INT 1
42414: DEC
42415: ST_TO_ADDR
42416: LD_VAR 0 2
42420: PUSH
42421: FOR_TO
42422: IFFALSE 42480
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
42424: LD_ADDR_VAR 0 6
42428: PUSH
42429: LD_VAR 0 6
42433: PPUSH
42434: LD_VAR 0 5
42438: PPUSH
42439: LD_VAR 0 7
42443: PUSH
42444: LD_INT 1
42446: ARRAY
42447: PUSH
42448: LD_VAR 0 5
42452: ARRAY
42453: PUSH
42454: LD_VAR 0 7
42458: PUSH
42459: LD_INT 2
42461: ARRAY
42462: PUSH
42463: LD_VAR 0 5
42467: ARRAY
42468: PUSH
42469: EMPTY
42470: LIST
42471: LIST
42472: PPUSH
42473: CALL_OW 1
42477: ST_TO_ADDR
42478: GO 42421
42480: POP
42481: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42482: LD_ADDR_EXP 63
42486: PUSH
42487: LD_EXP 63
42491: PPUSH
42492: LD_VAR 0 1
42496: PPUSH
42497: LD_VAR 0 6
42501: PPUSH
42502: CALL_OW 1
42506: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42507: LD_ADDR_EXP 65
42511: PUSH
42512: LD_EXP 65
42516: PPUSH
42517: LD_VAR 0 1
42521: PPUSH
42522: LD_VAR 0 3
42526: PPUSH
42527: CALL_OW 1
42531: ST_TO_ADDR
// end ;
42532: LD_VAR 0 4
42536: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42537: LD_INT 0
42539: PPUSH
// if not mc_bases [ base ] then
42540: LD_EXP 50
42544: PUSH
42545: LD_VAR 0 1
42549: ARRAY
42550: NOT
42551: IFFALSE 42555
// exit ;
42553: GO 42580
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42555: LD_ADDR_EXP 55
42559: PUSH
42560: LD_EXP 55
42564: PPUSH
42565: LD_VAR 0 1
42569: PPUSH
42570: LD_VAR 0 2
42574: PPUSH
42575: CALL_OW 1
42579: ST_TO_ADDR
// end ;
42580: LD_VAR 0 3
42584: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42585: LD_INT 0
42587: PPUSH
// if not mc_bases [ base ] then
42588: LD_EXP 50
42592: PUSH
42593: LD_VAR 0 1
42597: ARRAY
42598: NOT
42599: IFFALSE 42603
// exit ;
42601: GO 42640
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42603: LD_ADDR_EXP 55
42607: PUSH
42608: LD_EXP 55
42612: PPUSH
42613: LD_VAR 0 1
42617: PPUSH
42618: LD_EXP 55
42622: PUSH
42623: LD_VAR 0 1
42627: ARRAY
42628: PUSH
42629: LD_VAR 0 2
42633: UNION
42634: PPUSH
42635: CALL_OW 1
42639: ST_TO_ADDR
// end ;
42640: LD_VAR 0 3
42644: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42645: LD_INT 0
42647: PPUSH
// if not mc_bases [ base ] then
42648: LD_EXP 50
42652: PUSH
42653: LD_VAR 0 1
42657: ARRAY
42658: NOT
42659: IFFALSE 42663
// exit ;
42661: GO 42688
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42663: LD_ADDR_EXP 71
42667: PUSH
42668: LD_EXP 71
42672: PPUSH
42673: LD_VAR 0 1
42677: PPUSH
42678: LD_VAR 0 2
42682: PPUSH
42683: CALL_OW 1
42687: ST_TO_ADDR
// end ;
42688: LD_VAR 0 3
42692: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42693: LD_INT 0
42695: PPUSH
// if not mc_bases [ base ] then
42696: LD_EXP 50
42700: PUSH
42701: LD_VAR 0 1
42705: ARRAY
42706: NOT
42707: IFFALSE 42711
// exit ;
42709: GO 42748
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42711: LD_ADDR_EXP 71
42715: PUSH
42716: LD_EXP 71
42720: PPUSH
42721: LD_VAR 0 1
42725: PPUSH
42726: LD_EXP 71
42730: PUSH
42731: LD_VAR 0 1
42735: ARRAY
42736: PUSH
42737: LD_VAR 0 2
42741: ADD
42742: PPUSH
42743: CALL_OW 1
42747: ST_TO_ADDR
// end ;
42748: LD_VAR 0 3
42752: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42753: LD_INT 0
42755: PPUSH
// if not mc_bases [ base ] then
42756: LD_EXP 50
42760: PUSH
42761: LD_VAR 0 1
42765: ARRAY
42766: NOT
42767: IFFALSE 42771
// exit ;
42769: GO 42825
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42771: LD_ADDR_EXP 72
42775: PUSH
42776: LD_EXP 72
42780: PPUSH
42781: LD_VAR 0 1
42785: PPUSH
42786: LD_VAR 0 2
42790: PPUSH
42791: CALL_OW 1
42795: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42796: LD_ADDR_EXP 61
42800: PUSH
42801: LD_EXP 61
42805: PPUSH
42806: LD_VAR 0 1
42810: PPUSH
42811: LD_VAR 0 2
42815: PUSH
42816: LD_INT 0
42818: PLUS
42819: PPUSH
42820: CALL_OW 1
42824: ST_TO_ADDR
// end ;
42825: LD_VAR 0 3
42829: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42830: LD_INT 0
42832: PPUSH
// if not mc_bases [ base ] then
42833: LD_EXP 50
42837: PUSH
42838: LD_VAR 0 1
42842: ARRAY
42843: NOT
42844: IFFALSE 42848
// exit ;
42846: GO 42873
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42848: LD_ADDR_EXP 61
42852: PUSH
42853: LD_EXP 61
42857: PPUSH
42858: LD_VAR 0 1
42862: PPUSH
42863: LD_VAR 0 2
42867: PPUSH
42868: CALL_OW 1
42872: ST_TO_ADDR
// end ;
42873: LD_VAR 0 3
42877: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42878: LD_INT 0
42880: PPUSH
42881: PPUSH
42882: PPUSH
42883: PPUSH
// if not mc_bases [ base ] then
42884: LD_EXP 50
42888: PUSH
42889: LD_VAR 0 1
42893: ARRAY
42894: NOT
42895: IFFALSE 42899
// exit ;
42897: GO 42964
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42899: LD_ADDR_EXP 70
42903: PUSH
42904: LD_EXP 70
42908: PPUSH
42909: LD_VAR 0 1
42913: PUSH
42914: LD_EXP 70
42918: PUSH
42919: LD_VAR 0 1
42923: ARRAY
42924: PUSH
42925: LD_INT 1
42927: PLUS
42928: PUSH
42929: EMPTY
42930: LIST
42931: LIST
42932: PPUSH
42933: LD_VAR 0 1
42937: PUSH
42938: LD_VAR 0 2
42942: PUSH
42943: LD_VAR 0 3
42947: PUSH
42948: LD_VAR 0 4
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: LIST
42957: LIST
42958: PPUSH
42959: CALL 54081 0 3
42963: ST_TO_ADDR
// end ;
42964: LD_VAR 0 5
42968: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42969: LD_INT 0
42971: PPUSH
// if not mc_bases [ base ] then
42972: LD_EXP 50
42976: PUSH
42977: LD_VAR 0 1
42981: ARRAY
42982: NOT
42983: IFFALSE 42987
// exit ;
42985: GO 43012
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42987: LD_ADDR_EXP 87
42991: PUSH
42992: LD_EXP 87
42996: PPUSH
42997: LD_VAR 0 1
43001: PPUSH
43002: LD_VAR 0 2
43006: PPUSH
43007: CALL_OW 1
43011: ST_TO_ADDR
// end ;
43012: LD_VAR 0 3
43016: RET
// export function MC_GetMinesField ( base ) ; begin
43017: LD_INT 0
43019: PPUSH
// result := mc_mines [ base ] ;
43020: LD_ADDR_VAR 0 2
43024: PUSH
43025: LD_EXP 63
43029: PUSH
43030: LD_VAR 0 1
43034: ARRAY
43035: ST_TO_ADDR
// end ;
43036: LD_VAR 0 2
43040: RET
// export function MC_GetProduceList ( base ) ; begin
43041: LD_INT 0
43043: PPUSH
// result := mc_produce [ base ] ;
43044: LD_ADDR_VAR 0 2
43048: PUSH
43049: LD_EXP 71
43053: PUSH
43054: LD_VAR 0 1
43058: ARRAY
43059: ST_TO_ADDR
// end ;
43060: LD_VAR 0 2
43064: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
43065: LD_INT 0
43067: PPUSH
43068: PPUSH
// if not mc_bases then
43069: LD_EXP 50
43073: NOT
43074: IFFALSE 43078
// exit ;
43076: GO 43143
// if mc_bases [ base ] then
43078: LD_EXP 50
43082: PUSH
43083: LD_VAR 0 1
43087: ARRAY
43088: IFFALSE 43143
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43090: LD_ADDR_VAR 0 3
43094: PUSH
43095: LD_EXP 50
43099: PUSH
43100: LD_VAR 0 1
43104: ARRAY
43105: PPUSH
43106: LD_INT 30
43108: PUSH
43109: LD_VAR 0 2
43113: PUSH
43114: EMPTY
43115: LIST
43116: LIST
43117: PPUSH
43118: CALL_OW 72
43122: ST_TO_ADDR
// if result then
43123: LD_VAR 0 3
43127: IFFALSE 43143
// result := result [ 1 ] ;
43129: LD_ADDR_VAR 0 3
43133: PUSH
43134: LD_VAR 0 3
43138: PUSH
43139: LD_INT 1
43141: ARRAY
43142: ST_TO_ADDR
// end ; end ;
43143: LD_VAR 0 3
43147: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43148: LD_INT 0
43150: PPUSH
43151: PPUSH
// if not mc_bases then
43152: LD_EXP 50
43156: NOT
43157: IFFALSE 43161
// exit ;
43159: GO 43206
// if mc_bases [ base ] then
43161: LD_EXP 50
43165: PUSH
43166: LD_VAR 0 1
43170: ARRAY
43171: IFFALSE 43206
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43173: LD_ADDR_VAR 0 3
43177: PUSH
43178: LD_EXP 50
43182: PUSH
43183: LD_VAR 0 1
43187: ARRAY
43188: PPUSH
43189: LD_INT 30
43191: PUSH
43192: LD_VAR 0 2
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PPUSH
43201: CALL_OW 72
43205: ST_TO_ADDR
// end ;
43206: LD_VAR 0 3
43210: RET
// export function MC_SetTame ( base , area ) ; begin
43211: LD_INT 0
43213: PPUSH
// if not mc_bases or not base then
43214: LD_EXP 50
43218: NOT
43219: PUSH
43220: LD_VAR 0 1
43224: NOT
43225: OR
43226: IFFALSE 43230
// exit ;
43228: GO 43255
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43230: LD_ADDR_EXP 78
43234: PUSH
43235: LD_EXP 78
43239: PPUSH
43240: LD_VAR 0 1
43244: PPUSH
43245: LD_VAR 0 2
43249: PPUSH
43250: CALL_OW 1
43254: ST_TO_ADDR
// end ;
43255: LD_VAR 0 3
43259: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43260: LD_INT 0
43262: PPUSH
43263: PPUSH
// if not mc_bases or not base then
43264: LD_EXP 50
43268: NOT
43269: PUSH
43270: LD_VAR 0 1
43274: NOT
43275: OR
43276: IFFALSE 43280
// exit ;
43278: GO 43382
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43280: LD_ADDR_VAR 0 4
43284: PUSH
43285: LD_EXP 50
43289: PUSH
43290: LD_VAR 0 1
43294: ARRAY
43295: PPUSH
43296: LD_INT 30
43298: PUSH
43299: LD_VAR 0 2
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PPUSH
43308: CALL_OW 72
43312: ST_TO_ADDR
// if not tmp then
43313: LD_VAR 0 4
43317: NOT
43318: IFFALSE 43322
// exit ;
43320: GO 43382
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43322: LD_ADDR_EXP 82
43326: PUSH
43327: LD_EXP 82
43331: PPUSH
43332: LD_VAR 0 1
43336: PPUSH
43337: LD_EXP 82
43341: PUSH
43342: LD_VAR 0 1
43346: ARRAY
43347: PPUSH
43348: LD_EXP 82
43352: PUSH
43353: LD_VAR 0 1
43357: ARRAY
43358: PUSH
43359: LD_INT 1
43361: PLUS
43362: PPUSH
43363: LD_VAR 0 4
43367: PUSH
43368: LD_INT 1
43370: ARRAY
43371: PPUSH
43372: CALL_OW 2
43376: PPUSH
43377: CALL_OW 1
43381: ST_TO_ADDR
// end ;
43382: LD_VAR 0 3
43386: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43387: LD_INT 0
43389: PPUSH
43390: PPUSH
// if not mc_bases or not base or not kinds then
43391: LD_EXP 50
43395: NOT
43396: PUSH
43397: LD_VAR 0 1
43401: NOT
43402: OR
43403: PUSH
43404: LD_VAR 0 2
43408: NOT
43409: OR
43410: IFFALSE 43414
// exit ;
43412: GO 43475
// for i in kinds do
43414: LD_ADDR_VAR 0 4
43418: PUSH
43419: LD_VAR 0 2
43423: PUSH
43424: FOR_IN
43425: IFFALSE 43473
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43427: LD_ADDR_EXP 84
43431: PUSH
43432: LD_EXP 84
43436: PPUSH
43437: LD_VAR 0 1
43441: PUSH
43442: LD_EXP 84
43446: PUSH
43447: LD_VAR 0 1
43451: ARRAY
43452: PUSH
43453: LD_INT 1
43455: PLUS
43456: PUSH
43457: EMPTY
43458: LIST
43459: LIST
43460: PPUSH
43461: LD_VAR 0 4
43465: PPUSH
43466: CALL 54081 0 3
43470: ST_TO_ADDR
43471: GO 43424
43473: POP
43474: POP
// end ;
43475: LD_VAR 0 3
43479: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43480: LD_INT 0
43482: PPUSH
// if not mc_bases or not base or not areas then
43483: LD_EXP 50
43487: NOT
43488: PUSH
43489: LD_VAR 0 1
43493: NOT
43494: OR
43495: PUSH
43496: LD_VAR 0 2
43500: NOT
43501: OR
43502: IFFALSE 43506
// exit ;
43504: GO 43531
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43506: LD_ADDR_EXP 68
43510: PUSH
43511: LD_EXP 68
43515: PPUSH
43516: LD_VAR 0 1
43520: PPUSH
43521: LD_VAR 0 2
43525: PPUSH
43526: CALL_OW 1
43530: ST_TO_ADDR
// end ;
43531: LD_VAR 0 3
43535: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43536: LD_INT 0
43538: PPUSH
// if not mc_bases or not base or not teleports_exit then
43539: LD_EXP 50
43543: NOT
43544: PUSH
43545: LD_VAR 0 1
43549: NOT
43550: OR
43551: PUSH
43552: LD_VAR 0 2
43556: NOT
43557: OR
43558: IFFALSE 43562
// exit ;
43560: GO 43587
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43562: LD_ADDR_EXP 85
43566: PUSH
43567: LD_EXP 85
43571: PPUSH
43572: LD_VAR 0 1
43576: PPUSH
43577: LD_VAR 0 2
43581: PPUSH
43582: CALL_OW 1
43586: ST_TO_ADDR
// end ;
43587: LD_VAR 0 3
43591: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43592: LD_INT 0
43594: PPUSH
43595: PPUSH
43596: PPUSH
// if not mc_bases or not base or not ext_list then
43597: LD_EXP 50
43601: NOT
43602: PUSH
43603: LD_VAR 0 1
43607: NOT
43608: OR
43609: PUSH
43610: LD_VAR 0 5
43614: NOT
43615: OR
43616: IFFALSE 43620
// exit ;
43618: GO 43793
// tmp := GetFacExtXYD ( x , y , d ) ;
43620: LD_ADDR_VAR 0 8
43624: PUSH
43625: LD_VAR 0 2
43629: PPUSH
43630: LD_VAR 0 3
43634: PPUSH
43635: LD_VAR 0 4
43639: PPUSH
43640: CALL 84455 0 3
43644: ST_TO_ADDR
// if not tmp then
43645: LD_VAR 0 8
43649: NOT
43650: IFFALSE 43654
// exit ;
43652: GO 43793
// for i in tmp do
43654: LD_ADDR_VAR 0 7
43658: PUSH
43659: LD_VAR 0 8
43663: PUSH
43664: FOR_IN
43665: IFFALSE 43791
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43667: LD_ADDR_EXP 55
43671: PUSH
43672: LD_EXP 55
43676: PPUSH
43677: LD_VAR 0 1
43681: PPUSH
43682: LD_EXP 55
43686: PUSH
43687: LD_VAR 0 1
43691: ARRAY
43692: PPUSH
43693: LD_EXP 55
43697: PUSH
43698: LD_VAR 0 1
43702: ARRAY
43703: PUSH
43704: LD_INT 1
43706: PLUS
43707: PPUSH
43708: LD_VAR 0 5
43712: PUSH
43713: LD_INT 1
43715: ARRAY
43716: PUSH
43717: LD_VAR 0 7
43721: PUSH
43722: LD_INT 1
43724: ARRAY
43725: PUSH
43726: LD_VAR 0 7
43730: PUSH
43731: LD_INT 2
43733: ARRAY
43734: PUSH
43735: LD_VAR 0 7
43739: PUSH
43740: LD_INT 3
43742: ARRAY
43743: PUSH
43744: EMPTY
43745: LIST
43746: LIST
43747: LIST
43748: LIST
43749: PPUSH
43750: CALL_OW 2
43754: PPUSH
43755: CALL_OW 1
43759: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43760: LD_ADDR_VAR 0 5
43764: PUSH
43765: LD_VAR 0 5
43769: PPUSH
43770: LD_INT 1
43772: PPUSH
43773: CALL_OW 3
43777: ST_TO_ADDR
// if not ext_list then
43778: LD_VAR 0 5
43782: NOT
43783: IFFALSE 43789
// exit ;
43785: POP
43786: POP
43787: GO 43793
// end ;
43789: GO 43664
43791: POP
43792: POP
// end ;
43793: LD_VAR 0 6
43797: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43798: LD_INT 0
43800: PPUSH
// if not mc_bases or not base or not weapon_list then
43801: LD_EXP 50
43805: NOT
43806: PUSH
43807: LD_VAR 0 1
43811: NOT
43812: OR
43813: PUSH
43814: LD_VAR 0 2
43818: NOT
43819: OR
43820: IFFALSE 43824
// exit ;
43822: GO 43849
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43824: LD_ADDR_EXP 89
43828: PUSH
43829: LD_EXP 89
43833: PPUSH
43834: LD_VAR 0 1
43838: PPUSH
43839: LD_VAR 0 2
43843: PPUSH
43844: CALL_OW 1
43848: ST_TO_ADDR
// end ;
43849: LD_VAR 0 3
43853: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43854: LD_INT 0
43856: PPUSH
// if not mc_bases or not base or not tech_list then
43857: LD_EXP 50
43861: NOT
43862: PUSH
43863: LD_VAR 0 1
43867: NOT
43868: OR
43869: PUSH
43870: LD_VAR 0 2
43874: NOT
43875: OR
43876: IFFALSE 43880
// exit ;
43878: GO 43905
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43880: LD_ADDR_EXP 77
43884: PUSH
43885: LD_EXP 77
43889: PPUSH
43890: LD_VAR 0 1
43894: PPUSH
43895: LD_VAR 0 2
43899: PPUSH
43900: CALL_OW 1
43904: ST_TO_ADDR
// end ;
43905: LD_VAR 0 3
43909: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43910: LD_INT 0
43912: PPUSH
// if not mc_bases or not parking_area or not base then
43913: LD_EXP 50
43917: NOT
43918: PUSH
43919: LD_VAR 0 2
43923: NOT
43924: OR
43925: PUSH
43926: LD_VAR 0 1
43930: NOT
43931: OR
43932: IFFALSE 43936
// exit ;
43934: GO 43961
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43936: LD_ADDR_EXP 74
43940: PUSH
43941: LD_EXP 74
43945: PPUSH
43946: LD_VAR 0 1
43950: PPUSH
43951: LD_VAR 0 2
43955: PPUSH
43956: CALL_OW 1
43960: ST_TO_ADDR
// end ;
43961: LD_VAR 0 3
43965: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43966: LD_INT 0
43968: PPUSH
// if not mc_bases or not base or not scan_area then
43969: LD_EXP 50
43973: NOT
43974: PUSH
43975: LD_VAR 0 1
43979: NOT
43980: OR
43981: PUSH
43982: LD_VAR 0 2
43986: NOT
43987: OR
43988: IFFALSE 43992
// exit ;
43990: GO 44017
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43992: LD_ADDR_EXP 75
43996: PUSH
43997: LD_EXP 75
44001: PPUSH
44002: LD_VAR 0 1
44006: PPUSH
44007: LD_VAR 0 2
44011: PPUSH
44012: CALL_OW 1
44016: ST_TO_ADDR
// end ;
44017: LD_VAR 0 3
44021: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
44022: LD_INT 0
44024: PPUSH
44025: PPUSH
// if not mc_bases or not base then
44026: LD_EXP 50
44030: NOT
44031: PUSH
44032: LD_VAR 0 1
44036: NOT
44037: OR
44038: IFFALSE 44042
// exit ;
44040: GO 44106
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
44042: LD_ADDR_VAR 0 3
44046: PUSH
44047: LD_INT 1
44049: PUSH
44050: LD_INT 2
44052: PUSH
44053: LD_INT 3
44055: PUSH
44056: LD_INT 4
44058: PUSH
44059: LD_INT 11
44061: PUSH
44062: EMPTY
44063: LIST
44064: LIST
44065: LIST
44066: LIST
44067: LIST
44068: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
44069: LD_ADDR_EXP 77
44073: PUSH
44074: LD_EXP 77
44078: PPUSH
44079: LD_VAR 0 1
44083: PPUSH
44084: LD_EXP 77
44088: PUSH
44089: LD_VAR 0 1
44093: ARRAY
44094: PUSH
44095: LD_VAR 0 3
44099: DIFF
44100: PPUSH
44101: CALL_OW 1
44105: ST_TO_ADDR
// end ;
44106: LD_VAR 0 2
44110: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44111: LD_INT 0
44113: PPUSH
// result := mc_vehicles [ base ] ;
44114: LD_ADDR_VAR 0 3
44118: PUSH
44119: LD_EXP 69
44123: PUSH
44124: LD_VAR 0 1
44128: ARRAY
44129: ST_TO_ADDR
// if onlyCombat then
44130: LD_VAR 0 2
44134: IFFALSE 44306
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44136: LD_ADDR_VAR 0 3
44140: PUSH
44141: LD_VAR 0 3
44145: PUSH
44146: LD_VAR 0 3
44150: PPUSH
44151: LD_INT 2
44153: PUSH
44154: LD_INT 34
44156: PUSH
44157: LD_INT 12
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: PUSH
44164: LD_INT 34
44166: PUSH
44167: LD_INT 51
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: LD_INT 34
44176: PUSH
44177: LD_INT 89
44179: PUSH
44180: EMPTY
44181: LIST
44182: LIST
44183: PUSH
44184: LD_INT 34
44186: PUSH
44187: LD_INT 32
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: PUSH
44194: LD_INT 34
44196: PUSH
44197: LD_INT 13
44199: PUSH
44200: EMPTY
44201: LIST
44202: LIST
44203: PUSH
44204: LD_INT 34
44206: PUSH
44207: LD_INT 52
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: PUSH
44214: LD_INT 34
44216: PUSH
44217: LD_INT 88
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 34
44226: PUSH
44227: LD_INT 14
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: PUSH
44234: LD_INT 34
44236: PUSH
44237: LD_INT 53
44239: PUSH
44240: EMPTY
44241: LIST
44242: LIST
44243: PUSH
44244: LD_INT 34
44246: PUSH
44247: LD_INT 98
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 34
44256: PUSH
44257: LD_INT 31
44259: PUSH
44260: EMPTY
44261: LIST
44262: LIST
44263: PUSH
44264: LD_INT 34
44266: PUSH
44267: LD_INT 48
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: LD_INT 34
44276: PUSH
44277: LD_INT 8
44279: PUSH
44280: EMPTY
44281: LIST
44282: LIST
44283: PUSH
44284: EMPTY
44285: LIST
44286: LIST
44287: LIST
44288: LIST
44289: LIST
44290: LIST
44291: LIST
44292: LIST
44293: LIST
44294: LIST
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: PPUSH
44300: CALL_OW 72
44304: DIFF
44305: ST_TO_ADDR
// end ; end_of_file
44306: LD_VAR 0 3
44310: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44311: LD_INT 0
44313: PPUSH
44314: PPUSH
44315: PPUSH
// if not mc_bases or not skirmish then
44316: LD_EXP 50
44320: NOT
44321: PUSH
44322: LD_EXP 48
44326: NOT
44327: OR
44328: IFFALSE 44332
// exit ;
44330: GO 44497
// for i = 1 to mc_bases do
44332: LD_ADDR_VAR 0 4
44336: PUSH
44337: DOUBLE
44338: LD_INT 1
44340: DEC
44341: ST_TO_ADDR
44342: LD_EXP 50
44346: PUSH
44347: FOR_TO
44348: IFFALSE 44495
// begin if sci in mc_bases [ i ] then
44350: LD_VAR 0 2
44354: PUSH
44355: LD_EXP 50
44359: PUSH
44360: LD_VAR 0 4
44364: ARRAY
44365: IN
44366: IFFALSE 44493
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44368: LD_ADDR_EXP 79
44372: PUSH
44373: LD_EXP 79
44377: PPUSH
44378: LD_VAR 0 4
44382: PUSH
44383: LD_EXP 79
44387: PUSH
44388: LD_VAR 0 4
44392: ARRAY
44393: PUSH
44394: LD_INT 1
44396: PLUS
44397: PUSH
44398: EMPTY
44399: LIST
44400: LIST
44401: PPUSH
44402: LD_VAR 0 1
44406: PPUSH
44407: CALL 54081 0 3
44411: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44412: LD_ADDR_VAR 0 5
44416: PUSH
44417: LD_EXP 50
44421: PUSH
44422: LD_VAR 0 4
44426: ARRAY
44427: PPUSH
44428: LD_INT 2
44430: PUSH
44431: LD_INT 30
44433: PUSH
44434: LD_INT 0
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: PUSH
44441: LD_INT 30
44443: PUSH
44444: LD_INT 1
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: LIST
44455: PPUSH
44456: CALL_OW 72
44460: PPUSH
44461: LD_VAR 0 1
44465: PPUSH
44466: CALL_OW 74
44470: ST_TO_ADDR
// if tmp then
44471: LD_VAR 0 5
44475: IFFALSE 44491
// ComStandNearbyBuilding ( ape , tmp ) ;
44477: LD_VAR 0 1
44481: PPUSH
44482: LD_VAR 0 5
44486: PPUSH
44487: CALL 50683 0 2
// break ;
44491: GO 44495
// end ; end ;
44493: GO 44347
44495: POP
44496: POP
// end ;
44497: LD_VAR 0 3
44501: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44502: LD_INT 0
44504: PPUSH
44505: PPUSH
44506: PPUSH
// if not mc_bases or not skirmish then
44507: LD_EXP 50
44511: NOT
44512: PUSH
44513: LD_EXP 48
44517: NOT
44518: OR
44519: IFFALSE 44523
// exit ;
44521: GO 44612
// for i = 1 to mc_bases do
44523: LD_ADDR_VAR 0 4
44527: PUSH
44528: DOUBLE
44529: LD_INT 1
44531: DEC
44532: ST_TO_ADDR
44533: LD_EXP 50
44537: PUSH
44538: FOR_TO
44539: IFFALSE 44610
// begin if building in mc_busy_turret_list [ i ] then
44541: LD_VAR 0 1
44545: PUSH
44546: LD_EXP 60
44550: PUSH
44551: LD_VAR 0 4
44555: ARRAY
44556: IN
44557: IFFALSE 44608
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44559: LD_ADDR_VAR 0 5
44563: PUSH
44564: LD_EXP 60
44568: PUSH
44569: LD_VAR 0 4
44573: ARRAY
44574: PUSH
44575: LD_VAR 0 1
44579: DIFF
44580: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44581: LD_ADDR_EXP 60
44585: PUSH
44586: LD_EXP 60
44590: PPUSH
44591: LD_VAR 0 4
44595: PPUSH
44596: LD_VAR 0 5
44600: PPUSH
44601: CALL_OW 1
44605: ST_TO_ADDR
// break ;
44606: GO 44610
// end ; end ;
44608: GO 44538
44610: POP
44611: POP
// end ;
44612: LD_VAR 0 3
44616: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44617: LD_INT 0
44619: PPUSH
44620: PPUSH
44621: PPUSH
// if not mc_bases or not skirmish then
44622: LD_EXP 50
44626: NOT
44627: PUSH
44628: LD_EXP 48
44632: NOT
44633: OR
44634: IFFALSE 44638
// exit ;
44636: GO 44837
// for i = 1 to mc_bases do
44638: LD_ADDR_VAR 0 5
44642: PUSH
44643: DOUBLE
44644: LD_INT 1
44646: DEC
44647: ST_TO_ADDR
44648: LD_EXP 50
44652: PUSH
44653: FOR_TO
44654: IFFALSE 44835
// if building in mc_bases [ i ] then
44656: LD_VAR 0 1
44660: PUSH
44661: LD_EXP 50
44665: PUSH
44666: LD_VAR 0 5
44670: ARRAY
44671: IN
44672: IFFALSE 44833
// begin tmp := mc_bases [ i ] diff building ;
44674: LD_ADDR_VAR 0 6
44678: PUSH
44679: LD_EXP 50
44683: PUSH
44684: LD_VAR 0 5
44688: ARRAY
44689: PUSH
44690: LD_VAR 0 1
44694: DIFF
44695: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44696: LD_ADDR_EXP 50
44700: PUSH
44701: LD_EXP 50
44705: PPUSH
44706: LD_VAR 0 5
44710: PPUSH
44711: LD_VAR 0 6
44715: PPUSH
44716: CALL_OW 1
44720: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44721: LD_VAR 0 1
44725: PUSH
44726: LD_EXP 58
44730: PUSH
44731: LD_VAR 0 5
44735: ARRAY
44736: IN
44737: IFFALSE 44776
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44739: LD_ADDR_EXP 58
44743: PUSH
44744: LD_EXP 58
44748: PPUSH
44749: LD_VAR 0 5
44753: PPUSH
44754: LD_EXP 58
44758: PUSH
44759: LD_VAR 0 5
44763: ARRAY
44764: PUSH
44765: LD_VAR 0 1
44769: DIFF
44770: PPUSH
44771: CALL_OW 1
44775: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44776: LD_VAR 0 1
44780: PUSH
44781: LD_EXP 59
44785: PUSH
44786: LD_VAR 0 5
44790: ARRAY
44791: IN
44792: IFFALSE 44831
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44794: LD_ADDR_EXP 59
44798: PUSH
44799: LD_EXP 59
44803: PPUSH
44804: LD_VAR 0 5
44808: PPUSH
44809: LD_EXP 59
44813: PUSH
44814: LD_VAR 0 5
44818: ARRAY
44819: PUSH
44820: LD_VAR 0 1
44824: DIFF
44825: PPUSH
44826: CALL_OW 1
44830: ST_TO_ADDR
// break ;
44831: GO 44835
// end ;
44833: GO 44653
44835: POP
44836: POP
// end ;
44837: LD_VAR 0 4
44841: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44842: LD_INT 0
44844: PPUSH
44845: PPUSH
44846: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44847: LD_EXP 50
44851: NOT
44852: PUSH
44853: LD_EXP 48
44857: NOT
44858: OR
44859: PUSH
44860: LD_VAR 0 3
44864: PUSH
44865: LD_EXP 76
44869: IN
44870: NOT
44871: OR
44872: IFFALSE 44876
// exit ;
44874: GO 44999
// for i = 1 to mc_vehicles do
44876: LD_ADDR_VAR 0 6
44880: PUSH
44881: DOUBLE
44882: LD_INT 1
44884: DEC
44885: ST_TO_ADDR
44886: LD_EXP 69
44890: PUSH
44891: FOR_TO
44892: IFFALSE 44997
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44894: LD_VAR 0 2
44898: PUSH
44899: LD_EXP 69
44903: PUSH
44904: LD_VAR 0 6
44908: ARRAY
44909: IN
44910: PUSH
44911: LD_VAR 0 1
44915: PUSH
44916: LD_EXP 69
44920: PUSH
44921: LD_VAR 0 6
44925: ARRAY
44926: IN
44927: OR
44928: IFFALSE 44995
// begin tmp := mc_vehicles [ i ] diff old ;
44930: LD_ADDR_VAR 0 7
44934: PUSH
44935: LD_EXP 69
44939: PUSH
44940: LD_VAR 0 6
44944: ARRAY
44945: PUSH
44946: LD_VAR 0 2
44950: DIFF
44951: ST_TO_ADDR
// tmp := tmp diff new ;
44952: LD_ADDR_VAR 0 7
44956: PUSH
44957: LD_VAR 0 7
44961: PUSH
44962: LD_VAR 0 1
44966: DIFF
44967: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44968: LD_ADDR_EXP 69
44972: PUSH
44973: LD_EXP 69
44977: PPUSH
44978: LD_VAR 0 6
44982: PPUSH
44983: LD_VAR 0 7
44987: PPUSH
44988: CALL_OW 1
44992: ST_TO_ADDR
// break ;
44993: GO 44997
// end ;
44995: GO 44891
44997: POP
44998: POP
// end ;
44999: LD_VAR 0 5
45003: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
45004: LD_INT 0
45006: PPUSH
45007: PPUSH
45008: PPUSH
45009: PPUSH
// if not mc_bases or not skirmish then
45010: LD_EXP 50
45014: NOT
45015: PUSH
45016: LD_EXP 48
45020: NOT
45021: OR
45022: IFFALSE 45026
// exit ;
45024: GO 45446
// repeat wait ( 0 0$1 ) ;
45026: LD_INT 35
45028: PPUSH
45029: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
45033: LD_EXP 94
45037: NOT
45038: IFFALSE 45026
// mc_block_vehicle_constructed_thread := true ;
45040: LD_ADDR_EXP 94
45044: PUSH
45045: LD_INT 1
45047: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
45048: LD_ADDR_VAR 0 5
45052: PUSH
45053: LD_VAR 0 1
45057: PPUSH
45058: CALL_OW 255
45062: ST_TO_ADDR
// for i = 1 to mc_bases do
45063: LD_ADDR_VAR 0 4
45067: PUSH
45068: DOUBLE
45069: LD_INT 1
45071: DEC
45072: ST_TO_ADDR
45073: LD_EXP 50
45077: PUSH
45078: FOR_TO
45079: IFFALSE 45436
// begin if factory in mc_bases [ i ] then
45081: LD_VAR 0 2
45085: PUSH
45086: LD_EXP 50
45090: PUSH
45091: LD_VAR 0 4
45095: ARRAY
45096: IN
45097: IFFALSE 45434
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
45099: LD_EXP 72
45103: PUSH
45104: LD_VAR 0 4
45108: ARRAY
45109: PUSH
45110: LD_EXP 61
45114: PUSH
45115: LD_VAR 0 4
45119: ARRAY
45120: LESS
45121: PUSH
45122: LD_VAR 0 1
45126: PPUSH
45127: CALL_OW 264
45131: PUSH
45132: LD_INT 31
45134: PUSH
45135: LD_INT 32
45137: PUSH
45138: LD_INT 51
45140: PUSH
45141: LD_INT 89
45143: PUSH
45144: LD_INT 12
45146: PUSH
45147: LD_INT 30
45149: PUSH
45150: LD_INT 98
45152: PUSH
45153: LD_INT 11
45155: PUSH
45156: LD_INT 53
45158: PUSH
45159: LD_INT 14
45161: PUSH
45162: LD_INT 91
45164: PUSH
45165: LD_INT 29
45167: PUSH
45168: LD_INT 99
45170: PUSH
45171: LD_INT 13
45173: PUSH
45174: LD_INT 52
45176: PUSH
45177: LD_INT 88
45179: PUSH
45180: LD_INT 48
45182: PUSH
45183: LD_INT 8
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: LIST
45190: LIST
45191: LIST
45192: LIST
45193: LIST
45194: LIST
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: LIST
45200: LIST
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: IN
45206: NOT
45207: AND
45208: IFFALSE 45256
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45210: LD_ADDR_EXP 72
45214: PUSH
45215: LD_EXP 72
45219: PPUSH
45220: LD_VAR 0 4
45224: PUSH
45225: LD_EXP 72
45229: PUSH
45230: LD_VAR 0 4
45234: ARRAY
45235: PUSH
45236: LD_INT 1
45238: PLUS
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: PPUSH
45244: LD_VAR 0 1
45248: PPUSH
45249: CALL 54081 0 3
45253: ST_TO_ADDR
45254: GO 45300
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45256: LD_ADDR_EXP 69
45260: PUSH
45261: LD_EXP 69
45265: PPUSH
45266: LD_VAR 0 4
45270: PUSH
45271: LD_EXP 69
45275: PUSH
45276: LD_VAR 0 4
45280: ARRAY
45281: PUSH
45282: LD_INT 1
45284: PLUS
45285: PUSH
45286: EMPTY
45287: LIST
45288: LIST
45289: PPUSH
45290: LD_VAR 0 1
45294: PPUSH
45295: CALL 54081 0 3
45299: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
45300: LD_ADDR_EXP 94
45304: PUSH
45305: LD_INT 0
45307: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45308: LD_VAR 0 1
45312: PPUSH
45313: CALL_OW 263
45317: PUSH
45318: LD_INT 2
45320: EQUAL
45321: IFFALSE 45350
// begin repeat wait ( 0 0$3 ) ;
45323: LD_INT 105
45325: PPUSH
45326: CALL_OW 67
// Connect ( vehicle ) ;
45330: LD_VAR 0 1
45334: PPUSH
45335: CALL 57427 0 1
// until IsControledBy ( vehicle ) ;
45339: LD_VAR 0 1
45343: PPUSH
45344: CALL_OW 312
45348: IFFALSE 45323
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45350: LD_VAR 0 1
45354: PPUSH
45355: LD_EXP 74
45359: PUSH
45360: LD_VAR 0 4
45364: ARRAY
45365: PPUSH
45366: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45370: LD_VAR 0 1
45374: PPUSH
45375: CALL_OW 263
45379: PUSH
45380: LD_INT 1
45382: NONEQUAL
45383: IFFALSE 45387
// break ;
45385: GO 45436
// repeat wait ( 0 0$1 ) ;
45387: LD_INT 35
45389: PPUSH
45390: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45394: LD_VAR 0 1
45398: PPUSH
45399: LD_EXP 74
45403: PUSH
45404: LD_VAR 0 4
45408: ARRAY
45409: PPUSH
45410: CALL_OW 308
45414: IFFALSE 45387
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
45416: LD_VAR 0 1
45420: PPUSH
45421: CALL_OW 311
45425: PPUSH
45426: CALL_OW 121
// exit ;
45430: POP
45431: POP
45432: GO 45446
// end ; end ;
45434: GO 45078
45436: POP
45437: POP
// mc_block_vehicle_constructed_thread := false ;
45438: LD_ADDR_EXP 94
45442: PUSH
45443: LD_INT 0
45445: ST_TO_ADDR
// end ;
45446: LD_VAR 0 3
45450: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45451: LD_INT 0
45453: PPUSH
45454: PPUSH
45455: PPUSH
45456: PPUSH
// if not mc_bases or not skirmish then
45457: LD_EXP 50
45461: NOT
45462: PUSH
45463: LD_EXP 48
45467: NOT
45468: OR
45469: IFFALSE 45473
// exit ;
45471: GO 45826
// repeat wait ( 0 0$1 ) ;
45473: LD_INT 35
45475: PPUSH
45476: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45480: LD_VAR 0 2
45484: PPUSH
45485: LD_VAR 0 3
45489: PPUSH
45490: CALL_OW 284
45494: IFFALSE 45473
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45496: LD_VAR 0 2
45500: PPUSH
45501: LD_VAR 0 3
45505: PPUSH
45506: CALL_OW 283
45510: PUSH
45511: LD_INT 4
45513: EQUAL
45514: IFFALSE 45518
// exit ;
45516: GO 45826
// for i = 1 to mc_bases do
45518: LD_ADDR_VAR 0 7
45522: PUSH
45523: DOUBLE
45524: LD_INT 1
45526: DEC
45527: ST_TO_ADDR
45528: LD_EXP 50
45532: PUSH
45533: FOR_TO
45534: IFFALSE 45824
// begin if mc_crates_area [ i ] then
45536: LD_EXP 68
45540: PUSH
45541: LD_VAR 0 7
45545: ARRAY
45546: IFFALSE 45657
// for j in mc_crates_area [ i ] do
45548: LD_ADDR_VAR 0 8
45552: PUSH
45553: LD_EXP 68
45557: PUSH
45558: LD_VAR 0 7
45562: ARRAY
45563: PUSH
45564: FOR_IN
45565: IFFALSE 45655
// if InArea ( x , y , j ) then
45567: LD_VAR 0 2
45571: PPUSH
45572: LD_VAR 0 3
45576: PPUSH
45577: LD_VAR 0 8
45581: PPUSH
45582: CALL_OW 309
45586: IFFALSE 45653
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45588: LD_ADDR_EXP 66
45592: PUSH
45593: LD_EXP 66
45597: PPUSH
45598: LD_VAR 0 7
45602: PUSH
45603: LD_EXP 66
45607: PUSH
45608: LD_VAR 0 7
45612: ARRAY
45613: PUSH
45614: LD_INT 1
45616: PLUS
45617: PUSH
45618: EMPTY
45619: LIST
45620: LIST
45621: PPUSH
45622: LD_VAR 0 4
45626: PUSH
45627: LD_VAR 0 2
45631: PUSH
45632: LD_VAR 0 3
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: LIST
45641: PPUSH
45642: CALL 54081 0 3
45646: ST_TO_ADDR
// exit ;
45647: POP
45648: POP
45649: POP
45650: POP
45651: GO 45826
// end ;
45653: GO 45564
45655: POP
45656: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45657: LD_ADDR_VAR 0 9
45661: PUSH
45662: LD_EXP 50
45666: PUSH
45667: LD_VAR 0 7
45671: ARRAY
45672: PPUSH
45673: LD_INT 2
45675: PUSH
45676: LD_INT 30
45678: PUSH
45679: LD_INT 0
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: PUSH
45686: LD_INT 30
45688: PUSH
45689: LD_INT 1
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: PUSH
45696: EMPTY
45697: LIST
45698: LIST
45699: LIST
45700: PPUSH
45701: CALL_OW 72
45705: ST_TO_ADDR
// if not depot then
45706: LD_VAR 0 9
45710: NOT
45711: IFFALSE 45715
// continue ;
45713: GO 45533
// for j in depot do
45715: LD_ADDR_VAR 0 8
45719: PUSH
45720: LD_VAR 0 9
45724: PUSH
45725: FOR_IN
45726: IFFALSE 45820
// if GetDistUnitXY ( j , x , y ) < 30 then
45728: LD_VAR 0 8
45732: PPUSH
45733: LD_VAR 0 2
45737: PPUSH
45738: LD_VAR 0 3
45742: PPUSH
45743: CALL_OW 297
45747: PUSH
45748: LD_INT 30
45750: LESS
45751: IFFALSE 45818
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45753: LD_ADDR_EXP 66
45757: PUSH
45758: LD_EXP 66
45762: PPUSH
45763: LD_VAR 0 7
45767: PUSH
45768: LD_EXP 66
45772: PUSH
45773: LD_VAR 0 7
45777: ARRAY
45778: PUSH
45779: LD_INT 1
45781: PLUS
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PPUSH
45787: LD_VAR 0 4
45791: PUSH
45792: LD_VAR 0 2
45796: PUSH
45797: LD_VAR 0 3
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: LIST
45806: PPUSH
45807: CALL 54081 0 3
45811: ST_TO_ADDR
// exit ;
45812: POP
45813: POP
45814: POP
45815: POP
45816: GO 45826
// end ;
45818: GO 45725
45820: POP
45821: POP
// end ;
45822: GO 45533
45824: POP
45825: POP
// end ;
45826: LD_VAR 0 6
45830: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45831: LD_INT 0
45833: PPUSH
45834: PPUSH
45835: PPUSH
45836: PPUSH
// if not mc_bases or not skirmish then
45837: LD_EXP 50
45841: NOT
45842: PUSH
45843: LD_EXP 48
45847: NOT
45848: OR
45849: IFFALSE 45853
// exit ;
45851: GO 46130
// side := GetSide ( lab ) ;
45853: LD_ADDR_VAR 0 4
45857: PUSH
45858: LD_VAR 0 2
45862: PPUSH
45863: CALL_OW 255
45867: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45868: LD_VAR 0 4
45872: PUSH
45873: LD_EXP 76
45877: IN
45878: NOT
45879: PUSH
45880: LD_EXP 77
45884: NOT
45885: OR
45886: PUSH
45887: LD_EXP 50
45891: NOT
45892: OR
45893: IFFALSE 45897
// exit ;
45895: GO 46130
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45897: LD_ADDR_EXP 77
45901: PUSH
45902: LD_EXP 77
45906: PPUSH
45907: LD_VAR 0 4
45911: PPUSH
45912: LD_EXP 77
45916: PUSH
45917: LD_VAR 0 4
45921: ARRAY
45922: PUSH
45923: LD_VAR 0 1
45927: DIFF
45928: PPUSH
45929: CALL_OW 1
45933: ST_TO_ADDR
// for i = 1 to mc_bases do
45934: LD_ADDR_VAR 0 5
45938: PUSH
45939: DOUBLE
45940: LD_INT 1
45942: DEC
45943: ST_TO_ADDR
45944: LD_EXP 50
45948: PUSH
45949: FOR_TO
45950: IFFALSE 46128
// begin if lab in mc_bases [ i ] then
45952: LD_VAR 0 2
45956: PUSH
45957: LD_EXP 50
45961: PUSH
45962: LD_VAR 0 5
45966: ARRAY
45967: IN
45968: IFFALSE 46126
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45970: LD_VAR 0 1
45974: PUSH
45975: LD_INT 11
45977: PUSH
45978: LD_INT 4
45980: PUSH
45981: LD_INT 3
45983: PUSH
45984: LD_INT 2
45986: PUSH
45987: EMPTY
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: IN
45993: PUSH
45994: LD_EXP 80
45998: PUSH
45999: LD_VAR 0 5
46003: ARRAY
46004: AND
46005: IFFALSE 46126
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
46007: LD_ADDR_VAR 0 6
46011: PUSH
46012: LD_EXP 80
46016: PUSH
46017: LD_VAR 0 5
46021: ARRAY
46022: PUSH
46023: LD_INT 1
46025: ARRAY
46026: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46027: LD_ADDR_EXP 80
46031: PUSH
46032: LD_EXP 80
46036: PPUSH
46037: LD_VAR 0 5
46041: PPUSH
46042: EMPTY
46043: PPUSH
46044: CALL_OW 1
46048: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46049: LD_VAR 0 6
46053: PPUSH
46054: LD_INT 0
46056: PPUSH
46057: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46061: LD_VAR 0 6
46065: PPUSH
46066: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46070: LD_ADDR_EXP 79
46074: PUSH
46075: LD_EXP 79
46079: PPUSH
46080: LD_VAR 0 5
46084: PPUSH
46085: LD_EXP 79
46089: PUSH
46090: LD_VAR 0 5
46094: ARRAY
46095: PPUSH
46096: LD_INT 1
46098: PPUSH
46099: LD_VAR 0 6
46103: PPUSH
46104: CALL_OW 2
46108: PPUSH
46109: CALL_OW 1
46113: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46114: LD_VAR 0 5
46118: PPUSH
46119: LD_INT 112
46121: PPUSH
46122: CALL 22580 0 2
// end ; end ; end ;
46126: GO 45949
46128: POP
46129: POP
// end ;
46130: LD_VAR 0 3
46134: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46135: LD_INT 0
46137: PPUSH
46138: PPUSH
46139: PPUSH
46140: PPUSH
46141: PPUSH
46142: PPUSH
46143: PPUSH
46144: PPUSH
// if not mc_bases or not skirmish then
46145: LD_EXP 50
46149: NOT
46150: PUSH
46151: LD_EXP 48
46155: NOT
46156: OR
46157: IFFALSE 46161
// exit ;
46159: GO 47530
// for i = 1 to mc_bases do
46161: LD_ADDR_VAR 0 3
46165: PUSH
46166: DOUBLE
46167: LD_INT 1
46169: DEC
46170: ST_TO_ADDR
46171: LD_EXP 50
46175: PUSH
46176: FOR_TO
46177: IFFALSE 47528
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46179: LD_VAR 0 1
46183: PUSH
46184: LD_EXP 50
46188: PUSH
46189: LD_VAR 0 3
46193: ARRAY
46194: IN
46195: PUSH
46196: LD_VAR 0 1
46200: PUSH
46201: LD_EXP 57
46205: PUSH
46206: LD_VAR 0 3
46210: ARRAY
46211: IN
46212: OR
46213: PUSH
46214: LD_VAR 0 1
46218: PUSH
46219: LD_EXP 72
46223: PUSH
46224: LD_VAR 0 3
46228: ARRAY
46229: IN
46230: OR
46231: PUSH
46232: LD_VAR 0 1
46236: PUSH
46237: LD_EXP 69
46241: PUSH
46242: LD_VAR 0 3
46246: ARRAY
46247: IN
46248: OR
46249: PUSH
46250: LD_VAR 0 1
46254: PUSH
46255: LD_EXP 79
46259: PUSH
46260: LD_VAR 0 3
46264: ARRAY
46265: IN
46266: OR
46267: PUSH
46268: LD_VAR 0 1
46272: PUSH
46273: LD_EXP 80
46277: PUSH
46278: LD_VAR 0 3
46282: ARRAY
46283: IN
46284: OR
46285: IFFALSE 47526
// begin if un in mc_ape [ i ] then
46287: LD_VAR 0 1
46291: PUSH
46292: LD_EXP 79
46296: PUSH
46297: LD_VAR 0 3
46301: ARRAY
46302: IN
46303: IFFALSE 46342
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46305: LD_ADDR_EXP 79
46309: PUSH
46310: LD_EXP 79
46314: PPUSH
46315: LD_VAR 0 3
46319: PPUSH
46320: LD_EXP 79
46324: PUSH
46325: LD_VAR 0 3
46329: ARRAY
46330: PUSH
46331: LD_VAR 0 1
46335: DIFF
46336: PPUSH
46337: CALL_OW 1
46341: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46342: LD_VAR 0 1
46346: PUSH
46347: LD_EXP 80
46351: PUSH
46352: LD_VAR 0 3
46356: ARRAY
46357: IN
46358: IFFALSE 46382
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46360: LD_ADDR_EXP 80
46364: PUSH
46365: LD_EXP 80
46369: PPUSH
46370: LD_VAR 0 3
46374: PPUSH
46375: EMPTY
46376: PPUSH
46377: CALL_OW 1
46381: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
46382: LD_VAR 0 1
46386: PPUSH
46387: CALL_OW 247
46391: PUSH
46392: LD_INT 2
46394: EQUAL
46395: PUSH
46396: LD_VAR 0 1
46400: PPUSH
46401: CALL_OW 110
46405: PUSH
46406: LD_INT 20
46408: EQUAL
46409: PUSH
46410: LD_VAR 0 1
46414: PUSH
46415: LD_EXP 72
46419: PUSH
46420: LD_VAR 0 3
46424: ARRAY
46425: IN
46426: OR
46427: PUSH
46428: LD_VAR 0 1
46432: PPUSH
46433: CALL_OW 264
46437: PUSH
46438: LD_INT 12
46440: PUSH
46441: LD_INT 51
46443: PUSH
46444: LD_INT 89
46446: PUSH
46447: LD_INT 32
46449: PUSH
46450: LD_INT 13
46452: PUSH
46453: LD_INT 52
46455: PUSH
46456: LD_INT 31
46458: PUSH
46459: EMPTY
46460: LIST
46461: LIST
46462: LIST
46463: LIST
46464: LIST
46465: LIST
46466: LIST
46467: IN
46468: OR
46469: AND
46470: IFFALSE 46778
// begin if un in mc_defender [ i ] then
46472: LD_VAR 0 1
46476: PUSH
46477: LD_EXP 72
46481: PUSH
46482: LD_VAR 0 3
46486: ARRAY
46487: IN
46488: IFFALSE 46527
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46490: LD_ADDR_EXP 72
46494: PUSH
46495: LD_EXP 72
46499: PPUSH
46500: LD_VAR 0 3
46504: PPUSH
46505: LD_EXP 72
46509: PUSH
46510: LD_VAR 0 3
46514: ARRAY
46515: PUSH
46516: LD_VAR 0 1
46520: DIFF
46521: PPUSH
46522: CALL_OW 1
46526: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46527: LD_ADDR_VAR 0 8
46531: PUSH
46532: LD_VAR 0 3
46536: PPUSH
46537: LD_INT 3
46539: PPUSH
46540: CALL 43148 0 2
46544: ST_TO_ADDR
// if fac then
46545: LD_VAR 0 8
46549: IFFALSE 46778
// begin for j in fac do
46551: LD_ADDR_VAR 0 4
46555: PUSH
46556: LD_VAR 0 8
46560: PUSH
46561: FOR_IN
46562: IFFALSE 46776
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46564: LD_ADDR_VAR 0 9
46568: PUSH
46569: LD_VAR 0 8
46573: PPUSH
46574: LD_VAR 0 1
46578: PPUSH
46579: CALL_OW 265
46583: PPUSH
46584: LD_VAR 0 1
46588: PPUSH
46589: CALL_OW 262
46593: PPUSH
46594: LD_VAR 0 1
46598: PPUSH
46599: CALL_OW 263
46603: PPUSH
46604: LD_VAR 0 1
46608: PPUSH
46609: CALL_OW 264
46613: PPUSH
46614: CALL 51579 0 5
46618: ST_TO_ADDR
// if components then
46619: LD_VAR 0 9
46623: IFFALSE 46774
// begin if GetWeapon ( un ) = ar_control_tower then
46625: LD_VAR 0 1
46629: PPUSH
46630: CALL_OW 264
46634: PUSH
46635: LD_INT 31
46637: EQUAL
46638: IFFALSE 46755
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46640: LD_VAR 0 1
46644: PPUSH
46645: CALL_OW 311
46649: PPUSH
46650: LD_INT 0
46652: PPUSH
46653: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46657: LD_ADDR_EXP 90
46661: PUSH
46662: LD_EXP 90
46666: PPUSH
46667: LD_VAR 0 3
46671: PPUSH
46672: LD_EXP 90
46676: PUSH
46677: LD_VAR 0 3
46681: ARRAY
46682: PUSH
46683: LD_VAR 0 1
46687: PPUSH
46688: CALL_OW 311
46692: DIFF
46693: PPUSH
46694: CALL_OW 1
46698: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46699: LD_ADDR_VAR 0 7
46703: PUSH
46704: LD_EXP 71
46708: PUSH
46709: LD_VAR 0 3
46713: ARRAY
46714: PPUSH
46715: LD_INT 1
46717: PPUSH
46718: LD_VAR 0 9
46722: PPUSH
46723: CALL_OW 2
46727: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46728: LD_ADDR_EXP 71
46732: PUSH
46733: LD_EXP 71
46737: PPUSH
46738: LD_VAR 0 3
46742: PPUSH
46743: LD_VAR 0 7
46747: PPUSH
46748: CALL_OW 1
46752: ST_TO_ADDR
// end else
46753: GO 46772
// MC_InsertProduceList ( i , [ components ] ) ;
46755: LD_VAR 0 3
46759: PPUSH
46760: LD_VAR 0 9
46764: PUSH
46765: EMPTY
46766: LIST
46767: PPUSH
46768: CALL 42693 0 2
// break ;
46772: GO 46776
// end ; end ;
46774: GO 46561
46776: POP
46777: POP
// end ; end ; if GetType ( un ) = unit_building then
46778: LD_VAR 0 1
46782: PPUSH
46783: CALL_OW 247
46787: PUSH
46788: LD_INT 3
46790: EQUAL
46791: IFFALSE 47194
// begin btype := GetBType ( un ) ;
46793: LD_ADDR_VAR 0 5
46797: PUSH
46798: LD_VAR 0 1
46802: PPUSH
46803: CALL_OW 266
46807: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46808: LD_VAR 0 5
46812: PUSH
46813: LD_INT 29
46815: PUSH
46816: LD_INT 30
46818: PUSH
46819: EMPTY
46820: LIST
46821: LIST
46822: IN
46823: IFFALSE 46896
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46825: LD_VAR 0 1
46829: PPUSH
46830: CALL_OW 250
46834: PPUSH
46835: LD_VAR 0 1
46839: PPUSH
46840: CALL_OW 251
46844: PPUSH
46845: LD_VAR 0 1
46849: PPUSH
46850: CALL_OW 255
46854: PPUSH
46855: CALL_OW 440
46859: NOT
46860: IFFALSE 46896
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46862: LD_VAR 0 1
46866: PPUSH
46867: CALL_OW 250
46871: PPUSH
46872: LD_VAR 0 1
46876: PPUSH
46877: CALL_OW 251
46881: PPUSH
46882: LD_VAR 0 1
46886: PPUSH
46887: CALL_OW 255
46891: PPUSH
46892: CALL_OW 441
// end ; if btype = b_warehouse then
46896: LD_VAR 0 5
46900: PUSH
46901: LD_INT 1
46903: EQUAL
46904: IFFALSE 46922
// begin btype := b_depot ;
46906: LD_ADDR_VAR 0 5
46910: PUSH
46911: LD_INT 0
46913: ST_TO_ADDR
// pos := 1 ;
46914: LD_ADDR_VAR 0 6
46918: PUSH
46919: LD_INT 1
46921: ST_TO_ADDR
// end ; if btype = b_factory then
46922: LD_VAR 0 5
46926: PUSH
46927: LD_INT 3
46929: EQUAL
46930: IFFALSE 46948
// begin btype := b_workshop ;
46932: LD_ADDR_VAR 0 5
46936: PUSH
46937: LD_INT 2
46939: ST_TO_ADDR
// pos := 1 ;
46940: LD_ADDR_VAR 0 6
46944: PUSH
46945: LD_INT 1
46947: ST_TO_ADDR
// end ; if btype = b_barracks then
46948: LD_VAR 0 5
46952: PUSH
46953: LD_INT 5
46955: EQUAL
46956: IFFALSE 46966
// btype := b_armoury ;
46958: LD_ADDR_VAR 0 5
46962: PUSH
46963: LD_INT 4
46965: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46966: LD_VAR 0 5
46970: PUSH
46971: LD_INT 7
46973: PUSH
46974: LD_INT 8
46976: PUSH
46977: EMPTY
46978: LIST
46979: LIST
46980: IN
46981: IFFALSE 46991
// btype := b_lab ;
46983: LD_ADDR_VAR 0 5
46987: PUSH
46988: LD_INT 6
46990: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46991: LD_ADDR_EXP 55
46995: PUSH
46996: LD_EXP 55
47000: PPUSH
47001: LD_VAR 0 3
47005: PUSH
47006: LD_EXP 55
47010: PUSH
47011: LD_VAR 0 3
47015: ARRAY
47016: PUSH
47017: LD_INT 1
47019: PLUS
47020: PUSH
47021: EMPTY
47022: LIST
47023: LIST
47024: PPUSH
47025: LD_VAR 0 5
47029: PUSH
47030: LD_VAR 0 1
47034: PPUSH
47035: CALL_OW 250
47039: PUSH
47040: LD_VAR 0 1
47044: PPUSH
47045: CALL_OW 251
47049: PUSH
47050: LD_VAR 0 1
47054: PPUSH
47055: CALL_OW 254
47059: PUSH
47060: EMPTY
47061: LIST
47062: LIST
47063: LIST
47064: LIST
47065: PPUSH
47066: CALL 54081 0 3
47070: ST_TO_ADDR
// if pos = 1 then
47071: LD_VAR 0 6
47075: PUSH
47076: LD_INT 1
47078: EQUAL
47079: IFFALSE 47194
// begin tmp := mc_build_list [ i ] ;
47081: LD_ADDR_VAR 0 7
47085: PUSH
47086: LD_EXP 55
47090: PUSH
47091: LD_VAR 0 3
47095: ARRAY
47096: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47097: LD_VAR 0 7
47101: PPUSH
47102: LD_INT 2
47104: PUSH
47105: LD_INT 30
47107: PUSH
47108: LD_INT 0
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: PUSH
47115: LD_INT 30
47117: PUSH
47118: LD_INT 1
47120: PUSH
47121: EMPTY
47122: LIST
47123: LIST
47124: PUSH
47125: EMPTY
47126: LIST
47127: LIST
47128: LIST
47129: PPUSH
47130: CALL_OW 72
47134: IFFALSE 47144
// pos := 2 ;
47136: LD_ADDR_VAR 0 6
47140: PUSH
47141: LD_INT 2
47143: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47144: LD_ADDR_VAR 0 7
47148: PUSH
47149: LD_VAR 0 7
47153: PPUSH
47154: LD_VAR 0 6
47158: PPUSH
47159: LD_VAR 0 7
47163: PPUSH
47164: CALL 54407 0 3
47168: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47169: LD_ADDR_EXP 55
47173: PUSH
47174: LD_EXP 55
47178: PPUSH
47179: LD_VAR 0 3
47183: PPUSH
47184: LD_VAR 0 7
47188: PPUSH
47189: CALL_OW 1
47193: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47194: LD_VAR 0 1
47198: PUSH
47199: LD_EXP 50
47203: PUSH
47204: LD_VAR 0 3
47208: ARRAY
47209: IN
47210: IFFALSE 47249
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47212: LD_ADDR_EXP 50
47216: PUSH
47217: LD_EXP 50
47221: PPUSH
47222: LD_VAR 0 3
47226: PPUSH
47227: LD_EXP 50
47231: PUSH
47232: LD_VAR 0 3
47236: ARRAY
47237: PUSH
47238: LD_VAR 0 1
47242: DIFF
47243: PPUSH
47244: CALL_OW 1
47248: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47249: LD_VAR 0 1
47253: PUSH
47254: LD_EXP 57
47258: PUSH
47259: LD_VAR 0 3
47263: ARRAY
47264: IN
47265: IFFALSE 47304
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47267: LD_ADDR_EXP 57
47271: PUSH
47272: LD_EXP 57
47276: PPUSH
47277: LD_VAR 0 3
47281: PPUSH
47282: LD_EXP 57
47286: PUSH
47287: LD_VAR 0 3
47291: ARRAY
47292: PUSH
47293: LD_VAR 0 1
47297: DIFF
47298: PPUSH
47299: CALL_OW 1
47303: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47304: LD_VAR 0 1
47308: PUSH
47309: LD_EXP 69
47313: PUSH
47314: LD_VAR 0 3
47318: ARRAY
47319: IN
47320: IFFALSE 47359
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47322: LD_ADDR_EXP 69
47326: PUSH
47327: LD_EXP 69
47331: PPUSH
47332: LD_VAR 0 3
47336: PPUSH
47337: LD_EXP 69
47341: PUSH
47342: LD_VAR 0 3
47346: ARRAY
47347: PUSH
47348: LD_VAR 0 1
47352: DIFF
47353: PPUSH
47354: CALL_OW 1
47358: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47359: LD_VAR 0 1
47363: PUSH
47364: LD_EXP 72
47368: PUSH
47369: LD_VAR 0 3
47373: ARRAY
47374: IN
47375: IFFALSE 47414
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47377: LD_ADDR_EXP 72
47381: PUSH
47382: LD_EXP 72
47386: PPUSH
47387: LD_VAR 0 3
47391: PPUSH
47392: LD_EXP 72
47396: PUSH
47397: LD_VAR 0 3
47401: ARRAY
47402: PUSH
47403: LD_VAR 0 1
47407: DIFF
47408: PPUSH
47409: CALL_OW 1
47413: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47414: LD_VAR 0 1
47418: PUSH
47419: LD_EXP 59
47423: PUSH
47424: LD_VAR 0 3
47428: ARRAY
47429: IN
47430: IFFALSE 47469
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47432: LD_ADDR_EXP 59
47436: PUSH
47437: LD_EXP 59
47441: PPUSH
47442: LD_VAR 0 3
47446: PPUSH
47447: LD_EXP 59
47451: PUSH
47452: LD_VAR 0 3
47456: ARRAY
47457: PUSH
47458: LD_VAR 0 1
47462: DIFF
47463: PPUSH
47464: CALL_OW 1
47468: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47469: LD_VAR 0 1
47473: PUSH
47474: LD_EXP 58
47478: PUSH
47479: LD_VAR 0 3
47483: ARRAY
47484: IN
47485: IFFALSE 47524
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47487: LD_ADDR_EXP 58
47491: PUSH
47492: LD_EXP 58
47496: PPUSH
47497: LD_VAR 0 3
47501: PPUSH
47502: LD_EXP 58
47506: PUSH
47507: LD_VAR 0 3
47511: ARRAY
47512: PUSH
47513: LD_VAR 0 1
47517: DIFF
47518: PPUSH
47519: CALL_OW 1
47523: ST_TO_ADDR
// end ; break ;
47524: GO 47528
// end ;
47526: GO 46176
47528: POP
47529: POP
// end ;
47530: LD_VAR 0 2
47534: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47535: LD_INT 0
47537: PPUSH
47538: PPUSH
47539: PPUSH
// if not mc_bases or not skirmish then
47540: LD_EXP 50
47544: NOT
47545: PUSH
47546: LD_EXP 48
47550: NOT
47551: OR
47552: IFFALSE 47556
// exit ;
47554: GO 47771
// for i = 1 to mc_bases do
47556: LD_ADDR_VAR 0 3
47560: PUSH
47561: DOUBLE
47562: LD_INT 1
47564: DEC
47565: ST_TO_ADDR
47566: LD_EXP 50
47570: PUSH
47571: FOR_TO
47572: IFFALSE 47769
// begin if building in mc_construct_list [ i ] then
47574: LD_VAR 0 1
47578: PUSH
47579: LD_EXP 57
47583: PUSH
47584: LD_VAR 0 3
47588: ARRAY
47589: IN
47590: IFFALSE 47767
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47592: LD_ADDR_EXP 57
47596: PUSH
47597: LD_EXP 57
47601: PPUSH
47602: LD_VAR 0 3
47606: PPUSH
47607: LD_EXP 57
47611: PUSH
47612: LD_VAR 0 3
47616: ARRAY
47617: PUSH
47618: LD_VAR 0 1
47622: DIFF
47623: PPUSH
47624: CALL_OW 1
47628: ST_TO_ADDR
// if building in mc_lab [ i ] then
47629: LD_VAR 0 1
47633: PUSH
47634: LD_EXP 83
47638: PUSH
47639: LD_VAR 0 3
47643: ARRAY
47644: IN
47645: IFFALSE 47700
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47647: LD_ADDR_EXP 84
47651: PUSH
47652: LD_EXP 84
47656: PPUSH
47657: LD_VAR 0 3
47661: PPUSH
47662: LD_EXP 84
47666: PUSH
47667: LD_VAR 0 3
47671: ARRAY
47672: PPUSH
47673: LD_INT 1
47675: PPUSH
47676: LD_EXP 84
47680: PUSH
47681: LD_VAR 0 3
47685: ARRAY
47686: PPUSH
47687: LD_INT 0
47689: PPUSH
47690: CALL 53499 0 4
47694: PPUSH
47695: CALL_OW 1
47699: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47700: LD_VAR 0 1
47704: PUSH
47705: LD_EXP 50
47709: PUSH
47710: LD_VAR 0 3
47714: ARRAY
47715: IN
47716: NOT
47717: IFFALSE 47763
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47719: LD_ADDR_EXP 50
47723: PUSH
47724: LD_EXP 50
47728: PPUSH
47729: LD_VAR 0 3
47733: PUSH
47734: LD_EXP 50
47738: PUSH
47739: LD_VAR 0 3
47743: ARRAY
47744: PUSH
47745: LD_INT 1
47747: PLUS
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PPUSH
47753: LD_VAR 0 1
47757: PPUSH
47758: CALL 54081 0 3
47762: ST_TO_ADDR
// exit ;
47763: POP
47764: POP
47765: GO 47771
// end ; end ;
47767: GO 47571
47769: POP
47770: POP
// end ;
47771: LD_VAR 0 2
47775: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47776: LD_INT 0
47778: PPUSH
47779: PPUSH
47780: PPUSH
47781: PPUSH
47782: PPUSH
47783: PPUSH
47784: PPUSH
// if not mc_bases or not skirmish then
47785: LD_EXP 50
47789: NOT
47790: PUSH
47791: LD_EXP 48
47795: NOT
47796: OR
47797: IFFALSE 47801
// exit ;
47799: GO 48462
// for i = 1 to mc_bases do
47801: LD_ADDR_VAR 0 3
47805: PUSH
47806: DOUBLE
47807: LD_INT 1
47809: DEC
47810: ST_TO_ADDR
47811: LD_EXP 50
47815: PUSH
47816: FOR_TO
47817: IFFALSE 48460
// begin if building in mc_construct_list [ i ] then
47819: LD_VAR 0 1
47823: PUSH
47824: LD_EXP 57
47828: PUSH
47829: LD_VAR 0 3
47833: ARRAY
47834: IN
47835: IFFALSE 48458
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47837: LD_ADDR_EXP 57
47841: PUSH
47842: LD_EXP 57
47846: PPUSH
47847: LD_VAR 0 3
47851: PPUSH
47852: LD_EXP 57
47856: PUSH
47857: LD_VAR 0 3
47861: ARRAY
47862: PUSH
47863: LD_VAR 0 1
47867: DIFF
47868: PPUSH
47869: CALL_OW 1
47873: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47874: LD_ADDR_EXP 50
47878: PUSH
47879: LD_EXP 50
47883: PPUSH
47884: LD_VAR 0 3
47888: PUSH
47889: LD_EXP 50
47893: PUSH
47894: LD_VAR 0 3
47898: ARRAY
47899: PUSH
47900: LD_INT 1
47902: PLUS
47903: PUSH
47904: EMPTY
47905: LIST
47906: LIST
47907: PPUSH
47908: LD_VAR 0 1
47912: PPUSH
47913: CALL 54081 0 3
47917: ST_TO_ADDR
// btype := GetBType ( building ) ;
47918: LD_ADDR_VAR 0 5
47922: PUSH
47923: LD_VAR 0 1
47927: PPUSH
47928: CALL_OW 266
47932: ST_TO_ADDR
// side := GetSide ( building ) ;
47933: LD_ADDR_VAR 0 8
47937: PUSH
47938: LD_VAR 0 1
47942: PPUSH
47943: CALL_OW 255
47947: ST_TO_ADDR
// if btype = b_lab then
47948: LD_VAR 0 5
47952: PUSH
47953: LD_INT 6
47955: EQUAL
47956: IFFALSE 48006
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47958: LD_ADDR_EXP 83
47962: PUSH
47963: LD_EXP 83
47967: PPUSH
47968: LD_VAR 0 3
47972: PUSH
47973: LD_EXP 83
47977: PUSH
47978: LD_VAR 0 3
47982: ARRAY
47983: PUSH
47984: LD_INT 1
47986: PLUS
47987: PUSH
47988: EMPTY
47989: LIST
47990: LIST
47991: PPUSH
47992: LD_VAR 0 1
47996: PPUSH
47997: CALL 54081 0 3
48001: ST_TO_ADDR
// exit ;
48002: POP
48003: POP
48004: GO 48462
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
48006: LD_VAR 0 5
48010: PUSH
48011: LD_INT 0
48013: PUSH
48014: LD_INT 2
48016: PUSH
48017: LD_INT 4
48019: PUSH
48020: EMPTY
48021: LIST
48022: LIST
48023: LIST
48024: IN
48025: IFFALSE 48149
// begin if btype = b_armoury then
48027: LD_VAR 0 5
48031: PUSH
48032: LD_INT 4
48034: EQUAL
48035: IFFALSE 48045
// btype := b_barracks ;
48037: LD_ADDR_VAR 0 5
48041: PUSH
48042: LD_INT 5
48044: ST_TO_ADDR
// if btype = b_depot then
48045: LD_VAR 0 5
48049: PUSH
48050: LD_INT 0
48052: EQUAL
48053: IFFALSE 48063
// btype := b_warehouse ;
48055: LD_ADDR_VAR 0 5
48059: PUSH
48060: LD_INT 1
48062: ST_TO_ADDR
// if btype = b_workshop then
48063: LD_VAR 0 5
48067: PUSH
48068: LD_INT 2
48070: EQUAL
48071: IFFALSE 48081
// btype := b_factory ;
48073: LD_ADDR_VAR 0 5
48077: PUSH
48078: LD_INT 3
48080: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48081: LD_VAR 0 5
48085: PPUSH
48086: LD_VAR 0 8
48090: PPUSH
48091: CALL_OW 323
48095: PUSH
48096: LD_INT 1
48098: EQUAL
48099: IFFALSE 48145
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48101: LD_ADDR_EXP 82
48105: PUSH
48106: LD_EXP 82
48110: PPUSH
48111: LD_VAR 0 3
48115: PUSH
48116: LD_EXP 82
48120: PUSH
48121: LD_VAR 0 3
48125: ARRAY
48126: PUSH
48127: LD_INT 1
48129: PLUS
48130: PUSH
48131: EMPTY
48132: LIST
48133: LIST
48134: PPUSH
48135: LD_VAR 0 1
48139: PPUSH
48140: CALL 54081 0 3
48144: ST_TO_ADDR
// exit ;
48145: POP
48146: POP
48147: GO 48462
// end ; if btype in [ b_bunker , b_turret ] then
48149: LD_VAR 0 5
48153: PUSH
48154: LD_INT 32
48156: PUSH
48157: LD_INT 33
48159: PUSH
48160: EMPTY
48161: LIST
48162: LIST
48163: IN
48164: IFFALSE 48454
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48166: LD_ADDR_EXP 58
48170: PUSH
48171: LD_EXP 58
48175: PPUSH
48176: LD_VAR 0 3
48180: PUSH
48181: LD_EXP 58
48185: PUSH
48186: LD_VAR 0 3
48190: ARRAY
48191: PUSH
48192: LD_INT 1
48194: PLUS
48195: PUSH
48196: EMPTY
48197: LIST
48198: LIST
48199: PPUSH
48200: LD_VAR 0 1
48204: PPUSH
48205: CALL 54081 0 3
48209: ST_TO_ADDR
// if btype = b_bunker then
48210: LD_VAR 0 5
48214: PUSH
48215: LD_INT 32
48217: EQUAL
48218: IFFALSE 48454
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48220: LD_ADDR_EXP 59
48224: PUSH
48225: LD_EXP 59
48229: PPUSH
48230: LD_VAR 0 3
48234: PUSH
48235: LD_EXP 59
48239: PUSH
48240: LD_VAR 0 3
48244: ARRAY
48245: PUSH
48246: LD_INT 1
48248: PLUS
48249: PUSH
48250: EMPTY
48251: LIST
48252: LIST
48253: PPUSH
48254: LD_VAR 0 1
48258: PPUSH
48259: CALL 54081 0 3
48263: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48264: LD_ADDR_VAR 0 6
48268: PUSH
48269: LD_EXP 50
48273: PUSH
48274: LD_VAR 0 3
48278: ARRAY
48279: PPUSH
48280: LD_INT 25
48282: PUSH
48283: LD_INT 1
48285: PUSH
48286: EMPTY
48287: LIST
48288: LIST
48289: PUSH
48290: LD_INT 3
48292: PUSH
48293: LD_INT 54
48295: PUSH
48296: EMPTY
48297: LIST
48298: PUSH
48299: EMPTY
48300: LIST
48301: LIST
48302: PUSH
48303: EMPTY
48304: LIST
48305: LIST
48306: PPUSH
48307: CALL_OW 72
48311: ST_TO_ADDR
// if tmp then
48312: LD_VAR 0 6
48316: IFFALSE 48322
// exit ;
48318: POP
48319: POP
48320: GO 48462
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48322: LD_ADDR_VAR 0 6
48326: PUSH
48327: LD_EXP 50
48331: PUSH
48332: LD_VAR 0 3
48336: ARRAY
48337: PPUSH
48338: LD_INT 2
48340: PUSH
48341: LD_INT 30
48343: PUSH
48344: LD_INT 4
48346: PUSH
48347: EMPTY
48348: LIST
48349: LIST
48350: PUSH
48351: LD_INT 30
48353: PUSH
48354: LD_INT 5
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: PUSH
48361: EMPTY
48362: LIST
48363: LIST
48364: LIST
48365: PPUSH
48366: CALL_OW 72
48370: ST_TO_ADDR
// if not tmp then
48371: LD_VAR 0 6
48375: NOT
48376: IFFALSE 48382
// exit ;
48378: POP
48379: POP
48380: GO 48462
// for j in tmp do
48382: LD_ADDR_VAR 0 4
48386: PUSH
48387: LD_VAR 0 6
48391: PUSH
48392: FOR_IN
48393: IFFALSE 48452
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48395: LD_ADDR_VAR 0 7
48399: PUSH
48400: LD_VAR 0 4
48404: PPUSH
48405: CALL_OW 313
48409: PPUSH
48410: LD_INT 25
48412: PUSH
48413: LD_INT 1
48415: PUSH
48416: EMPTY
48417: LIST
48418: LIST
48419: PPUSH
48420: CALL_OW 72
48424: ST_TO_ADDR
// if units then
48425: LD_VAR 0 7
48429: IFFALSE 48450
// begin ComExitBuilding ( units [ 1 ] ) ;
48431: LD_VAR 0 7
48435: PUSH
48436: LD_INT 1
48438: ARRAY
48439: PPUSH
48440: CALL_OW 122
// exit ;
48444: POP
48445: POP
48446: POP
48447: POP
48448: GO 48462
// end ; end ;
48450: GO 48392
48452: POP
48453: POP
// end ; end ; exit ;
48454: POP
48455: POP
48456: GO 48462
// end ; end ;
48458: GO 47816
48460: POP
48461: POP
// end ;
48462: LD_VAR 0 2
48466: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48467: LD_INT 0
48469: PPUSH
48470: PPUSH
48471: PPUSH
48472: PPUSH
48473: PPUSH
48474: PPUSH
48475: PPUSH
// if not mc_bases or not skirmish then
48476: LD_EXP 50
48480: NOT
48481: PUSH
48482: LD_EXP 48
48486: NOT
48487: OR
48488: IFFALSE 48492
// exit ;
48490: GO 48757
// btype := GetBType ( building ) ;
48492: LD_ADDR_VAR 0 6
48496: PUSH
48497: LD_VAR 0 1
48501: PPUSH
48502: CALL_OW 266
48506: ST_TO_ADDR
// x := GetX ( building ) ;
48507: LD_ADDR_VAR 0 7
48511: PUSH
48512: LD_VAR 0 1
48516: PPUSH
48517: CALL_OW 250
48521: ST_TO_ADDR
// y := GetY ( building ) ;
48522: LD_ADDR_VAR 0 8
48526: PUSH
48527: LD_VAR 0 1
48531: PPUSH
48532: CALL_OW 251
48536: ST_TO_ADDR
// d := GetDir ( building ) ;
48537: LD_ADDR_VAR 0 9
48541: PUSH
48542: LD_VAR 0 1
48546: PPUSH
48547: CALL_OW 254
48551: ST_TO_ADDR
// for i = 1 to mc_bases do
48552: LD_ADDR_VAR 0 4
48556: PUSH
48557: DOUBLE
48558: LD_INT 1
48560: DEC
48561: ST_TO_ADDR
48562: LD_EXP 50
48566: PUSH
48567: FOR_TO
48568: IFFALSE 48755
// begin if not mc_build_list [ i ] then
48570: LD_EXP 55
48574: PUSH
48575: LD_VAR 0 4
48579: ARRAY
48580: NOT
48581: IFFALSE 48585
// continue ;
48583: GO 48567
// for j := 1 to mc_build_list [ i ] do
48585: LD_ADDR_VAR 0 5
48589: PUSH
48590: DOUBLE
48591: LD_INT 1
48593: DEC
48594: ST_TO_ADDR
48595: LD_EXP 55
48599: PUSH
48600: LD_VAR 0 4
48604: ARRAY
48605: PUSH
48606: FOR_TO
48607: IFFALSE 48751
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48609: LD_VAR 0 6
48613: PUSH
48614: LD_VAR 0 7
48618: PUSH
48619: LD_VAR 0 8
48623: PUSH
48624: LD_VAR 0 9
48628: PUSH
48629: EMPTY
48630: LIST
48631: LIST
48632: LIST
48633: LIST
48634: PPUSH
48635: LD_EXP 55
48639: PUSH
48640: LD_VAR 0 4
48644: ARRAY
48645: PUSH
48646: LD_VAR 0 5
48650: ARRAY
48651: PPUSH
48652: CALL 60638 0 2
48656: IFFALSE 48749
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48658: LD_ADDR_EXP 55
48662: PUSH
48663: LD_EXP 55
48667: PPUSH
48668: LD_VAR 0 4
48672: PPUSH
48673: LD_EXP 55
48677: PUSH
48678: LD_VAR 0 4
48682: ARRAY
48683: PPUSH
48684: LD_VAR 0 5
48688: PPUSH
48689: CALL_OW 3
48693: PPUSH
48694: CALL_OW 1
48698: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48699: LD_ADDR_EXP 57
48703: PUSH
48704: LD_EXP 57
48708: PPUSH
48709: LD_VAR 0 4
48713: PUSH
48714: LD_EXP 57
48718: PUSH
48719: LD_VAR 0 4
48723: ARRAY
48724: PUSH
48725: LD_INT 1
48727: PLUS
48728: PUSH
48729: EMPTY
48730: LIST
48731: LIST
48732: PPUSH
48733: LD_VAR 0 1
48737: PPUSH
48738: CALL 54081 0 3
48742: ST_TO_ADDR
// exit ;
48743: POP
48744: POP
48745: POP
48746: POP
48747: GO 48757
// end ;
48749: GO 48606
48751: POP
48752: POP
// end ;
48753: GO 48567
48755: POP
48756: POP
// end ;
48757: LD_VAR 0 3
48761: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48762: LD_INT 0
48764: PPUSH
48765: PPUSH
48766: PPUSH
// if not mc_bases or not skirmish then
48767: LD_EXP 50
48771: NOT
48772: PUSH
48773: LD_EXP 48
48777: NOT
48778: OR
48779: IFFALSE 48783
// exit ;
48781: GO 48973
// for i = 1 to mc_bases do
48783: LD_ADDR_VAR 0 4
48787: PUSH
48788: DOUBLE
48789: LD_INT 1
48791: DEC
48792: ST_TO_ADDR
48793: LD_EXP 50
48797: PUSH
48798: FOR_TO
48799: IFFALSE 48886
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48801: LD_VAR 0 1
48805: PUSH
48806: LD_EXP 58
48810: PUSH
48811: LD_VAR 0 4
48815: ARRAY
48816: IN
48817: PUSH
48818: LD_VAR 0 1
48822: PUSH
48823: LD_EXP 59
48827: PUSH
48828: LD_VAR 0 4
48832: ARRAY
48833: IN
48834: NOT
48835: AND
48836: IFFALSE 48884
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48838: LD_ADDR_EXP 59
48842: PUSH
48843: LD_EXP 59
48847: PPUSH
48848: LD_VAR 0 4
48852: PUSH
48853: LD_EXP 59
48857: PUSH
48858: LD_VAR 0 4
48862: ARRAY
48863: PUSH
48864: LD_INT 1
48866: PLUS
48867: PUSH
48868: EMPTY
48869: LIST
48870: LIST
48871: PPUSH
48872: LD_VAR 0 1
48876: PPUSH
48877: CALL 54081 0 3
48881: ST_TO_ADDR
// break ;
48882: GO 48886
// end ; end ;
48884: GO 48798
48886: POP
48887: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48888: LD_VAR 0 1
48892: PPUSH
48893: CALL_OW 257
48897: PUSH
48898: LD_EXP 76
48902: IN
48903: PUSH
48904: LD_VAR 0 1
48908: PPUSH
48909: CALL_OW 266
48913: PUSH
48914: LD_INT 5
48916: EQUAL
48917: AND
48918: PUSH
48919: LD_VAR 0 2
48923: PPUSH
48924: CALL_OW 110
48928: PUSH
48929: LD_INT 18
48931: NONEQUAL
48932: AND
48933: IFFALSE 48973
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48935: LD_VAR 0 2
48939: PPUSH
48940: CALL_OW 257
48944: PUSH
48945: LD_INT 5
48947: PUSH
48948: LD_INT 8
48950: PUSH
48951: LD_INT 9
48953: PUSH
48954: EMPTY
48955: LIST
48956: LIST
48957: LIST
48958: IN
48959: IFFALSE 48973
// SetClass ( unit , 1 ) ;
48961: LD_VAR 0 2
48965: PPUSH
48966: LD_INT 1
48968: PPUSH
48969: CALL_OW 336
// end ;
48973: LD_VAR 0 3
48977: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48978: LD_INT 0
48980: PPUSH
48981: PPUSH
// if not mc_bases or not skirmish then
48982: LD_EXP 50
48986: NOT
48987: PUSH
48988: LD_EXP 48
48992: NOT
48993: OR
48994: IFFALSE 48998
// exit ;
48996: GO 49114
// if GetLives ( abandoned_vehicle ) > 250 then
48998: LD_VAR 0 2
49002: PPUSH
49003: CALL_OW 256
49007: PUSH
49008: LD_INT 250
49010: GREATER
49011: IFFALSE 49015
// exit ;
49013: GO 49114
// for i = 1 to mc_bases do
49015: LD_ADDR_VAR 0 6
49019: PUSH
49020: DOUBLE
49021: LD_INT 1
49023: DEC
49024: ST_TO_ADDR
49025: LD_EXP 50
49029: PUSH
49030: FOR_TO
49031: IFFALSE 49112
// begin if driver in mc_bases [ i ] then
49033: LD_VAR 0 1
49037: PUSH
49038: LD_EXP 50
49042: PUSH
49043: LD_VAR 0 6
49047: ARRAY
49048: IN
49049: IFFALSE 49110
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49051: LD_VAR 0 1
49055: PPUSH
49056: LD_EXP 50
49060: PUSH
49061: LD_VAR 0 6
49065: ARRAY
49066: PPUSH
49067: LD_INT 2
49069: PUSH
49070: LD_INT 30
49072: PUSH
49073: LD_INT 0
49075: PUSH
49076: EMPTY
49077: LIST
49078: LIST
49079: PUSH
49080: LD_INT 30
49082: PUSH
49083: LD_INT 1
49085: PUSH
49086: EMPTY
49087: LIST
49088: LIST
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: LIST
49094: PPUSH
49095: CALL_OW 72
49099: PUSH
49100: LD_INT 1
49102: ARRAY
49103: PPUSH
49104: CALL 87698 0 2
// break ;
49108: GO 49112
// end ; end ;
49110: GO 49030
49112: POP
49113: POP
// end ; end_of_file
49114: LD_VAR 0 5
49118: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49119: LD_INT 0
49121: PPUSH
49122: PPUSH
// if exist_mode then
49123: LD_VAR 0 2
49127: IFFALSE 49152
// unit := CreateCharacter ( prefix & ident ) else
49129: LD_ADDR_VAR 0 5
49133: PUSH
49134: LD_VAR 0 3
49138: PUSH
49139: LD_VAR 0 1
49143: STR
49144: PPUSH
49145: CALL_OW 34
49149: ST_TO_ADDR
49150: GO 49167
// unit := NewCharacter ( ident ) ;
49152: LD_ADDR_VAR 0 5
49156: PUSH
49157: LD_VAR 0 1
49161: PPUSH
49162: CALL_OW 25
49166: ST_TO_ADDR
// result := unit ;
49167: LD_ADDR_VAR 0 4
49171: PUSH
49172: LD_VAR 0 5
49176: ST_TO_ADDR
// end ;
49177: LD_VAR 0 4
49181: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49182: LD_INT 0
49184: PPUSH
49185: PPUSH
// if not side or not nation then
49186: LD_VAR 0 1
49190: NOT
49191: PUSH
49192: LD_VAR 0 2
49196: NOT
49197: OR
49198: IFFALSE 49202
// exit ;
49200: GO 49970
// case nation of nation_american :
49202: LD_VAR 0 2
49206: PUSH
49207: LD_INT 1
49209: DOUBLE
49210: EQUAL
49211: IFTRUE 49215
49213: GO 49429
49215: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
49216: LD_ADDR_VAR 0 4
49220: PUSH
49221: LD_INT 35
49223: PUSH
49224: LD_INT 45
49226: PUSH
49227: LD_INT 46
49229: PUSH
49230: LD_INT 47
49232: PUSH
49233: LD_INT 82
49235: PUSH
49236: LD_INT 83
49238: PUSH
49239: LD_INT 84
49241: PUSH
49242: LD_INT 85
49244: PUSH
49245: LD_INT 86
49247: PUSH
49248: LD_INT 1
49250: PUSH
49251: LD_INT 2
49253: PUSH
49254: LD_INT 6
49256: PUSH
49257: LD_INT 15
49259: PUSH
49260: LD_INT 16
49262: PUSH
49263: LD_INT 7
49265: PUSH
49266: LD_INT 12
49268: PUSH
49269: LD_INT 13
49271: PUSH
49272: LD_INT 10
49274: PUSH
49275: LD_INT 14
49277: PUSH
49278: LD_INT 20
49280: PUSH
49281: LD_INT 21
49283: PUSH
49284: LD_INT 22
49286: PUSH
49287: LD_INT 25
49289: PUSH
49290: LD_INT 32
49292: PUSH
49293: LD_INT 27
49295: PUSH
49296: LD_INT 36
49298: PUSH
49299: LD_INT 69
49301: PUSH
49302: LD_INT 39
49304: PUSH
49305: LD_INT 34
49307: PUSH
49308: LD_INT 40
49310: PUSH
49311: LD_INT 48
49313: PUSH
49314: LD_INT 49
49316: PUSH
49317: LD_INT 50
49319: PUSH
49320: LD_INT 51
49322: PUSH
49323: LD_INT 52
49325: PUSH
49326: LD_INT 53
49328: PUSH
49329: LD_INT 54
49331: PUSH
49332: LD_INT 55
49334: PUSH
49335: LD_INT 56
49337: PUSH
49338: LD_INT 57
49340: PUSH
49341: LD_INT 58
49343: PUSH
49344: LD_INT 59
49346: PUSH
49347: LD_INT 60
49349: PUSH
49350: LD_INT 61
49352: PUSH
49353: LD_INT 62
49355: PUSH
49356: LD_INT 80
49358: PUSH
49359: LD_INT 82
49361: PUSH
49362: LD_INT 83
49364: PUSH
49365: LD_INT 84
49367: PUSH
49368: LD_INT 85
49370: PUSH
49371: LD_INT 86
49373: PUSH
49374: EMPTY
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: LIST
49380: LIST
49381: LIST
49382: LIST
49383: LIST
49384: LIST
49385: LIST
49386: LIST
49387: LIST
49388: LIST
49389: LIST
49390: LIST
49391: LIST
49392: LIST
49393: LIST
49394: LIST
49395: LIST
49396: LIST
49397: LIST
49398: LIST
49399: LIST
49400: LIST
49401: LIST
49402: LIST
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: LIST
49410: LIST
49411: LIST
49412: LIST
49413: LIST
49414: LIST
49415: LIST
49416: LIST
49417: LIST
49418: LIST
49419: LIST
49420: LIST
49421: LIST
49422: LIST
49423: LIST
49424: LIST
49425: LIST
49426: ST_TO_ADDR
49427: GO 49894
49429: LD_INT 2
49431: DOUBLE
49432: EQUAL
49433: IFTRUE 49437
49435: GO 49663
49437: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
49438: LD_ADDR_VAR 0 4
49442: PUSH
49443: LD_INT 35
49445: PUSH
49446: LD_INT 45
49448: PUSH
49449: LD_INT 46
49451: PUSH
49452: LD_INT 47
49454: PUSH
49455: LD_INT 82
49457: PUSH
49458: LD_INT 83
49460: PUSH
49461: LD_INT 84
49463: PUSH
49464: LD_INT 85
49466: PUSH
49467: LD_INT 87
49469: PUSH
49470: LD_INT 70
49472: PUSH
49473: LD_INT 1
49475: PUSH
49476: LD_INT 11
49478: PUSH
49479: LD_INT 3
49481: PUSH
49482: LD_INT 4
49484: PUSH
49485: LD_INT 5
49487: PUSH
49488: LD_INT 6
49490: PUSH
49491: LD_INT 15
49493: PUSH
49494: LD_INT 18
49496: PUSH
49497: LD_INT 7
49499: PUSH
49500: LD_INT 17
49502: PUSH
49503: LD_INT 8
49505: PUSH
49506: LD_INT 20
49508: PUSH
49509: LD_INT 21
49511: PUSH
49512: LD_INT 22
49514: PUSH
49515: LD_INT 72
49517: PUSH
49518: LD_INT 26
49520: PUSH
49521: LD_INT 69
49523: PUSH
49524: LD_INT 39
49526: PUSH
49527: LD_INT 40
49529: PUSH
49530: LD_INT 41
49532: PUSH
49533: LD_INT 42
49535: PUSH
49536: LD_INT 43
49538: PUSH
49539: LD_INT 48
49541: PUSH
49542: LD_INT 49
49544: PUSH
49545: LD_INT 50
49547: PUSH
49548: LD_INT 51
49550: PUSH
49551: LD_INT 52
49553: PUSH
49554: LD_INT 53
49556: PUSH
49557: LD_INT 54
49559: PUSH
49560: LD_INT 55
49562: PUSH
49563: LD_INT 56
49565: PUSH
49566: LD_INT 60
49568: PUSH
49569: LD_INT 61
49571: PUSH
49572: LD_INT 62
49574: PUSH
49575: LD_INT 66
49577: PUSH
49578: LD_INT 67
49580: PUSH
49581: LD_INT 68
49583: PUSH
49584: LD_INT 81
49586: PUSH
49587: LD_INT 82
49589: PUSH
49590: LD_INT 83
49592: PUSH
49593: LD_INT 84
49595: PUSH
49596: LD_INT 85
49598: PUSH
49599: LD_INT 87
49601: PUSH
49602: LD_INT 88
49604: PUSH
49605: EMPTY
49606: LIST
49607: LIST
49608: LIST
49609: LIST
49610: LIST
49611: LIST
49612: LIST
49613: LIST
49614: LIST
49615: LIST
49616: LIST
49617: LIST
49618: LIST
49619: LIST
49620: LIST
49621: LIST
49622: LIST
49623: LIST
49624: LIST
49625: LIST
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: LIST
49631: LIST
49632: LIST
49633: LIST
49634: LIST
49635: LIST
49636: LIST
49637: LIST
49638: LIST
49639: LIST
49640: LIST
49641: LIST
49642: LIST
49643: LIST
49644: LIST
49645: LIST
49646: LIST
49647: LIST
49648: LIST
49649: LIST
49650: LIST
49651: LIST
49652: LIST
49653: LIST
49654: LIST
49655: LIST
49656: LIST
49657: LIST
49658: LIST
49659: LIST
49660: ST_TO_ADDR
49661: GO 49894
49663: LD_INT 3
49665: DOUBLE
49666: EQUAL
49667: IFTRUE 49671
49669: GO 49893
49671: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49672: LD_ADDR_VAR 0 4
49676: PUSH
49677: LD_INT 46
49679: PUSH
49680: LD_INT 47
49682: PUSH
49683: LD_INT 1
49685: PUSH
49686: LD_INT 2
49688: PUSH
49689: LD_INT 82
49691: PUSH
49692: LD_INT 83
49694: PUSH
49695: LD_INT 84
49697: PUSH
49698: LD_INT 85
49700: PUSH
49701: LD_INT 86
49703: PUSH
49704: LD_INT 11
49706: PUSH
49707: LD_INT 9
49709: PUSH
49710: LD_INT 20
49712: PUSH
49713: LD_INT 19
49715: PUSH
49716: LD_INT 21
49718: PUSH
49719: LD_INT 24
49721: PUSH
49722: LD_INT 22
49724: PUSH
49725: LD_INT 25
49727: PUSH
49728: LD_INT 28
49730: PUSH
49731: LD_INT 29
49733: PUSH
49734: LD_INT 30
49736: PUSH
49737: LD_INT 31
49739: PUSH
49740: LD_INT 37
49742: PUSH
49743: LD_INT 38
49745: PUSH
49746: LD_INT 32
49748: PUSH
49749: LD_INT 27
49751: PUSH
49752: LD_INT 33
49754: PUSH
49755: LD_INT 69
49757: PUSH
49758: LD_INT 39
49760: PUSH
49761: LD_INT 34
49763: PUSH
49764: LD_INT 40
49766: PUSH
49767: LD_INT 71
49769: PUSH
49770: LD_INT 23
49772: PUSH
49773: LD_INT 44
49775: PUSH
49776: LD_INT 48
49778: PUSH
49779: LD_INT 49
49781: PUSH
49782: LD_INT 50
49784: PUSH
49785: LD_INT 51
49787: PUSH
49788: LD_INT 52
49790: PUSH
49791: LD_INT 53
49793: PUSH
49794: LD_INT 54
49796: PUSH
49797: LD_INT 55
49799: PUSH
49800: LD_INT 56
49802: PUSH
49803: LD_INT 57
49805: PUSH
49806: LD_INT 58
49808: PUSH
49809: LD_INT 59
49811: PUSH
49812: LD_INT 63
49814: PUSH
49815: LD_INT 64
49817: PUSH
49818: LD_INT 65
49820: PUSH
49821: LD_INT 82
49823: PUSH
49824: LD_INT 83
49826: PUSH
49827: LD_INT 84
49829: PUSH
49830: LD_INT 85
49832: PUSH
49833: LD_INT 86
49835: PUSH
49836: EMPTY
49837: LIST
49838: LIST
49839: LIST
49840: LIST
49841: LIST
49842: LIST
49843: LIST
49844: LIST
49845: LIST
49846: LIST
49847: LIST
49848: LIST
49849: LIST
49850: LIST
49851: LIST
49852: LIST
49853: LIST
49854: LIST
49855: LIST
49856: LIST
49857: LIST
49858: LIST
49859: LIST
49860: LIST
49861: LIST
49862: LIST
49863: LIST
49864: LIST
49865: LIST
49866: LIST
49867: LIST
49868: LIST
49869: LIST
49870: LIST
49871: LIST
49872: LIST
49873: LIST
49874: LIST
49875: LIST
49876: LIST
49877: LIST
49878: LIST
49879: LIST
49880: LIST
49881: LIST
49882: LIST
49883: LIST
49884: LIST
49885: LIST
49886: LIST
49887: LIST
49888: LIST
49889: LIST
49890: ST_TO_ADDR
49891: GO 49894
49893: POP
// if state > - 1 and state < 3 then
49894: LD_VAR 0 3
49898: PUSH
49899: LD_INT 1
49901: NEG
49902: GREATER
49903: PUSH
49904: LD_VAR 0 3
49908: PUSH
49909: LD_INT 3
49911: LESS
49912: AND
49913: IFFALSE 49970
// for i in result do
49915: LD_ADDR_VAR 0 5
49919: PUSH
49920: LD_VAR 0 4
49924: PUSH
49925: FOR_IN
49926: IFFALSE 49968
// if GetTech ( i , side ) <> state then
49928: LD_VAR 0 5
49932: PPUSH
49933: LD_VAR 0 1
49937: PPUSH
49938: CALL_OW 321
49942: PUSH
49943: LD_VAR 0 3
49947: NONEQUAL
49948: IFFALSE 49966
// result := result diff i ;
49950: LD_ADDR_VAR 0 4
49954: PUSH
49955: LD_VAR 0 4
49959: PUSH
49960: LD_VAR 0 5
49964: DIFF
49965: ST_TO_ADDR
49966: GO 49925
49968: POP
49969: POP
// end ;
49970: LD_VAR 0 4
49974: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49975: LD_INT 0
49977: PPUSH
49978: PPUSH
49979: PPUSH
// result := true ;
49980: LD_ADDR_VAR 0 3
49984: PUSH
49985: LD_INT 1
49987: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49988: LD_ADDR_VAR 0 5
49992: PUSH
49993: LD_VAR 0 2
49997: PPUSH
49998: CALL_OW 480
50002: ST_TO_ADDR
// if not tmp then
50003: LD_VAR 0 5
50007: NOT
50008: IFFALSE 50012
// exit ;
50010: GO 50061
// for i in tmp do
50012: LD_ADDR_VAR 0 4
50016: PUSH
50017: LD_VAR 0 5
50021: PUSH
50022: FOR_IN
50023: IFFALSE 50059
// if GetTech ( i , side ) <> state_researched then
50025: LD_VAR 0 4
50029: PPUSH
50030: LD_VAR 0 1
50034: PPUSH
50035: CALL_OW 321
50039: PUSH
50040: LD_INT 2
50042: NONEQUAL
50043: IFFALSE 50057
// begin result := false ;
50045: LD_ADDR_VAR 0 3
50049: PUSH
50050: LD_INT 0
50052: ST_TO_ADDR
// exit ;
50053: POP
50054: POP
50055: GO 50061
// end ;
50057: GO 50022
50059: POP
50060: POP
// end ;
50061: LD_VAR 0 3
50065: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50066: LD_INT 0
50068: PPUSH
50069: PPUSH
50070: PPUSH
50071: PPUSH
50072: PPUSH
50073: PPUSH
50074: PPUSH
50075: PPUSH
50076: PPUSH
50077: PPUSH
50078: PPUSH
50079: PPUSH
50080: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50081: LD_VAR 0 1
50085: NOT
50086: PUSH
50087: LD_VAR 0 1
50091: PPUSH
50092: CALL_OW 257
50096: PUSH
50097: LD_INT 9
50099: NONEQUAL
50100: OR
50101: IFFALSE 50105
// exit ;
50103: GO 50678
// side := GetSide ( unit ) ;
50105: LD_ADDR_VAR 0 9
50109: PUSH
50110: LD_VAR 0 1
50114: PPUSH
50115: CALL_OW 255
50119: ST_TO_ADDR
// tech_space := tech_spacanom ;
50120: LD_ADDR_VAR 0 12
50124: PUSH
50125: LD_INT 29
50127: ST_TO_ADDR
// tech_time := tech_taurad ;
50128: LD_ADDR_VAR 0 13
50132: PUSH
50133: LD_INT 28
50135: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50136: LD_ADDR_VAR 0 11
50140: PUSH
50141: LD_VAR 0 1
50145: PPUSH
50146: CALL_OW 310
50150: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50151: LD_VAR 0 11
50155: PPUSH
50156: CALL_OW 247
50160: PUSH
50161: LD_INT 2
50163: EQUAL
50164: IFFALSE 50168
// exit ;
50166: GO 50678
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50168: LD_ADDR_VAR 0 8
50172: PUSH
50173: LD_INT 81
50175: PUSH
50176: LD_VAR 0 9
50180: PUSH
50181: EMPTY
50182: LIST
50183: LIST
50184: PUSH
50185: LD_INT 3
50187: PUSH
50188: LD_INT 21
50190: PUSH
50191: LD_INT 3
50193: PUSH
50194: EMPTY
50195: LIST
50196: LIST
50197: PUSH
50198: EMPTY
50199: LIST
50200: LIST
50201: PUSH
50202: EMPTY
50203: LIST
50204: LIST
50205: PPUSH
50206: CALL_OW 69
50210: ST_TO_ADDR
// if not tmp then
50211: LD_VAR 0 8
50215: NOT
50216: IFFALSE 50220
// exit ;
50218: GO 50678
// if in_unit then
50220: LD_VAR 0 11
50224: IFFALSE 50248
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50226: LD_ADDR_VAR 0 10
50230: PUSH
50231: LD_VAR 0 8
50235: PPUSH
50236: LD_VAR 0 11
50240: PPUSH
50241: CALL_OW 74
50245: ST_TO_ADDR
50246: GO 50268
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50248: LD_ADDR_VAR 0 10
50252: PUSH
50253: LD_VAR 0 8
50257: PPUSH
50258: LD_VAR 0 1
50262: PPUSH
50263: CALL_OW 74
50267: ST_TO_ADDR
// if not enemy then
50268: LD_VAR 0 10
50272: NOT
50273: IFFALSE 50277
// exit ;
50275: GO 50678
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50277: LD_VAR 0 11
50281: PUSH
50282: LD_VAR 0 11
50286: PPUSH
50287: LD_VAR 0 10
50291: PPUSH
50292: CALL_OW 296
50296: PUSH
50297: LD_INT 13
50299: GREATER
50300: AND
50301: PUSH
50302: LD_VAR 0 1
50306: PPUSH
50307: LD_VAR 0 10
50311: PPUSH
50312: CALL_OW 296
50316: PUSH
50317: LD_INT 12
50319: GREATER
50320: OR
50321: IFFALSE 50325
// exit ;
50323: GO 50678
// missile := [ 1 ] ;
50325: LD_ADDR_VAR 0 14
50329: PUSH
50330: LD_INT 1
50332: PUSH
50333: EMPTY
50334: LIST
50335: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50336: LD_VAR 0 9
50340: PPUSH
50341: LD_VAR 0 12
50345: PPUSH
50346: CALL_OW 325
50350: IFFALSE 50379
// missile := Replace ( missile , missile + 1 , 2 ) ;
50352: LD_ADDR_VAR 0 14
50356: PUSH
50357: LD_VAR 0 14
50361: PPUSH
50362: LD_VAR 0 14
50366: PUSH
50367: LD_INT 1
50369: PLUS
50370: PPUSH
50371: LD_INT 2
50373: PPUSH
50374: CALL_OW 1
50378: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50379: LD_VAR 0 9
50383: PPUSH
50384: LD_VAR 0 13
50388: PPUSH
50389: CALL_OW 325
50393: PUSH
50394: LD_VAR 0 10
50398: PPUSH
50399: CALL_OW 255
50403: PPUSH
50404: LD_VAR 0 13
50408: PPUSH
50409: CALL_OW 325
50413: NOT
50414: AND
50415: IFFALSE 50444
// missile := Replace ( missile , missile + 1 , 3 ) ;
50417: LD_ADDR_VAR 0 14
50421: PUSH
50422: LD_VAR 0 14
50426: PPUSH
50427: LD_VAR 0 14
50431: PUSH
50432: LD_INT 1
50434: PLUS
50435: PPUSH
50436: LD_INT 3
50438: PPUSH
50439: CALL_OW 1
50443: ST_TO_ADDR
// if missile < 2 then
50444: LD_VAR 0 14
50448: PUSH
50449: LD_INT 2
50451: LESS
50452: IFFALSE 50456
// exit ;
50454: GO 50678
// x := GetX ( enemy ) ;
50456: LD_ADDR_VAR 0 4
50460: PUSH
50461: LD_VAR 0 10
50465: PPUSH
50466: CALL_OW 250
50470: ST_TO_ADDR
// y := GetY ( enemy ) ;
50471: LD_ADDR_VAR 0 5
50475: PUSH
50476: LD_VAR 0 10
50480: PPUSH
50481: CALL_OW 251
50485: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50486: LD_ADDR_VAR 0 6
50490: PUSH
50491: LD_VAR 0 4
50495: PUSH
50496: LD_INT 1
50498: NEG
50499: PPUSH
50500: LD_INT 1
50502: PPUSH
50503: CALL_OW 12
50507: PLUS
50508: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50509: LD_ADDR_VAR 0 7
50513: PUSH
50514: LD_VAR 0 5
50518: PUSH
50519: LD_INT 1
50521: NEG
50522: PPUSH
50523: LD_INT 1
50525: PPUSH
50526: CALL_OW 12
50530: PLUS
50531: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50532: LD_VAR 0 6
50536: PPUSH
50537: LD_VAR 0 7
50541: PPUSH
50542: CALL_OW 488
50546: NOT
50547: IFFALSE 50569
// begin _x := x ;
50549: LD_ADDR_VAR 0 6
50553: PUSH
50554: LD_VAR 0 4
50558: ST_TO_ADDR
// _y := y ;
50559: LD_ADDR_VAR 0 7
50563: PUSH
50564: LD_VAR 0 5
50568: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50569: LD_ADDR_VAR 0 3
50573: PUSH
50574: LD_INT 1
50576: PPUSH
50577: LD_VAR 0 14
50581: PPUSH
50582: CALL_OW 12
50586: ST_TO_ADDR
// case i of 1 :
50587: LD_VAR 0 3
50591: PUSH
50592: LD_INT 1
50594: DOUBLE
50595: EQUAL
50596: IFTRUE 50600
50598: GO 50617
50600: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50601: LD_VAR 0 1
50605: PPUSH
50606: LD_VAR 0 10
50610: PPUSH
50611: CALL_OW 115
50615: GO 50678
50617: LD_INT 2
50619: DOUBLE
50620: EQUAL
50621: IFTRUE 50625
50623: GO 50647
50625: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50626: LD_VAR 0 1
50630: PPUSH
50631: LD_VAR 0 6
50635: PPUSH
50636: LD_VAR 0 7
50640: PPUSH
50641: CALL_OW 153
50645: GO 50678
50647: LD_INT 3
50649: DOUBLE
50650: EQUAL
50651: IFTRUE 50655
50653: GO 50677
50655: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50656: LD_VAR 0 1
50660: PPUSH
50661: LD_VAR 0 6
50665: PPUSH
50666: LD_VAR 0 7
50670: PPUSH
50671: CALL_OW 154
50675: GO 50678
50677: POP
// end ;
50678: LD_VAR 0 2
50682: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50683: LD_INT 0
50685: PPUSH
50686: PPUSH
50687: PPUSH
50688: PPUSH
50689: PPUSH
50690: PPUSH
// if not unit or not building then
50691: LD_VAR 0 1
50695: NOT
50696: PUSH
50697: LD_VAR 0 2
50701: NOT
50702: OR
50703: IFFALSE 50707
// exit ;
50705: GO 50865
// x := GetX ( building ) ;
50707: LD_ADDR_VAR 0 5
50711: PUSH
50712: LD_VAR 0 2
50716: PPUSH
50717: CALL_OW 250
50721: ST_TO_ADDR
// y := GetY ( building ) ;
50722: LD_ADDR_VAR 0 6
50726: PUSH
50727: LD_VAR 0 2
50731: PPUSH
50732: CALL_OW 251
50736: ST_TO_ADDR
// for i = 0 to 5 do
50737: LD_ADDR_VAR 0 4
50741: PUSH
50742: DOUBLE
50743: LD_INT 0
50745: DEC
50746: ST_TO_ADDR
50747: LD_INT 5
50749: PUSH
50750: FOR_TO
50751: IFFALSE 50863
// begin _x := ShiftX ( x , i , 3 ) ;
50753: LD_ADDR_VAR 0 7
50757: PUSH
50758: LD_VAR 0 5
50762: PPUSH
50763: LD_VAR 0 4
50767: PPUSH
50768: LD_INT 3
50770: PPUSH
50771: CALL_OW 272
50775: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50776: LD_ADDR_VAR 0 8
50780: PUSH
50781: LD_VAR 0 6
50785: PPUSH
50786: LD_VAR 0 4
50790: PPUSH
50791: LD_INT 3
50793: PPUSH
50794: CALL_OW 273
50798: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50799: LD_VAR 0 7
50803: PPUSH
50804: LD_VAR 0 8
50808: PPUSH
50809: CALL_OW 488
50813: NOT
50814: IFFALSE 50818
// continue ;
50816: GO 50750
// if HexInfo ( _x , _y ) = 0 then
50818: LD_VAR 0 7
50822: PPUSH
50823: LD_VAR 0 8
50827: PPUSH
50828: CALL_OW 428
50832: PUSH
50833: LD_INT 0
50835: EQUAL
50836: IFFALSE 50861
// begin ComMoveXY ( unit , _x , _y ) ;
50838: LD_VAR 0 1
50842: PPUSH
50843: LD_VAR 0 7
50847: PPUSH
50848: LD_VAR 0 8
50852: PPUSH
50853: CALL_OW 111
// exit ;
50857: POP
50858: POP
50859: GO 50865
// end ; end ;
50861: GO 50750
50863: POP
50864: POP
// end ;
50865: LD_VAR 0 3
50869: RET
// export function ScanBase ( side , base_area ) ; begin
50870: LD_INT 0
50872: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50873: LD_ADDR_VAR 0 3
50877: PUSH
50878: LD_VAR 0 2
50882: PPUSH
50883: LD_INT 81
50885: PUSH
50886: LD_VAR 0 1
50890: PUSH
50891: EMPTY
50892: LIST
50893: LIST
50894: PPUSH
50895: CALL_OW 70
50899: ST_TO_ADDR
// end ;
50900: LD_VAR 0 3
50904: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50905: LD_INT 0
50907: PPUSH
50908: PPUSH
50909: PPUSH
50910: PPUSH
// result := false ;
50911: LD_ADDR_VAR 0 2
50915: PUSH
50916: LD_INT 0
50918: ST_TO_ADDR
// side := GetSide ( unit ) ;
50919: LD_ADDR_VAR 0 3
50923: PUSH
50924: LD_VAR 0 1
50928: PPUSH
50929: CALL_OW 255
50933: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50934: LD_ADDR_VAR 0 4
50938: PUSH
50939: LD_VAR 0 1
50943: PPUSH
50944: CALL_OW 248
50948: ST_TO_ADDR
// case nat of 1 :
50949: LD_VAR 0 4
50953: PUSH
50954: LD_INT 1
50956: DOUBLE
50957: EQUAL
50958: IFTRUE 50962
50960: GO 50973
50962: POP
// tech := tech_lassight ; 2 :
50963: LD_ADDR_VAR 0 5
50967: PUSH
50968: LD_INT 12
50970: ST_TO_ADDR
50971: GO 51012
50973: LD_INT 2
50975: DOUBLE
50976: EQUAL
50977: IFTRUE 50981
50979: GO 50992
50981: POP
// tech := tech_mortar ; 3 :
50982: LD_ADDR_VAR 0 5
50986: PUSH
50987: LD_INT 41
50989: ST_TO_ADDR
50990: GO 51012
50992: LD_INT 3
50994: DOUBLE
50995: EQUAL
50996: IFTRUE 51000
50998: GO 51011
51000: POP
// tech := tech_bazooka ; end ;
51001: LD_ADDR_VAR 0 5
51005: PUSH
51006: LD_INT 44
51008: ST_TO_ADDR
51009: GO 51012
51011: POP
// if Researched ( side , tech ) then
51012: LD_VAR 0 3
51016: PPUSH
51017: LD_VAR 0 5
51021: PPUSH
51022: CALL_OW 325
51026: IFFALSE 51053
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51028: LD_ADDR_VAR 0 2
51032: PUSH
51033: LD_INT 5
51035: PUSH
51036: LD_INT 8
51038: PUSH
51039: LD_INT 9
51041: PUSH
51042: EMPTY
51043: LIST
51044: LIST
51045: LIST
51046: PUSH
51047: LD_VAR 0 4
51051: ARRAY
51052: ST_TO_ADDR
// end ;
51053: LD_VAR 0 2
51057: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51058: LD_INT 0
51060: PPUSH
51061: PPUSH
51062: PPUSH
// if not mines then
51063: LD_VAR 0 2
51067: NOT
51068: IFFALSE 51072
// exit ;
51070: GO 51216
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51072: LD_ADDR_VAR 0 5
51076: PUSH
51077: LD_INT 81
51079: PUSH
51080: LD_VAR 0 1
51084: PUSH
51085: EMPTY
51086: LIST
51087: LIST
51088: PUSH
51089: LD_INT 3
51091: PUSH
51092: LD_INT 21
51094: PUSH
51095: LD_INT 3
51097: PUSH
51098: EMPTY
51099: LIST
51100: LIST
51101: PUSH
51102: EMPTY
51103: LIST
51104: LIST
51105: PUSH
51106: EMPTY
51107: LIST
51108: LIST
51109: PPUSH
51110: CALL_OW 69
51114: ST_TO_ADDR
// for i in mines do
51115: LD_ADDR_VAR 0 4
51119: PUSH
51120: LD_VAR 0 2
51124: PUSH
51125: FOR_IN
51126: IFFALSE 51214
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51128: LD_VAR 0 4
51132: PUSH
51133: LD_INT 1
51135: ARRAY
51136: PPUSH
51137: LD_VAR 0 4
51141: PUSH
51142: LD_INT 2
51144: ARRAY
51145: PPUSH
51146: CALL_OW 458
51150: NOT
51151: IFFALSE 51155
// continue ;
51153: GO 51125
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51155: LD_VAR 0 4
51159: PUSH
51160: LD_INT 1
51162: ARRAY
51163: PPUSH
51164: LD_VAR 0 4
51168: PUSH
51169: LD_INT 2
51171: ARRAY
51172: PPUSH
51173: CALL_OW 428
51177: PUSH
51178: LD_VAR 0 5
51182: IN
51183: IFFALSE 51212
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51185: LD_VAR 0 4
51189: PUSH
51190: LD_INT 1
51192: ARRAY
51193: PPUSH
51194: LD_VAR 0 4
51198: PUSH
51199: LD_INT 2
51201: ARRAY
51202: PPUSH
51203: LD_VAR 0 1
51207: PPUSH
51208: CALL_OW 456
// end ;
51212: GO 51125
51214: POP
51215: POP
// end ;
51216: LD_VAR 0 3
51220: RET
// export function Count ( array ) ; begin
51221: LD_INT 0
51223: PPUSH
// result := array + 0 ;
51224: LD_ADDR_VAR 0 2
51228: PUSH
51229: LD_VAR 0 1
51233: PUSH
51234: LD_INT 0
51236: PLUS
51237: ST_TO_ADDR
// end ;
51238: LD_VAR 0 2
51242: RET
// export function IsEmpty ( building ) ; begin
51243: LD_INT 0
51245: PPUSH
// if not building then
51246: LD_VAR 0 1
51250: NOT
51251: IFFALSE 51255
// exit ;
51253: GO 51298
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51255: LD_ADDR_VAR 0 2
51259: PUSH
51260: LD_VAR 0 1
51264: PUSH
51265: LD_INT 22
51267: PUSH
51268: LD_VAR 0 1
51272: PPUSH
51273: CALL_OW 255
51277: PUSH
51278: EMPTY
51279: LIST
51280: LIST
51281: PUSH
51282: LD_INT 58
51284: PUSH
51285: EMPTY
51286: LIST
51287: PUSH
51288: EMPTY
51289: LIST
51290: LIST
51291: PPUSH
51292: CALL_OW 69
51296: IN
51297: ST_TO_ADDR
// end ;
51298: LD_VAR 0 2
51302: RET
// export function IsNotFull ( building ) ; var places ; begin
51303: LD_INT 0
51305: PPUSH
51306: PPUSH
// if not building then
51307: LD_VAR 0 1
51311: NOT
51312: IFFALSE 51316
// exit ;
51314: GO 51344
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
51316: LD_ADDR_VAR 0 2
51320: PUSH
51321: LD_VAR 0 1
51325: PPUSH
51326: LD_INT 3
51328: PUSH
51329: LD_INT 62
51331: PUSH
51332: EMPTY
51333: LIST
51334: PUSH
51335: EMPTY
51336: LIST
51337: LIST
51338: PPUSH
51339: CALL_OW 72
51343: ST_TO_ADDR
// end ;
51344: LD_VAR 0 2
51348: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51349: LD_INT 0
51351: PPUSH
51352: PPUSH
51353: PPUSH
51354: PPUSH
// tmp := [ ] ;
51355: LD_ADDR_VAR 0 3
51359: PUSH
51360: EMPTY
51361: ST_TO_ADDR
// list := [ ] ;
51362: LD_ADDR_VAR 0 5
51366: PUSH
51367: EMPTY
51368: ST_TO_ADDR
// for i = 16 to 25 do
51369: LD_ADDR_VAR 0 4
51373: PUSH
51374: DOUBLE
51375: LD_INT 16
51377: DEC
51378: ST_TO_ADDR
51379: LD_INT 25
51381: PUSH
51382: FOR_TO
51383: IFFALSE 51456
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51385: LD_ADDR_VAR 0 3
51389: PUSH
51390: LD_VAR 0 3
51394: PUSH
51395: LD_INT 22
51397: PUSH
51398: LD_VAR 0 1
51402: PPUSH
51403: CALL_OW 255
51407: PUSH
51408: EMPTY
51409: LIST
51410: LIST
51411: PUSH
51412: LD_INT 91
51414: PUSH
51415: LD_VAR 0 1
51419: PUSH
51420: LD_INT 6
51422: PUSH
51423: EMPTY
51424: LIST
51425: LIST
51426: LIST
51427: PUSH
51428: LD_INT 30
51430: PUSH
51431: LD_VAR 0 4
51435: PUSH
51436: EMPTY
51437: LIST
51438: LIST
51439: PUSH
51440: EMPTY
51441: LIST
51442: LIST
51443: LIST
51444: PUSH
51445: EMPTY
51446: LIST
51447: PPUSH
51448: CALL_OW 69
51452: ADD
51453: ST_TO_ADDR
51454: GO 51382
51456: POP
51457: POP
// for i = 1 to tmp do
51458: LD_ADDR_VAR 0 4
51462: PUSH
51463: DOUBLE
51464: LD_INT 1
51466: DEC
51467: ST_TO_ADDR
51468: LD_VAR 0 3
51472: PUSH
51473: FOR_TO
51474: IFFALSE 51562
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51476: LD_ADDR_VAR 0 5
51480: PUSH
51481: LD_VAR 0 5
51485: PUSH
51486: LD_VAR 0 3
51490: PUSH
51491: LD_VAR 0 4
51495: ARRAY
51496: PPUSH
51497: CALL_OW 266
51501: PUSH
51502: LD_VAR 0 3
51506: PUSH
51507: LD_VAR 0 4
51511: ARRAY
51512: PPUSH
51513: CALL_OW 250
51517: PUSH
51518: LD_VAR 0 3
51522: PUSH
51523: LD_VAR 0 4
51527: ARRAY
51528: PPUSH
51529: CALL_OW 251
51533: PUSH
51534: LD_VAR 0 3
51538: PUSH
51539: LD_VAR 0 4
51543: ARRAY
51544: PPUSH
51545: CALL_OW 254
51549: PUSH
51550: EMPTY
51551: LIST
51552: LIST
51553: LIST
51554: LIST
51555: PUSH
51556: EMPTY
51557: LIST
51558: ADD
51559: ST_TO_ADDR
51560: GO 51473
51562: POP
51563: POP
// result := list ;
51564: LD_ADDR_VAR 0 2
51568: PUSH
51569: LD_VAR 0 5
51573: ST_TO_ADDR
// end ;
51574: LD_VAR 0 2
51578: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51579: LD_INT 0
51581: PPUSH
51582: PPUSH
51583: PPUSH
51584: PPUSH
51585: PPUSH
51586: PPUSH
51587: PPUSH
// if not factory then
51588: LD_VAR 0 1
51592: NOT
51593: IFFALSE 51597
// exit ;
51595: GO 52190
// if control = control_apeman then
51597: LD_VAR 0 4
51601: PUSH
51602: LD_INT 5
51604: EQUAL
51605: IFFALSE 51714
// begin tmp := UnitsInside ( factory ) ;
51607: LD_ADDR_VAR 0 8
51611: PUSH
51612: LD_VAR 0 1
51616: PPUSH
51617: CALL_OW 313
51621: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51622: LD_VAR 0 8
51626: PPUSH
51627: LD_INT 25
51629: PUSH
51630: LD_INT 12
51632: PUSH
51633: EMPTY
51634: LIST
51635: LIST
51636: PPUSH
51637: CALL_OW 72
51641: NOT
51642: IFFALSE 51652
// control := control_manual ;
51644: LD_ADDR_VAR 0 4
51648: PUSH
51649: LD_INT 1
51651: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51652: LD_ADDR_VAR 0 8
51656: PUSH
51657: LD_VAR 0 1
51661: PPUSH
51662: CALL 51349 0 1
51666: ST_TO_ADDR
// if tmp then
51667: LD_VAR 0 8
51671: IFFALSE 51714
// begin for i in tmp do
51673: LD_ADDR_VAR 0 7
51677: PUSH
51678: LD_VAR 0 8
51682: PUSH
51683: FOR_IN
51684: IFFALSE 51712
// if i [ 1 ] = b_ext_radio then
51686: LD_VAR 0 7
51690: PUSH
51691: LD_INT 1
51693: ARRAY
51694: PUSH
51695: LD_INT 22
51697: EQUAL
51698: IFFALSE 51710
// begin control := control_remote ;
51700: LD_ADDR_VAR 0 4
51704: PUSH
51705: LD_INT 2
51707: ST_TO_ADDR
// break ;
51708: GO 51712
// end ;
51710: GO 51683
51712: POP
51713: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51714: LD_VAR 0 1
51718: PPUSH
51719: LD_VAR 0 2
51723: PPUSH
51724: LD_VAR 0 3
51728: PPUSH
51729: LD_VAR 0 4
51733: PPUSH
51734: LD_VAR 0 5
51738: PPUSH
51739: CALL_OW 448
51743: IFFALSE 51778
// begin result := [ chassis , engine , control , weapon ] ;
51745: LD_ADDR_VAR 0 6
51749: PUSH
51750: LD_VAR 0 2
51754: PUSH
51755: LD_VAR 0 3
51759: PUSH
51760: LD_VAR 0 4
51764: PUSH
51765: LD_VAR 0 5
51769: PUSH
51770: EMPTY
51771: LIST
51772: LIST
51773: LIST
51774: LIST
51775: ST_TO_ADDR
// exit ;
51776: GO 52190
// end ; _chassis := AvailableChassisList ( factory ) ;
51778: LD_ADDR_VAR 0 9
51782: PUSH
51783: LD_VAR 0 1
51787: PPUSH
51788: CALL_OW 475
51792: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51793: LD_ADDR_VAR 0 11
51797: PUSH
51798: LD_VAR 0 1
51802: PPUSH
51803: CALL_OW 476
51807: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51808: LD_ADDR_VAR 0 12
51812: PUSH
51813: LD_VAR 0 1
51817: PPUSH
51818: CALL_OW 477
51822: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51823: LD_ADDR_VAR 0 10
51827: PUSH
51828: LD_VAR 0 1
51832: PPUSH
51833: CALL_OW 478
51837: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51838: LD_VAR 0 9
51842: NOT
51843: PUSH
51844: LD_VAR 0 11
51848: NOT
51849: OR
51850: PUSH
51851: LD_VAR 0 12
51855: NOT
51856: OR
51857: PUSH
51858: LD_VAR 0 10
51862: NOT
51863: OR
51864: IFFALSE 51899
// begin result := [ chassis , engine , control , weapon ] ;
51866: LD_ADDR_VAR 0 6
51870: PUSH
51871: LD_VAR 0 2
51875: PUSH
51876: LD_VAR 0 3
51880: PUSH
51881: LD_VAR 0 4
51885: PUSH
51886: LD_VAR 0 5
51890: PUSH
51891: EMPTY
51892: LIST
51893: LIST
51894: LIST
51895: LIST
51896: ST_TO_ADDR
// exit ;
51897: GO 52190
// end ; if not chassis in _chassis then
51899: LD_VAR 0 2
51903: PUSH
51904: LD_VAR 0 9
51908: IN
51909: NOT
51910: IFFALSE 51936
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51912: LD_ADDR_VAR 0 2
51916: PUSH
51917: LD_VAR 0 9
51921: PUSH
51922: LD_INT 1
51924: PPUSH
51925: LD_VAR 0 9
51929: PPUSH
51930: CALL_OW 12
51934: ARRAY
51935: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51936: LD_VAR 0 2
51940: PPUSH
51941: LD_VAR 0 3
51945: PPUSH
51946: CALL 52195 0 2
51950: NOT
51951: IFFALSE 52010
// repeat engine := _engine [ 1 ] ;
51953: LD_ADDR_VAR 0 3
51957: PUSH
51958: LD_VAR 0 11
51962: PUSH
51963: LD_INT 1
51965: ARRAY
51966: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51967: LD_ADDR_VAR 0 11
51971: PUSH
51972: LD_VAR 0 11
51976: PPUSH
51977: LD_INT 1
51979: PPUSH
51980: CALL_OW 3
51984: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51985: LD_VAR 0 2
51989: PPUSH
51990: LD_VAR 0 3
51994: PPUSH
51995: CALL 52195 0 2
51999: PUSH
52000: LD_VAR 0 11
52004: PUSH
52005: EMPTY
52006: EQUAL
52007: OR
52008: IFFALSE 51953
// if not control in _control then
52010: LD_VAR 0 4
52014: PUSH
52015: LD_VAR 0 12
52019: IN
52020: NOT
52021: IFFALSE 52047
// control := _control [ rand ( 1 , _control ) ] ;
52023: LD_ADDR_VAR 0 4
52027: PUSH
52028: LD_VAR 0 12
52032: PUSH
52033: LD_INT 1
52035: PPUSH
52036: LD_VAR 0 12
52040: PPUSH
52041: CALL_OW 12
52045: ARRAY
52046: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52047: LD_VAR 0 2
52051: PPUSH
52052: LD_VAR 0 5
52056: PPUSH
52057: CALL 52415 0 2
52061: NOT
52062: IFFALSE 52121
// repeat weapon := _weapon [ 1 ] ;
52064: LD_ADDR_VAR 0 5
52068: PUSH
52069: LD_VAR 0 10
52073: PUSH
52074: LD_INT 1
52076: ARRAY
52077: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52078: LD_ADDR_VAR 0 10
52082: PUSH
52083: LD_VAR 0 10
52087: PPUSH
52088: LD_INT 1
52090: PPUSH
52091: CALL_OW 3
52095: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52096: LD_VAR 0 2
52100: PPUSH
52101: LD_VAR 0 5
52105: PPUSH
52106: CALL 52415 0 2
52110: PUSH
52111: LD_VAR 0 10
52115: PUSH
52116: EMPTY
52117: EQUAL
52118: OR
52119: IFFALSE 52064
// result := [ ] ;
52121: LD_ADDR_VAR 0 6
52125: PUSH
52126: EMPTY
52127: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52128: LD_VAR 0 1
52132: PPUSH
52133: LD_VAR 0 2
52137: PPUSH
52138: LD_VAR 0 3
52142: PPUSH
52143: LD_VAR 0 4
52147: PPUSH
52148: LD_VAR 0 5
52152: PPUSH
52153: CALL_OW 448
52157: IFFALSE 52190
// result := [ chassis , engine , control , weapon ] ;
52159: LD_ADDR_VAR 0 6
52163: PUSH
52164: LD_VAR 0 2
52168: PUSH
52169: LD_VAR 0 3
52173: PUSH
52174: LD_VAR 0 4
52178: PUSH
52179: LD_VAR 0 5
52183: PUSH
52184: EMPTY
52185: LIST
52186: LIST
52187: LIST
52188: LIST
52189: ST_TO_ADDR
// end ;
52190: LD_VAR 0 6
52194: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52195: LD_INT 0
52197: PPUSH
// if not chassis or not engine then
52198: LD_VAR 0 1
52202: NOT
52203: PUSH
52204: LD_VAR 0 2
52208: NOT
52209: OR
52210: IFFALSE 52214
// exit ;
52212: GO 52410
// case engine of engine_solar :
52214: LD_VAR 0 2
52218: PUSH
52219: LD_INT 2
52221: DOUBLE
52222: EQUAL
52223: IFTRUE 52227
52225: GO 52265
52227: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52228: LD_ADDR_VAR 0 3
52232: PUSH
52233: LD_INT 11
52235: PUSH
52236: LD_INT 12
52238: PUSH
52239: LD_INT 13
52241: PUSH
52242: LD_INT 14
52244: PUSH
52245: LD_INT 1
52247: PUSH
52248: LD_INT 2
52250: PUSH
52251: LD_INT 3
52253: PUSH
52254: EMPTY
52255: LIST
52256: LIST
52257: LIST
52258: LIST
52259: LIST
52260: LIST
52261: LIST
52262: ST_TO_ADDR
52263: GO 52394
52265: LD_INT 1
52267: DOUBLE
52268: EQUAL
52269: IFTRUE 52273
52271: GO 52335
52273: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52274: LD_ADDR_VAR 0 3
52278: PUSH
52279: LD_INT 11
52281: PUSH
52282: LD_INT 12
52284: PUSH
52285: LD_INT 13
52287: PUSH
52288: LD_INT 14
52290: PUSH
52291: LD_INT 1
52293: PUSH
52294: LD_INT 2
52296: PUSH
52297: LD_INT 3
52299: PUSH
52300: LD_INT 4
52302: PUSH
52303: LD_INT 5
52305: PUSH
52306: LD_INT 21
52308: PUSH
52309: LD_INT 23
52311: PUSH
52312: LD_INT 22
52314: PUSH
52315: LD_INT 24
52317: PUSH
52318: EMPTY
52319: LIST
52320: LIST
52321: LIST
52322: LIST
52323: LIST
52324: LIST
52325: LIST
52326: LIST
52327: LIST
52328: LIST
52329: LIST
52330: LIST
52331: LIST
52332: ST_TO_ADDR
52333: GO 52394
52335: LD_INT 3
52337: DOUBLE
52338: EQUAL
52339: IFTRUE 52343
52341: GO 52393
52343: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52344: LD_ADDR_VAR 0 3
52348: PUSH
52349: LD_INT 13
52351: PUSH
52352: LD_INT 14
52354: PUSH
52355: LD_INT 2
52357: PUSH
52358: LD_INT 3
52360: PUSH
52361: LD_INT 4
52363: PUSH
52364: LD_INT 5
52366: PUSH
52367: LD_INT 21
52369: PUSH
52370: LD_INT 22
52372: PUSH
52373: LD_INT 23
52375: PUSH
52376: LD_INT 24
52378: PUSH
52379: EMPTY
52380: LIST
52381: LIST
52382: LIST
52383: LIST
52384: LIST
52385: LIST
52386: LIST
52387: LIST
52388: LIST
52389: LIST
52390: ST_TO_ADDR
52391: GO 52394
52393: POP
// result := ( chassis in result ) ;
52394: LD_ADDR_VAR 0 3
52398: PUSH
52399: LD_VAR 0 1
52403: PUSH
52404: LD_VAR 0 3
52408: IN
52409: ST_TO_ADDR
// end ;
52410: LD_VAR 0 3
52414: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52415: LD_INT 0
52417: PPUSH
// if not chassis or not weapon then
52418: LD_VAR 0 1
52422: NOT
52423: PUSH
52424: LD_VAR 0 2
52428: NOT
52429: OR
52430: IFFALSE 52434
// exit ;
52432: GO 53494
// case weapon of us_machine_gun :
52434: LD_VAR 0 2
52438: PUSH
52439: LD_INT 2
52441: DOUBLE
52442: EQUAL
52443: IFTRUE 52447
52445: GO 52477
52447: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52448: LD_ADDR_VAR 0 3
52452: PUSH
52453: LD_INT 1
52455: PUSH
52456: LD_INT 2
52458: PUSH
52459: LD_INT 3
52461: PUSH
52462: LD_INT 4
52464: PUSH
52465: LD_INT 5
52467: PUSH
52468: EMPTY
52469: LIST
52470: LIST
52471: LIST
52472: LIST
52473: LIST
52474: ST_TO_ADDR
52475: GO 53478
52477: LD_INT 3
52479: DOUBLE
52480: EQUAL
52481: IFTRUE 52485
52483: GO 52515
52485: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52486: LD_ADDR_VAR 0 3
52490: PUSH
52491: LD_INT 1
52493: PUSH
52494: LD_INT 2
52496: PUSH
52497: LD_INT 3
52499: PUSH
52500: LD_INT 4
52502: PUSH
52503: LD_INT 5
52505: PUSH
52506: EMPTY
52507: LIST
52508: LIST
52509: LIST
52510: LIST
52511: LIST
52512: ST_TO_ADDR
52513: GO 53478
52515: LD_INT 11
52517: DOUBLE
52518: EQUAL
52519: IFTRUE 52523
52521: GO 52553
52523: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52524: LD_ADDR_VAR 0 3
52528: PUSH
52529: LD_INT 1
52531: PUSH
52532: LD_INT 2
52534: PUSH
52535: LD_INT 3
52537: PUSH
52538: LD_INT 4
52540: PUSH
52541: LD_INT 5
52543: PUSH
52544: EMPTY
52545: LIST
52546: LIST
52547: LIST
52548: LIST
52549: LIST
52550: ST_TO_ADDR
52551: GO 53478
52553: LD_INT 4
52555: DOUBLE
52556: EQUAL
52557: IFTRUE 52561
52559: GO 52587
52561: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52562: LD_ADDR_VAR 0 3
52566: PUSH
52567: LD_INT 2
52569: PUSH
52570: LD_INT 3
52572: PUSH
52573: LD_INT 4
52575: PUSH
52576: LD_INT 5
52578: PUSH
52579: EMPTY
52580: LIST
52581: LIST
52582: LIST
52583: LIST
52584: ST_TO_ADDR
52585: GO 53478
52587: LD_INT 5
52589: DOUBLE
52590: EQUAL
52591: IFTRUE 52595
52593: GO 52621
52595: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52596: LD_ADDR_VAR 0 3
52600: PUSH
52601: LD_INT 2
52603: PUSH
52604: LD_INT 3
52606: PUSH
52607: LD_INT 4
52609: PUSH
52610: LD_INT 5
52612: PUSH
52613: EMPTY
52614: LIST
52615: LIST
52616: LIST
52617: LIST
52618: ST_TO_ADDR
52619: GO 53478
52621: LD_INT 9
52623: DOUBLE
52624: EQUAL
52625: IFTRUE 52629
52627: GO 52655
52629: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52630: LD_ADDR_VAR 0 3
52634: PUSH
52635: LD_INT 2
52637: PUSH
52638: LD_INT 3
52640: PUSH
52641: LD_INT 4
52643: PUSH
52644: LD_INT 5
52646: PUSH
52647: EMPTY
52648: LIST
52649: LIST
52650: LIST
52651: LIST
52652: ST_TO_ADDR
52653: GO 53478
52655: LD_INT 7
52657: DOUBLE
52658: EQUAL
52659: IFTRUE 52663
52661: GO 52689
52663: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52664: LD_ADDR_VAR 0 3
52668: PUSH
52669: LD_INT 2
52671: PUSH
52672: LD_INT 3
52674: PUSH
52675: LD_INT 4
52677: PUSH
52678: LD_INT 5
52680: PUSH
52681: EMPTY
52682: LIST
52683: LIST
52684: LIST
52685: LIST
52686: ST_TO_ADDR
52687: GO 53478
52689: LD_INT 12
52691: DOUBLE
52692: EQUAL
52693: IFTRUE 52697
52695: GO 52723
52697: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52698: LD_ADDR_VAR 0 3
52702: PUSH
52703: LD_INT 2
52705: PUSH
52706: LD_INT 3
52708: PUSH
52709: LD_INT 4
52711: PUSH
52712: LD_INT 5
52714: PUSH
52715: EMPTY
52716: LIST
52717: LIST
52718: LIST
52719: LIST
52720: ST_TO_ADDR
52721: GO 53478
52723: LD_INT 13
52725: DOUBLE
52726: EQUAL
52727: IFTRUE 52731
52729: GO 52757
52731: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52732: LD_ADDR_VAR 0 3
52736: PUSH
52737: LD_INT 2
52739: PUSH
52740: LD_INT 3
52742: PUSH
52743: LD_INT 4
52745: PUSH
52746: LD_INT 5
52748: PUSH
52749: EMPTY
52750: LIST
52751: LIST
52752: LIST
52753: LIST
52754: ST_TO_ADDR
52755: GO 53478
52757: LD_INT 14
52759: DOUBLE
52760: EQUAL
52761: IFTRUE 52765
52763: GO 52783
52765: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52766: LD_ADDR_VAR 0 3
52770: PUSH
52771: LD_INT 4
52773: PUSH
52774: LD_INT 5
52776: PUSH
52777: EMPTY
52778: LIST
52779: LIST
52780: ST_TO_ADDR
52781: GO 53478
52783: LD_INT 6
52785: DOUBLE
52786: EQUAL
52787: IFTRUE 52791
52789: GO 52809
52791: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52792: LD_ADDR_VAR 0 3
52796: PUSH
52797: LD_INT 4
52799: PUSH
52800: LD_INT 5
52802: PUSH
52803: EMPTY
52804: LIST
52805: LIST
52806: ST_TO_ADDR
52807: GO 53478
52809: LD_INT 10
52811: DOUBLE
52812: EQUAL
52813: IFTRUE 52817
52815: GO 52835
52817: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52818: LD_ADDR_VAR 0 3
52822: PUSH
52823: LD_INT 4
52825: PUSH
52826: LD_INT 5
52828: PUSH
52829: EMPTY
52830: LIST
52831: LIST
52832: ST_TO_ADDR
52833: GO 53478
52835: LD_INT 22
52837: DOUBLE
52838: EQUAL
52839: IFTRUE 52843
52841: GO 52869
52843: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52844: LD_ADDR_VAR 0 3
52848: PUSH
52849: LD_INT 11
52851: PUSH
52852: LD_INT 12
52854: PUSH
52855: LD_INT 13
52857: PUSH
52858: LD_INT 14
52860: PUSH
52861: EMPTY
52862: LIST
52863: LIST
52864: LIST
52865: LIST
52866: ST_TO_ADDR
52867: GO 53478
52869: LD_INT 23
52871: DOUBLE
52872: EQUAL
52873: IFTRUE 52877
52875: GO 52903
52877: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52878: LD_ADDR_VAR 0 3
52882: PUSH
52883: LD_INT 11
52885: PUSH
52886: LD_INT 12
52888: PUSH
52889: LD_INT 13
52891: PUSH
52892: LD_INT 14
52894: PUSH
52895: EMPTY
52896: LIST
52897: LIST
52898: LIST
52899: LIST
52900: ST_TO_ADDR
52901: GO 53478
52903: LD_INT 24
52905: DOUBLE
52906: EQUAL
52907: IFTRUE 52911
52909: GO 52937
52911: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52912: LD_ADDR_VAR 0 3
52916: PUSH
52917: LD_INT 11
52919: PUSH
52920: LD_INT 12
52922: PUSH
52923: LD_INT 13
52925: PUSH
52926: LD_INT 14
52928: PUSH
52929: EMPTY
52930: LIST
52931: LIST
52932: LIST
52933: LIST
52934: ST_TO_ADDR
52935: GO 53478
52937: LD_INT 30
52939: DOUBLE
52940: EQUAL
52941: IFTRUE 52945
52943: GO 52971
52945: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52946: LD_ADDR_VAR 0 3
52950: PUSH
52951: LD_INT 11
52953: PUSH
52954: LD_INT 12
52956: PUSH
52957: LD_INT 13
52959: PUSH
52960: LD_INT 14
52962: PUSH
52963: EMPTY
52964: LIST
52965: LIST
52966: LIST
52967: LIST
52968: ST_TO_ADDR
52969: GO 53478
52971: LD_INT 25
52973: DOUBLE
52974: EQUAL
52975: IFTRUE 52979
52977: GO 52997
52979: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52980: LD_ADDR_VAR 0 3
52984: PUSH
52985: LD_INT 13
52987: PUSH
52988: LD_INT 14
52990: PUSH
52991: EMPTY
52992: LIST
52993: LIST
52994: ST_TO_ADDR
52995: GO 53478
52997: LD_INT 27
52999: DOUBLE
53000: EQUAL
53001: IFTRUE 53005
53003: GO 53023
53005: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
53006: LD_ADDR_VAR 0 3
53010: PUSH
53011: LD_INT 13
53013: PUSH
53014: LD_INT 14
53016: PUSH
53017: EMPTY
53018: LIST
53019: LIST
53020: ST_TO_ADDR
53021: GO 53478
53023: LD_INT 92
53025: DOUBLE
53026: EQUAL
53027: IFTRUE 53031
53029: GO 53057
53031: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53032: LD_ADDR_VAR 0 3
53036: PUSH
53037: LD_INT 11
53039: PUSH
53040: LD_INT 12
53042: PUSH
53043: LD_INT 13
53045: PUSH
53046: LD_INT 14
53048: PUSH
53049: EMPTY
53050: LIST
53051: LIST
53052: LIST
53053: LIST
53054: ST_TO_ADDR
53055: GO 53478
53057: LD_INT 28
53059: DOUBLE
53060: EQUAL
53061: IFTRUE 53065
53063: GO 53083
53065: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53066: LD_ADDR_VAR 0 3
53070: PUSH
53071: LD_INT 13
53073: PUSH
53074: LD_INT 14
53076: PUSH
53077: EMPTY
53078: LIST
53079: LIST
53080: ST_TO_ADDR
53081: GO 53478
53083: LD_INT 29
53085: DOUBLE
53086: EQUAL
53087: IFTRUE 53091
53089: GO 53109
53091: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53092: LD_ADDR_VAR 0 3
53096: PUSH
53097: LD_INT 13
53099: PUSH
53100: LD_INT 14
53102: PUSH
53103: EMPTY
53104: LIST
53105: LIST
53106: ST_TO_ADDR
53107: GO 53478
53109: LD_INT 31
53111: DOUBLE
53112: EQUAL
53113: IFTRUE 53117
53115: GO 53135
53117: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53118: LD_ADDR_VAR 0 3
53122: PUSH
53123: LD_INT 13
53125: PUSH
53126: LD_INT 14
53128: PUSH
53129: EMPTY
53130: LIST
53131: LIST
53132: ST_TO_ADDR
53133: GO 53478
53135: LD_INT 26
53137: DOUBLE
53138: EQUAL
53139: IFTRUE 53143
53141: GO 53161
53143: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53144: LD_ADDR_VAR 0 3
53148: PUSH
53149: LD_INT 13
53151: PUSH
53152: LD_INT 14
53154: PUSH
53155: EMPTY
53156: LIST
53157: LIST
53158: ST_TO_ADDR
53159: GO 53478
53161: LD_INT 42
53163: DOUBLE
53164: EQUAL
53165: IFTRUE 53169
53167: GO 53195
53169: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53170: LD_ADDR_VAR 0 3
53174: PUSH
53175: LD_INT 21
53177: PUSH
53178: LD_INT 22
53180: PUSH
53181: LD_INT 23
53183: PUSH
53184: LD_INT 24
53186: PUSH
53187: EMPTY
53188: LIST
53189: LIST
53190: LIST
53191: LIST
53192: ST_TO_ADDR
53193: GO 53478
53195: LD_INT 43
53197: DOUBLE
53198: EQUAL
53199: IFTRUE 53203
53201: GO 53229
53203: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53204: LD_ADDR_VAR 0 3
53208: PUSH
53209: LD_INT 21
53211: PUSH
53212: LD_INT 22
53214: PUSH
53215: LD_INT 23
53217: PUSH
53218: LD_INT 24
53220: PUSH
53221: EMPTY
53222: LIST
53223: LIST
53224: LIST
53225: LIST
53226: ST_TO_ADDR
53227: GO 53478
53229: LD_INT 44
53231: DOUBLE
53232: EQUAL
53233: IFTRUE 53237
53235: GO 53263
53237: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53238: LD_ADDR_VAR 0 3
53242: PUSH
53243: LD_INT 21
53245: PUSH
53246: LD_INT 22
53248: PUSH
53249: LD_INT 23
53251: PUSH
53252: LD_INT 24
53254: PUSH
53255: EMPTY
53256: LIST
53257: LIST
53258: LIST
53259: LIST
53260: ST_TO_ADDR
53261: GO 53478
53263: LD_INT 45
53265: DOUBLE
53266: EQUAL
53267: IFTRUE 53271
53269: GO 53297
53271: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53272: LD_ADDR_VAR 0 3
53276: PUSH
53277: LD_INT 21
53279: PUSH
53280: LD_INT 22
53282: PUSH
53283: LD_INT 23
53285: PUSH
53286: LD_INT 24
53288: PUSH
53289: EMPTY
53290: LIST
53291: LIST
53292: LIST
53293: LIST
53294: ST_TO_ADDR
53295: GO 53478
53297: LD_INT 49
53299: DOUBLE
53300: EQUAL
53301: IFTRUE 53305
53303: GO 53331
53305: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53306: LD_ADDR_VAR 0 3
53310: PUSH
53311: LD_INT 21
53313: PUSH
53314: LD_INT 22
53316: PUSH
53317: LD_INT 23
53319: PUSH
53320: LD_INT 24
53322: PUSH
53323: EMPTY
53324: LIST
53325: LIST
53326: LIST
53327: LIST
53328: ST_TO_ADDR
53329: GO 53478
53331: LD_INT 51
53333: DOUBLE
53334: EQUAL
53335: IFTRUE 53339
53337: GO 53365
53339: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53340: LD_ADDR_VAR 0 3
53344: PUSH
53345: LD_INT 21
53347: PUSH
53348: LD_INT 22
53350: PUSH
53351: LD_INT 23
53353: PUSH
53354: LD_INT 24
53356: PUSH
53357: EMPTY
53358: LIST
53359: LIST
53360: LIST
53361: LIST
53362: ST_TO_ADDR
53363: GO 53478
53365: LD_INT 52
53367: DOUBLE
53368: EQUAL
53369: IFTRUE 53373
53371: GO 53399
53373: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53374: LD_ADDR_VAR 0 3
53378: PUSH
53379: LD_INT 21
53381: PUSH
53382: LD_INT 22
53384: PUSH
53385: LD_INT 23
53387: PUSH
53388: LD_INT 24
53390: PUSH
53391: EMPTY
53392: LIST
53393: LIST
53394: LIST
53395: LIST
53396: ST_TO_ADDR
53397: GO 53478
53399: LD_INT 53
53401: DOUBLE
53402: EQUAL
53403: IFTRUE 53407
53405: GO 53425
53407: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53408: LD_ADDR_VAR 0 3
53412: PUSH
53413: LD_INT 23
53415: PUSH
53416: LD_INT 24
53418: PUSH
53419: EMPTY
53420: LIST
53421: LIST
53422: ST_TO_ADDR
53423: GO 53478
53425: LD_INT 46
53427: DOUBLE
53428: EQUAL
53429: IFTRUE 53433
53431: GO 53451
53433: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53434: LD_ADDR_VAR 0 3
53438: PUSH
53439: LD_INT 23
53441: PUSH
53442: LD_INT 24
53444: PUSH
53445: EMPTY
53446: LIST
53447: LIST
53448: ST_TO_ADDR
53449: GO 53478
53451: LD_INT 47
53453: DOUBLE
53454: EQUAL
53455: IFTRUE 53459
53457: GO 53477
53459: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53460: LD_ADDR_VAR 0 3
53464: PUSH
53465: LD_INT 23
53467: PUSH
53468: LD_INT 24
53470: PUSH
53471: EMPTY
53472: LIST
53473: LIST
53474: ST_TO_ADDR
53475: GO 53478
53477: POP
// result := ( chassis in result ) ;
53478: LD_ADDR_VAR 0 3
53482: PUSH
53483: LD_VAR 0 1
53487: PUSH
53488: LD_VAR 0 3
53492: IN
53493: ST_TO_ADDR
// end ;
53494: LD_VAR 0 3
53498: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53499: LD_INT 0
53501: PPUSH
53502: PPUSH
53503: PPUSH
53504: PPUSH
53505: PPUSH
53506: PPUSH
53507: PPUSH
// result := array ;
53508: LD_ADDR_VAR 0 5
53512: PUSH
53513: LD_VAR 0 1
53517: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53518: LD_VAR 0 1
53522: NOT
53523: PUSH
53524: LD_VAR 0 2
53528: NOT
53529: OR
53530: PUSH
53531: LD_VAR 0 3
53535: NOT
53536: OR
53537: PUSH
53538: LD_VAR 0 2
53542: PUSH
53543: LD_VAR 0 1
53547: GREATER
53548: OR
53549: PUSH
53550: LD_VAR 0 3
53554: PUSH
53555: LD_VAR 0 1
53559: GREATER
53560: OR
53561: IFFALSE 53565
// exit ;
53563: GO 53861
// if direction then
53565: LD_VAR 0 4
53569: IFFALSE 53633
// begin d := 1 ;
53571: LD_ADDR_VAR 0 9
53575: PUSH
53576: LD_INT 1
53578: ST_TO_ADDR
// if i_from > i_to then
53579: LD_VAR 0 2
53583: PUSH
53584: LD_VAR 0 3
53588: GREATER
53589: IFFALSE 53615
// length := ( array - i_from ) + i_to else
53591: LD_ADDR_VAR 0 11
53595: PUSH
53596: LD_VAR 0 1
53600: PUSH
53601: LD_VAR 0 2
53605: MINUS
53606: PUSH
53607: LD_VAR 0 3
53611: PLUS
53612: ST_TO_ADDR
53613: GO 53631
// length := i_to - i_from ;
53615: LD_ADDR_VAR 0 11
53619: PUSH
53620: LD_VAR 0 3
53624: PUSH
53625: LD_VAR 0 2
53629: MINUS
53630: ST_TO_ADDR
// end else
53631: GO 53694
// begin d := - 1 ;
53633: LD_ADDR_VAR 0 9
53637: PUSH
53638: LD_INT 1
53640: NEG
53641: ST_TO_ADDR
// if i_from > i_to then
53642: LD_VAR 0 2
53646: PUSH
53647: LD_VAR 0 3
53651: GREATER
53652: IFFALSE 53672
// length := i_from - i_to else
53654: LD_ADDR_VAR 0 11
53658: PUSH
53659: LD_VAR 0 2
53663: PUSH
53664: LD_VAR 0 3
53668: MINUS
53669: ST_TO_ADDR
53670: GO 53694
// length := ( array - i_to ) + i_from ;
53672: LD_ADDR_VAR 0 11
53676: PUSH
53677: LD_VAR 0 1
53681: PUSH
53682: LD_VAR 0 3
53686: MINUS
53687: PUSH
53688: LD_VAR 0 2
53692: PLUS
53693: ST_TO_ADDR
// end ; if not length then
53694: LD_VAR 0 11
53698: NOT
53699: IFFALSE 53703
// exit ;
53701: GO 53861
// tmp := array ;
53703: LD_ADDR_VAR 0 10
53707: PUSH
53708: LD_VAR 0 1
53712: ST_TO_ADDR
// for i = 1 to length do
53713: LD_ADDR_VAR 0 6
53717: PUSH
53718: DOUBLE
53719: LD_INT 1
53721: DEC
53722: ST_TO_ADDR
53723: LD_VAR 0 11
53727: PUSH
53728: FOR_TO
53729: IFFALSE 53849
// begin for j = 1 to array do
53731: LD_ADDR_VAR 0 7
53735: PUSH
53736: DOUBLE
53737: LD_INT 1
53739: DEC
53740: ST_TO_ADDR
53741: LD_VAR 0 1
53745: PUSH
53746: FOR_TO
53747: IFFALSE 53835
// begin k := j + d ;
53749: LD_ADDR_VAR 0 8
53753: PUSH
53754: LD_VAR 0 7
53758: PUSH
53759: LD_VAR 0 9
53763: PLUS
53764: ST_TO_ADDR
// if k > array then
53765: LD_VAR 0 8
53769: PUSH
53770: LD_VAR 0 1
53774: GREATER
53775: IFFALSE 53785
// k := 1 ;
53777: LD_ADDR_VAR 0 8
53781: PUSH
53782: LD_INT 1
53784: ST_TO_ADDR
// if not k then
53785: LD_VAR 0 8
53789: NOT
53790: IFFALSE 53802
// k := array ;
53792: LD_ADDR_VAR 0 8
53796: PUSH
53797: LD_VAR 0 1
53801: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53802: LD_ADDR_VAR 0 10
53806: PUSH
53807: LD_VAR 0 10
53811: PPUSH
53812: LD_VAR 0 8
53816: PPUSH
53817: LD_VAR 0 1
53821: PUSH
53822: LD_VAR 0 7
53826: ARRAY
53827: PPUSH
53828: CALL_OW 1
53832: ST_TO_ADDR
// end ;
53833: GO 53746
53835: POP
53836: POP
// array := tmp ;
53837: LD_ADDR_VAR 0 1
53841: PUSH
53842: LD_VAR 0 10
53846: ST_TO_ADDR
// end ;
53847: GO 53728
53849: POP
53850: POP
// result := array ;
53851: LD_ADDR_VAR 0 5
53855: PUSH
53856: LD_VAR 0 1
53860: ST_TO_ADDR
// end ;
53861: LD_VAR 0 5
53865: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53866: LD_INT 0
53868: PPUSH
53869: PPUSH
// result := 0 ;
53870: LD_ADDR_VAR 0 3
53874: PUSH
53875: LD_INT 0
53877: ST_TO_ADDR
// if not array or not value in array then
53878: LD_VAR 0 1
53882: NOT
53883: PUSH
53884: LD_VAR 0 2
53888: PUSH
53889: LD_VAR 0 1
53893: IN
53894: NOT
53895: OR
53896: IFFALSE 53900
// exit ;
53898: GO 53954
// for i = 1 to array do
53900: LD_ADDR_VAR 0 4
53904: PUSH
53905: DOUBLE
53906: LD_INT 1
53908: DEC
53909: ST_TO_ADDR
53910: LD_VAR 0 1
53914: PUSH
53915: FOR_TO
53916: IFFALSE 53952
// if value = array [ i ] then
53918: LD_VAR 0 2
53922: PUSH
53923: LD_VAR 0 1
53927: PUSH
53928: LD_VAR 0 4
53932: ARRAY
53933: EQUAL
53934: IFFALSE 53950
// begin result := i ;
53936: LD_ADDR_VAR 0 3
53940: PUSH
53941: LD_VAR 0 4
53945: ST_TO_ADDR
// exit ;
53946: POP
53947: POP
53948: GO 53954
// end ;
53950: GO 53915
53952: POP
53953: POP
// end ;
53954: LD_VAR 0 3
53958: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53959: LD_INT 0
53961: PPUSH
// vc_chassis := chassis ;
53962: LD_ADDR_OWVAR 37
53966: PUSH
53967: LD_VAR 0 1
53971: ST_TO_ADDR
// vc_engine := engine ;
53972: LD_ADDR_OWVAR 39
53976: PUSH
53977: LD_VAR 0 2
53981: ST_TO_ADDR
// vc_control := control ;
53982: LD_ADDR_OWVAR 38
53986: PUSH
53987: LD_VAR 0 3
53991: ST_TO_ADDR
// vc_weapon := weapon ;
53992: LD_ADDR_OWVAR 40
53996: PUSH
53997: LD_VAR 0 4
54001: ST_TO_ADDR
// vc_fuel_battery := fuel ;
54002: LD_ADDR_OWVAR 41
54006: PUSH
54007: LD_VAR 0 5
54011: ST_TO_ADDR
// end ;
54012: LD_VAR 0 6
54016: RET
// export function WantPlant ( unit ) ; var task ; begin
54017: LD_INT 0
54019: PPUSH
54020: PPUSH
// result := false ;
54021: LD_ADDR_VAR 0 2
54025: PUSH
54026: LD_INT 0
54028: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54029: LD_ADDR_VAR 0 3
54033: PUSH
54034: LD_VAR 0 1
54038: PPUSH
54039: CALL_OW 437
54043: ST_TO_ADDR
// if task then
54044: LD_VAR 0 3
54048: IFFALSE 54076
// if task [ 1 ] [ 1 ] = p then
54050: LD_VAR 0 3
54054: PUSH
54055: LD_INT 1
54057: ARRAY
54058: PUSH
54059: LD_INT 1
54061: ARRAY
54062: PUSH
54063: LD_STRING p
54065: EQUAL
54066: IFFALSE 54076
// result := true ;
54068: LD_ADDR_VAR 0 2
54072: PUSH
54073: LD_INT 1
54075: ST_TO_ADDR
// end ;
54076: LD_VAR 0 2
54080: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54081: LD_INT 0
54083: PPUSH
54084: PPUSH
54085: PPUSH
54086: PPUSH
// if pos < 1 then
54087: LD_VAR 0 2
54091: PUSH
54092: LD_INT 1
54094: LESS
54095: IFFALSE 54099
// exit ;
54097: GO 54402
// if pos = 1 then
54099: LD_VAR 0 2
54103: PUSH
54104: LD_INT 1
54106: EQUAL
54107: IFFALSE 54140
// result := Replace ( arr , pos [ 1 ] , value ) else
54109: LD_ADDR_VAR 0 4
54113: PUSH
54114: LD_VAR 0 1
54118: PPUSH
54119: LD_VAR 0 2
54123: PUSH
54124: LD_INT 1
54126: ARRAY
54127: PPUSH
54128: LD_VAR 0 3
54132: PPUSH
54133: CALL_OW 1
54137: ST_TO_ADDR
54138: GO 54402
// begin tmp := arr ;
54140: LD_ADDR_VAR 0 6
54144: PUSH
54145: LD_VAR 0 1
54149: ST_TO_ADDR
// s_arr := [ tmp ] ;
54150: LD_ADDR_VAR 0 7
54154: PUSH
54155: LD_VAR 0 6
54159: PUSH
54160: EMPTY
54161: LIST
54162: ST_TO_ADDR
// for i = 1 to pos - 1 do
54163: LD_ADDR_VAR 0 5
54167: PUSH
54168: DOUBLE
54169: LD_INT 1
54171: DEC
54172: ST_TO_ADDR
54173: LD_VAR 0 2
54177: PUSH
54178: LD_INT 1
54180: MINUS
54181: PUSH
54182: FOR_TO
54183: IFFALSE 54228
// begin tmp := tmp [ pos [ i ] ] ;
54185: LD_ADDR_VAR 0 6
54189: PUSH
54190: LD_VAR 0 6
54194: PUSH
54195: LD_VAR 0 2
54199: PUSH
54200: LD_VAR 0 5
54204: ARRAY
54205: ARRAY
54206: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54207: LD_ADDR_VAR 0 7
54211: PUSH
54212: LD_VAR 0 7
54216: PUSH
54217: LD_VAR 0 6
54221: PUSH
54222: EMPTY
54223: LIST
54224: ADD
54225: ST_TO_ADDR
// end ;
54226: GO 54182
54228: POP
54229: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54230: LD_ADDR_VAR 0 6
54234: PUSH
54235: LD_VAR 0 6
54239: PPUSH
54240: LD_VAR 0 2
54244: PUSH
54245: LD_VAR 0 2
54249: ARRAY
54250: PPUSH
54251: LD_VAR 0 3
54255: PPUSH
54256: CALL_OW 1
54260: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54261: LD_ADDR_VAR 0 7
54265: PUSH
54266: LD_VAR 0 7
54270: PPUSH
54271: LD_VAR 0 7
54275: PPUSH
54276: LD_VAR 0 6
54280: PPUSH
54281: CALL_OW 1
54285: ST_TO_ADDR
// for i = s_arr downto 2 do
54286: LD_ADDR_VAR 0 5
54290: PUSH
54291: DOUBLE
54292: LD_VAR 0 7
54296: INC
54297: ST_TO_ADDR
54298: LD_INT 2
54300: PUSH
54301: FOR_DOWNTO
54302: IFFALSE 54386
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54304: LD_ADDR_VAR 0 6
54308: PUSH
54309: LD_VAR 0 7
54313: PUSH
54314: LD_VAR 0 5
54318: PUSH
54319: LD_INT 1
54321: MINUS
54322: ARRAY
54323: PPUSH
54324: LD_VAR 0 2
54328: PUSH
54329: LD_VAR 0 5
54333: PUSH
54334: LD_INT 1
54336: MINUS
54337: ARRAY
54338: PPUSH
54339: LD_VAR 0 7
54343: PUSH
54344: LD_VAR 0 5
54348: ARRAY
54349: PPUSH
54350: CALL_OW 1
54354: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54355: LD_ADDR_VAR 0 7
54359: PUSH
54360: LD_VAR 0 7
54364: PPUSH
54365: LD_VAR 0 5
54369: PUSH
54370: LD_INT 1
54372: MINUS
54373: PPUSH
54374: LD_VAR 0 6
54378: PPUSH
54379: CALL_OW 1
54383: ST_TO_ADDR
// end ;
54384: GO 54301
54386: POP
54387: POP
// result := s_arr [ 1 ] ;
54388: LD_ADDR_VAR 0 4
54392: PUSH
54393: LD_VAR 0 7
54397: PUSH
54398: LD_INT 1
54400: ARRAY
54401: ST_TO_ADDR
// end ; end ;
54402: LD_VAR 0 4
54406: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54407: LD_INT 0
54409: PPUSH
54410: PPUSH
// if not list then
54411: LD_VAR 0 1
54415: NOT
54416: IFFALSE 54420
// exit ;
54418: GO 54511
// i := list [ pos1 ] ;
54420: LD_ADDR_VAR 0 5
54424: PUSH
54425: LD_VAR 0 1
54429: PUSH
54430: LD_VAR 0 2
54434: ARRAY
54435: ST_TO_ADDR
// if not i then
54436: LD_VAR 0 5
54440: NOT
54441: IFFALSE 54445
// exit ;
54443: GO 54511
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54445: LD_ADDR_VAR 0 1
54449: PUSH
54450: LD_VAR 0 1
54454: PPUSH
54455: LD_VAR 0 2
54459: PPUSH
54460: LD_VAR 0 1
54464: PUSH
54465: LD_VAR 0 3
54469: ARRAY
54470: PPUSH
54471: CALL_OW 1
54475: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54476: LD_ADDR_VAR 0 1
54480: PUSH
54481: LD_VAR 0 1
54485: PPUSH
54486: LD_VAR 0 3
54490: PPUSH
54491: LD_VAR 0 5
54495: PPUSH
54496: CALL_OW 1
54500: ST_TO_ADDR
// result := list ;
54501: LD_ADDR_VAR 0 4
54505: PUSH
54506: LD_VAR 0 1
54510: ST_TO_ADDR
// end ;
54511: LD_VAR 0 4
54515: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54516: LD_INT 0
54518: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54519: LD_ADDR_VAR 0 5
54523: PUSH
54524: LD_VAR 0 1
54528: PPUSH
54529: CALL_OW 250
54533: PPUSH
54534: LD_VAR 0 1
54538: PPUSH
54539: CALL_OW 251
54543: PPUSH
54544: LD_VAR 0 2
54548: PPUSH
54549: LD_VAR 0 3
54553: PPUSH
54554: LD_VAR 0 4
54558: PPUSH
54559: CALL 54937 0 5
54563: ST_TO_ADDR
// end ;
54564: LD_VAR 0 5
54568: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
54569: LD_INT 0
54571: PPUSH
54572: PPUSH
54573: PPUSH
54574: PPUSH
// if not list or not unit then
54575: LD_VAR 0 2
54579: NOT
54580: PUSH
54581: LD_VAR 0 1
54585: NOT
54586: OR
54587: IFFALSE 54591
// exit ;
54589: GO 54932
// result := [ ] ;
54591: LD_ADDR_VAR 0 5
54595: PUSH
54596: EMPTY
54597: ST_TO_ADDR
// for i in list do
54598: LD_ADDR_VAR 0 6
54602: PUSH
54603: LD_VAR 0 2
54607: PUSH
54608: FOR_IN
54609: IFFALSE 54827
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
54611: LD_ADDR_VAR 0 8
54615: PUSH
54616: LD_VAR 0 1
54620: PPUSH
54621: LD_VAR 0 6
54625: PUSH
54626: LD_INT 1
54628: ARRAY
54629: PPUSH
54630: LD_VAR 0 6
54634: PUSH
54635: LD_INT 2
54637: ARRAY
54638: PPUSH
54639: CALL_OW 297
54643: ST_TO_ADDR
// if not Count ( result ) then
54644: LD_VAR 0 5
54648: PPUSH
54649: CALL 51221 0 1
54653: NOT
54654: IFFALSE 54687
// begin result := Join ( result , [ i , tmp ] ) ;
54656: LD_ADDR_VAR 0 5
54660: PUSH
54661: LD_VAR 0 5
54665: PPUSH
54666: LD_VAR 0 6
54670: PUSH
54671: LD_VAR 0 8
54675: PUSH
54676: EMPTY
54677: LIST
54678: LIST
54679: PPUSH
54680: CALL 86821 0 2
54684: ST_TO_ADDR
// continue ;
54685: GO 54608
// end ; if result [ result ] [ 2 ] <= tmp then
54687: LD_VAR 0 5
54691: PUSH
54692: LD_VAR 0 5
54696: ARRAY
54697: PUSH
54698: LD_INT 2
54700: ARRAY
54701: PUSH
54702: LD_VAR 0 8
54706: LESSEQUAL
54707: IFFALSE 54740
// result := Join ( result , [ i , tmp ] ) else
54709: LD_ADDR_VAR 0 5
54713: PUSH
54714: LD_VAR 0 5
54718: PPUSH
54719: LD_VAR 0 6
54723: PUSH
54724: LD_VAR 0 8
54728: PUSH
54729: EMPTY
54730: LIST
54731: LIST
54732: PPUSH
54733: CALL 86821 0 2
54737: ST_TO_ADDR
54738: GO 54825
// begin for j := 1 to Count ( result ) do
54740: LD_ADDR_VAR 0 7
54744: PUSH
54745: DOUBLE
54746: LD_INT 1
54748: DEC
54749: ST_TO_ADDR
54750: LD_VAR 0 5
54754: PPUSH
54755: CALL 51221 0 1
54759: PUSH
54760: FOR_TO
54761: IFFALSE 54823
// begin if tmp < result [ j ] [ 2 ] then
54763: LD_VAR 0 8
54767: PUSH
54768: LD_VAR 0 5
54772: PUSH
54773: LD_VAR 0 7
54777: ARRAY
54778: PUSH
54779: LD_INT 2
54781: ARRAY
54782: LESS
54783: IFFALSE 54821
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54785: LD_ADDR_VAR 0 5
54789: PUSH
54790: LD_VAR 0 5
54794: PPUSH
54795: LD_VAR 0 7
54799: PPUSH
54800: LD_VAR 0 6
54804: PUSH
54805: LD_VAR 0 8
54809: PUSH
54810: EMPTY
54811: LIST
54812: LIST
54813: PPUSH
54814: CALL_OW 2
54818: ST_TO_ADDR
// break ;
54819: GO 54823
// end ; end ;
54821: GO 54760
54823: POP
54824: POP
// end ; end ;
54825: GO 54608
54827: POP
54828: POP
// if result and not asc then
54829: LD_VAR 0 5
54833: PUSH
54834: LD_VAR 0 3
54838: NOT
54839: AND
54840: IFFALSE 54857
// result := ReverseArray ( result ) ;
54842: LD_ADDR_VAR 0 5
54846: PUSH
54847: LD_VAR 0 5
54851: PPUSH
54852: CALL 82097 0 1
54856: ST_TO_ADDR
// tmp := [ ] ;
54857: LD_ADDR_VAR 0 8
54861: PUSH
54862: EMPTY
54863: ST_TO_ADDR
// if mode then
54864: LD_VAR 0 4
54868: IFFALSE 54932
// begin for i := 1 to result do
54870: LD_ADDR_VAR 0 6
54874: PUSH
54875: DOUBLE
54876: LD_INT 1
54878: DEC
54879: ST_TO_ADDR
54880: LD_VAR 0 5
54884: PUSH
54885: FOR_TO
54886: IFFALSE 54920
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
54888: LD_ADDR_VAR 0 8
54892: PUSH
54893: LD_VAR 0 8
54897: PPUSH
54898: LD_VAR 0 5
54902: PUSH
54903: LD_VAR 0 6
54907: ARRAY
54908: PUSH
54909: LD_INT 1
54911: ARRAY
54912: PPUSH
54913: CALL 86821 0 2
54917: ST_TO_ADDR
54918: GO 54885
54920: POP
54921: POP
// result := tmp ;
54922: LD_ADDR_VAR 0 5
54926: PUSH
54927: LD_VAR 0 8
54931: ST_TO_ADDR
// end ; end ;
54932: LD_VAR 0 5
54936: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54937: LD_INT 0
54939: PPUSH
54940: PPUSH
54941: PPUSH
54942: PPUSH
// if not list then
54943: LD_VAR 0 3
54947: NOT
54948: IFFALSE 54952
// exit ;
54950: GO 55340
// result := [ ] ;
54952: LD_ADDR_VAR 0 6
54956: PUSH
54957: EMPTY
54958: ST_TO_ADDR
// for i in list do
54959: LD_ADDR_VAR 0 7
54963: PUSH
54964: LD_VAR 0 3
54968: PUSH
54969: FOR_IN
54970: IFFALSE 55172
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54972: LD_ADDR_VAR 0 9
54976: PUSH
54977: LD_VAR 0 7
54981: PPUSH
54982: LD_VAR 0 1
54986: PPUSH
54987: LD_VAR 0 2
54991: PPUSH
54992: CALL_OW 297
54996: ST_TO_ADDR
// if not result then
54997: LD_VAR 0 6
55001: NOT
55002: IFFALSE 55028
// result := [ [ i , tmp ] ] else
55004: LD_ADDR_VAR 0 6
55008: PUSH
55009: LD_VAR 0 7
55013: PUSH
55014: LD_VAR 0 9
55018: PUSH
55019: EMPTY
55020: LIST
55021: LIST
55022: PUSH
55023: EMPTY
55024: LIST
55025: ST_TO_ADDR
55026: GO 55170
// begin if result [ result ] [ 2 ] < tmp then
55028: LD_VAR 0 6
55032: PUSH
55033: LD_VAR 0 6
55037: ARRAY
55038: PUSH
55039: LD_INT 2
55041: ARRAY
55042: PUSH
55043: LD_VAR 0 9
55047: LESS
55048: IFFALSE 55090
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
55050: LD_ADDR_VAR 0 6
55054: PUSH
55055: LD_VAR 0 6
55059: PPUSH
55060: LD_VAR 0 6
55064: PUSH
55065: LD_INT 1
55067: PLUS
55068: PPUSH
55069: LD_VAR 0 7
55073: PUSH
55074: LD_VAR 0 9
55078: PUSH
55079: EMPTY
55080: LIST
55081: LIST
55082: PPUSH
55083: CALL_OW 2
55087: ST_TO_ADDR
55088: GO 55170
// for j = 1 to result do
55090: LD_ADDR_VAR 0 8
55094: PUSH
55095: DOUBLE
55096: LD_INT 1
55098: DEC
55099: ST_TO_ADDR
55100: LD_VAR 0 6
55104: PUSH
55105: FOR_TO
55106: IFFALSE 55168
// begin if tmp < result [ j ] [ 2 ] then
55108: LD_VAR 0 9
55112: PUSH
55113: LD_VAR 0 6
55117: PUSH
55118: LD_VAR 0 8
55122: ARRAY
55123: PUSH
55124: LD_INT 2
55126: ARRAY
55127: LESS
55128: IFFALSE 55166
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55130: LD_ADDR_VAR 0 6
55134: PUSH
55135: LD_VAR 0 6
55139: PPUSH
55140: LD_VAR 0 8
55144: PPUSH
55145: LD_VAR 0 7
55149: PUSH
55150: LD_VAR 0 9
55154: PUSH
55155: EMPTY
55156: LIST
55157: LIST
55158: PPUSH
55159: CALL_OW 2
55163: ST_TO_ADDR
// break ;
55164: GO 55168
// end ; end ;
55166: GO 55105
55168: POP
55169: POP
// end ; end ;
55170: GO 54969
55172: POP
55173: POP
// if result and not asc then
55174: LD_VAR 0 6
55178: PUSH
55179: LD_VAR 0 4
55183: NOT
55184: AND
55185: IFFALSE 55260
// begin tmp := result ;
55187: LD_ADDR_VAR 0 9
55191: PUSH
55192: LD_VAR 0 6
55196: ST_TO_ADDR
// for i = tmp downto 1 do
55197: LD_ADDR_VAR 0 7
55201: PUSH
55202: DOUBLE
55203: LD_VAR 0 9
55207: INC
55208: ST_TO_ADDR
55209: LD_INT 1
55211: PUSH
55212: FOR_DOWNTO
55213: IFFALSE 55258
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
55215: LD_ADDR_VAR 0 6
55219: PUSH
55220: LD_VAR 0 6
55224: PPUSH
55225: LD_VAR 0 9
55229: PUSH
55230: LD_VAR 0 7
55234: MINUS
55235: PUSH
55236: LD_INT 1
55238: PLUS
55239: PPUSH
55240: LD_VAR 0 9
55244: PUSH
55245: LD_VAR 0 7
55249: ARRAY
55250: PPUSH
55251: CALL_OW 1
55255: ST_TO_ADDR
55256: GO 55212
55258: POP
55259: POP
// end ; tmp := [ ] ;
55260: LD_ADDR_VAR 0 9
55264: PUSH
55265: EMPTY
55266: ST_TO_ADDR
// if mode then
55267: LD_VAR 0 5
55271: IFFALSE 55340
// begin for i = 1 to result do
55273: LD_ADDR_VAR 0 7
55277: PUSH
55278: DOUBLE
55279: LD_INT 1
55281: DEC
55282: ST_TO_ADDR
55283: LD_VAR 0 6
55287: PUSH
55288: FOR_TO
55289: IFFALSE 55328
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
55291: LD_ADDR_VAR 0 9
55295: PUSH
55296: LD_VAR 0 9
55300: PPUSH
55301: LD_VAR 0 7
55305: PPUSH
55306: LD_VAR 0 6
55310: PUSH
55311: LD_VAR 0 7
55315: ARRAY
55316: PUSH
55317: LD_INT 1
55319: ARRAY
55320: PPUSH
55321: CALL_OW 1
55325: ST_TO_ADDR
55326: GO 55288
55328: POP
55329: POP
// result := tmp ;
55330: LD_ADDR_VAR 0 6
55334: PUSH
55335: LD_VAR 0 9
55339: ST_TO_ADDR
// end ; end ;
55340: LD_VAR 0 6
55344: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55345: LD_INT 0
55347: PPUSH
55348: PPUSH
55349: PPUSH
55350: PPUSH
55351: PPUSH
55352: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55353: LD_ADDR_VAR 0 5
55357: PUSH
55358: LD_INT 0
55360: PUSH
55361: LD_INT 0
55363: PUSH
55364: LD_INT 0
55366: PUSH
55367: EMPTY
55368: PUSH
55369: EMPTY
55370: LIST
55371: LIST
55372: LIST
55373: LIST
55374: ST_TO_ADDR
// if not x or not y then
55375: LD_VAR 0 2
55379: NOT
55380: PUSH
55381: LD_VAR 0 3
55385: NOT
55386: OR
55387: IFFALSE 55391
// exit ;
55389: GO 57041
// if not range then
55391: LD_VAR 0 4
55395: NOT
55396: IFFALSE 55406
// range := 10 ;
55398: LD_ADDR_VAR 0 4
55402: PUSH
55403: LD_INT 10
55405: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55406: LD_ADDR_VAR 0 8
55410: PUSH
55411: LD_INT 81
55413: PUSH
55414: LD_VAR 0 1
55418: PUSH
55419: EMPTY
55420: LIST
55421: LIST
55422: PUSH
55423: LD_INT 92
55425: PUSH
55426: LD_VAR 0 2
55430: PUSH
55431: LD_VAR 0 3
55435: PUSH
55436: LD_VAR 0 4
55440: PUSH
55441: EMPTY
55442: LIST
55443: LIST
55444: LIST
55445: LIST
55446: PUSH
55447: LD_INT 3
55449: PUSH
55450: LD_INT 21
55452: PUSH
55453: LD_INT 3
55455: PUSH
55456: EMPTY
55457: LIST
55458: LIST
55459: PUSH
55460: EMPTY
55461: LIST
55462: LIST
55463: PUSH
55464: EMPTY
55465: LIST
55466: LIST
55467: LIST
55468: PPUSH
55469: CALL_OW 69
55473: ST_TO_ADDR
// if not tmp then
55474: LD_VAR 0 8
55478: NOT
55479: IFFALSE 55483
// exit ;
55481: GO 57041
// for i in tmp do
55483: LD_ADDR_VAR 0 6
55487: PUSH
55488: LD_VAR 0 8
55492: PUSH
55493: FOR_IN
55494: IFFALSE 57016
// begin points := [ 0 , 0 , 0 ] ;
55496: LD_ADDR_VAR 0 9
55500: PUSH
55501: LD_INT 0
55503: PUSH
55504: LD_INT 0
55506: PUSH
55507: LD_INT 0
55509: PUSH
55510: EMPTY
55511: LIST
55512: LIST
55513: LIST
55514: ST_TO_ADDR
// bpoints := 1 ;
55515: LD_ADDR_VAR 0 10
55519: PUSH
55520: LD_INT 1
55522: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55523: LD_VAR 0 6
55527: PPUSH
55528: CALL_OW 247
55532: PUSH
55533: LD_INT 1
55535: DOUBLE
55536: EQUAL
55537: IFTRUE 55541
55539: GO 56119
55541: POP
// begin if GetClass ( i ) = 1 then
55542: LD_VAR 0 6
55546: PPUSH
55547: CALL_OW 257
55551: PUSH
55552: LD_INT 1
55554: EQUAL
55555: IFFALSE 55576
// points := [ 10 , 5 , 3 ] ;
55557: LD_ADDR_VAR 0 9
55561: PUSH
55562: LD_INT 10
55564: PUSH
55565: LD_INT 5
55567: PUSH
55568: LD_INT 3
55570: PUSH
55571: EMPTY
55572: LIST
55573: LIST
55574: LIST
55575: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55576: LD_VAR 0 6
55580: PPUSH
55581: CALL_OW 257
55585: PUSH
55586: LD_INT 2
55588: PUSH
55589: LD_INT 3
55591: PUSH
55592: LD_INT 4
55594: PUSH
55595: EMPTY
55596: LIST
55597: LIST
55598: LIST
55599: IN
55600: IFFALSE 55621
// points := [ 3 , 2 , 1 ] ;
55602: LD_ADDR_VAR 0 9
55606: PUSH
55607: LD_INT 3
55609: PUSH
55610: LD_INT 2
55612: PUSH
55613: LD_INT 1
55615: PUSH
55616: EMPTY
55617: LIST
55618: LIST
55619: LIST
55620: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55621: LD_VAR 0 6
55625: PPUSH
55626: CALL_OW 257
55630: PUSH
55631: LD_INT 5
55633: EQUAL
55634: IFFALSE 55655
// points := [ 130 , 5 , 2 ] ;
55636: LD_ADDR_VAR 0 9
55640: PUSH
55641: LD_INT 130
55643: PUSH
55644: LD_INT 5
55646: PUSH
55647: LD_INT 2
55649: PUSH
55650: EMPTY
55651: LIST
55652: LIST
55653: LIST
55654: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55655: LD_VAR 0 6
55659: PPUSH
55660: CALL_OW 257
55664: PUSH
55665: LD_INT 8
55667: EQUAL
55668: IFFALSE 55689
// points := [ 35 , 35 , 30 ] ;
55670: LD_ADDR_VAR 0 9
55674: PUSH
55675: LD_INT 35
55677: PUSH
55678: LD_INT 35
55680: PUSH
55681: LD_INT 30
55683: PUSH
55684: EMPTY
55685: LIST
55686: LIST
55687: LIST
55688: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55689: LD_VAR 0 6
55693: PPUSH
55694: CALL_OW 257
55698: PUSH
55699: LD_INT 9
55701: EQUAL
55702: IFFALSE 55723
// points := [ 20 , 55 , 40 ] ;
55704: LD_ADDR_VAR 0 9
55708: PUSH
55709: LD_INT 20
55711: PUSH
55712: LD_INT 55
55714: PUSH
55715: LD_INT 40
55717: PUSH
55718: EMPTY
55719: LIST
55720: LIST
55721: LIST
55722: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55723: LD_VAR 0 6
55727: PPUSH
55728: CALL_OW 257
55732: PUSH
55733: LD_INT 12
55735: PUSH
55736: LD_INT 16
55738: PUSH
55739: EMPTY
55740: LIST
55741: LIST
55742: IN
55743: IFFALSE 55764
// points := [ 5 , 3 , 2 ] ;
55745: LD_ADDR_VAR 0 9
55749: PUSH
55750: LD_INT 5
55752: PUSH
55753: LD_INT 3
55755: PUSH
55756: LD_INT 2
55758: PUSH
55759: EMPTY
55760: LIST
55761: LIST
55762: LIST
55763: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55764: LD_VAR 0 6
55768: PPUSH
55769: CALL_OW 257
55773: PUSH
55774: LD_INT 17
55776: EQUAL
55777: IFFALSE 55798
// points := [ 100 , 50 , 75 ] ;
55779: LD_ADDR_VAR 0 9
55783: PUSH
55784: LD_INT 100
55786: PUSH
55787: LD_INT 50
55789: PUSH
55790: LD_INT 75
55792: PUSH
55793: EMPTY
55794: LIST
55795: LIST
55796: LIST
55797: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55798: LD_VAR 0 6
55802: PPUSH
55803: CALL_OW 257
55807: PUSH
55808: LD_INT 15
55810: EQUAL
55811: IFFALSE 55832
// points := [ 10 , 5 , 3 ] ;
55813: LD_ADDR_VAR 0 9
55817: PUSH
55818: LD_INT 10
55820: PUSH
55821: LD_INT 5
55823: PUSH
55824: LD_INT 3
55826: PUSH
55827: EMPTY
55828: LIST
55829: LIST
55830: LIST
55831: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55832: LD_VAR 0 6
55836: PPUSH
55837: CALL_OW 257
55841: PUSH
55842: LD_INT 14
55844: EQUAL
55845: IFFALSE 55866
// points := [ 10 , 0 , 0 ] ;
55847: LD_ADDR_VAR 0 9
55851: PUSH
55852: LD_INT 10
55854: PUSH
55855: LD_INT 0
55857: PUSH
55858: LD_INT 0
55860: PUSH
55861: EMPTY
55862: LIST
55863: LIST
55864: LIST
55865: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55866: LD_VAR 0 6
55870: PPUSH
55871: CALL_OW 257
55875: PUSH
55876: LD_INT 11
55878: EQUAL
55879: IFFALSE 55900
// points := [ 30 , 10 , 5 ] ;
55881: LD_ADDR_VAR 0 9
55885: PUSH
55886: LD_INT 30
55888: PUSH
55889: LD_INT 10
55891: PUSH
55892: LD_INT 5
55894: PUSH
55895: EMPTY
55896: LIST
55897: LIST
55898: LIST
55899: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55900: LD_VAR 0 1
55904: PPUSH
55905: LD_INT 5
55907: PPUSH
55908: CALL_OW 321
55912: PUSH
55913: LD_INT 2
55915: EQUAL
55916: IFFALSE 55933
// bpoints := bpoints * 1.8 ;
55918: LD_ADDR_VAR 0 10
55922: PUSH
55923: LD_VAR 0 10
55927: PUSH
55928: LD_REAL  1.80000000000000E+0000
55931: MUL
55932: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55933: LD_VAR 0 6
55937: PPUSH
55938: CALL_OW 257
55942: PUSH
55943: LD_INT 1
55945: PUSH
55946: LD_INT 2
55948: PUSH
55949: LD_INT 3
55951: PUSH
55952: LD_INT 4
55954: PUSH
55955: EMPTY
55956: LIST
55957: LIST
55958: LIST
55959: LIST
55960: IN
55961: PUSH
55962: LD_VAR 0 1
55966: PPUSH
55967: LD_INT 51
55969: PPUSH
55970: CALL_OW 321
55974: PUSH
55975: LD_INT 2
55977: EQUAL
55978: AND
55979: IFFALSE 55996
// bpoints := bpoints * 1.2 ;
55981: LD_ADDR_VAR 0 10
55985: PUSH
55986: LD_VAR 0 10
55990: PUSH
55991: LD_REAL  1.20000000000000E+0000
55994: MUL
55995: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55996: LD_VAR 0 6
56000: PPUSH
56001: CALL_OW 257
56005: PUSH
56006: LD_INT 5
56008: PUSH
56009: LD_INT 7
56011: PUSH
56012: LD_INT 9
56014: PUSH
56015: EMPTY
56016: LIST
56017: LIST
56018: LIST
56019: IN
56020: PUSH
56021: LD_VAR 0 1
56025: PPUSH
56026: LD_INT 52
56028: PPUSH
56029: CALL_OW 321
56033: PUSH
56034: LD_INT 2
56036: EQUAL
56037: AND
56038: IFFALSE 56055
// bpoints := bpoints * 1.5 ;
56040: LD_ADDR_VAR 0 10
56044: PUSH
56045: LD_VAR 0 10
56049: PUSH
56050: LD_REAL  1.50000000000000E+0000
56053: MUL
56054: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
56055: LD_VAR 0 1
56059: PPUSH
56060: LD_INT 66
56062: PPUSH
56063: CALL_OW 321
56067: PUSH
56068: LD_INT 2
56070: EQUAL
56071: IFFALSE 56088
// bpoints := bpoints * 1.1 ;
56073: LD_ADDR_VAR 0 10
56077: PUSH
56078: LD_VAR 0 10
56082: PUSH
56083: LD_REAL  1.10000000000000E+0000
56086: MUL
56087: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
56088: LD_ADDR_VAR 0 10
56092: PUSH
56093: LD_VAR 0 10
56097: PUSH
56098: LD_VAR 0 6
56102: PPUSH
56103: LD_INT 1
56105: PPUSH
56106: CALL_OW 259
56110: PUSH
56111: LD_REAL  1.15000000000000E+0000
56114: MUL
56115: MUL
56116: ST_TO_ADDR
// end ; unit_vehicle :
56117: GO 56945
56119: LD_INT 2
56121: DOUBLE
56122: EQUAL
56123: IFTRUE 56127
56125: GO 56933
56127: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
56128: LD_VAR 0 6
56132: PPUSH
56133: CALL_OW 264
56137: PUSH
56138: LD_INT 2
56140: PUSH
56141: LD_INT 42
56143: PUSH
56144: LD_INT 24
56146: PUSH
56147: EMPTY
56148: LIST
56149: LIST
56150: LIST
56151: IN
56152: IFFALSE 56173
// points := [ 25 , 5 , 3 ] ;
56154: LD_ADDR_VAR 0 9
56158: PUSH
56159: LD_INT 25
56161: PUSH
56162: LD_INT 5
56164: PUSH
56165: LD_INT 3
56167: PUSH
56168: EMPTY
56169: LIST
56170: LIST
56171: LIST
56172: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
56173: LD_VAR 0 6
56177: PPUSH
56178: CALL_OW 264
56182: PUSH
56183: LD_INT 4
56185: PUSH
56186: LD_INT 43
56188: PUSH
56189: LD_INT 25
56191: PUSH
56192: EMPTY
56193: LIST
56194: LIST
56195: LIST
56196: IN
56197: IFFALSE 56218
// points := [ 40 , 15 , 5 ] ;
56199: LD_ADDR_VAR 0 9
56203: PUSH
56204: LD_INT 40
56206: PUSH
56207: LD_INT 15
56209: PUSH
56210: LD_INT 5
56212: PUSH
56213: EMPTY
56214: LIST
56215: LIST
56216: LIST
56217: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
56218: LD_VAR 0 6
56222: PPUSH
56223: CALL_OW 264
56227: PUSH
56228: LD_INT 3
56230: PUSH
56231: LD_INT 23
56233: PUSH
56234: EMPTY
56235: LIST
56236: LIST
56237: IN
56238: IFFALSE 56259
// points := [ 7 , 25 , 8 ] ;
56240: LD_ADDR_VAR 0 9
56244: PUSH
56245: LD_INT 7
56247: PUSH
56248: LD_INT 25
56250: PUSH
56251: LD_INT 8
56253: PUSH
56254: EMPTY
56255: LIST
56256: LIST
56257: LIST
56258: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
56259: LD_VAR 0 6
56263: PPUSH
56264: CALL_OW 264
56268: PUSH
56269: LD_INT 5
56271: PUSH
56272: LD_INT 27
56274: PUSH
56275: LD_INT 44
56277: PUSH
56278: EMPTY
56279: LIST
56280: LIST
56281: LIST
56282: IN
56283: IFFALSE 56304
// points := [ 14 , 50 , 16 ] ;
56285: LD_ADDR_VAR 0 9
56289: PUSH
56290: LD_INT 14
56292: PUSH
56293: LD_INT 50
56295: PUSH
56296: LD_INT 16
56298: PUSH
56299: EMPTY
56300: LIST
56301: LIST
56302: LIST
56303: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
56304: LD_VAR 0 6
56308: PPUSH
56309: CALL_OW 264
56313: PUSH
56314: LD_INT 6
56316: PUSH
56317: LD_INT 46
56319: PUSH
56320: EMPTY
56321: LIST
56322: LIST
56323: IN
56324: IFFALSE 56345
// points := [ 32 , 120 , 70 ] ;
56326: LD_ADDR_VAR 0 9
56330: PUSH
56331: LD_INT 32
56333: PUSH
56334: LD_INT 120
56336: PUSH
56337: LD_INT 70
56339: PUSH
56340: EMPTY
56341: LIST
56342: LIST
56343: LIST
56344: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
56345: LD_VAR 0 6
56349: PPUSH
56350: CALL_OW 264
56354: PUSH
56355: LD_INT 7
56357: PUSH
56358: LD_INT 28
56360: PUSH
56361: LD_INT 45
56363: PUSH
56364: LD_INT 92
56366: PUSH
56367: EMPTY
56368: LIST
56369: LIST
56370: LIST
56371: LIST
56372: IN
56373: IFFALSE 56394
// points := [ 35 , 20 , 45 ] ;
56375: LD_ADDR_VAR 0 9
56379: PUSH
56380: LD_INT 35
56382: PUSH
56383: LD_INT 20
56385: PUSH
56386: LD_INT 45
56388: PUSH
56389: EMPTY
56390: LIST
56391: LIST
56392: LIST
56393: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56394: LD_VAR 0 6
56398: PPUSH
56399: CALL_OW 264
56403: PUSH
56404: LD_INT 47
56406: PUSH
56407: EMPTY
56408: LIST
56409: IN
56410: IFFALSE 56431
// points := [ 67 , 45 , 75 ] ;
56412: LD_ADDR_VAR 0 9
56416: PUSH
56417: LD_INT 67
56419: PUSH
56420: LD_INT 45
56422: PUSH
56423: LD_INT 75
56425: PUSH
56426: EMPTY
56427: LIST
56428: LIST
56429: LIST
56430: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56431: LD_VAR 0 6
56435: PPUSH
56436: CALL_OW 264
56440: PUSH
56441: LD_INT 26
56443: PUSH
56444: EMPTY
56445: LIST
56446: IN
56447: IFFALSE 56468
// points := [ 120 , 30 , 80 ] ;
56449: LD_ADDR_VAR 0 9
56453: PUSH
56454: LD_INT 120
56456: PUSH
56457: LD_INT 30
56459: PUSH
56460: LD_INT 80
56462: PUSH
56463: EMPTY
56464: LIST
56465: LIST
56466: LIST
56467: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56468: LD_VAR 0 6
56472: PPUSH
56473: CALL_OW 264
56477: PUSH
56478: LD_INT 22
56480: PUSH
56481: EMPTY
56482: LIST
56483: IN
56484: IFFALSE 56505
// points := [ 40 , 1 , 1 ] ;
56486: LD_ADDR_VAR 0 9
56490: PUSH
56491: LD_INT 40
56493: PUSH
56494: LD_INT 1
56496: PUSH
56497: LD_INT 1
56499: PUSH
56500: EMPTY
56501: LIST
56502: LIST
56503: LIST
56504: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56505: LD_VAR 0 6
56509: PPUSH
56510: CALL_OW 264
56514: PUSH
56515: LD_INT 29
56517: PUSH
56518: EMPTY
56519: LIST
56520: IN
56521: IFFALSE 56542
// points := [ 70 , 200 , 400 ] ;
56523: LD_ADDR_VAR 0 9
56527: PUSH
56528: LD_INT 70
56530: PUSH
56531: LD_INT 200
56533: PUSH
56534: LD_INT 400
56536: PUSH
56537: EMPTY
56538: LIST
56539: LIST
56540: LIST
56541: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56542: LD_VAR 0 6
56546: PPUSH
56547: CALL_OW 264
56551: PUSH
56552: LD_INT 14
56554: PUSH
56555: LD_INT 53
56557: PUSH
56558: EMPTY
56559: LIST
56560: LIST
56561: IN
56562: IFFALSE 56583
// points := [ 40 , 10 , 20 ] ;
56564: LD_ADDR_VAR 0 9
56568: PUSH
56569: LD_INT 40
56571: PUSH
56572: LD_INT 10
56574: PUSH
56575: LD_INT 20
56577: PUSH
56578: EMPTY
56579: LIST
56580: LIST
56581: LIST
56582: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56583: LD_VAR 0 6
56587: PPUSH
56588: CALL_OW 264
56592: PUSH
56593: LD_INT 9
56595: PUSH
56596: EMPTY
56597: LIST
56598: IN
56599: IFFALSE 56620
// points := [ 5 , 70 , 20 ] ;
56601: LD_ADDR_VAR 0 9
56605: PUSH
56606: LD_INT 5
56608: PUSH
56609: LD_INT 70
56611: PUSH
56612: LD_INT 20
56614: PUSH
56615: EMPTY
56616: LIST
56617: LIST
56618: LIST
56619: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56620: LD_VAR 0 6
56624: PPUSH
56625: CALL_OW 264
56629: PUSH
56630: LD_INT 10
56632: PUSH
56633: EMPTY
56634: LIST
56635: IN
56636: IFFALSE 56657
// points := [ 35 , 110 , 70 ] ;
56638: LD_ADDR_VAR 0 9
56642: PUSH
56643: LD_INT 35
56645: PUSH
56646: LD_INT 110
56648: PUSH
56649: LD_INT 70
56651: PUSH
56652: EMPTY
56653: LIST
56654: LIST
56655: LIST
56656: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56657: LD_VAR 0 6
56661: PPUSH
56662: CALL_OW 265
56666: PUSH
56667: LD_INT 25
56669: EQUAL
56670: IFFALSE 56691
// points := [ 80 , 65 , 100 ] ;
56672: LD_ADDR_VAR 0 9
56676: PUSH
56677: LD_INT 80
56679: PUSH
56680: LD_INT 65
56682: PUSH
56683: LD_INT 100
56685: PUSH
56686: EMPTY
56687: LIST
56688: LIST
56689: LIST
56690: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56691: LD_VAR 0 6
56695: PPUSH
56696: CALL_OW 263
56700: PUSH
56701: LD_INT 1
56703: EQUAL
56704: IFFALSE 56739
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56706: LD_ADDR_VAR 0 10
56710: PUSH
56711: LD_VAR 0 10
56715: PUSH
56716: LD_VAR 0 6
56720: PPUSH
56721: CALL_OW 311
56725: PPUSH
56726: LD_INT 3
56728: PPUSH
56729: CALL_OW 259
56733: PUSH
56734: LD_INT 4
56736: MUL
56737: MUL
56738: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56739: LD_VAR 0 6
56743: PPUSH
56744: CALL_OW 263
56748: PUSH
56749: LD_INT 2
56751: EQUAL
56752: IFFALSE 56803
// begin j := IsControledBy ( i ) ;
56754: LD_ADDR_VAR 0 7
56758: PUSH
56759: LD_VAR 0 6
56763: PPUSH
56764: CALL_OW 312
56768: ST_TO_ADDR
// if j then
56769: LD_VAR 0 7
56773: IFFALSE 56803
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56775: LD_ADDR_VAR 0 10
56779: PUSH
56780: LD_VAR 0 10
56784: PUSH
56785: LD_VAR 0 7
56789: PPUSH
56790: LD_INT 3
56792: PPUSH
56793: CALL_OW 259
56797: PUSH
56798: LD_INT 3
56800: MUL
56801: MUL
56802: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56803: LD_VAR 0 6
56807: PPUSH
56808: CALL_OW 264
56812: PUSH
56813: LD_INT 5
56815: PUSH
56816: LD_INT 6
56818: PUSH
56819: LD_INT 46
56821: PUSH
56822: LD_INT 44
56824: PUSH
56825: LD_INT 47
56827: PUSH
56828: LD_INT 45
56830: PUSH
56831: LD_INT 28
56833: PUSH
56834: LD_INT 7
56836: PUSH
56837: LD_INT 27
56839: PUSH
56840: LD_INT 29
56842: PUSH
56843: EMPTY
56844: LIST
56845: LIST
56846: LIST
56847: LIST
56848: LIST
56849: LIST
56850: LIST
56851: LIST
56852: LIST
56853: LIST
56854: IN
56855: PUSH
56856: LD_VAR 0 1
56860: PPUSH
56861: LD_INT 52
56863: PPUSH
56864: CALL_OW 321
56868: PUSH
56869: LD_INT 2
56871: EQUAL
56872: AND
56873: IFFALSE 56890
// bpoints := bpoints * 1.2 ;
56875: LD_ADDR_VAR 0 10
56879: PUSH
56880: LD_VAR 0 10
56884: PUSH
56885: LD_REAL  1.20000000000000E+0000
56888: MUL
56889: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56890: LD_VAR 0 6
56894: PPUSH
56895: CALL_OW 264
56899: PUSH
56900: LD_INT 6
56902: PUSH
56903: LD_INT 46
56905: PUSH
56906: LD_INT 47
56908: PUSH
56909: EMPTY
56910: LIST
56911: LIST
56912: LIST
56913: IN
56914: IFFALSE 56931
// bpoints := bpoints * 1.2 ;
56916: LD_ADDR_VAR 0 10
56920: PUSH
56921: LD_VAR 0 10
56925: PUSH
56926: LD_REAL  1.20000000000000E+0000
56929: MUL
56930: ST_TO_ADDR
// end ; unit_building :
56931: GO 56945
56933: LD_INT 3
56935: DOUBLE
56936: EQUAL
56937: IFTRUE 56941
56939: GO 56944
56941: POP
// ; end ;
56942: GO 56945
56944: POP
// for j = 1 to 3 do
56945: LD_ADDR_VAR 0 7
56949: PUSH
56950: DOUBLE
56951: LD_INT 1
56953: DEC
56954: ST_TO_ADDR
56955: LD_INT 3
56957: PUSH
56958: FOR_TO
56959: IFFALSE 57012
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56961: LD_ADDR_VAR 0 5
56965: PUSH
56966: LD_VAR 0 5
56970: PPUSH
56971: LD_VAR 0 7
56975: PPUSH
56976: LD_VAR 0 5
56980: PUSH
56981: LD_VAR 0 7
56985: ARRAY
56986: PUSH
56987: LD_VAR 0 9
56991: PUSH
56992: LD_VAR 0 7
56996: ARRAY
56997: PUSH
56998: LD_VAR 0 10
57002: MUL
57003: PLUS
57004: PPUSH
57005: CALL_OW 1
57009: ST_TO_ADDR
57010: GO 56958
57012: POP
57013: POP
// end ;
57014: GO 55493
57016: POP
57017: POP
// result := Replace ( result , 4 , tmp ) ;
57018: LD_ADDR_VAR 0 5
57022: PUSH
57023: LD_VAR 0 5
57027: PPUSH
57028: LD_INT 4
57030: PPUSH
57031: LD_VAR 0 8
57035: PPUSH
57036: CALL_OW 1
57040: ST_TO_ADDR
// end ;
57041: LD_VAR 0 5
57045: RET
// export function DangerAtRange ( unit , range ) ; begin
57046: LD_INT 0
57048: PPUSH
// if not unit then
57049: LD_VAR 0 1
57053: NOT
57054: IFFALSE 57058
// exit ;
57056: GO 57103
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
57058: LD_ADDR_VAR 0 3
57062: PUSH
57063: LD_VAR 0 1
57067: PPUSH
57068: CALL_OW 255
57072: PPUSH
57073: LD_VAR 0 1
57077: PPUSH
57078: CALL_OW 250
57082: PPUSH
57083: LD_VAR 0 1
57087: PPUSH
57088: CALL_OW 251
57092: PPUSH
57093: LD_VAR 0 2
57097: PPUSH
57098: CALL 55345 0 4
57102: ST_TO_ADDR
// end ;
57103: LD_VAR 0 3
57107: RET
// export function DangerInArea ( side , area ) ; begin
57108: LD_INT 0
57110: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
57111: LD_ADDR_VAR 0 3
57115: PUSH
57116: LD_VAR 0 2
57120: PPUSH
57121: LD_INT 81
57123: PUSH
57124: LD_VAR 0 1
57128: PUSH
57129: EMPTY
57130: LIST
57131: LIST
57132: PPUSH
57133: CALL_OW 70
57137: ST_TO_ADDR
// end ;
57138: LD_VAR 0 3
57142: RET
// export function IsExtension ( b ) ; begin
57143: LD_INT 0
57145: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
57146: LD_ADDR_VAR 0 2
57150: PUSH
57151: LD_VAR 0 1
57155: PUSH
57156: LD_INT 23
57158: PUSH
57159: LD_INT 20
57161: PUSH
57162: LD_INT 22
57164: PUSH
57165: LD_INT 17
57167: PUSH
57168: LD_INT 24
57170: PUSH
57171: LD_INT 21
57173: PUSH
57174: LD_INT 19
57176: PUSH
57177: LD_INT 16
57179: PUSH
57180: LD_INT 25
57182: PUSH
57183: LD_INT 18
57185: PUSH
57186: EMPTY
57187: LIST
57188: LIST
57189: LIST
57190: LIST
57191: LIST
57192: LIST
57193: LIST
57194: LIST
57195: LIST
57196: LIST
57197: IN
57198: ST_TO_ADDR
// end ;
57199: LD_VAR 0 2
57203: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
57204: LD_INT 0
57206: PPUSH
57207: PPUSH
57208: PPUSH
// result := [ ] ;
57209: LD_ADDR_VAR 0 4
57213: PUSH
57214: EMPTY
57215: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
57216: LD_ADDR_VAR 0 5
57220: PUSH
57221: LD_VAR 0 2
57225: PPUSH
57226: LD_INT 21
57228: PUSH
57229: LD_INT 3
57231: PUSH
57232: EMPTY
57233: LIST
57234: LIST
57235: PPUSH
57236: CALL_OW 70
57240: ST_TO_ADDR
// if not tmp then
57241: LD_VAR 0 5
57245: NOT
57246: IFFALSE 57250
// exit ;
57248: GO 57314
// if checkLink then
57250: LD_VAR 0 3
57254: IFFALSE 57304
// begin for i in tmp do
57256: LD_ADDR_VAR 0 6
57260: PUSH
57261: LD_VAR 0 5
57265: PUSH
57266: FOR_IN
57267: IFFALSE 57302
// if GetBase ( i ) <> base then
57269: LD_VAR 0 6
57273: PPUSH
57274: CALL_OW 274
57278: PUSH
57279: LD_VAR 0 1
57283: NONEQUAL
57284: IFFALSE 57300
// ComLinkToBase ( base , i ) ;
57286: LD_VAR 0 1
57290: PPUSH
57291: LD_VAR 0 6
57295: PPUSH
57296: CALL_OW 169
57300: GO 57266
57302: POP
57303: POP
// end ; result := tmp ;
57304: LD_ADDR_VAR 0 4
57308: PUSH
57309: LD_VAR 0 5
57313: ST_TO_ADDR
// end ;
57314: LD_VAR 0 4
57318: RET
// export function ComComplete ( units , b ) ; var i ; begin
57319: LD_INT 0
57321: PPUSH
57322: PPUSH
// if not units then
57323: LD_VAR 0 1
57327: NOT
57328: IFFALSE 57332
// exit ;
57330: GO 57422
// for i in units do
57332: LD_ADDR_VAR 0 4
57336: PUSH
57337: LD_VAR 0 1
57341: PUSH
57342: FOR_IN
57343: IFFALSE 57420
// if BuildingStatus ( b ) = bs_build then
57345: LD_VAR 0 2
57349: PPUSH
57350: CALL_OW 461
57354: PUSH
57355: LD_INT 1
57357: EQUAL
57358: IFFALSE 57418
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
57360: LD_VAR 0 4
57364: PPUSH
57365: LD_STRING h
57367: PUSH
57368: LD_VAR 0 2
57372: PPUSH
57373: CALL_OW 250
57377: PUSH
57378: LD_VAR 0 2
57382: PPUSH
57383: CALL_OW 251
57387: PUSH
57388: LD_VAR 0 2
57392: PUSH
57393: LD_INT 0
57395: PUSH
57396: LD_INT 0
57398: PUSH
57399: LD_INT 0
57401: PUSH
57402: EMPTY
57403: LIST
57404: LIST
57405: LIST
57406: LIST
57407: LIST
57408: LIST
57409: LIST
57410: PUSH
57411: EMPTY
57412: LIST
57413: PPUSH
57414: CALL_OW 446
57418: GO 57342
57420: POP
57421: POP
// end ;
57422: LD_VAR 0 3
57426: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57427: LD_INT 0
57429: PPUSH
57430: PPUSH
57431: PPUSH
57432: PPUSH
57433: PPUSH
57434: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
57435: LD_VAR 0 1
57439: NOT
57440: PUSH
57441: LD_VAR 0 1
57445: PPUSH
57446: CALL_OW 263
57450: PUSH
57451: LD_INT 2
57453: NONEQUAL
57454: OR
57455: IFFALSE 57459
// exit ;
57457: GO 57775
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57459: LD_ADDR_VAR 0 6
57463: PUSH
57464: LD_INT 22
57466: PUSH
57467: LD_VAR 0 1
57471: PPUSH
57472: CALL_OW 255
57476: PUSH
57477: EMPTY
57478: LIST
57479: LIST
57480: PUSH
57481: LD_INT 2
57483: PUSH
57484: LD_INT 30
57486: PUSH
57487: LD_INT 36
57489: PUSH
57490: EMPTY
57491: LIST
57492: LIST
57493: PUSH
57494: LD_INT 34
57496: PUSH
57497: LD_INT 31
57499: PUSH
57500: EMPTY
57501: LIST
57502: LIST
57503: PUSH
57504: EMPTY
57505: LIST
57506: LIST
57507: LIST
57508: PUSH
57509: EMPTY
57510: LIST
57511: LIST
57512: PPUSH
57513: CALL_OW 69
57517: ST_TO_ADDR
// if not tmp then
57518: LD_VAR 0 6
57522: NOT
57523: IFFALSE 57527
// exit ;
57525: GO 57775
// result := [ ] ;
57527: LD_ADDR_VAR 0 2
57531: PUSH
57532: EMPTY
57533: ST_TO_ADDR
// for i in tmp do
57534: LD_ADDR_VAR 0 3
57538: PUSH
57539: LD_VAR 0 6
57543: PUSH
57544: FOR_IN
57545: IFFALSE 57616
// begin t := UnitsInside ( i ) ;
57547: LD_ADDR_VAR 0 4
57551: PUSH
57552: LD_VAR 0 3
57556: PPUSH
57557: CALL_OW 313
57561: ST_TO_ADDR
// if t then
57562: LD_VAR 0 4
57566: IFFALSE 57614
// for j in t do
57568: LD_ADDR_VAR 0 7
57572: PUSH
57573: LD_VAR 0 4
57577: PUSH
57578: FOR_IN
57579: IFFALSE 57612
// result := Replace ( result , result + 1 , j ) ;
57581: LD_ADDR_VAR 0 2
57585: PUSH
57586: LD_VAR 0 2
57590: PPUSH
57591: LD_VAR 0 2
57595: PUSH
57596: LD_INT 1
57598: PLUS
57599: PPUSH
57600: LD_VAR 0 7
57604: PPUSH
57605: CALL_OW 1
57609: ST_TO_ADDR
57610: GO 57578
57612: POP
57613: POP
// end ;
57614: GO 57544
57616: POP
57617: POP
// if not result then
57618: LD_VAR 0 2
57622: NOT
57623: IFFALSE 57627
// exit ;
57625: GO 57775
// mech := result [ 1 ] ;
57627: LD_ADDR_VAR 0 5
57631: PUSH
57632: LD_VAR 0 2
57636: PUSH
57637: LD_INT 1
57639: ARRAY
57640: ST_TO_ADDR
// if result > 1 then
57641: LD_VAR 0 2
57645: PUSH
57646: LD_INT 1
57648: GREATER
57649: IFFALSE 57761
// begin for i = 2 to result do
57651: LD_ADDR_VAR 0 3
57655: PUSH
57656: DOUBLE
57657: LD_INT 2
57659: DEC
57660: ST_TO_ADDR
57661: LD_VAR 0 2
57665: PUSH
57666: FOR_TO
57667: IFFALSE 57759
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57669: LD_ADDR_VAR 0 4
57673: PUSH
57674: LD_VAR 0 2
57678: PUSH
57679: LD_VAR 0 3
57683: ARRAY
57684: PPUSH
57685: LD_INT 3
57687: PPUSH
57688: CALL_OW 259
57692: PUSH
57693: LD_VAR 0 2
57697: PUSH
57698: LD_VAR 0 3
57702: ARRAY
57703: PPUSH
57704: CALL_OW 432
57708: MINUS
57709: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57710: LD_VAR 0 4
57714: PUSH
57715: LD_VAR 0 5
57719: PPUSH
57720: LD_INT 3
57722: PPUSH
57723: CALL_OW 259
57727: PUSH
57728: LD_VAR 0 5
57732: PPUSH
57733: CALL_OW 432
57737: MINUS
57738: GREATEREQUAL
57739: IFFALSE 57757
// mech := result [ i ] ;
57741: LD_ADDR_VAR 0 5
57745: PUSH
57746: LD_VAR 0 2
57750: PUSH
57751: LD_VAR 0 3
57755: ARRAY
57756: ST_TO_ADDR
// end ;
57757: GO 57666
57759: POP
57760: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57761: LD_VAR 0 1
57765: PPUSH
57766: LD_VAR 0 5
57770: PPUSH
57771: CALL_OW 135
// end ;
57775: LD_VAR 0 2
57779: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57780: LD_INT 0
57782: PPUSH
57783: PPUSH
57784: PPUSH
57785: PPUSH
57786: PPUSH
57787: PPUSH
57788: PPUSH
57789: PPUSH
57790: PPUSH
57791: PPUSH
57792: PPUSH
57793: PPUSH
57794: PPUSH
// result := [ ] ;
57795: LD_ADDR_VAR 0 7
57799: PUSH
57800: EMPTY
57801: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57802: LD_VAR 0 1
57806: PPUSH
57807: CALL_OW 266
57811: PUSH
57812: LD_INT 0
57814: PUSH
57815: LD_INT 1
57817: PUSH
57818: EMPTY
57819: LIST
57820: LIST
57821: IN
57822: NOT
57823: IFFALSE 57827
// exit ;
57825: GO 59461
// if name then
57827: LD_VAR 0 3
57831: IFFALSE 57847
// SetBName ( base_dep , name ) ;
57833: LD_VAR 0 1
57837: PPUSH
57838: LD_VAR 0 3
57842: PPUSH
57843: CALL_OW 500
// base := GetBase ( base_dep ) ;
57847: LD_ADDR_VAR 0 15
57851: PUSH
57852: LD_VAR 0 1
57856: PPUSH
57857: CALL_OW 274
57861: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57862: LD_ADDR_VAR 0 16
57866: PUSH
57867: LD_VAR 0 1
57871: PPUSH
57872: CALL_OW 255
57876: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57877: LD_ADDR_VAR 0 17
57881: PUSH
57882: LD_VAR 0 1
57886: PPUSH
57887: CALL_OW 248
57891: ST_TO_ADDR
// if sources then
57892: LD_VAR 0 5
57896: IFFALSE 57943
// for i = 1 to 3 do
57898: LD_ADDR_VAR 0 8
57902: PUSH
57903: DOUBLE
57904: LD_INT 1
57906: DEC
57907: ST_TO_ADDR
57908: LD_INT 3
57910: PUSH
57911: FOR_TO
57912: IFFALSE 57941
// AddResourceType ( base , i , sources [ i ] ) ;
57914: LD_VAR 0 15
57918: PPUSH
57919: LD_VAR 0 8
57923: PPUSH
57924: LD_VAR 0 5
57928: PUSH
57929: LD_VAR 0 8
57933: ARRAY
57934: PPUSH
57935: CALL_OW 276
57939: GO 57911
57941: POP
57942: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57943: LD_ADDR_VAR 0 18
57947: PUSH
57948: LD_VAR 0 15
57952: PPUSH
57953: LD_VAR 0 2
57957: PPUSH
57958: LD_INT 1
57960: PPUSH
57961: CALL 57204 0 3
57965: ST_TO_ADDR
// InitHc ;
57966: CALL_OW 19
// InitUc ;
57970: CALL_OW 18
// uc_side := side ;
57974: LD_ADDR_OWVAR 20
57978: PUSH
57979: LD_VAR 0 16
57983: ST_TO_ADDR
// uc_nation := nation ;
57984: LD_ADDR_OWVAR 21
57988: PUSH
57989: LD_VAR 0 17
57993: ST_TO_ADDR
// if buildings then
57994: LD_VAR 0 18
57998: IFFALSE 59320
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
58000: LD_ADDR_VAR 0 19
58004: PUSH
58005: LD_VAR 0 18
58009: PPUSH
58010: LD_INT 2
58012: PUSH
58013: LD_INT 30
58015: PUSH
58016: LD_INT 29
58018: PUSH
58019: EMPTY
58020: LIST
58021: LIST
58022: PUSH
58023: LD_INT 30
58025: PUSH
58026: LD_INT 30
58028: PUSH
58029: EMPTY
58030: LIST
58031: LIST
58032: PUSH
58033: EMPTY
58034: LIST
58035: LIST
58036: LIST
58037: PPUSH
58038: CALL_OW 72
58042: ST_TO_ADDR
// if tmp then
58043: LD_VAR 0 19
58047: IFFALSE 58095
// for i in tmp do
58049: LD_ADDR_VAR 0 8
58053: PUSH
58054: LD_VAR 0 19
58058: PUSH
58059: FOR_IN
58060: IFFALSE 58093
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
58062: LD_VAR 0 8
58066: PPUSH
58067: CALL_OW 250
58071: PPUSH
58072: LD_VAR 0 8
58076: PPUSH
58077: CALL_OW 251
58081: PPUSH
58082: LD_VAR 0 16
58086: PPUSH
58087: CALL_OW 441
58091: GO 58059
58093: POP
58094: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
58095: LD_VAR 0 18
58099: PPUSH
58100: LD_INT 2
58102: PUSH
58103: LD_INT 30
58105: PUSH
58106: LD_INT 32
58108: PUSH
58109: EMPTY
58110: LIST
58111: LIST
58112: PUSH
58113: LD_INT 30
58115: PUSH
58116: LD_INT 33
58118: PUSH
58119: EMPTY
58120: LIST
58121: LIST
58122: PUSH
58123: EMPTY
58124: LIST
58125: LIST
58126: LIST
58127: PPUSH
58128: CALL_OW 72
58132: IFFALSE 58220
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
58134: LD_ADDR_VAR 0 8
58138: PUSH
58139: LD_VAR 0 18
58143: PPUSH
58144: LD_INT 2
58146: PUSH
58147: LD_INT 30
58149: PUSH
58150: LD_INT 32
58152: PUSH
58153: EMPTY
58154: LIST
58155: LIST
58156: PUSH
58157: LD_INT 30
58159: PUSH
58160: LD_INT 33
58162: PUSH
58163: EMPTY
58164: LIST
58165: LIST
58166: PUSH
58167: EMPTY
58168: LIST
58169: LIST
58170: LIST
58171: PPUSH
58172: CALL_OW 72
58176: PUSH
58177: FOR_IN
58178: IFFALSE 58218
// begin if not GetBWeapon ( i ) then
58180: LD_VAR 0 8
58184: PPUSH
58185: CALL_OW 269
58189: NOT
58190: IFFALSE 58216
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
58192: LD_VAR 0 8
58196: PPUSH
58197: LD_VAR 0 8
58201: PPUSH
58202: LD_VAR 0 2
58206: PPUSH
58207: CALL 59466 0 2
58211: PPUSH
58212: CALL_OW 431
// end ;
58216: GO 58177
58218: POP
58219: POP
// end ; for i = 1 to personel do
58220: LD_ADDR_VAR 0 8
58224: PUSH
58225: DOUBLE
58226: LD_INT 1
58228: DEC
58229: ST_TO_ADDR
58230: LD_VAR 0 6
58234: PUSH
58235: FOR_TO
58236: IFFALSE 59300
// begin if i > 4 then
58238: LD_VAR 0 8
58242: PUSH
58243: LD_INT 4
58245: GREATER
58246: IFFALSE 58250
// break ;
58248: GO 59300
// case i of 1 :
58250: LD_VAR 0 8
58254: PUSH
58255: LD_INT 1
58257: DOUBLE
58258: EQUAL
58259: IFTRUE 58263
58261: GO 58343
58263: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
58264: LD_ADDR_VAR 0 12
58268: PUSH
58269: LD_VAR 0 18
58273: PPUSH
58274: LD_INT 22
58276: PUSH
58277: LD_VAR 0 16
58281: PUSH
58282: EMPTY
58283: LIST
58284: LIST
58285: PUSH
58286: LD_INT 58
58288: PUSH
58289: EMPTY
58290: LIST
58291: PUSH
58292: LD_INT 2
58294: PUSH
58295: LD_INT 30
58297: PUSH
58298: LD_INT 32
58300: PUSH
58301: EMPTY
58302: LIST
58303: LIST
58304: PUSH
58305: LD_INT 30
58307: PUSH
58308: LD_INT 4
58310: PUSH
58311: EMPTY
58312: LIST
58313: LIST
58314: PUSH
58315: LD_INT 30
58317: PUSH
58318: LD_INT 5
58320: PUSH
58321: EMPTY
58322: LIST
58323: LIST
58324: PUSH
58325: EMPTY
58326: LIST
58327: LIST
58328: LIST
58329: LIST
58330: PUSH
58331: EMPTY
58332: LIST
58333: LIST
58334: LIST
58335: PPUSH
58336: CALL_OW 72
58340: ST_TO_ADDR
58341: GO 58565
58343: LD_INT 2
58345: DOUBLE
58346: EQUAL
58347: IFTRUE 58351
58349: GO 58413
58351: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
58352: LD_ADDR_VAR 0 12
58356: PUSH
58357: LD_VAR 0 18
58361: PPUSH
58362: LD_INT 22
58364: PUSH
58365: LD_VAR 0 16
58369: PUSH
58370: EMPTY
58371: LIST
58372: LIST
58373: PUSH
58374: LD_INT 2
58376: PUSH
58377: LD_INT 30
58379: PUSH
58380: LD_INT 0
58382: PUSH
58383: EMPTY
58384: LIST
58385: LIST
58386: PUSH
58387: LD_INT 30
58389: PUSH
58390: LD_INT 1
58392: PUSH
58393: EMPTY
58394: LIST
58395: LIST
58396: PUSH
58397: EMPTY
58398: LIST
58399: LIST
58400: LIST
58401: PUSH
58402: EMPTY
58403: LIST
58404: LIST
58405: PPUSH
58406: CALL_OW 72
58410: ST_TO_ADDR
58411: GO 58565
58413: LD_INT 3
58415: DOUBLE
58416: EQUAL
58417: IFTRUE 58421
58419: GO 58483
58421: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58422: LD_ADDR_VAR 0 12
58426: PUSH
58427: LD_VAR 0 18
58431: PPUSH
58432: LD_INT 22
58434: PUSH
58435: LD_VAR 0 16
58439: PUSH
58440: EMPTY
58441: LIST
58442: LIST
58443: PUSH
58444: LD_INT 2
58446: PUSH
58447: LD_INT 30
58449: PUSH
58450: LD_INT 2
58452: PUSH
58453: EMPTY
58454: LIST
58455: LIST
58456: PUSH
58457: LD_INT 30
58459: PUSH
58460: LD_INT 3
58462: PUSH
58463: EMPTY
58464: LIST
58465: LIST
58466: PUSH
58467: EMPTY
58468: LIST
58469: LIST
58470: LIST
58471: PUSH
58472: EMPTY
58473: LIST
58474: LIST
58475: PPUSH
58476: CALL_OW 72
58480: ST_TO_ADDR
58481: GO 58565
58483: LD_INT 4
58485: DOUBLE
58486: EQUAL
58487: IFTRUE 58491
58489: GO 58564
58491: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58492: LD_ADDR_VAR 0 12
58496: PUSH
58497: LD_VAR 0 18
58501: PPUSH
58502: LD_INT 22
58504: PUSH
58505: LD_VAR 0 16
58509: PUSH
58510: EMPTY
58511: LIST
58512: LIST
58513: PUSH
58514: LD_INT 2
58516: PUSH
58517: LD_INT 30
58519: PUSH
58520: LD_INT 6
58522: PUSH
58523: EMPTY
58524: LIST
58525: LIST
58526: PUSH
58527: LD_INT 30
58529: PUSH
58530: LD_INT 7
58532: PUSH
58533: EMPTY
58534: LIST
58535: LIST
58536: PUSH
58537: LD_INT 30
58539: PUSH
58540: LD_INT 8
58542: PUSH
58543: EMPTY
58544: LIST
58545: LIST
58546: PUSH
58547: EMPTY
58548: LIST
58549: LIST
58550: LIST
58551: LIST
58552: PUSH
58553: EMPTY
58554: LIST
58555: LIST
58556: PPUSH
58557: CALL_OW 72
58561: ST_TO_ADDR
58562: GO 58565
58564: POP
// if i = 1 then
58565: LD_VAR 0 8
58569: PUSH
58570: LD_INT 1
58572: EQUAL
58573: IFFALSE 58684
// begin tmp := [ ] ;
58575: LD_ADDR_VAR 0 19
58579: PUSH
58580: EMPTY
58581: ST_TO_ADDR
// for j in f do
58582: LD_ADDR_VAR 0 9
58586: PUSH
58587: LD_VAR 0 12
58591: PUSH
58592: FOR_IN
58593: IFFALSE 58666
// if GetBType ( j ) = b_bunker then
58595: LD_VAR 0 9
58599: PPUSH
58600: CALL_OW 266
58604: PUSH
58605: LD_INT 32
58607: EQUAL
58608: IFFALSE 58635
// tmp := Insert ( tmp , 1 , j ) else
58610: LD_ADDR_VAR 0 19
58614: PUSH
58615: LD_VAR 0 19
58619: PPUSH
58620: LD_INT 1
58622: PPUSH
58623: LD_VAR 0 9
58627: PPUSH
58628: CALL_OW 2
58632: ST_TO_ADDR
58633: GO 58664
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58635: LD_ADDR_VAR 0 19
58639: PUSH
58640: LD_VAR 0 19
58644: PPUSH
58645: LD_VAR 0 19
58649: PUSH
58650: LD_INT 1
58652: PLUS
58653: PPUSH
58654: LD_VAR 0 9
58658: PPUSH
58659: CALL_OW 2
58663: ST_TO_ADDR
58664: GO 58592
58666: POP
58667: POP
// if tmp then
58668: LD_VAR 0 19
58672: IFFALSE 58684
// f := tmp ;
58674: LD_ADDR_VAR 0 12
58678: PUSH
58679: LD_VAR 0 19
58683: ST_TO_ADDR
// end ; x := personel [ i ] ;
58684: LD_ADDR_VAR 0 13
58688: PUSH
58689: LD_VAR 0 6
58693: PUSH
58694: LD_VAR 0 8
58698: ARRAY
58699: ST_TO_ADDR
// if x = - 1 then
58700: LD_VAR 0 13
58704: PUSH
58705: LD_INT 1
58707: NEG
58708: EQUAL
58709: IFFALSE 58918
// begin for j in f do
58711: LD_ADDR_VAR 0 9
58715: PUSH
58716: LD_VAR 0 12
58720: PUSH
58721: FOR_IN
58722: IFFALSE 58914
// repeat InitHc ;
58724: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58728: LD_VAR 0 9
58732: PPUSH
58733: CALL_OW 266
58737: PUSH
58738: LD_INT 5
58740: EQUAL
58741: IFFALSE 58811
// begin if UnitsInside ( j ) < 3 then
58743: LD_VAR 0 9
58747: PPUSH
58748: CALL_OW 313
58752: PUSH
58753: LD_INT 3
58755: LESS
58756: IFFALSE 58792
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58758: LD_INT 0
58760: PPUSH
58761: LD_INT 5
58763: PUSH
58764: LD_INT 8
58766: PUSH
58767: LD_INT 9
58769: PUSH
58770: EMPTY
58771: LIST
58772: LIST
58773: LIST
58774: PUSH
58775: LD_VAR 0 17
58779: ARRAY
58780: PPUSH
58781: LD_VAR 0 4
58785: PPUSH
58786: CALL_OW 380
58790: GO 58809
// PrepareHuman ( false , i , skill ) ;
58792: LD_INT 0
58794: PPUSH
58795: LD_VAR 0 8
58799: PPUSH
58800: LD_VAR 0 4
58804: PPUSH
58805: CALL_OW 380
// end else
58809: GO 58828
// PrepareHuman ( false , i , skill ) ;
58811: LD_INT 0
58813: PPUSH
58814: LD_VAR 0 8
58818: PPUSH
58819: LD_VAR 0 4
58823: PPUSH
58824: CALL_OW 380
// un := CreateHuman ;
58828: LD_ADDR_VAR 0 14
58832: PUSH
58833: CALL_OW 44
58837: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58838: LD_ADDR_VAR 0 7
58842: PUSH
58843: LD_VAR 0 7
58847: PPUSH
58848: LD_INT 1
58850: PPUSH
58851: LD_VAR 0 14
58855: PPUSH
58856: CALL_OW 2
58860: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58861: LD_VAR 0 14
58865: PPUSH
58866: LD_VAR 0 9
58870: PPUSH
58871: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58875: LD_VAR 0 9
58879: PPUSH
58880: CALL_OW 313
58884: PUSH
58885: LD_INT 6
58887: EQUAL
58888: PUSH
58889: LD_VAR 0 9
58893: PPUSH
58894: CALL_OW 266
58898: PUSH
58899: LD_INT 32
58901: PUSH
58902: LD_INT 31
58904: PUSH
58905: EMPTY
58906: LIST
58907: LIST
58908: IN
58909: OR
58910: IFFALSE 58724
58912: GO 58721
58914: POP
58915: POP
// end else
58916: GO 59298
// for j = 1 to x do
58918: LD_ADDR_VAR 0 9
58922: PUSH
58923: DOUBLE
58924: LD_INT 1
58926: DEC
58927: ST_TO_ADDR
58928: LD_VAR 0 13
58932: PUSH
58933: FOR_TO
58934: IFFALSE 59296
// begin InitHc ;
58936: CALL_OW 19
// if not f then
58940: LD_VAR 0 12
58944: NOT
58945: IFFALSE 59034
// begin PrepareHuman ( false , i , skill ) ;
58947: LD_INT 0
58949: PPUSH
58950: LD_VAR 0 8
58954: PPUSH
58955: LD_VAR 0 4
58959: PPUSH
58960: CALL_OW 380
// un := CreateHuman ;
58964: LD_ADDR_VAR 0 14
58968: PUSH
58969: CALL_OW 44
58973: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58974: LD_ADDR_VAR 0 7
58978: PUSH
58979: LD_VAR 0 7
58983: PPUSH
58984: LD_INT 1
58986: PPUSH
58987: LD_VAR 0 14
58991: PPUSH
58992: CALL_OW 2
58996: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58997: LD_VAR 0 14
59001: PPUSH
59002: LD_VAR 0 1
59006: PPUSH
59007: CALL_OW 250
59011: PPUSH
59012: LD_VAR 0 1
59016: PPUSH
59017: CALL_OW 251
59021: PPUSH
59022: LD_INT 10
59024: PPUSH
59025: LD_INT 0
59027: PPUSH
59028: CALL_OW 50
// continue ;
59032: GO 58933
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
59034: LD_VAR 0 12
59038: PUSH
59039: LD_INT 1
59041: ARRAY
59042: PPUSH
59043: CALL_OW 313
59047: PUSH
59048: LD_VAR 0 12
59052: PUSH
59053: LD_INT 1
59055: ARRAY
59056: PPUSH
59057: CALL_OW 266
59061: PUSH
59062: LD_INT 32
59064: PUSH
59065: LD_INT 31
59067: PUSH
59068: EMPTY
59069: LIST
59070: LIST
59071: IN
59072: AND
59073: PUSH
59074: LD_VAR 0 12
59078: PUSH
59079: LD_INT 1
59081: ARRAY
59082: PPUSH
59083: CALL_OW 313
59087: PUSH
59088: LD_INT 6
59090: EQUAL
59091: OR
59092: IFFALSE 59112
// f := Delete ( f , 1 ) ;
59094: LD_ADDR_VAR 0 12
59098: PUSH
59099: LD_VAR 0 12
59103: PPUSH
59104: LD_INT 1
59106: PPUSH
59107: CALL_OW 3
59111: ST_TO_ADDR
// if not f then
59112: LD_VAR 0 12
59116: NOT
59117: IFFALSE 59135
// begin x := x + 2 ;
59119: LD_ADDR_VAR 0 13
59123: PUSH
59124: LD_VAR 0 13
59128: PUSH
59129: LD_INT 2
59131: PLUS
59132: ST_TO_ADDR
// continue ;
59133: GO 58933
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
59135: LD_VAR 0 12
59139: PUSH
59140: LD_INT 1
59142: ARRAY
59143: PPUSH
59144: CALL_OW 266
59148: PUSH
59149: LD_INT 5
59151: EQUAL
59152: IFFALSE 59226
// begin if UnitsInside ( f [ 1 ] ) < 3 then
59154: LD_VAR 0 12
59158: PUSH
59159: LD_INT 1
59161: ARRAY
59162: PPUSH
59163: CALL_OW 313
59167: PUSH
59168: LD_INT 3
59170: LESS
59171: IFFALSE 59207
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59173: LD_INT 0
59175: PPUSH
59176: LD_INT 5
59178: PUSH
59179: LD_INT 8
59181: PUSH
59182: LD_INT 9
59184: PUSH
59185: EMPTY
59186: LIST
59187: LIST
59188: LIST
59189: PUSH
59190: LD_VAR 0 17
59194: ARRAY
59195: PPUSH
59196: LD_VAR 0 4
59200: PPUSH
59201: CALL_OW 380
59205: GO 59224
// PrepareHuman ( false , i , skill ) ;
59207: LD_INT 0
59209: PPUSH
59210: LD_VAR 0 8
59214: PPUSH
59215: LD_VAR 0 4
59219: PPUSH
59220: CALL_OW 380
// end else
59224: GO 59243
// PrepareHuman ( false , i , skill ) ;
59226: LD_INT 0
59228: PPUSH
59229: LD_VAR 0 8
59233: PPUSH
59234: LD_VAR 0 4
59238: PPUSH
59239: CALL_OW 380
// un := CreateHuman ;
59243: LD_ADDR_VAR 0 14
59247: PUSH
59248: CALL_OW 44
59252: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59253: LD_ADDR_VAR 0 7
59257: PUSH
59258: LD_VAR 0 7
59262: PPUSH
59263: LD_INT 1
59265: PPUSH
59266: LD_VAR 0 14
59270: PPUSH
59271: CALL_OW 2
59275: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
59276: LD_VAR 0 14
59280: PPUSH
59281: LD_VAR 0 12
59285: PUSH
59286: LD_INT 1
59288: ARRAY
59289: PPUSH
59290: CALL_OW 52
// end ;
59294: GO 58933
59296: POP
59297: POP
// end ;
59298: GO 58235
59300: POP
59301: POP
// result := result ^ buildings ;
59302: LD_ADDR_VAR 0 7
59306: PUSH
59307: LD_VAR 0 7
59311: PUSH
59312: LD_VAR 0 18
59316: ADD
59317: ST_TO_ADDR
// end else
59318: GO 59461
// begin for i = 1 to personel do
59320: LD_ADDR_VAR 0 8
59324: PUSH
59325: DOUBLE
59326: LD_INT 1
59328: DEC
59329: ST_TO_ADDR
59330: LD_VAR 0 6
59334: PUSH
59335: FOR_TO
59336: IFFALSE 59459
// begin if i > 4 then
59338: LD_VAR 0 8
59342: PUSH
59343: LD_INT 4
59345: GREATER
59346: IFFALSE 59350
// break ;
59348: GO 59459
// x := personel [ i ] ;
59350: LD_ADDR_VAR 0 13
59354: PUSH
59355: LD_VAR 0 6
59359: PUSH
59360: LD_VAR 0 8
59364: ARRAY
59365: ST_TO_ADDR
// if x = - 1 then
59366: LD_VAR 0 13
59370: PUSH
59371: LD_INT 1
59373: NEG
59374: EQUAL
59375: IFFALSE 59379
// continue ;
59377: GO 59335
// PrepareHuman ( false , i , skill ) ;
59379: LD_INT 0
59381: PPUSH
59382: LD_VAR 0 8
59386: PPUSH
59387: LD_VAR 0 4
59391: PPUSH
59392: CALL_OW 380
// un := CreateHuman ;
59396: LD_ADDR_VAR 0 14
59400: PUSH
59401: CALL_OW 44
59405: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59406: LD_VAR 0 14
59410: PPUSH
59411: LD_VAR 0 1
59415: PPUSH
59416: CALL_OW 250
59420: PPUSH
59421: LD_VAR 0 1
59425: PPUSH
59426: CALL_OW 251
59430: PPUSH
59431: LD_INT 10
59433: PPUSH
59434: LD_INT 0
59436: PPUSH
59437: CALL_OW 50
// result := result ^ un ;
59441: LD_ADDR_VAR 0 7
59445: PUSH
59446: LD_VAR 0 7
59450: PUSH
59451: LD_VAR 0 14
59455: ADD
59456: ST_TO_ADDR
// end ;
59457: GO 59335
59459: POP
59460: POP
// end ; end ;
59461: LD_VAR 0 7
59465: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59466: LD_INT 0
59468: PPUSH
59469: PPUSH
59470: PPUSH
59471: PPUSH
59472: PPUSH
59473: PPUSH
59474: PPUSH
59475: PPUSH
59476: PPUSH
59477: PPUSH
59478: PPUSH
59479: PPUSH
59480: PPUSH
59481: PPUSH
59482: PPUSH
59483: PPUSH
// result := false ;
59484: LD_ADDR_VAR 0 3
59488: PUSH
59489: LD_INT 0
59491: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59492: LD_VAR 0 1
59496: NOT
59497: PUSH
59498: LD_VAR 0 1
59502: PPUSH
59503: CALL_OW 266
59507: PUSH
59508: LD_INT 32
59510: PUSH
59511: LD_INT 33
59513: PUSH
59514: EMPTY
59515: LIST
59516: LIST
59517: IN
59518: NOT
59519: OR
59520: IFFALSE 59524
// exit ;
59522: GO 60633
// nat := GetNation ( tower ) ;
59524: LD_ADDR_VAR 0 12
59528: PUSH
59529: LD_VAR 0 1
59533: PPUSH
59534: CALL_OW 248
59538: ST_TO_ADDR
// side := GetSide ( tower ) ;
59539: LD_ADDR_VAR 0 16
59543: PUSH
59544: LD_VAR 0 1
59548: PPUSH
59549: CALL_OW 255
59553: ST_TO_ADDR
// x := GetX ( tower ) ;
59554: LD_ADDR_VAR 0 10
59558: PUSH
59559: LD_VAR 0 1
59563: PPUSH
59564: CALL_OW 250
59568: ST_TO_ADDR
// y := GetY ( tower ) ;
59569: LD_ADDR_VAR 0 11
59573: PUSH
59574: LD_VAR 0 1
59578: PPUSH
59579: CALL_OW 251
59583: ST_TO_ADDR
// if not x or not y then
59584: LD_VAR 0 10
59588: NOT
59589: PUSH
59590: LD_VAR 0 11
59594: NOT
59595: OR
59596: IFFALSE 59600
// exit ;
59598: GO 60633
// weapon := 0 ;
59600: LD_ADDR_VAR 0 18
59604: PUSH
59605: LD_INT 0
59607: ST_TO_ADDR
// fac_list := [ ] ;
59608: LD_ADDR_VAR 0 17
59612: PUSH
59613: EMPTY
59614: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
59615: LD_ADDR_VAR 0 6
59619: PUSH
59620: LD_VAR 0 1
59624: PPUSH
59625: CALL_OW 274
59629: PPUSH
59630: LD_VAR 0 2
59634: PPUSH
59635: LD_INT 0
59637: PPUSH
59638: CALL 57204 0 3
59642: PPUSH
59643: LD_INT 30
59645: PUSH
59646: LD_INT 3
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: PPUSH
59653: CALL_OW 72
59657: ST_TO_ADDR
// if not factories then
59658: LD_VAR 0 6
59662: NOT
59663: IFFALSE 59667
// exit ;
59665: GO 60633
// for i in factories do
59667: LD_ADDR_VAR 0 8
59671: PUSH
59672: LD_VAR 0 6
59676: PUSH
59677: FOR_IN
59678: IFFALSE 59703
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59680: LD_ADDR_VAR 0 17
59684: PUSH
59685: LD_VAR 0 17
59689: PUSH
59690: LD_VAR 0 8
59694: PPUSH
59695: CALL_OW 478
59699: UNION
59700: ST_TO_ADDR
59701: GO 59677
59703: POP
59704: POP
// if not fac_list then
59705: LD_VAR 0 17
59709: NOT
59710: IFFALSE 59714
// exit ;
59712: GO 60633
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59714: LD_ADDR_VAR 0 5
59718: PUSH
59719: LD_INT 4
59721: PUSH
59722: LD_INT 5
59724: PUSH
59725: LD_INT 9
59727: PUSH
59728: LD_INT 10
59730: PUSH
59731: LD_INT 6
59733: PUSH
59734: LD_INT 7
59736: PUSH
59737: LD_INT 11
59739: PUSH
59740: EMPTY
59741: LIST
59742: LIST
59743: LIST
59744: LIST
59745: LIST
59746: LIST
59747: LIST
59748: PUSH
59749: LD_INT 27
59751: PUSH
59752: LD_INT 28
59754: PUSH
59755: LD_INT 26
59757: PUSH
59758: LD_INT 30
59760: PUSH
59761: EMPTY
59762: LIST
59763: LIST
59764: LIST
59765: LIST
59766: PUSH
59767: LD_INT 43
59769: PUSH
59770: LD_INT 44
59772: PUSH
59773: LD_INT 46
59775: PUSH
59776: LD_INT 45
59778: PUSH
59779: LD_INT 47
59781: PUSH
59782: LD_INT 49
59784: PUSH
59785: EMPTY
59786: LIST
59787: LIST
59788: LIST
59789: LIST
59790: LIST
59791: LIST
59792: PUSH
59793: EMPTY
59794: LIST
59795: LIST
59796: LIST
59797: PUSH
59798: LD_VAR 0 12
59802: ARRAY
59803: ST_TO_ADDR
// list := list isect fac_list ;
59804: LD_ADDR_VAR 0 5
59808: PUSH
59809: LD_VAR 0 5
59813: PUSH
59814: LD_VAR 0 17
59818: ISECT
59819: ST_TO_ADDR
// if not list then
59820: LD_VAR 0 5
59824: NOT
59825: IFFALSE 59829
// exit ;
59827: GO 60633
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59829: LD_VAR 0 12
59833: PUSH
59834: LD_INT 3
59836: EQUAL
59837: PUSH
59838: LD_INT 49
59840: PUSH
59841: LD_VAR 0 5
59845: IN
59846: AND
59847: PUSH
59848: LD_INT 31
59850: PPUSH
59851: LD_VAR 0 16
59855: PPUSH
59856: CALL_OW 321
59860: PUSH
59861: LD_INT 2
59863: EQUAL
59864: AND
59865: IFFALSE 59925
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59867: LD_INT 22
59869: PUSH
59870: LD_VAR 0 16
59874: PUSH
59875: EMPTY
59876: LIST
59877: LIST
59878: PUSH
59879: LD_INT 35
59881: PUSH
59882: LD_INT 49
59884: PUSH
59885: EMPTY
59886: LIST
59887: LIST
59888: PUSH
59889: LD_INT 91
59891: PUSH
59892: LD_VAR 0 1
59896: PUSH
59897: LD_INT 10
59899: PUSH
59900: EMPTY
59901: LIST
59902: LIST
59903: LIST
59904: PUSH
59905: EMPTY
59906: LIST
59907: LIST
59908: LIST
59909: PPUSH
59910: CALL_OW 69
59914: NOT
59915: IFFALSE 59925
// weapon := ru_time_lapser ;
59917: LD_ADDR_VAR 0 18
59921: PUSH
59922: LD_INT 49
59924: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59925: LD_VAR 0 12
59929: PUSH
59930: LD_INT 1
59932: PUSH
59933: LD_INT 2
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: IN
59940: PUSH
59941: LD_INT 11
59943: PUSH
59944: LD_VAR 0 5
59948: IN
59949: PUSH
59950: LD_INT 30
59952: PUSH
59953: LD_VAR 0 5
59957: IN
59958: OR
59959: AND
59960: PUSH
59961: LD_INT 6
59963: PPUSH
59964: LD_VAR 0 16
59968: PPUSH
59969: CALL_OW 321
59973: PUSH
59974: LD_INT 2
59976: EQUAL
59977: AND
59978: IFFALSE 60143
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59980: LD_INT 22
59982: PUSH
59983: LD_VAR 0 16
59987: PUSH
59988: EMPTY
59989: LIST
59990: LIST
59991: PUSH
59992: LD_INT 2
59994: PUSH
59995: LD_INT 35
59997: PUSH
59998: LD_INT 11
60000: PUSH
60001: EMPTY
60002: LIST
60003: LIST
60004: PUSH
60005: LD_INT 35
60007: PUSH
60008: LD_INT 30
60010: PUSH
60011: EMPTY
60012: LIST
60013: LIST
60014: PUSH
60015: EMPTY
60016: LIST
60017: LIST
60018: LIST
60019: PUSH
60020: LD_INT 91
60022: PUSH
60023: LD_VAR 0 1
60027: PUSH
60028: LD_INT 18
60030: PUSH
60031: EMPTY
60032: LIST
60033: LIST
60034: LIST
60035: PUSH
60036: EMPTY
60037: LIST
60038: LIST
60039: LIST
60040: PPUSH
60041: CALL_OW 69
60045: NOT
60046: PUSH
60047: LD_INT 22
60049: PUSH
60050: LD_VAR 0 16
60054: PUSH
60055: EMPTY
60056: LIST
60057: LIST
60058: PUSH
60059: LD_INT 2
60061: PUSH
60062: LD_INT 30
60064: PUSH
60065: LD_INT 32
60067: PUSH
60068: EMPTY
60069: LIST
60070: LIST
60071: PUSH
60072: LD_INT 30
60074: PUSH
60075: LD_INT 33
60077: PUSH
60078: EMPTY
60079: LIST
60080: LIST
60081: PUSH
60082: EMPTY
60083: LIST
60084: LIST
60085: LIST
60086: PUSH
60087: LD_INT 91
60089: PUSH
60090: LD_VAR 0 1
60094: PUSH
60095: LD_INT 12
60097: PUSH
60098: EMPTY
60099: LIST
60100: LIST
60101: LIST
60102: PUSH
60103: EMPTY
60104: LIST
60105: LIST
60106: LIST
60107: PUSH
60108: EMPTY
60109: LIST
60110: PPUSH
60111: CALL_OW 69
60115: PUSH
60116: LD_INT 2
60118: GREATER
60119: AND
60120: IFFALSE 60143
// weapon := [ us_radar , ar_radar ] [ nat ] ;
60122: LD_ADDR_VAR 0 18
60126: PUSH
60127: LD_INT 11
60129: PUSH
60130: LD_INT 30
60132: PUSH
60133: EMPTY
60134: LIST
60135: LIST
60136: PUSH
60137: LD_VAR 0 12
60141: ARRAY
60142: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
60143: LD_VAR 0 18
60147: NOT
60148: PUSH
60149: LD_INT 40
60151: PPUSH
60152: LD_VAR 0 16
60156: PPUSH
60157: CALL_OW 321
60161: PUSH
60162: LD_INT 2
60164: EQUAL
60165: AND
60166: PUSH
60167: LD_INT 7
60169: PUSH
60170: LD_VAR 0 5
60174: IN
60175: PUSH
60176: LD_INT 28
60178: PUSH
60179: LD_VAR 0 5
60183: IN
60184: OR
60185: PUSH
60186: LD_INT 45
60188: PUSH
60189: LD_VAR 0 5
60193: IN
60194: OR
60195: AND
60196: IFFALSE 60450
// begin hex := GetHexInfo ( x , y ) ;
60198: LD_ADDR_VAR 0 4
60202: PUSH
60203: LD_VAR 0 10
60207: PPUSH
60208: LD_VAR 0 11
60212: PPUSH
60213: CALL_OW 546
60217: ST_TO_ADDR
// if hex [ 1 ] then
60218: LD_VAR 0 4
60222: PUSH
60223: LD_INT 1
60225: ARRAY
60226: IFFALSE 60230
// exit ;
60228: GO 60633
// height := hex [ 2 ] ;
60230: LD_ADDR_VAR 0 15
60234: PUSH
60235: LD_VAR 0 4
60239: PUSH
60240: LD_INT 2
60242: ARRAY
60243: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
60244: LD_ADDR_VAR 0 14
60248: PUSH
60249: LD_INT 0
60251: PUSH
60252: LD_INT 2
60254: PUSH
60255: LD_INT 3
60257: PUSH
60258: LD_INT 5
60260: PUSH
60261: EMPTY
60262: LIST
60263: LIST
60264: LIST
60265: LIST
60266: ST_TO_ADDR
// for i in tmp do
60267: LD_ADDR_VAR 0 8
60271: PUSH
60272: LD_VAR 0 14
60276: PUSH
60277: FOR_IN
60278: IFFALSE 60448
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
60280: LD_ADDR_VAR 0 9
60284: PUSH
60285: LD_VAR 0 10
60289: PPUSH
60290: LD_VAR 0 8
60294: PPUSH
60295: LD_INT 5
60297: PPUSH
60298: CALL_OW 272
60302: PUSH
60303: LD_VAR 0 11
60307: PPUSH
60308: LD_VAR 0 8
60312: PPUSH
60313: LD_INT 5
60315: PPUSH
60316: CALL_OW 273
60320: PUSH
60321: EMPTY
60322: LIST
60323: LIST
60324: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
60325: LD_VAR 0 9
60329: PUSH
60330: LD_INT 1
60332: ARRAY
60333: PPUSH
60334: LD_VAR 0 9
60338: PUSH
60339: LD_INT 2
60341: ARRAY
60342: PPUSH
60343: CALL_OW 488
60347: IFFALSE 60446
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
60349: LD_ADDR_VAR 0 4
60353: PUSH
60354: LD_VAR 0 9
60358: PUSH
60359: LD_INT 1
60361: ARRAY
60362: PPUSH
60363: LD_VAR 0 9
60367: PUSH
60368: LD_INT 2
60370: ARRAY
60371: PPUSH
60372: CALL_OW 546
60376: ST_TO_ADDR
// if hex [ 1 ] then
60377: LD_VAR 0 4
60381: PUSH
60382: LD_INT 1
60384: ARRAY
60385: IFFALSE 60389
// continue ;
60387: GO 60277
// h := hex [ 2 ] ;
60389: LD_ADDR_VAR 0 13
60393: PUSH
60394: LD_VAR 0 4
60398: PUSH
60399: LD_INT 2
60401: ARRAY
60402: ST_TO_ADDR
// if h + 7 < height then
60403: LD_VAR 0 13
60407: PUSH
60408: LD_INT 7
60410: PLUS
60411: PUSH
60412: LD_VAR 0 15
60416: LESS
60417: IFFALSE 60446
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60419: LD_ADDR_VAR 0 18
60423: PUSH
60424: LD_INT 7
60426: PUSH
60427: LD_INT 28
60429: PUSH
60430: LD_INT 45
60432: PUSH
60433: EMPTY
60434: LIST
60435: LIST
60436: LIST
60437: PUSH
60438: LD_VAR 0 12
60442: ARRAY
60443: ST_TO_ADDR
// break ;
60444: GO 60448
// end ; end ; end ;
60446: GO 60277
60448: POP
60449: POP
// end ; if not weapon then
60450: LD_VAR 0 18
60454: NOT
60455: IFFALSE 60515
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60457: LD_ADDR_VAR 0 5
60461: PUSH
60462: LD_VAR 0 5
60466: PUSH
60467: LD_INT 11
60469: PUSH
60470: LD_INT 30
60472: PUSH
60473: LD_INT 49
60475: PUSH
60476: EMPTY
60477: LIST
60478: LIST
60479: LIST
60480: DIFF
60481: ST_TO_ADDR
// if not list then
60482: LD_VAR 0 5
60486: NOT
60487: IFFALSE 60491
// exit ;
60489: GO 60633
// weapon := list [ rand ( 1 , list ) ] ;
60491: LD_ADDR_VAR 0 18
60495: PUSH
60496: LD_VAR 0 5
60500: PUSH
60501: LD_INT 1
60503: PPUSH
60504: LD_VAR 0 5
60508: PPUSH
60509: CALL_OW 12
60513: ARRAY
60514: ST_TO_ADDR
// end ; if weapon then
60515: LD_VAR 0 18
60519: IFFALSE 60633
// begin tmp := CostOfWeapon ( weapon ) ;
60521: LD_ADDR_VAR 0 14
60525: PUSH
60526: LD_VAR 0 18
60530: PPUSH
60531: CALL_OW 451
60535: ST_TO_ADDR
// j := GetBase ( tower ) ;
60536: LD_ADDR_VAR 0 9
60540: PUSH
60541: LD_VAR 0 1
60545: PPUSH
60546: CALL_OW 274
60550: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60551: LD_VAR 0 9
60555: PPUSH
60556: LD_INT 1
60558: PPUSH
60559: CALL_OW 275
60563: PUSH
60564: LD_VAR 0 14
60568: PUSH
60569: LD_INT 1
60571: ARRAY
60572: GREATEREQUAL
60573: PUSH
60574: LD_VAR 0 9
60578: PPUSH
60579: LD_INT 2
60581: PPUSH
60582: CALL_OW 275
60586: PUSH
60587: LD_VAR 0 14
60591: PUSH
60592: LD_INT 2
60594: ARRAY
60595: GREATEREQUAL
60596: AND
60597: PUSH
60598: LD_VAR 0 9
60602: PPUSH
60603: LD_INT 3
60605: PPUSH
60606: CALL_OW 275
60610: PUSH
60611: LD_VAR 0 14
60615: PUSH
60616: LD_INT 3
60618: ARRAY
60619: GREATEREQUAL
60620: AND
60621: IFFALSE 60633
// result := weapon ;
60623: LD_ADDR_VAR 0 3
60627: PUSH
60628: LD_VAR 0 18
60632: ST_TO_ADDR
// end ; end ;
60633: LD_VAR 0 3
60637: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60638: LD_INT 0
60640: PPUSH
60641: PPUSH
// result := true ;
60642: LD_ADDR_VAR 0 3
60646: PUSH
60647: LD_INT 1
60649: ST_TO_ADDR
// if array1 = array2 then
60650: LD_VAR 0 1
60654: PUSH
60655: LD_VAR 0 2
60659: EQUAL
60660: IFFALSE 60720
// begin for i = 1 to array1 do
60662: LD_ADDR_VAR 0 4
60666: PUSH
60667: DOUBLE
60668: LD_INT 1
60670: DEC
60671: ST_TO_ADDR
60672: LD_VAR 0 1
60676: PUSH
60677: FOR_TO
60678: IFFALSE 60716
// if array1 [ i ] <> array2 [ i ] then
60680: LD_VAR 0 1
60684: PUSH
60685: LD_VAR 0 4
60689: ARRAY
60690: PUSH
60691: LD_VAR 0 2
60695: PUSH
60696: LD_VAR 0 4
60700: ARRAY
60701: NONEQUAL
60702: IFFALSE 60714
// begin result := false ;
60704: LD_ADDR_VAR 0 3
60708: PUSH
60709: LD_INT 0
60711: ST_TO_ADDR
// break ;
60712: GO 60716
// end ;
60714: GO 60677
60716: POP
60717: POP
// end else
60718: GO 60728
// result := false ;
60720: LD_ADDR_VAR 0 3
60724: PUSH
60725: LD_INT 0
60727: ST_TO_ADDR
// end ;
60728: LD_VAR 0 3
60732: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60733: LD_INT 0
60735: PPUSH
60736: PPUSH
// if not array1 or not array2 then
60737: LD_VAR 0 1
60741: NOT
60742: PUSH
60743: LD_VAR 0 2
60747: NOT
60748: OR
60749: IFFALSE 60753
// exit ;
60751: GO 60817
// result := true ;
60753: LD_ADDR_VAR 0 3
60757: PUSH
60758: LD_INT 1
60760: ST_TO_ADDR
// for i = 1 to array1 do
60761: LD_ADDR_VAR 0 4
60765: PUSH
60766: DOUBLE
60767: LD_INT 1
60769: DEC
60770: ST_TO_ADDR
60771: LD_VAR 0 1
60775: PUSH
60776: FOR_TO
60777: IFFALSE 60815
// if array1 [ i ] <> array2 [ i ] then
60779: LD_VAR 0 1
60783: PUSH
60784: LD_VAR 0 4
60788: ARRAY
60789: PUSH
60790: LD_VAR 0 2
60794: PUSH
60795: LD_VAR 0 4
60799: ARRAY
60800: NONEQUAL
60801: IFFALSE 60813
// begin result := false ;
60803: LD_ADDR_VAR 0 3
60807: PUSH
60808: LD_INT 0
60810: ST_TO_ADDR
// break ;
60811: GO 60815
// end ;
60813: GO 60776
60815: POP
60816: POP
// end ;
60817: LD_VAR 0 3
60821: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60822: LD_INT 0
60824: PPUSH
60825: PPUSH
60826: PPUSH
// pom := GetBase ( fac ) ;
60827: LD_ADDR_VAR 0 5
60831: PUSH
60832: LD_VAR 0 1
60836: PPUSH
60837: CALL_OW 274
60841: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60842: LD_ADDR_VAR 0 4
60846: PUSH
60847: LD_VAR 0 2
60851: PUSH
60852: LD_INT 1
60854: ARRAY
60855: PPUSH
60856: LD_VAR 0 2
60860: PUSH
60861: LD_INT 2
60863: ARRAY
60864: PPUSH
60865: LD_VAR 0 2
60869: PUSH
60870: LD_INT 3
60872: ARRAY
60873: PPUSH
60874: LD_VAR 0 2
60878: PUSH
60879: LD_INT 4
60881: ARRAY
60882: PPUSH
60883: CALL_OW 449
60887: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60888: LD_ADDR_VAR 0 3
60892: PUSH
60893: LD_VAR 0 5
60897: PPUSH
60898: LD_INT 1
60900: PPUSH
60901: CALL_OW 275
60905: PUSH
60906: LD_VAR 0 4
60910: PUSH
60911: LD_INT 1
60913: ARRAY
60914: GREATEREQUAL
60915: PUSH
60916: LD_VAR 0 5
60920: PPUSH
60921: LD_INT 2
60923: PPUSH
60924: CALL_OW 275
60928: PUSH
60929: LD_VAR 0 4
60933: PUSH
60934: LD_INT 2
60936: ARRAY
60937: GREATEREQUAL
60938: AND
60939: PUSH
60940: LD_VAR 0 5
60944: PPUSH
60945: LD_INT 3
60947: PPUSH
60948: CALL_OW 275
60952: PUSH
60953: LD_VAR 0 4
60957: PUSH
60958: LD_INT 3
60960: ARRAY
60961: GREATEREQUAL
60962: AND
60963: ST_TO_ADDR
// end ;
60964: LD_VAR 0 3
60968: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60969: LD_INT 0
60971: PPUSH
60972: PPUSH
60973: PPUSH
60974: PPUSH
// pom := GetBase ( building ) ;
60975: LD_ADDR_VAR 0 3
60979: PUSH
60980: LD_VAR 0 1
60984: PPUSH
60985: CALL_OW 274
60989: ST_TO_ADDR
// if not pom then
60990: LD_VAR 0 3
60994: NOT
60995: IFFALSE 60999
// exit ;
60997: GO 61169
// btype := GetBType ( building ) ;
60999: LD_ADDR_VAR 0 5
61003: PUSH
61004: LD_VAR 0 1
61008: PPUSH
61009: CALL_OW 266
61013: ST_TO_ADDR
// if btype = b_armoury then
61014: LD_VAR 0 5
61018: PUSH
61019: LD_INT 4
61021: EQUAL
61022: IFFALSE 61032
// btype := b_barracks ;
61024: LD_ADDR_VAR 0 5
61028: PUSH
61029: LD_INT 5
61031: ST_TO_ADDR
// if btype = b_depot then
61032: LD_VAR 0 5
61036: PUSH
61037: LD_INT 0
61039: EQUAL
61040: IFFALSE 61050
// btype := b_warehouse ;
61042: LD_ADDR_VAR 0 5
61046: PUSH
61047: LD_INT 1
61049: ST_TO_ADDR
// if btype = b_workshop then
61050: LD_VAR 0 5
61054: PUSH
61055: LD_INT 2
61057: EQUAL
61058: IFFALSE 61068
// btype := b_factory ;
61060: LD_ADDR_VAR 0 5
61064: PUSH
61065: LD_INT 3
61067: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61068: LD_ADDR_VAR 0 4
61072: PUSH
61073: LD_VAR 0 5
61077: PPUSH
61078: LD_VAR 0 1
61082: PPUSH
61083: CALL_OW 248
61087: PPUSH
61088: CALL_OW 450
61092: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61093: LD_ADDR_VAR 0 2
61097: PUSH
61098: LD_VAR 0 3
61102: PPUSH
61103: LD_INT 1
61105: PPUSH
61106: CALL_OW 275
61110: PUSH
61111: LD_VAR 0 4
61115: PUSH
61116: LD_INT 1
61118: ARRAY
61119: GREATEREQUAL
61120: PUSH
61121: LD_VAR 0 3
61125: PPUSH
61126: LD_INT 2
61128: PPUSH
61129: CALL_OW 275
61133: PUSH
61134: LD_VAR 0 4
61138: PUSH
61139: LD_INT 2
61141: ARRAY
61142: GREATEREQUAL
61143: AND
61144: PUSH
61145: LD_VAR 0 3
61149: PPUSH
61150: LD_INT 3
61152: PPUSH
61153: CALL_OW 275
61157: PUSH
61158: LD_VAR 0 4
61162: PUSH
61163: LD_INT 3
61165: ARRAY
61166: GREATEREQUAL
61167: AND
61168: ST_TO_ADDR
// end ;
61169: LD_VAR 0 2
61173: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
61174: LD_INT 0
61176: PPUSH
61177: PPUSH
61178: PPUSH
// pom := GetBase ( building ) ;
61179: LD_ADDR_VAR 0 4
61183: PUSH
61184: LD_VAR 0 1
61188: PPUSH
61189: CALL_OW 274
61193: ST_TO_ADDR
// if not pom then
61194: LD_VAR 0 4
61198: NOT
61199: IFFALSE 61203
// exit ;
61201: GO 61304
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61203: LD_ADDR_VAR 0 5
61207: PUSH
61208: LD_VAR 0 2
61212: PPUSH
61213: LD_VAR 0 1
61217: PPUSH
61218: CALL_OW 248
61222: PPUSH
61223: CALL_OW 450
61227: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61228: LD_ADDR_VAR 0 3
61232: PUSH
61233: LD_VAR 0 4
61237: PPUSH
61238: LD_INT 1
61240: PPUSH
61241: CALL_OW 275
61245: PUSH
61246: LD_VAR 0 5
61250: PUSH
61251: LD_INT 1
61253: ARRAY
61254: GREATEREQUAL
61255: PUSH
61256: LD_VAR 0 4
61260: PPUSH
61261: LD_INT 2
61263: PPUSH
61264: CALL_OW 275
61268: PUSH
61269: LD_VAR 0 5
61273: PUSH
61274: LD_INT 2
61276: ARRAY
61277: GREATEREQUAL
61278: AND
61279: PUSH
61280: LD_VAR 0 4
61284: PPUSH
61285: LD_INT 3
61287: PPUSH
61288: CALL_OW 275
61292: PUSH
61293: LD_VAR 0 5
61297: PUSH
61298: LD_INT 3
61300: ARRAY
61301: GREATEREQUAL
61302: AND
61303: ST_TO_ADDR
// end ;
61304: LD_VAR 0 3
61308: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
61309: LD_INT 0
61311: PPUSH
61312: PPUSH
61313: PPUSH
61314: PPUSH
61315: PPUSH
61316: PPUSH
61317: PPUSH
61318: PPUSH
61319: PPUSH
61320: PPUSH
61321: PPUSH
// result := false ;
61322: LD_ADDR_VAR 0 8
61326: PUSH
61327: LD_INT 0
61329: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
61330: LD_VAR 0 5
61334: NOT
61335: PUSH
61336: LD_VAR 0 1
61340: NOT
61341: OR
61342: PUSH
61343: LD_VAR 0 2
61347: NOT
61348: OR
61349: PUSH
61350: LD_VAR 0 3
61354: NOT
61355: OR
61356: IFFALSE 61360
// exit ;
61358: GO 62174
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
61360: LD_ADDR_VAR 0 14
61364: PUSH
61365: LD_VAR 0 1
61369: PPUSH
61370: LD_VAR 0 2
61374: PPUSH
61375: LD_VAR 0 3
61379: PPUSH
61380: LD_VAR 0 4
61384: PPUSH
61385: LD_VAR 0 5
61389: PUSH
61390: LD_INT 1
61392: ARRAY
61393: PPUSH
61394: CALL_OW 248
61398: PPUSH
61399: LD_INT 0
61401: PPUSH
61402: CALL 63427 0 6
61406: ST_TO_ADDR
// if not hexes then
61407: LD_VAR 0 14
61411: NOT
61412: IFFALSE 61416
// exit ;
61414: GO 62174
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61416: LD_ADDR_VAR 0 17
61420: PUSH
61421: LD_VAR 0 5
61425: PPUSH
61426: LD_INT 22
61428: PUSH
61429: LD_VAR 0 13
61433: PPUSH
61434: CALL_OW 255
61438: PUSH
61439: EMPTY
61440: LIST
61441: LIST
61442: PUSH
61443: LD_INT 2
61445: PUSH
61446: LD_INT 30
61448: PUSH
61449: LD_INT 0
61451: PUSH
61452: EMPTY
61453: LIST
61454: LIST
61455: PUSH
61456: LD_INT 30
61458: PUSH
61459: LD_INT 1
61461: PUSH
61462: EMPTY
61463: LIST
61464: LIST
61465: PUSH
61466: EMPTY
61467: LIST
61468: LIST
61469: LIST
61470: PUSH
61471: EMPTY
61472: LIST
61473: LIST
61474: PPUSH
61475: CALL_OW 72
61479: ST_TO_ADDR
// for i = 1 to hexes do
61480: LD_ADDR_VAR 0 9
61484: PUSH
61485: DOUBLE
61486: LD_INT 1
61488: DEC
61489: ST_TO_ADDR
61490: LD_VAR 0 14
61494: PUSH
61495: FOR_TO
61496: IFFALSE 62172
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61498: LD_ADDR_VAR 0 13
61502: PUSH
61503: LD_VAR 0 14
61507: PUSH
61508: LD_VAR 0 9
61512: ARRAY
61513: PUSH
61514: LD_INT 1
61516: ARRAY
61517: PPUSH
61518: LD_VAR 0 14
61522: PUSH
61523: LD_VAR 0 9
61527: ARRAY
61528: PUSH
61529: LD_INT 2
61531: ARRAY
61532: PPUSH
61533: CALL_OW 428
61537: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61538: LD_VAR 0 14
61542: PUSH
61543: LD_VAR 0 9
61547: ARRAY
61548: PUSH
61549: LD_INT 1
61551: ARRAY
61552: PPUSH
61553: LD_VAR 0 14
61557: PUSH
61558: LD_VAR 0 9
61562: ARRAY
61563: PUSH
61564: LD_INT 2
61566: ARRAY
61567: PPUSH
61568: CALL_OW 351
61572: PUSH
61573: LD_VAR 0 14
61577: PUSH
61578: LD_VAR 0 9
61582: ARRAY
61583: PUSH
61584: LD_INT 1
61586: ARRAY
61587: PPUSH
61588: LD_VAR 0 14
61592: PUSH
61593: LD_VAR 0 9
61597: ARRAY
61598: PUSH
61599: LD_INT 2
61601: ARRAY
61602: PPUSH
61603: CALL_OW 488
61607: NOT
61608: OR
61609: PUSH
61610: LD_VAR 0 13
61614: PPUSH
61615: CALL_OW 247
61619: PUSH
61620: LD_INT 3
61622: EQUAL
61623: OR
61624: IFFALSE 61630
// exit ;
61626: POP
61627: POP
61628: GO 62174
// if not tmp then
61630: LD_VAR 0 13
61634: NOT
61635: IFFALSE 61639
// continue ;
61637: GO 61495
// result := true ;
61639: LD_ADDR_VAR 0 8
61643: PUSH
61644: LD_INT 1
61646: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
61647: LD_VAR 0 6
61651: PUSH
61652: LD_VAR 0 13
61656: PPUSH
61657: CALL_OW 247
61661: PUSH
61662: LD_INT 2
61664: EQUAL
61665: AND
61666: PUSH
61667: LD_VAR 0 13
61671: PPUSH
61672: CALL_OW 263
61676: PUSH
61677: LD_INT 1
61679: EQUAL
61680: AND
61681: IFFALSE 61845
// begin if IsDrivenBy ( tmp ) then
61683: LD_VAR 0 13
61687: PPUSH
61688: CALL_OW 311
61692: IFFALSE 61696
// continue ;
61694: GO 61495
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61696: LD_VAR 0 6
61700: PPUSH
61701: LD_INT 3
61703: PUSH
61704: LD_INT 60
61706: PUSH
61707: EMPTY
61708: LIST
61709: PUSH
61710: EMPTY
61711: LIST
61712: LIST
61713: PUSH
61714: LD_INT 3
61716: PUSH
61717: LD_INT 55
61719: PUSH
61720: EMPTY
61721: LIST
61722: PUSH
61723: EMPTY
61724: LIST
61725: LIST
61726: PUSH
61727: EMPTY
61728: LIST
61729: LIST
61730: PPUSH
61731: CALL_OW 72
61735: IFFALSE 61843
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61737: LD_ADDR_VAR 0 18
61741: PUSH
61742: LD_VAR 0 6
61746: PPUSH
61747: LD_INT 3
61749: PUSH
61750: LD_INT 60
61752: PUSH
61753: EMPTY
61754: LIST
61755: PUSH
61756: EMPTY
61757: LIST
61758: LIST
61759: PUSH
61760: LD_INT 3
61762: PUSH
61763: LD_INT 55
61765: PUSH
61766: EMPTY
61767: LIST
61768: PUSH
61769: EMPTY
61770: LIST
61771: LIST
61772: PUSH
61773: EMPTY
61774: LIST
61775: LIST
61776: PPUSH
61777: CALL_OW 72
61781: PUSH
61782: LD_INT 1
61784: ARRAY
61785: ST_TO_ADDR
// if IsInUnit ( driver ) then
61786: LD_VAR 0 18
61790: PPUSH
61791: CALL_OW 310
61795: IFFALSE 61806
// ComExit ( driver ) ;
61797: LD_VAR 0 18
61801: PPUSH
61802: CALL 87219 0 1
// AddComEnterUnit ( driver , tmp ) ;
61806: LD_VAR 0 18
61810: PPUSH
61811: LD_VAR 0 13
61815: PPUSH
61816: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61820: LD_VAR 0 18
61824: PPUSH
61825: LD_VAR 0 7
61829: PPUSH
61830: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61834: LD_VAR 0 18
61838: PPUSH
61839: CALL_OW 181
// end ; continue ;
61843: GO 61495
// end ; if not cleaners or not tmp in cleaners then
61845: LD_VAR 0 6
61849: NOT
61850: PUSH
61851: LD_VAR 0 13
61855: PUSH
61856: LD_VAR 0 6
61860: IN
61861: NOT
61862: OR
61863: IFFALSE 62170
// begin if dep then
61865: LD_VAR 0 17
61869: IFFALSE 62005
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61871: LD_ADDR_VAR 0 16
61875: PUSH
61876: LD_VAR 0 17
61880: PUSH
61881: LD_INT 1
61883: ARRAY
61884: PPUSH
61885: CALL_OW 250
61889: PPUSH
61890: LD_VAR 0 17
61894: PUSH
61895: LD_INT 1
61897: ARRAY
61898: PPUSH
61899: CALL_OW 254
61903: PPUSH
61904: LD_INT 5
61906: PPUSH
61907: CALL_OW 272
61911: PUSH
61912: LD_VAR 0 17
61916: PUSH
61917: LD_INT 1
61919: ARRAY
61920: PPUSH
61921: CALL_OW 251
61925: PPUSH
61926: LD_VAR 0 17
61930: PUSH
61931: LD_INT 1
61933: ARRAY
61934: PPUSH
61935: CALL_OW 254
61939: PPUSH
61940: LD_INT 5
61942: PPUSH
61943: CALL_OW 273
61947: PUSH
61948: EMPTY
61949: LIST
61950: LIST
61951: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61952: LD_VAR 0 16
61956: PUSH
61957: LD_INT 1
61959: ARRAY
61960: PPUSH
61961: LD_VAR 0 16
61965: PUSH
61966: LD_INT 2
61968: ARRAY
61969: PPUSH
61970: CALL_OW 488
61974: IFFALSE 62005
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61976: LD_VAR 0 13
61980: PPUSH
61981: LD_VAR 0 16
61985: PUSH
61986: LD_INT 1
61988: ARRAY
61989: PPUSH
61990: LD_VAR 0 16
61994: PUSH
61995: LD_INT 2
61997: ARRAY
61998: PPUSH
61999: CALL_OW 111
// continue ;
62003: GO 61495
// end ; end ; r := GetDir ( tmp ) ;
62005: LD_ADDR_VAR 0 15
62009: PUSH
62010: LD_VAR 0 13
62014: PPUSH
62015: CALL_OW 254
62019: ST_TO_ADDR
// if r = 5 then
62020: LD_VAR 0 15
62024: PUSH
62025: LD_INT 5
62027: EQUAL
62028: IFFALSE 62038
// r := 0 ;
62030: LD_ADDR_VAR 0 15
62034: PUSH
62035: LD_INT 0
62037: ST_TO_ADDR
// for j = r to 5 do
62038: LD_ADDR_VAR 0 10
62042: PUSH
62043: DOUBLE
62044: LD_VAR 0 15
62048: DEC
62049: ST_TO_ADDR
62050: LD_INT 5
62052: PUSH
62053: FOR_TO
62054: IFFALSE 62168
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
62056: LD_ADDR_VAR 0 11
62060: PUSH
62061: LD_VAR 0 13
62065: PPUSH
62066: CALL_OW 250
62070: PPUSH
62071: LD_VAR 0 10
62075: PPUSH
62076: LD_INT 2
62078: PPUSH
62079: CALL_OW 272
62083: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
62084: LD_ADDR_VAR 0 12
62088: PUSH
62089: LD_VAR 0 13
62093: PPUSH
62094: CALL_OW 251
62098: PPUSH
62099: LD_VAR 0 10
62103: PPUSH
62104: LD_INT 2
62106: PPUSH
62107: CALL_OW 273
62111: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
62112: LD_VAR 0 11
62116: PPUSH
62117: LD_VAR 0 12
62121: PPUSH
62122: CALL_OW 488
62126: PUSH
62127: LD_VAR 0 11
62131: PPUSH
62132: LD_VAR 0 12
62136: PPUSH
62137: CALL_OW 428
62141: NOT
62142: AND
62143: IFFALSE 62166
// begin ComMoveXY ( tmp , _x , _y ) ;
62145: LD_VAR 0 13
62149: PPUSH
62150: LD_VAR 0 11
62154: PPUSH
62155: LD_VAR 0 12
62159: PPUSH
62160: CALL_OW 111
// break ;
62164: GO 62168
// end ; end ;
62166: GO 62053
62168: POP
62169: POP
// end ; end ;
62170: GO 61495
62172: POP
62173: POP
// end ;
62174: LD_VAR 0 8
62178: RET
// export function BuildingTechInvented ( side , btype ) ; begin
62179: LD_INT 0
62181: PPUSH
// result := true ;
62182: LD_ADDR_VAR 0 3
62186: PUSH
62187: LD_INT 1
62189: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
62190: LD_VAR 0 2
62194: PUSH
62195: LD_INT 24
62197: DOUBLE
62198: EQUAL
62199: IFTRUE 62209
62201: LD_INT 33
62203: DOUBLE
62204: EQUAL
62205: IFTRUE 62209
62207: GO 62234
62209: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
62210: LD_ADDR_VAR 0 3
62214: PUSH
62215: LD_INT 32
62217: PPUSH
62218: LD_VAR 0 1
62222: PPUSH
62223: CALL_OW 321
62227: PUSH
62228: LD_INT 2
62230: EQUAL
62231: ST_TO_ADDR
62232: GO 62550
62234: LD_INT 20
62236: DOUBLE
62237: EQUAL
62238: IFTRUE 62242
62240: GO 62267
62242: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
62243: LD_ADDR_VAR 0 3
62247: PUSH
62248: LD_INT 6
62250: PPUSH
62251: LD_VAR 0 1
62255: PPUSH
62256: CALL_OW 321
62260: PUSH
62261: LD_INT 2
62263: EQUAL
62264: ST_TO_ADDR
62265: GO 62550
62267: LD_INT 22
62269: DOUBLE
62270: EQUAL
62271: IFTRUE 62281
62273: LD_INT 36
62275: DOUBLE
62276: EQUAL
62277: IFTRUE 62281
62279: GO 62306
62281: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
62282: LD_ADDR_VAR 0 3
62286: PUSH
62287: LD_INT 15
62289: PPUSH
62290: LD_VAR 0 1
62294: PPUSH
62295: CALL_OW 321
62299: PUSH
62300: LD_INT 2
62302: EQUAL
62303: ST_TO_ADDR
62304: GO 62550
62306: LD_INT 30
62308: DOUBLE
62309: EQUAL
62310: IFTRUE 62314
62312: GO 62339
62314: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
62315: LD_ADDR_VAR 0 3
62319: PUSH
62320: LD_INT 20
62322: PPUSH
62323: LD_VAR 0 1
62327: PPUSH
62328: CALL_OW 321
62332: PUSH
62333: LD_INT 2
62335: EQUAL
62336: ST_TO_ADDR
62337: GO 62550
62339: LD_INT 28
62341: DOUBLE
62342: EQUAL
62343: IFTRUE 62353
62345: LD_INT 21
62347: DOUBLE
62348: EQUAL
62349: IFTRUE 62353
62351: GO 62378
62353: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
62354: LD_ADDR_VAR 0 3
62358: PUSH
62359: LD_INT 21
62361: PPUSH
62362: LD_VAR 0 1
62366: PPUSH
62367: CALL_OW 321
62371: PUSH
62372: LD_INT 2
62374: EQUAL
62375: ST_TO_ADDR
62376: GO 62550
62378: LD_INT 16
62380: DOUBLE
62381: EQUAL
62382: IFTRUE 62386
62384: GO 62411
62386: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
62387: LD_ADDR_VAR 0 3
62391: PUSH
62392: LD_INT 84
62394: PPUSH
62395: LD_VAR 0 1
62399: PPUSH
62400: CALL_OW 321
62404: PUSH
62405: LD_INT 2
62407: EQUAL
62408: ST_TO_ADDR
62409: GO 62550
62411: LD_INT 19
62413: DOUBLE
62414: EQUAL
62415: IFTRUE 62425
62417: LD_INT 23
62419: DOUBLE
62420: EQUAL
62421: IFTRUE 62425
62423: GO 62450
62425: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
62426: LD_ADDR_VAR 0 3
62430: PUSH
62431: LD_INT 83
62433: PPUSH
62434: LD_VAR 0 1
62438: PPUSH
62439: CALL_OW 321
62443: PUSH
62444: LD_INT 2
62446: EQUAL
62447: ST_TO_ADDR
62448: GO 62550
62450: LD_INT 17
62452: DOUBLE
62453: EQUAL
62454: IFTRUE 62458
62456: GO 62483
62458: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
62459: LD_ADDR_VAR 0 3
62463: PUSH
62464: LD_INT 39
62466: PPUSH
62467: LD_VAR 0 1
62471: PPUSH
62472: CALL_OW 321
62476: PUSH
62477: LD_INT 2
62479: EQUAL
62480: ST_TO_ADDR
62481: GO 62550
62483: LD_INT 18
62485: DOUBLE
62486: EQUAL
62487: IFTRUE 62491
62489: GO 62516
62491: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
62492: LD_ADDR_VAR 0 3
62496: PUSH
62497: LD_INT 40
62499: PPUSH
62500: LD_VAR 0 1
62504: PPUSH
62505: CALL_OW 321
62509: PUSH
62510: LD_INT 2
62512: EQUAL
62513: ST_TO_ADDR
62514: GO 62550
62516: LD_INT 27
62518: DOUBLE
62519: EQUAL
62520: IFTRUE 62524
62522: GO 62549
62524: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
62525: LD_ADDR_VAR 0 3
62529: PUSH
62530: LD_INT 35
62532: PPUSH
62533: LD_VAR 0 1
62537: PPUSH
62538: CALL_OW 321
62542: PUSH
62543: LD_INT 2
62545: EQUAL
62546: ST_TO_ADDR
62547: GO 62550
62549: POP
// end ;
62550: LD_VAR 0 3
62554: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
62555: LD_INT 0
62557: PPUSH
62558: PPUSH
62559: PPUSH
62560: PPUSH
62561: PPUSH
62562: PPUSH
62563: PPUSH
62564: PPUSH
62565: PPUSH
62566: PPUSH
62567: PPUSH
// result := false ;
62568: LD_ADDR_VAR 0 6
62572: PUSH
62573: LD_INT 0
62575: ST_TO_ADDR
// if btype = b_depot then
62576: LD_VAR 0 2
62580: PUSH
62581: LD_INT 0
62583: EQUAL
62584: IFFALSE 62596
// begin result := true ;
62586: LD_ADDR_VAR 0 6
62590: PUSH
62591: LD_INT 1
62593: ST_TO_ADDR
// exit ;
62594: GO 63422
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
62596: LD_VAR 0 1
62600: NOT
62601: PUSH
62602: LD_VAR 0 1
62606: PPUSH
62607: CALL_OW 266
62611: PUSH
62612: LD_INT 0
62614: PUSH
62615: LD_INT 1
62617: PUSH
62618: EMPTY
62619: LIST
62620: LIST
62621: IN
62622: NOT
62623: OR
62624: PUSH
62625: LD_VAR 0 2
62629: NOT
62630: OR
62631: PUSH
62632: LD_VAR 0 5
62636: PUSH
62637: LD_INT 0
62639: PUSH
62640: LD_INT 1
62642: PUSH
62643: LD_INT 2
62645: PUSH
62646: LD_INT 3
62648: PUSH
62649: LD_INT 4
62651: PUSH
62652: LD_INT 5
62654: PUSH
62655: EMPTY
62656: LIST
62657: LIST
62658: LIST
62659: LIST
62660: LIST
62661: LIST
62662: IN
62663: NOT
62664: OR
62665: PUSH
62666: LD_VAR 0 3
62670: PPUSH
62671: LD_VAR 0 4
62675: PPUSH
62676: CALL_OW 488
62680: NOT
62681: OR
62682: IFFALSE 62686
// exit ;
62684: GO 63422
// side := GetSide ( depot ) ;
62686: LD_ADDR_VAR 0 9
62690: PUSH
62691: LD_VAR 0 1
62695: PPUSH
62696: CALL_OW 255
62700: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62701: LD_VAR 0 9
62705: PPUSH
62706: LD_VAR 0 2
62710: PPUSH
62711: CALL 62179 0 2
62715: NOT
62716: IFFALSE 62720
// exit ;
62718: GO 63422
// pom := GetBase ( depot ) ;
62720: LD_ADDR_VAR 0 10
62724: PUSH
62725: LD_VAR 0 1
62729: PPUSH
62730: CALL_OW 274
62734: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62735: LD_ADDR_VAR 0 11
62739: PUSH
62740: LD_VAR 0 2
62744: PPUSH
62745: LD_VAR 0 1
62749: PPUSH
62750: CALL_OW 248
62754: PPUSH
62755: CALL_OW 450
62759: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62760: LD_VAR 0 10
62764: PPUSH
62765: LD_INT 1
62767: PPUSH
62768: CALL_OW 275
62772: PUSH
62773: LD_VAR 0 11
62777: PUSH
62778: LD_INT 1
62780: ARRAY
62781: GREATEREQUAL
62782: PUSH
62783: LD_VAR 0 10
62787: PPUSH
62788: LD_INT 2
62790: PPUSH
62791: CALL_OW 275
62795: PUSH
62796: LD_VAR 0 11
62800: PUSH
62801: LD_INT 2
62803: ARRAY
62804: GREATEREQUAL
62805: AND
62806: PUSH
62807: LD_VAR 0 10
62811: PPUSH
62812: LD_INT 3
62814: PPUSH
62815: CALL_OW 275
62819: PUSH
62820: LD_VAR 0 11
62824: PUSH
62825: LD_INT 3
62827: ARRAY
62828: GREATEREQUAL
62829: AND
62830: NOT
62831: IFFALSE 62835
// exit ;
62833: GO 63422
// if GetBType ( depot ) = b_depot then
62835: LD_VAR 0 1
62839: PPUSH
62840: CALL_OW 266
62844: PUSH
62845: LD_INT 0
62847: EQUAL
62848: IFFALSE 62860
// dist := 28 else
62850: LD_ADDR_VAR 0 14
62854: PUSH
62855: LD_INT 28
62857: ST_TO_ADDR
62858: GO 62868
// dist := 36 ;
62860: LD_ADDR_VAR 0 14
62864: PUSH
62865: LD_INT 36
62867: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62868: LD_VAR 0 1
62872: PPUSH
62873: LD_VAR 0 3
62877: PPUSH
62878: LD_VAR 0 4
62882: PPUSH
62883: CALL_OW 297
62887: PUSH
62888: LD_VAR 0 14
62892: GREATER
62893: IFFALSE 62897
// exit ;
62895: GO 63422
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62897: LD_ADDR_VAR 0 12
62901: PUSH
62902: LD_VAR 0 2
62906: PPUSH
62907: LD_VAR 0 3
62911: PPUSH
62912: LD_VAR 0 4
62916: PPUSH
62917: LD_VAR 0 5
62921: PPUSH
62922: LD_VAR 0 1
62926: PPUSH
62927: CALL_OW 248
62931: PPUSH
62932: LD_INT 0
62934: PPUSH
62935: CALL 63427 0 6
62939: ST_TO_ADDR
// if not hexes then
62940: LD_VAR 0 12
62944: NOT
62945: IFFALSE 62949
// exit ;
62947: GO 63422
// hex := GetHexInfo ( x , y ) ;
62949: LD_ADDR_VAR 0 15
62953: PUSH
62954: LD_VAR 0 3
62958: PPUSH
62959: LD_VAR 0 4
62963: PPUSH
62964: CALL_OW 546
62968: ST_TO_ADDR
// if hex [ 1 ] then
62969: LD_VAR 0 15
62973: PUSH
62974: LD_INT 1
62976: ARRAY
62977: IFFALSE 62981
// exit ;
62979: GO 63422
// height := hex [ 2 ] ;
62981: LD_ADDR_VAR 0 13
62985: PUSH
62986: LD_VAR 0 15
62990: PUSH
62991: LD_INT 2
62993: ARRAY
62994: ST_TO_ADDR
// for i = 1 to hexes do
62995: LD_ADDR_VAR 0 7
62999: PUSH
63000: DOUBLE
63001: LD_INT 1
63003: DEC
63004: ST_TO_ADDR
63005: LD_VAR 0 12
63009: PUSH
63010: FOR_TO
63011: IFFALSE 63341
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
63013: LD_VAR 0 12
63017: PUSH
63018: LD_VAR 0 7
63022: ARRAY
63023: PUSH
63024: LD_INT 1
63026: ARRAY
63027: PPUSH
63028: LD_VAR 0 12
63032: PUSH
63033: LD_VAR 0 7
63037: ARRAY
63038: PUSH
63039: LD_INT 2
63041: ARRAY
63042: PPUSH
63043: CALL_OW 488
63047: NOT
63048: PUSH
63049: LD_VAR 0 12
63053: PUSH
63054: LD_VAR 0 7
63058: ARRAY
63059: PUSH
63060: LD_INT 1
63062: ARRAY
63063: PPUSH
63064: LD_VAR 0 12
63068: PUSH
63069: LD_VAR 0 7
63073: ARRAY
63074: PUSH
63075: LD_INT 2
63077: ARRAY
63078: PPUSH
63079: CALL_OW 428
63083: PUSH
63084: LD_INT 0
63086: GREATER
63087: OR
63088: PUSH
63089: LD_VAR 0 12
63093: PUSH
63094: LD_VAR 0 7
63098: ARRAY
63099: PUSH
63100: LD_INT 1
63102: ARRAY
63103: PPUSH
63104: LD_VAR 0 12
63108: PUSH
63109: LD_VAR 0 7
63113: ARRAY
63114: PUSH
63115: LD_INT 2
63117: ARRAY
63118: PPUSH
63119: CALL_OW 351
63123: OR
63124: IFFALSE 63130
// exit ;
63126: POP
63127: POP
63128: GO 63422
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63130: LD_ADDR_VAR 0 8
63134: PUSH
63135: LD_VAR 0 12
63139: PUSH
63140: LD_VAR 0 7
63144: ARRAY
63145: PUSH
63146: LD_INT 1
63148: ARRAY
63149: PPUSH
63150: LD_VAR 0 12
63154: PUSH
63155: LD_VAR 0 7
63159: ARRAY
63160: PUSH
63161: LD_INT 2
63163: ARRAY
63164: PPUSH
63165: CALL_OW 546
63169: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63170: LD_VAR 0 8
63174: PUSH
63175: LD_INT 1
63177: ARRAY
63178: PUSH
63179: LD_VAR 0 8
63183: PUSH
63184: LD_INT 2
63186: ARRAY
63187: PUSH
63188: LD_VAR 0 13
63192: PUSH
63193: LD_INT 2
63195: PLUS
63196: GREATER
63197: OR
63198: PUSH
63199: LD_VAR 0 8
63203: PUSH
63204: LD_INT 2
63206: ARRAY
63207: PUSH
63208: LD_VAR 0 13
63212: PUSH
63213: LD_INT 2
63215: MINUS
63216: LESS
63217: OR
63218: PUSH
63219: LD_VAR 0 8
63223: PUSH
63224: LD_INT 3
63226: ARRAY
63227: PUSH
63228: LD_INT 0
63230: PUSH
63231: LD_INT 8
63233: PUSH
63234: LD_INT 9
63236: PUSH
63237: LD_INT 10
63239: PUSH
63240: LD_INT 11
63242: PUSH
63243: LD_INT 12
63245: PUSH
63246: LD_INT 13
63248: PUSH
63249: LD_INT 16
63251: PUSH
63252: LD_INT 17
63254: PUSH
63255: LD_INT 18
63257: PUSH
63258: LD_INT 19
63260: PUSH
63261: LD_INT 20
63263: PUSH
63264: LD_INT 21
63266: PUSH
63267: EMPTY
63268: LIST
63269: LIST
63270: LIST
63271: LIST
63272: LIST
63273: LIST
63274: LIST
63275: LIST
63276: LIST
63277: LIST
63278: LIST
63279: LIST
63280: LIST
63281: IN
63282: NOT
63283: OR
63284: PUSH
63285: LD_VAR 0 8
63289: PUSH
63290: LD_INT 5
63292: ARRAY
63293: NOT
63294: OR
63295: PUSH
63296: LD_VAR 0 8
63300: PUSH
63301: LD_INT 6
63303: ARRAY
63304: PUSH
63305: LD_INT 1
63307: PUSH
63308: LD_INT 2
63310: PUSH
63311: LD_INT 7
63313: PUSH
63314: LD_INT 9
63316: PUSH
63317: LD_INT 10
63319: PUSH
63320: LD_INT 11
63322: PUSH
63323: EMPTY
63324: LIST
63325: LIST
63326: LIST
63327: LIST
63328: LIST
63329: LIST
63330: IN
63331: NOT
63332: OR
63333: IFFALSE 63339
// exit ;
63335: POP
63336: POP
63337: GO 63422
// end ;
63339: GO 63010
63341: POP
63342: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63343: LD_VAR 0 9
63347: PPUSH
63348: LD_VAR 0 3
63352: PPUSH
63353: LD_VAR 0 4
63357: PPUSH
63358: LD_INT 20
63360: PPUSH
63361: CALL 55345 0 4
63365: PUSH
63366: LD_INT 4
63368: ARRAY
63369: IFFALSE 63373
// exit ;
63371: GO 63422
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63373: LD_VAR 0 2
63377: PUSH
63378: LD_INT 29
63380: PUSH
63381: LD_INT 30
63383: PUSH
63384: EMPTY
63385: LIST
63386: LIST
63387: IN
63388: PUSH
63389: LD_VAR 0 3
63393: PPUSH
63394: LD_VAR 0 4
63398: PPUSH
63399: LD_VAR 0 9
63403: PPUSH
63404: CALL_OW 440
63408: NOT
63409: AND
63410: IFFALSE 63414
// exit ;
63412: GO 63422
// result := true ;
63414: LD_ADDR_VAR 0 6
63418: PUSH
63419: LD_INT 1
63421: ST_TO_ADDR
// end ;
63422: LD_VAR 0 6
63426: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
63427: LD_INT 0
63429: PPUSH
63430: PPUSH
63431: PPUSH
63432: PPUSH
63433: PPUSH
63434: PPUSH
63435: PPUSH
63436: PPUSH
63437: PPUSH
63438: PPUSH
63439: PPUSH
63440: PPUSH
63441: PPUSH
63442: PPUSH
63443: PPUSH
63444: PPUSH
63445: PPUSH
63446: PPUSH
63447: PPUSH
63448: PPUSH
63449: PPUSH
63450: PPUSH
63451: PPUSH
63452: PPUSH
63453: PPUSH
63454: PPUSH
63455: PPUSH
63456: PPUSH
63457: PPUSH
63458: PPUSH
63459: PPUSH
63460: PPUSH
63461: PPUSH
63462: PPUSH
63463: PPUSH
63464: PPUSH
63465: PPUSH
63466: PPUSH
63467: PPUSH
63468: PPUSH
63469: PPUSH
63470: PPUSH
63471: PPUSH
63472: PPUSH
63473: PPUSH
63474: PPUSH
63475: PPUSH
63476: PPUSH
63477: PPUSH
63478: PPUSH
63479: PPUSH
63480: PPUSH
63481: PPUSH
63482: PPUSH
63483: PPUSH
63484: PPUSH
63485: PPUSH
63486: PPUSH
// result = [ ] ;
63487: LD_ADDR_VAR 0 7
63491: PUSH
63492: EMPTY
63493: ST_TO_ADDR
// temp_list = [ ] ;
63494: LD_ADDR_VAR 0 9
63498: PUSH
63499: EMPTY
63500: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63501: LD_VAR 0 4
63505: PUSH
63506: LD_INT 0
63508: PUSH
63509: LD_INT 1
63511: PUSH
63512: LD_INT 2
63514: PUSH
63515: LD_INT 3
63517: PUSH
63518: LD_INT 4
63520: PUSH
63521: LD_INT 5
63523: PUSH
63524: EMPTY
63525: LIST
63526: LIST
63527: LIST
63528: LIST
63529: LIST
63530: LIST
63531: IN
63532: NOT
63533: PUSH
63534: LD_VAR 0 1
63538: PUSH
63539: LD_INT 0
63541: PUSH
63542: LD_INT 1
63544: PUSH
63545: EMPTY
63546: LIST
63547: LIST
63548: IN
63549: PUSH
63550: LD_VAR 0 5
63554: PUSH
63555: LD_INT 1
63557: PUSH
63558: LD_INT 2
63560: PUSH
63561: LD_INT 3
63563: PUSH
63564: EMPTY
63565: LIST
63566: LIST
63567: LIST
63568: IN
63569: NOT
63570: AND
63571: OR
63572: IFFALSE 63576
// exit ;
63574: GO 81967
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
63576: LD_VAR 0 1
63580: PUSH
63581: LD_INT 6
63583: PUSH
63584: LD_INT 7
63586: PUSH
63587: LD_INT 8
63589: PUSH
63590: LD_INT 13
63592: PUSH
63593: LD_INT 12
63595: PUSH
63596: LD_INT 15
63598: PUSH
63599: LD_INT 11
63601: PUSH
63602: LD_INT 14
63604: PUSH
63605: LD_INT 10
63607: PUSH
63608: EMPTY
63609: LIST
63610: LIST
63611: LIST
63612: LIST
63613: LIST
63614: LIST
63615: LIST
63616: LIST
63617: LIST
63618: IN
63619: IFFALSE 63629
// btype = b_lab ;
63621: LD_ADDR_VAR 0 1
63625: PUSH
63626: LD_INT 6
63628: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63629: LD_VAR 0 6
63633: PUSH
63634: LD_INT 0
63636: PUSH
63637: LD_INT 1
63639: PUSH
63640: LD_INT 2
63642: PUSH
63643: EMPTY
63644: LIST
63645: LIST
63646: LIST
63647: IN
63648: NOT
63649: PUSH
63650: LD_VAR 0 1
63654: PUSH
63655: LD_INT 0
63657: PUSH
63658: LD_INT 1
63660: PUSH
63661: LD_INT 2
63663: PUSH
63664: LD_INT 3
63666: PUSH
63667: LD_INT 6
63669: PUSH
63670: LD_INT 36
63672: PUSH
63673: LD_INT 4
63675: PUSH
63676: LD_INT 5
63678: PUSH
63679: LD_INT 31
63681: PUSH
63682: LD_INT 32
63684: PUSH
63685: LD_INT 33
63687: PUSH
63688: EMPTY
63689: LIST
63690: LIST
63691: LIST
63692: LIST
63693: LIST
63694: LIST
63695: LIST
63696: LIST
63697: LIST
63698: LIST
63699: LIST
63700: IN
63701: NOT
63702: PUSH
63703: LD_VAR 0 6
63707: PUSH
63708: LD_INT 1
63710: EQUAL
63711: AND
63712: OR
63713: PUSH
63714: LD_VAR 0 1
63718: PUSH
63719: LD_INT 2
63721: PUSH
63722: LD_INT 3
63724: PUSH
63725: EMPTY
63726: LIST
63727: LIST
63728: IN
63729: NOT
63730: PUSH
63731: LD_VAR 0 6
63735: PUSH
63736: LD_INT 2
63738: EQUAL
63739: AND
63740: OR
63741: IFFALSE 63751
// mode = 0 ;
63743: LD_ADDR_VAR 0 6
63747: PUSH
63748: LD_INT 0
63750: ST_TO_ADDR
// case mode of 0 :
63751: LD_VAR 0 6
63755: PUSH
63756: LD_INT 0
63758: DOUBLE
63759: EQUAL
63760: IFTRUE 63764
63762: GO 75217
63764: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63765: LD_ADDR_VAR 0 11
63769: PUSH
63770: LD_INT 0
63772: PUSH
63773: LD_INT 0
63775: PUSH
63776: EMPTY
63777: LIST
63778: LIST
63779: PUSH
63780: LD_INT 0
63782: PUSH
63783: LD_INT 1
63785: NEG
63786: PUSH
63787: EMPTY
63788: LIST
63789: LIST
63790: PUSH
63791: LD_INT 1
63793: PUSH
63794: LD_INT 0
63796: PUSH
63797: EMPTY
63798: LIST
63799: LIST
63800: PUSH
63801: LD_INT 1
63803: PUSH
63804: LD_INT 1
63806: PUSH
63807: EMPTY
63808: LIST
63809: LIST
63810: PUSH
63811: LD_INT 0
63813: PUSH
63814: LD_INT 1
63816: PUSH
63817: EMPTY
63818: LIST
63819: LIST
63820: PUSH
63821: LD_INT 1
63823: NEG
63824: PUSH
63825: LD_INT 0
63827: PUSH
63828: EMPTY
63829: LIST
63830: LIST
63831: PUSH
63832: LD_INT 1
63834: NEG
63835: PUSH
63836: LD_INT 1
63838: NEG
63839: PUSH
63840: EMPTY
63841: LIST
63842: LIST
63843: PUSH
63844: LD_INT 1
63846: NEG
63847: PUSH
63848: LD_INT 2
63850: NEG
63851: PUSH
63852: EMPTY
63853: LIST
63854: LIST
63855: PUSH
63856: LD_INT 0
63858: PUSH
63859: LD_INT 2
63861: NEG
63862: PUSH
63863: EMPTY
63864: LIST
63865: LIST
63866: PUSH
63867: LD_INT 1
63869: PUSH
63870: LD_INT 1
63872: NEG
63873: PUSH
63874: EMPTY
63875: LIST
63876: LIST
63877: PUSH
63878: LD_INT 1
63880: PUSH
63881: LD_INT 2
63883: PUSH
63884: EMPTY
63885: LIST
63886: LIST
63887: PUSH
63888: LD_INT 0
63890: PUSH
63891: LD_INT 2
63893: PUSH
63894: EMPTY
63895: LIST
63896: LIST
63897: PUSH
63898: LD_INT 1
63900: NEG
63901: PUSH
63902: LD_INT 1
63904: PUSH
63905: EMPTY
63906: LIST
63907: LIST
63908: PUSH
63909: LD_INT 1
63911: PUSH
63912: LD_INT 3
63914: PUSH
63915: EMPTY
63916: LIST
63917: LIST
63918: PUSH
63919: LD_INT 0
63921: PUSH
63922: LD_INT 3
63924: PUSH
63925: EMPTY
63926: LIST
63927: LIST
63928: PUSH
63929: LD_INT 1
63931: NEG
63932: PUSH
63933: LD_INT 2
63935: PUSH
63936: EMPTY
63937: LIST
63938: LIST
63939: PUSH
63940: EMPTY
63941: LIST
63942: LIST
63943: LIST
63944: LIST
63945: LIST
63946: LIST
63947: LIST
63948: LIST
63949: LIST
63950: LIST
63951: LIST
63952: LIST
63953: LIST
63954: LIST
63955: LIST
63956: LIST
63957: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63958: LD_ADDR_VAR 0 12
63962: PUSH
63963: LD_INT 0
63965: PUSH
63966: LD_INT 0
63968: PUSH
63969: EMPTY
63970: LIST
63971: LIST
63972: PUSH
63973: LD_INT 0
63975: PUSH
63976: LD_INT 1
63978: NEG
63979: PUSH
63980: EMPTY
63981: LIST
63982: LIST
63983: PUSH
63984: LD_INT 1
63986: PUSH
63987: LD_INT 0
63989: PUSH
63990: EMPTY
63991: LIST
63992: LIST
63993: PUSH
63994: LD_INT 1
63996: PUSH
63997: LD_INT 1
63999: PUSH
64000: EMPTY
64001: LIST
64002: LIST
64003: PUSH
64004: LD_INT 0
64006: PUSH
64007: LD_INT 1
64009: PUSH
64010: EMPTY
64011: LIST
64012: LIST
64013: PUSH
64014: LD_INT 1
64016: NEG
64017: PUSH
64018: LD_INT 0
64020: PUSH
64021: EMPTY
64022: LIST
64023: LIST
64024: PUSH
64025: LD_INT 1
64027: NEG
64028: PUSH
64029: LD_INT 1
64031: NEG
64032: PUSH
64033: EMPTY
64034: LIST
64035: LIST
64036: PUSH
64037: LD_INT 1
64039: PUSH
64040: LD_INT 1
64042: NEG
64043: PUSH
64044: EMPTY
64045: LIST
64046: LIST
64047: PUSH
64048: LD_INT 2
64050: PUSH
64051: LD_INT 0
64053: PUSH
64054: EMPTY
64055: LIST
64056: LIST
64057: PUSH
64058: LD_INT 2
64060: PUSH
64061: LD_INT 1
64063: PUSH
64064: EMPTY
64065: LIST
64066: LIST
64067: PUSH
64068: LD_INT 1
64070: NEG
64071: PUSH
64072: LD_INT 1
64074: PUSH
64075: EMPTY
64076: LIST
64077: LIST
64078: PUSH
64079: LD_INT 2
64081: NEG
64082: PUSH
64083: LD_INT 0
64085: PUSH
64086: EMPTY
64087: LIST
64088: LIST
64089: PUSH
64090: LD_INT 2
64092: NEG
64093: PUSH
64094: LD_INT 1
64096: NEG
64097: PUSH
64098: EMPTY
64099: LIST
64100: LIST
64101: PUSH
64102: LD_INT 2
64104: NEG
64105: PUSH
64106: LD_INT 1
64108: PUSH
64109: EMPTY
64110: LIST
64111: LIST
64112: PUSH
64113: LD_INT 3
64115: NEG
64116: PUSH
64117: LD_INT 0
64119: PUSH
64120: EMPTY
64121: LIST
64122: LIST
64123: PUSH
64124: LD_INT 3
64126: NEG
64127: PUSH
64128: LD_INT 1
64130: NEG
64131: PUSH
64132: EMPTY
64133: LIST
64134: LIST
64135: PUSH
64136: EMPTY
64137: LIST
64138: LIST
64139: LIST
64140: LIST
64141: LIST
64142: LIST
64143: LIST
64144: LIST
64145: LIST
64146: LIST
64147: LIST
64148: LIST
64149: LIST
64150: LIST
64151: LIST
64152: LIST
64153: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64154: LD_ADDR_VAR 0 13
64158: PUSH
64159: LD_INT 0
64161: PUSH
64162: LD_INT 0
64164: PUSH
64165: EMPTY
64166: LIST
64167: LIST
64168: PUSH
64169: LD_INT 0
64171: PUSH
64172: LD_INT 1
64174: NEG
64175: PUSH
64176: EMPTY
64177: LIST
64178: LIST
64179: PUSH
64180: LD_INT 1
64182: PUSH
64183: LD_INT 0
64185: PUSH
64186: EMPTY
64187: LIST
64188: LIST
64189: PUSH
64190: LD_INT 1
64192: PUSH
64193: LD_INT 1
64195: PUSH
64196: EMPTY
64197: LIST
64198: LIST
64199: PUSH
64200: LD_INT 0
64202: PUSH
64203: LD_INT 1
64205: PUSH
64206: EMPTY
64207: LIST
64208: LIST
64209: PUSH
64210: LD_INT 1
64212: NEG
64213: PUSH
64214: LD_INT 0
64216: PUSH
64217: EMPTY
64218: LIST
64219: LIST
64220: PUSH
64221: LD_INT 1
64223: NEG
64224: PUSH
64225: LD_INT 1
64227: NEG
64228: PUSH
64229: EMPTY
64230: LIST
64231: LIST
64232: PUSH
64233: LD_INT 1
64235: NEG
64236: PUSH
64237: LD_INT 2
64239: NEG
64240: PUSH
64241: EMPTY
64242: LIST
64243: LIST
64244: PUSH
64245: LD_INT 2
64247: PUSH
64248: LD_INT 1
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: PUSH
64255: LD_INT 2
64257: PUSH
64258: LD_INT 2
64260: PUSH
64261: EMPTY
64262: LIST
64263: LIST
64264: PUSH
64265: LD_INT 1
64267: PUSH
64268: LD_INT 2
64270: PUSH
64271: EMPTY
64272: LIST
64273: LIST
64274: PUSH
64275: LD_INT 2
64277: NEG
64278: PUSH
64279: LD_INT 1
64281: NEG
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: PUSH
64287: LD_INT 2
64289: NEG
64290: PUSH
64291: LD_INT 2
64293: NEG
64294: PUSH
64295: EMPTY
64296: LIST
64297: LIST
64298: PUSH
64299: LD_INT 2
64301: NEG
64302: PUSH
64303: LD_INT 3
64305: NEG
64306: PUSH
64307: EMPTY
64308: LIST
64309: LIST
64310: PUSH
64311: LD_INT 3
64313: NEG
64314: PUSH
64315: LD_INT 2
64317: NEG
64318: PUSH
64319: EMPTY
64320: LIST
64321: LIST
64322: PUSH
64323: LD_INT 3
64325: NEG
64326: PUSH
64327: LD_INT 3
64329: NEG
64330: PUSH
64331: EMPTY
64332: LIST
64333: LIST
64334: PUSH
64335: EMPTY
64336: LIST
64337: LIST
64338: LIST
64339: LIST
64340: LIST
64341: LIST
64342: LIST
64343: LIST
64344: LIST
64345: LIST
64346: LIST
64347: LIST
64348: LIST
64349: LIST
64350: LIST
64351: LIST
64352: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64353: LD_ADDR_VAR 0 14
64357: PUSH
64358: LD_INT 0
64360: PUSH
64361: LD_INT 0
64363: PUSH
64364: EMPTY
64365: LIST
64366: LIST
64367: PUSH
64368: LD_INT 0
64370: PUSH
64371: LD_INT 1
64373: NEG
64374: PUSH
64375: EMPTY
64376: LIST
64377: LIST
64378: PUSH
64379: LD_INT 1
64381: PUSH
64382: LD_INT 0
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PUSH
64389: LD_INT 1
64391: PUSH
64392: LD_INT 1
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: PUSH
64399: LD_INT 0
64401: PUSH
64402: LD_INT 1
64404: PUSH
64405: EMPTY
64406: LIST
64407: LIST
64408: PUSH
64409: LD_INT 1
64411: NEG
64412: PUSH
64413: LD_INT 0
64415: PUSH
64416: EMPTY
64417: LIST
64418: LIST
64419: PUSH
64420: LD_INT 1
64422: NEG
64423: PUSH
64424: LD_INT 1
64426: NEG
64427: PUSH
64428: EMPTY
64429: LIST
64430: LIST
64431: PUSH
64432: LD_INT 1
64434: NEG
64435: PUSH
64436: LD_INT 2
64438: NEG
64439: PUSH
64440: EMPTY
64441: LIST
64442: LIST
64443: PUSH
64444: LD_INT 0
64446: PUSH
64447: LD_INT 2
64449: NEG
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: PUSH
64455: LD_INT 1
64457: PUSH
64458: LD_INT 1
64460: NEG
64461: PUSH
64462: EMPTY
64463: LIST
64464: LIST
64465: PUSH
64466: LD_INT 1
64468: PUSH
64469: LD_INT 2
64471: PUSH
64472: EMPTY
64473: LIST
64474: LIST
64475: PUSH
64476: LD_INT 0
64478: PUSH
64479: LD_INT 2
64481: PUSH
64482: EMPTY
64483: LIST
64484: LIST
64485: PUSH
64486: LD_INT 1
64488: NEG
64489: PUSH
64490: LD_INT 1
64492: PUSH
64493: EMPTY
64494: LIST
64495: LIST
64496: PUSH
64497: LD_INT 1
64499: NEG
64500: PUSH
64501: LD_INT 3
64503: NEG
64504: PUSH
64505: EMPTY
64506: LIST
64507: LIST
64508: PUSH
64509: LD_INT 0
64511: PUSH
64512: LD_INT 3
64514: NEG
64515: PUSH
64516: EMPTY
64517: LIST
64518: LIST
64519: PUSH
64520: LD_INT 1
64522: PUSH
64523: LD_INT 2
64525: NEG
64526: PUSH
64527: EMPTY
64528: LIST
64529: LIST
64530: PUSH
64531: EMPTY
64532: LIST
64533: LIST
64534: LIST
64535: LIST
64536: LIST
64537: LIST
64538: LIST
64539: LIST
64540: LIST
64541: LIST
64542: LIST
64543: LIST
64544: LIST
64545: LIST
64546: LIST
64547: LIST
64548: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64549: LD_ADDR_VAR 0 15
64553: PUSH
64554: LD_INT 0
64556: PUSH
64557: LD_INT 0
64559: PUSH
64560: EMPTY
64561: LIST
64562: LIST
64563: PUSH
64564: LD_INT 0
64566: PUSH
64567: LD_INT 1
64569: NEG
64570: PUSH
64571: EMPTY
64572: LIST
64573: LIST
64574: PUSH
64575: LD_INT 1
64577: PUSH
64578: LD_INT 0
64580: PUSH
64581: EMPTY
64582: LIST
64583: LIST
64584: PUSH
64585: LD_INT 1
64587: PUSH
64588: LD_INT 1
64590: PUSH
64591: EMPTY
64592: LIST
64593: LIST
64594: PUSH
64595: LD_INT 0
64597: PUSH
64598: LD_INT 1
64600: PUSH
64601: EMPTY
64602: LIST
64603: LIST
64604: PUSH
64605: LD_INT 1
64607: NEG
64608: PUSH
64609: LD_INT 0
64611: PUSH
64612: EMPTY
64613: LIST
64614: LIST
64615: PUSH
64616: LD_INT 1
64618: NEG
64619: PUSH
64620: LD_INT 1
64622: NEG
64623: PUSH
64624: EMPTY
64625: LIST
64626: LIST
64627: PUSH
64628: LD_INT 1
64630: PUSH
64631: LD_INT 1
64633: NEG
64634: PUSH
64635: EMPTY
64636: LIST
64637: LIST
64638: PUSH
64639: LD_INT 2
64641: PUSH
64642: LD_INT 0
64644: PUSH
64645: EMPTY
64646: LIST
64647: LIST
64648: PUSH
64649: LD_INT 2
64651: PUSH
64652: LD_INT 1
64654: PUSH
64655: EMPTY
64656: LIST
64657: LIST
64658: PUSH
64659: LD_INT 1
64661: NEG
64662: PUSH
64663: LD_INT 1
64665: PUSH
64666: EMPTY
64667: LIST
64668: LIST
64669: PUSH
64670: LD_INT 2
64672: NEG
64673: PUSH
64674: LD_INT 0
64676: PUSH
64677: EMPTY
64678: LIST
64679: LIST
64680: PUSH
64681: LD_INT 2
64683: NEG
64684: PUSH
64685: LD_INT 1
64687: NEG
64688: PUSH
64689: EMPTY
64690: LIST
64691: LIST
64692: PUSH
64693: LD_INT 2
64695: PUSH
64696: LD_INT 1
64698: NEG
64699: PUSH
64700: EMPTY
64701: LIST
64702: LIST
64703: PUSH
64704: LD_INT 3
64706: PUSH
64707: LD_INT 0
64709: PUSH
64710: EMPTY
64711: LIST
64712: LIST
64713: PUSH
64714: LD_INT 3
64716: PUSH
64717: LD_INT 1
64719: PUSH
64720: EMPTY
64721: LIST
64722: LIST
64723: PUSH
64724: EMPTY
64725: LIST
64726: LIST
64727: LIST
64728: LIST
64729: LIST
64730: LIST
64731: LIST
64732: LIST
64733: LIST
64734: LIST
64735: LIST
64736: LIST
64737: LIST
64738: LIST
64739: LIST
64740: LIST
64741: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64742: LD_ADDR_VAR 0 16
64746: PUSH
64747: LD_INT 0
64749: PUSH
64750: LD_INT 0
64752: PUSH
64753: EMPTY
64754: LIST
64755: LIST
64756: PUSH
64757: LD_INT 0
64759: PUSH
64760: LD_INT 1
64762: NEG
64763: PUSH
64764: EMPTY
64765: LIST
64766: LIST
64767: PUSH
64768: LD_INT 1
64770: PUSH
64771: LD_INT 0
64773: PUSH
64774: EMPTY
64775: LIST
64776: LIST
64777: PUSH
64778: LD_INT 1
64780: PUSH
64781: LD_INT 1
64783: PUSH
64784: EMPTY
64785: LIST
64786: LIST
64787: PUSH
64788: LD_INT 0
64790: PUSH
64791: LD_INT 1
64793: PUSH
64794: EMPTY
64795: LIST
64796: LIST
64797: PUSH
64798: LD_INT 1
64800: NEG
64801: PUSH
64802: LD_INT 0
64804: PUSH
64805: EMPTY
64806: LIST
64807: LIST
64808: PUSH
64809: LD_INT 1
64811: NEG
64812: PUSH
64813: LD_INT 1
64815: NEG
64816: PUSH
64817: EMPTY
64818: LIST
64819: LIST
64820: PUSH
64821: LD_INT 1
64823: NEG
64824: PUSH
64825: LD_INT 2
64827: NEG
64828: PUSH
64829: EMPTY
64830: LIST
64831: LIST
64832: PUSH
64833: LD_INT 2
64835: PUSH
64836: LD_INT 1
64838: PUSH
64839: EMPTY
64840: LIST
64841: LIST
64842: PUSH
64843: LD_INT 2
64845: PUSH
64846: LD_INT 2
64848: PUSH
64849: EMPTY
64850: LIST
64851: LIST
64852: PUSH
64853: LD_INT 1
64855: PUSH
64856: LD_INT 2
64858: PUSH
64859: EMPTY
64860: LIST
64861: LIST
64862: PUSH
64863: LD_INT 2
64865: NEG
64866: PUSH
64867: LD_INT 1
64869: NEG
64870: PUSH
64871: EMPTY
64872: LIST
64873: LIST
64874: PUSH
64875: LD_INT 2
64877: NEG
64878: PUSH
64879: LD_INT 2
64881: NEG
64882: PUSH
64883: EMPTY
64884: LIST
64885: LIST
64886: PUSH
64887: LD_INT 3
64889: PUSH
64890: LD_INT 2
64892: PUSH
64893: EMPTY
64894: LIST
64895: LIST
64896: PUSH
64897: LD_INT 3
64899: PUSH
64900: LD_INT 3
64902: PUSH
64903: EMPTY
64904: LIST
64905: LIST
64906: PUSH
64907: LD_INT 2
64909: PUSH
64910: LD_INT 3
64912: PUSH
64913: EMPTY
64914: LIST
64915: LIST
64916: PUSH
64917: EMPTY
64918: LIST
64919: LIST
64920: LIST
64921: LIST
64922: LIST
64923: LIST
64924: LIST
64925: LIST
64926: LIST
64927: LIST
64928: LIST
64929: LIST
64930: LIST
64931: LIST
64932: LIST
64933: LIST
64934: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64935: LD_ADDR_VAR 0 17
64939: PUSH
64940: LD_INT 0
64942: PUSH
64943: LD_INT 0
64945: PUSH
64946: EMPTY
64947: LIST
64948: LIST
64949: PUSH
64950: LD_INT 0
64952: PUSH
64953: LD_INT 1
64955: NEG
64956: PUSH
64957: EMPTY
64958: LIST
64959: LIST
64960: PUSH
64961: LD_INT 1
64963: PUSH
64964: LD_INT 0
64966: PUSH
64967: EMPTY
64968: LIST
64969: LIST
64970: PUSH
64971: LD_INT 1
64973: PUSH
64974: LD_INT 1
64976: PUSH
64977: EMPTY
64978: LIST
64979: LIST
64980: PUSH
64981: LD_INT 0
64983: PUSH
64984: LD_INT 1
64986: PUSH
64987: EMPTY
64988: LIST
64989: LIST
64990: PUSH
64991: LD_INT 1
64993: NEG
64994: PUSH
64995: LD_INT 0
64997: PUSH
64998: EMPTY
64999: LIST
65000: LIST
65001: PUSH
65002: LD_INT 1
65004: NEG
65005: PUSH
65006: LD_INT 1
65008: NEG
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: PUSH
65014: LD_INT 1
65016: NEG
65017: PUSH
65018: LD_INT 2
65020: NEG
65021: PUSH
65022: EMPTY
65023: LIST
65024: LIST
65025: PUSH
65026: LD_INT 0
65028: PUSH
65029: LD_INT 2
65031: NEG
65032: PUSH
65033: EMPTY
65034: LIST
65035: LIST
65036: PUSH
65037: LD_INT 1
65039: PUSH
65040: LD_INT 1
65042: NEG
65043: PUSH
65044: EMPTY
65045: LIST
65046: LIST
65047: PUSH
65048: LD_INT 2
65050: PUSH
65051: LD_INT 0
65053: PUSH
65054: EMPTY
65055: LIST
65056: LIST
65057: PUSH
65058: LD_INT 2
65060: PUSH
65061: LD_INT 1
65063: PUSH
65064: EMPTY
65065: LIST
65066: LIST
65067: PUSH
65068: LD_INT 2
65070: PUSH
65071: LD_INT 2
65073: PUSH
65074: EMPTY
65075: LIST
65076: LIST
65077: PUSH
65078: LD_INT 1
65080: PUSH
65081: LD_INT 2
65083: PUSH
65084: EMPTY
65085: LIST
65086: LIST
65087: PUSH
65088: LD_INT 0
65090: PUSH
65091: LD_INT 2
65093: PUSH
65094: EMPTY
65095: LIST
65096: LIST
65097: PUSH
65098: LD_INT 1
65100: NEG
65101: PUSH
65102: LD_INT 1
65104: PUSH
65105: EMPTY
65106: LIST
65107: LIST
65108: PUSH
65109: LD_INT 2
65111: NEG
65112: PUSH
65113: LD_INT 0
65115: PUSH
65116: EMPTY
65117: LIST
65118: LIST
65119: PUSH
65120: LD_INT 2
65122: NEG
65123: PUSH
65124: LD_INT 1
65126: NEG
65127: PUSH
65128: EMPTY
65129: LIST
65130: LIST
65131: PUSH
65132: LD_INT 2
65134: NEG
65135: PUSH
65136: LD_INT 2
65138: NEG
65139: PUSH
65140: EMPTY
65141: LIST
65142: LIST
65143: PUSH
65144: EMPTY
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: LIST
65154: LIST
65155: LIST
65156: LIST
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65165: LD_ADDR_VAR 0 18
65169: PUSH
65170: LD_INT 0
65172: PUSH
65173: LD_INT 0
65175: PUSH
65176: EMPTY
65177: LIST
65178: LIST
65179: PUSH
65180: LD_INT 0
65182: PUSH
65183: LD_INT 1
65185: NEG
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: PUSH
65191: LD_INT 1
65193: PUSH
65194: LD_INT 0
65196: PUSH
65197: EMPTY
65198: LIST
65199: LIST
65200: PUSH
65201: LD_INT 1
65203: PUSH
65204: LD_INT 1
65206: PUSH
65207: EMPTY
65208: LIST
65209: LIST
65210: PUSH
65211: LD_INT 0
65213: PUSH
65214: LD_INT 1
65216: PUSH
65217: EMPTY
65218: LIST
65219: LIST
65220: PUSH
65221: LD_INT 1
65223: NEG
65224: PUSH
65225: LD_INT 0
65227: PUSH
65228: EMPTY
65229: LIST
65230: LIST
65231: PUSH
65232: LD_INT 1
65234: NEG
65235: PUSH
65236: LD_INT 1
65238: NEG
65239: PUSH
65240: EMPTY
65241: LIST
65242: LIST
65243: PUSH
65244: LD_INT 1
65246: NEG
65247: PUSH
65248: LD_INT 2
65250: NEG
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: PUSH
65256: LD_INT 0
65258: PUSH
65259: LD_INT 2
65261: NEG
65262: PUSH
65263: EMPTY
65264: LIST
65265: LIST
65266: PUSH
65267: LD_INT 1
65269: PUSH
65270: LD_INT 1
65272: NEG
65273: PUSH
65274: EMPTY
65275: LIST
65276: LIST
65277: PUSH
65278: LD_INT 2
65280: PUSH
65281: LD_INT 0
65283: PUSH
65284: EMPTY
65285: LIST
65286: LIST
65287: PUSH
65288: LD_INT 2
65290: PUSH
65291: LD_INT 1
65293: PUSH
65294: EMPTY
65295: LIST
65296: LIST
65297: PUSH
65298: LD_INT 2
65300: PUSH
65301: LD_INT 2
65303: PUSH
65304: EMPTY
65305: LIST
65306: LIST
65307: PUSH
65308: LD_INT 1
65310: PUSH
65311: LD_INT 2
65313: PUSH
65314: EMPTY
65315: LIST
65316: LIST
65317: PUSH
65318: LD_INT 0
65320: PUSH
65321: LD_INT 2
65323: PUSH
65324: EMPTY
65325: LIST
65326: LIST
65327: PUSH
65328: LD_INT 1
65330: NEG
65331: PUSH
65332: LD_INT 1
65334: PUSH
65335: EMPTY
65336: LIST
65337: LIST
65338: PUSH
65339: LD_INT 2
65341: NEG
65342: PUSH
65343: LD_INT 0
65345: PUSH
65346: EMPTY
65347: LIST
65348: LIST
65349: PUSH
65350: LD_INT 2
65352: NEG
65353: PUSH
65354: LD_INT 1
65356: NEG
65357: PUSH
65358: EMPTY
65359: LIST
65360: LIST
65361: PUSH
65362: LD_INT 2
65364: NEG
65365: PUSH
65366: LD_INT 2
65368: NEG
65369: PUSH
65370: EMPTY
65371: LIST
65372: LIST
65373: PUSH
65374: EMPTY
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65395: LD_ADDR_VAR 0 19
65399: PUSH
65400: LD_INT 0
65402: PUSH
65403: LD_INT 0
65405: PUSH
65406: EMPTY
65407: LIST
65408: LIST
65409: PUSH
65410: LD_INT 0
65412: PUSH
65413: LD_INT 1
65415: NEG
65416: PUSH
65417: EMPTY
65418: LIST
65419: LIST
65420: PUSH
65421: LD_INT 1
65423: PUSH
65424: LD_INT 0
65426: PUSH
65427: EMPTY
65428: LIST
65429: LIST
65430: PUSH
65431: LD_INT 1
65433: PUSH
65434: LD_INT 1
65436: PUSH
65437: EMPTY
65438: LIST
65439: LIST
65440: PUSH
65441: LD_INT 0
65443: PUSH
65444: LD_INT 1
65446: PUSH
65447: EMPTY
65448: LIST
65449: LIST
65450: PUSH
65451: LD_INT 1
65453: NEG
65454: PUSH
65455: LD_INT 0
65457: PUSH
65458: EMPTY
65459: LIST
65460: LIST
65461: PUSH
65462: LD_INT 1
65464: NEG
65465: PUSH
65466: LD_INT 1
65468: NEG
65469: PUSH
65470: EMPTY
65471: LIST
65472: LIST
65473: PUSH
65474: LD_INT 1
65476: NEG
65477: PUSH
65478: LD_INT 2
65480: NEG
65481: PUSH
65482: EMPTY
65483: LIST
65484: LIST
65485: PUSH
65486: LD_INT 0
65488: PUSH
65489: LD_INT 2
65491: NEG
65492: PUSH
65493: EMPTY
65494: LIST
65495: LIST
65496: PUSH
65497: LD_INT 1
65499: PUSH
65500: LD_INT 1
65502: NEG
65503: PUSH
65504: EMPTY
65505: LIST
65506: LIST
65507: PUSH
65508: LD_INT 2
65510: PUSH
65511: LD_INT 0
65513: PUSH
65514: EMPTY
65515: LIST
65516: LIST
65517: PUSH
65518: LD_INT 2
65520: PUSH
65521: LD_INT 1
65523: PUSH
65524: EMPTY
65525: LIST
65526: LIST
65527: PUSH
65528: LD_INT 2
65530: PUSH
65531: LD_INT 2
65533: PUSH
65534: EMPTY
65535: LIST
65536: LIST
65537: PUSH
65538: LD_INT 1
65540: PUSH
65541: LD_INT 2
65543: PUSH
65544: EMPTY
65545: LIST
65546: LIST
65547: PUSH
65548: LD_INT 0
65550: PUSH
65551: LD_INT 2
65553: PUSH
65554: EMPTY
65555: LIST
65556: LIST
65557: PUSH
65558: LD_INT 1
65560: NEG
65561: PUSH
65562: LD_INT 1
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: PUSH
65569: LD_INT 2
65571: NEG
65572: PUSH
65573: LD_INT 0
65575: PUSH
65576: EMPTY
65577: LIST
65578: LIST
65579: PUSH
65580: LD_INT 2
65582: NEG
65583: PUSH
65584: LD_INT 1
65586: NEG
65587: PUSH
65588: EMPTY
65589: LIST
65590: LIST
65591: PUSH
65592: LD_INT 2
65594: NEG
65595: PUSH
65596: LD_INT 2
65598: NEG
65599: PUSH
65600: EMPTY
65601: LIST
65602: LIST
65603: PUSH
65604: EMPTY
65605: LIST
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: LIST
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: LIST
65624: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65625: LD_ADDR_VAR 0 20
65629: PUSH
65630: LD_INT 0
65632: PUSH
65633: LD_INT 0
65635: PUSH
65636: EMPTY
65637: LIST
65638: LIST
65639: PUSH
65640: LD_INT 0
65642: PUSH
65643: LD_INT 1
65645: NEG
65646: PUSH
65647: EMPTY
65648: LIST
65649: LIST
65650: PUSH
65651: LD_INT 1
65653: PUSH
65654: LD_INT 0
65656: PUSH
65657: EMPTY
65658: LIST
65659: LIST
65660: PUSH
65661: LD_INT 1
65663: PUSH
65664: LD_INT 1
65666: PUSH
65667: EMPTY
65668: LIST
65669: LIST
65670: PUSH
65671: LD_INT 0
65673: PUSH
65674: LD_INT 1
65676: PUSH
65677: EMPTY
65678: LIST
65679: LIST
65680: PUSH
65681: LD_INT 1
65683: NEG
65684: PUSH
65685: LD_INT 0
65687: PUSH
65688: EMPTY
65689: LIST
65690: LIST
65691: PUSH
65692: LD_INT 1
65694: NEG
65695: PUSH
65696: LD_INT 1
65698: NEG
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: PUSH
65704: LD_INT 1
65706: NEG
65707: PUSH
65708: LD_INT 2
65710: NEG
65711: PUSH
65712: EMPTY
65713: LIST
65714: LIST
65715: PUSH
65716: LD_INT 0
65718: PUSH
65719: LD_INT 2
65721: NEG
65722: PUSH
65723: EMPTY
65724: LIST
65725: LIST
65726: PUSH
65727: LD_INT 1
65729: PUSH
65730: LD_INT 1
65732: NEG
65733: PUSH
65734: EMPTY
65735: LIST
65736: LIST
65737: PUSH
65738: LD_INT 2
65740: PUSH
65741: LD_INT 0
65743: PUSH
65744: EMPTY
65745: LIST
65746: LIST
65747: PUSH
65748: LD_INT 2
65750: PUSH
65751: LD_INT 1
65753: PUSH
65754: EMPTY
65755: LIST
65756: LIST
65757: PUSH
65758: LD_INT 2
65760: PUSH
65761: LD_INT 2
65763: PUSH
65764: EMPTY
65765: LIST
65766: LIST
65767: PUSH
65768: LD_INT 1
65770: PUSH
65771: LD_INT 2
65773: PUSH
65774: EMPTY
65775: LIST
65776: LIST
65777: PUSH
65778: LD_INT 0
65780: PUSH
65781: LD_INT 2
65783: PUSH
65784: EMPTY
65785: LIST
65786: LIST
65787: PUSH
65788: LD_INT 1
65790: NEG
65791: PUSH
65792: LD_INT 1
65794: PUSH
65795: EMPTY
65796: LIST
65797: LIST
65798: PUSH
65799: LD_INT 2
65801: NEG
65802: PUSH
65803: LD_INT 0
65805: PUSH
65806: EMPTY
65807: LIST
65808: LIST
65809: PUSH
65810: LD_INT 2
65812: NEG
65813: PUSH
65814: LD_INT 1
65816: NEG
65817: PUSH
65818: EMPTY
65819: LIST
65820: LIST
65821: PUSH
65822: LD_INT 2
65824: NEG
65825: PUSH
65826: LD_INT 2
65828: NEG
65829: PUSH
65830: EMPTY
65831: LIST
65832: LIST
65833: PUSH
65834: EMPTY
65835: LIST
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: LIST
65841: LIST
65842: LIST
65843: LIST
65844: LIST
65845: LIST
65846: LIST
65847: LIST
65848: LIST
65849: LIST
65850: LIST
65851: LIST
65852: LIST
65853: LIST
65854: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65855: LD_ADDR_VAR 0 21
65859: PUSH
65860: LD_INT 0
65862: PUSH
65863: LD_INT 0
65865: PUSH
65866: EMPTY
65867: LIST
65868: LIST
65869: PUSH
65870: LD_INT 0
65872: PUSH
65873: LD_INT 1
65875: NEG
65876: PUSH
65877: EMPTY
65878: LIST
65879: LIST
65880: PUSH
65881: LD_INT 1
65883: PUSH
65884: LD_INT 0
65886: PUSH
65887: EMPTY
65888: LIST
65889: LIST
65890: PUSH
65891: LD_INT 1
65893: PUSH
65894: LD_INT 1
65896: PUSH
65897: EMPTY
65898: LIST
65899: LIST
65900: PUSH
65901: LD_INT 0
65903: PUSH
65904: LD_INT 1
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PUSH
65911: LD_INT 1
65913: NEG
65914: PUSH
65915: LD_INT 0
65917: PUSH
65918: EMPTY
65919: LIST
65920: LIST
65921: PUSH
65922: LD_INT 1
65924: NEG
65925: PUSH
65926: LD_INT 1
65928: NEG
65929: PUSH
65930: EMPTY
65931: LIST
65932: LIST
65933: PUSH
65934: LD_INT 1
65936: NEG
65937: PUSH
65938: LD_INT 2
65940: NEG
65941: PUSH
65942: EMPTY
65943: LIST
65944: LIST
65945: PUSH
65946: LD_INT 0
65948: PUSH
65949: LD_INT 2
65951: NEG
65952: PUSH
65953: EMPTY
65954: LIST
65955: LIST
65956: PUSH
65957: LD_INT 1
65959: PUSH
65960: LD_INT 1
65962: NEG
65963: PUSH
65964: EMPTY
65965: LIST
65966: LIST
65967: PUSH
65968: LD_INT 2
65970: PUSH
65971: LD_INT 0
65973: PUSH
65974: EMPTY
65975: LIST
65976: LIST
65977: PUSH
65978: LD_INT 2
65980: PUSH
65981: LD_INT 1
65983: PUSH
65984: EMPTY
65985: LIST
65986: LIST
65987: PUSH
65988: LD_INT 2
65990: PUSH
65991: LD_INT 2
65993: PUSH
65994: EMPTY
65995: LIST
65996: LIST
65997: PUSH
65998: LD_INT 1
66000: PUSH
66001: LD_INT 2
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PUSH
66008: LD_INT 0
66010: PUSH
66011: LD_INT 2
66013: PUSH
66014: EMPTY
66015: LIST
66016: LIST
66017: PUSH
66018: LD_INT 1
66020: NEG
66021: PUSH
66022: LD_INT 1
66024: PUSH
66025: EMPTY
66026: LIST
66027: LIST
66028: PUSH
66029: LD_INT 2
66031: NEG
66032: PUSH
66033: LD_INT 0
66035: PUSH
66036: EMPTY
66037: LIST
66038: LIST
66039: PUSH
66040: LD_INT 2
66042: NEG
66043: PUSH
66044: LD_INT 1
66046: NEG
66047: PUSH
66048: EMPTY
66049: LIST
66050: LIST
66051: PUSH
66052: LD_INT 2
66054: NEG
66055: PUSH
66056: LD_INT 2
66058: NEG
66059: PUSH
66060: EMPTY
66061: LIST
66062: LIST
66063: PUSH
66064: EMPTY
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: LIST
66071: LIST
66072: LIST
66073: LIST
66074: LIST
66075: LIST
66076: LIST
66077: LIST
66078: LIST
66079: LIST
66080: LIST
66081: LIST
66082: LIST
66083: LIST
66084: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66085: LD_ADDR_VAR 0 22
66089: PUSH
66090: LD_INT 0
66092: PUSH
66093: LD_INT 0
66095: PUSH
66096: EMPTY
66097: LIST
66098: LIST
66099: PUSH
66100: LD_INT 0
66102: PUSH
66103: LD_INT 1
66105: NEG
66106: PUSH
66107: EMPTY
66108: LIST
66109: LIST
66110: PUSH
66111: LD_INT 1
66113: PUSH
66114: LD_INT 0
66116: PUSH
66117: EMPTY
66118: LIST
66119: LIST
66120: PUSH
66121: LD_INT 1
66123: PUSH
66124: LD_INT 1
66126: PUSH
66127: EMPTY
66128: LIST
66129: LIST
66130: PUSH
66131: LD_INT 0
66133: PUSH
66134: LD_INT 1
66136: PUSH
66137: EMPTY
66138: LIST
66139: LIST
66140: PUSH
66141: LD_INT 1
66143: NEG
66144: PUSH
66145: LD_INT 0
66147: PUSH
66148: EMPTY
66149: LIST
66150: LIST
66151: PUSH
66152: LD_INT 1
66154: NEG
66155: PUSH
66156: LD_INT 1
66158: NEG
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: PUSH
66164: LD_INT 1
66166: NEG
66167: PUSH
66168: LD_INT 2
66170: NEG
66171: PUSH
66172: EMPTY
66173: LIST
66174: LIST
66175: PUSH
66176: LD_INT 0
66178: PUSH
66179: LD_INT 2
66181: NEG
66182: PUSH
66183: EMPTY
66184: LIST
66185: LIST
66186: PUSH
66187: LD_INT 1
66189: PUSH
66190: LD_INT 1
66192: NEG
66193: PUSH
66194: EMPTY
66195: LIST
66196: LIST
66197: PUSH
66198: LD_INT 2
66200: PUSH
66201: LD_INT 0
66203: PUSH
66204: EMPTY
66205: LIST
66206: LIST
66207: PUSH
66208: LD_INT 2
66210: PUSH
66211: LD_INT 1
66213: PUSH
66214: EMPTY
66215: LIST
66216: LIST
66217: PUSH
66218: LD_INT 2
66220: PUSH
66221: LD_INT 2
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: PUSH
66228: LD_INT 1
66230: PUSH
66231: LD_INT 2
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: PUSH
66238: LD_INT 0
66240: PUSH
66241: LD_INT 2
66243: PUSH
66244: EMPTY
66245: LIST
66246: LIST
66247: PUSH
66248: LD_INT 1
66250: NEG
66251: PUSH
66252: LD_INT 1
66254: PUSH
66255: EMPTY
66256: LIST
66257: LIST
66258: PUSH
66259: LD_INT 2
66261: NEG
66262: PUSH
66263: LD_INT 0
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 2
66272: NEG
66273: PUSH
66274: LD_INT 1
66276: NEG
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: PUSH
66282: LD_INT 2
66284: NEG
66285: PUSH
66286: LD_INT 2
66288: NEG
66289: PUSH
66290: EMPTY
66291: LIST
66292: LIST
66293: PUSH
66294: EMPTY
66295: LIST
66296: LIST
66297: LIST
66298: LIST
66299: LIST
66300: LIST
66301: LIST
66302: LIST
66303: LIST
66304: LIST
66305: LIST
66306: LIST
66307: LIST
66308: LIST
66309: LIST
66310: LIST
66311: LIST
66312: LIST
66313: LIST
66314: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66315: LD_ADDR_VAR 0 23
66319: PUSH
66320: LD_INT 0
66322: PUSH
66323: LD_INT 0
66325: PUSH
66326: EMPTY
66327: LIST
66328: LIST
66329: PUSH
66330: LD_INT 0
66332: PUSH
66333: LD_INT 1
66335: NEG
66336: PUSH
66337: EMPTY
66338: LIST
66339: LIST
66340: PUSH
66341: LD_INT 1
66343: PUSH
66344: LD_INT 0
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: PUSH
66351: LD_INT 1
66353: PUSH
66354: LD_INT 1
66356: PUSH
66357: EMPTY
66358: LIST
66359: LIST
66360: PUSH
66361: LD_INT 0
66363: PUSH
66364: LD_INT 1
66366: PUSH
66367: EMPTY
66368: LIST
66369: LIST
66370: PUSH
66371: LD_INT 1
66373: NEG
66374: PUSH
66375: LD_INT 0
66377: PUSH
66378: EMPTY
66379: LIST
66380: LIST
66381: PUSH
66382: LD_INT 1
66384: NEG
66385: PUSH
66386: LD_INT 1
66388: NEG
66389: PUSH
66390: EMPTY
66391: LIST
66392: LIST
66393: PUSH
66394: LD_INT 1
66396: NEG
66397: PUSH
66398: LD_INT 2
66400: NEG
66401: PUSH
66402: EMPTY
66403: LIST
66404: LIST
66405: PUSH
66406: LD_INT 0
66408: PUSH
66409: LD_INT 2
66411: NEG
66412: PUSH
66413: EMPTY
66414: LIST
66415: LIST
66416: PUSH
66417: LD_INT 1
66419: PUSH
66420: LD_INT 1
66422: NEG
66423: PUSH
66424: EMPTY
66425: LIST
66426: LIST
66427: PUSH
66428: LD_INT 2
66430: PUSH
66431: LD_INT 0
66433: PUSH
66434: EMPTY
66435: LIST
66436: LIST
66437: PUSH
66438: LD_INT 2
66440: PUSH
66441: LD_INT 1
66443: PUSH
66444: EMPTY
66445: LIST
66446: LIST
66447: PUSH
66448: LD_INT 2
66450: PUSH
66451: LD_INT 2
66453: PUSH
66454: EMPTY
66455: LIST
66456: LIST
66457: PUSH
66458: LD_INT 1
66460: PUSH
66461: LD_INT 2
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: PUSH
66468: LD_INT 0
66470: PUSH
66471: LD_INT 2
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 1
66480: NEG
66481: PUSH
66482: LD_INT 1
66484: PUSH
66485: EMPTY
66486: LIST
66487: LIST
66488: PUSH
66489: LD_INT 2
66491: NEG
66492: PUSH
66493: LD_INT 0
66495: PUSH
66496: EMPTY
66497: LIST
66498: LIST
66499: PUSH
66500: LD_INT 2
66502: NEG
66503: PUSH
66504: LD_INT 1
66506: NEG
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: PUSH
66512: LD_INT 2
66514: NEG
66515: PUSH
66516: LD_INT 2
66518: NEG
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: PUSH
66524: LD_INT 2
66526: NEG
66527: PUSH
66528: LD_INT 3
66530: NEG
66531: PUSH
66532: EMPTY
66533: LIST
66534: LIST
66535: PUSH
66536: LD_INT 1
66538: NEG
66539: PUSH
66540: LD_INT 3
66542: NEG
66543: PUSH
66544: EMPTY
66545: LIST
66546: LIST
66547: PUSH
66548: LD_INT 1
66550: PUSH
66551: LD_INT 2
66553: NEG
66554: PUSH
66555: EMPTY
66556: LIST
66557: LIST
66558: PUSH
66559: LD_INT 2
66561: PUSH
66562: LD_INT 1
66564: NEG
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: EMPTY
66571: LIST
66572: LIST
66573: LIST
66574: LIST
66575: LIST
66576: LIST
66577: LIST
66578: LIST
66579: LIST
66580: LIST
66581: LIST
66582: LIST
66583: LIST
66584: LIST
66585: LIST
66586: LIST
66587: LIST
66588: LIST
66589: LIST
66590: LIST
66591: LIST
66592: LIST
66593: LIST
66594: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
66595: LD_ADDR_VAR 0 24
66599: PUSH
66600: LD_INT 0
66602: PUSH
66603: LD_INT 0
66605: PUSH
66606: EMPTY
66607: LIST
66608: LIST
66609: PUSH
66610: LD_INT 0
66612: PUSH
66613: LD_INT 1
66615: NEG
66616: PUSH
66617: EMPTY
66618: LIST
66619: LIST
66620: PUSH
66621: LD_INT 1
66623: PUSH
66624: LD_INT 0
66626: PUSH
66627: EMPTY
66628: LIST
66629: LIST
66630: PUSH
66631: LD_INT 1
66633: PUSH
66634: LD_INT 1
66636: PUSH
66637: EMPTY
66638: LIST
66639: LIST
66640: PUSH
66641: LD_INT 0
66643: PUSH
66644: LD_INT 1
66646: PUSH
66647: EMPTY
66648: LIST
66649: LIST
66650: PUSH
66651: LD_INT 1
66653: NEG
66654: PUSH
66655: LD_INT 0
66657: PUSH
66658: EMPTY
66659: LIST
66660: LIST
66661: PUSH
66662: LD_INT 1
66664: NEG
66665: PUSH
66666: LD_INT 1
66668: NEG
66669: PUSH
66670: EMPTY
66671: LIST
66672: LIST
66673: PUSH
66674: LD_INT 1
66676: NEG
66677: PUSH
66678: LD_INT 2
66680: NEG
66681: PUSH
66682: EMPTY
66683: LIST
66684: LIST
66685: PUSH
66686: LD_INT 0
66688: PUSH
66689: LD_INT 2
66691: NEG
66692: PUSH
66693: EMPTY
66694: LIST
66695: LIST
66696: PUSH
66697: LD_INT 1
66699: PUSH
66700: LD_INT 1
66702: NEG
66703: PUSH
66704: EMPTY
66705: LIST
66706: LIST
66707: PUSH
66708: LD_INT 2
66710: PUSH
66711: LD_INT 0
66713: PUSH
66714: EMPTY
66715: LIST
66716: LIST
66717: PUSH
66718: LD_INT 2
66720: PUSH
66721: LD_INT 1
66723: PUSH
66724: EMPTY
66725: LIST
66726: LIST
66727: PUSH
66728: LD_INT 2
66730: PUSH
66731: LD_INT 2
66733: PUSH
66734: EMPTY
66735: LIST
66736: LIST
66737: PUSH
66738: LD_INT 1
66740: PUSH
66741: LD_INT 2
66743: PUSH
66744: EMPTY
66745: LIST
66746: LIST
66747: PUSH
66748: LD_INT 0
66750: PUSH
66751: LD_INT 2
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PUSH
66758: LD_INT 1
66760: NEG
66761: PUSH
66762: LD_INT 1
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: PUSH
66769: LD_INT 2
66771: NEG
66772: PUSH
66773: LD_INT 0
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: PUSH
66780: LD_INT 2
66782: NEG
66783: PUSH
66784: LD_INT 1
66786: NEG
66787: PUSH
66788: EMPTY
66789: LIST
66790: LIST
66791: PUSH
66792: LD_INT 2
66794: NEG
66795: PUSH
66796: LD_INT 2
66798: NEG
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: PUSH
66804: LD_INT 1
66806: PUSH
66807: LD_INT 2
66809: NEG
66810: PUSH
66811: EMPTY
66812: LIST
66813: LIST
66814: PUSH
66815: LD_INT 2
66817: PUSH
66818: LD_INT 1
66820: NEG
66821: PUSH
66822: EMPTY
66823: LIST
66824: LIST
66825: PUSH
66826: LD_INT 3
66828: PUSH
66829: LD_INT 1
66831: PUSH
66832: EMPTY
66833: LIST
66834: LIST
66835: PUSH
66836: LD_INT 3
66838: PUSH
66839: LD_INT 2
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: PUSH
66846: EMPTY
66847: LIST
66848: LIST
66849: LIST
66850: LIST
66851: LIST
66852: LIST
66853: LIST
66854: LIST
66855: LIST
66856: LIST
66857: LIST
66858: LIST
66859: LIST
66860: LIST
66861: LIST
66862: LIST
66863: LIST
66864: LIST
66865: LIST
66866: LIST
66867: LIST
66868: LIST
66869: LIST
66870: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66871: LD_ADDR_VAR 0 25
66875: PUSH
66876: LD_INT 0
66878: PUSH
66879: LD_INT 0
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: PUSH
66886: LD_INT 0
66888: PUSH
66889: LD_INT 1
66891: NEG
66892: PUSH
66893: EMPTY
66894: LIST
66895: LIST
66896: PUSH
66897: LD_INT 1
66899: PUSH
66900: LD_INT 0
66902: PUSH
66903: EMPTY
66904: LIST
66905: LIST
66906: PUSH
66907: LD_INT 1
66909: PUSH
66910: LD_INT 1
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: PUSH
66917: LD_INT 0
66919: PUSH
66920: LD_INT 1
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PUSH
66927: LD_INT 1
66929: NEG
66930: PUSH
66931: LD_INT 0
66933: PUSH
66934: EMPTY
66935: LIST
66936: LIST
66937: PUSH
66938: LD_INT 1
66940: NEG
66941: PUSH
66942: LD_INT 1
66944: NEG
66945: PUSH
66946: EMPTY
66947: LIST
66948: LIST
66949: PUSH
66950: LD_INT 1
66952: NEG
66953: PUSH
66954: LD_INT 2
66956: NEG
66957: PUSH
66958: EMPTY
66959: LIST
66960: LIST
66961: PUSH
66962: LD_INT 0
66964: PUSH
66965: LD_INT 2
66967: NEG
66968: PUSH
66969: EMPTY
66970: LIST
66971: LIST
66972: PUSH
66973: LD_INT 1
66975: PUSH
66976: LD_INT 1
66978: NEG
66979: PUSH
66980: EMPTY
66981: LIST
66982: LIST
66983: PUSH
66984: LD_INT 2
66986: PUSH
66987: LD_INT 0
66989: PUSH
66990: EMPTY
66991: LIST
66992: LIST
66993: PUSH
66994: LD_INT 2
66996: PUSH
66997: LD_INT 1
66999: PUSH
67000: EMPTY
67001: LIST
67002: LIST
67003: PUSH
67004: LD_INT 2
67006: PUSH
67007: LD_INT 2
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: LD_INT 1
67016: PUSH
67017: LD_INT 2
67019: PUSH
67020: EMPTY
67021: LIST
67022: LIST
67023: PUSH
67024: LD_INT 0
67026: PUSH
67027: LD_INT 2
67029: PUSH
67030: EMPTY
67031: LIST
67032: LIST
67033: PUSH
67034: LD_INT 1
67036: NEG
67037: PUSH
67038: LD_INT 1
67040: PUSH
67041: EMPTY
67042: LIST
67043: LIST
67044: PUSH
67045: LD_INT 2
67047: NEG
67048: PUSH
67049: LD_INT 0
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: PUSH
67056: LD_INT 2
67058: NEG
67059: PUSH
67060: LD_INT 1
67062: NEG
67063: PUSH
67064: EMPTY
67065: LIST
67066: LIST
67067: PUSH
67068: LD_INT 2
67070: NEG
67071: PUSH
67072: LD_INT 2
67074: NEG
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: PUSH
67080: LD_INT 3
67082: PUSH
67083: LD_INT 1
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PUSH
67090: LD_INT 3
67092: PUSH
67093: LD_INT 2
67095: PUSH
67096: EMPTY
67097: LIST
67098: LIST
67099: PUSH
67100: LD_INT 2
67102: PUSH
67103: LD_INT 3
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 1
67112: PUSH
67113: LD_INT 3
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: EMPTY
67121: LIST
67122: LIST
67123: LIST
67124: LIST
67125: LIST
67126: LIST
67127: LIST
67128: LIST
67129: LIST
67130: LIST
67131: LIST
67132: LIST
67133: LIST
67134: LIST
67135: LIST
67136: LIST
67137: LIST
67138: LIST
67139: LIST
67140: LIST
67141: LIST
67142: LIST
67143: LIST
67144: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67145: LD_ADDR_VAR 0 26
67149: PUSH
67150: LD_INT 0
67152: PUSH
67153: LD_INT 0
67155: PUSH
67156: EMPTY
67157: LIST
67158: LIST
67159: PUSH
67160: LD_INT 0
67162: PUSH
67163: LD_INT 1
67165: NEG
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: PUSH
67171: LD_INT 1
67173: PUSH
67174: LD_INT 0
67176: PUSH
67177: EMPTY
67178: LIST
67179: LIST
67180: PUSH
67181: LD_INT 1
67183: PUSH
67184: LD_INT 1
67186: PUSH
67187: EMPTY
67188: LIST
67189: LIST
67190: PUSH
67191: LD_INT 0
67193: PUSH
67194: LD_INT 1
67196: PUSH
67197: EMPTY
67198: LIST
67199: LIST
67200: PUSH
67201: LD_INT 1
67203: NEG
67204: PUSH
67205: LD_INT 0
67207: PUSH
67208: EMPTY
67209: LIST
67210: LIST
67211: PUSH
67212: LD_INT 1
67214: NEG
67215: PUSH
67216: LD_INT 1
67218: NEG
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PUSH
67224: LD_INT 1
67226: NEG
67227: PUSH
67228: LD_INT 2
67230: NEG
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PUSH
67236: LD_INT 0
67238: PUSH
67239: LD_INT 2
67241: NEG
67242: PUSH
67243: EMPTY
67244: LIST
67245: LIST
67246: PUSH
67247: LD_INT 1
67249: PUSH
67250: LD_INT 1
67252: NEG
67253: PUSH
67254: EMPTY
67255: LIST
67256: LIST
67257: PUSH
67258: LD_INT 2
67260: PUSH
67261: LD_INT 0
67263: PUSH
67264: EMPTY
67265: LIST
67266: LIST
67267: PUSH
67268: LD_INT 2
67270: PUSH
67271: LD_INT 1
67273: PUSH
67274: EMPTY
67275: LIST
67276: LIST
67277: PUSH
67278: LD_INT 2
67280: PUSH
67281: LD_INT 2
67283: PUSH
67284: EMPTY
67285: LIST
67286: LIST
67287: PUSH
67288: LD_INT 1
67290: PUSH
67291: LD_INT 2
67293: PUSH
67294: EMPTY
67295: LIST
67296: LIST
67297: PUSH
67298: LD_INT 0
67300: PUSH
67301: LD_INT 2
67303: PUSH
67304: EMPTY
67305: LIST
67306: LIST
67307: PUSH
67308: LD_INT 1
67310: NEG
67311: PUSH
67312: LD_INT 1
67314: PUSH
67315: EMPTY
67316: LIST
67317: LIST
67318: PUSH
67319: LD_INT 2
67321: NEG
67322: PUSH
67323: LD_INT 0
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: PUSH
67330: LD_INT 2
67332: NEG
67333: PUSH
67334: LD_INT 1
67336: NEG
67337: PUSH
67338: EMPTY
67339: LIST
67340: LIST
67341: PUSH
67342: LD_INT 2
67344: NEG
67345: PUSH
67346: LD_INT 2
67348: NEG
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: PUSH
67354: LD_INT 2
67356: PUSH
67357: LD_INT 3
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: PUSH
67364: LD_INT 1
67366: PUSH
67367: LD_INT 3
67369: PUSH
67370: EMPTY
67371: LIST
67372: LIST
67373: PUSH
67374: LD_INT 1
67376: NEG
67377: PUSH
67378: LD_INT 2
67380: PUSH
67381: EMPTY
67382: LIST
67383: LIST
67384: PUSH
67385: LD_INT 2
67387: NEG
67388: PUSH
67389: LD_INT 1
67391: PUSH
67392: EMPTY
67393: LIST
67394: LIST
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: LIST
67400: LIST
67401: LIST
67402: LIST
67403: LIST
67404: LIST
67405: LIST
67406: LIST
67407: LIST
67408: LIST
67409: LIST
67410: LIST
67411: LIST
67412: LIST
67413: LIST
67414: LIST
67415: LIST
67416: LIST
67417: LIST
67418: LIST
67419: LIST
67420: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67421: LD_ADDR_VAR 0 27
67425: PUSH
67426: LD_INT 0
67428: PUSH
67429: LD_INT 0
67431: PUSH
67432: EMPTY
67433: LIST
67434: LIST
67435: PUSH
67436: LD_INT 0
67438: PUSH
67439: LD_INT 1
67441: NEG
67442: PUSH
67443: EMPTY
67444: LIST
67445: LIST
67446: PUSH
67447: LD_INT 1
67449: PUSH
67450: LD_INT 0
67452: PUSH
67453: EMPTY
67454: LIST
67455: LIST
67456: PUSH
67457: LD_INT 1
67459: PUSH
67460: LD_INT 1
67462: PUSH
67463: EMPTY
67464: LIST
67465: LIST
67466: PUSH
67467: LD_INT 0
67469: PUSH
67470: LD_INT 1
67472: PUSH
67473: EMPTY
67474: LIST
67475: LIST
67476: PUSH
67477: LD_INT 1
67479: NEG
67480: PUSH
67481: LD_INT 0
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: PUSH
67488: LD_INT 1
67490: NEG
67491: PUSH
67492: LD_INT 1
67494: NEG
67495: PUSH
67496: EMPTY
67497: LIST
67498: LIST
67499: PUSH
67500: LD_INT 1
67502: NEG
67503: PUSH
67504: LD_INT 2
67506: NEG
67507: PUSH
67508: EMPTY
67509: LIST
67510: LIST
67511: PUSH
67512: LD_INT 0
67514: PUSH
67515: LD_INT 2
67517: NEG
67518: PUSH
67519: EMPTY
67520: LIST
67521: LIST
67522: PUSH
67523: LD_INT 1
67525: PUSH
67526: LD_INT 1
67528: NEG
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 2
67536: PUSH
67537: LD_INT 0
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 2
67546: PUSH
67547: LD_INT 1
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 2
67556: PUSH
67557: LD_INT 2
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 1
67566: PUSH
67567: LD_INT 2
67569: PUSH
67570: EMPTY
67571: LIST
67572: LIST
67573: PUSH
67574: LD_INT 0
67576: PUSH
67577: LD_INT 2
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: LD_INT 1
67586: NEG
67587: PUSH
67588: LD_INT 1
67590: PUSH
67591: EMPTY
67592: LIST
67593: LIST
67594: PUSH
67595: LD_INT 2
67597: NEG
67598: PUSH
67599: LD_INT 0
67601: PUSH
67602: EMPTY
67603: LIST
67604: LIST
67605: PUSH
67606: LD_INT 2
67608: NEG
67609: PUSH
67610: LD_INT 1
67612: NEG
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 2
67620: NEG
67621: PUSH
67622: LD_INT 2
67624: NEG
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: LD_INT 1
67632: NEG
67633: PUSH
67634: LD_INT 2
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 2
67643: NEG
67644: PUSH
67645: LD_INT 1
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: LD_INT 3
67654: NEG
67655: PUSH
67656: LD_INT 1
67658: NEG
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: PUSH
67664: LD_INT 3
67666: NEG
67667: PUSH
67668: LD_INT 2
67670: NEG
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PUSH
67676: EMPTY
67677: LIST
67678: LIST
67679: LIST
67680: LIST
67681: LIST
67682: LIST
67683: LIST
67684: LIST
67685: LIST
67686: LIST
67687: LIST
67688: LIST
67689: LIST
67690: LIST
67691: LIST
67692: LIST
67693: LIST
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: LIST
67700: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67701: LD_ADDR_VAR 0 28
67705: PUSH
67706: LD_INT 0
67708: PUSH
67709: LD_INT 0
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: PUSH
67716: LD_INT 0
67718: PUSH
67719: LD_INT 1
67721: NEG
67722: PUSH
67723: EMPTY
67724: LIST
67725: LIST
67726: PUSH
67727: LD_INT 1
67729: PUSH
67730: LD_INT 0
67732: PUSH
67733: EMPTY
67734: LIST
67735: LIST
67736: PUSH
67737: LD_INT 1
67739: PUSH
67740: LD_INT 1
67742: PUSH
67743: EMPTY
67744: LIST
67745: LIST
67746: PUSH
67747: LD_INT 0
67749: PUSH
67750: LD_INT 1
67752: PUSH
67753: EMPTY
67754: LIST
67755: LIST
67756: PUSH
67757: LD_INT 1
67759: NEG
67760: PUSH
67761: LD_INT 0
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: PUSH
67768: LD_INT 1
67770: NEG
67771: PUSH
67772: LD_INT 1
67774: NEG
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 1
67782: NEG
67783: PUSH
67784: LD_INT 2
67786: NEG
67787: PUSH
67788: EMPTY
67789: LIST
67790: LIST
67791: PUSH
67792: LD_INT 0
67794: PUSH
67795: LD_INT 2
67797: NEG
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 1
67805: PUSH
67806: LD_INT 1
67808: NEG
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 2
67816: PUSH
67817: LD_INT 0
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 2
67826: PUSH
67827: LD_INT 1
67829: PUSH
67830: EMPTY
67831: LIST
67832: LIST
67833: PUSH
67834: LD_INT 2
67836: PUSH
67837: LD_INT 2
67839: PUSH
67840: EMPTY
67841: LIST
67842: LIST
67843: PUSH
67844: LD_INT 1
67846: PUSH
67847: LD_INT 2
67849: PUSH
67850: EMPTY
67851: LIST
67852: LIST
67853: PUSH
67854: LD_INT 0
67856: PUSH
67857: LD_INT 2
67859: PUSH
67860: EMPTY
67861: LIST
67862: LIST
67863: PUSH
67864: LD_INT 1
67866: NEG
67867: PUSH
67868: LD_INT 1
67870: PUSH
67871: EMPTY
67872: LIST
67873: LIST
67874: PUSH
67875: LD_INT 2
67877: NEG
67878: PUSH
67879: LD_INT 0
67881: PUSH
67882: EMPTY
67883: LIST
67884: LIST
67885: PUSH
67886: LD_INT 2
67888: NEG
67889: PUSH
67890: LD_INT 1
67892: NEG
67893: PUSH
67894: EMPTY
67895: LIST
67896: LIST
67897: PUSH
67898: LD_INT 2
67900: NEG
67901: PUSH
67902: LD_INT 2
67904: NEG
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: PUSH
67910: LD_INT 2
67912: NEG
67913: PUSH
67914: LD_INT 3
67916: NEG
67917: PUSH
67918: EMPTY
67919: LIST
67920: LIST
67921: PUSH
67922: LD_INT 1
67924: NEG
67925: PUSH
67926: LD_INT 3
67928: NEG
67929: PUSH
67930: EMPTY
67931: LIST
67932: LIST
67933: PUSH
67934: LD_INT 3
67936: NEG
67937: PUSH
67938: LD_INT 1
67940: NEG
67941: PUSH
67942: EMPTY
67943: LIST
67944: LIST
67945: PUSH
67946: LD_INT 3
67948: NEG
67949: PUSH
67950: LD_INT 2
67952: NEG
67953: PUSH
67954: EMPTY
67955: LIST
67956: LIST
67957: PUSH
67958: EMPTY
67959: LIST
67960: LIST
67961: LIST
67962: LIST
67963: LIST
67964: LIST
67965: LIST
67966: LIST
67967: LIST
67968: LIST
67969: LIST
67970: LIST
67971: LIST
67972: LIST
67973: LIST
67974: LIST
67975: LIST
67976: LIST
67977: LIST
67978: LIST
67979: LIST
67980: LIST
67981: LIST
67982: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67983: LD_ADDR_VAR 0 29
67987: PUSH
67988: LD_INT 0
67990: PUSH
67991: LD_INT 0
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: PUSH
67998: LD_INT 0
68000: PUSH
68001: LD_INT 1
68003: NEG
68004: PUSH
68005: EMPTY
68006: LIST
68007: LIST
68008: PUSH
68009: LD_INT 1
68011: PUSH
68012: LD_INT 0
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PUSH
68019: LD_INT 1
68021: PUSH
68022: LD_INT 1
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PUSH
68029: LD_INT 0
68031: PUSH
68032: LD_INT 1
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PUSH
68039: LD_INT 1
68041: NEG
68042: PUSH
68043: LD_INT 0
68045: PUSH
68046: EMPTY
68047: LIST
68048: LIST
68049: PUSH
68050: LD_INT 1
68052: NEG
68053: PUSH
68054: LD_INT 1
68056: NEG
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: PUSH
68062: LD_INT 1
68064: NEG
68065: PUSH
68066: LD_INT 2
68068: NEG
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PUSH
68074: LD_INT 0
68076: PUSH
68077: LD_INT 2
68079: NEG
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 1
68087: PUSH
68088: LD_INT 1
68090: NEG
68091: PUSH
68092: EMPTY
68093: LIST
68094: LIST
68095: PUSH
68096: LD_INT 2
68098: PUSH
68099: LD_INT 0
68101: PUSH
68102: EMPTY
68103: LIST
68104: LIST
68105: PUSH
68106: LD_INT 2
68108: PUSH
68109: LD_INT 1
68111: PUSH
68112: EMPTY
68113: LIST
68114: LIST
68115: PUSH
68116: LD_INT 1
68118: PUSH
68119: LD_INT 2
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: PUSH
68126: LD_INT 0
68128: PUSH
68129: LD_INT 2
68131: PUSH
68132: EMPTY
68133: LIST
68134: LIST
68135: PUSH
68136: LD_INT 1
68138: NEG
68139: PUSH
68140: LD_INT 1
68142: PUSH
68143: EMPTY
68144: LIST
68145: LIST
68146: PUSH
68147: LD_INT 2
68149: NEG
68150: PUSH
68151: LD_INT 1
68153: NEG
68154: PUSH
68155: EMPTY
68156: LIST
68157: LIST
68158: PUSH
68159: LD_INT 2
68161: NEG
68162: PUSH
68163: LD_INT 2
68165: NEG
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: PUSH
68171: LD_INT 2
68173: NEG
68174: PUSH
68175: LD_INT 3
68177: NEG
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: LD_INT 2
68185: PUSH
68186: LD_INT 1
68188: NEG
68189: PUSH
68190: EMPTY
68191: LIST
68192: LIST
68193: PUSH
68194: LD_INT 3
68196: PUSH
68197: LD_INT 1
68199: PUSH
68200: EMPTY
68201: LIST
68202: LIST
68203: PUSH
68204: LD_INT 1
68206: PUSH
68207: LD_INT 3
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: PUSH
68214: LD_INT 1
68216: NEG
68217: PUSH
68218: LD_INT 2
68220: PUSH
68221: EMPTY
68222: LIST
68223: LIST
68224: PUSH
68225: LD_INT 3
68227: NEG
68228: PUSH
68229: LD_INT 2
68231: NEG
68232: PUSH
68233: EMPTY
68234: LIST
68235: LIST
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: LIST
68241: LIST
68242: LIST
68243: LIST
68244: LIST
68245: LIST
68246: LIST
68247: LIST
68248: LIST
68249: LIST
68250: LIST
68251: LIST
68252: LIST
68253: LIST
68254: LIST
68255: LIST
68256: LIST
68257: LIST
68258: LIST
68259: LIST
68260: LIST
68261: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68262: LD_ADDR_VAR 0 30
68266: PUSH
68267: LD_INT 0
68269: PUSH
68270: LD_INT 0
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: PUSH
68277: LD_INT 0
68279: PUSH
68280: LD_INT 1
68282: NEG
68283: PUSH
68284: EMPTY
68285: LIST
68286: LIST
68287: PUSH
68288: LD_INT 1
68290: PUSH
68291: LD_INT 0
68293: PUSH
68294: EMPTY
68295: LIST
68296: LIST
68297: PUSH
68298: LD_INT 1
68300: PUSH
68301: LD_INT 1
68303: PUSH
68304: EMPTY
68305: LIST
68306: LIST
68307: PUSH
68308: LD_INT 0
68310: PUSH
68311: LD_INT 1
68313: PUSH
68314: EMPTY
68315: LIST
68316: LIST
68317: PUSH
68318: LD_INT 1
68320: NEG
68321: PUSH
68322: LD_INT 0
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: PUSH
68329: LD_INT 1
68331: NEG
68332: PUSH
68333: LD_INT 1
68335: NEG
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: LD_INT 1
68343: NEG
68344: PUSH
68345: LD_INT 2
68347: NEG
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 0
68355: PUSH
68356: LD_INT 2
68358: NEG
68359: PUSH
68360: EMPTY
68361: LIST
68362: LIST
68363: PUSH
68364: LD_INT 1
68366: PUSH
68367: LD_INT 1
68369: NEG
68370: PUSH
68371: EMPTY
68372: LIST
68373: LIST
68374: PUSH
68375: LD_INT 2
68377: PUSH
68378: LD_INT 0
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: PUSH
68385: LD_INT 2
68387: PUSH
68388: LD_INT 1
68390: PUSH
68391: EMPTY
68392: LIST
68393: LIST
68394: PUSH
68395: LD_INT 2
68397: PUSH
68398: LD_INT 2
68400: PUSH
68401: EMPTY
68402: LIST
68403: LIST
68404: PUSH
68405: LD_INT 1
68407: PUSH
68408: LD_INT 2
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: PUSH
68415: LD_INT 1
68417: NEG
68418: PUSH
68419: LD_INT 1
68421: PUSH
68422: EMPTY
68423: LIST
68424: LIST
68425: PUSH
68426: LD_INT 2
68428: NEG
68429: PUSH
68430: LD_INT 0
68432: PUSH
68433: EMPTY
68434: LIST
68435: LIST
68436: PUSH
68437: LD_INT 2
68439: NEG
68440: PUSH
68441: LD_INT 1
68443: NEG
68444: PUSH
68445: EMPTY
68446: LIST
68447: LIST
68448: PUSH
68449: LD_INT 1
68451: NEG
68452: PUSH
68453: LD_INT 3
68455: NEG
68456: PUSH
68457: EMPTY
68458: LIST
68459: LIST
68460: PUSH
68461: LD_INT 1
68463: PUSH
68464: LD_INT 2
68466: NEG
68467: PUSH
68468: EMPTY
68469: LIST
68470: LIST
68471: PUSH
68472: LD_INT 3
68474: PUSH
68475: LD_INT 2
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 2
68484: PUSH
68485: LD_INT 3
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PUSH
68492: LD_INT 2
68494: NEG
68495: PUSH
68496: LD_INT 1
68498: PUSH
68499: EMPTY
68500: LIST
68501: LIST
68502: PUSH
68503: LD_INT 3
68505: NEG
68506: PUSH
68507: LD_INT 1
68509: NEG
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: LIST
68526: LIST
68527: LIST
68528: LIST
68529: LIST
68530: LIST
68531: LIST
68532: LIST
68533: LIST
68534: LIST
68535: LIST
68536: LIST
68537: LIST
68538: LIST
68539: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68540: LD_ADDR_VAR 0 31
68544: PUSH
68545: LD_INT 0
68547: PUSH
68548: LD_INT 0
68550: PUSH
68551: EMPTY
68552: LIST
68553: LIST
68554: PUSH
68555: LD_INT 0
68557: PUSH
68558: LD_INT 1
68560: NEG
68561: PUSH
68562: EMPTY
68563: LIST
68564: LIST
68565: PUSH
68566: LD_INT 1
68568: PUSH
68569: LD_INT 0
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: PUSH
68576: LD_INT 1
68578: PUSH
68579: LD_INT 1
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PUSH
68586: LD_INT 0
68588: PUSH
68589: LD_INT 1
68591: PUSH
68592: EMPTY
68593: LIST
68594: LIST
68595: PUSH
68596: LD_INT 1
68598: NEG
68599: PUSH
68600: LD_INT 0
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PUSH
68607: LD_INT 1
68609: NEG
68610: PUSH
68611: LD_INT 1
68613: NEG
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: LD_INT 1
68621: NEG
68622: PUSH
68623: LD_INT 2
68625: NEG
68626: PUSH
68627: EMPTY
68628: LIST
68629: LIST
68630: PUSH
68631: LD_INT 1
68633: PUSH
68634: LD_INT 1
68636: NEG
68637: PUSH
68638: EMPTY
68639: LIST
68640: LIST
68641: PUSH
68642: LD_INT 2
68644: PUSH
68645: LD_INT 0
68647: PUSH
68648: EMPTY
68649: LIST
68650: LIST
68651: PUSH
68652: LD_INT 2
68654: PUSH
68655: LD_INT 1
68657: PUSH
68658: EMPTY
68659: LIST
68660: LIST
68661: PUSH
68662: LD_INT 2
68664: PUSH
68665: LD_INT 2
68667: PUSH
68668: EMPTY
68669: LIST
68670: LIST
68671: PUSH
68672: LD_INT 1
68674: PUSH
68675: LD_INT 2
68677: PUSH
68678: EMPTY
68679: LIST
68680: LIST
68681: PUSH
68682: LD_INT 0
68684: PUSH
68685: LD_INT 2
68687: PUSH
68688: EMPTY
68689: LIST
68690: LIST
68691: PUSH
68692: LD_INT 1
68694: NEG
68695: PUSH
68696: LD_INT 1
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: PUSH
68703: LD_INT 2
68705: NEG
68706: PUSH
68707: LD_INT 1
68709: NEG
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: PUSH
68715: LD_INT 2
68717: NEG
68718: PUSH
68719: LD_INT 2
68721: NEG
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: PUSH
68727: LD_INT 2
68729: NEG
68730: PUSH
68731: LD_INT 3
68733: NEG
68734: PUSH
68735: EMPTY
68736: LIST
68737: LIST
68738: PUSH
68739: LD_INT 2
68741: PUSH
68742: LD_INT 1
68744: NEG
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 3
68752: PUSH
68753: LD_INT 1
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: PUSH
68760: LD_INT 1
68762: PUSH
68763: LD_INT 3
68765: PUSH
68766: EMPTY
68767: LIST
68768: LIST
68769: PUSH
68770: LD_INT 1
68772: NEG
68773: PUSH
68774: LD_INT 2
68776: PUSH
68777: EMPTY
68778: LIST
68779: LIST
68780: PUSH
68781: LD_INT 3
68783: NEG
68784: PUSH
68785: LD_INT 2
68787: NEG
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: LIST
68797: LIST
68798: LIST
68799: LIST
68800: LIST
68801: LIST
68802: LIST
68803: LIST
68804: LIST
68805: LIST
68806: LIST
68807: LIST
68808: LIST
68809: LIST
68810: LIST
68811: LIST
68812: LIST
68813: LIST
68814: LIST
68815: LIST
68816: LIST
68817: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68818: LD_ADDR_VAR 0 32
68822: PUSH
68823: LD_INT 0
68825: PUSH
68826: LD_INT 0
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PUSH
68833: LD_INT 0
68835: PUSH
68836: LD_INT 1
68838: NEG
68839: PUSH
68840: EMPTY
68841: LIST
68842: LIST
68843: PUSH
68844: LD_INT 1
68846: PUSH
68847: LD_INT 0
68849: PUSH
68850: EMPTY
68851: LIST
68852: LIST
68853: PUSH
68854: LD_INT 1
68856: PUSH
68857: LD_INT 1
68859: PUSH
68860: EMPTY
68861: LIST
68862: LIST
68863: PUSH
68864: LD_INT 0
68866: PUSH
68867: LD_INT 1
68869: PUSH
68870: EMPTY
68871: LIST
68872: LIST
68873: PUSH
68874: LD_INT 1
68876: NEG
68877: PUSH
68878: LD_INT 0
68880: PUSH
68881: EMPTY
68882: LIST
68883: LIST
68884: PUSH
68885: LD_INT 1
68887: NEG
68888: PUSH
68889: LD_INT 1
68891: NEG
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: PUSH
68897: LD_INT 1
68899: NEG
68900: PUSH
68901: LD_INT 2
68903: NEG
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: PUSH
68909: LD_INT 0
68911: PUSH
68912: LD_INT 2
68914: NEG
68915: PUSH
68916: EMPTY
68917: LIST
68918: LIST
68919: PUSH
68920: LD_INT 1
68922: PUSH
68923: LD_INT 1
68925: NEG
68926: PUSH
68927: EMPTY
68928: LIST
68929: LIST
68930: PUSH
68931: LD_INT 2
68933: PUSH
68934: LD_INT 1
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: LD_INT 2
68943: PUSH
68944: LD_INT 2
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 1
68953: PUSH
68954: LD_INT 2
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PUSH
68961: LD_INT 0
68963: PUSH
68964: LD_INT 2
68966: PUSH
68967: EMPTY
68968: LIST
68969: LIST
68970: PUSH
68971: LD_INT 1
68973: NEG
68974: PUSH
68975: LD_INT 1
68977: PUSH
68978: EMPTY
68979: LIST
68980: LIST
68981: PUSH
68982: LD_INT 2
68984: NEG
68985: PUSH
68986: LD_INT 0
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 2
68995: NEG
68996: PUSH
68997: LD_INT 1
68999: NEG
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: LD_INT 1
69007: NEG
69008: PUSH
69009: LD_INT 3
69011: NEG
69012: PUSH
69013: EMPTY
69014: LIST
69015: LIST
69016: PUSH
69017: LD_INT 1
69019: PUSH
69020: LD_INT 2
69022: NEG
69023: PUSH
69024: EMPTY
69025: LIST
69026: LIST
69027: PUSH
69028: LD_INT 3
69030: PUSH
69031: LD_INT 2
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 2
69040: PUSH
69041: LD_INT 3
69043: PUSH
69044: EMPTY
69045: LIST
69046: LIST
69047: PUSH
69048: LD_INT 2
69050: NEG
69051: PUSH
69052: LD_INT 1
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: LD_INT 3
69061: NEG
69062: PUSH
69063: LD_INT 1
69065: NEG
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PUSH
69071: EMPTY
69072: LIST
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: LIST
69086: LIST
69087: LIST
69088: LIST
69089: LIST
69090: LIST
69091: LIST
69092: LIST
69093: LIST
69094: LIST
69095: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69096: LD_ADDR_VAR 0 33
69100: PUSH
69101: LD_INT 0
69103: PUSH
69104: LD_INT 0
69106: PUSH
69107: EMPTY
69108: LIST
69109: LIST
69110: PUSH
69111: LD_INT 0
69113: PUSH
69114: LD_INT 1
69116: NEG
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PUSH
69122: LD_INT 1
69124: PUSH
69125: LD_INT 0
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: PUSH
69132: LD_INT 1
69134: PUSH
69135: LD_INT 1
69137: PUSH
69138: EMPTY
69139: LIST
69140: LIST
69141: PUSH
69142: LD_INT 0
69144: PUSH
69145: LD_INT 1
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: PUSH
69152: LD_INT 1
69154: NEG
69155: PUSH
69156: LD_INT 0
69158: PUSH
69159: EMPTY
69160: LIST
69161: LIST
69162: PUSH
69163: LD_INT 1
69165: NEG
69166: PUSH
69167: LD_INT 1
69169: NEG
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: PUSH
69175: LD_INT 1
69177: NEG
69178: PUSH
69179: LD_INT 2
69181: NEG
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PUSH
69187: LD_INT 1
69189: PUSH
69190: LD_INT 1
69192: NEG
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: LD_INT 2
69200: PUSH
69201: LD_INT 0
69203: PUSH
69204: EMPTY
69205: LIST
69206: LIST
69207: PUSH
69208: LD_INT 2
69210: PUSH
69211: LD_INT 1
69213: PUSH
69214: EMPTY
69215: LIST
69216: LIST
69217: PUSH
69218: LD_INT 1
69220: PUSH
69221: LD_INT 2
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: PUSH
69228: LD_INT 0
69230: PUSH
69231: LD_INT 2
69233: PUSH
69234: EMPTY
69235: LIST
69236: LIST
69237: PUSH
69238: LD_INT 1
69240: NEG
69241: PUSH
69242: LD_INT 1
69244: PUSH
69245: EMPTY
69246: LIST
69247: LIST
69248: PUSH
69249: LD_INT 2
69251: NEG
69252: PUSH
69253: LD_INT 0
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 2
69262: NEG
69263: PUSH
69264: LD_INT 1
69266: NEG
69267: PUSH
69268: EMPTY
69269: LIST
69270: LIST
69271: PUSH
69272: LD_INT 2
69274: NEG
69275: PUSH
69276: LD_INT 2
69278: NEG
69279: PUSH
69280: EMPTY
69281: LIST
69282: LIST
69283: PUSH
69284: LD_INT 2
69286: NEG
69287: PUSH
69288: LD_INT 3
69290: NEG
69291: PUSH
69292: EMPTY
69293: LIST
69294: LIST
69295: PUSH
69296: LD_INT 2
69298: PUSH
69299: LD_INT 1
69301: NEG
69302: PUSH
69303: EMPTY
69304: LIST
69305: LIST
69306: PUSH
69307: LD_INT 3
69309: PUSH
69310: LD_INT 1
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: PUSH
69317: LD_INT 1
69319: PUSH
69320: LD_INT 3
69322: PUSH
69323: EMPTY
69324: LIST
69325: LIST
69326: PUSH
69327: LD_INT 1
69329: NEG
69330: PUSH
69331: LD_INT 2
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: LD_INT 3
69340: NEG
69341: PUSH
69342: LD_INT 2
69344: NEG
69345: PUSH
69346: EMPTY
69347: LIST
69348: LIST
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: LIST
69366: LIST
69367: LIST
69368: LIST
69369: LIST
69370: LIST
69371: LIST
69372: LIST
69373: LIST
69374: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69375: LD_ADDR_VAR 0 34
69379: PUSH
69380: LD_INT 0
69382: PUSH
69383: LD_INT 0
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PUSH
69390: LD_INT 0
69392: PUSH
69393: LD_INT 1
69395: NEG
69396: PUSH
69397: EMPTY
69398: LIST
69399: LIST
69400: PUSH
69401: LD_INT 1
69403: PUSH
69404: LD_INT 0
69406: PUSH
69407: EMPTY
69408: LIST
69409: LIST
69410: PUSH
69411: LD_INT 1
69413: PUSH
69414: LD_INT 1
69416: PUSH
69417: EMPTY
69418: LIST
69419: LIST
69420: PUSH
69421: LD_INT 0
69423: PUSH
69424: LD_INT 1
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: PUSH
69431: LD_INT 1
69433: NEG
69434: PUSH
69435: LD_INT 0
69437: PUSH
69438: EMPTY
69439: LIST
69440: LIST
69441: PUSH
69442: LD_INT 1
69444: NEG
69445: PUSH
69446: LD_INT 1
69448: NEG
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: PUSH
69454: LD_INT 1
69456: NEG
69457: PUSH
69458: LD_INT 2
69460: NEG
69461: PUSH
69462: EMPTY
69463: LIST
69464: LIST
69465: PUSH
69466: LD_INT 0
69468: PUSH
69469: LD_INT 2
69471: NEG
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: PUSH
69477: LD_INT 1
69479: PUSH
69480: LD_INT 1
69482: NEG
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: LD_INT 2
69490: PUSH
69491: LD_INT 1
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: LD_INT 2
69500: PUSH
69501: LD_INT 2
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 1
69510: PUSH
69511: LD_INT 2
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: PUSH
69518: LD_INT 1
69520: NEG
69521: PUSH
69522: LD_INT 1
69524: PUSH
69525: EMPTY
69526: LIST
69527: LIST
69528: PUSH
69529: LD_INT 2
69531: NEG
69532: PUSH
69533: LD_INT 0
69535: PUSH
69536: EMPTY
69537: LIST
69538: LIST
69539: PUSH
69540: LD_INT 2
69542: NEG
69543: PUSH
69544: LD_INT 1
69546: NEG
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: LD_INT 2
69554: NEG
69555: PUSH
69556: LD_INT 2
69558: NEG
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PUSH
69564: LD_INT 1
69566: NEG
69567: PUSH
69568: LD_INT 3
69570: NEG
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: PUSH
69576: LD_INT 1
69578: PUSH
69579: LD_INT 2
69581: NEG
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: PUSH
69587: LD_INT 3
69589: PUSH
69590: LD_INT 2
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 2
69599: PUSH
69600: LD_INT 3
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: PUSH
69607: LD_INT 2
69609: NEG
69610: PUSH
69611: LD_INT 1
69613: PUSH
69614: EMPTY
69615: LIST
69616: LIST
69617: PUSH
69618: LD_INT 3
69620: NEG
69621: PUSH
69622: LD_INT 1
69624: NEG
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: LIST
69643: LIST
69644: LIST
69645: LIST
69646: LIST
69647: LIST
69648: LIST
69649: LIST
69650: LIST
69651: LIST
69652: LIST
69653: LIST
69654: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69655: LD_ADDR_VAR 0 35
69659: PUSH
69660: LD_INT 0
69662: PUSH
69663: LD_INT 0
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 0
69672: PUSH
69673: LD_INT 1
69675: NEG
69676: PUSH
69677: EMPTY
69678: LIST
69679: LIST
69680: PUSH
69681: LD_INT 1
69683: PUSH
69684: LD_INT 0
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: LD_INT 1
69693: PUSH
69694: LD_INT 1
69696: PUSH
69697: EMPTY
69698: LIST
69699: LIST
69700: PUSH
69701: LD_INT 0
69703: PUSH
69704: LD_INT 1
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 1
69713: NEG
69714: PUSH
69715: LD_INT 0
69717: PUSH
69718: EMPTY
69719: LIST
69720: LIST
69721: PUSH
69722: LD_INT 1
69724: NEG
69725: PUSH
69726: LD_INT 1
69728: NEG
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: PUSH
69734: LD_INT 2
69736: PUSH
69737: LD_INT 1
69739: PUSH
69740: EMPTY
69741: LIST
69742: LIST
69743: PUSH
69744: LD_INT 2
69746: NEG
69747: PUSH
69748: LD_INT 1
69750: NEG
69751: PUSH
69752: EMPTY
69753: LIST
69754: LIST
69755: PUSH
69756: EMPTY
69757: LIST
69758: LIST
69759: LIST
69760: LIST
69761: LIST
69762: LIST
69763: LIST
69764: LIST
69765: LIST
69766: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69767: LD_ADDR_VAR 0 36
69771: PUSH
69772: LD_INT 0
69774: PUSH
69775: LD_INT 0
69777: PUSH
69778: EMPTY
69779: LIST
69780: LIST
69781: PUSH
69782: LD_INT 0
69784: PUSH
69785: LD_INT 1
69787: NEG
69788: PUSH
69789: EMPTY
69790: LIST
69791: LIST
69792: PUSH
69793: LD_INT 1
69795: PUSH
69796: LD_INT 0
69798: PUSH
69799: EMPTY
69800: LIST
69801: LIST
69802: PUSH
69803: LD_INT 1
69805: PUSH
69806: LD_INT 1
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: PUSH
69813: LD_INT 0
69815: PUSH
69816: LD_INT 1
69818: PUSH
69819: EMPTY
69820: LIST
69821: LIST
69822: PUSH
69823: LD_INT 1
69825: NEG
69826: PUSH
69827: LD_INT 0
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PUSH
69834: LD_INT 1
69836: NEG
69837: PUSH
69838: LD_INT 1
69840: NEG
69841: PUSH
69842: EMPTY
69843: LIST
69844: LIST
69845: PUSH
69846: LD_INT 1
69848: NEG
69849: PUSH
69850: LD_INT 2
69852: NEG
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: PUSH
69858: LD_INT 1
69860: PUSH
69861: LD_INT 2
69863: PUSH
69864: EMPTY
69865: LIST
69866: LIST
69867: PUSH
69868: EMPTY
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: LIST
69877: LIST
69878: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69879: LD_ADDR_VAR 0 37
69883: PUSH
69884: LD_INT 0
69886: PUSH
69887: LD_INT 0
69889: PUSH
69890: EMPTY
69891: LIST
69892: LIST
69893: PUSH
69894: LD_INT 0
69896: PUSH
69897: LD_INT 1
69899: NEG
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: PUSH
69905: LD_INT 1
69907: PUSH
69908: LD_INT 0
69910: PUSH
69911: EMPTY
69912: LIST
69913: LIST
69914: PUSH
69915: LD_INT 1
69917: PUSH
69918: LD_INT 1
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: PUSH
69925: LD_INT 0
69927: PUSH
69928: LD_INT 1
69930: PUSH
69931: EMPTY
69932: LIST
69933: LIST
69934: PUSH
69935: LD_INT 1
69937: NEG
69938: PUSH
69939: LD_INT 0
69941: PUSH
69942: EMPTY
69943: LIST
69944: LIST
69945: PUSH
69946: LD_INT 1
69948: NEG
69949: PUSH
69950: LD_INT 1
69952: NEG
69953: PUSH
69954: EMPTY
69955: LIST
69956: LIST
69957: PUSH
69958: LD_INT 1
69960: PUSH
69961: LD_INT 1
69963: NEG
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: PUSH
69969: LD_INT 1
69971: NEG
69972: PUSH
69973: LD_INT 1
69975: PUSH
69976: EMPTY
69977: LIST
69978: LIST
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: LIST
69988: LIST
69989: LIST
69990: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69991: LD_ADDR_VAR 0 38
69995: PUSH
69996: LD_INT 0
69998: PUSH
69999: LD_INT 0
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: LD_INT 0
70008: PUSH
70009: LD_INT 1
70011: NEG
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: PUSH
70017: LD_INT 1
70019: PUSH
70020: LD_INT 0
70022: PUSH
70023: EMPTY
70024: LIST
70025: LIST
70026: PUSH
70027: LD_INT 1
70029: PUSH
70030: LD_INT 1
70032: PUSH
70033: EMPTY
70034: LIST
70035: LIST
70036: PUSH
70037: LD_INT 0
70039: PUSH
70040: LD_INT 1
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PUSH
70047: LD_INT 1
70049: NEG
70050: PUSH
70051: LD_INT 0
70053: PUSH
70054: EMPTY
70055: LIST
70056: LIST
70057: PUSH
70058: LD_INT 1
70060: NEG
70061: PUSH
70062: LD_INT 1
70064: NEG
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 2
70072: PUSH
70073: LD_INT 1
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: PUSH
70080: LD_INT 2
70082: NEG
70083: PUSH
70084: LD_INT 1
70086: NEG
70087: PUSH
70088: EMPTY
70089: LIST
70090: LIST
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: LIST
70096: LIST
70097: LIST
70098: LIST
70099: LIST
70100: LIST
70101: LIST
70102: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70103: LD_ADDR_VAR 0 39
70107: PUSH
70108: LD_INT 0
70110: PUSH
70111: LD_INT 0
70113: PUSH
70114: EMPTY
70115: LIST
70116: LIST
70117: PUSH
70118: LD_INT 0
70120: PUSH
70121: LD_INT 1
70123: NEG
70124: PUSH
70125: EMPTY
70126: LIST
70127: LIST
70128: PUSH
70129: LD_INT 1
70131: PUSH
70132: LD_INT 0
70134: PUSH
70135: EMPTY
70136: LIST
70137: LIST
70138: PUSH
70139: LD_INT 1
70141: PUSH
70142: LD_INT 1
70144: PUSH
70145: EMPTY
70146: LIST
70147: LIST
70148: PUSH
70149: LD_INT 0
70151: PUSH
70152: LD_INT 1
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PUSH
70159: LD_INT 1
70161: NEG
70162: PUSH
70163: LD_INT 0
70165: PUSH
70166: EMPTY
70167: LIST
70168: LIST
70169: PUSH
70170: LD_INT 1
70172: NEG
70173: PUSH
70174: LD_INT 1
70176: NEG
70177: PUSH
70178: EMPTY
70179: LIST
70180: LIST
70181: PUSH
70182: LD_INT 1
70184: NEG
70185: PUSH
70186: LD_INT 2
70188: NEG
70189: PUSH
70190: EMPTY
70191: LIST
70192: LIST
70193: PUSH
70194: LD_INT 1
70196: PUSH
70197: LD_INT 2
70199: PUSH
70200: EMPTY
70201: LIST
70202: LIST
70203: PUSH
70204: EMPTY
70205: LIST
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: LIST
70214: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70215: LD_ADDR_VAR 0 40
70219: PUSH
70220: LD_INT 0
70222: PUSH
70223: LD_INT 0
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PUSH
70230: LD_INT 0
70232: PUSH
70233: LD_INT 1
70235: NEG
70236: PUSH
70237: EMPTY
70238: LIST
70239: LIST
70240: PUSH
70241: LD_INT 1
70243: PUSH
70244: LD_INT 0
70246: PUSH
70247: EMPTY
70248: LIST
70249: LIST
70250: PUSH
70251: LD_INT 1
70253: PUSH
70254: LD_INT 1
70256: PUSH
70257: EMPTY
70258: LIST
70259: LIST
70260: PUSH
70261: LD_INT 0
70263: PUSH
70264: LD_INT 1
70266: PUSH
70267: EMPTY
70268: LIST
70269: LIST
70270: PUSH
70271: LD_INT 1
70273: NEG
70274: PUSH
70275: LD_INT 0
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: PUSH
70282: LD_INT 1
70284: NEG
70285: PUSH
70286: LD_INT 1
70288: NEG
70289: PUSH
70290: EMPTY
70291: LIST
70292: LIST
70293: PUSH
70294: LD_INT 1
70296: PUSH
70297: LD_INT 1
70299: NEG
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 1
70307: NEG
70308: PUSH
70309: LD_INT 1
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: EMPTY
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70327: LD_ADDR_VAR 0 41
70331: PUSH
70332: LD_INT 0
70334: PUSH
70335: LD_INT 0
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: PUSH
70342: LD_INT 0
70344: PUSH
70345: LD_INT 1
70347: NEG
70348: PUSH
70349: EMPTY
70350: LIST
70351: LIST
70352: PUSH
70353: LD_INT 1
70355: PUSH
70356: LD_INT 0
70358: PUSH
70359: EMPTY
70360: LIST
70361: LIST
70362: PUSH
70363: LD_INT 1
70365: PUSH
70366: LD_INT 1
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: PUSH
70373: LD_INT 0
70375: PUSH
70376: LD_INT 1
70378: PUSH
70379: EMPTY
70380: LIST
70381: LIST
70382: PUSH
70383: LD_INT 1
70385: NEG
70386: PUSH
70387: LD_INT 0
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: LD_INT 1
70396: NEG
70397: PUSH
70398: LD_INT 1
70400: NEG
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: LD_INT 1
70408: NEG
70409: PUSH
70410: LD_INT 2
70412: NEG
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: PUSH
70418: LD_INT 1
70420: PUSH
70421: LD_INT 1
70423: NEG
70424: PUSH
70425: EMPTY
70426: LIST
70427: LIST
70428: PUSH
70429: LD_INT 2
70431: PUSH
70432: LD_INT 0
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: PUSH
70439: LD_INT 2
70441: PUSH
70442: LD_INT 1
70444: PUSH
70445: EMPTY
70446: LIST
70447: LIST
70448: PUSH
70449: LD_INT 2
70451: PUSH
70452: LD_INT 2
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 1
70461: PUSH
70462: LD_INT 2
70464: PUSH
70465: EMPTY
70466: LIST
70467: LIST
70468: PUSH
70469: LD_INT 1
70471: NEG
70472: PUSH
70473: LD_INT 1
70475: PUSH
70476: EMPTY
70477: LIST
70478: LIST
70479: PUSH
70480: LD_INT 2
70482: NEG
70483: PUSH
70484: LD_INT 0
70486: PUSH
70487: EMPTY
70488: LIST
70489: LIST
70490: PUSH
70491: LD_INT 2
70493: NEG
70494: PUSH
70495: LD_INT 1
70497: NEG
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 2
70505: NEG
70506: PUSH
70507: LD_INT 2
70509: NEG
70510: PUSH
70511: EMPTY
70512: LIST
70513: LIST
70514: PUSH
70515: LD_INT 2
70517: NEG
70518: PUSH
70519: LD_INT 3
70521: NEG
70522: PUSH
70523: EMPTY
70524: LIST
70525: LIST
70526: PUSH
70527: LD_INT 2
70529: PUSH
70530: LD_INT 1
70532: NEG
70533: PUSH
70534: EMPTY
70535: LIST
70536: LIST
70537: PUSH
70538: LD_INT 3
70540: PUSH
70541: LD_INT 0
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: PUSH
70548: LD_INT 3
70550: PUSH
70551: LD_INT 1
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PUSH
70558: LD_INT 3
70560: PUSH
70561: LD_INT 2
70563: PUSH
70564: EMPTY
70565: LIST
70566: LIST
70567: PUSH
70568: LD_INT 3
70570: PUSH
70571: LD_INT 3
70573: PUSH
70574: EMPTY
70575: LIST
70576: LIST
70577: PUSH
70578: LD_INT 2
70580: PUSH
70581: LD_INT 3
70583: PUSH
70584: EMPTY
70585: LIST
70586: LIST
70587: PUSH
70588: LD_INT 2
70590: NEG
70591: PUSH
70592: LD_INT 1
70594: PUSH
70595: EMPTY
70596: LIST
70597: LIST
70598: PUSH
70599: LD_INT 3
70601: NEG
70602: PUSH
70603: LD_INT 0
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: LD_INT 3
70612: NEG
70613: PUSH
70614: LD_INT 1
70616: NEG
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: PUSH
70622: LD_INT 3
70624: NEG
70625: PUSH
70626: LD_INT 2
70628: NEG
70629: PUSH
70630: EMPTY
70631: LIST
70632: LIST
70633: PUSH
70634: LD_INT 3
70636: NEG
70637: PUSH
70638: LD_INT 3
70640: NEG
70641: PUSH
70642: EMPTY
70643: LIST
70644: LIST
70645: PUSH
70646: EMPTY
70647: LIST
70648: LIST
70649: LIST
70650: LIST
70651: LIST
70652: LIST
70653: LIST
70654: LIST
70655: LIST
70656: LIST
70657: LIST
70658: LIST
70659: LIST
70660: LIST
70661: LIST
70662: LIST
70663: LIST
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70677: LD_ADDR_VAR 0 42
70681: PUSH
70682: LD_INT 0
70684: PUSH
70685: LD_INT 0
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: PUSH
70692: LD_INT 0
70694: PUSH
70695: LD_INT 1
70697: NEG
70698: PUSH
70699: EMPTY
70700: LIST
70701: LIST
70702: PUSH
70703: LD_INT 1
70705: PUSH
70706: LD_INT 0
70708: PUSH
70709: EMPTY
70710: LIST
70711: LIST
70712: PUSH
70713: LD_INT 1
70715: PUSH
70716: LD_INT 1
70718: PUSH
70719: EMPTY
70720: LIST
70721: LIST
70722: PUSH
70723: LD_INT 0
70725: PUSH
70726: LD_INT 1
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: PUSH
70733: LD_INT 1
70735: NEG
70736: PUSH
70737: LD_INT 0
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 1
70746: NEG
70747: PUSH
70748: LD_INT 1
70750: NEG
70751: PUSH
70752: EMPTY
70753: LIST
70754: LIST
70755: PUSH
70756: LD_INT 1
70758: NEG
70759: PUSH
70760: LD_INT 2
70762: NEG
70763: PUSH
70764: EMPTY
70765: LIST
70766: LIST
70767: PUSH
70768: LD_INT 0
70770: PUSH
70771: LD_INT 2
70773: NEG
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: PUSH
70779: LD_INT 1
70781: PUSH
70782: LD_INT 1
70784: NEG
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: PUSH
70790: LD_INT 2
70792: PUSH
70793: LD_INT 1
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: PUSH
70800: LD_INT 2
70802: PUSH
70803: LD_INT 2
70805: PUSH
70806: EMPTY
70807: LIST
70808: LIST
70809: PUSH
70810: LD_INT 1
70812: PUSH
70813: LD_INT 2
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 0
70822: PUSH
70823: LD_INT 2
70825: PUSH
70826: EMPTY
70827: LIST
70828: LIST
70829: PUSH
70830: LD_INT 1
70832: NEG
70833: PUSH
70834: LD_INT 1
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: LD_INT 2
70843: NEG
70844: PUSH
70845: LD_INT 1
70847: NEG
70848: PUSH
70849: EMPTY
70850: LIST
70851: LIST
70852: PUSH
70853: LD_INT 2
70855: NEG
70856: PUSH
70857: LD_INT 2
70859: NEG
70860: PUSH
70861: EMPTY
70862: LIST
70863: LIST
70864: PUSH
70865: LD_INT 2
70867: NEG
70868: PUSH
70869: LD_INT 3
70871: NEG
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: PUSH
70877: LD_INT 1
70879: NEG
70880: PUSH
70881: LD_INT 3
70883: NEG
70884: PUSH
70885: EMPTY
70886: LIST
70887: LIST
70888: PUSH
70889: LD_INT 0
70891: PUSH
70892: LD_INT 3
70894: NEG
70895: PUSH
70896: EMPTY
70897: LIST
70898: LIST
70899: PUSH
70900: LD_INT 1
70902: PUSH
70903: LD_INT 2
70905: NEG
70906: PUSH
70907: EMPTY
70908: LIST
70909: LIST
70910: PUSH
70911: LD_INT 3
70913: PUSH
70914: LD_INT 2
70916: PUSH
70917: EMPTY
70918: LIST
70919: LIST
70920: PUSH
70921: LD_INT 3
70923: PUSH
70924: LD_INT 3
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: PUSH
70931: LD_INT 2
70933: PUSH
70934: LD_INT 3
70936: PUSH
70937: EMPTY
70938: LIST
70939: LIST
70940: PUSH
70941: LD_INT 1
70943: PUSH
70944: LD_INT 3
70946: PUSH
70947: EMPTY
70948: LIST
70949: LIST
70950: PUSH
70951: LD_INT 0
70953: PUSH
70954: LD_INT 3
70956: PUSH
70957: EMPTY
70958: LIST
70959: LIST
70960: PUSH
70961: LD_INT 1
70963: NEG
70964: PUSH
70965: LD_INT 2
70967: PUSH
70968: EMPTY
70969: LIST
70970: LIST
70971: PUSH
70972: LD_INT 3
70974: NEG
70975: PUSH
70976: LD_INT 2
70978: NEG
70979: PUSH
70980: EMPTY
70981: LIST
70982: LIST
70983: PUSH
70984: LD_INT 3
70986: NEG
70987: PUSH
70988: LD_INT 3
70990: NEG
70991: PUSH
70992: EMPTY
70993: LIST
70994: LIST
70995: PUSH
70996: EMPTY
70997: LIST
70998: LIST
70999: LIST
71000: LIST
71001: LIST
71002: LIST
71003: LIST
71004: LIST
71005: LIST
71006: LIST
71007: LIST
71008: LIST
71009: LIST
71010: LIST
71011: LIST
71012: LIST
71013: LIST
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71027: LD_ADDR_VAR 0 43
71031: PUSH
71032: LD_INT 0
71034: PUSH
71035: LD_INT 0
71037: PUSH
71038: EMPTY
71039: LIST
71040: LIST
71041: PUSH
71042: LD_INT 0
71044: PUSH
71045: LD_INT 1
71047: NEG
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: PUSH
71053: LD_INT 1
71055: PUSH
71056: LD_INT 0
71058: PUSH
71059: EMPTY
71060: LIST
71061: LIST
71062: PUSH
71063: LD_INT 1
71065: PUSH
71066: LD_INT 1
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: LD_INT 0
71075: PUSH
71076: LD_INT 1
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PUSH
71083: LD_INT 1
71085: NEG
71086: PUSH
71087: LD_INT 0
71089: PUSH
71090: EMPTY
71091: LIST
71092: LIST
71093: PUSH
71094: LD_INT 1
71096: NEG
71097: PUSH
71098: LD_INT 1
71100: NEG
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PUSH
71106: LD_INT 1
71108: NEG
71109: PUSH
71110: LD_INT 2
71112: NEG
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: PUSH
71118: LD_INT 0
71120: PUSH
71121: LD_INT 2
71123: NEG
71124: PUSH
71125: EMPTY
71126: LIST
71127: LIST
71128: PUSH
71129: LD_INT 1
71131: PUSH
71132: LD_INT 1
71134: NEG
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: PUSH
71140: LD_INT 2
71142: PUSH
71143: LD_INT 0
71145: PUSH
71146: EMPTY
71147: LIST
71148: LIST
71149: PUSH
71150: LD_INT 2
71152: PUSH
71153: LD_INT 1
71155: PUSH
71156: EMPTY
71157: LIST
71158: LIST
71159: PUSH
71160: LD_INT 1
71162: PUSH
71163: LD_INT 2
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: LD_INT 0
71172: PUSH
71173: LD_INT 2
71175: PUSH
71176: EMPTY
71177: LIST
71178: LIST
71179: PUSH
71180: LD_INT 1
71182: NEG
71183: PUSH
71184: LD_INT 1
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PUSH
71191: LD_INT 2
71193: NEG
71194: PUSH
71195: LD_INT 0
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: PUSH
71202: LD_INT 2
71204: NEG
71205: PUSH
71206: LD_INT 1
71208: NEG
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PUSH
71214: LD_INT 1
71216: NEG
71217: PUSH
71218: LD_INT 3
71220: NEG
71221: PUSH
71222: EMPTY
71223: LIST
71224: LIST
71225: PUSH
71226: LD_INT 0
71228: PUSH
71229: LD_INT 3
71231: NEG
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: PUSH
71237: LD_INT 1
71239: PUSH
71240: LD_INT 2
71242: NEG
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 2
71250: PUSH
71251: LD_INT 1
71253: NEG
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: LD_INT 3
71261: PUSH
71262: LD_INT 0
71264: PUSH
71265: EMPTY
71266: LIST
71267: LIST
71268: PUSH
71269: LD_INT 3
71271: PUSH
71272: LD_INT 1
71274: PUSH
71275: EMPTY
71276: LIST
71277: LIST
71278: PUSH
71279: LD_INT 1
71281: PUSH
71282: LD_INT 3
71284: PUSH
71285: EMPTY
71286: LIST
71287: LIST
71288: PUSH
71289: LD_INT 0
71291: PUSH
71292: LD_INT 3
71294: PUSH
71295: EMPTY
71296: LIST
71297: LIST
71298: PUSH
71299: LD_INT 1
71301: NEG
71302: PUSH
71303: LD_INT 2
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: LD_INT 2
71312: NEG
71313: PUSH
71314: LD_INT 1
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 3
71323: NEG
71324: PUSH
71325: LD_INT 0
71327: PUSH
71328: EMPTY
71329: LIST
71330: LIST
71331: PUSH
71332: LD_INT 3
71334: NEG
71335: PUSH
71336: LD_INT 1
71338: NEG
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: PUSH
71344: EMPTY
71345: LIST
71346: LIST
71347: LIST
71348: LIST
71349: LIST
71350: LIST
71351: LIST
71352: LIST
71353: LIST
71354: LIST
71355: LIST
71356: LIST
71357: LIST
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: LIST
71364: LIST
71365: LIST
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71375: LD_ADDR_VAR 0 44
71379: PUSH
71380: LD_INT 0
71382: PUSH
71383: LD_INT 0
71385: PUSH
71386: EMPTY
71387: LIST
71388: LIST
71389: PUSH
71390: LD_INT 0
71392: PUSH
71393: LD_INT 1
71395: NEG
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: PUSH
71401: LD_INT 1
71403: PUSH
71404: LD_INT 0
71406: PUSH
71407: EMPTY
71408: LIST
71409: LIST
71410: PUSH
71411: LD_INT 1
71413: PUSH
71414: LD_INT 1
71416: PUSH
71417: EMPTY
71418: LIST
71419: LIST
71420: PUSH
71421: LD_INT 0
71423: PUSH
71424: LD_INT 1
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: PUSH
71431: LD_INT 1
71433: NEG
71434: PUSH
71435: LD_INT 0
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: PUSH
71442: LD_INT 1
71444: NEG
71445: PUSH
71446: LD_INT 1
71448: NEG
71449: PUSH
71450: EMPTY
71451: LIST
71452: LIST
71453: PUSH
71454: LD_INT 1
71456: NEG
71457: PUSH
71458: LD_INT 2
71460: NEG
71461: PUSH
71462: EMPTY
71463: LIST
71464: LIST
71465: PUSH
71466: LD_INT 1
71468: PUSH
71469: LD_INT 1
71471: NEG
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PUSH
71477: LD_INT 2
71479: PUSH
71480: LD_INT 0
71482: PUSH
71483: EMPTY
71484: LIST
71485: LIST
71486: PUSH
71487: LD_INT 2
71489: PUSH
71490: LD_INT 1
71492: PUSH
71493: EMPTY
71494: LIST
71495: LIST
71496: PUSH
71497: LD_INT 2
71499: PUSH
71500: LD_INT 2
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 1
71509: PUSH
71510: LD_INT 2
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: PUSH
71517: LD_INT 1
71519: NEG
71520: PUSH
71521: LD_INT 1
71523: PUSH
71524: EMPTY
71525: LIST
71526: LIST
71527: PUSH
71528: LD_INT 2
71530: NEG
71531: PUSH
71532: LD_INT 0
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: PUSH
71539: LD_INT 2
71541: NEG
71542: PUSH
71543: LD_INT 1
71545: NEG
71546: PUSH
71547: EMPTY
71548: LIST
71549: LIST
71550: PUSH
71551: LD_INT 2
71553: NEG
71554: PUSH
71555: LD_INT 2
71557: NEG
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: LD_INT 2
71565: NEG
71566: PUSH
71567: LD_INT 3
71569: NEG
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PUSH
71575: LD_INT 2
71577: PUSH
71578: LD_INT 1
71580: NEG
71581: PUSH
71582: EMPTY
71583: LIST
71584: LIST
71585: PUSH
71586: LD_INT 3
71588: PUSH
71589: LD_INT 0
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: PUSH
71596: LD_INT 3
71598: PUSH
71599: LD_INT 1
71601: PUSH
71602: EMPTY
71603: LIST
71604: LIST
71605: PUSH
71606: LD_INT 3
71608: PUSH
71609: LD_INT 2
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: PUSH
71616: LD_INT 3
71618: PUSH
71619: LD_INT 3
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: PUSH
71626: LD_INT 2
71628: PUSH
71629: LD_INT 3
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: PUSH
71636: LD_INT 2
71638: NEG
71639: PUSH
71640: LD_INT 1
71642: PUSH
71643: EMPTY
71644: LIST
71645: LIST
71646: PUSH
71647: LD_INT 3
71649: NEG
71650: PUSH
71651: LD_INT 0
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: PUSH
71658: LD_INT 3
71660: NEG
71661: PUSH
71662: LD_INT 1
71664: NEG
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 3
71672: NEG
71673: PUSH
71674: LD_INT 2
71676: NEG
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 3
71684: NEG
71685: PUSH
71686: LD_INT 3
71688: NEG
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: PUSH
71694: EMPTY
71695: LIST
71696: LIST
71697: LIST
71698: LIST
71699: LIST
71700: LIST
71701: LIST
71702: LIST
71703: LIST
71704: LIST
71705: LIST
71706: LIST
71707: LIST
71708: LIST
71709: LIST
71710: LIST
71711: LIST
71712: LIST
71713: LIST
71714: LIST
71715: LIST
71716: LIST
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: LIST
71722: LIST
71723: LIST
71724: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71725: LD_ADDR_VAR 0 45
71729: PUSH
71730: LD_INT 0
71732: PUSH
71733: LD_INT 0
71735: PUSH
71736: EMPTY
71737: LIST
71738: LIST
71739: PUSH
71740: LD_INT 0
71742: PUSH
71743: LD_INT 1
71745: NEG
71746: PUSH
71747: EMPTY
71748: LIST
71749: LIST
71750: PUSH
71751: LD_INT 1
71753: PUSH
71754: LD_INT 0
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: LD_INT 1
71763: PUSH
71764: LD_INT 1
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: PUSH
71771: LD_INT 0
71773: PUSH
71774: LD_INT 1
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: PUSH
71781: LD_INT 1
71783: NEG
71784: PUSH
71785: LD_INT 0
71787: PUSH
71788: EMPTY
71789: LIST
71790: LIST
71791: PUSH
71792: LD_INT 1
71794: NEG
71795: PUSH
71796: LD_INT 1
71798: NEG
71799: PUSH
71800: EMPTY
71801: LIST
71802: LIST
71803: PUSH
71804: LD_INT 1
71806: NEG
71807: PUSH
71808: LD_INT 2
71810: NEG
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 0
71818: PUSH
71819: LD_INT 2
71821: NEG
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PUSH
71827: LD_INT 1
71829: PUSH
71830: LD_INT 1
71832: NEG
71833: PUSH
71834: EMPTY
71835: LIST
71836: LIST
71837: PUSH
71838: LD_INT 2
71840: PUSH
71841: LD_INT 1
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 2
71850: PUSH
71851: LD_INT 2
71853: PUSH
71854: EMPTY
71855: LIST
71856: LIST
71857: PUSH
71858: LD_INT 1
71860: PUSH
71861: LD_INT 2
71863: PUSH
71864: EMPTY
71865: LIST
71866: LIST
71867: PUSH
71868: LD_INT 0
71870: PUSH
71871: LD_INT 2
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: PUSH
71878: LD_INT 1
71880: NEG
71881: PUSH
71882: LD_INT 1
71884: PUSH
71885: EMPTY
71886: LIST
71887: LIST
71888: PUSH
71889: LD_INT 2
71891: NEG
71892: PUSH
71893: LD_INT 1
71895: NEG
71896: PUSH
71897: EMPTY
71898: LIST
71899: LIST
71900: PUSH
71901: LD_INT 2
71903: NEG
71904: PUSH
71905: LD_INT 2
71907: NEG
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: LD_INT 2
71915: NEG
71916: PUSH
71917: LD_INT 3
71919: NEG
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PUSH
71925: LD_INT 1
71927: NEG
71928: PUSH
71929: LD_INT 3
71931: NEG
71932: PUSH
71933: EMPTY
71934: LIST
71935: LIST
71936: PUSH
71937: LD_INT 0
71939: PUSH
71940: LD_INT 3
71942: NEG
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: PUSH
71948: LD_INT 1
71950: PUSH
71951: LD_INT 2
71953: NEG
71954: PUSH
71955: EMPTY
71956: LIST
71957: LIST
71958: PUSH
71959: LD_INT 3
71961: PUSH
71962: LD_INT 2
71964: PUSH
71965: EMPTY
71966: LIST
71967: LIST
71968: PUSH
71969: LD_INT 3
71971: PUSH
71972: LD_INT 3
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: PUSH
71979: LD_INT 2
71981: PUSH
71982: LD_INT 3
71984: PUSH
71985: EMPTY
71986: LIST
71987: LIST
71988: PUSH
71989: LD_INT 1
71991: PUSH
71992: LD_INT 3
71994: PUSH
71995: EMPTY
71996: LIST
71997: LIST
71998: PUSH
71999: LD_INT 0
72001: PUSH
72002: LD_INT 3
72004: PUSH
72005: EMPTY
72006: LIST
72007: LIST
72008: PUSH
72009: LD_INT 1
72011: NEG
72012: PUSH
72013: LD_INT 2
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: LD_INT 3
72022: NEG
72023: PUSH
72024: LD_INT 2
72026: NEG
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: PUSH
72032: LD_INT 3
72034: NEG
72035: PUSH
72036: LD_INT 3
72038: NEG
72039: PUSH
72040: EMPTY
72041: LIST
72042: LIST
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: LIST
72048: LIST
72049: LIST
72050: LIST
72051: LIST
72052: LIST
72053: LIST
72054: LIST
72055: LIST
72056: LIST
72057: LIST
72058: LIST
72059: LIST
72060: LIST
72061: LIST
72062: LIST
72063: LIST
72064: LIST
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: LIST
72071: LIST
72072: LIST
72073: LIST
72074: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72075: LD_ADDR_VAR 0 46
72079: PUSH
72080: LD_INT 0
72082: PUSH
72083: LD_INT 0
72085: PUSH
72086: EMPTY
72087: LIST
72088: LIST
72089: PUSH
72090: LD_INT 0
72092: PUSH
72093: LD_INT 1
72095: NEG
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: PUSH
72101: LD_INT 1
72103: PUSH
72104: LD_INT 0
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 1
72113: PUSH
72114: LD_INT 1
72116: PUSH
72117: EMPTY
72118: LIST
72119: LIST
72120: PUSH
72121: LD_INT 0
72123: PUSH
72124: LD_INT 1
72126: PUSH
72127: EMPTY
72128: LIST
72129: LIST
72130: PUSH
72131: LD_INT 1
72133: NEG
72134: PUSH
72135: LD_INT 0
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: PUSH
72142: LD_INT 1
72144: NEG
72145: PUSH
72146: LD_INT 1
72148: NEG
72149: PUSH
72150: EMPTY
72151: LIST
72152: LIST
72153: PUSH
72154: LD_INT 1
72156: NEG
72157: PUSH
72158: LD_INT 2
72160: NEG
72161: PUSH
72162: EMPTY
72163: LIST
72164: LIST
72165: PUSH
72166: LD_INT 0
72168: PUSH
72169: LD_INT 2
72171: NEG
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: PUSH
72177: LD_INT 1
72179: PUSH
72180: LD_INT 1
72182: NEG
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: PUSH
72188: LD_INT 2
72190: PUSH
72191: LD_INT 0
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 2
72200: PUSH
72201: LD_INT 1
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 1
72210: PUSH
72211: LD_INT 2
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 0
72220: PUSH
72221: LD_INT 2
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: PUSH
72228: LD_INT 1
72230: NEG
72231: PUSH
72232: LD_INT 1
72234: PUSH
72235: EMPTY
72236: LIST
72237: LIST
72238: PUSH
72239: LD_INT 2
72241: NEG
72242: PUSH
72243: LD_INT 0
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: PUSH
72250: LD_INT 2
72252: NEG
72253: PUSH
72254: LD_INT 1
72256: NEG
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: PUSH
72262: LD_INT 1
72264: NEG
72265: PUSH
72266: LD_INT 3
72268: NEG
72269: PUSH
72270: EMPTY
72271: LIST
72272: LIST
72273: PUSH
72274: LD_INT 0
72276: PUSH
72277: LD_INT 3
72279: NEG
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PUSH
72285: LD_INT 1
72287: PUSH
72288: LD_INT 2
72290: NEG
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: PUSH
72296: LD_INT 2
72298: PUSH
72299: LD_INT 1
72301: NEG
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 3
72309: PUSH
72310: LD_INT 0
72312: PUSH
72313: EMPTY
72314: LIST
72315: LIST
72316: PUSH
72317: LD_INT 3
72319: PUSH
72320: LD_INT 1
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: LD_INT 1
72329: PUSH
72330: LD_INT 3
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 0
72339: PUSH
72340: LD_INT 3
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: PUSH
72347: LD_INT 1
72349: NEG
72350: PUSH
72351: LD_INT 2
72353: PUSH
72354: EMPTY
72355: LIST
72356: LIST
72357: PUSH
72358: LD_INT 2
72360: NEG
72361: PUSH
72362: LD_INT 1
72364: PUSH
72365: EMPTY
72366: LIST
72367: LIST
72368: PUSH
72369: LD_INT 3
72371: NEG
72372: PUSH
72373: LD_INT 0
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: PUSH
72380: LD_INT 3
72382: NEG
72383: PUSH
72384: LD_INT 1
72386: NEG
72387: PUSH
72388: EMPTY
72389: LIST
72390: LIST
72391: PUSH
72392: EMPTY
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: LIST
72401: LIST
72402: LIST
72403: LIST
72404: LIST
72405: LIST
72406: LIST
72407: LIST
72408: LIST
72409: LIST
72410: LIST
72411: LIST
72412: LIST
72413: LIST
72414: LIST
72415: LIST
72416: LIST
72417: LIST
72418: LIST
72419: LIST
72420: LIST
72421: LIST
72422: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72423: LD_ADDR_VAR 0 47
72427: PUSH
72428: LD_INT 0
72430: PUSH
72431: LD_INT 0
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PUSH
72438: LD_INT 0
72440: PUSH
72441: LD_INT 1
72443: NEG
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: LD_INT 1
72451: PUSH
72452: LD_INT 0
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: PUSH
72459: LD_INT 1
72461: PUSH
72462: LD_INT 1
72464: PUSH
72465: EMPTY
72466: LIST
72467: LIST
72468: PUSH
72469: LD_INT 0
72471: PUSH
72472: LD_INT 1
72474: PUSH
72475: EMPTY
72476: LIST
72477: LIST
72478: PUSH
72479: LD_INT 1
72481: NEG
72482: PUSH
72483: LD_INT 0
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: PUSH
72490: LD_INT 1
72492: NEG
72493: PUSH
72494: LD_INT 1
72496: NEG
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PUSH
72502: LD_INT 1
72504: NEG
72505: PUSH
72506: LD_INT 2
72508: NEG
72509: PUSH
72510: EMPTY
72511: LIST
72512: LIST
72513: PUSH
72514: LD_INT 0
72516: PUSH
72517: LD_INT 2
72519: NEG
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PUSH
72525: LD_INT 1
72527: PUSH
72528: LD_INT 1
72530: NEG
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: PUSH
72536: LD_INT 2
72538: NEG
72539: PUSH
72540: LD_INT 1
72542: NEG
72543: PUSH
72544: EMPTY
72545: LIST
72546: LIST
72547: PUSH
72548: LD_INT 2
72550: NEG
72551: PUSH
72552: LD_INT 2
72554: NEG
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: EMPTY
72561: LIST
72562: LIST
72563: LIST
72564: LIST
72565: LIST
72566: LIST
72567: LIST
72568: LIST
72569: LIST
72570: LIST
72571: LIST
72572: LIST
72573: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
72574: LD_ADDR_VAR 0 48
72578: PUSH
72579: LD_INT 0
72581: PUSH
72582: LD_INT 0
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: PUSH
72589: LD_INT 0
72591: PUSH
72592: LD_INT 1
72594: NEG
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 1
72602: PUSH
72603: LD_INT 0
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: PUSH
72610: LD_INT 1
72612: PUSH
72613: LD_INT 1
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: PUSH
72620: LD_INT 0
72622: PUSH
72623: LD_INT 1
72625: PUSH
72626: EMPTY
72627: LIST
72628: LIST
72629: PUSH
72630: LD_INT 1
72632: NEG
72633: PUSH
72634: LD_INT 0
72636: PUSH
72637: EMPTY
72638: LIST
72639: LIST
72640: PUSH
72641: LD_INT 1
72643: NEG
72644: PUSH
72645: LD_INT 1
72647: NEG
72648: PUSH
72649: EMPTY
72650: LIST
72651: LIST
72652: PUSH
72653: LD_INT 1
72655: NEG
72656: PUSH
72657: LD_INT 2
72659: NEG
72660: PUSH
72661: EMPTY
72662: LIST
72663: LIST
72664: PUSH
72665: LD_INT 0
72667: PUSH
72668: LD_INT 2
72670: NEG
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: PUSH
72676: LD_INT 1
72678: PUSH
72679: LD_INT 1
72681: NEG
72682: PUSH
72683: EMPTY
72684: LIST
72685: LIST
72686: PUSH
72687: LD_INT 2
72689: PUSH
72690: LD_INT 0
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 2
72699: PUSH
72700: LD_INT 1
72702: PUSH
72703: EMPTY
72704: LIST
72705: LIST
72706: PUSH
72707: EMPTY
72708: LIST
72709: LIST
72710: LIST
72711: LIST
72712: LIST
72713: LIST
72714: LIST
72715: LIST
72716: LIST
72717: LIST
72718: LIST
72719: LIST
72720: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72721: LD_ADDR_VAR 0 49
72725: PUSH
72726: LD_INT 0
72728: PUSH
72729: LD_INT 0
72731: PUSH
72732: EMPTY
72733: LIST
72734: LIST
72735: PUSH
72736: LD_INT 0
72738: PUSH
72739: LD_INT 1
72741: NEG
72742: PUSH
72743: EMPTY
72744: LIST
72745: LIST
72746: PUSH
72747: LD_INT 1
72749: PUSH
72750: LD_INT 0
72752: PUSH
72753: EMPTY
72754: LIST
72755: LIST
72756: PUSH
72757: LD_INT 1
72759: PUSH
72760: LD_INT 1
72762: PUSH
72763: EMPTY
72764: LIST
72765: LIST
72766: PUSH
72767: LD_INT 0
72769: PUSH
72770: LD_INT 1
72772: PUSH
72773: EMPTY
72774: LIST
72775: LIST
72776: PUSH
72777: LD_INT 1
72779: NEG
72780: PUSH
72781: LD_INT 0
72783: PUSH
72784: EMPTY
72785: LIST
72786: LIST
72787: PUSH
72788: LD_INT 1
72790: NEG
72791: PUSH
72792: LD_INT 1
72794: NEG
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: LD_INT 1
72802: PUSH
72803: LD_INT 1
72805: NEG
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: PUSH
72811: LD_INT 2
72813: PUSH
72814: LD_INT 0
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: PUSH
72821: LD_INT 2
72823: PUSH
72824: LD_INT 1
72826: PUSH
72827: EMPTY
72828: LIST
72829: LIST
72830: PUSH
72831: LD_INT 2
72833: PUSH
72834: LD_INT 2
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: PUSH
72841: LD_INT 1
72843: PUSH
72844: LD_INT 2
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: LIST
72855: LIST
72856: LIST
72857: LIST
72858: LIST
72859: LIST
72860: LIST
72861: LIST
72862: LIST
72863: LIST
72864: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72865: LD_ADDR_VAR 0 50
72869: PUSH
72870: LD_INT 0
72872: PUSH
72873: LD_INT 0
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: PUSH
72880: LD_INT 0
72882: PUSH
72883: LD_INT 1
72885: NEG
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: PUSH
72891: LD_INT 1
72893: PUSH
72894: LD_INT 0
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: PUSH
72901: LD_INT 1
72903: PUSH
72904: LD_INT 1
72906: PUSH
72907: EMPTY
72908: LIST
72909: LIST
72910: PUSH
72911: LD_INT 0
72913: PUSH
72914: LD_INT 1
72916: PUSH
72917: EMPTY
72918: LIST
72919: LIST
72920: PUSH
72921: LD_INT 1
72923: NEG
72924: PUSH
72925: LD_INT 0
72927: PUSH
72928: EMPTY
72929: LIST
72930: LIST
72931: PUSH
72932: LD_INT 1
72934: NEG
72935: PUSH
72936: LD_INT 1
72938: NEG
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: PUSH
72944: LD_INT 2
72946: PUSH
72947: LD_INT 1
72949: PUSH
72950: EMPTY
72951: LIST
72952: LIST
72953: PUSH
72954: LD_INT 2
72956: PUSH
72957: LD_INT 2
72959: PUSH
72960: EMPTY
72961: LIST
72962: LIST
72963: PUSH
72964: LD_INT 1
72966: PUSH
72967: LD_INT 2
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: PUSH
72974: LD_INT 0
72976: PUSH
72977: LD_INT 2
72979: PUSH
72980: EMPTY
72981: LIST
72982: LIST
72983: PUSH
72984: LD_INT 1
72986: NEG
72987: PUSH
72988: LD_INT 1
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: LIST
72999: LIST
73000: LIST
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: LIST
73008: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73009: LD_ADDR_VAR 0 51
73013: PUSH
73014: LD_INT 0
73016: PUSH
73017: LD_INT 0
73019: PUSH
73020: EMPTY
73021: LIST
73022: LIST
73023: PUSH
73024: LD_INT 0
73026: PUSH
73027: LD_INT 1
73029: NEG
73030: PUSH
73031: EMPTY
73032: LIST
73033: LIST
73034: PUSH
73035: LD_INT 1
73037: PUSH
73038: LD_INT 0
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: LD_INT 1
73047: PUSH
73048: LD_INT 1
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: LD_INT 0
73057: PUSH
73058: LD_INT 1
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: PUSH
73065: LD_INT 1
73067: NEG
73068: PUSH
73069: LD_INT 0
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: PUSH
73076: LD_INT 1
73078: NEG
73079: PUSH
73080: LD_INT 1
73082: NEG
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 1
73090: PUSH
73091: LD_INT 2
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PUSH
73098: LD_INT 0
73100: PUSH
73101: LD_INT 2
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PUSH
73108: LD_INT 1
73110: NEG
73111: PUSH
73112: LD_INT 1
73114: PUSH
73115: EMPTY
73116: LIST
73117: LIST
73118: PUSH
73119: LD_INT 2
73121: NEG
73122: PUSH
73123: LD_INT 0
73125: PUSH
73126: EMPTY
73127: LIST
73128: LIST
73129: PUSH
73130: LD_INT 2
73132: NEG
73133: PUSH
73134: LD_INT 1
73136: NEG
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: EMPTY
73143: LIST
73144: LIST
73145: LIST
73146: LIST
73147: LIST
73148: LIST
73149: LIST
73150: LIST
73151: LIST
73152: LIST
73153: LIST
73154: LIST
73155: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73156: LD_ADDR_VAR 0 52
73160: PUSH
73161: LD_INT 0
73163: PUSH
73164: LD_INT 0
73166: PUSH
73167: EMPTY
73168: LIST
73169: LIST
73170: PUSH
73171: LD_INT 0
73173: PUSH
73174: LD_INT 1
73176: NEG
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PUSH
73182: LD_INT 1
73184: PUSH
73185: LD_INT 0
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PUSH
73192: LD_INT 1
73194: PUSH
73195: LD_INT 1
73197: PUSH
73198: EMPTY
73199: LIST
73200: LIST
73201: PUSH
73202: LD_INT 0
73204: PUSH
73205: LD_INT 1
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 1
73214: NEG
73215: PUSH
73216: LD_INT 0
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: PUSH
73223: LD_INT 1
73225: NEG
73226: PUSH
73227: LD_INT 1
73229: NEG
73230: PUSH
73231: EMPTY
73232: LIST
73233: LIST
73234: PUSH
73235: LD_INT 1
73237: NEG
73238: PUSH
73239: LD_INT 2
73241: NEG
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PUSH
73247: LD_INT 1
73249: NEG
73250: PUSH
73251: LD_INT 1
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: PUSH
73258: LD_INT 2
73260: NEG
73261: PUSH
73262: LD_INT 0
73264: PUSH
73265: EMPTY
73266: LIST
73267: LIST
73268: PUSH
73269: LD_INT 2
73271: NEG
73272: PUSH
73273: LD_INT 1
73275: NEG
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: PUSH
73281: LD_INT 2
73283: NEG
73284: PUSH
73285: LD_INT 2
73287: NEG
73288: PUSH
73289: EMPTY
73290: LIST
73291: LIST
73292: PUSH
73293: EMPTY
73294: LIST
73295: LIST
73296: LIST
73297: LIST
73298: LIST
73299: LIST
73300: LIST
73301: LIST
73302: LIST
73303: LIST
73304: LIST
73305: LIST
73306: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73307: LD_ADDR_VAR 0 53
73311: PUSH
73312: LD_INT 0
73314: PUSH
73315: LD_INT 0
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PUSH
73322: LD_INT 0
73324: PUSH
73325: LD_INT 1
73327: NEG
73328: PUSH
73329: EMPTY
73330: LIST
73331: LIST
73332: PUSH
73333: LD_INT 1
73335: PUSH
73336: LD_INT 0
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: PUSH
73343: LD_INT 1
73345: PUSH
73346: LD_INT 1
73348: PUSH
73349: EMPTY
73350: LIST
73351: LIST
73352: PUSH
73353: LD_INT 0
73355: PUSH
73356: LD_INT 1
73358: PUSH
73359: EMPTY
73360: LIST
73361: LIST
73362: PUSH
73363: LD_INT 1
73365: NEG
73366: PUSH
73367: LD_INT 0
73369: PUSH
73370: EMPTY
73371: LIST
73372: LIST
73373: PUSH
73374: LD_INT 1
73376: NEG
73377: PUSH
73378: LD_INT 1
73380: NEG
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: PUSH
73386: LD_INT 1
73388: NEG
73389: PUSH
73390: LD_INT 2
73392: NEG
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 0
73400: PUSH
73401: LD_INT 2
73403: NEG
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 1
73411: PUSH
73412: LD_INT 1
73414: NEG
73415: PUSH
73416: EMPTY
73417: LIST
73418: LIST
73419: PUSH
73420: LD_INT 2
73422: PUSH
73423: LD_INT 0
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: PUSH
73430: LD_INT 2
73432: PUSH
73433: LD_INT 1
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 2
73442: PUSH
73443: LD_INT 2
73445: PUSH
73446: EMPTY
73447: LIST
73448: LIST
73449: PUSH
73450: LD_INT 1
73452: PUSH
73453: LD_INT 2
73455: PUSH
73456: EMPTY
73457: LIST
73458: LIST
73459: PUSH
73460: LD_INT 0
73462: PUSH
73463: LD_INT 2
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: PUSH
73470: LD_INT 1
73472: NEG
73473: PUSH
73474: LD_INT 1
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: LD_INT 2
73483: NEG
73484: PUSH
73485: LD_INT 0
73487: PUSH
73488: EMPTY
73489: LIST
73490: LIST
73491: PUSH
73492: LD_INT 2
73494: NEG
73495: PUSH
73496: LD_INT 1
73498: NEG
73499: PUSH
73500: EMPTY
73501: LIST
73502: LIST
73503: PUSH
73504: LD_INT 2
73506: NEG
73507: PUSH
73508: LD_INT 2
73510: NEG
73511: PUSH
73512: EMPTY
73513: LIST
73514: LIST
73515: PUSH
73516: EMPTY
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: LIST
73527: LIST
73528: LIST
73529: LIST
73530: LIST
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: LIST
73536: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73537: LD_ADDR_VAR 0 54
73541: PUSH
73542: LD_INT 0
73544: PUSH
73545: LD_INT 0
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: PUSH
73552: LD_INT 0
73554: PUSH
73555: LD_INT 1
73557: NEG
73558: PUSH
73559: EMPTY
73560: LIST
73561: LIST
73562: PUSH
73563: LD_INT 1
73565: PUSH
73566: LD_INT 0
73568: PUSH
73569: EMPTY
73570: LIST
73571: LIST
73572: PUSH
73573: LD_INT 1
73575: PUSH
73576: LD_INT 1
73578: PUSH
73579: EMPTY
73580: LIST
73581: LIST
73582: PUSH
73583: LD_INT 0
73585: PUSH
73586: LD_INT 1
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: LD_INT 1
73595: NEG
73596: PUSH
73597: LD_INT 0
73599: PUSH
73600: EMPTY
73601: LIST
73602: LIST
73603: PUSH
73604: LD_INT 1
73606: NEG
73607: PUSH
73608: LD_INT 1
73610: NEG
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 1
73618: NEG
73619: PUSH
73620: LD_INT 2
73622: NEG
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 0
73630: PUSH
73631: LD_INT 2
73633: NEG
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: PUSH
73639: LD_INT 1
73641: PUSH
73642: LD_INT 1
73644: NEG
73645: PUSH
73646: EMPTY
73647: LIST
73648: LIST
73649: PUSH
73650: LD_INT 2
73652: PUSH
73653: LD_INT 0
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: PUSH
73660: LD_INT 2
73662: PUSH
73663: LD_INT 1
73665: PUSH
73666: EMPTY
73667: LIST
73668: LIST
73669: PUSH
73670: LD_INT 2
73672: PUSH
73673: LD_INT 2
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: PUSH
73680: LD_INT 1
73682: PUSH
73683: LD_INT 2
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: PUSH
73690: LD_INT 0
73692: PUSH
73693: LD_INT 2
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: LD_INT 1
73702: NEG
73703: PUSH
73704: LD_INT 1
73706: PUSH
73707: EMPTY
73708: LIST
73709: LIST
73710: PUSH
73711: LD_INT 2
73713: NEG
73714: PUSH
73715: LD_INT 0
73717: PUSH
73718: EMPTY
73719: LIST
73720: LIST
73721: PUSH
73722: LD_INT 2
73724: NEG
73725: PUSH
73726: LD_INT 1
73728: NEG
73729: PUSH
73730: EMPTY
73731: LIST
73732: LIST
73733: PUSH
73734: LD_INT 2
73736: NEG
73737: PUSH
73738: LD_INT 2
73740: NEG
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: LIST
73750: LIST
73751: LIST
73752: LIST
73753: LIST
73754: LIST
73755: LIST
73756: LIST
73757: LIST
73758: LIST
73759: LIST
73760: LIST
73761: LIST
73762: LIST
73763: LIST
73764: LIST
73765: LIST
73766: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73767: LD_ADDR_VAR 0 55
73771: PUSH
73772: LD_INT 0
73774: PUSH
73775: LD_INT 0
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PUSH
73782: LD_INT 0
73784: PUSH
73785: LD_INT 1
73787: NEG
73788: PUSH
73789: EMPTY
73790: LIST
73791: LIST
73792: PUSH
73793: LD_INT 1
73795: PUSH
73796: LD_INT 0
73798: PUSH
73799: EMPTY
73800: LIST
73801: LIST
73802: PUSH
73803: LD_INT 1
73805: PUSH
73806: LD_INT 1
73808: PUSH
73809: EMPTY
73810: LIST
73811: LIST
73812: PUSH
73813: LD_INT 0
73815: PUSH
73816: LD_INT 1
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: PUSH
73823: LD_INT 1
73825: NEG
73826: PUSH
73827: LD_INT 0
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: LD_INT 1
73836: NEG
73837: PUSH
73838: LD_INT 1
73840: NEG
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 1
73848: NEG
73849: PUSH
73850: LD_INT 2
73852: NEG
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: PUSH
73858: LD_INT 0
73860: PUSH
73861: LD_INT 2
73863: NEG
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PUSH
73869: LD_INT 1
73871: PUSH
73872: LD_INT 1
73874: NEG
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: PUSH
73880: LD_INT 2
73882: PUSH
73883: LD_INT 0
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: PUSH
73890: LD_INT 2
73892: PUSH
73893: LD_INT 1
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: PUSH
73900: LD_INT 2
73902: PUSH
73903: LD_INT 2
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: LD_INT 1
73912: PUSH
73913: LD_INT 2
73915: PUSH
73916: EMPTY
73917: LIST
73918: LIST
73919: PUSH
73920: LD_INT 0
73922: PUSH
73923: LD_INT 2
73925: PUSH
73926: EMPTY
73927: LIST
73928: LIST
73929: PUSH
73930: LD_INT 1
73932: NEG
73933: PUSH
73934: LD_INT 1
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: PUSH
73941: LD_INT 2
73943: NEG
73944: PUSH
73945: LD_INT 0
73947: PUSH
73948: EMPTY
73949: LIST
73950: LIST
73951: PUSH
73952: LD_INT 2
73954: NEG
73955: PUSH
73956: LD_INT 1
73958: NEG
73959: PUSH
73960: EMPTY
73961: LIST
73962: LIST
73963: PUSH
73964: LD_INT 2
73966: NEG
73967: PUSH
73968: LD_INT 2
73970: NEG
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: PUSH
73976: EMPTY
73977: LIST
73978: LIST
73979: LIST
73980: LIST
73981: LIST
73982: LIST
73983: LIST
73984: LIST
73985: LIST
73986: LIST
73987: LIST
73988: LIST
73989: LIST
73990: LIST
73991: LIST
73992: LIST
73993: LIST
73994: LIST
73995: LIST
73996: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73997: LD_ADDR_VAR 0 56
74001: PUSH
74002: LD_INT 0
74004: PUSH
74005: LD_INT 0
74007: PUSH
74008: EMPTY
74009: LIST
74010: LIST
74011: PUSH
74012: LD_INT 0
74014: PUSH
74015: LD_INT 1
74017: NEG
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: PUSH
74023: LD_INT 1
74025: PUSH
74026: LD_INT 0
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: PUSH
74033: LD_INT 1
74035: PUSH
74036: LD_INT 1
74038: PUSH
74039: EMPTY
74040: LIST
74041: LIST
74042: PUSH
74043: LD_INT 0
74045: PUSH
74046: LD_INT 1
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PUSH
74053: LD_INT 1
74055: NEG
74056: PUSH
74057: LD_INT 0
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: PUSH
74064: LD_INT 1
74066: NEG
74067: PUSH
74068: LD_INT 1
74070: NEG
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 1
74078: NEG
74079: PUSH
74080: LD_INT 2
74082: NEG
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PUSH
74088: LD_INT 0
74090: PUSH
74091: LD_INT 2
74093: NEG
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: PUSH
74099: LD_INT 1
74101: PUSH
74102: LD_INT 1
74104: NEG
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: PUSH
74110: LD_INT 2
74112: PUSH
74113: LD_INT 0
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PUSH
74120: LD_INT 2
74122: PUSH
74123: LD_INT 1
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: LD_INT 2
74132: PUSH
74133: LD_INT 2
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: PUSH
74140: LD_INT 1
74142: PUSH
74143: LD_INT 2
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: PUSH
74150: LD_INT 0
74152: PUSH
74153: LD_INT 2
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: LD_INT 1
74162: NEG
74163: PUSH
74164: LD_INT 1
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: PUSH
74171: LD_INT 2
74173: NEG
74174: PUSH
74175: LD_INT 0
74177: PUSH
74178: EMPTY
74179: LIST
74180: LIST
74181: PUSH
74182: LD_INT 2
74184: NEG
74185: PUSH
74186: LD_INT 1
74188: NEG
74189: PUSH
74190: EMPTY
74191: LIST
74192: LIST
74193: PUSH
74194: LD_INT 2
74196: NEG
74197: PUSH
74198: LD_INT 2
74200: NEG
74201: PUSH
74202: EMPTY
74203: LIST
74204: LIST
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: LIST
74210: LIST
74211: LIST
74212: LIST
74213: LIST
74214: LIST
74215: LIST
74216: LIST
74217: LIST
74218: LIST
74219: LIST
74220: LIST
74221: LIST
74222: LIST
74223: LIST
74224: LIST
74225: LIST
74226: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74227: LD_ADDR_VAR 0 57
74231: PUSH
74232: LD_INT 0
74234: PUSH
74235: LD_INT 0
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: LD_INT 0
74244: PUSH
74245: LD_INT 1
74247: NEG
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: LD_INT 1
74255: PUSH
74256: LD_INT 0
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: LD_INT 1
74265: PUSH
74266: LD_INT 1
74268: PUSH
74269: EMPTY
74270: LIST
74271: LIST
74272: PUSH
74273: LD_INT 0
74275: PUSH
74276: LD_INT 1
74278: PUSH
74279: EMPTY
74280: LIST
74281: LIST
74282: PUSH
74283: LD_INT 1
74285: NEG
74286: PUSH
74287: LD_INT 0
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PUSH
74294: LD_INT 1
74296: NEG
74297: PUSH
74298: LD_INT 1
74300: NEG
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PUSH
74306: LD_INT 1
74308: NEG
74309: PUSH
74310: LD_INT 2
74312: NEG
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: PUSH
74318: LD_INT 0
74320: PUSH
74321: LD_INT 2
74323: NEG
74324: PUSH
74325: EMPTY
74326: LIST
74327: LIST
74328: PUSH
74329: LD_INT 1
74331: PUSH
74332: LD_INT 1
74334: NEG
74335: PUSH
74336: EMPTY
74337: LIST
74338: LIST
74339: PUSH
74340: LD_INT 2
74342: PUSH
74343: LD_INT 0
74345: PUSH
74346: EMPTY
74347: LIST
74348: LIST
74349: PUSH
74350: LD_INT 2
74352: PUSH
74353: LD_INT 1
74355: PUSH
74356: EMPTY
74357: LIST
74358: LIST
74359: PUSH
74360: LD_INT 2
74362: PUSH
74363: LD_INT 2
74365: PUSH
74366: EMPTY
74367: LIST
74368: LIST
74369: PUSH
74370: LD_INT 1
74372: PUSH
74373: LD_INT 2
74375: PUSH
74376: EMPTY
74377: LIST
74378: LIST
74379: PUSH
74380: LD_INT 0
74382: PUSH
74383: LD_INT 2
74385: PUSH
74386: EMPTY
74387: LIST
74388: LIST
74389: PUSH
74390: LD_INT 1
74392: NEG
74393: PUSH
74394: LD_INT 1
74396: PUSH
74397: EMPTY
74398: LIST
74399: LIST
74400: PUSH
74401: LD_INT 2
74403: NEG
74404: PUSH
74405: LD_INT 0
74407: PUSH
74408: EMPTY
74409: LIST
74410: LIST
74411: PUSH
74412: LD_INT 2
74414: NEG
74415: PUSH
74416: LD_INT 1
74418: NEG
74419: PUSH
74420: EMPTY
74421: LIST
74422: LIST
74423: PUSH
74424: LD_INT 2
74426: NEG
74427: PUSH
74428: LD_INT 2
74430: NEG
74431: PUSH
74432: EMPTY
74433: LIST
74434: LIST
74435: PUSH
74436: EMPTY
74437: LIST
74438: LIST
74439: LIST
74440: LIST
74441: LIST
74442: LIST
74443: LIST
74444: LIST
74445: LIST
74446: LIST
74447: LIST
74448: LIST
74449: LIST
74450: LIST
74451: LIST
74452: LIST
74453: LIST
74454: LIST
74455: LIST
74456: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74457: LD_ADDR_VAR 0 58
74461: PUSH
74462: LD_INT 0
74464: PUSH
74465: LD_INT 0
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: PUSH
74472: LD_INT 0
74474: PUSH
74475: LD_INT 1
74477: NEG
74478: PUSH
74479: EMPTY
74480: LIST
74481: LIST
74482: PUSH
74483: LD_INT 1
74485: PUSH
74486: LD_INT 0
74488: PUSH
74489: EMPTY
74490: LIST
74491: LIST
74492: PUSH
74493: LD_INT 1
74495: PUSH
74496: LD_INT 1
74498: PUSH
74499: EMPTY
74500: LIST
74501: LIST
74502: PUSH
74503: LD_INT 0
74505: PUSH
74506: LD_INT 1
74508: PUSH
74509: EMPTY
74510: LIST
74511: LIST
74512: PUSH
74513: LD_INT 1
74515: NEG
74516: PUSH
74517: LD_INT 0
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: PUSH
74524: LD_INT 1
74526: NEG
74527: PUSH
74528: LD_INT 1
74530: NEG
74531: PUSH
74532: EMPTY
74533: LIST
74534: LIST
74535: PUSH
74536: LD_INT 1
74538: NEG
74539: PUSH
74540: LD_INT 2
74542: NEG
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: PUSH
74548: LD_INT 0
74550: PUSH
74551: LD_INT 2
74553: NEG
74554: PUSH
74555: EMPTY
74556: LIST
74557: LIST
74558: PUSH
74559: LD_INT 1
74561: PUSH
74562: LD_INT 1
74564: NEG
74565: PUSH
74566: EMPTY
74567: LIST
74568: LIST
74569: PUSH
74570: LD_INT 2
74572: PUSH
74573: LD_INT 0
74575: PUSH
74576: EMPTY
74577: LIST
74578: LIST
74579: PUSH
74580: LD_INT 2
74582: PUSH
74583: LD_INT 1
74585: PUSH
74586: EMPTY
74587: LIST
74588: LIST
74589: PUSH
74590: LD_INT 2
74592: PUSH
74593: LD_INT 2
74595: PUSH
74596: EMPTY
74597: LIST
74598: LIST
74599: PUSH
74600: LD_INT 1
74602: PUSH
74603: LD_INT 2
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: PUSH
74610: LD_INT 0
74612: PUSH
74613: LD_INT 2
74615: PUSH
74616: EMPTY
74617: LIST
74618: LIST
74619: PUSH
74620: LD_INT 1
74622: NEG
74623: PUSH
74624: LD_INT 1
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: LD_INT 2
74633: NEG
74634: PUSH
74635: LD_INT 0
74637: PUSH
74638: EMPTY
74639: LIST
74640: LIST
74641: PUSH
74642: LD_INT 2
74644: NEG
74645: PUSH
74646: LD_INT 1
74648: NEG
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: LD_INT 2
74656: NEG
74657: PUSH
74658: LD_INT 2
74660: NEG
74661: PUSH
74662: EMPTY
74663: LIST
74664: LIST
74665: PUSH
74666: EMPTY
74667: LIST
74668: LIST
74669: LIST
74670: LIST
74671: LIST
74672: LIST
74673: LIST
74674: LIST
74675: LIST
74676: LIST
74677: LIST
74678: LIST
74679: LIST
74680: LIST
74681: LIST
74682: LIST
74683: LIST
74684: LIST
74685: LIST
74686: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74687: LD_ADDR_VAR 0 59
74691: PUSH
74692: LD_INT 0
74694: PUSH
74695: LD_INT 0
74697: PUSH
74698: EMPTY
74699: LIST
74700: LIST
74701: PUSH
74702: LD_INT 0
74704: PUSH
74705: LD_INT 1
74707: NEG
74708: PUSH
74709: EMPTY
74710: LIST
74711: LIST
74712: PUSH
74713: LD_INT 1
74715: PUSH
74716: LD_INT 0
74718: PUSH
74719: EMPTY
74720: LIST
74721: LIST
74722: PUSH
74723: LD_INT 1
74725: PUSH
74726: LD_INT 1
74728: PUSH
74729: EMPTY
74730: LIST
74731: LIST
74732: PUSH
74733: LD_INT 0
74735: PUSH
74736: LD_INT 1
74738: PUSH
74739: EMPTY
74740: LIST
74741: LIST
74742: PUSH
74743: LD_INT 1
74745: NEG
74746: PUSH
74747: LD_INT 0
74749: PUSH
74750: EMPTY
74751: LIST
74752: LIST
74753: PUSH
74754: LD_INT 1
74756: NEG
74757: PUSH
74758: LD_INT 1
74760: NEG
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: PUSH
74766: EMPTY
74767: LIST
74768: LIST
74769: LIST
74770: LIST
74771: LIST
74772: LIST
74773: LIST
74774: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74775: LD_ADDR_VAR 0 60
74779: PUSH
74780: LD_INT 0
74782: PUSH
74783: LD_INT 0
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: LD_INT 0
74792: PUSH
74793: LD_INT 1
74795: NEG
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PUSH
74801: LD_INT 1
74803: PUSH
74804: LD_INT 0
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 1
74813: PUSH
74814: LD_INT 1
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: LD_INT 1
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: LD_INT 1
74833: NEG
74834: PUSH
74835: LD_INT 0
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 1
74844: NEG
74845: PUSH
74846: LD_INT 1
74848: NEG
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: PUSH
74854: EMPTY
74855: LIST
74856: LIST
74857: LIST
74858: LIST
74859: LIST
74860: LIST
74861: LIST
74862: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74863: LD_ADDR_VAR 0 61
74867: PUSH
74868: LD_INT 0
74870: PUSH
74871: LD_INT 0
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: PUSH
74878: LD_INT 0
74880: PUSH
74881: LD_INT 1
74883: NEG
74884: PUSH
74885: EMPTY
74886: LIST
74887: LIST
74888: PUSH
74889: LD_INT 1
74891: PUSH
74892: LD_INT 0
74894: PUSH
74895: EMPTY
74896: LIST
74897: LIST
74898: PUSH
74899: LD_INT 1
74901: PUSH
74902: LD_INT 1
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PUSH
74909: LD_INT 0
74911: PUSH
74912: LD_INT 1
74914: PUSH
74915: EMPTY
74916: LIST
74917: LIST
74918: PUSH
74919: LD_INT 1
74921: NEG
74922: PUSH
74923: LD_INT 0
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: PUSH
74930: LD_INT 1
74932: NEG
74933: PUSH
74934: LD_INT 1
74936: NEG
74937: PUSH
74938: EMPTY
74939: LIST
74940: LIST
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: LIST
74946: LIST
74947: LIST
74948: LIST
74949: LIST
74950: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74951: LD_ADDR_VAR 0 62
74955: PUSH
74956: LD_INT 0
74958: PUSH
74959: LD_INT 0
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: LD_INT 0
74968: PUSH
74969: LD_INT 1
74971: NEG
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: LD_INT 1
74979: PUSH
74980: LD_INT 0
74982: PUSH
74983: EMPTY
74984: LIST
74985: LIST
74986: PUSH
74987: LD_INT 1
74989: PUSH
74990: LD_INT 1
74992: PUSH
74993: EMPTY
74994: LIST
74995: LIST
74996: PUSH
74997: LD_INT 0
74999: PUSH
75000: LD_INT 1
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 1
75009: NEG
75010: PUSH
75011: LD_INT 0
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: PUSH
75018: LD_INT 1
75020: NEG
75021: PUSH
75022: LD_INT 1
75024: NEG
75025: PUSH
75026: EMPTY
75027: LIST
75028: LIST
75029: PUSH
75030: EMPTY
75031: LIST
75032: LIST
75033: LIST
75034: LIST
75035: LIST
75036: LIST
75037: LIST
75038: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75039: LD_ADDR_VAR 0 63
75043: PUSH
75044: LD_INT 0
75046: PUSH
75047: LD_INT 0
75049: PUSH
75050: EMPTY
75051: LIST
75052: LIST
75053: PUSH
75054: LD_INT 0
75056: PUSH
75057: LD_INT 1
75059: NEG
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: PUSH
75065: LD_INT 1
75067: PUSH
75068: LD_INT 0
75070: PUSH
75071: EMPTY
75072: LIST
75073: LIST
75074: PUSH
75075: LD_INT 1
75077: PUSH
75078: LD_INT 1
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: PUSH
75085: LD_INT 0
75087: PUSH
75088: LD_INT 1
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: PUSH
75095: LD_INT 1
75097: NEG
75098: PUSH
75099: LD_INT 0
75101: PUSH
75102: EMPTY
75103: LIST
75104: LIST
75105: PUSH
75106: LD_INT 1
75108: NEG
75109: PUSH
75110: LD_INT 1
75112: NEG
75113: PUSH
75114: EMPTY
75115: LIST
75116: LIST
75117: PUSH
75118: EMPTY
75119: LIST
75120: LIST
75121: LIST
75122: LIST
75123: LIST
75124: LIST
75125: LIST
75126: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75127: LD_ADDR_VAR 0 64
75131: PUSH
75132: LD_INT 0
75134: PUSH
75135: LD_INT 0
75137: PUSH
75138: EMPTY
75139: LIST
75140: LIST
75141: PUSH
75142: LD_INT 0
75144: PUSH
75145: LD_INT 1
75147: NEG
75148: PUSH
75149: EMPTY
75150: LIST
75151: LIST
75152: PUSH
75153: LD_INT 1
75155: PUSH
75156: LD_INT 0
75158: PUSH
75159: EMPTY
75160: LIST
75161: LIST
75162: PUSH
75163: LD_INT 1
75165: PUSH
75166: LD_INT 1
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: PUSH
75173: LD_INT 0
75175: PUSH
75176: LD_INT 1
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: PUSH
75183: LD_INT 1
75185: NEG
75186: PUSH
75187: LD_INT 0
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PUSH
75194: LD_INT 1
75196: NEG
75197: PUSH
75198: LD_INT 1
75200: NEG
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: LIST
75210: LIST
75211: LIST
75212: LIST
75213: LIST
75214: ST_TO_ADDR
// end ; 1 :
75215: GO 81112
75217: LD_INT 1
75219: DOUBLE
75220: EQUAL
75221: IFTRUE 75225
75223: GO 77848
75225: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75226: LD_ADDR_VAR 0 11
75230: PUSH
75231: LD_INT 1
75233: NEG
75234: PUSH
75235: LD_INT 3
75237: NEG
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: LD_INT 0
75245: PUSH
75246: LD_INT 3
75248: NEG
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 1
75256: PUSH
75257: LD_INT 2
75259: NEG
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PUSH
75265: EMPTY
75266: LIST
75267: LIST
75268: LIST
75269: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75270: LD_ADDR_VAR 0 12
75274: PUSH
75275: LD_INT 2
75277: PUSH
75278: LD_INT 1
75280: NEG
75281: PUSH
75282: EMPTY
75283: LIST
75284: LIST
75285: PUSH
75286: LD_INT 3
75288: PUSH
75289: LD_INT 0
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: PUSH
75296: LD_INT 3
75298: PUSH
75299: LD_INT 1
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: LIST
75310: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75311: LD_ADDR_VAR 0 13
75315: PUSH
75316: LD_INT 3
75318: PUSH
75319: LD_INT 2
75321: PUSH
75322: EMPTY
75323: LIST
75324: LIST
75325: PUSH
75326: LD_INT 3
75328: PUSH
75329: LD_INT 3
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 2
75338: PUSH
75339: LD_INT 3
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: LIST
75350: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75351: LD_ADDR_VAR 0 14
75355: PUSH
75356: LD_INT 1
75358: PUSH
75359: LD_INT 3
75361: PUSH
75362: EMPTY
75363: LIST
75364: LIST
75365: PUSH
75366: LD_INT 0
75368: PUSH
75369: LD_INT 3
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 1
75378: NEG
75379: PUSH
75380: LD_INT 2
75382: PUSH
75383: EMPTY
75384: LIST
75385: LIST
75386: PUSH
75387: EMPTY
75388: LIST
75389: LIST
75390: LIST
75391: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75392: LD_ADDR_VAR 0 15
75396: PUSH
75397: LD_INT 2
75399: NEG
75400: PUSH
75401: LD_INT 1
75403: PUSH
75404: EMPTY
75405: LIST
75406: LIST
75407: PUSH
75408: LD_INT 3
75410: NEG
75411: PUSH
75412: LD_INT 0
75414: PUSH
75415: EMPTY
75416: LIST
75417: LIST
75418: PUSH
75419: LD_INT 3
75421: NEG
75422: PUSH
75423: LD_INT 1
75425: NEG
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: EMPTY
75432: LIST
75433: LIST
75434: LIST
75435: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75436: LD_ADDR_VAR 0 16
75440: PUSH
75441: LD_INT 2
75443: NEG
75444: PUSH
75445: LD_INT 3
75447: NEG
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 3
75455: NEG
75456: PUSH
75457: LD_INT 2
75459: NEG
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: PUSH
75465: LD_INT 3
75467: NEG
75468: PUSH
75469: LD_INT 3
75471: NEG
75472: PUSH
75473: EMPTY
75474: LIST
75475: LIST
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: LIST
75481: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75482: LD_ADDR_VAR 0 17
75486: PUSH
75487: LD_INT 1
75489: NEG
75490: PUSH
75491: LD_INT 3
75493: NEG
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 0
75501: PUSH
75502: LD_INT 3
75504: NEG
75505: PUSH
75506: EMPTY
75507: LIST
75508: LIST
75509: PUSH
75510: LD_INT 1
75512: PUSH
75513: LD_INT 2
75515: NEG
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PUSH
75521: EMPTY
75522: LIST
75523: LIST
75524: LIST
75525: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75526: LD_ADDR_VAR 0 18
75530: PUSH
75531: LD_INT 2
75533: PUSH
75534: LD_INT 1
75536: NEG
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PUSH
75542: LD_INT 3
75544: PUSH
75545: LD_INT 0
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 3
75554: PUSH
75555: LD_INT 1
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: PUSH
75562: EMPTY
75563: LIST
75564: LIST
75565: LIST
75566: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75567: LD_ADDR_VAR 0 19
75571: PUSH
75572: LD_INT 3
75574: PUSH
75575: LD_INT 2
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PUSH
75582: LD_INT 3
75584: PUSH
75585: LD_INT 3
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: PUSH
75592: LD_INT 2
75594: PUSH
75595: LD_INT 3
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: PUSH
75602: EMPTY
75603: LIST
75604: LIST
75605: LIST
75606: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75607: LD_ADDR_VAR 0 20
75611: PUSH
75612: LD_INT 1
75614: PUSH
75615: LD_INT 3
75617: PUSH
75618: EMPTY
75619: LIST
75620: LIST
75621: PUSH
75622: LD_INT 0
75624: PUSH
75625: LD_INT 3
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: PUSH
75632: LD_INT 1
75634: NEG
75635: PUSH
75636: LD_INT 2
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: EMPTY
75644: LIST
75645: LIST
75646: LIST
75647: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75648: LD_ADDR_VAR 0 21
75652: PUSH
75653: LD_INT 2
75655: NEG
75656: PUSH
75657: LD_INT 1
75659: PUSH
75660: EMPTY
75661: LIST
75662: LIST
75663: PUSH
75664: LD_INT 3
75666: NEG
75667: PUSH
75668: LD_INT 0
75670: PUSH
75671: EMPTY
75672: LIST
75673: LIST
75674: PUSH
75675: LD_INT 3
75677: NEG
75678: PUSH
75679: LD_INT 1
75681: NEG
75682: PUSH
75683: EMPTY
75684: LIST
75685: LIST
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: LIST
75691: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75692: LD_ADDR_VAR 0 22
75696: PUSH
75697: LD_INT 2
75699: NEG
75700: PUSH
75701: LD_INT 3
75703: NEG
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: PUSH
75709: LD_INT 3
75711: NEG
75712: PUSH
75713: LD_INT 2
75715: NEG
75716: PUSH
75717: EMPTY
75718: LIST
75719: LIST
75720: PUSH
75721: LD_INT 3
75723: NEG
75724: PUSH
75725: LD_INT 3
75727: NEG
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: LIST
75737: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75738: LD_ADDR_VAR 0 23
75742: PUSH
75743: LD_INT 0
75745: PUSH
75746: LD_INT 3
75748: NEG
75749: PUSH
75750: EMPTY
75751: LIST
75752: LIST
75753: PUSH
75754: LD_INT 1
75756: NEG
75757: PUSH
75758: LD_INT 4
75760: NEG
75761: PUSH
75762: EMPTY
75763: LIST
75764: LIST
75765: PUSH
75766: LD_INT 1
75768: PUSH
75769: LD_INT 3
75771: NEG
75772: PUSH
75773: EMPTY
75774: LIST
75775: LIST
75776: PUSH
75777: EMPTY
75778: LIST
75779: LIST
75780: LIST
75781: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75782: LD_ADDR_VAR 0 24
75786: PUSH
75787: LD_INT 3
75789: PUSH
75790: LD_INT 0
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: PUSH
75797: LD_INT 3
75799: PUSH
75800: LD_INT 1
75802: NEG
75803: PUSH
75804: EMPTY
75805: LIST
75806: LIST
75807: PUSH
75808: LD_INT 4
75810: PUSH
75811: LD_INT 1
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: LIST
75822: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75823: LD_ADDR_VAR 0 25
75827: PUSH
75828: LD_INT 3
75830: PUSH
75831: LD_INT 3
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: PUSH
75838: LD_INT 4
75840: PUSH
75841: LD_INT 3
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: LD_INT 3
75850: PUSH
75851: LD_INT 4
75853: PUSH
75854: EMPTY
75855: LIST
75856: LIST
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: LIST
75862: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75863: LD_ADDR_VAR 0 26
75867: PUSH
75868: LD_INT 0
75870: PUSH
75871: LD_INT 3
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: PUSH
75878: LD_INT 1
75880: PUSH
75881: LD_INT 4
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: LD_INT 1
75890: NEG
75891: PUSH
75892: LD_INT 3
75894: PUSH
75895: EMPTY
75896: LIST
75897: LIST
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: LIST
75903: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75904: LD_ADDR_VAR 0 27
75908: PUSH
75909: LD_INT 3
75911: NEG
75912: PUSH
75913: LD_INT 0
75915: PUSH
75916: EMPTY
75917: LIST
75918: LIST
75919: PUSH
75920: LD_INT 3
75922: NEG
75923: PUSH
75924: LD_INT 1
75926: PUSH
75927: EMPTY
75928: LIST
75929: LIST
75930: PUSH
75931: LD_INT 4
75933: NEG
75934: PUSH
75935: LD_INT 1
75937: NEG
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: LIST
75947: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75948: LD_ADDR_VAR 0 28
75952: PUSH
75953: LD_INT 3
75955: NEG
75956: PUSH
75957: LD_INT 3
75959: NEG
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 3
75967: NEG
75968: PUSH
75969: LD_INT 4
75971: NEG
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 4
75979: NEG
75980: PUSH
75981: LD_INT 3
75983: NEG
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: PUSH
75989: EMPTY
75990: LIST
75991: LIST
75992: LIST
75993: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75994: LD_ADDR_VAR 0 29
75998: PUSH
75999: LD_INT 1
76001: NEG
76002: PUSH
76003: LD_INT 3
76005: NEG
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: PUSH
76011: LD_INT 0
76013: PUSH
76014: LD_INT 3
76016: NEG
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: LD_INT 1
76024: PUSH
76025: LD_INT 2
76027: NEG
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 1
76035: NEG
76036: PUSH
76037: LD_INT 4
76039: NEG
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PUSH
76045: LD_INT 0
76047: PUSH
76048: LD_INT 4
76050: NEG
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PUSH
76056: LD_INT 1
76058: PUSH
76059: LD_INT 3
76061: NEG
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: PUSH
76067: LD_INT 1
76069: NEG
76070: PUSH
76071: LD_INT 5
76073: NEG
76074: PUSH
76075: EMPTY
76076: LIST
76077: LIST
76078: PUSH
76079: LD_INT 0
76081: PUSH
76082: LD_INT 5
76084: NEG
76085: PUSH
76086: EMPTY
76087: LIST
76088: LIST
76089: PUSH
76090: LD_INT 1
76092: PUSH
76093: LD_INT 4
76095: NEG
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PUSH
76101: LD_INT 1
76103: NEG
76104: PUSH
76105: LD_INT 6
76107: NEG
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 0
76115: PUSH
76116: LD_INT 6
76118: NEG
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: LD_INT 1
76126: PUSH
76127: LD_INT 5
76129: NEG
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: EMPTY
76136: LIST
76137: LIST
76138: LIST
76139: LIST
76140: LIST
76141: LIST
76142: LIST
76143: LIST
76144: LIST
76145: LIST
76146: LIST
76147: LIST
76148: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76149: LD_ADDR_VAR 0 30
76153: PUSH
76154: LD_INT 2
76156: PUSH
76157: LD_INT 1
76159: NEG
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: LD_INT 3
76167: PUSH
76168: LD_INT 0
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: LD_INT 3
76177: PUSH
76178: LD_INT 1
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: PUSH
76185: LD_INT 3
76187: PUSH
76188: LD_INT 1
76190: NEG
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: PUSH
76196: LD_INT 4
76198: PUSH
76199: LD_INT 0
76201: PUSH
76202: EMPTY
76203: LIST
76204: LIST
76205: PUSH
76206: LD_INT 4
76208: PUSH
76209: LD_INT 1
76211: PUSH
76212: EMPTY
76213: LIST
76214: LIST
76215: PUSH
76216: LD_INT 4
76218: PUSH
76219: LD_INT 1
76221: NEG
76222: PUSH
76223: EMPTY
76224: LIST
76225: LIST
76226: PUSH
76227: LD_INT 5
76229: PUSH
76230: LD_INT 0
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: LD_INT 5
76239: PUSH
76240: LD_INT 1
76242: PUSH
76243: EMPTY
76244: LIST
76245: LIST
76246: PUSH
76247: LD_INT 5
76249: PUSH
76250: LD_INT 1
76252: NEG
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: PUSH
76258: LD_INT 6
76260: PUSH
76261: LD_INT 0
76263: PUSH
76264: EMPTY
76265: LIST
76266: LIST
76267: PUSH
76268: LD_INT 6
76270: PUSH
76271: LD_INT 1
76273: PUSH
76274: EMPTY
76275: LIST
76276: LIST
76277: PUSH
76278: EMPTY
76279: LIST
76280: LIST
76281: LIST
76282: LIST
76283: LIST
76284: LIST
76285: LIST
76286: LIST
76287: LIST
76288: LIST
76289: LIST
76290: LIST
76291: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76292: LD_ADDR_VAR 0 31
76296: PUSH
76297: LD_INT 3
76299: PUSH
76300: LD_INT 2
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: PUSH
76307: LD_INT 3
76309: PUSH
76310: LD_INT 3
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: PUSH
76317: LD_INT 2
76319: PUSH
76320: LD_INT 3
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PUSH
76327: LD_INT 4
76329: PUSH
76330: LD_INT 3
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 4
76339: PUSH
76340: LD_INT 4
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: LD_INT 3
76349: PUSH
76350: LD_INT 4
76352: PUSH
76353: EMPTY
76354: LIST
76355: LIST
76356: PUSH
76357: LD_INT 5
76359: PUSH
76360: LD_INT 4
76362: PUSH
76363: EMPTY
76364: LIST
76365: LIST
76366: PUSH
76367: LD_INT 5
76369: PUSH
76370: LD_INT 5
76372: PUSH
76373: EMPTY
76374: LIST
76375: LIST
76376: PUSH
76377: LD_INT 4
76379: PUSH
76380: LD_INT 5
76382: PUSH
76383: EMPTY
76384: LIST
76385: LIST
76386: PUSH
76387: LD_INT 6
76389: PUSH
76390: LD_INT 5
76392: PUSH
76393: EMPTY
76394: LIST
76395: LIST
76396: PUSH
76397: LD_INT 6
76399: PUSH
76400: LD_INT 6
76402: PUSH
76403: EMPTY
76404: LIST
76405: LIST
76406: PUSH
76407: LD_INT 5
76409: PUSH
76410: LD_INT 6
76412: PUSH
76413: EMPTY
76414: LIST
76415: LIST
76416: PUSH
76417: EMPTY
76418: LIST
76419: LIST
76420: LIST
76421: LIST
76422: LIST
76423: LIST
76424: LIST
76425: LIST
76426: LIST
76427: LIST
76428: LIST
76429: LIST
76430: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76431: LD_ADDR_VAR 0 32
76435: PUSH
76436: LD_INT 1
76438: PUSH
76439: LD_INT 3
76441: PUSH
76442: EMPTY
76443: LIST
76444: LIST
76445: PUSH
76446: LD_INT 0
76448: PUSH
76449: LD_INT 3
76451: PUSH
76452: EMPTY
76453: LIST
76454: LIST
76455: PUSH
76456: LD_INT 1
76458: NEG
76459: PUSH
76460: LD_INT 2
76462: PUSH
76463: EMPTY
76464: LIST
76465: LIST
76466: PUSH
76467: LD_INT 1
76469: PUSH
76470: LD_INT 4
76472: PUSH
76473: EMPTY
76474: LIST
76475: LIST
76476: PUSH
76477: LD_INT 0
76479: PUSH
76480: LD_INT 4
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: PUSH
76487: LD_INT 1
76489: NEG
76490: PUSH
76491: LD_INT 3
76493: PUSH
76494: EMPTY
76495: LIST
76496: LIST
76497: PUSH
76498: LD_INT 1
76500: PUSH
76501: LD_INT 5
76503: PUSH
76504: EMPTY
76505: LIST
76506: LIST
76507: PUSH
76508: LD_INT 0
76510: PUSH
76511: LD_INT 5
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: LD_INT 1
76520: NEG
76521: PUSH
76522: LD_INT 4
76524: PUSH
76525: EMPTY
76526: LIST
76527: LIST
76528: PUSH
76529: LD_INT 1
76531: PUSH
76532: LD_INT 6
76534: PUSH
76535: EMPTY
76536: LIST
76537: LIST
76538: PUSH
76539: LD_INT 0
76541: PUSH
76542: LD_INT 6
76544: PUSH
76545: EMPTY
76546: LIST
76547: LIST
76548: PUSH
76549: LD_INT 1
76551: NEG
76552: PUSH
76553: LD_INT 5
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: LIST
76564: LIST
76565: LIST
76566: LIST
76567: LIST
76568: LIST
76569: LIST
76570: LIST
76571: LIST
76572: LIST
76573: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
76574: LD_ADDR_VAR 0 33
76578: PUSH
76579: LD_INT 2
76581: NEG
76582: PUSH
76583: LD_INT 1
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: LD_INT 3
76592: NEG
76593: PUSH
76594: LD_INT 0
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: LD_INT 3
76603: NEG
76604: PUSH
76605: LD_INT 1
76607: NEG
76608: PUSH
76609: EMPTY
76610: LIST
76611: LIST
76612: PUSH
76613: LD_INT 3
76615: NEG
76616: PUSH
76617: LD_INT 1
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: PUSH
76624: LD_INT 4
76626: NEG
76627: PUSH
76628: LD_INT 0
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 4
76637: NEG
76638: PUSH
76639: LD_INT 1
76641: NEG
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: PUSH
76647: LD_INT 4
76649: NEG
76650: PUSH
76651: LD_INT 1
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: PUSH
76658: LD_INT 5
76660: NEG
76661: PUSH
76662: LD_INT 0
76664: PUSH
76665: EMPTY
76666: LIST
76667: LIST
76668: PUSH
76669: LD_INT 5
76671: NEG
76672: PUSH
76673: LD_INT 1
76675: NEG
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: PUSH
76681: LD_INT 5
76683: NEG
76684: PUSH
76685: LD_INT 1
76687: PUSH
76688: EMPTY
76689: LIST
76690: LIST
76691: PUSH
76692: LD_INT 6
76694: NEG
76695: PUSH
76696: LD_INT 0
76698: PUSH
76699: EMPTY
76700: LIST
76701: LIST
76702: PUSH
76703: LD_INT 6
76705: NEG
76706: PUSH
76707: LD_INT 1
76709: NEG
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: LIST
76719: LIST
76720: LIST
76721: LIST
76722: LIST
76723: LIST
76724: LIST
76725: LIST
76726: LIST
76727: LIST
76728: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76729: LD_ADDR_VAR 0 34
76733: PUSH
76734: LD_INT 2
76736: NEG
76737: PUSH
76738: LD_INT 3
76740: NEG
76741: PUSH
76742: EMPTY
76743: LIST
76744: LIST
76745: PUSH
76746: LD_INT 3
76748: NEG
76749: PUSH
76750: LD_INT 2
76752: NEG
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PUSH
76758: LD_INT 3
76760: NEG
76761: PUSH
76762: LD_INT 3
76764: NEG
76765: PUSH
76766: EMPTY
76767: LIST
76768: LIST
76769: PUSH
76770: LD_INT 3
76772: NEG
76773: PUSH
76774: LD_INT 4
76776: NEG
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: PUSH
76782: LD_INT 4
76784: NEG
76785: PUSH
76786: LD_INT 3
76788: NEG
76789: PUSH
76790: EMPTY
76791: LIST
76792: LIST
76793: PUSH
76794: LD_INT 4
76796: NEG
76797: PUSH
76798: LD_INT 4
76800: NEG
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: LD_INT 4
76808: NEG
76809: PUSH
76810: LD_INT 5
76812: NEG
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: LD_INT 5
76820: NEG
76821: PUSH
76822: LD_INT 4
76824: NEG
76825: PUSH
76826: EMPTY
76827: LIST
76828: LIST
76829: PUSH
76830: LD_INT 5
76832: NEG
76833: PUSH
76834: LD_INT 5
76836: NEG
76837: PUSH
76838: EMPTY
76839: LIST
76840: LIST
76841: PUSH
76842: LD_INT 5
76844: NEG
76845: PUSH
76846: LD_INT 6
76848: NEG
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PUSH
76854: LD_INT 6
76856: NEG
76857: PUSH
76858: LD_INT 5
76860: NEG
76861: PUSH
76862: EMPTY
76863: LIST
76864: LIST
76865: PUSH
76866: LD_INT 6
76868: NEG
76869: PUSH
76870: LD_INT 6
76872: NEG
76873: PUSH
76874: EMPTY
76875: LIST
76876: LIST
76877: PUSH
76878: EMPTY
76879: LIST
76880: LIST
76881: LIST
76882: LIST
76883: LIST
76884: LIST
76885: LIST
76886: LIST
76887: LIST
76888: LIST
76889: LIST
76890: LIST
76891: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76892: LD_ADDR_VAR 0 41
76896: PUSH
76897: LD_INT 0
76899: PUSH
76900: LD_INT 2
76902: NEG
76903: PUSH
76904: EMPTY
76905: LIST
76906: LIST
76907: PUSH
76908: LD_INT 1
76910: NEG
76911: PUSH
76912: LD_INT 3
76914: NEG
76915: PUSH
76916: EMPTY
76917: LIST
76918: LIST
76919: PUSH
76920: LD_INT 1
76922: PUSH
76923: LD_INT 2
76925: NEG
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: LIST
76935: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76936: LD_ADDR_VAR 0 42
76940: PUSH
76941: LD_INT 2
76943: PUSH
76944: LD_INT 0
76946: PUSH
76947: EMPTY
76948: LIST
76949: LIST
76950: PUSH
76951: LD_INT 2
76953: PUSH
76954: LD_INT 1
76956: NEG
76957: PUSH
76958: EMPTY
76959: LIST
76960: LIST
76961: PUSH
76962: LD_INT 3
76964: PUSH
76965: LD_INT 1
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: LIST
76976: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76977: LD_ADDR_VAR 0 43
76981: PUSH
76982: LD_INT 2
76984: PUSH
76985: LD_INT 2
76987: PUSH
76988: EMPTY
76989: LIST
76990: LIST
76991: PUSH
76992: LD_INT 3
76994: PUSH
76995: LD_INT 2
76997: PUSH
76998: EMPTY
76999: LIST
77000: LIST
77001: PUSH
77002: LD_INT 2
77004: PUSH
77005: LD_INT 3
77007: PUSH
77008: EMPTY
77009: LIST
77010: LIST
77011: PUSH
77012: EMPTY
77013: LIST
77014: LIST
77015: LIST
77016: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77017: LD_ADDR_VAR 0 44
77021: PUSH
77022: LD_INT 0
77024: PUSH
77025: LD_INT 2
77027: PUSH
77028: EMPTY
77029: LIST
77030: LIST
77031: PUSH
77032: LD_INT 1
77034: PUSH
77035: LD_INT 3
77037: PUSH
77038: EMPTY
77039: LIST
77040: LIST
77041: PUSH
77042: LD_INT 1
77044: NEG
77045: PUSH
77046: LD_INT 2
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PUSH
77053: EMPTY
77054: LIST
77055: LIST
77056: LIST
77057: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77058: LD_ADDR_VAR 0 45
77062: PUSH
77063: LD_INT 2
77065: NEG
77066: PUSH
77067: LD_INT 0
77069: PUSH
77070: EMPTY
77071: LIST
77072: LIST
77073: PUSH
77074: LD_INT 2
77076: NEG
77077: PUSH
77078: LD_INT 1
77080: PUSH
77081: EMPTY
77082: LIST
77083: LIST
77084: PUSH
77085: LD_INT 3
77087: NEG
77088: PUSH
77089: LD_INT 1
77091: NEG
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: LIST
77101: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77102: LD_ADDR_VAR 0 46
77106: PUSH
77107: LD_INT 2
77109: NEG
77110: PUSH
77111: LD_INT 2
77113: NEG
77114: PUSH
77115: EMPTY
77116: LIST
77117: LIST
77118: PUSH
77119: LD_INT 2
77121: NEG
77122: PUSH
77123: LD_INT 3
77125: NEG
77126: PUSH
77127: EMPTY
77128: LIST
77129: LIST
77130: PUSH
77131: LD_INT 3
77133: NEG
77134: PUSH
77135: LD_INT 2
77137: NEG
77138: PUSH
77139: EMPTY
77140: LIST
77141: LIST
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: LIST
77147: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77148: LD_ADDR_VAR 0 47
77152: PUSH
77153: LD_INT 2
77155: NEG
77156: PUSH
77157: LD_INT 3
77159: NEG
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: PUSH
77165: LD_INT 1
77167: NEG
77168: PUSH
77169: LD_INT 3
77171: NEG
77172: PUSH
77173: EMPTY
77174: LIST
77175: LIST
77176: PUSH
77177: EMPTY
77178: LIST
77179: LIST
77180: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77181: LD_ADDR_VAR 0 48
77185: PUSH
77186: LD_INT 1
77188: PUSH
77189: LD_INT 2
77191: NEG
77192: PUSH
77193: EMPTY
77194: LIST
77195: LIST
77196: PUSH
77197: LD_INT 2
77199: PUSH
77200: LD_INT 1
77202: NEG
77203: PUSH
77204: EMPTY
77205: LIST
77206: LIST
77207: PUSH
77208: EMPTY
77209: LIST
77210: LIST
77211: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77212: LD_ADDR_VAR 0 49
77216: PUSH
77217: LD_INT 3
77219: PUSH
77220: LD_INT 1
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: PUSH
77227: LD_INT 3
77229: PUSH
77230: LD_INT 2
77232: PUSH
77233: EMPTY
77234: LIST
77235: LIST
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77241: LD_ADDR_VAR 0 50
77245: PUSH
77246: LD_INT 2
77248: PUSH
77249: LD_INT 3
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 1
77258: PUSH
77259: LD_INT 3
77261: PUSH
77262: EMPTY
77263: LIST
77264: LIST
77265: PUSH
77266: EMPTY
77267: LIST
77268: LIST
77269: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77270: LD_ADDR_VAR 0 51
77274: PUSH
77275: LD_INT 1
77277: NEG
77278: PUSH
77279: LD_INT 2
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 2
77288: NEG
77289: PUSH
77290: LD_INT 1
77292: PUSH
77293: EMPTY
77294: LIST
77295: LIST
77296: PUSH
77297: EMPTY
77298: LIST
77299: LIST
77300: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77301: LD_ADDR_VAR 0 52
77305: PUSH
77306: LD_INT 3
77308: NEG
77309: PUSH
77310: LD_INT 1
77312: NEG
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 3
77320: NEG
77321: PUSH
77322: LD_INT 2
77324: NEG
77325: PUSH
77326: EMPTY
77327: LIST
77328: LIST
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77334: LD_ADDR_VAR 0 53
77338: PUSH
77339: LD_INT 1
77341: NEG
77342: PUSH
77343: LD_INT 3
77345: NEG
77346: PUSH
77347: EMPTY
77348: LIST
77349: LIST
77350: PUSH
77351: LD_INT 0
77353: PUSH
77354: LD_INT 3
77356: NEG
77357: PUSH
77358: EMPTY
77359: LIST
77360: LIST
77361: PUSH
77362: LD_INT 1
77364: PUSH
77365: LD_INT 2
77367: NEG
77368: PUSH
77369: EMPTY
77370: LIST
77371: LIST
77372: PUSH
77373: EMPTY
77374: LIST
77375: LIST
77376: LIST
77377: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77378: LD_ADDR_VAR 0 54
77382: PUSH
77383: LD_INT 2
77385: PUSH
77386: LD_INT 1
77388: NEG
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: LD_INT 3
77396: PUSH
77397: LD_INT 0
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: PUSH
77404: LD_INT 3
77406: PUSH
77407: LD_INT 1
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: LIST
77418: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77419: LD_ADDR_VAR 0 55
77423: PUSH
77424: LD_INT 3
77426: PUSH
77427: LD_INT 2
77429: PUSH
77430: EMPTY
77431: LIST
77432: LIST
77433: PUSH
77434: LD_INT 3
77436: PUSH
77437: LD_INT 3
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: PUSH
77444: LD_INT 2
77446: PUSH
77447: LD_INT 3
77449: PUSH
77450: EMPTY
77451: LIST
77452: LIST
77453: PUSH
77454: EMPTY
77455: LIST
77456: LIST
77457: LIST
77458: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77459: LD_ADDR_VAR 0 56
77463: PUSH
77464: LD_INT 1
77466: PUSH
77467: LD_INT 3
77469: PUSH
77470: EMPTY
77471: LIST
77472: LIST
77473: PUSH
77474: LD_INT 0
77476: PUSH
77477: LD_INT 3
77479: PUSH
77480: EMPTY
77481: LIST
77482: LIST
77483: PUSH
77484: LD_INT 1
77486: NEG
77487: PUSH
77488: LD_INT 2
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: LIST
77499: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77500: LD_ADDR_VAR 0 57
77504: PUSH
77505: LD_INT 2
77507: NEG
77508: PUSH
77509: LD_INT 1
77511: PUSH
77512: EMPTY
77513: LIST
77514: LIST
77515: PUSH
77516: LD_INT 3
77518: NEG
77519: PUSH
77520: LD_INT 0
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: PUSH
77527: LD_INT 3
77529: NEG
77530: PUSH
77531: LD_INT 1
77533: NEG
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: PUSH
77539: EMPTY
77540: LIST
77541: LIST
77542: LIST
77543: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77544: LD_ADDR_VAR 0 58
77548: PUSH
77549: LD_INT 2
77551: NEG
77552: PUSH
77553: LD_INT 3
77555: NEG
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PUSH
77561: LD_INT 3
77563: NEG
77564: PUSH
77565: LD_INT 2
77567: NEG
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: PUSH
77573: LD_INT 3
77575: NEG
77576: PUSH
77577: LD_INT 3
77579: NEG
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: LIST
77589: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
77590: LD_ADDR_VAR 0 59
77594: PUSH
77595: LD_INT 1
77597: NEG
77598: PUSH
77599: LD_INT 2
77601: NEG
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: PUSH
77607: LD_INT 0
77609: PUSH
77610: LD_INT 2
77612: NEG
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: PUSH
77618: LD_INT 1
77620: PUSH
77621: LD_INT 1
77623: NEG
77624: PUSH
77625: EMPTY
77626: LIST
77627: LIST
77628: PUSH
77629: EMPTY
77630: LIST
77631: LIST
77632: LIST
77633: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77634: LD_ADDR_VAR 0 60
77638: PUSH
77639: LD_INT 1
77641: PUSH
77642: LD_INT 1
77644: NEG
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: PUSH
77650: LD_INT 2
77652: PUSH
77653: LD_INT 0
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: LD_INT 2
77662: PUSH
77663: LD_INT 1
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: PUSH
77670: EMPTY
77671: LIST
77672: LIST
77673: LIST
77674: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77675: LD_ADDR_VAR 0 61
77679: PUSH
77680: LD_INT 2
77682: PUSH
77683: LD_INT 1
77685: PUSH
77686: EMPTY
77687: LIST
77688: LIST
77689: PUSH
77690: LD_INT 2
77692: PUSH
77693: LD_INT 2
77695: PUSH
77696: EMPTY
77697: LIST
77698: LIST
77699: PUSH
77700: LD_INT 1
77702: PUSH
77703: LD_INT 2
77705: PUSH
77706: EMPTY
77707: LIST
77708: LIST
77709: PUSH
77710: EMPTY
77711: LIST
77712: LIST
77713: LIST
77714: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77715: LD_ADDR_VAR 0 62
77719: PUSH
77720: LD_INT 1
77722: PUSH
77723: LD_INT 2
77725: PUSH
77726: EMPTY
77727: LIST
77728: LIST
77729: PUSH
77730: LD_INT 0
77732: PUSH
77733: LD_INT 2
77735: PUSH
77736: EMPTY
77737: LIST
77738: LIST
77739: PUSH
77740: LD_INT 1
77742: NEG
77743: PUSH
77744: LD_INT 1
77746: PUSH
77747: EMPTY
77748: LIST
77749: LIST
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: LIST
77755: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77756: LD_ADDR_VAR 0 63
77760: PUSH
77761: LD_INT 1
77763: NEG
77764: PUSH
77765: LD_INT 1
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: PUSH
77772: LD_INT 2
77774: NEG
77775: PUSH
77776: LD_INT 0
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: PUSH
77783: LD_INT 2
77785: NEG
77786: PUSH
77787: LD_INT 1
77789: NEG
77790: PUSH
77791: EMPTY
77792: LIST
77793: LIST
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: LIST
77799: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77800: LD_ADDR_VAR 0 64
77804: PUSH
77805: LD_INT 1
77807: NEG
77808: PUSH
77809: LD_INT 2
77811: NEG
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 2
77819: NEG
77820: PUSH
77821: LD_INT 1
77823: NEG
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: PUSH
77829: LD_INT 2
77831: NEG
77832: PUSH
77833: LD_INT 2
77835: NEG
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: LIST
77845: ST_TO_ADDR
// end ; 2 :
77846: GO 81112
77848: LD_INT 2
77850: DOUBLE
77851: EQUAL
77852: IFTRUE 77856
77854: GO 81111
77856: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77857: LD_ADDR_VAR 0 29
77861: PUSH
77862: LD_INT 4
77864: PUSH
77865: LD_INT 0
77867: PUSH
77868: EMPTY
77869: LIST
77870: LIST
77871: PUSH
77872: LD_INT 4
77874: PUSH
77875: LD_INT 1
77877: NEG
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PUSH
77883: LD_INT 5
77885: PUSH
77886: LD_INT 0
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: PUSH
77893: LD_INT 5
77895: PUSH
77896: LD_INT 1
77898: PUSH
77899: EMPTY
77900: LIST
77901: LIST
77902: PUSH
77903: LD_INT 4
77905: PUSH
77906: LD_INT 1
77908: PUSH
77909: EMPTY
77910: LIST
77911: LIST
77912: PUSH
77913: LD_INT 3
77915: PUSH
77916: LD_INT 0
77918: PUSH
77919: EMPTY
77920: LIST
77921: LIST
77922: PUSH
77923: LD_INT 3
77925: PUSH
77926: LD_INT 1
77928: NEG
77929: PUSH
77930: EMPTY
77931: LIST
77932: LIST
77933: PUSH
77934: LD_INT 3
77936: PUSH
77937: LD_INT 2
77939: NEG
77940: PUSH
77941: EMPTY
77942: LIST
77943: LIST
77944: PUSH
77945: LD_INT 5
77947: PUSH
77948: LD_INT 2
77950: PUSH
77951: EMPTY
77952: LIST
77953: LIST
77954: PUSH
77955: LD_INT 3
77957: PUSH
77958: LD_INT 3
77960: PUSH
77961: EMPTY
77962: LIST
77963: LIST
77964: PUSH
77965: LD_INT 3
77967: PUSH
77968: LD_INT 2
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: PUSH
77975: LD_INT 4
77977: PUSH
77978: LD_INT 3
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 4
77987: PUSH
77988: LD_INT 4
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: PUSH
77995: LD_INT 3
77997: PUSH
77998: LD_INT 4
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: PUSH
78005: LD_INT 2
78007: PUSH
78008: LD_INT 3
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: PUSH
78015: LD_INT 2
78017: PUSH
78018: LD_INT 2
78020: PUSH
78021: EMPTY
78022: LIST
78023: LIST
78024: PUSH
78025: LD_INT 4
78027: PUSH
78028: LD_INT 2
78030: PUSH
78031: EMPTY
78032: LIST
78033: LIST
78034: PUSH
78035: LD_INT 2
78037: PUSH
78038: LD_INT 4
78040: PUSH
78041: EMPTY
78042: LIST
78043: LIST
78044: PUSH
78045: LD_INT 0
78047: PUSH
78048: LD_INT 4
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: PUSH
78055: LD_INT 0
78057: PUSH
78058: LD_INT 3
78060: PUSH
78061: EMPTY
78062: LIST
78063: LIST
78064: PUSH
78065: LD_INT 1
78067: PUSH
78068: LD_INT 4
78070: PUSH
78071: EMPTY
78072: LIST
78073: LIST
78074: PUSH
78075: LD_INT 1
78077: PUSH
78078: LD_INT 5
78080: PUSH
78081: EMPTY
78082: LIST
78083: LIST
78084: PUSH
78085: LD_INT 0
78087: PUSH
78088: LD_INT 5
78090: PUSH
78091: EMPTY
78092: LIST
78093: LIST
78094: PUSH
78095: LD_INT 1
78097: NEG
78098: PUSH
78099: LD_INT 4
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: PUSH
78106: LD_INT 1
78108: NEG
78109: PUSH
78110: LD_INT 3
78112: PUSH
78113: EMPTY
78114: LIST
78115: LIST
78116: PUSH
78117: LD_INT 2
78119: PUSH
78120: LD_INT 5
78122: PUSH
78123: EMPTY
78124: LIST
78125: LIST
78126: PUSH
78127: LD_INT 2
78129: NEG
78130: PUSH
78131: LD_INT 3
78133: PUSH
78134: EMPTY
78135: LIST
78136: LIST
78137: PUSH
78138: LD_INT 3
78140: NEG
78141: PUSH
78142: LD_INT 0
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: PUSH
78149: LD_INT 3
78151: NEG
78152: PUSH
78153: LD_INT 1
78155: NEG
78156: PUSH
78157: EMPTY
78158: LIST
78159: LIST
78160: PUSH
78161: LD_INT 2
78163: NEG
78164: PUSH
78165: LD_INT 0
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 2
78174: NEG
78175: PUSH
78176: LD_INT 1
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: LD_INT 3
78185: NEG
78186: PUSH
78187: LD_INT 1
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 4
78196: NEG
78197: PUSH
78198: LD_INT 0
78200: PUSH
78201: EMPTY
78202: LIST
78203: LIST
78204: PUSH
78205: LD_INT 4
78207: NEG
78208: PUSH
78209: LD_INT 1
78211: NEG
78212: PUSH
78213: EMPTY
78214: LIST
78215: LIST
78216: PUSH
78217: LD_INT 4
78219: NEG
78220: PUSH
78221: LD_INT 2
78223: NEG
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: PUSH
78229: LD_INT 2
78231: NEG
78232: PUSH
78233: LD_INT 2
78235: PUSH
78236: EMPTY
78237: LIST
78238: LIST
78239: PUSH
78240: LD_INT 4
78242: NEG
78243: PUSH
78244: LD_INT 4
78246: NEG
78247: PUSH
78248: EMPTY
78249: LIST
78250: LIST
78251: PUSH
78252: LD_INT 4
78254: NEG
78255: PUSH
78256: LD_INT 5
78258: NEG
78259: PUSH
78260: EMPTY
78261: LIST
78262: LIST
78263: PUSH
78264: LD_INT 3
78266: NEG
78267: PUSH
78268: LD_INT 4
78270: NEG
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: PUSH
78276: LD_INT 3
78278: NEG
78279: PUSH
78280: LD_INT 3
78282: NEG
78283: PUSH
78284: EMPTY
78285: LIST
78286: LIST
78287: PUSH
78288: LD_INT 4
78290: NEG
78291: PUSH
78292: LD_INT 3
78294: NEG
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: PUSH
78300: LD_INT 5
78302: NEG
78303: PUSH
78304: LD_INT 4
78306: NEG
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: PUSH
78312: LD_INT 5
78314: NEG
78315: PUSH
78316: LD_INT 5
78318: NEG
78319: PUSH
78320: EMPTY
78321: LIST
78322: LIST
78323: PUSH
78324: LD_INT 3
78326: NEG
78327: PUSH
78328: LD_INT 5
78330: NEG
78331: PUSH
78332: EMPTY
78333: LIST
78334: LIST
78335: PUSH
78336: LD_INT 5
78338: NEG
78339: PUSH
78340: LD_INT 3
78342: NEG
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: LIST
78352: LIST
78353: LIST
78354: LIST
78355: LIST
78356: LIST
78357: LIST
78358: LIST
78359: LIST
78360: LIST
78361: LIST
78362: LIST
78363: LIST
78364: LIST
78365: LIST
78366: LIST
78367: LIST
78368: LIST
78369: LIST
78370: LIST
78371: LIST
78372: LIST
78373: LIST
78374: LIST
78375: LIST
78376: LIST
78377: LIST
78378: LIST
78379: LIST
78380: LIST
78381: LIST
78382: LIST
78383: LIST
78384: LIST
78385: LIST
78386: LIST
78387: LIST
78388: LIST
78389: LIST
78390: LIST
78391: LIST
78392: LIST
78393: LIST
78394: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78395: LD_ADDR_VAR 0 30
78399: PUSH
78400: LD_INT 4
78402: PUSH
78403: LD_INT 4
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: PUSH
78410: LD_INT 4
78412: PUSH
78413: LD_INT 3
78415: PUSH
78416: EMPTY
78417: LIST
78418: LIST
78419: PUSH
78420: LD_INT 5
78422: PUSH
78423: LD_INT 4
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 5
78432: PUSH
78433: LD_INT 5
78435: PUSH
78436: EMPTY
78437: LIST
78438: LIST
78439: PUSH
78440: LD_INT 4
78442: PUSH
78443: LD_INT 5
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: LD_INT 3
78452: PUSH
78453: LD_INT 4
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 3
78462: PUSH
78463: LD_INT 3
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: PUSH
78470: LD_INT 5
78472: PUSH
78473: LD_INT 3
78475: PUSH
78476: EMPTY
78477: LIST
78478: LIST
78479: PUSH
78480: LD_INT 3
78482: PUSH
78483: LD_INT 5
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: PUSH
78490: LD_INT 0
78492: PUSH
78493: LD_INT 3
78495: PUSH
78496: EMPTY
78497: LIST
78498: LIST
78499: PUSH
78500: LD_INT 0
78502: PUSH
78503: LD_INT 2
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: LD_INT 1
78512: PUSH
78513: LD_INT 3
78515: PUSH
78516: EMPTY
78517: LIST
78518: LIST
78519: PUSH
78520: LD_INT 1
78522: PUSH
78523: LD_INT 4
78525: PUSH
78526: EMPTY
78527: LIST
78528: LIST
78529: PUSH
78530: LD_INT 0
78532: PUSH
78533: LD_INT 4
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: LD_INT 1
78542: NEG
78543: PUSH
78544: LD_INT 3
78546: PUSH
78547: EMPTY
78548: LIST
78549: LIST
78550: PUSH
78551: LD_INT 1
78553: NEG
78554: PUSH
78555: LD_INT 2
78557: PUSH
78558: EMPTY
78559: LIST
78560: LIST
78561: PUSH
78562: LD_INT 2
78564: PUSH
78565: LD_INT 4
78567: PUSH
78568: EMPTY
78569: LIST
78570: LIST
78571: PUSH
78572: LD_INT 2
78574: NEG
78575: PUSH
78576: LD_INT 2
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: PUSH
78583: LD_INT 4
78585: NEG
78586: PUSH
78587: LD_INT 0
78589: PUSH
78590: EMPTY
78591: LIST
78592: LIST
78593: PUSH
78594: LD_INT 4
78596: NEG
78597: PUSH
78598: LD_INT 1
78600: NEG
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: PUSH
78606: LD_INT 3
78608: NEG
78609: PUSH
78610: LD_INT 0
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: PUSH
78617: LD_INT 3
78619: NEG
78620: PUSH
78621: LD_INT 1
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 4
78630: NEG
78631: PUSH
78632: LD_INT 1
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 5
78641: NEG
78642: PUSH
78643: LD_INT 0
78645: PUSH
78646: EMPTY
78647: LIST
78648: LIST
78649: PUSH
78650: LD_INT 5
78652: NEG
78653: PUSH
78654: LD_INT 1
78656: NEG
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: PUSH
78662: LD_INT 5
78664: NEG
78665: PUSH
78666: LD_INT 2
78668: NEG
78669: PUSH
78670: EMPTY
78671: LIST
78672: LIST
78673: PUSH
78674: LD_INT 3
78676: NEG
78677: PUSH
78678: LD_INT 2
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PUSH
78685: LD_INT 3
78687: NEG
78688: PUSH
78689: LD_INT 3
78691: NEG
78692: PUSH
78693: EMPTY
78694: LIST
78695: LIST
78696: PUSH
78697: LD_INT 3
78699: NEG
78700: PUSH
78701: LD_INT 4
78703: NEG
78704: PUSH
78705: EMPTY
78706: LIST
78707: LIST
78708: PUSH
78709: LD_INT 2
78711: NEG
78712: PUSH
78713: LD_INT 3
78715: NEG
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: PUSH
78721: LD_INT 2
78723: NEG
78724: PUSH
78725: LD_INT 2
78727: NEG
78728: PUSH
78729: EMPTY
78730: LIST
78731: LIST
78732: PUSH
78733: LD_INT 3
78735: NEG
78736: PUSH
78737: LD_INT 2
78739: NEG
78740: PUSH
78741: EMPTY
78742: LIST
78743: LIST
78744: PUSH
78745: LD_INT 4
78747: NEG
78748: PUSH
78749: LD_INT 3
78751: NEG
78752: PUSH
78753: EMPTY
78754: LIST
78755: LIST
78756: PUSH
78757: LD_INT 4
78759: NEG
78760: PUSH
78761: LD_INT 4
78763: NEG
78764: PUSH
78765: EMPTY
78766: LIST
78767: LIST
78768: PUSH
78769: LD_INT 2
78771: NEG
78772: PUSH
78773: LD_INT 4
78775: NEG
78776: PUSH
78777: EMPTY
78778: LIST
78779: LIST
78780: PUSH
78781: LD_INT 4
78783: NEG
78784: PUSH
78785: LD_INT 2
78787: NEG
78788: PUSH
78789: EMPTY
78790: LIST
78791: LIST
78792: PUSH
78793: LD_INT 0
78795: PUSH
78796: LD_INT 4
78798: NEG
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: PUSH
78804: LD_INT 0
78806: PUSH
78807: LD_INT 5
78809: NEG
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 1
78817: PUSH
78818: LD_INT 4
78820: NEG
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: PUSH
78826: LD_INT 1
78828: PUSH
78829: LD_INT 3
78831: NEG
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 0
78839: PUSH
78840: LD_INT 3
78842: NEG
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 1
78850: NEG
78851: PUSH
78852: LD_INT 4
78854: NEG
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: PUSH
78860: LD_INT 1
78862: NEG
78863: PUSH
78864: LD_INT 5
78866: NEG
78867: PUSH
78868: EMPTY
78869: LIST
78870: LIST
78871: PUSH
78872: LD_INT 2
78874: PUSH
78875: LD_INT 3
78877: NEG
78878: PUSH
78879: EMPTY
78880: LIST
78881: LIST
78882: PUSH
78883: LD_INT 2
78885: NEG
78886: PUSH
78887: LD_INT 5
78889: NEG
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: LIST
78899: LIST
78900: LIST
78901: LIST
78902: LIST
78903: LIST
78904: LIST
78905: LIST
78906: LIST
78907: LIST
78908: LIST
78909: LIST
78910: LIST
78911: LIST
78912: LIST
78913: LIST
78914: LIST
78915: LIST
78916: LIST
78917: LIST
78918: LIST
78919: LIST
78920: LIST
78921: LIST
78922: LIST
78923: LIST
78924: LIST
78925: LIST
78926: LIST
78927: LIST
78928: LIST
78929: LIST
78930: LIST
78931: LIST
78932: LIST
78933: LIST
78934: LIST
78935: LIST
78936: LIST
78937: LIST
78938: LIST
78939: LIST
78940: LIST
78941: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78942: LD_ADDR_VAR 0 31
78946: PUSH
78947: LD_INT 0
78949: PUSH
78950: LD_INT 4
78952: PUSH
78953: EMPTY
78954: LIST
78955: LIST
78956: PUSH
78957: LD_INT 0
78959: PUSH
78960: LD_INT 3
78962: PUSH
78963: EMPTY
78964: LIST
78965: LIST
78966: PUSH
78967: LD_INT 1
78969: PUSH
78970: LD_INT 4
78972: PUSH
78973: EMPTY
78974: LIST
78975: LIST
78976: PUSH
78977: LD_INT 1
78979: PUSH
78980: LD_INT 5
78982: PUSH
78983: EMPTY
78984: LIST
78985: LIST
78986: PUSH
78987: LD_INT 0
78989: PUSH
78990: LD_INT 5
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: PUSH
78997: LD_INT 1
78999: NEG
79000: PUSH
79001: LD_INT 4
79003: PUSH
79004: EMPTY
79005: LIST
79006: LIST
79007: PUSH
79008: LD_INT 1
79010: NEG
79011: PUSH
79012: LD_INT 3
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: PUSH
79019: LD_INT 2
79021: PUSH
79022: LD_INT 5
79024: PUSH
79025: EMPTY
79026: LIST
79027: LIST
79028: PUSH
79029: LD_INT 2
79031: NEG
79032: PUSH
79033: LD_INT 3
79035: PUSH
79036: EMPTY
79037: LIST
79038: LIST
79039: PUSH
79040: LD_INT 3
79042: NEG
79043: PUSH
79044: LD_INT 0
79046: PUSH
79047: EMPTY
79048: LIST
79049: LIST
79050: PUSH
79051: LD_INT 3
79053: NEG
79054: PUSH
79055: LD_INT 1
79057: NEG
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: PUSH
79063: LD_INT 2
79065: NEG
79066: PUSH
79067: LD_INT 0
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 2
79076: NEG
79077: PUSH
79078: LD_INT 1
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 3
79087: NEG
79088: PUSH
79089: LD_INT 1
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 4
79098: NEG
79099: PUSH
79100: LD_INT 0
79102: PUSH
79103: EMPTY
79104: LIST
79105: LIST
79106: PUSH
79107: LD_INT 4
79109: NEG
79110: PUSH
79111: LD_INT 1
79113: NEG
79114: PUSH
79115: EMPTY
79116: LIST
79117: LIST
79118: PUSH
79119: LD_INT 4
79121: NEG
79122: PUSH
79123: LD_INT 2
79125: NEG
79126: PUSH
79127: EMPTY
79128: LIST
79129: LIST
79130: PUSH
79131: LD_INT 2
79133: NEG
79134: PUSH
79135: LD_INT 2
79137: PUSH
79138: EMPTY
79139: LIST
79140: LIST
79141: PUSH
79142: LD_INT 4
79144: NEG
79145: PUSH
79146: LD_INT 4
79148: NEG
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: PUSH
79154: LD_INT 4
79156: NEG
79157: PUSH
79158: LD_INT 5
79160: NEG
79161: PUSH
79162: EMPTY
79163: LIST
79164: LIST
79165: PUSH
79166: LD_INT 3
79168: NEG
79169: PUSH
79170: LD_INT 4
79172: NEG
79173: PUSH
79174: EMPTY
79175: LIST
79176: LIST
79177: PUSH
79178: LD_INT 3
79180: NEG
79181: PUSH
79182: LD_INT 3
79184: NEG
79185: PUSH
79186: EMPTY
79187: LIST
79188: LIST
79189: PUSH
79190: LD_INT 4
79192: NEG
79193: PUSH
79194: LD_INT 3
79196: NEG
79197: PUSH
79198: EMPTY
79199: LIST
79200: LIST
79201: PUSH
79202: LD_INT 5
79204: NEG
79205: PUSH
79206: LD_INT 4
79208: NEG
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 5
79216: NEG
79217: PUSH
79218: LD_INT 5
79220: NEG
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: PUSH
79226: LD_INT 3
79228: NEG
79229: PUSH
79230: LD_INT 5
79232: NEG
79233: PUSH
79234: EMPTY
79235: LIST
79236: LIST
79237: PUSH
79238: LD_INT 5
79240: NEG
79241: PUSH
79242: LD_INT 3
79244: NEG
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PUSH
79250: LD_INT 0
79252: PUSH
79253: LD_INT 3
79255: NEG
79256: PUSH
79257: EMPTY
79258: LIST
79259: LIST
79260: PUSH
79261: LD_INT 0
79263: PUSH
79264: LD_INT 4
79266: NEG
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: PUSH
79272: LD_INT 1
79274: PUSH
79275: LD_INT 3
79277: NEG
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 1
79285: PUSH
79286: LD_INT 2
79288: NEG
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PUSH
79294: LD_INT 0
79296: PUSH
79297: LD_INT 2
79299: NEG
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: LD_INT 1
79307: NEG
79308: PUSH
79309: LD_INT 3
79311: NEG
79312: PUSH
79313: EMPTY
79314: LIST
79315: LIST
79316: PUSH
79317: LD_INT 1
79319: NEG
79320: PUSH
79321: LD_INT 4
79323: NEG
79324: PUSH
79325: EMPTY
79326: LIST
79327: LIST
79328: PUSH
79329: LD_INT 2
79331: PUSH
79332: LD_INT 2
79334: NEG
79335: PUSH
79336: EMPTY
79337: LIST
79338: LIST
79339: PUSH
79340: LD_INT 2
79342: NEG
79343: PUSH
79344: LD_INT 4
79346: NEG
79347: PUSH
79348: EMPTY
79349: LIST
79350: LIST
79351: PUSH
79352: LD_INT 4
79354: PUSH
79355: LD_INT 0
79357: PUSH
79358: EMPTY
79359: LIST
79360: LIST
79361: PUSH
79362: LD_INT 4
79364: PUSH
79365: LD_INT 1
79367: NEG
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: PUSH
79373: LD_INT 5
79375: PUSH
79376: LD_INT 0
79378: PUSH
79379: EMPTY
79380: LIST
79381: LIST
79382: PUSH
79383: LD_INT 5
79385: PUSH
79386: LD_INT 1
79388: PUSH
79389: EMPTY
79390: LIST
79391: LIST
79392: PUSH
79393: LD_INT 4
79395: PUSH
79396: LD_INT 1
79398: PUSH
79399: EMPTY
79400: LIST
79401: LIST
79402: PUSH
79403: LD_INT 3
79405: PUSH
79406: LD_INT 0
79408: PUSH
79409: EMPTY
79410: LIST
79411: LIST
79412: PUSH
79413: LD_INT 3
79415: PUSH
79416: LD_INT 1
79418: NEG
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: LD_INT 3
79426: PUSH
79427: LD_INT 2
79429: NEG
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 5
79437: PUSH
79438: LD_INT 2
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: LIST
79453: LIST
79454: LIST
79455: LIST
79456: LIST
79457: LIST
79458: LIST
79459: LIST
79460: LIST
79461: LIST
79462: LIST
79463: LIST
79464: LIST
79465: LIST
79466: LIST
79467: LIST
79468: LIST
79469: LIST
79470: LIST
79471: LIST
79472: LIST
79473: LIST
79474: LIST
79475: LIST
79476: LIST
79477: LIST
79478: LIST
79479: LIST
79480: LIST
79481: LIST
79482: LIST
79483: LIST
79484: LIST
79485: LIST
79486: LIST
79487: LIST
79488: LIST
79489: LIST
79490: LIST
79491: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79492: LD_ADDR_VAR 0 32
79496: PUSH
79497: LD_INT 4
79499: NEG
79500: PUSH
79501: LD_INT 0
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PUSH
79508: LD_INT 4
79510: NEG
79511: PUSH
79512: LD_INT 1
79514: NEG
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: PUSH
79520: LD_INT 3
79522: NEG
79523: PUSH
79524: LD_INT 0
79526: PUSH
79527: EMPTY
79528: LIST
79529: LIST
79530: PUSH
79531: LD_INT 3
79533: NEG
79534: PUSH
79535: LD_INT 1
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: PUSH
79542: LD_INT 4
79544: NEG
79545: PUSH
79546: LD_INT 1
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: LD_INT 5
79555: NEG
79556: PUSH
79557: LD_INT 0
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PUSH
79564: LD_INT 5
79566: NEG
79567: PUSH
79568: LD_INT 1
79570: NEG
79571: PUSH
79572: EMPTY
79573: LIST
79574: LIST
79575: PUSH
79576: LD_INT 5
79578: NEG
79579: PUSH
79580: LD_INT 2
79582: NEG
79583: PUSH
79584: EMPTY
79585: LIST
79586: LIST
79587: PUSH
79588: LD_INT 3
79590: NEG
79591: PUSH
79592: LD_INT 2
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: LD_INT 3
79601: NEG
79602: PUSH
79603: LD_INT 3
79605: NEG
79606: PUSH
79607: EMPTY
79608: LIST
79609: LIST
79610: PUSH
79611: LD_INT 3
79613: NEG
79614: PUSH
79615: LD_INT 4
79617: NEG
79618: PUSH
79619: EMPTY
79620: LIST
79621: LIST
79622: PUSH
79623: LD_INT 2
79625: NEG
79626: PUSH
79627: LD_INT 3
79629: NEG
79630: PUSH
79631: EMPTY
79632: LIST
79633: LIST
79634: PUSH
79635: LD_INT 2
79637: NEG
79638: PUSH
79639: LD_INT 2
79641: NEG
79642: PUSH
79643: EMPTY
79644: LIST
79645: LIST
79646: PUSH
79647: LD_INT 3
79649: NEG
79650: PUSH
79651: LD_INT 2
79653: NEG
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: LD_INT 4
79661: NEG
79662: PUSH
79663: LD_INT 3
79665: NEG
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PUSH
79671: LD_INT 4
79673: NEG
79674: PUSH
79675: LD_INT 4
79677: NEG
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: LD_INT 2
79685: NEG
79686: PUSH
79687: LD_INT 4
79689: NEG
79690: PUSH
79691: EMPTY
79692: LIST
79693: LIST
79694: PUSH
79695: LD_INT 4
79697: NEG
79698: PUSH
79699: LD_INT 2
79701: NEG
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: PUSH
79707: LD_INT 0
79709: PUSH
79710: LD_INT 4
79712: NEG
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 0
79720: PUSH
79721: LD_INT 5
79723: NEG
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 1
79731: PUSH
79732: LD_INT 4
79734: NEG
79735: PUSH
79736: EMPTY
79737: LIST
79738: LIST
79739: PUSH
79740: LD_INT 1
79742: PUSH
79743: LD_INT 3
79745: NEG
79746: PUSH
79747: EMPTY
79748: LIST
79749: LIST
79750: PUSH
79751: LD_INT 0
79753: PUSH
79754: LD_INT 3
79756: NEG
79757: PUSH
79758: EMPTY
79759: LIST
79760: LIST
79761: PUSH
79762: LD_INT 1
79764: NEG
79765: PUSH
79766: LD_INT 4
79768: NEG
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: LD_INT 1
79776: NEG
79777: PUSH
79778: LD_INT 5
79780: NEG
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PUSH
79786: LD_INT 2
79788: PUSH
79789: LD_INT 3
79791: NEG
79792: PUSH
79793: EMPTY
79794: LIST
79795: LIST
79796: PUSH
79797: LD_INT 2
79799: NEG
79800: PUSH
79801: LD_INT 5
79803: NEG
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: PUSH
79809: LD_INT 3
79811: PUSH
79812: LD_INT 0
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 3
79821: PUSH
79822: LD_INT 1
79824: NEG
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 4
79832: PUSH
79833: LD_INT 0
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 4
79842: PUSH
79843: LD_INT 1
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 3
79852: PUSH
79853: LD_INT 1
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 2
79862: PUSH
79863: LD_INT 0
79865: PUSH
79866: EMPTY
79867: LIST
79868: LIST
79869: PUSH
79870: LD_INT 2
79872: PUSH
79873: LD_INT 1
79875: NEG
79876: PUSH
79877: EMPTY
79878: LIST
79879: LIST
79880: PUSH
79881: LD_INT 2
79883: PUSH
79884: LD_INT 2
79886: NEG
79887: PUSH
79888: EMPTY
79889: LIST
79890: LIST
79891: PUSH
79892: LD_INT 4
79894: PUSH
79895: LD_INT 2
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: PUSH
79902: LD_INT 4
79904: PUSH
79905: LD_INT 4
79907: PUSH
79908: EMPTY
79909: LIST
79910: LIST
79911: PUSH
79912: LD_INT 4
79914: PUSH
79915: LD_INT 3
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: PUSH
79922: LD_INT 5
79924: PUSH
79925: LD_INT 4
79927: PUSH
79928: EMPTY
79929: LIST
79930: LIST
79931: PUSH
79932: LD_INT 5
79934: PUSH
79935: LD_INT 5
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: PUSH
79942: LD_INT 4
79944: PUSH
79945: LD_INT 5
79947: PUSH
79948: EMPTY
79949: LIST
79950: LIST
79951: PUSH
79952: LD_INT 3
79954: PUSH
79955: LD_INT 4
79957: PUSH
79958: EMPTY
79959: LIST
79960: LIST
79961: PUSH
79962: LD_INT 3
79964: PUSH
79965: LD_INT 3
79967: PUSH
79968: EMPTY
79969: LIST
79970: LIST
79971: PUSH
79972: LD_INT 5
79974: PUSH
79975: LD_INT 3
79977: PUSH
79978: EMPTY
79979: LIST
79980: LIST
79981: PUSH
79982: LD_INT 3
79984: PUSH
79985: LD_INT 5
79987: PUSH
79988: EMPTY
79989: LIST
79990: LIST
79991: PUSH
79992: EMPTY
79993: LIST
79994: LIST
79995: LIST
79996: LIST
79997: LIST
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: LIST
80007: LIST
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: LIST
80018: LIST
80019: LIST
80020: LIST
80021: LIST
80022: LIST
80023: LIST
80024: LIST
80025: LIST
80026: LIST
80027: LIST
80028: LIST
80029: LIST
80030: LIST
80031: LIST
80032: LIST
80033: LIST
80034: LIST
80035: LIST
80036: LIST
80037: LIST
80038: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80039: LD_ADDR_VAR 0 33
80043: PUSH
80044: LD_INT 4
80046: NEG
80047: PUSH
80048: LD_INT 4
80050: NEG
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: LD_INT 4
80058: NEG
80059: PUSH
80060: LD_INT 5
80062: NEG
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: LD_INT 3
80070: NEG
80071: PUSH
80072: LD_INT 4
80074: NEG
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PUSH
80080: LD_INT 3
80082: NEG
80083: PUSH
80084: LD_INT 3
80086: NEG
80087: PUSH
80088: EMPTY
80089: LIST
80090: LIST
80091: PUSH
80092: LD_INT 4
80094: NEG
80095: PUSH
80096: LD_INT 3
80098: NEG
80099: PUSH
80100: EMPTY
80101: LIST
80102: LIST
80103: PUSH
80104: LD_INT 5
80106: NEG
80107: PUSH
80108: LD_INT 4
80110: NEG
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 5
80118: NEG
80119: PUSH
80120: LD_INT 5
80122: NEG
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 3
80130: NEG
80131: PUSH
80132: LD_INT 5
80134: NEG
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 5
80142: NEG
80143: PUSH
80144: LD_INT 3
80146: NEG
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: PUSH
80152: LD_INT 0
80154: PUSH
80155: LD_INT 3
80157: NEG
80158: PUSH
80159: EMPTY
80160: LIST
80161: LIST
80162: PUSH
80163: LD_INT 0
80165: PUSH
80166: LD_INT 4
80168: NEG
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: LD_INT 1
80176: PUSH
80177: LD_INT 3
80179: NEG
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: PUSH
80185: LD_INT 1
80187: PUSH
80188: LD_INT 2
80190: NEG
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: LD_INT 0
80198: PUSH
80199: LD_INT 2
80201: NEG
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: LD_INT 1
80209: NEG
80210: PUSH
80211: LD_INT 3
80213: NEG
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: PUSH
80219: LD_INT 1
80221: NEG
80222: PUSH
80223: LD_INT 4
80225: NEG
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 2
80233: PUSH
80234: LD_INT 2
80236: NEG
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: LD_INT 2
80244: NEG
80245: PUSH
80246: LD_INT 4
80248: NEG
80249: PUSH
80250: EMPTY
80251: LIST
80252: LIST
80253: PUSH
80254: LD_INT 4
80256: PUSH
80257: LD_INT 0
80259: PUSH
80260: EMPTY
80261: LIST
80262: LIST
80263: PUSH
80264: LD_INT 4
80266: PUSH
80267: LD_INT 1
80269: NEG
80270: PUSH
80271: EMPTY
80272: LIST
80273: LIST
80274: PUSH
80275: LD_INT 5
80277: PUSH
80278: LD_INT 0
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 5
80287: PUSH
80288: LD_INT 1
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: PUSH
80295: LD_INT 4
80297: PUSH
80298: LD_INT 1
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: LD_INT 3
80307: PUSH
80308: LD_INT 0
80310: PUSH
80311: EMPTY
80312: LIST
80313: LIST
80314: PUSH
80315: LD_INT 3
80317: PUSH
80318: LD_INT 1
80320: NEG
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: PUSH
80326: LD_INT 3
80328: PUSH
80329: LD_INT 2
80331: NEG
80332: PUSH
80333: EMPTY
80334: LIST
80335: LIST
80336: PUSH
80337: LD_INT 5
80339: PUSH
80340: LD_INT 2
80342: PUSH
80343: EMPTY
80344: LIST
80345: LIST
80346: PUSH
80347: LD_INT 3
80349: PUSH
80350: LD_INT 3
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 3
80359: PUSH
80360: LD_INT 2
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 4
80369: PUSH
80370: LD_INT 3
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: PUSH
80377: LD_INT 4
80379: PUSH
80380: LD_INT 4
80382: PUSH
80383: EMPTY
80384: LIST
80385: LIST
80386: PUSH
80387: LD_INT 3
80389: PUSH
80390: LD_INT 4
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PUSH
80397: LD_INT 2
80399: PUSH
80400: LD_INT 3
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: PUSH
80407: LD_INT 2
80409: PUSH
80410: LD_INT 2
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: LD_INT 4
80419: PUSH
80420: LD_INT 2
80422: PUSH
80423: EMPTY
80424: LIST
80425: LIST
80426: PUSH
80427: LD_INT 2
80429: PUSH
80430: LD_INT 4
80432: PUSH
80433: EMPTY
80434: LIST
80435: LIST
80436: PUSH
80437: LD_INT 0
80439: PUSH
80440: LD_INT 4
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 0
80449: PUSH
80450: LD_INT 3
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: LD_INT 1
80459: PUSH
80460: LD_INT 4
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: LD_INT 1
80469: PUSH
80470: LD_INT 5
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: PUSH
80477: LD_INT 0
80479: PUSH
80480: LD_INT 5
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 1
80489: NEG
80490: PUSH
80491: LD_INT 4
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: PUSH
80498: LD_INT 1
80500: NEG
80501: PUSH
80502: LD_INT 3
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 2
80511: PUSH
80512: LD_INT 5
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: PUSH
80519: LD_INT 2
80521: NEG
80522: PUSH
80523: LD_INT 3
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: LIST
80545: LIST
80546: LIST
80547: LIST
80548: LIST
80549: LIST
80550: LIST
80551: LIST
80552: LIST
80553: LIST
80554: LIST
80555: LIST
80556: LIST
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
80577: LD_ADDR_VAR 0 34
80581: PUSH
80582: LD_INT 0
80584: PUSH
80585: LD_INT 4
80587: NEG
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: PUSH
80593: LD_INT 0
80595: PUSH
80596: LD_INT 5
80598: NEG
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: PUSH
80604: LD_INT 1
80606: PUSH
80607: LD_INT 4
80609: NEG
80610: PUSH
80611: EMPTY
80612: LIST
80613: LIST
80614: PUSH
80615: LD_INT 1
80617: PUSH
80618: LD_INT 3
80620: NEG
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PUSH
80626: LD_INT 0
80628: PUSH
80629: LD_INT 3
80631: NEG
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: PUSH
80637: LD_INT 1
80639: NEG
80640: PUSH
80641: LD_INT 4
80643: NEG
80644: PUSH
80645: EMPTY
80646: LIST
80647: LIST
80648: PUSH
80649: LD_INT 1
80651: NEG
80652: PUSH
80653: LD_INT 5
80655: NEG
80656: PUSH
80657: EMPTY
80658: LIST
80659: LIST
80660: PUSH
80661: LD_INT 2
80663: PUSH
80664: LD_INT 3
80666: NEG
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: PUSH
80672: LD_INT 2
80674: NEG
80675: PUSH
80676: LD_INT 5
80678: NEG
80679: PUSH
80680: EMPTY
80681: LIST
80682: LIST
80683: PUSH
80684: LD_INT 3
80686: PUSH
80687: LD_INT 0
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: PUSH
80694: LD_INT 3
80696: PUSH
80697: LD_INT 1
80699: NEG
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: PUSH
80705: LD_INT 4
80707: PUSH
80708: LD_INT 0
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: PUSH
80715: LD_INT 4
80717: PUSH
80718: LD_INT 1
80720: PUSH
80721: EMPTY
80722: LIST
80723: LIST
80724: PUSH
80725: LD_INT 3
80727: PUSH
80728: LD_INT 1
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: PUSH
80735: LD_INT 2
80737: PUSH
80738: LD_INT 0
80740: PUSH
80741: EMPTY
80742: LIST
80743: LIST
80744: PUSH
80745: LD_INT 2
80747: PUSH
80748: LD_INT 1
80750: NEG
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: PUSH
80756: LD_INT 2
80758: PUSH
80759: LD_INT 2
80761: NEG
80762: PUSH
80763: EMPTY
80764: LIST
80765: LIST
80766: PUSH
80767: LD_INT 4
80769: PUSH
80770: LD_INT 2
80772: PUSH
80773: EMPTY
80774: LIST
80775: LIST
80776: PUSH
80777: LD_INT 4
80779: PUSH
80780: LD_INT 4
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 4
80789: PUSH
80790: LD_INT 3
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 5
80799: PUSH
80800: LD_INT 4
80802: PUSH
80803: EMPTY
80804: LIST
80805: LIST
80806: PUSH
80807: LD_INT 5
80809: PUSH
80810: LD_INT 5
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 4
80819: PUSH
80820: LD_INT 5
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 3
80829: PUSH
80830: LD_INT 4
80832: PUSH
80833: EMPTY
80834: LIST
80835: LIST
80836: PUSH
80837: LD_INT 3
80839: PUSH
80840: LD_INT 3
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 5
80849: PUSH
80850: LD_INT 3
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: LD_INT 3
80859: PUSH
80860: LD_INT 5
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: PUSH
80867: LD_INT 0
80869: PUSH
80870: LD_INT 3
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 0
80879: PUSH
80880: LD_INT 2
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: PUSH
80887: LD_INT 1
80889: PUSH
80890: LD_INT 3
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PUSH
80897: LD_INT 1
80899: PUSH
80900: LD_INT 4
80902: PUSH
80903: EMPTY
80904: LIST
80905: LIST
80906: PUSH
80907: LD_INT 0
80909: PUSH
80910: LD_INT 4
80912: PUSH
80913: EMPTY
80914: LIST
80915: LIST
80916: PUSH
80917: LD_INT 1
80919: NEG
80920: PUSH
80921: LD_INT 3
80923: PUSH
80924: EMPTY
80925: LIST
80926: LIST
80927: PUSH
80928: LD_INT 1
80930: NEG
80931: PUSH
80932: LD_INT 2
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PUSH
80939: LD_INT 2
80941: PUSH
80942: LD_INT 4
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 2
80951: NEG
80952: PUSH
80953: LD_INT 2
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: PUSH
80960: LD_INT 4
80962: NEG
80963: PUSH
80964: LD_INT 0
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: LD_INT 4
80973: NEG
80974: PUSH
80975: LD_INT 1
80977: NEG
80978: PUSH
80979: EMPTY
80980: LIST
80981: LIST
80982: PUSH
80983: LD_INT 3
80985: NEG
80986: PUSH
80987: LD_INT 0
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PUSH
80994: LD_INT 3
80996: NEG
80997: PUSH
80998: LD_INT 1
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 4
81007: NEG
81008: PUSH
81009: LD_INT 1
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: PUSH
81016: LD_INT 5
81018: NEG
81019: PUSH
81020: LD_INT 0
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: LD_INT 5
81029: NEG
81030: PUSH
81031: LD_INT 1
81033: NEG
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: LD_INT 5
81041: NEG
81042: PUSH
81043: LD_INT 2
81045: NEG
81046: PUSH
81047: EMPTY
81048: LIST
81049: LIST
81050: PUSH
81051: LD_INT 3
81053: NEG
81054: PUSH
81055: LD_INT 2
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: PUSH
81062: EMPTY
81063: LIST
81064: LIST
81065: LIST
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: LIST
81095: LIST
81096: LIST
81097: LIST
81098: LIST
81099: LIST
81100: LIST
81101: LIST
81102: LIST
81103: LIST
81104: LIST
81105: LIST
81106: LIST
81107: LIST
81108: ST_TO_ADDR
// end ; end ;
81109: GO 81112
81111: POP
// case btype of b_depot , b_warehouse :
81112: LD_VAR 0 1
81116: PUSH
81117: LD_INT 0
81119: DOUBLE
81120: EQUAL
81121: IFTRUE 81131
81123: LD_INT 1
81125: DOUBLE
81126: EQUAL
81127: IFTRUE 81131
81129: GO 81332
81131: POP
// case nation of nation_american :
81132: LD_VAR 0 5
81136: PUSH
81137: LD_INT 1
81139: DOUBLE
81140: EQUAL
81141: IFTRUE 81145
81143: GO 81201
81145: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
81146: LD_ADDR_VAR 0 9
81150: PUSH
81151: LD_VAR 0 11
81155: PUSH
81156: LD_VAR 0 12
81160: PUSH
81161: LD_VAR 0 13
81165: PUSH
81166: LD_VAR 0 14
81170: PUSH
81171: LD_VAR 0 15
81175: PUSH
81176: LD_VAR 0 16
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: PUSH
81189: LD_VAR 0 4
81193: PUSH
81194: LD_INT 1
81196: PLUS
81197: ARRAY
81198: ST_TO_ADDR
81199: GO 81330
81201: LD_INT 2
81203: DOUBLE
81204: EQUAL
81205: IFTRUE 81209
81207: GO 81265
81209: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
81210: LD_ADDR_VAR 0 9
81214: PUSH
81215: LD_VAR 0 17
81219: PUSH
81220: LD_VAR 0 18
81224: PUSH
81225: LD_VAR 0 19
81229: PUSH
81230: LD_VAR 0 20
81234: PUSH
81235: LD_VAR 0 21
81239: PUSH
81240: LD_VAR 0 22
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: LIST
81249: LIST
81250: LIST
81251: LIST
81252: PUSH
81253: LD_VAR 0 4
81257: PUSH
81258: LD_INT 1
81260: PLUS
81261: ARRAY
81262: ST_TO_ADDR
81263: GO 81330
81265: LD_INT 3
81267: DOUBLE
81268: EQUAL
81269: IFTRUE 81273
81271: GO 81329
81273: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81274: LD_ADDR_VAR 0 9
81278: PUSH
81279: LD_VAR 0 23
81283: PUSH
81284: LD_VAR 0 24
81288: PUSH
81289: LD_VAR 0 25
81293: PUSH
81294: LD_VAR 0 26
81298: PUSH
81299: LD_VAR 0 27
81303: PUSH
81304: LD_VAR 0 28
81308: PUSH
81309: EMPTY
81310: LIST
81311: LIST
81312: LIST
81313: LIST
81314: LIST
81315: LIST
81316: PUSH
81317: LD_VAR 0 4
81321: PUSH
81322: LD_INT 1
81324: PLUS
81325: ARRAY
81326: ST_TO_ADDR
81327: GO 81330
81329: POP
81330: GO 81885
81332: LD_INT 2
81334: DOUBLE
81335: EQUAL
81336: IFTRUE 81346
81338: LD_INT 3
81340: DOUBLE
81341: EQUAL
81342: IFTRUE 81346
81344: GO 81402
81346: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81347: LD_ADDR_VAR 0 9
81351: PUSH
81352: LD_VAR 0 29
81356: PUSH
81357: LD_VAR 0 30
81361: PUSH
81362: LD_VAR 0 31
81366: PUSH
81367: LD_VAR 0 32
81371: PUSH
81372: LD_VAR 0 33
81376: PUSH
81377: LD_VAR 0 34
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: LIST
81386: LIST
81387: LIST
81388: LIST
81389: PUSH
81390: LD_VAR 0 4
81394: PUSH
81395: LD_INT 1
81397: PLUS
81398: ARRAY
81399: ST_TO_ADDR
81400: GO 81885
81402: LD_INT 16
81404: DOUBLE
81405: EQUAL
81406: IFTRUE 81464
81408: LD_INT 17
81410: DOUBLE
81411: EQUAL
81412: IFTRUE 81464
81414: LD_INT 18
81416: DOUBLE
81417: EQUAL
81418: IFTRUE 81464
81420: LD_INT 19
81422: DOUBLE
81423: EQUAL
81424: IFTRUE 81464
81426: LD_INT 22
81428: DOUBLE
81429: EQUAL
81430: IFTRUE 81464
81432: LD_INT 20
81434: DOUBLE
81435: EQUAL
81436: IFTRUE 81464
81438: LD_INT 21
81440: DOUBLE
81441: EQUAL
81442: IFTRUE 81464
81444: LD_INT 23
81446: DOUBLE
81447: EQUAL
81448: IFTRUE 81464
81450: LD_INT 24
81452: DOUBLE
81453: EQUAL
81454: IFTRUE 81464
81456: LD_INT 25
81458: DOUBLE
81459: EQUAL
81460: IFTRUE 81464
81462: GO 81520
81464: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81465: LD_ADDR_VAR 0 9
81469: PUSH
81470: LD_VAR 0 35
81474: PUSH
81475: LD_VAR 0 36
81479: PUSH
81480: LD_VAR 0 37
81484: PUSH
81485: LD_VAR 0 38
81489: PUSH
81490: LD_VAR 0 39
81494: PUSH
81495: LD_VAR 0 40
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: LIST
81504: LIST
81505: LIST
81506: LIST
81507: PUSH
81508: LD_VAR 0 4
81512: PUSH
81513: LD_INT 1
81515: PLUS
81516: ARRAY
81517: ST_TO_ADDR
81518: GO 81885
81520: LD_INT 6
81522: DOUBLE
81523: EQUAL
81524: IFTRUE 81576
81526: LD_INT 7
81528: DOUBLE
81529: EQUAL
81530: IFTRUE 81576
81532: LD_INT 8
81534: DOUBLE
81535: EQUAL
81536: IFTRUE 81576
81538: LD_INT 13
81540: DOUBLE
81541: EQUAL
81542: IFTRUE 81576
81544: LD_INT 12
81546: DOUBLE
81547: EQUAL
81548: IFTRUE 81576
81550: LD_INT 15
81552: DOUBLE
81553: EQUAL
81554: IFTRUE 81576
81556: LD_INT 11
81558: DOUBLE
81559: EQUAL
81560: IFTRUE 81576
81562: LD_INT 14
81564: DOUBLE
81565: EQUAL
81566: IFTRUE 81576
81568: LD_INT 10
81570: DOUBLE
81571: EQUAL
81572: IFTRUE 81576
81574: GO 81632
81576: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
81577: LD_ADDR_VAR 0 9
81581: PUSH
81582: LD_VAR 0 41
81586: PUSH
81587: LD_VAR 0 42
81591: PUSH
81592: LD_VAR 0 43
81596: PUSH
81597: LD_VAR 0 44
81601: PUSH
81602: LD_VAR 0 45
81606: PUSH
81607: LD_VAR 0 46
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: PUSH
81620: LD_VAR 0 4
81624: PUSH
81625: LD_INT 1
81627: PLUS
81628: ARRAY
81629: ST_TO_ADDR
81630: GO 81885
81632: LD_INT 36
81634: DOUBLE
81635: EQUAL
81636: IFTRUE 81640
81638: GO 81696
81640: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
81641: LD_ADDR_VAR 0 9
81645: PUSH
81646: LD_VAR 0 47
81650: PUSH
81651: LD_VAR 0 48
81655: PUSH
81656: LD_VAR 0 49
81660: PUSH
81661: LD_VAR 0 50
81665: PUSH
81666: LD_VAR 0 51
81670: PUSH
81671: LD_VAR 0 52
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: PUSH
81684: LD_VAR 0 4
81688: PUSH
81689: LD_INT 1
81691: PLUS
81692: ARRAY
81693: ST_TO_ADDR
81694: GO 81885
81696: LD_INT 4
81698: DOUBLE
81699: EQUAL
81700: IFTRUE 81722
81702: LD_INT 5
81704: DOUBLE
81705: EQUAL
81706: IFTRUE 81722
81708: LD_INT 34
81710: DOUBLE
81711: EQUAL
81712: IFTRUE 81722
81714: LD_INT 37
81716: DOUBLE
81717: EQUAL
81718: IFTRUE 81722
81720: GO 81778
81722: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81723: LD_ADDR_VAR 0 9
81727: PUSH
81728: LD_VAR 0 53
81732: PUSH
81733: LD_VAR 0 54
81737: PUSH
81738: LD_VAR 0 55
81742: PUSH
81743: LD_VAR 0 56
81747: PUSH
81748: LD_VAR 0 57
81752: PUSH
81753: LD_VAR 0 58
81757: PUSH
81758: EMPTY
81759: LIST
81760: LIST
81761: LIST
81762: LIST
81763: LIST
81764: LIST
81765: PUSH
81766: LD_VAR 0 4
81770: PUSH
81771: LD_INT 1
81773: PLUS
81774: ARRAY
81775: ST_TO_ADDR
81776: GO 81885
81778: LD_INT 31
81780: DOUBLE
81781: EQUAL
81782: IFTRUE 81828
81784: LD_INT 32
81786: DOUBLE
81787: EQUAL
81788: IFTRUE 81828
81790: LD_INT 33
81792: DOUBLE
81793: EQUAL
81794: IFTRUE 81828
81796: LD_INT 27
81798: DOUBLE
81799: EQUAL
81800: IFTRUE 81828
81802: LD_INT 26
81804: DOUBLE
81805: EQUAL
81806: IFTRUE 81828
81808: LD_INT 28
81810: DOUBLE
81811: EQUAL
81812: IFTRUE 81828
81814: LD_INT 29
81816: DOUBLE
81817: EQUAL
81818: IFTRUE 81828
81820: LD_INT 30
81822: DOUBLE
81823: EQUAL
81824: IFTRUE 81828
81826: GO 81884
81828: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81829: LD_ADDR_VAR 0 9
81833: PUSH
81834: LD_VAR 0 59
81838: PUSH
81839: LD_VAR 0 60
81843: PUSH
81844: LD_VAR 0 61
81848: PUSH
81849: LD_VAR 0 62
81853: PUSH
81854: LD_VAR 0 63
81858: PUSH
81859: LD_VAR 0 64
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: LIST
81868: LIST
81869: LIST
81870: LIST
81871: PUSH
81872: LD_VAR 0 4
81876: PUSH
81877: LD_INT 1
81879: PLUS
81880: ARRAY
81881: ST_TO_ADDR
81882: GO 81885
81884: POP
// temp_list2 = [ ] ;
81885: LD_ADDR_VAR 0 10
81889: PUSH
81890: EMPTY
81891: ST_TO_ADDR
// for i in temp_list do
81892: LD_ADDR_VAR 0 8
81896: PUSH
81897: LD_VAR 0 9
81901: PUSH
81902: FOR_IN
81903: IFFALSE 81955
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81905: LD_ADDR_VAR 0 10
81909: PUSH
81910: LD_VAR 0 10
81914: PUSH
81915: LD_VAR 0 8
81919: PUSH
81920: LD_INT 1
81922: ARRAY
81923: PUSH
81924: LD_VAR 0 2
81928: PLUS
81929: PUSH
81930: LD_VAR 0 8
81934: PUSH
81935: LD_INT 2
81937: ARRAY
81938: PUSH
81939: LD_VAR 0 3
81943: PLUS
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PUSH
81949: EMPTY
81950: LIST
81951: ADD
81952: ST_TO_ADDR
81953: GO 81902
81955: POP
81956: POP
// result = temp_list2 ;
81957: LD_ADDR_VAR 0 7
81961: PUSH
81962: LD_VAR 0 10
81966: ST_TO_ADDR
// end ;
81967: LD_VAR 0 7
81971: RET
// export function EnemyInRange ( unit , dist ) ; begin
81972: LD_INT 0
81974: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81975: LD_ADDR_VAR 0 3
81979: PUSH
81980: LD_VAR 0 1
81984: PPUSH
81985: CALL_OW 255
81989: PPUSH
81990: LD_VAR 0 1
81994: PPUSH
81995: CALL_OW 250
81999: PPUSH
82000: LD_VAR 0 1
82004: PPUSH
82005: CALL_OW 251
82009: PPUSH
82010: LD_VAR 0 2
82014: PPUSH
82015: CALL 55345 0 4
82019: PUSH
82020: LD_INT 4
82022: ARRAY
82023: ST_TO_ADDR
// end ;
82024: LD_VAR 0 3
82028: RET
// export function PlayerSeeMe ( unit ) ; begin
82029: LD_INT 0
82031: PPUSH
// result := See ( your_side , unit ) ;
82032: LD_ADDR_VAR 0 2
82036: PUSH
82037: LD_OWVAR 2
82041: PPUSH
82042: LD_VAR 0 1
82046: PPUSH
82047: CALL_OW 292
82051: ST_TO_ADDR
// end ;
82052: LD_VAR 0 2
82056: RET
// export function ReverseDir ( unit ) ; begin
82057: LD_INT 0
82059: PPUSH
// if not unit then
82060: LD_VAR 0 1
82064: NOT
82065: IFFALSE 82069
// exit ;
82067: GO 82092
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
82069: LD_ADDR_VAR 0 2
82073: PUSH
82074: LD_VAR 0 1
82078: PPUSH
82079: CALL_OW 254
82083: PUSH
82084: LD_INT 3
82086: PLUS
82087: PUSH
82088: LD_INT 6
82090: MOD
82091: ST_TO_ADDR
// end ;
82092: LD_VAR 0 2
82096: RET
// export function ReverseArray ( array ) ; var i ; begin
82097: LD_INT 0
82099: PPUSH
82100: PPUSH
// if not array then
82101: LD_VAR 0 1
82105: NOT
82106: IFFALSE 82110
// exit ;
82108: GO 82165
// result := [ ] ;
82110: LD_ADDR_VAR 0 2
82114: PUSH
82115: EMPTY
82116: ST_TO_ADDR
// for i := array downto 1 do
82117: LD_ADDR_VAR 0 3
82121: PUSH
82122: DOUBLE
82123: LD_VAR 0 1
82127: INC
82128: ST_TO_ADDR
82129: LD_INT 1
82131: PUSH
82132: FOR_DOWNTO
82133: IFFALSE 82163
// result := Join ( result , array [ i ] ) ;
82135: LD_ADDR_VAR 0 2
82139: PUSH
82140: LD_VAR 0 2
82144: PPUSH
82145: LD_VAR 0 1
82149: PUSH
82150: LD_VAR 0 3
82154: ARRAY
82155: PPUSH
82156: CALL 86821 0 2
82160: ST_TO_ADDR
82161: GO 82132
82163: POP
82164: POP
// end ;
82165: LD_VAR 0 2
82169: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
82170: LD_INT 0
82172: PPUSH
82173: PPUSH
82174: PPUSH
82175: PPUSH
82176: PPUSH
82177: PPUSH
// if not unit or not hexes then
82178: LD_VAR 0 1
82182: NOT
82183: PUSH
82184: LD_VAR 0 2
82188: NOT
82189: OR
82190: IFFALSE 82194
// exit ;
82192: GO 82317
// dist := 9999 ;
82194: LD_ADDR_VAR 0 5
82198: PUSH
82199: LD_INT 9999
82201: ST_TO_ADDR
// for i = 1 to hexes do
82202: LD_ADDR_VAR 0 4
82206: PUSH
82207: DOUBLE
82208: LD_INT 1
82210: DEC
82211: ST_TO_ADDR
82212: LD_VAR 0 2
82216: PUSH
82217: FOR_TO
82218: IFFALSE 82305
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82220: LD_ADDR_VAR 0 6
82224: PUSH
82225: LD_VAR 0 1
82229: PPUSH
82230: LD_VAR 0 2
82234: PUSH
82235: LD_VAR 0 4
82239: ARRAY
82240: PUSH
82241: LD_INT 1
82243: ARRAY
82244: PPUSH
82245: LD_VAR 0 2
82249: PUSH
82250: LD_VAR 0 4
82254: ARRAY
82255: PUSH
82256: LD_INT 2
82258: ARRAY
82259: PPUSH
82260: CALL_OW 297
82264: ST_TO_ADDR
// if tdist < dist then
82265: LD_VAR 0 6
82269: PUSH
82270: LD_VAR 0 5
82274: LESS
82275: IFFALSE 82303
// begin hex := hexes [ i ] ;
82277: LD_ADDR_VAR 0 8
82281: PUSH
82282: LD_VAR 0 2
82286: PUSH
82287: LD_VAR 0 4
82291: ARRAY
82292: ST_TO_ADDR
// dist := tdist ;
82293: LD_ADDR_VAR 0 5
82297: PUSH
82298: LD_VAR 0 6
82302: ST_TO_ADDR
// end ; end ;
82303: GO 82217
82305: POP
82306: POP
// result := hex ;
82307: LD_ADDR_VAR 0 3
82311: PUSH
82312: LD_VAR 0 8
82316: ST_TO_ADDR
// end ;
82317: LD_VAR 0 3
82321: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82322: LD_INT 0
82324: PPUSH
82325: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82326: LD_VAR 0 1
82330: NOT
82331: PUSH
82332: LD_VAR 0 1
82336: PUSH
82337: LD_INT 21
82339: PUSH
82340: LD_INT 2
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PUSH
82347: LD_INT 23
82349: PUSH
82350: LD_INT 2
82352: PUSH
82353: EMPTY
82354: LIST
82355: LIST
82356: PUSH
82357: EMPTY
82358: LIST
82359: LIST
82360: PPUSH
82361: CALL_OW 69
82365: IN
82366: NOT
82367: OR
82368: IFFALSE 82372
// exit ;
82370: GO 82419
// for i = 1 to 3 do
82372: LD_ADDR_VAR 0 3
82376: PUSH
82377: DOUBLE
82378: LD_INT 1
82380: DEC
82381: ST_TO_ADDR
82382: LD_INT 3
82384: PUSH
82385: FOR_TO
82386: IFFALSE 82417
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82388: LD_VAR 0 1
82392: PPUSH
82393: CALL_OW 250
82397: PPUSH
82398: LD_VAR 0 1
82402: PPUSH
82403: CALL_OW 251
82407: PPUSH
82408: LD_INT 1
82410: PPUSH
82411: CALL_OW 453
82415: GO 82385
82417: POP
82418: POP
// end ;
82419: LD_VAR 0 2
82423: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82424: LD_INT 0
82426: PPUSH
82427: PPUSH
82428: PPUSH
82429: PPUSH
82430: PPUSH
82431: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
82432: LD_VAR 0 1
82436: NOT
82437: PUSH
82438: LD_VAR 0 2
82442: NOT
82443: OR
82444: PUSH
82445: LD_VAR 0 1
82449: PPUSH
82450: CALL_OW 314
82454: OR
82455: IFFALSE 82459
// exit ;
82457: GO 82926
// if GetLives ( i ) < 250 then
82459: LD_VAR 0 4
82463: PPUSH
82464: CALL_OW 256
82468: PUSH
82469: LD_INT 250
82471: LESS
82472: IFFALSE 82485
// begin ComAutodestruct ( i ) ;
82474: LD_VAR 0 4
82478: PPUSH
82479: CALL 82322 0 1
// exit ;
82483: GO 82926
// end ; x := GetX ( enemy_unit ) ;
82485: LD_ADDR_VAR 0 7
82489: PUSH
82490: LD_VAR 0 2
82494: PPUSH
82495: CALL_OW 250
82499: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82500: LD_ADDR_VAR 0 8
82504: PUSH
82505: LD_VAR 0 2
82509: PPUSH
82510: CALL_OW 251
82514: ST_TO_ADDR
// if not x or not y then
82515: LD_VAR 0 7
82519: NOT
82520: PUSH
82521: LD_VAR 0 8
82525: NOT
82526: OR
82527: IFFALSE 82531
// exit ;
82529: GO 82926
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82531: LD_ADDR_VAR 0 6
82535: PUSH
82536: LD_VAR 0 7
82540: PPUSH
82541: LD_INT 0
82543: PPUSH
82544: LD_INT 4
82546: PPUSH
82547: CALL_OW 272
82551: PUSH
82552: LD_VAR 0 8
82556: PPUSH
82557: LD_INT 0
82559: PPUSH
82560: LD_INT 4
82562: PPUSH
82563: CALL_OW 273
82567: PUSH
82568: EMPTY
82569: LIST
82570: LIST
82571: PUSH
82572: LD_VAR 0 7
82576: PPUSH
82577: LD_INT 1
82579: PPUSH
82580: LD_INT 4
82582: PPUSH
82583: CALL_OW 272
82587: PUSH
82588: LD_VAR 0 8
82592: PPUSH
82593: LD_INT 1
82595: PPUSH
82596: LD_INT 4
82598: PPUSH
82599: CALL_OW 273
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: PUSH
82608: LD_VAR 0 7
82612: PPUSH
82613: LD_INT 2
82615: PPUSH
82616: LD_INT 4
82618: PPUSH
82619: CALL_OW 272
82623: PUSH
82624: LD_VAR 0 8
82628: PPUSH
82629: LD_INT 2
82631: PPUSH
82632: LD_INT 4
82634: PPUSH
82635: CALL_OW 273
82639: PUSH
82640: EMPTY
82641: LIST
82642: LIST
82643: PUSH
82644: LD_VAR 0 7
82648: PPUSH
82649: LD_INT 3
82651: PPUSH
82652: LD_INT 4
82654: PPUSH
82655: CALL_OW 272
82659: PUSH
82660: LD_VAR 0 8
82664: PPUSH
82665: LD_INT 3
82667: PPUSH
82668: LD_INT 4
82670: PPUSH
82671: CALL_OW 273
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: PUSH
82680: LD_VAR 0 7
82684: PPUSH
82685: LD_INT 4
82687: PPUSH
82688: LD_INT 4
82690: PPUSH
82691: CALL_OW 272
82695: PUSH
82696: LD_VAR 0 8
82700: PPUSH
82701: LD_INT 4
82703: PPUSH
82704: LD_INT 4
82706: PPUSH
82707: CALL_OW 273
82711: PUSH
82712: EMPTY
82713: LIST
82714: LIST
82715: PUSH
82716: LD_VAR 0 7
82720: PPUSH
82721: LD_INT 5
82723: PPUSH
82724: LD_INT 4
82726: PPUSH
82727: CALL_OW 272
82731: PUSH
82732: LD_VAR 0 8
82736: PPUSH
82737: LD_INT 5
82739: PPUSH
82740: LD_INT 4
82742: PPUSH
82743: CALL_OW 273
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: LIST
82756: LIST
82757: LIST
82758: LIST
82759: ST_TO_ADDR
// for i = tmp downto 1 do
82760: LD_ADDR_VAR 0 4
82764: PUSH
82765: DOUBLE
82766: LD_VAR 0 6
82770: INC
82771: ST_TO_ADDR
82772: LD_INT 1
82774: PUSH
82775: FOR_DOWNTO
82776: IFFALSE 82877
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82778: LD_VAR 0 6
82782: PUSH
82783: LD_VAR 0 4
82787: ARRAY
82788: PUSH
82789: LD_INT 1
82791: ARRAY
82792: PPUSH
82793: LD_VAR 0 6
82797: PUSH
82798: LD_VAR 0 4
82802: ARRAY
82803: PUSH
82804: LD_INT 2
82806: ARRAY
82807: PPUSH
82808: CALL_OW 488
82812: NOT
82813: PUSH
82814: LD_VAR 0 6
82818: PUSH
82819: LD_VAR 0 4
82823: ARRAY
82824: PUSH
82825: LD_INT 1
82827: ARRAY
82828: PPUSH
82829: LD_VAR 0 6
82833: PUSH
82834: LD_VAR 0 4
82838: ARRAY
82839: PUSH
82840: LD_INT 2
82842: ARRAY
82843: PPUSH
82844: CALL_OW 428
82848: PUSH
82849: LD_INT 0
82851: NONEQUAL
82852: OR
82853: IFFALSE 82875
// tmp := Delete ( tmp , i ) ;
82855: LD_ADDR_VAR 0 6
82859: PUSH
82860: LD_VAR 0 6
82864: PPUSH
82865: LD_VAR 0 4
82869: PPUSH
82870: CALL_OW 3
82874: ST_TO_ADDR
82875: GO 82775
82877: POP
82878: POP
// j := GetClosestHex ( unit , tmp ) ;
82879: LD_ADDR_VAR 0 5
82883: PUSH
82884: LD_VAR 0 1
82888: PPUSH
82889: LD_VAR 0 6
82893: PPUSH
82894: CALL 82170 0 2
82898: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82899: LD_VAR 0 1
82903: PPUSH
82904: LD_VAR 0 5
82908: PUSH
82909: LD_INT 1
82911: ARRAY
82912: PPUSH
82913: LD_VAR 0 5
82917: PUSH
82918: LD_INT 2
82920: ARRAY
82921: PPUSH
82922: CALL_OW 111
// end ;
82926: LD_VAR 0 3
82930: RET
// export function PrepareApemanSoldier ( ) ; begin
82931: LD_INT 0
82933: PPUSH
// uc_nation := 0 ;
82934: LD_ADDR_OWVAR 21
82938: PUSH
82939: LD_INT 0
82941: ST_TO_ADDR
// hc_sex := sex_male ;
82942: LD_ADDR_OWVAR 27
82946: PUSH
82947: LD_INT 1
82949: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82950: LD_ADDR_OWVAR 28
82954: PUSH
82955: LD_INT 15
82957: ST_TO_ADDR
// hc_gallery :=  ;
82958: LD_ADDR_OWVAR 33
82962: PUSH
82963: LD_STRING 
82965: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82966: LD_ADDR_OWVAR 31
82970: PUSH
82971: LD_INT 0
82973: PPUSH
82974: LD_INT 3
82976: PPUSH
82977: CALL_OW 12
82981: PUSH
82982: LD_INT 0
82984: PPUSH
82985: LD_INT 3
82987: PPUSH
82988: CALL_OW 12
82992: PUSH
82993: LD_INT 0
82995: PUSH
82996: LD_INT 0
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: LIST
83003: LIST
83004: ST_TO_ADDR
// end ;
83005: LD_VAR 0 1
83009: RET
// export function PrepareApemanEngineer ( ) ; begin
83010: LD_INT 0
83012: PPUSH
// uc_nation := 0 ;
83013: LD_ADDR_OWVAR 21
83017: PUSH
83018: LD_INT 0
83020: ST_TO_ADDR
// hc_sex := sex_male ;
83021: LD_ADDR_OWVAR 27
83025: PUSH
83026: LD_INT 1
83028: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
83029: LD_ADDR_OWVAR 28
83033: PUSH
83034: LD_INT 16
83036: ST_TO_ADDR
// hc_gallery :=  ;
83037: LD_ADDR_OWVAR 33
83041: PUSH
83042: LD_STRING 
83044: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83045: LD_ADDR_OWVAR 31
83049: PUSH
83050: LD_INT 0
83052: PPUSH
83053: LD_INT 3
83055: PPUSH
83056: CALL_OW 12
83060: PUSH
83061: LD_INT 0
83063: PPUSH
83064: LD_INT 3
83066: PPUSH
83067: CALL_OW 12
83071: PUSH
83072: LD_INT 0
83074: PUSH
83075: LD_INT 0
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: ST_TO_ADDR
// end ;
83084: LD_VAR 0 1
83088: RET
// export function PrepareApeman ( agressivity ) ; begin
83089: LD_INT 0
83091: PPUSH
// uc_side := 0 ;
83092: LD_ADDR_OWVAR 20
83096: PUSH
83097: LD_INT 0
83099: ST_TO_ADDR
// uc_nation := 0 ;
83100: LD_ADDR_OWVAR 21
83104: PUSH
83105: LD_INT 0
83107: ST_TO_ADDR
// hc_sex := sex_male ;
83108: LD_ADDR_OWVAR 27
83112: PUSH
83113: LD_INT 1
83115: ST_TO_ADDR
// hc_class := class_apeman ;
83116: LD_ADDR_OWVAR 28
83120: PUSH
83121: LD_INT 12
83123: ST_TO_ADDR
// hc_gallery :=  ;
83124: LD_ADDR_OWVAR 33
83128: PUSH
83129: LD_STRING 
83131: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83132: LD_ADDR_OWVAR 35
83136: PUSH
83137: LD_VAR 0 1
83141: NEG
83142: PPUSH
83143: LD_VAR 0 1
83147: PPUSH
83148: CALL_OW 12
83152: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83153: LD_ADDR_OWVAR 31
83157: PUSH
83158: LD_INT 0
83160: PPUSH
83161: LD_INT 3
83163: PPUSH
83164: CALL_OW 12
83168: PUSH
83169: LD_INT 0
83171: PPUSH
83172: LD_INT 3
83174: PPUSH
83175: CALL_OW 12
83179: PUSH
83180: LD_INT 0
83182: PUSH
83183: LD_INT 0
83185: PUSH
83186: EMPTY
83187: LIST
83188: LIST
83189: LIST
83190: LIST
83191: ST_TO_ADDR
// end ;
83192: LD_VAR 0 2
83196: RET
// export function PrepareTiger ( agressivity ) ; begin
83197: LD_INT 0
83199: PPUSH
// uc_side := 0 ;
83200: LD_ADDR_OWVAR 20
83204: PUSH
83205: LD_INT 0
83207: ST_TO_ADDR
// uc_nation := 0 ;
83208: LD_ADDR_OWVAR 21
83212: PUSH
83213: LD_INT 0
83215: ST_TO_ADDR
// hc_class := class_tiger ;
83216: LD_ADDR_OWVAR 28
83220: PUSH
83221: LD_INT 14
83223: ST_TO_ADDR
// hc_gallery :=  ;
83224: LD_ADDR_OWVAR 33
83228: PUSH
83229: LD_STRING 
83231: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83232: LD_ADDR_OWVAR 35
83236: PUSH
83237: LD_VAR 0 1
83241: NEG
83242: PPUSH
83243: LD_VAR 0 1
83247: PPUSH
83248: CALL_OW 12
83252: ST_TO_ADDR
// end ;
83253: LD_VAR 0 2
83257: RET
// export function PrepareEnchidna ( ) ; begin
83258: LD_INT 0
83260: PPUSH
// uc_side := 0 ;
83261: LD_ADDR_OWVAR 20
83265: PUSH
83266: LD_INT 0
83268: ST_TO_ADDR
// uc_nation := 0 ;
83269: LD_ADDR_OWVAR 21
83273: PUSH
83274: LD_INT 0
83276: ST_TO_ADDR
// hc_class := class_baggie ;
83277: LD_ADDR_OWVAR 28
83281: PUSH
83282: LD_INT 13
83284: ST_TO_ADDR
// hc_gallery :=  ;
83285: LD_ADDR_OWVAR 33
83289: PUSH
83290: LD_STRING 
83292: ST_TO_ADDR
// end ;
83293: LD_VAR 0 1
83297: RET
// export function PrepareFrog ( ) ; begin
83298: LD_INT 0
83300: PPUSH
// uc_side := 0 ;
83301: LD_ADDR_OWVAR 20
83305: PUSH
83306: LD_INT 0
83308: ST_TO_ADDR
// uc_nation := 0 ;
83309: LD_ADDR_OWVAR 21
83313: PUSH
83314: LD_INT 0
83316: ST_TO_ADDR
// hc_class := class_frog ;
83317: LD_ADDR_OWVAR 28
83321: PUSH
83322: LD_INT 19
83324: ST_TO_ADDR
// hc_gallery :=  ;
83325: LD_ADDR_OWVAR 33
83329: PUSH
83330: LD_STRING 
83332: ST_TO_ADDR
// end ;
83333: LD_VAR 0 1
83337: RET
// export function PrepareFish ( ) ; begin
83338: LD_INT 0
83340: PPUSH
// uc_side := 0 ;
83341: LD_ADDR_OWVAR 20
83345: PUSH
83346: LD_INT 0
83348: ST_TO_ADDR
// uc_nation := 0 ;
83349: LD_ADDR_OWVAR 21
83353: PUSH
83354: LD_INT 0
83356: ST_TO_ADDR
// hc_class := class_fish ;
83357: LD_ADDR_OWVAR 28
83361: PUSH
83362: LD_INT 20
83364: ST_TO_ADDR
// hc_gallery :=  ;
83365: LD_ADDR_OWVAR 33
83369: PUSH
83370: LD_STRING 
83372: ST_TO_ADDR
// end ;
83373: LD_VAR 0 1
83377: RET
// export function PrepareBird ( ) ; begin
83378: LD_INT 0
83380: PPUSH
// uc_side := 0 ;
83381: LD_ADDR_OWVAR 20
83385: PUSH
83386: LD_INT 0
83388: ST_TO_ADDR
// uc_nation := 0 ;
83389: LD_ADDR_OWVAR 21
83393: PUSH
83394: LD_INT 0
83396: ST_TO_ADDR
// hc_class := class_phororhacos ;
83397: LD_ADDR_OWVAR 28
83401: PUSH
83402: LD_INT 18
83404: ST_TO_ADDR
// hc_gallery :=  ;
83405: LD_ADDR_OWVAR 33
83409: PUSH
83410: LD_STRING 
83412: ST_TO_ADDR
// end ;
83413: LD_VAR 0 1
83417: RET
// export function PrepareHorse ( ) ; begin
83418: LD_INT 0
83420: PPUSH
// uc_side := 0 ;
83421: LD_ADDR_OWVAR 20
83425: PUSH
83426: LD_INT 0
83428: ST_TO_ADDR
// uc_nation := 0 ;
83429: LD_ADDR_OWVAR 21
83433: PUSH
83434: LD_INT 0
83436: ST_TO_ADDR
// hc_class := class_horse ;
83437: LD_ADDR_OWVAR 28
83441: PUSH
83442: LD_INT 21
83444: ST_TO_ADDR
// hc_gallery :=  ;
83445: LD_ADDR_OWVAR 33
83449: PUSH
83450: LD_STRING 
83452: ST_TO_ADDR
// end ;
83453: LD_VAR 0 1
83457: RET
// export function PrepareMastodont ( ) ; begin
83458: LD_INT 0
83460: PPUSH
// uc_side := 0 ;
83461: LD_ADDR_OWVAR 20
83465: PUSH
83466: LD_INT 0
83468: ST_TO_ADDR
// uc_nation := 0 ;
83469: LD_ADDR_OWVAR 21
83473: PUSH
83474: LD_INT 0
83476: ST_TO_ADDR
// vc_chassis := class_mastodont ;
83477: LD_ADDR_OWVAR 37
83481: PUSH
83482: LD_INT 31
83484: ST_TO_ADDR
// vc_control := control_rider ;
83485: LD_ADDR_OWVAR 38
83489: PUSH
83490: LD_INT 4
83492: ST_TO_ADDR
// end ;
83493: LD_VAR 0 1
83497: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83498: LD_INT 0
83500: PPUSH
83501: PPUSH
83502: PPUSH
// uc_side = 0 ;
83503: LD_ADDR_OWVAR 20
83507: PUSH
83508: LD_INT 0
83510: ST_TO_ADDR
// uc_nation = 0 ;
83511: LD_ADDR_OWVAR 21
83515: PUSH
83516: LD_INT 0
83518: ST_TO_ADDR
// InitHc_All ( ) ;
83519: CALL_OW 584
// InitVc ;
83523: CALL_OW 20
// if mastodonts then
83527: LD_VAR 0 6
83531: IFFALSE 83598
// for i = 1 to mastodonts do
83533: LD_ADDR_VAR 0 11
83537: PUSH
83538: DOUBLE
83539: LD_INT 1
83541: DEC
83542: ST_TO_ADDR
83543: LD_VAR 0 6
83547: PUSH
83548: FOR_TO
83549: IFFALSE 83596
// begin vc_chassis := 31 ;
83551: LD_ADDR_OWVAR 37
83555: PUSH
83556: LD_INT 31
83558: ST_TO_ADDR
// vc_control := control_rider ;
83559: LD_ADDR_OWVAR 38
83563: PUSH
83564: LD_INT 4
83566: ST_TO_ADDR
// animal := CreateVehicle ;
83567: LD_ADDR_VAR 0 12
83571: PUSH
83572: CALL_OW 45
83576: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83577: LD_VAR 0 12
83581: PPUSH
83582: LD_VAR 0 8
83586: PPUSH
83587: LD_INT 0
83589: PPUSH
83590: CALL 85726 0 3
// end ;
83594: GO 83548
83596: POP
83597: POP
// if horses then
83598: LD_VAR 0 5
83602: IFFALSE 83669
// for i = 1 to horses do
83604: LD_ADDR_VAR 0 11
83608: PUSH
83609: DOUBLE
83610: LD_INT 1
83612: DEC
83613: ST_TO_ADDR
83614: LD_VAR 0 5
83618: PUSH
83619: FOR_TO
83620: IFFALSE 83667
// begin hc_class := 21 ;
83622: LD_ADDR_OWVAR 28
83626: PUSH
83627: LD_INT 21
83629: ST_TO_ADDR
// hc_gallery :=  ;
83630: LD_ADDR_OWVAR 33
83634: PUSH
83635: LD_STRING 
83637: ST_TO_ADDR
// animal := CreateHuman ;
83638: LD_ADDR_VAR 0 12
83642: PUSH
83643: CALL_OW 44
83647: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83648: LD_VAR 0 12
83652: PPUSH
83653: LD_VAR 0 8
83657: PPUSH
83658: LD_INT 0
83660: PPUSH
83661: CALL 85726 0 3
// end ;
83665: GO 83619
83667: POP
83668: POP
// if birds then
83669: LD_VAR 0 1
83673: IFFALSE 83740
// for i = 1 to birds do
83675: LD_ADDR_VAR 0 11
83679: PUSH
83680: DOUBLE
83681: LD_INT 1
83683: DEC
83684: ST_TO_ADDR
83685: LD_VAR 0 1
83689: PUSH
83690: FOR_TO
83691: IFFALSE 83738
// begin hc_class := 18 ;
83693: LD_ADDR_OWVAR 28
83697: PUSH
83698: LD_INT 18
83700: ST_TO_ADDR
// hc_gallery =  ;
83701: LD_ADDR_OWVAR 33
83705: PUSH
83706: LD_STRING 
83708: ST_TO_ADDR
// animal := CreateHuman ;
83709: LD_ADDR_VAR 0 12
83713: PUSH
83714: CALL_OW 44
83718: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83719: LD_VAR 0 12
83723: PPUSH
83724: LD_VAR 0 8
83728: PPUSH
83729: LD_INT 0
83731: PPUSH
83732: CALL 85726 0 3
// end ;
83736: GO 83690
83738: POP
83739: POP
// if tigers then
83740: LD_VAR 0 2
83744: IFFALSE 83828
// for i = 1 to tigers do
83746: LD_ADDR_VAR 0 11
83750: PUSH
83751: DOUBLE
83752: LD_INT 1
83754: DEC
83755: ST_TO_ADDR
83756: LD_VAR 0 2
83760: PUSH
83761: FOR_TO
83762: IFFALSE 83826
// begin hc_class = class_tiger ;
83764: LD_ADDR_OWVAR 28
83768: PUSH
83769: LD_INT 14
83771: ST_TO_ADDR
// hc_gallery =  ;
83772: LD_ADDR_OWVAR 33
83776: PUSH
83777: LD_STRING 
83779: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83780: LD_ADDR_OWVAR 35
83784: PUSH
83785: LD_INT 7
83787: NEG
83788: PPUSH
83789: LD_INT 7
83791: PPUSH
83792: CALL_OW 12
83796: ST_TO_ADDR
// animal := CreateHuman ;
83797: LD_ADDR_VAR 0 12
83801: PUSH
83802: CALL_OW 44
83806: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83807: LD_VAR 0 12
83811: PPUSH
83812: LD_VAR 0 8
83816: PPUSH
83817: LD_INT 0
83819: PPUSH
83820: CALL 85726 0 3
// end ;
83824: GO 83761
83826: POP
83827: POP
// if apemans then
83828: LD_VAR 0 3
83832: IFFALSE 83955
// for i = 1 to apemans do
83834: LD_ADDR_VAR 0 11
83838: PUSH
83839: DOUBLE
83840: LD_INT 1
83842: DEC
83843: ST_TO_ADDR
83844: LD_VAR 0 3
83848: PUSH
83849: FOR_TO
83850: IFFALSE 83953
// begin hc_class = class_apeman ;
83852: LD_ADDR_OWVAR 28
83856: PUSH
83857: LD_INT 12
83859: ST_TO_ADDR
// hc_gallery =  ;
83860: LD_ADDR_OWVAR 33
83864: PUSH
83865: LD_STRING 
83867: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83868: LD_ADDR_OWVAR 35
83872: PUSH
83873: LD_INT 2
83875: NEG
83876: PPUSH
83877: LD_INT 2
83879: PPUSH
83880: CALL_OW 12
83884: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83885: LD_ADDR_OWVAR 31
83889: PUSH
83890: LD_INT 1
83892: PPUSH
83893: LD_INT 3
83895: PPUSH
83896: CALL_OW 12
83900: PUSH
83901: LD_INT 1
83903: PPUSH
83904: LD_INT 3
83906: PPUSH
83907: CALL_OW 12
83911: PUSH
83912: LD_INT 0
83914: PUSH
83915: LD_INT 0
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: LIST
83922: LIST
83923: ST_TO_ADDR
// animal := CreateHuman ;
83924: LD_ADDR_VAR 0 12
83928: PUSH
83929: CALL_OW 44
83933: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83934: LD_VAR 0 12
83938: PPUSH
83939: LD_VAR 0 8
83943: PPUSH
83944: LD_INT 0
83946: PPUSH
83947: CALL 85726 0 3
// end ;
83951: GO 83849
83953: POP
83954: POP
// if enchidnas then
83955: LD_VAR 0 4
83959: IFFALSE 84026
// for i = 1 to enchidnas do
83961: LD_ADDR_VAR 0 11
83965: PUSH
83966: DOUBLE
83967: LD_INT 1
83969: DEC
83970: ST_TO_ADDR
83971: LD_VAR 0 4
83975: PUSH
83976: FOR_TO
83977: IFFALSE 84024
// begin hc_class = 13 ;
83979: LD_ADDR_OWVAR 28
83983: PUSH
83984: LD_INT 13
83986: ST_TO_ADDR
// hc_gallery =  ;
83987: LD_ADDR_OWVAR 33
83991: PUSH
83992: LD_STRING 
83994: ST_TO_ADDR
// animal := CreateHuman ;
83995: LD_ADDR_VAR 0 12
83999: PUSH
84000: CALL_OW 44
84004: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84005: LD_VAR 0 12
84009: PPUSH
84010: LD_VAR 0 8
84014: PPUSH
84015: LD_INT 0
84017: PPUSH
84018: CALL 85726 0 3
// end ;
84022: GO 83976
84024: POP
84025: POP
// if fishes then
84026: LD_VAR 0 7
84030: IFFALSE 84097
// for i = 1 to fishes do
84032: LD_ADDR_VAR 0 11
84036: PUSH
84037: DOUBLE
84038: LD_INT 1
84040: DEC
84041: ST_TO_ADDR
84042: LD_VAR 0 7
84046: PUSH
84047: FOR_TO
84048: IFFALSE 84095
// begin hc_class = 20 ;
84050: LD_ADDR_OWVAR 28
84054: PUSH
84055: LD_INT 20
84057: ST_TO_ADDR
// hc_gallery =  ;
84058: LD_ADDR_OWVAR 33
84062: PUSH
84063: LD_STRING 
84065: ST_TO_ADDR
// animal := CreateHuman ;
84066: LD_ADDR_VAR 0 12
84070: PUSH
84071: CALL_OW 44
84075: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84076: LD_VAR 0 12
84080: PPUSH
84081: LD_VAR 0 9
84085: PPUSH
84086: LD_INT 0
84088: PPUSH
84089: CALL 85726 0 3
// end ;
84093: GO 84047
84095: POP
84096: POP
// end ;
84097: LD_VAR 0 10
84101: RET
// export function WantHeal ( sci , unit ) ; begin
84102: LD_INT 0
84104: PPUSH
// if GetTaskList ( sci ) > 0 then
84105: LD_VAR 0 1
84109: PPUSH
84110: CALL_OW 437
84114: PUSH
84115: LD_INT 0
84117: GREATER
84118: IFFALSE 84188
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84120: LD_VAR 0 1
84124: PPUSH
84125: CALL_OW 437
84129: PUSH
84130: LD_INT 1
84132: ARRAY
84133: PUSH
84134: LD_INT 1
84136: ARRAY
84137: PUSH
84138: LD_STRING l
84140: EQUAL
84141: PUSH
84142: LD_VAR 0 1
84146: PPUSH
84147: CALL_OW 437
84151: PUSH
84152: LD_INT 1
84154: ARRAY
84155: PUSH
84156: LD_INT 4
84158: ARRAY
84159: PUSH
84160: LD_VAR 0 2
84164: EQUAL
84165: AND
84166: IFFALSE 84178
// result := true else
84168: LD_ADDR_VAR 0 3
84172: PUSH
84173: LD_INT 1
84175: ST_TO_ADDR
84176: GO 84186
// result := false ;
84178: LD_ADDR_VAR 0 3
84182: PUSH
84183: LD_INT 0
84185: ST_TO_ADDR
// end else
84186: GO 84196
// result := false ;
84188: LD_ADDR_VAR 0 3
84192: PUSH
84193: LD_INT 0
84195: ST_TO_ADDR
// end ;
84196: LD_VAR 0 3
84200: RET
// export function HealTarget ( sci ) ; begin
84201: LD_INT 0
84203: PPUSH
// if not sci then
84204: LD_VAR 0 1
84208: NOT
84209: IFFALSE 84213
// exit ;
84211: GO 84278
// result := 0 ;
84213: LD_ADDR_VAR 0 2
84217: PUSH
84218: LD_INT 0
84220: ST_TO_ADDR
// if GetTaskList ( sci ) then
84221: LD_VAR 0 1
84225: PPUSH
84226: CALL_OW 437
84230: IFFALSE 84278
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84232: LD_VAR 0 1
84236: PPUSH
84237: CALL_OW 437
84241: PUSH
84242: LD_INT 1
84244: ARRAY
84245: PUSH
84246: LD_INT 1
84248: ARRAY
84249: PUSH
84250: LD_STRING l
84252: EQUAL
84253: IFFALSE 84278
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84255: LD_ADDR_VAR 0 2
84259: PUSH
84260: LD_VAR 0 1
84264: PPUSH
84265: CALL_OW 437
84269: PUSH
84270: LD_INT 1
84272: ARRAY
84273: PUSH
84274: LD_INT 4
84276: ARRAY
84277: ST_TO_ADDR
// end ;
84278: LD_VAR 0 2
84282: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84283: LD_INT 0
84285: PPUSH
84286: PPUSH
84287: PPUSH
84288: PPUSH
// if not base_units then
84289: LD_VAR 0 1
84293: NOT
84294: IFFALSE 84298
// exit ;
84296: GO 84385
// result := false ;
84298: LD_ADDR_VAR 0 2
84302: PUSH
84303: LD_INT 0
84305: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84306: LD_ADDR_VAR 0 5
84310: PUSH
84311: LD_VAR 0 1
84315: PPUSH
84316: LD_INT 21
84318: PUSH
84319: LD_INT 3
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: PPUSH
84326: CALL_OW 72
84330: ST_TO_ADDR
// if not tmp then
84331: LD_VAR 0 5
84335: NOT
84336: IFFALSE 84340
// exit ;
84338: GO 84385
// for i in tmp do
84340: LD_ADDR_VAR 0 3
84344: PUSH
84345: LD_VAR 0 5
84349: PUSH
84350: FOR_IN
84351: IFFALSE 84383
// begin result := EnemyInRange ( i , 22 ) ;
84353: LD_ADDR_VAR 0 2
84357: PUSH
84358: LD_VAR 0 3
84362: PPUSH
84363: LD_INT 22
84365: PPUSH
84366: CALL 81972 0 2
84370: ST_TO_ADDR
// if result then
84371: LD_VAR 0 2
84375: IFFALSE 84381
// exit ;
84377: POP
84378: POP
84379: GO 84385
// end ;
84381: GO 84350
84383: POP
84384: POP
// end ;
84385: LD_VAR 0 2
84389: RET
// export function FilterByTag ( units , tag ) ; begin
84390: LD_INT 0
84392: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
84393: LD_ADDR_VAR 0 3
84397: PUSH
84398: LD_VAR 0 1
84402: PPUSH
84403: LD_INT 120
84405: PUSH
84406: LD_VAR 0 2
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PPUSH
84415: CALL_OW 72
84419: ST_TO_ADDR
// end ;
84420: LD_VAR 0 3
84424: RET
// export function IsDriver ( un ) ; begin
84425: LD_INT 0
84427: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84428: LD_ADDR_VAR 0 2
84432: PUSH
84433: LD_VAR 0 1
84437: PUSH
84438: LD_INT 55
84440: PUSH
84441: EMPTY
84442: LIST
84443: PPUSH
84444: CALL_OW 69
84448: IN
84449: ST_TO_ADDR
// end ;
84450: LD_VAR 0 2
84454: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84455: LD_INT 0
84457: PPUSH
84458: PPUSH
// list := [ ] ;
84459: LD_ADDR_VAR 0 5
84463: PUSH
84464: EMPTY
84465: ST_TO_ADDR
// case d of 0 :
84466: LD_VAR 0 3
84470: PUSH
84471: LD_INT 0
84473: DOUBLE
84474: EQUAL
84475: IFTRUE 84479
84477: GO 84612
84479: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84480: LD_ADDR_VAR 0 5
84484: PUSH
84485: LD_VAR 0 1
84489: PUSH
84490: LD_INT 4
84492: MINUS
84493: PUSH
84494: LD_VAR 0 2
84498: PUSH
84499: LD_INT 4
84501: MINUS
84502: PUSH
84503: LD_INT 2
84505: PUSH
84506: EMPTY
84507: LIST
84508: LIST
84509: LIST
84510: PUSH
84511: LD_VAR 0 1
84515: PUSH
84516: LD_INT 3
84518: MINUS
84519: PUSH
84520: LD_VAR 0 2
84524: PUSH
84525: LD_INT 1
84527: PUSH
84528: EMPTY
84529: LIST
84530: LIST
84531: LIST
84532: PUSH
84533: LD_VAR 0 1
84537: PUSH
84538: LD_INT 4
84540: PLUS
84541: PUSH
84542: LD_VAR 0 2
84546: PUSH
84547: LD_INT 4
84549: PUSH
84550: EMPTY
84551: LIST
84552: LIST
84553: LIST
84554: PUSH
84555: LD_VAR 0 1
84559: PUSH
84560: LD_INT 3
84562: PLUS
84563: PUSH
84564: LD_VAR 0 2
84568: PUSH
84569: LD_INT 3
84571: PLUS
84572: PUSH
84573: LD_INT 5
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: LIST
84580: PUSH
84581: LD_VAR 0 1
84585: PUSH
84586: LD_VAR 0 2
84590: PUSH
84591: LD_INT 4
84593: PLUS
84594: PUSH
84595: LD_INT 0
84597: PUSH
84598: EMPTY
84599: LIST
84600: LIST
84601: LIST
84602: PUSH
84603: EMPTY
84604: LIST
84605: LIST
84606: LIST
84607: LIST
84608: LIST
84609: ST_TO_ADDR
// end ; 1 :
84610: GO 85310
84612: LD_INT 1
84614: DOUBLE
84615: EQUAL
84616: IFTRUE 84620
84618: GO 84753
84620: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84621: LD_ADDR_VAR 0 5
84625: PUSH
84626: LD_VAR 0 1
84630: PUSH
84631: LD_VAR 0 2
84635: PUSH
84636: LD_INT 4
84638: MINUS
84639: PUSH
84640: LD_INT 3
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: LIST
84647: PUSH
84648: LD_VAR 0 1
84652: PUSH
84653: LD_INT 3
84655: MINUS
84656: PUSH
84657: LD_VAR 0 2
84661: PUSH
84662: LD_INT 3
84664: MINUS
84665: PUSH
84666: LD_INT 2
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: LIST
84673: PUSH
84674: LD_VAR 0 1
84678: PUSH
84679: LD_INT 4
84681: MINUS
84682: PUSH
84683: LD_VAR 0 2
84687: PUSH
84688: LD_INT 1
84690: PUSH
84691: EMPTY
84692: LIST
84693: LIST
84694: LIST
84695: PUSH
84696: LD_VAR 0 1
84700: PUSH
84701: LD_VAR 0 2
84705: PUSH
84706: LD_INT 3
84708: PLUS
84709: PUSH
84710: LD_INT 0
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: LIST
84717: PUSH
84718: LD_VAR 0 1
84722: PUSH
84723: LD_INT 4
84725: PLUS
84726: PUSH
84727: LD_VAR 0 2
84731: PUSH
84732: LD_INT 4
84734: PLUS
84735: PUSH
84736: LD_INT 5
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: LIST
84743: PUSH
84744: EMPTY
84745: LIST
84746: LIST
84747: LIST
84748: LIST
84749: LIST
84750: ST_TO_ADDR
// end ; 2 :
84751: GO 85310
84753: LD_INT 2
84755: DOUBLE
84756: EQUAL
84757: IFTRUE 84761
84759: GO 84890
84761: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84762: LD_ADDR_VAR 0 5
84766: PUSH
84767: LD_VAR 0 1
84771: PUSH
84772: LD_VAR 0 2
84776: PUSH
84777: LD_INT 3
84779: MINUS
84780: PUSH
84781: LD_INT 3
84783: PUSH
84784: EMPTY
84785: LIST
84786: LIST
84787: LIST
84788: PUSH
84789: LD_VAR 0 1
84793: PUSH
84794: LD_INT 4
84796: PLUS
84797: PUSH
84798: LD_VAR 0 2
84802: PUSH
84803: LD_INT 4
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: LIST
84810: PUSH
84811: LD_VAR 0 1
84815: PUSH
84816: LD_VAR 0 2
84820: PUSH
84821: LD_INT 4
84823: PLUS
84824: PUSH
84825: LD_INT 0
84827: PUSH
84828: EMPTY
84829: LIST
84830: LIST
84831: LIST
84832: PUSH
84833: LD_VAR 0 1
84837: PUSH
84838: LD_INT 3
84840: MINUS
84841: PUSH
84842: LD_VAR 0 2
84846: PUSH
84847: LD_INT 1
84849: PUSH
84850: EMPTY
84851: LIST
84852: LIST
84853: LIST
84854: PUSH
84855: LD_VAR 0 1
84859: PUSH
84860: LD_INT 4
84862: MINUS
84863: PUSH
84864: LD_VAR 0 2
84868: PUSH
84869: LD_INT 4
84871: MINUS
84872: PUSH
84873: LD_INT 2
84875: PUSH
84876: EMPTY
84877: LIST
84878: LIST
84879: LIST
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: LIST
84885: LIST
84886: LIST
84887: ST_TO_ADDR
// end ; 3 :
84888: GO 85310
84890: LD_INT 3
84892: DOUBLE
84893: EQUAL
84894: IFTRUE 84898
84896: GO 85031
84898: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84899: LD_ADDR_VAR 0 5
84903: PUSH
84904: LD_VAR 0 1
84908: PUSH
84909: LD_INT 3
84911: PLUS
84912: PUSH
84913: LD_VAR 0 2
84917: PUSH
84918: LD_INT 4
84920: PUSH
84921: EMPTY
84922: LIST
84923: LIST
84924: LIST
84925: PUSH
84926: LD_VAR 0 1
84930: PUSH
84931: LD_INT 4
84933: PLUS
84934: PUSH
84935: LD_VAR 0 2
84939: PUSH
84940: LD_INT 4
84942: PLUS
84943: PUSH
84944: LD_INT 5
84946: PUSH
84947: EMPTY
84948: LIST
84949: LIST
84950: LIST
84951: PUSH
84952: LD_VAR 0 1
84956: PUSH
84957: LD_INT 4
84959: MINUS
84960: PUSH
84961: LD_VAR 0 2
84965: PUSH
84966: LD_INT 1
84968: PUSH
84969: EMPTY
84970: LIST
84971: LIST
84972: LIST
84973: PUSH
84974: LD_VAR 0 1
84978: PUSH
84979: LD_VAR 0 2
84983: PUSH
84984: LD_INT 4
84986: MINUS
84987: PUSH
84988: LD_INT 3
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: LIST
84995: PUSH
84996: LD_VAR 0 1
85000: PUSH
85001: LD_INT 3
85003: MINUS
85004: PUSH
85005: LD_VAR 0 2
85009: PUSH
85010: LD_INT 3
85012: MINUS
85013: PUSH
85014: LD_INT 2
85016: PUSH
85017: EMPTY
85018: LIST
85019: LIST
85020: LIST
85021: PUSH
85022: EMPTY
85023: LIST
85024: LIST
85025: LIST
85026: LIST
85027: LIST
85028: ST_TO_ADDR
// end ; 4 :
85029: GO 85310
85031: LD_INT 4
85033: DOUBLE
85034: EQUAL
85035: IFTRUE 85039
85037: GO 85172
85039: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
85040: LD_ADDR_VAR 0 5
85044: PUSH
85045: LD_VAR 0 1
85049: PUSH
85050: LD_VAR 0 2
85054: PUSH
85055: LD_INT 4
85057: PLUS
85058: PUSH
85059: LD_INT 0
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: LIST
85066: PUSH
85067: LD_VAR 0 1
85071: PUSH
85072: LD_INT 3
85074: PLUS
85075: PUSH
85076: LD_VAR 0 2
85080: PUSH
85081: LD_INT 3
85083: PLUS
85084: PUSH
85085: LD_INT 5
85087: PUSH
85088: EMPTY
85089: LIST
85090: LIST
85091: LIST
85092: PUSH
85093: LD_VAR 0 1
85097: PUSH
85098: LD_INT 4
85100: PLUS
85101: PUSH
85102: LD_VAR 0 2
85106: PUSH
85107: LD_INT 4
85109: PUSH
85110: EMPTY
85111: LIST
85112: LIST
85113: LIST
85114: PUSH
85115: LD_VAR 0 1
85119: PUSH
85120: LD_VAR 0 2
85124: PUSH
85125: LD_INT 3
85127: MINUS
85128: PUSH
85129: LD_INT 3
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: LIST
85136: PUSH
85137: LD_VAR 0 1
85141: PUSH
85142: LD_INT 4
85144: MINUS
85145: PUSH
85146: LD_VAR 0 2
85150: PUSH
85151: LD_INT 4
85153: MINUS
85154: PUSH
85155: LD_INT 2
85157: PUSH
85158: EMPTY
85159: LIST
85160: LIST
85161: LIST
85162: PUSH
85163: EMPTY
85164: LIST
85165: LIST
85166: LIST
85167: LIST
85168: LIST
85169: ST_TO_ADDR
// end ; 5 :
85170: GO 85310
85172: LD_INT 5
85174: DOUBLE
85175: EQUAL
85176: IFTRUE 85180
85178: GO 85309
85180: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85181: LD_ADDR_VAR 0 5
85185: PUSH
85186: LD_VAR 0 1
85190: PUSH
85191: LD_INT 4
85193: MINUS
85194: PUSH
85195: LD_VAR 0 2
85199: PUSH
85200: LD_INT 1
85202: PUSH
85203: EMPTY
85204: LIST
85205: LIST
85206: LIST
85207: PUSH
85208: LD_VAR 0 1
85212: PUSH
85213: LD_VAR 0 2
85217: PUSH
85218: LD_INT 4
85220: MINUS
85221: PUSH
85222: LD_INT 3
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: LIST
85229: PUSH
85230: LD_VAR 0 1
85234: PUSH
85235: LD_INT 4
85237: PLUS
85238: PUSH
85239: LD_VAR 0 2
85243: PUSH
85244: LD_INT 4
85246: PLUS
85247: PUSH
85248: LD_INT 5
85250: PUSH
85251: EMPTY
85252: LIST
85253: LIST
85254: LIST
85255: PUSH
85256: LD_VAR 0 1
85260: PUSH
85261: LD_INT 3
85263: PLUS
85264: PUSH
85265: LD_VAR 0 2
85269: PUSH
85270: LD_INT 4
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: LIST
85277: PUSH
85278: LD_VAR 0 1
85282: PUSH
85283: LD_VAR 0 2
85287: PUSH
85288: LD_INT 3
85290: PLUS
85291: PUSH
85292: LD_INT 0
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: LIST
85299: PUSH
85300: EMPTY
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: ST_TO_ADDR
// end ; end ;
85307: GO 85310
85309: POP
// result := list ;
85310: LD_ADDR_VAR 0 4
85314: PUSH
85315: LD_VAR 0 5
85319: ST_TO_ADDR
// end ;
85320: LD_VAR 0 4
85324: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85325: LD_INT 0
85327: PPUSH
85328: PPUSH
85329: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85330: LD_VAR 0 1
85334: NOT
85335: PUSH
85336: LD_VAR 0 2
85340: PUSH
85341: LD_INT 1
85343: PUSH
85344: LD_INT 2
85346: PUSH
85347: LD_INT 3
85349: PUSH
85350: LD_INT 4
85352: PUSH
85353: EMPTY
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: IN
85359: NOT
85360: OR
85361: IFFALSE 85365
// exit ;
85363: GO 85448
// tmp := [ ] ;
85365: LD_ADDR_VAR 0 5
85369: PUSH
85370: EMPTY
85371: ST_TO_ADDR
// for i in units do
85372: LD_ADDR_VAR 0 4
85376: PUSH
85377: LD_VAR 0 1
85381: PUSH
85382: FOR_IN
85383: IFFALSE 85417
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
85385: LD_ADDR_VAR 0 5
85389: PUSH
85390: LD_VAR 0 5
85394: PPUSH
85395: LD_VAR 0 4
85399: PPUSH
85400: LD_VAR 0 2
85404: PPUSH
85405: CALL_OW 259
85409: PPUSH
85410: CALL 86821 0 2
85414: ST_TO_ADDR
85415: GO 85382
85417: POP
85418: POP
// if not tmp then
85419: LD_VAR 0 5
85423: NOT
85424: IFFALSE 85428
// exit ;
85426: GO 85448
// result := SortListByListDesc ( units , tmp ) ;
85428: LD_ADDR_VAR 0 3
85432: PUSH
85433: LD_VAR 0 1
85437: PPUSH
85438: LD_VAR 0 5
85442: PPUSH
85443: CALL_OW 77
85447: ST_TO_ADDR
// end ;
85448: LD_VAR 0 3
85452: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85453: LD_INT 0
85455: PPUSH
85456: PPUSH
85457: PPUSH
// result := false ;
85458: LD_ADDR_VAR 0 3
85462: PUSH
85463: LD_INT 0
85465: ST_TO_ADDR
// if not building then
85466: LD_VAR 0 2
85470: NOT
85471: IFFALSE 85475
// exit ;
85473: GO 85613
// x := GetX ( building ) ;
85475: LD_ADDR_VAR 0 4
85479: PUSH
85480: LD_VAR 0 2
85484: PPUSH
85485: CALL_OW 250
85489: ST_TO_ADDR
// y := GetY ( building ) ;
85490: LD_ADDR_VAR 0 5
85494: PUSH
85495: LD_VAR 0 2
85499: PPUSH
85500: CALL_OW 251
85504: ST_TO_ADDR
// if not x or not y then
85505: LD_VAR 0 4
85509: NOT
85510: PUSH
85511: LD_VAR 0 5
85515: NOT
85516: OR
85517: IFFALSE 85521
// exit ;
85519: GO 85613
// if GetTaskList ( unit ) then
85521: LD_VAR 0 1
85525: PPUSH
85526: CALL_OW 437
85530: IFFALSE 85613
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85532: LD_STRING e
85534: PUSH
85535: LD_VAR 0 1
85539: PPUSH
85540: CALL_OW 437
85544: PUSH
85545: LD_INT 1
85547: ARRAY
85548: PUSH
85549: LD_INT 1
85551: ARRAY
85552: EQUAL
85553: PUSH
85554: LD_VAR 0 4
85558: PUSH
85559: LD_VAR 0 1
85563: PPUSH
85564: CALL_OW 437
85568: PUSH
85569: LD_INT 1
85571: ARRAY
85572: PUSH
85573: LD_INT 2
85575: ARRAY
85576: EQUAL
85577: AND
85578: PUSH
85579: LD_VAR 0 5
85583: PUSH
85584: LD_VAR 0 1
85588: PPUSH
85589: CALL_OW 437
85593: PUSH
85594: LD_INT 1
85596: ARRAY
85597: PUSH
85598: LD_INT 3
85600: ARRAY
85601: EQUAL
85602: AND
85603: IFFALSE 85613
// result := true end ;
85605: LD_ADDR_VAR 0 3
85609: PUSH
85610: LD_INT 1
85612: ST_TO_ADDR
// end ;
85613: LD_VAR 0 3
85617: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85618: LD_INT 0
85620: PPUSH
// result := false ;
85621: LD_ADDR_VAR 0 4
85625: PUSH
85626: LD_INT 0
85628: ST_TO_ADDR
// if GetTaskList ( unit ) then
85629: LD_VAR 0 1
85633: PPUSH
85634: CALL_OW 437
85638: IFFALSE 85721
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85640: LD_STRING M
85642: PUSH
85643: LD_VAR 0 1
85647: PPUSH
85648: CALL_OW 437
85652: PUSH
85653: LD_INT 1
85655: ARRAY
85656: PUSH
85657: LD_INT 1
85659: ARRAY
85660: EQUAL
85661: PUSH
85662: LD_VAR 0 2
85666: PUSH
85667: LD_VAR 0 1
85671: PPUSH
85672: CALL_OW 437
85676: PUSH
85677: LD_INT 1
85679: ARRAY
85680: PUSH
85681: LD_INT 2
85683: ARRAY
85684: EQUAL
85685: AND
85686: PUSH
85687: LD_VAR 0 3
85691: PUSH
85692: LD_VAR 0 1
85696: PPUSH
85697: CALL_OW 437
85701: PUSH
85702: LD_INT 1
85704: ARRAY
85705: PUSH
85706: LD_INT 3
85708: ARRAY
85709: EQUAL
85710: AND
85711: IFFALSE 85721
// result := true ;
85713: LD_ADDR_VAR 0 4
85717: PUSH
85718: LD_INT 1
85720: ST_TO_ADDR
// end ; end ;
85721: LD_VAR 0 4
85725: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85726: LD_INT 0
85728: PPUSH
85729: PPUSH
85730: PPUSH
85731: PPUSH
// if not unit or not area then
85732: LD_VAR 0 1
85736: NOT
85737: PUSH
85738: LD_VAR 0 2
85742: NOT
85743: OR
85744: IFFALSE 85748
// exit ;
85746: GO 85924
// tmp := AreaToList ( area , i ) ;
85748: LD_ADDR_VAR 0 6
85752: PUSH
85753: LD_VAR 0 2
85757: PPUSH
85758: LD_VAR 0 5
85762: PPUSH
85763: CALL_OW 517
85767: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85768: LD_ADDR_VAR 0 5
85772: PUSH
85773: DOUBLE
85774: LD_INT 1
85776: DEC
85777: ST_TO_ADDR
85778: LD_VAR 0 6
85782: PUSH
85783: LD_INT 1
85785: ARRAY
85786: PUSH
85787: FOR_TO
85788: IFFALSE 85922
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85790: LD_ADDR_VAR 0 7
85794: PUSH
85795: LD_VAR 0 6
85799: PUSH
85800: LD_INT 1
85802: ARRAY
85803: PUSH
85804: LD_VAR 0 5
85808: ARRAY
85809: PUSH
85810: LD_VAR 0 6
85814: PUSH
85815: LD_INT 2
85817: ARRAY
85818: PUSH
85819: LD_VAR 0 5
85823: ARRAY
85824: PUSH
85825: EMPTY
85826: LIST
85827: LIST
85828: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
85829: LD_INT 92
85831: PUSH
85832: LD_VAR 0 7
85836: PUSH
85837: LD_INT 1
85839: ARRAY
85840: PUSH
85841: LD_VAR 0 7
85845: PUSH
85846: LD_INT 2
85848: ARRAY
85849: PUSH
85850: LD_INT 2
85852: PUSH
85853: EMPTY
85854: LIST
85855: LIST
85856: LIST
85857: LIST
85858: PPUSH
85859: CALL_OW 69
85863: PUSH
85864: LD_INT 0
85866: EQUAL
85867: IFFALSE 85920
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85869: LD_VAR 0 1
85873: PPUSH
85874: LD_VAR 0 7
85878: PUSH
85879: LD_INT 1
85881: ARRAY
85882: PPUSH
85883: LD_VAR 0 7
85887: PUSH
85888: LD_INT 2
85890: ARRAY
85891: PPUSH
85892: LD_VAR 0 3
85896: PPUSH
85897: CALL_OW 48
// result := IsPlaced ( unit ) ;
85901: LD_ADDR_VAR 0 4
85905: PUSH
85906: LD_VAR 0 1
85910: PPUSH
85911: CALL_OW 305
85915: ST_TO_ADDR
// exit ;
85916: POP
85917: POP
85918: GO 85924
// end ; end ;
85920: GO 85787
85922: POP
85923: POP
// end ;
85924: LD_VAR 0 4
85928: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85929: LD_INT 0
85931: PPUSH
85932: PPUSH
85933: PPUSH
// if not side or side > 8 then
85934: LD_VAR 0 1
85938: NOT
85939: PUSH
85940: LD_VAR 0 1
85944: PUSH
85945: LD_INT 8
85947: GREATER
85948: OR
85949: IFFALSE 85953
// exit ;
85951: GO 86140
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85953: LD_ADDR_VAR 0 4
85957: PUSH
85958: LD_INT 22
85960: PUSH
85961: LD_VAR 0 1
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: PUSH
85970: LD_INT 21
85972: PUSH
85973: LD_INT 3
85975: PUSH
85976: EMPTY
85977: LIST
85978: LIST
85979: PUSH
85980: EMPTY
85981: LIST
85982: LIST
85983: PPUSH
85984: CALL_OW 69
85988: ST_TO_ADDR
// if not tmp then
85989: LD_VAR 0 4
85993: NOT
85994: IFFALSE 85998
// exit ;
85996: GO 86140
// enable_addtolog := true ;
85998: LD_ADDR_OWVAR 81
86002: PUSH
86003: LD_INT 1
86005: ST_TO_ADDR
// AddToLog ( [ ) ;
86006: LD_STRING [
86008: PPUSH
86009: CALL_OW 561
// for i in tmp do
86013: LD_ADDR_VAR 0 3
86017: PUSH
86018: LD_VAR 0 4
86022: PUSH
86023: FOR_IN
86024: IFFALSE 86131
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
86026: LD_STRING [
86028: PUSH
86029: LD_VAR 0 3
86033: PPUSH
86034: CALL_OW 266
86038: STR
86039: PUSH
86040: LD_STRING , 
86042: STR
86043: PUSH
86044: LD_VAR 0 3
86048: PPUSH
86049: CALL_OW 250
86053: STR
86054: PUSH
86055: LD_STRING , 
86057: STR
86058: PUSH
86059: LD_VAR 0 3
86063: PPUSH
86064: CALL_OW 251
86068: STR
86069: PUSH
86070: LD_STRING , 
86072: STR
86073: PUSH
86074: LD_VAR 0 3
86078: PPUSH
86079: CALL_OW 254
86083: STR
86084: PUSH
86085: LD_STRING , 
86087: STR
86088: PUSH
86089: LD_VAR 0 3
86093: PPUSH
86094: LD_INT 1
86096: PPUSH
86097: CALL_OW 268
86101: STR
86102: PUSH
86103: LD_STRING , 
86105: STR
86106: PUSH
86107: LD_VAR 0 3
86111: PPUSH
86112: LD_INT 2
86114: PPUSH
86115: CALL_OW 268
86119: STR
86120: PUSH
86121: LD_STRING ],
86123: STR
86124: PPUSH
86125: CALL_OW 561
// end ;
86129: GO 86023
86131: POP
86132: POP
// AddToLog ( ]; ) ;
86133: LD_STRING ];
86135: PPUSH
86136: CALL_OW 561
// end ;
86140: LD_VAR 0 2
86144: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
86145: LD_INT 0
86147: PPUSH
86148: PPUSH
86149: PPUSH
86150: PPUSH
86151: PPUSH
// if not area or not rate or not max then
86152: LD_VAR 0 1
86156: NOT
86157: PUSH
86158: LD_VAR 0 2
86162: NOT
86163: OR
86164: PUSH
86165: LD_VAR 0 4
86169: NOT
86170: OR
86171: IFFALSE 86175
// exit ;
86173: GO 86364
// while 1 do
86175: LD_INT 1
86177: IFFALSE 86364
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
86179: LD_ADDR_VAR 0 9
86183: PUSH
86184: LD_VAR 0 1
86188: PPUSH
86189: LD_INT 1
86191: PPUSH
86192: CALL_OW 287
86196: PUSH
86197: LD_INT 10
86199: MUL
86200: ST_TO_ADDR
// r := rate / 10 ;
86201: LD_ADDR_VAR 0 7
86205: PUSH
86206: LD_VAR 0 2
86210: PUSH
86211: LD_INT 10
86213: DIVREAL
86214: ST_TO_ADDR
// time := 1 1$00 ;
86215: LD_ADDR_VAR 0 8
86219: PUSH
86220: LD_INT 2100
86222: ST_TO_ADDR
// if amount < min then
86223: LD_VAR 0 9
86227: PUSH
86228: LD_VAR 0 3
86232: LESS
86233: IFFALSE 86251
// r := r * 2 else
86235: LD_ADDR_VAR 0 7
86239: PUSH
86240: LD_VAR 0 7
86244: PUSH
86245: LD_INT 2
86247: MUL
86248: ST_TO_ADDR
86249: GO 86277
// if amount > max then
86251: LD_VAR 0 9
86255: PUSH
86256: LD_VAR 0 4
86260: GREATER
86261: IFFALSE 86277
// r := r / 2 ;
86263: LD_ADDR_VAR 0 7
86267: PUSH
86268: LD_VAR 0 7
86272: PUSH
86273: LD_INT 2
86275: DIVREAL
86276: ST_TO_ADDR
// time := time / r ;
86277: LD_ADDR_VAR 0 8
86281: PUSH
86282: LD_VAR 0 8
86286: PUSH
86287: LD_VAR 0 7
86291: DIVREAL
86292: ST_TO_ADDR
// if time < 0 then
86293: LD_VAR 0 8
86297: PUSH
86298: LD_INT 0
86300: LESS
86301: IFFALSE 86318
// time := time * - 1 ;
86303: LD_ADDR_VAR 0 8
86307: PUSH
86308: LD_VAR 0 8
86312: PUSH
86313: LD_INT 1
86315: NEG
86316: MUL
86317: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
86318: LD_VAR 0 8
86322: PUSH
86323: LD_INT 35
86325: PPUSH
86326: LD_INT 875
86328: PPUSH
86329: CALL_OW 12
86333: PLUS
86334: PPUSH
86335: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86339: LD_INT 1
86341: PPUSH
86342: LD_INT 5
86344: PPUSH
86345: CALL_OW 12
86349: PPUSH
86350: LD_VAR 0 1
86354: PPUSH
86355: LD_INT 1
86357: PPUSH
86358: CALL_OW 55
// end ;
86362: GO 86175
// end ;
86364: LD_VAR 0 5
86368: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86369: LD_INT 0
86371: PPUSH
86372: PPUSH
86373: PPUSH
86374: PPUSH
86375: PPUSH
86376: PPUSH
86377: PPUSH
86378: PPUSH
// if not turrets or not factories then
86379: LD_VAR 0 1
86383: NOT
86384: PUSH
86385: LD_VAR 0 2
86389: NOT
86390: OR
86391: IFFALSE 86395
// exit ;
86393: GO 86702
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86395: LD_ADDR_VAR 0 10
86399: PUSH
86400: LD_INT 5
86402: PUSH
86403: LD_INT 6
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: PUSH
86410: LD_INT 2
86412: PUSH
86413: LD_INT 4
86415: PUSH
86416: EMPTY
86417: LIST
86418: LIST
86419: PUSH
86420: LD_INT 3
86422: PUSH
86423: LD_INT 5
86425: PUSH
86426: EMPTY
86427: LIST
86428: LIST
86429: PUSH
86430: EMPTY
86431: LIST
86432: LIST
86433: LIST
86434: PUSH
86435: LD_INT 24
86437: PUSH
86438: LD_INT 25
86440: PUSH
86441: EMPTY
86442: LIST
86443: LIST
86444: PUSH
86445: LD_INT 23
86447: PUSH
86448: LD_INT 27
86450: PUSH
86451: EMPTY
86452: LIST
86453: LIST
86454: PUSH
86455: EMPTY
86456: LIST
86457: LIST
86458: PUSH
86459: LD_INT 42
86461: PUSH
86462: LD_INT 43
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 44
86471: PUSH
86472: LD_INT 46
86474: PUSH
86475: EMPTY
86476: LIST
86477: LIST
86478: PUSH
86479: LD_INT 45
86481: PUSH
86482: LD_INT 47
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: EMPTY
86490: LIST
86491: LIST
86492: LIST
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: LIST
86498: ST_TO_ADDR
// result := [ ] ;
86499: LD_ADDR_VAR 0 3
86503: PUSH
86504: EMPTY
86505: ST_TO_ADDR
// for i in turrets do
86506: LD_ADDR_VAR 0 4
86510: PUSH
86511: LD_VAR 0 1
86515: PUSH
86516: FOR_IN
86517: IFFALSE 86700
// begin nat := GetNation ( i ) ;
86519: LD_ADDR_VAR 0 7
86523: PUSH
86524: LD_VAR 0 4
86528: PPUSH
86529: CALL_OW 248
86533: ST_TO_ADDR
// weapon := 0 ;
86534: LD_ADDR_VAR 0 8
86538: PUSH
86539: LD_INT 0
86541: ST_TO_ADDR
// if not nat then
86542: LD_VAR 0 7
86546: NOT
86547: IFFALSE 86551
// continue ;
86549: GO 86516
// for j in list [ nat ] do
86551: LD_ADDR_VAR 0 5
86555: PUSH
86556: LD_VAR 0 10
86560: PUSH
86561: LD_VAR 0 7
86565: ARRAY
86566: PUSH
86567: FOR_IN
86568: IFFALSE 86609
// if GetBWeapon ( i ) = j [ 1 ] then
86570: LD_VAR 0 4
86574: PPUSH
86575: CALL_OW 269
86579: PUSH
86580: LD_VAR 0 5
86584: PUSH
86585: LD_INT 1
86587: ARRAY
86588: EQUAL
86589: IFFALSE 86607
// begin weapon := j [ 2 ] ;
86591: LD_ADDR_VAR 0 8
86595: PUSH
86596: LD_VAR 0 5
86600: PUSH
86601: LD_INT 2
86603: ARRAY
86604: ST_TO_ADDR
// break ;
86605: GO 86609
// end ;
86607: GO 86567
86609: POP
86610: POP
// if not weapon then
86611: LD_VAR 0 8
86615: NOT
86616: IFFALSE 86620
// continue ;
86618: GO 86516
// for k in factories do
86620: LD_ADDR_VAR 0 6
86624: PUSH
86625: LD_VAR 0 2
86629: PUSH
86630: FOR_IN
86631: IFFALSE 86696
// begin weapons := AvailableWeaponList ( k ) ;
86633: LD_ADDR_VAR 0 9
86637: PUSH
86638: LD_VAR 0 6
86642: PPUSH
86643: CALL_OW 478
86647: ST_TO_ADDR
// if not weapons then
86648: LD_VAR 0 9
86652: NOT
86653: IFFALSE 86657
// continue ;
86655: GO 86630
// if weapon in weapons then
86657: LD_VAR 0 8
86661: PUSH
86662: LD_VAR 0 9
86666: IN
86667: IFFALSE 86694
// begin result := [ i , weapon ] ;
86669: LD_ADDR_VAR 0 3
86673: PUSH
86674: LD_VAR 0 4
86678: PUSH
86679: LD_VAR 0 8
86683: PUSH
86684: EMPTY
86685: LIST
86686: LIST
86687: ST_TO_ADDR
// exit ;
86688: POP
86689: POP
86690: POP
86691: POP
86692: GO 86702
// end ; end ;
86694: GO 86630
86696: POP
86697: POP
// end ;
86698: GO 86516
86700: POP
86701: POP
// end ;
86702: LD_VAR 0 3
86706: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86707: LD_INT 0
86709: PPUSH
// if not side or side > 8 then
86710: LD_VAR 0 3
86714: NOT
86715: PUSH
86716: LD_VAR 0 3
86720: PUSH
86721: LD_INT 8
86723: GREATER
86724: OR
86725: IFFALSE 86729
// exit ;
86727: GO 86788
// if not range then
86729: LD_VAR 0 4
86733: NOT
86734: IFFALSE 86745
// range := - 12 ;
86736: LD_ADDR_VAR 0 4
86740: PUSH
86741: LD_INT 12
86743: NEG
86744: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86745: LD_VAR 0 1
86749: PPUSH
86750: LD_VAR 0 2
86754: PPUSH
86755: LD_VAR 0 3
86759: PPUSH
86760: LD_VAR 0 4
86764: PPUSH
86765: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86769: LD_VAR 0 1
86773: PPUSH
86774: LD_VAR 0 2
86778: PPUSH
86779: LD_VAR 0 3
86783: PPUSH
86784: CALL_OW 331
// end ;
86788: LD_VAR 0 5
86792: RET
// export function Video ( mode ) ; begin
86793: LD_INT 0
86795: PPUSH
// ingame_video = mode ;
86796: LD_ADDR_OWVAR 52
86800: PUSH
86801: LD_VAR 0 1
86805: ST_TO_ADDR
// interface_hidden = mode ;
86806: LD_ADDR_OWVAR 54
86810: PUSH
86811: LD_VAR 0 1
86815: ST_TO_ADDR
// end ;
86816: LD_VAR 0 2
86820: RET
// export function Join ( array , element ) ; begin
86821: LD_INT 0
86823: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86824: LD_ADDR_VAR 0 3
86828: PUSH
86829: LD_VAR 0 1
86833: PPUSH
86834: LD_VAR 0 1
86838: PUSH
86839: LD_INT 1
86841: PLUS
86842: PPUSH
86843: LD_VAR 0 2
86847: PPUSH
86848: CALL_OW 1
86852: ST_TO_ADDR
// end ;
86853: LD_VAR 0 3
86857: RET
// export function JoinUnion ( array , element ) ; begin
86858: LD_INT 0
86860: PPUSH
// result := array union element ;
86861: LD_ADDR_VAR 0 3
86865: PUSH
86866: LD_VAR 0 1
86870: PUSH
86871: LD_VAR 0 2
86875: UNION
86876: ST_TO_ADDR
// end ;
86877: LD_VAR 0 3
86881: RET
// export function GetBehemoths ( side ) ; begin
86882: LD_INT 0
86884: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86885: LD_ADDR_VAR 0 2
86889: PUSH
86890: LD_INT 22
86892: PUSH
86893: LD_VAR 0 1
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 31
86904: PUSH
86905: LD_INT 25
86907: PUSH
86908: EMPTY
86909: LIST
86910: LIST
86911: PUSH
86912: EMPTY
86913: LIST
86914: LIST
86915: PPUSH
86916: CALL_OW 69
86920: ST_TO_ADDR
// end ;
86921: LD_VAR 0 2
86925: RET
// export function Shuffle ( array ) ; var i , index ; begin
86926: LD_INT 0
86928: PPUSH
86929: PPUSH
86930: PPUSH
// result := [ ] ;
86931: LD_ADDR_VAR 0 2
86935: PUSH
86936: EMPTY
86937: ST_TO_ADDR
// if not array then
86938: LD_VAR 0 1
86942: NOT
86943: IFFALSE 86947
// exit ;
86945: GO 87046
// Randomize ;
86947: CALL_OW 10
// for i = array downto 1 do
86951: LD_ADDR_VAR 0 3
86955: PUSH
86956: DOUBLE
86957: LD_VAR 0 1
86961: INC
86962: ST_TO_ADDR
86963: LD_INT 1
86965: PUSH
86966: FOR_DOWNTO
86967: IFFALSE 87044
// begin index := rand ( 1 , array ) ;
86969: LD_ADDR_VAR 0 4
86973: PUSH
86974: LD_INT 1
86976: PPUSH
86977: LD_VAR 0 1
86981: PPUSH
86982: CALL_OW 12
86986: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86987: LD_ADDR_VAR 0 2
86991: PUSH
86992: LD_VAR 0 2
86996: PPUSH
86997: LD_VAR 0 2
87001: PUSH
87002: LD_INT 1
87004: PLUS
87005: PPUSH
87006: LD_VAR 0 1
87010: PUSH
87011: LD_VAR 0 4
87015: ARRAY
87016: PPUSH
87017: CALL_OW 2
87021: ST_TO_ADDR
// array := Delete ( array , index ) ;
87022: LD_ADDR_VAR 0 1
87026: PUSH
87027: LD_VAR 0 1
87031: PPUSH
87032: LD_VAR 0 4
87036: PPUSH
87037: CALL_OW 3
87041: ST_TO_ADDR
// end ;
87042: GO 86966
87044: POP
87045: POP
// end ;
87046: LD_VAR 0 2
87050: RET
// export function GetBaseMaterials ( base ) ; begin
87051: LD_INT 0
87053: PPUSH
// result := [ 0 , 0 , 0 ] ;
87054: LD_ADDR_VAR 0 2
87058: PUSH
87059: LD_INT 0
87061: PUSH
87062: LD_INT 0
87064: PUSH
87065: LD_INT 0
87067: PUSH
87068: EMPTY
87069: LIST
87070: LIST
87071: LIST
87072: ST_TO_ADDR
// if not base then
87073: LD_VAR 0 1
87077: NOT
87078: IFFALSE 87082
// exit ;
87080: GO 87131
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
87082: LD_ADDR_VAR 0 2
87086: PUSH
87087: LD_VAR 0 1
87091: PPUSH
87092: LD_INT 1
87094: PPUSH
87095: CALL_OW 275
87099: PUSH
87100: LD_VAR 0 1
87104: PPUSH
87105: LD_INT 2
87107: PPUSH
87108: CALL_OW 275
87112: PUSH
87113: LD_VAR 0 1
87117: PPUSH
87118: LD_INT 3
87120: PPUSH
87121: CALL_OW 275
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: LIST
87130: ST_TO_ADDR
// end ;
87131: LD_VAR 0 2
87135: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
87136: LD_INT 0
87138: PPUSH
87139: PPUSH
// result := array ;
87140: LD_ADDR_VAR 0 3
87144: PUSH
87145: LD_VAR 0 1
87149: ST_TO_ADDR
// if size >= result then
87150: LD_VAR 0 2
87154: PUSH
87155: LD_VAR 0 3
87159: GREATEREQUAL
87160: IFFALSE 87164
// exit ;
87162: GO 87214
// if size then
87164: LD_VAR 0 2
87168: IFFALSE 87214
// for i := array downto size do
87170: LD_ADDR_VAR 0 4
87174: PUSH
87175: DOUBLE
87176: LD_VAR 0 1
87180: INC
87181: ST_TO_ADDR
87182: LD_VAR 0 2
87186: PUSH
87187: FOR_DOWNTO
87188: IFFALSE 87212
// result := Delete ( result , result ) ;
87190: LD_ADDR_VAR 0 3
87194: PUSH
87195: LD_VAR 0 3
87199: PPUSH
87200: LD_VAR 0 3
87204: PPUSH
87205: CALL_OW 3
87209: ST_TO_ADDR
87210: GO 87187
87212: POP
87213: POP
// end ;
87214: LD_VAR 0 3
87218: RET
// export function ComExit ( unit ) ; var tmp ; begin
87219: LD_INT 0
87221: PPUSH
87222: PPUSH
// if not IsInUnit ( unit ) then
87223: LD_VAR 0 1
87227: PPUSH
87228: CALL_OW 310
87232: NOT
87233: IFFALSE 87237
// exit ;
87235: GO 87297
// tmp := IsInUnit ( unit ) ;
87237: LD_ADDR_VAR 0 3
87241: PUSH
87242: LD_VAR 0 1
87246: PPUSH
87247: CALL_OW 310
87251: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
87252: LD_VAR 0 3
87256: PPUSH
87257: CALL_OW 247
87261: PUSH
87262: LD_INT 2
87264: EQUAL
87265: IFFALSE 87278
// ComExitVehicle ( unit ) else
87267: LD_VAR 0 1
87271: PPUSH
87272: CALL_OW 121
87276: GO 87287
// ComExitBuilding ( unit ) ;
87278: LD_VAR 0 1
87282: PPUSH
87283: CALL_OW 122
// result := tmp ;
87287: LD_ADDR_VAR 0 2
87291: PUSH
87292: LD_VAR 0 3
87296: ST_TO_ADDR
// end ;
87297: LD_VAR 0 2
87301: RET
// export function ComExitAll ( units ) ; var i ; begin
87302: LD_INT 0
87304: PPUSH
87305: PPUSH
// if not units then
87306: LD_VAR 0 1
87310: NOT
87311: IFFALSE 87315
// exit ;
87313: GO 87341
// for i in units do
87315: LD_ADDR_VAR 0 3
87319: PUSH
87320: LD_VAR 0 1
87324: PUSH
87325: FOR_IN
87326: IFFALSE 87339
// ComExit ( i ) ;
87328: LD_VAR 0 3
87332: PPUSH
87333: CALL 87219 0 1
87337: GO 87325
87339: POP
87340: POP
// end ;
87341: LD_VAR 0 2
87345: RET
// export function ResetHc ; begin
87346: LD_INT 0
87348: PPUSH
// InitHc ;
87349: CALL_OW 19
// hc_importance := 0 ;
87353: LD_ADDR_OWVAR 32
87357: PUSH
87358: LD_INT 0
87360: ST_TO_ADDR
// end ;
87361: LD_VAR 0 1
87365: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
87366: LD_INT 0
87368: PPUSH
87369: PPUSH
87370: PPUSH
// _x := ( x1 + x2 ) div 2 ;
87371: LD_ADDR_VAR 0 6
87375: PUSH
87376: LD_VAR 0 1
87380: PUSH
87381: LD_VAR 0 3
87385: PLUS
87386: PUSH
87387: LD_INT 2
87389: DIV
87390: ST_TO_ADDR
// if _x < 0 then
87391: LD_VAR 0 6
87395: PUSH
87396: LD_INT 0
87398: LESS
87399: IFFALSE 87416
// _x := _x * - 1 ;
87401: LD_ADDR_VAR 0 6
87405: PUSH
87406: LD_VAR 0 6
87410: PUSH
87411: LD_INT 1
87413: NEG
87414: MUL
87415: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87416: LD_ADDR_VAR 0 7
87420: PUSH
87421: LD_VAR 0 2
87425: PUSH
87426: LD_VAR 0 4
87430: PLUS
87431: PUSH
87432: LD_INT 2
87434: DIV
87435: ST_TO_ADDR
// if _y < 0 then
87436: LD_VAR 0 7
87440: PUSH
87441: LD_INT 0
87443: LESS
87444: IFFALSE 87461
// _y := _y * - 1 ;
87446: LD_ADDR_VAR 0 7
87450: PUSH
87451: LD_VAR 0 7
87455: PUSH
87456: LD_INT 1
87458: NEG
87459: MUL
87460: ST_TO_ADDR
// result := [ _x , _y ] ;
87461: LD_ADDR_VAR 0 5
87465: PUSH
87466: LD_VAR 0 6
87470: PUSH
87471: LD_VAR 0 7
87475: PUSH
87476: EMPTY
87477: LIST
87478: LIST
87479: ST_TO_ADDR
// end ;
87480: LD_VAR 0 5
87484: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87485: LD_INT 0
87487: PPUSH
87488: PPUSH
87489: PPUSH
87490: PPUSH
// task := GetTaskList ( unit ) ;
87491: LD_ADDR_VAR 0 7
87495: PUSH
87496: LD_VAR 0 1
87500: PPUSH
87501: CALL_OW 437
87505: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87506: LD_VAR 0 7
87510: NOT
87511: PUSH
87512: LD_VAR 0 1
87516: PPUSH
87517: LD_VAR 0 2
87521: PPUSH
87522: CALL_OW 308
87526: NOT
87527: AND
87528: IFFALSE 87532
// exit ;
87530: GO 87650
// if IsInArea ( unit , area ) then
87532: LD_VAR 0 1
87536: PPUSH
87537: LD_VAR 0 2
87541: PPUSH
87542: CALL_OW 308
87546: IFFALSE 87564
// begin ComMoveToArea ( unit , goAway ) ;
87548: LD_VAR 0 1
87552: PPUSH
87553: LD_VAR 0 3
87557: PPUSH
87558: CALL_OW 113
// exit ;
87562: GO 87650
// end ; if task [ 1 ] [ 1 ] <> M then
87564: LD_VAR 0 7
87568: PUSH
87569: LD_INT 1
87571: ARRAY
87572: PUSH
87573: LD_INT 1
87575: ARRAY
87576: PUSH
87577: LD_STRING M
87579: NONEQUAL
87580: IFFALSE 87584
// exit ;
87582: GO 87650
// x := task [ 1 ] [ 2 ] ;
87584: LD_ADDR_VAR 0 5
87588: PUSH
87589: LD_VAR 0 7
87593: PUSH
87594: LD_INT 1
87596: ARRAY
87597: PUSH
87598: LD_INT 2
87600: ARRAY
87601: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87602: LD_ADDR_VAR 0 6
87606: PUSH
87607: LD_VAR 0 7
87611: PUSH
87612: LD_INT 1
87614: ARRAY
87615: PUSH
87616: LD_INT 3
87618: ARRAY
87619: ST_TO_ADDR
// if InArea ( x , y , area ) then
87620: LD_VAR 0 5
87624: PPUSH
87625: LD_VAR 0 6
87629: PPUSH
87630: LD_VAR 0 2
87634: PPUSH
87635: CALL_OW 309
87639: IFFALSE 87650
// ComStop ( unit ) ;
87641: LD_VAR 0 1
87645: PPUSH
87646: CALL_OW 141
// end ;
87650: LD_VAR 0 4
87654: RET
// export function Abs ( value ) ; begin
87655: LD_INT 0
87657: PPUSH
// result := value ;
87658: LD_ADDR_VAR 0 2
87662: PUSH
87663: LD_VAR 0 1
87667: ST_TO_ADDR
// if value < 0 then
87668: LD_VAR 0 1
87672: PUSH
87673: LD_INT 0
87675: LESS
87676: IFFALSE 87693
// result := value * - 1 ;
87678: LD_ADDR_VAR 0 2
87682: PUSH
87683: LD_VAR 0 1
87687: PUSH
87688: LD_INT 1
87690: NEG
87691: MUL
87692: ST_TO_ADDR
// end ;
87693: LD_VAR 0 2
87697: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87698: LD_INT 0
87700: PPUSH
87701: PPUSH
87702: PPUSH
87703: PPUSH
87704: PPUSH
87705: PPUSH
87706: PPUSH
87707: PPUSH
// if not unit or not building then
87708: LD_VAR 0 1
87712: NOT
87713: PUSH
87714: LD_VAR 0 2
87718: NOT
87719: OR
87720: IFFALSE 87724
// exit ;
87722: GO 87950
// x := GetX ( building ) ;
87724: LD_ADDR_VAR 0 4
87728: PUSH
87729: LD_VAR 0 2
87733: PPUSH
87734: CALL_OW 250
87738: ST_TO_ADDR
// y := GetY ( building ) ;
87739: LD_ADDR_VAR 0 6
87743: PUSH
87744: LD_VAR 0 2
87748: PPUSH
87749: CALL_OW 251
87753: ST_TO_ADDR
// d := GetDir ( building ) ;
87754: LD_ADDR_VAR 0 8
87758: PUSH
87759: LD_VAR 0 2
87763: PPUSH
87764: CALL_OW 254
87768: ST_TO_ADDR
// r := 4 ;
87769: LD_ADDR_VAR 0 9
87773: PUSH
87774: LD_INT 4
87776: ST_TO_ADDR
// for i := 1 to 5 do
87777: LD_ADDR_VAR 0 10
87781: PUSH
87782: DOUBLE
87783: LD_INT 1
87785: DEC
87786: ST_TO_ADDR
87787: LD_INT 5
87789: PUSH
87790: FOR_TO
87791: IFFALSE 87948
// begin _x := ShiftX ( x , d , r + i ) ;
87793: LD_ADDR_VAR 0 5
87797: PUSH
87798: LD_VAR 0 4
87802: PPUSH
87803: LD_VAR 0 8
87807: PPUSH
87808: LD_VAR 0 9
87812: PUSH
87813: LD_VAR 0 10
87817: PLUS
87818: PPUSH
87819: CALL_OW 272
87823: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87824: LD_ADDR_VAR 0 7
87828: PUSH
87829: LD_VAR 0 6
87833: PPUSH
87834: LD_VAR 0 8
87838: PPUSH
87839: LD_VAR 0 9
87843: PUSH
87844: LD_VAR 0 10
87848: PLUS
87849: PPUSH
87850: CALL_OW 273
87854: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87855: LD_VAR 0 5
87859: PPUSH
87860: LD_VAR 0 7
87864: PPUSH
87865: CALL_OW 488
87869: PUSH
87870: LD_VAR 0 5
87874: PPUSH
87875: LD_VAR 0 7
87879: PPUSH
87880: CALL_OW 428
87884: PPUSH
87885: CALL_OW 247
87889: PUSH
87890: LD_INT 3
87892: PUSH
87893: LD_INT 2
87895: PUSH
87896: EMPTY
87897: LIST
87898: LIST
87899: IN
87900: NOT
87901: AND
87902: IFFALSE 87946
// begin ComMoveXY ( unit , _x , _y ) ;
87904: LD_VAR 0 1
87908: PPUSH
87909: LD_VAR 0 5
87913: PPUSH
87914: LD_VAR 0 7
87918: PPUSH
87919: CALL_OW 111
// result := [ _x , _y ] ;
87923: LD_ADDR_VAR 0 3
87927: PUSH
87928: LD_VAR 0 5
87932: PUSH
87933: LD_VAR 0 7
87937: PUSH
87938: EMPTY
87939: LIST
87940: LIST
87941: ST_TO_ADDR
// exit ;
87942: POP
87943: POP
87944: GO 87950
// end ; end ;
87946: GO 87790
87948: POP
87949: POP
// end ;
87950: LD_VAR 0 3
87954: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87955: LD_INT 0
87957: PPUSH
87958: PPUSH
87959: PPUSH
// result := 0 ;
87960: LD_ADDR_VAR 0 3
87964: PUSH
87965: LD_INT 0
87967: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87968: LD_VAR 0 1
87972: PUSH
87973: LD_INT 0
87975: LESS
87976: PUSH
87977: LD_VAR 0 1
87981: PUSH
87982: LD_INT 8
87984: GREATER
87985: OR
87986: PUSH
87987: LD_VAR 0 2
87991: PUSH
87992: LD_INT 0
87994: LESS
87995: OR
87996: PUSH
87997: LD_VAR 0 2
88001: PUSH
88002: LD_INT 8
88004: GREATER
88005: OR
88006: IFFALSE 88010
// exit ;
88008: GO 88085
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
88010: LD_ADDR_VAR 0 4
88014: PUSH
88015: LD_INT 22
88017: PUSH
88018: LD_VAR 0 2
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PPUSH
88027: CALL_OW 69
88031: PUSH
88032: FOR_IN
88033: IFFALSE 88083
// begin un := UnitShoot ( i ) ;
88035: LD_ADDR_VAR 0 5
88039: PUSH
88040: LD_VAR 0 4
88044: PPUSH
88045: CALL_OW 504
88049: ST_TO_ADDR
// if GetSide ( un ) = side1 then
88050: LD_VAR 0 5
88054: PPUSH
88055: CALL_OW 255
88059: PUSH
88060: LD_VAR 0 1
88064: EQUAL
88065: IFFALSE 88081
// begin result := un ;
88067: LD_ADDR_VAR 0 3
88071: PUSH
88072: LD_VAR 0 5
88076: ST_TO_ADDR
// exit ;
88077: POP
88078: POP
88079: GO 88085
// end ; end ;
88081: GO 88032
88083: POP
88084: POP
// end ;
88085: LD_VAR 0 3
88089: RET
// export function GetCargoBay ( units ) ; begin
88090: LD_INT 0
88092: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
88093: LD_ADDR_VAR 0 2
88097: PUSH
88098: LD_VAR 0 1
88102: PPUSH
88103: LD_INT 2
88105: PUSH
88106: LD_INT 34
88108: PUSH
88109: LD_INT 12
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: PUSH
88116: LD_INT 34
88118: PUSH
88119: LD_INT 51
88121: PUSH
88122: EMPTY
88123: LIST
88124: LIST
88125: PUSH
88126: LD_INT 34
88128: PUSH
88129: LD_INT 32
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: PUSH
88136: LD_INT 34
88138: PUSH
88139: LD_INT 89
88141: PUSH
88142: EMPTY
88143: LIST
88144: LIST
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: LIST
88150: LIST
88151: LIST
88152: PPUSH
88153: CALL_OW 72
88157: ST_TO_ADDR
// end ;
88158: LD_VAR 0 2
88162: RET
// export function Negate ( value ) ; begin
88163: LD_INT 0
88165: PPUSH
// result := not value ;
88166: LD_ADDR_VAR 0 2
88170: PUSH
88171: LD_VAR 0 1
88175: NOT
88176: ST_TO_ADDR
// end ;
88177: LD_VAR 0 2
88181: RET
// export function Inc ( value ) ; begin
88182: LD_INT 0
88184: PPUSH
// result := value + 1 ;
88185: LD_ADDR_VAR 0 2
88189: PUSH
88190: LD_VAR 0 1
88194: PUSH
88195: LD_INT 1
88197: PLUS
88198: ST_TO_ADDR
// end ;
88199: LD_VAR 0 2
88203: RET
// export function Dec ( value ) ; begin
88204: LD_INT 0
88206: PPUSH
// result := value - 1 ;
88207: LD_ADDR_VAR 0 2
88211: PUSH
88212: LD_VAR 0 1
88216: PUSH
88217: LD_INT 1
88219: MINUS
88220: ST_TO_ADDR
// end ;
88221: LD_VAR 0 2
88225: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
88226: LD_INT 0
88228: PPUSH
88229: PPUSH
88230: PPUSH
88231: PPUSH
88232: PPUSH
88233: PPUSH
88234: PPUSH
88235: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
88236: LD_VAR 0 1
88240: PPUSH
88241: LD_VAR 0 2
88245: PPUSH
88246: CALL_OW 488
88250: NOT
88251: PUSH
88252: LD_VAR 0 3
88256: PPUSH
88257: LD_VAR 0 4
88261: PPUSH
88262: CALL_OW 488
88266: NOT
88267: OR
88268: IFFALSE 88281
// begin result := - 1 ;
88270: LD_ADDR_VAR 0 5
88274: PUSH
88275: LD_INT 1
88277: NEG
88278: ST_TO_ADDR
// exit ;
88279: GO 88516
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
88281: LD_ADDR_VAR 0 12
88285: PUSH
88286: LD_VAR 0 1
88290: PPUSH
88291: LD_VAR 0 2
88295: PPUSH
88296: LD_VAR 0 3
88300: PPUSH
88301: LD_VAR 0 4
88305: PPUSH
88306: CALL 87366 0 4
88310: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
88311: LD_ADDR_VAR 0 11
88315: PUSH
88316: LD_VAR 0 1
88320: PPUSH
88321: LD_VAR 0 2
88325: PPUSH
88326: LD_VAR 0 12
88330: PUSH
88331: LD_INT 1
88333: ARRAY
88334: PPUSH
88335: LD_VAR 0 12
88339: PUSH
88340: LD_INT 2
88342: ARRAY
88343: PPUSH
88344: CALL_OW 298
88348: ST_TO_ADDR
// distance := 9999 ;
88349: LD_ADDR_VAR 0 10
88353: PUSH
88354: LD_INT 9999
88356: ST_TO_ADDR
// for i := 0 to 5 do
88357: LD_ADDR_VAR 0 6
88361: PUSH
88362: DOUBLE
88363: LD_INT 0
88365: DEC
88366: ST_TO_ADDR
88367: LD_INT 5
88369: PUSH
88370: FOR_TO
88371: IFFALSE 88514
// begin _x := ShiftX ( x1 , i , centerDist ) ;
88373: LD_ADDR_VAR 0 7
88377: PUSH
88378: LD_VAR 0 1
88382: PPUSH
88383: LD_VAR 0 6
88387: PPUSH
88388: LD_VAR 0 11
88392: PPUSH
88393: CALL_OW 272
88397: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
88398: LD_ADDR_VAR 0 8
88402: PUSH
88403: LD_VAR 0 2
88407: PPUSH
88408: LD_VAR 0 6
88412: PPUSH
88413: LD_VAR 0 11
88417: PPUSH
88418: CALL_OW 273
88422: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88423: LD_VAR 0 7
88427: PPUSH
88428: LD_VAR 0 8
88432: PPUSH
88433: CALL_OW 488
88437: NOT
88438: IFFALSE 88442
// continue ;
88440: GO 88370
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
88442: LD_ADDR_VAR 0 9
88446: PUSH
88447: LD_VAR 0 12
88451: PUSH
88452: LD_INT 1
88454: ARRAY
88455: PPUSH
88456: LD_VAR 0 12
88460: PUSH
88461: LD_INT 2
88463: ARRAY
88464: PPUSH
88465: LD_VAR 0 7
88469: PPUSH
88470: LD_VAR 0 8
88474: PPUSH
88475: CALL_OW 298
88479: ST_TO_ADDR
// if tmp < distance then
88480: LD_VAR 0 9
88484: PUSH
88485: LD_VAR 0 10
88489: LESS
88490: IFFALSE 88512
// begin result := i ;
88492: LD_ADDR_VAR 0 5
88496: PUSH
88497: LD_VAR 0 6
88501: ST_TO_ADDR
// distance := tmp ;
88502: LD_ADDR_VAR 0 10
88506: PUSH
88507: LD_VAR 0 9
88511: ST_TO_ADDR
// end ; end ;
88512: GO 88370
88514: POP
88515: POP
// end ;
88516: LD_VAR 0 5
88520: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88521: LD_INT 0
88523: PPUSH
88524: PPUSH
// if not driver or not IsInUnit ( driver ) then
88525: LD_VAR 0 1
88529: NOT
88530: PUSH
88531: LD_VAR 0 1
88535: PPUSH
88536: CALL_OW 310
88540: NOT
88541: OR
88542: IFFALSE 88546
// exit ;
88544: GO 88636
// vehicle := IsInUnit ( driver ) ;
88546: LD_ADDR_VAR 0 3
88550: PUSH
88551: LD_VAR 0 1
88555: PPUSH
88556: CALL_OW 310
88560: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88561: LD_VAR 0 1
88565: PPUSH
88566: LD_STRING \
88568: PUSH
88569: LD_INT 0
88571: PUSH
88572: LD_INT 0
88574: PUSH
88575: LD_INT 0
88577: PUSH
88578: LD_INT 0
88580: PUSH
88581: LD_INT 0
88583: PUSH
88584: LD_INT 0
88586: PUSH
88587: EMPTY
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: LIST
88595: PUSH
88596: LD_STRING E
88598: PUSH
88599: LD_INT 0
88601: PUSH
88602: LD_INT 0
88604: PUSH
88605: LD_VAR 0 3
88609: PUSH
88610: LD_INT 0
88612: PUSH
88613: LD_INT 0
88615: PUSH
88616: LD_INT 0
88618: PUSH
88619: EMPTY
88620: LIST
88621: LIST
88622: LIST
88623: LIST
88624: LIST
88625: LIST
88626: LIST
88627: PUSH
88628: EMPTY
88629: LIST
88630: LIST
88631: PPUSH
88632: CALL_OW 446
// end ;
88636: LD_VAR 0 2
88640: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88641: LD_INT 0
88643: PPUSH
88644: PPUSH
// if not driver or not IsInUnit ( driver ) then
88645: LD_VAR 0 1
88649: NOT
88650: PUSH
88651: LD_VAR 0 1
88655: PPUSH
88656: CALL_OW 310
88660: NOT
88661: OR
88662: IFFALSE 88666
// exit ;
88664: GO 88756
// vehicle := IsInUnit ( driver ) ;
88666: LD_ADDR_VAR 0 3
88670: PUSH
88671: LD_VAR 0 1
88675: PPUSH
88676: CALL_OW 310
88680: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88681: LD_VAR 0 1
88685: PPUSH
88686: LD_STRING \
88688: PUSH
88689: LD_INT 0
88691: PUSH
88692: LD_INT 0
88694: PUSH
88695: LD_INT 0
88697: PUSH
88698: LD_INT 0
88700: PUSH
88701: LD_INT 0
88703: PUSH
88704: LD_INT 0
88706: PUSH
88707: EMPTY
88708: LIST
88709: LIST
88710: LIST
88711: LIST
88712: LIST
88713: LIST
88714: LIST
88715: PUSH
88716: LD_STRING E
88718: PUSH
88719: LD_INT 0
88721: PUSH
88722: LD_INT 0
88724: PUSH
88725: LD_VAR 0 3
88729: PUSH
88730: LD_INT 0
88732: PUSH
88733: LD_INT 0
88735: PUSH
88736: LD_INT 0
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: PUSH
88748: EMPTY
88749: LIST
88750: LIST
88751: PPUSH
88752: CALL_OW 447
// end ;
88756: LD_VAR 0 2
88760: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88761: LD_INT 0
88763: PPUSH
88764: PPUSH
88765: PPUSH
// tmp := [ ] ;
88766: LD_ADDR_VAR 0 5
88770: PUSH
88771: EMPTY
88772: ST_TO_ADDR
// for i in units do
88773: LD_ADDR_VAR 0 4
88777: PUSH
88778: LD_VAR 0 1
88782: PUSH
88783: FOR_IN
88784: IFFALSE 88822
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88786: LD_ADDR_VAR 0 5
88790: PUSH
88791: LD_VAR 0 5
88795: PPUSH
88796: LD_VAR 0 5
88800: PUSH
88801: LD_INT 1
88803: PLUS
88804: PPUSH
88805: LD_VAR 0 4
88809: PPUSH
88810: CALL_OW 256
88814: PPUSH
88815: CALL_OW 2
88819: ST_TO_ADDR
88820: GO 88783
88822: POP
88823: POP
// if not tmp then
88824: LD_VAR 0 5
88828: NOT
88829: IFFALSE 88833
// exit ;
88831: GO 88881
// if asc then
88833: LD_VAR 0 2
88837: IFFALSE 88861
// result := SortListByListAsc ( units , tmp ) else
88839: LD_ADDR_VAR 0 3
88843: PUSH
88844: LD_VAR 0 1
88848: PPUSH
88849: LD_VAR 0 5
88853: PPUSH
88854: CALL_OW 76
88858: ST_TO_ADDR
88859: GO 88881
// result := SortListByListDesc ( units , tmp ) ;
88861: LD_ADDR_VAR 0 3
88865: PUSH
88866: LD_VAR 0 1
88870: PPUSH
88871: LD_VAR 0 5
88875: PPUSH
88876: CALL_OW 77
88880: ST_TO_ADDR
// end ;
88881: LD_VAR 0 3
88885: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88886: LD_INT 0
88888: PPUSH
88889: PPUSH
// task := GetTaskList ( mech ) ;
88890: LD_ADDR_VAR 0 4
88894: PUSH
88895: LD_VAR 0 1
88899: PPUSH
88900: CALL_OW 437
88904: ST_TO_ADDR
// if not task then
88905: LD_VAR 0 4
88909: NOT
88910: IFFALSE 88914
// exit ;
88912: GO 88956
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88914: LD_ADDR_VAR 0 3
88918: PUSH
88919: LD_VAR 0 4
88923: PUSH
88924: LD_INT 1
88926: ARRAY
88927: PUSH
88928: LD_INT 1
88930: ARRAY
88931: PUSH
88932: LD_STRING r
88934: EQUAL
88935: PUSH
88936: LD_VAR 0 4
88940: PUSH
88941: LD_INT 1
88943: ARRAY
88944: PUSH
88945: LD_INT 4
88947: ARRAY
88948: PUSH
88949: LD_VAR 0 2
88953: EQUAL
88954: AND
88955: ST_TO_ADDR
// end ;
88956: LD_VAR 0 3
88960: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88961: LD_INT 0
88963: PPUSH
// SetDir ( unit , d ) ;
88964: LD_VAR 0 1
88968: PPUSH
88969: LD_VAR 0 4
88973: PPUSH
88974: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88978: LD_VAR 0 1
88982: PPUSH
88983: LD_VAR 0 2
88987: PPUSH
88988: LD_VAR 0 3
88992: PPUSH
88993: LD_VAR 0 5
88997: PPUSH
88998: CALL_OW 48
// end ;
89002: LD_VAR 0 6
89006: RET
// export function ToNaturalNumber ( number ) ; begin
89007: LD_INT 0
89009: PPUSH
// result := number div 1 ;
89010: LD_ADDR_VAR 0 2
89014: PUSH
89015: LD_VAR 0 1
89019: PUSH
89020: LD_INT 1
89022: DIV
89023: ST_TO_ADDR
// if number < 0 then
89024: LD_VAR 0 1
89028: PUSH
89029: LD_INT 0
89031: LESS
89032: IFFALSE 89042
// result := 0 ;
89034: LD_ADDR_VAR 0 2
89038: PUSH
89039: LD_INT 0
89041: ST_TO_ADDR
// end ;
89042: LD_VAR 0 2
89046: RET
// export function SortByClass ( units , class ) ; var un ; begin
89047: LD_INT 0
89049: PPUSH
89050: PPUSH
// if not units or not class then
89051: LD_VAR 0 1
89055: NOT
89056: PUSH
89057: LD_VAR 0 2
89061: NOT
89062: OR
89063: IFFALSE 89067
// exit ;
89065: GO 89162
// result := [ ] ;
89067: LD_ADDR_VAR 0 3
89071: PUSH
89072: EMPTY
89073: ST_TO_ADDR
// for un in units do
89074: LD_ADDR_VAR 0 4
89078: PUSH
89079: LD_VAR 0 1
89083: PUSH
89084: FOR_IN
89085: IFFALSE 89160
// if GetClass ( un ) = class then
89087: LD_VAR 0 4
89091: PPUSH
89092: CALL_OW 257
89096: PUSH
89097: LD_VAR 0 2
89101: EQUAL
89102: IFFALSE 89129
// result := Insert ( result , 1 , un ) else
89104: LD_ADDR_VAR 0 3
89108: PUSH
89109: LD_VAR 0 3
89113: PPUSH
89114: LD_INT 1
89116: PPUSH
89117: LD_VAR 0 4
89121: PPUSH
89122: CALL_OW 2
89126: ST_TO_ADDR
89127: GO 89158
// result := Replace ( result , result + 1 , un ) ;
89129: LD_ADDR_VAR 0 3
89133: PUSH
89134: LD_VAR 0 3
89138: PPUSH
89139: LD_VAR 0 3
89143: PUSH
89144: LD_INT 1
89146: PLUS
89147: PPUSH
89148: LD_VAR 0 4
89152: PPUSH
89153: CALL_OW 1
89157: ST_TO_ADDR
89158: GO 89084
89160: POP
89161: POP
// end ;
89162: LD_VAR 0 3
89166: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
89167: LD_INT 0
89169: PPUSH
89170: PPUSH
89171: PPUSH
89172: PPUSH
89173: PPUSH
89174: PPUSH
89175: PPUSH
// result := [ ] ;
89176: LD_ADDR_VAR 0 4
89180: PUSH
89181: EMPTY
89182: ST_TO_ADDR
// if x - r < 0 then
89183: LD_VAR 0 1
89187: PUSH
89188: LD_VAR 0 3
89192: MINUS
89193: PUSH
89194: LD_INT 0
89196: LESS
89197: IFFALSE 89209
// min_x := 0 else
89199: LD_ADDR_VAR 0 8
89203: PUSH
89204: LD_INT 0
89206: ST_TO_ADDR
89207: GO 89225
// min_x := x - r ;
89209: LD_ADDR_VAR 0 8
89213: PUSH
89214: LD_VAR 0 1
89218: PUSH
89219: LD_VAR 0 3
89223: MINUS
89224: ST_TO_ADDR
// if y - r < 0 then
89225: LD_VAR 0 2
89229: PUSH
89230: LD_VAR 0 3
89234: MINUS
89235: PUSH
89236: LD_INT 0
89238: LESS
89239: IFFALSE 89251
// min_y := 0 else
89241: LD_ADDR_VAR 0 7
89245: PUSH
89246: LD_INT 0
89248: ST_TO_ADDR
89249: GO 89267
// min_y := y - r ;
89251: LD_ADDR_VAR 0 7
89255: PUSH
89256: LD_VAR 0 2
89260: PUSH
89261: LD_VAR 0 3
89265: MINUS
89266: ST_TO_ADDR
// max_x := x + r ;
89267: LD_ADDR_VAR 0 9
89271: PUSH
89272: LD_VAR 0 1
89276: PUSH
89277: LD_VAR 0 3
89281: PLUS
89282: ST_TO_ADDR
// max_y := y + r ;
89283: LD_ADDR_VAR 0 10
89287: PUSH
89288: LD_VAR 0 2
89292: PUSH
89293: LD_VAR 0 3
89297: PLUS
89298: ST_TO_ADDR
// for _x = min_x to max_x do
89299: LD_ADDR_VAR 0 5
89303: PUSH
89304: DOUBLE
89305: LD_VAR 0 8
89309: DEC
89310: ST_TO_ADDR
89311: LD_VAR 0 9
89315: PUSH
89316: FOR_TO
89317: IFFALSE 89418
// for _y = min_y to max_y do
89319: LD_ADDR_VAR 0 6
89323: PUSH
89324: DOUBLE
89325: LD_VAR 0 7
89329: DEC
89330: ST_TO_ADDR
89331: LD_VAR 0 10
89335: PUSH
89336: FOR_TO
89337: IFFALSE 89414
// begin if not ValidHex ( _x , _y ) then
89339: LD_VAR 0 5
89343: PPUSH
89344: LD_VAR 0 6
89348: PPUSH
89349: CALL_OW 488
89353: NOT
89354: IFFALSE 89358
// continue ;
89356: GO 89336
// if GetResourceTypeXY ( _x , _y ) then
89358: LD_VAR 0 5
89362: PPUSH
89363: LD_VAR 0 6
89367: PPUSH
89368: CALL_OW 283
89372: IFFALSE 89412
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
89374: LD_ADDR_VAR 0 4
89378: PUSH
89379: LD_VAR 0 4
89383: PPUSH
89384: LD_VAR 0 4
89388: PUSH
89389: LD_INT 1
89391: PLUS
89392: PPUSH
89393: LD_VAR 0 5
89397: PUSH
89398: LD_VAR 0 6
89402: PUSH
89403: EMPTY
89404: LIST
89405: LIST
89406: PPUSH
89407: CALL_OW 1
89411: ST_TO_ADDR
// end ;
89412: GO 89336
89414: POP
89415: POP
89416: GO 89316
89418: POP
89419: POP
// end ;
89420: LD_VAR 0 4
89424: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
89425: LD_INT 0
89427: PPUSH
89428: PPUSH
89429: PPUSH
89430: PPUSH
89431: PPUSH
89432: PPUSH
89433: PPUSH
89434: PPUSH
// if not units then
89435: LD_VAR 0 1
89439: NOT
89440: IFFALSE 89444
// exit ;
89442: GO 89968
// result := UnitFilter ( units , [ f_ok ] ) ;
89444: LD_ADDR_VAR 0 3
89448: PUSH
89449: LD_VAR 0 1
89453: PPUSH
89454: LD_INT 50
89456: PUSH
89457: EMPTY
89458: LIST
89459: PPUSH
89460: CALL_OW 72
89464: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
89465: LD_ADDR_VAR 0 8
89469: PUSH
89470: LD_VAR 0 1
89474: PUSH
89475: LD_INT 1
89477: ARRAY
89478: PPUSH
89479: CALL_OW 255
89483: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
89484: LD_ADDR_VAR 0 10
89488: PUSH
89489: LD_INT 29
89491: PUSH
89492: LD_INT 91
89494: PUSH
89495: LD_INT 49
89497: PUSH
89498: EMPTY
89499: LIST
89500: LIST
89501: LIST
89502: ST_TO_ADDR
// if not result then
89503: LD_VAR 0 3
89507: NOT
89508: IFFALSE 89512
// exit ;
89510: GO 89968
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
89512: LD_ADDR_VAR 0 5
89516: PUSH
89517: LD_INT 81
89519: PUSH
89520: LD_VAR 0 8
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PPUSH
89529: CALL_OW 69
89533: ST_TO_ADDR
// for i in result do
89534: LD_ADDR_VAR 0 4
89538: PUSH
89539: LD_VAR 0 3
89543: PUSH
89544: FOR_IN
89545: IFFALSE 89966
// begin tag := GetTag ( i ) + 1 ;
89547: LD_ADDR_VAR 0 9
89551: PUSH
89552: LD_VAR 0 4
89556: PPUSH
89557: CALL_OW 110
89561: PUSH
89562: LD_INT 1
89564: PLUS
89565: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
89566: LD_ADDR_VAR 0 7
89570: PUSH
89571: LD_VAR 0 4
89575: PPUSH
89576: CALL_OW 250
89580: PPUSH
89581: LD_VAR 0 4
89585: PPUSH
89586: CALL_OW 251
89590: PPUSH
89591: LD_INT 6
89593: PPUSH
89594: CALL 89167 0 3
89598: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
89599: LD_VAR 0 4
89603: PPUSH
89604: CALL_OW 247
89608: PUSH
89609: LD_INT 2
89611: EQUAL
89612: PUSH
89613: LD_VAR 0 7
89617: AND
89618: PUSH
89619: LD_VAR 0 4
89623: PPUSH
89624: CALL_OW 264
89628: PUSH
89629: LD_VAR 0 10
89633: IN
89634: NOT
89635: AND
89636: IFFALSE 89675
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
89638: LD_VAR 0 4
89642: PPUSH
89643: LD_VAR 0 7
89647: PUSH
89648: LD_INT 1
89650: ARRAY
89651: PUSH
89652: LD_INT 1
89654: ARRAY
89655: PPUSH
89656: LD_VAR 0 7
89660: PUSH
89661: LD_INT 1
89663: ARRAY
89664: PUSH
89665: LD_INT 2
89667: ARRAY
89668: PPUSH
89669: CALL_OW 116
89673: GO 89964
// if path > tag then
89675: LD_VAR 0 2
89679: PUSH
89680: LD_VAR 0 9
89684: GREATER
89685: IFFALSE 89893
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
89687: LD_ADDR_VAR 0 6
89691: PUSH
89692: LD_VAR 0 5
89696: PPUSH
89697: LD_INT 91
89699: PUSH
89700: LD_VAR 0 4
89704: PUSH
89705: LD_INT 8
89707: PUSH
89708: EMPTY
89709: LIST
89710: LIST
89711: LIST
89712: PPUSH
89713: CALL_OW 72
89717: ST_TO_ADDR
// if nearEnemy then
89718: LD_VAR 0 6
89722: IFFALSE 89791
// begin if GetWeapon ( i ) = ru_time_lapser then
89724: LD_VAR 0 4
89728: PPUSH
89729: CALL_OW 264
89733: PUSH
89734: LD_INT 49
89736: EQUAL
89737: IFFALSE 89765
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89739: LD_VAR 0 4
89743: PPUSH
89744: LD_VAR 0 6
89748: PPUSH
89749: LD_VAR 0 4
89753: PPUSH
89754: CALL_OW 74
89758: PPUSH
89759: CALL_OW 112
89763: GO 89789
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89765: LD_VAR 0 4
89769: PPUSH
89770: LD_VAR 0 6
89774: PPUSH
89775: LD_VAR 0 4
89779: PPUSH
89780: CALL_OW 74
89784: PPUSH
89785: CALL 90893 0 2
// end else
89789: GO 89891
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89791: LD_VAR 0 4
89795: PPUSH
89796: LD_VAR 0 2
89800: PUSH
89801: LD_VAR 0 9
89805: ARRAY
89806: PUSH
89807: LD_INT 1
89809: ARRAY
89810: PPUSH
89811: LD_VAR 0 2
89815: PUSH
89816: LD_VAR 0 9
89820: ARRAY
89821: PUSH
89822: LD_INT 2
89824: ARRAY
89825: PPUSH
89826: CALL_OW 297
89830: PUSH
89831: LD_INT 6
89833: GREATER
89834: IFFALSE 89877
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89836: LD_VAR 0 4
89840: PPUSH
89841: LD_VAR 0 2
89845: PUSH
89846: LD_VAR 0 9
89850: ARRAY
89851: PUSH
89852: LD_INT 1
89854: ARRAY
89855: PPUSH
89856: LD_VAR 0 2
89860: PUSH
89861: LD_VAR 0 9
89865: ARRAY
89866: PUSH
89867: LD_INT 2
89869: ARRAY
89870: PPUSH
89871: CALL_OW 114
89875: GO 89891
// SetTag ( i , tag ) ;
89877: LD_VAR 0 4
89881: PPUSH
89882: LD_VAR 0 9
89886: PPUSH
89887: CALL_OW 109
// end else
89891: GO 89964
// if enemy then
89893: LD_VAR 0 5
89897: IFFALSE 89964
// begin if GetWeapon ( i ) = ru_time_lapser then
89899: LD_VAR 0 4
89903: PPUSH
89904: CALL_OW 264
89908: PUSH
89909: LD_INT 49
89911: EQUAL
89912: IFFALSE 89940
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89914: LD_VAR 0 4
89918: PPUSH
89919: LD_VAR 0 5
89923: PPUSH
89924: LD_VAR 0 4
89928: PPUSH
89929: CALL_OW 74
89933: PPUSH
89934: CALL_OW 112
89938: GO 89964
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89940: LD_VAR 0 4
89944: PPUSH
89945: LD_VAR 0 5
89949: PPUSH
89950: LD_VAR 0 4
89954: PPUSH
89955: CALL_OW 74
89959: PPUSH
89960: CALL 90893 0 2
// end ; end ;
89964: GO 89544
89966: POP
89967: POP
// end ;
89968: LD_VAR 0 3
89972: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89973: LD_INT 0
89975: PPUSH
89976: PPUSH
89977: PPUSH
// if not unit or IsInUnit ( unit ) then
89978: LD_VAR 0 1
89982: NOT
89983: PUSH
89984: LD_VAR 0 1
89988: PPUSH
89989: CALL_OW 310
89993: OR
89994: IFFALSE 89998
// exit ;
89996: GO 90089
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89998: LD_ADDR_VAR 0 4
90002: PUSH
90003: LD_VAR 0 1
90007: PPUSH
90008: CALL_OW 250
90012: PPUSH
90013: LD_VAR 0 2
90017: PPUSH
90018: LD_INT 1
90020: PPUSH
90021: CALL_OW 272
90025: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
90026: LD_ADDR_VAR 0 5
90030: PUSH
90031: LD_VAR 0 1
90035: PPUSH
90036: CALL_OW 251
90040: PPUSH
90041: LD_VAR 0 2
90045: PPUSH
90046: LD_INT 1
90048: PPUSH
90049: CALL_OW 273
90053: ST_TO_ADDR
// if ValidHex ( x , y ) then
90054: LD_VAR 0 4
90058: PPUSH
90059: LD_VAR 0 5
90063: PPUSH
90064: CALL_OW 488
90068: IFFALSE 90089
// ComTurnXY ( unit , x , y ) ;
90070: LD_VAR 0 1
90074: PPUSH
90075: LD_VAR 0 4
90079: PPUSH
90080: LD_VAR 0 5
90084: PPUSH
90085: CALL_OW 118
// end ;
90089: LD_VAR 0 3
90093: RET
// export function SeeUnits ( side , units ) ; var i ; begin
90094: LD_INT 0
90096: PPUSH
90097: PPUSH
// result := false ;
90098: LD_ADDR_VAR 0 3
90102: PUSH
90103: LD_INT 0
90105: ST_TO_ADDR
// if not units then
90106: LD_VAR 0 2
90110: NOT
90111: IFFALSE 90115
// exit ;
90113: GO 90160
// for i in units do
90115: LD_ADDR_VAR 0 4
90119: PUSH
90120: LD_VAR 0 2
90124: PUSH
90125: FOR_IN
90126: IFFALSE 90158
// if See ( side , i ) then
90128: LD_VAR 0 1
90132: PPUSH
90133: LD_VAR 0 4
90137: PPUSH
90138: CALL_OW 292
90142: IFFALSE 90156
// begin result := true ;
90144: LD_ADDR_VAR 0 3
90148: PUSH
90149: LD_INT 1
90151: ST_TO_ADDR
// exit ;
90152: POP
90153: POP
90154: GO 90160
// end ;
90156: GO 90125
90158: POP
90159: POP
// end ;
90160: LD_VAR 0 3
90164: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
90165: LD_INT 0
90167: PPUSH
90168: PPUSH
90169: PPUSH
90170: PPUSH
// if not unit or not points then
90171: LD_VAR 0 1
90175: NOT
90176: PUSH
90177: LD_VAR 0 2
90181: NOT
90182: OR
90183: IFFALSE 90187
// exit ;
90185: GO 90277
// dist := 99999 ;
90187: LD_ADDR_VAR 0 5
90191: PUSH
90192: LD_INT 99999
90194: ST_TO_ADDR
// for i in points do
90195: LD_ADDR_VAR 0 4
90199: PUSH
90200: LD_VAR 0 2
90204: PUSH
90205: FOR_IN
90206: IFFALSE 90275
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
90208: LD_ADDR_VAR 0 6
90212: PUSH
90213: LD_VAR 0 1
90217: PPUSH
90218: LD_VAR 0 4
90222: PUSH
90223: LD_INT 1
90225: ARRAY
90226: PPUSH
90227: LD_VAR 0 4
90231: PUSH
90232: LD_INT 2
90234: ARRAY
90235: PPUSH
90236: CALL_OW 297
90240: ST_TO_ADDR
// if tmpDist < dist then
90241: LD_VAR 0 6
90245: PUSH
90246: LD_VAR 0 5
90250: LESS
90251: IFFALSE 90273
// begin result := i ;
90253: LD_ADDR_VAR 0 3
90257: PUSH
90258: LD_VAR 0 4
90262: ST_TO_ADDR
// dist := tmpDist ;
90263: LD_ADDR_VAR 0 5
90267: PUSH
90268: LD_VAR 0 6
90272: ST_TO_ADDR
// end ; end ;
90273: GO 90205
90275: POP
90276: POP
// end ;
90277: LD_VAR 0 3
90281: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
90282: LD_INT 0
90284: PPUSH
// uc_side := side ;
90285: LD_ADDR_OWVAR 20
90289: PUSH
90290: LD_VAR 0 1
90294: ST_TO_ADDR
// uc_nation := 3 ;
90295: LD_ADDR_OWVAR 21
90299: PUSH
90300: LD_INT 3
90302: ST_TO_ADDR
// vc_chassis := 25 ;
90303: LD_ADDR_OWVAR 37
90307: PUSH
90308: LD_INT 25
90310: ST_TO_ADDR
// vc_engine := engine_siberite ;
90311: LD_ADDR_OWVAR 39
90315: PUSH
90316: LD_INT 3
90318: ST_TO_ADDR
// vc_control := control_computer ;
90319: LD_ADDR_OWVAR 38
90323: PUSH
90324: LD_INT 3
90326: ST_TO_ADDR
// vc_weapon := 59 ;
90327: LD_ADDR_OWVAR 40
90331: PUSH
90332: LD_INT 59
90334: ST_TO_ADDR
// result := CreateVehicle ;
90335: LD_ADDR_VAR 0 5
90339: PUSH
90340: CALL_OW 45
90344: ST_TO_ADDR
// SetDir ( result , d ) ;
90345: LD_VAR 0 5
90349: PPUSH
90350: LD_VAR 0 4
90354: PPUSH
90355: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
90359: LD_VAR 0 5
90363: PPUSH
90364: LD_VAR 0 2
90368: PPUSH
90369: LD_VAR 0 3
90373: PPUSH
90374: LD_INT 0
90376: PPUSH
90377: CALL_OW 48
// end ;
90381: LD_VAR 0 5
90385: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
90386: LD_INT 0
90388: PPUSH
90389: PPUSH
90390: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
90391: LD_ADDR_VAR 0 2
90395: PUSH
90396: LD_INT 0
90398: PUSH
90399: LD_INT 0
90401: PUSH
90402: LD_INT 0
90404: PUSH
90405: LD_INT 0
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
90414: LD_VAR 0 1
90418: NOT
90419: PUSH
90420: LD_VAR 0 1
90424: PPUSH
90425: CALL_OW 264
90429: PUSH
90430: LD_INT 12
90432: PUSH
90433: LD_INT 51
90435: PUSH
90436: LD_INT 32
90438: PUSH
90439: LD_INT 89
90441: PUSH
90442: EMPTY
90443: LIST
90444: LIST
90445: LIST
90446: LIST
90447: IN
90448: NOT
90449: OR
90450: IFFALSE 90454
// exit ;
90452: GO 90552
// for i := 1 to 3 do
90454: LD_ADDR_VAR 0 3
90458: PUSH
90459: DOUBLE
90460: LD_INT 1
90462: DEC
90463: ST_TO_ADDR
90464: LD_INT 3
90466: PUSH
90467: FOR_TO
90468: IFFALSE 90550
// begin tmp := GetCargo ( cargo , i ) ;
90470: LD_ADDR_VAR 0 4
90474: PUSH
90475: LD_VAR 0 1
90479: PPUSH
90480: LD_VAR 0 3
90484: PPUSH
90485: CALL_OW 289
90489: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
90490: LD_ADDR_VAR 0 2
90494: PUSH
90495: LD_VAR 0 2
90499: PPUSH
90500: LD_VAR 0 3
90504: PPUSH
90505: LD_VAR 0 4
90509: PPUSH
90510: CALL_OW 1
90514: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
90515: LD_ADDR_VAR 0 2
90519: PUSH
90520: LD_VAR 0 2
90524: PPUSH
90525: LD_INT 4
90527: PPUSH
90528: LD_VAR 0 2
90532: PUSH
90533: LD_INT 4
90535: ARRAY
90536: PUSH
90537: LD_VAR 0 4
90541: PLUS
90542: PPUSH
90543: CALL_OW 1
90547: ST_TO_ADDR
// end ;
90548: GO 90467
90550: POP
90551: POP
// end ;
90552: LD_VAR 0 2
90556: RET
// export function Length ( array ) ; begin
90557: LD_INT 0
90559: PPUSH
// result := array + 0 ;
90560: LD_ADDR_VAR 0 2
90564: PUSH
90565: LD_VAR 0 1
90569: PUSH
90570: LD_INT 0
90572: PLUS
90573: ST_TO_ADDR
// end ;
90574: LD_VAR 0 2
90578: RET
// export function PrepareArray ( array ) ; begin
90579: LD_INT 0
90581: PPUSH
// result := array diff 0 ;
90582: LD_ADDR_VAR 0 2
90586: PUSH
90587: LD_VAR 0 1
90591: PUSH
90592: LD_INT 0
90594: DIFF
90595: ST_TO_ADDR
// if not result [ 1 ] then
90596: LD_VAR 0 2
90600: PUSH
90601: LD_INT 1
90603: ARRAY
90604: NOT
90605: IFFALSE 90625
// result := Delete ( result , 1 ) ;
90607: LD_ADDR_VAR 0 2
90611: PUSH
90612: LD_VAR 0 2
90616: PPUSH
90617: LD_INT 1
90619: PPUSH
90620: CALL_OW 3
90624: ST_TO_ADDR
// end ;
90625: LD_VAR 0 2
90629: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
90630: LD_INT 0
90632: PPUSH
90633: PPUSH
90634: PPUSH
90635: PPUSH
// sibRocketRange := 25 ;
90636: LD_ADDR_VAR 0 6
90640: PUSH
90641: LD_INT 25
90643: ST_TO_ADDR
// result := false ;
90644: LD_ADDR_VAR 0 4
90648: PUSH
90649: LD_INT 0
90651: ST_TO_ADDR
// for i := 0 to 5 do
90652: LD_ADDR_VAR 0 5
90656: PUSH
90657: DOUBLE
90658: LD_INT 0
90660: DEC
90661: ST_TO_ADDR
90662: LD_INT 5
90664: PUSH
90665: FOR_TO
90666: IFFALSE 90733
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
90668: LD_VAR 0 1
90672: PPUSH
90673: LD_VAR 0 5
90677: PPUSH
90678: LD_VAR 0 6
90682: PPUSH
90683: CALL_OW 272
90687: PPUSH
90688: LD_VAR 0 2
90692: PPUSH
90693: LD_VAR 0 5
90697: PPUSH
90698: LD_VAR 0 6
90702: PPUSH
90703: CALL_OW 273
90707: PPUSH
90708: LD_VAR 0 3
90712: PPUSH
90713: CALL_OW 309
90717: IFFALSE 90731
// begin result := true ;
90719: LD_ADDR_VAR 0 4
90723: PUSH
90724: LD_INT 1
90726: ST_TO_ADDR
// exit ;
90727: POP
90728: POP
90729: GO 90735
// end ;
90731: GO 90665
90733: POP
90734: POP
// end ;
90735: LD_VAR 0 4
90739: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90740: LD_INT 0
90742: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90743: LD_VAR 0 1
90747: PPUSH
90748: LD_VAR 0 2
90752: PPUSH
90753: LD_INT 0
90755: PPUSH
90756: LD_INT 0
90758: PPUSH
90759: LD_INT 1
90761: PPUSH
90762: LD_INT 0
90764: PPUSH
90765: CALL_OW 587
// end ;
90769: LD_VAR 0 3
90773: RET
// export function CenterOnNow ( unit ) ; begin
90774: LD_INT 0
90776: PPUSH
// result := IsInUnit ( unit ) ;
90777: LD_ADDR_VAR 0 2
90781: PUSH
90782: LD_VAR 0 1
90786: PPUSH
90787: CALL_OW 310
90791: ST_TO_ADDR
// if not result then
90792: LD_VAR 0 2
90796: NOT
90797: IFFALSE 90809
// result := unit ;
90799: LD_ADDR_VAR 0 2
90803: PUSH
90804: LD_VAR 0 1
90808: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
90809: LD_VAR 0 1
90813: PPUSH
90814: CALL_OW 87
// end ;
90818: LD_VAR 0 2
90822: RET
// export function ComMoveHex ( unit , hex ) ; begin
90823: LD_INT 0
90825: PPUSH
// if not hex then
90826: LD_VAR 0 2
90830: NOT
90831: IFFALSE 90835
// exit ;
90833: GO 90888
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
90835: LD_VAR 0 2
90839: PUSH
90840: LD_INT 1
90842: ARRAY
90843: PPUSH
90844: LD_VAR 0 2
90848: PUSH
90849: LD_INT 2
90851: ARRAY
90852: PPUSH
90853: CALL_OW 428
90857: IFFALSE 90861
// exit ;
90859: GO 90888
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
90861: LD_VAR 0 1
90865: PPUSH
90866: LD_VAR 0 2
90870: PUSH
90871: LD_INT 1
90873: ARRAY
90874: PPUSH
90875: LD_VAR 0 2
90879: PUSH
90880: LD_INT 2
90882: ARRAY
90883: PPUSH
90884: CALL_OW 111
// end ;
90888: LD_VAR 0 3
90892: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
90893: LD_INT 0
90895: PPUSH
90896: PPUSH
90897: PPUSH
// if not unit or not enemy then
90898: LD_VAR 0 1
90902: NOT
90903: PUSH
90904: LD_VAR 0 2
90908: NOT
90909: OR
90910: IFFALSE 90914
// exit ;
90912: GO 91038
// x := GetX ( enemy ) ;
90914: LD_ADDR_VAR 0 4
90918: PUSH
90919: LD_VAR 0 2
90923: PPUSH
90924: CALL_OW 250
90928: ST_TO_ADDR
// y := GetY ( enemy ) ;
90929: LD_ADDR_VAR 0 5
90933: PUSH
90934: LD_VAR 0 2
90938: PPUSH
90939: CALL_OW 251
90943: ST_TO_ADDR
// if ValidHex ( x , y ) then
90944: LD_VAR 0 4
90948: PPUSH
90949: LD_VAR 0 5
90953: PPUSH
90954: CALL_OW 488
90958: IFFALSE 91038
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
90960: LD_VAR 0 2
90964: PPUSH
90965: CALL_OW 247
90969: PUSH
90970: LD_INT 3
90972: PUSH
90973: LD_INT 2
90975: PUSH
90976: EMPTY
90977: LIST
90978: LIST
90979: IN
90980: PUSH
90981: LD_VAR 0 1
90985: PPUSH
90986: CALL_OW 255
90990: PPUSH
90991: LD_VAR 0 2
90995: PPUSH
90996: CALL_OW 292
91000: AND
91001: IFFALSE 91019
// ComAttackUnit ( unit , enemy ) else
91003: LD_VAR 0 1
91007: PPUSH
91008: LD_VAR 0 2
91012: PPUSH
91013: CALL_OW 115
91017: GO 91038
// ComAgressiveMove ( unit , x , y ) ;
91019: LD_VAR 0 1
91023: PPUSH
91024: LD_VAR 0 4
91028: PPUSH
91029: LD_VAR 0 5
91033: PPUSH
91034: CALL_OW 114
// end ;
91038: LD_VAR 0 3
91042: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
91043: LD_INT 0
91045: PPUSH
91046: PPUSH
91047: PPUSH
// list := AreaToList ( area , 0 ) ;
91048: LD_ADDR_VAR 0 5
91052: PUSH
91053: LD_VAR 0 1
91057: PPUSH
91058: LD_INT 0
91060: PPUSH
91061: CALL_OW 517
91065: ST_TO_ADDR
// if not list then
91066: LD_VAR 0 5
91070: NOT
91071: IFFALSE 91075
// exit ;
91073: GO 91205
// if all then
91075: LD_VAR 0 2
91079: IFFALSE 91167
// begin for i := 1 to list [ 1 ] do
91081: LD_ADDR_VAR 0 4
91085: PUSH
91086: DOUBLE
91087: LD_INT 1
91089: DEC
91090: ST_TO_ADDR
91091: LD_VAR 0 5
91095: PUSH
91096: LD_INT 1
91098: ARRAY
91099: PUSH
91100: FOR_TO
91101: IFFALSE 91163
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
91103: LD_ADDR_VAR 0 3
91107: PUSH
91108: LD_VAR 0 3
91112: PPUSH
91113: LD_VAR 0 3
91117: PUSH
91118: LD_INT 1
91120: PLUS
91121: PPUSH
91122: LD_VAR 0 5
91126: PUSH
91127: LD_INT 1
91129: ARRAY
91130: PUSH
91131: LD_VAR 0 4
91135: ARRAY
91136: PUSH
91137: LD_VAR 0 5
91141: PUSH
91142: LD_INT 2
91144: ARRAY
91145: PUSH
91146: LD_VAR 0 4
91150: ARRAY
91151: PUSH
91152: EMPTY
91153: LIST
91154: LIST
91155: PPUSH
91156: CALL_OW 1
91160: ST_TO_ADDR
91161: GO 91100
91163: POP
91164: POP
// exit ;
91165: GO 91205
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
91167: LD_ADDR_VAR 0 3
91171: PUSH
91172: LD_VAR 0 5
91176: PUSH
91177: LD_INT 1
91179: ARRAY
91180: PUSH
91181: LD_INT 1
91183: ARRAY
91184: PUSH
91185: LD_VAR 0 5
91189: PUSH
91190: LD_INT 2
91192: ARRAY
91193: PUSH
91194: LD_INT 1
91196: ARRAY
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: PUSH
91202: EMPTY
91203: LIST
91204: ST_TO_ADDR
// end ;
91205: LD_VAR 0 3
91209: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
91210: LD_INT 0
91212: PPUSH
91213: PPUSH
// list := AreaToList ( area , 0 ) ;
91214: LD_ADDR_VAR 0 4
91218: PUSH
91219: LD_VAR 0 1
91223: PPUSH
91224: LD_INT 0
91226: PPUSH
91227: CALL_OW 517
91231: ST_TO_ADDR
// if not list then
91232: LD_VAR 0 4
91236: NOT
91237: IFFALSE 91241
// exit ;
91239: GO 91282
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
91241: LD_ADDR_VAR 0 3
91245: PUSH
91246: LD_VAR 0 4
91250: PUSH
91251: LD_INT 1
91253: ARRAY
91254: PUSH
91255: LD_INT 1
91257: ARRAY
91258: PUSH
91259: LD_VAR 0 4
91263: PUSH
91264: LD_INT 2
91266: ARRAY
91267: PUSH
91268: LD_INT 1
91270: ARRAY
91271: PUSH
91272: LD_VAR 0 2
91276: PUSH
91277: EMPTY
91278: LIST
91279: LIST
91280: LIST
91281: ST_TO_ADDR
// end ;
91282: LD_VAR 0 3
91286: RET
// export function First ( array ) ; begin
91287: LD_INT 0
91289: PPUSH
// if not array then
91290: LD_VAR 0 1
91294: NOT
91295: IFFALSE 91299
// exit ;
91297: GO 91313
// result := array [ 1 ] ;
91299: LD_ADDR_VAR 0 2
91303: PUSH
91304: LD_VAR 0 1
91308: PUSH
91309: LD_INT 1
91311: ARRAY
91312: ST_TO_ADDR
// end ;
91313: LD_VAR 0 2
91317: RET
// export function Last ( array ) ; begin
91318: LD_INT 0
91320: PPUSH
// if not array then
91321: LD_VAR 0 1
91325: NOT
91326: IFFALSE 91330
// exit ;
91328: GO 91346
// result := array [ array ] ;
91330: LD_ADDR_VAR 0 2
91334: PUSH
91335: LD_VAR 0 1
91339: PUSH
91340: LD_VAR 0 1
91344: ARRAY
91345: ST_TO_ADDR
// end ; end_of_file end_of_file
91346: LD_VAR 0 2
91350: RET
// export globalGameSaveCounter ; every 0 0$1 do
91351: GO 91353
91353: DISABLE
// begin enable ;
91354: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
91355: LD_STRING updateTimer(
91357: PUSH
91358: LD_OWVAR 1
91362: STR
91363: PUSH
91364: LD_STRING );
91366: STR
91367: PPUSH
91368: CALL_OW 559
// end ;
91372: END
// every 0 0$1 do
91373: GO 91375
91375: DISABLE
// begin globalGameSaveCounter := 0 ;
91376: LD_ADDR_EXP 95
91380: PUSH
91381: LD_INT 0
91383: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
91384: LD_STRING setGameSaveCounter(0)
91386: PPUSH
91387: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
91391: LD_STRING initStreamRollete();
91393: PPUSH
91394: CALL_OW 559
// InitStreamMode ;
91398: CALL 92724 0 0
// DefineStreamItems ( false ) ;
91402: LD_INT 0
91404: PPUSH
91405: CALL 93188 0 1
// end ;
91409: END
// export function SOS_MapStart ( ) ; begin
91410: LD_INT 0
91412: PPUSH
// if streamModeActive then
91413: LD_EXP 96
91417: IFFALSE 91426
// DefineStreamItems ( true ) ;
91419: LD_INT 1
91421: PPUSH
91422: CALL 93188 0 1
// UpdateLuaVariables ( ) ;
91426: CALL 91443 0 0
// UpdateFactoryWaypoints ( ) ;
91430: CALL 106057 0 0
// UpdateWarehouseGatheringPoints ( ) ;
91434: CALL 106314 0 0
// end ;
91438: LD_VAR 0 1
91442: RET
// function UpdateLuaVariables ( ) ; begin
91443: LD_INT 0
91445: PPUSH
// if globalGameSaveCounter then
91446: LD_EXP 95
91450: IFFALSE 91484
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
91452: LD_ADDR_EXP 95
91456: PUSH
91457: LD_EXP 95
91461: PPUSH
91462: CALL 88182 0 1
91466: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91467: LD_STRING setGameSaveCounter(
91469: PUSH
91470: LD_EXP 95
91474: STR
91475: PUSH
91476: LD_STRING )
91478: STR
91479: PPUSH
91480: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
91484: LD_STRING setGameDifficulty(
91486: PUSH
91487: LD_OWVAR 67
91491: STR
91492: PUSH
91493: LD_STRING )
91495: STR
91496: PPUSH
91497: CALL_OW 559
// end ;
91501: LD_VAR 0 1
91505: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91506: LD_INT 0
91508: PPUSH
// if p2 = stream_mode then
91509: LD_VAR 0 2
91513: PUSH
91514: LD_INT 100
91516: EQUAL
91517: IFFALSE 92520
// begin if not StreamModeActive then
91519: LD_EXP 96
91523: NOT
91524: IFFALSE 91534
// StreamModeActive := true ;
91526: LD_ADDR_EXP 96
91530: PUSH
91531: LD_INT 1
91533: ST_TO_ADDR
// if p3 = 0 then
91534: LD_VAR 0 3
91538: PUSH
91539: LD_INT 0
91541: EQUAL
91542: IFFALSE 91548
// InitStreamMode ;
91544: CALL 92724 0 0
// if p3 = 1 then
91548: LD_VAR 0 3
91552: PUSH
91553: LD_INT 1
91555: EQUAL
91556: IFFALSE 91566
// sRocket := true ;
91558: LD_ADDR_EXP 101
91562: PUSH
91563: LD_INT 1
91565: ST_TO_ADDR
// if p3 = 2 then
91566: LD_VAR 0 3
91570: PUSH
91571: LD_INT 2
91573: EQUAL
91574: IFFALSE 91584
// sSpeed := true ;
91576: LD_ADDR_EXP 100
91580: PUSH
91581: LD_INT 1
91583: ST_TO_ADDR
// if p3 = 3 then
91584: LD_VAR 0 3
91588: PUSH
91589: LD_INT 3
91591: EQUAL
91592: IFFALSE 91602
// sEngine := true ;
91594: LD_ADDR_EXP 102
91598: PUSH
91599: LD_INT 1
91601: ST_TO_ADDR
// if p3 = 4 then
91602: LD_VAR 0 3
91606: PUSH
91607: LD_INT 4
91609: EQUAL
91610: IFFALSE 91620
// sSpec := true ;
91612: LD_ADDR_EXP 99
91616: PUSH
91617: LD_INT 1
91619: ST_TO_ADDR
// if p3 = 5 then
91620: LD_VAR 0 3
91624: PUSH
91625: LD_INT 5
91627: EQUAL
91628: IFFALSE 91638
// sLevel := true ;
91630: LD_ADDR_EXP 103
91634: PUSH
91635: LD_INT 1
91637: ST_TO_ADDR
// if p3 = 6 then
91638: LD_VAR 0 3
91642: PUSH
91643: LD_INT 6
91645: EQUAL
91646: IFFALSE 91656
// sArmoury := true ;
91648: LD_ADDR_EXP 104
91652: PUSH
91653: LD_INT 1
91655: ST_TO_ADDR
// if p3 = 7 then
91656: LD_VAR 0 3
91660: PUSH
91661: LD_INT 7
91663: EQUAL
91664: IFFALSE 91674
// sRadar := true ;
91666: LD_ADDR_EXP 105
91670: PUSH
91671: LD_INT 1
91673: ST_TO_ADDR
// if p3 = 8 then
91674: LD_VAR 0 3
91678: PUSH
91679: LD_INT 8
91681: EQUAL
91682: IFFALSE 91692
// sBunker := true ;
91684: LD_ADDR_EXP 106
91688: PUSH
91689: LD_INT 1
91691: ST_TO_ADDR
// if p3 = 9 then
91692: LD_VAR 0 3
91696: PUSH
91697: LD_INT 9
91699: EQUAL
91700: IFFALSE 91710
// sHack := true ;
91702: LD_ADDR_EXP 107
91706: PUSH
91707: LD_INT 1
91709: ST_TO_ADDR
// if p3 = 10 then
91710: LD_VAR 0 3
91714: PUSH
91715: LD_INT 10
91717: EQUAL
91718: IFFALSE 91728
// sFire := true ;
91720: LD_ADDR_EXP 108
91724: PUSH
91725: LD_INT 1
91727: ST_TO_ADDR
// if p3 = 11 then
91728: LD_VAR 0 3
91732: PUSH
91733: LD_INT 11
91735: EQUAL
91736: IFFALSE 91746
// sRefresh := true ;
91738: LD_ADDR_EXP 109
91742: PUSH
91743: LD_INT 1
91745: ST_TO_ADDR
// if p3 = 12 then
91746: LD_VAR 0 3
91750: PUSH
91751: LD_INT 12
91753: EQUAL
91754: IFFALSE 91764
// sExp := true ;
91756: LD_ADDR_EXP 110
91760: PUSH
91761: LD_INT 1
91763: ST_TO_ADDR
// if p3 = 13 then
91764: LD_VAR 0 3
91768: PUSH
91769: LD_INT 13
91771: EQUAL
91772: IFFALSE 91782
// sDepot := true ;
91774: LD_ADDR_EXP 111
91778: PUSH
91779: LD_INT 1
91781: ST_TO_ADDR
// if p3 = 14 then
91782: LD_VAR 0 3
91786: PUSH
91787: LD_INT 14
91789: EQUAL
91790: IFFALSE 91800
// sFlag := true ;
91792: LD_ADDR_EXP 112
91796: PUSH
91797: LD_INT 1
91799: ST_TO_ADDR
// if p3 = 15 then
91800: LD_VAR 0 3
91804: PUSH
91805: LD_INT 15
91807: EQUAL
91808: IFFALSE 91818
// sKamikadze := true ;
91810: LD_ADDR_EXP 120
91814: PUSH
91815: LD_INT 1
91817: ST_TO_ADDR
// if p3 = 16 then
91818: LD_VAR 0 3
91822: PUSH
91823: LD_INT 16
91825: EQUAL
91826: IFFALSE 91836
// sTroll := true ;
91828: LD_ADDR_EXP 121
91832: PUSH
91833: LD_INT 1
91835: ST_TO_ADDR
// if p3 = 17 then
91836: LD_VAR 0 3
91840: PUSH
91841: LD_INT 17
91843: EQUAL
91844: IFFALSE 91854
// sSlow := true ;
91846: LD_ADDR_EXP 122
91850: PUSH
91851: LD_INT 1
91853: ST_TO_ADDR
// if p3 = 18 then
91854: LD_VAR 0 3
91858: PUSH
91859: LD_INT 18
91861: EQUAL
91862: IFFALSE 91872
// sLack := true ;
91864: LD_ADDR_EXP 123
91868: PUSH
91869: LD_INT 1
91871: ST_TO_ADDR
// if p3 = 19 then
91872: LD_VAR 0 3
91876: PUSH
91877: LD_INT 19
91879: EQUAL
91880: IFFALSE 91890
// sTank := true ;
91882: LD_ADDR_EXP 125
91886: PUSH
91887: LD_INT 1
91889: ST_TO_ADDR
// if p3 = 20 then
91890: LD_VAR 0 3
91894: PUSH
91895: LD_INT 20
91897: EQUAL
91898: IFFALSE 91908
// sRemote := true ;
91900: LD_ADDR_EXP 126
91904: PUSH
91905: LD_INT 1
91907: ST_TO_ADDR
// if p3 = 21 then
91908: LD_VAR 0 3
91912: PUSH
91913: LD_INT 21
91915: EQUAL
91916: IFFALSE 91926
// sPowell := true ;
91918: LD_ADDR_EXP 127
91922: PUSH
91923: LD_INT 1
91925: ST_TO_ADDR
// if p3 = 22 then
91926: LD_VAR 0 3
91930: PUSH
91931: LD_INT 22
91933: EQUAL
91934: IFFALSE 91944
// sTeleport := true ;
91936: LD_ADDR_EXP 130
91940: PUSH
91941: LD_INT 1
91943: ST_TO_ADDR
// if p3 = 23 then
91944: LD_VAR 0 3
91948: PUSH
91949: LD_INT 23
91951: EQUAL
91952: IFFALSE 91962
// sOilTower := true ;
91954: LD_ADDR_EXP 132
91958: PUSH
91959: LD_INT 1
91961: ST_TO_ADDR
// if p3 = 24 then
91962: LD_VAR 0 3
91966: PUSH
91967: LD_INT 24
91969: EQUAL
91970: IFFALSE 91980
// sShovel := true ;
91972: LD_ADDR_EXP 133
91976: PUSH
91977: LD_INT 1
91979: ST_TO_ADDR
// if p3 = 25 then
91980: LD_VAR 0 3
91984: PUSH
91985: LD_INT 25
91987: EQUAL
91988: IFFALSE 91998
// sSheik := true ;
91990: LD_ADDR_EXP 134
91994: PUSH
91995: LD_INT 1
91997: ST_TO_ADDR
// if p3 = 26 then
91998: LD_VAR 0 3
92002: PUSH
92003: LD_INT 26
92005: EQUAL
92006: IFFALSE 92016
// sEarthquake := true ;
92008: LD_ADDR_EXP 136
92012: PUSH
92013: LD_INT 1
92015: ST_TO_ADDR
// if p3 = 27 then
92016: LD_VAR 0 3
92020: PUSH
92021: LD_INT 27
92023: EQUAL
92024: IFFALSE 92034
// sAI := true ;
92026: LD_ADDR_EXP 137
92030: PUSH
92031: LD_INT 1
92033: ST_TO_ADDR
// if p3 = 28 then
92034: LD_VAR 0 3
92038: PUSH
92039: LD_INT 28
92041: EQUAL
92042: IFFALSE 92052
// sCargo := true ;
92044: LD_ADDR_EXP 140
92048: PUSH
92049: LD_INT 1
92051: ST_TO_ADDR
// if p3 = 29 then
92052: LD_VAR 0 3
92056: PUSH
92057: LD_INT 29
92059: EQUAL
92060: IFFALSE 92070
// sDLaser := true ;
92062: LD_ADDR_EXP 141
92066: PUSH
92067: LD_INT 1
92069: ST_TO_ADDR
// if p3 = 30 then
92070: LD_VAR 0 3
92074: PUSH
92075: LD_INT 30
92077: EQUAL
92078: IFFALSE 92088
// sExchange := true ;
92080: LD_ADDR_EXP 142
92084: PUSH
92085: LD_INT 1
92087: ST_TO_ADDR
// if p3 = 31 then
92088: LD_VAR 0 3
92092: PUSH
92093: LD_INT 31
92095: EQUAL
92096: IFFALSE 92106
// sFac := true ;
92098: LD_ADDR_EXP 143
92102: PUSH
92103: LD_INT 1
92105: ST_TO_ADDR
// if p3 = 32 then
92106: LD_VAR 0 3
92110: PUSH
92111: LD_INT 32
92113: EQUAL
92114: IFFALSE 92124
// sPower := true ;
92116: LD_ADDR_EXP 144
92120: PUSH
92121: LD_INT 1
92123: ST_TO_ADDR
// if p3 = 33 then
92124: LD_VAR 0 3
92128: PUSH
92129: LD_INT 33
92131: EQUAL
92132: IFFALSE 92142
// sRandom := true ;
92134: LD_ADDR_EXP 145
92138: PUSH
92139: LD_INT 1
92141: ST_TO_ADDR
// if p3 = 34 then
92142: LD_VAR 0 3
92146: PUSH
92147: LD_INT 34
92149: EQUAL
92150: IFFALSE 92160
// sShield := true ;
92152: LD_ADDR_EXP 146
92156: PUSH
92157: LD_INT 1
92159: ST_TO_ADDR
// if p3 = 35 then
92160: LD_VAR 0 3
92164: PUSH
92165: LD_INT 35
92167: EQUAL
92168: IFFALSE 92178
// sTime := true ;
92170: LD_ADDR_EXP 147
92174: PUSH
92175: LD_INT 1
92177: ST_TO_ADDR
// if p3 = 36 then
92178: LD_VAR 0 3
92182: PUSH
92183: LD_INT 36
92185: EQUAL
92186: IFFALSE 92196
// sTools := true ;
92188: LD_ADDR_EXP 148
92192: PUSH
92193: LD_INT 1
92195: ST_TO_ADDR
// if p3 = 101 then
92196: LD_VAR 0 3
92200: PUSH
92201: LD_INT 101
92203: EQUAL
92204: IFFALSE 92214
// sSold := true ;
92206: LD_ADDR_EXP 113
92210: PUSH
92211: LD_INT 1
92213: ST_TO_ADDR
// if p3 = 102 then
92214: LD_VAR 0 3
92218: PUSH
92219: LD_INT 102
92221: EQUAL
92222: IFFALSE 92232
// sDiff := true ;
92224: LD_ADDR_EXP 114
92228: PUSH
92229: LD_INT 1
92231: ST_TO_ADDR
// if p3 = 103 then
92232: LD_VAR 0 3
92236: PUSH
92237: LD_INT 103
92239: EQUAL
92240: IFFALSE 92250
// sFog := true ;
92242: LD_ADDR_EXP 117
92246: PUSH
92247: LD_INT 1
92249: ST_TO_ADDR
// if p3 = 104 then
92250: LD_VAR 0 3
92254: PUSH
92255: LD_INT 104
92257: EQUAL
92258: IFFALSE 92268
// sReset := true ;
92260: LD_ADDR_EXP 118
92264: PUSH
92265: LD_INT 1
92267: ST_TO_ADDR
// if p3 = 105 then
92268: LD_VAR 0 3
92272: PUSH
92273: LD_INT 105
92275: EQUAL
92276: IFFALSE 92286
// sSun := true ;
92278: LD_ADDR_EXP 119
92282: PUSH
92283: LD_INT 1
92285: ST_TO_ADDR
// if p3 = 106 then
92286: LD_VAR 0 3
92290: PUSH
92291: LD_INT 106
92293: EQUAL
92294: IFFALSE 92304
// sTiger := true ;
92296: LD_ADDR_EXP 115
92300: PUSH
92301: LD_INT 1
92303: ST_TO_ADDR
// if p3 = 107 then
92304: LD_VAR 0 3
92308: PUSH
92309: LD_INT 107
92311: EQUAL
92312: IFFALSE 92322
// sBomb := true ;
92314: LD_ADDR_EXP 116
92318: PUSH
92319: LD_INT 1
92321: ST_TO_ADDR
// if p3 = 108 then
92322: LD_VAR 0 3
92326: PUSH
92327: LD_INT 108
92329: EQUAL
92330: IFFALSE 92340
// sWound := true ;
92332: LD_ADDR_EXP 124
92336: PUSH
92337: LD_INT 1
92339: ST_TO_ADDR
// if p3 = 109 then
92340: LD_VAR 0 3
92344: PUSH
92345: LD_INT 109
92347: EQUAL
92348: IFFALSE 92358
// sBetray := true ;
92350: LD_ADDR_EXP 128
92354: PUSH
92355: LD_INT 1
92357: ST_TO_ADDR
// if p3 = 110 then
92358: LD_VAR 0 3
92362: PUSH
92363: LD_INT 110
92365: EQUAL
92366: IFFALSE 92376
// sContamin := true ;
92368: LD_ADDR_EXP 129
92372: PUSH
92373: LD_INT 1
92375: ST_TO_ADDR
// if p3 = 111 then
92376: LD_VAR 0 3
92380: PUSH
92381: LD_INT 111
92383: EQUAL
92384: IFFALSE 92394
// sOil := true ;
92386: LD_ADDR_EXP 131
92390: PUSH
92391: LD_INT 1
92393: ST_TO_ADDR
// if p3 = 112 then
92394: LD_VAR 0 3
92398: PUSH
92399: LD_INT 112
92401: EQUAL
92402: IFFALSE 92412
// sStu := true ;
92404: LD_ADDR_EXP 135
92408: PUSH
92409: LD_INT 1
92411: ST_TO_ADDR
// if p3 = 113 then
92412: LD_VAR 0 3
92416: PUSH
92417: LD_INT 113
92419: EQUAL
92420: IFFALSE 92430
// sBazooka := true ;
92422: LD_ADDR_EXP 138
92426: PUSH
92427: LD_INT 1
92429: ST_TO_ADDR
// if p3 = 114 then
92430: LD_VAR 0 3
92434: PUSH
92435: LD_INT 114
92437: EQUAL
92438: IFFALSE 92448
// sMortar := true ;
92440: LD_ADDR_EXP 139
92444: PUSH
92445: LD_INT 1
92447: ST_TO_ADDR
// if p3 = 115 then
92448: LD_VAR 0 3
92452: PUSH
92453: LD_INT 115
92455: EQUAL
92456: IFFALSE 92466
// sRanger := true ;
92458: LD_ADDR_EXP 149
92462: PUSH
92463: LD_INT 1
92465: ST_TO_ADDR
// if p3 = 116 then
92466: LD_VAR 0 3
92470: PUSH
92471: LD_INT 116
92473: EQUAL
92474: IFFALSE 92484
// sComputer := true ;
92476: LD_ADDR_EXP 150
92480: PUSH
92481: LD_INT 1
92483: ST_TO_ADDR
// if p3 = 117 then
92484: LD_VAR 0 3
92488: PUSH
92489: LD_INT 117
92491: EQUAL
92492: IFFALSE 92502
// s30 := true ;
92494: LD_ADDR_EXP 151
92498: PUSH
92499: LD_INT 1
92501: ST_TO_ADDR
// if p3 = 118 then
92502: LD_VAR 0 3
92506: PUSH
92507: LD_INT 118
92509: EQUAL
92510: IFFALSE 92520
// s60 := true ;
92512: LD_ADDR_EXP 152
92516: PUSH
92517: LD_INT 1
92519: ST_TO_ADDR
// end ; if p2 = hack_mode then
92520: LD_VAR 0 2
92524: PUSH
92525: LD_INT 101
92527: EQUAL
92528: IFFALSE 92656
// begin case p3 of 1 :
92530: LD_VAR 0 3
92534: PUSH
92535: LD_INT 1
92537: DOUBLE
92538: EQUAL
92539: IFTRUE 92543
92541: GO 92550
92543: POP
// hHackUnlimitedResources ; 2 :
92544: CALL 104803 0 0
92548: GO 92656
92550: LD_INT 2
92552: DOUBLE
92553: EQUAL
92554: IFTRUE 92558
92556: GO 92565
92558: POP
// hHackSetLevel10 ; 3 :
92559: CALL 104936 0 0
92563: GO 92656
92565: LD_INT 3
92567: DOUBLE
92568: EQUAL
92569: IFTRUE 92573
92571: GO 92580
92573: POP
// hHackSetLevel10YourUnits ; 4 :
92574: CALL 105021 0 0
92578: GO 92656
92580: LD_INT 4
92582: DOUBLE
92583: EQUAL
92584: IFTRUE 92588
92586: GO 92595
92588: POP
// hHackInvincible ; 5 :
92589: CALL 105469 0 0
92593: GO 92656
92595: LD_INT 5
92597: DOUBLE
92598: EQUAL
92599: IFTRUE 92603
92601: GO 92610
92603: POP
// hHackInvisible ; 6 :
92604: CALL 105580 0 0
92608: GO 92656
92610: LD_INT 6
92612: DOUBLE
92613: EQUAL
92614: IFTRUE 92618
92616: GO 92625
92618: POP
// hHackChangeYourSide ; 7 :
92619: CALL 105637 0 0
92623: GO 92656
92625: LD_INT 7
92627: DOUBLE
92628: EQUAL
92629: IFTRUE 92633
92631: GO 92640
92633: POP
// hHackChangeUnitSide ; 8 :
92634: CALL 105679 0 0
92638: GO 92656
92640: LD_INT 8
92642: DOUBLE
92643: EQUAL
92644: IFTRUE 92648
92646: GO 92655
92648: POP
// hHackFog ; end ;
92649: CALL 105780 0 0
92653: GO 92656
92655: POP
// end ; if p2 = game_save_mode then
92656: LD_VAR 0 2
92660: PUSH
92661: LD_INT 102
92663: EQUAL
92664: IFFALSE 92719
// begin if p3 = 1 then
92666: LD_VAR 0 3
92670: PUSH
92671: LD_INT 1
92673: EQUAL
92674: IFFALSE 92686
// globalGameSaveCounter := p4 ;
92676: LD_ADDR_EXP 95
92680: PUSH
92681: LD_VAR 0 4
92685: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
92686: LD_VAR 0 3
92690: PUSH
92691: LD_INT 2
92693: EQUAL
92694: PUSH
92695: LD_EXP 95
92699: AND
92700: IFFALSE 92719
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92702: LD_STRING setGameSaveCounter(
92704: PUSH
92705: LD_EXP 95
92709: STR
92710: PUSH
92711: LD_STRING )
92713: STR
92714: PPUSH
92715: CALL_OW 559
// end ; end ;
92719: LD_VAR 0 7
92723: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
92724: LD_INT 0
92726: PPUSH
// streamModeActive := false ;
92727: LD_ADDR_EXP 96
92731: PUSH
92732: LD_INT 0
92734: ST_TO_ADDR
// normalCounter := 36 ;
92735: LD_ADDR_EXP 97
92739: PUSH
92740: LD_INT 36
92742: ST_TO_ADDR
// hardcoreCounter := 18 ;
92743: LD_ADDR_EXP 98
92747: PUSH
92748: LD_INT 18
92750: ST_TO_ADDR
// sRocket := false ;
92751: LD_ADDR_EXP 101
92755: PUSH
92756: LD_INT 0
92758: ST_TO_ADDR
// sSpeed := false ;
92759: LD_ADDR_EXP 100
92763: PUSH
92764: LD_INT 0
92766: ST_TO_ADDR
// sEngine := false ;
92767: LD_ADDR_EXP 102
92771: PUSH
92772: LD_INT 0
92774: ST_TO_ADDR
// sSpec := false ;
92775: LD_ADDR_EXP 99
92779: PUSH
92780: LD_INT 0
92782: ST_TO_ADDR
// sLevel := false ;
92783: LD_ADDR_EXP 103
92787: PUSH
92788: LD_INT 0
92790: ST_TO_ADDR
// sArmoury := false ;
92791: LD_ADDR_EXP 104
92795: PUSH
92796: LD_INT 0
92798: ST_TO_ADDR
// sRadar := false ;
92799: LD_ADDR_EXP 105
92803: PUSH
92804: LD_INT 0
92806: ST_TO_ADDR
// sBunker := false ;
92807: LD_ADDR_EXP 106
92811: PUSH
92812: LD_INT 0
92814: ST_TO_ADDR
// sHack := false ;
92815: LD_ADDR_EXP 107
92819: PUSH
92820: LD_INT 0
92822: ST_TO_ADDR
// sFire := false ;
92823: LD_ADDR_EXP 108
92827: PUSH
92828: LD_INT 0
92830: ST_TO_ADDR
// sRefresh := false ;
92831: LD_ADDR_EXP 109
92835: PUSH
92836: LD_INT 0
92838: ST_TO_ADDR
// sExp := false ;
92839: LD_ADDR_EXP 110
92843: PUSH
92844: LD_INT 0
92846: ST_TO_ADDR
// sDepot := false ;
92847: LD_ADDR_EXP 111
92851: PUSH
92852: LD_INT 0
92854: ST_TO_ADDR
// sFlag := false ;
92855: LD_ADDR_EXP 112
92859: PUSH
92860: LD_INT 0
92862: ST_TO_ADDR
// sKamikadze := false ;
92863: LD_ADDR_EXP 120
92867: PUSH
92868: LD_INT 0
92870: ST_TO_ADDR
// sTroll := false ;
92871: LD_ADDR_EXP 121
92875: PUSH
92876: LD_INT 0
92878: ST_TO_ADDR
// sSlow := false ;
92879: LD_ADDR_EXP 122
92883: PUSH
92884: LD_INT 0
92886: ST_TO_ADDR
// sLack := false ;
92887: LD_ADDR_EXP 123
92891: PUSH
92892: LD_INT 0
92894: ST_TO_ADDR
// sTank := false ;
92895: LD_ADDR_EXP 125
92899: PUSH
92900: LD_INT 0
92902: ST_TO_ADDR
// sRemote := false ;
92903: LD_ADDR_EXP 126
92907: PUSH
92908: LD_INT 0
92910: ST_TO_ADDR
// sPowell := false ;
92911: LD_ADDR_EXP 127
92915: PUSH
92916: LD_INT 0
92918: ST_TO_ADDR
// sTeleport := false ;
92919: LD_ADDR_EXP 130
92923: PUSH
92924: LD_INT 0
92926: ST_TO_ADDR
// sOilTower := false ;
92927: LD_ADDR_EXP 132
92931: PUSH
92932: LD_INT 0
92934: ST_TO_ADDR
// sShovel := false ;
92935: LD_ADDR_EXP 133
92939: PUSH
92940: LD_INT 0
92942: ST_TO_ADDR
// sSheik := false ;
92943: LD_ADDR_EXP 134
92947: PUSH
92948: LD_INT 0
92950: ST_TO_ADDR
// sEarthquake := false ;
92951: LD_ADDR_EXP 136
92955: PUSH
92956: LD_INT 0
92958: ST_TO_ADDR
// sAI := false ;
92959: LD_ADDR_EXP 137
92963: PUSH
92964: LD_INT 0
92966: ST_TO_ADDR
// sCargo := false ;
92967: LD_ADDR_EXP 140
92971: PUSH
92972: LD_INT 0
92974: ST_TO_ADDR
// sDLaser := false ;
92975: LD_ADDR_EXP 141
92979: PUSH
92980: LD_INT 0
92982: ST_TO_ADDR
// sExchange := false ;
92983: LD_ADDR_EXP 142
92987: PUSH
92988: LD_INT 0
92990: ST_TO_ADDR
// sFac := false ;
92991: LD_ADDR_EXP 143
92995: PUSH
92996: LD_INT 0
92998: ST_TO_ADDR
// sPower := false ;
92999: LD_ADDR_EXP 144
93003: PUSH
93004: LD_INT 0
93006: ST_TO_ADDR
// sRandom := false ;
93007: LD_ADDR_EXP 145
93011: PUSH
93012: LD_INT 0
93014: ST_TO_ADDR
// sShield := false ;
93015: LD_ADDR_EXP 146
93019: PUSH
93020: LD_INT 0
93022: ST_TO_ADDR
// sTime := false ;
93023: LD_ADDR_EXP 147
93027: PUSH
93028: LD_INT 0
93030: ST_TO_ADDR
// sTools := false ;
93031: LD_ADDR_EXP 148
93035: PUSH
93036: LD_INT 0
93038: ST_TO_ADDR
// sSold := false ;
93039: LD_ADDR_EXP 113
93043: PUSH
93044: LD_INT 0
93046: ST_TO_ADDR
// sDiff := false ;
93047: LD_ADDR_EXP 114
93051: PUSH
93052: LD_INT 0
93054: ST_TO_ADDR
// sFog := false ;
93055: LD_ADDR_EXP 117
93059: PUSH
93060: LD_INT 0
93062: ST_TO_ADDR
// sReset := false ;
93063: LD_ADDR_EXP 118
93067: PUSH
93068: LD_INT 0
93070: ST_TO_ADDR
// sSun := false ;
93071: LD_ADDR_EXP 119
93075: PUSH
93076: LD_INT 0
93078: ST_TO_ADDR
// sTiger := false ;
93079: LD_ADDR_EXP 115
93083: PUSH
93084: LD_INT 0
93086: ST_TO_ADDR
// sBomb := false ;
93087: LD_ADDR_EXP 116
93091: PUSH
93092: LD_INT 0
93094: ST_TO_ADDR
// sWound := false ;
93095: LD_ADDR_EXP 124
93099: PUSH
93100: LD_INT 0
93102: ST_TO_ADDR
// sBetray := false ;
93103: LD_ADDR_EXP 128
93107: PUSH
93108: LD_INT 0
93110: ST_TO_ADDR
// sContamin := false ;
93111: LD_ADDR_EXP 129
93115: PUSH
93116: LD_INT 0
93118: ST_TO_ADDR
// sOil := false ;
93119: LD_ADDR_EXP 131
93123: PUSH
93124: LD_INT 0
93126: ST_TO_ADDR
// sStu := false ;
93127: LD_ADDR_EXP 135
93131: PUSH
93132: LD_INT 0
93134: ST_TO_ADDR
// sBazooka := false ;
93135: LD_ADDR_EXP 138
93139: PUSH
93140: LD_INT 0
93142: ST_TO_ADDR
// sMortar := false ;
93143: LD_ADDR_EXP 139
93147: PUSH
93148: LD_INT 0
93150: ST_TO_ADDR
// sRanger := false ;
93151: LD_ADDR_EXP 149
93155: PUSH
93156: LD_INT 0
93158: ST_TO_ADDR
// sComputer := false ;
93159: LD_ADDR_EXP 150
93163: PUSH
93164: LD_INT 0
93166: ST_TO_ADDR
// s30 := false ;
93167: LD_ADDR_EXP 151
93171: PUSH
93172: LD_INT 0
93174: ST_TO_ADDR
// s60 := false ;
93175: LD_ADDR_EXP 152
93179: PUSH
93180: LD_INT 0
93182: ST_TO_ADDR
// end ;
93183: LD_VAR 0 1
93187: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93188: LD_INT 0
93190: PPUSH
93191: PPUSH
93192: PPUSH
93193: PPUSH
93194: PPUSH
93195: PPUSH
93196: PPUSH
// result := [ ] ;
93197: LD_ADDR_VAR 0 2
93201: PUSH
93202: EMPTY
93203: ST_TO_ADDR
// if campaign_id = 1 then
93204: LD_OWVAR 69
93208: PUSH
93209: LD_INT 1
93211: EQUAL
93212: IFFALSE 96378
// begin case mission_number of 1 :
93214: LD_OWVAR 70
93218: PUSH
93219: LD_INT 1
93221: DOUBLE
93222: EQUAL
93223: IFTRUE 93227
93225: GO 93303
93227: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93228: LD_ADDR_VAR 0 2
93232: PUSH
93233: LD_INT 2
93235: PUSH
93236: LD_INT 4
93238: PUSH
93239: LD_INT 11
93241: PUSH
93242: LD_INT 12
93244: PUSH
93245: LD_INT 15
93247: PUSH
93248: LD_INT 16
93250: PUSH
93251: LD_INT 22
93253: PUSH
93254: LD_INT 23
93256: PUSH
93257: LD_INT 26
93259: PUSH
93260: EMPTY
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: LIST
93270: PUSH
93271: LD_INT 101
93273: PUSH
93274: LD_INT 102
93276: PUSH
93277: LD_INT 106
93279: PUSH
93280: LD_INT 116
93282: PUSH
93283: LD_INT 117
93285: PUSH
93286: LD_INT 118
93288: PUSH
93289: EMPTY
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: LIST
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: ST_TO_ADDR
93301: GO 96376
93303: LD_INT 2
93305: DOUBLE
93306: EQUAL
93307: IFTRUE 93311
93309: GO 93395
93311: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93312: LD_ADDR_VAR 0 2
93316: PUSH
93317: LD_INT 2
93319: PUSH
93320: LD_INT 4
93322: PUSH
93323: LD_INT 11
93325: PUSH
93326: LD_INT 12
93328: PUSH
93329: LD_INT 15
93331: PUSH
93332: LD_INT 16
93334: PUSH
93335: LD_INT 22
93337: PUSH
93338: LD_INT 23
93340: PUSH
93341: LD_INT 26
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: PUSH
93355: LD_INT 101
93357: PUSH
93358: LD_INT 102
93360: PUSH
93361: LD_INT 105
93363: PUSH
93364: LD_INT 106
93366: PUSH
93367: LD_INT 108
93369: PUSH
93370: LD_INT 116
93372: PUSH
93373: LD_INT 117
93375: PUSH
93376: LD_INT 118
93378: PUSH
93379: EMPTY
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: LIST
93388: PUSH
93389: EMPTY
93390: LIST
93391: LIST
93392: ST_TO_ADDR
93393: GO 96376
93395: LD_INT 3
93397: DOUBLE
93398: EQUAL
93399: IFTRUE 93403
93401: GO 93491
93403: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
93404: LD_ADDR_VAR 0 2
93408: PUSH
93409: LD_INT 2
93411: PUSH
93412: LD_INT 4
93414: PUSH
93415: LD_INT 5
93417: PUSH
93418: LD_INT 11
93420: PUSH
93421: LD_INT 12
93423: PUSH
93424: LD_INT 15
93426: PUSH
93427: LD_INT 16
93429: PUSH
93430: LD_INT 22
93432: PUSH
93433: LD_INT 26
93435: PUSH
93436: LD_INT 36
93438: PUSH
93439: EMPTY
93440: LIST
93441: LIST
93442: LIST
93443: LIST
93444: LIST
93445: LIST
93446: LIST
93447: LIST
93448: LIST
93449: LIST
93450: PUSH
93451: LD_INT 101
93453: PUSH
93454: LD_INT 102
93456: PUSH
93457: LD_INT 105
93459: PUSH
93460: LD_INT 106
93462: PUSH
93463: LD_INT 108
93465: PUSH
93466: LD_INT 116
93468: PUSH
93469: LD_INT 117
93471: PUSH
93472: LD_INT 118
93474: PUSH
93475: EMPTY
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: PUSH
93485: EMPTY
93486: LIST
93487: LIST
93488: ST_TO_ADDR
93489: GO 96376
93491: LD_INT 4
93493: DOUBLE
93494: EQUAL
93495: IFTRUE 93499
93497: GO 93595
93499: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
93500: LD_ADDR_VAR 0 2
93504: PUSH
93505: LD_INT 2
93507: PUSH
93508: LD_INT 4
93510: PUSH
93511: LD_INT 5
93513: PUSH
93514: LD_INT 8
93516: PUSH
93517: LD_INT 11
93519: PUSH
93520: LD_INT 12
93522: PUSH
93523: LD_INT 15
93525: PUSH
93526: LD_INT 16
93528: PUSH
93529: LD_INT 22
93531: PUSH
93532: LD_INT 23
93534: PUSH
93535: LD_INT 26
93537: PUSH
93538: LD_INT 36
93540: PUSH
93541: EMPTY
93542: LIST
93543: LIST
93544: LIST
93545: LIST
93546: LIST
93547: LIST
93548: LIST
93549: LIST
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: PUSH
93555: LD_INT 101
93557: PUSH
93558: LD_INT 102
93560: PUSH
93561: LD_INT 105
93563: PUSH
93564: LD_INT 106
93566: PUSH
93567: LD_INT 108
93569: PUSH
93570: LD_INT 116
93572: PUSH
93573: LD_INT 117
93575: PUSH
93576: LD_INT 118
93578: PUSH
93579: EMPTY
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: LIST
93587: LIST
93588: PUSH
93589: EMPTY
93590: LIST
93591: LIST
93592: ST_TO_ADDR
93593: GO 96376
93595: LD_INT 5
93597: DOUBLE
93598: EQUAL
93599: IFTRUE 93603
93601: GO 93715
93603: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
93604: LD_ADDR_VAR 0 2
93608: PUSH
93609: LD_INT 2
93611: PUSH
93612: LD_INT 4
93614: PUSH
93615: LD_INT 5
93617: PUSH
93618: LD_INT 6
93620: PUSH
93621: LD_INT 8
93623: PUSH
93624: LD_INT 11
93626: PUSH
93627: LD_INT 12
93629: PUSH
93630: LD_INT 15
93632: PUSH
93633: LD_INT 16
93635: PUSH
93636: LD_INT 22
93638: PUSH
93639: LD_INT 23
93641: PUSH
93642: LD_INT 25
93644: PUSH
93645: LD_INT 26
93647: PUSH
93648: LD_INT 36
93650: PUSH
93651: EMPTY
93652: LIST
93653: LIST
93654: LIST
93655: LIST
93656: LIST
93657: LIST
93658: LIST
93659: LIST
93660: LIST
93661: LIST
93662: LIST
93663: LIST
93664: LIST
93665: LIST
93666: PUSH
93667: LD_INT 101
93669: PUSH
93670: LD_INT 102
93672: PUSH
93673: LD_INT 105
93675: PUSH
93676: LD_INT 106
93678: PUSH
93679: LD_INT 108
93681: PUSH
93682: LD_INT 109
93684: PUSH
93685: LD_INT 112
93687: PUSH
93688: LD_INT 116
93690: PUSH
93691: LD_INT 117
93693: PUSH
93694: LD_INT 118
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: LIST
93706: LIST
93707: LIST
93708: PUSH
93709: EMPTY
93710: LIST
93711: LIST
93712: ST_TO_ADDR
93713: GO 96376
93715: LD_INT 6
93717: DOUBLE
93718: EQUAL
93719: IFTRUE 93723
93721: GO 93855
93723: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
93724: LD_ADDR_VAR 0 2
93728: PUSH
93729: LD_INT 2
93731: PUSH
93732: LD_INT 4
93734: PUSH
93735: LD_INT 5
93737: PUSH
93738: LD_INT 6
93740: PUSH
93741: LD_INT 8
93743: PUSH
93744: LD_INT 11
93746: PUSH
93747: LD_INT 12
93749: PUSH
93750: LD_INT 15
93752: PUSH
93753: LD_INT 16
93755: PUSH
93756: LD_INT 20
93758: PUSH
93759: LD_INT 21
93761: PUSH
93762: LD_INT 22
93764: PUSH
93765: LD_INT 23
93767: PUSH
93768: LD_INT 25
93770: PUSH
93771: LD_INT 26
93773: PUSH
93774: LD_INT 30
93776: PUSH
93777: LD_INT 31
93779: PUSH
93780: LD_INT 32
93782: PUSH
93783: LD_INT 36
93785: PUSH
93786: EMPTY
93787: LIST
93788: LIST
93789: LIST
93790: LIST
93791: LIST
93792: LIST
93793: LIST
93794: LIST
93795: LIST
93796: LIST
93797: LIST
93798: LIST
93799: LIST
93800: LIST
93801: LIST
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: PUSH
93807: LD_INT 101
93809: PUSH
93810: LD_INT 102
93812: PUSH
93813: LD_INT 105
93815: PUSH
93816: LD_INT 106
93818: PUSH
93819: LD_INT 108
93821: PUSH
93822: LD_INT 109
93824: PUSH
93825: LD_INT 112
93827: PUSH
93828: LD_INT 116
93830: PUSH
93831: LD_INT 117
93833: PUSH
93834: LD_INT 118
93836: PUSH
93837: EMPTY
93838: LIST
93839: LIST
93840: LIST
93841: LIST
93842: LIST
93843: LIST
93844: LIST
93845: LIST
93846: LIST
93847: LIST
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: ST_TO_ADDR
93853: GO 96376
93855: LD_INT 7
93857: DOUBLE
93858: EQUAL
93859: IFTRUE 93863
93861: GO 93975
93863: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
93864: LD_ADDR_VAR 0 2
93868: PUSH
93869: LD_INT 2
93871: PUSH
93872: LD_INT 4
93874: PUSH
93875: LD_INT 5
93877: PUSH
93878: LD_INT 7
93880: PUSH
93881: LD_INT 11
93883: PUSH
93884: LD_INT 12
93886: PUSH
93887: LD_INT 15
93889: PUSH
93890: LD_INT 16
93892: PUSH
93893: LD_INT 20
93895: PUSH
93896: LD_INT 21
93898: PUSH
93899: LD_INT 22
93901: PUSH
93902: LD_INT 23
93904: PUSH
93905: LD_INT 25
93907: PUSH
93908: LD_INT 26
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: PUSH
93927: LD_INT 101
93929: PUSH
93930: LD_INT 102
93932: PUSH
93933: LD_INT 103
93935: PUSH
93936: LD_INT 105
93938: PUSH
93939: LD_INT 106
93941: PUSH
93942: LD_INT 108
93944: PUSH
93945: LD_INT 112
93947: PUSH
93948: LD_INT 116
93950: PUSH
93951: LD_INT 117
93953: PUSH
93954: LD_INT 118
93956: PUSH
93957: EMPTY
93958: LIST
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: LIST
93967: LIST
93968: PUSH
93969: EMPTY
93970: LIST
93971: LIST
93972: ST_TO_ADDR
93973: GO 96376
93975: LD_INT 8
93977: DOUBLE
93978: EQUAL
93979: IFTRUE 93983
93981: GO 94123
93983: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
93984: LD_ADDR_VAR 0 2
93988: PUSH
93989: LD_INT 2
93991: PUSH
93992: LD_INT 4
93994: PUSH
93995: LD_INT 5
93997: PUSH
93998: LD_INT 6
94000: PUSH
94001: LD_INT 7
94003: PUSH
94004: LD_INT 8
94006: PUSH
94007: LD_INT 11
94009: PUSH
94010: LD_INT 12
94012: PUSH
94013: LD_INT 15
94015: PUSH
94016: LD_INT 16
94018: PUSH
94019: LD_INT 20
94021: PUSH
94022: LD_INT 21
94024: PUSH
94025: LD_INT 22
94027: PUSH
94028: LD_INT 23
94030: PUSH
94031: LD_INT 25
94033: PUSH
94034: LD_INT 26
94036: PUSH
94037: LD_INT 30
94039: PUSH
94040: LD_INT 31
94042: PUSH
94043: LD_INT 32
94045: PUSH
94046: LD_INT 36
94048: PUSH
94049: EMPTY
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: LIST
94056: LIST
94057: LIST
94058: LIST
94059: LIST
94060: LIST
94061: LIST
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: PUSH
94071: LD_INT 101
94073: PUSH
94074: LD_INT 102
94076: PUSH
94077: LD_INT 103
94079: PUSH
94080: LD_INT 105
94082: PUSH
94083: LD_INT 106
94085: PUSH
94086: LD_INT 108
94088: PUSH
94089: LD_INT 109
94091: PUSH
94092: LD_INT 112
94094: PUSH
94095: LD_INT 116
94097: PUSH
94098: LD_INT 117
94100: PUSH
94101: LD_INT 118
94103: PUSH
94104: EMPTY
94105: LIST
94106: LIST
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: LIST
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: ST_TO_ADDR
94121: GO 96376
94123: LD_INT 9
94125: DOUBLE
94126: EQUAL
94127: IFTRUE 94131
94129: GO 94279
94131: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94132: LD_ADDR_VAR 0 2
94136: PUSH
94137: LD_INT 2
94139: PUSH
94140: LD_INT 4
94142: PUSH
94143: LD_INT 5
94145: PUSH
94146: LD_INT 6
94148: PUSH
94149: LD_INT 7
94151: PUSH
94152: LD_INT 8
94154: PUSH
94155: LD_INT 11
94157: PUSH
94158: LD_INT 12
94160: PUSH
94161: LD_INT 15
94163: PUSH
94164: LD_INT 16
94166: PUSH
94167: LD_INT 20
94169: PUSH
94170: LD_INT 21
94172: PUSH
94173: LD_INT 22
94175: PUSH
94176: LD_INT 23
94178: PUSH
94179: LD_INT 25
94181: PUSH
94182: LD_INT 26
94184: PUSH
94185: LD_INT 28
94187: PUSH
94188: LD_INT 30
94190: PUSH
94191: LD_INT 31
94193: PUSH
94194: LD_INT 32
94196: PUSH
94197: LD_INT 36
94199: PUSH
94200: EMPTY
94201: LIST
94202: LIST
94203: LIST
94204: LIST
94205: LIST
94206: LIST
94207: LIST
94208: LIST
94209: LIST
94210: LIST
94211: LIST
94212: LIST
94213: LIST
94214: LIST
94215: LIST
94216: LIST
94217: LIST
94218: LIST
94219: LIST
94220: LIST
94221: LIST
94222: PUSH
94223: LD_INT 101
94225: PUSH
94226: LD_INT 102
94228: PUSH
94229: LD_INT 103
94231: PUSH
94232: LD_INT 105
94234: PUSH
94235: LD_INT 106
94237: PUSH
94238: LD_INT 108
94240: PUSH
94241: LD_INT 109
94243: PUSH
94244: LD_INT 112
94246: PUSH
94247: LD_INT 114
94249: PUSH
94250: LD_INT 116
94252: PUSH
94253: LD_INT 117
94255: PUSH
94256: LD_INT 118
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: LIST
94263: LIST
94264: LIST
94265: LIST
94266: LIST
94267: LIST
94268: LIST
94269: LIST
94270: LIST
94271: LIST
94272: PUSH
94273: EMPTY
94274: LIST
94275: LIST
94276: ST_TO_ADDR
94277: GO 96376
94279: LD_INT 10
94281: DOUBLE
94282: EQUAL
94283: IFTRUE 94287
94285: GO 94483
94287: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94288: LD_ADDR_VAR 0 2
94292: PUSH
94293: LD_INT 2
94295: PUSH
94296: LD_INT 4
94298: PUSH
94299: LD_INT 5
94301: PUSH
94302: LD_INT 6
94304: PUSH
94305: LD_INT 7
94307: PUSH
94308: LD_INT 8
94310: PUSH
94311: LD_INT 9
94313: PUSH
94314: LD_INT 10
94316: PUSH
94317: LD_INT 11
94319: PUSH
94320: LD_INT 12
94322: PUSH
94323: LD_INT 13
94325: PUSH
94326: LD_INT 14
94328: PUSH
94329: LD_INT 15
94331: PUSH
94332: LD_INT 16
94334: PUSH
94335: LD_INT 17
94337: PUSH
94338: LD_INT 18
94340: PUSH
94341: LD_INT 19
94343: PUSH
94344: LD_INT 20
94346: PUSH
94347: LD_INT 21
94349: PUSH
94350: LD_INT 22
94352: PUSH
94353: LD_INT 23
94355: PUSH
94356: LD_INT 24
94358: PUSH
94359: LD_INT 25
94361: PUSH
94362: LD_INT 26
94364: PUSH
94365: LD_INT 28
94367: PUSH
94368: LD_INT 30
94370: PUSH
94371: LD_INT 31
94373: PUSH
94374: LD_INT 32
94376: PUSH
94377: LD_INT 36
94379: PUSH
94380: EMPTY
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: LIST
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: PUSH
94411: LD_INT 101
94413: PUSH
94414: LD_INT 102
94416: PUSH
94417: LD_INT 103
94419: PUSH
94420: LD_INT 104
94422: PUSH
94423: LD_INT 105
94425: PUSH
94426: LD_INT 106
94428: PUSH
94429: LD_INT 107
94431: PUSH
94432: LD_INT 108
94434: PUSH
94435: LD_INT 109
94437: PUSH
94438: LD_INT 110
94440: PUSH
94441: LD_INT 111
94443: PUSH
94444: LD_INT 112
94446: PUSH
94447: LD_INT 114
94449: PUSH
94450: LD_INT 116
94452: PUSH
94453: LD_INT 117
94455: PUSH
94456: LD_INT 118
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: PUSH
94477: EMPTY
94478: LIST
94479: LIST
94480: ST_TO_ADDR
94481: GO 96376
94483: LD_INT 11
94485: DOUBLE
94486: EQUAL
94487: IFTRUE 94491
94489: GO 94695
94491: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
94492: LD_ADDR_VAR 0 2
94496: PUSH
94497: LD_INT 2
94499: PUSH
94500: LD_INT 3
94502: PUSH
94503: LD_INT 4
94505: PUSH
94506: LD_INT 5
94508: PUSH
94509: LD_INT 6
94511: PUSH
94512: LD_INT 7
94514: PUSH
94515: LD_INT 8
94517: PUSH
94518: LD_INT 9
94520: PUSH
94521: LD_INT 10
94523: PUSH
94524: LD_INT 11
94526: PUSH
94527: LD_INT 12
94529: PUSH
94530: LD_INT 13
94532: PUSH
94533: LD_INT 14
94535: PUSH
94536: LD_INT 15
94538: PUSH
94539: LD_INT 16
94541: PUSH
94542: LD_INT 17
94544: PUSH
94545: LD_INT 18
94547: PUSH
94548: LD_INT 19
94550: PUSH
94551: LD_INT 20
94553: PUSH
94554: LD_INT 21
94556: PUSH
94557: LD_INT 22
94559: PUSH
94560: LD_INT 23
94562: PUSH
94563: LD_INT 24
94565: PUSH
94566: LD_INT 25
94568: PUSH
94569: LD_INT 26
94571: PUSH
94572: LD_INT 28
94574: PUSH
94575: LD_INT 30
94577: PUSH
94578: LD_INT 31
94580: PUSH
94581: LD_INT 32
94583: PUSH
94584: LD_INT 34
94586: PUSH
94587: LD_INT 36
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: PUSH
94623: LD_INT 101
94625: PUSH
94626: LD_INT 102
94628: PUSH
94629: LD_INT 103
94631: PUSH
94632: LD_INT 104
94634: PUSH
94635: LD_INT 105
94637: PUSH
94638: LD_INT 106
94640: PUSH
94641: LD_INT 107
94643: PUSH
94644: LD_INT 108
94646: PUSH
94647: LD_INT 109
94649: PUSH
94650: LD_INT 110
94652: PUSH
94653: LD_INT 111
94655: PUSH
94656: LD_INT 112
94658: PUSH
94659: LD_INT 114
94661: PUSH
94662: LD_INT 116
94664: PUSH
94665: LD_INT 117
94667: PUSH
94668: LD_INT 118
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: PUSH
94689: EMPTY
94690: LIST
94691: LIST
94692: ST_TO_ADDR
94693: GO 96376
94695: LD_INT 12
94697: DOUBLE
94698: EQUAL
94699: IFTRUE 94703
94701: GO 94923
94703: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
94704: LD_ADDR_VAR 0 2
94708: PUSH
94709: LD_INT 1
94711: PUSH
94712: LD_INT 2
94714: PUSH
94715: LD_INT 3
94717: PUSH
94718: LD_INT 4
94720: PUSH
94721: LD_INT 5
94723: PUSH
94724: LD_INT 6
94726: PUSH
94727: LD_INT 7
94729: PUSH
94730: LD_INT 8
94732: PUSH
94733: LD_INT 9
94735: PUSH
94736: LD_INT 10
94738: PUSH
94739: LD_INT 11
94741: PUSH
94742: LD_INT 12
94744: PUSH
94745: LD_INT 13
94747: PUSH
94748: LD_INT 14
94750: PUSH
94751: LD_INT 15
94753: PUSH
94754: LD_INT 16
94756: PUSH
94757: LD_INT 17
94759: PUSH
94760: LD_INT 18
94762: PUSH
94763: LD_INT 19
94765: PUSH
94766: LD_INT 20
94768: PUSH
94769: LD_INT 21
94771: PUSH
94772: LD_INT 22
94774: PUSH
94775: LD_INT 23
94777: PUSH
94778: LD_INT 24
94780: PUSH
94781: LD_INT 25
94783: PUSH
94784: LD_INT 26
94786: PUSH
94787: LD_INT 27
94789: PUSH
94790: LD_INT 28
94792: PUSH
94793: LD_INT 30
94795: PUSH
94796: LD_INT 31
94798: PUSH
94799: LD_INT 32
94801: PUSH
94802: LD_INT 33
94804: PUSH
94805: LD_INT 34
94807: PUSH
94808: LD_INT 36
94810: PUSH
94811: EMPTY
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: PUSH
94847: LD_INT 101
94849: PUSH
94850: LD_INT 102
94852: PUSH
94853: LD_INT 103
94855: PUSH
94856: LD_INT 104
94858: PUSH
94859: LD_INT 105
94861: PUSH
94862: LD_INT 106
94864: PUSH
94865: LD_INT 107
94867: PUSH
94868: LD_INT 108
94870: PUSH
94871: LD_INT 109
94873: PUSH
94874: LD_INT 110
94876: PUSH
94877: LD_INT 111
94879: PUSH
94880: LD_INT 112
94882: PUSH
94883: LD_INT 113
94885: PUSH
94886: LD_INT 114
94888: PUSH
94889: LD_INT 116
94891: PUSH
94892: LD_INT 117
94894: PUSH
94895: LD_INT 118
94897: PUSH
94898: EMPTY
94899: LIST
94900: LIST
94901: LIST
94902: LIST
94903: LIST
94904: LIST
94905: LIST
94906: LIST
94907: LIST
94908: LIST
94909: LIST
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: PUSH
94917: EMPTY
94918: LIST
94919: LIST
94920: ST_TO_ADDR
94921: GO 96376
94923: LD_INT 13
94925: DOUBLE
94926: EQUAL
94927: IFTRUE 94931
94929: GO 95139
94931: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
94932: LD_ADDR_VAR 0 2
94936: PUSH
94937: LD_INT 1
94939: PUSH
94940: LD_INT 2
94942: PUSH
94943: LD_INT 3
94945: PUSH
94946: LD_INT 4
94948: PUSH
94949: LD_INT 5
94951: PUSH
94952: LD_INT 8
94954: PUSH
94955: LD_INT 9
94957: PUSH
94958: LD_INT 10
94960: PUSH
94961: LD_INT 11
94963: PUSH
94964: LD_INT 12
94966: PUSH
94967: LD_INT 14
94969: PUSH
94970: LD_INT 15
94972: PUSH
94973: LD_INT 16
94975: PUSH
94976: LD_INT 17
94978: PUSH
94979: LD_INT 18
94981: PUSH
94982: LD_INT 19
94984: PUSH
94985: LD_INT 20
94987: PUSH
94988: LD_INT 21
94990: PUSH
94991: LD_INT 22
94993: PUSH
94994: LD_INT 23
94996: PUSH
94997: LD_INT 24
94999: PUSH
95000: LD_INT 25
95002: PUSH
95003: LD_INT 26
95005: PUSH
95006: LD_INT 27
95008: PUSH
95009: LD_INT 28
95011: PUSH
95012: LD_INT 30
95014: PUSH
95015: LD_INT 31
95017: PUSH
95018: LD_INT 32
95020: PUSH
95021: LD_INT 33
95023: PUSH
95024: LD_INT 34
95026: PUSH
95027: LD_INT 36
95029: PUSH
95030: EMPTY
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: PUSH
95063: LD_INT 101
95065: PUSH
95066: LD_INT 102
95068: PUSH
95069: LD_INT 103
95071: PUSH
95072: LD_INT 104
95074: PUSH
95075: LD_INT 105
95077: PUSH
95078: LD_INT 106
95080: PUSH
95081: LD_INT 107
95083: PUSH
95084: LD_INT 108
95086: PUSH
95087: LD_INT 109
95089: PUSH
95090: LD_INT 110
95092: PUSH
95093: LD_INT 111
95095: PUSH
95096: LD_INT 112
95098: PUSH
95099: LD_INT 113
95101: PUSH
95102: LD_INT 114
95104: PUSH
95105: LD_INT 116
95107: PUSH
95108: LD_INT 117
95110: PUSH
95111: LD_INT 118
95113: PUSH
95114: EMPTY
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: LIST
95129: LIST
95130: LIST
95131: LIST
95132: PUSH
95133: EMPTY
95134: LIST
95135: LIST
95136: ST_TO_ADDR
95137: GO 96376
95139: LD_INT 14
95141: DOUBLE
95142: EQUAL
95143: IFTRUE 95147
95145: GO 95371
95147: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95148: LD_ADDR_VAR 0 2
95152: PUSH
95153: LD_INT 1
95155: PUSH
95156: LD_INT 2
95158: PUSH
95159: LD_INT 3
95161: PUSH
95162: LD_INT 4
95164: PUSH
95165: LD_INT 5
95167: PUSH
95168: LD_INT 6
95170: PUSH
95171: LD_INT 7
95173: PUSH
95174: LD_INT 8
95176: PUSH
95177: LD_INT 9
95179: PUSH
95180: LD_INT 10
95182: PUSH
95183: LD_INT 11
95185: PUSH
95186: LD_INT 12
95188: PUSH
95189: LD_INT 13
95191: PUSH
95192: LD_INT 14
95194: PUSH
95195: LD_INT 15
95197: PUSH
95198: LD_INT 16
95200: PUSH
95201: LD_INT 17
95203: PUSH
95204: LD_INT 18
95206: PUSH
95207: LD_INT 19
95209: PUSH
95210: LD_INT 20
95212: PUSH
95213: LD_INT 21
95215: PUSH
95216: LD_INT 22
95218: PUSH
95219: LD_INT 23
95221: PUSH
95222: LD_INT 24
95224: PUSH
95225: LD_INT 25
95227: PUSH
95228: LD_INT 26
95230: PUSH
95231: LD_INT 27
95233: PUSH
95234: LD_INT 28
95236: PUSH
95237: LD_INT 29
95239: PUSH
95240: LD_INT 30
95242: PUSH
95243: LD_INT 31
95245: PUSH
95246: LD_INT 32
95248: PUSH
95249: LD_INT 33
95251: PUSH
95252: LD_INT 34
95254: PUSH
95255: LD_INT 36
95257: PUSH
95258: EMPTY
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: LIST
95284: LIST
95285: LIST
95286: LIST
95287: LIST
95288: LIST
95289: LIST
95290: LIST
95291: LIST
95292: LIST
95293: LIST
95294: PUSH
95295: LD_INT 101
95297: PUSH
95298: LD_INT 102
95300: PUSH
95301: LD_INT 103
95303: PUSH
95304: LD_INT 104
95306: PUSH
95307: LD_INT 105
95309: PUSH
95310: LD_INT 106
95312: PUSH
95313: LD_INT 107
95315: PUSH
95316: LD_INT 108
95318: PUSH
95319: LD_INT 109
95321: PUSH
95322: LD_INT 110
95324: PUSH
95325: LD_INT 111
95327: PUSH
95328: LD_INT 112
95330: PUSH
95331: LD_INT 113
95333: PUSH
95334: LD_INT 114
95336: PUSH
95337: LD_INT 116
95339: PUSH
95340: LD_INT 117
95342: PUSH
95343: LD_INT 118
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: LIST
95353: LIST
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: ST_TO_ADDR
95369: GO 96376
95371: LD_INT 15
95373: DOUBLE
95374: EQUAL
95375: IFTRUE 95379
95377: GO 95603
95379: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
95380: LD_ADDR_VAR 0 2
95384: PUSH
95385: LD_INT 1
95387: PUSH
95388: LD_INT 2
95390: PUSH
95391: LD_INT 3
95393: PUSH
95394: LD_INT 4
95396: PUSH
95397: LD_INT 5
95399: PUSH
95400: LD_INT 6
95402: PUSH
95403: LD_INT 7
95405: PUSH
95406: LD_INT 8
95408: PUSH
95409: LD_INT 9
95411: PUSH
95412: LD_INT 10
95414: PUSH
95415: LD_INT 11
95417: PUSH
95418: LD_INT 12
95420: PUSH
95421: LD_INT 13
95423: PUSH
95424: LD_INT 14
95426: PUSH
95427: LD_INT 15
95429: PUSH
95430: LD_INT 16
95432: PUSH
95433: LD_INT 17
95435: PUSH
95436: LD_INT 18
95438: PUSH
95439: LD_INT 19
95441: PUSH
95442: LD_INT 20
95444: PUSH
95445: LD_INT 21
95447: PUSH
95448: LD_INT 22
95450: PUSH
95451: LD_INT 23
95453: PUSH
95454: LD_INT 24
95456: PUSH
95457: LD_INT 25
95459: PUSH
95460: LD_INT 26
95462: PUSH
95463: LD_INT 27
95465: PUSH
95466: LD_INT 28
95468: PUSH
95469: LD_INT 29
95471: PUSH
95472: LD_INT 30
95474: PUSH
95475: LD_INT 31
95477: PUSH
95478: LD_INT 32
95480: PUSH
95481: LD_INT 33
95483: PUSH
95484: LD_INT 34
95486: PUSH
95487: LD_INT 36
95489: PUSH
95490: EMPTY
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: PUSH
95527: LD_INT 101
95529: PUSH
95530: LD_INT 102
95532: PUSH
95533: LD_INT 103
95535: PUSH
95536: LD_INT 104
95538: PUSH
95539: LD_INT 105
95541: PUSH
95542: LD_INT 106
95544: PUSH
95545: LD_INT 107
95547: PUSH
95548: LD_INT 108
95550: PUSH
95551: LD_INT 109
95553: PUSH
95554: LD_INT 110
95556: PUSH
95557: LD_INT 111
95559: PUSH
95560: LD_INT 112
95562: PUSH
95563: LD_INT 113
95565: PUSH
95566: LD_INT 114
95568: PUSH
95569: LD_INT 116
95571: PUSH
95572: LD_INT 117
95574: PUSH
95575: LD_INT 118
95577: PUSH
95578: EMPTY
95579: LIST
95580: LIST
95581: LIST
95582: LIST
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: PUSH
95597: EMPTY
95598: LIST
95599: LIST
95600: ST_TO_ADDR
95601: GO 96376
95603: LD_INT 16
95605: DOUBLE
95606: EQUAL
95607: IFTRUE 95611
95609: GO 95747
95611: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
95612: LD_ADDR_VAR 0 2
95616: PUSH
95617: LD_INT 2
95619: PUSH
95620: LD_INT 4
95622: PUSH
95623: LD_INT 5
95625: PUSH
95626: LD_INT 7
95628: PUSH
95629: LD_INT 11
95631: PUSH
95632: LD_INT 12
95634: PUSH
95635: LD_INT 15
95637: PUSH
95638: LD_INT 16
95640: PUSH
95641: LD_INT 20
95643: PUSH
95644: LD_INT 21
95646: PUSH
95647: LD_INT 22
95649: PUSH
95650: LD_INT 23
95652: PUSH
95653: LD_INT 25
95655: PUSH
95656: LD_INT 26
95658: PUSH
95659: LD_INT 30
95661: PUSH
95662: LD_INT 31
95664: PUSH
95665: LD_INT 32
95667: PUSH
95668: LD_INT 33
95670: PUSH
95671: LD_INT 34
95673: PUSH
95674: EMPTY
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: PUSH
95695: LD_INT 101
95697: PUSH
95698: LD_INT 102
95700: PUSH
95701: LD_INT 103
95703: PUSH
95704: LD_INT 106
95706: PUSH
95707: LD_INT 108
95709: PUSH
95710: LD_INT 112
95712: PUSH
95713: LD_INT 113
95715: PUSH
95716: LD_INT 114
95718: PUSH
95719: LD_INT 116
95721: PUSH
95722: LD_INT 117
95724: PUSH
95725: LD_INT 118
95727: PUSH
95728: EMPTY
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: PUSH
95741: EMPTY
95742: LIST
95743: LIST
95744: ST_TO_ADDR
95745: GO 96376
95747: LD_INT 17
95749: DOUBLE
95750: EQUAL
95751: IFTRUE 95755
95753: GO 95979
95755: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
95756: LD_ADDR_VAR 0 2
95760: PUSH
95761: LD_INT 1
95763: PUSH
95764: LD_INT 2
95766: PUSH
95767: LD_INT 3
95769: PUSH
95770: LD_INT 4
95772: PUSH
95773: LD_INT 5
95775: PUSH
95776: LD_INT 6
95778: PUSH
95779: LD_INT 7
95781: PUSH
95782: LD_INT 8
95784: PUSH
95785: LD_INT 9
95787: PUSH
95788: LD_INT 10
95790: PUSH
95791: LD_INT 11
95793: PUSH
95794: LD_INT 12
95796: PUSH
95797: LD_INT 13
95799: PUSH
95800: LD_INT 14
95802: PUSH
95803: LD_INT 15
95805: PUSH
95806: LD_INT 16
95808: PUSH
95809: LD_INT 17
95811: PUSH
95812: LD_INT 18
95814: PUSH
95815: LD_INT 19
95817: PUSH
95818: LD_INT 20
95820: PUSH
95821: LD_INT 21
95823: PUSH
95824: LD_INT 22
95826: PUSH
95827: LD_INT 23
95829: PUSH
95830: LD_INT 24
95832: PUSH
95833: LD_INT 25
95835: PUSH
95836: LD_INT 26
95838: PUSH
95839: LD_INT 27
95841: PUSH
95842: LD_INT 28
95844: PUSH
95845: LD_INT 29
95847: PUSH
95848: LD_INT 30
95850: PUSH
95851: LD_INT 31
95853: PUSH
95854: LD_INT 32
95856: PUSH
95857: LD_INT 33
95859: PUSH
95860: LD_INT 34
95862: PUSH
95863: LD_INT 36
95865: PUSH
95866: EMPTY
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: PUSH
95903: LD_INT 101
95905: PUSH
95906: LD_INT 102
95908: PUSH
95909: LD_INT 103
95911: PUSH
95912: LD_INT 104
95914: PUSH
95915: LD_INT 105
95917: PUSH
95918: LD_INT 106
95920: PUSH
95921: LD_INT 107
95923: PUSH
95924: LD_INT 108
95926: PUSH
95927: LD_INT 109
95929: PUSH
95930: LD_INT 110
95932: PUSH
95933: LD_INT 111
95935: PUSH
95936: LD_INT 112
95938: PUSH
95939: LD_INT 113
95941: PUSH
95942: LD_INT 114
95944: PUSH
95945: LD_INT 116
95947: PUSH
95948: LD_INT 117
95950: PUSH
95951: LD_INT 118
95953: PUSH
95954: EMPTY
95955: LIST
95956: LIST
95957: LIST
95958: LIST
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: PUSH
95973: EMPTY
95974: LIST
95975: LIST
95976: ST_TO_ADDR
95977: GO 96376
95979: LD_INT 18
95981: DOUBLE
95982: EQUAL
95983: IFTRUE 95987
95985: GO 96135
95987: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
95988: LD_ADDR_VAR 0 2
95992: PUSH
95993: LD_INT 2
95995: PUSH
95996: LD_INT 4
95998: PUSH
95999: LD_INT 5
96001: PUSH
96002: LD_INT 7
96004: PUSH
96005: LD_INT 11
96007: PUSH
96008: LD_INT 12
96010: PUSH
96011: LD_INT 15
96013: PUSH
96014: LD_INT 16
96016: PUSH
96017: LD_INT 20
96019: PUSH
96020: LD_INT 21
96022: PUSH
96023: LD_INT 22
96025: PUSH
96026: LD_INT 23
96028: PUSH
96029: LD_INT 25
96031: PUSH
96032: LD_INT 26
96034: PUSH
96035: LD_INT 30
96037: PUSH
96038: LD_INT 31
96040: PUSH
96041: LD_INT 32
96043: PUSH
96044: LD_INT 33
96046: PUSH
96047: LD_INT 34
96049: PUSH
96050: LD_INT 35
96052: PUSH
96053: LD_INT 36
96055: PUSH
96056: EMPTY
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: PUSH
96079: LD_INT 101
96081: PUSH
96082: LD_INT 102
96084: PUSH
96085: LD_INT 103
96087: PUSH
96088: LD_INT 106
96090: PUSH
96091: LD_INT 108
96093: PUSH
96094: LD_INT 112
96096: PUSH
96097: LD_INT 113
96099: PUSH
96100: LD_INT 114
96102: PUSH
96103: LD_INT 115
96105: PUSH
96106: LD_INT 116
96108: PUSH
96109: LD_INT 117
96111: PUSH
96112: LD_INT 118
96114: PUSH
96115: EMPTY
96116: LIST
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: PUSH
96129: EMPTY
96130: LIST
96131: LIST
96132: ST_TO_ADDR
96133: GO 96376
96135: LD_INT 19
96137: DOUBLE
96138: EQUAL
96139: IFTRUE 96143
96141: GO 96375
96143: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96144: LD_ADDR_VAR 0 2
96148: PUSH
96149: LD_INT 1
96151: PUSH
96152: LD_INT 2
96154: PUSH
96155: LD_INT 3
96157: PUSH
96158: LD_INT 4
96160: PUSH
96161: LD_INT 5
96163: PUSH
96164: LD_INT 6
96166: PUSH
96167: LD_INT 7
96169: PUSH
96170: LD_INT 8
96172: PUSH
96173: LD_INT 9
96175: PUSH
96176: LD_INT 10
96178: PUSH
96179: LD_INT 11
96181: PUSH
96182: LD_INT 12
96184: PUSH
96185: LD_INT 13
96187: PUSH
96188: LD_INT 14
96190: PUSH
96191: LD_INT 15
96193: PUSH
96194: LD_INT 16
96196: PUSH
96197: LD_INT 17
96199: PUSH
96200: LD_INT 18
96202: PUSH
96203: LD_INT 19
96205: PUSH
96206: LD_INT 20
96208: PUSH
96209: LD_INT 21
96211: PUSH
96212: LD_INT 22
96214: PUSH
96215: LD_INT 23
96217: PUSH
96218: LD_INT 24
96220: PUSH
96221: LD_INT 25
96223: PUSH
96224: LD_INT 26
96226: PUSH
96227: LD_INT 27
96229: PUSH
96230: LD_INT 28
96232: PUSH
96233: LD_INT 29
96235: PUSH
96236: LD_INT 30
96238: PUSH
96239: LD_INT 31
96241: PUSH
96242: LD_INT 32
96244: PUSH
96245: LD_INT 33
96247: PUSH
96248: LD_INT 34
96250: PUSH
96251: LD_INT 35
96253: PUSH
96254: LD_INT 36
96256: PUSH
96257: EMPTY
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: PUSH
96295: LD_INT 101
96297: PUSH
96298: LD_INT 102
96300: PUSH
96301: LD_INT 103
96303: PUSH
96304: LD_INT 104
96306: PUSH
96307: LD_INT 105
96309: PUSH
96310: LD_INT 106
96312: PUSH
96313: LD_INT 107
96315: PUSH
96316: LD_INT 108
96318: PUSH
96319: LD_INT 109
96321: PUSH
96322: LD_INT 110
96324: PUSH
96325: LD_INT 111
96327: PUSH
96328: LD_INT 112
96330: PUSH
96331: LD_INT 113
96333: PUSH
96334: LD_INT 114
96336: PUSH
96337: LD_INT 115
96339: PUSH
96340: LD_INT 116
96342: PUSH
96343: LD_INT 117
96345: PUSH
96346: LD_INT 118
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: LIST
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: ST_TO_ADDR
96373: GO 96376
96375: POP
// end else
96376: GO 96607
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96378: LD_ADDR_VAR 0 2
96382: PUSH
96383: LD_INT 1
96385: PUSH
96386: LD_INT 2
96388: PUSH
96389: LD_INT 3
96391: PUSH
96392: LD_INT 4
96394: PUSH
96395: LD_INT 5
96397: PUSH
96398: LD_INT 6
96400: PUSH
96401: LD_INT 7
96403: PUSH
96404: LD_INT 8
96406: PUSH
96407: LD_INT 9
96409: PUSH
96410: LD_INT 10
96412: PUSH
96413: LD_INT 11
96415: PUSH
96416: LD_INT 12
96418: PUSH
96419: LD_INT 13
96421: PUSH
96422: LD_INT 14
96424: PUSH
96425: LD_INT 15
96427: PUSH
96428: LD_INT 16
96430: PUSH
96431: LD_INT 17
96433: PUSH
96434: LD_INT 18
96436: PUSH
96437: LD_INT 19
96439: PUSH
96440: LD_INT 20
96442: PUSH
96443: LD_INT 21
96445: PUSH
96446: LD_INT 22
96448: PUSH
96449: LD_INT 23
96451: PUSH
96452: LD_INT 24
96454: PUSH
96455: LD_INT 25
96457: PUSH
96458: LD_INT 26
96460: PUSH
96461: LD_INT 27
96463: PUSH
96464: LD_INT 28
96466: PUSH
96467: LD_INT 29
96469: PUSH
96470: LD_INT 30
96472: PUSH
96473: LD_INT 31
96475: PUSH
96476: LD_INT 32
96478: PUSH
96479: LD_INT 33
96481: PUSH
96482: LD_INT 34
96484: PUSH
96485: LD_INT 35
96487: PUSH
96488: LD_INT 36
96490: PUSH
96491: EMPTY
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: LIST
96528: PUSH
96529: LD_INT 101
96531: PUSH
96532: LD_INT 102
96534: PUSH
96535: LD_INT 103
96537: PUSH
96538: LD_INT 104
96540: PUSH
96541: LD_INT 105
96543: PUSH
96544: LD_INT 106
96546: PUSH
96547: LD_INT 107
96549: PUSH
96550: LD_INT 108
96552: PUSH
96553: LD_INT 109
96555: PUSH
96556: LD_INT 110
96558: PUSH
96559: LD_INT 111
96561: PUSH
96562: LD_INT 112
96564: PUSH
96565: LD_INT 113
96567: PUSH
96568: LD_INT 114
96570: PUSH
96571: LD_INT 115
96573: PUSH
96574: LD_INT 116
96576: PUSH
96577: LD_INT 117
96579: PUSH
96580: LD_INT 118
96582: PUSH
96583: EMPTY
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: PUSH
96603: EMPTY
96604: LIST
96605: LIST
96606: ST_TO_ADDR
// if result then
96607: LD_VAR 0 2
96611: IFFALSE 97397
// begin normal :=  ;
96613: LD_ADDR_VAR 0 5
96617: PUSH
96618: LD_STRING 
96620: ST_TO_ADDR
// hardcore :=  ;
96621: LD_ADDR_VAR 0 6
96625: PUSH
96626: LD_STRING 
96628: ST_TO_ADDR
// active :=  ;
96629: LD_ADDR_VAR 0 7
96633: PUSH
96634: LD_STRING 
96636: ST_TO_ADDR
// for i = 1 to normalCounter do
96637: LD_ADDR_VAR 0 8
96641: PUSH
96642: DOUBLE
96643: LD_INT 1
96645: DEC
96646: ST_TO_ADDR
96647: LD_EXP 97
96651: PUSH
96652: FOR_TO
96653: IFFALSE 96754
// begin tmp := 0 ;
96655: LD_ADDR_VAR 0 3
96659: PUSH
96660: LD_STRING 0
96662: ST_TO_ADDR
// if result [ 1 ] then
96663: LD_VAR 0 2
96667: PUSH
96668: LD_INT 1
96670: ARRAY
96671: IFFALSE 96736
// if result [ 1 ] [ 1 ] = i then
96673: LD_VAR 0 2
96677: PUSH
96678: LD_INT 1
96680: ARRAY
96681: PUSH
96682: LD_INT 1
96684: ARRAY
96685: PUSH
96686: LD_VAR 0 8
96690: EQUAL
96691: IFFALSE 96736
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
96693: LD_ADDR_VAR 0 2
96697: PUSH
96698: LD_VAR 0 2
96702: PPUSH
96703: LD_INT 1
96705: PPUSH
96706: LD_VAR 0 2
96710: PUSH
96711: LD_INT 1
96713: ARRAY
96714: PPUSH
96715: LD_INT 1
96717: PPUSH
96718: CALL_OW 3
96722: PPUSH
96723: CALL_OW 1
96727: ST_TO_ADDR
// tmp := 1 ;
96728: LD_ADDR_VAR 0 3
96732: PUSH
96733: LD_STRING 1
96735: ST_TO_ADDR
// end ; normal := normal & tmp ;
96736: LD_ADDR_VAR 0 5
96740: PUSH
96741: LD_VAR 0 5
96745: PUSH
96746: LD_VAR 0 3
96750: STR
96751: ST_TO_ADDR
// end ;
96752: GO 96652
96754: POP
96755: POP
// for i = 1 to hardcoreCounter do
96756: LD_ADDR_VAR 0 8
96760: PUSH
96761: DOUBLE
96762: LD_INT 1
96764: DEC
96765: ST_TO_ADDR
96766: LD_EXP 98
96770: PUSH
96771: FOR_TO
96772: IFFALSE 96877
// begin tmp := 0 ;
96774: LD_ADDR_VAR 0 3
96778: PUSH
96779: LD_STRING 0
96781: ST_TO_ADDR
// if result [ 2 ] then
96782: LD_VAR 0 2
96786: PUSH
96787: LD_INT 2
96789: ARRAY
96790: IFFALSE 96859
// if result [ 2 ] [ 1 ] = 100 + i then
96792: LD_VAR 0 2
96796: PUSH
96797: LD_INT 2
96799: ARRAY
96800: PUSH
96801: LD_INT 1
96803: ARRAY
96804: PUSH
96805: LD_INT 100
96807: PUSH
96808: LD_VAR 0 8
96812: PLUS
96813: EQUAL
96814: IFFALSE 96859
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96816: LD_ADDR_VAR 0 2
96820: PUSH
96821: LD_VAR 0 2
96825: PPUSH
96826: LD_INT 2
96828: PPUSH
96829: LD_VAR 0 2
96833: PUSH
96834: LD_INT 2
96836: ARRAY
96837: PPUSH
96838: LD_INT 1
96840: PPUSH
96841: CALL_OW 3
96845: PPUSH
96846: CALL_OW 1
96850: ST_TO_ADDR
// tmp := 1 ;
96851: LD_ADDR_VAR 0 3
96855: PUSH
96856: LD_STRING 1
96858: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96859: LD_ADDR_VAR 0 6
96863: PUSH
96864: LD_VAR 0 6
96868: PUSH
96869: LD_VAR 0 3
96873: STR
96874: ST_TO_ADDR
// end ;
96875: GO 96771
96877: POP
96878: POP
// if isGameLoad then
96879: LD_VAR 0 1
96883: IFFALSE 97358
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
96885: LD_ADDR_VAR 0 4
96889: PUSH
96890: LD_EXP 101
96894: PUSH
96895: LD_EXP 100
96899: PUSH
96900: LD_EXP 102
96904: PUSH
96905: LD_EXP 99
96909: PUSH
96910: LD_EXP 103
96914: PUSH
96915: LD_EXP 104
96919: PUSH
96920: LD_EXP 105
96924: PUSH
96925: LD_EXP 106
96929: PUSH
96930: LD_EXP 107
96934: PUSH
96935: LD_EXP 108
96939: PUSH
96940: LD_EXP 109
96944: PUSH
96945: LD_EXP 110
96949: PUSH
96950: LD_EXP 111
96954: PUSH
96955: LD_EXP 112
96959: PUSH
96960: LD_EXP 120
96964: PUSH
96965: LD_EXP 121
96969: PUSH
96970: LD_EXP 122
96974: PUSH
96975: LD_EXP 123
96979: PUSH
96980: LD_EXP 125
96984: PUSH
96985: LD_EXP 126
96989: PUSH
96990: LD_EXP 127
96994: PUSH
96995: LD_EXP 130
96999: PUSH
97000: LD_EXP 132
97004: PUSH
97005: LD_EXP 133
97009: PUSH
97010: LD_EXP 134
97014: PUSH
97015: LD_EXP 136
97019: PUSH
97020: LD_EXP 137
97024: PUSH
97025: LD_EXP 140
97029: PUSH
97030: LD_EXP 141
97034: PUSH
97035: LD_EXP 142
97039: PUSH
97040: LD_EXP 143
97044: PUSH
97045: LD_EXP 144
97049: PUSH
97050: LD_EXP 145
97054: PUSH
97055: LD_EXP 146
97059: PUSH
97060: LD_EXP 147
97064: PUSH
97065: LD_EXP 148
97069: PUSH
97070: LD_EXP 113
97074: PUSH
97075: LD_EXP 114
97079: PUSH
97080: LD_EXP 117
97084: PUSH
97085: LD_EXP 118
97089: PUSH
97090: LD_EXP 119
97094: PUSH
97095: LD_EXP 115
97099: PUSH
97100: LD_EXP 116
97104: PUSH
97105: LD_EXP 124
97109: PUSH
97110: LD_EXP 128
97114: PUSH
97115: LD_EXP 129
97119: PUSH
97120: LD_EXP 131
97124: PUSH
97125: LD_EXP 135
97129: PUSH
97130: LD_EXP 138
97134: PUSH
97135: LD_EXP 139
97139: PUSH
97140: LD_EXP 149
97144: PUSH
97145: LD_EXP 150
97149: PUSH
97150: LD_EXP 151
97154: PUSH
97155: LD_EXP 152
97159: PUSH
97160: EMPTY
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: LIST
97174: LIST
97175: LIST
97176: LIST
97177: LIST
97178: LIST
97179: LIST
97180: LIST
97181: LIST
97182: LIST
97183: LIST
97184: LIST
97185: LIST
97186: LIST
97187: LIST
97188: LIST
97189: LIST
97190: LIST
97191: LIST
97192: LIST
97193: LIST
97194: LIST
97195: LIST
97196: LIST
97197: LIST
97198: LIST
97199: LIST
97200: LIST
97201: LIST
97202: LIST
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: ST_TO_ADDR
// tmp :=  ;
97216: LD_ADDR_VAR 0 3
97220: PUSH
97221: LD_STRING 
97223: ST_TO_ADDR
// for i = 1 to normalCounter do
97224: LD_ADDR_VAR 0 8
97228: PUSH
97229: DOUBLE
97230: LD_INT 1
97232: DEC
97233: ST_TO_ADDR
97234: LD_EXP 97
97238: PUSH
97239: FOR_TO
97240: IFFALSE 97276
// begin if flags [ i ] then
97242: LD_VAR 0 4
97246: PUSH
97247: LD_VAR 0 8
97251: ARRAY
97252: IFFALSE 97274
// tmp := tmp & i & ; ;
97254: LD_ADDR_VAR 0 3
97258: PUSH
97259: LD_VAR 0 3
97263: PUSH
97264: LD_VAR 0 8
97268: STR
97269: PUSH
97270: LD_STRING ;
97272: STR
97273: ST_TO_ADDR
// end ;
97274: GO 97239
97276: POP
97277: POP
// for i = 1 to hardcoreCounter do
97278: LD_ADDR_VAR 0 8
97282: PUSH
97283: DOUBLE
97284: LD_INT 1
97286: DEC
97287: ST_TO_ADDR
97288: LD_EXP 98
97292: PUSH
97293: FOR_TO
97294: IFFALSE 97340
// begin if flags [ normalCounter + i ] then
97296: LD_VAR 0 4
97300: PUSH
97301: LD_EXP 97
97305: PUSH
97306: LD_VAR 0 8
97310: PLUS
97311: ARRAY
97312: IFFALSE 97338
// tmp := tmp & ( 100 + i ) & ; ;
97314: LD_ADDR_VAR 0 3
97318: PUSH
97319: LD_VAR 0 3
97323: PUSH
97324: LD_INT 100
97326: PUSH
97327: LD_VAR 0 8
97331: PLUS
97332: STR
97333: PUSH
97334: LD_STRING ;
97336: STR
97337: ST_TO_ADDR
// end ;
97338: GO 97293
97340: POP
97341: POP
// if tmp then
97342: LD_VAR 0 3
97346: IFFALSE 97358
// active := tmp ;
97348: LD_ADDR_VAR 0 7
97352: PUSH
97353: LD_VAR 0 3
97357: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97358: LD_STRING getStreamItemsFromMission("
97360: PUSH
97361: LD_VAR 0 5
97365: STR
97366: PUSH
97367: LD_STRING ","
97369: STR
97370: PUSH
97371: LD_VAR 0 6
97375: STR
97376: PUSH
97377: LD_STRING ","
97379: STR
97380: PUSH
97381: LD_VAR 0 7
97385: STR
97386: PUSH
97387: LD_STRING ")
97389: STR
97390: PPUSH
97391: CALL_OW 559
// end else
97395: GO 97404
// ToLua ( getStreamItemsFromMission("","","") ) ;
97397: LD_STRING getStreamItemsFromMission("","","")
97399: PPUSH
97400: CALL_OW 559
// end ;
97404: LD_VAR 0 2
97408: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
97409: LD_EXP 96
97413: PUSH
97414: LD_EXP 101
97418: AND
97419: IFFALSE 97543
97421: GO 97423
97423: DISABLE
97424: LD_INT 0
97426: PPUSH
97427: PPUSH
// begin enable ;
97428: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
97429: LD_ADDR_VAR 0 2
97433: PUSH
97434: LD_INT 22
97436: PUSH
97437: LD_OWVAR 2
97441: PUSH
97442: EMPTY
97443: LIST
97444: LIST
97445: PUSH
97446: LD_INT 2
97448: PUSH
97449: LD_INT 34
97451: PUSH
97452: LD_INT 7
97454: PUSH
97455: EMPTY
97456: LIST
97457: LIST
97458: PUSH
97459: LD_INT 34
97461: PUSH
97462: LD_INT 45
97464: PUSH
97465: EMPTY
97466: LIST
97467: LIST
97468: PUSH
97469: LD_INT 34
97471: PUSH
97472: LD_INT 28
97474: PUSH
97475: EMPTY
97476: LIST
97477: LIST
97478: PUSH
97479: LD_INT 34
97481: PUSH
97482: LD_INT 47
97484: PUSH
97485: EMPTY
97486: LIST
97487: LIST
97488: PUSH
97489: EMPTY
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: PPUSH
97500: CALL_OW 69
97504: ST_TO_ADDR
// if not tmp then
97505: LD_VAR 0 2
97509: NOT
97510: IFFALSE 97514
// exit ;
97512: GO 97543
// for i in tmp do
97514: LD_ADDR_VAR 0 1
97518: PUSH
97519: LD_VAR 0 2
97523: PUSH
97524: FOR_IN
97525: IFFALSE 97541
// begin SetLives ( i , 0 ) ;
97527: LD_VAR 0 1
97531: PPUSH
97532: LD_INT 0
97534: PPUSH
97535: CALL_OW 234
// end ;
97539: GO 97524
97541: POP
97542: POP
// end ;
97543: PPOPN 2
97545: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
97546: LD_EXP 96
97550: PUSH
97551: LD_EXP 102
97555: AND
97556: IFFALSE 97640
97558: GO 97560
97560: DISABLE
97561: LD_INT 0
97563: PPUSH
97564: PPUSH
// begin enable ;
97565: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
97566: LD_ADDR_VAR 0 2
97570: PUSH
97571: LD_INT 22
97573: PUSH
97574: LD_OWVAR 2
97578: PUSH
97579: EMPTY
97580: LIST
97581: LIST
97582: PUSH
97583: LD_INT 32
97585: PUSH
97586: LD_INT 3
97588: PUSH
97589: EMPTY
97590: LIST
97591: LIST
97592: PUSH
97593: EMPTY
97594: LIST
97595: LIST
97596: PPUSH
97597: CALL_OW 69
97601: ST_TO_ADDR
// if not tmp then
97602: LD_VAR 0 2
97606: NOT
97607: IFFALSE 97611
// exit ;
97609: GO 97640
// for i in tmp do
97611: LD_ADDR_VAR 0 1
97615: PUSH
97616: LD_VAR 0 2
97620: PUSH
97621: FOR_IN
97622: IFFALSE 97638
// begin SetLives ( i , 0 ) ;
97624: LD_VAR 0 1
97628: PPUSH
97629: LD_INT 0
97631: PPUSH
97632: CALL_OW 234
// end ;
97636: GO 97621
97638: POP
97639: POP
// end ;
97640: PPOPN 2
97642: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
97643: LD_EXP 96
97647: PUSH
97648: LD_EXP 99
97652: AND
97653: IFFALSE 97746
97655: GO 97657
97657: DISABLE
97658: LD_INT 0
97660: PPUSH
// begin enable ;
97661: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
97662: LD_ADDR_VAR 0 1
97666: PUSH
97667: LD_INT 22
97669: PUSH
97670: LD_OWVAR 2
97674: PUSH
97675: EMPTY
97676: LIST
97677: LIST
97678: PUSH
97679: LD_INT 2
97681: PUSH
97682: LD_INT 25
97684: PUSH
97685: LD_INT 5
97687: PUSH
97688: EMPTY
97689: LIST
97690: LIST
97691: PUSH
97692: LD_INT 25
97694: PUSH
97695: LD_INT 9
97697: PUSH
97698: EMPTY
97699: LIST
97700: LIST
97701: PUSH
97702: LD_INT 25
97704: PUSH
97705: LD_INT 8
97707: PUSH
97708: EMPTY
97709: LIST
97710: LIST
97711: PUSH
97712: EMPTY
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: PUSH
97718: EMPTY
97719: LIST
97720: LIST
97721: PPUSH
97722: CALL_OW 69
97726: PUSH
97727: FOR_IN
97728: IFFALSE 97744
// begin SetClass ( i , 1 ) ;
97730: LD_VAR 0 1
97734: PPUSH
97735: LD_INT 1
97737: PPUSH
97738: CALL_OW 336
// end ;
97742: GO 97727
97744: POP
97745: POP
// end ;
97746: PPOPN 1
97748: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97749: LD_EXP 96
97753: PUSH
97754: LD_EXP 100
97758: AND
97759: PUSH
97760: LD_OWVAR 65
97764: PUSH
97765: LD_INT 7
97767: LESS
97768: AND
97769: IFFALSE 97783
97771: GO 97773
97773: DISABLE
// begin enable ;
97774: ENABLE
// game_speed := 7 ;
97775: LD_ADDR_OWVAR 65
97779: PUSH
97780: LD_INT 7
97782: ST_TO_ADDR
// end ;
97783: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97784: LD_EXP 96
97788: PUSH
97789: LD_EXP 103
97793: AND
97794: IFFALSE 97996
97796: GO 97798
97798: DISABLE
97799: LD_INT 0
97801: PPUSH
97802: PPUSH
97803: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97804: LD_ADDR_VAR 0 3
97808: PUSH
97809: LD_INT 81
97811: PUSH
97812: LD_OWVAR 2
97816: PUSH
97817: EMPTY
97818: LIST
97819: LIST
97820: PUSH
97821: LD_INT 21
97823: PUSH
97824: LD_INT 1
97826: PUSH
97827: EMPTY
97828: LIST
97829: LIST
97830: PUSH
97831: EMPTY
97832: LIST
97833: LIST
97834: PPUSH
97835: CALL_OW 69
97839: ST_TO_ADDR
// if not tmp then
97840: LD_VAR 0 3
97844: NOT
97845: IFFALSE 97849
// exit ;
97847: GO 97996
// if tmp > 5 then
97849: LD_VAR 0 3
97853: PUSH
97854: LD_INT 5
97856: GREATER
97857: IFFALSE 97869
// k := 5 else
97859: LD_ADDR_VAR 0 2
97863: PUSH
97864: LD_INT 5
97866: ST_TO_ADDR
97867: GO 97879
// k := tmp ;
97869: LD_ADDR_VAR 0 2
97873: PUSH
97874: LD_VAR 0 3
97878: ST_TO_ADDR
// for i := 1 to k do
97879: LD_ADDR_VAR 0 1
97883: PUSH
97884: DOUBLE
97885: LD_INT 1
97887: DEC
97888: ST_TO_ADDR
97889: LD_VAR 0 2
97893: PUSH
97894: FOR_TO
97895: IFFALSE 97994
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
97897: LD_VAR 0 3
97901: PUSH
97902: LD_VAR 0 1
97906: ARRAY
97907: PPUSH
97908: LD_VAR 0 1
97912: PUSH
97913: LD_INT 4
97915: MOD
97916: PUSH
97917: LD_INT 1
97919: PLUS
97920: PPUSH
97921: CALL_OW 259
97925: PUSH
97926: LD_INT 10
97928: LESS
97929: IFFALSE 97992
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97931: LD_VAR 0 3
97935: PUSH
97936: LD_VAR 0 1
97940: ARRAY
97941: PPUSH
97942: LD_VAR 0 1
97946: PUSH
97947: LD_INT 4
97949: MOD
97950: PUSH
97951: LD_INT 1
97953: PLUS
97954: PPUSH
97955: LD_VAR 0 3
97959: PUSH
97960: LD_VAR 0 1
97964: ARRAY
97965: PPUSH
97966: LD_VAR 0 1
97970: PUSH
97971: LD_INT 4
97973: MOD
97974: PUSH
97975: LD_INT 1
97977: PLUS
97978: PPUSH
97979: CALL_OW 259
97983: PUSH
97984: LD_INT 1
97986: PLUS
97987: PPUSH
97988: CALL_OW 237
97992: GO 97894
97994: POP
97995: POP
// end ;
97996: PPOPN 3
97998: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97999: LD_EXP 96
98003: PUSH
98004: LD_EXP 104
98008: AND
98009: IFFALSE 98029
98011: GO 98013
98013: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98014: LD_INT 4
98016: PPUSH
98017: LD_OWVAR 2
98021: PPUSH
98022: LD_INT 0
98024: PPUSH
98025: CALL_OW 324
98029: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98030: LD_EXP 96
98034: PUSH
98035: LD_EXP 133
98039: AND
98040: IFFALSE 98060
98042: GO 98044
98044: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98045: LD_INT 19
98047: PPUSH
98048: LD_OWVAR 2
98052: PPUSH
98053: LD_INT 0
98055: PPUSH
98056: CALL_OW 324
98060: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98061: LD_EXP 96
98065: PUSH
98066: LD_EXP 105
98070: AND
98071: IFFALSE 98173
98073: GO 98075
98075: DISABLE
98076: LD_INT 0
98078: PPUSH
98079: PPUSH
// begin enable ;
98080: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98081: LD_ADDR_VAR 0 2
98085: PUSH
98086: LD_INT 22
98088: PUSH
98089: LD_OWVAR 2
98093: PUSH
98094: EMPTY
98095: LIST
98096: LIST
98097: PUSH
98098: LD_INT 2
98100: PUSH
98101: LD_INT 34
98103: PUSH
98104: LD_INT 11
98106: PUSH
98107: EMPTY
98108: LIST
98109: LIST
98110: PUSH
98111: LD_INT 34
98113: PUSH
98114: LD_INT 30
98116: PUSH
98117: EMPTY
98118: LIST
98119: LIST
98120: PUSH
98121: EMPTY
98122: LIST
98123: LIST
98124: LIST
98125: PUSH
98126: EMPTY
98127: LIST
98128: LIST
98129: PPUSH
98130: CALL_OW 69
98134: ST_TO_ADDR
// if not tmp then
98135: LD_VAR 0 2
98139: NOT
98140: IFFALSE 98144
// exit ;
98142: GO 98173
// for i in tmp do
98144: LD_ADDR_VAR 0 1
98148: PUSH
98149: LD_VAR 0 2
98153: PUSH
98154: FOR_IN
98155: IFFALSE 98171
// begin SetLives ( i , 0 ) ;
98157: LD_VAR 0 1
98161: PPUSH
98162: LD_INT 0
98164: PPUSH
98165: CALL_OW 234
// end ;
98169: GO 98154
98171: POP
98172: POP
// end ;
98173: PPOPN 2
98175: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98176: LD_EXP 96
98180: PUSH
98181: LD_EXP 106
98185: AND
98186: IFFALSE 98206
98188: GO 98190
98190: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98191: LD_INT 32
98193: PPUSH
98194: LD_OWVAR 2
98198: PPUSH
98199: LD_INT 0
98201: PPUSH
98202: CALL_OW 324
98206: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98207: LD_EXP 96
98211: PUSH
98212: LD_EXP 107
98216: AND
98217: IFFALSE 98398
98219: GO 98221
98221: DISABLE
98222: LD_INT 0
98224: PPUSH
98225: PPUSH
98226: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98227: LD_ADDR_VAR 0 2
98231: PUSH
98232: LD_INT 22
98234: PUSH
98235: LD_OWVAR 2
98239: PUSH
98240: EMPTY
98241: LIST
98242: LIST
98243: PUSH
98244: LD_INT 33
98246: PUSH
98247: LD_INT 3
98249: PUSH
98250: EMPTY
98251: LIST
98252: LIST
98253: PUSH
98254: EMPTY
98255: LIST
98256: LIST
98257: PPUSH
98258: CALL_OW 69
98262: ST_TO_ADDR
// if not tmp then
98263: LD_VAR 0 2
98267: NOT
98268: IFFALSE 98272
// exit ;
98270: GO 98398
// side := 0 ;
98272: LD_ADDR_VAR 0 3
98276: PUSH
98277: LD_INT 0
98279: ST_TO_ADDR
// for i := 1 to 8 do
98280: LD_ADDR_VAR 0 1
98284: PUSH
98285: DOUBLE
98286: LD_INT 1
98288: DEC
98289: ST_TO_ADDR
98290: LD_INT 8
98292: PUSH
98293: FOR_TO
98294: IFFALSE 98342
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98296: LD_OWVAR 2
98300: PUSH
98301: LD_VAR 0 1
98305: NONEQUAL
98306: PUSH
98307: LD_OWVAR 2
98311: PPUSH
98312: LD_VAR 0 1
98316: PPUSH
98317: CALL_OW 81
98321: PUSH
98322: LD_INT 2
98324: EQUAL
98325: AND
98326: IFFALSE 98340
// begin side := i ;
98328: LD_ADDR_VAR 0 3
98332: PUSH
98333: LD_VAR 0 1
98337: ST_TO_ADDR
// break ;
98338: GO 98342
// end ;
98340: GO 98293
98342: POP
98343: POP
// if not side then
98344: LD_VAR 0 3
98348: NOT
98349: IFFALSE 98353
// exit ;
98351: GO 98398
// for i := 1 to tmp do
98353: LD_ADDR_VAR 0 1
98357: PUSH
98358: DOUBLE
98359: LD_INT 1
98361: DEC
98362: ST_TO_ADDR
98363: LD_VAR 0 2
98367: PUSH
98368: FOR_TO
98369: IFFALSE 98396
// if Prob ( 60 ) then
98371: LD_INT 60
98373: PPUSH
98374: CALL_OW 13
98378: IFFALSE 98394
// SetSide ( i , side ) ;
98380: LD_VAR 0 1
98384: PPUSH
98385: LD_VAR 0 3
98389: PPUSH
98390: CALL_OW 235
98394: GO 98368
98396: POP
98397: POP
// end ;
98398: PPOPN 3
98400: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
98401: LD_EXP 96
98405: PUSH
98406: LD_EXP 109
98410: AND
98411: IFFALSE 98530
98413: GO 98415
98415: DISABLE
98416: LD_INT 0
98418: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
98419: LD_ADDR_VAR 0 1
98423: PUSH
98424: LD_INT 22
98426: PUSH
98427: LD_OWVAR 2
98431: PUSH
98432: EMPTY
98433: LIST
98434: LIST
98435: PUSH
98436: LD_INT 21
98438: PUSH
98439: LD_INT 1
98441: PUSH
98442: EMPTY
98443: LIST
98444: LIST
98445: PUSH
98446: LD_INT 3
98448: PUSH
98449: LD_INT 23
98451: PUSH
98452: LD_INT 0
98454: PUSH
98455: EMPTY
98456: LIST
98457: LIST
98458: PUSH
98459: EMPTY
98460: LIST
98461: LIST
98462: PUSH
98463: EMPTY
98464: LIST
98465: LIST
98466: LIST
98467: PPUSH
98468: CALL_OW 69
98472: PUSH
98473: FOR_IN
98474: IFFALSE 98528
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
98476: LD_VAR 0 1
98480: PPUSH
98481: CALL_OW 257
98485: PUSH
98486: LD_INT 1
98488: PUSH
98489: LD_INT 2
98491: PUSH
98492: LD_INT 3
98494: PUSH
98495: LD_INT 4
98497: PUSH
98498: EMPTY
98499: LIST
98500: LIST
98501: LIST
98502: LIST
98503: IN
98504: IFFALSE 98526
// SetClass ( un , rand ( 1 , 4 ) ) ;
98506: LD_VAR 0 1
98510: PPUSH
98511: LD_INT 1
98513: PPUSH
98514: LD_INT 4
98516: PPUSH
98517: CALL_OW 12
98521: PPUSH
98522: CALL_OW 336
98526: GO 98473
98528: POP
98529: POP
// end ;
98530: PPOPN 1
98532: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
98533: LD_EXP 96
98537: PUSH
98538: LD_EXP 108
98542: AND
98543: IFFALSE 98622
98545: GO 98547
98547: DISABLE
98548: LD_INT 0
98550: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98551: LD_ADDR_VAR 0 1
98555: PUSH
98556: LD_INT 22
98558: PUSH
98559: LD_OWVAR 2
98563: PUSH
98564: EMPTY
98565: LIST
98566: LIST
98567: PUSH
98568: LD_INT 21
98570: PUSH
98571: LD_INT 3
98573: PUSH
98574: EMPTY
98575: LIST
98576: LIST
98577: PUSH
98578: EMPTY
98579: LIST
98580: LIST
98581: PPUSH
98582: CALL_OW 69
98586: ST_TO_ADDR
// if not tmp then
98587: LD_VAR 0 1
98591: NOT
98592: IFFALSE 98596
// exit ;
98594: GO 98622
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
98596: LD_VAR 0 1
98600: PUSH
98601: LD_INT 1
98603: PPUSH
98604: LD_VAR 0 1
98608: PPUSH
98609: CALL_OW 12
98613: ARRAY
98614: PPUSH
98615: LD_INT 100
98617: PPUSH
98618: CALL_OW 234
// end ;
98622: PPOPN 1
98624: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
98625: LD_EXP 96
98629: PUSH
98630: LD_EXP 110
98634: AND
98635: IFFALSE 98733
98637: GO 98639
98639: DISABLE
98640: LD_INT 0
98642: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98643: LD_ADDR_VAR 0 1
98647: PUSH
98648: LD_INT 22
98650: PUSH
98651: LD_OWVAR 2
98655: PUSH
98656: EMPTY
98657: LIST
98658: LIST
98659: PUSH
98660: LD_INT 21
98662: PUSH
98663: LD_INT 1
98665: PUSH
98666: EMPTY
98667: LIST
98668: LIST
98669: PUSH
98670: EMPTY
98671: LIST
98672: LIST
98673: PPUSH
98674: CALL_OW 69
98678: ST_TO_ADDR
// if not tmp then
98679: LD_VAR 0 1
98683: NOT
98684: IFFALSE 98688
// exit ;
98686: GO 98733
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
98688: LD_VAR 0 1
98692: PUSH
98693: LD_INT 1
98695: PPUSH
98696: LD_VAR 0 1
98700: PPUSH
98701: CALL_OW 12
98705: ARRAY
98706: PPUSH
98707: LD_INT 1
98709: PPUSH
98710: LD_INT 4
98712: PPUSH
98713: CALL_OW 12
98717: PPUSH
98718: LD_INT 3000
98720: PPUSH
98721: LD_INT 9000
98723: PPUSH
98724: CALL_OW 12
98728: PPUSH
98729: CALL_OW 492
// end ;
98733: PPOPN 1
98735: END
// every 0 0$1 trigger StreamModeActive and sDepot do
98736: LD_EXP 96
98740: PUSH
98741: LD_EXP 111
98745: AND
98746: IFFALSE 98766
98748: GO 98750
98750: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98751: LD_INT 1
98753: PPUSH
98754: LD_OWVAR 2
98758: PPUSH
98759: LD_INT 0
98761: PPUSH
98762: CALL_OW 324
98766: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98767: LD_EXP 96
98771: PUSH
98772: LD_EXP 112
98776: AND
98777: IFFALSE 98860
98779: GO 98781
98781: DISABLE
98782: LD_INT 0
98784: PPUSH
98785: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98786: LD_ADDR_VAR 0 2
98790: PUSH
98791: LD_INT 22
98793: PUSH
98794: LD_OWVAR 2
98798: PUSH
98799: EMPTY
98800: LIST
98801: LIST
98802: PUSH
98803: LD_INT 21
98805: PUSH
98806: LD_INT 3
98808: PUSH
98809: EMPTY
98810: LIST
98811: LIST
98812: PUSH
98813: EMPTY
98814: LIST
98815: LIST
98816: PPUSH
98817: CALL_OW 69
98821: ST_TO_ADDR
// if not tmp then
98822: LD_VAR 0 2
98826: NOT
98827: IFFALSE 98831
// exit ;
98829: GO 98860
// for i in tmp do
98831: LD_ADDR_VAR 0 1
98835: PUSH
98836: LD_VAR 0 2
98840: PUSH
98841: FOR_IN
98842: IFFALSE 98858
// SetBLevel ( i , 10 ) ;
98844: LD_VAR 0 1
98848: PPUSH
98849: LD_INT 10
98851: PPUSH
98852: CALL_OW 241
98856: GO 98841
98858: POP
98859: POP
// end ;
98860: PPOPN 2
98862: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
98863: LD_EXP 96
98867: PUSH
98868: LD_EXP 113
98872: AND
98873: IFFALSE 98984
98875: GO 98877
98877: DISABLE
98878: LD_INT 0
98880: PPUSH
98881: PPUSH
98882: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98883: LD_ADDR_VAR 0 3
98887: PUSH
98888: LD_INT 22
98890: PUSH
98891: LD_OWVAR 2
98895: PUSH
98896: EMPTY
98897: LIST
98898: LIST
98899: PUSH
98900: LD_INT 25
98902: PUSH
98903: LD_INT 1
98905: PUSH
98906: EMPTY
98907: LIST
98908: LIST
98909: PUSH
98910: EMPTY
98911: LIST
98912: LIST
98913: PPUSH
98914: CALL_OW 69
98918: ST_TO_ADDR
// if not tmp then
98919: LD_VAR 0 3
98923: NOT
98924: IFFALSE 98928
// exit ;
98926: GO 98984
// un := tmp [ rand ( 1 , tmp ) ] ;
98928: LD_ADDR_VAR 0 2
98932: PUSH
98933: LD_VAR 0 3
98937: PUSH
98938: LD_INT 1
98940: PPUSH
98941: LD_VAR 0 3
98945: PPUSH
98946: CALL_OW 12
98950: ARRAY
98951: ST_TO_ADDR
// if Crawls ( un ) then
98952: LD_VAR 0 2
98956: PPUSH
98957: CALL_OW 318
98961: IFFALSE 98972
// ComWalk ( un ) ;
98963: LD_VAR 0 2
98967: PPUSH
98968: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98972: LD_VAR 0 2
98976: PPUSH
98977: LD_INT 5
98979: PPUSH
98980: CALL_OW 336
// end ;
98984: PPOPN 3
98986: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
98987: LD_EXP 96
98991: PUSH
98992: LD_EXP 114
98996: AND
98997: PUSH
98998: LD_OWVAR 67
99002: PUSH
99003: LD_INT 4
99005: LESS
99006: AND
99007: IFFALSE 99026
99009: GO 99011
99011: DISABLE
// begin Difficulty := Difficulty + 1 ;
99012: LD_ADDR_OWVAR 67
99016: PUSH
99017: LD_OWVAR 67
99021: PUSH
99022: LD_INT 1
99024: PLUS
99025: ST_TO_ADDR
// end ;
99026: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99027: LD_EXP 96
99031: PUSH
99032: LD_EXP 115
99036: AND
99037: IFFALSE 99140
99039: GO 99041
99041: DISABLE
99042: LD_INT 0
99044: PPUSH
// begin for i := 1 to 5 do
99045: LD_ADDR_VAR 0 1
99049: PUSH
99050: DOUBLE
99051: LD_INT 1
99053: DEC
99054: ST_TO_ADDR
99055: LD_INT 5
99057: PUSH
99058: FOR_TO
99059: IFFALSE 99138
// begin uc_nation := nation_nature ;
99061: LD_ADDR_OWVAR 21
99065: PUSH
99066: LD_INT 0
99068: ST_TO_ADDR
// uc_side := 0 ;
99069: LD_ADDR_OWVAR 20
99073: PUSH
99074: LD_INT 0
99076: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99077: LD_ADDR_OWVAR 29
99081: PUSH
99082: LD_INT 12
99084: PUSH
99085: LD_INT 12
99087: PUSH
99088: EMPTY
99089: LIST
99090: LIST
99091: ST_TO_ADDR
// hc_agressivity := 20 ;
99092: LD_ADDR_OWVAR 35
99096: PUSH
99097: LD_INT 20
99099: ST_TO_ADDR
// hc_class := class_tiger ;
99100: LD_ADDR_OWVAR 28
99104: PUSH
99105: LD_INT 14
99107: ST_TO_ADDR
// hc_gallery :=  ;
99108: LD_ADDR_OWVAR 33
99112: PUSH
99113: LD_STRING 
99115: ST_TO_ADDR
// hc_name :=  ;
99116: LD_ADDR_OWVAR 26
99120: PUSH
99121: LD_STRING 
99123: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99124: CALL_OW 44
99128: PPUSH
99129: LD_INT 0
99131: PPUSH
99132: CALL_OW 51
// end ;
99136: GO 99058
99138: POP
99139: POP
// end ;
99140: PPOPN 1
99142: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99143: LD_EXP 96
99147: PUSH
99148: LD_EXP 116
99152: AND
99153: IFFALSE 99162
99155: GO 99157
99157: DISABLE
// StreamSibBomb ;
99158: CALL 99163 0 0
99162: END
// export function StreamSibBomb ; var i , x , y ; begin
99163: LD_INT 0
99165: PPUSH
99166: PPUSH
99167: PPUSH
99168: PPUSH
// result := false ;
99169: LD_ADDR_VAR 0 1
99173: PUSH
99174: LD_INT 0
99176: ST_TO_ADDR
// for i := 1 to 16 do
99177: LD_ADDR_VAR 0 2
99181: PUSH
99182: DOUBLE
99183: LD_INT 1
99185: DEC
99186: ST_TO_ADDR
99187: LD_INT 16
99189: PUSH
99190: FOR_TO
99191: IFFALSE 99390
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99193: LD_ADDR_VAR 0 3
99197: PUSH
99198: LD_INT 10
99200: PUSH
99201: LD_INT 20
99203: PUSH
99204: LD_INT 30
99206: PUSH
99207: LD_INT 40
99209: PUSH
99210: LD_INT 50
99212: PUSH
99213: LD_INT 60
99215: PUSH
99216: LD_INT 70
99218: PUSH
99219: LD_INT 80
99221: PUSH
99222: LD_INT 90
99224: PUSH
99225: LD_INT 100
99227: PUSH
99228: LD_INT 110
99230: PUSH
99231: LD_INT 120
99233: PUSH
99234: LD_INT 130
99236: PUSH
99237: LD_INT 140
99239: PUSH
99240: LD_INT 150
99242: PUSH
99243: EMPTY
99244: LIST
99245: LIST
99246: LIST
99247: LIST
99248: LIST
99249: LIST
99250: LIST
99251: LIST
99252: LIST
99253: LIST
99254: LIST
99255: LIST
99256: LIST
99257: LIST
99258: LIST
99259: PUSH
99260: LD_INT 1
99262: PPUSH
99263: LD_INT 15
99265: PPUSH
99266: CALL_OW 12
99270: ARRAY
99271: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99272: LD_ADDR_VAR 0 4
99276: PUSH
99277: LD_INT 10
99279: PUSH
99280: LD_INT 20
99282: PUSH
99283: LD_INT 30
99285: PUSH
99286: LD_INT 40
99288: PUSH
99289: LD_INT 50
99291: PUSH
99292: LD_INT 60
99294: PUSH
99295: LD_INT 70
99297: PUSH
99298: LD_INT 80
99300: PUSH
99301: LD_INT 90
99303: PUSH
99304: LD_INT 100
99306: PUSH
99307: LD_INT 110
99309: PUSH
99310: LD_INT 120
99312: PUSH
99313: LD_INT 130
99315: PUSH
99316: LD_INT 140
99318: PUSH
99319: LD_INT 150
99321: PUSH
99322: EMPTY
99323: LIST
99324: LIST
99325: LIST
99326: LIST
99327: LIST
99328: LIST
99329: LIST
99330: LIST
99331: LIST
99332: LIST
99333: LIST
99334: LIST
99335: LIST
99336: LIST
99337: LIST
99338: PUSH
99339: LD_INT 1
99341: PPUSH
99342: LD_INT 15
99344: PPUSH
99345: CALL_OW 12
99349: ARRAY
99350: ST_TO_ADDR
// if ValidHex ( x , y ) then
99351: LD_VAR 0 3
99355: PPUSH
99356: LD_VAR 0 4
99360: PPUSH
99361: CALL_OW 488
99365: IFFALSE 99388
// begin result := [ x , y ] ;
99367: LD_ADDR_VAR 0 1
99371: PUSH
99372: LD_VAR 0 3
99376: PUSH
99377: LD_VAR 0 4
99381: PUSH
99382: EMPTY
99383: LIST
99384: LIST
99385: ST_TO_ADDR
// break ;
99386: GO 99390
// end ; end ;
99388: GO 99190
99390: POP
99391: POP
// if result then
99392: LD_VAR 0 1
99396: IFFALSE 99456
// begin ToLua ( playSibBomb() ) ;
99398: LD_STRING playSibBomb()
99400: PPUSH
99401: CALL_OW 559
// wait ( 0 0$14 ) ;
99405: LD_INT 490
99407: PPUSH
99408: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
99412: LD_VAR 0 1
99416: PUSH
99417: LD_INT 1
99419: ARRAY
99420: PPUSH
99421: LD_VAR 0 1
99425: PUSH
99426: LD_INT 2
99428: ARRAY
99429: PPUSH
99430: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
99434: LD_VAR 0 1
99438: PUSH
99439: LD_INT 1
99441: ARRAY
99442: PPUSH
99443: LD_VAR 0 1
99447: PUSH
99448: LD_INT 2
99450: ARRAY
99451: PPUSH
99452: CALL_OW 429
// end ; end ;
99456: LD_VAR 0 1
99460: RET
// every 0 0$1 trigger StreamModeActive and sReset do
99461: LD_EXP 96
99465: PUSH
99466: LD_EXP 118
99470: AND
99471: IFFALSE 99483
99473: GO 99475
99475: DISABLE
// YouLost (  ) ;
99476: LD_STRING 
99478: PPUSH
99479: CALL_OW 104
99483: END
// every 0 0$1 trigger StreamModeActive and sFog do
99484: LD_EXP 96
99488: PUSH
99489: LD_EXP 117
99493: AND
99494: IFFALSE 99508
99496: GO 99498
99498: DISABLE
// FogOff ( your_side ) ;
99499: LD_OWVAR 2
99503: PPUSH
99504: CALL_OW 344
99508: END
// every 0 0$1 trigger StreamModeActive and sSun do
99509: LD_EXP 96
99513: PUSH
99514: LD_EXP 119
99518: AND
99519: IFFALSE 99547
99521: GO 99523
99523: DISABLE
// begin solar_recharge_percent := 0 ;
99524: LD_ADDR_OWVAR 79
99528: PUSH
99529: LD_INT 0
99531: ST_TO_ADDR
// wait ( 5 5$00 ) ;
99532: LD_INT 10500
99534: PPUSH
99535: CALL_OW 67
// solar_recharge_percent := 100 ;
99539: LD_ADDR_OWVAR 79
99543: PUSH
99544: LD_INT 100
99546: ST_TO_ADDR
// end ;
99547: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
99548: LD_EXP 96
99552: PUSH
99553: LD_EXP 120
99557: AND
99558: IFFALSE 99797
99560: GO 99562
99562: DISABLE
99563: LD_INT 0
99565: PPUSH
99566: PPUSH
99567: PPUSH
// begin tmp := [ ] ;
99568: LD_ADDR_VAR 0 3
99572: PUSH
99573: EMPTY
99574: ST_TO_ADDR
// for i := 1 to 6 do
99575: LD_ADDR_VAR 0 1
99579: PUSH
99580: DOUBLE
99581: LD_INT 1
99583: DEC
99584: ST_TO_ADDR
99585: LD_INT 6
99587: PUSH
99588: FOR_TO
99589: IFFALSE 99694
// begin uc_nation := nation_nature ;
99591: LD_ADDR_OWVAR 21
99595: PUSH
99596: LD_INT 0
99598: ST_TO_ADDR
// uc_side := 0 ;
99599: LD_ADDR_OWVAR 20
99603: PUSH
99604: LD_INT 0
99606: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99607: LD_ADDR_OWVAR 29
99611: PUSH
99612: LD_INT 12
99614: PUSH
99615: LD_INT 12
99617: PUSH
99618: EMPTY
99619: LIST
99620: LIST
99621: ST_TO_ADDR
// hc_agressivity := 20 ;
99622: LD_ADDR_OWVAR 35
99626: PUSH
99627: LD_INT 20
99629: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
99630: LD_ADDR_OWVAR 28
99634: PUSH
99635: LD_INT 17
99637: ST_TO_ADDR
// hc_gallery :=  ;
99638: LD_ADDR_OWVAR 33
99642: PUSH
99643: LD_STRING 
99645: ST_TO_ADDR
// hc_name :=  ;
99646: LD_ADDR_OWVAR 26
99650: PUSH
99651: LD_STRING 
99653: ST_TO_ADDR
// un := CreateHuman ;
99654: LD_ADDR_VAR 0 2
99658: PUSH
99659: CALL_OW 44
99663: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
99664: LD_VAR 0 2
99668: PPUSH
99669: LD_INT 1
99671: PPUSH
99672: CALL_OW 51
// tmp := tmp ^ un ;
99676: LD_ADDR_VAR 0 3
99680: PUSH
99681: LD_VAR 0 3
99685: PUSH
99686: LD_VAR 0 2
99690: ADD
99691: ST_TO_ADDR
// end ;
99692: GO 99588
99694: POP
99695: POP
// repeat wait ( 0 0$1 ) ;
99696: LD_INT 35
99698: PPUSH
99699: CALL_OW 67
// for un in tmp do
99703: LD_ADDR_VAR 0 2
99707: PUSH
99708: LD_VAR 0 3
99712: PUSH
99713: FOR_IN
99714: IFFALSE 99788
// begin if IsDead ( un ) then
99716: LD_VAR 0 2
99720: PPUSH
99721: CALL_OW 301
99725: IFFALSE 99745
// begin tmp := tmp diff un ;
99727: LD_ADDR_VAR 0 3
99731: PUSH
99732: LD_VAR 0 3
99736: PUSH
99737: LD_VAR 0 2
99741: DIFF
99742: ST_TO_ADDR
// continue ;
99743: GO 99713
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
99745: LD_VAR 0 2
99749: PPUSH
99750: LD_INT 3
99752: PUSH
99753: LD_INT 22
99755: PUSH
99756: LD_INT 0
99758: PUSH
99759: EMPTY
99760: LIST
99761: LIST
99762: PUSH
99763: EMPTY
99764: LIST
99765: LIST
99766: PPUSH
99767: CALL_OW 69
99771: PPUSH
99772: LD_VAR 0 2
99776: PPUSH
99777: CALL_OW 74
99781: PPUSH
99782: CALL_OW 115
// end ;
99786: GO 99713
99788: POP
99789: POP
// until not tmp ;
99790: LD_VAR 0 3
99794: NOT
99795: IFFALSE 99696
// end ;
99797: PPOPN 3
99799: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99800: LD_EXP 96
99804: PUSH
99805: LD_EXP 121
99809: AND
99810: IFFALSE 99864
99812: GO 99814
99814: DISABLE
// begin ToLua ( displayTroll(); ) ;
99815: LD_STRING displayTroll();
99817: PPUSH
99818: CALL_OW 559
// wait ( 3 3$00 ) ;
99822: LD_INT 6300
99824: PPUSH
99825: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99829: LD_STRING hideTroll();
99831: PPUSH
99832: CALL_OW 559
// wait ( 1 1$00 ) ;
99836: LD_INT 2100
99838: PPUSH
99839: CALL_OW 67
// ToLua ( displayTroll(); ) ;
99843: LD_STRING displayTroll();
99845: PPUSH
99846: CALL_OW 559
// wait ( 1 1$00 ) ;
99850: LD_INT 2100
99852: PPUSH
99853: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99857: LD_STRING hideTroll();
99859: PPUSH
99860: CALL_OW 559
// end ;
99864: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
99865: LD_EXP 96
99869: PUSH
99870: LD_EXP 122
99874: AND
99875: IFFALSE 99938
99877: GO 99879
99879: DISABLE
99880: LD_INT 0
99882: PPUSH
// begin p := 0 ;
99883: LD_ADDR_VAR 0 1
99887: PUSH
99888: LD_INT 0
99890: ST_TO_ADDR
// repeat game_speed := 1 ;
99891: LD_ADDR_OWVAR 65
99895: PUSH
99896: LD_INT 1
99898: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99899: LD_INT 35
99901: PPUSH
99902: CALL_OW 67
// p := p + 1 ;
99906: LD_ADDR_VAR 0 1
99910: PUSH
99911: LD_VAR 0 1
99915: PUSH
99916: LD_INT 1
99918: PLUS
99919: ST_TO_ADDR
// until p >= 60 ;
99920: LD_VAR 0 1
99924: PUSH
99925: LD_INT 60
99927: GREATEREQUAL
99928: IFFALSE 99891
// game_speed := 4 ;
99930: LD_ADDR_OWVAR 65
99934: PUSH
99935: LD_INT 4
99937: ST_TO_ADDR
// end ;
99938: PPOPN 1
99940: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99941: LD_EXP 96
99945: PUSH
99946: LD_EXP 123
99950: AND
99951: IFFALSE 100097
99953: GO 99955
99955: DISABLE
99956: LD_INT 0
99958: PPUSH
99959: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99960: LD_ADDR_VAR 0 1
99964: PUSH
99965: LD_INT 22
99967: PUSH
99968: LD_OWVAR 2
99972: PUSH
99973: EMPTY
99974: LIST
99975: LIST
99976: PUSH
99977: LD_INT 2
99979: PUSH
99980: LD_INT 30
99982: PUSH
99983: LD_INT 0
99985: PUSH
99986: EMPTY
99987: LIST
99988: LIST
99989: PUSH
99990: LD_INT 30
99992: PUSH
99993: LD_INT 1
99995: PUSH
99996: EMPTY
99997: LIST
99998: LIST
99999: PUSH
100000: EMPTY
100001: LIST
100002: LIST
100003: LIST
100004: PUSH
100005: EMPTY
100006: LIST
100007: LIST
100008: PPUSH
100009: CALL_OW 69
100013: ST_TO_ADDR
// if not depot then
100014: LD_VAR 0 1
100018: NOT
100019: IFFALSE 100023
// exit ;
100021: GO 100097
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100023: LD_ADDR_VAR 0 2
100027: PUSH
100028: LD_VAR 0 1
100032: PUSH
100033: LD_INT 1
100035: PPUSH
100036: LD_VAR 0 1
100040: PPUSH
100041: CALL_OW 12
100045: ARRAY
100046: PPUSH
100047: CALL_OW 274
100051: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100052: LD_VAR 0 2
100056: PPUSH
100057: LD_INT 1
100059: PPUSH
100060: LD_INT 0
100062: PPUSH
100063: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100067: LD_VAR 0 2
100071: PPUSH
100072: LD_INT 2
100074: PPUSH
100075: LD_INT 0
100077: PPUSH
100078: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100082: LD_VAR 0 2
100086: PPUSH
100087: LD_INT 3
100089: PPUSH
100090: LD_INT 0
100092: PPUSH
100093: CALL_OW 277
// end ;
100097: PPOPN 2
100099: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100100: LD_EXP 96
100104: PUSH
100105: LD_EXP 124
100109: AND
100110: IFFALSE 100207
100112: GO 100114
100114: DISABLE
100115: LD_INT 0
100117: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100118: LD_ADDR_VAR 0 1
100122: PUSH
100123: LD_INT 22
100125: PUSH
100126: LD_OWVAR 2
100130: PUSH
100131: EMPTY
100132: LIST
100133: LIST
100134: PUSH
100135: LD_INT 21
100137: PUSH
100138: LD_INT 1
100140: PUSH
100141: EMPTY
100142: LIST
100143: LIST
100144: PUSH
100145: LD_INT 3
100147: PUSH
100148: LD_INT 23
100150: PUSH
100151: LD_INT 0
100153: PUSH
100154: EMPTY
100155: LIST
100156: LIST
100157: PUSH
100158: EMPTY
100159: LIST
100160: LIST
100161: PUSH
100162: EMPTY
100163: LIST
100164: LIST
100165: LIST
100166: PPUSH
100167: CALL_OW 69
100171: ST_TO_ADDR
// if not tmp then
100172: LD_VAR 0 1
100176: NOT
100177: IFFALSE 100181
// exit ;
100179: GO 100207
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100181: LD_VAR 0 1
100185: PUSH
100186: LD_INT 1
100188: PPUSH
100189: LD_VAR 0 1
100193: PPUSH
100194: CALL_OW 12
100198: ARRAY
100199: PPUSH
100200: LD_INT 200
100202: PPUSH
100203: CALL_OW 234
// end ;
100207: PPOPN 1
100209: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100210: LD_EXP 96
100214: PUSH
100215: LD_EXP 125
100219: AND
100220: IFFALSE 100299
100222: GO 100224
100224: DISABLE
100225: LD_INT 0
100227: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100228: LD_ADDR_VAR 0 1
100232: PUSH
100233: LD_INT 22
100235: PUSH
100236: LD_OWVAR 2
100240: PUSH
100241: EMPTY
100242: LIST
100243: LIST
100244: PUSH
100245: LD_INT 21
100247: PUSH
100248: LD_INT 2
100250: PUSH
100251: EMPTY
100252: LIST
100253: LIST
100254: PUSH
100255: EMPTY
100256: LIST
100257: LIST
100258: PPUSH
100259: CALL_OW 69
100263: ST_TO_ADDR
// if not tmp then
100264: LD_VAR 0 1
100268: NOT
100269: IFFALSE 100273
// exit ;
100271: GO 100299
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100273: LD_VAR 0 1
100277: PUSH
100278: LD_INT 1
100280: PPUSH
100281: LD_VAR 0 1
100285: PPUSH
100286: CALL_OW 12
100290: ARRAY
100291: PPUSH
100292: LD_INT 60
100294: PPUSH
100295: CALL_OW 234
// end ;
100299: PPOPN 1
100301: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100302: LD_EXP 96
100306: PUSH
100307: LD_EXP 126
100311: AND
100312: IFFALSE 100411
100314: GO 100316
100316: DISABLE
100317: LD_INT 0
100319: PPUSH
100320: PPUSH
// begin enable ;
100321: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100322: LD_ADDR_VAR 0 1
100326: PUSH
100327: LD_INT 22
100329: PUSH
100330: LD_OWVAR 2
100334: PUSH
100335: EMPTY
100336: LIST
100337: LIST
100338: PUSH
100339: LD_INT 61
100341: PUSH
100342: EMPTY
100343: LIST
100344: PUSH
100345: LD_INT 33
100347: PUSH
100348: LD_INT 2
100350: PUSH
100351: EMPTY
100352: LIST
100353: LIST
100354: PUSH
100355: EMPTY
100356: LIST
100357: LIST
100358: LIST
100359: PPUSH
100360: CALL_OW 69
100364: ST_TO_ADDR
// if not tmp then
100365: LD_VAR 0 1
100369: NOT
100370: IFFALSE 100374
// exit ;
100372: GO 100411
// for i in tmp do
100374: LD_ADDR_VAR 0 2
100378: PUSH
100379: LD_VAR 0 1
100383: PUSH
100384: FOR_IN
100385: IFFALSE 100409
// if IsControledBy ( i ) then
100387: LD_VAR 0 2
100391: PPUSH
100392: CALL_OW 312
100396: IFFALSE 100407
// ComUnlink ( i ) ;
100398: LD_VAR 0 2
100402: PPUSH
100403: CALL_OW 136
100407: GO 100384
100409: POP
100410: POP
// end ;
100411: PPOPN 2
100413: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
100414: LD_EXP 96
100418: PUSH
100419: LD_EXP 127
100423: AND
100424: IFFALSE 100564
100426: GO 100428
100428: DISABLE
100429: LD_INT 0
100431: PPUSH
100432: PPUSH
// begin ToLua ( displayPowell(); ) ;
100433: LD_STRING displayPowell();
100435: PPUSH
100436: CALL_OW 559
// uc_side := 0 ;
100440: LD_ADDR_OWVAR 20
100444: PUSH
100445: LD_INT 0
100447: ST_TO_ADDR
// uc_nation := 2 ;
100448: LD_ADDR_OWVAR 21
100452: PUSH
100453: LD_INT 2
100455: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
100456: LD_ADDR_OWVAR 37
100460: PUSH
100461: LD_INT 14
100463: ST_TO_ADDR
// vc_engine := engine_siberite ;
100464: LD_ADDR_OWVAR 39
100468: PUSH
100469: LD_INT 3
100471: ST_TO_ADDR
// vc_control := control_apeman ;
100472: LD_ADDR_OWVAR 38
100476: PUSH
100477: LD_INT 5
100479: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
100480: LD_ADDR_OWVAR 40
100484: PUSH
100485: LD_INT 29
100487: ST_TO_ADDR
// un := CreateVehicle ;
100488: LD_ADDR_VAR 0 2
100492: PUSH
100493: CALL_OW 45
100497: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100498: LD_VAR 0 2
100502: PPUSH
100503: LD_INT 1
100505: PPUSH
100506: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100510: LD_INT 35
100512: PPUSH
100513: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100517: LD_VAR 0 2
100521: PPUSH
100522: LD_INT 22
100524: PUSH
100525: LD_OWVAR 2
100529: PUSH
100530: EMPTY
100531: LIST
100532: LIST
100533: PPUSH
100534: CALL_OW 69
100538: PPUSH
100539: LD_VAR 0 2
100543: PPUSH
100544: CALL_OW 74
100548: PPUSH
100549: CALL_OW 115
// until IsDead ( un ) ;
100553: LD_VAR 0 2
100557: PPUSH
100558: CALL_OW 301
100562: IFFALSE 100510
// end ;
100564: PPOPN 2
100566: END
// every 0 0$1 trigger StreamModeActive and sStu do
100567: LD_EXP 96
100571: PUSH
100572: LD_EXP 135
100576: AND
100577: IFFALSE 100593
100579: GO 100581
100581: DISABLE
// begin ToLua ( displayStucuk(); ) ;
100582: LD_STRING displayStucuk();
100584: PPUSH
100585: CALL_OW 559
// ResetFog ;
100589: CALL_OW 335
// end ;
100593: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
100594: LD_EXP 96
100598: PUSH
100599: LD_EXP 128
100603: AND
100604: IFFALSE 100745
100606: GO 100608
100608: DISABLE
100609: LD_INT 0
100611: PPUSH
100612: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100613: LD_ADDR_VAR 0 2
100617: PUSH
100618: LD_INT 22
100620: PUSH
100621: LD_OWVAR 2
100625: PUSH
100626: EMPTY
100627: LIST
100628: LIST
100629: PUSH
100630: LD_INT 21
100632: PUSH
100633: LD_INT 1
100635: PUSH
100636: EMPTY
100637: LIST
100638: LIST
100639: PUSH
100640: EMPTY
100641: LIST
100642: LIST
100643: PPUSH
100644: CALL_OW 69
100648: ST_TO_ADDR
// if not tmp then
100649: LD_VAR 0 2
100653: NOT
100654: IFFALSE 100658
// exit ;
100656: GO 100745
// un := tmp [ rand ( 1 , tmp ) ] ;
100658: LD_ADDR_VAR 0 1
100662: PUSH
100663: LD_VAR 0 2
100667: PUSH
100668: LD_INT 1
100670: PPUSH
100671: LD_VAR 0 2
100675: PPUSH
100676: CALL_OW 12
100680: ARRAY
100681: ST_TO_ADDR
// SetSide ( un , 0 ) ;
100682: LD_VAR 0 1
100686: PPUSH
100687: LD_INT 0
100689: PPUSH
100690: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
100694: LD_VAR 0 1
100698: PPUSH
100699: LD_OWVAR 3
100703: PUSH
100704: LD_VAR 0 1
100708: DIFF
100709: PPUSH
100710: LD_VAR 0 1
100714: PPUSH
100715: CALL_OW 74
100719: PPUSH
100720: CALL_OW 115
// wait ( 0 0$20 ) ;
100724: LD_INT 700
100726: PPUSH
100727: CALL_OW 67
// SetSide ( un , your_side ) ;
100731: LD_VAR 0 1
100735: PPUSH
100736: LD_OWVAR 2
100740: PPUSH
100741: CALL_OW 235
// end ;
100745: PPOPN 2
100747: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100748: LD_EXP 96
100752: PUSH
100753: LD_EXP 129
100757: AND
100758: IFFALSE 100864
100760: GO 100762
100762: DISABLE
100763: LD_INT 0
100765: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100766: LD_ADDR_VAR 0 1
100770: PUSH
100771: LD_INT 22
100773: PUSH
100774: LD_OWVAR 2
100778: PUSH
100779: EMPTY
100780: LIST
100781: LIST
100782: PUSH
100783: LD_INT 2
100785: PUSH
100786: LD_INT 30
100788: PUSH
100789: LD_INT 0
100791: PUSH
100792: EMPTY
100793: LIST
100794: LIST
100795: PUSH
100796: LD_INT 30
100798: PUSH
100799: LD_INT 1
100801: PUSH
100802: EMPTY
100803: LIST
100804: LIST
100805: PUSH
100806: EMPTY
100807: LIST
100808: LIST
100809: LIST
100810: PUSH
100811: EMPTY
100812: LIST
100813: LIST
100814: PPUSH
100815: CALL_OW 69
100819: ST_TO_ADDR
// if not depot then
100820: LD_VAR 0 1
100824: NOT
100825: IFFALSE 100829
// exit ;
100827: GO 100864
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
100829: LD_VAR 0 1
100833: PUSH
100834: LD_INT 1
100836: ARRAY
100837: PPUSH
100838: CALL_OW 250
100842: PPUSH
100843: LD_VAR 0 1
100847: PUSH
100848: LD_INT 1
100850: ARRAY
100851: PPUSH
100852: CALL_OW 251
100856: PPUSH
100857: LD_INT 70
100859: PPUSH
100860: CALL_OW 495
// end ;
100864: PPOPN 1
100866: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
100867: LD_EXP 96
100871: PUSH
100872: LD_EXP 130
100876: AND
100877: IFFALSE 101088
100879: GO 100881
100881: DISABLE
100882: LD_INT 0
100884: PPUSH
100885: PPUSH
100886: PPUSH
100887: PPUSH
100888: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100889: LD_ADDR_VAR 0 5
100893: PUSH
100894: LD_INT 22
100896: PUSH
100897: LD_OWVAR 2
100901: PUSH
100902: EMPTY
100903: LIST
100904: LIST
100905: PUSH
100906: LD_INT 21
100908: PUSH
100909: LD_INT 1
100911: PUSH
100912: EMPTY
100913: LIST
100914: LIST
100915: PUSH
100916: EMPTY
100917: LIST
100918: LIST
100919: PPUSH
100920: CALL_OW 69
100924: ST_TO_ADDR
// if not tmp then
100925: LD_VAR 0 5
100929: NOT
100930: IFFALSE 100934
// exit ;
100932: GO 101088
// for i in tmp do
100934: LD_ADDR_VAR 0 1
100938: PUSH
100939: LD_VAR 0 5
100943: PUSH
100944: FOR_IN
100945: IFFALSE 101086
// begin d := rand ( 0 , 5 ) ;
100947: LD_ADDR_VAR 0 4
100951: PUSH
100952: LD_INT 0
100954: PPUSH
100955: LD_INT 5
100957: PPUSH
100958: CALL_OW 12
100962: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100963: LD_ADDR_VAR 0 2
100967: PUSH
100968: LD_VAR 0 1
100972: PPUSH
100973: CALL_OW 250
100977: PPUSH
100978: LD_VAR 0 4
100982: PPUSH
100983: LD_INT 3
100985: PPUSH
100986: LD_INT 12
100988: PPUSH
100989: CALL_OW 12
100993: PPUSH
100994: CALL_OW 272
100998: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100999: LD_ADDR_VAR 0 3
101003: PUSH
101004: LD_VAR 0 1
101008: PPUSH
101009: CALL_OW 251
101013: PPUSH
101014: LD_VAR 0 4
101018: PPUSH
101019: LD_INT 3
101021: PPUSH
101022: LD_INT 12
101024: PPUSH
101025: CALL_OW 12
101029: PPUSH
101030: CALL_OW 273
101034: ST_TO_ADDR
// if ValidHex ( x , y ) then
101035: LD_VAR 0 2
101039: PPUSH
101040: LD_VAR 0 3
101044: PPUSH
101045: CALL_OW 488
101049: IFFALSE 101084
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101051: LD_VAR 0 1
101055: PPUSH
101056: LD_VAR 0 2
101060: PPUSH
101061: LD_VAR 0 3
101065: PPUSH
101066: LD_INT 3
101068: PPUSH
101069: LD_INT 6
101071: PPUSH
101072: CALL_OW 12
101076: PPUSH
101077: LD_INT 1
101079: PPUSH
101080: CALL_OW 483
// end ;
101084: GO 100944
101086: POP
101087: POP
// end ;
101088: PPOPN 5
101090: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101091: LD_EXP 96
101095: PUSH
101096: LD_EXP 131
101100: AND
101101: IFFALSE 101195
101103: GO 101105
101105: DISABLE
101106: LD_INT 0
101108: PPUSH
101109: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101110: LD_ADDR_VAR 0 2
101114: PUSH
101115: LD_INT 22
101117: PUSH
101118: LD_OWVAR 2
101122: PUSH
101123: EMPTY
101124: LIST
101125: LIST
101126: PUSH
101127: LD_INT 32
101129: PUSH
101130: LD_INT 1
101132: PUSH
101133: EMPTY
101134: LIST
101135: LIST
101136: PUSH
101137: LD_INT 21
101139: PUSH
101140: LD_INT 2
101142: PUSH
101143: EMPTY
101144: LIST
101145: LIST
101146: PUSH
101147: EMPTY
101148: LIST
101149: LIST
101150: LIST
101151: PPUSH
101152: CALL_OW 69
101156: ST_TO_ADDR
// if not tmp then
101157: LD_VAR 0 2
101161: NOT
101162: IFFALSE 101166
// exit ;
101164: GO 101195
// for i in tmp do
101166: LD_ADDR_VAR 0 1
101170: PUSH
101171: LD_VAR 0 2
101175: PUSH
101176: FOR_IN
101177: IFFALSE 101193
// SetFuel ( i , 0 ) ;
101179: LD_VAR 0 1
101183: PPUSH
101184: LD_INT 0
101186: PPUSH
101187: CALL_OW 240
101191: GO 101176
101193: POP
101194: POP
// end ;
101195: PPOPN 2
101197: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101198: LD_EXP 96
101202: PUSH
101203: LD_EXP 132
101207: AND
101208: IFFALSE 101274
101210: GO 101212
101212: DISABLE
101213: LD_INT 0
101215: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101216: LD_ADDR_VAR 0 1
101220: PUSH
101221: LD_INT 22
101223: PUSH
101224: LD_OWVAR 2
101228: PUSH
101229: EMPTY
101230: LIST
101231: LIST
101232: PUSH
101233: LD_INT 30
101235: PUSH
101236: LD_INT 29
101238: PUSH
101239: EMPTY
101240: LIST
101241: LIST
101242: PUSH
101243: EMPTY
101244: LIST
101245: LIST
101246: PPUSH
101247: CALL_OW 69
101251: ST_TO_ADDR
// if not tmp then
101252: LD_VAR 0 1
101256: NOT
101257: IFFALSE 101261
// exit ;
101259: GO 101274
// DestroyUnit ( tmp [ 1 ] ) ;
101261: LD_VAR 0 1
101265: PUSH
101266: LD_INT 1
101268: ARRAY
101269: PPUSH
101270: CALL_OW 65
// end ;
101274: PPOPN 1
101276: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101277: LD_EXP 96
101281: PUSH
101282: LD_EXP 134
101286: AND
101287: IFFALSE 101416
101289: GO 101291
101291: DISABLE
101292: LD_INT 0
101294: PPUSH
// begin uc_side := 0 ;
101295: LD_ADDR_OWVAR 20
101299: PUSH
101300: LD_INT 0
101302: ST_TO_ADDR
// uc_nation := nation_arabian ;
101303: LD_ADDR_OWVAR 21
101307: PUSH
101308: LD_INT 2
101310: ST_TO_ADDR
// hc_gallery :=  ;
101311: LD_ADDR_OWVAR 33
101315: PUSH
101316: LD_STRING 
101318: ST_TO_ADDR
// hc_name :=  ;
101319: LD_ADDR_OWVAR 26
101323: PUSH
101324: LD_STRING 
101326: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101327: LD_INT 1
101329: PPUSH
101330: LD_INT 11
101332: PPUSH
101333: LD_INT 10
101335: PPUSH
101336: CALL_OW 380
// un := CreateHuman ;
101340: LD_ADDR_VAR 0 1
101344: PUSH
101345: CALL_OW 44
101349: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101350: LD_VAR 0 1
101354: PPUSH
101355: LD_INT 1
101357: PPUSH
101358: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101362: LD_INT 35
101364: PPUSH
101365: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101369: LD_VAR 0 1
101373: PPUSH
101374: LD_INT 22
101376: PUSH
101377: LD_OWVAR 2
101381: PUSH
101382: EMPTY
101383: LIST
101384: LIST
101385: PPUSH
101386: CALL_OW 69
101390: PPUSH
101391: LD_VAR 0 1
101395: PPUSH
101396: CALL_OW 74
101400: PPUSH
101401: CALL_OW 115
// until IsDead ( un ) ;
101405: LD_VAR 0 1
101409: PPUSH
101410: CALL_OW 301
101414: IFFALSE 101362
// end ;
101416: PPOPN 1
101418: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
101419: LD_EXP 96
101423: PUSH
101424: LD_EXP 136
101428: AND
101429: IFFALSE 101441
101431: GO 101433
101433: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
101434: LD_STRING earthquake(getX(game), 0, 32)
101436: PPUSH
101437: CALL_OW 559
101441: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
101442: LD_EXP 96
101446: PUSH
101447: LD_EXP 137
101451: AND
101452: IFFALSE 101543
101454: GO 101456
101456: DISABLE
101457: LD_INT 0
101459: PPUSH
// begin enable ;
101460: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
101461: LD_ADDR_VAR 0 1
101465: PUSH
101466: LD_INT 22
101468: PUSH
101469: LD_OWVAR 2
101473: PUSH
101474: EMPTY
101475: LIST
101476: LIST
101477: PUSH
101478: LD_INT 21
101480: PUSH
101481: LD_INT 2
101483: PUSH
101484: EMPTY
101485: LIST
101486: LIST
101487: PUSH
101488: LD_INT 33
101490: PUSH
101491: LD_INT 3
101493: PUSH
101494: EMPTY
101495: LIST
101496: LIST
101497: PUSH
101498: EMPTY
101499: LIST
101500: LIST
101501: LIST
101502: PPUSH
101503: CALL_OW 69
101507: ST_TO_ADDR
// if not tmp then
101508: LD_VAR 0 1
101512: NOT
101513: IFFALSE 101517
// exit ;
101515: GO 101543
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101517: LD_VAR 0 1
101521: PUSH
101522: LD_INT 1
101524: PPUSH
101525: LD_VAR 0 1
101529: PPUSH
101530: CALL_OW 12
101534: ARRAY
101535: PPUSH
101536: LD_INT 1
101538: PPUSH
101539: CALL_OW 234
// end ;
101543: PPOPN 1
101545: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
101546: LD_EXP 96
101550: PUSH
101551: LD_EXP 138
101555: AND
101556: IFFALSE 101697
101558: GO 101560
101560: DISABLE
101561: LD_INT 0
101563: PPUSH
101564: PPUSH
101565: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101566: LD_ADDR_VAR 0 3
101570: PUSH
101571: LD_INT 22
101573: PUSH
101574: LD_OWVAR 2
101578: PUSH
101579: EMPTY
101580: LIST
101581: LIST
101582: PUSH
101583: LD_INT 25
101585: PUSH
101586: LD_INT 1
101588: PUSH
101589: EMPTY
101590: LIST
101591: LIST
101592: PUSH
101593: EMPTY
101594: LIST
101595: LIST
101596: PPUSH
101597: CALL_OW 69
101601: ST_TO_ADDR
// if not tmp then
101602: LD_VAR 0 3
101606: NOT
101607: IFFALSE 101611
// exit ;
101609: GO 101697
// un := tmp [ rand ( 1 , tmp ) ] ;
101611: LD_ADDR_VAR 0 2
101615: PUSH
101616: LD_VAR 0 3
101620: PUSH
101621: LD_INT 1
101623: PPUSH
101624: LD_VAR 0 3
101628: PPUSH
101629: CALL_OW 12
101633: ARRAY
101634: ST_TO_ADDR
// if Crawls ( un ) then
101635: LD_VAR 0 2
101639: PPUSH
101640: CALL_OW 318
101644: IFFALSE 101655
// ComWalk ( un ) ;
101646: LD_VAR 0 2
101650: PPUSH
101651: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
101655: LD_VAR 0 2
101659: PPUSH
101660: LD_INT 9
101662: PPUSH
101663: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
101667: LD_INT 28
101669: PPUSH
101670: LD_OWVAR 2
101674: PPUSH
101675: LD_INT 2
101677: PPUSH
101678: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
101682: LD_INT 29
101684: PPUSH
101685: LD_OWVAR 2
101689: PPUSH
101690: LD_INT 2
101692: PPUSH
101693: CALL_OW 322
// end ;
101697: PPOPN 3
101699: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
101700: LD_EXP 96
101704: PUSH
101705: LD_EXP 139
101709: AND
101710: IFFALSE 101821
101712: GO 101714
101714: DISABLE
101715: LD_INT 0
101717: PPUSH
101718: PPUSH
101719: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101720: LD_ADDR_VAR 0 3
101724: PUSH
101725: LD_INT 22
101727: PUSH
101728: LD_OWVAR 2
101732: PUSH
101733: EMPTY
101734: LIST
101735: LIST
101736: PUSH
101737: LD_INT 25
101739: PUSH
101740: LD_INT 1
101742: PUSH
101743: EMPTY
101744: LIST
101745: LIST
101746: PUSH
101747: EMPTY
101748: LIST
101749: LIST
101750: PPUSH
101751: CALL_OW 69
101755: ST_TO_ADDR
// if not tmp then
101756: LD_VAR 0 3
101760: NOT
101761: IFFALSE 101765
// exit ;
101763: GO 101821
// un := tmp [ rand ( 1 , tmp ) ] ;
101765: LD_ADDR_VAR 0 2
101769: PUSH
101770: LD_VAR 0 3
101774: PUSH
101775: LD_INT 1
101777: PPUSH
101778: LD_VAR 0 3
101782: PPUSH
101783: CALL_OW 12
101787: ARRAY
101788: ST_TO_ADDR
// if Crawls ( un ) then
101789: LD_VAR 0 2
101793: PPUSH
101794: CALL_OW 318
101798: IFFALSE 101809
// ComWalk ( un ) ;
101800: LD_VAR 0 2
101804: PPUSH
101805: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101809: LD_VAR 0 2
101813: PPUSH
101814: LD_INT 8
101816: PPUSH
101817: CALL_OW 336
// end ;
101821: PPOPN 3
101823: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
101824: LD_EXP 96
101828: PUSH
101829: LD_EXP 140
101833: AND
101834: IFFALSE 101978
101836: GO 101838
101838: DISABLE
101839: LD_INT 0
101841: PPUSH
101842: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
101843: LD_ADDR_VAR 0 2
101847: PUSH
101848: LD_INT 22
101850: PUSH
101851: LD_OWVAR 2
101855: PUSH
101856: EMPTY
101857: LIST
101858: LIST
101859: PUSH
101860: LD_INT 21
101862: PUSH
101863: LD_INT 2
101865: PUSH
101866: EMPTY
101867: LIST
101868: LIST
101869: PUSH
101870: LD_INT 2
101872: PUSH
101873: LD_INT 34
101875: PUSH
101876: LD_INT 12
101878: PUSH
101879: EMPTY
101880: LIST
101881: LIST
101882: PUSH
101883: LD_INT 34
101885: PUSH
101886: LD_INT 51
101888: PUSH
101889: EMPTY
101890: LIST
101891: LIST
101892: PUSH
101893: LD_INT 34
101895: PUSH
101896: LD_INT 32
101898: PUSH
101899: EMPTY
101900: LIST
101901: LIST
101902: PUSH
101903: EMPTY
101904: LIST
101905: LIST
101906: LIST
101907: LIST
101908: PUSH
101909: EMPTY
101910: LIST
101911: LIST
101912: LIST
101913: PPUSH
101914: CALL_OW 69
101918: ST_TO_ADDR
// if not tmp then
101919: LD_VAR 0 2
101923: NOT
101924: IFFALSE 101928
// exit ;
101926: GO 101978
// for i in tmp do
101928: LD_ADDR_VAR 0 1
101932: PUSH
101933: LD_VAR 0 2
101937: PUSH
101938: FOR_IN
101939: IFFALSE 101976
// if GetCargo ( i , mat_artifact ) = 0 then
101941: LD_VAR 0 1
101945: PPUSH
101946: LD_INT 4
101948: PPUSH
101949: CALL_OW 289
101953: PUSH
101954: LD_INT 0
101956: EQUAL
101957: IFFALSE 101974
// SetCargo ( i , mat_siberit , 100 ) ;
101959: LD_VAR 0 1
101963: PPUSH
101964: LD_INT 3
101966: PPUSH
101967: LD_INT 100
101969: PPUSH
101970: CALL_OW 290
101974: GO 101938
101976: POP
101977: POP
// end ;
101978: PPOPN 2
101980: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101981: LD_EXP 96
101985: PUSH
101986: LD_EXP 141
101990: AND
101991: IFFALSE 102174
101993: GO 101995
101995: DISABLE
101996: LD_INT 0
101998: PPUSH
101999: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102000: LD_ADDR_VAR 0 2
102004: PUSH
102005: LD_INT 22
102007: PUSH
102008: LD_OWVAR 2
102012: PUSH
102013: EMPTY
102014: LIST
102015: LIST
102016: PPUSH
102017: CALL_OW 69
102021: ST_TO_ADDR
// if not tmp then
102022: LD_VAR 0 2
102026: NOT
102027: IFFALSE 102031
// exit ;
102029: GO 102174
// for i := 1 to 2 do
102031: LD_ADDR_VAR 0 1
102035: PUSH
102036: DOUBLE
102037: LD_INT 1
102039: DEC
102040: ST_TO_ADDR
102041: LD_INT 2
102043: PUSH
102044: FOR_TO
102045: IFFALSE 102172
// begin uc_side := your_side ;
102047: LD_ADDR_OWVAR 20
102051: PUSH
102052: LD_OWVAR 2
102056: ST_TO_ADDR
// uc_nation := nation_american ;
102057: LD_ADDR_OWVAR 21
102061: PUSH
102062: LD_INT 1
102064: ST_TO_ADDR
// vc_chassis := us_morphling ;
102065: LD_ADDR_OWVAR 37
102069: PUSH
102070: LD_INT 5
102072: ST_TO_ADDR
// vc_engine := engine_siberite ;
102073: LD_ADDR_OWVAR 39
102077: PUSH
102078: LD_INT 3
102080: ST_TO_ADDR
// vc_control := control_computer ;
102081: LD_ADDR_OWVAR 38
102085: PUSH
102086: LD_INT 3
102088: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102089: LD_ADDR_OWVAR 40
102093: PUSH
102094: LD_INT 10
102096: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102097: LD_VAR 0 2
102101: PUSH
102102: LD_INT 1
102104: ARRAY
102105: PPUSH
102106: CALL_OW 310
102110: NOT
102111: IFFALSE 102158
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102113: CALL_OW 45
102117: PPUSH
102118: LD_VAR 0 2
102122: PUSH
102123: LD_INT 1
102125: ARRAY
102126: PPUSH
102127: CALL_OW 250
102131: PPUSH
102132: LD_VAR 0 2
102136: PUSH
102137: LD_INT 1
102139: ARRAY
102140: PPUSH
102141: CALL_OW 251
102145: PPUSH
102146: LD_INT 12
102148: PPUSH
102149: LD_INT 1
102151: PPUSH
102152: CALL_OW 50
102156: GO 102170
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102158: CALL_OW 45
102162: PPUSH
102163: LD_INT 1
102165: PPUSH
102166: CALL_OW 51
// end ;
102170: GO 102044
102172: POP
102173: POP
// end ;
102174: PPOPN 2
102176: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102177: LD_EXP 96
102181: PUSH
102182: LD_EXP 142
102186: AND
102187: IFFALSE 102409
102189: GO 102191
102191: DISABLE
102192: LD_INT 0
102194: PPUSH
102195: PPUSH
102196: PPUSH
102197: PPUSH
102198: PPUSH
102199: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102200: LD_ADDR_VAR 0 6
102204: PUSH
102205: LD_INT 22
102207: PUSH
102208: LD_OWVAR 2
102212: PUSH
102213: EMPTY
102214: LIST
102215: LIST
102216: PUSH
102217: LD_INT 21
102219: PUSH
102220: LD_INT 1
102222: PUSH
102223: EMPTY
102224: LIST
102225: LIST
102226: PUSH
102227: LD_INT 3
102229: PUSH
102230: LD_INT 23
102232: PUSH
102233: LD_INT 0
102235: PUSH
102236: EMPTY
102237: LIST
102238: LIST
102239: PUSH
102240: EMPTY
102241: LIST
102242: LIST
102243: PUSH
102244: EMPTY
102245: LIST
102246: LIST
102247: LIST
102248: PPUSH
102249: CALL_OW 69
102253: ST_TO_ADDR
// if not tmp then
102254: LD_VAR 0 6
102258: NOT
102259: IFFALSE 102263
// exit ;
102261: GO 102409
// s1 := rand ( 1 , 4 ) ;
102263: LD_ADDR_VAR 0 2
102267: PUSH
102268: LD_INT 1
102270: PPUSH
102271: LD_INT 4
102273: PPUSH
102274: CALL_OW 12
102278: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102279: LD_ADDR_VAR 0 4
102283: PUSH
102284: LD_VAR 0 6
102288: PUSH
102289: LD_INT 1
102291: ARRAY
102292: PPUSH
102293: LD_VAR 0 2
102297: PPUSH
102298: CALL_OW 259
102302: ST_TO_ADDR
// if s1 = 1 then
102303: LD_VAR 0 2
102307: PUSH
102308: LD_INT 1
102310: EQUAL
102311: IFFALSE 102331
// s2 := rand ( 2 , 4 ) else
102313: LD_ADDR_VAR 0 3
102317: PUSH
102318: LD_INT 2
102320: PPUSH
102321: LD_INT 4
102323: PPUSH
102324: CALL_OW 12
102328: ST_TO_ADDR
102329: GO 102339
// s2 := 1 ;
102331: LD_ADDR_VAR 0 3
102335: PUSH
102336: LD_INT 1
102338: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102339: LD_ADDR_VAR 0 5
102343: PUSH
102344: LD_VAR 0 6
102348: PUSH
102349: LD_INT 1
102351: ARRAY
102352: PPUSH
102353: LD_VAR 0 3
102357: PPUSH
102358: CALL_OW 259
102362: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102363: LD_VAR 0 6
102367: PUSH
102368: LD_INT 1
102370: ARRAY
102371: PPUSH
102372: LD_VAR 0 2
102376: PPUSH
102377: LD_VAR 0 5
102381: PPUSH
102382: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
102386: LD_VAR 0 6
102390: PUSH
102391: LD_INT 1
102393: ARRAY
102394: PPUSH
102395: LD_VAR 0 3
102399: PPUSH
102400: LD_VAR 0 4
102404: PPUSH
102405: CALL_OW 237
// end ;
102409: PPOPN 6
102411: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
102412: LD_EXP 96
102416: PUSH
102417: LD_EXP 143
102421: AND
102422: IFFALSE 102501
102424: GO 102426
102426: DISABLE
102427: LD_INT 0
102429: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
102430: LD_ADDR_VAR 0 1
102434: PUSH
102435: LD_INT 22
102437: PUSH
102438: LD_OWVAR 2
102442: PUSH
102443: EMPTY
102444: LIST
102445: LIST
102446: PUSH
102447: LD_INT 30
102449: PUSH
102450: LD_INT 3
102452: PUSH
102453: EMPTY
102454: LIST
102455: LIST
102456: PUSH
102457: EMPTY
102458: LIST
102459: LIST
102460: PPUSH
102461: CALL_OW 69
102465: ST_TO_ADDR
// if not tmp then
102466: LD_VAR 0 1
102470: NOT
102471: IFFALSE 102475
// exit ;
102473: GO 102501
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102475: LD_VAR 0 1
102479: PUSH
102480: LD_INT 1
102482: PPUSH
102483: LD_VAR 0 1
102487: PPUSH
102488: CALL_OW 12
102492: ARRAY
102493: PPUSH
102494: LD_INT 1
102496: PPUSH
102497: CALL_OW 234
// end ;
102501: PPOPN 1
102503: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
102504: LD_EXP 96
102508: PUSH
102509: LD_EXP 144
102513: AND
102514: IFFALSE 102626
102516: GO 102518
102518: DISABLE
102519: LD_INT 0
102521: PPUSH
102522: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
102523: LD_ADDR_VAR 0 2
102527: PUSH
102528: LD_INT 22
102530: PUSH
102531: LD_OWVAR 2
102535: PUSH
102536: EMPTY
102537: LIST
102538: LIST
102539: PUSH
102540: LD_INT 2
102542: PUSH
102543: LD_INT 30
102545: PUSH
102546: LD_INT 27
102548: PUSH
102549: EMPTY
102550: LIST
102551: LIST
102552: PUSH
102553: LD_INT 30
102555: PUSH
102556: LD_INT 26
102558: PUSH
102559: EMPTY
102560: LIST
102561: LIST
102562: PUSH
102563: LD_INT 30
102565: PUSH
102566: LD_INT 28
102568: PUSH
102569: EMPTY
102570: LIST
102571: LIST
102572: PUSH
102573: EMPTY
102574: LIST
102575: LIST
102576: LIST
102577: LIST
102578: PUSH
102579: EMPTY
102580: LIST
102581: LIST
102582: PPUSH
102583: CALL_OW 69
102587: ST_TO_ADDR
// if not tmp then
102588: LD_VAR 0 2
102592: NOT
102593: IFFALSE 102597
// exit ;
102595: GO 102626
// for i in tmp do
102597: LD_ADDR_VAR 0 1
102601: PUSH
102602: LD_VAR 0 2
102606: PUSH
102607: FOR_IN
102608: IFFALSE 102624
// SetLives ( i , 1 ) ;
102610: LD_VAR 0 1
102614: PPUSH
102615: LD_INT 1
102617: PPUSH
102618: CALL_OW 234
102622: GO 102607
102624: POP
102625: POP
// end ;
102626: PPOPN 2
102628: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
102629: LD_EXP 96
102633: PUSH
102634: LD_EXP 145
102638: AND
102639: IFFALSE 102926
102641: GO 102643
102643: DISABLE
102644: LD_INT 0
102646: PPUSH
102647: PPUSH
102648: PPUSH
// begin i := rand ( 1 , 7 ) ;
102649: LD_ADDR_VAR 0 1
102653: PUSH
102654: LD_INT 1
102656: PPUSH
102657: LD_INT 7
102659: PPUSH
102660: CALL_OW 12
102664: ST_TO_ADDR
// case i of 1 :
102665: LD_VAR 0 1
102669: PUSH
102670: LD_INT 1
102672: DOUBLE
102673: EQUAL
102674: IFTRUE 102678
102676: GO 102688
102678: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
102679: LD_STRING earthquake(getX(game), 0, 32)
102681: PPUSH
102682: CALL_OW 559
102686: GO 102926
102688: LD_INT 2
102690: DOUBLE
102691: EQUAL
102692: IFTRUE 102696
102694: GO 102710
102696: POP
// begin ToLua ( displayStucuk(); ) ;
102697: LD_STRING displayStucuk();
102699: PPUSH
102700: CALL_OW 559
// ResetFog ;
102704: CALL_OW 335
// end ; 3 :
102708: GO 102926
102710: LD_INT 3
102712: DOUBLE
102713: EQUAL
102714: IFTRUE 102718
102716: GO 102822
102718: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102719: LD_ADDR_VAR 0 2
102723: PUSH
102724: LD_INT 22
102726: PUSH
102727: LD_OWVAR 2
102731: PUSH
102732: EMPTY
102733: LIST
102734: LIST
102735: PUSH
102736: LD_INT 25
102738: PUSH
102739: LD_INT 1
102741: PUSH
102742: EMPTY
102743: LIST
102744: LIST
102745: PUSH
102746: EMPTY
102747: LIST
102748: LIST
102749: PPUSH
102750: CALL_OW 69
102754: ST_TO_ADDR
// if not tmp then
102755: LD_VAR 0 2
102759: NOT
102760: IFFALSE 102764
// exit ;
102762: GO 102926
// un := tmp [ rand ( 1 , tmp ) ] ;
102764: LD_ADDR_VAR 0 3
102768: PUSH
102769: LD_VAR 0 2
102773: PUSH
102774: LD_INT 1
102776: PPUSH
102777: LD_VAR 0 2
102781: PPUSH
102782: CALL_OW 12
102786: ARRAY
102787: ST_TO_ADDR
// if Crawls ( un ) then
102788: LD_VAR 0 3
102792: PPUSH
102793: CALL_OW 318
102797: IFFALSE 102808
// ComWalk ( un ) ;
102799: LD_VAR 0 3
102803: PPUSH
102804: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102808: LD_VAR 0 3
102812: PPUSH
102813: LD_INT 8
102815: PPUSH
102816: CALL_OW 336
// end ; 4 :
102820: GO 102926
102822: LD_INT 4
102824: DOUBLE
102825: EQUAL
102826: IFTRUE 102830
102828: GO 102904
102830: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102831: LD_ADDR_VAR 0 2
102835: PUSH
102836: LD_INT 22
102838: PUSH
102839: LD_OWVAR 2
102843: PUSH
102844: EMPTY
102845: LIST
102846: LIST
102847: PUSH
102848: LD_INT 30
102850: PUSH
102851: LD_INT 29
102853: PUSH
102854: EMPTY
102855: LIST
102856: LIST
102857: PUSH
102858: EMPTY
102859: LIST
102860: LIST
102861: PPUSH
102862: CALL_OW 69
102866: ST_TO_ADDR
// if not tmp then
102867: LD_VAR 0 2
102871: NOT
102872: IFFALSE 102876
// exit ;
102874: GO 102926
// CenterNowOnUnits ( tmp [ 1 ] ) ;
102876: LD_VAR 0 2
102880: PUSH
102881: LD_INT 1
102883: ARRAY
102884: PPUSH
102885: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
102889: LD_VAR 0 2
102893: PUSH
102894: LD_INT 1
102896: ARRAY
102897: PPUSH
102898: CALL_OW 65
// end ; 5 .. 7 :
102902: GO 102926
102904: LD_INT 5
102906: DOUBLE
102907: GREATEREQUAL
102908: IFFALSE 102916
102910: LD_INT 7
102912: DOUBLE
102913: LESSEQUAL
102914: IFTRUE 102918
102916: GO 102925
102918: POP
// StreamSibBomb ; end ;
102919: CALL 99163 0 0
102923: GO 102926
102925: POP
// end ;
102926: PPOPN 3
102928: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102929: LD_EXP 96
102933: PUSH
102934: LD_EXP 146
102938: AND
102939: IFFALSE 103095
102941: GO 102943
102943: DISABLE
102944: LD_INT 0
102946: PPUSH
102947: PPUSH
102948: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102949: LD_ADDR_VAR 0 2
102953: PUSH
102954: LD_INT 81
102956: PUSH
102957: LD_OWVAR 2
102961: PUSH
102962: EMPTY
102963: LIST
102964: LIST
102965: PUSH
102966: LD_INT 2
102968: PUSH
102969: LD_INT 21
102971: PUSH
102972: LD_INT 1
102974: PUSH
102975: EMPTY
102976: LIST
102977: LIST
102978: PUSH
102979: LD_INT 21
102981: PUSH
102982: LD_INT 2
102984: PUSH
102985: EMPTY
102986: LIST
102987: LIST
102988: PUSH
102989: EMPTY
102990: LIST
102991: LIST
102992: LIST
102993: PUSH
102994: EMPTY
102995: LIST
102996: LIST
102997: PPUSH
102998: CALL_OW 69
103002: ST_TO_ADDR
// if not tmp then
103003: LD_VAR 0 2
103007: NOT
103008: IFFALSE 103012
// exit ;
103010: GO 103095
// p := 0 ;
103012: LD_ADDR_VAR 0 3
103016: PUSH
103017: LD_INT 0
103019: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103020: LD_INT 35
103022: PPUSH
103023: CALL_OW 67
// p := p + 1 ;
103027: LD_ADDR_VAR 0 3
103031: PUSH
103032: LD_VAR 0 3
103036: PUSH
103037: LD_INT 1
103039: PLUS
103040: ST_TO_ADDR
// for i in tmp do
103041: LD_ADDR_VAR 0 1
103045: PUSH
103046: LD_VAR 0 2
103050: PUSH
103051: FOR_IN
103052: IFFALSE 103083
// if GetLives ( i ) < 1000 then
103054: LD_VAR 0 1
103058: PPUSH
103059: CALL_OW 256
103063: PUSH
103064: LD_INT 1000
103066: LESS
103067: IFFALSE 103081
// SetLives ( i , 1000 ) ;
103069: LD_VAR 0 1
103073: PPUSH
103074: LD_INT 1000
103076: PPUSH
103077: CALL_OW 234
103081: GO 103051
103083: POP
103084: POP
// until p > 20 ;
103085: LD_VAR 0 3
103089: PUSH
103090: LD_INT 20
103092: GREATER
103093: IFFALSE 103020
// end ;
103095: PPOPN 3
103097: END
// every 0 0$1 trigger StreamModeActive and sTime do
103098: LD_EXP 96
103102: PUSH
103103: LD_EXP 147
103107: AND
103108: IFFALSE 103143
103110: GO 103112
103112: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103113: LD_INT 28
103115: PPUSH
103116: LD_OWVAR 2
103120: PPUSH
103121: LD_INT 2
103123: PPUSH
103124: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103128: LD_INT 30
103130: PPUSH
103131: LD_OWVAR 2
103135: PPUSH
103136: LD_INT 2
103138: PPUSH
103139: CALL_OW 322
// end ;
103143: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103144: LD_EXP 96
103148: PUSH
103149: LD_EXP 148
103153: AND
103154: IFFALSE 103275
103156: GO 103158
103158: DISABLE
103159: LD_INT 0
103161: PPUSH
103162: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103163: LD_ADDR_VAR 0 2
103167: PUSH
103168: LD_INT 22
103170: PUSH
103171: LD_OWVAR 2
103175: PUSH
103176: EMPTY
103177: LIST
103178: LIST
103179: PUSH
103180: LD_INT 21
103182: PUSH
103183: LD_INT 1
103185: PUSH
103186: EMPTY
103187: LIST
103188: LIST
103189: PUSH
103190: LD_INT 3
103192: PUSH
103193: LD_INT 23
103195: PUSH
103196: LD_INT 0
103198: PUSH
103199: EMPTY
103200: LIST
103201: LIST
103202: PUSH
103203: EMPTY
103204: LIST
103205: LIST
103206: PUSH
103207: EMPTY
103208: LIST
103209: LIST
103210: LIST
103211: PPUSH
103212: CALL_OW 69
103216: ST_TO_ADDR
// if not tmp then
103217: LD_VAR 0 2
103221: NOT
103222: IFFALSE 103226
// exit ;
103224: GO 103275
// for i in tmp do
103226: LD_ADDR_VAR 0 1
103230: PUSH
103231: LD_VAR 0 2
103235: PUSH
103236: FOR_IN
103237: IFFALSE 103273
// begin if Crawls ( i ) then
103239: LD_VAR 0 1
103243: PPUSH
103244: CALL_OW 318
103248: IFFALSE 103259
// ComWalk ( i ) ;
103250: LD_VAR 0 1
103254: PPUSH
103255: CALL_OW 138
// SetClass ( i , 2 ) ;
103259: LD_VAR 0 1
103263: PPUSH
103264: LD_INT 2
103266: PPUSH
103267: CALL_OW 336
// end ;
103271: GO 103236
103273: POP
103274: POP
// end ;
103275: PPOPN 2
103277: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103278: LD_EXP 96
103282: PUSH
103283: LD_EXP 149
103287: AND
103288: IFFALSE 103576
103290: GO 103292
103292: DISABLE
103293: LD_INT 0
103295: PPUSH
103296: PPUSH
103297: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103298: LD_OWVAR 2
103302: PPUSH
103303: LD_INT 9
103305: PPUSH
103306: LD_INT 1
103308: PPUSH
103309: LD_INT 1
103311: PPUSH
103312: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103316: LD_INT 9
103318: PPUSH
103319: LD_OWVAR 2
103323: PPUSH
103324: CALL_OW 343
// uc_side := 9 ;
103328: LD_ADDR_OWVAR 20
103332: PUSH
103333: LD_INT 9
103335: ST_TO_ADDR
// uc_nation := 2 ;
103336: LD_ADDR_OWVAR 21
103340: PUSH
103341: LD_INT 2
103343: ST_TO_ADDR
// hc_name := Dark Warrior ;
103344: LD_ADDR_OWVAR 26
103348: PUSH
103349: LD_STRING Dark Warrior
103351: ST_TO_ADDR
// hc_gallery :=  ;
103352: LD_ADDR_OWVAR 33
103356: PUSH
103357: LD_STRING 
103359: ST_TO_ADDR
// hc_noskilllimit := true ;
103360: LD_ADDR_OWVAR 76
103364: PUSH
103365: LD_INT 1
103367: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103368: LD_ADDR_OWVAR 31
103372: PUSH
103373: LD_INT 30
103375: PUSH
103376: LD_INT 30
103378: PUSH
103379: LD_INT 30
103381: PUSH
103382: LD_INT 30
103384: PUSH
103385: EMPTY
103386: LIST
103387: LIST
103388: LIST
103389: LIST
103390: ST_TO_ADDR
// un := CreateHuman ;
103391: LD_ADDR_VAR 0 3
103395: PUSH
103396: CALL_OW 44
103400: ST_TO_ADDR
// hc_noskilllimit := false ;
103401: LD_ADDR_OWVAR 76
103405: PUSH
103406: LD_INT 0
103408: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103409: LD_VAR 0 3
103413: PPUSH
103414: LD_INT 1
103416: PPUSH
103417: CALL_OW 51
// ToLua ( playRanger() ) ;
103421: LD_STRING playRanger()
103423: PPUSH
103424: CALL_OW 559
// p := 0 ;
103428: LD_ADDR_VAR 0 2
103432: PUSH
103433: LD_INT 0
103435: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103436: LD_INT 35
103438: PPUSH
103439: CALL_OW 67
// p := p + 1 ;
103443: LD_ADDR_VAR 0 2
103447: PUSH
103448: LD_VAR 0 2
103452: PUSH
103453: LD_INT 1
103455: PLUS
103456: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
103457: LD_VAR 0 3
103461: PPUSH
103462: CALL_OW 256
103466: PUSH
103467: LD_INT 1000
103469: LESS
103470: IFFALSE 103484
// SetLives ( un , 1000 ) ;
103472: LD_VAR 0 3
103476: PPUSH
103477: LD_INT 1000
103479: PPUSH
103480: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
103484: LD_VAR 0 3
103488: PPUSH
103489: LD_INT 81
103491: PUSH
103492: LD_OWVAR 2
103496: PUSH
103497: EMPTY
103498: LIST
103499: LIST
103500: PUSH
103501: LD_INT 91
103503: PUSH
103504: LD_VAR 0 3
103508: PUSH
103509: LD_INT 30
103511: PUSH
103512: EMPTY
103513: LIST
103514: LIST
103515: LIST
103516: PUSH
103517: EMPTY
103518: LIST
103519: LIST
103520: PPUSH
103521: CALL_OW 69
103525: PPUSH
103526: LD_VAR 0 3
103530: PPUSH
103531: CALL_OW 74
103535: PPUSH
103536: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
103540: LD_VAR 0 2
103544: PUSH
103545: LD_INT 80
103547: GREATER
103548: PUSH
103549: LD_VAR 0 3
103553: PPUSH
103554: CALL_OW 301
103558: OR
103559: IFFALSE 103436
// if un then
103561: LD_VAR 0 3
103565: IFFALSE 103576
// RemoveUnit ( un ) ;
103567: LD_VAR 0 3
103571: PPUSH
103572: CALL_OW 64
// end ;
103576: PPOPN 3
103578: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
103579: LD_EXP 150
103583: IFFALSE 103699
103585: GO 103587
103587: DISABLE
103588: LD_INT 0
103590: PPUSH
103591: PPUSH
103592: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
103593: LD_ADDR_VAR 0 2
103597: PUSH
103598: LD_INT 81
103600: PUSH
103601: LD_OWVAR 2
103605: PUSH
103606: EMPTY
103607: LIST
103608: LIST
103609: PUSH
103610: LD_INT 21
103612: PUSH
103613: LD_INT 1
103615: PUSH
103616: EMPTY
103617: LIST
103618: LIST
103619: PUSH
103620: EMPTY
103621: LIST
103622: LIST
103623: PPUSH
103624: CALL_OW 69
103628: ST_TO_ADDR
// ToLua ( playComputer() ) ;
103629: LD_STRING playComputer()
103631: PPUSH
103632: CALL_OW 559
// if not tmp then
103636: LD_VAR 0 2
103640: NOT
103641: IFFALSE 103645
// exit ;
103643: GO 103699
// for i in tmp do
103645: LD_ADDR_VAR 0 1
103649: PUSH
103650: LD_VAR 0 2
103654: PUSH
103655: FOR_IN
103656: IFFALSE 103697
// for j := 1 to 4 do
103658: LD_ADDR_VAR 0 3
103662: PUSH
103663: DOUBLE
103664: LD_INT 1
103666: DEC
103667: ST_TO_ADDR
103668: LD_INT 4
103670: PUSH
103671: FOR_TO
103672: IFFALSE 103693
// SetSkill ( i , j , 10 ) ;
103674: LD_VAR 0 1
103678: PPUSH
103679: LD_VAR 0 3
103683: PPUSH
103684: LD_INT 10
103686: PPUSH
103687: CALL_OW 237
103691: GO 103671
103693: POP
103694: POP
103695: GO 103655
103697: POP
103698: POP
// end ;
103699: PPOPN 3
103701: END
// every 0 0$1 trigger s30 do var i , tmp ;
103702: LD_EXP 151
103706: IFFALSE 103775
103708: GO 103710
103710: DISABLE
103711: LD_INT 0
103713: PPUSH
103714: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103715: LD_ADDR_VAR 0 2
103719: PUSH
103720: LD_INT 22
103722: PUSH
103723: LD_OWVAR 2
103727: PUSH
103728: EMPTY
103729: LIST
103730: LIST
103731: PPUSH
103732: CALL_OW 69
103736: ST_TO_ADDR
// if not tmp then
103737: LD_VAR 0 2
103741: NOT
103742: IFFALSE 103746
// exit ;
103744: GO 103775
// for i in tmp do
103746: LD_ADDR_VAR 0 1
103750: PUSH
103751: LD_VAR 0 2
103755: PUSH
103756: FOR_IN
103757: IFFALSE 103773
// SetLives ( i , 300 ) ;
103759: LD_VAR 0 1
103763: PPUSH
103764: LD_INT 300
103766: PPUSH
103767: CALL_OW 234
103771: GO 103756
103773: POP
103774: POP
// end ;
103775: PPOPN 2
103777: END
// every 0 0$1 trigger s60 do var i , tmp ;
103778: LD_EXP 152
103782: IFFALSE 103851
103784: GO 103786
103786: DISABLE
103787: LD_INT 0
103789: PPUSH
103790: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103791: LD_ADDR_VAR 0 2
103795: PUSH
103796: LD_INT 22
103798: PUSH
103799: LD_OWVAR 2
103803: PUSH
103804: EMPTY
103805: LIST
103806: LIST
103807: PPUSH
103808: CALL_OW 69
103812: ST_TO_ADDR
// if not tmp then
103813: LD_VAR 0 2
103817: NOT
103818: IFFALSE 103822
// exit ;
103820: GO 103851
// for i in tmp do
103822: LD_ADDR_VAR 0 1
103826: PUSH
103827: LD_VAR 0 2
103831: PUSH
103832: FOR_IN
103833: IFFALSE 103849
// SetLives ( i , 600 ) ;
103835: LD_VAR 0 1
103839: PPUSH
103840: LD_INT 600
103842: PPUSH
103843: CALL_OW 234
103847: GO 103832
103849: POP
103850: POP
// end ;
103851: PPOPN 2
103853: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103854: LD_INT 0
103856: PPUSH
// case cmd of 301 :
103857: LD_VAR 0 1
103861: PUSH
103862: LD_INT 301
103864: DOUBLE
103865: EQUAL
103866: IFTRUE 103870
103868: GO 103902
103870: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
103871: LD_VAR 0 6
103875: PPUSH
103876: LD_VAR 0 7
103880: PPUSH
103881: LD_VAR 0 8
103885: PPUSH
103886: LD_VAR 0 4
103890: PPUSH
103891: LD_VAR 0 5
103895: PPUSH
103896: CALL 105111 0 5
103900: GO 104023
103902: LD_INT 302
103904: DOUBLE
103905: EQUAL
103906: IFTRUE 103910
103908: GO 103947
103910: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
103911: LD_VAR 0 6
103915: PPUSH
103916: LD_VAR 0 7
103920: PPUSH
103921: LD_VAR 0 8
103925: PPUSH
103926: LD_VAR 0 9
103930: PPUSH
103931: LD_VAR 0 4
103935: PPUSH
103936: LD_VAR 0 5
103940: PPUSH
103941: CALL 105202 0 6
103945: GO 104023
103947: LD_INT 303
103949: DOUBLE
103950: EQUAL
103951: IFTRUE 103955
103953: GO 103992
103955: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103956: LD_VAR 0 6
103960: PPUSH
103961: LD_VAR 0 7
103965: PPUSH
103966: LD_VAR 0 8
103970: PPUSH
103971: LD_VAR 0 9
103975: PPUSH
103976: LD_VAR 0 4
103980: PPUSH
103981: LD_VAR 0 5
103985: PPUSH
103986: CALL 104028 0 6
103990: GO 104023
103992: LD_INT 304
103994: DOUBLE
103995: EQUAL
103996: IFTRUE 104000
103998: GO 104022
104000: POP
// hHackTeleport ( unit , x , y ) ; end ;
104001: LD_VAR 0 2
104005: PPUSH
104006: LD_VAR 0 4
104010: PPUSH
104011: LD_VAR 0 5
104015: PPUSH
104016: CALL 105795 0 3
104020: GO 104023
104022: POP
// end ;
104023: LD_VAR 0 12
104027: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104028: LD_INT 0
104030: PPUSH
104031: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104032: LD_VAR 0 1
104036: PUSH
104037: LD_INT 1
104039: LESS
104040: PUSH
104041: LD_VAR 0 1
104045: PUSH
104046: LD_INT 3
104048: GREATER
104049: OR
104050: PUSH
104051: LD_VAR 0 5
104055: PPUSH
104056: LD_VAR 0 6
104060: PPUSH
104061: CALL_OW 428
104065: OR
104066: IFFALSE 104070
// exit ;
104068: GO 104798
// uc_side := your_side ;
104070: LD_ADDR_OWVAR 20
104074: PUSH
104075: LD_OWVAR 2
104079: ST_TO_ADDR
// uc_nation := nation ;
104080: LD_ADDR_OWVAR 21
104084: PUSH
104085: LD_VAR 0 1
104089: ST_TO_ADDR
// bc_level = 1 ;
104090: LD_ADDR_OWVAR 43
104094: PUSH
104095: LD_INT 1
104097: ST_TO_ADDR
// case btype of 1 :
104098: LD_VAR 0 2
104102: PUSH
104103: LD_INT 1
104105: DOUBLE
104106: EQUAL
104107: IFTRUE 104111
104109: GO 104122
104111: POP
// bc_type := b_depot ; 2 :
104112: LD_ADDR_OWVAR 42
104116: PUSH
104117: LD_INT 0
104119: ST_TO_ADDR
104120: GO 104742
104122: LD_INT 2
104124: DOUBLE
104125: EQUAL
104126: IFTRUE 104130
104128: GO 104141
104130: POP
// bc_type := b_warehouse ; 3 :
104131: LD_ADDR_OWVAR 42
104135: PUSH
104136: LD_INT 1
104138: ST_TO_ADDR
104139: GO 104742
104141: LD_INT 3
104143: DOUBLE
104144: EQUAL
104145: IFTRUE 104149
104147: GO 104160
104149: POP
// bc_type := b_lab ; 4 .. 9 :
104150: LD_ADDR_OWVAR 42
104154: PUSH
104155: LD_INT 6
104157: ST_TO_ADDR
104158: GO 104742
104160: LD_INT 4
104162: DOUBLE
104163: GREATEREQUAL
104164: IFFALSE 104172
104166: LD_INT 9
104168: DOUBLE
104169: LESSEQUAL
104170: IFTRUE 104174
104172: GO 104234
104174: POP
// begin bc_type := b_lab_half ;
104175: LD_ADDR_OWVAR 42
104179: PUSH
104180: LD_INT 7
104182: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104183: LD_ADDR_OWVAR 44
104187: PUSH
104188: LD_INT 10
104190: PUSH
104191: LD_INT 11
104193: PUSH
104194: LD_INT 12
104196: PUSH
104197: LD_INT 15
104199: PUSH
104200: LD_INT 14
104202: PUSH
104203: LD_INT 13
104205: PUSH
104206: EMPTY
104207: LIST
104208: LIST
104209: LIST
104210: LIST
104211: LIST
104212: LIST
104213: PUSH
104214: LD_VAR 0 2
104218: PUSH
104219: LD_INT 3
104221: MINUS
104222: ARRAY
104223: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
104224: LD_ADDR_OWVAR 45
104228: PUSH
104229: LD_INT 9
104231: ST_TO_ADDR
// end ; 10 .. 13 :
104232: GO 104742
104234: LD_INT 10
104236: DOUBLE
104237: GREATEREQUAL
104238: IFFALSE 104246
104240: LD_INT 13
104242: DOUBLE
104243: LESSEQUAL
104244: IFTRUE 104248
104246: GO 104325
104248: POP
// begin bc_type := b_lab_full ;
104249: LD_ADDR_OWVAR 42
104253: PUSH
104254: LD_INT 8
104256: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104257: LD_ADDR_OWVAR 44
104261: PUSH
104262: LD_INT 10
104264: PUSH
104265: LD_INT 12
104267: PUSH
104268: LD_INT 14
104270: PUSH
104271: LD_INT 13
104273: PUSH
104274: EMPTY
104275: LIST
104276: LIST
104277: LIST
104278: LIST
104279: PUSH
104280: LD_VAR 0 2
104284: PUSH
104285: LD_INT 9
104287: MINUS
104288: ARRAY
104289: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104290: LD_ADDR_OWVAR 45
104294: PUSH
104295: LD_INT 11
104297: PUSH
104298: LD_INT 15
104300: PUSH
104301: LD_INT 12
104303: PUSH
104304: LD_INT 15
104306: PUSH
104307: EMPTY
104308: LIST
104309: LIST
104310: LIST
104311: LIST
104312: PUSH
104313: LD_VAR 0 2
104317: PUSH
104318: LD_INT 9
104320: MINUS
104321: ARRAY
104322: ST_TO_ADDR
// end ; 14 :
104323: GO 104742
104325: LD_INT 14
104327: DOUBLE
104328: EQUAL
104329: IFTRUE 104333
104331: GO 104344
104333: POP
// bc_type := b_workshop ; 15 :
104334: LD_ADDR_OWVAR 42
104338: PUSH
104339: LD_INT 2
104341: ST_TO_ADDR
104342: GO 104742
104344: LD_INT 15
104346: DOUBLE
104347: EQUAL
104348: IFTRUE 104352
104350: GO 104363
104352: POP
// bc_type := b_factory ; 16 :
104353: LD_ADDR_OWVAR 42
104357: PUSH
104358: LD_INT 3
104360: ST_TO_ADDR
104361: GO 104742
104363: LD_INT 16
104365: DOUBLE
104366: EQUAL
104367: IFTRUE 104371
104369: GO 104382
104371: POP
// bc_type := b_ext_gun ; 17 :
104372: LD_ADDR_OWVAR 42
104376: PUSH
104377: LD_INT 17
104379: ST_TO_ADDR
104380: GO 104742
104382: LD_INT 17
104384: DOUBLE
104385: EQUAL
104386: IFTRUE 104390
104388: GO 104418
104390: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
104391: LD_ADDR_OWVAR 42
104395: PUSH
104396: LD_INT 19
104398: PUSH
104399: LD_INT 23
104401: PUSH
104402: LD_INT 19
104404: PUSH
104405: EMPTY
104406: LIST
104407: LIST
104408: LIST
104409: PUSH
104410: LD_VAR 0 1
104414: ARRAY
104415: ST_TO_ADDR
104416: GO 104742
104418: LD_INT 18
104420: DOUBLE
104421: EQUAL
104422: IFTRUE 104426
104424: GO 104437
104426: POP
// bc_type := b_ext_radar ; 19 :
104427: LD_ADDR_OWVAR 42
104431: PUSH
104432: LD_INT 20
104434: ST_TO_ADDR
104435: GO 104742
104437: LD_INT 19
104439: DOUBLE
104440: EQUAL
104441: IFTRUE 104445
104443: GO 104456
104445: POP
// bc_type := b_ext_radio ; 20 :
104446: LD_ADDR_OWVAR 42
104450: PUSH
104451: LD_INT 22
104453: ST_TO_ADDR
104454: GO 104742
104456: LD_INT 20
104458: DOUBLE
104459: EQUAL
104460: IFTRUE 104464
104462: GO 104475
104464: POP
// bc_type := b_ext_siberium ; 21 :
104465: LD_ADDR_OWVAR 42
104469: PUSH
104470: LD_INT 21
104472: ST_TO_ADDR
104473: GO 104742
104475: LD_INT 21
104477: DOUBLE
104478: EQUAL
104479: IFTRUE 104483
104481: GO 104494
104483: POP
// bc_type := b_ext_computer ; 22 :
104484: LD_ADDR_OWVAR 42
104488: PUSH
104489: LD_INT 24
104491: ST_TO_ADDR
104492: GO 104742
104494: LD_INT 22
104496: DOUBLE
104497: EQUAL
104498: IFTRUE 104502
104500: GO 104513
104502: POP
// bc_type := b_ext_track ; 23 :
104503: LD_ADDR_OWVAR 42
104507: PUSH
104508: LD_INT 16
104510: ST_TO_ADDR
104511: GO 104742
104513: LD_INT 23
104515: DOUBLE
104516: EQUAL
104517: IFTRUE 104521
104519: GO 104532
104521: POP
// bc_type := b_ext_laser ; 24 :
104522: LD_ADDR_OWVAR 42
104526: PUSH
104527: LD_INT 25
104529: ST_TO_ADDR
104530: GO 104742
104532: LD_INT 24
104534: DOUBLE
104535: EQUAL
104536: IFTRUE 104540
104538: GO 104551
104540: POP
// bc_type := b_control_tower ; 25 :
104541: LD_ADDR_OWVAR 42
104545: PUSH
104546: LD_INT 36
104548: ST_TO_ADDR
104549: GO 104742
104551: LD_INT 25
104553: DOUBLE
104554: EQUAL
104555: IFTRUE 104559
104557: GO 104570
104559: POP
// bc_type := b_breastwork ; 26 :
104560: LD_ADDR_OWVAR 42
104564: PUSH
104565: LD_INT 31
104567: ST_TO_ADDR
104568: GO 104742
104570: LD_INT 26
104572: DOUBLE
104573: EQUAL
104574: IFTRUE 104578
104576: GO 104589
104578: POP
// bc_type := b_bunker ; 27 :
104579: LD_ADDR_OWVAR 42
104583: PUSH
104584: LD_INT 32
104586: ST_TO_ADDR
104587: GO 104742
104589: LD_INT 27
104591: DOUBLE
104592: EQUAL
104593: IFTRUE 104597
104595: GO 104608
104597: POP
// bc_type := b_turret ; 28 :
104598: LD_ADDR_OWVAR 42
104602: PUSH
104603: LD_INT 33
104605: ST_TO_ADDR
104606: GO 104742
104608: LD_INT 28
104610: DOUBLE
104611: EQUAL
104612: IFTRUE 104616
104614: GO 104627
104616: POP
// bc_type := b_armoury ; 29 :
104617: LD_ADDR_OWVAR 42
104621: PUSH
104622: LD_INT 4
104624: ST_TO_ADDR
104625: GO 104742
104627: LD_INT 29
104629: DOUBLE
104630: EQUAL
104631: IFTRUE 104635
104633: GO 104646
104635: POP
// bc_type := b_barracks ; 30 :
104636: LD_ADDR_OWVAR 42
104640: PUSH
104641: LD_INT 5
104643: ST_TO_ADDR
104644: GO 104742
104646: LD_INT 30
104648: DOUBLE
104649: EQUAL
104650: IFTRUE 104654
104652: GO 104665
104654: POP
// bc_type := b_solar_power ; 31 :
104655: LD_ADDR_OWVAR 42
104659: PUSH
104660: LD_INT 27
104662: ST_TO_ADDR
104663: GO 104742
104665: LD_INT 31
104667: DOUBLE
104668: EQUAL
104669: IFTRUE 104673
104671: GO 104684
104673: POP
// bc_type := b_oil_power ; 32 :
104674: LD_ADDR_OWVAR 42
104678: PUSH
104679: LD_INT 26
104681: ST_TO_ADDR
104682: GO 104742
104684: LD_INT 32
104686: DOUBLE
104687: EQUAL
104688: IFTRUE 104692
104690: GO 104703
104692: POP
// bc_type := b_siberite_power ; 33 :
104693: LD_ADDR_OWVAR 42
104697: PUSH
104698: LD_INT 28
104700: ST_TO_ADDR
104701: GO 104742
104703: LD_INT 33
104705: DOUBLE
104706: EQUAL
104707: IFTRUE 104711
104709: GO 104722
104711: POP
// bc_type := b_oil_mine ; 34 :
104712: LD_ADDR_OWVAR 42
104716: PUSH
104717: LD_INT 29
104719: ST_TO_ADDR
104720: GO 104742
104722: LD_INT 34
104724: DOUBLE
104725: EQUAL
104726: IFTRUE 104730
104728: GO 104741
104730: POP
// bc_type := b_siberite_mine ; end ;
104731: LD_ADDR_OWVAR 42
104735: PUSH
104736: LD_INT 30
104738: ST_TO_ADDR
104739: GO 104742
104741: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
104742: LD_ADDR_VAR 0 8
104746: PUSH
104747: LD_VAR 0 5
104751: PPUSH
104752: LD_VAR 0 6
104756: PPUSH
104757: LD_VAR 0 3
104761: PPUSH
104762: CALL_OW 47
104766: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
104767: LD_OWVAR 42
104771: PUSH
104772: LD_INT 32
104774: PUSH
104775: LD_INT 33
104777: PUSH
104778: EMPTY
104779: LIST
104780: LIST
104781: IN
104782: IFFALSE 104798
// PlaceWeaponTurret ( b , weapon ) ;
104784: LD_VAR 0 8
104788: PPUSH
104789: LD_VAR 0 4
104793: PPUSH
104794: CALL_OW 431
// end ;
104798: LD_VAR 0 7
104802: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
104803: LD_INT 0
104805: PPUSH
104806: PPUSH
104807: PPUSH
104808: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104809: LD_ADDR_VAR 0 4
104813: PUSH
104814: LD_INT 22
104816: PUSH
104817: LD_OWVAR 2
104821: PUSH
104822: EMPTY
104823: LIST
104824: LIST
104825: PUSH
104826: LD_INT 2
104828: PUSH
104829: LD_INT 30
104831: PUSH
104832: LD_INT 0
104834: PUSH
104835: EMPTY
104836: LIST
104837: LIST
104838: PUSH
104839: LD_INT 30
104841: PUSH
104842: LD_INT 1
104844: PUSH
104845: EMPTY
104846: LIST
104847: LIST
104848: PUSH
104849: EMPTY
104850: LIST
104851: LIST
104852: LIST
104853: PUSH
104854: EMPTY
104855: LIST
104856: LIST
104857: PPUSH
104858: CALL_OW 69
104862: ST_TO_ADDR
// if not tmp then
104863: LD_VAR 0 4
104867: NOT
104868: IFFALSE 104872
// exit ;
104870: GO 104931
// for i in tmp do
104872: LD_ADDR_VAR 0 2
104876: PUSH
104877: LD_VAR 0 4
104881: PUSH
104882: FOR_IN
104883: IFFALSE 104929
// for j = 1 to 3 do
104885: LD_ADDR_VAR 0 3
104889: PUSH
104890: DOUBLE
104891: LD_INT 1
104893: DEC
104894: ST_TO_ADDR
104895: LD_INT 3
104897: PUSH
104898: FOR_TO
104899: IFFALSE 104925
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
104901: LD_VAR 0 2
104905: PPUSH
104906: CALL_OW 274
104910: PPUSH
104911: LD_VAR 0 3
104915: PPUSH
104916: LD_INT 99999
104918: PPUSH
104919: CALL_OW 277
104923: GO 104898
104925: POP
104926: POP
104927: GO 104882
104929: POP
104930: POP
// end ;
104931: LD_VAR 0 1
104935: RET
// export function hHackSetLevel10 ; var i , j ; begin
104936: LD_INT 0
104938: PPUSH
104939: PPUSH
104940: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104941: LD_ADDR_VAR 0 2
104945: PUSH
104946: LD_INT 21
104948: PUSH
104949: LD_INT 1
104951: PUSH
104952: EMPTY
104953: LIST
104954: LIST
104955: PPUSH
104956: CALL_OW 69
104960: PUSH
104961: FOR_IN
104962: IFFALSE 105014
// if IsSelected ( i ) then
104964: LD_VAR 0 2
104968: PPUSH
104969: CALL_OW 306
104973: IFFALSE 105012
// begin for j := 1 to 4 do
104975: LD_ADDR_VAR 0 3
104979: PUSH
104980: DOUBLE
104981: LD_INT 1
104983: DEC
104984: ST_TO_ADDR
104985: LD_INT 4
104987: PUSH
104988: FOR_TO
104989: IFFALSE 105010
// SetSkill ( i , j , 10 ) ;
104991: LD_VAR 0 2
104995: PPUSH
104996: LD_VAR 0 3
105000: PPUSH
105001: LD_INT 10
105003: PPUSH
105004: CALL_OW 237
105008: GO 104988
105010: POP
105011: POP
// end ;
105012: GO 104961
105014: POP
105015: POP
// end ;
105016: LD_VAR 0 1
105020: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105021: LD_INT 0
105023: PPUSH
105024: PPUSH
105025: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105026: LD_ADDR_VAR 0 2
105030: PUSH
105031: LD_INT 22
105033: PUSH
105034: LD_OWVAR 2
105038: PUSH
105039: EMPTY
105040: LIST
105041: LIST
105042: PUSH
105043: LD_INT 21
105045: PUSH
105046: LD_INT 1
105048: PUSH
105049: EMPTY
105050: LIST
105051: LIST
105052: PUSH
105053: EMPTY
105054: LIST
105055: LIST
105056: PPUSH
105057: CALL_OW 69
105061: PUSH
105062: FOR_IN
105063: IFFALSE 105104
// begin for j := 1 to 4 do
105065: LD_ADDR_VAR 0 3
105069: PUSH
105070: DOUBLE
105071: LD_INT 1
105073: DEC
105074: ST_TO_ADDR
105075: LD_INT 4
105077: PUSH
105078: FOR_TO
105079: IFFALSE 105100
// SetSkill ( i , j , 10 ) ;
105081: LD_VAR 0 2
105085: PPUSH
105086: LD_VAR 0 3
105090: PPUSH
105091: LD_INT 10
105093: PPUSH
105094: CALL_OW 237
105098: GO 105078
105100: POP
105101: POP
// end ;
105102: GO 105062
105104: POP
105105: POP
// end ;
105106: LD_VAR 0 1
105110: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105111: LD_INT 0
105113: PPUSH
// uc_side := your_side ;
105114: LD_ADDR_OWVAR 20
105118: PUSH
105119: LD_OWVAR 2
105123: ST_TO_ADDR
// uc_nation := nation ;
105124: LD_ADDR_OWVAR 21
105128: PUSH
105129: LD_VAR 0 1
105133: ST_TO_ADDR
// InitHc ;
105134: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105138: LD_INT 0
105140: PPUSH
105141: LD_VAR 0 2
105145: PPUSH
105146: LD_VAR 0 3
105150: PPUSH
105151: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105155: LD_VAR 0 4
105159: PPUSH
105160: LD_VAR 0 5
105164: PPUSH
105165: CALL_OW 428
105169: PUSH
105170: LD_INT 0
105172: EQUAL
105173: IFFALSE 105197
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105175: CALL_OW 44
105179: PPUSH
105180: LD_VAR 0 4
105184: PPUSH
105185: LD_VAR 0 5
105189: PPUSH
105190: LD_INT 1
105192: PPUSH
105193: CALL_OW 48
// end ;
105197: LD_VAR 0 6
105201: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105202: LD_INT 0
105204: PPUSH
105205: PPUSH
// uc_side := your_side ;
105206: LD_ADDR_OWVAR 20
105210: PUSH
105211: LD_OWVAR 2
105215: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105216: LD_VAR 0 1
105220: PUSH
105221: LD_INT 1
105223: PUSH
105224: LD_INT 2
105226: PUSH
105227: LD_INT 3
105229: PUSH
105230: LD_INT 4
105232: PUSH
105233: LD_INT 5
105235: PUSH
105236: EMPTY
105237: LIST
105238: LIST
105239: LIST
105240: LIST
105241: LIST
105242: IN
105243: IFFALSE 105255
// uc_nation := nation_american else
105245: LD_ADDR_OWVAR 21
105249: PUSH
105250: LD_INT 1
105252: ST_TO_ADDR
105253: GO 105298
// if chassis in [ 11 , 12 , 13 , 14 ] then
105255: LD_VAR 0 1
105259: PUSH
105260: LD_INT 11
105262: PUSH
105263: LD_INT 12
105265: PUSH
105266: LD_INT 13
105268: PUSH
105269: LD_INT 14
105271: PUSH
105272: EMPTY
105273: LIST
105274: LIST
105275: LIST
105276: LIST
105277: IN
105278: IFFALSE 105290
// uc_nation := nation_arabian else
105280: LD_ADDR_OWVAR 21
105284: PUSH
105285: LD_INT 2
105287: ST_TO_ADDR
105288: GO 105298
// uc_nation := nation_russian ;
105290: LD_ADDR_OWVAR 21
105294: PUSH
105295: LD_INT 3
105297: ST_TO_ADDR
// vc_chassis := chassis ;
105298: LD_ADDR_OWVAR 37
105302: PUSH
105303: LD_VAR 0 1
105307: ST_TO_ADDR
// vc_engine := engine ;
105308: LD_ADDR_OWVAR 39
105312: PUSH
105313: LD_VAR 0 2
105317: ST_TO_ADDR
// vc_control := control ;
105318: LD_ADDR_OWVAR 38
105322: PUSH
105323: LD_VAR 0 3
105327: ST_TO_ADDR
// vc_weapon := weapon ;
105328: LD_ADDR_OWVAR 40
105332: PUSH
105333: LD_VAR 0 4
105337: ST_TO_ADDR
// un := CreateVehicle ;
105338: LD_ADDR_VAR 0 8
105342: PUSH
105343: CALL_OW 45
105347: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105348: LD_VAR 0 8
105352: PPUSH
105353: LD_INT 0
105355: PPUSH
105356: LD_INT 5
105358: PPUSH
105359: CALL_OW 12
105363: PPUSH
105364: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105368: LD_VAR 0 8
105372: PPUSH
105373: LD_VAR 0 5
105377: PPUSH
105378: LD_VAR 0 6
105382: PPUSH
105383: LD_INT 1
105385: PPUSH
105386: CALL_OW 48
// end ;
105390: LD_VAR 0 7
105394: RET
// export hInvincible ; every 1 do
105395: GO 105397
105397: DISABLE
// hInvincible := [ ] ;
105398: LD_ADDR_EXP 153
105402: PUSH
105403: EMPTY
105404: ST_TO_ADDR
105405: END
// every 10 do var i ;
105406: GO 105408
105408: DISABLE
105409: LD_INT 0
105411: PPUSH
// begin enable ;
105412: ENABLE
// if not hInvincible then
105413: LD_EXP 153
105417: NOT
105418: IFFALSE 105422
// exit ;
105420: GO 105466
// for i in hInvincible do
105422: LD_ADDR_VAR 0 1
105426: PUSH
105427: LD_EXP 153
105431: PUSH
105432: FOR_IN
105433: IFFALSE 105464
// if GetLives ( i ) < 1000 then
105435: LD_VAR 0 1
105439: PPUSH
105440: CALL_OW 256
105444: PUSH
105445: LD_INT 1000
105447: LESS
105448: IFFALSE 105462
// SetLives ( i , 1000 ) ;
105450: LD_VAR 0 1
105454: PPUSH
105455: LD_INT 1000
105457: PPUSH
105458: CALL_OW 234
105462: GO 105432
105464: POP
105465: POP
// end ;
105466: PPOPN 1
105468: END
// export function hHackInvincible ; var i ; begin
105469: LD_INT 0
105471: PPUSH
105472: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
105473: LD_ADDR_VAR 0 2
105477: PUSH
105478: LD_INT 2
105480: PUSH
105481: LD_INT 21
105483: PUSH
105484: LD_INT 1
105486: PUSH
105487: EMPTY
105488: LIST
105489: LIST
105490: PUSH
105491: LD_INT 21
105493: PUSH
105494: LD_INT 2
105496: PUSH
105497: EMPTY
105498: LIST
105499: LIST
105500: PUSH
105501: EMPTY
105502: LIST
105503: LIST
105504: LIST
105505: PPUSH
105506: CALL_OW 69
105510: PUSH
105511: FOR_IN
105512: IFFALSE 105573
// if IsSelected ( i ) then
105514: LD_VAR 0 2
105518: PPUSH
105519: CALL_OW 306
105523: IFFALSE 105571
// begin if i in hInvincible then
105525: LD_VAR 0 2
105529: PUSH
105530: LD_EXP 153
105534: IN
105535: IFFALSE 105555
// hInvincible := hInvincible diff i else
105537: LD_ADDR_EXP 153
105541: PUSH
105542: LD_EXP 153
105546: PUSH
105547: LD_VAR 0 2
105551: DIFF
105552: ST_TO_ADDR
105553: GO 105571
// hInvincible := hInvincible union i ;
105555: LD_ADDR_EXP 153
105559: PUSH
105560: LD_EXP 153
105564: PUSH
105565: LD_VAR 0 2
105569: UNION
105570: ST_TO_ADDR
// end ;
105571: GO 105511
105573: POP
105574: POP
// end ;
105575: LD_VAR 0 1
105579: RET
// export function hHackInvisible ; var i , j ; begin
105580: LD_INT 0
105582: PPUSH
105583: PPUSH
105584: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105585: LD_ADDR_VAR 0 2
105589: PUSH
105590: LD_INT 21
105592: PUSH
105593: LD_INT 1
105595: PUSH
105596: EMPTY
105597: LIST
105598: LIST
105599: PPUSH
105600: CALL_OW 69
105604: PUSH
105605: FOR_IN
105606: IFFALSE 105630
// if IsSelected ( i ) then
105608: LD_VAR 0 2
105612: PPUSH
105613: CALL_OW 306
105617: IFFALSE 105628
// ComForceInvisible ( i ) ;
105619: LD_VAR 0 2
105623: PPUSH
105624: CALL_OW 496
105628: GO 105605
105630: POP
105631: POP
// end ;
105632: LD_VAR 0 1
105636: RET
// export function hHackChangeYourSide ; begin
105637: LD_INT 0
105639: PPUSH
// if your_side = 8 then
105640: LD_OWVAR 2
105644: PUSH
105645: LD_INT 8
105647: EQUAL
105648: IFFALSE 105660
// your_side := 0 else
105650: LD_ADDR_OWVAR 2
105654: PUSH
105655: LD_INT 0
105657: ST_TO_ADDR
105658: GO 105674
// your_side := your_side + 1 ;
105660: LD_ADDR_OWVAR 2
105664: PUSH
105665: LD_OWVAR 2
105669: PUSH
105670: LD_INT 1
105672: PLUS
105673: ST_TO_ADDR
// end ;
105674: LD_VAR 0 1
105678: RET
// export function hHackChangeUnitSide ; var i , j ; begin
105679: LD_INT 0
105681: PPUSH
105682: PPUSH
105683: PPUSH
// for i in all_units do
105684: LD_ADDR_VAR 0 2
105688: PUSH
105689: LD_OWVAR 3
105693: PUSH
105694: FOR_IN
105695: IFFALSE 105773
// if IsSelected ( i ) then
105697: LD_VAR 0 2
105701: PPUSH
105702: CALL_OW 306
105706: IFFALSE 105771
// begin j := GetSide ( i ) ;
105708: LD_ADDR_VAR 0 3
105712: PUSH
105713: LD_VAR 0 2
105717: PPUSH
105718: CALL_OW 255
105722: ST_TO_ADDR
// if j = 8 then
105723: LD_VAR 0 3
105727: PUSH
105728: LD_INT 8
105730: EQUAL
105731: IFFALSE 105743
// j := 0 else
105733: LD_ADDR_VAR 0 3
105737: PUSH
105738: LD_INT 0
105740: ST_TO_ADDR
105741: GO 105757
// j := j + 1 ;
105743: LD_ADDR_VAR 0 3
105747: PUSH
105748: LD_VAR 0 3
105752: PUSH
105753: LD_INT 1
105755: PLUS
105756: ST_TO_ADDR
// SetSide ( i , j ) ;
105757: LD_VAR 0 2
105761: PPUSH
105762: LD_VAR 0 3
105766: PPUSH
105767: CALL_OW 235
// end ;
105771: GO 105694
105773: POP
105774: POP
// end ;
105775: LD_VAR 0 1
105779: RET
// export function hHackFog ; begin
105780: LD_INT 0
105782: PPUSH
// FogOff ( true ) ;
105783: LD_INT 1
105785: PPUSH
105786: CALL_OW 344
// end ;
105790: LD_VAR 0 1
105794: RET
// export function hHackTeleport ( unit , x , y ) ; begin
105795: LD_INT 0
105797: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
105798: LD_VAR 0 1
105802: PPUSH
105803: LD_VAR 0 2
105807: PPUSH
105808: LD_VAR 0 3
105812: PPUSH
105813: LD_INT 1
105815: PPUSH
105816: LD_INT 1
105818: PPUSH
105819: CALL_OW 483
// CenterOnXY ( x , y ) ;
105823: LD_VAR 0 2
105827: PPUSH
105828: LD_VAR 0 3
105832: PPUSH
105833: CALL_OW 84
// end ;
105837: LD_VAR 0 4
105841: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
105842: LD_INT 0
105844: PPUSH
105845: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
105846: LD_VAR 0 1
105850: NOT
105851: PUSH
105852: LD_VAR 0 2
105856: PPUSH
105857: LD_VAR 0 3
105861: PPUSH
105862: CALL_OW 488
105866: NOT
105867: OR
105868: PUSH
105869: LD_VAR 0 1
105873: PPUSH
105874: CALL_OW 266
105878: PUSH
105879: LD_INT 3
105881: NONEQUAL
105882: PUSH
105883: LD_VAR 0 1
105887: PPUSH
105888: CALL_OW 247
105892: PUSH
105893: LD_INT 1
105895: EQUAL
105896: NOT
105897: AND
105898: OR
105899: IFFALSE 105903
// exit ;
105901: GO 106052
// if GetType ( factory ) = unit_human then
105903: LD_VAR 0 1
105907: PPUSH
105908: CALL_OW 247
105912: PUSH
105913: LD_INT 1
105915: EQUAL
105916: IFFALSE 105933
// factory := IsInUnit ( factory ) ;
105918: LD_ADDR_VAR 0 1
105922: PUSH
105923: LD_VAR 0 1
105927: PPUSH
105928: CALL_OW 310
105932: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
105933: LD_VAR 0 1
105937: PPUSH
105938: CALL_OW 266
105942: PUSH
105943: LD_INT 3
105945: NONEQUAL
105946: IFFALSE 105950
// exit ;
105948: GO 106052
// if HexInfo ( x , y ) = factory then
105950: LD_VAR 0 2
105954: PPUSH
105955: LD_VAR 0 3
105959: PPUSH
105960: CALL_OW 428
105964: PUSH
105965: LD_VAR 0 1
105969: EQUAL
105970: IFFALSE 105997
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
105972: LD_ADDR_EXP 154
105976: PUSH
105977: LD_EXP 154
105981: PPUSH
105982: LD_VAR 0 1
105986: PPUSH
105987: LD_INT 0
105989: PPUSH
105990: CALL_OW 1
105994: ST_TO_ADDR
105995: GO 106048
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
105997: LD_ADDR_EXP 154
106001: PUSH
106002: LD_EXP 154
106006: PPUSH
106007: LD_VAR 0 1
106011: PPUSH
106012: LD_VAR 0 1
106016: PPUSH
106017: CALL_OW 255
106021: PUSH
106022: LD_VAR 0 1
106026: PUSH
106027: LD_VAR 0 2
106031: PUSH
106032: LD_VAR 0 3
106036: PUSH
106037: EMPTY
106038: LIST
106039: LIST
106040: LIST
106041: LIST
106042: PPUSH
106043: CALL_OW 1
106047: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106048: CALL 106057 0 0
// end ;
106052: LD_VAR 0 4
106056: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106057: LD_INT 0
106059: PPUSH
106060: PPUSH
106061: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106062: LD_STRING resetFactoryWaypoint();
106064: PPUSH
106065: CALL_OW 559
// if factoryWaypoints then
106069: LD_EXP 154
106073: IFFALSE 106199
// begin list := PrepareArray ( factoryWaypoints ) ;
106075: LD_ADDR_VAR 0 3
106079: PUSH
106080: LD_EXP 154
106084: PPUSH
106085: CALL 90579 0 1
106089: ST_TO_ADDR
// for i := 1 to list do
106090: LD_ADDR_VAR 0 2
106094: PUSH
106095: DOUBLE
106096: LD_INT 1
106098: DEC
106099: ST_TO_ADDR
106100: LD_VAR 0 3
106104: PUSH
106105: FOR_TO
106106: IFFALSE 106197
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106108: LD_STRING setFactoryWaypointXY(
106110: PUSH
106111: LD_VAR 0 3
106115: PUSH
106116: LD_VAR 0 2
106120: ARRAY
106121: PUSH
106122: LD_INT 1
106124: ARRAY
106125: STR
106126: PUSH
106127: LD_STRING ,
106129: STR
106130: PUSH
106131: LD_VAR 0 3
106135: PUSH
106136: LD_VAR 0 2
106140: ARRAY
106141: PUSH
106142: LD_INT 2
106144: ARRAY
106145: STR
106146: PUSH
106147: LD_STRING ,
106149: STR
106150: PUSH
106151: LD_VAR 0 3
106155: PUSH
106156: LD_VAR 0 2
106160: ARRAY
106161: PUSH
106162: LD_INT 3
106164: ARRAY
106165: STR
106166: PUSH
106167: LD_STRING ,
106169: STR
106170: PUSH
106171: LD_VAR 0 3
106175: PUSH
106176: LD_VAR 0 2
106180: ARRAY
106181: PUSH
106182: LD_INT 4
106184: ARRAY
106185: STR
106186: PUSH
106187: LD_STRING )
106189: STR
106190: PPUSH
106191: CALL_OW 559
106195: GO 106105
106197: POP
106198: POP
// end ; end ;
106199: LD_VAR 0 1
106203: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
106204: LD_INT 0
106206: PPUSH
// if HexInfo ( x , y ) = warehouse then
106207: LD_VAR 0 2
106211: PPUSH
106212: LD_VAR 0 3
106216: PPUSH
106217: CALL_OW 428
106221: PUSH
106222: LD_VAR 0 1
106226: EQUAL
106227: IFFALSE 106254
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
106229: LD_ADDR_EXP 155
106233: PUSH
106234: LD_EXP 155
106238: PPUSH
106239: LD_VAR 0 1
106243: PPUSH
106244: LD_INT 0
106246: PPUSH
106247: CALL_OW 1
106251: ST_TO_ADDR
106252: GO 106305
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
106254: LD_ADDR_EXP 155
106258: PUSH
106259: LD_EXP 155
106263: PPUSH
106264: LD_VAR 0 1
106268: PPUSH
106269: LD_VAR 0 1
106273: PPUSH
106274: CALL_OW 255
106278: PUSH
106279: LD_VAR 0 1
106283: PUSH
106284: LD_VAR 0 2
106288: PUSH
106289: LD_VAR 0 3
106293: PUSH
106294: EMPTY
106295: LIST
106296: LIST
106297: LIST
106298: LIST
106299: PPUSH
106300: CALL_OW 1
106304: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
106305: CALL 106314 0 0
// end ;
106309: LD_VAR 0 4
106313: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
106314: LD_INT 0
106316: PPUSH
106317: PPUSH
106318: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
106319: LD_STRING resetWarehouseGatheringPoints();
106321: PPUSH
106322: CALL_OW 559
// if warehouseGatheringPoints then
106326: LD_EXP 155
106330: IFFALSE 106456
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
106332: LD_ADDR_VAR 0 3
106336: PUSH
106337: LD_EXP 155
106341: PPUSH
106342: CALL 90579 0 1
106346: ST_TO_ADDR
// for i := 1 to list do
106347: LD_ADDR_VAR 0 2
106351: PUSH
106352: DOUBLE
106353: LD_INT 1
106355: DEC
106356: ST_TO_ADDR
106357: LD_VAR 0 3
106361: PUSH
106362: FOR_TO
106363: IFFALSE 106454
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106365: LD_STRING setWarehouseGatheringPointXY(
106367: PUSH
106368: LD_VAR 0 3
106372: PUSH
106373: LD_VAR 0 2
106377: ARRAY
106378: PUSH
106379: LD_INT 1
106381: ARRAY
106382: STR
106383: PUSH
106384: LD_STRING ,
106386: STR
106387: PUSH
106388: LD_VAR 0 3
106392: PUSH
106393: LD_VAR 0 2
106397: ARRAY
106398: PUSH
106399: LD_INT 2
106401: ARRAY
106402: STR
106403: PUSH
106404: LD_STRING ,
106406: STR
106407: PUSH
106408: LD_VAR 0 3
106412: PUSH
106413: LD_VAR 0 2
106417: ARRAY
106418: PUSH
106419: LD_INT 3
106421: ARRAY
106422: STR
106423: PUSH
106424: LD_STRING ,
106426: STR
106427: PUSH
106428: LD_VAR 0 3
106432: PUSH
106433: LD_VAR 0 2
106437: ARRAY
106438: PUSH
106439: LD_INT 4
106441: ARRAY
106442: STR
106443: PUSH
106444: LD_STRING )
106446: STR
106447: PPUSH
106448: CALL_OW 559
106452: GO 106362
106454: POP
106455: POP
// end ; end ;
106456: LD_VAR 0 1
106460: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
106461: LD_EXP 155
106465: IFFALSE 107150
106467: GO 106469
106469: DISABLE
106470: LD_INT 0
106472: PPUSH
106473: PPUSH
106474: PPUSH
106475: PPUSH
106476: PPUSH
106477: PPUSH
106478: PPUSH
106479: PPUSH
106480: PPUSH
// begin enable ;
106481: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
106482: LD_ADDR_VAR 0 3
106486: PUSH
106487: LD_EXP 155
106491: PPUSH
106492: CALL 90579 0 1
106496: ST_TO_ADDR
// if not list then
106497: LD_VAR 0 3
106501: NOT
106502: IFFALSE 106506
// exit ;
106504: GO 107150
// for i := 1 to list do
106506: LD_ADDR_VAR 0 1
106510: PUSH
106511: DOUBLE
106512: LD_INT 1
106514: DEC
106515: ST_TO_ADDR
106516: LD_VAR 0 3
106520: PUSH
106521: FOR_TO
106522: IFFALSE 107148
// begin depot := list [ i ] [ 2 ] ;
106524: LD_ADDR_VAR 0 8
106528: PUSH
106529: LD_VAR 0 3
106533: PUSH
106534: LD_VAR 0 1
106538: ARRAY
106539: PUSH
106540: LD_INT 2
106542: ARRAY
106543: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
106544: LD_ADDR_VAR 0 5
106548: PUSH
106549: LD_VAR 0 3
106553: PUSH
106554: LD_VAR 0 1
106558: ARRAY
106559: PUSH
106560: LD_INT 1
106562: ARRAY
106563: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
106564: LD_VAR 0 8
106568: PPUSH
106569: CALL_OW 301
106573: PUSH
106574: LD_VAR 0 5
106578: PUSH
106579: LD_VAR 0 8
106583: PPUSH
106584: CALL_OW 255
106588: NONEQUAL
106589: OR
106590: IFFALSE 106619
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
106592: LD_ADDR_EXP 155
106596: PUSH
106597: LD_EXP 155
106601: PPUSH
106602: LD_VAR 0 8
106606: PPUSH
106607: LD_INT 0
106609: PPUSH
106610: CALL_OW 1
106614: ST_TO_ADDR
// exit ;
106615: POP
106616: POP
106617: GO 107150
// end ; x := list [ i ] [ 3 ] ;
106619: LD_ADDR_VAR 0 6
106623: PUSH
106624: LD_VAR 0 3
106628: PUSH
106629: LD_VAR 0 1
106633: ARRAY
106634: PUSH
106635: LD_INT 3
106637: ARRAY
106638: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
106639: LD_ADDR_VAR 0 7
106643: PUSH
106644: LD_VAR 0 3
106648: PUSH
106649: LD_VAR 0 1
106653: ARRAY
106654: PUSH
106655: LD_INT 4
106657: ARRAY
106658: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
106659: LD_ADDR_VAR 0 9
106663: PUSH
106664: LD_VAR 0 6
106668: PPUSH
106669: LD_VAR 0 7
106673: PPUSH
106674: LD_INT 16
106676: PPUSH
106677: CALL 89167 0 3
106681: ST_TO_ADDR
// if not cratesNearbyPoint then
106682: LD_VAR 0 9
106686: NOT
106687: IFFALSE 106693
// exit ;
106689: POP
106690: POP
106691: GO 107150
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
106693: LD_ADDR_VAR 0 4
106697: PUSH
106698: LD_INT 22
106700: PUSH
106701: LD_VAR 0 5
106705: PUSH
106706: EMPTY
106707: LIST
106708: LIST
106709: PUSH
106710: LD_INT 3
106712: PUSH
106713: LD_INT 60
106715: PUSH
106716: EMPTY
106717: LIST
106718: PUSH
106719: EMPTY
106720: LIST
106721: LIST
106722: PUSH
106723: LD_INT 91
106725: PUSH
106726: LD_VAR 0 8
106730: PUSH
106731: LD_INT 6
106733: PUSH
106734: EMPTY
106735: LIST
106736: LIST
106737: LIST
106738: PUSH
106739: LD_INT 2
106741: PUSH
106742: LD_INT 25
106744: PUSH
106745: LD_INT 2
106747: PUSH
106748: EMPTY
106749: LIST
106750: LIST
106751: PUSH
106752: LD_INT 25
106754: PUSH
106755: LD_INT 16
106757: PUSH
106758: EMPTY
106759: LIST
106760: LIST
106761: PUSH
106762: EMPTY
106763: LIST
106764: LIST
106765: LIST
106766: PUSH
106767: EMPTY
106768: LIST
106769: LIST
106770: LIST
106771: LIST
106772: PPUSH
106773: CALL_OW 69
106777: PUSH
106778: LD_VAR 0 8
106782: PPUSH
106783: CALL_OW 313
106787: PPUSH
106788: LD_INT 3
106790: PUSH
106791: LD_INT 60
106793: PUSH
106794: EMPTY
106795: LIST
106796: PUSH
106797: EMPTY
106798: LIST
106799: LIST
106800: PUSH
106801: LD_INT 2
106803: PUSH
106804: LD_INT 25
106806: PUSH
106807: LD_INT 2
106809: PUSH
106810: EMPTY
106811: LIST
106812: LIST
106813: PUSH
106814: LD_INT 25
106816: PUSH
106817: LD_INT 16
106819: PUSH
106820: EMPTY
106821: LIST
106822: LIST
106823: PUSH
106824: EMPTY
106825: LIST
106826: LIST
106827: LIST
106828: PUSH
106829: EMPTY
106830: LIST
106831: LIST
106832: PPUSH
106833: CALL_OW 72
106837: UNION
106838: ST_TO_ADDR
// if tmp then
106839: LD_VAR 0 4
106843: IFFALSE 106923
// begin tmp := ShrinkArray ( tmp , 3 ) ;
106845: LD_ADDR_VAR 0 4
106849: PUSH
106850: LD_VAR 0 4
106854: PPUSH
106855: LD_INT 3
106857: PPUSH
106858: CALL 87136 0 2
106862: ST_TO_ADDR
// for j in tmp do
106863: LD_ADDR_VAR 0 2
106867: PUSH
106868: LD_VAR 0 4
106872: PUSH
106873: FOR_IN
106874: IFFALSE 106917
// begin if IsInUnit ( j ) then
106876: LD_VAR 0 2
106880: PPUSH
106881: CALL_OW 310
106885: IFFALSE 106896
// ComExit ( j ) ;
106887: LD_VAR 0 2
106891: PPUSH
106892: CALL 87219 0 1
// AddComCollect ( j , x , y ) ;
106896: LD_VAR 0 2
106900: PPUSH
106901: LD_VAR 0 6
106905: PPUSH
106906: LD_VAR 0 7
106910: PPUSH
106911: CALL_OW 177
// end ;
106915: GO 106873
106917: POP
106918: POP
// exit ;
106919: POP
106920: POP
106921: GO 107150
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
106923: LD_ADDR_VAR 0 4
106927: PUSH
106928: LD_INT 22
106930: PUSH
106931: LD_VAR 0 5
106935: PUSH
106936: EMPTY
106937: LIST
106938: LIST
106939: PUSH
106940: LD_INT 91
106942: PUSH
106943: LD_VAR 0 8
106947: PUSH
106948: LD_INT 8
106950: PUSH
106951: EMPTY
106952: LIST
106953: LIST
106954: LIST
106955: PUSH
106956: LD_INT 2
106958: PUSH
106959: LD_INT 34
106961: PUSH
106962: LD_INT 12
106964: PUSH
106965: EMPTY
106966: LIST
106967: LIST
106968: PUSH
106969: LD_INT 34
106971: PUSH
106972: LD_INT 51
106974: PUSH
106975: EMPTY
106976: LIST
106977: LIST
106978: PUSH
106979: LD_INT 34
106981: PUSH
106982: LD_INT 32
106984: PUSH
106985: EMPTY
106986: LIST
106987: LIST
106988: PUSH
106989: LD_INT 34
106991: PUSH
106992: LD_INT 89
106994: PUSH
106995: EMPTY
106996: LIST
106997: LIST
106998: PUSH
106999: EMPTY
107000: LIST
107001: LIST
107002: LIST
107003: LIST
107004: LIST
107005: PUSH
107006: EMPTY
107007: LIST
107008: LIST
107009: LIST
107010: PPUSH
107011: CALL_OW 69
107015: ST_TO_ADDR
// if tmp then
107016: LD_VAR 0 4
107020: IFFALSE 107146
// begin for j in tmp do
107022: LD_ADDR_VAR 0 2
107026: PUSH
107027: LD_VAR 0 4
107031: PUSH
107032: FOR_IN
107033: IFFALSE 107144
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107035: LD_VAR 0 2
107039: PPUSH
107040: CALL_OW 262
107044: PUSH
107045: LD_INT 3
107047: EQUAL
107048: PUSH
107049: LD_VAR 0 2
107053: PPUSH
107054: CALL_OW 261
107058: PUSH
107059: LD_INT 20
107061: GREATER
107062: OR
107063: PUSH
107064: LD_VAR 0 2
107068: PPUSH
107069: CALL_OW 314
107073: NOT
107074: AND
107075: PUSH
107076: LD_VAR 0 2
107080: PPUSH
107081: CALL_OW 263
107085: PUSH
107086: LD_INT 1
107088: NONEQUAL
107089: PUSH
107090: LD_VAR 0 2
107094: PPUSH
107095: CALL_OW 311
107099: OR
107100: AND
107101: IFFALSE 107142
// begin ComCollect ( j , x , y ) ;
107103: LD_VAR 0 2
107107: PPUSH
107108: LD_VAR 0 6
107112: PPUSH
107113: LD_VAR 0 7
107117: PPUSH
107118: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107122: LD_VAR 0 2
107126: PPUSH
107127: LD_VAR 0 8
107131: PPUSH
107132: CALL_OW 172
// exit ;
107136: POP
107137: POP
107138: POP
107139: POP
107140: GO 107150
// end ;
107142: GO 107032
107144: POP
107145: POP
// end ; end ;
107146: GO 106521
107148: POP
107149: POP
// end ; end_of_file
107150: PPOPN 9
107152: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
107153: LD_INT 0
107155: PPUSH
107156: PPUSH
107157: PPUSH
107158: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107159: LD_VAR 0 1
107163: PPUSH
107164: CALL_OW 264
107168: PUSH
107169: LD_INT 91
107171: EQUAL
107172: IFFALSE 107244
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107174: LD_INT 68
107176: PPUSH
107177: LD_VAR 0 1
107181: PPUSH
107182: CALL_OW 255
107186: PPUSH
107187: CALL_OW 321
107191: PUSH
107192: LD_INT 2
107194: EQUAL
107195: IFFALSE 107207
// eff := 70 else
107197: LD_ADDR_VAR 0 4
107201: PUSH
107202: LD_INT 70
107204: ST_TO_ADDR
107205: GO 107215
// eff := 30 ;
107207: LD_ADDR_VAR 0 4
107211: PUSH
107212: LD_INT 30
107214: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107215: LD_VAR 0 1
107219: PPUSH
107220: CALL_OW 250
107224: PPUSH
107225: LD_VAR 0 1
107229: PPUSH
107230: CALL_OW 251
107234: PPUSH
107235: LD_VAR 0 4
107239: PPUSH
107240: CALL_OW 495
// end ; end ;
107244: LD_VAR 0 2
107248: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
107249: LD_INT 0
107251: PPUSH
// end ;
107252: LD_VAR 0 4
107256: RET
// export function SOS_Command ( cmd ) ; begin
107257: LD_INT 0
107259: PPUSH
// end ;
107260: LD_VAR 0 2
107264: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
107265: LD_INT 0
107267: PPUSH
// end ;
107268: LD_VAR 0 6
107272: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
107273: LD_INT 0
107275: PPUSH
107276: PPUSH
// if not vehicle or not factory then
107277: LD_VAR 0 1
107281: NOT
107282: PUSH
107283: LD_VAR 0 2
107287: NOT
107288: OR
107289: IFFALSE 107293
// exit ;
107291: GO 107524
// if factoryWaypoints >= factory then
107293: LD_EXP 154
107297: PUSH
107298: LD_VAR 0 2
107302: GREATEREQUAL
107303: IFFALSE 107524
// if factoryWaypoints [ factory ] then
107305: LD_EXP 154
107309: PUSH
107310: LD_VAR 0 2
107314: ARRAY
107315: IFFALSE 107524
// begin if GetControl ( vehicle ) = control_manual then
107317: LD_VAR 0 1
107321: PPUSH
107322: CALL_OW 263
107326: PUSH
107327: LD_INT 1
107329: EQUAL
107330: IFFALSE 107411
// begin driver := IsDrivenBy ( vehicle ) ;
107332: LD_ADDR_VAR 0 4
107336: PUSH
107337: LD_VAR 0 1
107341: PPUSH
107342: CALL_OW 311
107346: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107347: LD_VAR 0 4
107351: PPUSH
107352: LD_EXP 154
107356: PUSH
107357: LD_VAR 0 2
107361: ARRAY
107362: PUSH
107363: LD_INT 3
107365: ARRAY
107366: PPUSH
107367: LD_EXP 154
107371: PUSH
107372: LD_VAR 0 2
107376: ARRAY
107377: PUSH
107378: LD_INT 4
107380: ARRAY
107381: PPUSH
107382: CALL_OW 171
// AddComExitVehicle ( driver ) ;
107386: LD_VAR 0 4
107390: PPUSH
107391: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
107395: LD_VAR 0 4
107399: PPUSH
107400: LD_VAR 0 2
107404: PPUSH
107405: CALL_OW 180
// end else
107409: GO 107524
// if GetControl ( vehicle ) = control_remote then
107411: LD_VAR 0 1
107415: PPUSH
107416: CALL_OW 263
107420: PUSH
107421: LD_INT 2
107423: EQUAL
107424: IFFALSE 107485
// begin wait ( 0 0$2 ) ;
107426: LD_INT 70
107428: PPUSH
107429: CALL_OW 67
// if Connect ( vehicle ) then
107433: LD_VAR 0 1
107437: PPUSH
107438: CALL 57427 0 1
107442: IFFALSE 107483
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107444: LD_VAR 0 1
107448: PPUSH
107449: LD_EXP 154
107453: PUSH
107454: LD_VAR 0 2
107458: ARRAY
107459: PUSH
107460: LD_INT 3
107462: ARRAY
107463: PPUSH
107464: LD_EXP 154
107468: PUSH
107469: LD_VAR 0 2
107473: ARRAY
107474: PUSH
107475: LD_INT 4
107477: ARRAY
107478: PPUSH
107479: CALL_OW 171
// end else
107483: GO 107524
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107485: LD_VAR 0 1
107489: PPUSH
107490: LD_EXP 154
107494: PUSH
107495: LD_VAR 0 2
107499: ARRAY
107500: PUSH
107501: LD_INT 3
107503: ARRAY
107504: PPUSH
107505: LD_EXP 154
107509: PUSH
107510: LD_VAR 0 2
107514: ARRAY
107515: PUSH
107516: LD_INT 4
107518: ARRAY
107519: PPUSH
107520: CALL_OW 171
// end ; end ;
107524: LD_VAR 0 3
107528: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
107529: LD_INT 0
107531: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
107532: LD_VAR 0 1
107536: PUSH
107537: LD_INT 250
107539: EQUAL
107540: PUSH
107541: LD_VAR 0 2
107545: PPUSH
107546: CALL_OW 264
107550: PUSH
107551: LD_INT 81
107553: EQUAL
107554: AND
107555: IFFALSE 107576
// MinerPlaceMine ( unit , x , y ) ;
107557: LD_VAR 0 2
107561: PPUSH
107562: LD_VAR 0 4
107566: PPUSH
107567: LD_VAR 0 5
107571: PPUSH
107572: CALL 110566 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
107576: LD_VAR 0 1
107580: PUSH
107581: LD_INT 251
107583: EQUAL
107584: PUSH
107585: LD_VAR 0 2
107589: PPUSH
107590: CALL_OW 264
107594: PUSH
107595: LD_INT 81
107597: EQUAL
107598: AND
107599: IFFALSE 107620
// MinerDetonateMine ( unit , x , y ) ;
107601: LD_VAR 0 2
107605: PPUSH
107606: LD_VAR 0 4
107610: PPUSH
107611: LD_VAR 0 5
107615: PPUSH
107616: CALL 110841 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
107620: LD_VAR 0 1
107624: PUSH
107625: LD_INT 252
107627: EQUAL
107628: PUSH
107629: LD_VAR 0 2
107633: PPUSH
107634: CALL_OW 264
107638: PUSH
107639: LD_INT 81
107641: EQUAL
107642: AND
107643: IFFALSE 107664
// MinerCreateMinefield ( unit , x , y ) ;
107645: LD_VAR 0 2
107649: PPUSH
107650: LD_VAR 0 4
107654: PPUSH
107655: LD_VAR 0 5
107659: PPUSH
107660: CALL 111258 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
107664: LD_VAR 0 1
107668: PUSH
107669: LD_INT 253
107671: EQUAL
107672: PUSH
107673: LD_VAR 0 2
107677: PPUSH
107678: CALL_OW 257
107682: PUSH
107683: LD_INT 5
107685: EQUAL
107686: AND
107687: IFFALSE 107708
// ComBinocular ( unit , x , y ) ;
107689: LD_VAR 0 2
107693: PPUSH
107694: LD_VAR 0 4
107698: PPUSH
107699: LD_VAR 0 5
107703: PPUSH
107704: CALL 111627 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
107708: LD_VAR 0 1
107712: PUSH
107713: LD_INT 254
107715: EQUAL
107716: PUSH
107717: LD_VAR 0 2
107721: PPUSH
107722: CALL_OW 264
107726: PUSH
107727: LD_INT 99
107729: EQUAL
107730: AND
107731: PUSH
107732: LD_VAR 0 3
107736: PPUSH
107737: CALL_OW 263
107741: PUSH
107742: LD_INT 3
107744: EQUAL
107745: AND
107746: IFFALSE 107762
// HackDestroyVehicle ( unit , selectedUnit ) ;
107748: LD_VAR 0 2
107752: PPUSH
107753: LD_VAR 0 3
107757: PPUSH
107758: CALL 109930 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
107762: LD_VAR 0 1
107766: PUSH
107767: LD_INT 255
107769: EQUAL
107770: PUSH
107771: LD_VAR 0 2
107775: PPUSH
107776: CALL_OW 264
107780: PUSH
107781: LD_INT 14
107783: PUSH
107784: LD_INT 53
107786: PUSH
107787: EMPTY
107788: LIST
107789: LIST
107790: IN
107791: AND
107792: PUSH
107793: LD_VAR 0 4
107797: PPUSH
107798: LD_VAR 0 5
107802: PPUSH
107803: CALL_OW 488
107807: AND
107808: IFFALSE 107832
// CutTreeXYR ( unit , x , y , 12 ) ;
107810: LD_VAR 0 2
107814: PPUSH
107815: LD_VAR 0 4
107819: PPUSH
107820: LD_VAR 0 5
107824: PPUSH
107825: LD_INT 12
107827: PPUSH
107828: CALL 107927 0 4
// if cmd = 256 then
107832: LD_VAR 0 1
107836: PUSH
107837: LD_INT 256
107839: EQUAL
107840: IFFALSE 107861
// SetFactoryWaypoint ( unit , x , y ) ;
107842: LD_VAR 0 2
107846: PPUSH
107847: LD_VAR 0 4
107851: PPUSH
107852: LD_VAR 0 5
107856: PPUSH
107857: CALL 105842 0 3
// if cmd = 257 then
107861: LD_VAR 0 1
107865: PUSH
107866: LD_INT 257
107868: EQUAL
107869: IFFALSE 107890
// SetWarehouseGatheringPoint ( unit , x , y ) ;
107871: LD_VAR 0 2
107875: PPUSH
107876: LD_VAR 0 4
107880: PPUSH
107881: LD_VAR 0 5
107885: PPUSH
107886: CALL 106204 0 3
// if cmd = 258 then
107890: LD_VAR 0 1
107894: PUSH
107895: LD_INT 258
107897: EQUAL
107898: IFFALSE 107922
// BurnTreeXYR ( unit , x , y , 8 ) ;
107900: LD_VAR 0 2
107904: PPUSH
107905: LD_VAR 0 4
107909: PPUSH
107910: LD_VAR 0 5
107914: PPUSH
107915: LD_INT 8
107917: PPUSH
107918: CALL 108321 0 4
// end ;
107922: LD_VAR 0 6
107926: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107927: LD_INT 0
107929: PPUSH
107930: PPUSH
107931: PPUSH
107932: PPUSH
107933: PPUSH
107934: PPUSH
107935: PPUSH
107936: PPUSH
107937: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
107938: LD_VAR 0 1
107942: PPUSH
107943: CALL_OW 302
107947: NOT
107948: PUSH
107949: LD_VAR 0 2
107953: PPUSH
107954: LD_VAR 0 3
107958: PPUSH
107959: CALL_OW 488
107963: NOT
107964: OR
107965: PUSH
107966: LD_VAR 0 4
107970: NOT
107971: OR
107972: IFFALSE 107976
// exit ;
107974: GO 108316
// list := [ ] ;
107976: LD_ADDR_VAR 0 13
107980: PUSH
107981: EMPTY
107982: ST_TO_ADDR
// if x - r < 0 then
107983: LD_VAR 0 2
107987: PUSH
107988: LD_VAR 0 4
107992: MINUS
107993: PUSH
107994: LD_INT 0
107996: LESS
107997: IFFALSE 108009
// min_x := 0 else
107999: LD_ADDR_VAR 0 7
108003: PUSH
108004: LD_INT 0
108006: ST_TO_ADDR
108007: GO 108025
// min_x := x - r ;
108009: LD_ADDR_VAR 0 7
108013: PUSH
108014: LD_VAR 0 2
108018: PUSH
108019: LD_VAR 0 4
108023: MINUS
108024: ST_TO_ADDR
// if y - r < 0 then
108025: LD_VAR 0 3
108029: PUSH
108030: LD_VAR 0 4
108034: MINUS
108035: PUSH
108036: LD_INT 0
108038: LESS
108039: IFFALSE 108051
// min_y := 0 else
108041: LD_ADDR_VAR 0 8
108045: PUSH
108046: LD_INT 0
108048: ST_TO_ADDR
108049: GO 108067
// min_y := y - r ;
108051: LD_ADDR_VAR 0 8
108055: PUSH
108056: LD_VAR 0 3
108060: PUSH
108061: LD_VAR 0 4
108065: MINUS
108066: ST_TO_ADDR
// max_x := x + r ;
108067: LD_ADDR_VAR 0 9
108071: PUSH
108072: LD_VAR 0 2
108076: PUSH
108077: LD_VAR 0 4
108081: PLUS
108082: ST_TO_ADDR
// max_y := y + r ;
108083: LD_ADDR_VAR 0 10
108087: PUSH
108088: LD_VAR 0 3
108092: PUSH
108093: LD_VAR 0 4
108097: PLUS
108098: ST_TO_ADDR
// for _x = min_x to max_x do
108099: LD_ADDR_VAR 0 11
108103: PUSH
108104: DOUBLE
108105: LD_VAR 0 7
108109: DEC
108110: ST_TO_ADDR
108111: LD_VAR 0 9
108115: PUSH
108116: FOR_TO
108117: IFFALSE 108234
// for _y = min_y to max_y do
108119: LD_ADDR_VAR 0 12
108123: PUSH
108124: DOUBLE
108125: LD_VAR 0 8
108129: DEC
108130: ST_TO_ADDR
108131: LD_VAR 0 10
108135: PUSH
108136: FOR_TO
108137: IFFALSE 108230
// begin if not ValidHex ( _x , _y ) then
108139: LD_VAR 0 11
108143: PPUSH
108144: LD_VAR 0 12
108148: PPUSH
108149: CALL_OW 488
108153: NOT
108154: IFFALSE 108158
// continue ;
108156: GO 108136
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108158: LD_VAR 0 11
108162: PPUSH
108163: LD_VAR 0 12
108167: PPUSH
108168: CALL_OW 351
108172: PUSH
108173: LD_VAR 0 11
108177: PPUSH
108178: LD_VAR 0 12
108182: PPUSH
108183: CALL_OW 554
108187: AND
108188: IFFALSE 108228
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108190: LD_ADDR_VAR 0 13
108194: PUSH
108195: LD_VAR 0 13
108199: PPUSH
108200: LD_VAR 0 13
108204: PUSH
108205: LD_INT 1
108207: PLUS
108208: PPUSH
108209: LD_VAR 0 11
108213: PUSH
108214: LD_VAR 0 12
108218: PUSH
108219: EMPTY
108220: LIST
108221: LIST
108222: PPUSH
108223: CALL_OW 2
108227: ST_TO_ADDR
// end ;
108228: GO 108136
108230: POP
108231: POP
108232: GO 108116
108234: POP
108235: POP
// if not list then
108236: LD_VAR 0 13
108240: NOT
108241: IFFALSE 108245
// exit ;
108243: GO 108316
// for i in list do
108245: LD_ADDR_VAR 0 6
108249: PUSH
108250: LD_VAR 0 13
108254: PUSH
108255: FOR_IN
108256: IFFALSE 108314
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108258: LD_VAR 0 1
108262: PPUSH
108263: LD_STRING M
108265: PUSH
108266: LD_VAR 0 6
108270: PUSH
108271: LD_INT 1
108273: ARRAY
108274: PUSH
108275: LD_VAR 0 6
108279: PUSH
108280: LD_INT 2
108282: ARRAY
108283: PUSH
108284: LD_INT 0
108286: PUSH
108287: LD_INT 0
108289: PUSH
108290: LD_INT 0
108292: PUSH
108293: LD_INT 0
108295: PUSH
108296: EMPTY
108297: LIST
108298: LIST
108299: LIST
108300: LIST
108301: LIST
108302: LIST
108303: LIST
108304: PUSH
108305: EMPTY
108306: LIST
108307: PPUSH
108308: CALL_OW 447
108312: GO 108255
108314: POP
108315: POP
// end ;
108316: LD_VAR 0 5
108320: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
108321: LD_INT 0
108323: PPUSH
108324: PPUSH
108325: PPUSH
108326: PPUSH
108327: PPUSH
108328: PPUSH
108329: PPUSH
108330: PPUSH
108331: PPUSH
108332: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
108333: LD_VAR 0 1
108337: PPUSH
108338: CALL_OW 302
108342: NOT
108343: PUSH
108344: LD_VAR 0 2
108348: PPUSH
108349: LD_VAR 0 3
108353: PPUSH
108354: CALL_OW 488
108358: NOT
108359: OR
108360: PUSH
108361: LD_VAR 0 4
108365: NOT
108366: OR
108367: IFFALSE 108371
// exit ;
108369: GO 108884
// list := [ ] ;
108371: LD_ADDR_VAR 0 13
108375: PUSH
108376: EMPTY
108377: ST_TO_ADDR
// if x - r < 0 then
108378: LD_VAR 0 2
108382: PUSH
108383: LD_VAR 0 4
108387: MINUS
108388: PUSH
108389: LD_INT 0
108391: LESS
108392: IFFALSE 108404
// min_x := 0 else
108394: LD_ADDR_VAR 0 7
108398: PUSH
108399: LD_INT 0
108401: ST_TO_ADDR
108402: GO 108420
// min_x := x - r ;
108404: LD_ADDR_VAR 0 7
108408: PUSH
108409: LD_VAR 0 2
108413: PUSH
108414: LD_VAR 0 4
108418: MINUS
108419: ST_TO_ADDR
// if y - r < 0 then
108420: LD_VAR 0 3
108424: PUSH
108425: LD_VAR 0 4
108429: MINUS
108430: PUSH
108431: LD_INT 0
108433: LESS
108434: IFFALSE 108446
// min_y := 0 else
108436: LD_ADDR_VAR 0 8
108440: PUSH
108441: LD_INT 0
108443: ST_TO_ADDR
108444: GO 108462
// min_y := y - r ;
108446: LD_ADDR_VAR 0 8
108450: PUSH
108451: LD_VAR 0 3
108455: PUSH
108456: LD_VAR 0 4
108460: MINUS
108461: ST_TO_ADDR
// max_x := x + r ;
108462: LD_ADDR_VAR 0 9
108466: PUSH
108467: LD_VAR 0 2
108471: PUSH
108472: LD_VAR 0 4
108476: PLUS
108477: ST_TO_ADDR
// max_y := y + r ;
108478: LD_ADDR_VAR 0 10
108482: PUSH
108483: LD_VAR 0 3
108487: PUSH
108488: LD_VAR 0 4
108492: PLUS
108493: ST_TO_ADDR
// for _x = min_x to max_x do
108494: LD_ADDR_VAR 0 11
108498: PUSH
108499: DOUBLE
108500: LD_VAR 0 7
108504: DEC
108505: ST_TO_ADDR
108506: LD_VAR 0 9
108510: PUSH
108511: FOR_TO
108512: IFFALSE 108629
// for _y = min_y to max_y do
108514: LD_ADDR_VAR 0 12
108518: PUSH
108519: DOUBLE
108520: LD_VAR 0 8
108524: DEC
108525: ST_TO_ADDR
108526: LD_VAR 0 10
108530: PUSH
108531: FOR_TO
108532: IFFALSE 108625
// begin if not ValidHex ( _x , _y ) then
108534: LD_VAR 0 11
108538: PPUSH
108539: LD_VAR 0 12
108543: PPUSH
108544: CALL_OW 488
108548: NOT
108549: IFFALSE 108553
// continue ;
108551: GO 108531
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108553: LD_VAR 0 11
108557: PPUSH
108558: LD_VAR 0 12
108562: PPUSH
108563: CALL_OW 351
108567: PUSH
108568: LD_VAR 0 11
108572: PPUSH
108573: LD_VAR 0 12
108577: PPUSH
108578: CALL_OW 554
108582: AND
108583: IFFALSE 108623
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108585: LD_ADDR_VAR 0 13
108589: PUSH
108590: LD_VAR 0 13
108594: PPUSH
108595: LD_VAR 0 13
108599: PUSH
108600: LD_INT 1
108602: PLUS
108603: PPUSH
108604: LD_VAR 0 11
108608: PUSH
108609: LD_VAR 0 12
108613: PUSH
108614: EMPTY
108615: LIST
108616: LIST
108617: PPUSH
108618: CALL_OW 2
108622: ST_TO_ADDR
// end ;
108623: GO 108531
108625: POP
108626: POP
108627: GO 108511
108629: POP
108630: POP
// if not list then
108631: LD_VAR 0 13
108635: NOT
108636: IFFALSE 108640
// exit ;
108638: GO 108884
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
108640: LD_ADDR_VAR 0 13
108644: PUSH
108645: LD_VAR 0 1
108649: PPUSH
108650: LD_VAR 0 13
108654: PPUSH
108655: LD_INT 1
108657: PPUSH
108658: LD_INT 1
108660: PPUSH
108661: CALL 54569 0 4
108665: ST_TO_ADDR
// ComStop ( flame ) ;
108666: LD_VAR 0 1
108670: PPUSH
108671: CALL_OW 141
// for i in list do
108675: LD_ADDR_VAR 0 6
108679: PUSH
108680: LD_VAR 0 13
108684: PUSH
108685: FOR_IN
108686: IFFALSE 108717
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
108688: LD_VAR 0 1
108692: PPUSH
108693: LD_VAR 0 6
108697: PUSH
108698: LD_INT 1
108700: ARRAY
108701: PPUSH
108702: LD_VAR 0 6
108706: PUSH
108707: LD_INT 2
108709: ARRAY
108710: PPUSH
108711: CALL_OW 176
108715: GO 108685
108717: POP
108718: POP
// repeat wait ( 0 0$1 ) ;
108719: LD_INT 35
108721: PPUSH
108722: CALL_OW 67
// task := GetTaskList ( flame ) ;
108726: LD_ADDR_VAR 0 14
108730: PUSH
108731: LD_VAR 0 1
108735: PPUSH
108736: CALL_OW 437
108740: ST_TO_ADDR
// if not task then
108741: LD_VAR 0 14
108745: NOT
108746: IFFALSE 108750
// exit ;
108748: GO 108884
// if task [ 1 ] [ 1 ] <> | then
108750: LD_VAR 0 14
108754: PUSH
108755: LD_INT 1
108757: ARRAY
108758: PUSH
108759: LD_INT 1
108761: ARRAY
108762: PUSH
108763: LD_STRING |
108765: NONEQUAL
108766: IFFALSE 108770
// exit ;
108768: GO 108884
// _x := task [ 1 ] [ 2 ] ;
108770: LD_ADDR_VAR 0 11
108774: PUSH
108775: LD_VAR 0 14
108779: PUSH
108780: LD_INT 1
108782: ARRAY
108783: PUSH
108784: LD_INT 2
108786: ARRAY
108787: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
108788: LD_ADDR_VAR 0 12
108792: PUSH
108793: LD_VAR 0 14
108797: PUSH
108798: LD_INT 1
108800: ARRAY
108801: PUSH
108802: LD_INT 3
108804: ARRAY
108805: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
108806: LD_VAR 0 11
108810: PPUSH
108811: LD_VAR 0 12
108815: PPUSH
108816: CALL_OW 351
108820: NOT
108821: PUSH
108822: LD_VAR 0 11
108826: PPUSH
108827: LD_VAR 0 12
108831: PPUSH
108832: CALL_OW 554
108836: NOT
108837: OR
108838: IFFALSE 108872
// begin task := Delete ( task , 1 ) ;
108840: LD_ADDR_VAR 0 14
108844: PUSH
108845: LD_VAR 0 14
108849: PPUSH
108850: LD_INT 1
108852: PPUSH
108853: CALL_OW 3
108857: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
108858: LD_VAR 0 1
108862: PPUSH
108863: LD_VAR 0 14
108867: PPUSH
108868: CALL_OW 446
// end ; until not HasTask ( flame ) ;
108872: LD_VAR 0 1
108876: PPUSH
108877: CALL_OW 314
108881: NOT
108882: IFFALSE 108719
// end ;
108884: LD_VAR 0 5
108888: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
108889: LD_EXP 157
108893: NOT
108894: IFFALSE 108944
108896: GO 108898
108898: DISABLE
// begin initHack := true ;
108899: LD_ADDR_EXP 157
108903: PUSH
108904: LD_INT 1
108906: ST_TO_ADDR
// hackTanks := [ ] ;
108907: LD_ADDR_EXP 158
108911: PUSH
108912: EMPTY
108913: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
108914: LD_ADDR_EXP 159
108918: PUSH
108919: EMPTY
108920: ST_TO_ADDR
// hackLimit := 3 ;
108921: LD_ADDR_EXP 160
108925: PUSH
108926: LD_INT 3
108928: ST_TO_ADDR
// hackDist := 12 ;
108929: LD_ADDR_EXP 161
108933: PUSH
108934: LD_INT 12
108936: ST_TO_ADDR
// hackCounter := [ ] ;
108937: LD_ADDR_EXP 162
108941: PUSH
108942: EMPTY
108943: ST_TO_ADDR
// end ;
108944: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
108945: LD_EXP 157
108949: PUSH
108950: LD_INT 34
108952: PUSH
108953: LD_INT 99
108955: PUSH
108956: EMPTY
108957: LIST
108958: LIST
108959: PPUSH
108960: CALL_OW 69
108964: AND
108965: IFFALSE 109218
108967: GO 108969
108969: DISABLE
108970: LD_INT 0
108972: PPUSH
108973: PPUSH
// begin enable ;
108974: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
108975: LD_ADDR_VAR 0 1
108979: PUSH
108980: LD_INT 34
108982: PUSH
108983: LD_INT 99
108985: PUSH
108986: EMPTY
108987: LIST
108988: LIST
108989: PPUSH
108990: CALL_OW 69
108994: PUSH
108995: FOR_IN
108996: IFFALSE 109216
// begin if not i in hackTanks then
108998: LD_VAR 0 1
109002: PUSH
109003: LD_EXP 158
109007: IN
109008: NOT
109009: IFFALSE 109092
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
109011: LD_ADDR_EXP 158
109015: PUSH
109016: LD_EXP 158
109020: PPUSH
109021: LD_EXP 158
109025: PUSH
109026: LD_INT 1
109028: PLUS
109029: PPUSH
109030: LD_VAR 0 1
109034: PPUSH
109035: CALL_OW 1
109039: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
109040: LD_ADDR_EXP 159
109044: PUSH
109045: LD_EXP 159
109049: PPUSH
109050: LD_EXP 159
109054: PUSH
109055: LD_INT 1
109057: PLUS
109058: PPUSH
109059: EMPTY
109060: PPUSH
109061: CALL_OW 1
109065: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
109066: LD_ADDR_EXP 162
109070: PUSH
109071: LD_EXP 162
109075: PPUSH
109076: LD_EXP 162
109080: PUSH
109081: LD_INT 1
109083: PLUS
109084: PPUSH
109085: EMPTY
109086: PPUSH
109087: CALL_OW 1
109091: ST_TO_ADDR
// end ; if not IsOk ( i ) then
109092: LD_VAR 0 1
109096: PPUSH
109097: CALL_OW 302
109101: NOT
109102: IFFALSE 109115
// begin HackUnlinkAll ( i ) ;
109104: LD_VAR 0 1
109108: PPUSH
109109: CALL 109221 0 1
// continue ;
109113: GO 108995
// end ; HackCheckCapturedStatus ( i ) ;
109115: LD_VAR 0 1
109119: PPUSH
109120: CALL 109664 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
109124: LD_ADDR_VAR 0 2
109128: PUSH
109129: LD_INT 81
109131: PUSH
109132: LD_VAR 0 1
109136: PPUSH
109137: CALL_OW 255
109141: PUSH
109142: EMPTY
109143: LIST
109144: LIST
109145: PUSH
109146: LD_INT 33
109148: PUSH
109149: LD_INT 3
109151: PUSH
109152: EMPTY
109153: LIST
109154: LIST
109155: PUSH
109156: LD_INT 91
109158: PUSH
109159: LD_VAR 0 1
109163: PUSH
109164: LD_EXP 161
109168: PUSH
109169: EMPTY
109170: LIST
109171: LIST
109172: LIST
109173: PUSH
109174: LD_INT 50
109176: PUSH
109177: EMPTY
109178: LIST
109179: PUSH
109180: EMPTY
109181: LIST
109182: LIST
109183: LIST
109184: LIST
109185: PPUSH
109186: CALL_OW 69
109190: ST_TO_ADDR
// if not tmp then
109191: LD_VAR 0 2
109195: NOT
109196: IFFALSE 109200
// continue ;
109198: GO 108995
// HackLink ( i , tmp ) ;
109200: LD_VAR 0 1
109204: PPUSH
109205: LD_VAR 0 2
109209: PPUSH
109210: CALL 109357 0 2
// end ;
109214: GO 108995
109216: POP
109217: POP
// end ;
109218: PPOPN 2
109220: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
109221: LD_INT 0
109223: PPUSH
109224: PPUSH
109225: PPUSH
// if not hack in hackTanks then
109226: LD_VAR 0 1
109230: PUSH
109231: LD_EXP 158
109235: IN
109236: NOT
109237: IFFALSE 109241
// exit ;
109239: GO 109352
// index := GetElementIndex ( hackTanks , hack ) ;
109241: LD_ADDR_VAR 0 4
109245: PUSH
109246: LD_EXP 158
109250: PPUSH
109251: LD_VAR 0 1
109255: PPUSH
109256: CALL 53866 0 2
109260: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
109261: LD_EXP 159
109265: PUSH
109266: LD_VAR 0 4
109270: ARRAY
109271: IFFALSE 109352
// begin for i in hackTanksCaptured [ index ] do
109273: LD_ADDR_VAR 0 3
109277: PUSH
109278: LD_EXP 159
109282: PUSH
109283: LD_VAR 0 4
109287: ARRAY
109288: PUSH
109289: FOR_IN
109290: IFFALSE 109316
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
109292: LD_VAR 0 3
109296: PUSH
109297: LD_INT 1
109299: ARRAY
109300: PPUSH
109301: LD_VAR 0 3
109305: PUSH
109306: LD_INT 2
109308: ARRAY
109309: PPUSH
109310: CALL_OW 235
109314: GO 109289
109316: POP
109317: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
109318: LD_ADDR_EXP 159
109322: PUSH
109323: LD_EXP 159
109327: PPUSH
109328: LD_VAR 0 4
109332: PPUSH
109333: EMPTY
109334: PPUSH
109335: CALL_OW 1
109339: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
109340: LD_VAR 0 1
109344: PPUSH
109345: LD_INT 0
109347: PPUSH
109348: CALL_OW 505
// end ; end ;
109352: LD_VAR 0 2
109356: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
109357: LD_INT 0
109359: PPUSH
109360: PPUSH
109361: PPUSH
// if not hack in hackTanks or not vehicles then
109362: LD_VAR 0 1
109366: PUSH
109367: LD_EXP 158
109371: IN
109372: NOT
109373: PUSH
109374: LD_VAR 0 2
109378: NOT
109379: OR
109380: IFFALSE 109384
// exit ;
109382: GO 109659
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
109384: LD_ADDR_VAR 0 2
109388: PUSH
109389: LD_VAR 0 1
109393: PPUSH
109394: LD_VAR 0 2
109398: PPUSH
109399: LD_INT 1
109401: PPUSH
109402: LD_INT 1
109404: PPUSH
109405: CALL 54516 0 4
109409: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
109410: LD_ADDR_VAR 0 5
109414: PUSH
109415: LD_EXP 158
109419: PPUSH
109420: LD_VAR 0 1
109424: PPUSH
109425: CALL 53866 0 2
109429: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
109430: LD_EXP 159
109434: PUSH
109435: LD_VAR 0 5
109439: ARRAY
109440: PUSH
109441: LD_EXP 160
109445: LESS
109446: IFFALSE 109635
// begin for i := 1 to vehicles do
109448: LD_ADDR_VAR 0 4
109452: PUSH
109453: DOUBLE
109454: LD_INT 1
109456: DEC
109457: ST_TO_ADDR
109458: LD_VAR 0 2
109462: PUSH
109463: FOR_TO
109464: IFFALSE 109633
// begin if hackTanksCaptured [ index ] = hackLimit then
109466: LD_EXP 159
109470: PUSH
109471: LD_VAR 0 5
109475: ARRAY
109476: PUSH
109477: LD_EXP 160
109481: EQUAL
109482: IFFALSE 109486
// break ;
109484: GO 109633
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
109486: LD_ADDR_EXP 162
109490: PUSH
109491: LD_EXP 162
109495: PPUSH
109496: LD_VAR 0 5
109500: PPUSH
109501: LD_EXP 162
109505: PUSH
109506: LD_VAR 0 5
109510: ARRAY
109511: PUSH
109512: LD_INT 1
109514: PLUS
109515: PPUSH
109516: CALL_OW 1
109520: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109521: LD_ADDR_EXP 159
109525: PUSH
109526: LD_EXP 159
109530: PPUSH
109531: LD_VAR 0 5
109535: PUSH
109536: LD_EXP 159
109540: PUSH
109541: LD_VAR 0 5
109545: ARRAY
109546: PUSH
109547: LD_INT 1
109549: PLUS
109550: PUSH
109551: EMPTY
109552: LIST
109553: LIST
109554: PPUSH
109555: LD_VAR 0 2
109559: PUSH
109560: LD_VAR 0 4
109564: ARRAY
109565: PUSH
109566: LD_VAR 0 2
109570: PUSH
109571: LD_VAR 0 4
109575: ARRAY
109576: PPUSH
109577: CALL_OW 255
109581: PUSH
109582: EMPTY
109583: LIST
109584: LIST
109585: PPUSH
109586: CALL 54081 0 3
109590: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109591: LD_VAR 0 2
109595: PUSH
109596: LD_VAR 0 4
109600: ARRAY
109601: PPUSH
109602: LD_VAR 0 1
109606: PPUSH
109607: CALL_OW 255
109611: PPUSH
109612: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109616: LD_VAR 0 2
109620: PUSH
109621: LD_VAR 0 4
109625: ARRAY
109626: PPUSH
109627: CALL_OW 141
// end ;
109631: GO 109463
109633: POP
109634: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109635: LD_VAR 0 1
109639: PPUSH
109640: LD_EXP 159
109644: PUSH
109645: LD_VAR 0 5
109649: ARRAY
109650: PUSH
109651: LD_INT 0
109653: PLUS
109654: PPUSH
109655: CALL_OW 505
// end ;
109659: LD_VAR 0 3
109663: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109664: LD_INT 0
109666: PPUSH
109667: PPUSH
109668: PPUSH
109669: PPUSH
// if not hack in hackTanks then
109670: LD_VAR 0 1
109674: PUSH
109675: LD_EXP 158
109679: IN
109680: NOT
109681: IFFALSE 109685
// exit ;
109683: GO 109925
// index := GetElementIndex ( hackTanks , hack ) ;
109685: LD_ADDR_VAR 0 4
109689: PUSH
109690: LD_EXP 158
109694: PPUSH
109695: LD_VAR 0 1
109699: PPUSH
109700: CALL 53866 0 2
109704: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109705: LD_ADDR_VAR 0 3
109709: PUSH
109710: DOUBLE
109711: LD_EXP 159
109715: PUSH
109716: LD_VAR 0 4
109720: ARRAY
109721: INC
109722: ST_TO_ADDR
109723: LD_INT 1
109725: PUSH
109726: FOR_DOWNTO
109727: IFFALSE 109899
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109729: LD_ADDR_VAR 0 5
109733: PUSH
109734: LD_EXP 159
109738: PUSH
109739: LD_VAR 0 4
109743: ARRAY
109744: PUSH
109745: LD_VAR 0 3
109749: ARRAY
109750: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109751: LD_VAR 0 5
109755: PUSH
109756: LD_INT 1
109758: ARRAY
109759: PPUSH
109760: CALL_OW 302
109764: NOT
109765: PUSH
109766: LD_VAR 0 5
109770: PUSH
109771: LD_INT 1
109773: ARRAY
109774: PPUSH
109775: CALL_OW 255
109779: PUSH
109780: LD_VAR 0 1
109784: PPUSH
109785: CALL_OW 255
109789: NONEQUAL
109790: OR
109791: IFFALSE 109897
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109793: LD_VAR 0 5
109797: PUSH
109798: LD_INT 1
109800: ARRAY
109801: PPUSH
109802: CALL_OW 305
109806: PUSH
109807: LD_VAR 0 5
109811: PUSH
109812: LD_INT 1
109814: ARRAY
109815: PPUSH
109816: CALL_OW 255
109820: PUSH
109821: LD_VAR 0 1
109825: PPUSH
109826: CALL_OW 255
109830: EQUAL
109831: AND
109832: IFFALSE 109856
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
109834: LD_VAR 0 5
109838: PUSH
109839: LD_INT 1
109841: ARRAY
109842: PPUSH
109843: LD_VAR 0 5
109847: PUSH
109848: LD_INT 2
109850: ARRAY
109851: PPUSH
109852: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
109856: LD_ADDR_EXP 159
109860: PUSH
109861: LD_EXP 159
109865: PPUSH
109866: LD_VAR 0 4
109870: PPUSH
109871: LD_EXP 159
109875: PUSH
109876: LD_VAR 0 4
109880: ARRAY
109881: PPUSH
109882: LD_VAR 0 3
109886: PPUSH
109887: CALL_OW 3
109891: PPUSH
109892: CALL_OW 1
109896: ST_TO_ADDR
// end ; end ;
109897: GO 109726
109899: POP
109900: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109901: LD_VAR 0 1
109905: PPUSH
109906: LD_EXP 159
109910: PUSH
109911: LD_VAR 0 4
109915: ARRAY
109916: PUSH
109917: LD_INT 0
109919: PLUS
109920: PPUSH
109921: CALL_OW 505
// end ;
109925: LD_VAR 0 2
109929: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
109930: LD_INT 0
109932: PPUSH
109933: PPUSH
109934: PPUSH
109935: PPUSH
// if not hack in hackTanks then
109936: LD_VAR 0 1
109940: PUSH
109941: LD_EXP 158
109945: IN
109946: NOT
109947: IFFALSE 109951
// exit ;
109949: GO 110036
// index := GetElementIndex ( hackTanks , hack ) ;
109951: LD_ADDR_VAR 0 5
109955: PUSH
109956: LD_EXP 158
109960: PPUSH
109961: LD_VAR 0 1
109965: PPUSH
109966: CALL 53866 0 2
109970: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
109971: LD_ADDR_VAR 0 4
109975: PUSH
109976: DOUBLE
109977: LD_INT 1
109979: DEC
109980: ST_TO_ADDR
109981: LD_EXP 159
109985: PUSH
109986: LD_VAR 0 5
109990: ARRAY
109991: PUSH
109992: FOR_TO
109993: IFFALSE 110034
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
109995: LD_EXP 159
109999: PUSH
110000: LD_VAR 0 5
110004: ARRAY
110005: PUSH
110006: LD_VAR 0 4
110010: ARRAY
110011: PUSH
110012: LD_INT 1
110014: ARRAY
110015: PUSH
110016: LD_VAR 0 2
110020: EQUAL
110021: IFFALSE 110032
// KillUnit ( vehicle ) ;
110023: LD_VAR 0 2
110027: PPUSH
110028: CALL_OW 66
110032: GO 109992
110034: POP
110035: POP
// end ;
110036: LD_VAR 0 3
110040: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
110041: LD_EXP 163
110045: NOT
110046: IFFALSE 110081
110048: GO 110050
110050: DISABLE
// begin initMiner := true ;
110051: LD_ADDR_EXP 163
110055: PUSH
110056: LD_INT 1
110058: ST_TO_ADDR
// minersList := [ ] ;
110059: LD_ADDR_EXP 164
110063: PUSH
110064: EMPTY
110065: ST_TO_ADDR
// minerMinesList := [ ] ;
110066: LD_ADDR_EXP 165
110070: PUSH
110071: EMPTY
110072: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
110073: LD_ADDR_EXP 166
110077: PUSH
110078: LD_INT 5
110080: ST_TO_ADDR
// end ;
110081: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
110082: LD_EXP 163
110086: PUSH
110087: LD_INT 34
110089: PUSH
110090: LD_INT 81
110092: PUSH
110093: EMPTY
110094: LIST
110095: LIST
110096: PPUSH
110097: CALL_OW 69
110101: AND
110102: IFFALSE 110563
110104: GO 110106
110106: DISABLE
110107: LD_INT 0
110109: PPUSH
110110: PPUSH
110111: PPUSH
110112: PPUSH
// begin enable ;
110113: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
110114: LD_ADDR_VAR 0 1
110118: PUSH
110119: LD_INT 34
110121: PUSH
110122: LD_INT 81
110124: PUSH
110125: EMPTY
110126: LIST
110127: LIST
110128: PPUSH
110129: CALL_OW 69
110133: PUSH
110134: FOR_IN
110135: IFFALSE 110207
// begin if not i in minersList then
110137: LD_VAR 0 1
110141: PUSH
110142: LD_EXP 164
110146: IN
110147: NOT
110148: IFFALSE 110205
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
110150: LD_ADDR_EXP 164
110154: PUSH
110155: LD_EXP 164
110159: PPUSH
110160: LD_EXP 164
110164: PUSH
110165: LD_INT 1
110167: PLUS
110168: PPUSH
110169: LD_VAR 0 1
110173: PPUSH
110174: CALL_OW 1
110178: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
110179: LD_ADDR_EXP 165
110183: PUSH
110184: LD_EXP 165
110188: PPUSH
110189: LD_EXP 165
110193: PUSH
110194: LD_INT 1
110196: PLUS
110197: PPUSH
110198: EMPTY
110199: PPUSH
110200: CALL_OW 1
110204: ST_TO_ADDR
// end end ;
110205: GO 110134
110207: POP
110208: POP
// for i := minerMinesList downto 1 do
110209: LD_ADDR_VAR 0 1
110213: PUSH
110214: DOUBLE
110215: LD_EXP 165
110219: INC
110220: ST_TO_ADDR
110221: LD_INT 1
110223: PUSH
110224: FOR_DOWNTO
110225: IFFALSE 110561
// begin if IsLive ( minersList [ i ] ) then
110227: LD_EXP 164
110231: PUSH
110232: LD_VAR 0 1
110236: ARRAY
110237: PPUSH
110238: CALL_OW 300
110242: IFFALSE 110270
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
110244: LD_EXP 164
110248: PUSH
110249: LD_VAR 0 1
110253: ARRAY
110254: PPUSH
110255: LD_EXP 165
110259: PUSH
110260: LD_VAR 0 1
110264: ARRAY
110265: PPUSH
110266: CALL_OW 505
// if not minerMinesList [ i ] then
110270: LD_EXP 165
110274: PUSH
110275: LD_VAR 0 1
110279: ARRAY
110280: NOT
110281: IFFALSE 110285
// continue ;
110283: GO 110224
// for j := minerMinesList [ i ] downto 1 do
110285: LD_ADDR_VAR 0 2
110289: PUSH
110290: DOUBLE
110291: LD_EXP 165
110295: PUSH
110296: LD_VAR 0 1
110300: ARRAY
110301: INC
110302: ST_TO_ADDR
110303: LD_INT 1
110305: PUSH
110306: FOR_DOWNTO
110307: IFFALSE 110557
// begin side := GetSide ( minersList [ i ] ) ;
110309: LD_ADDR_VAR 0 3
110313: PUSH
110314: LD_EXP 164
110318: PUSH
110319: LD_VAR 0 1
110323: ARRAY
110324: PPUSH
110325: CALL_OW 255
110329: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
110330: LD_ADDR_VAR 0 4
110334: PUSH
110335: LD_EXP 165
110339: PUSH
110340: LD_VAR 0 1
110344: ARRAY
110345: PUSH
110346: LD_VAR 0 2
110350: ARRAY
110351: PUSH
110352: LD_INT 1
110354: ARRAY
110355: PPUSH
110356: LD_EXP 165
110360: PUSH
110361: LD_VAR 0 1
110365: ARRAY
110366: PUSH
110367: LD_VAR 0 2
110371: ARRAY
110372: PUSH
110373: LD_INT 2
110375: ARRAY
110376: PPUSH
110377: CALL_OW 428
110381: ST_TO_ADDR
// if not tmp then
110382: LD_VAR 0 4
110386: NOT
110387: IFFALSE 110391
// continue ;
110389: GO 110306
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
110391: LD_VAR 0 4
110395: PUSH
110396: LD_INT 81
110398: PUSH
110399: LD_VAR 0 3
110403: PUSH
110404: EMPTY
110405: LIST
110406: LIST
110407: PPUSH
110408: CALL_OW 69
110412: IN
110413: PUSH
110414: LD_EXP 165
110418: PUSH
110419: LD_VAR 0 1
110423: ARRAY
110424: PUSH
110425: LD_VAR 0 2
110429: ARRAY
110430: PUSH
110431: LD_INT 1
110433: ARRAY
110434: PPUSH
110435: LD_EXP 165
110439: PUSH
110440: LD_VAR 0 1
110444: ARRAY
110445: PUSH
110446: LD_VAR 0 2
110450: ARRAY
110451: PUSH
110452: LD_INT 2
110454: ARRAY
110455: PPUSH
110456: CALL_OW 458
110460: AND
110461: IFFALSE 110555
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
110463: LD_EXP 165
110467: PUSH
110468: LD_VAR 0 1
110472: ARRAY
110473: PUSH
110474: LD_VAR 0 2
110478: ARRAY
110479: PUSH
110480: LD_INT 1
110482: ARRAY
110483: PPUSH
110484: LD_EXP 165
110488: PUSH
110489: LD_VAR 0 1
110493: ARRAY
110494: PUSH
110495: LD_VAR 0 2
110499: ARRAY
110500: PUSH
110501: LD_INT 2
110503: ARRAY
110504: PPUSH
110505: LD_VAR 0 3
110509: PPUSH
110510: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110514: LD_ADDR_EXP 165
110518: PUSH
110519: LD_EXP 165
110523: PPUSH
110524: LD_VAR 0 1
110528: PPUSH
110529: LD_EXP 165
110533: PUSH
110534: LD_VAR 0 1
110538: ARRAY
110539: PPUSH
110540: LD_VAR 0 2
110544: PPUSH
110545: CALL_OW 3
110549: PPUSH
110550: CALL_OW 1
110554: ST_TO_ADDR
// end ; end ;
110555: GO 110306
110557: POP
110558: POP
// end ;
110559: GO 110224
110561: POP
110562: POP
// end ;
110563: PPOPN 4
110565: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110566: LD_INT 0
110568: PPUSH
110569: PPUSH
// result := false ;
110570: LD_ADDR_VAR 0 4
110574: PUSH
110575: LD_INT 0
110577: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110578: LD_VAR 0 1
110582: PPUSH
110583: CALL_OW 264
110587: PUSH
110588: LD_INT 81
110590: EQUAL
110591: NOT
110592: IFFALSE 110596
// exit ;
110594: GO 110836
// index := GetElementIndex ( minersList , unit ) ;
110596: LD_ADDR_VAR 0 5
110600: PUSH
110601: LD_EXP 164
110605: PPUSH
110606: LD_VAR 0 1
110610: PPUSH
110611: CALL 53866 0 2
110615: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110616: LD_EXP 165
110620: PUSH
110621: LD_VAR 0 5
110625: ARRAY
110626: PUSH
110627: LD_EXP 166
110631: GREATEREQUAL
110632: IFFALSE 110636
// exit ;
110634: GO 110836
// ComMoveXY ( unit , x , y ) ;
110636: LD_VAR 0 1
110640: PPUSH
110641: LD_VAR 0 2
110645: PPUSH
110646: LD_VAR 0 3
110650: PPUSH
110651: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110655: LD_INT 35
110657: PPUSH
110658: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110662: LD_VAR 0 1
110666: PPUSH
110667: LD_VAR 0 2
110671: PPUSH
110672: LD_VAR 0 3
110676: PPUSH
110677: CALL 85618 0 3
110681: NOT
110682: PUSH
110683: LD_VAR 0 1
110687: PPUSH
110688: CALL_OW 314
110692: AND
110693: IFFALSE 110697
// exit ;
110695: GO 110836
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110697: LD_VAR 0 2
110701: PPUSH
110702: LD_VAR 0 3
110706: PPUSH
110707: CALL_OW 428
110711: PUSH
110712: LD_VAR 0 1
110716: EQUAL
110717: PUSH
110718: LD_VAR 0 1
110722: PPUSH
110723: CALL_OW 314
110727: NOT
110728: AND
110729: IFFALSE 110655
// PlaySoundXY ( x , y , PlantMine ) ;
110731: LD_VAR 0 2
110735: PPUSH
110736: LD_VAR 0 3
110740: PPUSH
110741: LD_STRING PlantMine
110743: PPUSH
110744: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110748: LD_VAR 0 2
110752: PPUSH
110753: LD_VAR 0 3
110757: PPUSH
110758: LD_VAR 0 1
110762: PPUSH
110763: CALL_OW 255
110767: PPUSH
110768: LD_INT 0
110770: PPUSH
110771: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110775: LD_ADDR_EXP 165
110779: PUSH
110780: LD_EXP 165
110784: PPUSH
110785: LD_VAR 0 5
110789: PUSH
110790: LD_EXP 165
110794: PUSH
110795: LD_VAR 0 5
110799: ARRAY
110800: PUSH
110801: LD_INT 1
110803: PLUS
110804: PUSH
110805: EMPTY
110806: LIST
110807: LIST
110808: PPUSH
110809: LD_VAR 0 2
110813: PUSH
110814: LD_VAR 0 3
110818: PUSH
110819: EMPTY
110820: LIST
110821: LIST
110822: PPUSH
110823: CALL 54081 0 3
110827: ST_TO_ADDR
// result := true ;
110828: LD_ADDR_VAR 0 4
110832: PUSH
110833: LD_INT 1
110835: ST_TO_ADDR
// end ;
110836: LD_VAR 0 4
110840: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
110841: LD_INT 0
110843: PPUSH
110844: PPUSH
110845: PPUSH
// if not unit in minersList then
110846: LD_VAR 0 1
110850: PUSH
110851: LD_EXP 164
110855: IN
110856: NOT
110857: IFFALSE 110861
// exit ;
110859: GO 111253
// index := GetElementIndex ( minersList , unit ) ;
110861: LD_ADDR_VAR 0 6
110865: PUSH
110866: LD_EXP 164
110870: PPUSH
110871: LD_VAR 0 1
110875: PPUSH
110876: CALL 53866 0 2
110880: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
110881: LD_ADDR_VAR 0 5
110885: PUSH
110886: DOUBLE
110887: LD_EXP 165
110891: PUSH
110892: LD_VAR 0 6
110896: ARRAY
110897: INC
110898: ST_TO_ADDR
110899: LD_INT 1
110901: PUSH
110902: FOR_DOWNTO
110903: IFFALSE 111064
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
110905: LD_EXP 165
110909: PUSH
110910: LD_VAR 0 6
110914: ARRAY
110915: PUSH
110916: LD_VAR 0 5
110920: ARRAY
110921: PUSH
110922: LD_INT 1
110924: ARRAY
110925: PUSH
110926: LD_VAR 0 2
110930: EQUAL
110931: PUSH
110932: LD_EXP 165
110936: PUSH
110937: LD_VAR 0 6
110941: ARRAY
110942: PUSH
110943: LD_VAR 0 5
110947: ARRAY
110948: PUSH
110949: LD_INT 2
110951: ARRAY
110952: PUSH
110953: LD_VAR 0 3
110957: EQUAL
110958: AND
110959: IFFALSE 111062
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110961: LD_EXP 165
110965: PUSH
110966: LD_VAR 0 6
110970: ARRAY
110971: PUSH
110972: LD_VAR 0 5
110976: ARRAY
110977: PUSH
110978: LD_INT 1
110980: ARRAY
110981: PPUSH
110982: LD_EXP 165
110986: PUSH
110987: LD_VAR 0 6
110991: ARRAY
110992: PUSH
110993: LD_VAR 0 5
110997: ARRAY
110998: PUSH
110999: LD_INT 2
111001: ARRAY
111002: PPUSH
111003: LD_VAR 0 1
111007: PPUSH
111008: CALL_OW 255
111012: PPUSH
111013: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111017: LD_ADDR_EXP 165
111021: PUSH
111022: LD_EXP 165
111026: PPUSH
111027: LD_VAR 0 6
111031: PPUSH
111032: LD_EXP 165
111036: PUSH
111037: LD_VAR 0 6
111041: ARRAY
111042: PPUSH
111043: LD_VAR 0 5
111047: PPUSH
111048: CALL_OW 3
111052: PPUSH
111053: CALL_OW 1
111057: ST_TO_ADDR
// exit ;
111058: POP
111059: POP
111060: GO 111253
// end ; end ;
111062: GO 110902
111064: POP
111065: POP
// for i := minerMinesList [ index ] downto 1 do
111066: LD_ADDR_VAR 0 5
111070: PUSH
111071: DOUBLE
111072: LD_EXP 165
111076: PUSH
111077: LD_VAR 0 6
111081: ARRAY
111082: INC
111083: ST_TO_ADDR
111084: LD_INT 1
111086: PUSH
111087: FOR_DOWNTO
111088: IFFALSE 111251
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
111090: LD_EXP 165
111094: PUSH
111095: LD_VAR 0 6
111099: ARRAY
111100: PUSH
111101: LD_VAR 0 5
111105: ARRAY
111106: PUSH
111107: LD_INT 1
111109: ARRAY
111110: PPUSH
111111: LD_EXP 165
111115: PUSH
111116: LD_VAR 0 6
111120: ARRAY
111121: PUSH
111122: LD_VAR 0 5
111126: ARRAY
111127: PUSH
111128: LD_INT 2
111130: ARRAY
111131: PPUSH
111132: LD_VAR 0 2
111136: PPUSH
111137: LD_VAR 0 3
111141: PPUSH
111142: CALL_OW 298
111146: PUSH
111147: LD_INT 6
111149: LESS
111150: IFFALSE 111249
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111152: LD_EXP 165
111156: PUSH
111157: LD_VAR 0 6
111161: ARRAY
111162: PUSH
111163: LD_VAR 0 5
111167: ARRAY
111168: PUSH
111169: LD_INT 1
111171: ARRAY
111172: PPUSH
111173: LD_EXP 165
111177: PUSH
111178: LD_VAR 0 6
111182: ARRAY
111183: PUSH
111184: LD_VAR 0 5
111188: ARRAY
111189: PUSH
111190: LD_INT 2
111192: ARRAY
111193: PPUSH
111194: LD_VAR 0 1
111198: PPUSH
111199: CALL_OW 255
111203: PPUSH
111204: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111208: LD_ADDR_EXP 165
111212: PUSH
111213: LD_EXP 165
111217: PPUSH
111218: LD_VAR 0 6
111222: PPUSH
111223: LD_EXP 165
111227: PUSH
111228: LD_VAR 0 6
111232: ARRAY
111233: PPUSH
111234: LD_VAR 0 5
111238: PPUSH
111239: CALL_OW 3
111243: PPUSH
111244: CALL_OW 1
111248: ST_TO_ADDR
// end ; end ;
111249: GO 111087
111251: POP
111252: POP
// end ;
111253: LD_VAR 0 4
111257: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
111258: LD_INT 0
111260: PPUSH
111261: PPUSH
111262: PPUSH
111263: PPUSH
111264: PPUSH
111265: PPUSH
111266: PPUSH
111267: PPUSH
111268: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
111269: LD_VAR 0 1
111273: PPUSH
111274: CALL_OW 264
111278: PUSH
111279: LD_INT 81
111281: EQUAL
111282: NOT
111283: PUSH
111284: LD_VAR 0 1
111288: PUSH
111289: LD_EXP 164
111293: IN
111294: NOT
111295: OR
111296: IFFALSE 111300
// exit ;
111298: GO 111622
// index := GetElementIndex ( minersList , unit ) ;
111300: LD_ADDR_VAR 0 6
111304: PUSH
111305: LD_EXP 164
111309: PPUSH
111310: LD_VAR 0 1
111314: PPUSH
111315: CALL 53866 0 2
111319: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
111320: LD_ADDR_VAR 0 8
111324: PUSH
111325: LD_EXP 166
111329: PUSH
111330: LD_EXP 165
111334: PUSH
111335: LD_VAR 0 6
111339: ARRAY
111340: MINUS
111341: ST_TO_ADDR
// if not minesFreeAmount then
111342: LD_VAR 0 8
111346: NOT
111347: IFFALSE 111351
// exit ;
111349: GO 111622
// tmp := [ ] ;
111351: LD_ADDR_VAR 0 7
111355: PUSH
111356: EMPTY
111357: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
111358: LD_ADDR_VAR 0 5
111362: PUSH
111363: DOUBLE
111364: LD_INT 1
111366: DEC
111367: ST_TO_ADDR
111368: LD_VAR 0 8
111372: PUSH
111373: FOR_TO
111374: IFFALSE 111569
// begin _d := rand ( 0 , 5 ) ;
111376: LD_ADDR_VAR 0 11
111380: PUSH
111381: LD_INT 0
111383: PPUSH
111384: LD_INT 5
111386: PPUSH
111387: CALL_OW 12
111391: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
111392: LD_ADDR_VAR 0 12
111396: PUSH
111397: LD_INT 2
111399: PPUSH
111400: LD_INT 6
111402: PPUSH
111403: CALL_OW 12
111407: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
111408: LD_ADDR_VAR 0 9
111412: PUSH
111413: LD_VAR 0 2
111417: PPUSH
111418: LD_VAR 0 11
111422: PPUSH
111423: LD_VAR 0 12
111427: PPUSH
111428: CALL_OW 272
111432: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
111433: LD_ADDR_VAR 0 10
111437: PUSH
111438: LD_VAR 0 3
111442: PPUSH
111443: LD_VAR 0 11
111447: PPUSH
111448: LD_VAR 0 12
111452: PPUSH
111453: CALL_OW 273
111457: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
111458: LD_VAR 0 9
111462: PPUSH
111463: LD_VAR 0 10
111467: PPUSH
111468: CALL_OW 488
111472: PUSH
111473: LD_VAR 0 9
111477: PUSH
111478: LD_VAR 0 10
111482: PUSH
111483: EMPTY
111484: LIST
111485: LIST
111486: PUSH
111487: LD_VAR 0 7
111491: IN
111492: NOT
111493: AND
111494: PUSH
111495: LD_VAR 0 9
111499: PPUSH
111500: LD_VAR 0 10
111504: PPUSH
111505: CALL_OW 458
111509: NOT
111510: AND
111511: IFFALSE 111553
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111513: LD_ADDR_VAR 0 7
111517: PUSH
111518: LD_VAR 0 7
111522: PPUSH
111523: LD_VAR 0 7
111527: PUSH
111528: LD_INT 1
111530: PLUS
111531: PPUSH
111532: LD_VAR 0 9
111536: PUSH
111537: LD_VAR 0 10
111541: PUSH
111542: EMPTY
111543: LIST
111544: LIST
111545: PPUSH
111546: CALL_OW 1
111550: ST_TO_ADDR
111551: GO 111567
// i := i - 1 ;
111553: LD_ADDR_VAR 0 5
111557: PUSH
111558: LD_VAR 0 5
111562: PUSH
111563: LD_INT 1
111565: MINUS
111566: ST_TO_ADDR
// end ;
111567: GO 111373
111569: POP
111570: POP
// for i in tmp do
111571: LD_ADDR_VAR 0 5
111575: PUSH
111576: LD_VAR 0 7
111580: PUSH
111581: FOR_IN
111582: IFFALSE 111620
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111584: LD_VAR 0 1
111588: PPUSH
111589: LD_VAR 0 5
111593: PUSH
111594: LD_INT 1
111596: ARRAY
111597: PPUSH
111598: LD_VAR 0 5
111602: PUSH
111603: LD_INT 2
111605: ARRAY
111606: PPUSH
111607: CALL 110566 0 3
111611: NOT
111612: IFFALSE 111618
// exit ;
111614: POP
111615: POP
111616: GO 111622
111618: GO 111581
111620: POP
111621: POP
// end ;
111622: LD_VAR 0 4
111626: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
111627: LD_INT 0
111629: PPUSH
111630: PPUSH
111631: PPUSH
111632: PPUSH
111633: PPUSH
111634: PPUSH
111635: PPUSH
// if not GetClass ( unit ) = class_sniper then
111636: LD_VAR 0 1
111640: PPUSH
111641: CALL_OW 257
111645: PUSH
111646: LD_INT 5
111648: EQUAL
111649: NOT
111650: IFFALSE 111654
// exit ;
111652: GO 112042
// dist := 8 ;
111654: LD_ADDR_VAR 0 5
111658: PUSH
111659: LD_INT 8
111661: ST_TO_ADDR
// viewRange := 12 ;
111662: LD_ADDR_VAR 0 7
111666: PUSH
111667: LD_INT 12
111669: ST_TO_ADDR
// side := GetSide ( unit ) ;
111670: LD_ADDR_VAR 0 6
111674: PUSH
111675: LD_VAR 0 1
111679: PPUSH
111680: CALL_OW 255
111684: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111685: LD_INT 61
111687: PPUSH
111688: LD_VAR 0 6
111692: PPUSH
111693: CALL_OW 321
111697: PUSH
111698: LD_INT 2
111700: EQUAL
111701: IFFALSE 111711
// viewRange := 16 ;
111703: LD_ADDR_VAR 0 7
111707: PUSH
111708: LD_INT 16
111710: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111711: LD_VAR 0 1
111715: PPUSH
111716: LD_VAR 0 2
111720: PPUSH
111721: LD_VAR 0 3
111725: PPUSH
111726: CALL_OW 297
111730: PUSH
111731: LD_VAR 0 5
111735: GREATER
111736: IFFALSE 111815
// begin ComMoveXY ( unit , x , y ) ;
111738: LD_VAR 0 1
111742: PPUSH
111743: LD_VAR 0 2
111747: PPUSH
111748: LD_VAR 0 3
111752: PPUSH
111753: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111757: LD_INT 35
111759: PPUSH
111760: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111764: LD_VAR 0 1
111768: PPUSH
111769: LD_VAR 0 2
111773: PPUSH
111774: LD_VAR 0 3
111778: PPUSH
111779: CALL 85618 0 3
111783: NOT
111784: IFFALSE 111788
// exit ;
111786: GO 112042
// until GetDistUnitXY ( unit , x , y ) < dist ;
111788: LD_VAR 0 1
111792: PPUSH
111793: LD_VAR 0 2
111797: PPUSH
111798: LD_VAR 0 3
111802: PPUSH
111803: CALL_OW 297
111807: PUSH
111808: LD_VAR 0 5
111812: LESS
111813: IFFALSE 111757
// end ; ComTurnXY ( unit , x , y ) ;
111815: LD_VAR 0 1
111819: PPUSH
111820: LD_VAR 0 2
111824: PPUSH
111825: LD_VAR 0 3
111829: PPUSH
111830: CALL_OW 118
// wait ( 5 ) ;
111834: LD_INT 5
111836: PPUSH
111837: CALL_OW 67
// _d := GetDir ( unit ) ;
111841: LD_ADDR_VAR 0 10
111845: PUSH
111846: LD_VAR 0 1
111850: PPUSH
111851: CALL_OW 254
111855: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
111856: LD_ADDR_VAR 0 8
111860: PUSH
111861: LD_VAR 0 1
111865: PPUSH
111866: CALL_OW 250
111870: PPUSH
111871: LD_VAR 0 10
111875: PPUSH
111876: LD_VAR 0 5
111880: PPUSH
111881: CALL_OW 272
111885: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
111886: LD_ADDR_VAR 0 9
111890: PUSH
111891: LD_VAR 0 1
111895: PPUSH
111896: CALL_OW 251
111900: PPUSH
111901: LD_VAR 0 10
111905: PPUSH
111906: LD_VAR 0 5
111910: PPUSH
111911: CALL_OW 273
111915: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
111916: LD_VAR 0 8
111920: PPUSH
111921: LD_VAR 0 9
111925: PPUSH
111926: CALL_OW 488
111930: NOT
111931: IFFALSE 111935
// exit ;
111933: GO 112042
// ComAnimCustom ( unit , 1 ) ;
111935: LD_VAR 0 1
111939: PPUSH
111940: LD_INT 1
111942: PPUSH
111943: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
111947: LD_VAR 0 8
111951: PPUSH
111952: LD_VAR 0 9
111956: PPUSH
111957: LD_VAR 0 6
111961: PPUSH
111962: LD_VAR 0 7
111966: PPUSH
111967: CALL_OW 330
// repeat wait ( 1 ) ;
111971: LD_INT 1
111973: PPUSH
111974: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
111978: LD_VAR 0 1
111982: PPUSH
111983: CALL_OW 316
111987: PUSH
111988: LD_VAR 0 1
111992: PPUSH
111993: CALL_OW 314
111997: OR
111998: PUSH
111999: LD_VAR 0 1
112003: PPUSH
112004: CALL_OW 302
112008: NOT
112009: OR
112010: PUSH
112011: LD_VAR 0 1
112015: PPUSH
112016: CALL_OW 301
112020: OR
112021: IFFALSE 111971
// RemoveSeeing ( _x , _y , side ) ;
112023: LD_VAR 0 8
112027: PPUSH
112028: LD_VAR 0 9
112032: PPUSH
112033: LD_VAR 0 6
112037: PPUSH
112038: CALL_OW 331
// end ; end_of_file
112042: LD_VAR 0 4
112046: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
112047: LD_INT 0
112049: PPUSH
112050: PPUSH
112051: PPUSH
112052: PPUSH
112053: PPUSH
112054: PPUSH
112055: PPUSH
112056: PPUSH
112057: PPUSH
112058: PPUSH
112059: PPUSH
112060: PPUSH
112061: PPUSH
112062: PPUSH
112063: PPUSH
112064: PPUSH
112065: PPUSH
112066: PPUSH
112067: PPUSH
112068: PPUSH
112069: PPUSH
112070: PPUSH
112071: PPUSH
112072: PPUSH
112073: PPUSH
112074: PPUSH
112075: PPUSH
112076: PPUSH
112077: PPUSH
112078: PPUSH
112079: PPUSH
112080: PPUSH
112081: PPUSH
112082: PPUSH
// if not list then
112083: LD_VAR 0 1
112087: NOT
112088: IFFALSE 112092
// exit ;
112090: GO 116751
// base := list [ 1 ] ;
112092: LD_ADDR_VAR 0 3
112096: PUSH
112097: LD_VAR 0 1
112101: PUSH
112102: LD_INT 1
112104: ARRAY
112105: ST_TO_ADDR
// group := list [ 2 ] ;
112106: LD_ADDR_VAR 0 4
112110: PUSH
112111: LD_VAR 0 1
112115: PUSH
112116: LD_INT 2
112118: ARRAY
112119: ST_TO_ADDR
// path := list [ 3 ] ;
112120: LD_ADDR_VAR 0 5
112124: PUSH
112125: LD_VAR 0 1
112129: PUSH
112130: LD_INT 3
112132: ARRAY
112133: ST_TO_ADDR
// flags := list [ 4 ] ;
112134: LD_ADDR_VAR 0 6
112138: PUSH
112139: LD_VAR 0 1
112143: PUSH
112144: LD_INT 4
112146: ARRAY
112147: ST_TO_ADDR
// mined := [ ] ;
112148: LD_ADDR_VAR 0 27
112152: PUSH
112153: EMPTY
112154: ST_TO_ADDR
// bombed := [ ] ;
112155: LD_ADDR_VAR 0 28
112159: PUSH
112160: EMPTY
112161: ST_TO_ADDR
// healers := [ ] ;
112162: LD_ADDR_VAR 0 31
112166: PUSH
112167: EMPTY
112168: ST_TO_ADDR
// to_heal := [ ] ;
112169: LD_ADDR_VAR 0 30
112173: PUSH
112174: EMPTY
112175: ST_TO_ADDR
// repairs := [ ] ;
112176: LD_ADDR_VAR 0 33
112180: PUSH
112181: EMPTY
112182: ST_TO_ADDR
// to_repair := [ ] ;
112183: LD_ADDR_VAR 0 32
112187: PUSH
112188: EMPTY
112189: ST_TO_ADDR
// if not group or not path then
112190: LD_VAR 0 4
112194: NOT
112195: PUSH
112196: LD_VAR 0 5
112200: NOT
112201: OR
112202: IFFALSE 112206
// exit ;
112204: GO 116751
// side := GetSide ( group [ 1 ] ) ;
112206: LD_ADDR_VAR 0 35
112210: PUSH
112211: LD_VAR 0 4
112215: PUSH
112216: LD_INT 1
112218: ARRAY
112219: PPUSH
112220: CALL_OW 255
112224: ST_TO_ADDR
// if flags then
112225: LD_VAR 0 6
112229: IFFALSE 112373
// begin f_ignore_area := flags [ 1 ] ;
112231: LD_ADDR_VAR 0 17
112235: PUSH
112236: LD_VAR 0 6
112240: PUSH
112241: LD_INT 1
112243: ARRAY
112244: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
112245: LD_ADDR_VAR 0 18
112249: PUSH
112250: LD_VAR 0 6
112254: PUSH
112255: LD_INT 2
112257: ARRAY
112258: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
112259: LD_ADDR_VAR 0 19
112263: PUSH
112264: LD_VAR 0 6
112268: PUSH
112269: LD_INT 3
112271: ARRAY
112272: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
112273: LD_ADDR_VAR 0 20
112277: PUSH
112278: LD_VAR 0 6
112282: PUSH
112283: LD_INT 4
112285: ARRAY
112286: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
112287: LD_ADDR_VAR 0 21
112291: PUSH
112292: LD_VAR 0 6
112296: PUSH
112297: LD_INT 5
112299: ARRAY
112300: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
112301: LD_ADDR_VAR 0 22
112305: PUSH
112306: LD_VAR 0 6
112310: PUSH
112311: LD_INT 6
112313: ARRAY
112314: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
112315: LD_ADDR_VAR 0 23
112319: PUSH
112320: LD_VAR 0 6
112324: PUSH
112325: LD_INT 7
112327: ARRAY
112328: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
112329: LD_ADDR_VAR 0 24
112333: PUSH
112334: LD_VAR 0 6
112338: PUSH
112339: LD_INT 8
112341: ARRAY
112342: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
112343: LD_ADDR_VAR 0 25
112347: PUSH
112348: LD_VAR 0 6
112352: PUSH
112353: LD_INT 9
112355: ARRAY
112356: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
112357: LD_ADDR_VAR 0 26
112361: PUSH
112362: LD_VAR 0 6
112366: PUSH
112367: LD_INT 10
112369: ARRAY
112370: ST_TO_ADDR
// end else
112371: GO 112453
// begin f_ignore_area := false ;
112373: LD_ADDR_VAR 0 17
112377: PUSH
112378: LD_INT 0
112380: ST_TO_ADDR
// f_capture := false ;
112381: LD_ADDR_VAR 0 18
112385: PUSH
112386: LD_INT 0
112388: ST_TO_ADDR
// f_ignore_civ := false ;
112389: LD_ADDR_VAR 0 19
112393: PUSH
112394: LD_INT 0
112396: ST_TO_ADDR
// f_murder := false ;
112397: LD_ADDR_VAR 0 20
112401: PUSH
112402: LD_INT 0
112404: ST_TO_ADDR
// f_mines := false ;
112405: LD_ADDR_VAR 0 21
112409: PUSH
112410: LD_INT 0
112412: ST_TO_ADDR
// f_repair := false ;
112413: LD_ADDR_VAR 0 22
112417: PUSH
112418: LD_INT 0
112420: ST_TO_ADDR
// f_heal := false ;
112421: LD_ADDR_VAR 0 23
112425: PUSH
112426: LD_INT 0
112428: ST_TO_ADDR
// f_spacetime := false ;
112429: LD_ADDR_VAR 0 24
112433: PUSH
112434: LD_INT 0
112436: ST_TO_ADDR
// f_attack_depot := false ;
112437: LD_ADDR_VAR 0 25
112441: PUSH
112442: LD_INT 0
112444: ST_TO_ADDR
// f_crawl := false ;
112445: LD_ADDR_VAR 0 26
112449: PUSH
112450: LD_INT 0
112452: ST_TO_ADDR
// end ; if f_heal then
112453: LD_VAR 0 23
112457: IFFALSE 112484
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
112459: LD_ADDR_VAR 0 31
112463: PUSH
112464: LD_VAR 0 4
112468: PPUSH
112469: LD_INT 25
112471: PUSH
112472: LD_INT 4
112474: PUSH
112475: EMPTY
112476: LIST
112477: LIST
112478: PPUSH
112479: CALL_OW 72
112483: ST_TO_ADDR
// if f_repair then
112484: LD_VAR 0 22
112488: IFFALSE 112515
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
112490: LD_ADDR_VAR 0 33
112494: PUSH
112495: LD_VAR 0 4
112499: PPUSH
112500: LD_INT 25
112502: PUSH
112503: LD_INT 3
112505: PUSH
112506: EMPTY
112507: LIST
112508: LIST
112509: PPUSH
112510: CALL_OW 72
112514: ST_TO_ADDR
// units_path := [ ] ;
112515: LD_ADDR_VAR 0 16
112519: PUSH
112520: EMPTY
112521: ST_TO_ADDR
// for i = 1 to group do
112522: LD_ADDR_VAR 0 7
112526: PUSH
112527: DOUBLE
112528: LD_INT 1
112530: DEC
112531: ST_TO_ADDR
112532: LD_VAR 0 4
112536: PUSH
112537: FOR_TO
112538: IFFALSE 112567
// units_path := Replace ( units_path , i , path ) ;
112540: LD_ADDR_VAR 0 16
112544: PUSH
112545: LD_VAR 0 16
112549: PPUSH
112550: LD_VAR 0 7
112554: PPUSH
112555: LD_VAR 0 5
112559: PPUSH
112560: CALL_OW 1
112564: ST_TO_ADDR
112565: GO 112537
112567: POP
112568: POP
// repeat for i = group downto 1 do
112569: LD_ADDR_VAR 0 7
112573: PUSH
112574: DOUBLE
112575: LD_VAR 0 4
112579: INC
112580: ST_TO_ADDR
112581: LD_INT 1
112583: PUSH
112584: FOR_DOWNTO
112585: IFFALSE 116707
// begin wait ( 5 ) ;
112587: LD_INT 5
112589: PPUSH
112590: CALL_OW 67
// tmp := [ ] ;
112594: LD_ADDR_VAR 0 14
112598: PUSH
112599: EMPTY
112600: ST_TO_ADDR
// attacking := false ;
112601: LD_ADDR_VAR 0 29
112605: PUSH
112606: LD_INT 0
112608: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112609: LD_VAR 0 4
112613: PUSH
112614: LD_VAR 0 7
112618: ARRAY
112619: PPUSH
112620: CALL_OW 301
112624: PUSH
112625: LD_VAR 0 4
112629: PUSH
112630: LD_VAR 0 7
112634: ARRAY
112635: NOT
112636: OR
112637: IFFALSE 112746
// begin if GetType ( group [ i ] ) = unit_human then
112639: LD_VAR 0 4
112643: PUSH
112644: LD_VAR 0 7
112648: ARRAY
112649: PPUSH
112650: CALL_OW 247
112654: PUSH
112655: LD_INT 1
112657: EQUAL
112658: IFFALSE 112704
// begin to_heal := to_heal diff group [ i ] ;
112660: LD_ADDR_VAR 0 30
112664: PUSH
112665: LD_VAR 0 30
112669: PUSH
112670: LD_VAR 0 4
112674: PUSH
112675: LD_VAR 0 7
112679: ARRAY
112680: DIFF
112681: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112682: LD_ADDR_VAR 0 31
112686: PUSH
112687: LD_VAR 0 31
112691: PUSH
112692: LD_VAR 0 4
112696: PUSH
112697: LD_VAR 0 7
112701: ARRAY
112702: DIFF
112703: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112704: LD_ADDR_VAR 0 4
112708: PUSH
112709: LD_VAR 0 4
112713: PPUSH
112714: LD_VAR 0 7
112718: PPUSH
112719: CALL_OW 3
112723: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112724: LD_ADDR_VAR 0 16
112728: PUSH
112729: LD_VAR 0 16
112733: PPUSH
112734: LD_VAR 0 7
112738: PPUSH
112739: CALL_OW 3
112743: ST_TO_ADDR
// continue ;
112744: GO 112584
// end ; if f_repair then
112746: LD_VAR 0 22
112750: IFFALSE 113239
// begin if GetType ( group [ i ] ) = unit_vehicle then
112752: LD_VAR 0 4
112756: PUSH
112757: LD_VAR 0 7
112761: ARRAY
112762: PPUSH
112763: CALL_OW 247
112767: PUSH
112768: LD_INT 2
112770: EQUAL
112771: IFFALSE 112961
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112773: LD_VAR 0 4
112777: PUSH
112778: LD_VAR 0 7
112782: ARRAY
112783: PPUSH
112784: CALL_OW 256
112788: PUSH
112789: LD_INT 700
112791: LESS
112792: PUSH
112793: LD_VAR 0 4
112797: PUSH
112798: LD_VAR 0 7
112802: ARRAY
112803: PUSH
112804: LD_VAR 0 32
112808: IN
112809: NOT
112810: AND
112811: IFFALSE 112835
// to_repair := to_repair union group [ i ] ;
112813: LD_ADDR_VAR 0 32
112817: PUSH
112818: LD_VAR 0 32
112822: PUSH
112823: LD_VAR 0 4
112827: PUSH
112828: LD_VAR 0 7
112832: ARRAY
112833: UNION
112834: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
112835: LD_VAR 0 4
112839: PUSH
112840: LD_VAR 0 7
112844: ARRAY
112845: PPUSH
112846: CALL_OW 256
112850: PUSH
112851: LD_INT 1000
112853: EQUAL
112854: PUSH
112855: LD_VAR 0 4
112859: PUSH
112860: LD_VAR 0 7
112864: ARRAY
112865: PUSH
112866: LD_VAR 0 32
112870: IN
112871: AND
112872: IFFALSE 112896
// to_repair := to_repair diff group [ i ] ;
112874: LD_ADDR_VAR 0 32
112878: PUSH
112879: LD_VAR 0 32
112883: PUSH
112884: LD_VAR 0 4
112888: PUSH
112889: LD_VAR 0 7
112893: ARRAY
112894: DIFF
112895: ST_TO_ADDR
// if group [ i ] in to_repair then
112896: LD_VAR 0 4
112900: PUSH
112901: LD_VAR 0 7
112905: ARRAY
112906: PUSH
112907: LD_VAR 0 32
112911: IN
112912: IFFALSE 112959
// begin if not IsInArea ( group [ i ] , f_repair ) then
112914: LD_VAR 0 4
112918: PUSH
112919: LD_VAR 0 7
112923: ARRAY
112924: PPUSH
112925: LD_VAR 0 22
112929: PPUSH
112930: CALL_OW 308
112934: NOT
112935: IFFALSE 112957
// ComMoveToArea ( group [ i ] , f_repair ) ;
112937: LD_VAR 0 4
112941: PUSH
112942: LD_VAR 0 7
112946: ARRAY
112947: PPUSH
112948: LD_VAR 0 22
112952: PPUSH
112953: CALL_OW 113
// continue ;
112957: GO 112584
// end ; end else
112959: GO 113239
// if group [ i ] in repairs then
112961: LD_VAR 0 4
112965: PUSH
112966: LD_VAR 0 7
112970: ARRAY
112971: PUSH
112972: LD_VAR 0 33
112976: IN
112977: IFFALSE 113239
// begin if IsInUnit ( group [ i ] ) then
112979: LD_VAR 0 4
112983: PUSH
112984: LD_VAR 0 7
112988: ARRAY
112989: PPUSH
112990: CALL_OW 310
112994: IFFALSE 113062
// begin z := IsInUnit ( group [ i ] ) ;
112996: LD_ADDR_VAR 0 13
113000: PUSH
113001: LD_VAR 0 4
113005: PUSH
113006: LD_VAR 0 7
113010: ARRAY
113011: PPUSH
113012: CALL_OW 310
113016: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
113017: LD_VAR 0 13
113021: PUSH
113022: LD_VAR 0 32
113026: IN
113027: PUSH
113028: LD_VAR 0 13
113032: PPUSH
113033: LD_VAR 0 22
113037: PPUSH
113038: CALL_OW 308
113042: AND
113043: IFFALSE 113060
// ComExitVehicle ( group [ i ] ) ;
113045: LD_VAR 0 4
113049: PUSH
113050: LD_VAR 0 7
113054: ARRAY
113055: PPUSH
113056: CALL_OW 121
// end else
113060: GO 113239
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
113062: LD_ADDR_VAR 0 13
113066: PUSH
113067: LD_VAR 0 4
113071: PPUSH
113072: LD_INT 95
113074: PUSH
113075: LD_VAR 0 22
113079: PUSH
113080: EMPTY
113081: LIST
113082: LIST
113083: PUSH
113084: LD_INT 58
113086: PUSH
113087: EMPTY
113088: LIST
113089: PUSH
113090: EMPTY
113091: LIST
113092: LIST
113093: PPUSH
113094: CALL_OW 72
113098: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
113099: LD_VAR 0 4
113103: PUSH
113104: LD_VAR 0 7
113108: ARRAY
113109: PPUSH
113110: CALL_OW 314
113114: NOT
113115: IFFALSE 113237
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
113117: LD_ADDR_VAR 0 10
113121: PUSH
113122: LD_VAR 0 13
113126: PPUSH
113127: LD_VAR 0 4
113131: PUSH
113132: LD_VAR 0 7
113136: ARRAY
113137: PPUSH
113138: CALL_OW 74
113142: ST_TO_ADDR
// if not x then
113143: LD_VAR 0 10
113147: NOT
113148: IFFALSE 113152
// continue ;
113150: GO 112584
// if GetLives ( x ) < 1000 then
113152: LD_VAR 0 10
113156: PPUSH
113157: CALL_OW 256
113161: PUSH
113162: LD_INT 1000
113164: LESS
113165: IFFALSE 113189
// ComRepairVehicle ( group [ i ] , x ) else
113167: LD_VAR 0 4
113171: PUSH
113172: LD_VAR 0 7
113176: ARRAY
113177: PPUSH
113178: LD_VAR 0 10
113182: PPUSH
113183: CALL_OW 129
113187: GO 113237
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
113189: LD_VAR 0 23
113193: PUSH
113194: LD_VAR 0 4
113198: PUSH
113199: LD_VAR 0 7
113203: ARRAY
113204: PPUSH
113205: CALL_OW 256
113209: PUSH
113210: LD_INT 1000
113212: LESS
113213: AND
113214: NOT
113215: IFFALSE 113237
// ComEnterUnit ( group [ i ] , x ) ;
113217: LD_VAR 0 4
113221: PUSH
113222: LD_VAR 0 7
113226: ARRAY
113227: PPUSH
113228: LD_VAR 0 10
113232: PPUSH
113233: CALL_OW 120
// end ; continue ;
113237: GO 112584
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
113239: LD_VAR 0 23
113243: PUSH
113244: LD_VAR 0 4
113248: PUSH
113249: LD_VAR 0 7
113253: ARRAY
113254: PPUSH
113255: CALL_OW 247
113259: PUSH
113260: LD_INT 1
113262: EQUAL
113263: AND
113264: IFFALSE 113742
// begin if group [ i ] in healers then
113266: LD_VAR 0 4
113270: PUSH
113271: LD_VAR 0 7
113275: ARRAY
113276: PUSH
113277: LD_VAR 0 31
113281: IN
113282: IFFALSE 113555
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
113284: LD_VAR 0 4
113288: PUSH
113289: LD_VAR 0 7
113293: ARRAY
113294: PPUSH
113295: LD_VAR 0 23
113299: PPUSH
113300: CALL_OW 308
113304: NOT
113305: PUSH
113306: LD_VAR 0 4
113310: PUSH
113311: LD_VAR 0 7
113315: ARRAY
113316: PPUSH
113317: CALL_OW 314
113321: NOT
113322: AND
113323: IFFALSE 113347
// ComMoveToArea ( group [ i ] , f_heal ) else
113325: LD_VAR 0 4
113329: PUSH
113330: LD_VAR 0 7
113334: ARRAY
113335: PPUSH
113336: LD_VAR 0 23
113340: PPUSH
113341: CALL_OW 113
113345: GO 113553
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
113347: LD_VAR 0 4
113351: PUSH
113352: LD_VAR 0 7
113356: ARRAY
113357: PPUSH
113358: CALL 84201 0 1
113362: PPUSH
113363: CALL_OW 256
113367: PUSH
113368: LD_INT 1000
113370: EQUAL
113371: IFFALSE 113390
// ComStop ( group [ i ] ) else
113373: LD_VAR 0 4
113377: PUSH
113378: LD_VAR 0 7
113382: ARRAY
113383: PPUSH
113384: CALL_OW 141
113388: GO 113553
// if not HasTask ( group [ i ] ) and to_heal then
113390: LD_VAR 0 4
113394: PUSH
113395: LD_VAR 0 7
113399: ARRAY
113400: PPUSH
113401: CALL_OW 314
113405: NOT
113406: PUSH
113407: LD_VAR 0 30
113411: AND
113412: IFFALSE 113553
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
113414: LD_ADDR_VAR 0 13
113418: PUSH
113419: LD_VAR 0 30
113423: PPUSH
113424: LD_INT 3
113426: PUSH
113427: LD_INT 54
113429: PUSH
113430: EMPTY
113431: LIST
113432: PUSH
113433: EMPTY
113434: LIST
113435: LIST
113436: PPUSH
113437: CALL_OW 72
113441: PPUSH
113442: LD_VAR 0 4
113446: PUSH
113447: LD_VAR 0 7
113451: ARRAY
113452: PPUSH
113453: CALL_OW 74
113457: ST_TO_ADDR
// if z then
113458: LD_VAR 0 13
113462: IFFALSE 113553
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
113464: LD_INT 91
113466: PUSH
113467: LD_VAR 0 13
113471: PUSH
113472: LD_INT 10
113474: PUSH
113475: EMPTY
113476: LIST
113477: LIST
113478: LIST
113479: PUSH
113480: LD_INT 81
113482: PUSH
113483: LD_VAR 0 13
113487: PPUSH
113488: CALL_OW 255
113492: PUSH
113493: EMPTY
113494: LIST
113495: LIST
113496: PUSH
113497: EMPTY
113498: LIST
113499: LIST
113500: PPUSH
113501: CALL_OW 69
113505: PUSH
113506: LD_INT 0
113508: EQUAL
113509: IFFALSE 113533
// ComHeal ( group [ i ] , z ) else
113511: LD_VAR 0 4
113515: PUSH
113516: LD_VAR 0 7
113520: ARRAY
113521: PPUSH
113522: LD_VAR 0 13
113526: PPUSH
113527: CALL_OW 128
113531: GO 113553
// ComMoveToArea ( group [ i ] , f_heal ) ;
113533: LD_VAR 0 4
113537: PUSH
113538: LD_VAR 0 7
113542: ARRAY
113543: PPUSH
113544: LD_VAR 0 23
113548: PPUSH
113549: CALL_OW 113
// end ; continue ;
113553: GO 112584
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113555: LD_VAR 0 4
113559: PUSH
113560: LD_VAR 0 7
113564: ARRAY
113565: PPUSH
113566: CALL_OW 256
113570: PUSH
113571: LD_INT 700
113573: LESS
113574: PUSH
113575: LD_VAR 0 4
113579: PUSH
113580: LD_VAR 0 7
113584: ARRAY
113585: PUSH
113586: LD_VAR 0 30
113590: IN
113591: NOT
113592: AND
113593: IFFALSE 113617
// to_heal := to_heal union group [ i ] ;
113595: LD_ADDR_VAR 0 30
113599: PUSH
113600: LD_VAR 0 30
113604: PUSH
113605: LD_VAR 0 4
113609: PUSH
113610: LD_VAR 0 7
113614: ARRAY
113615: UNION
113616: ST_TO_ADDR
// if group [ i ] in to_heal then
113617: LD_VAR 0 4
113621: PUSH
113622: LD_VAR 0 7
113626: ARRAY
113627: PUSH
113628: LD_VAR 0 30
113632: IN
113633: IFFALSE 113742
// begin if GetLives ( group [ i ] ) = 1000 then
113635: LD_VAR 0 4
113639: PUSH
113640: LD_VAR 0 7
113644: ARRAY
113645: PPUSH
113646: CALL_OW 256
113650: PUSH
113651: LD_INT 1000
113653: EQUAL
113654: IFFALSE 113680
// to_heal := to_heal diff group [ i ] else
113656: LD_ADDR_VAR 0 30
113660: PUSH
113661: LD_VAR 0 30
113665: PUSH
113666: LD_VAR 0 4
113670: PUSH
113671: LD_VAR 0 7
113675: ARRAY
113676: DIFF
113677: ST_TO_ADDR
113678: GO 113742
// begin if not IsInArea ( group [ i ] , to_heal ) then
113680: LD_VAR 0 4
113684: PUSH
113685: LD_VAR 0 7
113689: ARRAY
113690: PPUSH
113691: LD_VAR 0 30
113695: PPUSH
113696: CALL_OW 308
113700: NOT
113701: IFFALSE 113725
// ComMoveToArea ( group [ i ] , f_heal ) else
113703: LD_VAR 0 4
113707: PUSH
113708: LD_VAR 0 7
113712: ARRAY
113713: PPUSH
113714: LD_VAR 0 23
113718: PPUSH
113719: CALL_OW 113
113723: GO 113740
// ComHold ( group [ i ] ) ;
113725: LD_VAR 0 4
113729: PUSH
113730: LD_VAR 0 7
113734: ARRAY
113735: PPUSH
113736: CALL_OW 140
// continue ;
113740: GO 112584
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113742: LD_VAR 0 4
113746: PUSH
113747: LD_VAR 0 7
113751: ARRAY
113752: PPUSH
113753: LD_INT 10
113755: PPUSH
113756: CALL 81972 0 2
113760: NOT
113761: PUSH
113762: LD_VAR 0 16
113766: PUSH
113767: LD_VAR 0 7
113771: ARRAY
113772: PUSH
113773: EMPTY
113774: EQUAL
113775: NOT
113776: AND
113777: IFFALSE 114043
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113779: LD_VAR 0 4
113783: PUSH
113784: LD_VAR 0 7
113788: ARRAY
113789: PPUSH
113790: CALL_OW 262
113794: PUSH
113795: LD_INT 1
113797: PUSH
113798: LD_INT 2
113800: PUSH
113801: EMPTY
113802: LIST
113803: LIST
113804: IN
113805: IFFALSE 113846
// if GetFuel ( group [ i ] ) < 10 then
113807: LD_VAR 0 4
113811: PUSH
113812: LD_VAR 0 7
113816: ARRAY
113817: PPUSH
113818: CALL_OW 261
113822: PUSH
113823: LD_INT 10
113825: LESS
113826: IFFALSE 113846
// SetFuel ( group [ i ] , 12 ) ;
113828: LD_VAR 0 4
113832: PUSH
113833: LD_VAR 0 7
113837: ARRAY
113838: PPUSH
113839: LD_INT 12
113841: PPUSH
113842: CALL_OW 240
// if units_path [ i ] then
113846: LD_VAR 0 16
113850: PUSH
113851: LD_VAR 0 7
113855: ARRAY
113856: IFFALSE 114041
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
113858: LD_VAR 0 4
113862: PUSH
113863: LD_VAR 0 7
113867: ARRAY
113868: PPUSH
113869: LD_VAR 0 16
113873: PUSH
113874: LD_VAR 0 7
113878: ARRAY
113879: PUSH
113880: LD_INT 1
113882: ARRAY
113883: PUSH
113884: LD_INT 1
113886: ARRAY
113887: PPUSH
113888: LD_VAR 0 16
113892: PUSH
113893: LD_VAR 0 7
113897: ARRAY
113898: PUSH
113899: LD_INT 1
113901: ARRAY
113902: PUSH
113903: LD_INT 2
113905: ARRAY
113906: PPUSH
113907: CALL_OW 297
113911: PUSH
113912: LD_INT 6
113914: GREATER
113915: IFFALSE 113990
// begin if not HasTask ( group [ i ] ) then
113917: LD_VAR 0 4
113921: PUSH
113922: LD_VAR 0 7
113926: ARRAY
113927: PPUSH
113928: CALL_OW 314
113932: NOT
113933: IFFALSE 113988
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
113935: LD_VAR 0 4
113939: PUSH
113940: LD_VAR 0 7
113944: ARRAY
113945: PPUSH
113946: LD_VAR 0 16
113950: PUSH
113951: LD_VAR 0 7
113955: ARRAY
113956: PUSH
113957: LD_INT 1
113959: ARRAY
113960: PUSH
113961: LD_INT 1
113963: ARRAY
113964: PPUSH
113965: LD_VAR 0 16
113969: PUSH
113970: LD_VAR 0 7
113974: ARRAY
113975: PUSH
113976: LD_INT 1
113978: ARRAY
113979: PUSH
113980: LD_INT 2
113982: ARRAY
113983: PPUSH
113984: CALL_OW 114
// end else
113988: GO 114041
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
113990: LD_ADDR_VAR 0 15
113994: PUSH
113995: LD_VAR 0 16
113999: PUSH
114000: LD_VAR 0 7
114004: ARRAY
114005: PPUSH
114006: LD_INT 1
114008: PPUSH
114009: CALL_OW 3
114013: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
114014: LD_ADDR_VAR 0 16
114018: PUSH
114019: LD_VAR 0 16
114023: PPUSH
114024: LD_VAR 0 7
114028: PPUSH
114029: LD_VAR 0 15
114033: PPUSH
114034: CALL_OW 1
114038: ST_TO_ADDR
// continue ;
114039: GO 112584
// end ; end ; end else
114041: GO 116705
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
114043: LD_ADDR_VAR 0 14
114047: PUSH
114048: LD_INT 81
114050: PUSH
114051: LD_VAR 0 4
114055: PUSH
114056: LD_VAR 0 7
114060: ARRAY
114061: PPUSH
114062: CALL_OW 255
114066: PUSH
114067: EMPTY
114068: LIST
114069: LIST
114070: PPUSH
114071: CALL_OW 69
114075: ST_TO_ADDR
// if not tmp then
114076: LD_VAR 0 14
114080: NOT
114081: IFFALSE 114085
// continue ;
114083: GO 112584
// if f_ignore_area then
114085: LD_VAR 0 17
114089: IFFALSE 114177
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
114091: LD_ADDR_VAR 0 15
114095: PUSH
114096: LD_VAR 0 14
114100: PPUSH
114101: LD_INT 3
114103: PUSH
114104: LD_INT 92
114106: PUSH
114107: LD_VAR 0 17
114111: PUSH
114112: LD_INT 1
114114: ARRAY
114115: PUSH
114116: LD_VAR 0 17
114120: PUSH
114121: LD_INT 2
114123: ARRAY
114124: PUSH
114125: LD_VAR 0 17
114129: PUSH
114130: LD_INT 3
114132: ARRAY
114133: PUSH
114134: EMPTY
114135: LIST
114136: LIST
114137: LIST
114138: LIST
114139: PUSH
114140: EMPTY
114141: LIST
114142: LIST
114143: PPUSH
114144: CALL_OW 72
114148: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114149: LD_VAR 0 14
114153: PUSH
114154: LD_VAR 0 15
114158: DIFF
114159: IFFALSE 114177
// tmp := tmp diff tmp2 ;
114161: LD_ADDR_VAR 0 14
114165: PUSH
114166: LD_VAR 0 14
114170: PUSH
114171: LD_VAR 0 15
114175: DIFF
114176: ST_TO_ADDR
// end ; if not f_murder then
114177: LD_VAR 0 20
114181: NOT
114182: IFFALSE 114240
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
114184: LD_ADDR_VAR 0 15
114188: PUSH
114189: LD_VAR 0 14
114193: PPUSH
114194: LD_INT 3
114196: PUSH
114197: LD_INT 50
114199: PUSH
114200: EMPTY
114201: LIST
114202: PUSH
114203: EMPTY
114204: LIST
114205: LIST
114206: PPUSH
114207: CALL_OW 72
114211: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114212: LD_VAR 0 14
114216: PUSH
114217: LD_VAR 0 15
114221: DIFF
114222: IFFALSE 114240
// tmp := tmp diff tmp2 ;
114224: LD_ADDR_VAR 0 14
114228: PUSH
114229: LD_VAR 0 14
114233: PUSH
114234: LD_VAR 0 15
114238: DIFF
114239: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
114240: LD_ADDR_VAR 0 14
114244: PUSH
114245: LD_VAR 0 4
114249: PUSH
114250: LD_VAR 0 7
114254: ARRAY
114255: PPUSH
114256: LD_VAR 0 14
114260: PPUSH
114261: LD_INT 1
114263: PPUSH
114264: LD_INT 1
114266: PPUSH
114267: CALL 54516 0 4
114271: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
114272: LD_VAR 0 4
114276: PUSH
114277: LD_VAR 0 7
114281: ARRAY
114282: PPUSH
114283: CALL_OW 257
114287: PUSH
114288: LD_INT 1
114290: EQUAL
114291: IFFALSE 114739
// begin if WantPlant ( group [ i ] ) then
114293: LD_VAR 0 4
114297: PUSH
114298: LD_VAR 0 7
114302: ARRAY
114303: PPUSH
114304: CALL 54017 0 1
114308: IFFALSE 114312
// continue ;
114310: GO 112584
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
114312: LD_VAR 0 18
114316: PUSH
114317: LD_VAR 0 4
114321: PUSH
114322: LD_VAR 0 7
114326: ARRAY
114327: PPUSH
114328: CALL_OW 310
114332: NOT
114333: AND
114334: PUSH
114335: LD_VAR 0 14
114339: PUSH
114340: LD_INT 1
114342: ARRAY
114343: PUSH
114344: LD_VAR 0 14
114348: PPUSH
114349: LD_INT 21
114351: PUSH
114352: LD_INT 2
114354: PUSH
114355: EMPTY
114356: LIST
114357: LIST
114358: PUSH
114359: LD_INT 58
114361: PUSH
114362: EMPTY
114363: LIST
114364: PUSH
114365: EMPTY
114366: LIST
114367: LIST
114368: PPUSH
114369: CALL_OW 72
114373: IN
114374: AND
114375: IFFALSE 114411
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
114377: LD_VAR 0 4
114381: PUSH
114382: LD_VAR 0 7
114386: ARRAY
114387: PPUSH
114388: LD_VAR 0 14
114392: PUSH
114393: LD_INT 1
114395: ARRAY
114396: PPUSH
114397: CALL_OW 120
// attacking := true ;
114401: LD_ADDR_VAR 0 29
114405: PUSH
114406: LD_INT 1
114408: ST_TO_ADDR
// continue ;
114409: GO 112584
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
114411: LD_VAR 0 26
114415: PUSH
114416: LD_VAR 0 4
114420: PUSH
114421: LD_VAR 0 7
114425: ARRAY
114426: PPUSH
114427: CALL_OW 257
114431: PUSH
114432: LD_INT 1
114434: EQUAL
114435: AND
114436: PUSH
114437: LD_VAR 0 4
114441: PUSH
114442: LD_VAR 0 7
114446: ARRAY
114447: PPUSH
114448: CALL_OW 256
114452: PUSH
114453: LD_INT 800
114455: LESS
114456: AND
114457: PUSH
114458: LD_VAR 0 4
114462: PUSH
114463: LD_VAR 0 7
114467: ARRAY
114468: PPUSH
114469: CALL_OW 318
114473: NOT
114474: AND
114475: IFFALSE 114492
// ComCrawl ( group [ i ] ) ;
114477: LD_VAR 0 4
114481: PUSH
114482: LD_VAR 0 7
114486: ARRAY
114487: PPUSH
114488: CALL_OW 137
// if f_mines then
114492: LD_VAR 0 21
114496: IFFALSE 114739
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
114498: LD_VAR 0 14
114502: PUSH
114503: LD_INT 1
114505: ARRAY
114506: PPUSH
114507: CALL_OW 247
114511: PUSH
114512: LD_INT 3
114514: EQUAL
114515: PUSH
114516: LD_VAR 0 14
114520: PUSH
114521: LD_INT 1
114523: ARRAY
114524: PUSH
114525: LD_VAR 0 27
114529: IN
114530: NOT
114531: AND
114532: IFFALSE 114739
// begin x := GetX ( tmp [ 1 ] ) ;
114534: LD_ADDR_VAR 0 10
114538: PUSH
114539: LD_VAR 0 14
114543: PUSH
114544: LD_INT 1
114546: ARRAY
114547: PPUSH
114548: CALL_OW 250
114552: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114553: LD_ADDR_VAR 0 11
114557: PUSH
114558: LD_VAR 0 14
114562: PUSH
114563: LD_INT 1
114565: ARRAY
114566: PPUSH
114567: CALL_OW 251
114571: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114572: LD_ADDR_VAR 0 12
114576: PUSH
114577: LD_VAR 0 4
114581: PUSH
114582: LD_VAR 0 7
114586: ARRAY
114587: PPUSH
114588: CALL 82057 0 1
114592: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114593: LD_VAR 0 4
114597: PUSH
114598: LD_VAR 0 7
114602: ARRAY
114603: PPUSH
114604: LD_VAR 0 10
114608: PPUSH
114609: LD_VAR 0 11
114613: PPUSH
114614: LD_VAR 0 14
114618: PUSH
114619: LD_INT 1
114621: ARRAY
114622: PPUSH
114623: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114627: LD_VAR 0 4
114631: PUSH
114632: LD_VAR 0 7
114636: ARRAY
114637: PPUSH
114638: LD_VAR 0 10
114642: PPUSH
114643: LD_VAR 0 12
114647: PPUSH
114648: LD_INT 7
114650: PPUSH
114651: CALL_OW 272
114655: PPUSH
114656: LD_VAR 0 11
114660: PPUSH
114661: LD_VAR 0 12
114665: PPUSH
114666: LD_INT 7
114668: PPUSH
114669: CALL_OW 273
114673: PPUSH
114674: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114678: LD_VAR 0 4
114682: PUSH
114683: LD_VAR 0 7
114687: ARRAY
114688: PPUSH
114689: LD_INT 71
114691: PPUSH
114692: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114696: LD_ADDR_VAR 0 27
114700: PUSH
114701: LD_VAR 0 27
114705: PPUSH
114706: LD_VAR 0 27
114710: PUSH
114711: LD_INT 1
114713: PLUS
114714: PPUSH
114715: LD_VAR 0 14
114719: PUSH
114720: LD_INT 1
114722: ARRAY
114723: PPUSH
114724: CALL_OW 1
114728: ST_TO_ADDR
// attacking := true ;
114729: LD_ADDR_VAR 0 29
114733: PUSH
114734: LD_INT 1
114736: ST_TO_ADDR
// continue ;
114737: GO 112584
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114739: LD_VAR 0 4
114743: PUSH
114744: LD_VAR 0 7
114748: ARRAY
114749: PPUSH
114750: CALL_OW 257
114754: PUSH
114755: LD_INT 17
114757: EQUAL
114758: PUSH
114759: LD_VAR 0 4
114763: PUSH
114764: LD_VAR 0 7
114768: ARRAY
114769: PPUSH
114770: CALL_OW 110
114774: PUSH
114775: LD_INT 71
114777: EQUAL
114778: NOT
114779: AND
114780: IFFALSE 114926
// begin attacking := false ;
114782: LD_ADDR_VAR 0 29
114786: PUSH
114787: LD_INT 0
114789: ST_TO_ADDR
// k := 5 ;
114790: LD_ADDR_VAR 0 9
114794: PUSH
114795: LD_INT 5
114797: ST_TO_ADDR
// if tmp < k then
114798: LD_VAR 0 14
114802: PUSH
114803: LD_VAR 0 9
114807: LESS
114808: IFFALSE 114820
// k := tmp ;
114810: LD_ADDR_VAR 0 9
114814: PUSH
114815: LD_VAR 0 14
114819: ST_TO_ADDR
// for j = 1 to k do
114820: LD_ADDR_VAR 0 8
114824: PUSH
114825: DOUBLE
114826: LD_INT 1
114828: DEC
114829: ST_TO_ADDR
114830: LD_VAR 0 9
114834: PUSH
114835: FOR_TO
114836: IFFALSE 114924
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
114838: LD_VAR 0 14
114842: PUSH
114843: LD_VAR 0 8
114847: ARRAY
114848: PUSH
114849: LD_VAR 0 14
114853: PPUSH
114854: LD_INT 58
114856: PUSH
114857: EMPTY
114858: LIST
114859: PPUSH
114860: CALL_OW 72
114864: IN
114865: NOT
114866: IFFALSE 114922
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114868: LD_VAR 0 4
114872: PUSH
114873: LD_VAR 0 7
114877: ARRAY
114878: PPUSH
114879: LD_VAR 0 14
114883: PUSH
114884: LD_VAR 0 8
114888: ARRAY
114889: PPUSH
114890: CALL_OW 115
// attacking := true ;
114894: LD_ADDR_VAR 0 29
114898: PUSH
114899: LD_INT 1
114901: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
114902: LD_VAR 0 4
114906: PUSH
114907: LD_VAR 0 7
114911: ARRAY
114912: PPUSH
114913: LD_INT 71
114915: PPUSH
114916: CALL_OW 109
// continue ;
114920: GO 114835
// end ; end ;
114922: GO 114835
114924: POP
114925: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
114926: LD_VAR 0 4
114930: PUSH
114931: LD_VAR 0 7
114935: ARRAY
114936: PPUSH
114937: CALL_OW 257
114941: PUSH
114942: LD_INT 8
114944: EQUAL
114945: PUSH
114946: LD_VAR 0 4
114950: PUSH
114951: LD_VAR 0 7
114955: ARRAY
114956: PPUSH
114957: CALL_OW 264
114961: PUSH
114962: LD_INT 28
114964: PUSH
114965: LD_INT 45
114967: PUSH
114968: LD_INT 7
114970: PUSH
114971: LD_INT 47
114973: PUSH
114974: EMPTY
114975: LIST
114976: LIST
114977: LIST
114978: LIST
114979: IN
114980: OR
114981: IFFALSE 115237
// begin attacking := false ;
114983: LD_ADDR_VAR 0 29
114987: PUSH
114988: LD_INT 0
114990: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
114991: LD_VAR 0 14
114995: PUSH
114996: LD_INT 1
114998: ARRAY
114999: PPUSH
115000: CALL_OW 266
115004: PUSH
115005: LD_INT 32
115007: PUSH
115008: LD_INT 31
115010: PUSH
115011: LD_INT 33
115013: PUSH
115014: LD_INT 4
115016: PUSH
115017: LD_INT 5
115019: PUSH
115020: EMPTY
115021: LIST
115022: LIST
115023: LIST
115024: LIST
115025: LIST
115026: IN
115027: IFFALSE 115213
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
115029: LD_ADDR_VAR 0 9
115033: PUSH
115034: LD_VAR 0 14
115038: PUSH
115039: LD_INT 1
115041: ARRAY
115042: PPUSH
115043: CALL_OW 266
115047: PPUSH
115048: LD_VAR 0 14
115052: PUSH
115053: LD_INT 1
115055: ARRAY
115056: PPUSH
115057: CALL_OW 250
115061: PPUSH
115062: LD_VAR 0 14
115066: PUSH
115067: LD_INT 1
115069: ARRAY
115070: PPUSH
115071: CALL_OW 251
115075: PPUSH
115076: LD_VAR 0 14
115080: PUSH
115081: LD_INT 1
115083: ARRAY
115084: PPUSH
115085: CALL_OW 254
115089: PPUSH
115090: LD_VAR 0 14
115094: PUSH
115095: LD_INT 1
115097: ARRAY
115098: PPUSH
115099: CALL_OW 248
115103: PPUSH
115104: LD_INT 0
115106: PPUSH
115107: CALL 63427 0 6
115111: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
115112: LD_ADDR_VAR 0 8
115116: PUSH
115117: LD_VAR 0 4
115121: PUSH
115122: LD_VAR 0 7
115126: ARRAY
115127: PPUSH
115128: LD_VAR 0 9
115132: PPUSH
115133: CALL 82170 0 2
115137: ST_TO_ADDR
// if j then
115138: LD_VAR 0 8
115142: IFFALSE 115211
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
115144: LD_VAR 0 8
115148: PUSH
115149: LD_INT 1
115151: ARRAY
115152: PPUSH
115153: LD_VAR 0 8
115157: PUSH
115158: LD_INT 2
115160: ARRAY
115161: PPUSH
115162: CALL_OW 488
115166: IFFALSE 115211
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
115168: LD_VAR 0 4
115172: PUSH
115173: LD_VAR 0 7
115177: ARRAY
115178: PPUSH
115179: LD_VAR 0 8
115183: PUSH
115184: LD_INT 1
115186: ARRAY
115187: PPUSH
115188: LD_VAR 0 8
115192: PUSH
115193: LD_INT 2
115195: ARRAY
115196: PPUSH
115197: CALL_OW 116
// attacking := true ;
115201: LD_ADDR_VAR 0 29
115205: PUSH
115206: LD_INT 1
115208: ST_TO_ADDR
// continue ;
115209: GO 112584
// end ; end else
115211: GO 115237
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115213: LD_VAR 0 4
115217: PUSH
115218: LD_VAR 0 7
115222: ARRAY
115223: PPUSH
115224: LD_VAR 0 14
115228: PUSH
115229: LD_INT 1
115231: ARRAY
115232: PPUSH
115233: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
115237: LD_VAR 0 4
115241: PUSH
115242: LD_VAR 0 7
115246: ARRAY
115247: PPUSH
115248: CALL_OW 265
115252: PUSH
115253: LD_INT 11
115255: EQUAL
115256: IFFALSE 115534
// begin k := 10 ;
115258: LD_ADDR_VAR 0 9
115262: PUSH
115263: LD_INT 10
115265: ST_TO_ADDR
// x := 0 ;
115266: LD_ADDR_VAR 0 10
115270: PUSH
115271: LD_INT 0
115273: ST_TO_ADDR
// if tmp < k then
115274: LD_VAR 0 14
115278: PUSH
115279: LD_VAR 0 9
115283: LESS
115284: IFFALSE 115296
// k := tmp ;
115286: LD_ADDR_VAR 0 9
115290: PUSH
115291: LD_VAR 0 14
115295: ST_TO_ADDR
// for j = k downto 1 do
115296: LD_ADDR_VAR 0 8
115300: PUSH
115301: DOUBLE
115302: LD_VAR 0 9
115306: INC
115307: ST_TO_ADDR
115308: LD_INT 1
115310: PUSH
115311: FOR_DOWNTO
115312: IFFALSE 115387
// begin if GetType ( tmp [ j ] ) = unit_human then
115314: LD_VAR 0 14
115318: PUSH
115319: LD_VAR 0 8
115323: ARRAY
115324: PPUSH
115325: CALL_OW 247
115329: PUSH
115330: LD_INT 1
115332: EQUAL
115333: IFFALSE 115385
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
115335: LD_VAR 0 4
115339: PUSH
115340: LD_VAR 0 7
115344: ARRAY
115345: PPUSH
115346: LD_VAR 0 14
115350: PUSH
115351: LD_VAR 0 8
115355: ARRAY
115356: PPUSH
115357: CALL 82424 0 2
// x := tmp [ j ] ;
115361: LD_ADDR_VAR 0 10
115365: PUSH
115366: LD_VAR 0 14
115370: PUSH
115371: LD_VAR 0 8
115375: ARRAY
115376: ST_TO_ADDR
// attacking := true ;
115377: LD_ADDR_VAR 0 29
115381: PUSH
115382: LD_INT 1
115384: ST_TO_ADDR
// end ; end ;
115385: GO 115311
115387: POP
115388: POP
// if not x then
115389: LD_VAR 0 10
115393: NOT
115394: IFFALSE 115534
// begin attacking := true ;
115396: LD_ADDR_VAR 0 29
115400: PUSH
115401: LD_INT 1
115403: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
115404: LD_VAR 0 4
115408: PUSH
115409: LD_VAR 0 7
115413: ARRAY
115414: PPUSH
115415: CALL_OW 250
115419: PPUSH
115420: LD_VAR 0 4
115424: PUSH
115425: LD_VAR 0 7
115429: ARRAY
115430: PPUSH
115431: CALL_OW 251
115435: PPUSH
115436: CALL_OW 546
115440: PUSH
115441: LD_INT 2
115443: ARRAY
115444: PUSH
115445: LD_VAR 0 14
115449: PUSH
115450: LD_INT 1
115452: ARRAY
115453: PPUSH
115454: CALL_OW 250
115458: PPUSH
115459: LD_VAR 0 14
115463: PUSH
115464: LD_INT 1
115466: ARRAY
115467: PPUSH
115468: CALL_OW 251
115472: PPUSH
115473: CALL_OW 546
115477: PUSH
115478: LD_INT 2
115480: ARRAY
115481: EQUAL
115482: IFFALSE 115510
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
115484: LD_VAR 0 4
115488: PUSH
115489: LD_VAR 0 7
115493: ARRAY
115494: PPUSH
115495: LD_VAR 0 14
115499: PUSH
115500: LD_INT 1
115502: ARRAY
115503: PPUSH
115504: CALL 82424 0 2
115508: GO 115534
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115510: LD_VAR 0 4
115514: PUSH
115515: LD_VAR 0 7
115519: ARRAY
115520: PPUSH
115521: LD_VAR 0 14
115525: PUSH
115526: LD_INT 1
115528: ARRAY
115529: PPUSH
115530: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115534: LD_VAR 0 4
115538: PUSH
115539: LD_VAR 0 7
115543: ARRAY
115544: PPUSH
115545: CALL_OW 264
115549: PUSH
115550: LD_INT 29
115552: EQUAL
115553: IFFALSE 115919
// begin if WantsToAttack ( group [ i ] ) in bombed then
115555: LD_VAR 0 4
115559: PUSH
115560: LD_VAR 0 7
115564: ARRAY
115565: PPUSH
115566: CALL_OW 319
115570: PUSH
115571: LD_VAR 0 28
115575: IN
115576: IFFALSE 115580
// continue ;
115578: GO 112584
// k := 8 ;
115580: LD_ADDR_VAR 0 9
115584: PUSH
115585: LD_INT 8
115587: ST_TO_ADDR
// x := 0 ;
115588: LD_ADDR_VAR 0 10
115592: PUSH
115593: LD_INT 0
115595: ST_TO_ADDR
// if tmp < k then
115596: LD_VAR 0 14
115600: PUSH
115601: LD_VAR 0 9
115605: LESS
115606: IFFALSE 115618
// k := tmp ;
115608: LD_ADDR_VAR 0 9
115612: PUSH
115613: LD_VAR 0 14
115617: ST_TO_ADDR
// for j = 1 to k do
115618: LD_ADDR_VAR 0 8
115622: PUSH
115623: DOUBLE
115624: LD_INT 1
115626: DEC
115627: ST_TO_ADDR
115628: LD_VAR 0 9
115632: PUSH
115633: FOR_TO
115634: IFFALSE 115766
// begin if GetType ( tmp [ j ] ) = unit_building then
115636: LD_VAR 0 14
115640: PUSH
115641: LD_VAR 0 8
115645: ARRAY
115646: PPUSH
115647: CALL_OW 247
115651: PUSH
115652: LD_INT 3
115654: EQUAL
115655: IFFALSE 115764
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115657: LD_VAR 0 14
115661: PUSH
115662: LD_VAR 0 8
115666: ARRAY
115667: PUSH
115668: LD_VAR 0 28
115672: IN
115673: NOT
115674: PUSH
115675: LD_VAR 0 14
115679: PUSH
115680: LD_VAR 0 8
115684: ARRAY
115685: PPUSH
115686: CALL_OW 313
115690: AND
115691: IFFALSE 115764
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115693: LD_VAR 0 4
115697: PUSH
115698: LD_VAR 0 7
115702: ARRAY
115703: PPUSH
115704: LD_VAR 0 14
115708: PUSH
115709: LD_VAR 0 8
115713: ARRAY
115714: PPUSH
115715: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115719: LD_ADDR_VAR 0 28
115723: PUSH
115724: LD_VAR 0 28
115728: PPUSH
115729: LD_VAR 0 28
115733: PUSH
115734: LD_INT 1
115736: PLUS
115737: PPUSH
115738: LD_VAR 0 14
115742: PUSH
115743: LD_VAR 0 8
115747: ARRAY
115748: PPUSH
115749: CALL_OW 1
115753: ST_TO_ADDR
// attacking := true ;
115754: LD_ADDR_VAR 0 29
115758: PUSH
115759: LD_INT 1
115761: ST_TO_ADDR
// break ;
115762: GO 115766
// end ; end ;
115764: GO 115633
115766: POP
115767: POP
// if not attacking and f_attack_depot then
115768: LD_VAR 0 29
115772: NOT
115773: PUSH
115774: LD_VAR 0 25
115778: AND
115779: IFFALSE 115874
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115781: LD_ADDR_VAR 0 13
115785: PUSH
115786: LD_VAR 0 14
115790: PPUSH
115791: LD_INT 2
115793: PUSH
115794: LD_INT 30
115796: PUSH
115797: LD_INT 0
115799: PUSH
115800: EMPTY
115801: LIST
115802: LIST
115803: PUSH
115804: LD_INT 30
115806: PUSH
115807: LD_INT 1
115809: PUSH
115810: EMPTY
115811: LIST
115812: LIST
115813: PUSH
115814: EMPTY
115815: LIST
115816: LIST
115817: LIST
115818: PPUSH
115819: CALL_OW 72
115823: ST_TO_ADDR
// if z then
115824: LD_VAR 0 13
115828: IFFALSE 115874
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
115830: LD_VAR 0 4
115834: PUSH
115835: LD_VAR 0 7
115839: ARRAY
115840: PPUSH
115841: LD_VAR 0 13
115845: PPUSH
115846: LD_VAR 0 4
115850: PUSH
115851: LD_VAR 0 7
115855: ARRAY
115856: PPUSH
115857: CALL_OW 74
115861: PPUSH
115862: CALL_OW 115
// attacking := true ;
115866: LD_ADDR_VAR 0 29
115870: PUSH
115871: LD_INT 1
115873: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
115874: LD_VAR 0 4
115878: PUSH
115879: LD_VAR 0 7
115883: ARRAY
115884: PPUSH
115885: CALL_OW 256
115889: PUSH
115890: LD_INT 500
115892: LESS
115893: IFFALSE 115919
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115895: LD_VAR 0 4
115899: PUSH
115900: LD_VAR 0 7
115904: ARRAY
115905: PPUSH
115906: LD_VAR 0 14
115910: PUSH
115911: LD_INT 1
115913: ARRAY
115914: PPUSH
115915: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
115919: LD_VAR 0 4
115923: PUSH
115924: LD_VAR 0 7
115928: ARRAY
115929: PPUSH
115930: CALL_OW 264
115934: PUSH
115935: LD_INT 49
115937: EQUAL
115938: IFFALSE 116059
// begin if not HasTask ( group [ i ] ) then
115940: LD_VAR 0 4
115944: PUSH
115945: LD_VAR 0 7
115949: ARRAY
115950: PPUSH
115951: CALL_OW 314
115955: NOT
115956: IFFALSE 116059
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
115958: LD_ADDR_VAR 0 9
115962: PUSH
115963: LD_INT 81
115965: PUSH
115966: LD_VAR 0 4
115970: PUSH
115971: LD_VAR 0 7
115975: ARRAY
115976: PPUSH
115977: CALL_OW 255
115981: PUSH
115982: EMPTY
115983: LIST
115984: LIST
115985: PPUSH
115986: CALL_OW 69
115990: PPUSH
115991: LD_VAR 0 4
115995: PUSH
115996: LD_VAR 0 7
116000: ARRAY
116001: PPUSH
116002: CALL_OW 74
116006: ST_TO_ADDR
// if k then
116007: LD_VAR 0 9
116011: IFFALSE 116059
// if GetDistUnits ( group [ i ] , k ) > 10 then
116013: LD_VAR 0 4
116017: PUSH
116018: LD_VAR 0 7
116022: ARRAY
116023: PPUSH
116024: LD_VAR 0 9
116028: PPUSH
116029: CALL_OW 296
116033: PUSH
116034: LD_INT 10
116036: GREATER
116037: IFFALSE 116059
// ComMoveUnit ( group [ i ] , k ) ;
116039: LD_VAR 0 4
116043: PUSH
116044: LD_VAR 0 7
116048: ARRAY
116049: PPUSH
116050: LD_VAR 0 9
116054: PPUSH
116055: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
116059: LD_VAR 0 4
116063: PUSH
116064: LD_VAR 0 7
116068: ARRAY
116069: PPUSH
116070: CALL_OW 256
116074: PUSH
116075: LD_INT 250
116077: LESS
116078: PUSH
116079: LD_VAR 0 4
116083: PUSH
116084: LD_VAR 0 7
116088: ARRAY
116089: PUSH
116090: LD_INT 21
116092: PUSH
116093: LD_INT 2
116095: PUSH
116096: EMPTY
116097: LIST
116098: LIST
116099: PUSH
116100: LD_INT 23
116102: PUSH
116103: LD_INT 2
116105: PUSH
116106: EMPTY
116107: LIST
116108: LIST
116109: PUSH
116110: EMPTY
116111: LIST
116112: LIST
116113: PPUSH
116114: CALL_OW 69
116118: IN
116119: AND
116120: IFFALSE 116245
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
116122: LD_ADDR_VAR 0 9
116126: PUSH
116127: LD_OWVAR 3
116131: PUSH
116132: LD_VAR 0 4
116136: PUSH
116137: LD_VAR 0 7
116141: ARRAY
116142: DIFF
116143: PPUSH
116144: LD_VAR 0 4
116148: PUSH
116149: LD_VAR 0 7
116153: ARRAY
116154: PPUSH
116155: CALL_OW 74
116159: ST_TO_ADDR
// if not k then
116160: LD_VAR 0 9
116164: NOT
116165: IFFALSE 116169
// continue ;
116167: GO 112584
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
116169: LD_VAR 0 9
116173: PUSH
116174: LD_INT 81
116176: PUSH
116177: LD_VAR 0 4
116181: PUSH
116182: LD_VAR 0 7
116186: ARRAY
116187: PPUSH
116188: CALL_OW 255
116192: PUSH
116193: EMPTY
116194: LIST
116195: LIST
116196: PPUSH
116197: CALL_OW 69
116201: IN
116202: PUSH
116203: LD_VAR 0 9
116207: PPUSH
116208: LD_VAR 0 4
116212: PUSH
116213: LD_VAR 0 7
116217: ARRAY
116218: PPUSH
116219: CALL_OW 296
116223: PUSH
116224: LD_INT 5
116226: LESS
116227: AND
116228: IFFALSE 116245
// ComAutodestruct ( group [ i ] ) ;
116230: LD_VAR 0 4
116234: PUSH
116235: LD_VAR 0 7
116239: ARRAY
116240: PPUSH
116241: CALL 82322 0 1
// end ; if f_attack_depot then
116245: LD_VAR 0 25
116249: IFFALSE 116361
// begin k := 6 ;
116251: LD_ADDR_VAR 0 9
116255: PUSH
116256: LD_INT 6
116258: ST_TO_ADDR
// if tmp < k then
116259: LD_VAR 0 14
116263: PUSH
116264: LD_VAR 0 9
116268: LESS
116269: IFFALSE 116281
// k := tmp ;
116271: LD_ADDR_VAR 0 9
116275: PUSH
116276: LD_VAR 0 14
116280: ST_TO_ADDR
// for j = 1 to k do
116281: LD_ADDR_VAR 0 8
116285: PUSH
116286: DOUBLE
116287: LD_INT 1
116289: DEC
116290: ST_TO_ADDR
116291: LD_VAR 0 9
116295: PUSH
116296: FOR_TO
116297: IFFALSE 116359
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
116299: LD_VAR 0 8
116303: PPUSH
116304: CALL_OW 266
116308: PUSH
116309: LD_INT 0
116311: PUSH
116312: LD_INT 1
116314: PUSH
116315: EMPTY
116316: LIST
116317: LIST
116318: IN
116319: IFFALSE 116357
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116321: LD_VAR 0 4
116325: PUSH
116326: LD_VAR 0 7
116330: ARRAY
116331: PPUSH
116332: LD_VAR 0 14
116336: PUSH
116337: LD_VAR 0 8
116341: ARRAY
116342: PPUSH
116343: CALL_OW 115
// attacking := true ;
116347: LD_ADDR_VAR 0 29
116351: PUSH
116352: LD_INT 1
116354: ST_TO_ADDR
// break ;
116355: GO 116359
// end ;
116357: GO 116296
116359: POP
116360: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
116361: LD_VAR 0 4
116365: PUSH
116366: LD_VAR 0 7
116370: ARRAY
116371: PPUSH
116372: CALL_OW 302
116376: PUSH
116377: LD_VAR 0 29
116381: NOT
116382: AND
116383: IFFALSE 116705
// begin if GetTag ( group [ i ] ) = 71 then
116385: LD_VAR 0 4
116389: PUSH
116390: LD_VAR 0 7
116394: ARRAY
116395: PPUSH
116396: CALL_OW 110
116400: PUSH
116401: LD_INT 71
116403: EQUAL
116404: IFFALSE 116445
// begin if HasTask ( group [ i ] ) then
116406: LD_VAR 0 4
116410: PUSH
116411: LD_VAR 0 7
116415: ARRAY
116416: PPUSH
116417: CALL_OW 314
116421: IFFALSE 116427
// continue else
116423: GO 112584
116425: GO 116445
// SetTag ( group [ i ] , 0 ) ;
116427: LD_VAR 0 4
116431: PUSH
116432: LD_VAR 0 7
116436: ARRAY
116437: PPUSH
116438: LD_INT 0
116440: PPUSH
116441: CALL_OW 109
// end ; k := 8 ;
116445: LD_ADDR_VAR 0 9
116449: PUSH
116450: LD_INT 8
116452: ST_TO_ADDR
// x := 0 ;
116453: LD_ADDR_VAR 0 10
116457: PUSH
116458: LD_INT 0
116460: ST_TO_ADDR
// if tmp < k then
116461: LD_VAR 0 14
116465: PUSH
116466: LD_VAR 0 9
116470: LESS
116471: IFFALSE 116483
// k := tmp ;
116473: LD_ADDR_VAR 0 9
116477: PUSH
116478: LD_VAR 0 14
116482: ST_TO_ADDR
// for j = 1 to k do
116483: LD_ADDR_VAR 0 8
116487: PUSH
116488: DOUBLE
116489: LD_INT 1
116491: DEC
116492: ST_TO_ADDR
116493: LD_VAR 0 9
116497: PUSH
116498: FOR_TO
116499: IFFALSE 116597
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
116501: LD_VAR 0 14
116505: PUSH
116506: LD_VAR 0 8
116510: ARRAY
116511: PPUSH
116512: CALL_OW 247
116516: PUSH
116517: LD_INT 1
116519: EQUAL
116520: PUSH
116521: LD_VAR 0 14
116525: PUSH
116526: LD_VAR 0 8
116530: ARRAY
116531: PPUSH
116532: CALL_OW 256
116536: PUSH
116537: LD_INT 250
116539: LESS
116540: PUSH
116541: LD_VAR 0 20
116545: AND
116546: PUSH
116547: LD_VAR 0 20
116551: NOT
116552: PUSH
116553: LD_VAR 0 14
116557: PUSH
116558: LD_VAR 0 8
116562: ARRAY
116563: PPUSH
116564: CALL_OW 256
116568: PUSH
116569: LD_INT 250
116571: GREATEREQUAL
116572: AND
116573: OR
116574: AND
116575: IFFALSE 116595
// begin x := tmp [ j ] ;
116577: LD_ADDR_VAR 0 10
116581: PUSH
116582: LD_VAR 0 14
116586: PUSH
116587: LD_VAR 0 8
116591: ARRAY
116592: ST_TO_ADDR
// break ;
116593: GO 116597
// end ;
116595: GO 116498
116597: POP
116598: POP
// if x then
116599: LD_VAR 0 10
116603: IFFALSE 116627
// ComAttackUnit ( group [ i ] , x ) else
116605: LD_VAR 0 4
116609: PUSH
116610: LD_VAR 0 7
116614: ARRAY
116615: PPUSH
116616: LD_VAR 0 10
116620: PPUSH
116621: CALL_OW 115
116625: GO 116651
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116627: LD_VAR 0 4
116631: PUSH
116632: LD_VAR 0 7
116636: ARRAY
116637: PPUSH
116638: LD_VAR 0 14
116642: PUSH
116643: LD_INT 1
116645: ARRAY
116646: PPUSH
116647: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116651: LD_VAR 0 4
116655: PUSH
116656: LD_VAR 0 7
116660: ARRAY
116661: PPUSH
116662: CALL_OW 314
116666: NOT
116667: IFFALSE 116705
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116669: LD_VAR 0 4
116673: PUSH
116674: LD_VAR 0 7
116678: ARRAY
116679: PPUSH
116680: LD_VAR 0 14
116684: PPUSH
116685: LD_VAR 0 4
116689: PUSH
116690: LD_VAR 0 7
116694: ARRAY
116695: PPUSH
116696: CALL_OW 74
116700: PPUSH
116701: CALL_OW 115
// end ; end ; end ;
116705: GO 112584
116707: POP
116708: POP
// wait ( 0 0$2 ) ;
116709: LD_INT 70
116711: PPUSH
116712: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116716: LD_VAR 0 4
116720: NOT
116721: PUSH
116722: LD_VAR 0 4
116726: PUSH
116727: EMPTY
116728: EQUAL
116729: OR
116730: PUSH
116731: LD_INT 81
116733: PUSH
116734: LD_VAR 0 35
116738: PUSH
116739: EMPTY
116740: LIST
116741: LIST
116742: PPUSH
116743: CALL_OW 69
116747: NOT
116748: OR
116749: IFFALSE 112569
// end ;
116751: LD_VAR 0 2
116755: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116756: LD_INT 0
116758: PPUSH
116759: PPUSH
116760: PPUSH
116761: PPUSH
116762: PPUSH
116763: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116764: LD_VAR 0 1
116768: NOT
116769: PUSH
116770: LD_EXP 50
116774: PUSH
116775: LD_VAR 0 1
116779: ARRAY
116780: NOT
116781: OR
116782: PUSH
116783: LD_VAR 0 2
116787: NOT
116788: OR
116789: IFFALSE 116793
// exit ;
116791: GO 117347
// side := mc_sides [ base ] ;
116793: LD_ADDR_VAR 0 6
116797: PUSH
116798: LD_EXP 76
116802: PUSH
116803: LD_VAR 0 1
116807: ARRAY
116808: ST_TO_ADDR
// if not side then
116809: LD_VAR 0 6
116813: NOT
116814: IFFALSE 116818
// exit ;
116816: GO 117347
// for i in solds do
116818: LD_ADDR_VAR 0 7
116822: PUSH
116823: LD_VAR 0 2
116827: PUSH
116828: FOR_IN
116829: IFFALSE 116890
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
116831: LD_VAR 0 7
116835: PPUSH
116836: CALL_OW 310
116840: PPUSH
116841: CALL_OW 266
116845: PUSH
116846: LD_INT 32
116848: PUSH
116849: LD_INT 31
116851: PUSH
116852: EMPTY
116853: LIST
116854: LIST
116855: IN
116856: IFFALSE 116876
// solds := solds diff i else
116858: LD_ADDR_VAR 0 2
116862: PUSH
116863: LD_VAR 0 2
116867: PUSH
116868: LD_VAR 0 7
116872: DIFF
116873: ST_TO_ADDR
116874: GO 116888
// SetTag ( i , 18 ) ;
116876: LD_VAR 0 7
116880: PPUSH
116881: LD_INT 18
116883: PPUSH
116884: CALL_OW 109
116888: GO 116828
116890: POP
116891: POP
// if not solds then
116892: LD_VAR 0 2
116896: NOT
116897: IFFALSE 116901
// exit ;
116899: GO 117347
// repeat wait ( 0 0$2 ) ;
116901: LD_INT 70
116903: PPUSH
116904: CALL_OW 67
// enemy := mc_scan [ base ] ;
116908: LD_ADDR_VAR 0 4
116912: PUSH
116913: LD_EXP 73
116917: PUSH
116918: LD_VAR 0 1
116922: ARRAY
116923: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116924: LD_EXP 50
116928: PUSH
116929: LD_VAR 0 1
116933: ARRAY
116934: NOT
116935: PUSH
116936: LD_EXP 50
116940: PUSH
116941: LD_VAR 0 1
116945: ARRAY
116946: PUSH
116947: EMPTY
116948: EQUAL
116949: OR
116950: IFFALSE 116987
// begin for i in solds do
116952: LD_ADDR_VAR 0 7
116956: PUSH
116957: LD_VAR 0 2
116961: PUSH
116962: FOR_IN
116963: IFFALSE 116976
// ComStop ( i ) ;
116965: LD_VAR 0 7
116969: PPUSH
116970: CALL_OW 141
116974: GO 116962
116976: POP
116977: POP
// solds := [ ] ;
116978: LD_ADDR_VAR 0 2
116982: PUSH
116983: EMPTY
116984: ST_TO_ADDR
// exit ;
116985: GO 117347
// end ; for i in solds do
116987: LD_ADDR_VAR 0 7
116991: PUSH
116992: LD_VAR 0 2
116996: PUSH
116997: FOR_IN
116998: IFFALSE 117319
// begin if IsInUnit ( i ) then
117000: LD_VAR 0 7
117004: PPUSH
117005: CALL_OW 310
117009: IFFALSE 117020
// ComExitBuilding ( i ) ;
117011: LD_VAR 0 7
117015: PPUSH
117016: CALL_OW 122
// if GetLives ( i ) > 500 then
117020: LD_VAR 0 7
117024: PPUSH
117025: CALL_OW 256
117029: PUSH
117030: LD_INT 500
117032: GREATER
117033: IFFALSE 117086
// begin e := NearestUnitToUnit ( enemy , i ) ;
117035: LD_ADDR_VAR 0 5
117039: PUSH
117040: LD_VAR 0 4
117044: PPUSH
117045: LD_VAR 0 7
117049: PPUSH
117050: CALL_OW 74
117054: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
117055: LD_VAR 0 7
117059: PPUSH
117060: LD_VAR 0 5
117064: PPUSH
117065: CALL_OW 250
117069: PPUSH
117070: LD_VAR 0 5
117074: PPUSH
117075: CALL_OW 251
117079: PPUSH
117080: CALL_OW 114
// end else
117084: GO 117317
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
117086: LD_VAR 0 7
117090: PPUSH
117091: LD_EXP 50
117095: PUSH
117096: LD_VAR 0 1
117100: ARRAY
117101: PPUSH
117102: LD_INT 2
117104: PUSH
117105: LD_INT 30
117107: PUSH
117108: LD_INT 0
117110: PUSH
117111: EMPTY
117112: LIST
117113: LIST
117114: PUSH
117115: LD_INT 30
117117: PUSH
117118: LD_INT 1
117120: PUSH
117121: EMPTY
117122: LIST
117123: LIST
117124: PUSH
117125: LD_INT 30
117127: PUSH
117128: LD_INT 6
117130: PUSH
117131: EMPTY
117132: LIST
117133: LIST
117134: PUSH
117135: EMPTY
117136: LIST
117137: LIST
117138: LIST
117139: LIST
117140: PPUSH
117141: CALL_OW 72
117145: PPUSH
117146: LD_VAR 0 7
117150: PPUSH
117151: CALL_OW 74
117155: PPUSH
117156: CALL_OW 296
117160: PUSH
117161: LD_INT 10
117163: GREATER
117164: IFFALSE 117317
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
117166: LD_ADDR_VAR 0 8
117170: PUSH
117171: LD_EXP 50
117175: PUSH
117176: LD_VAR 0 1
117180: ARRAY
117181: PPUSH
117182: LD_INT 2
117184: PUSH
117185: LD_INT 30
117187: PUSH
117188: LD_INT 0
117190: PUSH
117191: EMPTY
117192: LIST
117193: LIST
117194: PUSH
117195: LD_INT 30
117197: PUSH
117198: LD_INT 1
117200: PUSH
117201: EMPTY
117202: LIST
117203: LIST
117204: PUSH
117205: LD_INT 30
117207: PUSH
117208: LD_INT 6
117210: PUSH
117211: EMPTY
117212: LIST
117213: LIST
117214: PUSH
117215: EMPTY
117216: LIST
117217: LIST
117218: LIST
117219: LIST
117220: PPUSH
117221: CALL_OW 72
117225: PPUSH
117226: LD_VAR 0 7
117230: PPUSH
117231: CALL_OW 74
117235: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
117236: LD_VAR 0 7
117240: PPUSH
117241: LD_VAR 0 8
117245: PPUSH
117246: CALL_OW 250
117250: PPUSH
117251: LD_INT 3
117253: PPUSH
117254: LD_INT 5
117256: PPUSH
117257: CALL_OW 272
117261: PPUSH
117262: LD_VAR 0 8
117266: PPUSH
117267: CALL_OW 251
117271: PPUSH
117272: LD_INT 3
117274: PPUSH
117275: LD_INT 5
117277: PPUSH
117278: CALL_OW 273
117282: PPUSH
117283: CALL_OW 111
// SetTag ( i , 0 ) ;
117287: LD_VAR 0 7
117291: PPUSH
117292: LD_INT 0
117294: PPUSH
117295: CALL_OW 109
// solds := solds diff i ;
117299: LD_ADDR_VAR 0 2
117303: PUSH
117304: LD_VAR 0 2
117308: PUSH
117309: LD_VAR 0 7
117313: DIFF
117314: ST_TO_ADDR
// continue ;
117315: GO 116997
// end ; end ;
117317: GO 116997
117319: POP
117320: POP
// until not solds or not enemy ;
117321: LD_VAR 0 2
117325: NOT
117326: PUSH
117327: LD_VAR 0 4
117331: NOT
117332: OR
117333: IFFALSE 116901
// MC_Reset ( base , 18 ) ;
117335: LD_VAR 0 1
117339: PPUSH
117340: LD_INT 18
117342: PPUSH
117343: CALL 22580 0 2
// end ;
117347: LD_VAR 0 3
117351: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
117352: LD_INT 0
117354: PPUSH
117355: PPUSH
117356: PPUSH
117357: PPUSH
117358: PPUSH
117359: PPUSH
117360: PPUSH
117361: PPUSH
117362: PPUSH
117363: PPUSH
117364: PPUSH
117365: PPUSH
117366: PPUSH
117367: PPUSH
117368: PPUSH
117369: PPUSH
117370: PPUSH
117371: PPUSH
117372: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
117373: LD_ADDR_VAR 0 12
117377: PUSH
117378: LD_EXP 50
117382: PUSH
117383: LD_VAR 0 1
117387: ARRAY
117388: PPUSH
117389: LD_INT 25
117391: PUSH
117392: LD_INT 3
117394: PUSH
117395: EMPTY
117396: LIST
117397: LIST
117398: PPUSH
117399: CALL_OW 72
117403: ST_TO_ADDR
// if mc_remote_driver [ base ] then
117404: LD_EXP 90
117408: PUSH
117409: LD_VAR 0 1
117413: ARRAY
117414: IFFALSE 117438
// mechs := mechs diff mc_remote_driver [ base ] ;
117416: LD_ADDR_VAR 0 12
117420: PUSH
117421: LD_VAR 0 12
117425: PUSH
117426: LD_EXP 90
117430: PUSH
117431: LD_VAR 0 1
117435: ARRAY
117436: DIFF
117437: ST_TO_ADDR
// for i in mechs do
117438: LD_ADDR_VAR 0 4
117442: PUSH
117443: LD_VAR 0 12
117447: PUSH
117448: FOR_IN
117449: IFFALSE 117484
// if GetTag ( i ) > 0 then
117451: LD_VAR 0 4
117455: PPUSH
117456: CALL_OW 110
117460: PUSH
117461: LD_INT 0
117463: GREATER
117464: IFFALSE 117482
// mechs := mechs diff i ;
117466: LD_ADDR_VAR 0 12
117470: PUSH
117471: LD_VAR 0 12
117475: PUSH
117476: LD_VAR 0 4
117480: DIFF
117481: ST_TO_ADDR
117482: GO 117448
117484: POP
117485: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117486: LD_ADDR_VAR 0 8
117490: PUSH
117491: LD_EXP 50
117495: PUSH
117496: LD_VAR 0 1
117500: ARRAY
117501: PPUSH
117502: LD_INT 2
117504: PUSH
117505: LD_INT 25
117507: PUSH
117508: LD_INT 1
117510: PUSH
117511: EMPTY
117512: LIST
117513: LIST
117514: PUSH
117515: LD_INT 25
117517: PUSH
117518: LD_INT 5
117520: PUSH
117521: EMPTY
117522: LIST
117523: LIST
117524: PUSH
117525: LD_INT 25
117527: PUSH
117528: LD_INT 8
117530: PUSH
117531: EMPTY
117532: LIST
117533: LIST
117534: PUSH
117535: LD_INT 25
117537: PUSH
117538: LD_INT 9
117540: PUSH
117541: EMPTY
117542: LIST
117543: LIST
117544: PUSH
117545: EMPTY
117546: LIST
117547: LIST
117548: LIST
117549: LIST
117550: LIST
117551: PPUSH
117552: CALL_OW 72
117556: ST_TO_ADDR
// if not defenders and not solds then
117557: LD_VAR 0 2
117561: NOT
117562: PUSH
117563: LD_VAR 0 8
117567: NOT
117568: AND
117569: IFFALSE 117573
// exit ;
117571: GO 119343
// depot_under_attack := false ;
117573: LD_ADDR_VAR 0 16
117577: PUSH
117578: LD_INT 0
117580: ST_TO_ADDR
// sold_defenders := [ ] ;
117581: LD_ADDR_VAR 0 17
117585: PUSH
117586: EMPTY
117587: ST_TO_ADDR
// if mechs then
117588: LD_VAR 0 12
117592: IFFALSE 117745
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117594: LD_ADDR_VAR 0 4
117598: PUSH
117599: LD_VAR 0 2
117603: PPUSH
117604: LD_INT 21
117606: PUSH
117607: LD_INT 2
117609: PUSH
117610: EMPTY
117611: LIST
117612: LIST
117613: PPUSH
117614: CALL_OW 72
117618: PUSH
117619: FOR_IN
117620: IFFALSE 117743
// begin if GetTag ( i ) <> 20 then
117622: LD_VAR 0 4
117626: PPUSH
117627: CALL_OW 110
117631: PUSH
117632: LD_INT 20
117634: NONEQUAL
117635: IFFALSE 117649
// SetTag ( i , 20 ) ;
117637: LD_VAR 0 4
117641: PPUSH
117642: LD_INT 20
117644: PPUSH
117645: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117649: LD_VAR 0 4
117653: PPUSH
117654: CALL_OW 263
117658: PUSH
117659: LD_INT 1
117661: EQUAL
117662: PUSH
117663: LD_VAR 0 4
117667: PPUSH
117668: CALL_OW 311
117672: NOT
117673: AND
117674: IFFALSE 117741
// begin un := mechs [ 1 ] ;
117676: LD_ADDR_VAR 0 10
117680: PUSH
117681: LD_VAR 0 12
117685: PUSH
117686: LD_INT 1
117688: ARRAY
117689: ST_TO_ADDR
// ComExit ( un ) ;
117690: LD_VAR 0 10
117694: PPUSH
117695: CALL 87219 0 1
// AddComEnterUnit ( un , i ) ;
117699: LD_VAR 0 10
117703: PPUSH
117704: LD_VAR 0 4
117708: PPUSH
117709: CALL_OW 180
// SetTag ( un , 19 ) ;
117713: LD_VAR 0 10
117717: PPUSH
117718: LD_INT 19
117720: PPUSH
117721: CALL_OW 109
// mechs := mechs diff un ;
117725: LD_ADDR_VAR 0 12
117729: PUSH
117730: LD_VAR 0 12
117734: PUSH
117735: LD_VAR 0 10
117739: DIFF
117740: ST_TO_ADDR
// end ; end ;
117741: GO 117619
117743: POP
117744: POP
// if solds then
117745: LD_VAR 0 8
117749: IFFALSE 117808
// for i in solds do
117751: LD_ADDR_VAR 0 4
117755: PUSH
117756: LD_VAR 0 8
117760: PUSH
117761: FOR_IN
117762: IFFALSE 117806
// if not GetTag ( i ) then
117764: LD_VAR 0 4
117768: PPUSH
117769: CALL_OW 110
117773: NOT
117774: IFFALSE 117804
// begin defenders := defenders union i ;
117776: LD_ADDR_VAR 0 2
117780: PUSH
117781: LD_VAR 0 2
117785: PUSH
117786: LD_VAR 0 4
117790: UNION
117791: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117792: LD_VAR 0 4
117796: PPUSH
117797: LD_INT 18
117799: PPUSH
117800: CALL_OW 109
// end ;
117804: GO 117761
117806: POP
117807: POP
// repeat wait ( 0 0$2 ) ;
117808: LD_INT 70
117810: PPUSH
117811: CALL_OW 67
// enemy := mc_scan [ base ] ;
117815: LD_ADDR_VAR 0 21
117819: PUSH
117820: LD_EXP 73
117824: PUSH
117825: LD_VAR 0 1
117829: ARRAY
117830: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117831: LD_EXP 50
117835: PUSH
117836: LD_VAR 0 1
117840: ARRAY
117841: NOT
117842: PUSH
117843: LD_EXP 50
117847: PUSH
117848: LD_VAR 0 1
117852: ARRAY
117853: PUSH
117854: EMPTY
117855: EQUAL
117856: OR
117857: IFFALSE 117894
// begin for i in defenders do
117859: LD_ADDR_VAR 0 4
117863: PUSH
117864: LD_VAR 0 2
117868: PUSH
117869: FOR_IN
117870: IFFALSE 117883
// ComStop ( i ) ;
117872: LD_VAR 0 4
117876: PPUSH
117877: CALL_OW 141
117881: GO 117869
117883: POP
117884: POP
// defenders := [ ] ;
117885: LD_ADDR_VAR 0 2
117889: PUSH
117890: EMPTY
117891: ST_TO_ADDR
// exit ;
117892: GO 119343
// end ; for i in defenders do
117894: LD_ADDR_VAR 0 4
117898: PUSH
117899: LD_VAR 0 2
117903: PUSH
117904: FOR_IN
117905: IFFALSE 118803
// begin e := NearestUnitToUnit ( enemy , i ) ;
117907: LD_ADDR_VAR 0 13
117911: PUSH
117912: LD_VAR 0 21
117916: PPUSH
117917: LD_VAR 0 4
117921: PPUSH
117922: CALL_OW 74
117926: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117927: LD_ADDR_VAR 0 7
117931: PUSH
117932: LD_EXP 50
117936: PUSH
117937: LD_VAR 0 1
117941: ARRAY
117942: PPUSH
117943: LD_INT 2
117945: PUSH
117946: LD_INT 30
117948: PUSH
117949: LD_INT 0
117951: PUSH
117952: EMPTY
117953: LIST
117954: LIST
117955: PUSH
117956: LD_INT 30
117958: PUSH
117959: LD_INT 1
117961: PUSH
117962: EMPTY
117963: LIST
117964: LIST
117965: PUSH
117966: EMPTY
117967: LIST
117968: LIST
117969: LIST
117970: PPUSH
117971: CALL_OW 72
117975: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
117976: LD_ADDR_VAR 0 16
117980: PUSH
117981: LD_VAR 0 7
117985: NOT
117986: PUSH
117987: LD_VAR 0 7
117991: PPUSH
117992: LD_INT 3
117994: PUSH
117995: LD_INT 24
117997: PUSH
117998: LD_INT 600
118000: PUSH
118001: EMPTY
118002: LIST
118003: LIST
118004: PUSH
118005: EMPTY
118006: LIST
118007: LIST
118008: PPUSH
118009: CALL_OW 72
118013: OR
118014: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
118015: LD_VAR 0 4
118019: PPUSH
118020: CALL_OW 247
118024: PUSH
118025: LD_INT 2
118027: DOUBLE
118028: EQUAL
118029: IFTRUE 118033
118031: GO 118429
118033: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118034: LD_VAR 0 4
118038: PPUSH
118039: CALL_OW 256
118043: PUSH
118044: LD_INT 1000
118046: EQUAL
118047: PUSH
118048: LD_VAR 0 4
118052: PPUSH
118053: LD_VAR 0 13
118057: PPUSH
118058: CALL_OW 296
118062: PUSH
118063: LD_INT 40
118065: LESS
118066: PUSH
118067: LD_VAR 0 13
118071: PPUSH
118072: LD_EXP 75
118076: PUSH
118077: LD_VAR 0 1
118081: ARRAY
118082: PPUSH
118083: CALL_OW 308
118087: OR
118088: AND
118089: IFFALSE 118211
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
118091: LD_VAR 0 4
118095: PPUSH
118096: CALL_OW 262
118100: PUSH
118101: LD_INT 1
118103: EQUAL
118104: PUSH
118105: LD_VAR 0 4
118109: PPUSH
118110: CALL_OW 261
118114: PUSH
118115: LD_INT 30
118117: LESS
118118: AND
118119: PUSH
118120: LD_VAR 0 7
118124: AND
118125: IFFALSE 118195
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
118127: LD_VAR 0 4
118131: PPUSH
118132: LD_VAR 0 7
118136: PPUSH
118137: LD_VAR 0 4
118141: PPUSH
118142: CALL_OW 74
118146: PPUSH
118147: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
118151: LD_VAR 0 4
118155: PPUSH
118156: LD_VAR 0 7
118160: PPUSH
118161: LD_VAR 0 4
118165: PPUSH
118166: CALL_OW 74
118170: PPUSH
118171: CALL_OW 296
118175: PUSH
118176: LD_INT 6
118178: LESS
118179: IFFALSE 118193
// SetFuel ( i , 100 ) ;
118181: LD_VAR 0 4
118185: PPUSH
118186: LD_INT 100
118188: PPUSH
118189: CALL_OW 240
// end else
118193: GO 118209
// ComAttackUnit ( i , e ) ;
118195: LD_VAR 0 4
118199: PPUSH
118200: LD_VAR 0 13
118204: PPUSH
118205: CALL_OW 115
// end else
118209: GO 118312
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
118211: LD_VAR 0 13
118215: PPUSH
118216: LD_EXP 75
118220: PUSH
118221: LD_VAR 0 1
118225: ARRAY
118226: PPUSH
118227: CALL_OW 308
118231: NOT
118232: PUSH
118233: LD_VAR 0 4
118237: PPUSH
118238: LD_VAR 0 13
118242: PPUSH
118243: CALL_OW 296
118247: PUSH
118248: LD_INT 40
118250: GREATEREQUAL
118251: AND
118252: PUSH
118253: LD_VAR 0 4
118257: PPUSH
118258: CALL_OW 256
118262: PUSH
118263: LD_INT 650
118265: LESSEQUAL
118266: OR
118267: PUSH
118268: LD_VAR 0 4
118272: PPUSH
118273: LD_EXP 74
118277: PUSH
118278: LD_VAR 0 1
118282: ARRAY
118283: PPUSH
118284: CALL_OW 308
118288: NOT
118289: AND
118290: IFFALSE 118312
// ComMoveToArea ( i , mc_parking [ base ] ) ;
118292: LD_VAR 0 4
118296: PPUSH
118297: LD_EXP 74
118301: PUSH
118302: LD_VAR 0 1
118306: ARRAY
118307: PPUSH
118308: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
118312: LD_VAR 0 4
118316: PPUSH
118317: CALL_OW 256
118321: PUSH
118322: LD_INT 1000
118324: LESS
118325: PUSH
118326: LD_VAR 0 4
118330: PPUSH
118331: CALL_OW 263
118335: PUSH
118336: LD_INT 1
118338: EQUAL
118339: AND
118340: PUSH
118341: LD_VAR 0 4
118345: PPUSH
118346: CALL_OW 311
118350: AND
118351: PUSH
118352: LD_VAR 0 4
118356: PPUSH
118357: LD_EXP 74
118361: PUSH
118362: LD_VAR 0 1
118366: ARRAY
118367: PPUSH
118368: CALL_OW 308
118372: AND
118373: IFFALSE 118427
// begin mech := IsDrivenBy ( i ) ;
118375: LD_ADDR_VAR 0 9
118379: PUSH
118380: LD_VAR 0 4
118384: PPUSH
118385: CALL_OW 311
118389: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
118390: LD_VAR 0 9
118394: PPUSH
118395: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
118399: LD_VAR 0 9
118403: PPUSH
118404: LD_VAR 0 4
118408: PPUSH
118409: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
118413: LD_VAR 0 9
118417: PPUSH
118418: LD_VAR 0 4
118422: PPUSH
118423: CALL_OW 180
// end ; end ; unit_human :
118427: GO 118774
118429: LD_INT 1
118431: DOUBLE
118432: EQUAL
118433: IFTRUE 118437
118435: GO 118773
118437: POP
// begin b := IsInUnit ( i ) ;
118438: LD_ADDR_VAR 0 18
118442: PUSH
118443: LD_VAR 0 4
118447: PPUSH
118448: CALL_OW 310
118452: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
118453: LD_ADDR_VAR 0 19
118457: PUSH
118458: LD_VAR 0 18
118462: NOT
118463: PUSH
118464: LD_VAR 0 18
118468: PPUSH
118469: CALL_OW 266
118473: PUSH
118474: LD_INT 32
118476: PUSH
118477: LD_INT 31
118479: PUSH
118480: EMPTY
118481: LIST
118482: LIST
118483: IN
118484: OR
118485: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
118486: LD_VAR 0 18
118490: PPUSH
118491: CALL_OW 266
118495: PUSH
118496: LD_INT 5
118498: EQUAL
118499: PUSH
118500: LD_VAR 0 4
118504: PPUSH
118505: CALL_OW 257
118509: PUSH
118510: LD_INT 1
118512: PUSH
118513: LD_INT 2
118515: PUSH
118516: LD_INT 3
118518: PUSH
118519: LD_INT 4
118521: PUSH
118522: EMPTY
118523: LIST
118524: LIST
118525: LIST
118526: LIST
118527: IN
118528: AND
118529: IFFALSE 118566
// begin class := AllowSpecClass ( i ) ;
118531: LD_ADDR_VAR 0 20
118535: PUSH
118536: LD_VAR 0 4
118540: PPUSH
118541: CALL 50905 0 1
118545: ST_TO_ADDR
// if class then
118546: LD_VAR 0 20
118550: IFFALSE 118566
// ComChangeProfession ( i , class ) ;
118552: LD_VAR 0 4
118556: PPUSH
118557: LD_VAR 0 20
118561: PPUSH
118562: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118566: LD_VAR 0 16
118570: PUSH
118571: LD_VAR 0 2
118575: PPUSH
118576: LD_INT 21
118578: PUSH
118579: LD_INT 2
118581: PUSH
118582: EMPTY
118583: LIST
118584: LIST
118585: PPUSH
118586: CALL_OW 72
118590: PUSH
118591: LD_INT 1
118593: LESSEQUAL
118594: OR
118595: PUSH
118596: LD_VAR 0 19
118600: AND
118601: PUSH
118602: LD_VAR 0 4
118606: PUSH
118607: LD_VAR 0 17
118611: IN
118612: NOT
118613: AND
118614: IFFALSE 118707
// begin if b then
118616: LD_VAR 0 18
118620: IFFALSE 118669
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118622: LD_VAR 0 18
118626: PPUSH
118627: LD_VAR 0 21
118631: PPUSH
118632: LD_VAR 0 18
118636: PPUSH
118637: CALL_OW 74
118641: PPUSH
118642: CALL_OW 296
118646: PUSH
118647: LD_INT 10
118649: LESS
118650: PUSH
118651: LD_VAR 0 18
118655: PPUSH
118656: CALL_OW 461
118660: PUSH
118661: LD_INT 7
118663: NONEQUAL
118664: AND
118665: IFFALSE 118669
// continue ;
118667: GO 117904
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118669: LD_ADDR_VAR 0 17
118673: PUSH
118674: LD_VAR 0 17
118678: PPUSH
118679: LD_VAR 0 17
118683: PUSH
118684: LD_INT 1
118686: PLUS
118687: PPUSH
118688: LD_VAR 0 4
118692: PPUSH
118693: CALL_OW 1
118697: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118698: LD_VAR 0 4
118702: PPUSH
118703: CALL_OW 122
// end ; if sold_defenders then
118707: LD_VAR 0 17
118711: IFFALSE 118771
// if i in sold_defenders then
118713: LD_VAR 0 4
118717: PUSH
118718: LD_VAR 0 17
118722: IN
118723: IFFALSE 118771
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118725: LD_VAR 0 4
118729: PPUSH
118730: CALL_OW 314
118734: NOT
118735: PUSH
118736: LD_VAR 0 4
118740: PPUSH
118741: LD_VAR 0 13
118745: PPUSH
118746: CALL_OW 296
118750: PUSH
118751: LD_INT 30
118753: LESS
118754: AND
118755: IFFALSE 118771
// ComAttackUnit ( i , e ) ;
118757: LD_VAR 0 4
118761: PPUSH
118762: LD_VAR 0 13
118766: PPUSH
118767: CALL_OW 115
// end ; end ; end ;
118771: GO 118774
118773: POP
// if IsDead ( i ) then
118774: LD_VAR 0 4
118778: PPUSH
118779: CALL_OW 301
118783: IFFALSE 118801
// defenders := defenders diff i ;
118785: LD_ADDR_VAR 0 2
118789: PUSH
118790: LD_VAR 0 2
118794: PUSH
118795: LD_VAR 0 4
118799: DIFF
118800: ST_TO_ADDR
// end ;
118801: GO 117904
118803: POP
118804: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118805: LD_VAR 0 21
118809: NOT
118810: PUSH
118811: LD_VAR 0 2
118815: NOT
118816: OR
118817: PUSH
118818: LD_EXP 50
118822: PUSH
118823: LD_VAR 0 1
118827: ARRAY
118828: NOT
118829: OR
118830: IFFALSE 117808
// MC_Reset ( base , 18 ) ;
118832: LD_VAR 0 1
118836: PPUSH
118837: LD_INT 18
118839: PPUSH
118840: CALL 22580 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118844: LD_ADDR_VAR 0 2
118848: PUSH
118849: LD_VAR 0 2
118853: PUSH
118854: LD_VAR 0 2
118858: PPUSH
118859: LD_INT 2
118861: PUSH
118862: LD_INT 25
118864: PUSH
118865: LD_INT 1
118867: PUSH
118868: EMPTY
118869: LIST
118870: LIST
118871: PUSH
118872: LD_INT 25
118874: PUSH
118875: LD_INT 5
118877: PUSH
118878: EMPTY
118879: LIST
118880: LIST
118881: PUSH
118882: LD_INT 25
118884: PUSH
118885: LD_INT 8
118887: PUSH
118888: EMPTY
118889: LIST
118890: LIST
118891: PUSH
118892: LD_INT 25
118894: PUSH
118895: LD_INT 9
118897: PUSH
118898: EMPTY
118899: LIST
118900: LIST
118901: PUSH
118902: EMPTY
118903: LIST
118904: LIST
118905: LIST
118906: LIST
118907: LIST
118908: PPUSH
118909: CALL_OW 72
118913: DIFF
118914: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
118915: LD_VAR 0 21
118919: NOT
118920: PUSH
118921: LD_VAR 0 2
118925: PPUSH
118926: LD_INT 21
118928: PUSH
118929: LD_INT 2
118931: PUSH
118932: EMPTY
118933: LIST
118934: LIST
118935: PPUSH
118936: CALL_OW 72
118940: AND
118941: IFFALSE 119279
// begin tmp := FilterByTag ( defenders , 19 ) ;
118943: LD_ADDR_VAR 0 11
118947: PUSH
118948: LD_VAR 0 2
118952: PPUSH
118953: LD_INT 19
118955: PPUSH
118956: CALL 84390 0 2
118960: ST_TO_ADDR
// if tmp then
118961: LD_VAR 0 11
118965: IFFALSE 119035
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
118967: LD_ADDR_VAR 0 11
118971: PUSH
118972: LD_VAR 0 11
118976: PPUSH
118977: LD_INT 25
118979: PUSH
118980: LD_INT 3
118982: PUSH
118983: EMPTY
118984: LIST
118985: LIST
118986: PPUSH
118987: CALL_OW 72
118991: ST_TO_ADDR
// if tmp then
118992: LD_VAR 0 11
118996: IFFALSE 119035
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
118998: LD_ADDR_EXP 62
119002: PUSH
119003: LD_EXP 62
119007: PPUSH
119008: LD_VAR 0 1
119012: PPUSH
119013: LD_EXP 62
119017: PUSH
119018: LD_VAR 0 1
119022: ARRAY
119023: PUSH
119024: LD_VAR 0 11
119028: UNION
119029: PPUSH
119030: CALL_OW 1
119034: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119035: LD_VAR 0 1
119039: PPUSH
119040: LD_INT 19
119042: PPUSH
119043: CALL 22580 0 2
// repeat wait ( 0 0$1 ) ;
119047: LD_INT 35
119049: PPUSH
119050: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119054: LD_EXP 50
119058: PUSH
119059: LD_VAR 0 1
119063: ARRAY
119064: NOT
119065: PUSH
119066: LD_EXP 50
119070: PUSH
119071: LD_VAR 0 1
119075: ARRAY
119076: PUSH
119077: EMPTY
119078: EQUAL
119079: OR
119080: IFFALSE 119117
// begin for i in defenders do
119082: LD_ADDR_VAR 0 4
119086: PUSH
119087: LD_VAR 0 2
119091: PUSH
119092: FOR_IN
119093: IFFALSE 119106
// ComStop ( i ) ;
119095: LD_VAR 0 4
119099: PPUSH
119100: CALL_OW 141
119104: GO 119092
119106: POP
119107: POP
// defenders := [ ] ;
119108: LD_ADDR_VAR 0 2
119112: PUSH
119113: EMPTY
119114: ST_TO_ADDR
// exit ;
119115: GO 119343
// end ; for i in defenders do
119117: LD_ADDR_VAR 0 4
119121: PUSH
119122: LD_VAR 0 2
119126: PUSH
119127: FOR_IN
119128: IFFALSE 119217
// begin if not IsInArea ( i , mc_parking [ base ] ) then
119130: LD_VAR 0 4
119134: PPUSH
119135: LD_EXP 74
119139: PUSH
119140: LD_VAR 0 1
119144: ARRAY
119145: PPUSH
119146: CALL_OW 308
119150: NOT
119151: IFFALSE 119175
// ComMoveToArea ( i , mc_parking [ base ] ) else
119153: LD_VAR 0 4
119157: PPUSH
119158: LD_EXP 74
119162: PUSH
119163: LD_VAR 0 1
119167: ARRAY
119168: PPUSH
119169: CALL_OW 113
119173: GO 119215
// if GetControl ( i ) = control_manual then
119175: LD_VAR 0 4
119179: PPUSH
119180: CALL_OW 263
119184: PUSH
119185: LD_INT 1
119187: EQUAL
119188: IFFALSE 119215
// if IsDrivenBy ( i ) then
119190: LD_VAR 0 4
119194: PPUSH
119195: CALL_OW 311
119199: IFFALSE 119215
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
119201: LD_VAR 0 4
119205: PPUSH
119206: CALL_OW 311
119210: PPUSH
119211: CALL_OW 121
// end ;
119215: GO 119127
119217: POP
119218: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
119219: LD_VAR 0 2
119223: PPUSH
119224: LD_INT 95
119226: PUSH
119227: LD_EXP 74
119231: PUSH
119232: LD_VAR 0 1
119236: ARRAY
119237: PUSH
119238: EMPTY
119239: LIST
119240: LIST
119241: PPUSH
119242: CALL_OW 72
119246: PUSH
119247: LD_VAR 0 2
119251: EQUAL
119252: PUSH
119253: LD_EXP 73
119257: PUSH
119258: LD_VAR 0 1
119262: ARRAY
119263: OR
119264: PUSH
119265: LD_EXP 50
119269: PUSH
119270: LD_VAR 0 1
119274: ARRAY
119275: NOT
119276: OR
119277: IFFALSE 119047
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
119279: LD_ADDR_EXP 72
119283: PUSH
119284: LD_EXP 72
119288: PPUSH
119289: LD_VAR 0 1
119293: PPUSH
119294: LD_VAR 0 2
119298: PPUSH
119299: LD_INT 21
119301: PUSH
119302: LD_INT 2
119304: PUSH
119305: EMPTY
119306: LIST
119307: LIST
119308: PPUSH
119309: CALL_OW 72
119313: PPUSH
119314: CALL_OW 1
119318: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
119319: LD_VAR 0 1
119323: PPUSH
119324: LD_INT 19
119326: PPUSH
119327: CALL 22580 0 2
// MC_Reset ( base , 20 ) ;
119331: LD_VAR 0 1
119335: PPUSH
119336: LD_INT 20
119338: PPUSH
119339: CALL 22580 0 2
// end ; end_of_file
119343: LD_VAR 0 3
119347: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
119348: LD_VAR 0 1
119352: PUSH
119353: LD_INT 200
119355: DOUBLE
119356: GREATEREQUAL
119357: IFFALSE 119365
119359: LD_INT 299
119361: DOUBLE
119362: LESSEQUAL
119363: IFTRUE 119367
119365: GO 119399
119367: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
119368: LD_VAR 0 1
119372: PPUSH
119373: LD_VAR 0 2
119377: PPUSH
119378: LD_VAR 0 3
119382: PPUSH
119383: LD_VAR 0 4
119387: PPUSH
119388: LD_VAR 0 5
119392: PPUSH
119393: CALL 107529 0 5
119397: GO 119476
119399: LD_INT 300
119401: DOUBLE
119402: GREATEREQUAL
119403: IFFALSE 119411
119405: LD_INT 399
119407: DOUBLE
119408: LESSEQUAL
119409: IFTRUE 119413
119411: GO 119475
119413: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
119414: LD_VAR 0 1
119418: PPUSH
119419: LD_VAR 0 2
119423: PPUSH
119424: LD_VAR 0 3
119428: PPUSH
119429: LD_VAR 0 4
119433: PPUSH
119434: LD_VAR 0 5
119438: PPUSH
119439: LD_VAR 0 6
119443: PPUSH
119444: LD_VAR 0 7
119448: PPUSH
119449: LD_VAR 0 8
119453: PPUSH
119454: LD_VAR 0 9
119458: PPUSH
119459: LD_VAR 0 10
119463: PPUSH
119464: LD_VAR 0 11
119468: PPUSH
119469: CALL 103854 0 11
119473: GO 119476
119475: POP
// end ;
119476: PPOPN 11
119478: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
119479: LD_VAR 0 1
119483: PPUSH
119484: LD_VAR 0 2
119488: PPUSH
119489: LD_VAR 0 3
119493: PPUSH
119494: LD_VAR 0 4
119498: PPUSH
119499: LD_VAR 0 5
119503: PPUSH
119504: CALL 107265 0 5
// end ; end_of_file
119508: PPOPN 5
119510: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119511: LD_VAR 0 1
119515: PPUSH
119516: LD_VAR 0 2
119520: PPUSH
119521: LD_VAR 0 3
119525: PPUSH
119526: LD_VAR 0 4
119530: PPUSH
119531: LD_VAR 0 5
119535: PPUSH
119536: LD_VAR 0 6
119540: PPUSH
119541: CALL 91506 0 6
// end ;
119545: PPOPN 6
119547: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119548: LD_INT 0
119550: PPUSH
// begin if not units then
119551: LD_VAR 0 1
119555: NOT
119556: IFFALSE 119560
// exit ;
119558: GO 119560
// end ;
119560: PPOPN 7
119562: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119563: CALL 91410 0 0
// end ;
119567: PPOPN 1
119569: END
