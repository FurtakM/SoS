// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 98 0 0
// InitGlobalVariables ;
  19: CALL 85616 0 0
// InitMacro ;
  23: CALL 17849 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  40: LD_INT 8
  42: PPUSH
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  50: LD_INT 4
  52: PPUSH
  53: LD_INT 3
  55: PPUSH
  56: LD_INT 6
  58: PPUSH
  59: LD_INT 3
  61: PPUSH
  62: LD_INT 2
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 7
  70: PPUSH
  71: LD_INT 18
  73: PPUSH
  74: LD_INT 19
  76: PPUSH
  77: CALL 80908 0 9
// PrepareAmerican ;
  81: CALL 647 0 0
// PrepareArabian ;
  85: CALL 2598 0 0
// MC_Start ( ) ;
  89: CALL 19961 0 0
// Action ;
  93: CALL 8495 0 0
// end ;
  97: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  98: LD_INT 0
 100: PPUSH
// debug := false ;
 101: LD_ADDR_EXP 1
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// game := true ;
 109: LD_ADDR_EXP 2
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// mission_prefix := 11_ ;
 117: LD_ADDR_EXP 3
 121: PUSH
 122: LD_STRING 11_
 124: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 125: LD_ADDR_EXP 4
 129: PUSH
 130: LD_STRING 10c_
 132: ST_TO_ADDR
// ar_run := false ;
 133: LD_ADDR_EXP 5
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// ar_patrol := false ;
 141: LD_ADDR_EXP 7
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// base_captured := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// us_scout := 0 ;
 157: LD_ADDR_EXP 8
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 165: LD_ADDR_EXP 9
 169: PUSH
 170: LD_INT 0
 172: PUSH
 173: LD_INT 0
 175: PUSH
 176: LD_INT 0
 178: PUSH
 179: LD_INT 0
 181: PUSH
 182: LD_INT 0
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: LIST
 189: LIST
 190: LIST
 191: ST_TO_ADDR
// kamikazed := false ;
 192: LD_ADDR_EXP 11
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifact_stolen := false ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// artifact_get := false ;
 208: LD_ADDR_EXP 13
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 273000
 223: PUSH
 224: LD_INT 252000
 226: PUSH
 227: LD_INT 241500
 229: PUSH
 230: EMPTY
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 9
 357: PUSH
 358: EMPTY
 359: LIST
 360: LIST
 361: LIST
 362: PUSH
 363: LD_OWVAR 67
 367: ARRAY
 368: PPUSH
 369: LD_INT 3
 371: PPUSH
 372: CALL 41231 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 376: LD_INT 2
 378: PPUSH
 379: LD_INT 4
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 9
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: PUSH
 393: LD_OWVAR 67
 397: ARRAY
 398: PPUSH
 399: LD_INT 2
 401: PPUSH
 402: CALL 41231 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield3_left ) ;
 406: LD_INT 3
 408: PPUSH
 409: LD_INT 4
 411: PUSH
 412: LD_INT 6
 414: PUSH
 415: LD_INT 9
 417: PUSH
 418: EMPTY
 419: LIST
 420: LIST
 421: LIST
 422: PUSH
 423: LD_OWVAR 67
 427: ARRAY
 428: PPUSH
 429: LD_INT 1
 431: PPUSH
 432: CALL 41231 0 3
// for i = 1 to mc_bases do
 436: LD_ADDR_VAR 0 2
 440: PUSH
 441: DOUBLE
 442: LD_INT 1
 444: DEC
 445: ST_TO_ADDR
 446: LD_EXP 50
 450: PUSH
 451: FOR_TO
 452: IFFALSE 476
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 454: LD_VAR 0 2
 458: PPUSH
 459: LD_EXP 43
 463: PUSH
 464: LD_VAR 0 2
 468: ARRAY
 469: PPUSH
 470: CALL 41657 0 2
 474: GO 451
 476: POP
 477: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 478: LD_INT 1
 480: PPUSH
 481: LD_INT 14
 483: PUSH
 484: LD_INT 1
 486: PUSH
 487: LD_INT 2
 489: PUSH
 490: LD_EXP 99
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: PUSH
 501: LD_INT 14
 503: PUSH
 504: LD_INT 1
 506: PUSH
 507: LD_INT 2
 509: PUSH
 510: LD_EXP 99
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PPUSH
 525: CALL 41549 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 529: LD_INT 2
 531: PPUSH
 532: LD_INT 14
 534: PUSH
 535: LD_INT 1
 537: PUSH
 538: LD_INT 2
 540: PUSH
 541: LD_EXP 99
 545: PUSH
 546: EMPTY
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: PUSH
 552: EMPTY
 553: LIST
 554: PPUSH
 555: CALL 41549 0 2
// end ;
 559: LD_VAR 0 1
 563: RET
// function Debuger ; var i ; begin
 564: LD_INT 0
 566: PPUSH
 567: PPUSH
// if not debug then
 568: LD_EXP 1
 572: NOT
 573: IFFALSE 577
// exit ;
 575: GO 613
// game_speed := 5 ;
 577: LD_ADDR_OWVAR 65
 581: PUSH
 582: LD_INT 5
 584: ST_TO_ADDR
// uc_side := 1 ;
 585: LD_ADDR_OWVAR 20
 589: PUSH
 590: LD_INT 1
 592: ST_TO_ADDR
// uc_nation := 1 ;
 593: LD_ADDR_OWVAR 21
 597: PUSH
 598: LD_INT 1
 600: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 601: LD_EXP 36
 605: PPUSH
 606: LD_INT 1
 608: PPUSH
 609: CALL_OW 235
// end ;
 613: LD_VAR 0 1
 617: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 618: LD_INT 94
 620: PPUSH
 621: CALL_OW 301
 625: PUSH
 626: LD_INT 45
 628: PPUSH
 629: CALL_OW 302
 633: AND
 634: IFFALSE 646
 636: GO 638
 638: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 639: LD_STRING ACH_EAST
 641: PPUSH
 642: CALL_OW 543
 646: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 647: LD_INT 0
 649: PPUSH
 650: PPUSH
 651: PPUSH
 652: PPUSH
 653: PPUSH
 654: PPUSH
 655: PPUSH
 656: PPUSH
// uc_side := 4 ;
 657: LD_ADDR_OWVAR 20
 661: PUSH
 662: LD_INT 4
 664: ST_TO_ADDR
// uc_nation := 1 ;
 665: LD_ADDR_OWVAR 21
 669: PUSH
 670: LD_INT 1
 672: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 673: LD_ADDR_EXP 30
 677: PUSH
 678: LD_STRING Powell
 680: PPUSH
 681: LD_INT 0
 683: PPUSH
 684: LD_STRING 
 686: PPUSH
 687: CALL 47960 0 3
 691: ST_TO_ADDR
// uc_side := 1 ;
 692: LD_ADDR_OWVAR 20
 696: PUSH
 697: LD_INT 1
 699: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 700: LD_ADDR_EXP 21
 704: PUSH
 705: LD_STRING JMM
 707: PPUSH
 708: LD_EXP 1
 712: NOT
 713: PPUSH
 714: LD_EXP 4
 718: PPUSH
 719: CALL 47960 0 3
 723: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 724: LD_EXP 21
 728: PPUSH
 729: CALL_OW 257
 733: PUSH
 734: LD_INT 4
 736: GREATER
 737: IFFALSE 751
// SetClass ( JMM , 1 ) ;
 739: LD_EXP 21
 743: PPUSH
 744: LD_INT 1
 746: PPUSH
 747: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 751: LD_ADDR_EXP 22
 755: PUSH
 756: LD_STRING Lisa
 758: PPUSH
 759: LD_EXP 1
 763: NOT
 764: PPUSH
 765: LD_EXP 4
 769: PPUSH
 770: CALL 47960 0 3
 774: ST_TO_ADDR
// if not Lisa then
 775: LD_EXP 22
 779: NOT
 780: IFFALSE 795
// Lisa := CreateCharacter ( 10_Lisa ) ;
 782: LD_ADDR_EXP 22
 786: PUSH
 787: LD_STRING 10_Lisa
 789: PPUSH
 790: CALL_OW 34
 794: ST_TO_ADDR
// if not Lisa then
 795: LD_EXP 22
 799: NOT
 800: IFFALSE 815
// Lisa := CreateCharacter ( 09_Lisa ) ;
 802: LD_ADDR_EXP 22
 806: PUSH
 807: LD_STRING 09_Lisa
 809: PPUSH
 810: CALL_OW 34
 814: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 815: LD_ADDR_EXP 31
 819: PUSH
 820: LD_STRING Cornel
 822: PPUSH
 823: LD_EXP 1
 827: NOT
 828: PPUSH
 829: LD_EXP 4
 833: PPUSH
 834: CALL 47960 0 3
 838: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 839: LD_ADDR_EXP 23
 843: PUSH
 844: LD_STRING Donaldson
 846: PPUSH
 847: LD_EXP 1
 851: NOT
 852: PPUSH
 853: LD_EXP 4
 857: PPUSH
 858: CALL 47960 0 3
 862: ST_TO_ADDR
// if not Donaldson then
 863: LD_EXP 23
 867: NOT
 868: IFFALSE 883
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 870: LD_ADDR_EXP 23
 874: PUSH
 875: LD_STRING 10_Donaldson
 877: PPUSH
 878: CALL_OW 34
 882: ST_TO_ADDR
// if not Donaldson then
 883: LD_EXP 23
 887: NOT
 888: IFFALSE 903
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 890: LD_ADDR_EXP 23
 894: PUSH
 895: LD_STRING 09_Donaldson
 897: PPUSH
 898: CALL_OW 34
 902: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 903: LD_ADDR_EXP 24
 907: PUSH
 908: LD_STRING Bobby
 910: PPUSH
 911: LD_EXP 1
 915: NOT
 916: PPUSH
 917: LD_EXP 4
 921: PPUSH
 922: CALL 47960 0 3
 926: ST_TO_ADDR
// if not Bobby then
 927: LD_EXP 24
 931: NOT
 932: IFFALSE 947
// Bobby := CreateCharacter ( 10_Bobby ) ;
 934: LD_ADDR_EXP 24
 938: PUSH
 939: LD_STRING 10_Bobby
 941: PPUSH
 942: CALL_OW 34
 946: ST_TO_ADDR
// if not Bobby then
 947: LD_EXP 24
 951: NOT
 952: IFFALSE 967
// Bobby := CreateCharacter ( 09_Bobby ) ;
 954: LD_ADDR_EXP 24
 958: PUSH
 959: LD_STRING 09_Bobby
 961: PPUSH
 962: CALL_OW 34
 966: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 967: LD_ADDR_EXP 25
 971: PUSH
 972: LD_STRING Cyrus
 974: PPUSH
 975: LD_EXP 1
 979: NOT
 980: PPUSH
 981: LD_EXP 4
 985: PPUSH
 986: CALL 47960 0 3
 990: ST_TO_ADDR
// if not Cyrus then
 991: LD_EXP 25
 995: NOT
 996: IFFALSE 1011
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 998: LD_ADDR_EXP 25
1002: PUSH
1003: LD_STRING 10_Cyrus
1005: PPUSH
1006: CALL_OW 34
1010: ST_TO_ADDR
// if not Cyrus then
1011: LD_EXP 25
1015: NOT
1016: IFFALSE 1031
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1018: LD_ADDR_EXP 25
1022: PUSH
1023: LD_STRING 09_Cyrus
1025: PPUSH
1026: CALL_OW 34
1030: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1031: LD_ADDR_EXP 26
1035: PUSH
1036: LD_STRING Denis
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_EXP 4
1049: PPUSH
1050: CALL 47960 0 3
1054: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1055: LD_ADDR_EXP 27
1059: PUSH
1060: LD_STRING Brown
1062: PPUSH
1063: LD_EXP 1
1067: NOT
1068: PPUSH
1069: LD_EXP 4
1073: PPUSH
1074: CALL 47960 0 3
1078: ST_TO_ADDR
// if not Brown then
1079: LD_EXP 27
1083: NOT
1084: IFFALSE 1099
// Brown := CreateCharacter ( 10_Brown ) ;
1086: LD_ADDR_EXP 27
1090: PUSH
1091: LD_STRING 10_Brown
1093: PPUSH
1094: CALL_OW 34
1098: ST_TO_ADDR
// if not Brown then
1099: LD_EXP 27
1103: NOT
1104: IFFALSE 1119
// Brown := CreateCharacter ( 08_Brown ) ;
1106: LD_ADDR_EXP 27
1110: PUSH
1111: LD_STRING 08_Brown
1113: PPUSH
1114: CALL_OW 34
1118: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1119: LD_ADDR_EXP 28
1123: PUSH
1124: LD_STRING Gladstone
1126: PPUSH
1127: LD_EXP 1
1131: NOT
1132: PPUSH
1133: LD_EXP 4
1137: PPUSH
1138: CALL 47960 0 3
1142: ST_TO_ADDR
// if not Gladstone then
1143: LD_EXP 28
1147: NOT
1148: IFFALSE 1163
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1150: LD_ADDR_EXP 28
1154: PUSH
1155: LD_STRING 10_Gladstone
1157: PPUSH
1158: CALL_OW 34
1162: ST_TO_ADDR
// if not Gladstone then
1163: LD_EXP 28
1167: NOT
1168: IFFALSE 1183
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1170: LD_ADDR_EXP 28
1174: PUSH
1175: LD_STRING 08_Gladstone
1177: PPUSH
1178: CALL_OW 34
1182: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1183: LD_ADDR_EXP 29
1187: PUSH
1188: LD_STRING Houten
1190: PPUSH
1191: LD_EXP 1
1195: NOT
1196: PPUSH
1197: LD_EXP 4
1201: PPUSH
1202: CALL 47960 0 3
1206: ST_TO_ADDR
// if not Houten then
1207: LD_EXP 29
1211: NOT
1212: IFFALSE 1227
// Houten := CreateCharacter ( 10_Houten ) ;
1214: LD_ADDR_EXP 29
1218: PUSH
1219: LD_STRING 10_Houten
1221: PPUSH
1222: CALL_OW 34
1226: ST_TO_ADDR
// if not Houten then
1227: LD_EXP 29
1231: NOT
1232: IFFALSE 1247
// Houten := CreateCharacter ( 09_Houten ) ;
1234: LD_ADDR_EXP 29
1238: PUSH
1239: LD_STRING 09_Houten
1241: PPUSH
1242: CALL_OW 34
1246: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1247: LD_ADDR_EXP 31
1251: PUSH
1252: LD_STRING Cornell
1254: PPUSH
1255: LD_EXP 1
1259: NOT
1260: PPUSH
1261: LD_EXP 4
1265: PPUSH
1266: CALL 47960 0 3
1270: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1271: LD_ADDR_EXP 32
1275: PUSH
1276: LD_STRING Gary
1278: PPUSH
1279: LD_EXP 1
1283: NOT
1284: PPUSH
1285: LD_EXP 4
1289: PPUSH
1290: CALL 47960 0 3
1294: ST_TO_ADDR
// if not Gary then
1295: LD_EXP 32
1299: NOT
1300: IFFALSE 1315
// Gary := CreateCharacter ( 10_Gary ) ;
1302: LD_ADDR_EXP 32
1306: PUSH
1307: LD_STRING 10_Gary
1309: PPUSH
1310: CALL_OW 34
1314: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1315: LD_ADDR_EXP 33
1319: PUSH
1320: LD_STRING Frank
1322: PPUSH
1323: LD_EXP 1
1327: NOT
1328: PPUSH
1329: LD_EXP 4
1333: PPUSH
1334: CALL 47960 0 3
1338: ST_TO_ADDR
// if not Frank then
1339: LD_EXP 33
1343: NOT
1344: IFFALSE 1359
// Frank := CreateCharacter ( 08_Frank ) ;
1346: LD_ADDR_EXP 33
1350: PUSH
1351: LD_STRING 08_Frank
1353: PPUSH
1354: CALL_OW 34
1358: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1359: LD_ADDR_EXP 34
1363: PUSH
1364: LD_STRING Kikuchi
1366: PPUSH
1367: LD_EXP 1
1371: NOT
1372: PPUSH
1373: LD_EXP 4
1377: PPUSH
1378: CALL 47960 0 3
1382: ST_TO_ADDR
// if not Kikuchi then
1383: LD_EXP 34
1387: NOT
1388: IFFALSE 1403
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1390: LD_ADDR_EXP 34
1394: PUSH
1395: LD_STRING 08_Kikuchi
1397: PPUSH
1398: CALL_OW 34
1402: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1403: LD_ADDR_VAR 0 5
1407: PUSH
1408: LD_EXP 22
1412: PUSH
1413: LD_EXP 23
1417: PUSH
1418: LD_EXP 24
1422: PUSH
1423: LD_EXP 25
1427: PUSH
1428: LD_EXP 26
1432: PUSH
1433: LD_EXP 27
1437: PUSH
1438: LD_EXP 28
1442: PUSH
1443: LD_EXP 29
1447: PUSH
1448: LD_EXP 31
1452: PUSH
1453: LD_EXP 32
1457: PUSH
1458: LD_EXP 33
1462: PUSH
1463: LD_EXP 34
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: ST_TO_ADDR
// tmp := tmp diff 0 ;
1482: LD_ADDR_VAR 0 5
1486: PUSH
1487: LD_VAR 0 5
1491: PUSH
1492: LD_INT 0
1494: DIFF
1495: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1496: LD_ADDR_VAR 0 5
1500: PUSH
1501: LD_VAR 0 5
1505: PUSH
1506: LD_STRING 10_lock
1508: PPUSH
1509: CALL_OW 31
1513: UNION
1514: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1515: LD_ADDR_VAR 0 5
1519: PUSH
1520: LD_VAR 0 5
1524: PUSH
1525: LD_STRING 10c_lock
1527: PPUSH
1528: CALL_OW 31
1532: UNION
1533: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1534: LD_STRING 10_lock
1536: PPUSH
1537: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1541: LD_STRING 10c_lock
1543: PPUSH
1544: CALL_OW 40
// for i in tmp do
1548: LD_ADDR_VAR 0 2
1552: PUSH
1553: LD_VAR 0 5
1557: PUSH
1558: FOR_IN
1559: IFFALSE 1597
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1561: LD_VAR 0 2
1565: PPUSH
1566: CALL_OW 257
1570: PUSH
1571: LD_INT 8
1573: PUSH
1574: LD_INT 2
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: IN
1581: IFFALSE 1595
// SetClass ( i , class_soldier ) ;
1583: LD_VAR 0 2
1587: PPUSH
1588: LD_INT 1
1590: PPUSH
1591: CALL_OW 336
1595: GO 1558
1597: POP
1598: POP
// if tmp < 12 then
1599: LD_VAR 0 5
1603: PUSH
1604: LD_INT 12
1606: LESS
1607: IFFALSE 1701
// begin k := 16 - tmp ;
1609: LD_ADDR_VAR 0 3
1613: PUSH
1614: LD_INT 16
1616: PUSH
1617: LD_VAR 0 5
1621: MINUS
1622: ST_TO_ADDR
// for i = 1 to k do
1623: LD_ADDR_VAR 0 2
1627: PUSH
1628: DOUBLE
1629: LD_INT 1
1631: DEC
1632: ST_TO_ADDR
1633: LD_VAR 0 3
1637: PUSH
1638: FOR_TO
1639: IFFALSE 1699
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1641: LD_INT 0
1643: PPUSH
1644: LD_INT 1
1646: PUSH
1647: LD_INT 1
1649: PUSH
1650: LD_INT 3
1652: PUSH
1653: LD_INT 4
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: PUSH
1662: LD_INT 1
1664: PPUSH
1665: LD_INT 4
1667: PPUSH
1668: CALL_OW 12
1672: ARRAY
1673: PPUSH
1674: LD_INT 6
1676: PPUSH
1677: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1681: LD_ADDR_VAR 0 5
1685: PUSH
1686: LD_VAR 0 5
1690: PUSH
1691: CALL_OW 44
1695: ADD
1696: ST_TO_ADDR
// end ;
1697: GO 1638
1699: POP
1700: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1701: LD_ADDR_EXP 19
1705: PUSH
1706: LD_STRING 1
1708: PPUSH
1709: LD_INT 12
1711: PPUSH
1712: LD_INT 12
1714: PPUSH
1715: LD_INT -5
1717: PUSH
1718: LD_EXP 21
1722: PUSH
1723: LD_INT -2
1725: PUSH
1726: LD_INT -3
1728: PUSH
1729: LD_INT -5
1731: PUSH
1732: EMPTY
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PUSH
1739: LD_VAR 0 5
1743: ADD
1744: PUSH
1745: LD_INT -6
1747: PUSH
1748: LD_INT -4
1750: PUSH
1751: LD_EXP 30
1755: PUSH
1756: EMPTY
1757: LIST
1758: LIST
1759: LIST
1760: ADD
1761: PPUSH
1762: LD_INT 1
1764: PUSH
1765: LD_INT 4
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: LD_INT 0
1777: PUSH
1778: LD_INT 5
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: PUSH
1786: LD_INT 4
1788: PUSH
1789: LD_INT 0
1791: PUSH
1792: LD_INT 3
1794: PUSH
1795: EMPTY
1796: LIST
1797: LIST
1798: LIST
1799: PUSH
1800: LD_INT 5
1802: PUSH
1803: LD_INT 0
1805: PUSH
1806: LD_INT 2
1808: PUSH
1809: EMPTY
1810: LIST
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PPUSH
1820: CALL_OW 42
1824: ST_TO_ADDR
// others := tmp diff selected ;
1825: LD_ADDR_VAR 0 8
1829: PUSH
1830: LD_VAR 0 5
1834: PUSH
1835: LD_EXP 19
1839: DIFF
1840: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1841: LD_ADDR_VAR 0 8
1845: PUSH
1846: LD_VAR 0 8
1850: PUSH
1851: LD_EXP 22
1855: PUSH
1856: LD_EXP 23
1860: PUSH
1861: LD_EXP 24
1865: PUSH
1866: LD_EXP 25
1870: PUSH
1871: LD_EXP 26
1875: PUSH
1876: LD_EXP 27
1880: PUSH
1881: LD_EXP 28
1885: PUSH
1886: LD_EXP 29
1890: PUSH
1891: LD_EXP 31
1895: PUSH
1896: LD_EXP 32
1900: PUSH
1901: LD_EXP 33
1905: PUSH
1906: LD_EXP 34
1910: PUSH
1911: EMPTY
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: DIFF
1925: ST_TO_ADDR
// if others then
1926: LD_VAR 0 8
1930: IFFALSE 1944
// SaveCharacters ( others , 11_others ) ;
1932: LD_VAR 0 8
1936: PPUSH
1937: LD_STRING 11_others
1939: PPUSH
1940: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 3
1951: PUSH
1952: LD_INT 1
1954: PUSH
1955: LD_INT 1
1957: PUSH
1958: LD_INT 4
1960: PUSH
1961: EMPTY
1962: LIST
1963: LIST
1964: LIST
1965: LIST
1966: PUSH
1967: LD_INT 2
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 5
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: PUSH
1985: LD_INT 4
1987: PUSH
1988: LD_INT 1
1990: PUSH
1991: LD_INT 1
1993: PUSH
1994: LD_INT 5
1996: PUSH
1997: EMPTY
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: LD_INT 1
2008: PUSH
2009: LD_INT 1
2011: PUSH
2012: LD_INT 7
2014: PUSH
2015: EMPTY
2016: LIST
2017: LIST
2018: LIST
2019: LIST
2020: PUSH
2021: LD_INT 3
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 1
2029: PUSH
2030: LD_INT 7
2032: PUSH
2033: EMPTY
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: ST_TO_ADDR
// for i in JMM ^ selected do
2046: LD_ADDR_VAR 0 2
2050: PUSH
2051: LD_EXP 21
2055: PUSH
2056: LD_EXP 19
2060: ADD
2061: PUSH
2062: FOR_IN
2063: IFFALSE 2252
// begin if GetClass ( i ) = 3 then
2065: LD_VAR 0 2
2069: PPUSH
2070: CALL_OW 257
2074: PUSH
2075: LD_INT 3
2077: EQUAL
2078: IFFALSE 2235
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2080: LD_ADDR_OWVAR 37
2084: PUSH
2085: LD_VAR 0 6
2089: PUSH
2090: LD_INT 1
2092: ARRAY
2093: PUSH
2094: LD_INT 1
2096: ARRAY
2097: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2098: LD_ADDR_OWVAR 39
2102: PUSH
2103: LD_VAR 0 6
2107: PUSH
2108: LD_INT 1
2110: ARRAY
2111: PUSH
2112: LD_INT 2
2114: ARRAY
2115: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2116: LD_ADDR_OWVAR 38
2120: PUSH
2121: LD_VAR 0 6
2125: PUSH
2126: LD_INT 1
2128: ARRAY
2129: PUSH
2130: LD_INT 3
2132: ARRAY
2133: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2134: LD_ADDR_OWVAR 40
2138: PUSH
2139: LD_VAR 0 6
2143: PUSH
2144: LD_INT 1
2146: ARRAY
2147: PUSH
2148: LD_INT 4
2150: ARRAY
2151: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2152: LD_ADDR_VAR 0 6
2156: PUSH
2157: LD_VAR 0 6
2161: PPUSH
2162: LD_INT 1
2164: PPUSH
2165: CALL_OW 3
2169: ST_TO_ADDR
// veh := CreateVehicle ;
2170: LD_ADDR_VAR 0 7
2174: PUSH
2175: CALL_OW 45
2179: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2180: LD_VAR 0 7
2184: PPUSH
2185: LD_INT 8
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2195: LD_VAR 0 2
2199: PPUSH
2200: LD_VAR 0 7
2204: PPUSH
2205: CALL_OW 52
// if i = JMM then
2209: LD_VAR 0 2
2213: PUSH
2214: LD_EXP 21
2218: EQUAL
2219: IFFALSE 2233
// SetMark ( veh , 1 ) ;
2221: LD_VAR 0 7
2225: PPUSH
2226: LD_INT 1
2228: PPUSH
2229: CALL_OW 242
// end else
2233: GO 2250
// PlaceUnitArea ( i , am_hum_start , false ) ;
2235: LD_VAR 0 2
2239: PPUSH
2240: LD_INT 9
2242: PPUSH
2243: LD_INT 0
2245: PPUSH
2246: CALL_OW 49
// end ;
2250: GO 2062
2252: POP
2253: POP
// vc_chassis := us_medium_tracked ;
2254: LD_ADDR_OWVAR 37
2258: PUSH
2259: LD_INT 3
2261: ST_TO_ADDR
// vc_engine := engine_solar ;
2262: LD_ADDR_OWVAR 39
2266: PUSH
2267: LD_INT 2
2269: ST_TO_ADDR
// vc_control := control_computer ;
2270: LD_ADDR_OWVAR 38
2274: PUSH
2275: LD_INT 3
2277: ST_TO_ADDR
// vc_weapon := us_radar ;
2278: LD_ADDR_OWVAR 40
2282: PUSH
2283: LD_INT 11
2285: ST_TO_ADDR
// veh := CreateVehicle ;
2286: LD_ADDR_VAR 0 7
2290: PUSH
2291: CALL_OW 45
2295: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2296: LD_VAR 0 7
2300: PPUSH
2301: LD_INT 87
2303: PPUSH
2304: LD_INT 142
2306: PPUSH
2307: LD_INT 0
2309: PPUSH
2310: CALL_OW 48
// end ;
2314: LD_VAR 0 1
2318: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2319: LD_INT 0
2321: PPUSH
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side := 1 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 1
2332: ST_TO_ADDR
// uc_nation := 1 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 1
2340: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2341: LD_ADDR_VAR 0 3
2345: PUSH
2346: LD_INT 3
2348: PUSH
2349: LD_INT 1
2351: PUSH
2352: LD_INT 3
2354: PUSH
2355: LD_INT 5
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: LIST
2362: LIST
2363: PUSH
2364: LD_INT 3
2366: PUSH
2367: LD_INT 1
2369: PUSH
2370: LD_INT 3
2372: PUSH
2373: LD_INT 7
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: LIST
2381: PUSH
2382: LD_INT 3
2384: PUSH
2385: LD_INT 1
2387: PUSH
2388: LD_INT 3
2390: PUSH
2391: LD_INT 7
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: LIST
2398: LIST
2399: PUSH
2400: LD_INT 3
2402: PUSH
2403: LD_INT 1
2405: PUSH
2406: LD_INT 3
2408: PUSH
2409: LD_INT 11
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: LIST
2416: LIST
2417: PUSH
2418: LD_INT 4
2420: PUSH
2421: LD_INT 1
2423: PUSH
2424: LD_INT 3
2426: PUSH
2427: LD_INT 6
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: LIST
2434: LIST
2435: PUSH
2436: LD_INT 4
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: LD_INT 3
2444: PUSH
2445: LD_INT 5
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2462: LD_ADDR_VAR 0 2
2466: PUSH
2467: DOUBLE
2468: LD_INT 1
2470: DEC
2471: ST_TO_ADDR
2472: LD_INT 7
2474: PUSH
2475: LD_OWVAR 67
2479: MINUS
2480: PUSH
2481: FOR_TO
2482: IFFALSE 2591
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2484: LD_ADDR_OWVAR 37
2488: PUSH
2489: LD_VAR 0 3
2493: PUSH
2494: LD_VAR 0 2
2498: ARRAY
2499: PUSH
2500: LD_INT 1
2502: ARRAY
2503: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2504: LD_ADDR_OWVAR 39
2508: PUSH
2509: LD_VAR 0 3
2513: PUSH
2514: LD_VAR 0 2
2518: ARRAY
2519: PUSH
2520: LD_INT 2
2522: ARRAY
2523: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2524: LD_ADDR_OWVAR 38
2528: PUSH
2529: LD_VAR 0 3
2533: PUSH
2534: LD_VAR 0 2
2538: ARRAY
2539: PUSH
2540: LD_INT 3
2542: ARRAY
2543: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2544: LD_ADDR_OWVAR 40
2548: PUSH
2549: LD_VAR 0 3
2553: PUSH
2554: LD_VAR 0 2
2558: ARRAY
2559: PUSH
2560: LD_INT 4
2562: ARRAY
2563: ST_TO_ADDR
// veh := CreateVehicle ;
2564: LD_ADDR_VAR 0 4
2568: PUSH
2569: CALL_OW 45
2573: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2574: LD_VAR 0 4
2578: PPUSH
2579: LD_INT 8
2581: PPUSH
2582: LD_INT 0
2584: PPUSH
2585: CALL_OW 49
// end ;
2589: GO 2481
2591: POP
2592: POP
// end ; end_of_file
2593: LD_VAR 0 1
2597: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2598: LD_INT 0
2600: PPUSH
2601: PPUSH
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// if Difficulty = 1 then
2606: LD_OWVAR 67
2610: PUSH
2611: LD_INT 1
2613: EQUAL
2614: IFFALSE 2711
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2616: LD_ADDR_VAR 0 6
2620: PUSH
2621: LD_INT 129
2623: PUSH
2624: LD_INT 45
2626: PUSH
2627: EMPTY
2628: LIST
2629: LIST
2630: PUSH
2631: LD_INT 143
2633: PUSH
2634: LD_INT 58
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: PUSH
2641: LD_INT 184
2643: PUSH
2644: LD_INT 113
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: PUSH
2651: LD_INT 163
2653: PUSH
2654: LD_INT 107
2656: PUSH
2657: EMPTY
2658: LIST
2659: LIST
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: LIST
2665: LIST
2666: ST_TO_ADDR
// for i in tmp do
2667: LD_ADDR_VAR 0 2
2671: PUSH
2672: LD_VAR 0 6
2676: PUSH
2677: FOR_IN
2678: IFFALSE 2709
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2680: LD_VAR 0 2
2684: PUSH
2685: LD_INT 1
2687: ARRAY
2688: PPUSH
2689: LD_VAR 0 2
2693: PUSH
2694: LD_INT 2
2696: ARRAY
2697: PPUSH
2698: CALL_OW 428
2702: PPUSH
2703: CALL_OW 64
2707: GO 2677
2709: POP
2710: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2711: LD_ADDR_VAR 0 2
2715: PUSH
2716: LD_INT 21
2718: PUSH
2719: LD_INT 3
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: PPUSH
2726: CALL_OW 69
2730: PUSH
2731: FOR_IN
2732: IFFALSE 2765
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
2734: LD_VAR 0 2
2738: PPUSH
2739: LD_INT 5
2741: PUSH
2742: LD_INT 6
2744: PUSH
2745: LD_INT 7
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: LIST
2752: PUSH
2753: LD_OWVAR 67
2757: ARRAY
2758: PPUSH
2759: CALL_OW 241
2763: GO 2731
2765: POP
2766: POP
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2767: LD_ADDR_VAR 0 5
2771: PUSH
2772: LD_INT 5
2774: PUSH
2775: LD_INT 6
2777: PUSH
2778: LD_INT 7
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: LIST
2785: PUSH
2786: LD_OWVAR 67
2790: ARRAY
2791: ST_TO_ADDR
// uc_side := 2 ;
2792: LD_ADDR_OWVAR 20
2796: PUSH
2797: LD_INT 2
2799: ST_TO_ADDR
// uc_nation := 2 ;
2800: LD_ADDR_OWVAR 21
2804: PUSH
2805: LD_INT 2
2807: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2808: LD_ADDR_OWVAR 37
2812: PUSH
2813: LD_INT 14
2815: ST_TO_ADDR
// vc_engine := engine_siberite ;
2816: LD_ADDR_OWVAR 39
2820: PUSH
2821: LD_INT 3
2823: ST_TO_ADDR
// vc_control := control_manual ;
2824: LD_ADDR_OWVAR 38
2828: PUSH
2829: LD_INT 1
2831: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2832: LD_ADDR_OWVAR 40
2836: PUSH
2837: LD_INT 31
2839: ST_TO_ADDR
// for i = 1 to 3 do
2840: LD_ADDR_VAR 0 2
2844: PUSH
2845: DOUBLE
2846: LD_INT 1
2848: DEC
2849: ST_TO_ADDR
2850: LD_INT 3
2852: PUSH
2853: FOR_TO
2854: IFFALSE 2938
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2856: LD_INT 0
2858: PPUSH
2859: LD_INT 3
2861: PPUSH
2862: LD_VAR 0 5
2866: PPUSH
2867: CALL_OW 380
// un := CreateVehicle ;
2871: LD_ADDR_VAR 0 4
2875: PUSH
2876: CALL_OW 45
2880: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2881: LD_VAR 0 4
2885: PPUSH
2886: LD_INT 0
2888: PPUSH
2889: LD_INT 5
2891: PPUSH
2892: CALL_OW 12
2896: PPUSH
2897: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2901: LD_VAR 0 4
2905: PPUSH
2906: LD_INT 156
2908: PPUSH
2909: LD_INT 15
2911: PPUSH
2912: LD_INT 6
2914: PPUSH
2915: LD_INT 0
2917: PPUSH
2918: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2922: CALL_OW 44
2926: PPUSH
2927: LD_VAR 0 4
2931: PPUSH
2932: CALL_OW 52
// end ;
2936: GO 2853
2938: POP
2939: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2940: LD_ADDR_EXP 37
2944: PUSH
2945: LD_INT 94
2947: PPUSH
2948: LD_INT 28
2950: PPUSH
2951: LD_STRING dammam
2953: PPUSH
2954: LD_VAR 0 5
2958: PPUSH
2959: LD_INT 10000
2961: PUSH
2962: LD_INT 1000
2964: PUSH
2965: LD_INT 300
2967: PUSH
2968: EMPTY
2969: LIST
2970: LIST
2971: LIST
2972: PPUSH
2973: LD_INT 12
2975: PUSH
2976: LD_INT 2
2978: PUSH
2979: LD_INT 3
2981: PUSH
2982: LD_INT 4
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_OWVAR 67
2994: ARRAY
2995: PUSH
2996: LD_INT 1
2998: NEG
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PPUSH
3009: CALL 56225 0 6
3013: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
3014: LD_ADDR_EXP 37
3018: PUSH
3019: LD_EXP 37
3023: PUSH
3024: LD_INT 122
3026: PPUSH
3027: LD_INT 25
3029: PPUSH
3030: LD_STRING 
3032: PPUSH
3033: LD_VAR 0 5
3037: PPUSH
3038: LD_INT 500
3040: PUSH
3041: LD_INT 60
3043: PUSH
3044: LD_INT 0
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: LIST
3051: PPUSH
3052: LD_INT 8
3054: PUSH
3055: LD_INT 2
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 4
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: LIST
3068: PUSH
3069: LD_OWVAR 67
3073: ARRAY
3074: PUSH
3075: LD_INT 2
3077: PUSH
3078: LD_INT 0
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: PPUSH
3087: CALL 56225 0 6
3091: UNION
3092: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 10 , 4 , 3 , 2 ] ) ;
3093: LD_ADDR_EXP 35
3097: PUSH
3098: LD_INT 45
3100: PPUSH
3101: LD_INT 24
3103: PPUSH
3104: LD_STRING jeddah
3106: PPUSH
3107: LD_VAR 0 5
3111: PPUSH
3112: LD_INT 700
3114: PUSH
3115: LD_INT 300
3117: PUSH
3118: LD_INT 10
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: LIST
3125: PPUSH
3126: LD_INT 10
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: LD_INT 3
3134: PUSH
3135: LD_INT 2
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: PPUSH
3144: CALL 56225 0 6
3148: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3149: LD_ADDR_EXP 36
3153: PUSH
3154: LD_INT 7
3156: PPUSH
3157: LD_INT 27
3159: PPUSH
3160: LD_STRING riyadh
3162: PPUSH
3163: LD_VAR 0 5
3167: PPUSH
3168: LD_INT 500
3170: PUSH
3171: LD_INT 60
3173: PUSH
3174: LD_INT 0
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: LIST
3181: PPUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 3
3190: PUSH
3191: LD_INT 1
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: PPUSH
3200: CALL 56225 0 6
3204: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 10 , 2 , 3 , 1 ] ) ;
3205: LD_ADDR_EXP 39
3209: PUSH
3210: LD_INT 204
3212: PPUSH
3213: LD_INT 26
3215: PPUSH
3216: LD_STRING 
3218: PPUSH
3219: LD_VAR 0 5
3223: PPUSH
3224: LD_INT 500
3226: PUSH
3227: LD_INT 50
3229: PUSH
3230: LD_INT 0
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: LIST
3237: PPUSH
3238: LD_INT 10
3240: PUSH
3241: LD_INT 2
3243: PUSH
3244: LD_INT 3
3246: PUSH
3247: LD_INT 1
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PPUSH
3256: CALL 56225 0 6
3260: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3261: LD_ADDR_EXP 50
3265: PUSH
3266: LD_EXP 37
3270: PUSH
3271: LD_EXP 35
3275: PUSH
3276: LD_EXP 39
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3286: LD_ADDR_VAR 0 2
3290: PUSH
3291: LD_INT 22
3293: PUSH
3294: LD_INT 2
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: PUSH
3301: LD_INT 30
3303: PUSH
3304: LD_INT 31
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: PUSH
3311: LD_INT 58
3313: PUSH
3314: EMPTY
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: LIST
3321: PPUSH
3322: CALL_OW 69
3326: PUSH
3327: FOR_IN
3328: IFFALSE 3453
// begin if GetBase ( i ) then
3330: LD_VAR 0 2
3334: PPUSH
3335: CALL_OW 274
3339: IFFALSE 3343
// continue ;
3341: GO 3327
// d := GetDir ( i ) ;
3343: LD_ADDR_VAR 0 3
3347: PUSH
3348: LD_VAR 0 2
3352: PPUSH
3353: CALL_OW 254
3357: ST_TO_ADDR
// if d < 3 then
3358: LD_VAR 0 3
3362: PUSH
3363: LD_INT 3
3365: LESS
3366: IFFALSE 3384
// d := d + 3 else
3368: LD_ADDR_VAR 0 3
3372: PUSH
3373: LD_VAR 0 3
3377: PUSH
3378: LD_INT 3
3380: PLUS
3381: ST_TO_ADDR
3382: GO 3398
// d := d - 3 ;
3384: LD_ADDR_VAR 0 3
3388: PUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MINUS
3397: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3398: LD_INT 0
3400: PPUSH
3401: LD_INT 8
3403: PPUSH
3404: LD_VAR 0 5
3408: PPUSH
3409: CALL_OW 380
// un := CreateHuman ;
3413: LD_ADDR_VAR 0 4
3417: PUSH
3418: CALL_OW 44
3422: ST_TO_ADDR
// SetDir ( un , d ) ;
3423: LD_VAR 0 4
3427: PPUSH
3428: LD_VAR 0 3
3432: PPUSH
3433: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3437: LD_VAR 0 4
3441: PPUSH
3442: LD_VAR 0 2
3446: PPUSH
3447: CALL_OW 52
// end ;
3451: GO 3327
3453: POP
3454: POP
// if Difficulty > 1 then
3455: LD_OWVAR 67
3459: PUSH
3460: LD_INT 1
3462: GREATER
3463: IFFALSE 3834
// begin ar_kamikadze := [ ] ;
3465: LD_ADDR_EXP 42
3469: PUSH
3470: EMPTY
3471: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3472: LD_INT 0
3474: PPUSH
3475: LD_INT 1
3477: PPUSH
3478: LD_VAR 0 5
3482: PPUSH
3483: CALL_OW 380
// un := CreateHuman ;
3487: LD_ADDR_VAR 0 4
3491: PUSH
3492: CALL_OW 44
3496: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3497: LD_VAR 0 4
3501: PPUSH
3502: LD_INT 3
3504: PPUSH
3505: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3509: LD_VAR 0 4
3513: PPUSH
3514: LD_INT 23
3516: PPUSH
3517: LD_INT 44
3519: PPUSH
3520: LD_INT 0
3522: PPUSH
3523: CALL_OW 48
// ComCrawl ( un ) ;
3527: LD_VAR 0 4
3531: PPUSH
3532: CALL_OW 137
// un := CreateHuman ;
3536: LD_ADDR_VAR 0 4
3540: PUSH
3541: CALL_OW 44
3545: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3546: LD_VAR 0 4
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3558: LD_VAR 0 4
3562: PPUSH
3563: LD_INT 30
3565: PPUSH
3566: LD_INT 39
3568: PPUSH
3569: LD_INT 0
3571: PPUSH
3572: CALL_OW 48
// ComCrawl ( un ) ;
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3585: LD_INT 0
3587: PPUSH
3588: LD_INT 17
3590: PPUSH
3591: LD_VAR 0 5
3595: PPUSH
3596: CALL_OW 380
// un := CreateHuman ;
3600: LD_ADDR_VAR 0 4
3604: PUSH
3605: CALL_OW 44
3609: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3610: LD_VAR 0 4
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3622: LD_VAR 0 4
3626: PPUSH
3627: LD_INT 45
3629: PPUSH
3630: LD_INT 86
3632: PPUSH
3633: LD_INT 0
3635: PPUSH
3636: CALL_OW 48
// ComHold ( un ) ;
3640: LD_VAR 0 4
3644: PPUSH
3645: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3649: LD_ADDR_EXP 42
3653: PUSH
3654: LD_EXP 42
3658: PPUSH
3659: LD_EXP 42
3663: PUSH
3664: LD_INT 1
3666: PLUS
3667: PPUSH
3668: LD_VAR 0 4
3672: PPUSH
3673: CALL_OW 1
3677: ST_TO_ADDR
// un := CreateHuman ;
3678: LD_ADDR_VAR 0 4
3682: PUSH
3683: CALL_OW 44
3687: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3688: LD_VAR 0 4
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3700: LD_VAR 0 4
3704: PPUSH
3705: LD_INT 60
3707: PPUSH
3708: LD_INT 85
3710: PPUSH
3711: LD_INT 0
3713: PPUSH
3714: CALL_OW 48
// ComHold ( un ) ;
3718: LD_VAR 0 4
3722: PPUSH
3723: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3727: LD_ADDR_EXP 42
3731: PUSH
3732: LD_EXP 42
3736: PPUSH
3737: LD_EXP 42
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_VAR 0 4
3750: PPUSH
3751: CALL_OW 1
3755: ST_TO_ADDR
// un := CreateHuman ;
3756: LD_ADDR_VAR 0 4
3760: PUSH
3761: CALL_OW 44
3765: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3766: LD_VAR 0 4
3770: PPUSH
3771: LD_INT 3
3773: PPUSH
3774: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3778: LD_VAR 0 4
3782: PPUSH
3783: LD_INT 222
3785: PPUSH
3786: LD_INT 166
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// ComHold ( un ) ;
3796: LD_VAR 0 4
3800: PPUSH
3801: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3805: LD_ADDR_EXP 42
3809: PUSH
3810: LD_EXP 42
3814: PPUSH
3815: LD_EXP 42
3819: PUSH
3820: LD_INT 1
3822: PLUS
3823: PPUSH
3824: LD_VAR 0 4
3828: PPUSH
3829: CALL_OW 1
3833: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3834: LD_ADDR_EXP 40
3838: PUSH
3839: EMPTY
3840: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3841: LD_INT 1
3843: PPUSH
3844: LD_INT 1
3846: PPUSH
3847: LD_VAR 0 5
3851: PPUSH
3852: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3856: LD_ADDR_OWVAR 26
3860: PUSH
3861: LD_STRING Pavel Grigorovic
3863: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3864: LD_ADDR_OWVAR 33
3868: PUSH
3869: LD_STRING SecondCharsGal
3871: ST_TO_ADDR
// hc_face_number := 4 ;
3872: LD_ADDR_OWVAR 34
3876: PUSH
3877: LD_INT 4
3879: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3880: LD_ADDR_EXP 40
3884: PUSH
3885: LD_EXP 40
3889: PPUSH
3890: LD_INT 1
3892: PPUSH
3893: CALL_OW 44
3897: PPUSH
3898: CALL_OW 1
3902: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3903: LD_INT 2
3905: PPUSH
3906: LD_INT 4
3908: PPUSH
3909: LD_INT 2
3911: PPUSH
3912: CALL_OW 380
// hc_name := Lucy Sebel ;
3916: LD_ADDR_OWVAR 26
3920: PUSH
3921: LD_STRING Lucy Sebel
3923: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3924: LD_ADDR_OWVAR 33
3928: PUSH
3929: LD_STRING SecondCharsGal
3931: ST_TO_ADDR
// hc_face_number := 15 ;
3932: LD_ADDR_OWVAR 34
3936: PUSH
3937: LD_INT 15
3939: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3940: LD_ADDR_EXP 40
3944: PUSH
3945: LD_EXP 40
3949: PPUSH
3950: LD_INT 2
3952: PPUSH
3953: CALL_OW 44
3957: PPUSH
3958: CALL_OW 1
3962: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3963: LD_INT 2
3965: PPUSH
3966: LD_INT 4
3968: PPUSH
3969: LD_INT 2
3971: PPUSH
3972: CALL_OW 380
// hc_gallery :=  ;
3976: LD_ADDR_OWVAR 33
3980: PUSH
3981: LD_STRING 
3983: ST_TO_ADDR
// hc_name :=  ;
3984: LD_ADDR_OWVAR 26
3988: PUSH
3989: LD_STRING 
3991: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3992: LD_ADDR_EXP 40
3996: PUSH
3997: LD_EXP 40
4001: PPUSH
4002: LD_INT 3
4004: PPUSH
4005: CALL_OW 44
4009: PPUSH
4010: CALL_OW 1
4014: ST_TO_ADDR
// hc_sex := sex_male ;
4015: LD_ADDR_OWVAR 27
4019: PUSH
4020: LD_INT 1
4022: ST_TO_ADDR
// hc_class = 11 ;
4023: LD_ADDR_OWVAR 28
4027: PUSH
4028: LD_INT 11
4030: ST_TO_ADDR
// hc_gallery = sandar ;
4031: LD_ADDR_OWVAR 33
4035: PUSH
4036: LD_STRING sandar
4038: ST_TO_ADDR
// hc_face_number = 33 ;
4039: LD_ADDR_OWVAR 34
4043: PUSH
4044: LD_INT 33
4046: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4047: LD_ADDR_OWVAR 26
4051: PUSH
4052: LD_STRING Thabit Muhair Saliba
4054: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4055: LD_ADDR_OWVAR 31
4059: PUSH
4060: LD_INT 0
4062: PUSH
4063: LD_INT 0
4065: PUSH
4066: LD_INT 0
4068: PUSH
4069: LD_INT 0
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: LIST
4076: LIST
4077: ST_TO_ADDR
// Saliba = CreateHuman ;
4078: LD_ADDR_EXP 44
4082: PUSH
4083: CALL_OW 44
4087: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4088: LD_EXP 44
4092: PPUSH
4093: LD_INT 7
4095: PPUSH
4096: CALL_OW 52
// if gensher_active then
4100: LD_EXP 18
4104: IFFALSE 4131
// begin Gensher = NewCharacter ( Dietrich ) ;
4106: LD_ADDR_EXP 45
4110: PUSH
4111: LD_STRING Dietrich
4113: PPUSH
4114: CALL_OW 25
4118: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4119: LD_EXP 45
4123: PPUSH
4124: LD_INT 94
4126: PPUSH
4127: CALL_OW 52
// end ; InitHc ;
4131: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4135: LD_ADDR_EXP 41
4139: PUSH
4140: EMPTY
4141: ST_TO_ADDR
// for i = 1 to 5 do
4142: LD_ADDR_VAR 0 2
4146: PUSH
4147: DOUBLE
4148: LD_INT 1
4150: DEC
4151: ST_TO_ADDR
4152: LD_INT 5
4154: PUSH
4155: FOR_TO
4156: IFFALSE 4328
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4158: LD_INT 13
4160: PUSH
4161: LD_INT 14
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 2
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 1
4182: PUSH
4183: LD_INT 2
4185: PUSH
4186: EMPTY
4187: LIST
4188: LIST
4189: PUSH
4190: LD_INT 1
4192: PPUSH
4193: LD_INT 2
4195: PPUSH
4196: CALL_OW 12
4200: ARRAY
4201: PPUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 25
4207: PUSH
4208: LD_INT 27
4210: PUSH
4211: LD_INT 26
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: LIST
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 60
4233: PPUSH
4234: LD_INT 100
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 52784 0 5
// un := CreateVehicle ;
4246: LD_ADDR_VAR 0 4
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4256: LD_ADDR_EXP 41
4260: PUSH
4261: LD_EXP 41
4265: PPUSH
4266: LD_EXP 41
4270: PUSH
4271: LD_INT 1
4273: PLUS
4274: PPUSH
4275: LD_VAR 0 4
4279: PPUSH
4280: CALL_OW 1
4284: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4285: LD_VAR 0 4
4289: PPUSH
4290: LD_INT 0
4292: PPUSH
4293: LD_INT 5
4295: PPUSH
4296: CALL_OW 12
4300: PPUSH
4301: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4305: LD_VAR 0 4
4309: PPUSH
4310: LD_INT 124
4312: PPUSH
4313: LD_INT 141
4315: PPUSH
4316: LD_INT 8
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL_OW 50
// end ;
4326: GO 4155
4328: POP
4329: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4330: LD_ADDR_EXP 43
4334: PUSH
4335: EMPTY
4336: PUSH
4337: EMPTY
4338: PUSH
4339: EMPTY
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: LIST
4345: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
4346: LD_ADDR_VAR 0 3
4350: PUSH
4351: DOUBLE
4352: LD_INT 1
4354: DEC
4355: ST_TO_ADDR
4356: LD_INT 3
4358: PUSH
4359: LD_INT 3
4361: PUSH
4362: LD_INT 4
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: LIST
4369: PUSH
4370: LD_OWVAR 67
4374: ARRAY
4375: PUSH
4376: FOR_TO
4377: IFFALSE 4591
// for i = 1 to 3 do
4379: LD_ADDR_VAR 0 2
4383: PUSH
4384: DOUBLE
4385: LD_INT 1
4387: DEC
4388: ST_TO_ADDR
4389: LD_INT 3
4391: PUSH
4392: FOR_TO
4393: IFFALSE 4587
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4395: LD_INT 14
4397: PPUSH
4398: LD_INT 3
4400: PUSH
4401: LD_INT 2
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 1
4410: PPUSH
4411: LD_INT 2
4413: PPUSH
4414: CALL_OW 12
4418: ARRAY
4419: PPUSH
4420: LD_INT 1
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 1
4432: PPUSH
4433: LD_INT 2
4435: PPUSH
4436: CALL_OW 12
4440: ARRAY
4441: PPUSH
4442: LD_INT 25
4444: PUSH
4445: LD_INT 27
4447: PUSH
4448: LD_INT 26
4450: PUSH
4451: LD_INT 28
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 1
4462: PPUSH
4463: LD_INT 4
4465: PPUSH
4466: CALL_OW 12
4470: ARRAY
4471: PPUSH
4472: LD_INT 100
4474: PPUSH
4475: CALL 52784 0 5
// un := CreateVehicle ;
4479: LD_ADDR_VAR 0 4
4483: PUSH
4484: CALL_OW 45
4488: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4489: LD_ADDR_EXP 43
4493: PUSH
4494: LD_EXP 43
4498: PPUSH
4499: LD_VAR 0 2
4503: PUSH
4504: LD_EXP 43
4508: PUSH
4509: LD_VAR 0 2
4513: ARRAY
4514: PUSH
4515: LD_INT 1
4517: PLUS
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PPUSH
4523: LD_VAR 0 4
4527: PPUSH
4528: CALL 52906 0 3
4532: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4533: LD_VAR 0 4
4537: PPUSH
4538: LD_INT 0
4540: PPUSH
4541: LD_INT 5
4543: PPUSH
4544: CALL_OW 12
4548: PPUSH
4549: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4553: LD_VAR 0 4
4557: PPUSH
4558: LD_INT 20
4560: PUSH
4561: LD_INT 21
4563: PUSH
4564: LD_INT 22
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: LIST
4571: PUSH
4572: LD_VAR 0 2
4576: ARRAY
4577: PPUSH
4578: LD_INT 0
4580: PPUSH
4581: CALL_OW 49
// end ;
4585: GO 4392
4587: POP
4588: POP
4589: GO 4376
4591: POP
4592: POP
// InitHc ;
4593: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4597: LD_INT 4
4599: PPUSH
4600: LD_INT 5
4602: PPUSH
4603: LD_INT 10
4605: PPUSH
4606: LD_INT 5
4608: PPUSH
4609: LD_INT 0
4611: PPUSH
4612: CALL_OW 58
// end ;
4616: LD_VAR 0 1
4620: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4621: LD_EXP 42
4625: IFFALSE 4699
4627: GO 4629
4629: DISABLE
4630: LD_INT 0
4632: PPUSH
// begin enable ;
4633: ENABLE
// for i in ar_kamikadze do
4634: LD_ADDR_VAR 0 1
4638: PUSH
4639: LD_EXP 42
4643: PUSH
4644: FOR_IN
4645: IFFALSE 4697
// if See ( 1 , i ) then
4647: LD_INT 1
4649: PPUSH
4650: LD_VAR 0 1
4654: PPUSH
4655: CALL_OW 292
4659: IFFALSE 4695
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4661: LD_VAR 0 1
4665: PPUSH
4666: LD_INT 81
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PPUSH
4676: CALL_OW 69
4680: PPUSH
4681: LD_VAR 0 1
4685: PPUSH
4686: CALL_OW 74
4690: PPUSH
4691: CALL_OW 115
4695: GO 4644
4697: POP
4698: POP
// end ;
4699: PPOPN 1
4701: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4702: LD_EXP 13
4706: IFFALSE 5023
4708: GO 4710
4710: DISABLE
4711: LD_INT 0
4713: PPUSH
4714: PPUSH
4715: PPUSH
4716: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4717: LD_INT 35
4719: PPUSH
4720: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4724: LD_INT 1
4726: PPUSH
4727: CALL 41945 0 1
4731: PUSH
4732: LD_INT 0
4734: EQUAL
4735: IFFALSE 4717
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4737: LD_INT 1
4739: PPUSH
4740: LD_INT 14
4742: PUSH
4743: LD_INT 3
4745: PUSH
4746: LD_INT 2
4748: PUSH
4749: LD_INT 32
4751: PUSH
4752: EMPTY
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: PUSH
4758: EMPTY
4759: LIST
4760: PPUSH
4761: CALL 41549 0 2
// repeat wait ( 0 0$1 ) ;
4765: LD_INT 35
4767: PPUSH
4768: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4772: LD_EXP 69
4776: PUSH
4777: LD_INT 1
4779: ARRAY
4780: PPUSH
4781: LD_INT 33
4783: PUSH
4784: LD_INT 2
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: PUSH
4791: LD_INT 34
4793: PUSH
4794: LD_INT 32
4796: PUSH
4797: EMPTY
4798: LIST
4799: LIST
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PPUSH
4805: CALL_OW 72
4809: IFFALSE 4765
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4811: LD_ADDR_VAR 0 2
4815: PUSH
4816: LD_EXP 69
4820: PUSH
4821: LD_INT 1
4823: ARRAY
4824: PPUSH
4825: LD_INT 33
4827: PUSH
4828: LD_INT 2
4830: PUSH
4831: EMPTY
4832: LIST
4833: LIST
4834: PUSH
4835: LD_INT 34
4837: PUSH
4838: LD_INT 32
4840: PUSH
4841: EMPTY
4842: LIST
4843: LIST
4844: PUSH
4845: EMPTY
4846: LIST
4847: LIST
4848: PPUSH
4849: CALL_OW 72
4853: PUSH
4854: LD_INT 1
4856: ARRAY
4857: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4858: LD_ADDR_VAR 0 4
4862: PUSH
4863: LD_INT 5
4865: PPUSH
4866: CALL_OW 469
4870: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4871: LD_INT 35
4873: PPUSH
4874: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4878: LD_ADDR_VAR 0 4
4882: PUSH
4883: LD_INT 5
4885: PPUSH
4886: CALL_OW 469
4890: ST_TO_ADDR
// tmp := 100 ;
4891: LD_ADDR_VAR 0 3
4895: PUSH
4896: LD_INT 100
4898: ST_TO_ADDR
// if pos then
4899: LD_VAR 0 4
4903: IFFALSE 4943
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4905: LD_ADDR_VAR 0 3
4909: PUSH
4910: LD_INT 2
4912: PPUSH
4913: LD_VAR 0 4
4917: PUSH
4918: LD_INT 1
4920: ARRAY
4921: PPUSH
4922: LD_VAR 0 4
4926: PUSH
4927: LD_INT 2
4929: ARRAY
4930: PPUSH
4931: LD_INT 20
4933: PPUSH
4934: CALL 53802 0 4
4938: PUSH
4939: LD_INT 4
4941: ARRAY
4942: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4943: LD_VAR 0 4
4947: PUSH
4948: LD_EXP 14
4952: NOT
4953: AND
4954: PUSH
4955: LD_VAR 0 3
4959: PUSH
4960: LD_INT 10
4962: LESS
4963: AND
4964: IFFALSE 4871
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4966: LD_VAR 0 2
4970: PPUSH
4971: LD_VAR 0 4
4975: PUSH
4976: LD_INT 1
4978: ARRAY
4979: PPUSH
4980: LD_VAR 0 4
4984: PUSH
4985: LD_INT 2
4987: ARRAY
4988: PPUSH
4989: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_INT 198
5000: PPUSH
5001: LD_INT 113
5003: PPUSH
5004: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5008: LD_VAR 0 2
5012: PPUSH
5013: LD_INT 124
5015: PPUSH
5016: LD_INT 7
5018: PPUSH
5019: CALL_OW 171
// end ;
5023: PPOPN 4
5025: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5026: LD_EXP 6
5030: IFFALSE 7871
5032: GO 5034
5034: DISABLE
5035: LD_INT 0
5037: PPUSH
5038: PPUSH
5039: PPUSH
5040: PPUSH
5041: PPUSH
5042: PPUSH
5043: PPUSH
5044: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
5045: LD_ADDR_VAR 0 4
5049: PUSH
5050: LD_INT 5
5052: PUSH
5053: LD_INT 6
5055: PUSH
5056: LD_INT 7
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: LIST
5063: PUSH
5064: LD_OWVAR 67
5068: ARRAY
5069: ST_TO_ADDR
// coords := [ ] ;
5070: LD_ADDR_VAR 0 5
5074: PUSH
5075: EMPTY
5076: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5077: LD_ADDR_VAR 0 6
5081: PUSH
5082: LD_INT 0
5084: PUSH
5085: LD_INT 0
5087: PUSH
5088: LD_INT 0
5090: PUSH
5091: LD_INT 0
5093: PUSH
5094: LD_INT 1
5096: PUSH
5097: LD_INT 0
5099: PUSH
5100: LD_INT 0
5102: PUSH
5103: LD_INT 0
5105: PUSH
5106: LD_INT 1
5108: PUSH
5109: LD_INT 0
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: LIST
5119: LIST
5120: LIST
5121: LIST
5122: LIST
5123: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5124: LD_INT 1
5126: PPUSH
5127: LD_INT 14
5129: PUSH
5130: LD_INT 1
5132: PUSH
5133: LD_INT 2
5135: PUSH
5136: LD_INT 28
5138: PUSH
5139: EMPTY
5140: LIST
5141: LIST
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 14
5147: PUSH
5148: LD_INT 1
5150: PUSH
5151: LD_INT 2
5153: PUSH
5154: LD_INT 25
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: PUSH
5163: LD_INT 14
5165: PUSH
5166: LD_INT 1
5168: PUSH
5169: LD_INT 2
5171: PUSH
5172: LD_INT 28
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: LIST
5180: PUSH
5181: LD_INT 14
5183: PUSH
5184: LD_INT 1
5186: PUSH
5187: LD_INT 2
5189: PUSH
5190: LD_INT 29
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: PUSH
5199: EMPTY
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: PPUSH
5205: CALL 41549 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
5209: LD_INT 21000
5211: PUSH
5212: LD_INT 19950
5214: PUSH
5215: LD_INT 18900
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: LIST
5222: PUSH
5223: LD_OWVAR 67
5227: ARRAY
5228: PPUSH
5229: CALL_OW 67
// InitHc ;
5233: CALL_OW 19
// InitUc ;
5237: CALL_OW 18
// uc_side := 2 ;
5241: LD_ADDR_OWVAR 20
5245: PUSH
5246: LD_INT 2
5248: ST_TO_ADDR
// uc_nation := 2 ;
5249: LD_ADDR_OWVAR 21
5253: PUSH
5254: LD_INT 2
5256: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5257: LD_ADDR_VAR 0 3
5261: PUSH
5262: EMPTY
5263: PUSH
5264: EMPTY
5265: PUSH
5266: EMPTY
5267: PUSH
5268: EMPTY
5269: PUSH
5270: EMPTY
5271: PUSH
5272: EMPTY
5273: LIST
5274: LIST
5275: LIST
5276: LIST
5277: LIST
5278: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5279: LD_ADDR_VAR 0 3
5283: PUSH
5284: LD_VAR 0 3
5288: PPUSH
5289: LD_INT 1
5291: PPUSH
5292: LD_EXP 69
5296: PUSH
5297: LD_INT 1
5299: ARRAY
5300: PUSH
5301: LD_INT 2
5303: PUSH
5304: LD_INT 34
5306: PUSH
5307: LD_EXP 99
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PUSH
5316: LD_INT 34
5318: PUSH
5319: LD_INT 32
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: PUSH
5326: EMPTY
5327: LIST
5328: LIST
5329: LIST
5330: PPUSH
5331: CALL_OW 69
5335: DIFF
5336: PPUSH
5337: CALL_OW 1
5341: ST_TO_ADDR
// for i = 1 to Difficulty do
5342: LD_ADDR_VAR 0 1
5346: PUSH
5347: DOUBLE
5348: LD_INT 1
5350: DEC
5351: ST_TO_ADDR
5352: LD_OWVAR 67
5356: PUSH
5357: FOR_TO
5358: IFFALSE 5496
// begin uc_side := 2 ;
5360: LD_ADDR_OWVAR 20
5364: PUSH
5365: LD_INT 2
5367: ST_TO_ADDR
// uc_nation := 2 ;
5368: LD_ADDR_OWVAR 21
5372: PUSH
5373: LD_INT 2
5375: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5376: LD_INT 13
5378: PPUSH
5379: LD_INT 3
5381: PPUSH
5382: LD_INT 5
5384: PPUSH
5385: LD_INT 29
5387: PPUSH
5388: LD_INT 100
5390: PPUSH
5391: CALL 52784 0 5
// un := CreateVehicle ;
5395: LD_ADDR_VAR 0 2
5399: PUSH
5400: CALL_OW 45
5404: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5405: LD_ADDR_VAR 0 3
5409: PUSH
5410: LD_VAR 0 3
5414: PPUSH
5415: LD_INT 1
5417: PUSH
5418: LD_VAR 0 3
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PUSH
5427: LD_INT 1
5429: PLUS
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PPUSH
5435: LD_VAR 0 2
5439: PPUSH
5440: CALL 52906 0 3
5444: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5445: LD_VAR 0 2
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5457: LD_VAR 0 2
5461: PPUSH
5462: LD_INT 16
5464: PPUSH
5465: LD_INT 0
5467: PPUSH
5468: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5472: LD_VAR 0 2
5476: PPUSH
5477: LD_INT 51
5479: PPUSH
5480: LD_INT 10
5482: PPUSH
5483: CALL_OW 111
// wait ( 0 0$2 ) ;
5487: LD_INT 70
5489: PPUSH
5490: CALL_OW 67
// end ;
5494: GO 5357
5496: POP
5497: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5498: LD_ADDR_VAR 0 5
5502: PUSH
5503: LD_INT 51
5505: PUSH
5506: LD_INT 24
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: PUSH
5513: LD_INT 75
5515: PUSH
5516: LD_INT 90
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5527: LD_INT 1
5529: PPUSH
5530: LD_VAR 0 3
5534: PUSH
5535: LD_INT 1
5537: ARRAY
5538: PPUSH
5539: LD_VAR 0 5
5543: PPUSH
5544: LD_VAR 0 6
5548: PPUSH
5549: CALL 41782 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5553: LD_ADDR_VAR 0 1
5557: PUSH
5558: DOUBLE
5559: LD_INT 1
5561: DEC
5562: ST_TO_ADDR
5563: LD_INT 1
5565: PUSH
5566: LD_INT 3
5568: PUSH
5569: LD_INT 3
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: LIST
5576: PUSH
5577: LD_OWVAR 67
5581: ARRAY
5582: PUSH
5583: FOR_TO
5584: IFFALSE 5684
// begin uc_side := 2 ;
5586: LD_ADDR_OWVAR 20
5590: PUSH
5591: LD_INT 2
5593: ST_TO_ADDR
// uc_nation := 2 ;
5594: LD_ADDR_OWVAR 21
5598: PUSH
5599: LD_INT 2
5601: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5602: LD_INT 0
5604: PPUSH
5605: LD_INT 17
5607: PPUSH
5608: LD_VAR 0 4
5612: PPUSH
5613: CALL_OW 380
// un := CreateHuman ;
5617: LD_ADDR_VAR 0 2
5621: PUSH
5622: CALL_OW 44
5626: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5627: LD_ADDR_VAR 0 3
5631: PUSH
5632: LD_VAR 0 3
5636: PPUSH
5637: LD_INT 2
5639: PUSH
5640: LD_VAR 0 3
5644: PUSH
5645: LD_INT 2
5647: ARRAY
5648: PUSH
5649: LD_INT 1
5651: PLUS
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: PPUSH
5657: LD_VAR 0 2
5661: PPUSH
5662: CALL 52906 0 3
5666: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5667: LD_VAR 0 2
5671: PPUSH
5672: LD_INT 13
5674: PPUSH
5675: LD_INT 0
5677: PPUSH
5678: CALL_OW 49
// end ;
5682: GO 5583
5684: POP
5685: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5686: LD_ADDR_VAR 0 1
5690: PUSH
5691: DOUBLE
5692: LD_INT 1
5694: DEC
5695: ST_TO_ADDR
5696: LD_INT 3
5698: PUSH
5699: LD_INT 4
5701: PUSH
5702: LD_INT 4
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_OWVAR 67
5714: ARRAY
5715: PUSH
5716: FOR_TO
5717: IFFALSE 5838
// begin uc_side := 2 ;
5719: LD_ADDR_OWVAR 20
5723: PUSH
5724: LD_INT 2
5726: ST_TO_ADDR
// uc_nation := 2 ;
5727: LD_ADDR_OWVAR 21
5731: PUSH
5732: LD_INT 2
5734: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5735: LD_INT 0
5737: PPUSH
5738: LD_INT 1
5740: PUSH
5741: LD_INT 8
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: LD_VAR 0 1
5752: PUSH
5753: LD_INT 2
5755: MOD
5756: PUSH
5757: LD_INT 1
5759: PLUS
5760: ARRAY
5761: PPUSH
5762: LD_VAR 0 4
5766: PPUSH
5767: CALL_OW 380
// un := CreateHuman ;
5771: LD_ADDR_VAR 0 2
5775: PUSH
5776: CALL_OW 44
5780: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5781: LD_ADDR_VAR 0 3
5785: PUSH
5786: LD_VAR 0 3
5790: PPUSH
5791: LD_INT 2
5793: PUSH
5794: LD_VAR 0 3
5798: PUSH
5799: LD_INT 2
5801: ARRAY
5802: PUSH
5803: LD_INT 1
5805: PLUS
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: LD_VAR 0 2
5815: PPUSH
5816: CALL 52906 0 3
5820: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5821: LD_VAR 0 2
5825: PPUSH
5826: LD_INT 13
5828: PPUSH
5829: LD_INT 0
5831: PPUSH
5832: CALL_OW 49
// end ;
5836: GO 5716
5838: POP
5839: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5840: LD_ADDR_VAR 0 5
5844: PUSH
5845: LD_INT 67
5847: PUSH
5848: LD_INT 112
5850: PUSH
5851: EMPTY
5852: LIST
5853: LIST
5854: PUSH
5855: LD_INT 85
5857: PUSH
5858: LD_INT 130
5860: PUSH
5861: EMPTY
5862: LIST
5863: LIST
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5869: LD_INT 2
5871: PPUSH
5872: LD_VAR 0 3
5876: PUSH
5877: LD_INT 2
5879: ARRAY
5880: PPUSH
5881: LD_VAR 0 5
5885: PPUSH
5886: LD_VAR 0 6
5890: PPUSH
5891: CALL 41782 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5895: LD_ADDR_VAR 0 1
5899: PUSH
5900: DOUBLE
5901: LD_INT 1
5903: DEC
5904: ST_TO_ADDR
5905: LD_INT 1
5907: PUSH
5908: LD_INT 2
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: LIST
5918: PUSH
5919: LD_OWVAR 67
5923: ARRAY
5924: PUSH
5925: FOR_TO
5926: IFFALSE 6026
// begin uc_side := 2 ;
5928: LD_ADDR_OWVAR 20
5932: PUSH
5933: LD_INT 2
5935: ST_TO_ADDR
// uc_nation := 2 ;
5936: LD_ADDR_OWVAR 21
5940: PUSH
5941: LD_INT 2
5943: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5944: LD_INT 0
5946: PPUSH
5947: LD_INT 17
5949: PPUSH
5950: LD_VAR 0 4
5954: PPUSH
5955: CALL_OW 380
// un := CreateHuman ;
5959: LD_ADDR_VAR 0 2
5963: PUSH
5964: CALL_OW 44
5968: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5969: LD_ADDR_VAR 0 3
5973: PUSH
5974: LD_VAR 0 3
5978: PPUSH
5979: LD_INT 3
5981: PUSH
5982: LD_VAR 0 3
5986: PUSH
5987: LD_INT 3
5989: ARRAY
5990: PUSH
5991: LD_INT 1
5993: PLUS
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PPUSH
5999: LD_VAR 0 2
6003: PPUSH
6004: CALL 52906 0 3
6008: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6009: LD_VAR 0 2
6013: PPUSH
6014: LD_INT 14
6016: PPUSH
6017: LD_INT 0
6019: PPUSH
6020: CALL_OW 49
// end ;
6024: GO 5925
6026: POP
6027: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6028: LD_ADDR_VAR 0 5
6032: PUSH
6033: LD_INT 148
6035: PUSH
6036: LD_INT 158
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PUSH
6043: LD_INT 148
6045: PUSH
6046: LD_INT 158
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6057: LD_INT 3
6059: PPUSH
6060: LD_VAR 0 3
6064: PUSH
6065: LD_INT 3
6067: ARRAY
6068: PPUSH
6069: LD_VAR 0 5
6073: PPUSH
6074: LD_VAR 0 6
6078: PPUSH
6079: CALL 41782 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
6083: LD_ADDR_VAR 0 1
6087: PUSH
6088: DOUBLE
6089: LD_INT 1
6091: DEC
6092: ST_TO_ADDR
6093: LD_INT 2
6095: PUSH
6096: LD_INT 4
6098: PUSH
6099: LD_INT 4
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: LIST
6106: PUSH
6107: LD_OWVAR 67
6111: ARRAY
6112: PUSH
6113: FOR_TO
6114: IFFALSE 6338
// begin uc_side := 2 ;
6116: LD_ADDR_OWVAR 20
6120: PUSH
6121: LD_INT 2
6123: ST_TO_ADDR
// uc_nation := 2 ;
6124: LD_ADDR_OWVAR 21
6128: PUSH
6129: LD_INT 2
6131: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6132: LD_INT 14
6134: PPUSH
6135: LD_INT 3
6137: PPUSH
6138: LD_INT 1
6140: PUSH
6141: LD_INT 5
6143: PUSH
6144: EMPTY
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 1
6150: PPUSH
6151: LD_INT 2
6153: PPUSH
6154: CALL_OW 12
6158: ARRAY
6159: PPUSH
6160: LD_INT 27
6162: PUSH
6163: LD_INT 26
6165: PUSH
6166: LD_INT 28
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 1
6176: PPUSH
6177: LD_INT 3
6179: PPUSH
6180: CALL_OW 12
6184: ARRAY
6185: PPUSH
6186: LD_INT 100
6188: PPUSH
6189: CALL 52784 0 5
// un := CreateVehicle ;
6193: LD_ADDR_VAR 0 2
6197: PUSH
6198: CALL_OW 45
6202: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6203: LD_ADDR_VAR 0 3
6207: PUSH
6208: LD_VAR 0 3
6212: PPUSH
6213: LD_INT 4
6215: PUSH
6216: LD_VAR 0 3
6220: PUSH
6221: LD_INT 4
6223: ARRAY
6224: PUSH
6225: LD_INT 1
6227: PLUS
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: PPUSH
6233: LD_VAR 0 2
6237: PPUSH
6238: CALL 52906 0 3
6242: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6243: LD_VAR 0 2
6247: PPUSH
6248: LD_INT 5
6250: PPUSH
6251: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6255: LD_VAR 0 2
6259: PPUSH
6260: LD_INT 15
6262: PPUSH
6263: LD_INT 0
6265: PPUSH
6266: CALL_OW 49
// if GetControl ( un ) = control_manual then
6270: LD_VAR 0 2
6274: PPUSH
6275: CALL_OW 263
6279: PUSH
6280: LD_INT 1
6282: EQUAL
6283: IFFALSE 6314
// begin PrepareHuman ( false , 3 , skill ) ;
6285: LD_INT 0
6287: PPUSH
6288: LD_INT 3
6290: PPUSH
6291: LD_VAR 0 4
6295: PPUSH
6296: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6300: CALL_OW 44
6304: PPUSH
6305: LD_VAR 0 2
6309: PPUSH
6310: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6314: LD_VAR 0 2
6318: PPUSH
6319: LD_INT 179
6321: PPUSH
6322: LD_INT 135
6324: PPUSH
6325: CALL_OW 111
// wait ( 0 0$2 ) ;
6329: LD_INT 70
6331: PPUSH
6332: CALL_OW 67
// end ;
6336: GO 6113
6338: POP
6339: POP
// vc_chassis := 15 ;
6340: LD_ADDR_OWVAR 37
6344: PUSH
6345: LD_INT 15
6347: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6348: LD_ADDR_VAR 0 3
6352: PUSH
6353: LD_VAR 0 3
6357: PPUSH
6358: LD_INT 4
6360: PUSH
6361: LD_VAR 0 3
6365: PUSH
6366: LD_INT 4
6368: ARRAY
6369: PUSH
6370: LD_INT 1
6372: PLUS
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: PPUSH
6378: CALL_OW 45
6382: PPUSH
6383: CALL 52906 0 3
6387: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6388: LD_VAR 0 3
6392: PUSH
6393: LD_INT 4
6395: ARRAY
6396: PUSH
6397: LD_VAR 0 3
6401: PUSH
6402: LD_INT 4
6404: ARRAY
6405: ARRAY
6406: PPUSH
6407: LD_INT 15
6409: PPUSH
6410: LD_INT 0
6412: PPUSH
6413: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6417: LD_INT 0
6419: PPUSH
6420: LD_INT 11
6422: PPUSH
6423: LD_VAR 0 4
6427: PPUSH
6428: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6432: LD_ADDR_VAR 0 3
6436: PUSH
6437: LD_VAR 0 3
6441: PPUSH
6442: LD_INT 4
6444: PUSH
6445: LD_VAR 0 3
6449: PUSH
6450: LD_INT 4
6452: ARRAY
6453: PUSH
6454: LD_INT 1
6456: PLUS
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: PPUSH
6462: CALL_OW 44
6466: PPUSH
6467: CALL 52906 0 3
6471: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6472: LD_VAR 0 3
6476: PUSH
6477: LD_INT 4
6479: ARRAY
6480: PUSH
6481: LD_VAR 0 3
6485: PUSH
6486: LD_INT 4
6488: ARRAY
6489: ARRAY
6490: PPUSH
6491: LD_VAR 0 3
6495: PUSH
6496: LD_INT 4
6498: ARRAY
6499: PUSH
6500: LD_VAR 0 3
6504: PUSH
6505: LD_INT 4
6507: ARRAY
6508: PUSH
6509: LD_INT 1
6511: MINUS
6512: ARRAY
6513: PPUSH
6514: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6518: LD_ADDR_VAR 0 5
6522: PUSH
6523: LD_INT 148
6525: PUSH
6526: LD_INT 140
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: PUSH
6533: EMPTY
6534: LIST
6535: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6536: LD_INT 1
6538: PPUSH
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PPUSH
6548: LD_VAR 0 5
6552: PPUSH
6553: LD_VAR 0 6
6557: PPUSH
6558: CALL 41782 0 4
// if gensher_active then
6562: LD_EXP 18
6566: IFFALSE 6968
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6568: LD_EXP 45
6572: PPUSH
6573: LD_STRING D10-Diet-1
6575: PPUSH
6576: CALL_OW 94
// for i = 1 to 2 do
6580: LD_ADDR_VAR 0 1
6584: PUSH
6585: DOUBLE
6586: LD_INT 1
6588: DEC
6589: ST_TO_ADDR
6590: LD_INT 2
6592: PUSH
6593: FOR_TO
6594: IFFALSE 6732
// begin uc_side := 2 ;
6596: LD_ADDR_OWVAR 20
6600: PUSH
6601: LD_INT 2
6603: ST_TO_ADDR
// uc_nation := 2 ;
6604: LD_ADDR_OWVAR 21
6608: PUSH
6609: LD_INT 2
6611: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6612: LD_INT 13
6614: PPUSH
6615: LD_INT 3
6617: PPUSH
6618: LD_INT 5
6620: PPUSH
6621: LD_INT 29
6623: PPUSH
6624: LD_INT 100
6626: PPUSH
6627: CALL 52784 0 5
// un := CreateVehicle ;
6631: LD_ADDR_VAR 0 2
6635: PUSH
6636: CALL_OW 45
6640: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6641: LD_ADDR_VAR 0 3
6645: PUSH
6646: LD_VAR 0 3
6650: PPUSH
6651: LD_INT 5
6653: PUSH
6654: LD_VAR 0 3
6658: PUSH
6659: LD_INT 5
6661: ARRAY
6662: PUSH
6663: LD_INT 1
6665: PLUS
6666: PUSH
6667: EMPTY
6668: LIST
6669: LIST
6670: PPUSH
6671: LD_VAR 0 2
6675: PPUSH
6676: CALL 52906 0 3
6680: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6681: LD_VAR 0 2
6685: PPUSH
6686: LD_INT 0
6688: PPUSH
6689: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6693: LD_VAR 0 2
6697: PPUSH
6698: LD_INT 23
6700: PPUSH
6701: LD_INT 0
6703: PPUSH
6704: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6708: LD_VAR 0 2
6712: PPUSH
6713: LD_INT 85
6715: PPUSH
6716: LD_INT 152
6718: PPUSH
6719: CALL_OW 111
// wait ( 0 0$2 ) ;
6723: LD_INT 70
6725: PPUSH
6726: CALL_OW 67
// end ;
6730: GO 6593
6732: POP
6733: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6734: LD_ADDR_VAR 0 1
6738: PUSH
6739: DOUBLE
6740: LD_INT 1
6742: DEC
6743: ST_TO_ADDR
6744: LD_INT 2
6746: PUSH
6747: LD_INT 3
6749: PUSH
6750: LD_INT 3
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: PUSH
6758: LD_OWVAR 67
6762: ARRAY
6763: PUSH
6764: FOR_TO
6765: IFFALSE 6922
// begin uc_side := 2 ;
6767: LD_ADDR_OWVAR 20
6771: PUSH
6772: LD_INT 2
6774: ST_TO_ADDR
// uc_nation := 2 ;
6775: LD_ADDR_OWVAR 21
6779: PUSH
6780: LD_INT 2
6782: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6783: LD_INT 14
6785: PPUSH
6786: LD_INT 3
6788: PPUSH
6789: LD_INT 5
6791: PPUSH
6792: LD_INT 27
6794: PUSH
6795: LD_INT 28
6797: PUSH
6798: EMPTY
6799: LIST
6800: LIST
6801: PUSH
6802: LD_INT 1
6804: PPUSH
6805: LD_INT 2
6807: PPUSH
6808: CALL_OW 12
6812: ARRAY
6813: PPUSH
6814: LD_INT 100
6816: PPUSH
6817: CALL 52784 0 5
// un := CreateVehicle ;
6821: LD_ADDR_VAR 0 2
6825: PUSH
6826: CALL_OW 45
6830: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6831: LD_ADDR_VAR 0 3
6835: PUSH
6836: LD_VAR 0 3
6840: PPUSH
6841: LD_INT 5
6843: PUSH
6844: LD_VAR 0 3
6848: PUSH
6849: LD_INT 5
6851: ARRAY
6852: PUSH
6853: LD_INT 1
6855: PLUS
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: LD_VAR 0 2
6865: PPUSH
6866: CALL 52906 0 3
6870: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_INT 0
6878: PPUSH
6879: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6883: LD_VAR 0 2
6887: PPUSH
6888: LD_INT 23
6890: PPUSH
6891: LD_INT 0
6893: PPUSH
6894: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6898: LD_VAR 0 2
6902: PPUSH
6903: LD_INT 85
6905: PPUSH
6906: LD_INT 152
6908: PPUSH
6909: CALL_OW 111
// wait ( 0 0$2 ) ;
6913: LD_INT 70
6915: PPUSH
6916: CALL_OW 67
// end ;
6920: GO 6764
6922: POP
6923: POP
// coords := [ [ 97 , 143 ] ] ;
6924: LD_ADDR_VAR 0 5
6928: PUSH
6929: LD_INT 97
6931: PUSH
6932: LD_INT 143
6934: PUSH
6935: EMPTY
6936: LIST
6937: LIST
6938: PUSH
6939: EMPTY
6940: LIST
6941: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6942: LD_INT 1
6944: PPUSH
6945: LD_VAR 0 3
6949: PUSH
6950: LD_INT 5
6952: ARRAY
6953: PPUSH
6954: LD_VAR 0 5
6958: PPUSH
6959: LD_VAR 0 6
6963: PPUSH
6964: CALL 41782 0 4
// end ; Wait ( 13 13$00 ) ;
6968: LD_INT 27300
6970: PPUSH
6971: CALL_OW 67
// tmp := [ ] ;
6975: LD_ADDR_VAR 0 3
6979: PUSH
6980: EMPTY
6981: ST_TO_ADDR
// w := 1 ;
6982: LD_ADDR_VAR 0 7
6986: PUSH
6987: LD_INT 1
6989: ST_TO_ADDR
// repeat tmp := [ ] ;
6990: LD_ADDR_VAR 0 3
6994: PUSH
6995: EMPTY
6996: ST_TO_ADDR
// if w mod 4 = 0 then
6997: LD_VAR 0 7
7001: PUSH
7002: LD_INT 4
7004: MOD
7005: PUSH
7006: LD_INT 0
7008: EQUAL
7009: IFFALSE 7096
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7011: LD_ADDR_VAR 0 8
7015: PUSH
7016: LD_INT 11
7018: PUSH
7019: LD_INT 1
7021: PUSH
7022: LD_INT 2
7024: PUSH
7025: LD_INT 24
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: LIST
7032: LIST
7033: PUSH
7034: LD_INT 11
7036: PUSH
7037: LD_INT 1
7039: PUSH
7040: LD_INT 2
7042: PUSH
7043: LD_INT 24
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: LIST
7050: LIST
7051: PUSH
7052: LD_INT 11
7054: PUSH
7055: LD_INT 1
7057: PUSH
7058: LD_INT 2
7060: PUSH
7061: LD_INT 24
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: LIST
7068: LIST
7069: PUSH
7070: LD_INT 11
7072: PUSH
7073: LD_INT 1
7075: PUSH
7076: LD_INT 2
7078: PUSH
7079: LD_INT 24
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: LIST
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: ST_TO_ADDR
7094: GO 7198
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7096: LD_ADDR_VAR 0 8
7100: PUSH
7101: LD_INT 14
7103: PUSH
7104: LD_INT 1
7106: PUSH
7107: LD_INT 2
7109: PUSH
7110: LD_INT 28
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: LIST
7117: LIST
7118: PUSH
7119: LD_INT 14
7121: PUSH
7122: LD_INT 1
7124: PUSH
7125: LD_INT 2
7127: PUSH
7128: LD_INT 25
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: LIST
7135: LIST
7136: PUSH
7137: LD_INT 14
7139: PUSH
7140: LD_INT 1
7142: PUSH
7143: LD_INT 2
7145: PUSH
7146: LD_INT 28
7148: PUSH
7149: EMPTY
7150: LIST
7151: LIST
7152: LIST
7153: LIST
7154: PUSH
7155: LD_INT 14
7157: PUSH
7158: LD_INT 1
7160: PUSH
7161: LD_INT 2
7163: PUSH
7164: LD_INT 29
7166: PUSH
7167: EMPTY
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: PUSH
7173: LD_INT 11
7175: PUSH
7176: LD_INT 1
7178: PUSH
7179: LD_INT 2
7181: PUSH
7182: LD_INT 24
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: PUSH
7191: EMPTY
7192: LIST
7193: LIST
7194: LIST
7195: LIST
7196: LIST
7197: ST_TO_ADDR
// if w mod 3 = 0 then
7198: LD_VAR 0 7
7202: PUSH
7203: LD_INT 3
7205: MOD
7206: PUSH
7207: LD_INT 0
7209: EQUAL
7210: IFFALSE 7286
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7212: LD_ADDR_VAR 0 8
7216: PUSH
7217: LD_VAR 0 8
7221: PPUSH
7222: LD_INT 1
7224: PUSH
7225: LD_VAR 0 8
7229: PUSH
7230: LD_VAR 0 1
7234: ARRAY
7235: PUSH
7236: LD_INT 1
7238: PLUS
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PPUSH
7244: LD_INT 14
7246: PUSH
7247: LD_INT 1
7249: PUSH
7250: LD_INT 2
7252: PUSH
7253: LD_INT 25
7255: PUSH
7256: LD_INT 28
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: PUSH
7263: LD_INT 1
7265: PPUSH
7266: LD_INT 2
7268: PPUSH
7269: CALL_OW 12
7273: ARRAY
7274: PUSH
7275: EMPTY
7276: LIST
7277: LIST
7278: LIST
7279: LIST
7280: PPUSH
7281: CALL 52906 0 3
7285: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7286: LD_INT 1
7288: PPUSH
7289: LD_VAR 0 8
7293: PPUSH
7294: CALL 41549 0 2
// if GetSide ( ar_dep_w ) = 2 then
7298: LD_INT 45
7300: PPUSH
7301: CALL_OW 255
7305: PUSH
7306: LD_INT 2
7308: EQUAL
7309: IFFALSE 7394
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7311: LD_ADDR_VAR 0 8
7315: PUSH
7316: LD_INT 14
7318: PUSH
7319: LD_INT 1
7321: PUSH
7322: LD_INT 2
7324: PUSH
7325: LD_INT 28
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: LIST
7333: PUSH
7334: LD_INT 14
7336: PUSH
7337: LD_INT 1
7339: PUSH
7340: LD_INT 2
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: EMPTY
7347: LIST
7348: LIST
7349: LIST
7350: LIST
7351: PUSH
7352: LD_INT 14
7354: PUSH
7355: LD_INT 1
7357: PUSH
7358: LD_INT 2
7360: PUSH
7361: LD_INT 27
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: LIST
7374: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7375: LD_INT 2
7377: PPUSH
7378: LD_VAR 0 8
7382: PPUSH
7383: CALL 41549 0 2
// wait ( 0 0$50 ) ;
7387: LD_INT 1750
7389: PPUSH
7390: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7394: LD_INT 35
7396: PPUSH
7397: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7401: LD_EXP 69
7405: PUSH
7406: LD_INT 1
7408: ARRAY
7409: PPUSH
7410: LD_INT 3
7412: PUSH
7413: LD_INT 2
7415: PUSH
7416: LD_INT 34
7418: PUSH
7419: LD_INT 32
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: PUSH
7426: LD_INT 34
7428: PUSH
7429: LD_EXP 99
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: PUSH
7438: EMPTY
7439: LIST
7440: LIST
7441: LIST
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PPUSH
7447: CALL_OW 72
7451: PUSH
7452: LD_INT 4
7454: GREATEREQUAL
7455: IFFALSE 7394
// wait ( 0 0$10 ) ;
7457: LD_INT 350
7459: PPUSH
7460: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7464: LD_ADDR_VAR 0 3
7468: PUSH
7469: LD_EXP 69
7473: PUSH
7474: LD_INT 1
7476: ARRAY
7477: PPUSH
7478: LD_INT 3
7480: PUSH
7481: LD_INT 2
7483: PUSH
7484: LD_INT 34
7486: PUSH
7487: LD_INT 32
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 34
7496: PUSH
7497: LD_EXP 99
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: LIST
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: PPUSH
7515: CALL_OW 72
7519: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7520: LD_INT 100
7522: PPUSH
7523: CALL_OW 13
7527: PUSH
7528: LD_INT 50
7530: LESS
7531: IFFALSE 7564
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7533: LD_ADDR_VAR 0 5
7537: PUSH
7538: LD_INT 55
7540: PUSH
7541: LD_INT 7
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PUSH
7548: LD_INT 75
7550: PUSH
7551: LD_INT 90
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PUSH
7558: EMPTY
7559: LIST
7560: LIST
7561: ST_TO_ADDR
7562: GO 7593
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7564: LD_ADDR_VAR 0 5
7568: PUSH
7569: LD_INT 128
7571: PUSH
7572: LD_INT 94
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PUSH
7579: LD_INT 180
7581: PUSH
7582: LD_INT 135
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: PUSH
7589: EMPTY
7590: LIST
7591: LIST
7592: ST_TO_ADDR
// if w mod 4 = 0 then
7593: LD_VAR 0 7
7597: PUSH
7598: LD_INT 4
7600: MOD
7601: PUSH
7602: LD_INT 0
7604: EQUAL
7605: IFFALSE 7636
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7607: LD_ADDR_VAR 0 5
7611: PUSH
7612: LD_INT 91
7614: PUSH
7615: LD_INT 58
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: LD_INT 117
7624: PUSH
7625: LD_INT 107
7627: PUSH
7628: EMPTY
7629: LIST
7630: LIST
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7636: LD_VAR 0 3
7640: PPUSH
7641: LD_VAR 0 5
7645: PUSH
7646: LD_INT 1
7648: ARRAY
7649: PPUSH
7650: LD_VAR 0 5
7654: PUSH
7655: LD_INT 2
7657: ARRAY
7658: PPUSH
7659: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7663: LD_INT 35
7665: PPUSH
7666: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7670: LD_VAR 0 3
7674: PPUSH
7675: LD_INT 60
7677: PUSH
7678: EMPTY
7679: LIST
7680: PPUSH
7681: CALL_OW 72
7685: PUSH
7686: LD_INT 0
7688: EQUAL
7689: IFFALSE 7663
// repeat wait ( 0 0$2 ) ;
7691: LD_INT 70
7693: PPUSH
7694: CALL_OW 67
// for i in tmp do
7698: LD_ADDR_VAR 0 1
7702: PUSH
7703: LD_VAR 0 3
7707: PUSH
7708: FOR_IN
7709: IFFALSE 7798
// if GetChassis ( i ) = ar_hovercraft then
7711: LD_VAR 0 1
7715: PPUSH
7716: CALL_OW 265
7720: PUSH
7721: LD_INT 11
7723: EQUAL
7724: IFFALSE 7762
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7726: LD_VAR 0 1
7730: PPUSH
7731: LD_INT 22
7733: PUSH
7734: LD_INT 1
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PPUSH
7741: CALL_OW 69
7745: PPUSH
7746: LD_VAR 0 1
7750: PPUSH
7751: CALL_OW 74
7755: PPUSH
7756: CALL 80427 0 2
7760: GO 7796
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7762: LD_VAR 0 1
7766: PPUSH
7767: LD_INT 22
7769: PUSH
7770: LD_INT 1
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PPUSH
7777: CALL_OW 69
7781: PPUSH
7782: LD_VAR 0 1
7786: PPUSH
7787: CALL_OW 74
7791: PPUSH
7792: CALL_OW 115
7796: GO 7708
7798: POP
7799: POP
// until not tmp ;
7800: LD_VAR 0 3
7804: NOT
7805: IFFALSE 7691
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7807: LD_INT 22050
7809: PPUSH
7810: LD_INT 28350
7812: PPUSH
7813: CALL_OW 12
7817: PPUSH
7818: CALL_OW 67
// w := w + 1 ;
7822: LD_ADDR_VAR 0 7
7826: PUSH
7827: LD_VAR 0 7
7831: PUSH
7832: LD_INT 1
7834: PLUS
7835: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7836: LD_INT 94
7838: PPUSH
7839: CALL_OW 301
7843: PUSH
7844: LD_EXP 50
7848: PUSH
7849: LD_INT 1
7851: ARRAY
7852: PPUSH
7853: LD_INT 30
7855: PUSH
7856: LD_INT 3
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PPUSH
7863: CALL_OW 72
7867: NOT
7868: OR
7869: IFFALSE 6990
// end ;
7871: PPOPN 8
7873: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7874: LD_INT 204
7876: IFFALSE 8342
7878: GO 7880
7880: DISABLE
7881: LD_INT 0
7883: PPUSH
7884: PPUSH
7885: PPUSH
7886: PPUSH
// begin enable ;
7887: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7888: LD_INT 35
7890: PPUSH
7891: LD_INT 1190
7893: PPUSH
7894: CALL_OW 12
7898: PPUSH
7899: CALL_OW 67
// tmp := [ ] ;
7903: LD_ADDR_VAR 0 2
7907: PUSH
7908: EMPTY
7909: ST_TO_ADDR
// uc_side := 8 ;
7910: LD_ADDR_OWVAR 20
7914: PUSH
7915: LD_INT 8
7917: ST_TO_ADDR
// uc_nation := 2 ;
7918: LD_ADDR_OWVAR 21
7922: PUSH
7923: LD_INT 2
7925: ST_TO_ADDR
// InitHc ;
7926: CALL_OW 19
// for i = 1 to 3 do
7930: LD_ADDR_VAR 0 1
7934: PUSH
7935: DOUBLE
7936: LD_INT 1
7938: DEC
7939: ST_TO_ADDR
7940: LD_INT 3
7942: PUSH
7943: FOR_TO
7944: IFFALSE 8071
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7946: LD_INT 13
7948: PUSH
7949: LD_INT 14
7951: PUSH
7952: EMPTY
7953: LIST
7954: LIST
7955: PUSH
7956: LD_INT 1
7958: PPUSH
7959: LD_INT 2
7961: PPUSH
7962: CALL_OW 12
7966: ARRAY
7967: PPUSH
7968: LD_INT 3
7970: PPUSH
7971: LD_INT 5
7973: PPUSH
7974: LD_INT 27
7976: PUSH
7977: LD_INT 28
7979: PUSH
7980: EMPTY
7981: LIST
7982: LIST
7983: PUSH
7984: LD_INT 1
7986: PPUSH
7987: LD_INT 2
7989: PPUSH
7990: CALL_OW 12
7994: ARRAY
7995: PPUSH
7996: LD_INT 100
7998: PPUSH
7999: CALL 52784 0 5
// un := CreateVehicle ;
8003: LD_ADDR_VAR 0 3
8007: PUSH
8008: CALL_OW 45
8012: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8013: LD_VAR 0 3
8017: PPUSH
8018: LD_INT 4
8020: PPUSH
8021: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8025: LD_VAR 0 3
8029: PPUSH
8030: LD_INT 15
8032: PPUSH
8033: LD_INT 0
8035: PPUSH
8036: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8040: LD_ADDR_VAR 0 2
8044: PUSH
8045: LD_VAR 0 2
8049: PPUSH
8050: LD_VAR 0 2
8054: PUSH
8055: LD_INT 1
8057: PLUS
8058: PPUSH
8059: LD_VAR 0 3
8063: PPUSH
8064: CALL_OW 1
8068: ST_TO_ADDR
// end ;
8069: GO 7943
8071: POP
8072: POP
// for i = 1 to 4 do
8073: LD_ADDR_VAR 0 1
8077: PUSH
8078: DOUBLE
8079: LD_INT 1
8081: DEC
8082: ST_TO_ADDR
8083: LD_INT 4
8085: PUSH
8086: FOR_TO
8087: IFFALSE 8158
// begin PrepareHuman ( false , 1 , 6 ) ;
8089: LD_INT 0
8091: PPUSH
8092: LD_INT 1
8094: PPUSH
8095: LD_INT 6
8097: PPUSH
8098: CALL_OW 380
// un := CreateHuman ;
8102: LD_ADDR_VAR 0 3
8106: PUSH
8107: CALL_OW 44
8111: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8112: LD_VAR 0 3
8116: PPUSH
8117: LD_INT 15
8119: PPUSH
8120: LD_INT 0
8122: PPUSH
8123: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8127: LD_ADDR_VAR 0 2
8131: PUSH
8132: LD_VAR 0 2
8136: PPUSH
8137: LD_VAR 0 2
8141: PUSH
8142: LD_INT 1
8144: PLUS
8145: PPUSH
8146: LD_VAR 0 3
8150: PPUSH
8151: CALL_OW 1
8155: ST_TO_ADDR
// end ;
8156: GO 8086
8158: POP
8159: POP
// wait ( 0 0$3 ) ;
8160: LD_INT 105
8162: PPUSH
8163: CALL_OW 67
// for i in tmp do
8167: LD_ADDR_VAR 0 1
8171: PUSH
8172: LD_VAR 0 2
8176: PUSH
8177: FOR_IN
8178: IFFALSE 8246
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8180: LD_VAR 0 1
8184: PPUSH
8185: CALL_OW 257
8189: PUSH
8190: LD_INT 1
8192: EQUAL
8193: PUSH
8194: LD_VAR 0 1
8198: PPUSH
8199: CALL_OW 247
8203: PUSH
8204: LD_INT 2
8206: EQUAL
8207: OR
8208: IFFALSE 8244
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8210: LD_VAR 0 1
8214: PPUSH
8215: LD_INT 81
8217: PUSH
8218: LD_INT 8
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PPUSH
8230: LD_VAR 0 1
8234: PPUSH
8235: CALL_OW 74
8239: PPUSH
8240: CALL_OW 115
8244: GO 8177
8246: POP
8247: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8248: LD_VAR 0 2
8252: PPUSH
8253: LD_INT 210
8255: PPUSH
8256: LD_INT 178
8258: PPUSH
8259: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8263: LD_ADDR_VAR 0 4
8267: PUSH
8268: LD_INT 10
8270: PPUSH
8271: LD_INT 22
8273: PUSH
8274: LD_INT 8
8276: PUSH
8277: EMPTY
8278: LIST
8279: LIST
8280: PPUSH
8281: CALL_OW 70
8285: ST_TO_ADDR
// if x then
8286: LD_VAR 0 4
8290: IFFALSE 8318
// for i in x do
8292: LD_ADDR_VAR 0 1
8296: PUSH
8297: LD_VAR 0 4
8301: PUSH
8302: FOR_IN
8303: IFFALSE 8316
// RemoveUnit ( i ) ;
8305: LD_VAR 0 1
8309: PPUSH
8310: CALL_OW 64
8314: GO 8302
8316: POP
8317: POP
// wait ( 0 0$1 ) ;
8318: LD_INT 35
8320: PPUSH
8321: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8325: LD_INT 22
8327: PUSH
8328: LD_INT 8
8330: PUSH
8331: EMPTY
8332: LIST
8333: LIST
8334: PPUSH
8335: CALL_OW 69
8339: NOT
8340: IFFALSE 8248
// end ;
8342: PPOPN 4
8344: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8345: LD_INT 22
8347: PUSH
8348: LD_INT 2
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: PUSH
8355: LD_INT 34
8357: PUSH
8358: LD_INT 31
8360: PUSH
8361: EMPTY
8362: LIST
8363: LIST
8364: PUSH
8365: LD_INT 3
8367: PUSH
8368: LD_INT 24
8370: PUSH
8371: LD_INT 1000
8373: PUSH
8374: EMPTY
8375: LIST
8376: LIST
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: LIST
8386: PPUSH
8387: CALL_OW 69
8391: IFFALSE 8494
8393: GO 8395
8395: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8396: LD_INT 45
8398: PPUSH
8399: CALL_OW 302
8403: PUSH
8404: LD_INT 45
8406: PPUSH
8407: CALL_OW 255
8411: AND
8412: IFFALSE 8455
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8414: LD_INT 22
8416: PUSH
8417: LD_INT 2
8419: PUSH
8420: EMPTY
8421: LIST
8422: LIST
8423: PUSH
8424: LD_INT 34
8426: PUSH
8427: LD_INT 31
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: EMPTY
8435: LIST
8436: LIST
8437: PPUSH
8438: CALL_OW 69
8442: PPUSH
8443: LD_INT 18
8445: PPUSH
8446: LD_INT 8
8448: PPUSH
8449: CALL_OW 111
8453: GO 8494
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8455: LD_INT 22
8457: PUSH
8458: LD_INT 2
8460: PUSH
8461: EMPTY
8462: LIST
8463: LIST
8464: PUSH
8465: LD_INT 34
8467: PUSH
8468: LD_INT 31
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: PPUSH
8479: CALL_OW 69
8483: PPUSH
8484: LD_INT 106
8486: PPUSH
8487: LD_INT 14
8489: PPUSH
8490: CALL_OW 111
// end ; end_of_file
8494: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8495: LD_INT 0
8497: PPUSH
8498: PPUSH
8499: PPUSH
8500: PPUSH
8501: PPUSH
8502: PPUSH
// InGameOn ;
8503: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8507: LD_EXP 21
8511: PPUSH
8512: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8516: LD_INT 2
8518: PPUSH
8519: LD_INT 1
8521: PPUSH
8522: LD_INT 1
8524: PPUSH
8525: LD_INT 1
8527: PPUSH
8528: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8532: LD_ADDR_VAR 0 2
8536: PUSH
8537: LD_INT 22
8539: PUSH
8540: LD_INT 1
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: PUSH
8547: LD_INT 25
8549: PUSH
8550: LD_INT 1
8552: PUSH
8553: EMPTY
8554: LIST
8555: LIST
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: PPUSH
8561: CALL_OW 69
8565: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8566: LD_ADDR_VAR 0 4
8570: PUSH
8571: LD_INT 22
8573: PUSH
8574: LD_INT 1
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: PUSH
8581: LD_INT 34
8583: PUSH
8584: LD_INT 11
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: PUSH
8591: EMPTY
8592: LIST
8593: LIST
8594: PPUSH
8595: CALL_OW 69
8599: PUSH
8600: LD_INT 1
8602: ARRAY
8603: ST_TO_ADDR
// for i = 1 to tmp do
8604: LD_ADDR_VAR 0 6
8608: PUSH
8609: DOUBLE
8610: LD_INT 1
8612: DEC
8613: ST_TO_ADDR
8614: LD_VAR 0 2
8618: PUSH
8619: FOR_TO
8620: IFFALSE 8667
// begin if i = 5 then
8622: LD_VAR 0 6
8626: PUSH
8627: LD_INT 5
8629: EQUAL
8630: IFFALSE 8634
// break ;
8632: GO 8667
// sols := Replace ( sols , i , tmp [ i ] ) ;
8634: LD_ADDR_VAR 0 5
8638: PUSH
8639: LD_VAR 0 5
8643: PPUSH
8644: LD_VAR 0 6
8648: PPUSH
8649: LD_VAR 0 2
8653: PUSH
8654: LD_VAR 0 6
8658: ARRAY
8659: PPUSH
8660: CALL_OW 1
8664: ST_TO_ADDR
// end ;
8665: GO 8619
8667: POP
8668: POP
// tmp := ar_force_tmp ;
8669: LD_ADDR_VAR 0 2
8673: PUSH
8674: LD_EXP 40
8678: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8679: LD_VAR 0 2
8683: PUSH
8684: LD_INT 1
8686: ARRAY
8687: PPUSH
8688: LD_INT 108
8690: PPUSH
8691: LD_INT 139
8693: PPUSH
8694: LD_INT 0
8696: PPUSH
8697: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8701: LD_VAR 0 2
8705: PUSH
8706: LD_INT 1
8708: ARRAY
8709: PPUSH
8710: LD_EXP 21
8714: PPUSH
8715: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8719: LD_VAR 0 2
8723: PUSH
8724: LD_INT 2
8726: ARRAY
8727: PPUSH
8728: LD_INT 114
8730: PPUSH
8731: LD_INT 132
8733: PPUSH
8734: LD_INT 0
8736: PPUSH
8737: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8741: LD_VAR 0 2
8745: PUSH
8746: LD_INT 3
8748: ARRAY
8749: PPUSH
8750: LD_INT 115
8752: PPUSH
8753: LD_INT 132
8755: PPUSH
8756: LD_INT 0
8758: PPUSH
8759: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8763: LD_VAR 0 2
8767: PUSH
8768: LD_INT 2
8770: ARRAY
8771: PUSH
8772: LD_VAR 0 2
8776: PUSH
8777: LD_INT 3
8779: ARRAY
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PPUSH
8785: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8789: LD_VAR 0 4
8793: PPUSH
8794: LD_INT 83
8796: PPUSH
8797: LD_INT 123
8799: PPUSH
8800: CALL_OW 111
// Wait ( 0 0$01 ) ;
8804: LD_INT 35
8806: PPUSH
8807: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8811: LD_INT 90
8813: PPUSH
8814: LD_INT 144
8816: PPUSH
8817: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8821: LD_VAR 0 5
8825: PPUSH
8826: LD_INT 88
8828: PPUSH
8829: LD_INT 129
8831: PPUSH
8832: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8836: LD_ADDR_VAR 0 3
8840: PUSH
8841: LD_INT 92
8843: PUSH
8844: LD_INT 131
8846: PUSH
8847: EMPTY
8848: LIST
8849: LIST
8850: PUSH
8851: LD_INT 88
8853: PUSH
8854: LD_INT 127
8856: PUSH
8857: EMPTY
8858: LIST
8859: LIST
8860: PUSH
8861: LD_INT 91
8863: PUSH
8864: LD_INT 132
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PUSH
8871: LD_INT 92
8873: PUSH
8874: LD_INT 134
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: LIST
8885: LIST
8886: ST_TO_ADDR
// for i = 1 to sols do
8887: LD_ADDR_VAR 0 6
8891: PUSH
8892: DOUBLE
8893: LD_INT 1
8895: DEC
8896: ST_TO_ADDR
8897: LD_VAR 0 5
8901: PUSH
8902: FOR_TO
8903: IFFALSE 8976
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8905: LD_VAR 0 5
8909: PUSH
8910: LD_VAR 0 6
8914: ARRAY
8915: PPUSH
8916: LD_VAR 0 3
8920: PUSH
8921: LD_VAR 0 6
8925: ARRAY
8926: PUSH
8927: LD_INT 1
8929: ARRAY
8930: PPUSH
8931: LD_VAR 0 3
8935: PUSH
8936: LD_VAR 0 6
8940: ARRAY
8941: PUSH
8942: LD_INT 2
8944: ARRAY
8945: PPUSH
8946: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8950: LD_VAR 0 5
8954: PUSH
8955: LD_VAR 0 6
8959: ARRAY
8960: PPUSH
8961: CALL_OW 197
// AddComHold ( sols ) ;
8965: LD_VAR 0 5
8969: PPUSH
8970: CALL_OW 200
// end ;
8974: GO 8902
8976: POP
8977: POP
// repeat wait ( 0 0$1 ) ;
8978: LD_INT 35
8980: PPUSH
8981: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8985: LD_VAR 0 5
8989: PUSH
8990: LD_INT 1
8992: ARRAY
8993: PPUSH
8994: LD_INT 92
8996: PPUSH
8997: LD_INT 131
8999: PPUSH
9000: CALL_OW 297
9004: PUSH
9005: LD_INT 4
9007: LESS
9008: IFFALSE 8978
// CenterOnXY ( 96 , 139 ) ;
9010: LD_INT 96
9012: PPUSH
9013: LD_INT 139
9015: PPUSH
9016: CALL_OW 84
// wait ( 0 0$3 ) ;
9020: LD_INT 105
9022: PPUSH
9023: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9027: LD_INT 111
9029: PPUSH
9030: LD_INT 135
9032: PPUSH
9033: LD_INT 1
9035: PPUSH
9036: LD_INT 25
9038: NEG
9039: PPUSH
9040: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9044: LD_VAR 0 2
9048: PUSH
9049: LD_INT 2
9051: ARRAY
9052: PPUSH
9053: LD_VAR 0 2
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PPUSH
9062: CALL_OW 250
9066: PUSH
9067: LD_INT 3
9069: PLUS
9070: PPUSH
9071: LD_VAR 0 2
9075: PUSH
9076: LD_INT 1
9078: ARRAY
9079: PPUSH
9080: CALL_OW 251
9084: PPUSH
9085: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9089: LD_VAR 0 2
9093: PUSH
9094: LD_INT 3
9096: ARRAY
9097: PPUSH
9098: LD_INT 7
9100: PPUSH
9101: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9105: LD_VAR 0 2
9109: PUSH
9110: LD_INT 2
9112: ARRAY
9113: PPUSH
9114: LD_VAR 0 2
9118: PUSH
9119: LD_INT 1
9121: ARRAY
9122: PPUSH
9123: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9127: LD_INT 35
9129: PPUSH
9130: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9134: LD_VAR 0 2
9138: PUSH
9139: LD_INT 1
9141: ARRAY
9142: PPUSH
9143: LD_VAR 0 2
9147: PUSH
9148: LD_INT 2
9150: ARRAY
9151: PPUSH
9152: CALL_OW 296
9156: PUSH
9157: LD_INT 5
9159: LESS
9160: IFFALSE 9127
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9162: LD_VAR 0 2
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 2
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PPUSH
9180: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9184: LD_VAR 0 2
9188: PUSH
9189: LD_INT 1
9191: ARRAY
9192: PPUSH
9193: LD_STRING D1a-Merc1-1
9195: PPUSH
9196: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9200: LD_VAR 0 2
9204: PUSH
9205: LD_INT 2
9207: ARRAY
9208: PPUSH
9209: LD_STRING D1a-FMerc2-1
9211: PPUSH
9212: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 2
9223: ARRAY
9224: PPUSH
9225: LD_VAR 0 2
9229: PUSH
9230: LD_INT 1
9232: ARRAY
9233: PPUSH
9234: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9238: LD_VAR 0 2
9242: PUSH
9243: LD_INT 1
9245: ARRAY
9246: PPUSH
9247: LD_INT 500
9249: PPUSH
9250: CALL_OW 234
// wait ( 0 0$2 ) ;
9254: LD_INT 70
9256: PPUSH
9257: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9261: LD_VAR 0 2
9265: PUSH
9266: LD_INT 1
9268: ARRAY
9269: PPUSH
9270: LD_INT 2
9272: PPUSH
9273: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9277: LD_INT 10
9279: PPUSH
9280: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9284: LD_VAR 0 2
9288: PUSH
9289: LD_INT 1
9291: ARRAY
9292: PPUSH
9293: LD_STRING D1a-Merc1-2
9295: PPUSH
9296: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9300: LD_INT 7
9302: PPUSH
9303: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9307: LD_VAR 0 2
9311: PUSH
9312: LD_INT 1
9314: ARRAY
9315: PPUSH
9316: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9320: LD_VAR 0 2
9324: PUSH
9325: LD_INT 2
9327: ARRAY
9328: PPUSH
9329: LD_INT 10
9331: PPUSH
9332: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9336: LD_VAR 0 2
9340: PUSH
9341: LD_INT 2
9343: ARRAY
9344: PPUSH
9345: LD_STRING D1a-FMerc2-2
9347: PPUSH
9348: CALL_OW 88
// wait ( 0 0$1 ) ;
9352: LD_INT 35
9354: PPUSH
9355: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9359: LD_INT 7
9361: PPUSH
9362: CALL_OW 85
// wait ( 0 0$2 ) ;
9366: LD_INT 70
9368: PPUSH
9369: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9373: LD_EXP 44
9377: PPUSH
9378: LD_STRING D1a-Saliba-1
9380: PPUSH
9381: CALL_OW 91
// KillUnit ( Saliba ) ;
9385: LD_EXP 44
9389: PPUSH
9390: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9394: LD_VAR 0 2
9398: PUSH
9399: LD_INT 3
9401: ARRAY
9402: PPUSH
9403: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9407: LD_EXP 21
9411: PPUSH
9412: CALL_OW 85
// wait ( 0 0$1 ) ;
9416: LD_INT 35
9418: PPUSH
9419: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9423: LD_VAR 0 5
9427: PPUSH
9428: LD_INT 88
9430: PPUSH
9431: LD_INT 141
9433: PPUSH
9434: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9438: LD_VAR 0 5
9442: PPUSH
9443: LD_INT 70
9445: PPUSH
9446: CALL_OW 202
// wait ( 0 0$2 ) ;
9450: LD_INT 70
9452: PPUSH
9453: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9457: LD_INT 2
9459: PPUSH
9460: LD_INT 1
9462: PPUSH
9463: LD_INT 2
9465: PPUSH
9466: LD_INT 1
9468: PPUSH
9469: CALL_OW 80
// InGameOff ;
9473: CALL_OW 9
// ComWalk ( sols ) ;
9477: LD_VAR 0 5
9481: PPUSH
9482: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9486: LD_STRING M1
9488: PPUSH
9489: CALL_OW 337
// game_speed := 4 ;
9493: LD_ADDR_OWVAR 65
9497: PUSH
9498: LD_INT 4
9500: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9501: LD_INT 111
9503: PPUSH
9504: LD_INT 135
9506: PPUSH
9507: LD_INT 1
9509: PPUSH
9510: CALL_OW 331
// SaveForQuickRestart ;
9514: CALL_OW 22
// ar_run := true ;
9518: LD_ADDR_EXP 5
9522: PUSH
9523: LD_INT 1
9525: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9526: LD_INT 35
9528: PPUSH
9529: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9533: LD_INT 22
9535: PUSH
9536: LD_INT 1
9538: PUSH
9539: EMPTY
9540: LIST
9541: LIST
9542: PUSH
9543: LD_INT 91
9545: PUSH
9546: LD_INT 7
9548: PUSH
9549: LD_INT 10
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PPUSH
9561: CALL_OW 69
9565: PUSH
9566: LD_INT 7
9568: PPUSH
9569: CALL_OW 256
9573: PUSH
9574: LD_INT 999
9576: LESS
9577: OR
9578: IFFALSE 9526
// if GetSide ( ar_dep_s ) = 2 then
9580: LD_INT 7
9582: PPUSH
9583: CALL_OW 255
9587: PUSH
9588: LD_INT 2
9590: EQUAL
9591: IFFALSE 9603
// SetSide ( ar_dep_s , 1 ) ;
9593: LD_INT 7
9595: PPUSH
9596: LD_INT 1
9598: PPUSH
9599: CALL_OW 235
// end ;
9603: LD_VAR 0 1
9607: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9608: LD_EXP 5
9612: IFFALSE 9972
9614: GO 9616
9616: DISABLE
9617: LD_INT 0
9619: PPUSH
9620: PPUSH
9621: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9622: LD_ADDR_VAR 0 2
9626: PUSH
9627: LD_EXP 40
9631: PUSH
9632: LD_EXP 36
9636: PPUSH
9637: LD_INT 2
9639: PUSH
9640: LD_INT 21
9642: PUSH
9643: LD_INT 2
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: PUSH
9650: LD_INT 21
9652: PUSH
9653: LD_INT 1
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: LIST
9664: PPUSH
9665: CALL_OW 72
9669: ADD
9670: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9671: LD_VAR 0 2
9675: PPUSH
9676: LD_INT 5
9678: PPUSH
9679: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9683: LD_INT 5
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: CALL_OW 343
// k := 1 ;
9693: LD_ADDR_VAR 0 3
9697: PUSH
9698: LD_INT 1
9700: ST_TO_ADDR
// for i in tmp do
9701: LD_ADDR_VAR 0 1
9705: PUSH
9706: LD_VAR 0 2
9710: PUSH
9711: FOR_IN
9712: IFFALSE 9797
// begin if IsInUnit ( i ) then
9714: LD_VAR 0 1
9718: PPUSH
9719: CALL_OW 310
9723: IFFALSE 9734
// ComExitBuilding ( i ) ;
9725: LD_VAR 0 1
9729: PPUSH
9730: CALL_OW 122
// if GetClass ( i ) = 3 then
9734: LD_VAR 0 1
9738: PPUSH
9739: CALL_OW 257
9743: PUSH
9744: LD_INT 3
9746: EQUAL
9747: IFFALSE 9783
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9749: LD_VAR 0 1
9753: PPUSH
9754: LD_EXP 41
9758: PUSH
9759: LD_VAR 0 3
9763: ARRAY
9764: PPUSH
9765: CALL_OW 180
// k := k + 1 ;
9769: LD_ADDR_VAR 0 3
9773: PUSH
9774: LD_VAR 0 3
9778: PUSH
9779: LD_INT 1
9781: PLUS
9782: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9783: LD_VAR 0 1
9787: PPUSH
9788: LD_INT 10
9790: PPUSH
9791: CALL_OW 173
// end ;
9795: GO 9711
9797: POP
9798: POP
// ar_patrol := true ;
9799: LD_ADDR_EXP 7
9803: PUSH
9804: LD_INT 1
9806: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9807: LD_INT 10
9809: PPUSH
9810: CALL_OW 67
// for i in tmp do
9814: LD_ADDR_VAR 0 1
9818: PUSH
9819: LD_VAR 0 2
9823: PUSH
9824: FOR_IN
9825: IFFALSE 9853
// if not HasTask ( i ) then
9827: LD_VAR 0 1
9831: PPUSH
9832: CALL_OW 314
9836: NOT
9837: IFFALSE 9851
// ComMoveToArea ( i , escape_area ) ;
9839: LD_VAR 0 1
9843: PPUSH
9844: LD_INT 10
9846: PPUSH
9847: CALL_OW 113
9851: GO 9824
9853: POP
9854: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9855: LD_ADDR_VAR 0 3
9859: PUSH
9860: LD_VAR 0 2
9864: PPUSH
9865: LD_INT 95
9867: PUSH
9868: LD_INT 10
9870: PUSH
9871: EMPTY
9872: LIST
9873: LIST
9874: PPUSH
9875: CALL_OW 72
9879: ST_TO_ADDR
// if k then
9880: LD_VAR 0 3
9884: IFFALSE 9953
// for i in k do
9886: LD_ADDR_VAR 0 1
9890: PUSH
9891: LD_VAR 0 3
9895: PUSH
9896: FOR_IN
9897: IFFALSE 9951
// begin if IsInUnit ( i ) then
9899: LD_VAR 0 1
9903: PPUSH
9904: CALL_OW 310
9908: IFFALSE 9924
// RemoveUnit ( IsInUnit ( i ) ) ;
9910: LD_VAR 0 1
9914: PPUSH
9915: CALL_OW 310
9919: PPUSH
9920: CALL_OW 64
// RemoveUnit ( i ) ;
9924: LD_VAR 0 1
9928: PPUSH
9929: CALL_OW 64
// tmp := tmp diff i ;
9933: LD_ADDR_VAR 0 2
9937: PUSH
9938: LD_VAR 0 2
9942: PUSH
9943: LD_VAR 0 1
9947: DIFF
9948: ST_TO_ADDR
// end ;
9949: GO 9896
9951: POP
9952: POP
// until tmp = [ ] ;
9953: LD_VAR 0 2
9957: PUSH
9958: EMPTY
9959: EQUAL
9960: IFFALSE 9807
// ChangeSideFog ( 5 , 5 ) ;
9962: LD_INT 5
9964: PPUSH
9965: LD_INT 5
9967: PPUSH
9968: CALL_OW 343
// end ;
9972: PPOPN 3
9974: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9975: LD_EXP 7
9979: IFFALSE 10269
9981: GO 9983
9983: DISABLE
9984: LD_INT 0
9986: PPUSH
9987: PPUSH
9988: PPUSH
// begin uc_side := 2 ;
9989: LD_ADDR_OWVAR 20
9993: PUSH
9994: LD_INT 2
9996: ST_TO_ADDR
// uc_nation := 2 ;
9997: LD_ADDR_OWVAR 21
10001: PUSH
10002: LD_INT 2
10004: ST_TO_ADDR
// InitHc ;
10005: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10009: LD_INT 1
10011: PPUSH
10012: LD_INT 1
10014: PPUSH
10015: LD_INT 6
10017: PPUSH
10018: CALL_OW 380
// un := CreateHuman ;
10022: LD_ADDR_VAR 0 2
10026: PUSH
10027: CALL_OW 44
10031: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10032: LD_INT 14
10034: PPUSH
10035: LD_INT 1
10037: PPUSH
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 27
10043: PPUSH
10044: LD_INT 98
10046: PPUSH
10047: CALL 52784 0 5
// veh := CreateVehicle ;
10051: LD_ADDR_VAR 0 3
10055: PUSH
10056: CALL_OW 45
10060: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10061: LD_VAR 0 3
10065: PPUSH
10066: LD_INT 4
10068: PPUSH
10069: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10073: LD_VAR 0 3
10077: PPUSH
10078: LD_INT 179
10080: PPUSH
10081: LD_INT 135
10083: PPUSH
10084: LD_INT 0
10086: PPUSH
10087: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10091: LD_VAR 0 2
10095: PPUSH
10096: LD_VAR 0 3
10100: PPUSH
10101: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10105: LD_VAR 0 2
10109: PPUSH
10110: LD_INT 126
10112: PPUSH
10113: LD_INT 133
10115: PPUSH
10116: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10120: LD_INT 10
10122: PPUSH
10123: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10127: LD_INT 1
10129: PPUSH
10130: LD_VAR 0 3
10134: PPUSH
10135: CALL_OW 292
10139: PUSH
10140: LD_VAR 0 3
10144: PPUSH
10145: LD_INT 7
10147: PPUSH
10148: CALL_OW 296
10152: PUSH
10153: LD_INT 9
10155: LESS
10156: OR
10157: IFFALSE 10120
// ComHold ( veh ) ;
10159: LD_VAR 0 3
10163: PPUSH
10164: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10168: LD_VAR 0 2
10172: PPUSH
10173: LD_STRING D2aa-Ar1-1
10175: PPUSH
10176: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10180: LD_VAR 0 2
10184: PPUSH
10185: LD_INT 177
10187: PPUSH
10188: LD_INT 96
10190: PPUSH
10191: CALL_OW 111
// AddComExitVehicle ( un ) ;
10195: LD_VAR 0 2
10199: PPUSH
10200: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10204: LD_INT 35
10206: PPUSH
10207: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10211: LD_VAR 0 2
10215: PPUSH
10216: LD_INT 204
10218: PPUSH
10219: CALL_OW 296
10223: PUSH
10224: LD_INT 15
10226: LESS
10227: IFFALSE 10204
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10229: LD_ADDR_EXP 50
10233: PUSH
10234: LD_EXP 50
10238: PPUSH
10239: LD_INT 3
10241: PUSH
10242: LD_EXP 50
10246: PUSH
10247: LD_INT 3
10249: ARRAY
10250: PUSH
10251: LD_INT 1
10253: PLUS
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: PPUSH
10259: LD_VAR 0 2
10263: PPUSH
10264: CALL 52906 0 3
10268: ST_TO_ADDR
// end ;
10269: PPOPN 3
10271: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10272: LD_INT 7
10274: PPUSH
10275: CALL_OW 255
10279: PUSH
10280: LD_INT 1
10282: EQUAL
10283: PUSH
10284: LD_INT 7
10286: PPUSH
10287: CALL_OW 301
10291: OR
10292: IFFALSE 12696
10294: GO 10296
10296: DISABLE
10297: LD_INT 0
10299: PPUSH
10300: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10301: LD_ADDR_VAR 0 1
10305: PUSH
10306: LD_EXP 36
10310: PPUSH
10311: LD_INT 21
10313: PUSH
10314: LD_INT 3
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PPUSH
10321: CALL_OW 72
10325: PUSH
10326: FOR_IN
10327: IFFALSE 10343
// SetSide ( i , 1 ) ;
10329: LD_VAR 0 1
10333: PPUSH
10334: LD_INT 1
10336: PPUSH
10337: CALL_OW 235
10341: GO 10326
10343: POP
10344: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10345: LD_ADDR_VAR 0 2
10349: PUSH
10350: LD_INT 46
10352: PUSH
10353: LD_INT 41
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PUSH
10360: LD_INT 50
10362: PUSH
10363: LD_INT 25
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: PUSH
10370: LD_INT 57
10372: PUSH
10373: LD_INT 75
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 75
10382: PUSH
10383: LD_INT 89
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 51
10392: PUSH
10393: LD_INT 45
10395: PUSH
10396: EMPTY
10397: LIST
10398: LIST
10399: PUSH
10400: LD_INT 95
10402: PUSH
10403: LD_INT 95
10405: PUSH
10406: EMPTY
10407: LIST
10408: LIST
10409: PUSH
10410: LD_INT 84
10412: PUSH
10413: LD_INT 77
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: PUSH
10420: LD_INT 101
10422: PUSH
10423: LD_INT 76
10425: PUSH
10426: EMPTY
10427: LIST
10428: LIST
10429: PUSH
10430: LD_INT 118
10432: PUSH
10433: LD_INT 81
10435: PUSH
10436: EMPTY
10437: LIST
10438: LIST
10439: PUSH
10440: LD_INT 139
10442: PUSH
10443: LD_INT 97
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: PUSH
10450: LD_INT 129
10452: PUSH
10453: LD_INT 114
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: PUSH
10460: LD_INT 154
10462: PUSH
10463: LD_INT 111
10465: PUSH
10466: EMPTY
10467: LIST
10468: LIST
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: ST_TO_ADDR
// base_captured := true ;
10484: LD_ADDR_EXP 6
10488: PUSH
10489: LD_INT 1
10491: ST_TO_ADDR
// DialogueOn ;
10492: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10496: LD_EXP 21
10500: PPUSH
10501: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10505: LD_EXP 21
10509: PPUSH
10510: LD_STRING D2-JMM-1
10512: PPUSH
10513: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10517: LD_EXP 30
10521: PPUSH
10522: LD_STRING D2-Pow-1
10524: PPUSH
10525: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10529: LD_EXP 21
10533: PPUSH
10534: LD_STRING D2-JMM-2
10536: PPUSH
10537: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10541: LD_EXP 30
10545: PPUSH
10546: LD_STRING D2-Pow-2
10548: PPUSH
10549: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10553: LD_EXP 21
10557: PPUSH
10558: LD_STRING D2-JMM-3
10560: PPUSH
10561: CALL_OW 88
// DialogueOff ;
10565: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10569: LD_STRING M2
10571: PPUSH
10572: CALL_OW 337
// Wait ( 0 0$2 ) ;
10576: LD_INT 70
10578: PPUSH
10579: CALL_OW 67
// if IsOk ( Gary ) then
10583: LD_EXP 32
10587: PPUSH
10588: CALL_OW 302
10592: IFFALSE 10606
// Say ( Gary , D2a-Gary-1 ) ;
10594: LD_EXP 32
10598: PPUSH
10599: LD_STRING D2a-Gary-1
10601: PPUSH
10602: CALL_OW 88
// if IsOk ( Bobby ) then
10606: LD_EXP 24
10610: PPUSH
10611: CALL_OW 302
10615: IFFALSE 10629
// Say ( Bobby , D2a-Bobby-1 ) ;
10617: LD_EXP 24
10621: PPUSH
10622: LD_STRING D2a-Bobby-1
10624: PPUSH
10625: CALL_OW 88
// if IsOk ( Cyrus ) then
10629: LD_EXP 25
10633: PPUSH
10634: CALL_OW 302
10638: IFFALSE 10652
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10640: LD_EXP 25
10644: PPUSH
10645: LD_STRING D2a-Cyrus-1
10647: PPUSH
10648: CALL_OW 88
// if IsOk ( Lisa ) then
10652: LD_EXP 22
10656: PPUSH
10657: CALL_OW 302
10661: IFFALSE 10675
// Say ( Lisa , D2a-Lisa-1 ) ;
10663: LD_EXP 22
10667: PPUSH
10668: LD_STRING D2a-Lisa-1
10670: PPUSH
10671: CALL_OW 88
// if IsOk ( Frank ) then
10675: LD_EXP 33
10679: PPUSH
10680: CALL_OW 302
10684: IFFALSE 10698
// Say ( Frank , D2a-Frank-1 ) ;
10686: LD_EXP 33
10690: PPUSH
10691: LD_STRING D2a-Frank-1
10693: PPUSH
10694: CALL_OW 88
// if IsOk ( Cornel ) then
10698: LD_EXP 31
10702: PPUSH
10703: CALL_OW 302
10707: IFFALSE 10721
// Say ( Cornel , D2a-Corn-1 ) ;
10709: LD_EXP 31
10713: PPUSH
10714: LD_STRING D2a-Corn-1
10716: PPUSH
10717: CALL_OW 88
// if IsOk ( Donaldson ) then
10721: LD_EXP 23
10725: PPUSH
10726: CALL_OW 302
10730: IFFALSE 10744
// Say ( Donaldson , D2a-Don-1 ) ;
10732: LD_EXP 23
10736: PPUSH
10737: LD_STRING D2a-Don-1
10739: PPUSH
10740: CALL_OW 88
// if IsOk ( Brown ) then
10744: LD_EXP 27
10748: PPUSH
10749: CALL_OW 302
10753: IFFALSE 10767
// Say ( Brown , D2a-Brown-1 ) ;
10755: LD_EXP 27
10759: PPUSH
10760: LD_STRING D2a-Brown-1
10762: PPUSH
10763: CALL_OW 88
// Wait ( 0 0$30 ) ;
10767: LD_INT 1050
10769: PPUSH
10770: CALL_OW 67
// if IsOk ( Frank ) then
10774: LD_EXP 33
10778: PPUSH
10779: CALL_OW 302
10783: IFFALSE 11049
// begin DialogueOn ;
10785: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10789: LD_EXP 21
10793: PUSH
10794: LD_EXP 33
10798: PUSH
10799: EMPTY
10800: LIST
10801: LIST
10802: PPUSH
10803: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10807: LD_EXP 33
10811: PPUSH
10812: LD_STRING D3F-Frank-1
10814: PPUSH
10815: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10819: LD_EXP 21
10823: PPUSH
10824: LD_STRING D3F-JMM-1
10826: PPUSH
10827: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10831: LD_EXP 33
10835: PPUSH
10836: LD_STRING D3F-Frank-2
10838: PPUSH
10839: CALL_OW 88
// case Query ( QFrank ) of 1 :
10843: LD_STRING QFrank
10845: PPUSH
10846: CALL_OW 97
10850: PUSH
10851: LD_INT 1
10853: DOUBLE
10854: EQUAL
10855: IFTRUE 10859
10857: GO 10882
10859: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10860: LD_EXP 21
10864: PPUSH
10865: LD_STRING D3Fa-JMM-1
10867: PPUSH
10868: CALL_OW 88
// us_scout := 1 ;
10872: LD_ADDR_EXP 8
10876: PUSH
10877: LD_INT 1
10879: ST_TO_ADDR
// end ; 2 :
10880: GO 11045
10882: LD_INT 2
10884: DOUBLE
10885: EQUAL
10886: IFTRUE 10890
10888: GO 11012
10890: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10891: LD_EXP 21
10895: PPUSH
10896: LD_STRING D3Fb-JMM-1
10898: PPUSH
10899: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10903: LD_EXP 33
10907: PPUSH
10908: LD_STRING D3Fb-Frank-1
10910: PPUSH
10911: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10915: LD_STRING QFrank2
10917: PPUSH
10918: CALL_OW 97
10922: PUSH
10923: LD_INT 1
10925: DOUBLE
10926: EQUAL
10927: IFTRUE 10931
10929: GO 10978
10931: POP
// begin us_scout := 2 ;
10932: LD_ADDR_EXP 8
10936: PUSH
10937: LD_INT 2
10939: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10940: LD_EXP 21
10944: PPUSH
10945: LD_STRING D3Fba-JMM-1
10947: PPUSH
10948: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10952: LD_EXP 33
10956: PPUSH
10957: LD_STRING D3Fba-Frank-1
10959: PPUSH
10960: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10964: LD_EXP 21
10968: PPUSH
10969: LD_STRING D3Fba-JMM-2
10971: PPUSH
10972: CALL_OW 88
// end ; 2 :
10976: GO 11010
10978: LD_INT 2
10980: DOUBLE
10981: EQUAL
10982: IFTRUE 10986
10984: GO 11009
10986: POP
// begin us_scout := 0 ;
10987: LD_ADDR_EXP 8
10991: PUSH
10992: LD_INT 0
10994: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10995: LD_EXP 21
10999: PPUSH
11000: LD_STRING D3Fbb-JMM-1
11002: PPUSH
11003: CALL_OW 88
// end ; end ;
11007: GO 11010
11009: POP
// end ; 3 :
11010: GO 11045
11012: LD_INT 3
11014: DOUBLE
11015: EQUAL
11016: IFTRUE 11020
11018: GO 11044
11020: POP
// begin us_scout := - 1 ;
11021: LD_ADDR_EXP 8
11025: PUSH
11026: LD_INT 1
11028: NEG
11029: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11030: LD_EXP 21
11034: PPUSH
11035: LD_STRING D3Fc-JMM-1
11037: PPUSH
11038: CALL_OW 88
// end ; end ;
11042: GO 11045
11044: POP
// DialogueOff ;
11045: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
11049: LD_EXP 8
11053: PUSH
11054: LD_INT 1
11056: NEG
11057: PUSH
11058: LD_INT 0
11060: PUSH
11061: EMPTY
11062: LIST
11063: LIST
11064: IN
11065: IFFALSE 11069
// exit ;
11067: GO 12696
// if us_scout in [ 1 , 2 ] then
11069: LD_EXP 8
11073: PUSH
11074: LD_INT 1
11076: PUSH
11077: LD_INT 2
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: IN
11084: IFFALSE 11763
// begin if IsInUnit ( Frank ) then
11086: LD_EXP 33
11090: PPUSH
11091: CALL_OW 310
11095: IFFALSE 11106
// ComExit ( Frank ) ;
11097: LD_EXP 33
11101: PPUSH
11102: CALL 84670 0 1
// SetSide ( Frank , 4 ) ;
11106: LD_EXP 33
11110: PPUSH
11111: LD_INT 4
11113: PPUSH
11114: CALL_OW 235
// wait ( 0 0$1 ) ;
11118: LD_INT 35
11120: PPUSH
11121: CALL_OW 67
// if us_scout = 2 then
11125: LD_EXP 8
11129: PUSH
11130: LD_INT 2
11132: EQUAL
11133: IFFALSE 11501
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11135: LD_EXP 33
11139: PPUSH
11140: LD_INT 75
11142: PPUSH
11143: LD_INT 63
11145: PPUSH
11146: CALL_OW 111
// AddComHold ( Frank ) ;
11150: LD_EXP 33
11154: PPUSH
11155: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11159: LD_EXP 33
11163: PPUSH
11164: LD_INT 770
11166: PPUSH
11167: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11171: LD_EXP 33
11175: PPUSH
11176: LD_INT 100
11178: PPUSH
11179: LD_INT 75
11181: PPUSH
11182: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11186: LD_EXP 33
11190: PPUSH
11191: LD_INT 123
11193: PPUSH
11194: LD_INT 103
11196: PPUSH
11197: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11201: LD_EXP 33
11205: PPUSH
11206: LD_INT 138
11208: PPUSH
11209: LD_INT 108
11211: PPUSH
11212: CALL_OW 171
// AddComHold ( Frank ) ;
11216: LD_EXP 33
11220: PPUSH
11221: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11225: LD_INT 35
11227: PPUSH
11228: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11232: LD_EXP 33
11236: PPUSH
11237: LD_INT 138
11239: PPUSH
11240: LD_INT 108
11242: PPUSH
11243: CALL_OW 307
11247: IFFALSE 11225
// AddComMoveXY ( Frank , 125 , 132 ) ;
11249: LD_EXP 33
11253: PPUSH
11254: LD_INT 125
11256: PPUSH
11257: LD_INT 132
11259: PPUSH
11260: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11264: LD_INT 35
11266: PPUSH
11267: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11271: LD_INT 1
11273: PPUSH
11274: LD_EXP 33
11278: PPUSH
11279: CALL_OW 292
11283: PUSH
11284: LD_EXP 33
11288: PPUSH
11289: LD_INT 7
11291: PPUSH
11292: CALL_OW 296
11296: PUSH
11297: LD_INT 7
11299: LESS
11300: OR
11301: IFFALSE 11264
// DialogueOn ;
11303: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11307: LD_EXP 33
11311: PPUSH
11312: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11316: LD_INT 10
11318: PPUSH
11319: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11323: LD_EXP 21
11327: PPUSH
11328: LD_STRING D4Fa-JMM-1
11330: PPUSH
11331: CALL_OW 88
// for i in points do
11335: LD_ADDR_VAR 0 1
11339: PUSH
11340: LD_VAR 0 2
11344: PUSH
11345: FOR_IN
11346: IFFALSE 11404
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11348: LD_VAR 0 1
11352: PUSH
11353: LD_INT 1
11355: ARRAY
11356: PPUSH
11357: LD_VAR 0 1
11361: PUSH
11362: LD_INT 2
11364: ARRAY
11365: PPUSH
11366: LD_INT 1
11368: PPUSH
11369: LD_INT 20
11371: NEG
11372: PPUSH
11373: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11377: LD_VAR 0 1
11381: PUSH
11382: LD_INT 1
11384: ARRAY
11385: PPUSH
11386: LD_VAR 0 1
11390: PUSH
11391: LD_INT 2
11393: ARRAY
11394: PPUSH
11395: LD_INT 1
11397: PPUSH
11398: CALL_OW 331
// end ;
11402: GO 11345
11404: POP
11405: POP
// dwait ( 0 0$0.5 ) ;
11406: LD_INT 18
11408: PPUSH
11409: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11413: LD_INT 42
11415: PPUSH
11416: LD_INT 27
11418: PPUSH
11419: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11423: LD_EXP 33
11427: PPUSH
11428: LD_STRING D4Fa-Frank-1
11430: PPUSH
11431: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11435: LD_INT 18
11437: PPUSH
11438: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11442: LD_EXP 21
11446: PPUSH
11447: LD_STRING D4Fa-JMM-2
11449: PPUSH
11450: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11454: LD_INT 118
11456: PPUSH
11457: LD_INT 80
11459: PPUSH
11460: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11464: LD_EXP 33
11468: PPUSH
11469: LD_STRING D4Fa-Frank-2
11471: PPUSH
11472: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11476: LD_INT 10
11478: PPUSH
11479: CALL_OW 68
// DialogueOff ;
11483: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11487: LD_EXP 33
11491: PPUSH
11492: LD_INT 1
11494: PPUSH
11495: CALL_OW 235
// end else
11499: GO 11763
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11501: LD_INT 2
11503: PPUSH
11504: LD_INT 4
11506: PPUSH
11507: LD_INT 2
11509: PPUSH
11510: LD_INT 1
11512: PPUSH
11513: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11517: LD_EXP 33
11521: PPUSH
11522: LD_INT 75
11524: PPUSH
11525: LD_INT 63
11527: PPUSH
11528: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11532: LD_EXP 33
11536: PPUSH
11537: LD_INT 175
11539: PPUSH
11540: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11544: LD_EXP 33
11548: PPUSH
11549: LD_INT 102
11551: PPUSH
11552: LD_INT 76
11554: PPUSH
11555: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11559: LD_EXP 33
11563: PPUSH
11564: LD_INT 108
11566: PPUSH
11567: LD_INT 70
11569: PPUSH
11570: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11574: LD_INT 35
11576: PPUSH
11577: CALL_OW 67
// until See ( 2 , Frank ) ;
11581: LD_INT 2
11583: PPUSH
11584: LD_EXP 33
11588: PPUSH
11589: CALL_OW 292
11593: IFFALSE 11574
// ComMoveXY ( Frank , 112 , 118 ) ;
11595: LD_EXP 33
11599: PPUSH
11600: LD_INT 112
11602: PPUSH
11603: LD_INT 118
11605: PPUSH
11606: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11610: LD_EXP 33
11614: PPUSH
11615: CALL_OW 256
11619: PUSH
11620: LD_INT 750
11622: GREATEREQUAL
11623: IFFALSE 11637
// SetLives ( Frank , 700 ) ;
11625: LD_EXP 33
11629: PPUSH
11630: LD_INT 700
11632: PPUSH
11633: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11637: LD_INT 35
11639: PPUSH
11640: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11644: LD_INT 1
11646: PPUSH
11647: LD_EXP 33
11651: PPUSH
11652: CALL_OW 292
11656: PUSH
11657: LD_EXP 33
11661: PPUSH
11662: LD_INT 7
11664: PPUSH
11665: CALL_OW 296
11669: PUSH
11670: LD_INT 17
11672: LESS
11673: OR
11674: IFFALSE 11637
// DialogueOn ;
11676: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11680: LD_EXP 33
11684: PPUSH
11685: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11689: LD_EXP 33
11693: PPUSH
11694: LD_STRING D4Fb-Frank-1
11696: PPUSH
11697: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11701: LD_EXP 21
11705: PPUSH
11706: LD_STRING D4Fb-JMM-1
11708: PPUSH
11709: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11713: LD_INT 2
11715: PPUSH
11716: LD_STRING D4Fb-FSci1-1
11718: PPUSH
11719: CALL 16611 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11723: LD_EXP 33
11727: PPUSH
11728: LD_STRING D4Fb-Frank-2
11730: PPUSH
11731: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11735: LD_EXP 21
11739: PPUSH
11740: LD_STRING D4Fb-JMM-2
11742: PPUSH
11743: CALL_OW 88
// DialogueOff ;
11747: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11751: LD_EXP 33
11755: PPUSH
11756: LD_INT 1
11758: PPUSH
11759: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11763: LD_EXP 34
11767: PPUSH
11768: CALL_OW 302
11772: PUSH
11773: LD_EXP 33
11777: NOT
11778: AND
11779: IFFALSE 11927
// begin DialogueOn ;
11781: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11785: LD_EXP 21
11789: PUSH
11790: LD_EXP 34
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: PPUSH
11799: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11803: LD_EXP 34
11807: PPUSH
11808: LD_STRING D3Y-Yam-1
11810: PPUSH
11811: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11815: LD_EXP 21
11819: PPUSH
11820: LD_STRING D3Y-JMM-1
11822: PPUSH
11823: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11827: LD_EXP 34
11831: PPUSH
11832: LD_STRING D3Y-Yam-2
11834: PPUSH
11835: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11839: LD_STRING QYamoko
11841: PPUSH
11842: CALL_OW 97
11846: PUSH
11847: LD_INT 1
11849: DOUBLE
11850: EQUAL
11851: IFTRUE 11855
11853: GO 11890
11855: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11856: LD_EXP 21
11860: PPUSH
11861: LD_STRING D3Ya-JMM-1
11863: PPUSH
11864: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11868: LD_EXP 34
11872: PPUSH
11873: LD_STRING D3Ya-Yam-1
11875: PPUSH
11876: CALL_OW 88
// us_scout := 1 ;
11880: LD_ADDR_EXP 8
11884: PUSH
11885: LD_INT 1
11887: ST_TO_ADDR
// end ; 2 :
11888: GO 11923
11890: LD_INT 2
11892: DOUBLE
11893: EQUAL
11894: IFTRUE 11898
11896: GO 11922
11898: POP
// begin us_scout := - 1 ;
11899: LD_ADDR_EXP 8
11903: PUSH
11904: LD_INT 1
11906: NEG
11907: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11908: LD_EXP 21
11912: PPUSH
11913: LD_STRING D3Yb-JMM-1
11915: PPUSH
11916: CALL_OW 88
// end ; end ;
11920: GO 11923
11922: POP
// DialogueOff ;
11923: CALL_OW 7
// end ; if Frank then
11927: LD_EXP 33
11931: IFFALSE 11935
// exit ;
11933: GO 12696
// if us_scout in [ - 1 , 0 ] then
11935: LD_EXP 8
11939: PUSH
11940: LD_INT 1
11942: NEG
11943: PUSH
11944: LD_INT 0
11946: PUSH
11947: EMPTY
11948: LIST
11949: LIST
11950: IN
11951: IFFALSE 11955
// exit ;
11953: GO 12696
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11955: LD_ADDR_EXP 8
11959: PUSH
11960: LD_INT 2
11962: PUSH
11963: LD_INT 2
11965: PUSH
11966: LD_INT 1
11968: PUSH
11969: EMPTY
11970: LIST
11971: LIST
11972: LIST
11973: PUSH
11974: LD_OWVAR 67
11978: ARRAY
11979: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11980: LD_EXP 8
11984: PUSH
11985: LD_INT 1
11987: PUSH
11988: LD_INT 2
11990: PUSH
11991: EMPTY
11992: LIST
11993: LIST
11994: IN
11995: IFFALSE 12696
// begin if IsInUnit ( Kikuchi ) then
11997: LD_EXP 34
12001: PPUSH
12002: CALL_OW 310
12006: IFFALSE 12017
// ComExitBuilding ( Kikuchi ) ;
12008: LD_EXP 34
12012: PPUSH
12013: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12017: LD_EXP 34
12021: PPUSH
12022: CALL_OW 311
12026: IFFALSE 12037
// ComExitVehicle ( Kikuchi ) ;
12028: LD_EXP 34
12032: PPUSH
12033: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12037: LD_EXP 34
12041: PPUSH
12042: LD_INT 4
12044: PPUSH
12045: CALL_OW 235
// wait ( 0 0$1 ) ;
12049: LD_INT 35
12051: PPUSH
12052: CALL_OW 67
// if us_scout = 2 then
12056: LD_EXP 8
12060: PUSH
12061: LD_INT 2
12063: EQUAL
12064: IFFALSE 12444
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12066: LD_EXP 34
12070: PPUSH
12071: LD_INT 75
12073: PPUSH
12074: LD_INT 63
12076: PPUSH
12077: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12081: LD_EXP 34
12085: PPUSH
12086: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12090: LD_EXP 34
12094: PPUSH
12095: LD_INT 770
12097: PPUSH
12098: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12102: LD_EXP 34
12106: PPUSH
12107: LD_INT 100
12109: PPUSH
12110: LD_INT 75
12112: PPUSH
12113: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12117: LD_EXP 34
12121: PPUSH
12122: LD_INT 123
12124: PPUSH
12125: LD_INT 103
12127: PPUSH
12128: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12132: LD_EXP 34
12136: PPUSH
12137: LD_INT 138
12139: PPUSH
12140: LD_INT 108
12142: PPUSH
12143: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12147: LD_EXP 34
12151: PPUSH
12152: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12156: LD_INT 35
12158: PPUSH
12159: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12163: LD_EXP 34
12167: PPUSH
12168: LD_INT 138
12170: PPUSH
12171: LD_INT 108
12173: PPUSH
12174: CALL_OW 307
12178: IFFALSE 12156
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12180: LD_EXP 34
12184: PPUSH
12185: LD_INT 125
12187: PPUSH
12188: LD_INT 132
12190: PPUSH
12191: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12195: LD_INT 35
12197: PPUSH
12198: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12202: LD_INT 1
12204: PPUSH
12205: LD_EXP 34
12209: PPUSH
12210: CALL_OW 292
12214: PUSH
12215: LD_EXP 34
12219: PPUSH
12220: LD_INT 7
12222: PPUSH
12223: CALL_OW 296
12227: PUSH
12228: LD_INT 7
12230: LESS
12231: OR
12232: IFFALSE 12195
// DialogueOn ;
12234: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12238: LD_EXP 34
12242: PPUSH
12243: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12247: LD_INT 10
12249: PPUSH
12250: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12254: LD_EXP 34
12258: PPUSH
12259: LD_STRING D4Ya-Yam-1
12261: PPUSH
12262: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12266: LD_EXP 21
12270: PPUSH
12271: LD_STRING D4Ya-JMM-1
12273: PPUSH
12274: CALL_OW 88
// for i in points do
12278: LD_ADDR_VAR 0 1
12282: PUSH
12283: LD_VAR 0 2
12287: PUSH
12288: FOR_IN
12289: IFFALSE 12347
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12291: LD_VAR 0 1
12295: PUSH
12296: LD_INT 1
12298: ARRAY
12299: PPUSH
12300: LD_VAR 0 1
12304: PUSH
12305: LD_INT 2
12307: ARRAY
12308: PPUSH
12309: LD_INT 1
12311: PPUSH
12312: LD_INT 20
12314: NEG
12315: PPUSH
12316: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12320: LD_VAR 0 1
12324: PUSH
12325: LD_INT 1
12327: ARRAY
12328: PPUSH
12329: LD_VAR 0 1
12333: PUSH
12334: LD_INT 2
12336: ARRAY
12337: PPUSH
12338: LD_INT 1
12340: PPUSH
12341: CALL_OW 331
// end ;
12345: GO 12288
12347: POP
12348: POP
// dwait ( 0 0$0.5 ) ;
12349: LD_INT 18
12351: PPUSH
12352: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12356: LD_INT 42
12358: PPUSH
12359: LD_INT 27
12361: PPUSH
12362: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12366: LD_EXP 34
12370: PPUSH
12371: LD_STRING D4Ya-Yam-2
12373: PPUSH
12374: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12378: LD_INT 18
12380: PPUSH
12381: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12385: LD_INT 118
12387: PPUSH
12388: LD_INT 80
12390: PPUSH
12391: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12395: LD_EXP 21
12399: PPUSH
12400: LD_STRING D4Ya-JMM-2
12402: PPUSH
12403: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12407: LD_EXP 34
12411: PPUSH
12412: LD_STRING D4Ya-Yam-3
12414: PPUSH
12415: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12419: LD_INT 10
12421: PPUSH
12422: CALL_OW 68
// DialogueOff ;
12426: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12430: LD_EXP 34
12434: PPUSH
12435: LD_INT 1
12437: PPUSH
12438: CALL_OW 235
// end else
12442: GO 12696
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12444: LD_INT 2
12446: PPUSH
12447: LD_INT 4
12449: PPUSH
12450: LD_INT 2
12452: PPUSH
12453: LD_INT 1
12455: PPUSH
12456: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12460: LD_EXP 34
12464: PPUSH
12465: LD_INT 75
12467: PPUSH
12468: LD_INT 63
12470: PPUSH
12471: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12475: LD_EXP 34
12479: PPUSH
12480: LD_INT 175
12482: PPUSH
12483: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12487: LD_EXP 34
12491: PPUSH
12492: LD_INT 102
12494: PPUSH
12495: LD_INT 76
12497: PPUSH
12498: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12502: LD_EXP 34
12506: PPUSH
12507: LD_INT 108
12509: PPUSH
12510: LD_INT 70
12512: PPUSH
12513: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12517: LD_INT 35
12519: PPUSH
12520: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12524: LD_INT 2
12526: PPUSH
12527: LD_EXP 34
12531: PPUSH
12532: CALL_OW 292
12536: IFFALSE 12517
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12538: LD_EXP 34
12542: PPUSH
12543: LD_INT 112
12545: PPUSH
12546: LD_INT 118
12548: PPUSH
12549: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12553: LD_EXP 34
12557: PPUSH
12558: CALL_OW 256
12562: PUSH
12563: LD_INT 750
12565: GREATEREQUAL
12566: IFFALSE 12580
// SetLives ( Kikuchi , 700 ) ;
12568: LD_EXP 34
12572: PPUSH
12573: LD_INT 700
12575: PPUSH
12576: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12580: LD_INT 35
12582: PPUSH
12583: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12587: LD_INT 1
12589: PPUSH
12590: LD_EXP 34
12594: PPUSH
12595: CALL_OW 292
12599: PUSH
12600: LD_EXP 34
12604: PPUSH
12605: LD_INT 7
12607: PPUSH
12608: CALL_OW 296
12612: PUSH
12613: LD_INT 17
12615: LESS
12616: OR
12617: IFFALSE 12580
// DialogueOn ;
12619: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12623: LD_EXP 34
12627: PPUSH
12628: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12632: LD_EXP 34
12636: PPUSH
12637: LD_STRING D4Yb-Yam-1
12639: PPUSH
12640: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12644: LD_EXP 21
12648: PPUSH
12649: LD_STRING D4Yb-JMM-1
12651: PPUSH
12652: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12656: LD_EXP 34
12660: PPUSH
12661: LD_STRING D4Yb-Yam-2
12663: PPUSH
12664: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12668: LD_EXP 21
12672: PPUSH
12673: LD_STRING D4Yb-JMM-2
12675: PPUSH
12676: CALL_OW 88
// DialogueOff ;
12680: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12684: LD_EXP 34
12688: PPUSH
12689: LD_INT 1
12691: PPUSH
12692: CALL_OW 235
// end ; end ; end ;
12696: PPOPN 2
12698: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12699: LD_EXP 6
12703: IFFALSE 13736
12705: GO 12707
12707: DISABLE
12708: LD_INT 0
12710: PPUSH
12711: PPUSH
12712: PPUSH
12713: PPUSH
// begin enable ;
12714: ENABLE
// if not seen [ 1 ] then
12715: LD_EXP 9
12719: PUSH
12720: LD_INT 1
12722: ARRAY
12723: NOT
12724: IFFALSE 12904
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12726: LD_ADDR_VAR 0 2
12730: PUSH
12731: LD_INT 22
12733: PUSH
12734: LD_INT 2
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: PUSH
12741: LD_INT 2
12743: PUSH
12744: LD_INT 25
12746: PUSH
12747: LD_INT 11
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 33
12756: PUSH
12757: LD_INT 4
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PPUSH
12773: CALL_OW 69
12777: ST_TO_ADDR
// if tmp then
12778: LD_VAR 0 2
12782: IFFALSE 12904
// for i in tmp do
12784: LD_ADDR_VAR 0 1
12788: PUSH
12789: LD_VAR 0 2
12793: PUSH
12794: FOR_IN
12795: IFFALSE 12902
// if See ( 1 , i ) then
12797: LD_INT 1
12799: PPUSH
12800: LD_VAR 0 1
12804: PPUSH
12805: CALL_OW 292
12809: IFFALSE 12900
// begin seen := Replace ( seen , 1 , true ) ;
12811: LD_ADDR_EXP 9
12815: PUSH
12816: LD_EXP 9
12820: PPUSH
12821: LD_INT 1
12823: PPUSH
12824: LD_INT 1
12826: PPUSH
12827: CALL_OW 1
12831: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12832: LD_INT 1
12834: PPUSH
12835: CALL 16433 0 1
12839: IFFALSE 12900
// begin DialogueOn ;
12841: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12845: LD_VAR 0 1
12849: PPUSH
12850: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12854: LD_INT 10
12856: PPUSH
12857: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12861: LD_ADDR_VAR 0 3
12865: PUSH
12866: LD_INT 1
12868: PPUSH
12869: LD_STRING D5a-Sol2-1
12871: PPUSH
12872: CALL 16611 0 2
12876: ST_TO_ADDR
// if not un then
12877: LD_VAR 0 3
12881: NOT
12882: IFFALSE 12894
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12884: LD_INT 2
12886: PPUSH
12887: LD_STRING D5a-FSol2-1
12889: PPUSH
12890: CALL 16611 0 2
// DialogueOff ;
12894: CALL_OW 7
// break ;
12898: GO 12902
// end ; end ;
12900: GO 12794
12902: POP
12903: POP
// end ; if not seen [ 2 ] then
12904: LD_EXP 9
12908: PUSH
12909: LD_INT 2
12911: ARRAY
12912: NOT
12913: IFFALSE 13138
// begin can_kamikazed := true ;
12915: LD_ADDR_EXP 10
12919: PUSH
12920: LD_INT 1
12922: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12923: LD_ADDR_VAR 0 2
12927: PUSH
12928: LD_INT 22
12930: PUSH
12931: LD_INT 2
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: PUSH
12938: LD_INT 25
12940: PUSH
12941: LD_INT 17
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: PUSH
12948: EMPTY
12949: LIST
12950: LIST
12951: PPUSH
12952: CALL_OW 69
12956: ST_TO_ADDR
// if tmp then
12957: LD_VAR 0 2
12961: IFFALSE 13138
// for i in tmp do
12963: LD_ADDR_VAR 0 1
12967: PUSH
12968: LD_VAR 0 2
12972: PUSH
12973: FOR_IN
12974: IFFALSE 13136
// if See ( 1 , i ) then
12976: LD_INT 1
12978: PPUSH
12979: LD_VAR 0 1
12983: PPUSH
12984: CALL_OW 292
12988: IFFALSE 13134
// begin seen := Replace ( seen , 2 , true ) ;
12990: LD_ADDR_EXP 9
12994: PUSH
12995: LD_EXP 9
12999: PPUSH
13000: LD_INT 2
13002: PPUSH
13003: LD_INT 1
13005: PPUSH
13006: CALL_OW 1
13010: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13011: LD_INT 1
13013: PPUSH
13014: CALL 16433 0 1
13018: IFFALSE 13134
// begin DialogueOn ;
13020: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13024: LD_VAR 0 1
13028: PPUSH
13029: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13033: LD_INT 10
13035: PPUSH
13036: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13040: LD_ADDR_VAR 0 3
13044: PUSH
13045: LD_INT 1
13047: PPUSH
13048: LD_STRING D5b-Sol1-1
13050: PPUSH
13051: CALL 16611 0 2
13055: ST_TO_ADDR
// if not un then
13056: LD_VAR 0 3
13060: NOT
13061: IFFALSE 13079
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13063: LD_ADDR_VAR 0 3
13067: PUSH
13068: LD_INT 2
13070: PPUSH
13071: LD_STRING D5b-FSol1-1
13073: PPUSH
13074: CALL 16611 0 2
13078: ST_TO_ADDR
// if un then
13079: LD_VAR 0 3
13083: IFFALSE 13128
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13085: LD_ADDR_VAR 0 4
13089: PUSH
13090: LD_INT 1
13092: PPUSH
13093: LD_STRING D5b-Sol2-1
13095: PPUSH
13096: LD_VAR 0 3
13100: PPUSH
13101: CALL 16837 0 3
13105: ST_TO_ADDR
// if not un2 then
13106: LD_VAR 0 4
13110: NOT
13111: IFFALSE 13128
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13113: LD_INT 2
13115: PPUSH
13116: LD_STRING D5b-FSol2-1
13118: PPUSH
13119: LD_VAR 0 3
13123: PPUSH
13124: CALL 16837 0 3
// end ; DialogueOff ;
13128: CALL_OW 7
// break ;
13132: GO 13136
// end ; end ;
13134: GO 12973
13136: POP
13137: POP
// end ; if not seen [ 3 ] then
13138: LD_EXP 9
13142: PUSH
13143: LD_INT 3
13145: ARRAY
13146: NOT
13147: IFFALSE 13321
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13149: LD_ADDR_VAR 0 2
13153: PUSH
13154: LD_INT 22
13156: PUSH
13157: LD_INT 2
13159: PUSH
13160: EMPTY
13161: LIST
13162: LIST
13163: PUSH
13164: LD_INT 33
13166: PUSH
13167: LD_INT 2
13169: PUSH
13170: EMPTY
13171: LIST
13172: LIST
13173: PUSH
13174: EMPTY
13175: LIST
13176: LIST
13177: PPUSH
13178: CALL_OW 69
13182: ST_TO_ADDR
// if tmp then
13183: LD_VAR 0 2
13187: IFFALSE 13321
// for i in tmp do
13189: LD_ADDR_VAR 0 1
13193: PUSH
13194: LD_VAR 0 2
13198: PUSH
13199: FOR_IN
13200: IFFALSE 13319
// if See ( 1 , i ) then
13202: LD_INT 1
13204: PPUSH
13205: LD_VAR 0 1
13209: PPUSH
13210: CALL_OW 292
13214: IFFALSE 13317
// begin seen := Replace ( seen , 3 , true ) ;
13216: LD_ADDR_EXP 9
13220: PUSH
13221: LD_EXP 9
13225: PPUSH
13226: LD_INT 3
13228: PPUSH
13229: LD_INT 1
13231: PPUSH
13232: CALL_OW 1
13236: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13237: LD_INT 1
13239: PPUSH
13240: CALL 16433 0 1
13244: IFFALSE 13317
// begin DialogueOn ;
13246: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13250: LD_VAR 0 1
13254: PPUSH
13255: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13259: LD_INT 10
13261: PPUSH
13262: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13266: LD_ADDR_VAR 0 3
13270: PUSH
13271: LD_INT 1
13273: PPUSH
13274: LD_STRING D8-Sol1-1
13276: PPUSH
13277: CALL 16611 0 2
13281: ST_TO_ADDR
// if not un then
13282: LD_VAR 0 3
13286: NOT
13287: IFFALSE 13299
// SayRand ( sex_female , D8-FSol1-1 ) ;
13289: LD_INT 2
13291: PPUSH
13292: LD_STRING D8-FSol1-1
13294: PPUSH
13295: CALL 16611 0 2
// Say ( JMM , D8-JMM-1 ) ;
13299: LD_EXP 21
13303: PPUSH
13304: LD_STRING D8-JMM-1
13306: PPUSH
13307: CALL_OW 88
// DialogueOff ;
13311: CALL_OW 7
// break ;
13315: GO 13319
// end ; end ;
13317: GO 13199
13319: POP
13320: POP
// end ; if not seen [ 4 ] then
13321: LD_EXP 9
13325: PUSH
13326: LD_INT 4
13328: ARRAY
13329: NOT
13330: IFFALSE 13492
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13332: LD_ADDR_VAR 0 2
13336: PUSH
13337: LD_INT 22
13339: PUSH
13340: LD_INT 2
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: PUSH
13347: LD_INT 33
13349: PUSH
13350: LD_INT 5
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: EMPTY
13358: LIST
13359: LIST
13360: PPUSH
13361: CALL_OW 69
13365: ST_TO_ADDR
// if tmp then
13366: LD_VAR 0 2
13370: IFFALSE 13492
// for i in tmp do
13372: LD_ADDR_VAR 0 1
13376: PUSH
13377: LD_VAR 0 2
13381: PUSH
13382: FOR_IN
13383: IFFALSE 13490
// if See ( 1 , i ) then
13385: LD_INT 1
13387: PPUSH
13388: LD_VAR 0 1
13392: PPUSH
13393: CALL_OW 292
13397: IFFALSE 13488
// begin seen := Replace ( seen , 4 , true ) ;
13399: LD_ADDR_EXP 9
13403: PUSH
13404: LD_EXP 9
13408: PPUSH
13409: LD_INT 4
13411: PPUSH
13412: LD_INT 1
13414: PPUSH
13415: CALL_OW 1
13419: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13420: LD_INT 1
13422: PPUSH
13423: CALL 16433 0 1
13427: IFFALSE 13488
// begin DialogueOn ;
13429: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13433: LD_VAR 0 1
13437: PPUSH
13438: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13442: LD_INT 10
13444: PPUSH
13445: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13449: LD_ADDR_VAR 0 3
13453: PUSH
13454: LD_INT 1
13456: PPUSH
13457: LD_STRING D5a-Sol1-1
13459: PPUSH
13460: CALL 16611 0 2
13464: ST_TO_ADDR
// if not un then
13465: LD_VAR 0 3
13469: NOT
13470: IFFALSE 13482
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13472: LD_INT 2
13474: PPUSH
13475: LD_STRING D5a-FSol1-1
13477: PPUSH
13478: CALL 16611 0 2
// DialogueOff ;
13482: CALL_OW 7
// break ;
13486: GO 13490
// end ; end ;
13488: GO 13382
13490: POP
13491: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13492: LD_EXP 9
13496: PUSH
13497: LD_INT 5
13499: ARRAY
13500: NOT
13501: PUSH
13502: LD_EXP 9
13506: PUSH
13507: LD_INT 3
13509: ARRAY
13510: AND
13511: IFFALSE 13685
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13513: LD_ADDR_VAR 0 2
13517: PUSH
13518: LD_INT 22
13520: PUSH
13521: LD_INT 2
13523: PUSH
13524: EMPTY
13525: LIST
13526: LIST
13527: PUSH
13528: LD_INT 34
13530: PUSH
13531: LD_INT 31
13533: PUSH
13534: EMPTY
13535: LIST
13536: LIST
13537: PUSH
13538: EMPTY
13539: LIST
13540: LIST
13541: PPUSH
13542: CALL_OW 69
13546: ST_TO_ADDR
// if tmp then
13547: LD_VAR 0 2
13551: IFFALSE 13685
// for i in tmp do
13553: LD_ADDR_VAR 0 1
13557: PUSH
13558: LD_VAR 0 2
13562: PUSH
13563: FOR_IN
13564: IFFALSE 13683
// if See ( 1 , i ) then
13566: LD_INT 1
13568: PPUSH
13569: LD_VAR 0 1
13573: PPUSH
13574: CALL_OW 292
13578: IFFALSE 13681
// begin seen := Replace ( seen , 5 , true ) ;
13580: LD_ADDR_EXP 9
13584: PUSH
13585: LD_EXP 9
13589: PPUSH
13590: LD_INT 5
13592: PPUSH
13593: LD_INT 1
13595: PPUSH
13596: CALL_OW 1
13600: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13601: LD_INT 1
13603: PPUSH
13604: CALL 16433 0 1
13608: IFFALSE 13681
// begin DialogueOn ;
13610: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13614: LD_VAR 0 1
13618: PPUSH
13619: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13623: LD_INT 10
13625: PPUSH
13626: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13630: LD_ADDR_VAR 0 3
13634: PUSH
13635: LD_INT 1
13637: PPUSH
13638: LD_STRING D8a-Sol2-1
13640: PPUSH
13641: CALL 16611 0 2
13645: ST_TO_ADDR
// if not un then
13646: LD_VAR 0 3
13650: NOT
13651: IFFALSE 13663
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13653: LD_INT 2
13655: PPUSH
13656: LD_STRING D8a-FSol2-1
13658: PPUSH
13659: CALL 16611 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13663: LD_EXP 21
13667: PPUSH
13668: LD_STRING D8a-JMM-1
13670: PPUSH
13671: CALL_OW 88
// DialogueOff ;
13675: CALL_OW 7
// break ;
13679: GO 13683
// end ; end ;
13681: GO 13563
13683: POP
13684: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13685: LD_EXP 9
13689: PUSH
13690: LD_INT 1
13692: ARRAY
13693: PUSH
13694: LD_EXP 9
13698: PUSH
13699: LD_INT 2
13701: ARRAY
13702: AND
13703: PUSH
13704: LD_EXP 9
13708: PUSH
13709: LD_INT 3
13711: ARRAY
13712: AND
13713: PUSH
13714: LD_EXP 9
13718: PUSH
13719: LD_INT 4
13721: ARRAY
13722: AND
13723: PUSH
13724: LD_EXP 9
13728: PUSH
13729: LD_INT 5
13731: ARRAY
13732: AND
13733: IFFALSE 13736
// disable ;
13735: DISABLE
// end ;
13736: PPOPN 4
13738: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13739: LD_EXP 10
13743: PUSH
13744: LD_EXP 11
13748: AND
13749: IFFALSE 13947
13751: GO 13753
13753: DISABLE
13754: LD_INT 0
13756: PPUSH
// begin DialogueOn ;
13757: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13761: LD_EXP 11
13765: PPUSH
13766: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13770: LD_ADDR_VAR 0 1
13774: PUSH
13775: LD_INT 1
13777: PPUSH
13778: LD_STRING D5c-Sol1-1
13780: PPUSH
13781: CALL 16611 0 2
13785: ST_TO_ADDR
// if not un then
13786: LD_VAR 0 1
13790: NOT
13791: IFFALSE 13809
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13793: LD_ADDR_VAR 0 1
13797: PUSH
13798: LD_INT 2
13800: PPUSH
13801: LD_STRING D5c-FSol1-1
13803: PPUSH
13804: CALL 16611 0 2
13808: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13809: LD_EXP 21
13813: PPUSH
13814: LD_STRING D5c-JMM-1
13816: PPUSH
13817: CALL_OW 88
// if IsOk ( Lisa ) then
13821: LD_EXP 22
13825: PPUSH
13826: CALL_OW 302
13830: IFFALSE 13846
// Say ( Lisa , D5d-Lisa-1 ) else
13832: LD_EXP 22
13836: PPUSH
13837: LD_STRING D5d-Lisa-1
13839: PPUSH
13840: CALL_OW 88
13844: GO 13931
// if IsOk ( Cyrus ) then
13846: LD_EXP 25
13850: PPUSH
13851: CALL_OW 302
13855: IFFALSE 13871
// Say ( Cyrus , D5d-Cyrus-1 ) else
13857: LD_EXP 25
13861: PPUSH
13862: LD_STRING D5d-Cyrus-1
13864: PPUSH
13865: CALL_OW 88
13869: GO 13931
// if IsOk ( Gary ) then
13871: LD_EXP 32
13875: PPUSH
13876: CALL_OW 302
13880: IFFALSE 13896
// Say ( Gary , D5d-Gary-1 ) else
13882: LD_EXP 32
13886: PPUSH
13887: LD_STRING D5d-Gary-1
13889: PPUSH
13890: CALL_OW 88
13894: GO 13931
// if GetSex ( un ) = sex_male then
13896: LD_VAR 0 1
13900: PPUSH
13901: CALL_OW 258
13905: PUSH
13906: LD_INT 1
13908: EQUAL
13909: IFFALSE 13925
// Say ( un , D5d-Sol1-1 ) else
13911: LD_VAR 0 1
13915: PPUSH
13916: LD_STRING D5d-Sol1-1
13918: PPUSH
13919: CALL_OW 88
13923: GO 13931
// begin DialogueOff ;
13925: CALL_OW 7
// exit ;
13929: GO 13947
// end ; Say ( JMM , D5d-JMM-1 ) ;
13931: LD_EXP 21
13935: PPUSH
13936: LD_STRING D5d-JMM-1
13938: PPUSH
13939: CALL_OW 88
// DialogueOff ;
13943: CALL_OW 7
// end ;
13947: PPOPN 1
13949: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13950: LD_INT 1
13952: PPUSH
13953: LD_INT 17
13955: PPUSH
13956: CALL_OW 294
13960: PUSH
13961: LD_INT 2
13963: GREATEREQUAL
13964: IFFALSE 14096
13966: GO 13968
13968: DISABLE
13969: LD_INT 0
13971: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13972: LD_INT 10
13974: PPUSH
13975: LD_INT 5
13977: PPUSH
13978: LD_INT 1
13980: PPUSH
13981: LD_INT 10
13983: NEG
13984: PPUSH
13985: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13989: LD_INT 10
13991: PPUSH
13992: LD_INT 5
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14002: LD_INT 10
14004: PPUSH
14005: LD_INT 5
14007: PPUSH
14008: CALL_OW 86
// DialogueOn ;
14012: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14016: LD_ADDR_VAR 0 1
14020: PUSH
14021: LD_INT 1
14023: PPUSH
14024: LD_STRING D6-Sci1-1
14026: PPUSH
14027: CALL 16611 0 2
14031: ST_TO_ADDR
// if un then
14032: LD_VAR 0 1
14036: IFFALSE 14074
// begin Say ( JMM , D6-JMM-1 ) ;
14038: LD_EXP 21
14042: PPUSH
14043: LD_STRING D6-JMM-1
14045: PPUSH
14046: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14050: LD_VAR 0 1
14054: PPUSH
14055: LD_STRING D6-Sci1-2
14057: PPUSH
14058: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14062: LD_EXP 21
14066: PPUSH
14067: LD_STRING D6-JMM-2
14069: PPUSH
14070: CALL_OW 88
// end ; DialogueOff ;
14074: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14078: LD_STRING M3
14080: PPUSH
14081: CALL_OW 337
// wait ( 0 0$30 ) ;
14085: LD_INT 1050
14087: PPUSH
14088: CALL_OW 67
// AmericanReinforcements ;
14092: CALL 2319 0 0
// end ;
14096: PPOPN 1
14098: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14099: LD_OWVAR 1
14103: PUSH
14104: LD_INT 42000
14106: GREATEREQUAL
14107: PUSH
14108: LD_INT 2
14110: PPUSH
14111: LD_INT 169
14113: PPUSH
14114: LD_INT 90
14116: PPUSH
14117: LD_INT 10
14119: PPUSH
14120: CALL 53802 0 4
14124: PUSH
14125: LD_INT 4
14127: ARRAY
14128: PUSH
14129: LD_INT 0
14131: EQUAL
14132: PUSH
14133: LD_INT 45
14135: PPUSH
14136: CALL_OW 301
14140: OR
14141: PUSH
14142: LD_INT 45
14144: PPUSH
14145: CALL_OW 255
14149: PUSH
14150: LD_INT 1
14152: EQUAL
14153: OR
14154: AND
14155: PUSH
14156: LD_INT 94
14158: PPUSH
14159: CALL_OW 301
14163: NOT
14164: AND
14165: IFFALSE 15370
14167: GO 14169
14169: DISABLE
14170: LD_INT 0
14172: PPUSH
14173: PPUSH
14174: PPUSH
14175: PPUSH
14176: PPUSH
// begin uc_side := 5 ;
14177: LD_ADDR_OWVAR 20
14181: PUSH
14182: LD_INT 5
14184: ST_TO_ADDR
// uc_nation := 2 ;
14185: LD_ADDR_OWVAR 21
14189: PUSH
14190: LD_INT 2
14192: ST_TO_ADDR
// InitHc ;
14193: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14197: LD_INT 1
14199: PPUSH
14200: LD_INT 3
14202: PPUSH
14203: LD_INT 8
14205: PPUSH
14206: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14210: LD_ADDR_OWVAR 29
14214: PUSH
14215: LD_INT 12
14217: PUSH
14218: LD_INT 12
14220: PUSH
14221: EMPTY
14222: LIST
14223: LIST
14224: ST_TO_ADDR
// hc_name := Hans Fliege ;
14225: LD_ADDR_OWVAR 26
14229: PUSH
14230: LD_STRING Hans Fliege
14232: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14233: LD_ADDR_OWVAR 33
14237: PUSH
14238: LD_STRING SecondCharsGal
14240: ST_TO_ADDR
// hc_face_number := 7 ;
14241: LD_ADDR_OWVAR 34
14245: PUSH
14246: LD_INT 7
14248: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14249: LD_ADDR_EXP 46
14253: PUSH
14254: CALL_OW 44
14258: ST_TO_ADDR
// InitHc ;
14259: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14263: LD_INT 1
14265: PPUSH
14266: LD_INT 16
14268: PPUSH
14269: LD_INT 2
14271: PPUSH
14272: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14276: LD_ADDR_OWVAR 29
14280: PUSH
14281: LD_INT 12
14283: PUSH
14284: LD_INT 12
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: ST_TO_ADDR
// hc_name :=  ;
14291: LD_ADDR_OWVAR 26
14295: PUSH
14296: LD_STRING 
14298: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14299: LD_ADDR_EXP 47
14303: PUSH
14304: CALL_OW 44
14308: ST_TO_ADDR
// InitHc ;
14309: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14313: LD_INT 35
14315: PPUSH
14316: CALL_OW 67
// until not InBattle ( 1 ) ;
14320: LD_INT 1
14322: PPUSH
14323: CALL_OW 463
14327: NOT
14328: IFFALSE 14313
// wait ( 0 0$5 ) ;
14330: LD_INT 175
14332: PPUSH
14333: CALL_OW 67
// DialogueOn ;
14337: CALL_OW 6
// InGameOn ;
14341: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14345: LD_ADDR_VAR 0 1
14349: PUSH
14350: LD_INT 22
14352: PUSH
14353: LD_INT 1
14355: PUSH
14356: EMPTY
14357: LIST
14358: LIST
14359: PUSH
14360: LD_INT 2
14362: PUSH
14363: LD_INT 25
14365: PUSH
14366: LD_INT 1
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: PUSH
14373: LD_INT 25
14375: PUSH
14376: LD_INT 2
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: PUSH
14383: LD_INT 25
14385: PUSH
14386: LD_INT 3
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: PUSH
14393: LD_INT 25
14395: PUSH
14396: LD_INT 4
14398: PUSH
14399: EMPTY
14400: LIST
14401: LIST
14402: PUSH
14403: LD_INT 25
14405: PUSH
14406: LD_INT 5
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: PUSH
14413: LD_INT 25
14415: PUSH
14416: LD_INT 8
14418: PUSH
14419: EMPTY
14420: LIST
14421: LIST
14422: PUSH
14423: EMPTY
14424: LIST
14425: LIST
14426: LIST
14427: LIST
14428: LIST
14429: LIST
14430: LIST
14431: PUSH
14432: EMPTY
14433: LIST
14434: LIST
14435: PPUSH
14436: CALL_OW 69
14440: PUSH
14441: LD_EXP 21
14445: PUSH
14446: LD_EXP 22
14450: PUSH
14451: LD_EXP 23
14455: PUSH
14456: LD_EXP 24
14460: PUSH
14461: LD_EXP 25
14465: PUSH
14466: LD_EXP 26
14470: PUSH
14471: LD_EXP 27
14475: PUSH
14476: LD_EXP 28
14480: PUSH
14481: LD_EXP 29
14485: PUSH
14486: LD_EXP 31
14490: PUSH
14491: LD_EXP 32
14495: PUSH
14496: LD_EXP 33
14500: PUSH
14501: LD_EXP 34
14505: PUSH
14506: EMPTY
14507: LIST
14508: LIST
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: DIFF
14521: PPUSH
14522: LD_INT 26
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: EMPTY
14529: LIST
14530: LIST
14531: PPUSH
14532: CALL_OW 72
14536: PUSH
14537: LD_INT 1
14539: ARRAY
14540: ST_TO_ADDR
// if Brown then
14541: LD_EXP 27
14545: IFFALSE 14557
// un := Brown ;
14547: LD_ADDR_VAR 0 1
14551: PUSH
14552: LD_EXP 27
14556: ST_TO_ADDR
// if un then
14557: LD_VAR 0 1
14561: IFFALSE 14587
// begin Say ( un , D7-Sol1-1 ) ;
14563: LD_VAR 0 1
14567: PPUSH
14568: LD_STRING D7-Sol1-1
14570: PPUSH
14571: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14575: LD_EXP 21
14579: PPUSH
14580: LD_STRING D7-JMM-1
14582: PPUSH
14583: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14587: LD_EXP 46
14591: PPUSH
14592: LD_STRING D7-Ar1-1
14594: PPUSH
14595: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14599: LD_EXP 21
14603: PPUSH
14604: LD_STRING D7-JMM-2
14606: PPUSH
14607: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14611: LD_EXP 46
14615: PPUSH
14616: LD_STRING D7-Ar1-2
14618: PPUSH
14619: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14623: LD_EXP 21
14627: PPUSH
14628: LD_STRING D7-JMM-3
14630: PPUSH
14631: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14635: LD_EXP 46
14639: PPUSH
14640: LD_STRING D7-Ar1-3
14642: PPUSH
14643: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14647: LD_EXP 21
14651: PPUSH
14652: LD_STRING D7-JMM-4
14654: PPUSH
14655: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14659: LD_EXP 46
14663: PPUSH
14664: LD_STRING D7-Ar1-4
14666: PPUSH
14667: CALL_OW 94
// InGameOff ;
14671: CALL_OW 9
// DialogueOff ;
14675: CALL_OW 7
// case Query ( QCameras ) of 1 :
14679: LD_STRING QCameras
14681: PPUSH
14682: CALL_OW 97
14686: PUSH
14687: LD_INT 1
14689: DOUBLE
14690: EQUAL
14691: IFTRUE 14695
14693: GO 14698
14695: POP
// ; 2 :
14696: GO 14712
14698: LD_INT 2
14700: DOUBLE
14701: EQUAL
14702: IFTRUE 14706
14704: GO 14711
14706: POP
// exit ; end ;
14707: GO 15370
14709: GO 14712
14711: POP
// ChangeMissionObjectives ( MCar ) ;
14712: LD_STRING MCar
14714: PPUSH
14715: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14719: LD_INT 124
14721: PPUSH
14722: LD_INT 90
14724: PPUSH
14725: LD_INT 1
14727: PPUSH
14728: LD_INT 6
14730: NEG
14731: PPUSH
14732: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14736: LD_INT 124
14738: PPUSH
14739: LD_INT 90
14741: PPUSH
14742: LD_INT 1
14744: PPUSH
14745: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14749: LD_INT 12
14751: PPUSH
14752: LD_INT 1
14754: PPUSH
14755: CALL_OW 424
// wait ( 3 ) ;
14759: LD_INT 3
14761: PPUSH
14762: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14766: LD_INT 124
14768: PPUSH
14769: LD_INT 90
14771: PPUSH
14772: CALL_OW 86
// cargo := false ;
14776: LD_ADDR_VAR 0 3
14780: PUSH
14781: LD_INT 0
14783: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14784: LD_INT 35
14786: PPUSH
14787: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14791: LD_ADDR_VAR 0 3
14795: PUSH
14796: LD_INT 12
14798: PPUSH
14799: LD_INT 32
14801: PUSH
14802: LD_INT 3
14804: PUSH
14805: EMPTY
14806: LIST
14807: LIST
14808: PUSH
14809: LD_INT 34
14811: PUSH
14812: LD_INT 32
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: PUSH
14819: LD_INT 58
14821: PUSH
14822: EMPTY
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: LIST
14829: PPUSH
14830: CALL_OW 70
14834: ST_TO_ADDR
// until cargo ;
14835: LD_VAR 0 3
14839: IFFALSE 14784
// cargo := cargo [ 1 ] ;
14841: LD_ADDR_VAR 0 3
14845: PUSH
14846: LD_VAR 0 3
14850: PUSH
14851: LD_INT 1
14853: ARRAY
14854: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14855: LD_VAR 0 3
14859: PPUSH
14860: LD_INT 5
14862: PPUSH
14863: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14867: LD_INT 12
14869: PPUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14877: LD_EXP 46
14881: PPUSH
14882: LD_INT 11
14884: PPUSH
14885: LD_INT 0
14887: PPUSH
14888: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14892: LD_EXP 47
14896: PPUSH
14897: LD_INT 11
14899: PPUSH
14900: LD_INT 0
14902: PPUSH
14903: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14907: LD_EXP 46
14911: PUSH
14912: LD_EXP 47
14916: PUSH
14917: EMPTY
14918: LIST
14919: LIST
14920: PPUSH
14921: LD_INT 12
14923: PPUSH
14924: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14928: LD_EXP 46
14932: PPUSH
14933: LD_VAR 0 3
14937: PPUSH
14938: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14942: LD_EXP 46
14946: PUSH
14947: LD_EXP 47
14951: PUSH
14952: EMPTY
14953: LIST
14954: LIST
14955: PPUSH
14956: LD_INT 209
14958: PPUSH
14959: LD_INT 178
14961: PPUSH
14962: CALL_OW 171
// escaped := 0 ;
14966: LD_ADDR_VAR 0 5
14970: PUSH
14971: LD_INT 0
14973: ST_TO_ADDR
// while ( true ) do
14974: LD_INT 1
14976: IFFALSE 15192
// begin wait ( 0 0$1 ) ;
14978: LD_INT 35
14980: PPUSH
14981: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14985: LD_EXP 46
14989: PPUSH
14990: CALL_OW 314
14994: NOT
14995: PUSH
14996: LD_EXP 47
15000: PPUSH
15001: CALL_OW 314
15005: NOT
15006: OR
15007: IFFALSE 15033
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15009: LD_EXP 46
15013: PUSH
15014: LD_EXP 47
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: PPUSH
15023: LD_INT 209
15025: PPUSH
15026: LD_INT 178
15028: PPUSH
15029: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15033: LD_EXP 46
15037: PPUSH
15038: LD_INT 10
15040: PPUSH
15041: CALL_OW 308
15045: IFFALSE 15070
// begin RemoveUnit ( ar_mechanic ) ;
15047: LD_EXP 46
15051: PPUSH
15052: CALL_OW 64
// escaped := escaped + 1 ;
15056: LD_ADDR_VAR 0 5
15060: PUSH
15061: LD_VAR 0 5
15065: PUSH
15066: LD_INT 1
15068: PLUS
15069: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15070: LD_EXP 47
15074: PPUSH
15075: LD_INT 10
15077: PPUSH
15078: CALL_OW 308
15082: IFFALSE 15107
// begin RemoveUnit ( ar_mechanic_friend ) ;
15084: LD_EXP 47
15088: PPUSH
15089: CALL_OW 64
// escaped := escaped + 1 ;
15093: LD_ADDR_VAR 0 5
15097: PUSH
15098: LD_VAR 0 5
15102: PUSH
15103: LD_INT 1
15105: PLUS
15106: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15107: LD_VAR 0 3
15111: PPUSH
15112: LD_INT 10
15114: PPUSH
15115: CALL_OW 308
15119: IFFALSE 15130
// RemoveUnit ( cargo ) ;
15121: LD_VAR 0 3
15125: PPUSH
15126: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15130: LD_EXP 46
15134: PPUSH
15135: CALL_OW 305
15139: NOT
15140: PUSH
15141: LD_VAR 0 5
15145: PUSH
15146: LD_INT 2
15148: GREATEREQUAL
15149: AND
15150: IFFALSE 15154
// break ;
15152: GO 15192
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15154: LD_EXP 46
15158: PPUSH
15159: CALL_OW 305
15163: NOT
15164: PUSH
15165: LD_EXP 47
15169: PPUSH
15170: CALL_OW 305
15174: NOT
15175: AND
15176: PUSH
15177: LD_VAR 0 5
15181: PUSH
15182: LD_INT 2
15184: LESS
15185: AND
15186: IFFALSE 15190
// exit ;
15188: GO 15370
// end ;
15190: GO 14974
// wait ( 0 0$2 ) ;
15192: LD_INT 70
15194: PPUSH
15195: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15199: LD_EXP 46
15203: PPUSH
15204: LD_STRING D7a-Ar1-1
15206: PPUSH
15207: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15211: LD_ADDR_VAR 0 4
15215: PUSH
15216: LD_INT 129
15218: PUSH
15219: LD_INT 10
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PUSH
15226: LD_INT 103
15228: PUSH
15229: LD_INT 6
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: PUSH
15236: LD_INT 148
15238: PUSH
15239: LD_INT 47
15241: PUSH
15242: EMPTY
15243: LIST
15244: LIST
15245: PUSH
15246: LD_INT 155
15248: PUSH
15249: LD_INT 16
15251: PUSH
15252: EMPTY
15253: LIST
15254: LIST
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: LIST
15260: LIST
15261: ST_TO_ADDR
// if Difficulty = 1 then
15262: LD_OWVAR 67
15266: PUSH
15267: LD_INT 1
15269: EQUAL
15270: IFFALSE 15307
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15272: LD_ADDR_VAR 0 4
15276: PUSH
15277: LD_VAR 0 4
15281: PUSH
15282: LD_INT 78
15284: PUSH
15285: LD_INT 7
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PUSH
15292: LD_INT 104
15294: PUSH
15295: LD_INT 43
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: ADD
15306: ST_TO_ADDR
// for i in tmp do
15307: LD_ADDR_VAR 0 2
15311: PUSH
15312: LD_VAR 0 4
15316: PUSH
15317: FOR_IN
15318: IFFALSE 15351
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15320: LD_VAR 0 2
15324: PUSH
15325: LD_INT 1
15327: ARRAY
15328: PPUSH
15329: LD_VAR 0 2
15333: PUSH
15334: LD_INT 2
15336: ARRAY
15337: PPUSH
15338: LD_INT 1
15340: PPUSH
15341: LD_INT 9
15343: NEG
15344: PPUSH
15345: CALL_OW 330
15349: GO 15317
15351: POP
15352: POP
// SetAchievement ( ACH_FRIEND ) ;
15353: LD_STRING ACH_FRIEND
15355: PPUSH
15356: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15360: LD_INT 129
15362: PPUSH
15363: LD_INT 10
15365: PPUSH
15366: CALL_OW 84
// end ;
15370: PPOPN 5
15372: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15373: LD_EXP 15
15377: PUSH
15378: LD_INT 21000
15380: MINUS
15381: PUSH
15382: LD_OWVAR 1
15386: LESSEQUAL
15387: IFFALSE 15427
15389: GO 15391
15391: DISABLE
// begin powell_warn := true ;
15392: LD_ADDR_EXP 16
15396: PUSH
15397: LD_INT 1
15399: ST_TO_ADDR
// DialogueOn ;
15400: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15404: LD_EXP 30
15408: PPUSH
15409: LD_STRING D9-Pow-1
15411: PPUSH
15412: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15416: LD_INT 10
15418: PPUSH
15419: CALL_OW 68
// DialogueOff ;
15423: CALL_OW 7
// end ;
15427: END
// every 0 0$1 trigger game_time <= tick do
15428: LD_EXP 15
15432: PUSH
15433: LD_OWVAR 1
15437: LESSEQUAL
15438: IFFALSE 15477
15440: GO 15442
15442: DISABLE
// begin DialogueOn ;
15443: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15447: LD_EXP 30
15451: PPUSH
15452: LD_STRING D9a-Pow-1
15454: PPUSH
15455: CALL_OW 94
// dwait ( 0 0$2 ) ;
15459: LD_INT 70
15461: PPUSH
15462: CALL_OW 68
// DialogueOff ;
15466: CALL_OW 7
// YouLost ( Command ) ;
15470: LD_STRING Command
15472: PPUSH
15473: CALL_OW 104
// end ;
15477: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15478: LD_INT 22
15480: PUSH
15481: LD_INT 2
15483: PUSH
15484: EMPTY
15485: LIST
15486: LIST
15487: PUSH
15488: LD_INT 30
15490: PUSH
15491: LD_INT 1
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PPUSH
15502: CALL_OW 69
15506: PUSH
15507: LD_INT 0
15509: EQUAL
15510: PUSH
15511: LD_EXP 21
15515: PPUSH
15516: CALL_OW 302
15520: AND
15521: IFFALSE 16430
15523: GO 15525
15525: DISABLE
15526: LD_INT 0
15528: PPUSH
15529: PPUSH
15530: PPUSH
15531: PPUSH
// begin m1 := false ;
15532: LD_ADDR_VAR 0 2
15536: PUSH
15537: LD_INT 0
15539: ST_TO_ADDR
// m2 := false ;
15540: LD_ADDR_VAR 0 3
15544: PUSH
15545: LD_INT 0
15547: ST_TO_ADDR
// m3 := false ;
15548: LD_ADDR_VAR 0 4
15552: PUSH
15553: LD_INT 0
15555: ST_TO_ADDR
// if not am_veh_consturcted then
15556: LD_EXP 20
15560: NOT
15561: IFFALSE 15570
// SetAchievement ( ACH_ARABTECH ) ;
15563: LD_STRING ACH_ARABTECH
15565: PPUSH
15566: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
15570: LD_OWVAR 1
15574: PUSH
15575: LD_INT 252000
15577: PUSH
15578: LD_INT 210000
15580: PUSH
15581: LD_INT 199500
15583: PUSH
15584: EMPTY
15585: LIST
15586: LIST
15587: LIST
15588: PUSH
15589: LD_OWVAR 67
15593: ARRAY
15594: LESS
15595: IFFALSE 15617
// begin m3 := true ;
15597: LD_ADDR_VAR 0 4
15601: PUSH
15602: LD_INT 1
15604: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15605: LD_STRING Time1
15607: PPUSH
15608: LD_INT 1
15610: PPUSH
15611: CALL_OW 101
// end else
15615: GO 15648
// if not powell_warn then
15617: LD_EXP 16
15621: NOT
15622: IFFALSE 15637
// AddMedal ( Time1 , - 1 ) else
15624: LD_STRING Time1
15626: PPUSH
15627: LD_INT 1
15629: NEG
15630: PPUSH
15631: CALL_OW 101
15635: GO 15648
// AddMedal ( Time1 , - 2 ) ;
15637: LD_STRING Time1
15639: PPUSH
15640: LD_INT 2
15642: NEG
15643: PPUSH
15644: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15648: LD_EXP 17
15652: PUSH
15653: LD_INT 5
15655: PUSH
15656: LD_INT 4
15658: PUSH
15659: LD_INT 3
15661: PUSH
15662: EMPTY
15663: LIST
15664: LIST
15665: LIST
15666: PUSH
15667: LD_OWVAR 67
15671: ARRAY
15672: GREATEREQUAL
15673: IFFALSE 15688
// AddMedal ( Destroy , - 2 ) else
15675: LD_STRING Destroy
15677: PPUSH
15678: LD_INT 2
15680: NEG
15681: PPUSH
15682: CALL_OW 101
15686: GO 15821
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15688: LD_INT 22
15690: PUSH
15691: LD_INT 2
15693: PUSH
15694: EMPTY
15695: LIST
15696: LIST
15697: PUSH
15698: LD_INT 21
15700: PUSH
15701: LD_INT 3
15703: PUSH
15704: EMPTY
15705: LIST
15706: LIST
15707: PUSH
15708: LD_INT 50
15710: PUSH
15711: EMPTY
15712: LIST
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: LIST
15718: PPUSH
15719: CALL_OW 69
15723: PUSH
15724: LD_INT 25
15726: GREATEREQUAL
15727: IFFALSE 15742
// AddMedal ( Destroy , - 1 ) else
15729: LD_STRING Destroy
15731: PPUSH
15732: LD_INT 1
15734: NEG
15735: PPUSH
15736: CALL_OW 101
15740: GO 15821
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15742: LD_INT 22
15744: PUSH
15745: LD_INT 2
15747: PUSH
15748: EMPTY
15749: LIST
15750: LIST
15751: PUSH
15752: LD_INT 21
15754: PUSH
15755: LD_INT 3
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 50
15764: PUSH
15765: EMPTY
15766: LIST
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: LIST
15772: PPUSH
15773: CALL_OW 69
15777: PUSH
15778: LD_INT 15
15780: GREATEREQUAL
15781: IFFALSE 15803
// begin m1 := true ;
15783: LD_ADDR_VAR 0 2
15787: PUSH
15788: LD_INT 1
15790: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15791: LD_STRING Destroy
15793: PPUSH
15794: LD_INT 1
15796: PPUSH
15797: CALL_OW 101
// end else
15801: GO 15821
// begin m1 := true ;
15803: LD_ADDR_VAR 0 2
15807: PUSH
15808: LD_INT 1
15810: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15811: LD_STRING Destroy
15813: PPUSH
15814: LD_INT 2
15816: PPUSH
15817: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15821: LD_EXP 13
15825: PPUSH
15826: LD_STRING 11_artifact_captured
15828: PPUSH
15829: CALL_OW 39
// if artifact_get then
15833: LD_EXP 13
15837: IFFALSE 15859
// begin m2 := true ;
15839: LD_ADDR_VAR 0 3
15843: PUSH
15844: LD_INT 1
15846: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15847: LD_STRING Artefact
15849: PPUSH
15850: LD_INT 1
15852: PPUSH
15853: CALL_OW 101
// end else
15857: GO 15870
// AddMedal ( Artefact , - 1 ) ;
15859: LD_STRING Artefact
15861: PPUSH
15862: LD_INT 1
15864: NEG
15865: PPUSH
15866: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15870: LD_VAR 0 2
15874: PUSH
15875: LD_VAR 0 3
15879: AND
15880: PUSH
15881: LD_VAR 0 4
15885: AND
15886: PUSH
15887: LD_OWVAR 67
15891: PUSH
15892: LD_INT 3
15894: EQUAL
15895: AND
15896: IFFALSE 15908
// SetAchievementEX ( ACH_AMER , 11 ) ;
15898: LD_STRING ACH_AMER
15900: PPUSH
15901: LD_INT 11
15903: PPUSH
15904: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15908: LD_VAR 0 2
15912: PUSH
15913: LD_VAR 0 3
15917: AND
15918: PUSH
15919: LD_VAR 0 4
15923: AND
15924: PUSH
15925: LD_EXP 17
15929: PUSH
15930: LD_INT 0
15932: EQUAL
15933: AND
15934: IFFALSE 15950
// begin wait ( 3 ) ;
15936: LD_INT 3
15938: PPUSH
15939: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15943: LD_STRING ACH_GENERAL
15945: PPUSH
15946: CALL_OW 543
// end ; if tick <= 100 100$00 then
15950: LD_OWVAR 1
15954: PUSH
15955: LD_INT 210000
15957: LESSEQUAL
15958: IFFALSE 15974
// begin wait ( 3 ) ;
15960: LD_INT 3
15962: PPUSH
15963: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15967: LD_STRING ACH_ASPEED_11
15969: PPUSH
15970: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15974: LD_STRING MAIN
15976: PPUSH
15977: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15981: LD_ADDR_EXP 19
15985: PUSH
15986: LD_EXP 19
15990: PPUSH
15991: LD_INT 51
15993: PUSH
15994: EMPTY
15995: LIST
15996: PPUSH
15997: CALL_OW 72
16001: ST_TO_ADDR
// tmp := JMM ^ selected ;
16002: LD_ADDR_VAR 0 1
16006: PUSH
16007: LD_EXP 21
16011: PUSH
16012: LD_EXP 19
16016: ADD
16017: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16018: LD_VAR 0 1
16022: PPUSH
16023: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16027: LD_VAR 0 1
16031: PUSH
16032: LD_EXP 21
16036: PUSH
16037: LD_EXP 22
16041: PUSH
16042: LD_EXP 23
16046: PUSH
16047: LD_EXP 24
16051: PUSH
16052: LD_EXP 25
16056: PUSH
16057: LD_EXP 26
16061: PUSH
16062: LD_EXP 27
16066: PUSH
16067: LD_EXP 28
16071: PUSH
16072: LD_EXP 29
16076: PUSH
16077: LD_EXP 31
16081: PUSH
16082: LD_EXP 32
16086: PUSH
16087: LD_EXP 33
16091: PUSH
16092: LD_EXP 34
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: LIST
16101: LIST
16102: LIST
16103: LIST
16104: LIST
16105: LIST
16106: LIST
16107: LIST
16108: LIST
16109: LIST
16110: LIST
16111: DIFF
16112: PPUSH
16113: LD_STRING 11c_others
16115: PPUSH
16116: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16120: LD_EXP 21
16124: PPUSH
16125: LD_EXP 3
16129: PUSH
16130: LD_STRING JMM
16132: STR
16133: PPUSH
16134: CALL_OW 38
// if Lisa then
16138: LD_EXP 22
16142: IFFALSE 16162
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16144: LD_EXP 22
16148: PPUSH
16149: LD_EXP 3
16153: PUSH
16154: LD_STRING Lisa
16156: STR
16157: PPUSH
16158: CALL_OW 38
// if Donaldson then
16162: LD_EXP 23
16166: IFFALSE 16186
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16168: LD_EXP 23
16172: PPUSH
16173: LD_EXP 3
16177: PUSH
16178: LD_STRING Donaldson
16180: STR
16181: PPUSH
16182: CALL_OW 38
// if Bobby then
16186: LD_EXP 24
16190: IFFALSE 16210
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16192: LD_EXP 24
16196: PPUSH
16197: LD_EXP 3
16201: PUSH
16202: LD_STRING Bobby
16204: STR
16205: PPUSH
16206: CALL_OW 38
// if Cyrus then
16210: LD_EXP 25
16214: IFFALSE 16234
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16216: LD_EXP 25
16220: PPUSH
16221: LD_EXP 3
16225: PUSH
16226: LD_STRING Cyrus
16228: STR
16229: PPUSH
16230: CALL_OW 38
// if Denis then
16234: LD_EXP 26
16238: IFFALSE 16258
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16240: LD_EXP 26
16244: PPUSH
16245: LD_EXP 3
16249: PUSH
16250: LD_STRING Denis
16252: STR
16253: PPUSH
16254: CALL_OW 38
// if Brown then
16258: LD_EXP 27
16262: IFFALSE 16282
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16264: LD_EXP 27
16268: PPUSH
16269: LD_EXP 3
16273: PUSH
16274: LD_STRING Brown
16276: STR
16277: PPUSH
16278: CALL_OW 38
// if Gladstone then
16282: LD_EXP 28
16286: IFFALSE 16306
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16288: LD_EXP 28
16292: PPUSH
16293: LD_EXP 3
16297: PUSH
16298: LD_STRING Gladstone
16300: STR
16301: PPUSH
16302: CALL_OW 38
// if Houten then
16306: LD_EXP 29
16310: IFFALSE 16330
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16312: LD_EXP 29
16316: PPUSH
16317: LD_EXP 3
16321: PUSH
16322: LD_STRING Houten
16324: STR
16325: PPUSH
16326: CALL_OW 38
// if Cornel then
16330: LD_EXP 31
16334: IFFALSE 16354
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16336: LD_EXP 31
16340: PPUSH
16341: LD_EXP 3
16345: PUSH
16346: LD_STRING Cornell
16348: STR
16349: PPUSH
16350: CALL_OW 38
// if Gary then
16354: LD_EXP 32
16358: IFFALSE 16378
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16360: LD_EXP 32
16364: PPUSH
16365: LD_EXP 3
16369: PUSH
16370: LD_STRING Gary
16372: STR
16373: PPUSH
16374: CALL_OW 38
// if Frank then
16378: LD_EXP 33
16382: IFFALSE 16402
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16384: LD_EXP 33
16388: PPUSH
16389: LD_EXP 3
16393: PUSH
16394: LD_STRING Frank
16396: STR
16397: PPUSH
16398: CALL_OW 38
// if Kikuchi then
16402: LD_EXP 34
16406: IFFALSE 16426
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16408: LD_EXP 34
16412: PPUSH
16413: LD_EXP 3
16417: PUSH
16418: LD_STRING Kikuchi
16420: STR
16421: PPUSH
16422: CALL_OW 38
// YouWin ;
16426: CALL_OW 103
// end ;
16430: PPOPN 4
16432: END
// export function CanSayRand ( side ) ; begin
16433: LD_INT 0
16435: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16436: LD_ADDR_VAR 0 2
16440: PUSH
16441: LD_INT 52
16443: PUSH
16444: EMPTY
16445: LIST
16446: PUSH
16447: LD_INT 22
16449: PUSH
16450: LD_VAR 0 1
16454: PUSH
16455: EMPTY
16456: LIST
16457: LIST
16458: PUSH
16459: LD_INT 2
16461: PUSH
16462: LD_INT 25
16464: PUSH
16465: LD_INT 1
16467: PUSH
16468: EMPTY
16469: LIST
16470: LIST
16471: PUSH
16472: LD_INT 25
16474: PUSH
16475: LD_INT 2
16477: PUSH
16478: EMPTY
16479: LIST
16480: LIST
16481: PUSH
16482: LD_INT 25
16484: PUSH
16485: LD_INT 3
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: LD_INT 25
16494: PUSH
16495: LD_INT 4
16497: PUSH
16498: EMPTY
16499: LIST
16500: LIST
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: LIST
16506: LIST
16507: LIST
16508: PUSH
16509: EMPTY
16510: LIST
16511: LIST
16512: LIST
16513: PPUSH
16514: CALL_OW 69
16518: PUSH
16519: LD_EXP 21
16523: PUSH
16524: LD_EXP 33
16528: PUSH
16529: LD_EXP 22
16533: PUSH
16534: LD_EXP 23
16538: PUSH
16539: LD_EXP 24
16543: PUSH
16544: LD_EXP 25
16548: PUSH
16549: LD_EXP 26
16553: PUSH
16554: LD_EXP 27
16558: PUSH
16559: LD_EXP 28
16563: PUSH
16564: LD_EXP 29
16568: PUSH
16569: LD_EXP 30
16573: PUSH
16574: LD_EXP 31
16578: PUSH
16579: LD_EXP 32
16583: PUSH
16584: LD_EXP 34
16588: PUSH
16589: EMPTY
16590: LIST
16591: LIST
16592: LIST
16593: LIST
16594: LIST
16595: LIST
16596: LIST
16597: LIST
16598: LIST
16599: LIST
16600: LIST
16601: LIST
16602: LIST
16603: LIST
16604: DIFF
16605: ST_TO_ADDR
// end ;
16606: LD_VAR 0 2
16610: RET
// export function SayRand ( sex , dial ) ; begin
16611: LD_INT 0
16613: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16614: LD_ADDR_VAR 0 3
16618: PUSH
16619: LD_INT 52
16621: PUSH
16622: EMPTY
16623: LIST
16624: PUSH
16625: LD_INT 22
16627: PUSH
16628: LD_INT 1
16630: PUSH
16631: EMPTY
16632: LIST
16633: LIST
16634: PUSH
16635: LD_INT 26
16637: PUSH
16638: LD_VAR 0 1
16642: PUSH
16643: EMPTY
16644: LIST
16645: LIST
16646: PUSH
16647: LD_INT 2
16649: PUSH
16650: LD_INT 25
16652: PUSH
16653: LD_INT 1
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: PUSH
16660: LD_INT 25
16662: PUSH
16663: LD_INT 2
16665: PUSH
16666: EMPTY
16667: LIST
16668: LIST
16669: PUSH
16670: LD_INT 25
16672: PUSH
16673: LD_INT 3
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PUSH
16680: LD_INT 25
16682: PUSH
16683: LD_INT 4
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: LIST
16694: LIST
16695: LIST
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: LIST
16701: LIST
16702: PPUSH
16703: CALL_OW 69
16707: PUSH
16708: LD_EXP 21
16712: PUSH
16713: LD_EXP 33
16717: PUSH
16718: LD_EXP 22
16722: PUSH
16723: LD_EXP 23
16727: PUSH
16728: LD_EXP 24
16732: PUSH
16733: LD_EXP 25
16737: PUSH
16738: LD_EXP 26
16742: PUSH
16743: LD_EXP 27
16747: PUSH
16748: LD_EXP 28
16752: PUSH
16753: LD_EXP 29
16757: PUSH
16758: LD_EXP 30
16762: PUSH
16763: LD_EXP 31
16767: PUSH
16768: LD_EXP 32
16772: PUSH
16773: LD_EXP 34
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: LIST
16782: LIST
16783: LIST
16784: LIST
16785: LIST
16786: LIST
16787: LIST
16788: LIST
16789: LIST
16790: LIST
16791: LIST
16792: LIST
16793: DIFF
16794: ST_TO_ADDR
// if not result then
16795: LD_VAR 0 3
16799: NOT
16800: IFFALSE 16804
// exit ;
16802: GO 16832
// result := result [ 1 ] ;
16804: LD_ADDR_VAR 0 3
16808: PUSH
16809: LD_VAR 0 3
16813: PUSH
16814: LD_INT 1
16816: ARRAY
16817: ST_TO_ADDR
// Say ( result , dial ) ;
16818: LD_VAR 0 3
16822: PPUSH
16823: LD_VAR 0 2
16827: PPUSH
16828: CALL_OW 88
// end ;
16832: LD_VAR 0 3
16836: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16837: LD_INT 0
16839: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16840: LD_ADDR_VAR 0 4
16844: PUSH
16845: LD_INT 22
16847: PUSH
16848: LD_INT 1
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: PUSH
16855: LD_INT 26
16857: PUSH
16858: LD_VAR 0 1
16862: PUSH
16863: EMPTY
16864: LIST
16865: LIST
16866: PUSH
16867: LD_INT 2
16869: PUSH
16870: LD_INT 25
16872: PUSH
16873: LD_INT 1
16875: PUSH
16876: EMPTY
16877: LIST
16878: LIST
16879: PUSH
16880: LD_INT 25
16882: PUSH
16883: LD_INT 2
16885: PUSH
16886: EMPTY
16887: LIST
16888: LIST
16889: PUSH
16890: LD_INT 25
16892: PUSH
16893: LD_INT 3
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 25
16902: PUSH
16903: LD_INT 4
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: LIST
16916: PUSH
16917: EMPTY
16918: LIST
16919: LIST
16920: LIST
16921: PPUSH
16922: CALL_OW 69
16926: PUSH
16927: LD_EXP 21
16931: PUSH
16932: LD_EXP 33
16936: PUSH
16937: LD_EXP 22
16941: PUSH
16942: LD_EXP 23
16946: PUSH
16947: LD_EXP 24
16951: PUSH
16952: LD_EXP 25
16956: PUSH
16957: LD_EXP 26
16961: PUSH
16962: LD_EXP 27
16966: PUSH
16967: LD_EXP 28
16971: PUSH
16972: LD_EXP 29
16976: PUSH
16977: LD_EXP 30
16981: PUSH
16982: LD_EXP 31
16986: PUSH
16987: LD_EXP 32
16991: PUSH
16992: LD_EXP 34
16996: PUSH
16997: EMPTY
16998: LIST
16999: LIST
17000: LIST
17001: LIST
17002: LIST
17003: LIST
17004: LIST
17005: LIST
17006: LIST
17007: LIST
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: PUSH
17013: LD_VAR 0 3
17017: ADD
17018: DIFF
17019: ST_TO_ADDR
// if not result then
17020: LD_VAR 0 4
17024: NOT
17025: IFFALSE 17029
// exit ;
17027: GO 17057
// result := result [ 1 ] ;
17029: LD_ADDR_VAR 0 4
17033: PUSH
17034: LD_VAR 0 4
17038: PUSH
17039: LD_INT 1
17041: ARRAY
17042: ST_TO_ADDR
// Say ( result , dial ) ;
17043: LD_VAR 0 4
17047: PPUSH
17048: LD_VAR 0 2
17052: PPUSH
17053: CALL_OW 88
// end ; end_of_file
17057: LD_VAR 0 4
17061: RET
// export function CustomEvent ( event ) ; begin
17062: LD_INT 0
17064: PPUSH
// end ;
17065: LD_VAR 0 2
17069: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17070: LD_VAR 0 1
17074: PPUSH
17075: CALL_OW 255
17079: PUSH
17080: LD_INT 1
17082: EQUAL
17083: IFFALSE 17093
// artifact_get := true ;
17085: LD_ADDR_EXP 13
17089: PUSH
17090: LD_INT 1
17092: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17093: LD_VAR 0 1
17097: PPUSH
17098: CALL_OW 255
17102: PUSH
17103: LD_INT 2
17105: EQUAL
17106: IFFALSE 17124
// begin artifact_get := false ;
17108: LD_ADDR_EXP 13
17112: PUSH
17113: LD_INT 0
17115: ST_TO_ADDR
// artifact_stolen := true ;
17116: LD_ADDR_EXP 12
17120: PUSH
17121: LD_INT 1
17123: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17124: LD_ADDR_EXP 14
17128: PUSH
17129: LD_INT 1
17131: ST_TO_ADDR
// end ;
17132: PPOPN 2
17134: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17135: LD_ADDR_EXP 14
17139: PUSH
17140: LD_INT 0
17142: ST_TO_ADDR
// end ;
17143: PPOPN 2
17145: END
// on UnitDestroyed ( un ) do begin if un = JMM then
17146: LD_VAR 0 1
17150: PUSH
17151: LD_EXP 21
17155: EQUAL
17156: IFFALSE 17167
// begin YouLost ( JMM ) ;
17158: LD_STRING JMM
17160: PPUSH
17161: CALL_OW 104
// exit ;
17165: GO 17299
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17167: LD_VAR 0 1
17171: PUSH
17172: LD_INT 22
17174: PUSH
17175: LD_INT 1
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: PUSH
17182: LD_INT 21
17184: PUSH
17185: LD_INT 1
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: PUSH
17192: LD_INT 2
17194: PUSH
17195: LD_INT 25
17197: PUSH
17198: LD_INT 1
17200: PUSH
17201: EMPTY
17202: LIST
17203: LIST
17204: PUSH
17205: LD_INT 25
17207: PUSH
17208: LD_INT 2
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: PUSH
17215: LD_INT 25
17217: PUSH
17218: LD_INT 3
17220: PUSH
17221: EMPTY
17222: LIST
17223: LIST
17224: PUSH
17225: LD_INT 25
17227: PUSH
17228: LD_INT 4
17230: PUSH
17231: EMPTY
17232: LIST
17233: LIST
17234: PUSH
17235: LD_INT 25
17237: PUSH
17238: LD_INT 5
17240: PUSH
17241: EMPTY
17242: LIST
17243: LIST
17244: PUSH
17245: LD_INT 25
17247: PUSH
17248: LD_INT 8
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PUSH
17255: EMPTY
17256: LIST
17257: LIST
17258: LIST
17259: LIST
17260: LIST
17261: LIST
17262: LIST
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: LIST
17268: PPUSH
17269: CALL_OW 69
17273: IN
17274: IFFALSE 17290
// loses_counter := loses_counter + 1 ;
17276: LD_ADDR_EXP 17
17280: PUSH
17281: LD_EXP 17
17285: PUSH
17286: LD_INT 1
17288: PLUS
17289: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17290: LD_VAR 0 1
17294: PPUSH
17295: CALL 45008 0 1
// end ;
17299: PPOPN 1
17301: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17302: LD_VAR 0 1
17306: PPUSH
17307: LD_VAR 0 2
17311: PPUSH
17312: CALL 47342 0 2
// end ;
17316: PPOPN 2
17318: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17319: LD_VAR 0 1
17323: PPUSH
17324: CALL 46651 0 1
// end ;
17328: PPOPN 1
17330: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17331: LD_VAR 0 1
17335: PPUSH
17336: LD_VAR 0 2
17340: PPUSH
17341: LD_VAR 0 3
17345: PPUSH
17346: LD_VAR 0 4
17350: PPUSH
17351: LD_VAR 0 5
17355: PPUSH
17356: CALL 44324 0 5
// end ;
17360: PPOPN 5
17362: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
17363: LD_VAR 0 1
17367: PPUSH
17368: CALL_OW 248
17372: PUSH
17373: LD_INT 1
17375: EQUAL
17376: IFFALSE 17386
// am_veh_consturcted := true ;
17378: LD_ADDR_EXP 20
17382: PUSH
17383: LD_INT 1
17385: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17386: LD_VAR 0 1
17390: PPUSH
17391: LD_VAR 0 2
17395: PPUSH
17396: CALL 43914 0 2
// end ;
17400: PPOPN 2
17402: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17403: LD_VAR 0 1
17407: PPUSH
17408: CALL_OW 247
17412: PUSH
17413: LD_INT 2
17415: EQUAL
17416: IFFALSE 17420
// exit ;
17418: GO 17437
// if not kamikazed then
17420: LD_EXP 11
17424: NOT
17425: IFFALSE 17437
// kamikazed := unit ;
17427: LD_ADDR_EXP 11
17431: PUSH
17432: LD_VAR 0 1
17436: ST_TO_ADDR
// end ;
17437: PPOPN 1
17439: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17440: LD_INT 0
17442: PPUSH
17443: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17444: LD_VAR 0 1
17448: PPUSH
17449: LD_VAR 0 2
17453: PPUSH
17454: LD_VAR 0 3
17458: PPUSH
17459: LD_VAR 0 4
17463: PPUSH
17464: CALL 43752 0 4
// end ;
17468: PPOPN 6
17470: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17471: LD_VAR 0 1
17475: PPUSH
17476: LD_VAR 0 2
17480: PPUSH
17481: LD_VAR 0 3
17485: PPUSH
17486: CALL 43527 0 3
// end ;
17490: PPOPN 3
17492: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17493: LD_VAR 0 1
17497: PPUSH
17498: LD_VAR 0 2
17502: PPUSH
17503: CALL 44704 0 2
// end ;
17507: PPOPN 2
17509: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17510: LD_VAR 0 1
17514: PPUSH
17515: LD_VAR 0 2
17519: PPUSH
17520: CALL 43221 0 2
// end ;
17524: PPOPN 2
17526: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17527: LD_VAR 0 1
17531: PPUSH
17532: LD_VAR 0 2
17536: PPUSH
17537: CALL 43412 0 2
// end ;
17541: PPOPN 2
17543: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17544: LD_VAR 0 1
17548: PPUSH
17549: CALL 46410 0 1
// end ;
17553: PPOPN 1
17555: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17556: LD_VAR 0 1
17560: PPUSH
17561: LD_VAR 0 2
17565: PPUSH
17566: CALL 47603 0 2
// end ;
17570: PPOPN 2
17572: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17573: LD_VAR 0 1
17577: PPUSH
17578: LD_VAR 0 2
17582: PPUSH
17583: LD_VAR 0 3
17587: PPUSH
17588: LD_VAR 0 4
17592: PPUSH
17593: CALL 47819 0 4
// end ;
17597: PPOPN 4
17599: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17600: LD_VAR 0 1
17604: PPUSH
17605: CALL 99033 0 1
// end ; end_of_file
17609: PPOPN 1
17611: END
// every 0 0$1 trigger game do
17612: LD_EXP 2
17616: IFFALSE 17646
17618: GO 17620
17620: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17621: LD_INT 7
17623: PUSH
17624: LD_INT 6
17626: PUSH
17627: LD_INT 4
17629: PUSH
17630: LD_INT 6
17632: PUSH
17633: EMPTY
17634: LIST
17635: LIST
17636: LIST
17637: LIST
17638: PPUSH
17639: LD_INT 1750
17641: PPUSH
17642: CALL 17647 0 2
17646: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17647: LD_INT 0
17649: PPUSH
17650: PPUSH
17651: PPUSH
// if not areas then
17652: LD_VAR 0 1
17656: NOT
17657: IFFALSE 17661
// exit ;
17659: GO 17791
// repeat wait ( time ) ;
17661: LD_VAR 0 2
17665: PPUSH
17666: CALL_OW 67
// for i in areas do
17670: LD_ADDR_VAR 0 4
17674: PUSH
17675: LD_VAR 0 1
17679: PUSH
17680: FOR_IN
17681: IFFALSE 17750
// begin p := rand ( 1 , 90 ) ;
17683: LD_ADDR_VAR 0 5
17687: PUSH
17688: LD_INT 1
17690: PPUSH
17691: LD_INT 90
17693: PPUSH
17694: CALL_OW 12
17698: ST_TO_ADDR
// if Prob ( p ) then
17699: LD_VAR 0 5
17703: PPUSH
17704: CALL_OW 13
17708: IFFALSE 17748
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17710: LD_INT 2
17712: PPUSH
17713: LD_INT 5
17715: PPUSH
17716: CALL_OW 12
17720: PPUSH
17721: LD_VAR 0 4
17725: PPUSH
17726: LD_INT 1
17728: PPUSH
17729: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17733: LD_INT 735
17735: PPUSH
17736: LD_INT 1295
17738: PPUSH
17739: CALL_OW 12
17743: PPUSH
17744: CALL_OW 67
// end ; end ;
17748: GO 17680
17750: POP
17751: POP
// time := time + 0 0$3 ;
17752: LD_ADDR_VAR 0 2
17756: PUSH
17757: LD_VAR 0 2
17761: PUSH
17762: LD_INT 105
17764: PLUS
17765: ST_TO_ADDR
// if time > 6 6$00 then
17766: LD_VAR 0 2
17770: PUSH
17771: LD_INT 12600
17773: GREATER
17774: IFFALSE 17784
// time := 0 0$40 ;
17776: LD_ADDR_VAR 0 2
17780: PUSH
17781: LD_INT 1400
17783: ST_TO_ADDR
// until not game ;
17784: LD_EXP 2
17788: NOT
17789: IFFALSE 17661
// end ;
17791: LD_VAR 0 3
17795: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 ] [ Difficulty ] do
17796: LD_OWVAR 1
17800: PUSH
17801: LD_INT 84000
17803: PUSH
17804: LD_INT 73500
17806: PUSH
17807: LD_INT 63000
17809: PUSH
17810: EMPTY
17811: LIST
17812: LIST
17813: LIST
17814: PUSH
17815: LD_OWVAR 67
17819: ARRAY
17820: LESS
17821: IFFALSE 17848
17823: GO 17825
17825: DISABLE
// begin enable ;
17826: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17827: LD_INT 1
17829: PPUSH
17830: LD_INT 5
17832: PPUSH
17833: CALL_OW 12
17837: PPUSH
17838: LD_INT 7
17840: PPUSH
17841: LD_INT 1
17843: PPUSH
17844: CALL_OW 55
// end ; end_of_file
17848: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
17849: LD_INT 0
17851: PPUSH
17852: PPUSH
// skirmish := false ;
17853: LD_ADDR_EXP 48
17857: PUSH
17858: LD_INT 0
17860: ST_TO_ADDR
// debug_mc := false ;
17861: LD_ADDR_EXP 49
17865: PUSH
17866: LD_INT 0
17868: ST_TO_ADDR
// mc_bases := [ ] ;
17869: LD_ADDR_EXP 50
17873: PUSH
17874: EMPTY
17875: ST_TO_ADDR
// mc_sides := [ ] ;
17876: LD_ADDR_EXP 76
17880: PUSH
17881: EMPTY
17882: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17883: LD_ADDR_EXP 51
17887: PUSH
17888: EMPTY
17889: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17890: LD_ADDR_EXP 52
17894: PUSH
17895: EMPTY
17896: ST_TO_ADDR
// mc_need_heal := [ ] ;
17897: LD_ADDR_EXP 53
17901: PUSH
17902: EMPTY
17903: ST_TO_ADDR
// mc_healers := [ ] ;
17904: LD_ADDR_EXP 54
17908: PUSH
17909: EMPTY
17910: ST_TO_ADDR
// mc_build_list := [ ] ;
17911: LD_ADDR_EXP 55
17915: PUSH
17916: EMPTY
17917: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17918: LD_ADDR_EXP 82
17922: PUSH
17923: EMPTY
17924: ST_TO_ADDR
// mc_builders := [ ] ;
17925: LD_ADDR_EXP 56
17929: PUSH
17930: EMPTY
17931: ST_TO_ADDR
// mc_construct_list := [ ] ;
17932: LD_ADDR_EXP 57
17936: PUSH
17937: EMPTY
17938: ST_TO_ADDR
// mc_turret_list := [ ] ;
17939: LD_ADDR_EXP 58
17943: PUSH
17944: EMPTY
17945: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17946: LD_ADDR_EXP 59
17950: PUSH
17951: EMPTY
17952: ST_TO_ADDR
// mc_miners := [ ] ;
17953: LD_ADDR_EXP 64
17957: PUSH
17958: EMPTY
17959: ST_TO_ADDR
// mc_mines := [ ] ;
17960: LD_ADDR_EXP 63
17964: PUSH
17965: EMPTY
17966: ST_TO_ADDR
// mc_minefields := [ ] ;
17967: LD_ADDR_EXP 65
17971: PUSH
17972: EMPTY
17973: ST_TO_ADDR
// mc_crates := [ ] ;
17974: LD_ADDR_EXP 66
17978: PUSH
17979: EMPTY
17980: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17981: LD_ADDR_EXP 67
17985: PUSH
17986: EMPTY
17987: ST_TO_ADDR
// mc_crates_area := [ ] ;
17988: LD_ADDR_EXP 68
17992: PUSH
17993: EMPTY
17994: ST_TO_ADDR
// mc_vehicles := [ ] ;
17995: LD_ADDR_EXP 69
17999: PUSH
18000: EMPTY
18001: ST_TO_ADDR
// mc_attack := [ ] ;
18002: LD_ADDR_EXP 70
18006: PUSH
18007: EMPTY
18008: ST_TO_ADDR
// mc_produce := [ ] ;
18009: LD_ADDR_EXP 71
18013: PUSH
18014: EMPTY
18015: ST_TO_ADDR
// mc_defender := [ ] ;
18016: LD_ADDR_EXP 72
18020: PUSH
18021: EMPTY
18022: ST_TO_ADDR
// mc_parking := [ ] ;
18023: LD_ADDR_EXP 74
18027: PUSH
18028: EMPTY
18029: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18030: LD_ADDR_EXP 60
18034: PUSH
18035: EMPTY
18036: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18037: LD_ADDR_EXP 62
18041: PUSH
18042: EMPTY
18043: ST_TO_ADDR
// mc_scan := [ ] ;
18044: LD_ADDR_EXP 73
18048: PUSH
18049: EMPTY
18050: ST_TO_ADDR
// mc_scan_area := [ ] ;
18051: LD_ADDR_EXP 75
18055: PUSH
18056: EMPTY
18057: ST_TO_ADDR
// mc_tech := [ ] ;
18058: LD_ADDR_EXP 77
18062: PUSH
18063: EMPTY
18064: ST_TO_ADDR
// mc_class := [ ] ;
18065: LD_ADDR_EXP 91
18069: PUSH
18070: EMPTY
18071: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18072: LD_ADDR_EXP 92
18076: PUSH
18077: EMPTY
18078: ST_TO_ADDR
// end ;
18079: LD_VAR 0 1
18083: RET
// export function MC_Kill ( base ) ; begin
18084: LD_INT 0
18086: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18087: LD_ADDR_EXP 50
18091: PUSH
18092: LD_EXP 50
18096: PPUSH
18097: LD_VAR 0 1
18101: PPUSH
18102: EMPTY
18103: PPUSH
18104: CALL_OW 1
18108: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18109: LD_ADDR_EXP 51
18113: PUSH
18114: LD_EXP 51
18118: PPUSH
18119: LD_VAR 0 1
18123: PPUSH
18124: EMPTY
18125: PPUSH
18126: CALL_OW 1
18130: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18131: LD_ADDR_EXP 52
18135: PUSH
18136: LD_EXP 52
18140: PPUSH
18141: LD_VAR 0 1
18145: PPUSH
18146: EMPTY
18147: PPUSH
18148: CALL_OW 1
18152: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18153: LD_ADDR_EXP 53
18157: PUSH
18158: LD_EXP 53
18162: PPUSH
18163: LD_VAR 0 1
18167: PPUSH
18168: EMPTY
18169: PPUSH
18170: CALL_OW 1
18174: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18175: LD_ADDR_EXP 54
18179: PUSH
18180: LD_EXP 54
18184: PPUSH
18185: LD_VAR 0 1
18189: PPUSH
18190: EMPTY
18191: PPUSH
18192: CALL_OW 1
18196: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18197: LD_ADDR_EXP 55
18201: PUSH
18202: LD_EXP 55
18206: PPUSH
18207: LD_VAR 0 1
18211: PPUSH
18212: EMPTY
18213: PPUSH
18214: CALL_OW 1
18218: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18219: LD_ADDR_EXP 56
18223: PUSH
18224: LD_EXP 56
18228: PPUSH
18229: LD_VAR 0 1
18233: PPUSH
18234: EMPTY
18235: PPUSH
18236: CALL_OW 1
18240: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18241: LD_ADDR_EXP 57
18245: PUSH
18246: LD_EXP 57
18250: PPUSH
18251: LD_VAR 0 1
18255: PPUSH
18256: EMPTY
18257: PPUSH
18258: CALL_OW 1
18262: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18263: LD_ADDR_EXP 58
18267: PUSH
18268: LD_EXP 58
18272: PPUSH
18273: LD_VAR 0 1
18277: PPUSH
18278: EMPTY
18279: PPUSH
18280: CALL_OW 1
18284: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18285: LD_ADDR_EXP 59
18289: PUSH
18290: LD_EXP 59
18294: PPUSH
18295: LD_VAR 0 1
18299: PPUSH
18300: EMPTY
18301: PPUSH
18302: CALL_OW 1
18306: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18307: LD_ADDR_EXP 60
18311: PUSH
18312: LD_EXP 60
18316: PPUSH
18317: LD_VAR 0 1
18321: PPUSH
18322: EMPTY
18323: PPUSH
18324: CALL_OW 1
18328: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18329: LD_ADDR_EXP 61
18333: PUSH
18334: LD_EXP 61
18338: PPUSH
18339: LD_VAR 0 1
18343: PPUSH
18344: LD_INT 0
18346: PPUSH
18347: CALL_OW 1
18351: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18352: LD_ADDR_EXP 62
18356: PUSH
18357: LD_EXP 62
18361: PPUSH
18362: LD_VAR 0 1
18366: PPUSH
18367: EMPTY
18368: PPUSH
18369: CALL_OW 1
18373: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18374: LD_ADDR_EXP 63
18378: PUSH
18379: LD_EXP 63
18383: PPUSH
18384: LD_VAR 0 1
18388: PPUSH
18389: EMPTY
18390: PPUSH
18391: CALL_OW 1
18395: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18396: LD_ADDR_EXP 64
18400: PUSH
18401: LD_EXP 64
18405: PPUSH
18406: LD_VAR 0 1
18410: PPUSH
18411: EMPTY
18412: PPUSH
18413: CALL_OW 1
18417: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18418: LD_ADDR_EXP 65
18422: PUSH
18423: LD_EXP 65
18427: PPUSH
18428: LD_VAR 0 1
18432: PPUSH
18433: EMPTY
18434: PPUSH
18435: CALL_OW 1
18439: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18440: LD_ADDR_EXP 66
18444: PUSH
18445: LD_EXP 66
18449: PPUSH
18450: LD_VAR 0 1
18454: PPUSH
18455: EMPTY
18456: PPUSH
18457: CALL_OW 1
18461: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18462: LD_ADDR_EXP 67
18466: PUSH
18467: LD_EXP 67
18471: PPUSH
18472: LD_VAR 0 1
18476: PPUSH
18477: EMPTY
18478: PPUSH
18479: CALL_OW 1
18483: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18484: LD_ADDR_EXP 68
18488: PUSH
18489: LD_EXP 68
18493: PPUSH
18494: LD_VAR 0 1
18498: PPUSH
18499: EMPTY
18500: PPUSH
18501: CALL_OW 1
18505: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18506: LD_ADDR_EXP 69
18510: PUSH
18511: LD_EXP 69
18515: PPUSH
18516: LD_VAR 0 1
18520: PPUSH
18521: EMPTY
18522: PPUSH
18523: CALL_OW 1
18527: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18528: LD_ADDR_EXP 70
18532: PUSH
18533: LD_EXP 70
18537: PPUSH
18538: LD_VAR 0 1
18542: PPUSH
18543: EMPTY
18544: PPUSH
18545: CALL_OW 1
18549: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18550: LD_ADDR_EXP 71
18554: PUSH
18555: LD_EXP 71
18559: PPUSH
18560: LD_VAR 0 1
18564: PPUSH
18565: EMPTY
18566: PPUSH
18567: CALL_OW 1
18571: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18572: LD_ADDR_EXP 72
18576: PUSH
18577: LD_EXP 72
18581: PPUSH
18582: LD_VAR 0 1
18586: PPUSH
18587: EMPTY
18588: PPUSH
18589: CALL_OW 1
18593: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18594: LD_ADDR_EXP 73
18598: PUSH
18599: LD_EXP 73
18603: PPUSH
18604: LD_VAR 0 1
18608: PPUSH
18609: EMPTY
18610: PPUSH
18611: CALL_OW 1
18615: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18616: LD_ADDR_EXP 74
18620: PUSH
18621: LD_EXP 74
18625: PPUSH
18626: LD_VAR 0 1
18630: PPUSH
18631: EMPTY
18632: PPUSH
18633: CALL_OW 1
18637: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18638: LD_ADDR_EXP 75
18642: PUSH
18643: LD_EXP 75
18647: PPUSH
18648: LD_VAR 0 1
18652: PPUSH
18653: EMPTY
18654: PPUSH
18655: CALL_OW 1
18659: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18660: LD_ADDR_EXP 77
18664: PUSH
18665: LD_EXP 77
18669: PPUSH
18670: LD_VAR 0 1
18674: PPUSH
18675: EMPTY
18676: PPUSH
18677: CALL_OW 1
18681: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18682: LD_ADDR_EXP 79
18686: PUSH
18687: LD_EXP 79
18691: PPUSH
18692: LD_VAR 0 1
18696: PPUSH
18697: EMPTY
18698: PPUSH
18699: CALL_OW 1
18703: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18704: LD_ADDR_EXP 80
18708: PUSH
18709: LD_EXP 80
18713: PPUSH
18714: LD_VAR 0 1
18718: PPUSH
18719: EMPTY
18720: PPUSH
18721: CALL_OW 1
18725: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18726: LD_ADDR_EXP 81
18730: PUSH
18731: LD_EXP 81
18735: PPUSH
18736: LD_VAR 0 1
18740: PPUSH
18741: EMPTY
18742: PPUSH
18743: CALL_OW 1
18747: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18748: LD_ADDR_EXP 82
18752: PUSH
18753: LD_EXP 82
18757: PPUSH
18758: LD_VAR 0 1
18762: PPUSH
18763: EMPTY
18764: PPUSH
18765: CALL_OW 1
18769: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18770: LD_ADDR_EXP 83
18774: PUSH
18775: LD_EXP 83
18779: PPUSH
18780: LD_VAR 0 1
18784: PPUSH
18785: EMPTY
18786: PPUSH
18787: CALL_OW 1
18791: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18792: LD_ADDR_EXP 84
18796: PUSH
18797: LD_EXP 84
18801: PPUSH
18802: LD_VAR 0 1
18806: PPUSH
18807: EMPTY
18808: PPUSH
18809: CALL_OW 1
18813: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18814: LD_ADDR_EXP 85
18818: PUSH
18819: LD_EXP 85
18823: PPUSH
18824: LD_VAR 0 1
18828: PPUSH
18829: EMPTY
18830: PPUSH
18831: CALL_OW 1
18835: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18836: LD_ADDR_EXP 86
18840: PUSH
18841: LD_EXP 86
18845: PPUSH
18846: LD_VAR 0 1
18850: PPUSH
18851: EMPTY
18852: PPUSH
18853: CALL_OW 1
18857: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18858: LD_ADDR_EXP 87
18862: PUSH
18863: LD_EXP 87
18867: PPUSH
18868: LD_VAR 0 1
18872: PPUSH
18873: EMPTY
18874: PPUSH
18875: CALL_OW 1
18879: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18880: LD_ADDR_EXP 88
18884: PUSH
18885: LD_EXP 88
18889: PPUSH
18890: LD_VAR 0 1
18894: PPUSH
18895: EMPTY
18896: PPUSH
18897: CALL_OW 1
18901: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18902: LD_ADDR_EXP 89
18906: PUSH
18907: LD_EXP 89
18911: PPUSH
18912: LD_VAR 0 1
18916: PPUSH
18917: EMPTY
18918: PPUSH
18919: CALL_OW 1
18923: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18924: LD_ADDR_EXP 90
18928: PUSH
18929: LD_EXP 90
18933: PPUSH
18934: LD_VAR 0 1
18938: PPUSH
18939: EMPTY
18940: PPUSH
18941: CALL_OW 1
18945: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18946: LD_ADDR_EXP 91
18950: PUSH
18951: LD_EXP 91
18955: PPUSH
18956: LD_VAR 0 1
18960: PPUSH
18961: EMPTY
18962: PPUSH
18963: CALL_OW 1
18967: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18968: LD_ADDR_EXP 92
18972: PUSH
18973: LD_EXP 92
18977: PPUSH
18978: LD_VAR 0 1
18982: PPUSH
18983: LD_INT 0
18985: PPUSH
18986: CALL_OW 1
18990: ST_TO_ADDR
// end ;
18991: LD_VAR 0 2
18995: RET
// export function MC_Add ( side , units ) ; var base ; begin
18996: LD_INT 0
18998: PPUSH
18999: PPUSH
// base := mc_bases + 1 ;
19000: LD_ADDR_VAR 0 4
19004: PUSH
19005: LD_EXP 50
19009: PUSH
19010: LD_INT 1
19012: PLUS
19013: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19014: LD_ADDR_EXP 76
19018: PUSH
19019: LD_EXP 76
19023: PPUSH
19024: LD_VAR 0 4
19028: PPUSH
19029: LD_VAR 0 1
19033: PPUSH
19034: CALL_OW 1
19038: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19039: LD_ADDR_EXP 50
19043: PUSH
19044: LD_EXP 50
19048: PPUSH
19049: LD_VAR 0 4
19053: PPUSH
19054: LD_VAR 0 2
19058: PPUSH
19059: CALL_OW 1
19063: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19064: LD_ADDR_EXP 51
19068: PUSH
19069: LD_EXP 51
19073: PPUSH
19074: LD_VAR 0 4
19078: PPUSH
19079: EMPTY
19080: PPUSH
19081: CALL_OW 1
19085: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19086: LD_ADDR_EXP 52
19090: PUSH
19091: LD_EXP 52
19095: PPUSH
19096: LD_VAR 0 4
19100: PPUSH
19101: EMPTY
19102: PPUSH
19103: CALL_OW 1
19107: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19108: LD_ADDR_EXP 53
19112: PUSH
19113: LD_EXP 53
19117: PPUSH
19118: LD_VAR 0 4
19122: PPUSH
19123: EMPTY
19124: PPUSH
19125: CALL_OW 1
19129: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19130: LD_ADDR_EXP 54
19134: PUSH
19135: LD_EXP 54
19139: PPUSH
19140: LD_VAR 0 4
19144: PPUSH
19145: EMPTY
19146: PPUSH
19147: CALL_OW 1
19151: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19152: LD_ADDR_EXP 55
19156: PUSH
19157: LD_EXP 55
19161: PPUSH
19162: LD_VAR 0 4
19166: PPUSH
19167: EMPTY
19168: PPUSH
19169: CALL_OW 1
19173: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19174: LD_ADDR_EXP 56
19178: PUSH
19179: LD_EXP 56
19183: PPUSH
19184: LD_VAR 0 4
19188: PPUSH
19189: EMPTY
19190: PPUSH
19191: CALL_OW 1
19195: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19196: LD_ADDR_EXP 57
19200: PUSH
19201: LD_EXP 57
19205: PPUSH
19206: LD_VAR 0 4
19210: PPUSH
19211: EMPTY
19212: PPUSH
19213: CALL_OW 1
19217: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19218: LD_ADDR_EXP 58
19222: PUSH
19223: LD_EXP 58
19227: PPUSH
19228: LD_VAR 0 4
19232: PPUSH
19233: EMPTY
19234: PPUSH
19235: CALL_OW 1
19239: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19240: LD_ADDR_EXP 59
19244: PUSH
19245: LD_EXP 59
19249: PPUSH
19250: LD_VAR 0 4
19254: PPUSH
19255: EMPTY
19256: PPUSH
19257: CALL_OW 1
19261: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19262: LD_ADDR_EXP 60
19266: PUSH
19267: LD_EXP 60
19271: PPUSH
19272: LD_VAR 0 4
19276: PPUSH
19277: EMPTY
19278: PPUSH
19279: CALL_OW 1
19283: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19284: LD_ADDR_EXP 61
19288: PUSH
19289: LD_EXP 61
19293: PPUSH
19294: LD_VAR 0 4
19298: PPUSH
19299: LD_INT 0
19301: PPUSH
19302: CALL_OW 1
19306: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19307: LD_ADDR_EXP 62
19311: PUSH
19312: LD_EXP 62
19316: PPUSH
19317: LD_VAR 0 4
19321: PPUSH
19322: EMPTY
19323: PPUSH
19324: CALL_OW 1
19328: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19329: LD_ADDR_EXP 63
19333: PUSH
19334: LD_EXP 63
19338: PPUSH
19339: LD_VAR 0 4
19343: PPUSH
19344: EMPTY
19345: PPUSH
19346: CALL_OW 1
19350: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19351: LD_ADDR_EXP 64
19355: PUSH
19356: LD_EXP 64
19360: PPUSH
19361: LD_VAR 0 4
19365: PPUSH
19366: EMPTY
19367: PPUSH
19368: CALL_OW 1
19372: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19373: LD_ADDR_EXP 65
19377: PUSH
19378: LD_EXP 65
19382: PPUSH
19383: LD_VAR 0 4
19387: PPUSH
19388: EMPTY
19389: PPUSH
19390: CALL_OW 1
19394: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19395: LD_ADDR_EXP 66
19399: PUSH
19400: LD_EXP 66
19404: PPUSH
19405: LD_VAR 0 4
19409: PPUSH
19410: EMPTY
19411: PPUSH
19412: CALL_OW 1
19416: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19417: LD_ADDR_EXP 67
19421: PUSH
19422: LD_EXP 67
19426: PPUSH
19427: LD_VAR 0 4
19431: PPUSH
19432: EMPTY
19433: PPUSH
19434: CALL_OW 1
19438: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19439: LD_ADDR_EXP 68
19443: PUSH
19444: LD_EXP 68
19448: PPUSH
19449: LD_VAR 0 4
19453: PPUSH
19454: EMPTY
19455: PPUSH
19456: CALL_OW 1
19460: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19461: LD_ADDR_EXP 69
19465: PUSH
19466: LD_EXP 69
19470: PPUSH
19471: LD_VAR 0 4
19475: PPUSH
19476: EMPTY
19477: PPUSH
19478: CALL_OW 1
19482: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19483: LD_ADDR_EXP 70
19487: PUSH
19488: LD_EXP 70
19492: PPUSH
19493: LD_VAR 0 4
19497: PPUSH
19498: EMPTY
19499: PPUSH
19500: CALL_OW 1
19504: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19505: LD_ADDR_EXP 71
19509: PUSH
19510: LD_EXP 71
19514: PPUSH
19515: LD_VAR 0 4
19519: PPUSH
19520: EMPTY
19521: PPUSH
19522: CALL_OW 1
19526: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19527: LD_ADDR_EXP 72
19531: PUSH
19532: LD_EXP 72
19536: PPUSH
19537: LD_VAR 0 4
19541: PPUSH
19542: EMPTY
19543: PPUSH
19544: CALL_OW 1
19548: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19549: LD_ADDR_EXP 73
19553: PUSH
19554: LD_EXP 73
19558: PPUSH
19559: LD_VAR 0 4
19563: PPUSH
19564: EMPTY
19565: PPUSH
19566: CALL_OW 1
19570: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19571: LD_ADDR_EXP 74
19575: PUSH
19576: LD_EXP 74
19580: PPUSH
19581: LD_VAR 0 4
19585: PPUSH
19586: EMPTY
19587: PPUSH
19588: CALL_OW 1
19592: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19593: LD_ADDR_EXP 75
19597: PUSH
19598: LD_EXP 75
19602: PPUSH
19603: LD_VAR 0 4
19607: PPUSH
19608: EMPTY
19609: PPUSH
19610: CALL_OW 1
19614: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19615: LD_ADDR_EXP 77
19619: PUSH
19620: LD_EXP 77
19624: PPUSH
19625: LD_VAR 0 4
19629: PPUSH
19630: EMPTY
19631: PPUSH
19632: CALL_OW 1
19636: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19637: LD_ADDR_EXP 79
19641: PUSH
19642: LD_EXP 79
19646: PPUSH
19647: LD_VAR 0 4
19651: PPUSH
19652: EMPTY
19653: PPUSH
19654: CALL_OW 1
19658: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19659: LD_ADDR_EXP 80
19663: PUSH
19664: LD_EXP 80
19668: PPUSH
19669: LD_VAR 0 4
19673: PPUSH
19674: EMPTY
19675: PPUSH
19676: CALL_OW 1
19680: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19681: LD_ADDR_EXP 81
19685: PUSH
19686: LD_EXP 81
19690: PPUSH
19691: LD_VAR 0 4
19695: PPUSH
19696: EMPTY
19697: PPUSH
19698: CALL_OW 1
19702: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19703: LD_ADDR_EXP 82
19707: PUSH
19708: LD_EXP 82
19712: PPUSH
19713: LD_VAR 0 4
19717: PPUSH
19718: EMPTY
19719: PPUSH
19720: CALL_OW 1
19724: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19725: LD_ADDR_EXP 83
19729: PUSH
19730: LD_EXP 83
19734: PPUSH
19735: LD_VAR 0 4
19739: PPUSH
19740: EMPTY
19741: PPUSH
19742: CALL_OW 1
19746: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19747: LD_ADDR_EXP 84
19751: PUSH
19752: LD_EXP 84
19756: PPUSH
19757: LD_VAR 0 4
19761: PPUSH
19762: EMPTY
19763: PPUSH
19764: CALL_OW 1
19768: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19769: LD_ADDR_EXP 85
19773: PUSH
19774: LD_EXP 85
19778: PPUSH
19779: LD_VAR 0 4
19783: PPUSH
19784: EMPTY
19785: PPUSH
19786: CALL_OW 1
19790: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19791: LD_ADDR_EXP 86
19795: PUSH
19796: LD_EXP 86
19800: PPUSH
19801: LD_VAR 0 4
19805: PPUSH
19806: EMPTY
19807: PPUSH
19808: CALL_OW 1
19812: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19813: LD_ADDR_EXP 87
19817: PUSH
19818: LD_EXP 87
19822: PPUSH
19823: LD_VAR 0 4
19827: PPUSH
19828: EMPTY
19829: PPUSH
19830: CALL_OW 1
19834: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19835: LD_ADDR_EXP 88
19839: PUSH
19840: LD_EXP 88
19844: PPUSH
19845: LD_VAR 0 4
19849: PPUSH
19850: EMPTY
19851: PPUSH
19852: CALL_OW 1
19856: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19857: LD_ADDR_EXP 89
19861: PUSH
19862: LD_EXP 89
19866: PPUSH
19867: LD_VAR 0 4
19871: PPUSH
19872: EMPTY
19873: PPUSH
19874: CALL_OW 1
19878: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19879: LD_ADDR_EXP 90
19883: PUSH
19884: LD_EXP 90
19888: PPUSH
19889: LD_VAR 0 4
19893: PPUSH
19894: EMPTY
19895: PPUSH
19896: CALL_OW 1
19900: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19901: LD_ADDR_EXP 91
19905: PUSH
19906: LD_EXP 91
19910: PPUSH
19911: LD_VAR 0 4
19915: PPUSH
19916: EMPTY
19917: PPUSH
19918: CALL_OW 1
19922: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19923: LD_ADDR_EXP 92
19927: PUSH
19928: LD_EXP 92
19932: PPUSH
19933: LD_VAR 0 4
19937: PPUSH
19938: LD_INT 0
19940: PPUSH
19941: CALL_OW 1
19945: ST_TO_ADDR
// result := base ;
19946: LD_ADDR_VAR 0 3
19950: PUSH
19951: LD_VAR 0 4
19955: ST_TO_ADDR
// end ;
19956: LD_VAR 0 3
19960: RET
// export function MC_Start ( ) ; var i ; begin
19961: LD_INT 0
19963: PPUSH
19964: PPUSH
// for i = 1 to mc_bases do
19965: LD_ADDR_VAR 0 2
19969: PUSH
19970: DOUBLE
19971: LD_INT 1
19973: DEC
19974: ST_TO_ADDR
19975: LD_EXP 50
19979: PUSH
19980: FOR_TO
19981: IFFALSE 21058
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
19983: LD_ADDR_EXP 50
19987: PUSH
19988: LD_EXP 50
19992: PPUSH
19993: LD_VAR 0 2
19997: PPUSH
19998: LD_EXP 50
20002: PUSH
20003: LD_VAR 0 2
20007: ARRAY
20008: PUSH
20009: LD_INT 0
20011: DIFF
20012: PPUSH
20013: CALL_OW 1
20017: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20018: LD_ADDR_EXP 51
20022: PUSH
20023: LD_EXP 51
20027: PPUSH
20028: LD_VAR 0 2
20032: PPUSH
20033: EMPTY
20034: PPUSH
20035: CALL_OW 1
20039: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20040: LD_ADDR_EXP 52
20044: PUSH
20045: LD_EXP 52
20049: PPUSH
20050: LD_VAR 0 2
20054: PPUSH
20055: EMPTY
20056: PPUSH
20057: CALL_OW 1
20061: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20062: LD_ADDR_EXP 53
20066: PUSH
20067: LD_EXP 53
20071: PPUSH
20072: LD_VAR 0 2
20076: PPUSH
20077: EMPTY
20078: PPUSH
20079: CALL_OW 1
20083: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20084: LD_ADDR_EXP 54
20088: PUSH
20089: LD_EXP 54
20093: PPUSH
20094: LD_VAR 0 2
20098: PPUSH
20099: EMPTY
20100: PUSH
20101: EMPTY
20102: PUSH
20103: EMPTY
20104: LIST
20105: LIST
20106: PPUSH
20107: CALL_OW 1
20111: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20112: LD_ADDR_EXP 55
20116: PUSH
20117: LD_EXP 55
20121: PPUSH
20122: LD_VAR 0 2
20126: PPUSH
20127: EMPTY
20128: PPUSH
20129: CALL_OW 1
20133: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20134: LD_ADDR_EXP 82
20138: PUSH
20139: LD_EXP 82
20143: PPUSH
20144: LD_VAR 0 2
20148: PPUSH
20149: EMPTY
20150: PPUSH
20151: CALL_OW 1
20155: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20156: LD_ADDR_EXP 56
20160: PUSH
20161: LD_EXP 56
20165: PPUSH
20166: LD_VAR 0 2
20170: PPUSH
20171: EMPTY
20172: PPUSH
20173: CALL_OW 1
20177: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20178: LD_ADDR_EXP 57
20182: PUSH
20183: LD_EXP 57
20187: PPUSH
20188: LD_VAR 0 2
20192: PPUSH
20193: EMPTY
20194: PPUSH
20195: CALL_OW 1
20199: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20200: LD_ADDR_EXP 58
20204: PUSH
20205: LD_EXP 58
20209: PPUSH
20210: LD_VAR 0 2
20214: PPUSH
20215: LD_EXP 50
20219: PUSH
20220: LD_VAR 0 2
20224: ARRAY
20225: PPUSH
20226: LD_INT 2
20228: PUSH
20229: LD_INT 30
20231: PUSH
20232: LD_INT 32
20234: PUSH
20235: EMPTY
20236: LIST
20237: LIST
20238: PUSH
20239: LD_INT 30
20241: PUSH
20242: LD_INT 33
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: LIST
20253: PPUSH
20254: CALL_OW 72
20258: PPUSH
20259: CALL_OW 1
20263: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20264: LD_ADDR_EXP 59
20268: PUSH
20269: LD_EXP 59
20273: PPUSH
20274: LD_VAR 0 2
20278: PPUSH
20279: LD_EXP 50
20283: PUSH
20284: LD_VAR 0 2
20288: ARRAY
20289: PPUSH
20290: LD_INT 2
20292: PUSH
20293: LD_INT 30
20295: PUSH
20296: LD_INT 32
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: PUSH
20303: LD_INT 30
20305: PUSH
20306: LD_INT 31
20308: PUSH
20309: EMPTY
20310: LIST
20311: LIST
20312: PUSH
20313: EMPTY
20314: LIST
20315: LIST
20316: LIST
20317: PUSH
20318: LD_INT 58
20320: PUSH
20321: EMPTY
20322: LIST
20323: PUSH
20324: EMPTY
20325: LIST
20326: LIST
20327: PPUSH
20328: CALL_OW 72
20332: PPUSH
20333: CALL_OW 1
20337: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20338: LD_ADDR_EXP 60
20342: PUSH
20343: LD_EXP 60
20347: PPUSH
20348: LD_VAR 0 2
20352: PPUSH
20353: EMPTY
20354: PPUSH
20355: CALL_OW 1
20359: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20360: LD_ADDR_EXP 64
20364: PUSH
20365: LD_EXP 64
20369: PPUSH
20370: LD_VAR 0 2
20374: PPUSH
20375: EMPTY
20376: PPUSH
20377: CALL_OW 1
20381: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20382: LD_ADDR_EXP 63
20386: PUSH
20387: LD_EXP 63
20391: PPUSH
20392: LD_VAR 0 2
20396: PPUSH
20397: EMPTY
20398: PPUSH
20399: CALL_OW 1
20403: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20404: LD_ADDR_EXP 65
20408: PUSH
20409: LD_EXP 65
20413: PPUSH
20414: LD_VAR 0 2
20418: PPUSH
20419: EMPTY
20420: PPUSH
20421: CALL_OW 1
20425: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20426: LD_ADDR_EXP 66
20430: PUSH
20431: LD_EXP 66
20435: PPUSH
20436: LD_VAR 0 2
20440: PPUSH
20441: EMPTY
20442: PPUSH
20443: CALL_OW 1
20447: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20448: LD_ADDR_EXP 67
20452: PUSH
20453: LD_EXP 67
20457: PPUSH
20458: LD_VAR 0 2
20462: PPUSH
20463: EMPTY
20464: PPUSH
20465: CALL_OW 1
20469: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20470: LD_ADDR_EXP 68
20474: PUSH
20475: LD_EXP 68
20479: PPUSH
20480: LD_VAR 0 2
20484: PPUSH
20485: EMPTY
20486: PPUSH
20487: CALL_OW 1
20491: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20492: LD_ADDR_EXP 69
20496: PUSH
20497: LD_EXP 69
20501: PPUSH
20502: LD_VAR 0 2
20506: PPUSH
20507: EMPTY
20508: PPUSH
20509: CALL_OW 1
20513: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20514: LD_ADDR_EXP 70
20518: PUSH
20519: LD_EXP 70
20523: PPUSH
20524: LD_VAR 0 2
20528: PPUSH
20529: EMPTY
20530: PPUSH
20531: CALL_OW 1
20535: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20536: LD_ADDR_EXP 71
20540: PUSH
20541: LD_EXP 71
20545: PPUSH
20546: LD_VAR 0 2
20550: PPUSH
20551: EMPTY
20552: PPUSH
20553: CALL_OW 1
20557: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20558: LD_ADDR_EXP 72
20562: PUSH
20563: LD_EXP 72
20567: PPUSH
20568: LD_VAR 0 2
20572: PPUSH
20573: EMPTY
20574: PPUSH
20575: CALL_OW 1
20579: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20580: LD_ADDR_EXP 61
20584: PUSH
20585: LD_EXP 61
20589: PPUSH
20590: LD_VAR 0 2
20594: PPUSH
20595: LD_INT 0
20597: PPUSH
20598: CALL_OW 1
20602: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20603: LD_ADDR_EXP 74
20607: PUSH
20608: LD_EXP 74
20612: PPUSH
20613: LD_VAR 0 2
20617: PPUSH
20618: LD_INT 0
20620: PPUSH
20621: CALL_OW 1
20625: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20626: LD_ADDR_EXP 62
20630: PUSH
20631: LD_EXP 62
20635: PPUSH
20636: LD_VAR 0 2
20640: PPUSH
20641: EMPTY
20642: PPUSH
20643: CALL_OW 1
20647: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20648: LD_ADDR_EXP 73
20652: PUSH
20653: LD_EXP 73
20657: PPUSH
20658: LD_VAR 0 2
20662: PPUSH
20663: LD_INT 0
20665: PPUSH
20666: CALL_OW 1
20670: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20671: LD_ADDR_EXP 75
20675: PUSH
20676: LD_EXP 75
20680: PPUSH
20681: LD_VAR 0 2
20685: PPUSH
20686: EMPTY
20687: PPUSH
20688: CALL_OW 1
20692: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20693: LD_ADDR_EXP 78
20697: PUSH
20698: LD_EXP 78
20702: PPUSH
20703: LD_VAR 0 2
20707: PPUSH
20708: LD_INT 0
20710: PPUSH
20711: CALL_OW 1
20715: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20716: LD_ADDR_EXP 79
20720: PUSH
20721: LD_EXP 79
20725: PPUSH
20726: LD_VAR 0 2
20730: PPUSH
20731: EMPTY
20732: PPUSH
20733: CALL_OW 1
20737: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20738: LD_ADDR_EXP 80
20742: PUSH
20743: LD_EXP 80
20747: PPUSH
20748: LD_VAR 0 2
20752: PPUSH
20753: EMPTY
20754: PPUSH
20755: CALL_OW 1
20759: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20760: LD_ADDR_EXP 81
20764: PUSH
20765: LD_EXP 81
20769: PPUSH
20770: LD_VAR 0 2
20774: PPUSH
20775: EMPTY
20776: PPUSH
20777: CALL_OW 1
20781: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20782: LD_ADDR_EXP 83
20786: PUSH
20787: LD_EXP 83
20791: PPUSH
20792: LD_VAR 0 2
20796: PPUSH
20797: LD_EXP 50
20801: PUSH
20802: LD_VAR 0 2
20806: ARRAY
20807: PPUSH
20808: LD_INT 2
20810: PUSH
20811: LD_INT 30
20813: PUSH
20814: LD_INT 6
20816: PUSH
20817: EMPTY
20818: LIST
20819: LIST
20820: PUSH
20821: LD_INT 30
20823: PUSH
20824: LD_INT 7
20826: PUSH
20827: EMPTY
20828: LIST
20829: LIST
20830: PUSH
20831: LD_INT 30
20833: PUSH
20834: LD_INT 8
20836: PUSH
20837: EMPTY
20838: LIST
20839: LIST
20840: PUSH
20841: EMPTY
20842: LIST
20843: LIST
20844: LIST
20845: LIST
20846: PPUSH
20847: CALL_OW 72
20851: PPUSH
20852: CALL_OW 1
20856: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20857: LD_ADDR_EXP 84
20861: PUSH
20862: LD_EXP 84
20866: PPUSH
20867: LD_VAR 0 2
20871: PPUSH
20872: EMPTY
20873: PPUSH
20874: CALL_OW 1
20878: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20879: LD_ADDR_EXP 85
20883: PUSH
20884: LD_EXP 85
20888: PPUSH
20889: LD_VAR 0 2
20893: PPUSH
20894: EMPTY
20895: PPUSH
20896: CALL_OW 1
20900: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20901: LD_ADDR_EXP 86
20905: PUSH
20906: LD_EXP 86
20910: PPUSH
20911: LD_VAR 0 2
20915: PPUSH
20916: EMPTY
20917: PPUSH
20918: CALL_OW 1
20922: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20923: LD_ADDR_EXP 87
20927: PUSH
20928: LD_EXP 87
20932: PPUSH
20933: LD_VAR 0 2
20937: PPUSH
20938: EMPTY
20939: PPUSH
20940: CALL_OW 1
20944: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20945: LD_ADDR_EXP 88
20949: PUSH
20950: LD_EXP 88
20954: PPUSH
20955: LD_VAR 0 2
20959: PPUSH
20960: EMPTY
20961: PPUSH
20962: CALL_OW 1
20966: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
20967: LD_ADDR_EXP 89
20971: PUSH
20972: LD_EXP 89
20976: PPUSH
20977: LD_VAR 0 2
20981: PPUSH
20982: EMPTY
20983: PPUSH
20984: CALL_OW 1
20988: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
20989: LD_ADDR_EXP 90
20993: PUSH
20994: LD_EXP 90
20998: PPUSH
20999: LD_VAR 0 2
21003: PPUSH
21004: EMPTY
21005: PPUSH
21006: CALL_OW 1
21010: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21011: LD_ADDR_EXP 91
21015: PUSH
21016: LD_EXP 91
21020: PPUSH
21021: LD_VAR 0 2
21025: PPUSH
21026: EMPTY
21027: PPUSH
21028: CALL_OW 1
21032: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21033: LD_ADDR_EXP 92
21037: PUSH
21038: LD_EXP 92
21042: PPUSH
21043: LD_VAR 0 2
21047: PPUSH
21048: LD_INT 0
21050: PPUSH
21051: CALL_OW 1
21055: ST_TO_ADDR
// end ;
21056: GO 19980
21058: POP
21059: POP
// MC_InitSides ( ) ;
21060: CALL 21346 0 0
// MC_InitResearch ( ) ;
21064: CALL 21085 0 0
// CustomInitMacro ( ) ;
21068: CALL 304 0 0
// skirmish := true ;
21072: LD_ADDR_EXP 48
21076: PUSH
21077: LD_INT 1
21079: ST_TO_ADDR
// end ;
21080: LD_VAR 0 1
21084: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21085: LD_INT 0
21087: PPUSH
21088: PPUSH
21089: PPUSH
21090: PPUSH
21091: PPUSH
21092: PPUSH
// if not mc_bases then
21093: LD_EXP 50
21097: NOT
21098: IFFALSE 21102
// exit ;
21100: GO 21341
// for i = 1 to 8 do
21102: LD_ADDR_VAR 0 2
21106: PUSH
21107: DOUBLE
21108: LD_INT 1
21110: DEC
21111: ST_TO_ADDR
21112: LD_INT 8
21114: PUSH
21115: FOR_TO
21116: IFFALSE 21142
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21118: LD_ADDR_EXP 77
21122: PUSH
21123: LD_EXP 77
21127: PPUSH
21128: LD_VAR 0 2
21132: PPUSH
21133: EMPTY
21134: PPUSH
21135: CALL_OW 1
21139: ST_TO_ADDR
21140: GO 21115
21142: POP
21143: POP
// tmp := [ ] ;
21144: LD_ADDR_VAR 0 5
21148: PUSH
21149: EMPTY
21150: ST_TO_ADDR
// for i = 1 to mc_sides do
21151: LD_ADDR_VAR 0 2
21155: PUSH
21156: DOUBLE
21157: LD_INT 1
21159: DEC
21160: ST_TO_ADDR
21161: LD_EXP 76
21165: PUSH
21166: FOR_TO
21167: IFFALSE 21225
// if not mc_sides [ i ] in tmp then
21169: LD_EXP 76
21173: PUSH
21174: LD_VAR 0 2
21178: ARRAY
21179: PUSH
21180: LD_VAR 0 5
21184: IN
21185: NOT
21186: IFFALSE 21223
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21188: LD_ADDR_VAR 0 5
21192: PUSH
21193: LD_VAR 0 5
21197: PPUSH
21198: LD_VAR 0 5
21202: PUSH
21203: LD_INT 1
21205: PLUS
21206: PPUSH
21207: LD_EXP 76
21211: PUSH
21212: LD_VAR 0 2
21216: ARRAY
21217: PPUSH
21218: CALL_OW 2
21222: ST_TO_ADDR
21223: GO 21166
21225: POP
21226: POP
// if not tmp then
21227: LD_VAR 0 5
21231: NOT
21232: IFFALSE 21236
// exit ;
21234: GO 21341
// for j in tmp do
21236: LD_ADDR_VAR 0 3
21240: PUSH
21241: LD_VAR 0 5
21245: PUSH
21246: FOR_IN
21247: IFFALSE 21339
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21249: LD_ADDR_VAR 0 6
21253: PUSH
21254: LD_INT 22
21256: PUSH
21257: LD_VAR 0 3
21261: PUSH
21262: EMPTY
21263: LIST
21264: LIST
21265: PPUSH
21266: CALL_OW 69
21270: ST_TO_ADDR
// if not un then
21271: LD_VAR 0 6
21275: NOT
21276: IFFALSE 21280
// continue ;
21278: GO 21246
// nation := GetNation ( un [ 1 ] ) ;
21280: LD_ADDR_VAR 0 4
21284: PUSH
21285: LD_VAR 0 6
21289: PUSH
21290: LD_INT 1
21292: ARRAY
21293: PPUSH
21294: CALL_OW 248
21298: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21299: LD_ADDR_EXP 77
21303: PUSH
21304: LD_EXP 77
21308: PPUSH
21309: LD_VAR 0 3
21313: PPUSH
21314: LD_VAR 0 3
21318: PPUSH
21319: LD_VAR 0 4
21323: PPUSH
21324: LD_INT 1
21326: PPUSH
21327: CALL 48023 0 3
21331: PPUSH
21332: CALL_OW 1
21336: ST_TO_ADDR
// end ;
21337: GO 21246
21339: POP
21340: POP
// end ;
21341: LD_VAR 0 1
21345: RET
// export function MC_InitSides ( ) ; var i ; begin
21346: LD_INT 0
21348: PPUSH
21349: PPUSH
// if not mc_bases then
21350: LD_EXP 50
21354: NOT
21355: IFFALSE 21359
// exit ;
21357: GO 21433
// for i = 1 to mc_bases do
21359: LD_ADDR_VAR 0 2
21363: PUSH
21364: DOUBLE
21365: LD_INT 1
21367: DEC
21368: ST_TO_ADDR
21369: LD_EXP 50
21373: PUSH
21374: FOR_TO
21375: IFFALSE 21431
// if mc_bases [ i ] then
21377: LD_EXP 50
21381: PUSH
21382: LD_VAR 0 2
21386: ARRAY
21387: IFFALSE 21429
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21389: LD_ADDR_EXP 76
21393: PUSH
21394: LD_EXP 76
21398: PPUSH
21399: LD_VAR 0 2
21403: PPUSH
21404: LD_EXP 50
21408: PUSH
21409: LD_VAR 0 2
21413: ARRAY
21414: PUSH
21415: LD_INT 1
21417: ARRAY
21418: PPUSH
21419: CALL_OW 255
21423: PPUSH
21424: CALL_OW 1
21428: ST_TO_ADDR
21429: GO 21374
21431: POP
21432: POP
// end ;
21433: LD_VAR 0 1
21437: RET
// every 0 0$03 trigger skirmish do
21438: LD_EXP 48
21442: IFFALSE 21596
21444: GO 21446
21446: DISABLE
// begin enable ;
21447: ENABLE
// MC_CheckBuildings ( ) ;
21448: CALL 26094 0 0
// MC_CheckPeopleLife ( ) ;
21452: CALL 26219 0 0
// RaiseSailEvent ( 100 ) ;
21456: LD_INT 100
21458: PPUSH
21459: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21463: LD_INT 103
21465: PPUSH
21466: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21470: LD_INT 104
21472: PPUSH
21473: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21477: LD_INT 105
21479: PPUSH
21480: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21484: LD_INT 106
21486: PPUSH
21487: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21491: LD_INT 107
21493: PPUSH
21494: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21498: LD_INT 108
21500: PPUSH
21501: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21505: LD_INT 109
21507: PPUSH
21508: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21512: LD_INT 110
21514: PPUSH
21515: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21519: LD_INT 111
21521: PPUSH
21522: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21526: LD_INT 112
21528: PPUSH
21529: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21533: LD_INT 113
21535: PPUSH
21536: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21540: LD_INT 120
21542: PPUSH
21543: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21547: LD_INT 121
21549: PPUSH
21550: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21554: LD_INT 122
21556: PPUSH
21557: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21561: LD_INT 123
21563: PPUSH
21564: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21568: LD_INT 124
21570: PPUSH
21571: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21575: LD_INT 125
21577: PPUSH
21578: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21582: LD_INT 126
21584: PPUSH
21585: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21589: LD_INT 200
21591: PPUSH
21592: CALL_OW 427
// end ;
21596: END
// on SailEvent ( event ) do begin if event < 100 then
21597: LD_VAR 0 1
21601: PUSH
21602: LD_INT 100
21604: LESS
21605: IFFALSE 21616
// CustomEvent ( event ) ;
21607: LD_VAR 0 1
21611: PPUSH
21612: CALL 17062 0 1
// if event = 100 then
21616: LD_VAR 0 1
21620: PUSH
21621: LD_INT 100
21623: EQUAL
21624: IFFALSE 21630
// MC_ClassManager ( ) ;
21626: CALL 22022 0 0
// if event = 101 then
21630: LD_VAR 0 1
21634: PUSH
21635: LD_INT 101
21637: EQUAL
21638: IFFALSE 21644
// MC_RepairBuildings ( ) ;
21640: CALL 26804 0 0
// if event = 102 then
21644: LD_VAR 0 1
21648: PUSH
21649: LD_INT 102
21651: EQUAL
21652: IFFALSE 21658
// MC_Heal ( ) ;
21654: CALL 27689 0 0
// if event = 103 then
21658: LD_VAR 0 1
21662: PUSH
21663: LD_INT 103
21665: EQUAL
21666: IFFALSE 21672
// MC_Build ( ) ;
21668: CALL 28111 0 0
// if event = 104 then
21672: LD_VAR 0 1
21676: PUSH
21677: LD_INT 104
21679: EQUAL
21680: IFFALSE 21686
// MC_TurretWeapon ( ) ;
21682: CALL 29752 0 0
// if event = 105 then
21686: LD_VAR 0 1
21690: PUSH
21691: LD_INT 105
21693: EQUAL
21694: IFFALSE 21700
// MC_BuildUpgrade ( ) ;
21696: CALL 29303 0 0
// if event = 106 then
21700: LD_VAR 0 1
21704: PUSH
21705: LD_INT 106
21707: EQUAL
21708: IFFALSE 21714
// MC_PlantMines ( ) ;
21710: CALL 30182 0 0
// if event = 107 then
21714: LD_VAR 0 1
21718: PUSH
21719: LD_INT 107
21721: EQUAL
21722: IFFALSE 21728
// MC_CollectCrates ( ) ;
21724: CALL 30973 0 0
// if event = 108 then
21728: LD_VAR 0 1
21732: PUSH
21733: LD_INT 108
21735: EQUAL
21736: IFFALSE 21742
// MC_LinkRemoteControl ( ) ;
21738: CALL 32749 0 0
// if event = 109 then
21742: LD_VAR 0 1
21746: PUSH
21747: LD_INT 109
21749: EQUAL
21750: IFFALSE 21756
// MC_ProduceVehicle ( ) ;
21752: CALL 32930 0 0
// if event = 110 then
21756: LD_VAR 0 1
21760: PUSH
21761: LD_INT 110
21763: EQUAL
21764: IFFALSE 21770
// MC_SendAttack ( ) ;
21766: CALL 33396 0 0
// if event = 111 then
21770: LD_VAR 0 1
21774: PUSH
21775: LD_INT 111
21777: EQUAL
21778: IFFALSE 21784
// MC_Defend ( ) ;
21780: CALL 33504 0 0
// if event = 112 then
21784: LD_VAR 0 1
21788: PUSH
21789: LD_INT 112
21791: EQUAL
21792: IFFALSE 21798
// MC_Research ( ) ;
21794: CALL 34131 0 0
// if event = 113 then
21798: LD_VAR 0 1
21802: PUSH
21803: LD_INT 113
21805: EQUAL
21806: IFFALSE 21812
// MC_MinesTrigger ( ) ;
21808: CALL 35245 0 0
// if event = 120 then
21812: LD_VAR 0 1
21816: PUSH
21817: LD_INT 120
21819: EQUAL
21820: IFFALSE 21826
// MC_RepairVehicle ( ) ;
21822: CALL 35344 0 0
// if event = 121 then
21826: LD_VAR 0 1
21830: PUSH
21831: LD_INT 121
21833: EQUAL
21834: IFFALSE 21840
// MC_TameApe ( ) ;
21836: CALL 36074 0 0
// if event = 122 then
21840: LD_VAR 0 1
21844: PUSH
21845: LD_INT 122
21847: EQUAL
21848: IFFALSE 21854
// MC_ChangeApeClass ( ) ;
21850: CALL 36903 0 0
// if event = 123 then
21854: LD_VAR 0 1
21858: PUSH
21859: LD_INT 123
21861: EQUAL
21862: IFFALSE 21868
// MC_Bazooka ( ) ;
21864: CALL 37553 0 0
// if event = 124 then
21868: LD_VAR 0 1
21872: PUSH
21873: LD_INT 124
21875: EQUAL
21876: IFFALSE 21882
// MC_TeleportExit ( ) ;
21878: CALL 37751 0 0
// if event = 125 then
21882: LD_VAR 0 1
21886: PUSH
21887: LD_INT 125
21889: EQUAL
21890: IFFALSE 21896
// MC_Deposits ( ) ;
21892: CALL 38398 0 0
// if event = 126 then
21896: LD_VAR 0 1
21900: PUSH
21901: LD_INT 126
21903: EQUAL
21904: IFFALSE 21910
// MC_RemoteDriver ( ) ;
21906: CALL 39023 0 0
// if event = 200 then
21910: LD_VAR 0 1
21914: PUSH
21915: LD_INT 200
21917: EQUAL
21918: IFFALSE 21924
// MC_Idle ( ) ;
21920: CALL 40972 0 0
// end ;
21924: PPOPN 1
21926: END
// export function MC_Reset ( base , tag ) ; var i ; begin
21927: LD_INT 0
21929: PPUSH
21930: PPUSH
// if not mc_bases [ base ] or not tag then
21931: LD_EXP 50
21935: PUSH
21936: LD_VAR 0 1
21940: ARRAY
21941: NOT
21942: PUSH
21943: LD_VAR 0 2
21947: NOT
21948: OR
21949: IFFALSE 21953
// exit ;
21951: GO 22017
// for i in mc_bases [ base ] union mc_ape [ base ] do
21953: LD_ADDR_VAR 0 4
21957: PUSH
21958: LD_EXP 50
21962: PUSH
21963: LD_VAR 0 1
21967: ARRAY
21968: PUSH
21969: LD_EXP 79
21973: PUSH
21974: LD_VAR 0 1
21978: ARRAY
21979: UNION
21980: PUSH
21981: FOR_IN
21982: IFFALSE 22015
// if GetTag ( i ) = tag then
21984: LD_VAR 0 4
21988: PPUSH
21989: CALL_OW 110
21993: PUSH
21994: LD_VAR 0 2
21998: EQUAL
21999: IFFALSE 22013
// SetTag ( i , 0 ) ;
22001: LD_VAR 0 4
22005: PPUSH
22006: LD_INT 0
22008: PPUSH
22009: CALL_OW 109
22013: GO 21981
22015: POP
22016: POP
// end ;
22017: LD_VAR 0 3
22021: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22022: LD_INT 0
22024: PPUSH
22025: PPUSH
22026: PPUSH
22027: PPUSH
22028: PPUSH
22029: PPUSH
22030: PPUSH
22031: PPUSH
// if not mc_bases then
22032: LD_EXP 50
22036: NOT
22037: IFFALSE 22041
// exit ;
22039: GO 22499
// for i = 1 to mc_bases do
22041: LD_ADDR_VAR 0 2
22045: PUSH
22046: DOUBLE
22047: LD_INT 1
22049: DEC
22050: ST_TO_ADDR
22051: LD_EXP 50
22055: PUSH
22056: FOR_TO
22057: IFFALSE 22497
// begin tmp := MC_ClassCheckReq ( i ) ;
22059: LD_ADDR_VAR 0 4
22063: PUSH
22064: LD_VAR 0 2
22068: PPUSH
22069: CALL 22504 0 1
22073: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22074: LD_ADDR_EXP 91
22078: PUSH
22079: LD_EXP 91
22083: PPUSH
22084: LD_VAR 0 2
22088: PPUSH
22089: LD_VAR 0 4
22093: PPUSH
22094: CALL_OW 1
22098: ST_TO_ADDR
// if not tmp then
22099: LD_VAR 0 4
22103: NOT
22104: IFFALSE 22108
// continue ;
22106: GO 22056
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22108: LD_ADDR_VAR 0 6
22112: PUSH
22113: LD_EXP 50
22117: PUSH
22118: LD_VAR 0 2
22122: ARRAY
22123: PPUSH
22124: LD_INT 2
22126: PUSH
22127: LD_INT 30
22129: PUSH
22130: LD_INT 4
22132: PUSH
22133: EMPTY
22134: LIST
22135: LIST
22136: PUSH
22137: LD_INT 30
22139: PUSH
22140: LD_INT 5
22142: PUSH
22143: EMPTY
22144: LIST
22145: LIST
22146: PUSH
22147: EMPTY
22148: LIST
22149: LIST
22150: LIST
22151: PPUSH
22152: CALL_OW 72
22156: PUSH
22157: LD_EXP 50
22161: PUSH
22162: LD_VAR 0 2
22166: ARRAY
22167: PPUSH
22168: LD_INT 2
22170: PUSH
22171: LD_INT 30
22173: PUSH
22174: LD_INT 0
22176: PUSH
22177: EMPTY
22178: LIST
22179: LIST
22180: PUSH
22181: LD_INT 30
22183: PUSH
22184: LD_INT 1
22186: PUSH
22187: EMPTY
22188: LIST
22189: LIST
22190: PUSH
22191: EMPTY
22192: LIST
22193: LIST
22194: LIST
22195: PPUSH
22196: CALL_OW 72
22200: PUSH
22201: LD_EXP 50
22205: PUSH
22206: LD_VAR 0 2
22210: ARRAY
22211: PPUSH
22212: LD_INT 30
22214: PUSH
22215: LD_INT 3
22217: PUSH
22218: EMPTY
22219: LIST
22220: LIST
22221: PPUSH
22222: CALL_OW 72
22226: PUSH
22227: LD_EXP 50
22231: PUSH
22232: LD_VAR 0 2
22236: ARRAY
22237: PPUSH
22238: LD_INT 2
22240: PUSH
22241: LD_INT 30
22243: PUSH
22244: LD_INT 6
22246: PUSH
22247: EMPTY
22248: LIST
22249: LIST
22250: PUSH
22251: LD_INT 30
22253: PUSH
22254: LD_INT 7
22256: PUSH
22257: EMPTY
22258: LIST
22259: LIST
22260: PUSH
22261: LD_INT 30
22263: PUSH
22264: LD_INT 8
22266: PUSH
22267: EMPTY
22268: LIST
22269: LIST
22270: PUSH
22271: EMPTY
22272: LIST
22273: LIST
22274: LIST
22275: LIST
22276: PPUSH
22277: CALL_OW 72
22281: PUSH
22282: EMPTY
22283: LIST
22284: LIST
22285: LIST
22286: LIST
22287: ST_TO_ADDR
// for j = 1 to 4 do
22288: LD_ADDR_VAR 0 3
22292: PUSH
22293: DOUBLE
22294: LD_INT 1
22296: DEC
22297: ST_TO_ADDR
22298: LD_INT 4
22300: PUSH
22301: FOR_TO
22302: IFFALSE 22493
// begin if not tmp [ j ] then
22304: LD_VAR 0 4
22308: PUSH
22309: LD_VAR 0 3
22313: ARRAY
22314: NOT
22315: IFFALSE 22319
// continue ;
22317: GO 22301
// for p in tmp [ j ] do
22319: LD_ADDR_VAR 0 5
22323: PUSH
22324: LD_VAR 0 4
22328: PUSH
22329: LD_VAR 0 3
22333: ARRAY
22334: PUSH
22335: FOR_IN
22336: IFFALSE 22489
// begin if not b [ j ] then
22338: LD_VAR 0 6
22342: PUSH
22343: LD_VAR 0 3
22347: ARRAY
22348: NOT
22349: IFFALSE 22353
// break ;
22351: GO 22489
// e := 0 ;
22353: LD_ADDR_VAR 0 7
22357: PUSH
22358: LD_INT 0
22360: ST_TO_ADDR
// for k in b [ j ] do
22361: LD_ADDR_VAR 0 8
22365: PUSH
22366: LD_VAR 0 6
22370: PUSH
22371: LD_VAR 0 3
22375: ARRAY
22376: PUSH
22377: FOR_IN
22378: IFFALSE 22405
// if IsNotFull ( k ) then
22380: LD_VAR 0 8
22384: PPUSH
22385: CALL 50172 0 1
22389: IFFALSE 22403
// begin e := k ;
22391: LD_ADDR_VAR 0 7
22395: PUSH
22396: LD_VAR 0 8
22400: ST_TO_ADDR
// break ;
22401: GO 22405
// end ;
22403: GO 22377
22405: POP
22406: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22407: LD_VAR 0 7
22411: PUSH
22412: LD_VAR 0 5
22416: PPUSH
22417: LD_VAR 0 7
22421: PPUSH
22422: CALL 82925 0 2
22426: NOT
22427: AND
22428: IFFALSE 22487
// begin if IsInUnit ( p ) then
22430: LD_VAR 0 5
22434: PPUSH
22435: CALL_OW 310
22439: IFFALSE 22450
// ComExitBuilding ( p ) ;
22441: LD_VAR 0 5
22445: PPUSH
22446: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22450: LD_VAR 0 5
22454: PPUSH
22455: LD_VAR 0 7
22459: PPUSH
22460: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22464: LD_VAR 0 5
22468: PPUSH
22469: LD_VAR 0 3
22473: PPUSH
22474: CALL_OW 183
// AddComExitBuilding ( p ) ;
22478: LD_VAR 0 5
22482: PPUSH
22483: CALL_OW 182
// end ; end ;
22487: GO 22335
22489: POP
22490: POP
// end ;
22491: GO 22301
22493: POP
22494: POP
// end ;
22495: GO 22056
22497: POP
22498: POP
// end ;
22499: LD_VAR 0 1
22503: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22504: LD_INT 0
22506: PPUSH
22507: PPUSH
22508: PPUSH
22509: PPUSH
22510: PPUSH
22511: PPUSH
22512: PPUSH
22513: PPUSH
22514: PPUSH
22515: PPUSH
22516: PPUSH
22517: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22518: LD_VAR 0 1
22522: NOT
22523: PUSH
22524: LD_EXP 50
22528: PUSH
22529: LD_VAR 0 1
22533: ARRAY
22534: NOT
22535: OR
22536: PUSH
22537: LD_EXP 50
22541: PUSH
22542: LD_VAR 0 1
22546: ARRAY
22547: PPUSH
22548: LD_INT 2
22550: PUSH
22551: LD_INT 30
22553: PUSH
22554: LD_INT 0
22556: PUSH
22557: EMPTY
22558: LIST
22559: LIST
22560: PUSH
22561: LD_INT 30
22563: PUSH
22564: LD_INT 1
22566: PUSH
22567: EMPTY
22568: LIST
22569: LIST
22570: PUSH
22571: EMPTY
22572: LIST
22573: LIST
22574: LIST
22575: PPUSH
22576: CALL_OW 72
22580: NOT
22581: OR
22582: IFFALSE 22586
// exit ;
22584: GO 26089
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22586: LD_ADDR_VAR 0 4
22590: PUSH
22591: LD_EXP 50
22595: PUSH
22596: LD_VAR 0 1
22600: ARRAY
22601: PPUSH
22602: LD_INT 2
22604: PUSH
22605: LD_INT 25
22607: PUSH
22608: LD_INT 1
22610: PUSH
22611: EMPTY
22612: LIST
22613: LIST
22614: PUSH
22615: LD_INT 25
22617: PUSH
22618: LD_INT 2
22620: PUSH
22621: EMPTY
22622: LIST
22623: LIST
22624: PUSH
22625: LD_INT 25
22627: PUSH
22628: LD_INT 3
22630: PUSH
22631: EMPTY
22632: LIST
22633: LIST
22634: PUSH
22635: LD_INT 25
22637: PUSH
22638: LD_INT 4
22640: PUSH
22641: EMPTY
22642: LIST
22643: LIST
22644: PUSH
22645: LD_INT 25
22647: PUSH
22648: LD_INT 5
22650: PUSH
22651: EMPTY
22652: LIST
22653: LIST
22654: PUSH
22655: LD_INT 25
22657: PUSH
22658: LD_INT 8
22660: PUSH
22661: EMPTY
22662: LIST
22663: LIST
22664: PUSH
22665: LD_INT 25
22667: PUSH
22668: LD_INT 9
22670: PUSH
22671: EMPTY
22672: LIST
22673: LIST
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: LIST
22679: LIST
22680: LIST
22681: LIST
22682: LIST
22683: LIST
22684: PPUSH
22685: CALL_OW 72
22689: ST_TO_ADDR
// if not tmp then
22690: LD_VAR 0 4
22694: NOT
22695: IFFALSE 22699
// exit ;
22697: GO 26089
// for i in tmp do
22699: LD_ADDR_VAR 0 3
22703: PUSH
22704: LD_VAR 0 4
22708: PUSH
22709: FOR_IN
22710: IFFALSE 22741
// if GetTag ( i ) then
22712: LD_VAR 0 3
22716: PPUSH
22717: CALL_OW 110
22721: IFFALSE 22739
// tmp := tmp diff i ;
22723: LD_ADDR_VAR 0 4
22727: PUSH
22728: LD_VAR 0 4
22732: PUSH
22733: LD_VAR 0 3
22737: DIFF
22738: ST_TO_ADDR
22739: GO 22709
22741: POP
22742: POP
// if not tmp then
22743: LD_VAR 0 4
22747: NOT
22748: IFFALSE 22752
// exit ;
22750: GO 26089
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22752: LD_ADDR_VAR 0 5
22756: PUSH
22757: LD_EXP 50
22761: PUSH
22762: LD_VAR 0 1
22766: ARRAY
22767: PPUSH
22768: LD_INT 2
22770: PUSH
22771: LD_INT 25
22773: PUSH
22774: LD_INT 1
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: PUSH
22781: LD_INT 25
22783: PUSH
22784: LD_INT 5
22786: PUSH
22787: EMPTY
22788: LIST
22789: LIST
22790: PUSH
22791: LD_INT 25
22793: PUSH
22794: LD_INT 8
22796: PUSH
22797: EMPTY
22798: LIST
22799: LIST
22800: PUSH
22801: LD_INT 25
22803: PUSH
22804: LD_INT 9
22806: PUSH
22807: EMPTY
22808: LIST
22809: LIST
22810: PUSH
22811: EMPTY
22812: LIST
22813: LIST
22814: LIST
22815: LIST
22816: LIST
22817: PPUSH
22818: CALL_OW 72
22822: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22823: LD_ADDR_VAR 0 6
22827: PUSH
22828: LD_EXP 50
22832: PUSH
22833: LD_VAR 0 1
22837: ARRAY
22838: PPUSH
22839: LD_INT 25
22841: PUSH
22842: LD_INT 2
22844: PUSH
22845: EMPTY
22846: LIST
22847: LIST
22848: PPUSH
22849: CALL_OW 72
22853: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22854: LD_ADDR_VAR 0 7
22858: PUSH
22859: LD_EXP 50
22863: PUSH
22864: LD_VAR 0 1
22868: ARRAY
22869: PPUSH
22870: LD_INT 25
22872: PUSH
22873: LD_INT 3
22875: PUSH
22876: EMPTY
22877: LIST
22878: LIST
22879: PPUSH
22880: CALL_OW 72
22884: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22885: LD_ADDR_VAR 0 8
22889: PUSH
22890: LD_EXP 50
22894: PUSH
22895: LD_VAR 0 1
22899: ARRAY
22900: PPUSH
22901: LD_INT 25
22903: PUSH
22904: LD_INT 4
22906: PUSH
22907: EMPTY
22908: LIST
22909: LIST
22910: PUSH
22911: LD_INT 24
22913: PUSH
22914: LD_INT 251
22916: PUSH
22917: EMPTY
22918: LIST
22919: LIST
22920: PUSH
22921: EMPTY
22922: LIST
22923: LIST
22924: PPUSH
22925: CALL_OW 72
22929: ST_TO_ADDR
// if mc_scan [ base ] then
22930: LD_EXP 73
22934: PUSH
22935: LD_VAR 0 1
22939: ARRAY
22940: IFFALSE 23401
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
22942: LD_ADDR_EXP 92
22946: PUSH
22947: LD_EXP 92
22951: PPUSH
22952: LD_VAR 0 1
22956: PPUSH
22957: LD_INT 4
22959: PPUSH
22960: CALL_OW 1
22964: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
22965: LD_ADDR_VAR 0 12
22969: PUSH
22970: LD_EXP 50
22974: PUSH
22975: LD_VAR 0 1
22979: ARRAY
22980: PPUSH
22981: LD_INT 2
22983: PUSH
22984: LD_INT 30
22986: PUSH
22987: LD_INT 4
22989: PUSH
22990: EMPTY
22991: LIST
22992: LIST
22993: PUSH
22994: LD_INT 30
22996: PUSH
22997: LD_INT 5
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: PUSH
23004: EMPTY
23005: LIST
23006: LIST
23007: LIST
23008: PPUSH
23009: CALL_OW 72
23013: ST_TO_ADDR
// if not b then
23014: LD_VAR 0 12
23018: NOT
23019: IFFALSE 23023
// exit ;
23021: GO 26089
// p := [ ] ;
23023: LD_ADDR_VAR 0 11
23027: PUSH
23028: EMPTY
23029: ST_TO_ADDR
// if sci >= 2 then
23030: LD_VAR 0 8
23034: PUSH
23035: LD_INT 2
23037: GREATEREQUAL
23038: IFFALSE 23069
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23040: LD_ADDR_VAR 0 8
23044: PUSH
23045: LD_VAR 0 8
23049: PUSH
23050: LD_INT 1
23052: ARRAY
23053: PUSH
23054: LD_VAR 0 8
23058: PUSH
23059: LD_INT 2
23061: ARRAY
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: ST_TO_ADDR
23067: GO 23130
// if sci = 1 then
23069: LD_VAR 0 8
23073: PUSH
23074: LD_INT 1
23076: EQUAL
23077: IFFALSE 23098
// sci := [ sci [ 1 ] ] else
23079: LD_ADDR_VAR 0 8
23083: PUSH
23084: LD_VAR 0 8
23088: PUSH
23089: LD_INT 1
23091: ARRAY
23092: PUSH
23093: EMPTY
23094: LIST
23095: ST_TO_ADDR
23096: GO 23130
// if sci = 0 then
23098: LD_VAR 0 8
23102: PUSH
23103: LD_INT 0
23105: EQUAL
23106: IFFALSE 23130
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23108: LD_ADDR_VAR 0 11
23112: PUSH
23113: LD_VAR 0 4
23117: PPUSH
23118: LD_INT 4
23120: PPUSH
23121: CALL 82788 0 2
23125: PUSH
23126: LD_INT 1
23128: ARRAY
23129: ST_TO_ADDR
// if eng > 4 then
23130: LD_VAR 0 6
23134: PUSH
23135: LD_INT 4
23137: GREATER
23138: IFFALSE 23184
// for i = eng downto 4 do
23140: LD_ADDR_VAR 0 3
23144: PUSH
23145: DOUBLE
23146: LD_VAR 0 6
23150: INC
23151: ST_TO_ADDR
23152: LD_INT 4
23154: PUSH
23155: FOR_DOWNTO
23156: IFFALSE 23182
// eng := eng diff eng [ i ] ;
23158: LD_ADDR_VAR 0 6
23162: PUSH
23163: LD_VAR 0 6
23167: PUSH
23168: LD_VAR 0 6
23172: PUSH
23173: LD_VAR 0 3
23177: ARRAY
23178: DIFF
23179: ST_TO_ADDR
23180: GO 23155
23182: POP
23183: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23184: LD_ADDR_VAR 0 4
23188: PUSH
23189: LD_VAR 0 4
23193: PUSH
23194: LD_VAR 0 5
23198: PUSH
23199: LD_VAR 0 6
23203: UNION
23204: PUSH
23205: LD_VAR 0 7
23209: UNION
23210: PUSH
23211: LD_VAR 0 8
23215: UNION
23216: DIFF
23217: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23218: LD_ADDR_VAR 0 13
23222: PUSH
23223: LD_EXP 50
23227: PUSH
23228: LD_VAR 0 1
23232: ARRAY
23233: PPUSH
23234: LD_INT 2
23236: PUSH
23237: LD_INT 30
23239: PUSH
23240: LD_INT 32
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: PUSH
23247: LD_INT 30
23249: PUSH
23250: LD_INT 31
23252: PUSH
23253: EMPTY
23254: LIST
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: LIST
23261: PPUSH
23262: CALL_OW 72
23266: PUSH
23267: LD_EXP 50
23271: PUSH
23272: LD_VAR 0 1
23276: ARRAY
23277: PPUSH
23278: LD_INT 2
23280: PUSH
23281: LD_INT 30
23283: PUSH
23284: LD_INT 4
23286: PUSH
23287: EMPTY
23288: LIST
23289: LIST
23290: PUSH
23291: LD_INT 30
23293: PUSH
23294: LD_INT 5
23296: PUSH
23297: EMPTY
23298: LIST
23299: LIST
23300: PUSH
23301: EMPTY
23302: LIST
23303: LIST
23304: LIST
23305: PPUSH
23306: CALL_OW 72
23310: PUSH
23311: LD_INT 6
23313: MUL
23314: PLUS
23315: ST_TO_ADDR
// if bcount < tmp then
23316: LD_VAR 0 13
23320: PUSH
23321: LD_VAR 0 4
23325: LESS
23326: IFFALSE 23372
// for i = tmp downto bcount do
23328: LD_ADDR_VAR 0 3
23332: PUSH
23333: DOUBLE
23334: LD_VAR 0 4
23338: INC
23339: ST_TO_ADDR
23340: LD_VAR 0 13
23344: PUSH
23345: FOR_DOWNTO
23346: IFFALSE 23370
// tmp := Delete ( tmp , tmp ) ;
23348: LD_ADDR_VAR 0 4
23352: PUSH
23353: LD_VAR 0 4
23357: PPUSH
23358: LD_VAR 0 4
23362: PPUSH
23363: CALL_OW 3
23367: ST_TO_ADDR
23368: GO 23345
23370: POP
23371: POP
// result := [ tmp , 0 , 0 , p ] ;
23372: LD_ADDR_VAR 0 2
23376: PUSH
23377: LD_VAR 0 4
23381: PUSH
23382: LD_INT 0
23384: PUSH
23385: LD_INT 0
23387: PUSH
23388: LD_VAR 0 11
23392: PUSH
23393: EMPTY
23394: LIST
23395: LIST
23396: LIST
23397: LIST
23398: ST_TO_ADDR
// exit ;
23399: GO 26089
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23401: LD_EXP 50
23405: PUSH
23406: LD_VAR 0 1
23410: ARRAY
23411: PPUSH
23412: LD_INT 2
23414: PUSH
23415: LD_INT 30
23417: PUSH
23418: LD_INT 6
23420: PUSH
23421: EMPTY
23422: LIST
23423: LIST
23424: PUSH
23425: LD_INT 30
23427: PUSH
23428: LD_INT 7
23430: PUSH
23431: EMPTY
23432: LIST
23433: LIST
23434: PUSH
23435: LD_INT 30
23437: PUSH
23438: LD_INT 8
23440: PUSH
23441: EMPTY
23442: LIST
23443: LIST
23444: PUSH
23445: EMPTY
23446: LIST
23447: LIST
23448: LIST
23449: LIST
23450: PPUSH
23451: CALL_OW 72
23455: NOT
23456: PUSH
23457: LD_EXP 50
23461: PUSH
23462: LD_VAR 0 1
23466: ARRAY
23467: PPUSH
23468: LD_INT 30
23470: PUSH
23471: LD_INT 3
23473: PUSH
23474: EMPTY
23475: LIST
23476: LIST
23477: PPUSH
23478: CALL_OW 72
23482: NOT
23483: AND
23484: IFFALSE 23556
// begin if eng = tmp then
23486: LD_VAR 0 6
23490: PUSH
23491: LD_VAR 0 4
23495: EQUAL
23496: IFFALSE 23500
// exit ;
23498: GO 26089
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23500: LD_ADDR_EXP 92
23504: PUSH
23505: LD_EXP 92
23509: PPUSH
23510: LD_VAR 0 1
23514: PPUSH
23515: LD_INT 1
23517: PPUSH
23518: CALL_OW 1
23522: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23523: LD_ADDR_VAR 0 2
23527: PUSH
23528: LD_INT 0
23530: PUSH
23531: LD_VAR 0 4
23535: PUSH
23536: LD_VAR 0 6
23540: DIFF
23541: PUSH
23542: LD_INT 0
23544: PUSH
23545: LD_INT 0
23547: PUSH
23548: EMPTY
23549: LIST
23550: LIST
23551: LIST
23552: LIST
23553: ST_TO_ADDR
// exit ;
23554: GO 26089
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23556: LD_EXP 77
23560: PUSH
23561: LD_EXP 76
23565: PUSH
23566: LD_VAR 0 1
23570: ARRAY
23571: ARRAY
23572: PUSH
23573: LD_EXP 50
23577: PUSH
23578: LD_VAR 0 1
23582: ARRAY
23583: PPUSH
23584: LD_INT 2
23586: PUSH
23587: LD_INT 30
23589: PUSH
23590: LD_INT 6
23592: PUSH
23593: EMPTY
23594: LIST
23595: LIST
23596: PUSH
23597: LD_INT 30
23599: PUSH
23600: LD_INT 7
23602: PUSH
23603: EMPTY
23604: LIST
23605: LIST
23606: PUSH
23607: LD_INT 30
23609: PUSH
23610: LD_INT 8
23612: PUSH
23613: EMPTY
23614: LIST
23615: LIST
23616: PUSH
23617: EMPTY
23618: LIST
23619: LIST
23620: LIST
23621: LIST
23622: PPUSH
23623: CALL_OW 72
23627: AND
23628: PUSH
23629: LD_EXP 50
23633: PUSH
23634: LD_VAR 0 1
23638: ARRAY
23639: PPUSH
23640: LD_INT 30
23642: PUSH
23643: LD_INT 3
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: PPUSH
23650: CALL_OW 72
23654: NOT
23655: AND
23656: IFFALSE 23870
// begin if sci >= 6 then
23658: LD_VAR 0 8
23662: PUSH
23663: LD_INT 6
23665: GREATEREQUAL
23666: IFFALSE 23670
// exit ;
23668: GO 26089
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23670: LD_ADDR_EXP 92
23674: PUSH
23675: LD_EXP 92
23679: PPUSH
23680: LD_VAR 0 1
23684: PPUSH
23685: LD_INT 2
23687: PPUSH
23688: CALL_OW 1
23692: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23693: LD_ADDR_VAR 0 9
23697: PUSH
23698: LD_VAR 0 4
23702: PUSH
23703: LD_VAR 0 8
23707: DIFF
23708: PPUSH
23709: LD_INT 4
23711: PPUSH
23712: CALL 82788 0 2
23716: ST_TO_ADDR
// p := [ ] ;
23717: LD_ADDR_VAR 0 11
23721: PUSH
23722: EMPTY
23723: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23724: LD_VAR 0 8
23728: PUSH
23729: LD_INT 6
23731: LESS
23732: PUSH
23733: LD_VAR 0 9
23737: PUSH
23738: LD_INT 6
23740: GREATER
23741: AND
23742: IFFALSE 23823
// begin for i = 1 to 6 - sci do
23744: LD_ADDR_VAR 0 3
23748: PUSH
23749: DOUBLE
23750: LD_INT 1
23752: DEC
23753: ST_TO_ADDR
23754: LD_INT 6
23756: PUSH
23757: LD_VAR 0 8
23761: MINUS
23762: PUSH
23763: FOR_TO
23764: IFFALSE 23819
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23766: LD_ADDR_VAR 0 11
23770: PUSH
23771: LD_VAR 0 11
23775: PPUSH
23776: LD_VAR 0 11
23780: PUSH
23781: LD_INT 1
23783: PLUS
23784: PPUSH
23785: LD_VAR 0 9
23789: PUSH
23790: LD_INT 1
23792: ARRAY
23793: PPUSH
23794: CALL_OW 2
23798: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23799: LD_ADDR_VAR 0 9
23803: PUSH
23804: LD_VAR 0 9
23808: PPUSH
23809: LD_INT 1
23811: PPUSH
23812: CALL_OW 3
23816: ST_TO_ADDR
// end ;
23817: GO 23763
23819: POP
23820: POP
// end else
23821: GO 23843
// if sort then
23823: LD_VAR 0 9
23827: IFFALSE 23843
// p := sort [ 1 ] ;
23829: LD_ADDR_VAR 0 11
23833: PUSH
23834: LD_VAR 0 9
23838: PUSH
23839: LD_INT 1
23841: ARRAY
23842: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23843: LD_ADDR_VAR 0 2
23847: PUSH
23848: LD_INT 0
23850: PUSH
23851: LD_INT 0
23853: PUSH
23854: LD_INT 0
23856: PUSH
23857: LD_VAR 0 11
23861: PUSH
23862: EMPTY
23863: LIST
23864: LIST
23865: LIST
23866: LIST
23867: ST_TO_ADDR
// exit ;
23868: GO 26089
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23870: LD_EXP 77
23874: PUSH
23875: LD_EXP 76
23879: PUSH
23880: LD_VAR 0 1
23884: ARRAY
23885: ARRAY
23886: PUSH
23887: LD_EXP 50
23891: PUSH
23892: LD_VAR 0 1
23896: ARRAY
23897: PPUSH
23898: LD_INT 2
23900: PUSH
23901: LD_INT 30
23903: PUSH
23904: LD_INT 6
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: PUSH
23911: LD_INT 30
23913: PUSH
23914: LD_INT 7
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: PUSH
23921: LD_INT 30
23923: PUSH
23924: LD_INT 8
23926: PUSH
23927: EMPTY
23928: LIST
23929: LIST
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: LIST
23935: LIST
23936: PPUSH
23937: CALL_OW 72
23941: AND
23942: PUSH
23943: LD_EXP 50
23947: PUSH
23948: LD_VAR 0 1
23952: ARRAY
23953: PPUSH
23954: LD_INT 30
23956: PUSH
23957: LD_INT 3
23959: PUSH
23960: EMPTY
23961: LIST
23962: LIST
23963: PPUSH
23964: CALL_OW 72
23968: AND
23969: IFFALSE 24703
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
23971: LD_ADDR_EXP 92
23975: PUSH
23976: LD_EXP 92
23980: PPUSH
23981: LD_VAR 0 1
23985: PPUSH
23986: LD_INT 3
23988: PPUSH
23989: CALL_OW 1
23993: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23994: LD_ADDR_VAR 0 2
23998: PUSH
23999: LD_INT 0
24001: PUSH
24002: LD_INT 0
24004: PUSH
24005: LD_INT 0
24007: PUSH
24008: LD_INT 0
24010: PUSH
24011: EMPTY
24012: LIST
24013: LIST
24014: LIST
24015: LIST
24016: ST_TO_ADDR
// if not eng then
24017: LD_VAR 0 6
24021: NOT
24022: IFFALSE 24085
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24024: LD_ADDR_VAR 0 11
24028: PUSH
24029: LD_VAR 0 4
24033: PPUSH
24034: LD_INT 2
24036: PPUSH
24037: CALL 82788 0 2
24041: PUSH
24042: LD_INT 1
24044: ARRAY
24045: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24046: LD_ADDR_VAR 0 2
24050: PUSH
24051: LD_VAR 0 2
24055: PPUSH
24056: LD_INT 2
24058: PPUSH
24059: LD_VAR 0 11
24063: PPUSH
24064: CALL_OW 1
24068: ST_TO_ADDR
// tmp := tmp diff p ;
24069: LD_ADDR_VAR 0 4
24073: PUSH
24074: LD_VAR 0 4
24078: PUSH
24079: LD_VAR 0 11
24083: DIFF
24084: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24085: LD_VAR 0 4
24089: PUSH
24090: LD_VAR 0 8
24094: PUSH
24095: LD_INT 6
24097: LESS
24098: AND
24099: IFFALSE 24287
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24101: LD_ADDR_VAR 0 9
24105: PUSH
24106: LD_VAR 0 4
24110: PUSH
24111: LD_VAR 0 8
24115: PUSH
24116: LD_VAR 0 7
24120: UNION
24121: DIFF
24122: PPUSH
24123: LD_INT 4
24125: PPUSH
24126: CALL 82788 0 2
24130: ST_TO_ADDR
// p := [ ] ;
24131: LD_ADDR_VAR 0 11
24135: PUSH
24136: EMPTY
24137: ST_TO_ADDR
// if sort then
24138: LD_VAR 0 9
24142: IFFALSE 24258
// for i = 1 to 6 - sci do
24144: LD_ADDR_VAR 0 3
24148: PUSH
24149: DOUBLE
24150: LD_INT 1
24152: DEC
24153: ST_TO_ADDR
24154: LD_INT 6
24156: PUSH
24157: LD_VAR 0 8
24161: MINUS
24162: PUSH
24163: FOR_TO
24164: IFFALSE 24256
// begin if i = sort then
24166: LD_VAR 0 3
24170: PUSH
24171: LD_VAR 0 9
24175: EQUAL
24176: IFFALSE 24180
// break ;
24178: GO 24256
// if GetClass ( i ) = 4 then
24180: LD_VAR 0 3
24184: PPUSH
24185: CALL_OW 257
24189: PUSH
24190: LD_INT 4
24192: EQUAL
24193: IFFALSE 24197
// continue ;
24195: GO 24163
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24197: LD_ADDR_VAR 0 11
24201: PUSH
24202: LD_VAR 0 11
24206: PPUSH
24207: LD_VAR 0 11
24211: PUSH
24212: LD_INT 1
24214: PLUS
24215: PPUSH
24216: LD_VAR 0 9
24220: PUSH
24221: LD_VAR 0 3
24225: ARRAY
24226: PPUSH
24227: CALL_OW 2
24231: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24232: LD_ADDR_VAR 0 4
24236: PUSH
24237: LD_VAR 0 4
24241: PUSH
24242: LD_VAR 0 9
24246: PUSH
24247: LD_VAR 0 3
24251: ARRAY
24252: DIFF
24253: ST_TO_ADDR
// end ;
24254: GO 24163
24256: POP
24257: POP
// if p then
24258: LD_VAR 0 11
24262: IFFALSE 24287
// result := Replace ( result , 4 , p ) ;
24264: LD_ADDR_VAR 0 2
24268: PUSH
24269: LD_VAR 0 2
24273: PPUSH
24274: LD_INT 4
24276: PPUSH
24277: LD_VAR 0 11
24281: PPUSH
24282: CALL_OW 1
24286: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24287: LD_VAR 0 4
24291: PUSH
24292: LD_VAR 0 7
24296: PUSH
24297: LD_INT 6
24299: LESS
24300: AND
24301: IFFALSE 24489
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24303: LD_ADDR_VAR 0 9
24307: PUSH
24308: LD_VAR 0 4
24312: PUSH
24313: LD_VAR 0 8
24317: PUSH
24318: LD_VAR 0 7
24322: UNION
24323: DIFF
24324: PPUSH
24325: LD_INT 3
24327: PPUSH
24328: CALL 82788 0 2
24332: ST_TO_ADDR
// p := [ ] ;
24333: LD_ADDR_VAR 0 11
24337: PUSH
24338: EMPTY
24339: ST_TO_ADDR
// if sort then
24340: LD_VAR 0 9
24344: IFFALSE 24460
// for i = 1 to 6 - mech do
24346: LD_ADDR_VAR 0 3
24350: PUSH
24351: DOUBLE
24352: LD_INT 1
24354: DEC
24355: ST_TO_ADDR
24356: LD_INT 6
24358: PUSH
24359: LD_VAR 0 7
24363: MINUS
24364: PUSH
24365: FOR_TO
24366: IFFALSE 24458
// begin if i = sort then
24368: LD_VAR 0 3
24372: PUSH
24373: LD_VAR 0 9
24377: EQUAL
24378: IFFALSE 24382
// break ;
24380: GO 24458
// if GetClass ( i ) = 3 then
24382: LD_VAR 0 3
24386: PPUSH
24387: CALL_OW 257
24391: PUSH
24392: LD_INT 3
24394: EQUAL
24395: IFFALSE 24399
// continue ;
24397: GO 24365
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24399: LD_ADDR_VAR 0 11
24403: PUSH
24404: LD_VAR 0 11
24408: PPUSH
24409: LD_VAR 0 11
24413: PUSH
24414: LD_INT 1
24416: PLUS
24417: PPUSH
24418: LD_VAR 0 9
24422: PUSH
24423: LD_VAR 0 3
24427: ARRAY
24428: PPUSH
24429: CALL_OW 2
24433: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24434: LD_ADDR_VAR 0 4
24438: PUSH
24439: LD_VAR 0 4
24443: PUSH
24444: LD_VAR 0 9
24448: PUSH
24449: LD_VAR 0 3
24453: ARRAY
24454: DIFF
24455: ST_TO_ADDR
// end ;
24456: GO 24365
24458: POP
24459: POP
// if p then
24460: LD_VAR 0 11
24464: IFFALSE 24489
// result := Replace ( result , 3 , p ) ;
24466: LD_ADDR_VAR 0 2
24470: PUSH
24471: LD_VAR 0 2
24475: PPUSH
24476: LD_INT 3
24478: PPUSH
24479: LD_VAR 0 11
24483: PPUSH
24484: CALL_OW 1
24488: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24489: LD_VAR 0 4
24493: PUSH
24494: LD_INT 6
24496: GREATER
24497: PUSH
24498: LD_VAR 0 6
24502: PUSH
24503: LD_INT 6
24505: LESS
24506: AND
24507: IFFALSE 24701
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24509: LD_ADDR_VAR 0 9
24513: PUSH
24514: LD_VAR 0 4
24518: PUSH
24519: LD_VAR 0 8
24523: PUSH
24524: LD_VAR 0 7
24528: UNION
24529: PUSH
24530: LD_VAR 0 6
24534: UNION
24535: DIFF
24536: PPUSH
24537: LD_INT 2
24539: PPUSH
24540: CALL 82788 0 2
24544: ST_TO_ADDR
// p := [ ] ;
24545: LD_ADDR_VAR 0 11
24549: PUSH
24550: EMPTY
24551: ST_TO_ADDR
// if sort then
24552: LD_VAR 0 9
24556: IFFALSE 24672
// for i = 1 to 6 - eng do
24558: LD_ADDR_VAR 0 3
24562: PUSH
24563: DOUBLE
24564: LD_INT 1
24566: DEC
24567: ST_TO_ADDR
24568: LD_INT 6
24570: PUSH
24571: LD_VAR 0 6
24575: MINUS
24576: PUSH
24577: FOR_TO
24578: IFFALSE 24670
// begin if i = sort then
24580: LD_VAR 0 3
24584: PUSH
24585: LD_VAR 0 9
24589: EQUAL
24590: IFFALSE 24594
// break ;
24592: GO 24670
// if GetClass ( i ) = 2 then
24594: LD_VAR 0 3
24598: PPUSH
24599: CALL_OW 257
24603: PUSH
24604: LD_INT 2
24606: EQUAL
24607: IFFALSE 24611
// continue ;
24609: GO 24577
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24611: LD_ADDR_VAR 0 11
24615: PUSH
24616: LD_VAR 0 11
24620: PPUSH
24621: LD_VAR 0 11
24625: PUSH
24626: LD_INT 1
24628: PLUS
24629: PPUSH
24630: LD_VAR 0 9
24634: PUSH
24635: LD_VAR 0 3
24639: ARRAY
24640: PPUSH
24641: CALL_OW 2
24645: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24646: LD_ADDR_VAR 0 4
24650: PUSH
24651: LD_VAR 0 4
24655: PUSH
24656: LD_VAR 0 9
24660: PUSH
24661: LD_VAR 0 3
24665: ARRAY
24666: DIFF
24667: ST_TO_ADDR
// end ;
24668: GO 24577
24670: POP
24671: POP
// if p then
24672: LD_VAR 0 11
24676: IFFALSE 24701
// result := Replace ( result , 2 , p ) ;
24678: LD_ADDR_VAR 0 2
24682: PUSH
24683: LD_VAR 0 2
24687: PPUSH
24688: LD_INT 2
24690: PPUSH
24691: LD_VAR 0 11
24695: PPUSH
24696: CALL_OW 1
24700: ST_TO_ADDR
// end ; exit ;
24701: GO 26089
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24703: LD_EXP 77
24707: PUSH
24708: LD_EXP 76
24712: PUSH
24713: LD_VAR 0 1
24717: ARRAY
24718: ARRAY
24719: NOT
24720: PUSH
24721: LD_EXP 50
24725: PUSH
24726: LD_VAR 0 1
24730: ARRAY
24731: PPUSH
24732: LD_INT 30
24734: PUSH
24735: LD_INT 3
24737: PUSH
24738: EMPTY
24739: LIST
24740: LIST
24741: PPUSH
24742: CALL_OW 72
24746: AND
24747: PUSH
24748: LD_EXP 55
24752: PUSH
24753: LD_VAR 0 1
24757: ARRAY
24758: AND
24759: IFFALSE 25367
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24761: LD_ADDR_EXP 92
24765: PUSH
24766: LD_EXP 92
24770: PPUSH
24771: LD_VAR 0 1
24775: PPUSH
24776: LD_INT 5
24778: PPUSH
24779: CALL_OW 1
24783: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24784: LD_ADDR_VAR 0 2
24788: PUSH
24789: LD_INT 0
24791: PUSH
24792: LD_INT 0
24794: PUSH
24795: LD_INT 0
24797: PUSH
24798: LD_INT 0
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: LIST
24805: LIST
24806: ST_TO_ADDR
// if sci > 1 then
24807: LD_VAR 0 8
24811: PUSH
24812: LD_INT 1
24814: GREATER
24815: IFFALSE 24843
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24817: LD_ADDR_VAR 0 4
24821: PUSH
24822: LD_VAR 0 4
24826: PUSH
24827: LD_VAR 0 8
24831: PUSH
24832: LD_VAR 0 8
24836: PUSH
24837: LD_INT 1
24839: ARRAY
24840: DIFF
24841: DIFF
24842: ST_TO_ADDR
// if tmp and not sci then
24843: LD_VAR 0 4
24847: PUSH
24848: LD_VAR 0 8
24852: NOT
24853: AND
24854: IFFALSE 24923
// begin sort := SortBySkill ( tmp , 4 ) ;
24856: LD_ADDR_VAR 0 9
24860: PUSH
24861: LD_VAR 0 4
24865: PPUSH
24866: LD_INT 4
24868: PPUSH
24869: CALL 82788 0 2
24873: ST_TO_ADDR
// if sort then
24874: LD_VAR 0 9
24878: IFFALSE 24894
// p := sort [ 1 ] ;
24880: LD_ADDR_VAR 0 11
24884: PUSH
24885: LD_VAR 0 9
24889: PUSH
24890: LD_INT 1
24892: ARRAY
24893: ST_TO_ADDR
// if p then
24894: LD_VAR 0 11
24898: IFFALSE 24923
// result := Replace ( result , 4 , p ) ;
24900: LD_ADDR_VAR 0 2
24904: PUSH
24905: LD_VAR 0 2
24909: PPUSH
24910: LD_INT 4
24912: PPUSH
24913: LD_VAR 0 11
24917: PPUSH
24918: CALL_OW 1
24922: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24923: LD_ADDR_VAR 0 4
24927: PUSH
24928: LD_VAR 0 4
24932: PUSH
24933: LD_VAR 0 7
24937: DIFF
24938: ST_TO_ADDR
// if tmp and mech < 6 then
24939: LD_VAR 0 4
24943: PUSH
24944: LD_VAR 0 7
24948: PUSH
24949: LD_INT 6
24951: LESS
24952: AND
24953: IFFALSE 25141
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24955: LD_ADDR_VAR 0 9
24959: PUSH
24960: LD_VAR 0 4
24964: PUSH
24965: LD_VAR 0 8
24969: PUSH
24970: LD_VAR 0 7
24974: UNION
24975: DIFF
24976: PPUSH
24977: LD_INT 3
24979: PPUSH
24980: CALL 82788 0 2
24984: ST_TO_ADDR
// p := [ ] ;
24985: LD_ADDR_VAR 0 11
24989: PUSH
24990: EMPTY
24991: ST_TO_ADDR
// if sort then
24992: LD_VAR 0 9
24996: IFFALSE 25112
// for i = 1 to 6 - mech do
24998: LD_ADDR_VAR 0 3
25002: PUSH
25003: DOUBLE
25004: LD_INT 1
25006: DEC
25007: ST_TO_ADDR
25008: LD_INT 6
25010: PUSH
25011: LD_VAR 0 7
25015: MINUS
25016: PUSH
25017: FOR_TO
25018: IFFALSE 25110
// begin if i = sort then
25020: LD_VAR 0 3
25024: PUSH
25025: LD_VAR 0 9
25029: EQUAL
25030: IFFALSE 25034
// break ;
25032: GO 25110
// if GetClass ( i ) = 3 then
25034: LD_VAR 0 3
25038: PPUSH
25039: CALL_OW 257
25043: PUSH
25044: LD_INT 3
25046: EQUAL
25047: IFFALSE 25051
// continue ;
25049: GO 25017
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25051: LD_ADDR_VAR 0 11
25055: PUSH
25056: LD_VAR 0 11
25060: PPUSH
25061: LD_VAR 0 11
25065: PUSH
25066: LD_INT 1
25068: PLUS
25069: PPUSH
25070: LD_VAR 0 9
25074: PUSH
25075: LD_VAR 0 3
25079: ARRAY
25080: PPUSH
25081: CALL_OW 2
25085: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25086: LD_ADDR_VAR 0 4
25090: PUSH
25091: LD_VAR 0 4
25095: PUSH
25096: LD_VAR 0 9
25100: PUSH
25101: LD_VAR 0 3
25105: ARRAY
25106: DIFF
25107: ST_TO_ADDR
// end ;
25108: GO 25017
25110: POP
25111: POP
// if p then
25112: LD_VAR 0 11
25116: IFFALSE 25141
// result := Replace ( result , 3 , p ) ;
25118: LD_ADDR_VAR 0 2
25122: PUSH
25123: LD_VAR 0 2
25127: PPUSH
25128: LD_INT 3
25130: PPUSH
25131: LD_VAR 0 11
25135: PPUSH
25136: CALL_OW 1
25140: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25141: LD_ADDR_VAR 0 4
25145: PUSH
25146: LD_VAR 0 4
25150: PUSH
25151: LD_VAR 0 6
25155: DIFF
25156: ST_TO_ADDR
// if tmp and eng < 6 then
25157: LD_VAR 0 4
25161: PUSH
25162: LD_VAR 0 6
25166: PUSH
25167: LD_INT 6
25169: LESS
25170: AND
25171: IFFALSE 25365
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25173: LD_ADDR_VAR 0 9
25177: PUSH
25178: LD_VAR 0 4
25182: PUSH
25183: LD_VAR 0 8
25187: PUSH
25188: LD_VAR 0 7
25192: UNION
25193: PUSH
25194: LD_VAR 0 6
25198: UNION
25199: DIFF
25200: PPUSH
25201: LD_INT 2
25203: PPUSH
25204: CALL 82788 0 2
25208: ST_TO_ADDR
// p := [ ] ;
25209: LD_ADDR_VAR 0 11
25213: PUSH
25214: EMPTY
25215: ST_TO_ADDR
// if sort then
25216: LD_VAR 0 9
25220: IFFALSE 25336
// for i = 1 to 6 - eng do
25222: LD_ADDR_VAR 0 3
25226: PUSH
25227: DOUBLE
25228: LD_INT 1
25230: DEC
25231: ST_TO_ADDR
25232: LD_INT 6
25234: PUSH
25235: LD_VAR 0 6
25239: MINUS
25240: PUSH
25241: FOR_TO
25242: IFFALSE 25334
// begin if i = sort then
25244: LD_VAR 0 3
25248: PUSH
25249: LD_VAR 0 9
25253: EQUAL
25254: IFFALSE 25258
// break ;
25256: GO 25334
// if GetClass ( i ) = 2 then
25258: LD_VAR 0 3
25262: PPUSH
25263: CALL_OW 257
25267: PUSH
25268: LD_INT 2
25270: EQUAL
25271: IFFALSE 25275
// continue ;
25273: GO 25241
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25275: LD_ADDR_VAR 0 11
25279: PUSH
25280: LD_VAR 0 11
25284: PPUSH
25285: LD_VAR 0 11
25289: PUSH
25290: LD_INT 1
25292: PLUS
25293: PPUSH
25294: LD_VAR 0 9
25298: PUSH
25299: LD_VAR 0 3
25303: ARRAY
25304: PPUSH
25305: CALL_OW 2
25309: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25310: LD_ADDR_VAR 0 4
25314: PUSH
25315: LD_VAR 0 4
25319: PUSH
25320: LD_VAR 0 9
25324: PUSH
25325: LD_VAR 0 3
25329: ARRAY
25330: DIFF
25331: ST_TO_ADDR
// end ;
25332: GO 25241
25334: POP
25335: POP
// if p then
25336: LD_VAR 0 11
25340: IFFALSE 25365
// result := Replace ( result , 2 , p ) ;
25342: LD_ADDR_VAR 0 2
25346: PUSH
25347: LD_VAR 0 2
25351: PPUSH
25352: LD_INT 2
25354: PPUSH
25355: LD_VAR 0 11
25359: PPUSH
25360: CALL_OW 1
25364: ST_TO_ADDR
// end ; exit ;
25365: GO 26089
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25367: LD_EXP 77
25371: PUSH
25372: LD_EXP 76
25376: PUSH
25377: LD_VAR 0 1
25381: ARRAY
25382: ARRAY
25383: NOT
25384: PUSH
25385: LD_EXP 50
25389: PUSH
25390: LD_VAR 0 1
25394: ARRAY
25395: PPUSH
25396: LD_INT 30
25398: PUSH
25399: LD_INT 3
25401: PUSH
25402: EMPTY
25403: LIST
25404: LIST
25405: PPUSH
25406: CALL_OW 72
25410: AND
25411: PUSH
25412: LD_EXP 55
25416: PUSH
25417: LD_VAR 0 1
25421: ARRAY
25422: NOT
25423: AND
25424: IFFALSE 26089
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25426: LD_ADDR_EXP 92
25430: PUSH
25431: LD_EXP 92
25435: PPUSH
25436: LD_VAR 0 1
25440: PPUSH
25441: LD_INT 6
25443: PPUSH
25444: CALL_OW 1
25448: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25449: LD_ADDR_VAR 0 2
25453: PUSH
25454: LD_INT 0
25456: PUSH
25457: LD_INT 0
25459: PUSH
25460: LD_INT 0
25462: PUSH
25463: LD_INT 0
25465: PUSH
25466: EMPTY
25467: LIST
25468: LIST
25469: LIST
25470: LIST
25471: ST_TO_ADDR
// if sci >= 1 then
25472: LD_VAR 0 8
25476: PUSH
25477: LD_INT 1
25479: GREATEREQUAL
25480: IFFALSE 25502
// tmp := tmp diff sci [ 1 ] ;
25482: LD_ADDR_VAR 0 4
25486: PUSH
25487: LD_VAR 0 4
25491: PUSH
25492: LD_VAR 0 8
25496: PUSH
25497: LD_INT 1
25499: ARRAY
25500: DIFF
25501: ST_TO_ADDR
// if tmp and not sci then
25502: LD_VAR 0 4
25506: PUSH
25507: LD_VAR 0 8
25511: NOT
25512: AND
25513: IFFALSE 25582
// begin sort := SortBySkill ( tmp , 4 ) ;
25515: LD_ADDR_VAR 0 9
25519: PUSH
25520: LD_VAR 0 4
25524: PPUSH
25525: LD_INT 4
25527: PPUSH
25528: CALL 82788 0 2
25532: ST_TO_ADDR
// if sort then
25533: LD_VAR 0 9
25537: IFFALSE 25553
// p := sort [ 1 ] ;
25539: LD_ADDR_VAR 0 11
25543: PUSH
25544: LD_VAR 0 9
25548: PUSH
25549: LD_INT 1
25551: ARRAY
25552: ST_TO_ADDR
// if p then
25553: LD_VAR 0 11
25557: IFFALSE 25582
// result := Replace ( result , 4 , p ) ;
25559: LD_ADDR_VAR 0 2
25563: PUSH
25564: LD_VAR 0 2
25568: PPUSH
25569: LD_INT 4
25571: PPUSH
25572: LD_VAR 0 11
25576: PPUSH
25577: CALL_OW 1
25581: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25582: LD_ADDR_VAR 0 4
25586: PUSH
25587: LD_VAR 0 4
25591: PUSH
25592: LD_VAR 0 7
25596: DIFF
25597: ST_TO_ADDR
// if tmp and mech < 6 then
25598: LD_VAR 0 4
25602: PUSH
25603: LD_VAR 0 7
25607: PUSH
25608: LD_INT 6
25610: LESS
25611: AND
25612: IFFALSE 25794
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25614: LD_ADDR_VAR 0 9
25618: PUSH
25619: LD_VAR 0 4
25623: PUSH
25624: LD_VAR 0 7
25628: DIFF
25629: PPUSH
25630: LD_INT 3
25632: PPUSH
25633: CALL 82788 0 2
25637: ST_TO_ADDR
// p := [ ] ;
25638: LD_ADDR_VAR 0 11
25642: PUSH
25643: EMPTY
25644: ST_TO_ADDR
// if sort then
25645: LD_VAR 0 9
25649: IFFALSE 25765
// for i = 1 to 6 - mech do
25651: LD_ADDR_VAR 0 3
25655: PUSH
25656: DOUBLE
25657: LD_INT 1
25659: DEC
25660: ST_TO_ADDR
25661: LD_INT 6
25663: PUSH
25664: LD_VAR 0 7
25668: MINUS
25669: PUSH
25670: FOR_TO
25671: IFFALSE 25763
// begin if i = sort then
25673: LD_VAR 0 3
25677: PUSH
25678: LD_VAR 0 9
25682: EQUAL
25683: IFFALSE 25687
// break ;
25685: GO 25763
// if GetClass ( i ) = 3 then
25687: LD_VAR 0 3
25691: PPUSH
25692: CALL_OW 257
25696: PUSH
25697: LD_INT 3
25699: EQUAL
25700: IFFALSE 25704
// continue ;
25702: GO 25670
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25704: LD_ADDR_VAR 0 11
25708: PUSH
25709: LD_VAR 0 11
25713: PPUSH
25714: LD_VAR 0 11
25718: PUSH
25719: LD_INT 1
25721: PLUS
25722: PPUSH
25723: LD_VAR 0 9
25727: PUSH
25728: LD_VAR 0 3
25732: ARRAY
25733: PPUSH
25734: CALL_OW 2
25738: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25739: LD_ADDR_VAR 0 4
25743: PUSH
25744: LD_VAR 0 4
25748: PUSH
25749: LD_VAR 0 9
25753: PUSH
25754: LD_VAR 0 3
25758: ARRAY
25759: DIFF
25760: ST_TO_ADDR
// end ;
25761: GO 25670
25763: POP
25764: POP
// if p then
25765: LD_VAR 0 11
25769: IFFALSE 25794
// result := Replace ( result , 3 , p ) ;
25771: LD_ADDR_VAR 0 2
25775: PUSH
25776: LD_VAR 0 2
25780: PPUSH
25781: LD_INT 3
25783: PPUSH
25784: LD_VAR 0 11
25788: PPUSH
25789: CALL_OW 1
25793: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25794: LD_ADDR_VAR 0 4
25798: PUSH
25799: LD_VAR 0 4
25803: PUSH
25804: LD_VAR 0 6
25808: DIFF
25809: ST_TO_ADDR
// if tmp and eng < 4 then
25810: LD_VAR 0 4
25814: PUSH
25815: LD_VAR 0 6
25819: PUSH
25820: LD_INT 4
25822: LESS
25823: AND
25824: IFFALSE 26014
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25826: LD_ADDR_VAR 0 9
25830: PUSH
25831: LD_VAR 0 4
25835: PUSH
25836: LD_VAR 0 7
25840: PUSH
25841: LD_VAR 0 6
25845: UNION
25846: DIFF
25847: PPUSH
25848: LD_INT 2
25850: PPUSH
25851: CALL 82788 0 2
25855: ST_TO_ADDR
// p := [ ] ;
25856: LD_ADDR_VAR 0 11
25860: PUSH
25861: EMPTY
25862: ST_TO_ADDR
// if sort then
25863: LD_VAR 0 9
25867: IFFALSE 25983
// for i = 1 to 4 - eng do
25869: LD_ADDR_VAR 0 3
25873: PUSH
25874: DOUBLE
25875: LD_INT 1
25877: DEC
25878: ST_TO_ADDR
25879: LD_INT 4
25881: PUSH
25882: LD_VAR 0 6
25886: MINUS
25887: PUSH
25888: FOR_TO
25889: IFFALSE 25981
// begin if i = sort then
25891: LD_VAR 0 3
25895: PUSH
25896: LD_VAR 0 9
25900: EQUAL
25901: IFFALSE 25905
// break ;
25903: GO 25981
// if GetClass ( i ) = 2 then
25905: LD_VAR 0 3
25909: PPUSH
25910: CALL_OW 257
25914: PUSH
25915: LD_INT 2
25917: EQUAL
25918: IFFALSE 25922
// continue ;
25920: GO 25888
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25922: LD_ADDR_VAR 0 11
25926: PUSH
25927: LD_VAR 0 11
25931: PPUSH
25932: LD_VAR 0 11
25936: PUSH
25937: LD_INT 1
25939: PLUS
25940: PPUSH
25941: LD_VAR 0 9
25945: PUSH
25946: LD_VAR 0 3
25950: ARRAY
25951: PPUSH
25952: CALL_OW 2
25956: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25957: LD_ADDR_VAR 0 4
25961: PUSH
25962: LD_VAR 0 4
25966: PUSH
25967: LD_VAR 0 9
25971: PUSH
25972: LD_VAR 0 3
25976: ARRAY
25977: DIFF
25978: ST_TO_ADDR
// end ;
25979: GO 25888
25981: POP
25982: POP
// if p then
25983: LD_VAR 0 11
25987: IFFALSE 26012
// result := Replace ( result , 2 , p ) ;
25989: LD_ADDR_VAR 0 2
25993: PUSH
25994: LD_VAR 0 2
25998: PPUSH
25999: LD_INT 2
26001: PPUSH
26002: LD_VAR 0 11
26006: PPUSH
26007: CALL_OW 1
26011: ST_TO_ADDR
// end else
26012: GO 26058
// for i = eng downto 5 do
26014: LD_ADDR_VAR 0 3
26018: PUSH
26019: DOUBLE
26020: LD_VAR 0 6
26024: INC
26025: ST_TO_ADDR
26026: LD_INT 5
26028: PUSH
26029: FOR_DOWNTO
26030: IFFALSE 26056
// tmp := tmp union eng [ i ] ;
26032: LD_ADDR_VAR 0 4
26036: PUSH
26037: LD_VAR 0 4
26041: PUSH
26042: LD_VAR 0 6
26046: PUSH
26047: LD_VAR 0 3
26051: ARRAY
26052: UNION
26053: ST_TO_ADDR
26054: GO 26029
26056: POP
26057: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26058: LD_ADDR_VAR 0 2
26062: PUSH
26063: LD_VAR 0 2
26067: PPUSH
26068: LD_INT 1
26070: PPUSH
26071: LD_VAR 0 4
26075: PUSH
26076: LD_VAR 0 5
26080: DIFF
26081: PPUSH
26082: CALL_OW 1
26086: ST_TO_ADDR
// exit ;
26087: GO 26089
// end ; end ;
26089: LD_VAR 0 2
26093: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26094: LD_INT 0
26096: PPUSH
26097: PPUSH
26098: PPUSH
// if not mc_bases then
26099: LD_EXP 50
26103: NOT
26104: IFFALSE 26108
// exit ;
26106: GO 26214
// for i = 1 to mc_bases do
26108: LD_ADDR_VAR 0 2
26112: PUSH
26113: DOUBLE
26114: LD_INT 1
26116: DEC
26117: ST_TO_ADDR
26118: LD_EXP 50
26122: PUSH
26123: FOR_TO
26124: IFFALSE 26205
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26126: LD_ADDR_VAR 0 3
26130: PUSH
26131: LD_EXP 50
26135: PUSH
26136: LD_VAR 0 2
26140: ARRAY
26141: PPUSH
26142: LD_INT 21
26144: PUSH
26145: LD_INT 3
26147: PUSH
26148: EMPTY
26149: LIST
26150: LIST
26151: PUSH
26152: LD_INT 3
26154: PUSH
26155: LD_INT 24
26157: PUSH
26158: LD_INT 1000
26160: PUSH
26161: EMPTY
26162: LIST
26163: LIST
26164: PUSH
26165: EMPTY
26166: LIST
26167: LIST
26168: PUSH
26169: EMPTY
26170: LIST
26171: LIST
26172: PPUSH
26173: CALL_OW 72
26177: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26178: LD_ADDR_EXP 51
26182: PUSH
26183: LD_EXP 51
26187: PPUSH
26188: LD_VAR 0 2
26192: PPUSH
26193: LD_VAR 0 3
26197: PPUSH
26198: CALL_OW 1
26202: ST_TO_ADDR
// end ;
26203: GO 26123
26205: POP
26206: POP
// RaiseSailEvent ( 101 ) ;
26207: LD_INT 101
26209: PPUSH
26210: CALL_OW 427
// end ;
26214: LD_VAR 0 1
26218: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26219: LD_INT 0
26221: PPUSH
26222: PPUSH
26223: PPUSH
26224: PPUSH
26225: PPUSH
26226: PPUSH
26227: PPUSH
// if not mc_bases then
26228: LD_EXP 50
26232: NOT
26233: IFFALSE 26237
// exit ;
26235: GO 26799
// for i = 1 to mc_bases do
26237: LD_ADDR_VAR 0 2
26241: PUSH
26242: DOUBLE
26243: LD_INT 1
26245: DEC
26246: ST_TO_ADDR
26247: LD_EXP 50
26251: PUSH
26252: FOR_TO
26253: IFFALSE 26790
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26255: LD_ADDR_VAR 0 5
26259: PUSH
26260: LD_EXP 50
26264: PUSH
26265: LD_VAR 0 2
26269: ARRAY
26270: PUSH
26271: LD_EXP 79
26275: PUSH
26276: LD_VAR 0 2
26280: ARRAY
26281: UNION
26282: PPUSH
26283: LD_INT 21
26285: PUSH
26286: LD_INT 1
26288: PUSH
26289: EMPTY
26290: LIST
26291: LIST
26292: PUSH
26293: LD_INT 1
26295: PUSH
26296: LD_INT 3
26298: PUSH
26299: LD_INT 54
26301: PUSH
26302: EMPTY
26303: LIST
26304: PUSH
26305: EMPTY
26306: LIST
26307: LIST
26308: PUSH
26309: LD_INT 3
26311: PUSH
26312: LD_INT 24
26314: PUSH
26315: LD_INT 1000
26317: PUSH
26318: EMPTY
26319: LIST
26320: LIST
26321: PUSH
26322: EMPTY
26323: LIST
26324: LIST
26325: PUSH
26326: EMPTY
26327: LIST
26328: LIST
26329: LIST
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: PPUSH
26335: CALL_OW 72
26339: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26340: LD_ADDR_VAR 0 6
26344: PUSH
26345: LD_EXP 50
26349: PUSH
26350: LD_VAR 0 2
26354: ARRAY
26355: PPUSH
26356: LD_INT 21
26358: PUSH
26359: LD_INT 1
26361: PUSH
26362: EMPTY
26363: LIST
26364: LIST
26365: PUSH
26366: LD_INT 1
26368: PUSH
26369: LD_INT 3
26371: PUSH
26372: LD_INT 54
26374: PUSH
26375: EMPTY
26376: LIST
26377: PUSH
26378: EMPTY
26379: LIST
26380: LIST
26381: PUSH
26382: LD_INT 3
26384: PUSH
26385: LD_INT 24
26387: PUSH
26388: LD_INT 250
26390: PUSH
26391: EMPTY
26392: LIST
26393: LIST
26394: PUSH
26395: EMPTY
26396: LIST
26397: LIST
26398: PUSH
26399: EMPTY
26400: LIST
26401: LIST
26402: LIST
26403: PUSH
26404: EMPTY
26405: LIST
26406: LIST
26407: PPUSH
26408: CALL_OW 72
26412: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26413: LD_ADDR_VAR 0 7
26417: PUSH
26418: LD_VAR 0 5
26422: PUSH
26423: LD_VAR 0 6
26427: DIFF
26428: ST_TO_ADDR
// if not need_heal_1 then
26429: LD_VAR 0 6
26433: NOT
26434: IFFALSE 26467
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26436: LD_ADDR_EXP 53
26440: PUSH
26441: LD_EXP 53
26445: PPUSH
26446: LD_VAR 0 2
26450: PUSH
26451: LD_INT 1
26453: PUSH
26454: EMPTY
26455: LIST
26456: LIST
26457: PPUSH
26458: EMPTY
26459: PPUSH
26460: CALL 52906 0 3
26464: ST_TO_ADDR
26465: GO 26537
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26467: LD_ADDR_EXP 53
26471: PUSH
26472: LD_EXP 53
26476: PPUSH
26477: LD_VAR 0 2
26481: PUSH
26482: LD_INT 1
26484: PUSH
26485: EMPTY
26486: LIST
26487: LIST
26488: PPUSH
26489: LD_EXP 53
26493: PUSH
26494: LD_VAR 0 2
26498: ARRAY
26499: PUSH
26500: LD_INT 1
26502: ARRAY
26503: PPUSH
26504: LD_INT 3
26506: PUSH
26507: LD_INT 24
26509: PUSH
26510: LD_INT 1000
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: PUSH
26517: EMPTY
26518: LIST
26519: LIST
26520: PPUSH
26521: CALL_OW 72
26525: PUSH
26526: LD_VAR 0 6
26530: UNION
26531: PPUSH
26532: CALL 52906 0 3
26536: ST_TO_ADDR
// if not need_heal_2 then
26537: LD_VAR 0 7
26541: NOT
26542: IFFALSE 26575
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26544: LD_ADDR_EXP 53
26548: PUSH
26549: LD_EXP 53
26553: PPUSH
26554: LD_VAR 0 2
26558: PUSH
26559: LD_INT 2
26561: PUSH
26562: EMPTY
26563: LIST
26564: LIST
26565: PPUSH
26566: EMPTY
26567: PPUSH
26568: CALL 52906 0 3
26572: ST_TO_ADDR
26573: GO 26607
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26575: LD_ADDR_EXP 53
26579: PUSH
26580: LD_EXP 53
26584: PPUSH
26585: LD_VAR 0 2
26589: PUSH
26590: LD_INT 2
26592: PUSH
26593: EMPTY
26594: LIST
26595: LIST
26596: PPUSH
26597: LD_VAR 0 7
26601: PPUSH
26602: CALL 52906 0 3
26606: ST_TO_ADDR
// if need_heal_2 then
26607: LD_VAR 0 7
26611: IFFALSE 26772
// for j in need_heal_2 do
26613: LD_ADDR_VAR 0 3
26617: PUSH
26618: LD_VAR 0 7
26622: PUSH
26623: FOR_IN
26624: IFFALSE 26770
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26626: LD_ADDR_VAR 0 5
26630: PUSH
26631: LD_EXP 50
26635: PUSH
26636: LD_VAR 0 2
26640: ARRAY
26641: PPUSH
26642: LD_INT 2
26644: PUSH
26645: LD_INT 30
26647: PUSH
26648: LD_INT 6
26650: PUSH
26651: EMPTY
26652: LIST
26653: LIST
26654: PUSH
26655: LD_INT 30
26657: PUSH
26658: LD_INT 7
26660: PUSH
26661: EMPTY
26662: LIST
26663: LIST
26664: PUSH
26665: LD_INT 30
26667: PUSH
26668: LD_INT 8
26670: PUSH
26671: EMPTY
26672: LIST
26673: LIST
26674: PUSH
26675: LD_INT 30
26677: PUSH
26678: LD_INT 0
26680: PUSH
26681: EMPTY
26682: LIST
26683: LIST
26684: PUSH
26685: LD_INT 30
26687: PUSH
26688: LD_INT 1
26690: PUSH
26691: EMPTY
26692: LIST
26693: LIST
26694: PUSH
26695: EMPTY
26696: LIST
26697: LIST
26698: LIST
26699: LIST
26700: LIST
26701: LIST
26702: PPUSH
26703: CALL_OW 72
26707: ST_TO_ADDR
// if tmp then
26708: LD_VAR 0 5
26712: IFFALSE 26768
// begin k := NearestUnitToUnit ( tmp , j ) ;
26714: LD_ADDR_VAR 0 4
26718: PUSH
26719: LD_VAR 0 5
26723: PPUSH
26724: LD_VAR 0 3
26728: PPUSH
26729: CALL_OW 74
26733: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26734: LD_VAR 0 3
26738: PPUSH
26739: LD_VAR 0 4
26743: PPUSH
26744: CALL_OW 296
26748: PUSH
26749: LD_INT 5
26751: GREATER
26752: IFFALSE 26768
// ComMoveToNearbyEntrance ( j , k ) ;
26754: LD_VAR 0 3
26758: PPUSH
26759: LD_VAR 0 4
26763: PPUSH
26764: CALL 85149 0 2
// end ; end ;
26768: GO 26623
26770: POP
26771: POP
// if not need_heal_1 and not need_heal_2 then
26772: LD_VAR 0 6
26776: NOT
26777: PUSH
26778: LD_VAR 0 7
26782: NOT
26783: AND
26784: IFFALSE 26788
// continue ;
26786: GO 26252
// end ;
26788: GO 26252
26790: POP
26791: POP
// RaiseSailEvent ( 102 ) ;
26792: LD_INT 102
26794: PPUSH
26795: CALL_OW 427
// end ;
26799: LD_VAR 0 1
26803: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26804: LD_INT 0
26806: PPUSH
26807: PPUSH
26808: PPUSH
26809: PPUSH
26810: PPUSH
26811: PPUSH
26812: PPUSH
26813: PPUSH
// if not mc_bases then
26814: LD_EXP 50
26818: NOT
26819: IFFALSE 26823
// exit ;
26821: GO 27684
// for i = 1 to mc_bases do
26823: LD_ADDR_VAR 0 2
26827: PUSH
26828: DOUBLE
26829: LD_INT 1
26831: DEC
26832: ST_TO_ADDR
26833: LD_EXP 50
26837: PUSH
26838: FOR_TO
26839: IFFALSE 27682
// begin if not mc_building_need_repair [ i ] then
26841: LD_EXP 51
26845: PUSH
26846: LD_VAR 0 2
26850: ARRAY
26851: NOT
26852: IFFALSE 27039
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
26854: LD_ADDR_VAR 0 6
26858: PUSH
26859: LD_EXP 69
26863: PUSH
26864: LD_VAR 0 2
26868: ARRAY
26869: PPUSH
26870: LD_INT 3
26872: PUSH
26873: LD_INT 24
26875: PUSH
26876: LD_INT 1000
26878: PUSH
26879: EMPTY
26880: LIST
26881: LIST
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: PUSH
26887: LD_INT 2
26889: PUSH
26890: LD_INT 34
26892: PUSH
26893: LD_INT 13
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: PUSH
26900: LD_INT 34
26902: PUSH
26903: LD_INT 52
26905: PUSH
26906: EMPTY
26907: LIST
26908: LIST
26909: PUSH
26910: LD_INT 34
26912: PUSH
26913: LD_EXP 99
26917: PUSH
26918: EMPTY
26919: LIST
26920: LIST
26921: PUSH
26922: EMPTY
26923: LIST
26924: LIST
26925: LIST
26926: LIST
26927: PUSH
26928: EMPTY
26929: LIST
26930: LIST
26931: PPUSH
26932: CALL_OW 72
26936: ST_TO_ADDR
// if cranes then
26937: LD_VAR 0 6
26941: IFFALSE 27003
// for j in cranes do
26943: LD_ADDR_VAR 0 3
26947: PUSH
26948: LD_VAR 0 6
26952: PUSH
26953: FOR_IN
26954: IFFALSE 27001
// if not IsInArea ( j , mc_parking [ i ] ) then
26956: LD_VAR 0 3
26960: PPUSH
26961: LD_EXP 74
26965: PUSH
26966: LD_VAR 0 2
26970: ARRAY
26971: PPUSH
26972: CALL_OW 308
26976: NOT
26977: IFFALSE 26999
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26979: LD_VAR 0 3
26983: PPUSH
26984: LD_EXP 74
26988: PUSH
26989: LD_VAR 0 2
26993: ARRAY
26994: PPUSH
26995: CALL_OW 113
26999: GO 26953
27001: POP
27002: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27003: LD_ADDR_EXP 52
27007: PUSH
27008: LD_EXP 52
27012: PPUSH
27013: LD_VAR 0 2
27017: PPUSH
27018: EMPTY
27019: PPUSH
27020: CALL_OW 1
27024: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27025: LD_VAR 0 2
27029: PPUSH
27030: LD_INT 101
27032: PPUSH
27033: CALL 21927 0 2
// continue ;
27037: GO 26838
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27039: LD_ADDR_EXP 56
27043: PUSH
27044: LD_EXP 56
27048: PPUSH
27049: LD_VAR 0 2
27053: PPUSH
27054: EMPTY
27055: PPUSH
27056: CALL_OW 1
27060: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27061: LD_VAR 0 2
27065: PPUSH
27066: LD_INT 103
27068: PPUSH
27069: CALL 21927 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27073: LD_ADDR_VAR 0 5
27077: PUSH
27078: LD_EXP 50
27082: PUSH
27083: LD_VAR 0 2
27087: ARRAY
27088: PUSH
27089: LD_EXP 79
27093: PUSH
27094: LD_VAR 0 2
27098: ARRAY
27099: UNION
27100: PPUSH
27101: LD_INT 2
27103: PUSH
27104: LD_INT 25
27106: PUSH
27107: LD_INT 2
27109: PUSH
27110: EMPTY
27111: LIST
27112: LIST
27113: PUSH
27114: LD_INT 25
27116: PUSH
27117: LD_INT 16
27119: PUSH
27120: EMPTY
27121: LIST
27122: LIST
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: LIST
27128: PUSH
27129: EMPTY
27130: LIST
27131: PPUSH
27132: CALL_OW 72
27136: PUSH
27137: LD_EXP 53
27141: PUSH
27142: LD_VAR 0 2
27146: ARRAY
27147: PUSH
27148: LD_INT 1
27150: ARRAY
27151: PUSH
27152: LD_EXP 53
27156: PUSH
27157: LD_VAR 0 2
27161: ARRAY
27162: PUSH
27163: LD_INT 2
27165: ARRAY
27166: UNION
27167: DIFF
27168: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27169: LD_ADDR_VAR 0 6
27173: PUSH
27174: LD_EXP 69
27178: PUSH
27179: LD_VAR 0 2
27183: ARRAY
27184: PPUSH
27185: LD_INT 2
27187: PUSH
27188: LD_INT 34
27190: PUSH
27191: LD_INT 13
27193: PUSH
27194: EMPTY
27195: LIST
27196: LIST
27197: PUSH
27198: LD_INT 34
27200: PUSH
27201: LD_INT 52
27203: PUSH
27204: EMPTY
27205: LIST
27206: LIST
27207: PUSH
27208: LD_INT 34
27210: PUSH
27211: LD_EXP 99
27215: PUSH
27216: EMPTY
27217: LIST
27218: LIST
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: LIST
27224: LIST
27225: PPUSH
27226: CALL_OW 72
27230: ST_TO_ADDR
// if cranes then
27231: LD_VAR 0 6
27235: IFFALSE 27371
// begin for j in cranes do
27237: LD_ADDR_VAR 0 3
27241: PUSH
27242: LD_VAR 0 6
27246: PUSH
27247: FOR_IN
27248: IFFALSE 27369
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27250: LD_VAR 0 3
27254: PPUSH
27255: CALL_OW 256
27259: PUSH
27260: LD_INT 1000
27262: EQUAL
27263: PUSH
27264: LD_VAR 0 3
27268: PPUSH
27269: CALL_OW 314
27273: NOT
27274: AND
27275: IFFALSE 27309
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
27277: LD_VAR 0 3
27281: PPUSH
27282: LD_EXP 51
27286: PUSH
27287: LD_VAR 0 2
27291: ARRAY
27292: PPUSH
27293: LD_VAR 0 3
27297: PPUSH
27298: CALL_OW 74
27302: PPUSH
27303: CALL_OW 130
27307: GO 27367
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27309: LD_VAR 0 3
27313: PPUSH
27314: CALL_OW 256
27318: PUSH
27319: LD_INT 500
27321: LESS
27322: PUSH
27323: LD_VAR 0 3
27327: PPUSH
27328: LD_EXP 74
27332: PUSH
27333: LD_VAR 0 2
27337: ARRAY
27338: PPUSH
27339: CALL_OW 308
27343: NOT
27344: AND
27345: IFFALSE 27367
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27347: LD_VAR 0 3
27351: PPUSH
27352: LD_EXP 74
27356: PUSH
27357: LD_VAR 0 2
27361: ARRAY
27362: PPUSH
27363: CALL_OW 113
// end ;
27367: GO 27247
27369: POP
27370: POP
// end ; if tmp > 3 then
27371: LD_VAR 0 5
27375: PUSH
27376: LD_INT 3
27378: GREATER
27379: IFFALSE 27399
// tmp := ShrinkArray ( tmp , 4 ) ;
27381: LD_ADDR_VAR 0 5
27385: PUSH
27386: LD_VAR 0 5
27390: PPUSH
27391: LD_INT 4
27393: PPUSH
27394: CALL 84597 0 2
27398: ST_TO_ADDR
// if not tmp then
27399: LD_VAR 0 5
27403: NOT
27404: IFFALSE 27408
// continue ;
27406: GO 26838
// for j in tmp do
27408: LD_ADDR_VAR 0 3
27412: PUSH
27413: LD_VAR 0 5
27417: PUSH
27418: FOR_IN
27419: IFFALSE 27678
// begin if IsInUnit ( j ) then
27421: LD_VAR 0 3
27425: PPUSH
27426: CALL_OW 310
27430: IFFALSE 27441
// ComExitBuilding ( j ) ;
27432: LD_VAR 0 3
27436: PPUSH
27437: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27441: LD_VAR 0 3
27445: PUSH
27446: LD_EXP 52
27450: PUSH
27451: LD_VAR 0 2
27455: ARRAY
27456: IN
27457: NOT
27458: IFFALSE 27516
// begin SetTag ( j , 101 ) ;
27460: LD_VAR 0 3
27464: PPUSH
27465: LD_INT 101
27467: PPUSH
27468: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27472: LD_ADDR_EXP 52
27476: PUSH
27477: LD_EXP 52
27481: PPUSH
27482: LD_VAR 0 2
27486: PUSH
27487: LD_EXP 52
27491: PUSH
27492: LD_VAR 0 2
27496: ARRAY
27497: PUSH
27498: LD_INT 1
27500: PLUS
27501: PUSH
27502: EMPTY
27503: LIST
27504: LIST
27505: PPUSH
27506: LD_VAR 0 3
27510: PPUSH
27511: CALL 52906 0 3
27515: ST_TO_ADDR
// end ; wait ( 1 ) ;
27516: LD_INT 1
27518: PPUSH
27519: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27523: LD_ADDR_VAR 0 7
27527: PUSH
27528: LD_EXP 51
27532: PUSH
27533: LD_VAR 0 2
27537: ARRAY
27538: ST_TO_ADDR
// if mc_scan [ i ] then
27539: LD_EXP 73
27543: PUSH
27544: LD_VAR 0 2
27548: ARRAY
27549: IFFALSE 27611
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27551: LD_ADDR_VAR 0 7
27555: PUSH
27556: LD_EXP 51
27560: PUSH
27561: LD_VAR 0 2
27565: ARRAY
27566: PPUSH
27567: LD_INT 3
27569: PUSH
27570: LD_INT 30
27572: PUSH
27573: LD_INT 32
27575: PUSH
27576: EMPTY
27577: LIST
27578: LIST
27579: PUSH
27580: LD_INT 30
27582: PUSH
27583: LD_INT 33
27585: PUSH
27586: EMPTY
27587: LIST
27588: LIST
27589: PUSH
27590: LD_INT 30
27592: PUSH
27593: LD_INT 31
27595: PUSH
27596: EMPTY
27597: LIST
27598: LIST
27599: PUSH
27600: EMPTY
27601: LIST
27602: LIST
27603: LIST
27604: LIST
27605: PPUSH
27606: CALL_OW 72
27610: ST_TO_ADDR
// if not to_repair_tmp then
27611: LD_VAR 0 7
27615: NOT
27616: IFFALSE 27620
// continue ;
27618: GO 27418
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27620: LD_ADDR_VAR 0 8
27624: PUSH
27625: LD_VAR 0 7
27629: PPUSH
27630: LD_VAR 0 3
27634: PPUSH
27635: CALL_OW 74
27639: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27640: LD_VAR 0 8
27644: PPUSH
27645: LD_INT 16
27647: PPUSH
27648: CALL 55499 0 2
27652: PUSH
27653: LD_INT 4
27655: ARRAY
27656: PUSH
27657: LD_INT 10
27659: LESS
27660: IFFALSE 27676
// ComRepairBuilding ( j , to_repair ) ;
27662: LD_VAR 0 3
27666: PPUSH
27667: LD_VAR 0 8
27671: PPUSH
27672: CALL_OW 130
// end ;
27676: GO 27418
27678: POP
27679: POP
// end ;
27680: GO 26838
27682: POP
27683: POP
// end ;
27684: LD_VAR 0 1
27688: RET
// export function MC_Heal ; var i , j , tmp ; begin
27689: LD_INT 0
27691: PPUSH
27692: PPUSH
27693: PPUSH
27694: PPUSH
// if not mc_bases then
27695: LD_EXP 50
27699: NOT
27700: IFFALSE 27704
// exit ;
27702: GO 28106
// for i = 1 to mc_bases do
27704: LD_ADDR_VAR 0 2
27708: PUSH
27709: DOUBLE
27710: LD_INT 1
27712: DEC
27713: ST_TO_ADDR
27714: LD_EXP 50
27718: PUSH
27719: FOR_TO
27720: IFFALSE 28104
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27722: LD_EXP 53
27726: PUSH
27727: LD_VAR 0 2
27731: ARRAY
27732: PUSH
27733: LD_INT 1
27735: ARRAY
27736: NOT
27737: PUSH
27738: LD_EXP 53
27742: PUSH
27743: LD_VAR 0 2
27747: ARRAY
27748: PUSH
27749: LD_INT 2
27751: ARRAY
27752: NOT
27753: AND
27754: IFFALSE 27792
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27756: LD_ADDR_EXP 54
27760: PUSH
27761: LD_EXP 54
27765: PPUSH
27766: LD_VAR 0 2
27770: PPUSH
27771: EMPTY
27772: PPUSH
27773: CALL_OW 1
27777: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27778: LD_VAR 0 2
27782: PPUSH
27783: LD_INT 102
27785: PPUSH
27786: CALL 21927 0 2
// continue ;
27790: GO 27719
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27792: LD_ADDR_VAR 0 4
27796: PUSH
27797: LD_EXP 50
27801: PUSH
27802: LD_VAR 0 2
27806: ARRAY
27807: PPUSH
27808: LD_INT 25
27810: PUSH
27811: LD_INT 4
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: PPUSH
27818: CALL_OW 72
27822: ST_TO_ADDR
// if not tmp then
27823: LD_VAR 0 4
27827: NOT
27828: IFFALSE 27832
// continue ;
27830: GO 27719
// if mc_taming [ i ] then
27832: LD_EXP 81
27836: PUSH
27837: LD_VAR 0 2
27841: ARRAY
27842: IFFALSE 27866
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27844: LD_ADDR_EXP 81
27848: PUSH
27849: LD_EXP 81
27853: PPUSH
27854: LD_VAR 0 2
27858: PPUSH
27859: EMPTY
27860: PPUSH
27861: CALL_OW 1
27865: ST_TO_ADDR
// for j in tmp do
27866: LD_ADDR_VAR 0 3
27870: PUSH
27871: LD_VAR 0 4
27875: PUSH
27876: FOR_IN
27877: IFFALSE 28100
// begin if IsInUnit ( j ) then
27879: LD_VAR 0 3
27883: PPUSH
27884: CALL_OW 310
27888: IFFALSE 27899
// ComExitBuilding ( j ) ;
27890: LD_VAR 0 3
27894: PPUSH
27895: CALL_OW 122
// if not j in mc_healers [ i ] then
27899: LD_VAR 0 3
27903: PUSH
27904: LD_EXP 54
27908: PUSH
27909: LD_VAR 0 2
27913: ARRAY
27914: IN
27915: NOT
27916: IFFALSE 27962
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27918: LD_ADDR_EXP 54
27922: PUSH
27923: LD_EXP 54
27927: PPUSH
27928: LD_VAR 0 2
27932: PUSH
27933: LD_EXP 54
27937: PUSH
27938: LD_VAR 0 2
27942: ARRAY
27943: PUSH
27944: LD_INT 1
27946: PLUS
27947: PUSH
27948: EMPTY
27949: LIST
27950: LIST
27951: PPUSH
27952: LD_VAR 0 3
27956: PPUSH
27957: CALL 52906 0 3
27961: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
27962: LD_VAR 0 3
27966: PPUSH
27967: CALL_OW 110
27971: PUSH
27972: LD_INT 102
27974: NONEQUAL
27975: IFFALSE 27989
// SetTag ( j , 102 ) ;
27977: LD_VAR 0 3
27981: PPUSH
27982: LD_INT 102
27984: PPUSH
27985: CALL_OW 109
// Wait ( 3 ) ;
27989: LD_INT 3
27991: PPUSH
27992: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
27996: LD_EXP 53
28000: PUSH
28001: LD_VAR 0 2
28005: ARRAY
28006: PUSH
28007: LD_INT 1
28009: ARRAY
28010: IFFALSE 28042
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28012: LD_VAR 0 3
28016: PPUSH
28017: LD_EXP 53
28021: PUSH
28022: LD_VAR 0 2
28026: ARRAY
28027: PUSH
28028: LD_INT 1
28030: ARRAY
28031: PUSH
28032: LD_INT 1
28034: ARRAY
28035: PPUSH
28036: CALL_OW 128
28040: GO 28098
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28042: LD_VAR 0 3
28046: PPUSH
28047: CALL_OW 314
28051: NOT
28052: PUSH
28053: LD_EXP 53
28057: PUSH
28058: LD_VAR 0 2
28062: ARRAY
28063: PUSH
28064: LD_INT 2
28066: ARRAY
28067: AND
28068: IFFALSE 28098
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28070: LD_VAR 0 3
28074: PPUSH
28075: LD_EXP 53
28079: PUSH
28080: LD_VAR 0 2
28084: ARRAY
28085: PUSH
28086: LD_INT 2
28088: ARRAY
28089: PUSH
28090: LD_INT 1
28092: ARRAY
28093: PPUSH
28094: CALL_OW 128
// end ;
28098: GO 27876
28100: POP
28101: POP
// end ;
28102: GO 27719
28104: POP
28105: POP
// end ;
28106: LD_VAR 0 1
28110: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
28111: LD_INT 0
28113: PPUSH
28114: PPUSH
28115: PPUSH
28116: PPUSH
28117: PPUSH
// if not mc_bases then
28118: LD_EXP 50
28122: NOT
28123: IFFALSE 28127
// exit ;
28125: GO 29298
// for i = 1 to mc_bases do
28127: LD_ADDR_VAR 0 2
28131: PUSH
28132: DOUBLE
28133: LD_INT 1
28135: DEC
28136: ST_TO_ADDR
28137: LD_EXP 50
28141: PUSH
28142: FOR_TO
28143: IFFALSE 29296
// begin if mc_scan [ i ] then
28145: LD_EXP 73
28149: PUSH
28150: LD_VAR 0 2
28154: ARRAY
28155: IFFALSE 28159
// continue ;
28157: GO 28142
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28159: LD_EXP 55
28163: PUSH
28164: LD_VAR 0 2
28168: ARRAY
28169: NOT
28170: PUSH
28171: LD_EXP 57
28175: PUSH
28176: LD_VAR 0 2
28180: ARRAY
28181: NOT
28182: AND
28183: PUSH
28184: LD_EXP 56
28188: PUSH
28189: LD_VAR 0 2
28193: ARRAY
28194: AND
28195: IFFALSE 28233
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28197: LD_ADDR_EXP 56
28201: PUSH
28202: LD_EXP 56
28206: PPUSH
28207: LD_VAR 0 2
28211: PPUSH
28212: EMPTY
28213: PPUSH
28214: CALL_OW 1
28218: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28219: LD_VAR 0 2
28223: PPUSH
28224: LD_INT 103
28226: PPUSH
28227: CALL 21927 0 2
// continue ;
28231: GO 28142
// end ; if mc_construct_list [ i ] then
28233: LD_EXP 57
28237: PUSH
28238: LD_VAR 0 2
28242: ARRAY
28243: IFFALSE 28463
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28245: LD_ADDR_VAR 0 4
28249: PUSH
28250: LD_EXP 50
28254: PUSH
28255: LD_VAR 0 2
28259: ARRAY
28260: PPUSH
28261: LD_INT 25
28263: PUSH
28264: LD_INT 2
28266: PUSH
28267: EMPTY
28268: LIST
28269: LIST
28270: PPUSH
28271: CALL_OW 72
28275: PUSH
28276: LD_EXP 52
28280: PUSH
28281: LD_VAR 0 2
28285: ARRAY
28286: DIFF
28287: ST_TO_ADDR
// if not tmp then
28288: LD_VAR 0 4
28292: NOT
28293: IFFALSE 28297
// continue ;
28295: GO 28142
// for j in tmp do
28297: LD_ADDR_VAR 0 3
28301: PUSH
28302: LD_VAR 0 4
28306: PUSH
28307: FOR_IN
28308: IFFALSE 28459
// begin if not mc_builders [ i ] then
28310: LD_EXP 56
28314: PUSH
28315: LD_VAR 0 2
28319: ARRAY
28320: NOT
28321: IFFALSE 28379
// begin SetTag ( j , 103 ) ;
28323: LD_VAR 0 3
28327: PPUSH
28328: LD_INT 103
28330: PPUSH
28331: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28335: LD_ADDR_EXP 56
28339: PUSH
28340: LD_EXP 56
28344: PPUSH
28345: LD_VAR 0 2
28349: PUSH
28350: LD_EXP 56
28354: PUSH
28355: LD_VAR 0 2
28359: ARRAY
28360: PUSH
28361: LD_INT 1
28363: PLUS
28364: PUSH
28365: EMPTY
28366: LIST
28367: LIST
28368: PPUSH
28369: LD_VAR 0 3
28373: PPUSH
28374: CALL 52906 0 3
28378: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28379: LD_VAR 0 3
28383: PPUSH
28384: CALL_OW 310
28388: IFFALSE 28399
// ComExitBuilding ( j ) ;
28390: LD_VAR 0 3
28394: PPUSH
28395: CALL_OW 122
// wait ( 3 ) ;
28399: LD_INT 3
28401: PPUSH
28402: CALL_OW 67
// if not mc_construct_list [ i ] then
28406: LD_EXP 57
28410: PUSH
28411: LD_VAR 0 2
28415: ARRAY
28416: NOT
28417: IFFALSE 28421
// break ;
28419: GO 28459
// if not HasTask ( j ) then
28421: LD_VAR 0 3
28425: PPUSH
28426: CALL_OW 314
28430: NOT
28431: IFFALSE 28457
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28433: LD_VAR 0 3
28437: PPUSH
28438: LD_EXP 57
28442: PUSH
28443: LD_VAR 0 2
28447: ARRAY
28448: PUSH
28449: LD_INT 1
28451: ARRAY
28452: PPUSH
28453: CALL 55763 0 2
// end ;
28457: GO 28307
28459: POP
28460: POP
// end else
28461: GO 29294
// if mc_build_list [ i ] then
28463: LD_EXP 55
28467: PUSH
28468: LD_VAR 0 2
28472: ARRAY
28473: IFFALSE 29294
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28475: LD_ADDR_VAR 0 5
28479: PUSH
28480: LD_EXP 50
28484: PUSH
28485: LD_VAR 0 2
28489: ARRAY
28490: PPUSH
28491: LD_INT 2
28493: PUSH
28494: LD_INT 30
28496: PUSH
28497: LD_INT 0
28499: PUSH
28500: EMPTY
28501: LIST
28502: LIST
28503: PUSH
28504: LD_INT 30
28506: PUSH
28507: LD_INT 1
28509: PUSH
28510: EMPTY
28511: LIST
28512: LIST
28513: PUSH
28514: EMPTY
28515: LIST
28516: LIST
28517: LIST
28518: PPUSH
28519: CALL_OW 72
28523: ST_TO_ADDR
// if depot then
28524: LD_VAR 0 5
28528: IFFALSE 28546
// depot := depot [ 1 ] else
28530: LD_ADDR_VAR 0 5
28534: PUSH
28535: LD_VAR 0 5
28539: PUSH
28540: LD_INT 1
28542: ARRAY
28543: ST_TO_ADDR
28544: GO 28554
// depot := 0 ;
28546: LD_ADDR_VAR 0 5
28550: PUSH
28551: LD_INT 0
28553: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28554: LD_EXP 55
28558: PUSH
28559: LD_VAR 0 2
28563: ARRAY
28564: PUSH
28565: LD_INT 1
28567: ARRAY
28568: PUSH
28569: LD_INT 1
28571: ARRAY
28572: PPUSH
28573: CALL 55587 0 1
28577: PUSH
28578: LD_EXP 50
28582: PUSH
28583: LD_VAR 0 2
28587: ARRAY
28588: PPUSH
28589: LD_INT 2
28591: PUSH
28592: LD_INT 30
28594: PUSH
28595: LD_INT 2
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: LD_INT 30
28604: PUSH
28605: LD_INT 3
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: PUSH
28612: EMPTY
28613: LIST
28614: LIST
28615: LIST
28616: PPUSH
28617: CALL_OW 72
28621: NOT
28622: AND
28623: IFFALSE 28728
// begin for j = 1 to mc_build_list [ i ] do
28625: LD_ADDR_VAR 0 3
28629: PUSH
28630: DOUBLE
28631: LD_INT 1
28633: DEC
28634: ST_TO_ADDR
28635: LD_EXP 55
28639: PUSH
28640: LD_VAR 0 2
28644: ARRAY
28645: PUSH
28646: FOR_TO
28647: IFFALSE 28726
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28649: LD_EXP 55
28653: PUSH
28654: LD_VAR 0 2
28658: ARRAY
28659: PUSH
28660: LD_VAR 0 3
28664: ARRAY
28665: PUSH
28666: LD_INT 1
28668: ARRAY
28669: PUSH
28670: LD_INT 2
28672: EQUAL
28673: IFFALSE 28724
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28675: LD_ADDR_EXP 55
28679: PUSH
28680: LD_EXP 55
28684: PPUSH
28685: LD_VAR 0 2
28689: PPUSH
28690: LD_EXP 55
28694: PUSH
28695: LD_VAR 0 2
28699: ARRAY
28700: PPUSH
28701: LD_VAR 0 3
28705: PPUSH
28706: LD_INT 1
28708: PPUSH
28709: LD_INT 0
28711: PPUSH
28712: CALL 52324 0 4
28716: PPUSH
28717: CALL_OW 1
28721: ST_TO_ADDR
// break ;
28722: GO 28726
// end ;
28724: GO 28646
28726: POP
28727: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28728: LD_EXP 55
28732: PUSH
28733: LD_VAR 0 2
28737: ARRAY
28738: PUSH
28739: LD_INT 1
28741: ARRAY
28742: PUSH
28743: LD_INT 1
28745: ARRAY
28746: PUSH
28747: LD_INT 0
28749: EQUAL
28750: PUSH
28751: LD_VAR 0 5
28755: PUSH
28756: LD_VAR 0 5
28760: PPUSH
28761: LD_EXP 55
28765: PUSH
28766: LD_VAR 0 2
28770: ARRAY
28771: PUSH
28772: LD_INT 1
28774: ARRAY
28775: PUSH
28776: LD_INT 1
28778: ARRAY
28779: PPUSH
28780: LD_EXP 55
28784: PUSH
28785: LD_VAR 0 2
28789: ARRAY
28790: PUSH
28791: LD_INT 1
28793: ARRAY
28794: PUSH
28795: LD_INT 2
28797: ARRAY
28798: PPUSH
28799: LD_EXP 55
28803: PUSH
28804: LD_VAR 0 2
28808: ARRAY
28809: PUSH
28810: LD_INT 1
28812: ARRAY
28813: PUSH
28814: LD_INT 3
28816: ARRAY
28817: PPUSH
28818: LD_EXP 55
28822: PUSH
28823: LD_VAR 0 2
28827: ARRAY
28828: PUSH
28829: LD_INT 1
28831: ARRAY
28832: PUSH
28833: LD_INT 4
28835: ARRAY
28836: PPUSH
28837: CALL 60654 0 5
28841: AND
28842: OR
28843: IFFALSE 29124
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28845: LD_ADDR_VAR 0 4
28849: PUSH
28850: LD_EXP 50
28854: PUSH
28855: LD_VAR 0 2
28859: ARRAY
28860: PPUSH
28861: LD_INT 25
28863: PUSH
28864: LD_INT 2
28866: PUSH
28867: EMPTY
28868: LIST
28869: LIST
28870: PPUSH
28871: CALL_OW 72
28875: PUSH
28876: LD_EXP 52
28880: PUSH
28881: LD_VAR 0 2
28885: ARRAY
28886: DIFF
28887: ST_TO_ADDR
// if not tmp then
28888: LD_VAR 0 4
28892: NOT
28893: IFFALSE 28897
// continue ;
28895: GO 28142
// for j in tmp do
28897: LD_ADDR_VAR 0 3
28901: PUSH
28902: LD_VAR 0 4
28906: PUSH
28907: FOR_IN
28908: IFFALSE 29120
// begin if not mc_builders [ i ] then
28910: LD_EXP 56
28914: PUSH
28915: LD_VAR 0 2
28919: ARRAY
28920: NOT
28921: IFFALSE 28979
// begin SetTag ( j , 103 ) ;
28923: LD_VAR 0 3
28927: PPUSH
28928: LD_INT 103
28930: PPUSH
28931: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28935: LD_ADDR_EXP 56
28939: PUSH
28940: LD_EXP 56
28944: PPUSH
28945: LD_VAR 0 2
28949: PUSH
28950: LD_EXP 56
28954: PUSH
28955: LD_VAR 0 2
28959: ARRAY
28960: PUSH
28961: LD_INT 1
28963: PLUS
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PPUSH
28969: LD_VAR 0 3
28973: PPUSH
28974: CALL 52906 0 3
28978: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28979: LD_VAR 0 3
28983: PPUSH
28984: CALL_OW 310
28988: IFFALSE 28999
// ComExitBuilding ( j ) ;
28990: LD_VAR 0 3
28994: PPUSH
28995: CALL_OW 122
// wait ( 3 ) ;
28999: LD_INT 3
29001: PPUSH
29002: CALL_OW 67
// if not mc_build_list [ i ] then
29006: LD_EXP 55
29010: PUSH
29011: LD_VAR 0 2
29015: ARRAY
29016: NOT
29017: IFFALSE 29021
// break ;
29019: GO 29120
// if not HasTask ( j ) then
29021: LD_VAR 0 3
29025: PPUSH
29026: CALL_OW 314
29030: NOT
29031: IFFALSE 29118
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29033: LD_VAR 0 3
29037: PPUSH
29038: LD_EXP 55
29042: PUSH
29043: LD_VAR 0 2
29047: ARRAY
29048: PUSH
29049: LD_INT 1
29051: ARRAY
29052: PUSH
29053: LD_INT 1
29055: ARRAY
29056: PPUSH
29057: LD_EXP 55
29061: PUSH
29062: LD_VAR 0 2
29066: ARRAY
29067: PUSH
29068: LD_INT 1
29070: ARRAY
29071: PUSH
29072: LD_INT 2
29074: ARRAY
29075: PPUSH
29076: LD_EXP 55
29080: PUSH
29081: LD_VAR 0 2
29085: ARRAY
29086: PUSH
29087: LD_INT 1
29089: ARRAY
29090: PUSH
29091: LD_INT 3
29093: ARRAY
29094: PPUSH
29095: LD_EXP 55
29099: PUSH
29100: LD_VAR 0 2
29104: ARRAY
29105: PUSH
29106: LD_INT 1
29108: ARRAY
29109: PUSH
29110: LD_INT 4
29112: ARRAY
29113: PPUSH
29114: CALL_OW 145
// end ;
29118: GO 28907
29120: POP
29121: POP
// end else
29122: GO 29294
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29124: LD_EXP 50
29128: PUSH
29129: LD_VAR 0 2
29133: ARRAY
29134: PPUSH
29135: LD_EXP 55
29139: PUSH
29140: LD_VAR 0 2
29144: ARRAY
29145: PUSH
29146: LD_INT 1
29148: ARRAY
29149: PUSH
29150: LD_INT 1
29152: ARRAY
29153: PPUSH
29154: LD_EXP 55
29158: PUSH
29159: LD_VAR 0 2
29163: ARRAY
29164: PUSH
29165: LD_INT 1
29167: ARRAY
29168: PUSH
29169: LD_INT 2
29171: ARRAY
29172: PPUSH
29173: LD_EXP 55
29177: PUSH
29178: LD_VAR 0 2
29182: ARRAY
29183: PUSH
29184: LD_INT 1
29186: ARRAY
29187: PUSH
29188: LD_INT 3
29190: ARRAY
29191: PPUSH
29192: LD_EXP 55
29196: PUSH
29197: LD_VAR 0 2
29201: ARRAY
29202: PUSH
29203: LD_INT 1
29205: ARRAY
29206: PUSH
29207: LD_INT 4
29209: ARRAY
29210: PPUSH
29211: LD_EXP 50
29215: PUSH
29216: LD_VAR 0 2
29220: ARRAY
29221: PPUSH
29222: LD_INT 21
29224: PUSH
29225: LD_INT 3
29227: PUSH
29228: EMPTY
29229: LIST
29230: LIST
29231: PPUSH
29232: CALL_OW 72
29236: PPUSH
29237: EMPTY
29238: PPUSH
29239: CALL 59784 0 7
29243: NOT
29244: IFFALSE 29294
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29246: LD_ADDR_EXP 55
29250: PUSH
29251: LD_EXP 55
29255: PPUSH
29256: LD_VAR 0 2
29260: PPUSH
29261: LD_EXP 55
29265: PUSH
29266: LD_VAR 0 2
29270: ARRAY
29271: PPUSH
29272: LD_INT 1
29274: PPUSH
29275: LD_INT 1
29277: NEG
29278: PPUSH
29279: LD_INT 0
29281: PPUSH
29282: CALL 52324 0 4
29286: PPUSH
29287: CALL_OW 1
29291: ST_TO_ADDR
// continue ;
29292: GO 28142
// end ; end ; end ;
29294: GO 28142
29296: POP
29297: POP
// end ;
29298: LD_VAR 0 1
29302: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29303: LD_INT 0
29305: PPUSH
29306: PPUSH
29307: PPUSH
29308: PPUSH
29309: PPUSH
29310: PPUSH
// if not mc_bases then
29311: LD_EXP 50
29315: NOT
29316: IFFALSE 29320
// exit ;
29318: GO 29747
// for i = 1 to mc_bases do
29320: LD_ADDR_VAR 0 2
29324: PUSH
29325: DOUBLE
29326: LD_INT 1
29328: DEC
29329: ST_TO_ADDR
29330: LD_EXP 50
29334: PUSH
29335: FOR_TO
29336: IFFALSE 29745
// begin tmp := mc_build_upgrade [ i ] ;
29338: LD_ADDR_VAR 0 4
29342: PUSH
29343: LD_EXP 82
29347: PUSH
29348: LD_VAR 0 2
29352: ARRAY
29353: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29354: LD_ADDR_VAR 0 6
29358: PUSH
29359: LD_EXP 83
29363: PUSH
29364: LD_VAR 0 2
29368: ARRAY
29369: PPUSH
29370: LD_INT 2
29372: PUSH
29373: LD_INT 30
29375: PUSH
29376: LD_INT 6
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 30
29385: PUSH
29386: LD_INT 7
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: LIST
29397: PPUSH
29398: CALL_OW 72
29402: ST_TO_ADDR
// if not tmp and not lab then
29403: LD_VAR 0 4
29407: NOT
29408: PUSH
29409: LD_VAR 0 6
29413: NOT
29414: AND
29415: IFFALSE 29419
// continue ;
29417: GO 29335
// if tmp then
29419: LD_VAR 0 4
29423: IFFALSE 29543
// for j in tmp do
29425: LD_ADDR_VAR 0 3
29429: PUSH
29430: LD_VAR 0 4
29434: PUSH
29435: FOR_IN
29436: IFFALSE 29541
// begin if UpgradeCost ( j ) then
29438: LD_VAR 0 3
29442: PPUSH
29443: CALL 59444 0 1
29447: IFFALSE 29539
// begin ComUpgrade ( j ) ;
29449: LD_VAR 0 3
29453: PPUSH
29454: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29458: LD_ADDR_EXP 82
29462: PUSH
29463: LD_EXP 82
29467: PPUSH
29468: LD_VAR 0 2
29472: PPUSH
29473: LD_EXP 82
29477: PUSH
29478: LD_VAR 0 2
29482: ARRAY
29483: PUSH
29484: LD_VAR 0 3
29488: DIFF
29489: PPUSH
29490: CALL_OW 1
29494: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29495: LD_ADDR_EXP 57
29499: PUSH
29500: LD_EXP 57
29504: PPUSH
29505: LD_VAR 0 2
29509: PUSH
29510: LD_EXP 57
29514: PUSH
29515: LD_VAR 0 2
29519: ARRAY
29520: PUSH
29521: LD_INT 1
29523: PLUS
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PPUSH
29529: LD_VAR 0 3
29533: PPUSH
29534: CALL 52906 0 3
29538: ST_TO_ADDR
// end ; end ;
29539: GO 29435
29541: POP
29542: POP
// if not lab or not mc_lab_upgrade [ i ] then
29543: LD_VAR 0 6
29547: NOT
29548: PUSH
29549: LD_EXP 84
29553: PUSH
29554: LD_VAR 0 2
29558: ARRAY
29559: NOT
29560: OR
29561: IFFALSE 29565
// continue ;
29563: GO 29335
// for j in lab do
29565: LD_ADDR_VAR 0 3
29569: PUSH
29570: LD_VAR 0 6
29574: PUSH
29575: FOR_IN
29576: IFFALSE 29741
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29578: LD_VAR 0 3
29582: PPUSH
29583: CALL_OW 266
29587: PUSH
29588: LD_INT 6
29590: PUSH
29591: LD_INT 7
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: IN
29598: PUSH
29599: LD_VAR 0 3
29603: PPUSH
29604: CALL_OW 461
29608: PUSH
29609: LD_INT 1
29611: NONEQUAL
29612: AND
29613: IFFALSE 29739
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29615: LD_VAR 0 3
29619: PPUSH
29620: LD_EXP 84
29624: PUSH
29625: LD_VAR 0 2
29629: ARRAY
29630: PUSH
29631: LD_INT 1
29633: ARRAY
29634: PPUSH
29635: CALL 59649 0 2
29639: IFFALSE 29739
// begin ComCancel ( j ) ;
29641: LD_VAR 0 3
29645: PPUSH
29646: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29650: LD_VAR 0 3
29654: PPUSH
29655: LD_EXP 84
29659: PUSH
29660: LD_VAR 0 2
29664: ARRAY
29665: PUSH
29666: LD_INT 1
29668: ARRAY
29669: PPUSH
29670: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29674: LD_VAR 0 3
29678: PUSH
29679: LD_EXP 57
29683: PUSH
29684: LD_VAR 0 2
29688: ARRAY
29689: IN
29690: NOT
29691: IFFALSE 29737
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29693: LD_ADDR_EXP 57
29697: PUSH
29698: LD_EXP 57
29702: PPUSH
29703: LD_VAR 0 2
29707: PUSH
29708: LD_EXP 57
29712: PUSH
29713: LD_VAR 0 2
29717: ARRAY
29718: PUSH
29719: LD_INT 1
29721: PLUS
29722: PUSH
29723: EMPTY
29724: LIST
29725: LIST
29726: PPUSH
29727: LD_VAR 0 3
29731: PPUSH
29732: CALL 52906 0 3
29736: ST_TO_ADDR
// break ;
29737: GO 29741
// end ; end ; end ;
29739: GO 29575
29741: POP
29742: POP
// end ;
29743: GO 29335
29745: POP
29746: POP
// end ;
29747: LD_VAR 0 1
29751: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29752: LD_INT 0
29754: PPUSH
29755: PPUSH
29756: PPUSH
29757: PPUSH
29758: PPUSH
29759: PPUSH
29760: PPUSH
29761: PPUSH
29762: PPUSH
// if not mc_bases then
29763: LD_EXP 50
29767: NOT
29768: IFFALSE 29772
// exit ;
29770: GO 30177
// for i = 1 to mc_bases do
29772: LD_ADDR_VAR 0 2
29776: PUSH
29777: DOUBLE
29778: LD_INT 1
29780: DEC
29781: ST_TO_ADDR
29782: LD_EXP 50
29786: PUSH
29787: FOR_TO
29788: IFFALSE 30175
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
29790: LD_EXP 58
29794: PUSH
29795: LD_VAR 0 2
29799: ARRAY
29800: NOT
29801: PUSH
29802: LD_EXP 50
29806: PUSH
29807: LD_VAR 0 2
29811: ARRAY
29812: PPUSH
29813: LD_INT 30
29815: PUSH
29816: LD_INT 3
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PPUSH
29823: CALL_OW 72
29827: NOT
29828: OR
29829: IFFALSE 29833
// continue ;
29831: GO 29787
// busy := false ;
29833: LD_ADDR_VAR 0 8
29837: PUSH
29838: LD_INT 0
29840: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29841: LD_ADDR_VAR 0 4
29845: PUSH
29846: LD_EXP 50
29850: PUSH
29851: LD_VAR 0 2
29855: ARRAY
29856: PPUSH
29857: LD_INT 30
29859: PUSH
29860: LD_INT 3
29862: PUSH
29863: EMPTY
29864: LIST
29865: LIST
29866: PPUSH
29867: CALL_OW 72
29871: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
29872: LD_ADDR_VAR 0 6
29876: PUSH
29877: LD_EXP 58
29881: PUSH
29882: LD_VAR 0 2
29886: ARRAY
29887: PPUSH
29888: LD_INT 2
29890: PUSH
29891: LD_INT 30
29893: PUSH
29894: LD_INT 32
29896: PUSH
29897: EMPTY
29898: LIST
29899: LIST
29900: PUSH
29901: LD_INT 30
29903: PUSH
29904: LD_INT 33
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: LIST
29915: PPUSH
29916: CALL_OW 72
29920: ST_TO_ADDR
// if not t then
29921: LD_VAR 0 6
29925: NOT
29926: IFFALSE 29930
// continue ;
29928: GO 29787
// for j in tmp do
29930: LD_ADDR_VAR 0 3
29934: PUSH
29935: LD_VAR 0 4
29939: PUSH
29940: FOR_IN
29941: IFFALSE 29971
// if not BuildingStatus ( j ) = bs_idle then
29943: LD_VAR 0 3
29947: PPUSH
29948: CALL_OW 461
29952: PUSH
29953: LD_INT 2
29955: EQUAL
29956: NOT
29957: IFFALSE 29969
// begin busy := true ;
29959: LD_ADDR_VAR 0 8
29963: PUSH
29964: LD_INT 1
29966: ST_TO_ADDR
// break ;
29967: GO 29971
// end ;
29969: GO 29940
29971: POP
29972: POP
// if busy then
29973: LD_VAR 0 8
29977: IFFALSE 29981
// continue ;
29979: GO 29787
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
29981: LD_ADDR_VAR 0 7
29985: PUSH
29986: LD_VAR 0 6
29990: PPUSH
29991: LD_INT 35
29993: PUSH
29994: LD_INT 0
29996: PUSH
29997: EMPTY
29998: LIST
29999: LIST
30000: PPUSH
30001: CALL_OW 72
30005: ST_TO_ADDR
// if tw then
30006: LD_VAR 0 7
30010: IFFALSE 30087
// begin tw := tw [ 1 ] ;
30012: LD_ADDR_VAR 0 7
30016: PUSH
30017: LD_VAR 0 7
30021: PUSH
30022: LD_INT 1
30024: ARRAY
30025: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30026: LD_ADDR_VAR 0 9
30030: PUSH
30031: LD_VAR 0 7
30035: PPUSH
30036: LD_EXP 75
30040: PUSH
30041: LD_VAR 0 2
30045: ARRAY
30046: PPUSH
30047: CALL 57911 0 2
30051: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30052: LD_EXP 89
30056: PUSH
30057: LD_VAR 0 2
30061: ARRAY
30062: IFFALSE 30085
// if not weapon in mc_allowed_tower_weapons [ i ] then
30064: LD_VAR 0 9
30068: PUSH
30069: LD_EXP 89
30073: PUSH
30074: LD_VAR 0 2
30078: ARRAY
30079: IN
30080: NOT
30081: IFFALSE 30085
// continue ;
30083: GO 29787
// end else
30085: GO 30150
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30087: LD_ADDR_VAR 0 5
30091: PUSH
30092: LD_EXP 58
30096: PUSH
30097: LD_VAR 0 2
30101: ARRAY
30102: PPUSH
30103: LD_VAR 0 4
30107: PPUSH
30108: CALL 83830 0 2
30112: ST_TO_ADDR
// if not tmp2 then
30113: LD_VAR 0 5
30117: NOT
30118: IFFALSE 30122
// continue ;
30120: GO 29787
// tw := tmp2 [ 1 ] ;
30122: LD_ADDR_VAR 0 7
30126: PUSH
30127: LD_VAR 0 5
30131: PUSH
30132: LD_INT 1
30134: ARRAY
30135: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30136: LD_ADDR_VAR 0 9
30140: PUSH
30141: LD_VAR 0 5
30145: PUSH
30146: LD_INT 2
30148: ARRAY
30149: ST_TO_ADDR
// end ; if not weapon then
30150: LD_VAR 0 9
30154: NOT
30155: IFFALSE 30159
// continue ;
30157: GO 29787
// ComPlaceWeapon ( tw , weapon ) ;
30159: LD_VAR 0 7
30163: PPUSH
30164: LD_VAR 0 9
30168: PPUSH
30169: CALL_OW 148
// end ;
30173: GO 29787
30175: POP
30176: POP
// end ;
30177: LD_VAR 0 1
30181: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30182: LD_INT 0
30184: PPUSH
30185: PPUSH
30186: PPUSH
30187: PPUSH
30188: PPUSH
30189: PPUSH
30190: PPUSH
// if not mc_bases then
30191: LD_EXP 50
30195: NOT
30196: IFFALSE 30200
// exit ;
30198: GO 30968
// for i = 1 to mc_bases do
30200: LD_ADDR_VAR 0 2
30204: PUSH
30205: DOUBLE
30206: LD_INT 1
30208: DEC
30209: ST_TO_ADDR
30210: LD_EXP 50
30214: PUSH
30215: FOR_TO
30216: IFFALSE 30966
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30218: LD_EXP 63
30222: PUSH
30223: LD_VAR 0 2
30227: ARRAY
30228: NOT
30229: PUSH
30230: LD_EXP 63
30234: PUSH
30235: LD_VAR 0 2
30239: ARRAY
30240: PUSH
30241: LD_EXP 64
30245: PUSH
30246: LD_VAR 0 2
30250: ARRAY
30251: EQUAL
30252: OR
30253: PUSH
30254: LD_EXP 73
30258: PUSH
30259: LD_VAR 0 2
30263: ARRAY
30264: OR
30265: IFFALSE 30269
// continue ;
30267: GO 30215
// if mc_miners [ i ] then
30269: LD_EXP 64
30273: PUSH
30274: LD_VAR 0 2
30278: ARRAY
30279: IFFALSE 30653
// begin for j = mc_miners [ i ] downto 1 do
30281: LD_ADDR_VAR 0 3
30285: PUSH
30286: DOUBLE
30287: LD_EXP 64
30291: PUSH
30292: LD_VAR 0 2
30296: ARRAY
30297: INC
30298: ST_TO_ADDR
30299: LD_INT 1
30301: PUSH
30302: FOR_DOWNTO
30303: IFFALSE 30651
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30305: LD_EXP 64
30309: PUSH
30310: LD_VAR 0 2
30314: ARRAY
30315: PUSH
30316: LD_VAR 0 3
30320: ARRAY
30321: PPUSH
30322: CALL_OW 301
30326: PUSH
30327: LD_EXP 64
30331: PUSH
30332: LD_VAR 0 2
30336: ARRAY
30337: PUSH
30338: LD_VAR 0 3
30342: ARRAY
30343: PPUSH
30344: CALL_OW 257
30348: PUSH
30349: LD_INT 1
30351: NONEQUAL
30352: OR
30353: IFFALSE 30416
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30355: LD_ADDR_VAR 0 5
30359: PUSH
30360: LD_EXP 64
30364: PUSH
30365: LD_VAR 0 2
30369: ARRAY
30370: PUSH
30371: LD_EXP 64
30375: PUSH
30376: LD_VAR 0 2
30380: ARRAY
30381: PUSH
30382: LD_VAR 0 3
30386: ARRAY
30387: DIFF
30388: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30389: LD_ADDR_EXP 64
30393: PUSH
30394: LD_EXP 64
30398: PPUSH
30399: LD_VAR 0 2
30403: PPUSH
30404: LD_VAR 0 5
30408: PPUSH
30409: CALL_OW 1
30413: ST_TO_ADDR
// continue ;
30414: GO 30302
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30416: LD_EXP 64
30420: PUSH
30421: LD_VAR 0 2
30425: ARRAY
30426: PUSH
30427: LD_VAR 0 3
30431: ARRAY
30432: PPUSH
30433: CALL_OW 257
30437: PUSH
30438: LD_INT 1
30440: EQUAL
30441: PUSH
30442: LD_EXP 64
30446: PUSH
30447: LD_VAR 0 2
30451: ARRAY
30452: PUSH
30453: LD_VAR 0 3
30457: ARRAY
30458: PPUSH
30459: CALL_OW 459
30463: NOT
30464: AND
30465: PUSH
30466: LD_EXP 64
30470: PUSH
30471: LD_VAR 0 2
30475: ARRAY
30476: PUSH
30477: LD_VAR 0 3
30481: ARRAY
30482: PPUSH
30483: CALL_OW 314
30487: NOT
30488: AND
30489: IFFALSE 30649
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30491: LD_EXP 64
30495: PUSH
30496: LD_VAR 0 2
30500: ARRAY
30501: PUSH
30502: LD_VAR 0 3
30506: ARRAY
30507: PPUSH
30508: CALL_OW 310
30512: IFFALSE 30535
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30514: LD_EXP 64
30518: PUSH
30519: LD_VAR 0 2
30523: ARRAY
30524: PUSH
30525: LD_VAR 0 3
30529: ARRAY
30530: PPUSH
30531: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30535: LD_EXP 64
30539: PUSH
30540: LD_VAR 0 2
30544: ARRAY
30545: PUSH
30546: LD_VAR 0 3
30550: ARRAY
30551: PPUSH
30552: CALL_OW 314
30556: NOT
30557: IFFALSE 30649
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30559: LD_ADDR_VAR 0 7
30563: PUSH
30564: LD_INT 1
30566: PPUSH
30567: LD_EXP 63
30571: PUSH
30572: LD_VAR 0 2
30576: ARRAY
30577: PPUSH
30578: CALL_OW 12
30582: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30583: LD_EXP 64
30587: PUSH
30588: LD_VAR 0 2
30592: ARRAY
30593: PUSH
30594: LD_VAR 0 3
30598: ARRAY
30599: PPUSH
30600: LD_EXP 63
30604: PUSH
30605: LD_VAR 0 2
30609: ARRAY
30610: PUSH
30611: LD_VAR 0 7
30615: ARRAY
30616: PUSH
30617: LD_INT 1
30619: ARRAY
30620: PPUSH
30621: LD_EXP 63
30625: PUSH
30626: LD_VAR 0 2
30630: ARRAY
30631: PUSH
30632: LD_VAR 0 7
30636: ARRAY
30637: PUSH
30638: LD_INT 2
30640: ARRAY
30641: PPUSH
30642: LD_INT 0
30644: PPUSH
30645: CALL_OW 193
// end ; end ; end ;
30649: GO 30302
30651: POP
30652: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30653: LD_ADDR_VAR 0 5
30657: PUSH
30658: LD_EXP 50
30662: PUSH
30663: LD_VAR 0 2
30667: ARRAY
30668: PPUSH
30669: LD_INT 2
30671: PUSH
30672: LD_INT 30
30674: PUSH
30675: LD_INT 4
30677: PUSH
30678: EMPTY
30679: LIST
30680: LIST
30681: PUSH
30682: LD_INT 30
30684: PUSH
30685: LD_INT 5
30687: PUSH
30688: EMPTY
30689: LIST
30690: LIST
30691: PUSH
30692: LD_INT 30
30694: PUSH
30695: LD_INT 32
30697: PUSH
30698: EMPTY
30699: LIST
30700: LIST
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: LIST
30706: LIST
30707: PPUSH
30708: CALL_OW 72
30712: ST_TO_ADDR
// if not tmp then
30713: LD_VAR 0 5
30717: NOT
30718: IFFALSE 30722
// continue ;
30720: GO 30215
// list := [ ] ;
30722: LD_ADDR_VAR 0 6
30726: PUSH
30727: EMPTY
30728: ST_TO_ADDR
// for j in tmp do
30729: LD_ADDR_VAR 0 3
30733: PUSH
30734: LD_VAR 0 5
30738: PUSH
30739: FOR_IN
30740: IFFALSE 30809
// begin for k in UnitsInside ( j ) do
30742: LD_ADDR_VAR 0 4
30746: PUSH
30747: LD_VAR 0 3
30751: PPUSH
30752: CALL_OW 313
30756: PUSH
30757: FOR_IN
30758: IFFALSE 30805
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30760: LD_VAR 0 4
30764: PPUSH
30765: CALL_OW 257
30769: PUSH
30770: LD_INT 1
30772: EQUAL
30773: PUSH
30774: LD_VAR 0 4
30778: PPUSH
30779: CALL_OW 459
30783: NOT
30784: AND
30785: IFFALSE 30803
// list := list ^ k ;
30787: LD_ADDR_VAR 0 6
30791: PUSH
30792: LD_VAR 0 6
30796: PUSH
30797: LD_VAR 0 4
30801: ADD
30802: ST_TO_ADDR
30803: GO 30757
30805: POP
30806: POP
// end ;
30807: GO 30739
30809: POP
30810: POP
// list := list diff mc_miners [ i ] ;
30811: LD_ADDR_VAR 0 6
30815: PUSH
30816: LD_VAR 0 6
30820: PUSH
30821: LD_EXP 64
30825: PUSH
30826: LD_VAR 0 2
30830: ARRAY
30831: DIFF
30832: ST_TO_ADDR
// if not list then
30833: LD_VAR 0 6
30837: NOT
30838: IFFALSE 30842
// continue ;
30840: GO 30215
// k := mc_mines [ i ] - mc_miners [ i ] ;
30842: LD_ADDR_VAR 0 4
30846: PUSH
30847: LD_EXP 63
30851: PUSH
30852: LD_VAR 0 2
30856: ARRAY
30857: PUSH
30858: LD_EXP 64
30862: PUSH
30863: LD_VAR 0 2
30867: ARRAY
30868: MINUS
30869: ST_TO_ADDR
// if k > list then
30870: LD_VAR 0 4
30874: PUSH
30875: LD_VAR 0 6
30879: GREATER
30880: IFFALSE 30892
// k := list ;
30882: LD_ADDR_VAR 0 4
30886: PUSH
30887: LD_VAR 0 6
30891: ST_TO_ADDR
// for j = 1 to k do
30892: LD_ADDR_VAR 0 3
30896: PUSH
30897: DOUBLE
30898: LD_INT 1
30900: DEC
30901: ST_TO_ADDR
30902: LD_VAR 0 4
30906: PUSH
30907: FOR_TO
30908: IFFALSE 30962
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30910: LD_ADDR_EXP 64
30914: PUSH
30915: LD_EXP 64
30919: PPUSH
30920: LD_VAR 0 2
30924: PUSH
30925: LD_EXP 64
30929: PUSH
30930: LD_VAR 0 2
30934: ARRAY
30935: PUSH
30936: LD_INT 1
30938: PLUS
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PPUSH
30944: LD_VAR 0 6
30948: PUSH
30949: LD_VAR 0 3
30953: ARRAY
30954: PPUSH
30955: CALL 52906 0 3
30959: ST_TO_ADDR
30960: GO 30907
30962: POP
30963: POP
// end ;
30964: GO 30215
30966: POP
30967: POP
// end ;
30968: LD_VAR 0 1
30972: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30973: LD_INT 0
30975: PPUSH
30976: PPUSH
30977: PPUSH
30978: PPUSH
30979: PPUSH
30980: PPUSH
30981: PPUSH
30982: PPUSH
30983: PPUSH
30984: PPUSH
// if not mc_bases then
30985: LD_EXP 50
30989: NOT
30990: IFFALSE 30994
// exit ;
30992: GO 32744
// for i = 1 to mc_bases do
30994: LD_ADDR_VAR 0 2
30998: PUSH
30999: DOUBLE
31000: LD_INT 1
31002: DEC
31003: ST_TO_ADDR
31004: LD_EXP 50
31008: PUSH
31009: FOR_TO
31010: IFFALSE 32742
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31012: LD_EXP 50
31016: PUSH
31017: LD_VAR 0 2
31021: ARRAY
31022: NOT
31023: PUSH
31024: LD_EXP 57
31028: PUSH
31029: LD_VAR 0 2
31033: ARRAY
31034: OR
31035: IFFALSE 31039
// continue ;
31037: GO 31009
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31039: LD_EXP 66
31043: PUSH
31044: LD_VAR 0 2
31048: ARRAY
31049: NOT
31050: PUSH
31051: LD_EXP 67
31055: PUSH
31056: LD_VAR 0 2
31060: ARRAY
31061: AND
31062: IFFALSE 31100
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31064: LD_ADDR_EXP 67
31068: PUSH
31069: LD_EXP 67
31073: PPUSH
31074: LD_VAR 0 2
31078: PPUSH
31079: EMPTY
31080: PPUSH
31081: CALL_OW 1
31085: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31086: LD_VAR 0 2
31090: PPUSH
31091: LD_INT 107
31093: PPUSH
31094: CALL 21927 0 2
// continue ;
31098: GO 31009
// end ; target := [ ] ;
31100: LD_ADDR_VAR 0 6
31104: PUSH
31105: EMPTY
31106: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31107: LD_ADDR_VAR 0 3
31111: PUSH
31112: DOUBLE
31113: LD_EXP 66
31117: PUSH
31118: LD_VAR 0 2
31122: ARRAY
31123: INC
31124: ST_TO_ADDR
31125: LD_INT 1
31127: PUSH
31128: FOR_DOWNTO
31129: IFFALSE 31389
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31131: LD_EXP 66
31135: PUSH
31136: LD_VAR 0 2
31140: ARRAY
31141: PUSH
31142: LD_VAR 0 3
31146: ARRAY
31147: PUSH
31148: LD_INT 2
31150: ARRAY
31151: PPUSH
31152: LD_EXP 66
31156: PUSH
31157: LD_VAR 0 2
31161: ARRAY
31162: PUSH
31163: LD_VAR 0 3
31167: ARRAY
31168: PUSH
31169: LD_INT 3
31171: ARRAY
31172: PPUSH
31173: CALL_OW 488
31177: PUSH
31178: LD_EXP 66
31182: PUSH
31183: LD_VAR 0 2
31187: ARRAY
31188: PUSH
31189: LD_VAR 0 3
31193: ARRAY
31194: PUSH
31195: LD_INT 2
31197: ARRAY
31198: PPUSH
31199: LD_EXP 66
31203: PUSH
31204: LD_VAR 0 2
31208: ARRAY
31209: PUSH
31210: LD_VAR 0 3
31214: ARRAY
31215: PUSH
31216: LD_INT 3
31218: ARRAY
31219: PPUSH
31220: CALL_OW 284
31224: PUSH
31225: LD_INT 0
31227: EQUAL
31228: AND
31229: IFFALSE 31284
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31231: LD_ADDR_VAR 0 5
31235: PUSH
31236: LD_EXP 66
31240: PUSH
31241: LD_VAR 0 2
31245: ARRAY
31246: PPUSH
31247: LD_VAR 0 3
31251: PPUSH
31252: CALL_OW 3
31256: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31257: LD_ADDR_EXP 66
31261: PUSH
31262: LD_EXP 66
31266: PPUSH
31267: LD_VAR 0 2
31271: PPUSH
31272: LD_VAR 0 5
31276: PPUSH
31277: CALL_OW 1
31281: ST_TO_ADDR
// continue ;
31282: GO 31128
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31284: LD_EXP 50
31288: PUSH
31289: LD_VAR 0 2
31293: ARRAY
31294: PUSH
31295: LD_INT 1
31297: ARRAY
31298: PPUSH
31299: CALL_OW 255
31303: PPUSH
31304: LD_EXP 66
31308: PUSH
31309: LD_VAR 0 2
31313: ARRAY
31314: PUSH
31315: LD_VAR 0 3
31319: ARRAY
31320: PUSH
31321: LD_INT 2
31323: ARRAY
31324: PPUSH
31325: LD_EXP 66
31329: PUSH
31330: LD_VAR 0 2
31334: ARRAY
31335: PUSH
31336: LD_VAR 0 3
31340: ARRAY
31341: PUSH
31342: LD_INT 3
31344: ARRAY
31345: PPUSH
31346: LD_INT 30
31348: PPUSH
31349: CALL 53802 0 4
31353: PUSH
31354: LD_INT 4
31356: ARRAY
31357: PUSH
31358: LD_INT 0
31360: EQUAL
31361: IFFALSE 31387
// begin target := mc_crates [ i ] [ j ] ;
31363: LD_ADDR_VAR 0 6
31367: PUSH
31368: LD_EXP 66
31372: PUSH
31373: LD_VAR 0 2
31377: ARRAY
31378: PUSH
31379: LD_VAR 0 3
31383: ARRAY
31384: ST_TO_ADDR
// break ;
31385: GO 31389
// end ; end ;
31387: GO 31128
31389: POP
31390: POP
// if not target then
31391: LD_VAR 0 6
31395: NOT
31396: IFFALSE 31400
// continue ;
31398: GO 31009
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31400: LD_ADDR_VAR 0 7
31404: PUSH
31405: LD_EXP 69
31409: PUSH
31410: LD_VAR 0 2
31414: ARRAY
31415: PPUSH
31416: LD_INT 2
31418: PUSH
31419: LD_INT 3
31421: PUSH
31422: LD_INT 58
31424: PUSH
31425: EMPTY
31426: LIST
31427: PUSH
31428: EMPTY
31429: LIST
31430: LIST
31431: PUSH
31432: LD_INT 61
31434: PUSH
31435: EMPTY
31436: LIST
31437: PUSH
31438: LD_INT 33
31440: PUSH
31441: LD_INT 5
31443: PUSH
31444: EMPTY
31445: LIST
31446: LIST
31447: PUSH
31448: LD_INT 33
31450: PUSH
31451: LD_INT 3
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: PUSH
31465: LD_INT 2
31467: PUSH
31468: LD_INT 34
31470: PUSH
31471: LD_INT 32
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PUSH
31478: LD_INT 34
31480: PUSH
31481: LD_INT 51
31483: PUSH
31484: EMPTY
31485: LIST
31486: LIST
31487: PUSH
31488: LD_INT 34
31490: PUSH
31491: LD_INT 12
31493: PUSH
31494: EMPTY
31495: LIST
31496: LIST
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: PUSH
31504: EMPTY
31505: LIST
31506: LIST
31507: PPUSH
31508: CALL_OW 72
31512: ST_TO_ADDR
// if not cargo then
31513: LD_VAR 0 7
31517: NOT
31518: IFFALSE 32161
// begin if mc_crates_collector [ i ] < 5 then
31520: LD_EXP 67
31524: PUSH
31525: LD_VAR 0 2
31529: ARRAY
31530: PUSH
31531: LD_INT 5
31533: LESS
31534: IFFALSE 31900
// begin if mc_ape [ i ] then
31536: LD_EXP 79
31540: PUSH
31541: LD_VAR 0 2
31545: ARRAY
31546: IFFALSE 31593
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31548: LD_ADDR_VAR 0 5
31552: PUSH
31553: LD_EXP 79
31557: PUSH
31558: LD_VAR 0 2
31562: ARRAY
31563: PPUSH
31564: LD_INT 25
31566: PUSH
31567: LD_INT 16
31569: PUSH
31570: EMPTY
31571: LIST
31572: LIST
31573: PUSH
31574: LD_INT 24
31576: PUSH
31577: LD_INT 750
31579: PUSH
31580: EMPTY
31581: LIST
31582: LIST
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PPUSH
31588: CALL_OW 72
31592: ST_TO_ADDR
// if not tmp then
31593: LD_VAR 0 5
31597: NOT
31598: IFFALSE 31645
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31600: LD_ADDR_VAR 0 5
31604: PUSH
31605: LD_EXP 50
31609: PUSH
31610: LD_VAR 0 2
31614: ARRAY
31615: PPUSH
31616: LD_INT 25
31618: PUSH
31619: LD_INT 2
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: LD_INT 24
31628: PUSH
31629: LD_INT 750
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: EMPTY
31637: LIST
31638: LIST
31639: PPUSH
31640: CALL_OW 72
31644: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31645: LD_EXP 79
31649: PUSH
31650: LD_VAR 0 2
31654: ARRAY
31655: PUSH
31656: LD_EXP 50
31660: PUSH
31661: LD_VAR 0 2
31665: ARRAY
31666: PPUSH
31667: LD_INT 25
31669: PUSH
31670: LD_INT 2
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 24
31679: PUSH
31680: LD_INT 750
31682: PUSH
31683: EMPTY
31684: LIST
31685: LIST
31686: PUSH
31687: EMPTY
31688: LIST
31689: LIST
31690: PPUSH
31691: CALL_OW 72
31695: AND
31696: PUSH
31697: LD_VAR 0 5
31701: PUSH
31702: LD_INT 5
31704: LESS
31705: AND
31706: IFFALSE 31788
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31708: LD_ADDR_VAR 0 3
31712: PUSH
31713: LD_EXP 50
31717: PUSH
31718: LD_VAR 0 2
31722: ARRAY
31723: PPUSH
31724: LD_INT 25
31726: PUSH
31727: LD_INT 2
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: LD_INT 24
31736: PUSH
31737: LD_INT 750
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PPUSH
31748: CALL_OW 72
31752: PUSH
31753: FOR_IN
31754: IFFALSE 31786
// begin tmp := tmp union j ;
31756: LD_ADDR_VAR 0 5
31760: PUSH
31761: LD_VAR 0 5
31765: PUSH
31766: LD_VAR 0 3
31770: UNION
31771: ST_TO_ADDR
// if tmp >= 5 then
31772: LD_VAR 0 5
31776: PUSH
31777: LD_INT 5
31779: GREATEREQUAL
31780: IFFALSE 31784
// break ;
31782: GO 31786
// end ;
31784: GO 31753
31786: POP
31787: POP
// end ; if not tmp then
31788: LD_VAR 0 5
31792: NOT
31793: IFFALSE 31797
// continue ;
31795: GO 31009
// for j in tmp do
31797: LD_ADDR_VAR 0 3
31801: PUSH
31802: LD_VAR 0 5
31806: PUSH
31807: FOR_IN
31808: IFFALSE 31898
// if not GetTag ( j ) then
31810: LD_VAR 0 3
31814: PPUSH
31815: CALL_OW 110
31819: NOT
31820: IFFALSE 31896
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31822: LD_ADDR_EXP 67
31826: PUSH
31827: LD_EXP 67
31831: PPUSH
31832: LD_VAR 0 2
31836: PUSH
31837: LD_EXP 67
31841: PUSH
31842: LD_VAR 0 2
31846: ARRAY
31847: PUSH
31848: LD_INT 1
31850: PLUS
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PPUSH
31856: LD_VAR 0 3
31860: PPUSH
31861: CALL 52906 0 3
31865: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31866: LD_VAR 0 3
31870: PPUSH
31871: LD_INT 107
31873: PPUSH
31874: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31878: LD_EXP 67
31882: PUSH
31883: LD_VAR 0 2
31887: ARRAY
31888: PUSH
31889: LD_INT 5
31891: GREATEREQUAL
31892: IFFALSE 31896
// break ;
31894: GO 31898
// end ;
31896: GO 31807
31898: POP
31899: POP
// end ; if mc_crates_collector [ i ] and target then
31900: LD_EXP 67
31904: PUSH
31905: LD_VAR 0 2
31909: ARRAY
31910: PUSH
31911: LD_VAR 0 6
31915: AND
31916: IFFALSE 32159
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31918: LD_EXP 67
31922: PUSH
31923: LD_VAR 0 2
31927: ARRAY
31928: PUSH
31929: LD_VAR 0 6
31933: PUSH
31934: LD_INT 1
31936: ARRAY
31937: LESS
31938: IFFALSE 31958
// tmp := mc_crates_collector [ i ] else
31940: LD_ADDR_VAR 0 5
31944: PUSH
31945: LD_EXP 67
31949: PUSH
31950: LD_VAR 0 2
31954: ARRAY
31955: ST_TO_ADDR
31956: GO 31972
// tmp := target [ 1 ] ;
31958: LD_ADDR_VAR 0 5
31962: PUSH
31963: LD_VAR 0 6
31967: PUSH
31968: LD_INT 1
31970: ARRAY
31971: ST_TO_ADDR
// k := 0 ;
31972: LD_ADDR_VAR 0 4
31976: PUSH
31977: LD_INT 0
31979: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31980: LD_ADDR_VAR 0 3
31984: PUSH
31985: LD_EXP 67
31989: PUSH
31990: LD_VAR 0 2
31994: ARRAY
31995: PUSH
31996: FOR_IN
31997: IFFALSE 32157
// begin k := k + 1 ;
31999: LD_ADDR_VAR 0 4
32003: PUSH
32004: LD_VAR 0 4
32008: PUSH
32009: LD_INT 1
32011: PLUS
32012: ST_TO_ADDR
// if k > tmp then
32013: LD_VAR 0 4
32017: PUSH
32018: LD_VAR 0 5
32022: GREATER
32023: IFFALSE 32027
// break ;
32025: GO 32157
// if not GetClass ( j ) in [ 2 , 16 ] then
32027: LD_VAR 0 3
32031: PPUSH
32032: CALL_OW 257
32036: PUSH
32037: LD_INT 2
32039: PUSH
32040: LD_INT 16
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: IN
32047: NOT
32048: IFFALSE 32101
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32050: LD_ADDR_EXP 67
32054: PUSH
32055: LD_EXP 67
32059: PPUSH
32060: LD_VAR 0 2
32064: PPUSH
32065: LD_EXP 67
32069: PUSH
32070: LD_VAR 0 2
32074: ARRAY
32075: PUSH
32076: LD_VAR 0 3
32080: DIFF
32081: PPUSH
32082: CALL_OW 1
32086: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32087: LD_VAR 0 3
32091: PPUSH
32092: LD_INT 0
32094: PPUSH
32095: CALL_OW 109
// continue ;
32099: GO 31996
// end ; if IsInUnit ( j ) then
32101: LD_VAR 0 3
32105: PPUSH
32106: CALL_OW 310
32110: IFFALSE 32121
// ComExitBuilding ( j ) ;
32112: LD_VAR 0 3
32116: PPUSH
32117: CALL_OW 122
// wait ( 3 ) ;
32121: LD_INT 3
32123: PPUSH
32124: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32128: LD_VAR 0 3
32132: PPUSH
32133: LD_VAR 0 6
32137: PUSH
32138: LD_INT 2
32140: ARRAY
32141: PPUSH
32142: LD_VAR 0 6
32146: PUSH
32147: LD_INT 3
32149: ARRAY
32150: PPUSH
32151: CALL_OW 117
// end ;
32155: GO 31996
32157: POP
32158: POP
// end ; end else
32159: GO 32740
// begin for j in cargo do
32161: LD_ADDR_VAR 0 3
32165: PUSH
32166: LD_VAR 0 7
32170: PUSH
32171: FOR_IN
32172: IFFALSE 32738
// begin if GetTag ( j ) <> 0 then
32174: LD_VAR 0 3
32178: PPUSH
32179: CALL_OW 110
32183: PUSH
32184: LD_INT 0
32186: NONEQUAL
32187: IFFALSE 32191
// continue ;
32189: GO 32171
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32191: LD_VAR 0 3
32195: PPUSH
32196: CALL_OW 256
32200: PUSH
32201: LD_INT 1000
32203: LESS
32204: PUSH
32205: LD_VAR 0 3
32209: PPUSH
32210: LD_EXP 74
32214: PUSH
32215: LD_VAR 0 2
32219: ARRAY
32220: PPUSH
32221: CALL_OW 308
32225: NOT
32226: AND
32227: IFFALSE 32249
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32229: LD_VAR 0 3
32233: PPUSH
32234: LD_EXP 74
32238: PUSH
32239: LD_VAR 0 2
32243: ARRAY
32244: PPUSH
32245: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32249: LD_VAR 0 3
32253: PPUSH
32254: CALL_OW 256
32258: PUSH
32259: LD_INT 1000
32261: LESS
32262: PUSH
32263: LD_VAR 0 3
32267: PPUSH
32268: LD_EXP 74
32272: PUSH
32273: LD_VAR 0 2
32277: ARRAY
32278: PPUSH
32279: CALL_OW 308
32283: AND
32284: IFFALSE 32288
// continue ;
32286: GO 32171
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32288: LD_VAR 0 3
32292: PPUSH
32293: CALL_OW 262
32297: PUSH
32298: LD_INT 2
32300: EQUAL
32301: PUSH
32302: LD_VAR 0 3
32306: PPUSH
32307: CALL_OW 261
32311: PUSH
32312: LD_INT 15
32314: LESS
32315: AND
32316: IFFALSE 32320
// continue ;
32318: GO 32171
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32320: LD_VAR 0 3
32324: PPUSH
32325: CALL_OW 262
32329: PUSH
32330: LD_INT 1
32332: EQUAL
32333: PUSH
32334: LD_VAR 0 3
32338: PPUSH
32339: CALL_OW 261
32343: PUSH
32344: LD_INT 10
32346: LESS
32347: AND
32348: IFFALSE 32677
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32350: LD_ADDR_VAR 0 8
32354: PUSH
32355: LD_EXP 50
32359: PUSH
32360: LD_VAR 0 2
32364: ARRAY
32365: PPUSH
32366: LD_INT 2
32368: PUSH
32369: LD_INT 30
32371: PUSH
32372: LD_INT 0
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PUSH
32379: LD_INT 30
32381: PUSH
32382: LD_INT 1
32384: PUSH
32385: EMPTY
32386: LIST
32387: LIST
32388: PUSH
32389: EMPTY
32390: LIST
32391: LIST
32392: LIST
32393: PPUSH
32394: CALL_OW 72
32398: ST_TO_ADDR
// if not depot then
32399: LD_VAR 0 8
32403: NOT
32404: IFFALSE 32408
// continue ;
32406: GO 32171
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32408: LD_VAR 0 3
32412: PPUSH
32413: LD_VAR 0 8
32417: PPUSH
32418: LD_VAR 0 3
32422: PPUSH
32423: CALL_OW 74
32427: PPUSH
32428: CALL_OW 296
32432: PUSH
32433: LD_INT 6
32435: LESS
32436: IFFALSE 32452
// SetFuel ( j , 100 ) else
32438: LD_VAR 0 3
32442: PPUSH
32443: LD_INT 100
32445: PPUSH
32446: CALL_OW 240
32450: GO 32677
// if GetFuel ( j ) = 0 then
32452: LD_VAR 0 3
32456: PPUSH
32457: CALL_OW 261
32461: PUSH
32462: LD_INT 0
32464: EQUAL
32465: IFFALSE 32677
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32467: LD_ADDR_EXP 69
32471: PUSH
32472: LD_EXP 69
32476: PPUSH
32477: LD_VAR 0 2
32481: PPUSH
32482: LD_EXP 69
32486: PUSH
32487: LD_VAR 0 2
32491: ARRAY
32492: PUSH
32493: LD_VAR 0 3
32497: DIFF
32498: PPUSH
32499: CALL_OW 1
32503: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32504: LD_VAR 0 3
32508: PPUSH
32509: CALL_OW 263
32513: PUSH
32514: LD_INT 1
32516: EQUAL
32517: IFFALSE 32533
// ComExitVehicle ( IsInUnit ( j ) ) ;
32519: LD_VAR 0 3
32523: PPUSH
32524: CALL_OW 310
32528: PPUSH
32529: CALL_OW 121
// if GetControl ( j ) = control_remote then
32533: LD_VAR 0 3
32537: PPUSH
32538: CALL_OW 263
32542: PUSH
32543: LD_INT 2
32545: EQUAL
32546: IFFALSE 32557
// ComUnlink ( j ) ;
32548: LD_VAR 0 3
32552: PPUSH
32553: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32557: LD_ADDR_VAR 0 9
32561: PUSH
32562: LD_VAR 0 2
32566: PPUSH
32567: LD_INT 3
32569: PPUSH
32570: CALL 42052 0 2
32574: ST_TO_ADDR
// if fac then
32575: LD_VAR 0 9
32579: IFFALSE 32675
// begin for k in fac do
32581: LD_ADDR_VAR 0 4
32585: PUSH
32586: LD_VAR 0 9
32590: PUSH
32591: FOR_IN
32592: IFFALSE 32673
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32594: LD_ADDR_VAR 0 10
32598: PUSH
32599: LD_VAR 0 9
32603: PPUSH
32604: LD_VAR 0 3
32608: PPUSH
32609: CALL_OW 265
32613: PPUSH
32614: LD_VAR 0 3
32618: PPUSH
32619: CALL_OW 262
32623: PPUSH
32624: LD_VAR 0 3
32628: PPUSH
32629: CALL_OW 263
32633: PPUSH
32634: LD_VAR 0 3
32638: PPUSH
32639: CALL_OW 264
32643: PPUSH
32644: CALL 50438 0 5
32648: ST_TO_ADDR
// if components then
32649: LD_VAR 0 10
32653: IFFALSE 32671
// begin MC_InsertProduceList ( i , components ) ;
32655: LD_VAR 0 2
32659: PPUSH
32660: LD_VAR 0 10
32664: PPUSH
32665: CALL 41597 0 2
// break ;
32669: GO 32673
// end ; end ;
32671: GO 32591
32673: POP
32674: POP
// end ; continue ;
32675: GO 32171
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32677: LD_VAR 0 3
32681: PPUSH
32682: LD_INT 1
32684: PPUSH
32685: CALL_OW 289
32689: PUSH
32690: LD_INT 100
32692: LESS
32693: PUSH
32694: LD_VAR 0 3
32698: PPUSH
32699: CALL_OW 314
32703: NOT
32704: AND
32705: IFFALSE 32734
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32707: LD_VAR 0 3
32711: PPUSH
32712: LD_VAR 0 6
32716: PUSH
32717: LD_INT 2
32719: ARRAY
32720: PPUSH
32721: LD_VAR 0 6
32725: PUSH
32726: LD_INT 3
32728: ARRAY
32729: PPUSH
32730: CALL_OW 117
// break ;
32734: GO 32738
// end ;
32736: GO 32171
32738: POP
32739: POP
// end ; end ;
32740: GO 31009
32742: POP
32743: POP
// end ;
32744: LD_VAR 0 1
32748: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32749: LD_INT 0
32751: PPUSH
32752: PPUSH
32753: PPUSH
32754: PPUSH
// if not mc_bases then
32755: LD_EXP 50
32759: NOT
32760: IFFALSE 32764
// exit ;
32762: GO 32925
// for i = 1 to mc_bases do
32764: LD_ADDR_VAR 0 2
32768: PUSH
32769: DOUBLE
32770: LD_INT 1
32772: DEC
32773: ST_TO_ADDR
32774: LD_EXP 50
32778: PUSH
32779: FOR_TO
32780: IFFALSE 32923
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32782: LD_ADDR_VAR 0 4
32786: PUSH
32787: LD_EXP 69
32791: PUSH
32792: LD_VAR 0 2
32796: ARRAY
32797: PUSH
32798: LD_EXP 72
32802: PUSH
32803: LD_VAR 0 2
32807: ARRAY
32808: UNION
32809: PPUSH
32810: LD_INT 33
32812: PUSH
32813: LD_INT 2
32815: PUSH
32816: EMPTY
32817: LIST
32818: LIST
32819: PPUSH
32820: CALL_OW 72
32824: ST_TO_ADDR
// if tmp then
32825: LD_VAR 0 4
32829: IFFALSE 32921
// for j in tmp do
32831: LD_ADDR_VAR 0 3
32835: PUSH
32836: LD_VAR 0 4
32840: PUSH
32841: FOR_IN
32842: IFFALSE 32919
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32844: LD_VAR 0 3
32848: PPUSH
32849: CALL_OW 312
32853: NOT
32854: PUSH
32855: LD_VAR 0 3
32859: PPUSH
32860: CALL_OW 256
32864: PUSH
32865: LD_INT 250
32867: GREATEREQUAL
32868: AND
32869: IFFALSE 32882
// Connect ( j ) else
32871: LD_VAR 0 3
32875: PPUSH
32876: CALL 55871 0 1
32880: GO 32917
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32882: LD_VAR 0 3
32886: PPUSH
32887: CALL_OW 256
32891: PUSH
32892: LD_INT 250
32894: LESS
32895: PUSH
32896: LD_VAR 0 3
32900: PPUSH
32901: CALL_OW 312
32905: AND
32906: IFFALSE 32917
// ComUnlink ( j ) ;
32908: LD_VAR 0 3
32912: PPUSH
32913: CALL_OW 136
32917: GO 32841
32919: POP
32920: POP
// end ;
32921: GO 32779
32923: POP
32924: POP
// end ;
32925: LD_VAR 0 1
32929: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
32930: LD_INT 0
32932: PPUSH
32933: PPUSH
32934: PPUSH
32935: PPUSH
32936: PPUSH
// if not mc_bases then
32937: LD_EXP 50
32941: NOT
32942: IFFALSE 32946
// exit ;
32944: GO 33391
// for i = 1 to mc_bases do
32946: LD_ADDR_VAR 0 2
32950: PUSH
32951: DOUBLE
32952: LD_INT 1
32954: DEC
32955: ST_TO_ADDR
32956: LD_EXP 50
32960: PUSH
32961: FOR_TO
32962: IFFALSE 33389
// begin if not mc_produce [ i ] then
32964: LD_EXP 71
32968: PUSH
32969: LD_VAR 0 2
32973: ARRAY
32974: NOT
32975: IFFALSE 32979
// continue ;
32977: GO 32961
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32979: LD_ADDR_VAR 0 5
32983: PUSH
32984: LD_EXP 50
32988: PUSH
32989: LD_VAR 0 2
32993: ARRAY
32994: PPUSH
32995: LD_INT 30
32997: PUSH
32998: LD_INT 3
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PPUSH
33005: CALL_OW 72
33009: ST_TO_ADDR
// if not fac then
33010: LD_VAR 0 5
33014: NOT
33015: IFFALSE 33019
// continue ;
33017: GO 32961
// for j in fac do
33019: LD_ADDR_VAR 0 3
33023: PUSH
33024: LD_VAR 0 5
33028: PUSH
33029: FOR_IN
33030: IFFALSE 33385
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33032: LD_VAR 0 3
33036: PPUSH
33037: CALL_OW 461
33041: PUSH
33042: LD_INT 2
33044: NONEQUAL
33045: PUSH
33046: LD_VAR 0 3
33050: PPUSH
33051: LD_INT 15
33053: PPUSH
33054: CALL 55499 0 2
33058: PUSH
33059: LD_INT 4
33061: ARRAY
33062: OR
33063: IFFALSE 33067
// continue ;
33065: GO 33029
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33067: LD_VAR 0 3
33071: PPUSH
33072: LD_EXP 71
33076: PUSH
33077: LD_VAR 0 2
33081: ARRAY
33082: PUSH
33083: LD_INT 1
33085: ARRAY
33086: PUSH
33087: LD_INT 1
33089: ARRAY
33090: PPUSH
33091: LD_EXP 71
33095: PUSH
33096: LD_VAR 0 2
33100: ARRAY
33101: PUSH
33102: LD_INT 1
33104: ARRAY
33105: PUSH
33106: LD_INT 2
33108: ARRAY
33109: PPUSH
33110: LD_EXP 71
33114: PUSH
33115: LD_VAR 0 2
33119: ARRAY
33120: PUSH
33121: LD_INT 1
33123: ARRAY
33124: PUSH
33125: LD_INT 3
33127: ARRAY
33128: PPUSH
33129: LD_EXP 71
33133: PUSH
33134: LD_VAR 0 2
33138: ARRAY
33139: PUSH
33140: LD_INT 1
33142: ARRAY
33143: PUSH
33144: LD_INT 4
33146: ARRAY
33147: PPUSH
33148: CALL_OW 448
33152: PUSH
33153: LD_VAR 0 3
33157: PPUSH
33158: LD_EXP 71
33162: PUSH
33163: LD_VAR 0 2
33167: ARRAY
33168: PUSH
33169: LD_INT 1
33171: ARRAY
33172: PUSH
33173: LD_INT 1
33175: ARRAY
33176: PUSH
33177: LD_EXP 71
33181: PUSH
33182: LD_VAR 0 2
33186: ARRAY
33187: PUSH
33188: LD_INT 1
33190: ARRAY
33191: PUSH
33192: LD_INT 2
33194: ARRAY
33195: PUSH
33196: LD_EXP 71
33200: PUSH
33201: LD_VAR 0 2
33205: ARRAY
33206: PUSH
33207: LD_INT 1
33209: ARRAY
33210: PUSH
33211: LD_INT 3
33213: ARRAY
33214: PUSH
33215: LD_EXP 71
33219: PUSH
33220: LD_VAR 0 2
33224: ARRAY
33225: PUSH
33226: LD_INT 1
33228: ARRAY
33229: PUSH
33230: LD_INT 4
33232: ARRAY
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: LIST
33238: LIST
33239: PPUSH
33240: CALL 59297 0 2
33244: AND
33245: IFFALSE 33383
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33247: LD_VAR 0 3
33251: PPUSH
33252: LD_EXP 71
33256: PUSH
33257: LD_VAR 0 2
33261: ARRAY
33262: PUSH
33263: LD_INT 1
33265: ARRAY
33266: PUSH
33267: LD_INT 1
33269: ARRAY
33270: PPUSH
33271: LD_EXP 71
33275: PUSH
33276: LD_VAR 0 2
33280: ARRAY
33281: PUSH
33282: LD_INT 1
33284: ARRAY
33285: PUSH
33286: LD_INT 2
33288: ARRAY
33289: PPUSH
33290: LD_EXP 71
33294: PUSH
33295: LD_VAR 0 2
33299: ARRAY
33300: PUSH
33301: LD_INT 1
33303: ARRAY
33304: PUSH
33305: LD_INT 3
33307: ARRAY
33308: PPUSH
33309: LD_EXP 71
33313: PUSH
33314: LD_VAR 0 2
33318: ARRAY
33319: PUSH
33320: LD_INT 1
33322: ARRAY
33323: PUSH
33324: LD_INT 4
33326: ARRAY
33327: PPUSH
33328: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33332: LD_ADDR_VAR 0 4
33336: PUSH
33337: LD_EXP 71
33341: PUSH
33342: LD_VAR 0 2
33346: ARRAY
33347: PPUSH
33348: LD_INT 1
33350: PPUSH
33351: CALL_OW 3
33355: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33356: LD_ADDR_EXP 71
33360: PUSH
33361: LD_EXP 71
33365: PPUSH
33366: LD_VAR 0 2
33370: PPUSH
33371: LD_VAR 0 4
33375: PPUSH
33376: CALL_OW 1
33380: ST_TO_ADDR
// break ;
33381: GO 33385
// end ; end ;
33383: GO 33029
33385: POP
33386: POP
// end ;
33387: GO 32961
33389: POP
33390: POP
// end ;
33391: LD_VAR 0 1
33395: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33396: LD_INT 0
33398: PPUSH
33399: PPUSH
33400: PPUSH
// if not mc_bases then
33401: LD_EXP 50
33405: NOT
33406: IFFALSE 33410
// exit ;
33408: GO 33499
// for i = 1 to mc_bases do
33410: LD_ADDR_VAR 0 2
33414: PUSH
33415: DOUBLE
33416: LD_INT 1
33418: DEC
33419: ST_TO_ADDR
33420: LD_EXP 50
33424: PUSH
33425: FOR_TO
33426: IFFALSE 33497
// begin if mc_attack [ i ] then
33428: LD_EXP 70
33432: PUSH
33433: LD_VAR 0 2
33437: ARRAY
33438: IFFALSE 33495
// begin tmp := mc_attack [ i ] [ 1 ] ;
33440: LD_ADDR_VAR 0 3
33444: PUSH
33445: LD_EXP 70
33449: PUSH
33450: LD_VAR 0 2
33454: ARRAY
33455: PUSH
33456: LD_INT 1
33458: ARRAY
33459: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33460: LD_ADDR_EXP 70
33464: PUSH
33465: LD_EXP 70
33469: PPUSH
33470: LD_VAR 0 2
33474: PPUSH
33475: EMPTY
33476: PPUSH
33477: CALL_OW 1
33481: ST_TO_ADDR
// Attack ( tmp ) ;
33482: LD_VAR 0 3
33486: PPUSH
33487: CALL 102942 0 1
// exit ;
33491: POP
33492: POP
33493: GO 33499
// end ; end ;
33495: GO 33425
33497: POP
33498: POP
// end ;
33499: LD_VAR 0 1
33503: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33504: LD_INT 0
33506: PPUSH
33507: PPUSH
33508: PPUSH
33509: PPUSH
33510: PPUSH
33511: PPUSH
33512: PPUSH
// if not mc_bases then
33513: LD_EXP 50
33517: NOT
33518: IFFALSE 33522
// exit ;
33520: GO 34126
// for i = 1 to mc_bases do
33522: LD_ADDR_VAR 0 2
33526: PUSH
33527: DOUBLE
33528: LD_INT 1
33530: DEC
33531: ST_TO_ADDR
33532: LD_EXP 50
33536: PUSH
33537: FOR_TO
33538: IFFALSE 34124
// begin if not mc_bases [ i ] then
33540: LD_EXP 50
33544: PUSH
33545: LD_VAR 0 2
33549: ARRAY
33550: NOT
33551: IFFALSE 33555
// continue ;
33553: GO 33537
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33555: LD_ADDR_VAR 0 7
33559: PUSH
33560: LD_EXP 50
33564: PUSH
33565: LD_VAR 0 2
33569: ARRAY
33570: PUSH
33571: LD_INT 1
33573: ARRAY
33574: PPUSH
33575: CALL 49742 0 1
33579: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33580: LD_ADDR_EXP 73
33584: PUSH
33585: LD_EXP 73
33589: PPUSH
33590: LD_VAR 0 2
33594: PPUSH
33595: LD_EXP 50
33599: PUSH
33600: LD_VAR 0 2
33604: ARRAY
33605: PUSH
33606: LD_INT 1
33608: ARRAY
33609: PPUSH
33610: CALL_OW 255
33614: PPUSH
33615: LD_EXP 75
33619: PUSH
33620: LD_VAR 0 2
33624: ARRAY
33625: PPUSH
33626: CALL 49707 0 2
33630: PPUSH
33631: CALL_OW 1
33635: ST_TO_ADDR
// if not mc_scan [ i ] then
33636: LD_EXP 73
33640: PUSH
33641: LD_VAR 0 2
33645: ARRAY
33646: NOT
33647: IFFALSE 33802
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33649: LD_ADDR_VAR 0 4
33653: PUSH
33654: LD_EXP 50
33658: PUSH
33659: LD_VAR 0 2
33663: ARRAY
33664: PPUSH
33665: LD_INT 2
33667: PUSH
33668: LD_INT 25
33670: PUSH
33671: LD_INT 5
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 25
33680: PUSH
33681: LD_INT 8
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 25
33690: PUSH
33691: LD_INT 9
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: EMPTY
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: PPUSH
33704: CALL_OW 72
33708: ST_TO_ADDR
// if not tmp then
33709: LD_VAR 0 4
33713: NOT
33714: IFFALSE 33718
// continue ;
33716: GO 33537
// for j in tmp do
33718: LD_ADDR_VAR 0 3
33722: PUSH
33723: LD_VAR 0 4
33727: PUSH
33728: FOR_IN
33729: IFFALSE 33800
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33731: LD_VAR 0 3
33735: PPUSH
33736: CALL_OW 310
33740: PPUSH
33741: CALL_OW 266
33745: PUSH
33746: LD_INT 5
33748: EQUAL
33749: PUSH
33750: LD_VAR 0 3
33754: PPUSH
33755: CALL_OW 257
33759: PUSH
33760: LD_INT 1
33762: EQUAL
33763: AND
33764: PUSH
33765: LD_VAR 0 3
33769: PPUSH
33770: CALL_OW 459
33774: NOT
33775: AND
33776: PUSH
33777: LD_VAR 0 7
33781: AND
33782: IFFALSE 33798
// ComChangeProfession ( j , class ) ;
33784: LD_VAR 0 3
33788: PPUSH
33789: LD_VAR 0 7
33793: PPUSH
33794: CALL_OW 123
33798: GO 33728
33800: POP
33801: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33802: LD_EXP 73
33806: PUSH
33807: LD_VAR 0 2
33811: ARRAY
33812: PUSH
33813: LD_EXP 72
33817: PUSH
33818: LD_VAR 0 2
33822: ARRAY
33823: NOT
33824: AND
33825: PUSH
33826: LD_EXP 50
33830: PUSH
33831: LD_VAR 0 2
33835: ARRAY
33836: PPUSH
33837: LD_INT 30
33839: PUSH
33840: LD_INT 32
33842: PUSH
33843: EMPTY
33844: LIST
33845: LIST
33846: PPUSH
33847: CALL_OW 72
33851: NOT
33852: AND
33853: PUSH
33854: LD_EXP 50
33858: PUSH
33859: LD_VAR 0 2
33863: ARRAY
33864: PPUSH
33865: LD_INT 2
33867: PUSH
33868: LD_INT 30
33870: PUSH
33871: LD_INT 4
33873: PUSH
33874: EMPTY
33875: LIST
33876: LIST
33877: PUSH
33878: LD_INT 30
33880: PUSH
33881: LD_INT 5
33883: PUSH
33884: EMPTY
33885: LIST
33886: LIST
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: LIST
33892: PPUSH
33893: CALL_OW 72
33897: NOT
33898: AND
33899: IFFALSE 34031
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33901: LD_ADDR_VAR 0 4
33905: PUSH
33906: LD_EXP 50
33910: PUSH
33911: LD_VAR 0 2
33915: ARRAY
33916: PPUSH
33917: LD_INT 2
33919: PUSH
33920: LD_INT 25
33922: PUSH
33923: LD_INT 1
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: PUSH
33930: LD_INT 25
33932: PUSH
33933: LD_INT 5
33935: PUSH
33936: EMPTY
33937: LIST
33938: LIST
33939: PUSH
33940: LD_INT 25
33942: PUSH
33943: LD_INT 8
33945: PUSH
33946: EMPTY
33947: LIST
33948: LIST
33949: PUSH
33950: LD_INT 25
33952: PUSH
33953: LD_INT 9
33955: PUSH
33956: EMPTY
33957: LIST
33958: LIST
33959: PUSH
33960: EMPTY
33961: LIST
33962: LIST
33963: LIST
33964: LIST
33965: LIST
33966: PPUSH
33967: CALL_OW 72
33971: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33972: LD_ADDR_VAR 0 4
33976: PUSH
33977: LD_VAR 0 4
33981: PUSH
33982: LD_VAR 0 4
33986: PPUSH
33987: LD_INT 18
33989: PPUSH
33990: CALL 81800 0 2
33994: DIFF
33995: ST_TO_ADDR
// if tmp then
33996: LD_VAR 0 4
34000: IFFALSE 34031
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
34002: LD_VAR 0 2
34006: PPUSH
34007: LD_VAR 0 4
34011: PPUSH
34012: LD_EXP 75
34016: PUSH
34017: LD_VAR 0 2
34021: ARRAY
34022: PPUSH
34023: CALL 107651 0 3
// exit ;
34027: POP
34028: POP
34029: GO 34126
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
34031: LD_EXP 73
34035: PUSH
34036: LD_VAR 0 2
34040: ARRAY
34041: PUSH
34042: LD_EXP 72
34046: PUSH
34047: LD_VAR 0 2
34051: ARRAY
34052: AND
34053: IFFALSE 34122
// begin tmp := mc_defender [ i ] ;
34055: LD_ADDR_VAR 0 4
34059: PUSH
34060: LD_EXP 72
34064: PUSH
34065: LD_VAR 0 2
34069: ARRAY
34070: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34071: LD_ADDR_EXP 72
34075: PUSH
34076: LD_EXP 72
34080: PPUSH
34081: LD_VAR 0 2
34085: PPUSH
34086: EMPTY
34087: PPUSH
34088: CALL_OW 1
34092: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
34093: LD_VAR 0 2
34097: PPUSH
34098: LD_VAR 0 4
34102: PPUSH
34103: LD_EXP 73
34107: PUSH
34108: LD_VAR 0 2
34112: ARRAY
34113: PPUSH
34114: CALL 108212 0 3
// exit ;
34118: POP
34119: POP
34120: GO 34126
// end ; end ;
34122: GO 33537
34124: POP
34125: POP
// end ;
34126: LD_VAR 0 1
34130: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34131: LD_INT 0
34133: PPUSH
34134: PPUSH
34135: PPUSH
34136: PPUSH
34137: PPUSH
34138: PPUSH
34139: PPUSH
34140: PPUSH
34141: PPUSH
34142: PPUSH
34143: PPUSH
// if not mc_bases then
34144: LD_EXP 50
34148: NOT
34149: IFFALSE 34153
// exit ;
34151: GO 35240
// for i = 1 to mc_bases do
34153: LD_ADDR_VAR 0 2
34157: PUSH
34158: DOUBLE
34159: LD_INT 1
34161: DEC
34162: ST_TO_ADDR
34163: LD_EXP 50
34167: PUSH
34168: FOR_TO
34169: IFFALSE 35238
// begin tmp := mc_lab [ i ] ;
34171: LD_ADDR_VAR 0 6
34175: PUSH
34176: LD_EXP 83
34180: PUSH
34181: LD_VAR 0 2
34185: ARRAY
34186: ST_TO_ADDR
// if not tmp then
34187: LD_VAR 0 6
34191: NOT
34192: IFFALSE 34196
// continue ;
34194: GO 34168
// idle_lab := 0 ;
34196: LD_ADDR_VAR 0 11
34200: PUSH
34201: LD_INT 0
34203: ST_TO_ADDR
// for j in tmp do
34204: LD_ADDR_VAR 0 3
34208: PUSH
34209: LD_VAR 0 6
34213: PUSH
34214: FOR_IN
34215: IFFALSE 35234
// begin researching := false ;
34217: LD_ADDR_VAR 0 10
34221: PUSH
34222: LD_INT 0
34224: ST_TO_ADDR
// side := GetSide ( j ) ;
34225: LD_ADDR_VAR 0 4
34229: PUSH
34230: LD_VAR 0 3
34234: PPUSH
34235: CALL_OW 255
34239: ST_TO_ADDR
// if not mc_tech [ side ] then
34240: LD_EXP 77
34244: PUSH
34245: LD_VAR 0 4
34249: ARRAY
34250: NOT
34251: IFFALSE 34255
// continue ;
34253: GO 34214
// if BuildingStatus ( j ) = bs_idle then
34255: LD_VAR 0 3
34259: PPUSH
34260: CALL_OW 461
34264: PUSH
34265: LD_INT 2
34267: EQUAL
34268: IFFALSE 34456
// begin if idle_lab and UnitsInside ( j ) < 6 then
34270: LD_VAR 0 11
34274: PUSH
34275: LD_VAR 0 3
34279: PPUSH
34280: CALL_OW 313
34284: PUSH
34285: LD_INT 6
34287: LESS
34288: AND
34289: IFFALSE 34360
// begin tmp2 := UnitsInside ( idle_lab ) ;
34291: LD_ADDR_VAR 0 9
34295: PUSH
34296: LD_VAR 0 11
34300: PPUSH
34301: CALL_OW 313
34305: ST_TO_ADDR
// if tmp2 then
34306: LD_VAR 0 9
34310: IFFALSE 34352
// for x in tmp2 do
34312: LD_ADDR_VAR 0 7
34316: PUSH
34317: LD_VAR 0 9
34321: PUSH
34322: FOR_IN
34323: IFFALSE 34350
// begin ComExitBuilding ( x ) ;
34325: LD_VAR 0 7
34329: PPUSH
34330: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34334: LD_VAR 0 7
34338: PPUSH
34339: LD_VAR 0 3
34343: PPUSH
34344: CALL_OW 180
// end ;
34348: GO 34322
34350: POP
34351: POP
// idle_lab := 0 ;
34352: LD_ADDR_VAR 0 11
34356: PUSH
34357: LD_INT 0
34359: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34360: LD_ADDR_VAR 0 5
34364: PUSH
34365: LD_EXP 77
34369: PUSH
34370: LD_VAR 0 4
34374: ARRAY
34375: PUSH
34376: FOR_IN
34377: IFFALSE 34437
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
34379: LD_VAR 0 3
34383: PPUSH
34384: LD_VAR 0 5
34388: PPUSH
34389: CALL_OW 430
34393: PUSH
34394: LD_VAR 0 4
34398: PPUSH
34399: LD_VAR 0 5
34403: PPUSH
34404: CALL 48812 0 2
34408: AND
34409: IFFALSE 34435
// begin researching := true ;
34411: LD_ADDR_VAR 0 10
34415: PUSH
34416: LD_INT 1
34418: ST_TO_ADDR
// ComResearch ( j , t ) ;
34419: LD_VAR 0 3
34423: PPUSH
34424: LD_VAR 0 5
34428: PPUSH
34429: CALL_OW 124
// break ;
34433: GO 34437
// end ;
34435: GO 34376
34437: POP
34438: POP
// if not researching then
34439: LD_VAR 0 10
34443: NOT
34444: IFFALSE 34456
// idle_lab := j ;
34446: LD_ADDR_VAR 0 11
34450: PUSH
34451: LD_VAR 0 3
34455: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
34456: LD_VAR 0 3
34460: PPUSH
34461: CALL_OW 461
34465: PUSH
34466: LD_INT 10
34468: EQUAL
34469: IFFALSE 35057
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
34471: LD_EXP 79
34475: PUSH
34476: LD_VAR 0 2
34480: ARRAY
34481: NOT
34482: PUSH
34483: LD_EXP 80
34487: PUSH
34488: LD_VAR 0 2
34492: ARRAY
34493: NOT
34494: AND
34495: PUSH
34496: LD_EXP 77
34500: PUSH
34501: LD_VAR 0 4
34505: ARRAY
34506: PUSH
34507: LD_INT 1
34509: GREATER
34510: AND
34511: IFFALSE 34642
// begin ComCancel ( j ) ;
34513: LD_VAR 0 3
34517: PPUSH
34518: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
34522: LD_ADDR_EXP 77
34526: PUSH
34527: LD_EXP 77
34531: PPUSH
34532: LD_VAR 0 4
34536: PPUSH
34537: LD_EXP 77
34541: PUSH
34542: LD_VAR 0 4
34546: ARRAY
34547: PPUSH
34548: LD_EXP 77
34552: PUSH
34553: LD_VAR 0 4
34557: ARRAY
34558: PUSH
34559: LD_INT 1
34561: MINUS
34562: PPUSH
34563: LD_EXP 77
34567: PUSH
34568: LD_VAR 0 4
34572: ARRAY
34573: PPUSH
34574: LD_INT 0
34576: PPUSH
34577: CALL 52324 0 4
34581: PPUSH
34582: CALL_OW 1
34586: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
34587: LD_ADDR_EXP 77
34591: PUSH
34592: LD_EXP 77
34596: PPUSH
34597: LD_VAR 0 4
34601: PPUSH
34602: LD_EXP 77
34606: PUSH
34607: LD_VAR 0 4
34611: ARRAY
34612: PPUSH
34613: LD_EXP 77
34617: PUSH
34618: LD_VAR 0 4
34622: ARRAY
34623: PPUSH
34624: LD_INT 1
34626: PPUSH
34627: LD_INT 0
34629: PPUSH
34630: CALL 52324 0 4
34634: PPUSH
34635: CALL_OW 1
34639: ST_TO_ADDR
// continue ;
34640: GO 34214
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
34642: LD_EXP 79
34646: PUSH
34647: LD_VAR 0 2
34651: ARRAY
34652: PUSH
34653: LD_EXP 80
34657: PUSH
34658: LD_VAR 0 2
34662: ARRAY
34663: NOT
34664: AND
34665: IFFALSE 34792
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
34667: LD_ADDR_EXP 80
34671: PUSH
34672: LD_EXP 80
34676: PPUSH
34677: LD_VAR 0 2
34681: PUSH
34682: LD_EXP 80
34686: PUSH
34687: LD_VAR 0 2
34691: ARRAY
34692: PUSH
34693: LD_INT 1
34695: PLUS
34696: PUSH
34697: EMPTY
34698: LIST
34699: LIST
34700: PPUSH
34701: LD_EXP 79
34705: PUSH
34706: LD_VAR 0 2
34710: ARRAY
34711: PUSH
34712: LD_INT 1
34714: ARRAY
34715: PPUSH
34716: CALL 52906 0 3
34720: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34721: LD_EXP 79
34725: PUSH
34726: LD_VAR 0 2
34730: ARRAY
34731: PUSH
34732: LD_INT 1
34734: ARRAY
34735: PPUSH
34736: LD_INT 112
34738: PPUSH
34739: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34743: LD_ADDR_VAR 0 9
34747: PUSH
34748: LD_EXP 79
34752: PUSH
34753: LD_VAR 0 2
34757: ARRAY
34758: PPUSH
34759: LD_INT 1
34761: PPUSH
34762: CALL_OW 3
34766: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34767: LD_ADDR_EXP 79
34771: PUSH
34772: LD_EXP 79
34776: PPUSH
34777: LD_VAR 0 2
34781: PPUSH
34782: LD_VAR 0 9
34786: PPUSH
34787: CALL_OW 1
34791: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34792: LD_EXP 79
34796: PUSH
34797: LD_VAR 0 2
34801: ARRAY
34802: PUSH
34803: LD_EXP 80
34807: PUSH
34808: LD_VAR 0 2
34812: ARRAY
34813: AND
34814: PUSH
34815: LD_EXP 80
34819: PUSH
34820: LD_VAR 0 2
34824: ARRAY
34825: PUSH
34826: LD_INT 1
34828: ARRAY
34829: PPUSH
34830: CALL_OW 310
34834: NOT
34835: AND
34836: PUSH
34837: LD_VAR 0 3
34841: PPUSH
34842: CALL_OW 313
34846: PUSH
34847: LD_INT 6
34849: EQUAL
34850: AND
34851: IFFALSE 34907
// begin tmp2 := UnitsInside ( j ) ;
34853: LD_ADDR_VAR 0 9
34857: PUSH
34858: LD_VAR 0 3
34862: PPUSH
34863: CALL_OW 313
34867: ST_TO_ADDR
// if tmp2 = 6 then
34868: LD_VAR 0 9
34872: PUSH
34873: LD_INT 6
34875: EQUAL
34876: IFFALSE 34907
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
34878: LD_VAR 0 9
34882: PUSH
34883: LD_INT 1
34885: ARRAY
34886: PPUSH
34887: LD_INT 112
34889: PPUSH
34890: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
34894: LD_VAR 0 9
34898: PUSH
34899: LD_INT 1
34901: ARRAY
34902: PPUSH
34903: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
34907: LD_EXP 80
34911: PUSH
34912: LD_VAR 0 2
34916: ARRAY
34917: PUSH
34918: LD_EXP 80
34922: PUSH
34923: LD_VAR 0 2
34927: ARRAY
34928: PUSH
34929: LD_INT 1
34931: ARRAY
34932: PPUSH
34933: CALL_OW 314
34937: NOT
34938: AND
34939: PUSH
34940: LD_EXP 80
34944: PUSH
34945: LD_VAR 0 2
34949: ARRAY
34950: PUSH
34951: LD_INT 1
34953: ARRAY
34954: PPUSH
34955: CALL_OW 310
34959: NOT
34960: AND
34961: IFFALSE 34987
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
34963: LD_EXP 80
34967: PUSH
34968: LD_VAR 0 2
34972: ARRAY
34973: PUSH
34974: LD_INT 1
34976: ARRAY
34977: PPUSH
34978: LD_VAR 0 3
34982: PPUSH
34983: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34987: LD_EXP 80
34991: PUSH
34992: LD_VAR 0 2
34996: ARRAY
34997: PUSH
34998: LD_INT 1
35000: ARRAY
35001: PPUSH
35002: CALL_OW 310
35006: PUSH
35007: LD_EXP 80
35011: PUSH
35012: LD_VAR 0 2
35016: ARRAY
35017: PUSH
35018: LD_INT 1
35020: ARRAY
35021: PPUSH
35022: CALL_OW 310
35026: PPUSH
35027: CALL_OW 461
35031: PUSH
35032: LD_INT 3
35034: NONEQUAL
35035: AND
35036: IFFALSE 35057
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35038: LD_EXP 80
35042: PUSH
35043: LD_VAR 0 2
35047: ARRAY
35048: PUSH
35049: LD_INT 1
35051: ARRAY
35052: PPUSH
35053: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35057: LD_VAR 0 3
35061: PPUSH
35062: CALL_OW 461
35066: PUSH
35067: LD_INT 6
35069: EQUAL
35070: PUSH
35071: LD_VAR 0 6
35075: PUSH
35076: LD_INT 1
35078: GREATER
35079: AND
35080: IFFALSE 35232
// begin sci := [ ] ;
35082: LD_ADDR_VAR 0 8
35086: PUSH
35087: EMPTY
35088: ST_TO_ADDR
// for x in ( tmp diff j ) do
35089: LD_ADDR_VAR 0 7
35093: PUSH
35094: LD_VAR 0 6
35098: PUSH
35099: LD_VAR 0 3
35103: DIFF
35104: PUSH
35105: FOR_IN
35106: IFFALSE 35158
// begin if sci = 6 then
35108: LD_VAR 0 8
35112: PUSH
35113: LD_INT 6
35115: EQUAL
35116: IFFALSE 35120
// break ;
35118: GO 35158
// if BuildingStatus ( x ) = bs_idle then
35120: LD_VAR 0 7
35124: PPUSH
35125: CALL_OW 461
35129: PUSH
35130: LD_INT 2
35132: EQUAL
35133: IFFALSE 35156
// sci := sci ^ UnitsInside ( x ) ;
35135: LD_ADDR_VAR 0 8
35139: PUSH
35140: LD_VAR 0 8
35144: PUSH
35145: LD_VAR 0 7
35149: PPUSH
35150: CALL_OW 313
35154: ADD
35155: ST_TO_ADDR
// end ;
35156: GO 35105
35158: POP
35159: POP
// if not sci then
35160: LD_VAR 0 8
35164: NOT
35165: IFFALSE 35169
// continue ;
35167: GO 34214
// for x in sci do
35169: LD_ADDR_VAR 0 7
35173: PUSH
35174: LD_VAR 0 8
35178: PUSH
35179: FOR_IN
35180: IFFALSE 35230
// if IsInUnit ( x ) and not HasTask ( x ) then
35182: LD_VAR 0 7
35186: PPUSH
35187: CALL_OW 310
35191: PUSH
35192: LD_VAR 0 7
35196: PPUSH
35197: CALL_OW 314
35201: NOT
35202: AND
35203: IFFALSE 35228
// begin ComExitBuilding ( x ) ;
35205: LD_VAR 0 7
35209: PPUSH
35210: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35214: LD_VAR 0 7
35218: PPUSH
35219: LD_VAR 0 3
35223: PPUSH
35224: CALL_OW 180
// end ;
35228: GO 35179
35230: POP
35231: POP
// end ; end ;
35232: GO 34214
35234: POP
35235: POP
// end ;
35236: GO 34168
35238: POP
35239: POP
// end ;
35240: LD_VAR 0 1
35244: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35245: LD_INT 0
35247: PPUSH
35248: PPUSH
// if not mc_bases then
35249: LD_EXP 50
35253: NOT
35254: IFFALSE 35258
// exit ;
35256: GO 35339
// for i = 1 to mc_bases do
35258: LD_ADDR_VAR 0 2
35262: PUSH
35263: DOUBLE
35264: LD_INT 1
35266: DEC
35267: ST_TO_ADDR
35268: LD_EXP 50
35272: PUSH
35273: FOR_TO
35274: IFFALSE 35337
// if mc_mines [ i ] and mc_miners [ i ] then
35276: LD_EXP 63
35280: PUSH
35281: LD_VAR 0 2
35285: ARRAY
35286: PUSH
35287: LD_EXP 64
35291: PUSH
35292: LD_VAR 0 2
35296: ARRAY
35297: AND
35298: IFFALSE 35335
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35300: LD_EXP 64
35304: PUSH
35305: LD_VAR 0 2
35309: ARRAY
35310: PUSH
35311: LD_INT 1
35313: ARRAY
35314: PPUSH
35315: CALL_OW 255
35319: PPUSH
35320: LD_EXP 63
35324: PUSH
35325: LD_VAR 0 2
35329: ARRAY
35330: PPUSH
35331: CALL 49895 0 2
35335: GO 35273
35337: POP
35338: POP
// end ;
35339: LD_VAR 0 1
35343: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35344: LD_INT 0
35346: PPUSH
35347: PPUSH
35348: PPUSH
35349: PPUSH
35350: PPUSH
35351: PPUSH
35352: PPUSH
35353: PPUSH
// if not mc_bases or not mc_parking then
35354: LD_EXP 50
35358: NOT
35359: PUSH
35360: LD_EXP 74
35364: NOT
35365: OR
35366: IFFALSE 35370
// exit ;
35368: GO 36069
// for i = 1 to mc_bases do
35370: LD_ADDR_VAR 0 2
35374: PUSH
35375: DOUBLE
35376: LD_INT 1
35378: DEC
35379: ST_TO_ADDR
35380: LD_EXP 50
35384: PUSH
35385: FOR_TO
35386: IFFALSE 36067
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
35388: LD_EXP 50
35392: PUSH
35393: LD_VAR 0 2
35397: ARRAY
35398: NOT
35399: PUSH
35400: LD_EXP 74
35404: PUSH
35405: LD_VAR 0 2
35409: ARRAY
35410: NOT
35411: OR
35412: IFFALSE 35416
// continue ;
35414: GO 35385
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35416: LD_ADDR_VAR 0 5
35420: PUSH
35421: LD_EXP 50
35425: PUSH
35426: LD_VAR 0 2
35430: ARRAY
35431: PUSH
35432: LD_INT 1
35434: ARRAY
35435: PPUSH
35436: CALL_OW 255
35440: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35441: LD_ADDR_VAR 0 6
35445: PUSH
35446: LD_EXP 50
35450: PUSH
35451: LD_VAR 0 2
35455: ARRAY
35456: PPUSH
35457: LD_INT 30
35459: PUSH
35460: LD_INT 3
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PPUSH
35467: CALL_OW 72
35471: ST_TO_ADDR
// if not fac then
35472: LD_VAR 0 6
35476: NOT
35477: IFFALSE 35528
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35479: LD_ADDR_VAR 0 6
35483: PUSH
35484: LD_EXP 50
35488: PUSH
35489: LD_VAR 0 2
35493: ARRAY
35494: PPUSH
35495: LD_INT 2
35497: PUSH
35498: LD_INT 30
35500: PUSH
35501: LD_INT 0
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 30
35510: PUSH
35511: LD_INT 1
35513: PUSH
35514: EMPTY
35515: LIST
35516: LIST
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: LIST
35522: PPUSH
35523: CALL_OW 72
35527: ST_TO_ADDR
// if not fac then
35528: LD_VAR 0 6
35532: NOT
35533: IFFALSE 35537
// continue ;
35535: GO 35385
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35537: LD_ADDR_VAR 0 7
35541: PUSH
35542: LD_EXP 74
35546: PUSH
35547: LD_VAR 0 2
35551: ARRAY
35552: PPUSH
35553: LD_INT 22
35555: PUSH
35556: LD_VAR 0 5
35560: PUSH
35561: EMPTY
35562: LIST
35563: LIST
35564: PUSH
35565: LD_INT 21
35567: PUSH
35568: LD_INT 2
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 3
35577: PUSH
35578: LD_INT 24
35580: PUSH
35581: LD_INT 1000
35583: PUSH
35584: EMPTY
35585: LIST
35586: LIST
35587: PUSH
35588: EMPTY
35589: LIST
35590: LIST
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: LIST
35596: PPUSH
35597: CALL_OW 70
35601: ST_TO_ADDR
// for j in fac do
35602: LD_ADDR_VAR 0 3
35606: PUSH
35607: LD_VAR 0 6
35611: PUSH
35612: FOR_IN
35613: IFFALSE 35694
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35615: LD_ADDR_VAR 0 7
35619: PUSH
35620: LD_VAR 0 7
35624: PUSH
35625: LD_INT 22
35627: PUSH
35628: LD_VAR 0 5
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: LD_INT 91
35639: PUSH
35640: LD_VAR 0 3
35644: PUSH
35645: LD_INT 15
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: LIST
35652: PUSH
35653: LD_INT 21
35655: PUSH
35656: LD_INT 2
35658: PUSH
35659: EMPTY
35660: LIST
35661: LIST
35662: PUSH
35663: LD_INT 3
35665: PUSH
35666: LD_INT 24
35668: PUSH
35669: LD_INT 1000
35671: PUSH
35672: EMPTY
35673: LIST
35674: LIST
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: LIST
35684: LIST
35685: PPUSH
35686: CALL_OW 69
35690: UNION
35691: ST_TO_ADDR
35692: GO 35612
35694: POP
35695: POP
// if not vehs then
35696: LD_VAR 0 7
35700: NOT
35701: IFFALSE 35727
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35703: LD_ADDR_EXP 62
35707: PUSH
35708: LD_EXP 62
35712: PPUSH
35713: LD_VAR 0 2
35717: PPUSH
35718: EMPTY
35719: PPUSH
35720: CALL_OW 1
35724: ST_TO_ADDR
// continue ;
35725: GO 35385
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35727: LD_ADDR_VAR 0 8
35731: PUSH
35732: LD_EXP 50
35736: PUSH
35737: LD_VAR 0 2
35741: ARRAY
35742: PPUSH
35743: LD_INT 30
35745: PUSH
35746: LD_INT 3
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PPUSH
35753: CALL_OW 72
35757: ST_TO_ADDR
// if tmp then
35758: LD_VAR 0 8
35762: IFFALSE 35865
// begin for j in tmp do
35764: LD_ADDR_VAR 0 3
35768: PUSH
35769: LD_VAR 0 8
35773: PUSH
35774: FOR_IN
35775: IFFALSE 35863
// for k in UnitsInside ( j ) do
35777: LD_ADDR_VAR 0 4
35781: PUSH
35782: LD_VAR 0 3
35786: PPUSH
35787: CALL_OW 313
35791: PUSH
35792: FOR_IN
35793: IFFALSE 35859
// if k then
35795: LD_VAR 0 4
35799: IFFALSE 35857
// if not k in mc_repair_vehicle [ i ] then
35801: LD_VAR 0 4
35805: PUSH
35806: LD_EXP 62
35810: PUSH
35811: LD_VAR 0 2
35815: ARRAY
35816: IN
35817: NOT
35818: IFFALSE 35857
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35820: LD_ADDR_EXP 62
35824: PUSH
35825: LD_EXP 62
35829: PPUSH
35830: LD_VAR 0 2
35834: PPUSH
35835: LD_EXP 62
35839: PUSH
35840: LD_VAR 0 2
35844: ARRAY
35845: PUSH
35846: LD_VAR 0 4
35850: UNION
35851: PPUSH
35852: CALL_OW 1
35856: ST_TO_ADDR
35857: GO 35792
35859: POP
35860: POP
35861: GO 35774
35863: POP
35864: POP
// end ; if not mc_repair_vehicle [ i ] then
35865: LD_EXP 62
35869: PUSH
35870: LD_VAR 0 2
35874: ARRAY
35875: NOT
35876: IFFALSE 35880
// continue ;
35878: GO 35385
// for j in mc_repair_vehicle [ i ] do
35880: LD_ADDR_VAR 0 3
35884: PUSH
35885: LD_EXP 62
35889: PUSH
35890: LD_VAR 0 2
35894: ARRAY
35895: PUSH
35896: FOR_IN
35897: IFFALSE 36063
// begin if GetClass ( j ) <> 3 then
35899: LD_VAR 0 3
35903: PPUSH
35904: CALL_OW 257
35908: PUSH
35909: LD_INT 3
35911: NONEQUAL
35912: IFFALSE 35953
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
35914: LD_ADDR_EXP 62
35918: PUSH
35919: LD_EXP 62
35923: PPUSH
35924: LD_VAR 0 2
35928: PPUSH
35929: LD_EXP 62
35933: PUSH
35934: LD_VAR 0 2
35938: ARRAY
35939: PUSH
35940: LD_VAR 0 3
35944: DIFF
35945: PPUSH
35946: CALL_OW 1
35950: ST_TO_ADDR
// continue ;
35951: GO 35896
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
35953: LD_VAR 0 3
35957: PPUSH
35958: CALL_OW 311
35962: NOT
35963: PUSH
35964: LD_VAR 0 3
35968: PUSH
35969: LD_EXP 53
35973: PUSH
35974: LD_VAR 0 2
35978: ARRAY
35979: PUSH
35980: LD_INT 1
35982: ARRAY
35983: IN
35984: NOT
35985: AND
35986: PUSH
35987: LD_VAR 0 3
35991: PUSH
35992: LD_EXP 53
35996: PUSH
35997: LD_VAR 0 2
36001: ARRAY
36002: PUSH
36003: LD_INT 2
36005: ARRAY
36006: IN
36007: NOT
36008: AND
36009: IFFALSE 36061
// begin if IsInUnit ( j ) then
36011: LD_VAR 0 3
36015: PPUSH
36016: CALL_OW 310
36020: IFFALSE 36031
// ComExitBuilding ( j ) ;
36022: LD_VAR 0 3
36026: PPUSH
36027: CALL_OW 122
// if not HasTask ( j ) then
36031: LD_VAR 0 3
36035: PPUSH
36036: CALL_OW 314
36040: NOT
36041: IFFALSE 36061
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
36043: LD_VAR 0 3
36047: PPUSH
36048: LD_VAR 0 7
36052: PUSH
36053: LD_INT 1
36055: ARRAY
36056: PPUSH
36057: CALL_OW 189
// end ; end ;
36061: GO 35896
36063: POP
36064: POP
// end ;
36065: GO 35385
36067: POP
36068: POP
// end ;
36069: LD_VAR 0 1
36073: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36074: LD_INT 0
36076: PPUSH
36077: PPUSH
36078: PPUSH
36079: PPUSH
36080: PPUSH
36081: PPUSH
36082: PPUSH
36083: PPUSH
36084: PPUSH
36085: PPUSH
36086: PPUSH
// if not mc_bases then
36087: LD_EXP 50
36091: NOT
36092: IFFALSE 36096
// exit ;
36094: GO 36898
// for i = 1 to mc_bases do
36096: LD_ADDR_VAR 0 2
36100: PUSH
36101: DOUBLE
36102: LD_INT 1
36104: DEC
36105: ST_TO_ADDR
36106: LD_EXP 50
36110: PUSH
36111: FOR_TO
36112: IFFALSE 36896
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36114: LD_EXP 78
36118: PUSH
36119: LD_VAR 0 2
36123: ARRAY
36124: NOT
36125: PUSH
36126: LD_EXP 53
36130: PUSH
36131: LD_VAR 0 2
36135: ARRAY
36136: PUSH
36137: LD_INT 1
36139: ARRAY
36140: OR
36141: PUSH
36142: LD_EXP 53
36146: PUSH
36147: LD_VAR 0 2
36151: ARRAY
36152: PUSH
36153: LD_INT 2
36155: ARRAY
36156: OR
36157: PUSH
36158: LD_EXP 76
36162: PUSH
36163: LD_VAR 0 2
36167: ARRAY
36168: PPUSH
36169: LD_INT 1
36171: PPUSH
36172: CALL_OW 325
36176: NOT
36177: OR
36178: PUSH
36179: LD_EXP 73
36183: PUSH
36184: LD_VAR 0 2
36188: ARRAY
36189: OR
36190: IFFALSE 36194
// continue ;
36192: GO 36111
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36194: LD_ADDR_VAR 0 8
36198: PUSH
36199: LD_EXP 50
36203: PUSH
36204: LD_VAR 0 2
36208: ARRAY
36209: PPUSH
36210: LD_INT 25
36212: PUSH
36213: LD_INT 4
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 50
36222: PUSH
36223: EMPTY
36224: LIST
36225: PUSH
36226: LD_INT 3
36228: PUSH
36229: LD_INT 60
36231: PUSH
36232: EMPTY
36233: LIST
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: LIST
36243: PPUSH
36244: CALL_OW 72
36248: PUSH
36249: LD_EXP 54
36253: PUSH
36254: LD_VAR 0 2
36258: ARRAY
36259: DIFF
36260: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36261: LD_ADDR_VAR 0 9
36265: PUSH
36266: LD_EXP 50
36270: PUSH
36271: LD_VAR 0 2
36275: ARRAY
36276: PPUSH
36277: LD_INT 2
36279: PUSH
36280: LD_INT 30
36282: PUSH
36283: LD_INT 0
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 30
36292: PUSH
36293: LD_INT 1
36295: PUSH
36296: EMPTY
36297: LIST
36298: LIST
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: LIST
36304: PPUSH
36305: CALL_OW 72
36309: ST_TO_ADDR
// if not tmp or not dep then
36310: LD_VAR 0 8
36314: NOT
36315: PUSH
36316: LD_VAR 0 9
36320: NOT
36321: OR
36322: IFFALSE 36326
// continue ;
36324: GO 36111
// side := GetSide ( tmp [ 1 ] ) ;
36326: LD_ADDR_VAR 0 11
36330: PUSH
36331: LD_VAR 0 8
36335: PUSH
36336: LD_INT 1
36338: ARRAY
36339: PPUSH
36340: CALL_OW 255
36344: ST_TO_ADDR
// dep := dep [ 1 ] ;
36345: LD_ADDR_VAR 0 9
36349: PUSH
36350: LD_VAR 0 9
36354: PUSH
36355: LD_INT 1
36357: ARRAY
36358: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
36359: LD_ADDR_VAR 0 7
36363: PUSH
36364: LD_EXP 78
36368: PUSH
36369: LD_VAR 0 2
36373: ARRAY
36374: PPUSH
36375: LD_INT 22
36377: PUSH
36378: LD_INT 0
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 25
36387: PUSH
36388: LD_INT 12
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: PPUSH
36399: CALL_OW 70
36403: PUSH
36404: LD_INT 22
36406: PUSH
36407: LD_INT 0
36409: PUSH
36410: EMPTY
36411: LIST
36412: LIST
36413: PUSH
36414: LD_INT 25
36416: PUSH
36417: LD_INT 12
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 91
36426: PUSH
36427: LD_VAR 0 9
36431: PUSH
36432: LD_INT 20
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: LIST
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: LIST
36444: PPUSH
36445: CALL_OW 69
36449: UNION
36450: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
36451: LD_ADDR_VAR 0 10
36455: PUSH
36456: LD_EXP 78
36460: PUSH
36461: LD_VAR 0 2
36465: ARRAY
36466: PPUSH
36467: LD_INT 81
36469: PUSH
36470: LD_VAR 0 11
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PPUSH
36479: CALL_OW 70
36483: ST_TO_ADDR
// if not apes or danger_at_area then
36484: LD_VAR 0 7
36488: NOT
36489: PUSH
36490: LD_VAR 0 10
36494: OR
36495: IFFALSE 36545
// begin if mc_taming [ i ] then
36497: LD_EXP 81
36501: PUSH
36502: LD_VAR 0 2
36506: ARRAY
36507: IFFALSE 36543
// begin MC_Reset ( i , 121 ) ;
36509: LD_VAR 0 2
36513: PPUSH
36514: LD_INT 121
36516: PPUSH
36517: CALL 21927 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36521: LD_ADDR_EXP 81
36525: PUSH
36526: LD_EXP 81
36530: PPUSH
36531: LD_VAR 0 2
36535: PPUSH
36536: EMPTY
36537: PPUSH
36538: CALL_OW 1
36542: ST_TO_ADDR
// end ; continue ;
36543: GO 36111
// end ; for j in tmp do
36545: LD_ADDR_VAR 0 3
36549: PUSH
36550: LD_VAR 0 8
36554: PUSH
36555: FOR_IN
36556: IFFALSE 36892
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
36558: LD_VAR 0 3
36562: PUSH
36563: LD_EXP 81
36567: PUSH
36568: LD_VAR 0 2
36572: ARRAY
36573: IN
36574: NOT
36575: PUSH
36576: LD_EXP 81
36580: PUSH
36581: LD_VAR 0 2
36585: ARRAY
36586: PUSH
36587: LD_INT 3
36589: LESS
36590: AND
36591: IFFALSE 36649
// begin SetTag ( j , 121 ) ;
36593: LD_VAR 0 3
36597: PPUSH
36598: LD_INT 121
36600: PPUSH
36601: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
36605: LD_ADDR_EXP 81
36609: PUSH
36610: LD_EXP 81
36614: PPUSH
36615: LD_VAR 0 2
36619: PUSH
36620: LD_EXP 81
36624: PUSH
36625: LD_VAR 0 2
36629: ARRAY
36630: PUSH
36631: LD_INT 1
36633: PLUS
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PPUSH
36639: LD_VAR 0 3
36643: PPUSH
36644: CALL 52906 0 3
36648: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
36649: LD_VAR 0 3
36653: PUSH
36654: LD_EXP 81
36658: PUSH
36659: LD_VAR 0 2
36663: ARRAY
36664: IN
36665: IFFALSE 36890
// begin if GetClass ( j ) <> 4 then
36667: LD_VAR 0 3
36671: PPUSH
36672: CALL_OW 257
36676: PUSH
36677: LD_INT 4
36679: NONEQUAL
36680: IFFALSE 36733
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
36682: LD_ADDR_EXP 81
36686: PUSH
36687: LD_EXP 81
36691: PPUSH
36692: LD_VAR 0 2
36696: PPUSH
36697: LD_EXP 81
36701: PUSH
36702: LD_VAR 0 2
36706: ARRAY
36707: PUSH
36708: LD_VAR 0 3
36712: DIFF
36713: PPUSH
36714: CALL_OW 1
36718: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36719: LD_VAR 0 3
36723: PPUSH
36724: LD_INT 0
36726: PPUSH
36727: CALL_OW 109
// continue ;
36731: GO 36555
// end ; if IsInUnit ( j ) then
36733: LD_VAR 0 3
36737: PPUSH
36738: CALL_OW 310
36742: IFFALSE 36753
// ComExitBuilding ( j ) ;
36744: LD_VAR 0 3
36748: PPUSH
36749: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36753: LD_ADDR_VAR 0 6
36757: PUSH
36758: LD_VAR 0 7
36762: PPUSH
36763: LD_VAR 0 3
36767: PPUSH
36768: CALL_OW 74
36772: ST_TO_ADDR
// if not ape then
36773: LD_VAR 0 6
36777: NOT
36778: IFFALSE 36782
// break ;
36780: GO 36892
// x := GetX ( ape ) ;
36782: LD_ADDR_VAR 0 4
36786: PUSH
36787: LD_VAR 0 6
36791: PPUSH
36792: CALL_OW 250
36796: ST_TO_ADDR
// y := GetY ( ape ) ;
36797: LD_ADDR_VAR 0 5
36801: PUSH
36802: LD_VAR 0 6
36806: PPUSH
36807: CALL_OW 251
36811: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36812: LD_VAR 0 4
36816: PPUSH
36817: LD_VAR 0 5
36821: PPUSH
36822: CALL_OW 488
36826: NOT
36827: PUSH
36828: LD_VAR 0 11
36832: PPUSH
36833: LD_VAR 0 4
36837: PPUSH
36838: LD_VAR 0 5
36842: PPUSH
36843: LD_INT 20
36845: PPUSH
36846: CALL 53802 0 4
36850: PUSH
36851: LD_INT 4
36853: ARRAY
36854: OR
36855: IFFALSE 36859
// break ;
36857: GO 36892
// if not HasTask ( j ) then
36859: LD_VAR 0 3
36863: PPUSH
36864: CALL_OW 314
36868: NOT
36869: IFFALSE 36890
// ComTameXY ( j , x , y ) ;
36871: LD_VAR 0 3
36875: PPUSH
36876: LD_VAR 0 4
36880: PPUSH
36881: LD_VAR 0 5
36885: PPUSH
36886: CALL_OW 131
// end ; end ;
36890: GO 36555
36892: POP
36893: POP
// end ;
36894: GO 36111
36896: POP
36897: POP
// end ;
36898: LD_VAR 0 1
36902: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
36903: LD_INT 0
36905: PPUSH
36906: PPUSH
36907: PPUSH
36908: PPUSH
36909: PPUSH
36910: PPUSH
36911: PPUSH
36912: PPUSH
// if not mc_bases then
36913: LD_EXP 50
36917: NOT
36918: IFFALSE 36922
// exit ;
36920: GO 37548
// for i = 1 to mc_bases do
36922: LD_ADDR_VAR 0 2
36926: PUSH
36927: DOUBLE
36928: LD_INT 1
36930: DEC
36931: ST_TO_ADDR
36932: LD_EXP 50
36936: PUSH
36937: FOR_TO
36938: IFFALSE 37546
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
36940: LD_EXP 79
36944: PUSH
36945: LD_VAR 0 2
36949: ARRAY
36950: NOT
36951: PUSH
36952: LD_EXP 79
36956: PUSH
36957: LD_VAR 0 2
36961: ARRAY
36962: PPUSH
36963: LD_INT 25
36965: PUSH
36966: LD_INT 12
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PPUSH
36973: CALL_OW 72
36977: NOT
36978: OR
36979: IFFALSE 36983
// continue ;
36981: GO 36937
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36983: LD_ADDR_VAR 0 5
36987: PUSH
36988: LD_EXP 79
36992: PUSH
36993: LD_VAR 0 2
36997: ARRAY
36998: PUSH
36999: LD_INT 1
37001: ARRAY
37002: PPUSH
37003: CALL_OW 255
37007: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37008: LD_VAR 0 5
37012: PPUSH
37013: LD_INT 2
37015: PPUSH
37016: CALL_OW 325
37020: IFFALSE 37273
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37022: LD_ADDR_VAR 0 4
37026: PUSH
37027: LD_EXP 79
37031: PUSH
37032: LD_VAR 0 2
37036: ARRAY
37037: PPUSH
37038: LD_INT 25
37040: PUSH
37041: LD_INT 16
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PPUSH
37048: CALL_OW 72
37052: ST_TO_ADDR
// if tmp < 6 then
37053: LD_VAR 0 4
37057: PUSH
37058: LD_INT 6
37060: LESS
37061: IFFALSE 37273
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37063: LD_ADDR_VAR 0 6
37067: PUSH
37068: LD_EXP 50
37072: PUSH
37073: LD_VAR 0 2
37077: ARRAY
37078: PPUSH
37079: LD_INT 2
37081: PUSH
37082: LD_INT 30
37084: PUSH
37085: LD_INT 0
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 30
37094: PUSH
37095: LD_INT 1
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: LIST
37106: PPUSH
37107: CALL_OW 72
37111: ST_TO_ADDR
// if depot then
37112: LD_VAR 0 6
37116: IFFALSE 37273
// begin selected := 0 ;
37118: LD_ADDR_VAR 0 7
37122: PUSH
37123: LD_INT 0
37125: ST_TO_ADDR
// for j in depot do
37126: LD_ADDR_VAR 0 3
37130: PUSH
37131: LD_VAR 0 6
37135: PUSH
37136: FOR_IN
37137: IFFALSE 37168
// begin if UnitsInside ( j ) < 6 then
37139: LD_VAR 0 3
37143: PPUSH
37144: CALL_OW 313
37148: PUSH
37149: LD_INT 6
37151: LESS
37152: IFFALSE 37166
// begin selected := j ;
37154: LD_ADDR_VAR 0 7
37158: PUSH
37159: LD_VAR 0 3
37163: ST_TO_ADDR
// break ;
37164: GO 37168
// end ; end ;
37166: GO 37136
37168: POP
37169: POP
// if selected then
37170: LD_VAR 0 7
37174: IFFALSE 37273
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37176: LD_ADDR_VAR 0 3
37180: PUSH
37181: LD_EXP 79
37185: PUSH
37186: LD_VAR 0 2
37190: ARRAY
37191: PPUSH
37192: LD_INT 25
37194: PUSH
37195: LD_INT 12
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PPUSH
37202: CALL_OW 72
37206: PUSH
37207: FOR_IN
37208: IFFALSE 37271
// if not HasTask ( j ) then
37210: LD_VAR 0 3
37214: PPUSH
37215: CALL_OW 314
37219: NOT
37220: IFFALSE 37269
// begin if not IsInUnit ( j ) then
37222: LD_VAR 0 3
37226: PPUSH
37227: CALL_OW 310
37231: NOT
37232: IFFALSE 37248
// ComEnterUnit ( j , selected ) ;
37234: LD_VAR 0 3
37238: PPUSH
37239: LD_VAR 0 7
37243: PPUSH
37244: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37248: LD_VAR 0 3
37252: PPUSH
37253: LD_INT 16
37255: PPUSH
37256: CALL_OW 183
// AddComExitBuilding ( j ) ;
37260: LD_VAR 0 3
37264: PPUSH
37265: CALL_OW 182
// end ;
37269: GO 37207
37271: POP
37272: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37273: LD_VAR 0 5
37277: PPUSH
37278: LD_INT 11
37280: PPUSH
37281: CALL_OW 325
37285: IFFALSE 37544
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37287: LD_ADDR_VAR 0 4
37291: PUSH
37292: LD_EXP 79
37296: PUSH
37297: LD_VAR 0 2
37301: ARRAY
37302: PPUSH
37303: LD_INT 25
37305: PUSH
37306: LD_INT 16
37308: PUSH
37309: EMPTY
37310: LIST
37311: LIST
37312: PPUSH
37313: CALL_OW 72
37317: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37318: LD_VAR 0 4
37322: PUSH
37323: LD_INT 6
37325: GREATEREQUAL
37326: PUSH
37327: LD_VAR 0 5
37331: PPUSH
37332: LD_INT 2
37334: PPUSH
37335: CALL_OW 325
37339: NOT
37340: OR
37341: IFFALSE 37544
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37343: LD_ADDR_VAR 0 8
37347: PUSH
37348: LD_EXP 50
37352: PUSH
37353: LD_VAR 0 2
37357: ARRAY
37358: PPUSH
37359: LD_INT 2
37361: PUSH
37362: LD_INT 30
37364: PUSH
37365: LD_INT 4
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PUSH
37372: LD_INT 30
37374: PUSH
37375: LD_INT 5
37377: PUSH
37378: EMPTY
37379: LIST
37380: LIST
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: LIST
37386: PPUSH
37387: CALL_OW 72
37391: ST_TO_ADDR
// if barracks then
37392: LD_VAR 0 8
37396: IFFALSE 37544
// begin selected := 0 ;
37398: LD_ADDR_VAR 0 7
37402: PUSH
37403: LD_INT 0
37405: ST_TO_ADDR
// for j in barracks do
37406: LD_ADDR_VAR 0 3
37410: PUSH
37411: LD_VAR 0 8
37415: PUSH
37416: FOR_IN
37417: IFFALSE 37448
// begin if UnitsInside ( j ) < 6 then
37419: LD_VAR 0 3
37423: PPUSH
37424: CALL_OW 313
37428: PUSH
37429: LD_INT 6
37431: LESS
37432: IFFALSE 37446
// begin selected := j ;
37434: LD_ADDR_VAR 0 7
37438: PUSH
37439: LD_VAR 0 3
37443: ST_TO_ADDR
// break ;
37444: GO 37448
// end ; end ;
37446: GO 37416
37448: POP
37449: POP
// if selected then
37450: LD_VAR 0 7
37454: IFFALSE 37544
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37456: LD_ADDR_VAR 0 3
37460: PUSH
37461: LD_EXP 79
37465: PUSH
37466: LD_VAR 0 2
37470: ARRAY
37471: PPUSH
37472: LD_INT 25
37474: PUSH
37475: LD_INT 12
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: PPUSH
37482: CALL_OW 72
37486: PUSH
37487: FOR_IN
37488: IFFALSE 37542
// if not IsInUnit ( j ) and not HasTask ( j ) then
37490: LD_VAR 0 3
37494: PPUSH
37495: CALL_OW 310
37499: NOT
37500: PUSH
37501: LD_VAR 0 3
37505: PPUSH
37506: CALL_OW 314
37510: NOT
37511: AND
37512: IFFALSE 37540
// begin ComEnterUnit ( j , selected ) ;
37514: LD_VAR 0 3
37518: PPUSH
37519: LD_VAR 0 7
37523: PPUSH
37524: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
37528: LD_VAR 0 3
37532: PPUSH
37533: LD_INT 15
37535: PPUSH
37536: CALL_OW 183
// end ;
37540: GO 37487
37542: POP
37543: POP
// end ; end ; end ; end ; end ;
37544: GO 36937
37546: POP
37547: POP
// end ;
37548: LD_VAR 0 1
37552: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
37553: LD_INT 0
37555: PPUSH
37556: PPUSH
37557: PPUSH
37558: PPUSH
// if not mc_bases then
37559: LD_EXP 50
37563: NOT
37564: IFFALSE 37568
// exit ;
37566: GO 37746
// for i = 1 to mc_bases do
37568: LD_ADDR_VAR 0 2
37572: PUSH
37573: DOUBLE
37574: LD_INT 1
37576: DEC
37577: ST_TO_ADDR
37578: LD_EXP 50
37582: PUSH
37583: FOR_TO
37584: IFFALSE 37744
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
37586: LD_ADDR_VAR 0 4
37590: PUSH
37591: LD_EXP 50
37595: PUSH
37596: LD_VAR 0 2
37600: ARRAY
37601: PPUSH
37602: LD_INT 25
37604: PUSH
37605: LD_INT 9
37607: PUSH
37608: EMPTY
37609: LIST
37610: LIST
37611: PPUSH
37612: CALL_OW 72
37616: ST_TO_ADDR
// if not tmp then
37617: LD_VAR 0 4
37621: NOT
37622: IFFALSE 37626
// continue ;
37624: GO 37583
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
37626: LD_EXP 76
37630: PUSH
37631: LD_VAR 0 2
37635: ARRAY
37636: PPUSH
37637: LD_INT 29
37639: PPUSH
37640: CALL_OW 325
37644: NOT
37645: PUSH
37646: LD_EXP 76
37650: PUSH
37651: LD_VAR 0 2
37655: ARRAY
37656: PPUSH
37657: LD_INT 28
37659: PPUSH
37660: CALL_OW 325
37664: NOT
37665: AND
37666: IFFALSE 37670
// continue ;
37668: GO 37583
// for j in tmp do
37670: LD_ADDR_VAR 0 3
37674: PUSH
37675: LD_VAR 0 4
37679: PUSH
37680: FOR_IN
37681: IFFALSE 37740
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37683: LD_VAR 0 3
37687: PUSH
37688: LD_EXP 53
37692: PUSH
37693: LD_VAR 0 2
37697: ARRAY
37698: PUSH
37699: LD_INT 1
37701: ARRAY
37702: IN
37703: NOT
37704: PUSH
37705: LD_VAR 0 3
37709: PUSH
37710: LD_EXP 53
37714: PUSH
37715: LD_VAR 0 2
37719: ARRAY
37720: PUSH
37721: LD_INT 2
37723: ARRAY
37724: IN
37725: NOT
37726: AND
37727: IFFALSE 37738
// ComSpaceTimeShoot ( j ) ;
37729: LD_VAR 0 3
37733: PPUSH
37734: CALL 48903 0 1
37738: GO 37680
37740: POP
37741: POP
// end ;
37742: GO 37583
37744: POP
37745: POP
// end ;
37746: LD_VAR 0 1
37750: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37751: LD_INT 0
37753: PPUSH
37754: PPUSH
37755: PPUSH
37756: PPUSH
37757: PPUSH
37758: PPUSH
37759: PPUSH
37760: PPUSH
37761: PPUSH
// if not mc_bases then
37762: LD_EXP 50
37766: NOT
37767: IFFALSE 37771
// exit ;
37769: GO 38393
// for i = 1 to mc_bases do
37771: LD_ADDR_VAR 0 2
37775: PUSH
37776: DOUBLE
37777: LD_INT 1
37779: DEC
37780: ST_TO_ADDR
37781: LD_EXP 50
37785: PUSH
37786: FOR_TO
37787: IFFALSE 38391
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37789: LD_EXP 85
37793: PUSH
37794: LD_VAR 0 2
37798: ARRAY
37799: NOT
37800: PUSH
37801: LD_INT 38
37803: PPUSH
37804: LD_EXP 76
37808: PUSH
37809: LD_VAR 0 2
37813: ARRAY
37814: PPUSH
37815: CALL_OW 321
37819: PUSH
37820: LD_INT 2
37822: NONEQUAL
37823: OR
37824: IFFALSE 37828
// continue ;
37826: GO 37786
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37828: LD_ADDR_VAR 0 8
37832: PUSH
37833: LD_EXP 50
37837: PUSH
37838: LD_VAR 0 2
37842: ARRAY
37843: PPUSH
37844: LD_INT 30
37846: PUSH
37847: LD_INT 34
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PPUSH
37854: CALL_OW 72
37858: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
37859: LD_ADDR_VAR 0 9
37863: PUSH
37864: LD_EXP 50
37868: PUSH
37869: LD_VAR 0 2
37873: ARRAY
37874: PPUSH
37875: LD_INT 25
37877: PUSH
37878: LD_INT 4
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PPUSH
37885: CALL_OW 72
37889: PPUSH
37890: LD_INT 0
37892: PPUSH
37893: CALL 81800 0 2
37897: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
37898: LD_VAR 0 9
37902: NOT
37903: PUSH
37904: LD_VAR 0 8
37908: NOT
37909: OR
37910: PUSH
37911: LD_EXP 50
37915: PUSH
37916: LD_VAR 0 2
37920: ARRAY
37921: PPUSH
37922: LD_INT 124
37924: PPUSH
37925: CALL 81800 0 2
37929: OR
37930: IFFALSE 37934
// continue ;
37932: GO 37786
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
37934: LD_EXP 86
37938: PUSH
37939: LD_VAR 0 2
37943: ARRAY
37944: PUSH
37945: LD_EXP 85
37949: PUSH
37950: LD_VAR 0 2
37954: ARRAY
37955: LESS
37956: PUSH
37957: LD_EXP 86
37961: PUSH
37962: LD_VAR 0 2
37966: ARRAY
37967: PUSH
37968: LD_VAR 0 8
37972: LESS
37973: AND
37974: IFFALSE 38389
// begin tmp := sci [ 1 ] ;
37976: LD_ADDR_VAR 0 7
37980: PUSH
37981: LD_VAR 0 9
37985: PUSH
37986: LD_INT 1
37988: ARRAY
37989: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37990: LD_VAR 0 7
37994: PPUSH
37995: LD_INT 124
37997: PPUSH
37998: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38002: LD_ADDR_VAR 0 3
38006: PUSH
38007: DOUBLE
38008: LD_EXP 85
38012: PUSH
38013: LD_VAR 0 2
38017: ARRAY
38018: INC
38019: ST_TO_ADDR
38020: LD_EXP 85
38024: PUSH
38025: LD_VAR 0 2
38029: ARRAY
38030: PUSH
38031: FOR_DOWNTO
38032: IFFALSE 38375
// begin if IsInUnit ( tmp ) then
38034: LD_VAR 0 7
38038: PPUSH
38039: CALL_OW 310
38043: IFFALSE 38054
// ComExitBuilding ( tmp ) ;
38045: LD_VAR 0 7
38049: PPUSH
38050: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38054: LD_INT 35
38056: PPUSH
38057: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38061: LD_VAR 0 7
38065: PPUSH
38066: CALL_OW 310
38070: NOT
38071: PUSH
38072: LD_VAR 0 7
38076: PPUSH
38077: CALL_OW 314
38081: NOT
38082: AND
38083: IFFALSE 38054
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38085: LD_ADDR_VAR 0 6
38089: PUSH
38090: LD_VAR 0 7
38094: PPUSH
38095: CALL_OW 250
38099: PUSH
38100: LD_VAR 0 7
38104: PPUSH
38105: CALL_OW 251
38109: PUSH
38110: EMPTY
38111: LIST
38112: LIST
38113: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38114: LD_INT 35
38116: PPUSH
38117: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38121: LD_ADDR_VAR 0 4
38125: PUSH
38126: LD_EXP 85
38130: PUSH
38131: LD_VAR 0 2
38135: ARRAY
38136: PUSH
38137: LD_VAR 0 3
38141: ARRAY
38142: PUSH
38143: LD_INT 1
38145: ARRAY
38146: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38147: LD_ADDR_VAR 0 5
38151: PUSH
38152: LD_EXP 85
38156: PUSH
38157: LD_VAR 0 2
38161: ARRAY
38162: PUSH
38163: LD_VAR 0 3
38167: ARRAY
38168: PUSH
38169: LD_INT 2
38171: ARRAY
38172: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38173: LD_VAR 0 7
38177: PPUSH
38178: LD_INT 10
38180: PPUSH
38181: CALL 55499 0 2
38185: PUSH
38186: LD_INT 4
38188: ARRAY
38189: IFFALSE 38227
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38191: LD_VAR 0 7
38195: PPUSH
38196: LD_VAR 0 6
38200: PUSH
38201: LD_INT 1
38203: ARRAY
38204: PPUSH
38205: LD_VAR 0 6
38209: PUSH
38210: LD_INT 2
38212: ARRAY
38213: PPUSH
38214: CALL_OW 111
// wait ( 0 0$10 ) ;
38218: LD_INT 350
38220: PPUSH
38221: CALL_OW 67
// end else
38225: GO 38253
// begin ComMoveXY ( tmp , x , y ) ;
38227: LD_VAR 0 7
38231: PPUSH
38232: LD_VAR 0 4
38236: PPUSH
38237: LD_VAR 0 5
38241: PPUSH
38242: CALL_OW 111
// wait ( 0 0$3 ) ;
38246: LD_INT 105
38248: PPUSH
38249: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38253: LD_VAR 0 7
38257: PPUSH
38258: LD_VAR 0 4
38262: PPUSH
38263: LD_VAR 0 5
38267: PPUSH
38268: CALL_OW 307
38272: IFFALSE 38114
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38274: LD_VAR 0 7
38278: PPUSH
38279: LD_VAR 0 4
38283: PPUSH
38284: LD_VAR 0 5
38288: PPUSH
38289: LD_VAR 0 8
38293: PUSH
38294: LD_VAR 0 3
38298: ARRAY
38299: PPUSH
38300: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38304: LD_INT 35
38306: PPUSH
38307: CALL_OW 67
// until not HasTask ( tmp ) ;
38311: LD_VAR 0 7
38315: PPUSH
38316: CALL_OW 314
38320: NOT
38321: IFFALSE 38304
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38323: LD_ADDR_EXP 86
38327: PUSH
38328: LD_EXP 86
38332: PPUSH
38333: LD_VAR 0 2
38337: PUSH
38338: LD_EXP 86
38342: PUSH
38343: LD_VAR 0 2
38347: ARRAY
38348: PUSH
38349: LD_INT 1
38351: PLUS
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PPUSH
38357: LD_VAR 0 8
38361: PUSH
38362: LD_VAR 0 3
38366: ARRAY
38367: PPUSH
38368: CALL 52906 0 3
38372: ST_TO_ADDR
// end ;
38373: GO 38031
38375: POP
38376: POP
// MC_Reset ( i , 124 ) ;
38377: LD_VAR 0 2
38381: PPUSH
38382: LD_INT 124
38384: PPUSH
38385: CALL 21927 0 2
// end ; end ;
38389: GO 37786
38391: POP
38392: POP
// end ;
38393: LD_VAR 0 1
38397: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
38398: LD_INT 0
38400: PPUSH
38401: PPUSH
38402: PPUSH
// if not mc_bases then
38403: LD_EXP 50
38407: NOT
38408: IFFALSE 38412
// exit ;
38410: GO 39018
// for i = 1 to mc_bases do
38412: LD_ADDR_VAR 0 2
38416: PUSH
38417: DOUBLE
38418: LD_INT 1
38420: DEC
38421: ST_TO_ADDR
38422: LD_EXP 50
38426: PUSH
38427: FOR_TO
38428: IFFALSE 39016
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
38430: LD_ADDR_VAR 0 3
38434: PUSH
38435: LD_EXP 50
38439: PUSH
38440: LD_VAR 0 2
38444: ARRAY
38445: PPUSH
38446: LD_INT 25
38448: PUSH
38449: LD_INT 4
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PPUSH
38456: CALL_OW 72
38460: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38461: LD_VAR 0 3
38465: NOT
38466: PUSH
38467: LD_EXP 87
38471: PUSH
38472: LD_VAR 0 2
38476: ARRAY
38477: NOT
38478: OR
38479: PUSH
38480: LD_EXP 50
38484: PUSH
38485: LD_VAR 0 2
38489: ARRAY
38490: PPUSH
38491: LD_INT 2
38493: PUSH
38494: LD_INT 30
38496: PUSH
38497: LD_INT 0
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: LD_INT 30
38506: PUSH
38507: LD_INT 1
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: EMPTY
38515: LIST
38516: LIST
38517: LIST
38518: PPUSH
38519: CALL_OW 72
38523: NOT
38524: OR
38525: IFFALSE 38575
// begin if mc_deposits_finder [ i ] then
38527: LD_EXP 88
38531: PUSH
38532: LD_VAR 0 2
38536: ARRAY
38537: IFFALSE 38573
// begin MC_Reset ( i , 125 ) ;
38539: LD_VAR 0 2
38543: PPUSH
38544: LD_INT 125
38546: PPUSH
38547: CALL 21927 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38551: LD_ADDR_EXP 88
38555: PUSH
38556: LD_EXP 88
38560: PPUSH
38561: LD_VAR 0 2
38565: PPUSH
38566: EMPTY
38567: PPUSH
38568: CALL_OW 1
38572: ST_TO_ADDR
// end ; continue ;
38573: GO 38427
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
38575: LD_EXP 87
38579: PUSH
38580: LD_VAR 0 2
38584: ARRAY
38585: PUSH
38586: LD_INT 1
38588: ARRAY
38589: PUSH
38590: LD_INT 3
38592: ARRAY
38593: PUSH
38594: LD_INT 1
38596: EQUAL
38597: PUSH
38598: LD_INT 20
38600: PPUSH
38601: LD_EXP 76
38605: PUSH
38606: LD_VAR 0 2
38610: ARRAY
38611: PPUSH
38612: CALL_OW 321
38616: PUSH
38617: LD_INT 2
38619: NONEQUAL
38620: AND
38621: IFFALSE 38671
// begin if mc_deposits_finder [ i ] then
38623: LD_EXP 88
38627: PUSH
38628: LD_VAR 0 2
38632: ARRAY
38633: IFFALSE 38669
// begin MC_Reset ( i , 125 ) ;
38635: LD_VAR 0 2
38639: PPUSH
38640: LD_INT 125
38642: PPUSH
38643: CALL 21927 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38647: LD_ADDR_EXP 88
38651: PUSH
38652: LD_EXP 88
38656: PPUSH
38657: LD_VAR 0 2
38661: PPUSH
38662: EMPTY
38663: PPUSH
38664: CALL_OW 1
38668: ST_TO_ADDR
// end ; continue ;
38669: GO 38427
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
38671: LD_EXP 87
38675: PUSH
38676: LD_VAR 0 2
38680: ARRAY
38681: PUSH
38682: LD_INT 1
38684: ARRAY
38685: PUSH
38686: LD_INT 1
38688: ARRAY
38689: PPUSH
38690: LD_EXP 87
38694: PUSH
38695: LD_VAR 0 2
38699: ARRAY
38700: PUSH
38701: LD_INT 1
38703: ARRAY
38704: PUSH
38705: LD_INT 2
38707: ARRAY
38708: PPUSH
38709: LD_EXP 76
38713: PUSH
38714: LD_VAR 0 2
38718: ARRAY
38719: PPUSH
38720: CALL_OW 440
38724: IFFALSE 38767
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38726: LD_ADDR_EXP 87
38730: PUSH
38731: LD_EXP 87
38735: PPUSH
38736: LD_VAR 0 2
38740: PPUSH
38741: LD_EXP 87
38745: PUSH
38746: LD_VAR 0 2
38750: ARRAY
38751: PPUSH
38752: LD_INT 1
38754: PPUSH
38755: CALL_OW 3
38759: PPUSH
38760: CALL_OW 1
38764: ST_TO_ADDR
38765: GO 39014
// begin if not mc_deposits_finder [ i ] then
38767: LD_EXP 88
38771: PUSH
38772: LD_VAR 0 2
38776: ARRAY
38777: NOT
38778: IFFALSE 38830
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38780: LD_ADDR_EXP 88
38784: PUSH
38785: LD_EXP 88
38789: PPUSH
38790: LD_VAR 0 2
38794: PPUSH
38795: LD_VAR 0 3
38799: PUSH
38800: LD_INT 1
38802: ARRAY
38803: PUSH
38804: EMPTY
38805: LIST
38806: PPUSH
38807: CALL_OW 1
38811: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38812: LD_VAR 0 3
38816: PUSH
38817: LD_INT 1
38819: ARRAY
38820: PPUSH
38821: LD_INT 125
38823: PPUSH
38824: CALL_OW 109
// end else
38828: GO 39014
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
38830: LD_EXP 88
38834: PUSH
38835: LD_VAR 0 2
38839: ARRAY
38840: PUSH
38841: LD_INT 1
38843: ARRAY
38844: PPUSH
38845: CALL_OW 310
38849: IFFALSE 38872
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
38851: LD_EXP 88
38855: PUSH
38856: LD_VAR 0 2
38860: ARRAY
38861: PUSH
38862: LD_INT 1
38864: ARRAY
38865: PPUSH
38866: CALL_OW 122
38870: GO 39014
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
38872: LD_EXP 88
38876: PUSH
38877: LD_VAR 0 2
38881: ARRAY
38882: PUSH
38883: LD_INT 1
38885: ARRAY
38886: PPUSH
38887: CALL_OW 314
38891: NOT
38892: PUSH
38893: LD_EXP 88
38897: PUSH
38898: LD_VAR 0 2
38902: ARRAY
38903: PUSH
38904: LD_INT 1
38906: ARRAY
38907: PPUSH
38908: LD_EXP 87
38912: PUSH
38913: LD_VAR 0 2
38917: ARRAY
38918: PUSH
38919: LD_INT 1
38921: ARRAY
38922: PUSH
38923: LD_INT 1
38925: ARRAY
38926: PPUSH
38927: LD_EXP 87
38931: PUSH
38932: LD_VAR 0 2
38936: ARRAY
38937: PUSH
38938: LD_INT 1
38940: ARRAY
38941: PUSH
38942: LD_INT 2
38944: ARRAY
38945: PPUSH
38946: CALL_OW 297
38950: PUSH
38951: LD_INT 6
38953: GREATER
38954: AND
38955: IFFALSE 39014
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
38957: LD_EXP 88
38961: PUSH
38962: LD_VAR 0 2
38966: ARRAY
38967: PUSH
38968: LD_INT 1
38970: ARRAY
38971: PPUSH
38972: LD_EXP 87
38976: PUSH
38977: LD_VAR 0 2
38981: ARRAY
38982: PUSH
38983: LD_INT 1
38985: ARRAY
38986: PUSH
38987: LD_INT 1
38989: ARRAY
38990: PPUSH
38991: LD_EXP 87
38995: PUSH
38996: LD_VAR 0 2
39000: ARRAY
39001: PUSH
39002: LD_INT 1
39004: ARRAY
39005: PUSH
39006: LD_INT 2
39008: ARRAY
39009: PPUSH
39010: CALL_OW 111
// end ; end ; end ;
39014: GO 38427
39016: POP
39017: POP
// end ;
39018: LD_VAR 0 1
39022: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39023: LD_INT 0
39025: PPUSH
39026: PPUSH
39027: PPUSH
39028: PPUSH
39029: PPUSH
39030: PPUSH
39031: PPUSH
39032: PPUSH
39033: PPUSH
39034: PPUSH
39035: PPUSH
// if not mc_bases then
39036: LD_EXP 50
39040: NOT
39041: IFFALSE 39045
// exit ;
39043: GO 39985
// for i = 1 to mc_bases do
39045: LD_ADDR_VAR 0 2
39049: PUSH
39050: DOUBLE
39051: LD_INT 1
39053: DEC
39054: ST_TO_ADDR
39055: LD_EXP 50
39059: PUSH
39060: FOR_TO
39061: IFFALSE 39983
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39063: LD_EXP 50
39067: PUSH
39068: LD_VAR 0 2
39072: ARRAY
39073: NOT
39074: PUSH
39075: LD_EXP 73
39079: PUSH
39080: LD_VAR 0 2
39084: ARRAY
39085: OR
39086: IFFALSE 39090
// continue ;
39088: GO 39060
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39090: LD_ADDR_VAR 0 7
39094: PUSH
39095: LD_EXP 50
39099: PUSH
39100: LD_VAR 0 2
39104: ARRAY
39105: PUSH
39106: LD_INT 1
39108: ARRAY
39109: PPUSH
39110: CALL_OW 248
39114: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39115: LD_VAR 0 7
39119: PUSH
39120: LD_INT 3
39122: EQUAL
39123: PUSH
39124: LD_EXP 69
39128: PUSH
39129: LD_VAR 0 2
39133: ARRAY
39134: PUSH
39135: LD_EXP 72
39139: PUSH
39140: LD_VAR 0 2
39144: ARRAY
39145: UNION
39146: PPUSH
39147: LD_INT 33
39149: PUSH
39150: LD_INT 2
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PPUSH
39157: CALL_OW 72
39161: NOT
39162: OR
39163: IFFALSE 39167
// continue ;
39165: GO 39060
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39167: LD_ADDR_VAR 0 9
39171: PUSH
39172: LD_EXP 50
39176: PUSH
39177: LD_VAR 0 2
39181: ARRAY
39182: PPUSH
39183: LD_INT 30
39185: PUSH
39186: LD_INT 36
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PPUSH
39193: CALL_OW 72
39197: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39198: LD_ADDR_VAR 0 10
39202: PUSH
39203: LD_EXP 69
39207: PUSH
39208: LD_VAR 0 2
39212: ARRAY
39213: PPUSH
39214: LD_INT 34
39216: PUSH
39217: LD_INT 31
39219: PUSH
39220: EMPTY
39221: LIST
39222: LIST
39223: PPUSH
39224: CALL_OW 72
39228: ST_TO_ADDR
// if not cts and not mcts then
39229: LD_VAR 0 9
39233: NOT
39234: PUSH
39235: LD_VAR 0 10
39239: NOT
39240: AND
39241: IFFALSE 39245
// continue ;
39243: GO 39060
// x := cts ;
39245: LD_ADDR_VAR 0 11
39249: PUSH
39250: LD_VAR 0 9
39254: ST_TO_ADDR
// if not x then
39255: LD_VAR 0 11
39259: NOT
39260: IFFALSE 39272
// x := mcts ;
39262: LD_ADDR_VAR 0 11
39266: PUSH
39267: LD_VAR 0 10
39271: ST_TO_ADDR
// if not x then
39272: LD_VAR 0 11
39276: NOT
39277: IFFALSE 39281
// continue ;
39279: GO 39060
// if mc_remote_driver [ i ] then
39281: LD_EXP 90
39285: PUSH
39286: LD_VAR 0 2
39290: ARRAY
39291: IFFALSE 39678
// for j in mc_remote_driver [ i ] do
39293: LD_ADDR_VAR 0 3
39297: PUSH
39298: LD_EXP 90
39302: PUSH
39303: LD_VAR 0 2
39307: ARRAY
39308: PUSH
39309: FOR_IN
39310: IFFALSE 39676
// begin if GetClass ( j ) <> 3 then
39312: LD_VAR 0 3
39316: PPUSH
39317: CALL_OW 257
39321: PUSH
39322: LD_INT 3
39324: NONEQUAL
39325: IFFALSE 39378
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39327: LD_ADDR_EXP 90
39331: PUSH
39332: LD_EXP 90
39336: PPUSH
39337: LD_VAR 0 2
39341: PPUSH
39342: LD_EXP 90
39346: PUSH
39347: LD_VAR 0 2
39351: ARRAY
39352: PUSH
39353: LD_VAR 0 3
39357: DIFF
39358: PPUSH
39359: CALL_OW 1
39363: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39364: LD_VAR 0 3
39368: PPUSH
39369: LD_INT 0
39371: PPUSH
39372: CALL_OW 109
// continue ;
39376: GO 39309
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
39378: LD_EXP 69
39382: PUSH
39383: LD_VAR 0 2
39387: ARRAY
39388: PPUSH
39389: LD_INT 34
39391: PUSH
39392: LD_INT 31
39394: PUSH
39395: EMPTY
39396: LIST
39397: LIST
39398: PUSH
39399: LD_INT 58
39401: PUSH
39402: EMPTY
39403: LIST
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: PPUSH
39409: CALL_OW 72
39413: PUSH
39414: LD_VAR 0 3
39418: PPUSH
39419: CALL 81888 0 1
39423: NOT
39424: AND
39425: IFFALSE 39496
// begin if IsInUnit ( j ) then
39427: LD_VAR 0 3
39431: PPUSH
39432: CALL_OW 310
39436: IFFALSE 39447
// ComExitBuilding ( j ) ;
39438: LD_VAR 0 3
39442: PPUSH
39443: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
39447: LD_VAR 0 3
39451: PPUSH
39452: LD_EXP 69
39456: PUSH
39457: LD_VAR 0 2
39461: ARRAY
39462: PPUSH
39463: LD_INT 34
39465: PUSH
39466: LD_INT 31
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: LD_INT 58
39475: PUSH
39476: EMPTY
39477: LIST
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PPUSH
39483: CALL_OW 72
39487: PUSH
39488: LD_INT 1
39490: ARRAY
39491: PPUSH
39492: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
39496: LD_VAR 0 3
39500: PPUSH
39501: CALL_OW 310
39505: NOT
39506: PUSH
39507: LD_VAR 0 3
39511: PPUSH
39512: CALL_OW 310
39516: PPUSH
39517: CALL_OW 266
39521: PUSH
39522: LD_INT 36
39524: NONEQUAL
39525: PUSH
39526: LD_VAR 0 3
39530: PPUSH
39531: CALL 81888 0 1
39535: NOT
39536: AND
39537: OR
39538: IFFALSE 39674
// begin if IsInUnit ( j ) then
39540: LD_VAR 0 3
39544: PPUSH
39545: CALL_OW 310
39549: IFFALSE 39560
// ComExitBuilding ( j ) ;
39551: LD_VAR 0 3
39555: PPUSH
39556: CALL_OW 122
// ct := 0 ;
39560: LD_ADDR_VAR 0 8
39564: PUSH
39565: LD_INT 0
39567: ST_TO_ADDR
// for k in x do
39568: LD_ADDR_VAR 0 4
39572: PUSH
39573: LD_VAR 0 11
39577: PUSH
39578: FOR_IN
39579: IFFALSE 39652
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
39581: LD_VAR 0 4
39585: PPUSH
39586: CALL_OW 264
39590: PUSH
39591: LD_INT 31
39593: EQUAL
39594: PUSH
39595: LD_VAR 0 4
39599: PPUSH
39600: CALL_OW 311
39604: NOT
39605: AND
39606: PUSH
39607: LD_VAR 0 4
39611: PPUSH
39612: CALL_OW 266
39616: PUSH
39617: LD_INT 36
39619: EQUAL
39620: PUSH
39621: LD_VAR 0 4
39625: PPUSH
39626: CALL_OW 313
39630: PUSH
39631: LD_INT 3
39633: LESS
39634: AND
39635: OR
39636: IFFALSE 39650
// begin ct := k ;
39638: LD_ADDR_VAR 0 8
39642: PUSH
39643: LD_VAR 0 4
39647: ST_TO_ADDR
// break ;
39648: GO 39652
// end ;
39650: GO 39578
39652: POP
39653: POP
// if ct then
39654: LD_VAR 0 8
39658: IFFALSE 39674
// ComEnterUnit ( j , ct ) ;
39660: LD_VAR 0 3
39664: PPUSH
39665: LD_VAR 0 8
39669: PPUSH
39670: CALL_OW 120
// end ; end ;
39674: GO 39309
39676: POP
39677: POP
// places := 0 ;
39678: LD_ADDR_VAR 0 5
39682: PUSH
39683: LD_INT 0
39685: ST_TO_ADDR
// for j = 1 to x do
39686: LD_ADDR_VAR 0 3
39690: PUSH
39691: DOUBLE
39692: LD_INT 1
39694: DEC
39695: ST_TO_ADDR
39696: LD_VAR 0 11
39700: PUSH
39701: FOR_TO
39702: IFFALSE 39778
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39704: LD_VAR 0 11
39708: PUSH
39709: LD_VAR 0 3
39713: ARRAY
39714: PPUSH
39715: CALL_OW 264
39719: PUSH
39720: LD_INT 31
39722: EQUAL
39723: IFFALSE 39741
// places := places + 1 else
39725: LD_ADDR_VAR 0 5
39729: PUSH
39730: LD_VAR 0 5
39734: PUSH
39735: LD_INT 1
39737: PLUS
39738: ST_TO_ADDR
39739: GO 39776
// if GetBType ( x [ j ] ) = b_control_tower then
39741: LD_VAR 0 11
39745: PUSH
39746: LD_VAR 0 3
39750: ARRAY
39751: PPUSH
39752: CALL_OW 266
39756: PUSH
39757: LD_INT 36
39759: EQUAL
39760: IFFALSE 39776
// places := places + 3 ;
39762: LD_ADDR_VAR 0 5
39766: PUSH
39767: LD_VAR 0 5
39771: PUSH
39772: LD_INT 3
39774: PLUS
39775: ST_TO_ADDR
39776: GO 39701
39778: POP
39779: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39780: LD_VAR 0 5
39784: PUSH
39785: LD_INT 0
39787: EQUAL
39788: PUSH
39789: LD_VAR 0 5
39793: PUSH
39794: LD_EXP 90
39798: PUSH
39799: LD_VAR 0 2
39803: ARRAY
39804: LESSEQUAL
39805: OR
39806: IFFALSE 39810
// continue ;
39808: GO 39060
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39810: LD_ADDR_VAR 0 6
39814: PUSH
39815: LD_EXP 50
39819: PUSH
39820: LD_VAR 0 2
39824: ARRAY
39825: PPUSH
39826: LD_INT 25
39828: PUSH
39829: LD_INT 3
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PPUSH
39836: CALL_OW 72
39840: PUSH
39841: LD_EXP 90
39845: PUSH
39846: LD_VAR 0 2
39850: ARRAY
39851: DIFF
39852: PPUSH
39853: LD_INT 3
39855: PPUSH
39856: CALL 82788 0 2
39860: ST_TO_ADDR
// for j in tmp do
39861: LD_ADDR_VAR 0 3
39865: PUSH
39866: LD_VAR 0 6
39870: PUSH
39871: FOR_IN
39872: IFFALSE 39907
// if GetTag ( j ) > 0 then
39874: LD_VAR 0 3
39878: PPUSH
39879: CALL_OW 110
39883: PUSH
39884: LD_INT 0
39886: GREATER
39887: IFFALSE 39905
// tmp := tmp diff j ;
39889: LD_ADDR_VAR 0 6
39893: PUSH
39894: LD_VAR 0 6
39898: PUSH
39899: LD_VAR 0 3
39903: DIFF
39904: ST_TO_ADDR
39905: GO 39871
39907: POP
39908: POP
// if not tmp then
39909: LD_VAR 0 6
39913: NOT
39914: IFFALSE 39918
// continue ;
39916: GO 39060
// if places then
39918: LD_VAR 0 5
39922: IFFALSE 39981
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
39924: LD_ADDR_EXP 90
39928: PUSH
39929: LD_EXP 90
39933: PPUSH
39934: LD_VAR 0 2
39938: PPUSH
39939: LD_EXP 90
39943: PUSH
39944: LD_VAR 0 2
39948: ARRAY
39949: PUSH
39950: LD_VAR 0 6
39954: PUSH
39955: LD_INT 1
39957: ARRAY
39958: UNION
39959: PPUSH
39960: CALL_OW 1
39964: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
39965: LD_VAR 0 6
39969: PUSH
39970: LD_INT 1
39972: ARRAY
39973: PPUSH
39974: LD_INT 126
39976: PPUSH
39977: CALL_OW 109
// end ; end ;
39981: GO 39060
39983: POP
39984: POP
// end ;
39985: LD_VAR 0 1
39989: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
39990: LD_INT 0
39992: PPUSH
39993: PPUSH
39994: PPUSH
39995: PPUSH
39996: PPUSH
39997: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
39998: LD_VAR 0 1
40002: NOT
40003: PUSH
40004: LD_VAR 0 2
40008: NOT
40009: OR
40010: PUSH
40011: LD_VAR 0 3
40015: NOT
40016: OR
40017: PUSH
40018: LD_VAR 0 4
40022: PUSH
40023: LD_INT 1
40025: PUSH
40026: LD_INT 2
40028: PUSH
40029: LD_INT 3
40031: PUSH
40032: LD_INT 4
40034: PUSH
40035: LD_INT 5
40037: PUSH
40038: LD_INT 8
40040: PUSH
40041: LD_INT 9
40043: PUSH
40044: LD_INT 15
40046: PUSH
40047: LD_INT 16
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: LIST
40054: LIST
40055: LIST
40056: LIST
40057: LIST
40058: LIST
40059: LIST
40060: IN
40061: NOT
40062: OR
40063: IFFALSE 40067
// exit ;
40065: GO 40967
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40067: LD_ADDR_VAR 0 2
40071: PUSH
40072: LD_VAR 0 2
40076: PPUSH
40077: LD_INT 21
40079: PUSH
40080: LD_INT 3
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: LD_INT 24
40089: PUSH
40090: LD_INT 250
40092: PUSH
40093: EMPTY
40094: LIST
40095: LIST
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PPUSH
40101: CALL_OW 72
40105: ST_TO_ADDR
// case class of 1 , 15 :
40106: LD_VAR 0 4
40110: PUSH
40111: LD_INT 1
40113: DOUBLE
40114: EQUAL
40115: IFTRUE 40125
40117: LD_INT 15
40119: DOUBLE
40120: EQUAL
40121: IFTRUE 40125
40123: GO 40210
40125: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40126: LD_ADDR_VAR 0 8
40130: PUSH
40131: LD_VAR 0 2
40135: PPUSH
40136: LD_INT 2
40138: PUSH
40139: LD_INT 30
40141: PUSH
40142: LD_INT 32
40144: PUSH
40145: EMPTY
40146: LIST
40147: LIST
40148: PUSH
40149: LD_INT 30
40151: PUSH
40152: LD_INT 31
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PUSH
40159: EMPTY
40160: LIST
40161: LIST
40162: LIST
40163: PPUSH
40164: CALL_OW 72
40168: PUSH
40169: LD_VAR 0 2
40173: PPUSH
40174: LD_INT 2
40176: PUSH
40177: LD_INT 30
40179: PUSH
40180: LD_INT 4
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: PUSH
40187: LD_INT 30
40189: PUSH
40190: LD_INT 5
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: LIST
40201: PPUSH
40202: CALL_OW 72
40206: ADD
40207: ST_TO_ADDR
40208: GO 40456
40210: LD_INT 2
40212: DOUBLE
40213: EQUAL
40214: IFTRUE 40224
40216: LD_INT 16
40218: DOUBLE
40219: EQUAL
40220: IFTRUE 40224
40222: GO 40270
40224: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40225: LD_ADDR_VAR 0 8
40229: PUSH
40230: LD_VAR 0 2
40234: PPUSH
40235: LD_INT 2
40237: PUSH
40238: LD_INT 30
40240: PUSH
40241: LD_INT 0
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 30
40250: PUSH
40251: LD_INT 1
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: LIST
40262: PPUSH
40263: CALL_OW 72
40267: ST_TO_ADDR
40268: GO 40456
40270: LD_INT 3
40272: DOUBLE
40273: EQUAL
40274: IFTRUE 40278
40276: GO 40324
40278: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40279: LD_ADDR_VAR 0 8
40283: PUSH
40284: LD_VAR 0 2
40288: PPUSH
40289: LD_INT 2
40291: PUSH
40292: LD_INT 30
40294: PUSH
40295: LD_INT 2
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: PUSH
40302: LD_INT 30
40304: PUSH
40305: LD_INT 3
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: LIST
40316: PPUSH
40317: CALL_OW 72
40321: ST_TO_ADDR
40322: GO 40456
40324: LD_INT 4
40326: DOUBLE
40327: EQUAL
40328: IFTRUE 40332
40330: GO 40389
40332: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40333: LD_ADDR_VAR 0 8
40337: PUSH
40338: LD_VAR 0 2
40342: PPUSH
40343: LD_INT 2
40345: PUSH
40346: LD_INT 30
40348: PUSH
40349: LD_INT 6
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 30
40358: PUSH
40359: LD_INT 7
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 30
40368: PUSH
40369: LD_INT 8
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: LIST
40380: LIST
40381: PPUSH
40382: CALL_OW 72
40386: ST_TO_ADDR
40387: GO 40456
40389: LD_INT 5
40391: DOUBLE
40392: EQUAL
40393: IFTRUE 40409
40395: LD_INT 8
40397: DOUBLE
40398: EQUAL
40399: IFTRUE 40409
40401: LD_INT 9
40403: DOUBLE
40404: EQUAL
40405: IFTRUE 40409
40407: GO 40455
40409: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
40410: LD_ADDR_VAR 0 8
40414: PUSH
40415: LD_VAR 0 2
40419: PPUSH
40420: LD_INT 2
40422: PUSH
40423: LD_INT 30
40425: PUSH
40426: LD_INT 4
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 30
40435: PUSH
40436: LD_INT 5
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: LIST
40447: PPUSH
40448: CALL_OW 72
40452: ST_TO_ADDR
40453: GO 40456
40455: POP
// if not tmp then
40456: LD_VAR 0 8
40460: NOT
40461: IFFALSE 40465
// exit ;
40463: GO 40967
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
40465: LD_VAR 0 4
40469: PUSH
40470: LD_INT 1
40472: PUSH
40473: LD_INT 15
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: IN
40480: PUSH
40481: LD_EXP 59
40485: PUSH
40486: LD_VAR 0 1
40490: ARRAY
40491: AND
40492: IFFALSE 40648
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
40494: LD_ADDR_VAR 0 9
40498: PUSH
40499: LD_EXP 59
40503: PUSH
40504: LD_VAR 0 1
40508: ARRAY
40509: PUSH
40510: LD_INT 1
40512: ARRAY
40513: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
40514: LD_VAR 0 9
40518: PUSH
40519: LD_EXP 60
40523: PUSH
40524: LD_VAR 0 1
40528: ARRAY
40529: IN
40530: NOT
40531: IFFALSE 40646
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
40533: LD_ADDR_EXP 60
40537: PUSH
40538: LD_EXP 60
40542: PPUSH
40543: LD_VAR 0 1
40547: PUSH
40548: LD_EXP 60
40552: PUSH
40553: LD_VAR 0 1
40557: ARRAY
40558: PUSH
40559: LD_INT 1
40561: PLUS
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PPUSH
40567: LD_VAR 0 9
40571: PPUSH
40572: CALL 52906 0 3
40576: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
40577: LD_ADDR_EXP 59
40581: PUSH
40582: LD_EXP 59
40586: PPUSH
40587: LD_VAR 0 1
40591: PPUSH
40592: LD_EXP 59
40596: PUSH
40597: LD_VAR 0 1
40601: ARRAY
40602: PUSH
40603: LD_VAR 0 9
40607: DIFF
40608: PPUSH
40609: CALL_OW 1
40613: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
40614: LD_VAR 0 3
40618: PPUSH
40619: LD_EXP 60
40623: PUSH
40624: LD_VAR 0 1
40628: ARRAY
40629: PUSH
40630: LD_EXP 60
40634: PUSH
40635: LD_VAR 0 1
40639: ARRAY
40640: ARRAY
40641: PPUSH
40642: CALL_OW 120
// end ; exit ;
40646: GO 40967
// end ; if tmp > 1 then
40648: LD_VAR 0 8
40652: PUSH
40653: LD_INT 1
40655: GREATER
40656: IFFALSE 40760
// for i = 2 to tmp do
40658: LD_ADDR_VAR 0 6
40662: PUSH
40663: DOUBLE
40664: LD_INT 2
40666: DEC
40667: ST_TO_ADDR
40668: LD_VAR 0 8
40672: PUSH
40673: FOR_TO
40674: IFFALSE 40758
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
40676: LD_VAR 0 8
40680: PUSH
40681: LD_VAR 0 6
40685: ARRAY
40686: PPUSH
40687: CALL_OW 461
40691: PUSH
40692: LD_INT 6
40694: EQUAL
40695: IFFALSE 40756
// begin x := tmp [ i ] ;
40697: LD_ADDR_VAR 0 9
40701: PUSH
40702: LD_VAR 0 8
40706: PUSH
40707: LD_VAR 0 6
40711: ARRAY
40712: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40713: LD_ADDR_VAR 0 8
40717: PUSH
40718: LD_VAR 0 8
40722: PPUSH
40723: LD_VAR 0 6
40727: PPUSH
40728: CALL_OW 3
40732: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40733: LD_ADDR_VAR 0 8
40737: PUSH
40738: LD_VAR 0 8
40742: PPUSH
40743: LD_INT 1
40745: PPUSH
40746: LD_VAR 0 9
40750: PPUSH
40751: CALL_OW 2
40755: ST_TO_ADDR
// end ;
40756: GO 40673
40758: POP
40759: POP
// for i in tmp do
40760: LD_ADDR_VAR 0 6
40764: PUSH
40765: LD_VAR 0 8
40769: PUSH
40770: FOR_IN
40771: IFFALSE 40840
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40773: LD_VAR 0 6
40777: PPUSH
40778: CALL_OW 313
40782: PUSH
40783: LD_INT 6
40785: LESS
40786: PUSH
40787: LD_VAR 0 6
40791: PPUSH
40792: CALL_OW 266
40796: PUSH
40797: LD_INT 31
40799: PUSH
40800: LD_INT 32
40802: PUSH
40803: EMPTY
40804: LIST
40805: LIST
40806: IN
40807: NOT
40808: AND
40809: PUSH
40810: LD_VAR 0 6
40814: PPUSH
40815: CALL_OW 313
40819: PUSH
40820: LD_INT 0
40822: EQUAL
40823: OR
40824: IFFALSE 40838
// begin j := i ;
40826: LD_ADDR_VAR 0 7
40830: PUSH
40831: LD_VAR 0 6
40835: ST_TO_ADDR
// break ;
40836: GO 40840
// end ; end ;
40838: GO 40770
40840: POP
40841: POP
// if j then
40842: LD_VAR 0 7
40846: IFFALSE 40864
// ComEnterUnit ( unit , j ) else
40848: LD_VAR 0 3
40852: PPUSH
40853: LD_VAR 0 7
40857: PPUSH
40858: CALL_OW 120
40862: GO 40967
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40864: LD_ADDR_VAR 0 10
40868: PUSH
40869: LD_VAR 0 2
40873: PPUSH
40874: LD_INT 2
40876: PUSH
40877: LD_INT 30
40879: PUSH
40880: LD_INT 0
40882: PUSH
40883: EMPTY
40884: LIST
40885: LIST
40886: PUSH
40887: LD_INT 30
40889: PUSH
40890: LD_INT 1
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: LIST
40901: PPUSH
40902: CALL_OW 72
40906: ST_TO_ADDR
// if depot then
40907: LD_VAR 0 10
40911: IFFALSE 40967
// begin depot := NearestUnitToUnit ( depot , unit ) ;
40913: LD_ADDR_VAR 0 10
40917: PUSH
40918: LD_VAR 0 10
40922: PPUSH
40923: LD_VAR 0 3
40927: PPUSH
40928: CALL_OW 74
40932: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
40933: LD_VAR 0 3
40937: PPUSH
40938: LD_VAR 0 10
40942: PPUSH
40943: CALL_OW 296
40947: PUSH
40948: LD_INT 10
40950: GREATER
40951: IFFALSE 40967
// ComStandNearbyBuilding ( unit , depot ) ;
40953: LD_VAR 0 3
40957: PPUSH
40958: LD_VAR 0 10
40962: PPUSH
40963: CALL 49520 0 2
// end ; end ; end ;
40967: LD_VAR 0 5
40971: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
40972: LD_INT 0
40974: PPUSH
40975: PPUSH
40976: PPUSH
40977: PPUSH
// if not mc_bases then
40978: LD_EXP 50
40982: NOT
40983: IFFALSE 40987
// exit ;
40985: GO 41226
// for i = 1 to mc_bases do
40987: LD_ADDR_VAR 0 2
40991: PUSH
40992: DOUBLE
40993: LD_INT 1
40995: DEC
40996: ST_TO_ADDR
40997: LD_EXP 50
41001: PUSH
41002: FOR_TO
41003: IFFALSE 41224
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41005: LD_ADDR_VAR 0 4
41009: PUSH
41010: LD_EXP 50
41014: PUSH
41015: LD_VAR 0 2
41019: ARRAY
41020: PPUSH
41021: LD_INT 21
41023: PUSH
41024: LD_INT 1
41026: PUSH
41027: EMPTY
41028: LIST
41029: LIST
41030: PPUSH
41031: CALL_OW 72
41035: PUSH
41036: LD_EXP 79
41040: PUSH
41041: LD_VAR 0 2
41045: ARRAY
41046: UNION
41047: ST_TO_ADDR
// if not tmp then
41048: LD_VAR 0 4
41052: NOT
41053: IFFALSE 41057
// continue ;
41055: GO 41002
// for j in tmp do
41057: LD_ADDR_VAR 0 3
41061: PUSH
41062: LD_VAR 0 4
41066: PUSH
41067: FOR_IN
41068: IFFALSE 41220
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41070: LD_VAR 0 3
41074: PPUSH
41075: CALL_OW 110
41079: NOT
41080: PUSH
41081: LD_VAR 0 3
41085: PPUSH
41086: CALL_OW 314
41090: NOT
41091: AND
41092: PUSH
41093: LD_VAR 0 3
41097: PPUSH
41098: CALL_OW 311
41102: NOT
41103: AND
41104: PUSH
41105: LD_VAR 0 3
41109: PPUSH
41110: CALL_OW 310
41114: NOT
41115: AND
41116: PUSH
41117: LD_VAR 0 3
41121: PUSH
41122: LD_EXP 53
41126: PUSH
41127: LD_VAR 0 2
41131: ARRAY
41132: PUSH
41133: LD_INT 1
41135: ARRAY
41136: IN
41137: NOT
41138: AND
41139: PUSH
41140: LD_VAR 0 3
41144: PUSH
41145: LD_EXP 53
41149: PUSH
41150: LD_VAR 0 2
41154: ARRAY
41155: PUSH
41156: LD_INT 2
41158: ARRAY
41159: IN
41160: NOT
41161: AND
41162: PUSH
41163: LD_VAR 0 3
41167: PUSH
41168: LD_EXP 62
41172: PUSH
41173: LD_VAR 0 2
41177: ARRAY
41178: IN
41179: NOT
41180: AND
41181: IFFALSE 41218
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41183: LD_VAR 0 2
41187: PPUSH
41188: LD_EXP 50
41192: PUSH
41193: LD_VAR 0 2
41197: ARRAY
41198: PPUSH
41199: LD_VAR 0 3
41203: PPUSH
41204: LD_VAR 0 3
41208: PPUSH
41209: CALL_OW 257
41213: PPUSH
41214: CALL 39990 0 4
// end ;
41218: GO 41067
41220: POP
41221: POP
// end ;
41222: GO 41002
41224: POP
41225: POP
// end ;
41226: LD_VAR 0 1
41230: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41231: LD_INT 0
41233: PPUSH
41234: PPUSH
41235: PPUSH
41236: PPUSH
41237: PPUSH
41238: PPUSH
// if not mc_bases [ base ] then
41239: LD_EXP 50
41243: PUSH
41244: LD_VAR 0 1
41248: ARRAY
41249: NOT
41250: IFFALSE 41254
// exit ;
41252: GO 41436
// tmp := [ ] ;
41254: LD_ADDR_VAR 0 6
41258: PUSH
41259: EMPTY
41260: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41261: LD_ADDR_VAR 0 7
41265: PUSH
41266: LD_VAR 0 3
41270: PPUSH
41271: LD_INT 0
41273: PPUSH
41274: CALL_OW 517
41278: ST_TO_ADDR
// if not list then
41279: LD_VAR 0 7
41283: NOT
41284: IFFALSE 41288
// exit ;
41286: GO 41436
// for i = 1 to amount do
41288: LD_ADDR_VAR 0 5
41292: PUSH
41293: DOUBLE
41294: LD_INT 1
41296: DEC
41297: ST_TO_ADDR
41298: LD_VAR 0 2
41302: PUSH
41303: FOR_TO
41304: IFFALSE 41384
// begin x := rand ( 1 , list [ 1 ] ) ;
41306: LD_ADDR_VAR 0 8
41310: PUSH
41311: LD_INT 1
41313: PPUSH
41314: LD_VAR 0 7
41318: PUSH
41319: LD_INT 1
41321: ARRAY
41322: PPUSH
41323: CALL_OW 12
41327: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41328: LD_ADDR_VAR 0 6
41332: PUSH
41333: LD_VAR 0 6
41337: PPUSH
41338: LD_VAR 0 5
41342: PPUSH
41343: LD_VAR 0 7
41347: PUSH
41348: LD_INT 1
41350: ARRAY
41351: PUSH
41352: LD_VAR 0 8
41356: ARRAY
41357: PUSH
41358: LD_VAR 0 7
41362: PUSH
41363: LD_INT 2
41365: ARRAY
41366: PUSH
41367: LD_VAR 0 8
41371: ARRAY
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: PPUSH
41377: CALL_OW 1
41381: ST_TO_ADDR
// end ;
41382: GO 41303
41384: POP
41385: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
41386: LD_ADDR_EXP 63
41390: PUSH
41391: LD_EXP 63
41395: PPUSH
41396: LD_VAR 0 1
41400: PPUSH
41401: LD_VAR 0 6
41405: PPUSH
41406: CALL_OW 1
41410: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
41411: LD_ADDR_EXP 65
41415: PUSH
41416: LD_EXP 65
41420: PPUSH
41421: LD_VAR 0 1
41425: PPUSH
41426: LD_VAR 0 3
41430: PPUSH
41431: CALL_OW 1
41435: ST_TO_ADDR
// end ;
41436: LD_VAR 0 4
41440: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
41441: LD_INT 0
41443: PPUSH
// if not mc_bases [ base ] then
41444: LD_EXP 50
41448: PUSH
41449: LD_VAR 0 1
41453: ARRAY
41454: NOT
41455: IFFALSE 41459
// exit ;
41457: GO 41484
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
41459: LD_ADDR_EXP 55
41463: PUSH
41464: LD_EXP 55
41468: PPUSH
41469: LD_VAR 0 1
41473: PPUSH
41474: LD_VAR 0 2
41478: PPUSH
41479: CALL_OW 1
41483: ST_TO_ADDR
// end ;
41484: LD_VAR 0 3
41488: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
41489: LD_INT 0
41491: PPUSH
// if not mc_bases [ base ] then
41492: LD_EXP 50
41496: PUSH
41497: LD_VAR 0 1
41501: ARRAY
41502: NOT
41503: IFFALSE 41507
// exit ;
41505: GO 41544
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
41507: LD_ADDR_EXP 55
41511: PUSH
41512: LD_EXP 55
41516: PPUSH
41517: LD_VAR 0 1
41521: PPUSH
41522: LD_EXP 55
41526: PUSH
41527: LD_VAR 0 1
41531: ARRAY
41532: PUSH
41533: LD_VAR 0 2
41537: UNION
41538: PPUSH
41539: CALL_OW 1
41543: ST_TO_ADDR
// end ;
41544: LD_VAR 0 3
41548: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
41549: LD_INT 0
41551: PPUSH
// if not mc_bases [ base ] then
41552: LD_EXP 50
41556: PUSH
41557: LD_VAR 0 1
41561: ARRAY
41562: NOT
41563: IFFALSE 41567
// exit ;
41565: GO 41592
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
41567: LD_ADDR_EXP 71
41571: PUSH
41572: LD_EXP 71
41576: PPUSH
41577: LD_VAR 0 1
41581: PPUSH
41582: LD_VAR 0 2
41586: PPUSH
41587: CALL_OW 1
41591: ST_TO_ADDR
// end ;
41592: LD_VAR 0 3
41596: RET
// export function MC_InsertProduceList ( base , components ) ; begin
41597: LD_INT 0
41599: PPUSH
// if not mc_bases [ base ] then
41600: LD_EXP 50
41604: PUSH
41605: LD_VAR 0 1
41609: ARRAY
41610: NOT
41611: IFFALSE 41615
// exit ;
41613: GO 41652
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
41615: LD_ADDR_EXP 71
41619: PUSH
41620: LD_EXP 71
41624: PPUSH
41625: LD_VAR 0 1
41629: PPUSH
41630: LD_EXP 71
41634: PUSH
41635: LD_VAR 0 1
41639: ARRAY
41640: PUSH
41641: LD_VAR 0 2
41645: ADD
41646: PPUSH
41647: CALL_OW 1
41651: ST_TO_ADDR
// end ;
41652: LD_VAR 0 3
41656: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
41657: LD_INT 0
41659: PPUSH
// if not mc_bases [ base ] then
41660: LD_EXP 50
41664: PUSH
41665: LD_VAR 0 1
41669: ARRAY
41670: NOT
41671: IFFALSE 41675
// exit ;
41673: GO 41729
// mc_defender := Replace ( mc_defender , base , deflist ) ;
41675: LD_ADDR_EXP 72
41679: PUSH
41680: LD_EXP 72
41684: PPUSH
41685: LD_VAR 0 1
41689: PPUSH
41690: LD_VAR 0 2
41694: PPUSH
41695: CALL_OW 1
41699: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
41700: LD_ADDR_EXP 61
41704: PUSH
41705: LD_EXP 61
41709: PPUSH
41710: LD_VAR 0 1
41714: PPUSH
41715: LD_VAR 0 2
41719: PUSH
41720: LD_INT 0
41722: PLUS
41723: PPUSH
41724: CALL_OW 1
41728: ST_TO_ADDR
// end ;
41729: LD_VAR 0 3
41733: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41734: LD_INT 0
41736: PPUSH
// if not mc_bases [ base ] then
41737: LD_EXP 50
41741: PUSH
41742: LD_VAR 0 1
41746: ARRAY
41747: NOT
41748: IFFALSE 41752
// exit ;
41750: GO 41777
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41752: LD_ADDR_EXP 61
41756: PUSH
41757: LD_EXP 61
41761: PPUSH
41762: LD_VAR 0 1
41766: PPUSH
41767: LD_VAR 0 2
41771: PPUSH
41772: CALL_OW 1
41776: ST_TO_ADDR
// end ;
41777: LD_VAR 0 3
41781: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41782: LD_INT 0
41784: PPUSH
41785: PPUSH
41786: PPUSH
41787: PPUSH
// if not mc_bases [ base ] then
41788: LD_EXP 50
41792: PUSH
41793: LD_VAR 0 1
41797: ARRAY
41798: NOT
41799: IFFALSE 41803
// exit ;
41801: GO 41868
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41803: LD_ADDR_EXP 70
41807: PUSH
41808: LD_EXP 70
41812: PPUSH
41813: LD_VAR 0 1
41817: PUSH
41818: LD_EXP 70
41822: PUSH
41823: LD_VAR 0 1
41827: ARRAY
41828: PUSH
41829: LD_INT 1
41831: PLUS
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: PPUSH
41837: LD_VAR 0 1
41841: PUSH
41842: LD_VAR 0 2
41846: PUSH
41847: LD_VAR 0 3
41851: PUSH
41852: LD_VAR 0 4
41856: PUSH
41857: EMPTY
41858: LIST
41859: LIST
41860: LIST
41861: LIST
41862: PPUSH
41863: CALL 52906 0 3
41867: ST_TO_ADDR
// end ;
41868: LD_VAR 0 5
41872: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
41873: LD_INT 0
41875: PPUSH
// if not mc_bases [ base ] then
41876: LD_EXP 50
41880: PUSH
41881: LD_VAR 0 1
41885: ARRAY
41886: NOT
41887: IFFALSE 41891
// exit ;
41889: GO 41916
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
41891: LD_ADDR_EXP 87
41895: PUSH
41896: LD_EXP 87
41900: PPUSH
41901: LD_VAR 0 1
41905: PPUSH
41906: LD_VAR 0 2
41910: PPUSH
41911: CALL_OW 1
41915: ST_TO_ADDR
// end ;
41916: LD_VAR 0 3
41920: RET
// export function MC_GetMinesField ( base ) ; begin
41921: LD_INT 0
41923: PPUSH
// result := mc_mines [ base ] ;
41924: LD_ADDR_VAR 0 2
41928: PUSH
41929: LD_EXP 63
41933: PUSH
41934: LD_VAR 0 1
41938: ARRAY
41939: ST_TO_ADDR
// end ;
41940: LD_VAR 0 2
41944: RET
// export function MC_GetProduceList ( base ) ; begin
41945: LD_INT 0
41947: PPUSH
// result := mc_produce [ base ] ;
41948: LD_ADDR_VAR 0 2
41952: PUSH
41953: LD_EXP 71
41957: PUSH
41958: LD_VAR 0 1
41962: ARRAY
41963: ST_TO_ADDR
// end ;
41964: LD_VAR 0 2
41968: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
41969: LD_INT 0
41971: PPUSH
41972: PPUSH
// if not mc_bases then
41973: LD_EXP 50
41977: NOT
41978: IFFALSE 41982
// exit ;
41980: GO 42047
// if mc_bases [ base ] then
41982: LD_EXP 50
41986: PUSH
41987: LD_VAR 0 1
41991: ARRAY
41992: IFFALSE 42047
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41994: LD_ADDR_VAR 0 3
41998: PUSH
41999: LD_EXP 50
42003: PUSH
42004: LD_VAR 0 1
42008: ARRAY
42009: PPUSH
42010: LD_INT 30
42012: PUSH
42013: LD_VAR 0 2
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: PPUSH
42022: CALL_OW 72
42026: ST_TO_ADDR
// if result then
42027: LD_VAR 0 3
42031: IFFALSE 42047
// result := result [ 1 ] ;
42033: LD_ADDR_VAR 0 3
42037: PUSH
42038: LD_VAR 0 3
42042: PUSH
42043: LD_INT 1
42045: ARRAY
42046: ST_TO_ADDR
// end ; end ;
42047: LD_VAR 0 3
42051: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42052: LD_INT 0
42054: PPUSH
42055: PPUSH
// if not mc_bases then
42056: LD_EXP 50
42060: NOT
42061: IFFALSE 42065
// exit ;
42063: GO 42110
// if mc_bases [ base ] then
42065: LD_EXP 50
42069: PUSH
42070: LD_VAR 0 1
42074: ARRAY
42075: IFFALSE 42110
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42077: LD_ADDR_VAR 0 3
42081: PUSH
42082: LD_EXP 50
42086: PUSH
42087: LD_VAR 0 1
42091: ARRAY
42092: PPUSH
42093: LD_INT 30
42095: PUSH
42096: LD_VAR 0 2
42100: PUSH
42101: EMPTY
42102: LIST
42103: LIST
42104: PPUSH
42105: CALL_OW 72
42109: ST_TO_ADDR
// end ;
42110: LD_VAR 0 3
42114: RET
// export function MC_SetTame ( base , area ) ; begin
42115: LD_INT 0
42117: PPUSH
// if not mc_bases or not base then
42118: LD_EXP 50
42122: NOT
42123: PUSH
42124: LD_VAR 0 1
42128: NOT
42129: OR
42130: IFFALSE 42134
// exit ;
42132: GO 42159
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42134: LD_ADDR_EXP 78
42138: PUSH
42139: LD_EXP 78
42143: PPUSH
42144: LD_VAR 0 1
42148: PPUSH
42149: LD_VAR 0 2
42153: PPUSH
42154: CALL_OW 1
42158: ST_TO_ADDR
// end ;
42159: LD_VAR 0 3
42163: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42164: LD_INT 0
42166: PPUSH
42167: PPUSH
// if not mc_bases or not base then
42168: LD_EXP 50
42172: NOT
42173: PUSH
42174: LD_VAR 0 1
42178: NOT
42179: OR
42180: IFFALSE 42184
// exit ;
42182: GO 42286
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42184: LD_ADDR_VAR 0 4
42188: PUSH
42189: LD_EXP 50
42193: PUSH
42194: LD_VAR 0 1
42198: ARRAY
42199: PPUSH
42200: LD_INT 30
42202: PUSH
42203: LD_VAR 0 2
42207: PUSH
42208: EMPTY
42209: LIST
42210: LIST
42211: PPUSH
42212: CALL_OW 72
42216: ST_TO_ADDR
// if not tmp then
42217: LD_VAR 0 4
42221: NOT
42222: IFFALSE 42226
// exit ;
42224: GO 42286
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42226: LD_ADDR_EXP 82
42230: PUSH
42231: LD_EXP 82
42235: PPUSH
42236: LD_VAR 0 1
42240: PPUSH
42241: LD_EXP 82
42245: PUSH
42246: LD_VAR 0 1
42250: ARRAY
42251: PPUSH
42252: LD_EXP 82
42256: PUSH
42257: LD_VAR 0 1
42261: ARRAY
42262: PUSH
42263: LD_INT 1
42265: PLUS
42266: PPUSH
42267: LD_VAR 0 4
42271: PUSH
42272: LD_INT 1
42274: ARRAY
42275: PPUSH
42276: CALL_OW 2
42280: PPUSH
42281: CALL_OW 1
42285: ST_TO_ADDR
// end ;
42286: LD_VAR 0 3
42290: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42291: LD_INT 0
42293: PPUSH
42294: PPUSH
// if not mc_bases or not base or not kinds then
42295: LD_EXP 50
42299: NOT
42300: PUSH
42301: LD_VAR 0 1
42305: NOT
42306: OR
42307: PUSH
42308: LD_VAR 0 2
42312: NOT
42313: OR
42314: IFFALSE 42318
// exit ;
42316: GO 42379
// for i in kinds do
42318: LD_ADDR_VAR 0 4
42322: PUSH
42323: LD_VAR 0 2
42327: PUSH
42328: FOR_IN
42329: IFFALSE 42377
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42331: LD_ADDR_EXP 84
42335: PUSH
42336: LD_EXP 84
42340: PPUSH
42341: LD_VAR 0 1
42345: PUSH
42346: LD_EXP 84
42350: PUSH
42351: LD_VAR 0 1
42355: ARRAY
42356: PUSH
42357: LD_INT 1
42359: PLUS
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PPUSH
42365: LD_VAR 0 4
42369: PPUSH
42370: CALL 52906 0 3
42374: ST_TO_ADDR
42375: GO 42328
42377: POP
42378: POP
// end ;
42379: LD_VAR 0 3
42383: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
42384: LD_INT 0
42386: PPUSH
// if not mc_bases or not base or not areas then
42387: LD_EXP 50
42391: NOT
42392: PUSH
42393: LD_VAR 0 1
42397: NOT
42398: OR
42399: PUSH
42400: LD_VAR 0 2
42404: NOT
42405: OR
42406: IFFALSE 42410
// exit ;
42408: GO 42435
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
42410: LD_ADDR_EXP 68
42414: PUSH
42415: LD_EXP 68
42419: PPUSH
42420: LD_VAR 0 1
42424: PPUSH
42425: LD_VAR 0 2
42429: PPUSH
42430: CALL_OW 1
42434: ST_TO_ADDR
// end ;
42435: LD_VAR 0 3
42439: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
42440: LD_INT 0
42442: PPUSH
// if not mc_bases or not base or not teleports_exit then
42443: LD_EXP 50
42447: NOT
42448: PUSH
42449: LD_VAR 0 1
42453: NOT
42454: OR
42455: PUSH
42456: LD_VAR 0 2
42460: NOT
42461: OR
42462: IFFALSE 42466
// exit ;
42464: GO 42491
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
42466: LD_ADDR_EXP 85
42470: PUSH
42471: LD_EXP 85
42475: PPUSH
42476: LD_VAR 0 1
42480: PPUSH
42481: LD_VAR 0 2
42485: PPUSH
42486: CALL_OW 1
42490: ST_TO_ADDR
// end ;
42491: LD_VAR 0 3
42495: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
42496: LD_INT 0
42498: PPUSH
42499: PPUSH
42500: PPUSH
// if not mc_bases or not base or not ext_list then
42501: LD_EXP 50
42505: NOT
42506: PUSH
42507: LD_VAR 0 1
42511: NOT
42512: OR
42513: PUSH
42514: LD_VAR 0 5
42518: NOT
42519: OR
42520: IFFALSE 42524
// exit ;
42522: GO 42697
// tmp := GetFacExtXYD ( x , y , d ) ;
42524: LD_ADDR_VAR 0 8
42528: PUSH
42529: LD_VAR 0 2
42533: PPUSH
42534: LD_VAR 0 3
42538: PPUSH
42539: LD_VAR 0 4
42543: PPUSH
42544: CALL 81918 0 3
42548: ST_TO_ADDR
// if not tmp then
42549: LD_VAR 0 8
42553: NOT
42554: IFFALSE 42558
// exit ;
42556: GO 42697
// for i in tmp do
42558: LD_ADDR_VAR 0 7
42562: PUSH
42563: LD_VAR 0 8
42567: PUSH
42568: FOR_IN
42569: IFFALSE 42695
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
42571: LD_ADDR_EXP 55
42575: PUSH
42576: LD_EXP 55
42580: PPUSH
42581: LD_VAR 0 1
42585: PPUSH
42586: LD_EXP 55
42590: PUSH
42591: LD_VAR 0 1
42595: ARRAY
42596: PPUSH
42597: LD_EXP 55
42601: PUSH
42602: LD_VAR 0 1
42606: ARRAY
42607: PUSH
42608: LD_INT 1
42610: PLUS
42611: PPUSH
42612: LD_VAR 0 5
42616: PUSH
42617: LD_INT 1
42619: ARRAY
42620: PUSH
42621: LD_VAR 0 7
42625: PUSH
42626: LD_INT 1
42628: ARRAY
42629: PUSH
42630: LD_VAR 0 7
42634: PUSH
42635: LD_INT 2
42637: ARRAY
42638: PUSH
42639: LD_VAR 0 7
42643: PUSH
42644: LD_INT 3
42646: ARRAY
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: LIST
42652: LIST
42653: PPUSH
42654: CALL_OW 2
42658: PPUSH
42659: CALL_OW 1
42663: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
42664: LD_ADDR_VAR 0 5
42668: PUSH
42669: LD_VAR 0 5
42673: PPUSH
42674: LD_INT 1
42676: PPUSH
42677: CALL_OW 3
42681: ST_TO_ADDR
// if not ext_list then
42682: LD_VAR 0 5
42686: NOT
42687: IFFALSE 42693
// exit ;
42689: POP
42690: POP
42691: GO 42697
// end ;
42693: GO 42568
42695: POP
42696: POP
// end ;
42697: LD_VAR 0 6
42701: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42702: LD_INT 0
42704: PPUSH
// if not mc_bases or not base or not weapon_list then
42705: LD_EXP 50
42709: NOT
42710: PUSH
42711: LD_VAR 0 1
42715: NOT
42716: OR
42717: PUSH
42718: LD_VAR 0 2
42722: NOT
42723: OR
42724: IFFALSE 42728
// exit ;
42726: GO 42753
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42728: LD_ADDR_EXP 89
42732: PUSH
42733: LD_EXP 89
42737: PPUSH
42738: LD_VAR 0 1
42742: PPUSH
42743: LD_VAR 0 2
42747: PPUSH
42748: CALL_OW 1
42752: ST_TO_ADDR
// end ;
42753: LD_VAR 0 3
42757: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42758: LD_INT 0
42760: PPUSH
// if not mc_bases or not base or not tech_list then
42761: LD_EXP 50
42765: NOT
42766: PUSH
42767: LD_VAR 0 1
42771: NOT
42772: OR
42773: PUSH
42774: LD_VAR 0 2
42778: NOT
42779: OR
42780: IFFALSE 42784
// exit ;
42782: GO 42809
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42784: LD_ADDR_EXP 77
42788: PUSH
42789: LD_EXP 77
42793: PPUSH
42794: LD_VAR 0 1
42798: PPUSH
42799: LD_VAR 0 2
42803: PPUSH
42804: CALL_OW 1
42808: ST_TO_ADDR
// end ;
42809: LD_VAR 0 3
42813: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42814: LD_INT 0
42816: PPUSH
// if not mc_bases or not parking_area or not base then
42817: LD_EXP 50
42821: NOT
42822: PUSH
42823: LD_VAR 0 2
42827: NOT
42828: OR
42829: PUSH
42830: LD_VAR 0 1
42834: NOT
42835: OR
42836: IFFALSE 42840
// exit ;
42838: GO 42865
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
42840: LD_ADDR_EXP 74
42844: PUSH
42845: LD_EXP 74
42849: PPUSH
42850: LD_VAR 0 1
42854: PPUSH
42855: LD_VAR 0 2
42859: PPUSH
42860: CALL_OW 1
42864: ST_TO_ADDR
// end ;
42865: LD_VAR 0 3
42869: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
42870: LD_INT 0
42872: PPUSH
// if not mc_bases or not base or not scan_area then
42873: LD_EXP 50
42877: NOT
42878: PUSH
42879: LD_VAR 0 1
42883: NOT
42884: OR
42885: PUSH
42886: LD_VAR 0 2
42890: NOT
42891: OR
42892: IFFALSE 42896
// exit ;
42894: GO 42921
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
42896: LD_ADDR_EXP 75
42900: PUSH
42901: LD_EXP 75
42905: PPUSH
42906: LD_VAR 0 1
42910: PPUSH
42911: LD_VAR 0 2
42915: PPUSH
42916: CALL_OW 1
42920: ST_TO_ADDR
// end ;
42921: LD_VAR 0 3
42925: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
42926: LD_INT 0
42928: PPUSH
42929: PPUSH
// if not mc_bases or not base then
42930: LD_EXP 50
42934: NOT
42935: PUSH
42936: LD_VAR 0 1
42940: NOT
42941: OR
42942: IFFALSE 42946
// exit ;
42944: GO 43010
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
42946: LD_ADDR_VAR 0 3
42950: PUSH
42951: LD_INT 1
42953: PUSH
42954: LD_INT 2
42956: PUSH
42957: LD_INT 3
42959: PUSH
42960: LD_INT 4
42962: PUSH
42963: LD_INT 11
42965: PUSH
42966: EMPTY
42967: LIST
42968: LIST
42969: LIST
42970: LIST
42971: LIST
42972: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
42973: LD_ADDR_EXP 77
42977: PUSH
42978: LD_EXP 77
42982: PPUSH
42983: LD_VAR 0 1
42987: PPUSH
42988: LD_EXP 77
42992: PUSH
42993: LD_VAR 0 1
42997: ARRAY
42998: PUSH
42999: LD_VAR 0 3
43003: DIFF
43004: PPUSH
43005: CALL_OW 1
43009: ST_TO_ADDR
// end ;
43010: LD_VAR 0 2
43014: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43015: LD_INT 0
43017: PPUSH
// result := mc_vehicles [ base ] ;
43018: LD_ADDR_VAR 0 3
43022: PUSH
43023: LD_EXP 69
43027: PUSH
43028: LD_VAR 0 1
43032: ARRAY
43033: ST_TO_ADDR
// if onlyCombat then
43034: LD_VAR 0 2
43038: IFFALSE 43216
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43040: LD_ADDR_VAR 0 3
43044: PUSH
43045: LD_VAR 0 3
43049: PUSH
43050: LD_VAR 0 3
43054: PPUSH
43055: LD_INT 2
43057: PUSH
43058: LD_INT 34
43060: PUSH
43061: LD_INT 12
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: PUSH
43068: LD_INT 34
43070: PUSH
43071: LD_INT 51
43073: PUSH
43074: EMPTY
43075: LIST
43076: LIST
43077: PUSH
43078: LD_INT 34
43080: PUSH
43081: LD_EXP 94
43085: PUSH
43086: EMPTY
43087: LIST
43088: LIST
43089: PUSH
43090: LD_INT 34
43092: PUSH
43093: LD_INT 32
43095: PUSH
43096: EMPTY
43097: LIST
43098: LIST
43099: PUSH
43100: LD_INT 34
43102: PUSH
43103: LD_INT 13
43105: PUSH
43106: EMPTY
43107: LIST
43108: LIST
43109: PUSH
43110: LD_INT 34
43112: PUSH
43113: LD_INT 52
43115: PUSH
43116: EMPTY
43117: LIST
43118: LIST
43119: PUSH
43120: LD_INT 34
43122: PUSH
43123: LD_EXP 99
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: PUSH
43132: LD_INT 34
43134: PUSH
43135: LD_INT 14
43137: PUSH
43138: EMPTY
43139: LIST
43140: LIST
43141: PUSH
43142: LD_INT 34
43144: PUSH
43145: LD_INT 53
43147: PUSH
43148: EMPTY
43149: LIST
43150: LIST
43151: PUSH
43152: LD_INT 34
43154: PUSH
43155: LD_EXP 93
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 34
43166: PUSH
43167: LD_INT 31
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PUSH
43174: LD_INT 34
43176: PUSH
43177: LD_INT 48
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: LD_INT 34
43186: PUSH
43187: LD_INT 8
43189: PUSH
43190: EMPTY
43191: LIST
43192: LIST
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: LIST
43198: LIST
43199: LIST
43200: LIST
43201: LIST
43202: LIST
43203: LIST
43204: LIST
43205: LIST
43206: LIST
43207: LIST
43208: LIST
43209: PPUSH
43210: CALL_OW 72
43214: DIFF
43215: ST_TO_ADDR
// end ; end_of_file
43216: LD_VAR 0 3
43220: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43221: LD_INT 0
43223: PPUSH
43224: PPUSH
43225: PPUSH
// if not mc_bases or not skirmish then
43226: LD_EXP 50
43230: NOT
43231: PUSH
43232: LD_EXP 48
43236: NOT
43237: OR
43238: IFFALSE 43242
// exit ;
43240: GO 43407
// for i = 1 to mc_bases do
43242: LD_ADDR_VAR 0 4
43246: PUSH
43247: DOUBLE
43248: LD_INT 1
43250: DEC
43251: ST_TO_ADDR
43252: LD_EXP 50
43256: PUSH
43257: FOR_TO
43258: IFFALSE 43405
// begin if sci in mc_bases [ i ] then
43260: LD_VAR 0 2
43264: PUSH
43265: LD_EXP 50
43269: PUSH
43270: LD_VAR 0 4
43274: ARRAY
43275: IN
43276: IFFALSE 43403
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43278: LD_ADDR_EXP 79
43282: PUSH
43283: LD_EXP 79
43287: PPUSH
43288: LD_VAR 0 4
43292: PUSH
43293: LD_EXP 79
43297: PUSH
43298: LD_VAR 0 4
43302: ARRAY
43303: PUSH
43304: LD_INT 1
43306: PLUS
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: PPUSH
43312: LD_VAR 0 1
43316: PPUSH
43317: CALL 52906 0 3
43321: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43322: LD_ADDR_VAR 0 5
43326: PUSH
43327: LD_EXP 50
43331: PUSH
43332: LD_VAR 0 4
43336: ARRAY
43337: PPUSH
43338: LD_INT 2
43340: PUSH
43341: LD_INT 30
43343: PUSH
43344: LD_INT 0
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: LD_INT 30
43353: PUSH
43354: LD_INT 1
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: LIST
43365: PPUSH
43366: CALL_OW 72
43370: PPUSH
43371: LD_VAR 0 1
43375: PPUSH
43376: CALL_OW 74
43380: ST_TO_ADDR
// if tmp then
43381: LD_VAR 0 5
43385: IFFALSE 43401
// ComStandNearbyBuilding ( ape , tmp ) ;
43387: LD_VAR 0 1
43391: PPUSH
43392: LD_VAR 0 5
43396: PPUSH
43397: CALL 49520 0 2
// break ;
43401: GO 43405
// end ; end ;
43403: GO 43257
43405: POP
43406: POP
// end ;
43407: LD_VAR 0 3
43411: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
43412: LD_INT 0
43414: PPUSH
43415: PPUSH
43416: PPUSH
// if not mc_bases or not skirmish then
43417: LD_EXP 50
43421: NOT
43422: PUSH
43423: LD_EXP 48
43427: NOT
43428: OR
43429: IFFALSE 43433
// exit ;
43431: GO 43522
// for i = 1 to mc_bases do
43433: LD_ADDR_VAR 0 4
43437: PUSH
43438: DOUBLE
43439: LD_INT 1
43441: DEC
43442: ST_TO_ADDR
43443: LD_EXP 50
43447: PUSH
43448: FOR_TO
43449: IFFALSE 43520
// begin if building in mc_busy_turret_list [ i ] then
43451: LD_VAR 0 1
43455: PUSH
43456: LD_EXP 60
43460: PUSH
43461: LD_VAR 0 4
43465: ARRAY
43466: IN
43467: IFFALSE 43518
// begin tmp := mc_busy_turret_list [ i ] diff building ;
43469: LD_ADDR_VAR 0 5
43473: PUSH
43474: LD_EXP 60
43478: PUSH
43479: LD_VAR 0 4
43483: ARRAY
43484: PUSH
43485: LD_VAR 0 1
43489: DIFF
43490: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
43491: LD_ADDR_EXP 60
43495: PUSH
43496: LD_EXP 60
43500: PPUSH
43501: LD_VAR 0 4
43505: PPUSH
43506: LD_VAR 0 5
43510: PPUSH
43511: CALL_OW 1
43515: ST_TO_ADDR
// break ;
43516: GO 43520
// end ; end ;
43518: GO 43448
43520: POP
43521: POP
// end ;
43522: LD_VAR 0 3
43526: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
43527: LD_INT 0
43529: PPUSH
43530: PPUSH
43531: PPUSH
// if not mc_bases or not skirmish then
43532: LD_EXP 50
43536: NOT
43537: PUSH
43538: LD_EXP 48
43542: NOT
43543: OR
43544: IFFALSE 43548
// exit ;
43546: GO 43747
// for i = 1 to mc_bases do
43548: LD_ADDR_VAR 0 5
43552: PUSH
43553: DOUBLE
43554: LD_INT 1
43556: DEC
43557: ST_TO_ADDR
43558: LD_EXP 50
43562: PUSH
43563: FOR_TO
43564: IFFALSE 43745
// if building in mc_bases [ i ] then
43566: LD_VAR 0 1
43570: PUSH
43571: LD_EXP 50
43575: PUSH
43576: LD_VAR 0 5
43580: ARRAY
43581: IN
43582: IFFALSE 43743
// begin tmp := mc_bases [ i ] diff building ;
43584: LD_ADDR_VAR 0 6
43588: PUSH
43589: LD_EXP 50
43593: PUSH
43594: LD_VAR 0 5
43598: ARRAY
43599: PUSH
43600: LD_VAR 0 1
43604: DIFF
43605: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
43606: LD_ADDR_EXP 50
43610: PUSH
43611: LD_EXP 50
43615: PPUSH
43616: LD_VAR 0 5
43620: PPUSH
43621: LD_VAR 0 6
43625: PPUSH
43626: CALL_OW 1
43630: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
43631: LD_VAR 0 1
43635: PUSH
43636: LD_EXP 58
43640: PUSH
43641: LD_VAR 0 5
43645: ARRAY
43646: IN
43647: IFFALSE 43686
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
43649: LD_ADDR_EXP 58
43653: PUSH
43654: LD_EXP 58
43658: PPUSH
43659: LD_VAR 0 5
43663: PPUSH
43664: LD_EXP 58
43668: PUSH
43669: LD_VAR 0 5
43673: ARRAY
43674: PUSH
43675: LD_VAR 0 1
43679: DIFF
43680: PPUSH
43681: CALL_OW 1
43685: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
43686: LD_VAR 0 1
43690: PUSH
43691: LD_EXP 59
43695: PUSH
43696: LD_VAR 0 5
43700: ARRAY
43701: IN
43702: IFFALSE 43741
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
43704: LD_ADDR_EXP 59
43708: PUSH
43709: LD_EXP 59
43713: PPUSH
43714: LD_VAR 0 5
43718: PPUSH
43719: LD_EXP 59
43723: PUSH
43724: LD_VAR 0 5
43728: ARRAY
43729: PUSH
43730: LD_VAR 0 1
43734: DIFF
43735: PPUSH
43736: CALL_OW 1
43740: ST_TO_ADDR
// break ;
43741: GO 43745
// end ;
43743: GO 43563
43745: POP
43746: POP
// end ;
43747: LD_VAR 0 4
43751: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43752: LD_INT 0
43754: PPUSH
43755: PPUSH
43756: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43757: LD_EXP 50
43761: NOT
43762: PUSH
43763: LD_EXP 48
43767: NOT
43768: OR
43769: PUSH
43770: LD_VAR 0 3
43774: PUSH
43775: LD_EXP 76
43779: IN
43780: NOT
43781: OR
43782: IFFALSE 43786
// exit ;
43784: GO 43909
// for i = 1 to mc_vehicles do
43786: LD_ADDR_VAR 0 6
43790: PUSH
43791: DOUBLE
43792: LD_INT 1
43794: DEC
43795: ST_TO_ADDR
43796: LD_EXP 69
43800: PUSH
43801: FOR_TO
43802: IFFALSE 43907
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43804: LD_VAR 0 2
43808: PUSH
43809: LD_EXP 69
43813: PUSH
43814: LD_VAR 0 6
43818: ARRAY
43819: IN
43820: PUSH
43821: LD_VAR 0 1
43825: PUSH
43826: LD_EXP 69
43830: PUSH
43831: LD_VAR 0 6
43835: ARRAY
43836: IN
43837: OR
43838: IFFALSE 43905
// begin tmp := mc_vehicles [ i ] diff old ;
43840: LD_ADDR_VAR 0 7
43844: PUSH
43845: LD_EXP 69
43849: PUSH
43850: LD_VAR 0 6
43854: ARRAY
43855: PUSH
43856: LD_VAR 0 2
43860: DIFF
43861: ST_TO_ADDR
// tmp := tmp diff new ;
43862: LD_ADDR_VAR 0 7
43866: PUSH
43867: LD_VAR 0 7
43871: PUSH
43872: LD_VAR 0 1
43876: DIFF
43877: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
43878: LD_ADDR_EXP 69
43882: PUSH
43883: LD_EXP 69
43887: PPUSH
43888: LD_VAR 0 6
43892: PPUSH
43893: LD_VAR 0 7
43897: PPUSH
43898: CALL_OW 1
43902: ST_TO_ADDR
// break ;
43903: GO 43907
// end ;
43905: GO 43801
43907: POP
43908: POP
// end ;
43909: LD_VAR 0 5
43913: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
43914: LD_INT 0
43916: PPUSH
43917: PPUSH
43918: PPUSH
43919: PPUSH
// if not mc_bases or not skirmish then
43920: LD_EXP 50
43924: NOT
43925: PUSH
43926: LD_EXP 48
43930: NOT
43931: OR
43932: IFFALSE 43936
// exit ;
43934: GO 44319
// side := GetSide ( vehicle ) ;
43936: LD_ADDR_VAR 0 5
43940: PUSH
43941: LD_VAR 0 1
43945: PPUSH
43946: CALL_OW 255
43950: ST_TO_ADDR
// for i = 1 to mc_bases do
43951: LD_ADDR_VAR 0 4
43955: PUSH
43956: DOUBLE
43957: LD_INT 1
43959: DEC
43960: ST_TO_ADDR
43961: LD_EXP 50
43965: PUSH
43966: FOR_TO
43967: IFFALSE 44317
// begin if factory in mc_bases [ i ] then
43969: LD_VAR 0 2
43973: PUSH
43974: LD_EXP 50
43978: PUSH
43979: LD_VAR 0 4
43983: ARRAY
43984: IN
43985: IFFALSE 44315
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
43987: LD_EXP 72
43991: PUSH
43992: LD_VAR 0 4
43996: ARRAY
43997: PUSH
43998: LD_EXP 61
44002: PUSH
44003: LD_VAR 0 4
44007: ARRAY
44008: LESS
44009: PUSH
44010: LD_VAR 0 1
44014: PPUSH
44015: CALL_OW 264
44019: PUSH
44020: LD_INT 31
44022: PUSH
44023: LD_INT 32
44025: PUSH
44026: LD_INT 51
44028: PUSH
44029: LD_EXP 94
44033: PUSH
44034: LD_INT 12
44036: PUSH
44037: LD_INT 30
44039: PUSH
44040: LD_EXP 93
44044: PUSH
44045: LD_INT 11
44047: PUSH
44048: LD_INT 53
44050: PUSH
44051: LD_INT 14
44053: PUSH
44054: LD_EXP 97
44058: PUSH
44059: LD_INT 29
44061: PUSH
44062: LD_EXP 95
44066: PUSH
44067: LD_INT 13
44069: PUSH
44070: LD_INT 52
44072: PUSH
44073: LD_EXP 99
44077: PUSH
44078: LD_INT 48
44080: PUSH
44081: LD_INT 8
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: LIST
44088: LIST
44089: LIST
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: LIST
44095: LIST
44096: LIST
44097: LIST
44098: LIST
44099: LIST
44100: LIST
44101: LIST
44102: LIST
44103: IN
44104: NOT
44105: AND
44106: IFFALSE 44154
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44108: LD_ADDR_EXP 72
44112: PUSH
44113: LD_EXP 72
44117: PPUSH
44118: LD_VAR 0 4
44122: PUSH
44123: LD_EXP 72
44127: PUSH
44128: LD_VAR 0 4
44132: ARRAY
44133: PUSH
44134: LD_INT 1
44136: PLUS
44137: PUSH
44138: EMPTY
44139: LIST
44140: LIST
44141: PPUSH
44142: LD_VAR 0 1
44146: PPUSH
44147: CALL 52906 0 3
44151: ST_TO_ADDR
44152: GO 44198
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44154: LD_ADDR_EXP 69
44158: PUSH
44159: LD_EXP 69
44163: PPUSH
44164: LD_VAR 0 4
44168: PUSH
44169: LD_EXP 69
44173: PUSH
44174: LD_VAR 0 4
44178: ARRAY
44179: PUSH
44180: LD_INT 1
44182: PLUS
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PPUSH
44188: LD_VAR 0 1
44192: PPUSH
44193: CALL 52906 0 3
44197: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44198: LD_VAR 0 1
44202: PPUSH
44203: CALL_OW 263
44207: PUSH
44208: LD_INT 2
44210: EQUAL
44211: IFFALSE 44231
// begin repeat wait ( 0 0$1 ) ;
44213: LD_INT 35
44215: PPUSH
44216: CALL_OW 67
// until IsControledBy ( vehicle ) ;
44220: LD_VAR 0 1
44224: PPUSH
44225: CALL_OW 312
44229: IFFALSE 44213
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44231: LD_VAR 0 1
44235: PPUSH
44236: LD_EXP 74
44240: PUSH
44241: LD_VAR 0 4
44245: ARRAY
44246: PPUSH
44247: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44251: LD_VAR 0 1
44255: PPUSH
44256: CALL_OW 263
44260: PUSH
44261: LD_INT 1
44263: NONEQUAL
44264: IFFALSE 44268
// break ;
44266: GO 44317
// repeat wait ( 0 0$1 ) ;
44268: LD_INT 35
44270: PPUSH
44271: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44275: LD_VAR 0 1
44279: PPUSH
44280: LD_EXP 74
44284: PUSH
44285: LD_VAR 0 4
44289: ARRAY
44290: PPUSH
44291: CALL_OW 308
44295: IFFALSE 44268
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44297: LD_VAR 0 1
44301: PPUSH
44302: CALL_OW 311
44306: PPUSH
44307: CALL_OW 121
// exit ;
44311: POP
44312: POP
44313: GO 44319
// end ; end ;
44315: GO 43966
44317: POP
44318: POP
// end ;
44319: LD_VAR 0 3
44323: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44324: LD_INT 0
44326: PPUSH
44327: PPUSH
44328: PPUSH
44329: PPUSH
// if not mc_bases or not skirmish then
44330: LD_EXP 50
44334: NOT
44335: PUSH
44336: LD_EXP 48
44340: NOT
44341: OR
44342: IFFALSE 44346
// exit ;
44344: GO 44699
// repeat wait ( 0 0$1 ) ;
44346: LD_INT 35
44348: PPUSH
44349: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
44353: LD_VAR 0 2
44357: PPUSH
44358: LD_VAR 0 3
44362: PPUSH
44363: CALL_OW 284
44367: IFFALSE 44346
// if GetResourceTypeXY ( x , y ) = mat_artefact then
44369: LD_VAR 0 2
44373: PPUSH
44374: LD_VAR 0 3
44378: PPUSH
44379: CALL_OW 283
44383: PUSH
44384: LD_INT 4
44386: EQUAL
44387: IFFALSE 44391
// exit ;
44389: GO 44699
// for i = 1 to mc_bases do
44391: LD_ADDR_VAR 0 7
44395: PUSH
44396: DOUBLE
44397: LD_INT 1
44399: DEC
44400: ST_TO_ADDR
44401: LD_EXP 50
44405: PUSH
44406: FOR_TO
44407: IFFALSE 44697
// begin if mc_crates_area [ i ] then
44409: LD_EXP 68
44413: PUSH
44414: LD_VAR 0 7
44418: ARRAY
44419: IFFALSE 44530
// for j in mc_crates_area [ i ] do
44421: LD_ADDR_VAR 0 8
44425: PUSH
44426: LD_EXP 68
44430: PUSH
44431: LD_VAR 0 7
44435: ARRAY
44436: PUSH
44437: FOR_IN
44438: IFFALSE 44528
// if InArea ( x , y , j ) then
44440: LD_VAR 0 2
44444: PPUSH
44445: LD_VAR 0 3
44449: PPUSH
44450: LD_VAR 0 8
44454: PPUSH
44455: CALL_OW 309
44459: IFFALSE 44526
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44461: LD_ADDR_EXP 66
44465: PUSH
44466: LD_EXP 66
44470: PPUSH
44471: LD_VAR 0 7
44475: PUSH
44476: LD_EXP 66
44480: PUSH
44481: LD_VAR 0 7
44485: ARRAY
44486: PUSH
44487: LD_INT 1
44489: PLUS
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PPUSH
44495: LD_VAR 0 4
44499: PUSH
44500: LD_VAR 0 2
44504: PUSH
44505: LD_VAR 0 3
44509: PUSH
44510: EMPTY
44511: LIST
44512: LIST
44513: LIST
44514: PPUSH
44515: CALL 52906 0 3
44519: ST_TO_ADDR
// exit ;
44520: POP
44521: POP
44522: POP
44523: POP
44524: GO 44699
// end ;
44526: GO 44437
44528: POP
44529: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44530: LD_ADDR_VAR 0 9
44534: PUSH
44535: LD_EXP 50
44539: PUSH
44540: LD_VAR 0 7
44544: ARRAY
44545: PPUSH
44546: LD_INT 2
44548: PUSH
44549: LD_INT 30
44551: PUSH
44552: LD_INT 0
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PUSH
44559: LD_INT 30
44561: PUSH
44562: LD_INT 1
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: EMPTY
44570: LIST
44571: LIST
44572: LIST
44573: PPUSH
44574: CALL_OW 72
44578: ST_TO_ADDR
// if not depot then
44579: LD_VAR 0 9
44583: NOT
44584: IFFALSE 44588
// continue ;
44586: GO 44406
// for j in depot do
44588: LD_ADDR_VAR 0 8
44592: PUSH
44593: LD_VAR 0 9
44597: PUSH
44598: FOR_IN
44599: IFFALSE 44693
// if GetDistUnitXY ( j , x , y ) < 30 then
44601: LD_VAR 0 8
44605: PPUSH
44606: LD_VAR 0 2
44610: PPUSH
44611: LD_VAR 0 3
44615: PPUSH
44616: CALL_OW 297
44620: PUSH
44621: LD_INT 30
44623: LESS
44624: IFFALSE 44691
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44626: LD_ADDR_EXP 66
44630: PUSH
44631: LD_EXP 66
44635: PPUSH
44636: LD_VAR 0 7
44640: PUSH
44641: LD_EXP 66
44645: PUSH
44646: LD_VAR 0 7
44650: ARRAY
44651: PUSH
44652: LD_INT 1
44654: PLUS
44655: PUSH
44656: EMPTY
44657: LIST
44658: LIST
44659: PPUSH
44660: LD_VAR 0 4
44664: PUSH
44665: LD_VAR 0 2
44669: PUSH
44670: LD_VAR 0 3
44674: PUSH
44675: EMPTY
44676: LIST
44677: LIST
44678: LIST
44679: PPUSH
44680: CALL 52906 0 3
44684: ST_TO_ADDR
// exit ;
44685: POP
44686: POP
44687: POP
44688: POP
44689: GO 44699
// end ;
44691: GO 44598
44693: POP
44694: POP
// end ;
44695: GO 44406
44697: POP
44698: POP
// end ;
44699: LD_VAR 0 6
44703: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
44704: LD_INT 0
44706: PPUSH
44707: PPUSH
44708: PPUSH
44709: PPUSH
// if not mc_bases or not skirmish then
44710: LD_EXP 50
44714: NOT
44715: PUSH
44716: LD_EXP 48
44720: NOT
44721: OR
44722: IFFALSE 44726
// exit ;
44724: GO 45003
// side := GetSide ( lab ) ;
44726: LD_ADDR_VAR 0 4
44730: PUSH
44731: LD_VAR 0 2
44735: PPUSH
44736: CALL_OW 255
44740: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44741: LD_VAR 0 4
44745: PUSH
44746: LD_EXP 76
44750: IN
44751: NOT
44752: PUSH
44753: LD_EXP 77
44757: NOT
44758: OR
44759: PUSH
44760: LD_EXP 50
44764: NOT
44765: OR
44766: IFFALSE 44770
// exit ;
44768: GO 45003
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44770: LD_ADDR_EXP 77
44774: PUSH
44775: LD_EXP 77
44779: PPUSH
44780: LD_VAR 0 4
44784: PPUSH
44785: LD_EXP 77
44789: PUSH
44790: LD_VAR 0 4
44794: ARRAY
44795: PUSH
44796: LD_VAR 0 1
44800: DIFF
44801: PPUSH
44802: CALL_OW 1
44806: ST_TO_ADDR
// for i = 1 to mc_bases do
44807: LD_ADDR_VAR 0 5
44811: PUSH
44812: DOUBLE
44813: LD_INT 1
44815: DEC
44816: ST_TO_ADDR
44817: LD_EXP 50
44821: PUSH
44822: FOR_TO
44823: IFFALSE 45001
// begin if lab in mc_bases [ i ] then
44825: LD_VAR 0 2
44829: PUSH
44830: LD_EXP 50
44834: PUSH
44835: LD_VAR 0 5
44839: ARRAY
44840: IN
44841: IFFALSE 44999
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
44843: LD_VAR 0 1
44847: PUSH
44848: LD_INT 11
44850: PUSH
44851: LD_INT 4
44853: PUSH
44854: LD_INT 3
44856: PUSH
44857: LD_INT 2
44859: PUSH
44860: EMPTY
44861: LIST
44862: LIST
44863: LIST
44864: LIST
44865: IN
44866: PUSH
44867: LD_EXP 80
44871: PUSH
44872: LD_VAR 0 5
44876: ARRAY
44877: AND
44878: IFFALSE 44999
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
44880: LD_ADDR_VAR 0 6
44884: PUSH
44885: LD_EXP 80
44889: PUSH
44890: LD_VAR 0 5
44894: ARRAY
44895: PUSH
44896: LD_INT 1
44898: ARRAY
44899: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44900: LD_ADDR_EXP 80
44904: PUSH
44905: LD_EXP 80
44909: PPUSH
44910: LD_VAR 0 5
44914: PPUSH
44915: EMPTY
44916: PPUSH
44917: CALL_OW 1
44921: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
44922: LD_VAR 0 6
44926: PPUSH
44927: LD_INT 0
44929: PPUSH
44930: CALL_OW 109
// ComExitBuilding ( tmp ) ;
44934: LD_VAR 0 6
44938: PPUSH
44939: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
44943: LD_ADDR_EXP 79
44947: PUSH
44948: LD_EXP 79
44952: PPUSH
44953: LD_VAR 0 5
44957: PPUSH
44958: LD_EXP 79
44962: PUSH
44963: LD_VAR 0 5
44967: ARRAY
44968: PPUSH
44969: LD_INT 1
44971: PPUSH
44972: LD_VAR 0 6
44976: PPUSH
44977: CALL_OW 2
44981: PPUSH
44982: CALL_OW 1
44986: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
44987: LD_VAR 0 5
44991: PPUSH
44992: LD_INT 112
44994: PPUSH
44995: CALL 21927 0 2
// end ; end ; end ;
44999: GO 44822
45001: POP
45002: POP
// end ;
45003: LD_VAR 0 3
45007: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45008: LD_INT 0
45010: PPUSH
45011: PPUSH
45012: PPUSH
45013: PPUSH
45014: PPUSH
45015: PPUSH
45016: PPUSH
45017: PPUSH
// if not mc_bases or not skirmish then
45018: LD_EXP 50
45022: NOT
45023: PUSH
45024: LD_EXP 48
45028: NOT
45029: OR
45030: IFFALSE 45034
// exit ;
45032: GO 46405
// for i = 1 to mc_bases do
45034: LD_ADDR_VAR 0 3
45038: PUSH
45039: DOUBLE
45040: LD_INT 1
45042: DEC
45043: ST_TO_ADDR
45044: LD_EXP 50
45048: PUSH
45049: FOR_TO
45050: IFFALSE 46403
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45052: LD_VAR 0 1
45056: PUSH
45057: LD_EXP 50
45061: PUSH
45062: LD_VAR 0 3
45066: ARRAY
45067: IN
45068: PUSH
45069: LD_VAR 0 1
45073: PUSH
45074: LD_EXP 57
45078: PUSH
45079: LD_VAR 0 3
45083: ARRAY
45084: IN
45085: OR
45086: PUSH
45087: LD_VAR 0 1
45091: PUSH
45092: LD_EXP 72
45096: PUSH
45097: LD_VAR 0 3
45101: ARRAY
45102: IN
45103: OR
45104: PUSH
45105: LD_VAR 0 1
45109: PUSH
45110: LD_EXP 69
45114: PUSH
45115: LD_VAR 0 3
45119: ARRAY
45120: IN
45121: OR
45122: PUSH
45123: LD_VAR 0 1
45127: PUSH
45128: LD_EXP 79
45132: PUSH
45133: LD_VAR 0 3
45137: ARRAY
45138: IN
45139: OR
45140: PUSH
45141: LD_VAR 0 1
45145: PUSH
45146: LD_EXP 80
45150: PUSH
45151: LD_VAR 0 3
45155: ARRAY
45156: IN
45157: OR
45158: IFFALSE 46401
// begin if un in mc_ape [ i ] then
45160: LD_VAR 0 1
45164: PUSH
45165: LD_EXP 79
45169: PUSH
45170: LD_VAR 0 3
45174: ARRAY
45175: IN
45176: IFFALSE 45215
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45178: LD_ADDR_EXP 79
45182: PUSH
45183: LD_EXP 79
45187: PPUSH
45188: LD_VAR 0 3
45192: PPUSH
45193: LD_EXP 79
45197: PUSH
45198: LD_VAR 0 3
45202: ARRAY
45203: PUSH
45204: LD_VAR 0 1
45208: DIFF
45209: PPUSH
45210: CALL_OW 1
45214: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45215: LD_VAR 0 1
45219: PUSH
45220: LD_EXP 80
45224: PUSH
45225: LD_VAR 0 3
45229: ARRAY
45230: IN
45231: IFFALSE 45255
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45233: LD_ADDR_EXP 80
45237: PUSH
45238: LD_EXP 80
45242: PPUSH
45243: LD_VAR 0 3
45247: PPUSH
45248: EMPTY
45249: PPUSH
45250: CALL_OW 1
45254: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45255: LD_VAR 0 1
45259: PPUSH
45260: CALL_OW 247
45264: PUSH
45265: LD_INT 2
45267: EQUAL
45268: PUSH
45269: LD_VAR 0 1
45273: PPUSH
45274: CALL_OW 110
45278: PUSH
45279: LD_INT 20
45281: EQUAL
45282: PUSH
45283: LD_VAR 0 1
45287: PUSH
45288: LD_EXP 72
45292: PUSH
45293: LD_VAR 0 3
45297: ARRAY
45298: IN
45299: OR
45300: PUSH
45301: LD_VAR 0 1
45305: PPUSH
45306: CALL_OW 264
45310: PUSH
45311: LD_INT 12
45313: PUSH
45314: LD_INT 51
45316: PUSH
45317: LD_EXP 94
45321: PUSH
45322: LD_INT 32
45324: PUSH
45325: LD_INT 13
45327: PUSH
45328: LD_INT 52
45330: PUSH
45331: LD_INT 31
45333: PUSH
45334: EMPTY
45335: LIST
45336: LIST
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: IN
45343: OR
45344: AND
45345: IFFALSE 45653
// begin if un in mc_defender [ i ] then
45347: LD_VAR 0 1
45351: PUSH
45352: LD_EXP 72
45356: PUSH
45357: LD_VAR 0 3
45361: ARRAY
45362: IN
45363: IFFALSE 45402
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45365: LD_ADDR_EXP 72
45369: PUSH
45370: LD_EXP 72
45374: PPUSH
45375: LD_VAR 0 3
45379: PPUSH
45380: LD_EXP 72
45384: PUSH
45385: LD_VAR 0 3
45389: ARRAY
45390: PUSH
45391: LD_VAR 0 1
45395: DIFF
45396: PPUSH
45397: CALL_OW 1
45401: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
45402: LD_ADDR_VAR 0 8
45406: PUSH
45407: LD_VAR 0 3
45411: PPUSH
45412: LD_INT 3
45414: PPUSH
45415: CALL 42052 0 2
45419: ST_TO_ADDR
// if fac then
45420: LD_VAR 0 8
45424: IFFALSE 45653
// begin for j in fac do
45426: LD_ADDR_VAR 0 4
45430: PUSH
45431: LD_VAR 0 8
45435: PUSH
45436: FOR_IN
45437: IFFALSE 45651
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
45439: LD_ADDR_VAR 0 9
45443: PUSH
45444: LD_VAR 0 8
45448: PPUSH
45449: LD_VAR 0 1
45453: PPUSH
45454: CALL_OW 265
45458: PPUSH
45459: LD_VAR 0 1
45463: PPUSH
45464: CALL_OW 262
45468: PPUSH
45469: LD_VAR 0 1
45473: PPUSH
45474: CALL_OW 263
45478: PPUSH
45479: LD_VAR 0 1
45483: PPUSH
45484: CALL_OW 264
45488: PPUSH
45489: CALL 50438 0 5
45493: ST_TO_ADDR
// if components then
45494: LD_VAR 0 9
45498: IFFALSE 45649
// begin if GetWeapon ( un ) = ar_control_tower then
45500: LD_VAR 0 1
45504: PPUSH
45505: CALL_OW 264
45509: PUSH
45510: LD_INT 31
45512: EQUAL
45513: IFFALSE 45630
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
45515: LD_VAR 0 1
45519: PPUSH
45520: CALL_OW 311
45524: PPUSH
45525: LD_INT 0
45527: PPUSH
45528: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
45532: LD_ADDR_EXP 90
45536: PUSH
45537: LD_EXP 90
45541: PPUSH
45542: LD_VAR 0 3
45546: PPUSH
45547: LD_EXP 90
45551: PUSH
45552: LD_VAR 0 3
45556: ARRAY
45557: PUSH
45558: LD_VAR 0 1
45562: PPUSH
45563: CALL_OW 311
45567: DIFF
45568: PPUSH
45569: CALL_OW 1
45573: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
45574: LD_ADDR_VAR 0 7
45578: PUSH
45579: LD_EXP 71
45583: PUSH
45584: LD_VAR 0 3
45588: ARRAY
45589: PPUSH
45590: LD_INT 1
45592: PPUSH
45593: LD_VAR 0 9
45597: PPUSH
45598: CALL_OW 2
45602: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
45603: LD_ADDR_EXP 71
45607: PUSH
45608: LD_EXP 71
45612: PPUSH
45613: LD_VAR 0 3
45617: PPUSH
45618: LD_VAR 0 7
45622: PPUSH
45623: CALL_OW 1
45627: ST_TO_ADDR
// end else
45628: GO 45647
// MC_InsertProduceList ( i , [ components ] ) ;
45630: LD_VAR 0 3
45634: PPUSH
45635: LD_VAR 0 9
45639: PUSH
45640: EMPTY
45641: LIST
45642: PPUSH
45643: CALL 41597 0 2
// break ;
45647: GO 45651
// end ; end ;
45649: GO 45436
45651: POP
45652: POP
// end ; end ; if GetType ( un ) = unit_building then
45653: LD_VAR 0 1
45657: PPUSH
45658: CALL_OW 247
45662: PUSH
45663: LD_INT 3
45665: EQUAL
45666: IFFALSE 46069
// begin btype := GetBType ( un ) ;
45668: LD_ADDR_VAR 0 5
45672: PUSH
45673: LD_VAR 0 1
45677: PPUSH
45678: CALL_OW 266
45682: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
45683: LD_VAR 0 5
45687: PUSH
45688: LD_INT 29
45690: PUSH
45691: LD_INT 30
45693: PUSH
45694: EMPTY
45695: LIST
45696: LIST
45697: IN
45698: IFFALSE 45771
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
45700: LD_VAR 0 1
45704: PPUSH
45705: CALL_OW 250
45709: PPUSH
45710: LD_VAR 0 1
45714: PPUSH
45715: CALL_OW 251
45719: PPUSH
45720: LD_VAR 0 1
45724: PPUSH
45725: CALL_OW 255
45729: PPUSH
45730: CALL_OW 440
45734: NOT
45735: IFFALSE 45771
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45737: LD_VAR 0 1
45741: PPUSH
45742: CALL_OW 250
45746: PPUSH
45747: LD_VAR 0 1
45751: PPUSH
45752: CALL_OW 251
45756: PPUSH
45757: LD_VAR 0 1
45761: PPUSH
45762: CALL_OW 255
45766: PPUSH
45767: CALL_OW 441
// end ; if btype = b_warehouse then
45771: LD_VAR 0 5
45775: PUSH
45776: LD_INT 1
45778: EQUAL
45779: IFFALSE 45797
// begin btype := b_depot ;
45781: LD_ADDR_VAR 0 5
45785: PUSH
45786: LD_INT 0
45788: ST_TO_ADDR
// pos := 1 ;
45789: LD_ADDR_VAR 0 6
45793: PUSH
45794: LD_INT 1
45796: ST_TO_ADDR
// end ; if btype = b_factory then
45797: LD_VAR 0 5
45801: PUSH
45802: LD_INT 3
45804: EQUAL
45805: IFFALSE 45823
// begin btype := b_workshop ;
45807: LD_ADDR_VAR 0 5
45811: PUSH
45812: LD_INT 2
45814: ST_TO_ADDR
// pos := 1 ;
45815: LD_ADDR_VAR 0 6
45819: PUSH
45820: LD_INT 1
45822: ST_TO_ADDR
// end ; if btype = b_barracks then
45823: LD_VAR 0 5
45827: PUSH
45828: LD_INT 5
45830: EQUAL
45831: IFFALSE 45841
// btype := b_armoury ;
45833: LD_ADDR_VAR 0 5
45837: PUSH
45838: LD_INT 4
45840: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
45841: LD_VAR 0 5
45845: PUSH
45846: LD_INT 7
45848: PUSH
45849: LD_INT 8
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: IN
45856: IFFALSE 45866
// btype := b_lab ;
45858: LD_ADDR_VAR 0 5
45862: PUSH
45863: LD_INT 6
45865: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
45866: LD_ADDR_EXP 55
45870: PUSH
45871: LD_EXP 55
45875: PPUSH
45876: LD_VAR 0 3
45880: PUSH
45881: LD_EXP 55
45885: PUSH
45886: LD_VAR 0 3
45890: ARRAY
45891: PUSH
45892: LD_INT 1
45894: PLUS
45895: PUSH
45896: EMPTY
45897: LIST
45898: LIST
45899: PPUSH
45900: LD_VAR 0 5
45904: PUSH
45905: LD_VAR 0 1
45909: PPUSH
45910: CALL_OW 250
45914: PUSH
45915: LD_VAR 0 1
45919: PPUSH
45920: CALL_OW 251
45924: PUSH
45925: LD_VAR 0 1
45929: PPUSH
45930: CALL_OW 254
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: LIST
45939: LIST
45940: PPUSH
45941: CALL 52906 0 3
45945: ST_TO_ADDR
// if pos = 1 then
45946: LD_VAR 0 6
45950: PUSH
45951: LD_INT 1
45953: EQUAL
45954: IFFALSE 46069
// begin tmp := mc_build_list [ i ] ;
45956: LD_ADDR_VAR 0 7
45960: PUSH
45961: LD_EXP 55
45965: PUSH
45966: LD_VAR 0 3
45970: ARRAY
45971: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45972: LD_VAR 0 7
45976: PPUSH
45977: LD_INT 2
45979: PUSH
45980: LD_INT 30
45982: PUSH
45983: LD_INT 0
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PUSH
45990: LD_INT 30
45992: PUSH
45993: LD_INT 1
45995: PUSH
45996: EMPTY
45997: LIST
45998: LIST
45999: PUSH
46000: EMPTY
46001: LIST
46002: LIST
46003: LIST
46004: PPUSH
46005: CALL_OW 72
46009: IFFALSE 46019
// pos := 2 ;
46011: LD_ADDR_VAR 0 6
46015: PUSH
46016: LD_INT 2
46018: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46019: LD_ADDR_VAR 0 7
46023: PUSH
46024: LD_VAR 0 7
46028: PPUSH
46029: LD_VAR 0 6
46033: PPUSH
46034: LD_VAR 0 7
46038: PPUSH
46039: CALL 53232 0 3
46043: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46044: LD_ADDR_EXP 55
46048: PUSH
46049: LD_EXP 55
46053: PPUSH
46054: LD_VAR 0 3
46058: PPUSH
46059: LD_VAR 0 7
46063: PPUSH
46064: CALL_OW 1
46068: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46069: LD_VAR 0 1
46073: PUSH
46074: LD_EXP 50
46078: PUSH
46079: LD_VAR 0 3
46083: ARRAY
46084: IN
46085: IFFALSE 46124
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46087: LD_ADDR_EXP 50
46091: PUSH
46092: LD_EXP 50
46096: PPUSH
46097: LD_VAR 0 3
46101: PPUSH
46102: LD_EXP 50
46106: PUSH
46107: LD_VAR 0 3
46111: ARRAY
46112: PUSH
46113: LD_VAR 0 1
46117: DIFF
46118: PPUSH
46119: CALL_OW 1
46123: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46124: LD_VAR 0 1
46128: PUSH
46129: LD_EXP 57
46133: PUSH
46134: LD_VAR 0 3
46138: ARRAY
46139: IN
46140: IFFALSE 46179
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46142: LD_ADDR_EXP 57
46146: PUSH
46147: LD_EXP 57
46151: PPUSH
46152: LD_VAR 0 3
46156: PPUSH
46157: LD_EXP 57
46161: PUSH
46162: LD_VAR 0 3
46166: ARRAY
46167: PUSH
46168: LD_VAR 0 1
46172: DIFF
46173: PPUSH
46174: CALL_OW 1
46178: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46179: LD_VAR 0 1
46183: PUSH
46184: LD_EXP 69
46188: PUSH
46189: LD_VAR 0 3
46193: ARRAY
46194: IN
46195: IFFALSE 46234
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46197: LD_ADDR_EXP 69
46201: PUSH
46202: LD_EXP 69
46206: PPUSH
46207: LD_VAR 0 3
46211: PPUSH
46212: LD_EXP 69
46216: PUSH
46217: LD_VAR 0 3
46221: ARRAY
46222: PUSH
46223: LD_VAR 0 1
46227: DIFF
46228: PPUSH
46229: CALL_OW 1
46233: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46234: LD_VAR 0 1
46238: PUSH
46239: LD_EXP 72
46243: PUSH
46244: LD_VAR 0 3
46248: ARRAY
46249: IN
46250: IFFALSE 46289
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46252: LD_ADDR_EXP 72
46256: PUSH
46257: LD_EXP 72
46261: PPUSH
46262: LD_VAR 0 3
46266: PPUSH
46267: LD_EXP 72
46271: PUSH
46272: LD_VAR 0 3
46276: ARRAY
46277: PUSH
46278: LD_VAR 0 1
46282: DIFF
46283: PPUSH
46284: CALL_OW 1
46288: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46289: LD_VAR 0 1
46293: PUSH
46294: LD_EXP 59
46298: PUSH
46299: LD_VAR 0 3
46303: ARRAY
46304: IN
46305: IFFALSE 46344
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46307: LD_ADDR_EXP 59
46311: PUSH
46312: LD_EXP 59
46316: PPUSH
46317: LD_VAR 0 3
46321: PPUSH
46322: LD_EXP 59
46326: PUSH
46327: LD_VAR 0 3
46331: ARRAY
46332: PUSH
46333: LD_VAR 0 1
46337: DIFF
46338: PPUSH
46339: CALL_OW 1
46343: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46344: LD_VAR 0 1
46348: PUSH
46349: LD_EXP 58
46353: PUSH
46354: LD_VAR 0 3
46358: ARRAY
46359: IN
46360: IFFALSE 46399
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
46362: LD_ADDR_EXP 58
46366: PUSH
46367: LD_EXP 58
46371: PPUSH
46372: LD_VAR 0 3
46376: PPUSH
46377: LD_EXP 58
46381: PUSH
46382: LD_VAR 0 3
46386: ARRAY
46387: PUSH
46388: LD_VAR 0 1
46392: DIFF
46393: PPUSH
46394: CALL_OW 1
46398: ST_TO_ADDR
// end ; break ;
46399: GO 46403
// end ;
46401: GO 45049
46403: POP
46404: POP
// end ;
46405: LD_VAR 0 2
46409: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
46410: LD_INT 0
46412: PPUSH
46413: PPUSH
46414: PPUSH
// if not mc_bases or not skirmish then
46415: LD_EXP 50
46419: NOT
46420: PUSH
46421: LD_EXP 48
46425: NOT
46426: OR
46427: IFFALSE 46431
// exit ;
46429: GO 46646
// for i = 1 to mc_bases do
46431: LD_ADDR_VAR 0 3
46435: PUSH
46436: DOUBLE
46437: LD_INT 1
46439: DEC
46440: ST_TO_ADDR
46441: LD_EXP 50
46445: PUSH
46446: FOR_TO
46447: IFFALSE 46644
// begin if building in mc_construct_list [ i ] then
46449: LD_VAR 0 1
46453: PUSH
46454: LD_EXP 57
46458: PUSH
46459: LD_VAR 0 3
46463: ARRAY
46464: IN
46465: IFFALSE 46642
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46467: LD_ADDR_EXP 57
46471: PUSH
46472: LD_EXP 57
46476: PPUSH
46477: LD_VAR 0 3
46481: PPUSH
46482: LD_EXP 57
46486: PUSH
46487: LD_VAR 0 3
46491: ARRAY
46492: PUSH
46493: LD_VAR 0 1
46497: DIFF
46498: PPUSH
46499: CALL_OW 1
46503: ST_TO_ADDR
// if building in mc_lab [ i ] then
46504: LD_VAR 0 1
46508: PUSH
46509: LD_EXP 83
46513: PUSH
46514: LD_VAR 0 3
46518: ARRAY
46519: IN
46520: IFFALSE 46575
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
46522: LD_ADDR_EXP 84
46526: PUSH
46527: LD_EXP 84
46531: PPUSH
46532: LD_VAR 0 3
46536: PPUSH
46537: LD_EXP 84
46541: PUSH
46542: LD_VAR 0 3
46546: ARRAY
46547: PPUSH
46548: LD_INT 1
46550: PPUSH
46551: LD_EXP 84
46555: PUSH
46556: LD_VAR 0 3
46560: ARRAY
46561: PPUSH
46562: LD_INT 0
46564: PPUSH
46565: CALL 52324 0 4
46569: PPUSH
46570: CALL_OW 1
46574: ST_TO_ADDR
// if not building in mc_bases [ i ] then
46575: LD_VAR 0 1
46579: PUSH
46580: LD_EXP 50
46584: PUSH
46585: LD_VAR 0 3
46589: ARRAY
46590: IN
46591: NOT
46592: IFFALSE 46638
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46594: LD_ADDR_EXP 50
46598: PUSH
46599: LD_EXP 50
46603: PPUSH
46604: LD_VAR 0 3
46608: PUSH
46609: LD_EXP 50
46613: PUSH
46614: LD_VAR 0 3
46618: ARRAY
46619: PUSH
46620: LD_INT 1
46622: PLUS
46623: PUSH
46624: EMPTY
46625: LIST
46626: LIST
46627: PPUSH
46628: LD_VAR 0 1
46632: PPUSH
46633: CALL 52906 0 3
46637: ST_TO_ADDR
// exit ;
46638: POP
46639: POP
46640: GO 46646
// end ; end ;
46642: GO 46446
46644: POP
46645: POP
// end ;
46646: LD_VAR 0 2
46650: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
46651: LD_INT 0
46653: PPUSH
46654: PPUSH
46655: PPUSH
46656: PPUSH
46657: PPUSH
46658: PPUSH
46659: PPUSH
// if not mc_bases or not skirmish then
46660: LD_EXP 50
46664: NOT
46665: PUSH
46666: LD_EXP 48
46670: NOT
46671: OR
46672: IFFALSE 46676
// exit ;
46674: GO 47337
// for i = 1 to mc_bases do
46676: LD_ADDR_VAR 0 3
46680: PUSH
46681: DOUBLE
46682: LD_INT 1
46684: DEC
46685: ST_TO_ADDR
46686: LD_EXP 50
46690: PUSH
46691: FOR_TO
46692: IFFALSE 47335
// begin if building in mc_construct_list [ i ] then
46694: LD_VAR 0 1
46698: PUSH
46699: LD_EXP 57
46703: PUSH
46704: LD_VAR 0 3
46708: ARRAY
46709: IN
46710: IFFALSE 47333
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46712: LD_ADDR_EXP 57
46716: PUSH
46717: LD_EXP 57
46721: PPUSH
46722: LD_VAR 0 3
46726: PPUSH
46727: LD_EXP 57
46731: PUSH
46732: LD_VAR 0 3
46736: ARRAY
46737: PUSH
46738: LD_VAR 0 1
46742: DIFF
46743: PPUSH
46744: CALL_OW 1
46748: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46749: LD_ADDR_EXP 50
46753: PUSH
46754: LD_EXP 50
46758: PPUSH
46759: LD_VAR 0 3
46763: PUSH
46764: LD_EXP 50
46768: PUSH
46769: LD_VAR 0 3
46773: ARRAY
46774: PUSH
46775: LD_INT 1
46777: PLUS
46778: PUSH
46779: EMPTY
46780: LIST
46781: LIST
46782: PPUSH
46783: LD_VAR 0 1
46787: PPUSH
46788: CALL 52906 0 3
46792: ST_TO_ADDR
// btype := GetBType ( building ) ;
46793: LD_ADDR_VAR 0 5
46797: PUSH
46798: LD_VAR 0 1
46802: PPUSH
46803: CALL_OW 266
46807: ST_TO_ADDR
// side := GetSide ( building ) ;
46808: LD_ADDR_VAR 0 8
46812: PUSH
46813: LD_VAR 0 1
46817: PPUSH
46818: CALL_OW 255
46822: ST_TO_ADDR
// if btype = b_lab then
46823: LD_VAR 0 5
46827: PUSH
46828: LD_INT 6
46830: EQUAL
46831: IFFALSE 46881
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
46833: LD_ADDR_EXP 83
46837: PUSH
46838: LD_EXP 83
46842: PPUSH
46843: LD_VAR 0 3
46847: PUSH
46848: LD_EXP 83
46852: PUSH
46853: LD_VAR 0 3
46857: ARRAY
46858: PUSH
46859: LD_INT 1
46861: PLUS
46862: PUSH
46863: EMPTY
46864: LIST
46865: LIST
46866: PPUSH
46867: LD_VAR 0 1
46871: PPUSH
46872: CALL 52906 0 3
46876: ST_TO_ADDR
// exit ;
46877: POP
46878: POP
46879: GO 47337
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
46881: LD_VAR 0 5
46885: PUSH
46886: LD_INT 0
46888: PUSH
46889: LD_INT 2
46891: PUSH
46892: LD_INT 4
46894: PUSH
46895: EMPTY
46896: LIST
46897: LIST
46898: LIST
46899: IN
46900: IFFALSE 47024
// begin if btype = b_armoury then
46902: LD_VAR 0 5
46906: PUSH
46907: LD_INT 4
46909: EQUAL
46910: IFFALSE 46920
// btype := b_barracks ;
46912: LD_ADDR_VAR 0 5
46916: PUSH
46917: LD_INT 5
46919: ST_TO_ADDR
// if btype = b_depot then
46920: LD_VAR 0 5
46924: PUSH
46925: LD_INT 0
46927: EQUAL
46928: IFFALSE 46938
// btype := b_warehouse ;
46930: LD_ADDR_VAR 0 5
46934: PUSH
46935: LD_INT 1
46937: ST_TO_ADDR
// if btype = b_workshop then
46938: LD_VAR 0 5
46942: PUSH
46943: LD_INT 2
46945: EQUAL
46946: IFFALSE 46956
// btype := b_factory ;
46948: LD_ADDR_VAR 0 5
46952: PUSH
46953: LD_INT 3
46955: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
46956: LD_VAR 0 5
46960: PPUSH
46961: LD_VAR 0 8
46965: PPUSH
46966: CALL_OW 323
46970: PUSH
46971: LD_INT 1
46973: EQUAL
46974: IFFALSE 47020
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
46976: LD_ADDR_EXP 82
46980: PUSH
46981: LD_EXP 82
46985: PPUSH
46986: LD_VAR 0 3
46990: PUSH
46991: LD_EXP 82
46995: PUSH
46996: LD_VAR 0 3
47000: ARRAY
47001: PUSH
47002: LD_INT 1
47004: PLUS
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PPUSH
47010: LD_VAR 0 1
47014: PPUSH
47015: CALL 52906 0 3
47019: ST_TO_ADDR
// exit ;
47020: POP
47021: POP
47022: GO 47337
// end ; if btype in [ b_bunker , b_turret ] then
47024: LD_VAR 0 5
47028: PUSH
47029: LD_INT 32
47031: PUSH
47032: LD_INT 33
47034: PUSH
47035: EMPTY
47036: LIST
47037: LIST
47038: IN
47039: IFFALSE 47329
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47041: LD_ADDR_EXP 58
47045: PUSH
47046: LD_EXP 58
47050: PPUSH
47051: LD_VAR 0 3
47055: PUSH
47056: LD_EXP 58
47060: PUSH
47061: LD_VAR 0 3
47065: ARRAY
47066: PUSH
47067: LD_INT 1
47069: PLUS
47070: PUSH
47071: EMPTY
47072: LIST
47073: LIST
47074: PPUSH
47075: LD_VAR 0 1
47079: PPUSH
47080: CALL 52906 0 3
47084: ST_TO_ADDR
// if btype = b_bunker then
47085: LD_VAR 0 5
47089: PUSH
47090: LD_INT 32
47092: EQUAL
47093: IFFALSE 47329
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47095: LD_ADDR_EXP 59
47099: PUSH
47100: LD_EXP 59
47104: PPUSH
47105: LD_VAR 0 3
47109: PUSH
47110: LD_EXP 59
47114: PUSH
47115: LD_VAR 0 3
47119: ARRAY
47120: PUSH
47121: LD_INT 1
47123: PLUS
47124: PUSH
47125: EMPTY
47126: LIST
47127: LIST
47128: PPUSH
47129: LD_VAR 0 1
47133: PPUSH
47134: CALL 52906 0 3
47138: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47139: LD_ADDR_VAR 0 6
47143: PUSH
47144: LD_EXP 50
47148: PUSH
47149: LD_VAR 0 3
47153: ARRAY
47154: PPUSH
47155: LD_INT 25
47157: PUSH
47158: LD_INT 1
47160: PUSH
47161: EMPTY
47162: LIST
47163: LIST
47164: PUSH
47165: LD_INT 3
47167: PUSH
47168: LD_INT 54
47170: PUSH
47171: EMPTY
47172: LIST
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PUSH
47178: EMPTY
47179: LIST
47180: LIST
47181: PPUSH
47182: CALL_OW 72
47186: ST_TO_ADDR
// if tmp then
47187: LD_VAR 0 6
47191: IFFALSE 47197
// exit ;
47193: POP
47194: POP
47195: GO 47337
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47197: LD_ADDR_VAR 0 6
47201: PUSH
47202: LD_EXP 50
47206: PUSH
47207: LD_VAR 0 3
47211: ARRAY
47212: PPUSH
47213: LD_INT 2
47215: PUSH
47216: LD_INT 30
47218: PUSH
47219: LD_INT 4
47221: PUSH
47222: EMPTY
47223: LIST
47224: LIST
47225: PUSH
47226: LD_INT 30
47228: PUSH
47229: LD_INT 5
47231: PUSH
47232: EMPTY
47233: LIST
47234: LIST
47235: PUSH
47236: EMPTY
47237: LIST
47238: LIST
47239: LIST
47240: PPUSH
47241: CALL_OW 72
47245: ST_TO_ADDR
// if not tmp then
47246: LD_VAR 0 6
47250: NOT
47251: IFFALSE 47257
// exit ;
47253: POP
47254: POP
47255: GO 47337
// for j in tmp do
47257: LD_ADDR_VAR 0 4
47261: PUSH
47262: LD_VAR 0 6
47266: PUSH
47267: FOR_IN
47268: IFFALSE 47327
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47270: LD_ADDR_VAR 0 7
47274: PUSH
47275: LD_VAR 0 4
47279: PPUSH
47280: CALL_OW 313
47284: PPUSH
47285: LD_INT 25
47287: PUSH
47288: LD_INT 1
47290: PUSH
47291: EMPTY
47292: LIST
47293: LIST
47294: PPUSH
47295: CALL_OW 72
47299: ST_TO_ADDR
// if units then
47300: LD_VAR 0 7
47304: IFFALSE 47325
// begin ComExitBuilding ( units [ 1 ] ) ;
47306: LD_VAR 0 7
47310: PUSH
47311: LD_INT 1
47313: ARRAY
47314: PPUSH
47315: CALL_OW 122
// exit ;
47319: POP
47320: POP
47321: POP
47322: POP
47323: GO 47337
// end ; end ;
47325: GO 47267
47327: POP
47328: POP
// end ; end ; exit ;
47329: POP
47330: POP
47331: GO 47337
// end ; end ;
47333: GO 46691
47335: POP
47336: POP
// end ;
47337: LD_VAR 0 2
47341: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47342: LD_INT 0
47344: PPUSH
47345: PPUSH
47346: PPUSH
47347: PPUSH
47348: PPUSH
47349: PPUSH
47350: PPUSH
// if not mc_bases or not skirmish then
47351: LD_EXP 50
47355: NOT
47356: PUSH
47357: LD_EXP 48
47361: NOT
47362: OR
47363: IFFALSE 47367
// exit ;
47365: GO 47598
// btype := GetBType ( building ) ;
47367: LD_ADDR_VAR 0 6
47371: PUSH
47372: LD_VAR 0 1
47376: PPUSH
47377: CALL_OW 266
47381: ST_TO_ADDR
// x := GetX ( building ) ;
47382: LD_ADDR_VAR 0 7
47386: PUSH
47387: LD_VAR 0 1
47391: PPUSH
47392: CALL_OW 250
47396: ST_TO_ADDR
// y := GetY ( building ) ;
47397: LD_ADDR_VAR 0 8
47401: PUSH
47402: LD_VAR 0 1
47406: PPUSH
47407: CALL_OW 251
47411: ST_TO_ADDR
// d := GetDir ( building ) ;
47412: LD_ADDR_VAR 0 9
47416: PUSH
47417: LD_VAR 0 1
47421: PPUSH
47422: CALL_OW 254
47426: ST_TO_ADDR
// for i = 1 to mc_bases do
47427: LD_ADDR_VAR 0 4
47431: PUSH
47432: DOUBLE
47433: LD_INT 1
47435: DEC
47436: ST_TO_ADDR
47437: LD_EXP 50
47441: PUSH
47442: FOR_TO
47443: IFFALSE 47596
// begin if not mc_build_list [ i ] then
47445: LD_EXP 55
47449: PUSH
47450: LD_VAR 0 4
47454: ARRAY
47455: NOT
47456: IFFALSE 47460
// continue ;
47458: GO 47442
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
47460: LD_VAR 0 6
47464: PUSH
47465: LD_VAR 0 7
47469: PUSH
47470: LD_VAR 0 8
47474: PUSH
47475: LD_VAR 0 9
47479: PUSH
47480: EMPTY
47481: LIST
47482: LIST
47483: LIST
47484: LIST
47485: PPUSH
47486: LD_EXP 55
47490: PUSH
47491: LD_VAR 0 4
47495: ARRAY
47496: PUSH
47497: LD_INT 1
47499: ARRAY
47500: PPUSH
47501: CALL 59113 0 2
47505: IFFALSE 47594
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
47507: LD_ADDR_EXP 55
47511: PUSH
47512: LD_EXP 55
47516: PPUSH
47517: LD_VAR 0 4
47521: PPUSH
47522: LD_EXP 55
47526: PUSH
47527: LD_VAR 0 4
47531: ARRAY
47532: PPUSH
47533: LD_INT 1
47535: PPUSH
47536: CALL_OW 3
47540: PPUSH
47541: CALL_OW 1
47545: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
47546: LD_ADDR_EXP 57
47550: PUSH
47551: LD_EXP 57
47555: PPUSH
47556: LD_VAR 0 4
47560: PUSH
47561: LD_EXP 57
47565: PUSH
47566: LD_VAR 0 4
47570: ARRAY
47571: PUSH
47572: LD_INT 1
47574: PLUS
47575: PUSH
47576: EMPTY
47577: LIST
47578: LIST
47579: PPUSH
47580: LD_VAR 0 1
47584: PPUSH
47585: CALL 52906 0 3
47589: ST_TO_ADDR
// exit ;
47590: POP
47591: POP
47592: GO 47598
// end ; end ;
47594: GO 47442
47596: POP
47597: POP
// end ;
47598: LD_VAR 0 3
47602: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
47603: LD_INT 0
47605: PPUSH
47606: PPUSH
47607: PPUSH
// if not mc_bases or not skirmish then
47608: LD_EXP 50
47612: NOT
47613: PUSH
47614: LD_EXP 48
47618: NOT
47619: OR
47620: IFFALSE 47624
// exit ;
47622: GO 47814
// for i = 1 to mc_bases do
47624: LD_ADDR_VAR 0 4
47628: PUSH
47629: DOUBLE
47630: LD_INT 1
47632: DEC
47633: ST_TO_ADDR
47634: LD_EXP 50
47638: PUSH
47639: FOR_TO
47640: IFFALSE 47727
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
47642: LD_VAR 0 1
47646: PUSH
47647: LD_EXP 58
47651: PUSH
47652: LD_VAR 0 4
47656: ARRAY
47657: IN
47658: PUSH
47659: LD_VAR 0 1
47663: PUSH
47664: LD_EXP 59
47668: PUSH
47669: LD_VAR 0 4
47673: ARRAY
47674: IN
47675: NOT
47676: AND
47677: IFFALSE 47725
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47679: LD_ADDR_EXP 59
47683: PUSH
47684: LD_EXP 59
47688: PPUSH
47689: LD_VAR 0 4
47693: PUSH
47694: LD_EXP 59
47698: PUSH
47699: LD_VAR 0 4
47703: ARRAY
47704: PUSH
47705: LD_INT 1
47707: PLUS
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PPUSH
47713: LD_VAR 0 1
47717: PPUSH
47718: CALL 52906 0 3
47722: ST_TO_ADDR
// break ;
47723: GO 47727
// end ; end ;
47725: GO 47639
47727: POP
47728: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47729: LD_VAR 0 1
47733: PPUSH
47734: CALL_OW 257
47738: PUSH
47739: LD_EXP 76
47743: IN
47744: PUSH
47745: LD_VAR 0 1
47749: PPUSH
47750: CALL_OW 266
47754: PUSH
47755: LD_INT 5
47757: EQUAL
47758: AND
47759: PUSH
47760: LD_VAR 0 2
47764: PPUSH
47765: CALL_OW 110
47769: PUSH
47770: LD_INT 18
47772: NONEQUAL
47773: AND
47774: IFFALSE 47814
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47776: LD_VAR 0 2
47780: PPUSH
47781: CALL_OW 257
47785: PUSH
47786: LD_INT 5
47788: PUSH
47789: LD_INT 8
47791: PUSH
47792: LD_INT 9
47794: PUSH
47795: EMPTY
47796: LIST
47797: LIST
47798: LIST
47799: IN
47800: IFFALSE 47814
// SetClass ( unit , 1 ) ;
47802: LD_VAR 0 2
47806: PPUSH
47807: LD_INT 1
47809: PPUSH
47810: CALL_OW 336
// end ;
47814: LD_VAR 0 3
47818: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
47819: LD_INT 0
47821: PPUSH
47822: PPUSH
// if not mc_bases or not skirmish then
47823: LD_EXP 50
47827: NOT
47828: PUSH
47829: LD_EXP 48
47833: NOT
47834: OR
47835: IFFALSE 47839
// exit ;
47837: GO 47955
// if GetLives ( abandoned_vehicle ) > 250 then
47839: LD_VAR 0 2
47843: PPUSH
47844: CALL_OW 256
47848: PUSH
47849: LD_INT 250
47851: GREATER
47852: IFFALSE 47856
// exit ;
47854: GO 47955
// for i = 1 to mc_bases do
47856: LD_ADDR_VAR 0 6
47860: PUSH
47861: DOUBLE
47862: LD_INT 1
47864: DEC
47865: ST_TO_ADDR
47866: LD_EXP 50
47870: PUSH
47871: FOR_TO
47872: IFFALSE 47953
// begin if driver in mc_bases [ i ] then
47874: LD_VAR 0 1
47878: PUSH
47879: LD_EXP 50
47883: PUSH
47884: LD_VAR 0 6
47888: ARRAY
47889: IN
47890: IFFALSE 47951
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
47892: LD_VAR 0 1
47896: PPUSH
47897: LD_EXP 50
47901: PUSH
47902: LD_VAR 0 6
47906: ARRAY
47907: PPUSH
47908: LD_INT 2
47910: PUSH
47911: LD_INT 30
47913: PUSH
47914: LD_INT 0
47916: PUSH
47917: EMPTY
47918: LIST
47919: LIST
47920: PUSH
47921: LD_INT 30
47923: PUSH
47924: LD_INT 1
47926: PUSH
47927: EMPTY
47928: LIST
47929: LIST
47930: PUSH
47931: EMPTY
47932: LIST
47933: LIST
47934: LIST
47935: PPUSH
47936: CALL_OW 72
47940: PUSH
47941: LD_INT 1
47943: ARRAY
47944: PPUSH
47945: CALL 85149 0 2
// break ;
47949: GO 47953
// end ; end ;
47951: GO 47871
47953: POP
47954: POP
// end ; end_of_file
47955: LD_VAR 0 5
47959: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
47960: LD_INT 0
47962: PPUSH
47963: PPUSH
// if exist_mode then
47964: LD_VAR 0 2
47968: IFFALSE 47993
// unit := CreateCharacter ( prefix & ident ) else
47970: LD_ADDR_VAR 0 5
47974: PUSH
47975: LD_VAR 0 3
47979: PUSH
47980: LD_VAR 0 1
47984: STR
47985: PPUSH
47986: CALL_OW 34
47990: ST_TO_ADDR
47991: GO 48008
// unit := NewCharacter ( ident ) ;
47993: LD_ADDR_VAR 0 5
47997: PUSH
47998: LD_VAR 0 1
48002: PPUSH
48003: CALL_OW 25
48007: ST_TO_ADDR
// result := unit ;
48008: LD_ADDR_VAR 0 4
48012: PUSH
48013: LD_VAR 0 5
48017: ST_TO_ADDR
// end ;
48018: LD_VAR 0 4
48022: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48023: LD_INT 0
48025: PPUSH
48026: PPUSH
// if not side or not nation then
48027: LD_VAR 0 1
48031: NOT
48032: PUSH
48033: LD_VAR 0 2
48037: NOT
48038: OR
48039: IFFALSE 48043
// exit ;
48041: GO 48807
// case nation of nation_american :
48043: LD_VAR 0 2
48047: PUSH
48048: LD_INT 1
48050: DOUBLE
48051: EQUAL
48052: IFTRUE 48056
48054: GO 48270
48056: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48057: LD_ADDR_VAR 0 4
48061: PUSH
48062: LD_INT 35
48064: PUSH
48065: LD_INT 45
48067: PUSH
48068: LD_INT 46
48070: PUSH
48071: LD_INT 47
48073: PUSH
48074: LD_INT 82
48076: PUSH
48077: LD_INT 83
48079: PUSH
48080: LD_INT 84
48082: PUSH
48083: LD_INT 85
48085: PUSH
48086: LD_INT 86
48088: PUSH
48089: LD_INT 1
48091: PUSH
48092: LD_INT 2
48094: PUSH
48095: LD_INT 6
48097: PUSH
48098: LD_INT 15
48100: PUSH
48101: LD_INT 16
48103: PUSH
48104: LD_INT 7
48106: PUSH
48107: LD_INT 12
48109: PUSH
48110: LD_INT 13
48112: PUSH
48113: LD_INT 10
48115: PUSH
48116: LD_INT 14
48118: PUSH
48119: LD_INT 20
48121: PUSH
48122: LD_INT 21
48124: PUSH
48125: LD_INT 22
48127: PUSH
48128: LD_INT 25
48130: PUSH
48131: LD_INT 32
48133: PUSH
48134: LD_INT 27
48136: PUSH
48137: LD_INT 36
48139: PUSH
48140: LD_INT 69
48142: PUSH
48143: LD_INT 39
48145: PUSH
48146: LD_INT 34
48148: PUSH
48149: LD_INT 40
48151: PUSH
48152: LD_INT 48
48154: PUSH
48155: LD_INT 49
48157: PUSH
48158: LD_INT 50
48160: PUSH
48161: LD_INT 51
48163: PUSH
48164: LD_INT 52
48166: PUSH
48167: LD_INT 53
48169: PUSH
48170: LD_INT 54
48172: PUSH
48173: LD_INT 55
48175: PUSH
48176: LD_INT 56
48178: PUSH
48179: LD_INT 57
48181: PUSH
48182: LD_INT 58
48184: PUSH
48185: LD_INT 59
48187: PUSH
48188: LD_INT 60
48190: PUSH
48191: LD_INT 61
48193: PUSH
48194: LD_INT 62
48196: PUSH
48197: LD_INT 80
48199: PUSH
48200: LD_INT 82
48202: PUSH
48203: LD_INT 83
48205: PUSH
48206: LD_INT 84
48208: PUSH
48209: LD_INT 85
48211: PUSH
48212: LD_INT 86
48214: PUSH
48215: EMPTY
48216: LIST
48217: LIST
48218: LIST
48219: LIST
48220: LIST
48221: LIST
48222: LIST
48223: LIST
48224: LIST
48225: LIST
48226: LIST
48227: LIST
48228: LIST
48229: LIST
48230: LIST
48231: LIST
48232: LIST
48233: LIST
48234: LIST
48235: LIST
48236: LIST
48237: LIST
48238: LIST
48239: LIST
48240: LIST
48241: LIST
48242: LIST
48243: LIST
48244: LIST
48245: LIST
48246: LIST
48247: LIST
48248: LIST
48249: LIST
48250: LIST
48251: LIST
48252: LIST
48253: LIST
48254: LIST
48255: LIST
48256: LIST
48257: LIST
48258: LIST
48259: LIST
48260: LIST
48261: LIST
48262: LIST
48263: LIST
48264: LIST
48265: LIST
48266: LIST
48267: ST_TO_ADDR
48268: GO 48731
48270: LD_INT 2
48272: DOUBLE
48273: EQUAL
48274: IFTRUE 48278
48276: GO 48500
48278: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
48279: LD_ADDR_VAR 0 4
48283: PUSH
48284: LD_INT 35
48286: PUSH
48287: LD_INT 45
48289: PUSH
48290: LD_INT 46
48292: PUSH
48293: LD_INT 47
48295: PUSH
48296: LD_INT 82
48298: PUSH
48299: LD_INT 83
48301: PUSH
48302: LD_INT 84
48304: PUSH
48305: LD_INT 85
48307: PUSH
48308: LD_INT 87
48310: PUSH
48311: LD_INT 70
48313: PUSH
48314: LD_INT 1
48316: PUSH
48317: LD_INT 11
48319: PUSH
48320: LD_INT 3
48322: PUSH
48323: LD_INT 4
48325: PUSH
48326: LD_INT 5
48328: PUSH
48329: LD_INT 6
48331: PUSH
48332: LD_INT 15
48334: PUSH
48335: LD_INT 18
48337: PUSH
48338: LD_INT 7
48340: PUSH
48341: LD_INT 17
48343: PUSH
48344: LD_INT 8
48346: PUSH
48347: LD_INT 20
48349: PUSH
48350: LD_INT 21
48352: PUSH
48353: LD_INT 22
48355: PUSH
48356: LD_INT 72
48358: PUSH
48359: LD_INT 26
48361: PUSH
48362: LD_INT 69
48364: PUSH
48365: LD_INT 39
48367: PUSH
48368: LD_INT 40
48370: PUSH
48371: LD_INT 41
48373: PUSH
48374: LD_INT 42
48376: PUSH
48377: LD_INT 43
48379: PUSH
48380: LD_INT 48
48382: PUSH
48383: LD_INT 49
48385: PUSH
48386: LD_INT 50
48388: PUSH
48389: LD_INT 51
48391: PUSH
48392: LD_INT 52
48394: PUSH
48395: LD_INT 53
48397: PUSH
48398: LD_INT 54
48400: PUSH
48401: LD_INT 55
48403: PUSH
48404: LD_INT 56
48406: PUSH
48407: LD_INT 60
48409: PUSH
48410: LD_INT 61
48412: PUSH
48413: LD_INT 62
48415: PUSH
48416: LD_INT 66
48418: PUSH
48419: LD_INT 67
48421: PUSH
48422: LD_INT 68
48424: PUSH
48425: LD_INT 81
48427: PUSH
48428: LD_INT 82
48430: PUSH
48431: LD_INT 83
48433: PUSH
48434: LD_INT 84
48436: PUSH
48437: LD_INT 85
48439: PUSH
48440: LD_INT 87
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: LIST
48447: LIST
48448: LIST
48449: LIST
48450: LIST
48451: LIST
48452: LIST
48453: LIST
48454: LIST
48455: LIST
48456: LIST
48457: LIST
48458: LIST
48459: LIST
48460: LIST
48461: LIST
48462: LIST
48463: LIST
48464: LIST
48465: LIST
48466: LIST
48467: LIST
48468: LIST
48469: LIST
48470: LIST
48471: LIST
48472: LIST
48473: LIST
48474: LIST
48475: LIST
48476: LIST
48477: LIST
48478: LIST
48479: LIST
48480: LIST
48481: LIST
48482: LIST
48483: LIST
48484: LIST
48485: LIST
48486: LIST
48487: LIST
48488: LIST
48489: LIST
48490: LIST
48491: LIST
48492: LIST
48493: LIST
48494: LIST
48495: LIST
48496: LIST
48497: ST_TO_ADDR
48498: GO 48731
48500: LD_INT 3
48502: DOUBLE
48503: EQUAL
48504: IFTRUE 48508
48506: GO 48730
48508: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
48509: LD_ADDR_VAR 0 4
48513: PUSH
48514: LD_INT 46
48516: PUSH
48517: LD_INT 47
48519: PUSH
48520: LD_INT 1
48522: PUSH
48523: LD_INT 2
48525: PUSH
48526: LD_INT 82
48528: PUSH
48529: LD_INT 83
48531: PUSH
48532: LD_INT 84
48534: PUSH
48535: LD_INT 85
48537: PUSH
48538: LD_INT 86
48540: PUSH
48541: LD_INT 11
48543: PUSH
48544: LD_INT 9
48546: PUSH
48547: LD_INT 20
48549: PUSH
48550: LD_INT 19
48552: PUSH
48553: LD_INT 21
48555: PUSH
48556: LD_INT 24
48558: PUSH
48559: LD_INT 22
48561: PUSH
48562: LD_INT 25
48564: PUSH
48565: LD_INT 28
48567: PUSH
48568: LD_INT 29
48570: PUSH
48571: LD_INT 30
48573: PUSH
48574: LD_INT 31
48576: PUSH
48577: LD_INT 37
48579: PUSH
48580: LD_INT 38
48582: PUSH
48583: LD_INT 32
48585: PUSH
48586: LD_INT 27
48588: PUSH
48589: LD_INT 33
48591: PUSH
48592: LD_INT 69
48594: PUSH
48595: LD_INT 39
48597: PUSH
48598: LD_INT 34
48600: PUSH
48601: LD_INT 40
48603: PUSH
48604: LD_INT 71
48606: PUSH
48607: LD_INT 23
48609: PUSH
48610: LD_INT 44
48612: PUSH
48613: LD_INT 48
48615: PUSH
48616: LD_INT 49
48618: PUSH
48619: LD_INT 50
48621: PUSH
48622: LD_INT 51
48624: PUSH
48625: LD_INT 52
48627: PUSH
48628: LD_INT 53
48630: PUSH
48631: LD_INT 54
48633: PUSH
48634: LD_INT 55
48636: PUSH
48637: LD_INT 56
48639: PUSH
48640: LD_INT 57
48642: PUSH
48643: LD_INT 58
48645: PUSH
48646: LD_INT 59
48648: PUSH
48649: LD_INT 63
48651: PUSH
48652: LD_INT 64
48654: PUSH
48655: LD_INT 65
48657: PUSH
48658: LD_INT 82
48660: PUSH
48661: LD_INT 83
48663: PUSH
48664: LD_INT 84
48666: PUSH
48667: LD_INT 85
48669: PUSH
48670: LD_INT 86
48672: PUSH
48673: EMPTY
48674: LIST
48675: LIST
48676: LIST
48677: LIST
48678: LIST
48679: LIST
48680: LIST
48681: LIST
48682: LIST
48683: LIST
48684: LIST
48685: LIST
48686: LIST
48687: LIST
48688: LIST
48689: LIST
48690: LIST
48691: LIST
48692: LIST
48693: LIST
48694: LIST
48695: LIST
48696: LIST
48697: LIST
48698: LIST
48699: LIST
48700: LIST
48701: LIST
48702: LIST
48703: LIST
48704: LIST
48705: LIST
48706: LIST
48707: LIST
48708: LIST
48709: LIST
48710: LIST
48711: LIST
48712: LIST
48713: LIST
48714: LIST
48715: LIST
48716: LIST
48717: LIST
48718: LIST
48719: LIST
48720: LIST
48721: LIST
48722: LIST
48723: LIST
48724: LIST
48725: LIST
48726: LIST
48727: ST_TO_ADDR
48728: GO 48731
48730: POP
// if state > - 1 and state < 3 then
48731: LD_VAR 0 3
48735: PUSH
48736: LD_INT 1
48738: NEG
48739: GREATER
48740: PUSH
48741: LD_VAR 0 3
48745: PUSH
48746: LD_INT 3
48748: LESS
48749: AND
48750: IFFALSE 48807
// for i in result do
48752: LD_ADDR_VAR 0 5
48756: PUSH
48757: LD_VAR 0 4
48761: PUSH
48762: FOR_IN
48763: IFFALSE 48805
// if GetTech ( i , side ) <> state then
48765: LD_VAR 0 5
48769: PPUSH
48770: LD_VAR 0 1
48774: PPUSH
48775: CALL_OW 321
48779: PUSH
48780: LD_VAR 0 3
48784: NONEQUAL
48785: IFFALSE 48803
// result := result diff i ;
48787: LD_ADDR_VAR 0 4
48791: PUSH
48792: LD_VAR 0 4
48796: PUSH
48797: LD_VAR 0 5
48801: DIFF
48802: ST_TO_ADDR
48803: GO 48762
48805: POP
48806: POP
// end ;
48807: LD_VAR 0 4
48811: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
48812: LD_INT 0
48814: PPUSH
48815: PPUSH
48816: PPUSH
// result := true ;
48817: LD_ADDR_VAR 0 3
48821: PUSH
48822: LD_INT 1
48824: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
48825: LD_ADDR_VAR 0 5
48829: PUSH
48830: LD_VAR 0 2
48834: PPUSH
48835: CALL_OW 480
48839: ST_TO_ADDR
// if not tmp then
48840: LD_VAR 0 5
48844: NOT
48845: IFFALSE 48849
// exit ;
48847: GO 48898
// for i in tmp do
48849: LD_ADDR_VAR 0 4
48853: PUSH
48854: LD_VAR 0 5
48858: PUSH
48859: FOR_IN
48860: IFFALSE 48896
// if GetTech ( i , side ) <> state_researched then
48862: LD_VAR 0 4
48866: PPUSH
48867: LD_VAR 0 1
48871: PPUSH
48872: CALL_OW 321
48876: PUSH
48877: LD_INT 2
48879: NONEQUAL
48880: IFFALSE 48894
// begin result := false ;
48882: LD_ADDR_VAR 0 3
48886: PUSH
48887: LD_INT 0
48889: ST_TO_ADDR
// exit ;
48890: POP
48891: POP
48892: GO 48898
// end ;
48894: GO 48859
48896: POP
48897: POP
// end ;
48898: LD_VAR 0 3
48902: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
48903: LD_INT 0
48905: PPUSH
48906: PPUSH
48907: PPUSH
48908: PPUSH
48909: PPUSH
48910: PPUSH
48911: PPUSH
48912: PPUSH
48913: PPUSH
48914: PPUSH
48915: PPUSH
48916: PPUSH
48917: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
48918: LD_VAR 0 1
48922: NOT
48923: PUSH
48924: LD_VAR 0 1
48928: PPUSH
48929: CALL_OW 257
48933: PUSH
48934: LD_INT 9
48936: NONEQUAL
48937: OR
48938: IFFALSE 48942
// exit ;
48940: GO 49515
// side := GetSide ( unit ) ;
48942: LD_ADDR_VAR 0 9
48946: PUSH
48947: LD_VAR 0 1
48951: PPUSH
48952: CALL_OW 255
48956: ST_TO_ADDR
// tech_space := tech_spacanom ;
48957: LD_ADDR_VAR 0 12
48961: PUSH
48962: LD_INT 29
48964: ST_TO_ADDR
// tech_time := tech_taurad ;
48965: LD_ADDR_VAR 0 13
48969: PUSH
48970: LD_INT 28
48972: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
48973: LD_ADDR_VAR 0 11
48977: PUSH
48978: LD_VAR 0 1
48982: PPUSH
48983: CALL_OW 310
48987: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
48988: LD_VAR 0 11
48992: PPUSH
48993: CALL_OW 247
48997: PUSH
48998: LD_INT 2
49000: EQUAL
49001: IFFALSE 49005
// exit ;
49003: GO 49515
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49005: LD_ADDR_VAR 0 8
49009: PUSH
49010: LD_INT 81
49012: PUSH
49013: LD_VAR 0 9
49017: PUSH
49018: EMPTY
49019: LIST
49020: LIST
49021: PUSH
49022: LD_INT 3
49024: PUSH
49025: LD_INT 21
49027: PUSH
49028: LD_INT 3
49030: PUSH
49031: EMPTY
49032: LIST
49033: LIST
49034: PUSH
49035: EMPTY
49036: LIST
49037: LIST
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PPUSH
49043: CALL_OW 69
49047: ST_TO_ADDR
// if not tmp then
49048: LD_VAR 0 8
49052: NOT
49053: IFFALSE 49057
// exit ;
49055: GO 49515
// if in_unit then
49057: LD_VAR 0 11
49061: IFFALSE 49085
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49063: LD_ADDR_VAR 0 10
49067: PUSH
49068: LD_VAR 0 8
49072: PPUSH
49073: LD_VAR 0 11
49077: PPUSH
49078: CALL_OW 74
49082: ST_TO_ADDR
49083: GO 49105
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49085: LD_ADDR_VAR 0 10
49089: PUSH
49090: LD_VAR 0 8
49094: PPUSH
49095: LD_VAR 0 1
49099: PPUSH
49100: CALL_OW 74
49104: ST_TO_ADDR
// if not enemy then
49105: LD_VAR 0 10
49109: NOT
49110: IFFALSE 49114
// exit ;
49112: GO 49515
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49114: LD_VAR 0 11
49118: PUSH
49119: LD_VAR 0 11
49123: PPUSH
49124: LD_VAR 0 10
49128: PPUSH
49129: CALL_OW 296
49133: PUSH
49134: LD_INT 13
49136: GREATER
49137: AND
49138: PUSH
49139: LD_VAR 0 1
49143: PPUSH
49144: LD_VAR 0 10
49148: PPUSH
49149: CALL_OW 296
49153: PUSH
49154: LD_INT 12
49156: GREATER
49157: OR
49158: IFFALSE 49162
// exit ;
49160: GO 49515
// missile := [ 1 ] ;
49162: LD_ADDR_VAR 0 14
49166: PUSH
49167: LD_INT 1
49169: PUSH
49170: EMPTY
49171: LIST
49172: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49173: LD_VAR 0 9
49177: PPUSH
49178: LD_VAR 0 12
49182: PPUSH
49183: CALL_OW 325
49187: IFFALSE 49216
// missile := Insert ( missile , missile + 1 , 2 ) ;
49189: LD_ADDR_VAR 0 14
49193: PUSH
49194: LD_VAR 0 14
49198: PPUSH
49199: LD_VAR 0 14
49203: PUSH
49204: LD_INT 1
49206: PLUS
49207: PPUSH
49208: LD_INT 2
49210: PPUSH
49211: CALL_OW 2
49215: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49216: LD_VAR 0 9
49220: PPUSH
49221: LD_VAR 0 13
49225: PPUSH
49226: CALL_OW 325
49230: PUSH
49231: LD_VAR 0 10
49235: PPUSH
49236: CALL_OW 255
49240: PPUSH
49241: LD_VAR 0 13
49245: PPUSH
49246: CALL_OW 325
49250: NOT
49251: AND
49252: IFFALSE 49281
// missile := Insert ( missile , missile + 1 , 3 ) ;
49254: LD_ADDR_VAR 0 14
49258: PUSH
49259: LD_VAR 0 14
49263: PPUSH
49264: LD_VAR 0 14
49268: PUSH
49269: LD_INT 1
49271: PLUS
49272: PPUSH
49273: LD_INT 3
49275: PPUSH
49276: CALL_OW 2
49280: ST_TO_ADDR
// if missile < 2 then
49281: LD_VAR 0 14
49285: PUSH
49286: LD_INT 2
49288: LESS
49289: IFFALSE 49293
// exit ;
49291: GO 49515
// x := GetX ( enemy ) ;
49293: LD_ADDR_VAR 0 4
49297: PUSH
49298: LD_VAR 0 10
49302: PPUSH
49303: CALL_OW 250
49307: ST_TO_ADDR
// y := GetY ( enemy ) ;
49308: LD_ADDR_VAR 0 5
49312: PUSH
49313: LD_VAR 0 10
49317: PPUSH
49318: CALL_OW 251
49322: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
49323: LD_ADDR_VAR 0 6
49327: PUSH
49328: LD_VAR 0 4
49332: PUSH
49333: LD_INT 1
49335: NEG
49336: PPUSH
49337: LD_INT 1
49339: PPUSH
49340: CALL_OW 12
49344: PLUS
49345: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
49346: LD_ADDR_VAR 0 7
49350: PUSH
49351: LD_VAR 0 5
49355: PUSH
49356: LD_INT 1
49358: NEG
49359: PPUSH
49360: LD_INT 1
49362: PPUSH
49363: CALL_OW 12
49367: PLUS
49368: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49369: LD_VAR 0 6
49373: PPUSH
49374: LD_VAR 0 7
49378: PPUSH
49379: CALL_OW 488
49383: NOT
49384: IFFALSE 49406
// begin _x := x ;
49386: LD_ADDR_VAR 0 6
49390: PUSH
49391: LD_VAR 0 4
49395: ST_TO_ADDR
// _y := y ;
49396: LD_ADDR_VAR 0 7
49400: PUSH
49401: LD_VAR 0 5
49405: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
49406: LD_ADDR_VAR 0 3
49410: PUSH
49411: LD_INT 1
49413: PPUSH
49414: LD_VAR 0 14
49418: PPUSH
49419: CALL_OW 12
49423: ST_TO_ADDR
// case i of 1 :
49424: LD_VAR 0 3
49428: PUSH
49429: LD_INT 1
49431: DOUBLE
49432: EQUAL
49433: IFTRUE 49437
49435: GO 49454
49437: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
49438: LD_VAR 0 1
49442: PPUSH
49443: LD_VAR 0 10
49447: PPUSH
49448: CALL_OW 115
49452: GO 49515
49454: LD_INT 2
49456: DOUBLE
49457: EQUAL
49458: IFTRUE 49462
49460: GO 49484
49462: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
49463: LD_VAR 0 1
49467: PPUSH
49468: LD_VAR 0 6
49472: PPUSH
49473: LD_VAR 0 7
49477: PPUSH
49478: CALL_OW 153
49482: GO 49515
49484: LD_INT 3
49486: DOUBLE
49487: EQUAL
49488: IFTRUE 49492
49490: GO 49514
49492: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
49493: LD_VAR 0 1
49497: PPUSH
49498: LD_VAR 0 6
49502: PPUSH
49503: LD_VAR 0 7
49507: PPUSH
49508: CALL_OW 154
49512: GO 49515
49514: POP
// end ;
49515: LD_VAR 0 2
49519: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
49520: LD_INT 0
49522: PPUSH
49523: PPUSH
49524: PPUSH
49525: PPUSH
49526: PPUSH
49527: PPUSH
// if not unit or not building then
49528: LD_VAR 0 1
49532: NOT
49533: PUSH
49534: LD_VAR 0 2
49538: NOT
49539: OR
49540: IFFALSE 49544
// exit ;
49542: GO 49702
// x := GetX ( building ) ;
49544: LD_ADDR_VAR 0 5
49548: PUSH
49549: LD_VAR 0 2
49553: PPUSH
49554: CALL_OW 250
49558: ST_TO_ADDR
// y := GetY ( building ) ;
49559: LD_ADDR_VAR 0 6
49563: PUSH
49564: LD_VAR 0 2
49568: PPUSH
49569: CALL_OW 251
49573: ST_TO_ADDR
// for i = 0 to 5 do
49574: LD_ADDR_VAR 0 4
49578: PUSH
49579: DOUBLE
49580: LD_INT 0
49582: DEC
49583: ST_TO_ADDR
49584: LD_INT 5
49586: PUSH
49587: FOR_TO
49588: IFFALSE 49700
// begin _x := ShiftX ( x , i , 3 ) ;
49590: LD_ADDR_VAR 0 7
49594: PUSH
49595: LD_VAR 0 5
49599: PPUSH
49600: LD_VAR 0 4
49604: PPUSH
49605: LD_INT 3
49607: PPUSH
49608: CALL_OW 272
49612: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
49613: LD_ADDR_VAR 0 8
49617: PUSH
49618: LD_VAR 0 6
49622: PPUSH
49623: LD_VAR 0 4
49627: PPUSH
49628: LD_INT 3
49630: PPUSH
49631: CALL_OW 273
49635: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49636: LD_VAR 0 7
49640: PPUSH
49641: LD_VAR 0 8
49645: PPUSH
49646: CALL_OW 488
49650: NOT
49651: IFFALSE 49655
// continue ;
49653: GO 49587
// if HexInfo ( _x , _y ) = 0 then
49655: LD_VAR 0 7
49659: PPUSH
49660: LD_VAR 0 8
49664: PPUSH
49665: CALL_OW 428
49669: PUSH
49670: LD_INT 0
49672: EQUAL
49673: IFFALSE 49698
// begin ComMoveXY ( unit , _x , _y ) ;
49675: LD_VAR 0 1
49679: PPUSH
49680: LD_VAR 0 7
49684: PPUSH
49685: LD_VAR 0 8
49689: PPUSH
49690: CALL_OW 111
// exit ;
49694: POP
49695: POP
49696: GO 49702
// end ; end ;
49698: GO 49587
49700: POP
49701: POP
// end ;
49702: LD_VAR 0 3
49706: RET
// export function ScanBase ( side , base_area ) ; begin
49707: LD_INT 0
49709: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
49710: LD_ADDR_VAR 0 3
49714: PUSH
49715: LD_VAR 0 2
49719: PPUSH
49720: LD_INT 81
49722: PUSH
49723: LD_VAR 0 1
49727: PUSH
49728: EMPTY
49729: LIST
49730: LIST
49731: PPUSH
49732: CALL_OW 70
49736: ST_TO_ADDR
// end ;
49737: LD_VAR 0 3
49741: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
49742: LD_INT 0
49744: PPUSH
49745: PPUSH
49746: PPUSH
49747: PPUSH
// result := false ;
49748: LD_ADDR_VAR 0 2
49752: PUSH
49753: LD_INT 0
49755: ST_TO_ADDR
// side := GetSide ( unit ) ;
49756: LD_ADDR_VAR 0 3
49760: PUSH
49761: LD_VAR 0 1
49765: PPUSH
49766: CALL_OW 255
49770: ST_TO_ADDR
// nat := GetNation ( unit ) ;
49771: LD_ADDR_VAR 0 4
49775: PUSH
49776: LD_VAR 0 1
49780: PPUSH
49781: CALL_OW 248
49785: ST_TO_ADDR
// case nat of 1 :
49786: LD_VAR 0 4
49790: PUSH
49791: LD_INT 1
49793: DOUBLE
49794: EQUAL
49795: IFTRUE 49799
49797: GO 49810
49799: POP
// tech := tech_lassight ; 2 :
49800: LD_ADDR_VAR 0 5
49804: PUSH
49805: LD_INT 12
49807: ST_TO_ADDR
49808: GO 49849
49810: LD_INT 2
49812: DOUBLE
49813: EQUAL
49814: IFTRUE 49818
49816: GO 49829
49818: POP
// tech := tech_mortar ; 3 :
49819: LD_ADDR_VAR 0 5
49823: PUSH
49824: LD_INT 41
49826: ST_TO_ADDR
49827: GO 49849
49829: LD_INT 3
49831: DOUBLE
49832: EQUAL
49833: IFTRUE 49837
49835: GO 49848
49837: POP
// tech := tech_bazooka ; end ;
49838: LD_ADDR_VAR 0 5
49842: PUSH
49843: LD_INT 44
49845: ST_TO_ADDR
49846: GO 49849
49848: POP
// if Researched ( side , tech ) then
49849: LD_VAR 0 3
49853: PPUSH
49854: LD_VAR 0 5
49858: PPUSH
49859: CALL_OW 325
49863: IFFALSE 49890
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
49865: LD_ADDR_VAR 0 2
49869: PUSH
49870: LD_INT 5
49872: PUSH
49873: LD_INT 8
49875: PUSH
49876: LD_INT 9
49878: PUSH
49879: EMPTY
49880: LIST
49881: LIST
49882: LIST
49883: PUSH
49884: LD_VAR 0 4
49888: ARRAY
49889: ST_TO_ADDR
// end ;
49890: LD_VAR 0 2
49894: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
49895: LD_INT 0
49897: PPUSH
49898: PPUSH
49899: PPUSH
// if not mines then
49900: LD_VAR 0 2
49904: NOT
49905: IFFALSE 49909
// exit ;
49907: GO 50053
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49909: LD_ADDR_VAR 0 5
49913: PUSH
49914: LD_INT 81
49916: PUSH
49917: LD_VAR 0 1
49921: PUSH
49922: EMPTY
49923: LIST
49924: LIST
49925: PUSH
49926: LD_INT 3
49928: PUSH
49929: LD_INT 21
49931: PUSH
49932: LD_INT 3
49934: PUSH
49935: EMPTY
49936: LIST
49937: LIST
49938: PUSH
49939: EMPTY
49940: LIST
49941: LIST
49942: PUSH
49943: EMPTY
49944: LIST
49945: LIST
49946: PPUSH
49947: CALL_OW 69
49951: ST_TO_ADDR
// for i in mines do
49952: LD_ADDR_VAR 0 4
49956: PUSH
49957: LD_VAR 0 2
49961: PUSH
49962: FOR_IN
49963: IFFALSE 50051
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
49965: LD_VAR 0 4
49969: PUSH
49970: LD_INT 1
49972: ARRAY
49973: PPUSH
49974: LD_VAR 0 4
49978: PUSH
49979: LD_INT 2
49981: ARRAY
49982: PPUSH
49983: CALL_OW 458
49987: NOT
49988: IFFALSE 49992
// continue ;
49990: GO 49962
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
49992: LD_VAR 0 4
49996: PUSH
49997: LD_INT 1
49999: ARRAY
50000: PPUSH
50001: LD_VAR 0 4
50005: PUSH
50006: LD_INT 2
50008: ARRAY
50009: PPUSH
50010: CALL_OW 428
50014: PUSH
50015: LD_VAR 0 5
50019: IN
50020: IFFALSE 50049
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50022: LD_VAR 0 4
50026: PUSH
50027: LD_INT 1
50029: ARRAY
50030: PPUSH
50031: LD_VAR 0 4
50035: PUSH
50036: LD_INT 2
50038: ARRAY
50039: PPUSH
50040: LD_VAR 0 1
50044: PPUSH
50045: CALL_OW 456
// end ;
50049: GO 49962
50051: POP
50052: POP
// end ;
50053: LD_VAR 0 3
50057: RET
// export function Count ( array ) ; var i ; begin
50058: LD_INT 0
50060: PPUSH
50061: PPUSH
// result := 0 ;
50062: LD_ADDR_VAR 0 2
50066: PUSH
50067: LD_INT 0
50069: ST_TO_ADDR
// for i in array do
50070: LD_ADDR_VAR 0 3
50074: PUSH
50075: LD_VAR 0 1
50079: PUSH
50080: FOR_IN
50081: IFFALSE 50105
// if i then
50083: LD_VAR 0 3
50087: IFFALSE 50103
// result := result + 1 ;
50089: LD_ADDR_VAR 0 2
50093: PUSH
50094: LD_VAR 0 2
50098: PUSH
50099: LD_INT 1
50101: PLUS
50102: ST_TO_ADDR
50103: GO 50080
50105: POP
50106: POP
// end ;
50107: LD_VAR 0 2
50111: RET
// export function IsEmpty ( building ) ; begin
50112: LD_INT 0
50114: PPUSH
// if not building then
50115: LD_VAR 0 1
50119: NOT
50120: IFFALSE 50124
// exit ;
50122: GO 50167
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50124: LD_ADDR_VAR 0 2
50128: PUSH
50129: LD_VAR 0 1
50133: PUSH
50134: LD_INT 22
50136: PUSH
50137: LD_VAR 0 1
50141: PPUSH
50142: CALL_OW 255
50146: PUSH
50147: EMPTY
50148: LIST
50149: LIST
50150: PUSH
50151: LD_INT 58
50153: PUSH
50154: EMPTY
50155: LIST
50156: PUSH
50157: EMPTY
50158: LIST
50159: LIST
50160: PPUSH
50161: CALL_OW 69
50165: IN
50166: ST_TO_ADDR
// end ;
50167: LD_VAR 0 2
50171: RET
// export function IsNotFull ( building ) ; begin
50172: LD_INT 0
50174: PPUSH
// if not building then
50175: LD_VAR 0 1
50179: NOT
50180: IFFALSE 50184
// exit ;
50182: GO 50203
// result := UnitsInside ( building ) < 6 ;
50184: LD_ADDR_VAR 0 2
50188: PUSH
50189: LD_VAR 0 1
50193: PPUSH
50194: CALL_OW 313
50198: PUSH
50199: LD_INT 6
50201: LESS
50202: ST_TO_ADDR
// end ;
50203: LD_VAR 0 2
50207: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
50208: LD_INT 0
50210: PPUSH
50211: PPUSH
50212: PPUSH
50213: PPUSH
// tmp := [ ] ;
50214: LD_ADDR_VAR 0 3
50218: PUSH
50219: EMPTY
50220: ST_TO_ADDR
// list := [ ] ;
50221: LD_ADDR_VAR 0 5
50225: PUSH
50226: EMPTY
50227: ST_TO_ADDR
// for i = 16 to 25 do
50228: LD_ADDR_VAR 0 4
50232: PUSH
50233: DOUBLE
50234: LD_INT 16
50236: DEC
50237: ST_TO_ADDR
50238: LD_INT 25
50240: PUSH
50241: FOR_TO
50242: IFFALSE 50315
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
50244: LD_ADDR_VAR 0 3
50248: PUSH
50249: LD_VAR 0 3
50253: PUSH
50254: LD_INT 22
50256: PUSH
50257: LD_VAR 0 1
50261: PPUSH
50262: CALL_OW 255
50266: PUSH
50267: EMPTY
50268: LIST
50269: LIST
50270: PUSH
50271: LD_INT 91
50273: PUSH
50274: LD_VAR 0 1
50278: PUSH
50279: LD_INT 6
50281: PUSH
50282: EMPTY
50283: LIST
50284: LIST
50285: LIST
50286: PUSH
50287: LD_INT 30
50289: PUSH
50290: LD_VAR 0 4
50294: PUSH
50295: EMPTY
50296: LIST
50297: LIST
50298: PUSH
50299: EMPTY
50300: LIST
50301: LIST
50302: LIST
50303: PUSH
50304: EMPTY
50305: LIST
50306: PPUSH
50307: CALL_OW 69
50311: ADD
50312: ST_TO_ADDR
50313: GO 50241
50315: POP
50316: POP
// for i = 1 to tmp do
50317: LD_ADDR_VAR 0 4
50321: PUSH
50322: DOUBLE
50323: LD_INT 1
50325: DEC
50326: ST_TO_ADDR
50327: LD_VAR 0 3
50331: PUSH
50332: FOR_TO
50333: IFFALSE 50421
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
50335: LD_ADDR_VAR 0 5
50339: PUSH
50340: LD_VAR 0 5
50344: PUSH
50345: LD_VAR 0 3
50349: PUSH
50350: LD_VAR 0 4
50354: ARRAY
50355: PPUSH
50356: CALL_OW 266
50360: PUSH
50361: LD_VAR 0 3
50365: PUSH
50366: LD_VAR 0 4
50370: ARRAY
50371: PPUSH
50372: CALL_OW 250
50376: PUSH
50377: LD_VAR 0 3
50381: PUSH
50382: LD_VAR 0 4
50386: ARRAY
50387: PPUSH
50388: CALL_OW 251
50392: PUSH
50393: LD_VAR 0 3
50397: PUSH
50398: LD_VAR 0 4
50402: ARRAY
50403: PPUSH
50404: CALL_OW 254
50408: PUSH
50409: EMPTY
50410: LIST
50411: LIST
50412: LIST
50413: LIST
50414: PUSH
50415: EMPTY
50416: LIST
50417: ADD
50418: ST_TO_ADDR
50419: GO 50332
50421: POP
50422: POP
// result := list ;
50423: LD_ADDR_VAR 0 2
50427: PUSH
50428: LD_VAR 0 5
50432: ST_TO_ADDR
// end ;
50433: LD_VAR 0 2
50437: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
50438: LD_INT 0
50440: PPUSH
50441: PPUSH
50442: PPUSH
50443: PPUSH
50444: PPUSH
50445: PPUSH
50446: PPUSH
// if not factory then
50447: LD_VAR 0 1
50451: NOT
50452: IFFALSE 50456
// exit ;
50454: GO 51049
// if control = control_apeman then
50456: LD_VAR 0 4
50460: PUSH
50461: LD_INT 5
50463: EQUAL
50464: IFFALSE 50573
// begin tmp := UnitsInside ( factory ) ;
50466: LD_ADDR_VAR 0 8
50470: PUSH
50471: LD_VAR 0 1
50475: PPUSH
50476: CALL_OW 313
50480: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
50481: LD_VAR 0 8
50485: PPUSH
50486: LD_INT 25
50488: PUSH
50489: LD_INT 12
50491: PUSH
50492: EMPTY
50493: LIST
50494: LIST
50495: PPUSH
50496: CALL_OW 72
50500: NOT
50501: IFFALSE 50511
// control := control_manual ;
50503: LD_ADDR_VAR 0 4
50507: PUSH
50508: LD_INT 1
50510: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
50511: LD_ADDR_VAR 0 8
50515: PUSH
50516: LD_VAR 0 1
50520: PPUSH
50521: CALL 50208 0 1
50525: ST_TO_ADDR
// if tmp then
50526: LD_VAR 0 8
50530: IFFALSE 50573
// begin for i in tmp do
50532: LD_ADDR_VAR 0 7
50536: PUSH
50537: LD_VAR 0 8
50541: PUSH
50542: FOR_IN
50543: IFFALSE 50571
// if i [ 1 ] = b_ext_radio then
50545: LD_VAR 0 7
50549: PUSH
50550: LD_INT 1
50552: ARRAY
50553: PUSH
50554: LD_INT 22
50556: EQUAL
50557: IFFALSE 50569
// begin control := control_remote ;
50559: LD_ADDR_VAR 0 4
50563: PUSH
50564: LD_INT 2
50566: ST_TO_ADDR
// break ;
50567: GO 50571
// end ;
50569: GO 50542
50571: POP
50572: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50573: LD_VAR 0 1
50577: PPUSH
50578: LD_VAR 0 2
50582: PPUSH
50583: LD_VAR 0 3
50587: PPUSH
50588: LD_VAR 0 4
50592: PPUSH
50593: LD_VAR 0 5
50597: PPUSH
50598: CALL_OW 448
50602: IFFALSE 50637
// begin result := [ chassis , engine , control , weapon ] ;
50604: LD_ADDR_VAR 0 6
50608: PUSH
50609: LD_VAR 0 2
50613: PUSH
50614: LD_VAR 0 3
50618: PUSH
50619: LD_VAR 0 4
50623: PUSH
50624: LD_VAR 0 5
50628: PUSH
50629: EMPTY
50630: LIST
50631: LIST
50632: LIST
50633: LIST
50634: ST_TO_ADDR
// exit ;
50635: GO 51049
// end ; _chassis := AvailableChassisList ( factory ) ;
50637: LD_ADDR_VAR 0 9
50641: PUSH
50642: LD_VAR 0 1
50646: PPUSH
50647: CALL_OW 475
50651: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
50652: LD_ADDR_VAR 0 11
50656: PUSH
50657: LD_VAR 0 1
50661: PPUSH
50662: CALL_OW 476
50666: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
50667: LD_ADDR_VAR 0 12
50671: PUSH
50672: LD_VAR 0 1
50676: PPUSH
50677: CALL_OW 477
50681: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
50682: LD_ADDR_VAR 0 10
50686: PUSH
50687: LD_VAR 0 1
50691: PPUSH
50692: CALL_OW 478
50696: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
50697: LD_VAR 0 9
50701: NOT
50702: PUSH
50703: LD_VAR 0 11
50707: NOT
50708: OR
50709: PUSH
50710: LD_VAR 0 12
50714: NOT
50715: OR
50716: PUSH
50717: LD_VAR 0 10
50721: NOT
50722: OR
50723: IFFALSE 50758
// begin result := [ chassis , engine , control , weapon ] ;
50725: LD_ADDR_VAR 0 6
50729: PUSH
50730: LD_VAR 0 2
50734: PUSH
50735: LD_VAR 0 3
50739: PUSH
50740: LD_VAR 0 4
50744: PUSH
50745: LD_VAR 0 5
50749: PUSH
50750: EMPTY
50751: LIST
50752: LIST
50753: LIST
50754: LIST
50755: ST_TO_ADDR
// exit ;
50756: GO 51049
// end ; if not chassis in _chassis then
50758: LD_VAR 0 2
50762: PUSH
50763: LD_VAR 0 9
50767: IN
50768: NOT
50769: IFFALSE 50795
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
50771: LD_ADDR_VAR 0 2
50775: PUSH
50776: LD_VAR 0 9
50780: PUSH
50781: LD_INT 1
50783: PPUSH
50784: LD_VAR 0 9
50788: PPUSH
50789: CALL_OW 12
50793: ARRAY
50794: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
50795: LD_VAR 0 2
50799: PPUSH
50800: LD_VAR 0 3
50804: PPUSH
50805: CALL 51054 0 2
50809: NOT
50810: IFFALSE 50869
// repeat engine := _engine [ 1 ] ;
50812: LD_ADDR_VAR 0 3
50816: PUSH
50817: LD_VAR 0 11
50821: PUSH
50822: LD_INT 1
50824: ARRAY
50825: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
50826: LD_ADDR_VAR 0 11
50830: PUSH
50831: LD_VAR 0 11
50835: PPUSH
50836: LD_INT 1
50838: PPUSH
50839: CALL_OW 3
50843: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
50844: LD_VAR 0 2
50848: PPUSH
50849: LD_VAR 0 3
50853: PPUSH
50854: CALL 51054 0 2
50858: PUSH
50859: LD_VAR 0 11
50863: PUSH
50864: EMPTY
50865: EQUAL
50866: OR
50867: IFFALSE 50812
// if not control in _control then
50869: LD_VAR 0 4
50873: PUSH
50874: LD_VAR 0 12
50878: IN
50879: NOT
50880: IFFALSE 50906
// control := _control [ rand ( 1 , _control ) ] ;
50882: LD_ADDR_VAR 0 4
50886: PUSH
50887: LD_VAR 0 12
50891: PUSH
50892: LD_INT 1
50894: PPUSH
50895: LD_VAR 0 12
50899: PPUSH
50900: CALL_OW 12
50904: ARRAY
50905: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
50906: LD_VAR 0 2
50910: PPUSH
50911: LD_VAR 0 5
50915: PPUSH
50916: CALL 51274 0 2
50920: NOT
50921: IFFALSE 50980
// repeat weapon := _weapon [ 1 ] ;
50923: LD_ADDR_VAR 0 5
50927: PUSH
50928: LD_VAR 0 10
50932: PUSH
50933: LD_INT 1
50935: ARRAY
50936: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
50937: LD_ADDR_VAR 0 10
50941: PUSH
50942: LD_VAR 0 10
50946: PPUSH
50947: LD_INT 1
50949: PPUSH
50950: CALL_OW 3
50954: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
50955: LD_VAR 0 2
50959: PPUSH
50960: LD_VAR 0 5
50964: PPUSH
50965: CALL 51274 0 2
50969: PUSH
50970: LD_VAR 0 10
50974: PUSH
50975: EMPTY
50976: EQUAL
50977: OR
50978: IFFALSE 50923
// result := [ ] ;
50980: LD_ADDR_VAR 0 6
50984: PUSH
50985: EMPTY
50986: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50987: LD_VAR 0 1
50991: PPUSH
50992: LD_VAR 0 2
50996: PPUSH
50997: LD_VAR 0 3
51001: PPUSH
51002: LD_VAR 0 4
51006: PPUSH
51007: LD_VAR 0 5
51011: PPUSH
51012: CALL_OW 448
51016: IFFALSE 51049
// result := [ chassis , engine , control , weapon ] ;
51018: LD_ADDR_VAR 0 6
51022: PUSH
51023: LD_VAR 0 2
51027: PUSH
51028: LD_VAR 0 3
51032: PUSH
51033: LD_VAR 0 4
51037: PUSH
51038: LD_VAR 0 5
51042: PUSH
51043: EMPTY
51044: LIST
51045: LIST
51046: LIST
51047: LIST
51048: ST_TO_ADDR
// end ;
51049: LD_VAR 0 6
51053: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51054: LD_INT 0
51056: PPUSH
// if not chassis or not engine then
51057: LD_VAR 0 1
51061: NOT
51062: PUSH
51063: LD_VAR 0 2
51067: NOT
51068: OR
51069: IFFALSE 51073
// exit ;
51071: GO 51269
// case engine of engine_solar :
51073: LD_VAR 0 2
51077: PUSH
51078: LD_INT 2
51080: DOUBLE
51081: EQUAL
51082: IFTRUE 51086
51084: GO 51124
51086: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51087: LD_ADDR_VAR 0 3
51091: PUSH
51092: LD_INT 11
51094: PUSH
51095: LD_INT 12
51097: PUSH
51098: LD_INT 13
51100: PUSH
51101: LD_INT 14
51103: PUSH
51104: LD_INT 1
51106: PUSH
51107: LD_INT 2
51109: PUSH
51110: LD_INT 3
51112: PUSH
51113: EMPTY
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: LIST
51120: LIST
51121: ST_TO_ADDR
51122: GO 51253
51124: LD_INT 1
51126: DOUBLE
51127: EQUAL
51128: IFTRUE 51132
51130: GO 51194
51132: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51133: LD_ADDR_VAR 0 3
51137: PUSH
51138: LD_INT 11
51140: PUSH
51141: LD_INT 12
51143: PUSH
51144: LD_INT 13
51146: PUSH
51147: LD_INT 14
51149: PUSH
51150: LD_INT 1
51152: PUSH
51153: LD_INT 2
51155: PUSH
51156: LD_INT 3
51158: PUSH
51159: LD_INT 4
51161: PUSH
51162: LD_INT 5
51164: PUSH
51165: LD_INT 21
51167: PUSH
51168: LD_INT 23
51170: PUSH
51171: LD_INT 22
51173: PUSH
51174: LD_INT 24
51176: PUSH
51177: EMPTY
51178: LIST
51179: LIST
51180: LIST
51181: LIST
51182: LIST
51183: LIST
51184: LIST
51185: LIST
51186: LIST
51187: LIST
51188: LIST
51189: LIST
51190: LIST
51191: ST_TO_ADDR
51192: GO 51253
51194: LD_INT 3
51196: DOUBLE
51197: EQUAL
51198: IFTRUE 51202
51200: GO 51252
51202: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51203: LD_ADDR_VAR 0 3
51207: PUSH
51208: LD_INT 13
51210: PUSH
51211: LD_INT 14
51213: PUSH
51214: LD_INT 2
51216: PUSH
51217: LD_INT 3
51219: PUSH
51220: LD_INT 4
51222: PUSH
51223: LD_INT 5
51225: PUSH
51226: LD_INT 21
51228: PUSH
51229: LD_INT 22
51231: PUSH
51232: LD_INT 23
51234: PUSH
51235: LD_INT 24
51237: PUSH
51238: EMPTY
51239: LIST
51240: LIST
51241: LIST
51242: LIST
51243: LIST
51244: LIST
51245: LIST
51246: LIST
51247: LIST
51248: LIST
51249: ST_TO_ADDR
51250: GO 51253
51252: POP
// result := ( chassis in result ) ;
51253: LD_ADDR_VAR 0 3
51257: PUSH
51258: LD_VAR 0 1
51262: PUSH
51263: LD_VAR 0 3
51267: IN
51268: ST_TO_ADDR
// end ;
51269: LD_VAR 0 3
51273: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
51274: LD_INT 0
51276: PPUSH
// if not chassis or not weapon then
51277: LD_VAR 0 1
51281: NOT
51282: PUSH
51283: LD_VAR 0 2
51287: NOT
51288: OR
51289: IFFALSE 51293
// exit ;
51291: GO 52319
// case weapon of us_machine_gun :
51293: LD_VAR 0 2
51297: PUSH
51298: LD_INT 2
51300: DOUBLE
51301: EQUAL
51302: IFTRUE 51306
51304: GO 51336
51306: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
51307: LD_ADDR_VAR 0 3
51311: PUSH
51312: LD_INT 1
51314: PUSH
51315: LD_INT 2
51317: PUSH
51318: LD_INT 3
51320: PUSH
51321: LD_INT 4
51323: PUSH
51324: LD_INT 5
51326: PUSH
51327: EMPTY
51328: LIST
51329: LIST
51330: LIST
51331: LIST
51332: LIST
51333: ST_TO_ADDR
51334: GO 52303
51336: LD_INT 3
51338: DOUBLE
51339: EQUAL
51340: IFTRUE 51344
51342: GO 51374
51344: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
51345: LD_ADDR_VAR 0 3
51349: PUSH
51350: LD_INT 1
51352: PUSH
51353: LD_INT 2
51355: PUSH
51356: LD_INT 3
51358: PUSH
51359: LD_INT 4
51361: PUSH
51362: LD_INT 5
51364: PUSH
51365: EMPTY
51366: LIST
51367: LIST
51368: LIST
51369: LIST
51370: LIST
51371: ST_TO_ADDR
51372: GO 52303
51374: LD_INT 11
51376: DOUBLE
51377: EQUAL
51378: IFTRUE 51382
51380: GO 51412
51382: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
51383: LD_ADDR_VAR 0 3
51387: PUSH
51388: LD_INT 1
51390: PUSH
51391: LD_INT 2
51393: PUSH
51394: LD_INT 3
51396: PUSH
51397: LD_INT 4
51399: PUSH
51400: LD_INT 5
51402: PUSH
51403: EMPTY
51404: LIST
51405: LIST
51406: LIST
51407: LIST
51408: LIST
51409: ST_TO_ADDR
51410: GO 52303
51412: LD_INT 4
51414: DOUBLE
51415: EQUAL
51416: IFTRUE 51420
51418: GO 51446
51420: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
51421: LD_ADDR_VAR 0 3
51425: PUSH
51426: LD_INT 2
51428: PUSH
51429: LD_INT 3
51431: PUSH
51432: LD_INT 4
51434: PUSH
51435: LD_INT 5
51437: PUSH
51438: EMPTY
51439: LIST
51440: LIST
51441: LIST
51442: LIST
51443: ST_TO_ADDR
51444: GO 52303
51446: LD_INT 5
51448: DOUBLE
51449: EQUAL
51450: IFTRUE 51454
51452: GO 51480
51454: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
51455: LD_ADDR_VAR 0 3
51459: PUSH
51460: LD_INT 2
51462: PUSH
51463: LD_INT 3
51465: PUSH
51466: LD_INT 4
51468: PUSH
51469: LD_INT 5
51471: PUSH
51472: EMPTY
51473: LIST
51474: LIST
51475: LIST
51476: LIST
51477: ST_TO_ADDR
51478: GO 52303
51480: LD_INT 9
51482: DOUBLE
51483: EQUAL
51484: IFTRUE 51488
51486: GO 51514
51488: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
51489: LD_ADDR_VAR 0 3
51493: PUSH
51494: LD_INT 2
51496: PUSH
51497: LD_INT 3
51499: PUSH
51500: LD_INT 4
51502: PUSH
51503: LD_INT 5
51505: PUSH
51506: EMPTY
51507: LIST
51508: LIST
51509: LIST
51510: LIST
51511: ST_TO_ADDR
51512: GO 52303
51514: LD_INT 7
51516: DOUBLE
51517: EQUAL
51518: IFTRUE 51522
51520: GO 51548
51522: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
51523: LD_ADDR_VAR 0 3
51527: PUSH
51528: LD_INT 2
51530: PUSH
51531: LD_INT 3
51533: PUSH
51534: LD_INT 4
51536: PUSH
51537: LD_INT 5
51539: PUSH
51540: EMPTY
51541: LIST
51542: LIST
51543: LIST
51544: LIST
51545: ST_TO_ADDR
51546: GO 52303
51548: LD_INT 12
51550: DOUBLE
51551: EQUAL
51552: IFTRUE 51556
51554: GO 51582
51556: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
51557: LD_ADDR_VAR 0 3
51561: PUSH
51562: LD_INT 2
51564: PUSH
51565: LD_INT 3
51567: PUSH
51568: LD_INT 4
51570: PUSH
51571: LD_INT 5
51573: PUSH
51574: EMPTY
51575: LIST
51576: LIST
51577: LIST
51578: LIST
51579: ST_TO_ADDR
51580: GO 52303
51582: LD_INT 13
51584: DOUBLE
51585: EQUAL
51586: IFTRUE 51590
51588: GO 51616
51590: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
51591: LD_ADDR_VAR 0 3
51595: PUSH
51596: LD_INT 2
51598: PUSH
51599: LD_INT 3
51601: PUSH
51602: LD_INT 4
51604: PUSH
51605: LD_INT 5
51607: PUSH
51608: EMPTY
51609: LIST
51610: LIST
51611: LIST
51612: LIST
51613: ST_TO_ADDR
51614: GO 52303
51616: LD_INT 14
51618: DOUBLE
51619: EQUAL
51620: IFTRUE 51624
51622: GO 51642
51624: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
51625: LD_ADDR_VAR 0 3
51629: PUSH
51630: LD_INT 4
51632: PUSH
51633: LD_INT 5
51635: PUSH
51636: EMPTY
51637: LIST
51638: LIST
51639: ST_TO_ADDR
51640: GO 52303
51642: LD_INT 6
51644: DOUBLE
51645: EQUAL
51646: IFTRUE 51650
51648: GO 51668
51650: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
51651: LD_ADDR_VAR 0 3
51655: PUSH
51656: LD_INT 4
51658: PUSH
51659: LD_INT 5
51661: PUSH
51662: EMPTY
51663: LIST
51664: LIST
51665: ST_TO_ADDR
51666: GO 52303
51668: LD_INT 10
51670: DOUBLE
51671: EQUAL
51672: IFTRUE 51676
51674: GO 51694
51676: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
51677: LD_ADDR_VAR 0 3
51681: PUSH
51682: LD_INT 4
51684: PUSH
51685: LD_INT 5
51687: PUSH
51688: EMPTY
51689: LIST
51690: LIST
51691: ST_TO_ADDR
51692: GO 52303
51694: LD_INT 22
51696: DOUBLE
51697: EQUAL
51698: IFTRUE 51702
51700: GO 51728
51702: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
51703: LD_ADDR_VAR 0 3
51707: PUSH
51708: LD_INT 11
51710: PUSH
51711: LD_INT 12
51713: PUSH
51714: LD_INT 13
51716: PUSH
51717: LD_INT 14
51719: PUSH
51720: EMPTY
51721: LIST
51722: LIST
51723: LIST
51724: LIST
51725: ST_TO_ADDR
51726: GO 52303
51728: LD_INT 23
51730: DOUBLE
51731: EQUAL
51732: IFTRUE 51736
51734: GO 51762
51736: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
51737: LD_ADDR_VAR 0 3
51741: PUSH
51742: LD_INT 11
51744: PUSH
51745: LD_INT 12
51747: PUSH
51748: LD_INT 13
51750: PUSH
51751: LD_INT 14
51753: PUSH
51754: EMPTY
51755: LIST
51756: LIST
51757: LIST
51758: LIST
51759: ST_TO_ADDR
51760: GO 52303
51762: LD_INT 24
51764: DOUBLE
51765: EQUAL
51766: IFTRUE 51770
51768: GO 51796
51770: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
51771: LD_ADDR_VAR 0 3
51775: PUSH
51776: LD_INT 11
51778: PUSH
51779: LD_INT 12
51781: PUSH
51782: LD_INT 13
51784: PUSH
51785: LD_INT 14
51787: PUSH
51788: EMPTY
51789: LIST
51790: LIST
51791: LIST
51792: LIST
51793: ST_TO_ADDR
51794: GO 52303
51796: LD_INT 30
51798: DOUBLE
51799: EQUAL
51800: IFTRUE 51804
51802: GO 51830
51804: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
51805: LD_ADDR_VAR 0 3
51809: PUSH
51810: LD_INT 11
51812: PUSH
51813: LD_INT 12
51815: PUSH
51816: LD_INT 13
51818: PUSH
51819: LD_INT 14
51821: PUSH
51822: EMPTY
51823: LIST
51824: LIST
51825: LIST
51826: LIST
51827: ST_TO_ADDR
51828: GO 52303
51830: LD_INT 25
51832: DOUBLE
51833: EQUAL
51834: IFTRUE 51838
51836: GO 51856
51838: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
51839: LD_ADDR_VAR 0 3
51843: PUSH
51844: LD_INT 13
51846: PUSH
51847: LD_INT 14
51849: PUSH
51850: EMPTY
51851: LIST
51852: LIST
51853: ST_TO_ADDR
51854: GO 52303
51856: LD_INT 27
51858: DOUBLE
51859: EQUAL
51860: IFTRUE 51864
51862: GO 51882
51864: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
51865: LD_ADDR_VAR 0 3
51869: PUSH
51870: LD_INT 13
51872: PUSH
51873: LD_INT 14
51875: PUSH
51876: EMPTY
51877: LIST
51878: LIST
51879: ST_TO_ADDR
51880: GO 52303
51882: LD_INT 28
51884: DOUBLE
51885: EQUAL
51886: IFTRUE 51890
51888: GO 51908
51890: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
51891: LD_ADDR_VAR 0 3
51895: PUSH
51896: LD_INT 13
51898: PUSH
51899: LD_INT 14
51901: PUSH
51902: EMPTY
51903: LIST
51904: LIST
51905: ST_TO_ADDR
51906: GO 52303
51908: LD_INT 29
51910: DOUBLE
51911: EQUAL
51912: IFTRUE 51916
51914: GO 51934
51916: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
51917: LD_ADDR_VAR 0 3
51921: PUSH
51922: LD_INT 13
51924: PUSH
51925: LD_INT 14
51927: PUSH
51928: EMPTY
51929: LIST
51930: LIST
51931: ST_TO_ADDR
51932: GO 52303
51934: LD_INT 31
51936: DOUBLE
51937: EQUAL
51938: IFTRUE 51942
51940: GO 51960
51942: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
51943: LD_ADDR_VAR 0 3
51947: PUSH
51948: LD_INT 13
51950: PUSH
51951: LD_INT 14
51953: PUSH
51954: EMPTY
51955: LIST
51956: LIST
51957: ST_TO_ADDR
51958: GO 52303
51960: LD_INT 26
51962: DOUBLE
51963: EQUAL
51964: IFTRUE 51968
51966: GO 51986
51968: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
51969: LD_ADDR_VAR 0 3
51973: PUSH
51974: LD_INT 13
51976: PUSH
51977: LD_INT 14
51979: PUSH
51980: EMPTY
51981: LIST
51982: LIST
51983: ST_TO_ADDR
51984: GO 52303
51986: LD_INT 42
51988: DOUBLE
51989: EQUAL
51990: IFTRUE 51994
51992: GO 52020
51994: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
51995: LD_ADDR_VAR 0 3
51999: PUSH
52000: LD_INT 21
52002: PUSH
52003: LD_INT 22
52005: PUSH
52006: LD_INT 23
52008: PUSH
52009: LD_INT 24
52011: PUSH
52012: EMPTY
52013: LIST
52014: LIST
52015: LIST
52016: LIST
52017: ST_TO_ADDR
52018: GO 52303
52020: LD_INT 43
52022: DOUBLE
52023: EQUAL
52024: IFTRUE 52028
52026: GO 52054
52028: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52029: LD_ADDR_VAR 0 3
52033: PUSH
52034: LD_INT 21
52036: PUSH
52037: LD_INT 22
52039: PUSH
52040: LD_INT 23
52042: PUSH
52043: LD_INT 24
52045: PUSH
52046: EMPTY
52047: LIST
52048: LIST
52049: LIST
52050: LIST
52051: ST_TO_ADDR
52052: GO 52303
52054: LD_INT 44
52056: DOUBLE
52057: EQUAL
52058: IFTRUE 52062
52060: GO 52088
52062: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52063: LD_ADDR_VAR 0 3
52067: PUSH
52068: LD_INT 21
52070: PUSH
52071: LD_INT 22
52073: PUSH
52074: LD_INT 23
52076: PUSH
52077: LD_INT 24
52079: PUSH
52080: EMPTY
52081: LIST
52082: LIST
52083: LIST
52084: LIST
52085: ST_TO_ADDR
52086: GO 52303
52088: LD_INT 45
52090: DOUBLE
52091: EQUAL
52092: IFTRUE 52096
52094: GO 52122
52096: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52097: LD_ADDR_VAR 0 3
52101: PUSH
52102: LD_INT 21
52104: PUSH
52105: LD_INT 22
52107: PUSH
52108: LD_INT 23
52110: PUSH
52111: LD_INT 24
52113: PUSH
52114: EMPTY
52115: LIST
52116: LIST
52117: LIST
52118: LIST
52119: ST_TO_ADDR
52120: GO 52303
52122: LD_INT 49
52124: DOUBLE
52125: EQUAL
52126: IFTRUE 52130
52128: GO 52156
52130: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52131: LD_ADDR_VAR 0 3
52135: PUSH
52136: LD_INT 21
52138: PUSH
52139: LD_INT 22
52141: PUSH
52142: LD_INT 23
52144: PUSH
52145: LD_INT 24
52147: PUSH
52148: EMPTY
52149: LIST
52150: LIST
52151: LIST
52152: LIST
52153: ST_TO_ADDR
52154: GO 52303
52156: LD_INT 51
52158: DOUBLE
52159: EQUAL
52160: IFTRUE 52164
52162: GO 52190
52164: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52165: LD_ADDR_VAR 0 3
52169: PUSH
52170: LD_INT 21
52172: PUSH
52173: LD_INT 22
52175: PUSH
52176: LD_INT 23
52178: PUSH
52179: LD_INT 24
52181: PUSH
52182: EMPTY
52183: LIST
52184: LIST
52185: LIST
52186: LIST
52187: ST_TO_ADDR
52188: GO 52303
52190: LD_INT 52
52192: DOUBLE
52193: EQUAL
52194: IFTRUE 52198
52196: GO 52224
52198: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
52199: LD_ADDR_VAR 0 3
52203: PUSH
52204: LD_INT 21
52206: PUSH
52207: LD_INT 22
52209: PUSH
52210: LD_INT 23
52212: PUSH
52213: LD_INT 24
52215: PUSH
52216: EMPTY
52217: LIST
52218: LIST
52219: LIST
52220: LIST
52221: ST_TO_ADDR
52222: GO 52303
52224: LD_INT 53
52226: DOUBLE
52227: EQUAL
52228: IFTRUE 52232
52230: GO 52250
52232: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
52233: LD_ADDR_VAR 0 3
52237: PUSH
52238: LD_INT 23
52240: PUSH
52241: LD_INT 24
52243: PUSH
52244: EMPTY
52245: LIST
52246: LIST
52247: ST_TO_ADDR
52248: GO 52303
52250: LD_INT 46
52252: DOUBLE
52253: EQUAL
52254: IFTRUE 52258
52256: GO 52276
52258: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
52259: LD_ADDR_VAR 0 3
52263: PUSH
52264: LD_INT 23
52266: PUSH
52267: LD_INT 24
52269: PUSH
52270: EMPTY
52271: LIST
52272: LIST
52273: ST_TO_ADDR
52274: GO 52303
52276: LD_INT 47
52278: DOUBLE
52279: EQUAL
52280: IFTRUE 52284
52282: GO 52302
52284: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52285: LD_ADDR_VAR 0 3
52289: PUSH
52290: LD_INT 23
52292: PUSH
52293: LD_INT 24
52295: PUSH
52296: EMPTY
52297: LIST
52298: LIST
52299: ST_TO_ADDR
52300: GO 52303
52302: POP
// result := ( chassis in result ) ;
52303: LD_ADDR_VAR 0 3
52307: PUSH
52308: LD_VAR 0 1
52312: PUSH
52313: LD_VAR 0 3
52317: IN
52318: ST_TO_ADDR
// end ;
52319: LD_VAR 0 3
52323: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
52324: LD_INT 0
52326: PPUSH
52327: PPUSH
52328: PPUSH
52329: PPUSH
52330: PPUSH
52331: PPUSH
52332: PPUSH
// result := array ;
52333: LD_ADDR_VAR 0 5
52337: PUSH
52338: LD_VAR 0 1
52342: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
52343: LD_VAR 0 1
52347: NOT
52348: PUSH
52349: LD_VAR 0 2
52353: NOT
52354: OR
52355: PUSH
52356: LD_VAR 0 3
52360: NOT
52361: OR
52362: PUSH
52363: LD_VAR 0 2
52367: PUSH
52368: LD_VAR 0 1
52372: GREATER
52373: OR
52374: PUSH
52375: LD_VAR 0 3
52379: PUSH
52380: LD_VAR 0 1
52384: GREATER
52385: OR
52386: IFFALSE 52390
// exit ;
52388: GO 52686
// if direction then
52390: LD_VAR 0 4
52394: IFFALSE 52458
// begin d := 1 ;
52396: LD_ADDR_VAR 0 9
52400: PUSH
52401: LD_INT 1
52403: ST_TO_ADDR
// if i_from > i_to then
52404: LD_VAR 0 2
52408: PUSH
52409: LD_VAR 0 3
52413: GREATER
52414: IFFALSE 52440
// length := ( array - i_from ) + i_to else
52416: LD_ADDR_VAR 0 11
52420: PUSH
52421: LD_VAR 0 1
52425: PUSH
52426: LD_VAR 0 2
52430: MINUS
52431: PUSH
52432: LD_VAR 0 3
52436: PLUS
52437: ST_TO_ADDR
52438: GO 52456
// length := i_to - i_from ;
52440: LD_ADDR_VAR 0 11
52444: PUSH
52445: LD_VAR 0 3
52449: PUSH
52450: LD_VAR 0 2
52454: MINUS
52455: ST_TO_ADDR
// end else
52456: GO 52519
// begin d := - 1 ;
52458: LD_ADDR_VAR 0 9
52462: PUSH
52463: LD_INT 1
52465: NEG
52466: ST_TO_ADDR
// if i_from > i_to then
52467: LD_VAR 0 2
52471: PUSH
52472: LD_VAR 0 3
52476: GREATER
52477: IFFALSE 52497
// length := i_from - i_to else
52479: LD_ADDR_VAR 0 11
52483: PUSH
52484: LD_VAR 0 2
52488: PUSH
52489: LD_VAR 0 3
52493: MINUS
52494: ST_TO_ADDR
52495: GO 52519
// length := ( array - i_to ) + i_from ;
52497: LD_ADDR_VAR 0 11
52501: PUSH
52502: LD_VAR 0 1
52506: PUSH
52507: LD_VAR 0 3
52511: MINUS
52512: PUSH
52513: LD_VAR 0 2
52517: PLUS
52518: ST_TO_ADDR
// end ; if not length then
52519: LD_VAR 0 11
52523: NOT
52524: IFFALSE 52528
// exit ;
52526: GO 52686
// tmp := array ;
52528: LD_ADDR_VAR 0 10
52532: PUSH
52533: LD_VAR 0 1
52537: ST_TO_ADDR
// for i = 1 to length do
52538: LD_ADDR_VAR 0 6
52542: PUSH
52543: DOUBLE
52544: LD_INT 1
52546: DEC
52547: ST_TO_ADDR
52548: LD_VAR 0 11
52552: PUSH
52553: FOR_TO
52554: IFFALSE 52674
// begin for j = 1 to array do
52556: LD_ADDR_VAR 0 7
52560: PUSH
52561: DOUBLE
52562: LD_INT 1
52564: DEC
52565: ST_TO_ADDR
52566: LD_VAR 0 1
52570: PUSH
52571: FOR_TO
52572: IFFALSE 52660
// begin k := j + d ;
52574: LD_ADDR_VAR 0 8
52578: PUSH
52579: LD_VAR 0 7
52583: PUSH
52584: LD_VAR 0 9
52588: PLUS
52589: ST_TO_ADDR
// if k > array then
52590: LD_VAR 0 8
52594: PUSH
52595: LD_VAR 0 1
52599: GREATER
52600: IFFALSE 52610
// k := 1 ;
52602: LD_ADDR_VAR 0 8
52606: PUSH
52607: LD_INT 1
52609: ST_TO_ADDR
// if not k then
52610: LD_VAR 0 8
52614: NOT
52615: IFFALSE 52627
// k := array ;
52617: LD_ADDR_VAR 0 8
52621: PUSH
52622: LD_VAR 0 1
52626: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
52627: LD_ADDR_VAR 0 10
52631: PUSH
52632: LD_VAR 0 10
52636: PPUSH
52637: LD_VAR 0 8
52641: PPUSH
52642: LD_VAR 0 1
52646: PUSH
52647: LD_VAR 0 7
52651: ARRAY
52652: PPUSH
52653: CALL_OW 1
52657: ST_TO_ADDR
// end ;
52658: GO 52571
52660: POP
52661: POP
// array := tmp ;
52662: LD_ADDR_VAR 0 1
52666: PUSH
52667: LD_VAR 0 10
52671: ST_TO_ADDR
// end ;
52672: GO 52553
52674: POP
52675: POP
// result := array ;
52676: LD_ADDR_VAR 0 5
52680: PUSH
52681: LD_VAR 0 1
52685: ST_TO_ADDR
// end ;
52686: LD_VAR 0 5
52690: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
52691: LD_INT 0
52693: PPUSH
52694: PPUSH
// result := 0 ;
52695: LD_ADDR_VAR 0 3
52699: PUSH
52700: LD_INT 0
52702: ST_TO_ADDR
// if not array or not value in array then
52703: LD_VAR 0 1
52707: NOT
52708: PUSH
52709: LD_VAR 0 2
52713: PUSH
52714: LD_VAR 0 1
52718: IN
52719: NOT
52720: OR
52721: IFFALSE 52725
// exit ;
52723: GO 52779
// for i = 1 to array do
52725: LD_ADDR_VAR 0 4
52729: PUSH
52730: DOUBLE
52731: LD_INT 1
52733: DEC
52734: ST_TO_ADDR
52735: LD_VAR 0 1
52739: PUSH
52740: FOR_TO
52741: IFFALSE 52777
// if value = array [ i ] then
52743: LD_VAR 0 2
52747: PUSH
52748: LD_VAR 0 1
52752: PUSH
52753: LD_VAR 0 4
52757: ARRAY
52758: EQUAL
52759: IFFALSE 52775
// begin result := i ;
52761: LD_ADDR_VAR 0 3
52765: PUSH
52766: LD_VAR 0 4
52770: ST_TO_ADDR
// exit ;
52771: POP
52772: POP
52773: GO 52779
// end ;
52775: GO 52740
52777: POP
52778: POP
// end ;
52779: LD_VAR 0 3
52783: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
52784: LD_INT 0
52786: PPUSH
// vc_chassis := chassis ;
52787: LD_ADDR_OWVAR 37
52791: PUSH
52792: LD_VAR 0 1
52796: ST_TO_ADDR
// vc_engine := engine ;
52797: LD_ADDR_OWVAR 39
52801: PUSH
52802: LD_VAR 0 2
52806: ST_TO_ADDR
// vc_control := control ;
52807: LD_ADDR_OWVAR 38
52811: PUSH
52812: LD_VAR 0 3
52816: ST_TO_ADDR
// vc_weapon := weapon ;
52817: LD_ADDR_OWVAR 40
52821: PUSH
52822: LD_VAR 0 4
52826: ST_TO_ADDR
// vc_fuel_battery := fuel ;
52827: LD_ADDR_OWVAR 41
52831: PUSH
52832: LD_VAR 0 5
52836: ST_TO_ADDR
// end ;
52837: LD_VAR 0 6
52841: RET
// export function WantPlant ( unit ) ; var task ; begin
52842: LD_INT 0
52844: PPUSH
52845: PPUSH
// result := false ;
52846: LD_ADDR_VAR 0 2
52850: PUSH
52851: LD_INT 0
52853: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
52854: LD_ADDR_VAR 0 3
52858: PUSH
52859: LD_VAR 0 1
52863: PPUSH
52864: CALL_OW 437
52868: ST_TO_ADDR
// if task then
52869: LD_VAR 0 3
52873: IFFALSE 52901
// if task [ 1 ] [ 1 ] = p then
52875: LD_VAR 0 3
52879: PUSH
52880: LD_INT 1
52882: ARRAY
52883: PUSH
52884: LD_INT 1
52886: ARRAY
52887: PUSH
52888: LD_STRING p
52890: EQUAL
52891: IFFALSE 52901
// result := true ;
52893: LD_ADDR_VAR 0 2
52897: PUSH
52898: LD_INT 1
52900: ST_TO_ADDR
// end ;
52901: LD_VAR 0 2
52905: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
52906: LD_INT 0
52908: PPUSH
52909: PPUSH
52910: PPUSH
52911: PPUSH
// if pos < 1 then
52912: LD_VAR 0 2
52916: PUSH
52917: LD_INT 1
52919: LESS
52920: IFFALSE 52924
// exit ;
52922: GO 53227
// if pos = 1 then
52924: LD_VAR 0 2
52928: PUSH
52929: LD_INT 1
52931: EQUAL
52932: IFFALSE 52965
// result := Replace ( arr , pos [ 1 ] , value ) else
52934: LD_ADDR_VAR 0 4
52938: PUSH
52939: LD_VAR 0 1
52943: PPUSH
52944: LD_VAR 0 2
52948: PUSH
52949: LD_INT 1
52951: ARRAY
52952: PPUSH
52953: LD_VAR 0 3
52957: PPUSH
52958: CALL_OW 1
52962: ST_TO_ADDR
52963: GO 53227
// begin tmp := arr ;
52965: LD_ADDR_VAR 0 6
52969: PUSH
52970: LD_VAR 0 1
52974: ST_TO_ADDR
// s_arr := [ tmp ] ;
52975: LD_ADDR_VAR 0 7
52979: PUSH
52980: LD_VAR 0 6
52984: PUSH
52985: EMPTY
52986: LIST
52987: ST_TO_ADDR
// for i = 1 to pos - 1 do
52988: LD_ADDR_VAR 0 5
52992: PUSH
52993: DOUBLE
52994: LD_INT 1
52996: DEC
52997: ST_TO_ADDR
52998: LD_VAR 0 2
53002: PUSH
53003: LD_INT 1
53005: MINUS
53006: PUSH
53007: FOR_TO
53008: IFFALSE 53053
// begin tmp := tmp [ pos [ i ] ] ;
53010: LD_ADDR_VAR 0 6
53014: PUSH
53015: LD_VAR 0 6
53019: PUSH
53020: LD_VAR 0 2
53024: PUSH
53025: LD_VAR 0 5
53029: ARRAY
53030: ARRAY
53031: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53032: LD_ADDR_VAR 0 7
53036: PUSH
53037: LD_VAR 0 7
53041: PUSH
53042: LD_VAR 0 6
53046: PUSH
53047: EMPTY
53048: LIST
53049: ADD
53050: ST_TO_ADDR
// end ;
53051: GO 53007
53053: POP
53054: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53055: LD_ADDR_VAR 0 6
53059: PUSH
53060: LD_VAR 0 6
53064: PPUSH
53065: LD_VAR 0 2
53069: PUSH
53070: LD_VAR 0 2
53074: ARRAY
53075: PPUSH
53076: LD_VAR 0 3
53080: PPUSH
53081: CALL_OW 1
53085: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53086: LD_ADDR_VAR 0 7
53090: PUSH
53091: LD_VAR 0 7
53095: PPUSH
53096: LD_VAR 0 7
53100: PPUSH
53101: LD_VAR 0 6
53105: PPUSH
53106: CALL_OW 1
53110: ST_TO_ADDR
// for i = s_arr downto 2 do
53111: LD_ADDR_VAR 0 5
53115: PUSH
53116: DOUBLE
53117: LD_VAR 0 7
53121: INC
53122: ST_TO_ADDR
53123: LD_INT 2
53125: PUSH
53126: FOR_DOWNTO
53127: IFFALSE 53211
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53129: LD_ADDR_VAR 0 6
53133: PUSH
53134: LD_VAR 0 7
53138: PUSH
53139: LD_VAR 0 5
53143: PUSH
53144: LD_INT 1
53146: MINUS
53147: ARRAY
53148: PPUSH
53149: LD_VAR 0 2
53153: PUSH
53154: LD_VAR 0 5
53158: PUSH
53159: LD_INT 1
53161: MINUS
53162: ARRAY
53163: PPUSH
53164: LD_VAR 0 7
53168: PUSH
53169: LD_VAR 0 5
53173: ARRAY
53174: PPUSH
53175: CALL_OW 1
53179: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53180: LD_ADDR_VAR 0 7
53184: PUSH
53185: LD_VAR 0 7
53189: PPUSH
53190: LD_VAR 0 5
53194: PUSH
53195: LD_INT 1
53197: MINUS
53198: PPUSH
53199: LD_VAR 0 6
53203: PPUSH
53204: CALL_OW 1
53208: ST_TO_ADDR
// end ;
53209: GO 53126
53211: POP
53212: POP
// result := s_arr [ 1 ] ;
53213: LD_ADDR_VAR 0 4
53217: PUSH
53218: LD_VAR 0 7
53222: PUSH
53223: LD_INT 1
53225: ARRAY
53226: ST_TO_ADDR
// end ; end ;
53227: LD_VAR 0 4
53231: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
53232: LD_INT 0
53234: PPUSH
53235: PPUSH
// if not list then
53236: LD_VAR 0 1
53240: NOT
53241: IFFALSE 53245
// exit ;
53243: GO 53336
// i := list [ pos1 ] ;
53245: LD_ADDR_VAR 0 5
53249: PUSH
53250: LD_VAR 0 1
53254: PUSH
53255: LD_VAR 0 2
53259: ARRAY
53260: ST_TO_ADDR
// if not i then
53261: LD_VAR 0 5
53265: NOT
53266: IFFALSE 53270
// exit ;
53268: GO 53336
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
53270: LD_ADDR_VAR 0 1
53274: PUSH
53275: LD_VAR 0 1
53279: PPUSH
53280: LD_VAR 0 2
53284: PPUSH
53285: LD_VAR 0 1
53289: PUSH
53290: LD_VAR 0 3
53294: ARRAY
53295: PPUSH
53296: CALL_OW 1
53300: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
53301: LD_ADDR_VAR 0 1
53305: PUSH
53306: LD_VAR 0 1
53310: PPUSH
53311: LD_VAR 0 3
53315: PPUSH
53316: LD_VAR 0 5
53320: PPUSH
53321: CALL_OW 1
53325: ST_TO_ADDR
// result := list ;
53326: LD_ADDR_VAR 0 4
53330: PUSH
53331: LD_VAR 0 1
53335: ST_TO_ADDR
// end ;
53336: LD_VAR 0 4
53340: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
53341: LD_INT 0
53343: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
53344: LD_ADDR_VAR 0 5
53348: PUSH
53349: LD_VAR 0 1
53353: PPUSH
53354: CALL_OW 250
53358: PPUSH
53359: LD_VAR 0 1
53363: PPUSH
53364: CALL_OW 251
53368: PPUSH
53369: LD_VAR 0 2
53373: PPUSH
53374: LD_VAR 0 3
53378: PPUSH
53379: LD_VAR 0 4
53383: PPUSH
53384: CALL 53394 0 5
53388: ST_TO_ADDR
// end ;
53389: LD_VAR 0 5
53393: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
53394: LD_INT 0
53396: PPUSH
53397: PPUSH
53398: PPUSH
53399: PPUSH
// if not list then
53400: LD_VAR 0 3
53404: NOT
53405: IFFALSE 53409
// exit ;
53407: GO 53797
// result := [ ] ;
53409: LD_ADDR_VAR 0 6
53413: PUSH
53414: EMPTY
53415: ST_TO_ADDR
// for i in list do
53416: LD_ADDR_VAR 0 7
53420: PUSH
53421: LD_VAR 0 3
53425: PUSH
53426: FOR_IN
53427: IFFALSE 53629
// begin tmp := GetDistUnitXY ( i , x , y ) ;
53429: LD_ADDR_VAR 0 9
53433: PUSH
53434: LD_VAR 0 7
53438: PPUSH
53439: LD_VAR 0 1
53443: PPUSH
53444: LD_VAR 0 2
53448: PPUSH
53449: CALL_OW 297
53453: ST_TO_ADDR
// if not result then
53454: LD_VAR 0 6
53458: NOT
53459: IFFALSE 53485
// result := [ [ i , tmp ] ] else
53461: LD_ADDR_VAR 0 6
53465: PUSH
53466: LD_VAR 0 7
53470: PUSH
53471: LD_VAR 0 9
53475: PUSH
53476: EMPTY
53477: LIST
53478: LIST
53479: PUSH
53480: EMPTY
53481: LIST
53482: ST_TO_ADDR
53483: GO 53627
// begin if result [ result ] [ 2 ] < tmp then
53485: LD_VAR 0 6
53489: PUSH
53490: LD_VAR 0 6
53494: ARRAY
53495: PUSH
53496: LD_INT 2
53498: ARRAY
53499: PUSH
53500: LD_VAR 0 9
53504: LESS
53505: IFFALSE 53547
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
53507: LD_ADDR_VAR 0 6
53511: PUSH
53512: LD_VAR 0 6
53516: PPUSH
53517: LD_VAR 0 6
53521: PUSH
53522: LD_INT 1
53524: PLUS
53525: PPUSH
53526: LD_VAR 0 7
53530: PUSH
53531: LD_VAR 0 9
53535: PUSH
53536: EMPTY
53537: LIST
53538: LIST
53539: PPUSH
53540: CALL_OW 2
53544: ST_TO_ADDR
53545: GO 53627
// for j = 1 to result do
53547: LD_ADDR_VAR 0 8
53551: PUSH
53552: DOUBLE
53553: LD_INT 1
53555: DEC
53556: ST_TO_ADDR
53557: LD_VAR 0 6
53561: PUSH
53562: FOR_TO
53563: IFFALSE 53625
// begin if tmp < result [ j ] [ 2 ] then
53565: LD_VAR 0 9
53569: PUSH
53570: LD_VAR 0 6
53574: PUSH
53575: LD_VAR 0 8
53579: ARRAY
53580: PUSH
53581: LD_INT 2
53583: ARRAY
53584: LESS
53585: IFFALSE 53623
// begin result := Insert ( result , j , [ i , tmp ] ) ;
53587: LD_ADDR_VAR 0 6
53591: PUSH
53592: LD_VAR 0 6
53596: PPUSH
53597: LD_VAR 0 8
53601: PPUSH
53602: LD_VAR 0 7
53606: PUSH
53607: LD_VAR 0 9
53611: PUSH
53612: EMPTY
53613: LIST
53614: LIST
53615: PPUSH
53616: CALL_OW 2
53620: ST_TO_ADDR
// break ;
53621: GO 53625
// end ; end ;
53623: GO 53562
53625: POP
53626: POP
// end ; end ;
53627: GO 53426
53629: POP
53630: POP
// if result and not asc then
53631: LD_VAR 0 6
53635: PUSH
53636: LD_VAR 0 4
53640: NOT
53641: AND
53642: IFFALSE 53717
// begin tmp := result ;
53644: LD_ADDR_VAR 0 9
53648: PUSH
53649: LD_VAR 0 6
53653: ST_TO_ADDR
// for i = tmp downto 1 do
53654: LD_ADDR_VAR 0 7
53658: PUSH
53659: DOUBLE
53660: LD_VAR 0 9
53664: INC
53665: ST_TO_ADDR
53666: LD_INT 1
53668: PUSH
53669: FOR_DOWNTO
53670: IFFALSE 53715
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
53672: LD_ADDR_VAR 0 6
53676: PUSH
53677: LD_VAR 0 6
53681: PPUSH
53682: LD_VAR 0 9
53686: PUSH
53687: LD_VAR 0 7
53691: MINUS
53692: PUSH
53693: LD_INT 1
53695: PLUS
53696: PPUSH
53697: LD_VAR 0 9
53701: PUSH
53702: LD_VAR 0 7
53706: ARRAY
53707: PPUSH
53708: CALL_OW 1
53712: ST_TO_ADDR
53713: GO 53669
53715: POP
53716: POP
// end ; tmp := [ ] ;
53717: LD_ADDR_VAR 0 9
53721: PUSH
53722: EMPTY
53723: ST_TO_ADDR
// if mode then
53724: LD_VAR 0 5
53728: IFFALSE 53797
// begin for i = 1 to result do
53730: LD_ADDR_VAR 0 7
53734: PUSH
53735: DOUBLE
53736: LD_INT 1
53738: DEC
53739: ST_TO_ADDR
53740: LD_VAR 0 6
53744: PUSH
53745: FOR_TO
53746: IFFALSE 53785
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
53748: LD_ADDR_VAR 0 9
53752: PUSH
53753: LD_VAR 0 9
53757: PPUSH
53758: LD_VAR 0 7
53762: PPUSH
53763: LD_VAR 0 6
53767: PUSH
53768: LD_VAR 0 7
53772: ARRAY
53773: PUSH
53774: LD_INT 1
53776: ARRAY
53777: PPUSH
53778: CALL_OW 1
53782: ST_TO_ADDR
53783: GO 53745
53785: POP
53786: POP
// result := tmp ;
53787: LD_ADDR_VAR 0 6
53791: PUSH
53792: LD_VAR 0 9
53796: ST_TO_ADDR
// end ; end ;
53797: LD_VAR 0 6
53801: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
53802: LD_INT 0
53804: PPUSH
53805: PPUSH
53806: PPUSH
53807: PPUSH
53808: PPUSH
53809: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
53810: LD_ADDR_VAR 0 5
53814: PUSH
53815: LD_INT 0
53817: PUSH
53818: LD_INT 0
53820: PUSH
53821: LD_INT 0
53823: PUSH
53824: EMPTY
53825: PUSH
53826: EMPTY
53827: LIST
53828: LIST
53829: LIST
53830: LIST
53831: ST_TO_ADDR
// if not x or not y then
53832: LD_VAR 0 2
53836: NOT
53837: PUSH
53838: LD_VAR 0 3
53842: NOT
53843: OR
53844: IFFALSE 53848
// exit ;
53846: GO 55494
// if not range then
53848: LD_VAR 0 4
53852: NOT
53853: IFFALSE 53863
// range := 10 ;
53855: LD_ADDR_VAR 0 4
53859: PUSH
53860: LD_INT 10
53862: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53863: LD_ADDR_VAR 0 8
53867: PUSH
53868: LD_INT 81
53870: PUSH
53871: LD_VAR 0 1
53875: PUSH
53876: EMPTY
53877: LIST
53878: LIST
53879: PUSH
53880: LD_INT 92
53882: PUSH
53883: LD_VAR 0 2
53887: PUSH
53888: LD_VAR 0 3
53892: PUSH
53893: LD_VAR 0 4
53897: PUSH
53898: EMPTY
53899: LIST
53900: LIST
53901: LIST
53902: LIST
53903: PUSH
53904: LD_INT 3
53906: PUSH
53907: LD_INT 21
53909: PUSH
53910: LD_INT 3
53912: PUSH
53913: EMPTY
53914: LIST
53915: LIST
53916: PUSH
53917: EMPTY
53918: LIST
53919: LIST
53920: PUSH
53921: EMPTY
53922: LIST
53923: LIST
53924: LIST
53925: PPUSH
53926: CALL_OW 69
53930: ST_TO_ADDR
// if not tmp then
53931: LD_VAR 0 8
53935: NOT
53936: IFFALSE 53940
// exit ;
53938: GO 55494
// for i in tmp do
53940: LD_ADDR_VAR 0 6
53944: PUSH
53945: LD_VAR 0 8
53949: PUSH
53950: FOR_IN
53951: IFFALSE 55469
// begin points := [ 0 , 0 , 0 ] ;
53953: LD_ADDR_VAR 0 9
53957: PUSH
53958: LD_INT 0
53960: PUSH
53961: LD_INT 0
53963: PUSH
53964: LD_INT 0
53966: PUSH
53967: EMPTY
53968: LIST
53969: LIST
53970: LIST
53971: ST_TO_ADDR
// bpoints := 1 ;
53972: LD_ADDR_VAR 0 10
53976: PUSH
53977: LD_INT 1
53979: ST_TO_ADDR
// case GetType ( i ) of unit_human :
53980: LD_VAR 0 6
53984: PPUSH
53985: CALL_OW 247
53989: PUSH
53990: LD_INT 1
53992: DOUBLE
53993: EQUAL
53994: IFTRUE 53998
53996: GO 54576
53998: POP
// begin if GetClass ( i ) = 1 then
53999: LD_VAR 0 6
54003: PPUSH
54004: CALL_OW 257
54008: PUSH
54009: LD_INT 1
54011: EQUAL
54012: IFFALSE 54033
// points := [ 10 , 5 , 3 ] ;
54014: LD_ADDR_VAR 0 9
54018: PUSH
54019: LD_INT 10
54021: PUSH
54022: LD_INT 5
54024: PUSH
54025: LD_INT 3
54027: PUSH
54028: EMPTY
54029: LIST
54030: LIST
54031: LIST
54032: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54033: LD_VAR 0 6
54037: PPUSH
54038: CALL_OW 257
54042: PUSH
54043: LD_INT 2
54045: PUSH
54046: LD_INT 3
54048: PUSH
54049: LD_INT 4
54051: PUSH
54052: EMPTY
54053: LIST
54054: LIST
54055: LIST
54056: IN
54057: IFFALSE 54078
// points := [ 3 , 2 , 1 ] ;
54059: LD_ADDR_VAR 0 9
54063: PUSH
54064: LD_INT 3
54066: PUSH
54067: LD_INT 2
54069: PUSH
54070: LD_INT 1
54072: PUSH
54073: EMPTY
54074: LIST
54075: LIST
54076: LIST
54077: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54078: LD_VAR 0 6
54082: PPUSH
54083: CALL_OW 257
54087: PUSH
54088: LD_INT 5
54090: EQUAL
54091: IFFALSE 54112
// points := [ 130 , 5 , 2 ] ;
54093: LD_ADDR_VAR 0 9
54097: PUSH
54098: LD_INT 130
54100: PUSH
54101: LD_INT 5
54103: PUSH
54104: LD_INT 2
54106: PUSH
54107: EMPTY
54108: LIST
54109: LIST
54110: LIST
54111: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54112: LD_VAR 0 6
54116: PPUSH
54117: CALL_OW 257
54121: PUSH
54122: LD_INT 8
54124: EQUAL
54125: IFFALSE 54146
// points := [ 35 , 35 , 30 ] ;
54127: LD_ADDR_VAR 0 9
54131: PUSH
54132: LD_INT 35
54134: PUSH
54135: LD_INT 35
54137: PUSH
54138: LD_INT 30
54140: PUSH
54141: EMPTY
54142: LIST
54143: LIST
54144: LIST
54145: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54146: LD_VAR 0 6
54150: PPUSH
54151: CALL_OW 257
54155: PUSH
54156: LD_INT 9
54158: EQUAL
54159: IFFALSE 54180
// points := [ 20 , 55 , 40 ] ;
54161: LD_ADDR_VAR 0 9
54165: PUSH
54166: LD_INT 20
54168: PUSH
54169: LD_INT 55
54171: PUSH
54172: LD_INT 40
54174: PUSH
54175: EMPTY
54176: LIST
54177: LIST
54178: LIST
54179: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54180: LD_VAR 0 6
54184: PPUSH
54185: CALL_OW 257
54189: PUSH
54190: LD_INT 12
54192: PUSH
54193: LD_INT 16
54195: PUSH
54196: EMPTY
54197: LIST
54198: LIST
54199: IN
54200: IFFALSE 54221
// points := [ 5 , 3 , 2 ] ;
54202: LD_ADDR_VAR 0 9
54206: PUSH
54207: LD_INT 5
54209: PUSH
54210: LD_INT 3
54212: PUSH
54213: LD_INT 2
54215: PUSH
54216: EMPTY
54217: LIST
54218: LIST
54219: LIST
54220: ST_TO_ADDR
// if GetClass ( i ) = 17 then
54221: LD_VAR 0 6
54225: PPUSH
54226: CALL_OW 257
54230: PUSH
54231: LD_INT 17
54233: EQUAL
54234: IFFALSE 54255
// points := [ 100 , 50 , 75 ] ;
54236: LD_ADDR_VAR 0 9
54240: PUSH
54241: LD_INT 100
54243: PUSH
54244: LD_INT 50
54246: PUSH
54247: LD_INT 75
54249: PUSH
54250: EMPTY
54251: LIST
54252: LIST
54253: LIST
54254: ST_TO_ADDR
// if GetClass ( i ) = 15 then
54255: LD_VAR 0 6
54259: PPUSH
54260: CALL_OW 257
54264: PUSH
54265: LD_INT 15
54267: EQUAL
54268: IFFALSE 54289
// points := [ 10 , 5 , 3 ] ;
54270: LD_ADDR_VAR 0 9
54274: PUSH
54275: LD_INT 10
54277: PUSH
54278: LD_INT 5
54280: PUSH
54281: LD_INT 3
54283: PUSH
54284: EMPTY
54285: LIST
54286: LIST
54287: LIST
54288: ST_TO_ADDR
// if GetClass ( i ) = 14 then
54289: LD_VAR 0 6
54293: PPUSH
54294: CALL_OW 257
54298: PUSH
54299: LD_INT 14
54301: EQUAL
54302: IFFALSE 54323
// points := [ 10 , 0 , 0 ] ;
54304: LD_ADDR_VAR 0 9
54308: PUSH
54309: LD_INT 10
54311: PUSH
54312: LD_INT 0
54314: PUSH
54315: LD_INT 0
54317: PUSH
54318: EMPTY
54319: LIST
54320: LIST
54321: LIST
54322: ST_TO_ADDR
// if GetClass ( i ) = 11 then
54323: LD_VAR 0 6
54327: PPUSH
54328: CALL_OW 257
54332: PUSH
54333: LD_INT 11
54335: EQUAL
54336: IFFALSE 54357
// points := [ 30 , 10 , 5 ] ;
54338: LD_ADDR_VAR 0 9
54342: PUSH
54343: LD_INT 30
54345: PUSH
54346: LD_INT 10
54348: PUSH
54349: LD_INT 5
54351: PUSH
54352: EMPTY
54353: LIST
54354: LIST
54355: LIST
54356: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
54357: LD_VAR 0 1
54361: PPUSH
54362: LD_INT 5
54364: PPUSH
54365: CALL_OW 321
54369: PUSH
54370: LD_INT 2
54372: EQUAL
54373: IFFALSE 54390
// bpoints := bpoints * 1.8 ;
54375: LD_ADDR_VAR 0 10
54379: PUSH
54380: LD_VAR 0 10
54384: PUSH
54385: LD_REAL  1.80000000000000E+0000
54388: MUL
54389: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
54390: LD_VAR 0 6
54394: PPUSH
54395: CALL_OW 257
54399: PUSH
54400: LD_INT 1
54402: PUSH
54403: LD_INT 2
54405: PUSH
54406: LD_INT 3
54408: PUSH
54409: LD_INT 4
54411: PUSH
54412: EMPTY
54413: LIST
54414: LIST
54415: LIST
54416: LIST
54417: IN
54418: PUSH
54419: LD_VAR 0 1
54423: PPUSH
54424: LD_INT 51
54426: PPUSH
54427: CALL_OW 321
54431: PUSH
54432: LD_INT 2
54434: EQUAL
54435: AND
54436: IFFALSE 54453
// bpoints := bpoints * 1.2 ;
54438: LD_ADDR_VAR 0 10
54442: PUSH
54443: LD_VAR 0 10
54447: PUSH
54448: LD_REAL  1.20000000000000E+0000
54451: MUL
54452: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
54453: LD_VAR 0 6
54457: PPUSH
54458: CALL_OW 257
54462: PUSH
54463: LD_INT 5
54465: PUSH
54466: LD_INT 7
54468: PUSH
54469: LD_INT 9
54471: PUSH
54472: EMPTY
54473: LIST
54474: LIST
54475: LIST
54476: IN
54477: PUSH
54478: LD_VAR 0 1
54482: PPUSH
54483: LD_INT 52
54485: PPUSH
54486: CALL_OW 321
54490: PUSH
54491: LD_INT 2
54493: EQUAL
54494: AND
54495: IFFALSE 54512
// bpoints := bpoints * 1.5 ;
54497: LD_ADDR_VAR 0 10
54501: PUSH
54502: LD_VAR 0 10
54506: PUSH
54507: LD_REAL  1.50000000000000E+0000
54510: MUL
54511: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
54512: LD_VAR 0 1
54516: PPUSH
54517: LD_INT 66
54519: PPUSH
54520: CALL_OW 321
54524: PUSH
54525: LD_INT 2
54527: EQUAL
54528: IFFALSE 54545
// bpoints := bpoints * 1.1 ;
54530: LD_ADDR_VAR 0 10
54534: PUSH
54535: LD_VAR 0 10
54539: PUSH
54540: LD_REAL  1.10000000000000E+0000
54543: MUL
54544: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
54545: LD_ADDR_VAR 0 10
54549: PUSH
54550: LD_VAR 0 10
54554: PUSH
54555: LD_VAR 0 6
54559: PPUSH
54560: LD_INT 1
54562: PPUSH
54563: CALL_OW 259
54567: PUSH
54568: LD_REAL  1.15000000000000E+0000
54571: MUL
54572: MUL
54573: ST_TO_ADDR
// end ; unit_vehicle :
54574: GO 55398
54576: LD_INT 2
54578: DOUBLE
54579: EQUAL
54580: IFTRUE 54584
54582: GO 55386
54584: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
54585: LD_VAR 0 6
54589: PPUSH
54590: CALL_OW 264
54594: PUSH
54595: LD_INT 2
54597: PUSH
54598: LD_INT 42
54600: PUSH
54601: LD_INT 24
54603: PUSH
54604: EMPTY
54605: LIST
54606: LIST
54607: LIST
54608: IN
54609: IFFALSE 54630
// points := [ 25 , 5 , 3 ] ;
54611: LD_ADDR_VAR 0 9
54615: PUSH
54616: LD_INT 25
54618: PUSH
54619: LD_INT 5
54621: PUSH
54622: LD_INT 3
54624: PUSH
54625: EMPTY
54626: LIST
54627: LIST
54628: LIST
54629: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
54630: LD_VAR 0 6
54634: PPUSH
54635: CALL_OW 264
54639: PUSH
54640: LD_INT 4
54642: PUSH
54643: LD_INT 43
54645: PUSH
54646: LD_INT 25
54648: PUSH
54649: EMPTY
54650: LIST
54651: LIST
54652: LIST
54653: IN
54654: IFFALSE 54675
// points := [ 40 , 15 , 5 ] ;
54656: LD_ADDR_VAR 0 9
54660: PUSH
54661: LD_INT 40
54663: PUSH
54664: LD_INT 15
54666: PUSH
54667: LD_INT 5
54669: PUSH
54670: EMPTY
54671: LIST
54672: LIST
54673: LIST
54674: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
54675: LD_VAR 0 6
54679: PPUSH
54680: CALL_OW 264
54684: PUSH
54685: LD_INT 3
54687: PUSH
54688: LD_INT 23
54690: PUSH
54691: EMPTY
54692: LIST
54693: LIST
54694: IN
54695: IFFALSE 54716
// points := [ 7 , 25 , 8 ] ;
54697: LD_ADDR_VAR 0 9
54701: PUSH
54702: LD_INT 7
54704: PUSH
54705: LD_INT 25
54707: PUSH
54708: LD_INT 8
54710: PUSH
54711: EMPTY
54712: LIST
54713: LIST
54714: LIST
54715: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
54716: LD_VAR 0 6
54720: PPUSH
54721: CALL_OW 264
54725: PUSH
54726: LD_INT 5
54728: PUSH
54729: LD_INT 27
54731: PUSH
54732: LD_INT 44
54734: PUSH
54735: EMPTY
54736: LIST
54737: LIST
54738: LIST
54739: IN
54740: IFFALSE 54761
// points := [ 14 , 50 , 16 ] ;
54742: LD_ADDR_VAR 0 9
54746: PUSH
54747: LD_INT 14
54749: PUSH
54750: LD_INT 50
54752: PUSH
54753: LD_INT 16
54755: PUSH
54756: EMPTY
54757: LIST
54758: LIST
54759: LIST
54760: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
54761: LD_VAR 0 6
54765: PPUSH
54766: CALL_OW 264
54770: PUSH
54771: LD_INT 6
54773: PUSH
54774: LD_INT 46
54776: PUSH
54777: EMPTY
54778: LIST
54779: LIST
54780: IN
54781: IFFALSE 54802
// points := [ 32 , 120 , 70 ] ;
54783: LD_ADDR_VAR 0 9
54787: PUSH
54788: LD_INT 32
54790: PUSH
54791: LD_INT 120
54793: PUSH
54794: LD_INT 70
54796: PUSH
54797: EMPTY
54798: LIST
54799: LIST
54800: LIST
54801: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
54802: LD_VAR 0 6
54806: PPUSH
54807: CALL_OW 264
54811: PUSH
54812: LD_INT 7
54814: PUSH
54815: LD_INT 28
54817: PUSH
54818: LD_INT 45
54820: PUSH
54821: EMPTY
54822: LIST
54823: LIST
54824: LIST
54825: IN
54826: IFFALSE 54847
// points := [ 35 , 20 , 45 ] ;
54828: LD_ADDR_VAR 0 9
54832: PUSH
54833: LD_INT 35
54835: PUSH
54836: LD_INT 20
54838: PUSH
54839: LD_INT 45
54841: PUSH
54842: EMPTY
54843: LIST
54844: LIST
54845: LIST
54846: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
54847: LD_VAR 0 6
54851: PPUSH
54852: CALL_OW 264
54856: PUSH
54857: LD_INT 47
54859: PUSH
54860: EMPTY
54861: LIST
54862: IN
54863: IFFALSE 54884
// points := [ 67 , 45 , 75 ] ;
54865: LD_ADDR_VAR 0 9
54869: PUSH
54870: LD_INT 67
54872: PUSH
54873: LD_INT 45
54875: PUSH
54876: LD_INT 75
54878: PUSH
54879: EMPTY
54880: LIST
54881: LIST
54882: LIST
54883: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
54884: LD_VAR 0 6
54888: PPUSH
54889: CALL_OW 264
54893: PUSH
54894: LD_INT 26
54896: PUSH
54897: EMPTY
54898: LIST
54899: IN
54900: IFFALSE 54921
// points := [ 120 , 30 , 80 ] ;
54902: LD_ADDR_VAR 0 9
54906: PUSH
54907: LD_INT 120
54909: PUSH
54910: LD_INT 30
54912: PUSH
54913: LD_INT 80
54915: PUSH
54916: EMPTY
54917: LIST
54918: LIST
54919: LIST
54920: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
54921: LD_VAR 0 6
54925: PPUSH
54926: CALL_OW 264
54930: PUSH
54931: LD_INT 22
54933: PUSH
54934: EMPTY
54935: LIST
54936: IN
54937: IFFALSE 54958
// points := [ 40 , 1 , 1 ] ;
54939: LD_ADDR_VAR 0 9
54943: PUSH
54944: LD_INT 40
54946: PUSH
54947: LD_INT 1
54949: PUSH
54950: LD_INT 1
54952: PUSH
54953: EMPTY
54954: LIST
54955: LIST
54956: LIST
54957: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
54958: LD_VAR 0 6
54962: PPUSH
54963: CALL_OW 264
54967: PUSH
54968: LD_INT 29
54970: PUSH
54971: EMPTY
54972: LIST
54973: IN
54974: IFFALSE 54995
// points := [ 70 , 200 , 400 ] ;
54976: LD_ADDR_VAR 0 9
54980: PUSH
54981: LD_INT 70
54983: PUSH
54984: LD_INT 200
54986: PUSH
54987: LD_INT 400
54989: PUSH
54990: EMPTY
54991: LIST
54992: LIST
54993: LIST
54994: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
54995: LD_VAR 0 6
54999: PPUSH
55000: CALL_OW 264
55004: PUSH
55005: LD_INT 14
55007: PUSH
55008: LD_INT 53
55010: PUSH
55011: EMPTY
55012: LIST
55013: LIST
55014: IN
55015: IFFALSE 55036
// points := [ 40 , 10 , 20 ] ;
55017: LD_ADDR_VAR 0 9
55021: PUSH
55022: LD_INT 40
55024: PUSH
55025: LD_INT 10
55027: PUSH
55028: LD_INT 20
55030: PUSH
55031: EMPTY
55032: LIST
55033: LIST
55034: LIST
55035: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55036: LD_VAR 0 6
55040: PPUSH
55041: CALL_OW 264
55045: PUSH
55046: LD_INT 9
55048: PUSH
55049: EMPTY
55050: LIST
55051: IN
55052: IFFALSE 55073
// points := [ 5 , 70 , 20 ] ;
55054: LD_ADDR_VAR 0 9
55058: PUSH
55059: LD_INT 5
55061: PUSH
55062: LD_INT 70
55064: PUSH
55065: LD_INT 20
55067: PUSH
55068: EMPTY
55069: LIST
55070: LIST
55071: LIST
55072: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55073: LD_VAR 0 6
55077: PPUSH
55078: CALL_OW 264
55082: PUSH
55083: LD_INT 10
55085: PUSH
55086: EMPTY
55087: LIST
55088: IN
55089: IFFALSE 55110
// points := [ 35 , 110 , 70 ] ;
55091: LD_ADDR_VAR 0 9
55095: PUSH
55096: LD_INT 35
55098: PUSH
55099: LD_INT 110
55101: PUSH
55102: LD_INT 70
55104: PUSH
55105: EMPTY
55106: LIST
55107: LIST
55108: LIST
55109: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55110: LD_VAR 0 6
55114: PPUSH
55115: CALL_OW 265
55119: PUSH
55120: LD_INT 25
55122: EQUAL
55123: IFFALSE 55144
// points := [ 80 , 65 , 100 ] ;
55125: LD_ADDR_VAR 0 9
55129: PUSH
55130: LD_INT 80
55132: PUSH
55133: LD_INT 65
55135: PUSH
55136: LD_INT 100
55138: PUSH
55139: EMPTY
55140: LIST
55141: LIST
55142: LIST
55143: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55144: LD_VAR 0 6
55148: PPUSH
55149: CALL_OW 263
55153: PUSH
55154: LD_INT 1
55156: EQUAL
55157: IFFALSE 55192
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55159: LD_ADDR_VAR 0 10
55163: PUSH
55164: LD_VAR 0 10
55168: PUSH
55169: LD_VAR 0 6
55173: PPUSH
55174: CALL_OW 311
55178: PPUSH
55179: LD_INT 3
55181: PPUSH
55182: CALL_OW 259
55186: PUSH
55187: LD_INT 4
55189: MUL
55190: MUL
55191: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
55192: LD_VAR 0 6
55196: PPUSH
55197: CALL_OW 263
55201: PUSH
55202: LD_INT 2
55204: EQUAL
55205: IFFALSE 55256
// begin j := IsControledBy ( i ) ;
55207: LD_ADDR_VAR 0 7
55211: PUSH
55212: LD_VAR 0 6
55216: PPUSH
55217: CALL_OW 312
55221: ST_TO_ADDR
// if j then
55222: LD_VAR 0 7
55226: IFFALSE 55256
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
55228: LD_ADDR_VAR 0 10
55232: PUSH
55233: LD_VAR 0 10
55237: PUSH
55238: LD_VAR 0 7
55242: PPUSH
55243: LD_INT 3
55245: PPUSH
55246: CALL_OW 259
55250: PUSH
55251: LD_INT 3
55253: MUL
55254: MUL
55255: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
55256: LD_VAR 0 6
55260: PPUSH
55261: CALL_OW 264
55265: PUSH
55266: LD_INT 5
55268: PUSH
55269: LD_INT 6
55271: PUSH
55272: LD_INT 46
55274: PUSH
55275: LD_INT 44
55277: PUSH
55278: LD_INT 47
55280: PUSH
55281: LD_INT 45
55283: PUSH
55284: LD_INT 28
55286: PUSH
55287: LD_INT 7
55289: PUSH
55290: LD_INT 27
55292: PUSH
55293: LD_INT 29
55295: PUSH
55296: EMPTY
55297: LIST
55298: LIST
55299: LIST
55300: LIST
55301: LIST
55302: LIST
55303: LIST
55304: LIST
55305: LIST
55306: LIST
55307: IN
55308: PUSH
55309: LD_VAR 0 1
55313: PPUSH
55314: LD_INT 52
55316: PPUSH
55317: CALL_OW 321
55321: PUSH
55322: LD_INT 2
55324: EQUAL
55325: AND
55326: IFFALSE 55343
// bpoints := bpoints * 1.2 ;
55328: LD_ADDR_VAR 0 10
55332: PUSH
55333: LD_VAR 0 10
55337: PUSH
55338: LD_REAL  1.20000000000000E+0000
55341: MUL
55342: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
55343: LD_VAR 0 6
55347: PPUSH
55348: CALL_OW 264
55352: PUSH
55353: LD_INT 6
55355: PUSH
55356: LD_INT 46
55358: PUSH
55359: LD_INT 47
55361: PUSH
55362: EMPTY
55363: LIST
55364: LIST
55365: LIST
55366: IN
55367: IFFALSE 55384
// bpoints := bpoints * 1.2 ;
55369: LD_ADDR_VAR 0 10
55373: PUSH
55374: LD_VAR 0 10
55378: PUSH
55379: LD_REAL  1.20000000000000E+0000
55382: MUL
55383: ST_TO_ADDR
// end ; unit_building :
55384: GO 55398
55386: LD_INT 3
55388: DOUBLE
55389: EQUAL
55390: IFTRUE 55394
55392: GO 55397
55394: POP
// ; end ;
55395: GO 55398
55397: POP
// for j = 1 to 3 do
55398: LD_ADDR_VAR 0 7
55402: PUSH
55403: DOUBLE
55404: LD_INT 1
55406: DEC
55407: ST_TO_ADDR
55408: LD_INT 3
55410: PUSH
55411: FOR_TO
55412: IFFALSE 55465
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
55414: LD_ADDR_VAR 0 5
55418: PUSH
55419: LD_VAR 0 5
55423: PPUSH
55424: LD_VAR 0 7
55428: PPUSH
55429: LD_VAR 0 5
55433: PUSH
55434: LD_VAR 0 7
55438: ARRAY
55439: PUSH
55440: LD_VAR 0 9
55444: PUSH
55445: LD_VAR 0 7
55449: ARRAY
55450: PUSH
55451: LD_VAR 0 10
55455: MUL
55456: PLUS
55457: PPUSH
55458: CALL_OW 1
55462: ST_TO_ADDR
55463: GO 55411
55465: POP
55466: POP
// end ;
55467: GO 53950
55469: POP
55470: POP
// result := Replace ( result , 4 , tmp ) ;
55471: LD_ADDR_VAR 0 5
55475: PUSH
55476: LD_VAR 0 5
55480: PPUSH
55481: LD_INT 4
55483: PPUSH
55484: LD_VAR 0 8
55488: PPUSH
55489: CALL_OW 1
55493: ST_TO_ADDR
// end ;
55494: LD_VAR 0 5
55498: RET
// export function DangerAtRange ( unit , range ) ; begin
55499: LD_INT 0
55501: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
55502: LD_ADDR_VAR 0 3
55506: PUSH
55507: LD_VAR 0 1
55511: PPUSH
55512: CALL_OW 255
55516: PPUSH
55517: LD_VAR 0 1
55521: PPUSH
55522: CALL_OW 250
55526: PPUSH
55527: LD_VAR 0 1
55531: PPUSH
55532: CALL_OW 251
55536: PPUSH
55537: LD_VAR 0 2
55541: PPUSH
55542: CALL 53802 0 4
55546: ST_TO_ADDR
// end ;
55547: LD_VAR 0 3
55551: RET
// export function DangerInArea ( side , area ) ; begin
55552: LD_INT 0
55554: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
55555: LD_ADDR_VAR 0 3
55559: PUSH
55560: LD_VAR 0 2
55564: PPUSH
55565: LD_INT 81
55567: PUSH
55568: LD_VAR 0 1
55572: PUSH
55573: EMPTY
55574: LIST
55575: LIST
55576: PPUSH
55577: CALL_OW 70
55581: ST_TO_ADDR
// end ;
55582: LD_VAR 0 3
55586: RET
// export function IsExtension ( b ) ; begin
55587: LD_INT 0
55589: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
55590: LD_ADDR_VAR 0 2
55594: PUSH
55595: LD_VAR 0 1
55599: PUSH
55600: LD_INT 23
55602: PUSH
55603: LD_INT 20
55605: PUSH
55606: LD_INT 22
55608: PUSH
55609: LD_INT 17
55611: PUSH
55612: LD_INT 24
55614: PUSH
55615: LD_INT 21
55617: PUSH
55618: LD_INT 19
55620: PUSH
55621: LD_INT 16
55623: PUSH
55624: LD_INT 25
55626: PUSH
55627: LD_INT 18
55629: PUSH
55630: EMPTY
55631: LIST
55632: LIST
55633: LIST
55634: LIST
55635: LIST
55636: LIST
55637: LIST
55638: LIST
55639: LIST
55640: LIST
55641: IN
55642: ST_TO_ADDR
// end ;
55643: LD_VAR 0 2
55647: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
55648: LD_INT 0
55650: PPUSH
55651: PPUSH
55652: PPUSH
// result := [ ] ;
55653: LD_ADDR_VAR 0 4
55657: PUSH
55658: EMPTY
55659: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
55660: LD_ADDR_VAR 0 5
55664: PUSH
55665: LD_VAR 0 2
55669: PPUSH
55670: LD_INT 21
55672: PUSH
55673: LD_INT 3
55675: PUSH
55676: EMPTY
55677: LIST
55678: LIST
55679: PPUSH
55680: CALL_OW 70
55684: ST_TO_ADDR
// if not tmp then
55685: LD_VAR 0 5
55689: NOT
55690: IFFALSE 55694
// exit ;
55692: GO 55758
// if checkLink then
55694: LD_VAR 0 3
55698: IFFALSE 55748
// begin for i in tmp do
55700: LD_ADDR_VAR 0 6
55704: PUSH
55705: LD_VAR 0 5
55709: PUSH
55710: FOR_IN
55711: IFFALSE 55746
// if GetBase ( i ) <> base then
55713: LD_VAR 0 6
55717: PPUSH
55718: CALL_OW 274
55722: PUSH
55723: LD_VAR 0 1
55727: NONEQUAL
55728: IFFALSE 55744
// ComLinkToBase ( base , i ) ;
55730: LD_VAR 0 1
55734: PPUSH
55735: LD_VAR 0 6
55739: PPUSH
55740: CALL_OW 169
55744: GO 55710
55746: POP
55747: POP
// end ; result := tmp ;
55748: LD_ADDR_VAR 0 4
55752: PUSH
55753: LD_VAR 0 5
55757: ST_TO_ADDR
// end ;
55758: LD_VAR 0 4
55762: RET
// export function ComComplete ( units , b ) ; var i ; begin
55763: LD_INT 0
55765: PPUSH
55766: PPUSH
// if not units then
55767: LD_VAR 0 1
55771: NOT
55772: IFFALSE 55776
// exit ;
55774: GO 55866
// for i in units do
55776: LD_ADDR_VAR 0 4
55780: PUSH
55781: LD_VAR 0 1
55785: PUSH
55786: FOR_IN
55787: IFFALSE 55864
// if BuildingStatus ( b ) = bs_build then
55789: LD_VAR 0 2
55793: PPUSH
55794: CALL_OW 461
55798: PUSH
55799: LD_INT 1
55801: EQUAL
55802: IFFALSE 55862
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
55804: LD_VAR 0 4
55808: PPUSH
55809: LD_STRING h
55811: PUSH
55812: LD_VAR 0 2
55816: PPUSH
55817: CALL_OW 250
55821: PUSH
55822: LD_VAR 0 2
55826: PPUSH
55827: CALL_OW 251
55831: PUSH
55832: LD_VAR 0 2
55836: PUSH
55837: LD_INT 0
55839: PUSH
55840: LD_INT 0
55842: PUSH
55843: LD_INT 0
55845: PUSH
55846: EMPTY
55847: LIST
55848: LIST
55849: LIST
55850: LIST
55851: LIST
55852: LIST
55853: LIST
55854: PUSH
55855: EMPTY
55856: LIST
55857: PPUSH
55858: CALL_OW 446
55862: GO 55786
55864: POP
55865: POP
// end ;
55866: LD_VAR 0 3
55870: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
55871: LD_INT 0
55873: PPUSH
55874: PPUSH
55875: PPUSH
55876: PPUSH
55877: PPUSH
55878: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
55879: LD_VAR 0 1
55883: NOT
55884: PUSH
55885: LD_VAR 0 1
55889: PPUSH
55890: CALL_OW 263
55894: PUSH
55895: LD_INT 2
55897: EQUAL
55898: NOT
55899: OR
55900: IFFALSE 55904
// exit ;
55902: GO 56220
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
55904: LD_ADDR_VAR 0 6
55908: PUSH
55909: LD_INT 22
55911: PUSH
55912: LD_VAR 0 1
55916: PPUSH
55917: CALL_OW 255
55921: PUSH
55922: EMPTY
55923: LIST
55924: LIST
55925: PUSH
55926: LD_INT 2
55928: PUSH
55929: LD_INT 30
55931: PUSH
55932: LD_INT 36
55934: PUSH
55935: EMPTY
55936: LIST
55937: LIST
55938: PUSH
55939: LD_INT 34
55941: PUSH
55942: LD_INT 31
55944: PUSH
55945: EMPTY
55946: LIST
55947: LIST
55948: PUSH
55949: EMPTY
55950: LIST
55951: LIST
55952: LIST
55953: PUSH
55954: EMPTY
55955: LIST
55956: LIST
55957: PPUSH
55958: CALL_OW 69
55962: ST_TO_ADDR
// if not tmp then
55963: LD_VAR 0 6
55967: NOT
55968: IFFALSE 55972
// exit ;
55970: GO 56220
// result := [ ] ;
55972: LD_ADDR_VAR 0 2
55976: PUSH
55977: EMPTY
55978: ST_TO_ADDR
// for i in tmp do
55979: LD_ADDR_VAR 0 3
55983: PUSH
55984: LD_VAR 0 6
55988: PUSH
55989: FOR_IN
55990: IFFALSE 56061
// begin t := UnitsInside ( i ) ;
55992: LD_ADDR_VAR 0 4
55996: PUSH
55997: LD_VAR 0 3
56001: PPUSH
56002: CALL_OW 313
56006: ST_TO_ADDR
// if t then
56007: LD_VAR 0 4
56011: IFFALSE 56059
// for j in t do
56013: LD_ADDR_VAR 0 7
56017: PUSH
56018: LD_VAR 0 4
56022: PUSH
56023: FOR_IN
56024: IFFALSE 56057
// result := Insert ( result , result + 1 , j ) ;
56026: LD_ADDR_VAR 0 2
56030: PUSH
56031: LD_VAR 0 2
56035: PPUSH
56036: LD_VAR 0 2
56040: PUSH
56041: LD_INT 1
56043: PLUS
56044: PPUSH
56045: LD_VAR 0 7
56049: PPUSH
56050: CALL_OW 2
56054: ST_TO_ADDR
56055: GO 56023
56057: POP
56058: POP
// end ;
56059: GO 55989
56061: POP
56062: POP
// if not result then
56063: LD_VAR 0 2
56067: NOT
56068: IFFALSE 56072
// exit ;
56070: GO 56220
// mech := result [ 1 ] ;
56072: LD_ADDR_VAR 0 5
56076: PUSH
56077: LD_VAR 0 2
56081: PUSH
56082: LD_INT 1
56084: ARRAY
56085: ST_TO_ADDR
// if result > 1 then
56086: LD_VAR 0 2
56090: PUSH
56091: LD_INT 1
56093: GREATER
56094: IFFALSE 56206
// for i = 2 to result do
56096: LD_ADDR_VAR 0 3
56100: PUSH
56101: DOUBLE
56102: LD_INT 2
56104: DEC
56105: ST_TO_ADDR
56106: LD_VAR 0 2
56110: PUSH
56111: FOR_TO
56112: IFFALSE 56204
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56114: LD_ADDR_VAR 0 4
56118: PUSH
56119: LD_VAR 0 2
56123: PUSH
56124: LD_VAR 0 3
56128: ARRAY
56129: PPUSH
56130: LD_INT 3
56132: PPUSH
56133: CALL_OW 259
56137: PUSH
56138: LD_VAR 0 2
56142: PUSH
56143: LD_VAR 0 3
56147: ARRAY
56148: PPUSH
56149: CALL_OW 432
56153: MINUS
56154: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56155: LD_VAR 0 4
56159: PUSH
56160: LD_VAR 0 5
56164: PPUSH
56165: LD_INT 3
56167: PPUSH
56168: CALL_OW 259
56172: PUSH
56173: LD_VAR 0 5
56177: PPUSH
56178: CALL_OW 432
56182: MINUS
56183: GREATEREQUAL
56184: IFFALSE 56202
// mech := result [ i ] ;
56186: LD_ADDR_VAR 0 5
56190: PUSH
56191: LD_VAR 0 2
56195: PUSH
56196: LD_VAR 0 3
56200: ARRAY
56201: ST_TO_ADDR
// end ;
56202: GO 56111
56204: POP
56205: POP
// ComLinkTo ( vehicle , mech ) ;
56206: LD_VAR 0 1
56210: PPUSH
56211: LD_VAR 0 5
56215: PPUSH
56216: CALL_OW 135
// end ;
56220: LD_VAR 0 2
56224: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
56225: LD_INT 0
56227: PPUSH
56228: PPUSH
56229: PPUSH
56230: PPUSH
56231: PPUSH
56232: PPUSH
56233: PPUSH
56234: PPUSH
56235: PPUSH
56236: PPUSH
56237: PPUSH
56238: PPUSH
56239: PPUSH
// result := [ ] ;
56240: LD_ADDR_VAR 0 7
56244: PUSH
56245: EMPTY
56246: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
56247: LD_VAR 0 1
56251: PPUSH
56252: CALL_OW 266
56256: PUSH
56257: LD_INT 0
56259: PUSH
56260: LD_INT 1
56262: PUSH
56263: EMPTY
56264: LIST
56265: LIST
56266: IN
56267: NOT
56268: IFFALSE 56272
// exit ;
56270: GO 57906
// if name then
56272: LD_VAR 0 3
56276: IFFALSE 56292
// SetBName ( base_dep , name ) ;
56278: LD_VAR 0 1
56282: PPUSH
56283: LD_VAR 0 3
56287: PPUSH
56288: CALL_OW 500
// base := GetBase ( base_dep ) ;
56292: LD_ADDR_VAR 0 15
56296: PUSH
56297: LD_VAR 0 1
56301: PPUSH
56302: CALL_OW 274
56306: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
56307: LD_ADDR_VAR 0 16
56311: PUSH
56312: LD_VAR 0 1
56316: PPUSH
56317: CALL_OW 255
56321: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
56322: LD_ADDR_VAR 0 17
56326: PUSH
56327: LD_VAR 0 1
56331: PPUSH
56332: CALL_OW 248
56336: ST_TO_ADDR
// if sources then
56337: LD_VAR 0 5
56341: IFFALSE 56388
// for i = 1 to 3 do
56343: LD_ADDR_VAR 0 8
56347: PUSH
56348: DOUBLE
56349: LD_INT 1
56351: DEC
56352: ST_TO_ADDR
56353: LD_INT 3
56355: PUSH
56356: FOR_TO
56357: IFFALSE 56386
// AddResourceType ( base , i , sources [ i ] ) ;
56359: LD_VAR 0 15
56363: PPUSH
56364: LD_VAR 0 8
56368: PPUSH
56369: LD_VAR 0 5
56373: PUSH
56374: LD_VAR 0 8
56378: ARRAY
56379: PPUSH
56380: CALL_OW 276
56384: GO 56356
56386: POP
56387: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
56388: LD_ADDR_VAR 0 18
56392: PUSH
56393: LD_VAR 0 15
56397: PPUSH
56398: LD_VAR 0 2
56402: PPUSH
56403: LD_INT 1
56405: PPUSH
56406: CALL 55648 0 3
56410: ST_TO_ADDR
// InitHc ;
56411: CALL_OW 19
// InitUc ;
56415: CALL_OW 18
// uc_side := side ;
56419: LD_ADDR_OWVAR 20
56423: PUSH
56424: LD_VAR 0 16
56428: ST_TO_ADDR
// uc_nation := nation ;
56429: LD_ADDR_OWVAR 21
56433: PUSH
56434: LD_VAR 0 17
56438: ST_TO_ADDR
// if buildings then
56439: LD_VAR 0 18
56443: IFFALSE 57765
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
56445: LD_ADDR_VAR 0 19
56449: PUSH
56450: LD_VAR 0 18
56454: PPUSH
56455: LD_INT 2
56457: PUSH
56458: LD_INT 30
56460: PUSH
56461: LD_INT 29
56463: PUSH
56464: EMPTY
56465: LIST
56466: LIST
56467: PUSH
56468: LD_INT 30
56470: PUSH
56471: LD_INT 30
56473: PUSH
56474: EMPTY
56475: LIST
56476: LIST
56477: PUSH
56478: EMPTY
56479: LIST
56480: LIST
56481: LIST
56482: PPUSH
56483: CALL_OW 72
56487: ST_TO_ADDR
// if tmp then
56488: LD_VAR 0 19
56492: IFFALSE 56540
// for i in tmp do
56494: LD_ADDR_VAR 0 8
56498: PUSH
56499: LD_VAR 0 19
56503: PUSH
56504: FOR_IN
56505: IFFALSE 56538
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
56507: LD_VAR 0 8
56511: PPUSH
56512: CALL_OW 250
56516: PPUSH
56517: LD_VAR 0 8
56521: PPUSH
56522: CALL_OW 251
56526: PPUSH
56527: LD_VAR 0 16
56531: PPUSH
56532: CALL_OW 441
56536: GO 56504
56538: POP
56539: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
56540: LD_VAR 0 18
56544: PPUSH
56545: LD_INT 2
56547: PUSH
56548: LD_INT 30
56550: PUSH
56551: LD_INT 32
56553: PUSH
56554: EMPTY
56555: LIST
56556: LIST
56557: PUSH
56558: LD_INT 30
56560: PUSH
56561: LD_INT 33
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: PUSH
56568: EMPTY
56569: LIST
56570: LIST
56571: LIST
56572: PPUSH
56573: CALL_OW 72
56577: IFFALSE 56665
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
56579: LD_ADDR_VAR 0 8
56583: PUSH
56584: LD_VAR 0 18
56588: PPUSH
56589: LD_INT 2
56591: PUSH
56592: LD_INT 30
56594: PUSH
56595: LD_INT 32
56597: PUSH
56598: EMPTY
56599: LIST
56600: LIST
56601: PUSH
56602: LD_INT 30
56604: PUSH
56605: LD_INT 33
56607: PUSH
56608: EMPTY
56609: LIST
56610: LIST
56611: PUSH
56612: EMPTY
56613: LIST
56614: LIST
56615: LIST
56616: PPUSH
56617: CALL_OW 72
56621: PUSH
56622: FOR_IN
56623: IFFALSE 56663
// begin if not GetBWeapon ( i ) then
56625: LD_VAR 0 8
56629: PPUSH
56630: CALL_OW 269
56634: NOT
56635: IFFALSE 56661
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
56637: LD_VAR 0 8
56641: PPUSH
56642: LD_VAR 0 8
56646: PPUSH
56647: LD_VAR 0 2
56651: PPUSH
56652: CALL 57911 0 2
56656: PPUSH
56657: CALL_OW 431
// end ;
56661: GO 56622
56663: POP
56664: POP
// end ; for i = 1 to personel do
56665: LD_ADDR_VAR 0 8
56669: PUSH
56670: DOUBLE
56671: LD_INT 1
56673: DEC
56674: ST_TO_ADDR
56675: LD_VAR 0 6
56679: PUSH
56680: FOR_TO
56681: IFFALSE 57745
// begin if i > 4 then
56683: LD_VAR 0 8
56687: PUSH
56688: LD_INT 4
56690: GREATER
56691: IFFALSE 56695
// break ;
56693: GO 57745
// case i of 1 :
56695: LD_VAR 0 8
56699: PUSH
56700: LD_INT 1
56702: DOUBLE
56703: EQUAL
56704: IFTRUE 56708
56706: GO 56788
56708: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
56709: LD_ADDR_VAR 0 12
56713: PUSH
56714: LD_VAR 0 18
56718: PPUSH
56719: LD_INT 22
56721: PUSH
56722: LD_VAR 0 16
56726: PUSH
56727: EMPTY
56728: LIST
56729: LIST
56730: PUSH
56731: LD_INT 58
56733: PUSH
56734: EMPTY
56735: LIST
56736: PUSH
56737: LD_INT 2
56739: PUSH
56740: LD_INT 30
56742: PUSH
56743: LD_INT 32
56745: PUSH
56746: EMPTY
56747: LIST
56748: LIST
56749: PUSH
56750: LD_INT 30
56752: PUSH
56753: LD_INT 4
56755: PUSH
56756: EMPTY
56757: LIST
56758: LIST
56759: PUSH
56760: LD_INT 30
56762: PUSH
56763: LD_INT 5
56765: PUSH
56766: EMPTY
56767: LIST
56768: LIST
56769: PUSH
56770: EMPTY
56771: LIST
56772: LIST
56773: LIST
56774: LIST
56775: PUSH
56776: EMPTY
56777: LIST
56778: LIST
56779: LIST
56780: PPUSH
56781: CALL_OW 72
56785: ST_TO_ADDR
56786: GO 57010
56788: LD_INT 2
56790: DOUBLE
56791: EQUAL
56792: IFTRUE 56796
56794: GO 56858
56796: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
56797: LD_ADDR_VAR 0 12
56801: PUSH
56802: LD_VAR 0 18
56806: PPUSH
56807: LD_INT 22
56809: PUSH
56810: LD_VAR 0 16
56814: PUSH
56815: EMPTY
56816: LIST
56817: LIST
56818: PUSH
56819: LD_INT 2
56821: PUSH
56822: LD_INT 30
56824: PUSH
56825: LD_INT 0
56827: PUSH
56828: EMPTY
56829: LIST
56830: LIST
56831: PUSH
56832: LD_INT 30
56834: PUSH
56835: LD_INT 1
56837: PUSH
56838: EMPTY
56839: LIST
56840: LIST
56841: PUSH
56842: EMPTY
56843: LIST
56844: LIST
56845: LIST
56846: PUSH
56847: EMPTY
56848: LIST
56849: LIST
56850: PPUSH
56851: CALL_OW 72
56855: ST_TO_ADDR
56856: GO 57010
56858: LD_INT 3
56860: DOUBLE
56861: EQUAL
56862: IFTRUE 56866
56864: GO 56928
56866: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
56867: LD_ADDR_VAR 0 12
56871: PUSH
56872: LD_VAR 0 18
56876: PPUSH
56877: LD_INT 22
56879: PUSH
56880: LD_VAR 0 16
56884: PUSH
56885: EMPTY
56886: LIST
56887: LIST
56888: PUSH
56889: LD_INT 2
56891: PUSH
56892: LD_INT 30
56894: PUSH
56895: LD_INT 2
56897: PUSH
56898: EMPTY
56899: LIST
56900: LIST
56901: PUSH
56902: LD_INT 30
56904: PUSH
56905: LD_INT 3
56907: PUSH
56908: EMPTY
56909: LIST
56910: LIST
56911: PUSH
56912: EMPTY
56913: LIST
56914: LIST
56915: LIST
56916: PUSH
56917: EMPTY
56918: LIST
56919: LIST
56920: PPUSH
56921: CALL_OW 72
56925: ST_TO_ADDR
56926: GO 57010
56928: LD_INT 4
56930: DOUBLE
56931: EQUAL
56932: IFTRUE 56936
56934: GO 57009
56936: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
56937: LD_ADDR_VAR 0 12
56941: PUSH
56942: LD_VAR 0 18
56946: PPUSH
56947: LD_INT 22
56949: PUSH
56950: LD_VAR 0 16
56954: PUSH
56955: EMPTY
56956: LIST
56957: LIST
56958: PUSH
56959: LD_INT 2
56961: PUSH
56962: LD_INT 30
56964: PUSH
56965: LD_INT 6
56967: PUSH
56968: EMPTY
56969: LIST
56970: LIST
56971: PUSH
56972: LD_INT 30
56974: PUSH
56975: LD_INT 7
56977: PUSH
56978: EMPTY
56979: LIST
56980: LIST
56981: PUSH
56982: LD_INT 30
56984: PUSH
56985: LD_INT 8
56987: PUSH
56988: EMPTY
56989: LIST
56990: LIST
56991: PUSH
56992: EMPTY
56993: LIST
56994: LIST
56995: LIST
56996: LIST
56997: PUSH
56998: EMPTY
56999: LIST
57000: LIST
57001: PPUSH
57002: CALL_OW 72
57006: ST_TO_ADDR
57007: GO 57010
57009: POP
// if i = 1 then
57010: LD_VAR 0 8
57014: PUSH
57015: LD_INT 1
57017: EQUAL
57018: IFFALSE 57129
// begin tmp := [ ] ;
57020: LD_ADDR_VAR 0 19
57024: PUSH
57025: EMPTY
57026: ST_TO_ADDR
// for j in f do
57027: LD_ADDR_VAR 0 9
57031: PUSH
57032: LD_VAR 0 12
57036: PUSH
57037: FOR_IN
57038: IFFALSE 57111
// if GetBType ( j ) = b_bunker then
57040: LD_VAR 0 9
57044: PPUSH
57045: CALL_OW 266
57049: PUSH
57050: LD_INT 32
57052: EQUAL
57053: IFFALSE 57080
// tmp := Insert ( tmp , 1 , j ) else
57055: LD_ADDR_VAR 0 19
57059: PUSH
57060: LD_VAR 0 19
57064: PPUSH
57065: LD_INT 1
57067: PPUSH
57068: LD_VAR 0 9
57072: PPUSH
57073: CALL_OW 2
57077: ST_TO_ADDR
57078: GO 57109
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57080: LD_ADDR_VAR 0 19
57084: PUSH
57085: LD_VAR 0 19
57089: PPUSH
57090: LD_VAR 0 19
57094: PUSH
57095: LD_INT 1
57097: PLUS
57098: PPUSH
57099: LD_VAR 0 9
57103: PPUSH
57104: CALL_OW 2
57108: ST_TO_ADDR
57109: GO 57037
57111: POP
57112: POP
// if tmp then
57113: LD_VAR 0 19
57117: IFFALSE 57129
// f := tmp ;
57119: LD_ADDR_VAR 0 12
57123: PUSH
57124: LD_VAR 0 19
57128: ST_TO_ADDR
// end ; x := personel [ i ] ;
57129: LD_ADDR_VAR 0 13
57133: PUSH
57134: LD_VAR 0 6
57138: PUSH
57139: LD_VAR 0 8
57143: ARRAY
57144: ST_TO_ADDR
// if x = - 1 then
57145: LD_VAR 0 13
57149: PUSH
57150: LD_INT 1
57152: NEG
57153: EQUAL
57154: IFFALSE 57363
// begin for j in f do
57156: LD_ADDR_VAR 0 9
57160: PUSH
57161: LD_VAR 0 12
57165: PUSH
57166: FOR_IN
57167: IFFALSE 57359
// repeat InitHc ;
57169: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57173: LD_VAR 0 9
57177: PPUSH
57178: CALL_OW 266
57182: PUSH
57183: LD_INT 5
57185: EQUAL
57186: IFFALSE 57256
// begin if UnitsInside ( j ) < 3 then
57188: LD_VAR 0 9
57192: PPUSH
57193: CALL_OW 313
57197: PUSH
57198: LD_INT 3
57200: LESS
57201: IFFALSE 57237
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57203: LD_INT 0
57205: PPUSH
57206: LD_INT 5
57208: PUSH
57209: LD_INT 8
57211: PUSH
57212: LD_INT 9
57214: PUSH
57215: EMPTY
57216: LIST
57217: LIST
57218: LIST
57219: PUSH
57220: LD_VAR 0 17
57224: ARRAY
57225: PPUSH
57226: LD_VAR 0 4
57230: PPUSH
57231: CALL_OW 380
57235: GO 57254
// PrepareHuman ( false , i , skill ) ;
57237: LD_INT 0
57239: PPUSH
57240: LD_VAR 0 8
57244: PPUSH
57245: LD_VAR 0 4
57249: PPUSH
57250: CALL_OW 380
// end else
57254: GO 57273
// PrepareHuman ( false , i , skill ) ;
57256: LD_INT 0
57258: PPUSH
57259: LD_VAR 0 8
57263: PPUSH
57264: LD_VAR 0 4
57268: PPUSH
57269: CALL_OW 380
// un := CreateHuman ;
57273: LD_ADDR_VAR 0 14
57277: PUSH
57278: CALL_OW 44
57282: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57283: LD_ADDR_VAR 0 7
57287: PUSH
57288: LD_VAR 0 7
57292: PPUSH
57293: LD_INT 1
57295: PPUSH
57296: LD_VAR 0 14
57300: PPUSH
57301: CALL_OW 2
57305: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
57306: LD_VAR 0 14
57310: PPUSH
57311: LD_VAR 0 9
57315: PPUSH
57316: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
57320: LD_VAR 0 9
57324: PPUSH
57325: CALL_OW 313
57329: PUSH
57330: LD_INT 6
57332: EQUAL
57333: PUSH
57334: LD_VAR 0 9
57338: PPUSH
57339: CALL_OW 266
57343: PUSH
57344: LD_INT 32
57346: PUSH
57347: LD_INT 31
57349: PUSH
57350: EMPTY
57351: LIST
57352: LIST
57353: IN
57354: OR
57355: IFFALSE 57169
57357: GO 57166
57359: POP
57360: POP
// end else
57361: GO 57743
// for j = 1 to x do
57363: LD_ADDR_VAR 0 9
57367: PUSH
57368: DOUBLE
57369: LD_INT 1
57371: DEC
57372: ST_TO_ADDR
57373: LD_VAR 0 13
57377: PUSH
57378: FOR_TO
57379: IFFALSE 57741
// begin InitHc ;
57381: CALL_OW 19
// if not f then
57385: LD_VAR 0 12
57389: NOT
57390: IFFALSE 57479
// begin PrepareHuman ( false , i , skill ) ;
57392: LD_INT 0
57394: PPUSH
57395: LD_VAR 0 8
57399: PPUSH
57400: LD_VAR 0 4
57404: PPUSH
57405: CALL_OW 380
// un := CreateHuman ;
57409: LD_ADDR_VAR 0 14
57413: PUSH
57414: CALL_OW 44
57418: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57419: LD_ADDR_VAR 0 7
57423: PUSH
57424: LD_VAR 0 7
57428: PPUSH
57429: LD_INT 1
57431: PPUSH
57432: LD_VAR 0 14
57436: PPUSH
57437: CALL_OW 2
57441: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57442: LD_VAR 0 14
57446: PPUSH
57447: LD_VAR 0 1
57451: PPUSH
57452: CALL_OW 250
57456: PPUSH
57457: LD_VAR 0 1
57461: PPUSH
57462: CALL_OW 251
57466: PPUSH
57467: LD_INT 10
57469: PPUSH
57470: LD_INT 0
57472: PPUSH
57473: CALL_OW 50
// continue ;
57477: GO 57378
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
57479: LD_VAR 0 12
57483: PUSH
57484: LD_INT 1
57486: ARRAY
57487: PPUSH
57488: CALL_OW 313
57492: PUSH
57493: LD_VAR 0 12
57497: PUSH
57498: LD_INT 1
57500: ARRAY
57501: PPUSH
57502: CALL_OW 266
57506: PUSH
57507: LD_INT 32
57509: PUSH
57510: LD_INT 31
57512: PUSH
57513: EMPTY
57514: LIST
57515: LIST
57516: IN
57517: AND
57518: PUSH
57519: LD_VAR 0 12
57523: PUSH
57524: LD_INT 1
57526: ARRAY
57527: PPUSH
57528: CALL_OW 313
57532: PUSH
57533: LD_INT 6
57535: EQUAL
57536: OR
57537: IFFALSE 57557
// f := Delete ( f , 1 ) ;
57539: LD_ADDR_VAR 0 12
57543: PUSH
57544: LD_VAR 0 12
57548: PPUSH
57549: LD_INT 1
57551: PPUSH
57552: CALL_OW 3
57556: ST_TO_ADDR
// if not f then
57557: LD_VAR 0 12
57561: NOT
57562: IFFALSE 57580
// begin x := x + 2 ;
57564: LD_ADDR_VAR 0 13
57568: PUSH
57569: LD_VAR 0 13
57573: PUSH
57574: LD_INT 2
57576: PLUS
57577: ST_TO_ADDR
// continue ;
57578: GO 57378
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
57580: LD_VAR 0 12
57584: PUSH
57585: LD_INT 1
57587: ARRAY
57588: PPUSH
57589: CALL_OW 266
57593: PUSH
57594: LD_INT 5
57596: EQUAL
57597: IFFALSE 57671
// begin if UnitsInside ( f [ 1 ] ) < 3 then
57599: LD_VAR 0 12
57603: PUSH
57604: LD_INT 1
57606: ARRAY
57607: PPUSH
57608: CALL_OW 313
57612: PUSH
57613: LD_INT 3
57615: LESS
57616: IFFALSE 57652
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57618: LD_INT 0
57620: PPUSH
57621: LD_INT 5
57623: PUSH
57624: LD_INT 8
57626: PUSH
57627: LD_INT 9
57629: PUSH
57630: EMPTY
57631: LIST
57632: LIST
57633: LIST
57634: PUSH
57635: LD_VAR 0 17
57639: ARRAY
57640: PPUSH
57641: LD_VAR 0 4
57645: PPUSH
57646: CALL_OW 380
57650: GO 57669
// PrepareHuman ( false , i , skill ) ;
57652: LD_INT 0
57654: PPUSH
57655: LD_VAR 0 8
57659: PPUSH
57660: LD_VAR 0 4
57664: PPUSH
57665: CALL_OW 380
// end else
57669: GO 57688
// PrepareHuman ( false , i , skill ) ;
57671: LD_INT 0
57673: PPUSH
57674: LD_VAR 0 8
57678: PPUSH
57679: LD_VAR 0 4
57683: PPUSH
57684: CALL_OW 380
// un := CreateHuman ;
57688: LD_ADDR_VAR 0 14
57692: PUSH
57693: CALL_OW 44
57697: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57698: LD_ADDR_VAR 0 7
57702: PUSH
57703: LD_VAR 0 7
57707: PPUSH
57708: LD_INT 1
57710: PPUSH
57711: LD_VAR 0 14
57715: PPUSH
57716: CALL_OW 2
57720: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
57721: LD_VAR 0 14
57725: PPUSH
57726: LD_VAR 0 12
57730: PUSH
57731: LD_INT 1
57733: ARRAY
57734: PPUSH
57735: CALL_OW 52
// end ;
57739: GO 57378
57741: POP
57742: POP
// end ;
57743: GO 56680
57745: POP
57746: POP
// result := result ^ buildings ;
57747: LD_ADDR_VAR 0 7
57751: PUSH
57752: LD_VAR 0 7
57756: PUSH
57757: LD_VAR 0 18
57761: ADD
57762: ST_TO_ADDR
// end else
57763: GO 57906
// begin for i = 1 to personel do
57765: LD_ADDR_VAR 0 8
57769: PUSH
57770: DOUBLE
57771: LD_INT 1
57773: DEC
57774: ST_TO_ADDR
57775: LD_VAR 0 6
57779: PUSH
57780: FOR_TO
57781: IFFALSE 57904
// begin if i > 4 then
57783: LD_VAR 0 8
57787: PUSH
57788: LD_INT 4
57790: GREATER
57791: IFFALSE 57795
// break ;
57793: GO 57904
// x := personel [ i ] ;
57795: LD_ADDR_VAR 0 13
57799: PUSH
57800: LD_VAR 0 6
57804: PUSH
57805: LD_VAR 0 8
57809: ARRAY
57810: ST_TO_ADDR
// if x = - 1 then
57811: LD_VAR 0 13
57815: PUSH
57816: LD_INT 1
57818: NEG
57819: EQUAL
57820: IFFALSE 57824
// continue ;
57822: GO 57780
// PrepareHuman ( false , i , skill ) ;
57824: LD_INT 0
57826: PPUSH
57827: LD_VAR 0 8
57831: PPUSH
57832: LD_VAR 0 4
57836: PPUSH
57837: CALL_OW 380
// un := CreateHuman ;
57841: LD_ADDR_VAR 0 14
57845: PUSH
57846: CALL_OW 44
57850: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57851: LD_VAR 0 14
57855: PPUSH
57856: LD_VAR 0 1
57860: PPUSH
57861: CALL_OW 250
57865: PPUSH
57866: LD_VAR 0 1
57870: PPUSH
57871: CALL_OW 251
57875: PPUSH
57876: LD_INT 10
57878: PPUSH
57879: LD_INT 0
57881: PPUSH
57882: CALL_OW 50
// result := result ^ un ;
57886: LD_ADDR_VAR 0 7
57890: PUSH
57891: LD_VAR 0 7
57895: PUSH
57896: LD_VAR 0 14
57900: ADD
57901: ST_TO_ADDR
// end ;
57902: GO 57780
57904: POP
57905: POP
// end ; end ;
57906: LD_VAR 0 7
57910: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
57911: LD_INT 0
57913: PPUSH
57914: PPUSH
57915: PPUSH
57916: PPUSH
57917: PPUSH
57918: PPUSH
57919: PPUSH
57920: PPUSH
57921: PPUSH
57922: PPUSH
57923: PPUSH
57924: PPUSH
57925: PPUSH
57926: PPUSH
57927: PPUSH
57928: PPUSH
// result := false ;
57929: LD_ADDR_VAR 0 3
57933: PUSH
57934: LD_INT 0
57936: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
57937: LD_VAR 0 1
57941: NOT
57942: PUSH
57943: LD_VAR 0 1
57947: PPUSH
57948: CALL_OW 266
57952: PUSH
57953: LD_INT 32
57955: PUSH
57956: LD_INT 33
57958: PUSH
57959: EMPTY
57960: LIST
57961: LIST
57962: IN
57963: NOT
57964: OR
57965: IFFALSE 57969
// exit ;
57967: GO 59108
// nat := GetNation ( tower ) ;
57969: LD_ADDR_VAR 0 12
57973: PUSH
57974: LD_VAR 0 1
57978: PPUSH
57979: CALL_OW 248
57983: ST_TO_ADDR
// side := GetSide ( tower ) ;
57984: LD_ADDR_VAR 0 16
57988: PUSH
57989: LD_VAR 0 1
57993: PPUSH
57994: CALL_OW 255
57998: ST_TO_ADDR
// x := GetX ( tower ) ;
57999: LD_ADDR_VAR 0 10
58003: PUSH
58004: LD_VAR 0 1
58008: PPUSH
58009: CALL_OW 250
58013: ST_TO_ADDR
// y := GetY ( tower ) ;
58014: LD_ADDR_VAR 0 11
58018: PUSH
58019: LD_VAR 0 1
58023: PPUSH
58024: CALL_OW 251
58028: ST_TO_ADDR
// if not x or not y then
58029: LD_VAR 0 10
58033: NOT
58034: PUSH
58035: LD_VAR 0 11
58039: NOT
58040: OR
58041: IFFALSE 58045
// exit ;
58043: GO 59108
// weapon := 0 ;
58045: LD_ADDR_VAR 0 18
58049: PUSH
58050: LD_INT 0
58052: ST_TO_ADDR
// fac_list := [ ] ;
58053: LD_ADDR_VAR 0 17
58057: PUSH
58058: EMPTY
58059: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58060: LD_ADDR_VAR 0 6
58064: PUSH
58065: LD_VAR 0 1
58069: PPUSH
58070: CALL_OW 274
58074: PPUSH
58075: LD_VAR 0 2
58079: PPUSH
58080: LD_INT 0
58082: PPUSH
58083: CALL 55648 0 3
58087: PPUSH
58088: LD_INT 30
58090: PUSH
58091: LD_INT 3
58093: PUSH
58094: EMPTY
58095: LIST
58096: LIST
58097: PPUSH
58098: CALL_OW 72
58102: ST_TO_ADDR
// if not factories then
58103: LD_VAR 0 6
58107: NOT
58108: IFFALSE 58112
// exit ;
58110: GO 59108
// for i in factories do
58112: LD_ADDR_VAR 0 8
58116: PUSH
58117: LD_VAR 0 6
58121: PUSH
58122: FOR_IN
58123: IFFALSE 58148
// fac_list := fac_list union AvailableWeaponList ( i ) ;
58125: LD_ADDR_VAR 0 17
58129: PUSH
58130: LD_VAR 0 17
58134: PUSH
58135: LD_VAR 0 8
58139: PPUSH
58140: CALL_OW 478
58144: UNION
58145: ST_TO_ADDR
58146: GO 58122
58148: POP
58149: POP
// if not fac_list then
58150: LD_VAR 0 17
58154: NOT
58155: IFFALSE 58159
// exit ;
58157: GO 59108
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58159: LD_ADDR_VAR 0 5
58163: PUSH
58164: LD_INT 4
58166: PUSH
58167: LD_INT 5
58169: PUSH
58170: LD_INT 9
58172: PUSH
58173: LD_INT 10
58175: PUSH
58176: LD_INT 6
58178: PUSH
58179: LD_INT 7
58181: PUSH
58182: LD_INT 11
58184: PUSH
58185: EMPTY
58186: LIST
58187: LIST
58188: LIST
58189: LIST
58190: LIST
58191: LIST
58192: LIST
58193: PUSH
58194: LD_INT 27
58196: PUSH
58197: LD_INT 28
58199: PUSH
58200: LD_INT 26
58202: PUSH
58203: LD_INT 30
58205: PUSH
58206: EMPTY
58207: LIST
58208: LIST
58209: LIST
58210: LIST
58211: PUSH
58212: LD_INT 43
58214: PUSH
58215: LD_INT 44
58217: PUSH
58218: LD_INT 46
58220: PUSH
58221: LD_INT 45
58223: PUSH
58224: LD_INT 47
58226: PUSH
58227: LD_INT 49
58229: PUSH
58230: EMPTY
58231: LIST
58232: LIST
58233: LIST
58234: LIST
58235: LIST
58236: LIST
58237: PUSH
58238: EMPTY
58239: LIST
58240: LIST
58241: LIST
58242: PUSH
58243: LD_VAR 0 12
58247: ARRAY
58248: ST_TO_ADDR
// for i in list do
58249: LD_ADDR_VAR 0 8
58253: PUSH
58254: LD_VAR 0 5
58258: PUSH
58259: FOR_IN
58260: IFFALSE 58293
// if not i in fac_list then
58262: LD_VAR 0 8
58266: PUSH
58267: LD_VAR 0 17
58271: IN
58272: NOT
58273: IFFALSE 58291
// list := list diff i ;
58275: LD_ADDR_VAR 0 5
58279: PUSH
58280: LD_VAR 0 5
58284: PUSH
58285: LD_VAR 0 8
58289: DIFF
58290: ST_TO_ADDR
58291: GO 58259
58293: POP
58294: POP
// if not list then
58295: LD_VAR 0 5
58299: NOT
58300: IFFALSE 58304
// exit ;
58302: GO 59108
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
58304: LD_VAR 0 12
58308: PUSH
58309: LD_INT 3
58311: EQUAL
58312: PUSH
58313: LD_INT 49
58315: PUSH
58316: LD_VAR 0 5
58320: IN
58321: AND
58322: PUSH
58323: LD_INT 31
58325: PPUSH
58326: LD_VAR 0 16
58330: PPUSH
58331: CALL_OW 321
58335: PUSH
58336: LD_INT 2
58338: EQUAL
58339: AND
58340: IFFALSE 58400
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
58342: LD_INT 22
58344: PUSH
58345: LD_VAR 0 16
58349: PUSH
58350: EMPTY
58351: LIST
58352: LIST
58353: PUSH
58354: LD_INT 35
58356: PUSH
58357: LD_INT 49
58359: PUSH
58360: EMPTY
58361: LIST
58362: LIST
58363: PUSH
58364: LD_INT 91
58366: PUSH
58367: LD_VAR 0 1
58371: PUSH
58372: LD_INT 10
58374: PUSH
58375: EMPTY
58376: LIST
58377: LIST
58378: LIST
58379: PUSH
58380: EMPTY
58381: LIST
58382: LIST
58383: LIST
58384: PPUSH
58385: CALL_OW 69
58389: NOT
58390: IFFALSE 58400
// weapon := ru_time_lapser ;
58392: LD_ADDR_VAR 0 18
58396: PUSH
58397: LD_INT 49
58399: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
58400: LD_VAR 0 12
58404: PUSH
58405: LD_INT 1
58407: PUSH
58408: LD_INT 2
58410: PUSH
58411: EMPTY
58412: LIST
58413: LIST
58414: IN
58415: PUSH
58416: LD_INT 11
58418: PUSH
58419: LD_VAR 0 5
58423: IN
58424: PUSH
58425: LD_INT 30
58427: PUSH
58428: LD_VAR 0 5
58432: IN
58433: OR
58434: AND
58435: PUSH
58436: LD_INT 6
58438: PPUSH
58439: LD_VAR 0 16
58443: PPUSH
58444: CALL_OW 321
58448: PUSH
58449: LD_INT 2
58451: EQUAL
58452: AND
58453: IFFALSE 58618
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
58455: LD_INT 22
58457: PUSH
58458: LD_VAR 0 16
58462: PUSH
58463: EMPTY
58464: LIST
58465: LIST
58466: PUSH
58467: LD_INT 2
58469: PUSH
58470: LD_INT 35
58472: PUSH
58473: LD_INT 11
58475: PUSH
58476: EMPTY
58477: LIST
58478: LIST
58479: PUSH
58480: LD_INT 35
58482: PUSH
58483: LD_INT 30
58485: PUSH
58486: EMPTY
58487: LIST
58488: LIST
58489: PUSH
58490: EMPTY
58491: LIST
58492: LIST
58493: LIST
58494: PUSH
58495: LD_INT 91
58497: PUSH
58498: LD_VAR 0 1
58502: PUSH
58503: LD_INT 18
58505: PUSH
58506: EMPTY
58507: LIST
58508: LIST
58509: LIST
58510: PUSH
58511: EMPTY
58512: LIST
58513: LIST
58514: LIST
58515: PPUSH
58516: CALL_OW 69
58520: NOT
58521: PUSH
58522: LD_INT 22
58524: PUSH
58525: LD_VAR 0 16
58529: PUSH
58530: EMPTY
58531: LIST
58532: LIST
58533: PUSH
58534: LD_INT 2
58536: PUSH
58537: LD_INT 30
58539: PUSH
58540: LD_INT 32
58542: PUSH
58543: EMPTY
58544: LIST
58545: LIST
58546: PUSH
58547: LD_INT 30
58549: PUSH
58550: LD_INT 33
58552: PUSH
58553: EMPTY
58554: LIST
58555: LIST
58556: PUSH
58557: EMPTY
58558: LIST
58559: LIST
58560: LIST
58561: PUSH
58562: LD_INT 91
58564: PUSH
58565: LD_VAR 0 1
58569: PUSH
58570: LD_INT 12
58572: PUSH
58573: EMPTY
58574: LIST
58575: LIST
58576: LIST
58577: PUSH
58578: EMPTY
58579: LIST
58580: LIST
58581: LIST
58582: PUSH
58583: EMPTY
58584: LIST
58585: PPUSH
58586: CALL_OW 69
58590: PUSH
58591: LD_INT 2
58593: GREATER
58594: AND
58595: IFFALSE 58618
// weapon := [ us_radar , ar_radar ] [ nat ] ;
58597: LD_ADDR_VAR 0 18
58601: PUSH
58602: LD_INT 11
58604: PUSH
58605: LD_INT 30
58607: PUSH
58608: EMPTY
58609: LIST
58610: LIST
58611: PUSH
58612: LD_VAR 0 12
58616: ARRAY
58617: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
58618: LD_VAR 0 18
58622: NOT
58623: PUSH
58624: LD_INT 40
58626: PPUSH
58627: LD_VAR 0 16
58631: PPUSH
58632: CALL_OW 321
58636: PUSH
58637: LD_INT 2
58639: EQUAL
58640: AND
58641: PUSH
58642: LD_INT 7
58644: PUSH
58645: LD_VAR 0 5
58649: IN
58650: PUSH
58651: LD_INT 28
58653: PUSH
58654: LD_VAR 0 5
58658: IN
58659: OR
58660: PUSH
58661: LD_INT 45
58663: PUSH
58664: LD_VAR 0 5
58668: IN
58669: OR
58670: AND
58671: IFFALSE 58925
// begin hex := GetHexInfo ( x , y ) ;
58673: LD_ADDR_VAR 0 4
58677: PUSH
58678: LD_VAR 0 10
58682: PPUSH
58683: LD_VAR 0 11
58687: PPUSH
58688: CALL_OW 546
58692: ST_TO_ADDR
// if hex [ 1 ] then
58693: LD_VAR 0 4
58697: PUSH
58698: LD_INT 1
58700: ARRAY
58701: IFFALSE 58705
// exit ;
58703: GO 59108
// height := hex [ 2 ] ;
58705: LD_ADDR_VAR 0 15
58709: PUSH
58710: LD_VAR 0 4
58714: PUSH
58715: LD_INT 2
58717: ARRAY
58718: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
58719: LD_ADDR_VAR 0 14
58723: PUSH
58724: LD_INT 0
58726: PUSH
58727: LD_INT 2
58729: PUSH
58730: LD_INT 3
58732: PUSH
58733: LD_INT 5
58735: PUSH
58736: EMPTY
58737: LIST
58738: LIST
58739: LIST
58740: LIST
58741: ST_TO_ADDR
// for i in tmp do
58742: LD_ADDR_VAR 0 8
58746: PUSH
58747: LD_VAR 0 14
58751: PUSH
58752: FOR_IN
58753: IFFALSE 58923
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
58755: LD_ADDR_VAR 0 9
58759: PUSH
58760: LD_VAR 0 10
58764: PPUSH
58765: LD_VAR 0 8
58769: PPUSH
58770: LD_INT 5
58772: PPUSH
58773: CALL_OW 272
58777: PUSH
58778: LD_VAR 0 11
58782: PPUSH
58783: LD_VAR 0 8
58787: PPUSH
58788: LD_INT 5
58790: PPUSH
58791: CALL_OW 273
58795: PUSH
58796: EMPTY
58797: LIST
58798: LIST
58799: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
58800: LD_VAR 0 9
58804: PUSH
58805: LD_INT 1
58807: ARRAY
58808: PPUSH
58809: LD_VAR 0 9
58813: PUSH
58814: LD_INT 2
58816: ARRAY
58817: PPUSH
58818: CALL_OW 488
58822: IFFALSE 58921
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
58824: LD_ADDR_VAR 0 4
58828: PUSH
58829: LD_VAR 0 9
58833: PUSH
58834: LD_INT 1
58836: ARRAY
58837: PPUSH
58838: LD_VAR 0 9
58842: PUSH
58843: LD_INT 2
58845: ARRAY
58846: PPUSH
58847: CALL_OW 546
58851: ST_TO_ADDR
// if hex [ 1 ] then
58852: LD_VAR 0 4
58856: PUSH
58857: LD_INT 1
58859: ARRAY
58860: IFFALSE 58864
// continue ;
58862: GO 58752
// h := hex [ 2 ] ;
58864: LD_ADDR_VAR 0 13
58868: PUSH
58869: LD_VAR 0 4
58873: PUSH
58874: LD_INT 2
58876: ARRAY
58877: ST_TO_ADDR
// if h + 7 < height then
58878: LD_VAR 0 13
58882: PUSH
58883: LD_INT 7
58885: PLUS
58886: PUSH
58887: LD_VAR 0 15
58891: LESS
58892: IFFALSE 58921
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
58894: LD_ADDR_VAR 0 18
58898: PUSH
58899: LD_INT 7
58901: PUSH
58902: LD_INT 28
58904: PUSH
58905: LD_INT 45
58907: PUSH
58908: EMPTY
58909: LIST
58910: LIST
58911: LIST
58912: PUSH
58913: LD_VAR 0 12
58917: ARRAY
58918: ST_TO_ADDR
// break ;
58919: GO 58923
// end ; end ; end ;
58921: GO 58752
58923: POP
58924: POP
// end ; if not weapon then
58925: LD_VAR 0 18
58929: NOT
58930: IFFALSE 58990
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
58932: LD_ADDR_VAR 0 5
58936: PUSH
58937: LD_VAR 0 5
58941: PUSH
58942: LD_INT 11
58944: PUSH
58945: LD_INT 30
58947: PUSH
58948: LD_INT 49
58950: PUSH
58951: EMPTY
58952: LIST
58953: LIST
58954: LIST
58955: DIFF
58956: ST_TO_ADDR
// if not list then
58957: LD_VAR 0 5
58961: NOT
58962: IFFALSE 58966
// exit ;
58964: GO 59108
// weapon := list [ rand ( 1 , list ) ] ;
58966: LD_ADDR_VAR 0 18
58970: PUSH
58971: LD_VAR 0 5
58975: PUSH
58976: LD_INT 1
58978: PPUSH
58979: LD_VAR 0 5
58983: PPUSH
58984: CALL_OW 12
58988: ARRAY
58989: ST_TO_ADDR
// end ; if weapon then
58990: LD_VAR 0 18
58994: IFFALSE 59108
// begin tmp := CostOfWeapon ( weapon ) ;
58996: LD_ADDR_VAR 0 14
59000: PUSH
59001: LD_VAR 0 18
59005: PPUSH
59006: CALL_OW 451
59010: ST_TO_ADDR
// j := GetBase ( tower ) ;
59011: LD_ADDR_VAR 0 9
59015: PUSH
59016: LD_VAR 0 1
59020: PPUSH
59021: CALL_OW 274
59025: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59026: LD_VAR 0 9
59030: PPUSH
59031: LD_INT 1
59033: PPUSH
59034: CALL_OW 275
59038: PUSH
59039: LD_VAR 0 14
59043: PUSH
59044: LD_INT 1
59046: ARRAY
59047: GREATEREQUAL
59048: PUSH
59049: LD_VAR 0 9
59053: PPUSH
59054: LD_INT 2
59056: PPUSH
59057: CALL_OW 275
59061: PUSH
59062: LD_VAR 0 14
59066: PUSH
59067: LD_INT 2
59069: ARRAY
59070: GREATEREQUAL
59071: AND
59072: PUSH
59073: LD_VAR 0 9
59077: PPUSH
59078: LD_INT 3
59080: PPUSH
59081: CALL_OW 275
59085: PUSH
59086: LD_VAR 0 14
59090: PUSH
59091: LD_INT 3
59093: ARRAY
59094: GREATEREQUAL
59095: AND
59096: IFFALSE 59108
// result := weapon ;
59098: LD_ADDR_VAR 0 3
59102: PUSH
59103: LD_VAR 0 18
59107: ST_TO_ADDR
// end ; end ;
59108: LD_VAR 0 3
59112: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59113: LD_INT 0
59115: PPUSH
59116: PPUSH
// result := true ;
59117: LD_ADDR_VAR 0 3
59121: PUSH
59122: LD_INT 1
59124: ST_TO_ADDR
// if array1 = array2 then
59125: LD_VAR 0 1
59129: PUSH
59130: LD_VAR 0 2
59134: EQUAL
59135: IFFALSE 59195
// begin for i = 1 to array1 do
59137: LD_ADDR_VAR 0 4
59141: PUSH
59142: DOUBLE
59143: LD_INT 1
59145: DEC
59146: ST_TO_ADDR
59147: LD_VAR 0 1
59151: PUSH
59152: FOR_TO
59153: IFFALSE 59191
// if array1 [ i ] <> array2 [ i ] then
59155: LD_VAR 0 1
59159: PUSH
59160: LD_VAR 0 4
59164: ARRAY
59165: PUSH
59166: LD_VAR 0 2
59170: PUSH
59171: LD_VAR 0 4
59175: ARRAY
59176: NONEQUAL
59177: IFFALSE 59189
// begin result := false ;
59179: LD_ADDR_VAR 0 3
59183: PUSH
59184: LD_INT 0
59186: ST_TO_ADDR
// break ;
59187: GO 59191
// end ;
59189: GO 59152
59191: POP
59192: POP
// end else
59193: GO 59203
// result := false ;
59195: LD_ADDR_VAR 0 3
59199: PUSH
59200: LD_INT 0
59202: ST_TO_ADDR
// end ;
59203: LD_VAR 0 3
59207: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
59208: LD_INT 0
59210: PPUSH
59211: PPUSH
// if not array1 or not array2 then
59212: LD_VAR 0 1
59216: NOT
59217: PUSH
59218: LD_VAR 0 2
59222: NOT
59223: OR
59224: IFFALSE 59228
// exit ;
59226: GO 59292
// result := true ;
59228: LD_ADDR_VAR 0 3
59232: PUSH
59233: LD_INT 1
59235: ST_TO_ADDR
// for i = 1 to array1 do
59236: LD_ADDR_VAR 0 4
59240: PUSH
59241: DOUBLE
59242: LD_INT 1
59244: DEC
59245: ST_TO_ADDR
59246: LD_VAR 0 1
59250: PUSH
59251: FOR_TO
59252: IFFALSE 59290
// if array1 [ i ] <> array2 [ i ] then
59254: LD_VAR 0 1
59258: PUSH
59259: LD_VAR 0 4
59263: ARRAY
59264: PUSH
59265: LD_VAR 0 2
59269: PUSH
59270: LD_VAR 0 4
59274: ARRAY
59275: NONEQUAL
59276: IFFALSE 59288
// begin result := false ;
59278: LD_ADDR_VAR 0 3
59282: PUSH
59283: LD_INT 0
59285: ST_TO_ADDR
// break ;
59286: GO 59290
// end ;
59288: GO 59251
59290: POP
59291: POP
// end ;
59292: LD_VAR 0 3
59296: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
59297: LD_INT 0
59299: PPUSH
59300: PPUSH
59301: PPUSH
// pom := GetBase ( fac ) ;
59302: LD_ADDR_VAR 0 5
59306: PUSH
59307: LD_VAR 0 1
59311: PPUSH
59312: CALL_OW 274
59316: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
59317: LD_ADDR_VAR 0 4
59321: PUSH
59322: LD_VAR 0 2
59326: PUSH
59327: LD_INT 1
59329: ARRAY
59330: PPUSH
59331: LD_VAR 0 2
59335: PUSH
59336: LD_INT 2
59338: ARRAY
59339: PPUSH
59340: LD_VAR 0 2
59344: PUSH
59345: LD_INT 3
59347: ARRAY
59348: PPUSH
59349: LD_VAR 0 2
59353: PUSH
59354: LD_INT 4
59356: ARRAY
59357: PPUSH
59358: CALL_OW 449
59362: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59363: LD_ADDR_VAR 0 3
59367: PUSH
59368: LD_VAR 0 5
59372: PPUSH
59373: LD_INT 1
59375: PPUSH
59376: CALL_OW 275
59380: PUSH
59381: LD_VAR 0 4
59385: PUSH
59386: LD_INT 1
59388: ARRAY
59389: GREATEREQUAL
59390: PUSH
59391: LD_VAR 0 5
59395: PPUSH
59396: LD_INT 2
59398: PPUSH
59399: CALL_OW 275
59403: PUSH
59404: LD_VAR 0 4
59408: PUSH
59409: LD_INT 2
59411: ARRAY
59412: GREATEREQUAL
59413: AND
59414: PUSH
59415: LD_VAR 0 5
59419: PPUSH
59420: LD_INT 3
59422: PPUSH
59423: CALL_OW 275
59427: PUSH
59428: LD_VAR 0 4
59432: PUSH
59433: LD_INT 3
59435: ARRAY
59436: GREATEREQUAL
59437: AND
59438: ST_TO_ADDR
// end ;
59439: LD_VAR 0 3
59443: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
59444: LD_INT 0
59446: PPUSH
59447: PPUSH
59448: PPUSH
59449: PPUSH
// pom := GetBase ( building ) ;
59450: LD_ADDR_VAR 0 3
59454: PUSH
59455: LD_VAR 0 1
59459: PPUSH
59460: CALL_OW 274
59464: ST_TO_ADDR
// if not pom then
59465: LD_VAR 0 3
59469: NOT
59470: IFFALSE 59474
// exit ;
59472: GO 59644
// btype := GetBType ( building ) ;
59474: LD_ADDR_VAR 0 5
59478: PUSH
59479: LD_VAR 0 1
59483: PPUSH
59484: CALL_OW 266
59488: ST_TO_ADDR
// if btype = b_armoury then
59489: LD_VAR 0 5
59493: PUSH
59494: LD_INT 4
59496: EQUAL
59497: IFFALSE 59507
// btype := b_barracks ;
59499: LD_ADDR_VAR 0 5
59503: PUSH
59504: LD_INT 5
59506: ST_TO_ADDR
// if btype = b_depot then
59507: LD_VAR 0 5
59511: PUSH
59512: LD_INT 0
59514: EQUAL
59515: IFFALSE 59525
// btype := b_warehouse ;
59517: LD_ADDR_VAR 0 5
59521: PUSH
59522: LD_INT 1
59524: ST_TO_ADDR
// if btype = b_workshop then
59525: LD_VAR 0 5
59529: PUSH
59530: LD_INT 2
59532: EQUAL
59533: IFFALSE 59543
// btype := b_factory ;
59535: LD_ADDR_VAR 0 5
59539: PUSH
59540: LD_INT 3
59542: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
59543: LD_ADDR_VAR 0 4
59547: PUSH
59548: LD_VAR 0 5
59552: PPUSH
59553: LD_VAR 0 1
59557: PPUSH
59558: CALL_OW 248
59562: PPUSH
59563: CALL_OW 450
59567: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59568: LD_ADDR_VAR 0 2
59572: PUSH
59573: LD_VAR 0 3
59577: PPUSH
59578: LD_INT 1
59580: PPUSH
59581: CALL_OW 275
59585: PUSH
59586: LD_VAR 0 4
59590: PUSH
59591: LD_INT 1
59593: ARRAY
59594: GREATEREQUAL
59595: PUSH
59596: LD_VAR 0 3
59600: PPUSH
59601: LD_INT 2
59603: PPUSH
59604: CALL_OW 275
59608: PUSH
59609: LD_VAR 0 4
59613: PUSH
59614: LD_INT 2
59616: ARRAY
59617: GREATEREQUAL
59618: AND
59619: PUSH
59620: LD_VAR 0 3
59624: PPUSH
59625: LD_INT 3
59627: PPUSH
59628: CALL_OW 275
59632: PUSH
59633: LD_VAR 0 4
59637: PUSH
59638: LD_INT 3
59640: ARRAY
59641: GREATEREQUAL
59642: AND
59643: ST_TO_ADDR
// end ;
59644: LD_VAR 0 2
59648: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
59649: LD_INT 0
59651: PPUSH
59652: PPUSH
59653: PPUSH
// pom := GetBase ( building ) ;
59654: LD_ADDR_VAR 0 4
59658: PUSH
59659: LD_VAR 0 1
59663: PPUSH
59664: CALL_OW 274
59668: ST_TO_ADDR
// if not pom then
59669: LD_VAR 0 4
59673: NOT
59674: IFFALSE 59678
// exit ;
59676: GO 59779
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
59678: LD_ADDR_VAR 0 5
59682: PUSH
59683: LD_VAR 0 2
59687: PPUSH
59688: LD_VAR 0 1
59692: PPUSH
59693: CALL_OW 248
59697: PPUSH
59698: CALL_OW 450
59702: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59703: LD_ADDR_VAR 0 3
59707: PUSH
59708: LD_VAR 0 4
59712: PPUSH
59713: LD_INT 1
59715: PPUSH
59716: CALL_OW 275
59720: PUSH
59721: LD_VAR 0 5
59725: PUSH
59726: LD_INT 1
59728: ARRAY
59729: GREATEREQUAL
59730: PUSH
59731: LD_VAR 0 4
59735: PPUSH
59736: LD_INT 2
59738: PPUSH
59739: CALL_OW 275
59743: PUSH
59744: LD_VAR 0 5
59748: PUSH
59749: LD_INT 2
59751: ARRAY
59752: GREATEREQUAL
59753: AND
59754: PUSH
59755: LD_VAR 0 4
59759: PPUSH
59760: LD_INT 3
59762: PPUSH
59763: CALL_OW 275
59767: PUSH
59768: LD_VAR 0 5
59772: PUSH
59773: LD_INT 3
59775: ARRAY
59776: GREATEREQUAL
59777: AND
59778: ST_TO_ADDR
// end ;
59779: LD_VAR 0 3
59783: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
59784: LD_INT 0
59786: PPUSH
59787: PPUSH
59788: PPUSH
59789: PPUSH
59790: PPUSH
59791: PPUSH
59792: PPUSH
59793: PPUSH
59794: PPUSH
59795: PPUSH
59796: PPUSH
// result := false ;
59797: LD_ADDR_VAR 0 8
59801: PUSH
59802: LD_INT 0
59804: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
59805: LD_VAR 0 5
59809: NOT
59810: PUSH
59811: LD_VAR 0 1
59815: NOT
59816: OR
59817: PUSH
59818: LD_VAR 0 2
59822: NOT
59823: OR
59824: PUSH
59825: LD_VAR 0 3
59829: NOT
59830: OR
59831: IFFALSE 59835
// exit ;
59833: GO 60649
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
59835: LD_ADDR_VAR 0 14
59839: PUSH
59840: LD_VAR 0 1
59844: PPUSH
59845: LD_VAR 0 2
59849: PPUSH
59850: LD_VAR 0 3
59854: PPUSH
59855: LD_VAR 0 4
59859: PPUSH
59860: LD_VAR 0 5
59864: PUSH
59865: LD_INT 1
59867: ARRAY
59868: PPUSH
59869: CALL_OW 248
59873: PPUSH
59874: LD_INT 0
59876: PPUSH
59877: CALL 61486 0 6
59881: ST_TO_ADDR
// if not hexes then
59882: LD_VAR 0 14
59886: NOT
59887: IFFALSE 59891
// exit ;
59889: GO 60649
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
59891: LD_ADDR_VAR 0 17
59895: PUSH
59896: LD_VAR 0 5
59900: PPUSH
59901: LD_INT 22
59903: PUSH
59904: LD_VAR 0 13
59908: PPUSH
59909: CALL_OW 255
59913: PUSH
59914: EMPTY
59915: LIST
59916: LIST
59917: PUSH
59918: LD_INT 2
59920: PUSH
59921: LD_INT 30
59923: PUSH
59924: LD_INT 0
59926: PUSH
59927: EMPTY
59928: LIST
59929: LIST
59930: PUSH
59931: LD_INT 30
59933: PUSH
59934: LD_INT 1
59936: PUSH
59937: EMPTY
59938: LIST
59939: LIST
59940: PUSH
59941: EMPTY
59942: LIST
59943: LIST
59944: LIST
59945: PUSH
59946: EMPTY
59947: LIST
59948: LIST
59949: PPUSH
59950: CALL_OW 72
59954: ST_TO_ADDR
// for i = 1 to hexes do
59955: LD_ADDR_VAR 0 9
59959: PUSH
59960: DOUBLE
59961: LD_INT 1
59963: DEC
59964: ST_TO_ADDR
59965: LD_VAR 0 14
59969: PUSH
59970: FOR_TO
59971: IFFALSE 60647
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
59973: LD_ADDR_VAR 0 13
59977: PUSH
59978: LD_VAR 0 14
59982: PUSH
59983: LD_VAR 0 9
59987: ARRAY
59988: PUSH
59989: LD_INT 1
59991: ARRAY
59992: PPUSH
59993: LD_VAR 0 14
59997: PUSH
59998: LD_VAR 0 9
60002: ARRAY
60003: PUSH
60004: LD_INT 2
60006: ARRAY
60007: PPUSH
60008: CALL_OW 428
60012: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60013: LD_VAR 0 14
60017: PUSH
60018: LD_VAR 0 9
60022: ARRAY
60023: PUSH
60024: LD_INT 1
60026: ARRAY
60027: PPUSH
60028: LD_VAR 0 14
60032: PUSH
60033: LD_VAR 0 9
60037: ARRAY
60038: PUSH
60039: LD_INT 2
60041: ARRAY
60042: PPUSH
60043: CALL_OW 351
60047: PUSH
60048: LD_VAR 0 14
60052: PUSH
60053: LD_VAR 0 9
60057: ARRAY
60058: PUSH
60059: LD_INT 1
60061: ARRAY
60062: PPUSH
60063: LD_VAR 0 14
60067: PUSH
60068: LD_VAR 0 9
60072: ARRAY
60073: PUSH
60074: LD_INT 2
60076: ARRAY
60077: PPUSH
60078: CALL_OW 488
60082: NOT
60083: OR
60084: PUSH
60085: LD_VAR 0 13
60089: PPUSH
60090: CALL_OW 247
60094: PUSH
60095: LD_INT 3
60097: EQUAL
60098: OR
60099: IFFALSE 60105
// exit ;
60101: POP
60102: POP
60103: GO 60649
// if not tmp then
60105: LD_VAR 0 13
60109: NOT
60110: IFFALSE 60114
// continue ;
60112: GO 59970
// result := true ;
60114: LD_ADDR_VAR 0 8
60118: PUSH
60119: LD_INT 1
60121: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60122: LD_VAR 0 6
60126: PUSH
60127: LD_VAR 0 13
60131: PPUSH
60132: CALL_OW 247
60136: PUSH
60137: LD_INT 2
60139: EQUAL
60140: AND
60141: PUSH
60142: LD_VAR 0 13
60146: PPUSH
60147: CALL_OW 263
60151: PUSH
60152: LD_INT 1
60154: EQUAL
60155: AND
60156: IFFALSE 60320
// begin if IsDrivenBy ( tmp ) then
60158: LD_VAR 0 13
60162: PPUSH
60163: CALL_OW 311
60167: IFFALSE 60171
// continue ;
60169: GO 59970
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
60171: LD_VAR 0 6
60175: PPUSH
60176: LD_INT 3
60178: PUSH
60179: LD_INT 60
60181: PUSH
60182: EMPTY
60183: LIST
60184: PUSH
60185: EMPTY
60186: LIST
60187: LIST
60188: PUSH
60189: LD_INT 3
60191: PUSH
60192: LD_INT 55
60194: PUSH
60195: EMPTY
60196: LIST
60197: PUSH
60198: EMPTY
60199: LIST
60200: LIST
60201: PUSH
60202: EMPTY
60203: LIST
60204: LIST
60205: PPUSH
60206: CALL_OW 72
60210: IFFALSE 60318
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
60212: LD_ADDR_VAR 0 18
60216: PUSH
60217: LD_VAR 0 6
60221: PPUSH
60222: LD_INT 3
60224: PUSH
60225: LD_INT 60
60227: PUSH
60228: EMPTY
60229: LIST
60230: PUSH
60231: EMPTY
60232: LIST
60233: LIST
60234: PUSH
60235: LD_INT 3
60237: PUSH
60238: LD_INT 55
60240: PUSH
60241: EMPTY
60242: LIST
60243: PUSH
60244: EMPTY
60245: LIST
60246: LIST
60247: PUSH
60248: EMPTY
60249: LIST
60250: LIST
60251: PPUSH
60252: CALL_OW 72
60256: PUSH
60257: LD_INT 1
60259: ARRAY
60260: ST_TO_ADDR
// if IsInUnit ( driver ) then
60261: LD_VAR 0 18
60265: PPUSH
60266: CALL_OW 310
60270: IFFALSE 60281
// ComExit ( driver ) ;
60272: LD_VAR 0 18
60276: PPUSH
60277: CALL 84670 0 1
// AddComEnterUnit ( driver , tmp ) ;
60281: LD_VAR 0 18
60285: PPUSH
60286: LD_VAR 0 13
60290: PPUSH
60291: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
60295: LD_VAR 0 18
60299: PPUSH
60300: LD_VAR 0 7
60304: PPUSH
60305: CALL_OW 173
// AddComExitVehicle ( driver ) ;
60309: LD_VAR 0 18
60313: PPUSH
60314: CALL_OW 181
// end ; continue ;
60318: GO 59970
// end ; if not cleaners or not tmp in cleaners then
60320: LD_VAR 0 6
60324: NOT
60325: PUSH
60326: LD_VAR 0 13
60330: PUSH
60331: LD_VAR 0 6
60335: IN
60336: NOT
60337: OR
60338: IFFALSE 60645
// begin if dep then
60340: LD_VAR 0 17
60344: IFFALSE 60480
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
60346: LD_ADDR_VAR 0 16
60350: PUSH
60351: LD_VAR 0 17
60355: PUSH
60356: LD_INT 1
60358: ARRAY
60359: PPUSH
60360: CALL_OW 250
60364: PPUSH
60365: LD_VAR 0 17
60369: PUSH
60370: LD_INT 1
60372: ARRAY
60373: PPUSH
60374: CALL_OW 254
60378: PPUSH
60379: LD_INT 5
60381: PPUSH
60382: CALL_OW 272
60386: PUSH
60387: LD_VAR 0 17
60391: PUSH
60392: LD_INT 1
60394: ARRAY
60395: PPUSH
60396: CALL_OW 251
60400: PPUSH
60401: LD_VAR 0 17
60405: PUSH
60406: LD_INT 1
60408: ARRAY
60409: PPUSH
60410: CALL_OW 254
60414: PPUSH
60415: LD_INT 5
60417: PPUSH
60418: CALL_OW 273
60422: PUSH
60423: EMPTY
60424: LIST
60425: LIST
60426: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
60427: LD_VAR 0 16
60431: PUSH
60432: LD_INT 1
60434: ARRAY
60435: PPUSH
60436: LD_VAR 0 16
60440: PUSH
60441: LD_INT 2
60443: ARRAY
60444: PPUSH
60445: CALL_OW 488
60449: IFFALSE 60480
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
60451: LD_VAR 0 13
60455: PPUSH
60456: LD_VAR 0 16
60460: PUSH
60461: LD_INT 1
60463: ARRAY
60464: PPUSH
60465: LD_VAR 0 16
60469: PUSH
60470: LD_INT 2
60472: ARRAY
60473: PPUSH
60474: CALL_OW 111
// continue ;
60478: GO 59970
// end ; end ; r := GetDir ( tmp ) ;
60480: LD_ADDR_VAR 0 15
60484: PUSH
60485: LD_VAR 0 13
60489: PPUSH
60490: CALL_OW 254
60494: ST_TO_ADDR
// if r = 5 then
60495: LD_VAR 0 15
60499: PUSH
60500: LD_INT 5
60502: EQUAL
60503: IFFALSE 60513
// r := 0 ;
60505: LD_ADDR_VAR 0 15
60509: PUSH
60510: LD_INT 0
60512: ST_TO_ADDR
// for j = r to 5 do
60513: LD_ADDR_VAR 0 10
60517: PUSH
60518: DOUBLE
60519: LD_VAR 0 15
60523: DEC
60524: ST_TO_ADDR
60525: LD_INT 5
60527: PUSH
60528: FOR_TO
60529: IFFALSE 60643
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
60531: LD_ADDR_VAR 0 11
60535: PUSH
60536: LD_VAR 0 13
60540: PPUSH
60541: CALL_OW 250
60545: PPUSH
60546: LD_VAR 0 10
60550: PPUSH
60551: LD_INT 2
60553: PPUSH
60554: CALL_OW 272
60558: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
60559: LD_ADDR_VAR 0 12
60563: PUSH
60564: LD_VAR 0 13
60568: PPUSH
60569: CALL_OW 251
60573: PPUSH
60574: LD_VAR 0 10
60578: PPUSH
60579: LD_INT 2
60581: PPUSH
60582: CALL_OW 273
60586: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
60587: LD_VAR 0 11
60591: PPUSH
60592: LD_VAR 0 12
60596: PPUSH
60597: CALL_OW 488
60601: PUSH
60602: LD_VAR 0 11
60606: PPUSH
60607: LD_VAR 0 12
60611: PPUSH
60612: CALL_OW 428
60616: NOT
60617: AND
60618: IFFALSE 60641
// begin ComMoveXY ( tmp , _x , _y ) ;
60620: LD_VAR 0 13
60624: PPUSH
60625: LD_VAR 0 11
60629: PPUSH
60630: LD_VAR 0 12
60634: PPUSH
60635: CALL_OW 111
// break ;
60639: GO 60643
// end ; end ;
60641: GO 60528
60643: POP
60644: POP
// end ; end ;
60645: GO 59970
60647: POP
60648: POP
// end ;
60649: LD_VAR 0 8
60653: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
60654: LD_INT 0
60656: PPUSH
60657: PPUSH
60658: PPUSH
60659: PPUSH
60660: PPUSH
60661: PPUSH
60662: PPUSH
60663: PPUSH
60664: PPUSH
60665: PPUSH
// result := false ;
60666: LD_ADDR_VAR 0 6
60670: PUSH
60671: LD_INT 0
60673: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
60674: LD_VAR 0 1
60678: NOT
60679: PUSH
60680: LD_VAR 0 1
60684: PPUSH
60685: CALL_OW 266
60689: PUSH
60690: LD_INT 0
60692: PUSH
60693: LD_INT 1
60695: PUSH
60696: EMPTY
60697: LIST
60698: LIST
60699: IN
60700: NOT
60701: OR
60702: PUSH
60703: LD_VAR 0 2
60707: NOT
60708: OR
60709: PUSH
60710: LD_VAR 0 5
60714: PUSH
60715: LD_INT 0
60717: PUSH
60718: LD_INT 1
60720: PUSH
60721: LD_INT 2
60723: PUSH
60724: LD_INT 3
60726: PUSH
60727: LD_INT 4
60729: PUSH
60730: LD_INT 5
60732: PUSH
60733: EMPTY
60734: LIST
60735: LIST
60736: LIST
60737: LIST
60738: LIST
60739: LIST
60740: IN
60741: NOT
60742: OR
60743: PUSH
60744: LD_VAR 0 3
60748: PPUSH
60749: LD_VAR 0 4
60753: PPUSH
60754: CALL_OW 488
60758: NOT
60759: OR
60760: IFFALSE 60764
// exit ;
60762: GO 61481
// pom := GetBase ( depot ) ;
60764: LD_ADDR_VAR 0 10
60768: PUSH
60769: LD_VAR 0 1
60773: PPUSH
60774: CALL_OW 274
60778: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
60779: LD_ADDR_VAR 0 11
60783: PUSH
60784: LD_VAR 0 2
60788: PPUSH
60789: LD_VAR 0 1
60793: PPUSH
60794: CALL_OW 248
60798: PPUSH
60799: CALL_OW 450
60803: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
60804: LD_VAR 0 10
60808: PPUSH
60809: LD_INT 1
60811: PPUSH
60812: CALL_OW 275
60816: PUSH
60817: LD_VAR 0 11
60821: PUSH
60822: LD_INT 1
60824: ARRAY
60825: GREATEREQUAL
60826: PUSH
60827: LD_VAR 0 10
60831: PPUSH
60832: LD_INT 2
60834: PPUSH
60835: CALL_OW 275
60839: PUSH
60840: LD_VAR 0 11
60844: PUSH
60845: LD_INT 2
60847: ARRAY
60848: GREATEREQUAL
60849: AND
60850: PUSH
60851: LD_VAR 0 10
60855: PPUSH
60856: LD_INT 3
60858: PPUSH
60859: CALL_OW 275
60863: PUSH
60864: LD_VAR 0 11
60868: PUSH
60869: LD_INT 3
60871: ARRAY
60872: GREATEREQUAL
60873: AND
60874: NOT
60875: IFFALSE 60879
// exit ;
60877: GO 61481
// if GetBType ( depot ) = b_depot then
60879: LD_VAR 0 1
60883: PPUSH
60884: CALL_OW 266
60888: PUSH
60889: LD_INT 0
60891: EQUAL
60892: IFFALSE 60904
// dist := 28 else
60894: LD_ADDR_VAR 0 14
60898: PUSH
60899: LD_INT 28
60901: ST_TO_ADDR
60902: GO 60912
// dist := 36 ;
60904: LD_ADDR_VAR 0 14
60908: PUSH
60909: LD_INT 36
60911: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
60912: LD_VAR 0 1
60916: PPUSH
60917: LD_VAR 0 3
60921: PPUSH
60922: LD_VAR 0 4
60926: PPUSH
60927: CALL_OW 297
60931: PUSH
60932: LD_VAR 0 14
60936: GREATER
60937: IFFALSE 60941
// exit ;
60939: GO 61481
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
60941: LD_ADDR_VAR 0 12
60945: PUSH
60946: LD_VAR 0 2
60950: PPUSH
60951: LD_VAR 0 3
60955: PPUSH
60956: LD_VAR 0 4
60960: PPUSH
60961: LD_VAR 0 5
60965: PPUSH
60966: LD_VAR 0 1
60970: PPUSH
60971: CALL_OW 248
60975: PPUSH
60976: LD_INT 0
60978: PPUSH
60979: CALL 61486 0 6
60983: ST_TO_ADDR
// if not hexes then
60984: LD_VAR 0 12
60988: NOT
60989: IFFALSE 60993
// exit ;
60991: GO 61481
// hex := GetHexInfo ( x , y ) ;
60993: LD_ADDR_VAR 0 15
60997: PUSH
60998: LD_VAR 0 3
61002: PPUSH
61003: LD_VAR 0 4
61007: PPUSH
61008: CALL_OW 546
61012: ST_TO_ADDR
// if hex [ 1 ] then
61013: LD_VAR 0 15
61017: PUSH
61018: LD_INT 1
61020: ARRAY
61021: IFFALSE 61025
// exit ;
61023: GO 61481
// height := hex [ 2 ] ;
61025: LD_ADDR_VAR 0 13
61029: PUSH
61030: LD_VAR 0 15
61034: PUSH
61035: LD_INT 2
61037: ARRAY
61038: ST_TO_ADDR
// for i = 1 to hexes do
61039: LD_ADDR_VAR 0 7
61043: PUSH
61044: DOUBLE
61045: LD_INT 1
61047: DEC
61048: ST_TO_ADDR
61049: LD_VAR 0 12
61053: PUSH
61054: FOR_TO
61055: IFFALSE 61385
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
61057: LD_VAR 0 12
61061: PUSH
61062: LD_VAR 0 7
61066: ARRAY
61067: PUSH
61068: LD_INT 1
61070: ARRAY
61071: PPUSH
61072: LD_VAR 0 12
61076: PUSH
61077: LD_VAR 0 7
61081: ARRAY
61082: PUSH
61083: LD_INT 2
61085: ARRAY
61086: PPUSH
61087: CALL_OW 488
61091: NOT
61092: PUSH
61093: LD_VAR 0 12
61097: PUSH
61098: LD_VAR 0 7
61102: ARRAY
61103: PUSH
61104: LD_INT 1
61106: ARRAY
61107: PPUSH
61108: LD_VAR 0 12
61112: PUSH
61113: LD_VAR 0 7
61117: ARRAY
61118: PUSH
61119: LD_INT 2
61121: ARRAY
61122: PPUSH
61123: CALL_OW 428
61127: PUSH
61128: LD_INT 0
61130: GREATER
61131: OR
61132: PUSH
61133: LD_VAR 0 12
61137: PUSH
61138: LD_VAR 0 7
61142: ARRAY
61143: PUSH
61144: LD_INT 1
61146: ARRAY
61147: PPUSH
61148: LD_VAR 0 12
61152: PUSH
61153: LD_VAR 0 7
61157: ARRAY
61158: PUSH
61159: LD_INT 2
61161: ARRAY
61162: PPUSH
61163: CALL_OW 351
61167: OR
61168: IFFALSE 61174
// exit ;
61170: POP
61171: POP
61172: GO 61481
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61174: LD_ADDR_VAR 0 8
61178: PUSH
61179: LD_VAR 0 12
61183: PUSH
61184: LD_VAR 0 7
61188: ARRAY
61189: PUSH
61190: LD_INT 1
61192: ARRAY
61193: PPUSH
61194: LD_VAR 0 12
61198: PUSH
61199: LD_VAR 0 7
61203: ARRAY
61204: PUSH
61205: LD_INT 2
61207: ARRAY
61208: PPUSH
61209: CALL_OW 546
61213: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
61214: LD_VAR 0 8
61218: PUSH
61219: LD_INT 1
61221: ARRAY
61222: PUSH
61223: LD_VAR 0 8
61227: PUSH
61228: LD_INT 2
61230: ARRAY
61231: PUSH
61232: LD_VAR 0 13
61236: PUSH
61237: LD_INT 2
61239: PLUS
61240: GREATER
61241: OR
61242: PUSH
61243: LD_VAR 0 8
61247: PUSH
61248: LD_INT 2
61250: ARRAY
61251: PUSH
61252: LD_VAR 0 13
61256: PUSH
61257: LD_INT 2
61259: MINUS
61260: LESS
61261: OR
61262: PUSH
61263: LD_VAR 0 8
61267: PUSH
61268: LD_INT 3
61270: ARRAY
61271: PUSH
61272: LD_INT 0
61274: PUSH
61275: LD_INT 8
61277: PUSH
61278: LD_INT 9
61280: PUSH
61281: LD_INT 10
61283: PUSH
61284: LD_INT 11
61286: PUSH
61287: LD_INT 12
61289: PUSH
61290: LD_INT 13
61292: PUSH
61293: LD_INT 16
61295: PUSH
61296: LD_INT 17
61298: PUSH
61299: LD_INT 18
61301: PUSH
61302: LD_INT 19
61304: PUSH
61305: LD_INT 20
61307: PUSH
61308: LD_INT 21
61310: PUSH
61311: EMPTY
61312: LIST
61313: LIST
61314: LIST
61315: LIST
61316: LIST
61317: LIST
61318: LIST
61319: LIST
61320: LIST
61321: LIST
61322: LIST
61323: LIST
61324: LIST
61325: IN
61326: NOT
61327: OR
61328: PUSH
61329: LD_VAR 0 8
61333: PUSH
61334: LD_INT 5
61336: ARRAY
61337: NOT
61338: OR
61339: PUSH
61340: LD_VAR 0 8
61344: PUSH
61345: LD_INT 6
61347: ARRAY
61348: PUSH
61349: LD_INT 1
61351: PUSH
61352: LD_INT 2
61354: PUSH
61355: LD_INT 7
61357: PUSH
61358: LD_INT 9
61360: PUSH
61361: LD_INT 10
61363: PUSH
61364: LD_INT 11
61366: PUSH
61367: EMPTY
61368: LIST
61369: LIST
61370: LIST
61371: LIST
61372: LIST
61373: LIST
61374: IN
61375: NOT
61376: OR
61377: IFFALSE 61383
// exit ;
61379: POP
61380: POP
61381: GO 61481
// end ;
61383: GO 61054
61385: POP
61386: POP
// side := GetSide ( depot ) ;
61387: LD_ADDR_VAR 0 9
61391: PUSH
61392: LD_VAR 0 1
61396: PPUSH
61397: CALL_OW 255
61401: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
61402: LD_VAR 0 9
61406: PPUSH
61407: LD_VAR 0 3
61411: PPUSH
61412: LD_VAR 0 4
61416: PPUSH
61417: LD_INT 20
61419: PPUSH
61420: CALL 53802 0 4
61424: PUSH
61425: LD_INT 4
61427: ARRAY
61428: IFFALSE 61432
// exit ;
61430: GO 61481
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
61432: LD_VAR 0 2
61436: PUSH
61437: LD_INT 29
61439: PUSH
61440: LD_INT 30
61442: PUSH
61443: EMPTY
61444: LIST
61445: LIST
61446: IN
61447: PUSH
61448: LD_VAR 0 3
61452: PPUSH
61453: LD_VAR 0 4
61457: PPUSH
61458: LD_VAR 0 9
61462: PPUSH
61463: CALL_OW 440
61467: NOT
61468: AND
61469: IFFALSE 61473
// exit ;
61471: GO 61481
// result := true ;
61473: LD_ADDR_VAR 0 6
61477: PUSH
61478: LD_INT 1
61480: ST_TO_ADDR
// end ;
61481: LD_VAR 0 6
61485: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
61486: LD_INT 0
61488: PPUSH
61489: PPUSH
61490: PPUSH
61491: PPUSH
61492: PPUSH
61493: PPUSH
61494: PPUSH
61495: PPUSH
61496: PPUSH
61497: PPUSH
61498: PPUSH
61499: PPUSH
61500: PPUSH
61501: PPUSH
61502: PPUSH
61503: PPUSH
61504: PPUSH
61505: PPUSH
61506: PPUSH
61507: PPUSH
61508: PPUSH
61509: PPUSH
61510: PPUSH
61511: PPUSH
61512: PPUSH
61513: PPUSH
61514: PPUSH
61515: PPUSH
61516: PPUSH
61517: PPUSH
61518: PPUSH
61519: PPUSH
61520: PPUSH
61521: PPUSH
61522: PPUSH
61523: PPUSH
61524: PPUSH
61525: PPUSH
61526: PPUSH
61527: PPUSH
61528: PPUSH
61529: PPUSH
61530: PPUSH
61531: PPUSH
61532: PPUSH
61533: PPUSH
61534: PPUSH
61535: PPUSH
61536: PPUSH
61537: PPUSH
61538: PPUSH
61539: PPUSH
61540: PPUSH
61541: PPUSH
61542: PPUSH
61543: PPUSH
61544: PPUSH
61545: PPUSH
// result = [ ] ;
61546: LD_ADDR_VAR 0 7
61550: PUSH
61551: EMPTY
61552: ST_TO_ADDR
// temp_list = [ ] ;
61553: LD_ADDR_VAR 0 9
61557: PUSH
61558: EMPTY
61559: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
61560: LD_VAR 0 4
61564: PUSH
61565: LD_INT 0
61567: PUSH
61568: LD_INT 1
61570: PUSH
61571: LD_INT 2
61573: PUSH
61574: LD_INT 3
61576: PUSH
61577: LD_INT 4
61579: PUSH
61580: LD_INT 5
61582: PUSH
61583: EMPTY
61584: LIST
61585: LIST
61586: LIST
61587: LIST
61588: LIST
61589: LIST
61590: IN
61591: NOT
61592: PUSH
61593: LD_VAR 0 1
61597: PUSH
61598: LD_INT 0
61600: PUSH
61601: LD_INT 1
61603: PUSH
61604: EMPTY
61605: LIST
61606: LIST
61607: IN
61608: PUSH
61609: LD_VAR 0 5
61613: PUSH
61614: LD_INT 1
61616: PUSH
61617: LD_INT 2
61619: PUSH
61620: LD_INT 3
61622: PUSH
61623: EMPTY
61624: LIST
61625: LIST
61626: LIST
61627: IN
61628: NOT
61629: AND
61630: OR
61631: IFFALSE 61635
// exit ;
61633: GO 80026
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
61635: LD_VAR 0 1
61639: PUSH
61640: LD_INT 6
61642: PUSH
61643: LD_INT 7
61645: PUSH
61646: LD_INT 8
61648: PUSH
61649: LD_INT 13
61651: PUSH
61652: LD_INT 12
61654: PUSH
61655: LD_INT 15
61657: PUSH
61658: LD_INT 11
61660: PUSH
61661: LD_INT 14
61663: PUSH
61664: LD_INT 10
61666: PUSH
61667: EMPTY
61668: LIST
61669: LIST
61670: LIST
61671: LIST
61672: LIST
61673: LIST
61674: LIST
61675: LIST
61676: LIST
61677: IN
61678: IFFALSE 61688
// btype = b_lab ;
61680: LD_ADDR_VAR 0 1
61684: PUSH
61685: LD_INT 6
61687: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
61688: LD_VAR 0 6
61692: PUSH
61693: LD_INT 0
61695: PUSH
61696: LD_INT 1
61698: PUSH
61699: LD_INT 2
61701: PUSH
61702: EMPTY
61703: LIST
61704: LIST
61705: LIST
61706: IN
61707: NOT
61708: PUSH
61709: LD_VAR 0 1
61713: PUSH
61714: LD_INT 0
61716: PUSH
61717: LD_INT 1
61719: PUSH
61720: LD_INT 2
61722: PUSH
61723: LD_INT 3
61725: PUSH
61726: LD_INT 6
61728: PUSH
61729: LD_INT 36
61731: PUSH
61732: LD_INT 4
61734: PUSH
61735: LD_INT 5
61737: PUSH
61738: LD_INT 31
61740: PUSH
61741: LD_INT 32
61743: PUSH
61744: LD_INT 33
61746: PUSH
61747: EMPTY
61748: LIST
61749: LIST
61750: LIST
61751: LIST
61752: LIST
61753: LIST
61754: LIST
61755: LIST
61756: LIST
61757: LIST
61758: LIST
61759: IN
61760: NOT
61761: PUSH
61762: LD_VAR 0 6
61766: PUSH
61767: LD_INT 1
61769: EQUAL
61770: AND
61771: OR
61772: PUSH
61773: LD_VAR 0 1
61777: PUSH
61778: LD_INT 2
61780: PUSH
61781: LD_INT 3
61783: PUSH
61784: EMPTY
61785: LIST
61786: LIST
61787: IN
61788: NOT
61789: PUSH
61790: LD_VAR 0 6
61794: PUSH
61795: LD_INT 2
61797: EQUAL
61798: AND
61799: OR
61800: IFFALSE 61810
// mode = 0 ;
61802: LD_ADDR_VAR 0 6
61806: PUSH
61807: LD_INT 0
61809: ST_TO_ADDR
// case mode of 0 :
61810: LD_VAR 0 6
61814: PUSH
61815: LD_INT 0
61817: DOUBLE
61818: EQUAL
61819: IFTRUE 61823
61821: GO 73276
61823: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
61824: LD_ADDR_VAR 0 11
61828: PUSH
61829: LD_INT 0
61831: PUSH
61832: LD_INT 0
61834: PUSH
61835: EMPTY
61836: LIST
61837: LIST
61838: PUSH
61839: LD_INT 0
61841: PUSH
61842: LD_INT 1
61844: NEG
61845: PUSH
61846: EMPTY
61847: LIST
61848: LIST
61849: PUSH
61850: LD_INT 1
61852: PUSH
61853: LD_INT 0
61855: PUSH
61856: EMPTY
61857: LIST
61858: LIST
61859: PUSH
61860: LD_INT 1
61862: PUSH
61863: LD_INT 1
61865: PUSH
61866: EMPTY
61867: LIST
61868: LIST
61869: PUSH
61870: LD_INT 0
61872: PUSH
61873: LD_INT 1
61875: PUSH
61876: EMPTY
61877: LIST
61878: LIST
61879: PUSH
61880: LD_INT 1
61882: NEG
61883: PUSH
61884: LD_INT 0
61886: PUSH
61887: EMPTY
61888: LIST
61889: LIST
61890: PUSH
61891: LD_INT 1
61893: NEG
61894: PUSH
61895: LD_INT 1
61897: NEG
61898: PUSH
61899: EMPTY
61900: LIST
61901: LIST
61902: PUSH
61903: LD_INT 1
61905: NEG
61906: PUSH
61907: LD_INT 2
61909: NEG
61910: PUSH
61911: EMPTY
61912: LIST
61913: LIST
61914: PUSH
61915: LD_INT 0
61917: PUSH
61918: LD_INT 2
61920: NEG
61921: PUSH
61922: EMPTY
61923: LIST
61924: LIST
61925: PUSH
61926: LD_INT 1
61928: PUSH
61929: LD_INT 1
61931: NEG
61932: PUSH
61933: EMPTY
61934: LIST
61935: LIST
61936: PUSH
61937: LD_INT 1
61939: PUSH
61940: LD_INT 2
61942: PUSH
61943: EMPTY
61944: LIST
61945: LIST
61946: PUSH
61947: LD_INT 0
61949: PUSH
61950: LD_INT 2
61952: PUSH
61953: EMPTY
61954: LIST
61955: LIST
61956: PUSH
61957: LD_INT 1
61959: NEG
61960: PUSH
61961: LD_INT 1
61963: PUSH
61964: EMPTY
61965: LIST
61966: LIST
61967: PUSH
61968: LD_INT 1
61970: PUSH
61971: LD_INT 3
61973: PUSH
61974: EMPTY
61975: LIST
61976: LIST
61977: PUSH
61978: LD_INT 0
61980: PUSH
61981: LD_INT 3
61983: PUSH
61984: EMPTY
61985: LIST
61986: LIST
61987: PUSH
61988: LD_INT 1
61990: NEG
61991: PUSH
61992: LD_INT 2
61994: PUSH
61995: EMPTY
61996: LIST
61997: LIST
61998: PUSH
61999: EMPTY
62000: LIST
62001: LIST
62002: LIST
62003: LIST
62004: LIST
62005: LIST
62006: LIST
62007: LIST
62008: LIST
62009: LIST
62010: LIST
62011: LIST
62012: LIST
62013: LIST
62014: LIST
62015: LIST
62016: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
62017: LD_ADDR_VAR 0 12
62021: PUSH
62022: LD_INT 0
62024: PUSH
62025: LD_INT 0
62027: PUSH
62028: EMPTY
62029: LIST
62030: LIST
62031: PUSH
62032: LD_INT 0
62034: PUSH
62035: LD_INT 1
62037: NEG
62038: PUSH
62039: EMPTY
62040: LIST
62041: LIST
62042: PUSH
62043: LD_INT 1
62045: PUSH
62046: LD_INT 0
62048: PUSH
62049: EMPTY
62050: LIST
62051: LIST
62052: PUSH
62053: LD_INT 1
62055: PUSH
62056: LD_INT 1
62058: PUSH
62059: EMPTY
62060: LIST
62061: LIST
62062: PUSH
62063: LD_INT 0
62065: PUSH
62066: LD_INT 1
62068: PUSH
62069: EMPTY
62070: LIST
62071: LIST
62072: PUSH
62073: LD_INT 1
62075: NEG
62076: PUSH
62077: LD_INT 0
62079: PUSH
62080: EMPTY
62081: LIST
62082: LIST
62083: PUSH
62084: LD_INT 1
62086: NEG
62087: PUSH
62088: LD_INT 1
62090: NEG
62091: PUSH
62092: EMPTY
62093: LIST
62094: LIST
62095: PUSH
62096: LD_INT 1
62098: PUSH
62099: LD_INT 1
62101: NEG
62102: PUSH
62103: EMPTY
62104: LIST
62105: LIST
62106: PUSH
62107: LD_INT 2
62109: PUSH
62110: LD_INT 0
62112: PUSH
62113: EMPTY
62114: LIST
62115: LIST
62116: PUSH
62117: LD_INT 2
62119: PUSH
62120: LD_INT 1
62122: PUSH
62123: EMPTY
62124: LIST
62125: LIST
62126: PUSH
62127: LD_INT 1
62129: NEG
62130: PUSH
62131: LD_INT 1
62133: PUSH
62134: EMPTY
62135: LIST
62136: LIST
62137: PUSH
62138: LD_INT 2
62140: NEG
62141: PUSH
62142: LD_INT 0
62144: PUSH
62145: EMPTY
62146: LIST
62147: LIST
62148: PUSH
62149: LD_INT 2
62151: NEG
62152: PUSH
62153: LD_INT 1
62155: NEG
62156: PUSH
62157: EMPTY
62158: LIST
62159: LIST
62160: PUSH
62161: LD_INT 2
62163: NEG
62164: PUSH
62165: LD_INT 1
62167: PUSH
62168: EMPTY
62169: LIST
62170: LIST
62171: PUSH
62172: LD_INT 3
62174: NEG
62175: PUSH
62176: LD_INT 0
62178: PUSH
62179: EMPTY
62180: LIST
62181: LIST
62182: PUSH
62183: LD_INT 3
62185: NEG
62186: PUSH
62187: LD_INT 1
62189: NEG
62190: PUSH
62191: EMPTY
62192: LIST
62193: LIST
62194: PUSH
62195: EMPTY
62196: LIST
62197: LIST
62198: LIST
62199: LIST
62200: LIST
62201: LIST
62202: LIST
62203: LIST
62204: LIST
62205: LIST
62206: LIST
62207: LIST
62208: LIST
62209: LIST
62210: LIST
62211: LIST
62212: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
62213: LD_ADDR_VAR 0 13
62217: PUSH
62218: LD_INT 0
62220: PUSH
62221: LD_INT 0
62223: PUSH
62224: EMPTY
62225: LIST
62226: LIST
62227: PUSH
62228: LD_INT 0
62230: PUSH
62231: LD_INT 1
62233: NEG
62234: PUSH
62235: EMPTY
62236: LIST
62237: LIST
62238: PUSH
62239: LD_INT 1
62241: PUSH
62242: LD_INT 0
62244: PUSH
62245: EMPTY
62246: LIST
62247: LIST
62248: PUSH
62249: LD_INT 1
62251: PUSH
62252: LD_INT 1
62254: PUSH
62255: EMPTY
62256: LIST
62257: LIST
62258: PUSH
62259: LD_INT 0
62261: PUSH
62262: LD_INT 1
62264: PUSH
62265: EMPTY
62266: LIST
62267: LIST
62268: PUSH
62269: LD_INT 1
62271: NEG
62272: PUSH
62273: LD_INT 0
62275: PUSH
62276: EMPTY
62277: LIST
62278: LIST
62279: PUSH
62280: LD_INT 1
62282: NEG
62283: PUSH
62284: LD_INT 1
62286: NEG
62287: PUSH
62288: EMPTY
62289: LIST
62290: LIST
62291: PUSH
62292: LD_INT 1
62294: NEG
62295: PUSH
62296: LD_INT 2
62298: NEG
62299: PUSH
62300: EMPTY
62301: LIST
62302: LIST
62303: PUSH
62304: LD_INT 2
62306: PUSH
62307: LD_INT 1
62309: PUSH
62310: EMPTY
62311: LIST
62312: LIST
62313: PUSH
62314: LD_INT 2
62316: PUSH
62317: LD_INT 2
62319: PUSH
62320: EMPTY
62321: LIST
62322: LIST
62323: PUSH
62324: LD_INT 1
62326: PUSH
62327: LD_INT 2
62329: PUSH
62330: EMPTY
62331: LIST
62332: LIST
62333: PUSH
62334: LD_INT 2
62336: NEG
62337: PUSH
62338: LD_INT 1
62340: NEG
62341: PUSH
62342: EMPTY
62343: LIST
62344: LIST
62345: PUSH
62346: LD_INT 2
62348: NEG
62349: PUSH
62350: LD_INT 2
62352: NEG
62353: PUSH
62354: EMPTY
62355: LIST
62356: LIST
62357: PUSH
62358: LD_INT 2
62360: NEG
62361: PUSH
62362: LD_INT 3
62364: NEG
62365: PUSH
62366: EMPTY
62367: LIST
62368: LIST
62369: PUSH
62370: LD_INT 3
62372: NEG
62373: PUSH
62374: LD_INT 2
62376: NEG
62377: PUSH
62378: EMPTY
62379: LIST
62380: LIST
62381: PUSH
62382: LD_INT 3
62384: NEG
62385: PUSH
62386: LD_INT 3
62388: NEG
62389: PUSH
62390: EMPTY
62391: LIST
62392: LIST
62393: PUSH
62394: EMPTY
62395: LIST
62396: LIST
62397: LIST
62398: LIST
62399: LIST
62400: LIST
62401: LIST
62402: LIST
62403: LIST
62404: LIST
62405: LIST
62406: LIST
62407: LIST
62408: LIST
62409: LIST
62410: LIST
62411: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
62412: LD_ADDR_VAR 0 14
62416: PUSH
62417: LD_INT 0
62419: PUSH
62420: LD_INT 0
62422: PUSH
62423: EMPTY
62424: LIST
62425: LIST
62426: PUSH
62427: LD_INT 0
62429: PUSH
62430: LD_INT 1
62432: NEG
62433: PUSH
62434: EMPTY
62435: LIST
62436: LIST
62437: PUSH
62438: LD_INT 1
62440: PUSH
62441: LD_INT 0
62443: PUSH
62444: EMPTY
62445: LIST
62446: LIST
62447: PUSH
62448: LD_INT 1
62450: PUSH
62451: LD_INT 1
62453: PUSH
62454: EMPTY
62455: LIST
62456: LIST
62457: PUSH
62458: LD_INT 0
62460: PUSH
62461: LD_INT 1
62463: PUSH
62464: EMPTY
62465: LIST
62466: LIST
62467: PUSH
62468: LD_INT 1
62470: NEG
62471: PUSH
62472: LD_INT 0
62474: PUSH
62475: EMPTY
62476: LIST
62477: LIST
62478: PUSH
62479: LD_INT 1
62481: NEG
62482: PUSH
62483: LD_INT 1
62485: NEG
62486: PUSH
62487: EMPTY
62488: LIST
62489: LIST
62490: PUSH
62491: LD_INT 1
62493: NEG
62494: PUSH
62495: LD_INT 2
62497: NEG
62498: PUSH
62499: EMPTY
62500: LIST
62501: LIST
62502: PUSH
62503: LD_INT 0
62505: PUSH
62506: LD_INT 2
62508: NEG
62509: PUSH
62510: EMPTY
62511: LIST
62512: LIST
62513: PUSH
62514: LD_INT 1
62516: PUSH
62517: LD_INT 1
62519: NEG
62520: PUSH
62521: EMPTY
62522: LIST
62523: LIST
62524: PUSH
62525: LD_INT 1
62527: PUSH
62528: LD_INT 2
62530: PUSH
62531: EMPTY
62532: LIST
62533: LIST
62534: PUSH
62535: LD_INT 0
62537: PUSH
62538: LD_INT 2
62540: PUSH
62541: EMPTY
62542: LIST
62543: LIST
62544: PUSH
62545: LD_INT 1
62547: NEG
62548: PUSH
62549: LD_INT 1
62551: PUSH
62552: EMPTY
62553: LIST
62554: LIST
62555: PUSH
62556: LD_INT 1
62558: NEG
62559: PUSH
62560: LD_INT 3
62562: NEG
62563: PUSH
62564: EMPTY
62565: LIST
62566: LIST
62567: PUSH
62568: LD_INT 0
62570: PUSH
62571: LD_INT 3
62573: NEG
62574: PUSH
62575: EMPTY
62576: LIST
62577: LIST
62578: PUSH
62579: LD_INT 1
62581: PUSH
62582: LD_INT 2
62584: NEG
62585: PUSH
62586: EMPTY
62587: LIST
62588: LIST
62589: PUSH
62590: EMPTY
62591: LIST
62592: LIST
62593: LIST
62594: LIST
62595: LIST
62596: LIST
62597: LIST
62598: LIST
62599: LIST
62600: LIST
62601: LIST
62602: LIST
62603: LIST
62604: LIST
62605: LIST
62606: LIST
62607: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
62608: LD_ADDR_VAR 0 15
62612: PUSH
62613: LD_INT 0
62615: PUSH
62616: LD_INT 0
62618: PUSH
62619: EMPTY
62620: LIST
62621: LIST
62622: PUSH
62623: LD_INT 0
62625: PUSH
62626: LD_INT 1
62628: NEG
62629: PUSH
62630: EMPTY
62631: LIST
62632: LIST
62633: PUSH
62634: LD_INT 1
62636: PUSH
62637: LD_INT 0
62639: PUSH
62640: EMPTY
62641: LIST
62642: LIST
62643: PUSH
62644: LD_INT 1
62646: PUSH
62647: LD_INT 1
62649: PUSH
62650: EMPTY
62651: LIST
62652: LIST
62653: PUSH
62654: LD_INT 0
62656: PUSH
62657: LD_INT 1
62659: PUSH
62660: EMPTY
62661: LIST
62662: LIST
62663: PUSH
62664: LD_INT 1
62666: NEG
62667: PUSH
62668: LD_INT 0
62670: PUSH
62671: EMPTY
62672: LIST
62673: LIST
62674: PUSH
62675: LD_INT 1
62677: NEG
62678: PUSH
62679: LD_INT 1
62681: NEG
62682: PUSH
62683: EMPTY
62684: LIST
62685: LIST
62686: PUSH
62687: LD_INT 1
62689: PUSH
62690: LD_INT 1
62692: NEG
62693: PUSH
62694: EMPTY
62695: LIST
62696: LIST
62697: PUSH
62698: LD_INT 2
62700: PUSH
62701: LD_INT 0
62703: PUSH
62704: EMPTY
62705: LIST
62706: LIST
62707: PUSH
62708: LD_INT 2
62710: PUSH
62711: LD_INT 1
62713: PUSH
62714: EMPTY
62715: LIST
62716: LIST
62717: PUSH
62718: LD_INT 1
62720: NEG
62721: PUSH
62722: LD_INT 1
62724: PUSH
62725: EMPTY
62726: LIST
62727: LIST
62728: PUSH
62729: LD_INT 2
62731: NEG
62732: PUSH
62733: LD_INT 0
62735: PUSH
62736: EMPTY
62737: LIST
62738: LIST
62739: PUSH
62740: LD_INT 2
62742: NEG
62743: PUSH
62744: LD_INT 1
62746: NEG
62747: PUSH
62748: EMPTY
62749: LIST
62750: LIST
62751: PUSH
62752: LD_INT 2
62754: PUSH
62755: LD_INT 1
62757: NEG
62758: PUSH
62759: EMPTY
62760: LIST
62761: LIST
62762: PUSH
62763: LD_INT 3
62765: PUSH
62766: LD_INT 0
62768: PUSH
62769: EMPTY
62770: LIST
62771: LIST
62772: PUSH
62773: LD_INT 3
62775: PUSH
62776: LD_INT 1
62778: PUSH
62779: EMPTY
62780: LIST
62781: LIST
62782: PUSH
62783: EMPTY
62784: LIST
62785: LIST
62786: LIST
62787: LIST
62788: LIST
62789: LIST
62790: LIST
62791: LIST
62792: LIST
62793: LIST
62794: LIST
62795: LIST
62796: LIST
62797: LIST
62798: LIST
62799: LIST
62800: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
62801: LD_ADDR_VAR 0 16
62805: PUSH
62806: LD_INT 0
62808: PUSH
62809: LD_INT 0
62811: PUSH
62812: EMPTY
62813: LIST
62814: LIST
62815: PUSH
62816: LD_INT 0
62818: PUSH
62819: LD_INT 1
62821: NEG
62822: PUSH
62823: EMPTY
62824: LIST
62825: LIST
62826: PUSH
62827: LD_INT 1
62829: PUSH
62830: LD_INT 0
62832: PUSH
62833: EMPTY
62834: LIST
62835: LIST
62836: PUSH
62837: LD_INT 1
62839: PUSH
62840: LD_INT 1
62842: PUSH
62843: EMPTY
62844: LIST
62845: LIST
62846: PUSH
62847: LD_INT 0
62849: PUSH
62850: LD_INT 1
62852: PUSH
62853: EMPTY
62854: LIST
62855: LIST
62856: PUSH
62857: LD_INT 1
62859: NEG
62860: PUSH
62861: LD_INT 0
62863: PUSH
62864: EMPTY
62865: LIST
62866: LIST
62867: PUSH
62868: LD_INT 1
62870: NEG
62871: PUSH
62872: LD_INT 1
62874: NEG
62875: PUSH
62876: EMPTY
62877: LIST
62878: LIST
62879: PUSH
62880: LD_INT 1
62882: NEG
62883: PUSH
62884: LD_INT 2
62886: NEG
62887: PUSH
62888: EMPTY
62889: LIST
62890: LIST
62891: PUSH
62892: LD_INT 2
62894: PUSH
62895: LD_INT 1
62897: PUSH
62898: EMPTY
62899: LIST
62900: LIST
62901: PUSH
62902: LD_INT 2
62904: PUSH
62905: LD_INT 2
62907: PUSH
62908: EMPTY
62909: LIST
62910: LIST
62911: PUSH
62912: LD_INT 1
62914: PUSH
62915: LD_INT 2
62917: PUSH
62918: EMPTY
62919: LIST
62920: LIST
62921: PUSH
62922: LD_INT 2
62924: NEG
62925: PUSH
62926: LD_INT 1
62928: NEG
62929: PUSH
62930: EMPTY
62931: LIST
62932: LIST
62933: PUSH
62934: LD_INT 2
62936: NEG
62937: PUSH
62938: LD_INT 2
62940: NEG
62941: PUSH
62942: EMPTY
62943: LIST
62944: LIST
62945: PUSH
62946: LD_INT 3
62948: PUSH
62949: LD_INT 2
62951: PUSH
62952: EMPTY
62953: LIST
62954: LIST
62955: PUSH
62956: LD_INT 3
62958: PUSH
62959: LD_INT 3
62961: PUSH
62962: EMPTY
62963: LIST
62964: LIST
62965: PUSH
62966: LD_INT 2
62968: PUSH
62969: LD_INT 3
62971: PUSH
62972: EMPTY
62973: LIST
62974: LIST
62975: PUSH
62976: EMPTY
62977: LIST
62978: LIST
62979: LIST
62980: LIST
62981: LIST
62982: LIST
62983: LIST
62984: LIST
62985: LIST
62986: LIST
62987: LIST
62988: LIST
62989: LIST
62990: LIST
62991: LIST
62992: LIST
62993: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62994: LD_ADDR_VAR 0 17
62998: PUSH
62999: LD_INT 0
63001: PUSH
63002: LD_INT 0
63004: PUSH
63005: EMPTY
63006: LIST
63007: LIST
63008: PUSH
63009: LD_INT 0
63011: PUSH
63012: LD_INT 1
63014: NEG
63015: PUSH
63016: EMPTY
63017: LIST
63018: LIST
63019: PUSH
63020: LD_INT 1
63022: PUSH
63023: LD_INT 0
63025: PUSH
63026: EMPTY
63027: LIST
63028: LIST
63029: PUSH
63030: LD_INT 1
63032: PUSH
63033: LD_INT 1
63035: PUSH
63036: EMPTY
63037: LIST
63038: LIST
63039: PUSH
63040: LD_INT 0
63042: PUSH
63043: LD_INT 1
63045: PUSH
63046: EMPTY
63047: LIST
63048: LIST
63049: PUSH
63050: LD_INT 1
63052: NEG
63053: PUSH
63054: LD_INT 0
63056: PUSH
63057: EMPTY
63058: LIST
63059: LIST
63060: PUSH
63061: LD_INT 1
63063: NEG
63064: PUSH
63065: LD_INT 1
63067: NEG
63068: PUSH
63069: EMPTY
63070: LIST
63071: LIST
63072: PUSH
63073: LD_INT 1
63075: NEG
63076: PUSH
63077: LD_INT 2
63079: NEG
63080: PUSH
63081: EMPTY
63082: LIST
63083: LIST
63084: PUSH
63085: LD_INT 0
63087: PUSH
63088: LD_INT 2
63090: NEG
63091: PUSH
63092: EMPTY
63093: LIST
63094: LIST
63095: PUSH
63096: LD_INT 1
63098: PUSH
63099: LD_INT 1
63101: NEG
63102: PUSH
63103: EMPTY
63104: LIST
63105: LIST
63106: PUSH
63107: LD_INT 2
63109: PUSH
63110: LD_INT 0
63112: PUSH
63113: EMPTY
63114: LIST
63115: LIST
63116: PUSH
63117: LD_INT 2
63119: PUSH
63120: LD_INT 1
63122: PUSH
63123: EMPTY
63124: LIST
63125: LIST
63126: PUSH
63127: LD_INT 2
63129: PUSH
63130: LD_INT 2
63132: PUSH
63133: EMPTY
63134: LIST
63135: LIST
63136: PUSH
63137: LD_INT 1
63139: PUSH
63140: LD_INT 2
63142: PUSH
63143: EMPTY
63144: LIST
63145: LIST
63146: PUSH
63147: LD_INT 0
63149: PUSH
63150: LD_INT 2
63152: PUSH
63153: EMPTY
63154: LIST
63155: LIST
63156: PUSH
63157: LD_INT 1
63159: NEG
63160: PUSH
63161: LD_INT 1
63163: PUSH
63164: EMPTY
63165: LIST
63166: LIST
63167: PUSH
63168: LD_INT 2
63170: NEG
63171: PUSH
63172: LD_INT 0
63174: PUSH
63175: EMPTY
63176: LIST
63177: LIST
63178: PUSH
63179: LD_INT 2
63181: NEG
63182: PUSH
63183: LD_INT 1
63185: NEG
63186: PUSH
63187: EMPTY
63188: LIST
63189: LIST
63190: PUSH
63191: LD_INT 2
63193: NEG
63194: PUSH
63195: LD_INT 2
63197: NEG
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: PUSH
63203: EMPTY
63204: LIST
63205: LIST
63206: LIST
63207: LIST
63208: LIST
63209: LIST
63210: LIST
63211: LIST
63212: LIST
63213: LIST
63214: LIST
63215: LIST
63216: LIST
63217: LIST
63218: LIST
63219: LIST
63220: LIST
63221: LIST
63222: LIST
63223: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63224: LD_ADDR_VAR 0 18
63228: PUSH
63229: LD_INT 0
63231: PUSH
63232: LD_INT 0
63234: PUSH
63235: EMPTY
63236: LIST
63237: LIST
63238: PUSH
63239: LD_INT 0
63241: PUSH
63242: LD_INT 1
63244: NEG
63245: PUSH
63246: EMPTY
63247: LIST
63248: LIST
63249: PUSH
63250: LD_INT 1
63252: PUSH
63253: LD_INT 0
63255: PUSH
63256: EMPTY
63257: LIST
63258: LIST
63259: PUSH
63260: LD_INT 1
63262: PUSH
63263: LD_INT 1
63265: PUSH
63266: EMPTY
63267: LIST
63268: LIST
63269: PUSH
63270: LD_INT 0
63272: PUSH
63273: LD_INT 1
63275: PUSH
63276: EMPTY
63277: LIST
63278: LIST
63279: PUSH
63280: LD_INT 1
63282: NEG
63283: PUSH
63284: LD_INT 0
63286: PUSH
63287: EMPTY
63288: LIST
63289: LIST
63290: PUSH
63291: LD_INT 1
63293: NEG
63294: PUSH
63295: LD_INT 1
63297: NEG
63298: PUSH
63299: EMPTY
63300: LIST
63301: LIST
63302: PUSH
63303: LD_INT 1
63305: NEG
63306: PUSH
63307: LD_INT 2
63309: NEG
63310: PUSH
63311: EMPTY
63312: LIST
63313: LIST
63314: PUSH
63315: LD_INT 0
63317: PUSH
63318: LD_INT 2
63320: NEG
63321: PUSH
63322: EMPTY
63323: LIST
63324: LIST
63325: PUSH
63326: LD_INT 1
63328: PUSH
63329: LD_INT 1
63331: NEG
63332: PUSH
63333: EMPTY
63334: LIST
63335: LIST
63336: PUSH
63337: LD_INT 2
63339: PUSH
63340: LD_INT 0
63342: PUSH
63343: EMPTY
63344: LIST
63345: LIST
63346: PUSH
63347: LD_INT 2
63349: PUSH
63350: LD_INT 1
63352: PUSH
63353: EMPTY
63354: LIST
63355: LIST
63356: PUSH
63357: LD_INT 2
63359: PUSH
63360: LD_INT 2
63362: PUSH
63363: EMPTY
63364: LIST
63365: LIST
63366: PUSH
63367: LD_INT 1
63369: PUSH
63370: LD_INT 2
63372: PUSH
63373: EMPTY
63374: LIST
63375: LIST
63376: PUSH
63377: LD_INT 0
63379: PUSH
63380: LD_INT 2
63382: PUSH
63383: EMPTY
63384: LIST
63385: LIST
63386: PUSH
63387: LD_INT 1
63389: NEG
63390: PUSH
63391: LD_INT 1
63393: PUSH
63394: EMPTY
63395: LIST
63396: LIST
63397: PUSH
63398: LD_INT 2
63400: NEG
63401: PUSH
63402: LD_INT 0
63404: PUSH
63405: EMPTY
63406: LIST
63407: LIST
63408: PUSH
63409: LD_INT 2
63411: NEG
63412: PUSH
63413: LD_INT 1
63415: NEG
63416: PUSH
63417: EMPTY
63418: LIST
63419: LIST
63420: PUSH
63421: LD_INT 2
63423: NEG
63424: PUSH
63425: LD_INT 2
63427: NEG
63428: PUSH
63429: EMPTY
63430: LIST
63431: LIST
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: LIST
63437: LIST
63438: LIST
63439: LIST
63440: LIST
63441: LIST
63442: LIST
63443: LIST
63444: LIST
63445: LIST
63446: LIST
63447: LIST
63448: LIST
63449: LIST
63450: LIST
63451: LIST
63452: LIST
63453: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63454: LD_ADDR_VAR 0 19
63458: PUSH
63459: LD_INT 0
63461: PUSH
63462: LD_INT 0
63464: PUSH
63465: EMPTY
63466: LIST
63467: LIST
63468: PUSH
63469: LD_INT 0
63471: PUSH
63472: LD_INT 1
63474: NEG
63475: PUSH
63476: EMPTY
63477: LIST
63478: LIST
63479: PUSH
63480: LD_INT 1
63482: PUSH
63483: LD_INT 0
63485: PUSH
63486: EMPTY
63487: LIST
63488: LIST
63489: PUSH
63490: LD_INT 1
63492: PUSH
63493: LD_INT 1
63495: PUSH
63496: EMPTY
63497: LIST
63498: LIST
63499: PUSH
63500: LD_INT 0
63502: PUSH
63503: LD_INT 1
63505: PUSH
63506: EMPTY
63507: LIST
63508: LIST
63509: PUSH
63510: LD_INT 1
63512: NEG
63513: PUSH
63514: LD_INT 0
63516: PUSH
63517: EMPTY
63518: LIST
63519: LIST
63520: PUSH
63521: LD_INT 1
63523: NEG
63524: PUSH
63525: LD_INT 1
63527: NEG
63528: PUSH
63529: EMPTY
63530: LIST
63531: LIST
63532: PUSH
63533: LD_INT 1
63535: NEG
63536: PUSH
63537: LD_INT 2
63539: NEG
63540: PUSH
63541: EMPTY
63542: LIST
63543: LIST
63544: PUSH
63545: LD_INT 0
63547: PUSH
63548: LD_INT 2
63550: NEG
63551: PUSH
63552: EMPTY
63553: LIST
63554: LIST
63555: PUSH
63556: LD_INT 1
63558: PUSH
63559: LD_INT 1
63561: NEG
63562: PUSH
63563: EMPTY
63564: LIST
63565: LIST
63566: PUSH
63567: LD_INT 2
63569: PUSH
63570: LD_INT 0
63572: PUSH
63573: EMPTY
63574: LIST
63575: LIST
63576: PUSH
63577: LD_INT 2
63579: PUSH
63580: LD_INT 1
63582: PUSH
63583: EMPTY
63584: LIST
63585: LIST
63586: PUSH
63587: LD_INT 2
63589: PUSH
63590: LD_INT 2
63592: PUSH
63593: EMPTY
63594: LIST
63595: LIST
63596: PUSH
63597: LD_INT 1
63599: PUSH
63600: LD_INT 2
63602: PUSH
63603: EMPTY
63604: LIST
63605: LIST
63606: PUSH
63607: LD_INT 0
63609: PUSH
63610: LD_INT 2
63612: PUSH
63613: EMPTY
63614: LIST
63615: LIST
63616: PUSH
63617: LD_INT 1
63619: NEG
63620: PUSH
63621: LD_INT 1
63623: PUSH
63624: EMPTY
63625: LIST
63626: LIST
63627: PUSH
63628: LD_INT 2
63630: NEG
63631: PUSH
63632: LD_INT 0
63634: PUSH
63635: EMPTY
63636: LIST
63637: LIST
63638: PUSH
63639: LD_INT 2
63641: NEG
63642: PUSH
63643: LD_INT 1
63645: NEG
63646: PUSH
63647: EMPTY
63648: LIST
63649: LIST
63650: PUSH
63651: LD_INT 2
63653: NEG
63654: PUSH
63655: LD_INT 2
63657: NEG
63658: PUSH
63659: EMPTY
63660: LIST
63661: LIST
63662: PUSH
63663: EMPTY
63664: LIST
63665: LIST
63666: LIST
63667: LIST
63668: LIST
63669: LIST
63670: LIST
63671: LIST
63672: LIST
63673: LIST
63674: LIST
63675: LIST
63676: LIST
63677: LIST
63678: LIST
63679: LIST
63680: LIST
63681: LIST
63682: LIST
63683: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63684: LD_ADDR_VAR 0 20
63688: PUSH
63689: LD_INT 0
63691: PUSH
63692: LD_INT 0
63694: PUSH
63695: EMPTY
63696: LIST
63697: LIST
63698: PUSH
63699: LD_INT 0
63701: PUSH
63702: LD_INT 1
63704: NEG
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PUSH
63710: LD_INT 1
63712: PUSH
63713: LD_INT 0
63715: PUSH
63716: EMPTY
63717: LIST
63718: LIST
63719: PUSH
63720: LD_INT 1
63722: PUSH
63723: LD_INT 1
63725: PUSH
63726: EMPTY
63727: LIST
63728: LIST
63729: PUSH
63730: LD_INT 0
63732: PUSH
63733: LD_INT 1
63735: PUSH
63736: EMPTY
63737: LIST
63738: LIST
63739: PUSH
63740: LD_INT 1
63742: NEG
63743: PUSH
63744: LD_INT 0
63746: PUSH
63747: EMPTY
63748: LIST
63749: LIST
63750: PUSH
63751: LD_INT 1
63753: NEG
63754: PUSH
63755: LD_INT 1
63757: NEG
63758: PUSH
63759: EMPTY
63760: LIST
63761: LIST
63762: PUSH
63763: LD_INT 1
63765: NEG
63766: PUSH
63767: LD_INT 2
63769: NEG
63770: PUSH
63771: EMPTY
63772: LIST
63773: LIST
63774: PUSH
63775: LD_INT 0
63777: PUSH
63778: LD_INT 2
63780: NEG
63781: PUSH
63782: EMPTY
63783: LIST
63784: LIST
63785: PUSH
63786: LD_INT 1
63788: PUSH
63789: LD_INT 1
63791: NEG
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: PUSH
63797: LD_INT 2
63799: PUSH
63800: LD_INT 0
63802: PUSH
63803: EMPTY
63804: LIST
63805: LIST
63806: PUSH
63807: LD_INT 2
63809: PUSH
63810: LD_INT 1
63812: PUSH
63813: EMPTY
63814: LIST
63815: LIST
63816: PUSH
63817: LD_INT 2
63819: PUSH
63820: LD_INT 2
63822: PUSH
63823: EMPTY
63824: LIST
63825: LIST
63826: PUSH
63827: LD_INT 1
63829: PUSH
63830: LD_INT 2
63832: PUSH
63833: EMPTY
63834: LIST
63835: LIST
63836: PUSH
63837: LD_INT 0
63839: PUSH
63840: LD_INT 2
63842: PUSH
63843: EMPTY
63844: LIST
63845: LIST
63846: PUSH
63847: LD_INT 1
63849: NEG
63850: PUSH
63851: LD_INT 1
63853: PUSH
63854: EMPTY
63855: LIST
63856: LIST
63857: PUSH
63858: LD_INT 2
63860: NEG
63861: PUSH
63862: LD_INT 0
63864: PUSH
63865: EMPTY
63866: LIST
63867: LIST
63868: PUSH
63869: LD_INT 2
63871: NEG
63872: PUSH
63873: LD_INT 1
63875: NEG
63876: PUSH
63877: EMPTY
63878: LIST
63879: LIST
63880: PUSH
63881: LD_INT 2
63883: NEG
63884: PUSH
63885: LD_INT 2
63887: NEG
63888: PUSH
63889: EMPTY
63890: LIST
63891: LIST
63892: PUSH
63893: EMPTY
63894: LIST
63895: LIST
63896: LIST
63897: LIST
63898: LIST
63899: LIST
63900: LIST
63901: LIST
63902: LIST
63903: LIST
63904: LIST
63905: LIST
63906: LIST
63907: LIST
63908: LIST
63909: LIST
63910: LIST
63911: LIST
63912: LIST
63913: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63914: LD_ADDR_VAR 0 21
63918: PUSH
63919: LD_INT 0
63921: PUSH
63922: LD_INT 0
63924: PUSH
63925: EMPTY
63926: LIST
63927: LIST
63928: PUSH
63929: LD_INT 0
63931: PUSH
63932: LD_INT 1
63934: NEG
63935: PUSH
63936: EMPTY
63937: LIST
63938: LIST
63939: PUSH
63940: LD_INT 1
63942: PUSH
63943: LD_INT 0
63945: PUSH
63946: EMPTY
63947: LIST
63948: LIST
63949: PUSH
63950: LD_INT 1
63952: PUSH
63953: LD_INT 1
63955: PUSH
63956: EMPTY
63957: LIST
63958: LIST
63959: PUSH
63960: LD_INT 0
63962: PUSH
63963: LD_INT 1
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: PUSH
63970: LD_INT 1
63972: NEG
63973: PUSH
63974: LD_INT 0
63976: PUSH
63977: EMPTY
63978: LIST
63979: LIST
63980: PUSH
63981: LD_INT 1
63983: NEG
63984: PUSH
63985: LD_INT 1
63987: NEG
63988: PUSH
63989: EMPTY
63990: LIST
63991: LIST
63992: PUSH
63993: LD_INT 1
63995: NEG
63996: PUSH
63997: LD_INT 2
63999: NEG
64000: PUSH
64001: EMPTY
64002: LIST
64003: LIST
64004: PUSH
64005: LD_INT 0
64007: PUSH
64008: LD_INT 2
64010: NEG
64011: PUSH
64012: EMPTY
64013: LIST
64014: LIST
64015: PUSH
64016: LD_INT 1
64018: PUSH
64019: LD_INT 1
64021: NEG
64022: PUSH
64023: EMPTY
64024: LIST
64025: LIST
64026: PUSH
64027: LD_INT 2
64029: PUSH
64030: LD_INT 0
64032: PUSH
64033: EMPTY
64034: LIST
64035: LIST
64036: PUSH
64037: LD_INT 2
64039: PUSH
64040: LD_INT 1
64042: PUSH
64043: EMPTY
64044: LIST
64045: LIST
64046: PUSH
64047: LD_INT 2
64049: PUSH
64050: LD_INT 2
64052: PUSH
64053: EMPTY
64054: LIST
64055: LIST
64056: PUSH
64057: LD_INT 1
64059: PUSH
64060: LD_INT 2
64062: PUSH
64063: EMPTY
64064: LIST
64065: LIST
64066: PUSH
64067: LD_INT 0
64069: PUSH
64070: LD_INT 2
64072: PUSH
64073: EMPTY
64074: LIST
64075: LIST
64076: PUSH
64077: LD_INT 1
64079: NEG
64080: PUSH
64081: LD_INT 1
64083: PUSH
64084: EMPTY
64085: LIST
64086: LIST
64087: PUSH
64088: LD_INT 2
64090: NEG
64091: PUSH
64092: LD_INT 0
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PUSH
64099: LD_INT 2
64101: NEG
64102: PUSH
64103: LD_INT 1
64105: NEG
64106: PUSH
64107: EMPTY
64108: LIST
64109: LIST
64110: PUSH
64111: LD_INT 2
64113: NEG
64114: PUSH
64115: LD_INT 2
64117: NEG
64118: PUSH
64119: EMPTY
64120: LIST
64121: LIST
64122: PUSH
64123: EMPTY
64124: LIST
64125: LIST
64126: LIST
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: LIST
64136: LIST
64137: LIST
64138: LIST
64139: LIST
64140: LIST
64141: LIST
64142: LIST
64143: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64144: LD_ADDR_VAR 0 22
64148: PUSH
64149: LD_INT 0
64151: PUSH
64152: LD_INT 0
64154: PUSH
64155: EMPTY
64156: LIST
64157: LIST
64158: PUSH
64159: LD_INT 0
64161: PUSH
64162: LD_INT 1
64164: NEG
64165: PUSH
64166: EMPTY
64167: LIST
64168: LIST
64169: PUSH
64170: LD_INT 1
64172: PUSH
64173: LD_INT 0
64175: PUSH
64176: EMPTY
64177: LIST
64178: LIST
64179: PUSH
64180: LD_INT 1
64182: PUSH
64183: LD_INT 1
64185: PUSH
64186: EMPTY
64187: LIST
64188: LIST
64189: PUSH
64190: LD_INT 0
64192: PUSH
64193: LD_INT 1
64195: PUSH
64196: EMPTY
64197: LIST
64198: LIST
64199: PUSH
64200: LD_INT 1
64202: NEG
64203: PUSH
64204: LD_INT 0
64206: PUSH
64207: EMPTY
64208: LIST
64209: LIST
64210: PUSH
64211: LD_INT 1
64213: NEG
64214: PUSH
64215: LD_INT 1
64217: NEG
64218: PUSH
64219: EMPTY
64220: LIST
64221: LIST
64222: PUSH
64223: LD_INT 1
64225: NEG
64226: PUSH
64227: LD_INT 2
64229: NEG
64230: PUSH
64231: EMPTY
64232: LIST
64233: LIST
64234: PUSH
64235: LD_INT 0
64237: PUSH
64238: LD_INT 2
64240: NEG
64241: PUSH
64242: EMPTY
64243: LIST
64244: LIST
64245: PUSH
64246: LD_INT 1
64248: PUSH
64249: LD_INT 1
64251: NEG
64252: PUSH
64253: EMPTY
64254: LIST
64255: LIST
64256: PUSH
64257: LD_INT 2
64259: PUSH
64260: LD_INT 0
64262: PUSH
64263: EMPTY
64264: LIST
64265: LIST
64266: PUSH
64267: LD_INT 2
64269: PUSH
64270: LD_INT 1
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: PUSH
64277: LD_INT 2
64279: PUSH
64280: LD_INT 2
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: PUSH
64287: LD_INT 1
64289: PUSH
64290: LD_INT 2
64292: PUSH
64293: EMPTY
64294: LIST
64295: LIST
64296: PUSH
64297: LD_INT 0
64299: PUSH
64300: LD_INT 2
64302: PUSH
64303: EMPTY
64304: LIST
64305: LIST
64306: PUSH
64307: LD_INT 1
64309: NEG
64310: PUSH
64311: LD_INT 1
64313: PUSH
64314: EMPTY
64315: LIST
64316: LIST
64317: PUSH
64318: LD_INT 2
64320: NEG
64321: PUSH
64322: LD_INT 0
64324: PUSH
64325: EMPTY
64326: LIST
64327: LIST
64328: PUSH
64329: LD_INT 2
64331: NEG
64332: PUSH
64333: LD_INT 1
64335: NEG
64336: PUSH
64337: EMPTY
64338: LIST
64339: LIST
64340: PUSH
64341: LD_INT 2
64343: NEG
64344: PUSH
64345: LD_INT 2
64347: NEG
64348: PUSH
64349: EMPTY
64350: LIST
64351: LIST
64352: PUSH
64353: EMPTY
64354: LIST
64355: LIST
64356: LIST
64357: LIST
64358: LIST
64359: LIST
64360: LIST
64361: LIST
64362: LIST
64363: LIST
64364: LIST
64365: LIST
64366: LIST
64367: LIST
64368: LIST
64369: LIST
64370: LIST
64371: LIST
64372: LIST
64373: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
64374: LD_ADDR_VAR 0 23
64378: PUSH
64379: LD_INT 0
64381: PUSH
64382: LD_INT 0
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PUSH
64389: LD_INT 0
64391: PUSH
64392: LD_INT 1
64394: NEG
64395: PUSH
64396: EMPTY
64397: LIST
64398: LIST
64399: PUSH
64400: LD_INT 1
64402: PUSH
64403: LD_INT 0
64405: PUSH
64406: EMPTY
64407: LIST
64408: LIST
64409: PUSH
64410: LD_INT 1
64412: PUSH
64413: LD_INT 1
64415: PUSH
64416: EMPTY
64417: LIST
64418: LIST
64419: PUSH
64420: LD_INT 0
64422: PUSH
64423: LD_INT 1
64425: PUSH
64426: EMPTY
64427: LIST
64428: LIST
64429: PUSH
64430: LD_INT 1
64432: NEG
64433: PUSH
64434: LD_INT 0
64436: PUSH
64437: EMPTY
64438: LIST
64439: LIST
64440: PUSH
64441: LD_INT 1
64443: NEG
64444: PUSH
64445: LD_INT 1
64447: NEG
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PUSH
64453: LD_INT 1
64455: NEG
64456: PUSH
64457: LD_INT 2
64459: NEG
64460: PUSH
64461: EMPTY
64462: LIST
64463: LIST
64464: PUSH
64465: LD_INT 0
64467: PUSH
64468: LD_INT 2
64470: NEG
64471: PUSH
64472: EMPTY
64473: LIST
64474: LIST
64475: PUSH
64476: LD_INT 1
64478: PUSH
64479: LD_INT 1
64481: NEG
64482: PUSH
64483: EMPTY
64484: LIST
64485: LIST
64486: PUSH
64487: LD_INT 2
64489: PUSH
64490: LD_INT 0
64492: PUSH
64493: EMPTY
64494: LIST
64495: LIST
64496: PUSH
64497: LD_INT 2
64499: PUSH
64500: LD_INT 1
64502: PUSH
64503: EMPTY
64504: LIST
64505: LIST
64506: PUSH
64507: LD_INT 2
64509: PUSH
64510: LD_INT 2
64512: PUSH
64513: EMPTY
64514: LIST
64515: LIST
64516: PUSH
64517: LD_INT 1
64519: PUSH
64520: LD_INT 2
64522: PUSH
64523: EMPTY
64524: LIST
64525: LIST
64526: PUSH
64527: LD_INT 0
64529: PUSH
64530: LD_INT 2
64532: PUSH
64533: EMPTY
64534: LIST
64535: LIST
64536: PUSH
64537: LD_INT 1
64539: NEG
64540: PUSH
64541: LD_INT 1
64543: PUSH
64544: EMPTY
64545: LIST
64546: LIST
64547: PUSH
64548: LD_INT 2
64550: NEG
64551: PUSH
64552: LD_INT 0
64554: PUSH
64555: EMPTY
64556: LIST
64557: LIST
64558: PUSH
64559: LD_INT 2
64561: NEG
64562: PUSH
64563: LD_INT 1
64565: NEG
64566: PUSH
64567: EMPTY
64568: LIST
64569: LIST
64570: PUSH
64571: LD_INT 2
64573: NEG
64574: PUSH
64575: LD_INT 2
64577: NEG
64578: PUSH
64579: EMPTY
64580: LIST
64581: LIST
64582: PUSH
64583: LD_INT 2
64585: NEG
64586: PUSH
64587: LD_INT 3
64589: NEG
64590: PUSH
64591: EMPTY
64592: LIST
64593: LIST
64594: PUSH
64595: LD_INT 1
64597: NEG
64598: PUSH
64599: LD_INT 3
64601: NEG
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PUSH
64607: LD_INT 1
64609: PUSH
64610: LD_INT 2
64612: NEG
64613: PUSH
64614: EMPTY
64615: LIST
64616: LIST
64617: PUSH
64618: LD_INT 2
64620: PUSH
64621: LD_INT 1
64623: NEG
64624: PUSH
64625: EMPTY
64626: LIST
64627: LIST
64628: PUSH
64629: EMPTY
64630: LIST
64631: LIST
64632: LIST
64633: LIST
64634: LIST
64635: LIST
64636: LIST
64637: LIST
64638: LIST
64639: LIST
64640: LIST
64641: LIST
64642: LIST
64643: LIST
64644: LIST
64645: LIST
64646: LIST
64647: LIST
64648: LIST
64649: LIST
64650: LIST
64651: LIST
64652: LIST
64653: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
64654: LD_ADDR_VAR 0 24
64658: PUSH
64659: LD_INT 0
64661: PUSH
64662: LD_INT 0
64664: PUSH
64665: EMPTY
64666: LIST
64667: LIST
64668: PUSH
64669: LD_INT 0
64671: PUSH
64672: LD_INT 1
64674: NEG
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: PUSH
64680: LD_INT 1
64682: PUSH
64683: LD_INT 0
64685: PUSH
64686: EMPTY
64687: LIST
64688: LIST
64689: PUSH
64690: LD_INT 1
64692: PUSH
64693: LD_INT 1
64695: PUSH
64696: EMPTY
64697: LIST
64698: LIST
64699: PUSH
64700: LD_INT 0
64702: PUSH
64703: LD_INT 1
64705: PUSH
64706: EMPTY
64707: LIST
64708: LIST
64709: PUSH
64710: LD_INT 1
64712: NEG
64713: PUSH
64714: LD_INT 0
64716: PUSH
64717: EMPTY
64718: LIST
64719: LIST
64720: PUSH
64721: LD_INT 1
64723: NEG
64724: PUSH
64725: LD_INT 1
64727: NEG
64728: PUSH
64729: EMPTY
64730: LIST
64731: LIST
64732: PUSH
64733: LD_INT 1
64735: NEG
64736: PUSH
64737: LD_INT 2
64739: NEG
64740: PUSH
64741: EMPTY
64742: LIST
64743: LIST
64744: PUSH
64745: LD_INT 0
64747: PUSH
64748: LD_INT 2
64750: NEG
64751: PUSH
64752: EMPTY
64753: LIST
64754: LIST
64755: PUSH
64756: LD_INT 1
64758: PUSH
64759: LD_INT 1
64761: NEG
64762: PUSH
64763: EMPTY
64764: LIST
64765: LIST
64766: PUSH
64767: LD_INT 2
64769: PUSH
64770: LD_INT 0
64772: PUSH
64773: EMPTY
64774: LIST
64775: LIST
64776: PUSH
64777: LD_INT 2
64779: PUSH
64780: LD_INT 1
64782: PUSH
64783: EMPTY
64784: LIST
64785: LIST
64786: PUSH
64787: LD_INT 2
64789: PUSH
64790: LD_INT 2
64792: PUSH
64793: EMPTY
64794: LIST
64795: LIST
64796: PUSH
64797: LD_INT 1
64799: PUSH
64800: LD_INT 2
64802: PUSH
64803: EMPTY
64804: LIST
64805: LIST
64806: PUSH
64807: LD_INT 0
64809: PUSH
64810: LD_INT 2
64812: PUSH
64813: EMPTY
64814: LIST
64815: LIST
64816: PUSH
64817: LD_INT 1
64819: NEG
64820: PUSH
64821: LD_INT 1
64823: PUSH
64824: EMPTY
64825: LIST
64826: LIST
64827: PUSH
64828: LD_INT 2
64830: NEG
64831: PUSH
64832: LD_INT 0
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: PUSH
64839: LD_INT 2
64841: NEG
64842: PUSH
64843: LD_INT 1
64845: NEG
64846: PUSH
64847: EMPTY
64848: LIST
64849: LIST
64850: PUSH
64851: LD_INT 2
64853: NEG
64854: PUSH
64855: LD_INT 2
64857: NEG
64858: PUSH
64859: EMPTY
64860: LIST
64861: LIST
64862: PUSH
64863: LD_INT 1
64865: PUSH
64866: LD_INT 2
64868: NEG
64869: PUSH
64870: EMPTY
64871: LIST
64872: LIST
64873: PUSH
64874: LD_INT 2
64876: PUSH
64877: LD_INT 1
64879: NEG
64880: PUSH
64881: EMPTY
64882: LIST
64883: LIST
64884: PUSH
64885: LD_INT 3
64887: PUSH
64888: LD_INT 1
64890: PUSH
64891: EMPTY
64892: LIST
64893: LIST
64894: PUSH
64895: LD_INT 3
64897: PUSH
64898: LD_INT 2
64900: PUSH
64901: EMPTY
64902: LIST
64903: LIST
64904: PUSH
64905: EMPTY
64906: LIST
64907: LIST
64908: LIST
64909: LIST
64910: LIST
64911: LIST
64912: LIST
64913: LIST
64914: LIST
64915: LIST
64916: LIST
64917: LIST
64918: LIST
64919: LIST
64920: LIST
64921: LIST
64922: LIST
64923: LIST
64924: LIST
64925: LIST
64926: LIST
64927: LIST
64928: LIST
64929: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
64930: LD_ADDR_VAR 0 25
64934: PUSH
64935: LD_INT 0
64937: PUSH
64938: LD_INT 0
64940: PUSH
64941: EMPTY
64942: LIST
64943: LIST
64944: PUSH
64945: LD_INT 0
64947: PUSH
64948: LD_INT 1
64950: NEG
64951: PUSH
64952: EMPTY
64953: LIST
64954: LIST
64955: PUSH
64956: LD_INT 1
64958: PUSH
64959: LD_INT 0
64961: PUSH
64962: EMPTY
64963: LIST
64964: LIST
64965: PUSH
64966: LD_INT 1
64968: PUSH
64969: LD_INT 1
64971: PUSH
64972: EMPTY
64973: LIST
64974: LIST
64975: PUSH
64976: LD_INT 0
64978: PUSH
64979: LD_INT 1
64981: PUSH
64982: EMPTY
64983: LIST
64984: LIST
64985: PUSH
64986: LD_INT 1
64988: NEG
64989: PUSH
64990: LD_INT 0
64992: PUSH
64993: EMPTY
64994: LIST
64995: LIST
64996: PUSH
64997: LD_INT 1
64999: NEG
65000: PUSH
65001: LD_INT 1
65003: NEG
65004: PUSH
65005: EMPTY
65006: LIST
65007: LIST
65008: PUSH
65009: LD_INT 1
65011: NEG
65012: PUSH
65013: LD_INT 2
65015: NEG
65016: PUSH
65017: EMPTY
65018: LIST
65019: LIST
65020: PUSH
65021: LD_INT 0
65023: PUSH
65024: LD_INT 2
65026: NEG
65027: PUSH
65028: EMPTY
65029: LIST
65030: LIST
65031: PUSH
65032: LD_INT 1
65034: PUSH
65035: LD_INT 1
65037: NEG
65038: PUSH
65039: EMPTY
65040: LIST
65041: LIST
65042: PUSH
65043: LD_INT 2
65045: PUSH
65046: LD_INT 0
65048: PUSH
65049: EMPTY
65050: LIST
65051: LIST
65052: PUSH
65053: LD_INT 2
65055: PUSH
65056: LD_INT 1
65058: PUSH
65059: EMPTY
65060: LIST
65061: LIST
65062: PUSH
65063: LD_INT 2
65065: PUSH
65066: LD_INT 2
65068: PUSH
65069: EMPTY
65070: LIST
65071: LIST
65072: PUSH
65073: LD_INT 1
65075: PUSH
65076: LD_INT 2
65078: PUSH
65079: EMPTY
65080: LIST
65081: LIST
65082: PUSH
65083: LD_INT 0
65085: PUSH
65086: LD_INT 2
65088: PUSH
65089: EMPTY
65090: LIST
65091: LIST
65092: PUSH
65093: LD_INT 1
65095: NEG
65096: PUSH
65097: LD_INT 1
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: PUSH
65104: LD_INT 2
65106: NEG
65107: PUSH
65108: LD_INT 0
65110: PUSH
65111: EMPTY
65112: LIST
65113: LIST
65114: PUSH
65115: LD_INT 2
65117: NEG
65118: PUSH
65119: LD_INT 1
65121: NEG
65122: PUSH
65123: EMPTY
65124: LIST
65125: LIST
65126: PUSH
65127: LD_INT 2
65129: NEG
65130: PUSH
65131: LD_INT 2
65133: NEG
65134: PUSH
65135: EMPTY
65136: LIST
65137: LIST
65138: PUSH
65139: LD_INT 3
65141: PUSH
65142: LD_INT 1
65144: PUSH
65145: EMPTY
65146: LIST
65147: LIST
65148: PUSH
65149: LD_INT 3
65151: PUSH
65152: LD_INT 2
65154: PUSH
65155: EMPTY
65156: LIST
65157: LIST
65158: PUSH
65159: LD_INT 2
65161: PUSH
65162: LD_INT 3
65164: PUSH
65165: EMPTY
65166: LIST
65167: LIST
65168: PUSH
65169: LD_INT 1
65171: PUSH
65172: LD_INT 3
65174: PUSH
65175: EMPTY
65176: LIST
65177: LIST
65178: PUSH
65179: EMPTY
65180: LIST
65181: LIST
65182: LIST
65183: LIST
65184: LIST
65185: LIST
65186: LIST
65187: LIST
65188: LIST
65189: LIST
65190: LIST
65191: LIST
65192: LIST
65193: LIST
65194: LIST
65195: LIST
65196: LIST
65197: LIST
65198: LIST
65199: LIST
65200: LIST
65201: LIST
65202: LIST
65203: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
65204: LD_ADDR_VAR 0 26
65208: PUSH
65209: LD_INT 0
65211: PUSH
65212: LD_INT 0
65214: PUSH
65215: EMPTY
65216: LIST
65217: LIST
65218: PUSH
65219: LD_INT 0
65221: PUSH
65222: LD_INT 1
65224: NEG
65225: PUSH
65226: EMPTY
65227: LIST
65228: LIST
65229: PUSH
65230: LD_INT 1
65232: PUSH
65233: LD_INT 0
65235: PUSH
65236: EMPTY
65237: LIST
65238: LIST
65239: PUSH
65240: LD_INT 1
65242: PUSH
65243: LD_INT 1
65245: PUSH
65246: EMPTY
65247: LIST
65248: LIST
65249: PUSH
65250: LD_INT 0
65252: PUSH
65253: LD_INT 1
65255: PUSH
65256: EMPTY
65257: LIST
65258: LIST
65259: PUSH
65260: LD_INT 1
65262: NEG
65263: PUSH
65264: LD_INT 0
65266: PUSH
65267: EMPTY
65268: LIST
65269: LIST
65270: PUSH
65271: LD_INT 1
65273: NEG
65274: PUSH
65275: LD_INT 1
65277: NEG
65278: PUSH
65279: EMPTY
65280: LIST
65281: LIST
65282: PUSH
65283: LD_INT 1
65285: NEG
65286: PUSH
65287: LD_INT 2
65289: NEG
65290: PUSH
65291: EMPTY
65292: LIST
65293: LIST
65294: PUSH
65295: LD_INT 0
65297: PUSH
65298: LD_INT 2
65300: NEG
65301: PUSH
65302: EMPTY
65303: LIST
65304: LIST
65305: PUSH
65306: LD_INT 1
65308: PUSH
65309: LD_INT 1
65311: NEG
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PUSH
65317: LD_INT 2
65319: PUSH
65320: LD_INT 0
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: PUSH
65327: LD_INT 2
65329: PUSH
65330: LD_INT 1
65332: PUSH
65333: EMPTY
65334: LIST
65335: LIST
65336: PUSH
65337: LD_INT 2
65339: PUSH
65340: LD_INT 2
65342: PUSH
65343: EMPTY
65344: LIST
65345: LIST
65346: PUSH
65347: LD_INT 1
65349: PUSH
65350: LD_INT 2
65352: PUSH
65353: EMPTY
65354: LIST
65355: LIST
65356: PUSH
65357: LD_INT 0
65359: PUSH
65360: LD_INT 2
65362: PUSH
65363: EMPTY
65364: LIST
65365: LIST
65366: PUSH
65367: LD_INT 1
65369: NEG
65370: PUSH
65371: LD_INT 1
65373: PUSH
65374: EMPTY
65375: LIST
65376: LIST
65377: PUSH
65378: LD_INT 2
65380: NEG
65381: PUSH
65382: LD_INT 0
65384: PUSH
65385: EMPTY
65386: LIST
65387: LIST
65388: PUSH
65389: LD_INT 2
65391: NEG
65392: PUSH
65393: LD_INT 1
65395: NEG
65396: PUSH
65397: EMPTY
65398: LIST
65399: LIST
65400: PUSH
65401: LD_INT 2
65403: NEG
65404: PUSH
65405: LD_INT 2
65407: NEG
65408: PUSH
65409: EMPTY
65410: LIST
65411: LIST
65412: PUSH
65413: LD_INT 2
65415: PUSH
65416: LD_INT 3
65418: PUSH
65419: EMPTY
65420: LIST
65421: LIST
65422: PUSH
65423: LD_INT 1
65425: PUSH
65426: LD_INT 3
65428: PUSH
65429: EMPTY
65430: LIST
65431: LIST
65432: PUSH
65433: LD_INT 1
65435: NEG
65436: PUSH
65437: LD_INT 2
65439: PUSH
65440: EMPTY
65441: LIST
65442: LIST
65443: PUSH
65444: LD_INT 2
65446: NEG
65447: PUSH
65448: LD_INT 1
65450: PUSH
65451: EMPTY
65452: LIST
65453: LIST
65454: PUSH
65455: EMPTY
65456: LIST
65457: LIST
65458: LIST
65459: LIST
65460: LIST
65461: LIST
65462: LIST
65463: LIST
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: LIST
65477: LIST
65478: LIST
65479: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
65480: LD_ADDR_VAR 0 27
65484: PUSH
65485: LD_INT 0
65487: PUSH
65488: LD_INT 0
65490: PUSH
65491: EMPTY
65492: LIST
65493: LIST
65494: PUSH
65495: LD_INT 0
65497: PUSH
65498: LD_INT 1
65500: NEG
65501: PUSH
65502: EMPTY
65503: LIST
65504: LIST
65505: PUSH
65506: LD_INT 1
65508: PUSH
65509: LD_INT 0
65511: PUSH
65512: EMPTY
65513: LIST
65514: LIST
65515: PUSH
65516: LD_INT 1
65518: PUSH
65519: LD_INT 1
65521: PUSH
65522: EMPTY
65523: LIST
65524: LIST
65525: PUSH
65526: LD_INT 0
65528: PUSH
65529: LD_INT 1
65531: PUSH
65532: EMPTY
65533: LIST
65534: LIST
65535: PUSH
65536: LD_INT 1
65538: NEG
65539: PUSH
65540: LD_INT 0
65542: PUSH
65543: EMPTY
65544: LIST
65545: LIST
65546: PUSH
65547: LD_INT 1
65549: NEG
65550: PUSH
65551: LD_INT 1
65553: NEG
65554: PUSH
65555: EMPTY
65556: LIST
65557: LIST
65558: PUSH
65559: LD_INT 1
65561: NEG
65562: PUSH
65563: LD_INT 2
65565: NEG
65566: PUSH
65567: EMPTY
65568: LIST
65569: LIST
65570: PUSH
65571: LD_INT 0
65573: PUSH
65574: LD_INT 2
65576: NEG
65577: PUSH
65578: EMPTY
65579: LIST
65580: LIST
65581: PUSH
65582: LD_INT 1
65584: PUSH
65585: LD_INT 1
65587: NEG
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: LD_INT 2
65595: PUSH
65596: LD_INT 0
65598: PUSH
65599: EMPTY
65600: LIST
65601: LIST
65602: PUSH
65603: LD_INT 2
65605: PUSH
65606: LD_INT 1
65608: PUSH
65609: EMPTY
65610: LIST
65611: LIST
65612: PUSH
65613: LD_INT 2
65615: PUSH
65616: LD_INT 2
65618: PUSH
65619: EMPTY
65620: LIST
65621: LIST
65622: PUSH
65623: LD_INT 1
65625: PUSH
65626: LD_INT 2
65628: PUSH
65629: EMPTY
65630: LIST
65631: LIST
65632: PUSH
65633: LD_INT 0
65635: PUSH
65636: LD_INT 2
65638: PUSH
65639: EMPTY
65640: LIST
65641: LIST
65642: PUSH
65643: LD_INT 1
65645: NEG
65646: PUSH
65647: LD_INT 1
65649: PUSH
65650: EMPTY
65651: LIST
65652: LIST
65653: PUSH
65654: LD_INT 2
65656: NEG
65657: PUSH
65658: LD_INT 0
65660: PUSH
65661: EMPTY
65662: LIST
65663: LIST
65664: PUSH
65665: LD_INT 2
65667: NEG
65668: PUSH
65669: LD_INT 1
65671: NEG
65672: PUSH
65673: EMPTY
65674: LIST
65675: LIST
65676: PUSH
65677: LD_INT 2
65679: NEG
65680: PUSH
65681: LD_INT 2
65683: NEG
65684: PUSH
65685: EMPTY
65686: LIST
65687: LIST
65688: PUSH
65689: LD_INT 1
65691: NEG
65692: PUSH
65693: LD_INT 2
65695: PUSH
65696: EMPTY
65697: LIST
65698: LIST
65699: PUSH
65700: LD_INT 2
65702: NEG
65703: PUSH
65704: LD_INT 1
65706: PUSH
65707: EMPTY
65708: LIST
65709: LIST
65710: PUSH
65711: LD_INT 3
65713: NEG
65714: PUSH
65715: LD_INT 1
65717: NEG
65718: PUSH
65719: EMPTY
65720: LIST
65721: LIST
65722: PUSH
65723: LD_INT 3
65725: NEG
65726: PUSH
65727: LD_INT 2
65729: NEG
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: PUSH
65735: EMPTY
65736: LIST
65737: LIST
65738: LIST
65739: LIST
65740: LIST
65741: LIST
65742: LIST
65743: LIST
65744: LIST
65745: LIST
65746: LIST
65747: LIST
65748: LIST
65749: LIST
65750: LIST
65751: LIST
65752: LIST
65753: LIST
65754: LIST
65755: LIST
65756: LIST
65757: LIST
65758: LIST
65759: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
65760: LD_ADDR_VAR 0 28
65764: PUSH
65765: LD_INT 0
65767: PUSH
65768: LD_INT 0
65770: PUSH
65771: EMPTY
65772: LIST
65773: LIST
65774: PUSH
65775: LD_INT 0
65777: PUSH
65778: LD_INT 1
65780: NEG
65781: PUSH
65782: EMPTY
65783: LIST
65784: LIST
65785: PUSH
65786: LD_INT 1
65788: PUSH
65789: LD_INT 0
65791: PUSH
65792: EMPTY
65793: LIST
65794: LIST
65795: PUSH
65796: LD_INT 1
65798: PUSH
65799: LD_INT 1
65801: PUSH
65802: EMPTY
65803: LIST
65804: LIST
65805: PUSH
65806: LD_INT 0
65808: PUSH
65809: LD_INT 1
65811: PUSH
65812: EMPTY
65813: LIST
65814: LIST
65815: PUSH
65816: LD_INT 1
65818: NEG
65819: PUSH
65820: LD_INT 0
65822: PUSH
65823: EMPTY
65824: LIST
65825: LIST
65826: PUSH
65827: LD_INT 1
65829: NEG
65830: PUSH
65831: LD_INT 1
65833: NEG
65834: PUSH
65835: EMPTY
65836: LIST
65837: LIST
65838: PUSH
65839: LD_INT 1
65841: NEG
65842: PUSH
65843: LD_INT 2
65845: NEG
65846: PUSH
65847: EMPTY
65848: LIST
65849: LIST
65850: PUSH
65851: LD_INT 0
65853: PUSH
65854: LD_INT 2
65856: NEG
65857: PUSH
65858: EMPTY
65859: LIST
65860: LIST
65861: PUSH
65862: LD_INT 1
65864: PUSH
65865: LD_INT 1
65867: NEG
65868: PUSH
65869: EMPTY
65870: LIST
65871: LIST
65872: PUSH
65873: LD_INT 2
65875: PUSH
65876: LD_INT 0
65878: PUSH
65879: EMPTY
65880: LIST
65881: LIST
65882: PUSH
65883: LD_INT 2
65885: PUSH
65886: LD_INT 1
65888: PUSH
65889: EMPTY
65890: LIST
65891: LIST
65892: PUSH
65893: LD_INT 2
65895: PUSH
65896: LD_INT 2
65898: PUSH
65899: EMPTY
65900: LIST
65901: LIST
65902: PUSH
65903: LD_INT 1
65905: PUSH
65906: LD_INT 2
65908: PUSH
65909: EMPTY
65910: LIST
65911: LIST
65912: PUSH
65913: LD_INT 0
65915: PUSH
65916: LD_INT 2
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: PUSH
65923: LD_INT 1
65925: NEG
65926: PUSH
65927: LD_INT 1
65929: PUSH
65930: EMPTY
65931: LIST
65932: LIST
65933: PUSH
65934: LD_INT 2
65936: NEG
65937: PUSH
65938: LD_INT 0
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PUSH
65945: LD_INT 2
65947: NEG
65948: PUSH
65949: LD_INT 1
65951: NEG
65952: PUSH
65953: EMPTY
65954: LIST
65955: LIST
65956: PUSH
65957: LD_INT 2
65959: NEG
65960: PUSH
65961: LD_INT 2
65963: NEG
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: PUSH
65969: LD_INT 2
65971: NEG
65972: PUSH
65973: LD_INT 3
65975: NEG
65976: PUSH
65977: EMPTY
65978: LIST
65979: LIST
65980: PUSH
65981: LD_INT 1
65983: NEG
65984: PUSH
65985: LD_INT 3
65987: NEG
65988: PUSH
65989: EMPTY
65990: LIST
65991: LIST
65992: PUSH
65993: LD_INT 3
65995: NEG
65996: PUSH
65997: LD_INT 1
65999: NEG
66000: PUSH
66001: EMPTY
66002: LIST
66003: LIST
66004: PUSH
66005: LD_INT 3
66007: NEG
66008: PUSH
66009: LD_INT 2
66011: NEG
66012: PUSH
66013: EMPTY
66014: LIST
66015: LIST
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: LIST
66021: LIST
66022: LIST
66023: LIST
66024: LIST
66025: LIST
66026: LIST
66027: LIST
66028: LIST
66029: LIST
66030: LIST
66031: LIST
66032: LIST
66033: LIST
66034: LIST
66035: LIST
66036: LIST
66037: LIST
66038: LIST
66039: LIST
66040: LIST
66041: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66042: LD_ADDR_VAR 0 29
66046: PUSH
66047: LD_INT 0
66049: PUSH
66050: LD_INT 0
66052: PUSH
66053: EMPTY
66054: LIST
66055: LIST
66056: PUSH
66057: LD_INT 0
66059: PUSH
66060: LD_INT 1
66062: NEG
66063: PUSH
66064: EMPTY
66065: LIST
66066: LIST
66067: PUSH
66068: LD_INT 1
66070: PUSH
66071: LD_INT 0
66073: PUSH
66074: EMPTY
66075: LIST
66076: LIST
66077: PUSH
66078: LD_INT 1
66080: PUSH
66081: LD_INT 1
66083: PUSH
66084: EMPTY
66085: LIST
66086: LIST
66087: PUSH
66088: LD_INT 0
66090: PUSH
66091: LD_INT 1
66093: PUSH
66094: EMPTY
66095: LIST
66096: LIST
66097: PUSH
66098: LD_INT 1
66100: NEG
66101: PUSH
66102: LD_INT 0
66104: PUSH
66105: EMPTY
66106: LIST
66107: LIST
66108: PUSH
66109: LD_INT 1
66111: NEG
66112: PUSH
66113: LD_INT 1
66115: NEG
66116: PUSH
66117: EMPTY
66118: LIST
66119: LIST
66120: PUSH
66121: LD_INT 1
66123: NEG
66124: PUSH
66125: LD_INT 2
66127: NEG
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PUSH
66133: LD_INT 0
66135: PUSH
66136: LD_INT 2
66138: NEG
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PUSH
66144: LD_INT 1
66146: PUSH
66147: LD_INT 1
66149: NEG
66150: PUSH
66151: EMPTY
66152: LIST
66153: LIST
66154: PUSH
66155: LD_INT 2
66157: PUSH
66158: LD_INT 0
66160: PUSH
66161: EMPTY
66162: LIST
66163: LIST
66164: PUSH
66165: LD_INT 2
66167: PUSH
66168: LD_INT 1
66170: PUSH
66171: EMPTY
66172: LIST
66173: LIST
66174: PUSH
66175: LD_INT 1
66177: PUSH
66178: LD_INT 2
66180: PUSH
66181: EMPTY
66182: LIST
66183: LIST
66184: PUSH
66185: LD_INT 0
66187: PUSH
66188: LD_INT 2
66190: PUSH
66191: EMPTY
66192: LIST
66193: LIST
66194: PUSH
66195: LD_INT 1
66197: NEG
66198: PUSH
66199: LD_INT 1
66201: PUSH
66202: EMPTY
66203: LIST
66204: LIST
66205: PUSH
66206: LD_INT 2
66208: NEG
66209: PUSH
66210: LD_INT 1
66212: NEG
66213: PUSH
66214: EMPTY
66215: LIST
66216: LIST
66217: PUSH
66218: LD_INT 2
66220: NEG
66221: PUSH
66222: LD_INT 2
66224: NEG
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 2
66232: NEG
66233: PUSH
66234: LD_INT 3
66236: NEG
66237: PUSH
66238: EMPTY
66239: LIST
66240: LIST
66241: PUSH
66242: LD_INT 2
66244: PUSH
66245: LD_INT 1
66247: NEG
66248: PUSH
66249: EMPTY
66250: LIST
66251: LIST
66252: PUSH
66253: LD_INT 3
66255: PUSH
66256: LD_INT 1
66258: PUSH
66259: EMPTY
66260: LIST
66261: LIST
66262: PUSH
66263: LD_INT 1
66265: PUSH
66266: LD_INT 3
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PUSH
66273: LD_INT 1
66275: NEG
66276: PUSH
66277: LD_INT 2
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: PUSH
66284: LD_INT 3
66286: NEG
66287: PUSH
66288: LD_INT 2
66290: NEG
66291: PUSH
66292: EMPTY
66293: LIST
66294: LIST
66295: PUSH
66296: EMPTY
66297: LIST
66298: LIST
66299: LIST
66300: LIST
66301: LIST
66302: LIST
66303: LIST
66304: LIST
66305: LIST
66306: LIST
66307: LIST
66308: LIST
66309: LIST
66310: LIST
66311: LIST
66312: LIST
66313: LIST
66314: LIST
66315: LIST
66316: LIST
66317: LIST
66318: LIST
66319: LIST
66320: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66321: LD_ADDR_VAR 0 30
66325: PUSH
66326: LD_INT 0
66328: PUSH
66329: LD_INT 0
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PUSH
66336: LD_INT 0
66338: PUSH
66339: LD_INT 1
66341: NEG
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 1
66349: PUSH
66350: LD_INT 0
66352: PUSH
66353: EMPTY
66354: LIST
66355: LIST
66356: PUSH
66357: LD_INT 1
66359: PUSH
66360: LD_INT 1
66362: PUSH
66363: EMPTY
66364: LIST
66365: LIST
66366: PUSH
66367: LD_INT 0
66369: PUSH
66370: LD_INT 1
66372: PUSH
66373: EMPTY
66374: LIST
66375: LIST
66376: PUSH
66377: LD_INT 1
66379: NEG
66380: PUSH
66381: LD_INT 0
66383: PUSH
66384: EMPTY
66385: LIST
66386: LIST
66387: PUSH
66388: LD_INT 1
66390: NEG
66391: PUSH
66392: LD_INT 1
66394: NEG
66395: PUSH
66396: EMPTY
66397: LIST
66398: LIST
66399: PUSH
66400: LD_INT 1
66402: NEG
66403: PUSH
66404: LD_INT 2
66406: NEG
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: LD_INT 0
66414: PUSH
66415: LD_INT 2
66417: NEG
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: PUSH
66423: LD_INT 1
66425: PUSH
66426: LD_INT 1
66428: NEG
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: LD_INT 2
66436: PUSH
66437: LD_INT 0
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: LD_INT 2
66446: PUSH
66447: LD_INT 1
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 2
66456: PUSH
66457: LD_INT 2
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PUSH
66464: LD_INT 1
66466: PUSH
66467: LD_INT 2
66469: PUSH
66470: EMPTY
66471: LIST
66472: LIST
66473: PUSH
66474: LD_INT 1
66476: NEG
66477: PUSH
66478: LD_INT 1
66480: PUSH
66481: EMPTY
66482: LIST
66483: LIST
66484: PUSH
66485: LD_INT 2
66487: NEG
66488: PUSH
66489: LD_INT 0
66491: PUSH
66492: EMPTY
66493: LIST
66494: LIST
66495: PUSH
66496: LD_INT 2
66498: NEG
66499: PUSH
66500: LD_INT 1
66502: NEG
66503: PUSH
66504: EMPTY
66505: LIST
66506: LIST
66507: PUSH
66508: LD_INT 1
66510: NEG
66511: PUSH
66512: LD_INT 3
66514: NEG
66515: PUSH
66516: EMPTY
66517: LIST
66518: LIST
66519: PUSH
66520: LD_INT 1
66522: PUSH
66523: LD_INT 2
66525: NEG
66526: PUSH
66527: EMPTY
66528: LIST
66529: LIST
66530: PUSH
66531: LD_INT 3
66533: PUSH
66534: LD_INT 2
66536: PUSH
66537: EMPTY
66538: LIST
66539: LIST
66540: PUSH
66541: LD_INT 2
66543: PUSH
66544: LD_INT 3
66546: PUSH
66547: EMPTY
66548: LIST
66549: LIST
66550: PUSH
66551: LD_INT 2
66553: NEG
66554: PUSH
66555: LD_INT 1
66557: PUSH
66558: EMPTY
66559: LIST
66560: LIST
66561: PUSH
66562: LD_INT 3
66564: NEG
66565: PUSH
66566: LD_INT 1
66568: NEG
66569: PUSH
66570: EMPTY
66571: LIST
66572: LIST
66573: PUSH
66574: EMPTY
66575: LIST
66576: LIST
66577: LIST
66578: LIST
66579: LIST
66580: LIST
66581: LIST
66582: LIST
66583: LIST
66584: LIST
66585: LIST
66586: LIST
66587: LIST
66588: LIST
66589: LIST
66590: LIST
66591: LIST
66592: LIST
66593: LIST
66594: LIST
66595: LIST
66596: LIST
66597: LIST
66598: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66599: LD_ADDR_VAR 0 31
66603: PUSH
66604: LD_INT 0
66606: PUSH
66607: LD_INT 0
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: PUSH
66614: LD_INT 0
66616: PUSH
66617: LD_INT 1
66619: NEG
66620: PUSH
66621: EMPTY
66622: LIST
66623: LIST
66624: PUSH
66625: LD_INT 1
66627: PUSH
66628: LD_INT 0
66630: PUSH
66631: EMPTY
66632: LIST
66633: LIST
66634: PUSH
66635: LD_INT 1
66637: PUSH
66638: LD_INT 1
66640: PUSH
66641: EMPTY
66642: LIST
66643: LIST
66644: PUSH
66645: LD_INT 0
66647: PUSH
66648: LD_INT 1
66650: PUSH
66651: EMPTY
66652: LIST
66653: LIST
66654: PUSH
66655: LD_INT 1
66657: NEG
66658: PUSH
66659: LD_INT 0
66661: PUSH
66662: EMPTY
66663: LIST
66664: LIST
66665: PUSH
66666: LD_INT 1
66668: NEG
66669: PUSH
66670: LD_INT 1
66672: NEG
66673: PUSH
66674: EMPTY
66675: LIST
66676: LIST
66677: PUSH
66678: LD_INT 1
66680: NEG
66681: PUSH
66682: LD_INT 2
66684: NEG
66685: PUSH
66686: EMPTY
66687: LIST
66688: LIST
66689: PUSH
66690: LD_INT 1
66692: PUSH
66693: LD_INT 1
66695: NEG
66696: PUSH
66697: EMPTY
66698: LIST
66699: LIST
66700: PUSH
66701: LD_INT 2
66703: PUSH
66704: LD_INT 0
66706: PUSH
66707: EMPTY
66708: LIST
66709: LIST
66710: PUSH
66711: LD_INT 2
66713: PUSH
66714: LD_INT 1
66716: PUSH
66717: EMPTY
66718: LIST
66719: LIST
66720: PUSH
66721: LD_INT 2
66723: PUSH
66724: LD_INT 2
66726: PUSH
66727: EMPTY
66728: LIST
66729: LIST
66730: PUSH
66731: LD_INT 1
66733: PUSH
66734: LD_INT 2
66736: PUSH
66737: EMPTY
66738: LIST
66739: LIST
66740: PUSH
66741: LD_INT 0
66743: PUSH
66744: LD_INT 2
66746: PUSH
66747: EMPTY
66748: LIST
66749: LIST
66750: PUSH
66751: LD_INT 1
66753: NEG
66754: PUSH
66755: LD_INT 1
66757: PUSH
66758: EMPTY
66759: LIST
66760: LIST
66761: PUSH
66762: LD_INT 2
66764: NEG
66765: PUSH
66766: LD_INT 1
66768: NEG
66769: PUSH
66770: EMPTY
66771: LIST
66772: LIST
66773: PUSH
66774: LD_INT 2
66776: NEG
66777: PUSH
66778: LD_INT 2
66780: NEG
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: PUSH
66786: LD_INT 2
66788: NEG
66789: PUSH
66790: LD_INT 3
66792: NEG
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: PUSH
66798: LD_INT 2
66800: PUSH
66801: LD_INT 1
66803: NEG
66804: PUSH
66805: EMPTY
66806: LIST
66807: LIST
66808: PUSH
66809: LD_INT 3
66811: PUSH
66812: LD_INT 1
66814: PUSH
66815: EMPTY
66816: LIST
66817: LIST
66818: PUSH
66819: LD_INT 1
66821: PUSH
66822: LD_INT 3
66824: PUSH
66825: EMPTY
66826: LIST
66827: LIST
66828: PUSH
66829: LD_INT 1
66831: NEG
66832: PUSH
66833: LD_INT 2
66835: PUSH
66836: EMPTY
66837: LIST
66838: LIST
66839: PUSH
66840: LD_INT 3
66842: NEG
66843: PUSH
66844: LD_INT 2
66846: NEG
66847: PUSH
66848: EMPTY
66849: LIST
66850: LIST
66851: PUSH
66852: EMPTY
66853: LIST
66854: LIST
66855: LIST
66856: LIST
66857: LIST
66858: LIST
66859: LIST
66860: LIST
66861: LIST
66862: LIST
66863: LIST
66864: LIST
66865: LIST
66866: LIST
66867: LIST
66868: LIST
66869: LIST
66870: LIST
66871: LIST
66872: LIST
66873: LIST
66874: LIST
66875: LIST
66876: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66877: LD_ADDR_VAR 0 32
66881: PUSH
66882: LD_INT 0
66884: PUSH
66885: LD_INT 0
66887: PUSH
66888: EMPTY
66889: LIST
66890: LIST
66891: PUSH
66892: LD_INT 0
66894: PUSH
66895: LD_INT 1
66897: NEG
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PUSH
66903: LD_INT 1
66905: PUSH
66906: LD_INT 0
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PUSH
66913: LD_INT 1
66915: PUSH
66916: LD_INT 1
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: PUSH
66923: LD_INT 0
66925: PUSH
66926: LD_INT 1
66928: PUSH
66929: EMPTY
66930: LIST
66931: LIST
66932: PUSH
66933: LD_INT 1
66935: NEG
66936: PUSH
66937: LD_INT 0
66939: PUSH
66940: EMPTY
66941: LIST
66942: LIST
66943: PUSH
66944: LD_INT 1
66946: NEG
66947: PUSH
66948: LD_INT 1
66950: NEG
66951: PUSH
66952: EMPTY
66953: LIST
66954: LIST
66955: PUSH
66956: LD_INT 1
66958: NEG
66959: PUSH
66960: LD_INT 2
66962: NEG
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: PUSH
66968: LD_INT 0
66970: PUSH
66971: LD_INT 2
66973: NEG
66974: PUSH
66975: EMPTY
66976: LIST
66977: LIST
66978: PUSH
66979: LD_INT 1
66981: PUSH
66982: LD_INT 1
66984: NEG
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: LD_INT 2
66992: PUSH
66993: LD_INT 1
66995: PUSH
66996: EMPTY
66997: LIST
66998: LIST
66999: PUSH
67000: LD_INT 2
67002: PUSH
67003: LD_INT 2
67005: PUSH
67006: EMPTY
67007: LIST
67008: LIST
67009: PUSH
67010: LD_INT 1
67012: PUSH
67013: LD_INT 2
67015: PUSH
67016: EMPTY
67017: LIST
67018: LIST
67019: PUSH
67020: LD_INT 0
67022: PUSH
67023: LD_INT 2
67025: PUSH
67026: EMPTY
67027: LIST
67028: LIST
67029: PUSH
67030: LD_INT 1
67032: NEG
67033: PUSH
67034: LD_INT 1
67036: PUSH
67037: EMPTY
67038: LIST
67039: LIST
67040: PUSH
67041: LD_INT 2
67043: NEG
67044: PUSH
67045: LD_INT 0
67047: PUSH
67048: EMPTY
67049: LIST
67050: LIST
67051: PUSH
67052: LD_INT 2
67054: NEG
67055: PUSH
67056: LD_INT 1
67058: NEG
67059: PUSH
67060: EMPTY
67061: LIST
67062: LIST
67063: PUSH
67064: LD_INT 1
67066: NEG
67067: PUSH
67068: LD_INT 3
67070: NEG
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 1
67078: PUSH
67079: LD_INT 2
67081: NEG
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: LD_INT 3
67089: PUSH
67090: LD_INT 2
67092: PUSH
67093: EMPTY
67094: LIST
67095: LIST
67096: PUSH
67097: LD_INT 2
67099: PUSH
67100: LD_INT 3
67102: PUSH
67103: EMPTY
67104: LIST
67105: LIST
67106: PUSH
67107: LD_INT 2
67109: NEG
67110: PUSH
67111: LD_INT 1
67113: PUSH
67114: EMPTY
67115: LIST
67116: LIST
67117: PUSH
67118: LD_INT 3
67120: NEG
67121: PUSH
67122: LD_INT 1
67124: NEG
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: LIST
67134: LIST
67135: LIST
67136: LIST
67137: LIST
67138: LIST
67139: LIST
67140: LIST
67141: LIST
67142: LIST
67143: LIST
67144: LIST
67145: LIST
67146: LIST
67147: LIST
67148: LIST
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67155: LD_ADDR_VAR 0 33
67159: PUSH
67160: LD_INT 0
67162: PUSH
67163: LD_INT 0
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: PUSH
67170: LD_INT 0
67172: PUSH
67173: LD_INT 1
67175: NEG
67176: PUSH
67177: EMPTY
67178: LIST
67179: LIST
67180: PUSH
67181: LD_INT 1
67183: PUSH
67184: LD_INT 0
67186: PUSH
67187: EMPTY
67188: LIST
67189: LIST
67190: PUSH
67191: LD_INT 1
67193: PUSH
67194: LD_INT 1
67196: PUSH
67197: EMPTY
67198: LIST
67199: LIST
67200: PUSH
67201: LD_INT 0
67203: PUSH
67204: LD_INT 1
67206: PUSH
67207: EMPTY
67208: LIST
67209: LIST
67210: PUSH
67211: LD_INT 1
67213: NEG
67214: PUSH
67215: LD_INT 0
67217: PUSH
67218: EMPTY
67219: LIST
67220: LIST
67221: PUSH
67222: LD_INT 1
67224: NEG
67225: PUSH
67226: LD_INT 1
67228: NEG
67229: PUSH
67230: EMPTY
67231: LIST
67232: LIST
67233: PUSH
67234: LD_INT 1
67236: NEG
67237: PUSH
67238: LD_INT 2
67240: NEG
67241: PUSH
67242: EMPTY
67243: LIST
67244: LIST
67245: PUSH
67246: LD_INT 1
67248: PUSH
67249: LD_INT 1
67251: NEG
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 2
67259: PUSH
67260: LD_INT 0
67262: PUSH
67263: EMPTY
67264: LIST
67265: LIST
67266: PUSH
67267: LD_INT 2
67269: PUSH
67270: LD_INT 1
67272: PUSH
67273: EMPTY
67274: LIST
67275: LIST
67276: PUSH
67277: LD_INT 1
67279: PUSH
67280: LD_INT 2
67282: PUSH
67283: EMPTY
67284: LIST
67285: LIST
67286: PUSH
67287: LD_INT 0
67289: PUSH
67290: LD_INT 2
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: PUSH
67297: LD_INT 1
67299: NEG
67300: PUSH
67301: LD_INT 1
67303: PUSH
67304: EMPTY
67305: LIST
67306: LIST
67307: PUSH
67308: LD_INT 2
67310: NEG
67311: PUSH
67312: LD_INT 0
67314: PUSH
67315: EMPTY
67316: LIST
67317: LIST
67318: PUSH
67319: LD_INT 2
67321: NEG
67322: PUSH
67323: LD_INT 1
67325: NEG
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: PUSH
67331: LD_INT 2
67333: NEG
67334: PUSH
67335: LD_INT 2
67337: NEG
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: PUSH
67343: LD_INT 2
67345: NEG
67346: PUSH
67347: LD_INT 3
67349: NEG
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 2
67357: PUSH
67358: LD_INT 1
67360: NEG
67361: PUSH
67362: EMPTY
67363: LIST
67364: LIST
67365: PUSH
67366: LD_INT 3
67368: PUSH
67369: LD_INT 1
67371: PUSH
67372: EMPTY
67373: LIST
67374: LIST
67375: PUSH
67376: LD_INT 1
67378: PUSH
67379: LD_INT 3
67381: PUSH
67382: EMPTY
67383: LIST
67384: LIST
67385: PUSH
67386: LD_INT 1
67388: NEG
67389: PUSH
67390: LD_INT 2
67392: PUSH
67393: EMPTY
67394: LIST
67395: LIST
67396: PUSH
67397: LD_INT 3
67399: NEG
67400: PUSH
67401: LD_INT 2
67403: NEG
67404: PUSH
67405: EMPTY
67406: LIST
67407: LIST
67408: PUSH
67409: EMPTY
67410: LIST
67411: LIST
67412: LIST
67413: LIST
67414: LIST
67415: LIST
67416: LIST
67417: LIST
67418: LIST
67419: LIST
67420: LIST
67421: LIST
67422: LIST
67423: LIST
67424: LIST
67425: LIST
67426: LIST
67427: LIST
67428: LIST
67429: LIST
67430: LIST
67431: LIST
67432: LIST
67433: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67434: LD_ADDR_VAR 0 34
67438: PUSH
67439: LD_INT 0
67441: PUSH
67442: LD_INT 0
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: PUSH
67449: LD_INT 0
67451: PUSH
67452: LD_INT 1
67454: NEG
67455: PUSH
67456: EMPTY
67457: LIST
67458: LIST
67459: PUSH
67460: LD_INT 1
67462: PUSH
67463: LD_INT 0
67465: PUSH
67466: EMPTY
67467: LIST
67468: LIST
67469: PUSH
67470: LD_INT 1
67472: PUSH
67473: LD_INT 1
67475: PUSH
67476: EMPTY
67477: LIST
67478: LIST
67479: PUSH
67480: LD_INT 0
67482: PUSH
67483: LD_INT 1
67485: PUSH
67486: EMPTY
67487: LIST
67488: LIST
67489: PUSH
67490: LD_INT 1
67492: NEG
67493: PUSH
67494: LD_INT 0
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: PUSH
67501: LD_INT 1
67503: NEG
67504: PUSH
67505: LD_INT 1
67507: NEG
67508: PUSH
67509: EMPTY
67510: LIST
67511: LIST
67512: PUSH
67513: LD_INT 1
67515: NEG
67516: PUSH
67517: LD_INT 2
67519: NEG
67520: PUSH
67521: EMPTY
67522: LIST
67523: LIST
67524: PUSH
67525: LD_INT 0
67527: PUSH
67528: LD_INT 2
67530: NEG
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 1
67538: PUSH
67539: LD_INT 1
67541: NEG
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: PUSH
67547: LD_INT 2
67549: PUSH
67550: LD_INT 1
67552: PUSH
67553: EMPTY
67554: LIST
67555: LIST
67556: PUSH
67557: LD_INT 2
67559: PUSH
67560: LD_INT 2
67562: PUSH
67563: EMPTY
67564: LIST
67565: LIST
67566: PUSH
67567: LD_INT 1
67569: PUSH
67570: LD_INT 2
67572: PUSH
67573: EMPTY
67574: LIST
67575: LIST
67576: PUSH
67577: LD_INT 1
67579: NEG
67580: PUSH
67581: LD_INT 1
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: PUSH
67588: LD_INT 2
67590: NEG
67591: PUSH
67592: LD_INT 0
67594: PUSH
67595: EMPTY
67596: LIST
67597: LIST
67598: PUSH
67599: LD_INT 2
67601: NEG
67602: PUSH
67603: LD_INT 1
67605: NEG
67606: PUSH
67607: EMPTY
67608: LIST
67609: LIST
67610: PUSH
67611: LD_INT 2
67613: NEG
67614: PUSH
67615: LD_INT 2
67617: NEG
67618: PUSH
67619: EMPTY
67620: LIST
67621: LIST
67622: PUSH
67623: LD_INT 1
67625: NEG
67626: PUSH
67627: LD_INT 3
67629: NEG
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: PUSH
67635: LD_INT 1
67637: PUSH
67638: LD_INT 2
67640: NEG
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PUSH
67646: LD_INT 3
67648: PUSH
67649: LD_INT 2
67651: PUSH
67652: EMPTY
67653: LIST
67654: LIST
67655: PUSH
67656: LD_INT 2
67658: PUSH
67659: LD_INT 3
67661: PUSH
67662: EMPTY
67663: LIST
67664: LIST
67665: PUSH
67666: LD_INT 2
67668: NEG
67669: PUSH
67670: LD_INT 1
67672: PUSH
67673: EMPTY
67674: LIST
67675: LIST
67676: PUSH
67677: LD_INT 3
67679: NEG
67680: PUSH
67681: LD_INT 1
67683: NEG
67684: PUSH
67685: EMPTY
67686: LIST
67687: LIST
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: LIST
67693: LIST
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: LIST
67700: LIST
67701: LIST
67702: LIST
67703: LIST
67704: LIST
67705: LIST
67706: LIST
67707: LIST
67708: LIST
67709: LIST
67710: LIST
67711: LIST
67712: LIST
67713: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
67714: LD_ADDR_VAR 0 35
67718: PUSH
67719: LD_INT 0
67721: PUSH
67722: LD_INT 0
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PUSH
67729: LD_INT 0
67731: PUSH
67732: LD_INT 1
67734: NEG
67735: PUSH
67736: EMPTY
67737: LIST
67738: LIST
67739: PUSH
67740: LD_INT 1
67742: PUSH
67743: LD_INT 0
67745: PUSH
67746: EMPTY
67747: LIST
67748: LIST
67749: PUSH
67750: LD_INT 1
67752: PUSH
67753: LD_INT 1
67755: PUSH
67756: EMPTY
67757: LIST
67758: LIST
67759: PUSH
67760: LD_INT 0
67762: PUSH
67763: LD_INT 1
67765: PUSH
67766: EMPTY
67767: LIST
67768: LIST
67769: PUSH
67770: LD_INT 1
67772: NEG
67773: PUSH
67774: LD_INT 0
67776: PUSH
67777: EMPTY
67778: LIST
67779: LIST
67780: PUSH
67781: LD_INT 1
67783: NEG
67784: PUSH
67785: LD_INT 1
67787: NEG
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 2
67795: PUSH
67796: LD_INT 1
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 2
67805: NEG
67806: PUSH
67807: LD_INT 1
67809: NEG
67810: PUSH
67811: EMPTY
67812: LIST
67813: LIST
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: LIST
67819: LIST
67820: LIST
67821: LIST
67822: LIST
67823: LIST
67824: LIST
67825: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
67826: LD_ADDR_VAR 0 36
67830: PUSH
67831: LD_INT 0
67833: PUSH
67834: LD_INT 0
67836: PUSH
67837: EMPTY
67838: LIST
67839: LIST
67840: PUSH
67841: LD_INT 0
67843: PUSH
67844: LD_INT 1
67846: NEG
67847: PUSH
67848: EMPTY
67849: LIST
67850: LIST
67851: PUSH
67852: LD_INT 1
67854: PUSH
67855: LD_INT 0
67857: PUSH
67858: EMPTY
67859: LIST
67860: LIST
67861: PUSH
67862: LD_INT 1
67864: PUSH
67865: LD_INT 1
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: PUSH
67872: LD_INT 0
67874: PUSH
67875: LD_INT 1
67877: PUSH
67878: EMPTY
67879: LIST
67880: LIST
67881: PUSH
67882: LD_INT 1
67884: NEG
67885: PUSH
67886: LD_INT 0
67888: PUSH
67889: EMPTY
67890: LIST
67891: LIST
67892: PUSH
67893: LD_INT 1
67895: NEG
67896: PUSH
67897: LD_INT 1
67899: NEG
67900: PUSH
67901: EMPTY
67902: LIST
67903: LIST
67904: PUSH
67905: LD_INT 1
67907: NEG
67908: PUSH
67909: LD_INT 2
67911: NEG
67912: PUSH
67913: EMPTY
67914: LIST
67915: LIST
67916: PUSH
67917: LD_INT 1
67919: PUSH
67920: LD_INT 2
67922: PUSH
67923: EMPTY
67924: LIST
67925: LIST
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
67938: LD_ADDR_VAR 0 37
67942: PUSH
67943: LD_INT 0
67945: PUSH
67946: LD_INT 0
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 0
67955: PUSH
67956: LD_INT 1
67958: NEG
67959: PUSH
67960: EMPTY
67961: LIST
67962: LIST
67963: PUSH
67964: LD_INT 1
67966: PUSH
67967: LD_INT 0
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PUSH
67974: LD_INT 1
67976: PUSH
67977: LD_INT 1
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 0
67986: PUSH
67987: LD_INT 1
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PUSH
67994: LD_INT 1
67996: NEG
67997: PUSH
67998: LD_INT 0
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: PUSH
68005: LD_INT 1
68007: NEG
68008: PUSH
68009: LD_INT 1
68011: NEG
68012: PUSH
68013: EMPTY
68014: LIST
68015: LIST
68016: PUSH
68017: LD_INT 1
68019: PUSH
68020: LD_INT 1
68022: NEG
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: PUSH
68028: LD_INT 1
68030: NEG
68031: PUSH
68032: LD_INT 1
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PUSH
68039: EMPTY
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: LIST
68046: LIST
68047: LIST
68048: LIST
68049: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68050: LD_ADDR_VAR 0 38
68054: PUSH
68055: LD_INT 0
68057: PUSH
68058: LD_INT 0
68060: PUSH
68061: EMPTY
68062: LIST
68063: LIST
68064: PUSH
68065: LD_INT 0
68067: PUSH
68068: LD_INT 1
68070: NEG
68071: PUSH
68072: EMPTY
68073: LIST
68074: LIST
68075: PUSH
68076: LD_INT 1
68078: PUSH
68079: LD_INT 0
68081: PUSH
68082: EMPTY
68083: LIST
68084: LIST
68085: PUSH
68086: LD_INT 1
68088: PUSH
68089: LD_INT 1
68091: PUSH
68092: EMPTY
68093: LIST
68094: LIST
68095: PUSH
68096: LD_INT 0
68098: PUSH
68099: LD_INT 1
68101: PUSH
68102: EMPTY
68103: LIST
68104: LIST
68105: PUSH
68106: LD_INT 1
68108: NEG
68109: PUSH
68110: LD_INT 0
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: PUSH
68117: LD_INT 1
68119: NEG
68120: PUSH
68121: LD_INT 1
68123: NEG
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PUSH
68129: LD_INT 2
68131: PUSH
68132: LD_INT 1
68134: PUSH
68135: EMPTY
68136: LIST
68137: LIST
68138: PUSH
68139: LD_INT 2
68141: NEG
68142: PUSH
68143: LD_INT 1
68145: NEG
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: PUSH
68151: EMPTY
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68162: LD_ADDR_VAR 0 39
68166: PUSH
68167: LD_INT 0
68169: PUSH
68170: LD_INT 0
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: PUSH
68177: LD_INT 0
68179: PUSH
68180: LD_INT 1
68182: NEG
68183: PUSH
68184: EMPTY
68185: LIST
68186: LIST
68187: PUSH
68188: LD_INT 1
68190: PUSH
68191: LD_INT 0
68193: PUSH
68194: EMPTY
68195: LIST
68196: LIST
68197: PUSH
68198: LD_INT 1
68200: PUSH
68201: LD_INT 1
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 0
68210: PUSH
68211: LD_INT 1
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 1
68220: NEG
68221: PUSH
68222: LD_INT 0
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 1
68231: NEG
68232: PUSH
68233: LD_INT 1
68235: NEG
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: PUSH
68241: LD_INT 1
68243: NEG
68244: PUSH
68245: LD_INT 2
68247: NEG
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PUSH
68253: LD_INT 1
68255: PUSH
68256: LD_INT 2
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: LIST
68270: LIST
68271: LIST
68272: LIST
68273: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68274: LD_ADDR_VAR 0 40
68278: PUSH
68279: LD_INT 0
68281: PUSH
68282: LD_INT 0
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: PUSH
68289: LD_INT 0
68291: PUSH
68292: LD_INT 1
68294: NEG
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: LD_INT 1
68302: PUSH
68303: LD_INT 0
68305: PUSH
68306: EMPTY
68307: LIST
68308: LIST
68309: PUSH
68310: LD_INT 1
68312: PUSH
68313: LD_INT 1
68315: PUSH
68316: EMPTY
68317: LIST
68318: LIST
68319: PUSH
68320: LD_INT 0
68322: PUSH
68323: LD_INT 1
68325: PUSH
68326: EMPTY
68327: LIST
68328: LIST
68329: PUSH
68330: LD_INT 1
68332: NEG
68333: PUSH
68334: LD_INT 0
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: LD_INT 1
68343: NEG
68344: PUSH
68345: LD_INT 1
68347: NEG
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 1
68355: PUSH
68356: LD_INT 1
68358: NEG
68359: PUSH
68360: EMPTY
68361: LIST
68362: LIST
68363: PUSH
68364: LD_INT 1
68366: NEG
68367: PUSH
68368: LD_INT 1
68370: PUSH
68371: EMPTY
68372: LIST
68373: LIST
68374: PUSH
68375: EMPTY
68376: LIST
68377: LIST
68378: LIST
68379: LIST
68380: LIST
68381: LIST
68382: LIST
68383: LIST
68384: LIST
68385: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68386: LD_ADDR_VAR 0 41
68390: PUSH
68391: LD_INT 0
68393: PUSH
68394: LD_INT 0
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: PUSH
68401: LD_INT 0
68403: PUSH
68404: LD_INT 1
68406: NEG
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: LD_INT 1
68414: PUSH
68415: LD_INT 0
68417: PUSH
68418: EMPTY
68419: LIST
68420: LIST
68421: PUSH
68422: LD_INT 1
68424: PUSH
68425: LD_INT 1
68427: PUSH
68428: EMPTY
68429: LIST
68430: LIST
68431: PUSH
68432: LD_INT 0
68434: PUSH
68435: LD_INT 1
68437: PUSH
68438: EMPTY
68439: LIST
68440: LIST
68441: PUSH
68442: LD_INT 1
68444: NEG
68445: PUSH
68446: LD_INT 0
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: LD_INT 1
68455: NEG
68456: PUSH
68457: LD_INT 1
68459: NEG
68460: PUSH
68461: EMPTY
68462: LIST
68463: LIST
68464: PUSH
68465: LD_INT 1
68467: NEG
68468: PUSH
68469: LD_INT 2
68471: NEG
68472: PUSH
68473: EMPTY
68474: LIST
68475: LIST
68476: PUSH
68477: LD_INT 1
68479: PUSH
68480: LD_INT 1
68482: NEG
68483: PUSH
68484: EMPTY
68485: LIST
68486: LIST
68487: PUSH
68488: LD_INT 2
68490: PUSH
68491: LD_INT 0
68493: PUSH
68494: EMPTY
68495: LIST
68496: LIST
68497: PUSH
68498: LD_INT 2
68500: PUSH
68501: LD_INT 1
68503: PUSH
68504: EMPTY
68505: LIST
68506: LIST
68507: PUSH
68508: LD_INT 2
68510: PUSH
68511: LD_INT 2
68513: PUSH
68514: EMPTY
68515: LIST
68516: LIST
68517: PUSH
68518: LD_INT 1
68520: PUSH
68521: LD_INT 2
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: PUSH
68528: LD_INT 1
68530: NEG
68531: PUSH
68532: LD_INT 1
68534: PUSH
68535: EMPTY
68536: LIST
68537: LIST
68538: PUSH
68539: LD_INT 2
68541: NEG
68542: PUSH
68543: LD_INT 0
68545: PUSH
68546: EMPTY
68547: LIST
68548: LIST
68549: PUSH
68550: LD_INT 2
68552: NEG
68553: PUSH
68554: LD_INT 1
68556: NEG
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: PUSH
68562: LD_INT 2
68564: NEG
68565: PUSH
68566: LD_INT 2
68568: NEG
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: PUSH
68574: LD_INT 2
68576: NEG
68577: PUSH
68578: LD_INT 3
68580: NEG
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PUSH
68586: LD_INT 2
68588: PUSH
68589: LD_INT 1
68591: NEG
68592: PUSH
68593: EMPTY
68594: LIST
68595: LIST
68596: PUSH
68597: LD_INT 3
68599: PUSH
68600: LD_INT 0
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PUSH
68607: LD_INT 3
68609: PUSH
68610: LD_INT 1
68612: PUSH
68613: EMPTY
68614: LIST
68615: LIST
68616: PUSH
68617: LD_INT 3
68619: PUSH
68620: LD_INT 2
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: PUSH
68627: LD_INT 3
68629: PUSH
68630: LD_INT 3
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: PUSH
68637: LD_INT 2
68639: PUSH
68640: LD_INT 3
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: PUSH
68647: LD_INT 2
68649: NEG
68650: PUSH
68651: LD_INT 1
68653: PUSH
68654: EMPTY
68655: LIST
68656: LIST
68657: PUSH
68658: LD_INT 3
68660: NEG
68661: PUSH
68662: LD_INT 0
68664: PUSH
68665: EMPTY
68666: LIST
68667: LIST
68668: PUSH
68669: LD_INT 3
68671: NEG
68672: PUSH
68673: LD_INT 1
68675: NEG
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PUSH
68681: LD_INT 3
68683: NEG
68684: PUSH
68685: LD_INT 2
68687: NEG
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: PUSH
68693: LD_INT 3
68695: NEG
68696: PUSH
68697: LD_INT 3
68699: NEG
68700: PUSH
68701: EMPTY
68702: LIST
68703: LIST
68704: PUSH
68705: EMPTY
68706: LIST
68707: LIST
68708: LIST
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: LIST
68719: LIST
68720: LIST
68721: LIST
68722: LIST
68723: LIST
68724: LIST
68725: LIST
68726: LIST
68727: LIST
68728: LIST
68729: LIST
68730: LIST
68731: LIST
68732: LIST
68733: LIST
68734: LIST
68735: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68736: LD_ADDR_VAR 0 42
68740: PUSH
68741: LD_INT 0
68743: PUSH
68744: LD_INT 0
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: PUSH
68751: LD_INT 0
68753: PUSH
68754: LD_INT 1
68756: NEG
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: PUSH
68762: LD_INT 1
68764: PUSH
68765: LD_INT 0
68767: PUSH
68768: EMPTY
68769: LIST
68770: LIST
68771: PUSH
68772: LD_INT 1
68774: PUSH
68775: LD_INT 1
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PUSH
68782: LD_INT 0
68784: PUSH
68785: LD_INT 1
68787: PUSH
68788: EMPTY
68789: LIST
68790: LIST
68791: PUSH
68792: LD_INT 1
68794: NEG
68795: PUSH
68796: LD_INT 0
68798: PUSH
68799: EMPTY
68800: LIST
68801: LIST
68802: PUSH
68803: LD_INT 1
68805: NEG
68806: PUSH
68807: LD_INT 1
68809: NEG
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: PUSH
68815: LD_INT 1
68817: NEG
68818: PUSH
68819: LD_INT 2
68821: NEG
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PUSH
68827: LD_INT 0
68829: PUSH
68830: LD_INT 2
68832: NEG
68833: PUSH
68834: EMPTY
68835: LIST
68836: LIST
68837: PUSH
68838: LD_INT 1
68840: PUSH
68841: LD_INT 1
68843: NEG
68844: PUSH
68845: EMPTY
68846: LIST
68847: LIST
68848: PUSH
68849: LD_INT 2
68851: PUSH
68852: LD_INT 1
68854: PUSH
68855: EMPTY
68856: LIST
68857: LIST
68858: PUSH
68859: LD_INT 2
68861: PUSH
68862: LD_INT 2
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: PUSH
68869: LD_INT 1
68871: PUSH
68872: LD_INT 2
68874: PUSH
68875: EMPTY
68876: LIST
68877: LIST
68878: PUSH
68879: LD_INT 0
68881: PUSH
68882: LD_INT 2
68884: PUSH
68885: EMPTY
68886: LIST
68887: LIST
68888: PUSH
68889: LD_INT 1
68891: NEG
68892: PUSH
68893: LD_INT 1
68895: PUSH
68896: EMPTY
68897: LIST
68898: LIST
68899: PUSH
68900: LD_INT 2
68902: NEG
68903: PUSH
68904: LD_INT 1
68906: NEG
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PUSH
68912: LD_INT 2
68914: NEG
68915: PUSH
68916: LD_INT 2
68918: NEG
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PUSH
68924: LD_INT 2
68926: NEG
68927: PUSH
68928: LD_INT 3
68930: NEG
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: PUSH
68936: LD_INT 1
68938: NEG
68939: PUSH
68940: LD_INT 3
68942: NEG
68943: PUSH
68944: EMPTY
68945: LIST
68946: LIST
68947: PUSH
68948: LD_INT 0
68950: PUSH
68951: LD_INT 3
68953: NEG
68954: PUSH
68955: EMPTY
68956: LIST
68957: LIST
68958: PUSH
68959: LD_INT 1
68961: PUSH
68962: LD_INT 2
68964: NEG
68965: PUSH
68966: EMPTY
68967: LIST
68968: LIST
68969: PUSH
68970: LD_INT 3
68972: PUSH
68973: LD_INT 2
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: PUSH
68980: LD_INT 3
68982: PUSH
68983: LD_INT 3
68985: PUSH
68986: EMPTY
68987: LIST
68988: LIST
68989: PUSH
68990: LD_INT 2
68992: PUSH
68993: LD_INT 3
68995: PUSH
68996: EMPTY
68997: LIST
68998: LIST
68999: PUSH
69000: LD_INT 1
69002: PUSH
69003: LD_INT 3
69005: PUSH
69006: EMPTY
69007: LIST
69008: LIST
69009: PUSH
69010: LD_INT 0
69012: PUSH
69013: LD_INT 3
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PUSH
69020: LD_INT 1
69022: NEG
69023: PUSH
69024: LD_INT 2
69026: PUSH
69027: EMPTY
69028: LIST
69029: LIST
69030: PUSH
69031: LD_INT 3
69033: NEG
69034: PUSH
69035: LD_INT 2
69037: NEG
69038: PUSH
69039: EMPTY
69040: LIST
69041: LIST
69042: PUSH
69043: LD_INT 3
69045: NEG
69046: PUSH
69047: LD_INT 3
69049: NEG
69050: PUSH
69051: EMPTY
69052: LIST
69053: LIST
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: LIST
69059: LIST
69060: LIST
69061: LIST
69062: LIST
69063: LIST
69064: LIST
69065: LIST
69066: LIST
69067: LIST
69068: LIST
69069: LIST
69070: LIST
69071: LIST
69072: LIST
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69086: LD_ADDR_VAR 0 43
69090: PUSH
69091: LD_INT 0
69093: PUSH
69094: LD_INT 0
69096: PUSH
69097: EMPTY
69098: LIST
69099: LIST
69100: PUSH
69101: LD_INT 0
69103: PUSH
69104: LD_INT 1
69106: NEG
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: PUSH
69112: LD_INT 1
69114: PUSH
69115: LD_INT 0
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PUSH
69122: LD_INT 1
69124: PUSH
69125: LD_INT 1
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: PUSH
69132: LD_INT 0
69134: PUSH
69135: LD_INT 1
69137: PUSH
69138: EMPTY
69139: LIST
69140: LIST
69141: PUSH
69142: LD_INT 1
69144: NEG
69145: PUSH
69146: LD_INT 0
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 1
69155: NEG
69156: PUSH
69157: LD_INT 1
69159: NEG
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: PUSH
69165: LD_INT 1
69167: NEG
69168: PUSH
69169: LD_INT 2
69171: NEG
69172: PUSH
69173: EMPTY
69174: LIST
69175: LIST
69176: PUSH
69177: LD_INT 0
69179: PUSH
69180: LD_INT 2
69182: NEG
69183: PUSH
69184: EMPTY
69185: LIST
69186: LIST
69187: PUSH
69188: LD_INT 1
69190: PUSH
69191: LD_INT 1
69193: NEG
69194: PUSH
69195: EMPTY
69196: LIST
69197: LIST
69198: PUSH
69199: LD_INT 2
69201: PUSH
69202: LD_INT 0
69204: PUSH
69205: EMPTY
69206: LIST
69207: LIST
69208: PUSH
69209: LD_INT 2
69211: PUSH
69212: LD_INT 1
69214: PUSH
69215: EMPTY
69216: LIST
69217: LIST
69218: PUSH
69219: LD_INT 1
69221: PUSH
69222: LD_INT 2
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: PUSH
69229: LD_INT 0
69231: PUSH
69232: LD_INT 2
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: PUSH
69239: LD_INT 1
69241: NEG
69242: PUSH
69243: LD_INT 1
69245: PUSH
69246: EMPTY
69247: LIST
69248: LIST
69249: PUSH
69250: LD_INT 2
69252: NEG
69253: PUSH
69254: LD_INT 0
69256: PUSH
69257: EMPTY
69258: LIST
69259: LIST
69260: PUSH
69261: LD_INT 2
69263: NEG
69264: PUSH
69265: LD_INT 1
69267: NEG
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: PUSH
69273: LD_INT 1
69275: NEG
69276: PUSH
69277: LD_INT 3
69279: NEG
69280: PUSH
69281: EMPTY
69282: LIST
69283: LIST
69284: PUSH
69285: LD_INT 0
69287: PUSH
69288: LD_INT 3
69290: NEG
69291: PUSH
69292: EMPTY
69293: LIST
69294: LIST
69295: PUSH
69296: LD_INT 1
69298: PUSH
69299: LD_INT 2
69301: NEG
69302: PUSH
69303: EMPTY
69304: LIST
69305: LIST
69306: PUSH
69307: LD_INT 2
69309: PUSH
69310: LD_INT 1
69312: NEG
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: PUSH
69318: LD_INT 3
69320: PUSH
69321: LD_INT 0
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: PUSH
69328: LD_INT 3
69330: PUSH
69331: LD_INT 1
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: LD_INT 1
69340: PUSH
69341: LD_INT 3
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: PUSH
69348: LD_INT 0
69350: PUSH
69351: LD_INT 3
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: PUSH
69358: LD_INT 1
69360: NEG
69361: PUSH
69362: LD_INT 2
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: PUSH
69369: LD_INT 2
69371: NEG
69372: PUSH
69373: LD_INT 1
69375: PUSH
69376: EMPTY
69377: LIST
69378: LIST
69379: PUSH
69380: LD_INT 3
69382: NEG
69383: PUSH
69384: LD_INT 0
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: PUSH
69391: LD_INT 3
69393: NEG
69394: PUSH
69395: LD_INT 1
69397: NEG
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: LIST
69415: LIST
69416: LIST
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: LIST
69425: LIST
69426: LIST
69427: LIST
69428: LIST
69429: LIST
69430: LIST
69431: LIST
69432: LIST
69433: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69434: LD_ADDR_VAR 0 44
69438: PUSH
69439: LD_INT 0
69441: PUSH
69442: LD_INT 0
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 0
69451: PUSH
69452: LD_INT 1
69454: NEG
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PUSH
69460: LD_INT 1
69462: PUSH
69463: LD_INT 0
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PUSH
69470: LD_INT 1
69472: PUSH
69473: LD_INT 1
69475: PUSH
69476: EMPTY
69477: LIST
69478: LIST
69479: PUSH
69480: LD_INT 0
69482: PUSH
69483: LD_INT 1
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: LD_INT 1
69492: NEG
69493: PUSH
69494: LD_INT 0
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 1
69503: NEG
69504: PUSH
69505: LD_INT 1
69507: NEG
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: LD_INT 1
69515: NEG
69516: PUSH
69517: LD_INT 2
69519: NEG
69520: PUSH
69521: EMPTY
69522: LIST
69523: LIST
69524: PUSH
69525: LD_INT 1
69527: PUSH
69528: LD_INT 1
69530: NEG
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: PUSH
69536: LD_INT 2
69538: PUSH
69539: LD_INT 0
69541: PUSH
69542: EMPTY
69543: LIST
69544: LIST
69545: PUSH
69546: LD_INT 2
69548: PUSH
69549: LD_INT 1
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: PUSH
69556: LD_INT 2
69558: PUSH
69559: LD_INT 2
69561: PUSH
69562: EMPTY
69563: LIST
69564: LIST
69565: PUSH
69566: LD_INT 1
69568: PUSH
69569: LD_INT 2
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: PUSH
69576: LD_INT 1
69578: NEG
69579: PUSH
69580: LD_INT 1
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: PUSH
69587: LD_INT 2
69589: NEG
69590: PUSH
69591: LD_INT 0
69593: PUSH
69594: EMPTY
69595: LIST
69596: LIST
69597: PUSH
69598: LD_INT 2
69600: NEG
69601: PUSH
69602: LD_INT 1
69604: NEG
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: PUSH
69610: LD_INT 2
69612: NEG
69613: PUSH
69614: LD_INT 2
69616: NEG
69617: PUSH
69618: EMPTY
69619: LIST
69620: LIST
69621: PUSH
69622: LD_INT 2
69624: NEG
69625: PUSH
69626: LD_INT 3
69628: NEG
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: PUSH
69634: LD_INT 2
69636: PUSH
69637: LD_INT 1
69639: NEG
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: PUSH
69645: LD_INT 3
69647: PUSH
69648: LD_INT 0
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: PUSH
69655: LD_INT 3
69657: PUSH
69658: LD_INT 1
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 3
69667: PUSH
69668: LD_INT 2
69670: PUSH
69671: EMPTY
69672: LIST
69673: LIST
69674: PUSH
69675: LD_INT 3
69677: PUSH
69678: LD_INT 3
69680: PUSH
69681: EMPTY
69682: LIST
69683: LIST
69684: PUSH
69685: LD_INT 2
69687: PUSH
69688: LD_INT 3
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: PUSH
69695: LD_INT 2
69697: NEG
69698: PUSH
69699: LD_INT 1
69701: PUSH
69702: EMPTY
69703: LIST
69704: LIST
69705: PUSH
69706: LD_INT 3
69708: NEG
69709: PUSH
69710: LD_INT 0
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: PUSH
69717: LD_INT 3
69719: NEG
69720: PUSH
69721: LD_INT 1
69723: NEG
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: PUSH
69729: LD_INT 3
69731: NEG
69732: PUSH
69733: LD_INT 2
69735: NEG
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: LD_INT 3
69743: NEG
69744: PUSH
69745: LD_INT 3
69747: NEG
69748: PUSH
69749: EMPTY
69750: LIST
69751: LIST
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: LIST
69757: LIST
69758: LIST
69759: LIST
69760: LIST
69761: LIST
69762: LIST
69763: LIST
69764: LIST
69765: LIST
69766: LIST
69767: LIST
69768: LIST
69769: LIST
69770: LIST
69771: LIST
69772: LIST
69773: LIST
69774: LIST
69775: LIST
69776: LIST
69777: LIST
69778: LIST
69779: LIST
69780: LIST
69781: LIST
69782: LIST
69783: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69784: LD_ADDR_VAR 0 45
69788: PUSH
69789: LD_INT 0
69791: PUSH
69792: LD_INT 0
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PUSH
69799: LD_INT 0
69801: PUSH
69802: LD_INT 1
69804: NEG
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: PUSH
69810: LD_INT 1
69812: PUSH
69813: LD_INT 0
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: LD_INT 1
69822: PUSH
69823: LD_INT 1
69825: PUSH
69826: EMPTY
69827: LIST
69828: LIST
69829: PUSH
69830: LD_INT 0
69832: PUSH
69833: LD_INT 1
69835: PUSH
69836: EMPTY
69837: LIST
69838: LIST
69839: PUSH
69840: LD_INT 1
69842: NEG
69843: PUSH
69844: LD_INT 0
69846: PUSH
69847: EMPTY
69848: LIST
69849: LIST
69850: PUSH
69851: LD_INT 1
69853: NEG
69854: PUSH
69855: LD_INT 1
69857: NEG
69858: PUSH
69859: EMPTY
69860: LIST
69861: LIST
69862: PUSH
69863: LD_INT 1
69865: NEG
69866: PUSH
69867: LD_INT 2
69869: NEG
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: PUSH
69875: LD_INT 0
69877: PUSH
69878: LD_INT 2
69880: NEG
69881: PUSH
69882: EMPTY
69883: LIST
69884: LIST
69885: PUSH
69886: LD_INT 1
69888: PUSH
69889: LD_INT 1
69891: NEG
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PUSH
69897: LD_INT 2
69899: PUSH
69900: LD_INT 1
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: PUSH
69907: LD_INT 2
69909: PUSH
69910: LD_INT 2
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: LD_INT 1
69919: PUSH
69920: LD_INT 2
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: PUSH
69927: LD_INT 0
69929: PUSH
69930: LD_INT 2
69932: PUSH
69933: EMPTY
69934: LIST
69935: LIST
69936: PUSH
69937: LD_INT 1
69939: NEG
69940: PUSH
69941: LD_INT 1
69943: PUSH
69944: EMPTY
69945: LIST
69946: LIST
69947: PUSH
69948: LD_INT 2
69950: NEG
69951: PUSH
69952: LD_INT 1
69954: NEG
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: LD_INT 2
69962: NEG
69963: PUSH
69964: LD_INT 2
69966: NEG
69967: PUSH
69968: EMPTY
69969: LIST
69970: LIST
69971: PUSH
69972: LD_INT 2
69974: NEG
69975: PUSH
69976: LD_INT 3
69978: NEG
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: PUSH
69984: LD_INT 1
69986: NEG
69987: PUSH
69988: LD_INT 3
69990: NEG
69991: PUSH
69992: EMPTY
69993: LIST
69994: LIST
69995: PUSH
69996: LD_INT 0
69998: PUSH
69999: LD_INT 3
70001: NEG
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: PUSH
70007: LD_INT 1
70009: PUSH
70010: LD_INT 2
70012: NEG
70013: PUSH
70014: EMPTY
70015: LIST
70016: LIST
70017: PUSH
70018: LD_INT 3
70020: PUSH
70021: LD_INT 2
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: PUSH
70028: LD_INT 3
70030: PUSH
70031: LD_INT 3
70033: PUSH
70034: EMPTY
70035: LIST
70036: LIST
70037: PUSH
70038: LD_INT 2
70040: PUSH
70041: LD_INT 3
70043: PUSH
70044: EMPTY
70045: LIST
70046: LIST
70047: PUSH
70048: LD_INT 1
70050: PUSH
70051: LD_INT 3
70053: PUSH
70054: EMPTY
70055: LIST
70056: LIST
70057: PUSH
70058: LD_INT 0
70060: PUSH
70061: LD_INT 3
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: PUSH
70068: LD_INT 1
70070: NEG
70071: PUSH
70072: LD_INT 2
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: LD_INT 3
70081: NEG
70082: PUSH
70083: LD_INT 2
70085: NEG
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 3
70093: NEG
70094: PUSH
70095: LD_INT 3
70097: NEG
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: LIST
70107: LIST
70108: LIST
70109: LIST
70110: LIST
70111: LIST
70112: LIST
70113: LIST
70114: LIST
70115: LIST
70116: LIST
70117: LIST
70118: LIST
70119: LIST
70120: LIST
70121: LIST
70122: LIST
70123: LIST
70124: LIST
70125: LIST
70126: LIST
70127: LIST
70128: LIST
70129: LIST
70130: LIST
70131: LIST
70132: LIST
70133: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70134: LD_ADDR_VAR 0 46
70138: PUSH
70139: LD_INT 0
70141: PUSH
70142: LD_INT 0
70144: PUSH
70145: EMPTY
70146: LIST
70147: LIST
70148: PUSH
70149: LD_INT 0
70151: PUSH
70152: LD_INT 1
70154: NEG
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: PUSH
70160: LD_INT 1
70162: PUSH
70163: LD_INT 0
70165: PUSH
70166: EMPTY
70167: LIST
70168: LIST
70169: PUSH
70170: LD_INT 1
70172: PUSH
70173: LD_INT 1
70175: PUSH
70176: EMPTY
70177: LIST
70178: LIST
70179: PUSH
70180: LD_INT 0
70182: PUSH
70183: LD_INT 1
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 1
70192: NEG
70193: PUSH
70194: LD_INT 0
70196: PUSH
70197: EMPTY
70198: LIST
70199: LIST
70200: PUSH
70201: LD_INT 1
70203: NEG
70204: PUSH
70205: LD_INT 1
70207: NEG
70208: PUSH
70209: EMPTY
70210: LIST
70211: LIST
70212: PUSH
70213: LD_INT 1
70215: NEG
70216: PUSH
70217: LD_INT 2
70219: NEG
70220: PUSH
70221: EMPTY
70222: LIST
70223: LIST
70224: PUSH
70225: LD_INT 0
70227: PUSH
70228: LD_INT 2
70230: NEG
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PUSH
70236: LD_INT 1
70238: PUSH
70239: LD_INT 1
70241: NEG
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: PUSH
70247: LD_INT 2
70249: PUSH
70250: LD_INT 0
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: LD_INT 2
70259: PUSH
70260: LD_INT 1
70262: PUSH
70263: EMPTY
70264: LIST
70265: LIST
70266: PUSH
70267: LD_INT 1
70269: PUSH
70270: LD_INT 2
70272: PUSH
70273: EMPTY
70274: LIST
70275: LIST
70276: PUSH
70277: LD_INT 0
70279: PUSH
70280: LD_INT 2
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: PUSH
70287: LD_INT 1
70289: NEG
70290: PUSH
70291: LD_INT 1
70293: PUSH
70294: EMPTY
70295: LIST
70296: LIST
70297: PUSH
70298: LD_INT 2
70300: NEG
70301: PUSH
70302: LD_INT 0
70304: PUSH
70305: EMPTY
70306: LIST
70307: LIST
70308: PUSH
70309: LD_INT 2
70311: NEG
70312: PUSH
70313: LD_INT 1
70315: NEG
70316: PUSH
70317: EMPTY
70318: LIST
70319: LIST
70320: PUSH
70321: LD_INT 1
70323: NEG
70324: PUSH
70325: LD_INT 3
70327: NEG
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: PUSH
70333: LD_INT 0
70335: PUSH
70336: LD_INT 3
70338: NEG
70339: PUSH
70340: EMPTY
70341: LIST
70342: LIST
70343: PUSH
70344: LD_INT 1
70346: PUSH
70347: LD_INT 2
70349: NEG
70350: PUSH
70351: EMPTY
70352: LIST
70353: LIST
70354: PUSH
70355: LD_INT 2
70357: PUSH
70358: LD_INT 1
70360: NEG
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: PUSH
70366: LD_INT 3
70368: PUSH
70369: LD_INT 0
70371: PUSH
70372: EMPTY
70373: LIST
70374: LIST
70375: PUSH
70376: LD_INT 3
70378: PUSH
70379: LD_INT 1
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PUSH
70386: LD_INT 1
70388: PUSH
70389: LD_INT 3
70391: PUSH
70392: EMPTY
70393: LIST
70394: LIST
70395: PUSH
70396: LD_INT 0
70398: PUSH
70399: LD_INT 3
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: LD_INT 1
70408: NEG
70409: PUSH
70410: LD_INT 2
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 2
70419: NEG
70420: PUSH
70421: LD_INT 1
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: PUSH
70428: LD_INT 3
70430: NEG
70431: PUSH
70432: LD_INT 0
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: PUSH
70439: LD_INT 3
70441: NEG
70442: PUSH
70443: LD_INT 1
70445: NEG
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: PUSH
70451: EMPTY
70452: LIST
70453: LIST
70454: LIST
70455: LIST
70456: LIST
70457: LIST
70458: LIST
70459: LIST
70460: LIST
70461: LIST
70462: LIST
70463: LIST
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: LIST
70472: LIST
70473: LIST
70474: LIST
70475: LIST
70476: LIST
70477: LIST
70478: LIST
70479: LIST
70480: LIST
70481: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70482: LD_ADDR_VAR 0 47
70486: PUSH
70487: LD_INT 0
70489: PUSH
70490: LD_INT 0
70492: PUSH
70493: EMPTY
70494: LIST
70495: LIST
70496: PUSH
70497: LD_INT 0
70499: PUSH
70500: LD_INT 1
70502: NEG
70503: PUSH
70504: EMPTY
70505: LIST
70506: LIST
70507: PUSH
70508: LD_INT 1
70510: PUSH
70511: LD_INT 0
70513: PUSH
70514: EMPTY
70515: LIST
70516: LIST
70517: PUSH
70518: LD_INT 1
70520: PUSH
70521: LD_INT 1
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: PUSH
70528: LD_INT 0
70530: PUSH
70531: LD_INT 1
70533: PUSH
70534: EMPTY
70535: LIST
70536: LIST
70537: PUSH
70538: LD_INT 1
70540: NEG
70541: PUSH
70542: LD_INT 0
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 1
70551: NEG
70552: PUSH
70553: LD_INT 1
70555: NEG
70556: PUSH
70557: EMPTY
70558: LIST
70559: LIST
70560: PUSH
70561: LD_INT 1
70563: NEG
70564: PUSH
70565: LD_INT 2
70567: NEG
70568: PUSH
70569: EMPTY
70570: LIST
70571: LIST
70572: PUSH
70573: LD_INT 0
70575: PUSH
70576: LD_INT 2
70578: NEG
70579: PUSH
70580: EMPTY
70581: LIST
70582: LIST
70583: PUSH
70584: LD_INT 1
70586: PUSH
70587: LD_INT 1
70589: NEG
70590: PUSH
70591: EMPTY
70592: LIST
70593: LIST
70594: PUSH
70595: LD_INT 2
70597: NEG
70598: PUSH
70599: LD_INT 1
70601: NEG
70602: PUSH
70603: EMPTY
70604: LIST
70605: LIST
70606: PUSH
70607: LD_INT 2
70609: NEG
70610: PUSH
70611: LD_INT 2
70613: NEG
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: LIST
70623: LIST
70624: LIST
70625: LIST
70626: LIST
70627: LIST
70628: LIST
70629: LIST
70630: LIST
70631: LIST
70632: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
70633: LD_ADDR_VAR 0 48
70637: PUSH
70638: LD_INT 0
70640: PUSH
70641: LD_INT 0
70643: PUSH
70644: EMPTY
70645: LIST
70646: LIST
70647: PUSH
70648: LD_INT 0
70650: PUSH
70651: LD_INT 1
70653: NEG
70654: PUSH
70655: EMPTY
70656: LIST
70657: LIST
70658: PUSH
70659: LD_INT 1
70661: PUSH
70662: LD_INT 0
70664: PUSH
70665: EMPTY
70666: LIST
70667: LIST
70668: PUSH
70669: LD_INT 1
70671: PUSH
70672: LD_INT 1
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: PUSH
70679: LD_INT 0
70681: PUSH
70682: LD_INT 1
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: LD_INT 1
70691: NEG
70692: PUSH
70693: LD_INT 0
70695: PUSH
70696: EMPTY
70697: LIST
70698: LIST
70699: PUSH
70700: LD_INT 1
70702: NEG
70703: PUSH
70704: LD_INT 1
70706: NEG
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: PUSH
70712: LD_INT 1
70714: NEG
70715: PUSH
70716: LD_INT 2
70718: NEG
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: LD_INT 0
70726: PUSH
70727: LD_INT 2
70729: NEG
70730: PUSH
70731: EMPTY
70732: LIST
70733: LIST
70734: PUSH
70735: LD_INT 1
70737: PUSH
70738: LD_INT 1
70740: NEG
70741: PUSH
70742: EMPTY
70743: LIST
70744: LIST
70745: PUSH
70746: LD_INT 2
70748: PUSH
70749: LD_INT 0
70751: PUSH
70752: EMPTY
70753: LIST
70754: LIST
70755: PUSH
70756: LD_INT 2
70758: PUSH
70759: LD_INT 1
70761: PUSH
70762: EMPTY
70763: LIST
70764: LIST
70765: PUSH
70766: EMPTY
70767: LIST
70768: LIST
70769: LIST
70770: LIST
70771: LIST
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
70780: LD_ADDR_VAR 0 49
70784: PUSH
70785: LD_INT 0
70787: PUSH
70788: LD_INT 0
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: PUSH
70795: LD_INT 0
70797: PUSH
70798: LD_INT 1
70800: NEG
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 1
70808: PUSH
70809: LD_INT 0
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: LD_INT 1
70818: PUSH
70819: LD_INT 1
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: PUSH
70826: LD_INT 0
70828: PUSH
70829: LD_INT 1
70831: PUSH
70832: EMPTY
70833: LIST
70834: LIST
70835: PUSH
70836: LD_INT 1
70838: NEG
70839: PUSH
70840: LD_INT 0
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 1
70849: NEG
70850: PUSH
70851: LD_INT 1
70853: NEG
70854: PUSH
70855: EMPTY
70856: LIST
70857: LIST
70858: PUSH
70859: LD_INT 1
70861: PUSH
70862: LD_INT 1
70864: NEG
70865: PUSH
70866: EMPTY
70867: LIST
70868: LIST
70869: PUSH
70870: LD_INT 2
70872: PUSH
70873: LD_INT 0
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: PUSH
70880: LD_INT 2
70882: PUSH
70883: LD_INT 1
70885: PUSH
70886: EMPTY
70887: LIST
70888: LIST
70889: PUSH
70890: LD_INT 2
70892: PUSH
70893: LD_INT 2
70895: PUSH
70896: EMPTY
70897: LIST
70898: LIST
70899: PUSH
70900: LD_INT 1
70902: PUSH
70903: LD_INT 2
70905: PUSH
70906: EMPTY
70907: LIST
70908: LIST
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
70924: LD_ADDR_VAR 0 50
70928: PUSH
70929: LD_INT 0
70931: PUSH
70932: LD_INT 0
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: PUSH
70939: LD_INT 0
70941: PUSH
70942: LD_INT 1
70944: NEG
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 1
70952: PUSH
70953: LD_INT 0
70955: PUSH
70956: EMPTY
70957: LIST
70958: LIST
70959: PUSH
70960: LD_INT 1
70962: PUSH
70963: LD_INT 1
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 0
70972: PUSH
70973: LD_INT 1
70975: PUSH
70976: EMPTY
70977: LIST
70978: LIST
70979: PUSH
70980: LD_INT 1
70982: NEG
70983: PUSH
70984: LD_INT 0
70986: PUSH
70987: EMPTY
70988: LIST
70989: LIST
70990: PUSH
70991: LD_INT 1
70993: NEG
70994: PUSH
70995: LD_INT 1
70997: NEG
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: PUSH
71003: LD_INT 2
71005: PUSH
71006: LD_INT 1
71008: PUSH
71009: EMPTY
71010: LIST
71011: LIST
71012: PUSH
71013: LD_INT 2
71015: PUSH
71016: LD_INT 2
71018: PUSH
71019: EMPTY
71020: LIST
71021: LIST
71022: PUSH
71023: LD_INT 1
71025: PUSH
71026: LD_INT 2
71028: PUSH
71029: EMPTY
71030: LIST
71031: LIST
71032: PUSH
71033: LD_INT 0
71035: PUSH
71036: LD_INT 2
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: PUSH
71043: LD_INT 1
71045: NEG
71046: PUSH
71047: LD_INT 1
71049: PUSH
71050: EMPTY
71051: LIST
71052: LIST
71053: PUSH
71054: EMPTY
71055: LIST
71056: LIST
71057: LIST
71058: LIST
71059: LIST
71060: LIST
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: LIST
71067: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
71068: LD_ADDR_VAR 0 51
71072: PUSH
71073: LD_INT 0
71075: PUSH
71076: LD_INT 0
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PUSH
71083: LD_INT 0
71085: PUSH
71086: LD_INT 1
71088: NEG
71089: PUSH
71090: EMPTY
71091: LIST
71092: LIST
71093: PUSH
71094: LD_INT 1
71096: PUSH
71097: LD_INT 0
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: PUSH
71104: LD_INT 1
71106: PUSH
71107: LD_INT 1
71109: PUSH
71110: EMPTY
71111: LIST
71112: LIST
71113: PUSH
71114: LD_INT 0
71116: PUSH
71117: LD_INT 1
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: PUSH
71124: LD_INT 1
71126: NEG
71127: PUSH
71128: LD_INT 0
71130: PUSH
71131: EMPTY
71132: LIST
71133: LIST
71134: PUSH
71135: LD_INT 1
71137: NEG
71138: PUSH
71139: LD_INT 1
71141: NEG
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: PUSH
71147: LD_INT 1
71149: PUSH
71150: LD_INT 2
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: PUSH
71157: LD_INT 0
71159: PUSH
71160: LD_INT 2
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: LD_INT 1
71169: NEG
71170: PUSH
71171: LD_INT 1
71173: PUSH
71174: EMPTY
71175: LIST
71176: LIST
71177: PUSH
71178: LD_INT 2
71180: NEG
71181: PUSH
71182: LD_INT 0
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 2
71191: NEG
71192: PUSH
71193: LD_INT 1
71195: NEG
71196: PUSH
71197: EMPTY
71198: LIST
71199: LIST
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: LIST
71205: LIST
71206: LIST
71207: LIST
71208: LIST
71209: LIST
71210: LIST
71211: LIST
71212: LIST
71213: LIST
71214: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71215: LD_ADDR_VAR 0 52
71219: PUSH
71220: LD_INT 0
71222: PUSH
71223: LD_INT 0
71225: PUSH
71226: EMPTY
71227: LIST
71228: LIST
71229: PUSH
71230: LD_INT 0
71232: PUSH
71233: LD_INT 1
71235: NEG
71236: PUSH
71237: EMPTY
71238: LIST
71239: LIST
71240: PUSH
71241: LD_INT 1
71243: PUSH
71244: LD_INT 0
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: LD_INT 1
71253: PUSH
71254: LD_INT 1
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PUSH
71261: LD_INT 0
71263: PUSH
71264: LD_INT 1
71266: PUSH
71267: EMPTY
71268: LIST
71269: LIST
71270: PUSH
71271: LD_INT 1
71273: NEG
71274: PUSH
71275: LD_INT 0
71277: PUSH
71278: EMPTY
71279: LIST
71280: LIST
71281: PUSH
71282: LD_INT 1
71284: NEG
71285: PUSH
71286: LD_INT 1
71288: NEG
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: PUSH
71294: LD_INT 1
71296: NEG
71297: PUSH
71298: LD_INT 2
71300: NEG
71301: PUSH
71302: EMPTY
71303: LIST
71304: LIST
71305: PUSH
71306: LD_INT 1
71308: NEG
71309: PUSH
71310: LD_INT 1
71312: PUSH
71313: EMPTY
71314: LIST
71315: LIST
71316: PUSH
71317: LD_INT 2
71319: NEG
71320: PUSH
71321: LD_INT 0
71323: PUSH
71324: EMPTY
71325: LIST
71326: LIST
71327: PUSH
71328: LD_INT 2
71330: NEG
71331: PUSH
71332: LD_INT 1
71334: NEG
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PUSH
71340: LD_INT 2
71342: NEG
71343: PUSH
71344: LD_INT 2
71346: NEG
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: LIST
71356: LIST
71357: LIST
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: LIST
71364: LIST
71365: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71366: LD_ADDR_VAR 0 53
71370: PUSH
71371: LD_INT 0
71373: PUSH
71374: LD_INT 0
71376: PUSH
71377: EMPTY
71378: LIST
71379: LIST
71380: PUSH
71381: LD_INT 0
71383: PUSH
71384: LD_INT 1
71386: NEG
71387: PUSH
71388: EMPTY
71389: LIST
71390: LIST
71391: PUSH
71392: LD_INT 1
71394: PUSH
71395: LD_INT 0
71397: PUSH
71398: EMPTY
71399: LIST
71400: LIST
71401: PUSH
71402: LD_INT 1
71404: PUSH
71405: LD_INT 1
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: PUSH
71412: LD_INT 0
71414: PUSH
71415: LD_INT 1
71417: PUSH
71418: EMPTY
71419: LIST
71420: LIST
71421: PUSH
71422: LD_INT 1
71424: NEG
71425: PUSH
71426: LD_INT 0
71428: PUSH
71429: EMPTY
71430: LIST
71431: LIST
71432: PUSH
71433: LD_INT 1
71435: NEG
71436: PUSH
71437: LD_INT 1
71439: NEG
71440: PUSH
71441: EMPTY
71442: LIST
71443: LIST
71444: PUSH
71445: LD_INT 1
71447: NEG
71448: PUSH
71449: LD_INT 2
71451: NEG
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PUSH
71457: LD_INT 0
71459: PUSH
71460: LD_INT 2
71462: NEG
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: PUSH
71468: LD_INT 1
71470: PUSH
71471: LD_INT 1
71473: NEG
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: PUSH
71479: LD_INT 2
71481: PUSH
71482: LD_INT 0
71484: PUSH
71485: EMPTY
71486: LIST
71487: LIST
71488: PUSH
71489: LD_INT 2
71491: PUSH
71492: LD_INT 1
71494: PUSH
71495: EMPTY
71496: LIST
71497: LIST
71498: PUSH
71499: LD_INT 2
71501: PUSH
71502: LD_INT 2
71504: PUSH
71505: EMPTY
71506: LIST
71507: LIST
71508: PUSH
71509: LD_INT 1
71511: PUSH
71512: LD_INT 2
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: PUSH
71519: LD_INT 0
71521: PUSH
71522: LD_INT 2
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: LD_INT 1
71531: NEG
71532: PUSH
71533: LD_INT 1
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: PUSH
71540: LD_INT 2
71542: NEG
71543: PUSH
71544: LD_INT 0
71546: PUSH
71547: EMPTY
71548: LIST
71549: LIST
71550: PUSH
71551: LD_INT 2
71553: NEG
71554: PUSH
71555: LD_INT 1
71557: NEG
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: LD_INT 2
71565: NEG
71566: PUSH
71567: LD_INT 2
71569: NEG
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PUSH
71575: EMPTY
71576: LIST
71577: LIST
71578: LIST
71579: LIST
71580: LIST
71581: LIST
71582: LIST
71583: LIST
71584: LIST
71585: LIST
71586: LIST
71587: LIST
71588: LIST
71589: LIST
71590: LIST
71591: LIST
71592: LIST
71593: LIST
71594: LIST
71595: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71596: LD_ADDR_VAR 0 54
71600: PUSH
71601: LD_INT 0
71603: PUSH
71604: LD_INT 0
71606: PUSH
71607: EMPTY
71608: LIST
71609: LIST
71610: PUSH
71611: LD_INT 0
71613: PUSH
71614: LD_INT 1
71616: NEG
71617: PUSH
71618: EMPTY
71619: LIST
71620: LIST
71621: PUSH
71622: LD_INT 1
71624: PUSH
71625: LD_INT 0
71627: PUSH
71628: EMPTY
71629: LIST
71630: LIST
71631: PUSH
71632: LD_INT 1
71634: PUSH
71635: LD_INT 1
71637: PUSH
71638: EMPTY
71639: LIST
71640: LIST
71641: PUSH
71642: LD_INT 0
71644: PUSH
71645: LD_INT 1
71647: PUSH
71648: EMPTY
71649: LIST
71650: LIST
71651: PUSH
71652: LD_INT 1
71654: NEG
71655: PUSH
71656: LD_INT 0
71658: PUSH
71659: EMPTY
71660: LIST
71661: LIST
71662: PUSH
71663: LD_INT 1
71665: NEG
71666: PUSH
71667: LD_INT 1
71669: NEG
71670: PUSH
71671: EMPTY
71672: LIST
71673: LIST
71674: PUSH
71675: LD_INT 1
71677: NEG
71678: PUSH
71679: LD_INT 2
71681: NEG
71682: PUSH
71683: EMPTY
71684: LIST
71685: LIST
71686: PUSH
71687: LD_INT 0
71689: PUSH
71690: LD_INT 2
71692: NEG
71693: PUSH
71694: EMPTY
71695: LIST
71696: LIST
71697: PUSH
71698: LD_INT 1
71700: PUSH
71701: LD_INT 1
71703: NEG
71704: PUSH
71705: EMPTY
71706: LIST
71707: LIST
71708: PUSH
71709: LD_INT 2
71711: PUSH
71712: LD_INT 0
71714: PUSH
71715: EMPTY
71716: LIST
71717: LIST
71718: PUSH
71719: LD_INT 2
71721: PUSH
71722: LD_INT 1
71724: PUSH
71725: EMPTY
71726: LIST
71727: LIST
71728: PUSH
71729: LD_INT 2
71731: PUSH
71732: LD_INT 2
71734: PUSH
71735: EMPTY
71736: LIST
71737: LIST
71738: PUSH
71739: LD_INT 1
71741: PUSH
71742: LD_INT 2
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: LD_INT 0
71751: PUSH
71752: LD_INT 2
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: PUSH
71759: LD_INT 1
71761: NEG
71762: PUSH
71763: LD_INT 1
71765: PUSH
71766: EMPTY
71767: LIST
71768: LIST
71769: PUSH
71770: LD_INT 2
71772: NEG
71773: PUSH
71774: LD_INT 0
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: PUSH
71781: LD_INT 2
71783: NEG
71784: PUSH
71785: LD_INT 1
71787: NEG
71788: PUSH
71789: EMPTY
71790: LIST
71791: LIST
71792: PUSH
71793: LD_INT 2
71795: NEG
71796: PUSH
71797: LD_INT 2
71799: NEG
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: EMPTY
71806: LIST
71807: LIST
71808: LIST
71809: LIST
71810: LIST
71811: LIST
71812: LIST
71813: LIST
71814: LIST
71815: LIST
71816: LIST
71817: LIST
71818: LIST
71819: LIST
71820: LIST
71821: LIST
71822: LIST
71823: LIST
71824: LIST
71825: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71826: LD_ADDR_VAR 0 55
71830: PUSH
71831: LD_INT 0
71833: PUSH
71834: LD_INT 0
71836: PUSH
71837: EMPTY
71838: LIST
71839: LIST
71840: PUSH
71841: LD_INT 0
71843: PUSH
71844: LD_INT 1
71846: NEG
71847: PUSH
71848: EMPTY
71849: LIST
71850: LIST
71851: PUSH
71852: LD_INT 1
71854: PUSH
71855: LD_INT 0
71857: PUSH
71858: EMPTY
71859: LIST
71860: LIST
71861: PUSH
71862: LD_INT 1
71864: PUSH
71865: LD_INT 1
71867: PUSH
71868: EMPTY
71869: LIST
71870: LIST
71871: PUSH
71872: LD_INT 0
71874: PUSH
71875: LD_INT 1
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: LD_INT 1
71884: NEG
71885: PUSH
71886: LD_INT 0
71888: PUSH
71889: EMPTY
71890: LIST
71891: LIST
71892: PUSH
71893: LD_INT 1
71895: NEG
71896: PUSH
71897: LD_INT 1
71899: NEG
71900: PUSH
71901: EMPTY
71902: LIST
71903: LIST
71904: PUSH
71905: LD_INT 1
71907: NEG
71908: PUSH
71909: LD_INT 2
71911: NEG
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: PUSH
71917: LD_INT 0
71919: PUSH
71920: LD_INT 2
71922: NEG
71923: PUSH
71924: EMPTY
71925: LIST
71926: LIST
71927: PUSH
71928: LD_INT 1
71930: PUSH
71931: LD_INT 1
71933: NEG
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: PUSH
71939: LD_INT 2
71941: PUSH
71942: LD_INT 0
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: PUSH
71949: LD_INT 2
71951: PUSH
71952: LD_INT 1
71954: PUSH
71955: EMPTY
71956: LIST
71957: LIST
71958: PUSH
71959: LD_INT 2
71961: PUSH
71962: LD_INT 2
71964: PUSH
71965: EMPTY
71966: LIST
71967: LIST
71968: PUSH
71969: LD_INT 1
71971: PUSH
71972: LD_INT 2
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: PUSH
71979: LD_INT 0
71981: PUSH
71982: LD_INT 2
71984: PUSH
71985: EMPTY
71986: LIST
71987: LIST
71988: PUSH
71989: LD_INT 1
71991: NEG
71992: PUSH
71993: LD_INT 1
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PUSH
72000: LD_INT 2
72002: NEG
72003: PUSH
72004: LD_INT 0
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 2
72013: NEG
72014: PUSH
72015: LD_INT 1
72017: NEG
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 2
72025: NEG
72026: PUSH
72027: LD_INT 2
72029: NEG
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: EMPTY
72036: LIST
72037: LIST
72038: LIST
72039: LIST
72040: LIST
72041: LIST
72042: LIST
72043: LIST
72044: LIST
72045: LIST
72046: LIST
72047: LIST
72048: LIST
72049: LIST
72050: LIST
72051: LIST
72052: LIST
72053: LIST
72054: LIST
72055: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72056: LD_ADDR_VAR 0 56
72060: PUSH
72061: LD_INT 0
72063: PUSH
72064: LD_INT 0
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: LD_INT 0
72073: PUSH
72074: LD_INT 1
72076: NEG
72077: PUSH
72078: EMPTY
72079: LIST
72080: LIST
72081: PUSH
72082: LD_INT 1
72084: PUSH
72085: LD_INT 0
72087: PUSH
72088: EMPTY
72089: LIST
72090: LIST
72091: PUSH
72092: LD_INT 1
72094: PUSH
72095: LD_INT 1
72097: PUSH
72098: EMPTY
72099: LIST
72100: LIST
72101: PUSH
72102: LD_INT 0
72104: PUSH
72105: LD_INT 1
72107: PUSH
72108: EMPTY
72109: LIST
72110: LIST
72111: PUSH
72112: LD_INT 1
72114: NEG
72115: PUSH
72116: LD_INT 0
72118: PUSH
72119: EMPTY
72120: LIST
72121: LIST
72122: PUSH
72123: LD_INT 1
72125: NEG
72126: PUSH
72127: LD_INT 1
72129: NEG
72130: PUSH
72131: EMPTY
72132: LIST
72133: LIST
72134: PUSH
72135: LD_INT 1
72137: NEG
72138: PUSH
72139: LD_INT 2
72141: NEG
72142: PUSH
72143: EMPTY
72144: LIST
72145: LIST
72146: PUSH
72147: LD_INT 0
72149: PUSH
72150: LD_INT 2
72152: NEG
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 1
72160: PUSH
72161: LD_INT 1
72163: NEG
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 2
72171: PUSH
72172: LD_INT 0
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: PUSH
72179: LD_INT 2
72181: PUSH
72182: LD_INT 1
72184: PUSH
72185: EMPTY
72186: LIST
72187: LIST
72188: PUSH
72189: LD_INT 2
72191: PUSH
72192: LD_INT 2
72194: PUSH
72195: EMPTY
72196: LIST
72197: LIST
72198: PUSH
72199: LD_INT 1
72201: PUSH
72202: LD_INT 2
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: PUSH
72209: LD_INT 0
72211: PUSH
72212: LD_INT 2
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: PUSH
72219: LD_INT 1
72221: NEG
72222: PUSH
72223: LD_INT 1
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: PUSH
72230: LD_INT 2
72232: NEG
72233: PUSH
72234: LD_INT 0
72236: PUSH
72237: EMPTY
72238: LIST
72239: LIST
72240: PUSH
72241: LD_INT 2
72243: NEG
72244: PUSH
72245: LD_INT 1
72247: NEG
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PUSH
72253: LD_INT 2
72255: NEG
72256: PUSH
72257: LD_INT 2
72259: NEG
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: EMPTY
72266: LIST
72267: LIST
72268: LIST
72269: LIST
72270: LIST
72271: LIST
72272: LIST
72273: LIST
72274: LIST
72275: LIST
72276: LIST
72277: LIST
72278: LIST
72279: LIST
72280: LIST
72281: LIST
72282: LIST
72283: LIST
72284: LIST
72285: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72286: LD_ADDR_VAR 0 57
72290: PUSH
72291: LD_INT 0
72293: PUSH
72294: LD_INT 0
72296: PUSH
72297: EMPTY
72298: LIST
72299: LIST
72300: PUSH
72301: LD_INT 0
72303: PUSH
72304: LD_INT 1
72306: NEG
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: PUSH
72312: LD_INT 1
72314: PUSH
72315: LD_INT 0
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: LD_INT 1
72324: PUSH
72325: LD_INT 1
72327: PUSH
72328: EMPTY
72329: LIST
72330: LIST
72331: PUSH
72332: LD_INT 0
72334: PUSH
72335: LD_INT 1
72337: PUSH
72338: EMPTY
72339: LIST
72340: LIST
72341: PUSH
72342: LD_INT 1
72344: NEG
72345: PUSH
72346: LD_INT 0
72348: PUSH
72349: EMPTY
72350: LIST
72351: LIST
72352: PUSH
72353: LD_INT 1
72355: NEG
72356: PUSH
72357: LD_INT 1
72359: NEG
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 1
72367: NEG
72368: PUSH
72369: LD_INT 2
72371: NEG
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: PUSH
72377: LD_INT 0
72379: PUSH
72380: LD_INT 2
72382: NEG
72383: PUSH
72384: EMPTY
72385: LIST
72386: LIST
72387: PUSH
72388: LD_INT 1
72390: PUSH
72391: LD_INT 1
72393: NEG
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 2
72401: PUSH
72402: LD_INT 0
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: PUSH
72409: LD_INT 2
72411: PUSH
72412: LD_INT 1
72414: PUSH
72415: EMPTY
72416: LIST
72417: LIST
72418: PUSH
72419: LD_INT 2
72421: PUSH
72422: LD_INT 2
72424: PUSH
72425: EMPTY
72426: LIST
72427: LIST
72428: PUSH
72429: LD_INT 1
72431: PUSH
72432: LD_INT 2
72434: PUSH
72435: EMPTY
72436: LIST
72437: LIST
72438: PUSH
72439: LD_INT 0
72441: PUSH
72442: LD_INT 2
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: LD_INT 1
72451: NEG
72452: PUSH
72453: LD_INT 1
72455: PUSH
72456: EMPTY
72457: LIST
72458: LIST
72459: PUSH
72460: LD_INT 2
72462: NEG
72463: PUSH
72464: LD_INT 0
72466: PUSH
72467: EMPTY
72468: LIST
72469: LIST
72470: PUSH
72471: LD_INT 2
72473: NEG
72474: PUSH
72475: LD_INT 1
72477: NEG
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: PUSH
72483: LD_INT 2
72485: NEG
72486: PUSH
72487: LD_INT 2
72489: NEG
72490: PUSH
72491: EMPTY
72492: LIST
72493: LIST
72494: PUSH
72495: EMPTY
72496: LIST
72497: LIST
72498: LIST
72499: LIST
72500: LIST
72501: LIST
72502: LIST
72503: LIST
72504: LIST
72505: LIST
72506: LIST
72507: LIST
72508: LIST
72509: LIST
72510: LIST
72511: LIST
72512: LIST
72513: LIST
72514: LIST
72515: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72516: LD_ADDR_VAR 0 58
72520: PUSH
72521: LD_INT 0
72523: PUSH
72524: LD_INT 0
72526: PUSH
72527: EMPTY
72528: LIST
72529: LIST
72530: PUSH
72531: LD_INT 0
72533: PUSH
72534: LD_INT 1
72536: NEG
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: PUSH
72542: LD_INT 1
72544: PUSH
72545: LD_INT 0
72547: PUSH
72548: EMPTY
72549: LIST
72550: LIST
72551: PUSH
72552: LD_INT 1
72554: PUSH
72555: LD_INT 1
72557: PUSH
72558: EMPTY
72559: LIST
72560: LIST
72561: PUSH
72562: LD_INT 0
72564: PUSH
72565: LD_INT 1
72567: PUSH
72568: EMPTY
72569: LIST
72570: LIST
72571: PUSH
72572: LD_INT 1
72574: NEG
72575: PUSH
72576: LD_INT 0
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PUSH
72583: LD_INT 1
72585: NEG
72586: PUSH
72587: LD_INT 1
72589: NEG
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 1
72597: NEG
72598: PUSH
72599: LD_INT 2
72601: NEG
72602: PUSH
72603: EMPTY
72604: LIST
72605: LIST
72606: PUSH
72607: LD_INT 0
72609: PUSH
72610: LD_INT 2
72612: NEG
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: PUSH
72618: LD_INT 1
72620: PUSH
72621: LD_INT 1
72623: NEG
72624: PUSH
72625: EMPTY
72626: LIST
72627: LIST
72628: PUSH
72629: LD_INT 2
72631: PUSH
72632: LD_INT 0
72634: PUSH
72635: EMPTY
72636: LIST
72637: LIST
72638: PUSH
72639: LD_INT 2
72641: PUSH
72642: LD_INT 1
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: PUSH
72649: LD_INT 2
72651: PUSH
72652: LD_INT 2
72654: PUSH
72655: EMPTY
72656: LIST
72657: LIST
72658: PUSH
72659: LD_INT 1
72661: PUSH
72662: LD_INT 2
72664: PUSH
72665: EMPTY
72666: LIST
72667: LIST
72668: PUSH
72669: LD_INT 0
72671: PUSH
72672: LD_INT 2
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: PUSH
72679: LD_INT 1
72681: NEG
72682: PUSH
72683: LD_INT 1
72685: PUSH
72686: EMPTY
72687: LIST
72688: LIST
72689: PUSH
72690: LD_INT 2
72692: NEG
72693: PUSH
72694: LD_INT 0
72696: PUSH
72697: EMPTY
72698: LIST
72699: LIST
72700: PUSH
72701: LD_INT 2
72703: NEG
72704: PUSH
72705: LD_INT 1
72707: NEG
72708: PUSH
72709: EMPTY
72710: LIST
72711: LIST
72712: PUSH
72713: LD_INT 2
72715: NEG
72716: PUSH
72717: LD_INT 2
72719: NEG
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: LIST
72729: LIST
72730: LIST
72731: LIST
72732: LIST
72733: LIST
72734: LIST
72735: LIST
72736: LIST
72737: LIST
72738: LIST
72739: LIST
72740: LIST
72741: LIST
72742: LIST
72743: LIST
72744: LIST
72745: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72746: LD_ADDR_VAR 0 59
72750: PUSH
72751: LD_INT 0
72753: PUSH
72754: LD_INT 0
72756: PUSH
72757: EMPTY
72758: LIST
72759: LIST
72760: PUSH
72761: LD_INT 0
72763: PUSH
72764: LD_INT 1
72766: NEG
72767: PUSH
72768: EMPTY
72769: LIST
72770: LIST
72771: PUSH
72772: LD_INT 1
72774: PUSH
72775: LD_INT 0
72777: PUSH
72778: EMPTY
72779: LIST
72780: LIST
72781: PUSH
72782: LD_INT 1
72784: PUSH
72785: LD_INT 1
72787: PUSH
72788: EMPTY
72789: LIST
72790: LIST
72791: PUSH
72792: LD_INT 0
72794: PUSH
72795: LD_INT 1
72797: PUSH
72798: EMPTY
72799: LIST
72800: LIST
72801: PUSH
72802: LD_INT 1
72804: NEG
72805: PUSH
72806: LD_INT 0
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: PUSH
72813: LD_INT 1
72815: NEG
72816: PUSH
72817: LD_INT 1
72819: NEG
72820: PUSH
72821: EMPTY
72822: LIST
72823: LIST
72824: PUSH
72825: EMPTY
72826: LIST
72827: LIST
72828: LIST
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72834: LD_ADDR_VAR 0 60
72838: PUSH
72839: LD_INT 0
72841: PUSH
72842: LD_INT 0
72844: PUSH
72845: EMPTY
72846: LIST
72847: LIST
72848: PUSH
72849: LD_INT 0
72851: PUSH
72852: LD_INT 1
72854: NEG
72855: PUSH
72856: EMPTY
72857: LIST
72858: LIST
72859: PUSH
72860: LD_INT 1
72862: PUSH
72863: LD_INT 0
72865: PUSH
72866: EMPTY
72867: LIST
72868: LIST
72869: PUSH
72870: LD_INT 1
72872: PUSH
72873: LD_INT 1
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: PUSH
72880: LD_INT 0
72882: PUSH
72883: LD_INT 1
72885: PUSH
72886: EMPTY
72887: LIST
72888: LIST
72889: PUSH
72890: LD_INT 1
72892: NEG
72893: PUSH
72894: LD_INT 0
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: PUSH
72901: LD_INT 1
72903: NEG
72904: PUSH
72905: LD_INT 1
72907: NEG
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: PUSH
72913: EMPTY
72914: LIST
72915: LIST
72916: LIST
72917: LIST
72918: LIST
72919: LIST
72920: LIST
72921: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72922: LD_ADDR_VAR 0 61
72926: PUSH
72927: LD_INT 0
72929: PUSH
72930: LD_INT 0
72932: PUSH
72933: EMPTY
72934: LIST
72935: LIST
72936: PUSH
72937: LD_INT 0
72939: PUSH
72940: LD_INT 1
72942: NEG
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: LD_INT 1
72950: PUSH
72951: LD_INT 0
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: PUSH
72958: LD_INT 1
72960: PUSH
72961: LD_INT 1
72963: PUSH
72964: EMPTY
72965: LIST
72966: LIST
72967: PUSH
72968: LD_INT 0
72970: PUSH
72971: LD_INT 1
72973: PUSH
72974: EMPTY
72975: LIST
72976: LIST
72977: PUSH
72978: LD_INT 1
72980: NEG
72981: PUSH
72982: LD_INT 0
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: LD_INT 1
72991: NEG
72992: PUSH
72993: LD_INT 1
72995: NEG
72996: PUSH
72997: EMPTY
72998: LIST
72999: LIST
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73010: LD_ADDR_VAR 0 62
73014: PUSH
73015: LD_INT 0
73017: PUSH
73018: LD_INT 0
73020: PUSH
73021: EMPTY
73022: LIST
73023: LIST
73024: PUSH
73025: LD_INT 0
73027: PUSH
73028: LD_INT 1
73030: NEG
73031: PUSH
73032: EMPTY
73033: LIST
73034: LIST
73035: PUSH
73036: LD_INT 1
73038: PUSH
73039: LD_INT 0
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: PUSH
73046: LD_INT 1
73048: PUSH
73049: LD_INT 1
73051: PUSH
73052: EMPTY
73053: LIST
73054: LIST
73055: PUSH
73056: LD_INT 0
73058: PUSH
73059: LD_INT 1
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: PUSH
73066: LD_INT 1
73068: NEG
73069: PUSH
73070: LD_INT 0
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PUSH
73077: LD_INT 1
73079: NEG
73080: PUSH
73081: LD_INT 1
73083: NEG
73084: PUSH
73085: EMPTY
73086: LIST
73087: LIST
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: LIST
73093: LIST
73094: LIST
73095: LIST
73096: LIST
73097: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73098: LD_ADDR_VAR 0 63
73102: PUSH
73103: LD_INT 0
73105: PUSH
73106: LD_INT 0
73108: PUSH
73109: EMPTY
73110: LIST
73111: LIST
73112: PUSH
73113: LD_INT 0
73115: PUSH
73116: LD_INT 1
73118: NEG
73119: PUSH
73120: EMPTY
73121: LIST
73122: LIST
73123: PUSH
73124: LD_INT 1
73126: PUSH
73127: LD_INT 0
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: LD_INT 1
73136: PUSH
73137: LD_INT 1
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 0
73146: PUSH
73147: LD_INT 1
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: PUSH
73154: LD_INT 1
73156: NEG
73157: PUSH
73158: LD_INT 0
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: LD_INT 1
73167: NEG
73168: PUSH
73169: LD_INT 1
73171: NEG
73172: PUSH
73173: EMPTY
73174: LIST
73175: LIST
73176: PUSH
73177: EMPTY
73178: LIST
73179: LIST
73180: LIST
73181: LIST
73182: LIST
73183: LIST
73184: LIST
73185: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73186: LD_ADDR_VAR 0 64
73190: PUSH
73191: LD_INT 0
73193: PUSH
73194: LD_INT 0
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 0
73203: PUSH
73204: LD_INT 1
73206: NEG
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 1
73214: PUSH
73215: LD_INT 0
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: PUSH
73222: LD_INT 1
73224: PUSH
73225: LD_INT 1
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 0
73234: PUSH
73235: LD_INT 1
73237: PUSH
73238: EMPTY
73239: LIST
73240: LIST
73241: PUSH
73242: LD_INT 1
73244: NEG
73245: PUSH
73246: LD_INT 0
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: PUSH
73253: LD_INT 1
73255: NEG
73256: PUSH
73257: LD_INT 1
73259: NEG
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: PUSH
73265: EMPTY
73266: LIST
73267: LIST
73268: LIST
73269: LIST
73270: LIST
73271: LIST
73272: LIST
73273: ST_TO_ADDR
// end ; 1 :
73274: GO 79171
73276: LD_INT 1
73278: DOUBLE
73279: EQUAL
73280: IFTRUE 73284
73282: GO 75907
73284: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
73285: LD_ADDR_VAR 0 11
73289: PUSH
73290: LD_INT 1
73292: NEG
73293: PUSH
73294: LD_INT 3
73296: NEG
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 0
73304: PUSH
73305: LD_INT 3
73307: NEG
73308: PUSH
73309: EMPTY
73310: LIST
73311: LIST
73312: PUSH
73313: LD_INT 1
73315: PUSH
73316: LD_INT 2
73318: NEG
73319: PUSH
73320: EMPTY
73321: LIST
73322: LIST
73323: PUSH
73324: EMPTY
73325: LIST
73326: LIST
73327: LIST
73328: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
73329: LD_ADDR_VAR 0 12
73333: PUSH
73334: LD_INT 2
73336: PUSH
73337: LD_INT 1
73339: NEG
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: LD_INT 3
73347: PUSH
73348: LD_INT 0
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PUSH
73355: LD_INT 3
73357: PUSH
73358: LD_INT 1
73360: PUSH
73361: EMPTY
73362: LIST
73363: LIST
73364: PUSH
73365: EMPTY
73366: LIST
73367: LIST
73368: LIST
73369: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
73370: LD_ADDR_VAR 0 13
73374: PUSH
73375: LD_INT 3
73377: PUSH
73378: LD_INT 2
73380: PUSH
73381: EMPTY
73382: LIST
73383: LIST
73384: PUSH
73385: LD_INT 3
73387: PUSH
73388: LD_INT 3
73390: PUSH
73391: EMPTY
73392: LIST
73393: LIST
73394: PUSH
73395: LD_INT 2
73397: PUSH
73398: LD_INT 3
73400: PUSH
73401: EMPTY
73402: LIST
73403: LIST
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: LIST
73409: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
73410: LD_ADDR_VAR 0 14
73414: PUSH
73415: LD_INT 1
73417: PUSH
73418: LD_INT 3
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: PUSH
73425: LD_INT 0
73427: PUSH
73428: LD_INT 3
73430: PUSH
73431: EMPTY
73432: LIST
73433: LIST
73434: PUSH
73435: LD_INT 1
73437: NEG
73438: PUSH
73439: LD_INT 2
73441: PUSH
73442: EMPTY
73443: LIST
73444: LIST
73445: PUSH
73446: EMPTY
73447: LIST
73448: LIST
73449: LIST
73450: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73451: LD_ADDR_VAR 0 15
73455: PUSH
73456: LD_INT 2
73458: NEG
73459: PUSH
73460: LD_INT 1
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: PUSH
73467: LD_INT 3
73469: NEG
73470: PUSH
73471: LD_INT 0
73473: PUSH
73474: EMPTY
73475: LIST
73476: LIST
73477: PUSH
73478: LD_INT 3
73480: NEG
73481: PUSH
73482: LD_INT 1
73484: NEG
73485: PUSH
73486: EMPTY
73487: LIST
73488: LIST
73489: PUSH
73490: EMPTY
73491: LIST
73492: LIST
73493: LIST
73494: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73495: LD_ADDR_VAR 0 16
73499: PUSH
73500: LD_INT 2
73502: NEG
73503: PUSH
73504: LD_INT 3
73506: NEG
73507: PUSH
73508: EMPTY
73509: LIST
73510: LIST
73511: PUSH
73512: LD_INT 3
73514: NEG
73515: PUSH
73516: LD_INT 2
73518: NEG
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: PUSH
73524: LD_INT 3
73526: NEG
73527: PUSH
73528: LD_INT 3
73530: NEG
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: LIST
73540: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
73541: LD_ADDR_VAR 0 17
73545: PUSH
73546: LD_INT 1
73548: NEG
73549: PUSH
73550: LD_INT 3
73552: NEG
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: PUSH
73558: LD_INT 0
73560: PUSH
73561: LD_INT 3
73563: NEG
73564: PUSH
73565: EMPTY
73566: LIST
73567: LIST
73568: PUSH
73569: LD_INT 1
73571: PUSH
73572: LD_INT 2
73574: NEG
73575: PUSH
73576: EMPTY
73577: LIST
73578: LIST
73579: PUSH
73580: EMPTY
73581: LIST
73582: LIST
73583: LIST
73584: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
73585: LD_ADDR_VAR 0 18
73589: PUSH
73590: LD_INT 2
73592: PUSH
73593: LD_INT 1
73595: NEG
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: PUSH
73601: LD_INT 3
73603: PUSH
73604: LD_INT 0
73606: PUSH
73607: EMPTY
73608: LIST
73609: LIST
73610: PUSH
73611: LD_INT 3
73613: PUSH
73614: LD_INT 1
73616: PUSH
73617: EMPTY
73618: LIST
73619: LIST
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: LIST
73625: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
73626: LD_ADDR_VAR 0 19
73630: PUSH
73631: LD_INT 3
73633: PUSH
73634: LD_INT 2
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: LD_INT 3
73643: PUSH
73644: LD_INT 3
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: LD_INT 2
73653: PUSH
73654: LD_INT 3
73656: PUSH
73657: EMPTY
73658: LIST
73659: LIST
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: LIST
73665: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
73666: LD_ADDR_VAR 0 20
73670: PUSH
73671: LD_INT 1
73673: PUSH
73674: LD_INT 3
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: PUSH
73681: LD_INT 0
73683: PUSH
73684: LD_INT 3
73686: PUSH
73687: EMPTY
73688: LIST
73689: LIST
73690: PUSH
73691: LD_INT 1
73693: NEG
73694: PUSH
73695: LD_INT 2
73697: PUSH
73698: EMPTY
73699: LIST
73700: LIST
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: LIST
73706: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73707: LD_ADDR_VAR 0 21
73711: PUSH
73712: LD_INT 2
73714: NEG
73715: PUSH
73716: LD_INT 1
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 3
73725: NEG
73726: PUSH
73727: LD_INT 0
73729: PUSH
73730: EMPTY
73731: LIST
73732: LIST
73733: PUSH
73734: LD_INT 3
73736: NEG
73737: PUSH
73738: LD_INT 1
73740: NEG
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: LIST
73750: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73751: LD_ADDR_VAR 0 22
73755: PUSH
73756: LD_INT 2
73758: NEG
73759: PUSH
73760: LD_INT 3
73762: NEG
73763: PUSH
73764: EMPTY
73765: LIST
73766: LIST
73767: PUSH
73768: LD_INT 3
73770: NEG
73771: PUSH
73772: LD_INT 2
73774: NEG
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: PUSH
73780: LD_INT 3
73782: NEG
73783: PUSH
73784: LD_INT 3
73786: NEG
73787: PUSH
73788: EMPTY
73789: LIST
73790: LIST
73791: PUSH
73792: EMPTY
73793: LIST
73794: LIST
73795: LIST
73796: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
73797: LD_ADDR_VAR 0 23
73801: PUSH
73802: LD_INT 0
73804: PUSH
73805: LD_INT 3
73807: NEG
73808: PUSH
73809: EMPTY
73810: LIST
73811: LIST
73812: PUSH
73813: LD_INT 1
73815: NEG
73816: PUSH
73817: LD_INT 4
73819: NEG
73820: PUSH
73821: EMPTY
73822: LIST
73823: LIST
73824: PUSH
73825: LD_INT 1
73827: PUSH
73828: LD_INT 3
73830: NEG
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PUSH
73836: EMPTY
73837: LIST
73838: LIST
73839: LIST
73840: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
73841: LD_ADDR_VAR 0 24
73845: PUSH
73846: LD_INT 3
73848: PUSH
73849: LD_INT 0
73851: PUSH
73852: EMPTY
73853: LIST
73854: LIST
73855: PUSH
73856: LD_INT 3
73858: PUSH
73859: LD_INT 1
73861: NEG
73862: PUSH
73863: EMPTY
73864: LIST
73865: LIST
73866: PUSH
73867: LD_INT 4
73869: PUSH
73870: LD_INT 1
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: LIST
73881: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
73882: LD_ADDR_VAR 0 25
73886: PUSH
73887: LD_INT 3
73889: PUSH
73890: LD_INT 3
73892: PUSH
73893: EMPTY
73894: LIST
73895: LIST
73896: PUSH
73897: LD_INT 4
73899: PUSH
73900: LD_INT 3
73902: PUSH
73903: EMPTY
73904: LIST
73905: LIST
73906: PUSH
73907: LD_INT 3
73909: PUSH
73910: LD_INT 4
73912: PUSH
73913: EMPTY
73914: LIST
73915: LIST
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: LIST
73921: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
73922: LD_ADDR_VAR 0 26
73926: PUSH
73927: LD_INT 0
73929: PUSH
73930: LD_INT 3
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: PUSH
73937: LD_INT 1
73939: PUSH
73940: LD_INT 4
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: LD_INT 1
73949: NEG
73950: PUSH
73951: LD_INT 3
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: PUSH
73958: EMPTY
73959: LIST
73960: LIST
73961: LIST
73962: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
73963: LD_ADDR_VAR 0 27
73967: PUSH
73968: LD_INT 3
73970: NEG
73971: PUSH
73972: LD_INT 0
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: PUSH
73979: LD_INT 3
73981: NEG
73982: PUSH
73983: LD_INT 1
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: PUSH
73990: LD_INT 4
73992: NEG
73993: PUSH
73994: LD_INT 1
73996: NEG
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: LIST
74006: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
74007: LD_ADDR_VAR 0 28
74011: PUSH
74012: LD_INT 3
74014: NEG
74015: PUSH
74016: LD_INT 3
74018: NEG
74019: PUSH
74020: EMPTY
74021: LIST
74022: LIST
74023: PUSH
74024: LD_INT 3
74026: NEG
74027: PUSH
74028: LD_INT 4
74030: NEG
74031: PUSH
74032: EMPTY
74033: LIST
74034: LIST
74035: PUSH
74036: LD_INT 4
74038: NEG
74039: PUSH
74040: LD_INT 3
74042: NEG
74043: PUSH
74044: EMPTY
74045: LIST
74046: LIST
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: LIST
74052: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
74053: LD_ADDR_VAR 0 29
74057: PUSH
74058: LD_INT 1
74060: NEG
74061: PUSH
74062: LD_INT 3
74064: NEG
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: PUSH
74070: LD_INT 0
74072: PUSH
74073: LD_INT 3
74075: NEG
74076: PUSH
74077: EMPTY
74078: LIST
74079: LIST
74080: PUSH
74081: LD_INT 1
74083: PUSH
74084: LD_INT 2
74086: NEG
74087: PUSH
74088: EMPTY
74089: LIST
74090: LIST
74091: PUSH
74092: LD_INT 1
74094: NEG
74095: PUSH
74096: LD_INT 4
74098: NEG
74099: PUSH
74100: EMPTY
74101: LIST
74102: LIST
74103: PUSH
74104: LD_INT 0
74106: PUSH
74107: LD_INT 4
74109: NEG
74110: PUSH
74111: EMPTY
74112: LIST
74113: LIST
74114: PUSH
74115: LD_INT 1
74117: PUSH
74118: LD_INT 3
74120: NEG
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 1
74128: NEG
74129: PUSH
74130: LD_INT 5
74132: NEG
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 0
74140: PUSH
74141: LD_INT 5
74143: NEG
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 1
74151: PUSH
74152: LD_INT 4
74154: NEG
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: LD_INT 1
74162: NEG
74163: PUSH
74164: LD_INT 6
74166: NEG
74167: PUSH
74168: EMPTY
74169: LIST
74170: LIST
74171: PUSH
74172: LD_INT 0
74174: PUSH
74175: LD_INT 6
74177: NEG
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: PUSH
74183: LD_INT 1
74185: PUSH
74186: LD_INT 5
74188: NEG
74189: PUSH
74190: EMPTY
74191: LIST
74192: LIST
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: LIST
74198: LIST
74199: LIST
74200: LIST
74201: LIST
74202: LIST
74203: LIST
74204: LIST
74205: LIST
74206: LIST
74207: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
74208: LD_ADDR_VAR 0 30
74212: PUSH
74213: LD_INT 2
74215: PUSH
74216: LD_INT 1
74218: NEG
74219: PUSH
74220: EMPTY
74221: LIST
74222: LIST
74223: PUSH
74224: LD_INT 3
74226: PUSH
74227: LD_INT 0
74229: PUSH
74230: EMPTY
74231: LIST
74232: LIST
74233: PUSH
74234: LD_INT 3
74236: PUSH
74237: LD_INT 1
74239: PUSH
74240: EMPTY
74241: LIST
74242: LIST
74243: PUSH
74244: LD_INT 3
74246: PUSH
74247: LD_INT 1
74249: NEG
74250: PUSH
74251: EMPTY
74252: LIST
74253: LIST
74254: PUSH
74255: LD_INT 4
74257: PUSH
74258: LD_INT 0
74260: PUSH
74261: EMPTY
74262: LIST
74263: LIST
74264: PUSH
74265: LD_INT 4
74267: PUSH
74268: LD_INT 1
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: LD_INT 4
74277: PUSH
74278: LD_INT 1
74280: NEG
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: PUSH
74286: LD_INT 5
74288: PUSH
74289: LD_INT 0
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: PUSH
74296: LD_INT 5
74298: PUSH
74299: LD_INT 1
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PUSH
74306: LD_INT 5
74308: PUSH
74309: LD_INT 1
74311: NEG
74312: PUSH
74313: EMPTY
74314: LIST
74315: LIST
74316: PUSH
74317: LD_INT 6
74319: PUSH
74320: LD_INT 0
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: PUSH
74327: LD_INT 6
74329: PUSH
74330: LD_INT 1
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: LIST
74341: LIST
74342: LIST
74343: LIST
74344: LIST
74345: LIST
74346: LIST
74347: LIST
74348: LIST
74349: LIST
74350: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
74351: LD_ADDR_VAR 0 31
74355: PUSH
74356: LD_INT 3
74358: PUSH
74359: LD_INT 2
74361: PUSH
74362: EMPTY
74363: LIST
74364: LIST
74365: PUSH
74366: LD_INT 3
74368: PUSH
74369: LD_INT 3
74371: PUSH
74372: EMPTY
74373: LIST
74374: LIST
74375: PUSH
74376: LD_INT 2
74378: PUSH
74379: LD_INT 3
74381: PUSH
74382: EMPTY
74383: LIST
74384: LIST
74385: PUSH
74386: LD_INT 4
74388: PUSH
74389: LD_INT 3
74391: PUSH
74392: EMPTY
74393: LIST
74394: LIST
74395: PUSH
74396: LD_INT 4
74398: PUSH
74399: LD_INT 4
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: PUSH
74406: LD_INT 3
74408: PUSH
74409: LD_INT 4
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: PUSH
74416: LD_INT 5
74418: PUSH
74419: LD_INT 4
74421: PUSH
74422: EMPTY
74423: LIST
74424: LIST
74425: PUSH
74426: LD_INT 5
74428: PUSH
74429: LD_INT 5
74431: PUSH
74432: EMPTY
74433: LIST
74434: LIST
74435: PUSH
74436: LD_INT 4
74438: PUSH
74439: LD_INT 5
74441: PUSH
74442: EMPTY
74443: LIST
74444: LIST
74445: PUSH
74446: LD_INT 6
74448: PUSH
74449: LD_INT 5
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: PUSH
74456: LD_INT 6
74458: PUSH
74459: LD_INT 6
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: PUSH
74466: LD_INT 5
74468: PUSH
74469: LD_INT 6
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: LIST
74480: LIST
74481: LIST
74482: LIST
74483: LIST
74484: LIST
74485: LIST
74486: LIST
74487: LIST
74488: LIST
74489: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
74490: LD_ADDR_VAR 0 32
74494: PUSH
74495: LD_INT 1
74497: PUSH
74498: LD_INT 3
74500: PUSH
74501: EMPTY
74502: LIST
74503: LIST
74504: PUSH
74505: LD_INT 0
74507: PUSH
74508: LD_INT 3
74510: PUSH
74511: EMPTY
74512: LIST
74513: LIST
74514: PUSH
74515: LD_INT 1
74517: NEG
74518: PUSH
74519: LD_INT 2
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: PUSH
74526: LD_INT 1
74528: PUSH
74529: LD_INT 4
74531: PUSH
74532: EMPTY
74533: LIST
74534: LIST
74535: PUSH
74536: LD_INT 0
74538: PUSH
74539: LD_INT 4
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PUSH
74546: LD_INT 1
74548: NEG
74549: PUSH
74550: LD_INT 3
74552: PUSH
74553: EMPTY
74554: LIST
74555: LIST
74556: PUSH
74557: LD_INT 1
74559: PUSH
74560: LD_INT 5
74562: PUSH
74563: EMPTY
74564: LIST
74565: LIST
74566: PUSH
74567: LD_INT 0
74569: PUSH
74570: LD_INT 5
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PUSH
74577: LD_INT 1
74579: NEG
74580: PUSH
74581: LD_INT 4
74583: PUSH
74584: EMPTY
74585: LIST
74586: LIST
74587: PUSH
74588: LD_INT 1
74590: PUSH
74591: LD_INT 6
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: PUSH
74598: LD_INT 0
74600: PUSH
74601: LD_INT 6
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: LD_INT 1
74610: NEG
74611: PUSH
74612: LD_INT 5
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: LIST
74623: LIST
74624: LIST
74625: LIST
74626: LIST
74627: LIST
74628: LIST
74629: LIST
74630: LIST
74631: LIST
74632: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
74633: LD_ADDR_VAR 0 33
74637: PUSH
74638: LD_INT 2
74640: NEG
74641: PUSH
74642: LD_INT 1
74644: PUSH
74645: EMPTY
74646: LIST
74647: LIST
74648: PUSH
74649: LD_INT 3
74651: NEG
74652: PUSH
74653: LD_INT 0
74655: PUSH
74656: EMPTY
74657: LIST
74658: LIST
74659: PUSH
74660: LD_INT 3
74662: NEG
74663: PUSH
74664: LD_INT 1
74666: NEG
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PUSH
74672: LD_INT 3
74674: NEG
74675: PUSH
74676: LD_INT 1
74678: PUSH
74679: EMPTY
74680: LIST
74681: LIST
74682: PUSH
74683: LD_INT 4
74685: NEG
74686: PUSH
74687: LD_INT 0
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: LD_INT 4
74696: NEG
74697: PUSH
74698: LD_INT 1
74700: NEG
74701: PUSH
74702: EMPTY
74703: LIST
74704: LIST
74705: PUSH
74706: LD_INT 4
74708: NEG
74709: PUSH
74710: LD_INT 1
74712: PUSH
74713: EMPTY
74714: LIST
74715: LIST
74716: PUSH
74717: LD_INT 5
74719: NEG
74720: PUSH
74721: LD_INT 0
74723: PUSH
74724: EMPTY
74725: LIST
74726: LIST
74727: PUSH
74728: LD_INT 5
74730: NEG
74731: PUSH
74732: LD_INT 1
74734: NEG
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: PUSH
74740: LD_INT 5
74742: NEG
74743: PUSH
74744: LD_INT 1
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: PUSH
74751: LD_INT 6
74753: NEG
74754: PUSH
74755: LD_INT 0
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: PUSH
74762: LD_INT 6
74764: NEG
74765: PUSH
74766: LD_INT 1
74768: NEG
74769: PUSH
74770: EMPTY
74771: LIST
74772: LIST
74773: PUSH
74774: EMPTY
74775: LIST
74776: LIST
74777: LIST
74778: LIST
74779: LIST
74780: LIST
74781: LIST
74782: LIST
74783: LIST
74784: LIST
74785: LIST
74786: LIST
74787: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
74788: LD_ADDR_VAR 0 34
74792: PUSH
74793: LD_INT 2
74795: NEG
74796: PUSH
74797: LD_INT 3
74799: NEG
74800: PUSH
74801: EMPTY
74802: LIST
74803: LIST
74804: PUSH
74805: LD_INT 3
74807: NEG
74808: PUSH
74809: LD_INT 2
74811: NEG
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: PUSH
74817: LD_INT 3
74819: NEG
74820: PUSH
74821: LD_INT 3
74823: NEG
74824: PUSH
74825: EMPTY
74826: LIST
74827: LIST
74828: PUSH
74829: LD_INT 3
74831: NEG
74832: PUSH
74833: LD_INT 4
74835: NEG
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PUSH
74841: LD_INT 4
74843: NEG
74844: PUSH
74845: LD_INT 3
74847: NEG
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: LD_INT 4
74855: NEG
74856: PUSH
74857: LD_INT 4
74859: NEG
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PUSH
74865: LD_INT 4
74867: NEG
74868: PUSH
74869: LD_INT 5
74871: NEG
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 5
74879: NEG
74880: PUSH
74881: LD_INT 4
74883: NEG
74884: PUSH
74885: EMPTY
74886: LIST
74887: LIST
74888: PUSH
74889: LD_INT 5
74891: NEG
74892: PUSH
74893: LD_INT 5
74895: NEG
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: PUSH
74901: LD_INT 5
74903: NEG
74904: PUSH
74905: LD_INT 6
74907: NEG
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: LD_INT 6
74915: NEG
74916: PUSH
74917: LD_INT 5
74919: NEG
74920: PUSH
74921: EMPTY
74922: LIST
74923: LIST
74924: PUSH
74925: LD_INT 6
74927: NEG
74928: PUSH
74929: LD_INT 6
74931: NEG
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: LIST
74941: LIST
74942: LIST
74943: LIST
74944: LIST
74945: LIST
74946: LIST
74947: LIST
74948: LIST
74949: LIST
74950: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
74951: LD_ADDR_VAR 0 41
74955: PUSH
74956: LD_INT 0
74958: PUSH
74959: LD_INT 2
74961: NEG
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PUSH
74967: LD_INT 1
74969: NEG
74970: PUSH
74971: LD_INT 3
74973: NEG
74974: PUSH
74975: EMPTY
74976: LIST
74977: LIST
74978: PUSH
74979: LD_INT 1
74981: PUSH
74982: LD_INT 2
74984: NEG
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: LIST
74994: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
74995: LD_ADDR_VAR 0 42
74999: PUSH
75000: LD_INT 2
75002: PUSH
75003: LD_INT 0
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: PUSH
75010: LD_INT 2
75012: PUSH
75013: LD_INT 1
75015: NEG
75016: PUSH
75017: EMPTY
75018: LIST
75019: LIST
75020: PUSH
75021: LD_INT 3
75023: PUSH
75024: LD_INT 1
75026: PUSH
75027: EMPTY
75028: LIST
75029: LIST
75030: PUSH
75031: EMPTY
75032: LIST
75033: LIST
75034: LIST
75035: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
75036: LD_ADDR_VAR 0 43
75040: PUSH
75041: LD_INT 2
75043: PUSH
75044: LD_INT 2
75046: PUSH
75047: EMPTY
75048: LIST
75049: LIST
75050: PUSH
75051: LD_INT 3
75053: PUSH
75054: LD_INT 2
75056: PUSH
75057: EMPTY
75058: LIST
75059: LIST
75060: PUSH
75061: LD_INT 2
75063: PUSH
75064: LD_INT 3
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: PUSH
75071: EMPTY
75072: LIST
75073: LIST
75074: LIST
75075: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
75076: LD_ADDR_VAR 0 44
75080: PUSH
75081: LD_INT 0
75083: PUSH
75084: LD_INT 2
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PUSH
75091: LD_INT 1
75093: PUSH
75094: LD_INT 3
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: PUSH
75101: LD_INT 1
75103: NEG
75104: PUSH
75105: LD_INT 2
75107: PUSH
75108: EMPTY
75109: LIST
75110: LIST
75111: PUSH
75112: EMPTY
75113: LIST
75114: LIST
75115: LIST
75116: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
75117: LD_ADDR_VAR 0 45
75121: PUSH
75122: LD_INT 2
75124: NEG
75125: PUSH
75126: LD_INT 0
75128: PUSH
75129: EMPTY
75130: LIST
75131: LIST
75132: PUSH
75133: LD_INT 2
75135: NEG
75136: PUSH
75137: LD_INT 1
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: LD_INT 3
75146: NEG
75147: PUSH
75148: LD_INT 1
75150: NEG
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: LIST
75160: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
75161: LD_ADDR_VAR 0 46
75165: PUSH
75166: LD_INT 2
75168: NEG
75169: PUSH
75170: LD_INT 2
75172: NEG
75173: PUSH
75174: EMPTY
75175: LIST
75176: LIST
75177: PUSH
75178: LD_INT 2
75180: NEG
75181: PUSH
75182: LD_INT 3
75184: NEG
75185: PUSH
75186: EMPTY
75187: LIST
75188: LIST
75189: PUSH
75190: LD_INT 3
75192: NEG
75193: PUSH
75194: LD_INT 2
75196: NEG
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: LIST
75206: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
75207: LD_ADDR_VAR 0 47
75211: PUSH
75212: LD_INT 2
75214: NEG
75215: PUSH
75216: LD_INT 3
75218: NEG
75219: PUSH
75220: EMPTY
75221: LIST
75222: LIST
75223: PUSH
75224: LD_INT 1
75226: NEG
75227: PUSH
75228: LD_INT 3
75230: NEG
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
75240: LD_ADDR_VAR 0 48
75244: PUSH
75245: LD_INT 1
75247: PUSH
75248: LD_INT 2
75250: NEG
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: LD_INT 2
75258: PUSH
75259: LD_INT 1
75261: NEG
75262: PUSH
75263: EMPTY
75264: LIST
75265: LIST
75266: PUSH
75267: EMPTY
75268: LIST
75269: LIST
75270: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
75271: LD_ADDR_VAR 0 49
75275: PUSH
75276: LD_INT 3
75278: PUSH
75279: LD_INT 1
75281: PUSH
75282: EMPTY
75283: LIST
75284: LIST
75285: PUSH
75286: LD_INT 3
75288: PUSH
75289: LD_INT 2
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
75300: LD_ADDR_VAR 0 50
75304: PUSH
75305: LD_INT 2
75307: PUSH
75308: LD_INT 3
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PUSH
75315: LD_INT 1
75317: PUSH
75318: LD_INT 3
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: EMPTY
75326: LIST
75327: LIST
75328: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
75329: LD_ADDR_VAR 0 51
75333: PUSH
75334: LD_INT 1
75336: NEG
75337: PUSH
75338: LD_INT 2
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: LD_INT 2
75347: NEG
75348: PUSH
75349: LD_INT 1
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: PUSH
75356: EMPTY
75357: LIST
75358: LIST
75359: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
75360: LD_ADDR_VAR 0 52
75364: PUSH
75365: LD_INT 3
75367: NEG
75368: PUSH
75369: LD_INT 1
75371: NEG
75372: PUSH
75373: EMPTY
75374: LIST
75375: LIST
75376: PUSH
75377: LD_INT 3
75379: NEG
75380: PUSH
75381: LD_INT 2
75383: NEG
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: PUSH
75389: EMPTY
75390: LIST
75391: LIST
75392: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75393: LD_ADDR_VAR 0 53
75397: PUSH
75398: LD_INT 1
75400: NEG
75401: PUSH
75402: LD_INT 3
75404: NEG
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PUSH
75410: LD_INT 0
75412: PUSH
75413: LD_INT 3
75415: NEG
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: PUSH
75421: LD_INT 1
75423: PUSH
75424: LD_INT 2
75426: NEG
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: EMPTY
75433: LIST
75434: LIST
75435: LIST
75436: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75437: LD_ADDR_VAR 0 54
75441: PUSH
75442: LD_INT 2
75444: PUSH
75445: LD_INT 1
75447: NEG
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 3
75455: PUSH
75456: LD_INT 0
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 3
75465: PUSH
75466: LD_INT 1
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: PUSH
75473: EMPTY
75474: LIST
75475: LIST
75476: LIST
75477: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75478: LD_ADDR_VAR 0 55
75482: PUSH
75483: LD_INT 3
75485: PUSH
75486: LD_INT 2
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: PUSH
75493: LD_INT 3
75495: PUSH
75496: LD_INT 3
75498: PUSH
75499: EMPTY
75500: LIST
75501: LIST
75502: PUSH
75503: LD_INT 2
75505: PUSH
75506: LD_INT 3
75508: PUSH
75509: EMPTY
75510: LIST
75511: LIST
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: LIST
75517: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75518: LD_ADDR_VAR 0 56
75522: PUSH
75523: LD_INT 1
75525: PUSH
75526: LD_INT 3
75528: PUSH
75529: EMPTY
75530: LIST
75531: LIST
75532: PUSH
75533: LD_INT 0
75535: PUSH
75536: LD_INT 3
75538: PUSH
75539: EMPTY
75540: LIST
75541: LIST
75542: PUSH
75543: LD_INT 1
75545: NEG
75546: PUSH
75547: LD_INT 2
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: LIST
75558: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75559: LD_ADDR_VAR 0 57
75563: PUSH
75564: LD_INT 2
75566: NEG
75567: PUSH
75568: LD_INT 1
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: PUSH
75575: LD_INT 3
75577: NEG
75578: PUSH
75579: LD_INT 0
75581: PUSH
75582: EMPTY
75583: LIST
75584: LIST
75585: PUSH
75586: LD_INT 3
75588: NEG
75589: PUSH
75590: LD_INT 1
75592: NEG
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: LIST
75602: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75603: LD_ADDR_VAR 0 58
75607: PUSH
75608: LD_INT 2
75610: NEG
75611: PUSH
75612: LD_INT 3
75614: NEG
75615: PUSH
75616: EMPTY
75617: LIST
75618: LIST
75619: PUSH
75620: LD_INT 3
75622: NEG
75623: PUSH
75624: LD_INT 2
75626: NEG
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: PUSH
75632: LD_INT 3
75634: NEG
75635: PUSH
75636: LD_INT 3
75638: NEG
75639: PUSH
75640: EMPTY
75641: LIST
75642: LIST
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: LIST
75648: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
75649: LD_ADDR_VAR 0 59
75653: PUSH
75654: LD_INT 1
75656: NEG
75657: PUSH
75658: LD_INT 2
75660: NEG
75661: PUSH
75662: EMPTY
75663: LIST
75664: LIST
75665: PUSH
75666: LD_INT 0
75668: PUSH
75669: LD_INT 2
75671: NEG
75672: PUSH
75673: EMPTY
75674: LIST
75675: LIST
75676: PUSH
75677: LD_INT 1
75679: PUSH
75680: LD_INT 1
75682: NEG
75683: PUSH
75684: EMPTY
75685: LIST
75686: LIST
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: LIST
75692: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75693: LD_ADDR_VAR 0 60
75697: PUSH
75698: LD_INT 1
75700: PUSH
75701: LD_INT 1
75703: NEG
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: PUSH
75709: LD_INT 2
75711: PUSH
75712: LD_INT 0
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: LD_INT 2
75721: PUSH
75722: LD_INT 1
75724: PUSH
75725: EMPTY
75726: LIST
75727: LIST
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: LIST
75733: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75734: LD_ADDR_VAR 0 61
75738: PUSH
75739: LD_INT 2
75741: PUSH
75742: LD_INT 1
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: PUSH
75749: LD_INT 2
75751: PUSH
75752: LD_INT 2
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: PUSH
75759: LD_INT 1
75761: PUSH
75762: LD_INT 2
75764: PUSH
75765: EMPTY
75766: LIST
75767: LIST
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: LIST
75773: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75774: LD_ADDR_VAR 0 62
75778: PUSH
75779: LD_INT 1
75781: PUSH
75782: LD_INT 2
75784: PUSH
75785: EMPTY
75786: LIST
75787: LIST
75788: PUSH
75789: LD_INT 0
75791: PUSH
75792: LD_INT 2
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: LD_INT 1
75801: NEG
75802: PUSH
75803: LD_INT 1
75805: PUSH
75806: EMPTY
75807: LIST
75808: LIST
75809: PUSH
75810: EMPTY
75811: LIST
75812: LIST
75813: LIST
75814: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75815: LD_ADDR_VAR 0 63
75819: PUSH
75820: LD_INT 1
75822: NEG
75823: PUSH
75824: LD_INT 1
75826: PUSH
75827: EMPTY
75828: LIST
75829: LIST
75830: PUSH
75831: LD_INT 2
75833: NEG
75834: PUSH
75835: LD_INT 0
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: PUSH
75842: LD_INT 2
75844: NEG
75845: PUSH
75846: LD_INT 1
75848: NEG
75849: PUSH
75850: EMPTY
75851: LIST
75852: LIST
75853: PUSH
75854: EMPTY
75855: LIST
75856: LIST
75857: LIST
75858: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75859: LD_ADDR_VAR 0 64
75863: PUSH
75864: LD_INT 1
75866: NEG
75867: PUSH
75868: LD_INT 2
75870: NEG
75871: PUSH
75872: EMPTY
75873: LIST
75874: LIST
75875: PUSH
75876: LD_INT 2
75878: NEG
75879: PUSH
75880: LD_INT 1
75882: NEG
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: LD_INT 2
75890: NEG
75891: PUSH
75892: LD_INT 2
75894: NEG
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: EMPTY
75901: LIST
75902: LIST
75903: LIST
75904: ST_TO_ADDR
// end ; 2 :
75905: GO 79171
75907: LD_INT 2
75909: DOUBLE
75910: EQUAL
75911: IFTRUE 75915
75913: GO 79170
75915: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
75916: LD_ADDR_VAR 0 29
75920: PUSH
75921: LD_INT 4
75923: PUSH
75924: LD_INT 0
75926: PUSH
75927: EMPTY
75928: LIST
75929: LIST
75930: PUSH
75931: LD_INT 4
75933: PUSH
75934: LD_INT 1
75936: NEG
75937: PUSH
75938: EMPTY
75939: LIST
75940: LIST
75941: PUSH
75942: LD_INT 5
75944: PUSH
75945: LD_INT 0
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 5
75954: PUSH
75955: LD_INT 1
75957: PUSH
75958: EMPTY
75959: LIST
75960: LIST
75961: PUSH
75962: LD_INT 4
75964: PUSH
75965: LD_INT 1
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PUSH
75972: LD_INT 3
75974: PUSH
75975: LD_INT 0
75977: PUSH
75978: EMPTY
75979: LIST
75980: LIST
75981: PUSH
75982: LD_INT 3
75984: PUSH
75985: LD_INT 1
75987: NEG
75988: PUSH
75989: EMPTY
75990: LIST
75991: LIST
75992: PUSH
75993: LD_INT 3
75995: PUSH
75996: LD_INT 2
75998: NEG
75999: PUSH
76000: EMPTY
76001: LIST
76002: LIST
76003: PUSH
76004: LD_INT 5
76006: PUSH
76007: LD_INT 2
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: PUSH
76014: LD_INT 3
76016: PUSH
76017: LD_INT 3
76019: PUSH
76020: EMPTY
76021: LIST
76022: LIST
76023: PUSH
76024: LD_INT 3
76026: PUSH
76027: LD_INT 2
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PUSH
76034: LD_INT 4
76036: PUSH
76037: LD_INT 3
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: PUSH
76044: LD_INT 4
76046: PUSH
76047: LD_INT 4
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: PUSH
76054: LD_INT 3
76056: PUSH
76057: LD_INT 4
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PUSH
76064: LD_INT 2
76066: PUSH
76067: LD_INT 3
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 2
76076: PUSH
76077: LD_INT 2
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: PUSH
76084: LD_INT 4
76086: PUSH
76087: LD_INT 2
76089: PUSH
76090: EMPTY
76091: LIST
76092: LIST
76093: PUSH
76094: LD_INT 2
76096: PUSH
76097: LD_INT 4
76099: PUSH
76100: EMPTY
76101: LIST
76102: LIST
76103: PUSH
76104: LD_INT 0
76106: PUSH
76107: LD_INT 4
76109: PUSH
76110: EMPTY
76111: LIST
76112: LIST
76113: PUSH
76114: LD_INT 0
76116: PUSH
76117: LD_INT 3
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: LD_INT 1
76126: PUSH
76127: LD_INT 4
76129: PUSH
76130: EMPTY
76131: LIST
76132: LIST
76133: PUSH
76134: LD_INT 1
76136: PUSH
76137: LD_INT 5
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: PUSH
76144: LD_INT 0
76146: PUSH
76147: LD_INT 5
76149: PUSH
76150: EMPTY
76151: LIST
76152: LIST
76153: PUSH
76154: LD_INT 1
76156: NEG
76157: PUSH
76158: LD_INT 4
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: LD_INT 1
76167: NEG
76168: PUSH
76169: LD_INT 3
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PUSH
76176: LD_INT 2
76178: PUSH
76179: LD_INT 5
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: PUSH
76186: LD_INT 2
76188: NEG
76189: PUSH
76190: LD_INT 3
76192: PUSH
76193: EMPTY
76194: LIST
76195: LIST
76196: PUSH
76197: LD_INT 3
76199: NEG
76200: PUSH
76201: LD_INT 0
76203: PUSH
76204: EMPTY
76205: LIST
76206: LIST
76207: PUSH
76208: LD_INT 3
76210: NEG
76211: PUSH
76212: LD_INT 1
76214: NEG
76215: PUSH
76216: EMPTY
76217: LIST
76218: LIST
76219: PUSH
76220: LD_INT 2
76222: NEG
76223: PUSH
76224: LD_INT 0
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: LD_INT 2
76233: NEG
76234: PUSH
76235: LD_INT 1
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: LD_INT 3
76244: NEG
76245: PUSH
76246: LD_INT 1
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: LD_INT 4
76255: NEG
76256: PUSH
76257: LD_INT 0
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: PUSH
76264: LD_INT 4
76266: NEG
76267: PUSH
76268: LD_INT 1
76270: NEG
76271: PUSH
76272: EMPTY
76273: LIST
76274: LIST
76275: PUSH
76276: LD_INT 4
76278: NEG
76279: PUSH
76280: LD_INT 2
76282: NEG
76283: PUSH
76284: EMPTY
76285: LIST
76286: LIST
76287: PUSH
76288: LD_INT 2
76290: NEG
76291: PUSH
76292: LD_INT 2
76294: PUSH
76295: EMPTY
76296: LIST
76297: LIST
76298: PUSH
76299: LD_INT 4
76301: NEG
76302: PUSH
76303: LD_INT 4
76305: NEG
76306: PUSH
76307: EMPTY
76308: LIST
76309: LIST
76310: PUSH
76311: LD_INT 4
76313: NEG
76314: PUSH
76315: LD_INT 5
76317: NEG
76318: PUSH
76319: EMPTY
76320: LIST
76321: LIST
76322: PUSH
76323: LD_INT 3
76325: NEG
76326: PUSH
76327: LD_INT 4
76329: NEG
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PUSH
76335: LD_INT 3
76337: NEG
76338: PUSH
76339: LD_INT 3
76341: NEG
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: LD_INT 4
76349: NEG
76350: PUSH
76351: LD_INT 3
76353: NEG
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: PUSH
76359: LD_INT 5
76361: NEG
76362: PUSH
76363: LD_INT 4
76365: NEG
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: PUSH
76371: LD_INT 5
76373: NEG
76374: PUSH
76375: LD_INT 5
76377: NEG
76378: PUSH
76379: EMPTY
76380: LIST
76381: LIST
76382: PUSH
76383: LD_INT 3
76385: NEG
76386: PUSH
76387: LD_INT 5
76389: NEG
76390: PUSH
76391: EMPTY
76392: LIST
76393: LIST
76394: PUSH
76395: LD_INT 5
76397: NEG
76398: PUSH
76399: LD_INT 3
76401: NEG
76402: PUSH
76403: EMPTY
76404: LIST
76405: LIST
76406: PUSH
76407: EMPTY
76408: LIST
76409: LIST
76410: LIST
76411: LIST
76412: LIST
76413: LIST
76414: LIST
76415: LIST
76416: LIST
76417: LIST
76418: LIST
76419: LIST
76420: LIST
76421: LIST
76422: LIST
76423: LIST
76424: LIST
76425: LIST
76426: LIST
76427: LIST
76428: LIST
76429: LIST
76430: LIST
76431: LIST
76432: LIST
76433: LIST
76434: LIST
76435: LIST
76436: LIST
76437: LIST
76438: LIST
76439: LIST
76440: LIST
76441: LIST
76442: LIST
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: LIST
76448: LIST
76449: LIST
76450: LIST
76451: LIST
76452: LIST
76453: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
76454: LD_ADDR_VAR 0 30
76458: PUSH
76459: LD_INT 4
76461: PUSH
76462: LD_INT 4
76464: PUSH
76465: EMPTY
76466: LIST
76467: LIST
76468: PUSH
76469: LD_INT 4
76471: PUSH
76472: LD_INT 3
76474: PUSH
76475: EMPTY
76476: LIST
76477: LIST
76478: PUSH
76479: LD_INT 5
76481: PUSH
76482: LD_INT 4
76484: PUSH
76485: EMPTY
76486: LIST
76487: LIST
76488: PUSH
76489: LD_INT 5
76491: PUSH
76492: LD_INT 5
76494: PUSH
76495: EMPTY
76496: LIST
76497: LIST
76498: PUSH
76499: LD_INT 4
76501: PUSH
76502: LD_INT 5
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: PUSH
76509: LD_INT 3
76511: PUSH
76512: LD_INT 4
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: PUSH
76519: LD_INT 3
76521: PUSH
76522: LD_INT 3
76524: PUSH
76525: EMPTY
76526: LIST
76527: LIST
76528: PUSH
76529: LD_INT 5
76531: PUSH
76532: LD_INT 3
76534: PUSH
76535: EMPTY
76536: LIST
76537: LIST
76538: PUSH
76539: LD_INT 3
76541: PUSH
76542: LD_INT 5
76544: PUSH
76545: EMPTY
76546: LIST
76547: LIST
76548: PUSH
76549: LD_INT 0
76551: PUSH
76552: LD_INT 3
76554: PUSH
76555: EMPTY
76556: LIST
76557: LIST
76558: PUSH
76559: LD_INT 0
76561: PUSH
76562: LD_INT 2
76564: PUSH
76565: EMPTY
76566: LIST
76567: LIST
76568: PUSH
76569: LD_INT 1
76571: PUSH
76572: LD_INT 3
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PUSH
76579: LD_INT 1
76581: PUSH
76582: LD_INT 4
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: PUSH
76589: LD_INT 0
76591: PUSH
76592: LD_INT 4
76594: PUSH
76595: EMPTY
76596: LIST
76597: LIST
76598: PUSH
76599: LD_INT 1
76601: NEG
76602: PUSH
76603: LD_INT 3
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 1
76612: NEG
76613: PUSH
76614: LD_INT 2
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PUSH
76621: LD_INT 2
76623: PUSH
76624: LD_INT 4
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: PUSH
76631: LD_INT 2
76633: NEG
76634: PUSH
76635: LD_INT 2
76637: PUSH
76638: EMPTY
76639: LIST
76640: LIST
76641: PUSH
76642: LD_INT 4
76644: NEG
76645: PUSH
76646: LD_INT 0
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: PUSH
76653: LD_INT 4
76655: NEG
76656: PUSH
76657: LD_INT 1
76659: NEG
76660: PUSH
76661: EMPTY
76662: LIST
76663: LIST
76664: PUSH
76665: LD_INT 3
76667: NEG
76668: PUSH
76669: LD_INT 0
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: PUSH
76676: LD_INT 3
76678: NEG
76679: PUSH
76680: LD_INT 1
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 4
76689: NEG
76690: PUSH
76691: LD_INT 1
76693: PUSH
76694: EMPTY
76695: LIST
76696: LIST
76697: PUSH
76698: LD_INT 5
76700: NEG
76701: PUSH
76702: LD_INT 0
76704: PUSH
76705: EMPTY
76706: LIST
76707: LIST
76708: PUSH
76709: LD_INT 5
76711: NEG
76712: PUSH
76713: LD_INT 1
76715: NEG
76716: PUSH
76717: EMPTY
76718: LIST
76719: LIST
76720: PUSH
76721: LD_INT 5
76723: NEG
76724: PUSH
76725: LD_INT 2
76727: NEG
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: PUSH
76733: LD_INT 3
76735: NEG
76736: PUSH
76737: LD_INT 2
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 3
76746: NEG
76747: PUSH
76748: LD_INT 3
76750: NEG
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: PUSH
76756: LD_INT 3
76758: NEG
76759: PUSH
76760: LD_INT 4
76762: NEG
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: PUSH
76768: LD_INT 2
76770: NEG
76771: PUSH
76772: LD_INT 3
76774: NEG
76775: PUSH
76776: EMPTY
76777: LIST
76778: LIST
76779: PUSH
76780: LD_INT 2
76782: NEG
76783: PUSH
76784: LD_INT 2
76786: NEG
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: LD_INT 3
76794: NEG
76795: PUSH
76796: LD_INT 2
76798: NEG
76799: PUSH
76800: EMPTY
76801: LIST
76802: LIST
76803: PUSH
76804: LD_INT 4
76806: NEG
76807: PUSH
76808: LD_INT 3
76810: NEG
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 4
76818: NEG
76819: PUSH
76820: LD_INT 4
76822: NEG
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: PUSH
76828: LD_INT 2
76830: NEG
76831: PUSH
76832: LD_INT 4
76834: NEG
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PUSH
76840: LD_INT 4
76842: NEG
76843: PUSH
76844: LD_INT 2
76846: NEG
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: PUSH
76852: LD_INT 0
76854: PUSH
76855: LD_INT 4
76857: NEG
76858: PUSH
76859: EMPTY
76860: LIST
76861: LIST
76862: PUSH
76863: LD_INT 0
76865: PUSH
76866: LD_INT 5
76868: NEG
76869: PUSH
76870: EMPTY
76871: LIST
76872: LIST
76873: PUSH
76874: LD_INT 1
76876: PUSH
76877: LD_INT 4
76879: NEG
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PUSH
76885: LD_INT 1
76887: PUSH
76888: LD_INT 3
76890: NEG
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 0
76898: PUSH
76899: LD_INT 3
76901: NEG
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 1
76909: NEG
76910: PUSH
76911: LD_INT 4
76913: NEG
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: PUSH
76919: LD_INT 1
76921: NEG
76922: PUSH
76923: LD_INT 5
76925: NEG
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: PUSH
76931: LD_INT 2
76933: PUSH
76934: LD_INT 3
76936: NEG
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: PUSH
76942: LD_INT 2
76944: NEG
76945: PUSH
76946: LD_INT 5
76948: NEG
76949: PUSH
76950: EMPTY
76951: LIST
76952: LIST
76953: PUSH
76954: EMPTY
76955: LIST
76956: LIST
76957: LIST
76958: LIST
76959: LIST
76960: LIST
76961: LIST
76962: LIST
76963: LIST
76964: LIST
76965: LIST
76966: LIST
76967: LIST
76968: LIST
76969: LIST
76970: LIST
76971: LIST
76972: LIST
76973: LIST
76974: LIST
76975: LIST
76976: LIST
76977: LIST
76978: LIST
76979: LIST
76980: LIST
76981: LIST
76982: LIST
76983: LIST
76984: LIST
76985: LIST
76986: LIST
76987: LIST
76988: LIST
76989: LIST
76990: LIST
76991: LIST
76992: LIST
76993: LIST
76994: LIST
76995: LIST
76996: LIST
76997: LIST
76998: LIST
76999: LIST
77000: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
77001: LD_ADDR_VAR 0 31
77005: PUSH
77006: LD_INT 0
77008: PUSH
77009: LD_INT 4
77011: PUSH
77012: EMPTY
77013: LIST
77014: LIST
77015: PUSH
77016: LD_INT 0
77018: PUSH
77019: LD_INT 3
77021: PUSH
77022: EMPTY
77023: LIST
77024: LIST
77025: PUSH
77026: LD_INT 1
77028: PUSH
77029: LD_INT 4
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: LD_INT 1
77038: PUSH
77039: LD_INT 5
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: LD_INT 0
77048: PUSH
77049: LD_INT 5
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: LD_INT 1
77058: NEG
77059: PUSH
77060: LD_INT 4
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: PUSH
77067: LD_INT 1
77069: NEG
77070: PUSH
77071: LD_INT 3
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: LD_INT 2
77080: PUSH
77081: LD_INT 5
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: PUSH
77088: LD_INT 2
77090: NEG
77091: PUSH
77092: LD_INT 3
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 3
77101: NEG
77102: PUSH
77103: LD_INT 0
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 3
77112: NEG
77113: PUSH
77114: LD_INT 1
77116: NEG
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: PUSH
77122: LD_INT 2
77124: NEG
77125: PUSH
77126: LD_INT 0
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: PUSH
77133: LD_INT 2
77135: NEG
77136: PUSH
77137: LD_INT 1
77139: PUSH
77140: EMPTY
77141: LIST
77142: LIST
77143: PUSH
77144: LD_INT 3
77146: NEG
77147: PUSH
77148: LD_INT 1
77150: PUSH
77151: EMPTY
77152: LIST
77153: LIST
77154: PUSH
77155: LD_INT 4
77157: NEG
77158: PUSH
77159: LD_INT 0
77161: PUSH
77162: EMPTY
77163: LIST
77164: LIST
77165: PUSH
77166: LD_INT 4
77168: NEG
77169: PUSH
77170: LD_INT 1
77172: NEG
77173: PUSH
77174: EMPTY
77175: LIST
77176: LIST
77177: PUSH
77178: LD_INT 4
77180: NEG
77181: PUSH
77182: LD_INT 2
77184: NEG
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: PUSH
77190: LD_INT 2
77192: NEG
77193: PUSH
77194: LD_INT 2
77196: PUSH
77197: EMPTY
77198: LIST
77199: LIST
77200: PUSH
77201: LD_INT 4
77203: NEG
77204: PUSH
77205: LD_INT 4
77207: NEG
77208: PUSH
77209: EMPTY
77210: LIST
77211: LIST
77212: PUSH
77213: LD_INT 4
77215: NEG
77216: PUSH
77217: LD_INT 5
77219: NEG
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 3
77227: NEG
77228: PUSH
77229: LD_INT 4
77231: NEG
77232: PUSH
77233: EMPTY
77234: LIST
77235: LIST
77236: PUSH
77237: LD_INT 3
77239: NEG
77240: PUSH
77241: LD_INT 3
77243: NEG
77244: PUSH
77245: EMPTY
77246: LIST
77247: LIST
77248: PUSH
77249: LD_INT 4
77251: NEG
77252: PUSH
77253: LD_INT 3
77255: NEG
77256: PUSH
77257: EMPTY
77258: LIST
77259: LIST
77260: PUSH
77261: LD_INT 5
77263: NEG
77264: PUSH
77265: LD_INT 4
77267: NEG
77268: PUSH
77269: EMPTY
77270: LIST
77271: LIST
77272: PUSH
77273: LD_INT 5
77275: NEG
77276: PUSH
77277: LD_INT 5
77279: NEG
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PUSH
77285: LD_INT 3
77287: NEG
77288: PUSH
77289: LD_INT 5
77291: NEG
77292: PUSH
77293: EMPTY
77294: LIST
77295: LIST
77296: PUSH
77297: LD_INT 5
77299: NEG
77300: PUSH
77301: LD_INT 3
77303: NEG
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: PUSH
77309: LD_INT 0
77311: PUSH
77312: LD_INT 3
77314: NEG
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: PUSH
77320: LD_INT 0
77322: PUSH
77323: LD_INT 4
77325: NEG
77326: PUSH
77327: EMPTY
77328: LIST
77329: LIST
77330: PUSH
77331: LD_INT 1
77333: PUSH
77334: LD_INT 3
77336: NEG
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: PUSH
77342: LD_INT 1
77344: PUSH
77345: LD_INT 2
77347: NEG
77348: PUSH
77349: EMPTY
77350: LIST
77351: LIST
77352: PUSH
77353: LD_INT 0
77355: PUSH
77356: LD_INT 2
77358: NEG
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: PUSH
77364: LD_INT 1
77366: NEG
77367: PUSH
77368: LD_INT 3
77370: NEG
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: PUSH
77376: LD_INT 1
77378: NEG
77379: PUSH
77380: LD_INT 4
77382: NEG
77383: PUSH
77384: EMPTY
77385: LIST
77386: LIST
77387: PUSH
77388: LD_INT 2
77390: PUSH
77391: LD_INT 2
77393: NEG
77394: PUSH
77395: EMPTY
77396: LIST
77397: LIST
77398: PUSH
77399: LD_INT 2
77401: NEG
77402: PUSH
77403: LD_INT 4
77405: NEG
77406: PUSH
77407: EMPTY
77408: LIST
77409: LIST
77410: PUSH
77411: LD_INT 4
77413: PUSH
77414: LD_INT 0
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PUSH
77421: LD_INT 4
77423: PUSH
77424: LD_INT 1
77426: NEG
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PUSH
77432: LD_INT 5
77434: PUSH
77435: LD_INT 0
77437: PUSH
77438: EMPTY
77439: LIST
77440: LIST
77441: PUSH
77442: LD_INT 5
77444: PUSH
77445: LD_INT 1
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: LD_INT 4
77454: PUSH
77455: LD_INT 1
77457: PUSH
77458: EMPTY
77459: LIST
77460: LIST
77461: PUSH
77462: LD_INT 3
77464: PUSH
77465: LD_INT 0
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: LD_INT 3
77474: PUSH
77475: LD_INT 1
77477: NEG
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: PUSH
77483: LD_INT 3
77485: PUSH
77486: LD_INT 2
77488: NEG
77489: PUSH
77490: EMPTY
77491: LIST
77492: LIST
77493: PUSH
77494: LD_INT 5
77496: PUSH
77497: LD_INT 2
77499: PUSH
77500: EMPTY
77501: LIST
77502: LIST
77503: PUSH
77504: EMPTY
77505: LIST
77506: LIST
77507: LIST
77508: LIST
77509: LIST
77510: LIST
77511: LIST
77512: LIST
77513: LIST
77514: LIST
77515: LIST
77516: LIST
77517: LIST
77518: LIST
77519: LIST
77520: LIST
77521: LIST
77522: LIST
77523: LIST
77524: LIST
77525: LIST
77526: LIST
77527: LIST
77528: LIST
77529: LIST
77530: LIST
77531: LIST
77532: LIST
77533: LIST
77534: LIST
77535: LIST
77536: LIST
77537: LIST
77538: LIST
77539: LIST
77540: LIST
77541: LIST
77542: LIST
77543: LIST
77544: LIST
77545: LIST
77546: LIST
77547: LIST
77548: LIST
77549: LIST
77550: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
77551: LD_ADDR_VAR 0 32
77555: PUSH
77556: LD_INT 4
77558: NEG
77559: PUSH
77560: LD_INT 0
77562: PUSH
77563: EMPTY
77564: LIST
77565: LIST
77566: PUSH
77567: LD_INT 4
77569: NEG
77570: PUSH
77571: LD_INT 1
77573: NEG
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: PUSH
77579: LD_INT 3
77581: NEG
77582: PUSH
77583: LD_INT 0
77585: PUSH
77586: EMPTY
77587: LIST
77588: LIST
77589: PUSH
77590: LD_INT 3
77592: NEG
77593: PUSH
77594: LD_INT 1
77596: PUSH
77597: EMPTY
77598: LIST
77599: LIST
77600: PUSH
77601: LD_INT 4
77603: NEG
77604: PUSH
77605: LD_INT 1
77607: PUSH
77608: EMPTY
77609: LIST
77610: LIST
77611: PUSH
77612: LD_INT 5
77614: NEG
77615: PUSH
77616: LD_INT 0
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: PUSH
77623: LD_INT 5
77625: NEG
77626: PUSH
77627: LD_INT 1
77629: NEG
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PUSH
77635: LD_INT 5
77637: NEG
77638: PUSH
77639: LD_INT 2
77641: NEG
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: PUSH
77647: LD_INT 3
77649: NEG
77650: PUSH
77651: LD_INT 2
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: PUSH
77658: LD_INT 3
77660: NEG
77661: PUSH
77662: LD_INT 3
77664: NEG
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: PUSH
77670: LD_INT 3
77672: NEG
77673: PUSH
77674: LD_INT 4
77676: NEG
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: PUSH
77682: LD_INT 2
77684: NEG
77685: PUSH
77686: LD_INT 3
77688: NEG
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: PUSH
77694: LD_INT 2
77696: NEG
77697: PUSH
77698: LD_INT 2
77700: NEG
77701: PUSH
77702: EMPTY
77703: LIST
77704: LIST
77705: PUSH
77706: LD_INT 3
77708: NEG
77709: PUSH
77710: LD_INT 2
77712: NEG
77713: PUSH
77714: EMPTY
77715: LIST
77716: LIST
77717: PUSH
77718: LD_INT 4
77720: NEG
77721: PUSH
77722: LD_INT 3
77724: NEG
77725: PUSH
77726: EMPTY
77727: LIST
77728: LIST
77729: PUSH
77730: LD_INT 4
77732: NEG
77733: PUSH
77734: LD_INT 4
77736: NEG
77737: PUSH
77738: EMPTY
77739: LIST
77740: LIST
77741: PUSH
77742: LD_INT 2
77744: NEG
77745: PUSH
77746: LD_INT 4
77748: NEG
77749: PUSH
77750: EMPTY
77751: LIST
77752: LIST
77753: PUSH
77754: LD_INT 4
77756: NEG
77757: PUSH
77758: LD_INT 2
77760: NEG
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: LD_INT 0
77768: PUSH
77769: LD_INT 4
77771: NEG
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: PUSH
77777: LD_INT 0
77779: PUSH
77780: LD_INT 5
77782: NEG
77783: PUSH
77784: EMPTY
77785: LIST
77786: LIST
77787: PUSH
77788: LD_INT 1
77790: PUSH
77791: LD_INT 4
77793: NEG
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 1
77801: PUSH
77802: LD_INT 3
77804: NEG
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: LD_INT 0
77812: PUSH
77813: LD_INT 3
77815: NEG
77816: PUSH
77817: EMPTY
77818: LIST
77819: LIST
77820: PUSH
77821: LD_INT 1
77823: NEG
77824: PUSH
77825: LD_INT 4
77827: NEG
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 1
77835: NEG
77836: PUSH
77837: LD_INT 5
77839: NEG
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: PUSH
77845: LD_INT 2
77847: PUSH
77848: LD_INT 3
77850: NEG
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: PUSH
77856: LD_INT 2
77858: NEG
77859: PUSH
77860: LD_INT 5
77862: NEG
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PUSH
77868: LD_INT 3
77870: PUSH
77871: LD_INT 0
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PUSH
77878: LD_INT 3
77880: PUSH
77881: LD_INT 1
77883: NEG
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: LD_INT 4
77891: PUSH
77892: LD_INT 0
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 4
77901: PUSH
77902: LD_INT 1
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 3
77911: PUSH
77912: LD_INT 1
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PUSH
77919: LD_INT 2
77921: PUSH
77922: LD_INT 0
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 2
77931: PUSH
77932: LD_INT 1
77934: NEG
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 2
77942: PUSH
77943: LD_INT 2
77945: NEG
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: LD_INT 4
77953: PUSH
77954: LD_INT 2
77956: PUSH
77957: EMPTY
77958: LIST
77959: LIST
77960: PUSH
77961: LD_INT 4
77963: PUSH
77964: LD_INT 4
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: PUSH
77971: LD_INT 4
77973: PUSH
77974: LD_INT 3
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: PUSH
77981: LD_INT 5
77983: PUSH
77984: LD_INT 4
77986: PUSH
77987: EMPTY
77988: LIST
77989: LIST
77990: PUSH
77991: LD_INT 5
77993: PUSH
77994: LD_INT 5
77996: PUSH
77997: EMPTY
77998: LIST
77999: LIST
78000: PUSH
78001: LD_INT 4
78003: PUSH
78004: LD_INT 5
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: LD_INT 3
78013: PUSH
78014: LD_INT 4
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: PUSH
78021: LD_INT 3
78023: PUSH
78024: LD_INT 3
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: PUSH
78031: LD_INT 5
78033: PUSH
78034: LD_INT 3
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: LD_INT 3
78043: PUSH
78044: LD_INT 5
78046: PUSH
78047: EMPTY
78048: LIST
78049: LIST
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: LIST
78055: LIST
78056: LIST
78057: LIST
78058: LIST
78059: LIST
78060: LIST
78061: LIST
78062: LIST
78063: LIST
78064: LIST
78065: LIST
78066: LIST
78067: LIST
78068: LIST
78069: LIST
78070: LIST
78071: LIST
78072: LIST
78073: LIST
78074: LIST
78075: LIST
78076: LIST
78077: LIST
78078: LIST
78079: LIST
78080: LIST
78081: LIST
78082: LIST
78083: LIST
78084: LIST
78085: LIST
78086: LIST
78087: LIST
78088: LIST
78089: LIST
78090: LIST
78091: LIST
78092: LIST
78093: LIST
78094: LIST
78095: LIST
78096: LIST
78097: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
78098: LD_ADDR_VAR 0 33
78102: PUSH
78103: LD_INT 4
78105: NEG
78106: PUSH
78107: LD_INT 4
78109: NEG
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: LD_INT 4
78117: NEG
78118: PUSH
78119: LD_INT 5
78121: NEG
78122: PUSH
78123: EMPTY
78124: LIST
78125: LIST
78126: PUSH
78127: LD_INT 3
78129: NEG
78130: PUSH
78131: LD_INT 4
78133: NEG
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: PUSH
78139: LD_INT 3
78141: NEG
78142: PUSH
78143: LD_INT 3
78145: NEG
78146: PUSH
78147: EMPTY
78148: LIST
78149: LIST
78150: PUSH
78151: LD_INT 4
78153: NEG
78154: PUSH
78155: LD_INT 3
78157: NEG
78158: PUSH
78159: EMPTY
78160: LIST
78161: LIST
78162: PUSH
78163: LD_INT 5
78165: NEG
78166: PUSH
78167: LD_INT 4
78169: NEG
78170: PUSH
78171: EMPTY
78172: LIST
78173: LIST
78174: PUSH
78175: LD_INT 5
78177: NEG
78178: PUSH
78179: LD_INT 5
78181: NEG
78182: PUSH
78183: EMPTY
78184: LIST
78185: LIST
78186: PUSH
78187: LD_INT 3
78189: NEG
78190: PUSH
78191: LD_INT 5
78193: NEG
78194: PUSH
78195: EMPTY
78196: LIST
78197: LIST
78198: PUSH
78199: LD_INT 5
78201: NEG
78202: PUSH
78203: LD_INT 3
78205: NEG
78206: PUSH
78207: EMPTY
78208: LIST
78209: LIST
78210: PUSH
78211: LD_INT 0
78213: PUSH
78214: LD_INT 3
78216: NEG
78217: PUSH
78218: EMPTY
78219: LIST
78220: LIST
78221: PUSH
78222: LD_INT 0
78224: PUSH
78225: LD_INT 4
78227: NEG
78228: PUSH
78229: EMPTY
78230: LIST
78231: LIST
78232: PUSH
78233: LD_INT 1
78235: PUSH
78236: LD_INT 3
78238: NEG
78239: PUSH
78240: EMPTY
78241: LIST
78242: LIST
78243: PUSH
78244: LD_INT 1
78246: PUSH
78247: LD_INT 2
78249: NEG
78250: PUSH
78251: EMPTY
78252: LIST
78253: LIST
78254: PUSH
78255: LD_INT 0
78257: PUSH
78258: LD_INT 2
78260: NEG
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: LD_INT 1
78268: NEG
78269: PUSH
78270: LD_INT 3
78272: NEG
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PUSH
78278: LD_INT 1
78280: NEG
78281: PUSH
78282: LD_INT 4
78284: NEG
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: PUSH
78290: LD_INT 2
78292: PUSH
78293: LD_INT 2
78295: NEG
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 2
78303: NEG
78304: PUSH
78305: LD_INT 4
78307: NEG
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: LD_INT 4
78315: PUSH
78316: LD_INT 0
78318: PUSH
78319: EMPTY
78320: LIST
78321: LIST
78322: PUSH
78323: LD_INT 4
78325: PUSH
78326: LD_INT 1
78328: NEG
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: PUSH
78334: LD_INT 5
78336: PUSH
78337: LD_INT 0
78339: PUSH
78340: EMPTY
78341: LIST
78342: LIST
78343: PUSH
78344: LD_INT 5
78346: PUSH
78347: LD_INT 1
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: PUSH
78354: LD_INT 4
78356: PUSH
78357: LD_INT 1
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: PUSH
78364: LD_INT 3
78366: PUSH
78367: LD_INT 0
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 3
78376: PUSH
78377: LD_INT 1
78379: NEG
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: LD_INT 3
78387: PUSH
78388: LD_INT 2
78390: NEG
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: PUSH
78396: LD_INT 5
78398: PUSH
78399: LD_INT 2
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: PUSH
78406: LD_INT 3
78408: PUSH
78409: LD_INT 3
78411: PUSH
78412: EMPTY
78413: LIST
78414: LIST
78415: PUSH
78416: LD_INT 3
78418: PUSH
78419: LD_INT 2
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 4
78428: PUSH
78429: LD_INT 3
78431: PUSH
78432: EMPTY
78433: LIST
78434: LIST
78435: PUSH
78436: LD_INT 4
78438: PUSH
78439: LD_INT 4
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PUSH
78446: LD_INT 3
78448: PUSH
78449: LD_INT 4
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 2
78458: PUSH
78459: LD_INT 3
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 2
78468: PUSH
78469: LD_INT 2
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 4
78478: PUSH
78479: LD_INT 2
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 2
78488: PUSH
78489: LD_INT 4
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 0
78498: PUSH
78499: LD_INT 4
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 0
78508: PUSH
78509: LD_INT 3
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 1
78518: PUSH
78519: LD_INT 4
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: PUSH
78526: LD_INT 1
78528: PUSH
78529: LD_INT 5
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PUSH
78536: LD_INT 0
78538: PUSH
78539: LD_INT 5
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: PUSH
78546: LD_INT 1
78548: NEG
78549: PUSH
78550: LD_INT 4
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 1
78559: NEG
78560: PUSH
78561: LD_INT 3
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: PUSH
78568: LD_INT 2
78570: PUSH
78571: LD_INT 5
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: LD_INT 2
78580: NEG
78581: PUSH
78582: LD_INT 3
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: LIST
78593: LIST
78594: LIST
78595: LIST
78596: LIST
78597: LIST
78598: LIST
78599: LIST
78600: LIST
78601: LIST
78602: LIST
78603: LIST
78604: LIST
78605: LIST
78606: LIST
78607: LIST
78608: LIST
78609: LIST
78610: LIST
78611: LIST
78612: LIST
78613: LIST
78614: LIST
78615: LIST
78616: LIST
78617: LIST
78618: LIST
78619: LIST
78620: LIST
78621: LIST
78622: LIST
78623: LIST
78624: LIST
78625: LIST
78626: LIST
78627: LIST
78628: LIST
78629: LIST
78630: LIST
78631: LIST
78632: LIST
78633: LIST
78634: LIST
78635: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
78636: LD_ADDR_VAR 0 34
78640: PUSH
78641: LD_INT 0
78643: PUSH
78644: LD_INT 4
78646: NEG
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: LD_INT 0
78654: PUSH
78655: LD_INT 5
78657: NEG
78658: PUSH
78659: EMPTY
78660: LIST
78661: LIST
78662: PUSH
78663: LD_INT 1
78665: PUSH
78666: LD_INT 4
78668: NEG
78669: PUSH
78670: EMPTY
78671: LIST
78672: LIST
78673: PUSH
78674: LD_INT 1
78676: PUSH
78677: LD_INT 3
78679: NEG
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PUSH
78685: LD_INT 0
78687: PUSH
78688: LD_INT 3
78690: NEG
78691: PUSH
78692: EMPTY
78693: LIST
78694: LIST
78695: PUSH
78696: LD_INT 1
78698: NEG
78699: PUSH
78700: LD_INT 4
78702: NEG
78703: PUSH
78704: EMPTY
78705: LIST
78706: LIST
78707: PUSH
78708: LD_INT 1
78710: NEG
78711: PUSH
78712: LD_INT 5
78714: NEG
78715: PUSH
78716: EMPTY
78717: LIST
78718: LIST
78719: PUSH
78720: LD_INT 2
78722: PUSH
78723: LD_INT 3
78725: NEG
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: LD_INT 2
78733: NEG
78734: PUSH
78735: LD_INT 5
78737: NEG
78738: PUSH
78739: EMPTY
78740: LIST
78741: LIST
78742: PUSH
78743: LD_INT 3
78745: PUSH
78746: LD_INT 0
78748: PUSH
78749: EMPTY
78750: LIST
78751: LIST
78752: PUSH
78753: LD_INT 3
78755: PUSH
78756: LD_INT 1
78758: NEG
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 4
78766: PUSH
78767: LD_INT 0
78769: PUSH
78770: EMPTY
78771: LIST
78772: LIST
78773: PUSH
78774: LD_INT 4
78776: PUSH
78777: LD_INT 1
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 3
78786: PUSH
78787: LD_INT 1
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: PUSH
78794: LD_INT 2
78796: PUSH
78797: LD_INT 0
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: PUSH
78804: LD_INT 2
78806: PUSH
78807: LD_INT 1
78809: NEG
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 2
78817: PUSH
78818: LD_INT 2
78820: NEG
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: PUSH
78826: LD_INT 4
78828: PUSH
78829: LD_INT 2
78831: PUSH
78832: EMPTY
78833: LIST
78834: LIST
78835: PUSH
78836: LD_INT 4
78838: PUSH
78839: LD_INT 4
78841: PUSH
78842: EMPTY
78843: LIST
78844: LIST
78845: PUSH
78846: LD_INT 4
78848: PUSH
78849: LD_INT 3
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 5
78858: PUSH
78859: LD_INT 4
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: PUSH
78866: LD_INT 5
78868: PUSH
78869: LD_INT 5
78871: PUSH
78872: EMPTY
78873: LIST
78874: LIST
78875: PUSH
78876: LD_INT 4
78878: PUSH
78879: LD_INT 5
78881: PUSH
78882: EMPTY
78883: LIST
78884: LIST
78885: PUSH
78886: LD_INT 3
78888: PUSH
78889: LD_INT 4
78891: PUSH
78892: EMPTY
78893: LIST
78894: LIST
78895: PUSH
78896: LD_INT 3
78898: PUSH
78899: LD_INT 3
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PUSH
78906: LD_INT 5
78908: PUSH
78909: LD_INT 3
78911: PUSH
78912: EMPTY
78913: LIST
78914: LIST
78915: PUSH
78916: LD_INT 3
78918: PUSH
78919: LD_INT 5
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: PUSH
78926: LD_INT 0
78928: PUSH
78929: LD_INT 3
78931: PUSH
78932: EMPTY
78933: LIST
78934: LIST
78935: PUSH
78936: LD_INT 0
78938: PUSH
78939: LD_INT 2
78941: PUSH
78942: EMPTY
78943: LIST
78944: LIST
78945: PUSH
78946: LD_INT 1
78948: PUSH
78949: LD_INT 3
78951: PUSH
78952: EMPTY
78953: LIST
78954: LIST
78955: PUSH
78956: LD_INT 1
78958: PUSH
78959: LD_INT 4
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: PUSH
78966: LD_INT 0
78968: PUSH
78969: LD_INT 4
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: PUSH
78976: LD_INT 1
78978: NEG
78979: PUSH
78980: LD_INT 3
78982: PUSH
78983: EMPTY
78984: LIST
78985: LIST
78986: PUSH
78987: LD_INT 1
78989: NEG
78990: PUSH
78991: LD_INT 2
78993: PUSH
78994: EMPTY
78995: LIST
78996: LIST
78997: PUSH
78998: LD_INT 2
79000: PUSH
79001: LD_INT 4
79003: PUSH
79004: EMPTY
79005: LIST
79006: LIST
79007: PUSH
79008: LD_INT 2
79010: NEG
79011: PUSH
79012: LD_INT 2
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: PUSH
79019: LD_INT 4
79021: NEG
79022: PUSH
79023: LD_INT 0
79025: PUSH
79026: EMPTY
79027: LIST
79028: LIST
79029: PUSH
79030: LD_INT 4
79032: NEG
79033: PUSH
79034: LD_INT 1
79036: NEG
79037: PUSH
79038: EMPTY
79039: LIST
79040: LIST
79041: PUSH
79042: LD_INT 3
79044: NEG
79045: PUSH
79046: LD_INT 0
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 3
79055: NEG
79056: PUSH
79057: LD_INT 1
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 4
79066: NEG
79067: PUSH
79068: LD_INT 1
79070: PUSH
79071: EMPTY
79072: LIST
79073: LIST
79074: PUSH
79075: LD_INT 5
79077: NEG
79078: PUSH
79079: LD_INT 0
79081: PUSH
79082: EMPTY
79083: LIST
79084: LIST
79085: PUSH
79086: LD_INT 5
79088: NEG
79089: PUSH
79090: LD_INT 1
79092: NEG
79093: PUSH
79094: EMPTY
79095: LIST
79096: LIST
79097: PUSH
79098: LD_INT 5
79100: NEG
79101: PUSH
79102: LD_INT 2
79104: NEG
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: PUSH
79110: LD_INT 3
79112: NEG
79113: PUSH
79114: LD_INT 2
79116: PUSH
79117: EMPTY
79118: LIST
79119: LIST
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: LIST
79125: LIST
79126: LIST
79127: LIST
79128: LIST
79129: LIST
79130: LIST
79131: LIST
79132: LIST
79133: LIST
79134: LIST
79135: LIST
79136: LIST
79137: LIST
79138: LIST
79139: LIST
79140: LIST
79141: LIST
79142: LIST
79143: LIST
79144: LIST
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: LIST
79151: LIST
79152: LIST
79153: LIST
79154: LIST
79155: LIST
79156: LIST
79157: LIST
79158: LIST
79159: LIST
79160: LIST
79161: LIST
79162: LIST
79163: LIST
79164: LIST
79165: LIST
79166: LIST
79167: ST_TO_ADDR
// end ; end ;
79168: GO 79171
79170: POP
// case btype of b_depot , b_warehouse :
79171: LD_VAR 0 1
79175: PUSH
79176: LD_INT 0
79178: DOUBLE
79179: EQUAL
79180: IFTRUE 79190
79182: LD_INT 1
79184: DOUBLE
79185: EQUAL
79186: IFTRUE 79190
79188: GO 79391
79190: POP
// case nation of nation_american :
79191: LD_VAR 0 5
79195: PUSH
79196: LD_INT 1
79198: DOUBLE
79199: EQUAL
79200: IFTRUE 79204
79202: GO 79260
79204: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
79205: LD_ADDR_VAR 0 9
79209: PUSH
79210: LD_VAR 0 11
79214: PUSH
79215: LD_VAR 0 12
79219: PUSH
79220: LD_VAR 0 13
79224: PUSH
79225: LD_VAR 0 14
79229: PUSH
79230: LD_VAR 0 15
79234: PUSH
79235: LD_VAR 0 16
79239: PUSH
79240: EMPTY
79241: LIST
79242: LIST
79243: LIST
79244: LIST
79245: LIST
79246: LIST
79247: PUSH
79248: LD_VAR 0 4
79252: PUSH
79253: LD_INT 1
79255: PLUS
79256: ARRAY
79257: ST_TO_ADDR
79258: GO 79389
79260: LD_INT 2
79262: DOUBLE
79263: EQUAL
79264: IFTRUE 79268
79266: GO 79324
79268: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
79269: LD_ADDR_VAR 0 9
79273: PUSH
79274: LD_VAR 0 17
79278: PUSH
79279: LD_VAR 0 18
79283: PUSH
79284: LD_VAR 0 19
79288: PUSH
79289: LD_VAR 0 20
79293: PUSH
79294: LD_VAR 0 21
79298: PUSH
79299: LD_VAR 0 22
79303: PUSH
79304: EMPTY
79305: LIST
79306: LIST
79307: LIST
79308: LIST
79309: LIST
79310: LIST
79311: PUSH
79312: LD_VAR 0 4
79316: PUSH
79317: LD_INT 1
79319: PLUS
79320: ARRAY
79321: ST_TO_ADDR
79322: GO 79389
79324: LD_INT 3
79326: DOUBLE
79327: EQUAL
79328: IFTRUE 79332
79330: GO 79388
79332: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
79333: LD_ADDR_VAR 0 9
79337: PUSH
79338: LD_VAR 0 23
79342: PUSH
79343: LD_VAR 0 24
79347: PUSH
79348: LD_VAR 0 25
79352: PUSH
79353: LD_VAR 0 26
79357: PUSH
79358: LD_VAR 0 27
79362: PUSH
79363: LD_VAR 0 28
79367: PUSH
79368: EMPTY
79369: LIST
79370: LIST
79371: LIST
79372: LIST
79373: LIST
79374: LIST
79375: PUSH
79376: LD_VAR 0 4
79380: PUSH
79381: LD_INT 1
79383: PLUS
79384: ARRAY
79385: ST_TO_ADDR
79386: GO 79389
79388: POP
79389: GO 79944
79391: LD_INT 2
79393: DOUBLE
79394: EQUAL
79395: IFTRUE 79405
79397: LD_INT 3
79399: DOUBLE
79400: EQUAL
79401: IFTRUE 79405
79403: GO 79461
79405: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
79406: LD_ADDR_VAR 0 9
79410: PUSH
79411: LD_VAR 0 29
79415: PUSH
79416: LD_VAR 0 30
79420: PUSH
79421: LD_VAR 0 31
79425: PUSH
79426: LD_VAR 0 32
79430: PUSH
79431: LD_VAR 0 33
79435: PUSH
79436: LD_VAR 0 34
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: PUSH
79449: LD_VAR 0 4
79453: PUSH
79454: LD_INT 1
79456: PLUS
79457: ARRAY
79458: ST_TO_ADDR
79459: GO 79944
79461: LD_INT 16
79463: DOUBLE
79464: EQUAL
79465: IFTRUE 79523
79467: LD_INT 17
79469: DOUBLE
79470: EQUAL
79471: IFTRUE 79523
79473: LD_INT 18
79475: DOUBLE
79476: EQUAL
79477: IFTRUE 79523
79479: LD_INT 19
79481: DOUBLE
79482: EQUAL
79483: IFTRUE 79523
79485: LD_INT 22
79487: DOUBLE
79488: EQUAL
79489: IFTRUE 79523
79491: LD_INT 20
79493: DOUBLE
79494: EQUAL
79495: IFTRUE 79523
79497: LD_INT 21
79499: DOUBLE
79500: EQUAL
79501: IFTRUE 79523
79503: LD_INT 23
79505: DOUBLE
79506: EQUAL
79507: IFTRUE 79523
79509: LD_INT 24
79511: DOUBLE
79512: EQUAL
79513: IFTRUE 79523
79515: LD_INT 25
79517: DOUBLE
79518: EQUAL
79519: IFTRUE 79523
79521: GO 79579
79523: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
79524: LD_ADDR_VAR 0 9
79528: PUSH
79529: LD_VAR 0 35
79533: PUSH
79534: LD_VAR 0 36
79538: PUSH
79539: LD_VAR 0 37
79543: PUSH
79544: LD_VAR 0 38
79548: PUSH
79549: LD_VAR 0 39
79553: PUSH
79554: LD_VAR 0 40
79558: PUSH
79559: EMPTY
79560: LIST
79561: LIST
79562: LIST
79563: LIST
79564: LIST
79565: LIST
79566: PUSH
79567: LD_VAR 0 4
79571: PUSH
79572: LD_INT 1
79574: PLUS
79575: ARRAY
79576: ST_TO_ADDR
79577: GO 79944
79579: LD_INT 6
79581: DOUBLE
79582: EQUAL
79583: IFTRUE 79635
79585: LD_INT 7
79587: DOUBLE
79588: EQUAL
79589: IFTRUE 79635
79591: LD_INT 8
79593: DOUBLE
79594: EQUAL
79595: IFTRUE 79635
79597: LD_INT 13
79599: DOUBLE
79600: EQUAL
79601: IFTRUE 79635
79603: LD_INT 12
79605: DOUBLE
79606: EQUAL
79607: IFTRUE 79635
79609: LD_INT 15
79611: DOUBLE
79612: EQUAL
79613: IFTRUE 79635
79615: LD_INT 11
79617: DOUBLE
79618: EQUAL
79619: IFTRUE 79635
79621: LD_INT 14
79623: DOUBLE
79624: EQUAL
79625: IFTRUE 79635
79627: LD_INT 10
79629: DOUBLE
79630: EQUAL
79631: IFTRUE 79635
79633: GO 79691
79635: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
79636: LD_ADDR_VAR 0 9
79640: PUSH
79641: LD_VAR 0 41
79645: PUSH
79646: LD_VAR 0 42
79650: PUSH
79651: LD_VAR 0 43
79655: PUSH
79656: LD_VAR 0 44
79660: PUSH
79661: LD_VAR 0 45
79665: PUSH
79666: LD_VAR 0 46
79670: PUSH
79671: EMPTY
79672: LIST
79673: LIST
79674: LIST
79675: LIST
79676: LIST
79677: LIST
79678: PUSH
79679: LD_VAR 0 4
79683: PUSH
79684: LD_INT 1
79686: PLUS
79687: ARRAY
79688: ST_TO_ADDR
79689: GO 79944
79691: LD_INT 36
79693: DOUBLE
79694: EQUAL
79695: IFTRUE 79699
79697: GO 79755
79699: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
79700: LD_ADDR_VAR 0 9
79704: PUSH
79705: LD_VAR 0 47
79709: PUSH
79710: LD_VAR 0 48
79714: PUSH
79715: LD_VAR 0 49
79719: PUSH
79720: LD_VAR 0 50
79724: PUSH
79725: LD_VAR 0 51
79729: PUSH
79730: LD_VAR 0 52
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: LIST
79739: LIST
79740: LIST
79741: LIST
79742: PUSH
79743: LD_VAR 0 4
79747: PUSH
79748: LD_INT 1
79750: PLUS
79751: ARRAY
79752: ST_TO_ADDR
79753: GO 79944
79755: LD_INT 4
79757: DOUBLE
79758: EQUAL
79759: IFTRUE 79781
79761: LD_INT 5
79763: DOUBLE
79764: EQUAL
79765: IFTRUE 79781
79767: LD_INT 34
79769: DOUBLE
79770: EQUAL
79771: IFTRUE 79781
79773: LD_INT 37
79775: DOUBLE
79776: EQUAL
79777: IFTRUE 79781
79779: GO 79837
79781: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
79782: LD_ADDR_VAR 0 9
79786: PUSH
79787: LD_VAR 0 53
79791: PUSH
79792: LD_VAR 0 54
79796: PUSH
79797: LD_VAR 0 55
79801: PUSH
79802: LD_VAR 0 56
79806: PUSH
79807: LD_VAR 0 57
79811: PUSH
79812: LD_VAR 0 58
79816: PUSH
79817: EMPTY
79818: LIST
79819: LIST
79820: LIST
79821: LIST
79822: LIST
79823: LIST
79824: PUSH
79825: LD_VAR 0 4
79829: PUSH
79830: LD_INT 1
79832: PLUS
79833: ARRAY
79834: ST_TO_ADDR
79835: GO 79944
79837: LD_INT 31
79839: DOUBLE
79840: EQUAL
79841: IFTRUE 79887
79843: LD_INT 32
79845: DOUBLE
79846: EQUAL
79847: IFTRUE 79887
79849: LD_INT 33
79851: DOUBLE
79852: EQUAL
79853: IFTRUE 79887
79855: LD_INT 27
79857: DOUBLE
79858: EQUAL
79859: IFTRUE 79887
79861: LD_INT 26
79863: DOUBLE
79864: EQUAL
79865: IFTRUE 79887
79867: LD_INT 28
79869: DOUBLE
79870: EQUAL
79871: IFTRUE 79887
79873: LD_INT 29
79875: DOUBLE
79876: EQUAL
79877: IFTRUE 79887
79879: LD_INT 30
79881: DOUBLE
79882: EQUAL
79883: IFTRUE 79887
79885: GO 79943
79887: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
79888: LD_ADDR_VAR 0 9
79892: PUSH
79893: LD_VAR 0 59
79897: PUSH
79898: LD_VAR 0 60
79902: PUSH
79903: LD_VAR 0 61
79907: PUSH
79908: LD_VAR 0 62
79912: PUSH
79913: LD_VAR 0 63
79917: PUSH
79918: LD_VAR 0 64
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: LIST
79929: LIST
79930: PUSH
79931: LD_VAR 0 4
79935: PUSH
79936: LD_INT 1
79938: PLUS
79939: ARRAY
79940: ST_TO_ADDR
79941: GO 79944
79943: POP
// temp_list2 = [ ] ;
79944: LD_ADDR_VAR 0 10
79948: PUSH
79949: EMPTY
79950: ST_TO_ADDR
// for i in temp_list do
79951: LD_ADDR_VAR 0 8
79955: PUSH
79956: LD_VAR 0 9
79960: PUSH
79961: FOR_IN
79962: IFFALSE 80014
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
79964: LD_ADDR_VAR 0 10
79968: PUSH
79969: LD_VAR 0 10
79973: PUSH
79974: LD_VAR 0 8
79978: PUSH
79979: LD_INT 1
79981: ARRAY
79982: PUSH
79983: LD_VAR 0 2
79987: PLUS
79988: PUSH
79989: LD_VAR 0 8
79993: PUSH
79994: LD_INT 2
79996: ARRAY
79997: PUSH
79998: LD_VAR 0 3
80002: PLUS
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: PUSH
80008: EMPTY
80009: LIST
80010: ADD
80011: ST_TO_ADDR
80012: GO 79961
80014: POP
80015: POP
// result = temp_list2 ;
80016: LD_ADDR_VAR 0 7
80020: PUSH
80021: LD_VAR 0 10
80025: ST_TO_ADDR
// end ;
80026: LD_VAR 0 7
80030: RET
// export function EnemyInRange ( unit , dist ) ; begin
80031: LD_INT 0
80033: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
80034: LD_ADDR_VAR 0 3
80038: PUSH
80039: LD_VAR 0 1
80043: PPUSH
80044: CALL_OW 255
80048: PPUSH
80049: LD_VAR 0 1
80053: PPUSH
80054: CALL_OW 250
80058: PPUSH
80059: LD_VAR 0 1
80063: PPUSH
80064: CALL_OW 251
80068: PPUSH
80069: LD_VAR 0 2
80073: PPUSH
80074: CALL 53802 0 4
80078: PUSH
80079: LD_INT 4
80081: ARRAY
80082: ST_TO_ADDR
// end ;
80083: LD_VAR 0 3
80087: RET
// export function PlayerSeeMe ( unit ) ; begin
80088: LD_INT 0
80090: PPUSH
// result := See ( your_side , unit ) ;
80091: LD_ADDR_VAR 0 2
80095: PUSH
80096: LD_OWVAR 2
80100: PPUSH
80101: LD_VAR 0 1
80105: PPUSH
80106: CALL_OW 292
80110: ST_TO_ADDR
// end ;
80111: LD_VAR 0 2
80115: RET
// export function ReverseDir ( unit ) ; begin
80116: LD_INT 0
80118: PPUSH
// if not unit then
80119: LD_VAR 0 1
80123: NOT
80124: IFFALSE 80128
// exit ;
80126: GO 80151
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
80128: LD_ADDR_VAR 0 2
80132: PUSH
80133: LD_VAR 0 1
80137: PPUSH
80138: CALL_OW 254
80142: PUSH
80143: LD_INT 3
80145: PLUS
80146: PUSH
80147: LD_INT 6
80149: MOD
80150: ST_TO_ADDR
// end ;
80151: LD_VAR 0 2
80155: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
80156: LD_INT 0
80158: PPUSH
80159: PPUSH
80160: PPUSH
80161: PPUSH
80162: PPUSH
// if not hexes then
80163: LD_VAR 0 2
80167: NOT
80168: IFFALSE 80172
// exit ;
80170: GO 80320
// dist := 9999 ;
80172: LD_ADDR_VAR 0 5
80176: PUSH
80177: LD_INT 9999
80179: ST_TO_ADDR
// for i = 1 to hexes do
80180: LD_ADDR_VAR 0 4
80184: PUSH
80185: DOUBLE
80186: LD_INT 1
80188: DEC
80189: ST_TO_ADDR
80190: LD_VAR 0 2
80194: PUSH
80195: FOR_TO
80196: IFFALSE 80308
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
80198: LD_VAR 0 1
80202: PPUSH
80203: LD_VAR 0 2
80207: PUSH
80208: LD_VAR 0 4
80212: ARRAY
80213: PUSH
80214: LD_INT 1
80216: ARRAY
80217: PPUSH
80218: LD_VAR 0 2
80222: PUSH
80223: LD_VAR 0 4
80227: ARRAY
80228: PUSH
80229: LD_INT 2
80231: ARRAY
80232: PPUSH
80233: CALL_OW 297
80237: PUSH
80238: LD_VAR 0 5
80242: LESS
80243: IFFALSE 80306
// begin hex := hexes [ i ] ;
80245: LD_ADDR_VAR 0 7
80249: PUSH
80250: LD_VAR 0 2
80254: PUSH
80255: LD_VAR 0 4
80259: ARRAY
80260: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
80261: LD_ADDR_VAR 0 5
80265: PUSH
80266: LD_VAR 0 1
80270: PPUSH
80271: LD_VAR 0 2
80275: PUSH
80276: LD_VAR 0 4
80280: ARRAY
80281: PUSH
80282: LD_INT 1
80284: ARRAY
80285: PPUSH
80286: LD_VAR 0 2
80290: PUSH
80291: LD_VAR 0 4
80295: ARRAY
80296: PUSH
80297: LD_INT 2
80299: ARRAY
80300: PPUSH
80301: CALL_OW 297
80305: ST_TO_ADDR
// end ; end ;
80306: GO 80195
80308: POP
80309: POP
// result := hex ;
80310: LD_ADDR_VAR 0 3
80314: PUSH
80315: LD_VAR 0 7
80319: ST_TO_ADDR
// end ;
80320: LD_VAR 0 3
80324: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
80325: LD_INT 0
80327: PPUSH
80328: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
80329: LD_VAR 0 1
80333: NOT
80334: PUSH
80335: LD_VAR 0 1
80339: PUSH
80340: LD_INT 21
80342: PUSH
80343: LD_INT 2
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 23
80352: PUSH
80353: LD_INT 2
80355: PUSH
80356: EMPTY
80357: LIST
80358: LIST
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PPUSH
80364: CALL_OW 69
80368: IN
80369: NOT
80370: OR
80371: IFFALSE 80375
// exit ;
80373: GO 80422
// for i = 1 to 3 do
80375: LD_ADDR_VAR 0 3
80379: PUSH
80380: DOUBLE
80381: LD_INT 1
80383: DEC
80384: ST_TO_ADDR
80385: LD_INT 3
80387: PUSH
80388: FOR_TO
80389: IFFALSE 80420
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
80391: LD_VAR 0 1
80395: PPUSH
80396: CALL_OW 250
80400: PPUSH
80401: LD_VAR 0 1
80405: PPUSH
80406: CALL_OW 251
80410: PPUSH
80411: LD_INT 1
80413: PPUSH
80414: CALL_OW 453
80418: GO 80388
80420: POP
80421: POP
// end ;
80422: LD_VAR 0 2
80426: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
80427: LD_INT 0
80429: PPUSH
80430: PPUSH
80431: PPUSH
80432: PPUSH
80433: PPUSH
80434: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
80435: LD_VAR 0 1
80439: NOT
80440: PUSH
80441: LD_VAR 0 2
80445: NOT
80446: OR
80447: PUSH
80448: LD_VAR 0 1
80452: PPUSH
80453: CALL_OW 314
80457: OR
80458: IFFALSE 80462
// exit ;
80460: GO 80903
// x := GetX ( enemy_unit ) ;
80462: LD_ADDR_VAR 0 7
80466: PUSH
80467: LD_VAR 0 2
80471: PPUSH
80472: CALL_OW 250
80476: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
80477: LD_ADDR_VAR 0 8
80481: PUSH
80482: LD_VAR 0 2
80486: PPUSH
80487: CALL_OW 251
80491: ST_TO_ADDR
// if not x or not y then
80492: LD_VAR 0 7
80496: NOT
80497: PUSH
80498: LD_VAR 0 8
80502: NOT
80503: OR
80504: IFFALSE 80508
// exit ;
80506: GO 80903
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
80508: LD_ADDR_VAR 0 6
80512: PUSH
80513: LD_VAR 0 7
80517: PPUSH
80518: LD_INT 0
80520: PPUSH
80521: LD_INT 4
80523: PPUSH
80524: CALL_OW 272
80528: PUSH
80529: LD_VAR 0 8
80533: PPUSH
80534: LD_INT 0
80536: PPUSH
80537: LD_INT 4
80539: PPUSH
80540: CALL_OW 273
80544: PUSH
80545: EMPTY
80546: LIST
80547: LIST
80548: PUSH
80549: LD_VAR 0 7
80553: PPUSH
80554: LD_INT 1
80556: PPUSH
80557: LD_INT 4
80559: PPUSH
80560: CALL_OW 272
80564: PUSH
80565: LD_VAR 0 8
80569: PPUSH
80570: LD_INT 1
80572: PPUSH
80573: LD_INT 4
80575: PPUSH
80576: CALL_OW 273
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_VAR 0 7
80589: PPUSH
80590: LD_INT 2
80592: PPUSH
80593: LD_INT 4
80595: PPUSH
80596: CALL_OW 272
80600: PUSH
80601: LD_VAR 0 8
80605: PPUSH
80606: LD_INT 2
80608: PPUSH
80609: LD_INT 4
80611: PPUSH
80612: CALL_OW 273
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_VAR 0 7
80625: PPUSH
80626: LD_INT 3
80628: PPUSH
80629: LD_INT 4
80631: PPUSH
80632: CALL_OW 272
80636: PUSH
80637: LD_VAR 0 8
80641: PPUSH
80642: LD_INT 3
80644: PPUSH
80645: LD_INT 4
80647: PPUSH
80648: CALL_OW 273
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_VAR 0 7
80661: PPUSH
80662: LD_INT 4
80664: PPUSH
80665: LD_INT 4
80667: PPUSH
80668: CALL_OW 272
80672: PUSH
80673: LD_VAR 0 8
80677: PPUSH
80678: LD_INT 4
80680: PPUSH
80681: LD_INT 4
80683: PPUSH
80684: CALL_OW 273
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: PUSH
80693: LD_VAR 0 7
80697: PPUSH
80698: LD_INT 5
80700: PPUSH
80701: LD_INT 4
80703: PPUSH
80704: CALL_OW 272
80708: PUSH
80709: LD_VAR 0 8
80713: PPUSH
80714: LD_INT 5
80716: PPUSH
80717: LD_INT 4
80719: PPUSH
80720: CALL_OW 273
80724: PUSH
80725: EMPTY
80726: LIST
80727: LIST
80728: PUSH
80729: EMPTY
80730: LIST
80731: LIST
80732: LIST
80733: LIST
80734: LIST
80735: LIST
80736: ST_TO_ADDR
// for i = tmp downto 1 do
80737: LD_ADDR_VAR 0 4
80741: PUSH
80742: DOUBLE
80743: LD_VAR 0 6
80747: INC
80748: ST_TO_ADDR
80749: LD_INT 1
80751: PUSH
80752: FOR_DOWNTO
80753: IFFALSE 80854
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
80755: LD_VAR 0 6
80759: PUSH
80760: LD_VAR 0 4
80764: ARRAY
80765: PUSH
80766: LD_INT 1
80768: ARRAY
80769: PPUSH
80770: LD_VAR 0 6
80774: PUSH
80775: LD_VAR 0 4
80779: ARRAY
80780: PUSH
80781: LD_INT 2
80783: ARRAY
80784: PPUSH
80785: CALL_OW 488
80789: NOT
80790: PUSH
80791: LD_VAR 0 6
80795: PUSH
80796: LD_VAR 0 4
80800: ARRAY
80801: PUSH
80802: LD_INT 1
80804: ARRAY
80805: PPUSH
80806: LD_VAR 0 6
80810: PUSH
80811: LD_VAR 0 4
80815: ARRAY
80816: PUSH
80817: LD_INT 2
80819: ARRAY
80820: PPUSH
80821: CALL_OW 428
80825: PUSH
80826: LD_INT 0
80828: NONEQUAL
80829: OR
80830: IFFALSE 80852
// tmp := Delete ( tmp , i ) ;
80832: LD_ADDR_VAR 0 6
80836: PUSH
80837: LD_VAR 0 6
80841: PPUSH
80842: LD_VAR 0 4
80846: PPUSH
80847: CALL_OW 3
80851: ST_TO_ADDR
80852: GO 80752
80854: POP
80855: POP
// j := GetClosestHex ( unit , tmp ) ;
80856: LD_ADDR_VAR 0 5
80860: PUSH
80861: LD_VAR 0 1
80865: PPUSH
80866: LD_VAR 0 6
80870: PPUSH
80871: CALL 80156 0 2
80875: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
80876: LD_VAR 0 1
80880: PPUSH
80881: LD_VAR 0 5
80885: PUSH
80886: LD_INT 1
80888: ARRAY
80889: PPUSH
80890: LD_VAR 0 5
80894: PUSH
80895: LD_INT 2
80897: ARRAY
80898: PPUSH
80899: CALL_OW 111
// end ;
80903: LD_VAR 0 3
80907: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
80908: LD_INT 0
80910: PPUSH
80911: PPUSH
80912: PPUSH
// uc_side = 0 ;
80913: LD_ADDR_OWVAR 20
80917: PUSH
80918: LD_INT 0
80920: ST_TO_ADDR
// uc_nation = 0 ;
80921: LD_ADDR_OWVAR 21
80925: PUSH
80926: LD_INT 0
80928: ST_TO_ADDR
// InitHc_All ( ) ;
80929: CALL_OW 584
// InitVc ;
80933: CALL_OW 20
// if mastodonts then
80937: LD_VAR 0 6
80941: IFFALSE 81008
// for i = 1 to mastodonts do
80943: LD_ADDR_VAR 0 11
80947: PUSH
80948: DOUBLE
80949: LD_INT 1
80951: DEC
80952: ST_TO_ADDR
80953: LD_VAR 0 6
80957: PUSH
80958: FOR_TO
80959: IFFALSE 81006
// begin vc_chassis := 31 ;
80961: LD_ADDR_OWVAR 37
80965: PUSH
80966: LD_INT 31
80968: ST_TO_ADDR
// vc_control := control_rider ;
80969: LD_ADDR_OWVAR 38
80973: PUSH
80974: LD_INT 4
80976: ST_TO_ADDR
// animal := CreateVehicle ;
80977: LD_ADDR_VAR 0 12
80981: PUSH
80982: CALL_OW 45
80986: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80987: LD_VAR 0 12
80991: PPUSH
80992: LD_VAR 0 8
80996: PPUSH
80997: LD_INT 0
80999: PPUSH
81000: CALL 83196 0 3
// end ;
81004: GO 80958
81006: POP
81007: POP
// if horses then
81008: LD_VAR 0 5
81012: IFFALSE 81079
// for i = 1 to horses do
81014: LD_ADDR_VAR 0 11
81018: PUSH
81019: DOUBLE
81020: LD_INT 1
81022: DEC
81023: ST_TO_ADDR
81024: LD_VAR 0 5
81028: PUSH
81029: FOR_TO
81030: IFFALSE 81077
// begin hc_class := 21 ;
81032: LD_ADDR_OWVAR 28
81036: PUSH
81037: LD_INT 21
81039: ST_TO_ADDR
// hc_gallery :=  ;
81040: LD_ADDR_OWVAR 33
81044: PUSH
81045: LD_STRING 
81047: ST_TO_ADDR
// animal := CreateHuman ;
81048: LD_ADDR_VAR 0 12
81052: PUSH
81053: CALL_OW 44
81057: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81058: LD_VAR 0 12
81062: PPUSH
81063: LD_VAR 0 8
81067: PPUSH
81068: LD_INT 0
81070: PPUSH
81071: CALL 83196 0 3
// end ;
81075: GO 81029
81077: POP
81078: POP
// if birds then
81079: LD_VAR 0 1
81083: IFFALSE 81150
// for i = 1 to birds do
81085: LD_ADDR_VAR 0 11
81089: PUSH
81090: DOUBLE
81091: LD_INT 1
81093: DEC
81094: ST_TO_ADDR
81095: LD_VAR 0 1
81099: PUSH
81100: FOR_TO
81101: IFFALSE 81148
// begin hc_class = 18 ;
81103: LD_ADDR_OWVAR 28
81107: PUSH
81108: LD_INT 18
81110: ST_TO_ADDR
// hc_gallery =  ;
81111: LD_ADDR_OWVAR 33
81115: PUSH
81116: LD_STRING 
81118: ST_TO_ADDR
// animal := CreateHuman ;
81119: LD_ADDR_VAR 0 12
81123: PUSH
81124: CALL_OW 44
81128: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81129: LD_VAR 0 12
81133: PPUSH
81134: LD_VAR 0 8
81138: PPUSH
81139: LD_INT 0
81141: PPUSH
81142: CALL 83196 0 3
// end ;
81146: GO 81100
81148: POP
81149: POP
// if tigers then
81150: LD_VAR 0 2
81154: IFFALSE 81238
// for i = 1 to tigers do
81156: LD_ADDR_VAR 0 11
81160: PUSH
81161: DOUBLE
81162: LD_INT 1
81164: DEC
81165: ST_TO_ADDR
81166: LD_VAR 0 2
81170: PUSH
81171: FOR_TO
81172: IFFALSE 81236
// begin hc_class = class_tiger ;
81174: LD_ADDR_OWVAR 28
81178: PUSH
81179: LD_INT 14
81181: ST_TO_ADDR
// hc_gallery =  ;
81182: LD_ADDR_OWVAR 33
81186: PUSH
81187: LD_STRING 
81189: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
81190: LD_ADDR_OWVAR 35
81194: PUSH
81195: LD_INT 7
81197: NEG
81198: PPUSH
81199: LD_INT 7
81201: PPUSH
81202: CALL_OW 12
81206: ST_TO_ADDR
// animal := CreateHuman ;
81207: LD_ADDR_VAR 0 12
81211: PUSH
81212: CALL_OW 44
81216: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81217: LD_VAR 0 12
81221: PPUSH
81222: LD_VAR 0 8
81226: PPUSH
81227: LD_INT 0
81229: PPUSH
81230: CALL 83196 0 3
// end ;
81234: GO 81171
81236: POP
81237: POP
// if apemans then
81238: LD_VAR 0 3
81242: IFFALSE 81365
// for i = 1 to apemans do
81244: LD_ADDR_VAR 0 11
81248: PUSH
81249: DOUBLE
81250: LD_INT 1
81252: DEC
81253: ST_TO_ADDR
81254: LD_VAR 0 3
81258: PUSH
81259: FOR_TO
81260: IFFALSE 81363
// begin hc_class = class_apeman ;
81262: LD_ADDR_OWVAR 28
81266: PUSH
81267: LD_INT 12
81269: ST_TO_ADDR
// hc_gallery =  ;
81270: LD_ADDR_OWVAR 33
81274: PUSH
81275: LD_STRING 
81277: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
81278: LD_ADDR_OWVAR 35
81282: PUSH
81283: LD_INT 5
81285: NEG
81286: PPUSH
81287: LD_INT 5
81289: PPUSH
81290: CALL_OW 12
81294: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
81295: LD_ADDR_OWVAR 31
81299: PUSH
81300: LD_INT 1
81302: PPUSH
81303: LD_INT 3
81305: PPUSH
81306: CALL_OW 12
81310: PUSH
81311: LD_INT 1
81313: PPUSH
81314: LD_INT 3
81316: PPUSH
81317: CALL_OW 12
81321: PUSH
81322: LD_INT 0
81324: PUSH
81325: LD_INT 0
81327: PUSH
81328: EMPTY
81329: LIST
81330: LIST
81331: LIST
81332: LIST
81333: ST_TO_ADDR
// animal := CreateHuman ;
81334: LD_ADDR_VAR 0 12
81338: PUSH
81339: CALL_OW 44
81343: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81344: LD_VAR 0 12
81348: PPUSH
81349: LD_VAR 0 8
81353: PPUSH
81354: LD_INT 0
81356: PPUSH
81357: CALL 83196 0 3
// end ;
81361: GO 81259
81363: POP
81364: POP
// if enchidnas then
81365: LD_VAR 0 4
81369: IFFALSE 81436
// for i = 1 to enchidnas do
81371: LD_ADDR_VAR 0 11
81375: PUSH
81376: DOUBLE
81377: LD_INT 1
81379: DEC
81380: ST_TO_ADDR
81381: LD_VAR 0 4
81385: PUSH
81386: FOR_TO
81387: IFFALSE 81434
// begin hc_class = 13 ;
81389: LD_ADDR_OWVAR 28
81393: PUSH
81394: LD_INT 13
81396: ST_TO_ADDR
// hc_gallery =  ;
81397: LD_ADDR_OWVAR 33
81401: PUSH
81402: LD_STRING 
81404: ST_TO_ADDR
// animal := CreateHuman ;
81405: LD_ADDR_VAR 0 12
81409: PUSH
81410: CALL_OW 44
81414: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81415: LD_VAR 0 12
81419: PPUSH
81420: LD_VAR 0 8
81424: PPUSH
81425: LD_INT 0
81427: PPUSH
81428: CALL 83196 0 3
// end ;
81432: GO 81386
81434: POP
81435: POP
// if fishes then
81436: LD_VAR 0 7
81440: IFFALSE 81507
// for i = 1 to fishes do
81442: LD_ADDR_VAR 0 11
81446: PUSH
81447: DOUBLE
81448: LD_INT 1
81450: DEC
81451: ST_TO_ADDR
81452: LD_VAR 0 7
81456: PUSH
81457: FOR_TO
81458: IFFALSE 81505
// begin hc_class = 20 ;
81460: LD_ADDR_OWVAR 28
81464: PUSH
81465: LD_INT 20
81467: ST_TO_ADDR
// hc_gallery =  ;
81468: LD_ADDR_OWVAR 33
81472: PUSH
81473: LD_STRING 
81475: ST_TO_ADDR
// animal := CreateHuman ;
81476: LD_ADDR_VAR 0 12
81480: PUSH
81481: CALL_OW 44
81485: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
81486: LD_VAR 0 12
81490: PPUSH
81491: LD_VAR 0 9
81495: PPUSH
81496: LD_INT 0
81498: PPUSH
81499: CALL 83196 0 3
// end ;
81503: GO 81457
81505: POP
81506: POP
// end ;
81507: LD_VAR 0 10
81511: RET
// export function WantHeal ( sci , unit ) ; begin
81512: LD_INT 0
81514: PPUSH
// if GetTaskList ( sci ) > 0 then
81515: LD_VAR 0 1
81519: PPUSH
81520: CALL_OW 437
81524: PUSH
81525: LD_INT 0
81527: GREATER
81528: IFFALSE 81598
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
81530: LD_VAR 0 1
81534: PPUSH
81535: CALL_OW 437
81539: PUSH
81540: LD_INT 1
81542: ARRAY
81543: PUSH
81544: LD_INT 1
81546: ARRAY
81547: PUSH
81548: LD_STRING l
81550: EQUAL
81551: PUSH
81552: LD_VAR 0 1
81556: PPUSH
81557: CALL_OW 437
81561: PUSH
81562: LD_INT 1
81564: ARRAY
81565: PUSH
81566: LD_INT 4
81568: ARRAY
81569: PUSH
81570: LD_VAR 0 2
81574: EQUAL
81575: AND
81576: IFFALSE 81588
// result := true else
81578: LD_ADDR_VAR 0 3
81582: PUSH
81583: LD_INT 1
81585: ST_TO_ADDR
81586: GO 81596
// result := false ;
81588: LD_ADDR_VAR 0 3
81592: PUSH
81593: LD_INT 0
81595: ST_TO_ADDR
// end else
81596: GO 81606
// result := false ;
81598: LD_ADDR_VAR 0 3
81602: PUSH
81603: LD_INT 0
81605: ST_TO_ADDR
// end ;
81606: LD_VAR 0 3
81610: RET
// export function HealTarget ( sci ) ; begin
81611: LD_INT 0
81613: PPUSH
// if not sci then
81614: LD_VAR 0 1
81618: NOT
81619: IFFALSE 81623
// exit ;
81621: GO 81688
// result := 0 ;
81623: LD_ADDR_VAR 0 2
81627: PUSH
81628: LD_INT 0
81630: ST_TO_ADDR
// if GetTaskList ( sci ) then
81631: LD_VAR 0 1
81635: PPUSH
81636: CALL_OW 437
81640: IFFALSE 81688
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
81642: LD_VAR 0 1
81646: PPUSH
81647: CALL_OW 437
81651: PUSH
81652: LD_INT 1
81654: ARRAY
81655: PUSH
81656: LD_INT 1
81658: ARRAY
81659: PUSH
81660: LD_STRING l
81662: EQUAL
81663: IFFALSE 81688
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
81665: LD_ADDR_VAR 0 2
81669: PUSH
81670: LD_VAR 0 1
81674: PPUSH
81675: CALL_OW 437
81679: PUSH
81680: LD_INT 1
81682: ARRAY
81683: PUSH
81684: LD_INT 4
81686: ARRAY
81687: ST_TO_ADDR
// end ;
81688: LD_VAR 0 2
81692: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
81693: LD_INT 0
81695: PPUSH
81696: PPUSH
81697: PPUSH
81698: PPUSH
// if not base_units then
81699: LD_VAR 0 1
81703: NOT
81704: IFFALSE 81708
// exit ;
81706: GO 81795
// result := false ;
81708: LD_ADDR_VAR 0 2
81712: PUSH
81713: LD_INT 0
81715: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
81716: LD_ADDR_VAR 0 5
81720: PUSH
81721: LD_VAR 0 1
81725: PPUSH
81726: LD_INT 21
81728: PUSH
81729: LD_INT 3
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: PPUSH
81736: CALL_OW 72
81740: ST_TO_ADDR
// if not tmp then
81741: LD_VAR 0 5
81745: NOT
81746: IFFALSE 81750
// exit ;
81748: GO 81795
// for i in tmp do
81750: LD_ADDR_VAR 0 3
81754: PUSH
81755: LD_VAR 0 5
81759: PUSH
81760: FOR_IN
81761: IFFALSE 81793
// begin result := EnemyInRange ( i , 22 ) ;
81763: LD_ADDR_VAR 0 2
81767: PUSH
81768: LD_VAR 0 3
81772: PPUSH
81773: LD_INT 22
81775: PPUSH
81776: CALL 80031 0 2
81780: ST_TO_ADDR
// if result then
81781: LD_VAR 0 2
81785: IFFALSE 81791
// exit ;
81787: POP
81788: POP
81789: GO 81795
// end ;
81791: GO 81760
81793: POP
81794: POP
// end ;
81795: LD_VAR 0 2
81799: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
81800: LD_INT 0
81802: PPUSH
81803: PPUSH
// if not units then
81804: LD_VAR 0 1
81808: NOT
81809: IFFALSE 81813
// exit ;
81811: GO 81883
// result := [ ] ;
81813: LD_ADDR_VAR 0 3
81817: PUSH
81818: EMPTY
81819: ST_TO_ADDR
// for i in units do
81820: LD_ADDR_VAR 0 4
81824: PUSH
81825: LD_VAR 0 1
81829: PUSH
81830: FOR_IN
81831: IFFALSE 81881
// if GetTag ( i ) = tag then
81833: LD_VAR 0 4
81837: PPUSH
81838: CALL_OW 110
81842: PUSH
81843: LD_VAR 0 2
81847: EQUAL
81848: IFFALSE 81879
// result := Insert ( result , result + 1 , i ) ;
81850: LD_ADDR_VAR 0 3
81854: PUSH
81855: LD_VAR 0 3
81859: PPUSH
81860: LD_VAR 0 3
81864: PUSH
81865: LD_INT 1
81867: PLUS
81868: PPUSH
81869: LD_VAR 0 4
81873: PPUSH
81874: CALL_OW 2
81878: ST_TO_ADDR
81879: GO 81830
81881: POP
81882: POP
// end ;
81883: LD_VAR 0 3
81887: RET
// export function IsDriver ( un ) ; begin
81888: LD_INT 0
81890: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
81891: LD_ADDR_VAR 0 2
81895: PUSH
81896: LD_VAR 0 1
81900: PUSH
81901: LD_INT 55
81903: PUSH
81904: EMPTY
81905: LIST
81906: PPUSH
81907: CALL_OW 69
81911: IN
81912: ST_TO_ADDR
// end ;
81913: LD_VAR 0 2
81917: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
81918: LD_INT 0
81920: PPUSH
81921: PPUSH
// list := [ ] ;
81922: LD_ADDR_VAR 0 5
81926: PUSH
81927: EMPTY
81928: ST_TO_ADDR
// case d of 0 :
81929: LD_VAR 0 3
81933: PUSH
81934: LD_INT 0
81936: DOUBLE
81937: EQUAL
81938: IFTRUE 81942
81940: GO 82075
81942: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
81943: LD_ADDR_VAR 0 5
81947: PUSH
81948: LD_VAR 0 1
81952: PUSH
81953: LD_INT 4
81955: MINUS
81956: PUSH
81957: LD_VAR 0 2
81961: PUSH
81962: LD_INT 4
81964: MINUS
81965: PUSH
81966: LD_INT 2
81968: PUSH
81969: EMPTY
81970: LIST
81971: LIST
81972: LIST
81973: PUSH
81974: LD_VAR 0 1
81978: PUSH
81979: LD_INT 3
81981: MINUS
81982: PUSH
81983: LD_VAR 0 2
81987: PUSH
81988: LD_INT 1
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: LIST
81995: PUSH
81996: LD_VAR 0 1
82000: PUSH
82001: LD_INT 4
82003: PLUS
82004: PUSH
82005: LD_VAR 0 2
82009: PUSH
82010: LD_INT 4
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: LIST
82017: PUSH
82018: LD_VAR 0 1
82022: PUSH
82023: LD_INT 3
82025: PLUS
82026: PUSH
82027: LD_VAR 0 2
82031: PUSH
82032: LD_INT 3
82034: PLUS
82035: PUSH
82036: LD_INT 5
82038: PUSH
82039: EMPTY
82040: LIST
82041: LIST
82042: LIST
82043: PUSH
82044: LD_VAR 0 1
82048: PUSH
82049: LD_VAR 0 2
82053: PUSH
82054: LD_INT 4
82056: PLUS
82057: PUSH
82058: LD_INT 0
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: LIST
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: LIST
82070: LIST
82071: LIST
82072: ST_TO_ADDR
// end ; 1 :
82073: GO 82773
82075: LD_INT 1
82077: DOUBLE
82078: EQUAL
82079: IFTRUE 82083
82081: GO 82216
82083: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
82084: LD_ADDR_VAR 0 5
82088: PUSH
82089: LD_VAR 0 1
82093: PUSH
82094: LD_VAR 0 2
82098: PUSH
82099: LD_INT 4
82101: MINUS
82102: PUSH
82103: LD_INT 3
82105: PUSH
82106: EMPTY
82107: LIST
82108: LIST
82109: LIST
82110: PUSH
82111: LD_VAR 0 1
82115: PUSH
82116: LD_INT 3
82118: MINUS
82119: PUSH
82120: LD_VAR 0 2
82124: PUSH
82125: LD_INT 3
82127: MINUS
82128: PUSH
82129: LD_INT 2
82131: PUSH
82132: EMPTY
82133: LIST
82134: LIST
82135: LIST
82136: PUSH
82137: LD_VAR 0 1
82141: PUSH
82142: LD_INT 4
82144: MINUS
82145: PUSH
82146: LD_VAR 0 2
82150: PUSH
82151: LD_INT 1
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: LIST
82158: PUSH
82159: LD_VAR 0 1
82163: PUSH
82164: LD_VAR 0 2
82168: PUSH
82169: LD_INT 3
82171: PLUS
82172: PUSH
82173: LD_INT 0
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: LIST
82180: PUSH
82181: LD_VAR 0 1
82185: PUSH
82186: LD_INT 4
82188: PLUS
82189: PUSH
82190: LD_VAR 0 2
82194: PUSH
82195: LD_INT 4
82197: PLUS
82198: PUSH
82199: LD_INT 5
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: LIST
82206: PUSH
82207: EMPTY
82208: LIST
82209: LIST
82210: LIST
82211: LIST
82212: LIST
82213: ST_TO_ADDR
// end ; 2 :
82214: GO 82773
82216: LD_INT 2
82218: DOUBLE
82219: EQUAL
82220: IFTRUE 82224
82222: GO 82353
82224: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
82225: LD_ADDR_VAR 0 5
82229: PUSH
82230: LD_VAR 0 1
82234: PUSH
82235: LD_VAR 0 2
82239: PUSH
82240: LD_INT 3
82242: MINUS
82243: PUSH
82244: LD_INT 3
82246: PUSH
82247: EMPTY
82248: LIST
82249: LIST
82250: LIST
82251: PUSH
82252: LD_VAR 0 1
82256: PUSH
82257: LD_INT 4
82259: PLUS
82260: PUSH
82261: LD_VAR 0 2
82265: PUSH
82266: LD_INT 4
82268: PUSH
82269: EMPTY
82270: LIST
82271: LIST
82272: LIST
82273: PUSH
82274: LD_VAR 0 1
82278: PUSH
82279: LD_VAR 0 2
82283: PUSH
82284: LD_INT 4
82286: PLUS
82287: PUSH
82288: LD_INT 0
82290: PUSH
82291: EMPTY
82292: LIST
82293: LIST
82294: LIST
82295: PUSH
82296: LD_VAR 0 1
82300: PUSH
82301: LD_INT 3
82303: MINUS
82304: PUSH
82305: LD_VAR 0 2
82309: PUSH
82310: LD_INT 1
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: LIST
82317: PUSH
82318: LD_VAR 0 1
82322: PUSH
82323: LD_INT 4
82325: MINUS
82326: PUSH
82327: LD_VAR 0 2
82331: PUSH
82332: LD_INT 4
82334: MINUS
82335: PUSH
82336: LD_INT 2
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: LIST
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: LIST
82348: LIST
82349: LIST
82350: ST_TO_ADDR
// end ; 3 :
82351: GO 82773
82353: LD_INT 3
82355: DOUBLE
82356: EQUAL
82357: IFTRUE 82361
82359: GO 82494
82361: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
82362: LD_ADDR_VAR 0 5
82366: PUSH
82367: LD_VAR 0 1
82371: PUSH
82372: LD_INT 3
82374: PLUS
82375: PUSH
82376: LD_VAR 0 2
82380: PUSH
82381: LD_INT 4
82383: PUSH
82384: EMPTY
82385: LIST
82386: LIST
82387: LIST
82388: PUSH
82389: LD_VAR 0 1
82393: PUSH
82394: LD_INT 4
82396: PLUS
82397: PUSH
82398: LD_VAR 0 2
82402: PUSH
82403: LD_INT 4
82405: PLUS
82406: PUSH
82407: LD_INT 5
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: LIST
82414: PUSH
82415: LD_VAR 0 1
82419: PUSH
82420: LD_INT 4
82422: MINUS
82423: PUSH
82424: LD_VAR 0 2
82428: PUSH
82429: LD_INT 1
82431: PUSH
82432: EMPTY
82433: LIST
82434: LIST
82435: LIST
82436: PUSH
82437: LD_VAR 0 1
82441: PUSH
82442: LD_VAR 0 2
82446: PUSH
82447: LD_INT 4
82449: MINUS
82450: PUSH
82451: LD_INT 3
82453: PUSH
82454: EMPTY
82455: LIST
82456: LIST
82457: LIST
82458: PUSH
82459: LD_VAR 0 1
82463: PUSH
82464: LD_INT 3
82466: MINUS
82467: PUSH
82468: LD_VAR 0 2
82472: PUSH
82473: LD_INT 3
82475: MINUS
82476: PUSH
82477: LD_INT 2
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: LIST
82484: PUSH
82485: EMPTY
82486: LIST
82487: LIST
82488: LIST
82489: LIST
82490: LIST
82491: ST_TO_ADDR
// end ; 4 :
82492: GO 82773
82494: LD_INT 4
82496: DOUBLE
82497: EQUAL
82498: IFTRUE 82502
82500: GO 82635
82502: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
82503: LD_ADDR_VAR 0 5
82507: PUSH
82508: LD_VAR 0 1
82512: PUSH
82513: LD_VAR 0 2
82517: PUSH
82518: LD_INT 4
82520: PLUS
82521: PUSH
82522: LD_INT 0
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: LIST
82529: PUSH
82530: LD_VAR 0 1
82534: PUSH
82535: LD_INT 3
82537: PLUS
82538: PUSH
82539: LD_VAR 0 2
82543: PUSH
82544: LD_INT 3
82546: PLUS
82547: PUSH
82548: LD_INT 5
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: LIST
82555: PUSH
82556: LD_VAR 0 1
82560: PUSH
82561: LD_INT 4
82563: PLUS
82564: PUSH
82565: LD_VAR 0 2
82569: PUSH
82570: LD_INT 4
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: LIST
82577: PUSH
82578: LD_VAR 0 1
82582: PUSH
82583: LD_VAR 0 2
82587: PUSH
82588: LD_INT 3
82590: MINUS
82591: PUSH
82592: LD_INT 3
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: LIST
82599: PUSH
82600: LD_VAR 0 1
82604: PUSH
82605: LD_INT 4
82607: MINUS
82608: PUSH
82609: LD_VAR 0 2
82613: PUSH
82614: LD_INT 4
82616: MINUS
82617: PUSH
82618: LD_INT 2
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: LIST
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: LIST
82630: LIST
82631: LIST
82632: ST_TO_ADDR
// end ; 5 :
82633: GO 82773
82635: LD_INT 5
82637: DOUBLE
82638: EQUAL
82639: IFTRUE 82643
82641: GO 82772
82643: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
82644: LD_ADDR_VAR 0 5
82648: PUSH
82649: LD_VAR 0 1
82653: PUSH
82654: LD_INT 4
82656: MINUS
82657: PUSH
82658: LD_VAR 0 2
82662: PUSH
82663: LD_INT 1
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: LIST
82670: PUSH
82671: LD_VAR 0 1
82675: PUSH
82676: LD_VAR 0 2
82680: PUSH
82681: LD_INT 4
82683: MINUS
82684: PUSH
82685: LD_INT 3
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: LIST
82692: PUSH
82693: LD_VAR 0 1
82697: PUSH
82698: LD_INT 4
82700: PLUS
82701: PUSH
82702: LD_VAR 0 2
82706: PUSH
82707: LD_INT 4
82709: PLUS
82710: PUSH
82711: LD_INT 5
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: LIST
82718: PUSH
82719: LD_VAR 0 1
82723: PUSH
82724: LD_INT 3
82726: PLUS
82727: PUSH
82728: LD_VAR 0 2
82732: PUSH
82733: LD_INT 4
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: LIST
82740: PUSH
82741: LD_VAR 0 1
82745: PUSH
82746: LD_VAR 0 2
82750: PUSH
82751: LD_INT 3
82753: PLUS
82754: PUSH
82755: LD_INT 0
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: LIST
82762: PUSH
82763: EMPTY
82764: LIST
82765: LIST
82766: LIST
82767: LIST
82768: LIST
82769: ST_TO_ADDR
// end ; end ;
82770: GO 82773
82772: POP
// result := list ;
82773: LD_ADDR_VAR 0 4
82777: PUSH
82778: LD_VAR 0 5
82782: ST_TO_ADDR
// end ;
82783: LD_VAR 0 4
82787: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
82788: LD_INT 0
82790: PPUSH
82791: PPUSH
82792: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
82793: LD_VAR 0 1
82797: NOT
82798: PUSH
82799: LD_VAR 0 2
82803: PUSH
82804: LD_INT 1
82806: PUSH
82807: LD_INT 2
82809: PUSH
82810: LD_INT 3
82812: PUSH
82813: LD_INT 4
82815: PUSH
82816: EMPTY
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: IN
82822: NOT
82823: OR
82824: IFFALSE 82828
// exit ;
82826: GO 82920
// tmp := [ ] ;
82828: LD_ADDR_VAR 0 5
82832: PUSH
82833: EMPTY
82834: ST_TO_ADDR
// for i in units do
82835: LD_ADDR_VAR 0 4
82839: PUSH
82840: LD_VAR 0 1
82844: PUSH
82845: FOR_IN
82846: IFFALSE 82889
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
82848: LD_ADDR_VAR 0 5
82852: PUSH
82853: LD_VAR 0 5
82857: PPUSH
82858: LD_VAR 0 5
82862: PUSH
82863: LD_INT 1
82865: PLUS
82866: PPUSH
82867: LD_VAR 0 4
82871: PPUSH
82872: LD_VAR 0 2
82876: PPUSH
82877: CALL_OW 259
82881: PPUSH
82882: CALL_OW 2
82886: ST_TO_ADDR
82887: GO 82845
82889: POP
82890: POP
// if not tmp then
82891: LD_VAR 0 5
82895: NOT
82896: IFFALSE 82900
// exit ;
82898: GO 82920
// result := SortListByListDesc ( units , tmp ) ;
82900: LD_ADDR_VAR 0 3
82904: PUSH
82905: LD_VAR 0 1
82909: PPUSH
82910: LD_VAR 0 5
82914: PPUSH
82915: CALL_OW 77
82919: ST_TO_ADDR
// end ;
82920: LD_VAR 0 3
82924: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
82925: LD_INT 0
82927: PPUSH
82928: PPUSH
82929: PPUSH
// result := false ;
82930: LD_ADDR_VAR 0 3
82934: PUSH
82935: LD_INT 0
82937: ST_TO_ADDR
// x := GetX ( building ) ;
82938: LD_ADDR_VAR 0 4
82942: PUSH
82943: LD_VAR 0 2
82947: PPUSH
82948: CALL_OW 250
82952: ST_TO_ADDR
// y := GetY ( building ) ;
82953: LD_ADDR_VAR 0 5
82957: PUSH
82958: LD_VAR 0 2
82962: PPUSH
82963: CALL_OW 251
82967: ST_TO_ADDR
// if not building or not x or not y then
82968: LD_VAR 0 2
82972: NOT
82973: PUSH
82974: LD_VAR 0 4
82978: NOT
82979: OR
82980: PUSH
82981: LD_VAR 0 5
82985: NOT
82986: OR
82987: IFFALSE 82991
// exit ;
82989: GO 83083
// if GetTaskList ( unit ) then
82991: LD_VAR 0 1
82995: PPUSH
82996: CALL_OW 437
83000: IFFALSE 83083
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
83002: LD_STRING e
83004: PUSH
83005: LD_VAR 0 1
83009: PPUSH
83010: CALL_OW 437
83014: PUSH
83015: LD_INT 1
83017: ARRAY
83018: PUSH
83019: LD_INT 1
83021: ARRAY
83022: EQUAL
83023: PUSH
83024: LD_VAR 0 4
83028: PUSH
83029: LD_VAR 0 1
83033: PPUSH
83034: CALL_OW 437
83038: PUSH
83039: LD_INT 1
83041: ARRAY
83042: PUSH
83043: LD_INT 2
83045: ARRAY
83046: EQUAL
83047: AND
83048: PUSH
83049: LD_VAR 0 5
83053: PUSH
83054: LD_VAR 0 1
83058: PPUSH
83059: CALL_OW 437
83063: PUSH
83064: LD_INT 1
83066: ARRAY
83067: PUSH
83068: LD_INT 3
83070: ARRAY
83071: EQUAL
83072: AND
83073: IFFALSE 83083
// result := true end ;
83075: LD_ADDR_VAR 0 3
83079: PUSH
83080: LD_INT 1
83082: ST_TO_ADDR
// end ;
83083: LD_VAR 0 3
83087: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
83088: LD_INT 0
83090: PPUSH
// result := false ;
83091: LD_ADDR_VAR 0 4
83095: PUSH
83096: LD_INT 0
83098: ST_TO_ADDR
// if GetTaskList ( unit ) then
83099: LD_VAR 0 1
83103: PPUSH
83104: CALL_OW 437
83108: IFFALSE 83191
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
83110: LD_STRING M
83112: PUSH
83113: LD_VAR 0 1
83117: PPUSH
83118: CALL_OW 437
83122: PUSH
83123: LD_INT 1
83125: ARRAY
83126: PUSH
83127: LD_INT 1
83129: ARRAY
83130: EQUAL
83131: PUSH
83132: LD_VAR 0 2
83136: PUSH
83137: LD_VAR 0 1
83141: PPUSH
83142: CALL_OW 437
83146: PUSH
83147: LD_INT 1
83149: ARRAY
83150: PUSH
83151: LD_INT 2
83153: ARRAY
83154: EQUAL
83155: AND
83156: PUSH
83157: LD_VAR 0 3
83161: PUSH
83162: LD_VAR 0 1
83166: PPUSH
83167: CALL_OW 437
83171: PUSH
83172: LD_INT 1
83174: ARRAY
83175: PUSH
83176: LD_INT 3
83178: ARRAY
83179: EQUAL
83180: AND
83181: IFFALSE 83191
// result := true ;
83183: LD_ADDR_VAR 0 4
83187: PUSH
83188: LD_INT 1
83190: ST_TO_ADDR
// end ; end ;
83191: LD_VAR 0 4
83195: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
83196: LD_INT 0
83198: PPUSH
83199: PPUSH
83200: PPUSH
83201: PPUSH
// if not unit or not area then
83202: LD_VAR 0 1
83206: NOT
83207: PUSH
83208: LD_VAR 0 2
83212: NOT
83213: OR
83214: IFFALSE 83218
// exit ;
83216: GO 83382
// tmp := AreaToList ( area , i ) ;
83218: LD_ADDR_VAR 0 6
83222: PUSH
83223: LD_VAR 0 2
83227: PPUSH
83228: LD_VAR 0 5
83232: PPUSH
83233: CALL_OW 517
83237: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
83238: LD_ADDR_VAR 0 5
83242: PUSH
83243: DOUBLE
83244: LD_INT 1
83246: DEC
83247: ST_TO_ADDR
83248: LD_VAR 0 6
83252: PUSH
83253: LD_INT 1
83255: ARRAY
83256: PUSH
83257: FOR_TO
83258: IFFALSE 83380
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
83260: LD_ADDR_VAR 0 7
83264: PUSH
83265: LD_VAR 0 6
83269: PUSH
83270: LD_INT 1
83272: ARRAY
83273: PUSH
83274: LD_VAR 0 5
83278: ARRAY
83279: PUSH
83280: LD_VAR 0 6
83284: PUSH
83285: LD_INT 2
83287: ARRAY
83288: PUSH
83289: LD_VAR 0 5
83293: ARRAY
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
83299: LD_VAR 0 7
83303: PUSH
83304: LD_INT 1
83306: ARRAY
83307: PPUSH
83308: LD_VAR 0 7
83312: PUSH
83313: LD_INT 2
83315: ARRAY
83316: PPUSH
83317: CALL_OW 428
83321: PUSH
83322: LD_INT 0
83324: EQUAL
83325: IFFALSE 83378
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
83327: LD_VAR 0 1
83331: PPUSH
83332: LD_VAR 0 7
83336: PUSH
83337: LD_INT 1
83339: ARRAY
83340: PPUSH
83341: LD_VAR 0 7
83345: PUSH
83346: LD_INT 2
83348: ARRAY
83349: PPUSH
83350: LD_VAR 0 3
83354: PPUSH
83355: CALL_OW 48
// result := IsPlaced ( unit ) ;
83359: LD_ADDR_VAR 0 4
83363: PUSH
83364: LD_VAR 0 1
83368: PPUSH
83369: CALL_OW 305
83373: ST_TO_ADDR
// exit ;
83374: POP
83375: POP
83376: GO 83382
// end ; end ;
83378: GO 83257
83380: POP
83381: POP
// end ;
83382: LD_VAR 0 4
83386: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
83387: LD_INT 0
83389: PPUSH
83390: PPUSH
83391: PPUSH
// if not side or side > 8 then
83392: LD_VAR 0 1
83396: NOT
83397: PUSH
83398: LD_VAR 0 1
83402: PUSH
83403: LD_INT 8
83405: GREATER
83406: OR
83407: IFFALSE 83411
// exit ;
83409: GO 83598
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
83411: LD_ADDR_VAR 0 4
83415: PUSH
83416: LD_INT 22
83418: PUSH
83419: LD_VAR 0 1
83423: PUSH
83424: EMPTY
83425: LIST
83426: LIST
83427: PUSH
83428: LD_INT 21
83430: PUSH
83431: LD_INT 3
83433: PUSH
83434: EMPTY
83435: LIST
83436: LIST
83437: PUSH
83438: EMPTY
83439: LIST
83440: LIST
83441: PPUSH
83442: CALL_OW 69
83446: ST_TO_ADDR
// if not tmp then
83447: LD_VAR 0 4
83451: NOT
83452: IFFALSE 83456
// exit ;
83454: GO 83598
// enable_addtolog := true ;
83456: LD_ADDR_OWVAR 81
83460: PUSH
83461: LD_INT 1
83463: ST_TO_ADDR
// AddToLog ( [ ) ;
83464: LD_STRING [
83466: PPUSH
83467: CALL_OW 561
// for i in tmp do
83471: LD_ADDR_VAR 0 3
83475: PUSH
83476: LD_VAR 0 4
83480: PUSH
83481: FOR_IN
83482: IFFALSE 83589
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
83484: LD_STRING [
83486: PUSH
83487: LD_VAR 0 3
83491: PPUSH
83492: CALL_OW 266
83496: STR
83497: PUSH
83498: LD_STRING , 
83500: STR
83501: PUSH
83502: LD_VAR 0 3
83506: PPUSH
83507: CALL_OW 250
83511: STR
83512: PUSH
83513: LD_STRING , 
83515: STR
83516: PUSH
83517: LD_VAR 0 3
83521: PPUSH
83522: CALL_OW 251
83526: STR
83527: PUSH
83528: LD_STRING , 
83530: STR
83531: PUSH
83532: LD_VAR 0 3
83536: PPUSH
83537: CALL_OW 254
83541: STR
83542: PUSH
83543: LD_STRING , 
83545: STR
83546: PUSH
83547: LD_VAR 0 3
83551: PPUSH
83552: LD_INT 1
83554: PPUSH
83555: CALL_OW 268
83559: STR
83560: PUSH
83561: LD_STRING , 
83563: STR
83564: PUSH
83565: LD_VAR 0 3
83569: PPUSH
83570: LD_INT 2
83572: PPUSH
83573: CALL_OW 268
83577: STR
83578: PUSH
83579: LD_STRING ],
83581: STR
83582: PPUSH
83583: CALL_OW 561
// end ;
83587: GO 83481
83589: POP
83590: POP
// AddToLog ( ]; ) ;
83591: LD_STRING ];
83593: PPUSH
83594: CALL_OW 561
// end ;
83598: LD_VAR 0 2
83602: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
83603: LD_INT 0
83605: PPUSH
83606: PPUSH
83607: PPUSH
83608: PPUSH
83609: PPUSH
// if not area or not rate or not max then
83610: LD_VAR 0 1
83614: NOT
83615: PUSH
83616: LD_VAR 0 2
83620: NOT
83621: OR
83622: PUSH
83623: LD_VAR 0 4
83627: NOT
83628: OR
83629: IFFALSE 83633
// exit ;
83631: GO 83825
// while 1 do
83633: LD_INT 1
83635: IFFALSE 83825
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
83637: LD_ADDR_VAR 0 9
83641: PUSH
83642: LD_VAR 0 1
83646: PPUSH
83647: LD_INT 1
83649: PPUSH
83650: CALL_OW 287
83654: PUSH
83655: LD_INT 10
83657: MUL
83658: ST_TO_ADDR
// r := rate / 10 ;
83659: LD_ADDR_VAR 0 7
83663: PUSH
83664: LD_VAR 0 2
83668: PUSH
83669: LD_INT 10
83671: DIVREAL
83672: ST_TO_ADDR
// time := 1 1$00 ;
83673: LD_ADDR_VAR 0 8
83677: PUSH
83678: LD_INT 2100
83680: ST_TO_ADDR
// if amount < min then
83681: LD_VAR 0 9
83685: PUSH
83686: LD_VAR 0 3
83690: LESS
83691: IFFALSE 83709
// r := r * 2 else
83693: LD_ADDR_VAR 0 7
83697: PUSH
83698: LD_VAR 0 7
83702: PUSH
83703: LD_INT 2
83705: MUL
83706: ST_TO_ADDR
83707: GO 83735
// if amount > max then
83709: LD_VAR 0 9
83713: PUSH
83714: LD_VAR 0 4
83718: GREATER
83719: IFFALSE 83735
// r := r / 2 ;
83721: LD_ADDR_VAR 0 7
83725: PUSH
83726: LD_VAR 0 7
83730: PUSH
83731: LD_INT 2
83733: DIVREAL
83734: ST_TO_ADDR
// time := time / r ;
83735: LD_ADDR_VAR 0 8
83739: PUSH
83740: LD_VAR 0 8
83744: PUSH
83745: LD_VAR 0 7
83749: DIVREAL
83750: ST_TO_ADDR
// if time < 0 then
83751: LD_VAR 0 8
83755: PUSH
83756: LD_INT 0
83758: LESS
83759: IFFALSE 83776
// time := time * - 1 ;
83761: LD_ADDR_VAR 0 8
83765: PUSH
83766: LD_VAR 0 8
83770: PUSH
83771: LD_INT 1
83773: NEG
83774: MUL
83775: ST_TO_ADDR
// wait ( time ) ;
83776: LD_VAR 0 8
83780: PPUSH
83781: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
83785: LD_INT 35
83787: PPUSH
83788: LD_INT 875
83790: PPUSH
83791: CALL_OW 12
83795: PPUSH
83796: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
83800: LD_INT 1
83802: PPUSH
83803: LD_INT 5
83805: PPUSH
83806: CALL_OW 12
83810: PPUSH
83811: LD_VAR 0 1
83815: PPUSH
83816: LD_INT 1
83818: PPUSH
83819: CALL_OW 55
// end ;
83823: GO 83633
// end ;
83825: LD_VAR 0 5
83829: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
83830: LD_INT 0
83832: PPUSH
83833: PPUSH
83834: PPUSH
83835: PPUSH
83836: PPUSH
83837: PPUSH
83838: PPUSH
83839: PPUSH
// if not turrets or not factories then
83840: LD_VAR 0 1
83844: NOT
83845: PUSH
83846: LD_VAR 0 2
83850: NOT
83851: OR
83852: IFFALSE 83856
// exit ;
83854: GO 84163
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
83856: LD_ADDR_VAR 0 10
83860: PUSH
83861: LD_INT 5
83863: PUSH
83864: LD_INT 6
83866: PUSH
83867: EMPTY
83868: LIST
83869: LIST
83870: PUSH
83871: LD_INT 2
83873: PUSH
83874: LD_INT 4
83876: PUSH
83877: EMPTY
83878: LIST
83879: LIST
83880: PUSH
83881: LD_INT 3
83883: PUSH
83884: LD_INT 5
83886: PUSH
83887: EMPTY
83888: LIST
83889: LIST
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: LIST
83895: PUSH
83896: LD_INT 24
83898: PUSH
83899: LD_INT 25
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: PUSH
83906: LD_INT 23
83908: PUSH
83909: LD_INT 27
83911: PUSH
83912: EMPTY
83913: LIST
83914: LIST
83915: PUSH
83916: EMPTY
83917: LIST
83918: LIST
83919: PUSH
83920: LD_INT 42
83922: PUSH
83923: LD_INT 43
83925: PUSH
83926: EMPTY
83927: LIST
83928: LIST
83929: PUSH
83930: LD_INT 44
83932: PUSH
83933: LD_INT 46
83935: PUSH
83936: EMPTY
83937: LIST
83938: LIST
83939: PUSH
83940: LD_INT 45
83942: PUSH
83943: LD_INT 47
83945: PUSH
83946: EMPTY
83947: LIST
83948: LIST
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: LIST
83954: PUSH
83955: EMPTY
83956: LIST
83957: LIST
83958: LIST
83959: ST_TO_ADDR
// result := [ ] ;
83960: LD_ADDR_VAR 0 3
83964: PUSH
83965: EMPTY
83966: ST_TO_ADDR
// for i in turrets do
83967: LD_ADDR_VAR 0 4
83971: PUSH
83972: LD_VAR 0 1
83976: PUSH
83977: FOR_IN
83978: IFFALSE 84161
// begin nat := GetNation ( i ) ;
83980: LD_ADDR_VAR 0 7
83984: PUSH
83985: LD_VAR 0 4
83989: PPUSH
83990: CALL_OW 248
83994: ST_TO_ADDR
// weapon := 0 ;
83995: LD_ADDR_VAR 0 8
83999: PUSH
84000: LD_INT 0
84002: ST_TO_ADDR
// if not nat then
84003: LD_VAR 0 7
84007: NOT
84008: IFFALSE 84012
// continue ;
84010: GO 83977
// for j in list [ nat ] do
84012: LD_ADDR_VAR 0 5
84016: PUSH
84017: LD_VAR 0 10
84021: PUSH
84022: LD_VAR 0 7
84026: ARRAY
84027: PUSH
84028: FOR_IN
84029: IFFALSE 84070
// if GetBWeapon ( i ) = j [ 1 ] then
84031: LD_VAR 0 4
84035: PPUSH
84036: CALL_OW 269
84040: PUSH
84041: LD_VAR 0 5
84045: PUSH
84046: LD_INT 1
84048: ARRAY
84049: EQUAL
84050: IFFALSE 84068
// begin weapon := j [ 2 ] ;
84052: LD_ADDR_VAR 0 8
84056: PUSH
84057: LD_VAR 0 5
84061: PUSH
84062: LD_INT 2
84064: ARRAY
84065: ST_TO_ADDR
// break ;
84066: GO 84070
// end ;
84068: GO 84028
84070: POP
84071: POP
// if not weapon then
84072: LD_VAR 0 8
84076: NOT
84077: IFFALSE 84081
// continue ;
84079: GO 83977
// for k in factories do
84081: LD_ADDR_VAR 0 6
84085: PUSH
84086: LD_VAR 0 2
84090: PUSH
84091: FOR_IN
84092: IFFALSE 84157
// begin weapons := AvailableWeaponList ( k ) ;
84094: LD_ADDR_VAR 0 9
84098: PUSH
84099: LD_VAR 0 6
84103: PPUSH
84104: CALL_OW 478
84108: ST_TO_ADDR
// if not weapons then
84109: LD_VAR 0 9
84113: NOT
84114: IFFALSE 84118
// continue ;
84116: GO 84091
// if weapon in weapons then
84118: LD_VAR 0 8
84122: PUSH
84123: LD_VAR 0 9
84127: IN
84128: IFFALSE 84155
// begin result := [ i , weapon ] ;
84130: LD_ADDR_VAR 0 3
84134: PUSH
84135: LD_VAR 0 4
84139: PUSH
84140: LD_VAR 0 8
84144: PUSH
84145: EMPTY
84146: LIST
84147: LIST
84148: ST_TO_ADDR
// exit ;
84149: POP
84150: POP
84151: POP
84152: POP
84153: GO 84163
// end ; end ;
84155: GO 84091
84157: POP
84158: POP
// end ;
84159: GO 83977
84161: POP
84162: POP
// end ;
84163: LD_VAR 0 3
84167: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
84168: LD_INT 0
84170: PPUSH
// if not side or side > 8 then
84171: LD_VAR 0 3
84175: NOT
84176: PUSH
84177: LD_VAR 0 3
84181: PUSH
84182: LD_INT 8
84184: GREATER
84185: OR
84186: IFFALSE 84190
// exit ;
84188: GO 84249
// if not range then
84190: LD_VAR 0 4
84194: NOT
84195: IFFALSE 84206
// range := - 12 ;
84197: LD_ADDR_VAR 0 4
84201: PUSH
84202: LD_INT 12
84204: NEG
84205: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
84206: LD_VAR 0 1
84210: PPUSH
84211: LD_VAR 0 2
84215: PPUSH
84216: LD_VAR 0 3
84220: PPUSH
84221: LD_VAR 0 4
84225: PPUSH
84226: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
84230: LD_VAR 0 1
84234: PPUSH
84235: LD_VAR 0 2
84239: PPUSH
84240: LD_VAR 0 3
84244: PPUSH
84245: CALL_OW 331
// end ;
84249: LD_VAR 0 5
84253: RET
// export function Video ( mode ) ; begin
84254: LD_INT 0
84256: PPUSH
// ingame_video = mode ;
84257: LD_ADDR_OWVAR 52
84261: PUSH
84262: LD_VAR 0 1
84266: ST_TO_ADDR
// interface_hidden = mode ;
84267: LD_ADDR_OWVAR 54
84271: PUSH
84272: LD_VAR 0 1
84276: ST_TO_ADDR
// end ;
84277: LD_VAR 0 2
84281: RET
// export function Join ( array , element ) ; begin
84282: LD_INT 0
84284: PPUSH
// result := Replace ( array , array + 1 , element ) ;
84285: LD_ADDR_VAR 0 3
84289: PUSH
84290: LD_VAR 0 1
84294: PPUSH
84295: LD_VAR 0 1
84299: PUSH
84300: LD_INT 1
84302: PLUS
84303: PPUSH
84304: LD_VAR 0 2
84308: PPUSH
84309: CALL_OW 1
84313: ST_TO_ADDR
// end ;
84314: LD_VAR 0 3
84318: RET
// export function JoinUnion ( array , element ) ; begin
84319: LD_INT 0
84321: PPUSH
// result := array union element ;
84322: LD_ADDR_VAR 0 3
84326: PUSH
84327: LD_VAR 0 1
84331: PUSH
84332: LD_VAR 0 2
84336: UNION
84337: ST_TO_ADDR
// end ;
84338: LD_VAR 0 3
84342: RET
// export function GetBehemoths ( side ) ; begin
84343: LD_INT 0
84345: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
84346: LD_ADDR_VAR 0 2
84350: PUSH
84351: LD_INT 22
84353: PUSH
84354: LD_VAR 0 1
84358: PUSH
84359: EMPTY
84360: LIST
84361: LIST
84362: PUSH
84363: LD_INT 31
84365: PUSH
84366: LD_INT 25
84368: PUSH
84369: EMPTY
84370: LIST
84371: LIST
84372: PUSH
84373: EMPTY
84374: LIST
84375: LIST
84376: PPUSH
84377: CALL_OW 69
84381: ST_TO_ADDR
// end ;
84382: LD_VAR 0 2
84386: RET
// export function Shuffle ( array ) ; var i , index ; begin
84387: LD_INT 0
84389: PPUSH
84390: PPUSH
84391: PPUSH
// result := [ ] ;
84392: LD_ADDR_VAR 0 2
84396: PUSH
84397: EMPTY
84398: ST_TO_ADDR
// if not array then
84399: LD_VAR 0 1
84403: NOT
84404: IFFALSE 84408
// exit ;
84406: GO 84507
// Randomize ;
84408: CALL_OW 10
// for i = array downto 1 do
84412: LD_ADDR_VAR 0 3
84416: PUSH
84417: DOUBLE
84418: LD_VAR 0 1
84422: INC
84423: ST_TO_ADDR
84424: LD_INT 1
84426: PUSH
84427: FOR_DOWNTO
84428: IFFALSE 84505
// begin index := rand ( 1 , array ) ;
84430: LD_ADDR_VAR 0 4
84434: PUSH
84435: LD_INT 1
84437: PPUSH
84438: LD_VAR 0 1
84442: PPUSH
84443: CALL_OW 12
84447: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
84448: LD_ADDR_VAR 0 2
84452: PUSH
84453: LD_VAR 0 2
84457: PPUSH
84458: LD_VAR 0 2
84462: PUSH
84463: LD_INT 1
84465: PLUS
84466: PPUSH
84467: LD_VAR 0 1
84471: PUSH
84472: LD_VAR 0 4
84476: ARRAY
84477: PPUSH
84478: CALL_OW 2
84482: ST_TO_ADDR
// array := Delete ( array , index ) ;
84483: LD_ADDR_VAR 0 1
84487: PUSH
84488: LD_VAR 0 1
84492: PPUSH
84493: LD_VAR 0 4
84497: PPUSH
84498: CALL_OW 3
84502: ST_TO_ADDR
// end ;
84503: GO 84427
84505: POP
84506: POP
// end ;
84507: LD_VAR 0 2
84511: RET
// export function GetBaseMaterials ( base ) ; begin
84512: LD_INT 0
84514: PPUSH
// result := [ 0 , 0 , 0 ] ;
84515: LD_ADDR_VAR 0 2
84519: PUSH
84520: LD_INT 0
84522: PUSH
84523: LD_INT 0
84525: PUSH
84526: LD_INT 0
84528: PUSH
84529: EMPTY
84530: LIST
84531: LIST
84532: LIST
84533: ST_TO_ADDR
// if not base then
84534: LD_VAR 0 1
84538: NOT
84539: IFFALSE 84543
// exit ;
84541: GO 84592
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
84543: LD_ADDR_VAR 0 2
84547: PUSH
84548: LD_VAR 0 1
84552: PPUSH
84553: LD_INT 1
84555: PPUSH
84556: CALL_OW 275
84560: PUSH
84561: LD_VAR 0 1
84565: PPUSH
84566: LD_INT 2
84568: PPUSH
84569: CALL_OW 275
84573: PUSH
84574: LD_VAR 0 1
84578: PPUSH
84579: LD_INT 3
84581: PPUSH
84582: CALL_OW 275
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: LIST
84591: ST_TO_ADDR
// end ;
84592: LD_VAR 0 2
84596: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
84597: LD_INT 0
84599: PPUSH
84600: PPUSH
// result := array ;
84601: LD_ADDR_VAR 0 3
84605: PUSH
84606: LD_VAR 0 1
84610: ST_TO_ADDR
// if size > 0 then
84611: LD_VAR 0 2
84615: PUSH
84616: LD_INT 0
84618: GREATER
84619: IFFALSE 84665
// for i := array downto size do
84621: LD_ADDR_VAR 0 4
84625: PUSH
84626: DOUBLE
84627: LD_VAR 0 1
84631: INC
84632: ST_TO_ADDR
84633: LD_VAR 0 2
84637: PUSH
84638: FOR_DOWNTO
84639: IFFALSE 84663
// result := Delete ( result , result ) ;
84641: LD_ADDR_VAR 0 3
84645: PUSH
84646: LD_VAR 0 3
84650: PPUSH
84651: LD_VAR 0 3
84655: PPUSH
84656: CALL_OW 3
84660: ST_TO_ADDR
84661: GO 84638
84663: POP
84664: POP
// end ;
84665: LD_VAR 0 3
84669: RET
// export function ComExit ( unit ) ; var tmp ; begin
84670: LD_INT 0
84672: PPUSH
84673: PPUSH
// if not IsInUnit ( unit ) then
84674: LD_VAR 0 1
84678: PPUSH
84679: CALL_OW 310
84683: NOT
84684: IFFALSE 84688
// exit ;
84686: GO 84748
// tmp := IsInUnit ( unit ) ;
84688: LD_ADDR_VAR 0 3
84692: PUSH
84693: LD_VAR 0 1
84697: PPUSH
84698: CALL_OW 310
84702: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
84703: LD_VAR 0 3
84707: PPUSH
84708: CALL_OW 247
84712: PUSH
84713: LD_INT 2
84715: EQUAL
84716: IFFALSE 84729
// ComExitVehicle ( unit ) else
84718: LD_VAR 0 1
84722: PPUSH
84723: CALL_OW 121
84727: GO 84738
// ComExitBuilding ( unit ) ;
84729: LD_VAR 0 1
84733: PPUSH
84734: CALL_OW 122
// result := tmp ;
84738: LD_ADDR_VAR 0 2
84742: PUSH
84743: LD_VAR 0 3
84747: ST_TO_ADDR
// end ;
84748: LD_VAR 0 2
84752: RET
// export function ComExitAll ( units ) ; var i ; begin
84753: LD_INT 0
84755: PPUSH
84756: PPUSH
// if not units then
84757: LD_VAR 0 1
84761: NOT
84762: IFFALSE 84766
// exit ;
84764: GO 84792
// for i in units do
84766: LD_ADDR_VAR 0 3
84770: PUSH
84771: LD_VAR 0 1
84775: PUSH
84776: FOR_IN
84777: IFFALSE 84790
// ComExit ( i ) ;
84779: LD_VAR 0 3
84783: PPUSH
84784: CALL 84670 0 1
84788: GO 84776
84790: POP
84791: POP
// end ;
84792: LD_VAR 0 2
84796: RET
// export function ResetHc ; begin
84797: LD_INT 0
84799: PPUSH
// InitHc ;
84800: CALL_OW 19
// hc_importance := 0 ;
84804: LD_ADDR_OWVAR 32
84808: PUSH
84809: LD_INT 0
84811: ST_TO_ADDR
// end ;
84812: LD_VAR 0 1
84816: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
84817: LD_INT 0
84819: PPUSH
84820: PPUSH
84821: PPUSH
// _x := ( x1 + x2 ) div 2 ;
84822: LD_ADDR_VAR 0 6
84826: PUSH
84827: LD_VAR 0 1
84831: PUSH
84832: LD_VAR 0 3
84836: PLUS
84837: PUSH
84838: LD_INT 2
84840: DIV
84841: ST_TO_ADDR
// if _x < 0 then
84842: LD_VAR 0 6
84846: PUSH
84847: LD_INT 0
84849: LESS
84850: IFFALSE 84867
// _x := _x * - 1 ;
84852: LD_ADDR_VAR 0 6
84856: PUSH
84857: LD_VAR 0 6
84861: PUSH
84862: LD_INT 1
84864: NEG
84865: MUL
84866: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
84867: LD_ADDR_VAR 0 7
84871: PUSH
84872: LD_VAR 0 2
84876: PUSH
84877: LD_VAR 0 4
84881: PLUS
84882: PUSH
84883: LD_INT 2
84885: DIV
84886: ST_TO_ADDR
// if _y < 0 then
84887: LD_VAR 0 7
84891: PUSH
84892: LD_INT 0
84894: LESS
84895: IFFALSE 84912
// _y := _y * - 1 ;
84897: LD_ADDR_VAR 0 7
84901: PUSH
84902: LD_VAR 0 7
84906: PUSH
84907: LD_INT 1
84909: NEG
84910: MUL
84911: ST_TO_ADDR
// result := [ _x , _y ] ;
84912: LD_ADDR_VAR 0 5
84916: PUSH
84917: LD_VAR 0 6
84921: PUSH
84922: LD_VAR 0 7
84926: PUSH
84927: EMPTY
84928: LIST
84929: LIST
84930: ST_TO_ADDR
// end ;
84931: LD_VAR 0 5
84935: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
84936: LD_INT 0
84938: PPUSH
84939: PPUSH
84940: PPUSH
84941: PPUSH
// task := GetTaskList ( unit ) ;
84942: LD_ADDR_VAR 0 7
84946: PUSH
84947: LD_VAR 0 1
84951: PPUSH
84952: CALL_OW 437
84956: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
84957: LD_VAR 0 7
84961: NOT
84962: PUSH
84963: LD_VAR 0 1
84967: PPUSH
84968: LD_VAR 0 2
84972: PPUSH
84973: CALL_OW 308
84977: NOT
84978: AND
84979: IFFALSE 84983
// exit ;
84981: GO 85101
// if IsInArea ( unit , area ) then
84983: LD_VAR 0 1
84987: PPUSH
84988: LD_VAR 0 2
84992: PPUSH
84993: CALL_OW 308
84997: IFFALSE 85015
// begin ComMoveToArea ( unit , goAway ) ;
84999: LD_VAR 0 1
85003: PPUSH
85004: LD_VAR 0 3
85008: PPUSH
85009: CALL_OW 113
// exit ;
85013: GO 85101
// end ; if task [ 1 ] [ 1 ] <> M then
85015: LD_VAR 0 7
85019: PUSH
85020: LD_INT 1
85022: ARRAY
85023: PUSH
85024: LD_INT 1
85026: ARRAY
85027: PUSH
85028: LD_STRING M
85030: NONEQUAL
85031: IFFALSE 85035
// exit ;
85033: GO 85101
// x := task [ 1 ] [ 2 ] ;
85035: LD_ADDR_VAR 0 5
85039: PUSH
85040: LD_VAR 0 7
85044: PUSH
85045: LD_INT 1
85047: ARRAY
85048: PUSH
85049: LD_INT 2
85051: ARRAY
85052: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
85053: LD_ADDR_VAR 0 6
85057: PUSH
85058: LD_VAR 0 7
85062: PUSH
85063: LD_INT 1
85065: ARRAY
85066: PUSH
85067: LD_INT 3
85069: ARRAY
85070: ST_TO_ADDR
// if InArea ( x , y , area ) then
85071: LD_VAR 0 5
85075: PPUSH
85076: LD_VAR 0 6
85080: PPUSH
85081: LD_VAR 0 2
85085: PPUSH
85086: CALL_OW 309
85090: IFFALSE 85101
// ComStop ( unit ) ;
85092: LD_VAR 0 1
85096: PPUSH
85097: CALL_OW 141
// end ;
85101: LD_VAR 0 4
85105: RET
// export function Abs ( value ) ; begin
85106: LD_INT 0
85108: PPUSH
// result := value ;
85109: LD_ADDR_VAR 0 2
85113: PUSH
85114: LD_VAR 0 1
85118: ST_TO_ADDR
// if value < 0 then
85119: LD_VAR 0 1
85123: PUSH
85124: LD_INT 0
85126: LESS
85127: IFFALSE 85144
// result := value * - 1 ;
85129: LD_ADDR_VAR 0 2
85133: PUSH
85134: LD_VAR 0 1
85138: PUSH
85139: LD_INT 1
85141: NEG
85142: MUL
85143: ST_TO_ADDR
// end ;
85144: LD_VAR 0 2
85148: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
85149: LD_INT 0
85151: PPUSH
85152: PPUSH
85153: PPUSH
85154: PPUSH
85155: PPUSH
85156: PPUSH
85157: PPUSH
85158: PPUSH
// if not unit or not building then
85159: LD_VAR 0 1
85163: NOT
85164: PUSH
85165: LD_VAR 0 2
85169: NOT
85170: OR
85171: IFFALSE 85175
// exit ;
85173: GO 85401
// x := GetX ( building ) ;
85175: LD_ADDR_VAR 0 4
85179: PUSH
85180: LD_VAR 0 2
85184: PPUSH
85185: CALL_OW 250
85189: ST_TO_ADDR
// y := GetY ( building ) ;
85190: LD_ADDR_VAR 0 6
85194: PUSH
85195: LD_VAR 0 2
85199: PPUSH
85200: CALL_OW 251
85204: ST_TO_ADDR
// d := GetDir ( building ) ;
85205: LD_ADDR_VAR 0 8
85209: PUSH
85210: LD_VAR 0 2
85214: PPUSH
85215: CALL_OW 254
85219: ST_TO_ADDR
// r := 4 ;
85220: LD_ADDR_VAR 0 9
85224: PUSH
85225: LD_INT 4
85227: ST_TO_ADDR
// for i := 1 to 5 do
85228: LD_ADDR_VAR 0 10
85232: PUSH
85233: DOUBLE
85234: LD_INT 1
85236: DEC
85237: ST_TO_ADDR
85238: LD_INT 5
85240: PUSH
85241: FOR_TO
85242: IFFALSE 85399
// begin _x := ShiftX ( x , d , r + i ) ;
85244: LD_ADDR_VAR 0 5
85248: PUSH
85249: LD_VAR 0 4
85253: PPUSH
85254: LD_VAR 0 8
85258: PPUSH
85259: LD_VAR 0 9
85263: PUSH
85264: LD_VAR 0 10
85268: PLUS
85269: PPUSH
85270: CALL_OW 272
85274: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
85275: LD_ADDR_VAR 0 7
85279: PUSH
85280: LD_VAR 0 6
85284: PPUSH
85285: LD_VAR 0 8
85289: PPUSH
85290: LD_VAR 0 9
85294: PUSH
85295: LD_VAR 0 10
85299: PLUS
85300: PPUSH
85301: CALL_OW 273
85305: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
85306: LD_VAR 0 5
85310: PPUSH
85311: LD_VAR 0 7
85315: PPUSH
85316: CALL_OW 488
85320: PUSH
85321: LD_VAR 0 5
85325: PPUSH
85326: LD_VAR 0 7
85330: PPUSH
85331: CALL_OW 428
85335: PPUSH
85336: CALL_OW 247
85340: PUSH
85341: LD_INT 3
85343: PUSH
85344: LD_INT 2
85346: PUSH
85347: EMPTY
85348: LIST
85349: LIST
85350: IN
85351: NOT
85352: AND
85353: IFFALSE 85397
// begin ComMoveXY ( unit , _x , _y ) ;
85355: LD_VAR 0 1
85359: PPUSH
85360: LD_VAR 0 5
85364: PPUSH
85365: LD_VAR 0 7
85369: PPUSH
85370: CALL_OW 111
// result := [ _x , _y ] ;
85374: LD_ADDR_VAR 0 3
85378: PUSH
85379: LD_VAR 0 5
85383: PUSH
85384: LD_VAR 0 7
85388: PUSH
85389: EMPTY
85390: LIST
85391: LIST
85392: ST_TO_ADDR
// exit ;
85393: POP
85394: POP
85395: GO 85401
// end ; end ;
85397: GO 85241
85399: POP
85400: POP
// end ;
85401: LD_VAR 0 3
85405: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
85406: LD_INT 0
85408: PPUSH
85409: PPUSH
85410: PPUSH
// result := 0 ;
85411: LD_ADDR_VAR 0 3
85415: PUSH
85416: LD_INT 0
85418: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
85419: LD_VAR 0 1
85423: PUSH
85424: LD_INT 0
85426: LESS
85427: PUSH
85428: LD_VAR 0 1
85432: PUSH
85433: LD_INT 8
85435: GREATER
85436: OR
85437: PUSH
85438: LD_VAR 0 2
85442: PUSH
85443: LD_INT 0
85445: LESS
85446: OR
85447: PUSH
85448: LD_VAR 0 2
85452: PUSH
85453: LD_INT 8
85455: GREATER
85456: OR
85457: IFFALSE 85461
// exit ;
85459: GO 85536
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
85461: LD_ADDR_VAR 0 4
85465: PUSH
85466: LD_INT 22
85468: PUSH
85469: LD_VAR 0 2
85473: PUSH
85474: EMPTY
85475: LIST
85476: LIST
85477: PPUSH
85478: CALL_OW 69
85482: PUSH
85483: FOR_IN
85484: IFFALSE 85534
// begin un := UnitShoot ( i ) ;
85486: LD_ADDR_VAR 0 5
85490: PUSH
85491: LD_VAR 0 4
85495: PPUSH
85496: CALL_OW 504
85500: ST_TO_ADDR
// if GetSide ( un ) = side1 then
85501: LD_VAR 0 5
85505: PPUSH
85506: CALL_OW 255
85510: PUSH
85511: LD_VAR 0 1
85515: EQUAL
85516: IFFALSE 85532
// begin result := un ;
85518: LD_ADDR_VAR 0 3
85522: PUSH
85523: LD_VAR 0 5
85527: ST_TO_ADDR
// exit ;
85528: POP
85529: POP
85530: GO 85536
// end ; end ;
85532: GO 85483
85534: POP
85535: POP
// end ;
85536: LD_VAR 0 3
85540: RET
// export function GetCargoBay ( units ) ; begin
85541: LD_INT 0
85543: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
85544: LD_ADDR_VAR 0 2
85548: PUSH
85549: LD_VAR 0 1
85553: PPUSH
85554: LD_INT 2
85556: PUSH
85557: LD_INT 34
85559: PUSH
85560: LD_INT 12
85562: PUSH
85563: EMPTY
85564: LIST
85565: LIST
85566: PUSH
85567: LD_INT 34
85569: PUSH
85570: LD_INT 51
85572: PUSH
85573: EMPTY
85574: LIST
85575: LIST
85576: PUSH
85577: LD_INT 34
85579: PUSH
85580: LD_INT 32
85582: PUSH
85583: EMPTY
85584: LIST
85585: LIST
85586: PUSH
85587: LD_INT 34
85589: PUSH
85590: LD_EXP 94
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: PUSH
85599: EMPTY
85600: LIST
85601: LIST
85602: LIST
85603: LIST
85604: LIST
85605: PPUSH
85606: CALL_OW 72
85610: ST_TO_ADDR
// end ; end_of_file
85611: LD_VAR 0 2
85615: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
85616: LD_INT 0
85618: PPUSH
// ar_miner := 81 ;
85619: LD_ADDR_EXP 100
85623: PUSH
85624: LD_INT 81
85626: ST_TO_ADDR
// ar_crane := 88 ;
85627: LD_ADDR_EXP 99
85631: PUSH
85632: LD_INT 88
85634: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
85635: LD_ADDR_EXP 94
85639: PUSH
85640: LD_INT 89
85642: ST_TO_ADDR
// us_hack := 99 ;
85643: LD_ADDR_EXP 95
85647: PUSH
85648: LD_INT 99
85650: ST_TO_ADDR
// us_artillery := 97 ;
85651: LD_ADDR_EXP 96
85655: PUSH
85656: LD_INT 97
85658: ST_TO_ADDR
// ar_bio_bomb := 91 ;
85659: LD_ADDR_EXP 97
85663: PUSH
85664: LD_INT 91
85666: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
85667: LD_ADDR_EXP 98
85671: PUSH
85672: LD_INT 92
85674: ST_TO_ADDR
// ru_radar := 98 ;
85675: LD_ADDR_EXP 93
85679: PUSH
85680: LD_INT 98
85682: ST_TO_ADDR
// tech_Artillery := 80 ;
85683: LD_ADDR_EXP 101
85687: PUSH
85688: LD_INT 80
85690: ST_TO_ADDR
// tech_RadMat := 81 ;
85691: LD_ADDR_EXP 102
85695: PUSH
85696: LD_INT 81
85698: ST_TO_ADDR
// tech_BasicTools := 82 ;
85699: LD_ADDR_EXP 103
85703: PUSH
85704: LD_INT 82
85706: ST_TO_ADDR
// tech_Cargo := 83 ;
85707: LD_ADDR_EXP 104
85711: PUSH
85712: LD_INT 83
85714: ST_TO_ADDR
// tech_Track := 84 ;
85715: LD_ADDR_EXP 105
85719: PUSH
85720: LD_INT 84
85722: ST_TO_ADDR
// tech_Crane := 85 ;
85723: LD_ADDR_EXP 106
85727: PUSH
85728: LD_INT 85
85730: ST_TO_ADDR
// tech_Bulldozer := 86 ;
85731: LD_ADDR_EXP 107
85735: PUSH
85736: LD_INT 86
85738: ST_TO_ADDR
// tech_Hovercraft := 87 ;
85739: LD_ADDR_EXP 108
85743: PUSH
85744: LD_INT 87
85746: ST_TO_ADDR
// end ;
85747: LD_VAR 0 1
85751: RET
// every 1 do
85752: GO 85754
85754: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
85755: CALL 85616 0 0
85759: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
85760: LD_VAR 0 2
85764: PUSH
85765: LD_INT 100
85767: EQUAL
85768: IFFALSE 86717
// begin if not StreamModeActive then
85770: LD_EXP 109
85774: NOT
85775: IFFALSE 85785
// StreamModeActive := true ;
85777: LD_ADDR_EXP 109
85781: PUSH
85782: LD_INT 1
85784: ST_TO_ADDR
// if p3 = 0 then
85785: LD_VAR 0 3
85789: PUSH
85790: LD_INT 0
85792: EQUAL
85793: IFFALSE 85799
// InitStreamMode ;
85795: CALL 86875 0 0
// if p3 = 1 then
85799: LD_VAR 0 3
85803: PUSH
85804: LD_INT 1
85806: EQUAL
85807: IFFALSE 85817
// sRocket := true ;
85809: LD_ADDR_EXP 114
85813: PUSH
85814: LD_INT 1
85816: ST_TO_ADDR
// if p3 = 2 then
85817: LD_VAR 0 3
85821: PUSH
85822: LD_INT 2
85824: EQUAL
85825: IFFALSE 85835
// sSpeed := true ;
85827: LD_ADDR_EXP 113
85831: PUSH
85832: LD_INT 1
85834: ST_TO_ADDR
// if p3 = 3 then
85835: LD_VAR 0 3
85839: PUSH
85840: LD_INT 3
85842: EQUAL
85843: IFFALSE 85853
// sEngine := true ;
85845: LD_ADDR_EXP 115
85849: PUSH
85850: LD_INT 1
85852: ST_TO_ADDR
// if p3 = 4 then
85853: LD_VAR 0 3
85857: PUSH
85858: LD_INT 4
85860: EQUAL
85861: IFFALSE 85871
// sSpec := true ;
85863: LD_ADDR_EXP 112
85867: PUSH
85868: LD_INT 1
85870: ST_TO_ADDR
// if p3 = 5 then
85871: LD_VAR 0 3
85875: PUSH
85876: LD_INT 5
85878: EQUAL
85879: IFFALSE 85889
// sLevel := true ;
85881: LD_ADDR_EXP 116
85885: PUSH
85886: LD_INT 1
85888: ST_TO_ADDR
// if p3 = 6 then
85889: LD_VAR 0 3
85893: PUSH
85894: LD_INT 6
85896: EQUAL
85897: IFFALSE 85907
// sArmoury := true ;
85899: LD_ADDR_EXP 117
85903: PUSH
85904: LD_INT 1
85906: ST_TO_ADDR
// if p3 = 7 then
85907: LD_VAR 0 3
85911: PUSH
85912: LD_INT 7
85914: EQUAL
85915: IFFALSE 85925
// sRadar := true ;
85917: LD_ADDR_EXP 118
85921: PUSH
85922: LD_INT 1
85924: ST_TO_ADDR
// if p3 = 8 then
85925: LD_VAR 0 3
85929: PUSH
85930: LD_INT 8
85932: EQUAL
85933: IFFALSE 85943
// sBunker := true ;
85935: LD_ADDR_EXP 119
85939: PUSH
85940: LD_INT 1
85942: ST_TO_ADDR
// if p3 = 9 then
85943: LD_VAR 0 3
85947: PUSH
85948: LD_INT 9
85950: EQUAL
85951: IFFALSE 85961
// sHack := true ;
85953: LD_ADDR_EXP 120
85957: PUSH
85958: LD_INT 1
85960: ST_TO_ADDR
// if p3 = 10 then
85961: LD_VAR 0 3
85965: PUSH
85966: LD_INT 10
85968: EQUAL
85969: IFFALSE 85979
// sFire := true ;
85971: LD_ADDR_EXP 121
85975: PUSH
85976: LD_INT 1
85978: ST_TO_ADDR
// if p3 = 11 then
85979: LD_VAR 0 3
85983: PUSH
85984: LD_INT 11
85986: EQUAL
85987: IFFALSE 85997
// sRefresh := true ;
85989: LD_ADDR_EXP 122
85993: PUSH
85994: LD_INT 1
85996: ST_TO_ADDR
// if p3 = 12 then
85997: LD_VAR 0 3
86001: PUSH
86002: LD_INT 12
86004: EQUAL
86005: IFFALSE 86015
// sExp := true ;
86007: LD_ADDR_EXP 123
86011: PUSH
86012: LD_INT 1
86014: ST_TO_ADDR
// if p3 = 13 then
86015: LD_VAR 0 3
86019: PUSH
86020: LD_INT 13
86022: EQUAL
86023: IFFALSE 86033
// sDepot := true ;
86025: LD_ADDR_EXP 124
86029: PUSH
86030: LD_INT 1
86032: ST_TO_ADDR
// if p3 = 14 then
86033: LD_VAR 0 3
86037: PUSH
86038: LD_INT 14
86040: EQUAL
86041: IFFALSE 86051
// sFlag := true ;
86043: LD_ADDR_EXP 125
86047: PUSH
86048: LD_INT 1
86050: ST_TO_ADDR
// if p3 = 15 then
86051: LD_VAR 0 3
86055: PUSH
86056: LD_INT 15
86058: EQUAL
86059: IFFALSE 86069
// sKamikadze := true ;
86061: LD_ADDR_EXP 133
86065: PUSH
86066: LD_INT 1
86068: ST_TO_ADDR
// if p3 = 16 then
86069: LD_VAR 0 3
86073: PUSH
86074: LD_INT 16
86076: EQUAL
86077: IFFALSE 86087
// sTroll := true ;
86079: LD_ADDR_EXP 134
86083: PUSH
86084: LD_INT 1
86086: ST_TO_ADDR
// if p3 = 17 then
86087: LD_VAR 0 3
86091: PUSH
86092: LD_INT 17
86094: EQUAL
86095: IFFALSE 86105
// sSlow := true ;
86097: LD_ADDR_EXP 135
86101: PUSH
86102: LD_INT 1
86104: ST_TO_ADDR
// if p3 = 18 then
86105: LD_VAR 0 3
86109: PUSH
86110: LD_INT 18
86112: EQUAL
86113: IFFALSE 86123
// sLack := true ;
86115: LD_ADDR_EXP 136
86119: PUSH
86120: LD_INT 1
86122: ST_TO_ADDR
// if p3 = 19 then
86123: LD_VAR 0 3
86127: PUSH
86128: LD_INT 19
86130: EQUAL
86131: IFFALSE 86141
// sTank := true ;
86133: LD_ADDR_EXP 138
86137: PUSH
86138: LD_INT 1
86140: ST_TO_ADDR
// if p3 = 20 then
86141: LD_VAR 0 3
86145: PUSH
86146: LD_INT 20
86148: EQUAL
86149: IFFALSE 86159
// sRemote := true ;
86151: LD_ADDR_EXP 139
86155: PUSH
86156: LD_INT 1
86158: ST_TO_ADDR
// if p3 = 21 then
86159: LD_VAR 0 3
86163: PUSH
86164: LD_INT 21
86166: EQUAL
86167: IFFALSE 86177
// sPowell := true ;
86169: LD_ADDR_EXP 140
86173: PUSH
86174: LD_INT 1
86176: ST_TO_ADDR
// if p3 = 22 then
86177: LD_VAR 0 3
86181: PUSH
86182: LD_INT 22
86184: EQUAL
86185: IFFALSE 86195
// sTeleport := true ;
86187: LD_ADDR_EXP 143
86191: PUSH
86192: LD_INT 1
86194: ST_TO_ADDR
// if p3 = 23 then
86195: LD_VAR 0 3
86199: PUSH
86200: LD_INT 23
86202: EQUAL
86203: IFFALSE 86213
// sOilTower := true ;
86205: LD_ADDR_EXP 145
86209: PUSH
86210: LD_INT 1
86212: ST_TO_ADDR
// if p3 = 24 then
86213: LD_VAR 0 3
86217: PUSH
86218: LD_INT 24
86220: EQUAL
86221: IFFALSE 86231
// sShovel := true ;
86223: LD_ADDR_EXP 146
86227: PUSH
86228: LD_INT 1
86230: ST_TO_ADDR
// if p3 = 25 then
86231: LD_VAR 0 3
86235: PUSH
86236: LD_INT 25
86238: EQUAL
86239: IFFALSE 86249
// sSheik := true ;
86241: LD_ADDR_EXP 147
86245: PUSH
86246: LD_INT 1
86248: ST_TO_ADDR
// if p3 = 26 then
86249: LD_VAR 0 3
86253: PUSH
86254: LD_INT 26
86256: EQUAL
86257: IFFALSE 86267
// sEarthquake := true ;
86259: LD_ADDR_EXP 149
86263: PUSH
86264: LD_INT 1
86266: ST_TO_ADDR
// if p3 = 27 then
86267: LD_VAR 0 3
86271: PUSH
86272: LD_INT 27
86274: EQUAL
86275: IFFALSE 86285
// sAI := true ;
86277: LD_ADDR_EXP 150
86281: PUSH
86282: LD_INT 1
86284: ST_TO_ADDR
// if p3 = 28 then
86285: LD_VAR 0 3
86289: PUSH
86290: LD_INT 28
86292: EQUAL
86293: IFFALSE 86303
// sCargo := true ;
86295: LD_ADDR_EXP 153
86299: PUSH
86300: LD_INT 1
86302: ST_TO_ADDR
// if p3 = 29 then
86303: LD_VAR 0 3
86307: PUSH
86308: LD_INT 29
86310: EQUAL
86311: IFFALSE 86321
// sDLaser := true ;
86313: LD_ADDR_EXP 154
86317: PUSH
86318: LD_INT 1
86320: ST_TO_ADDR
// if p3 = 30 then
86321: LD_VAR 0 3
86325: PUSH
86326: LD_INT 30
86328: EQUAL
86329: IFFALSE 86339
// sExchange := true ;
86331: LD_ADDR_EXP 155
86335: PUSH
86336: LD_INT 1
86338: ST_TO_ADDR
// if p3 = 31 then
86339: LD_VAR 0 3
86343: PUSH
86344: LD_INT 31
86346: EQUAL
86347: IFFALSE 86357
// sFac := true ;
86349: LD_ADDR_EXP 156
86353: PUSH
86354: LD_INT 1
86356: ST_TO_ADDR
// if p3 = 32 then
86357: LD_VAR 0 3
86361: PUSH
86362: LD_INT 32
86364: EQUAL
86365: IFFALSE 86375
// sPower := true ;
86367: LD_ADDR_EXP 157
86371: PUSH
86372: LD_INT 1
86374: ST_TO_ADDR
// if p3 = 33 then
86375: LD_VAR 0 3
86379: PUSH
86380: LD_INT 33
86382: EQUAL
86383: IFFALSE 86393
// sRandom := true ;
86385: LD_ADDR_EXP 158
86389: PUSH
86390: LD_INT 1
86392: ST_TO_ADDR
// if p3 = 34 then
86393: LD_VAR 0 3
86397: PUSH
86398: LD_INT 34
86400: EQUAL
86401: IFFALSE 86411
// sShield := true ;
86403: LD_ADDR_EXP 159
86407: PUSH
86408: LD_INT 1
86410: ST_TO_ADDR
// if p3 = 35 then
86411: LD_VAR 0 3
86415: PUSH
86416: LD_INT 35
86418: EQUAL
86419: IFFALSE 86429
// sTime := true ;
86421: LD_ADDR_EXP 160
86425: PUSH
86426: LD_INT 1
86428: ST_TO_ADDR
// if p3 = 36 then
86429: LD_VAR 0 3
86433: PUSH
86434: LD_INT 36
86436: EQUAL
86437: IFFALSE 86447
// sTools := true ;
86439: LD_ADDR_EXP 161
86443: PUSH
86444: LD_INT 1
86446: ST_TO_ADDR
// if p3 = 101 then
86447: LD_VAR 0 3
86451: PUSH
86452: LD_INT 101
86454: EQUAL
86455: IFFALSE 86465
// sSold := true ;
86457: LD_ADDR_EXP 126
86461: PUSH
86462: LD_INT 1
86464: ST_TO_ADDR
// if p3 = 102 then
86465: LD_VAR 0 3
86469: PUSH
86470: LD_INT 102
86472: EQUAL
86473: IFFALSE 86483
// sDiff := true ;
86475: LD_ADDR_EXP 127
86479: PUSH
86480: LD_INT 1
86482: ST_TO_ADDR
// if p3 = 103 then
86483: LD_VAR 0 3
86487: PUSH
86488: LD_INT 103
86490: EQUAL
86491: IFFALSE 86501
// sFog := true ;
86493: LD_ADDR_EXP 130
86497: PUSH
86498: LD_INT 1
86500: ST_TO_ADDR
// if p3 = 104 then
86501: LD_VAR 0 3
86505: PUSH
86506: LD_INT 104
86508: EQUAL
86509: IFFALSE 86519
// sReset := true ;
86511: LD_ADDR_EXP 131
86515: PUSH
86516: LD_INT 1
86518: ST_TO_ADDR
// if p3 = 105 then
86519: LD_VAR 0 3
86523: PUSH
86524: LD_INT 105
86526: EQUAL
86527: IFFALSE 86537
// sSun := true ;
86529: LD_ADDR_EXP 132
86533: PUSH
86534: LD_INT 1
86536: ST_TO_ADDR
// if p3 = 106 then
86537: LD_VAR 0 3
86541: PUSH
86542: LD_INT 106
86544: EQUAL
86545: IFFALSE 86555
// sTiger := true ;
86547: LD_ADDR_EXP 128
86551: PUSH
86552: LD_INT 1
86554: ST_TO_ADDR
// if p3 = 107 then
86555: LD_VAR 0 3
86559: PUSH
86560: LD_INT 107
86562: EQUAL
86563: IFFALSE 86573
// sBomb := true ;
86565: LD_ADDR_EXP 129
86569: PUSH
86570: LD_INT 1
86572: ST_TO_ADDR
// if p3 = 108 then
86573: LD_VAR 0 3
86577: PUSH
86578: LD_INT 108
86580: EQUAL
86581: IFFALSE 86591
// sWound := true ;
86583: LD_ADDR_EXP 137
86587: PUSH
86588: LD_INT 1
86590: ST_TO_ADDR
// if p3 = 109 then
86591: LD_VAR 0 3
86595: PUSH
86596: LD_INT 109
86598: EQUAL
86599: IFFALSE 86609
// sBetray := true ;
86601: LD_ADDR_EXP 141
86605: PUSH
86606: LD_INT 1
86608: ST_TO_ADDR
// if p3 = 110 then
86609: LD_VAR 0 3
86613: PUSH
86614: LD_INT 110
86616: EQUAL
86617: IFFALSE 86627
// sContamin := true ;
86619: LD_ADDR_EXP 142
86623: PUSH
86624: LD_INT 1
86626: ST_TO_ADDR
// if p3 = 111 then
86627: LD_VAR 0 3
86631: PUSH
86632: LD_INT 111
86634: EQUAL
86635: IFFALSE 86645
// sOil := true ;
86637: LD_ADDR_EXP 144
86641: PUSH
86642: LD_INT 1
86644: ST_TO_ADDR
// if p3 = 112 then
86645: LD_VAR 0 3
86649: PUSH
86650: LD_INT 112
86652: EQUAL
86653: IFFALSE 86663
// sStu := true ;
86655: LD_ADDR_EXP 148
86659: PUSH
86660: LD_INT 1
86662: ST_TO_ADDR
// if p3 = 113 then
86663: LD_VAR 0 3
86667: PUSH
86668: LD_INT 113
86670: EQUAL
86671: IFFALSE 86681
// sBazooka := true ;
86673: LD_ADDR_EXP 151
86677: PUSH
86678: LD_INT 1
86680: ST_TO_ADDR
// if p3 = 114 then
86681: LD_VAR 0 3
86685: PUSH
86686: LD_INT 114
86688: EQUAL
86689: IFFALSE 86699
// sMortar := true ;
86691: LD_ADDR_EXP 152
86695: PUSH
86696: LD_INT 1
86698: ST_TO_ADDR
// if p3 = 115 then
86699: LD_VAR 0 3
86703: PUSH
86704: LD_INT 115
86706: EQUAL
86707: IFFALSE 86717
// sRanger := true ;
86709: LD_ADDR_EXP 162
86713: PUSH
86714: LD_INT 1
86716: ST_TO_ADDR
// end ; if p2 = 101 then
86717: LD_VAR 0 2
86721: PUSH
86722: LD_INT 101
86724: EQUAL
86725: IFFALSE 86853
// begin case p3 of 1 :
86727: LD_VAR 0 3
86731: PUSH
86732: LD_INT 1
86734: DOUBLE
86735: EQUAL
86736: IFTRUE 86740
86738: GO 86747
86740: POP
// hHackUnlimitedResources ; 2 :
86741: CALL 97888 0 0
86745: GO 86853
86747: LD_INT 2
86749: DOUBLE
86750: EQUAL
86751: IFTRUE 86755
86753: GO 86762
86755: POP
// hHackSetLevel10 ; 3 :
86756: CALL 98021 0 0
86760: GO 86853
86762: LD_INT 3
86764: DOUBLE
86765: EQUAL
86766: IFTRUE 86770
86768: GO 86777
86770: POP
// hHackSetLevel10YourUnits ; 4 :
86771: CALL 98106 0 0
86775: GO 86853
86777: LD_INT 4
86779: DOUBLE
86780: EQUAL
86781: IFTRUE 86785
86783: GO 86792
86785: POP
// hHackInvincible ; 5 :
86786: CALL 98554 0 0
86790: GO 86853
86792: LD_INT 5
86794: DOUBLE
86795: EQUAL
86796: IFTRUE 86800
86798: GO 86807
86800: POP
// hHackInvisible ; 6 :
86801: CALL 98665 0 0
86805: GO 86853
86807: LD_INT 6
86809: DOUBLE
86810: EQUAL
86811: IFTRUE 86815
86813: GO 86822
86815: POP
// hHackChangeYourSide ; 7 :
86816: CALL 98722 0 0
86820: GO 86853
86822: LD_INT 7
86824: DOUBLE
86825: EQUAL
86826: IFTRUE 86830
86828: GO 86837
86830: POP
// hHackChangeUnitSide ; 8 :
86831: CALL 98764 0 0
86835: GO 86853
86837: LD_INT 8
86839: DOUBLE
86840: EQUAL
86841: IFTRUE 86845
86843: GO 86852
86845: POP
// hHackFog ; end ;
86846: CALL 98865 0 0
86850: GO 86853
86852: POP
// end ; end ;
86853: PPOPN 6
86855: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
86856: GO 86858
86858: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
86859: LD_STRING initStreamRollete();
86861: PPUSH
86862: CALL_OW 559
// InitStreamMode ;
86866: CALL 86875 0 0
// DefineStreamItems ( ) ;
86870: CALL 87315 0 0
// end ;
86874: END
// function InitStreamMode ; begin
86875: LD_INT 0
86877: PPUSH
// streamModeActive := false ;
86878: LD_ADDR_EXP 109
86882: PUSH
86883: LD_INT 0
86885: ST_TO_ADDR
// normalCounter := 36 ;
86886: LD_ADDR_EXP 110
86890: PUSH
86891: LD_INT 36
86893: ST_TO_ADDR
// hardcoreCounter := 16 ;
86894: LD_ADDR_EXP 111
86898: PUSH
86899: LD_INT 16
86901: ST_TO_ADDR
// sRocket := false ;
86902: LD_ADDR_EXP 114
86906: PUSH
86907: LD_INT 0
86909: ST_TO_ADDR
// sSpeed := false ;
86910: LD_ADDR_EXP 113
86914: PUSH
86915: LD_INT 0
86917: ST_TO_ADDR
// sEngine := false ;
86918: LD_ADDR_EXP 115
86922: PUSH
86923: LD_INT 0
86925: ST_TO_ADDR
// sSpec := false ;
86926: LD_ADDR_EXP 112
86930: PUSH
86931: LD_INT 0
86933: ST_TO_ADDR
// sLevel := false ;
86934: LD_ADDR_EXP 116
86938: PUSH
86939: LD_INT 0
86941: ST_TO_ADDR
// sArmoury := false ;
86942: LD_ADDR_EXP 117
86946: PUSH
86947: LD_INT 0
86949: ST_TO_ADDR
// sRadar := false ;
86950: LD_ADDR_EXP 118
86954: PUSH
86955: LD_INT 0
86957: ST_TO_ADDR
// sBunker := false ;
86958: LD_ADDR_EXP 119
86962: PUSH
86963: LD_INT 0
86965: ST_TO_ADDR
// sHack := false ;
86966: LD_ADDR_EXP 120
86970: PUSH
86971: LD_INT 0
86973: ST_TO_ADDR
// sFire := false ;
86974: LD_ADDR_EXP 121
86978: PUSH
86979: LD_INT 0
86981: ST_TO_ADDR
// sRefresh := false ;
86982: LD_ADDR_EXP 122
86986: PUSH
86987: LD_INT 0
86989: ST_TO_ADDR
// sExp := false ;
86990: LD_ADDR_EXP 123
86994: PUSH
86995: LD_INT 0
86997: ST_TO_ADDR
// sDepot := false ;
86998: LD_ADDR_EXP 124
87002: PUSH
87003: LD_INT 0
87005: ST_TO_ADDR
// sFlag := false ;
87006: LD_ADDR_EXP 125
87010: PUSH
87011: LD_INT 0
87013: ST_TO_ADDR
// sKamikadze := false ;
87014: LD_ADDR_EXP 133
87018: PUSH
87019: LD_INT 0
87021: ST_TO_ADDR
// sTroll := false ;
87022: LD_ADDR_EXP 134
87026: PUSH
87027: LD_INT 0
87029: ST_TO_ADDR
// sSlow := false ;
87030: LD_ADDR_EXP 135
87034: PUSH
87035: LD_INT 0
87037: ST_TO_ADDR
// sLack := false ;
87038: LD_ADDR_EXP 136
87042: PUSH
87043: LD_INT 0
87045: ST_TO_ADDR
// sTank := false ;
87046: LD_ADDR_EXP 138
87050: PUSH
87051: LD_INT 0
87053: ST_TO_ADDR
// sRemote := false ;
87054: LD_ADDR_EXP 139
87058: PUSH
87059: LD_INT 0
87061: ST_TO_ADDR
// sPowell := false ;
87062: LD_ADDR_EXP 140
87066: PUSH
87067: LD_INT 0
87069: ST_TO_ADDR
// sTeleport := false ;
87070: LD_ADDR_EXP 143
87074: PUSH
87075: LD_INT 0
87077: ST_TO_ADDR
// sOilTower := false ;
87078: LD_ADDR_EXP 145
87082: PUSH
87083: LD_INT 0
87085: ST_TO_ADDR
// sShovel := false ;
87086: LD_ADDR_EXP 146
87090: PUSH
87091: LD_INT 0
87093: ST_TO_ADDR
// sSheik := false ;
87094: LD_ADDR_EXP 147
87098: PUSH
87099: LD_INT 0
87101: ST_TO_ADDR
// sEarthquake := false ;
87102: LD_ADDR_EXP 149
87106: PUSH
87107: LD_INT 0
87109: ST_TO_ADDR
// sAI := false ;
87110: LD_ADDR_EXP 150
87114: PUSH
87115: LD_INT 0
87117: ST_TO_ADDR
// sCargo := false ;
87118: LD_ADDR_EXP 153
87122: PUSH
87123: LD_INT 0
87125: ST_TO_ADDR
// sDLaser := false ;
87126: LD_ADDR_EXP 154
87130: PUSH
87131: LD_INT 0
87133: ST_TO_ADDR
// sExchange := false ;
87134: LD_ADDR_EXP 155
87138: PUSH
87139: LD_INT 0
87141: ST_TO_ADDR
// sFac := false ;
87142: LD_ADDR_EXP 156
87146: PUSH
87147: LD_INT 0
87149: ST_TO_ADDR
// sPower := false ;
87150: LD_ADDR_EXP 157
87154: PUSH
87155: LD_INT 0
87157: ST_TO_ADDR
// sRandom := false ;
87158: LD_ADDR_EXP 158
87162: PUSH
87163: LD_INT 0
87165: ST_TO_ADDR
// sShield := false ;
87166: LD_ADDR_EXP 159
87170: PUSH
87171: LD_INT 0
87173: ST_TO_ADDR
// sTime := false ;
87174: LD_ADDR_EXP 160
87178: PUSH
87179: LD_INT 0
87181: ST_TO_ADDR
// sTools := false ;
87182: LD_ADDR_EXP 161
87186: PUSH
87187: LD_INT 0
87189: ST_TO_ADDR
// sSold := false ;
87190: LD_ADDR_EXP 126
87194: PUSH
87195: LD_INT 0
87197: ST_TO_ADDR
// sDiff := false ;
87198: LD_ADDR_EXP 127
87202: PUSH
87203: LD_INT 0
87205: ST_TO_ADDR
// sFog := false ;
87206: LD_ADDR_EXP 130
87210: PUSH
87211: LD_INT 0
87213: ST_TO_ADDR
// sReset := false ;
87214: LD_ADDR_EXP 131
87218: PUSH
87219: LD_INT 0
87221: ST_TO_ADDR
// sSun := false ;
87222: LD_ADDR_EXP 132
87226: PUSH
87227: LD_INT 0
87229: ST_TO_ADDR
// sTiger := false ;
87230: LD_ADDR_EXP 128
87234: PUSH
87235: LD_INT 0
87237: ST_TO_ADDR
// sBomb := false ;
87238: LD_ADDR_EXP 129
87242: PUSH
87243: LD_INT 0
87245: ST_TO_ADDR
// sWound := false ;
87246: LD_ADDR_EXP 137
87250: PUSH
87251: LD_INT 0
87253: ST_TO_ADDR
// sBetray := false ;
87254: LD_ADDR_EXP 141
87258: PUSH
87259: LD_INT 0
87261: ST_TO_ADDR
// sContamin := false ;
87262: LD_ADDR_EXP 142
87266: PUSH
87267: LD_INT 0
87269: ST_TO_ADDR
// sOil := false ;
87270: LD_ADDR_EXP 144
87274: PUSH
87275: LD_INT 0
87277: ST_TO_ADDR
// sStu := false ;
87278: LD_ADDR_EXP 148
87282: PUSH
87283: LD_INT 0
87285: ST_TO_ADDR
// sBazooka := false ;
87286: LD_ADDR_EXP 151
87290: PUSH
87291: LD_INT 0
87293: ST_TO_ADDR
// sMortar := false ;
87294: LD_ADDR_EXP 152
87298: PUSH
87299: LD_INT 0
87301: ST_TO_ADDR
// sRanger := false ;
87302: LD_ADDR_EXP 162
87306: PUSH
87307: LD_INT 0
87309: ST_TO_ADDR
// end ;
87310: LD_VAR 0 1
87314: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
87315: LD_INT 0
87317: PPUSH
87318: PPUSH
87319: PPUSH
87320: PPUSH
87321: PPUSH
// result := [ ] ;
87322: LD_ADDR_VAR 0 1
87326: PUSH
87327: EMPTY
87328: ST_TO_ADDR
// if campaign_id = 1 then
87329: LD_OWVAR 69
87333: PUSH
87334: LD_INT 1
87336: EQUAL
87337: IFFALSE 90275
// begin case mission_number of 1 :
87339: LD_OWVAR 70
87343: PUSH
87344: LD_INT 1
87346: DOUBLE
87347: EQUAL
87348: IFTRUE 87352
87350: GO 87416
87352: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
87353: LD_ADDR_VAR 0 1
87357: PUSH
87358: LD_INT 2
87360: PUSH
87361: LD_INT 4
87363: PUSH
87364: LD_INT 11
87366: PUSH
87367: LD_INT 12
87369: PUSH
87370: LD_INT 15
87372: PUSH
87373: LD_INT 16
87375: PUSH
87376: LD_INT 22
87378: PUSH
87379: LD_INT 23
87381: PUSH
87382: LD_INT 26
87384: PUSH
87385: EMPTY
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: PUSH
87396: LD_INT 101
87398: PUSH
87399: LD_INT 102
87401: PUSH
87402: LD_INT 106
87404: PUSH
87405: EMPTY
87406: LIST
87407: LIST
87408: LIST
87409: PUSH
87410: EMPTY
87411: LIST
87412: LIST
87413: ST_TO_ADDR
87414: GO 90273
87416: LD_INT 2
87418: DOUBLE
87419: EQUAL
87420: IFTRUE 87424
87422: GO 87496
87424: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
87425: LD_ADDR_VAR 0 1
87429: PUSH
87430: LD_INT 2
87432: PUSH
87433: LD_INT 4
87435: PUSH
87436: LD_INT 11
87438: PUSH
87439: LD_INT 12
87441: PUSH
87442: LD_INT 15
87444: PUSH
87445: LD_INT 16
87447: PUSH
87448: LD_INT 22
87450: PUSH
87451: LD_INT 23
87453: PUSH
87454: LD_INT 26
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: PUSH
87468: LD_INT 101
87470: PUSH
87471: LD_INT 102
87473: PUSH
87474: LD_INT 105
87476: PUSH
87477: LD_INT 106
87479: PUSH
87480: LD_INT 108
87482: PUSH
87483: EMPTY
87484: LIST
87485: LIST
87486: LIST
87487: LIST
87488: LIST
87489: PUSH
87490: EMPTY
87491: LIST
87492: LIST
87493: ST_TO_ADDR
87494: GO 90273
87496: LD_INT 3
87498: DOUBLE
87499: EQUAL
87500: IFTRUE 87504
87502: GO 87580
87504: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
87505: LD_ADDR_VAR 0 1
87509: PUSH
87510: LD_INT 2
87512: PUSH
87513: LD_INT 4
87515: PUSH
87516: LD_INT 5
87518: PUSH
87519: LD_INT 11
87521: PUSH
87522: LD_INT 12
87524: PUSH
87525: LD_INT 15
87527: PUSH
87528: LD_INT 16
87530: PUSH
87531: LD_INT 22
87533: PUSH
87534: LD_INT 26
87536: PUSH
87537: LD_INT 36
87539: PUSH
87540: EMPTY
87541: LIST
87542: LIST
87543: LIST
87544: LIST
87545: LIST
87546: LIST
87547: LIST
87548: LIST
87549: LIST
87550: LIST
87551: PUSH
87552: LD_INT 101
87554: PUSH
87555: LD_INT 102
87557: PUSH
87558: LD_INT 105
87560: PUSH
87561: LD_INT 106
87563: PUSH
87564: LD_INT 108
87566: PUSH
87567: EMPTY
87568: LIST
87569: LIST
87570: LIST
87571: LIST
87572: LIST
87573: PUSH
87574: EMPTY
87575: LIST
87576: LIST
87577: ST_TO_ADDR
87578: GO 90273
87580: LD_INT 4
87582: DOUBLE
87583: EQUAL
87584: IFTRUE 87588
87586: GO 87672
87588: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
87589: LD_ADDR_VAR 0 1
87593: PUSH
87594: LD_INT 2
87596: PUSH
87597: LD_INT 4
87599: PUSH
87600: LD_INT 5
87602: PUSH
87603: LD_INT 8
87605: PUSH
87606: LD_INT 11
87608: PUSH
87609: LD_INT 12
87611: PUSH
87612: LD_INT 15
87614: PUSH
87615: LD_INT 16
87617: PUSH
87618: LD_INT 22
87620: PUSH
87621: LD_INT 23
87623: PUSH
87624: LD_INT 26
87626: PUSH
87627: LD_INT 36
87629: PUSH
87630: EMPTY
87631: LIST
87632: LIST
87633: LIST
87634: LIST
87635: LIST
87636: LIST
87637: LIST
87638: LIST
87639: LIST
87640: LIST
87641: LIST
87642: LIST
87643: PUSH
87644: LD_INT 101
87646: PUSH
87647: LD_INT 102
87649: PUSH
87650: LD_INT 105
87652: PUSH
87653: LD_INT 106
87655: PUSH
87656: LD_INT 108
87658: PUSH
87659: EMPTY
87660: LIST
87661: LIST
87662: LIST
87663: LIST
87664: LIST
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: ST_TO_ADDR
87670: GO 90273
87672: LD_INT 5
87674: DOUBLE
87675: EQUAL
87676: IFTRUE 87680
87678: GO 87780
87680: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
87681: LD_ADDR_VAR 0 1
87685: PUSH
87686: LD_INT 2
87688: PUSH
87689: LD_INT 4
87691: PUSH
87692: LD_INT 5
87694: PUSH
87695: LD_INT 6
87697: PUSH
87698: LD_INT 8
87700: PUSH
87701: LD_INT 11
87703: PUSH
87704: LD_INT 12
87706: PUSH
87707: LD_INT 15
87709: PUSH
87710: LD_INT 16
87712: PUSH
87713: LD_INT 22
87715: PUSH
87716: LD_INT 23
87718: PUSH
87719: LD_INT 25
87721: PUSH
87722: LD_INT 26
87724: PUSH
87725: LD_INT 36
87727: PUSH
87728: EMPTY
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: PUSH
87744: LD_INT 101
87746: PUSH
87747: LD_INT 102
87749: PUSH
87750: LD_INT 105
87752: PUSH
87753: LD_INT 106
87755: PUSH
87756: LD_INT 108
87758: PUSH
87759: LD_INT 109
87761: PUSH
87762: LD_INT 112
87764: PUSH
87765: EMPTY
87766: LIST
87767: LIST
87768: LIST
87769: LIST
87770: LIST
87771: LIST
87772: LIST
87773: PUSH
87774: EMPTY
87775: LIST
87776: LIST
87777: ST_TO_ADDR
87778: GO 90273
87780: LD_INT 6
87782: DOUBLE
87783: EQUAL
87784: IFTRUE 87788
87786: GO 87908
87788: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
87789: LD_ADDR_VAR 0 1
87793: PUSH
87794: LD_INT 2
87796: PUSH
87797: LD_INT 4
87799: PUSH
87800: LD_INT 5
87802: PUSH
87803: LD_INT 6
87805: PUSH
87806: LD_INT 8
87808: PUSH
87809: LD_INT 11
87811: PUSH
87812: LD_INT 12
87814: PUSH
87815: LD_INT 15
87817: PUSH
87818: LD_INT 16
87820: PUSH
87821: LD_INT 20
87823: PUSH
87824: LD_INT 21
87826: PUSH
87827: LD_INT 22
87829: PUSH
87830: LD_INT 23
87832: PUSH
87833: LD_INT 25
87835: PUSH
87836: LD_INT 26
87838: PUSH
87839: LD_INT 30
87841: PUSH
87842: LD_INT 31
87844: PUSH
87845: LD_INT 32
87847: PUSH
87848: LD_INT 36
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: LIST
87865: LIST
87866: LIST
87867: LIST
87868: LIST
87869: LIST
87870: LIST
87871: PUSH
87872: LD_INT 101
87874: PUSH
87875: LD_INT 102
87877: PUSH
87878: LD_INT 105
87880: PUSH
87881: LD_INT 106
87883: PUSH
87884: LD_INT 108
87886: PUSH
87887: LD_INT 109
87889: PUSH
87890: LD_INT 112
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: LIST
87900: LIST
87901: PUSH
87902: EMPTY
87903: LIST
87904: LIST
87905: ST_TO_ADDR
87906: GO 90273
87908: LD_INT 7
87910: DOUBLE
87911: EQUAL
87912: IFTRUE 87916
87914: GO 88016
87916: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
87917: LD_ADDR_VAR 0 1
87921: PUSH
87922: LD_INT 2
87924: PUSH
87925: LD_INT 4
87927: PUSH
87928: LD_INT 5
87930: PUSH
87931: LD_INT 7
87933: PUSH
87934: LD_INT 11
87936: PUSH
87937: LD_INT 12
87939: PUSH
87940: LD_INT 15
87942: PUSH
87943: LD_INT 16
87945: PUSH
87946: LD_INT 20
87948: PUSH
87949: LD_INT 21
87951: PUSH
87952: LD_INT 22
87954: PUSH
87955: LD_INT 23
87957: PUSH
87958: LD_INT 25
87960: PUSH
87961: LD_INT 26
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: LIST
87968: LIST
87969: LIST
87970: LIST
87971: LIST
87972: LIST
87973: LIST
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: PUSH
87980: LD_INT 101
87982: PUSH
87983: LD_INT 102
87985: PUSH
87986: LD_INT 103
87988: PUSH
87989: LD_INT 105
87991: PUSH
87992: LD_INT 106
87994: PUSH
87995: LD_INT 108
87997: PUSH
87998: LD_INT 112
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: PUSH
88010: EMPTY
88011: LIST
88012: LIST
88013: ST_TO_ADDR
88014: GO 90273
88016: LD_INT 8
88018: DOUBLE
88019: EQUAL
88020: IFTRUE 88024
88022: GO 88152
88024: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
88025: LD_ADDR_VAR 0 1
88029: PUSH
88030: LD_INT 2
88032: PUSH
88033: LD_INT 4
88035: PUSH
88036: LD_INT 5
88038: PUSH
88039: LD_INT 6
88041: PUSH
88042: LD_INT 7
88044: PUSH
88045: LD_INT 8
88047: PUSH
88048: LD_INT 11
88050: PUSH
88051: LD_INT 12
88053: PUSH
88054: LD_INT 15
88056: PUSH
88057: LD_INT 16
88059: PUSH
88060: LD_INT 20
88062: PUSH
88063: LD_INT 21
88065: PUSH
88066: LD_INT 22
88068: PUSH
88069: LD_INT 23
88071: PUSH
88072: LD_INT 25
88074: PUSH
88075: LD_INT 26
88077: PUSH
88078: LD_INT 30
88080: PUSH
88081: LD_INT 31
88083: PUSH
88084: LD_INT 32
88086: PUSH
88087: LD_INT 36
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: LIST
88108: LIST
88109: LIST
88110: LIST
88111: PUSH
88112: LD_INT 101
88114: PUSH
88115: LD_INT 102
88117: PUSH
88118: LD_INT 103
88120: PUSH
88121: LD_INT 105
88123: PUSH
88124: LD_INT 106
88126: PUSH
88127: LD_INT 108
88129: PUSH
88130: LD_INT 109
88132: PUSH
88133: LD_INT 112
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: ST_TO_ADDR
88150: GO 90273
88152: LD_INT 9
88154: DOUBLE
88155: EQUAL
88156: IFTRUE 88160
88158: GO 88296
88160: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
88161: LD_ADDR_VAR 0 1
88165: PUSH
88166: LD_INT 2
88168: PUSH
88169: LD_INT 4
88171: PUSH
88172: LD_INT 5
88174: PUSH
88175: LD_INT 6
88177: PUSH
88178: LD_INT 7
88180: PUSH
88181: LD_INT 8
88183: PUSH
88184: LD_INT 11
88186: PUSH
88187: LD_INT 12
88189: PUSH
88190: LD_INT 15
88192: PUSH
88193: LD_INT 16
88195: PUSH
88196: LD_INT 20
88198: PUSH
88199: LD_INT 21
88201: PUSH
88202: LD_INT 22
88204: PUSH
88205: LD_INT 23
88207: PUSH
88208: LD_INT 25
88210: PUSH
88211: LD_INT 26
88213: PUSH
88214: LD_INT 28
88216: PUSH
88217: LD_INT 30
88219: PUSH
88220: LD_INT 31
88222: PUSH
88223: LD_INT 32
88225: PUSH
88226: LD_INT 36
88228: PUSH
88229: EMPTY
88230: LIST
88231: LIST
88232: LIST
88233: LIST
88234: LIST
88235: LIST
88236: LIST
88237: LIST
88238: LIST
88239: LIST
88240: LIST
88241: LIST
88242: LIST
88243: LIST
88244: LIST
88245: LIST
88246: LIST
88247: LIST
88248: LIST
88249: LIST
88250: LIST
88251: PUSH
88252: LD_INT 101
88254: PUSH
88255: LD_INT 102
88257: PUSH
88258: LD_INT 103
88260: PUSH
88261: LD_INT 105
88263: PUSH
88264: LD_INT 106
88266: PUSH
88267: LD_INT 108
88269: PUSH
88270: LD_INT 109
88272: PUSH
88273: LD_INT 112
88275: PUSH
88276: LD_INT 114
88278: PUSH
88279: EMPTY
88280: LIST
88281: LIST
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: PUSH
88290: EMPTY
88291: LIST
88292: LIST
88293: ST_TO_ADDR
88294: GO 90273
88296: LD_INT 10
88298: DOUBLE
88299: EQUAL
88300: IFTRUE 88304
88302: GO 88488
88304: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
88305: LD_ADDR_VAR 0 1
88309: PUSH
88310: LD_INT 2
88312: PUSH
88313: LD_INT 4
88315: PUSH
88316: LD_INT 5
88318: PUSH
88319: LD_INT 6
88321: PUSH
88322: LD_INT 7
88324: PUSH
88325: LD_INT 8
88327: PUSH
88328: LD_INT 9
88330: PUSH
88331: LD_INT 10
88333: PUSH
88334: LD_INT 11
88336: PUSH
88337: LD_INT 12
88339: PUSH
88340: LD_INT 13
88342: PUSH
88343: LD_INT 14
88345: PUSH
88346: LD_INT 15
88348: PUSH
88349: LD_INT 16
88351: PUSH
88352: LD_INT 17
88354: PUSH
88355: LD_INT 18
88357: PUSH
88358: LD_INT 19
88360: PUSH
88361: LD_INT 20
88363: PUSH
88364: LD_INT 21
88366: PUSH
88367: LD_INT 22
88369: PUSH
88370: LD_INT 23
88372: PUSH
88373: LD_INT 24
88375: PUSH
88376: LD_INT 25
88378: PUSH
88379: LD_INT 26
88381: PUSH
88382: LD_INT 28
88384: PUSH
88385: LD_INT 30
88387: PUSH
88388: LD_INT 31
88390: PUSH
88391: LD_INT 32
88393: PUSH
88394: LD_INT 36
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: LIST
88417: LIST
88418: LIST
88419: LIST
88420: LIST
88421: LIST
88422: LIST
88423: LIST
88424: LIST
88425: LIST
88426: LIST
88427: PUSH
88428: LD_INT 101
88430: PUSH
88431: LD_INT 102
88433: PUSH
88434: LD_INT 103
88436: PUSH
88437: LD_INT 104
88439: PUSH
88440: LD_INT 105
88442: PUSH
88443: LD_INT 106
88445: PUSH
88446: LD_INT 107
88448: PUSH
88449: LD_INT 108
88451: PUSH
88452: LD_INT 109
88454: PUSH
88455: LD_INT 110
88457: PUSH
88458: LD_INT 111
88460: PUSH
88461: LD_INT 112
88463: PUSH
88464: LD_INT 114
88466: PUSH
88467: EMPTY
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: PUSH
88482: EMPTY
88483: LIST
88484: LIST
88485: ST_TO_ADDR
88486: GO 90273
88488: LD_INT 11
88490: DOUBLE
88491: EQUAL
88492: IFTRUE 88496
88494: GO 88688
88496: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
88497: LD_ADDR_VAR 0 1
88501: PUSH
88502: LD_INT 2
88504: PUSH
88505: LD_INT 3
88507: PUSH
88508: LD_INT 4
88510: PUSH
88511: LD_INT 5
88513: PUSH
88514: LD_INT 6
88516: PUSH
88517: LD_INT 7
88519: PUSH
88520: LD_INT 8
88522: PUSH
88523: LD_INT 9
88525: PUSH
88526: LD_INT 10
88528: PUSH
88529: LD_INT 11
88531: PUSH
88532: LD_INT 12
88534: PUSH
88535: LD_INT 13
88537: PUSH
88538: LD_INT 14
88540: PUSH
88541: LD_INT 15
88543: PUSH
88544: LD_INT 16
88546: PUSH
88547: LD_INT 17
88549: PUSH
88550: LD_INT 18
88552: PUSH
88553: LD_INT 19
88555: PUSH
88556: LD_INT 20
88558: PUSH
88559: LD_INT 21
88561: PUSH
88562: LD_INT 22
88564: PUSH
88565: LD_INT 23
88567: PUSH
88568: LD_INT 24
88570: PUSH
88571: LD_INT 25
88573: PUSH
88574: LD_INT 26
88576: PUSH
88577: LD_INT 28
88579: PUSH
88580: LD_INT 30
88582: PUSH
88583: LD_INT 31
88585: PUSH
88586: LD_INT 32
88588: PUSH
88589: LD_INT 34
88591: PUSH
88592: LD_INT 36
88594: PUSH
88595: EMPTY
88596: LIST
88597: LIST
88598: LIST
88599: LIST
88600: LIST
88601: LIST
88602: LIST
88603: LIST
88604: LIST
88605: LIST
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: LIST
88617: LIST
88618: LIST
88619: LIST
88620: LIST
88621: LIST
88622: LIST
88623: LIST
88624: LIST
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 101
88630: PUSH
88631: LD_INT 102
88633: PUSH
88634: LD_INT 103
88636: PUSH
88637: LD_INT 104
88639: PUSH
88640: LD_INT 105
88642: PUSH
88643: LD_INT 106
88645: PUSH
88646: LD_INT 107
88648: PUSH
88649: LD_INT 108
88651: PUSH
88652: LD_INT 109
88654: PUSH
88655: LD_INT 110
88657: PUSH
88658: LD_INT 111
88660: PUSH
88661: LD_INT 112
88663: PUSH
88664: LD_INT 114
88666: PUSH
88667: EMPTY
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: LIST
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: PUSH
88682: EMPTY
88683: LIST
88684: LIST
88685: ST_TO_ADDR
88686: GO 90273
88688: LD_INT 12
88690: DOUBLE
88691: EQUAL
88692: IFTRUE 88696
88694: GO 88904
88696: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
88697: LD_ADDR_VAR 0 1
88701: PUSH
88702: LD_INT 1
88704: PUSH
88705: LD_INT 2
88707: PUSH
88708: LD_INT 3
88710: PUSH
88711: LD_INT 4
88713: PUSH
88714: LD_INT 5
88716: PUSH
88717: LD_INT 6
88719: PUSH
88720: LD_INT 7
88722: PUSH
88723: LD_INT 8
88725: PUSH
88726: LD_INT 9
88728: PUSH
88729: LD_INT 10
88731: PUSH
88732: LD_INT 11
88734: PUSH
88735: LD_INT 12
88737: PUSH
88738: LD_INT 13
88740: PUSH
88741: LD_INT 14
88743: PUSH
88744: LD_INT 15
88746: PUSH
88747: LD_INT 16
88749: PUSH
88750: LD_INT 17
88752: PUSH
88753: LD_INT 18
88755: PUSH
88756: LD_INT 19
88758: PUSH
88759: LD_INT 20
88761: PUSH
88762: LD_INT 21
88764: PUSH
88765: LD_INT 22
88767: PUSH
88768: LD_INT 23
88770: PUSH
88771: LD_INT 24
88773: PUSH
88774: LD_INT 25
88776: PUSH
88777: LD_INT 26
88779: PUSH
88780: LD_INT 27
88782: PUSH
88783: LD_INT 28
88785: PUSH
88786: LD_INT 30
88788: PUSH
88789: LD_INT 31
88791: PUSH
88792: LD_INT 32
88794: PUSH
88795: LD_INT 33
88797: PUSH
88798: LD_INT 34
88800: PUSH
88801: LD_INT 36
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: LIST
88816: LIST
88817: LIST
88818: LIST
88819: LIST
88820: LIST
88821: LIST
88822: LIST
88823: LIST
88824: LIST
88825: LIST
88826: LIST
88827: LIST
88828: LIST
88829: LIST
88830: LIST
88831: LIST
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: LIST
88837: LIST
88838: LIST
88839: PUSH
88840: LD_INT 101
88842: PUSH
88843: LD_INT 102
88845: PUSH
88846: LD_INT 103
88848: PUSH
88849: LD_INT 104
88851: PUSH
88852: LD_INT 105
88854: PUSH
88855: LD_INT 106
88857: PUSH
88858: LD_INT 107
88860: PUSH
88861: LD_INT 108
88863: PUSH
88864: LD_INT 109
88866: PUSH
88867: LD_INT 110
88869: PUSH
88870: LD_INT 111
88872: PUSH
88873: LD_INT 112
88875: PUSH
88876: LD_INT 113
88878: PUSH
88879: LD_INT 114
88881: PUSH
88882: EMPTY
88883: LIST
88884: LIST
88885: LIST
88886: LIST
88887: LIST
88888: LIST
88889: LIST
88890: LIST
88891: LIST
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: LIST
88897: PUSH
88898: EMPTY
88899: LIST
88900: LIST
88901: ST_TO_ADDR
88902: GO 90273
88904: LD_INT 13
88906: DOUBLE
88907: EQUAL
88908: IFTRUE 88912
88910: GO 89108
88912: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
88913: LD_ADDR_VAR 0 1
88917: PUSH
88918: LD_INT 1
88920: PUSH
88921: LD_INT 2
88923: PUSH
88924: LD_INT 3
88926: PUSH
88927: LD_INT 4
88929: PUSH
88930: LD_INT 5
88932: PUSH
88933: LD_INT 8
88935: PUSH
88936: LD_INT 9
88938: PUSH
88939: LD_INT 10
88941: PUSH
88942: LD_INT 11
88944: PUSH
88945: LD_INT 12
88947: PUSH
88948: LD_INT 14
88950: PUSH
88951: LD_INT 15
88953: PUSH
88954: LD_INT 16
88956: PUSH
88957: LD_INT 17
88959: PUSH
88960: LD_INT 18
88962: PUSH
88963: LD_INT 19
88965: PUSH
88966: LD_INT 20
88968: PUSH
88969: LD_INT 21
88971: PUSH
88972: LD_INT 22
88974: PUSH
88975: LD_INT 23
88977: PUSH
88978: LD_INT 24
88980: PUSH
88981: LD_INT 25
88983: PUSH
88984: LD_INT 26
88986: PUSH
88987: LD_INT 27
88989: PUSH
88990: LD_INT 28
88992: PUSH
88993: LD_INT 30
88995: PUSH
88996: LD_INT 31
88998: PUSH
88999: LD_INT 32
89001: PUSH
89002: LD_INT 33
89004: PUSH
89005: LD_INT 34
89007: PUSH
89008: LD_INT 36
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: LIST
89032: LIST
89033: LIST
89034: LIST
89035: LIST
89036: LIST
89037: LIST
89038: LIST
89039: LIST
89040: LIST
89041: LIST
89042: LIST
89043: PUSH
89044: LD_INT 101
89046: PUSH
89047: LD_INT 102
89049: PUSH
89050: LD_INT 103
89052: PUSH
89053: LD_INT 104
89055: PUSH
89056: LD_INT 105
89058: PUSH
89059: LD_INT 106
89061: PUSH
89062: LD_INT 107
89064: PUSH
89065: LD_INT 108
89067: PUSH
89068: LD_INT 109
89070: PUSH
89071: LD_INT 110
89073: PUSH
89074: LD_INT 111
89076: PUSH
89077: LD_INT 112
89079: PUSH
89080: LD_INT 113
89082: PUSH
89083: LD_INT 114
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: LIST
89090: LIST
89091: LIST
89092: LIST
89093: LIST
89094: LIST
89095: LIST
89096: LIST
89097: LIST
89098: LIST
89099: LIST
89100: LIST
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: ST_TO_ADDR
89106: GO 90273
89108: LD_INT 14
89110: DOUBLE
89111: EQUAL
89112: IFTRUE 89116
89114: GO 89328
89116: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
89117: LD_ADDR_VAR 0 1
89121: PUSH
89122: LD_INT 1
89124: PUSH
89125: LD_INT 2
89127: PUSH
89128: LD_INT 3
89130: PUSH
89131: LD_INT 4
89133: PUSH
89134: LD_INT 5
89136: PUSH
89137: LD_INT 6
89139: PUSH
89140: LD_INT 7
89142: PUSH
89143: LD_INT 8
89145: PUSH
89146: LD_INT 9
89148: PUSH
89149: LD_INT 10
89151: PUSH
89152: LD_INT 11
89154: PUSH
89155: LD_INT 12
89157: PUSH
89158: LD_INT 13
89160: PUSH
89161: LD_INT 14
89163: PUSH
89164: LD_INT 15
89166: PUSH
89167: LD_INT 16
89169: PUSH
89170: LD_INT 17
89172: PUSH
89173: LD_INT 18
89175: PUSH
89176: LD_INT 19
89178: PUSH
89179: LD_INT 20
89181: PUSH
89182: LD_INT 21
89184: PUSH
89185: LD_INT 22
89187: PUSH
89188: LD_INT 23
89190: PUSH
89191: LD_INT 24
89193: PUSH
89194: LD_INT 25
89196: PUSH
89197: LD_INT 26
89199: PUSH
89200: LD_INT 27
89202: PUSH
89203: LD_INT 28
89205: PUSH
89206: LD_INT 29
89208: PUSH
89209: LD_INT 30
89211: PUSH
89212: LD_INT 31
89214: PUSH
89215: LD_INT 32
89217: PUSH
89218: LD_INT 33
89220: PUSH
89221: LD_INT 34
89223: PUSH
89224: LD_INT 36
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: LIST
89237: LIST
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: PUSH
89264: LD_INT 101
89266: PUSH
89267: LD_INT 102
89269: PUSH
89270: LD_INT 103
89272: PUSH
89273: LD_INT 104
89275: PUSH
89276: LD_INT 105
89278: PUSH
89279: LD_INT 106
89281: PUSH
89282: LD_INT 107
89284: PUSH
89285: LD_INT 108
89287: PUSH
89288: LD_INT 109
89290: PUSH
89291: LD_INT 110
89293: PUSH
89294: LD_INT 111
89296: PUSH
89297: LD_INT 112
89299: PUSH
89300: LD_INT 113
89302: PUSH
89303: LD_INT 114
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: LIST
89310: LIST
89311: LIST
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: PUSH
89322: EMPTY
89323: LIST
89324: LIST
89325: ST_TO_ADDR
89326: GO 90273
89328: LD_INT 15
89330: DOUBLE
89331: EQUAL
89332: IFTRUE 89336
89334: GO 89548
89336: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
89337: LD_ADDR_VAR 0 1
89341: PUSH
89342: LD_INT 1
89344: PUSH
89345: LD_INT 2
89347: PUSH
89348: LD_INT 3
89350: PUSH
89351: LD_INT 4
89353: PUSH
89354: LD_INT 5
89356: PUSH
89357: LD_INT 6
89359: PUSH
89360: LD_INT 7
89362: PUSH
89363: LD_INT 8
89365: PUSH
89366: LD_INT 9
89368: PUSH
89369: LD_INT 10
89371: PUSH
89372: LD_INT 11
89374: PUSH
89375: LD_INT 12
89377: PUSH
89378: LD_INT 13
89380: PUSH
89381: LD_INT 14
89383: PUSH
89384: LD_INT 15
89386: PUSH
89387: LD_INT 16
89389: PUSH
89390: LD_INT 17
89392: PUSH
89393: LD_INT 18
89395: PUSH
89396: LD_INT 19
89398: PUSH
89399: LD_INT 20
89401: PUSH
89402: LD_INT 21
89404: PUSH
89405: LD_INT 22
89407: PUSH
89408: LD_INT 23
89410: PUSH
89411: LD_INT 24
89413: PUSH
89414: LD_INT 25
89416: PUSH
89417: LD_INT 26
89419: PUSH
89420: LD_INT 27
89422: PUSH
89423: LD_INT 28
89425: PUSH
89426: LD_INT 29
89428: PUSH
89429: LD_INT 30
89431: PUSH
89432: LD_INT 31
89434: PUSH
89435: LD_INT 32
89437: PUSH
89438: LD_INT 33
89440: PUSH
89441: LD_INT 34
89443: PUSH
89444: LD_INT 36
89446: PUSH
89447: EMPTY
89448: LIST
89449: LIST
89450: LIST
89451: LIST
89452: LIST
89453: LIST
89454: LIST
89455: LIST
89456: LIST
89457: LIST
89458: LIST
89459: LIST
89460: LIST
89461: LIST
89462: LIST
89463: LIST
89464: LIST
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: LIST
89473: LIST
89474: LIST
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: PUSH
89484: LD_INT 101
89486: PUSH
89487: LD_INT 102
89489: PUSH
89490: LD_INT 103
89492: PUSH
89493: LD_INT 104
89495: PUSH
89496: LD_INT 105
89498: PUSH
89499: LD_INT 106
89501: PUSH
89502: LD_INT 107
89504: PUSH
89505: LD_INT 108
89507: PUSH
89508: LD_INT 109
89510: PUSH
89511: LD_INT 110
89513: PUSH
89514: LD_INT 111
89516: PUSH
89517: LD_INT 112
89519: PUSH
89520: LD_INT 113
89522: PUSH
89523: LD_INT 114
89525: PUSH
89526: EMPTY
89527: LIST
89528: LIST
89529: LIST
89530: LIST
89531: LIST
89532: LIST
89533: LIST
89534: LIST
89535: LIST
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: PUSH
89542: EMPTY
89543: LIST
89544: LIST
89545: ST_TO_ADDR
89546: GO 90273
89548: LD_INT 16
89550: DOUBLE
89551: EQUAL
89552: IFTRUE 89556
89554: GO 89680
89556: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
89557: LD_ADDR_VAR 0 1
89561: PUSH
89562: LD_INT 2
89564: PUSH
89565: LD_INT 4
89567: PUSH
89568: LD_INT 5
89570: PUSH
89571: LD_INT 7
89573: PUSH
89574: LD_INT 11
89576: PUSH
89577: LD_INT 12
89579: PUSH
89580: LD_INT 15
89582: PUSH
89583: LD_INT 16
89585: PUSH
89586: LD_INT 20
89588: PUSH
89589: LD_INT 21
89591: PUSH
89592: LD_INT 22
89594: PUSH
89595: LD_INT 23
89597: PUSH
89598: LD_INT 25
89600: PUSH
89601: LD_INT 26
89603: PUSH
89604: LD_INT 30
89606: PUSH
89607: LD_INT 31
89609: PUSH
89610: LD_INT 32
89612: PUSH
89613: LD_INT 33
89615: PUSH
89616: LD_INT 34
89618: PUSH
89619: EMPTY
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: LIST
89625: LIST
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: LIST
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: PUSH
89640: LD_INT 101
89642: PUSH
89643: LD_INT 102
89645: PUSH
89646: LD_INT 103
89648: PUSH
89649: LD_INT 106
89651: PUSH
89652: LD_INT 108
89654: PUSH
89655: LD_INT 112
89657: PUSH
89658: LD_INT 113
89660: PUSH
89661: LD_INT 114
89663: PUSH
89664: EMPTY
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: LIST
89671: LIST
89672: LIST
89673: PUSH
89674: EMPTY
89675: LIST
89676: LIST
89677: ST_TO_ADDR
89678: GO 90273
89680: LD_INT 17
89682: DOUBLE
89683: EQUAL
89684: IFTRUE 89688
89686: GO 89900
89688: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
89689: LD_ADDR_VAR 0 1
89693: PUSH
89694: LD_INT 1
89696: PUSH
89697: LD_INT 2
89699: PUSH
89700: LD_INT 3
89702: PUSH
89703: LD_INT 4
89705: PUSH
89706: LD_INT 5
89708: PUSH
89709: LD_INT 6
89711: PUSH
89712: LD_INT 7
89714: PUSH
89715: LD_INT 8
89717: PUSH
89718: LD_INT 9
89720: PUSH
89721: LD_INT 10
89723: PUSH
89724: LD_INT 11
89726: PUSH
89727: LD_INT 12
89729: PUSH
89730: LD_INT 13
89732: PUSH
89733: LD_INT 14
89735: PUSH
89736: LD_INT 15
89738: PUSH
89739: LD_INT 16
89741: PUSH
89742: LD_INT 17
89744: PUSH
89745: LD_INT 18
89747: PUSH
89748: LD_INT 19
89750: PUSH
89751: LD_INT 20
89753: PUSH
89754: LD_INT 21
89756: PUSH
89757: LD_INT 22
89759: PUSH
89760: LD_INT 23
89762: PUSH
89763: LD_INT 24
89765: PUSH
89766: LD_INT 25
89768: PUSH
89769: LD_INT 26
89771: PUSH
89772: LD_INT 27
89774: PUSH
89775: LD_INT 28
89777: PUSH
89778: LD_INT 29
89780: PUSH
89781: LD_INT 30
89783: PUSH
89784: LD_INT 31
89786: PUSH
89787: LD_INT 32
89789: PUSH
89790: LD_INT 33
89792: PUSH
89793: LD_INT 34
89795: PUSH
89796: LD_INT 36
89798: PUSH
89799: EMPTY
89800: LIST
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: LIST
89809: LIST
89810: LIST
89811: LIST
89812: LIST
89813: LIST
89814: LIST
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: LIST
89821: LIST
89822: LIST
89823: LIST
89824: LIST
89825: LIST
89826: LIST
89827: LIST
89828: LIST
89829: LIST
89830: LIST
89831: LIST
89832: LIST
89833: LIST
89834: LIST
89835: PUSH
89836: LD_INT 101
89838: PUSH
89839: LD_INT 102
89841: PUSH
89842: LD_INT 103
89844: PUSH
89845: LD_INT 104
89847: PUSH
89848: LD_INT 105
89850: PUSH
89851: LD_INT 106
89853: PUSH
89854: LD_INT 107
89856: PUSH
89857: LD_INT 108
89859: PUSH
89860: LD_INT 109
89862: PUSH
89863: LD_INT 110
89865: PUSH
89866: LD_INT 111
89868: PUSH
89869: LD_INT 112
89871: PUSH
89872: LD_INT 113
89874: PUSH
89875: LD_INT 114
89877: PUSH
89878: EMPTY
89879: LIST
89880: LIST
89881: LIST
89882: LIST
89883: LIST
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: LIST
89892: LIST
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: ST_TO_ADDR
89898: GO 90273
89900: LD_INT 18
89902: DOUBLE
89903: EQUAL
89904: IFTRUE 89908
89906: GO 90044
89908: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
89909: LD_ADDR_VAR 0 1
89913: PUSH
89914: LD_INT 2
89916: PUSH
89917: LD_INT 4
89919: PUSH
89920: LD_INT 5
89922: PUSH
89923: LD_INT 7
89925: PUSH
89926: LD_INT 11
89928: PUSH
89929: LD_INT 12
89931: PUSH
89932: LD_INT 15
89934: PUSH
89935: LD_INT 16
89937: PUSH
89938: LD_INT 20
89940: PUSH
89941: LD_INT 21
89943: PUSH
89944: LD_INT 22
89946: PUSH
89947: LD_INT 23
89949: PUSH
89950: LD_INT 25
89952: PUSH
89953: LD_INT 26
89955: PUSH
89956: LD_INT 30
89958: PUSH
89959: LD_INT 31
89961: PUSH
89962: LD_INT 32
89964: PUSH
89965: LD_INT 33
89967: PUSH
89968: LD_INT 34
89970: PUSH
89971: LD_INT 35
89973: PUSH
89974: LD_INT 36
89976: PUSH
89977: EMPTY
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: LIST
89991: LIST
89992: LIST
89993: LIST
89994: LIST
89995: LIST
89996: LIST
89997: LIST
89998: LIST
89999: PUSH
90000: LD_INT 101
90002: PUSH
90003: LD_INT 102
90005: PUSH
90006: LD_INT 103
90008: PUSH
90009: LD_INT 106
90011: PUSH
90012: LD_INT 108
90014: PUSH
90015: LD_INT 112
90017: PUSH
90018: LD_INT 113
90020: PUSH
90021: LD_INT 114
90023: PUSH
90024: LD_INT 115
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: LIST
90031: LIST
90032: LIST
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: ST_TO_ADDR
90042: GO 90273
90044: LD_INT 19
90046: DOUBLE
90047: EQUAL
90048: IFTRUE 90052
90050: GO 90272
90052: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
90053: LD_ADDR_VAR 0 1
90057: PUSH
90058: LD_INT 1
90060: PUSH
90061: LD_INT 2
90063: PUSH
90064: LD_INT 3
90066: PUSH
90067: LD_INT 4
90069: PUSH
90070: LD_INT 5
90072: PUSH
90073: LD_INT 6
90075: PUSH
90076: LD_INT 7
90078: PUSH
90079: LD_INT 8
90081: PUSH
90082: LD_INT 9
90084: PUSH
90085: LD_INT 10
90087: PUSH
90088: LD_INT 11
90090: PUSH
90091: LD_INT 12
90093: PUSH
90094: LD_INT 13
90096: PUSH
90097: LD_INT 14
90099: PUSH
90100: LD_INT 15
90102: PUSH
90103: LD_INT 16
90105: PUSH
90106: LD_INT 17
90108: PUSH
90109: LD_INT 18
90111: PUSH
90112: LD_INT 19
90114: PUSH
90115: LD_INT 20
90117: PUSH
90118: LD_INT 21
90120: PUSH
90121: LD_INT 22
90123: PUSH
90124: LD_INT 23
90126: PUSH
90127: LD_INT 24
90129: PUSH
90130: LD_INT 25
90132: PUSH
90133: LD_INT 26
90135: PUSH
90136: LD_INT 27
90138: PUSH
90139: LD_INT 28
90141: PUSH
90142: LD_INT 29
90144: PUSH
90145: LD_INT 30
90147: PUSH
90148: LD_INT 31
90150: PUSH
90151: LD_INT 32
90153: PUSH
90154: LD_INT 33
90156: PUSH
90157: LD_INT 34
90159: PUSH
90160: LD_INT 35
90162: PUSH
90163: LD_INT 36
90165: PUSH
90166: EMPTY
90167: LIST
90168: LIST
90169: LIST
90170: LIST
90171: LIST
90172: LIST
90173: LIST
90174: LIST
90175: LIST
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: LIST
90193: LIST
90194: LIST
90195: LIST
90196: LIST
90197: LIST
90198: LIST
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: PUSH
90204: LD_INT 101
90206: PUSH
90207: LD_INT 102
90209: PUSH
90210: LD_INT 103
90212: PUSH
90213: LD_INT 104
90215: PUSH
90216: LD_INT 105
90218: PUSH
90219: LD_INT 106
90221: PUSH
90222: LD_INT 107
90224: PUSH
90225: LD_INT 108
90227: PUSH
90228: LD_INT 109
90230: PUSH
90231: LD_INT 110
90233: PUSH
90234: LD_INT 111
90236: PUSH
90237: LD_INT 112
90239: PUSH
90240: LD_INT 113
90242: PUSH
90243: LD_INT 114
90245: PUSH
90246: LD_INT 115
90248: PUSH
90249: EMPTY
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: PUSH
90266: EMPTY
90267: LIST
90268: LIST
90269: ST_TO_ADDR
90270: GO 90273
90272: POP
// end else
90273: GO 90492
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
90275: LD_ADDR_VAR 0 1
90279: PUSH
90280: LD_INT 1
90282: PUSH
90283: LD_INT 2
90285: PUSH
90286: LD_INT 3
90288: PUSH
90289: LD_INT 4
90291: PUSH
90292: LD_INT 5
90294: PUSH
90295: LD_INT 6
90297: PUSH
90298: LD_INT 7
90300: PUSH
90301: LD_INT 8
90303: PUSH
90304: LD_INT 9
90306: PUSH
90307: LD_INT 10
90309: PUSH
90310: LD_INT 11
90312: PUSH
90313: LD_INT 12
90315: PUSH
90316: LD_INT 13
90318: PUSH
90319: LD_INT 14
90321: PUSH
90322: LD_INT 15
90324: PUSH
90325: LD_INT 16
90327: PUSH
90328: LD_INT 17
90330: PUSH
90331: LD_INT 18
90333: PUSH
90334: LD_INT 19
90336: PUSH
90337: LD_INT 20
90339: PUSH
90340: LD_INT 21
90342: PUSH
90343: LD_INT 22
90345: PUSH
90346: LD_INT 23
90348: PUSH
90349: LD_INT 24
90351: PUSH
90352: LD_INT 25
90354: PUSH
90355: LD_INT 26
90357: PUSH
90358: LD_INT 27
90360: PUSH
90361: LD_INT 28
90363: PUSH
90364: LD_INT 29
90366: PUSH
90367: LD_INT 30
90369: PUSH
90370: LD_INT 31
90372: PUSH
90373: LD_INT 32
90375: PUSH
90376: LD_INT 33
90378: PUSH
90379: LD_INT 34
90381: PUSH
90382: LD_INT 35
90384: PUSH
90385: LD_INT 36
90387: PUSH
90388: EMPTY
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: LIST
90396: LIST
90397: LIST
90398: LIST
90399: LIST
90400: LIST
90401: LIST
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: LIST
90417: LIST
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: PUSH
90426: LD_INT 101
90428: PUSH
90429: LD_INT 102
90431: PUSH
90432: LD_INT 103
90434: PUSH
90435: LD_INT 104
90437: PUSH
90438: LD_INT 105
90440: PUSH
90441: LD_INT 106
90443: PUSH
90444: LD_INT 107
90446: PUSH
90447: LD_INT 108
90449: PUSH
90450: LD_INT 109
90452: PUSH
90453: LD_INT 110
90455: PUSH
90456: LD_INT 111
90458: PUSH
90459: LD_INT 112
90461: PUSH
90462: LD_INT 113
90464: PUSH
90465: LD_INT 114
90467: PUSH
90468: LD_INT 115
90470: PUSH
90471: EMPTY
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: LIST
90486: LIST
90487: PUSH
90488: EMPTY
90489: LIST
90490: LIST
90491: ST_TO_ADDR
// if result then
90492: LD_VAR 0 1
90496: IFFALSE 90785
// begin normal :=  ;
90498: LD_ADDR_VAR 0 3
90502: PUSH
90503: LD_STRING 
90505: ST_TO_ADDR
// hardcore :=  ;
90506: LD_ADDR_VAR 0 4
90510: PUSH
90511: LD_STRING 
90513: ST_TO_ADDR
// for i = 1 to normalCounter do
90514: LD_ADDR_VAR 0 5
90518: PUSH
90519: DOUBLE
90520: LD_INT 1
90522: DEC
90523: ST_TO_ADDR
90524: LD_EXP 110
90528: PUSH
90529: FOR_TO
90530: IFFALSE 90631
// begin tmp := 0 ;
90532: LD_ADDR_VAR 0 2
90536: PUSH
90537: LD_STRING 0
90539: ST_TO_ADDR
// if result [ 1 ] then
90540: LD_VAR 0 1
90544: PUSH
90545: LD_INT 1
90547: ARRAY
90548: IFFALSE 90613
// if result [ 1 ] [ 1 ] = i then
90550: LD_VAR 0 1
90554: PUSH
90555: LD_INT 1
90557: ARRAY
90558: PUSH
90559: LD_INT 1
90561: ARRAY
90562: PUSH
90563: LD_VAR 0 5
90567: EQUAL
90568: IFFALSE 90613
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
90570: LD_ADDR_VAR 0 1
90574: PUSH
90575: LD_VAR 0 1
90579: PPUSH
90580: LD_INT 1
90582: PPUSH
90583: LD_VAR 0 1
90587: PUSH
90588: LD_INT 1
90590: ARRAY
90591: PPUSH
90592: LD_INT 1
90594: PPUSH
90595: CALL_OW 3
90599: PPUSH
90600: CALL_OW 1
90604: ST_TO_ADDR
// tmp := 1 ;
90605: LD_ADDR_VAR 0 2
90609: PUSH
90610: LD_STRING 1
90612: ST_TO_ADDR
// end ; normal := normal & tmp ;
90613: LD_ADDR_VAR 0 3
90617: PUSH
90618: LD_VAR 0 3
90622: PUSH
90623: LD_VAR 0 2
90627: STR
90628: ST_TO_ADDR
// end ;
90629: GO 90529
90631: POP
90632: POP
// for i = 1 to hardcoreCounter do
90633: LD_ADDR_VAR 0 5
90637: PUSH
90638: DOUBLE
90639: LD_INT 1
90641: DEC
90642: ST_TO_ADDR
90643: LD_EXP 111
90647: PUSH
90648: FOR_TO
90649: IFFALSE 90754
// begin tmp := 0 ;
90651: LD_ADDR_VAR 0 2
90655: PUSH
90656: LD_STRING 0
90658: ST_TO_ADDR
// if result [ 2 ] then
90659: LD_VAR 0 1
90663: PUSH
90664: LD_INT 2
90666: ARRAY
90667: IFFALSE 90736
// if result [ 2 ] [ 1 ] = 100 + i then
90669: LD_VAR 0 1
90673: PUSH
90674: LD_INT 2
90676: ARRAY
90677: PUSH
90678: LD_INT 1
90680: ARRAY
90681: PUSH
90682: LD_INT 100
90684: PUSH
90685: LD_VAR 0 5
90689: PLUS
90690: EQUAL
90691: IFFALSE 90736
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
90693: LD_ADDR_VAR 0 1
90697: PUSH
90698: LD_VAR 0 1
90702: PPUSH
90703: LD_INT 2
90705: PPUSH
90706: LD_VAR 0 1
90710: PUSH
90711: LD_INT 2
90713: ARRAY
90714: PPUSH
90715: LD_INT 1
90717: PPUSH
90718: CALL_OW 3
90722: PPUSH
90723: CALL_OW 1
90727: ST_TO_ADDR
// tmp := 1 ;
90728: LD_ADDR_VAR 0 2
90732: PUSH
90733: LD_STRING 1
90735: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
90736: LD_ADDR_VAR 0 4
90740: PUSH
90741: LD_VAR 0 4
90745: PUSH
90746: LD_VAR 0 2
90750: STR
90751: ST_TO_ADDR
// end ;
90752: GO 90648
90754: POP
90755: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
90756: LD_STRING getStreamItemsFromMission("
90758: PUSH
90759: LD_VAR 0 3
90763: STR
90764: PUSH
90765: LD_STRING ","
90767: STR
90768: PUSH
90769: LD_VAR 0 4
90773: STR
90774: PUSH
90775: LD_STRING ")
90777: STR
90778: PPUSH
90779: CALL_OW 559
// end else
90783: GO 90792
// ToLua ( getStreamItemsFromMission("","") ) ;
90785: LD_STRING getStreamItemsFromMission("","")
90787: PPUSH
90788: CALL_OW 559
// end ;
90792: LD_VAR 0 1
90796: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
90797: LD_EXP 109
90801: PUSH
90802: LD_EXP 114
90806: AND
90807: IFFALSE 90931
90809: GO 90811
90811: DISABLE
90812: LD_INT 0
90814: PPUSH
90815: PPUSH
// begin enable ;
90816: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
90817: LD_ADDR_VAR 0 2
90821: PUSH
90822: LD_INT 22
90824: PUSH
90825: LD_OWVAR 2
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: PUSH
90834: LD_INT 2
90836: PUSH
90837: LD_INT 34
90839: PUSH
90840: LD_INT 7
90842: PUSH
90843: EMPTY
90844: LIST
90845: LIST
90846: PUSH
90847: LD_INT 34
90849: PUSH
90850: LD_INT 45
90852: PUSH
90853: EMPTY
90854: LIST
90855: LIST
90856: PUSH
90857: LD_INT 34
90859: PUSH
90860: LD_INT 28
90862: PUSH
90863: EMPTY
90864: LIST
90865: LIST
90866: PUSH
90867: LD_INT 34
90869: PUSH
90870: LD_INT 47
90872: PUSH
90873: EMPTY
90874: LIST
90875: LIST
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: PUSH
90884: EMPTY
90885: LIST
90886: LIST
90887: PPUSH
90888: CALL_OW 69
90892: ST_TO_ADDR
// if not tmp then
90893: LD_VAR 0 2
90897: NOT
90898: IFFALSE 90902
// exit ;
90900: GO 90931
// for i in tmp do
90902: LD_ADDR_VAR 0 1
90906: PUSH
90907: LD_VAR 0 2
90911: PUSH
90912: FOR_IN
90913: IFFALSE 90929
// begin SetLives ( i , 0 ) ;
90915: LD_VAR 0 1
90919: PPUSH
90920: LD_INT 0
90922: PPUSH
90923: CALL_OW 234
// end ;
90927: GO 90912
90929: POP
90930: POP
// end ;
90931: PPOPN 2
90933: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
90934: LD_EXP 109
90938: PUSH
90939: LD_EXP 115
90943: AND
90944: IFFALSE 91028
90946: GO 90948
90948: DISABLE
90949: LD_INT 0
90951: PPUSH
90952: PPUSH
// begin enable ;
90953: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
90954: LD_ADDR_VAR 0 2
90958: PUSH
90959: LD_INT 22
90961: PUSH
90962: LD_OWVAR 2
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: PUSH
90971: LD_INT 32
90973: PUSH
90974: LD_INT 3
90976: PUSH
90977: EMPTY
90978: LIST
90979: LIST
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PPUSH
90985: CALL_OW 69
90989: ST_TO_ADDR
// if not tmp then
90990: LD_VAR 0 2
90994: NOT
90995: IFFALSE 90999
// exit ;
90997: GO 91028
// for i in tmp do
90999: LD_ADDR_VAR 0 1
91003: PUSH
91004: LD_VAR 0 2
91008: PUSH
91009: FOR_IN
91010: IFFALSE 91026
// begin SetLives ( i , 0 ) ;
91012: LD_VAR 0 1
91016: PPUSH
91017: LD_INT 0
91019: PPUSH
91020: CALL_OW 234
// end ;
91024: GO 91009
91026: POP
91027: POP
// end ;
91028: PPOPN 2
91030: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
91031: LD_EXP 109
91035: PUSH
91036: LD_EXP 112
91040: AND
91041: IFFALSE 91134
91043: GO 91045
91045: DISABLE
91046: LD_INT 0
91048: PPUSH
// begin enable ;
91049: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
91050: LD_ADDR_VAR 0 1
91054: PUSH
91055: LD_INT 22
91057: PUSH
91058: LD_OWVAR 2
91062: PUSH
91063: EMPTY
91064: LIST
91065: LIST
91066: PUSH
91067: LD_INT 2
91069: PUSH
91070: LD_INT 25
91072: PUSH
91073: LD_INT 5
91075: PUSH
91076: EMPTY
91077: LIST
91078: LIST
91079: PUSH
91080: LD_INT 25
91082: PUSH
91083: LD_INT 9
91085: PUSH
91086: EMPTY
91087: LIST
91088: LIST
91089: PUSH
91090: LD_INT 25
91092: PUSH
91093: LD_INT 8
91095: PUSH
91096: EMPTY
91097: LIST
91098: LIST
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: LIST
91104: LIST
91105: PUSH
91106: EMPTY
91107: LIST
91108: LIST
91109: PPUSH
91110: CALL_OW 69
91114: PUSH
91115: FOR_IN
91116: IFFALSE 91132
// begin SetClass ( i , 1 ) ;
91118: LD_VAR 0 1
91122: PPUSH
91123: LD_INT 1
91125: PPUSH
91126: CALL_OW 336
// end ;
91130: GO 91115
91132: POP
91133: POP
// end ;
91134: PPOPN 1
91136: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
91137: LD_EXP 109
91141: PUSH
91142: LD_EXP 113
91146: AND
91147: PUSH
91148: LD_OWVAR 65
91152: PUSH
91153: LD_INT 7
91155: LESS
91156: AND
91157: IFFALSE 91171
91159: GO 91161
91161: DISABLE
// begin enable ;
91162: ENABLE
// game_speed := 7 ;
91163: LD_ADDR_OWVAR 65
91167: PUSH
91168: LD_INT 7
91170: ST_TO_ADDR
// end ;
91171: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
91172: LD_EXP 109
91176: PUSH
91177: LD_EXP 116
91181: AND
91182: IFFALSE 91384
91184: GO 91186
91186: DISABLE
91187: LD_INT 0
91189: PPUSH
91190: PPUSH
91191: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
91192: LD_ADDR_VAR 0 3
91196: PUSH
91197: LD_INT 81
91199: PUSH
91200: LD_OWVAR 2
91204: PUSH
91205: EMPTY
91206: LIST
91207: LIST
91208: PUSH
91209: LD_INT 21
91211: PUSH
91212: LD_INT 1
91214: PUSH
91215: EMPTY
91216: LIST
91217: LIST
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: PPUSH
91223: CALL_OW 69
91227: ST_TO_ADDR
// if not tmp then
91228: LD_VAR 0 3
91232: NOT
91233: IFFALSE 91237
// exit ;
91235: GO 91384
// if tmp > 5 then
91237: LD_VAR 0 3
91241: PUSH
91242: LD_INT 5
91244: GREATER
91245: IFFALSE 91257
// k := 5 else
91247: LD_ADDR_VAR 0 2
91251: PUSH
91252: LD_INT 5
91254: ST_TO_ADDR
91255: GO 91267
// k := tmp ;
91257: LD_ADDR_VAR 0 2
91261: PUSH
91262: LD_VAR 0 3
91266: ST_TO_ADDR
// for i := 1 to k do
91267: LD_ADDR_VAR 0 1
91271: PUSH
91272: DOUBLE
91273: LD_INT 1
91275: DEC
91276: ST_TO_ADDR
91277: LD_VAR 0 2
91281: PUSH
91282: FOR_TO
91283: IFFALSE 91382
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
91285: LD_VAR 0 3
91289: PUSH
91290: LD_VAR 0 1
91294: ARRAY
91295: PPUSH
91296: LD_VAR 0 1
91300: PUSH
91301: LD_INT 4
91303: MOD
91304: PUSH
91305: LD_INT 1
91307: PLUS
91308: PPUSH
91309: CALL_OW 259
91313: PUSH
91314: LD_INT 10
91316: LESS
91317: IFFALSE 91380
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
91319: LD_VAR 0 3
91323: PUSH
91324: LD_VAR 0 1
91328: ARRAY
91329: PPUSH
91330: LD_VAR 0 1
91334: PUSH
91335: LD_INT 4
91337: MOD
91338: PUSH
91339: LD_INT 1
91341: PLUS
91342: PPUSH
91343: LD_VAR 0 3
91347: PUSH
91348: LD_VAR 0 1
91352: ARRAY
91353: PPUSH
91354: LD_VAR 0 1
91358: PUSH
91359: LD_INT 4
91361: MOD
91362: PUSH
91363: LD_INT 1
91365: PLUS
91366: PPUSH
91367: CALL_OW 259
91371: PUSH
91372: LD_INT 1
91374: PLUS
91375: PPUSH
91376: CALL_OW 237
91380: GO 91282
91382: POP
91383: POP
// end ;
91384: PPOPN 3
91386: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
91387: LD_EXP 109
91391: PUSH
91392: LD_EXP 117
91396: AND
91397: IFFALSE 91417
91399: GO 91401
91401: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
91402: LD_INT 4
91404: PPUSH
91405: LD_OWVAR 2
91409: PPUSH
91410: LD_INT 0
91412: PPUSH
91413: CALL_OW 324
91417: END
// every 0 0$1 trigger StreamModeActive and sShovel do
91418: LD_EXP 109
91422: PUSH
91423: LD_EXP 146
91427: AND
91428: IFFALSE 91448
91430: GO 91432
91432: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
91433: LD_INT 19
91435: PPUSH
91436: LD_OWVAR 2
91440: PPUSH
91441: LD_INT 0
91443: PPUSH
91444: CALL_OW 324
91448: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
91449: LD_EXP 109
91453: PUSH
91454: LD_EXP 118
91458: AND
91459: IFFALSE 91561
91461: GO 91463
91463: DISABLE
91464: LD_INT 0
91466: PPUSH
91467: PPUSH
// begin enable ;
91468: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
91469: LD_ADDR_VAR 0 2
91473: PUSH
91474: LD_INT 22
91476: PUSH
91477: LD_OWVAR 2
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: PUSH
91486: LD_INT 2
91488: PUSH
91489: LD_INT 34
91491: PUSH
91492: LD_INT 11
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 34
91501: PUSH
91502: LD_INT 30
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: LIST
91513: PUSH
91514: EMPTY
91515: LIST
91516: LIST
91517: PPUSH
91518: CALL_OW 69
91522: ST_TO_ADDR
// if not tmp then
91523: LD_VAR 0 2
91527: NOT
91528: IFFALSE 91532
// exit ;
91530: GO 91561
// for i in tmp do
91532: LD_ADDR_VAR 0 1
91536: PUSH
91537: LD_VAR 0 2
91541: PUSH
91542: FOR_IN
91543: IFFALSE 91559
// begin SetLives ( i , 0 ) ;
91545: LD_VAR 0 1
91549: PPUSH
91550: LD_INT 0
91552: PPUSH
91553: CALL_OW 234
// end ;
91557: GO 91542
91559: POP
91560: POP
// end ;
91561: PPOPN 2
91563: END
// every 0 0$1 trigger StreamModeActive and sBunker do
91564: LD_EXP 109
91568: PUSH
91569: LD_EXP 119
91573: AND
91574: IFFALSE 91594
91576: GO 91578
91578: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
91579: LD_INT 32
91581: PPUSH
91582: LD_OWVAR 2
91586: PPUSH
91587: LD_INT 0
91589: PPUSH
91590: CALL_OW 324
91594: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
91595: LD_EXP 109
91599: PUSH
91600: LD_EXP 120
91604: AND
91605: IFFALSE 91786
91607: GO 91609
91609: DISABLE
91610: LD_INT 0
91612: PPUSH
91613: PPUSH
91614: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
91615: LD_ADDR_VAR 0 2
91619: PUSH
91620: LD_INT 22
91622: PUSH
91623: LD_OWVAR 2
91627: PUSH
91628: EMPTY
91629: LIST
91630: LIST
91631: PUSH
91632: LD_INT 33
91634: PUSH
91635: LD_INT 3
91637: PUSH
91638: EMPTY
91639: LIST
91640: LIST
91641: PUSH
91642: EMPTY
91643: LIST
91644: LIST
91645: PPUSH
91646: CALL_OW 69
91650: ST_TO_ADDR
// if not tmp then
91651: LD_VAR 0 2
91655: NOT
91656: IFFALSE 91660
// exit ;
91658: GO 91786
// side := 0 ;
91660: LD_ADDR_VAR 0 3
91664: PUSH
91665: LD_INT 0
91667: ST_TO_ADDR
// for i := 1 to 8 do
91668: LD_ADDR_VAR 0 1
91672: PUSH
91673: DOUBLE
91674: LD_INT 1
91676: DEC
91677: ST_TO_ADDR
91678: LD_INT 8
91680: PUSH
91681: FOR_TO
91682: IFFALSE 91730
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
91684: LD_OWVAR 2
91688: PUSH
91689: LD_VAR 0 1
91693: NONEQUAL
91694: PUSH
91695: LD_OWVAR 2
91699: PPUSH
91700: LD_VAR 0 1
91704: PPUSH
91705: CALL_OW 81
91709: PUSH
91710: LD_INT 2
91712: EQUAL
91713: AND
91714: IFFALSE 91728
// begin side := i ;
91716: LD_ADDR_VAR 0 3
91720: PUSH
91721: LD_VAR 0 1
91725: ST_TO_ADDR
// break ;
91726: GO 91730
// end ;
91728: GO 91681
91730: POP
91731: POP
// if not side then
91732: LD_VAR 0 3
91736: NOT
91737: IFFALSE 91741
// exit ;
91739: GO 91786
// for i := 1 to tmp do
91741: LD_ADDR_VAR 0 1
91745: PUSH
91746: DOUBLE
91747: LD_INT 1
91749: DEC
91750: ST_TO_ADDR
91751: LD_VAR 0 2
91755: PUSH
91756: FOR_TO
91757: IFFALSE 91784
// if Prob ( 60 ) then
91759: LD_INT 60
91761: PPUSH
91762: CALL_OW 13
91766: IFFALSE 91782
// SetSide ( i , side ) ;
91768: LD_VAR 0 1
91772: PPUSH
91773: LD_VAR 0 3
91777: PPUSH
91778: CALL_OW 235
91782: GO 91756
91784: POP
91785: POP
// end ;
91786: PPOPN 3
91788: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
91789: LD_EXP 109
91793: PUSH
91794: LD_EXP 122
91798: AND
91799: IFFALSE 91918
91801: GO 91803
91803: DISABLE
91804: LD_INT 0
91806: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
91807: LD_ADDR_VAR 0 1
91811: PUSH
91812: LD_INT 22
91814: PUSH
91815: LD_OWVAR 2
91819: PUSH
91820: EMPTY
91821: LIST
91822: LIST
91823: PUSH
91824: LD_INT 21
91826: PUSH
91827: LD_INT 1
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: PUSH
91834: LD_INT 3
91836: PUSH
91837: LD_INT 23
91839: PUSH
91840: LD_INT 0
91842: PUSH
91843: EMPTY
91844: LIST
91845: LIST
91846: PUSH
91847: EMPTY
91848: LIST
91849: LIST
91850: PUSH
91851: EMPTY
91852: LIST
91853: LIST
91854: LIST
91855: PPUSH
91856: CALL_OW 69
91860: PUSH
91861: FOR_IN
91862: IFFALSE 91916
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
91864: LD_VAR 0 1
91868: PPUSH
91869: CALL_OW 257
91873: PUSH
91874: LD_INT 1
91876: PUSH
91877: LD_INT 2
91879: PUSH
91880: LD_INT 3
91882: PUSH
91883: LD_INT 4
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: LIST
91890: LIST
91891: IN
91892: IFFALSE 91914
// SetClass ( un , rand ( 1 , 4 ) ) ;
91894: LD_VAR 0 1
91898: PPUSH
91899: LD_INT 1
91901: PPUSH
91902: LD_INT 4
91904: PPUSH
91905: CALL_OW 12
91909: PPUSH
91910: CALL_OW 336
91914: GO 91861
91916: POP
91917: POP
// end ;
91918: PPOPN 1
91920: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
91921: LD_EXP 109
91925: PUSH
91926: LD_EXP 121
91930: AND
91931: IFFALSE 92010
91933: GO 91935
91935: DISABLE
91936: LD_INT 0
91938: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91939: LD_ADDR_VAR 0 1
91943: PUSH
91944: LD_INT 22
91946: PUSH
91947: LD_OWVAR 2
91951: PUSH
91952: EMPTY
91953: LIST
91954: LIST
91955: PUSH
91956: LD_INT 21
91958: PUSH
91959: LD_INT 3
91961: PUSH
91962: EMPTY
91963: LIST
91964: LIST
91965: PUSH
91966: EMPTY
91967: LIST
91968: LIST
91969: PPUSH
91970: CALL_OW 69
91974: ST_TO_ADDR
// if not tmp then
91975: LD_VAR 0 1
91979: NOT
91980: IFFALSE 91984
// exit ;
91982: GO 92010
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
91984: LD_VAR 0 1
91988: PUSH
91989: LD_INT 1
91991: PPUSH
91992: LD_VAR 0 1
91996: PPUSH
91997: CALL_OW 12
92001: ARRAY
92002: PPUSH
92003: LD_INT 100
92005: PPUSH
92006: CALL_OW 234
// end ;
92010: PPOPN 1
92012: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
92013: LD_EXP 109
92017: PUSH
92018: LD_EXP 123
92022: AND
92023: IFFALSE 92121
92025: GO 92027
92027: DISABLE
92028: LD_INT 0
92030: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92031: LD_ADDR_VAR 0 1
92035: PUSH
92036: LD_INT 22
92038: PUSH
92039: LD_OWVAR 2
92043: PUSH
92044: EMPTY
92045: LIST
92046: LIST
92047: PUSH
92048: LD_INT 21
92050: PUSH
92051: LD_INT 1
92053: PUSH
92054: EMPTY
92055: LIST
92056: LIST
92057: PUSH
92058: EMPTY
92059: LIST
92060: LIST
92061: PPUSH
92062: CALL_OW 69
92066: ST_TO_ADDR
// if not tmp then
92067: LD_VAR 0 1
92071: NOT
92072: IFFALSE 92076
// exit ;
92074: GO 92121
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
92076: LD_VAR 0 1
92080: PUSH
92081: LD_INT 1
92083: PPUSH
92084: LD_VAR 0 1
92088: PPUSH
92089: CALL_OW 12
92093: ARRAY
92094: PPUSH
92095: LD_INT 1
92097: PPUSH
92098: LD_INT 4
92100: PPUSH
92101: CALL_OW 12
92105: PPUSH
92106: LD_INT 3000
92108: PPUSH
92109: LD_INT 9000
92111: PPUSH
92112: CALL_OW 12
92116: PPUSH
92117: CALL_OW 492
// end ;
92121: PPOPN 1
92123: END
// every 0 0$1 trigger StreamModeActive and sDepot do
92124: LD_EXP 109
92128: PUSH
92129: LD_EXP 124
92133: AND
92134: IFFALSE 92154
92136: GO 92138
92138: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
92139: LD_INT 1
92141: PPUSH
92142: LD_OWVAR 2
92146: PPUSH
92147: LD_INT 0
92149: PPUSH
92150: CALL_OW 324
92154: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
92155: LD_EXP 109
92159: PUSH
92160: LD_EXP 125
92164: AND
92165: IFFALSE 92248
92167: GO 92169
92169: DISABLE
92170: LD_INT 0
92172: PPUSH
92173: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92174: LD_ADDR_VAR 0 2
92178: PUSH
92179: LD_INT 22
92181: PUSH
92182: LD_OWVAR 2
92186: PUSH
92187: EMPTY
92188: LIST
92189: LIST
92190: PUSH
92191: LD_INT 21
92193: PUSH
92194: LD_INT 3
92196: PUSH
92197: EMPTY
92198: LIST
92199: LIST
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PPUSH
92205: CALL_OW 69
92209: ST_TO_ADDR
// if not tmp then
92210: LD_VAR 0 2
92214: NOT
92215: IFFALSE 92219
// exit ;
92217: GO 92248
// for i in tmp do
92219: LD_ADDR_VAR 0 1
92223: PUSH
92224: LD_VAR 0 2
92228: PUSH
92229: FOR_IN
92230: IFFALSE 92246
// SetBLevel ( i , 10 ) ;
92232: LD_VAR 0 1
92236: PPUSH
92237: LD_INT 10
92239: PPUSH
92240: CALL_OW 241
92244: GO 92229
92246: POP
92247: POP
// end ;
92248: PPOPN 2
92250: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
92251: LD_EXP 109
92255: PUSH
92256: LD_EXP 126
92260: AND
92261: IFFALSE 92372
92263: GO 92265
92265: DISABLE
92266: LD_INT 0
92268: PPUSH
92269: PPUSH
92270: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92271: LD_ADDR_VAR 0 3
92275: PUSH
92276: LD_INT 22
92278: PUSH
92279: LD_OWVAR 2
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: LD_INT 25
92290: PUSH
92291: LD_INT 1
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: PPUSH
92302: CALL_OW 69
92306: ST_TO_ADDR
// if not tmp then
92307: LD_VAR 0 3
92311: NOT
92312: IFFALSE 92316
// exit ;
92314: GO 92372
// un := tmp [ rand ( 1 , tmp ) ] ;
92316: LD_ADDR_VAR 0 2
92320: PUSH
92321: LD_VAR 0 3
92325: PUSH
92326: LD_INT 1
92328: PPUSH
92329: LD_VAR 0 3
92333: PPUSH
92334: CALL_OW 12
92338: ARRAY
92339: ST_TO_ADDR
// if Crawls ( un ) then
92340: LD_VAR 0 2
92344: PPUSH
92345: CALL_OW 318
92349: IFFALSE 92360
// ComWalk ( un ) ;
92351: LD_VAR 0 2
92355: PPUSH
92356: CALL_OW 138
// SetClass ( un , class_sniper ) ;
92360: LD_VAR 0 2
92364: PPUSH
92365: LD_INT 5
92367: PPUSH
92368: CALL_OW 336
// end ;
92372: PPOPN 3
92374: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
92375: LD_EXP 109
92379: PUSH
92380: LD_EXP 127
92384: AND
92385: PUSH
92386: LD_OWVAR 67
92390: PUSH
92391: LD_INT 3
92393: LESS
92394: AND
92395: IFFALSE 92414
92397: GO 92399
92399: DISABLE
// Difficulty := Difficulty + 1 ;
92400: LD_ADDR_OWVAR 67
92404: PUSH
92405: LD_OWVAR 67
92409: PUSH
92410: LD_INT 1
92412: PLUS
92413: ST_TO_ADDR
92414: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
92415: LD_EXP 109
92419: PUSH
92420: LD_EXP 128
92424: AND
92425: IFFALSE 92528
92427: GO 92429
92429: DISABLE
92430: LD_INT 0
92432: PPUSH
// begin for i := 1 to 5 do
92433: LD_ADDR_VAR 0 1
92437: PUSH
92438: DOUBLE
92439: LD_INT 1
92441: DEC
92442: ST_TO_ADDR
92443: LD_INT 5
92445: PUSH
92446: FOR_TO
92447: IFFALSE 92526
// begin uc_nation := nation_nature ;
92449: LD_ADDR_OWVAR 21
92453: PUSH
92454: LD_INT 0
92456: ST_TO_ADDR
// uc_side := 0 ;
92457: LD_ADDR_OWVAR 20
92461: PUSH
92462: LD_INT 0
92464: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92465: LD_ADDR_OWVAR 29
92469: PUSH
92470: LD_INT 12
92472: PUSH
92473: LD_INT 12
92475: PUSH
92476: EMPTY
92477: LIST
92478: LIST
92479: ST_TO_ADDR
// hc_agressivity := 20 ;
92480: LD_ADDR_OWVAR 35
92484: PUSH
92485: LD_INT 20
92487: ST_TO_ADDR
// hc_class := class_tiger ;
92488: LD_ADDR_OWVAR 28
92492: PUSH
92493: LD_INT 14
92495: ST_TO_ADDR
// hc_gallery :=  ;
92496: LD_ADDR_OWVAR 33
92500: PUSH
92501: LD_STRING 
92503: ST_TO_ADDR
// hc_name :=  ;
92504: LD_ADDR_OWVAR 26
92508: PUSH
92509: LD_STRING 
92511: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
92512: CALL_OW 44
92516: PPUSH
92517: LD_INT 0
92519: PPUSH
92520: CALL_OW 51
// end ;
92524: GO 92446
92526: POP
92527: POP
// end ;
92528: PPOPN 1
92530: END
// every 0 0$1 trigger StreamModeActive and sBomb do
92531: LD_EXP 109
92535: PUSH
92536: LD_EXP 129
92540: AND
92541: IFFALSE 92550
92543: GO 92545
92545: DISABLE
// StreamSibBomb ;
92546: CALL 92551 0 0
92550: END
// export function StreamSibBomb ; var i , x , y ; begin
92551: LD_INT 0
92553: PPUSH
92554: PPUSH
92555: PPUSH
92556: PPUSH
// result := false ;
92557: LD_ADDR_VAR 0 1
92561: PUSH
92562: LD_INT 0
92564: ST_TO_ADDR
// for i := 1 to 16 do
92565: LD_ADDR_VAR 0 2
92569: PUSH
92570: DOUBLE
92571: LD_INT 1
92573: DEC
92574: ST_TO_ADDR
92575: LD_INT 16
92577: PUSH
92578: FOR_TO
92579: IFFALSE 92778
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
92581: LD_ADDR_VAR 0 3
92585: PUSH
92586: LD_INT 10
92588: PUSH
92589: LD_INT 20
92591: PUSH
92592: LD_INT 30
92594: PUSH
92595: LD_INT 40
92597: PUSH
92598: LD_INT 50
92600: PUSH
92601: LD_INT 60
92603: PUSH
92604: LD_INT 70
92606: PUSH
92607: LD_INT 80
92609: PUSH
92610: LD_INT 90
92612: PUSH
92613: LD_INT 100
92615: PUSH
92616: LD_INT 110
92618: PUSH
92619: LD_INT 120
92621: PUSH
92622: LD_INT 130
92624: PUSH
92625: LD_INT 140
92627: PUSH
92628: LD_INT 150
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: PUSH
92648: LD_INT 1
92650: PPUSH
92651: LD_INT 15
92653: PPUSH
92654: CALL_OW 12
92658: ARRAY
92659: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
92660: LD_ADDR_VAR 0 4
92664: PUSH
92665: LD_INT 10
92667: PUSH
92668: LD_INT 20
92670: PUSH
92671: LD_INT 30
92673: PUSH
92674: LD_INT 40
92676: PUSH
92677: LD_INT 50
92679: PUSH
92680: LD_INT 60
92682: PUSH
92683: LD_INT 70
92685: PUSH
92686: LD_INT 80
92688: PUSH
92689: LD_INT 90
92691: PUSH
92692: LD_INT 100
92694: PUSH
92695: LD_INT 110
92697: PUSH
92698: LD_INT 120
92700: PUSH
92701: LD_INT 130
92703: PUSH
92704: LD_INT 140
92706: PUSH
92707: LD_INT 150
92709: PUSH
92710: EMPTY
92711: LIST
92712: LIST
92713: LIST
92714: LIST
92715: LIST
92716: LIST
92717: LIST
92718: LIST
92719: LIST
92720: LIST
92721: LIST
92722: LIST
92723: LIST
92724: LIST
92725: LIST
92726: PUSH
92727: LD_INT 1
92729: PPUSH
92730: LD_INT 15
92732: PPUSH
92733: CALL_OW 12
92737: ARRAY
92738: ST_TO_ADDR
// if ValidHex ( x , y ) then
92739: LD_VAR 0 3
92743: PPUSH
92744: LD_VAR 0 4
92748: PPUSH
92749: CALL_OW 488
92753: IFFALSE 92776
// begin result := [ x , y ] ;
92755: LD_ADDR_VAR 0 1
92759: PUSH
92760: LD_VAR 0 3
92764: PUSH
92765: LD_VAR 0 4
92769: PUSH
92770: EMPTY
92771: LIST
92772: LIST
92773: ST_TO_ADDR
// break ;
92774: GO 92778
// end ; end ;
92776: GO 92578
92778: POP
92779: POP
// if result then
92780: LD_VAR 0 1
92784: IFFALSE 92844
// begin ToLua ( playSibBomb() ) ;
92786: LD_STRING playSibBomb()
92788: PPUSH
92789: CALL_OW 559
// wait ( 0 0$14 ) ;
92793: LD_INT 490
92795: PPUSH
92796: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
92800: LD_VAR 0 1
92804: PUSH
92805: LD_INT 1
92807: ARRAY
92808: PPUSH
92809: LD_VAR 0 1
92813: PUSH
92814: LD_INT 2
92816: ARRAY
92817: PPUSH
92818: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
92822: LD_VAR 0 1
92826: PUSH
92827: LD_INT 1
92829: ARRAY
92830: PPUSH
92831: LD_VAR 0 1
92835: PUSH
92836: LD_INT 2
92838: ARRAY
92839: PPUSH
92840: CALL_OW 429
// end ; end ;
92844: LD_VAR 0 1
92848: RET
// every 0 0$1 trigger StreamModeActive and sReset do
92849: LD_EXP 109
92853: PUSH
92854: LD_EXP 131
92858: AND
92859: IFFALSE 92871
92861: GO 92863
92863: DISABLE
// YouLost (  ) ;
92864: LD_STRING 
92866: PPUSH
92867: CALL_OW 104
92871: END
// every 0 0$1 trigger StreamModeActive and sFog do
92872: LD_EXP 109
92876: PUSH
92877: LD_EXP 130
92881: AND
92882: IFFALSE 92896
92884: GO 92886
92886: DISABLE
// FogOff ( your_side ) ;
92887: LD_OWVAR 2
92891: PPUSH
92892: CALL_OW 344
92896: END
// every 0 0$1 trigger StreamModeActive and sSun do
92897: LD_EXP 109
92901: PUSH
92902: LD_EXP 132
92906: AND
92907: IFFALSE 92935
92909: GO 92911
92911: DISABLE
// begin solar_recharge_percent := 0 ;
92912: LD_ADDR_OWVAR 79
92916: PUSH
92917: LD_INT 0
92919: ST_TO_ADDR
// wait ( 5 5$00 ) ;
92920: LD_INT 10500
92922: PPUSH
92923: CALL_OW 67
// solar_recharge_percent := 100 ;
92927: LD_ADDR_OWVAR 79
92931: PUSH
92932: LD_INT 100
92934: ST_TO_ADDR
// end ;
92935: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
92936: LD_EXP 109
92940: PUSH
92941: LD_EXP 133
92945: AND
92946: IFFALSE 93185
92948: GO 92950
92950: DISABLE
92951: LD_INT 0
92953: PPUSH
92954: PPUSH
92955: PPUSH
// begin tmp := [ ] ;
92956: LD_ADDR_VAR 0 3
92960: PUSH
92961: EMPTY
92962: ST_TO_ADDR
// for i := 1 to 6 do
92963: LD_ADDR_VAR 0 1
92967: PUSH
92968: DOUBLE
92969: LD_INT 1
92971: DEC
92972: ST_TO_ADDR
92973: LD_INT 6
92975: PUSH
92976: FOR_TO
92977: IFFALSE 93082
// begin uc_nation := nation_nature ;
92979: LD_ADDR_OWVAR 21
92983: PUSH
92984: LD_INT 0
92986: ST_TO_ADDR
// uc_side := 0 ;
92987: LD_ADDR_OWVAR 20
92991: PUSH
92992: LD_INT 0
92994: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92995: LD_ADDR_OWVAR 29
92999: PUSH
93000: LD_INT 12
93002: PUSH
93003: LD_INT 12
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: ST_TO_ADDR
// hc_agressivity := 20 ;
93010: LD_ADDR_OWVAR 35
93014: PUSH
93015: LD_INT 20
93017: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
93018: LD_ADDR_OWVAR 28
93022: PUSH
93023: LD_INT 17
93025: ST_TO_ADDR
// hc_gallery :=  ;
93026: LD_ADDR_OWVAR 33
93030: PUSH
93031: LD_STRING 
93033: ST_TO_ADDR
// hc_name :=  ;
93034: LD_ADDR_OWVAR 26
93038: PUSH
93039: LD_STRING 
93041: ST_TO_ADDR
// un := CreateHuman ;
93042: LD_ADDR_VAR 0 2
93046: PUSH
93047: CALL_OW 44
93051: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
93052: LD_VAR 0 2
93056: PPUSH
93057: LD_INT 1
93059: PPUSH
93060: CALL_OW 51
// tmp := tmp ^ un ;
93064: LD_ADDR_VAR 0 3
93068: PUSH
93069: LD_VAR 0 3
93073: PUSH
93074: LD_VAR 0 2
93078: ADD
93079: ST_TO_ADDR
// end ;
93080: GO 92976
93082: POP
93083: POP
// repeat wait ( 0 0$1 ) ;
93084: LD_INT 35
93086: PPUSH
93087: CALL_OW 67
// for un in tmp do
93091: LD_ADDR_VAR 0 2
93095: PUSH
93096: LD_VAR 0 3
93100: PUSH
93101: FOR_IN
93102: IFFALSE 93176
// begin if IsDead ( un ) then
93104: LD_VAR 0 2
93108: PPUSH
93109: CALL_OW 301
93113: IFFALSE 93133
// begin tmp := tmp diff un ;
93115: LD_ADDR_VAR 0 3
93119: PUSH
93120: LD_VAR 0 3
93124: PUSH
93125: LD_VAR 0 2
93129: DIFF
93130: ST_TO_ADDR
// continue ;
93131: GO 93101
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
93133: LD_VAR 0 2
93137: PPUSH
93138: LD_INT 3
93140: PUSH
93141: LD_INT 22
93143: PUSH
93144: LD_INT 0
93146: PUSH
93147: EMPTY
93148: LIST
93149: LIST
93150: PUSH
93151: EMPTY
93152: LIST
93153: LIST
93154: PPUSH
93155: CALL_OW 69
93159: PPUSH
93160: LD_VAR 0 2
93164: PPUSH
93165: CALL_OW 74
93169: PPUSH
93170: CALL_OW 115
// end ;
93174: GO 93101
93176: POP
93177: POP
// until not tmp ;
93178: LD_VAR 0 3
93182: NOT
93183: IFFALSE 93084
// end ;
93185: PPOPN 3
93187: END
// every 0 0$1 trigger StreamModeActive and sTroll do
93188: LD_EXP 109
93192: PUSH
93193: LD_EXP 134
93197: AND
93198: IFFALSE 93252
93200: GO 93202
93202: DISABLE
// begin ToLua ( displayTroll(); ) ;
93203: LD_STRING displayTroll();
93205: PPUSH
93206: CALL_OW 559
// wait ( 3 3$00 ) ;
93210: LD_INT 6300
93212: PPUSH
93213: CALL_OW 67
// ToLua ( hideTroll(); ) ;
93217: LD_STRING hideTroll();
93219: PPUSH
93220: CALL_OW 559
// wait ( 1 1$00 ) ;
93224: LD_INT 2100
93226: PPUSH
93227: CALL_OW 67
// ToLua ( displayTroll(); ) ;
93231: LD_STRING displayTroll();
93233: PPUSH
93234: CALL_OW 559
// wait ( 1 1$00 ) ;
93238: LD_INT 2100
93240: PPUSH
93241: CALL_OW 67
// ToLua ( hideTroll(); ) ;
93245: LD_STRING hideTroll();
93247: PPUSH
93248: CALL_OW 559
// end ;
93252: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
93253: LD_EXP 109
93257: PUSH
93258: LD_EXP 135
93262: AND
93263: IFFALSE 93326
93265: GO 93267
93267: DISABLE
93268: LD_INT 0
93270: PPUSH
// begin p := 0 ;
93271: LD_ADDR_VAR 0 1
93275: PUSH
93276: LD_INT 0
93278: ST_TO_ADDR
// repeat game_speed := 1 ;
93279: LD_ADDR_OWVAR 65
93283: PUSH
93284: LD_INT 1
93286: ST_TO_ADDR
// wait ( 0 0$1 ) ;
93287: LD_INT 35
93289: PPUSH
93290: CALL_OW 67
// p := p + 1 ;
93294: LD_ADDR_VAR 0 1
93298: PUSH
93299: LD_VAR 0 1
93303: PUSH
93304: LD_INT 1
93306: PLUS
93307: ST_TO_ADDR
// until p >= 60 ;
93308: LD_VAR 0 1
93312: PUSH
93313: LD_INT 60
93315: GREATEREQUAL
93316: IFFALSE 93279
// game_speed := 4 ;
93318: LD_ADDR_OWVAR 65
93322: PUSH
93323: LD_INT 4
93325: ST_TO_ADDR
// end ;
93326: PPOPN 1
93328: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
93329: LD_EXP 109
93333: PUSH
93334: LD_EXP 136
93338: AND
93339: IFFALSE 93485
93341: GO 93343
93343: DISABLE
93344: LD_INT 0
93346: PPUSH
93347: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93348: LD_ADDR_VAR 0 1
93352: PUSH
93353: LD_INT 22
93355: PUSH
93356: LD_OWVAR 2
93360: PUSH
93361: EMPTY
93362: LIST
93363: LIST
93364: PUSH
93365: LD_INT 2
93367: PUSH
93368: LD_INT 30
93370: PUSH
93371: LD_INT 0
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: PUSH
93378: LD_INT 30
93380: PUSH
93381: LD_INT 1
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: LIST
93392: PUSH
93393: EMPTY
93394: LIST
93395: LIST
93396: PPUSH
93397: CALL_OW 69
93401: ST_TO_ADDR
// if not depot then
93402: LD_VAR 0 1
93406: NOT
93407: IFFALSE 93411
// exit ;
93409: GO 93485
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
93411: LD_ADDR_VAR 0 2
93415: PUSH
93416: LD_VAR 0 1
93420: PUSH
93421: LD_INT 1
93423: PPUSH
93424: LD_VAR 0 1
93428: PPUSH
93429: CALL_OW 12
93433: ARRAY
93434: PPUSH
93435: CALL_OW 274
93439: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
93440: LD_VAR 0 2
93444: PPUSH
93445: LD_INT 1
93447: PPUSH
93448: LD_INT 0
93450: PPUSH
93451: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
93455: LD_VAR 0 2
93459: PPUSH
93460: LD_INT 2
93462: PPUSH
93463: LD_INT 0
93465: PPUSH
93466: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
93470: LD_VAR 0 2
93474: PPUSH
93475: LD_INT 3
93477: PPUSH
93478: LD_INT 0
93480: PPUSH
93481: CALL_OW 277
// end ;
93485: PPOPN 2
93487: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
93488: LD_EXP 109
93492: PUSH
93493: LD_EXP 137
93497: AND
93498: IFFALSE 93595
93500: GO 93502
93502: DISABLE
93503: LD_INT 0
93505: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93506: LD_ADDR_VAR 0 1
93510: PUSH
93511: LD_INT 22
93513: PUSH
93514: LD_OWVAR 2
93518: PUSH
93519: EMPTY
93520: LIST
93521: LIST
93522: PUSH
93523: LD_INT 21
93525: PUSH
93526: LD_INT 1
93528: PUSH
93529: EMPTY
93530: LIST
93531: LIST
93532: PUSH
93533: LD_INT 3
93535: PUSH
93536: LD_INT 23
93538: PUSH
93539: LD_INT 0
93541: PUSH
93542: EMPTY
93543: LIST
93544: LIST
93545: PUSH
93546: EMPTY
93547: LIST
93548: LIST
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: LIST
93554: PPUSH
93555: CALL_OW 69
93559: ST_TO_ADDR
// if not tmp then
93560: LD_VAR 0 1
93564: NOT
93565: IFFALSE 93569
// exit ;
93567: GO 93595
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
93569: LD_VAR 0 1
93573: PUSH
93574: LD_INT 1
93576: PPUSH
93577: LD_VAR 0 1
93581: PPUSH
93582: CALL_OW 12
93586: ARRAY
93587: PPUSH
93588: LD_INT 200
93590: PPUSH
93591: CALL_OW 234
// end ;
93595: PPOPN 1
93597: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
93598: LD_EXP 109
93602: PUSH
93603: LD_EXP 138
93607: AND
93608: IFFALSE 93687
93610: GO 93612
93612: DISABLE
93613: LD_INT 0
93615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
93616: LD_ADDR_VAR 0 1
93620: PUSH
93621: LD_INT 22
93623: PUSH
93624: LD_OWVAR 2
93628: PUSH
93629: EMPTY
93630: LIST
93631: LIST
93632: PUSH
93633: LD_INT 21
93635: PUSH
93636: LD_INT 2
93638: PUSH
93639: EMPTY
93640: LIST
93641: LIST
93642: PUSH
93643: EMPTY
93644: LIST
93645: LIST
93646: PPUSH
93647: CALL_OW 69
93651: ST_TO_ADDR
// if not tmp then
93652: LD_VAR 0 1
93656: NOT
93657: IFFALSE 93661
// exit ;
93659: GO 93687
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
93661: LD_VAR 0 1
93665: PUSH
93666: LD_INT 1
93668: PPUSH
93669: LD_VAR 0 1
93673: PPUSH
93674: CALL_OW 12
93678: ARRAY
93679: PPUSH
93680: LD_INT 60
93682: PPUSH
93683: CALL_OW 234
// end ;
93687: PPOPN 1
93689: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
93690: LD_EXP 109
93694: PUSH
93695: LD_EXP 139
93699: AND
93700: IFFALSE 93799
93702: GO 93704
93704: DISABLE
93705: LD_INT 0
93707: PPUSH
93708: PPUSH
// begin enable ;
93709: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
93710: LD_ADDR_VAR 0 1
93714: PUSH
93715: LD_INT 22
93717: PUSH
93718: LD_OWVAR 2
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: PUSH
93727: LD_INT 61
93729: PUSH
93730: EMPTY
93731: LIST
93732: PUSH
93733: LD_INT 33
93735: PUSH
93736: LD_INT 2
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: LIST
93747: PPUSH
93748: CALL_OW 69
93752: ST_TO_ADDR
// if not tmp then
93753: LD_VAR 0 1
93757: NOT
93758: IFFALSE 93762
// exit ;
93760: GO 93799
// for i in tmp do
93762: LD_ADDR_VAR 0 2
93766: PUSH
93767: LD_VAR 0 1
93771: PUSH
93772: FOR_IN
93773: IFFALSE 93797
// if IsControledBy ( i ) then
93775: LD_VAR 0 2
93779: PPUSH
93780: CALL_OW 312
93784: IFFALSE 93795
// ComUnlink ( i ) ;
93786: LD_VAR 0 2
93790: PPUSH
93791: CALL_OW 136
93795: GO 93772
93797: POP
93798: POP
// end ;
93799: PPOPN 2
93801: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
93802: LD_EXP 109
93806: PUSH
93807: LD_EXP 140
93811: AND
93812: IFFALSE 93952
93814: GO 93816
93816: DISABLE
93817: LD_INT 0
93819: PPUSH
93820: PPUSH
// begin ToLua ( displayPowell(); ) ;
93821: LD_STRING displayPowell();
93823: PPUSH
93824: CALL_OW 559
// uc_side := 0 ;
93828: LD_ADDR_OWVAR 20
93832: PUSH
93833: LD_INT 0
93835: ST_TO_ADDR
// uc_nation := 2 ;
93836: LD_ADDR_OWVAR 21
93840: PUSH
93841: LD_INT 2
93843: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
93844: LD_ADDR_OWVAR 37
93848: PUSH
93849: LD_INT 14
93851: ST_TO_ADDR
// vc_engine := engine_siberite ;
93852: LD_ADDR_OWVAR 39
93856: PUSH
93857: LD_INT 3
93859: ST_TO_ADDR
// vc_control := control_apeman ;
93860: LD_ADDR_OWVAR 38
93864: PUSH
93865: LD_INT 5
93867: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
93868: LD_ADDR_OWVAR 40
93872: PUSH
93873: LD_INT 29
93875: ST_TO_ADDR
// un := CreateVehicle ;
93876: LD_ADDR_VAR 0 2
93880: PUSH
93881: CALL_OW 45
93885: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93886: LD_VAR 0 2
93890: PPUSH
93891: LD_INT 1
93893: PPUSH
93894: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
93898: LD_INT 35
93900: PPUSH
93901: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
93905: LD_VAR 0 2
93909: PPUSH
93910: LD_INT 22
93912: PUSH
93913: LD_OWVAR 2
93917: PUSH
93918: EMPTY
93919: LIST
93920: LIST
93921: PPUSH
93922: CALL_OW 69
93926: PPUSH
93927: LD_VAR 0 2
93931: PPUSH
93932: CALL_OW 74
93936: PPUSH
93937: CALL_OW 115
// until IsDead ( un ) ;
93941: LD_VAR 0 2
93945: PPUSH
93946: CALL_OW 301
93950: IFFALSE 93898
// end ;
93952: PPOPN 2
93954: END
// every 0 0$1 trigger StreamModeActive and sStu do
93955: LD_EXP 109
93959: PUSH
93960: LD_EXP 148
93964: AND
93965: IFFALSE 93981
93967: GO 93969
93969: DISABLE
// begin ToLua ( displayStucuk(); ) ;
93970: LD_STRING displayStucuk();
93972: PPUSH
93973: CALL_OW 559
// ResetFog ;
93977: CALL_OW 335
// end ;
93981: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
93982: LD_EXP 109
93986: PUSH
93987: LD_EXP 141
93991: AND
93992: IFFALSE 94133
93994: GO 93996
93996: DISABLE
93997: LD_INT 0
93999: PPUSH
94000: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94001: LD_ADDR_VAR 0 2
94005: PUSH
94006: LD_INT 22
94008: PUSH
94009: LD_OWVAR 2
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: PUSH
94018: LD_INT 21
94020: PUSH
94021: LD_INT 1
94023: PUSH
94024: EMPTY
94025: LIST
94026: LIST
94027: PUSH
94028: EMPTY
94029: LIST
94030: LIST
94031: PPUSH
94032: CALL_OW 69
94036: ST_TO_ADDR
// if not tmp then
94037: LD_VAR 0 2
94041: NOT
94042: IFFALSE 94046
// exit ;
94044: GO 94133
// un := tmp [ rand ( 1 , tmp ) ] ;
94046: LD_ADDR_VAR 0 1
94050: PUSH
94051: LD_VAR 0 2
94055: PUSH
94056: LD_INT 1
94058: PPUSH
94059: LD_VAR 0 2
94063: PPUSH
94064: CALL_OW 12
94068: ARRAY
94069: ST_TO_ADDR
// SetSide ( un , 0 ) ;
94070: LD_VAR 0 1
94074: PPUSH
94075: LD_INT 0
94077: PPUSH
94078: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
94082: LD_VAR 0 1
94086: PPUSH
94087: LD_OWVAR 3
94091: PUSH
94092: LD_VAR 0 1
94096: DIFF
94097: PPUSH
94098: LD_VAR 0 1
94102: PPUSH
94103: CALL_OW 74
94107: PPUSH
94108: CALL_OW 115
// wait ( 0 0$20 ) ;
94112: LD_INT 700
94114: PPUSH
94115: CALL_OW 67
// SetSide ( un , your_side ) ;
94119: LD_VAR 0 1
94123: PPUSH
94124: LD_OWVAR 2
94128: PPUSH
94129: CALL_OW 235
// end ;
94133: PPOPN 2
94135: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
94136: LD_EXP 109
94140: PUSH
94141: LD_EXP 142
94145: AND
94146: IFFALSE 94252
94148: GO 94150
94150: DISABLE
94151: LD_INT 0
94153: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94154: LD_ADDR_VAR 0 1
94158: PUSH
94159: LD_INT 22
94161: PUSH
94162: LD_OWVAR 2
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: PUSH
94171: LD_INT 2
94173: PUSH
94174: LD_INT 30
94176: PUSH
94177: LD_INT 0
94179: PUSH
94180: EMPTY
94181: LIST
94182: LIST
94183: PUSH
94184: LD_INT 30
94186: PUSH
94187: LD_INT 1
94189: PUSH
94190: EMPTY
94191: LIST
94192: LIST
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: LIST
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: PPUSH
94203: CALL_OW 69
94207: ST_TO_ADDR
// if not depot then
94208: LD_VAR 0 1
94212: NOT
94213: IFFALSE 94217
// exit ;
94215: GO 94252
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
94217: LD_VAR 0 1
94221: PUSH
94222: LD_INT 1
94224: ARRAY
94225: PPUSH
94226: CALL_OW 250
94230: PPUSH
94231: LD_VAR 0 1
94235: PUSH
94236: LD_INT 1
94238: ARRAY
94239: PPUSH
94240: CALL_OW 251
94244: PPUSH
94245: LD_INT 70
94247: PPUSH
94248: CALL_OW 495
// end ;
94252: PPOPN 1
94254: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
94255: LD_EXP 109
94259: PUSH
94260: LD_EXP 143
94264: AND
94265: IFFALSE 94476
94267: GO 94269
94269: DISABLE
94270: LD_INT 0
94272: PPUSH
94273: PPUSH
94274: PPUSH
94275: PPUSH
94276: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94277: LD_ADDR_VAR 0 5
94281: PUSH
94282: LD_INT 22
94284: PUSH
94285: LD_OWVAR 2
94289: PUSH
94290: EMPTY
94291: LIST
94292: LIST
94293: PUSH
94294: LD_INT 21
94296: PUSH
94297: LD_INT 1
94299: PUSH
94300: EMPTY
94301: LIST
94302: LIST
94303: PUSH
94304: EMPTY
94305: LIST
94306: LIST
94307: PPUSH
94308: CALL_OW 69
94312: ST_TO_ADDR
// if not tmp then
94313: LD_VAR 0 5
94317: NOT
94318: IFFALSE 94322
// exit ;
94320: GO 94476
// for i in tmp do
94322: LD_ADDR_VAR 0 1
94326: PUSH
94327: LD_VAR 0 5
94331: PUSH
94332: FOR_IN
94333: IFFALSE 94474
// begin d := rand ( 0 , 5 ) ;
94335: LD_ADDR_VAR 0 4
94339: PUSH
94340: LD_INT 0
94342: PPUSH
94343: LD_INT 5
94345: PPUSH
94346: CALL_OW 12
94350: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
94351: LD_ADDR_VAR 0 2
94355: PUSH
94356: LD_VAR 0 1
94360: PPUSH
94361: CALL_OW 250
94365: PPUSH
94366: LD_VAR 0 4
94370: PPUSH
94371: LD_INT 3
94373: PPUSH
94374: LD_INT 12
94376: PPUSH
94377: CALL_OW 12
94381: PPUSH
94382: CALL_OW 272
94386: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
94387: LD_ADDR_VAR 0 3
94391: PUSH
94392: LD_VAR 0 1
94396: PPUSH
94397: CALL_OW 251
94401: PPUSH
94402: LD_VAR 0 4
94406: PPUSH
94407: LD_INT 3
94409: PPUSH
94410: LD_INT 12
94412: PPUSH
94413: CALL_OW 12
94417: PPUSH
94418: CALL_OW 273
94422: ST_TO_ADDR
// if ValidHex ( x , y ) then
94423: LD_VAR 0 2
94427: PPUSH
94428: LD_VAR 0 3
94432: PPUSH
94433: CALL_OW 488
94437: IFFALSE 94472
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
94439: LD_VAR 0 1
94443: PPUSH
94444: LD_VAR 0 2
94448: PPUSH
94449: LD_VAR 0 3
94453: PPUSH
94454: LD_INT 3
94456: PPUSH
94457: LD_INT 6
94459: PPUSH
94460: CALL_OW 12
94464: PPUSH
94465: LD_INT 1
94467: PPUSH
94468: CALL_OW 483
// end ;
94472: GO 94332
94474: POP
94475: POP
// end ;
94476: PPOPN 5
94478: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
94479: LD_EXP 109
94483: PUSH
94484: LD_EXP 144
94488: AND
94489: IFFALSE 94583
94491: GO 94493
94493: DISABLE
94494: LD_INT 0
94496: PPUSH
94497: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
94498: LD_ADDR_VAR 0 2
94502: PUSH
94503: LD_INT 22
94505: PUSH
94506: LD_OWVAR 2
94510: PUSH
94511: EMPTY
94512: LIST
94513: LIST
94514: PUSH
94515: LD_INT 32
94517: PUSH
94518: LD_INT 1
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 21
94527: PUSH
94528: LD_INT 2
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: PUSH
94535: EMPTY
94536: LIST
94537: LIST
94538: LIST
94539: PPUSH
94540: CALL_OW 69
94544: ST_TO_ADDR
// if not tmp then
94545: LD_VAR 0 2
94549: NOT
94550: IFFALSE 94554
// exit ;
94552: GO 94583
// for i in tmp do
94554: LD_ADDR_VAR 0 1
94558: PUSH
94559: LD_VAR 0 2
94563: PUSH
94564: FOR_IN
94565: IFFALSE 94581
// SetFuel ( i , 0 ) ;
94567: LD_VAR 0 1
94571: PPUSH
94572: LD_INT 0
94574: PPUSH
94575: CALL_OW 240
94579: GO 94564
94581: POP
94582: POP
// end ;
94583: PPOPN 2
94585: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
94586: LD_EXP 109
94590: PUSH
94591: LD_EXP 145
94595: AND
94596: IFFALSE 94662
94598: GO 94600
94600: DISABLE
94601: LD_INT 0
94603: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
94604: LD_ADDR_VAR 0 1
94608: PUSH
94609: LD_INT 22
94611: PUSH
94612: LD_OWVAR 2
94616: PUSH
94617: EMPTY
94618: LIST
94619: LIST
94620: PUSH
94621: LD_INT 30
94623: PUSH
94624: LD_INT 29
94626: PUSH
94627: EMPTY
94628: LIST
94629: LIST
94630: PUSH
94631: EMPTY
94632: LIST
94633: LIST
94634: PPUSH
94635: CALL_OW 69
94639: ST_TO_ADDR
// if not tmp then
94640: LD_VAR 0 1
94644: NOT
94645: IFFALSE 94649
// exit ;
94647: GO 94662
// DestroyUnit ( tmp [ 1 ] ) ;
94649: LD_VAR 0 1
94653: PUSH
94654: LD_INT 1
94656: ARRAY
94657: PPUSH
94658: CALL_OW 65
// end ;
94662: PPOPN 1
94664: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
94665: LD_EXP 109
94669: PUSH
94670: LD_EXP 147
94674: AND
94675: IFFALSE 94804
94677: GO 94679
94679: DISABLE
94680: LD_INT 0
94682: PPUSH
// begin uc_side := 0 ;
94683: LD_ADDR_OWVAR 20
94687: PUSH
94688: LD_INT 0
94690: ST_TO_ADDR
// uc_nation := nation_arabian ;
94691: LD_ADDR_OWVAR 21
94695: PUSH
94696: LD_INT 2
94698: ST_TO_ADDR
// hc_gallery :=  ;
94699: LD_ADDR_OWVAR 33
94703: PUSH
94704: LD_STRING 
94706: ST_TO_ADDR
// hc_name :=  ;
94707: LD_ADDR_OWVAR 26
94711: PUSH
94712: LD_STRING 
94714: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
94715: LD_INT 1
94717: PPUSH
94718: LD_INT 11
94720: PPUSH
94721: LD_INT 10
94723: PPUSH
94724: CALL_OW 380
// un := CreateHuman ;
94728: LD_ADDR_VAR 0 1
94732: PUSH
94733: CALL_OW 44
94737: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94738: LD_VAR 0 1
94742: PPUSH
94743: LD_INT 1
94745: PPUSH
94746: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94750: LD_INT 35
94752: PPUSH
94753: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94757: LD_VAR 0 1
94761: PPUSH
94762: LD_INT 22
94764: PUSH
94765: LD_OWVAR 2
94769: PUSH
94770: EMPTY
94771: LIST
94772: LIST
94773: PPUSH
94774: CALL_OW 69
94778: PPUSH
94779: LD_VAR 0 1
94783: PPUSH
94784: CALL_OW 74
94788: PPUSH
94789: CALL_OW 115
// until IsDead ( un ) ;
94793: LD_VAR 0 1
94797: PPUSH
94798: CALL_OW 301
94802: IFFALSE 94750
// end ;
94804: PPOPN 1
94806: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
94807: LD_EXP 109
94811: PUSH
94812: LD_EXP 149
94816: AND
94817: IFFALSE 94829
94819: GO 94821
94821: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
94822: LD_STRING earthquake(getX(game), 0, 32)
94824: PPUSH
94825: CALL_OW 559
94829: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
94830: LD_EXP 109
94834: PUSH
94835: LD_EXP 150
94839: AND
94840: IFFALSE 94931
94842: GO 94844
94844: DISABLE
94845: LD_INT 0
94847: PPUSH
// begin enable ;
94848: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
94849: LD_ADDR_VAR 0 1
94853: PUSH
94854: LD_INT 22
94856: PUSH
94857: LD_OWVAR 2
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: PUSH
94866: LD_INT 21
94868: PUSH
94869: LD_INT 2
94871: PUSH
94872: EMPTY
94873: LIST
94874: LIST
94875: PUSH
94876: LD_INT 33
94878: PUSH
94879: LD_INT 3
94881: PUSH
94882: EMPTY
94883: LIST
94884: LIST
94885: PUSH
94886: EMPTY
94887: LIST
94888: LIST
94889: LIST
94890: PPUSH
94891: CALL_OW 69
94895: ST_TO_ADDR
// if not tmp then
94896: LD_VAR 0 1
94900: NOT
94901: IFFALSE 94905
// exit ;
94903: GO 94931
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94905: LD_VAR 0 1
94909: PUSH
94910: LD_INT 1
94912: PPUSH
94913: LD_VAR 0 1
94917: PPUSH
94918: CALL_OW 12
94922: ARRAY
94923: PPUSH
94924: LD_INT 1
94926: PPUSH
94927: CALL_OW 234
// end ;
94931: PPOPN 1
94933: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
94934: LD_EXP 109
94938: PUSH
94939: LD_EXP 151
94943: AND
94944: IFFALSE 95085
94946: GO 94948
94948: DISABLE
94949: LD_INT 0
94951: PPUSH
94952: PPUSH
94953: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94954: LD_ADDR_VAR 0 3
94958: PUSH
94959: LD_INT 22
94961: PUSH
94962: LD_OWVAR 2
94966: PUSH
94967: EMPTY
94968: LIST
94969: LIST
94970: PUSH
94971: LD_INT 25
94973: PUSH
94974: LD_INT 1
94976: PUSH
94977: EMPTY
94978: LIST
94979: LIST
94980: PUSH
94981: EMPTY
94982: LIST
94983: LIST
94984: PPUSH
94985: CALL_OW 69
94989: ST_TO_ADDR
// if not tmp then
94990: LD_VAR 0 3
94994: NOT
94995: IFFALSE 94999
// exit ;
94997: GO 95085
// un := tmp [ rand ( 1 , tmp ) ] ;
94999: LD_ADDR_VAR 0 2
95003: PUSH
95004: LD_VAR 0 3
95008: PUSH
95009: LD_INT 1
95011: PPUSH
95012: LD_VAR 0 3
95016: PPUSH
95017: CALL_OW 12
95021: ARRAY
95022: ST_TO_ADDR
// if Crawls ( un ) then
95023: LD_VAR 0 2
95027: PPUSH
95028: CALL_OW 318
95032: IFFALSE 95043
// ComWalk ( un ) ;
95034: LD_VAR 0 2
95038: PPUSH
95039: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
95043: LD_VAR 0 2
95047: PPUSH
95048: LD_INT 9
95050: PPUSH
95051: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
95055: LD_INT 28
95057: PPUSH
95058: LD_OWVAR 2
95062: PPUSH
95063: LD_INT 2
95065: PPUSH
95066: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
95070: LD_INT 29
95072: PPUSH
95073: LD_OWVAR 2
95077: PPUSH
95078: LD_INT 2
95080: PPUSH
95081: CALL_OW 322
// end ;
95085: PPOPN 3
95087: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
95088: LD_EXP 109
95092: PUSH
95093: LD_EXP 152
95097: AND
95098: IFFALSE 95209
95100: GO 95102
95102: DISABLE
95103: LD_INT 0
95105: PPUSH
95106: PPUSH
95107: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95108: LD_ADDR_VAR 0 3
95112: PUSH
95113: LD_INT 22
95115: PUSH
95116: LD_OWVAR 2
95120: PUSH
95121: EMPTY
95122: LIST
95123: LIST
95124: PUSH
95125: LD_INT 25
95127: PUSH
95128: LD_INT 1
95130: PUSH
95131: EMPTY
95132: LIST
95133: LIST
95134: PUSH
95135: EMPTY
95136: LIST
95137: LIST
95138: PPUSH
95139: CALL_OW 69
95143: ST_TO_ADDR
// if not tmp then
95144: LD_VAR 0 3
95148: NOT
95149: IFFALSE 95153
// exit ;
95151: GO 95209
// un := tmp [ rand ( 1 , tmp ) ] ;
95153: LD_ADDR_VAR 0 2
95157: PUSH
95158: LD_VAR 0 3
95162: PUSH
95163: LD_INT 1
95165: PPUSH
95166: LD_VAR 0 3
95170: PPUSH
95171: CALL_OW 12
95175: ARRAY
95176: ST_TO_ADDR
// if Crawls ( un ) then
95177: LD_VAR 0 2
95181: PPUSH
95182: CALL_OW 318
95186: IFFALSE 95197
// ComWalk ( un ) ;
95188: LD_VAR 0 2
95192: PPUSH
95193: CALL_OW 138
// SetClass ( un , class_mortar ) ;
95197: LD_VAR 0 2
95201: PPUSH
95202: LD_INT 8
95204: PPUSH
95205: CALL_OW 336
// end ;
95209: PPOPN 3
95211: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
95212: LD_EXP 109
95216: PUSH
95217: LD_EXP 153
95221: AND
95222: IFFALSE 95366
95224: GO 95226
95226: DISABLE
95227: LD_INT 0
95229: PPUSH
95230: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
95231: LD_ADDR_VAR 0 2
95235: PUSH
95236: LD_INT 22
95238: PUSH
95239: LD_OWVAR 2
95243: PUSH
95244: EMPTY
95245: LIST
95246: LIST
95247: PUSH
95248: LD_INT 21
95250: PUSH
95251: LD_INT 2
95253: PUSH
95254: EMPTY
95255: LIST
95256: LIST
95257: PUSH
95258: LD_INT 2
95260: PUSH
95261: LD_INT 34
95263: PUSH
95264: LD_INT 12
95266: PUSH
95267: EMPTY
95268: LIST
95269: LIST
95270: PUSH
95271: LD_INT 34
95273: PUSH
95274: LD_INT 51
95276: PUSH
95277: EMPTY
95278: LIST
95279: LIST
95280: PUSH
95281: LD_INT 34
95283: PUSH
95284: LD_INT 32
95286: PUSH
95287: EMPTY
95288: LIST
95289: LIST
95290: PUSH
95291: EMPTY
95292: LIST
95293: LIST
95294: LIST
95295: LIST
95296: PUSH
95297: EMPTY
95298: LIST
95299: LIST
95300: LIST
95301: PPUSH
95302: CALL_OW 69
95306: ST_TO_ADDR
// if not tmp then
95307: LD_VAR 0 2
95311: NOT
95312: IFFALSE 95316
// exit ;
95314: GO 95366
// for i in tmp do
95316: LD_ADDR_VAR 0 1
95320: PUSH
95321: LD_VAR 0 2
95325: PUSH
95326: FOR_IN
95327: IFFALSE 95364
// if GetCargo ( i , mat_artifact ) = 0 then
95329: LD_VAR 0 1
95333: PPUSH
95334: LD_INT 4
95336: PPUSH
95337: CALL_OW 289
95341: PUSH
95342: LD_INT 0
95344: EQUAL
95345: IFFALSE 95362
// SetCargo ( i , mat_siberit , 100 ) ;
95347: LD_VAR 0 1
95351: PPUSH
95352: LD_INT 3
95354: PPUSH
95355: LD_INT 100
95357: PPUSH
95358: CALL_OW 290
95362: GO 95326
95364: POP
95365: POP
// end ;
95366: PPOPN 2
95368: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
95369: LD_EXP 109
95373: PUSH
95374: LD_EXP 154
95378: AND
95379: IFFALSE 95562
95381: GO 95383
95383: DISABLE
95384: LD_INT 0
95386: PPUSH
95387: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
95388: LD_ADDR_VAR 0 2
95392: PUSH
95393: LD_INT 22
95395: PUSH
95396: LD_OWVAR 2
95400: PUSH
95401: EMPTY
95402: LIST
95403: LIST
95404: PPUSH
95405: CALL_OW 69
95409: ST_TO_ADDR
// if not tmp then
95410: LD_VAR 0 2
95414: NOT
95415: IFFALSE 95419
// exit ;
95417: GO 95562
// for i := 1 to 2 do
95419: LD_ADDR_VAR 0 1
95423: PUSH
95424: DOUBLE
95425: LD_INT 1
95427: DEC
95428: ST_TO_ADDR
95429: LD_INT 2
95431: PUSH
95432: FOR_TO
95433: IFFALSE 95560
// begin uc_side := your_side ;
95435: LD_ADDR_OWVAR 20
95439: PUSH
95440: LD_OWVAR 2
95444: ST_TO_ADDR
// uc_nation := nation_american ;
95445: LD_ADDR_OWVAR 21
95449: PUSH
95450: LD_INT 1
95452: ST_TO_ADDR
// vc_chassis := us_morphling ;
95453: LD_ADDR_OWVAR 37
95457: PUSH
95458: LD_INT 5
95460: ST_TO_ADDR
// vc_engine := engine_siberite ;
95461: LD_ADDR_OWVAR 39
95465: PUSH
95466: LD_INT 3
95468: ST_TO_ADDR
// vc_control := control_computer ;
95469: LD_ADDR_OWVAR 38
95473: PUSH
95474: LD_INT 3
95476: ST_TO_ADDR
// vc_weapon := us_double_laser ;
95477: LD_ADDR_OWVAR 40
95481: PUSH
95482: LD_INT 10
95484: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
95485: LD_VAR 0 2
95489: PUSH
95490: LD_INT 1
95492: ARRAY
95493: PPUSH
95494: CALL_OW 310
95498: NOT
95499: IFFALSE 95546
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
95501: CALL_OW 45
95505: PPUSH
95506: LD_VAR 0 2
95510: PUSH
95511: LD_INT 1
95513: ARRAY
95514: PPUSH
95515: CALL_OW 250
95519: PPUSH
95520: LD_VAR 0 2
95524: PUSH
95525: LD_INT 1
95527: ARRAY
95528: PPUSH
95529: CALL_OW 251
95533: PPUSH
95534: LD_INT 12
95536: PPUSH
95537: LD_INT 1
95539: PPUSH
95540: CALL_OW 50
95544: GO 95558
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
95546: CALL_OW 45
95550: PPUSH
95551: LD_INT 1
95553: PPUSH
95554: CALL_OW 51
// end ;
95558: GO 95432
95560: POP
95561: POP
// end ;
95562: PPOPN 2
95564: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
95565: LD_EXP 109
95569: PUSH
95570: LD_EXP 155
95574: AND
95575: IFFALSE 95797
95577: GO 95579
95579: DISABLE
95580: LD_INT 0
95582: PPUSH
95583: PPUSH
95584: PPUSH
95585: PPUSH
95586: PPUSH
95587: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95588: LD_ADDR_VAR 0 6
95592: PUSH
95593: LD_INT 22
95595: PUSH
95596: LD_OWVAR 2
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: PUSH
95605: LD_INT 21
95607: PUSH
95608: LD_INT 1
95610: PUSH
95611: EMPTY
95612: LIST
95613: LIST
95614: PUSH
95615: LD_INT 3
95617: PUSH
95618: LD_INT 23
95620: PUSH
95621: LD_INT 0
95623: PUSH
95624: EMPTY
95625: LIST
95626: LIST
95627: PUSH
95628: EMPTY
95629: LIST
95630: LIST
95631: PUSH
95632: EMPTY
95633: LIST
95634: LIST
95635: LIST
95636: PPUSH
95637: CALL_OW 69
95641: ST_TO_ADDR
// if not tmp then
95642: LD_VAR 0 6
95646: NOT
95647: IFFALSE 95651
// exit ;
95649: GO 95797
// s1 := rand ( 1 , 4 ) ;
95651: LD_ADDR_VAR 0 2
95655: PUSH
95656: LD_INT 1
95658: PPUSH
95659: LD_INT 4
95661: PPUSH
95662: CALL_OW 12
95666: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
95667: LD_ADDR_VAR 0 4
95671: PUSH
95672: LD_VAR 0 6
95676: PUSH
95677: LD_INT 1
95679: ARRAY
95680: PPUSH
95681: LD_VAR 0 2
95685: PPUSH
95686: CALL_OW 259
95690: ST_TO_ADDR
// if s1 = 1 then
95691: LD_VAR 0 2
95695: PUSH
95696: LD_INT 1
95698: EQUAL
95699: IFFALSE 95719
// s2 := rand ( 2 , 4 ) else
95701: LD_ADDR_VAR 0 3
95705: PUSH
95706: LD_INT 2
95708: PPUSH
95709: LD_INT 4
95711: PPUSH
95712: CALL_OW 12
95716: ST_TO_ADDR
95717: GO 95727
// s2 := 1 ;
95719: LD_ADDR_VAR 0 3
95723: PUSH
95724: LD_INT 1
95726: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
95727: LD_ADDR_VAR 0 5
95731: PUSH
95732: LD_VAR 0 6
95736: PUSH
95737: LD_INT 1
95739: ARRAY
95740: PPUSH
95741: LD_VAR 0 3
95745: PPUSH
95746: CALL_OW 259
95750: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
95751: LD_VAR 0 6
95755: PUSH
95756: LD_INT 1
95758: ARRAY
95759: PPUSH
95760: LD_VAR 0 2
95764: PPUSH
95765: LD_VAR 0 5
95769: PPUSH
95770: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
95774: LD_VAR 0 6
95778: PUSH
95779: LD_INT 1
95781: ARRAY
95782: PPUSH
95783: LD_VAR 0 3
95787: PPUSH
95788: LD_VAR 0 4
95792: PPUSH
95793: CALL_OW 237
// end ;
95797: PPOPN 6
95799: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
95800: LD_EXP 109
95804: PUSH
95805: LD_EXP 156
95809: AND
95810: IFFALSE 95889
95812: GO 95814
95814: DISABLE
95815: LD_INT 0
95817: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
95818: LD_ADDR_VAR 0 1
95822: PUSH
95823: LD_INT 22
95825: PUSH
95826: LD_OWVAR 2
95830: PUSH
95831: EMPTY
95832: LIST
95833: LIST
95834: PUSH
95835: LD_INT 30
95837: PUSH
95838: LD_INT 3
95840: PUSH
95841: EMPTY
95842: LIST
95843: LIST
95844: PUSH
95845: EMPTY
95846: LIST
95847: LIST
95848: PPUSH
95849: CALL_OW 69
95853: ST_TO_ADDR
// if not tmp then
95854: LD_VAR 0 1
95858: NOT
95859: IFFALSE 95863
// exit ;
95861: GO 95889
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95863: LD_VAR 0 1
95867: PUSH
95868: LD_INT 1
95870: PPUSH
95871: LD_VAR 0 1
95875: PPUSH
95876: CALL_OW 12
95880: ARRAY
95881: PPUSH
95882: LD_INT 1
95884: PPUSH
95885: CALL_OW 234
// end ;
95889: PPOPN 1
95891: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
95892: LD_EXP 109
95896: PUSH
95897: LD_EXP 157
95901: AND
95902: IFFALSE 96014
95904: GO 95906
95906: DISABLE
95907: LD_INT 0
95909: PPUSH
95910: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
95911: LD_ADDR_VAR 0 2
95915: PUSH
95916: LD_INT 22
95918: PUSH
95919: LD_OWVAR 2
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: PUSH
95928: LD_INT 2
95930: PUSH
95931: LD_INT 30
95933: PUSH
95934: LD_INT 27
95936: PUSH
95937: EMPTY
95938: LIST
95939: LIST
95940: PUSH
95941: LD_INT 30
95943: PUSH
95944: LD_INT 26
95946: PUSH
95947: EMPTY
95948: LIST
95949: LIST
95950: PUSH
95951: LD_INT 30
95953: PUSH
95954: LD_INT 28
95956: PUSH
95957: EMPTY
95958: LIST
95959: LIST
95960: PUSH
95961: EMPTY
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: PUSH
95967: EMPTY
95968: LIST
95969: LIST
95970: PPUSH
95971: CALL_OW 69
95975: ST_TO_ADDR
// if not tmp then
95976: LD_VAR 0 2
95980: NOT
95981: IFFALSE 95985
// exit ;
95983: GO 96014
// for i in tmp do
95985: LD_ADDR_VAR 0 1
95989: PUSH
95990: LD_VAR 0 2
95994: PUSH
95995: FOR_IN
95996: IFFALSE 96012
// SetLives ( i , 1 ) ;
95998: LD_VAR 0 1
96002: PPUSH
96003: LD_INT 1
96005: PPUSH
96006: CALL_OW 234
96010: GO 95995
96012: POP
96013: POP
// end ;
96014: PPOPN 2
96016: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
96017: LD_EXP 109
96021: PUSH
96022: LD_EXP 158
96026: AND
96027: IFFALSE 96301
96029: GO 96031
96031: DISABLE
96032: LD_INT 0
96034: PPUSH
96035: PPUSH
96036: PPUSH
// begin i := rand ( 1 , 7 ) ;
96037: LD_ADDR_VAR 0 1
96041: PUSH
96042: LD_INT 1
96044: PPUSH
96045: LD_INT 7
96047: PPUSH
96048: CALL_OW 12
96052: ST_TO_ADDR
// case i of 1 :
96053: LD_VAR 0 1
96057: PUSH
96058: LD_INT 1
96060: DOUBLE
96061: EQUAL
96062: IFTRUE 96066
96064: GO 96076
96066: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
96067: LD_STRING earthquake(getX(game), 0, 32)
96069: PPUSH
96070: CALL_OW 559
96074: GO 96301
96076: LD_INT 2
96078: DOUBLE
96079: EQUAL
96080: IFTRUE 96084
96082: GO 96098
96084: POP
// begin ToLua ( displayStucuk(); ) ;
96085: LD_STRING displayStucuk();
96087: PPUSH
96088: CALL_OW 559
// ResetFog ;
96092: CALL_OW 335
// end ; 3 :
96096: GO 96301
96098: LD_INT 3
96100: DOUBLE
96101: EQUAL
96102: IFTRUE 96106
96104: GO 96210
96106: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96107: LD_ADDR_VAR 0 2
96111: PUSH
96112: LD_INT 22
96114: PUSH
96115: LD_OWVAR 2
96119: PUSH
96120: EMPTY
96121: LIST
96122: LIST
96123: PUSH
96124: LD_INT 25
96126: PUSH
96127: LD_INT 1
96129: PUSH
96130: EMPTY
96131: LIST
96132: LIST
96133: PUSH
96134: EMPTY
96135: LIST
96136: LIST
96137: PPUSH
96138: CALL_OW 69
96142: ST_TO_ADDR
// if not tmp then
96143: LD_VAR 0 2
96147: NOT
96148: IFFALSE 96152
// exit ;
96150: GO 96301
// un := tmp [ rand ( 1 , tmp ) ] ;
96152: LD_ADDR_VAR 0 3
96156: PUSH
96157: LD_VAR 0 2
96161: PUSH
96162: LD_INT 1
96164: PPUSH
96165: LD_VAR 0 2
96169: PPUSH
96170: CALL_OW 12
96174: ARRAY
96175: ST_TO_ADDR
// if Crawls ( un ) then
96176: LD_VAR 0 3
96180: PPUSH
96181: CALL_OW 318
96185: IFFALSE 96196
// ComWalk ( un ) ;
96187: LD_VAR 0 3
96191: PPUSH
96192: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96196: LD_VAR 0 3
96200: PPUSH
96201: LD_INT 8
96203: PPUSH
96204: CALL_OW 336
// end ; 4 :
96208: GO 96301
96210: LD_INT 4
96212: DOUBLE
96213: EQUAL
96214: IFTRUE 96218
96216: GO 96279
96218: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96219: LD_ADDR_VAR 0 2
96223: PUSH
96224: LD_INT 22
96226: PUSH
96227: LD_OWVAR 2
96231: PUSH
96232: EMPTY
96233: LIST
96234: LIST
96235: PUSH
96236: LD_INT 30
96238: PUSH
96239: LD_INT 29
96241: PUSH
96242: EMPTY
96243: LIST
96244: LIST
96245: PUSH
96246: EMPTY
96247: LIST
96248: LIST
96249: PPUSH
96250: CALL_OW 69
96254: ST_TO_ADDR
// if not tmp then
96255: LD_VAR 0 2
96259: NOT
96260: IFFALSE 96264
// exit ;
96262: GO 96301
// DestroyUnit ( tmp [ 1 ] ) ;
96264: LD_VAR 0 2
96268: PUSH
96269: LD_INT 1
96271: ARRAY
96272: PPUSH
96273: CALL_OW 65
// end ; 5 .. 7 :
96277: GO 96301
96279: LD_INT 5
96281: DOUBLE
96282: GREATEREQUAL
96283: IFFALSE 96291
96285: LD_INT 7
96287: DOUBLE
96288: LESSEQUAL
96289: IFTRUE 96293
96291: GO 96300
96293: POP
// StreamSibBomb ; end ;
96294: CALL 92551 0 0
96298: GO 96301
96300: POP
// end ;
96301: PPOPN 3
96303: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
96304: LD_EXP 109
96308: PUSH
96309: LD_EXP 159
96313: AND
96314: IFFALSE 96470
96316: GO 96318
96318: DISABLE
96319: LD_INT 0
96321: PPUSH
96322: PPUSH
96323: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
96324: LD_ADDR_VAR 0 2
96328: PUSH
96329: LD_INT 81
96331: PUSH
96332: LD_OWVAR 2
96336: PUSH
96337: EMPTY
96338: LIST
96339: LIST
96340: PUSH
96341: LD_INT 2
96343: PUSH
96344: LD_INT 21
96346: PUSH
96347: LD_INT 1
96349: PUSH
96350: EMPTY
96351: LIST
96352: LIST
96353: PUSH
96354: LD_INT 21
96356: PUSH
96357: LD_INT 2
96359: PUSH
96360: EMPTY
96361: LIST
96362: LIST
96363: PUSH
96364: EMPTY
96365: LIST
96366: LIST
96367: LIST
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: PPUSH
96373: CALL_OW 69
96377: ST_TO_ADDR
// if not tmp then
96378: LD_VAR 0 2
96382: NOT
96383: IFFALSE 96387
// exit ;
96385: GO 96470
// p := 0 ;
96387: LD_ADDR_VAR 0 3
96391: PUSH
96392: LD_INT 0
96394: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
96395: LD_INT 35
96397: PPUSH
96398: CALL_OW 67
// p := p + 1 ;
96402: LD_ADDR_VAR 0 3
96406: PUSH
96407: LD_VAR 0 3
96411: PUSH
96412: LD_INT 1
96414: PLUS
96415: ST_TO_ADDR
// for i in tmp do
96416: LD_ADDR_VAR 0 1
96420: PUSH
96421: LD_VAR 0 2
96425: PUSH
96426: FOR_IN
96427: IFFALSE 96458
// if GetLives ( i ) < 1000 then
96429: LD_VAR 0 1
96433: PPUSH
96434: CALL_OW 256
96438: PUSH
96439: LD_INT 1000
96441: LESS
96442: IFFALSE 96456
// SetLives ( i , 1000 ) ;
96444: LD_VAR 0 1
96448: PPUSH
96449: LD_INT 1000
96451: PPUSH
96452: CALL_OW 234
96456: GO 96426
96458: POP
96459: POP
// until p > 20 ;
96460: LD_VAR 0 3
96464: PUSH
96465: LD_INT 20
96467: GREATER
96468: IFFALSE 96395
// end ;
96470: PPOPN 3
96472: END
// every 0 0$1 trigger StreamModeActive and sTime do
96473: LD_EXP 109
96477: PUSH
96478: LD_EXP 160
96482: AND
96483: IFFALSE 96518
96485: GO 96487
96487: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
96488: LD_INT 28
96490: PPUSH
96491: LD_OWVAR 2
96495: PPUSH
96496: LD_INT 2
96498: PPUSH
96499: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
96503: LD_INT 30
96505: PPUSH
96506: LD_OWVAR 2
96510: PPUSH
96511: LD_INT 2
96513: PPUSH
96514: CALL_OW 322
// end ;
96518: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
96519: LD_EXP 109
96523: PUSH
96524: LD_EXP 161
96528: AND
96529: IFFALSE 96650
96531: GO 96533
96533: DISABLE
96534: LD_INT 0
96536: PPUSH
96537: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96538: LD_ADDR_VAR 0 2
96542: PUSH
96543: LD_INT 22
96545: PUSH
96546: LD_OWVAR 2
96550: PUSH
96551: EMPTY
96552: LIST
96553: LIST
96554: PUSH
96555: LD_INT 21
96557: PUSH
96558: LD_INT 1
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: PUSH
96565: LD_INT 3
96567: PUSH
96568: LD_INT 23
96570: PUSH
96571: LD_INT 0
96573: PUSH
96574: EMPTY
96575: LIST
96576: LIST
96577: PUSH
96578: EMPTY
96579: LIST
96580: LIST
96581: PUSH
96582: EMPTY
96583: LIST
96584: LIST
96585: LIST
96586: PPUSH
96587: CALL_OW 69
96591: ST_TO_ADDR
// if not tmp then
96592: LD_VAR 0 2
96596: NOT
96597: IFFALSE 96601
// exit ;
96599: GO 96650
// for i in tmp do
96601: LD_ADDR_VAR 0 1
96605: PUSH
96606: LD_VAR 0 2
96610: PUSH
96611: FOR_IN
96612: IFFALSE 96648
// begin if Crawls ( i ) then
96614: LD_VAR 0 1
96618: PPUSH
96619: CALL_OW 318
96623: IFFALSE 96634
// ComWalk ( i ) ;
96625: LD_VAR 0 1
96629: PPUSH
96630: CALL_OW 138
// SetClass ( i , 2 ) ;
96634: LD_VAR 0 1
96638: PPUSH
96639: LD_INT 2
96641: PPUSH
96642: CALL_OW 336
// end ;
96646: GO 96611
96648: POP
96649: POP
// end ;
96650: PPOPN 2
96652: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
96653: LD_EXP 109
96657: PUSH
96658: LD_EXP 162
96662: AND
96663: IFFALSE 96944
96665: GO 96667
96667: DISABLE
96668: LD_INT 0
96670: PPUSH
96671: PPUSH
96672: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
96673: LD_OWVAR 2
96677: PPUSH
96678: LD_INT 9
96680: PPUSH
96681: LD_INT 1
96683: PPUSH
96684: LD_INT 1
96686: PPUSH
96687: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
96691: LD_INT 9
96693: PPUSH
96694: LD_OWVAR 2
96698: PPUSH
96699: CALL_OW 343
// uc_side := 9 ;
96703: LD_ADDR_OWVAR 20
96707: PUSH
96708: LD_INT 9
96710: ST_TO_ADDR
// uc_nation := 2 ;
96711: LD_ADDR_OWVAR 21
96715: PUSH
96716: LD_INT 2
96718: ST_TO_ADDR
// hc_name := Dark Warrior ;
96719: LD_ADDR_OWVAR 26
96723: PUSH
96724: LD_STRING Dark Warrior
96726: ST_TO_ADDR
// hc_gallery :=  ;
96727: LD_ADDR_OWVAR 33
96731: PUSH
96732: LD_STRING 
96734: ST_TO_ADDR
// hc_noskilllimit := true ;
96735: LD_ADDR_OWVAR 76
96739: PUSH
96740: LD_INT 1
96742: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
96743: LD_ADDR_OWVAR 31
96747: PUSH
96748: LD_INT 30
96750: PUSH
96751: LD_INT 30
96753: PUSH
96754: LD_INT 30
96756: PUSH
96757: LD_INT 30
96759: PUSH
96760: EMPTY
96761: LIST
96762: LIST
96763: LIST
96764: LIST
96765: ST_TO_ADDR
// un := CreateHuman ;
96766: LD_ADDR_VAR 0 3
96770: PUSH
96771: CALL_OW 44
96775: ST_TO_ADDR
// hc_noskilllimit := false ;
96776: LD_ADDR_OWVAR 76
96780: PUSH
96781: LD_INT 0
96783: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96784: LD_VAR 0 3
96788: PPUSH
96789: LD_INT 1
96791: PPUSH
96792: CALL_OW 51
// p := 0 ;
96796: LD_ADDR_VAR 0 2
96800: PUSH
96801: LD_INT 0
96803: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
96804: LD_INT 35
96806: PPUSH
96807: CALL_OW 67
// p := p + 1 ;
96811: LD_ADDR_VAR 0 2
96815: PUSH
96816: LD_VAR 0 2
96820: PUSH
96821: LD_INT 1
96823: PLUS
96824: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
96825: LD_VAR 0 3
96829: PPUSH
96830: CALL_OW 256
96834: PUSH
96835: LD_INT 1000
96837: LESS
96838: IFFALSE 96852
// SetLives ( un , 1000 ) ;
96840: LD_VAR 0 3
96844: PPUSH
96845: LD_INT 1000
96847: PPUSH
96848: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
96852: LD_VAR 0 3
96856: PPUSH
96857: LD_INT 81
96859: PUSH
96860: LD_OWVAR 2
96864: PUSH
96865: EMPTY
96866: LIST
96867: LIST
96868: PUSH
96869: LD_INT 91
96871: PUSH
96872: LD_VAR 0 3
96876: PUSH
96877: LD_INT 30
96879: PUSH
96880: EMPTY
96881: LIST
96882: LIST
96883: LIST
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: PPUSH
96889: CALL_OW 69
96893: PPUSH
96894: LD_VAR 0 3
96898: PPUSH
96899: CALL_OW 74
96903: PPUSH
96904: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
96908: LD_VAR 0 2
96912: PUSH
96913: LD_INT 60
96915: GREATER
96916: PUSH
96917: LD_VAR 0 3
96921: PPUSH
96922: CALL_OW 301
96926: OR
96927: IFFALSE 96804
// if un then
96929: LD_VAR 0 3
96933: IFFALSE 96944
// RemoveUnit ( un ) ;
96935: LD_VAR 0 3
96939: PPUSH
96940: CALL_OW 64
// end ;
96944: PPOPN 3
96946: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96947: LD_INT 0
96949: PPUSH
// case cmd of 301 :
96950: LD_VAR 0 1
96954: PUSH
96955: LD_INT 301
96957: DOUBLE
96958: EQUAL
96959: IFTRUE 96963
96961: GO 96995
96963: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
96964: LD_VAR 0 6
96968: PPUSH
96969: LD_VAR 0 7
96973: PPUSH
96974: LD_VAR 0 8
96978: PPUSH
96979: LD_VAR 0 4
96983: PPUSH
96984: LD_VAR 0 5
96988: PPUSH
96989: CALL 98196 0 5
96993: GO 97116
96995: LD_INT 302
96997: DOUBLE
96998: EQUAL
96999: IFTRUE 97003
97001: GO 97040
97003: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
97004: LD_VAR 0 6
97008: PPUSH
97009: LD_VAR 0 7
97013: PPUSH
97014: LD_VAR 0 8
97018: PPUSH
97019: LD_VAR 0 9
97023: PPUSH
97024: LD_VAR 0 4
97028: PPUSH
97029: LD_VAR 0 5
97033: PPUSH
97034: CALL 98287 0 6
97038: GO 97116
97040: LD_INT 303
97042: DOUBLE
97043: EQUAL
97044: IFTRUE 97048
97046: GO 97085
97048: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
97049: LD_VAR 0 6
97053: PPUSH
97054: LD_VAR 0 7
97058: PPUSH
97059: LD_VAR 0 8
97063: PPUSH
97064: LD_VAR 0 9
97068: PPUSH
97069: LD_VAR 0 4
97073: PPUSH
97074: LD_VAR 0 5
97078: PPUSH
97079: CALL 97121 0 6
97083: GO 97116
97085: LD_INT 304
97087: DOUBLE
97088: EQUAL
97089: IFTRUE 97093
97091: GO 97115
97093: POP
// hHackTeleport ( unit , x , y ) ; end ;
97094: LD_VAR 0 2
97098: PPUSH
97099: LD_VAR 0 4
97103: PPUSH
97104: LD_VAR 0 5
97108: PPUSH
97109: CALL 98880 0 3
97113: GO 97116
97115: POP
// end ;
97116: LD_VAR 0 12
97120: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
97121: LD_INT 0
97123: PPUSH
97124: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
97125: LD_VAR 0 1
97129: PUSH
97130: LD_INT 1
97132: LESS
97133: PUSH
97134: LD_VAR 0 1
97138: PUSH
97139: LD_INT 3
97141: GREATER
97142: OR
97143: PUSH
97144: LD_VAR 0 5
97148: PPUSH
97149: LD_VAR 0 6
97153: PPUSH
97154: CALL_OW 428
97158: OR
97159: IFFALSE 97163
// exit ;
97161: GO 97883
// uc_side := your_side ;
97163: LD_ADDR_OWVAR 20
97167: PUSH
97168: LD_OWVAR 2
97172: ST_TO_ADDR
// uc_nation := nation ;
97173: LD_ADDR_OWVAR 21
97177: PUSH
97178: LD_VAR 0 1
97182: ST_TO_ADDR
// bc_level = 1 ;
97183: LD_ADDR_OWVAR 43
97187: PUSH
97188: LD_INT 1
97190: ST_TO_ADDR
// case btype of 1 :
97191: LD_VAR 0 2
97195: PUSH
97196: LD_INT 1
97198: DOUBLE
97199: EQUAL
97200: IFTRUE 97204
97202: GO 97215
97204: POP
// bc_type := b_depot ; 2 :
97205: LD_ADDR_OWVAR 42
97209: PUSH
97210: LD_INT 0
97212: ST_TO_ADDR
97213: GO 97827
97215: LD_INT 2
97217: DOUBLE
97218: EQUAL
97219: IFTRUE 97223
97221: GO 97234
97223: POP
// bc_type := b_warehouse ; 3 :
97224: LD_ADDR_OWVAR 42
97228: PUSH
97229: LD_INT 1
97231: ST_TO_ADDR
97232: GO 97827
97234: LD_INT 3
97236: DOUBLE
97237: EQUAL
97238: IFTRUE 97242
97240: GO 97253
97242: POP
// bc_type := b_lab ; 4 .. 9 :
97243: LD_ADDR_OWVAR 42
97247: PUSH
97248: LD_INT 6
97250: ST_TO_ADDR
97251: GO 97827
97253: LD_INT 4
97255: DOUBLE
97256: GREATEREQUAL
97257: IFFALSE 97265
97259: LD_INT 9
97261: DOUBLE
97262: LESSEQUAL
97263: IFTRUE 97267
97265: GO 97319
97267: POP
// begin bc_type := b_lab_half ;
97268: LD_ADDR_OWVAR 42
97272: PUSH
97273: LD_INT 7
97275: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
97276: LD_ADDR_OWVAR 44
97280: PUSH
97281: LD_INT 10
97283: PUSH
97284: LD_INT 11
97286: PUSH
97287: LD_INT 12
97289: PUSH
97290: LD_INT 15
97292: PUSH
97293: LD_INT 14
97295: PUSH
97296: LD_INT 13
97298: PUSH
97299: EMPTY
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: LIST
97306: PUSH
97307: LD_VAR 0 2
97311: PUSH
97312: LD_INT 3
97314: MINUS
97315: ARRAY
97316: ST_TO_ADDR
// end ; 10 .. 13 :
97317: GO 97827
97319: LD_INT 10
97321: DOUBLE
97322: GREATEREQUAL
97323: IFFALSE 97331
97325: LD_INT 13
97327: DOUBLE
97328: LESSEQUAL
97329: IFTRUE 97333
97331: GO 97410
97333: POP
// begin bc_type := b_lab_full ;
97334: LD_ADDR_OWVAR 42
97338: PUSH
97339: LD_INT 8
97341: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
97342: LD_ADDR_OWVAR 44
97346: PUSH
97347: LD_INT 10
97349: PUSH
97350: LD_INT 12
97352: PUSH
97353: LD_INT 14
97355: PUSH
97356: LD_INT 13
97358: PUSH
97359: EMPTY
97360: LIST
97361: LIST
97362: LIST
97363: LIST
97364: PUSH
97365: LD_VAR 0 2
97369: PUSH
97370: LD_INT 9
97372: MINUS
97373: ARRAY
97374: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
97375: LD_ADDR_OWVAR 45
97379: PUSH
97380: LD_INT 11
97382: PUSH
97383: LD_INT 15
97385: PUSH
97386: LD_INT 12
97388: PUSH
97389: LD_INT 15
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: PUSH
97398: LD_VAR 0 2
97402: PUSH
97403: LD_INT 9
97405: MINUS
97406: ARRAY
97407: ST_TO_ADDR
// end ; 14 :
97408: GO 97827
97410: LD_INT 14
97412: DOUBLE
97413: EQUAL
97414: IFTRUE 97418
97416: GO 97429
97418: POP
// bc_type := b_workshop ; 15 :
97419: LD_ADDR_OWVAR 42
97423: PUSH
97424: LD_INT 2
97426: ST_TO_ADDR
97427: GO 97827
97429: LD_INT 15
97431: DOUBLE
97432: EQUAL
97433: IFTRUE 97437
97435: GO 97448
97437: POP
// bc_type := b_factory ; 16 :
97438: LD_ADDR_OWVAR 42
97442: PUSH
97443: LD_INT 3
97445: ST_TO_ADDR
97446: GO 97827
97448: LD_INT 16
97450: DOUBLE
97451: EQUAL
97452: IFTRUE 97456
97454: GO 97467
97456: POP
// bc_type := b_ext_gun ; 17 :
97457: LD_ADDR_OWVAR 42
97461: PUSH
97462: LD_INT 17
97464: ST_TO_ADDR
97465: GO 97827
97467: LD_INT 17
97469: DOUBLE
97470: EQUAL
97471: IFTRUE 97475
97473: GO 97503
97475: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
97476: LD_ADDR_OWVAR 42
97480: PUSH
97481: LD_INT 19
97483: PUSH
97484: LD_INT 23
97486: PUSH
97487: LD_INT 19
97489: PUSH
97490: EMPTY
97491: LIST
97492: LIST
97493: LIST
97494: PUSH
97495: LD_VAR 0 1
97499: ARRAY
97500: ST_TO_ADDR
97501: GO 97827
97503: LD_INT 18
97505: DOUBLE
97506: EQUAL
97507: IFTRUE 97511
97509: GO 97522
97511: POP
// bc_type := b_ext_radar ; 19 :
97512: LD_ADDR_OWVAR 42
97516: PUSH
97517: LD_INT 20
97519: ST_TO_ADDR
97520: GO 97827
97522: LD_INT 19
97524: DOUBLE
97525: EQUAL
97526: IFTRUE 97530
97528: GO 97541
97530: POP
// bc_type := b_ext_radio ; 20 :
97531: LD_ADDR_OWVAR 42
97535: PUSH
97536: LD_INT 22
97538: ST_TO_ADDR
97539: GO 97827
97541: LD_INT 20
97543: DOUBLE
97544: EQUAL
97545: IFTRUE 97549
97547: GO 97560
97549: POP
// bc_type := b_ext_siberium ; 21 :
97550: LD_ADDR_OWVAR 42
97554: PUSH
97555: LD_INT 21
97557: ST_TO_ADDR
97558: GO 97827
97560: LD_INT 21
97562: DOUBLE
97563: EQUAL
97564: IFTRUE 97568
97566: GO 97579
97568: POP
// bc_type := b_ext_computer ; 22 :
97569: LD_ADDR_OWVAR 42
97573: PUSH
97574: LD_INT 24
97576: ST_TO_ADDR
97577: GO 97827
97579: LD_INT 22
97581: DOUBLE
97582: EQUAL
97583: IFTRUE 97587
97585: GO 97598
97587: POP
// bc_type := b_ext_track ; 23 :
97588: LD_ADDR_OWVAR 42
97592: PUSH
97593: LD_INT 16
97595: ST_TO_ADDR
97596: GO 97827
97598: LD_INT 23
97600: DOUBLE
97601: EQUAL
97602: IFTRUE 97606
97604: GO 97617
97606: POP
// bc_type := b_ext_laser ; 24 :
97607: LD_ADDR_OWVAR 42
97611: PUSH
97612: LD_INT 25
97614: ST_TO_ADDR
97615: GO 97827
97617: LD_INT 24
97619: DOUBLE
97620: EQUAL
97621: IFTRUE 97625
97623: GO 97636
97625: POP
// bc_type := b_control_tower ; 25 :
97626: LD_ADDR_OWVAR 42
97630: PUSH
97631: LD_INT 36
97633: ST_TO_ADDR
97634: GO 97827
97636: LD_INT 25
97638: DOUBLE
97639: EQUAL
97640: IFTRUE 97644
97642: GO 97655
97644: POP
// bc_type := b_breastwork ; 26 :
97645: LD_ADDR_OWVAR 42
97649: PUSH
97650: LD_INT 31
97652: ST_TO_ADDR
97653: GO 97827
97655: LD_INT 26
97657: DOUBLE
97658: EQUAL
97659: IFTRUE 97663
97661: GO 97674
97663: POP
// bc_type := b_bunker ; 27 :
97664: LD_ADDR_OWVAR 42
97668: PUSH
97669: LD_INT 32
97671: ST_TO_ADDR
97672: GO 97827
97674: LD_INT 27
97676: DOUBLE
97677: EQUAL
97678: IFTRUE 97682
97680: GO 97693
97682: POP
// bc_type := b_turret ; 28 :
97683: LD_ADDR_OWVAR 42
97687: PUSH
97688: LD_INT 33
97690: ST_TO_ADDR
97691: GO 97827
97693: LD_INT 28
97695: DOUBLE
97696: EQUAL
97697: IFTRUE 97701
97699: GO 97712
97701: POP
// bc_type := b_armoury ; 29 :
97702: LD_ADDR_OWVAR 42
97706: PUSH
97707: LD_INT 4
97709: ST_TO_ADDR
97710: GO 97827
97712: LD_INT 29
97714: DOUBLE
97715: EQUAL
97716: IFTRUE 97720
97718: GO 97731
97720: POP
// bc_type := b_barracks ; 30 :
97721: LD_ADDR_OWVAR 42
97725: PUSH
97726: LD_INT 5
97728: ST_TO_ADDR
97729: GO 97827
97731: LD_INT 30
97733: DOUBLE
97734: EQUAL
97735: IFTRUE 97739
97737: GO 97750
97739: POP
// bc_type := b_solar_power ; 31 :
97740: LD_ADDR_OWVAR 42
97744: PUSH
97745: LD_INT 27
97747: ST_TO_ADDR
97748: GO 97827
97750: LD_INT 31
97752: DOUBLE
97753: EQUAL
97754: IFTRUE 97758
97756: GO 97769
97758: POP
// bc_type := b_oil_power ; 32 :
97759: LD_ADDR_OWVAR 42
97763: PUSH
97764: LD_INT 26
97766: ST_TO_ADDR
97767: GO 97827
97769: LD_INT 32
97771: DOUBLE
97772: EQUAL
97773: IFTRUE 97777
97775: GO 97788
97777: POP
// bc_type := b_siberite_power ; 33 :
97778: LD_ADDR_OWVAR 42
97782: PUSH
97783: LD_INT 28
97785: ST_TO_ADDR
97786: GO 97827
97788: LD_INT 33
97790: DOUBLE
97791: EQUAL
97792: IFTRUE 97796
97794: GO 97807
97796: POP
// bc_type := b_oil_mine ; 34 :
97797: LD_ADDR_OWVAR 42
97801: PUSH
97802: LD_INT 29
97804: ST_TO_ADDR
97805: GO 97827
97807: LD_INT 34
97809: DOUBLE
97810: EQUAL
97811: IFTRUE 97815
97813: GO 97826
97815: POP
// bc_type := b_siberite_mine ; end ;
97816: LD_ADDR_OWVAR 42
97820: PUSH
97821: LD_INT 30
97823: ST_TO_ADDR
97824: GO 97827
97826: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
97827: LD_ADDR_VAR 0 8
97831: PUSH
97832: LD_VAR 0 5
97836: PPUSH
97837: LD_VAR 0 6
97841: PPUSH
97842: LD_VAR 0 3
97846: PPUSH
97847: CALL_OW 47
97851: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
97852: LD_OWVAR 42
97856: PUSH
97857: LD_INT 32
97859: PUSH
97860: LD_INT 33
97862: PUSH
97863: EMPTY
97864: LIST
97865: LIST
97866: IN
97867: IFFALSE 97883
// PlaceWeaponTurret ( b , weapon ) ;
97869: LD_VAR 0 8
97873: PPUSH
97874: LD_VAR 0 4
97878: PPUSH
97879: CALL_OW 431
// end ;
97883: LD_VAR 0 7
97887: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
97888: LD_INT 0
97890: PPUSH
97891: PPUSH
97892: PPUSH
97893: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97894: LD_ADDR_VAR 0 4
97898: PUSH
97899: LD_INT 22
97901: PUSH
97902: LD_OWVAR 2
97906: PUSH
97907: EMPTY
97908: LIST
97909: LIST
97910: PUSH
97911: LD_INT 2
97913: PUSH
97914: LD_INT 30
97916: PUSH
97917: LD_INT 0
97919: PUSH
97920: EMPTY
97921: LIST
97922: LIST
97923: PUSH
97924: LD_INT 30
97926: PUSH
97927: LD_INT 1
97929: PUSH
97930: EMPTY
97931: LIST
97932: LIST
97933: PUSH
97934: EMPTY
97935: LIST
97936: LIST
97937: LIST
97938: PUSH
97939: EMPTY
97940: LIST
97941: LIST
97942: PPUSH
97943: CALL_OW 69
97947: ST_TO_ADDR
// if not tmp then
97948: LD_VAR 0 4
97952: NOT
97953: IFFALSE 97957
// exit ;
97955: GO 98016
// for i in tmp do
97957: LD_ADDR_VAR 0 2
97961: PUSH
97962: LD_VAR 0 4
97966: PUSH
97967: FOR_IN
97968: IFFALSE 98014
// for j = 1 to 3 do
97970: LD_ADDR_VAR 0 3
97974: PUSH
97975: DOUBLE
97976: LD_INT 1
97978: DEC
97979: ST_TO_ADDR
97980: LD_INT 3
97982: PUSH
97983: FOR_TO
97984: IFFALSE 98010
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
97986: LD_VAR 0 2
97990: PPUSH
97991: CALL_OW 274
97995: PPUSH
97996: LD_VAR 0 3
98000: PPUSH
98001: LD_INT 99999
98003: PPUSH
98004: CALL_OW 277
98008: GO 97983
98010: POP
98011: POP
98012: GO 97967
98014: POP
98015: POP
// end ;
98016: LD_VAR 0 1
98020: RET
// export function hHackSetLevel10 ; var i , j ; begin
98021: LD_INT 0
98023: PPUSH
98024: PPUSH
98025: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
98026: LD_ADDR_VAR 0 2
98030: PUSH
98031: LD_INT 21
98033: PUSH
98034: LD_INT 1
98036: PUSH
98037: EMPTY
98038: LIST
98039: LIST
98040: PPUSH
98041: CALL_OW 69
98045: PUSH
98046: FOR_IN
98047: IFFALSE 98099
// if IsSelected ( i ) then
98049: LD_VAR 0 2
98053: PPUSH
98054: CALL_OW 306
98058: IFFALSE 98097
// begin for j := 1 to 4 do
98060: LD_ADDR_VAR 0 3
98064: PUSH
98065: DOUBLE
98066: LD_INT 1
98068: DEC
98069: ST_TO_ADDR
98070: LD_INT 4
98072: PUSH
98073: FOR_TO
98074: IFFALSE 98095
// SetSkill ( i , j , 10 ) ;
98076: LD_VAR 0 2
98080: PPUSH
98081: LD_VAR 0 3
98085: PPUSH
98086: LD_INT 10
98088: PPUSH
98089: CALL_OW 237
98093: GO 98073
98095: POP
98096: POP
// end ;
98097: GO 98046
98099: POP
98100: POP
// end ;
98101: LD_VAR 0 1
98105: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
98106: LD_INT 0
98108: PPUSH
98109: PPUSH
98110: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
98111: LD_ADDR_VAR 0 2
98115: PUSH
98116: LD_INT 22
98118: PUSH
98119: LD_OWVAR 2
98123: PUSH
98124: EMPTY
98125: LIST
98126: LIST
98127: PUSH
98128: LD_INT 21
98130: PUSH
98131: LD_INT 1
98133: PUSH
98134: EMPTY
98135: LIST
98136: LIST
98137: PUSH
98138: EMPTY
98139: LIST
98140: LIST
98141: PPUSH
98142: CALL_OW 69
98146: PUSH
98147: FOR_IN
98148: IFFALSE 98189
// begin for j := 1 to 4 do
98150: LD_ADDR_VAR 0 3
98154: PUSH
98155: DOUBLE
98156: LD_INT 1
98158: DEC
98159: ST_TO_ADDR
98160: LD_INT 4
98162: PUSH
98163: FOR_TO
98164: IFFALSE 98185
// SetSkill ( i , j , 10 ) ;
98166: LD_VAR 0 2
98170: PPUSH
98171: LD_VAR 0 3
98175: PPUSH
98176: LD_INT 10
98178: PPUSH
98179: CALL_OW 237
98183: GO 98163
98185: POP
98186: POP
// end ;
98187: GO 98147
98189: POP
98190: POP
// end ;
98191: LD_VAR 0 1
98195: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
98196: LD_INT 0
98198: PPUSH
// uc_side := your_side ;
98199: LD_ADDR_OWVAR 20
98203: PUSH
98204: LD_OWVAR 2
98208: ST_TO_ADDR
// uc_nation := nation ;
98209: LD_ADDR_OWVAR 21
98213: PUSH
98214: LD_VAR 0 1
98218: ST_TO_ADDR
// InitHc ;
98219: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
98223: LD_INT 0
98225: PPUSH
98226: LD_VAR 0 2
98230: PPUSH
98231: LD_VAR 0 3
98235: PPUSH
98236: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
98240: LD_VAR 0 4
98244: PPUSH
98245: LD_VAR 0 5
98249: PPUSH
98250: CALL_OW 428
98254: PUSH
98255: LD_INT 0
98257: EQUAL
98258: IFFALSE 98282
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
98260: CALL_OW 44
98264: PPUSH
98265: LD_VAR 0 4
98269: PPUSH
98270: LD_VAR 0 5
98274: PPUSH
98275: LD_INT 1
98277: PPUSH
98278: CALL_OW 48
// end ;
98282: LD_VAR 0 6
98286: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
98287: LD_INT 0
98289: PPUSH
98290: PPUSH
// uc_side := your_side ;
98291: LD_ADDR_OWVAR 20
98295: PUSH
98296: LD_OWVAR 2
98300: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
98301: LD_VAR 0 1
98305: PUSH
98306: LD_INT 1
98308: PUSH
98309: LD_INT 2
98311: PUSH
98312: LD_INT 3
98314: PUSH
98315: LD_INT 4
98317: PUSH
98318: LD_INT 5
98320: PUSH
98321: EMPTY
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: IN
98328: IFFALSE 98340
// uc_nation := nation_american else
98330: LD_ADDR_OWVAR 21
98334: PUSH
98335: LD_INT 1
98337: ST_TO_ADDR
98338: GO 98383
// if chassis in [ 11 , 12 , 13 , 14 ] then
98340: LD_VAR 0 1
98344: PUSH
98345: LD_INT 11
98347: PUSH
98348: LD_INT 12
98350: PUSH
98351: LD_INT 13
98353: PUSH
98354: LD_INT 14
98356: PUSH
98357: EMPTY
98358: LIST
98359: LIST
98360: LIST
98361: LIST
98362: IN
98363: IFFALSE 98375
// uc_nation := nation_arabian else
98365: LD_ADDR_OWVAR 21
98369: PUSH
98370: LD_INT 2
98372: ST_TO_ADDR
98373: GO 98383
// uc_nation := nation_russian ;
98375: LD_ADDR_OWVAR 21
98379: PUSH
98380: LD_INT 3
98382: ST_TO_ADDR
// vc_chassis := chassis ;
98383: LD_ADDR_OWVAR 37
98387: PUSH
98388: LD_VAR 0 1
98392: ST_TO_ADDR
// vc_engine := engine ;
98393: LD_ADDR_OWVAR 39
98397: PUSH
98398: LD_VAR 0 2
98402: ST_TO_ADDR
// vc_control := control ;
98403: LD_ADDR_OWVAR 38
98407: PUSH
98408: LD_VAR 0 3
98412: ST_TO_ADDR
// vc_weapon := weapon ;
98413: LD_ADDR_OWVAR 40
98417: PUSH
98418: LD_VAR 0 4
98422: ST_TO_ADDR
// un := CreateVehicle ;
98423: LD_ADDR_VAR 0 8
98427: PUSH
98428: CALL_OW 45
98432: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
98433: LD_VAR 0 8
98437: PPUSH
98438: LD_INT 0
98440: PPUSH
98441: LD_INT 5
98443: PPUSH
98444: CALL_OW 12
98448: PPUSH
98449: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
98453: LD_VAR 0 8
98457: PPUSH
98458: LD_VAR 0 5
98462: PPUSH
98463: LD_VAR 0 6
98467: PPUSH
98468: LD_INT 1
98470: PPUSH
98471: CALL_OW 48
// end ;
98475: LD_VAR 0 7
98479: RET
// export hInvincible ; every 1 do
98480: GO 98482
98482: DISABLE
// hInvincible := [ ] ;
98483: LD_ADDR_EXP 163
98487: PUSH
98488: EMPTY
98489: ST_TO_ADDR
98490: END
// every 10 do var i ;
98491: GO 98493
98493: DISABLE
98494: LD_INT 0
98496: PPUSH
// begin enable ;
98497: ENABLE
// if not hInvincible then
98498: LD_EXP 163
98502: NOT
98503: IFFALSE 98507
// exit ;
98505: GO 98551
// for i in hInvincible do
98507: LD_ADDR_VAR 0 1
98511: PUSH
98512: LD_EXP 163
98516: PUSH
98517: FOR_IN
98518: IFFALSE 98549
// if GetLives ( i ) < 1000 then
98520: LD_VAR 0 1
98524: PPUSH
98525: CALL_OW 256
98529: PUSH
98530: LD_INT 1000
98532: LESS
98533: IFFALSE 98547
// SetLives ( i , 1000 ) ;
98535: LD_VAR 0 1
98539: PPUSH
98540: LD_INT 1000
98542: PPUSH
98543: CALL_OW 234
98547: GO 98517
98549: POP
98550: POP
// end ;
98551: PPOPN 1
98553: END
// export function hHackInvincible ; var i ; begin
98554: LD_INT 0
98556: PPUSH
98557: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
98558: LD_ADDR_VAR 0 2
98562: PUSH
98563: LD_INT 2
98565: PUSH
98566: LD_INT 21
98568: PUSH
98569: LD_INT 1
98571: PUSH
98572: EMPTY
98573: LIST
98574: LIST
98575: PUSH
98576: LD_INT 21
98578: PUSH
98579: LD_INT 2
98581: PUSH
98582: EMPTY
98583: LIST
98584: LIST
98585: PUSH
98586: EMPTY
98587: LIST
98588: LIST
98589: LIST
98590: PPUSH
98591: CALL_OW 69
98595: PUSH
98596: FOR_IN
98597: IFFALSE 98658
// if IsSelected ( i ) then
98599: LD_VAR 0 2
98603: PPUSH
98604: CALL_OW 306
98608: IFFALSE 98656
// begin if i in hInvincible then
98610: LD_VAR 0 2
98614: PUSH
98615: LD_EXP 163
98619: IN
98620: IFFALSE 98640
// hInvincible := hInvincible diff i else
98622: LD_ADDR_EXP 163
98626: PUSH
98627: LD_EXP 163
98631: PUSH
98632: LD_VAR 0 2
98636: DIFF
98637: ST_TO_ADDR
98638: GO 98656
// hInvincible := hInvincible union i ;
98640: LD_ADDR_EXP 163
98644: PUSH
98645: LD_EXP 163
98649: PUSH
98650: LD_VAR 0 2
98654: UNION
98655: ST_TO_ADDR
// end ;
98656: GO 98596
98658: POP
98659: POP
// end ;
98660: LD_VAR 0 1
98664: RET
// export function hHackInvisible ; var i , j ; begin
98665: LD_INT 0
98667: PPUSH
98668: PPUSH
98669: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
98670: LD_ADDR_VAR 0 2
98674: PUSH
98675: LD_INT 21
98677: PUSH
98678: LD_INT 1
98680: PUSH
98681: EMPTY
98682: LIST
98683: LIST
98684: PPUSH
98685: CALL_OW 69
98689: PUSH
98690: FOR_IN
98691: IFFALSE 98715
// if IsSelected ( i ) then
98693: LD_VAR 0 2
98697: PPUSH
98698: CALL_OW 306
98702: IFFALSE 98713
// ComForceInvisible ( i ) ;
98704: LD_VAR 0 2
98708: PPUSH
98709: CALL_OW 496
98713: GO 98690
98715: POP
98716: POP
// end ;
98717: LD_VAR 0 1
98721: RET
// export function hHackChangeYourSide ; begin
98722: LD_INT 0
98724: PPUSH
// if your_side = 8 then
98725: LD_OWVAR 2
98729: PUSH
98730: LD_INT 8
98732: EQUAL
98733: IFFALSE 98745
// your_side := 0 else
98735: LD_ADDR_OWVAR 2
98739: PUSH
98740: LD_INT 0
98742: ST_TO_ADDR
98743: GO 98759
// your_side := your_side + 1 ;
98745: LD_ADDR_OWVAR 2
98749: PUSH
98750: LD_OWVAR 2
98754: PUSH
98755: LD_INT 1
98757: PLUS
98758: ST_TO_ADDR
// end ;
98759: LD_VAR 0 1
98763: RET
// export function hHackChangeUnitSide ; var i , j ; begin
98764: LD_INT 0
98766: PPUSH
98767: PPUSH
98768: PPUSH
// for i in all_units do
98769: LD_ADDR_VAR 0 2
98773: PUSH
98774: LD_OWVAR 3
98778: PUSH
98779: FOR_IN
98780: IFFALSE 98858
// if IsSelected ( i ) then
98782: LD_VAR 0 2
98786: PPUSH
98787: CALL_OW 306
98791: IFFALSE 98856
// begin j := GetSide ( i ) ;
98793: LD_ADDR_VAR 0 3
98797: PUSH
98798: LD_VAR 0 2
98802: PPUSH
98803: CALL_OW 255
98807: ST_TO_ADDR
// if j = 8 then
98808: LD_VAR 0 3
98812: PUSH
98813: LD_INT 8
98815: EQUAL
98816: IFFALSE 98828
// j := 0 else
98818: LD_ADDR_VAR 0 3
98822: PUSH
98823: LD_INT 0
98825: ST_TO_ADDR
98826: GO 98842
// j := j + 1 ;
98828: LD_ADDR_VAR 0 3
98832: PUSH
98833: LD_VAR 0 3
98837: PUSH
98838: LD_INT 1
98840: PLUS
98841: ST_TO_ADDR
// SetSide ( i , j ) ;
98842: LD_VAR 0 2
98846: PPUSH
98847: LD_VAR 0 3
98851: PPUSH
98852: CALL_OW 235
// end ;
98856: GO 98779
98858: POP
98859: POP
// end ;
98860: LD_VAR 0 1
98864: RET
// export function hHackFog ; begin
98865: LD_INT 0
98867: PPUSH
// FogOff ( true ) ;
98868: LD_INT 1
98870: PPUSH
98871: CALL_OW 344
// end ;
98875: LD_VAR 0 1
98879: RET
// export function hHackTeleport ( unit , x , y ) ; begin
98880: LD_INT 0
98882: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
98883: LD_VAR 0 1
98887: PPUSH
98888: LD_VAR 0 2
98892: PPUSH
98893: LD_VAR 0 3
98897: PPUSH
98898: LD_INT 1
98900: PPUSH
98901: LD_INT 1
98903: PPUSH
98904: CALL_OW 483
// CenterOnXY ( x , y ) ;
98908: LD_VAR 0 2
98912: PPUSH
98913: LD_VAR 0 3
98917: PPUSH
98918: CALL_OW 84
// end ; end_of_file
98922: LD_VAR 0 4
98926: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
98927: LD_INT 0
98929: PPUSH
98930: PPUSH
98931: PPUSH
98932: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
98933: LD_VAR 0 1
98937: PPUSH
98938: CALL_OW 264
98942: PUSH
98943: LD_EXP 97
98947: EQUAL
98948: IFFALSE 99020
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
98950: LD_INT 68
98952: PPUSH
98953: LD_VAR 0 1
98957: PPUSH
98958: CALL_OW 255
98962: PPUSH
98963: CALL_OW 321
98967: PUSH
98968: LD_INT 2
98970: EQUAL
98971: IFFALSE 98983
// eff := 70 else
98973: LD_ADDR_VAR 0 4
98977: PUSH
98978: LD_INT 70
98980: ST_TO_ADDR
98981: GO 98991
// eff := 30 ;
98983: LD_ADDR_VAR 0 4
98987: PUSH
98988: LD_INT 30
98990: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
98991: LD_VAR 0 1
98995: PPUSH
98996: CALL_OW 250
99000: PPUSH
99001: LD_VAR 0 1
99005: PPUSH
99006: CALL_OW 251
99010: PPUSH
99011: LD_VAR 0 4
99015: PPUSH
99016: CALL_OW 495
// end ; end ;
99020: LD_VAR 0 2
99024: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
99025: LD_INT 0
99027: PPUSH
// end ;
99028: LD_VAR 0 4
99032: RET
// export function SOS_Command ( cmd ) ; begin
99033: LD_INT 0
99035: PPUSH
// end ;
99036: LD_VAR 0 2
99040: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
99041: LD_INT 0
99043: PPUSH
// if cmd = 121 then
99044: LD_VAR 0 1
99048: PUSH
99049: LD_INT 121
99051: EQUAL
99052: IFFALSE 99054
// end ;
99054: LD_VAR 0 6
99058: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
99059: LD_INT 0
99061: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
99062: LD_VAR 0 1
99066: PUSH
99067: LD_INT 250
99069: EQUAL
99070: PUSH
99071: LD_VAR 0 2
99075: PPUSH
99076: CALL_OW 264
99080: PUSH
99081: LD_EXP 100
99085: EQUAL
99086: AND
99087: IFFALSE 99108
// MinerPlaceMine ( unit , x , y ) ;
99089: LD_VAR 0 2
99093: PPUSH
99094: LD_VAR 0 4
99098: PPUSH
99099: LD_VAR 0 5
99103: PPUSH
99104: CALL 101457 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
99108: LD_VAR 0 1
99112: PUSH
99113: LD_INT 251
99115: EQUAL
99116: PUSH
99117: LD_VAR 0 2
99121: PPUSH
99122: CALL_OW 264
99126: PUSH
99127: LD_EXP 100
99131: EQUAL
99132: AND
99133: IFFALSE 99154
// MinerDetonateMine ( unit , x , y ) ;
99135: LD_VAR 0 2
99139: PPUSH
99140: LD_VAR 0 4
99144: PPUSH
99145: LD_VAR 0 5
99149: PPUSH
99150: CALL 101734 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
99154: LD_VAR 0 1
99158: PUSH
99159: LD_INT 252
99161: EQUAL
99162: PUSH
99163: LD_VAR 0 2
99167: PPUSH
99168: CALL_OW 264
99172: PUSH
99173: LD_EXP 100
99177: EQUAL
99178: AND
99179: IFFALSE 99200
// MinerCreateMinefield ( unit , x , y ) ;
99181: LD_VAR 0 2
99185: PPUSH
99186: LD_VAR 0 4
99190: PPUSH
99191: LD_VAR 0 5
99195: PPUSH
99196: CALL 102151 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
99200: LD_VAR 0 1
99204: PUSH
99205: LD_INT 253
99207: EQUAL
99208: PUSH
99209: LD_VAR 0 2
99213: PPUSH
99214: CALL_OW 257
99218: PUSH
99219: LD_INT 5
99221: EQUAL
99222: AND
99223: IFFALSE 99244
// ComBinocular ( unit , x , y ) ;
99225: LD_VAR 0 2
99229: PPUSH
99230: LD_VAR 0 4
99234: PPUSH
99235: LD_VAR 0 5
99239: PPUSH
99240: CALL 102522 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
99244: LD_VAR 0 1
99248: PUSH
99249: LD_INT 254
99251: EQUAL
99252: PUSH
99253: LD_VAR 0 2
99257: PPUSH
99258: CALL_OW 264
99262: PUSH
99263: LD_EXP 95
99267: EQUAL
99268: AND
99269: PUSH
99270: LD_VAR 0 3
99274: PPUSH
99275: CALL_OW 263
99279: PUSH
99280: LD_INT 3
99282: EQUAL
99283: AND
99284: IFFALSE 99300
// HackDestroyVehicle ( unit , selectedUnit ) ;
99286: LD_VAR 0 2
99290: PPUSH
99291: LD_VAR 0 3
99295: PPUSH
99296: CALL 100817 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
99300: LD_VAR 0 1
99304: PUSH
99305: LD_INT 255
99307: EQUAL
99308: PUSH
99309: LD_VAR 0 2
99313: PPUSH
99314: CALL_OW 264
99318: PUSH
99319: LD_INT 14
99321: PUSH
99322: LD_INT 53
99324: PUSH
99325: EMPTY
99326: LIST
99327: LIST
99328: IN
99329: AND
99330: PUSH
99331: LD_VAR 0 4
99335: PPUSH
99336: LD_VAR 0 5
99340: PPUSH
99341: CALL_OW 488
99345: AND
99346: IFFALSE 99370
// CutTreeXYR ( unit , x , y , 12 ) ;
99348: LD_VAR 0 2
99352: PPUSH
99353: LD_VAR 0 4
99357: PPUSH
99358: LD_VAR 0 5
99362: PPUSH
99363: LD_INT 12
99365: PPUSH
99366: CALL 99383 0 4
// end ;
99370: LD_VAR 0 6
99374: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
99375: LD_INT 0
99377: PPUSH
// end ;
99378: LD_VAR 0 4
99382: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
99383: LD_INT 0
99385: PPUSH
99386: PPUSH
99387: PPUSH
99388: PPUSH
99389: PPUSH
99390: PPUSH
99391: PPUSH
99392: PPUSH
99393: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
99394: LD_VAR 0 1
99398: NOT
99399: PUSH
99400: LD_VAR 0 2
99404: PPUSH
99405: LD_VAR 0 3
99409: PPUSH
99410: CALL_OW 488
99414: NOT
99415: OR
99416: PUSH
99417: LD_VAR 0 4
99421: NOT
99422: OR
99423: IFFALSE 99427
// exit ;
99425: GO 99767
// list := [ ] ;
99427: LD_ADDR_VAR 0 13
99431: PUSH
99432: EMPTY
99433: ST_TO_ADDR
// if x - r < 0 then
99434: LD_VAR 0 2
99438: PUSH
99439: LD_VAR 0 4
99443: MINUS
99444: PUSH
99445: LD_INT 0
99447: LESS
99448: IFFALSE 99460
// min_x := 0 else
99450: LD_ADDR_VAR 0 7
99454: PUSH
99455: LD_INT 0
99457: ST_TO_ADDR
99458: GO 99476
// min_x := x - r ;
99460: LD_ADDR_VAR 0 7
99464: PUSH
99465: LD_VAR 0 2
99469: PUSH
99470: LD_VAR 0 4
99474: MINUS
99475: ST_TO_ADDR
// if y - r < 0 then
99476: LD_VAR 0 3
99480: PUSH
99481: LD_VAR 0 4
99485: MINUS
99486: PUSH
99487: LD_INT 0
99489: LESS
99490: IFFALSE 99502
// min_y := 0 else
99492: LD_ADDR_VAR 0 8
99496: PUSH
99497: LD_INT 0
99499: ST_TO_ADDR
99500: GO 99518
// min_y := y - r ;
99502: LD_ADDR_VAR 0 8
99506: PUSH
99507: LD_VAR 0 3
99511: PUSH
99512: LD_VAR 0 4
99516: MINUS
99517: ST_TO_ADDR
// max_x := x + r ;
99518: LD_ADDR_VAR 0 9
99522: PUSH
99523: LD_VAR 0 2
99527: PUSH
99528: LD_VAR 0 4
99532: PLUS
99533: ST_TO_ADDR
// max_y := y + r ;
99534: LD_ADDR_VAR 0 10
99538: PUSH
99539: LD_VAR 0 3
99543: PUSH
99544: LD_VAR 0 4
99548: PLUS
99549: ST_TO_ADDR
// for _x = min_x to max_x do
99550: LD_ADDR_VAR 0 11
99554: PUSH
99555: DOUBLE
99556: LD_VAR 0 7
99560: DEC
99561: ST_TO_ADDR
99562: LD_VAR 0 9
99566: PUSH
99567: FOR_TO
99568: IFFALSE 99685
// for _y = min_y to max_y do
99570: LD_ADDR_VAR 0 12
99574: PUSH
99575: DOUBLE
99576: LD_VAR 0 8
99580: DEC
99581: ST_TO_ADDR
99582: LD_VAR 0 10
99586: PUSH
99587: FOR_TO
99588: IFFALSE 99681
// begin if not ValidHex ( _x , _y ) then
99590: LD_VAR 0 11
99594: PPUSH
99595: LD_VAR 0 12
99599: PPUSH
99600: CALL_OW 488
99604: NOT
99605: IFFALSE 99609
// continue ;
99607: GO 99587
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
99609: LD_VAR 0 11
99613: PPUSH
99614: LD_VAR 0 12
99618: PPUSH
99619: CALL_OW 351
99623: PUSH
99624: LD_VAR 0 11
99628: PPUSH
99629: LD_VAR 0 12
99633: PPUSH
99634: CALL_OW 554
99638: AND
99639: IFFALSE 99679
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
99641: LD_ADDR_VAR 0 13
99645: PUSH
99646: LD_VAR 0 13
99650: PPUSH
99651: LD_VAR 0 13
99655: PUSH
99656: LD_INT 1
99658: PLUS
99659: PPUSH
99660: LD_VAR 0 11
99664: PUSH
99665: LD_VAR 0 12
99669: PUSH
99670: EMPTY
99671: LIST
99672: LIST
99673: PPUSH
99674: CALL_OW 2
99678: ST_TO_ADDR
// end ;
99679: GO 99587
99681: POP
99682: POP
99683: GO 99567
99685: POP
99686: POP
// if not list then
99687: LD_VAR 0 13
99691: NOT
99692: IFFALSE 99696
// exit ;
99694: GO 99767
// for i in list do
99696: LD_ADDR_VAR 0 6
99700: PUSH
99701: LD_VAR 0 13
99705: PUSH
99706: FOR_IN
99707: IFFALSE 99765
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
99709: LD_VAR 0 1
99713: PPUSH
99714: LD_STRING M
99716: PUSH
99717: LD_VAR 0 6
99721: PUSH
99722: LD_INT 1
99724: ARRAY
99725: PUSH
99726: LD_VAR 0 6
99730: PUSH
99731: LD_INT 2
99733: ARRAY
99734: PUSH
99735: LD_INT 0
99737: PUSH
99738: LD_INT 0
99740: PUSH
99741: LD_INT 0
99743: PUSH
99744: LD_INT 0
99746: PUSH
99747: EMPTY
99748: LIST
99749: LIST
99750: LIST
99751: LIST
99752: LIST
99753: LIST
99754: LIST
99755: PUSH
99756: EMPTY
99757: LIST
99758: PPUSH
99759: CALL_OW 447
99763: GO 99706
99765: POP
99766: POP
// end ;
99767: LD_VAR 0 5
99771: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
99772: LD_EXP 166
99776: NOT
99777: IFFALSE 99827
99779: GO 99781
99781: DISABLE
// begin initHack := true ;
99782: LD_ADDR_EXP 166
99786: PUSH
99787: LD_INT 1
99789: ST_TO_ADDR
// hackTanks := [ ] ;
99790: LD_ADDR_EXP 167
99794: PUSH
99795: EMPTY
99796: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
99797: LD_ADDR_EXP 168
99801: PUSH
99802: EMPTY
99803: ST_TO_ADDR
// hackLimit := 3 ;
99804: LD_ADDR_EXP 169
99808: PUSH
99809: LD_INT 3
99811: ST_TO_ADDR
// hackDist := 12 ;
99812: LD_ADDR_EXP 170
99816: PUSH
99817: LD_INT 12
99819: ST_TO_ADDR
// hackCounter := [ ] ;
99820: LD_ADDR_EXP 171
99824: PUSH
99825: EMPTY
99826: ST_TO_ADDR
// end ;
99827: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
99828: LD_EXP 166
99832: PUSH
99833: LD_INT 34
99835: PUSH
99836: LD_EXP 95
99840: PUSH
99841: EMPTY
99842: LIST
99843: LIST
99844: PPUSH
99845: CALL_OW 69
99849: AND
99850: IFFALSE 100105
99852: GO 99854
99854: DISABLE
99855: LD_INT 0
99857: PPUSH
99858: PPUSH
// begin enable ;
99859: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
99860: LD_ADDR_VAR 0 1
99864: PUSH
99865: LD_INT 34
99867: PUSH
99868: LD_EXP 95
99872: PUSH
99873: EMPTY
99874: LIST
99875: LIST
99876: PPUSH
99877: CALL_OW 69
99881: PUSH
99882: FOR_IN
99883: IFFALSE 100103
// begin if not i in hackTanks then
99885: LD_VAR 0 1
99889: PUSH
99890: LD_EXP 167
99894: IN
99895: NOT
99896: IFFALSE 99979
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
99898: LD_ADDR_EXP 167
99902: PUSH
99903: LD_EXP 167
99907: PPUSH
99908: LD_EXP 167
99912: PUSH
99913: LD_INT 1
99915: PLUS
99916: PPUSH
99917: LD_VAR 0 1
99921: PPUSH
99922: CALL_OW 1
99926: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
99927: LD_ADDR_EXP 168
99931: PUSH
99932: LD_EXP 168
99936: PPUSH
99937: LD_EXP 168
99941: PUSH
99942: LD_INT 1
99944: PLUS
99945: PPUSH
99946: EMPTY
99947: PPUSH
99948: CALL_OW 1
99952: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
99953: LD_ADDR_EXP 171
99957: PUSH
99958: LD_EXP 171
99962: PPUSH
99963: LD_EXP 171
99967: PUSH
99968: LD_INT 1
99970: PLUS
99971: PPUSH
99972: EMPTY
99973: PPUSH
99974: CALL_OW 1
99978: ST_TO_ADDR
// end ; if not IsOk ( i ) then
99979: LD_VAR 0 1
99983: PPUSH
99984: CALL_OW 302
99988: NOT
99989: IFFALSE 100002
// begin HackUnlinkAll ( i ) ;
99991: LD_VAR 0 1
99995: PPUSH
99996: CALL 100108 0 1
// continue ;
100000: GO 99882
// end ; HackCheckCapturedStatus ( i ) ;
100002: LD_VAR 0 1
100006: PPUSH
100007: CALL 100551 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
100011: LD_ADDR_VAR 0 2
100015: PUSH
100016: LD_INT 81
100018: PUSH
100019: LD_VAR 0 1
100023: PPUSH
100024: CALL_OW 255
100028: PUSH
100029: EMPTY
100030: LIST
100031: LIST
100032: PUSH
100033: LD_INT 33
100035: PUSH
100036: LD_INT 3
100038: PUSH
100039: EMPTY
100040: LIST
100041: LIST
100042: PUSH
100043: LD_INT 91
100045: PUSH
100046: LD_VAR 0 1
100050: PUSH
100051: LD_EXP 170
100055: PUSH
100056: EMPTY
100057: LIST
100058: LIST
100059: LIST
100060: PUSH
100061: LD_INT 50
100063: PUSH
100064: EMPTY
100065: LIST
100066: PUSH
100067: EMPTY
100068: LIST
100069: LIST
100070: LIST
100071: LIST
100072: PPUSH
100073: CALL_OW 69
100077: ST_TO_ADDR
// if not tmp then
100078: LD_VAR 0 2
100082: NOT
100083: IFFALSE 100087
// continue ;
100085: GO 99882
// HackLink ( i , tmp ) ;
100087: LD_VAR 0 1
100091: PPUSH
100092: LD_VAR 0 2
100096: PPUSH
100097: CALL 100244 0 2
// end ;
100101: GO 99882
100103: POP
100104: POP
// end ;
100105: PPOPN 2
100107: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
100108: LD_INT 0
100110: PPUSH
100111: PPUSH
100112: PPUSH
// if not hack in hackTanks then
100113: LD_VAR 0 1
100117: PUSH
100118: LD_EXP 167
100122: IN
100123: NOT
100124: IFFALSE 100128
// exit ;
100126: GO 100239
// index := GetElementIndex ( hackTanks , hack ) ;
100128: LD_ADDR_VAR 0 4
100132: PUSH
100133: LD_EXP 167
100137: PPUSH
100138: LD_VAR 0 1
100142: PPUSH
100143: CALL 52691 0 2
100147: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
100148: LD_EXP 168
100152: PUSH
100153: LD_VAR 0 4
100157: ARRAY
100158: IFFALSE 100239
// begin for i in hackTanksCaptured [ index ] do
100160: LD_ADDR_VAR 0 3
100164: PUSH
100165: LD_EXP 168
100169: PUSH
100170: LD_VAR 0 4
100174: ARRAY
100175: PUSH
100176: FOR_IN
100177: IFFALSE 100203
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
100179: LD_VAR 0 3
100183: PUSH
100184: LD_INT 1
100186: ARRAY
100187: PPUSH
100188: LD_VAR 0 3
100192: PUSH
100193: LD_INT 2
100195: ARRAY
100196: PPUSH
100197: CALL_OW 235
100201: GO 100176
100203: POP
100204: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
100205: LD_ADDR_EXP 168
100209: PUSH
100210: LD_EXP 168
100214: PPUSH
100215: LD_VAR 0 4
100219: PPUSH
100220: EMPTY
100221: PPUSH
100222: CALL_OW 1
100226: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
100227: LD_VAR 0 1
100231: PPUSH
100232: LD_INT 0
100234: PPUSH
100235: CALL_OW 505
// end ; end ;
100239: LD_VAR 0 2
100243: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
100244: LD_INT 0
100246: PPUSH
100247: PPUSH
100248: PPUSH
// if not hack in hackTanks or not vehicles then
100249: LD_VAR 0 1
100253: PUSH
100254: LD_EXP 167
100258: IN
100259: NOT
100260: PUSH
100261: LD_VAR 0 2
100265: NOT
100266: OR
100267: IFFALSE 100271
// exit ;
100269: GO 100546
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
100271: LD_ADDR_VAR 0 2
100275: PUSH
100276: LD_VAR 0 1
100280: PPUSH
100281: LD_VAR 0 2
100285: PPUSH
100286: LD_INT 1
100288: PPUSH
100289: LD_INT 1
100291: PPUSH
100292: CALL 53341 0 4
100296: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
100297: LD_ADDR_VAR 0 5
100301: PUSH
100302: LD_EXP 167
100306: PPUSH
100307: LD_VAR 0 1
100311: PPUSH
100312: CALL 52691 0 2
100316: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
100317: LD_EXP 168
100321: PUSH
100322: LD_VAR 0 5
100326: ARRAY
100327: PUSH
100328: LD_EXP 169
100332: LESS
100333: IFFALSE 100522
// begin for i := 1 to vehicles do
100335: LD_ADDR_VAR 0 4
100339: PUSH
100340: DOUBLE
100341: LD_INT 1
100343: DEC
100344: ST_TO_ADDR
100345: LD_VAR 0 2
100349: PUSH
100350: FOR_TO
100351: IFFALSE 100520
// begin if hackTanksCaptured [ index ] = hackLimit then
100353: LD_EXP 168
100357: PUSH
100358: LD_VAR 0 5
100362: ARRAY
100363: PUSH
100364: LD_EXP 169
100368: EQUAL
100369: IFFALSE 100373
// break ;
100371: GO 100520
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
100373: LD_ADDR_EXP 171
100377: PUSH
100378: LD_EXP 171
100382: PPUSH
100383: LD_VAR 0 5
100387: PPUSH
100388: LD_EXP 171
100392: PUSH
100393: LD_VAR 0 5
100397: ARRAY
100398: PUSH
100399: LD_INT 1
100401: PLUS
100402: PPUSH
100403: CALL_OW 1
100407: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
100408: LD_ADDR_EXP 168
100412: PUSH
100413: LD_EXP 168
100417: PPUSH
100418: LD_VAR 0 5
100422: PUSH
100423: LD_EXP 168
100427: PUSH
100428: LD_VAR 0 5
100432: ARRAY
100433: PUSH
100434: LD_INT 1
100436: PLUS
100437: PUSH
100438: EMPTY
100439: LIST
100440: LIST
100441: PPUSH
100442: LD_VAR 0 2
100446: PUSH
100447: LD_VAR 0 4
100451: ARRAY
100452: PUSH
100453: LD_VAR 0 2
100457: PUSH
100458: LD_VAR 0 4
100462: ARRAY
100463: PPUSH
100464: CALL_OW 255
100468: PUSH
100469: EMPTY
100470: LIST
100471: LIST
100472: PPUSH
100473: CALL 52906 0 3
100477: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
100478: LD_VAR 0 2
100482: PUSH
100483: LD_VAR 0 4
100487: ARRAY
100488: PPUSH
100489: LD_VAR 0 1
100493: PPUSH
100494: CALL_OW 255
100498: PPUSH
100499: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
100503: LD_VAR 0 2
100507: PUSH
100508: LD_VAR 0 4
100512: ARRAY
100513: PPUSH
100514: CALL_OW 141
// end ;
100518: GO 100350
100520: POP
100521: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
100522: LD_VAR 0 1
100526: PPUSH
100527: LD_EXP 168
100531: PUSH
100532: LD_VAR 0 5
100536: ARRAY
100537: PUSH
100538: LD_INT 0
100540: PLUS
100541: PPUSH
100542: CALL_OW 505
// end ;
100546: LD_VAR 0 3
100550: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
100551: LD_INT 0
100553: PPUSH
100554: PPUSH
100555: PPUSH
100556: PPUSH
// if not hack in hackTanks then
100557: LD_VAR 0 1
100561: PUSH
100562: LD_EXP 167
100566: IN
100567: NOT
100568: IFFALSE 100572
// exit ;
100570: GO 100812
// index := GetElementIndex ( hackTanks , hack ) ;
100572: LD_ADDR_VAR 0 4
100576: PUSH
100577: LD_EXP 167
100581: PPUSH
100582: LD_VAR 0 1
100586: PPUSH
100587: CALL 52691 0 2
100591: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
100592: LD_ADDR_VAR 0 3
100596: PUSH
100597: DOUBLE
100598: LD_EXP 168
100602: PUSH
100603: LD_VAR 0 4
100607: ARRAY
100608: INC
100609: ST_TO_ADDR
100610: LD_INT 1
100612: PUSH
100613: FOR_DOWNTO
100614: IFFALSE 100786
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
100616: LD_ADDR_VAR 0 5
100620: PUSH
100621: LD_EXP 168
100625: PUSH
100626: LD_VAR 0 4
100630: ARRAY
100631: PUSH
100632: LD_VAR 0 3
100636: ARRAY
100637: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
100638: LD_VAR 0 5
100642: PUSH
100643: LD_INT 1
100645: ARRAY
100646: PPUSH
100647: CALL_OW 302
100651: NOT
100652: PUSH
100653: LD_VAR 0 5
100657: PUSH
100658: LD_INT 1
100660: ARRAY
100661: PPUSH
100662: CALL_OW 255
100666: PUSH
100667: LD_VAR 0 1
100671: PPUSH
100672: CALL_OW 255
100676: NONEQUAL
100677: OR
100678: IFFALSE 100784
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
100680: LD_VAR 0 5
100684: PUSH
100685: LD_INT 1
100687: ARRAY
100688: PPUSH
100689: CALL_OW 305
100693: PUSH
100694: LD_VAR 0 5
100698: PUSH
100699: LD_INT 1
100701: ARRAY
100702: PPUSH
100703: CALL_OW 255
100707: PUSH
100708: LD_VAR 0 1
100712: PPUSH
100713: CALL_OW 255
100717: EQUAL
100718: AND
100719: IFFALSE 100743
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
100721: LD_VAR 0 5
100725: PUSH
100726: LD_INT 1
100728: ARRAY
100729: PPUSH
100730: LD_VAR 0 5
100734: PUSH
100735: LD_INT 2
100737: ARRAY
100738: PPUSH
100739: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
100743: LD_ADDR_EXP 168
100747: PUSH
100748: LD_EXP 168
100752: PPUSH
100753: LD_VAR 0 4
100757: PPUSH
100758: LD_EXP 168
100762: PUSH
100763: LD_VAR 0 4
100767: ARRAY
100768: PPUSH
100769: LD_VAR 0 3
100773: PPUSH
100774: CALL_OW 3
100778: PPUSH
100779: CALL_OW 1
100783: ST_TO_ADDR
// end ; end ;
100784: GO 100613
100786: POP
100787: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
100788: LD_VAR 0 1
100792: PPUSH
100793: LD_EXP 168
100797: PUSH
100798: LD_VAR 0 4
100802: ARRAY
100803: PUSH
100804: LD_INT 0
100806: PLUS
100807: PPUSH
100808: CALL_OW 505
// end ;
100812: LD_VAR 0 2
100816: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
100817: LD_INT 0
100819: PPUSH
100820: PPUSH
100821: PPUSH
100822: PPUSH
// if not hack in hackTanks then
100823: LD_VAR 0 1
100827: PUSH
100828: LD_EXP 167
100832: IN
100833: NOT
100834: IFFALSE 100838
// exit ;
100836: GO 100923
// index := GetElementIndex ( hackTanks , hack ) ;
100838: LD_ADDR_VAR 0 5
100842: PUSH
100843: LD_EXP 167
100847: PPUSH
100848: LD_VAR 0 1
100852: PPUSH
100853: CALL 52691 0 2
100857: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
100858: LD_ADDR_VAR 0 4
100862: PUSH
100863: DOUBLE
100864: LD_INT 1
100866: DEC
100867: ST_TO_ADDR
100868: LD_EXP 168
100872: PUSH
100873: LD_VAR 0 5
100877: ARRAY
100878: PUSH
100879: FOR_TO
100880: IFFALSE 100921
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
100882: LD_EXP 168
100886: PUSH
100887: LD_VAR 0 5
100891: ARRAY
100892: PUSH
100893: LD_VAR 0 4
100897: ARRAY
100898: PUSH
100899: LD_INT 1
100901: ARRAY
100902: PUSH
100903: LD_VAR 0 2
100907: EQUAL
100908: IFFALSE 100919
// KillUnit ( vehicle ) ;
100910: LD_VAR 0 2
100914: PPUSH
100915: CALL_OW 66
100919: GO 100879
100921: POP
100922: POP
// end ;
100923: LD_VAR 0 3
100927: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
100928: LD_EXP 172
100932: NOT
100933: IFFALSE 100968
100935: GO 100937
100937: DISABLE
// begin initMiner := true ;
100938: LD_ADDR_EXP 172
100942: PUSH
100943: LD_INT 1
100945: ST_TO_ADDR
// minersList := [ ] ;
100946: LD_ADDR_EXP 173
100950: PUSH
100951: EMPTY
100952: ST_TO_ADDR
// minerMinesList := [ ] ;
100953: LD_ADDR_EXP 174
100957: PUSH
100958: EMPTY
100959: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
100960: LD_ADDR_EXP 175
100964: PUSH
100965: LD_INT 5
100967: ST_TO_ADDR
// end ;
100968: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
100969: LD_EXP 172
100973: PUSH
100974: LD_INT 34
100976: PUSH
100977: LD_EXP 100
100981: PUSH
100982: EMPTY
100983: LIST
100984: LIST
100985: PPUSH
100986: CALL_OW 69
100990: AND
100991: IFFALSE 101454
100993: GO 100995
100995: DISABLE
100996: LD_INT 0
100998: PPUSH
100999: PPUSH
101000: PPUSH
101001: PPUSH
// begin enable ;
101002: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
101003: LD_ADDR_VAR 0 1
101007: PUSH
101008: LD_INT 34
101010: PUSH
101011: LD_EXP 100
101015: PUSH
101016: EMPTY
101017: LIST
101018: LIST
101019: PPUSH
101020: CALL_OW 69
101024: PUSH
101025: FOR_IN
101026: IFFALSE 101098
// begin if not i in minersList then
101028: LD_VAR 0 1
101032: PUSH
101033: LD_EXP 173
101037: IN
101038: NOT
101039: IFFALSE 101096
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
101041: LD_ADDR_EXP 173
101045: PUSH
101046: LD_EXP 173
101050: PPUSH
101051: LD_EXP 173
101055: PUSH
101056: LD_INT 1
101058: PLUS
101059: PPUSH
101060: LD_VAR 0 1
101064: PPUSH
101065: CALL_OW 1
101069: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
101070: LD_ADDR_EXP 174
101074: PUSH
101075: LD_EXP 174
101079: PPUSH
101080: LD_EXP 174
101084: PUSH
101085: LD_INT 1
101087: PLUS
101088: PPUSH
101089: EMPTY
101090: PPUSH
101091: CALL_OW 1
101095: ST_TO_ADDR
// end end ;
101096: GO 101025
101098: POP
101099: POP
// for i := minerMinesList downto 1 do
101100: LD_ADDR_VAR 0 1
101104: PUSH
101105: DOUBLE
101106: LD_EXP 174
101110: INC
101111: ST_TO_ADDR
101112: LD_INT 1
101114: PUSH
101115: FOR_DOWNTO
101116: IFFALSE 101452
// begin if IsLive ( minersList [ i ] ) then
101118: LD_EXP 173
101122: PUSH
101123: LD_VAR 0 1
101127: ARRAY
101128: PPUSH
101129: CALL_OW 300
101133: IFFALSE 101161
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
101135: LD_EXP 173
101139: PUSH
101140: LD_VAR 0 1
101144: ARRAY
101145: PPUSH
101146: LD_EXP 174
101150: PUSH
101151: LD_VAR 0 1
101155: ARRAY
101156: PPUSH
101157: CALL_OW 505
// if not minerMinesList [ i ] then
101161: LD_EXP 174
101165: PUSH
101166: LD_VAR 0 1
101170: ARRAY
101171: NOT
101172: IFFALSE 101176
// continue ;
101174: GO 101115
// for j := minerMinesList [ i ] downto 1 do
101176: LD_ADDR_VAR 0 2
101180: PUSH
101181: DOUBLE
101182: LD_EXP 174
101186: PUSH
101187: LD_VAR 0 1
101191: ARRAY
101192: INC
101193: ST_TO_ADDR
101194: LD_INT 1
101196: PUSH
101197: FOR_DOWNTO
101198: IFFALSE 101448
// begin side := GetSide ( minersList [ i ] ) ;
101200: LD_ADDR_VAR 0 3
101204: PUSH
101205: LD_EXP 173
101209: PUSH
101210: LD_VAR 0 1
101214: ARRAY
101215: PPUSH
101216: CALL_OW 255
101220: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
101221: LD_ADDR_VAR 0 4
101225: PUSH
101226: LD_EXP 174
101230: PUSH
101231: LD_VAR 0 1
101235: ARRAY
101236: PUSH
101237: LD_VAR 0 2
101241: ARRAY
101242: PUSH
101243: LD_INT 1
101245: ARRAY
101246: PPUSH
101247: LD_EXP 174
101251: PUSH
101252: LD_VAR 0 1
101256: ARRAY
101257: PUSH
101258: LD_VAR 0 2
101262: ARRAY
101263: PUSH
101264: LD_INT 2
101266: ARRAY
101267: PPUSH
101268: CALL_OW 428
101272: ST_TO_ADDR
// if not tmp then
101273: LD_VAR 0 4
101277: NOT
101278: IFFALSE 101282
// continue ;
101280: GO 101197
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
101282: LD_VAR 0 4
101286: PUSH
101287: LD_INT 81
101289: PUSH
101290: LD_VAR 0 3
101294: PUSH
101295: EMPTY
101296: LIST
101297: LIST
101298: PPUSH
101299: CALL_OW 69
101303: IN
101304: PUSH
101305: LD_EXP 174
101309: PUSH
101310: LD_VAR 0 1
101314: ARRAY
101315: PUSH
101316: LD_VAR 0 2
101320: ARRAY
101321: PUSH
101322: LD_INT 1
101324: ARRAY
101325: PPUSH
101326: LD_EXP 174
101330: PUSH
101331: LD_VAR 0 1
101335: ARRAY
101336: PUSH
101337: LD_VAR 0 2
101341: ARRAY
101342: PUSH
101343: LD_INT 2
101345: ARRAY
101346: PPUSH
101347: CALL_OW 458
101351: AND
101352: IFFALSE 101446
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
101354: LD_EXP 174
101358: PUSH
101359: LD_VAR 0 1
101363: ARRAY
101364: PUSH
101365: LD_VAR 0 2
101369: ARRAY
101370: PUSH
101371: LD_INT 1
101373: ARRAY
101374: PPUSH
101375: LD_EXP 174
101379: PUSH
101380: LD_VAR 0 1
101384: ARRAY
101385: PUSH
101386: LD_VAR 0 2
101390: ARRAY
101391: PUSH
101392: LD_INT 2
101394: ARRAY
101395: PPUSH
101396: LD_VAR 0 3
101400: PPUSH
101401: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
101405: LD_ADDR_EXP 174
101409: PUSH
101410: LD_EXP 174
101414: PPUSH
101415: LD_VAR 0 1
101419: PPUSH
101420: LD_EXP 174
101424: PUSH
101425: LD_VAR 0 1
101429: ARRAY
101430: PPUSH
101431: LD_VAR 0 2
101435: PPUSH
101436: CALL_OW 3
101440: PPUSH
101441: CALL_OW 1
101445: ST_TO_ADDR
// end ; end ;
101446: GO 101197
101448: POP
101449: POP
// end ;
101450: GO 101115
101452: POP
101453: POP
// end ;
101454: PPOPN 4
101456: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
101457: LD_INT 0
101459: PPUSH
101460: PPUSH
// result := false ;
101461: LD_ADDR_VAR 0 4
101465: PUSH
101466: LD_INT 0
101468: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
101469: LD_VAR 0 1
101473: PPUSH
101474: CALL_OW 264
101478: PUSH
101479: LD_EXP 100
101483: EQUAL
101484: NOT
101485: IFFALSE 101489
// exit ;
101487: GO 101729
// index := GetElementIndex ( minersList , unit ) ;
101489: LD_ADDR_VAR 0 5
101493: PUSH
101494: LD_EXP 173
101498: PPUSH
101499: LD_VAR 0 1
101503: PPUSH
101504: CALL 52691 0 2
101508: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
101509: LD_EXP 174
101513: PUSH
101514: LD_VAR 0 5
101518: ARRAY
101519: PUSH
101520: LD_EXP 175
101524: GREATEREQUAL
101525: IFFALSE 101529
// exit ;
101527: GO 101729
// ComMoveXY ( unit , x , y ) ;
101529: LD_VAR 0 1
101533: PPUSH
101534: LD_VAR 0 2
101538: PPUSH
101539: LD_VAR 0 3
101543: PPUSH
101544: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
101548: LD_INT 35
101550: PPUSH
101551: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
101555: LD_VAR 0 1
101559: PPUSH
101560: LD_VAR 0 2
101564: PPUSH
101565: LD_VAR 0 3
101569: PPUSH
101570: CALL 83088 0 3
101574: NOT
101575: PUSH
101576: LD_VAR 0 1
101580: PPUSH
101581: CALL_OW 314
101585: AND
101586: IFFALSE 101590
// exit ;
101588: GO 101729
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
101590: LD_VAR 0 2
101594: PPUSH
101595: LD_VAR 0 3
101599: PPUSH
101600: CALL_OW 428
101604: PUSH
101605: LD_VAR 0 1
101609: EQUAL
101610: PUSH
101611: LD_VAR 0 1
101615: PPUSH
101616: CALL_OW 314
101620: NOT
101621: AND
101622: IFFALSE 101548
// PlaySoundXY ( x , y , PlantMine ) ;
101624: LD_VAR 0 2
101628: PPUSH
101629: LD_VAR 0 3
101633: PPUSH
101634: LD_STRING PlantMine
101636: PPUSH
101637: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
101641: LD_VAR 0 2
101645: PPUSH
101646: LD_VAR 0 3
101650: PPUSH
101651: LD_VAR 0 1
101655: PPUSH
101656: CALL_OW 255
101660: PPUSH
101661: LD_INT 0
101663: PPUSH
101664: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
101668: LD_ADDR_EXP 174
101672: PUSH
101673: LD_EXP 174
101677: PPUSH
101678: LD_VAR 0 5
101682: PUSH
101683: LD_EXP 174
101687: PUSH
101688: LD_VAR 0 5
101692: ARRAY
101693: PUSH
101694: LD_INT 1
101696: PLUS
101697: PUSH
101698: EMPTY
101699: LIST
101700: LIST
101701: PPUSH
101702: LD_VAR 0 2
101706: PUSH
101707: LD_VAR 0 3
101711: PUSH
101712: EMPTY
101713: LIST
101714: LIST
101715: PPUSH
101716: CALL 52906 0 3
101720: ST_TO_ADDR
// result := true ;
101721: LD_ADDR_VAR 0 4
101725: PUSH
101726: LD_INT 1
101728: ST_TO_ADDR
// end ;
101729: LD_VAR 0 4
101733: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
101734: LD_INT 0
101736: PPUSH
101737: PPUSH
101738: PPUSH
// if not unit in minersList then
101739: LD_VAR 0 1
101743: PUSH
101744: LD_EXP 173
101748: IN
101749: NOT
101750: IFFALSE 101754
// exit ;
101752: GO 102146
// index := GetElementIndex ( minersList , unit ) ;
101754: LD_ADDR_VAR 0 6
101758: PUSH
101759: LD_EXP 173
101763: PPUSH
101764: LD_VAR 0 1
101768: PPUSH
101769: CALL 52691 0 2
101773: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
101774: LD_ADDR_VAR 0 5
101778: PUSH
101779: DOUBLE
101780: LD_EXP 174
101784: PUSH
101785: LD_VAR 0 6
101789: ARRAY
101790: INC
101791: ST_TO_ADDR
101792: LD_INT 1
101794: PUSH
101795: FOR_DOWNTO
101796: IFFALSE 101957
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
101798: LD_EXP 174
101802: PUSH
101803: LD_VAR 0 6
101807: ARRAY
101808: PUSH
101809: LD_VAR 0 5
101813: ARRAY
101814: PUSH
101815: LD_INT 1
101817: ARRAY
101818: PUSH
101819: LD_VAR 0 2
101823: EQUAL
101824: PUSH
101825: LD_EXP 174
101829: PUSH
101830: LD_VAR 0 6
101834: ARRAY
101835: PUSH
101836: LD_VAR 0 5
101840: ARRAY
101841: PUSH
101842: LD_INT 2
101844: ARRAY
101845: PUSH
101846: LD_VAR 0 3
101850: EQUAL
101851: AND
101852: IFFALSE 101955
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
101854: LD_EXP 174
101858: PUSH
101859: LD_VAR 0 6
101863: ARRAY
101864: PUSH
101865: LD_VAR 0 5
101869: ARRAY
101870: PUSH
101871: LD_INT 1
101873: ARRAY
101874: PPUSH
101875: LD_EXP 174
101879: PUSH
101880: LD_VAR 0 6
101884: ARRAY
101885: PUSH
101886: LD_VAR 0 5
101890: ARRAY
101891: PUSH
101892: LD_INT 2
101894: ARRAY
101895: PPUSH
101896: LD_VAR 0 1
101900: PPUSH
101901: CALL_OW 255
101905: PPUSH
101906: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
101910: LD_ADDR_EXP 174
101914: PUSH
101915: LD_EXP 174
101919: PPUSH
101920: LD_VAR 0 6
101924: PPUSH
101925: LD_EXP 174
101929: PUSH
101930: LD_VAR 0 6
101934: ARRAY
101935: PPUSH
101936: LD_VAR 0 5
101940: PPUSH
101941: CALL_OW 3
101945: PPUSH
101946: CALL_OW 1
101950: ST_TO_ADDR
// exit ;
101951: POP
101952: POP
101953: GO 102146
// end ; end ;
101955: GO 101795
101957: POP
101958: POP
// for i := minerMinesList [ index ] downto 1 do
101959: LD_ADDR_VAR 0 5
101963: PUSH
101964: DOUBLE
101965: LD_EXP 174
101969: PUSH
101970: LD_VAR 0 6
101974: ARRAY
101975: INC
101976: ST_TO_ADDR
101977: LD_INT 1
101979: PUSH
101980: FOR_DOWNTO
101981: IFFALSE 102144
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
101983: LD_EXP 174
101987: PUSH
101988: LD_VAR 0 6
101992: ARRAY
101993: PUSH
101994: LD_VAR 0 5
101998: ARRAY
101999: PUSH
102000: LD_INT 1
102002: ARRAY
102003: PPUSH
102004: LD_EXP 174
102008: PUSH
102009: LD_VAR 0 6
102013: ARRAY
102014: PUSH
102015: LD_VAR 0 5
102019: ARRAY
102020: PUSH
102021: LD_INT 2
102023: ARRAY
102024: PPUSH
102025: LD_VAR 0 2
102029: PPUSH
102030: LD_VAR 0 3
102034: PPUSH
102035: CALL_OW 298
102039: PUSH
102040: LD_INT 6
102042: LESS
102043: IFFALSE 102142
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
102045: LD_EXP 174
102049: PUSH
102050: LD_VAR 0 6
102054: ARRAY
102055: PUSH
102056: LD_VAR 0 5
102060: ARRAY
102061: PUSH
102062: LD_INT 1
102064: ARRAY
102065: PPUSH
102066: LD_EXP 174
102070: PUSH
102071: LD_VAR 0 6
102075: ARRAY
102076: PUSH
102077: LD_VAR 0 5
102081: ARRAY
102082: PUSH
102083: LD_INT 2
102085: ARRAY
102086: PPUSH
102087: LD_VAR 0 1
102091: PPUSH
102092: CALL_OW 255
102096: PPUSH
102097: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
102101: LD_ADDR_EXP 174
102105: PUSH
102106: LD_EXP 174
102110: PPUSH
102111: LD_VAR 0 6
102115: PPUSH
102116: LD_EXP 174
102120: PUSH
102121: LD_VAR 0 6
102125: ARRAY
102126: PPUSH
102127: LD_VAR 0 5
102131: PPUSH
102132: CALL_OW 3
102136: PPUSH
102137: CALL_OW 1
102141: ST_TO_ADDR
// end ; end ;
102142: GO 101980
102144: POP
102145: POP
// end ;
102146: LD_VAR 0 4
102150: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
102151: LD_INT 0
102153: PPUSH
102154: PPUSH
102155: PPUSH
102156: PPUSH
102157: PPUSH
102158: PPUSH
102159: PPUSH
102160: PPUSH
102161: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
102162: LD_VAR 0 1
102166: PPUSH
102167: CALL_OW 264
102171: PUSH
102172: LD_EXP 100
102176: EQUAL
102177: NOT
102178: PUSH
102179: LD_VAR 0 1
102183: PUSH
102184: LD_EXP 173
102188: IN
102189: NOT
102190: OR
102191: IFFALSE 102195
// exit ;
102193: GO 102517
// index := GetElementIndex ( minersList , unit ) ;
102195: LD_ADDR_VAR 0 6
102199: PUSH
102200: LD_EXP 173
102204: PPUSH
102205: LD_VAR 0 1
102209: PPUSH
102210: CALL 52691 0 2
102214: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
102215: LD_ADDR_VAR 0 8
102219: PUSH
102220: LD_EXP 175
102224: PUSH
102225: LD_EXP 174
102229: PUSH
102230: LD_VAR 0 6
102234: ARRAY
102235: MINUS
102236: ST_TO_ADDR
// if not minesFreeAmount then
102237: LD_VAR 0 8
102241: NOT
102242: IFFALSE 102246
// exit ;
102244: GO 102517
// tmp := [ ] ;
102246: LD_ADDR_VAR 0 7
102250: PUSH
102251: EMPTY
102252: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
102253: LD_ADDR_VAR 0 5
102257: PUSH
102258: DOUBLE
102259: LD_INT 1
102261: DEC
102262: ST_TO_ADDR
102263: LD_VAR 0 8
102267: PUSH
102268: FOR_TO
102269: IFFALSE 102464
// begin _d := rand ( 0 , 5 ) ;
102271: LD_ADDR_VAR 0 11
102275: PUSH
102276: LD_INT 0
102278: PPUSH
102279: LD_INT 5
102281: PPUSH
102282: CALL_OW 12
102286: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
102287: LD_ADDR_VAR 0 12
102291: PUSH
102292: LD_INT 2
102294: PPUSH
102295: LD_INT 6
102297: PPUSH
102298: CALL_OW 12
102302: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
102303: LD_ADDR_VAR 0 9
102307: PUSH
102308: LD_VAR 0 2
102312: PPUSH
102313: LD_VAR 0 11
102317: PPUSH
102318: LD_VAR 0 12
102322: PPUSH
102323: CALL_OW 272
102327: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
102328: LD_ADDR_VAR 0 10
102332: PUSH
102333: LD_VAR 0 3
102337: PPUSH
102338: LD_VAR 0 11
102342: PPUSH
102343: LD_VAR 0 12
102347: PPUSH
102348: CALL_OW 273
102352: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
102353: LD_VAR 0 9
102357: PPUSH
102358: LD_VAR 0 10
102362: PPUSH
102363: CALL_OW 488
102367: PUSH
102368: LD_VAR 0 9
102372: PUSH
102373: LD_VAR 0 10
102377: PUSH
102378: EMPTY
102379: LIST
102380: LIST
102381: PUSH
102382: LD_VAR 0 7
102386: IN
102387: NOT
102388: AND
102389: PUSH
102390: LD_VAR 0 9
102394: PPUSH
102395: LD_VAR 0 10
102399: PPUSH
102400: CALL_OW 458
102404: NOT
102405: AND
102406: IFFALSE 102448
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
102408: LD_ADDR_VAR 0 7
102412: PUSH
102413: LD_VAR 0 7
102417: PPUSH
102418: LD_VAR 0 7
102422: PUSH
102423: LD_INT 1
102425: PLUS
102426: PPUSH
102427: LD_VAR 0 9
102431: PUSH
102432: LD_VAR 0 10
102436: PUSH
102437: EMPTY
102438: LIST
102439: LIST
102440: PPUSH
102441: CALL_OW 1
102445: ST_TO_ADDR
102446: GO 102462
// i := i - 1 ;
102448: LD_ADDR_VAR 0 5
102452: PUSH
102453: LD_VAR 0 5
102457: PUSH
102458: LD_INT 1
102460: MINUS
102461: ST_TO_ADDR
// end ;
102462: GO 102268
102464: POP
102465: POP
// for i in tmp do
102466: LD_ADDR_VAR 0 5
102470: PUSH
102471: LD_VAR 0 7
102475: PUSH
102476: FOR_IN
102477: IFFALSE 102515
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
102479: LD_VAR 0 1
102483: PPUSH
102484: LD_VAR 0 5
102488: PUSH
102489: LD_INT 1
102491: ARRAY
102492: PPUSH
102493: LD_VAR 0 5
102497: PUSH
102498: LD_INT 2
102500: ARRAY
102501: PPUSH
102502: CALL 101457 0 3
102506: NOT
102507: IFFALSE 102513
// exit ;
102509: POP
102510: POP
102511: GO 102517
102513: GO 102476
102515: POP
102516: POP
// end ;
102517: LD_VAR 0 4
102521: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
102522: LD_INT 0
102524: PPUSH
102525: PPUSH
102526: PPUSH
102527: PPUSH
102528: PPUSH
102529: PPUSH
102530: PPUSH
// if not GetClass ( unit ) = class_sniper then
102531: LD_VAR 0 1
102535: PPUSH
102536: CALL_OW 257
102540: PUSH
102541: LD_INT 5
102543: EQUAL
102544: NOT
102545: IFFALSE 102549
// exit ;
102547: GO 102937
// dist := 8 ;
102549: LD_ADDR_VAR 0 5
102553: PUSH
102554: LD_INT 8
102556: ST_TO_ADDR
// viewRange := 12 ;
102557: LD_ADDR_VAR 0 7
102561: PUSH
102562: LD_INT 12
102564: ST_TO_ADDR
// side := GetSide ( unit ) ;
102565: LD_ADDR_VAR 0 6
102569: PUSH
102570: LD_VAR 0 1
102574: PPUSH
102575: CALL_OW 255
102579: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
102580: LD_INT 61
102582: PPUSH
102583: LD_VAR 0 6
102587: PPUSH
102588: CALL_OW 321
102592: PUSH
102593: LD_INT 2
102595: EQUAL
102596: IFFALSE 102606
// viewRange := 16 ;
102598: LD_ADDR_VAR 0 7
102602: PUSH
102603: LD_INT 16
102605: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
102606: LD_VAR 0 1
102610: PPUSH
102611: LD_VAR 0 2
102615: PPUSH
102616: LD_VAR 0 3
102620: PPUSH
102621: CALL_OW 297
102625: PUSH
102626: LD_VAR 0 5
102630: GREATER
102631: IFFALSE 102710
// begin ComMoveXY ( unit , x , y ) ;
102633: LD_VAR 0 1
102637: PPUSH
102638: LD_VAR 0 2
102642: PPUSH
102643: LD_VAR 0 3
102647: PPUSH
102648: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
102652: LD_INT 35
102654: PPUSH
102655: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
102659: LD_VAR 0 1
102663: PPUSH
102664: LD_VAR 0 2
102668: PPUSH
102669: LD_VAR 0 3
102673: PPUSH
102674: CALL 83088 0 3
102678: NOT
102679: IFFALSE 102683
// exit ;
102681: GO 102937
// until GetDistUnitXY ( unit , x , y ) < dist ;
102683: LD_VAR 0 1
102687: PPUSH
102688: LD_VAR 0 2
102692: PPUSH
102693: LD_VAR 0 3
102697: PPUSH
102698: CALL_OW 297
102702: PUSH
102703: LD_VAR 0 5
102707: LESS
102708: IFFALSE 102652
// end ; ComTurnXY ( unit , x , y ) ;
102710: LD_VAR 0 1
102714: PPUSH
102715: LD_VAR 0 2
102719: PPUSH
102720: LD_VAR 0 3
102724: PPUSH
102725: CALL_OW 118
// wait ( 5 ) ;
102729: LD_INT 5
102731: PPUSH
102732: CALL_OW 67
// _d := GetDir ( unit ) ;
102736: LD_ADDR_VAR 0 10
102740: PUSH
102741: LD_VAR 0 1
102745: PPUSH
102746: CALL_OW 254
102750: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
102751: LD_ADDR_VAR 0 8
102755: PUSH
102756: LD_VAR 0 1
102760: PPUSH
102761: CALL_OW 250
102765: PPUSH
102766: LD_VAR 0 10
102770: PPUSH
102771: LD_VAR 0 5
102775: PPUSH
102776: CALL_OW 272
102780: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
102781: LD_ADDR_VAR 0 9
102785: PUSH
102786: LD_VAR 0 1
102790: PPUSH
102791: CALL_OW 251
102795: PPUSH
102796: LD_VAR 0 10
102800: PPUSH
102801: LD_VAR 0 5
102805: PPUSH
102806: CALL_OW 273
102810: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
102811: LD_VAR 0 8
102815: PPUSH
102816: LD_VAR 0 9
102820: PPUSH
102821: CALL_OW 488
102825: NOT
102826: IFFALSE 102830
// exit ;
102828: GO 102937
// ComAnimCustom ( unit , 1 ) ;
102830: LD_VAR 0 1
102834: PPUSH
102835: LD_INT 1
102837: PPUSH
102838: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
102842: LD_VAR 0 8
102846: PPUSH
102847: LD_VAR 0 9
102851: PPUSH
102852: LD_VAR 0 6
102856: PPUSH
102857: LD_VAR 0 7
102861: PPUSH
102862: CALL_OW 330
// repeat wait ( 1 ) ;
102866: LD_INT 1
102868: PPUSH
102869: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
102873: LD_VAR 0 1
102877: PPUSH
102878: CALL_OW 316
102882: PUSH
102883: LD_VAR 0 1
102887: PPUSH
102888: CALL_OW 314
102892: OR
102893: PUSH
102894: LD_VAR 0 1
102898: PPUSH
102899: CALL_OW 302
102903: NOT
102904: OR
102905: PUSH
102906: LD_VAR 0 1
102910: PPUSH
102911: CALL_OW 301
102915: OR
102916: IFFALSE 102866
// RemoveSeeing ( _x , _y , side ) ;
102918: LD_VAR 0 8
102922: PPUSH
102923: LD_VAR 0 9
102927: PPUSH
102928: LD_VAR 0 6
102932: PPUSH
102933: CALL_OW 331
// end ; end_of_file
102937: LD_VAR 0 4
102941: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
102942: LD_INT 0
102944: PPUSH
102945: PPUSH
102946: PPUSH
102947: PPUSH
102948: PPUSH
102949: PPUSH
102950: PPUSH
102951: PPUSH
102952: PPUSH
102953: PPUSH
102954: PPUSH
102955: PPUSH
102956: PPUSH
102957: PPUSH
102958: PPUSH
102959: PPUSH
102960: PPUSH
102961: PPUSH
102962: PPUSH
102963: PPUSH
102964: PPUSH
102965: PPUSH
102966: PPUSH
102967: PPUSH
102968: PPUSH
102969: PPUSH
102970: PPUSH
102971: PPUSH
102972: PPUSH
102973: PPUSH
102974: PPUSH
102975: PPUSH
102976: PPUSH
102977: PPUSH
// if not list then
102978: LD_VAR 0 1
102982: NOT
102983: IFFALSE 102987
// exit ;
102985: GO 107646
// base := list [ 1 ] ;
102987: LD_ADDR_VAR 0 3
102991: PUSH
102992: LD_VAR 0 1
102996: PUSH
102997: LD_INT 1
102999: ARRAY
103000: ST_TO_ADDR
// group := list [ 2 ] ;
103001: LD_ADDR_VAR 0 4
103005: PUSH
103006: LD_VAR 0 1
103010: PUSH
103011: LD_INT 2
103013: ARRAY
103014: ST_TO_ADDR
// path := list [ 3 ] ;
103015: LD_ADDR_VAR 0 5
103019: PUSH
103020: LD_VAR 0 1
103024: PUSH
103025: LD_INT 3
103027: ARRAY
103028: ST_TO_ADDR
// flags := list [ 4 ] ;
103029: LD_ADDR_VAR 0 6
103033: PUSH
103034: LD_VAR 0 1
103038: PUSH
103039: LD_INT 4
103041: ARRAY
103042: ST_TO_ADDR
// mined := [ ] ;
103043: LD_ADDR_VAR 0 27
103047: PUSH
103048: EMPTY
103049: ST_TO_ADDR
// bombed := [ ] ;
103050: LD_ADDR_VAR 0 28
103054: PUSH
103055: EMPTY
103056: ST_TO_ADDR
// healers := [ ] ;
103057: LD_ADDR_VAR 0 31
103061: PUSH
103062: EMPTY
103063: ST_TO_ADDR
// to_heal := [ ] ;
103064: LD_ADDR_VAR 0 30
103068: PUSH
103069: EMPTY
103070: ST_TO_ADDR
// repairs := [ ] ;
103071: LD_ADDR_VAR 0 33
103075: PUSH
103076: EMPTY
103077: ST_TO_ADDR
// to_repair := [ ] ;
103078: LD_ADDR_VAR 0 32
103082: PUSH
103083: EMPTY
103084: ST_TO_ADDR
// if not group or not path then
103085: LD_VAR 0 4
103089: NOT
103090: PUSH
103091: LD_VAR 0 5
103095: NOT
103096: OR
103097: IFFALSE 103101
// exit ;
103099: GO 107646
// side := GetSide ( group [ 1 ] ) ;
103101: LD_ADDR_VAR 0 35
103105: PUSH
103106: LD_VAR 0 4
103110: PUSH
103111: LD_INT 1
103113: ARRAY
103114: PPUSH
103115: CALL_OW 255
103119: ST_TO_ADDR
// if flags then
103120: LD_VAR 0 6
103124: IFFALSE 103268
// begin f_ignore_area := flags [ 1 ] ;
103126: LD_ADDR_VAR 0 17
103130: PUSH
103131: LD_VAR 0 6
103135: PUSH
103136: LD_INT 1
103138: ARRAY
103139: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
103140: LD_ADDR_VAR 0 18
103144: PUSH
103145: LD_VAR 0 6
103149: PUSH
103150: LD_INT 2
103152: ARRAY
103153: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
103154: LD_ADDR_VAR 0 19
103158: PUSH
103159: LD_VAR 0 6
103163: PUSH
103164: LD_INT 3
103166: ARRAY
103167: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
103168: LD_ADDR_VAR 0 20
103172: PUSH
103173: LD_VAR 0 6
103177: PUSH
103178: LD_INT 4
103180: ARRAY
103181: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
103182: LD_ADDR_VAR 0 21
103186: PUSH
103187: LD_VAR 0 6
103191: PUSH
103192: LD_INT 5
103194: ARRAY
103195: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
103196: LD_ADDR_VAR 0 22
103200: PUSH
103201: LD_VAR 0 6
103205: PUSH
103206: LD_INT 6
103208: ARRAY
103209: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
103210: LD_ADDR_VAR 0 23
103214: PUSH
103215: LD_VAR 0 6
103219: PUSH
103220: LD_INT 7
103222: ARRAY
103223: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
103224: LD_ADDR_VAR 0 24
103228: PUSH
103229: LD_VAR 0 6
103233: PUSH
103234: LD_INT 8
103236: ARRAY
103237: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
103238: LD_ADDR_VAR 0 25
103242: PUSH
103243: LD_VAR 0 6
103247: PUSH
103248: LD_INT 9
103250: ARRAY
103251: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
103252: LD_ADDR_VAR 0 26
103256: PUSH
103257: LD_VAR 0 6
103261: PUSH
103262: LD_INT 10
103264: ARRAY
103265: ST_TO_ADDR
// end else
103266: GO 103348
// begin f_ignore_area := false ;
103268: LD_ADDR_VAR 0 17
103272: PUSH
103273: LD_INT 0
103275: ST_TO_ADDR
// f_capture := false ;
103276: LD_ADDR_VAR 0 18
103280: PUSH
103281: LD_INT 0
103283: ST_TO_ADDR
// f_ignore_civ := false ;
103284: LD_ADDR_VAR 0 19
103288: PUSH
103289: LD_INT 0
103291: ST_TO_ADDR
// f_murder := false ;
103292: LD_ADDR_VAR 0 20
103296: PUSH
103297: LD_INT 0
103299: ST_TO_ADDR
// f_mines := false ;
103300: LD_ADDR_VAR 0 21
103304: PUSH
103305: LD_INT 0
103307: ST_TO_ADDR
// f_repair := false ;
103308: LD_ADDR_VAR 0 22
103312: PUSH
103313: LD_INT 0
103315: ST_TO_ADDR
// f_heal := false ;
103316: LD_ADDR_VAR 0 23
103320: PUSH
103321: LD_INT 0
103323: ST_TO_ADDR
// f_spacetime := false ;
103324: LD_ADDR_VAR 0 24
103328: PUSH
103329: LD_INT 0
103331: ST_TO_ADDR
// f_attack_depot := false ;
103332: LD_ADDR_VAR 0 25
103336: PUSH
103337: LD_INT 0
103339: ST_TO_ADDR
// f_crawl := false ;
103340: LD_ADDR_VAR 0 26
103344: PUSH
103345: LD_INT 0
103347: ST_TO_ADDR
// end ; if f_heal then
103348: LD_VAR 0 23
103352: IFFALSE 103379
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
103354: LD_ADDR_VAR 0 31
103358: PUSH
103359: LD_VAR 0 4
103363: PPUSH
103364: LD_INT 25
103366: PUSH
103367: LD_INT 4
103369: PUSH
103370: EMPTY
103371: LIST
103372: LIST
103373: PPUSH
103374: CALL_OW 72
103378: ST_TO_ADDR
// if f_repair then
103379: LD_VAR 0 22
103383: IFFALSE 103410
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
103385: LD_ADDR_VAR 0 33
103389: PUSH
103390: LD_VAR 0 4
103394: PPUSH
103395: LD_INT 25
103397: PUSH
103398: LD_INT 3
103400: PUSH
103401: EMPTY
103402: LIST
103403: LIST
103404: PPUSH
103405: CALL_OW 72
103409: ST_TO_ADDR
// units_path := [ ] ;
103410: LD_ADDR_VAR 0 16
103414: PUSH
103415: EMPTY
103416: ST_TO_ADDR
// for i = 1 to group do
103417: LD_ADDR_VAR 0 7
103421: PUSH
103422: DOUBLE
103423: LD_INT 1
103425: DEC
103426: ST_TO_ADDR
103427: LD_VAR 0 4
103431: PUSH
103432: FOR_TO
103433: IFFALSE 103462
// units_path := Replace ( units_path , i , path ) ;
103435: LD_ADDR_VAR 0 16
103439: PUSH
103440: LD_VAR 0 16
103444: PPUSH
103445: LD_VAR 0 7
103449: PPUSH
103450: LD_VAR 0 5
103454: PPUSH
103455: CALL_OW 1
103459: ST_TO_ADDR
103460: GO 103432
103462: POP
103463: POP
// repeat for i = group downto 1 do
103464: LD_ADDR_VAR 0 7
103468: PUSH
103469: DOUBLE
103470: LD_VAR 0 4
103474: INC
103475: ST_TO_ADDR
103476: LD_INT 1
103478: PUSH
103479: FOR_DOWNTO
103480: IFFALSE 107602
// begin wait ( 5 ) ;
103482: LD_INT 5
103484: PPUSH
103485: CALL_OW 67
// tmp := [ ] ;
103489: LD_ADDR_VAR 0 14
103493: PUSH
103494: EMPTY
103495: ST_TO_ADDR
// attacking := false ;
103496: LD_ADDR_VAR 0 29
103500: PUSH
103501: LD_INT 0
103503: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
103504: LD_VAR 0 4
103508: PUSH
103509: LD_VAR 0 7
103513: ARRAY
103514: PPUSH
103515: CALL_OW 301
103519: PUSH
103520: LD_VAR 0 4
103524: PUSH
103525: LD_VAR 0 7
103529: ARRAY
103530: NOT
103531: OR
103532: IFFALSE 103641
// begin if GetType ( group [ i ] ) = unit_human then
103534: LD_VAR 0 4
103538: PUSH
103539: LD_VAR 0 7
103543: ARRAY
103544: PPUSH
103545: CALL_OW 247
103549: PUSH
103550: LD_INT 1
103552: EQUAL
103553: IFFALSE 103599
// begin to_heal := to_heal diff group [ i ] ;
103555: LD_ADDR_VAR 0 30
103559: PUSH
103560: LD_VAR 0 30
103564: PUSH
103565: LD_VAR 0 4
103569: PUSH
103570: LD_VAR 0 7
103574: ARRAY
103575: DIFF
103576: ST_TO_ADDR
// healers := healers diff group [ i ] ;
103577: LD_ADDR_VAR 0 31
103581: PUSH
103582: LD_VAR 0 31
103586: PUSH
103587: LD_VAR 0 4
103591: PUSH
103592: LD_VAR 0 7
103596: ARRAY
103597: DIFF
103598: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
103599: LD_ADDR_VAR 0 4
103603: PUSH
103604: LD_VAR 0 4
103608: PPUSH
103609: LD_VAR 0 7
103613: PPUSH
103614: CALL_OW 3
103618: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
103619: LD_ADDR_VAR 0 16
103623: PUSH
103624: LD_VAR 0 16
103628: PPUSH
103629: LD_VAR 0 7
103633: PPUSH
103634: CALL_OW 3
103638: ST_TO_ADDR
// continue ;
103639: GO 103479
// end ; if f_repair then
103641: LD_VAR 0 22
103645: IFFALSE 104134
// begin if GetType ( group [ i ] ) = unit_vehicle then
103647: LD_VAR 0 4
103651: PUSH
103652: LD_VAR 0 7
103656: ARRAY
103657: PPUSH
103658: CALL_OW 247
103662: PUSH
103663: LD_INT 2
103665: EQUAL
103666: IFFALSE 103856
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
103668: LD_VAR 0 4
103672: PUSH
103673: LD_VAR 0 7
103677: ARRAY
103678: PPUSH
103679: CALL_OW 256
103683: PUSH
103684: LD_INT 700
103686: LESS
103687: PUSH
103688: LD_VAR 0 4
103692: PUSH
103693: LD_VAR 0 7
103697: ARRAY
103698: PUSH
103699: LD_VAR 0 32
103703: IN
103704: NOT
103705: AND
103706: IFFALSE 103730
// to_repair := to_repair union group [ i ] ;
103708: LD_ADDR_VAR 0 32
103712: PUSH
103713: LD_VAR 0 32
103717: PUSH
103718: LD_VAR 0 4
103722: PUSH
103723: LD_VAR 0 7
103727: ARRAY
103728: UNION
103729: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
103730: LD_VAR 0 4
103734: PUSH
103735: LD_VAR 0 7
103739: ARRAY
103740: PPUSH
103741: CALL_OW 256
103745: PUSH
103746: LD_INT 1000
103748: EQUAL
103749: PUSH
103750: LD_VAR 0 4
103754: PUSH
103755: LD_VAR 0 7
103759: ARRAY
103760: PUSH
103761: LD_VAR 0 32
103765: IN
103766: AND
103767: IFFALSE 103791
// to_repair := to_repair diff group [ i ] ;
103769: LD_ADDR_VAR 0 32
103773: PUSH
103774: LD_VAR 0 32
103778: PUSH
103779: LD_VAR 0 4
103783: PUSH
103784: LD_VAR 0 7
103788: ARRAY
103789: DIFF
103790: ST_TO_ADDR
// if group [ i ] in to_repair then
103791: LD_VAR 0 4
103795: PUSH
103796: LD_VAR 0 7
103800: ARRAY
103801: PUSH
103802: LD_VAR 0 32
103806: IN
103807: IFFALSE 103854
// begin if not IsInArea ( group [ i ] , f_repair ) then
103809: LD_VAR 0 4
103813: PUSH
103814: LD_VAR 0 7
103818: ARRAY
103819: PPUSH
103820: LD_VAR 0 22
103824: PPUSH
103825: CALL_OW 308
103829: NOT
103830: IFFALSE 103852
// ComMoveToArea ( group [ i ] , f_repair ) ;
103832: LD_VAR 0 4
103836: PUSH
103837: LD_VAR 0 7
103841: ARRAY
103842: PPUSH
103843: LD_VAR 0 22
103847: PPUSH
103848: CALL_OW 113
// continue ;
103852: GO 103479
// end ; end else
103854: GO 104134
// if group [ i ] in repairs then
103856: LD_VAR 0 4
103860: PUSH
103861: LD_VAR 0 7
103865: ARRAY
103866: PUSH
103867: LD_VAR 0 33
103871: IN
103872: IFFALSE 104134
// begin if IsInUnit ( group [ i ] ) then
103874: LD_VAR 0 4
103878: PUSH
103879: LD_VAR 0 7
103883: ARRAY
103884: PPUSH
103885: CALL_OW 310
103889: IFFALSE 103957
// begin z := IsInUnit ( group [ i ] ) ;
103891: LD_ADDR_VAR 0 13
103895: PUSH
103896: LD_VAR 0 4
103900: PUSH
103901: LD_VAR 0 7
103905: ARRAY
103906: PPUSH
103907: CALL_OW 310
103911: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
103912: LD_VAR 0 13
103916: PUSH
103917: LD_VAR 0 32
103921: IN
103922: PUSH
103923: LD_VAR 0 13
103927: PPUSH
103928: LD_VAR 0 22
103932: PPUSH
103933: CALL_OW 308
103937: AND
103938: IFFALSE 103955
// ComExitVehicle ( group [ i ] ) ;
103940: LD_VAR 0 4
103944: PUSH
103945: LD_VAR 0 7
103949: ARRAY
103950: PPUSH
103951: CALL_OW 121
// end else
103955: GO 104134
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
103957: LD_ADDR_VAR 0 13
103961: PUSH
103962: LD_VAR 0 4
103966: PPUSH
103967: LD_INT 95
103969: PUSH
103970: LD_VAR 0 22
103974: PUSH
103975: EMPTY
103976: LIST
103977: LIST
103978: PUSH
103979: LD_INT 58
103981: PUSH
103982: EMPTY
103983: LIST
103984: PUSH
103985: EMPTY
103986: LIST
103987: LIST
103988: PPUSH
103989: CALL_OW 72
103993: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
103994: LD_VAR 0 4
103998: PUSH
103999: LD_VAR 0 7
104003: ARRAY
104004: PPUSH
104005: CALL_OW 314
104009: NOT
104010: IFFALSE 104132
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
104012: LD_ADDR_VAR 0 10
104016: PUSH
104017: LD_VAR 0 13
104021: PPUSH
104022: LD_VAR 0 4
104026: PUSH
104027: LD_VAR 0 7
104031: ARRAY
104032: PPUSH
104033: CALL_OW 74
104037: ST_TO_ADDR
// if not x then
104038: LD_VAR 0 10
104042: NOT
104043: IFFALSE 104047
// continue ;
104045: GO 103479
// if GetLives ( x ) < 1000 then
104047: LD_VAR 0 10
104051: PPUSH
104052: CALL_OW 256
104056: PUSH
104057: LD_INT 1000
104059: LESS
104060: IFFALSE 104084
// ComRepairVehicle ( group [ i ] , x ) else
104062: LD_VAR 0 4
104066: PUSH
104067: LD_VAR 0 7
104071: ARRAY
104072: PPUSH
104073: LD_VAR 0 10
104077: PPUSH
104078: CALL_OW 129
104082: GO 104132
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
104084: LD_VAR 0 23
104088: PUSH
104089: LD_VAR 0 4
104093: PUSH
104094: LD_VAR 0 7
104098: ARRAY
104099: PPUSH
104100: CALL_OW 256
104104: PUSH
104105: LD_INT 1000
104107: LESS
104108: AND
104109: NOT
104110: IFFALSE 104132
// ComEnterUnit ( group [ i ] , x ) ;
104112: LD_VAR 0 4
104116: PUSH
104117: LD_VAR 0 7
104121: ARRAY
104122: PPUSH
104123: LD_VAR 0 10
104127: PPUSH
104128: CALL_OW 120
// end ; continue ;
104132: GO 103479
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
104134: LD_VAR 0 23
104138: PUSH
104139: LD_VAR 0 4
104143: PUSH
104144: LD_VAR 0 7
104148: ARRAY
104149: PPUSH
104150: CALL_OW 247
104154: PUSH
104155: LD_INT 1
104157: EQUAL
104158: AND
104159: IFFALSE 104637
// begin if group [ i ] in healers then
104161: LD_VAR 0 4
104165: PUSH
104166: LD_VAR 0 7
104170: ARRAY
104171: PUSH
104172: LD_VAR 0 31
104176: IN
104177: IFFALSE 104450
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
104179: LD_VAR 0 4
104183: PUSH
104184: LD_VAR 0 7
104188: ARRAY
104189: PPUSH
104190: LD_VAR 0 23
104194: PPUSH
104195: CALL_OW 308
104199: NOT
104200: PUSH
104201: LD_VAR 0 4
104205: PUSH
104206: LD_VAR 0 7
104210: ARRAY
104211: PPUSH
104212: CALL_OW 314
104216: NOT
104217: AND
104218: IFFALSE 104242
// ComMoveToArea ( group [ i ] , f_heal ) else
104220: LD_VAR 0 4
104224: PUSH
104225: LD_VAR 0 7
104229: ARRAY
104230: PPUSH
104231: LD_VAR 0 23
104235: PPUSH
104236: CALL_OW 113
104240: GO 104448
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
104242: LD_VAR 0 4
104246: PUSH
104247: LD_VAR 0 7
104251: ARRAY
104252: PPUSH
104253: CALL 81611 0 1
104257: PPUSH
104258: CALL_OW 256
104262: PUSH
104263: LD_INT 1000
104265: EQUAL
104266: IFFALSE 104285
// ComStop ( group [ i ] ) else
104268: LD_VAR 0 4
104272: PUSH
104273: LD_VAR 0 7
104277: ARRAY
104278: PPUSH
104279: CALL_OW 141
104283: GO 104448
// if not HasTask ( group [ i ] ) and to_heal then
104285: LD_VAR 0 4
104289: PUSH
104290: LD_VAR 0 7
104294: ARRAY
104295: PPUSH
104296: CALL_OW 314
104300: NOT
104301: PUSH
104302: LD_VAR 0 30
104306: AND
104307: IFFALSE 104448
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
104309: LD_ADDR_VAR 0 13
104313: PUSH
104314: LD_VAR 0 30
104318: PPUSH
104319: LD_INT 3
104321: PUSH
104322: LD_INT 54
104324: PUSH
104325: EMPTY
104326: LIST
104327: PUSH
104328: EMPTY
104329: LIST
104330: LIST
104331: PPUSH
104332: CALL_OW 72
104336: PPUSH
104337: LD_VAR 0 4
104341: PUSH
104342: LD_VAR 0 7
104346: ARRAY
104347: PPUSH
104348: CALL_OW 74
104352: ST_TO_ADDR
// if z then
104353: LD_VAR 0 13
104357: IFFALSE 104448
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
104359: LD_INT 91
104361: PUSH
104362: LD_VAR 0 13
104366: PUSH
104367: LD_INT 10
104369: PUSH
104370: EMPTY
104371: LIST
104372: LIST
104373: LIST
104374: PUSH
104375: LD_INT 81
104377: PUSH
104378: LD_VAR 0 13
104382: PPUSH
104383: CALL_OW 255
104387: PUSH
104388: EMPTY
104389: LIST
104390: LIST
104391: PUSH
104392: EMPTY
104393: LIST
104394: LIST
104395: PPUSH
104396: CALL_OW 69
104400: PUSH
104401: LD_INT 0
104403: EQUAL
104404: IFFALSE 104428
// ComHeal ( group [ i ] , z ) else
104406: LD_VAR 0 4
104410: PUSH
104411: LD_VAR 0 7
104415: ARRAY
104416: PPUSH
104417: LD_VAR 0 13
104421: PPUSH
104422: CALL_OW 128
104426: GO 104448
// ComMoveToArea ( group [ i ] , f_heal ) ;
104428: LD_VAR 0 4
104432: PUSH
104433: LD_VAR 0 7
104437: ARRAY
104438: PPUSH
104439: LD_VAR 0 23
104443: PPUSH
104444: CALL_OW 113
// end ; continue ;
104448: GO 103479
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
104450: LD_VAR 0 4
104454: PUSH
104455: LD_VAR 0 7
104459: ARRAY
104460: PPUSH
104461: CALL_OW 256
104465: PUSH
104466: LD_INT 700
104468: LESS
104469: PUSH
104470: LD_VAR 0 4
104474: PUSH
104475: LD_VAR 0 7
104479: ARRAY
104480: PUSH
104481: LD_VAR 0 30
104485: IN
104486: NOT
104487: AND
104488: IFFALSE 104512
// to_heal := to_heal union group [ i ] ;
104490: LD_ADDR_VAR 0 30
104494: PUSH
104495: LD_VAR 0 30
104499: PUSH
104500: LD_VAR 0 4
104504: PUSH
104505: LD_VAR 0 7
104509: ARRAY
104510: UNION
104511: ST_TO_ADDR
// if group [ i ] in to_heal then
104512: LD_VAR 0 4
104516: PUSH
104517: LD_VAR 0 7
104521: ARRAY
104522: PUSH
104523: LD_VAR 0 30
104527: IN
104528: IFFALSE 104637
// begin if GetLives ( group [ i ] ) = 1000 then
104530: LD_VAR 0 4
104534: PUSH
104535: LD_VAR 0 7
104539: ARRAY
104540: PPUSH
104541: CALL_OW 256
104545: PUSH
104546: LD_INT 1000
104548: EQUAL
104549: IFFALSE 104575
// to_heal := to_heal diff group [ i ] else
104551: LD_ADDR_VAR 0 30
104555: PUSH
104556: LD_VAR 0 30
104560: PUSH
104561: LD_VAR 0 4
104565: PUSH
104566: LD_VAR 0 7
104570: ARRAY
104571: DIFF
104572: ST_TO_ADDR
104573: GO 104637
// begin if not IsInArea ( group [ i ] , to_heal ) then
104575: LD_VAR 0 4
104579: PUSH
104580: LD_VAR 0 7
104584: ARRAY
104585: PPUSH
104586: LD_VAR 0 30
104590: PPUSH
104591: CALL_OW 308
104595: NOT
104596: IFFALSE 104620
// ComMoveToArea ( group [ i ] , f_heal ) else
104598: LD_VAR 0 4
104602: PUSH
104603: LD_VAR 0 7
104607: ARRAY
104608: PPUSH
104609: LD_VAR 0 23
104613: PPUSH
104614: CALL_OW 113
104618: GO 104635
// ComHold ( group [ i ] ) ;
104620: LD_VAR 0 4
104624: PUSH
104625: LD_VAR 0 7
104629: ARRAY
104630: PPUSH
104631: CALL_OW 140
// continue ;
104635: GO 103479
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
104637: LD_VAR 0 4
104641: PUSH
104642: LD_VAR 0 7
104646: ARRAY
104647: PPUSH
104648: LD_INT 10
104650: PPUSH
104651: CALL 80031 0 2
104655: NOT
104656: PUSH
104657: LD_VAR 0 16
104661: PUSH
104662: LD_VAR 0 7
104666: ARRAY
104667: PUSH
104668: EMPTY
104669: EQUAL
104670: NOT
104671: AND
104672: IFFALSE 104938
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
104674: LD_VAR 0 4
104678: PUSH
104679: LD_VAR 0 7
104683: ARRAY
104684: PPUSH
104685: CALL_OW 262
104689: PUSH
104690: LD_INT 1
104692: PUSH
104693: LD_INT 2
104695: PUSH
104696: EMPTY
104697: LIST
104698: LIST
104699: IN
104700: IFFALSE 104741
// if GetFuel ( group [ i ] ) < 10 then
104702: LD_VAR 0 4
104706: PUSH
104707: LD_VAR 0 7
104711: ARRAY
104712: PPUSH
104713: CALL_OW 261
104717: PUSH
104718: LD_INT 10
104720: LESS
104721: IFFALSE 104741
// SetFuel ( group [ i ] , 12 ) ;
104723: LD_VAR 0 4
104727: PUSH
104728: LD_VAR 0 7
104732: ARRAY
104733: PPUSH
104734: LD_INT 12
104736: PPUSH
104737: CALL_OW 240
// if units_path [ i ] then
104741: LD_VAR 0 16
104745: PUSH
104746: LD_VAR 0 7
104750: ARRAY
104751: IFFALSE 104936
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
104753: LD_VAR 0 4
104757: PUSH
104758: LD_VAR 0 7
104762: ARRAY
104763: PPUSH
104764: LD_VAR 0 16
104768: PUSH
104769: LD_VAR 0 7
104773: ARRAY
104774: PUSH
104775: LD_INT 1
104777: ARRAY
104778: PUSH
104779: LD_INT 1
104781: ARRAY
104782: PPUSH
104783: LD_VAR 0 16
104787: PUSH
104788: LD_VAR 0 7
104792: ARRAY
104793: PUSH
104794: LD_INT 1
104796: ARRAY
104797: PUSH
104798: LD_INT 2
104800: ARRAY
104801: PPUSH
104802: CALL_OW 297
104806: PUSH
104807: LD_INT 6
104809: GREATER
104810: IFFALSE 104885
// begin if not HasTask ( group [ i ] ) then
104812: LD_VAR 0 4
104816: PUSH
104817: LD_VAR 0 7
104821: ARRAY
104822: PPUSH
104823: CALL_OW 314
104827: NOT
104828: IFFALSE 104883
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
104830: LD_VAR 0 4
104834: PUSH
104835: LD_VAR 0 7
104839: ARRAY
104840: PPUSH
104841: LD_VAR 0 16
104845: PUSH
104846: LD_VAR 0 7
104850: ARRAY
104851: PUSH
104852: LD_INT 1
104854: ARRAY
104855: PUSH
104856: LD_INT 1
104858: ARRAY
104859: PPUSH
104860: LD_VAR 0 16
104864: PUSH
104865: LD_VAR 0 7
104869: ARRAY
104870: PUSH
104871: LD_INT 1
104873: ARRAY
104874: PUSH
104875: LD_INT 2
104877: ARRAY
104878: PPUSH
104879: CALL_OW 114
// end else
104883: GO 104936
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
104885: LD_ADDR_VAR 0 15
104889: PUSH
104890: LD_VAR 0 16
104894: PUSH
104895: LD_VAR 0 7
104899: ARRAY
104900: PPUSH
104901: LD_INT 1
104903: PPUSH
104904: CALL_OW 3
104908: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
104909: LD_ADDR_VAR 0 16
104913: PUSH
104914: LD_VAR 0 16
104918: PPUSH
104919: LD_VAR 0 7
104923: PPUSH
104924: LD_VAR 0 15
104928: PPUSH
104929: CALL_OW 1
104933: ST_TO_ADDR
// continue ;
104934: GO 103479
// end ; end ; end else
104936: GO 107600
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
104938: LD_ADDR_VAR 0 14
104942: PUSH
104943: LD_INT 81
104945: PUSH
104946: LD_VAR 0 4
104950: PUSH
104951: LD_VAR 0 7
104955: ARRAY
104956: PPUSH
104957: CALL_OW 255
104961: PUSH
104962: EMPTY
104963: LIST
104964: LIST
104965: PPUSH
104966: CALL_OW 69
104970: ST_TO_ADDR
// if not tmp then
104971: LD_VAR 0 14
104975: NOT
104976: IFFALSE 104980
// continue ;
104978: GO 103479
// if f_ignore_area then
104980: LD_VAR 0 17
104984: IFFALSE 105072
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
104986: LD_ADDR_VAR 0 15
104990: PUSH
104991: LD_VAR 0 14
104995: PPUSH
104996: LD_INT 3
104998: PUSH
104999: LD_INT 92
105001: PUSH
105002: LD_VAR 0 17
105006: PUSH
105007: LD_INT 1
105009: ARRAY
105010: PUSH
105011: LD_VAR 0 17
105015: PUSH
105016: LD_INT 2
105018: ARRAY
105019: PUSH
105020: LD_VAR 0 17
105024: PUSH
105025: LD_INT 3
105027: ARRAY
105028: PUSH
105029: EMPTY
105030: LIST
105031: LIST
105032: LIST
105033: LIST
105034: PUSH
105035: EMPTY
105036: LIST
105037: LIST
105038: PPUSH
105039: CALL_OW 72
105043: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
105044: LD_VAR 0 14
105048: PUSH
105049: LD_VAR 0 15
105053: DIFF
105054: IFFALSE 105072
// tmp := tmp diff tmp2 ;
105056: LD_ADDR_VAR 0 14
105060: PUSH
105061: LD_VAR 0 14
105065: PUSH
105066: LD_VAR 0 15
105070: DIFF
105071: ST_TO_ADDR
// end ; if not f_murder then
105072: LD_VAR 0 20
105076: NOT
105077: IFFALSE 105135
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
105079: LD_ADDR_VAR 0 15
105083: PUSH
105084: LD_VAR 0 14
105088: PPUSH
105089: LD_INT 3
105091: PUSH
105092: LD_INT 50
105094: PUSH
105095: EMPTY
105096: LIST
105097: PUSH
105098: EMPTY
105099: LIST
105100: LIST
105101: PPUSH
105102: CALL_OW 72
105106: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
105107: LD_VAR 0 14
105111: PUSH
105112: LD_VAR 0 15
105116: DIFF
105117: IFFALSE 105135
// tmp := tmp diff tmp2 ;
105119: LD_ADDR_VAR 0 14
105123: PUSH
105124: LD_VAR 0 14
105128: PUSH
105129: LD_VAR 0 15
105133: DIFF
105134: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
105135: LD_ADDR_VAR 0 14
105139: PUSH
105140: LD_VAR 0 4
105144: PUSH
105145: LD_VAR 0 7
105149: ARRAY
105150: PPUSH
105151: LD_VAR 0 14
105155: PPUSH
105156: LD_INT 1
105158: PPUSH
105159: LD_INT 1
105161: PPUSH
105162: CALL 53341 0 4
105166: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
105167: LD_VAR 0 4
105171: PUSH
105172: LD_VAR 0 7
105176: ARRAY
105177: PPUSH
105178: CALL_OW 257
105182: PUSH
105183: LD_INT 1
105185: EQUAL
105186: IFFALSE 105634
// begin if WantPlant ( group [ i ] ) then
105188: LD_VAR 0 4
105192: PUSH
105193: LD_VAR 0 7
105197: ARRAY
105198: PPUSH
105199: CALL 52842 0 1
105203: IFFALSE 105207
// continue ;
105205: GO 103479
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
105207: LD_VAR 0 18
105211: PUSH
105212: LD_VAR 0 4
105216: PUSH
105217: LD_VAR 0 7
105221: ARRAY
105222: PPUSH
105223: CALL_OW 310
105227: NOT
105228: AND
105229: PUSH
105230: LD_VAR 0 14
105234: PUSH
105235: LD_INT 1
105237: ARRAY
105238: PUSH
105239: LD_VAR 0 14
105243: PPUSH
105244: LD_INT 21
105246: PUSH
105247: LD_INT 2
105249: PUSH
105250: EMPTY
105251: LIST
105252: LIST
105253: PUSH
105254: LD_INT 58
105256: PUSH
105257: EMPTY
105258: LIST
105259: PUSH
105260: EMPTY
105261: LIST
105262: LIST
105263: PPUSH
105264: CALL_OW 72
105268: IN
105269: AND
105270: IFFALSE 105306
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
105272: LD_VAR 0 4
105276: PUSH
105277: LD_VAR 0 7
105281: ARRAY
105282: PPUSH
105283: LD_VAR 0 14
105287: PUSH
105288: LD_INT 1
105290: ARRAY
105291: PPUSH
105292: CALL_OW 120
// attacking := true ;
105296: LD_ADDR_VAR 0 29
105300: PUSH
105301: LD_INT 1
105303: ST_TO_ADDR
// continue ;
105304: GO 103479
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
105306: LD_VAR 0 26
105310: PUSH
105311: LD_VAR 0 4
105315: PUSH
105316: LD_VAR 0 7
105320: ARRAY
105321: PPUSH
105322: CALL_OW 257
105326: PUSH
105327: LD_INT 1
105329: EQUAL
105330: AND
105331: PUSH
105332: LD_VAR 0 4
105336: PUSH
105337: LD_VAR 0 7
105341: ARRAY
105342: PPUSH
105343: CALL_OW 256
105347: PUSH
105348: LD_INT 800
105350: LESS
105351: AND
105352: PUSH
105353: LD_VAR 0 4
105357: PUSH
105358: LD_VAR 0 7
105362: ARRAY
105363: PPUSH
105364: CALL_OW 318
105368: NOT
105369: AND
105370: IFFALSE 105387
// ComCrawl ( group [ i ] ) ;
105372: LD_VAR 0 4
105376: PUSH
105377: LD_VAR 0 7
105381: ARRAY
105382: PPUSH
105383: CALL_OW 137
// if f_mines then
105387: LD_VAR 0 21
105391: IFFALSE 105634
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
105393: LD_VAR 0 14
105397: PUSH
105398: LD_INT 1
105400: ARRAY
105401: PPUSH
105402: CALL_OW 247
105406: PUSH
105407: LD_INT 3
105409: EQUAL
105410: PUSH
105411: LD_VAR 0 14
105415: PUSH
105416: LD_INT 1
105418: ARRAY
105419: PUSH
105420: LD_VAR 0 27
105424: IN
105425: NOT
105426: AND
105427: IFFALSE 105634
// begin x := GetX ( tmp [ 1 ] ) ;
105429: LD_ADDR_VAR 0 10
105433: PUSH
105434: LD_VAR 0 14
105438: PUSH
105439: LD_INT 1
105441: ARRAY
105442: PPUSH
105443: CALL_OW 250
105447: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
105448: LD_ADDR_VAR 0 11
105452: PUSH
105453: LD_VAR 0 14
105457: PUSH
105458: LD_INT 1
105460: ARRAY
105461: PPUSH
105462: CALL_OW 251
105466: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
105467: LD_ADDR_VAR 0 12
105471: PUSH
105472: LD_VAR 0 4
105476: PUSH
105477: LD_VAR 0 7
105481: ARRAY
105482: PPUSH
105483: CALL 80116 0 1
105487: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
105488: LD_VAR 0 4
105492: PUSH
105493: LD_VAR 0 7
105497: ARRAY
105498: PPUSH
105499: LD_VAR 0 10
105503: PPUSH
105504: LD_VAR 0 11
105508: PPUSH
105509: LD_VAR 0 14
105513: PUSH
105514: LD_INT 1
105516: ARRAY
105517: PPUSH
105518: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
105522: LD_VAR 0 4
105526: PUSH
105527: LD_VAR 0 7
105531: ARRAY
105532: PPUSH
105533: LD_VAR 0 10
105537: PPUSH
105538: LD_VAR 0 12
105542: PPUSH
105543: LD_INT 7
105545: PPUSH
105546: CALL_OW 272
105550: PPUSH
105551: LD_VAR 0 11
105555: PPUSH
105556: LD_VAR 0 12
105560: PPUSH
105561: LD_INT 7
105563: PPUSH
105564: CALL_OW 273
105568: PPUSH
105569: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
105573: LD_VAR 0 4
105577: PUSH
105578: LD_VAR 0 7
105582: ARRAY
105583: PPUSH
105584: LD_INT 71
105586: PPUSH
105587: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
105591: LD_ADDR_VAR 0 27
105595: PUSH
105596: LD_VAR 0 27
105600: PPUSH
105601: LD_VAR 0 27
105605: PUSH
105606: LD_INT 1
105608: PLUS
105609: PPUSH
105610: LD_VAR 0 14
105614: PUSH
105615: LD_INT 1
105617: ARRAY
105618: PPUSH
105619: CALL_OW 1
105623: ST_TO_ADDR
// attacking := true ;
105624: LD_ADDR_VAR 0 29
105628: PUSH
105629: LD_INT 1
105631: ST_TO_ADDR
// continue ;
105632: GO 103479
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
105634: LD_VAR 0 4
105638: PUSH
105639: LD_VAR 0 7
105643: ARRAY
105644: PPUSH
105645: CALL_OW 257
105649: PUSH
105650: LD_INT 17
105652: EQUAL
105653: PUSH
105654: LD_VAR 0 4
105658: PUSH
105659: LD_VAR 0 7
105663: ARRAY
105664: PPUSH
105665: CALL_OW 110
105669: PUSH
105670: LD_INT 71
105672: EQUAL
105673: NOT
105674: AND
105675: IFFALSE 105821
// begin attacking := false ;
105677: LD_ADDR_VAR 0 29
105681: PUSH
105682: LD_INT 0
105684: ST_TO_ADDR
// k := 5 ;
105685: LD_ADDR_VAR 0 9
105689: PUSH
105690: LD_INT 5
105692: ST_TO_ADDR
// if tmp < k then
105693: LD_VAR 0 14
105697: PUSH
105698: LD_VAR 0 9
105702: LESS
105703: IFFALSE 105715
// k := tmp ;
105705: LD_ADDR_VAR 0 9
105709: PUSH
105710: LD_VAR 0 14
105714: ST_TO_ADDR
// for j = 1 to k do
105715: LD_ADDR_VAR 0 8
105719: PUSH
105720: DOUBLE
105721: LD_INT 1
105723: DEC
105724: ST_TO_ADDR
105725: LD_VAR 0 9
105729: PUSH
105730: FOR_TO
105731: IFFALSE 105819
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
105733: LD_VAR 0 14
105737: PUSH
105738: LD_VAR 0 8
105742: ARRAY
105743: PUSH
105744: LD_VAR 0 14
105748: PPUSH
105749: LD_INT 58
105751: PUSH
105752: EMPTY
105753: LIST
105754: PPUSH
105755: CALL_OW 72
105759: IN
105760: NOT
105761: IFFALSE 105817
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105763: LD_VAR 0 4
105767: PUSH
105768: LD_VAR 0 7
105772: ARRAY
105773: PPUSH
105774: LD_VAR 0 14
105778: PUSH
105779: LD_VAR 0 8
105783: ARRAY
105784: PPUSH
105785: CALL_OW 115
// attacking := true ;
105789: LD_ADDR_VAR 0 29
105793: PUSH
105794: LD_INT 1
105796: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
105797: LD_VAR 0 4
105801: PUSH
105802: LD_VAR 0 7
105806: ARRAY
105807: PPUSH
105808: LD_INT 71
105810: PPUSH
105811: CALL_OW 109
// continue ;
105815: GO 105730
// end ; end ;
105817: GO 105730
105819: POP
105820: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
105821: LD_VAR 0 4
105825: PUSH
105826: LD_VAR 0 7
105830: ARRAY
105831: PPUSH
105832: CALL_OW 257
105836: PUSH
105837: LD_INT 8
105839: EQUAL
105840: PUSH
105841: LD_VAR 0 4
105845: PUSH
105846: LD_VAR 0 7
105850: ARRAY
105851: PPUSH
105852: CALL_OW 264
105856: PUSH
105857: LD_INT 28
105859: PUSH
105860: LD_INT 45
105862: PUSH
105863: LD_INT 7
105865: PUSH
105866: LD_INT 47
105868: PUSH
105869: EMPTY
105870: LIST
105871: LIST
105872: LIST
105873: LIST
105874: IN
105875: OR
105876: IFFALSE 106132
// begin attacking := false ;
105878: LD_ADDR_VAR 0 29
105882: PUSH
105883: LD_INT 0
105885: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
105886: LD_VAR 0 14
105890: PUSH
105891: LD_INT 1
105893: ARRAY
105894: PPUSH
105895: CALL_OW 266
105899: PUSH
105900: LD_INT 32
105902: PUSH
105903: LD_INT 31
105905: PUSH
105906: LD_INT 33
105908: PUSH
105909: LD_INT 4
105911: PUSH
105912: LD_INT 5
105914: PUSH
105915: EMPTY
105916: LIST
105917: LIST
105918: LIST
105919: LIST
105920: LIST
105921: IN
105922: IFFALSE 106108
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
105924: LD_ADDR_VAR 0 9
105928: PUSH
105929: LD_VAR 0 14
105933: PUSH
105934: LD_INT 1
105936: ARRAY
105937: PPUSH
105938: CALL_OW 266
105942: PPUSH
105943: LD_VAR 0 14
105947: PUSH
105948: LD_INT 1
105950: ARRAY
105951: PPUSH
105952: CALL_OW 250
105956: PPUSH
105957: LD_VAR 0 14
105961: PUSH
105962: LD_INT 1
105964: ARRAY
105965: PPUSH
105966: CALL_OW 251
105970: PPUSH
105971: LD_VAR 0 14
105975: PUSH
105976: LD_INT 1
105978: ARRAY
105979: PPUSH
105980: CALL_OW 254
105984: PPUSH
105985: LD_VAR 0 14
105989: PUSH
105990: LD_INT 1
105992: ARRAY
105993: PPUSH
105994: CALL_OW 248
105998: PPUSH
105999: LD_INT 0
106001: PPUSH
106002: CALL 61486 0 6
106006: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
106007: LD_ADDR_VAR 0 8
106011: PUSH
106012: LD_VAR 0 4
106016: PUSH
106017: LD_VAR 0 7
106021: ARRAY
106022: PPUSH
106023: LD_VAR 0 9
106027: PPUSH
106028: CALL 80156 0 2
106032: ST_TO_ADDR
// if j then
106033: LD_VAR 0 8
106037: IFFALSE 106106
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
106039: LD_VAR 0 8
106043: PUSH
106044: LD_INT 1
106046: ARRAY
106047: PPUSH
106048: LD_VAR 0 8
106052: PUSH
106053: LD_INT 2
106055: ARRAY
106056: PPUSH
106057: CALL_OW 488
106061: IFFALSE 106106
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
106063: LD_VAR 0 4
106067: PUSH
106068: LD_VAR 0 7
106072: ARRAY
106073: PPUSH
106074: LD_VAR 0 8
106078: PUSH
106079: LD_INT 1
106081: ARRAY
106082: PPUSH
106083: LD_VAR 0 8
106087: PUSH
106088: LD_INT 2
106090: ARRAY
106091: PPUSH
106092: CALL_OW 116
// attacking := true ;
106096: LD_ADDR_VAR 0 29
106100: PUSH
106101: LD_INT 1
106103: ST_TO_ADDR
// continue ;
106104: GO 103479
// end ; end else
106106: GO 106132
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106108: LD_VAR 0 4
106112: PUSH
106113: LD_VAR 0 7
106117: ARRAY
106118: PPUSH
106119: LD_VAR 0 14
106123: PUSH
106124: LD_INT 1
106126: ARRAY
106127: PPUSH
106128: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
106132: LD_VAR 0 4
106136: PUSH
106137: LD_VAR 0 7
106141: ARRAY
106142: PPUSH
106143: CALL_OW 265
106147: PUSH
106148: LD_INT 11
106150: EQUAL
106151: IFFALSE 106429
// begin k := 10 ;
106153: LD_ADDR_VAR 0 9
106157: PUSH
106158: LD_INT 10
106160: ST_TO_ADDR
// x := 0 ;
106161: LD_ADDR_VAR 0 10
106165: PUSH
106166: LD_INT 0
106168: ST_TO_ADDR
// if tmp < k then
106169: LD_VAR 0 14
106173: PUSH
106174: LD_VAR 0 9
106178: LESS
106179: IFFALSE 106191
// k := tmp ;
106181: LD_ADDR_VAR 0 9
106185: PUSH
106186: LD_VAR 0 14
106190: ST_TO_ADDR
// for j = k downto 1 do
106191: LD_ADDR_VAR 0 8
106195: PUSH
106196: DOUBLE
106197: LD_VAR 0 9
106201: INC
106202: ST_TO_ADDR
106203: LD_INT 1
106205: PUSH
106206: FOR_DOWNTO
106207: IFFALSE 106282
// begin if GetType ( tmp [ j ] ) = unit_human then
106209: LD_VAR 0 14
106213: PUSH
106214: LD_VAR 0 8
106218: ARRAY
106219: PPUSH
106220: CALL_OW 247
106224: PUSH
106225: LD_INT 1
106227: EQUAL
106228: IFFALSE 106280
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
106230: LD_VAR 0 4
106234: PUSH
106235: LD_VAR 0 7
106239: ARRAY
106240: PPUSH
106241: LD_VAR 0 14
106245: PUSH
106246: LD_VAR 0 8
106250: ARRAY
106251: PPUSH
106252: CALL 80427 0 2
// x := tmp [ j ] ;
106256: LD_ADDR_VAR 0 10
106260: PUSH
106261: LD_VAR 0 14
106265: PUSH
106266: LD_VAR 0 8
106270: ARRAY
106271: ST_TO_ADDR
// attacking := true ;
106272: LD_ADDR_VAR 0 29
106276: PUSH
106277: LD_INT 1
106279: ST_TO_ADDR
// end ; end ;
106280: GO 106206
106282: POP
106283: POP
// if not x then
106284: LD_VAR 0 10
106288: NOT
106289: IFFALSE 106429
// begin attacking := true ;
106291: LD_ADDR_VAR 0 29
106295: PUSH
106296: LD_INT 1
106298: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
106299: LD_VAR 0 4
106303: PUSH
106304: LD_VAR 0 7
106308: ARRAY
106309: PPUSH
106310: CALL_OW 250
106314: PPUSH
106315: LD_VAR 0 4
106319: PUSH
106320: LD_VAR 0 7
106324: ARRAY
106325: PPUSH
106326: CALL_OW 251
106330: PPUSH
106331: CALL_OW 546
106335: PUSH
106336: LD_INT 2
106338: ARRAY
106339: PUSH
106340: LD_VAR 0 14
106344: PUSH
106345: LD_INT 1
106347: ARRAY
106348: PPUSH
106349: CALL_OW 250
106353: PPUSH
106354: LD_VAR 0 14
106358: PUSH
106359: LD_INT 1
106361: ARRAY
106362: PPUSH
106363: CALL_OW 251
106367: PPUSH
106368: CALL_OW 546
106372: PUSH
106373: LD_INT 2
106375: ARRAY
106376: EQUAL
106377: IFFALSE 106405
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
106379: LD_VAR 0 4
106383: PUSH
106384: LD_VAR 0 7
106388: ARRAY
106389: PPUSH
106390: LD_VAR 0 14
106394: PUSH
106395: LD_INT 1
106397: ARRAY
106398: PPUSH
106399: CALL 80427 0 2
106403: GO 106429
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106405: LD_VAR 0 4
106409: PUSH
106410: LD_VAR 0 7
106414: ARRAY
106415: PPUSH
106416: LD_VAR 0 14
106420: PUSH
106421: LD_INT 1
106423: ARRAY
106424: PPUSH
106425: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
106429: LD_VAR 0 4
106433: PUSH
106434: LD_VAR 0 7
106438: ARRAY
106439: PPUSH
106440: CALL_OW 264
106444: PUSH
106445: LD_INT 29
106447: EQUAL
106448: IFFALSE 106814
// begin if WantsToAttack ( group [ i ] ) in bombed then
106450: LD_VAR 0 4
106454: PUSH
106455: LD_VAR 0 7
106459: ARRAY
106460: PPUSH
106461: CALL_OW 319
106465: PUSH
106466: LD_VAR 0 28
106470: IN
106471: IFFALSE 106475
// continue ;
106473: GO 103479
// k := 8 ;
106475: LD_ADDR_VAR 0 9
106479: PUSH
106480: LD_INT 8
106482: ST_TO_ADDR
// x := 0 ;
106483: LD_ADDR_VAR 0 10
106487: PUSH
106488: LD_INT 0
106490: ST_TO_ADDR
// if tmp < k then
106491: LD_VAR 0 14
106495: PUSH
106496: LD_VAR 0 9
106500: LESS
106501: IFFALSE 106513
// k := tmp ;
106503: LD_ADDR_VAR 0 9
106507: PUSH
106508: LD_VAR 0 14
106512: ST_TO_ADDR
// for j = 1 to k do
106513: LD_ADDR_VAR 0 8
106517: PUSH
106518: DOUBLE
106519: LD_INT 1
106521: DEC
106522: ST_TO_ADDR
106523: LD_VAR 0 9
106527: PUSH
106528: FOR_TO
106529: IFFALSE 106661
// begin if GetType ( tmp [ j ] ) = unit_building then
106531: LD_VAR 0 14
106535: PUSH
106536: LD_VAR 0 8
106540: ARRAY
106541: PPUSH
106542: CALL_OW 247
106546: PUSH
106547: LD_INT 3
106549: EQUAL
106550: IFFALSE 106659
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
106552: LD_VAR 0 14
106556: PUSH
106557: LD_VAR 0 8
106561: ARRAY
106562: PUSH
106563: LD_VAR 0 28
106567: IN
106568: NOT
106569: PUSH
106570: LD_VAR 0 14
106574: PUSH
106575: LD_VAR 0 8
106579: ARRAY
106580: PPUSH
106581: CALL_OW 313
106585: AND
106586: IFFALSE 106659
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
106588: LD_VAR 0 4
106592: PUSH
106593: LD_VAR 0 7
106597: ARRAY
106598: PPUSH
106599: LD_VAR 0 14
106603: PUSH
106604: LD_VAR 0 8
106608: ARRAY
106609: PPUSH
106610: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
106614: LD_ADDR_VAR 0 28
106618: PUSH
106619: LD_VAR 0 28
106623: PPUSH
106624: LD_VAR 0 28
106628: PUSH
106629: LD_INT 1
106631: PLUS
106632: PPUSH
106633: LD_VAR 0 14
106637: PUSH
106638: LD_VAR 0 8
106642: ARRAY
106643: PPUSH
106644: CALL_OW 1
106648: ST_TO_ADDR
// attacking := true ;
106649: LD_ADDR_VAR 0 29
106653: PUSH
106654: LD_INT 1
106656: ST_TO_ADDR
// break ;
106657: GO 106661
// end ; end ;
106659: GO 106528
106661: POP
106662: POP
// if not attacking and f_attack_depot then
106663: LD_VAR 0 29
106667: NOT
106668: PUSH
106669: LD_VAR 0 25
106673: AND
106674: IFFALSE 106769
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
106676: LD_ADDR_VAR 0 13
106680: PUSH
106681: LD_VAR 0 14
106685: PPUSH
106686: LD_INT 2
106688: PUSH
106689: LD_INT 30
106691: PUSH
106692: LD_INT 0
106694: PUSH
106695: EMPTY
106696: LIST
106697: LIST
106698: PUSH
106699: LD_INT 30
106701: PUSH
106702: LD_INT 1
106704: PUSH
106705: EMPTY
106706: LIST
106707: LIST
106708: PUSH
106709: EMPTY
106710: LIST
106711: LIST
106712: LIST
106713: PPUSH
106714: CALL_OW 72
106718: ST_TO_ADDR
// if z then
106719: LD_VAR 0 13
106723: IFFALSE 106769
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
106725: LD_VAR 0 4
106729: PUSH
106730: LD_VAR 0 7
106734: ARRAY
106735: PPUSH
106736: LD_VAR 0 13
106740: PPUSH
106741: LD_VAR 0 4
106745: PUSH
106746: LD_VAR 0 7
106750: ARRAY
106751: PPUSH
106752: CALL_OW 74
106756: PPUSH
106757: CALL_OW 115
// attacking := true ;
106761: LD_ADDR_VAR 0 29
106765: PUSH
106766: LD_INT 1
106768: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
106769: LD_VAR 0 4
106773: PUSH
106774: LD_VAR 0 7
106778: ARRAY
106779: PPUSH
106780: CALL_OW 256
106784: PUSH
106785: LD_INT 500
106787: LESS
106788: IFFALSE 106814
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106790: LD_VAR 0 4
106794: PUSH
106795: LD_VAR 0 7
106799: ARRAY
106800: PPUSH
106801: LD_VAR 0 14
106805: PUSH
106806: LD_INT 1
106808: ARRAY
106809: PPUSH
106810: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
106814: LD_VAR 0 4
106818: PUSH
106819: LD_VAR 0 7
106823: ARRAY
106824: PPUSH
106825: CALL_OW 264
106829: PUSH
106830: LD_INT 49
106832: EQUAL
106833: IFFALSE 106954
// begin if not HasTask ( group [ i ] ) then
106835: LD_VAR 0 4
106839: PUSH
106840: LD_VAR 0 7
106844: ARRAY
106845: PPUSH
106846: CALL_OW 314
106850: NOT
106851: IFFALSE 106954
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
106853: LD_ADDR_VAR 0 9
106857: PUSH
106858: LD_INT 81
106860: PUSH
106861: LD_VAR 0 4
106865: PUSH
106866: LD_VAR 0 7
106870: ARRAY
106871: PPUSH
106872: CALL_OW 255
106876: PUSH
106877: EMPTY
106878: LIST
106879: LIST
106880: PPUSH
106881: CALL_OW 69
106885: PPUSH
106886: LD_VAR 0 4
106890: PUSH
106891: LD_VAR 0 7
106895: ARRAY
106896: PPUSH
106897: CALL_OW 74
106901: ST_TO_ADDR
// if k then
106902: LD_VAR 0 9
106906: IFFALSE 106954
// if GetDistUnits ( group [ i ] , k ) > 10 then
106908: LD_VAR 0 4
106912: PUSH
106913: LD_VAR 0 7
106917: ARRAY
106918: PPUSH
106919: LD_VAR 0 9
106923: PPUSH
106924: CALL_OW 296
106928: PUSH
106929: LD_INT 10
106931: GREATER
106932: IFFALSE 106954
// ComMoveUnit ( group [ i ] , k ) ;
106934: LD_VAR 0 4
106938: PUSH
106939: LD_VAR 0 7
106943: ARRAY
106944: PPUSH
106945: LD_VAR 0 9
106949: PPUSH
106950: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
106954: LD_VAR 0 4
106958: PUSH
106959: LD_VAR 0 7
106963: ARRAY
106964: PPUSH
106965: CALL_OW 256
106969: PUSH
106970: LD_INT 250
106972: LESS
106973: PUSH
106974: LD_VAR 0 4
106978: PUSH
106979: LD_VAR 0 7
106983: ARRAY
106984: PUSH
106985: LD_INT 21
106987: PUSH
106988: LD_INT 2
106990: PUSH
106991: EMPTY
106992: LIST
106993: LIST
106994: PUSH
106995: LD_INT 23
106997: PUSH
106998: LD_INT 2
107000: PUSH
107001: EMPTY
107002: LIST
107003: LIST
107004: PUSH
107005: EMPTY
107006: LIST
107007: LIST
107008: PPUSH
107009: CALL_OW 69
107013: IN
107014: AND
107015: IFFALSE 107140
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
107017: LD_ADDR_VAR 0 9
107021: PUSH
107022: LD_OWVAR 3
107026: PUSH
107027: LD_VAR 0 4
107031: PUSH
107032: LD_VAR 0 7
107036: ARRAY
107037: DIFF
107038: PPUSH
107039: LD_VAR 0 4
107043: PUSH
107044: LD_VAR 0 7
107048: ARRAY
107049: PPUSH
107050: CALL_OW 74
107054: ST_TO_ADDR
// if not k then
107055: LD_VAR 0 9
107059: NOT
107060: IFFALSE 107064
// continue ;
107062: GO 103479
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
107064: LD_VAR 0 9
107068: PUSH
107069: LD_INT 81
107071: PUSH
107072: LD_VAR 0 4
107076: PUSH
107077: LD_VAR 0 7
107081: ARRAY
107082: PPUSH
107083: CALL_OW 255
107087: PUSH
107088: EMPTY
107089: LIST
107090: LIST
107091: PPUSH
107092: CALL_OW 69
107096: IN
107097: PUSH
107098: LD_VAR 0 9
107102: PPUSH
107103: LD_VAR 0 4
107107: PUSH
107108: LD_VAR 0 7
107112: ARRAY
107113: PPUSH
107114: CALL_OW 296
107118: PUSH
107119: LD_INT 5
107121: LESS
107122: AND
107123: IFFALSE 107140
// ComAutodestruct ( group [ i ] ) ;
107125: LD_VAR 0 4
107129: PUSH
107130: LD_VAR 0 7
107134: ARRAY
107135: PPUSH
107136: CALL 80325 0 1
// end ; if f_attack_depot then
107140: LD_VAR 0 25
107144: IFFALSE 107256
// begin k := 6 ;
107146: LD_ADDR_VAR 0 9
107150: PUSH
107151: LD_INT 6
107153: ST_TO_ADDR
// if tmp < k then
107154: LD_VAR 0 14
107158: PUSH
107159: LD_VAR 0 9
107163: LESS
107164: IFFALSE 107176
// k := tmp ;
107166: LD_ADDR_VAR 0 9
107170: PUSH
107171: LD_VAR 0 14
107175: ST_TO_ADDR
// for j = 1 to k do
107176: LD_ADDR_VAR 0 8
107180: PUSH
107181: DOUBLE
107182: LD_INT 1
107184: DEC
107185: ST_TO_ADDR
107186: LD_VAR 0 9
107190: PUSH
107191: FOR_TO
107192: IFFALSE 107254
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
107194: LD_VAR 0 8
107198: PPUSH
107199: CALL_OW 266
107203: PUSH
107204: LD_INT 0
107206: PUSH
107207: LD_INT 1
107209: PUSH
107210: EMPTY
107211: LIST
107212: LIST
107213: IN
107214: IFFALSE 107252
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107216: LD_VAR 0 4
107220: PUSH
107221: LD_VAR 0 7
107225: ARRAY
107226: PPUSH
107227: LD_VAR 0 14
107231: PUSH
107232: LD_VAR 0 8
107236: ARRAY
107237: PPUSH
107238: CALL_OW 115
// attacking := true ;
107242: LD_ADDR_VAR 0 29
107246: PUSH
107247: LD_INT 1
107249: ST_TO_ADDR
// break ;
107250: GO 107254
// end ;
107252: GO 107191
107254: POP
107255: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
107256: LD_VAR 0 4
107260: PUSH
107261: LD_VAR 0 7
107265: ARRAY
107266: PPUSH
107267: CALL_OW 302
107271: PUSH
107272: LD_VAR 0 29
107276: NOT
107277: AND
107278: IFFALSE 107600
// begin if GetTag ( group [ i ] ) = 71 then
107280: LD_VAR 0 4
107284: PUSH
107285: LD_VAR 0 7
107289: ARRAY
107290: PPUSH
107291: CALL_OW 110
107295: PUSH
107296: LD_INT 71
107298: EQUAL
107299: IFFALSE 107340
// begin if HasTask ( group [ i ] ) then
107301: LD_VAR 0 4
107305: PUSH
107306: LD_VAR 0 7
107310: ARRAY
107311: PPUSH
107312: CALL_OW 314
107316: IFFALSE 107322
// continue else
107318: GO 103479
107320: GO 107340
// SetTag ( group [ i ] , 0 ) ;
107322: LD_VAR 0 4
107326: PUSH
107327: LD_VAR 0 7
107331: ARRAY
107332: PPUSH
107333: LD_INT 0
107335: PPUSH
107336: CALL_OW 109
// end ; k := 8 ;
107340: LD_ADDR_VAR 0 9
107344: PUSH
107345: LD_INT 8
107347: ST_TO_ADDR
// x := 0 ;
107348: LD_ADDR_VAR 0 10
107352: PUSH
107353: LD_INT 0
107355: ST_TO_ADDR
// if tmp < k then
107356: LD_VAR 0 14
107360: PUSH
107361: LD_VAR 0 9
107365: LESS
107366: IFFALSE 107378
// k := tmp ;
107368: LD_ADDR_VAR 0 9
107372: PUSH
107373: LD_VAR 0 14
107377: ST_TO_ADDR
// for j = 1 to k do
107378: LD_ADDR_VAR 0 8
107382: PUSH
107383: DOUBLE
107384: LD_INT 1
107386: DEC
107387: ST_TO_ADDR
107388: LD_VAR 0 9
107392: PUSH
107393: FOR_TO
107394: IFFALSE 107492
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
107396: LD_VAR 0 14
107400: PUSH
107401: LD_VAR 0 8
107405: ARRAY
107406: PPUSH
107407: CALL_OW 247
107411: PUSH
107412: LD_INT 1
107414: EQUAL
107415: PUSH
107416: LD_VAR 0 14
107420: PUSH
107421: LD_VAR 0 8
107425: ARRAY
107426: PPUSH
107427: CALL_OW 256
107431: PUSH
107432: LD_INT 250
107434: LESS
107435: PUSH
107436: LD_VAR 0 20
107440: AND
107441: PUSH
107442: LD_VAR 0 20
107446: NOT
107447: PUSH
107448: LD_VAR 0 14
107452: PUSH
107453: LD_VAR 0 8
107457: ARRAY
107458: PPUSH
107459: CALL_OW 256
107463: PUSH
107464: LD_INT 250
107466: GREATEREQUAL
107467: AND
107468: OR
107469: AND
107470: IFFALSE 107490
// begin x := tmp [ j ] ;
107472: LD_ADDR_VAR 0 10
107476: PUSH
107477: LD_VAR 0 14
107481: PUSH
107482: LD_VAR 0 8
107486: ARRAY
107487: ST_TO_ADDR
// break ;
107488: GO 107492
// end ;
107490: GO 107393
107492: POP
107493: POP
// if x then
107494: LD_VAR 0 10
107498: IFFALSE 107522
// ComAttackUnit ( group [ i ] , x ) else
107500: LD_VAR 0 4
107504: PUSH
107505: LD_VAR 0 7
107509: ARRAY
107510: PPUSH
107511: LD_VAR 0 10
107515: PPUSH
107516: CALL_OW 115
107520: GO 107546
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
107522: LD_VAR 0 4
107526: PUSH
107527: LD_VAR 0 7
107531: ARRAY
107532: PPUSH
107533: LD_VAR 0 14
107537: PUSH
107538: LD_INT 1
107540: ARRAY
107541: PPUSH
107542: CALL_OW 115
// if not HasTask ( group [ i ] ) then
107546: LD_VAR 0 4
107550: PUSH
107551: LD_VAR 0 7
107555: ARRAY
107556: PPUSH
107557: CALL_OW 314
107561: NOT
107562: IFFALSE 107600
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
107564: LD_VAR 0 4
107568: PUSH
107569: LD_VAR 0 7
107573: ARRAY
107574: PPUSH
107575: LD_VAR 0 14
107579: PPUSH
107580: LD_VAR 0 4
107584: PUSH
107585: LD_VAR 0 7
107589: ARRAY
107590: PPUSH
107591: CALL_OW 74
107595: PPUSH
107596: CALL_OW 115
// end ; end ; end ;
107600: GO 103479
107602: POP
107603: POP
// wait ( 0 0$2 ) ;
107604: LD_INT 70
107606: PPUSH
107607: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
107611: LD_VAR 0 4
107615: NOT
107616: PUSH
107617: LD_VAR 0 4
107621: PUSH
107622: EMPTY
107623: EQUAL
107624: OR
107625: PUSH
107626: LD_INT 81
107628: PUSH
107629: LD_VAR 0 35
107633: PUSH
107634: EMPTY
107635: LIST
107636: LIST
107637: PPUSH
107638: CALL_OW 69
107642: NOT
107643: OR
107644: IFFALSE 103464
// end ;
107646: LD_VAR 0 2
107650: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
107651: LD_INT 0
107653: PPUSH
107654: PPUSH
107655: PPUSH
107656: PPUSH
107657: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
107658: LD_VAR 0 1
107662: NOT
107663: PUSH
107664: LD_EXP 50
107668: PUSH
107669: LD_VAR 0 1
107673: ARRAY
107674: NOT
107675: OR
107676: PUSH
107677: LD_VAR 0 2
107681: NOT
107682: OR
107683: PUSH
107684: LD_VAR 0 3
107688: NOT
107689: OR
107690: IFFALSE 107694
// exit ;
107692: GO 108207
// side := mc_sides [ base ] ;
107694: LD_ADDR_VAR 0 6
107698: PUSH
107699: LD_EXP 76
107703: PUSH
107704: LD_VAR 0 1
107708: ARRAY
107709: ST_TO_ADDR
// if not side then
107710: LD_VAR 0 6
107714: NOT
107715: IFFALSE 107719
// exit ;
107717: GO 108207
// for i in solds do
107719: LD_ADDR_VAR 0 7
107723: PUSH
107724: LD_VAR 0 2
107728: PUSH
107729: FOR_IN
107730: IFFALSE 107791
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
107732: LD_VAR 0 7
107736: PPUSH
107737: CALL_OW 310
107741: PPUSH
107742: CALL_OW 266
107746: PUSH
107747: LD_INT 32
107749: PUSH
107750: LD_INT 31
107752: PUSH
107753: EMPTY
107754: LIST
107755: LIST
107756: IN
107757: IFFALSE 107777
// solds := solds diff i else
107759: LD_ADDR_VAR 0 2
107763: PUSH
107764: LD_VAR 0 2
107768: PUSH
107769: LD_VAR 0 7
107773: DIFF
107774: ST_TO_ADDR
107775: GO 107789
// SetTag ( i , 18 ) ;
107777: LD_VAR 0 7
107781: PPUSH
107782: LD_INT 18
107784: PPUSH
107785: CALL_OW 109
107789: GO 107729
107791: POP
107792: POP
// if not solds then
107793: LD_VAR 0 2
107797: NOT
107798: IFFALSE 107802
// exit ;
107800: GO 108207
// repeat wait ( 0 0$2 ) ;
107802: LD_INT 70
107804: PPUSH
107805: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
107809: LD_ADDR_VAR 0 5
107813: PUSH
107814: LD_VAR 0 6
107818: PPUSH
107819: LD_VAR 0 3
107823: PPUSH
107824: CALL 49707 0 2
107828: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107829: LD_EXP 50
107833: PUSH
107834: LD_VAR 0 1
107838: ARRAY
107839: NOT
107840: PUSH
107841: LD_EXP 50
107845: PUSH
107846: LD_VAR 0 1
107850: ARRAY
107851: PUSH
107852: EMPTY
107853: EQUAL
107854: OR
107855: IFFALSE 107892
// begin for i in solds do
107857: LD_ADDR_VAR 0 7
107861: PUSH
107862: LD_VAR 0 2
107866: PUSH
107867: FOR_IN
107868: IFFALSE 107881
// ComStop ( i ) ;
107870: LD_VAR 0 7
107874: PPUSH
107875: CALL_OW 141
107879: GO 107867
107881: POP
107882: POP
// solds := [ ] ;
107883: LD_ADDR_VAR 0 2
107887: PUSH
107888: EMPTY
107889: ST_TO_ADDR
// exit ;
107890: GO 108207
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
107892: LD_VAR 0 5
107896: NOT
107897: PUSH
107898: LD_VAR 0 5
107902: PUSH
107903: LD_INT 3
107905: GREATER
107906: OR
107907: PUSH
107908: LD_EXP 72
107912: PUSH
107913: LD_VAR 0 1
107917: ARRAY
107918: OR
107919: IFFALSE 107960
// begin for i in solds do
107921: LD_ADDR_VAR 0 7
107925: PUSH
107926: LD_VAR 0 2
107930: PUSH
107931: FOR_IN
107932: IFFALSE 107956
// if HasTask ( i ) then
107934: LD_VAR 0 7
107938: PPUSH
107939: CALL_OW 314
107943: IFFALSE 107954
// ComStop ( i ) ;
107945: LD_VAR 0 7
107949: PPUSH
107950: CALL_OW 141
107954: GO 107931
107956: POP
107957: POP
// break ;
107958: GO 108195
// end ; for i in solds do
107960: LD_ADDR_VAR 0 7
107964: PUSH
107965: LD_VAR 0 2
107969: PUSH
107970: FOR_IN
107971: IFFALSE 108187
// begin if IsInUnit ( i ) then
107973: LD_VAR 0 7
107977: PPUSH
107978: CALL_OW 310
107982: IFFALSE 107993
// ComExitBuilding ( i ) ;
107984: LD_VAR 0 7
107988: PPUSH
107989: CALL_OW 122
// if GetLives ( i ) > 333 then
107993: LD_VAR 0 7
107997: PPUSH
107998: CALL_OW 256
108002: PUSH
108003: LD_INT 333
108005: GREATER
108006: IFFALSE 108034
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
108008: LD_VAR 0 7
108012: PPUSH
108013: LD_VAR 0 5
108017: PPUSH
108018: LD_VAR 0 7
108022: PPUSH
108023: CALL_OW 74
108027: PPUSH
108028: CALL_OW 115
108032: GO 108185
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
108034: LD_ADDR_VAR 0 8
108038: PUSH
108039: LD_EXP 50
108043: PUSH
108044: LD_VAR 0 1
108048: ARRAY
108049: PPUSH
108050: LD_INT 2
108052: PUSH
108053: LD_INT 30
108055: PUSH
108056: LD_INT 0
108058: PUSH
108059: EMPTY
108060: LIST
108061: LIST
108062: PUSH
108063: LD_INT 30
108065: PUSH
108066: LD_INT 1
108068: PUSH
108069: EMPTY
108070: LIST
108071: LIST
108072: PUSH
108073: LD_INT 30
108075: PUSH
108076: LD_INT 6
108078: PUSH
108079: EMPTY
108080: LIST
108081: LIST
108082: PUSH
108083: EMPTY
108084: LIST
108085: LIST
108086: LIST
108087: LIST
108088: PPUSH
108089: CALL_OW 72
108093: PPUSH
108094: LD_VAR 0 7
108098: PPUSH
108099: CALL_OW 74
108103: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
108104: LD_VAR 0 7
108108: PPUSH
108109: LD_VAR 0 8
108113: PPUSH
108114: CALL_OW 250
108118: PPUSH
108119: LD_INT 3
108121: PPUSH
108122: LD_INT 5
108124: PPUSH
108125: CALL_OW 272
108129: PPUSH
108130: LD_VAR 0 8
108134: PPUSH
108135: CALL_OW 251
108139: PPUSH
108140: LD_INT 3
108142: PPUSH
108143: LD_INT 5
108145: PPUSH
108146: CALL_OW 273
108150: PPUSH
108151: CALL_OW 111
// SetTag ( i , 0 ) ;
108155: LD_VAR 0 7
108159: PPUSH
108160: LD_INT 0
108162: PPUSH
108163: CALL_OW 109
// solds := solds diff i ;
108167: LD_ADDR_VAR 0 2
108171: PUSH
108172: LD_VAR 0 2
108176: PUSH
108177: LD_VAR 0 7
108181: DIFF
108182: ST_TO_ADDR
// continue ;
108183: GO 107970
// end ; end ;
108185: GO 107970
108187: POP
108188: POP
// until solds ;
108189: LD_VAR 0 2
108193: IFFALSE 107802
// MC_Reset ( base , 18 ) ;
108195: LD_VAR 0 1
108199: PPUSH
108200: LD_INT 18
108202: PPUSH
108203: CALL 21927 0 2
// end ;
108207: LD_VAR 0 4
108211: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
108212: LD_INT 0
108214: PPUSH
108215: PPUSH
108216: PPUSH
108217: PPUSH
108218: PPUSH
108219: PPUSH
108220: PPUSH
108221: PPUSH
108222: PPUSH
108223: PPUSH
108224: PPUSH
108225: PPUSH
108226: PPUSH
108227: PPUSH
108228: PPUSH
108229: PPUSH
108230: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
108231: LD_ADDR_VAR 0 13
108235: PUSH
108236: LD_EXP 50
108240: PUSH
108241: LD_VAR 0 1
108245: ARRAY
108246: PPUSH
108247: LD_INT 25
108249: PUSH
108250: LD_INT 3
108252: PUSH
108253: EMPTY
108254: LIST
108255: LIST
108256: PPUSH
108257: CALL_OW 72
108261: ST_TO_ADDR
// if mc_remote_driver [ base ] then
108262: LD_EXP 90
108266: PUSH
108267: LD_VAR 0 1
108271: ARRAY
108272: IFFALSE 108296
// mechs := mechs diff mc_remote_driver [ base ] ;
108274: LD_ADDR_VAR 0 13
108278: PUSH
108279: LD_VAR 0 13
108283: PUSH
108284: LD_EXP 90
108288: PUSH
108289: LD_VAR 0 1
108293: ARRAY
108294: DIFF
108295: ST_TO_ADDR
// for i in mechs do
108296: LD_ADDR_VAR 0 5
108300: PUSH
108301: LD_VAR 0 13
108305: PUSH
108306: FOR_IN
108307: IFFALSE 108342
// if GetTag ( i ) > 0 then
108309: LD_VAR 0 5
108313: PPUSH
108314: CALL_OW 110
108318: PUSH
108319: LD_INT 0
108321: GREATER
108322: IFFALSE 108340
// mechs := mechs diff i ;
108324: LD_ADDR_VAR 0 13
108328: PUSH
108329: LD_VAR 0 13
108333: PUSH
108334: LD_VAR 0 5
108338: DIFF
108339: ST_TO_ADDR
108340: GO 108306
108342: POP
108343: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108344: LD_ADDR_VAR 0 9
108348: PUSH
108349: LD_EXP 50
108353: PUSH
108354: LD_VAR 0 1
108358: ARRAY
108359: PPUSH
108360: LD_INT 2
108362: PUSH
108363: LD_INT 25
108365: PUSH
108366: LD_INT 1
108368: PUSH
108369: EMPTY
108370: LIST
108371: LIST
108372: PUSH
108373: LD_INT 25
108375: PUSH
108376: LD_INT 5
108378: PUSH
108379: EMPTY
108380: LIST
108381: LIST
108382: PUSH
108383: LD_INT 25
108385: PUSH
108386: LD_INT 8
108388: PUSH
108389: EMPTY
108390: LIST
108391: LIST
108392: PUSH
108393: LD_INT 25
108395: PUSH
108396: LD_INT 9
108398: PUSH
108399: EMPTY
108400: LIST
108401: LIST
108402: PUSH
108403: EMPTY
108404: LIST
108405: LIST
108406: LIST
108407: LIST
108408: LIST
108409: PPUSH
108410: CALL_OW 72
108414: ST_TO_ADDR
// if not defenders and not solds then
108415: LD_VAR 0 2
108419: NOT
108420: PUSH
108421: LD_VAR 0 9
108425: NOT
108426: AND
108427: IFFALSE 108431
// exit ;
108429: GO 110121
// depot_under_attack := false ;
108431: LD_ADDR_VAR 0 17
108435: PUSH
108436: LD_INT 0
108438: ST_TO_ADDR
// sold_defenders := [ ] ;
108439: LD_ADDR_VAR 0 18
108443: PUSH
108444: EMPTY
108445: ST_TO_ADDR
// if mechs then
108446: LD_VAR 0 13
108450: IFFALSE 108603
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
108452: LD_ADDR_VAR 0 5
108456: PUSH
108457: LD_VAR 0 2
108461: PPUSH
108462: LD_INT 21
108464: PUSH
108465: LD_INT 2
108467: PUSH
108468: EMPTY
108469: LIST
108470: LIST
108471: PPUSH
108472: CALL_OW 72
108476: PUSH
108477: FOR_IN
108478: IFFALSE 108601
// begin if GetTag ( i ) <> 20 then
108480: LD_VAR 0 5
108484: PPUSH
108485: CALL_OW 110
108489: PUSH
108490: LD_INT 20
108492: NONEQUAL
108493: IFFALSE 108507
// SetTag ( i , 20 ) ;
108495: LD_VAR 0 5
108499: PPUSH
108500: LD_INT 20
108502: PPUSH
108503: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
108507: LD_VAR 0 5
108511: PPUSH
108512: CALL_OW 263
108516: PUSH
108517: LD_INT 1
108519: EQUAL
108520: PUSH
108521: LD_VAR 0 5
108525: PPUSH
108526: CALL_OW 311
108530: NOT
108531: AND
108532: IFFALSE 108599
// begin un := mechs [ 1 ] ;
108534: LD_ADDR_VAR 0 11
108538: PUSH
108539: LD_VAR 0 13
108543: PUSH
108544: LD_INT 1
108546: ARRAY
108547: ST_TO_ADDR
// ComExit ( un ) ;
108548: LD_VAR 0 11
108552: PPUSH
108553: CALL 84670 0 1
// AddComEnterUnit ( un , i ) ;
108557: LD_VAR 0 11
108561: PPUSH
108562: LD_VAR 0 5
108566: PPUSH
108567: CALL_OW 180
// SetTag ( un , 19 ) ;
108571: LD_VAR 0 11
108575: PPUSH
108576: LD_INT 19
108578: PPUSH
108579: CALL_OW 109
// mechs := mechs diff un ;
108583: LD_ADDR_VAR 0 13
108587: PUSH
108588: LD_VAR 0 13
108592: PUSH
108593: LD_VAR 0 11
108597: DIFF
108598: ST_TO_ADDR
// end ; end ;
108599: GO 108477
108601: POP
108602: POP
// if solds then
108603: LD_VAR 0 9
108607: IFFALSE 108666
// for i in solds do
108609: LD_ADDR_VAR 0 5
108613: PUSH
108614: LD_VAR 0 9
108618: PUSH
108619: FOR_IN
108620: IFFALSE 108664
// if not GetTag ( i ) then
108622: LD_VAR 0 5
108626: PPUSH
108627: CALL_OW 110
108631: NOT
108632: IFFALSE 108662
// begin defenders := defenders union i ;
108634: LD_ADDR_VAR 0 2
108638: PUSH
108639: LD_VAR 0 2
108643: PUSH
108644: LD_VAR 0 5
108648: UNION
108649: ST_TO_ADDR
// SetTag ( i , 18 ) ;
108650: LD_VAR 0 5
108654: PPUSH
108655: LD_INT 18
108657: PPUSH
108658: CALL_OW 109
// end ;
108662: GO 108619
108664: POP
108665: POP
// repeat wait ( 0 0$2 ) ;
108666: LD_INT 70
108668: PPUSH
108669: CALL_OW 67
// enemy := mc_scan [ base ] ;
108673: LD_ADDR_VAR 0 3
108677: PUSH
108678: LD_EXP 73
108682: PUSH
108683: LD_VAR 0 1
108687: ARRAY
108688: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
108689: LD_EXP 50
108693: PUSH
108694: LD_VAR 0 1
108698: ARRAY
108699: NOT
108700: PUSH
108701: LD_EXP 50
108705: PUSH
108706: LD_VAR 0 1
108710: ARRAY
108711: PUSH
108712: EMPTY
108713: EQUAL
108714: OR
108715: IFFALSE 108752
// begin for i in defenders do
108717: LD_ADDR_VAR 0 5
108721: PUSH
108722: LD_VAR 0 2
108726: PUSH
108727: FOR_IN
108728: IFFALSE 108741
// ComStop ( i ) ;
108730: LD_VAR 0 5
108734: PPUSH
108735: CALL_OW 141
108739: GO 108727
108741: POP
108742: POP
// defenders := [ ] ;
108743: LD_ADDR_VAR 0 2
108747: PUSH
108748: EMPTY
108749: ST_TO_ADDR
// exit ;
108750: GO 110121
// end ; for i in defenders do
108752: LD_ADDR_VAR 0 5
108756: PUSH
108757: LD_VAR 0 2
108761: PUSH
108762: FOR_IN
108763: IFFALSE 109581
// begin e := NearestUnitToUnit ( enemy , i ) ;
108765: LD_ADDR_VAR 0 14
108769: PUSH
108770: LD_VAR 0 3
108774: PPUSH
108775: LD_VAR 0 5
108779: PPUSH
108780: CALL_OW 74
108784: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108785: LD_ADDR_VAR 0 8
108789: PUSH
108790: LD_EXP 50
108794: PUSH
108795: LD_VAR 0 1
108799: ARRAY
108800: PPUSH
108801: LD_INT 2
108803: PUSH
108804: LD_INT 30
108806: PUSH
108807: LD_INT 0
108809: PUSH
108810: EMPTY
108811: LIST
108812: LIST
108813: PUSH
108814: LD_INT 30
108816: PUSH
108817: LD_INT 1
108819: PUSH
108820: EMPTY
108821: LIST
108822: LIST
108823: PUSH
108824: EMPTY
108825: LIST
108826: LIST
108827: LIST
108828: PPUSH
108829: CALL_OW 72
108833: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
108834: LD_ADDR_VAR 0 17
108838: PUSH
108839: LD_VAR 0 8
108843: NOT
108844: PUSH
108845: LD_VAR 0 8
108849: PPUSH
108850: LD_INT 3
108852: PUSH
108853: LD_INT 24
108855: PUSH
108856: LD_INT 600
108858: PUSH
108859: EMPTY
108860: LIST
108861: LIST
108862: PUSH
108863: EMPTY
108864: LIST
108865: LIST
108866: PPUSH
108867: CALL_OW 72
108871: OR
108872: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
108873: LD_VAR 0 5
108877: PPUSH
108878: CALL_OW 247
108882: PUSH
108883: LD_INT 2
108885: DOUBLE
108886: EQUAL
108887: IFTRUE 108891
108889: GO 109287
108891: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
108892: LD_VAR 0 5
108896: PPUSH
108897: CALL_OW 256
108901: PUSH
108902: LD_INT 650
108904: GREATER
108905: PUSH
108906: LD_VAR 0 5
108910: PPUSH
108911: LD_VAR 0 14
108915: PPUSH
108916: CALL_OW 296
108920: PUSH
108921: LD_INT 40
108923: LESS
108924: PUSH
108925: LD_VAR 0 14
108929: PPUSH
108930: LD_EXP 75
108934: PUSH
108935: LD_VAR 0 1
108939: ARRAY
108940: PPUSH
108941: CALL_OW 308
108945: OR
108946: AND
108947: IFFALSE 109069
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
108949: LD_VAR 0 5
108953: PPUSH
108954: CALL_OW 262
108958: PUSH
108959: LD_INT 1
108961: EQUAL
108962: PUSH
108963: LD_VAR 0 5
108967: PPUSH
108968: CALL_OW 261
108972: PUSH
108973: LD_INT 30
108975: LESS
108976: AND
108977: PUSH
108978: LD_VAR 0 8
108982: AND
108983: IFFALSE 109053
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
108985: LD_VAR 0 5
108989: PPUSH
108990: LD_VAR 0 8
108994: PPUSH
108995: LD_VAR 0 5
108999: PPUSH
109000: CALL_OW 74
109004: PPUSH
109005: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
109009: LD_VAR 0 5
109013: PPUSH
109014: LD_VAR 0 8
109018: PPUSH
109019: LD_VAR 0 5
109023: PPUSH
109024: CALL_OW 74
109028: PPUSH
109029: CALL_OW 296
109033: PUSH
109034: LD_INT 6
109036: LESS
109037: IFFALSE 109051
// SetFuel ( i , 100 ) ;
109039: LD_VAR 0 5
109043: PPUSH
109044: LD_INT 100
109046: PPUSH
109047: CALL_OW 240
// end else
109051: GO 109067
// ComAttackUnit ( i , e ) ;
109053: LD_VAR 0 5
109057: PPUSH
109058: LD_VAR 0 14
109062: PPUSH
109063: CALL_OW 115
// end else
109067: GO 109170
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
109069: LD_VAR 0 14
109073: PPUSH
109074: LD_EXP 75
109078: PUSH
109079: LD_VAR 0 1
109083: ARRAY
109084: PPUSH
109085: CALL_OW 308
109089: NOT
109090: PUSH
109091: LD_VAR 0 5
109095: PPUSH
109096: LD_VAR 0 14
109100: PPUSH
109101: CALL_OW 296
109105: PUSH
109106: LD_INT 40
109108: GREATEREQUAL
109109: AND
109110: PUSH
109111: LD_VAR 0 5
109115: PPUSH
109116: CALL_OW 256
109120: PUSH
109121: LD_INT 650
109123: LESSEQUAL
109124: OR
109125: PUSH
109126: LD_VAR 0 5
109130: PPUSH
109131: LD_EXP 74
109135: PUSH
109136: LD_VAR 0 1
109140: ARRAY
109141: PPUSH
109142: CALL_OW 308
109146: NOT
109147: AND
109148: IFFALSE 109170
// ComMoveToArea ( i , mc_parking [ base ] ) ;
109150: LD_VAR 0 5
109154: PPUSH
109155: LD_EXP 74
109159: PUSH
109160: LD_VAR 0 1
109164: ARRAY
109165: PPUSH
109166: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
109170: LD_VAR 0 5
109174: PPUSH
109175: CALL_OW 256
109179: PUSH
109180: LD_INT 998
109182: LESS
109183: PUSH
109184: LD_VAR 0 5
109188: PPUSH
109189: CALL_OW 263
109193: PUSH
109194: LD_INT 1
109196: EQUAL
109197: AND
109198: PUSH
109199: LD_VAR 0 5
109203: PPUSH
109204: CALL_OW 311
109208: AND
109209: PUSH
109210: LD_VAR 0 5
109214: PPUSH
109215: LD_EXP 74
109219: PUSH
109220: LD_VAR 0 1
109224: ARRAY
109225: PPUSH
109226: CALL_OW 308
109230: AND
109231: IFFALSE 109285
// begin mech := IsDrivenBy ( i ) ;
109233: LD_ADDR_VAR 0 10
109237: PUSH
109238: LD_VAR 0 5
109242: PPUSH
109243: CALL_OW 311
109247: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
109248: LD_VAR 0 10
109252: PPUSH
109253: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
109257: LD_VAR 0 10
109261: PPUSH
109262: LD_VAR 0 5
109266: PPUSH
109267: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
109271: LD_VAR 0 10
109275: PPUSH
109276: LD_VAR 0 5
109280: PPUSH
109281: CALL_OW 180
// end ; end ; unit_human :
109285: GO 109552
109287: LD_INT 1
109289: DOUBLE
109290: EQUAL
109291: IFTRUE 109295
109293: GO 109551
109295: POP
// begin b := IsInUnit ( i ) ;
109296: LD_ADDR_VAR 0 19
109300: PUSH
109301: LD_VAR 0 5
109305: PPUSH
109306: CALL_OW 310
109310: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
109311: LD_ADDR_VAR 0 20
109315: PUSH
109316: LD_VAR 0 19
109320: NOT
109321: PUSH
109322: LD_VAR 0 19
109326: PPUSH
109327: CALL_OW 266
109331: PUSH
109332: LD_INT 32
109334: PUSH
109335: LD_INT 31
109337: PUSH
109338: EMPTY
109339: LIST
109340: LIST
109341: IN
109342: OR
109343: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
109344: LD_VAR 0 17
109348: PUSH
109349: LD_VAR 0 2
109353: PPUSH
109354: LD_INT 21
109356: PUSH
109357: LD_INT 2
109359: PUSH
109360: EMPTY
109361: LIST
109362: LIST
109363: PPUSH
109364: CALL_OW 72
109368: PUSH
109369: LD_INT 1
109371: LESSEQUAL
109372: OR
109373: PUSH
109374: LD_VAR 0 20
109378: AND
109379: PUSH
109380: LD_VAR 0 5
109384: PUSH
109385: LD_VAR 0 18
109389: IN
109390: NOT
109391: AND
109392: IFFALSE 109485
// begin if b then
109394: LD_VAR 0 19
109398: IFFALSE 109447
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
109400: LD_VAR 0 19
109404: PPUSH
109405: LD_VAR 0 3
109409: PPUSH
109410: LD_VAR 0 19
109414: PPUSH
109415: CALL_OW 74
109419: PPUSH
109420: CALL_OW 296
109424: PUSH
109425: LD_INT 10
109427: LESS
109428: PUSH
109429: LD_VAR 0 19
109433: PPUSH
109434: CALL_OW 461
109438: PUSH
109439: LD_INT 7
109441: NONEQUAL
109442: AND
109443: IFFALSE 109447
// continue ;
109445: GO 108762
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
109447: LD_ADDR_VAR 0 18
109451: PUSH
109452: LD_VAR 0 18
109456: PPUSH
109457: LD_VAR 0 18
109461: PUSH
109462: LD_INT 1
109464: PLUS
109465: PPUSH
109466: LD_VAR 0 5
109470: PPUSH
109471: CALL_OW 1
109475: ST_TO_ADDR
// ComExitBuilding ( i ) ;
109476: LD_VAR 0 5
109480: PPUSH
109481: CALL_OW 122
// end ; if sold_defenders then
109485: LD_VAR 0 18
109489: IFFALSE 109549
// if i in sold_defenders then
109491: LD_VAR 0 5
109495: PUSH
109496: LD_VAR 0 18
109500: IN
109501: IFFALSE 109549
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
109503: LD_VAR 0 5
109507: PPUSH
109508: CALL_OW 314
109512: NOT
109513: PUSH
109514: LD_VAR 0 5
109518: PPUSH
109519: LD_VAR 0 14
109523: PPUSH
109524: CALL_OW 296
109528: PUSH
109529: LD_INT 30
109531: LESS
109532: AND
109533: IFFALSE 109549
// ComAttackUnit ( i , e ) ;
109535: LD_VAR 0 5
109539: PPUSH
109540: LD_VAR 0 14
109544: PPUSH
109545: CALL_OW 115
// end ; end ; end ;
109549: GO 109552
109551: POP
// if IsDead ( i ) then
109552: LD_VAR 0 5
109556: PPUSH
109557: CALL_OW 301
109561: IFFALSE 109579
// defenders := defenders diff i ;
109563: LD_ADDR_VAR 0 2
109567: PUSH
109568: LD_VAR 0 2
109572: PUSH
109573: LD_VAR 0 5
109577: DIFF
109578: ST_TO_ADDR
// end ;
109579: GO 108762
109581: POP
109582: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
109583: LD_VAR 0 3
109587: NOT
109588: PUSH
109589: LD_VAR 0 2
109593: NOT
109594: OR
109595: PUSH
109596: LD_EXP 50
109600: PUSH
109601: LD_VAR 0 1
109605: ARRAY
109606: NOT
109607: OR
109608: IFFALSE 108666
// MC_Reset ( base , 18 ) ;
109610: LD_VAR 0 1
109614: PPUSH
109615: LD_INT 18
109617: PPUSH
109618: CALL 21927 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
109622: LD_ADDR_VAR 0 2
109626: PUSH
109627: LD_VAR 0 2
109631: PUSH
109632: LD_VAR 0 2
109636: PPUSH
109637: LD_INT 2
109639: PUSH
109640: LD_INT 25
109642: PUSH
109643: LD_INT 1
109645: PUSH
109646: EMPTY
109647: LIST
109648: LIST
109649: PUSH
109650: LD_INT 25
109652: PUSH
109653: LD_INT 5
109655: PUSH
109656: EMPTY
109657: LIST
109658: LIST
109659: PUSH
109660: LD_INT 25
109662: PUSH
109663: LD_INT 8
109665: PUSH
109666: EMPTY
109667: LIST
109668: LIST
109669: PUSH
109670: LD_INT 25
109672: PUSH
109673: LD_INT 9
109675: PUSH
109676: EMPTY
109677: LIST
109678: LIST
109679: PUSH
109680: EMPTY
109681: LIST
109682: LIST
109683: LIST
109684: LIST
109685: LIST
109686: PPUSH
109687: CALL_OW 72
109691: DIFF
109692: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
109693: LD_VAR 0 3
109697: NOT
109698: PUSH
109699: LD_VAR 0 2
109703: PPUSH
109704: LD_INT 21
109706: PUSH
109707: LD_INT 2
109709: PUSH
109710: EMPTY
109711: LIST
109712: LIST
109713: PPUSH
109714: CALL_OW 72
109718: AND
109719: IFFALSE 110057
// begin tmp := FilterByTag ( defenders , 19 ) ;
109721: LD_ADDR_VAR 0 12
109725: PUSH
109726: LD_VAR 0 2
109730: PPUSH
109731: LD_INT 19
109733: PPUSH
109734: CALL 81800 0 2
109738: ST_TO_ADDR
// if tmp then
109739: LD_VAR 0 12
109743: IFFALSE 109813
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
109745: LD_ADDR_VAR 0 12
109749: PUSH
109750: LD_VAR 0 12
109754: PPUSH
109755: LD_INT 25
109757: PUSH
109758: LD_INT 3
109760: PUSH
109761: EMPTY
109762: LIST
109763: LIST
109764: PPUSH
109765: CALL_OW 72
109769: ST_TO_ADDR
// if tmp then
109770: LD_VAR 0 12
109774: IFFALSE 109813
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
109776: LD_ADDR_EXP 62
109780: PUSH
109781: LD_EXP 62
109785: PPUSH
109786: LD_VAR 0 1
109790: PPUSH
109791: LD_EXP 62
109795: PUSH
109796: LD_VAR 0 1
109800: ARRAY
109801: PUSH
109802: LD_VAR 0 12
109806: UNION
109807: PPUSH
109808: CALL_OW 1
109812: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
109813: LD_VAR 0 1
109817: PPUSH
109818: LD_INT 19
109820: PPUSH
109821: CALL 21927 0 2
// repeat wait ( 0 0$1 ) ;
109825: LD_INT 35
109827: PPUSH
109828: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109832: LD_EXP 50
109836: PUSH
109837: LD_VAR 0 1
109841: ARRAY
109842: NOT
109843: PUSH
109844: LD_EXP 50
109848: PUSH
109849: LD_VAR 0 1
109853: ARRAY
109854: PUSH
109855: EMPTY
109856: EQUAL
109857: OR
109858: IFFALSE 109895
// begin for i in defenders do
109860: LD_ADDR_VAR 0 5
109864: PUSH
109865: LD_VAR 0 2
109869: PUSH
109870: FOR_IN
109871: IFFALSE 109884
// ComStop ( i ) ;
109873: LD_VAR 0 5
109877: PPUSH
109878: CALL_OW 141
109882: GO 109870
109884: POP
109885: POP
// defenders := [ ] ;
109886: LD_ADDR_VAR 0 2
109890: PUSH
109891: EMPTY
109892: ST_TO_ADDR
// exit ;
109893: GO 110121
// end ; for i in defenders do
109895: LD_ADDR_VAR 0 5
109899: PUSH
109900: LD_VAR 0 2
109904: PUSH
109905: FOR_IN
109906: IFFALSE 109995
// begin if not IsInArea ( i , mc_parking [ base ] ) then
109908: LD_VAR 0 5
109912: PPUSH
109913: LD_EXP 74
109917: PUSH
109918: LD_VAR 0 1
109922: ARRAY
109923: PPUSH
109924: CALL_OW 308
109928: NOT
109929: IFFALSE 109953
// ComMoveToArea ( i , mc_parking [ base ] ) else
109931: LD_VAR 0 5
109935: PPUSH
109936: LD_EXP 74
109940: PUSH
109941: LD_VAR 0 1
109945: ARRAY
109946: PPUSH
109947: CALL_OW 113
109951: GO 109993
// if GetControl ( i ) = control_manual then
109953: LD_VAR 0 5
109957: PPUSH
109958: CALL_OW 263
109962: PUSH
109963: LD_INT 1
109965: EQUAL
109966: IFFALSE 109993
// if IsDrivenBy ( i ) then
109968: LD_VAR 0 5
109972: PPUSH
109973: CALL_OW 311
109977: IFFALSE 109993
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
109979: LD_VAR 0 5
109983: PPUSH
109984: CALL_OW 311
109988: PPUSH
109989: CALL_OW 121
// end ;
109993: GO 109905
109995: POP
109996: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
109997: LD_VAR 0 2
110001: PPUSH
110002: LD_INT 95
110004: PUSH
110005: LD_EXP 74
110009: PUSH
110010: LD_VAR 0 1
110014: ARRAY
110015: PUSH
110016: EMPTY
110017: LIST
110018: LIST
110019: PPUSH
110020: CALL_OW 72
110024: PUSH
110025: LD_VAR 0 2
110029: EQUAL
110030: PUSH
110031: LD_EXP 73
110035: PUSH
110036: LD_VAR 0 1
110040: ARRAY
110041: OR
110042: PUSH
110043: LD_EXP 50
110047: PUSH
110048: LD_VAR 0 1
110052: ARRAY
110053: NOT
110054: OR
110055: IFFALSE 109825
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
110057: LD_ADDR_EXP 72
110061: PUSH
110062: LD_EXP 72
110066: PPUSH
110067: LD_VAR 0 1
110071: PPUSH
110072: LD_VAR 0 2
110076: PPUSH
110077: LD_INT 21
110079: PUSH
110080: LD_INT 2
110082: PUSH
110083: EMPTY
110084: LIST
110085: LIST
110086: PPUSH
110087: CALL_OW 72
110091: PPUSH
110092: CALL_OW 1
110096: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
110097: LD_VAR 0 1
110101: PPUSH
110102: LD_INT 19
110104: PPUSH
110105: CALL 21927 0 2
// MC_Reset ( base , 20 ) ;
110109: LD_VAR 0 1
110113: PPUSH
110114: LD_INT 20
110116: PPUSH
110117: CALL 21927 0 2
// end ; end_of_file
110121: LD_VAR 0 4
110125: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
110126: LD_VAR 0 1
110130: PUSH
110131: LD_INT 200
110133: DOUBLE
110134: GREATEREQUAL
110135: IFFALSE 110143
110137: LD_INT 299
110139: DOUBLE
110140: LESSEQUAL
110141: IFTRUE 110145
110143: GO 110177
110145: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; end ;
110146: LD_VAR 0 1
110150: PPUSH
110151: LD_VAR 0 2
110155: PPUSH
110156: LD_VAR 0 3
110160: PPUSH
110161: LD_VAR 0 4
110165: PPUSH
110166: LD_VAR 0 5
110170: PPUSH
110171: CALL 99059 0 5
110175: GO 110178
110177: POP
// end ;
110178: PPOPN 11
110180: END
